         TITLE 'TSO/E HELP ISPF DIALOG'
***********************************************************************
*                                                                     *
* NAME:      TSOHELP                                                  *
*                                                                     *
* ACKNOWLEDGEMENT AND THANKS:                                         *
*            THIS MODULE WAS INSPIRED BY THE TSOEHELP CLIST WRITTEN   *
*            BY BOB ZIMMERMAN AND FOUND ON THE GUIDE ISPF TAPE.       *
*                                                                     *
* FUNCTION:  TO PROVIDE THE ISPF USER WITH SIMPLE ASSISTANCE IN       *
*            EXECUTING A TSO COMMAND BY ALLOWING THE TSO HELP INFO    *
*            TO BE ON THE COMMAND PANEL WITH THE COMMAND ENTRY LINE.  *
*                                                                     *
* FLOW:      1) ENTERED AS AN ISPF DIALOG WITH A PARM WHICH IDENTIFIES*
*            THE NAME OF THE TSO COMMAND WHOSE HELP IS DESIRED.       *
*                                                                     *
*            2) SUBROUTINES KDSNSUB AND KMEMSUB ARE USED TO           *
*               LOCATE THE TSO HELP MEMBER.                           *
*                                                                     *
*            3) AN ISPF TABLE IS CREATED WHERE EACH RECORD OF THE     *
*               TABLE IS A RECORD OF THE HELP MEMBER.                 *
*                                                                     *
*            4) THE TABLE IS DISPLAYED USING THE ISPF TBDISPL SERVICE *
*               USING PANEL TSOHELP.   AN INPUT FIELD IS INITIALIZED  *
*               WITH THE NAME OF THE COMMAND AND THE USER MAY NOW     *
*               ENTER THE DESIRED OPERANDS FOR THE COMMAND.           *
*                                                                     *
*            5) USER SPECIFIED OPTIONS:                               *
*               C - DISPLAY SPECIFIED SUBCOMMAND OR IF NO SUBCOMMAND  *
*                   IS SPECIFIED THE SCROLL TO FIRST/NEXT SUBCOMMAND. *
*                   (E.G. C SUBCMD)                                   *
*               E - EXECUTE THE GENERATED TSO COMMAND.                *
*               F - SCROLL TO FUNCTION FOR COMMAND.                   *
*               O - SCROLL TO OPERANDS FOR COMMAND.                   *
*                   IF A OPERAND IS SPECIFIED THEN THE SCREEN IS      *
*                   SCROLLED TO IT.                                   *
*                   (E.G. O OPER1 )                                   *
*               S - SCROLL TO SYNTAX FOR COMMAND.                     *
*             TOP - SCROLL TO THE FIRST LINE.               *LBD 03/86*
*              SC - SCROLL TO LIST OF SUBCOMMANDS.          *LBD 03/86*
*               M - SCROLL TO MESSAGE                       *LBD 01/87*
*                                                                     *
*                                                                     *
*            6) ONCE THE USER HAS COMPLETED THE ENTRY OF THE COMMANDS *
*               OPERANDS, THE COMMAND MAY BE EXECUTED.  AFTER THE     *
*               COMMAND EXECUTES THE USER IS RETURNED TO THE TSOHELP  *
*               PANEL.                                                *
*                                                                     *
*              OR                                                     *
*                                                                     *
*            6) IF THE FIRST BYTE OF THE PARM IS X'FF' THEN DISPLAY   *
*               THE PANEL WHICH DOES NOT ALLOW EXECUTION AS IT IS     *
*               FOR A SUBCOMMAND  OF THE ACTIVE COMMAND PROCESSOR.    *
*                                                                     *
*---------------------------------------------------------------------*
* CHANGE HISTORY:                                                     *
*              CHANGE TO IGNORE HELP RECORDS WITH '*' IN COLUMN 1.    *
*              LBD 11/14/85                                           *
*                                                                     *
*              REMOVED USE OF DYNALLOC TO GET UNIQUE TABLE NAME -     *
*              NOW I USE THE TIME.      LBD 11/18/85                  *
*                                                                     *
*              ALLOW SPECIFICATION OF A SUB-COMMAND AS WELL. LBD 2/86 *
*                                                                     *
*              SUPPORT SUBCOMMANDS OF ACTIVE TSO COMMAND.  LBD 3/86   *
*                                                                     *
*              ADDED TOP COMMAND.   LBD 3/86                          *
*                                                                     *
*              ADDED SC COMMAND.    LBD 3/86                          *
*                                                                     *
*              ADDED M OPTION.      LBD 1/87                          *
*                                                                     *
*              CHANGED TO USE KDSNSUB AND KMEMSUB INSTEAD  *LBD 07/88*
*                OF ISPF LIBRARY MANAGEMENT.               *LBD 07/88*
*                                                                     *
*              JULY 11, 1988    L.B. DYCK                             *
*              CHANGED TO RESCAN FROM THE TOP ON A NOT                *
*                FOUND CONDITION FOR SCAN'S.                          *
*                                                                     *
*---------------------------------------------------------------------*
* NOTES:       TO USE THE ISPF COMMAND TABLE MUST BE UPDATED.         *
*                                                                     *
*              VERB      T   ACTION                                   *
*              TSOHELP   0   SELECT PGM(TSOHELP) PARM(&ZPARM)         *
*                                                                     *
*                                                                     *
*---------------------------------------------------------------------*
* DEPENDENCIES:  ISPF VERSION 2                                       *
*                                                                     *
*                AVAILABILITY OF THE GUIDE ISPF PROJECTS ASSEMBLER    *
*                MACROS AND KSUBS ROUTINES.                           *
*                                                                     *
*                MUST ASSEMBLE WITH CSECT KSUBS...                    *
*                                                                     *
*---------------------------------------------------------------------*
* AUTHOR:      LIONEL DYCK                                            *
*              ROCKWELL INTERNATIONAL                                 *
*              PO BOX 2515                                            *
*              2201 SEAL BEACH BLVD.                                  *
*              SEAL BEACH, CALIF  90740                               *
*              MAIL CODE 110-SH28                                     *
*              PHONE (213) 594-1125                                   *
*              COMNET 374-1125                                        *
***********************************************************************
         EJECT
TSOHELP $PROLOG R11,R12
         EJECT
         TM    0(R1),X'80'         * BATCH PARM ..?         *LBD 06/88*
         BO    BATCH               * YES                    *LBD 06/88*
*                                                           *LBD 06/88*
         L     1,0(1)              * LOAD ADDR OF PARM
         LH    2,0(1)              * LOAD LENGTH OF PARM
         LTR   2,2                 * LENGTH OF ZERO
         BZ    SETDEF              * NO PARM - SET DEFAULT
         BCTR  2,0                 * SUBTRACT LENGTH BY 1
         EX    2,MOVECMD           * EXECUTE THE MOVE
         B     STARTIT                                     *LBD 02/86*
         SPACE 1                                            *LBD 06/88*
BATCH    DS    0H                                           *LBD 06/88*
         L     R1,0(R1)            * LOAD ADDRESS OF PARM   *LBD 06/88*
         LH    R2,0(R1)            * LOAD LENGTH            *LBD 06/88*
         LTR   R2,R2               * LENGTH > 0             *LBD 06/88*
         BZ    SETDEF              * NO - SET DEFAULT       *LBD 06/88*
         BCTR  R2,R0               * LESS 1 FOR MVC         *LBD 06/88*
         EX    R2,MOVEPARM         * AND MOVE COMMAND       *LBD 06/88*
         MVC   COMMAND,SCMD        * AND MOVE IT AGAIN      *LBD 07/88*
         SETON BTCH                                         *LBD 06/88*
         B     STARTIT                                      *LBD 06/88*
         SPACE 2                                           *LBD 02/86*
SETDEF   MVC   SCMD(8),=CL8'COMMANDS'                      *LBD 02/86*
         MVC   HELPANEL,=CL8'TSOHELPS'                     *LBD 01/87*
         SETON SUBX,DEF                                    *LBD 01/87*
STARTIT  DS    0H                                          *LBD 02/86*
         EJECT
         ISPF  LOAD
         EJECT
         VDEFINE '(ZERRMSG RECORD DL)',ZERRMSG,CHAR,80
         EJECT
         VDEFINE '(ZTDTOP)',ZTDTOP,FIXED,4
         EJECT
         VDEFINE '(COMMAND)',COMMAND,CHAR,20
         EJECT
         VDEFINE '(CMD)',CMD,CHAR,240
         EJECT
         VDEFINE '(ID TABNAME)',TABNAME,CHAR,8
         EJECT
         VDEFINE '(ZEDSMSG)',ZEDSMSG,CHAR,16
         EJECT
         VDEFINE '(ZEDLMSG)',ZEDLMSG,CHAR,72
         EJECT
         TIME  DEC
         ST    R0,TIME            SAVE TIME
         OI    TIME+3,X'0F'                                *LBD 11/85*
         UNPK  TABNAME+1(7),TIME                           *LBD 11/85*
         EJECT
         CONTROL ERRORS,RETURN
         EJECT
         MVC   KDSNAMT,DSN#       SET UP # OF DSN'S IN TBL *LBD 07/88*
         CALL  KDSNSUB,                                    *LBD 07/88* X
               (DDNAME,           8 BYTE DDNAME REQUESTED  *LBD 07/88* X
               KDSNAMT,           RETURN THIS MANY DSNAMES *LBD 07/88* X
               DSNTABLE),         TABLE TO STORE DSN'S     *LBD 07/88* X
               VL,                SET BIT ON LAST PARM     *LBD 07/88* X
               MF=(E,SPFPARMS)    EXECUTE FORM OF MACRO    *LBD 07/88*
         LTR   R15,R15
         BZ    OK1
         EJECT
         SETMSG MSG=ZERRMSG
         B     EXIT12
         EJECT
OK1      DS    0H
         IFON  DEF,NOCMD                                    *LBD 07/88*
         LA    R1,COMMAND                                  *LBD 02/86*
         LA    R2,SCMD                                     *LBD 02/86*
         CLI   SCMD,X'FF'                                  *LBD 03/86*
         BNE   NOSUBX                                      *LBD 03/86*
         MVC   COMMAND,BLANKS                              *LBD 07/88*
         LA    R2,SCMD+1                                   *LBD 03/86*
         MVC   HELPANEL,=CL8'TSOHELPS'                     *LBD 03/86*
         SETON SUBX                                        *LBD 03/86*
         LA    R3,40                                       *LBD 02/86*
MCMD     MVC   0(1,R1),0(R2)                               *LBD 02/86*
         LA    R1,1(R1)                                    *LBD 02/86*
         LA    R2,1(R2)                                    *LBD 02/86*
         CLI   0(R2),C' '                                  *LBD 02/86*
         BE    DOSCMD                                      *LBD 02/86*
         BCT   R3,MCMD                                     *LBD 02/86*
DOSCMD   DS    0H                                          *LBD 02/86*
         LA    R2,1(R2)                                    *LBD 02/86*
         MVC   SUBCMD,BLANKS                                *LBD 07/88*
         LA    R1,SUBCMD                                   *LBD 02/86*
         LA    R3,20                                       *LBD 02/86*
SMCMD    CLI   0(R2),C' '         END OF SUB COMMAND       *LBD 02/86*
         BE    DOKMEM             YES                      *LBD 02/86*
         MVC   0(1,R1),0(R2)                               *LBD 02/86*
         LA    R1,1(R1)                                    *LBD 02/86*
         LA    R2,1(R2)                                    *LBD 02/86*
         BCT   R3,SMCMD                                    *LBD 02/86*
         B     DOKMEM                                       *LBD 06/88*
NOCMD    DS    0H                                           *LBD 07/88*
         MVC   COMMAND,SCMD                                 *LBD 07/88*
         B     DOKMEM                                       *LBD 07/88*
NOSUBX   DS    0H                                          *LBD 03/86*
         IFON  BTCH,DOKMEM        DO IT IF BATCH FLAG       *LBD 07/88*
         LA    R3,SCMD+4          -> START OF COMMAND       *LBD 06/88*
         LH    R1,SCMD            LOAD FULL LENGTH          *LBD 06/88*
         LH    R2,SCMD+2          LOAD OFFSET TO SUB COMMAND*LBD 06/88*
         SR    R1,R2              GET TRUE LEN              *LBD 06/88*
         BCTR  R1,R0              LESS 1 FOR EX             *LBD 06/88*
         AR    R3,R2              -> TRUE COMMAND           *LBD 06/88*
         EX    R1,MVCMD                                     *LBD 06/88*
DOKMEM   DS    0H                                           *LBD 06/88*
         OC    COMMAND,BLANKS     INSURE UPPER CASE
         CALL  KMEMSUB,                                    *LBD 07/88* X
               (COMMAND,          MEMBER TO FIND           *LBD 07/88* X
               KDSNAMT,           NUMBER OF DSN'S TO CHECK *LBD 07/88* X
               DSNTABLE),         TABLE OF VALID DSN'S     *LBD 07/88* X
               VL,                MARK LAST ENTRY          *LBD 07/88* X
               MF=(E,SPFPARMS)    EXECUTE FORM OF MACRO    *LBD 07/88*
         LTR   R15,R15
         BZ    OK2
         SETMSG MSG=ZERRMSG
         B     EXIT12
         EJECT
OK2      DS    0H
         CLC   KDSNAMT,=H'0'      FOUND ?                  *LBD 07/88*
         BNE   OK2OPEN                                     *LBD 07/88*
NOFIND   DS    0H                                          *LBD 07/88*
         SETMSG MSG=ZERRMSG
         B     EXIT12
         EJECT
OK2OPEN  DS    0H                                          *LBD 07/88*
         LA    R1,DSNTABLE        -> DSNAME TABLE          *LBD 07/88*
         LH    R2,DSN#            NUMBER OF DSNAMES        *LBD 07/88*
FINDDSN  DS    0H                                          *LBD 07/88*
         CLI   0(R1),C' '         BLANK ?                  *LBD 07/88*
         BNE   HAVEDSN            NO - GOT OUR DSN         *LBD 07/88*
         LA    R1,44(R1)          -> NEXT DSN              *LBD 07/88*
         BCT   R2,FINDDSN         AND CONTINUE SCAN        *LBD 07/88*
         SETMSG MSG=ZERRMSG       WE HAVE FAILED
         B     EXIT12
HAVEDSN  DS    0H                                          *LBD 07/88*
         ST    R1,HELPDSN                                  *LBD 07/88*
         ALLOC DSN=HELPDSN,       DSNAME THAT WE FOUND     *LBD 07/88* X
               DDNRET=HELPDDN,    LOCATION FOR DDNAME      *LBD 07/88* X
               DISP=SHR,          DISPOSITION OF SHR       *LBD 07/88* X
               MEMBER=MEMBER,     MEMBER NAME              *LBD 07/88* X
               ERROR=S99FAIL      FAIL IF NOT FOUND        *LBD 07/88*
         MVC   HELPDD+40(8),HELPDDN+2   SET UP OUR DDNAME  *LBD 07/88*
         EJECT                                             *LBD 07/88*
         OPEN  (HELPDD,INPUT)                              *LBD 07/88*
         EJECT
OK3      DS    0H
         SPACE 2
         VDEFINE '(TYPE)',TYPE,CHAR,40,'(COPY)'
         CONTROL ERRORS,CANCEL
         EJECT
         TBCREATE TABNAME,NAMES='(RECORD)',WRITE='NOWRITE',            X
               REPLACE='REPLACE'
         LTR   R15,R15
         BZ    DOGET
         SETMSG MSG=ZERRMSG
         FREE DDN=HELPDDN
         B     EXIT12
         EJECT
DOGET    DS    0H
         GET   HELPDD                                      *LBD 07/88*
         MVC   RECORD(72),0(R1)   MOVE RECORD              *LBD 07/88*
DOADD    DS    0H
         CLI   RECORD,C'*'        COMMENT RECORD ?         *LBD 11/85*
         BE    DOGET              YES - SKIP IT.           *LBD 11/85*
         TBADD TABNAME
         B     DOGET                                       *LBD 07/88*
         EJECT
DISPL1   DS    0H
         CLOSE (HELPDD,FREE)
         MVC   RECORD,=CL80' '
         MVC   CMD(8),COMMAND
         TBADD TABNAME
         TBTOP TABNAME
         EJECT
         VDEFINE '(ZVERB)',ZVERB,CHAR,8
         VDEFINE '(ZSCROLLN)',ZSCROLLN,CHAR,4
         CLI   SUBCMD,C' '        ANY SUB COMMAND ?        *LBD 02/86*
         BE    DISPL              NO                       *LBD 02/86*
         CLC   =C'M(',SUBCMD       IS IT A MSG REQUEST ?   *LBD 01/87*
         BE    DOSMSG              YES                     *LBD 01/87*
         CLC   =C'MSGID(',SUBCMD   IS IT A MSG REQUEST ?   *LBD 01/87*
         BE    DOSMSGL             YES                     *LBD 01/87*
         MVI   TYPE,C'C'                                   *LBD 02/86*
         MVC   TYPE+2(20),SUBCMD                           *LBD 01/87*
         MVC   CMD(20),SCMD                                *LBD 02/86*
         B     DOSUB                                       *LBD 02/86*
         EJECT                                             *LBD 01/87*
DOSMSG   DS    0H                                          *LBD 01/87*
         LA    R1,SUBCMD+2         -> MSG ID               *LBD 01/87*
         B     DOSMSGS             GO SCAN FOR EOM         *LBD 01/87*
DOSMSGL  LA    R1,SUBCMD+6         -> MSG ID               *LBD 01/87*
         SPACE 1                                           *LBD 01/87*
DOSMSGS  DS    0H                                          *LBD 01/87*
         MVC   HELPANEL,=CL8'TSOHELPS' NO EXEC DISPLAY     *LBD 01/87*
         MVC   RECORD(2),=C'))'                            *LBD 01/87*
         LA    R2,RECORD+2                                 *LBD 01/87*
DOSMSGLP DS    0H                                          *LBD 01/87*
         CLI   0(R1),C' '          EOM                     *LBD 01/87*
         BE    DOSMSGE             YES                     *LBD 01/87*
         CLI   0(R1),C')'          EOM                     *LBD 01/87*
         BE    DOSMSGE             YES                     *LBD 01/87*
         MVC   0(1,R2),0(R1)                               *LBD 01/87*
         OI    0(R2),C' '          INSURE UPPER CASE       *LBD 01/87*
         LA    R1,1(R1)            BUMP SUBCMD/MSG ->      *LBD 01/87*
         LA    R2,1(R2)            BUMP TYPE ->            *LBD 01/87*
         B     DOSMSGLP            AND KEEP MOVING         *LBD 01/87*
DOSMSGE  MVI   0(R2),C'*'                                  *LBD 01/87*
         SETON TOP                                         *LBD 01/87*
         B     DOSCAN                                      *LBD 01/87*
         EJECT                                             *LBD 01/87*
DOTOP    DS    0H                                          *LBD 03/86*
         TBTOP TABNAME
         SETOF MSG,OPS                                     *LBD 01/87*
         EJECT                                             *LBD 02/86*
DISPL    DS    0H
         TBDISPL TABNAME,PANEL=HELPANEL
DISPL2   DS    0H
         LTR   R15,R15
         BNZ   EXIT
         TBSKIP TABNAME,NUMBER=ZTDTOP
         CLI   ZVERB,C' '
         BE    CKCMD
         CLC   ZVERB(2),=C'UP'
         BNE   DOSKIP
         MVI   MINUS,C'-'
DOSKIP   TBSKIP TABNAME,NUMBER=MINUS
         MVI   MINUS,C' '
         B     DISPL
         EJECT
CKCMD    DS    0H
         SETOF SCAN                                         *LBD 07/88*
         CLC   =CL2'E',TYPE
         BE    DOCMD
         CLC   =CL2'C',TYPE     SUB COMMAND
         BE    DOSUB
         CLC   =C'SC ',TYPE       SUB COMMAND LIST ?       *LBD 03/86*
         BE    DOSUBL                                      *LBD 03/86*
         CLC   =CL2'S',TYPE     FIND SYNTAX
         BE    DOSYN
         CLC   =CL2'X',TYPE     FIND SYNTAX
         BE    DOSYN
         CLC   =CL2'F',TYPE     FIND FUNCTION
         BE    DOFUN
         CLC   =CL2'O',TYPE     OPER FUNCTION
         BE    DOOPER
         CLC   =C'TOP ',TYPE      TOP OF TABLE             *LBD 03/86*
         BE    DOTOP                                       *LBD 03/86*
         SPACE 1                                           *LBD 01/87*
         CLC   =CL2'M',TYPE        MESSAGE FUNCTION        *LBD 01/87*
         BE    DOMSG                                       *LBD 01/87*
DISPX    DS    0H
         TBDISPL TABNAME
         B     DISPL2
         EJECT
DOSUB    DS    0H
         SETOF OPS,MSG                                     *LBD 01/87*
         CLC   =CL20'C',TYPE
         BE    DOSUBS
         MVC   RECORD,BLANKS
         MVI   RECORD,C'='
         MVC   RECORD+1(39),TYPE+2
         LA    R1,RECORD+39
         LA    R2,38
SLCLC    CLI   0(R1),C' '         LAST BLANK
         BNE   SLAST              YES
         BCTR  R1,R0              LESS 1
         BCT   R2,SLCLC
         B     DISPX
SLAST    MVI   1(R1),C'*'
         SETON TOP                                         *LBD 03/86*
         B     DOSCAN
DOSUBS   DS    0H
         MVC   RECORD,BLANKS
         MVC   RECORD(2),=C'=*'
         B     DOSCAN
         SPACE 2
DOSUBL   DS    0H
         MVC   RECORD,BLANKS
         MVC   RECORD(4),=C')S *'
         B     DOSCAN
         SPACE 2
DOSYN    DS    0H
         SETOF OPS,MSG                                     *LBD 01/87*
         MVC   RECORD,BLANKS
         MVC   RECORD(4),=C')X *'
         B     DOSCAN
         SPACE 2
DOFUN    DS    0H
         SETOF OPS,MSG                                     *LBD 01/87*
         MVC   RECORD,BLANKS
         MVC   RECORD(4),=C')F *'
         B     DOSCAN
         SPACE 2
DOOPER   DS    0H
         SETOF MSG                                         *LBD 01/87*
         CLC   =CL20'O',TYPE      OPERAND SPECIFIED ?
         BE    DOOPS
         MVC   RECORD,BLANKS
         MVC   RECORD(2),=C'))'
         MVC   RECORD+2(38),TYPE+2
         LA    R1,RECORD+39
         LA    R2,38
         SETON OPS                                         *LBD 01/87*
         B     SLCLC
DOOPS    DS    0H
         IFON  OPS,DONEXTOM                                *LBD 01/87*
         MVC   RECORD,BLANKS
         MVC   RECORD(4),=C')O *'
         SETON OPS                                         *LBD 01/87*
         B     DOSCAN
DONEXTOM DS    0H                                          *LBD 01/87*
         MVC   RECORD,BLANKS                               *LBD 01/87*
         MVC   RECORD(3),=C'))*'                           *LBD 01/87*
         B     DOSCAN                                      *LBD 01/87*
         SPACE 2                                           *LBD 01/87*
DOMSG    DS    0H                                          *LBD 01/87*
         SETOF OPS                                         *LBD 01/87*
         CLC   =CL20'M',TYPE      OPERAND SPECIFIED ?      *LBD 01/87*
         BE    DOMSGS                                      *LBD 01/87*
         MVC   RECORD,BLANKS                               *LBD 01/87*
         MVC   RECORD(2),=CL2'))'                          *LBD 01/87*
         MVC   RECORD+2(38),TYPE+2                         *LBD 01/87*
         LA    R1,RECORD+39                                *LBD 01/87*
         LA    R2,38                                       *LBD 01/87*
         SETON MSG                                         *LBD 01/87*
         B     SLCLC                                       *LBD 01/87*
DOMSGS   DS    0H                                          *LBD 01/87*
         IFON  MSG,DONEXTOM                                *LBD 01/87*
         MVC   RECORD,BLANKS                               *LBD 01/87*
         MVC   RECORD(3),=C')M '                           *LBD 01/87*
         SETON MSG,TOP                                     *LBD 01/87*
         B     DOSCAN                                      *LBD 01/87*
         EJECT
DOSCAN   DS    0H
         IFOFF TOP,NOTOP                                   *LBD 03/86*
         TBTOP TABNAME                                     *LBD 03/86*
NOTOP    DS    0H                                          *LBD 03/86*
         SETOF TOP                                         *LBD 03/86*
         VPUT  '(RECORD)'
         TBSCAN TABNAME,ARGLIST='(RECORD)',DIRECTION='NEXT'
         LTR   R15,R15
         BZ    DISPL
         IFON  SCAN,NFOUND        NOT FOUND                *LBD 07/88*
         SETON TOP,SCAN                                    *LBD 07/88*
         B     DOSCAN                                      *LBD 07/88*
NFOUND   DS    0H                                          *LBD 07/88*
         SETOF SCAN                                        *LBD 07/88*
         MVC   ZNFDATA,RECORD                              *LBD 01/87*
         VPUT  '(ZEDSMSG ZEDLMSG)'
         SETMSG MSG='ISRZ000'
         B     DISPL
         EJECT
DOCMD    DS    0H
         IFON  SUBX,DISPL         IGNORE ???               *LBD 03/86*
         CONTROL DISPLAY,LINE,10
         SELECT  CMDLEN,TSOCMD
         B     DISPL
         EJECT
EXIT     DS    0H
         TBEND TABNAME
         ISPF  DELETE
         $EPILOG 0
         EJECT
EXIT12   DS    0H
         ISPF  DELETE
         $EPILOG 12
         EJECT
         ISPF  PARMS,             MINIMUM OF               *LBD 07/88* X
               MINIMUM=5             5F IN PARMLIST        *LBD 07/88*
         SPACE 2
         DYNSPACE ,                                        *LBD 07/88*
         LTORG
         EJECT
S99FAIL  DS    0H                                          *LBD 07/88*
         S99FAIL                                           *LBD 07/88*
         B     EXIT12                                      *LBD 07/88*
         EJECT
         BITSW SUBX,TOP,MSG,OPS,BTCH,SCAN,DEF              *LBD 07/88*
         SPACE 2                                           *LBD 03/86*
HELPANEL DC    CL8'TSOHELP'                                *LBD 03/86*
TIME     DS    F                                           *LBD 11/85*
ZVERB    DC    CL8' '
MINUS    EQU   ZSCROLLN
ZSCROLLN DC    CL4' '
ZERRMSG  DC    CL80' '
RECORD   DC    CL80' '
DL       DC    CL80' '
TSOCMD   DC    C'CMD('
CMD      DC    CL240' '
         DC    C')'
CMDLEN   DC    A(L'CMD+5)
TYPE     DC    CL40' '
SAVETYPE DC    CL8' '
ID       DC    CL8' '
TABNAME  DC    CL8'D'
COMMAND  DC    CL8' '
SUBCMD   DC    CL8' '                                      *LBD 02/86*
BLANKS   DC    CL80' '
SCMD     DC    CL60' '
MOVECMD  MVC   SCMD(0),0(1)            *** EXECUTED INSTRUCTION
MOVEPARM MVC   SCMD(0),2(R1)           *** EXECUTED INSTRUCTION
MVCMD    MVC   COMMAND(0),0(R3)   *** EXECUTED              *LBD 06/88*
ZTDTOP   DC    F'0'
ZEDSMSG  DC    CL16'*NOT FOUND*'
ZEDLMSG  DC    CL72' '
         ORG   ZEDLMSG
         DC    C'SCAN='                                    *LBD 01/87*
ZNFDATA  DC    CL60' '                                     *LBD 01/87*
         ORG   ,
DDNAME   DC    CL8'SYSHELP'                                *LBD 07/88*
HELPDSN  DC    A(0),AL2(44)                                *LBD 07/88*
MEMBER   DC    A(COMMAND),AL2(8)                           *LBD 07/88*
KDSNAMT  DS    H                  AMOUNT FIELD FOR KDSNSUB *LBD 07/88*
DSN#     DC    H'30'              AMOUNT OF DSN'S FOR TBL  *LBD 07/88*
DSNTABLE DS    30CL44             TABLE OF DSN'S FOR KDSNSUB
         EJECT                                             *LBD 07/88*
HELPDD   DCB   DSORG=PS,MACRF=GL,DDNAME=DUMMY,EODAD=DISPL1 *LBD 07/88*
         EJECT                                             *LBD 07/88*
         IEFZB4D0                                          *LBD 07/88*
         EJECT                                             *LBD 07/88*
         IEFZB4D2                                          *LBD 07/88*
         END
***********************************************************************
*    BOB ZIMMERMAN                                                    *
*    CNA INSURANCE                                                    *
*    (312) 822-5719                                                   *
*    LAST MODIFIED 8412                                               *
*                                                                     *
***********************************************************************
*                                                                     *
*    WRITTEN AND MAINTAINED BY BRUCE LOMAR, BOB ZIMMERMAN             *
*    CNA INSURANCE                                                    *
*                                                                     *
***********************************************************************
*    THIS MODULE IS CALLED BY MANY DIALOGS AT CNA - CNA0KED FOR       *
*    EXAMPLE. IT WILL SEARCH THE TIOT AND UCBS TO FIND DATASETS       *
*    ALLOCATED, CONTAINS CERTAIN MEMBERS AND DDNAMES.                 *
***********************************************************************
*                                                                     *
*  AUTHORS AND DATES:                                                 *
*                                                                     *
*      MIKE AMLING - ORIGINAL CODE                       ??/??/80 N/A *
*                                                                     *
*                                                                     *
*  MAINTENANCE SUMMARY:                                               *
*                                                                     *
*    MIKE AMLING - REVISE TO USE &INUSE(13)               5/ 5/83 MA01*
*                                                                     *
*                                                                     *
***********************************************************************
         MACRO
         RF
         GBLB  &INUSE(13)                                         MA01
         GBLC  &EQU(12),&USING(12)
         LCLA  &A,&X
         LCLC  &C
&X       SETA  N'&SYSLIST
.LOOPX   AIF   (&X LE 0).MEXIT
&C       SETC  '&SYSLIST(&X)'
&X       SETA  &X-1
         AIF   ('&C' EQ '').LOOPX      SKIP NULL ENTRIES
.*
.*  FREE THE REGISTER CURRENTLY IN USE AS &C
.*
&A       SETA  2                       LOWEST SUPPORTED REGISTER - 1
.LOOPA   AIF   (&A GE 12).ERRINUS      12 IS HIGHEST SUPPORTED REGISTER
&A       SETA  &A+1
         AIF   ('&EQU(&A)' NE '&C').LOOPA
.*
&INUSE(&A) SETB 0                      INDICATE REG NO LONGER IN USE
&EQU(&A) SETC  ''                      RESET FOR LATER RF MACROS
         AIF   ('&USING(&A)' EQ '').LOOPX
&USING(&A) SETC ''
         DROP  &C                                                     $
         AGO   .LOOPX
.*
.* ERROR MNOTES
.*
.ERRINUS MNOTE 4,'REGISTER &C NOT IN USE.'
         AGO   .LOOPX
.MEXIT   MEND
***********************************************************************
*                                                                     *
*  AUTHORS AND DATES:                                                 *
*                                                                     *
*      MIKE AMLING - ORIGINAL CODE                       ??/??/80 N/A *
*                                                                     *
*                                                                     *
*  MAINTENANCE SUMMARY:                                               *
*                                                                     *
*    MIKE AMLING - REVISE TO USE &INUSE(13)               5/ 5/83 MA01*
*                                                                     *
*                                                                     *
***********************************************************************
         MACRO
         RG    &S,&T
         GBLB  &INUSE(13)                                         MA01
         GBLC  &EQU(12),&USING(12)
         LCLA  &A
         LCLC  &C
         AIF   (N'&SYSLIST LE 2).MULTIX
         MNOTE 8,'ALL BUT FIRST 2 POSITIONAL PARAMETERS IGNORED.'
.MULTIX  AIF   (T'&T NE 'O').PAIR
         AIF   ('&S(3)' NE '').SPEC
.*
.*  SEARCH FOR 1 AVAILABLE REGISTER
.*
&A       SETA  2                ONE LESS THAN LOWEST SUPPORTED REGISTER
.LOOP1   ANOP                                                     MA01
&A       SETA  &A+1
         AIF   (&INUSE(&A)).LOOP1
         AIF   (&A GT 12).ERRNORE      IF 3..12 NOT AVAILABLE     MA01
.*
.*  SET UP LONE REGISTER OR EVEN REGISTER OF PAIR
.*
.TAKEA   ANOP
&INUSE(&A) SETB 1                      NOTE REGISTER IN USE
&EQU(&A) SETC  '&S(1)'                 NOTE NAME FOR RF MACRO
&C       SETC  '&S(1)       '(1,8)
         MNOTE *,'&C EQU   &A'
&S(1)    EQU   &A                      DEFINE SYMBOL FOR REGISTER     $
         AIF   ('&S(2)' EQ '').MEXIT
         USING &S(2),&S(1)             TELL ASSEMBLER ABOUT CONTENTS  $
&USING(&A) SETC '&S(2)'                NOTE DSECT NAME FOR RCALL MACRO
.MEXIT   MEXIT
.*
.*  SEARCH FOR AN AVAILABLE EVEN/ODD REGISTER PAIR
.*
.PAIR    AIF   (N'&S LE 2 AND N'&T LE 2).PAIROVX
         MNOTE 8,'ASSIGNMENT OVERRIDE IGNORED WHEN REQUESTING PAIR.'
.PAIROVX ANOP
&A       SETA  3                       ODD REG OF 1ST PAIR - 2
.LOOP2   ANOP                                                     MA01
&A       SETA  &A+2
         AIF   (&INUSE(&A) OR &INUSE(&A-1)).LOOP2
         AIF   (&A GT 11).ERRNOPA   11 IS ODD REG OF HIGHEST PAIR MA01
.*
.*  SET UP ODD REGISTER OF PAIR
.*
&INUSE(&A) SETB 1                      NOTE REGISTER IN USE
&EQU(&A) SETC  '&T(1)'                 NOTE ODD REG NAME FOR RF MACRO
&C       SETC  '&T(1)       '(1,8)
         MNOTE *,'&C EQU   &A'
&T(1)    EQU   &A                      DEFINE SYMBOL FOR REGISTER     $
&A       SETA  &A-1                    PRESET FOR DEFINING EVEN REG
         AIF   ('&T(2)' EQ '').TAKEA
&USING(&A+1) SETC '&T(2)'              NOTE DSECT NAME FOR RCALL MACRO
         USING &T(2),&T(1)             TELL ASSEMBLER ABOUT CONTENTS  $
         AGO   .TAKEA
.*
.*  CHECK USER-SPECIFIED REGISTER
.*
.SPEC    ANOP
&A       SETA  K'&S(3)
.SPCLOOP AIF   (&A LE 0).SPCOK
         AIF   ('&S(3)'(&A,1) LT '0').ERRSPEC
&A       SETA  &A-1
         AGO   .SPCLOOP
.SPCOK   ANOP
&A       SETA  &S(3)
         AIF   (&A LT 3 OR &A GT 12).ERRS312
         AIF   (NOT &INUSE(&A)).TAKEA
         AIF   ('&EQU(&A)' EQ '').ERRINU2
         MNOTE 12,'SPECIFIED REGISTER &A IN USE AS &EQU(&A)'
         MEXIT
.ERRINU2 MNOTE 12,'SPECIFIED REGISTER &A IN USE BY CALLING CODE'
         MEXIT
.ERRSPEC MNOTE 8,'SPECIFIED REGISTER &S(3) NOT NUMERIC.'
         MEXIT
.ERRS312 MNOTE 8,'SPECIFIED REGISTER NOT IN RANGE 3-12.'
         MEXIT
.ERRNOPA MNOTE 8,'NO REGISTER PAIR AVAILABLE.'
         MEXIT
.ERRNORE MNOTE 8,'NO REGISTER AVAILABLE.'
         MEND
         MACRO
         CNASEND
         GBLC  &GBLSTRG                NAME OF STORAGE LENGTH
         GBLC  &GBLSAVE                NAME OF SAVE AREA
         GBLC  &GBLCNAM                NAME OF CSECT
         GBLC  &GBLRENT                REENTRANCY OPTION
         AIF   ('&GBLRENT' EQ 'NO' OR '&GBLRENT' EQ 'NOSAVE').DONE
         AIF   ('&SYSECT' EQ '&GBLSAVE').GEN
         SPACE 1
&GBLSAVE DSECT ,                       RESUME SAVE AREA DSECT
.GEN     ANOP
         SPACE 1
WORKEND$ DS    0D                      FORCE LENGTH TO DOUBLEWORD
&GBLSTRG EQU   WORKEND$-&GBLSAVE       SET UP LENGTH EQUATE
         SPACE 2
&GBLCNAM CSECT ,                       RESUME CSECT
.DONE    ANOP
         MEND
         MACRO
         CNASTRG
         GBLC  &GBLRENT
         GBLC  &GBLSAVE
         GBLC  &GBLWTG
         GBLC  &GBLCESV            DEFINES SAVE AREA FOR NSL'S
         AIF   ('&GBLRENT' EQ 'NO').DONE
         AIF   ('&GBLRENT' EQ 'NOSAVE').DONE
*
*        WORK AREA DSECT BEGINNING WITH CNASTRG MACRO GENERATION
*
&GBLSAVE DSECT
         DS    18F                 STANDARD SAVE AREA
         AIF   ('&GBLRENT' NE 'STACK' AND '&GBLRENT' NE 'NEWSTACK').CCH
         DS    F                   NEXT FREE STACK LOCATION
         AGO   .DONE
.CCH     AIF   ('&GBLRENT' NE 'COM' OR '&GBLWTG' EQ '').DONE
&GBLWTG  DS    F                   NEXT EXECUTION ADDRESS
.DONE    AIF   ('&GBLCESV' NE 'NSL').NONSL
         DS    F                   DUMMY FOR STAE EXIT ROUTINE
         DS    13F                 SAVE AREA FOR NSL ENTRY OPTION
.NONSL   ANOP
         MEND
         MACRO
&MNAME   CNAEXIT  &RC,&XCTL=,&SPKA=,&EXIT=YES
.*
.*       THIS MACRO PROVIDES A COMPANION EXIT MACRO TO
.*       THE ENTRY MACRO CNAENTER.
.*
.*
.*       DECLARE GLOBAL SYMBOLS USED FOR CNAENTER AND CNAEXIT
.*
         GBLA  &GBLREG#            NUMBER OF BASE REGISTERS
         GBLB  &GBLACTV            MACRO HAS BEEN INVOKED BEFORE
         GBLC  &GBLREGS(5)         BASE REGISTER VALUES
         GBLC  &GBLUSNG            BASE REGS WITH COMMAS FOR USING
         GBLC  &GBLRENT            RENT OPTION
         GBLC  &GBLSAVE            SNAME OPTION
         GBLC  &GBLSTRG            STORAGE OPTION
         GBLC  &GBLSTCK            SIZE OF STACK
         GBLC  &GBLCNAM            CSECT NAME
         GBLC  &GBLCESP            SUBPOOL FOR SAVEAREA FREEMAIN
         GBLC  &GBLCESV            SVC TYPE FOR RENT=(NEWSTACK,TYPE)
.*
.*       LOCAL VARIABLES
.*
         LCLA  &LCLBASE            NUMBER OF REG TO GEN R.C. HOLD
         LCLA  &LCLLOOP            LOOP CONTROL WHILE GENNING ABOVE
         LCLC  &LCLLABL            STATEMENT LABEL
         LCLC  &LCLRREG            CHARACTER FORM OF LCLBASE WITH R
         LCLC  &LCLXNAM            NAME TO XCTL TO
         LCLC  &LCLXLST            NAME OF XCTL PARM LIST
         LCLC  &LCLXREG            NAME OF REGISTER FOR MODULE ADDR
.*
.*       CHECK THE XCTL= OPERAND
.*       IT CANNOT BE USED WITH THE RC OPERAND
.*       THERE ARE THREE FORMS OF THE OPERAND
.*       XCTL=MODULE-NAME   (OBSOLETE VERSION)
.*       XCTL=(SF,PLIST-NAME,ROUTINE-ADDRESS-LOCATION)
.*       XCTL=(I,MODULE-NAME)
.*
         AIF   ('&XCTL' EQ '').XCTL1OK          NO XCTL= OPERAND
         AIF   ('&RC' EQ '').XCTL1A             NO RC OPERAND
         MNOTE 4,'RETURN CODE AND XCTL= INCOMPATIBLE. RETURN CODE IGNORE
               ED'
.XCTL1A  AIF   (N'&XCTL NE 1).XCTL1B
&LCLXNAM SETC  '&XCTL'                          SET MODULE NAME
         AGO   .XCTL1OK                         AND END CHECKS
.XCTL1B  AIF   ('&XCTL(1)' NE 'I').XCTL1C       IS IT INLINE PLIST
&LCLXNAM SETC  '&XCTL(2)'                       SET MODULE NAME
         AIF   (N'&XCTL NE 2).XCTL1E1           GENERATE ERROR MESSAGE
         AGO   .XCTL1OK
.XCTL1C  AIF   ('&XCTL(1)' NE 'SF' AND '&XCTL(1)' NE 'E').XCTL1E2
         AIF   ('&XCTL(2)' EQ '').XCTL1D        CHECK IF XCTL PLIST
&LCLXLST SETC  '&XCTL(2)'                       SET XCTL PARM LIST ADDR
.XCTL1D  AIF   ('&XCTL(3)' EQ '').XCTL1E        IS A REGISTER SET
&LCLXREG SETC  '&XCTL(3)'                       SET REGISTER NAME
.XCTL1E  AIF   (N'&XCTL GT 3).XCTL1E3           TOO MANY OPERANDS
         AGO   .XCTL1OK                         END CHECKS
.XCTL1E1 MNOTE 4,'XCTL=(I,PLIST-NAME) MUST HAVE 2 OPERANDS'
         AGO   .XCTL1OK
.XCTL1E2 MNOTE 4,'XCTL= FORMS ARE I AND E. XCTL=&XCTL(1) INVALID'
         AGO   .XCTL1OK
.XCTL1E3 MNOTE 4,'XCTL= TOO MANY OPERANDS'
.XCTL1OK ANOP
.*
.*       CHECK USAGE OF SPKA OPERAND
.*
         AIF   ('&SPKA' EQ '').SPKA1OK    NO SPKA= OPERAND
         AIF   ('&GBLCESV' NE '').SPKA1OK MUST BE RENT=(NEWSTACK,X)
         MNOTE 4,'SPKA=&SPKA VALID ONLY FOR RENT=(NEWSTACK,NSL)'
.SPKA1OK ANOP
.*
.***     CHECK USAGE OF THE EXIT=NO OPERAND
.*
         AIF   ('&EXIT' EQ 'YES').EXITOK
         AIF   ('&EXIT' EQ 'NO').EXITC1
         MNOTE 8,'EXIT=&EXIT VALUE INVALID'
.EXITC1  ANOP
         AIF   ('&XCTL' EQ '').EXITC2
         MNOTE 8,'EXIT=NO INVALID WITH XCTL=&XCTL'
.EXITC2  AIF   ('&RC' EQ '').EXITOK
         MNOTE 8,'EXIT=NO INVALID WITH RETURN CODE OPERAND &RC'
.EXITOK  ANOP
.*
.*       RESUME CSECT IF WE HAVE LEFT IT
.*
         AIF   ('&GBLCNAM' EQ '&SYSECT').READY
&GBLCNAM CSECT ,                   RESUME ORIGINAL CSECT
         SPACE 2
.READY   ANOP
.*
.*       SET STATEMENT LABEL
.*
&LCLLABL SETC  '&MNAME'
.*
.*       SET UP GLOBALS TO CAUSE DEFAULT IF CNAENTER NOT USED
.*
         AIF   (&GBLACTV).ACTIVE
&GBLRENT SETC  'NO'
&GBLSAVE SETC  'SAVEAREA'
         MNOTE 4,'CNAENTER NOT USED - WILL GENERATE FOR NON-REENTRANT'
.ACTIVE  ANOP
.*
.*       THERE ARE TWO FUNDAMENTAL CASES - 1 REQUIRING A FREEMAIN
.*       AND THE OTHER NOT.  THE FIRST CASE OCCURS WHEN &GBLRENT
.*       IS 'YES' OR 'NEWSTACK'.  THE OTHER OCCURS WHEN &GBLRENT
.*       IS 'NO' 'NOSAVE' 'STACK' OR 'COM'.  FIRST SECTION OF MACRO
.*       DETERMINES WHICH CASE IS PRESENT.
.*
         AIF   ('&GBLRENT' EQ 'YES' OR '&GBLRENT' EQ 'NEWSTACK').FREE
         AIF   ('&XCTL' NE '').GENXCTL
.*
.*       NOW GET THE RETURN CODE INTO R15 IF IT IS NOT IN 15 OR A
.*       SELF-DEFINING TERM.
.*
         AIF   ('&EXIT' EQ 'NO').NFRCSET    CASE - EXIT=NO
         AIF   ('&RC' EQ '0').NFRCSET       CASE - CNAEXIT 0 OPTIMIZE
         AIF   ('&XCTL' NE '').NFRCSET      CASE - XCTL OPERAND PRESENT
         AIF   ('&RC' EQ '').NFRCSET        CASE - NULL DEFAULT 0
         AIF   ('&RC' EQ '(R15)').NFRCSET   CASE - RC PRESET
         AIF   ('&RC' EQ '(15)').NFRCSET    CASE - RC PRESET
         AIF   ('&RC'(1,1) EQ '(').NFREG    CASE - REG FORM
         AIF   (T'&RC EQ 'N').NFRCSET       CASE - SELF-DEFINING
&LCLLABL L     R15,&RC             LOAD RETURN CODE VALUE
&LCLLABL SETC  ''                  NULIFY LABEL COPY
         AGO   .NFRCSET
.NFREG   ANOP
&LCLLABL LR    R15,&RC(1)          LOAD RETURN CODE VALUE
&LCLLABL SETC  ''
.*
.***     R15 LOADED UNLESS SR OR LA TO BE GENERATED
.*
.NFRCSET ANOP
.*
.*       RESTORE REGISTER 13 FOR NON-REENTRANT CASE
.*
         AIF   ('&GBLRENT' EQ 'NOSAVE').NFLR14
&LCLLABL L     R13,&GBLSAVE+4      RESTORE CALLER'S SAVE AREA
&LCLLABL SETC  ''
.*
.***     REENTER HERE FROM REENTRANT CASE
.*
.NFLR14  ANOP
         AIF   ('&RC' EQ '').NFLR14A           SKIP SUBSTRING IF NO PRM
         AIF   ('&RC'(1,1) EQ '(').NFLRN0      ALREADY LOADED IF REG.
         AIF   ('&EXIT' EQ 'NO' OR '&XCTL' NE '').NFLRN0
         AIF   ('&RC' NE '' AND T'&RC NE 'N').NFLRN0
.NFLR14A ANOP
&LCLLABL LM    R14,R12,12(R13)     RESTORE REGISTERS
         AIF   ('&RC' EQ '' OR '&RC' EQ '0').NFLRY0
         LA    R15,&RC             SET RETURN CODE NOT ZERO
         AGO   .NFLRN0A
.NFLRY0  ANOP
         SR    R15,R15             SET RETURN CODE ZERO
         AGO   .NFLRN0A
.*
.***     NEXT 2 INSTRUCTIONS IF RETURN CODE WAS LEFT IN R15
.*
.NFLRN0  ANOP
&LCLLABL L     R14,12(,R13)        RESTORE RETURN ADDRESS
         LM    R0,R12,20(R13)      RESTORE REMAINING REGISTERS
.NFLRN0A ANOP
         MVI   12(R13),X'FF'       FLAG AS RETURNED FOR SNAP SVC
         AIF   ('&EXIT' EQ 'NO').EXITNFN
         BR    R14                 RETURN TO CALLER
.EXITNFN ANOP
         MEXIT
.*
.*       REENTRANT CASE - FIRST GET RETURN CODE INTO A REGISTER
.*       WHICH IS NOT R15 AND IS NOT A BASE REGISTER.  DETERMINE
.*       WHICH REGISTER FIRST
.*
.FREE    AIF   ('&GBLCESV' NE '').GENNSL GO GENERATE SYSTEM CONV.
         AIF   ('&XCTL' NE '').FRSET   AVOID RETURN CODE LOGIC
&LCLRREG SETC  '&RC(1)'
         AIF   ('&RC' EQ '').FRNEED
         AIF   ('&RC'(1,1) EQ '(' AND '&RC' NE '(R15)').FRSET
.FRNEED  ANOP
&LCLBASE SETA  2
.FRCHECK ANOP
&LCLLOOP SETA  1
&LCLRREG SETC  'R&LCLBASE'
.FRLOOP  ANOP
         AIF   ('&LCLRREG' EQ '&GBLREGS(&LCLLOOP)').FRRETRY
&LCLLOOP SETA  &LCLLOOP+1
         AIF   (&LCLLOOP LE &GBLREG#).FRLOOP
         AGO   .FRLRC
.FRRETRY ANOP
&LCLBASE SETA  &LCLBASE+1
         AGO   .FRCHECK
.FRLRC   ANOP
         AIF   ('&EXIT' EQ 'NO').FRLR SAVE R15 AGAINST FREEMAIN
         AIF   ('&RC' EQ '0').FRSET  CASE - CNAEXIT 0 OPTIMIZED
         AIF   ('&XCTL' NE '').FRSET        CASE - XCTL= NO R15
         AIF   ('&RC' EQ '').FRSET          CASE - NULL DEFAULTS TO 0
         AIF   ('&RC'(1,1) EQ '(').FRLR     CASE - REGISTER OPERAND
         AIF   (T'&RC EQ 'N').FRSET         CASE - GENERATE LA INSTRUCT
&LCLLABL L     &LCLRREG,&RC        LOAD RETURN CODE VALUE
&LCLLABL SETC ''
         AGO   .FRSET
.FRLR    ANOP
&LCLLABL LR    &LCLRREG,&RC(1)     SAVE RETURN CODE OVER FREEMAIN
&LCLLABL SETC  ''
.FRSET   ANOP
&LCLLABL LR    R1,R13              SET ADDRESS TO FREE
&LCLLABL SETC  ''
         L     R13,&GBLSAVE+4      GET CALLER'S SAVE AREA
         AIF   ('&GBLRENT' EQ 'NEWSTACK').FRSTACK
 DC 0C'  FREEMAIN R,A=(1),LV=&GBLSTRG,SP=&GBLCESP' FREEMAIN ISSUED
         FREEMAIN R,A=(1),LV=&GBLSTRG,SP=&GBLCESP
         AGO   .NFSET15
.FRSTACK ANOP
 DC 0C'  FREEMAIN R,A=(1),LV=&GBLSTCK,SP=&GBLCESP' FREEMAIN ISSUED
         FREEMAIN R,A=(1),LV=&GBLSTCK,SP=&GBLCESP
.NFSET15 AIF   ('&XCTL' NE '').GENXCTL     GENERATE XCTL EXIT CODE
         AIF   ('&RC' EQ '' OR '&RC' EQ '0').NFLR14
         AIF   ('&RC'(1,1) EQ '(').FRSET15
         AIF   (T'&RC EQ 'N').NFLR14
.FRSET15 ANOP
         LR    R15,&LCLRREG        SET RETURN CODE INTO PROPER REG
         AGO   .NFLR14
.*
.*       GENERATE FOR RENT=(NEWSTACK,NSL),SPKA=
.*
.GENNSL  ANOP
&LCLLABL CNOP  0,4
&LCLLABL SETC  ''
         L     R0,*+8              LOAD SUBPOOL AND LENGTH
         B     *+8                 SKIP INLINE CONSTANT
         DC    AL1(&GBLCESP),AL3(&GBLSTCK)
         LA    R1,0(,R13)          POINT AT STACK
         LM    R2,R14,80(R13)      RESTORE OPEN/CLOSE/EOV REGS
         SVC   10                  ISSUE FREEMAIN SVC DIRECTLY
         AIF   ('&SPKA' EQ '').NSL1B
         SPKA  &SPKA               RETURN TO SUPERVISOR KEY
.NSL1B   AIF   ('&EXIT' EQ 'NO').MEND  IF EXIT=NO, GET OUT QUICKLY
         AIF   ('&LCLXREG' EQ '').NSL1C SKIP BRANCH TEST IF NOT REQ
         ICM   R15,15,&LCLXREG     CHECK FOR EP IN THIS LOAD MODULE
         BNZR  R15                 AND GO TO IT IF PRESENT
.NSL1C   AIF   ('&LCLXNAM' NE '').XCTL2B GEN INLINE LIST XCTL
   DC 0C'XCTL  SF=(E,&LCLXLST)'
         XCTL  SF=(E,&LCLXLST)
         MEXIT
.*
.*       GENERATE ERROR MESSAGE FOR RENT=(NEWSTACK,SVC6)
.*
.SVC6GEN AIF   ('&GBLCESV' NE 'SVC6').SVC5GEN TRY SVC15
         MNOTE 12,'RENT=(NEWSTACK,SVC6) NOT SUPPORTED BY CNAEXIT'
         MEXIT
.*
.*       GENERATE ERROR MESSAGE FOR RENT=(NEWSTACK,SVC15)
.*
.SVC5GEN AIF   ('&GBLCESV' NE 'SVC15').SVCXGEN TRY NEW PARM
         MNOTE 12,'RENT=(NEWSTACK,SVC15) NOT SUPPORTED BY CNAEXIT'
         MEXIT
.*
.*       GENERATE ERROR MESSAGE FOR UNRECOGNIZED &GBLCESV VALUE'
.*
.SVCXGEN MNOTE 12,'RENT=(NEWSTACK,&GBLCESV) NOT SUPPORTED BY CNAEXIT'
         MEXIT
.*
.*       GENERATE XCTL=(I,MODULE-NAME) VERSION OF XCTL
.*
.GENXCTL LM    R14,R12,12(R13)     RESTORE CALLERS REGISTERS
.XCTL2B  CNOP  2,4                 INSURE CONSTANT ALIGNMENT
         BALR  R15,0               SET NEW ADDRESSABILITY
         PUSH  USING               SAVE PREVIOUS ENVIRONMENT
         DROP  ,                   AVOID ADDRESSING PROBLEMS
         USING *,R15               AND TELL THE ASSEMBLER THE TRUTH
         L     R15,*+16            GET ADDRESS OF NEXT ROUTINE
         LTR   R15,R15             IS IT IN THIS MODULE
         BNZR  R15                 YES, GO TO IT DIRECTLY
         BALR  R15,0               NO, RESET ADDRESSABILITY
         USING *,R15               TELL THE ASSEMBLER AGAIN
         LA    R15,*+10            POINT AT XCTL SF= LIST
         XCTL  SF=(E,(15))         AND GO TO PROGRAM WITH ASSIST
         WXTRN &LCLXNAM            DECLARE AS WEAK EXTERNAL REFERENCE
         DC    A(&LCLXNAM)         IF LINKEDITED IN
         XCTL  EP=&LCLXNAM,SF=L    BUILD XCTL PARAMETER LIST
         POP   USING               GET USERS ENVIRONMENT BACK
.MEND    ANOP                        WAY TO BRANCH OUT
         MEND
         MACRO
&MNAME   CNAENTER  &BASES,         BASE REGISTER LIST                  X
               &CBASE=DR12,        REGISTER ADDRESSING COMMON          X
               &ENTRY=DYES,        GENERATE ENTRY STATEMENT (WITH NAME)X
               &ID=DYES,           FULL, NONE OR DATELESS ID           X
               &PARM=DR2,          WHERE TO PUT PARM LIST POINTER      X
               &PLOAD=,            HOW TO SET UP PARAMETER POINTERS    X
               &RENT=DYES,         REENTRANCY OR NOT AND TYPE          X
               &SAVE=YES,          SHOULD REGISTERS BE SAVED           X
               &SCLEAR=DNO,        SHOULD SAVE AREA BE CLEARED?        X
               &SNAME=,            NAME OF SAVE/WORK AREA              X
               &SP=,               SUBPOOL FOR SAVE AREA               X
               &SPKA=,             SET PROTECT KEY                     X
               &STACK=D2048,       SIZE OF STACK FOR NEWSTACK OPTION   X
               &STORAGE=DWORKLEN,  LENGTH OF STORAGE TO OBTAIN         X
               &WCLEAR=DNO,        SHOULD WORK AREA BE CLEARED?        X
               &WTG=D              WHERE TO GO FIELD NAME
.*
.*       DECLARE GLOBAL SYMBOLS USED FOR MULTIPLE INVOCATIONS AND
.*       THE CNAEXIT MACRO
.*
         GBLA  &GBLREG#            NUMBER OF BASE REGISTERS
         GBLA  &GBLQCNT            NUMBER OF Q ADDRESS CONSTANTS
         GBLB  &GBLACTV            MACRO HAS BEEN INVOKED BEFORE
         GBLB  &GBLSCLR            CLEAR SAVE AREA OPTION
         GBLB  &GBLWCLR            WORK AREA CLEAR OPTION
         GBLC  &GBLREGS(5)         BASE REGISTER VALUES
         GBLC  &GBLUSNG            BASE REGS WITH COMMAS FOR USING
         GBLC  &GBLID              ID OPTION
         GBLC  &GBLPARM            PARM OPTION
         GBLC  &GBLRENT            RENT OPTION
         GBLC  &GBLRSVE            SAVE REGISTERS OPTION (YES OR NO)
         GBLC  &GBLSAVE            SNAME OPTION
         GBLC  &GBLSTRG            STORAGE OPTION
         GBLC  &GBLSTCK            SIZE OF STACK
         GBLC  &GBLCNAM            CSECT NAME
         GBLC  &GBLQNAM(20)        UP TO 20 Q NAMES
         GBLC  &GBLWTG             WTG OPERAND OF 1ST ENTRY
         GBLC  &GBLCBAS            COMMON BASE REGISTER
         GBLC  &GBLCESP            SUBPOOL FOR GETMAIN AND FREEMAIN
         GBLC  &GBLCESV            SVC TYPE - SVCR6, SVCR15, NSL, NULL
         GBLC  &CNASPFL            LEVEL NUMBER FROM SPF LIBRARY
         GBLC  &CNASPFD            DATE OF LAST MODIFICATION
         GBLC  &CNASPFU            USERID OF LAST UPDATER
.*
.*       LOCAL SYMBOLS USED
.*
         LCLA  &LCLREG#            NUMBER OF ENTRIES IN &BASES
         LCLA  &LCLSUB1            DESTINATION SUBSCRIPT
         LCLA  &LCLSUB2            SOURCE SUBSCRIPT
         LCLA  &LCLIDSZ            SIZE OF ID CONSTANTS
         LCLA  &LCLIDLN            &LCLIDSZ-1
         LCLA  &LCLCONS            LENGTH OF ALL CONSTANTS
         LCLA  &LCLFILL            SIZE TO ALIGN SAVE AREA
         LCLA  &LCLWORK            ARITHMETIC WORK
         LCLA  &LCLPLUS            OFFSET CALCULATIONS
         LCLA  &LCLOFFS            OFFSET TO ENTRY OFFSET
         LCLA  &LCLSTRL            OFFSET TO STORAGE VALUE FOR STACKING
         LCLA  &LCLPRML            NUMBER OF VALUES TO PLOAD OPERAND
         LCLB  &LCLOFF             ON FOR 2ND-NTH ENTRIES
         LCLB  &LCLRENT            IS SOME FORM OF REENTRANCY IN?
         LCLB  &LCLENTR            IS ENTRY STATEMENT NEEDED?
         LCLB  &LCLSCLR            CLEAR SAVE AREA THIS ENTRY?
         LCLB  &LCLWCLR            CLEAR WORK AREA THIS ENTRY?
         LCLC  &LCLENAM            NAME FOR ENTRY STATEMENT
         LCLC  &LCLPARM            NAME FOR KEEPING R1
         LCLC  &LCLCHAR            CHARACTER WORK FIELD
         LCLC  &LCLSTRG            STORAGE THIS TIME THHROUGH
         LCLC  &LCLID              ID OPTION FOR THIS CALL
         LCLC  &LCLSVCT            SVC TYPE - SVCR6, SVCR15, NSL, NULL
         LCLC  &LCLTBAS            ENTRY POINT BASE FOR FIRST INSTRS.
.*
.*       IF THIS IS THE FIRST ENTRY, EDIT THE VALUES GIVEN
.*
         AIF   (&GBLACTV).NTH
&GBLACTV SETB  (1)               SET FOR NEXT TIME IN
&GBLCNAM SETC  '&SYSECT'           SET CSECT NAME
.*
.*       EDIT THE REENTRANCY OPTION  (FIRST SUBPARAMETER)
.*
         AIF   ('&RENT(1)' EQ 'DYES').DRENT
&LCLCHAR SETC  '&RENT(1)'
&LCLRENT SETB  ('&LCLCHAR' EQ 'YES'   OR '&LCLCHAR' EQ 'NEWSTACK' OR   *
                '&LCLCHAR' EQ 'STACK' OR '&LCLCHAR' EQ 'NOSAVE'   OR   *
                '&LCLCHAR' EQ 'COM')
         AIF   (&LCLRENT OR '&LCLCHAR' EQ 'NO').RENTOK
         MNOTE 4,'&RENT IS AN INVALID REENTRANCY OPTION - YES USED.'
.DRENT   ANOP
&GBLRENT SETC  'YES'
&LCLRENT SETB  (1)
         AGO   .RENTOVR
.RENTOK  ANOP
&GBLRENT SETC  '&RENT(1)'
.*
.*       EDIT THE WTG OPERAND IF &GBLRENT=COM
.*
         AIF   ('&GBLRENT' NE 'COM').RENTOVR
         AIF   ('&WTG' EQ 'D').RENTWTX     NO WTG TYPE PROCESSING
&GBLWTG  SETC  '&WTG'
         AIF   ('&GBLWTG' NE '').RENTWTX
         MNOTE *,'WTG OPERAND NULLIFIED - NO WTG CODE GENERATED'
.RENTWTX ANOP
         AIF   ('&CBASE' EQ 'DR12').DEFCBAS
         AIF   ('&CBASE' NE '').ASGNCBS
         MNOTE 8,'COMMON BASE NEEDED TO RELOCATE WORK AREA - R12 USED.'
.DEFCBAS ANOP
&GBLCBAS SETC  'R12'
         AGO   .RENTOVR
.ASGNCBS ANOP
&GBLCBAS SETC  '&CBASE'
.RENTOVR ANOP
.*
.*       EDIT THE SECOND RENT OPERAND.  THIS IS VALID ONLY IF THE
.*       RENT=NEWSTACK OPERAND IS CODED, AND MUST HAVE ONE OF THE
.*       VALUES 'SVCR6' 'SVCR15' 'NSL' OR NULL.
.*
&LCLTBAS SETC  'R15'                           ASSUME R15 AS ENTRY
         AIF   ('&RENT(2)' EQ '').RNT2END      NO SVC OPTION CODED
         AIF   ('&RENT(1)' NE 'NEWSTACK').RNT2E1 ERROR IF NOT NEWSTACK
         AIF   ('&RENT(2)' NE 'SVCR6' AND '&RENT(2)' NE 'SVCR15' AND   X
               '&RENT(2)' NE 'NSL').RNT2E2     NOT VALID ENTRYS
&GBLCESV SETC  '&RENT(2)'                      SET TYPE OF SVC ENTRY
&LCLSVCT SETC  '&RENT(2)'                      SET IT IN LOCAL
         AIF   ('&LCLSVCT' NE 'SVCR6').RNT2END R15 IS RIGHT
&LCLTBAS SETC  'R6'                            SET R6 AS ENTRY BASE
         AGO   .RNT2END
.RNT2E1  MNOTE 8,'SECOND RENT= OPERAND ONLY VALID WITH NEWSTACK'
         AGO   .RNT2END
.RNT2E2  MNOTE 8,'SECOND RENT= OPERAND MUST BE SVCR6, SVCR15, OR NSL'
.RNT2END ANOP
.*
.*       EDIT THE SPKA OPERAND.  IT IS ONLY VALID IF SECOND RENT
.*       OPTION IS USED.  IT IS USED ONLY IF SPECIFIED ON THE MACRO
.*
         AIF   ('&SPKA' EQ '').RNT3END
         AIF   ('&GBLCESV' NE '').RNT3END  SKIP IF 2ND RENT SPEC'D
         MNOTE 4,'SPKA= OPERAND NOT VALID IF 2ND RENT OPTION OMITTED'
.RNT3END ANOP
.*
.*       EDIT THE SAVE OPERAND.  THIS MUST BE YES UNLESS RENT=
.*       NO OR NOSAVE WAS ENTERED.  THEN IT MAY BE NO.
.*
&GBLRSVE SETC  'YES'                FORCE DEFAULT VALUE
         AIF ('&SAVE' EQ 'YES').RSAVEOK
         AIF ('&SAVE' NE 'NO').RSAVEX1
         AIF ('&GBLRENT' EQ 'NO' OR '&GBLRENT' EQ 'NOSAVE').RSAVEOK
         MNOTE 8,'SAVE=NO ONLY ALLOWED WITH RENT=NO OR RENT=NOSAVE'
         AGO   .RSAVEXL
.RSAVEX1 MNOTE 8,'SAVE= MUST BE YES OR NO'
         AGO   .RSAVEXL
.RSAVEOK ANOP
&GBLRSVE SETC  '&SAVE'
.RSAVEXL ANOP
.*
.*       EDIT THE STACK OPERAND - SHOULD BE D2048 UNLESS
.*       &GBLRENT=NEWSTACK.  IN THAT CASE, SET &GBLSTCK
.*       TO VALUE OF STACK OPERAND.  MULTIPLY BY 1024 IF
.*       ALL NUMERIC EXCEPT TERMINAL K.
.*
         AIF   ('&GBLRENT' EQ 'NEWSTACK').NSEDIT
         AIF   ('&STACK' EQ 'D2048').STACKX
         MNOTE 4,'STACK= IGNORED SINCE RENT=NEWSTACK NOT SPECIFIED'
         AGO   .STACKX
.NSEDIT  ANOP
&LCLWORK SETA  K'&STACK
         AIF   ('&STACK'(&LCLWORK,1) EQ 'K' AND &LCLWORK GT 1).KVAL
         AIF   ('&STACK' NE 'D2048').ASGNSTK
&GBLSTCK SETC  '2048'
         AGO   .STACKX
.KVAL    ANOP
&LCLCHAR SETC  '&STACK'(1,&LCLWORK-1)
.KVALOOP ANOP
&LCLWORK SETA  &LCLWORK-1
         AIF   ('&LCLCHAR'(&LCLWORK,1) LT '0').ASGNSTK
         AIF   (&LCLWORK GT 1).KVALOOP
&GBLSTCK SETC  '&LCLCHAR*1024'
         AGO   .STACKX
.ASGNSTK ANOP
&GBLSTCK SETC  '&STACK'
.STACKX  ANOP
.*
.*       EDIT THE BASE REGISTER SET AND SET UP GBLREG#, GBLREGS AND
.*       GBLUSNG.
.*
&LCLREG# SETA  N'&BASES
&GBLREG# SETA  &LCLREG#
&LCLSUB1 SETA  1
&LCLSUB2 SETA  1
         AIF   (&LCLRENT).OK#
&GBLREG# SETA  &GBLREG#+1          INCREMENT FOR R13 ADDITION
&GBLREGS(1) SETC 'R13'
&LCLSUB1 SETA  2
.OK#     ANOP
         AIF   (&GBLREG# GT 0).OKCOPY
         MNOTE 8,'NO BASE REGISTERS SPECIFIED - WILL USE R11'
&GBLREG# SETA  1
&GBLREGS(1) SETC 'R11'
.OKCOPY  AIF   (&LCLSUB2 GT &LCLREG#).COPUSNG
&GBLREGS(&LCLSUB1) SETC '&BASES(&LCLSUB2)'
&LCLSUB1 SETA  &LCLSUB1+1
&LCLSUB2 SETA  &LCLSUB2+1
         AGO   .OKCOPY
.COPUSNG ANOP
&GBLUSNG SETC  ',&GBLREGS(1)'
         AIF   (&GBLREG# LE 1).ID
&LCLSUB1 SETA  2
         AIF   ('&LCLSVCT' NE '').ERRSVC1
.UCOPY   AIF   (&LCLSUB1 GT &GBLREG#).ID
&GBLUSNG SETC  '&GBLUSNG,&GBLREGS(&LCLSUB1)'
&LCLSUB1 SETA  &LCLSUB1+1
         AGO   .UCOPY
.ERRSVC1 MNOTE 4,'ONLY 1 BASE REGISTER SUPPORTED FOR SVC TYPE &LCLSVCT'
.*
.*       EDIT THE IDENTIFICATION OPTION - DEFAULT IS DYES(YES)-IF SPEC
.*       IS NOT YES, NO, NODATE OR SHORT, SET TO SHORT
.*
.ID      AIF   ('&ID' EQ 'DYES').DID
         AIF   ('&ID' EQ 'YES').IDOK
         AIF   ('&ID' EQ 'NO').IDOK
         AIF   ('&ID' EQ 'NODATE').IDOK
         AIF   ('&ID' EQ 'SHORT').IDOK
         MNOTE 4,'&ID IS AN INVALID IDENTIFICATION OPTION - SHORT USED'
&GBLID   SETC  'SHORT'
&LCLID   SETC  'SHORT'
         AGO   .PRM
.DID     ANOP
&GBLID   SETC  'YES'
&LCLID   SETC  'YES'
         AGO   .PRM
.IDOK    ANOP
&GBLID   SETC  '&ID'
&LCLID   SETC  '&ID'
.*
.*       EDIT THE PARM OPERAND - SET R2 IF OMITTED
.*
.PRM     AIF   ('&PARM' EQ 'DR2').DPARM
         AIF   ('&PARM' NE '').SETPRM
         MNOTE *,'INPUT PARAMETER LIST POINTER WILL BE IN R2'
.DPARM   ANOP
&GBLPARM SETC  'R2'
&LCLPARM SETC  'R2'
         AGO   .ENT
.SETPRM  ANOP
&GBLPARM SETC  '&PARM'
&LCLPARM SETC  '&PARM'
.*
.*       EDIT THE ENTRY= OPERAND - VALID VALUES ARE YES, NO AND
.*       (YES,NAME) - IF YES, &MNAME MUST NOT BE NULL - SET NO
.*       IF INVALID VALUE OR YES AND NO &MNAME
.*
.ENT     ANOP
&LCLENAM SETC  '&MNAME'                  SET LOCAL NAME TO MACRO
         AIF   ('&MNAME' NE '').ENTNOK   YES, LET IT DEFAULT
&LCLENAM SETC  '&SYSECT'                 MUST BE AT START OF MACRO
.ENTNOK  AIF   ('&ENTRY' EQ 'DYES').EYES
         AIF   ('&ENTRY' EQ 'YES').EYES
         AIF   ('&ENTRY' EQ 'NO').SNAME
         AIF   ('&ENTRY(1)' EQ 'YES').ENAME
         MNOTE 4,'&ENTRY INVALID ENTRY OPTION - NO USED'
         AGO   .SNAME
.EOMIT   MNOTE 8,'ENTRY NAME OMITTED - WILL USE NAME FIELD OF CNAENTER X
               MACRO IF PRESENT'
.EYES    AIF   ('&MNAME' EQ '').ENONE
&LCLENAM SETC  '&MNAME'
&LCLENTR SETB  (1)
         AGO   .SNAME
.ENAME   AIF   ('&ENTRY(2)' EQ '').EOMIT
&LCLENAM SETC  '&ENTRY(2)'
&LCLENTR SETB  (1)
         AGO   .SNAME
.ENONE   MNOTE 8,'ENTRY=YES CANCELLED BECAUSE THERE IS NO NAME ON THE MX
               ACRO'
.*
.*       SET THE GLOBAL SAVEVAL TO BE SAVE/WORK AREA NAME FROM
.*       SNAME= OPERAND.  DEFAULT TO WORKAREA OR SAVEAREA
.*       DEPENDING ON REENTRANCY OPTION
.*
.SNAME   AIF   ('&SNAME' EQ '').SNDEF
&GBLSAVE SETC  '&SNAME'
         AGO   .QCONCK
.SNDEF   ANOP
&GBLSAVE SETC  'WORKAREA'
         AIF   (&LCLRENT).QCONCK
&GBLSAVE SETC  'SAVEAREA'
.QCONCK  AIF   ('&GBLRENT' NE 'COM').SCLR
         CNADXD &GBLSAVE
&GBLSAVE SETC  '&GBLQNAM(&GBLQCNT)'
.*
.*       SET THE GLOBAL CLEARS
.*
.SCLR    ANOP
&GBLSCLR SETB  ('&SCLEAR' EQ 'YES')
&LCLSCLR SETB  (&GBLSCLR)
.*
.*       SET THE GLOBAL CLEARW
.*
&GBLWCLR SETB  ('&WCLEAR' EQ 'YES')
&LCLWCLR SETB  (&GBLWCLR)
.*
.*       SET GLOBAL STRGVAL FROM STORAGE= - NULL ALLOWED FOR NON-RENT
.*
&GBLSTRG SETC  'WORKLEN'
&LCLSTRG SETC  'WORKLEN'
         AIF   ('&STORAGE' EQ 'DWORKLEN').EDITSP
&GBLSTRG SETC  '&STORAGE'
&LCLSTRG SETC  '&STORAGE'
         AIF   ('&GBLSTRG' NE '').EDITSP
         AIF   (NOT &LCLRENT).CALC
         AIF   ('&RENT(1)' EQ 'NOSAVE').EDITSP
&GBLSTRG SETC  'WORKLEN'
&LCLSTRG SETC  'WORKLEN'
         MNOTE 8,'STORAGE= NULLIFIED BUT VALUE REQUIRED - WORKLEN USED'
.*
.*  EDIT THE SP= PARAMETER (SUBPOOL = )
.*
.EDITSP  ANOP
&GBLCESP SETC '0'            DEFAULT IT TO SUBPOOL 0
         AIF  ('&SP' EQ '').CALC  ACCEPT THE DEFAULT
&GBLCESP SETC '&SP'          SET THE OPERAND VALUE
         AGO  .CALC
.*
.*
.*
.*       EDIT SUPPLIED OPERANDS AGAINST GLOBAL VALUES USED IN FIRST
.*       INVOCATION OF CNAENTER
.*
.*
.*
.NTH     ANOP
.*
.*       SET UP LOCAL ITEMS TO MATCH GLOBALS FOR FIRST APPROXIMATION
.*
&LCLSCLR SETB  (&GBLSCLR)
&LCLWCLR SETB  (&GBLWCLR)
&LCLPARM SETC  '&GBLPARM'
&LCLID   SETC  '&GBLID'
&LCLSTRG SETC  '&GBLSTRG'
&LCLOFF  SETB  (1)
&LCLSVCT SETC  '&GBLCESV'             SVC TYPE
&LCLTBAS SETC  'R15'                  TEMPORARY BASE IS R15
         AIF   ('&LCLSVCT' NE 'SVCR6').RNT2L1
&LCLTBAS SETC  'R6'                   TEMPORARY BASE IS R6 FOR SVCR6
.RNT2L1  ANOP
.*
.*       IGNORE ANY DESIGNATION OF BASE REGISTERS
.*
         AIF   (N'&BASES EQ 0).RENTR
         MNOTE 4,'BASE REGISTERS IGNORED - WILL USE SAME AS ON 1ST CALLX
                TO CNAENTER - &GBLREGS(1) IS FIRST BASE'
.*
.*       THE ENTRY ATTRIBUTE MUST BE ASSUMED ELSE WHY ANOTHER ENTRY?
.*
.RENTR   AIF   ('&ENTRY' EQ 'DYES' OR '&ENTRY' EQ 'YES').RSETM
         AIF   ('&ENTRY(2)' NE '').RSET2
         MNOTE 8,'&ENTRY INVALID FOR THIS CALL - YES USED AND NAME ON MX
               ACRO WILL BE ENTRY NAME'
.RSETM   AIF   ('&MNAME' NE '').RSETM2
         MNOTE 8,'MACRO NAME REQUIRED FOR ENTRY POINT - ####$$$$ USED'
&LCLENAM SETC  '####$$$$'
         AGO   .RENTSET
.RSET2   ANOP
&LCLENAM SETC  '&ENTRY(2)'
         AGO   .RENTSET
.RSETM2  ANOP
&LCLENAM SETC  '&MNAME'
.RENTSET ANOP
&LCLENTR SETB  (1)
.*
.*       ID VALUE RESET TO CONTAIN NO DATE SPECIFICATION IF YES
.*       CURRENTLY IN EFFECT
.*
         AIF   ('&LCLID' NE 'YES').CKIDOVR
&LCLID   SETC  'NODATE'
.CKIDOVR AIF   ('&ID' EQ 'DYES').RPRM
         AIF   ('&ID' EQ 'YES').LCLYES
         AIF   ('&ID' EQ 'SHORT').LCLYES
         AIF   ('&ID' EQ 'NODATE').LCLYES
         AIF   ('&ID' EQ 'NO').LCLYES
         MNOTE 4,'&ID INVALID FOR ID= - VALUE &LCLID USED.'
         AGO   .RPRM
.LCLYES  ANOP
&LCLID   SETC  '&ID'
.*
.*       SEE IF PARM REGISTER TO BE OVERRIDEN FOR THIS ENTRY
.*
.RPRM    ANOP
         AIF   ('&PARM' EQ 'DR2').RRENT
&LCLPARM SETC  '&PARM'
.*
.*       FLUSH RENT OPTION IF CODED - USE ORIGINAL
.*
.RRENT   AIF   ('&RENT(1)' EQ 'DYES').RSWRCK
         AIF   ('&RENT(1)' EQ '&GBLRENT').RSWRCK
         MNOTE 4,'&RENT REENTRANCY OPTION IGNORED - &GBLRENT FROM FIRSTX
               USE OF CNAENTER USED.'
.RSWRCK  ANOP
.*
.*       SET &LCLRENT FOR PROPER GEN TYPE
.*
&LCLRENT SETB  ('&GBLRENT' EQ 'YES'   OR '&GBLRENT' EQ 'NEWSTACK' OR   *
                '&GBLRENT' EQ 'STACK' OR '&GBLRENT' EQ 'NOSAVE' OR     *
                '&GBLRENT' EQ 'COM')
.*
.*       EDIT SPKA OPTION. ONLY VALID IF 2ND RENT OPTION CODED
.*
         AIF  ('&SPKA' EQ '' OR '&GBLCESV' NE '').RNT4OK
         MNOTE 4,'SPKA=&SPKA IGNORED IF 2ND RENT OPTION NOT CODED'
.RNT4OK  ANOP
.*
.*       EDIT WTG OPERAND IF GBLRENT=COM
.*
         AIF   ('&GBLRENT' NE 'COM').NOCBAS
         AIF   ('&GBLWTG' EQ '').NLWTG
         AIF   ('&WTG' EQ 'D' OR '&WTG' EQ '&GBLWTG').NOWTGE
         MNOTE 8,'&WTG WTG ENTRY IGNORED - &GBLWTG USED'
         AGO   .NOWTGE
.NLWTG   ANOP
         AIF   ('&WTG' EQ 'D' OR '&WTG' EQ '').NOWTGE
         MNOTE 8,'NO WTG CODE GENERATED DUE TO FIRST ENTRY CONDITIONS'
.NOWTGE  ANOP
         AIF   ('&CBASE' EQ 'DR12' OR '&CBASE' EQ '&GBLCBAS').NOCBAS
         MNOTE 8,'COMMON BASE CODED IGNORED - &GBLCBAS USED'
.NOCBAS  ANOP
.*
.*       RESET LOCAL VALUE OF CLEAR SWITHCES IF NOT DEFAULTED
.*
         AIF   ('&SCLEAR' EQ 'DNO').CKWCLR
&LCLSCLR SETB  ('&SCLEAR' EQ 'YES')
.CKWCLR  AIF   ('&WCLEAR' EQ 'DNO').RSN
&LCLWCLR SETB  ('&WCLEAR' EQ 'YES')
.*
.*       SAVE AREA NAME MUST REMAIN CONSTANT OVER INVOCATIONS
.*
.RSN     AIF   ('&SNAME' EQ '').RSTRG
         AIF   ('&SNAME' EQ '&GBLSAVE').RSTRG
         MNOTE 8,'&SNAME WILL NOT BE USED FOR SAVE/WORK AREA NAME - &GBL
               LSAVE WILL BE USED INSTEAD'
.*
.*       STORAGE VALUE CAN ONLY CHANGE FOR RENT=NEWSTACK OR RENT=STACK
.*
.RSTRG   AIF   ('&STORAGE' EQ 'DWORKLEN').CALC
         AIF   ('&STORAGE' EQ '&GBLSTRG').CALC
         AIF   ('&GBLRENT' EQ 'NEWSTACK' OR '&GBLRENT' EQ 'STACK').REST
        MNOTE 8,'UNABLE TO CHANGE STORAGE LENGTH - VALUE &GBLSTRG USED'
         AGO   .CALC
.REST    ANOP
&LCLSTRG SETC  '&STORAGE'
.*
.*
.*
.*       COMMON MACRO SET UP AND OFFSET CALCULATION
.*
.*
.*    ID=    NO     SHORT   NODATE    YES     ENTRY=  (SPFID)  FIRST?
.*
.*            0       10      10       24       NO       NO      ---
.*
.*                            28       28       YES      ---     NO
.*
.*                            28       42       YES      NO      YES
.*
.*                            34       48       NO       YES     ---
.*
.*                            52       66       YES      YES     YES
.*
.*
.CALC    ANOP
&LCLIDSZ SETA  0
         AIF   ('&LCLID' EQ 'NO').NOSPFID
&LCLIDSZ SETA  10
         AIF   ('&LCLID' EQ 'SHORT').NOSPFID  NO ID OR DATES
         AIF   (NOT &LCLENTR AND NOT &LCLOFF).IDLEN
&LCLIDSZ SETA  &LCLIDSZ+18           FOR ENTRY=YES
.IDLEN   AIF   (&LCLOFF).NOSPFID     NO DATES FOR 2ND ENTRY
         AIF   ('&LCLID' EQ 'NODATE').CALCND  NO DATE - MAY BE SPF
&LCLIDSZ SETA  &LCLIDSZ+14           FOR ASSEMBLY DATE AND TIME
.CALCND  AIF   ('&CNASPFL' EQ '').NOSPFID       SKIP IF NO SPF DATA
&LCLIDSZ SETA  &LCLIDSZ+24         LENGTH OF SPF SOURCE DATA
.NOSPFID ANOP
&LCLIDLN SETA  &LCLIDSZ-1
.*
.*       SIZE OF ID CONSTANTS CALCULATED - CALCULATE TOTAL
.*       CONSTANT SIZE BY ADDING 2 FOR STORAGE CALCULATION
.*       FOR STACKING, 2 FOR OFFSET FOR BASE 1 CALCULATION
.*       AND 72 PLUS ALIGNMENT FILLER FOR IN-LINE SAVE AREAS.
.*
&LCLCONS SETA  &LCLIDSZ
&LCLPLUS SETA  4
         AIF   (NOT &LCLOFF).NOFF
&LCLCONS SETA  &LCLCONS+2         ADD FOR BASE 1 OFFSET
&LCLOFFS SETA  &LCLIDSZ+&LCLPLUS
&LCLPLUS SETA  &LCLPLUS+2
.NOFF    AIF   ('&GBLRENT' NE 'STACK' AND '&GBLRENT' NE 'NEWSTACK').N
&LCLCONS SETA  &LCLCONS+2         ADD FOR STORAGE OFFSET
&LCLSTRL SETA  &LCLIDSZ+&LCLPLUS
&LCLPLUS SETA  &LCLPLUS+2
.N       AIF   ('&GBLRENT' NE 'NO' OR &LCLOFF).NOSAVE
&LCLWORK SETA  &LCLCONS/4
&LCLWORK SETA  &LCLWORK*4
&LCLFILL SETA  &LCLWORK+4-&LCLCONS
         AIF   (&LCLFILL LT 4).FSET
&LCLFILL SETA  0
.FSET    ANOP
&LCLCONS SETA  &LCLCONS+&LCLFILL+72
.*
.*
.*       CALCULATIONS ARE DONE ... BEGIN CODE GENERATION
.*
.*
.NOSAVE  ANOP
         AIF   (NOT &LCLOFF).NOALGN
         CNOP  0,8                 FORCE DOUBLE WORD ALIGNMENT
.NOALGN  AIF   (NOT &LCLENTR).NEGE
&LCLENAM DS    0H                  ENTRY POINT NAME
         ENTRY &LCLENAM            EXTERNAL DECLARATION
.NEGE    AIF   ('&MNAME' EQ '').NNAME
         AIF   ('&LCLENAM' EQ '&MNAME' AND &LCLENTR).NNAME
&MNAME   DS    0H                  ENTRY POINT NAME
.NNAME   ANOP
         USING *,&LCLTBAS          TEMPORARY BASE
         AIF   (&LCLCONS EQ 0).NOCONS
&LCLWORK SETA  &LCLCONS+4
         B     *+&LCLWORK          BRANCH AROUND ALL CONSTANTS
         AIF   (&LCLIDSZ EQ 0).NOIDSZ
         DC    AL1(&LCLIDLN)       LENGTH OF ID FIELDS
         AIF   (NOT &LCLENTR).NOECON
         DC    CL9'&LCLENAM'       ENTRY NAME IN ID FIELDS
         AIF   (&LCLIDSZ EQ 10).NOIDSZ
         DC    CL9'IN CSECT '
.NOECON  DC    CL9'&SYSECT'        CSECT NAME IN ID FIELDS
         AIF   (&LCLIDSZ EQ 10).NOIDSZ
         AIF   (&LCLOFF).NOIDSZ    SKIP BOTH TIME AND SPF DATA FOR 2ND
         AIF   ('&LCLID' EQ 'NODATE').SPFID1
         DC    CL9'&SYSDATE'       ASSEMBLY DATE IN ID FIELDS
         DC    CL5'&SYSTIME'       ASSEMBLY TIME IN ID FIELDS
.SPFID1  AIF   ('&CNASPFD' EQ '').NOIDSZ INSERT SPF DATA
         DC    CL8' &CNASPFD'      DATE OF THIS MODIFICATION
         DC    CL8'&CNASPFL'       LEVEL NUMBER OF THIS VERSION
         DC    CL8'&CNASPFU'       TSO USERID OF LAST UPDATER
.NOIDSZ  AIF   (NOT &LCLOFF).STCKCK
         AIF   ('&GBLRENT' EQ 'NO').SAOFF
         DC    Y(&LCLENAM-&SYSECT) OFFSET TO MODULE BASE
         AGO   .STCKCK
.SAOFF   DC    Y(&LCLENAM-&GBLSAVE) OFFSET TO MODULE BASE
.STCKCK  AIF   ('&GBLRENT' NE 'STACK' AND '&GBLRENT' NE 'NEWSTACK').F
         DC    Y(&LCLSTRG)         WORK AREA SIZE FROM STACK
.F       AIF   ('&GBLRENT' NE 'NO' OR &LCLOFF).NOCONS
         AIF   (&LCLFILL EQ 0).NOFILL
         DC    XL(&LCLFILL)'00'    FILLER TO ALIGN SAVE AREA
.NOFILL  ANOP
&GBLSAVE DC    18F'0'              MODULE'S SAVE AREA
.NOCONS  ANOP
         SPACE 2
.*
.*             GENERATE CODE FOR SVC ENTRY OPTIONS
.*
         AIF   ('&LCLSVCT' EQ '').RNT2GND   NO SVC ENTRY, GO TO STD.
         AIF   ('&LCLSVCT' EQ 'SVCR6').RNT2G1 DON'T SAVE BASE REGISTER
         AIF   ('&LCLSVCT' EQ 'NSL').RNT2G1  LIKEWISE FOR NSL OPTION
         LR    R3,&LCLTBAS         SAVE TEMPORARY BASE
         DROP  &LCLTBAS
         USING &LCLENAM,R3
&LCLTBAS SETC  'R3'                RESET TEMPORARY BASE
.RNT2G1  AIF   ('&SPKA' EQ '').RNT2G1A      SKIP IF NO SPKA OPTION
         AIF   ('&SPKA' NE 'DATAMGT').USERSPK
         SPKA  80                  SET DATAMGT PROTECT KEY
         AGO   .RNT2G1A
.USERSPK SPKA  &SPKA               SET PROTECT KEY FOR USER
.RNT2G1A ANOP
  DS  0C'GETMAIN R,LV=&GBLSTCK,SP=&GBLCESP' GET NEW STACK
         GETMAIN R,LV=&GBLSTCK,SP=&GBLCESP
         AIF   ('&LCLSVCT' NE 'NSL').RNT2G2  SKIP SAVE IF NOT NSL
         STM   R2,R14,80(R1)       SAVE OPEN/CLOSE/EOV REGS (EX. R3)
         LR    R13,R1              SET SAVEAREA IN PROPER BASE
         BALR  &GBLREGS(1),0       GET LOCATION
         LA    R15,*-&SYSECT       CALCULATE CORRECT BASE
         SLR   &GBLREGS(1),R15      --> 4K MODULE LIMIT <--
         AGO   .RNT2G3             SKIP OTHER OPTION FIDDLING
.RNT2G2  LR    R13,R1              SET SAVEAREA IN PROPER BASE
         AIF   ('&GBLREGS(1)' EQ '&LCLTBAS' AND NOT &LCLOFF).RNT2G3A
         AIF   ('&GBLREGS(1)' EQ '&LCLTBAS').RNT2G2A
         LR    &GBLREGS(1),&LCLTBAS SET PERMANENT BASE REGISTER
.RNT2G2A AIF   (NOT &LCLOFF).RNT2G3      SKIP IF NOT SECOND ENTRY
         SH    &GBLREGS(1),&LCLENAM+&LCLOFFS ADJUST THE BASE REGISTER
.RNT2G3  DROP  &LCLTBAS            RESET ADDRESSING
         USING &SYSECT&GBLUSNG     SET USING FOR PROGRAM
.RNT2G3A LH    R15,&LCLENAM+&LCLSTRL SET ADDRESS OF NEXT
         AR    R15,R13              WORKAREA IN THE STACK
         ST    R15,72(,R13)         FOR RENT=STACK PROCESSING
         XC    4(8,R13),4(R13)      CLEAR BACK AND FOREWARD POINTERS
         USING &GBLSAVE,R13         DECLARE DSA
         AIF   ('&LCLSVCT' NE 'SVCR6').RNT2G4 IS IT R6 ENTRY
         LM    R0,R1,32(R5)         RESTORE PARAMETER REGS FROM
         L     R15,92(R5)           SVRB SAVEAREA
.RNT2G4  SPACE 2
         MEXIT
.RNT2GND ANOP
.*
.*             NOW GENERATE FOR NON SVC ENTRY OPTIONS
.*
         AIF   ('&GBLRSVE' EQ 'NO').RSVE#1
         STM   R14,R12,12(R13)     SAVE CALLER'S REGISTERS
         AGO   .RSVE#2
.RSVE#1  LR    R3,R14              SAVE R14 FOR RETURN
.RSVE#2  LR    &LCLPARM,R1         SAVE INPUT PARAMETER LIST PTR.
         AIF   (&LCLRENT).RBASES
         AIF   (&LCLOFF).SOFFBAS
         LA    R15,&GBLSAVE        WILL BE BASE AND S.A. POINTER
.NRBAS   ST    R13,4(,R15)         SET BACK CHAIN
         ST    R15,8(,R13)         SET FORWARD CHAIN
         LR    R13,R15             SET BASE AND S.A. POINTER
         DROP  R15                 END TEMPORARY ADDRESSING
         USING &GBLSAVE&GBLUSNG    PERMANENT ADDRESSING
         AGO   .NTHBASE
.SOFFBAS ANOP
         SH    R15,&LCLENAM+&LCLOFFS WILL BE BASE AND S.A. POINTER
         AGO   .NRBAS
.RBASES  LR    &GBLREGS(1),R15     SET 1ST BASE REGISTER
         AIF   (NOT &LCLOFF).ROFFBAS
         SH    &GBLREGS(1),&LCLENAM+&LCLOFFS RESET BACK TO ORIGIN
.ROFFBAS DROP  R15                 END TEMPORARY ADDRESSING
         USING &SYSECT&GBLUSNG     PERMANENT ADDRESSING
.NTHBASE AIF   (&GBLREG# LE 1).NTHSET
&LCLSUB1 SETA  2
&LCLSUB2 SETA  1
         LA    R14,2048            CONSTANT FOR NTH BASE GENERATION
.NTHGENR AIF   (&LCLSUB1 GT &GBLREG#).NTHSET
         LA    &GBLREGS(&LCLSUB1),2048(R14,&GBLREGS(&LCLSUB2).)
&LCLSUB2 SETA  &LCLSUB1
&LCLSUB1 SETA  &LCLSUB1+1
         AGO   .NTHGENR
.NTHSET  ANOP
         SPACE 2
         AIF   ('&GBLRENT' EQ 'NO').PL
         AIF   ('&GBLRENT' EQ 'NOSAVE').PL
         AIF   ('&GBLRENT' EQ 'YES').GET
         AIF   ('&GBLRENT' EQ 'STACK').STACK
         AIF   ('&GBLRENT' EQ 'COM').COMGET
*                                  GET STACK
         GETMAIN  R,LV=&GBLSTCK,SP=&GBLCESP
         AGO   .FWDCHN
.STACK   ANOP
         L     R1,72(,R13)         GET NEXT AREA ORIGIN IN STACK
         AGO   .FWDCHN
.GET     ANOP
*                                  GET WORKING STORAGE
         GETMAIN  R,LV=&LCLSTRG,SP=&GBLCESP
         AGO   .FWDCHN
.COMGET  ANOP
         L     R1,Q&GBLQNAM(1)     GET OFFSET TO WORK AREA
         AR    R1,&GBLCBAS         ADJUST TO ADDRESS
.FWDCHN  ST    R1,8(,R13)          SET FORWARD CHAIN
         AIF   (NOT &LCLWCLR).SCLRCK
         LR    R14,R1              ADDRESS TO BEGIN CLEAR
         AIF   ('&GBLRENT' EQ 'YES').CLRLC
         AIF   (&LCLENTR).LHENTR
         LH    R15,&SYSECT+&LCLSTRL LENGTH OF CLEAR
         AGO   .CLRCMN
.CLRLC   LH    R15,*+8             LENGTH OF CLEAR
         B     *+6                 AROUND CONSTANT
         DC    Y(&LCLSTRG)         SIZE OF WORK AREA
         AGO   .CLRCMN
.LHENTR  LH    R15,&LCLENAM+&LCLSTRL LENGTH OF CLEAR
.CLRCMN  SR    R1,R1               FILL CHARACTER IS X'00'
         MVCL  R14,R0              CLEAR THE WORK AREA
         L     R1,8(,R13)          RELOAD CURRENT WORK POINTER
         AGO   .CLRD
.SCLRCK  AIF   (NOT &LCLSCLR).CLRD
         XC    0(72,R1),0(R1)      CLEAR THE SAVE AREA
.CLRD    AIF   ('&GBLRENT' EQ 'YES' OR '&GBLRENT' EQ 'COM').NOSTKS
         AIF   (&LCLENTR).LENENTR
         LH    R15,&SYSECT+&LCLSTRL SIZE OF AREA NEEDED IN STACK
         AGO   .BLDSTKN
.LENENTR LH    R15,&LCLENAM+&LCLSTRL SIZE OF AREA NEEDED IN STACK
.BLDSTKN AR    R15,R1              R15 IS NEXT FREE SLOT IN STACK
         ST    R15,72(,R1)         SET FOR NEXT MODULE TO FIND
.NOSTKS  AIF   ('&GBLRSVE' EQ 'NO').NRSV#3
         ST    R13,4(,R1)          SET BACK CHAIN
         LM    R13,R1,8(R13)       RESTORE CLOBBERED REGISTERS
         USING &GBLSAVE,R13        TELL ASSEMBLER ABOUT REGISTER
         AGO   .PL                 GO CHECK FOR PARAMETER LIST SAVE
.NRSV#3  LR    R13,R1              SET WORK AREA REGISTER
         USING &GBLSAVE,R13        TELL ASSEMBLER ABOUT REGISTER
.PL      AIF   ('&PLOAD' EQ '').DONE
&LCLPRML SETA  N'&PLOAD
&LCLWORK SETA  1
         SPACE 2
.PLLOOP  CNAPLOAD &PLOAD(&LCLWORK),&LCLWORK,&LCLPARM
&LCLWORK SETA  &LCLWORK+1
         AIF   (&LCLWORK LE &LCLPRML).PLLOOP
.DONE    AIF   ('&GBLRENT' NE 'COM').DONE1
         AIF   ('&GBLWTG' EQ '').DONE1
         ICM   R15,15,&GBLWTG         PICK UP WHERE TO GO ADDRESS
         BNZR  R15                    GO THERE IF INITIALIZED
.DONE1   ANOP
         SPACE 2
         MEND
KDSNDDN  TITLE 'SUBROUTINE: FIND DSNAME OR DDNAME OR MEMBER'
KDSNDDN  CSECT
         RG    (RBASE,,12)
         RG    (RARG)
         RG    (RCOUNT)
         RG    (RARRAY)
         RG    (RPARM)
*                                                                     *
*  TECHNICAL NOTES:                                                   *
*     1. PROGRAM IS REENTRANT.                                        *
*     2. "DDD" SERVICE USED FOR ALLOCATE/FREE OF LIBRARIES FOR BLDL   *
*        DURING MEMBER-SEARCH FUNCTION.                               *
*     3. THREE ENTRYPOINTS ARE USED (LINKEDITED WITH THREE ALIASES).  *
*     4. THREE PARAMETERS ARE RECEIVED AT EACH ENTRYPOINT;            *
*        LAST TWO PARAMETERS ARE UPDATED BY SUBROUTINE:               *
*           SEARCH-ARGUMENT                                           *
*           ARRAY ROW-COUNTER                                         *
*           ARRAY                                                     *
*        NOTE: "KSNSUB" ENTRY HAS AN OPTIONAL 4TH PARAMETER.          *
*     5. RETURN-CODES:                                                *
*              0 = SUCCESSFUL SEARCH ("HITS" FOUND).                  *
*              4 = SUCCESSFUL SEARCH ("HITS" FOUND); ARRAY OVERFLOW.  *
*              8 = UNSUCCESSFUL SEARCH (NO "HITS" FOUND).             *
         EJECT
*                                                                     *
*     KDSNSUB PARAMETERS ARE:                                         *
*           SEARCH-ARGUMENT   (8-BYTE DDNAME)                         *
*           ARRAY ROW-COUNTER (HALFWORD BINARY; UPDATED TO NUMBER OF  *
*                              DSNAMES FOUND)                         *
*           ARRAY             (N X 44-BYTE ARRAY FOR DSNAMES)         *
*           ARRAY             (N X 6-BYTE ARRAY FOR VOLSERS;OPTIONAL) *
KDSNSUB  CNAENTER RBASE,PARM=RPARM,RENT=YES
         MVI   FUNC,C'1'
         B     DOIT
         EJECT
*                                                                     *
*     KDDNSUB PARAMETERS ARE:                                         *
*           SEARCH-ARGUMENT   (44-BYTE DSNAME)                        *
*           ARRAY ROW-COUNTER (HALFWORD BINARY; UPDATED TO NUMBER OF  *
*                              DDNAMES FOUND)                         *
*           ARRAY             (N X 10-BYTE ARRAY FOR DDNAMES;         *
*                              ARRAY ROW FORMAT:                      *
*                              8-BYTE DDNAME                          *
*                              HALFWORD BINARY CONCATENATION SEQUENCE *
*                                   (0 = DSNAME IS NOT CONCATENATED)) *
KDDNSUB  CNAENTER PARM=RPARM,RENT=YES
         MVI   FUNC,C'2'
         B     DOIT
         EJECT
*                                                                     *
*     KMEMSUB PARAMETERS ARE:                                         *
*           SEARCH-ARGUMENT   (8-BYTE MEMBER NAME)                    *
*           ARRAY ROW-COUNTER (HALFWORD BINARY; UPDATED TO NUMBER OF  *
*                              "HITS" FOUND)                          *
*           ARRAY             (N X 44-BYTE ARRAY FILLED WITH DSNAMES; *
*                              "NO-HIT" DSNAMES ARE BLANKED-OUT IN    *
*                              PLACE).                                *
KMEMSUB  CNAENTER PARM=RPARM,RENT=YES
         MVI   FUNC,C'3'
         B     DOIT
         EJECT
DOIT     DS    0H
         XC    RC4,RC4
         LM    RARG,RARRAY,0(RPARM)          GRAB 3 ENTRY PARAMETERS
         XC    HOLDVOL,HOLDVOL               CLEAR
         TM    8(RPARM),X'80'                TEST FOR 4TH PARAMETER
         BO    *+10                          BR IF NOT PRESENT
         MVC   HOLDVOL,12(RPARM)             COPY 4TH-PARM ADDRESS
         NI    HOLDVOL,X'EF'                 CLEAR VL-BIT
         RF    RPARM                         FREE PARM-POINTER
         CLI   FUNC,C'3'                     MEMBER-TEST?
         BE    SEARCH3                       BR IF YES
*              CLEAR RESULTS-ARRAY FOR DSN/DDN SEARCH
         RG    (RWORK1A),(RWORK1B)
         RG    (RWORK2A),(RWORK2B)
         XR    RWORK2A,RWORK2A
         XR    RWORK2B,RWORK2B
         ICM   RWORK2B,8,=C' '               BLANK-FILL CHAR
         LH    RWORK1B,0(RCOUNT)             GET ARRAY COUNTER
         LA    RWORK1A,44                    MULTIPLY BY 44
         CLI   FUNC,C'2'                     DDN-SEARCH?
         BNE   *+8                           BR IF YES
         LA    RWORK1A,10                    MULTIPLY BY 10
         MR    RWORK1A,RWORK1A               MULTIPLY BY ARRAY COUNTER
         LR    RWORK1A,RARRAY                SET ARRAY ADDRESS
         MVCL  RWORK1A,RWORK2A               CLEAR RESULTS ARRAY
*
         RF    RWORK1A,RWORK1B
         RF    RWORK2A,RWORK2B
         RG    (RTALLY)
*
SEARCH12 DS    0H
         RG    (RTCB)                        TCB MAP
         RG    (RTIOT)                       TIOT MAP
         L     RTCB,540(R0)                  POINT TO TCBOLD
         L     RTIOT,12(RTCB)                POINT TO TIOT (TCBTIO)
         RF    RTCB                          DONE WITH TCB
         RG    RTIOTLN                       TCB DDNAME ENTRY LENGTH
         XR    RTIOTLN,RTIOTLN
         LA    RTIOT,24(RTIOT)               POINT TO 1ST DDNAME ENTRY
         XR    R0,R0                         CLEAR FOR RESULTS COUNT
         LH    RTALLY,0(RCOUNT)              ARRAY COUNTER
         LA    RTALLY,1(RTALLY)                PLUS 1 FOR BCT
         CLI   FUNC,C'2'                     DDNAME SEARCH?
         BE    DSLOOK                        BR IF YES
         EJECT
*              FIND DSNAMES FOR A DDNAME
DDLOOK   DS    0H                            FIND INITIAL DDNAME ENTRY
         RG    RVOL
         L     RVOL,HOLDVOL                  GET VOLSER ARRAY ADDR
         CLI   0(RTIOT),X'00'
         BE    DONEDDN                       BR IF DDNAME NOT FOUND
         IC    RTIOTLN,0(RTIOT)              PICK UP TIOELNGH
         CLC   0(8,RARG),4(RTIOT)            COMPARE INPUT TO TIOEDDNM
         BE    GOTDDN                        BR IF FOUND
         LA    RTIOT,0(RTIOTLN,RTIOT)        SET TO NEXT ENTRY
         B     DDLOOK
GOTDDN   DS    0H
         BCT   RTALLY,*+8                    DECREASE ARRAY COUNT
         B     NOROOM                        BR IF NO ROOM IN ARRAY
         A     R0,=F'1'                      ADD TO "HIT" COUNT
         TM    3(RTIOT),X'20'                TEST TIOELINK FOR DA(*)
         BZ    NOTTERM                       BR TO GET DSNAME
         MVC   0(8,RARRAY),=C'TERMFILE '
         B     VOLTST
NOTTERM  DS    0H
         TM    3(RTIOT),X'02'
         BZ    NOTSYSO
         MVC   0(8,RARRAY),=C'JESFILE '
         B     VOLTST
NOTSYSO  DS    0H
         L     R1,12(RTIOT)                  PICK UP JFCB ADDRESS
         SRL   R1,8                          SHIFT TO CLEAR TIOESTTC
         MVC   0(44,RARRAY),16(R1)           PICK UP DSNAME
VOLTST   DS    0H
         LTR   RVOL,RVOL                     VOLSERS WANTED?
         BZ    NEXTDSN                       BR IF NO
         MVC   0(6,RVOL),=CL6' '
         CLC   0(8,RARRAY),=CL8'NULLFILE'
         BE    BUMPVOL
         CLC   0(8,RARRAY),=CL8'TERMFILE'
         BE    BUMPVOL
         CLC   0(8,RARRAY),=CL8'JESFILE'
         BE    BUMPVOL
         L     R1,16(RTIOT)                  GET UCB ADDRESS
         USING IEFUCBOB,1
         MVC   0(6,RVOL),UCBVOLI             GRAB VOLSER
         DROP  1
BUMPVOL  LA    RVOL,6(RVOL)                  BUMP TO NEXT VOL SLOT
NEXTDSN  DS    0H
         LA    RARRAY,44(RARRAY)             BUMP TO NEXT DSN SLOT
         LA    RTIOT,0(RTIOTLN,RTIOT)        LOOP TO NEXT ENTRY
         CLI   0(RTIOT),X'00'
         BE    DONEDDN
         IC    RTIOTLN,0(RTIOT)              PICK UP TIOELNGH
         CLC   4(8,RTIOT),=CL8' '            TEST FOR CONCAT DSNAMES
         BE    GOTDDN                        BR IF FOUND
         B     DONEDDN
         RF    RVOL
         EJECT
*              FIND DDNAMES FOR A DSNAME
DSLOOK   DS    0H                            FIND INITIAL DDNAME ENTRY
         CLI   0(RTIOT),X'00'
         BE    DONEDDN                       BR IF DDNAME NOT FOUND
         IC    RTIOTLN,0(RTIOT)              PICK UP TIOELNGH
         CLI   4(RTIOT),C' '                 CONCATENATION?
         BE    BUMPDD                        BR IF YES
         MVC   REALDD,4(RTIOT)               GET CURRENT DDNAME
         XC    CONCAT,CONCAT                 ZERO CONCAT COUNTER
         L     R1,FOURBLANK
         CL    R1,4(RTIOTLN,RTIOT)           NEXT DDN BLANK?
         BNE   SKIPDD                        BR TO BYPASS CONCAT COUNT
BUMPDD   DS    0H
         LH    R1,CONCAT
         LA    R1,1(R1)                      ADD 1 TO CONCAT COUNTER
         STH   R1,CONCAT
SKIPDD   DS    0H
         TM    1(RTIOT),X'80'                TEST FOR INELIGIBLE ENTRY
         BO    SKIPDD2                       BR IF FOUND
CKTERM   DS    0H
         CLC   0(9,RARG),=C'TERMFILE '       CHECK FOR SPECIAL ARGUMENT
         BNE   CKSYSOUT                      BR IF FALSE
         TM    3(RTIOT),X'20'                DOES TIOT ENTRY MATCH?
         BO    GOTDSN                        BR IF TRUE
         B     SKIPDD2                       SKIP THIS ENTRY
CKSYSOUT DS    0H
         CLC   0(8,RARG),=C'JESFILE '        CHECK FOR SPECIAL ARGUMENT
         BNE   CKNULL                        BR IF FALSE
         TM    3(RTIOT),X'02'                DOES TIOT ENTRY MATCH?
         BO    GOTDSN                        BR IF TRUE
         B     SKIPDD2                       SKIP THIS ENTRY
CKNULL   DS    0H
         CLC   0(9,RARG),=C'NULLFILE '       CHECK FOR SPECIAL ARGUMENT
         BNE   CKDSN                         BR IF FALSE
         TM    3(RTIOT),X'22'                IS TIOT ENTRY JES OR TERM?
         BM    SKIPDD2                       BR IF TRUE TO SKIP ENTRY
CKDSN    DS    0H
         L     R1,12(RTIOT)                  PICK UP JFCB ADDRESS
         SRL   R1,8                          SHIFT TO CLEAR TIOESTTC
         CLC   0(44,RARG),16(R1)             COMPARE INPUT TO JFCB DSN
         BE    GOTDSN                        BR IF FOUND
SKIPDD2  DS    0H
         LA    RTIOT,0(RTIOTLN,RTIOT)        SET TO NEXT ENTRY
         B     DSLOOK
GOTDSN   DS    0H
         BCT   RTALLY,*+8                    DECREASE ARRAY COUNT
         B     NOROOM                        BR IF NO ROOM IN ARRAY
         A     R0,=F'1'                      ADD TO "HIT" COUNT
         MVC   0(8,RARRAY),REALDD            PICK UP DDNAME
         MVC   8(2,RARRAY),CONCAT            PICK UP CONCAT COUNTER
         LA    RARRAY,10(RARRAY)             BUMP TO NEXT DDN SLOT
         LA    RTIOT,0(RTIOTLN,RTIOT)        LOOP TO NEXT ENTRY
         CLI   0(RTIOT),X'00'
         BE    DONEDDN
         B     DSLOOK
         EJECT
*
*** SEARCH ARRAY FILLED ... PREPARE FOR EXIT
*
NOROOM   DS    0H
         RF    RTIOT,RTIOTLN
         MVI   RC1,4                         SET OVERFLOW RETURN-CODE
DONEDDN  DS    0H
         STH   R0,0(RCOUNT)                  SAVE DSN COUNT
         LTR   R0,R0                         ANY HITS?
         BNZ   FASTEXIT                      BR IF YES
         MVI   RC1,8                         SET NO-HIT RETURN-CODE
         B     FASTEXIT
         EJECT
*
*** LOOP EACH DSNAME TO BLDL AGAINST MEMBER NAME
*
SEARCH3  DS    0H
         RG    RWORK
         XR    RWORK,RWORK
         LH    RTALLY,0(RCOUNT)              WORKING DSN COUNT
         MVC   DTBL1,=H'1'                   NO. OF BLDL ENTRIES
         MVC   DTBLLTH,=H'12'                BLDL ENTRY LENGTH
         MVC   DTBLMEM,0(RARG)               SET MEMBER FOR BLDL
         MVC   PDSDCB(CDCBLTH),CONDCB        MOVE DCB TO GETMAIN AREA
         MVC   LOPEN(COPNLTH),CONOPEN
         MVC   LCLOSE(CCLSLTH),CONCLOS
KMEMTEMP FREEDD EXIT=FINDMEM
FINDMEM  DS    0H
*
KMEMTEMP DDD   DSN=0(RARRAY)@,DISP=SHR,EXIT=NOMEM
*
         LA    R2,PDSDCB
         OPEN  ((2),(INPUT)),MF=(E,LOPEN)    OPEN FOR BLDL
         BLDL  (2),DTBL                      TEST FOR MEMBER
         ST    R15,DTBLRET                   SAVE RETURN-CODE
         CLOSE ((2)),MF=(E,LCLOSE)           CLEANUP AFTER BLDL
         L     R15,DTBLRET                   TEST BLDL RETURN-CODE
         LTR   R15,R15
         BZ    YESMEM                        BR IF FOUND
NOMEM    DS    0H
         MVC   0(44,RARRAY),=CL44' '         BLANK DSNAME IF NOT FOUND
         B     LOOPMEM
YESMEM   DS    0H
         A     RWORK,=F'1'                   COUNT HITS
LOOPMEM  DS    0H
*
KMEMTEMP FREEDD EXIT=LOOPMEM2
*
LOOPMEM2 LA    RARRAY,44(RARRAY)
         BCT   RTALLY,FINDMEM                   PROCESSED DSNAME
         STH   RWORK,0(RCOUNT)               SET COUNT OF HITS
         LTR   RWORK,RWORK
         BNZ   FASTEXIT                      BR IF HITS
         MVI   RC1,8                         SET "NO-HIT" RETURN CODE
         B     FASTEXIT
         EJECT
         RF    RWORK,RTALLY,RARG,RCOUNT,RARRAY
         EJECT
*
*** PROGRAM EXIT
*
FASTEXIT CNAEXIT RC4
         TITLE '- SUBROUTINES'
         DDDD  CODE
         TITLE '- CONSTANTS'
         DS    0D
FOURBLANK DC   CL4' '
*    DCB FOR BLDL PROCESSING
         PRINT NOGEN
CONDCB   DCB   DDNAME=KMEMTEMP,DSORG=PO,MACRF=(R)
CDCBLTH  EQU   *-CONDCB
CONOPEN  OPEN  (,INPUT),MF=L
COPNLTH  EQU   *-CONOPEN
CONCLOS  CLOSE (,),MF=L
CCLSLTH  EQU   *-CONCLOS
         PRINT GEN
         LTORG *
         TITLE '- WORKING STORAGE'
         CNASTRG
RC4      DS    F
RC1      EQU   RC4+3,1
CONCAT   DS    H
FUNC     DS    C
HOLDVOL  DS    A
*
         DS    0F
REALDD   DS    CL8                           DDNAME HOLD FOR DSLOOK
*
DTBL     DS    0F                            BLDL WORK AREA
DTBL1    DS    H                             # ENTRIES
DTBLLTH  DS    H                             ENTRY LENGTH
DTBLMEM  DS    CL8
DTBLRET  DS    F
*
         DDDD  STORAGE
*
PDSDCB   DS    0A,CL(CDCBLTH)
LOPEN    DS    0A,CL(COPNLTH)
LCLOSE   DS    0A,CL(CCLSLTH)
         CNASEND
         TITLE '- DSECTS'
         PRINT NOGEN
         DCBD   DEVD=DA,DSORG=PS
IEFUCBOB DSECT
         IEFUCBOB
         EJECT
**************************************************************
*   ABSOLUTE REGISTER EQUATES
**************************************************************
          SPACE
R0        EQU   0
R1        EQU   1           PARAMETER REGISTER
R2        EQU   2
R3        EQU   3
R4        EQU   4
R5        EQU   5
R6        EQU   6
R7        EQU   7
R8        EQU   8
R9        EQU   9
R10       EQU   10
R11       EQU   11
R12       EQU   12
R13       EQU   13          ADDRESS OF SAVE-AREA
R14       EQU   14          RETURN REGISTER
R15       EQU   15
          SPACE
**************************************************************
*   CONDITIONAL VALUES
**************************************************************
          SPACE
*   AFTER COMPARE INSTRUCTIONS (A:B)
          SPACE
H         EQU   2           A HIGH
L         EQU   4           A LOW
E         EQU   8           A EQUAL B
NH        EQU   13          A NOT HIGH
NL        EQU   11          A NOT LOW
NE        EQU   7           A NOT EQUAL B
          SPACE
*   AFTER ARITHMETIC INSTRUCTIONS
          SPACE
O         EQU   1           OVERFLOW     (AFTER TM - ALL ONES)
P         EQU   2           PLUS
M         EQU   4           MINUS        (AFTER TM - MIXED   )
Z         EQU   8           ZERO         (AFTER TM - ALL ZERO)
NP        EQU   13          NOT PLUS
NM        EQU   11          NOT MINUS
NZ        EQU   7           NOT ZERO
          SPACE
*   AFTER TEST UNDER MASK INSTRUCTIONS
          SPACE
NO        EQU   14          NOT ONES     (SEE ABOVE FOR O, M, & Z)
          SPACE
**************************************************************
         END
