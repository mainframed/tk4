CKDP     TITLE 'CHKDUMP - MVS DIRECT ACCESS SYSTEM DUMP CHECK PROGRAM'
*        FUNCTION - THIS PROGRAM WILL PRINT MVS DUMP STATUS INFORMATION
*        ON SYSPRINT AND IF A STARTED TASK IT WILL ALSO DISPLAY TITLES
*        ON THE STARTING CONSOLE.  ALL SYS1.DUMP00-09 ON DA VOLUMES
*        WILL BE CHECKED.  OPTIONALLY PARM='ALL' MAY BE SPECIFIED TO
*        SCAN ALL DD STATEMENTS.
*
*        EXECUTE PARMS -
*
*              ALL     - DISPLAY DUMP STATUS ON ALL DD STMTS PRESENT
*              COUNT   - COUNT RECORDS IN DUMP
*              DEBUG   - TERMINATE WITH DUMP
*              CONSOLE - DISPLAY ALL PRINT MSGS ON CONSOLE
*
*
*        INPUT -
*              DDNAME IEFRDER OR SYSUT1 IF PARM='ALL' NOT SPECIFIED
*              IF PARM='ALL' SPECIFIED ANY DDNAME EXCEPT THOSE STARTING
*              WITH SYS, JOBLIB, STEPLIB, OR PGM=*.
*              INPUT DEVICE MAY BE DISK OR TAPE.
*
*
*        OUTPUT -
*              ALL OUTPUT WILL BE ON SYSPRINT.
*              IF THIS A STARTED TASK ONLY TITLES WILL ALSO BE
*              DISPLAYED ON THE STARTING CONSOLE UNLESS CONSOLE IS
*              SPECIFIED.
*
*
*
*
*
*
*
         MACRO
&NAME    PUTMSG  &MSGAD
         AIF   ('&MSGAD' EQ '').ERR
&NAME    IHBINNRA  &MSGAD
         L     15,=V(MSGWTR) .     LOAD ENTRY POINT ADDRESS
         BALR  14,15 .             LINK TO MESSAGE WRITER ROUTINE
         MEXIT
.ERR     MNOTE 12,'***  MESSAGE ADDRESS IS MISSING'
         MEND
CHKDUMP  CSECT
         SAVE  (14,12),,CHKDUMP&SYSDATE&SYSTIME
         LR    R12,R15             LOAD PROGRAM BASE REG
         USING CHKDUMP,R12
         ST    R13,SAVEAREA+4
         LA    R15,R13
         LA    R15,SAVEAREA
         ST    R15,8(R13)
         LR    R13,R15
         MVI   CNTLFLAG,0          CLEAR DUMP CONTROL FLAG
         MVI   STRTFLAG,0          CLEAR START METHOD FLAG
         MVI   STOPFLAG,0          CLEAR STOP METHOD FLAG
*
*        CHECK EXECUTE PARMS
*
         L     R2,0(R1)            LOAD PARM ADDRESS
         LH    R3,0(R2)            LOAD PARM LENGTH
         LTR   R3,R3               ARE ANY PARMS PRESENT
         BZ    NOPARMS             IF NOT CONTINUE
         LA    R1,2(R2)            LOAD START OF PARM FIELD
         LA    R14,1               LOAD INCREMENT COUNT
         LA    R15,1(R3,R2)        LOAD END OF PARM FIELD ADDRESS
FOLDLOOP OI    0(R1),BLANK         FOLD LOWER CASE TO UPPER CASE
         BXLE  R1,R14,FOLDLOOP     LOOP THRU ALL PARM BYTES
         LA    R1,2(R2)            LOAD START OF PARM FIELD
         SPACE
PARMLOOP CLC   ALL,0(R1)           IS ALL DD STATMENTS SPECIFIED
         BE    SETALL              IF YES GO SET OPTION
         CLC   COUNT,0(R1)         IS COUNT SPECIFIED
         BE    SETCNT              IF YES GO SET OPTION
         CLC   CONSOLE,0(R1)       IS CONSOLE SPECIFIED
         BE    SETCON              IF YES GO SET OPTION
         CLC   DEBUG,0(R1)         IS DEBUG SPECIFIED
         BE    SETDEBUG            IF YES GO SET OPTION
NEXTPARM BXLE  R1,R14,PARMLOOP     LOOP THRU ALL PARMS
         B     NOPARMS             ALL PARMS COMPLETE
         SPACE
SETALL   LA    R1,3(R1)            BUMP OVER PARM
         OI    CNTLFLAG,ALLDUMP    SET ALL DD STMT OPTION
         B     NEXTPARM            GO LOOP THRU ALL PARMS
         SPACE
SETCNT   LA    R1,5(R1)            BUMP OVER PARM
         OI    CNTLFLAG,CNTREC     SET ABEND OPTION
         B     NEXTPARM            GO LOOP THRU ALL PARMS
         SPACE
SETCON   LA    R1,7(R1)            BUMP OVER PARM
         OI    CNTLFLAG,DISPCON    SET ABEND OPTION
         B     NEXTPARM            GO LOOP THRU ALL PARMS
         SPACE
SETDEBUG LA    R1,5(R1)            BUMP OVER PARM
         OI    STOPFLAG,DEBUGOPT   SET ABEND OPTION
         B     NEXTPARM            GO LOOP THRU ALL PARMS
NOPARMS  EQU   *
         SPACE
*        INITALIZE HEADING MSG
         SPACE
         CALL  CDATE,CALDATE       GET CURRENT DATE
         TIME  DEC                 GET TIME OF DAY
         ST    R0,WORK             STORE TIME FOR CONVERSION
         MVC   TIME,EDMASK2        LOAD EDIT MASK
         ED    TIME,WORK           EDIT TIME INTO MSG
         LM    R14,R15,TITLE1AD    LOAD TITLE POINTER ADDRESSES
         LA    R1,MSG1             LOAD TITLE ADDRESS
         ST    R1,0(R14)           UPDATE TITLE POINTER ADDRESS
         LA    R1,MSG2             LOAD TITLE ADDRESS
         ST    R1,0(R15)           UPDATE TITLE POINTER ADDRESS
         SPACE
*        GET JOBNAME & OPERATOR COMMUNICATION ADDRESSES
         SPACE
         EXTRACT TIOTAD,FIELDS=(TIOT,COMM,TJID)
         LA    R4,SYSUT1           LOAD DCB BASE REG
         LM    R5,R6,TIOTAD        LOAD TIOT & COM BASE REGS
         USING IHADCB,R4
         USING TIOT,R5
         USING COMSECT,R6
*
*        FIND METHOD OF EXECUTION
*
         L     R7,CIBADDR          LOAD CIB BASE REG
         LTR   R7,R7               IS A CIB PRESENT
         BZ    BATCHJOB            IF NOT THIS IS A BATCH JOB
         USING CIB,R7
STARTJOB MVI   STRTFLAG,STRTTASK   SET EXECUTION METHOD FLAG
         SR    R0,R0               ZERO CONSOLE ID REG
         IC    R0,CIBCONID         LOAD CONSOLE ID
         STC   R0,CONID            SAVE CONSOLE ID
         WTO   MF=(E,WTO1)         DISPLAY HEADING
         QEDIT ORIGIN=CIBADDR,BLOCK=CIB  FREE INITIAL CIB
         B     REFCOMP             GO GET DEVICE INFORMATION
*
BATCHJOB EQU   *
         L     R1,TSOTJID          LOAD TSO USER ID
         LTR   R1,R1               IS THIS A TSO FOREGROUND
         BZ    REFCOMP             IF NOT IT MUST BE A BATCH JOB
         MVI   STRTFLAG,STRTTSO    SET EXECUTION METHOD FLAG
REFCOMP  EQU   *
         SPACE
*        CHECK FOR SINGLE VOLUME OR ALL DD STMT SCAN
         SPACE
         TM    CNTLFLAG,ALLDUMP    IS ALL DD STMT SCAN SPECIFIED
         BZ    SINGVOL             IF NOT GO DISPLAY SINGLE VOLUME
         LA    R2,TIOENTRY         LOAD TIOT DD ENTRY BASE REG
         USING TIOENTRY,R2
         SPACE
TIOTLOOP CLI   TIOELNGH,0          IS THIS END OF TIOT
         BE    RETURN              IF YES ALL DONE
         ICM   R1,7,TIOEFSRT       LOAD & CHECK UCB ADDRESS
         BZ    TIOTNEXT            SKIP IF DUMMY OR TERMINAL
         CLI   TIOEDDNM,BLANK      IS DDNAME BLANK
         BE    TIOTNEXT            IF YES SKIP IT
         CLC   SYS,TIOEDDNM        IS THIS A SYSXXXXX DDNAME
         BE    TIOTNEXT            IF YES SKIP IT
         CLC   JOBLIB,TIOEDDNM     IS THIS JOBLIB ENTRY
         BE    TIOTNEXT            IF YES SKIP IT
         CLC   STEPLIB,TIOEDDNM    IS THIS STEPLIB ENTRY
         BE    TIOTNEXT            IF YES SKIP IT
         CLC   PGMKEY,TIOEDDNM     IS THIS PGM=*.DD ENTRY
         BE    TIOTNEXT            IF YES SKIP IT
         MVC   DCBDDNAM,TIOEDDNM   LOAD CURRENT DDNAME
         DEVTYPE DCBDDNAM,DEVCONS,DEVTAB   GET DEVICE DATA
         CLI   DEVCLASS,DISK       IS DEVICE DIRECT ACCESS
         BE    GETJFCB             IF YES GO READ JFCB
         CLI   DEVCLASS,TAPE       IS DEVICE TAPE
         BE    GETJFCB             IF YES GO READ JFCB
TIOTNEXT SR    R1,R1               ZERO LENGTH REG
         IC    R1,TIOELNGH         LOAD LENGTH OF CURRENT ENTRY
         AR    R2,R1               BUMP BASE TO NEXT ENTRY
         B     TIOTLOOP            LOOP THUR ALL TIOT ENTRIES
         SPACE
*        DISPLAY DUMP STATUS FOR SINGLE VOLUME
*        GET DEVICE INFORMATION
         SPACE
SINGVOL  MVC   DCBDDNAM,STDDDNAM   LOAD STANDARD DDNAME
         DEVTYPE DCBDDNAM,DEVCONS,DEVTAB   GET DEVICE DATA
         LTR   R15,R15             IS DD STMT PRESENT
         BNZ   SETOPTDD            IF NOT USE OPTIONAL DDNAME
         CLI   DEVCLASS,DISK       IS DEVICE DIRECT ACCESS
         BE    GETJFCB             IF YES GO READ JFCB
         CLI   DEVCLASS,TAPE       IS DEVICE TAPE
         BE    GETJFCB             IF YES GO READ JFCB
         SPACE
SETOPTDD EQU   *
         MVC   DCBDDNAM,OPTDDNAM   LOAD OPTIONAL DDNAME
         DEVTYPE DCBDDNAM,DEVCONS,DEVTAB   GET DEVICE DATA
         LTR   R15,R15             IS DD STMT PRESENT
         BNZ   BADOPEN             IF NOT QUIT
         CLI   DEVCLASS,DISK       IS DEVICE DIRECT ACCESS
         BE    GETJFCB             IF YES GO READ JFCB
         CLI   DEVCLASS,TAPE       IS DEVICE TAPE
         BNE   BADDEVT             IF NOT QUIT
         SPACE
GETJFCB  EQU   *
         RDJFCB  SYSUT1            READ JFCB TO GET VOLUME
         LTR   R15,R15             IS DD STMT PRESENT
         BNZ   BADOPEN             IF NOT QUIT
         OI    JFCBTSDM,JFCNWRIT   PREVENT JFCB WRITE BACK
         MVC   DUMPSER,JFCBVOLS    LOAD VOLUME SERIAL
         CLI   DEVCLASS,DISK       IS DEVICE DIRECT ACCESS
         BE    INITDISK            IF YES GO INITIALIZE FOR DISK DEVICE
         SPACE
INITTAPE LA    R11,1               SET TAPE FILE NUMBER
         B     TAPELOOP            GO CHECK TAPE DUMP FILES
         SPACE
INITDISK MVC   JFCBDSNM,DUMPNAME   CHANGE DSNAME TO 1ST DUMP DSN
         LA    R11,DUMPZERO        LOAD 1ST DUMP NUMBER
         SPACE
DISKLOOP EQU   *
         STC   R11,DUMPNUMB        SET DUMP NUMBER
         SPACE
GETDSCB  EQU   *
         OBTAIN  DUMPDSCB          IS DUMP DATA SET ON VOLUME
         LTR   R15,R15             WAS DATA SET FOUND
         BNZ   NEXTDUMP            IF NOT SKIP THIS DATA SET
         OI    CNTLFLAG,DUMPFLAG   SET DUMP FOUND FLAG
         B     OPEN                GO OPEN DUMP DCB
         SPACE
TAPELOOP STH   R11,JFCBFLSQ        UPDATE FILE SEQUENCE NUMBER
         SPACE
OPEN     EQU   *
         OPEN  SYSUT1,TYPE=J       OPEN DUMP DATA SET
         TM    DCBOFLGS,X'10'      DID DCB OPEN
         BZ    BADOPEN             IF NOT GET OUT
         NI    CNTLFLAG,F0         RESET ERROR FLAGS
         SR    R7,R7               ZERO RECORD COUNT
         LA    R10,5               LOAD MAX RECORD COUNT
         SPACE
RECLOOP  EQU   *
         CLI   DEVCLASS,DISK       IS DEVICE DISK
         BE    READREC             IF YES SKIP STIMER
         MVC   PRGDEBAD,DCBDEBA    MOVE DEB ADDR TO PURGE PARM
         SR    R15,R15             ZERO WORK REG
         ST    R15,PRGTCBAD        SET PURGE TCB ADDR TO ZERO
         L     R15,DCBIOBA         LOAD IOB PREFIX ADDR
         LA    R15,8(R15)          LOAD START OF REAL IOB
         ST    R15,PRGIOBAD        SAVE REAL IOB ADDR IN PURGE PARM
         STIMER  REAL,TIMEEXIT,BINTVL=IOTIME   START TAPE TIMER
         SPACE
READREC  GET   SYSUT1              READ DUMP RECORD
         LA    R7,1(R7)            BUMP RECORD COUNT
         LR    R8,R1               LOAD DUMP REC BASE REG
         USING PRDINPUT,R8
         CLI   DEVCLASS,DISK       IS DEVICE DISK
         BE    READCHK             IF YES SKIP TTIMER
         TTIMER  CANCEL            STOP TAPE TIMER
         SPACE
READCHK  TM    CNTLFLAG,RECERR     DID I/O ERROR OCCUR
         BO    BADFMT              IF YES ASSUME BAD FORMAT
         OI    CNTLFLAG,RECFLAG    SET RECORD READ FLAG
         SETON XADUMP             SET AS XA DUMP           *LBD 12/85*
         CLI   PRDHDRID,X'FE'     XA DUMP HEADER ?         *LBD 12/85*
         BE    XADMP1                                      *LBD 12/85*
         CLI   PRDHDRID,PRDHDR     IS THIS A HEADER RECORD
         BNE   NEXTREC             IF NOT SKIP THIS RECORD
         SETOF XADUMP             TURN OFF XA DUMP FLAG    *LBD 12/85*
XADMP1   DS    0H                                          *LBD 12/85*
         CLI   PRDRECID,PRDHDREC   IS THIS A HEADER RECORD
         BE    GOTHDR              IF YES GO DISPLAY TITLE/TIME/DATE
NEXTREC  BCT   R10,RECLOOP         GO READ NEXT RECORD
         SPACE
*        DISPLAY ERROR MSG FOR BAD DATA SET FORMAT
         SPACE
BADFMT   EQU   *
         CLI   DEVCLASS,TAPE       IS DEVICE TAPE
         BE    TAPECOMP            IF YES NO MORE DUMPS
         MVC   BDFMTSER,JFCBVOLS   LOAD VOLUME SERIAL
         STC   R11,BDFMTNO         SET DUMP NUMBER
         LA    R9,MSG5             LOAD MSG ADDRESS
         BAL   R10,DISPWTO         GO DISPLAY MSG
         B     CLOSE               GO CLOSE DCB
         SPACE
*        FORMAT & DISPLAY DUMP TITLE
         SPACE
GOTHDR   EQU   *
         CLI   DEVCLASS,DISK       IS DEVICE DIRECT ACCESS
         BE    DISKHDR             IF YES GO INITIALIZE FOR DISK DEVICE
TAPEHDR  STC   R11,DUMPNO          STORE FILE SEQUENCE NUMBER
         OI    DUMPNO,F0           CONVERT BINARY TO CHARACTER
         OI    CNTLFLAG,DUMPFLAG   SET DUMP FOUND FLAG
         B     CONVDATE            GO COMPLETE MSG
         SPACE
DISKHDR  STC   R11,DUMPNO          SET DUMP NUMBER
         SPACE
CONVDATE DS    0H
         IFON  XADUMP,TIMEXA                               *LBD 12/85*
         LA    R1,12(R8)           LOAD TOD TIME ADDR
         B     HTIME                                       *LBD 12/85*
TIMEXA   LA    R1,16(R8)          TIME ADDR FOR XA DUMP    *LBD 12/85*
HTIME    DS    0H                                          *LBD 12/85*
         CALL  TODDEC,((R1))       CONVERT TOD TO TIME & DATE
         STM   R0,R1,TIMEDATE      SAVE CONVERTED TIME & DATE
         CALL  CDATE,(DUMPDATE,TIMEDATE+5),VL  CONVERT DATE TO CALENDAR
         MVC   DUMPTIME,EDMASK2    LOAD EDIT MASK
         ED    DUMPTIME,TIMEDATE   EDIT TIME INTO MSG
         UNPK  DUMPASID(3),PRDASID+1  CONVERT ASID
         TR    DUMPASID,HEXTABLE   CONVERT ALPHA
         MVI   DUMPASID+2,BLANK    BLANK GARBAGE BYTE
         IFON  XADUMP,TITXA                                *LBD 12/85*
         MVC   DUMPMSG,20(R8)      MOVE PART OF TITLE TO MSG
         MVC   DUMPTY,=C'370'     SET AS 370 DUMP          *LBD 12/85*
         B     SKTIT                                       *LBD 12/85*
TITXA    MVC   DUMPMSG,32(R8)      MOVE XA TITLE           *LBD 12/85*
         MVC   DUMPTY,=CL3'XA'    SET AS XA DUMP           *LBD 12/85*
SKTIT    DS    0H                                          *LBD 12/85*
         LA    R9,MSG3             LOAD MSG ADDRESS
         LA    R1,M3-1             LOAD END OF MSG ADDRESS
EOTLOOP  CLI   0(R1),BLANK         IS THIS END OF TITLE
         BNE   TITLEEND            IF YES GET OUT OF LOOP
         BCT   R1,EOTLOOP          LOOP TILL END OF TITLE IS FOUND
TITLEEND SR    R1,R9               FIND TOTAL MSG LENGTH
         LA    R1,1(R1)            INCLUDE LAST BYTE
         STH   R1,MSG3             SET CORRECT MSG LENGTH
         BAL   R10,DISPWTO         GO DISPLAY MSG
         OI    CNTLFLAG,HDRFLAG    SET TITLE DISPLAYED FLAG
         SPACE
*        SEARCH FOR 1ST SUMDUMP RECORD
         SPACE
SDMPSTRT GET   SYSUT1              READ DUMP RECORD
         LA    R7,1(R7)            BUMP RECORD COUNT
         LR    R8,R1               LOAD DUMP REC BASE REG
         CLC   SDUMPKEY,PRDASID    IS THIS A SUMDUMP RECORD
         BNE   SDMPSTRT            IF NOT CONTINUE READING
         LA    R5,PRDDATA          LOAD START OF SUMDUMP LOGICAL REC
         USING SMDLR,R5
         OI    CNTLFLAG,SDMPFLAG   SET SUMDUMP FOUND FLAG
         LH    R3,DCBLRECL         LOAD TOTAL RECORD LENGTH
         LA    R3,0(R3,R8)         FIND END OF RECORD ADDRESS
         SPACE
*        LOOP THRU SUMDUMP LOGICAL RECORDS
         SPACE
SDMPLOOP LA    R1,SMDLRDAT         LOAD END OF HEADER ADDRESS
         CR    R1,R3               IS HEADER SPLIT BETWEEN RECS
         BH    PARTHDR             IF YES GO MOVE EACH PART
FULLHDR  MVC   SUMDHDR,SMDLRHDR    MOVE HEADER TO WORK AREA
         B     SDMPCHK             GO CHECK RECORD TYPE
PARTHDR  SR    R3,R5               FIND LENGTH OF 1ST HALF OF HDR
         BCTR  R3,0                DECREMENT FOR EX ISN
         EX    R3,HDRMOVE          MOVE 1ST HALF TO WORK AREA
         LA    R3,1(R3)            RESET LENGTH TO TRUE VALUE
         GET   SYSUT1              READ DUMP RECORD
         LA    R7,1(R7)            BUMP RECORD COUNT
         LR    R8,R1               LOAD DUMP REC BASE REG
         CLC   SDUMPKEY,PRDASID    IS THIS A SUMDUMP RECORD
         BNE   SDMPBAD             IF NOT QUIT
         LA    R1,SUMDHDR(R3)      FIND START OF 2ND HALF OF HDR
         MVC   0(16,R1),PRDDATA    MOVE MAX LENGTH OF 2ND HALF
         LA    R5,PRDDATA          LOAD START OF SUMDUMP LOGICAL REC
         SR    R5,R3               BACK UP BASE TO PSEUDO START
         LH    R3,DCBLRECL         LOAD TOTAL RECORD LENGTH
         LA    R3,0(R3,R8)         FIND END OF RECORD ADDRESS
         SPACE
*        FORMAT SUMDUMP RECORD DATA
         SPACE
SDMPCHK  CLI   SUMDID0,0           IS LOGICAL REC ID VALID
         BNE   SDMPBAD             IF NOT QUIT
         CLI   SUMDID1,SMDEOD      IS THIS LAST SUMDUMP RECORD
         BE    CNTCHK              IF YES ALL SUMDUMP RECORDS COMPLETE
         CLI   SUMDID1,SMDRTM2A    IS THIS THE RTM2 RECORD
         BE    SDMPRTM             IF YES GO FORMAT SELECTED RTM DATA
         CLI   SUMDID1,SMDASIDR    IS THIS THE IDENTIFICATION RECORD
         BNE   SDMPNEXT            IF YES ALL SUMDUMP RECORDS COMPLETE
         SPACE
*        MOVE IDENTIFICATION RECORD TO WORK AREA
         SPACE
SDMPJOB  L     R15,SUMDLNGH        LOAD DATA LENGTH
         CH    R15,MINJOBLN        IS RECORD LONG ENOUGH
         BL    SDMPNEXT            IF NOT SKIP IT
         LA    R1,SMDLRDAT(R15)    LOAD END OF RECORD ADDRESS
         CR    R1,R3               DOES RECORD SPAN DUMP RECORDS
         BH    PARTJOB             IF YES GO MOVE EACH PART
FULLJOB  MVC   SUMDJBID,SMDLRDAT   MOVE ID RECORD TO WORK AREA
         B     FMTJOB              GO FORMAT ID RECORD
PARTJOB  LA    R1,SMDLRDAT         LOAD START OF ID DATA
         SR    R3,R1               FIND PARTIAL LENGTH
         BCTR  R3,0                DECREMENT FOR EX ISN
         EX    R3,JOBMOVE          MOVE 1ST HALF OF ID RECORD
         LA    R3,1(R3)            CORRECT PARTIAL LENGTH
         GET   SYSUT1              READ DUMP RECORD
         LA    R7,1(R7)            BUMP RECORD COUNT
         LR    R8,R1               LOAD DUMP REC BASE REG
         CLC   SDUMPKEY,PRDASID    IS THIS A SUMDUMP RECORD
         BNE   SDMPBAD             IF NOT QUIT
         LA    R1,SUMDHDR(R3)      FIND START OF 2ND HALF OF HDR
         MVC   0(24,R1),PRDDATA    MOVE MAX LENGTH OF 2ND HALF
         LA    R5,PRDDATA          LOAD START OF SUMDUMP LOGICAL REC
         LA    R3,20(R3)           ADD HDR LENGTH
         SR    R5,R3               BACK UP BASE TO PSEUDO START
         LH    R3,DCBLRECL         LOAD TOTAL RECORD LENGTH
         LA    R3,0(R3,R8)         FIND END OF RECORD ADDRESS
         SPACE
*        FORMAT IDENTIFICATION RECORD
         SPACE
FMTJOB   MVC   JOBNAME,SUMDJOBN    MOVE JOBNAME OR USERID TO MSG
         UNPK  ASID(5),SUMDASID(3) SUMDUMP ASID
         TR    ASID,HEXTABLE       CONVERT ALPHA
         MVI   ASID+4,BLANK        BLANK GARBAGE BYTE
         MVC   STEPNAME,SUMDSTEP   MOVE STEPNAME/PROCSTEP TO MSG
         LA    R9,MSG10            LOAD MSG ADDRESS
         BAL   R10,DISPLAY         PRINT SUMDUMP JOBNAME & ASID
         B     SDMPNEXT            GO CHECK NEXT SUMDUMP REC
         SPACE
JOBMOVE  MVC   SUMDJOBN(0),SMDLRDAT  MOVE PARTIAL ID REC TO WORK AREA
         SPACE
*        MOVE RTM2 RECORD TO WORK AREA
         SPACE
SDMPRTM  L     R15,SUMDLNGH        LOAD DATA LENGTH
         CH    R15,MINRTMLN        IS RECORD LONG ENOUGH
         BL    SDMPNEXT            IF NOT SKIP IT
         LH    R15,MINRTMLN        LOAD LENGTH OF RECORD USED
         LA    R1,SMDLRDAT(R15)    LOAD END OF RECORD ADDRESS
         CR    R1,R3               DOES RECORD SPAN DUMP RECORDS
         BH    PARTRTM             IF YES GO MOVE EACH PART
FULLRTM  MVC   SUMDRTM,SMDLRDAT    MOVE RTM RECORD TO WORK AREA
         B     FMTRTM              GO FORMAT ID RECORD
PARTRTM  LA    R1,SMDLRDAT         LOAD START OF RTM DATA
         SR    R3,R1               FIND PARTIAL LENGTH
         BCTR  R3,0                DECREMENT FOR EX ISN
         EX    R3,RTMMOVE1         MOVE 1ST HALF OF RTM RECORD
         LA    R3,1(R3)            CORRECT PARTIAL LENGTH FOR 1ST HALF
         GET   SYSUT1              READ DUMP RECORD
         LA    R7,1(R7)            BUMP RECORD COUNT
         LR    R8,R1               LOAD DUMP REC BASE REG
         CLC   SDUMPKEY,PRDASID    IS THIS A SUMDUMP RECORD
         BNE   SDMPBAD             IF NOT QUIT
         LA    R1,SUMDRTM(R3)      FIND START OF 2ND HALF OF HDR
         LH    R15,MINRTMLN        LOAD DATA LENGTH USED
         SR    R15,R3              FIND 2ND PARTIAL LENGTH
         BCTR  R15,0               DECREMENT FOR EX ISN
         EX    R15,RTMMOVE2        MOVE 2ND HALF OF RTM RECORD
         LA    R5,PRDDATA          LOAD START OF SUMDUMP LOGICAL REC
         LA    R3,20(R3)           ADD HDR LENGTH TO 1ST HALF LENGTH
         SR    R5,R3               BACK UP BASE TO PSEUDO START
         LH    R3,DCBLRECL         LOAD TOTAL RECORD LENGTH
         LA    R3,0(R3,R8)         FIND END OF RECORD ADDRESS
         SPACE
*        FORMAT SELECTED DATA FROM RTM2 RECORD
         SPACE
FMTRTM   EQU   *
         SPACE
FMTPGM   CLI   SUMDPGM,BLANK       IS PROGRAM NAME PRESENT
         BNH   FMTABEND            IF NOT SKIP MSG
         MVC   PGMNAME,SUMDPGM     LOAD FAILING PROGRAM NAME
         UNPK  ENTRYPT(7),SUMDPGEP+1  CONVERT ENTRY POINT ADDR
         TR    ENTRYPT,HEXTABLE    CONVERT ALPHA
         LA    R9,MSG13            LOAD MSG ADDRESS
         BAL   R10,DISPLAY         PRINT SUMDUMP PSW MSG
         SPACE
FMTABEND UNPK  ABECODE(9),SUMDCODE(5)  CONVERT COMPLETION CODE
         TR    ABECODE,HEXTABLE    CONVERT ALPHA
         MVI   ABECODE+8,BLANK     BLANK GARBAGE BYTE
         UNPK  TCBAD(7),SUMDTCB+1  CONVERT TCB ADDRESS
         TR    TCBAD,HEXTABLE      CONVERT ALPHA
         MVI   TCBAD+6,BLANK       BLANK GARBAGE BYTE
         UNPK  RTMFLAGS(9),SUMDFLAG(5)  CONVERT REASON FLAGS
         TR    RTMFLAGS,HEXTABLE   CONVERT ALPHA
         LA    R9,MSG11            LOAD MSG ADDRESS
         BAL   R10,DISPLAY         PRINT SUMDUMP ABEND CODE MSG
         SPACE
FMTPSW   LA    R9,MSG12            LOAD MSG ADDRESS
         ICM   R1,15,SUMDPSW+8     IS A PSW PRESENT
         BZ    FMTREGS             IF NOT SKIP PSW MSG
         MVC   M12KEY,PSWKEY       MOVE LINE TYPE TO MSG
         UNPK  M12WD1(9),SUMDPSW+00(5) CONVERT PSW WORD 1
         UNPK  M12WD2(9),SUMDPSW+04(5) CONVERT PSW WORD 2
         UNPK  M12WD3(9),SUMDPSW+08(5) CONVERT PSW ICL & INTERUPT
         UNPK  M12WD4(9),SUMDPSW+12(5) CONVERT TRANSLATION ADDRESS
         TR    M12WD1(M12-M12WD1),HEXTABLE  CONVERT ALPHA
         MVI   M12WD1+8,BLANK      BLANK GARBAGE BYTE
         MVI   M12WD2+8,BLANK      BLANK GARBAGE BYTE
         MVI   M12WD3+8,BLANK      BLANK GARBAGE BYTE
         BAL   R10,DISPLAY         DISPLAY SUMDUMP PSW MSG
         SPACE
FMTREGS  MVC   M12KEY,REGKEY       MOVE LINE TYPE TO MSG
         UNPK  M12WD1(9),SUMDREGS+00(5) CONVERT REG 0
         UNPK  M12WD2(9),SUMDREGS+04(5) CONVERT REG 1
         UNPK  M12WD3(9),SUMDREGS+08(5) CONVERT REG 2
         UNPK  M12WD4(9),SUMDREGS+12(5) CONVERT REG 3
         TR    M12WD1(M12-M12WD1),HEXTABLE  CONVERT ALPHA
         MVI   M12WD1+8,BLANK      BLANK GARBAGE BYTE
         MVI   M12WD2+8,BLANK      BLANK GARBAGE BYTE
         MVI   M12WD3+8,BLANK      BLANK GARBAGE BYTE
         BAL   R10,DISPLAY         DISPLAY SUMDUMP REGS 0 - 3
         SPACE
         MVC   M12KEY,BLANKS       MOVE LINE TYPE TO MSG
         UNPK  M12WD1(9),SUMDREGS+16(5) CONVERT REG 4
         UNPK  M12WD2(9),SUMDREGS+20(5) CONVERT REG 5
         UNPK  M12WD3(9),SUMDREGS+24(5) CONVERT REG 6
         UNPK  M12WD4(9),SUMDREGS+28(5) CONVERT REG 7
         TR    M12WD1(M12-M12WD1),HEXTABLE  CONVERT ALPHA
         MVI   M12WD1+8,BLANK      BLANK GARBAGE BYTE
         MVI   M12WD2+8,BLANK      BLANK GARBAGE BYTE
         MVI   M12WD3+8,BLANK      BLANK GARBAGE BYTE
         BAL   R10,DISPLAY         DISPLAY SUMDUMP REGS 4 - 7
         SPACE
         UNPK  M12WD1(9),SUMDREGS+32(5) CONVERT REG 8
         UNPK  M12WD2(9),SUMDREGS+36(5) CONVERT REG 9
         UNPK  M12WD3(9),SUMDREGS+40(5) CONVERT REG 10
         UNPK  M12WD4(9),SUMDREGS+44(5) CONVERT REG 11
         TR    M12WD1(M12-M12WD1),HEXTABLE  CONVERT ALPHA
         MVI   M12WD1+8,BLANK      BLANK GARBAGE BYTE
         MVI   M12WD2+8,BLANK      BLANK GARBAGE BYTE
         MVI   M12WD3+8,BLANK      BLANK GARBAGE BYTE
         BAL   R10,DISPLAY         DISPLAY SUMDUMP REGS 8 - 11
         SPACE
         UNPK  M12WD1(9),SUMDREGS+48(5) CONVERT REG 12
         UNPK  M12WD2(9),SUMDREGS+52(5) CONVERT REG 13
         UNPK  M12WD3(9),SUMDREGS+56(5) CONVERT REG 14
         UNPK  M12WD4(9),SUMDREGS+60(5) CONVERT REG 15
         TR    M12WD1(M12-M12WD1),HEXTABLE  CONVERT ALPHA
         MVI   M12WD1+8,BLANK      BLANK GARBAGE BYTE
         MVI   M12WD2+8,BLANK      BLANK GARBAGE BYTE
         MVI   M12WD3+8,BLANK      BLANK GARBAGE BYTE
         BAL   R10,DISPLAY         DISPLAY SUMDUMP REGS 12 - 15
         B     SDMPNEXT            GO TO NEXT LOGICAL RECORD
         SPACE
RTMMOVE1 MVC   SUMDRTM(0),SMDLRDAT MOVE PART OF RTM REC TO WORK AREA
RTMMOVE2 MVC   0(0,R1),PRDDATA     MOVE PART OF RTM REC TO WORK AREA
         SPACE
*        GET NEXT SUMDUMP LOGICAL RECORD
         SPACE
SDMPNEXT LA    R1,SMDLRDAT         GET START OF CURRENT LOG REC DATA
         A     R1,SUMDLNGH         FIND START OF NEXT LOGICAL RECORD
         CR    R1,R3               IS NEXT LOG REC IN CURRENT DUMP REC
         BH    SDMPSPAN            IF NOT CUR LOG REC SPANS DUMP REC
         BE    SDMPNEW             IF EQUAL NEXT LOG REC = DUMP REC
         LR    R5,R1               UPDATE LOGICAL RECORD BASE REG
         B     SDMPLOOP            GO CHECK NEXT LOGICAL REC
SDMPNEW  GET   SYSUT1              READ DUMP RECORD
         LA    R7,1(R7)            BUMP RECORD COUNT
         LR    R8,R1               LOAD DUMP REC BASE REG
         LH    R3,DCBLRECL         LOAD TOTAL RECORD LENGTH
         LA    R3,0(R3,R8)         FIND END OF RECORD ADDRESS
         CLC   SDUMPKEY,PRDASID    IS THIS A SUMDUMP RECORD
         BNE   SDMPBAD             IF NOT QUIT
         LA    R5,PRDDATA          LOAD START OF SUMDUMP LOGICAL REC
         B     SDMPLOOP            GO CHECK NEXT LOGICAL REC
SDMPSPAN SR    R1,R3               FIND LENGTH REMAINING
         LR    R5,R1               COPY DATA LENGTH REMAINING
SDMPSPLP GET   SYSUT1              READ DUMP RECORD
         LA    R7,1(R7)            BUMP RECORD COUNT
         LR    R8,R1               LOAD DUMP REC BASE REG
         LH    R3,DCBLRECL         LOAD TOTAL RECORD LENGTH
         LA    R3,0(R3,R8)         FIND END OF RECORD ADDRESS
         CLC   SDUMPKEY,PRDASID    IS THIS A SUMDUMP RECORD
         BNE   SDMPBAD             IF NOT QUIT
         LA    R1,PRDDATA          GET START OF NEXT DUMP REC
         AR    R1,R5               FIND START OF NEXT LOGICAL RECORD
         CR    R1,R3               IS NEXT LOG REC IN CURRENT DUMP REC
         BH    SDMPSPNX            IF NOT GET NEXT DUMP REC
         BE    SDMPNEW             IF EQUAL NEXT LOG REC = DUMP REC
         LR    R5,R1               LOAD START OF SUMDUMP LOGICAL REC
         B     SDMPLOOP            GO CHECK NEXT LOGICAL REC
SDMPSPNX SH    R5,H4K              DECREMENT LENGTH FOR NEXT REC
         B     SDMPSPLP            GO GET NEXT DUMP REC FOR SPAN
         SPACE
HDRMOVE  MVC   SUMDHDR(0),SMDLRHDR  MOVE PARTIAL HDR TO WORK AREA
         SPACE
SDMPBAD  LA    R9,MSG15            LOAD MSG ADDRESS
         BAL   R10,DISPLAY         PRINT ERROR MSG
         SPACE
*        COUNT ALL REMAINING RECORDS IN DUMP IF SPECIFIED
         SPACE
CNTCHK   TM    CNTLFLAG,CNTREC     IS RECORD COUNTING SPECIFIED
         BZ    CLOSE               IF NOT GO CLOSE DCB
CNTLOOP  GET   SYSUT1              READ DUMP RECORD
         LA    R7,1(R7)            BUMP RECORD COUNT
         LR    R8,R1               LOAD DUMP REC BASE REG
         B     CNTLOOP             LOOP THUR ALL RECORDS
         SPACE
*        DISPLAY EMPTY DUMP UNLESS A RECORD WAS READ
         SPACE
UT1END   EQU   *
         CLI   DEVCLASS,TAPE       IS DEVICE TAPE
         BE    TAPECOMP            IF YES NO MORE DUMPS
         TM    CNTLFLAG,HDRFLAG    WAS TITLE DISPLAYED
         BO    CNTMSGCK            IF YES GO CHECK RECORD COUNT
         TM    CNTLFLAG,RECFLAG    WERE ANY RECORDS FOUND
         BO    BADFMT              IF YES ASSUME BAD FORMAT
EMPTYMSG MVC   EMPTYSER,JFCBVOLS   LOAD VOLUME SERIAL
         STC   R11,EMPTYNO         SET DUMP NUMBER
         LA    R9,MSG4             LOAD MSG ADDRESS
         BAL   R10,DISPWTO         GO DISPLAY MSG
         B     CLOSE               SKIP RECORD COUNT MSG
         SPACE
*        PRINT RECORDS IN DATA SET IF SPECIFIED
         SPACE
CNTMSGCK TM    CNTLFLAG,CNTREC     IS RECORD COUNTING SPECIFIED
         BZ    CLOSE               IF NOT SKIP MSG
         CVD   R7,WORK             CONVERT RECORD COUNT
         MVC   RECCNT,EDMASK1      LOAD EDIT MASK
         ED    RECCNT,WORK+5       EDIT RECORD COUNT INTO PRINT LINE
         LA    R9,MSG9             LOAD MSG ADDRESS
         BAL   R10,DISPLAY         DISPLAY RECORD COUNT
         SPACE
CLOSE    CLOSE (SYSUT1,LEAVE)      CLOSE DUMP DCB
         SPACE
         PUTMSG  MSG14             PRINT BLANK LINE
         SPACE
*        LOOP THRU ALL DUMPS ON VOLUME
         SPACE
NEXTDUMP CLI   DEVCLASS,TAPE       IS DEVICE TAPE
         BE    BUMPDUMP            IF YES GO BUMP FILE NUMBER
         CLI   DUMPNUMB,DUMPMAX    IS THIS LAST DUMP DATA SET
         BE    DUMPCOMP            IF YES ALL DUMP DATA SETS PROCESSED
BUMPDUMP LA    R11,1(R11)          BUMP DUMP OR FILE NUMBER
         SPACE
*        CHECK OPERATOR FOR STOP REQUEST
         SPACE
OPERCHK  EQU   *
         CLI   OPECB,0             DID OPERATOR REPLY
         BZ    NOSTOP              IF NOT CONTINUE TEST
         L     R7,CIBADDR          LOAD CIB BASE REG
         USING CIB,R7
STOPCHK  CLI   CIBVERB,CIBSTOP     WAS STOP COMMAND ISSUED
         BE    STOPJOB             IF YES SKIP REMAINING DUMPS
NOSTOP   CLI   DEVCLASS,DISK       IS DEVICE DISK
         BE    DISKLOOP            LOOP THRU ALL DISK DUMP DATA SETS
         B     TAPELOOP            LOOP THRU ALL TAPE DUMP FILES
         SPACE
*        END OF TAPE VOLUME
         SPACE
TAPECOMP CLOSE  (SYSUT1,REWIND)    CLOSE DUMP TAPE DCB
         SPACE
*        CHECK IF ANY DUMP DATA SETS WERE FOUND
         SPACE
DUMPCOMP EQU   *
         TM    CNTLFLAG,ALLDUMP    IS ALL DD STMT SCAN SPECIFIED
         BO    TIOTNEXT            IF YES LOOP THUR ALL TIOT ENTRIES
         TM    CNTLFLAG,DUMPFLAG   WERE ANY DUMP DATA SETS FOUND
         BO    RETURN              IF YES RETURN TO CALLER
         SPACE
*        NO DUMP DATA SETS FOUND ON VOLUME
         SPACE
         MVC   NODMPSER,JFCBVOLS   LOAD VOLUME SERIAL
         LA    R9,MSG6             LOAD MSG ADDRESS
         BAL   R10,DISPWTO         GO DISPLAY MSG
         SPACE
RETURN   CLOSE SYSPRINT            CLOSE OPTIONAL PRINT DCB
         SR    R15,R15             ZERO RETURN CODE REG
         IC    R15,RETCODE         LOAD RETURN CODE
         TM    STOPFLAG,DEBUGOPT   IS DEBUG OPTION SPECIFIED
         BO    ABEND               IF YES GO ABEND
         L     R13,SAVEAREA+4
         RETURN  (14,12),RC=(15)   RETURN TO CALLER
         SPACE
STOPJOB  EQU   *
         B     RETURN              RETURN TO CALLER
         SPACE
ABEND    ABEND (R15),DUMP          ABEND WITH DUMP
*
*        DUMP DATA SET I/O ERROR EXIT
*
UT1ERR   EQU   *
         OI    CNTLFLAG,RECERR     SET RECORD I/O ERROR FLAG
         BR    R14                 RETURN TO SYSTEM
         EJECT
*        ERROR EXITS
         SPACE
BADOPEN  EQU   *
         MVI   RETCODE,16          SET RETURN CODE
         B     RETURN              GO RETURN TO CALLER
         SPACE
BADDEVT  MVI   RETCODE,20          SET RETURN CODE
         B     RETURN              GO RETURN TO CALLER
         SPACE
NOPRNT   MVI   RETCODE,32          SET RETURN CODE
         B     RETURN              GO RETURN TO CALLER
         EJECT
*        DISPLAY MSG TO INPUT SOURCE AND SYSPRINT
         SPACE
         USING WPLRF,R9
DISPLAY  TM    CNTLFLAG,DISPCON    IS OPERATOR DISPLAY SPECIFIED
         BZ    DISPMSG             IF NOT SKIP OPERATOR DISPLAY
         SPACE
DISPWTO  CLI   STRTFLAG,STRTTASK   IS THIS A STARTED TASK
         BNE   DISPMSG             IF NOT SKIP WTO
         OI    WPLMCSF1,WPLMCSFB   SET REG 0 SWITCH
         SR    R0,R0               ZERO CONSOLE ID REG
         IC    R0,CONID            LOAD CONSOLE ID
         WTO   MF=(E,(R9))         ISSUE OPERATOR MSG
         SPACE
DISPMSG  MVI   WPLMCSF1,0          CLEAR MSG SWITCH
         PUTMSG  (R9)              PRINT MSG
         BR    R10                 RETURN TO CALLER
         EJECT
*        TAPE TIMER EXIT ROUTINE
         SPACE
TIMEEXIT SAVE  (14,3)              SAVE REGS
         LR    R3,R15              LOAD BASE REG
         USING TIMEEXIT,R3
         PURGE PURGELST            STOP TAPE I/O
         OI    CNTLFLAG,RECERR     SET ERROR FLAG
         ST    R15,PURGERET        SAVE RETURN CODE
         WTO   'CHKDUMP TAPE TIMEOUT',ROUTCDE=3,DESC=7
         CLOSE SYSPRINT            CLOSE PRINT DCB
         ABEND 8,DUMP              ABEND TO STOP TAPE
         RETURN  (14,3)            RETURN TO SYSTEM
         DROP   R3
         EJECT
UT1OPEN  TM    CNTLFLAG,CNTREC     IS RECORD COUNTING SPECIFIED
         BZR   R14                 IF NOT RETURN
         CLI   DCBBUFNO,0          IS BUFFER NUMBER SPECIFIED
         BNZR  R14
         MVI   DCBBUFNO,CNTBUFNO   SET BUFFER NUMBER
         BR    R14
         EJECT
         REGEQU
FF       EQU   255                 NI ISN MASK
F0       EQU   X'F0'               NI ISN MASK
MCSROUT  EQU   X'80'               MCS DESCRIPTOR CODE & ROUT CODE FLAG
MCSREG0  EQU   X'40'               MCS CONSOLE ID IN REG 0 FLAG
BLANK    EQU   C' '                EBCDIC BANK
DUMPZERO EQU   C'0'                MINIMUM DUMP NUMBER
DUMPMAX  EQU   C'9'                MAXIMUM DUMP NUMBER
CNTBUFNO EQU   10                  DEFAULT DCBBUFNO IF COUNT SPECIFIED
SAVEAREA DC    18F'0'              PROGRAM SAVEAREA
         EXTRN SYSPRINT,TITLE1,TITLE2,LINECNT,LINE
TITLE1AD DC    A(TITLE1)           ADDRESS OF 1ST TITLE POINTER
TITLE2AD DC    A(TITLE2)           ADDRESS OF 2ND TITLE POINTER
LINECNTA DC    A(LINECNT)          ADDRESS OF MAX LINES PER PAGE
LINEAD   DC    A(LINE)             ADDRESS OF CURRENT LINE NUMBER
*
*        DEVICE TYPE INFORMATION
*
DEVCONS  DC    F'0'                DEVTYPE
DEVCLASS EQU   DEVCONS+2,1,C'X'    DEVICE CLASS
DISK     EQU   X'20'               DISK DEVICE CLASS
TAPE     EQU   X'80'               TAPE DEVICE CLASS
TRKLNGH  DC    F'0'                TRACK LENGTH
PHYCYL   DS    H                   PHYSICAL NUMBER OF CYLINDERS
TRKPRCYL DS    H                   TRACKS PER CYLINDER
         DS    2F                  UNUSED DEVICE VALUES
SUMDHDR  DS    0XL20               STANDARD SUMDUMP HEADER
SUMDID0  DS    X                   1ST BYTE OF LOG REC ID
SUMDID1  DS    X                   2ND BYTE OF LOG REC ID
         DS    H                   NOT USED
         DS    2F                  NOT USED
SUMDLNGH DS    F                   ACTUAL LOG REC DATA LENGTH
         DS    F                   NOT USED
SUMDJBID DS    0XL26               IDENTIFICATION RECORD
SUMDASID DS    XL2                 SUMDUMP RECORD ASID
SUMDJOBN DS    CL8                 JOBNAME
SUMDSTEP DS    CL16                STEPNAME & PROCSTEP
         ORG   SUMDJBID
SUMDRTM  DS    0XL204              SUMDUMP RTM2 RECORD
         ORG   SUMDRTM+X'10'
SUMDTCB  DS    A                   TCB ADDRESS
         ORG   SUMDRTM+X'1C'
SUMDCODE DS    XL4                 COMPLETION CODE
         ORG   SUMDRTM+X'3C'
SUMDREGS DS    XL64                REGS 0-15
SUMDPSW  DS    XL16                PSW, ICL, INT, XLAT ADDR
SUMDPGM  DS    CL8                 FAILING PGM NAME
SUMDPGEP DS    A                   FAILING PGM ENTRY POINT
         ORG   SUMDRTM+X'B4'
SUMDFLAG DS    0XL4                RTM REASON & COND FLAGS
SMDERRA  DS    X                   ERROR TYPE CAUSING ENTRY
SMDMCHK  EQU   X'80'               MACHINE CHECK
SMDPCHK  EQU   X'40'               PROGRAM CHECK
SMDRKEY  EQU   X'20'               RESTART KEY DEPRESSED
SMDSVCD  EQU   X'10'               SVC 13 ISSUED
SMDABTM  EQU   X'08'               ENTRY VIA ABTERM
SMDSVCE  EQU   X'04'               SVC ISSUED BY LOCKED OR SRB ROUTINE
SMDTEXC  EQU   X'02'               UNRECOVERABLE TRANSLATION FAILURE
SMDPGIO  EQU   X'01'               PAGE I/O ERROR
SMDERRB  DS    X                   ADDITIONAL ERROR ENTRY INFORMATION
SMDTYP1  EQU   X'08'               TYPE 1 SVC IN CONTROL
SMDENRB  EQU   X'02'               ENABLED RB IN CONTROL
SMDSRBM  EQU   X'01'               SRB MODE
SMDERRC  DS    X                   ADDITIONAL ERROR ENTRY INFORMATION
SMDSTAF  EQU   X'80'               PREVIOUS (E)STAE EXIT FAILED
SMDSTAI  EQU   X'40'               (E)STAE EXIT PREVIOUSLY RECVD CNTL
SMDIRB   EQU   X'20'               IRB PRECEDED RB IN ERROR
SMDPERC  EQU   X'10'               PERCOLATED ENTRY
SMDEAS   EQU   X'08'               LOW LEVEL EXIT RECOVERY
SMDERRD  DS    X                   ADDITIONAL ERROR ENTRY INFORMATION
SMDCLUP  EQU   X'80'               REC ROUT CLEAN UP / NO RETRY
SMDNRBE  EQU   X'40'               RB ASSOC WITH EXIT NOT IN CONTROL
SMDSTAE  EQU   X'20'               THIS ESTAE HAS BEEN FOR PREV ABEND
SMDCTS   EQU   X'10'               ANOTHER TASK SPECIFIED 'STEP' ABEND
SMDMABD  EQU   X'08'               PREVIOUS TASK HAS ABENDED
SMDRPIV  EQU   X'04'               REGS & PSW NOT AVAILABLE
SMDMCIV  EQU   X'02'               MACHINE CHECK ERROR INFO NOT AVAIL
SMDERFL  EQU   X'01'               ERRORID INFORMATION AVAILABLE
IOTIME   DC    F'3000'             30 SECOND TIMER VALUE
PURGELST DS    0F                  PURGE PARM LIST
         DC    X'E1'               PURGE OPTIONS
PRGDEBAD DC    AL3(0)              DEB ADDRESS
PRGTCBAD DC    A(0)                TCB ADDRESS
PRGIOBAD DC    A(PRGCHAIN)         IOB ADDRESS
PRGRETCD DC    A(0)                RETURN CODE
         DC    F'0'
PRGCHAIN DC    A(0)                RESTART CHAIN
PURGERET DC    F'0'                PURGE R15 RETURN CODE
WORK     DS    D                   CONVERSION WORK AREA
TIMEDATE DS    2F                  DECIMAL TIME & DATE OF DUMP
TIOTAD   DC    A(0)                ADDRESS OF TIOT
COMMAD   DC    A(0)                COMM AREA ADDRESS
TSOTJID  DC    F'0'                TSO USER ID
DSCBWORK EQU   SUMDJBID,148        OBTAIN WORK AREA
DUMPDSCB CAMLST  SEARCH,JFCBDSNM,JFCBVOLS,DSCBWORK  OBTAIN PARM LIST
         IEFJFCBN  LIST=YES        SYSUT1 JFCB
DUMPNUMB EQU   JFCBDSNM+10,1       LAST CHARACTER OF DUMP DSNAME
H1       DC    H'1'                HALF WORD CONSTANT
H8       DC    H'8'                MAX LENGTH OF COUNT PARM
H4K      DC    H'4096'             4 K CONSTANT
MINJOBLN DC    H'26'               MIN LENGTH OF ID RECORD
MINRTMLN DC    H'204'              MIN LENGTH OF RTM RECORD
SDUMPKEY DC    AL2(SMDPASID)       PSEUDO ASID FOR SUMDUMP RECORDS
RETCODE  DC    X'0'                PROGRAM RETURN CODE
CNTLFLAG DC    X'0'                CONTROL FLAG
DUMPFLAG EQU   128                 DUMP FOUND FLAG
ALLDUMP  EQU   64                  SCAN ALL DD STATEMENTS
CNTREC   EQU   32                  COUNT ALL DUMP RECORDS
DISPCON  EQU   16                  DISPLAY ALL MSGS ON CONSOLE
SDMPFLAG EQU   8                   SUMDUMP RECORDS FOUND
HDRFLAG  EQU   4                   TITLE DISPLAYED FLAG
RECFLAG  EQU   2                   SOME RECORD READ FLAG
RECERR   EQU   1                   DUMP RECORD I/O ERROR FLAG
STRTFLAG DC    X'0'                EXECUTION METHOD FLAG
STRTTSO  EQU   2                   TSO FOREGROUND TASK
STRTTASK EQU   1                   STARTED TASK
STRTBTCH EQU   0                   NORMAL BATCH JOB
STOPFLAG DC    X'0'                TEST TERMINATION OPTIONS
DEBUGOPT EQU   16                  DEBUG OPTION (ABEND WITH DUMP
OPERSTOP EQU   8                   OPERATOR ISSUED STOP COMMAND
CONID    DC    X'0'                STARTED TASK CONSOLE ID FLAG
SYS      DC    C'SYS'              SYSXXXXX DDNAME CONSTANT
JOBLIB   DC    C'JOBLIB '          JOBLIB DDNAME CONSTANT
STEPLIB  DC    C'STEPLIB '         STEPLIB DDNAME CONSTANT
PSWKEY   DC    C'PSW='             PSW LINE TYPE
REGKEY   DC    C'REG='             REGS LINE TYPE
STDDDNAM DC    CL8'IEFRDER'        STANDARD DDNAME
OPTDDNAM DC    CL8'SYSUT1'         OPTIONAL DDNAME
ALL      DC    C'ALL'              ALL DD STATMENT SCAN OPTION
COUNT    DC    C'COUNT'            COUNT DUMP RECORDS OPTION
CONSOLE  DC    C'CONSOLE'          CONSOLE DISPLAY ALL OPTION
DEBUG    DC    C'DEBUG'            DEBUG OPTION ABEND WITH DUMP
DUMPNAME DC    CL44'SYS1.DUMP00'   1ST MVS DIRECT ACCESS DUMP DSN
BLANKS   EQU   *-8,8               BLANK CONSTANT
FILE     DC    C'FILE'             TAPE MSG CONSTANT
EDMASK1  DC    X'402020202120'     FILE SEQUENCE EDIT MASK
EDMASK2  DC    X'4021204B20204B2020'   TOD EDIT MASK (HH.MM.SS)
HEXTABLE EQU   *-240
         DC    C'0123456789ABCDEF'
         SPACE 1                                           *LBD 12/85*
         BITSW XADUMP                                      *LBD 12/85*
         EJECT
         LTORG
         EJECT
SYSUT1   DCB   DSORG=PS,MACRF=GL,DDNAME=IEFRDER,RECFM=U,EXLST=UT1LST,  C
               BLKSIZE=4104,EODAD=UT1END,SYNAD=UT1ERR,EROPT=SKP
UT1LST   DC    X'07',AL3(JFCBDSNM) JFCB ADDRESS
         DC    X'85',AL3(UT1OPEN)  OPEN EXIT
         EJECT
*        PROGRAM MESSAGES
         SPACE
WTO1     DC    Y(W1-*),X'4000'
         DC    C' VOLUME D#   DATE    TIME ID TYPE   TITLE'
W1       EQU   *
         SPACE
MSG1     DC    AL2(M1-*,0)
         DC    C'1       MVS DUMP DISPLAY UTILITY '
CALDATE  DS    CL8                 CALENDAR DATE
TIME     DS    CL9                 HH.MM.SS TIME OF DAY
M1       EQU   *
         SPACE
MSG2     DC    AL2(M2-*,0)
         DC    C' VOLUME D#   DATE    TIME ID TYPE   TITLE'
M2       EQU   *
         SPACE
MSG3     DC    Y(M3-*,0)
         DC    C' '                PRINT CONTROL CHAR
DUMPSER  DS    CL6                 VOLUME SERIAL
         DC    C' '
         DC    C'0'                DISK DUMP MSG CONSTANT
DUMPNO   DS    C                   DISK DUMP NUMBER
         DC    C' '
DUMPDATE DS    CL8                 DUMP DATE
DUMPTIME DS    CL6                 DUMP TIME
         DC    C' '
DUMPASID DS    CL2                 ASID OF DUMP
         DC    C' '
DUMPTY   DC    CL3' '                                      *LBD 12/85*
         DC    C' '                                        *LBD 12/85*
DUMPMSG  DS    CL92                DUMP TITLE
M3       EQU   *
         SPACE
MSG4     DC    Y(M4-*,0)
         DC    C' '                PRINT CONTROL CHAR
EMPTYSER DS    CL6                 VOLUME SERIAL
         DC    C' 0'               DUMP DATA SET NAME
EMPTYNO  DS    C                   DUMP NUMBER
         DC    C'      EMPTY'
M4       EQU   *
         SPACE
MSG5     DC    Y(M5-*,0)
         DC    C' '                PRINT CONTROL CHAR
BDFMTSER DS    CL6                 VOLUME SERIAL
         DC    C' 0'      DUMP DATA SET NAME
BDFMTNO  DS    C                   DUMP NUMBER
         DC    C'      BAD FORMAT'
M5       EQU   *
         SPACE
MSG6     DC    Y(M6-*,0)
         DC    C' '                PRINT CONTROL CHAR
NODMPSER DS    CL6                 VOLUME SERIAL
         DC    C' CONTAINS NO DUMP DATA SETS'
M6       EQU   *
         SPACE
MSG7     DC    Y(M7-*,0)
         DC    C' '                PRINT CONTROL CHAR
         DC    C'UNABLE TO OPEN DUMP DEVICE'
M7       EQU   *
         SPACE
MSG8     DC    Y(M8-*,0)
         DC    C' '                PRINT CONTROL CHAR
         DC    C'DUMP DEVICE NOT TAPE OR DISK'
M8       EQU   *
         SPACE
MSG9     DC    Y(M9-*,0)
         DC    24C' '
RECCNT   DS    CL6                 TOTAL DUMP RECORD COUNT
         DC    C' RECORDS IN DUMP'
M9       EQU   *
         SPACE
MSG10    DC    Y(M10-*,0)
         DC    26C' '
         DC    C'JOB='
JOBNAME  DS    CL8                 JOBNAME FROM SUMDUMP RECORD
         DC    C' ASID='
ASID     DS    CL4                 ASID FROM SUMDUMP RECORD
         DC    C' STEP='
STEPNAME DS    CL16                STEPNAME/PROCSTEP FROM RECORD
M10      EQU   *
         SPACE
MSG11    DC    Y(M11-*,0)
         DC    26C' '
         DC    C'ABEND='
ABECODE  DS    CL8                 ABEND CODE
         DC    C' TCB='
TCBAD    DS    CL6                 TCB ADDRESS
         DC    C' RTM2FLGS='
RTMFLAGS DS    CL8                 RTM2 REASON/COND FLAGS
M11      EQU   *
         DS    C                   GARBAGE BYTE
         SPACE
MSG12    DC    Y(M12-*,0)
         DC    26C' '
M12KEY   DC    C'PSW='
M12WD1   DS    CL8                 FAILING EC PSW 1ST HALF
         DS    C                   BLANK DELIMITER
M12WD2   DS    CL8                 FAILING EC PSW LAST HALF
         DS    C                   BLANK DELIMITER
M12WD3   DS    CL8                 FAILING EC PSW ICL & INTERRUPT
         DS    C                   BLANK DELIMITER
M12WD4   DS    CL8                 FAILING TRANSLATION ADDRESS
M12      EQU   *
         DS    C                   GARBAGE BYTE
         SPACE
MSG13    DC    Y(M13-*,0)
         DC    26C' '
PGMKEY   DC    C'PGM='
PGMNAME  DS    CL8                 FAILING PGM NAME
         DC    C' EP='
ENTRYPT  DS    CL6                 FAILING PGM'S ENTRY PT
M13      EQU   *
         DS    C                   GARBAGE BYTE
         SPACE
MSG14    DC    Y(M14-*,0)
         DC    2C' '
M14      EQU   *
         SPACE
MSG15    DC    Y(M15-*,0)
         DC    25C' '
         DC    C' INVALID SUMDUMP RECORDS FOUND'
M15      EQU   *
         EJECT
         DCBD  DSORG=QS,DEVD=DA
         EJECT
COMSECT  DSECT
ECBADDR  DS    A                   ADDRESS OF MODIFY/STOP ECB
CIBADDR  DS    A                   ADDRESS OF 1ST CIB
         DS    CL8
OPECB    DC    F'0'                OPERATOR REPLY ECB
         EJECT
CIB      DSECT
         IEZCIB
         EJECT
         IEZWPL
         EJECT
PRDINPUT AMDDATA                  * IF 370 ASSEMBLY THEN REMOVE LABEL
         EJECT
         IHASMDLR
         EJECT
TIOT     DSECT
         IEFTIOT1
         END   CHKDUMP
MSGW     TITLE 'MESSAGE WRITER ROUTINE'
         SPACE
*        THIS ROUTINE WILL PRINT A VARIABLE LENGTH ASA MESSAGE ON
*        A SYSPRINT DATA SET WITH SEQUENTIAL PAGE NUMBERING.
*
*        IF THE MESSAGE WILL NOT FIT ON THE EXISTING PAGE IT WILL
*        BE PRINTED ON THE NEXT PAGE.  UP TO 3 TITLES WILL
*        BE INCLUDED IN THE HEADING IF SPECIFIED.
*
*        IF SYSPRINT CANNOT BE OPENED RETURN IS GIVEN TO
*        THE EXTERNAL ENTRY POINT DDRTN.  IF DDRTN IS NOT
*        DEFINED THE TASK WILL BE ABENED WITH A USER CODE OF 16.
*
*        BLKSIZE WILL BE SET TO 700 IF NOT DEFINED OR TO 129
*        IF SPECIFIED 1 THRU 128.
*
*        IF BUFNO IS NOT DEFINED, THE VALUE WILL BE SET TO 1 IF
*        BLKSIZE > 2800 OR MAXIMUM POSSIBLE WITHIN 2800 BYTES.
*
*        LINKAGE
*
*              LA   1,MESSAGE  OR  CALL MSGWTR,MF=(E,MESSAGE)
*              L    15,=V(MSGWTR)
*              BALR 14,15
*
*        REG 15 MUST CONTAIN ENTRY POINT ADDRESS
*        REG 1 MUST POINT TO A VARIABLE LENGTH MESSAGE
*
*        MESSAGE LIMITS
*
*        THE 1ST TITLE MUST NOT EXCEED 109 CHARACTERS.
*        THE REMAINING TITLES AND MESSAGES SHOULD NOT EXCEED 120 CHAR.
*        THE 1ST CHARACTER MUST BE A VALID ASA CONTROL CHARACTER
*        THE ONLY PERMISSABLE CHARACTERS ARE 1, +, BLANK, 0, & -
*
*
*        EXTERNAL ROUTINES
*
*        DDRTN                                   OPEN ERROR RETURN
*        QSAM PUT MOVE VARIABLE LENGTH           OUTPUT
*
*                  ENTRY POINTS AND THEIR USES
*
*        SYMBOL              USE                               DEFAULT
*
*        TITLE1    ADDRESS OF 1ST TITLE PRINTED IN HEADING       (0)
*        TITLE2    ADDRESS OF 2ND TITLE PRINTED IN HEADING       (0)
*        TITLE3    ADDRESS OF 3RD TITLE PRINTED IN HEADING       (0)
*        TITLE     SAME AS TITLE1
*        SUBTITLE  SAME AS TITLE2
*        PAGE      CURRENT PAGE NUMBER                           (0)
*        LINECNT   MAXIMUM NUMBER OF LINES PER PAGE             (42)
*        LINE      NUMBER OF LINES ON CURRENT PAGE               (0)
*        SYSPRINT  SYSPRINT DCB (MAY BE USED TO CLOSE DCB)
*
         SPACE
MSGWTR   CSECT
         ENTRY TITLE1,TITLE2,TITLE3
         ENTRY TITLE,SUBTITLE,PAGE,LINECNT,LINE,SYSPRINT
R0       EQU   0
R1       EQU   1
R2       EQU   2
R3       EQU   3
R4       EQU   4                   MESSAGE CONTROL CHARACTER SAVE REG
R5       EQU   5                   TITLE CONTROL CHARACTER SAVE REG
R6       EQU   6                   SUBTITLE CONTROL CHARACTER SAVE REG
R7       EQU   7                   MESSAGE BASE REG
R8       EQU   8                   TITLE BASE REG
R9       EQU   9                   SUBTITLE BASE REG
R10      EQU   10                  PAGE NUMBER REG
R11      EQU   11                  LINE NUMBER REG
R12      EQU   12                  PROGRAM BASE REG
R13      EQU   13                  SAVEAREA POINTER REG
R14      EQU   14                  RETURN REG
R15      EQU   15
BLANK    EQU   C' '
         USING *,12
         USING MESSAGE,R7
         SPACE
****    INITIALIZE ROUTINE    ****
         SPACE
         SAVE  (14,12),,*
         LR    R12,R15             LOAD PROGRAM BASE REG
         ST    13,SAVEAREA+4       STORE BACKWARD POINTER
         LA    2,SAVEAREA
         ST    2,8(13)             STORE FOREWARD POINTER
         LR    13,2                LOAD SAVEAREA POINTER
         LR    R7,R1               LOAD MESSAGE BASE
         IC    R4,CC               SAVE MESSAGE CONTROL CHARACTER
         SPACE
****    OPEN SYSPRINT IF NOT OPEN    ****
         SPACE
         TM    SYSPRINT+48,X'10'   IS SYSPRINT OPEN
         BO    ITSOPEN
         OPEN  (SYSPRINT,OUTPUT)
         TM    SYSPRINT+48,X'10'   WAS SYSPRINT SUCCESSFULLY OPENED
         BZ    NOPRINT
         B     NEWPAGE
         SPACE
****    ANALYZE MESSAGE CONTROL CHARACTER    ****
         SPACE
ITSOPEN  EQU   *
         CLI   CC,C' '             CHECK CONTROL CHARACTER
         BE    SINGLE
         CLI   CC,C'0'             CHECK CONTROL CHARACTER
         BE    DOUBLE
         CLI   CC,C'-'             CHECK CONTROL CHARACTER
         BE    TRIPLE
         CLI   CC,C'1'             CHECK CONTROL CHARACTER
         BE    NEWPAGE
         CLI   CC,C'+'             CHECK CONTROL CHARACTER
         BE    PRNTMSG
         MVI   CC,C' '             MAKE INVALID CONTROL CHARACTER BLANK
         SPACE
SINGLE   LA    R11,1               LOAD NUMBER OF LINES FOR MESSAGE
         B     LINECHK
         SPACE
DOUBLE   LA    R11,2               LOAD NU4BER OF LINES FOR MESSAGE
         B     LINECHK
         SPACE
TRIPLE   LA    R11,3               LOAD NUMBER OF LINES FOR MESSAGE
         SPACE
LINECHK  EQU   *
         L     R14,LINE            LOAD NUMBER OF LINES USED ON PAGE
         AR    R14,R11             ADD NUMBER OF LINES FOR MESSAGE
         C     R14,LINECNT         WILL LINE FIT ON THIS PAGE
         BH    NEWPAGE             IF NOT START ON A NEW PAGE
         LR    R11,R14             UPDATE LINE NUMBER
         B     PRNTMSG
         SPACE
****    PRINT HEADING FOR NEW PAGE    ****
         SPACE
NEWPAGE  EQU   *
         MVI   CC,C' '             SET CC TO SINGLE SPACE
         LA    R11,3               LOAD LINES FOR HEADING WITHOUT SUBT
         LM    R8,R10,TITLE1       LOAD TITLE POINTERS
         SPACE
*        INITIALIZE HEADING
         SPACE
         MVI   HEADTEXT,BLANK      BLANK 1ST BYTE OF HEADING TEXT
         MVC   HEADTEXT+1(108),HEADTEXT  RIPPLE REMAINDER OF FIELD
         LTR   R8,R8               IS 1ST TITLE PRESENT
         BZ    NOTITLE
         USING MESSAGE,R8
         SR    R1,R1               ZERO LENGTH REG
         IC    R1,LNGH+1           LOAD MSG LENGTH
         SH    R1,MSGCON           DECREMENT OVERHEAD BYTES
         BNP   NOTITLE             IS MESSAGE VALID
         CH    R1,MSGMAX           IS MSG TOO LONG
         BNH   *+8                 IF NOT SKIP NEXT ISN
         LH    R1,MSGMAX           TRUNCATE HEADING TO MAX LNGH
         EX    R1,HEADMOVE         MOVE 1ST TITLE TO HEADING
         DROP  R8
NOTITLE  EQU   *
         SPACE
*        PRINT HEADING WITH PAGE NUMBERS
         SPACE
         L     R10,PAGE            LOAD LAST PAGE NUMBER
         LA    R10,1(R10)          BUMP PAGE NUMBER
         ST    R10,PAGE            UPDATE PAGE NUMBER
         CVD   R10,WORK
         MVC   XPAGE,EDMASK        MOVE EDIT MASK TO PRINT LINE
         ED    XPAGE,WORK+5        EDIT PAGE NUMBER INTO PRINT LINE
         PUT   SYSPRINT,HEADING
         SPACE
****    PRINT SUBTITLE IF SPECIFIED    ****
         SPACE
         SR    R8,R8               ZERO REG FOR FLAG
SUBCHK   EQU   *
         LTR   R0,R9               IS SUBTITLE PRESENT
         BZ    NOSUBT
         USING MESSAGE,R9
         IC    R6,CC               SAVE SUBTITLE CONTROL CHARACTER
         CLI   CC,C'0'             CHECK CONTROL CHARACTER
         BE    SUB2
         CLI   CC,C'-'             CHECK CONTROL CHARACTER
         BE    SUB3
         MVI   CC,C' '             OVERLAY INVALID CONTROL CHARACTER
         B     SUB1                GO PRINT SINGLE SPACE
         SPACE
SUB3     LA    R11,1(R11)          INCREMENT LINE NUMBER FOR TITLE
SUB2     LA    R11,1(R11)          INCREMENT LINE NUMBER FOR TITLE
SUB1     LA    R11,1(R11)          INCREMENT LINE NUMBER FOR TITLE
         SPACE
SUBPRNT  EQU   *
         PUT   SYSPRINT,(0)        WRITE TITLE
         STC   R6,CC               RESTORE SUBTITLE CONTROL CHARACTER
         DROP  R9
NOSUBT   EQU   *
         LTR   R8,R8               IS THIS 1ST SUBTITLE
         BNZ   PRNTBLNK            IF NOT GO PRINT BLANK LINE
         L     R9,TITLE3           LOAD 2ND SUBTITLE POINTER
         BCT   R8,SUBCHK           SET FLAG REG NEG & CHECK 2ND SUB
         SPACE
****    PRINT 1 BLANK LINE    ****
         SPACE
PRNTBLNK EQU   *
         PUT   SYSPRINT,BLNKLINE   WRITE 1 BLANKLINE
         SPACE
****    PRINT MESSAGE LINE    ****
         SPACE
PRNTMSG  EQU   *
         PUT   SYSPRINT,(7)        PRINT MESSAGE
         CLI   CC,C'+'             WAS PRINTED CONTROL CHAR +
         BE    RETURN              IF SO RETURN
         STC   R4,CC               RESTORE MESSAGE CONTROL CHARACTER
         ST    R11,LINE            STORE CURRENT LINE NUMBER
         SPACE
****    NORMAL RETURN    ****
         SPACE
RETURN   EQU   *
         L     13,SAVEAREA+4       LOAD BACKWARD POINTER
         RETURN (14,12),RC=0
         SPACE
*        USE OPTIONAL RETURN ADDR IF SPECIFIED
         SPACE
NOPRINT  EQU   *
         L     R14,DDRTNPTR        LOAD ABNORMAL RETURN ADDRESS
         LTR   R14,R14             IS IT DEFINED
         BZ    ABEND               IF NOT ABEND TASK
         L     R13,SAVEAREA+4
         RETURN  (2,12),RC=16
ABEND    ABEND 20,DUMP             TERMINATE CURRENT TASK
         SPACE
****    DCB EXIT ROUTINE TO PROVIDE DEFAULT BLKSIZE    ****
         SPACE
DCBEXIT  EQU   *
         USING IHADCB,R1
         LH    R4,DCBBLKSI         LOAD BLKSIZE
         LTR   R4,R4               IS IT DEFINED
         BZ    DEFAULT             IF NOT USE DEFAULT
         LA    R3,129              LOAD MIN BLKSIZE
         CR    R4,R3               IS BLKSIZE VALID
         BNL   CHKBUFNO            IF YES CHECK BUFNO
         LR    R4,R3               USE MIN BLKSIZE
         B     CHKBUFNO            GO CHECK BUFNO
DEFAULT  EQU   *
         LA    R4,700              LOAD DEFAULT BLKSIZE
CHKBUFNO EQU   *
         STH   R4,DCBBLKSI         SAVE BLKSIZE
         CLI   DCBBUFNO,0          IS BUFNO DEFINED
         BNZ   EXITRET             IF YES RETURN TO OPEN
         SR    R2,R2               CLEAR REG FOR DIVISION
         LA    R3,2800             LOAD 4 * DEFAULT BLKSIZE
         DR    R2,R4               FIND NUMBER OF BUFFERS
         LTR   R3,R3               IS QUOTIENT ZERO
         BP    *+8                 IF NOT SKIP NEXT ISN
         LA    R3,1                SET BUFNO TO 1
         LA    R4,255              LOAD MAX BUFNO
         CR    R3,R4               IS BUFNO EXCESSIVE
         BNH   *+6                 IF NOT SKIP NEXT ISN
         LR    R3,R4               SET BUFNO TO 255
         STC   R3,DCBBUFNO         PUT BUFNO INTO DCB
EXITRET  EQU   *
         SR    R15,R15             CLEAR REG
         BR    R14                 RETURN TO OPEN
         EJECT
         USING MESSAGE,R8
HEADMOVE MVC   HEADTEXT(0),MSG     MOVE TITLE TO HEADING
         DROP  R8
SAVEAREA DS    18F
WORK     DS    D
TITLE1   DC    A(0)                ADDR OF MAIN TITLE
TITLE2   DC    A(0)                ADDR OF 1ST SUBTITLE
TITLE3   DC    A(0)                ADDR OF 2ND SUBTITLE
TITLE    EQU   TITLE1
SUBTITLE EQU   TITLE2
PAGE     DC    A(0)                NUMBER OF PAGES WRITTEN
LINECNT  DC    A(42)               LINE COUNT LIMIT FOR PAGE
LINE     DC    A(0)                NUMBER OF LINES USED ON PAGE
         WXTRN DDRTN
DDRTNPTR DC    A(DDRTN)            ADDRESS OF ABNORMAL RETURN
EXITLIST DC    X'85',AL3(DCBEXIT)
         LTORG
MSGCON   DC    H'6'                VA MSG OVERHEAD COUNT
MSGMAX   DC    H'108'              MAX HEADING LENGTH
EDMASK   DC    X'402020202120'     5 DIGIT EDIT MASK
         EJECT
SYSPRINT DCB   DSORG=PS,MACRF=PM,DDNAME=SYSPRINT,RECFM=VBA,LRECL=133,  C
               EXLST=EXITLIST
         EJECT
****    PROGRAM MESSAGES    ****
         SPACE
HEADING  DC    AL2(HEADEND-*,0),C'1'
HEADTEXT DC    CL109' '
         DC    C' PAGE'
XPAGE    DS    CL6                 PAGE NUMBER FIELD
HEADEND  EQU   *
         SPACE
BLNKLINE DC    AL2(BLNKEND-*),AL2(0)
         DC    8C' '
BLNKEND  EQU   *
         SPACE
MESSAGE  DSECT
LNGH     DS    CL2                 LENGTH OF MESSAGE
         DC    AL2(0)
CC       DS    C                   CONTROL CHARACTER
MSG      DS    CL120               MAXIMUM OF 120 CHARACTERS
         EJECT
         DCBD  DSORG=QS
         END
CDAT     TITLE 'CDATE - CALENDAR DATE ROUTINE'
*        FUNCTION
*
*                  THIS ROUTINE WILL CALCULATE A CALENDAR DATE
*                  FROM EITHER AN OPTIONAL INPUT JULIAN DATE OR
*                  THE CURRENT JULIAN DATE IN THE CVT
*
*        INPUT
*
*                  PARM1 - ADDRESS OF 8 BYTE RESULT ON ANY BOUNDARY
*                        FORMAT - MM/DD/YY
*
*                  PARM2 - ADDRESS OF 3 BYTE JULIAN DATE (OPTIONAL)
*                        FORMAT - YYDDDS (PACKED DECIMAL)
*                          IF MISSING CVTDATE IS USED
*
*        EXIT - RETURN TO CALLER VIA R14
*
*        ERROR MESSAGES - NONE
*
*        SUPERVISOR MACROS - NONE
*
*        EXTERNAL ROUTINES - NONE
*
*        EXTERNAL TABLES - CVT FOR CVTDATE
*
*        ATTRIBUTES - REENTRANT, NON-PRIVLEDGED
*
*
CDATE    CSECT
         USING PARMS,R1
         USING TARGET,R2
         USING JULIAN,R3
         USING WORKAREA,R4
         USING SAVEAREA,R13
         USING CDATE,R15
         SPACE
         SAVE  (14,4),,*           SAVE DESTROYED REGS
         LM    R2,R3,TARGETAD      LOAD TARGET & INPUT JULIAN BASE REGS
         CLI   TARGETAD,X'80'      IS ONLY 1 PARM PRESENT
         BE    GETDATE             IF YES USE CVT DATE
         CLI   DATEAD,X'80'        ARE BOTH PARMS PRESENT
         BE    GOTDATE             IF YES USE 2ND PARM DATE
         SPACE
*        USE CURRENT DATE FROM CVT FOR SINGLE PARM
         SPACE
GETDATE  EQU   *
         L     R1,CVTPTR           LOAD CVT BASE REG
         USING CVT,R1
         LA    R3,CVTDATE+1        LOAD JULIAN BASE REG
GOTDATE  EQU   *
         SPACE
*        GET WORKAREA ON A DOUBLE WORD BOUNDARY FROM END OF
*        UNUSED SAVEAREA
         SPACE
GETWORK  EQU   *
         LA    R4,FREESAVE+7       GET ADDR OF LAST BYTE OF WORK
         N     R4,DBLMASK          SET BASE TO DOUBLE WORD
         SPACE
*        GET SERIAL DAY
         SPACE
GETDAY   EQU   *
         XC    WORK(6),WORK        ZERO WORKAREA
         MVC   WORK+6(2),DDDS      MOVE DAY OF YEAR
         CVB   R14,WORK            GET BINARY VALUE OF DAY
         SPACE
*        CHECK FOR LEAP YEAR
         SPACE
LEAPCHK  EQU   *
         IC    R1,YY               LOAD YEAR
         LA    R0,19               LOAD LEAP YEAR MASK
         NR    R1,R0               CHECK FOR YEARS OF X0, X4, OR X8
         BZ    LEAPYEAR            IF YES DECREMENT DAY
         BCTR  R0,0                DECREMENT MASK FOR 12 YEAR
         XR    R1,R0               CHECK FOR YEARS XX12, 32, 52, 72, 92
         BNZ   STDYEAR             IF NOT DONT DECREMENT DAY OF YEAR
         SPACE
*        LEAP YEAR - CHECK FOR NO DAY MOD & FEB 29
         SPACE
LEAPYEAR EQU   *
         LA    R0,31+29            LOAD DAY OF YEAR FOR FEB 29
         CR    R14,R0              CHECK FOR FEB 29 OR LESS
         BL    STDYEAR             IF FEB 28 OR LESS USE STANDARD YEAR
         BH    DECRDAY             IF MAR 1 OR GREATER DECREMENT DAY
         LA    R1,2                SET MONTH TO FEB
         LA    R14,29              SET DAY TO 29
         B     CONVDATE            GO CONVERT DATE
         SPACE
DECRDAY  EQU   *
         BCTR  R14,0               DECREMENT DAY OF YEAR AFTER FEB 29
         SPACE
*        NON LEAP YEAR - NO DAY OF YEAR MODIFICATION
         SPACE
STDYEAR  EQU   *
         SR    R1,R1               ZERO MONTH INDEX
         SPACE
*        FIND MONTH OF YEAR & DAY OF MONTH
*
*        DECREMENT R14 BY DAYS IN MONTH
*        COUNT MONTHS IN R1
         SPACE
GETMONTH EQU   *
         LA    R1,1(R1)            INCREMENT INDEX TO NEXT MONTH
         IC    R0,MONTHTBL-1(R1)   LOAD NUMBER OF DAYS IN MONTH
         SR    R14,R0              DECREMENT DAYS FOR CURRENT MONTH
         BP    GETMONTH            LOOP TILL ZERO OR MINUS
         AR    R14,R0              RESTORE DAY OF MONTH TO POS VALUE
         SPACE
*        CONVERT DATE INTO TARGET
         SPACE
CONVDATE EQU   *
         CVD   R1,WORK             CONVERT MONTH TO DECIMAL
         OI    WORK+7,15           MAKE LOW DIGIT PRINTABLE
         UNPK  MONTH,WORK          UNPACK MONTH OF YEAR
         MVI   SLASH1,C'/'         INSERT FIELD SEPARATOR
         CVD   R14,WORK            CONVERT DAY OF MONTH
         OI    WORK+7,15           MAKE LOW DIGIT PRINTABLE
         UNPK  DAY,WORK            UNPACK DAY OF MONTH
         MVI   SLASH2,C'/'         INSERT FIELD SEPARATOR
         UNPK  WORK(3),YY(2)       UNPACK YEAR INTO WORKAREA
         MVC   YEAR,WORK           MOVE YEAR TO TARGET FIELD
         SPACE
*        RETURN TO CALLER
         SPACE
RETURN   EQU   *
         RETURN  (14,4),RC=0
         EJECT
         REGEQU
         DS    0F
DBLMASK  DC    X'00FFFFF8'         DOUBLE WORD BOUNDARY MASK
MONTHTBL DC    AL1(31,28,31,30,31,30,31,31,30,31,30,31)  DAYS / MONTH
         EJECT
PARMS    DSECT
TARGETAD DS    A                   ADDRESS OF CALENDAR DATE RESULT
DATEAD   DS    A                   ADDRESS OF INPUT DATE (YYDDDF)
         SPACE 3
JULIAN   DSECT
YY       DS    X                   YEAR - PACKED DECIMAL WITHOUT SIGN
DDDS     DS    PL2                 DAY OF YEAR - PACKED DECIMAL
         SPACE 3
TARGET   DSECT
MONTH    DS    CL2                 MONTH OF YEAR
SLASH1   DS    C                   SLASH FIELD SEPERATOR
DAY      DS    CL2                 DAY OF MONTH
SLASH2   DS    C                   SLASH FIELD SEPERATOR
YEAR     DS    CL2                 LAST 2 DIGITS OF YEAR
         SPACE 3
WORKAREA DSECT
WORK     DS    D
         SPACE 3
SAVEAREA DSECT
         DS    3F                  SYSTEM CHAIN WORDS
         DS    7F                  USED PART OF SAVEAREA
FREESAVE DS    F                   START OF USABLE SAVEAREA
         EJECT
         PRINT NOGEN
CVT      DSECT
         CVT
         END
TOD      TITLE 'TOD CONVERSION ROUTINE'
*        FUNCTION - THIS ROUTINE WILL CONVERT A 370 TOD TIME TO THE
*        VALUE RETURNED BY THE TIME SVC FOR DECIMAL OR BINARY TOD
*
*        ZERO TIME - JAN 1 1960 MVT OR JAN 1 1900 VS
*              JAN 1 1900 IS USED IF 1ST BIT OF TOD VALUE IS 1
*
*        ATTRIBUTES - REENTRANT
*              (DOUBLE WORD WORKAREA OBTAINED FROM SAVEAREA)
*
*        INPUT - R1 POINTS TO ADDRESS OF 8 BYTE TOD TIME
*
*        OUTPUT - R0 WILL CONTAIN TIME OF DAY
*                 R1 WILL CONTAIN STD SERIAL DAY & YEAR
*                 (SAME FORMAT AS TIME SVC)
*
*
*        DECIMAL TIME ENTRY POINT
*
TODDEC   CSECT
         USING TODDEC,R15
         SR    R0,R0               SET DECIMAL ENTRY FLAG REG
         LA    R15,BASE(R15)       SET BASE REG TO 2ND ENTRY POINT
         USING TODBIN,R15
         B     TODCOM              GO TO COMMON CODE
*
*        BINARY TIME ENTRY POINT
*
         ENTRY TODBIN
TODBIN   LA    R0,1                SET BINARY ENTRY POINT FLAG REG
BASE     EQU   TODBIN-TODDEC       BASE REG DISPLACEMENT ORIGIN
*
*        INITIALIZE ROUTINE
*
TODCOM   SAVE  (2,9)               SAVE WORK REGS
         USING SAVEAREA,R13
GETWORK  EQU   *
         LA    R9,FREESAVE+7       GET ADDR OF WORKAREA IN SAVEAREA
         N     R9,DBLMASK          SET BASE TO DOUBLE WORD
         USING WORKAREA,R9
*
*        CONVERT TOD ARG TO TIME & DATE
*
LOADARG  L     R4,0(R1)            LOAD INPUT ARG ADDRESS
         LM    R2,R3,0(R4)         LOAD TOD VALUE
         STCM  R2,8,12(R13)        SAVE 1ST BYTE OF TOD FOR EPOCH TEST
         SRDL  R2,12               SHIFT TO MICROSECONDS
*
*        SEPARATE TIME OF DAY FROM DATE
*
         D     R2,MICROMIN         FIND MINUTES SINCE ZERO TIME
         LR    R8,R2               SAVE MICROSECONDS SINCE LAST MINUTE
         SR    R2,R2               ZERO FOR DIVISION
         D     R2,MINPRDAY         FIND DAYS SINCE ZERO TIME
         LR    R7,R2               SAVE MINUTES OF DAY
         SR    R2,R2               ZERO REMAINDER
         LA    R3,1(R3)            BUMP DAY RELATIVE TO JAN 1 (MVT)
         TM    12(R13),X'80'       IS 1ST BIT OF TOD VALUE ON
         BZ    CONVDATE            IF NOT ASSUME MVT EPOCH
         SPACE
*        EXTRA DAY CORRECTION FOR GMT DIFF OF 0 HOURS
         SPACE
         ENTRY ONEDAYSW
ONEDAYSW B     NODAYINC            SKIP NEXT ISN UNLESS ZAPPED
         LA    R3,1(R3)            BUMP DAY 1 MORE FOR VS EPOCH
NODAYINC EQU   *
*
*        CONVERT DATE TO YEAR & SERIAL DAY
*
CONVDATE D     R2,DAYPRYR          FIND SERIAL DAY & YRS SINCE ZERO
         LR    R5,R3               COPY YEAR FOR LEAP YEAR CHECK
         SR    R4,R4               ZERO FDR DIVISION
         D     R4,YRPRLEAP         FIND NUMBER OF LEAP YEARS
         SR    R2,R5               DECR DAY BY LEAP YEAR COUNT
         BP    SETYEAR             IF POS, DAY & YEAR ARE OK
         A     R2,DAYPRYR          RAISE DAY TO POSITIVE VALUE
         BCTR  R3,0                DECREMENT YEAR
SETYEAR  TM    12(R13),X'80'       IS 1ST BIT OF TOD VALUE ON
         BO    VSYEAR              IF YES ASSUME VS EPOCH 1900
MVTYEAR  A     R3,ZEROYEAR         RAISE YEAR TO TRUE VALUE
VSYEAR   CVD   R3,WORK             CONVERT YEAR TO DECIMAL
         L     R1,WORK+4           LOAD YEAR INTO PARM REG
         SRL   R1,4                SHIFT OUT SIGN FIELD
         SLL   R1,16               REPOSITION FOR DAY INSERTION
         CVD   R2,WORK             CONVERT DAY OF YEAR TO DECIMAL
         OI    WORK+7,15           CHANGE SIGN FIELD FROM C TO F
         AL    R1,WORK+4           INSERT DAY INTO PARM REG
*
*        CONVERT TIME OF DAY
*
CONVTIME SR    R6,R6               ZERO FOR DIVISION
         LTR   R0,R0               WAS ENTRY FOR DECIMAL TIME
         BZ    CONVDEC             IF YES GO FIND DECIMAL TIME
*
*        CONVERT TIME TO BINARY HUNDREDTHS OF SECONDS
*
CONVBIN  MH    R7,H6000            CHANGE MINUTES TO HUNDREDTHS OF SEC
         LR    R0,R7               SHIFT TO PARM REG
         LR    R7,R8               LOAD MICROSEC SINCE LAST MINUTE
         D     R6,F10000           CONVERT TO HUNDREDTHS OF SEC
         AR    R0,R7               ADD TO PARM REG
         B     RETURN              GO RETURN TO CALLER
*
*        CONVERT TIME TO HHMMSSTH
*
CONVDEC  D     R6,MINPRHR          FIND HOUR OF DAY
         CVD   R7,WORK             CONVERT HOUR OF DAY TO DECIMAL
         L     R0,WORK+4           LOAD DECIMAL HOUR & SIGN
         SRL   R0,4                SHIFT OUT SIGN
         SLL   R0,24               SHIFT HOUR TO FINAL POSITION
         CVD   R6,WORK             CONVERT MINUTE OF HOUR TO DECIMAL
         L     R6,WORK+4           LOAD DECIMAL MINUTE & SIGN
         SRL   R6,4                SHIFT OUT SIGN
         SLL   R6,16               SHIFT MINUTE TO FINAL POSITION
         OR    R0,R6               ADD MINUTE TO HOUR
         CVD   R8,WORK             CONVERT SECOND OF MINUTE TO DECIMAL
         LM    R6,R7,WORK          LOAD SECONDS & FRACTION
         SLDL  R6,12               SHIFT SEC TENTHS & HUNDREDTHS
         OR    R0,R6               ADD SECOND TO HOUR & MINUTE
*
*        PARM REGS R0 & R1 ARE NOW THE SAME AS RETURNED BY TIME SVC
*
RETURN   RETURN  (2,9)             RETURN TO CALLER
         EJECT
*        CONSTANTS USED FOR CONVERSION
*
         REGEQU
         DS    0F
DBLMASK  DC    X'00FFFFF8'         DOUBLE WORD BOUNDARY MASK
MICROMIN DC    F'60000000'         MICROSECONDS PER MINUTE
MINPRDAY DC    F'1440'             MINUTES PER DAY
ZEROYEAR DC    F'60'               ZERO TIME YEAR (1960)
DAYPRYR  DC    F'365'              DAYS PER YEAR
YRPRLEAP DC    F'4'                YEARS PER LEAPYEAR
F10000   DC    F'10000'            MICROSECONDS PER HUNDREDTH SECOND
H6000    DC    H'6000'             HUNDREDTHS OF SEC PER MINUTE
MINPRHR  EQU   ZEROYEAR            MINUTES PER HOUR
         EJECT
WORKAREA DSECT
WORK     DS    D                   WORKAREA FOR CVD ISN
         SPACE 3
SAVEAREA DSECT
         DS    3F                  SYSTEM CHAIN WORDS
         DS    12F                 R14 THRU R9 WORDS
FREESAVE DS    F                   START OF UNUSED AREA
         END
