***********************************************************************
*    THIS PROGRAM AND ASSOCIATED WERE WRITTEN AT CNA INSURANCE        *
*    COMPANY.                                                         *
*                                                                     *
*    BOB ZIMMERMAN                                                    *
*    CNA INSURANCE                                                    *
*    (312) 822-5719                                                   *
*    LAST MOD 8412                                                    *
***********************************************************************
*    THIS MODULE IS CALLED BY CNA0KED - IT WILL RETURN A VALID CPPL   *
*    FOR THE PARSE ROUTINE.                                           *
***********************************************************************
***********************************************************************
*                                                                     *
*  MACRO:      GENCODE--GENERATE INSTRUCTION OF COND PARAMETER LIST.  *
*                                                                     *
*  FUNCTION:   TO PARSE THE INSTRUCTION SUBLIST PASSED AND GENERATE   *
*              THE PROPER CONDITIONAL BRANCH ACCORDING TO PARAMETERS  *
*              PASSED.                                                *
*                                                                     *
*  PARAMETERS:                                                        *
*                                                                     *
*          &INST   THE INSTRUCTION SUBLIST (EXACT ALLOWABLE FORMS     *
*                  SPECIFIED IN THE "NIU STRUCTURED MACROS" WRITEUP). *
*                                                                     *
*          &LBL    LABEL TO BE ATTACHED TO THE CONDITIONAL BRANCH.    *
*                                                                     *
*          &TYPE   IS EQUAL TO "NOT" WHEN CODED; SPECIFIES THAT BRANCH*
*                  TO BE TAKEN IF SPECIFIED CONDITION IS NOT TRUE.    *
*                                                                     *
*  XREF:       MACROS USED--GETCC                                     *
*              MODULES CALLED--NONE                                   *
*                                                                     *
*  AUTHOR:     DAVID T. CARPENTER.                                    *
*                                                                     *
*  DATE:       10 OCTOBER 1976.                                       *
*                                                                     *
*  SEE THE "NIU STRUCTURE MACROS"  WRITEUP FOR FURTHER DOCUMENTATION. *
*                                                                     *
***********************************************************************
*                                                                     *
*  MODIFICATION:  BY WALTER G. SCHEER OF CNA INSURANCE ON 10/5/77 WS02*
*                  -- ALL COND TYPE STATEMENTS WILL EXPECT THE        *
*                       CONDITION CODE MASK LAST!                     *
*                                                                     *
* MAINTENANCE                                                         *
*   MIKE AMLING -- MOVE GETCC FROM MACRO TO INLINE       4/14/83  MA04*
*   MIKE AMLING -- CLEAN UP CODE                         4/14/83  MA05*
*                                                                     *
***********************************************************************
***********************************************************************
*                                                                     *
*  MACRO:      GETCC--RETURN PROPER CC VALUE TO CALLING MACRO.        *
*                                                                     *
*  FUNCTION:   TO VERIFY AND TRANSLATE IF NECESSARY THE SPECIFIED     *
*              USER CONDITION.                                        *
*                                                                     *
*  PARAMETERS:                                                        *
*                                                                     *
*          &COND   THE SYMBOL SPECIFYING THE USER CONDITION THAT IS   *
*                  TO BE VERIFIED AND TRANSLATED.                     *
*                                                                     *
*  XREF:       MACROS USED--NONE                                      *
*              MODULES CALLED--NONE                                   *
*                                                                     *
*  AUTHOR:     DAVID T. CARPENTER.                                    *
*                                                                     *
*  DATE:       10 OCTOBER 1976.                                       *
*                                                                     *
*  SEE THE "NIU STRUCTURE MACROS"  WRITEUP FOR FURTHER DOCUMENTATION. *
*                                                                     *
***********************************************************************
*                                                                     *
*  MODIFICATION: BY WALTER G. SCHEER OF CNA INSURANCE ON 10/5/77. WS01*
*              -- WRITE ERROR MESSAGE IF THE RELATIONAL OPERATOR  WS01*
*                    NAME IS NON-STANDARD.                        WS01*
*                                                                     *
* MAINTENANCE                                                         *
*   MIKE AMLING -- CHANGE GE CONDITION CODE MASK TO 10,  4/14/83  MA02*
*                   LE CONDITION CODE MASK TO 12.                 MA02*
*   MIKE AMLING -- ADD C, NC, B AND NB CONDITION CODE    4/14/83  MA03*
*                   MASKS.                                        MA03*
*                                                                     *
***********************************************************************
         MACRO
         GENCODE &INST,&LBL,&TYPE
         GBLB  &ERRFLAG            INTERMACRO ERROR FLAG
         LCLA  &CCMVAL             CONDITION CODE MASK VALUE      MA04
         LCLC  &C
.*                                                                MA05
.** EDIT THE SUBLIST                                              MA05
.*                                                                MA05
         AIF   (N'&INST GT 5 OR                                        *
                (N'&INST LT 3 AND N'&INST NE 1)).BADLIST          MA05
&C       SETC  '&INST(N'&INST)'                                   MA04
         AIF   ('&C'(1,1) LT '0' OR '&C'(1,1) GT '9').NOTNUM      MA04
           AIF   (K'&C EQ 1).CCX                                  MA04
           AIF (K'&C GT 2 OR '&C' LT '10' OR '&C' GT '15').NUMERR MA04
         AGO   .CCX                                               MA04
.NOTNUM  AIF   (K'&C EQ 1).CALCC                                  MA04
         AIF   (K'&C NE 2).INVCOND
           AIF   ('&C'(1,1) EQ 'N').NEGATE                        MA05
           AIF   ('&C' EQ 'EQ').BC8
           AIF   ('&C' EQ 'LT').BC4
           AIF   ('&C' EQ 'GT').BC2
           AIF   ('&C' NE 'LE').TRYGE
&C           SETC  '12'                                           MA02
           AGO   .CCX                                             MA04
.TRYGE     AIF   ('&C' NE 'GE').INVCOND
&C           SETC  '10'                                           MA02
           AGO   .CCX                                             MA04
.NEGATE  ANOP                                                     MA05
&C       SETC  '&INST(N'&INST)'(2,1)
.CALCC   AIF   ('&C' EQ 'P' OR '&C' EQ 'H').BC2
           AIF   ('&C' EQ 'L' OR '&C' EQ 'M' OR '&C' EQ 'B').BC4  MA03
             AIF   ('&C' EQ 'E' OR '&C' EQ 'Z').BC8
               AIF   ('&C' EQ 'C').BC3                            MA03
                 AIF   ('&C' NE 'O').INVCOND                      MA03
&CCMVAL            SETA  1
                 AGO   .TSTN
.BC3           ANOP                                               MA03
&CCMVAL        SETA  3                                            MA03
               AGO   .TSTN                                        MA03
.BC8         ANOP
&CCMVAL      SETA  8
             AGO   .TSTN
.BC4       ANOP
&CCMVAL    SETA  4
           AGO   .TSTN
.BC2     ANOP
&CCMVAL  SETA 2
.TSTN    AIF  ('&INST(N'&INST)'(1,1) NE 'N').DONE
&CCMVAL    SETA  15-&CCMVAL
.DONE    ANOP                                                     MA04
&C       SETC  '&CCMVAL'                                          MA04
.**      AGO   .CCX                                               MA04
.CCX     ANOP                                                     MA04
.*                                                                MA05
.** THE EDIT PASSED, GENERATE CODE                                MA05
.*                                                                MA05
         AIF   (N'&INST EQ 1).INSTRUX IF SUBSTRING OF ONE-->.INSTRUX
         AIF   (N'&INST LT 5).CHKFOUR IF NOT 3-OP-->CHKFOUR
         &INST(1) &INST(2),&INST(3),&INST(4)
         AGO   .INSTRUX           GO TO .INSTRUX
.CHKFOUR ANOP
         AIF   (N'&INST LT 4).TRI  IF NOT 2-OP-->CHKTRI
         &INST(1) &INST(2),&INST(3)
         AGO   .INSTRUX           GO TO .INSTRUX
.TRI     ANOP
         &INST(1) &INST(2)
.INSTRUX ANOP
         AIF   ('&TYPE' EQ 'NOT').GENNOT  IF A 'NOT'-->GENNOT
         BC    &C,&LBL
         MEXIT
.GENNOT  ANOP
         BC    15-&C,&LBL
         MEXIT
.*
.** ERROR MESSAGES
.*
.INVCOND MNOTE 8,'VALUE ''&C'' NOT A STANDARD RELATIONAL OPERATOR' WS01
         AGO   .CCX                                               MA04
.BADLIST MNOTE 12,'*** IMPROPER NON-COMPARE SUBLIST ***'
&ERRFLAG SETB  1                  SET &ERRFLAG=ON
         MEXIT
.NUMERR  MNOTE 12,'*** INVALID NUMERIC CONDITION ***'
&ERRFLAG SETB  1                                                  MA05
         MEND
***********************************************************************
*                                                                     *
*   MACRO:  EXLBL                                                     *
*                                                                     *
*   FUNCTION:  THE EXLBL MACRO IS AN INTERNALLY INVOKED SUPPORT       *
*       MACRO.  IT PERFORMS THE OPERATION OF CONDITIONALLY GENERATING *
*       TWO DIFFERENT TYPES OF END LABELS DEPENDING ON THE ARGUMENT   *
*       &TYPE.                                                        *
*                                                                     *
*   PARAMETERS:                                                       *
*                                                                     *
*      &TYPE  INDICATES THE TYPE OF INVOCATION:                       *
*             DOIF - CAUSES THE GENERATION OF A LABEL FROM THE DOIFEX *
*                 STACK, WHICH IS THE LABEL ASSOCIATED WITH THE ENDIF *
*                 OR DO MACROS.                                       *
*             COND - CAUSES THE GENERATION OF A LABEL FROM THE CONDEX *
*                 STACK WHICH IS PART OF THE SEQUENCE OF LABELS       *
*                 CARRIED BETWEEN CONDS.  AFTER GENERATION A NEW      *
*                 UNIQUE LABEL IS PLACED ON THE STACK.                *
*                                                                     *
***********************************************************************
*                                                                     *
*    MODIFICATION HISTORY:                                            *
*    DATE     AUTHOR              COMMENTS                         ID *
*    05/30/79 MIKE AMLING         ADD DEFINITION OF DEFERRED      MA02*
*                                  @#NO&N1 LABELS TO SUPPORT      MA02*
*                                  CPARSE REWRITE                 MA02*
*                                                                     *
*    04/13/83 MIKE AMLING         USE DS 0H WHEN EQU * MIGHT      MA03*
*                                  LEGITIMATELY BE UNALIGNED      MA03*
*                                                                     *
***********************************************************************
         MACRO
         EXLBL &TYPE
         GBLA  &LVLPTR            INDEX INTO THE STACKS
         GBLA  &EXGEN             THE LABEL COUNTER
         GBLA  &EXNO              CURRENT SUBSCRIPT OF &EXNOLBL   MA02
         GBLA  &DOIFEX(50)        STACK FOR $ENDIF AND $DO LABELS
         GBLA  &CONDEX(50)        STACK FOR $COND END LABELS
         GBLA  &EXNOLBL(100)      STACK OF SAVED @#NO LBLS        MA02
         GBLA  &EXNOHI(50)        HIGHEST ELEMENT OF &EXNOLBL IN  MA02
.*                                 USE OUTSIDE OF CURRENT DO OR IFMA02
         AIF   ('&TYPE' NE 'DOIF').GENLBL  THEN WANT CONDEX LABEL
@#EX&DOIFEX(&LVLPTR) DS 0H                                        MA03
         MEXIT
.GENLBL  ANOP
@#EX&CONDEX(&LVLPTR) DS 0H                                        MA03
&CONDEX(&LVLPTR) SETA &EXGEN      PLACE VALUE OF &EXGEN ON &CONDEX
&EXGEN   SETA  &EXGEN+1           INCREMENT &EXGEN BY 1
.LOOP    AIF   (&EXNO LE &EXNOHI(&LVLPTR)).EXIT                   MA02
@#NO&EXNOLBL(&EXNO)  EQU  *                                       MA02
&EXNO    SETA  &EXNO-1                                            MA02
         AGO   .LOOP                                              MA02
.EXIT    MEND
         MACRO
         ENDIF
.**********************************************************************
.*                                                                    *
.*  MACRO:  ENDIF                                                     *
.*                                                                    *
.*  FUNCTION:  ENDIF FORMS THE ENDING DELIMITER FOR A IF-COND-ENDIF   *
.*      MACRO SEQUENCE.  IT GENERATES END LABELS AND A CON-           *
.*      DITIONAL ABEND INSTRUCTION DEPENDING ON THE &ELSE FLAG,       *
.*      WHICH INDICATES THE PRESENCE OF A PRECEEDING COND WITH AN     *
.*      ELSE ARGUMENT.  IN ADDITION, THE &ARGS FLAG INDICATES TO      *
.*      ENDIF WHETHER THE IBM CONCEPT-14 FORMAT IS BEING UTILIZED,    *
.*      WHICH ALSO SUPPRESSES THE ABEND GENERATION.  LASTLY, THE      *
.*      ENDIF MACRO DECREMENTS THE STACKS POINTER TO CLEAR THE        *
.*      STACKS FOR THIS SEQUENCE.                                     *
.*                                                                    *
.*  PARAMETERS:  NONE.                                                *
.*                                                                    *
.*  XREF:  MACROS USED - EXLBL                                        *
.*                                                                    *
.**********************************************************************
         GBLB  &FIRSTC            FLAG TO DETECT START OF SEQUENCE
         GBLB  &ELSE(50)          STACK TO DETECT $COND ELSE PRESENCE
         GBLB  &ARGS(50)          INDICATES SIMPLE IF-ELSE-ENDIF STRUC
         GBLB  &EXCODE(50)        THE STACK FOR $IF OR $DO ID
         GBLA  &LVLPTR            THE STACKS INDEX
         GBLA  &DOIFEX(50)        THE $DO OR $IF END LABEL STACK
         AIF   (&LVLPTR GT 0).CHKF  CHECK INVALID STACK LEVEL
         MNOTE 12,'***ERROR: UNMATCHED ENDIF***'
         AGO   .END
.CHKF    AIF   (&FIRSTC EQ 0).CHKNXT IF NOT ON, PROCEED NORMALLY
         MNOTE 12,'***ERROR: ENDIF IMMEDIATELY FOLLOWS IF OR DO***'
&FIRSTC  SETB  0                  TURN OFF &FIRSTC
         AGO   .DEC
.CHKNXT  AIF   (&ELSE(&LVLPTR) EQ 1).ABCOM  DONT GENERATE ABEND
         AIF   (&ARGS(&LVLPTR) EQ 0).ABND  THEN GENERATE ABEND
         EXLBL COND               GENERATE LABEL
         AGO   .ABCOM             BRANCH TO GET LABEL
.ABND    B     @#EX&DOIFEX(&LVLPTR)  BRANCH AROUND ABEND
         EXLBL COND               GENERATE LABEL
         ABEND 50,DUMP
.ABCOM   AIF   (&EXCODE(&LVLPTR) EQ 1).DECR  THEN MATCH OK
         MNOTE 12,'***ERROR: ENDIF PAIRED WITH DO***'
.DECR    EXLBL DOIF               GENERATE ENDIF LABEL
&ELSE(&LVLPTR) SETB  0            TURN &ELSE OFF
&ARGS(&LVLPTR) SETB  0            TURN OFF &ARGS
.DEC     ANOP
&LVLPTR  SETA  &LVLPTR-1          DECREMENT STACKS INDEX
.END     MEND
***********************************************************************
*                                                                     *
*  AUTHORS AND DATES:                                                 *
*                                                                     *
*      MIKE AMLING - ORIGINAL CODE                       ??/??/80 N/A *
*                                                                     *
*                                                                     *
*  MAINTENANCE SUMMARY:                                               *
*                                                                     *
*    MIKE AMLING - REVISE TO USE &INUSE(13)               5/ 5/83 MA01*
*                                                                     *
*                                                                     *
***********************************************************************
         MACRO
         RF
         GBLB  &INUSE(13)                                         MA01
         GBLC  &EQU(12),&USING(12)
         LCLA  &A,&X
         LCLC  &C
&X       SETA  N'&SYSLIST
.LOOPX   AIF   (&X LE 0).MEXIT
&C       SETC  '&SYSLIST(&X)'
&X       SETA  &X-1
         AIF   ('&C' EQ '').LOOPX      SKIP NULL ENTRIES
.*
.*  FREE THE REGISTER CURRENTLY IN USE AS &C
.*
&A       SETA  2                       LOWEST SUPPORTED REGISTER - 1
.LOOPA   AIF   (&A GE 12).ERRINUS      12 IS HIGHEST SUPPORTED REGISTER
&A       SETA  &A+1
         AIF   ('&EQU(&A)' NE '&C').LOOPA
.*
&INUSE(&A) SETB 0                      INDICATE REG NO LONGER IN USE
&EQU(&A) SETC  ''                      RESET FOR LATER RF MACROS
         AIF   ('&USING(&A)' EQ '').LOOPX
&USING(&A) SETC ''
         DROP  &C                                                     $
         AGO   .LOOPX
.*
.* ERROR MNOTES
.*
.ERRINUS MNOTE 4,'REGISTER &C NOT IN USE.'
         AGO   .LOOPX
.MEXIT   MEND
***********************************************************************
*                                                                     *
*  AUTHORS AND DATES:                                                 *
*                                                                     *
*      MIKE AMLING - ORIGINAL CODE                       ??/??/80 N/A *
*                                                                     *
*                                                                     *
*  MAINTENANCE SUMMARY:                                               *
*                                                                     *
*    MIKE AMLING - REVISE TO USE &INUSE(13)               5/ 5/83 MA01*
*                                                                     *
*                                                                     *
***********************************************************************
         MACRO
         RG    &S,&T
         GBLB  &INUSE(13)                                         MA01
         GBLC  &EQU(12),&USING(12)
         LCLA  &A
         LCLC  &C
         AIF   (N'&SYSLIST LE 2).MULTIX
         MNOTE 8,'ALL BUT FIRST 2 POSITIONAL PARAMETERS IGNORED.'
.MULTIX  AIF   (T'&T NE 'O').PAIR
         AIF   ('&S(3)' NE '').SPEC
.*
.*  SEARCH FOR 1 AVAILABLE REGISTER
.*
&A       SETA  2                ONE LESS THAN LOWEST SUPPORTED REGISTER
.LOOP1   ANOP                                                     MA01
&A       SETA  &A+1
         AIF   (&INUSE(&A)).LOOP1
         AIF   (&A GT 12).ERRNORE      IF 3..12 NOT AVAILABLE     MA01
.*
.*  SET UP LONE REGISTER OR EVEN REGISTER OF PAIR
.*
.TAKEA   ANOP
&INUSE(&A) SETB 1                      NOTE REGISTER IN USE
&EQU(&A) SETC  '&S(1)'                 NOTE NAME FOR RF MACRO
&C       SETC  '&S(1)       '(1,8)
         MNOTE *,'&C EQU   &A'
&S(1)    EQU   &A                      DEFINE SYMBOL FOR REGISTER     $
         AIF   ('&S(2)' EQ '').MEXIT
         USING &S(2),&S(1)             TELL ASSEMBLER ABOUT CONTENTS  $
&USING(&A) SETC '&S(2)'                NOTE DSECT NAME FOR RCALL MACRO
.MEXIT   MEXIT
.*
.*  SEARCH FOR AN AVAILABLE EVEN/ODD REGISTER PAIR
.*
.PAIR    AIF   (N'&S LE 2 AND N'&T LE 2).PAIROVX
         MNOTE 8,'ASSIGNMENT OVERRIDE IGNORED WHEN REQUESTING PAIR.'
.PAIROVX ANOP
&A       SETA  3                       ODD REG OF 1ST PAIR - 2
.LOOP2   ANOP                                                     MA01
&A       SETA  &A+2
         AIF   (&INUSE(&A) OR &INUSE(&A-1)).LOOP2
         AIF   (&A GT 11).ERRNOPA   11 IS ODD REG OF HIGHEST PAIR MA01
.*
.*  SET UP ODD REGISTER OF PAIR
.*
&INUSE(&A) SETB 1                      NOTE REGISTER IN USE
&EQU(&A) SETC  '&T(1)'                 NOTE ODD REG NAME FOR RF MACRO
&C       SETC  '&T(1)       '(1,8)
         MNOTE *,'&C EQU   &A'
&T(1)    EQU   &A                      DEFINE SYMBOL FOR REGISTER     $
&A       SETA  &A-1                    PRESET FOR DEFINING EVEN REG
         AIF   ('&T(2)' EQ '').TAKEA
&USING(&A+1) SETC '&T(2)'              NOTE DSECT NAME FOR RCALL MACRO
         USING &T(2),&T(1)             TELL ASSEMBLER ABOUT CONTENTS  $
         AGO   .TAKEA
.*
.*  CHECK USER-SPECIFIED REGISTER
.*
.SPEC    ANOP
&A       SETA  K'&S(3)
.SPCLOOP AIF   (&A LE 0).SPCOK
         AIF   ('&S(3)'(&A,1) LT '0').ERRSPEC
&A       SETA  &A-1
         AGO   .SPCLOOP
.SPCOK   ANOP
&A       SETA  &S(3)
         AIF   (&A LT 3 OR &A GT 12).ERRS312
         AIF   (NOT &INUSE(&A)).TAKEA
         AIF   ('&EQU(&A)' EQ '').ERRINU2
         MNOTE 12,'SPECIFIED REGISTER &A IN USE AS &EQU(&A)'
         MEXIT
.ERRINU2 MNOTE 12,'SPECIFIED REGISTER &A IN USE BY CALLING CODE'
         MEXIT
.ERRSPEC MNOTE 8,'SPECIFIED REGISTER &S(3) NOT NUMERIC.'
         MEXIT
.ERRS312 MNOTE 8,'SPECIFIED REGISTER NOT IN RANGE 3-12.'
         MEXIT
.ERRNOPA MNOTE 8,'NO REGISTER PAIR AVAILABLE.'
         MEXIT
.ERRNORE MNOTE 8,'NO REGISTER AVAILABLE.'
         MEND
         MACRO
&MNAME   CNAEXIT  &RC,&XCTL=,&SPKA=,&EXIT=YES
.*
.*       THIS MACRO PROVIDES A COMPANION EXIT MACRO TO
.*       THE ENTRY MACRO CNAENTER.
.*
.*
.*       DECLARE GLOBAL SYMBOLS USED FOR CNAENTER AND CNAEXIT
.*
         GBLA  &GBLREG#            NUMBER OF BASE REGISTERS
         GBLB  &GBLACTV            MACRO HAS BEEN INVOKED BEFORE
         GBLC  &GBLREGS(5)         BASE REGISTER VALUES
         GBLC  &GBLUSNG            BASE REGS WITH COMMAS FOR USING
         GBLC  &GBLRENT            RENT OPTION
         GBLC  &GBLSAVE            SNAME OPTION
         GBLC  &GBLSTRG            STORAGE OPTION
         GBLC  &GBLSTCK            SIZE OF STACK
         GBLC  &GBLCNAM            CSECT NAME
         GBLC  &GBLCESP            SUBPOOL FOR SAVEAREA FREEMAIN
         GBLC  &GBLCESV            SVC TYPE FOR RENT=(NEWSTACK,TYPE)
.*
.*       LOCAL VARIABLES
.*
         LCLA  &LCLBASE            NUMBER OF REG TO GEN R.C. HOLD
         LCLA  &LCLLOOP            LOOP CONTROL WHILE GENNING ABOVE
         LCLC  &LCLLABL            STATEMENT LABEL
         LCLC  &LCLRREG            CHARACTER FORM OF LCLBASE WITH R
         LCLC  &LCLXNAM            NAME TO XCTL TO
         LCLC  &LCLXLST            NAME OF XCTL PARM LIST
         LCLC  &LCLXREG            NAME OF REGISTER FOR MODULE ADDR
.*
.*       CHECK THE XCTL= OPERAND
.*       IT CANNOT BE USED WITH THE RC OPERAND
.*       THERE ARE THREE FORMS OF THE OPERAND
.*       XCTL=MODULE-NAME   (OBSOLETE VERSION)
.*       XCTL=(SF,PLIST-NAME,ROUTINE-ADDRESS-LOCATION)
.*       XCTL=(I,MODULE-NAME)
.*
         AIF   ('&XCTL' EQ '').XCTL1OK          NO XCTL= OPERAND
         AIF   ('&RC' EQ '').XCTL1A             NO RC OPERAND
         MNOTE 4,'RETURN CODE AND XCTL= INCOMPATIBLE. RETURN CODE IGNORE
               ED'
.XCTL1A  AIF   (N'&XCTL NE 1).XCTL1B
&LCLXNAM SETC  '&XCTL'                          SET MODULE NAME
         AGO   .XCTL1OK                         AND END CHECKS
.XCTL1B  AIF   ('&XCTL(1)' NE 'I').XCTL1C       IS IT INLINE PLIST
&LCLXNAM SETC  '&XCTL(2)'                       SET MODULE NAME
         AIF   (N'&XCTL NE 2).XCTL1E1           GENERATE ERROR MESSAGE
         AGO   .XCTL1OK
.XCTL1C  AIF   ('&XCTL(1)' NE 'SF' AND '&XCTL(1)' NE 'E').XCTL1E2
         AIF   ('&XCTL(2)' EQ '').XCTL1D        CHECK IF XCTL PLIST
&LCLXLST SETC  '&XCTL(2)'                       SET XCTL PARM LIST ADDR
.XCTL1D  AIF   ('&XCTL(3)' EQ '').XCTL1E        IS A REGISTER SET
&LCLXREG SETC  '&XCTL(3)'                       SET REGISTER NAME
.XCTL1E  AIF   (N'&XCTL GT 3).XCTL1E3           TOO MANY OPERANDS
         AGO   .XCTL1OK                         END CHECKS
.XCTL1E1 MNOTE 4,'XCTL=(I,PLIST-NAME) MUST HAVE 2 OPERANDS'
         AGO   .XCTL1OK
.XCTL1E2 MNOTE 4,'XCTL= FORMS ARE I AND E. XCTL=&XCTL(1) INVALID'
         AGO   .XCTL1OK
.XCTL1E3 MNOTE 4,'XCTL= TOO MANY OPERANDS'
.XCTL1OK ANOP
.*
.*       CHECK USAGE OF SPKA OPERAND
.*
         AIF   ('&SPKA' EQ '').SPKA1OK    NO SPKA= OPERAND
         AIF   ('&GBLCESV' NE '').SPKA1OK MUST BE RENT=(NEWSTACK,X)
         MNOTE 4,'SPKA=&SPKA VALID ONLY FOR RENT=(NEWSTACK,NSL)'
.SPKA1OK ANOP
.*
.***     CHECK USAGE OF THE EXIT=NO OPERAND
.*
         AIF   ('&EXIT' EQ 'YES').EXITOK
         AIF   ('&EXIT' EQ 'NO').EXITC1
         MNOTE 8,'EXIT=&EXIT VALUE INVALID'
.EXITC1  ANOP
         AIF   ('&XCTL' EQ '').EXITC2
         MNOTE 8,'EXIT=NO INVALID WITH XCTL=&XCTL'
.EXITC2  AIF   ('&RC' EQ '').EXITOK
         MNOTE 8,'EXIT=NO INVALID WITH RETURN CODE OPERAND &RC'
.EXITOK  ANOP
.*
.*       RESUME CSECT IF WE HAVE LEFT IT
.*
         AIF   ('&GBLCNAM' EQ '&SYSECT').READY
&GBLCNAM CSECT ,                   RESUME ORIGINAL CSECT
         SPACE 2
.READY   ANOP
.*
.*       SET STATEMENT LABEL
.*
&LCLLABL SETC  '&MNAME'
.*
.*       SET UP GLOBALS TO CAUSE DEFAULT IF CNAENTER NOT USED
.*
         AIF   (&GBLACTV).ACTIVE
&GBLRENT SETC  'NO'
&GBLSAVE SETC  'SAVEAREA'
         MNOTE 4,'CNAENTER NOT USED - WILL GENERATE FOR NON-REENTRANT'
.ACTIVE  ANOP
.*
.*       THERE ARE TWO FUNDAMENTAL CASES - 1 REQUIRING A FREEMAIN
.*       AND THE OTHER NOT.  THE FIRST CASE OCCURS WHEN &GBLRENT
.*       IS 'YES' OR 'NEWSTACK'.  THE OTHER OCCURS WHEN &GBLRENT
.*       IS 'NO' 'NOSAVE' 'STACK' OR 'COM'.  FIRST SECTION OF MACRO
.*       DETERMINES WHICH CASE IS PRESENT.
.*
         AIF   ('&GBLRENT' EQ 'YES' OR '&GBLRENT' EQ 'NEWSTACK').FREE
         AIF   ('&XCTL' NE '').GENXCTL
.*
.*       NOW GET THE RETURN CODE INTO R15 IF IT IS NOT IN 15 OR A
.*       SELF-DEFINING TERM.
.*
         AIF   ('&EXIT' EQ 'NO').NFRCSET    CASE - EXIT=NO
         AIF   ('&RC' EQ '0').NFRCSET       CASE - CNAEXIT 0 OPTIMIZE
         AIF   ('&XCTL' NE '').NFRCSET      CASE - XCTL OPERAND PRESENT
         AIF   ('&RC' EQ '').NFRCSET        CASE - NULL DEFAULT 0
         AIF   ('&RC' EQ '(R15)').NFRCSET   CASE - RC PRESET
         AIF   ('&RC' EQ '(15)').NFRCSET    CASE - RC PRESET
         AIF   ('&RC'(1,1) EQ '(').NFREG    CASE - REG FORM
         AIF   (T'&RC EQ 'N').NFRCSET       CASE - SELF-DEFINING
&LCLLABL L     R15,&RC             LOAD RETURN CODE VALUE
&LCLLABL SETC  ''                  NULIFY LABEL COPY
         AGO   .NFRCSET
.NFREG   ANOP
&LCLLABL LR    R15,&RC(1)          LOAD RETURN CODE VALUE
&LCLLABL SETC  ''
.*
.***     R15 LOADED UNLESS SR OR LA TO BE GENERATED
.*
.NFRCSET ANOP
.*
.*       RESTORE REGISTER 13 FOR NON-REENTRANT CASE
.*
         AIF   ('&GBLRENT' EQ 'NOSAVE').NFLR14
&LCLLABL L     R13,&GBLSAVE+4      RESTORE CALLER'S SAVE AREA
&LCLLABL SETC  ''
.*
.***     REENTER HERE FROM REENTRANT CASE
.*
.NFLR14  ANOP
         AIF   ('&RC' EQ '').NFLR14A           SKIP SUBSTRING IF NO PRM
         AIF   ('&RC'(1,1) EQ '(').NFLRN0      ALREADY LOADED IF REG.
         AIF   ('&EXIT' EQ 'NO' OR '&XCTL' NE '').NFLRN0
         AIF   ('&RC' NE '' AND T'&RC NE 'N').NFLRN0
.NFLR14A ANOP
&LCLLABL LM    R14,R12,12(R13)     RESTORE REGISTERS
         AIF   ('&RC' EQ '' OR '&RC' EQ '0').NFLRY0
         LA    R15,&RC             SET RETURN CODE NOT ZERO
         AGO   .NFLRN0A
.NFLRY0  ANOP
         SR    R15,R15             SET RETURN CODE ZERO
         AGO   .NFLRN0A
.*
.***     NEXT 2 INSTRUCTIONS IF RETURN CODE WAS LEFT IN R15
.*
.NFLRN0  ANOP
&LCLLABL L     R14,12(,R13)        RESTORE RETURN ADDRESS
         LM    R0,R12,20(R13)      RESTORE REMAINING REGISTERS
.NFLRN0A ANOP
         MVI   12(R13),X'FF'       FLAG AS RETURNED FOR SNAP SVC
         AIF   ('&EXIT' EQ 'NO').EXITNFN
         BR    R14                 RETURN TO CALLER
.EXITNFN ANOP
         MEXIT
.*
.*       REENTRANT CASE - FIRST GET RETURN CODE INTO A REGISTER
.*       WHICH IS NOT R15 AND IS NOT A BASE REGISTER.  DETERMINE
.*       WHICH REGISTER FIRST
.*
.FREE    AIF   ('&GBLCESV' NE '').GENNSL GO GENERATE SYSTEM CONV.
         AIF   ('&XCTL' NE '').FRSET   AVOID RETURN CODE LOGIC
&LCLRREG SETC  '&RC(1)'
         AIF   ('&RC' EQ '').FRNEED
         AIF   ('&RC'(1,1) EQ '(' AND '&RC' NE '(R15)').FRSET
.FRNEED  ANOP
&LCLBASE SETA  2
.FRCHECK ANOP
&LCLLOOP SETA  1
&LCLRREG SETC  'R&LCLBASE'
.FRLOOP  ANOP
         AIF   ('&LCLRREG' EQ '&GBLREGS(&LCLLOOP)').FRRETRY
&LCLLOOP SETA  &LCLLOOP+1
         AIF   (&LCLLOOP LE &GBLREG#).FRLOOP
         AGO   .FRLRC
.FRRETRY ANOP
&LCLBASE SETA  &LCLBASE+1
         AGO   .FRCHECK
.FRLRC   ANOP
         AIF   ('&EXIT' EQ 'NO').FRLR SAVE R15 AGAINST FREEMAIN
         AIF   ('&RC' EQ '0').FRSET  CASE - CNAEXIT 0 OPTIMIZED
         AIF   ('&XCTL' NE '').FRSET        CASE - XCTL= NO R15
         AIF   ('&RC' EQ '').FRSET          CASE - NULL DEFAULTS TO 0
         AIF   ('&RC'(1,1) EQ '(').FRLR     CASE - REGISTER OPERAND
         AIF   (T'&RC EQ 'N').FRSET         CASE - GENERATE LA INSTRUCT
&LCLLABL L     &LCLRREG,&RC        LOAD RETURN CODE VALUE
&LCLLABL SETC ''
         AGO   .FRSET
.FRLR    ANOP
&LCLLABL LR    &LCLRREG,&RC(1)     SAVE RETURN CODE OVER FREEMAIN
&LCLLABL SETC  ''
.FRSET   ANOP
&LCLLABL LR    R1,R13              SET ADDRESS TO FREE
&LCLLABL SETC  ''
         L     R13,&GBLSAVE+4      GET CALLER'S SAVE AREA
         AIF   ('&GBLRENT' EQ 'NEWSTACK').FRSTACK
 DC 0C'  FREEMAIN R,A=(1),LV=&GBLSTRG,SP=&GBLCESP' FREEMAIN ISSUED
         FREEMAIN R,A=(1),LV=&GBLSTRG,SP=&GBLCESP
         AGO   .NFSET15
.FRSTACK ANOP
 DC 0C'  FREEMAIN R,A=(1),LV=&GBLSTCK,SP=&GBLCESP' FREEMAIN ISSUED
         FREEMAIN R,A=(1),LV=&GBLSTCK,SP=&GBLCESP
.NFSET15 AIF   ('&XCTL' NE '').GENXCTL     GENERATE XCTL EXIT CODE
         AIF   ('&RC' EQ '' OR '&RC' EQ '0').NFLR14
         AIF   ('&RC'(1,1) EQ '(').FRSET15
         AIF   (T'&RC EQ 'N').NFLR14
.FRSET15 ANOP
         LR    R15,&LCLRREG        SET RETURN CODE INTO PROPER REG
         AGO   .NFLR14
.*
.*       GENERATE FOR RENT=(NEWSTACK,NSL),SPKA=
.*
.GENNSL  ANOP
&LCLLABL CNOP  0,4
&LCLLABL SETC  ''
         L     R0,*+8              LOAD SUBPOOL AND LENGTH
         B     *+8                 SKIP INLINE CONSTANT
         DC    AL1(&GBLCESP),AL3(&GBLSTCK)
         LA    R1,0(,R13)          POINT AT STACK
         LM    R2,R14,80(R13)      RESTORE OPEN/CLOSE/EOV REGS
         SVC   10                  ISSUE FREEMAIN SVC DIRECTLY
         AIF   ('&SPKA' EQ '').NSL1B
         SPKA  &SPKA               RETURN TO SUPERVISOR KEY
.NSL1B   AIF   ('&EXIT' EQ 'NO').MEND  IF EXIT=NO, GET OUT QUICKLY
         AIF   ('&LCLXREG' EQ '').NSL1C SKIP BRANCH TEST IF NOT REQ
         ICM   R15,15,&LCLXREG     CHECK FOR EP IN THIS LOAD MODULE
         BNZR  R15                 AND GO TO IT IF PRESENT
.NSL1C   AIF   ('&LCLXNAM' NE '').XCTL2B GEN INLINE LIST XCTL
   DC 0C'XCTL  SF=(E,&LCLXLST)'
         XCTL  SF=(E,&LCLXLST)
         MEXIT
.*
.*       GENERATE ERROR MESSAGE FOR RENT=(NEWSTACK,SVC6)
.*
.SVC6GEN AIF   ('&GBLCESV' NE 'SVC6').SVC5GEN TRY SVC15
         MNOTE 12,'RENT=(NEWSTACK,SVC6) NOT SUPPORTED BY CNAEXIT'
         MEXIT
.*
.*       GENERATE ERROR MESSAGE FOR RENT=(NEWSTACK,SVC15)
.*
.SVC5GEN AIF   ('&GBLCESV' NE 'SVC15').SVCXGEN TRY NEW PARM
         MNOTE 12,'RENT=(NEWSTACK,SVC15) NOT SUPPORTED BY CNAEXIT'
         MEXIT
.*
.*       GENERATE ERROR MESSAGE FOR UNRECOGNIZED &GBLCESV VALUE'
.*
.SVCXGEN MNOTE 12,'RENT=(NEWSTACK,&GBLCESV) NOT SUPPORTED BY CNAEXIT'
         MEXIT
.*
.*       GENERATE XCTL=(I,MODULE-NAME) VERSION OF XCTL
.*
.GENXCTL LM    R14,R12,12(R13)     RESTORE CALLERS REGISTERS
.XCTL2B  CNOP  2,4                 INSURE CONSTANT ALIGNMENT
         BALR  R15,0               SET NEW ADDRESSABILITY
         PUSH  USING               SAVE PREVIOUS ENVIRONMENT
         DROP  ,                   AVOID ADDRESSING PROBLEMS
         USING *,R15               AND TELL THE ASSEMBLER THE TRUTH
         L     R15,*+16            GET ADDRESS OF NEXT ROUTINE
         LTR   R15,R15             IS IT IN THIS MODULE
         BNZR  R15                 YES, GO TO IT DIRECTLY
         BALR  R15,0               NO, RESET ADDRESSABILITY
         USING *,R15               TELL THE ASSEMBLER AGAIN
         LA    R15,*+10            POINT AT XCTL SF= LIST
         XCTL  SF=(E,(15))         AND GO TO PROGRAM WITH ASSIST
         WXTRN &LCLXNAM            DECLARE AS WEAK EXTERNAL REFERENCE
         DC    A(&LCLXNAM)         IF LINKEDITED IN
         XCTL  EP=&LCLXNAM,SF=L    BUILD XCTL PARAMETER LIST
         POP   USING               GET USERS ENVIRONMENT BACK
.MEND    ANOP                        WAY TO BRANCH OUT
         MEND
         MACRO
         ELSE
.**********************************************************************
.*                                                                    *
.*  MACRO:  ELSE                                                      *
.*                                                                    *
.*  FUNCTION - ELSE ACCOMODATES THE CODING FORMAT OF THE              *
.*             IBM CONCEPT-14 IF-ELSE-ENDIF MACRO FORMAT.             *
.*                                                                    *
.**********************************************************************
         COND ELSE
         MEND
         MACRO
         PUSHNEST &TYPE
.**********************************************************************
.*                                                                    *
.*  MACRO:  PUSHNEST                                                  *
.*                                                                    *
.*  FUNCTION:  THE PUSHNEST MACRO IS AN INTERNALLY INVOKED SUPPORT    *
.*      MACRO WHICH PERFORMS THE INITIAL LABEL STACKING OPERATIONS    *
.*      NECESSARY TO ESTABLISH AN IF-COND-ENDIF OR A DO-COND-ENDDO    *
.*      SEQUENCE.  THIS INCLUDES STACKING A UNIQUE DOIF END LABEL     *
.*      FOR THE ENDIF OR DO MACROS, AND STACKING A LABEL TO BE USED   *
.*      BY THE INTERVENING CONDS.  THE TYPE CODE (IF OR DO) IS ALSO   *
.*      STACKED TO ALLOW SUBSEQUENT MACRO COMPATABILITY CHECKING      *
.*      DURING ENDIF OR ENDDO PROCESSING.                             *
.*                                                                    *
.*  PARAMETERS:                                                       *
.*                                                                    *
.*     &TYPE  INDICATES THE TYPE OF INVOCATION.  CAN BE ONE OF THE    *
.*            FOLLOWING:                                              *
.*            IF - PUSHNEST INVOKED FROM IF MACRO.                    *
.*            DO - PUSHNEST INVOKED FROM DO MACRO.                    *
.*                                                                    *
.*   MODIFICATION HISTORY:                                            *
.*   DATE     AUTHOR              COMMENTS                         ID *
.*   05/30/79 MIKE AMLING         ADD INITIALIZATION OF &EXNOHI()  MA02
.*                                TO SUPPORT CPARSE REWRITE        MA02
.*                                                                    *
.**********************************************************************
         GBLA  &EXGEN             THE LABEL COUNTER
         GBLA  &LVLPTR            THE STACKS INDEX
         GBLA  &CONDEX(50)        THE &COND LABEL STACK
         GBLA  &DOIFEX(50)        THE $DO OR $ENDIF END LABEL STACK
         GBLA  &EXNOHI(50)        HIGHEST SUBSCRIPT OF &EXNOLBL IN MA02
.*                                 USE OUTSIDE OF CURRENT DO OR IF MA02
         GBLA  &EXNO              CURRENT SUBSCRIPT OF &EXNOLBL    MA02
         GBLB  &EXCODE(50)        STACK OF MACRO TYPE CODES:
.*                                  0 = $DO
.*                                  1 = $IF
         AIF   (&LVLPTR LT 50).ADDSTK  IF NOT FULL PROCEED NORMALLY
         MNOTE 12,'***ERROR: NESTING LEVEL EXCEEDS CAPACITY***'
         MEXIT
.ADDSTK  ANOP
&LVLPTR  SETA  &LVLPTR+1          INCREMENT &LVLPTR FOR NEXT ENTRY
&DOIFEX(&LVLPTR) SETA  &EXGEN     PUT &EXGEN COUNTER VALUE ON &DOIFEX
&CONDEX(&LVLPTR) SETA  &EXGEN+1   PUT NEXT &EXGEN ON &CONDEX
&EXGEN   SETA  &EXGEN+2           SET UP NEXT UNIQUE VALUE
&EXCODE(&LVLPTR) SETB  ('&TYPE' EQ 'IF')
&EXNOHI(&LVLPTR) SETA  &EXNO      SET TO HIGHEST &EXNO IN USE      MA02
.*                                 OUTSIDE OF THIS $DO OR $IF      MA02
         MEND
***********************************************************************
*                                                                     *
*   MACRO:  IF                                                        *
*                                                                     *
*   FUNCTION:  THE IF MACRO FORMS THE BEGINNING DELIMITER FOR A       *
*       STRUCTURED IF-COND-ENDIF MACRO SEQUENCE.  IT PERFORMS THE     *
*       INITIAL STACK PROCESSING FOR THE SEQUENCE.  IN ADDITION, IN   *
*       ORDER TO ACCOMODATE THE CODING FORMAT FOR THE IBM CONCEPT-14  *
*       MACROS, ANY ARGUMENTS CODED WITH THE IF MACRO ARE PASSED TO   *
*       A GENERATED COND.  A FLAG, &ARGS, IS ALSO SET TO INDICATE     *
*       THIS CONDTION.                                                *
*                                                                     *
*   PARAMETERS:  ARGUMENTS MAY BE PASSED THROUGH &SYSLIST.            *
*                                                                     *
*   XREF:  MACROS USED - PUSHNEST.                                    *
*                                                                     *
***********************************************************************
***********************************************************************
*                                                                     *
* MAINTENANCE                                                         *
*   MIKE AMLING -- PROVOKE AN ERROR MESSAGE IF MORE     11/ 2/82  MA01*
*        THAN 25 OPERANDS, RATHER THAN GENERATING INCORRECT CODE      *
*                                                                     *
***********************************************************************
         MACRO
         IF
         GBLA  &LVLPTR             LEVEL OF MACRO INVOCATION
         GBLA  &EXNO               CURRENT SUBSCRIPT OF &EXNOLBL
         GBLA  &NOS                NUMBER TO DISTINGUISH @#NO LBLS
         GBLA  &GOS                NUMBER TO DISTINGUISH @#GO LBLS
         GBLA  &CONDEX(50)         STACK CONTAINING LABEL SUFFIX OF
.*                                  NEXT CONDITION SEGMENT
         GBLA  &DOIFEX(50)         STACK OF UNIQUE LABELS PER LEVEL
         GBLA  &EXNOLBL(100)       STACK OF SAVED @#NO LBLS
         GBLA  &EXNOHI(50)         HIGHEST SUBSCRIPT OF &EXNOLBL IN
.*                                  USE OUTSIDE OF THIS IF
.*
         GBLB  &ERRFLAG            ERROR DISCOVERED BY GENCODE
         GBLB  &FIRSTC             STILL WAITING FOR FIRST CONDITION
         GBLB  &ARGS(50)           SIMPLE IF-ELSE-ENDIF STRUC
         GBLB  &ELSE(50)           INDICATOR OF ELSE PROCESSED AT LEVEL
.*
         LCLA  &CNTR               POINTER TO CPARSE PARAMETER
         LCLA  &GOLBL(12)          STACK OF SAVED @#GO&GOS LABELS
         LCLA  &GO                 CURRENT SUBSCRIPT OF &GOLBL
.*
         LCLB  &NOUSED             @#NO&NOS HAS BEEN USED
         LCLB  &GOUSED             @#GO&GOS HAS BEEN USED
.*
         AIF   (&FIRSTC).IFIF      FIRST CONDITION OF PRECEDING IF OR
.*                                  DO HAS NOT YET APPEARED
&FIRSTC  SETB  (N'&SYSLIST LE 2 AND '&SYSLIST(1)&SYSLIST(2)' EQ '')
         PUSHNEST IF               INITIALIZE STACKS
         AIF   (&FIRSTC).EXIT      IF NO OPERANDS, DO NO MORE
&ARGS(&LVLPTR) SETB  1             TURN ON &ARGS FLAG
.*
.** EDIT FOR IMPROPER USE OF ELSE.
.*
         AIF   ('&SYSLIST(1)' EQ 'ELSE').FIRSELS  IF ELSE IS ERROR
.*
.** THE EDIT PASSED, GENERATE CODE.
.*
&CNTR    SETA  0                   START WITH FIRST POSITIONAL
*        COPY  CPARS               GENERATES CODE
.**********************************************************************
.*   BOB ZIMMERMAN                                                    *
.*   CNA INSURANCE                                                    *
.*   (312) 822-5719                                                   *
.*   LAST MOD 8412                                                    *
.**********************************************************************
.*   THIS MEMBER IS REQUIRED AS A COPY MEMBER BY THE MODULE           *
.*   CPPLRET.                                                         *
.**********************************************************************
.*                                                                    *
.*   COPY MEMBER: 'CPARS'                                             *
.*                                                                    *
.*   FUNCTION:  TO GENERATE TESTING AND BRANCHING CODE IMPLEMENTING   *
.*              THE 'IF', 'ELSIF', 'DO' AND 'COND' MACROS.            *
.*                                                                    *
.*   OPERANDS:  BEGINNING AND ENDING WITH SIMPLE CONDITIONS, THE      *
.*              OPERAND LIST CONSISTS OF SIMPLE CONDITIONS AND        *
.*              LOGICAL OPERATORS APPEARING IN TURNS.  FOR FULL       *
.*              INFORMATION ABOUT SIMPLE CONDITIONS AND LOGICAL       *
.*              OPERATIONS, CONSULT 'CODING OF CONDITIONS' IN         *
.*              USER'S MANUAL.                                        *
.*                                                                    *
.*   XREF:      MACROS USED - 'GENCODE'                               *
.*                                                                    *
.*                                                                    *
.*   AUTHOR:    NAIPING LEE.                                          *
.*                                                                    *
.*   DATE:      24 OCT 1976                                           *
.*                                                                    *
.**********************************************************************
.*                                                                    *
.*   MODIFICATION HISTORY:                                            *
.*   DATE     AUTHOR              COMMENTS                         ID *
.*   05/30/79 MIKE AMLING          REWRITTEN TO GENERATE OPTIMAL  MA02*
.*                                  CODE (RELATED CHANGES TO      MA02*
.*                                  EXLBL AND PUSHNEST)           MA02*
.*                                                                    *
.*   04/12/83 MIKE AMLING          REWRITTEN AS COPY MEMBER       MA03*
.*                                  RATHER THAN MACRO TO SUPPORT  MA03*
.*                                  UNLIMITED NUMBER OF OPERANDS  MA03*
.*                                                                    *
.**********************************************************************
.* THE FOLLOWING VARIABLE SYMBOLS USED IN CPARS SHOULD BE         MA03*
.*  DECLARED IN THE INVOKING MACRO.                               MA03*
.*       GBLA  &LVLPTR             NESTING LEVEL OF MACRO
.*       GBLA  &EXNO               CURRENT SUBSCRIPT OF &EXNOLBL  MA02
.*       GBLA  &NOS                COUNT TO DISTINGUISH @#NO LBLS MA02
.*       GBLA  &GOS                COUNT TO DISTINGUISH @#GO LBLS MA02
.*       GBLA  &CONDEX(50)         STACK OF COND SEQUENCE LABELS
.*       GBLA  &EXNOLBL(100)       STACK OF SAVED @#NO LBLS       MA02
.*       GBLA  &EXNOHI(50)         HIGHEST ELEMENT OF &EXNOLBL IN MA02
.*.*                                USE OUTSIDE OF THIS DO OR IF  MA02
.*.*                                                              MA03
.*       GBLB  &ERRFLAG            ERROR DISCOVERED BY GENCODE
.*.*                                                              MA03
.*       LCLA  &CNTR               POINTER TO CPARSE PARAMETER
.*       LCLA  &GO                 CURRENT SUBSCRIPT OF &GOLBL    MA02
.*       LCLA  &GOLBL(12)          STACK OF SAVED @#GO&GOS LABELS MA02
.*.*                                                              MA03
.*       LCLB  &NOUSED             @#NO&NOS HAS BEEN USED         MA02
.*       LCLB  &GOUSED             @#GO&GOS HAS BEEN USED         MA02
.*---------------------------------------------------------------------
.LOOP    ANOP
&CNTR    SETA  &CNTR+2                 UPDATE PTR TO CURRENT OPERANDS
         AIF   ('&SYSLIST(&CNTR-1)' EQ '').EVEN#P EVEN # PARMS IS ERROR
         AIF   (N'&SYSLIST EQ &CNTR-1).NULL                       MA03
         AIF   ('&SYSLIST(&CNTR)' EQ 'AND').AND                   MA02
         AIF   ('&SYSLIST(&CNTR)' EQ 'OR').OR                     MA02
         AIF   ('&SYSLIST(&CNTR)' EQ 'ANDIF').ANDIF               MA02
         AIF   ('&SYSLIST(&CNTR)' EQ 'ORIF').ORIF                 MA02
         AGO   .BADOP                                             MA03
.*---------------------------------------------------------------------
.NULL    GENCODE &SYSLIST(&CNTR-1),@#EX&CONDEX(&LVLPTR),NOT
         AIF   (&ERRFLAG).CPARSX       SKIP IF ERROR              MA02
.*                SAVE CURRENT @#NO&NOS, IF USED                  MA02
         AIF   (NOT &NOUSED).SAVEN1X                              MA02
&EXNO    SETA  &EXNO+1             GET AN ELEMENT OF &EXNOLBL     MA02
&EXNOLBL(&EXNO) SETA &NOS          SAVE &NOS TO BE DEFINED LATER  MA02
&NOS     SETA  &NOS+1              GET A FRESH &NOS               MA02
.SAVEN1X ANOP                                                     MA02
.*                 DEFINE ALL SAVED @#GO&GOS'S                    MA02
.EXGLOOP AIF   (&GO LE 0).EXGX                                    MA02
@#GO&GOLBL(&GO) EQU *                                             MA02
&GO      SETA  &GO-1                                              MA02
         AGO   .EXGLOOP                                           MA02
.EXGX    ANOP                                                     MA02
.*               DEFINE CURRENT @#GO&GOS, IF USED                 MA02
         AIF   (NOT &GOUSED).CPARSX                               MA02
@#GO&GOS EQU   *                                                  MA02
&GOS     SETA  &GOS+1              GET A FRESH &GOS               MA02
&GOUSED  SETB  0                   NEW &GOS HAS NOT YET BEEN USED MA02
         AGO   .CPARSX                                            MA03
.*---------------------------------------------------------------------
.AND     GENCODE &SYSLIST(&CNTR-1),@#NO&NOS,NOT GEN TESTING CODE  MA02
         AIF   (&ERRFLAG).CPARSX   SKIP IF ERROR                  MA02
&NOUSED  SETB  1                   INDICATE @#NO&NOS USED         MA02
         AGO   .LOOP
.*---------------------------------------------------------------------
.OR      GENCODE &SYSLIST(&CNTR-1),@#GO&GOS,  GEN TESTING CODE    MA02
         AIF   (&ERRFLAG).CPARSX   SKIP IF ERROR                  MA02
&GOUSED  SETB  1                   INDICATE @#GO&GOS USED         MA02
.*               DEFINE CURRENT @#NO&NOS, IF USED                 MA02
         AIF   (NOT &NOUSED).LOOP                                 MA02
@#NO&NOS EQU   *                                                  MA02
&NOS     SETA  &NOS+1              GET A FRESH &NOS               MA02
&NOUSED  SETB  0                   NEW &NOS HAS NOT YET BEEN USED MA02
         AGO   .LOOP
.*---------------------------------------------------------------------
.ANDIF   GENCODE &SYSLIST(&CNTR-1),@#NO&NOS,NOT GEN TESTING CODE  MA02
         AIF   (&ERRFLAG).CPARSX   SKIP IF ERROR                  MA02
.*                    SAVE CURRENT @#NO&NOS                       MA02
&EXNO    SETA  &EXNO+1             GET AN ELEMENT OF &EXNOLBL     MA02
&EXNOLBL(&EXNO) SETA &NOS          SAVE &NOS TO BE DEFINED LATER  MA02
&NOS     SETA  &NOS+1              GET A FRESH &NOS               MA02
&NOUSED  SETB  0                   NEW &NOS HAS NOT YET BEEN USED MA02
.*               DEFINE CURRENT @#GO&GOS, IF USED                 MA02
         AIF   (NOT &GOUSED).LOOP                                 MA02
@#GO&GOS EQU   *                                                  MA02
&GOS     SETA  &GOS+1              GET A FRESH &GOS               MA02
&GOUSED  SETB  0                   NEW &GOS HAS NOT YET BEEN USED MA02
         AGO   .LOOP
.*---------------------------------------------------------------------
.ORIF    GENCODE &SYSLIST(&CNTR-1),@#GO&GOS,   GEN TESTING CODE   MA02
         AIF   (&ERRFLAG).CPARSX   SKIP IF ERROR                  MA02
.*                    SAVE CURRENT @#GO&GOS                       MA02
&GO      SETA  &GO+1               GET AN ELEMENT OF &GOLBL       MA02
&GOLBL(&GO) SETA &GOS              SAVE &GOS TO BE DEFINED LATER  MA02
&GOS     SETA  &GOS+1              GET A FRESH &GOS               MA02
&GOUSED  SETB  0                   NEW &GOS HAS NOT YET BEEN USED MA02
.*                 DEFINE ALL SAVED @#NO&NOS'S                    MA02
.EXNLOOP AIF   (&EXNO LE &EXNOHI(&LVLPTR)).EXNX                   MA02
@#NO&EXNOLBL(&EXNO) EQU *                                         MA02
&EXNO    SETA  &EXNO-1                                            MA02
         AGO   .EXNLOOP                                           MA02
.EXNX    ANOP                                                     MA02
.*                DEFINE CURRENT @#NO&NOS, IF USED                MA02
         AIF   (NOT &NOUSED).LOOP                                 MA02
@#NO&NOS EQU   *                                                  MA02
&NOS     SETA  &NOS+1              GET A FRESH &NOS               MA02
&NOUSED  SETB  0                   NEW &NOS HAS NOT YET BEEN USED MA02
         AGO   .LOOP
.*---------------------------------------------------------------------
.*                                                                MA03
.** ERROR MESSAGES                                                MA03
.*                                                                MA03
.BADOP   ANOP                                                     MA03
&CNTR    SETA  &CNTR-1             FOR CONSISTENCY WITH ORIGINAL  MA02
         MNOTE 12,'*** ERROR: INVALID LOGICAL OPERATER OCCURED AFTER PA-
               RM &CNTR ***'
         AGO   .CPARSX                                            MA03
.EVEN#P  MNOTE 12,'*** ERROR: UNBALANCED (EVEN) NUMBER OF PARAMETERS **-
               *'
.**      AGO   .CPARSX                                            MA03
.CPARSX  ANOP                                                     MA03
         AGO   .EXIT
.*
.** ERROR MESSAGES
.*
.FIRSELS MNOTE 12,'*** ELSE AS FIRST CONDITION IS ILLEGAL ***'
         AGO   .EXIT               GO TO .EXIT
.IFIF    MNOTE 12,'***ERROR: IF IMMEDIATELY FOLLOWS IF OR DO***'
.**      AGO   .EXIT               GO TO .EXIT
.EXIT    MEND
         MACRO
&MNAME   CNAENTER  &BASES,         BASE REGISTER LIST                  X
               &CBASE=DR12,        REGISTER ADDRESSING COMMON          X
               &ENTRY=DYES,        GENERATE ENTRY STATEMENT (WITH NAME)X
               &ID=DYES,           FULL, NONE OR DATELESS ID           X
               &PARM=DR2,          WHERE TO PUT PARM LIST POINTER      X
               &PLOAD=,            HOW TO SET UP PARAMETER POINTERS    X
               &RENT=DYES,         REENTRANCY OR NOT AND TYPE          X
               &SAVE=YES,          SHOULD REGISTERS BE SAVED           X
               &SCLEAR=DNO,        SHOULD SAVE AREA BE CLEARED?        X
               &SNAME=,            NAME OF SAVE/WORK AREA              X
               &SP=,               SUBPOOL FOR SAVE AREA               X
               &SPKA=,             SET PROTECT KEY                     X
               &STACK=D2048,       SIZE OF STACK FOR NEWSTACK OPTION   X
               &STORAGE=DWORKLEN,  LENGTH OF STORAGE TO OBTAIN         X
               &WCLEAR=DNO,        SHOULD WORK AREA BE CLEARED?        X
               &WTG=D              WHERE TO GO FIELD NAME
.*
.*       DECLARE GLOBAL SYMBOLS USED FOR MULTIPLE INVOCATIONS AND
.*       THE CNAEXIT MACRO
.*
         GBLA  &GBLREG#            NUMBER OF BASE REGISTERS
         GBLA  &GBLQCNT            NUMBER OF Q ADDRESS CONSTANTS
         GBLB  &GBLACTV            MACRO HAS BEEN INVOKED BEFORE
         GBLB  &GBLSCLR            CLEAR SAVE AREA OPTION
         GBLB  &GBLWCLR            WORK AREA CLEAR OPTION
         GBLC  &GBLREGS(5)         BASE REGISTER VALUES
         GBLC  &GBLUSNG            BASE REGS WITH COMMAS FOR USING
         GBLC  &GBLID              ID OPTION
         GBLC  &GBLPARM            PARM OPTION
         GBLC  &GBLRENT            RENT OPTION
         GBLC  &GBLRSVE            SAVE REGISTERS OPTION (YES OR NO)
         GBLC  &GBLSAVE            SNAME OPTION
         GBLC  &GBLSTRG            STORAGE OPTION
         GBLC  &GBLSTCK            SIZE OF STACK
         GBLC  &GBLCNAM            CSECT NAME
         GBLC  &GBLQNAM(20)        UP TO 20 Q NAMES
         GBLC  &GBLWTG             WTG OPERAND OF 1ST ENTRY
         GBLC  &GBLCBAS            COMMON BASE REGISTER
         GBLC  &GBLCESP            SUBPOOL FOR GETMAIN AND FREEMAIN
         GBLC  &GBLCESV            SVC TYPE - SVCR6, SVCR15, NSL, NULL
         GBLC  &CNASPFL            LEVEL NUMBER FROM SPF LIBRARY
         GBLC  &CNASPFD            DATE OF LAST MODIFICATION
         GBLC  &CNASPFU            USERID OF LAST UPDATER
.*
.*       LOCAL SYMBOLS USED
.*
         LCLA  &LCLREG#            NUMBER OF ENTRIES IN &BASES
         LCLA  &LCLSUB1            DESTINATION SUBSCRIPT
         LCLA  &LCLSUB2            SOURCE SUBSCRIPT
         LCLA  &LCLIDSZ            SIZE OF ID CONSTANTS
         LCLA  &LCLIDLN            &LCLIDSZ-1
         LCLA  &LCLCONS            LENGTH OF ALL CONSTANTS
         LCLA  &LCLFILL            SIZE TO ALIGN SAVE AREA
         LCLA  &LCLWORK            ARITHMETIC WORK
         LCLA  &LCLPLUS            OFFSET CALCULATIONS
         LCLA  &LCLOFFS            OFFSET TO ENTRY OFFSET
         LCLA  &LCLSTRL            OFFSET TO STORAGE VALUE FOR STACKING
         LCLA  &LCLPRML            NUMBER OF VALUES TO PLOAD OPERAND
         LCLB  &LCLOFF             ON FOR 2ND-NTH ENTRIES
         LCLB  &LCLRENT            IS SOME FORM OF REENTRANCY IN?
         LCLB  &LCLENTR            IS ENTRY STATEMENT NEEDED?
         LCLB  &LCLSCLR            CLEAR SAVE AREA THIS ENTRY?
         LCLB  &LCLWCLR            CLEAR WORK AREA THIS ENTRY?
         LCLC  &LCLENAM            NAME FOR ENTRY STATEMENT
         LCLC  &LCLPARM            NAME FOR KEEPING R1
         LCLC  &LCLCHAR            CHARACTER WORK FIELD
         LCLC  &LCLSTRG            STORAGE THIS TIME THHROUGH
         LCLC  &LCLID              ID OPTION FOR THIS CALL
         LCLC  &LCLSVCT            SVC TYPE - SVCR6, SVCR15, NSL, NULL
         LCLC  &LCLTBAS            ENTRY POINT BASE FOR FIRST INSTRS.
.*
.*       IF THIS IS THE FIRST ENTRY, EDIT THE VALUES GIVEN
.*
         AIF   (&GBLACTV).NTH
&GBLACTV SETB  (1)               SET FOR NEXT TIME IN
&GBLCNAM SETC  '&SYSECT'           SET CSECT NAME
.*
.*       EDIT THE REENTRANCY OPTION  (FIRST SUBPARAMETER)
.*
         AIF   ('&RENT(1)' EQ 'DYES').DRENT
&LCLCHAR SETC  '&RENT(1)'
&LCLRENT SETB  ('&LCLCHAR' EQ 'YES'   OR '&LCLCHAR' EQ 'NEWSTACK' OR   *
                '&LCLCHAR' EQ 'STACK' OR '&LCLCHAR' EQ 'NOSAVE'   OR   *
                '&LCLCHAR' EQ 'COM')
         AIF   (&LCLRENT OR '&LCLCHAR' EQ 'NO').RENTOK
         MNOTE 4,'&RENT IS AN INVALID REENTRANCY OPTION - YES USED.'
.DRENT   ANOP
&GBLRENT SETC  'YES'
&LCLRENT SETB  (1)
         AGO   .RENTOVR
.RENTOK  ANOP
&GBLRENT SETC  '&RENT(1)'
.*
.*       EDIT THE WTG OPERAND IF &GBLRENT=COM
.*
         AIF   ('&GBLRENT' NE 'COM').RENTOVR
         AIF   ('&WTG' EQ 'D').RENTWTX     NO WTG TYPE PROCESSING
&GBLWTG  SETC  '&WTG'
         AIF   ('&GBLWTG' NE '').RENTWTX
         MNOTE *,'WTG OPERAND NULLIFIED - NO WTG CODE GENERATED'
.RENTWTX ANOP
         AIF   ('&CBASE' EQ 'DR12').DEFCBAS
         AIF   ('&CBASE' NE '').ASGNCBS
         MNOTE 8,'COMMON BASE NEEDED TO RELOCATE WORK AREA - R12 USED.'
.DEFCBAS ANOP
&GBLCBAS SETC  'R12'
         AGO   .RENTOVR
.ASGNCBS ANOP
&GBLCBAS SETC  '&CBASE'
.RENTOVR ANOP
.*
.*       EDIT THE SECOND RENT OPERAND.  THIS IS VALID ONLY IF THE
.*       RENT=NEWSTACK OPERAND IS CODED, AND MUST HAVE ONE OF THE
.*       VALUES 'SVCR6' 'SVCR15' 'NSL' OR NULL.
.*
&LCLTBAS SETC  'R15'                           ASSUME R15 AS ENTRY
         AIF   ('&RENT(2)' EQ '').RNT2END      NO SVC OPTION CODED
         AIF   ('&RENT(1)' NE 'NEWSTACK').RNT2E1 ERROR IF NOT NEWSTACK
         AIF   ('&RENT(2)' NE 'SVCR6' AND '&RENT(2)' NE 'SVCR15' AND   X
               '&RENT(2)' NE 'NSL').RNT2E2     NOT VALID ENTRYS
&GBLCESV SETC  '&RENT(2)'                      SET TYPE OF SVC ENTRY
&LCLSVCT SETC  '&RENT(2)'                      SET IT IN LOCAL
         AIF   ('&LCLSVCT' NE 'SVCR6').RNT2END R15 IS RIGHT
&LCLTBAS SETC  'R6'                            SET R6 AS ENTRY BASE
         AGO   .RNT2END
.RNT2E1  MNOTE 8,'SECOND RENT= OPERAND ONLY VALID WITH NEWSTACK'
         AGO   .RNT2END
.RNT2E2  MNOTE 8,'SECOND RENT= OPERAND MUST BE SVCR6, SVCR15, OR NSL'
.RNT2END ANOP
.*
.*       EDIT THE SPKA OPERAND.  IT IS ONLY VALID IF SECOND RENT
.*       OPTION IS USED.  IT IS USED ONLY IF SPECIFIED ON THE MACRO
.*
         AIF   ('&SPKA' EQ '').RNT3END
         AIF   ('&GBLCESV' NE '').RNT3END  SKIP IF 2ND RENT SPEC'D
         MNOTE 4,'SPKA= OPERAND NOT VALID IF 2ND RENT OPTION OMITTED'
.RNT3END ANOP
.*
.*       EDIT THE SAVE OPERAND.  THIS MUST BE YES UNLESS RENT=
.*       NO OR NOSAVE WAS ENTERED.  THEN IT MAY BE NO.
.*
&GBLRSVE SETC  'YES'                FORCE DEFAULT VALUE
         AIF ('&SAVE' EQ 'YES').RSAVEOK
         AIF ('&SAVE' NE 'NO').RSAVEX1
         AIF ('&GBLRENT' EQ 'NO' OR '&GBLRENT' EQ 'NOSAVE').RSAVEOK
         MNOTE 8,'SAVE=NO ONLY ALLOWED WITH RENT=NO OR RENT=NOSAVE'
         AGO   .RSAVEXL
.RSAVEX1 MNOTE 8,'SAVE= MUST BE YES OR NO'
         AGO   .RSAVEXL
.RSAVEOK ANOP
&GBLRSVE SETC  '&SAVE'
.RSAVEXL ANOP
.*
.*       EDIT THE STACK OPERAND - SHOULD BE D2048 UNLESS
.*       &GBLRENT=NEWSTACK.  IN THAT CASE, SET &GBLSTCK
.*       TO VALUE OF STACK OPERAND.  MULTIPLY BY 1024 IF
.*       ALL NUMERIC EXCEPT TERMINAL K.
.*
         AIF   ('&GBLRENT' EQ 'NEWSTACK').NSEDIT
         AIF   ('&STACK' EQ 'D2048').STACKX
         MNOTE 4,'STACK= IGNORED SINCE RENT=NEWSTACK NOT SPECIFIED'
         AGO   .STACKX
.NSEDIT  ANOP
&LCLWORK SETA  K'&STACK
         AIF   ('&STACK'(&LCLWORK,1) EQ 'K' AND &LCLWORK GT 1).KVAL
         AIF   ('&STACK' NE 'D2048').ASGNSTK
&GBLSTCK SETC  '2048'
         AGO   .STACKX
.KVAL    ANOP
&LCLCHAR SETC  '&STACK'(1,&LCLWORK-1)
.KVALOOP ANOP
&LCLWORK SETA  &LCLWORK-1
         AIF   ('&LCLCHAR'(&LCLWORK,1) LT '0').ASGNSTK
         AIF   (&LCLWORK GT 1).KVALOOP
&GBLSTCK SETC  '&LCLCHAR*1024'
         AGO   .STACKX
.ASGNSTK ANOP
&GBLSTCK SETC  '&STACK'
.STACKX  ANOP
.*
.*       EDIT THE BASE REGISTER SET AND SET UP GBLREG#, GBLREGS AND
.*       GBLUSNG.
.*
&LCLREG# SETA  N'&BASES
&GBLREG# SETA  &LCLREG#
&LCLSUB1 SETA  1
&LCLSUB2 SETA  1
         AIF   (&LCLRENT).OK#
&GBLREG# SETA  &GBLREG#+1          INCREMENT FOR R13 ADDITION
&GBLREGS(1) SETC 'R13'
&LCLSUB1 SETA  2
.OK#     ANOP
         AIF   (&GBLREG# GT 0).OKCOPY
         MNOTE 8,'NO BASE REGISTERS SPECIFIED - WILL USE R11'
&GBLREG# SETA  1
&GBLREGS(1) SETC 'R11'
.OKCOPY  AIF   (&LCLSUB2 GT &LCLREG#).COPUSNG
&GBLREGS(&LCLSUB1) SETC '&BASES(&LCLSUB2)'
&LCLSUB1 SETA  &LCLSUB1+1
&LCLSUB2 SETA  &LCLSUB2+1
         AGO   .OKCOPY
.COPUSNG ANOP
&GBLUSNG SETC  ',&GBLREGS(1)'
         AIF   (&GBLREG# LE 1).ID
&LCLSUB1 SETA  2
         AIF   ('&LCLSVCT' NE '').ERRSVC1
.UCOPY   AIF   (&LCLSUB1 GT &GBLREG#).ID
&GBLUSNG SETC  '&GBLUSNG,&GBLREGS(&LCLSUB1)'
&LCLSUB1 SETA  &LCLSUB1+1
         AGO   .UCOPY
.ERRSVC1 MNOTE 4,'ONLY 1 BASE REGISTER SUPPORTED FOR SVC TYPE &LCLSVCT'
.*
.*       EDIT THE IDENTIFICATION OPTION - DEFAULT IS DYES(YES)-IF SPEC
.*       IS NOT YES, NO, NODATE OR SHORT, SET TO SHORT
.*
.ID      AIF   ('&ID' EQ 'DYES').DID
         AIF   ('&ID' EQ 'YES').IDOK
         AIF   ('&ID' EQ 'NO').IDOK
         AIF   ('&ID' EQ 'NODATE').IDOK
         AIF   ('&ID' EQ 'SHORT').IDOK
         MNOTE 4,'&ID IS AN INVALID IDENTIFICATION OPTION - SHORT USED'
&GBLID   SETC  'SHORT'
&LCLID   SETC  'SHORT'
         AGO   .PRM
.DID     ANOP
&GBLID   SETC  'YES'
&LCLID   SETC  'YES'
         AGO   .PRM
.IDOK    ANOP
&GBLID   SETC  '&ID'
&LCLID   SETC  '&ID'
.*
.*       EDIT THE PARM OPERAND - SET R2 IF OMITTED
.*
.PRM     AIF   ('&PARM' EQ 'DR2').DPARM
         AIF   ('&PARM' NE '').SETPRM
         MNOTE *,'INPUT PARAMETER LIST POINTER WILL BE IN R2'
.DPARM   ANOP
&GBLPARM SETC  'R2'
&LCLPARM SETC  'R2'
         AGO   .ENT
.SETPRM  ANOP
&GBLPARM SETC  '&PARM'
&LCLPARM SETC  '&PARM'
.*
.*       EDIT THE ENTRY= OPERAND - VALID VALUES ARE YES, NO AND
.*       (YES,NAME) - IF YES, &MNAME MUST NOT BE NULL - SET NO
.*       IF INVALID VALUE OR YES AND NO &MNAME
.*
.ENT     ANOP
&LCLENAM SETC  '&MNAME'                  SET LOCAL NAME TO MACRO
         AIF   ('&MNAME' NE '').ENTNOK   YES, LET IT DEFAULT
&LCLENAM SETC  '&SYSECT'                 MUST BE AT START OF MACRO
.ENTNOK  AIF   ('&ENTRY' EQ 'DYES').EYES
         AIF   ('&ENTRY' EQ 'YES').EYES
         AIF   ('&ENTRY' EQ 'NO').SNAME
         AIF   ('&ENTRY(1)' EQ 'YES').ENAME
         MNOTE 4,'&ENTRY INVALID ENTRY OPTION - NO USED'
         AGO   .SNAME
.EOMIT   MNOTE 8,'ENTRY NAME OMITTED - WILL USE NAME FIELD OF CNAENTER X
               MACRO IF PRESENT'
.EYES    AIF   ('&MNAME' EQ '').ENONE
&LCLENAM SETC  '&MNAME'
&LCLENTR SETB  (1)
         AGO   .SNAME
.ENAME   AIF   ('&ENTRY(2)' EQ '').EOMIT
&LCLENAM SETC  '&ENTRY(2)'
&LCLENTR SETB  (1)
         AGO   .SNAME
.ENONE   MNOTE 8,'ENTRY=YES CANCELLED BECAUSE THERE IS NO NAME ON THE MX
               ACRO'
.*
.*       SET THE GLOBAL SAVEVAL TO BE SAVE/WORK AREA NAME FROM
.*       SNAME= OPERAND.  DEFAULT TO WORKAREA OR SAVEAREA
.*       DEPENDING ON REENTRANCY OPTION
.*
.SNAME   AIF   ('&SNAME' EQ '').SNDEF
&GBLSAVE SETC  '&SNAME'
         AGO   .QCONCK
.SNDEF   ANOP
&GBLSAVE SETC  'WORKAREA'
         AIF   (&LCLRENT).QCONCK
&GBLSAVE SETC  'SAVEAREA'
.QCONCK  AIF   ('&GBLRENT' NE 'COM').SCLR
         CNADXD &GBLSAVE
&GBLSAVE SETC  '&GBLQNAM(&GBLQCNT)'
.*
.*       SET THE GLOBAL CLEARS
.*
.SCLR    ANOP
&GBLSCLR SETB  ('&SCLEAR' EQ 'YES')
&LCLSCLR SETB  (&GBLSCLR)
.*
.*       SET THE GLOBAL CLEARW
.*
&GBLWCLR SETB  ('&WCLEAR' EQ 'YES')
&LCLWCLR SETB  (&GBLWCLR)
.*
.*       SET GLOBAL STRGVAL FROM STORAGE= - NULL ALLOWED FOR NON-RENT
.*
&GBLSTRG SETC  'WORKLEN'
&LCLSTRG SETC  'WORKLEN'
         AIF   ('&STORAGE' EQ 'DWORKLEN').EDITSP
&GBLSTRG SETC  '&STORAGE'
&LCLSTRG SETC  '&STORAGE'
         AIF   ('&GBLSTRG' NE '').EDITSP
         AIF   (NOT &LCLRENT).CALC
         AIF   ('&RENT(1)' EQ 'NOSAVE').EDITSP
&GBLSTRG SETC  'WORKLEN'
&LCLSTRG SETC  'WORKLEN'
         MNOTE 8,'STORAGE= NULLIFIED BUT VALUE REQUIRED - WORKLEN USED'
.*
.*  EDIT THE SP= PARAMETER (SUBPOOL = )
.*
.EDITSP  ANOP
&GBLCESP SETC '0'            DEFAULT IT TO SUBPOOL 0
         AIF  ('&SP' EQ '').CALC  ACCEPT THE DEFAULT
&GBLCESP SETC '&SP'          SET THE OPERAND VALUE
         AGO  .CALC
.*
.*
.*
.*       EDIT SUPPLIED OPERANDS AGAINST GLOBAL VALUES USED IN FIRST
.*       INVOCATION OF CNAENTER
.*
.*
.*
.NTH     ANOP
.*
.*       SET UP LOCAL ITEMS TO MATCH GLOBALS FOR FIRST APPROXIMATION
.*
&LCLSCLR SETB  (&GBLSCLR)
&LCLWCLR SETB  (&GBLWCLR)
&LCLPARM SETC  '&GBLPARM'
&LCLID   SETC  '&GBLID'
&LCLSTRG SETC  '&GBLSTRG'
&LCLOFF  SETB  (1)
&LCLSVCT SETC  '&GBLCESV'             SVC TYPE
&LCLTBAS SETC  'R15'                  TEMPORARY BASE IS R15
         AIF   ('&LCLSVCT' NE 'SVCR6').RNT2L1
&LCLTBAS SETC  'R6'                   TEMPORARY BASE IS R6 FOR SVCR6
.RNT2L1  ANOP
.*
.*       IGNORE ANY DESIGNATION OF BASE REGISTERS
.*
         AIF   (N'&BASES EQ 0).RENTR
         MNOTE 4,'BASE REGISTERS IGNORED - WILL USE SAME AS ON 1ST CALLX
                TO CNAENTER - &GBLREGS(1) IS FIRST BASE'
.*
.*       THE ENTRY ATTRIBUTE MUST BE ASSUMED ELSE WHY ANOTHER ENTRY?
.*
.RENTR   AIF   ('&ENTRY' EQ 'DYES' OR '&ENTRY' EQ 'YES').RSETM
         AIF   ('&ENTRY(2)' NE '').RSET2
         MNOTE 8,'&ENTRY INVALID FOR THIS CALL - YES USED AND NAME ON MX
               ACRO WILL BE ENTRY NAME'
.RSETM   AIF   ('&MNAME' NE '').RSETM2
         MNOTE 8,'MACRO NAME REQUIRED FOR ENTRY POINT - ####$$$$ USED'
&LCLENAM SETC  '####$$$$'
         AGO   .RENTSET
.RSET2   ANOP
&LCLENAM SETC  '&ENTRY(2)'
         AGO   .RENTSET
.RSETM2  ANOP
&LCLENAM SETC  '&MNAME'
.RENTSET ANOP
&LCLENTR SETB  (1)
.*
.*       ID VALUE RESET TO CONTAIN NO DATE SPECIFICATION IF YES
.*       CURRENTLY IN EFFECT
.*
         AIF   ('&LCLID' NE 'YES').CKIDOVR
&LCLID   SETC  'NODATE'
.CKIDOVR AIF   ('&ID' EQ 'DYES').RPRM
         AIF   ('&ID' EQ 'YES').LCLYES
         AIF   ('&ID' EQ 'SHORT').LCLYES
         AIF   ('&ID' EQ 'NODATE').LCLYES
         AIF   ('&ID' EQ 'NO').LCLYES
         MNOTE 4,'&ID INVALID FOR ID= - VALUE &LCLID USED.'
         AGO   .RPRM
.LCLYES  ANOP
&LCLID   SETC  '&ID'
.*
.*       SEE IF PARM REGISTER TO BE OVERRIDEN FOR THIS ENTRY
.*
.RPRM    ANOP
         AIF   ('&PARM' EQ 'DR2').RRENT
&LCLPARM SETC  '&PARM'
.*
.*       FLUSH RENT OPTION IF CODED - USE ORIGINAL
.*
.RRENT   AIF   ('&RENT(1)' EQ 'DYES').RSWRCK
         AIF   ('&RENT(1)' EQ '&GBLRENT').RSWRCK
         MNOTE 4,'&RENT REENTRANCY OPTION IGNORED - &GBLRENT FROM FIRSTX
               USE OF CNAENTER USED.'
.RSWRCK  ANOP
.*
.*       SET &LCLRENT FOR PROPER GEN TYPE
.*
&LCLRENT SETB  ('&GBLRENT' EQ 'YES'   OR '&GBLRENT' EQ 'NEWSTACK' OR   *
                '&GBLRENT' EQ 'STACK' OR '&GBLRENT' EQ 'NOSAVE' OR     *
                '&GBLRENT' EQ 'COM')
.*
.*       EDIT SPKA OPTION. ONLY VALID IF 2ND RENT OPTION CODED
.*
         AIF  ('&SPKA' EQ '' OR '&GBLCESV' NE '').RNT4OK
         MNOTE 4,'SPKA=&SPKA IGNORED IF 2ND RENT OPTION NOT CODED'
.RNT4OK  ANOP
.*
.*       EDIT WTG OPERAND IF GBLRENT=COM
.*
         AIF   ('&GBLRENT' NE 'COM').NOCBAS
         AIF   ('&GBLWTG' EQ '').NLWTG
         AIF   ('&WTG' EQ 'D' OR '&WTG' EQ '&GBLWTG').NOWTGE
         MNOTE 8,'&WTG WTG ENTRY IGNORED - &GBLWTG USED'
         AGO   .NOWTGE
.NLWTG   ANOP
         AIF   ('&WTG' EQ 'D' OR '&WTG' EQ '').NOWTGE
         MNOTE 8,'NO WTG CODE GENERATED DUE TO FIRST ENTRY CONDITIONS'
.NOWTGE  ANOP
         AIF   ('&CBASE' EQ 'DR12' OR '&CBASE' EQ '&GBLCBAS').NOCBAS
         MNOTE 8,'COMMON BASE CODED IGNORED - &GBLCBAS USED'
.NOCBAS  ANOP
.*
.*       RESET LOCAL VALUE OF CLEAR SWITHCES IF NOT DEFAULTED
.*
         AIF   ('&SCLEAR' EQ 'DNO').CKWCLR
&LCLSCLR SETB  ('&SCLEAR' EQ 'YES')
.CKWCLR  AIF   ('&WCLEAR' EQ 'DNO').RSN
&LCLWCLR SETB  ('&WCLEAR' EQ 'YES')
.*
.*       SAVE AREA NAME MUST REMAIN CONSTANT OVER INVOCATIONS
.*
.RSN     AIF   ('&SNAME' EQ '').RSTRG
         AIF   ('&SNAME' EQ '&GBLSAVE').RSTRG
         MNOTE 8,'&SNAME WILL NOT BE USED FOR SAVE/WORK AREA NAME - &GBL
               LSAVE WILL BE USED INSTEAD'
.*
.*       STORAGE VALUE CAN ONLY CHANGE FOR RENT=NEWSTACK OR RENT=STACK
.*
.RSTRG   AIF   ('&STORAGE' EQ 'DWORKLEN').CALC
         AIF   ('&STORAGE' EQ '&GBLSTRG').CALC
         AIF   ('&GBLRENT' EQ 'NEWSTACK' OR '&GBLRENT' EQ 'STACK').REST
        MNOTE 8,'UNABLE TO CHANGE STORAGE LENGTH - VALUE &GBLSTRG USED'
         AGO   .CALC
.REST    ANOP
&LCLSTRG SETC  '&STORAGE'
.*
.*
.*
.*       COMMON MACRO SET UP AND OFFSET CALCULATION
.*
.*
.*    ID=    NO     SHORT   NODATE    YES     ENTRY=  (SPFID)  FIRST?
.*
.*            0       10      10       24       NO       NO      ---
.*
.*                            28       28       YES      ---     NO
.*
.*                            28       42       YES      NO      YES
.*
.*                            34       48       NO       YES     ---
.*
.*                            52       66       YES      YES     YES
.*
.*
.CALC    ANOP
&LCLIDSZ SETA  0
         AIF   ('&LCLID' EQ 'NO').NOSPFID
&LCLIDSZ SETA  10
         AIF   ('&LCLID' EQ 'SHORT').NOSPFID  NO ID OR DATES
         AIF   (NOT &LCLENTR AND NOT &LCLOFF).IDLEN
&LCLIDSZ SETA  &LCLIDSZ+18           FOR ENTRY=YES
.IDLEN   AIF   (&LCLOFF).NOSPFID     NO DATES FOR 2ND ENTRY
         AIF   ('&LCLID' EQ 'NODATE').CALCND  NO DATE - MAY BE SPF
&LCLIDSZ SETA  &LCLIDSZ+14           FOR ASSEMBLY DATE AND TIME
.CALCND  AIF   ('&CNASPFL' EQ '').NOSPFID       SKIP IF NO SPF DATA
&LCLIDSZ SETA  &LCLIDSZ+24         LENGTH OF SPF SOURCE DATA
.NOSPFID ANOP
&LCLIDLN SETA  &LCLIDSZ-1
.*
.*       SIZE OF ID CONSTANTS CALCULATED - CALCULATE TOTAL
.*       CONSTANT SIZE BY ADDING 2 FOR STORAGE CALCULATION
.*       FOR STACKING, 2 FOR OFFSET FOR BASE 1 CALCULATION
.*       AND 72 PLUS ALIGNMENT FILLER FOR IN-LINE SAVE AREAS.
.*
&LCLCONS SETA  &LCLIDSZ
&LCLPLUS SETA  4
         AIF   (NOT &LCLOFF).NOFF
&LCLCONS SETA  &LCLCONS+2         ADD FOR BASE 1 OFFSET
&LCLOFFS SETA  &LCLIDSZ+&LCLPLUS
&LCLPLUS SETA  &LCLPLUS+2
.NOFF    AIF   ('&GBLRENT' NE 'STACK' AND '&GBLRENT' NE 'NEWSTACK').N
&LCLCONS SETA  &LCLCONS+2         ADD FOR STORAGE OFFSET
&LCLSTRL SETA  &LCLIDSZ+&LCLPLUS
&LCLPLUS SETA  &LCLPLUS+2
.N       AIF   ('&GBLRENT' NE 'NO' OR &LCLOFF).NOSAVE
&LCLWORK SETA  &LCLCONS/4
&LCLWORK SETA  &LCLWORK*4
&LCLFILL SETA  &LCLWORK+4-&LCLCONS
         AIF   (&LCLFILL LT 4).FSET
&LCLFILL SETA  0
.FSET    ANOP
&LCLCONS SETA  &LCLCONS+&LCLFILL+72
.*
.*
.*       CALCULATIONS ARE DONE ... BEGIN CODE GENERATION
.*
.*
.NOSAVE  ANOP
         AIF   (NOT &LCLOFF).NOALGN
         CNOP  0,8                 FORCE DOUBLE WORD ALIGNMENT
.NOALGN  AIF   (NOT &LCLENTR).NEGE
&LCLENAM DS    0H                  ENTRY POINT NAME
         ENTRY &LCLENAM            EXTERNAL DECLARATION
.NEGE    AIF   ('&MNAME' EQ '').NNAME
         AIF   ('&LCLENAM' EQ '&MNAME' AND &LCLENTR).NNAME
&MNAME   DS    0H                  ENTRY POINT NAME
.NNAME   ANOP
         USING *,&LCLTBAS          TEMPORARY BASE
         AIF   (&LCLCONS EQ 0).NOCONS
&LCLWORK SETA  &LCLCONS+4
         B     *+&LCLWORK          BRANCH AROUND ALL CONSTANTS
         AIF   (&LCLIDSZ EQ 0).NOIDSZ
         DC    AL1(&LCLIDLN)       LENGTH OF ID FIELDS
         AIF   (NOT &LCLENTR).NOECON
         DC    CL9'&LCLENAM'       ENTRY NAME IN ID FIELDS
         AIF   (&LCLIDSZ EQ 10).NOIDSZ
         DC    CL9'IN CSECT '
.NOECON  DC    CL9'&SYSECT'        CSECT NAME IN ID FIELDS
         AIF   (&LCLIDSZ EQ 10).NOIDSZ
         AIF   (&LCLOFF).NOIDSZ    SKIP BOTH TIME AND SPF DATA FOR 2ND
         AIF   ('&LCLID' EQ 'NODATE').SPFID1
         DC    CL9'&SYSDATE'       ASSEMBLY DATE IN ID FIELDS
         DC    CL5'&SYSTIME'       ASSEMBLY TIME IN ID FIELDS
.SPFID1  AIF   ('&CNASPFD' EQ '').NOIDSZ INSERT SPF DATA
         DC    CL8' &CNASPFD'      DATE OF THIS MODIFICATION
         DC    CL8'&CNASPFL'       LEVEL NUMBER OF THIS VERSION
         DC    CL8'&CNASPFU'       TSO USERID OF LAST UPDATER
.NOIDSZ  AIF   (NOT &LCLOFF).STCKCK
         AIF   ('&GBLRENT' EQ 'NO').SAOFF
         DC    Y(&LCLENAM-&SYSECT) OFFSET TO MODULE BASE
         AGO   .STCKCK
.SAOFF   DC    Y(&LCLENAM-&GBLSAVE) OFFSET TO MODULE BASE
.STCKCK  AIF   ('&GBLRENT' NE 'STACK' AND '&GBLRENT' NE 'NEWSTACK').F
         DC    Y(&LCLSTRG)         WORK AREA SIZE FROM STACK
.F       AIF   ('&GBLRENT' NE 'NO' OR &LCLOFF).NOCONS
         AIF   (&LCLFILL EQ 0).NOFILL
         DC    XL(&LCLFILL)'00'    FILLER TO ALIGN SAVE AREA
.NOFILL  ANOP
&GBLSAVE DC    18F'0'              MODULE'S SAVE AREA
.NOCONS  ANOP
         SPACE 2
.*
.*             GENERATE CODE FOR SVC ENTRY OPTIONS
.*
         AIF   ('&LCLSVCT' EQ '').RNT2GND   NO SVC ENTRY, GO TO STD.
         AIF   ('&LCLSVCT' EQ 'SVCR6').RNT2G1 DON'T SAVE BASE REGISTER
         AIF   ('&LCLSVCT' EQ 'NSL').RNT2G1  LIKEWISE FOR NSL OPTION
         LR    R3,&LCLTBAS         SAVE TEMPORARY BASE
         DROP  &LCLTBAS
         USING &LCLENAM,R3
&LCLTBAS SETC  'R3'                RESET TEMPORARY BASE
.RNT2G1  AIF   ('&SPKA' EQ '').RNT2G1A      SKIP IF NO SPKA OPTION
         AIF   ('&SPKA' NE 'DATAMGT').USERSPK
         SPKA  80                  SET DATAMGT PROTECT KEY
         AGO   .RNT2G1A
.USERSPK SPKA  &SPKA               SET PROTECT KEY FOR USER
.RNT2G1A ANOP
  DS  0C'GETMAIN R,LV=&GBLSTCK,SP=&GBLCESP' GET NEW STACK
         GETMAIN R,LV=&GBLSTCK,SP=&GBLCESP
         AIF   ('&LCLSVCT' NE 'NSL').RNT2G2  SKIP SAVE IF NOT NSL
         STM   R2,R14,80(R1)       SAVE OPEN/CLOSE/EOV REGS (EX. R3)
         LR    R13,R1              SET SAVEAREA IN PROPER BASE
         BALR  &GBLREGS(1),0       GET LOCATION
         LA    R15,*-&SYSECT       CALCULATE CORRECT BASE
         SLR   &GBLREGS(1),R15      --> 4K MODULE LIMIT <--
         AGO   .RNT2G3             SKIP OTHER OPTION FIDDLING
.RNT2G2  LR    R13,R1              SET SAVEAREA IN PROPER BASE
         AIF   ('&GBLREGS(1)' EQ '&LCLTBAS' AND NOT &LCLOFF).RNT2G3A
         AIF   ('&GBLREGS(1)' EQ '&LCLTBAS').RNT2G2A
         LR    &GBLREGS(1),&LCLTBAS SET PERMANENT BASE REGISTER
.RNT2G2A AIF   (NOT &LCLOFF).RNT2G3      SKIP IF NOT SECOND ENTRY
         SH    &GBLREGS(1),&LCLENAM+&LCLOFFS ADJUST THE BASE REGISTER
.RNT2G3  DROP  &LCLTBAS            RESET ADDRESSING
         USING &SYSECT&GBLUSNG     SET USING FOR PROGRAM
.RNT2G3A LH    R15,&LCLENAM+&LCLSTRL SET ADDRESS OF NEXT
         AR    R15,R13              WORKAREA IN THE STACK
         ST    R15,72(,R13)         FOR RENT=STACK PROCESSING
         XC    4(8,R13),4(R13)      CLEAR BACK AND FOREWARD POINTERS
         USING &GBLSAVE,R13         DECLARE DSA
         AIF   ('&LCLSVCT' NE 'SVCR6').RNT2G4 IS IT R6 ENTRY
         LM    R0,R1,32(R5)         RESTORE PARAMETER REGS FROM
         L     R15,92(R5)           SVRB SAVEAREA
.RNT2G4  SPACE 2
         MEXIT
.RNT2GND ANOP
.*
.*             NOW GENERATE FOR NON SVC ENTRY OPTIONS
.*
         AIF   ('&GBLRSVE' EQ 'NO').RSVE#1
         STM   R14,R12,12(R13)     SAVE CALLER'S REGISTERS
         AGO   .RSVE#2
.RSVE#1  LR    R3,R14              SAVE R14 FOR RETURN
.RSVE#2  LR    &LCLPARM,R1         SAVE INPUT PARAMETER LIST PTR.
         AIF   (&LCLRENT).RBASES
         AIF   (&LCLOFF).SOFFBAS
         LA    R15,&GBLSAVE        WILL BE BASE AND S.A. POINTER
.NRBAS   ST    R13,4(,R15)         SET BACK CHAIN
         ST    R15,8(,R13)         SET FORWARD CHAIN
         LR    R13,R15             SET BASE AND S.A. POINTER
         DROP  R15                 END TEMPORARY ADDRESSING
         USING &GBLSAVE&GBLUSNG    PERMANENT ADDRESSING
         AGO   .NTHBASE
.SOFFBAS ANOP
         SH    R15,&LCLENAM+&LCLOFFS WILL BE BASE AND S.A. POINTER
         AGO   .NRBAS
.RBASES  LR    &GBLREGS(1),R15     SET 1ST BASE REGISTER
         AIF   (NOT &LCLOFF).ROFFBAS
         SH    &GBLREGS(1),&LCLENAM+&LCLOFFS RESET BACK TO ORIGIN
.ROFFBAS DROP  R15                 END TEMPORARY ADDRESSING
         USING &SYSECT&GBLUSNG     PERMANENT ADDRESSING
.NTHBASE AIF   (&GBLREG# LE 1).NTHSET
&LCLSUB1 SETA  2
&LCLSUB2 SETA  1
         LA    R14,2048            CONSTANT FOR NTH BASE GENERATION
.NTHGENR AIF   (&LCLSUB1 GT &GBLREG#).NTHSET
         LA    &GBLREGS(&LCLSUB1),2048(R14,&GBLREGS(&LCLSUB2).)
&LCLSUB2 SETA  &LCLSUB1
&LCLSUB1 SETA  &LCLSUB1+1
         AGO   .NTHGENR
.NTHSET  ANOP
         SPACE 2
         AIF   ('&GBLRENT' EQ 'NO').PL
         AIF   ('&GBLRENT' EQ 'NOSAVE').PL
         AIF   ('&GBLRENT' EQ 'YES').GET
         AIF   ('&GBLRENT' EQ 'STACK').STACK
         AIF   ('&GBLRENT' EQ 'COM').COMGET
*                                  GET STACK
         GETMAIN  R,LV=&GBLSTCK,SP=&GBLCESP
         AGO   .FWDCHN
.STACK   ANOP
         L     R1,72(,R13)         GET NEXT AREA ORIGIN IN STACK
         AGO   .FWDCHN
.GET     ANOP
*                                  GET WORKING STORAGE
         GETMAIN  R,LV=&LCLSTRG,SP=&GBLCESP
         AGO   .FWDCHN
.COMGET  ANOP
         L     R1,Q&GBLQNAM(1)     GET OFFSET TO WORK AREA
         AR    R1,&GBLCBAS         ADJUST TO ADDRESS
.FWDCHN  ST    R1,8(,R13)          SET FORWARD CHAIN
         AIF   (NOT &LCLWCLR).SCLRCK
         LR    R14,R1              ADDRESS TO BEGIN CLEAR
         AIF   ('&GBLRENT' EQ 'YES').CLRLC
         AIF   (&LCLENTR).LHENTR
         LH    R15,&SYSECT+&LCLSTRL LENGTH OF CLEAR
         AGO   .CLRCMN
.CLRLC   LH    R15,*+8             LENGTH OF CLEAR
         B     *+6                 AROUND CONSTANT
         DC    Y(&LCLSTRG)         SIZE OF WORK AREA
         AGO   .CLRCMN
.LHENTR  LH    R15,&LCLENAM+&LCLSTRL LENGTH OF CLEAR
.CLRCMN  SR    R1,R1               FILL CHARACTER IS X'00'
         MVCL  R14,R0              CLEAR THE WORK AREA
         L     R1,8(,R13)          RELOAD CURRENT WORK POINTER
         AGO   .CLRD
.SCLRCK  AIF   (NOT &LCLSCLR).CLRD
         XC    0(72,R1),0(R1)      CLEAR THE SAVE AREA
.CLRD    AIF   ('&GBLRENT' EQ 'YES' OR '&GBLRENT' EQ 'COM').NOSTKS
         AIF   (&LCLENTR).LENENTR
         LH    R15,&SYSECT+&LCLSTRL SIZE OF AREA NEEDED IN STACK
         AGO   .BLDSTKN
.LENENTR LH    R15,&LCLENAM+&LCLSTRL SIZE OF AREA NEEDED IN STACK
.BLDSTKN AR    R15,R1              R15 IS NEXT FREE SLOT IN STACK
         ST    R15,72(,R1)         SET FOR NEXT MODULE TO FIND
.NOSTKS  AIF   ('&GBLRSVE' EQ 'NO').NRSV#3
         ST    R13,4(,R1)          SET BACK CHAIN
         LM    R13,R1,8(R13)       RESTORE CLOBBERED REGISTERS
         USING &GBLSAVE,R13        TELL ASSEMBLER ABOUT REGISTER
         AGO   .PL                 GO CHECK FOR PARAMETER LIST SAVE
.NRSV#3  LR    R13,R1              SET WORK AREA REGISTER
         USING &GBLSAVE,R13        TELL ASSEMBLER ABOUT REGISTER
.PL      AIF   ('&PLOAD' EQ '').DONE
&LCLPRML SETA  N'&PLOAD
&LCLWORK SETA  1
         SPACE 2
.PLLOOP  CNAPLOAD &PLOAD(&LCLWORK),&LCLWORK,&LCLPARM
&LCLWORK SETA  &LCLWORK+1
         AIF   (&LCLWORK LE &LCLPRML).PLLOOP
.DONE    AIF   ('&GBLRENT' NE 'COM').DONE1
         AIF   ('&GBLWTG' EQ '').DONE1
         ICM   R15,15,&GBLWTG         PICK UP WHERE TO GO ADDRESS
         BNZR  R15                    GO THERE IF INITIALIZED
.DONE1   ANOP
         SPACE 2
         MEND
CPPLRET  TITLE '- PROVIDE COMMAND PROCESSOR INTERFACE'
***********************************************************************
*  IF ONLY 1 INPUT PARAMETER
*      IF RUNNING AS JST
*          FAKE A CBUF, UPT, PSCB AND ECT
*      ELSE
*          FAKE A CBUF AND FIND THE REAL UPT, PSCB AND ECT
*      ENDIF
*      COPY THE PARM FIELD INTO THE CBUF
*  ENDIF
*  EXIT TO XXXXXXXX
***********************************************************************
CPPLRET  CSECT
R0       EQU   0
R1       EQU   1
R2       EQU   2
R12      EQU   12
R13      EQU   13
R14      EQU   14
R15      EQU   15
         USING PSA,R0
         RG    (RBASE,CPPLRET)
         CNAENTER RBASE,ENTRY=NO,RENT=NOSAVE
         USING SAVEAREA,R13
         L     RTCB,PSATOLD      ADDRESS OUR TCB
         RG    (RTCB,TCB)
         SPACE 1
         RG    (RPARM,PARM),RPARMLEN
         ICM   RPARM,B'1111',0(R1)
         IF    M                 IF ONLY 1 PARAM
             LH    RPARMLEN,PARM
             IF    (CL,RTCB,TCBJSTCB,E)  IS THIS THE JOB STEP TASK?
                 RF    RTCB
                 DC    H'0'          NOT YET SUPPORTED
             ENDIF
             LA    R0,WORKLEN(RPARMLEN)
             GETMAIN R,LV=(0)
             LR    RW,R1
             RG    (RW,WORKAREA)
             SPACE 1
             MVC   EXTRLIST,PROTEXTR
             EXTRACT EXTRANS,MF=(E,EXTRLIST) CHANGES R14
             L     R1,EXTRANS
             USING PSCB,R1
             SPACE 1
             LA    R15,CBUF      SET UP CPPL: CBUF, UPT, PSCB, ECT
             L     R2,PSCBRLGB   ADDRESS THE RELOGON BUFFER
             L     R0,PSCBUPT
             L     R2,256(,R2)   GET ECT ADDRESS FROM WORD AFTER RLGB
             USING ECT,R2
             NI    ECTSWS,X'FF'-ECTNOPD
             STM   R15,R2,WORKCPPL
             DROP  R1
             IF    (LTR,RPARMLEN,RPARMLEN,Z)
                 OI    ECTSWS,ECTNOPD  TURN ON THE NO-OPERANDS SWITCH
                 DROP  R2
             ENDIF
             LA    R0,4(,RPARMLEN)  SET THE CBUF LENGTH AND OFFSET
             SLL   R0,16
             ST    R0,CBUFLLOO
             SPACE 1
             LA    R0,CBUFCHAR   COPY THE PARM FIELD TO THE CBUF
             LR    R1,RPARMLEN
             LA    RPARM,2(,RPARM)
             MVCL  R0,RPARM
             RF    RPARM,RPARMLEN
             LR    R1,RW         PASS CPPL ADDRESS IN REGISTER
             RF    RW
         ENDIF
         LM    R14,R0,SAVEGR14   RESTORE R14 AND R0
*        L     R15,=V(XXXXXXXX)  REPLACE THIS USING LINKAGE EDITOR
         LM    R2,R12,SAVEGR02   RESTORE NON-LINKAGE REGISTERS
         RF    RBASE
*        BR    R15
         BR    R14
         TITLE '- CONSTANTS'
         LTORG
PROTEXTR EXTRACT FIELDS=PSB,MF=L
PROTELEN EQU   *-PROTEXTR
         TITLE '- DSECTS'
         PRINT NOGEN
         IKJCPPL
LENCPPL  EQU   *-CPPL
         SPACE 1
         IHAPSA ,
         IKJTCB ,
         IKJPSCB ,
         IKJECT ,
         SPACE 2
WORKAREA DSECT
EXTRANS  DS    A
EXTRLIST DS    XL(PROTELEN)
         ORG   WORKAREA
WORKCPPL DS    0F
         ORG   WORKAREA+LENCPPL
CBUF     DS    0H
CBUFLLOO DS    0XL4
CBUFLL   DS    H                 RDW LENGTH
CBUFOO   DS    H                 OFFSETS
CBUFCHAR DS    0C                COMMAND ITSELF
         ORG
WORKLEN  EQU   *-WORKAREA
         SPACE 2
PARM     DSECT
PARMH    DS    H                 PARM FIELD LENGTH
PARMCHAR DS    0C                PARM FIELD PROPER
         SPACE 2
SAVEAREA DSECT ,                 STANDARD OS 18-FULLWORD SAVE AREA
SAVEWRD1 DS    F
SAVEHSA  DS    A
SAVELSA  DS    A
SAVEGR14 DS    A
SAVEGR15 DS    A
SAVEGR00 DS    F
SAVEGR01 DS    A
SAVEGR02 DS    F
SAVEGR03 DS    F
SAVEGR04 DS    F
SAVEGR05 DS    F
SAVEGR06 DS    F
SAVEGR07 DS    F
SAVEGR08 DS    F
SAVEGR09 DS    F
SAVEGR10 DS    F
SAVEGR11 DS    F
SAVEGR12 DS    F
         END   CPPLRET                                             RENT
