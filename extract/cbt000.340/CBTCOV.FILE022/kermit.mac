**** KERMIT-TSO VERSION 2.20
*****************************************************************
*  Changes made for Version 2.20  (April 1987)
*  1.  Addition of assembly option &LINMODE to allow selection
*      of NCP or NOTNCP option for tailoring ATOENCP and ETOANCP
*      translate tables for use with NCP and non-NCP systems.
*  2.  Addition of assembly option &WARN that allows the default
*      for the option WARNING to be set ON or OFF.
*  3.  Modifications to RECEIVE CSECT to provide support for
*      PDSs and quoted data set names when the file name is
*      sent from the other Kermit.
*  4.  Modifications to PDSCHK CSECT to correct problems when
*      doing multiple PDS member searches.
*  5.  Expand messages set to the other Kermit to 28 bytes from
*      original 20 bytes.  See label ERRTAB in CSECT PARMS.
*  6.  Renumber the source.
*****************************************************************
***  ART RICHARD's modified version of STEVE BLANKINSHIP's 2.10
**   All mods are commented with my initials...AJR
*****************************************************************
*  Changes made for Version 2.10C
*  1.  Support for V-BINARY file type.
*  2.  Inclusion of Steve Blankinship's changes through 4/1/87.
*      These changes commented with Steve's initials...SEB
*  3.  Change FINISH command to terminate Server mode, but not
*      exit Kermit (as per CMS, UNIX, etc.)
*  4.  Change max value of 32767 for BLKSIZE, etc. to 32760 as
*      per MVS.
*  5.  Add check to RECEIVE routine so that BLKSIZE is not larger
*      than tracksize of allocated device (ABEND002).
*  6.  Change default for file WARNING from off to ON.
*  7.  Shorten command keywords to their minimum unique prefix.
*****************************************************************
*  Changes made for Version 2.10B
*  1.  Support for RECFM=U
*****************************************************************
*  Changes made for Version 2.10A
*  1.  VTAM STTRAN translation replaced with ATOENCP and ETOANCP
*      translate tables.  Support for these tables also added.
*      (TDUMP, SET ATOENCP, SET ETOANCP)
*  2.  Fixed messages associated with BLKSIZE and LRECL.
*  3.  Added "?-style help" within SET command.
*  4.  Tried to make user interface resemble Kermit-CMS 3.10 as
*      much as practical.
*  5.  SHOW command now has default of ALL.
*****************************************************************
*        USER MACROS
         PRINT OFF
         MACRO
&NAME    CLRSCR &FILLCHR=NULL,&FSMODE=OFF
         AIF ('&FSMODE' EQ 'ON').FSON
&NAME    SR    R0,R0              TURN FSMODE OFF AT EXIT
         AGO   .GETFILL
.FSON    ANOP
&NAME    LA    R0,4               LEAVE FSMODE ON AT EXIT
.GETFILL ANOP
         AIF   ('&FILLCHR' EQ 'BLANK').FILLSP
         SR    R1,R1              SET FILL CHARACTER TO NULL
         AGO   .GOCLEAR
.FILLSP  ANOP
         LA    R1,4               SET FILL CHARACTER TO BLANK
.GOCLEAR ANOP
         L     R15,=A(CLRSCR)     GET CLEAR SCREEN ROUTINE ADDRESS
         BALR  R14,R15            GO CLEAR THE SCREEN
         MEND
         MACRO
&NAME    PUTCRSR &ROW=0,&COLUMN=0
         LCLC  &ROWVAL,&COLVAL
&ROWVAL  SETC  '0'
&COLVAL  SETC  '0'
         AIF   ('&COLUMN' EQ '0').RCINVAL
         AIF   ('&ROW' EQ '0').RCINVAL
         AGO   .ROWCOL
.RCINVAL MNOTE 8,'ROW AND COLUMN MUST BE SPECIFIED'
         MEXIT
.*
.ROWCOL  ANOP
         CNOP  0,4
         AIF   (K'&NAME EQ 0).NONAME
&NAME    DS    0F
.NONAME  ANOP
         AIF   ('&ROW'(1,1) EQ '(').REGROW
&ROWVAL  SETC  '&ROW'
         AGO   .SETCOL
.*
.REGROW  ANOP
         STH   &ROW,PC&SYSNDX.B   SAVE ROW VALUE
.*
.*
.SETCOL  ANOP
         AIF   ('&COLUMN'(1,1) EQ '(').REGCOL
&COLVAL  SETC  '&COLUMN'
         AGO   .GENREST
.*
.REGCOL  ANOP
         STH   &COLUMN,PC&SYSNDX.B+2  SAVE COLUMN VALUE
.GENREST ANOP
&NAME    BAL   1,PC&SYSNDX.A      PICK UP ADDRESS OF PARM LIST
PC&SYSNDX.B EQU *
         DC    AL2(&ROWVAL.)
         DC    AL2(&COLVAL.)
.*
PC&SYSNDX.A L     15,=A(PUTCRSR)     GET ADDRESS OF PUTCRSR ROUTINE
         BALR  14,15              GO DISPLAY MESSAGE
         MEND
         SPACE 3
         MACRO
&NAME    FULLSCR &MSG,&LEN,&ROW=0,&COLUMN=0
         LCLC  &ROWVAL,&COLVAL,&LENVAL
         LCLA  &MSGLEN
&MSGLEN  SETA  0
&ROWVAL  SETC  '0'
&COLVAL  SETC  '0'
&LENVAL  SETC  '0'
         AIF   ('&COLUMN' EQ '0').RCINVAL
         AIF   ('&ROW' EQ '0').RCINVAL
         AGO   .ROWCOL
.RCINVAL MNOTE 8,'ROW AND COLUMN MUST BE SPECIFIED'
         MEXIT
.*
.ROWCOL  ANOP
         CNOP  0,4
         AIF   ('&MSG'(1,1) NE '''').MSGADDR
&NAME    LA    15,FS&SYSNDX.C     GET ADDRESS OF MESSAGE
         ST    15,FS&SYSNDX.B     PUT INTO PARM LIST
         AGO   .SETROW
.MSGADDR ANOP
&NAME    LA    15,&MSG            GET ADDRESS OF MESSAGE
         ST    15,FS&SYSNDX.B     PUT INTO PARM LIST
.*
.SETROW  ANOP
         AIF   ('&ROW'(1,1) EQ '(').REGROW
&ROWVAL  SETC  '&ROW'
         AGO   .SETCOL
.*
.REGROW  ANOP
         STH   &ROW,FS&SYSNDX.B+8 SAVE ROW VALUE
.*
.*
.SETCOL  ANOP
         AIF   ('&COLUMN'(1,1) EQ '(').REGCOL
&COLVAL  SETC  '&COLUMN'
         AGO   .CHKLEN
.*
.REGCOL  ANOP
         STH   &COLUMN,FS&SYSNDX.B+10 SAVE COLUMN VALUE
.CHKLEN  ANOP
         AIF   (K'&LEN NE 0).DOLEN
         AIF   ('&MSG'(1,1) NE '''').NEEDLEN
&MSGLEN  SETA  K'&MSG-2
&LENVAL  SETC  '&MSGLEN'
         AGO   .GENREST
.NEEDLEN ANOP
         MNOTE *,'MESSAGE LENGTH IS REQUIRED'
         MEXIT
.*
.DOLEN   ANOP
         AIF   ('&LEN'(1,1) EQ '(').LENCOL
&LENVAL  SETC  '&LEN'
         AGO   .GENREST
.*
.LENCOL  ANOP
         ST    &LEN,FS&SYSNDX.B+4 SAVE LENGTH VALUE
.GENREST ANOP
&NAME    BAL   1,FS&SYSNDX.A      PICK UP ADDRESS OF PARM LIST
FS&SYSNDX.B DS 0A
         DC    A(0)
         DC    A(&LENVAL.)
         DC    AL2(&ROWVAL.)
         DC    AL2(&COLVAL.)
         AIF   ('&MSG'(1,1) NE '''').GENBR
FS&SYSNDX.C DC C&MSG
.GENBR   ANOP
PT&SYSNDX.B DS 0H
.*
FS&SYSNDX.A L     15,=A(FULLSCR)     GET ADDRESS OF FULLSCR ROUTINE
         BALR  14,15              GO DISPLAY MESSAGE
         MEND
         SPACE 3
         MACRO
&NAME    BLOCKLET &LETTERS,&LEN
         AIF   ('&LETTERS'(1,1) EQ '''').LITMSG
         AIF   ('&LETTERS'(1,1) EQ '(').REGMSG
.*  ADDRESS OF LETTERS IS SUPPLIED
         AIF   (K'&LEN NE 0).ADRCNT
         MNOTE 8,'STRING LENGTH REQUIRED'
         MEXIT
.*
.ADRCNT  AIF   ('&LEN'(1,1) EQ '(').REGLEN
&NAME    LA    0,&LEN             GET LENGTH OF STRING
         AGO   .STRADR1
.*
.REGLEN  ANOP
&NAME    LR    0,&LEN             GET LENGTH OF STRING
.STRADR1 ANOP
         LA    1,&LETTERS         GET ADDRESS OF STRING
         AGO   .GOBLOCK
.*
.*
.LITMSG  ANOP
         AIF   (K'&LEN NE 0).LITCNT
         LA    0,L'PT&SYSNDX.A    GET LENGTH OF STRING
         AGO   .GENMSG
.*
.LITCNT  AIF   ('&LEN'(1,1) EQ '(').LITREGL
&NAME    LA    0,&LEN             GET LENGTH OF STRING
         AGO   .GENMSG
.*
.LITREGL ANOP
&NAME    LR    0,&LEN             GET LENGTH OF STRING
.GENMSG  ANOP
         LA    1,PT&SYSNDX.A      GET ADDRESS OF STRING
         B     PT&SYSNDX.B
PT&SYSNDX.A DC C&LETTERS
PT&SYSNDX.B DS 0H
         AGO   .GOBLOCK
.*
.*
.REGMSG  ANOP
         AIF   (K'&LEN NE 0).REGCNT
         MNOTE 8,'STRING LENGTH REQUIRED'
         MEXIT
.*
.REGCNT  AIF   ('&LEN'(1,1) EQ '(').REGREGL
&NAME    LA    0,&LEN             GET LENGTH OF STRING
         AGO   .STRADR2
.*
.REGREGL ANOP
&NAME    LR    0,&LEN             GET LENGTH OF STRING
.STRADR2 ANOP
         LA    1,&LETTERS         GET ADDRESS OF STRING
         AGO   .GOBLOCK
.*
.*
.GOBLOCK ANOP
         L     15,=A(BLOCKLET)    GET ADDRESS OF BLOCKLET ROUTINE
         BALR  14,15              GO DISPLAY BLOCK LETTERS
         MEND
         SPACE 3
*  MACRO OBTAINED FROM COLUMBIA UNIVERSITY KERMIT 3.0 WRITTEN BY
*  VACE KUNDAKCI.  MODIFIED BY STEVE BLANKINSHIP, TUCC
         MACRO
&LABEL   RET   &RANGE,&SKIP=
         GBLC  &RTN,&TYP,&EXT
         LCLC  &REG1,&REG2
         LCLA  &OFFSET
         AIF   ('&TYP' EQ 'SHORT').SHORT
&LABEL   L     13,4(,13)
         L     14,12(,13)
         AIF   ('&RANGE' NE '').STNRNG
&REG1    SETC  '0'
&REG2    SETC  '12'
&OFFSET  SETA  &REG1*4+20
         AGO   .GENLM
.STNRNG  ANOP
         AIF   (N'&RANGE LT 2).ONEREG
&REG1    SETC  '&RANGE(1)'
&REG2    SETC  '&RANGE(2)'
&OFFSET  SETA  &REG1*4+20
         AGO   .GENLM
.ONEREG  ANOP
&REG1    SETC  '&RANGE'
&REG2    SETC  '12'
&OFFSET  SETA  &REG1*4+20
.GENLM   ANOP
         LM    &REG1,&REG2,&OFFSET.(13)
         AGO   .SKIP
.SHORT   ANOP
&LABEL   LM    0,14,&RTN.SV
.SKIP    AIF   ('&SKIP' EQ '').BR14
         LTR   15,15
         B&SKIP 4(14)
         ICM   14,B'1111',0(14)
.BR14    BR    14
         MEND
         SPACE 3
*  MACRO OBTAINED FROM COLUMBIA UNIVERSITY KERMIT 3.0 WRITTEN BY
*  VACE KUNDAKCI.  MODIFIED BY STEVE BLANKINSHIP, TUCC
         MACRO
&LABEL   ENTER &TYPE,&EXTRA=,&MACGEN=
         GBLC  &RTN,&TYP,&EXT
         GBLC  &PRINT
         AIF   ('&MACGEN' EQ '').NOPRINT
&PRINT   SETC  '&MACGEN'
.NOPRINT ANOP
&RTN     SETC  '&LABEL'
         AIF   (K'&LABEL LE 6).LB1
&RTN     SETC  '&LABEL'(1,6)
.LB1     ANOP
&TYP     SETC  '&TYPE'
&EXT     SETC  '&EXTRA'
&LABEL   CSECT
         PUSH  PRINT
         PRINT &PRINT
         AIF   ('&TYPE' EQ 'SHORT').SHORT
         STM   14,12,12(13)
         BALR  12,0
         USING *,12
         AIF   ('&EXTRA' EQ '').NOEXT
         LA    &EXTRA,&LABEL+4096
         USING &LABEL+4096,&EXTRA
.NOEXT   LA    14,&RTN.SV
         ST    13,4(,14)
         ST    14,8(,13)
         LR    13,14
         MEXIT
.SHORT   USING &LABEL,15
         STM   0,14,&LABEL.SV
         LR    12,15
         DROP  15
         USING &LABEL,12
         MEND
         SPACE 3
*  MACRO OBTAINED FROM COLUMBIA UNIVERSITY KERMIT 3.0 WRITTEN BY
*  VACE KUNDAKCI.  MODIFIED BY STEVE BLANKINSHIP, TUCC
         MACRO
         EXIT
         GBLC  &RTN,&TYP,&EXT
&RTN.SV  DS    18F
         DROP  12
         AIF   ('&EXT' EQ '').NOEXT
         DROP  &EXT
.NOEXT   LTORG
         POP   PRINT
         MEND
         SPACE 3
         MACRO
&LABEL   UNALLOC &TYPE,&ADDR=,&NAME=
         AIF   ('&TYPE' NE 'DSNAME').CKDDN
&LABEL   SR    0,0                UNALLOCATE BY DSNAME
         AGO   .CKADDR
.CKDDN   AIF   ('&TYPE' NE 'DDNAME').BADTYPE
&LABEL   LA    0,4                UNALLOCATE BY DDNAME
         AGO   .CKADDR
.BADTYPE MNOTE 8,'INVALID "TYPE"'
         MEXIT
.*
.CKADDR  AIF   ('&ADDR' EQ '').CKNAME
         AIF   ('&NAME' NE '').CONFLCT
         AIF   ('&ADDR'(1,1) NE '(').ADDRADR
         LR    1,&ADDR            UNALLOC NAME AT THIS ADDRESS
         AGO   .GENLINK
.ADDRADR L     1,&ADDR            UNALLOC NAME AT THIS ADDRESS
         AGO   .GENLINK
.*
.CKNAME  AIF   ('&NAME' NE '').GONAME
         MNOTE 8,'NEITHER "ADDR" NOR "NAME" WAS SPECIFIED'
         MEXIT
.GONAME  AIF   ('&NAME'(1,1) NE '(').NAMENAM
         LR    1,&NAME             UNALLOC NAME
         AGO   .GENLINK
.NAMENAM LA    1,&NAME             UNALLOC NAME
         AGO   .GENLINK
.*
.CONFLCT MNOTE 8,'"ADDR" AND "NAME" ARE MUTUALLY EXCLUSIVE'
         MEXIT
.*
.GENLINK ANOP
         L     15,=A(DEALLOC)     GET ADDRESS OF DEALLOC ROUTINE
         BALR  14,15              GO DEALLOCATE
         MEND
         SPACE 3
         MACRO
&NAME    SETSEMI
&NAME    L     15,=A(SETSEMI)     GET ADDRESS OF SEMI-COLON ROUTINE
         BALR  14,15              GO INSERT SEMICOLON
         MEND
         SPACE 3
         MACRO
&NAME    PARSE &PCL,&ATTN=,&ERR=
&NAME    LA    1,PPLAREA          GET ADDRESS OF PPL
         L     0,=V(&PCL.)        GET ADDRESS OF PCL
         ST    0,12(,1)           PUT INTO THE PPL
         L     15,=A(PARSE)       GET ADDRESS OF PARSE SUBROUTINE
         BALR  14,15              GO PARSE
         B     *+4(15)            BRANCH ON RETURN CODE
         B     *+12               0  -  PARSE WAS SUCCESSFUL
         B     &ATTN              4  -  ATTENTION DURING PARSE
         B     &ERR               8  -  ERROR DURING PARSE
         MEND
         SPACE 3
         MACRO
&NAME    CHECKPDL &GOOD=,&BAD=
         LCLC  &BR,&GOTO
&BR      SETC  'BNE'              ASSUME GOOD IS SPECIFIED
&GOTO    SETC  '&GOOD'            ASSUME GOOD BRANCH
         AIF   ('&GOOD' NE '').GEN
&BR      SETC  'BE'               ASSUME BAD IS SPECIFIED
&GOTO    SETC  '&BAD'             ASSUME BAD BRANCH
         AIF   ('&BAD' NE '').GEN
         MNOTE 8,'"GOOD" OR "BAD" MUST BE SPECIFIED'
         MEXIT
.GEN     ANOP
&NAME    L    9,PDLADDR           GET PDL ADDRESS
         CL   9,=X'FF000000'      GOOD PDL?
         &BR  &GOTO
         MEND
         SPACE 3
         MACRO
&NAME    NUMTABS
         GBLA  &NUMTABS
         LCLA  &COUNT,&INDEX,&TOTAL
         LCLC  &TBSTRNG
&TOTAL   SETA  0
&INDEX   SETA  9
&NAME    DS    0X
.*
.*  LOOP HERE TO START AN NEW GENERATED "DC"
.*
.AGAIN   ANOP
&COUNT   SETA  0
&TBSTRNG SETC  'AL1'
.*
.*  LOOP HERE TO CONTINUE TO BUILD CURRENT "DC"
.*
.TBLOOP  ANOP
&TBSTRNG SETC  '&TBSTRNG'.'(&INDEX)'
&COUNT   SETA  &COUNT+1
&TOTAL   SETA  &TOTAL+1
         AIF   (&TOTAL GE &NUMTABS).LASTTB
         AIF   (&COUNT GE 6).PRTTAB
&INDEX   SETA  &INDEX+8
&TBSTRNG SETC  '&TBSTRNG'.',AL1'
         AGO   .TBLOOP
.*
.*  WHEN THE COUNT REACHES 6 GENERATE THE "DC", BUMP THE INDEX AND
.*  START WITH A NEW "DC"
.*
.PRTTAB  ANOP
         DC    &TBSTRNG
&INDEX   SETA  &INDEX+8
         AGO   .AGAIN
.*
.*  ALL THROUGH
.*
.LASTTB  ANOP
         DC    &TBSTRNG
         MEND
         SPACE 3
         MACRO
&NAME    WRTERM &MSG,&LEN,&DATA=NO
         LCLA  &MLEN
         AIF   ('&MSG'(1,1) EQ '''').LITMSG
         AIF   ('&MSG'(1,1) EQ '(').REGMSG
.*--------------------------------------------------------------------
.*
.*     MESSAGE ADDRESS SUPPLIED IN &MSG
.*
&NAME    LA    1,&MSG             GET ADDRESS OF MESSAGE
         AIF   (K'&LEN NE 0).ADRCNT
         MNOTE 8,'MESSAGE LENGTH REQUIRED'
         MEXIT
.*
.ADRCNT  ANOP
         AIF   ('&LEN'(1,1) EQ '(').REGLEN
.*
.*     ASSUME THAT LENGTH SUPPLIED IS A NUMBER
.*
         LA    0,&LEN             GET LENGTH OF MESSAGE
         AGO   .DOPUTL
.*
.*     LENGTH WAS SUPPLIED IN A REGISTER
.*
.REGLEN  ANOP
         LR    0,&LEN             GET LENGTH OF MESSAGE
         AGO   .DOPUTL
.*---------------------------------------------------------------------
.LITMSG  ANOP
&NAME    LA    1,PT&SYSNDX.A      GET ADDRESS OF MESSAGE
         AIF   (K'&LEN NE 0).LITCNT
         LA    0,L'PT&SYSNDX.A    GET LENGTH OF MESSAGE
         AGO   .GENMSG
.*
.*     LENGTH WAS SUPPLIED WITH A LITERAL MESSAGE
.*
.LITCNT  ANOP
         AIF   ('&LEN'(1,1) EQ '(').LITREGL
.*
.*     ASSUME LENGTH IS A NUMBER
.*
         LA    0,&LEN             GET LENGTH OF MESSAGE
         AGO   .GENMSG
.*
.*     LENGTH SUPPLIED IS IN A REGISTER
.*
.LITREGL ANOP
         LR    0,&LEN             GET LENGTH OF MESSAGE
.GENMSG  ANOP
         B     PT&SYSNDX.B
PT&SYSNDX.A DC C&MSG
PT&SYSNDX.B DS 0H
         AGO   .DOPUTL
.*---------------------------------------------------------------------
.REGMSG  ANOP
&NAME    LR    1,&MSG             GET MESSAGE ADDRESS
         AIF   (K'&LEN NE 0).REGCNT
         MNOTE *,'MESSAGE LENGTH MUST BE SUPPLIED'
         MEXIT
.REGCNT  AIF   ('&LEN'(1,1) EQ '(').REGREGL
.*
.*     ASSUME THE LENGTH IS A NUMBER
.*
         LA    0,&LEN             GET MESSAGE LENGTH
         AGO   .DOPUTL
.*
.*     LENGTH WAS SUPPLIED IN A REGISTER
.*
.REGREGL ANOP
         LR    0,&LEN             GET MESSAGE LENGTH
         AGO   .DOPUTL
.*---------------------------------------------------------------------
.DOPUTL  ANOP
         AIF   ('&DATA' NE 'YES').GENPUTL
         ICM   R0,8,=X'80'        INDICATE "DATA" PUTLINE
.GENPUTL ANOP
         L     15,=A(PUTLINE)     GET ADDRESS OF PUTLINE ROUTINE
         BALR  14,15              GO SEND MESSAGE TO TERMINAL
         MEND
         SPACE 3
         MACRO
&NAME    RDTERM &BUF,&LEN
         LCLA  &MLEN
         AIF   ('&BUF'(1,1) EQ '(').REGMSG
.*--------------------------------------------------------------------
.*
.*     MESSAGE ADDRESS SUPPLIED IN &BUF
.*
&NAME    LA    1,&BUF             GET ADDRESS OF BUFFER
         AIF   (K'&LEN NE 0).ADRCNT
         LA    0,L'&BUF           GET LENGTH OF BUFFER
         AGO   .DOGETL
.*
.ADRCNT  ANOP
         AIF   ('&LEN'(1,1) EQ '(').REGLEN
.*
.*     ASSUME THAT LENGTH SUPPLIED IS A NUMBER
.*
         LA    0,&LEN             GET LENGTH OF BUFFER
         AGO   .DOGETL
.*
.*     LENGTH WAS SUPPLIED IN A REGISTER
.*
.REGLEN  ANOP
         LR    0,&LEN             GET LENGTH OF BUFFER
         AGO   .DOGETL
.*---------------------------------------------------------------------
.REGMSG  ANOP
&NAME    LR    1,&BUF             GET BUFFER ADDRESS
         AIF   (K'&LEN NE 0).REGCNT
         MNOTE *,'BUFFER LENGTH MUST BE SUPPLIED'
         MEXIT
.REGCNT  AIF   ('&LEN'(1,1) EQ '(').REGREGL
.*
.*     ASSUME THE LENGTH IS A NUMBER
.*
         LA    0,&LEN             GET BUFFER LENGTH
         AGO   .DOGETL
.*
.*     LENGTH WAS SUPPLIED IN A REGISTER
.*
.REGREGL ANOP
         LR    0,&LEN             GET BUFFER LENGTH
         AGO   .DOGETL
.*---------------------------------------------------------------------
.DOGETL  ANOP
         L     15,=A(GETLINE)     GET ADDRESS OF GETLINE ROUTINE
         BALR  14,15              GO READ FROM TERMINAL
         MEND
         SPACE 3
         MACRO
&NAME    PROMPT &MSG,&LEN
         LCLA  &MLEN
         AIF   ('&MSG'(1,1) EQ '''').LITMSG
         AIF   ('&MSG'(1,1) EQ '(').REGMSG
.*--------------------------------------------------------------------
.*
.*     MESSAGE ADDRESS SUPPLIED IN &MSG
.*
&NAME    LA    1,&MSG             GET ADDRESS OF MESSAGE
         AIF   (K'&LEN NE 0).ADRCNT
         MNOTE 8,'MESSAGE LENGTH REQUIRED'
         MEXIT
.*
.ADRCNT  ANOP
         AIF   ('&LEN'(1,1) EQ '(').REGLEN
.*
.*     ASSUME THAT LENGTH SUPPLIED IS A NUMBER
.*
         LA    0,&LEN             GET LENGTH OF MESSAGE
         AGO   .DOPUTL
.*
.*     LENGTH WAS SUPPLIED IN A REGISTER
.*
.REGLEN  ANOP
         LR    0,&LEN             GET LENGTH OF MESSAGE
         AGO   .DOPUTL
.*---------------------------------------------------------------------
.LITMSG  ANOP
&NAME    LA    1,PT&SYSNDX.A      GET ADDRESS OF MESSAGE
         AIF   (K'&LEN NE 0).LITCNT
         LA    0,L'PT&SYSNDX.A    GET LENGTH OF MESSAGE
         AGO   .GENMSG
.*
.*     LENGTH WAS SUPPLIED WITH A LITERAL MESSAGE
.*
.LITCNT  ANOP
         AIF   ('&LEN'(1,1) EQ '(').LITREGL
.*
.*     ASSUME LENGTH IS A NUMBER
.*
         LA    0,&LEN             GET LENGTH OF MESSAGE
         AGO   .GENMSG
.*
.*     LENGTH SUPPLIED IS IN A REGISTER
.*
.LITREGL ANOP
         LR    0,&LEN             GET LENGTH OF MESSAGE
.GENMSG  ANOP
         B     PT&SYSNDX.B
PT&SYSNDX.A DC C&MSG
PT&SYSNDX.B DS 0H
         AGO   .DOPUTL
.*---------------------------------------------------------------------
.REGMSG  ANOP
&NAME    LR    1,&MSG             GET MESSAGE ADDRESS
         AIF   (K'&LEN NE 0).REGCNT
         MNOTE *,'MESSAGE LENGTH MUST BE SUPPLIED'
         MEXIT
.REGCNT  AIF   ('&LEN'(1,1) EQ '(').REGREGL
.*
.*     ASSUME THE LENGTH IS A NUMBER
.*
         LA    0,&LEN             GET MESSAGE LENGTH
         AGO   .DOPUTL
.*
.*     LENGTH WAS SUPPLIED IN A REGISTER
.*
.REGREGL ANOP
         LR    0,&LEN             GET MESSAGE LENGTH
         AGO   .DOPUTL
.*---------------------------------------------------------------------
.DOPUTL  ANOP
         L     15,=A(PUTGET)      GET ADDRESS OF PUTGET ROUTINE
         BALR  14,15              GO PROMPT FOR INPUT
         MEND
         SPACE 3
         MACRO
&NAME    LINEDIT &TEXT=,&SUB=,&DOT=YES
         LCLA  &TXTL,&OPER,&SUBL,&FLAGS
         LCLB  &REGVAL
         LCLC  &TXT,&FUNCT,&SUBLT,&SUBVAL,&TEMP(2)
         AIF   (K'&TEXT NE 0).CHKTXT
         MNOTE 8,'TEXT= OPERAND MISSING, IT IS REQUIRED'
         MEXIT
.*
.CHKTXT  AIF   ('&TEXT'(1,1) EQ '''').GETTXT
         MNOTE 8,'TEXT= OPERAND MUST BE ENCLOSED IN QUOTES'
         MEXIT
.*
.*       GET LENGTH OF TEXT AND ISOLATE TEXT FROM QUOTES
.*
.GETTXT  ANOP
&TXTL    SETA  K'&TEXT-2
&TXT     SETC  '&TEXT'(2,&TXTL)
.*
.*       CHECK FOR THE SUB= OPERAND
.*
         AIF   (K'&SUB NE 0).DOSUB
         MNOTE 8,'SUB= OPERAND IS MISSING, IT IS REQUIRED'
         MEXIT
.*
.DOSUB   ANOP
&FUNCT   SETC  '&SUB(1)'
         AIF   ('&FUNCT' EQ '').NULFUN
         AIF   ('&FUNCT' EQ 'CHARA').CHARA
         AIF   ('&FUNCT' EQ 'DECA').DECA
         AIF   ('&FUNCT' EQ 'DEC').DEC
         AIF   ('&FUNCT' EQ 'HEX4A').HEX4A
         AIF   ('&FUNCT' EQ 'HEXA').HEXA
         AIF   ('&FUNCT' EQ 'HEX').HEX
         MNOTE 8,'INVALID SUBSTITUTION FUNCTION &SUB(1)'
         MEXIT
.*
.NULFUN  MNOTE 8,'SUBSTITUTION FUNCTION OMITTED'
         MEXIT
.*
.HEX     ANOP
&OPER    SETA  0
         AGO   .FLAGS
.*
.HEXA    ANOP
&OPER    SETA  1
         AGO   .FLAGS
.*
.HEX4A   ANOP
&OPER    SETA  2
         AGO   .FLAGS
.*
.DEC     ANOP
&OPER    SETA  3
         AGO   .FLAGS
.*
.DECA    ANOP
&OPER    SETA  4
         AGO   .FLAGS
.*
.CHARA   ANOP
&OPER    SETA  5
         AGO   .FLAGS
.*
.*       SET UP FLAGS
.*
.FLAGS   ANOP
         AIF   ('&DOT' NE 'YES').SUBVAL
&FLAGS   SETA   128               TURN ON DOT FLAG (X'80')
.*
.*       GET SUBSTITUTION VALUE AND IMPLIED LENGTH
.*
.SUBVAL  ANOP
&SUBVAL  SETC   '&SUB(2)'
         AIF    ('&SUBVAL' NE '').GOODVAL
         MNOTE  8,'SUBSTITUTION VALUE MISSING. IT IS REQUIRED'
         MEXIT
.GOODVAL ANOP
         AIF    ('&SUBVAL'(1,1) NE '(').ADRVAL
&REGVAL  SETB   1                 INDICATE REGISTER VALUE
         AGO    .SUBLEN
.*
.*
.ADRVAL  ANOP
&REGVAL  SETB   0                 TURN OFF REGISTER SWITCH
.*
.*       GET LENGTH OF SUBSTITUTION VALUE IF SPECIFIED. IF ALLOWED
.*       THIS WILL OVERRIDE THE IMPLIED LENGTH
.*
.SUBLEN  ANOP
&SUBLT   SETC   '&SUB(3)'         GET LENGTH OF SUBSTITUTION VALUE
         AIF    ('&SUBLT' EQ '').PARMLST
         AIF    (&OPER EQ 2).SETLEN        ALLOW HEX4A TO SET LENGTH
         AIF    (&OPER EQ 5).SETLEN        ALLOW CHARA TO SET LENGTH
         MNOTE  8,'LENGTH SPECIFICATION NOT ALLOWED FOR &SUB(1)'
         MEXIT
.*
.SETLEN  ANOP
&SUBL    SETA   &SUBLT
         AGO    .PARMLST
.*
.*       SET UP PARAMETER LIST TO BE PASSED TO LINEDIT ROUTINE
.*
.PARMLST ANOP
&NAME    BAL   1,LNE&SYSNDX
         DC    AL1(&OPER)
         DC    AL1(&FLAGS)
         DC    AL2(&SUBL)
         DC    AL2(&TXTL)
         DC    C'&TXT'
LNE&SYSNDX  DS  0H
         AIF   (&REGVAL EQ 1).GENLR
         LA    0,&SUBVAL
         AGO   .EXIT
.*
.GENLR   LR    0,&SUBVAL
.EXIT    ANOP
         L     15,=A(LINEDIT)
         BALR  14,15
         MEND
         PRINT ON
         EJECT
******************************************************************* TSO
******************************************************************* TSO
******************************************************************* TSO
******************************************************************* TSO
******************************************************************* TSO
******************************************************************* TSO
******************************************************************* TSO
******************************************************************* TSO
*  THESE VALUES ARE USED TO SET A NUMBER OF ASSEMBLY PARAMETERS.    TSO
         SPACE 3                                                    TSO
         GBLA  &NUMTABS,&SIZ7171,&SIZLINE,&LOGBLK,&LOGRECL          TSO
         GBLC  &PRINT,&PREFIX,&LINMODE,&WARN                        AJR
&SIZ7171 SETA  1920               MAX PACKET SIZE FOR IBM7171       TSO
&SIZLINE SETA  1024               MAX PACKET SIZE FOR LINE TERMINAL TSO
&NUMTABS SETA  31                 MAXIMUM NUMBER OF TAB SETTINGS    TSO
&LOGBLK  SETA  19069              LOG DATA SET BLKSIZE              TSO
&LOGRECL SETA  9024               LOG DATA SET LRECL                TSO
&PRINT   SETC  'GEN'              MACRO EXPANSION PRINT OPTION      TSO
&PREFIX  SETC  'DISTRIB'          DATA SET PREFIXING METHOD         TSO
&LINMODE SETC  'NCP'              TERMINAL LINE MODE (NCP OR NOTNCP)TSO
&WARN    SETC  'ON'               IF "OFF" OVERWRITE INCOMING FILE  TSO
*                                 IF "ON" RENAME INCOMING FILE      TSO
         SPACE 1                                                    TSO
******************************************************************* TSO
******************************************************************* TSO
******************************************************************* TSO
******************************************************************* TSO
******************************************************************* TSO
******************************************************************* TSO
******************************************************************* TSO
******************************************************************* TSO
         EJECT                                                      TSO
KERMIT   TITLE 'KERMIT-TSO'                                         TSO
KERMIT   CSECT
* KERMIT   -
*
*  KERMIT TSO VERSION 2.20                                          TSO
*  April, 1987                                                      AJR
*
*  This program is the IBM MVS/TSO side of a file transfer system.  TSO
*  It can be used to transfer files between a micro and a system
*  running under MVS/TSO.                                           TSO
*  See the KERMIT User's Guide and Protocol manual for the complete
*  program specifications to which this program and any other
*  component of the system must adhere.
*
*  This program is based on the VM/CMS KERMIT Version 2.01          TSO
*  written by Daphne Tzoar, Columbia University Center for          TSO
*  Computing Activities in March 1982.                              TSO
*                                                                   TSO
*  Steve Blankinship, Triangle Universities Computation Center      TSO
*  January 1986                                                     TSO
*                                                                   TSO
*  NCP translate tables, support for RECFM=U, and V-Binary file     AJR
*  type support provided by Art Richard, Amdahl Corporation.        AJR
*
*  Please address all comments and questions to:
*                                                                   TSO
*  Steve Blankinship                                                TSO
*  Triangle Universities Computation Center                         TSO
*  P.O. Box 12076                                                   TSO
*  Research Triangle Park                                           TSO
*  North Carolina  27709                                            TSO
*  BITNET address  TUCSEB@TUCC                                      TSO
*
* Copyright (C) 1982,1983 Columbia University
* Additional material Copyright (C) 1986 Triangle Universities      TSO
*   Computation Center                                              TSO
*
* Permission is granted to any individual or institution to copy
* or use this program, except for explicitly commercial purposes.
*
* Note: If you find and correct problems in the program, please
* forward all changes to the author.
*
         EJECT
* REGISTER USAGE -
* R1 -
* R2 -
* R3 -
* R4 -
* R5 -
* R6 -
* R7 -
* R8 -
* R9 -
* R10 -
* R11 - BASE REGISTER FOR GLOBAL DATA AREA
* R12 - PROGRAM BASE
* R13 - SAVE AREA
* R14 - SUBROUTINE LINKAGE
* R15 - SUBROUTINE LINKAGE
*
* EXTERNAL MACROS/MODULES CALLED -
*  The following MACLIBs should be GLOBAL'd:
*       DMSSP, CMSLIB, TSOMAC
*
*  The following external routines are called:
*       WILD ASSEMBLE
*
*
         SPACE
ALCCB    DSECT                    PARM LIST FOR ALLOCDSN ROUTINE    TSO
ALCTYPE  DS    F                  TYPE OF ALLOCATION                TSO
ALCTOLD  EQU   X'80'              ALLOCATE OLD DATA SET             TSO
ALCTNEW  EQU   X'40'              ALLOCATE NEW DATA SET             TSO
ALCNCONC EQU   X'20'              DON'T ADD TO CONCATENATION TABLE  TSO
ALCCMPAT EQU   X'10'              DON'T CHECK FOR INCOMPATIBLE DATA TSO
*                                   SET TYPES.                      TSO
ALCDSN   DS    F                  POINTER TO LENGTH & DATA SET NAME TSO
ALCMEMBR DS    F                  POINTER TO LENGTH & MEMBER NAME   TSO
         SPACE 3                                                    TSO
LINPARMS DSECT                                                      TSO
LINFUNC  DS    AL1                FUNCTION CODE                     TSO
LINFLAGS DS    AL1                FLAGS                             TSO
LINDOT   EQU   X'80'              ON IF "DOT=YES"                   TSO
LINSUBL  DS    AL2                LENGTH OF SUBSTITUTION VALUE      TSO
LINTEXTL DS    AL2                LENGTH OF TEXT STRING             TSO
LINTEXT  DS    C                  START OF TEXT STRING              TSO
         SPACE 3                                                    TSO
         IKJCPPL                                                    TSO
         SPACE 3                                                    TSO
         IKJECT                                                     TSO
         SPACE 3                                                    TSO
         IKJUPT                                                     TSO
         SPACE 3                                                    TSO
         IKJIOPL                                                    TSO
         SPACE 3                                                    TSO
         IKJPTPB                                                    TSO
         SPACE 3                                                    TSO
         IKJPGPB                                                    TSO
         SPACE 3                                                    TSO
         IKJDFPL                                                    TSO
         SPACE 3                                                    TSO
         IKJDFPB                                                    TSO
         SPACE 3                                                    TSO
         IKJCSPL                                                    TSO
         SPACE 3                                                    TSO
         IKJCSOA                                                    TSO
         SPACE 3                                                    TSO
         IKJPPL                                                     TSO
         SPACE 3                                                    TSO
         PRINT     NOGEN                                            TSO
         DCBD  DSORG=(PS,PO),DEVD=(DA,TA)                           TSO
         SPACE
R0       EQU   0                                                    TSO
R1       EQU   1                                                    TSO
R2       EQU   2                                                    TSO
R3       EQU   3                                                    TSO
R4       EQU   4                                                    TSO
R5       EQU   5                                                    TSO
R6       EQU   6                                                    TSO
R7       EQU   7                                                    TSO
R8       EQU   8                                                    TSO
R9       EQU   9                                                    TSO
R10      EQU   10                                                   TSO
R11      EQU   11                                                   TSO
R12      EQU   12                                                   TSO
R13      EQU   13                                                   TSO
R14      EQU   14                                                   TSO
R15      EQU   15                                                   TSO
         SPACE 1                                                    TSO
SOH      EQU       X'01'               ^a FOR START OF HEADER CHAR
XON      EQU       X'11'               XON [13]
AD       EQU       68                  DATA PACKET (ASCII 'D')
AN       EQU       78                  NAK
AZ       EQU       90                  EOF packet, skip file group [16]
AS       EQU       83                  INIT PACKET
AY       EQU       89                  ACK
AF       EQU       70                  FILE PACKET
AB       EQU       66                  BREAK PACKET
AE       EQU       69                  ERROR PACKET
AR       EQU       82                  Get packet "R" [13]
AG       EQU       71                  Generic server packet "G" [13]
AL       EQU       76                  Logout packet "L" [13]
AI       EQU       73                  Parameter init packet "I" [13]
AX       EQU       88                  Skip file when sending [16]
ACR      EQU       13                  Ascii CR  [25]
ALF      EQU       10                  Ascii LF  [25]
ABL      EQU   32                 ASCII SPACE                       TSO
ERCOD    EQU       12                  MEANS EOF WITH 'FSREAD'
MAXTXT   EQU       64536               Max output buffer is 64K [6]
MAXBIN   EQU       80                  Max output for binary files [1]
SENDDLAY EQU   2000               20 SECONDS (HUNDREDTHS SECOND)    TSO
* Fields of variable FLAGS:
FLG1     EQU       X'80'               IS FILE THE FIRST OR NOT
FLG2     EQU       X'40'               OVERWRITE SENT FILENAME?
FLG3     EQU       X'20'               ONE = SENT ONLY PARTIAL RECORD
FLG4     EQU       X'10'               NAK FROM MICRO(0) OR RPACK(1)?
FLG5     EQU       X'08'               ALLOCATED MORE SPACE (DMSFREE)
BINF     EQU       X'04'               ONE := BINARY DATA  [1]
FLG7     EQU       X'02'               One := End-of-file  [4]
DEBUG    EQU       X'01'               Debug mode ON/OFF [10]
* Fields of variable LFLAGS:
RECVON   EQU   X'40'              IN RECEIVE MODE                   TSO
SENDON   EQU   X'20'              IN SEND MODE                      TSO
SERVON   EQU       X'10'               In SERVER mode [13]
TAKON    EQU       X'08'               TAKE command [15]
ALLFL    EQU       X'04'               SHOW ALL requested [17]
WARFL    EQU       X'02'               Rename incoming file [18]
CMDL     EQU       X'01'               Data on cmd line [11]
* Fields of variable SRFLAGS                                        TSO
SRINTO   EQU   X'80'              FILE NAME SPECIFIED ON SND/RCV    TSO
SRNWNAME EQU   X'40'              NEW NAME HAS BEEN ASSIGNED        TSO
SRBIGSCR EQU   X'20'              TERMINAL IS A BIG SCREEN 3270     TSO
SRBLOCK  EQU   X'10'              BLOCK LETTERS TO BE DISPLAYED     TSO
SRCLRSCR EQU   X'08'              CLEAR THE SCREEN                  TSO
*
DSSIZ    EQU       X'50'               Default send packet size [4]
DQUOTE   EQU       X'23'               Default quote character = # [4]
D8QUO    EQU       X'26'               Default 8-bit quochar=&  [1][4]
DCHKLEN  EQU       X'01'               Default checksum length [4]
DRPT     EQU       X'7E'               Default repeat prefix  TILDE [4]
DEOL     EQU       X'0D'               Default end of packet (CR) [4]
DLRECL   EQU   80                 DEFAULT LRECL IS 80               TSO
DBLKSZ   EQU   3600               DEFAULT BLKSIZE IS 3600           TSO
DRECFM   EQU   C'F'               DEFAULT RECFM IS F                TSO
DPRIME   EQU   5                  DEFAULT PRIMARY ALLOCATION        TSO
DSECOND  EQU   5                  DEFAULT SECONDARY ALLOCATION      TSO
DDIR     EQU   10                 DEFAULT DIRECTORY BLOCKS FOR PDS  TSO
DSTIM    EQU       X'08'               Default send time out [4]
DRTIM    EQU       X'0D'               Default receive time out [4]
DSPAD    EQU       X'00'               Default send padding. [4]
DRPAD    EQU       X'00'               Default receive padding. [4]
DSPADC   EQU       X'00'               Default send padding char. [4]
DRPADC   EQU       X'00'               Default rec padding char. [4]
SPMIN    EQU  20                  KERMIT PROTOCOL MIN PACKET SIZE   TSO
SPMAX    EQU  94                  KERMIT PROTOCOL MAX PACKET SIZE   TSO
SPMAXF   EQU  SPMAX+1             KERMIT EXTENDED PACKET BASE       TSO
SPMAXE   EQU  SPMAXF*SPMAX+SPMAX = 9024 KERMIT EXTENDED MAX PACKET  TSO
SPMAXESZ EQU  SPMAXE+8  SOH+LEN+NUM+TYPE+LENX1+LENX2+HCHECK+EOL     TSO
SPDEF    EQU  80                  KERMIT PROTOCOL DEFAULT PKT SIZE  TSO
LPKT     EQU  SPMAXESZ+SPMAX      PACKET BUFFER SIZE (WITH PAD)     TSO
LDSKBUF  EQU  65536               DISK BUFFER SIZE                  TSO
RPTMIN   EQU       X'03'               Min repeats for quoting [7]
*
* Fields of variable S1FLAGS
ISS1     EQU  1                   GOING THROUGH IBM7171/SERIES-1    TSO
* WCC flag bits and 3270 orders:
ALARM    EQU       X'04'               ring alarm
UNLKKB   EQU       X'02'               unlock keyboard
SBA      EQU       X'11'               Set Buffer Address (3270)
IC       EQU       X'13'               Insert Cursor (3270)
         TITLE '(KERMIT) Main program'                              TSO
KERMIT   ENTER ,                                                    TSO
*
* USE R11 AS BASE REGISTER FOR THE SHARED DATA AREA
         L         R11,=A(PARMS)
         USING     PARMS,R11
         ST        R1,CPPLADDR         Save CPPL address            TSO
         MVI       S1FLAGS,X'00'       Clear S/1 flags [12]
         GTSIZE    ,                   Get terminal information     TSO
         STM       R0,R1,SCRSIZE       Save screen size & line size TSO
         LTR       R0,R0               3270 type terminal?          TSO
         BZ        OKDEV               No                           TSO
         OI        S1FLAGS,ISS1        Remember going via S/1 [12]
         MR        R0,R0               GET NBR CHARACTERS ON SCREEN TSO
         C         R1,=F'4096'         BIG SCREEN?                  TSO
         BL        INITIAL             NO                           TSO
         OI        SRFLAGS,SRBIGSCR    INDICATE BIG SCREEN          TSO
         B         INITIAL             Go initialize                TSO
         SPACE     1                                                TSO
OKDEV    STSIZE    SIZE=130            Set up linesize              TSO
         SPACE 1                                                    TSO
         STTRAN NOTRAN           Use VTAM default translate table   AJR
         SPACE 1                                                    AJR
INITIAL  L         R15,=A(INIT)
         BALR      R14,R15             CALL THE INITIALIZATION
         L         R15,=A(PACKLEN)
         BALR      R14,R15             Get max send packet size [4]
         SPACE 1                                                    TSO
*        GET SPACE FOR DISK AND PACKET BUFFERS                      TSO
         SPACE 1                                                    TSO
         L     R0,LBUFSPC         GET AMOUNT OF SPACE FOR BUFFERS   TSO
         GETMAIN RC,LV=(0)        GET STORAGE FOR BUFFERS           TSO
         LTR   R15,R15            WAS STORAGE GOTTEN OK?            TSO
         BZ    SETBUFS            YES, GO SET UP BUFFERS            TSO
         WRTERM 'Unable to allocate storage for buffers'            TSO
         B     RET                QUIT                              TSO
         SPACE 1                                                    TSO
SETBUFS  ST    R1,ABUF            ADDR OF FIRST DISK BUFFER         TSO
         A     R1,=A(LDSKBUF)     POINT TO SECOND DISK BUFFER       TSO
         ST    R1,ARBUF           SAVE SECOND DISK BUFFER ADDRSS    TSO
         A     R1,=A(LDSKBUF)     POINT TO SDAT BUFFER AREA         TSO
         ST    R1,ASDAT           SAVE ADDRESS                      TSO
         A     R1,=A(LPKT)        POINT TO RDAT BUFFER AREA         TSO
         ST    R1,ARDAT           SAVE ADDRESS                      TSO
         A     R1,=A(LPKT)        POINT TO SNDPKT BUFFER AREA       TSO
         ST    R1,ASND7171        SAVE ADDRESS                      TSO
         MVC  0(S1ORDSL,R1),S1ORDS  INITIALIZE 7171 SBA             TSO
         A     R1,=A(S1ORDSL)     POINT PAST 7171 SBA               TSO
         ST    R1,ASNDPKT         SAVE ADDRESS                      TSO
         A     R1,=A(LPKT)        POINT TO RECPKT BUFFER AREA       TSO
         ST    R1,ARECPKT         SAVE ADDRESS                      TSO
         A     R1,=A(LPKT)        POINT TO LOGBUF BUFFER AREA       TSO
         ST    R1,ALOGBUF         SAVE ADDRESS                      TSO
         SPACE 1                                                    TSO
*        SET UP BUFFER LENGTHS IN PARMS                             TSO
         SPACE 1                                                    TSO
         L     R0,=A(LPKT)        LENGTH FOR SDAT,RDAT,SNDPKT,RECPKTTSO
         ST    R0,LSNDPKT         SET LENGTH FOR SNDPKT             TSO
         ST    R0,LRECPKT         SET LENGTH FOR RECPKT             TSO
         SPACE     1                                                TSO
         LA    R1,ALLOCCB         POINT TO ALLOCATION CONTROL BLOCK TSO
         USING ALCCB,R1           MAKE IT ADDRESSABLE               TSO
         LA    R0,ALCTOLD         INDICATE "OLD" ALLOCATION         TSO
         ST    R0,ALCTYPE         PUT INTO ALCCB                    TSO
         LA    R0,SYSTAKLN        GET ADDRESS OF FILE NAME & LENGTH TSO
         ST    R0,ALCDSN          PUT INTO ALCCB                    TSO
         XC    ALCMEMBR,ALCMEMBR  ASSUME NO MEMBER NAME             TSO
         DROP  R1                 DROP ALCCB ADDRESSABILITY         TSO
         L     R15,=A(ALLOCDSN)   GET ADDRESS OF ALLOCATION         TSO
         BALR  R14,R15            GO ALLOCATE USER TAKE FILE        TSO
         B     *+4(R15)           BRANCH ON RETURN CODE             TSO
         B     INIFALLO           0  - ALLOCATION OK                TSO
         B     INIF0              4  - DATA SET DOES NOT EXIST      TSO
         B     INIFERR2           8  - ALLOCATION ERROR             TSO
         B     INIFERR2           12 - INCOMPATIBLE DATA SET TYPE   TSO
         B     INIFERR2           16 - UNSUPPORTED DATA SET TYPE    TSO
         SPACE 1                                                    TSO
INIFERR2 WRTERM 'Allocation error on system TAKE file; file ignored'
         B     INIF0              SEE ABOUT ALLOCATION SYSTEM       TSO
         SPACE 1                                                    TSO
INIFALLO OI    LFLAGS,TAKON       COMMANDS ARE FROM FILE            TSO
         SPACE 1                                                    TSO
INIF0    LA    R1,TAKEDSNL        ADDRESS OF USER TAKE FILE         TSO
         L     R15,=A(PREFIXDS)   ADDRESS OF PREFIXING ROUTINE      TSO
         BALR  R14,R15            GO PREFIX TAKE FILE NAME          TSO
         B     *+4(R15)           BRANCH ON RETURN CODE             TSO
         B     ALLOCTAK           0  - DATA SET EXISTS              TSO
         B     INIF1              4  - DATA SET DOES NOT EXIST      TSO
         B     INIFERR1           8  - PREFIXING ERROR              TSO
         SPACE 1                                                    TSO
INIFERR1 WRTERM 'Error when prefixing KERMINI file; File ignored'   TSO
         SPACE 1                                                    TSO
ALLOCTAK LA    R1,ALLOCCB         POINT TO ALLOCATION CONTROL BLOCK TSO
         USING ALCCB,R1           MAKE IT ADDRESSABLE               TSO
         LA    R0,ALCTOLD         INDICATE "OLD" ALLOCATION         TSO
         ST    R0,ALCTYPE         PUT INTO ALCCB                    TSO
         LA    R0,TAKEDSNL        GET ADDRESS OF FILE NAME & LENGTH TSO
         ST    R0,ALCDSN          PUT INTO ALCCB                    TSO
         XC    ALCMEMBR,ALCMEMBR  ASSUME NO MEMBER NAME             TSO
         DROP  R1                 DROP ALCCB ADDRESSABILITY         TSO
         L     R15,=A(ALLOCDSN)   ADDRESS OF ALLOCATION ROUTINE     TSO
         BALR  R14,R15            GO ALLOCATE SYSTEM KERMINI        TSO
         B     *+4(R15)           BRANCH ON RETURN CODE             TSO
         B     ALLOSTAK           0  - DATA SET EXISTS              TSO
         B     INIF1              4  - DATA SET DOES NOT EXIST      TSO
         B     INIFERR3           8  - ALLOCATION ERROR             TSO
         B     INIFERR3           12 - INCOMPATIBLE DATA SET TYPE   TSO
         B     INIFERR3           16 - UNSUPPORTED DATA SET TYPE    TSO
         SPACE 1                                                    TSO
INIFERR3 WRTERM 'Allocation error on KERMINI file; file ignored'    TSO
         B     INIF1              CONTINUE                          TSO
         SPACE 1                                                    TSO
ALLOSTAK OI        LFLAGS,TAKON        COMMANDS ARE FROM FILE [15 end]
         SPACE 1                                                    TSO
*        Concatenate TAKE files if there is more than one           TSO
         SPACE 1                                                    TSO
         L     R15,=A(CONCAT)     ADDRESS OF CONCATENATION CODE     TSO
         BALR  R14,R15            GO CONCATENATE TAKE FILES         TSO
         LTR   R15,R15            CONCATENATION SUCCESSFUL          TSO
         BZ    INIF1              YES, PROCEED                      TSO
         NI    LFLAGS,255-TAKON   NO, INDICATE NO TAKE FILES        TSO
         WRTERM 'Unsuccessful TAKE file concatenation; TAKE files ignor+
               ed'
         B     INIF2              PROCEED                           TSO
         SPACE 1                                                    TSO
INIF1    TM    LFLAGS,TAKON       ARE THERE TAKE FILES?             TSO
         BNO   INIF2              NO, PROCEED                       TSO
         MVC   TAKEDCB+40(8),CONCTABL+2 DDNAME INTO TAKE DCB        TSO
         OPEN  (TAKEDCB,INPUT)    OPEN TAKE FILES                   TSO
         TM    TAKEDCB+(DCBOFLGS-IHADCB),DCBOFOPN  OPEN OK?         TSO
         BO    INIF2              YES, CONTINUE                     TSO
         WRTERM 'Unable to open INITIAL files; files ignored'       TSO
         NI    LFLAGS,255-TAKON   INDICATE NO TAKE FILES            TSO
INIF2    SR        R15,R15             ZERO RC INITIALLY (IF EXIT)
         MVI       EXTFLG,X'00'        Don't exit yet [11]
         LA    R2,PROMSG          GET ADDRESS OF HEADER MESSAGE     TSO
         LA    R3,L'PROMSG        GET LENGTH OF HEADER MESSAGE      TSO
         WRTERM (R2),(R3)                                           TSO
         WRTERM 'Enter HELP for Kermit-TSO help'                    AJR
         SPACE     2
*        Prompt user for input or read from TAKE file.
         SPACE
PROMPT   CLI       EXTFLG,X'FF'        Time to exit? [11]
         BE        LV2                 Yup [11]
         TM        LFLAGS,TAKON        Using TAKE file? [15 start]
         BNO       PRO1                No go prompt
         MVC   INPUT,BLANKS        Clear input buffer to blanks TSO
         GET       TAKEDCB,INPUT
         TR        INPUT(130),UPC      Upcase the input
         LA    R1,INPUT+L'INPUT   Point beyond end of input         TSO
         LA    R0,INPUT           Point to start of input           TSO
TAKLOOP  BCTR  R1,0               Back up one character             TSO
         CLI   0(R1),C' '         Is it a blank?                    TSO
         BNE   TAKGETLN           No, get length of command         TSO
         CR    R1,R0              At the end?                       TSO
         BH    TAKLOOP            No, keep looking                  TSO
         B     PROMPT             Command is all blanks             TSO
         SPACE 1                                                    TSO
TAKGETLN SR    R1,R0              Get length of command - 1         TSO
         LA    R1,5(,R1)          Add length of header + 1          TSO
         SLL   R1,16              Shift to upper half of reg        TSO
         ST    R1,INPUTLN         Save length                       TSO
         LA    R0,INPUTLN         Get address of buffer & len       TSO
         ST    R0,CMDBUF          Set as command buffer             TSO
         B     PRO2               Go parse                          TSO
         SPACE 1                                                    TSO
TAKEEOF  NI    LFLAGS,X'FF'-TAKON                                   TSO
         CLOSE (TAKEDCB)          Close TAKE files                  TSO
         FREEPOOL TAKEDCB         FREE THE QSAM BUFFER POOL         TSO
         L     R15,=A(DECONCAT)   Get address of DECONCAT           TSO
         BALR  R14,R15            Go do deconcatenation             TSO
         LA    R0,CONCTABL        START DEALLOCATION AT             TSO
         ST    R0,CONCPTR         BEGINNING OF TABLE                TSO
         LH    R2,CONCCNT         Get count to deallocate           TSO
         LA    R3,CONCTABL        Get concatenation table addr      TSO
TAKEDALC UNALLOC DDNAME,NAME=(R3) GO UNALLOCATE THE DDNAME          TSO
         SR    R1,R1              Clear for ICM                     TSO
         ICM   R1,3,0(R3)         Get length of DDNAME              TSO
         LA    R3,2(R1,R3)        Point to next DDNAME & length     TSO
         BCT   R2,TAKEDALC        Continue to deallocate            TSO
         XC    CONCCNT,CONCCNT    Clear concatenation count         TSO
         B         PROMPT              Done with init/TAKE [15 end]
         SPACE 1                                                    TSO
PRO1     STAX  KERMATTN,DEFER=NO,USADDR=(R11) EST ATTN EXIT         TSO
         TM    S1FLAGS,ISS1       IS IT IBM 7171/SERIES 1?          TSO
         BNO   PRO1A              NO                                TSO
         TM    SRFLAGS,SRCLRSCR   CLEAR SCREEN?                     TSO
         BNO   PRO1A              NO                                TSO
         PROMPT 'Kermit-TSO>'     EXTRA PROMPT FOR FULL-SCREEN      AJR
         B     *+4(R15)           Branch on return code             TSO
         B     PROCLR             0  - COMMAND RECEIVED             TSO
         B     PROCLR             4  - ATTENTION RECEIVED           TSO
PROCLR   CLRSCR ,                 GO CLEAR THE SCREEN               TSO
         NI    SRFLAGS,255-SRCLRSCR TURN OFF CLEAR SCREEN FLAG      TSO
PRO1A    PROMPT 'Kermit-TSO>'                                       AJR
         B     *+4(R15)           Branch on return code             TSO
         B     COMMAND            0  - Command received             TSO
         B     PRO1A              4  - Attention received           TSO
         SPACE 1                                                    TSO
COMMAND  LH    R0,0(,R1)          Get length of command buffer      TSO
         S     R0,=F'4'           Subtract length of header         TSO
         BZ    PRO1               Prompt again if null line         TSO
         ST    R1,CMDBUF          Save command buffer address       TSO
         SPACE 1                                                    TSO
PRO2     L     R1,CMDBUF          Get address of command buffer     TSO
         L     R15,=A(SCANCBUF)   Address of scanning routine       TSO
         BALR  R14,R15            Go scan for command               TSO
         STH   R0,CMDLEN          SAVE COMMAND LENGTH               TSO
         LTR   R0,R0              Was a command Found?              TSO
         BZ    PROMPT             No, go prompt                     TSO
         LR    R6,R2              Save pointer to command           TSO
NOPRO    MVI       ERRNUM,X'FF'        RESET ERROR FOR THIS TIME
         MVC       CHKLEN(1),CHKSET    Reset checksum length
         CLI       0(R6),C'E'          CHECK FOR 'EXIT' COMMAND
         BE        LEAVE
         CLI       0(R6),C'Q'          CHECK FOR 'QUIT' COMMAND
         BE        LEAVE
         CLC       0(4,R6),=C'HELP'    NEED HELP ?
         BNE       SETCHK
         L     R1,CMDBUF          POINT TO COMMAND BUFFER           TSO
         CALL  DOHELP             GO GET HELP                       TSO
         B         PROMPT
         SPACE 1                                                    TSO
SETCHK   CLC       0(3,R6),=CL3'SET'   IS IT THE SET COMMAND ?
         BE        STSWITCH
         CLC       0(2,R6),=C'ST'      IS IT THE STATUS COMMAND?    AJR
         BE        STATSW
         CLC       0(2,R6),=C'SH'      IS IT THE SHOW COMMAND?      AJR
         BE        SHOSW
         CLC       0(2,R6),=C'TD'      Dump a table? [20](TDUMP)    AJR
         BE        TDSW                [20]
         CLC       0(3,R6),=C'SER'     Server command [13]          AJR
         BE        SERVSW              Yup [13]
         CLC       0(2,R6),=C'TA'      Take a command file? [15]    AJR
         BE        TAKSW               [15]
         CLI       0(R6),C'*'          Is this a comment? [15]
         BE        PROMPT              Yes ignore [15]
         OI        FLAGS,FLG1          SET FLG1 - IT'S THE FIRST FILE
         NI        FLAGS,X'FF'-FLG2    TURN OFF OVERWRITE FLAG (INIT)
         XC        NFSENT,NFSENT       NUMBER OF FILES SENT (= 0)
         CLC   0(3,R6),=C'REC'    Is it the RECEIVE command?        TSO
         BE    RSWITCH            Yes,  go do RECEIVE               TSO
         CLC       0(3,R6),=C'SEN'
         BE    SSWITCH                                              TSO
ERR      WRTERM    'Invalid command'
         B         PROMPT              INVALID COMMAND - TRY AGAIN
         SPACE 3                                                    TSO
*        Process SEND command                                       TSO
         SPACE 1                                                    TSO
SSWITCH  EQU       *
         TM        FLAGS,DEBUG         In DEBUG mode? [10]
         BO        SCALL               Yes, then don't ignore attn [10]
         STAX      IGNATTN             Else ignore attention [10]
SCALL    L     R1,CMDBUF          POINT TO COMMAND BUFFER           TSO
         LH    R2,2(,R1)          GET OFFSET TO 1ST OPERAND         TSO
         LA    R2,4(R2,R1)        POINT TO FIRST OPERAND            TSO
         CLI   0(R2),C'?'         ASKING FOR HELP?                  TSO
         BNE   SNDFILE            NO, ASSUME OPERAND IS FILE NAME   TSO
         WRTERM 'Specify file name on SEND command'                 TSO
         B     PROMPT             GO BACK AND PROMPT AGAIN          TSO
         SPACE 1                                                    TSO
SNDFILE  L     R15,=A(SNDCMD)                                       TSO
         BALR      R14,R15             CALL SEND PORTION
         LTR       R5,R15              CHECK RETURN CODE
         BNZ       SETSTAX
         MVI       ERRNUM,X'FF'        WORKED OK
SETSTAX  STAX      ,                   Reset attn address [10]
         MVC       OLDERR(1),ERRNUM    ERROR SETTING OF THIS RUN
         TM        FLAGS,FLG5          GOT EXTRA SPACE?
         BNO       SSW1                NOPE, JUST LEAVE
         L     R0,=A(4096)        AMOUNT OF SPACE WE GOT            TSO
         L         R1,STORLOC          FIND IT & FREE IT
         FREEMAIN R,LV=(0),A=(1)  FREE IT                           TSO
         NI        FLAGS,X'FF'-FLG5    TURN OFF EXTRA SPACE FLAG
SSW1     LTR       R5,R5               CHECK THE RETCODE
         BZ        PROMPT              ALL OKAY
         WRTERM    'Error in sending file. Try again.'
         B         PROMPT              ERROR - TRY AGAIN
         SPACE     1                                                TSO
*        Process RECEIVE command                                    TSO
         SPACE     1                                                TSO
RSWITCH  EQU       *
         TM        FLAGS,DEBUG         In DEBUG mode? [10]
         BO        RCALL               Yes, then don't ignore attn [10]
         STAX      IGNATTN             Else ignore attention [10]
RCALL    L     R1,CMDBUF          POINT TO COMMAND BUFFER           TSO
         LH    R2,2(,R1)          GET OFFSET TO 1ST OPERAND         TSO
         LA    R2,4(R2,R1)        POINT TO FIRST OPERAND            TSO
         CLI   0(R2),C'?'         ASKING FOR HELP?                  TSO
         BNE   RCVFILE            NO, ASSUME OPERAND IS FILE NAME   TSO
         WRTERM 'Specify file name on RECEIVE command or press'     TSO
         WRTERM 'carriage return to use name(s) sent from micro-'   TSO
         WRTERM 'computer.'                                         TSO
         B     PROMPT             GO BACK AND PROMPT AGAIN          TSO
         SPACE 1                                                    TSO
RCVFILE  L         R15,=A(RCVCMD)                                   TSO
         BALR      R14,R15             CALL RECEIVE PORTION
         LTR       R5,R15              CHECK RETURN CODE
         BNZ       SETRSTX
         MVI       ERRNUM,X'FF'
SETRSTX  STAX      ,                   Reset attn address [10]
         MVC       OLDERR(1),ERRNUM    ERROR SETTING OF THIS RUN
         LTR       R5,R5               CHECK THE RETCODE
         BZ        PROMPT              ALL OKAY
         WRTERM    'Error in receiving file. Try again.'
         B         PROMPT              ERROR - TRY AGAIN
         SPACE     1                                                TSO
*        Process SET command                                        TSO
         SPACE     1                                                TSO
STSWITCH EQU       *
         L     R1,CMDBUF          PASS ADDRESS OF COMMAND BUFFER    TSO
         LH    R2,2(,R1)          GET OFFSET TO FIRST OPERAND       TSO
         LA    R2,4(R2,R1)        POINT TO FIRST OPERAND            TSO
         CLI   0(R2),C'?'         ASKING FOR HELP?                  TSO
         BNE   SETS0              NO                                TSO
         WRTERM 'One of the following:'                             AJR
         WRTERM ' ATOE            ATOENcp         BLKsize        BLOck +
                         DEBug'                                     AJR
         WRTERM ' DELay           DIrectory       ENd            ETOA  +
                         ETOANcp'                                   AJR
         WRTERM ' File            Header          Lrecl          PAcket+
                         PRimary'                                   AJR
         WRTERM ' Quote           Recfm           SECondary      SERies+
               1         Tabs'                                      AJR
         WRTERM ' Warning'                                          AJR
         B     PROMPT                                               TSO
         SPACE 1                                                    TSO
SETS0    L         R15,=A(SET)
         BALR      R14,R15             CALL "SET" SUBROUTINE
         LTR       R15,R15             CHECK RETCODE
         BZ        PROMPT
         WRTERM    'Invalid Set Command'
         B         PROMPT
         SPACE 1                                                    TSO
*        Process SHOW command                                       TSO
         SPACE 1                                                    TSO
SHOSW    EQU       *
         L     R1,CMDBUF          PASS ADDRESS OF COMMAND BUFFER    TSO
         LH    R2,2(,R1)          GET OFFSET TO FIRST OPERAND       TSO
         LA    R2,4(R2,R1)        POINT TO FIRST OPERAND            TSO
         CLI   0(R2),C'?'         ASKING FOR HELP?                  TSO
         BNE   SHOWS0             NO                                TSO
         WRTERM 'One of the following:'                             AJR
         WRTERM ' All(Default)    BLKsize         BLOck          DEBug +
                         DELay'                                     AJR
         WRTERM ' DIRectory       End             File           Header+
                         Lrecl'                                     AJR
         WRTERM ' PAcket          PRimary         Quote          Recfm +
                         SECondary'                                 AJR
         WRTERM ' SERies1         Tabs            Warning'          AJR
         B     PROMPT                                               TSO
         SPACE 1                                                    TSO
SHOWS0   L         R15,=A(SHOW)
         BALR      R14,R15             CALL "SHOW" SUBROUTINE
         LTR       R15,R15             CHECK RETCODE
         BZ        PROMPT
         WRTERM    'Invalid Show Command'
         B         PROMPT
         SPACE     1                                                TSO
*        Process SERVER command                                     TSO
         SPACE     1                                                TSO
SERVSW   EQU       *                   [13 start]
         L     R1,CMDBUF          GET ADDRESS OF COMMAND BUFFER     TSO
         LH    R2,2(,R1)          GET OFFSET TO 1ST OPERAND         TSO
         LA    R2,4(R2,R1)        POINT TO FIRST OPERAND            TSO
         CLI   0(R2),C'?'         ASKING FOR HELP?                  TSO
         BNE   SERVS0             NO, ASSUME OPERAND IS FILE NAME   TSO
         WRTERM    'Follow command with a carriage return'          TSO
         B         PROMPT
SERVS0   L         R15,=A(SERVER)
         BALR      R14,R15             Call server routine
         B         PROMPT              Return to normal mode [13 end]
         SPACE     1                                                TSO
*        Process TAKE command                                       TSO
         SPACE     1                                                TSO
TAKSW    L     R1,CMDBUF          Pass address of command buffer    TSO
         LH    R2,2(,R1)          GET OFFSET TO 1ST OPERAND         TSO
         LA    R2,4(R2,R1)        POINT TO FIRST OPERAND            TSO
         CLI   0(R2),C'?'         ASKING FOR HELP?                  TSO
         BNE   TAKFILE            NO, ASSUME OPERAND IS FILE NAME   TSO
         WRTERM 'Specify file name on TAKE command'                 TSO
         B     PROMPT             GO BACK AND PROMPT AGAIN          TSO
         SPACE 1                                                    TSO
TAKFILE  L     R15,=A(TAKECMD)    Get address of command routine    TSO
         BALR  R14,R15            Go process the command            TSO
         LTR   R15,R15            Everything go ok?                 TSO
         BNZ   PROMPT             No, go prompt for new command     TSO
         OI        LFLAGS,TAKON        Say we're in TAKE mode
         B         PROMPT              [15 end]
         SPACE     1                                                TSO
*        Process STATUS command                                     TSO
         SPACE     1                                                TSO
STATSW   EQU       *
         L     R1,CMDBUF          GET ADDRESS OF COMMAND BUFFER     TSO
         LH    R2,2(,R1)          GET OFFSET TO 1ST OPERAND         TSO
         LA    R2,4(R2,R1)        POINT TO FIRST OPERAND            TSO
         CLI   0(R2),C'?'         ASKING FOR HELP?                  TSO
         BNE   GIVSTAT            NO                                TSO
         WRTERM    'Follow command with a carriage return'          TSO
         B         PROMPT
GIVSTAT  CLI       OLDERR,X'FF'        WAS THERE AN ERROR LAST TIME?
         BNE       FAIL
         WRTERM    'No errors'                                      AJR
         B         PROMPT
FAIL     SR        R5,R5
         IC        R5,OLDERR           GET OFFSET INTO ERROR TABLE
         M     R4,=F'28'          OFFSET := ERRNUM * 28             TSO
         LA        R5,ERRTAB(R5)
         WRTERM (R5),28           PRINT ERROR MSG ON SCREEN         TSO
         B         PROMPT              AND LEAVE
         SPACE     1                                                TSO
IGNATTN  BR        R14                 Ignore attention [10]
         SPACE     1                                                TSO
*        PROCESS TDUMP COMMAND                                      AJR
         SPACE     1                                                TSO
TDSW     EQU       *                                                TSO
         L     R1,CMDBUF          PASS ADDRESS OF COMMAND BUFFER    TSO
         LH    R2,2(,R1)          GET OFFSET TO FIRST OPERAND       TSO
         LA    R2,4(R2,R1)        POINT TO FIRST OPERAND            TSO
         CLI   0(R2),C'?'         ASKING FOR HELP?                  TSO
         BNE   TDS0               NO                                TSO
         WRTERM 'Name of table to dump:'                            AJR
         WRTERM ' ATOE            ATOENcp         ETOA           ETOANc+
               p'                                                   AJR
         B     PROMPT                                               TSO
         SPACE 1                                                    TSO
TDS0     L     R15,=A(TDUMP)      GET ADDRESS OF TDUMP ROUTINE      TSO
         BALR  R14,R15            GO PROCESS COMMAND                TSO
         B         PROMPT
         SPACE     1                                                TSO
LEAVE    L     R1,CMDBUF          GET ADDRESS OF COMMAND BUFFER     TSO
         LH    R2,2(,R1)          GET OFFSET TO 1ST OPERAND         TSO
         LA    R2,4(R2,R1)        POINT TO FIRST OPERAND            TSO
         CLI   0(R2),C'?'         ASKING FOR HELP?                  TSO
         BNE   LV2                NO                                TSO
         WRTERM    'Follow command with a carriage return'
         B         PROMPT
         SPACE 1                                                    TSO
*        FREE BUFFERS                                               TSO
         SPACE 1                                                    TSO
LV2      L     R1,ABUF            POINT TO AREA TO FREE             TSO
         L     R0,LBUFSPC         GET SPACE TO FREE                 TSO
         FREEMAIN R,LV=(0),A=(1)  FREE BUFFERS                      TSO
         SPACE 1                                                    TSO
*        CLOSE DATA SETS                                            TSO
         SPACE 1                                                    TSO
         CLOSE (LOGDCB)           CLOSE THE LOG DATA SET            TSO
         UNALLOC DSNAME,NAME=SYSLOGLN  UNALLOCATE THE LOG DATA SET  TSO
RET      RET ,                                                      TSO
         EXIT                                                       TSO
         TITLE 'KERMIT ATTENTION EXIT FOR NON-FILE TRANSFER'        TSO
*        THIS ATTENTION EXIT IS USED WHEN KERMIT IS NOT TRANS-      TSO
*        FERING FILES WITH ANOTHER KERMIT.  IT POSTS THE ECB        TSO
*        USED IN COMMAND PROCESSING TO ALLOW PROCESSORS LIKE        TSO
*        IKJPARS TO RETURN TO THE KERMIT MODULE.                    TSO
*                                                                   TSO
*        WHEN FILES ARE BEING TRANSFERRED ANOTHER STAX IS ISSUED    TSO
*        WITH DEFER=YES SPECIFIED TO SUPPRESS ATTENTIONS.           TSO
         SPACE 3                                                    TSO
KERMATTN DS    0H                 MAIN KERMIT ATTN EXIT             TSO
         L     R11,8(,R1)         GET PARAMETER LIST ADDRESS        TSO
         MVI   CPECB,X'40'        POST THE MAIN ECB                 TSO
         SR    R15,R15            SET RETURN CODE OF ZERO           TSO
         BR    R14                RETURN TO STAX                    TSO
         SPACE 1                                                    TSO
         TITLE '(INIT) Initialize parameters'                       TSO
INIT     ENTER ,                                                    TSO
         XC        INPUT,INPUT
         XC        FSENT,FSENT
         XC        SPKNUM,SPKNUM       SET VARIABLES TO ZERO
         XC        RPKNUM,RPKNUM
         XC        LSDAT,LSDAT
         XC        LRDAT,LRDAT
         MVI       FLAGS,X'00'         CLEAR ALL FLAGS
         MVI   LFLAGS,X'00'       CLEAR LOCAL SETTINGS              TSO
         AIF   ('&WARN' EQ 'OFF').WAROFF                            TSO
         OI    LFLAGS,WARFL       INDICATE RENAME INCOMING FILES    TSO
.WAROFF  ANOP                                                       TSO
         MVI   SRFLAGS,0          CLEAR SEND/RECEIVE FLAGS          TSO
         XC        INBFPT,INBFPT
         XC        OUTBFPT,OUTBFPT
         XC        NUMTRY,NUMTRY
         MVI       PREV,X'00'
         MVI       ERRNUM,X'FF'        SET TO NO ERROR FOR NOW
         MVI       OLDERR,X'FF'        SAME HERE
         XC        PKVAR,PKVAR         ZERO IT OUT
         XC        OLDTRY,OLDTRY
         XC        TEMP,TEMP
         XC        NFSENT,NFSENT       ZERO FILES SENT,INITIALLY
         XC        STORLOC,STORLOC
         MVC   BLKSIZE,=AL2(DBLKSZ)  SET UP DEFAULT BLKSIZE         TSO
         MVC   LRECL,=AL2(DLRECL)  SET UP DEFAULT LRECL             TSO
         MVC   PRIME,=AL2(DPRIME)  SET UP DEFAULT PRIMARY ALLOCATN  TSO
         MVC   SECOND,=AL2(DSECOND)  SET UP DEFAULT SECONDARY ALLOC TSO
         MVC   DIRCTY,=AL2(DDIR)   SET UP DEFAULT DIRECTORY BLKS    TSO
         MVC   DELAY,=AL4(SENDDLAY)  SET UP SEND COMMAND DELAY      TSO
         MVI       RFM,DRECFM
         MVC       FM(2),DFM
         MVC       MAXOUT,=A(MAXTXT)   Max output buffer size [6]
         MVI       RQUOTE,DQUOTE       Use default quote char [4]
         MVI       SQUOTE,DQUOTE       Ditto [4]
         MVI       EBQUOT,D8QUO        For 8-bit quoting [1][4]
         MVI       ORIG8Q,D8QUO        For 8-bit quoting [1][4]
         MVI       REOL,DEOL           Use default for now [4]
         MVI       SEOL,DEOL           Ditto [4]
         MVI       STIME,DSTIM
         MVI       RTIME,DRTIM
         MVI       SPAD,DSPAD
         MVI       RPAD,DRPAD
         MVI       SPADCH,DSPADC
         MVI       RPADCH,DRPADC
         MVI       CHKLEN,DCHKLEN      Checksum length [4]
         MVI       CHKSET,DCHKLEN      Checksum length [4]
         MVI       RPTQ,DRPT           Repeat char prefix [4]
         MVI       ORIGQ,DRPT          Repeat char prefix [4]
         MVI       CXZ,X'00'           Abort sending file(s) [16]
         MVI       STATE,C' '
         MVI       STYPE,C' '
         MVI       RTYPE,C' '
         SPACE 1                                                    TSO
*        INITIALIZE THE TAB SETTINGS                                TSO
         SPACE 1                                                    TSO
         MVC   TABCOUNT,MAXTABS   SET UP TAB COUNT                  TSO
         MVC   TABTBL(&NUMTABS),DFLTTABS                            TSO
         SPACE 1                                                    TSO
*        BUILD DEFAULT PARAMETER BLOCK AND PARAMETER LIST           TSO
         SPACE 1                                                    TSO
         L     R3,CPPLADDR        GET ADDRESS OF CPPL               TSO
         USING CPPL,R3            MAKE IT ADDRESSABLE               TSO
         LA    R2,PRFXDFPB        GET DFPB ADDRESS                  TSO
         USING DFPB,R2            MAKE IT ADDRESSABLE               TSO
         LA    R0,WORKAREA        GET ADDRESS OF WORK AREA          TSO
         STCM  R0,7,DFPBQUAL+1    PUT INTO DFPB                     TSO
         L     R0,CPPLPSCB        GET PSCB ADDRESS                  TSO
         STCM  R0,7,DFPBPSCB+1    PUT INTO DFPB                     TSO
         DROP  R2                 DROP DFPB ADDRESSABILITY          TSO
         SPACE 1                                                    TSO
         LA    R2,PRFXDFPL        GET ADDRESS OF DFPL               TSO
         USING DFPL,R2            MAKE IT ADDRESSABLE               TSO
         MVC   DFPLUPT,CPPLUPT    PUT IN UPT ADDRESS                TSO
         MVC   DFPLECT,CPPLECT    PUT IN ECT ADDRESS                TSO
         LA    R0,CPECB           GET ADDRESS OF ECB                TSO
         ST    R0,DFPLECB         PUT INTO DFPL                     TSO
         LA    R0,PRFXDFPB        GET DFPB ADDRESS                  TSO
         ST    R0,DFPLDFPB        PUT INTO DFPL                     TSO
         DROP  R2                 DROP DFPL ADDRESSABILITY          TSO
         SPACE 1                                                    TSO
*        BUILD THE OUTPUT LINE DESCRIPTOR (OLD) AND I/O PARAMETER   TSO
*        LIST (IOPL).  ALSO SET UP THE PUTGET PARAMETER BLOCK       TSO
*        (PGPB).                                                    TSO
         SPACE 1                                                    TSO
         LA    R0,1               INDICATE ONE MESSAGE SEGMENT      TSO
         ST    R0,OLDSEG          PUT INTO OLD                      TSO
         LA    R0,PUTLBUF         GET ADDRESS OF OUTPUT BUFFER      TSO
         ST    R0,OLDBUF1         PUT INTO OLD                      TSO
         SPACE 1                                                    TSO
*        INITIALIZE IOPL FOR GETLINE, PUTLINE, & PUTGET             TSO
         SPACE 1                                                    TSO
         LA    R2,IOPLAREA        GET ADDRESS OF IOPL               TSO
         USING IOPL,R2            MAKE IT ADDRESSABLE               TSO
         L     R3,CPPLADDR        GET ADDRESS OF CPPL               TSO
         USING CPPL,R3            MAKE IT ADDRESSABLE               TSO
         L     R0,CPPLUPT         GET ADDRESS OF UPT                TSO
         ST    R0,IOPLUPT         PUT INTO IOPL                     TSO
         L     R0,CPPLECT         GET ADDRESS OF ECT                TSO
         ST    R0,IOPLECT         PUT INTO IOPL                     TSO
         LA    R0,CPECB           GET ADDRESS OF ECB                TSO
         ST    R0,IOPLECB         PUT INTO IOPL                     TSO
         DROP  R2                 DROP IOPL ADDRESSABILITY          TSO
         SPACE 1                                                    TSO
*        INITIALIZE CSPL FOR IKJSCAN                                TSO
         SPACE 1                                                    TSO
         LA    R2,CSPLAREA        GET ADDRESS OF CSPL               TSO
         USING CSPL,R2            MAKE IT ADDRESSABLE               TSO
         L     R0,CPPLUPT         GET ADDRESS OF UPT                TSO
         ST    R0,CSPLUPT         PUT INTO CSPL                     TSO
         L     R0,CPPLECT         GET ADDRESS OF ECT                TSO
         ST    R0,CSPLECT         PUT INTO CSPL                     TSO
         LA    R0,CPECB           GET ADDRESS OF ECB                TSO
         ST    R0,CSPLECB         PUT INTO CSPL                     TSO
         GETMAIN RC,LV=12,SP=1    GET STORAGE FOR FLAG WORD & CSOA  TSO
         LTR   R15,R15            STORAGE GOTTEN OK?                TSO
         BZ    INICSOA            YES, PROCEED                      TSO
         WRTERM 'Insufficient storage to build IKJSCAN control blocks'
         SVC   3                  QUIT                              TSO
         SPACE 1                                                    TSO
INICSOA  ST    R1,CSPLFLG         SAVE ADDRESS OF FLAG WORD         TSO
         LA    R1,4(,R1)          GET ADDRESS OF CSOA               TSO
         ST    R1,CSPLOA          PUT INTO CSPL                     TSO
         XC    CSPLCBUF,CSPLCBUF  CLEAR COMMAND BUFFER POINTER      TSO
         DROP  R2                 DROP CSPL ADDRESSABILITY          TSO
         SPACE 1                                                    TSO
*        INITIALIZE THE PARSE PARAMETER LIST                        TSO
         SPACE 1                                                    TSO
         LA    R2,PPLAREA         GET ADDRESS OF PPL                TSO
         USING PPL,R2             MAKE IT ADDRESSABLE               TSO
         L     R0,CPPLUPT         GET ADDRESS OF UPT                TSO
         ST    R0,PPLUPT          PUT INTO THE PPL                  TSO
         L     R0,CPPLECT         GET ADDRESS OF ECT                TSO
         ST    R0,PPLECT          PUT INTO THE PPL                  TSO
         LA    R0,CPECB           GET ADDRESS OF ECB                TSO
         ST    R0,PPLECB          PUT INTO THE PPL                  TSO
         LA    R0,PDLADDR         GET ADDRESS OF THE PDL POINTER    TSO
         ST    R0,PPLANS          PUT INTO THE PPL                  TSO
         DROP  R2                 DROP PPL ADDRESSABILITY           TSO
*
INITRET  RET ,                                                      TSO
         EXIT                                                       TSO
         DROP  R3                 DROP CPPL ADDRESSABILITY          TSO
         TITLE '(PACKLEN) Maximize data packet size'                TSO
*
* Set the maximum data packet size. [4]
PACKLEN  ENTER ,                                                    TSO
         L         R5,SPSIZ            Maximum send packet size
         C    R5,=A(SPMAX)        CHECK MAX PACKET SIZE             TSO
         BNH  PACKNY              NOT LONG                          TSO
         S    R5,=F'3'            EXTENDED HEADER LENGTH            TSO
         LA   R0,&SIZ7171         ASSUME MAX LENGTH FOR IBM7171     TSO
         TM   S1FLAGS,ISS1        IS THIS IBM 7171/SERIES-1?        TSO
         BO   *+8                 YES                               TSO
         LA   R0,&SIZLINE         SET MAX LENGTH FOR LINE TERMINALS TSO
         S    R0,=F'7'            ACCOUNT FOR OVERHEAD BYTES        TSO
         CR   R0,R5                                                 TSO
         BH   *+6                                                   TSO
         LR   R5,R0               BIGGEST WE CAN SEND               TSO
PACKNY   DS   0H                                                    TSO
         S         R5,=F'4'            Minus control information
         SR        R7,R7
         IC        R7,CHKLEN
         SR        R5,R7               Minus checksum length
         BCTR      R5,0
         BCTR      R5,0                Minus two for possible #X
         CLI       EBQUOT,AN           Doing 8-bit quoting?
         BE        PACK0               Nope
         CLI       EBQUOT,AY           Not doing it in this case either
         BE        PACK0
         BCTR      R5,0                Another one for 8-bit quoting
PACK0    CLI       RPTQ,X'00'          Doing repeat char quoting
         BE        PACK1               Nope, so that's all for now
         BCTR      R5,0
         BCTR      R5,0                Minus two for repeat prefix
PACK1    ST        R5,MAXDAT           Save max length for data field
* Do standard linkage and return.
         RET   ,                                                    TSO
         EXIT                                                       TSO
         TITLE '(LOGABEND) DCB ABEND exit for log data set'         TSO
LOGABEND CSECT                                                      TSO
         PUSH  PRINT                                                TSO
         PRINT NOGEN                                                TSO
         LR    R12,R15            ESTABLISH MODULE                  TSO
         USING LOGABEND,R12       ADDRESSABILITY                    TSO
         ST    R14,LOGRET         SAVE RETURN ADDRESS               TSO
         LA    R13,LOGSAVE        POINT TO SAVE AREA                TSO
         TM    3(R1),X'04'        OK TO IGNORE ERROR?               TSO
         BNO   LOGTERM            NO                                TSO
         SPACE 1                                                    TSO
*        LOOK FOR x37 ABENDS                                        TSO
         SPACE 1                                                    TSO
         CLC   =X'B370',0(R1)     B37 ABEND?                        TSO
         BE    LOGFILLD           YES                               TSO
         CLC   =X'D370',0(R1)     D37 ABEND?                        TSO
         BE    LOGFILLD           YES                               TSO
         CLC   =X'E370',0(R1)     E37 ABEND?                        TSO
         BNE   LOGTERM            NO                                TSO
LOGFILLD MVI   ERRNUM,32          SET LOG IS FULL                   TSO
         NI    FLAGS,255-DEBUG    TURN OFF DEBUG                    TSO
         MVI   STATE,C'A'         SET ABORT STATE                   TSO
         B     LOGMSG             GO SEND MESSAGE                   TSO
         SPACE 1                                                    TSO
LOGMSG   MVI   3(R1),X'04'        IGNORE THIS ABEND                 TSO
         L     R2,4(,R1)          GET THE DCB ADDRESS               TSO
         CLOSE ((R2))             CLOSE THE DCB                     TSO
         B     LOGRTRN            ALL THROUGH                       TSO
         SPACE 1                                                    TSO
LOGTERM  MVI   3(R1),X'00'        TERMINATE THE TASK                TSO
LOGRTRN  L     R14,LOGRET         GET RETURN ADDRESS                TSO
         BR    R14                RETURN                            TSO
         SPACE 3                                                    TSO
LOGRET   DS    F                  RETURN REGISTER SAVE AREA         TSO
LOGSAVE  DS    18F                SAVE AREA FOR THIS ROUTINE        TSO
         LTORG                                                      TSO
         DROP  R12                                                  TSO
         POP   PRINT                                                TSO
         TITLE '(DCBABEND) Exit for SEND, RECEIVE, and TAKE files'  TSO
DCBABEND CSECT                                                      TSO
         PUSH  PRINT                                                TSO
         PRINT NOGEN                                                TSO
         LR    R12,R15            ESTABLISH MODULE                  TSO
         USING DCBABEND,R12       ADDRESSABILITY                    TSO
         ST    R14,DCBRET         SAVE RETURN ADDRESS               TSO
         LA    R13,DCBSAVE        POINT TO SAVE AREA                TSO
         TM    3(R1),X'04'        OK TO IGNORE ERROR?               TSO
         BNO   DCBTERM            NO                                TSO
         SPACE 1                                                    TSO
*        LOOK FOR x37 ABENDS                                        TSO
         SPACE 1                                                    TSO
         CLC   =X'B370',0(R1)     B37 ABEND?                        TSO
         BE    DCBFILLD           YES                               TSO
         CLC   =X'D370',0(R1)     D37 ABEND?                        TSO
         BE    DCBFILLD           YES                               TSO
         CLC   =X'E370',0(R1)     E37 ABEND?                        TSO
         BNE   DCB013             NO                                TSO
DCBFILLD MVI   ERRNUM,6           SET FILE OR DISK IS FULL          TSO
         LM    R3,R4,DCBFULL      GET MESSAGE LENGTH AND ADDRESS    TSO
         B     DCBMSG             GO SEND MESSAGE                   TSO
         SPACE 1                                                    TSO
*        LOOK FOR 013 ABEND                                         TSO
         SPACE 1                                                    TSO
DCB013   CLC   =X'0130',0(R1)     013 ABEND?                        TSO
         BNE   DCBTERM            NO                                TSO
         CLI   2(R1),X'14'        REASON CODE = 14?                 TSO
         BNE   DCBMEM             NO                                TSO
         MVI   ERRNUM,14          SET CONFLICTING DCB ATTRIBUTES    TSO
         LM    R3,R4,DCBCONF      GET MESSAGE LENGTH AND ADDRESS    TSO
         B     DCBMSG             GO SEND MESSAGE                   TSO
         SPACE 1                                                    TSO
DCBMEM   CLI   2(R1),X'18'        UNKNOWN MEMBER NAME? (RC=X'18')   TSO
         BNE   DCBTERM            NO                                TSO
         MVI   ERRNUM,31          SET UNKNOWN MEMBER                TSO
         LM    R3,R4,DCBNOMEM     GET MESSAGE LENGTH AND ADDRESS    TSO
         B     DCBMSG             GO SEND MESSAGE                   TSO
         SPACE 1                                                    TSO
DCBMSG   MVI   3(R1),X'04'        IGNORE THIS ABEND                 TSO
         L     R2,4(,R1)          GET THE DCB ADDRESS               TSO
         CLOSE ((R2))             CLOSE THE DCB                     TSO
         TM    LFLAGS,SERVON+RECVON+SENDON  SENDING OR RECEIVING?   TSO
         BM    DCBRTRN            YES, ALL THROUGH                  TSO
         WRTERM (R4),(R3)         PRINT APPROPRIATE MESSAGE         TSO
         B     DCBRTRN            ALL THROUGH                       TSO
         SPACE 1                                                    TSO
DCBTERM  MVI   3(R1),X'00'        TERMINATE THE TASK                TSO
DCBRTRN  L     R14,DCBRET         GET RETURN ADDRESS                TSO
         BR    R14                RETURN                            TSO
         SPACE 3                                                    TSO
DCBRET   DS    F                  RETURN REGISTER SAVE AREA         TSO
DCBSAVE  DS    18F                SAVE AREA FOR THIS ROUTINE        TSO
DCBCONF  DC    A(L'DCBCNFLT),A(DCBCNFLT)                            TSO
DCBNOMEM DC    A(L'DCBNMEMB),A(DCBNMEMB)                            TSO
DCBFULL  DC    A(L'DCBFULLM),A(DCBFULLM)                            TSO
DCBCNFLT DC    C'Conflicting DCB attributes for data set specified' TSO
DCBNMEMB DC    C'Unknown member name specified'                     TSO
DCBFULLM DC    C'Data set or disk is full'                          TSO
         LTORG                                                      TSO
         DROP  R12                                                  TSO
         POP   PRINT                                                TSO
         TITLE '(SERVICE) Service routines'                         TSO
*        This routine translates data.                              TSO
*        On Entry:                                                  TSO
*          R2 -> Buffer to be translated                            TSO
*          R3 contains length to be translated                      TSO
*          R4 -> TRANSLATE TABLE                                    TSO
*                                                                   TSO
*        On exit:                                                   TSO
*          R15 contains return code (always zero)                   TSO
         SPACE 3                                                    TSO
TRANSLAT ENTER ,                                                    TSO
         LTR   R3,R3         ANYTHING TO DO?                        TSO
         BNP   TRANSRET      NO, QUIT                               TSO
         ALR   R2,R3         END OF SOURCE                          TSO
TRLOOP   LR    R1,R2                                                TSO
         SR    R1,R3         PTR TO REMAINING BYTES                 TSO
         BCTR  R3,0          COUNT FOR EX                           TSO
         EX    R3,TREX       TRANSLATE THE INPUT SEGMENT            TSO
         N     R3,=F'-256'   REMOVE COUNT DONE                      TSO
         BNZ   TRLOOP        LOOP THRU SOURCE                       TSO
TRANSRET SR    R15,R15       DONE, SET RC=0                         TSO
         RET   ,                                                    TSO
TREX     TR    0(*-*,R1),0(R4)                                      TSO
         EXIT                                                       TSO
         TITLE '(PARMS) Parameters for KERMIT-TSO'                  TSO
PARMS    CSECT                         GLOBAL DATA LIST
         PUSH  PRINT                                                TSO
         PRINT NOGEN                                                TSO
S1ORDS   DS        0D                  Transparent R/W [12 start]
         DC        X'F1F0',AL1(SBA),X'5D7F',AL1(SBA),X'0001'        TSO
S1ORDSL  EQU       *-S1ORDS            [12 end]
*
S1FLAGS  DC        X'00'               S/1 flags     [12 end]
*
LBUFSPC  DC    A((2*LDSKBUF)+(5*LPKT)+S1ORDSL) SPACE FOR BUFFERS    TSO
RPTGCNT  DC    H'0'               RPACK TGET COUNTER                SEB
RPTGSTOP DC    H'2'               STOP AFTER THIS # PASSES THR TGET SEB
CMDLEN   DC    H'0'               KERMIT COMMAND LENGTH             TSO
LSDAT    DS        F                   SEND PACKET SIZE
LRDAT    DS        F                   RECEIVE PACKET SIZE
MORENC   DS        F                   Encode refill routine [22]
MORDEC   DS        F                   Deocde dump routine [22]
FLAGS    DC        X'00'               USE TO TEST OUR FLAGS
LFLAGS   DC        X'00'               For local settings [12]
SRFLAGS  DC    X'00'              SEND/RECEIVE FLAGS                TSO
TYPFIL   DS    X                  TYPE OF FILE (T,B,or V)           AJR
NAMELN   DC    H'0'               LENGTH OF UNPREFIXED FILE NAME    TSO
NAME     DC    CL44' '            UNPREFIXED SEND FILE NAME         TSO
INPUTLN  DC    F'0'                                                 TSO
INPUT    DC    CL130' '           INPUT BUFFER                      TSO
ABUF     DS    A                  ADDR OF DISK INPUT BUFFER         TSO
ARBUF    DS    A                  ADDR OF DISK OUTPUT BUFFER        TSO
ALOGBUF  DS    A                  ADDR OF LOG BUFFER                TSO
ASDAT    DS    A                  ADDR OF TEMP SEND DATA BUFFER     TSO
ARDAT    DS    A                  ADDR OF TEMP RECEIVE DATA BUFFER  TSO
ASNDPKT  DS    A                  ADDR OF SEND DATA BUFFER          TSO
ASND7171 DS    A                  ADDR OF 7171 SBA AND BUFFER       TSO
LSNDPKT  DS    F                  LENGTH OF SEND DATA BUFFER        TSO
ARECPKT  DS    A                  ADDR OF RECEIVE DATA BUFFER       TSO
LRECPKT  DS    F                  LENGTH OF RECEIVE DATA BUFFER     TSO
RCVPKL   DS    F                  LENGTH OF PACKET READ FROM MICRO  TSO
PROMSG   DC    C'Kermit-TSO  Version 2.20  (ASM &SYSDATE)'          TSO
FILMSG1  DC        C'FILE-type is Text.'                     [  ]   SEB
FILMSG2  DC        C'FILE-type is Binary.'                   [  ]   SEB
FILMSG3  DC        C'FILE-type is V-Binary.'                 [  ]   AJR
DEBMSG1  DC        C'DEBUG mode is Off.'                     [  ]   SEB
DEBMSG2  DC        C'DEBUG mode is On.'                      [  ]   SEB
SERMSG1  DC    C'IBM7171/SERIES1 mode is Off.'                      SEB
SERMSG2  DC    C'IBM7171/SERIES1 mode is On.'                       SEB
WARMSG1  DC        C'WARNING is Off.'                        [  ]   SEB
WARMSG2  DC        C'WARNING is On.'                         [  ]   SEB
TABMSG1  DC    C'TAB expansion is Off.'                             AJR
TABMSG2  DC    C'TAB expansion is On.'                              AJR
HEADMSG1 DC    C'IBM 7171/Series-1 block HEADER is On'              SEB
HEADMSG2 DC    C'IBM 7171/Series-1 block HEADER is Off'             SEB
FSENT    DS    CL176              TABLE OF FILES SENT SO FAR        TSO
CONCPTR  DC    A(CONCTABL)        Pointer to next entry in table    TSO
CONCTXT  DC    X'0001'            Concatenation text unit           TSO
CONCCNT  DC    X'0000'            Count of entries on CONCTABL      TSO
CONCTABL DS    CL64               Table of TAKE files      [  ]     TSO
CONCFLAG DC    X'00'              Concatenation flags               TSO
CONCON   EQU   X'80'              Data sets are concatenated        TSO
WORKAREA DS    CL265              Work area                         TSO
DATASET  CAMLST NAME,FILNAM,,WORKAREA                               TSO
SPKNUM   DC        F'0'                SEND PACKET NUMBER [13]
RPKNUM   DC        F'0'                RECEIVE PACKET NUMBER [13]
NUMTRY   DC        F'0'                TRIAL COUNTER FOR TRANSFERS
OLDTRY   DS        F                   COUNTER FOR PREVIOUS PACKET
NFSENT   DC        F'0'                NUMBER OF FILES SENT
STORLOC  DS        F                   POINTER TO EXTRA STORAGE
RECL     DS        F                   RECORD LEN (IF RECFM = V)
RPSIZ    DC    A(SPMAX)           MAX RECEIVE PACKET SIZE           TSO
SPSIZ    DC    A(SPDEF)           SEND PACKET SIZE                  TSO
XLFCT    DC    A(SPMAXF)          EXTENDED PACKET SIZE BASE         TSO
MAXTRY   DC        F'5'                NO. OF TIMES TO RETRY PACKET
IMXTRY   DC        F'16'               NO. OF INITIAL TRIALS ALLOWED
DEL      DC        F'127'              OCTAL 177 (DELETE CHAR)
ZERO     DC        F'0'
ONE      DC        F'1'
TWO      DC        F'2'
SPACE    DC        F'32'               ASCII SPACE
O1H      DC        F'64'               OCTAL 100
O2H      DC        F'128'              OCTAL 200
MOD64    DC    F'63'                                                TSO
FF       DC    X'000000FF'                                          TSO
DELAY    DS    F                  SEND COMMAND DELAY (100THS SEC)   TSO
CPPLADDR DS    A                  CPPL address                      TSO
OLD      DS    0F                 OLD for IKJPTGT services          TSO
OLDSEG   DS    F                  Number of message segments        TSO
OLDBUF1  DS    F                  Address of 1st message seg        TSO
OLDBUF2  DS    F                  Address of 2nd message seg        TSO
OLDBUF3  DS    F                  Address of 3rd message seg        TSO
         SPACE 1                                                    TSO
NWOFFSET DS    F                  NEW OFFSET FOR COMMAND BUFFER     TSO
LGOFFCMD DS    0F
         DC    H'22',H'7',C'LOGOFF DISCONNECT '                     TSO
PRFXDFPB DS    0F                 DFPB                              TSO
         DC    AL1(4)             ENTRY CODE                        TSO
         DC    AL3(*-*)           POINTER TO LENGTH AND DSNAME      TSO
         DC    X'20'              PREFIX USERID                     TSO
         DC    AL3(*-*)           PSCB ADDRESS                      TSO
         DC    2A(0)                                                TSO
         DC    A(*-*)             POINTER TO PASSWORD               TSO
PRFXDFPL DC    4F'0'              DFPL                              TSO
ALLOCCB  DC    XL12'00'           DATA SET ALLOCATION CONTROL BLOCK TSO
IOPLAREA DC    4F'0'              IOPL                              TSO
ATCHCPPL DC    4F'0'              ATTACH CPPL AREA                  TSO
CSPLAREA DC    6F'0'              CSPL                              TSO
PPLAREA  DC    7F'0'              PPL                               TSO
CPECB    DC    F'0'               GETLINE/PUTLINE/PUTGET ECB        TSO
ATCHECB  DC    F'0'               ATTACH ECB                        TSO
ATCHTCB  DC    F'0'               ATTACH TCB ADDRESS                TSO
PDLADDR  DC    A(0)               ADDRESS OF PDL                    TSO
PUTLBUF  DS    0F                 PUTLINE buffer                    TSO
PUTLBLEN DC    H'0'               Length of PUTLINE buffer          TSO
         DC    H'0'               Offset                            TSO
PUTLTEXT DC    CL140' '           Text area of PUTLINE buffer       TSO
         PRINT GEN                                                  TSO
MAXTABS  DC    H'&NUMTABS'        MAXIMUM TAB SETTINGS              TSO
TABCOUNT DC    H'0'               CURRENT COUNT OF TABS             TSO
TABSWI   DC    X'00'              ON/OFF SWITCH FOR TABS            TSO
TABTBL   DC    XL&NUMTABS.'00'    TAB SETTINGS                      TSO
DFLTTABS NUMTABS ,                                                  TSO
         PRINT NOGEN                                                TSO
INBFPT   DC        F'0'                Input buffer pointer
OUTBFPT  DC        F'0'                Output buffer pointer
PAR      DS        F                   PARITY OF INCOMING CHARACTER [1]
CMDBUF   DS    A                  Address of command buffer         TSO
READMOD  DC    X'F6'              327x READ MODIFIED op code        TSO
EXTFLG   DS        X                   Exit flag [11]
SQUOTE   DS        X                   Micro's quote char
RQUOTE   DS        X                   QUOTE CHAR WE'LL SEND
EBQUOT   DS        X                   8-BIT QUOTING CHAR [1]
ORIG8Q   DS        X                   ORIG 8-BIT QUOTE CHAR [1]
STIME    DS        X                   Send timeout [5]
RTIME    DS        X                   Receive timeout [5]
SPAD     DS        X                   Send padding [5]
RPAD     DS        X                   Receive padding [5]
SPADCH   DS        X                   Send pad char [5]
RPADCH   DS        X                   Receive pad char [5]
CXZ      DS        X                   Abort send/rec file(s) [16]
TMP      DS        X
RCAPA    DC    X'0'               CAPABILITIES OF MICRO             TSO
SCAPA    DC    X'0'               CAPABILITIES I HAVE (NONE)        TSO
LONGP    EQU   X'02'              LONGP BIT IN CAPAS FLAGS          TSO
MORCAPAS EQU   X'01'              MORE CAPAS BYTES EXIST            TSO
TEMP     DS        F                   TEMPORARY SPACE
         DS        0D
PKVAR    DS        D                   USE FOR PICKING UP INTEGER
         DS        0D
CVDDBLWD DC    D'0'               DOUBLEWORD WORK AREA              TSO
DCBEXITS DC    X'91',AL3(DCBABEND)  DCB ABEND exit                  TSO
LOGEXITS DC    X'91',AL3(LOGABEND)  DCB ABEND exit for log file     TSO
RPMODFI  DC    H'0'               MODIFICATION VALUE                TSO
FILNAMLN DC    H'0'               LENGTH OF SEND/RECEIVE FILE NAME  TSO
FILNAM   DC    CL44' '            SEND/REC FILENAME                 TSO
MBRNAMLN DC    H'0'               LENGTH OF MEMBER NAME             TSO
MBRNAM   DC    CL8' '             MEMBER NAME                       TSO
TAKEDSNL DC    H'7'               Length of user TAKE file name     TSO
TAKEDSN  DC    CL44'KERMINI'      Name of user TAKE file            TSO
SYSTAKLN DC    0H'0',AL2(L'SYSTAK) Length of system TAKE file name  TSO
SYSTAK   DC    C'SYS1.KERMIT.INI'     SYSTEM TAKE FILE NAME     JWM TSO
SYSLOGLN DC    H'7'               Length of system DEBUG file name  TSO
SYSLOG   DC    CL44'KERMLOG'      System DEBUG file name            TSO
TAKEDCB  DCB   MACRF=GM,DSORG=PS,EODAD=TAKEEOF,EXLST=DCBEXITS       TSO
SENDRCV  DCB   MACRF=(GM,PM),DSORG=PS,EXLST=DCBEXITS                TSO
PDSCKDCB DCB   MACRF=R,DSORG=PO                                     TSO
LOGDCB   DCB   MACRF=PM,DSORG=PS,EXLST=LOGEXITS,RECFM=VB,           TSO+
               BLKSIZE=&LOGBLK,LRECL=&LOGRECL                       TSO
STATE    DS        C                   OUR CURRENT STATE
DFM      DC        CL2'A1'             DEFAULT FILEMODE
FM       DS        CL2                 FILEMODE USER WANTS
CHKLEN   DS        X                   Checksum length [4]
CURCHK   DS        X                   Store chksum length here [8]
CHKSET   DS        X                   SET by user [8]
RPTQ     DS        X                   Repeat prefix [4]
ORIGQ    DS        X                   Original repeat prefix [7]
RPTVAL   DS        X                   Character to be repeated [7]
RPTCT    DS        X                   No. of times is repeated [7]
REOL     DS        X                   EOL CHAR I NEED (CR)
SEOL     DS        X                   EOL I'LL SEND
BLKSIZE  DS    H                  BLKSIZE PROGRAM WILL USE          TSO
LRECL    DS    H                  LRECL PROGRAM WILL USE            TSO
PRIME    DS    H                  PRIMARY ALLOCATION PGM WILL USE   TSO
SECOND   DS    H                  SECONDARY ALLOCATION PGM WILL USE TSO
DIRCTY   DS    H                  N0. DIRECTORY BLOCKS FOR PDS      TSO
RFM      DS        C                   RECFM PROGRAM WILL USE
PREV     DS        C                   PREVIOUS CHAR REC (IN PTCHR)
SCRSIZE  DS    F                  NUM LINES ON SCREEN               TSO
LINESIZE DS    F                  SAVE USER'S CONSOLE LINESIZE      TSO
MAXDAT   DS        F                   Max packet size for send [4]
MAXOUT   DS        F                   Max output buffer [6]
ERRNUM   DS        X                   ERROR NUMBER,IN CASE WE DIE
OLDERR   DS        X                   ERROR OF PREVIOUS EXECUTION
STYPE    DS        C                   TYPE OF PACKET SENT
RTYPE    DS        C                   TYPE OF PACKET RECEIVED
ZEROS    DC    8F'0'              ZEROS FOR ZEROING                 TSO
BLANKS   DC    CL140' '           BLANKS FOR BLANKING               TSO
         EJECT                                                      TSO
* This is the ASCII TO EBCDIC (ATOE) Translate Table used in this   AJR
*     version of Kermit for everything EXCEPT IBM ACF/NCP.  It is   AJR
*     in complete accordance with the Translate Table published by  AJR
*     Columbia U. in the "KERMIT PROTOCOL MANUAL"  Sixth Edition.   AJR
*                    -0-1-2-3-4-5-6-7-8-9-A-B-C-D-E-F               AJR
ATOE     DC        X'00010203372D2E2F1605250B0C0D0E0F'    0-        AJR
         DC        X'101112133C3D322618193F271C1D1E1F'    1-        AJR
         DC        X'405A7F7B5B6C507D4D5D5C4E6B604B61'    2-        AJR
         DC        X'F0F1F2F3F4F5F6F7F8F97A5E4C7E6E6F'    3-        AJR
         DC        X'7CC1C2C3C4C5C6C7C8C9D1D2D3D4D5D6'    4-        AJR
         DC        X'D7D8D9E2E3E4E5E6E7E8E9ADE0BD5F6D'    5-        AJR
         DC        X'79818283848586878889919293949596'    6-        AJR
         DC        X'979899A2A3A4A5A6A7A8A9C04FD0A107'    7-        AJR
         DC        X'00010203372D2E2F1605250B0C0D0E0F'    8-        AJR
         DC        X'101112133C3D322618193F271C1D1E1F'    9-        AJR
         DC        X'405A7F7B5B6C507D4D5D5C4E6B604B61'    A-        AJR
         DC        X'F0F1F2F3F4F5F6F7F8F97A5E4C7E6E6F'    B-        AJR
         DC        X'7CC1C2C3C4C5C6C7C8C9D1D2D3D4D5D6'    C-        AJR
         DC        X'D7D8D9E2E3E4E5E6E7E8E9ADE0BD5F6D'    D-        AJR
         DC        X'79818283848586878889919293949596'    E-        AJR
         DC        X'979899A2A3A4A5A6A7A8A9C04FD0A107'    F-        AJR
         SPACE 1                                                    AJR
* This is the EBCDIC TO ASCII (ETOA) Translate Table used in this   AJR
*     version of Kermit for everything EXCEPT IBM ACF/NCP.  It is   AJR
*     in complete accordance with the Translate Table published by  AJR
*     Columbia U. in the "KERMIT PROTOCOL MANUAL"  Sixth Edition.   AJR
*     Characters not representable in ASCII are replaced by a NULL. AJR
*                    -0-1-2-3-4-5-6-7-8-9-A-B-C-D-E-F               AJR
ETOA     DC        X'000102030009007F0000000B0C0D0E0F'    0-        AJR
         DC        X'1011121300000800181900001C1D1E1F'    1-        AJR
         DC        X'00000000000A171B0000000000050607'    2-        AJR
         DC        X'0000160000000004000000001415001A'    3-        AJR
         DC        X'20000000000000000000002E3C282B7C'    4-        AJR
         DC        X'2600000000000000000021242A293B5E'    5-        AJR
         DC        X'2D2F00000000000000007C2C255F3E3F'    6-        AJR
         DC        X'000000000000000000603A2340273D22'    7-        AJR
         DC        X'00616263646566676869007B00000000'    8-        AJR
         DC        X'006A6B6C6D6E6F707172007D00000000'    9-        AJR
         DC        X'007E737475767778797A0000005B0000'    A-        AJR
         DC        X'000000000000000000000000005D0000'    B-        AJR
         DC        X'7B414243444546474849000000000000'    C-        AJR
         DC        X'7D4A4B4C4D4E4F505152000000000000'    D-        AJR
         DC        X'5C00535455565758595A000000000000'    E-        AJR
         DC        X'303132333435363738397C0000000000'    F-        AJR
         SPACE 1                                                    AJR
* And now sports fans...                                            AJR
* We have to be able to use a DIFFERENT translate table for NCP to  AJR
* handle IBM's APARS that broke NCP's translate tables...           AJR
ATOENCPA DC A(ATOENCP)                                              AJR
ETOANCPA DC A(ETOANCP)                                              AJR
         SPACE 1                                                    AJR
* Table to convert EBCDIC text to upper case. [15]                  AJR
*                    -0-1-2-3-4-5-6-7-8-9-A-B-C-D-E-F               AJR
UPC      DC        X'000102030405060708090A0B0C0D0E0F'    0-        AJR
         DC        X'101112131415161718191A1B1C1D1E1F'    1-        AJR
         DC        X'202122232425262728292A2B2C2D2E2F'    2-        AJR
         DC        X'303132333435363738393A3B3C3D3E3F'    3-        AJR
         DC        X'404142434445464748494A4B4C4D4E4F'    4-        AJR
         DC        X'505152535455565758595A5B5C5D5E5F'    5-        AJR
         DC        X'606162636465666768696A6B6C6D6E6F'    6-        AJR
         DC        X'707172737475767778797A7B7C7D7E7F'    7-        AJR
         DC        X'80C1C2C3C4C5C6C7C8C98A8B8C8D8E8F'    8-        AJR
         DC        X'90D1D2D3D4D5D6D7D8D99A9B9C9D9E9F'    9-        AJR
         DC        X'A0A1E2E3E4E5E6E7E8E9AAABACADAEAF'    A-        AJR
         DC        X'B0B1B2B3B4B5B6B7B8B9BABBBCBDBEBF'    B-        AJR
         DC        X'C0C1C2C3C4C5C6C7C8C9CACBCCCDCECF'    C-        AJR
         DC        X'D0D1D2D3D4D5D6D7D8D9DADBDCDDDEDF'    D-        AJR
         DC        X'E0E1E2E3E4E5E6E7E8E9EAEBECEDEEEF'    E-        AJR
         DC        X'F0F1F2F3F4F5F6F7F8F9FAFBFCFDFEFF'    F-        AJR
         SPACE 1                                                    TSO
*        TRANSLATE TABLE TO TURN OFF X'80' BIT IN EACH BYTE         TSO
OFF80    DC    128AL1(*-OFF80)                                      TSO
         DC    128AL1(*-OFF80-128)                                  TSO
         SPACE 1                                                    TSO
*        TRANSLATE TABLE TO TURN ON X'80' BIT IN EACH BYTE          TSO
ON80     DC    128AL1(*-ON80+128)                                   TSO
         DC    128AL1(*-ON80)                                       TSO
         SPACE 1                                                    TSO
* Table to use for CRC calculation
CRCTAB   DC        X'0000'
         DC        X'1081'
         DC        X'2102'
         DC        X'3183'
         DC        X'4204'
         DC        X'5285'
         DC        X'6306'
         DC        X'7387'
         DC        X'8408'
         DC        X'9489'
         DC        X'A50A'
         DC        X'B58B'
         DC        X'C60C'
         DC        X'D68D'
         DC        X'E70E'
         DC        X'F78F'
*
CRCTB2   DC        X'0000'
         DC        X'1189'
         DC        X'2312'
         DC        X'329B'
         DC        X'4624'
         DC        X'57AD'
         DC        X'6536'
         DC        X'74BF'
         DC        X'8C48'
         DC        X'9DC1'
         DC        X'AF5A'
         DC        X'BED3'
         DC        X'CA6C'
         DC        X'DBE5'
         DC        X'E97E'
         DC        X'F8F7'
*
* TABLE OF ERROR MESSAGES (IN CASE WE ABORT)
ERRTAB   DC    CL28'Bad send-packet size'               ERR MSG #0  TSO
         DC    CL28'Bad message number'                 ERR MSG #1  TSO
         DC    CL28'Unrecognized state'                 ERR MSG #2  TSO
         DC    CL28'No SOH encountered'                 ERR MSG #3  TSO
         DC    CL28'Bad character count'                ERR MSG #4  TSO
         DC    CL28'Bad checksum'                       ERR MSG #5  TSO
         DC    CL28'File or disk is full'               ERR MSG #6  TSO
         DC    CL28'Invalid packet type'                ERR MSG #7  TSO
         DC    CL28'Lost a packet'                      ERR MSG #8  TSO
         DC    CL28'Micro sent a NAK'                   ERR MSG #9  TSO
         DC    CL28'Micro aborted'                      ERR MSG #10 TSO
         DC    CL28'Invalid file name'                  ERR MSG #11 TSO
         DC    CL28'Invalid lrecl'                      ERR MSG #12 TSO
         DC    CL28'Permanent I/O error'                ERR MSG #13 TSO
         DC    CL28'Incompat file type'                 ERR MSG #14 TSO
         DC    CL28'Recfm conflict'                     ERR MSG #15 TSO
         DC    CL28'Err allocating space'               ERR MSG #16 TSO
         DC    CL28'Series/1 I/O error'                 ERR MSG #17 TSO
         DC    CL28'Unknown generic cmd'                ERR MSG #18 TSO
         DC    CL28'Unknown server cmd'                 ERR MSG #19 TSO
         DC    CL28'Cannot reassign file'               ERR MSG #20 TSO
         DC    CL28'File not found'                     ERR MSG #21 TSO
         DC    CL28'Send cancelled'                     ERR MSG #22 TSO
         DC    CL28'Receive cancelled'                  ERR MSG #23 TSO
         DC    CL28'Cannot create file'                 ERR MSG #24 TSO
         DC    CL28'Error writing file'                 ERR MSG #25 TSO
         DC    CL28'Error reading packet'               ERR MSG #26 TSO
         DC    CL28'Cannot prefix file'                 ERR MSG #27 TSO
         DC    CL28'Cannot allocate file'               ERR MSG #28 TSO
         DC    CL28'Cannot open file'                   ERR MSG #29 TSO
         DC    CL28'Unsupportd file type'               ERR MSG #30 TSO
         DC    CL28'Unknown member'                     ERR MSG #31 TSO
         DC    CL28'Log file is full'                   ERR MSG #32 TSO
         DC    CL28'V LRECL too small'                  ERR MSG #33 AJR
         DC    CL28'Record > BLKSIZE'                   ERR MSG #34 AJR
         DC    CL28'Bad record length'                  ERR MSG #35 AJR
         DC    CL28'BLKSIZE > Tracksize'                ERR MSG #36 AJR
         DC    CL28'Cannot overwrite quoted file'       ERR MSG #37 TSO
S1ERRNUM EQU       17                  Makes life easier [12]
         LTORG
         EJECT                                                      AJR
* These are the Translate Tables used for IBM ACF/NCP ONLY.         AJR
* They are in complete accordance with the Translate Table          AJR
* published by Columbia University in the "KERMIT PROTOCOL MANUAL"  AJR
* Sixth Edition, as well as tghe "IBM SYSTEM/370 REFERENCE SUMMARY" AJR
* GX20-1850, with the exception of the four characters that IBM     AJR
* hosed in ACF/NCP.  This is documented in the "ACF/NCP PROGRAM     AJR
* REFERENCE SUMMARY", in the Line Character Codes section under     AJR
* USASCII Character Code for TWX.                                   AJR
         SPACE 1                                                    AJR
* The four characters in dispute are:                               AJR
*         IBM               IBM                  IBM                AJR
*        ASCII              NCP                 EBCDIC              AJR
*     (& Kermit's)         EBCDIC             (& Kermit's)          AJR
*        -----             ------              ----------           AJR
*        X'21'              X'4F'                X'5A'              AJR
*        X'5B'              X'4A'                X'AD'              AJR
*        X'5D'              X'5A'                X'BD'              AJR
*        X'7C'              X'6A'                X'4F'              AJR
         SPACE 1                                                    AJR
* ASCII to EBCDIC Translate Table for NCP                           AJR
*                    -0-1-2-3-4-5-6-7-8-9-A-B-C-D-E-F               AJR
ATOENCP  DC        X'00010203372D2E2F1605250B0C0D0E0F'    0-        AJR
         DC        X'101112133C3D322618193F271C1D1E1F'    1-        AJR
         AIF   ('&LINMODE' EQ 'NOTNCP').ATOEN1                      TSO
         DC        X'404F7F7B5B6C507D4D5D5C4E6B604B61'    2-        AJR
         AGO   .ATOEN1A                                             TSO
.ATOEN1  ANOP                                                       TSO
         DC        X'405A7F7B5B6C507D4D5D5C4E6B604B61'    2-        AJR
.ATOEN1A ANOP                                                       TSO
         DC        X'F0F1F2F3F4F5F6F7F8F97A5E4C7E6E6F'    3-        AJR
         DC        X'7CC1C2C3C4C5C6C7C8C9D1D2D3D4D5D6'    4-        AJR
         AIF   ('&LINMODE' EQ 'NOTNCP').ATOEN2                      TSO
         DC        X'D7D8D9E2E3E4E5E6E7E8E94AE05A5F6D'    5-        AJR
         AGO   .ATOEN2A                                             TSO
.ATOEN2  ANOP                                                       TSO
         DC        X'D7D8D9E2E3E4E5E6E7E8E9ADE0BD5F6D'    5-        AJR
.ATOEN2A ANOP                                                       TSO
         DC        X'79818283848586878889919293949596'    6-        AJR
         AIF   ('&LINMODE' EQ 'NOTNCP').ATOEN3                      TSO
         DC        X'979899A2A3A4A5A6A7A8A9C06AD0A107'    7-        AJR
         AGO   .ATOEN3A                                             TSO
.ATOEN3  ANOP                                                       TSO
         DC        X'979899A2A3A4A5A6A7A8A9C04FD0A107'    7-        AJR
.ATOEN3A ANOP                                                       TSO
         DC        X'00010203372D2E2F1605250B0C0D0E0F'    8-        AJR
         DC        X'101112133C3D322618193F271C1D1E1F'    9-        AJR
         DC        X'405A7F7B5B6C507D4D5D5C4E6B604B61'    A-        AJR
         DC        X'F0F1F2F3F4F5F6F7F8F97A5E4C7E6E6F'    B-        AJR
         DC        X'7CC1C2C3C4C5C6C7C8C9D1D2D3D4D5D6'    C-        AJR
         DC        X'D7D8D9E2E3E4E5E6E7E8E9ADE0BD5F6D'    D-        AJR
         DC        X'79818283848586878889919293949596'    E-        AJR
         DC        X'979899A2A3A4A5A6A7A8A9C04FD0A107'    F-        AJR
         SPACE 1                                                    AJR
* EBCDIC to ASCII Translate Table for NCP                           AJR
* Characters not representable in ASCII are replaced by a NULL.     AJR
*                    -0-1-2-3-4-5-6-7-8-9-A-B-C-D-E-F               AJR
ETOANCP  DC        X'000102030009007F0000000B0C0D0E0F'    0-        AJR
         DC        X'1011121300000800181900001C1D1E1F'    1-        AJR
         DC        X'00000000000A171B0000000000050607'    2-        AJR
         DC        X'0000160000000004000000001415001A'    3-        AJR
         AIF   ('&LINMODE' EQ 'NOTNCP').ETOAN1                      TSO
         DC        X'200000000000000000005B2E3C282B21'    4-        AJR
         DC        X'260000000000000000005D242A293B5E'    5-        AJR
         AGO   .ETOAN1A                                             TSO
.ETOAN1  ANOP                                                       TSO
         DC        X'20000000000000000000002E3C282B7C'    4-        AJR
         DC        X'2600000000000000000021242A293B5E'    5-        AJR
.ETOAN1A ANOP                                                       TSO
         DC        X'2D2F00000000000000007C2C255F3E3F'    6-        AJR
         DC        X'000000000000000000603A2340273D22'    7-        AJR
         DC        X'00616263646566676869007B00000000'    8-        AJR
         DC        X'006A6B6C6D6E6F707172007D00000000'    9-        AJR
         DC        X'007E737475767778797A0000005B0000'    A-        AJR
         DC        X'000000000000000000000000005D0000'    B-        AJR
         DC        X'7B414243444546474849000000000000'    C-        AJR
         DC        X'7D4A4B4C4D4E4F505152000000000000'    D-        AJR
         DC        X'5C00535455565758595A000000000000'    E-        AJR
         DC        X'303132333435363738397C0000000000'    F-        AJR
         SPACE 1                                                    AJR
         POP   PRINT                                                TSO
         TITLE '(DOHELP) HELP command processor'                    TSO
*        This routine invokes the normal TSO help command to        TSO
*        display the help information for KERMIT.                   TSO
*                                                                   TSO
*        On Entry:                                                  TSO
*          R6 -> Command Buffer                                     TSO
         SPACE 3                                                    TSO
DOHELP   ENTER ,                                                    TSO
         LH    R2,0(,R1)          GET LENGTH OF COMMAND BUFFER      TSO
         LR    R3,R2              GET WORKING COPY OF LENGTH        TSO
         S     R3,=F'5'           ADJUST FOR CMD BUF PREFIX & EX    TSO
         EX    R3,HELPUPC         UPCASE THE TEXT IN COMMAND BUFFER TSO
*HELPUPC OC    4(*-*,R1),BLANKS                                     TSO
         SH    R2,CMDLEN          ADJUST ORIG LENGTH FOR CMD LEN    TSO
         BNP   HELPKCMD           IF <= 0 THEN THERE IS NO OPERAND  TSO
         LH    R2,2(,R1)          GET OFFSET TO OPERAND             TSO
         LA    R2,4(R2,R1)        POINT TO THE OPERAND              TSO
         CLI   0(R2),C' '         ARE THERE JUST BLANKS?            TSO
         BE    HELPKCMD           YES, NO OPERANDS                  TSO
         LA    R3,HELPCMDS        POINT TO THE COMMAND TABLE        TSO
         SR    R4,R4              CLEAR FOR FOLLOWING ICM           TSO
HELPLOP1 CLI   0(R3),X'FF'        END OF TABLE?                     TSO
         BE    HELPNCMD           YES, NOT A KERMIT COMMAND         TSO
         ICM   R4,1,0(R3)         GET LENGTH TO COMPARE             TSO
         BCTR  R4,0               ADJUST FOR EX                     TSO
         EX    R4,HELPCMP         IS COMMAND NAME A KERMIT COMMAND? TSO
*HELPCMP CLC   1(*-*,R3),0(R2)                                      TSO
         BE    HELPKCMD           YES                               TSO
         LA    R3,9(,R3)          POINT TO NEXT TABLE POSITION      TSO
         B     HELPLOP1           CONTINUE SCANNING TABLE           TSO
         SPACE 1                                                    TSO
HELPKCMD L     R2,CPPLADDR        GET ADDRESS OF KERMIT CPPL        TSO
         MVC   ATCHCPPL(16),0(R2) INITIALIZE ATTACH CPPL            TSO
         LA    R2,ATCHCPPL        GET ADDRESS OF ATTACH CPPL        TSO
         USING CPPL,R2            MAKE ATTACH CPPL ADDRESSABLE      TSO
         ST    R1,CPPLCBUF        PUT THE COMMAND BUFFER INTO CPPL  TSO
         L     R3,CPPLECT         GET THE ECT ADDRESS               TSO
         USING ECT,R3             MAKE IT ADDRESSABLE               TSO
         MVC   ECTSCMD,=CL8'HELP' SET UP ECT SUBCOMMAND FIELD       TSO
         LA    R1,ATCHCPPL        GET ADDRESS OF ATTACH CPPL        TSO
         MVI   ATCHECB,0          CLEAR THE ECB                     TSO
         ATTACH ECB=ATCHECB,EP=HELP,SHSPV=78,SZERO=NO               TSO
         LTR   R15,R15            WAS ATTACH SUCCESSFUL?            TSO
         BNZ   HELPATER           NO, PRINT ERROR MESSAGE           TSO
         ST    R1,ATCHTCB         SAVE TCB ADDRESS                  TSO
         WAIT  ECB=ATCHECB        WAIT FOR SUBTASK TO FINISH        TSO
         DETACH ATCHTCB           DETACH THE SUBTASK                TSO
         B     HELPRTN            RETURN TO CALLER                  TSO
         SPACE 1                                                    TSO
HELPATER WRTERM 'Error occurred when subtask was attached'          TSO
         B     HELPRTN            RETURN TO CALLER                  TSO
         SPACE 1                                                    TSO
HELPNCMD WRTERM 'Specified HELP operand is not a KERMIT subcommand' TSO
HELPRTN  RET   ,                                                    TSO
         SPACE 1                                                    TSO
HELPCMP  CLC   1(*-*,R3),0(R2)                                      TSO
HELPUPC  OC    4(*-*,R1),BLANKS                                     TSO
         SPACE 1                                                    TSO
HELPCMDS DS    0F                                                   TSO
         DC    X'1',CL8'E'        EXIT                              TSO
         DC    X'1',CL8'Q'        QUIT                              TSO
         DC    X'3',CL8'HEL'      HELP                              TSO
         DC    X'3',CL8'SET'      SET                               TSO
         DC    X'3',CL8'STA'      STATUS                            TSO
         DC    X'3',CL8'SHO'      SHOW                              TSO
         DC    X'3',CL8'TDU'      TDUMP                             TSO
         DC    X'3',CL8'SER'      SERVER                            TSO
         DC    X'3',CL8'TAK'      TAKE                              TSO
         DC    X'3',CL8'REC'      RECEIVE                           TSO
         DC    X'3',CL8'SEN'      SEND                              TSO
         DC    X'FFFFFFFFFF'      END OF COMMAND TABLE              TSO
         EXIT                                                       TSO
         DROP  R2                 DROP CPPL ADDRESS                 TSO
         DROP  R3                 DROP ECT ADDRESS                  TSO
         TITLE '(SNDCMD) SEND command processor'                    TSO
*        This routine processes the SEND command.  It parses the    TSO
*        operands in the command buffer, allocates the send file    TSO
*        and opens it.  It then passes control to the send          TSO
*        processor to perform the actual send function.             TSO
*                                                                   TSO
*        On Entry:                                                  TSO
*          R1 -> Command Buffer                                     TSO
*                                                                   TSO
*        On Exit:                                                   TSO
*          R15 contains a return code                               TSO
*             0  -  Normal send operation                           TSO
*             4  -  Send error                                      TSO
         SPACE 3                                                    TSO
SNDCMD   ENTER ,                                                    TSO
         SETSEMI                  GO INSERT SEMICOLON               TSO
         LA    R10,PPLAREA        POINT TO PARSE PARAMETER LIST     TSO
         USING PPL,R10            MAKE IT ADDRESSABLE               TSO
         ST    R1,PPLCBUF         ADDRESS OF COMMAND BUFFER IN PPL  TSO
         PARSE SNDPARM,ATTN=SNDRTRN,ERR=SNDERRTN                    TSO
         CHECKPDL BAD=SND#@PDL                                      TSO
         USING IKJPARMD,R9        MAKE PDL ADDRESSABLE              TSO
         SPACE 1                                                    TSO
         TM    SNDDSN+6,X'80'     IS DSNAME PRESENT?                TSO
         BNO   SND#@PDL           NO, GIVE ERROR MESSAGE AND RETURN TSO
         LH    R2,SNDDSN+4        GET LENGTH OF DSNAME              TSO
         STH   R2,FILNAMLN        SAVE LENGTH OF FILE NAME          TSO
         STH   R2,NAMELN          AND HERE ALSO                     TSO
         L     R3,SNDDSN          GET ADDRESS OF FILE NAME          TSO
         BCTR  R2,0               ADJUST FOR EX                     TSO
         EX    R2,SNDMVDS         SET UP FILE NAME                  TSO
*SNDMVDS MVC   FILNAM(*-*),0(R3)                                    TSO
         MVC   NAME,FILNAM        SAVE UNPREFIXED FILE NAME         TSO
         SPACE 1                                                    TSO
         XC    MBRNAMLN,MBRNAMLN  CLEAR MEMBER NAME LENGTH          TSO
         TM    SNDDSN+14,X'80'    IS MEMBER NAME PRESENT?           TSO
         BZ    SNDPREFX           NO, GO PREFIX FILE NAME           TSO
         LH    R2,SNDDSN+12       GET LENGTH OF MEMBER NAME         TSO
         STH   R2,MBRNAMLN        SAVE LENGTH                       TSO
         L     R3,SNDDSN+8        GET ADDRESS OF MEMBER NAME        TSO
         BCTR  R2,0               ADJUST FOR EX                     TSO
         EX    R2,SNDMVMB         SET UP MEMBER NAME                TSO
*SNDMVMB MVC   MBRNAM(*-*),0(R3)                                    TSO
         SPACE 1                                                    TSO
SNDPREFX TM    SNDDSN+6,X'40'     IS DSNAME QUOTED?                 TSO
         BZ    SNDPRFX            NO, GO PREFIX THE SUPPLIED FILE   TSO
         LOCATE DATASET           SEE IF DATA SET EXISTS            TSO
         LTR   R15,R15            WAS DATA SET FOUND?               TSO
         BNZ   SNDNFND            NO, GO SAY DATA SET NOT FOUND     TSO
         B     SNDALCDS           YES, GO ALLOCATE THE DATA SET     TSO
         SPACE 1                                                    TSO
SNDPRFX  IKJRLSA PDLADDR          RELEASE THE PDL                   TSO
         XC    PDLADDR,PDLADDR    CLEAR THE PDL ADDRESS             TSO
         LA    R1,FILNAMLN        GET ADDRESS OF LENGTH & FILE NAME TSO
         L     R15,=A(PREFIXDS)   GET ADDRESS OF PREFIX ROUTINE     TSO
         BALR  R14,R15            GO PREFIX THE NAME                TSO
         B     *+4(R15)           BRANCH ON RETURN CODE             TSO
         B     SNDALCDS           0  - OLD DATA SET                 TSO
         B     SNDNFND            4  - NEW DATA SET                 TSO
         B     SND#@PRE           8  - UNABLE TO PREFIX             TSO
         SPACE 1                                                    TSO
*        ALLOCATE THE DATA SET                                      TSO
         SPACE 1                                                    TSO
SNDALCDS LA    R8,ALLOCCB         POINT TO ALLOCATION CONTROL BLOCK TSO
         USING ALCCB,R8           MAKE IT ADDRESSABLE               TSO
         LA    R0,ALCTOLD         INDICATE "OLD" ALLOCATION         TSO
         ST    R0,ALCTYPE         PUT INTO ALCCB                    TSO
         LA    R0,FILNAMLN        GET ADDRESS OF FILE NAME & LENGTH TSO
         ST    R0,ALCDSN          PUT INTO ALCCB                    TSO
         XC    ALCMEMBR,ALCMEMBR  ASSUME NO MEMBER NAME             TSO
         SR    R0,R0              CLEAR FOR ICM                     TSO
         ICM   R0,3,MBRNAMLN      GET LENGTH OF MEMBER NAME         TSO
         BZ    SNDALC             NO, MEMBER NAME; DO ALLOCATE      TSO
         LA    R0,MBRNAMLN        GET ADDRESS OF MEMBER NAME        TSO
         ST    R0,ALCMEMBR        PUT INTO ALCCB                    TSO
SNDALC   LR    R1,R8              PASS ADDRESS OF ALCCB             TSO
         L     R15,=A(ALLOCDSN)   GET ALLOCATE ROUTINE ADDRESS      TSO
         BALR  R14,R15            GO ALLOCATE THE DATA SET          TSO
         B     *+4(R15)           BRANCH ON RETURN CODE             TSO
         B     SNDOPEN            0  -  ALLOCATION SUCCESSFUL       TSO
         B     SNDNFND            4  -  DATA SET NOT FOUND          TSO
         B     SNDALCER           8  -  ALLOCATION ERROR            TSO
         B     SNDINCMP           12 -  INCOMPATIBLE DATA SET TYPE  TSO
         B     SNDUNSUP           16 -  UNSUPPORTED DATA SET TYPE   TSO
         SPACE 1                                                    TSO
SNDINCMP WRTERM 'Incompatible data set type'                        TSO
         B     SNDERRTN                                             TSO
         SPACE 1                                                    TSO
SNDUNSUP WRTERM 'Unsupported data set type'                         TSO
         B     SNDERRTN           GO RETURN ERROR                   TSO
         SPACE 1                                                    TSO
SNDALCER WRTERM 'Error while attempting to allocate SEND data set'  TSO
         B     SNDERRTN           GO RETURN ERROR                   TSO
         SPACE 1                                                    TSO
SNDNFND  WRTERM 'SEND data set not found'                           TSO
         B     SNDERRTN           GO RETURN ERROR                   TSO
         SPACE 1                                                    TSO
*        OPEN THE DATA SET                                          TSO
         SPACE 1                                                    TSO
SNDOPEN  MVC   SENDRCV+40(8),BLANKS  CLEAR DCB DDNAME               TSO
         LR    R2,R0              SAVE LENGTH OF DDNAME             TSO
         BCTR  R2,0               ADJUST FOR EX                     TSO
         EX    R2,SNDMDDN         PUT DDNAME INTO DCB               TSO
*SNDMDDN MVC   SENDRCV+40(*-*),0(R1)                                TSO
         L     R0,=A(INBUFEOD)    GET EODAD ROUTINE ADDRESS         TSO
         STCM  R0,7,SENDRCV+(DCBEODA-IHADCB)  PUT INTO DCB          TSO
         L     R0,=A(INBUF0)      GET ADDRESS OF SYNAD ROUTINE      TSO
         STCM  R0,7,SENDRCV+(DCBSYNA-IHADCB)  PUT INTO DCB          TSO
         OPEN  (SENDRCV,INPUT)    OPEN THE DATA SET FOR INPUT       TSO
         TM    SENDRCV+(DCBOFLGS-IHADCB),DCBOFOPN  OPEN SUCCESSFUL? TSO
         BO    SNDSND             YES, GO PERFORM SEND OPERATION    TSO
         WRTERM 'Unable to open SEND data set.'                     TSO
         UNALLOC DSNAME,ADDR=ALCDSN  UNALLOCATE THE DATA SET        TSO
         B     SNDERRTN           GO RETURN ERROR                   TSO
         SPACE 1                                                    TSO
SNDSND   L     R15,=A(SEND)       GET ADDRESS OF SEND ROUTINE       TSO
         BALR  R14,R15            GO DO SEND OPERATION              TSO
         LR    R5,R15             PRESERVE RETURN CODE              TSO
         CLOSE (SENDRCV)          CLOSE DATA SET                    TSO
         FREEPOOL SENDRCV         FREE THE QSAM BUFFER POOL         TSO
         UNALLOC DSNAME,ADDR=ALCDSN  UNALLOCATE THE DATA SET        TSO
         LTR   R5,R5              SEND FUNCTION DONE OK?            TSO
         BNZ   SNDERRTN           NO, RETURN ERROR                  TSO
         SR    R15,R15            INDICATE NORMAL OPERATION         TSO
         B     SNDRTRN            RETURN TO CALLER                  TSO
         DROP  R8                 DROP ALCCB ADDRESSABILITY         TSO
         SPACE 1                                                    TSO
SND#@PRE WRTERM 'Unable to prefix SEND command file name'           TSO
         B     SNDERRTN           GO RETURN ERROR                   TSO
         SPACE 1                                                    TSO
SND#@PDL WRTERM 'Invalid parameters on the SEND command'            TSO
SNDERRTN LA    R15,4              SET ERROR RETURN CODE             TSO
SNDRTRN  RET   ,                                                    TSO
         SPACE 1                                                    TSO
SNDMVDS  MVC   FILNAM(*-*),0(R3)                                    TSO
SNDMDDN  MVC   SENDRCV+40(*-*),0(R1)                                TSO
SNDMVMB  MVC   MBRNAM(*-*),0(R3)                                    TSO
         DROP  R10                DROP PPL ADDRESSABILITY           TSO
         DROP  R9                 DROP PDL ADDRESSABILITY           TSO
         SPACE 1                                                    TSO
         PRINT NOGEN                                                TSO
SNDPARM  IKJPARM ,                                                  TSO
SNDDSN   IKJPOSIT DSNAME,PROMPT='FILE NAME FOR SEND'                TSO
         IKJENDP ,                                                  TSO
         PRINT GEN                                                  TSO
         SPACE 1                                                    TSO
         EXIT                                                       TSO
         TITLE '(SEND) Perform send function'                       TSO
SEND     ENTER ,
         MVC       EBQUOT(1),ORIG8Q    IF CHANGED IN LAST X-FER [1]
         MVI       CXZ,X'00'           Just in case [16]
         MVI       STATE,C'S'
         SR        R3,R3
         ST        R3,SPKNUM
         ST        R3,NUMTRY
NXTFIL   CLI       CXZ,AZ              Stop file group send [16]
         BE        DIEOK               Yes finish up [16]
         MVI       CXZ,X'00'           In case aborted last file [16]
         LA        R5,FSENT            TABLE W/FILES SENT SO FAR
         LA   R7,176(,R5)         POINT TO END OF TABLE             TSO
         L         R4,NFSENT           HOW MANY SENT SO FAR
FILLOOP  LTR       R4,R4
         BZ        OKSND
         BCTR      R4,0                DECREMENT COUNTER
         CLC  0(44,R5),NAME       THIS FILE SENT ALREADY?           TSO
         BE   DIEOK               YES, ALL THROUGH                  TSO
         LA   R5,44(,R5)          POINT TO NEXT FILE                TSO
         CR        R5,R7
         BNE       FILLOOP
         L         R5,STORLOC          SEARCH HERE NOW
         B         FILLOOP
         SPACE 1                                                    TSO
OKSND    OI   LFLAGS,SENDON       TURN ON SEND FLAGS                TSO
         TM   FLAGS,FLG1          IS THIS THE FIRST FILE?           TSO
         BNO  SLOOP               NO, DON'T WAIT                    TSO
         NI        FLAGS,X'FF'-FLG1    Turn off first file flag [13]
         TM   LFLAGS,SERVON       IN SERVER MODE?                   TSO
         BO        SLOOP               Yes so skip this stuff [13]
         TM   S1FLAGS,ISS1        IS IT SERIES-1/IBM 7171?          TSO
         BZ   SNOT7171            NO                                TSO
         STFSMODE ON,INITIAL=YES,NOEDIT=YES FULL-SCREEN MODE        TSO
         BLOCKLET =C'SEND',4      GO DO BLOCK LETTERS               TSO
         LA   R1,1(,R1)           SKIP ONE LINE FOR NEXT MESSAGE    TSO
         FULLSCR 'Escape to your local KERMIT and enter the RECEIVE com+
               mand',ROW=(1),COLUMN=1                               TSO
         PUTCRSR ROW=21,COLUMN=1  POSITION CURSOR                   TSO
         B     SDELAY             CONTINUE SEND OPERATION           TSO
         SPACE 1                                                    TSO
SNOT7171 L     R3,DELAY           GET DELAY VALUE                   TSO
         SR    R2,R2              CLEAR FOR DIVIDE                  TSO
         D     R2,=F'100'         CONVERT TO SECONDS                TSO
         LINEDIT TEXT='Delay in seconds before sending is .....',   TSO+
               SUB=(DEC,(R3))                                       TSO
         WRTERM 'Escape to your local KERMIT and enter the RECEIVE comm+
               and'                                                 AJR
SDELAY   STIMER WAIT,BINTVL=DELAY                                   TSO
         SPACE 1                                                    TSO
SLOOP    CLI       STATE,C'D'          SEND DATA STATE
         BE        SDATA
         CLI       STATE,C'F'          SEND FILE STATE
         BE        SFILE
         CLI       STATE,C'S'          SEND INIT STATE
         BE        SINIT
         CLI       STATE,C'Z'          END OF FILE STATE
         BE        SEOF
         CLI       STATE,C'B'          SEND BREAK STATE
         BE        SBREAK
         CLI       STATE,C'C'          COMPLETE STATE
         BE        COMPLETE
         CLI       STATE,C'A'          ABORT STATE
         BE        ABORT               ERROR - GO TO ABORT STATE
         MVI       ERRNUM,X'02'        UNRECOGNIZED STATE
         B         ABORT               OTHERWISE, DIE
         SPACE 1                                                    TSO
*        PROCESS SEND INIT STATE                                    TSO
         SPACE 1                                                    TSO
SINIT    CLC       NUMTRY,IMXTRY       SEE IF CAN SEND
         BL        SINIT0              YES WE CAN
         MVI       STATE,C'A'          NOPE, GO INTO ABORT STATE
         B         SLOOP
SINIT0   L         R3,NUMTRY
         LA        R3,1(R3)            INCREMENT TRIAL COUNTER
         ST        R3,NUMTRY
         L         R15,=A(RPAR)        Our paramters to send [5]
         BALR      R14,R15
         ST        R15,LSDAT           Size of packet [5]
         MVI       STYPE,AS            PACKET TYPE = SEND INITIATE
         MVC       CURCHK(1),CHKLEN    Save desired value [8]
         MVI       CHKLEN,X'01'        Init uses 1 char chksum [8]
         L         R15,=A(SPACK)       GET ADDRESS OF ROUTINE 'SPACK'
         BALR      R14,R15             SAVE * AND GO TO SPACK
         CLI       STATE,C'A'
         BE        ABORT
         L         15,=A(RPACK)        GET ADDRESS OF 'RPACK'
         BALR      R14,R15             SAVE * AND GO TO RPACK
         MVC       CHKLEN(1),CURCHK    Restore desired chksum [8]
         CLI       RTYPE,AE            ERROR PACKET?
         BNE       Y1                  NO, THEN MAYBE AN ACK
         MVI       ERRNUM,X'0A'        MICRO DIED
         MVI       STATE,C'A'          AND DIE
         B         SLOOP
Y1       CLI       RTYPE,AY            SEE IF GOT ACK
         BNE       N1                  MAYBE IT'S 'N'
         CLC       SPKNUM,RPKNUM       CHECK MESSAGE NUMBERS
         BE        AOK1
         MVI       ERRNUM,X'08'        PACKET LOST
         B         SLOOP
AOK1     L         R5,LRDAT            Number of pieces of data [5]
         L         R15,=A(SPAR)
         BALR      R14,R15             Read data from other host [5]
         L         R15,=A(PACKLEN)     Get max send packet size [5]
         BALR      R14,R15
NOCHG    MVI       STATE,C'F'          PUT INTO SEND FILE STATE
         XC        NUMTRY,NUMTRY       RESET TO ZERO
         L         R3,SPKNUM
         LA        R3,1(R3)            ADD ONE
         ST        R3,SPKNUM           STORE VALUE INCREMENTED BY 1
         NC        SPKNUM(4),=X'0000003F'   MASK TO GET MOD 64
         B         SLOOP
N1       CLI       RTYPE,AN            SEE IF IT'S 'N'
         BNE       AB1                 IF NOT, DIE
         TM        FLAGS,FLG4          DID MICRO NAK OR I REJECTED?
         BO        SLOOP               LEAVE ERR MSG AS IS IF I DID
         MVI       ERRNUM,X'09'        MICRO NAK'ED
         B         SLOOP
AB1      MVI       STATE,C'A'          ELSE, ABORT
         CLI       ERRNUM,S1ERRNUM     Was it a S/1 I/O error [12]
         BE        SLOOP               Yes just return [12]
         MVI       ERRNUM,X'07'        UNRECOGNIZED PACKET TYPE
         B         SLOOP
         SPACE 1                                                    TSO
*        PROCESS SEND FILE STATE                                    TSO
         SPACE 1                                                    TSO
SFILE    CLC       NUMTRY,MAXTRY       EXCEEDED NO. OF TRIES ALLOWED?
         BL        OK2                 NOPE, STILL OK
         MVI       STATE,C'A'          ABORT IF YES
         B         SLOOP
OK2      TR    NAME,ETOA                                            TSO
         LH    R4,NAMELN          GET LENGTH OF FILE NAME           TSO
         LR        R5,R4               COUNTER FOR LENTH OF FILNAM
         BCTR      R4,0                ONE LESS FOR 'EX' COMMAND
         L         R7,ABUF             Put FN here for encode [22]
         EX        R4,FIRST            PICK UP THE FN
         L         R3,NUMTRY
         LA        R3,1(R3)            INCREMENT TRIAL COUNTER
         ST        R3,NUMTRY
         MVI       STYPE,AF            PACKET TYPE = FILE HEADER
         ST        R5,LSDAT            SET BUFFER SIZE
         TR    NAME,ATOE          TRANSLATE THE NAME TO EBCDIC      AJR
         L         R3,NFSENT
         LR        R4,R3               SAVE VALUE
         C     R4,=F'4'           NEED MORE SPACE?                  TSO
         BE        ADDSP
         BH        ADDSP2
         M     R2,=F'44'          GET OFFSET INTO TABLE             TSO
         LA        R3,FSENT(R3)        POINTER INTO TABLE
         MVC   0(44,R3),NAME      SAVE FILE NAME YOU'RE SENDING     TSO
         LA        R4,1(R4)            INCREMENT NUMBER OF FILES SENT
         ST        R4,NFSENT
         B         SNDFIL
         SPACE 1                                                    TSO
ADDSP    L     R0,=F'4096'        GET 4K BLOCK                      TSO
         GETMAIN RC,LV=(0)        GET STORAGE                       TSO
         LTR  R15,R15             STORAGE GOTTEN OK?                TSO
         BZ   ADDSP1              YES                               TSO
         SPACE 1                                                    TSO
         MVI   ERRNUM,X'10'       ERROR ALLOCATING MORE SPACE       TSO
         MVI   STATE,C'A'         ABORT NOW                         TSO
         B     SLOOP                                                TSO
         SPACE 1                                                    TSO
ADDSP1   ST    R1,STORLOC         POINTS TO EXTRA DATA AREA         TSO
         OI        FLAGS,FLG5          GOT MORE SPACE (TURN ON FLAG)
ADDSP2   LR        R3,R4               GET CORRECT LENGTH AGAIN
         S     R3,=F'4'           GET PROPER POINTER                TSO
         M     R2,=F'44'          OFFSET INTO TABLE                 TSO
         A         R3,STORLOC          LOC IN TABLE
         MVC   0(44,R3),NAME      SAVE FILE NAME                    TSO
         LA        R4,1(R4)            INCREMENT FILE COUNTER
         ST        R4,NFSENT
SNDFIL   XC        INBFPT,INBFPT       Input buffer offset [22 start]
         MVC       RECL,LSDAT          Input buffer length
         L         R2,=A(NULREF)       Null refill routine
         ST        R2,MORENC
         L         R15,=A(ENCODE)
         BALR      R14,R15             Encode fn [22 end]
         L         R15,=A(SPACK)       GET ADDRESS OF 'SPACK'
         BALR      14,15               SAVE * AND GO TO SPACK
         CLI       STATE,C'A'
         BE        ABORT
         L         15,=A(RPACK)        GET ADDRESS OF 'RPACK'
         BALR      14,15               SAVE * AND GO TO RPACK
         CLI       RTYPE,AE            ERROR PACKET?
         BNE       Y2                  MAYBE AN ACK
         MVI       ERRNUM,X'0A'        MICRO DIED
         MVI       STATE,C'A'          SO WE DO TOO
         B         SLOOP
Y2       CLI       RTYPE,AY            SEE IF GOT ACK
         BNE       N2                  MAYBE GOT AN 'N'
         CLC       SPKNUM,RPKNUM       DO WE HAVE THE CORRECT ACK?
         BE        AOK2
         MVI       ERRNUM,X'08'        MISSING A PACKET SOMEWHERE
         B         SLOOP
AOK2     XC        NUMTRY,NUMTRY       RESET COUNTER
         L         R3,SPKNUM
         LA        R3,1(R3)            ADD ONE
         ST        R3,SPKNUM           STORE INCREMENTED VALUE
         NC        SPKNUM(4),=X'0000003F'   MASK TO GET MOD 64
         NI        FLAGS,X'FF'-FLG3    No data in input buffer [4]
         NI        FLAGS,X'FF'-FLG7    Not end of file yet [4]
         XC        LSDAT,LSDAT         No data in output buffer [4]
         L         15,=A(GTCHR)        GET A BUFFER FULL OF DATA
         BALR      14,15               DO GET-CHAR AND COME BACK
         MVI       STATE,C'D'          Send data state [4]
         C         R15,ZERO            Test the return code [4]
         BE        SLOOP               Successful return code [4]
         MVI       STATE,C'A'          Abort [4]
         BH        SLOOP               Got read error - fail [4]
         MVI       STATE,C'Z'          Send end-of-file state [4]
         CLC       LSDAT,ZERO          Any data to send [4]
         BE        SLOOP               No, goto eof state [4]
         MVI       STATE,C'D'          Send the last packet [4]
         B         SLOOP
N2       CLI       RTYPE,AN
         BNE       AB2                 ELSE, DIE
         TM        FLAGS,FLG4          DID MICRO NAK OR I REJECTED?
         BO        SLOOP               LEAVE ERR MSG AS IS IF I DID
         MVI       ERRNUM,X'09'        MICRO NAK'ED
         B         SLOOP
AB2      MVI       STATE,C'A'          ELSE, ABORT
         CLI       ERRNUM,S1ERRNUM     Was it a S/1 I/O error [12]
         BE        SLOOP               Yes just return [12]
         MVI       ERRNUM,X'07'        UNRECOGNIZED PACKET TYPE
         B         SLOOP
         SPACE 1                                                    TSO
*        PROCESS SEND DATA STATE                                    TSO
         SPACE 1                                                    TSO
SDATA    CLC       NUMTRY,MAXTRY       CAN WE DO IT?
         BL        OK4                 YES
         MVI       STATE,C'A'          ELSE ABORT
         B         SLOOP
OK4      L         R3,NUMTRY
         LA        R3,1(R3)            INCREMENT COUNTER
         ST        R3,NUMTRY
         MVI       STYPE,AD            PACKET TYPE = DATA
         L         R15,=A(SPACK)
         BALR      14,15               GO TO SPACK AND RETURN
         CLI       STATE,C'A'
         BE        ABORT
         L         15,=A(RPACK)
         BALR      14,15               SAME FOR RPACK
         CLI       RTYPE,AE            ERROR PACKET?
         BNE       Y4                  MAYBE AN ACK
         MVI       ERRNUM,X'0A'        MICRO DIED
         MVI       STATE,C'A'          SO WE DO TOO
         B         SLOOP
Y4       CLI       RTYPE,AY            SEE IF GOT 'ACK'
         BNE       N4                  SEE IF IT'S AN 'N'
         CLC       SPKNUM,RPKNUM       DO WE HAVE THE CORRECT ACK?
         BE        AOK4
         MVI       ERRNUM,X'08'        MISSING A PACKET
         B         SLOOP
AOK4     XC        NUMTRY,NUMTRY       RESET COUNTER
         L         R3,SPKNUM
         LA        R3,1(R3)            INCREMENT COUNTER
         ST        R3,SPKNUM
         NC        SPKNUM(4),=X'0000003F'   MASK TO GET MOD 64
         CLC       LRDAT,ONE           Data in ack? [16]
         BNE       BOK4                No just go on [16]
         L    R3,ARDAT            POINT TO DATA                     TSO
         CLI       0(R3),AX            Abort sending file [16]
         BE        SDAB                Yes [16]
         CLI       0(R3),AZ            Abort sending group [16]
         BNE       BOK4                No just ignore [16]
SDAB     MVC       CXZ(1),0(R3)        Pick up data [16]
         MVI       STATE,C'Z'          Go send end of file [16]
         MVI       ERRNUM,X'16'        Send cancelled [16]
         B         SLOOP               And continue [16]
BOK4     L         15,=A(GTCHR)        Get next buffer [16]
         BALR      14,15
         C         R15,ZERO            Test the return code [4]
         BE        SLOOP               Successful return code [4]
         MVI       STATE,C'A'          Abort [4]
         BH        SLOOP               Got read error - fail [4]
         MVI       STATE,C'Z'          Send end-of-file state [4]
         CLC       LSDAT,ZERO          Any data to send [4]
         BE        SLOOP               No, goto eof state [4]
         MVI       STATE,C'D'          Send the last packet [4]
         B         SLOOP
N4       CLI       RTYPE,AN
         BNE       AB4
         TM        FLAGS,FLG4          DID MICRO NAK OR I REJECTED?
         BO        SLOOP               LEAVE ERR MSG AS IS IF I DID
         MVI       ERRNUM,X'09'        MICRO NAK'ED
         B         SLOOP
AB4      MVI       STATE,C'A'
         CLI       ERRNUM,S1ERRNUM     Was it a S/1 I/O error [12]
         BE        SLOOP               Yes just return [12]
         MVI       ERRNUM,X'07'        ILLEGAL PACKET TYPE
         B         SLOOP
         SPACE 1                                                    TSO
*        PROCESS SEND END-OF-FILE STATE                             TSO
         SPACE 1                                                    TSO
SEOF     CLC       NUMTRY,MAXTRY       CAN WE DO IT?
         BL        OK5                 BRANCH IF YES
         MVI       STATE,C'A'          ABORT IF NO
         B         SLOOP
OK5      L         R3,NUMTRY
         LA        R3,1(R3)            ADD ONE
         ST        R3,NUMTRY           STORE INCREMENTED COUNTER
         MVI       STYPE,AZ            PACKET TYPE = EOF
         XC        LSDAT,LSDAT         LENGTH OF ZERO
         L         R15,=A(SPACK)
         BALR      14,15               SAVE * AND GO TO SPACK
         CLI       STATE,C'A'
         BE        ABORT
         L         15,=A(RPACK)
         BALR      14,15               SAME FOR RPACK
         CLI       RTYPE,AE            ERROR PACKET?
         BNE       Y5                  MAYBE AN ACK
         MVI       ERRNUM,X'0A'        MICRO DIED
         MVI       STATE,C'A'          SO WE DO TOO
         B         SLOOP
Y5       CLI       RTYPE,AY            CHECK FOR 'ACK'
         BNE       N5                  MAYBE WAS A 'NAK'
         CLC       SPKNUM,RPKNUM       CORRECT ACK?
         BE        AOK5
         MVI       ERRNUM,X'08'        LOST A PACKET
         B         SLOOP
AOK5     L         R3,SPKNUM
         LA        R3,1(R3)            ADD ONE
         ST        R3,SPKNUM           STORE VALUE INCREMENTED BY 1
         NC        SPKNUM(4),=X'0000003F'   MASK TO GET MOD 64
         MVI       STATE,C'F'          SET TO SEND FILE FOR NOW
         B         NXTFIL              GET-NEXT-FILE
         SPACE 1                                                    TSO
NOFIND   TM        FLAGS,FLG1          DID IT DIE ON FIRST TRY?
         BNO       DIEOK               NO ONES == NOT FIRST
         MVI       STATE,C'A'          ABORT THIS ONE
         TM        LFLAGS,SERVON       Are we a server [13]
         BO        NOF2                Yes handle differently [13]
         WRTERM    'File not found'
         B         SLOOP
NOF2     NI        FLAGS,X'FF'-FLG1    Clear first file status [13]
         MVI       ERRNUM,X'15'        Set msg for error packet [13]
         B         SLOOP               And go abort now [13]
DIEOK    MVI       STATE,C'B'          BREAK CONNECTION
         B         SLOOP
N5       CLI       RTYPE,AN
         BNE       AB5                 DIE IF NOT A NAK
         TM        FLAGS,FLG4          DID MICRO NAK OR I REJECTED?
         BO        SLOOP               LEAVE ERR MSG AS IS IF I DID
         MVI       ERRNUM,X'09'        MICRO NAK'ED
         B         SLOOP
AB5      MVI       STATE,C'A'          ELSE, ABORT
         CLI       ERRNUM,S1ERRNUM     Was it a S/1 I/O error [12]
         BE        SLOOP               Yes just return [12]
         MVI       ERRNUM,X'07'        UNRECOGNIZED PACKET TYPE
         B         SLOOP
         SPACE 1                                                    TSO
*        PROCESS SEND BREAK STATE                                   TSO
         SPACE 1                                                    TSO
SBREAK   CLC       NUMTRY,MAXTRY       OVER OUR LIMIT?
         BL        OK6                 BRANCH IF NO
         MVI       STATE,C'A'          ABORT IF YES
         B         SLOOP
OK6      L         R3,NUMTRY
         LA        R3,1(R3)            ADD ONE
         ST        R3,NUMTRY           INCREMEMTED TRIAL COUNTER
         MVI       STYPE,AB            PACKET TYPE = BREAK
         XC        LSDAT,LSDAT         LENGTH = ZERO
         L         R15,=A(SPACK)
         BALR      14,15               SAVE * AND GO TO SPACK
         CLI       STATE,C'A'
         BE        ABORT
         L         15,=A(RPACK)
         BALR      14,15               SAVE * AND GO TO RPACK
         CLI       RTYPE,AE            ERROR PACKET?
         BNE       Y6                  MAYBE AN ACK
         MVI       ERRNUM,X'0A'        MICRO DIED
         MVI       STATE,C'A'          THEN WE DO TOO
         B         SLOOP
Y6       CLI       RTYPE,AY            CHECK FOR ACK
         BNE       N6                  CHECK FOR 'N'
         CLC       SPKNUM,RPKNUM       CORRECT ACK?
         BE        AOK6
         MVI       ERRNUM,X'08'        LOST A PACKET
         B         SLOOP
AOK6     MVI       STATE,C'C'          COMPLETED STATE
         CLI       CXZ,X'00'           Other guy stop x-fer? [16]
         BE        SLOOP               No end OK [16]
         MVI       STATE,C'A'          Remember error [16]
         B         SLOOP
N6       CLI       RTYPE,AN            CHECK FOR 'N'
         BNE       AB6                 DIE IF NOT A NAK
         TM        FLAGS,FLG4          DID MICRO NAK OR I REJECTED?
         BO        SLOOP               LEAVE ERR MSG AS IS IF I DID
         MVI       ERRNUM,X'09'        MICRO NAK'ED
         B         SLOOP
AB6      MVI       STATE,C'A'          ELSE,ABORT
         CLI       ERRNUM,S1ERRNUM     Was it a S/1 I/O error [12]
         BE        SLOOP               Yes just return [12]
         MVI       ERRNUM,X'07'        UNRECOGNIZED PACKET TYPE
         B         SLOOP
*
         SPACE 1                                                    TSO
*        PROCESS SEND ABORT STATE                                   TSO
         SPACE 1                                                    TSO
ABORT    DS    0H                                                   TSO
         TM        FLAGS,FLG1          DYING ON FILE-NOT-FOUND?
         BO        NOERRP              IF SO, THEN NO ERROR PACKET
         CLI       ERRNUM,X'0A'        DID THE MICRO DIE?
         BE        NOERRP              NO ERROR PACKET IF SO
         CLI       ERRNUM,X'16'        Other side cancel send [16]
         BE        NOERRP              Yes no error packet [16]
* At least try to send an error packet.
*        CLI       ERRNUM,S1ERRNUM     Was it a S/1 I/O error [12]
*        BE        NOERRP              No error packet if yes [12]
         L         R15,=A(ERRPACK)     Send error packet [13]
         BALR      R14,R15             Error number in ERRNUM [13]
NOERRP   LA        R15,4               SET NON-ZERO RETCODE
         B         SENDRET             PREPARE TO LEAVE
         SPACE 1                                                    TSO
*        PROCESS SEND COMPLETE STATE                                TSO
         SPACE 1                                                    TSO
COMPLETE SR        R15,R15             ZERO WILL BE RETCODE
         SPACE 1                                                    TSO
SENDRET  DS    0H                                                   TSO
         NI    LFLAGS,255-SENDON  TURN OFF SEND STATE               TSO
         TM    S1FLAGS,ISS1       IS ITSERIES-1/IBM7171?            TSO
         BZ    SNO7171            NO                                TSO
         PUTCRSR ROW=21,COLUMN=1                                    TSO
         STFSMODE OFF             TURN OFF FULL SCREEN MODE         TSO
         OI    SRFLAGS,SRCLRSCR   TURN ON CLEAR SCREEN FLAG         TSO
SNO7171  RET   ,                                                    TSO
         SPACE 1                                                    TSO
FIRST    MVC   0(*-*,R7),NAME                                       TSO
         SPACE 1                                                    TSO
         EXIT
         TITLE '(GTCHR) Fill outgoing packet with maximum data'     TSO
* Rewrite routine to pack as much data into the outgoing packet as
* possible (not just a record at a time).  [4]
GTCHR    ENTER ,                                                    TSO
         L         R2,=A(INBUF)        Routine to call when [22]
         ST        R2,MORENC           need to refill on input [22]
         TM        FLAGS,FLG3          Does input buffer have data?
         BO        GTCH0               One means yes.
         L         R15,=A(INBUF)       Get a buffer full of data.
         BALR      R14,R15
         LTR       R15,R15             OK return code?
         BNZ       GTCH1               No, leave this routine.
GTCH0    L         R15,=A(ENCODE)      Encode the data
         BALR      R14,R15
GTCH1    RET   ,                                                    TSO
         EXIT                                                       TSO
         TITLE '(ENCODE) Encode packet'                             TSO
* Expects input buffer address in ABUF, writes to SDAT
* R8 - input buffer offset, R9 - output buffer offset,
* R10 - character count, R5 - quote character
* R3 - number of characters allowed in output buffer
* RECL - number of characters in input buffer (set in refill
* routine), MORENC has address of refill routine [22]
ENCODE   ENTER ,                                                    TSO
         L    R2,ASDAT            GET ADDRESS OF SDAT BUFFER        TSO
         CLC       RECL,ZERO           Any data to encode? [7]
         BE        ENCOD6              No just return [7]
         MVC       RPTQ(1),ORIGQ       Initialize repeat quote char [7]
         MVI       RPTVAL,X'00'        Holds Char to be repeated [7]
         MVI       RPTCT,X'01'         Number of repetitions [7]
         L         R3,MAXDAT           Max packet size
         LA        R3,1(R3)            Increment for BCT instruction
         SR        R9,R9               Initialize output buffer pointer
         SR        R10,R10             Ditto for character count
         SR        R5,R5               Will hold quote char
         IC        R5,RQUOTE
         L         R8,INBFPT           Where we left off
ENCOD0   BCTR      R3,0                Decr free space in output buffer
         LTR       R3,R3               Room left?
         BP        ENCOD1              Yes keep going
         ST        R8,INBFPT           No, so save input buffer pointer
         ST    R10,LSDAT          SAVE CHARACTER COUNT              TSO
         OI        FLAGS,FLG3          Stuff in input buffer
         SR        R15,R15             OK retcode
         B         ENCOD6
* Room in output buffer.  Now check if there's data in input buffer.
ENCOD1   C         R8,RECL             Any more input data?
         BL        ENCOD2              Yes go add to buffer
*        L         R15,=A(INBUF)       No, get more data [22]
         L         R15,MORENC          No, get more data [22]
         BALR      R14,R15
         L         R8,INBFPT           Input buffer pointer
         LTR       R15,R15             OK return code?
         BZ        ENCOD2              Yes, there's more input
         ST    R10,LSDAT          SAVE CHARACTER COUNT              TSO
         XC        INBFPT,INBFPT       Reset input buffer pointer
         NI        FLAGS,X'FF'-FLG3    No more data in input buffer
         B         ENCOD6
* Input data exists.  Add to buffer.
ENCOD2   SR        R7,R7
         L         R1,ABUF             ADDR OF BUFFER [2]
         AR        R1,R8               PLUS DISPLACEMENT [2]
ENCODFXD IC        R7,0(R1)            PICK UP BYTE [2]
         CLI       RPTQ,X'00'          Doing repeat quoting [7]
         BE        ENCOD23             No so skip this part [7]
         L         R6,RECL             Get length of input record [7]
         SR        R6,R8               Minus chars processed [7]
         C         R6,ONE              On last piece of input [7]
         BE        ENCOD21             Yes so write it out [7]
         CLI       RPTCT,X'5E'         Max that can rep in a byte [7]
         BE        ENCOD21             Then that's it [7]
         CLM       R7,B'0001',1(R1)    Current & next chars equal? [7]
         BNE       ENCOD21             No go write out chars [7]
         SR        R6,R6               Zero it out [7]
         IC        R6,RPTCT            Number of times char appears [7]
         LA        R6,1(R6)            Increment it [7]
         STC       R6,RPTCT            Remember number of repeats [7]
         STC       R7,RPTVAL           Remember repeated char [7]
         LA        R3,1(R3)            Adjust output pointer [7]
         LA        R8,1(R8)            Bump input pointer [7]
         B         ENCOD0              And get more data [7]
ENCOD21  CLI       RPTCT,X'01'         Were previous chars repeats [7]
         BE        ENCOD23             No so just add this char [7]
         CLI       RPTCT,RPTMIN        Within bounds for prefixing [7]
         BNL       ENCOD22             Yes, use repeat prefixing [7]
         SR        R6,R6               Blank it out [7]
         IC        R6,RPTCT            Not enough chars for repeats [7]
         SR        R8,R6               Adjust input buffer pointer [7]
         LA        R8,1(R8)            Don't get prev char again [7]
         LA        R3,1(R3)            Adjust output buffer counter [7]
         MVI       RPTVAL,X'00'        Clear out repeated char [7]
         MVC       ORIGQ(1),RPTQ       Save repeat quote char here [7]
         MVI       RPTQ,X'00'          Pretend not doing prefixing [7]
         B         ENCOD0              Reprocess the data [7]
ENCOD22  IC        R6,RPTQ             Get the repeat prefix [7]
         STC  R6,0(R9,R2)         ADD TO OUTPUT BUFFER              TSO
         LA        R9,1(R9)            Bump output pointer [7]
         LA        R10,1(R10)          Increment char count [7]
         BCTR      R3,0                Decrement for size [7]
         IC        R6,RPTCT            Size of repeated sequence [7]
         A         R6,=F'32'           Add space to make printable [7]
         STC  R6,0(R9,R2)         ADD SIZE TO OUTPUT BUFFER         TSO
         LA        R9,1(R9)            Bump output pointer [7]
         LA        R10,1(R10)          Increment char count [7]
         BCTR      R3,0                Decrement for char itself [7]
         MVI       RPTCT,X'01'         Reset repeat count [7]
         MVI       RPTVAL,X'00'        And this [7]
ENCOD23  CLI       EBQUOT,AN           DOING 8-BIT QUOTING? [1 START]
         BE        ENCOD3              NOPE, SO IGNORE
         CLI       EBQUOT,AY           CAN DO IT BUT AREN'T?
         BE        ENCOD3              YUP
         LR        R6,R7               SAVE CHAR HERE
         N         R6,=X'0000007F'     GET CHAR WITHOUT PARITY
         N         R7,=X'00000080'     ISOLATE PARITY
         LR        R7,R6               RESET REGISTER
         BZ        ENCOD3              DON'T NEED 8-BIT QUOTING
         LA   R4,0(R9,R2)         WHERE CHAR IS GOING               TSO
         MVC       0(1,R4),EBQUOT      Add 8-bit quote char to buffer
         LA        R9,1(R9)            INCR POINTER IN OUTPUT BUFFER
         LA        R10,1(R10)          Incr char count
         BCTR      R3,0                For 8-bit quote char [1 END]
ENCOD3   C         R7,SPACE            Is it a control character?
         BL        ENCOD5              Yes quote it and translate
         C         R7,DEL              Is it a delete?
         BE        ENCOD5              Yes quote it and translate
         CR        R7,R5               Is it the quote character?
         BE        ENCOD51             Yes quote it
         CLI       EBQUOT,AN           Doing 8-bit quoting [1 START]
         BE        ENCOD4              No how about repeat prefixing
         CLI       EBQUOT,AY           Same question
         BE        ENCOD4              Not doing quoting
         CLM       R7,B'0001',EBQUOT   Is char the 8-bit quote char?
         BE        ENCOD51             Yes output w/quote char [1 END]
ENCOD4   CLI       ORIGQ,X'00'         Doing repeat prefixing [7]
         BE        ENCOD52             No check for quote char [7]
         CLM       R7,B'0001',ORIGQ    Is char repeat quote char [7]
         BE        ENCOD51             Yes then quote it [7]
         B         ENCOD52             Else don't quote it [7]
ENCOD5   A         R7,O1H              Add 64 to char
         N         R7,=X'0000007F'     Get MOD 127
ENCOD51  LA   R4,0(R9,R2)         NEXT SPOT IN OUTPUT BUFFER        TSO
         MVC       0(1,R4),RQUOTE      Add quote char [7]
         LA        R9,1(R9)            Increment output buffer pointer
         LA        R10,1(R10)          Increment character counter
         BCTR      R3,0                Less space in output buffer [7]
ENCOD52  STC  R7,0(R9,R2)         ADD THE CHARACTER                 TSO
         LA        R9,1(R9)            Increment output buffer pointer
         LA        R8,1(R8)            Increment input buffer pointer
         LA        R10,1(R10)          Increment character counter
         CLI       RPTCT,X'01'         One occurence of char [7]
         BNE       ENCOD53             No there's more [7]
         MVC       RPTQ(1),ORIGQ       Restore repeat prefix [7]
         B         ENCOD0              Get more data
ENCOD53  SR        R6,R6               Zero out for increment [7]
         IC        R6,RPTCT            Number of repetitions [7]
         BCTR      R6,0                Decrement number left to do [7]
         STC       R6,RPTCT            Store here [7]
         B         ENCOD0              Add char again [7]
ENCOD6   RET   ,                                                    TSO
         SPACE 3                                                    TSO
NULREF   SR        R2,R2               [22 start]
         BCTR      R2,0                Get -1 here
         ST        R2,INBFPT           Say no more data to encode
         LR        R15,R2              Error ret code
         BR        R14                 That's it [22 end]
         EXIT                                                       TSO
         TITLE '(INBUF) Read data record from input file'           TSO
* Read the next line from the input file, and do EBCDIC to ASCII
* translation if requested.  [4]
INBUF    ENTER ,                                                    TSO
         TM        FLAGS,FLG7          Hit eof yet? [4]
         BNO       INBUFX              If yes, return RC of -1 [4]
         L         R15,=F'-1'          Error return code.
         XC        LSDAT,LSDAT         No data to send [4]
         B         INBUF9
INBUFX   L         R4,ABUF             READ INTO THIS BUFFER [2]
         CLI   TYPFIL,C'V'        V-BINARY?                         AJR
         BNE   INBUFRD            NO                                AJR
         LA    R4,2(,R4)          RESERVE 2 BYTES FOR LENGTH FIELD  AJR
INBUFRD  GET   SENDRCV,(R4)       GET A RECORD FROM SEND FILE       TSO
         B     INBUF1             GO PROCESS THIS RECORD            TSO
         SPACE 1                                                    TSO
*        SEND EODAD ROUTINE                                         TSO
         SPACE 1                                                    TSO
INBUFEOD OI    FLAGS,FLG7         SET EOF FLAG                      TSO
         L         R15,=F'-1'          Error return code.
         B         INBUF9
         SPACE 1                                                    TSO
*        SEND SYNAD ROUTINE                                         TSO
         SPACE 1                                                    TSO
INBUF0   L         R15,=F'1'           Error return code.
         MVI       ERRNUM,X'0D'        ELSE, GOT AN I/O ERROR
         B         INBUF9
         SPACE 1                                                    TSO
*        PROCESS SEND INPUT RECORD                                  TSO
         SPACE 1                                                    TSO
INBUF1   TM    SENDRCV+(DCBRECFM-IHADCB),DCBRECU  UNDEFINED FORMAT? AJR
         BO    INBUF10            YES                               AJR
         TM    SENDRCV+(DCBRECFM-IHADCB),DCBRECV  VARIABLE FORMAT?  AJR
         BO    INBUF11            YES                               TSO
INBUF10  LH    R5,SENDRCV+(DCBLRECL-IHADCB)  LRECL FOR RECFM=U or F AJR
         LA    R15,8              IN CASE OF ERROR                  AJR
         CH    R5,BLKSIZE         MUST NOT BE GREATER THAN BLKSIZE  AJR
         BNH   INBUF100           OK                                AJR
         B     INBUFERR           DIE                               AJR
INBUF100 CLI   TYPFIL,C'V'        V-BINARY?                         AJR
         BNE   INBUF12            NO                                AJR
         LA    R2,2                                                 AJR
         SR    R4,R2              BACK UP TO START OF BUFFER        AJR
         STH   R5,0(R4)           SAVE LENGTH AT START OF BUFFER    AJR
         AR    R5,R2              LRECL + 2 (FOR LENGTH)            AJR
         B     INBUF8             MUST BE BINARY                    AJR
         SPACE 1                                                    TSO
INBUF11  LH    R5,0(,R4)          LENGTH READ FOR VARIABLE RECORD   TSO
         LA    R15,8              IN CASE OF ERROR                  AJR
         CH    R5,SENDRCV+(DCBLRECL-IHADCB)       MATCH?            AJR
         BNE   INBUFER2           NO, GIVE UP                       AJR
         S     R5,=F'4'           REDUCE BY LENGTH OF RDW           TSO
         CLI   TYPFIL,C'V'        V-BINARY?                         AJR
         BNE   INBUF111           NO                                AJR
         LA    R2,2                                                 AJR
         SR    R4,R2              BACK UP TO START OF BUFFER        AJR
         STH   R5,0(R4)           SAVE LENGTH AT START OF BUFFER    AJR
         LA    R4,2(,R4)          PREPARE FOR SHIFT LEFT OF DATA    AJR
INBUF111 STM   R4,R7,INBFSV       SAVE REGS FOR MOVE                AJR
         LA    R6,4(R4)           2ND OPERAND ADDRESS               AJR
         LR    R7,R5              2ND OPERAND LENGTH                AJR
         LA    R5,4(R5)           1ST OPERAND LENGTH                AJR
         MVCL  R4,R6              MOVE DATA LEFT 4 BYTES            AJR
         LM    R4,R7,INBFSV       RESTORE REGS AFTER MOVE           AJR
         CLI   TYPFIL,C'V'        V-BINARY?                         AJR
         BNE   INBUF12            NO                                AJR
         LA    R2,2               ADJUST TO ABUF AND CORRECT LENGTH AJR
         SR    R4,R2              BACK UP TO START OF BUFFER        AJR
         LA    R5,2(,R5)          LRECL + 2 (FOR LENGTH)            AJR
         B     INBUF8             MUST BE BINARY                    AJR
         SPACE 1                                                    TSO
INBUF12  DS    0H                                                   TSO
         TM        FLAGS,BINF          BINARY FILE X-FER [1]
         BO        INBUF8              YES, SKIP TRANSLATION [1]
         LTR       R5,R5               Any data at all [4]
         BZ        INBUF7              No skip translation [4]
         L     R2,ABUF            POINT TO DATA TO TRANSLATE        TSO
         LR    R3,R5              LENGTH OF DATA TO TRANSLATE       TSO
         L     R4,=A(ETOA)        PASS TRANSLATE TABLE ADDRESS      TSO
         L     R15,=A(TRANSLAT)   GET TRANSLATE ROUTINE ADDRESS     TSO
         BALR  R14,R15            GO TRANSLATE DATA                 TSO
         L     R8,ABUF            POINT TO BUFFER                   TSO
         LR    R9,R8              POINT TO START OF DATA            TSO
         AR    R9,R5              POINT PAST END OF DATA            TSO
INBUF5   BCTR  R9,0               POINT TO PREVIOUS CHARACTER       TSO
         CLI   0(R9),ABL          IS IT A BLANK?                    TSO
         BNE   INBUF7             NO, FOUND LAST DATA CHARACTER     TSO
         BCTR  R5,0               REDUCE LENGTH FOR EVERY BLANK     TSO
         CR    R9,R8              AT BEGINNING OF DATA?             TSO
         BH    INBUF5             NO, CONTINUE BACK-SCAN            TSO
INBUF7   L         R9,ABUF             BUFFER HEAD [2]
         AR        R9,R5               PLUS DISPLACEMENT [2]
         MVC   0(2,R9),=X'0D0A'   ADD ASCII CR AND LF               TSO
         LA        R5,2(R5)            LRECL + 2 (FOR CRLF)         AJR
INBUF8   ST        R5,RECL             SAVE DATA LENGTH             AJR
         XC        INBFPT,INBFPT       Zero input buffer pointer
         SR        R15,R15             Return code == success
INBUF9   RET   ,                                                    TSO
         SPACE 1                                                    TSO
INBUFERR MVI   ERRNUM,34          RECORD > BLKSIZE                  AJR
         RET   ,                                                    AJR
         SPACE 1                                                    AJR
INBUFER2 MVI   ERRNUM,35          BAD RECORD LENGTH                 AJR
         RET   ,                                                    AJR
         SPACE 1                                                    AJR
INBFSV   DS    4F                 SAVE AREA FOR MOVE                AJR
         EXIT                                                       TSO
         TITLE '(RCVCMD) Receive command processor'                 TSO
*        This routine processes the RECEIVE command.  It parses the TSO
*        operands in the command buffer, allocates the receive file TSO
*        and opens it.  It then passes control to the receive       TSO
*        processor to perform the actual receive function.          TSO
*                                                                   TSO
*        On Entry:                                                  TSO
*          R1 -> Command Buffer                                     TSO
*                                                                   TSO
*        On Exit:                                                   TSO
*          R15 contains a return code                               TSO
*             0  -  Normal receive operation                        TSO
*             4  -  Receive error                                   TSO
         SPACE 3                                                    TSO
RCVCMD   ENTER ,                                                    TSO
         NI    SRFLAGS,255-SRINTO TURN OFF DSNAME ON COMMAND FLAG   TSO
         LH    R2,2(,R1)          GET OFFSET TO FIRST OPERAND       TSO
         SH    R2,CMDLEN          ADJUST FOR COMMAND LENGTH         TSO
         BNP   RCVGTFIL           IF <= 0 GET NAME(S) FROM MICRO    TSO
         LH    R2,2(,R1)          GET OFFSET TO FIRST OPERAND       TSO
         LA    R2,4(R2,R1)        POINT TO OPERAND                  TSO
         CLI   0(R2),C' '         ARE THERE JUST BLANKS?            TSO
         BE    RCVGTFIL           YES, NO NAME ON COMMAND           TSO
         CLI   0(R2),C'0'         IS IT A NON-NUMERIC?              TSO
         BNL   RCVGTFIL           NO, LOOKS LIKE A SEQUENCE NUMBER  TSO
         SETSEMI                  GO INSERT SEMICOLON               TSO
         LA    R10,PPLAREA        GET ADDRESS OF PARSE PARM LIST    TSO
         USING PPL,R10            MAKE IT ADDRESSABLE               TSO
         ST    R1,PPLCBUF         PUT ADDRESS OF CMD BUFFER IN PPL  TSO
         PARSE RCVPARM,ATTN=RCVRTRN,ERR=RCVERRTN                    TSO
         CHECKPDL BAD=RCV#@PDL                                      TSO
         USING IKJPARMD,R9        MAKE PDL ADDRESSABLE              TSO
         SPACE 1                                                    TSO
         TM    RCVDSN+6,X'80'     IS DSNAME PRESENT?                TSO
         BNO   RCVGTFIL           NO, GET NAME(S) FROM MICRO        TSO
         LH    R2,RCVDSN+4        GET LENGTH OF DSNAME              TSO
         STH   R2,FILNAMLN        SAVE LENGTH OF FILE NAME          TSO
         L     R3,RCVDSN          GET ADDRESS OF FILE NAME          TSO
         BCTR  R2,0               ADJUST FOR EX                     TSO
         EX    R2,RCVMVDS         SET UP FILE NAME                  TSO
*RCVMVDS MVC   FILNAM(*-*),0(R3)                                    TSO
         OI    SRFLAGS,SRINTO     INDICATE DATA SET NAME ON COMMAND TSO
         SPACE 1                                                    TSO
         XC    MBRNAMLN,MBRNAMLN  CLEAR MEMBER NAME LENGTH          TSO
         MVC   MBRNAM,BLANKS      CLEAR MEMBER NAME                 TSO
         TM    RCVDSN+14,X'80'    IS MEMBER NAME PRESENT?           TSO
         BZ    RCVPREFX           NO, GO PREFIX FILE NAME           TSO
         LH    R2,RCVDSN+12       GET LENGTH OF MEMBER NAME         TSO
         STH   R2,MBRNAMLN        SAVE LENGTH                       TSO
         L     R3,RCVDSN+8        GET ADDRESS OF MEMBER NAME        TSO
         BCTR  R2,0               ADJUST FOR EX                     TSO
         EX    R2,RCVMVMB         SET UP MEMBER NAME                TSO
*RCVMVMB MVC   MBRNAM(*-*),0(R3)                                    TSO
         SPACE 1                                                    TSO
RCVPREFX TM    RCVDSN+6,X'40'     IS DSNAME QUOTED?                 TSO
         BZ    RCVPRFX            NO, GO PREFIX THE SUPPLIED FILE   TSO
         LOCATE DATASET           SEE IF DATA SET EXISTS            TSO
         LTR   R15,R15            WAS DATA SET FOUND?               TSO
         BNZ   RCVALNEW           NO, GO ALLOCATE A NEW ONE         TSO
         B     RCVPRMPT           YES, GO PROMPT FOR OVERWRITE      TSO
         SPACE 1                                                    TSO
RCVPRFX  LA    R1,FILNAMLN        GET ADDRESS OF LENGTH & FILE NAME TSO
         L     R15,=A(PREFIXDS)   GET ADDRESS OF PREFIX ROUTINE     TSO
         BALR  R14,R15            GO PREFIX THE NAME                TSO
         B     *+4(R15)           BRANCH ON RETURN CODE             TSO
         B     RCVPRMPT           0  - OLD DATA SET                 TSO
         B     RCVALNEW           4  - NEW DATA SET                 TSO
         B     RCV#@PRE           8  - UNABLE TO PREFIX             TSO
         SPACE 1                                                    TSO
*        ALLOCATE THE DATA SET                                      TSO
         SPACE 1                                                    TSO
RCVPRMPT L     R15,=V(PDSCHK)     GET ADDRESS OF PDS CHECK ROUTINE  TSO
         BALR  R14,R15            GO SEE IF THIS IS A PDS           TSO
         B     *+4(R15)           BRANCH ON RETURN CODE             TSO
         B     RCVALOLD           WAS A PDS NOW GO ALLOCATE IT      TSO
         B     RCVPROMP           WAS NOT A PDS                     TSO
         B     RCVERRTN           ERROR, GO BACK AND PROMPT         TSO
         SPACE 1                                                    TSO
RCVPROMP PROMPT 'Data set exists.  Reply "OK" to overwrite:'        TSO
         B     *+4(R15)           BRANCH ON RETURN CODE             TSO
         B     RCVREPLY           0  - REPLY RECEIVED               TSO
         B     RCVERRTN           4  - ATTENTION, GO BACK AND PROMPTTSO
         SPACE 1                                                    TSO
RCVREPLY LH    R0,0(,R1)          GET LENGTH OF REPLY               TSO
         S     R0,=F'4'           ADJUST FOR RDW                    TSO
         BZ    RCVPRMPT           IF ZERO PROMPT AGAIN              TSO
         OC    4(2,R1),=C'  '     UPCASE FIRST 2 CHARACTERS OF REPLYTSO
         CLC   =C'OK',4(R1)       WAS REPLY "OK"?                   TSO
         BNE   RCVERRTN           NO, ABORT OPERATION               TSO
         SPACE 1                                                    TSO
RCVALOLD LA    R8,ALLOCCB         POINT TO ALLOCATION CONTROL BLOCK TSO
         USING ALCCB,R8           MAKE IT ADDRESSABLE               TSO
         LA    R0,ALCTOLD         INDICATE "OLD" ALLOCATION         TSO
         ST    R0,ALCTYPE         PUT INTO ALCCB                    TSO
         B     RCVALCDS           GO ALLOCATE THE FILE              TSO
         SPACE 1                                                    TSO
RCVALNEW LA    R8,ALLOCCB         POINT TO ALLOCATION CONTROL BLOCK TSO
         LA    R0,ALCTNEW         INDICATE "NEW" ALLOCATION         TSO
         ST    R0,ALCTYPE         PUT INTO ALCCB                    TSO
RCVALCDS LA    R0,FILNAMLN        GET ADDRESS OF FILE NAME & LENGTH TSO
         ST    R0,ALCDSN          PUT INTO ALCCB                    TSO
         XC    ALCMEMBR,ALCMEMBR  ASSUME NO MEMBER NAME             TSO
         SR    R0,R0              CLEAR FOR ICM                     TSO
         ICM   R0,3,MBRNAMLN      GET LENGTH OF MEMBER NAME         TSO
         BZ    RCVALC             NO, MEMBER NAME; DO ALLOCATE      TSO
         LA    R0,MBRNAMLN        GET ADDRESS OF MEMBER NAME        TSO
         ST    R0,ALCMEMBR        PUT INTO ALCCB                    TSO
RCVALC   IKJRLSA PDLADDR          RELEASE THE PDL                   TSO
         XC    PDLADDR,PDLADDR    CLEAR THE PDL ADDRESS             TSO
         LR    R1,R8              PASS ADDRESS OF ALCCB             TSO
         L     R15,=A(ALLOCDSN)   GET ALLOCATE ROUTINE ADDRESS      TSO
         BALR  R14,R15            GO ALLOCATE THE DATA SET          TSO
         B     *+4(R15)           BRANCH ON RETURN CODE             TSO
         B     RCVOPEN            0  -  ALLOCATION SUCCESSFUL       TSO
         B     RCVNFND            4  -  DATA SET NOT FOUND          TSO
         B     RCVALCER           8  -  ALLOCATION ERROR            TSO
         B     RCVINCMP           12 -  INCOMPATIBLE DATA SET TYPE  TSO
         B     RCVUNSUP           16 -  UNSUPPORTED DATA SET TYPE   TSO
         SPACE 1                                                    TSO
RCVINCMP WRTERM 'Incompatible data set type'                        TSO
         B     RCVERRTN           GO RETURN ERROR                   TSO
         SPACE 1                                                    TSO
RCVUNSUP WRTERM 'Unsupported data set type'                         TSO
         B     RCVERRTN           GO RETURN ERROR                   TSO
         SPACE 1                                                    TSO
RCVALCER WRTERM 'Error while attempting to allocate RECEIVE data set'
         B     RCVERRTN           GO RETURN ERROR                   TSO
         SPACE 1                                                    TSO
RCVNFND  WRTERM 'Receive data set not found'                        TSO
         B     RCVERRTN           GO RETURN ERROR                   TSO
         SPACE 1                                                    TSO
*        OPEN THE DATA SET                                          TSO
         SPACE 1                                                    TSO
RCVOPEN  MVC   SENDRCV+40(8),BLANKS  CLEAR DCB DDNAME               TSO
         LR    R2,R0              SAVE LENGTH OF DDNAME             TSO
         BCTR  R2,0               ADJUST FOR EX                     TSO
         EX    R2,RCVMDDN         PUT DDNAME INTO DCB               TSO
*RCVMDDN MVC   SENDRCV+40(*-*),0(R1)                                TSO
         SR    R0,R0              NEED ZEROS                        TSO
         STCM  R0,7,SENDRCV+(DCBEODA-IHADCB)  CLEAR EODAD ADDRESS   TSO
         STCM  R0,7,SENDRCV+(DCBSYNA-IHADCB)  CLEAR SYNAD ADDRESS   TSO
         OPEN  (SENDRCV,OUTPUT)   OPEN THE DATA SET FOR OUTPUT      TSO
         TM    SENDRCV+(DCBOFLGS-IHADCB),DCBOFOPN  OPEN SUCCESSFUL  TSO
         BO    RCVRCV             YES, GO PERFORM RECEIVE OPERATION TSO
         WRTERM 'Unable to open RECEIVE data set.'                  TSO
         UNALLOC DSNAME,ADDR=ALCDSN  UNALLOCATE THE DATA SET        TSO
         B     RCVERRTN           GO RETURN ERROR                   TSO
         SPACE 1                                                    TSO
RCVRCV   OI    FLAGS,FLG2         INDICATE OVERWRITE DATA SET       TSO
RCVGTFIL L     R15,=A(RECEIVE)    GET ADDRESS OF RECEIVE ROUTINE    TSO
         BALR  R14,R15            GO DO RECEIVE OPERATION           TSO
         LR    R5,R15             PRESERVE RETURN CODE              TSO
         CLI   STATE,C'A'         WAS THIS OPERATION ABORTED        TSO
         BNE   RCVTSTRC           NO, DON'T DO CLOSE ETC.           TSO
         TM    SENDRCV+(DCBOFLGS-IHADCB),DCBOFOPN  OPEN SUCCESSFUL? TSO
         BNO   RCVUNAL            NO                                TSO
         CLOSE (SENDRCV)          CLOSE DATA SET                    TSO
         FREEPOOL SENDRCV         FREE THE QSAM BUFFER POOL         TSO
RCVUNAL  LA    R8,ALLOCCB         GET ADDRESS OF ALLOCATION CB      TSO
         UNALLOC DSNAME,ADDR=ALCDSN  UNALLOCATE THE DATA SET        TSO
RCVTSTRC LTR   R5,R5              RECEIVE FUNCTION DONE OK?         TSO
         BNZ   RCVERRTN           NO, RETURN ERROR                  TSO
         B     RCVRTRN            RETURN TO CALLER                  TSO
         DROP  R8                 DROP ALCCB ADDRESSABILITY         TSO
         SPACE 1                                                    TSO
RCV#@PRE WRTERM 'Unable to prefix RECEIVE command file name'        TSO
         B     RCVERRTN           GO RETURN ERROR                   TSO
         SPACE 1                                                    TSO
RCV#@PDL WRTERM 'Invalid parameters on the RECEIVE command'         TSO
RCVERRTN LA    R15,4              SET ERROR RETURN CODE             TSO
RCVRTRN  RET   ,                                                    TSO
         SPACE 1                                                    TSO
RCVMVDS  MVC   FILNAM(*-*),0(R3)                                    TSO
RCVMDDN  MVC   SENDRCV+40(*-*),0(R1)                                TSO
RCVMVMB  MVC   MBRNAM(*-*),0(R3)                                    TSO
         DROP  R10                DROP PPL ADDRESSABILITY           TSO
         DROP  R9                 DROP PDL ADDRESSABILITY           TSO
         SPACE 1                                                    TSO
         PRINT NOGEN                                                TSO
RCVPARM  IKJPARM ,                                                  TSO
RCVDSN   IKJPOSIT DSNAME,PROMPT='FILE NAME FOR RECEIVE'             TSO
         IKJENDP ,                                                  TSO
         PRINT GEN                                                  TSO
         SPACE 1                                                    TSO
         EXIT                                                       TSO
         TITLE '(PDSCHK) Verify PDS member'                         TSO
*        This routine checks to see if the old data set being       TSO
*        allocated is a PDS.  It then allocates and opens the       TSO
*        data set and does a FIND to determine if the member is     TSO
*        present.                                                   TSO
*                                                                   TSO
*        On exit:                                                   TSO
*        R15 contains a return code                                 TSO
*            0 -- PDS member check was handled properly             TSO
*            4 -- Not a PDS                                         TSO
*            8 -- Error when processing PDS                         TSO
         SPACE 3                                                    TSO
PDSCHK   ENTER ,                                                    TSO
         CLC   =H'0',MBRNAMLN     IS THIS A PDS?                    TSO
         BE    PDSNOPDS           NO, JUST RETURN                   TSO
PDSALLOC LA    R8,ALLOCCB         POINT TO ALLOCATION CONTROL BLOCK TSO
         USING ALCCB,R8           MAKE IT ADDRESSABLE               TSO
         LA    R0,ALCTOLD         INDICATE "OLD" ALLOCATION         TSO
         ST    R0,ALCTYPE         PUT INTO ALCCB                    TSO
         OI    ALCTYPE+3,ALCCMPAT FORCE ALLOCATION AS PS DATA SET   TSO
         XC    ALCMEMBR,ALCMEMBR  DON'T USE MEMBER NAME             TSO
         LA    R0,FILNAMLN        GET ADDRESS OF FILE NAME & LENGTH TSO
         ST    R0,ALCDSN          PUT INTO ALCCB                    TSO
         LR    R1,R8              PASS ADDRESS OF ALCCB             TSO
         L     R15,=A(ALLOCDSN)   GET ALLOCATE ROUTINE ADDRESS      TSO
         BALR  R14,R15            GO ALLOCATE THE DATA SET          TSO
         B     *+4(R15)           BRANCH ON RETURN CODE             TSO
         B     PDSOPEN            0  -  ALLOCATION SUCCESSFUL       TSO
         B     PDSNFND            4  -  DATA SET NOT FOUND          TSO
         B     PDSALCER           8  -  ALLOCATION ERROR            TSO
         B     PDSOPEN            12 -  INCOMPATIBLE DATA SET TYPE  TSO
         B     PDSALCER           16 -  UNSUPPORTED DATA SET TYPE   TSO
         SPACE 1                                                    TSO
PDSALCER MVI   ERRNUM,28          SET ERROR ALLOCATING FILE         TSO
         TM    SRFLAGS,SRINTO     DATA SET NAME ON COMMAND?         TSO
         BZ    PDSERRTN           NO, JUST RETURN WITH ERROR        TSO
         WRTERM 'Allocation error for PDS'                          TSO
         B     PDSERRTN           GO RETURN ERROR                   TSO
         SPACE 1                                                    TSO
PDSNFND  MVI   ERRNUM,21          FILE NOT FOUND                    TSO
         TM    SRFLAGS,SRINTO     DATA SET NAME ON COMMAND?         TSO
         BZ    PDSERRTN           NO, JUST RETURN WITH ERROR        TSO
         WRTERM 'PDS not found'                                     TSO
         B     PDSERRTN           GO RETURN ERROR                   TSO
         SPACE 1                                                    TSO
*        OPEN THE DATA SET                                          TSO
         SPACE 1                                                    TSO
PDSOPEN  MVC   PDSCKDCB+40(8),BLANKS  CLEAR DCB DDNAME              TSO
         LR    R2,R0              SAVE LENGTH OF DDNAME             TSO
         BCTR  R2,0               ADJUST FOR EX                     TSO
         EX    R2,PDSMDDN         PUT DDNAME INTO DCB               TSO
*PDSMDDN MVC   PDSCKDCB+40(*-*),0(R1)                               TSO
         OPEN  (PDSCKDCB,INPUT)   OPEN THE DATA SET FOR INPUT       TSO
         TM    PDSCKDCB+(DCBOFLGS-IHADCB),DCBOFOPN  OPEN SUCCESSFUL TSO
         BO    PDSPDS             YES, GO PERFORM RECEIVE OPERATION TSO
         MVI   ERRNUM,29          SAY ERROR OPENING FILE            TSO
         UNALLOC DSNAME,ADDR=ALCDSN  UNALLOCATE THE DATA SET        TSO
         TM    SRFLAGS,SRINTO     DATA SET NAME ON COMMAND?         TSO
         BZ    PDSERRTN           NO, JUST RETURN WITH ERROR        TSO
         WRTERM 'Unable to open PDS'                                TSO
         B     PDSERRTN           GO RETURN ERROR                   TSO
         SPACE 1                                                    TSO
PDSPDS   FIND  PDSCKDCB,MBRNAM,D  SEARCH FOR MEMBER NAME            TSO
         B     *+4(R15)           BRANCH ON RETURN CODE             TSO
         B     PDSPRMPT           0  - MEMBER WAS FOUND             TSO
         B     PDSNOMEM           4  - MEMBER NOT FOUND             TSO
         B     PDSIOSTG           8  - I/O ERROR OR LACK OF MEMORY  TSO
         SPACE 1                                                    TSO
PDSPRMPT TM    SRFLAGS,SRINTO     WAS FILE NAME SPECIFIED ON CMD?   TSO
         BO    PDSPRMP2           YES                               TSO
         TM    LFLAGS,WARFL       CAN WE OVERWRITE EXISTING MEMBER? TSO
         BNO   PDSNOMEM           YES, SAME A MEMBER NOT FOUND      TSO
         MVC   PDSTMPMM,MBRNAM    SAVE MEMBER NAME TEMPORARILY      TSO
         LH    R2,RPMODFI         PICK UP MODIFICATION VALUE        TSO
         CVD   R2,CVDDBLWD        CONVERT IT                        TSO
         OI    CVDDBLWD+7,X'0F'                                     TSO
         UNPK  MBRNAM(8),CVDDBLWD PUT INTO MEMBER NAME AREA         TSO
         LH    R3,MBRNAMLN        GET MEMBER NAME LENGTH            TSO
         CH    R3,=H'7'           IS MEMBER LENGTH SHORTER THAN MAX?TSO
         BL    PDSMVNM            YES, MOVE IN NAME                 TSO
         LA    R3,6               MAX LENGTH OF MEMBER NAME TO MOVE TSO
         CLI   MBRNAM+6,C'0'      2 MOD DIGITS NEEDED?              TSO
         BE    PDS1MOD            NO                                TSO
PDSMVNM  BCTR  R3,0               ADJUST FOR EX                     TSO
PDS1MOD  EX    R3,PDSMVM          OVERLAY MEMBER                    TSO
*PDSMVM  MVC   MBRNAM(*-*),PDSTMPMM                                 TSO
         LA    R2,1(,R2)          BUMP MODIFICATION VALUE           TSO
         STH   R2,RPMODFI         PUT IT BACK                       TSO
         LA    R0,8               LENGTH OF NEW MEMBER NAME         TSO
         STH   R0,MBRNAMLN        PUT IT IN                         TSO
         B     PDSPDS             GO CHECK FOR THIS MEMBER          TSO
         SPACE 1                                                    TSO
PDSPRMP2 PROMPT 'Member exists.  Reply "OK" to overwrite:'          TSO
         B     *+4(R15)           BRANCH ON RETURN CODE             TSO
         B     PDSREPLY           0  - REPLY RECEIVED               TSO
         B     PDSERRTN           4  - ATTENTION, GO BACK AND PROMPTTSO
         SPACE 1                                                    TSO
PDSREPLY LH    R0,0(,R1)          GET LENGTH OF REPLY               TSO
         S     R0,=F'4'           ADJUST FOR RDW                    TSO
         BZ    PDSPRMPT           IF ZERO PROMPT AGAIN              TSO
         OC    4(2,R1),=C'  '     UPCASE FIRST 2 CHARACTERS OF REPLYTSO
         CLC   =C'OK',4(R1)       WAS REPLY "OK"?                   TSO
         BNE   PDSERRTN           NO, ABORT OPERATION               TSO
         SPACE 1                                                    TSO
PDSNOMEM SR    R15,R15            SET PDS HANDLED PROPERLY CODE     TSO
         B     PDSRTRN            GO RETURN                         TSO
         SPACE 1                                                    TSO
PDSIOSTG MVI   ERRNUM,13          INDICATE I/O ERROR                TSO
         TM    SRFLAGS,SRINTO     DATA SET NAME ON COMMAND?         TSO
         BZ    PDSERRTN           NO, JUST RETURN WITH ERROR        TSO
         LTR   R0,R0              I/O ERROR?                        TSO
         BNZ   PDSNOSTG           NO, NOT ENOUGH STORAGE            TSO
         WRTERM 'I/O error in PDS directory'                        TSO
         B     PDSERRTN           GO RETURN ERROR                   TSO
         SPACE 1                                                    TSO
PDSNOSTG WRTERM 'Insufficient storage to search PDS directory'      TSO
         B     PDSERRTN           GO RETURN ERROR                   TSO
         SPACE 1                                                    TSO
PDSNOPDS LA    R15,4              SET NO PDS RETURN CODE            TSO
         B     PDSQUIT            GO RETURN                         TSO
         SPACE 1                                                    TSO
PDSERRTN LA    R15,8              SET ERROR RETURN CODE             TSO
         SPACE 1                                                    TSO
PDSRTRN  LR    R2,R15             PRESERVE RETURN CODE              TSO
         CLOSE (PDSCKDCB)         CLOSE THE DATA SET                TSO
         UNALLOC DSNAME,ADDR=ALCDSN  UNALLOCATE THE DATA SET        TSO
         LR    R15,R2             RESTORE RETURN CODE               TSO
         SPACE 1                                                    TSO
PDSQUIT  RET   ,                                                    TSO
         SPACE 1                                                    TSO
PDSMDDN  MVC   PDSCKDCB+40(*-*),0(R1)                               TSO
PDSMVM   MVC   MBRNAM(*-*),PDSTMPMM                                 TSO
         SPACE 1                                                    TSO
PDSTMPMM DC    CL8' '             TEMPORARY STORAGE FOR MEMBER      TSO
         EXIT                                                       TSO
         DROP  R8                 DROP ALCCB ADDRESSABILITY         TSO
         TITLE '(RECEIVE) Perform receive function'                 TSO
RECEIVE  ENTER ,
         MVC       EBQUOT(1),ORIG8Q    IF CHANGED IN LAST X-FER [1]
         SR        R6,R6               GET ZERO
         ST        R6,NUMTRY           ZERO THIS OUT
         ST        R6,SPKNUM           HERE TOO
         OI     LFLAGS,RECVON     SET RECEIVE MODE                  TSO
         MVI       STATE,C'R'          SET TO RECEIVE STATE
         SPACE 1                                                    TSO
*        IF COMMUNICATIONS IS WITH A SERIES-1/IBM 7171 THEN         TSO
*        WRITE TO IT SO WE CAN READ                                 TSO
         SPACE 1                                                    TSO
         TM    LFLAGS,SERVON      IN SERVER MODE?                   TSO
         BO    RLOOP              YES                               TSO
         TM    S1FLAGS,ISS1       IS IT A SERIES-1/IBM7171?         TSO
         BZ    RNOT7171           NO CONTINUE                       TSO
         STFSMODE ON,INITIAL=YES,NOEDIT=YES  FULL SCREEN MODE       TSO
         BLOCKLET =C'RECEIVE',7   GO PUT IN BLOCK LETTERS           TSO
         LA    R1,1(,R1)          SKIP A LINE ON SCREEN             TSO
         FULLSCR 'Escape to your local KERMIT and enter the send comman+
               d',ROW=(1),COLUMN=1                                  TSO
         PUTCRSR ROW=21,COLUMN=1                                    TSO
         STIMER WAIT,BINTVL==F'500' WAIT UNTIL SCREEN IS PAINTED    TSO
         LA    R0,S1ORDSL         GET LENGTH TO WRITE               TSO
         L     R1,ASND7171        POINT TO BUFFER TO WRITE          TSO
         TPUT  (1),(0),NOEDIT                                       TSO
         B     RLOOP              START PROCESSING PACKETS          TSO
         SPACE 1                                                    TSO
RNOT7171 WRTERM 'Entering receive mode ...'                         TSO
         WRTERM 'Escape to your local KERMIT and enter the SEND command+
               '                                                    AJR
         STIMER WAIT,BINTVL==F'50' WAIT UNTIL MSG IS DISPLAYED      TSO
RLOOP    CLI       STATE,C'D'          RECEIVE DATA STATE
         BE        RDATA
         CLI       STATE,C'F'          RECEIVE FILE STATE
         BE        RFILE
         CLI       STATE,C'R'          RECEIVE INIT STATE
         BE        RINIT
         CLI       STATE,C'C'          COMPLETE STATE
         BE        RCOMP
         CLI       STATE,C'A'          ABORT STATE
         BE        RABORT
         MVI       ERRNUM,X'02'        UNRECOGNIZED STATE
         B         RABORT              ELSE, DIE
         SPACE 2                                                    TSO
*        PROCESS RECEIVE INIT STATE                                 TSO
         SPACE 1                                                    TSO
RINIT    CLC       NUMTRY,IMXTRY       SEE IF CAN RECEIVE
         BL        ROK1                YES, WE CAN
         MVI       STATE,C'A'          NOPE, GO INTO ABORT STATE
         B         RLOOP
         SPACE 1                                                    TSO
ROK1     L         R3,NUMTRY
         LA        R3,1(R3)            INCREMENT TRIAL COUNTER
         ST        R3,NUMTRY
         TM        LFLAGS,SERVON       In server mode? [13]
         BO        RY1                 Already read in packet [13]
         MVC       CURCHK(1),CHKLEN    Save desired value [8]
         MVI       CHKLEN,X'01'        Init uses 1 char chksum [8]
         L         R15,=A(RPACK)       GET INIT INFORMATION
         BALR      R14,R15
         MVC       CHKLEN(1),CURCHK    Restore desired chksum [8]
         CLI   STATE,C'A'         NEED TO ABORT?                    TSO
         BE    RLOOP              YES                               TSO
         CLI       RTYPE,AE            ERROR PACKET?
         BNE       RY1                 ALL OK
         MVI       ERRNUM,X'0A'        MICRO DIED
         MVI       STATE,C'A'          SO WE DO TOO
         B         RLOOP
         SPACE 1                                                    TSO
RY1      CLI       RTYPE,AS            IS IT A SEND-INIT PACKET
         BNE       RN1                 MAYBE IT GOT CLOBBERED
         L         R5,LRDAT            Number of pieces of data [5]
         L         R15,=A(SPAR)        Read his parameters [5]
         BALR      R14,R15
         MVC       SPKNUM(4),RPKNUM    SYNCH PACKET NUMBERS
         MVI       STYPE,AY            SET MESSAGE TYPE TO ACK
         L         R15,=A(RPAR)        Make packet of our values [5]
         BALR      R14,R15
         ST        R15,LSDAT           Size of packet [5]
         MVC       CURCHK(1),CHKLEN    Save desired value [8]
         MVI       CHKLEN,X'01'        Init uses 1 char chksum [8]
         L         R15,=A(SPACK)       ADDRESS OF SPACK
         BALR      R14,R15             SAVE * AND GO TO SPACK
         MVC       CHKLEN(1),CURCHK    Restore desired chksum [8]
         CLI       STATE,C'A'
         BE        RABORT
         MVI       STATE,C'F'          SET TO RECEIVE FILE STATE
         MVC       OLDTRY(4),NUMTRY    SAVE TRIAL COUNTER
         XC        NUMTRY,NUMTRY       RESET COUNTER TO ZERO
         L         R3,SPKNUM
         LA        R3,1(R3)            ADD ONE
         ST        R3,SPKNUM           STORE VALUE INCREMENTED BY 1
         NC        SPKNUM(4),=X'0000003F'   MASK TO GET MOD 64
         B         RLOOP
         SPACE 1                                                    TSO
RN1      CLI       RTYPE,AN            NAK (bad chksum)?
         BNE       RSELSE
         MVI       STYPE,AN            SEND A NAK PACKET
         XC        LSDAT,LSDAT         NO DATA
         MVC       CURCHK(1),CHKLEN    Save desired value [8]
         MVI       CHKLEN,X'01'        Init uses 1 char chksum [8]
         L         R15,=A(SPACK)
         BALR      R14,R15
         MVC       CHKLEN(1),CURCHK    Restore desired chksum [8]
         B         RLOOP
RSELSE   MVI       STATE,C'A'          ELSE,ABORT
         CLI       ERRNUM,S1ERRNUM     Was it a S/1 I/O error [12]
         BE        RLOOP               Yes just return [12]
         MVI       ERRNUM,X'07'        ILLEGAL PACKET TYPE
         B         RLOOP
         SPACE 2                                                    TSO
*        PROCESS RECEIVE FILE STATE                                 TSO
         SPACE 1                                                    TSO
RFILE    CLC       NUMTRY,MAXTRY       EXCEEDED NO. OF TRIALS ALLOWED
         BL        ROK2                NOPE, STILL OK
         MVI       STATE,C'A'          ABORT IF YES
         B         RLOOP
ROK2     L         R3,NUMTRY
         LA        R3,1(R3)            INCREMENT TRIAL COUNTER
         ST        R3,NUMTRY
         L         R15,=A(RPACK)       GET ADDRESS OF RPACK
         BALR      R14,R15             GO THERE AND RETURN WHEN DONE
         CLI   STATE,C'A'         NEED TO ABORT?                    TSO
         BE    RLOOP              YES                               TSO
         CLI       RTYPE,AE            ERROR PACKET?
         BNE       RY2                 MAYBE AN ACK
         MVI       ERRNUM,X'0A'        MICRO DIED
         MVI       STATE,C'A'          SO WE DO TOO
         B         RLOOP
RY2      CLI       RTYPE,AS            STILL IN INIT STATE?
         BNE       RNZ                 TRY FOR AN EOF
         CLC       OLDTRY,IMXTRY       CAN WE TRY AGAIN? [5]
         BL        ROLD
         MVI       STATE,C'A'          ELSE, ABORT
         B         RLOOP
ROLD     L         R3,OLDTRY
         LA        R3,1(R3)            INCREMENT COUNTER
         ST        R3,OLDTRY
         L         R3,SPKNUM           GET PACKET NUMBER SENT
         BCTR      R3,0                SUBTRACT ONE FROM IT
         C         R3,RPKNUM           RPKNUM MUST EQUAL SPKNUM-1
         BE        RNUM
         MVI       ERRNUM,X'08'        PREVIOUS PACKET MISSING
         B         RNAK                SEND A NAK
RNUM     MVI       STYPE,AY            ACK PACKET
         ST        R3,SPKNUM           MAKE SEND SEQ NO. = SPKNUM-1
         L         R15,=A(RPAR)        Get packet with our values [5]
         BALR      R14,R15
         ST        R15,LSDAT           Size of packet [5]
         L         R15,=A(SPACK)
         BALR      R14,R15             GO TO SPACK AND RETURN
         CLI       STATE,C'A'
         BE        RABORT
         L         R4,SPKNUM
         LA        R4,1(R4)            ADD ONE
         ST        R4,SPKNUM           RESTORE N TO PROPER VALUE
         XC        NUMTRY,NUMTRY       RESET COUNTER TO ZERO
         B         RLOOP
RNZ      CLI       RTYPE,AZ
         BNE       RNF                 MAYBE IT'S AN 'F'
         CLC       OLDTRY,MAXTRY       CAN WE TRY AGAIN?
         BL        ROLD2
         MVI       STATE,C'A'          ELSE,ABORT
         B         RLOOP
ROLD2    L         R3,OLDTRY
         LA        R3,1(R3)            INCREMENT COUNTER
         ST        R3,OLDTRY
         L         R3,SPKNUM           GET PACKET NUMBER SENT
         BCTR      R3,0                SUBTRACT ONE FROM IT
         C         R3,RPKNUM           RPKNUM MUST EQUAL SPKNUM-1
         BE        RNUM2
         MVI       ERRNUM,X'08'        PREVIOUS PACKET MISSING
         B         RNAK                SEND A NAK
RNUM2    MVI       STYPE,AY            ACK PACKET
         ST        R3,SPKNUM           SEND SEQ := SPKNUM-1
         XC        LSDAT,LSDAT         NO DATA
         L         R15,=A(SPACK)
         BALR      R14,R15
         CLI       STATE,C'A'
         BE        RABORT
         L         R4,SPKNUM
         LA        R4,1(R4)            ADD ONE
         ST        R4,SPKNUM           RESTORE SPKNUM TO PROPER VALUE
         XC        NUMTRY,NUMTRY       RESET COUNTER TO ZERO
         B         RLOOP
RNF      CLI       RTYPE,AF
         BNE       RNB                 WELL, IT'S NOT A FNAME
         CLC       RPKNUM,SPKNUM       THEY HAVE TO BE EQUAL
         BE        RNUM3
         MVI       ERRNUM,X'08'        PREVIOUS PACKET MISSING
         B         RNAK                SEND A NAK
RNUM3    MVI       STYPE,AY            ACK PACKET
         XC        LSDAT,LSDAT         NO DATA
         NI    SRFLAGS,255-SRNWNAME  CLEAR NEW NAME INDICATOR       TSO
         MVI       CXZ,X'00'           Clear each time [16]
         TM        FLAGS,FLG2          OVERWRITE THE NAME SENT?
         BO    RENOK              YES                               TSO
         L         R5,LRDAT            Data len to decode [22]
         LTR       R5,R5               CHECK LENGTH
         BZ        SAYNO               DIE IF NO FILENAME
         L         R2,=A(NULDMP)       Null dump routine [22]
         ST        R2,MORDEC           [22]
         XC        OUTBFPT,OUTBFPT     Output buffer offset [22]
         MVC       TEMP,MAXOUT         Save max here [22]
         MVC       MAXOUT,=A(MAXTXT)   Use big number [22]
         L         R15,=A(DECODE)      Decode the input [22]
         BALR      R14,R15             [22]
         MVC       MAXOUT,TEMP         Reset [22]
         L         R5,OUTBFPT          Len of decoded data [22]
         ST        R5,LRDAT            Keep length here [22]
         MVC   FILNM,=44X'20'     INITIALIZE TO ASCII BLANKS        TSO
         L         R9,ARBUF            Location of first char [22]
         LA    R9,4(,R9)          ADJUST FOR VARIABLE RECORD RDW    TSO
         BCTR      R5,0                Decrement for next instr [9]
         EX        R5,GETFN            Copy FN from buffer [9]
         TR    FILNM,ATOE         TRANSLATE TO EBCDIC               TSO
         OC    FILNM,BLANKS       UPPERCASE THE FILE NAME           TSO
         A     R5,=F'5'           ADJUST FOR LENGTH & EXECUTE       TSO
         SLL   R5,16              SHIFT TO UPPER HALF WORD          TSO
         ST    R5,FILNMLEN        SAVE IT HERE TOO                  TSO
         LA    R0,1               INITIALIZE MODIFICATION           TSO
         STH   R0,RPMODFI         VALUE                             TSO
         LA    R10,PPLAREA        GET ADDRESS OF PARSE PARM LIST    TSO
         USING PPL,R10            MAKE IT ADDRESSABLE               TSO
         LA    R1,FILNMCMD        GET COMMAND BUFFER ADDRESS        TSO
         ST    R1,PPLCBUF         PUT ADDRESS OF CMD BUF INTO PPL   TSO
         PARSE FILPARM,ATTN=*+12,ERR=RPINVFIL                       TSO
         CHECKPDL BAD=RPINVFIL                                      TSO
         USING IKJPARMD,R9        MAKE PDL ADDRESSABLE              TSO
         TM    FILDSN+6,X'80'     IS DSNAME PRESENT?                TSO
         BNO   RPINVFIL           NO                                TSO
         LH    R2,FILDSN+4        GET LENGTH OF DSNAME              TSO
         STH   R2,FILNAMLN        SAVE FILE NAME LENGTH             TSO
         STH   R2,NAMELN          SAVE LENGTH HERE ALSO             TSO
         MVC   FILNAM,BLANKS      CLEAR FILE NAME                   TSO
         L     R3,FILDSN          GET ADDRESS OF FILE NAME          TSO
         BCTR  R2,0               ADJUST FOR EX                     TSO
         EX    R2,RPMVDS          SET UP FILE NAME                  TSO
*RPMVDS  MVC   FILNAM(*-*),0(R3)                                    TSO
         MVC   NAME,FILNAM        PRESERVE UNPREFIXED FILE NAME     TSO
         XC    MBRNAMLN,MBRNAMLN  CLEAR MEMBER NAME LENGTH          TSO
         MVC   MBRNAM,BLANKS      CLEAR MEMBER NAME                 TSO
         TM    FILDSN+14,X'80'    IS MEMBER NAME PRESENT?           TSO
         BZ    RPPREFX            NO                                TSO
         LH    R2,FILDSN+12       GET LENGTH OF MEMBER NAME         TSO
         STH   R2,MBRNAMLN        SAVE LENGTH                       TSO
         L     R3,FILDSN+8        GET ADDRESS OF MEMBER NAME        TSO
         BCTR  R2,0               ADJUST FOR EX                     TSO
         EX    R2,RPMVMB          SET UP MEMBER NAME                TSO
*RPMVMB  MVC   MBRNAM(*-*),0(R3)                                    TSO
         SPACE 1                                                    TSO
RPPREFX  TM    FILDSN+6,X'40'     IS DSNAME QUOTED?                 TSO
         BZ    RPBRKUP            NO, GO BREAK DOWN FILE NAME       TSO
         LOCATE DATASET           SEE IF DATA SET EXISTS            TSO
         LTR   R15,R15            WAS DATA SET FOUND?               TSO
         BNZ   RPNEW              NO                                TSO
         B     RPOLD              GO ALLOCATE OLD DATA SET          TSO
         SPACE 1                                                    TSO
RPBRKUP  LA    R2,NAME            GET ADDRESS OF UNPREFIXED FILE    TSO
         LH    R3,NAMELN          GET FILE NAME LENGTH              TSO
RPSCAN   CLI   0(R2),C'.'         IS IT A DELIMITER?                TSO
         BE    RPFIRST            YES, FOUND FIRST LEVEL OF NAME    TSO
         CLI   0(R2),C' '         IS IT A DELIMITER?                TSO
         BE    RPFIRST            YES, FOUND FIRST LEVEL OF NAME    TSO
         LA    R2,1(,R2)          POINT TO NEXT CHARACTER           TSO
         BCT   R3,RPSCAN          CONTINUE LOOKING FOR DELIMITER    TSO
         SPACE 1                                                    TSO
RPFIRST  ST    R2,FIRSTADR        SAVE ADDRESS OF END OF FIRST LEV  TSO
         LA    R3,NAME            POINT TO START OF NAME            TSO
         SR    R2,R3              GET LENGTH OF FIRST LEVEL         TSO
         BNP   RPNOTFND           STRANGE NAME                      TSO
         STH   R2,FIRSTLN         SAVE LENGTH OF FIRST LEVEL        TSO
         LH    R3,NAMELN          GET LENGTH OF WHOLE NAME          TSO
         SR    R3,R2              LENGTH OF REST OF NAME            TSO
         STH   R3,RESTLN          SAVE IT                           TSO
RPNEWNAM LA    R1,FILNAMLN        GET FILE NAME LENGTH              TSO
         L     R15,=A(PREFIXDS)   GET ADDRESS OF PREFIXING ROUTINE  TSO
         BALR  R14,R15            GO PREFIX FILE NAME               TSO
         B     *+4(R15)           BRANCH ON RETURN CODE             TSO
         B     RPOLD              0  - OLD DATA SET                 TSO
         B     RPNEW              4  - NEW DATA SET                 TSO
         B     RPERR              8  - UNABLE TO PREFIX             TSO
         SPACE 1                                                    TSO
RPERR    MVI   ERRNUM,27          SAY "ERROR PREFIXING FILE"        TSO
         MVI   STATE,C'A'         ABORT                             TSO
         B     RLOOP                                                TSO
         SPACE 1                                                    TSO
RPINVFIL MVI   ERRNUM,11          SAY "INVALID FILE NAME"           TSO
         MVI   STATE,C'A'         ABORT                             TSO
         B     RLOOP                                                TSO
         SPACE 1                                                    TSO
RPOLD    TM    LFLAGS,WARFL       CAN WE OVERWRITE EXISTING FILE?   TSO
         BNO   RPOK               YES                               TSO
         TM    FILDSN+6,X'40'     IS DSNAME QUOTED?                 TSO
         BO    RPQUOTED           YES, CAN'T OVERWRITE QUOTED FILE  TSO
         NC    MBRNAMLN,MBRNAMLN  IS THIS A PDS?                    TSO
         BNZ   RPOK               YES, ALTER MEMBER NAME INSTEAD    TSO
         MVC   FILNAM,BLANKS      CLEAR FILE NAME                   TSO
         LH    R2,RPMODFI         GET CURRENT MODIFIER              TSO
         CVD   R2,CVDDBLWD        CONVERT IT                        TSO
         OI    CVDDBLWD+7,X'0F'                                     TSO
         UNPK  FILNAM(8),CVDDBLWD START BUILDING FILE NAME          TSO
         UNPK  NAMEMOD,CVDDBLWD   GET MODIFIER IN PRINTABLE FORM    TSO
         L     R3,FIRSTADR        GET ADDRESS OF REST OF NAME       TSO
         LH    R2,RESTLN          GET LENGTH OF REST OF NAME        TSO
         LTR   R2,R2              IS THERE ANY MORE?                TSO
         BNP   RPOVLY             NO                                TSO
         BCTR  R2,0               ADJUST FOR EX                     TSO
         EX    R2,RPMVRST         PUT IN REST OF NAME               TSO
*RPMVRST MVC   FILNAM+8(*-*),0(R3)                                  TSO
RPOVLY   LH    R2,FIRSTLN         GET LENGTH OF FIRST LEVEL         TSO
         CH    R2,=H'7'           IS LENGTH SHORTER THAN MAX?       TSO
         BL    RPMODIT            YES, OVERLAY NAME                 TSO
         LA    R2,6               MAX LENGTH OF NAME TO MOVE        TSO
         CLI   NAMEMOD,C'0'       IS IT A DOUBLE DIGIT MODIFIER?    TSO
         BE    RPMODONE           NO,  ONLY A SINGLE DIGIT          TSO
RPMODIT  BCTR  R2,0               MOVE ENOUGH TO MAKE DOUBLE DIGIT  TSO
RPMODONE EX    R2,RPMODIF         MOVE IN PORTION OF ORIGINAL NAME  TSO
*RPMODIF MVC   FILNAM(*-*),NAME                                     TSO
         LH    R2,RPMODFI         GET MODIFICATION VALUE            TSO
         LA    R2,1(,R2)          BUMP BY ONE                       TSO
         STH   R2,RPMODFI         PUT IT BACK                       TSO
         LA    R2,8               GET LENGTH OF FIRST LEVEL OF NAME TSO
         AH    R2,RESTLN          ADD LENGTH OF REST OF NAME        TSO
         STH   R2,FILNAMLN        SET NEW FILE NAME                 TSO
         OI    SRFLAGS,SRNWNAME   INDICATE NEW NAME FORMED          TSO
         B     RPNEWNAM           GO TRY MODIFIED NAME              TSO
         SPACE 1                                                    TSO
*        ALLOCATE THE DATA SET
         SPACE 1
RPOK     DS    0H                                                   TSO
         L     R15,=V(PDSCHK)     GET ADDRESS OF PDS CHECK ROUTINE  TSO
         BALR  R14,R15            GO SEE IF THIS IS A PDS           TSO
         B     *+4(R15)           BRANCH ON RETURN CODE             TSO
         B     RPAOLD             PDS, GO ALLOCATE                  TSO
         B     RPAOLD             NON-PDS, GO ALLOCATE              TSO
         MVI   STATE,C'A'         ABORT                             TSO
         B     RLOOP                                                TSO
         SPACE 1                                                    TSO
RPAOLD   LA    R8,ALLOCCB         POINT TO ALLOCATION CONTROL BLOCK TSO
         USING ALCCB,R8           MAKE IT ADDRESSABLE               TSO
         LA    R0,ALCTOLD         INDICATE "OLD" ALLOCATION         TSO
         ST    R0,ALCTYPE         PUT INTO ALCCB                    TSO
         B     RPALCDS            GO ALLOCATE THE FILE              TSO
         SPACE 1                                                    TSO
RPNEW    LA    R8,ALLOCCB         POINT TO ALLOCATION CONTROL BLOCK TSO
         LA    R0,ALCTNEW         INDICATE "NEW" ALLOCATION         TSO
         ST    R0,ALCTYPE         PUT INTO ALCCB                    TSO
RPALCDS  LA    R0,FILNAMLN        GET ADDRESS OF FILE NAME & LENGTH TSO
         ST    R0,ALCDSN          PUT INTO ALCCB                    TSO
         XC    ALCMEMBR,ALCMEMBR  ASSUME NO MEMBER NAME             TSO
         SR    R0,R0              CLEAR FOR ICM                     TSO
         ICM   R0,3,MBRNAMLN      GET LENGTH OF MEMBER NAME         TSO
         BZ    RPALC              NO MEMBER NAME; DO ALLOCATE       TSO
         LA    R0,MBRNAMLN        GET ADDRESS OF MEMBER NAME        TSO
         ST    R0,ALCMEMBR        PUT INTO ALCCB                    TSO
RPALC    IKJRLSA PDLADDR          RELEASE THE PDL                   TSO
         XC    PDLADDR,PDLADDR    CLEAR THE PDL ADDRESS             TSO
         LR    R1,R8              PASS ADDRESS OF ALCCB             TSO
         L     R15,=A(ALLOCDSN)   GET ALLOCATE ROUTINE ADDRESS      TSO
         BALR  R14,R15            GO ALLOCATE THE DATA SET          TSO
         B     *+4(R15)           BRANCH ON RETURN CODE             TSO
         B     RPOPEN             0  -  ALLOCATION SUCCESSFUL       TSO
         B     RPNOTFND           4  -  DATA SET NOT FOUND          TSO
         B     RPALCERR           8  -  ALLOCATION ERROR            TSO
         B     RPINCOMP           12 -  INCOMPATIBLE DATA SET TYPES TSO
         B     RPUNSUPT           16 -  UNSUPPORTED DATA SET TYPE   TSO
         SPACE 1                                                    TSO
RPNOREN  MVI   ERRNUM,20          SAY "CANNOT REASSIGN FILE"        TSO
         MVI   STATE,C'A'                                           TSO
         B     RLOOP                                                TSO
         SPACE 1                                                    TSO
RPNOTFND MVI   ERRNUM,21          SAY "FILE NOT FOUND"              TSO
         MVI   STATE,C'A'         SET ABORT STATE                   TSO
         B     RLOOP                                                TSO
         SPACE 1                                                    TSO
RPALCERR MVI   ERRNUM,28          SAY "ERR ALLOCATING FILE"         TSO
         MVI   STATE,C'A'         SET ABORT STATE                   TSO
         B     RLOOP                                                TSO
         SPACE 1                                                    TSO
RPINCOMP MVI   ERRNUM,14          SAY "INCOMPAT FILE TYPE"          TSO
         MVI   STATE,C'A'         SET ABORT STATE                   TSO
         B     RLOOP                                                TSO
         SPACE 1                                                    TSO
RPUNSUPT MVI   ERRNUM,30          SAY "UNSUPPORTD FILE TYPE"        TSO
         MVI   STATE,C'A'         SET ABORT STATE                   TSO
         B     RLOOP                                                TSO
         SPACE 1                                                    TSO
RPQUOTED MVI   ERRNUM,37          SAY "CANNOT OVERWRITE QUOTED FILE"TSO
         MVI   STATE,C'A'         SET ABORT STATE                   TSO
         B     RLOOP                                                TSO
         SPACE 1                                                    TSO
*        OPEN THE DATASET                                           AJR
         SPACE 1                                                    AJR
RPOPEN   MVC   SENDRCV+40(8),BLANKS  CLEAR DCB DDNAME               TSO
         LR    R2,R0              SAVE LENGTH OF DDNAME             TSO
         BCTR  R2,0               ADJUST FOR EX                     TSO
         EX    R2,RPMVDDN         PUT DDNAME INTO DCB               TSO
*RPMVDDN MVC   SENDRCV+40(*-*),0(R1)                                TSO
         SR    R0,R0              CLEAR EODAD ROUTINE ADDRESS       TSO
         STCM  R0,7,SENDRCV+(DCBEODA-IHADCB)  PUT INTO DCB          TSO
         STCM  R0,7,SENDRCV+(DCBSYNA-IHADCB)  CLEAR SYNAD ADDRESS   TSO
         OPEN  (SENDRCV,OUTPUT)   OPEN THE DATA SET FOR OUTPUT      TSO
         TM    SENDRCV+(DCBOFLGS-IHADCB),DCBOFOPN  OPEN SUCCESSFUL  TSO
         BNO   RPOPERR            NO                                AJR
DT3350   CLI   SENDRCV+(DCBDEVT-IHADCB),X'2B'   DEVTYPE=3350?       AJR
         BNE   DT3330             NO                                AJR
         CLC   BLKSIZE,=H'19069'  BLOCKSIZE GREATER THAN TRACKSIZE? AJR
         BNH   RENOK0             NO, CONTINUE RECEIVE OPERATION    AJR
         B     RPTRKERR           YES, SAY SO                       AJR
DT3330   CLI   SENDRCV+(DCBDEVT-IHADCB),X'29'   DEVTYPE=3330 MOD 1? AJR
         BNE   DT333011           NO                                AJR
         CLC   BLKSIZE,=H'13030'  BLOCKSIZE GREATER THAN TRACKSIZE? AJR
         BNH   RENOK0             NO, CONTINUE RECEIVE OPERATION    AJR
         B     RPTRKERR           YES, SAY SO                       AJR
DT333011 CLI   SENDRCV+(DCBDEVT-IHADCB),X'2D'   DEVTYPE=3330 MOD11? AJR
         BNE   RENOK0             ALL COMMON SMALL DEVICES COVERED  AJR
         CLC   BLKSIZE,=H'13030'  BLOCKSIZE GREATER THAN TRACKSIZE? AJR
         BNH   RENOK0             NO, CONTINUE RECEIVE OPERATION    AJR
RPTRKERR MVI   ERRNUM,36          SAY "BLKSIZE > TRACKSIZE"         AJR
         B     RPOPERR2           DIE                               AJR
RPOPERR  MVI   ERRNUM,29          SAY "ERROR OPENING FILE"          TSO
RPOPERR2 MVI   STATE,C'A'         SET ABORT STATE                   TSO
         UNALLOC DSNAME,ADDR=ALCDSN  UNALLOCATE THE DATA SET        TSO
         B     RLOOP                                                TSO
         SPACE 1                                                    TSO
RPMVDDN  MVC   SENDRCV+40(*-*),0(R1)                                TSO
         SPACE 1                                                    TSO
RENOK0   TM    SRFLAGS,SRNWNAME   WAS NEW NAME FORMED?              TSO
         BZ    RENOK              NO                                TSO
         L     R1,ASDAT           GET ADDRESS OF SDAT               TSO
         MVC   0(L'RPNWFIL,R1),RPNWFIL  PUT IN FIRST OF MESSAGE     TSO
         LH    R2,NAMELN          GET LENGTH OF FILE NAME           TSO
         BCTR  R2,0               ADJUST FOR EX                     TSO
         EX    R2,RPMVFIL         PUT FILE NAME INTO MESSAGE        TSO
*RPMVFIL MVC   L'RPNWFIL(*-*,R1),NAME                               TSO
         LA    R2,L'RPNWFIL(,R2)  GET LENGTH OF MESSAGE             TSO
         EX    R2,RPTRMSG         TRANSLATE MSG TO ASCII            TSO
*RPTRMSG TR    0(*-*,R1),ETOA                                       TSO
         LA    R2,1(,R2)          READJUST FOR EX                   TSO
         ST    R2,LSDAT           SAVE LENGTH OF DATA FOR SPACK     TSO
RENOK    L         R15,=A(SPACK)
         BALR      R14,R15             SEND ACK
         CLI       STATE,C'A'
         BE        RABORT
         MVC       OLDTRY(4),NUMTRY    KEEP NUMTRY FOR LATER
         XC        NUMTRY,NUMTRY       RESET TO ZERO
         L         R3,SPKNUM
         LA        R3,1(R3)            ADD ONE
         ST        R3,SPKNUM           INCREMENT COUNTER
         NC        SPKNUM(4),=X'0000003F'   MASK TO GET MOD 64
         MVI       STATE,C'D'          DATA RECEIVE STATE
         XC        OUTBFPT,OUTBFPT     Init output buffer pointer [6]
         B         RLOOP
RNB      CLI       RTYPE,AB            SEE IF IT'S A BREAK
         BNE       RNN                 MAYBE GOT A NAK
         CLC       RPKNUM,SPKNUM
         BE        RNUM4
         MVI       ERRNUM,X'08'        PREVIOUS PACKET MISSING
         B         RNAK                SEND A NAK
RNUM4    MVI       STYPE,AY            ACK PACKET
         XC        LSDAT,LSDAT         NO DATA
         L         R15,=A(SPACK)
         BALR      R14,R15
         CLI       STATE,C'A'
         BE        RABORT
         MVI       STATE,C'C'          COMPLETE STATE
         CLI       CXZ,X'00'           Other side kill x-fer? [16]
         BE        RLOOP               No end OK [16]
         MVI       STATE,C'A'          Else remember error [16]
         B         RLOOP
RNN      CLI       RTYPE,AN            SEE IF GOT A NAK
         BNE       RNELSE
RNAK     MVI       STYPE,AN            SEND A NAK PACKET
         XC        LSDAT,LSDAT         NO DATA
         L         R15,=A(SPACK)
         BALR      R14,R15
         B         RLOOP               DO NOTHING ON A NAK
RNELSE   MVI       STATE,C'A'          ABORT OTHERWISE
         CLI       ERRNUM,S1ERRNUM     Was it a S/1 I/O error [12]
         BE        RLOOP               Yes just return [12]
         MVI       ERRNUM,X'07'        ILLEGAL PACKET TYPE
         B         RLOOP
         SPACE 2                                                    TSO
*        PROCESS RECEIVE DATA STATE                                 TSO
         SPACE 1                                                    TSO
RDATA    CLC       NUMTRY,MAXTRY       HAVE WE EXCEEDED OUR LIMIT?
         BL        ROK3
         MVI       STATE,C'A'          ELSE, ABORT
         B         RLOOP
ROK3     L         R4,NUMTRY
         LA        R4,1(R4)            INCREMENT
         ST        R4,NUMTRY           SAVE INCREMENTED COUNTER
         L         R15,=A(RPACK)
         BALR      R14,R15             CALL RPACK
         CLI   STATE,C'A'         NEED TO ABORT?                    TSO
         BE    RLOOP              YES                               TSO
         CLI       RTYPE,AE            ERROR PACKET?
         BNE       RY3                 MAYBE AN ACK
         MVI       ERRNUM,X'0A'        MICRO DIED
         MVI       STATE,C'A'          WE ABORT TOO
         B         RLOOP
RY3      CLI       RTYPE,AD            IS THIS A DATA PACKET?
         BNE       RDF                 MAYBE IT'S AN FNAME PACKET
         CLC       SPKNUM,RPKNUM       CHECK FOR RIGHT PACKET
         BNE       DIF
         L         R15,=A(PTCHR)
         BALR      R14,R15             PUT CHARACTERS INTO FILE
         LTR       R15,R15             CHECK FOR NO ERROR [6]
         BZ        OKWR                NO ERROR
         MVI       STATE,C'A'          ABORT ON FILE SYSTEM ERROR
         B         RLOOP
OKWR     MVI       STYPE,AY            ACK PACKET
         XC        LSDAT,LSDAT         NO DATA
         L         R15,=A(SPACK)
         BALR      R14,R15
         CLI       STATE,C'A'
         BE        RABORT
         MVC       OLDTRY(4),NUMTRY    SAVE NUMTRY'S VALUE IN OLDTRY
         XC        NUMTRY,NUMTRY       RESET NUMTRY
         L         R3,SPKNUM
         LA        R3,1(R3)
         ST        R3,SPKNUM           INCREMENT COUNTER
         NC        SPKNUM(4),=X'0000003F'   MASK TO GET MOD 64
         B         RLOOP
DIF      CLC       OLDTRY,MAXTRY       CAN WE DO IT?
         BL        DIFNUM
         MVI       STATE,C'A'          AND ABORT
         B         RLOOP
DIFNUM   L         R4,OLDTRY
         LA        R4,1(R4)
         ST        R4,OLDTRY           INCREMENT THIS COUNTER
         L         R4,SPKNUM
         BCTR      R4,0
         C         R4,RPKNUM           RPKNUM MUST EQUAL SPKNUM-1
         BE        DIFOK
         MVI       ERRNUM,X'08'        PREVIOUS PACKET MISSING
         B         RDN1                SEND A NAK
DIFOK    XC        NUMTRY,NUMTRY       RESET COUNTER TO ZERO
         MVI       STYPE,AY            ACK PACKET
         XC        LSDAT,LSDAT         NO DATA
         ST        R4,SPKNUM           DECREMENT TO RESEND PACKET
         L         R15,=A(SPACK)
         BALR      R14,R15             SEND THE PACKET
         CLI       STATE,C'A'
         BE        RABORT
         L         R4,SPKNUM
         LA        R4,1(R4)            ADD ONE
         ST        R4,SPKNUM           RESTORE TO PROPER VALUE
         B         RLOOP               AND RETURN
RDF      CLI       RTYPE,AF            SENDING FILENAME AGAIN?
         BNE       RDZ
         CLC       OLDTRY,MAXTRY       CAN WE DO IT?
         BL        FILOVER             TRYING IT AGAIN
         MVI       STATE,C'A'          IF NO, ABORT
         B         RLOOP
FILOVER  L         R4,OLDTRY
         LA        R4,1(R4)
         ST        R4,OLDTRY           SAVE INCREMENTED VALUE
         L         R4,SPKNUM
         BCTR      R4,0                NEED VALUE OF N-1
         C         R4,RPKNUM           SPKNUM-1 MUST EQUAL RPKNUM
         BE        FILOK
         MVI       ERRNUM,X'08'        PREVIOUS PACKET MISSING
         B         RDN1                SEND A NAK
FILOK    XC        NUMTRY,NUMTRY       RESET TO ZERO
         XC        LSDAT,LSDAT         NO DATA
         MVI       STYPE,AY            ACK PACKET AGAIN
         ST        R4,SPKNUM           DECREMENT FOR NOW
         L         R15,=A(SPACK)
         BALR      R14,R15
         CLI       STATE,C'A'
         BE        RABORT
         L         R4,SPKNUM
         LA        R4,1(R4)            ADD ONE
         ST        R4,SPKNUM           RESTORE TO PROPER VALUE
         B         RLOOP               AND RETURN
RDZ      CLI       RTYPE,AZ            IS THIS AN EOF PACKET?
         BNE       RDN
         CLC       SPKNUM,RPKNUM       ARE THEY EQUAL
         BE        RDOK
         MVI       ERRNUM,X'08'        PREVIOUS PACKET MISSING
         B         RDN1                SEND A NAK
RDOK     CLC       LRDAT,ONE           One piece of data [16]
         BNE       RDWR                No go write out file [16]
         L    R3,ARDAT            POINT TO DATA                     TSO
         CLI       0(R3),AD            "D" for discard [16]
         BNE       RDWR                No write out file [16]
         MVI       ERRNUM,X'17'        Receive cancelled [16]
         MVI       CXZ,X'FF'           Remember that [16]
         B         RDXX                Pick up later on [16]
* If data left in buffer when get EOF packet, write remaining
* data out to the file.      [1]
RDWR     CLC       OUTBFPT,ZERO        HOW MUCH DATA LEFT [1]
         BE    BUFMT              NONE LEFT, SEND ACK               TSO
         L         R9,OUTBFPT          NUMBER OF CHARS IN BUFFER [1]
         L         R15,=A(OUTBUF)      WRITE OUT BUFFER [1] [6]
         BALR      R14,R15             GO TO IT [1]
         LTR       R15,R15             CHECK RETCODE [1]
         BZ    BUFMT              WORKED OK                         TSO
         MVI       STATE,C'A'          FILE SYSTEM ERROR [1]
         B         RLOOP               SO DIE [1]
BUFMT    CLOSE (SENDRCV)          CLOSE THE FILE                    TSO
         FREEPOOL SENDRCV         FREE THE QSAM BUFFER POOL         TSO
         LA    R8,ALLOCCB         GET ADDRESS OF ALLOCATION CB      TSO
         USING ALCCB,R8           MAKE IT ADDRESSABLE               TSO
         UNALLOC DSNAME,ADDR=ALCDSN  UNALLOCATE THE FILE            TSO
         DROP  R8                 DROP ALLOCCB ADDRESSABILITY       TSO
         SPACE 1                                                    TSO
RDXX     MVI       STYPE,AY            ACK THE PACKET  [1]
         XC        LSDAT,LSDAT         NO DATA
         L         R15,=A(SPACK)
         BALR      R14,R15
         MVC       OLDTRY(4),NUMTRY    SAVE NUMTRY'S VALUE HERE
         XC        NUMTRY,NUMTRY       AND RESET COUNTER
         L         R3,SPKNUM
         LA        R3,1(R3)
         ST        R3,SPKNUM           STORE VALUE INCREMENTED BY 1
         NC        SPKNUM(4),=X'0000003F'   MASK TO GET MOD 64
         MVI       STATE,C'F'          TRY FOR ANOTHER FILE
         NI        FLAGS,X'FF'-FLG2    Only change first file [9]
         B         RLOOP
RDN      CLI       RTYPE,AN            DO WE NEED TO SEND A NAK?
         BNE       RDELSE
RDN1     MVI       STYPE,AN            SEND A NAK
         XC        LSDAT,LSDAT         NO DATA
         L         R15,=A(SPACK)
         BALR      R14,R15
         B         RLOOP
RDELSE   MVI       STATE,C'A'          UNRECOGNIZED PACKET - ABORT
         CLI       ERRNUM,S1ERRNUM     Was it a S/1 I/O error [12]
         BE        RLOOP               Yes just return [12]
         MVI       ERRNUM,X'07'        ILLEGAL PACKET TYPE
         B         RLOOP
SAYNO    MVI       STYPE,AN            SEND A NAK PACKET
         XC        LSDAT,LSDAT         NO DATA
         MVI       ERRNUM,X'0B'        ILLEGAL FILENAME ERROR
         L         R15,=A(SPACK)
         BALR      R14,R15
         B         RLOOP
*
         SPACE 2                                                    TSO
*        PROCESS RECEIVE ABORT STATE                                TSO
         SPACE 1                                                    TSO
RABORT   DS    0H                                                   TSO
         CLI       ERRNUM,X'0A'        DID THE MICRO DIE?
         BE        RNOERRP             NO ERROR PACKET IF SO
         CLI       ERRNUM,X'17'        Other side cancel receive [16]
         BE        RNOERRP             Yes no error packet [16]
* At least try to send an error packet.
*        CLI       ERRNUM,S1ERRNUM     Was it a S/1 I/O error [12]
*        BE        RNOERRP             Yes just return [12]
         L         R15,=A(ERRPACK)     Send error packet [13]
         BALR      R14,R15             Error number in ERRNUM [13]
RNOERRP  LA        R15,4               SET A NON-ZERO RETCODE
         B         RECRET              PREPARE TO LEAVE
         SPACE 2                                                    TSO
*        PROCESS RECEIVE COMPLETE STATE                             TSO
         SPACE 1                                                    TSO
RCOMP    SR        R15,R15             RETCODE OF ZERO
RECRET   DS    0H                                                   TSO
         NI    LFLAGS,255-RECVON  TURN OFF RECEIVE MODE             TSO
         TM    S1FLAGS,ISS1       IS IT SERIES-1/IBM7171?           TSO
         BZ    RNO7171            NO                                TSO
         PUTCRSR ROW=21,COLUMN=1  POSITION CURSOR AFTER TRANSFER    TSO
         STFSMODE OFF             TURN OFF FULL SCREEN MODE         TSO
         OI    SRFLAGS,SRCLRSCR   TURN ON CLEAR SCREEN FLAG         TSO
RNO7171  RET   ,                                                    TSO
         SPACE 1                                                    TSO
GETFN    MVC   FILNM(*-*),0(R9)   MOVE FILE NAME                    TSO
RPMVMB   MVC   MBRNAM(*-*),0(R3)                                    TSO
RPMVDS   MVC   FILNAM(*-*),0(R3)                                    TSO
RPMODIF  MVC   FILNAM(*-*),NAME                                     TSO
RPMVRST  MVC   FILNAM+8(*-*),0(R3)                                  TSO
RPMVFIL  MVC   L'RPNWFIL(*-*,R1),NAME                               TSO
RPTRMSG  TR    0(*-*,R1),ETOA                                       TSO
         SPACE 1                                                    TSO
FIRSTADR DC    A(0)               ADDRESS OF END OF FIRST LEVEL     TSO
FIRSTLN  DC    H'0'               LENGTH OF FIRST LEVEL             TSO
RESTLN   DC    H'0'               LENGTH OF REST OF NAME            TSO
NAMEMOD  DC    CL2' '             EBCDIC MODIFICATION VALUE         TSO
RPNWFIL  DC    C'New file name is '                                 TSO
         SPACE 1                                                    TSO
FILNMCMD DS    0F                 TEMPORARY COMMAND BUFFER          TSO
FILNMLEN DC    H'0'               LENGTH OF DATA                    TSO
         DC    H'0'                                                 TSO
FILNM    DC    CL44' '            DATA AREA                         TSO
         SPACE 1                                                    TSO
         DROP  R9                 DROP PDL ADDRESSABILITY           TSO
         DROP  R10                DROP PPL ADDRESSABILITY           TSO
         PRINT NOGEN                                                TSO
FILPARM  IKJPARM ,                                                  TSO
FILDSN   IKJPOSIT DSNAME                                            TSO
         IKJENDP ,                                                  TSO
         PRINT NOGEN                                                TSO
         EXIT  ,                                                    TSO
         TITLE '(PTCHR) Write data to file'                         TSO
* Write data out to a file. [6]
PTCHR    ENTER ,                                                    TSO
         L         R2,=A(OUTBUF)       Routine to call to [22]
         ST        R2,MORDEC           dump decoded data [22]
         L         R5,LRDAT            Amount of input data
         L         R15,=A(DECODE)
         BALR      R14,R15
         RET   ,                                                    TSO
         EXIT  ,
         TITLE '(DECODE)  Decode packet'                            TSO
* Expects R5 to contain size of input data.  Other registers used:
* R4 - quote character, R8 - input buffer pointer, R9 - output
* buffer pointer (get value from OUTBFPT).  Expects input to be in
* buffer RDAT and write out to buffer whose address in in ARBUF. [6]
         SPACE 3                                                    TSO
DECODE   ENTER ,                                                    TSO
         L    R10,ARDAT           GET ADDRESS OF RDAT               TSO
         SR        R4,R4               Use to hold quote char
         IC        R4,SQUOTE
         SR        R8,R8               Input buffer pointer
         L         R9,OUTBFPT          Output buffer pointer
DECOD0   MVI       RPTCT,X'00'         Reset each time [7]
         MVI       RPTVAL,X'00'        Ditto [7]
         SR        R7,R7               Use to pick up char
         LTR       R5,R5               Any more data left?
         BNZ       DECOD1              Leave if all done
         ST        R9,OUTBFPT          Save place in output buffer
         SR        R15,R15             OK return code
         B         DECOD8              And return to caller
         SPACE 1                                                    TSO
DECOD1   L     R1,MAXOUT          GET MAXIMUM RECORD LENGTH         TSO
         CLI   RTYPE,AF           FILE PACKET?                      AJR
         BE    DECOD1A            YES                               AJR
         CLI   TYPFIL,C'V'        V-BINARY ?                        AJR
         BE    DECOD1D            YES                               AJR
         TM    SENDRCV+(DCBRECFM-IHADCB),DCBRECV         RECFM=F?   AJR
         BZ    DECOD1A            YES, LEAVE MAX DATA LENGTH AS IS  AJR
         TM    SENDRCV+(DCBRECFM-IHADCB),DCBRECU         RECFM=U?   AJR
         BO    DECOD1A            YES, LEAVE MAX DATA LENGTH AS IS  AJR
         S     R1,=F'4'           ACCOUNT FOR LENGTH OF RDW         TSO
         B     DECOD1A            GO DO IT                          AJR
DECOD1D  LTR   R9,R9              STARTED YET?                      AJR
         BZ    DECOD1A            NO                                AJR
         LA    R2,2               ACCOUNT FOR IMBEDDED LENGTH (LL)  AJR
         CR    R9,R2              DECODED LENGTH YET?               AJR
         BNE   DECOD1A            NO                                AJR
         L     R15,ARBUF          JUST DECODED LENGTH               AJR
         SR    R14,R14                                              AJR
         ICM   R14,3,4(15)        GET "TRUE" DATA LENGTH (LL)       AJR
         TM    SENDRCV+(DCBRECFM-IHADCB),DCBRECU         RECFM=U?   AJR
         BNO   DECOD1C            NO, RECFM=V                       AJR
         LA    R15,8              SET ERROR CODE IN CASE OF ERROR   AJR
         CH    R14,BLKSIZE        MUST NOT BE GREATER THAN BLKSIZE  AJR
         BNH   DECOD1B            OK                                AJR
         B     DECODERR           ERROR RETURN                      AJR
         SPACE 1                                                    AJR
DECOD1C  S     R14,=F'4'          ACCOUNT FOR LENGTH OF RDW         AJR
DECOD1B  AR    R14,R9             ADD 2 BYTES FOR LL                AJR
         LR    R1,R14             SET MAX LIMIT                     AJR
         ST    R14,MAXOUT         SAVE IT                           AJR
         B     DECOD1A                                              AJR
         SPACE 1                                                    AJR
DECOD1A  CR    R9,R1              MAXOUT REACHED?                   AJR
         BNL       DECOD7              YES,write it out             AJR
         CLI       RPTCT,X'00'         Doing a repeat [7]
         BE        DECOD11             No so get a char [7]
         XC        PAR,PAR             Clear the parity flag [7]
         IC        R7,RPTVAL           Get char we're repeating [7]
         TM        FLAGS,BINF          In binary mode? [25]
         BO        DECOD6              Yes no check for eol [25]
         CLI       RPTVAL,ACR          Ascii CR  [25]
         BE        DECOD7              Yes, write another record [25]
         CLI       RPTVAL,ALF          Ascii LF [25]
         BE        DECOD7              Yes, write another record [25]
         B         DECOD6              Write out to file [7]
DECOD11  BCTR      R5,0                Decrement char counter
         IC   R7,0(R8,R10)        GET CHARACTER FROM RDAT BUFFER    TSO
         XC        PAR,PAR             Assume hi bit=0 [1 start]
         CLI       RPTQ,X'00'          Doing repeat quoting [7]
         BE        DECOD12             No so skip next part [7]
         CLM       R7,B'0001',RPTQ     Picked up repeat quote char? [7]
         BNE       DECOD12             No continue processing [7]
         LA        R8,1(R8)            Bump input pointer [7]
         BCTR      R5,0                Modify buffer count [7]
         SR        R7,R7               Zero it out [7]
         IC   R7,0(R8,R10)        GET SIZE FROM RDAT BUFFER         TSO
         S         R7,=F'32'           Was made printable [7]
         STC       R7,RPTCT            Remember no. of repetitions [7]
         LA        R8,1(R8)            Bump input pointer [7]
         BCTR      R5,0                Modify buffer count [7]
         IC   R7,0(R8,R10)        GET REPEATED CHAR FROM RDAT       TSO
DECOD12  CLI       EBQUOT,AN           Are we doing 8-bit quoting?
         BE        DECOD2              Nope
         CLI       EBQUOT,AY           Can we do it but aren't?
         BE        DECOD2              Yes - so just forget it
         CLM       R7,B'0001',EBQUOT   Did we get 8-bit quote char?
         BNE       DECOD2              No - continue as usual
         BCTR      R5,0                Decrement no. of chars left
         LA        R8,1(R8)            Bump input pointer
         IC   R7,0(R8,R10)        GET QUOTED CHAR FROM RDAT         TSO
         MVI       PAR+3,X'80'         Set hi order bit on [1 end]
DECOD2   CR        R7,R4               Is it the quote character?
         BNE       DECOD6              No it's a regular char
         BCTR      R5,0                Else decrement char count
         LA        R8,1(R8)            Bump input pointer
         IC   R7,0(R8,R10)        GET SPECIAL CHAR FROM RDAT        TSO
         CLC       PAR,ZERO            If PAR <> 0 don't check [1]
         BNE       DECOD4              For CR/LF (it's 8A,8D) [1]
         TM        FLAGS,BINF          No check if binary mode [1]
         BO        DECOD4              Just skip it [1]
         C         R7,=X'0000004D'     Is it a CR? (CHAR(CR))
         BNE       DECOD3              No, check for LF
         MVI       PREV,X'4D'          Yes, remember we saw a CR
         LA        R8,1(R8)            Bump input pointer
         MVI       RPTVAL,ACR          Set in case of repeats [25]
         B         DECOD7              Write out record
DECOD3   C         R7,=X'0000004A'     Should we write out on LF?
         BNE       DECOD4              No keep going
         LA        R8,1(R8)            Bump input pointer
         CLI       PREV,X'4D'          Was last char CR?
         BE        DECOD0              Yes, so ignore LF
         MVI       RPTVAL,ALF          Set in case of repeats [25]
         B         DECOD7              Nope, so write out record
DECOD4   CR        R7,R4               Is it the quote char
         BE        DECOD6              Don't convert if yes
         CLI       EBQUOT,AN           Doing 8-bit quoting [1 start]
         BE        DECOD5              No don't check for quote char
         CLI       EBQUOT,AY           Can do it but aren't?
         BE        DECOD5              Yup-don't check for quote char
         CLM       R7,B'0001',EBQUOT   Is char the 8-bit quote char?
         BE        DECOD6              Yes - so don't convert
         CLI       RPTQ,X'00'          Doing repeat counts
         BE        DECOD5              No check for quote char [7]
         CLM       R7,B'0001',RPTQ     Is it the repeat quote char [7]
         BE        DECOD6              Yes, don't convert [7]
DECOD5   A         R7,O1H              Else add ^O100
         N         R7,=X'0000007F'     Get modulo ^O200
         NOP   DECOD6A                                              TSO
DECOD6   DS    0H                                                   TSO
         CLI   TABSWI,1           TAB EXPANSION IN EFFECT?          TSO
         BNE   DECOD6A            NO                                TSO
         TM    FLAGS,BINF         IN BINARY MODE?                   TSO
         BO    DECOD6A            YES, DO NO TAB EXPANSION          TSO
         CLM   R7,1,=X'09'        ASCII TAB?                        TSO
         BNE   DECOD6A            NO, CONTINUE                      TSO
         LH    R2,TABCOUNT        GET COUNT OF TABS THAT ARE SET    TSO
         LA    R3,TABTBL          POINT TO TABLE OF TABS            TSO
         SR    R6,R6              CLEAR FOR IC                      TSO
DECOD6LP IC    R6,0(,R3)          GET TAB CHARACTER FROM TABLE      TSO
         BCTR  R6,0               ADJUST FOR DISPLACEMENT COMPARE   TSO
         CR    R6,R9              WHERE IS THIS TAB COMPARED TO BUF TSO
         BE    DECOD6A2           RIGHT ON IT                       TSO
         BH    DECOD6A1           ABOVE BUFFER POSITION             TSO
         LA    R3,1(,R3)          POINT TO NEXT TAB POSITION        TSO
         BCT   R2,DECOD6LP        CONTINUE WITH NEXT TAB            TSO
         B     DECOD6A            NO MORE TABS, STORE THE CHAR      TSO
         SPACE 1                                                    TSO
DECOD6A1 SR    R6,R9              GET NUMBER BLANKS FOR EXPANSION   TSO
         BCTR  R6,0               ADJUST FOR EX                     TSO
         L     R1,ARBUF           GET OUTPUT BUFFER ADDRESS         TSO
         AR    R1,R9              PLUS DISPLACEMENT                 TSO
         LA    R1,4(,R1)          ACCOUNT FOR VARIABLE LENGTH RDW   TSO
         EX    R6,EXPND           MOVE IN BLANKS                    TSO
*EXPND   MVC   0(*-*,R1),ASCIBLNK                                   TSO
         LA    R9,1(R6,R9)        ADJUST OUTPUT BUFFER DISPLACEMENT TSO
         B     DECOD6A2           CONTINUE                          TSO
         SPACE 1                                                    TSO
DECOD6A  O     R7,PAR             OR IN THE PARITY BIT              TSO
         L         R1,ARBUF            Output buffer address [2]
         AR        R1,R9               Plus displacement [2]
         LA    R1,4(,R1)          ACCOUNT FOR VARIABLE LENGTH RDW   TSO
         STC       R7,0(R1)            Store char in buffer [2]
         LA        R9,1(R9)            Bump output buffer pointer
DECOD6A2 DS    0H                                                   TSO
         LA        R8,1(R8)            Bump input buffer pointer
         MVI       PREV,X'00'          Reset
         SR        R3,R3               Clear out for subtract [7]
         IC        R3,RPTCT            Get no. of repetitions [7]
         BCTR      R3,0                Decrement repeat count [7]
         LTR       R3,R3               More repeats to do [7]
         BNP       DECOD0              Not positive, get new char [7]
         STC       R3,RPTCT            Save modified count [7]
         BCTR      R8,0                Re-adjust input buf pointer [7]
         STC       R7,RPTVAL           Remember repeated char [7]
         B         DECOD1              And write it out again [7]
DECOD7   L         R15,MORDEC          Routine to write out record [22]
         BALR      R14,R15
         LTR       R15,R15             Check the return code
         BNZ       DECOD8              Return if failed
         XC        OUTBFPT,OUTBFPT     Reset output buffer pointer
         SR        R9,R9               Reset output buffer pointer
         SR        R3,R3               Clear out for subtract [7]
         IC        R3,RPTCT            Get no. of repetitions [7]
         CLI       RPTVAL,ACR          Ended with CR or LF? [25]
         BE        DECOD71             Yes do something else [25]
         CLI       RPTVAL,ALF          Or did we end 'cause [25]
         BE        DECOD71             hit max lrecl [25]
         LTR       R3,R3               More repeats to do [7]
         BP        DECOD1
         B         DECOD0              And get more input
DECOD71  BCTR      R3,0                One down [25]
         LTR       R3,R3               Any more to go? [25]
         BNP       DECOD0              No, all done [25]
         STC       R3,RPTCT            Remember new count [25]
         B         DECOD1              And get new char [25]
DECODERR MVI   ERRNUM,34         SAY BLKSIZE TOO SMALL              AJR
DECOD8   RET   ,                                                    TSO
         SPACE 1                                                    TSO
NULDMP   BR        R14                 Null routine [22]
         SPACE 1                                                    TSO
EXPND    MVC   0(*-*,R1),ASCIBLNK                                   TSO
         SPACE 1                                                    TSO
ASCIBLNK DC    255X'20'                                             TSO
         EXIT                                                       TSO
         TITLE '(OUTBUF)  Write buffer of data to disk'             AJR
* Write out a buffer full of data to disk.                          AJR
* Expects R9 to contain the number of characters in the record.     AJR
         SPACE 3                                                    AJR
OUTBUF   ENTER ,                                                    AJR
         L     R7,ARBUF           ADDRESS OF OUTPUT BUFFER          AJR
         CLI   TYPFIL,C'V'        V-BINARY?                         AJR
         BNE   OUTBFNRM           NO...NORMAL FILE TYPE             AJR
         SR    R1,R1              SPECIAL FILE TYPE                 AJR
         ICM   R1,3,4(R7)         GET "TRUE" RECORD LENGTH          AJR
         LR    R10,R1             PUT IT HERE TOO                   AJR
         TM    SENDRCV+(DCBRECFM-IHADCB),DCBRECU UNDEFINED FORMAT?  AJR
         BNO   OUTBUF1            NO, RECFM=V                       AJR
         STH   R1,SENDRCV+(DCBLRECL-IHADCB)   SAVE RECORD LENGTH    AJR
         LA    R7,2(,R7)          ACCOUNT FOR LENGTH (2 BYTES)      AJR
         LA    R2,2               ...AND HERE TOO                   AJR
         SR    R9,R2              CORRECT LENGTH                    AJR
         LA    R3,FILNAM                                            AJR
         LA    R15,8              IN CASE OF ERROR                  AJR
         CR    R1,R9              MATCH?                            AJR
         BNE   OUTBFERR           NO, GIVE UP                       AJR
         CH    R1,BLKSIZE         MUST NOT BE GREATER THAN BLKSIZE  AJR
         BNH   OUTBUF0            OK                                AJR
         B     OUTBFER2           NO, GIVE UP                       AJR
         SPACE 1                                                    AJR
OUTBUF0  LA    R7,4(,R7)          ACCOUNT FOR RDW (4 BYTES)         AJR
         B     OUTBFWRT           GO WRITE OUT BUFFER               AJR
         SPACE 1                                                    AJR
OUTBUF1  LA    R1,4(R1)         ACCOUNT FOR LENGTH OF RDW (RECFM=V) AJR
         STH   R1,SENDRCV+(DCBLRECL-IHADCB)   SAVE RECORD LENGTH    AJR
         LA    R7,2(,R7)          ACCOUNT FOR LENGTH (2 BYTES)      AJR
         LA    R2,2               ...AND HERE TOO                   AJR
         SR    R9,R2              CORRECT LENGTH                    AJR
         LA    R3,FILNAM                                            AJR
         LA    R15,8              IN CASE OF ERROR                  AJR
         CR    R10,R9             MATCH?                            AJR
         BNE   OUTBFERR           NO, GIVE UP                       AJR
         B     OUTBFVAR                                             AJR
         SPACE 1                                                    AJR
OUTBFNRM TM    SENDRCV+(DCBRECFM-IHADCB),DCBRECU UNDEFINED FORMAT?  AJR
         BNO   OUTBF              NO                                AJR
         STH   R9,SENDRCV+(DCBLRECL-IHADCB)  STORE RECORD LENGTH    AJR
         LA    R15,8              IN CASE OF ERROR                  AJR
         CH    R9,BLKSIZE         MUST NOT BE GREATER THAN BLKSIZE  AJR
         BNH   OUTBF              OK                                AJR
         B     OUTBFER2           NO, GIVE UP                       AJR
         SPACE 1                                                    AJR
OUTBF    LH    R6,SENDRCV+(DCBLRECL-IHADCB)  GET LRECL              AJR
         LTR       R10,R9              Any data or bare CR?
         BNZ       OUTBF0              Yes, there's data
         L         R1,ARBUF            Else, get addr of buffer [2]
         LA    R1,4(,R1)          ACCOUNT FOR VARIABLE LENGTH RDW   TSO
         MVI       0(R1),X'20'         Make first char a space [2]
         LA        R10,1(R10)          Length of one (fake blank line)
OUTBF0   TM        FLAGS,BINF          Binary data file? [1]
         BO        OUTBF3              If so skip translation [1]
         LR        R7,R10              Save size in R7 [2]
         LR        R1,R10              Here too [2]
         L         R3,ARBUF            Where translating starts [2]
         LA    R3,4(,R3)          ACCOUNT FOR VARIABLE LENGTH RDW   TSO
OUTBF1   BCTR      R1,0                Subtract 1 for EX command
         C         R1,=F'255'          Max for TRANSLATE is 256 [2]
         BL        OUTBF2              If is under max then is OK [2]
         LA        R1,255              Else, set to max [2]
OUTBF2   EX        R1,TRNS             ASCII to EBCDIC translation  AJR
         C         R7,=F'256'          Chars left to translate? [2]
         BNH       OUTBF3              Nope, we're done [2]
         LA        R3,256(R3)          X-late next group of chars [2]
         S         R7,=F'256'          Decr chars left to x-late [2]
         LR        R1,R7               No. of chars left to x-LATE [2]
         B         OUTBF1              Translate some more [2]
OUTBF3   LA        R3,FILNAM
         TM    SENDRCV+(DCBRECFM-IHADCB),DCBRECV     RECFM=U OR V?  AJR
         BO    OUTBF5             YES, LEAVE DATA AS IS             TSO
         CR        R10,R6              If fixed, cannot exceed lrecl
         BNL   OUTBF5             IF SO WRITE LRECL'S WORTH         TSO
         LR        R2,R6               Else, get lrecl size
         SR        R2,R10              Pad with this many spaces
         L         R0,ARBUF            Start of buffer [2]
         AR        R0,R10              Where to start padding [2]
         A     R0,=F'4'           ACCOUNT FOR VARIABLE LENGTH RDW   TSO
         LR        R1,R2               Amount to pad by [2]
         L    R15,=X'40000000'    PAD WITH SPACES                   TSO
         TM        FLAGS,BINF          In binary mode [1]
         BNO       OUTBF31             No so just pad [1]
         SR        R15,R15             Pad with nulls [1]
OUTBF31  MVCL      R0,R14              Do it [2]
OUTBF5   L     R7,ARBUF           GET ADDRESS OF OUTPUT BUFFER      TSO
         TM    SENDRCV+(DCBRECFM-IHADCB),DCBRECU UNDEFINED FORMAT?  AJR
         BO    OUTBFU             YES, SET UP TO WRITE UNDEFINED    AJR
         TM    SENDRCV+(DCBRECFM-IHADCB),DCBRECV VARIABLE FORMAT?   TSO
         BO    OUTBFVAR           YES, SET UP TO WRITE VARIABLE     TSO
OUTBFU   LA    R7,4(,R7)          DON'T USE PLACE FOR RDW           AJR
         B     OUTBFWRT           GO WRITE OUT BUFFER               TSO
         SPACE 1                                                    TSO
OUTBFVAR XC    0(4,R7),0(R7)      CLEAR RDW AREA                    TSO
         LA    R10,4(,R10)        ACCOUNT FOR LENGTH OF RDW         TSO
         STH   R10,0(,R7)         PUT LENGTH IN RDW                 TSO
         LA    R8,8               SET ERROR CODE IN CASE OF ERROR   TSO
         CH    R10,SENDRCV+(DCBLRECL-IHADCB)  LRECL TOO SMALL?      TSO
         BNH   OUTBFWRT           NO                                TSO
         MVI   ERRNUM,33          SAY V LRECL TOO SMALL             TSO
         B     OUTBFRTN           GO RETURN                         TSO
         SPACE 1                                                    TSO
OUTBFWRT PUT   SENDRCV,(R7)       WRITE BUFFER TO DATA SET          TSO
         LA    R15,8              SET ERROR CODE IN CASE OF ERROR   TSO
         CLI   ERRNUM,6           IS THE DATA SET FULL?             TSO
         BE    OUTBFRTN           YES                               TSO
*****                                                               TSO
*****                                                               TSO
*****                                                               TSO
*        THIS CODE IS FOR DEBUGGING PURPOSES ONLY. ZAP TO BR TO     TSO
*        BRANCH AROUND.                                             TSO
         B     OUTBFRND           *** ZAP TO TURN ON  DEBUGGING     TSO
         TM    FLAGS,DEBUG        *** ARE WE DEBUGGING?             TSO
         BNO   OUTBFRND           *** NO                            TSO
         TM    SENDRCV+(DCBRECFM-IHADCB),DCBRECV VARIABLE FORMAT?   TSO
         BNO   OUTBFRND           *** NO                            TSO
         XC    WORKAREA(4),WORKAREA *** CLEAR OUTPUT BUFFER         TSO
         CVD   R9,CVDDBLWD        *** CONVERT ORIG LENGTH           TSO
         OI    CVDDBLWD+7,X'0F'   ***                               TSO
         UNPK  WORKAREA+4(4),CVDDBLWD *** MAKE IT READABLE          TSO
         LH    R15,0(R7)          *** GET LENGTH OF RECORD          TSO
         CVD   R15,CVDDBLWD       *** CONVERT LENGTH TO DECIMAL     TSO
         OI    CVDDBLWD+7,X'0F'   ***                               TSO
         UNPK  WORKAREA+8(4),CVDDBLWD *** MAKE IT READABLE          TSO
         BCTR  R15,0              *** ADJUST FOR EX                 TSO
         EX    R15,OUTBFMV        *** MOVE IN RECORD                TSO
*OUTBFMV MVC   WORKAREA+12(*-*),4(R7) *** MOVE IN RECORD            TSO
         LA    R15,1+4+4(,R15)    *** ADJUST FOR EX & RDW           TSO
         STCM  R15,3,WORKAREA     *** SAVE RDW INTO BUFFER          TSO
         PUT   LOGDCB,WORKAREA    *** WRITE RECORD TO LOG           TSO
         B     OUTBFRND           *** EXIT DEBUGGING                TSO
OUTBFMV  MVC   WORKAREA+12(*-*),4(R7) *** MOVE IN RECORD            TSO
OUTBFRND DS    0H                 *** END OF DEBUGGING              TSO
*****                                                               TSO
*****                                                               TSO
*****                                                               TSO
         SR    R15,R15            INDICATE EVERYTHING OK            TSO
OUTBFRTN RET   ,                                                    TSO
         SPACE 1                                                    TSO
OUTBFERR MVI   ERRNUM,35          BAD RECORD LENGTH                 AJR
         RET   ,                                                    AJR
         SPACE 1                                                    AJR
OUTBFER2 MVI   ERRNUM,34          RECORD > BLKSIZE                  AJR
         RET   ,                                                    AJR
         SPACE 1                                                    TSO
TRNS     TR        0(0,R3),ATOE   BACK FROM ASCII TO EBCDIC         TSO
         EXIT                                                       TSO
         TITLE '(ERRPACK) Send error packet'                        TSO
* Send error packet.  Error number is in variable errnum. [13]
         SPACE 3                                                    TSO
ERRPACK  ENTER ,                                                    TSO
         L    R1,ASDAT            GET ADDRESS OF SDAT               TSO
         MVI       STYPE,AE            Error packet
         MVC  LSDAT(4),=F'28'     All msgs are this long            TSO
         MVC       SPKNUM(4),RPKNUM    Synch packet numbers
         SR        R5,R5
         IC        R5,ERRNUM           Get right message number
         M    R4,=F'28'           Offset := ERRNUM * 28             TSO
         LA        R5,ERRTAB(R5)
         MVC  0(28,R1),0(R5)      PUT DATA HERE                     TSO
         TR   0(28,R1),ETOA                                         TSO
         L         R15,=A(SPACK)
         BALR      R14,R15             Send error packet
         RET   ,                                                    TSO
         EXIT                                                       TSO
         TITLE '(RPACK)  Read packet'                               TSO
* Add support for two character checksum and three character CRC.
* Expects input data to be in RECPKT buffer.  Writes data out to
* RDAT buffer.  Registers used: R5 to calculate checksum, R8 as
* pointer in input buffer.  R9 as output buffer pointer.  [8]
         SPACE 3                                                    TSO
RPACK    ENTER ,                                                    TSO
         L     R2,ARECPKT         GET ADDRESS OF BUFFER             TSO
         L     R3,LRECPKT         GET LENGTH OF BUFFER              TSO
         TM        S1FLAGS,ISS1        is console a S/1?  [12 start]
         BZ        RECTTY              no: skip
         TGET  (R2),(R3),ASIS                                       TSO
         LTR   R15,R15            I/O SUCCESSFUL?                   SEB
         BZ    *+16               YES                               SEB
         C     R15,=F'24'         I/O SUCCESSFUL?                   SEB
         BZ    *+8                YES                               SEB
         NOP   *+4                NO; THIS NOP PROVIDES TEST POINT  SEB
         CLC   RPTGCNT,RPTGSTOP   REACHED # TIMES THRU HERE?        SEB
         BL    *+8                NO                                SEB
         NOP   *+4                YES; THIS NOP PROVIDES TEST POINT SEB
* The format of the incoming buffer is:
*     X'E8',X'????',<ASCII data with high bit set>,<CR>
* where the '????' is an SBA-type cursor address which would
* point to the end of the data on the screen (if it were
* really there).
         LA    R3,0(,R1)      NUMBER BYTES
         S     R3,=F'3'       TO MOVE                               TSO
         BNP   RPACKS1B       IF NOTHING TO MOVE CHECK FOR 7171     SEB
         LR    R15,R3         NUMBER BYTES TO MOVE                  TSO
         LA    R14,3(,R2)     MOVE FROM THREE BYTES OVER            TSO
         MVCL  R2,R14         SHIFT OVER THE LEADING SBA            TSO
         B     RPACKS1A       CONTINUE PROCESSING PACKET            SEB
         SPACE 1                                                    SEB
*        IF ONLY SBA IS SENT WHEN USING THE 7171/SERIES1            SEB
*        THEN FILL THE SCREEN WITH BLANKS AND READ IT BACK          SEB
*        TO FORCE VTAM TO INCREASE ITS BUFFER SIZE SO THAT          SEB
*        EXTENDED PACKETS CAN BE SENT.                              SEB
         SPACE 1                                                    SEB
RPACKS1B CLRSCR FILLCHR=BLANK,FSMODE=ON FILL SCREEN WITH BLANKS     SEB
         TPG   READMOD,1      READ THE SCREEN JUST FILLED           SEB
         L     R1,ARECPKT     GET BUFFER ADDRESS                    SEB
         L     R0,LRECPKT     GET BUFFER LENGTH                     SEB
         TGET  (1),(0),ASIS   RDMOD TO PRIME VTAM                   SEB
         LA    R1,3           FAKE NO PACKET                        SEB
         SPACE 1                                                    SEB
RPACKS1A L     R2,ARECPKT     POINT TO BUFFER AGAIN                 TSO
         LR    R6,R1          SAVE LENGTH OF PACKET                 TSO
         S     R6,=F'4'       MINUS CURSOR ADDRESS & CR             TSO
         BNM   RPACKS1E       DATA LENGTH >= 0; NO PROBLEM          TSO
         MVI   0(R2),X'0D'    7171 BLEW IT.  PUT IN CR              TSO
         SR    R6,R6          SET LENGTH FOR ONE DATA BYTE          TSO
         B     RPACKS1D       GO LOG PACKET                         TSO
         SPACE 1                                                    TSO
RPACKS1E EQU   *                                                    TSO
         ST    R6,RCVPKL      SAVE LENGTH OF DATA READ              TSO
         LR    R3,R6          PASS LENGTH OF DATA READ              TSO
         LA    R4,OFF80       TURN OFF HIGH BITS IN DATA READ IN    TSO
         L     R15,=A(TRANSLAT)  GET ADDRESS OF TRANSLATE ROUTINE   TSO
         BALR  R14,R15        GO TURN OFF HIGH BITS IN DATA         TSO
RPACKS1D TM    FLAGS,DEBUG    ARE WE DEBUGGING?                     TSO
         BNO       RPACKA              No don't log packet [14]
         L     R4,ALOGBUF     GET ADDRESS OF LOG BUFFER             TSO
         XC    0(4,R4),0(R4)  INITIALIZE LOG BUFFER RDW             TSO
         LTR   R6,R6          IS THERE ANY DATA?                    TSO
         BP    RPACKDCH       YES, PUT IN DATA                      TSO
         MVC   4(23,R4),=C'NULL DATA LINE RECEIVED'                 TSO
         MVC   0(2,R4),=H'27' SET LENGTH OF MESSAGE AND RDW         TSO
         B     RPACKDWR       GO WRITE MESSAGE INTO LOG FILE        TSO
         SPACE 1                                                    TSO
RPACKDCH LA    R0,4(,R6)      ADD RDW LENGTH                        TSO
         STH   R0,0(,R4)      BUILD RDW                             TSO
         LA    R4,4(,R4)      PLACE TO PUT LOG DATA                 TSO
         LR    R5,R6          LENGTH OF DATA TO MOVE                TSO
         LR    R14,R2         GET LOG DATA FROM HERE                TSO
         LR    R15,R6         LENGTH TO MOVE                        TSO
         ICM   R15,8,=C' '    PADDING CHARACTER                     TSO
         MVCL  R4,R14         MOVE DATA TO LOG BUFFER               TSO
         L     R2,ALOGBUF     GET ADDRESS OF                        TSO
         LA    R2,4(,R2)      BUFFER TO BE TRANSLATED               TSO
         LR    R3,R6          LENGTH TO BE TRANSLATED               TSO
         LA    R4,ATOE        PASS TRANSLATE TABLE ADDRESS          TSO
         L     R15,=A(TRANSLAT)  GET TRANSLATE ROUTINE ADDRESS      TSO
         BALR  R14,R15        TRANSLATE THE LOG RECORD              TSO
         SPACE 1                                                    TSO
         L     R4,ALOGBUF     GET ADDRESS OF LOG RECORD             TSO
RPACKDWR PUT   LOGDCB,(R4)    LOG THE PACKET                        TSO
         CLI   ERRNUM,32      IS THE LOG DATA SET FULL?             TSO
         BE    RPACK8         YES, RETURN; ABORT STATE HAS BEEN SET TSO
         L     R2,ARECPKT     GET ADDRESS OF RECEIVE PACKET         TSO
         B         RPACKA              re-join common code
         SPACE 1                                                    TSO
*        GET PACKET FROM A LINE-BY-LINE TERMINAL                    TSO
         SPACE 1                                                    TSO
RECTTY   EQU       *                   normal TTY-type read [12 end]
         RDTERM (R2),(R3)                                           TSO
         LTR   R15,R15        EVERYTHING OK?                        TSO
* NOTE: BEFORE WE DO ANYTHING FOOLISH, LET'S TRANSLATE NCP'S        AJR
*       GARBAGE INTO THE ASCII WE ALL KNOW AND LOVE...              AJR
         BZ    RPACKB         YES                                   AJR
         MVI   ERRNUM,26      ERROR READING PACKET                  TSO
         B     RPACK71                                              TSO
         SPACE 1                                                    TSO
RPACKDBG L     R4,ALOGBUF     GET ADDRESS OF LOG BUFFER             AJR
         XC    0(4,R4),0(R4)  INITIALIZE LOG BUFFER RDW             TSO
         LTR   R1,R1          IS THIS A ZERO LENGTH PACKET?         TSO
         BP    RPACKLPK       NO                                    TSO
         MVC   4(23,R4),=C'NULL DATA LINE RECEIVED'                 TSO
         MVC   0(2,R4),=H'27' PUT IN LENGTH OF MESSAGE AND RDW      TSO
         B     RPACKLOG       GO LOG IT                             TSO
         SPACE 1                                                    TSO
RPACKLPK LA    R0,4(,R1)      ADD LENGTH OF RDW                     TSO
         STH   R0,0(,R4)      PUT INTO RDW                          TSO
         LA    R4,4(,R4)      PLACE TO PUT LOG DATA                 TSO
         LR    R5,R1          LENGTH OF DATA TO MOVE                TSO
         LR    R14,R2         GET LOG DATA FROM HERE                TSO
         LR    R15,R1         LENGTH TO MOVE                        TSO
         ICM   R15,8,=C' '    PADDING CHARACTER                     TSO
         MVCL  R4,R14         MOVE DATA TO LOG BUFFER               TSO
         L     R2,ALOGBUF     GET ADDRESS OF                        AJR
         LA    R2,4(,R2)      BUFFER TO BE TRANSLATED               AJR
         LR    R3,R1          LENGTH TO BE TRANSLATED               AJR
         LA    R4,ATOE        PASS TRANSLATE TABLE ADDRESS          AJR
         L     R15,=A(TRANSLAT)  GET TRANSLATE ROUTINE ADDRESS      AJR
         BALR  R14,R15        TRANSLATE LOG RECORD TO REAL EBCDIC   AJR
         L     R4,ALOGBUF     POINT TO LOG BUFFER                   AJR
RPACKLOG PUT   LOGDCB,(R4)    LOG THE PACKET                        TSO
         CLI   ERRNUM,32      IS THE LOG DATA SET FULL?             TSO
         BE    RPACK8         YES, RETURN; ABORT STATE HAS BEEN SET TSO
         L     R2,ARECPKT     GET ADDRESS OF RECEIVE PACKET
         B     RPACKA         LOG COMPLETE...RE-JOIN COMMON CODE    AJR
         SPACE 1                                                    TSO
RPACKB   ST    R1,RCVPKL      SAVE LENGTH OF DATA READ              AJR
         L     R3,RCVPKL      GET LENGTH TO TRANSLATE               TSO
         L     R4,ETOANCPA    POINT TO NCP TRANSLATE TABLE          AJR
         L     R15,=V(TRANSLAT)  GET ADDRESS OF TRANSLATE ROUTINE   TSO
         BALR  R14,R15        GO TRANSLATE THE PACKET               TSO
         TM    FLAGS,DEBUG    ARE WE DEBUGGING?                     AJR
         BO        RPACKDBG   YES                                   AJR
         SPACE 1                                                    TSO
* COMMON CODE *                                                     AJR
RPACKA   EQU       *                   [12]
         NI        FLAGS,X'FF'-FLG4    Make guess about type of error
         SR        R8,R8               Index register for RECPKT
         SR        R5,R5               Checksum register
RPACK0   LA    R7,0(R8,R2)        ADDRESS OF NEXT INPUT CHARACTER   TSO
         CLI       0(R7),SOH           Is it Control-A
         BE        RPACK1              Yes, so far so good
         LA        R8,1(R8)            Try next character
         C     R8,RCVPKL          EXCEED LENGTH OF DATA READ?       TSO
         BL        RPACK0              No, can keep checking
         MVI       ERRNUM,X'03'        Yes so no "SOH" error
         B         RPACK71
RPACK1   SR        R9,R9               Zero output buffer pointer
         LA        R8,1(R8)            Increment input buffer pointer
         LA    R7,0(R8,R2)        GET LOCATION OF CHARACTER COUNT   TSO
         CLI       0(R7),SOH           Is it Control-A
         BE        RPACK1              Yes start over
         IC    R5,0(,R7)          START CHECKSUM                    TSO
         LR        R7,R5               Get size field
         ST    R7,LRDAT           LENGTH OF DATA & CONTROL INFO     TSO
         LA        R8,1(R8)            Increment input pointer
         SR        R7,R7               Zero it out
         IC    R7,0(R8,R2)        PICK UP PACKET NUMBER             TSO
         C         R7,=A(SOH)          Is it Control-A
         BE        RPACK1              Yes restart packet
         AR        R5,R7               Add to checksum
         S         R7,SPACE            Subtract the space
         STC       R7,RPKNUM+3         RPKNUM := received packet number
         LA        R8,1(R8)            Increment input counter
         IC    R7,0(R8,R2)        PICK UP PACKET TYPE               TSO
         C         R7,=A(SOH)          Is it Control-A
         BE        RPACK1              Yes restart
         STC       R7,RTYPE            Save value here
         AR        R5,R7               Add to checksum
         LA        R8,1(R8)            Go to next byte
         CLI   LRDAT+3,ABL        IS THIS AN EXTENDED PACKET?       TSO
         BNE   RPKSHORT           NO                                TSO
         LA    R15,3(,R8)         PAST LENX1,LENX2,HCHECK           TSO
         C     R15,RCVPKL         EXCEED LENGTH OF DATA READ?       TSO
         BNL   RPACK0             TOO LONG, TRY FOR ANOTHER SOH     TSO
         SR    R1,R1              CLEAR FOR IC                      TSO
         IC    R1,0(R8,R2)        PICK UP LENX1 BYTE                TSO
         C     R1,=A(SOH)         IS IT SOH?                        TSO
         BE    RPACK1             YES, RESTART                      TSO
         AR    R5,R1              ADD TO CHECKSUM                   TSO
         S     R1,SPACE           UNCHAR(LENX1)                     TSO
         MH    R1,XLFCT+2         HIGH DIGIT OF SIZE                TSO
         IC    R7,1(R8,R2)        PICK UP LENX2 BYTE                TSO
         C     R7,=A(SOH)         IS IT SOH?                        TSO
         BE    RPACK1             YES, RESTART                      TSO
         AR    R5,R7              ADD TO CHECKSUM                   TSO
         S     R7,SPACE           UNCHAR(LENX2)                     TSO
         AR    R1,R7              TOTAL EXTENDED PACKET SIZE        TSO
         IC    R7,2(R8,R2)        PICK UP HCHECK BYTE               TSO
         C     R7,=A(SOH)         IS IT SOH?                        TSO
         BE    RPACK1             YES, RESTART                      TSO
         S     R7,SPACE           UNCHAR(HCHECK)                    TSO
         LR    R15,R5             KEEP CHECKSUM HERE                TSO
         N     R15,FF             LOW BYTE OF TOTAL                 TSO
         SRL   R15,6              HIGH 2 BITS OF TOTAL              TSO
         AR    R15,R5             ADD THE TWO VALUES                TSO
         N     R15,MOD64          GET LOW ORDER 6 BITS              TSO
         CR    R15,R7             CHK COMPUTED VS RECEIVED          TSO
         BNE   RPACK7             ERR IF CHECKSUMS DON'T MATCH      TSO
         LA    R5,ABL(R7,R5)      ADD HCHECK TO CHECKSUM            TSO
         LA    R8,3(,R8)          POINT PAST LENX1,LENX2,HCHECK     TSO
         ST    R1,LRDAT           SAVE LENGTH OF DATA + CHECK       TSO
         LR    R4,R1              BE SURE LENGTH IS IN R4           TSO
         LA    R1,0(R8,R1)        EXPECTED TOTAL LENGTH OF PACKET   TSO
         C     R1,RCVPKL          EXCEED LENGTH OF DATA READ?       TSO
         BH    RPACK0             TOO LONG, TRY FOR ANOTHER SOH     TSO
         B     RPKDATA            GO PROCESS PACKET DATA            TSO
* Start of change.
* Now determine block check type for this packet.  Here we violate the
* layered nature of the protocol by inspecting the packet type in
* order to detect when the two sides get out of sync.  Two heuristics
* allow us to resync here:
*   a. An S packet always has a type 1 checksum.
*   b. A NAK never contains data, so its block check type is
*      PACKET LEN-2.
RPKSHORT DS    0H                                                   TSO
         L         R4,LRDAT            Get back the size
         S         R4,=F'34'           Unchar(len)-2 (for SEQ & TYPE)
RPKDATA  DS    0H                                                   TSO
         SR        R3,R3
         IC        R3,CHKLEN           Checksum length we expect
         CLI       RTYPE,AS            Is this an "S" packet?
         BNE       RPK0                Nope
         L         R3,ONE              Yes, use 1 char checksum
RPK0     CLI       RTYPE,AN            Is this a NAK?
         BNE       RPK1                Nope
         LR        R3,R4               Yes so len-2 is checksum type
RPK1     STC       R3,CHKLEN           Then this is chksum length
         SR        R4,R3               Real size of data
         ST        R4,LRDAT            Save correct size
* End of change.
         LTR       R4,R4               How much data did we get
         BZ        RPACK3              None so that's it
         L     R15,ARDAT          GET ADDRESS OF RDAT               TSO
RPACK2   XC        TEMP,TEMP           Zero it out
         LA    R7,0(R8,R2)        NEXT LOCATION IN BUFFER           TSO
         MVC       TEMP+3(1),0(R7)     Pick up next byte
         CLI       TEMP+3,SOH          Is it Control-A
         BE        RPACK1              Yes start over
         LA    R7,0(R9,R15)       WHERE THE DATA'S GOING            TSO
         MVC       0(1,R7),TEMP+3      And move it
         A         R5,TEMP             Add to checksum
         LA        R8,1(R8)            Bump input buffer pointer
         LA        R9,1(R9)            Bump output buffer pointer
         BCTR      R4,0                Decrement amount of input
         LTR       R4,R4               Any left?
         BNZ       RPACK2              Yes get another character
RPACK3   SR        R7,R7               Zero out register
         IC    R7,0(R8,R2)        GET CHECKSUM                      TSO
         LA        R8,1(R8)            Bump input pointer
         C         R7,=A(SOH)          Is it Control-A
         BE        RPACK1              Yes start over
         S         R7,SPACE            Turn char back into a number
         LR        R4,R5               Keep copy here [8]
         CLI       CHKLEN,X'02'        Using what checksum length
         BE        RPACK5              Two character checksum
         BH        RPACK4              Three character CRC
         ST        R5,TEMP             Else is a 1 char checksum
         N         R5,=X'000000C0'     Get two hi order bits
         SRL       R5,6                Shift it right by 6
         A         R5,TEMP             Add the two values
         N         R5,=X'0000003F'     Get mod 64
         CR        R5,R7               Computed vs received checksum
         BE        RPACK8              Successful
         B         RPACK7              We failed
RPACK4   L     R5,ARECPKT         GET ADDRESS OF INPUT BUFFER       TSO
         LA        R5,1(R5)            Skip over the ^A
         SR        R6,R6               Use for NULL
         BCTR      R8,0                Go back one char
         STC   R6,0(R8,R2)        NEXT SPOT IN OUTPUT BUFFER        TSO
         LA        R8,1(R8)            Next char to pick up
         L         R15,=A(CRCCLC)      Calculate the CRC
         BALR      R14,R15
         LR        R4,R15              Keep it here
         LR        R5,R4               Munge while here
         N         R5,=X'0000F000'     Get bits 12-15
         SRL       R5,12               Shift right by 12
         CR        R5,R7               Rec'v checksum = calculated one?
         BNE       RPACK7              No then we fail
         SR        R7,R7               Zero out register
         IC    R7,0(R8,R2)        GET NEXT CHARACTER OF CHECKSUM    TSO
         LA        R8,1(R8)            Bump input pointer
         C         R7,=A(SOH)          Is it Control-A
         BE        RPACK1              Yes start over
         S         R7,SPACE            Get real value
RPACK5   LR        R5,R4               Get back the CRC
         N         R5,=X'00000FC0'     Get bits 6-11
         SRL       R5,6                Shift right by six
         CR        R5,R7               Recv chksum = calc one?
         BNE       RPACK7              No
         SR        R7,R7               Zero out register
         IC    R7,0(R8,R2)        GET CHECKSUM                      TSO
         LA        R8,1(R8)            Bump input pointer
         C         R7,=A(SOH)          Is it Control-A
         BE        RPACK1              Yes start over
         S         R7,SPACE            Get back real value
         N         R4,=X'0000003F'     Get bits 0-5
         CR        R4,R7               Do the last chars match
         BE        RPACK8              Yes
RPACK7   EQU       *
* Uncomment next two lines when debugging to get first char of chksum.
*        A         R5,SPACE
*        LINEDIT   TEXT='CHK SB ...',SUB=(HEX,(R5))
         MVI       ERRNUM,X'05'        Bad checksum error
RPACK71  MVI       RTYPE,AN            Return a NAK
         OI        FLAGS,FLG4          RPACK NAK'ed the packet
RPACK8   RET   ,                                                    TSO
         SPACE 1                                                    TSO
RPACK9   EQU       *                   S/1 I/O error occurred [12]
         MVI       ERRNUM,S1ERRNUM     Set error type [12]
         MVI       RTYPE,X'00'         Set an invalid pkt type [12]
         B         RPACK8              Return to caller [12]
         SPACE 1                                                    TSO
         EXIT                                                       TSO
         TITLE '(SPACK)  Send packet'                               TSO
* Add support for two character checksum and three character CRC.
* Expects input data to be in SDAT buffer.  Registers used: R9 to
* calculate the checksum. [8]
         SPACE 3                                                    TSO
SPACK    ENTER ,                                                    TSO
         L     R8,ASNDPKT         GET ADDRESS OF SNDPKT             TSO
         SR        R9,R9               Zero out checksum register
         MVI   0(R8),SOH          ADD CONTROL-A TO PACKET           TSO
         L         R4,LSDAT            DATA SIZE + SPACE + TWO [8]
         SR        R5,R5               Zero for next instruction [8]
         IC        R5,CHKLEN           Get checksum length [8]
         LA    R4,2(R5,R4)        DATA, CHK, SEQ, TYPE LENGTHS      TSO
         C     R4,=A(SPMAX)       CHECK PACKET LENGTH BYTE          TSO
         BNH   SPACK00            NO EXTENDED DATA LENGTH           TSO
         SR    R4,R4              SET "TYPE 0" EXTENDED HEADER      TSO
SPACK00  A     R4,SPACE           MAKE IT PRINTABLE                 TSO
         STC   R4,1(,R8)          ADD LENGTH TO PACKET              TSO
         AR        R9,R4               And then add it to checksum
         CLC       SPKNUM,ZERO         Check if packet number is valid
         BNL       SPACK01             OK if >= to 0
         MVI       ERRNUM,X'01'        Illegal packet number
         MVI       STATE,C'A'
         B         SPRET
SPACK01  CLC       SPKNUM,O1H          See if is <= octal 100
         BNH       SPACK02
         MVI       ERRNUM,X'01'        Illegal packet number
         MVI       STATE,C'A'
         B         SPRET
SPACK02  L         R4,SPKNUM           Get packet number
         A         R4,SPACE            Add space to make it printable
         STC   R4,2(,R8)          ADD PACKET NUMBER TO PACKET       TSO
         AR        R9,R4               And add to checksum
         CLI       STYPE,X'41'         ASCII 'A'
         BL        SPACK03             Can't be less than this
         CLI       STYPE,X'5A'         ASCII 'Z'
         BNH       SPACK04             Can't be greater
SPACK03  MVI       ERRNUM,X'07'        Illegal packet type
         MVI       STATE,C'A'          Die on this
         B         SPRET
SPACK04  MVC   3(1,R8),STYPE      ADD PACKET TYPE TO PACKET         TSO
         SR        R2,R2               Zero it out
         IC        R2,STYPE
         AR        R9,R2               Add to checksum
         SR    R7,R7              OFFSET TO DATA                    TSO
         CLI   1(R8),ABL          "TYPE 0" EXTENDED HEADER?         TSO
         BNE   SPACK05            NO                                TSO
         L     R5,LSDAT           GET LENGTH OF DATA                TSO
         SR    R4,R4              CLEAR FOR IC                      TSO
         IC    R4,CHKLEN          GET CHECKSUM LENGTH               TSO
         AR    R5,R4              SUM = EXTENDED LENGTH             TSO
         SR    R4,R4              CLEAR FOR DIVIDE                  TSO
         D     R4,XLFCT           GET TWO PARTS                     TSO
         A     R5,SPACE           MAKE PRINTABLE                    TSO
         STC   R5,4(,R8)          ADD LENX1 TO PACKET               TSO
         AR    R9,R5              ADD TO CHECKSUM                   TSO
         A     R4,SPACE           MAKE PRINTABLE                    TSO
         STC   R4,5(,R8)          ADD LENX2 TO PACKET               TSO
         AR    R9,R4              ADD TO CHECKSUM                   TSO
         LR    R6,R9              CHECKSUM THROUGH LENX2 BYTE       TSO
         N     R6,FF              LOW BYTE OF TOTAL                 TSO
         SRL   R6,6               HIGH 2 BITS OF TOTAL              TSO
         AR    R6,R9              GET TYPE-1 CHECK VALUE            TSO
         N     R6,MOD64                                             TSO
         A     R6,SPACE           MAKE PRINTABLE                    TSO
         STC   R6,6(,R8)          ADD HCHECK TO PACKET              TSO
         AR    R9,R6              ADD TO CHECKSUM                   TSO
         LA    R7,3               OFFSET TO PUT DATA                TSO
SPACK05  DS    0H                                                   TSO
         L         R6,LSDAT            How much data
         LTR       R6,R6               Test it out
         BZ        SPACK3
         SR        R5,R5               Use to get data
         SR        R3,R3               Use to hold data
SPACK1   L     R15,ASDAT          GET ADDRESS OF SDAT               TSO
         IC    R3,0(R5,R15)       PICK UP CHAR                      TSO
         AR        R9,R3               Add to checksum
         LA        R5,1(R5)            Bump pointer
         CR        R5,R6               Got all the data yet
         BNE       SPACK1              Nope get the rest
         LA    R4,4(R7,R8)        POINT TO PLACE TO PUT DATA        TSO
         LR    R5,R6              LENGTH TO MOVE                    TSO
         L     R14,ASDAT          GET ADDRESS OF DATA TO MOVE       TSO
         LR    R15,R6             LENGTH TO MOVE                    TSO
         ICM   R15,8,=X'0'        PAD CHARACTER                     TSO
         MVCL  R4,R14             MOVE THE DATA INTO THE PACKET     TSO
         CLI   1(R8),ABL          EXTENDED PACKET?                  TSO
         BNE   SPACK3             NO                                TSO
         LA    R6,3(,R6)          POINT PAST LENX1,LENX2,HCHECK     TSO
SPACK3   LR        R7,R9               Need copy of chksum [8]
         CLI       CHKLEN,X'02'        What kind of checksum? [8]
         BE        SPACK5              2 char checkum [8]
         BH        SPACK4              3 char CRC [8]
         ST        R9,TEMP             Else is one char checksum
         N         R9,=X'000000C0'     Get MOD 192
         SRL       R9,6                Shift right by 6
         A         R9,TEMP             Add the two values
         N         R9,=X'0000003F'     Get MOD 64 of checksum
         A         R9,SPACE            Make printable
         STC   R9,4(R6,R8)        ADD TO BUFFER (AFTER DATA)        TSO
         B         SPACK6              Go add EOL char
SPACK4   SR        R5,R5               Zero out to get a NULL [8]
         STC   R5,4(R6,R8)        ADD NULL AT END OF DATA           TSO
         ST        R6,TEMP             Next free spot in buffer [8]
         LA    R5,1(,R8)          CHECKSUM STARTS WITH LENGTH BYTE  TSO
         L         R15,=A(CRCCLC)      Calculate the CRC [8]
         BALR      R14,R15             Return CRC in R15 [8]
         LR        R7,R15              Keep in here [8]
         LR        R5,R7               Munge value in dif register [8]
         N         R5,=X'0000F000'     Get bits 12-15 [8]
         SRL       R5,12               Shift right by 12 bits [8]
         A         R5,SPACE            Make char printable [8]
         L         R6,TEMP             Next free spot in buffer [8]
         STC   R5,4(R6,R8)        ADD TO BUFFER                     TSO
         LA        R6,1(R6)            Bump output pointer [8]
SPACK5   LR        R5,R7               Munge in dif register [8]
         N         R5,=X'00000FC0'     Get bits 6-11 [8]
         SRL       R5,6                Shift right 6 bits [8]
         A         R5,SPACE            Make char printable [8]
         STC   R5,4(R6,R8)        ADD TO BUFFER                     TSO
         LA        R6,1(R6)            Bump pointer [8]
         N         R7,=X'0000003F'     Get bits 0-5 [8]
         A         R7,SPACE            Make printable [8]
         STC   R7,4(R6,R8)        ADD TO BUFFER                     TSO
SPACK6   LA        R6,1(R6)            Bump pointer
         IC        R9,SEOL
         STC   R9,4(R6,R8)        ADD SEND END-OF-PACKET CHARACTER  TSO
         L         R6,LSDAT            Amount of data [8]
         LA    R6,5(,R6)          CNTL INFO & EOL FOR REGULAR PKT   TSO
         CLI   1(R8),ABL          IS THIS EXTENDED PACKET?          TSO
         BNE   *+8                NO                                TSO
         LA    R6,3(,R6)          PLUS LENX1,LENX2,HCHECK           TSO
         SR        R5,R5               Zero for next instruction [8]
         IC        R5,CHKLEN           Get checksum length [8]
         AR        R6,R5               Plus length of checksum
         TM        FLAGS,DEBUG         Are we debugging? [14]
         BNO       SPACK61             No don't log packet [14]
         L     R4,ALOGBUF         GET ADDRESS OF LOG BUFFER         TSO
         XC    0(4,R4),0(R4)      INITIALIZE LOG BUFFER RDW         TSO
         LA    R0,4(,R6)          GET LENGTH INCLUDING RDW          TSO
         STH   R0,0(,R4)          BUILD RDW                         TSO
         LA    R4,4(,R4)          POINT TO PLACE TO PUT LOG DATA    TSO
         LR    R5,R6              LENGTH OF DATA TO MOVE            TSO
         L     R14,ASNDPKT        MOVE DATA FROM HERE               TSO
         LR    R15,R6             LENGTH OF DATA TO MOVE            TSO
         ICM   R15,8,=C' '        PADDING CHARACTER                 TSO
         MVCL  R4,R14             MOVE LOG DATA                     TSO
         L     R2,ALOGBUF         GET ADDRESS OF LOG BUFFER         TSO
         LA    R2,4(,R2)          TO TRANSLATE                      TSO
         LR    R3,R6              LENGTH OF DATA TO TRANSLATE       TSO
         LA    R4,ATOE            PASS TRANSLATE TABLE ADDRESS      TSO
         L     R15,=A(TRANSLAT)   GET ADDRESS OF TRANSLATE ROUTINE  TSO
         BALR  R14,R15            GO TRANSLATE THE LOG BUFFER       TSO
         L     R4,ALOGBUF         GET ADDRESS OF LOG BUFFER         TSO
         PUT   LOGDCB,(R4)        LOG THE PACKET                    TSO
         CLI   ERRNUM,32          IS THE LOG DATA SET FULL?         TSO
         BE    SPRET              YES, RETURN; ABORT STATE IS SET   TSO
         SPACE 1                                                    TSO
SPACK61  TM    S1FLAGS,ISS1       IS THIS AN IBM 7171/SERIES-1?     TSO
         BZ        SENDTTY             no: do normal TTY output
         L     R2,ASNDPKT         PASS BUFFER ADDRESS               TSO
         LR    R3,R6              PASS LENGTH OF DATA               TSO
         LA    R4,ON80            TURN ON HIGH BITS IN DATA BUFFER  TSO
         L     R15,=A(TRANSLAT)   GET ADDRESS OF TRANSLATE ROUTINE  TSO
         BALR  R14,R15            GO TURN ON HIGH BITS IN DATA      TSO
         LA    R0,S1ORDSL(,R6)    INCREMENT BY LENGTH OF S/1 ORDERS TSO
         L     R1,ASND7171        GET ADDRESS OF BUFFER             TSO
         TPUT  (1),(0),NOEDIT     OUTPUT BUFFER                     TSO
         LTR   R15,R15            EVERYTHING OK?                    TSO
         BZ    SPRET              YES, GO RETURN                    TSO
         SPACE 1                                                    TSO
         MVI       ERRNUM,S1ERRNUM     no: flag error
         MVI       STATE,C'A'          go into abort state
         B         SPRET               ret to caller
         SPACE 1                                                    TSO
SENDTTY  EQU       *                   [12 end]
         L     R2,ASNDPKT         POINT TO SNDPKT BUFFER            TSO
         LR    R3,R6              PASS LENGTH TO TRANSLATE          TSO
         L     R4,ATOENCPA     PASS ADDRESS OF NCP TRANSLATE TABLE  AJR
         L     R15,=A(TRANSLAT)   GET ADDRESS OF TRANSLATE ROUTINE  TSO
         BALR  R14,R15            GO TRANSLATE BUFFER               TSO
         WRTERM (R2),(R6),DATA=YES                                  TSO
         SPACE 1                                                    TSO
SPRET    RET   ,                                                    TSO
         SPACE 1                                                    TSO
         EXIT                                                       TSO
         TITLE '(CRCCLC)  Calculate CRC'                            TSO
* Calculate the CRC and return it in R15.  Expects R5 to point to
* the start of the buffer on which the CRC is calculated.  Stops
* when it reaches a NULL. [8]
         SPACE 3                                                    TSO
CRCCLC   ENTER ,                                                    TSO
         SR        R3,R3               Initial CRC value is zero
CRC0     SR        R4,R4               Clear out before read char
         IC        R4,0(R5)            Get the next character
         LTR       R4,R4               Test it
         BZ        CRC1                If NULL then we're done
         LA        R5,1(R5)            Else bump input pointer
         LR        R7,R3               Munge CRC here
         N         R7,=X'000000FF'     Only want lo order byte
         XR        R4,R7               XOR input and CRC lo byte
         LR        R7,R4               Keep the original for later
         N         R7,=X'000000F0'     Keep hi 4 bits of lowest byte
         SRL       R7,4                Shift it right by four
         N         R4,=X'0000000F'     Get lo 4 bits of lowest byte
         AR        R4,R4               Double to get index into table
         LH        R4,CRCTB2(R4)       Get low portion
         AR        R7,R7               Double to get another index
         LH        R7,CRCTAB(R7)       Get high portion
         N         R4,=X'0000FFFF'     Don't want propogated sign
         N         R7,=X'0000FFFF'     Ditto
         XR        R4,R7               Add the two
         SRL       R3,8                Shift 8 bits to right
         XR        R3,R4               XOR table value and CRC
         B         CRC0                And get some more
CRC1     LR        R15,R3              Return CRC in R15
         RET   ,                                                    TSO
         EXIT                                                       TSO
         TITLE '(SPAR)  Read parameters from other machine'         TSO
* Read parameters from other host.  Size of data passed in R5.
* Use the default for any parameter not supplied. [5]
         SPACE 3                                                    TSO
SPAR     ENTER ,
         SR        R4,R4               Zero out register
         L    R7,ARDAT            POINTER TO DATA BUFFER            TSO
         C         R5,ZERO             Any data
         BH        SPAR0
         LA        R4,DSSIZ            Default send packet size
         B         SPAR02
SPAR0    IC        R4,0(R7)            Max send packet size
         S         R4,SPACE            Subtract the space
         C         R4,=A(SPMIN)        Can't be below minimum
         BNL       SPAR01              So far, so good
         LA        R4,SPMIN            Else, use the min valuea
         B         SPAR02
SPAR01   C         R4,=A(SPMAX)        Max send packet size
         BNH       SPAR02              Can't be above max
         LA        R4,SPMAX
SPAR02   STC       R4,SPSIZ+3          Save max send packet size
         C         R5,ONE              More than one piece of data?
         BH        SPAR1               Send timeout supplied
         LA        R4,DSTIM            Else, use default
         B         SPAR12
SPAR1    SR        R4,R4
         IC        R4,1(R7)            Get send timeout value
         S         R4,SPACE
         C         R4,ZERO             Must be non-negative
         BNL       SPAR12
         L         R4,ZERO
SPAR12   STC       R4,STIME            Save send timeout value
         C         R5,TWO              More than two pieces of data?
         BH        SPAR2               Yes, pick up pad char
         LA        R4,DSPAD            No, use default
         B         SPAR22
SPAR2    SR        R4,R4
         IC        R4,2(R7)            Get number of pad chars
         S         R4,SPACE
         C         R4,ZERO             Must be non-negative
         BH        SPAR22
         L         R4,ZERO             Else, use zero
SPAR22   STC       R4,SPAD
         C         R5,=F'3'            More than 3 pieces of data
         BH        SPAR3               Yes, get pad char to use
         LA        R4,DSPADC
         B         SPAR32
SPAR3    IC        R4,3(R7)            Pad char other side wants
         A         R4,O1H              Re-controllify it
         N         R4,=X'0000007F'
         C         R4,DEL              Is it a delete?
         BE        SPAR32              Yes, then it's OK
         C         R4,ZERO             Is it above zero
         BNL       SPAR31              Yes, then OK
         L         R4,ZERO             Else, use null
         B         SPAR32
SPAR31   C         R4,=F'31'           Is it a control char
         BNH       SPAR32              Yes, then OK
         L         R4,ZERO             No, so use null
SPAR32   STC       R4,SPADCH
         C         R5,=F'4'            More than 4 pieces of data
         BH        SPAR4               Yes, get EOL char
         LA        R4,DEOL             Else, use default
         B         SPAR42
SPAR4    IC        R4,4(R7)            Get the EOL char
         S         R4,SPACE
SPAR42   STC       R4,SEOL
         C         R5,=F'5'            More than 5 pieces of data
         BH        SPAR5
         LA        R4,DQUOTE
         B         SPAR52
SPAR5    SR        R4,R4
         IC        R4,5(R7)            Get quote char
         C         R4,SPACE            Less than a space?
         BNL       SPAR51              No, is OK so far
         LA        R4,DQUOTE           Yes, so use default
         B         SPAR52
SPAR51   C         R4,=F'126'          Must be tilde or less
         BNH       SPAR52
         LA        R4,DQUOTE           If higher than use default
SPAR52   STC       R4,SQUOTE
         C         R5,=F'6'            More than 6 pieces of data
         BH        SPAR6
         MVI       EBQUOT,AY           Default (can do it but won't)
         B         SPAR7
SPAR6    SR        R4,R4
         IC        R4,6(R7)
         L         R15,=A(DOQUO)       Set 8-bit quote char [1]
         BALR      R14,R15             [1]
SPAR7    C         R5,=F'7'            More than 7 pieces of data
         BH        SPAR71              Yes get checksum length
         MVI       CHKLEN,X'01'        Else use default of one
         B         SPAR8
SPAR71   SR        R4,R4
         IC        R4,7(R7)            Get checksum size they want
         L         R15,=A(DOCHK)       Check what they sent
         BALR      R14,R15
SPAR8    C         R5,=F'8'            More than 8 pieces of data
         BH        SPAR81              Get repeat quote they want
         MVI       RPTQ,X'00'          Else don't do repeat prefixing
         MVI       ORIGQ,X'00'         Reset here too  [24]
         B         SPAR9
SPAR81   SR        R4,R4
         IC        R4,8(R7)            Get prefix they want to use
         L         R15,=A(DORPT)       Routine to check their value
         BALR      R14,R15
SPAR9    C    R5,=F'9'            MORE THAN 9 PIECES OF DATA?       TSO
         BNH  SPARRET             NO                                TSO
         SR   R4,R4                                                 TSO
         IC   R4,9(,R7)           GET CAPAS BYTE                    TSO
         S    R4,SPACE            UNCHAR(CAPAS)                     TSO
         STC  R4,RCAPA            SAVE IT                           TSO
         TM   RCAPA,LONGP         USING EXTENDED PACKETS?           TSO
         BZ   SPARRET             NO                                TSO
         LA   R15,9               WE'RE ON THE TENTH BYTE           TSO
         MVC  TMP,RCAPA                                             TSO
SPARNS1  LA   R15,1(,R15)         POINT TO NEXT BYTE                TSO
         TM   TMP,MORCAPAS        ARE THERE MORE CAPAS BYTES?       TSO
         BZ   SPARNS2             NO                                TSO
         IC   R4,0(R15,R7)        GET NEXT CAPAS BYTE               TSO
         S    R4,SPACE            UNCHAR(CAPAS)                     TSO
         STC  R4,TMP              SAVE IT                           TSO
         B    SPARNS1             AROUND AGAIN                      TSO
SPARNS2  LA   R15,1(,R15)         SKIP THE WINDOW BYTE              TSO
         IC   R4,0(R15,R7)        GET MAXLX1 BYTE                   TSO
         LR   R1,R4               SAVE IT                           TSO
         S    R1,SPACE            UNCHAR(MAXLX1)                    TSO
         MH   R1,XLFCT+2          TIMES THE FACTOR                  TSO
         LA   R15,1(,R15)         POINT TO MAXLX2                   TSO
         IC   R4,0(R15,R7)        GET MAXLX2 BYTE                   TSO
         S    R4,SPACE            UNCHAR(MAXLX2)                    TSO
         AR   R1,R4               COMPUTE TOTAL PACKET LENGTH       TSO
         BNP  SPARRET             IF ZERO, USE DEFAULT              TSO
         ST   R1,SPSIZ            NEW SPSIZ FOR EXTENDED PACKETS    TSO
SPARRET  RET   ,                                                    TSO
*
* Set checksum length
DOCHK    MVI       TMP,X'31'
         CLM       R4,B'0001',TMP      Must be the character 1,2 or 3
         BL        DOCHK0              Below 1 so fail
         MVI       TMP,X'33'
         CLM       R4,B'0001',TMP
         BNH       DOCHK1              Is in the limit
         MVI       TMP,X'31'
DOCHK0   IC        R4,TMP              Else use default
DOCHK1   S         R4,=F'48'           Don't want it printable
         CLM       R4,B'0001',CHKLEN   Do we want the same thing?
         BE        DOCHK2              Yes then we're done
         MVI       CHKLEN,X'01'        Else use single char checksum
DOCHK2   BR        R14                 Return
* Set repeat count quote character.  It must be different from
* the control & eight-bit quote characters.  Also, both sides must
* use the same character.
DORPT    C         R4,=F'33'           Check if in valid range
         BNL       DORPT0              It's 33 or above
         B         DORPT4              Else fail
DORPT0   C         R4,=F'62'
         BH        DORPT1
         B         DORPT3              And 62 or below - OK
DORPT1   C         R4,=F'96'
         BNL       DORPT2              It's 96 or above
         B         DORPT4              Else fail
DORPT2   C         R4,=F'126'
         BH        DORPT4              If above 126 then fail
DORPT3   CLM       R4,B'0001',SQUOTE   Same as send quote char
         BE        DORPT4              Yes so fail
         CLM       R4,B'0001',RQUOTE   Same as receive quote char
         BE        DORPT4              Yes so fail
         CLM       R4,B'0001',EBQUOT   Same as eight bit prefix
         BE        DORPT4              Yes so fail
         CLM       R4,B'0001',RPTQ     We planning to use same char?
         BNE       DORPT4              No so fail
         BR        R14                 Yes so its OK
DORPT4   MVI       RPTQ,X'00'          Don't do repeat prefixing
         MVI       ORIGQ,X'00'         Reset here too  [24]
         BR        R14
*
         EXIT                                                       TSO
         TITLE '(RPAR) Sets up parameters to send to other machine' TSO
* Set up our parameters we will send to other host.  Return size
* of data in R15. [5]
         SPACE 3                                                    TSO
RPAR     ENTER ,                                                    TSO
         L    R1,ASDAT            GET ADDRESS OF SDAT               TSO
         L         R5,RPSIZ            Receive packet size
         A         R5,SPACE            Make it printable
         STC  R5,0(,R1)           ADD SIZE INFO TO SDAT BUFFER      TSO
         IC        R5,RTIME            Receive packet time out
         A         R5,SPACE
         STC  R5,1(,R1)           PUT INTO SDAT BUFFER              TSO
         IC        R5,RPAD             Number of padding chars.
         A         R5,SPACE
         STC  R5,2(,R1)           PUT INTO SDAT BUFFER              TSO
         IC        R5,RPADCH            Pad character
         L         R3,O1H
         XR        R5,R3               CTL function (xor with 64)
         N         R5,=X'0000007F'
         STC  R5,3(,R1)           PUT INTO SDAT BUFFER              TSO
         IC        R5,REOL             EOL char I need
         A         R5,SPACE            MAKE PRINTABLE
         STC  R5,4(,R1)           PUT INTO SDAT BUFFER              TSO
         IC        R5,RQUOTE           My quote char
         STC  R5,5(,R1)           PUT INTO SDAT BUFFER              TSO
         IC        R5,EBQUOT           8-BIT QUOTE CHAR [1]
         STC  R5,6(,R1)           PUT INTO SDAT BUFFER              TSO
         IC        R5,CHKLEN           Length of checksum
         A         R5,=F'48'           Make into a real digit
         STC  R5,7(,R1)           PUT INTO SDAT BUFFER              TSO
         SR        R5,R5
         IC        R5,RPTQ             Repeat quote char
         C         R5,ZERO             Null means no
         BNE       RPAR0               Branch if doing repeat quoting
         L         R5,SPACE            If not, send a blank instead
RPAR0    STC  R5,8(,R1)           PUT INTO SDAT BUFFER              TSO
         LA   R15,10              Return size of data               TSO
         NI   SCAPA,255-LONGP     INDICATE NO EXTENDED PACKETS      TSO
         LA   R5,SPMAX            LARGEST OLD KERMIT SIZE           TSO
         C    R5,RPSIZ            CHECK AGAINST MAX PACKET SIZE     TSO
         BNL  RPARNEX             SPMAX >= RPSIZ (NO EXTENDED PKTS) TSO
         A    R5,SPACE            TOCHAR(MAXL)                      TSO
         STC  R5,0(,R1)           SAVE NEW MAXL IN SDAT             TSO
         OI   SCAPA,LONGP         INDICATE EXTENDED PACKETS         TSO
         MVI  10(R1),ABL          WINDOW SIZE IS BLANK              TSO
         L    R5,RPSIZ            GET PACKET SIZE                   TSO
         LA   R4,&SIZ7171         GET MAX SIZE FOR IBM7171          TSO
         TM   S1FLAGS,ISS1        IS IT IBM 7171/SERIES-1?          TSO
         BO   *+8                 YES                               TSO
         LA   R4,&SIZLINE         GET MAX SIZE FOR LINE TERMINALS   TSO
         S    R4,=F'7'            REDUCE BY # OVERHEAD BYTES        TSO
         CR   R4,R5                                                 TSO
         BH   *+6                                                   TSO
         LR   R5,R4               BIGGEST WE CAN ACCEPT             TSO
         SR   R4,R4               CLEAR FOR DIVIDE                  TSO
         D    R4,XLFCT            COMPUTE EXTENDED SIZE BYTES       TSO
         A    R5,SPACE            TOCHAR(MAXLX1)                    TSO
         STC  R5,11(,R1)          PUT MAXLX1 INTO SDAT BUFFER       TSO
         A    R4,SPACE            TOCHAR(MAXLX2)                    TSO
         STC  R4,12(,R1)          PUT MAXLX1 INTO SDAT BUFFER       TSO
         LA   R15,13              RETURN NEW SIZE OF DATA           TSO
RPARNEX  SR   R5,R5               CLEAR FOR IC                      TSO
         IC   R5,SCAPA            GET CAPAS BYTE                    TSO
         A    R5,SPACE            TOCHAR(CAPAS)                     TSO
         STC  R5,9(,R1)           PUT CAPAS INTO SDAT BUFFER        TSO
         RET   ,                                                    TSO
         EXIT                                                       TSO
         TITLE '(DOQUO)  Set quote character'                       TSO
* New routine to set the 8-bit quote character depending on my
* own capabilities and the other Kermit's request.  [1]
         SPACE 3                                                    TSO
DOQUO    ENTER ,
         L    R7,ARDAT            POINT TO DATA BUFFER              TSO
         CLI       EBQUOT,AN           Can I do 8-bit quoting?
         BE        DQRET               No - so forget it
         CLI       EBQUOT,AY           Can I do it if requested?
         BNE       DQ0                 No - I must quote
         MVC       EBQUOT(1),6(R7)     Set new 8-bit quote char
         SR        R3,R3
         IC        R3,EBQUOT
         L         R15,=A(PRECHK)      Validate prefix
         BALR      R14,R15
         LTR       R15,R15             Check the return code
         BNZ       DQ1                 Failed so don't do quoting
         CLC       EBQUOT(1),RQUOTE    Same prefix
         BE        DQ1                 Not allowed so no quoting
         CLC       EBQUOT(1),SQUOTE    Same prefix
         BE        DQ1                 Not allowed so no quoting
         B         DQRET               And leave
DQ0      CLI       6(R7),AY            I need quoting - can he do it?
         BE        DQRET               Yes - then all is settled
         CLI       6(R7),AN            He can't do it - don't quote
         BE        DQ1                 He needs quoting also
         CLC       EBQUOT(1),6(R7)     The quote chars must match
         BE        DQRET               We match - its ok
DQ1      MVI       EBQUOT,AN           Else, forget the quoting
DQRET    RET   ,                                                    TSO
*
* Check if prefix in R3 is in valid range: 33-62, 96-126.   If OK,
* R15 contains a zero, else -1.
*
PRECHK   C         R3,=F'33'
         BNL       PREC0               It's 33 or above
         B         PREC4               Else fail
PREC0    C         R3,=F'62'
         BH        PREC1
         B         PREC5               And 62 or below - OK
PREC1    C         R3,=F'96'
         BNL       PREC2               It's 96 or above
         B         PREC4               Else fail
PREC2    C         R3,=F'126'
         BNH       PREC5               Is 126 or below - OK
PREC4    L         R15,=F'-1'          Bad rc means we failed
         BR        R14
PREC5    SR        R15,R15             Zero rc means all is well
         BR        R14
*
         EXIT                                                       TSO
         TITLE '(TAKECMD) TAKE  command processor'                  TSO
*        This routine processes the TAKE command.  It parses the    TSO
*        operands in the command buffer, allocates the take file    TSO
*        and opens it.  It then returns to the caller and the file  TSO
*        is read as if the user had type in the commands.           TSO
*                                                                   TSO
*        On Entry:                                                  TSO
*          R1 -> Command Buffer                                     TSO
*                                                                   TSO
*        On Exit:                                                   TSO
*          R15 contains a return code                               TSO
*             0  -  Normal take command                             TSO
*             4  -  Error in processing the TAKE command            TSO
         SPACE 3                                                    TSO
TAKECMD  ENTER ,                                                    TSO
         SETSEMI                  GO INSERT SEMICOLON               TSO
         LA    R10,PPLAREA        GET ADDRESS OF PPL                TSO
         USING PPL,R10            MAKE IT ADDRESSABLE               TSO
         ST    R1,PPLCBUF         PUT ADDR OF COMMAND BUFFER IN PPL TSO
         PARSE TAKPARM,ATTN=TAKRTRN,ERR=TAKERRTN                    TSO
         CHECKPDL BAD=TAK#@PDL                                      TSO
         USING IKJPARMD,R9        MAKE PDL ADDRESSABLE              TSO
         TM    TAKDSN+6,X'80'     IS DSNAME PRESENT?                TSO
         BNO   TAK#@PDL           NO, GIVE ERROR MESSAGE AND RETURN TSO
         LH    R2,TAKDSN+4        GET LENGTH OF DSNAME              TSO
         STH   R2,FILNAMLN        SAVE LENGTH OF FILE NAME          TSO
         L     R3,TAKDSN          GET ADDRESS OF FILE NAME          TSO
         BCTR  R2,0               ADJUST FOR EX                     TSO
         EX    R2,TAKMVDS         SET UP FILE NAME                  TSO
*TAKMVDS MVC   FILNAM(*-*),0(R3)                                    TSO
         SPACE 1                                                    TSO
         XC    MBRNAMLN,MBRNAMLN  CLEAR MEMBER NAME LENGTH          TSO
         TM    TAKDSN+14,X'80'    IS MEMBER NAME PRESENT?           TSO
         BZ    TAKPREFX           NO, GO PREFIX FILE NAME           TSO
         LH    R2,TAKDSN+12       GET LENGTH OF MEMBER NAME         TSO
         STH   R2,MBRNAMLN        SAVE LENGTH                       TSO
         L     R3,TAKDSN+8        GET ADDRESS OF MEMBER NAME        TSO
         BCTR  R2,0               ADJUST FOR EX                     TSO
         EX    R2,TAKMVMB         SET UP MEMBER NAME                TSO
*TAKMVMB MVC   MBRNAM(*-*),0(R3)                                    TSO
         SPACE 1                                                    TSO
TAKPREFX TM    TAKDSN+6,X'40'     IS DSNAME QUOTED?                 TSO
         BZ    TAKPRFX            NO, GO PREFIX THE SUPPLIED FILE   TSO
         LOCATE DATASET           SEE IF DATA SET EXISTS            TSO
         LTR   R15,R15            WAS DATA SET FOUND?               TSO
         BNZ   TAKNOFND           NO, GIVE ERROR MESSAGE & RETURN   TSO
         B     TAKALCDS           YES, GO ALLOCATE DATA SET         TSO
         SPACE 1                                                    TSO
TAKPRFX  IKJRLSA PDLADDR          RELEASE THE PDL                   TSO
         XC    PDLADDR,PDLADDR    CLEAR THE PDL ADDRESS             TSO
         LA    R1,FILNAMLN        GET ADDRESS OF LENGTH & FILE NAME TSO
         L     R15,=A(PREFIXDS)   GET ADDRESS OF PREFIX ROUTINE     TSO
         BALR  R14,R15            GO PREFIX THE NAME                TSO
         B     *+4(R15)           BRANCH ON RETURN CODE             TSO
         B     TAKALCDS           0  - DATA SET FOUND               TSO
         B     TAKNOFND           4  - DATA SET NOT FOUND           TSO
         B     TAK#@PRE           8  - UNABLE TO PREFIX             TSO
         SPACE 1                                                    TSO
*        ALLOCATE THE DATA SET                                      TSO
         SPACE 1                                                    TSO
TAKALCDS LA    R8,ALLOCCB         POINT TO ALLOCATION CONTROL BLOCK TSO
         USING ALCCB,R8           MAKE IT ADDRESSABLE               TSO
         LA    R0,ALCTOLD         INDICATE "OLD" ALLOCATION         TSO
         ST    R0,ALCTYPE         PUT INTO ALCCB                    TSO
         LA    R0,FILNAMLN        GET ADDRESS OF FILE NAME & LENGTH TSO
         ST    R0,ALCDSN          PUT INTO ALCCB                    TSO
         XC    ALCMEMBR,ALCMEMBR  ASSUME NO MEMBER NAME             TSO
         SR    R0,R0              CLEAR FOR ICM                     TSO
         ICM   R0,3,MBRNAMLN      GET LENGTH OF MEMBER NAME         TSO
         BZ    TAKALC             NO, MEMBER NAME; DO ALLOCATE      TSO
         LA    R0,MBRNAMLN        GET ADDRESS OF MEMBER NAME        TSO
         ST    R0,ALCMEMBR        PUT INTO ALCCB                    TSO
TAKALC   LR    R1,R8              PASS ADDRESS OF ALCCB             TSO
         L     R15,=A(ALLOCDSN)   GET ALLOCATE ROUTINE ADDRESS      TSO
         BALR  R14,R15            GO ALLOCATE THE DATA SET          TSO
         B     *+4(R15)           BRANCH ON RETURN CODE             TSO
         B     TAKOPEN            0  -  ALLOCATION SUCCESSFUL       TSO
         B     TAKNFND            4  -  DATA SET NOT FOUND          TSO
         B     TAKALCER           8  -  ALLOCATION ERROR            TSO
         B     TAKALCER           12 -  INCOMPATIBLE DATA SET TYPE  TSO
         B     TAKALCER           16 -  UNSUPPORTED DATA SET TYPE   TSO
         SPACE 1                                                    TSO
TAKALCER WRTERM 'Error while attempting to allocate TAKE data set'  TSO
         B     TAKERRTN           GO RETURN ERROR                   TSO
         SPACE 1                                                    TSO
TAKNFND  WRTERM 'TAKE data set not found'                           TSO
         B     TAKERRTN           GO RETURN ERROR                   TSO
         SPACE 1                                                    TSO
*        OPEN THE DATA SET                                          TSO
         SPACE 1                                                    TSO
TAKOPEN  MVC   TAKEDCB+40(8),BLANKS  CLEAR DCB DDNAME               TSO
         LR    R2,R0              SAVE LENGTH OF DDNAME             TSO
         BCTR  R2,0               ADJUST FOR EX                     TSO
         EX    R2,TAKMDDN         PUT DDNAME INTO DCB               TSO
*TAKMDDN MVC   TAKEDCB+40(*-*),0(R1)                                TSO
         OPEN  (TAKEDCB,INPUT)    OPEN THE DATA SET FOR INPUT       TSO
         TM    TAKEDCB+(DCBOFLGS-IHADCB),DCBOFOPN  OPEN SUCCESSFUL  TSO
         BO    TAKOK              YES, GO RETURN TO CALLER          TSO
         WRTERM 'Unable to open TAKE data set.'                     TSO
         UNALLOC DSNAME,ADDR=ALCDSN  UNALLOCATE THE DATA SET        TSO
         B     TAKERRTN           GO RETURN ERROR                   TSO
         DROP  R8                 DROP ALCCB ADDRESSABILITY         TSO
         SPACE 1                                                    TSO
TAKOK    SR    R15,R15            INDICATE NORMAL OPERATION         TSO
         B     TAKRTRN            RETURN TO CALLER                  TSO
         SPACE 1                                                    TSO
TAK#@PRE WRTERM 'Unable to prefix TAKE command file name'           TSO
         B     TAKERRTN           GO RETURN ERROR                   TSO
TAKNOFND WRTERM 'TAKE file does not exist'                          TSO
         B     TAKERRTN           GO RETURN ERROR                   TSO
         SPACE 1                                                    TSO
TAK#@PDL WRTERM 'PARSE found invalid parameters on the TAKE command'
TAKERRTN LA    R15,4              SET ERROR RETURN CODE             TSO
TAKRTRN  RET   ,                                                    TSO
         SPACE 1                                                    TSO
TAKMVDS  MVC   FILNAM(*-*),0(R3)                                    TSO
TAKMDDN  MVC   TAKEDCB+40(*-*),0(R1)                                TSO
TAKMVMB  MVC   MBRNAM(*-*),0(R3)                                    TSO
         DROP  R10                DROP PPL ADDRESSABILITY           TSO
         DROP  R9                 DROP PDL ADDRESSABILITY           TSO
         SPACE 1                                                    TSO
         PRINT NOGEN                                                TSO
TAKPARM  IKJPARM ,                                                  TSO
TAKDSN   IKJPOSIT DSNAME,PROMPT='FILE NAME FOR TAKE'                TSO
         IKJENDP ,                                                  TSO
         PRINT GEN                                                  TSO
         SPACE 1                                                    TSO
         EXIT                                                       TSO
         TITLE '(SET) SET command processor'                        TSO
*        THIS ROUTINE PROCESSES THE "SET" COMMAND TO SET VARIOUS    TSO
*        VALUES USED BY THE REST OF KERMIT.                         TSO
*                                                                   TSO
*        THE FOLLOWING COMMANDS ARE PROCESSED:                      TSO
*                                                                   TSO
*        "SET IBM7171"                                              TSO
*        "SET SERIES1"                                              TSO
*        "SET WARNING"                                              AJR
*        "SET FILE"                                                 TSO
*        "SET DEBUG"                                                TSO
*        "SET BLOCK"                                                TSO
*        "SET RECFM"                                                TSO
*        "SET QUOTE"                                                TSO
*        "SET BLKSIZE"                                              TSO
*        "SET LRECL"                                                TSO
*        "SET END"                                                  TSO
*        "SET PACKET"                                               TSO
*        "SET ETOA"                                                 TSO
*        "SET ATOE"                                                 TSO
*        "SET ETOANCP"                                              AJR
*        "SET ATOENCP"                                              AJR
*        "SET PRIMARY"                                              TSO
*        "SET SECONDARY"                                            TSO
*        "SET DIRECTORY"                                            TSO
*        "SET TABS"                                                 TSO
*        "SET DELAY"                                                TSO
*        "SET HEADER"                                               TSO
         SPACE 3                                                    TSO
SET      ENTER ,                                                    TSO
         SETSEMI                  GO INSERT SEMI-COLON              TSO
         LA    R10,PPLAREA        POINT TO PARSE PARAMETER LIST     TSO
         USING PPL,R10            MAKE IT ADDRESSABLE               TSO
         LR    R8,R1              SAVE ADDRESS OF COMMAND BUFFER    TSO
         ST    R1,PPLCBUF         PUT ADDRESS OF CMD BUF IN PPL     TSO
         PARSE SETPARM,ATTN=SETRET,ERR=SETERR                       TSO
         CHECKPDL GOOD=SETOFFST                                     TSO
         WRTERM 'PARSE found invalid parameters on the SET command' TSO
         B     SETERR                                               TSO
         SPACE 1                                                    TSO
         USING IKJPARMD,R9        MAKE PDL ADDRESSABLE              TSO
         SPACE 1                                                    TSO
SETOFFST ICM   R0,15,NWOFFSET     GET NEW OFFSET                    TSO
         BNZ   SETKEYWD           CONTINUE OF THERE IS ONE          TSO
         WRTERM 'Missing operand on SET command'                    TSO
         B     SETERR             RETURN ERROR                      TSO
         SPACE 1                                                    TSO
SETKEYWD STH   R0,2(,R8)          PUT NEW OFFSET INTO CMND BUFFER   TSO
         LH    R8,SETCMDS         GET VALUE OF KEYWORD              TSO
         IKJRLSA PDLADDR          RELEASE THE PDL                   TSO
         XC    PDLADDR,PDLADDR    CLEAR THE PDL ADDRESS             TSO
         L     R1,PPLCBUF         GET ADDRESS OF COMMAND BUFFER     TSO
         SETSEMI                  GO FENCE OFF NEXT OPERAND         TSO
         MH    R8,=H'4'           SET UP BRANCH LIST                TSO
         B     *+4(R8)            BRANCH ON KEYWORD LIST            TSO
         B     SETERR              0 - NO KEYWORD                   TSO
         B     SETSERIE            4 - IBM7171; USE SERIES1 CODE    TSO
         B     SETSERIE            8 - SERIES1                      TSO
         B     SETWARN            12 - WARNING                      TSO
         B     SETFILE            16 - FILE                         TSO
         B     SETDEBUG           20 - DEBUG                        TSO
         B     SETBLOCK           24 - BLOCK                        TSO
         B     SETRECFM           28 - RECFM                        TSO
         B     SETQUOTE           32 - QUOTE                        TSO
         B     SETBLKSZ           36 - BLKSIZE                      TSO
         B     SETLRECL           40 - LRECL                        TSO
         B     SETEND             44 - END                          TSO
         B     SETPACET           48 - PACKET                       TSO
         B     SETETOA            52 - ETOA                         TSO
         B     SETATOE            56 - ATOE                         TSO
         B     SETETOAN           60 - ETOANCP                      AJR
         B     SETATOEN           64 - ATOENCP                      AJR
         B     SETPRIME           68 - PRIMARY                      AJR
         B     SETSECND           72 - SECONDARY                    AJR
         B     SETDIRCT           76 - DIRECTORY                    AJR
         B     SETTABS            80 - TABS                         AJR
         B     SETDELAY           84 - DELAY                        AJR
         B     SETHEAD            86 - HEADER                       AJR
         SPACE 2                                                    TSO
********************************************************************TSO
*                                                                  *TSO
*        SET UP SERIES 1 / IBM 7171 SWITCH                         *TSO
*                                                                  *TSO
********************************************************************TSO
SETSERIE L     R6,=A(HELPFLG)     GET ADDRESS OF HELPFLAG           AJR
         CLI   0(R6),X'00'        CHECK IT                          AJR
         BE    SETSERI            NOT HELP REQUEST                  AJR
ONOFFHLP LA    R1,MSG1LST         GET ADDRESS OF MESSAGE LIST       AJR
         L     R15,=A(MESG)       GET ADDRESS OF "MESG" SUBROUTINE  AJR
         BALR  R14,R15            GO DO IT!                         AJR
         B     SETOK                                                AJR
         SPACE 1                                                    AJR
SETSERI  PARSE SETONOFF,ATTN=SETOK,ERR=SETERR                       TSO
         CHECKPDL BAD=SETERR                                        TSO
         L     R6,SETONOF         GET STRING ADDRESS                TSO
         CLC   =C'ON',0(R6)       Set series/1 mode on?             TSO
         BNE       STSR0
         OI        S1FLAGS,ISS1        Set series/1 mode on
         B         SETOK
         SPACE 1
STSR0    NI        S1FLAGS,X'FF'-ISS1  Set series/1 mode off
         B         SETOK
         SPACE 1                                                    AJR
MSG1LST  DC    A(MSG1L)           ADDRESS OF MESSAGE LENGTH         AJR
         DC    A(MSG1)            ADDRESS OF MESSAGE                AJR
         SPACE 2
********************************************************************TSO
*                                                                  *TSO
*        SET UP WARNING                                            *TSO
*                                                                  *TSO
********************************************************************TSO
SETWARN  L     R6,=A(HELPFLG)     GET ADDRESS OF HELPFLAG           AJR
         CLI   0(R6),X'00'        CHECK IT                          AJR
         BNE   ONOFFHLP           GO HANDLE HELP REQUEST            AJR
         PARSE SETONOFF,ATTN=SETOK,ERR=SETERR                       AJR
         CHECKPDL BAD=SETERR                                        TSO
         L     R6,SETONOF         GET STRING ADDRESS                TSO
         CLC   =C'ON',0(R6)       Set warning on?                   TSO
         BNE       STWR0
         OI        LFLAGS,WARFL        Set warning on
         B         SETOK
         SPACE 1
STWR0    NI        LFLAGS,X'FF'-WARFL  Set warning off
         B         SETOK
         SPACE 2
********************************************************************TSO
*                                                                  *TSO
*        SET UP FILE TYPE                                          *TSO
*                                                                  *TSO
********************************************************************TSO
SETFILE  L     R6,=A(HELPFLG)     GET ADDRESS OF HELPFLAG           AJR
         CLI   0(R6),X'00'        CHECK IT                          AJR
         BE    SETFIL             NOT HELP REQUEST                  AJR
         LA    R1,MSG2LST         GET ADDRESS OF MESSAGE LIST       AJR
         L     R15,=A(MESG)       GET ADDRESS OF "MESG" SUBROUTINE  AJR
         BALR  R14,R15            GO DO IT!                         AJR
         B         SETOK                                            AJR
         SPACE 1                                                    AJR
SETFIL   PARSE SETSUBFL,ATTN=SETOK,ERR=SETERR                       TSO
         CHECKPDL BAD=SETERR                                        TSO
         L     R6,SETKYFIL        GET STRING ADDRESS                TSO
         CLC   =C'B',0(R6)        Setting to BINARY?                AJR
         BNE       STBNV               No maybe it's V-BINARY       AJR
         OI        FLAGS,BINF          Set binary on
         MVC   TYPFIL,0(R6)       Save Binary TYPFIL (B)            AJR
         LH    R0,LRECL           GET LRECL                         TSO
         ST    R0,MAXOUT          SET MAXIMUM OUTPUT BUFFER SIZE    TSO
         B         SETOK
         SPACE 1
STBNV    CLC   =C'V',0(R6)        Setting to V-BINARY?              AJR
         BNE       STBN0               No maybe it's TEXT           AJR
         OI        FLAGS,BINF          Set binary on                AJR
         MVC   TYPFIL,0(R6)       Save V-Binary TYPFIL (V)          AJR
         B         SETOK                                            AJR
         SPACE 1                                                    AJR
STBN0    NI        FLAGS,X'FF'-BINF    Set it OFF  (Not Binary)     AJR
         MVC   TYPFIL,0(R6)       Save Text TYPFIL (T)              AJR
         MVC       MAXOUT,=A(MAXTXT)   Max output buffer size
         B         SETOK
         SPACE 1
MSG2LST  DC    A(MSG2L)           ADDRESS OF MESSAGE LENGTH         AJR
         DC    A(MSG2)            ADDRESS OF MESSAGE                AJR
         SPACE 2                                                    TSO
********************************************************************TSO
*                                                                  *TSO
*        SET UP DEBUG                                              *TSO
*                                                                  *TSO
********************************************************************TSO
SETDEBUG L     R6,=A(HELPFLG)     GET ADDRESS OF HELPFLAG           AJR
         CLI   0(R6),X'00'        CHECK IT                          AJR
         BNE   ONOFFHLP           GO HANDLE HELP REQUEST            AJR
         PARSE SETONOFF,ATTN=SETOK,ERR=SETERR                       TSO
         CHECKPDL BAD=SETERR                                        TSO
         L     R6,SETONOF       GET STRING ADDRESS                  TSO
         CLC   =C'ON',0(R6)     Setting it on?                      TSO
         BNE       STDEB3              No maybe it's OFF
         SPACE 1                                                    TSO
*        PREFIX THE LOG DATA SET NAME AND DETERMINE IF A NEW OR     TSO
*        OLD DATA SET MUST BE ALLOCATED.                            TSO
         SPACE 1                                                    TSO
         MVC   SYSLOG,BLANKS      MAKE SURE LOG DATA SET            TSO
         MVC   SYSLOG,=C'KERMLOG' IS NOT PREFIXED TO START WITH     TSO
         LA    R0,7               RESET LOG DATA SET                TSO
         STH   R0,SYSLOGLN        NAME LENGTH                       TSO
         LA    R1,SYSLOGLN        GET ADDRESS OF LENGTH & FILE NAME TSO
         L     R15,=A(PREFIXDS)   GET ADDRESS OF PREFIX ROUTINE     TSO
         BALR  R14,R15            GO PREFIX THE NAME                TSO
         B     *+4(R15)           BRANCH ON RETURN CODE             TSO
         B     LOGOLD             0  - OLD DATA SET                 TSO
         B     LOGNEW             4  - NEW DATA SET                 TSO
         B     LOG#@PRE           8  - UNABLE TO PREFIX             TSO
         SPACE 1                                                    TSO
*        ALLOCATE THE LOG DATA SET                                  TSO
         SPACE 1                                                    TSO
LOGOLD   PROMPT 'Log data set exists.  Enter OK to overwrite:'      TSO
         B     *+4(R15)           BRANCH ON RETURN CODE             TSO
         B     LOGREPLY           0  - REPLY RECEIVED               TSO
         B     SETERR             4  - ATTENTION; GO RETURN         TSO
         SPACE 1                                                    TSO
LOGREPLY LH    R0,0(,R1)          GET LENGTH OF REPLY               TSO
         S     R0,=F'4'           ADJUST FOR LENGTH & OFFSET        TSO
         BZ    LOGOLD             IF ZERO PROMPT AGAIN              TSO
         OC    4(2,R1),=C'  '     UPCASE 1ST 2 CHARACTERS OF REPLY  TSO
         CLC   =C'OK',4(R1)       WAS REPLY "OK"?                   TSO
         BNE   SETERR             NO, GO RETURN                     TSO
         LA    R1,ALLOCCB         GET ADDRESS OF ALLOCATE CB        TSO
         USING ALCCB,R1           MAKE IT ADDRESSABLE               TSO
         LA    R0,ALCTOLD         INDICATE "OLD" ALLOCATION         TSO
         ST    R0,ALCTYPE         PUT INTO ALCCB                    TSO
         B     LOGALCDS           GO ALLOCATE THE FILE              TSO
         SPACE 1                                                    TSO
*        ALLOCATE NEW LOG DATA SET                                  TSO
         SPACE 1                                                    TSO
LOGNEW   LA    R1,ALLOCCB         POINT TO ALLOCATE CB              TSO
         LA    R0,ALCTNEW         INDICATE "NEW" ALLOCATION         TSO
         ST    R0,ALCTYPE         PUT INTO ALCCB                    TSO
LOGALCDS LA    R0,SYSLOGLN        GET ADDRESS OF FILE NAME & LENGTH TSO
         ST    R0,ALCDSN          PUT INTO ALCCB                    TSO
         OI    ALCTYPE+3,ALCNCONC INDICATE DON'T ADD TO CONC TABLE  TSO
         XC    ALCMEMBR,ALCMEMBR  CAN'T BE PDS                      TSO
         L     R15,=A(ALLOCDSN)   GET ADDRESS OF ALLOCATE ROUTINE   TSO
         BALR  R14,R15            GO ALLOCATE THE DATA SET          TSO
         B     *+4(R15)           BRANCH ON RETURN CODE             TSO
         B     LOGOPEN            0  - ALLOCATION SUCCESSFUL        TSO
         B     LOGNFND            4  - DATA SET NOT FOUND           TSO
         B     LOGALCER           8  - ALLOCATION ERROR             TSO
         B     LOGALCER           12 - INCOMPATIBLE DATA SET TYPE   TSO
         B     LOGALCER           16 - UNSUPPORTED DATA SET TYPE    TSO
         SPACE 1                                                    TSO
LOGALCER WRTERM 'Error while attempting to allocate LOG data set'   TSO
         B     SETERR             GO RETURN ERROR                   TSO
         SPACE 1                                                    TSO
LOGNFND  WRTERM 'LOG data set not found'                            TSO
         B     SETERR             GO RETURN ERROR                   TSO
         SPACE 1                                                    TSO
*        OPEN THE LOG DATA SET                                      TSO
         SPACE 1                                                    TSO
LOGOPEN  MVC   LOGDCB+40(8),BLANKS  CLEAR DCB DDNAME                TSO
         LR    R2,R0              SAVE LENGTH OF DDNAME             TSO
         BCTR  R2,0               ADJUST FOR EX                     TSO
         EX    R2,LOGMDDN         PUT DDNAME INTO DCB               TSO
*LOGMDDN MVC   LOGDCB+40(*-*),0(R1)                                 TSO
         OPEN  (LOGDCB,OUTPUT)    OPEN THE DATA SET FOR OUTPUT      TSO
         TM    LOGDCB+(DCBOFLGS-IHADCB),DCBOFOPN  OPEN SUCCESSFUL?  TSO
         BZ    LOGNOPEN           NO                                TSO
         OI    FLAGS,DEBUG        TURN ON DEBUG FLAG                TSO
         B     SETOK              AND CONTINUE                      TSO
         SPACE 1                                                    TSO
LOGNOPEN WRTERM 'Unable to open LOG data set'                       TSO
         UNALLOC DSNAME,ADDR=ALCDSN  UNALLOCATE THE DATA SET        TSO
         B     SETERR             GO RETURN ERROR                   TSO
         DROP  R1                 DROP ALCCB ADDRESSABILITY         TSO
         SPACE 1                                                    TSO
LOG#@PRE WRTERM 'Unable to prefix LOG data set name'                TSO
         B     SETERR             GO RETURN ERROR                   TSO
         SPACE 1
LOGMDDN  MVC   LOGDCB+40(*-*),0(R1)                                 TSO
         SPACE 3                                                    TSO
STDEB3   NI        FLAGS,X'FF'-DEBUG   Set it OFF
         CLOSE (LOGDCB)           CLOSE LOG DATA SET                TSO
         B         SETOK
         SPACE 2
********************************************************************TSO
*                                                                  *TSO
*        SET UP BLOCK CHECK                                        *TSO
*                                                                  *TSO
********************************************************************TSO
SETBLOCK L     R6,=A(HELPFLG)     GET ADDRESS OF HELPFLAG           AJR
         CLI   0(R6),X'00'        CHECK IT                          AJR
         BE    SETBLOK            NOT HELP REQUEST                  AJR
         LA    R1,MSG3LST         GET ADDRESS OF MESSAGE LIST       AJR
         L     R15,=A(MESG)       GET ADDRESS OF "MESG" SUBROUTINE  AJR
         BALR  R14,R15            GO DO IT!                         AJR
         B         SETOK                                            AJR
         SPACE 1                                                    AJR
SETBLOK  PARSE SETSUBBL,ATTN=SETOK,ERR=SETERR                       TSO
         CHECKPDL BAD=SETERR                                        TSO
         L     R6,SETBLKCK      GET STRING ADDRESS                  TSO
         SR        R4,R4
         IC        R4,0(,R6)           Pick it up
         S         R4,=F'240'          Shouldn't be printable
         STC       R4,CHKLEN           Pick up block check
         STC       R4,CHKSET           Store here too
         B         SETOK
         SPACE 1
MSG3LST  DC    A(MSG3L)         ADDRESS OF MESSAGE LENGTH           AJR
         DC    A(MSG3)          ADDRESS OF MESSAGE                  AJR
         SPACE 2
********************************************************************TSO
*                                                                  *TSO
*        SET UP RECFM                                              *TSO
*                                                                  *TSO
********************************************************************TSO
SETRECFM L     R6,=A(HELPFLG)     GET ADDRESS OF HELPFLAG           AJR
         CLI   0(R6),X'00'        CHECK IT                          AJR
         BE    SETRECF            NOT HELP REQUEST                  AJR
         LA    R1,MSG4LST         GET ADDRESS OF MESSAGE LIST       AJR
         L     R15,=A(MESG)       GET ADDRESS OF "MESG" SUBROUTINE  AJR
         BALR  R14,R15            GO DO IT!                         AJR
         B         SETOK                                            AJR
         SPACE 1                                                    AJR
SETRECF  PARSE SETSUBRC,ATTN=SETOK,ERR=SETERR                       TSO
         CHECKPDL BAD=SETERR                                        TSO
         L     R6,SETRCFRM      GET ADDRESS OF STRING               TSO
         LR    R1,R6            POINT TO NEW RECFM                  TSO
         LH    R2,LRECL         PASS LRECL                          TSO
         LH    R3,BLKSIZE       PASS BLKSIZE                        TSO
         L     R15,=A(SETCHKLR) GET ADDRESS OF CHECK ROUTINE        SEB
         BALR  R14,R15          GO CHECK LRECL/BLKSIZE              SEB
         MVC       RFM(1),0(R6)        PICK UP RECFM
         B     *+4(R15)         BRANCH ON RETURN CODE FROM CHECK    SEB
         B     SETOK            0 - RECFM IS OK                     SEB
         B     BLKPRMT          4 - GO PROMPT FOR NEW BLKSIZE       SEB
         SPACE 1                                                    TSO
MSG4LST  DC    A(MSG4L)         ADDRESS OF MESSAGE LENGTH           AJR
         DC    A(MSG4)          ADDRESS OF MESSAGE                  AJR
         SPACE 2
********************************************************************TSO
*                                                                  *TSO
*        SET UP QUOTE CHARACTER                                    *TSO
*                                                                  *TSO
********************************************************************TSO
SETQUOTE L     R6,=A(HELPFLG)     GET ADDRESS OF HELPFLAG           AJR
         CLI   0(R6),X'00'        CHECK IT                          AJR
         BE    SETQUOT            NOT HELP REQUEST                  AJR
         LA    R1,MSG5LST         GET ADDRESS OF MESSAGE LIST       AJR
         L     R15,=A(MESG)       GET ADDRESS OF "MESG" SUBROUTINE  AJR
         BALR  R14,R15            GO DO IT!                         AJR
         B         SETOK                                            AJR
         SPACE 1                                                    AJR
SETQUOT  PARSE SETSUBQT,ATTN=SETOK,ERR=SETERR                       TSO
         CHECKPDL BAD=SETERR                                        TSO
         L     R6,SETQT         GET ADDRESS OF STRING               TSO
         MVC       RQUOTE(1),0(R6)     SET NEW QUOTE CHAR
         TR        RQUOTE(1),ETOA      GET ASCII FORM
         CLI       RQUOTE,X'21'        CAN'T BE LESS THAN 33
         BL        BADQUO
         CLI       RQUOTE,X'7E'        CAN'T BE LARGER THAN 126
         BH        BADQUO
         CLI       RQUOTE,X'3E'        HAS TO BE BETWEEN 33-62
         BNH       SETOK
         CLI       RQUOTE,X'60'        OR BETWEEN 96-126
         BNL       SETOK
         SPACE 1                                                    TSO
BADQUO   MVI       RQUOTE,DQUOTE       RESTORE DEFAULT QUOTE CHAR   AJR
         LA    R1,MSG5LST       GET ADDRESS OF MESSAGE LIST         AJR
         L     R15,=A(MESG)     GET ADDRESS OF "MESG" SUBROUTINE    AJR
         BALR  R14,R15          GO DO IT!                           AJR
         B         SETERR                                           AJR
         SPACE 1                                                    AJR
MSG5LST  DC    A(MSG5L)         ADDRESS OF MESSAGE LENGTH           AJR
         DC    A(MSG5)          ADDRESS OF MESSAGE                  AJR
         SPACE 2
********************************************************************TSO
*                                                                  *TSO
*        SET UP LRECL                                              *TSO
*                                                                  *TSO
********************************************************************TSO
SETLRECL L     R6,=A(HELPFLG)     GET ADDRESS OF HELPFLAG           AJR
         CLI   0(R6),X'00'        CHECK IT                          AJR
         BE    SETLREC            NOT HELP REQUEST                  AJR
         LA    R1,MSG6LST       GET ADDRESS OF MESSAGE LIST         AJR
         L     R15,=A(MESG)     GET ADDRESS OF "MESG" SUBROUTINE    AJR
         BALR  R14,R15          GO DO IT!                           AJR
LRECLHLP LA    R1,MSG7LST       GET ADDRESS OF MESSAGE LIST         AJR
         L     R15,=A(MESG)     GET ADDRESS OF "MESG" SUBROUTINE    AJR
         BALR  R14,R15          GO DO IT!                           AJR
         LA    R1,MSG8LST       GET ADDRESS OF MESSAGE LIST         AJR
         L     R15,=A(MESG)     GET ADDRESS OF "MESG" SUBROUTINE    AJR
         BALR  R14,R15          GO DO IT!                           AJR
         LA    R1,MSG15LST      GET ADDRESS OF MESSAGE LIST         AJR
         L     R15,=A(MESG)     GET ADDRESS OF "MESG" SUBROUTINE    AJR
         BALR  R14,R15          GO DO IT!                           AJR
         B     SETOK                                                AJR
         SPACE 1                                                    AJR
SETLREC  PARSE SETSUBLR,ATTN=SETOK,ERR=SETERR                       TSO
         CHECKPDL BAD=SETERR                                        TSO
         L     R6,SETLR         GET ADDRESS OF STRING               TSO
         L         R15,=A(GETNUM)      Get decimal number [20]
         BALR      R14,R15             Use common routine [20]
         LR    R2,R7              PASS LRECL                        TSO
         LH    R3,BLKSIZE         PASS BLKSIZE                      TSO
         LA    R1,RFM             PASS ADDRESS OF RECFM             TSO
         L     R15,=A(SETCHKLR)   GET ADDRESS OF CHECK ROUTINE      SEB
         BALR  R14,R15            GO CHECK LRECL/BLKSIZE            SEB
         STH   R7,LRECL           SET THE LRECL VALUE      [ ]      SEB
         B     *+4(R15)           BRANCH ON RETURN CODE             SEB
         B     BINCHK             0 - LRECL IS OK               AJR SEB
         B     BLKPRMT            4 - GO PROMPT FOR NEW BLKSIZE     SEB
         SPACE 1                                                    SEB
LRLPRMT  LINEDIT TEXT='BLKSIZE STORED= .....',SUB=(DEC,(R7))        AJR
         PROMPT 'Enter new LRECL value:'                            SEB
         B     *+4(R15)           BRANCH ON RETURN CODE             SEB
         B     LRECLNEW           0 - GOT A NEW LRECL               SEB
         B     SETERR             4 - ATTENTION, RETURN ERROR       SEB
         SPACE 1                                                    SEB
LRECLNEW LH    R0,0(,R1)          GET LENGTH OF COMMAND BUFFER      SEB
         S     R0,=F'4'           SUBTRACT LENGTH OF HEADER         SEB
         BZ    LRLPRMT            PROMPT AGAIN IF NULL LINE         SEB
         ST    R1,CMDBUF          SAVE COMMAND BUFFER ADDRESS       TSO
         ST    R1,PPLCBUF         SAVE IN PPL TOO               AJR SEB
         B     SETLREC            PROCESS LRECL                 AJR SEB
         SPACE 1                                                    SEB
BINCHK   TM    FLAGS,BINF         BINARY FILE?                      AJR
         BNO   SETOK              NO, EVERYTHING IS OK              AJR
         CLI   TYPFIL,C'V'        BINARY FILE...IS IT V-BINARY?     AJR
         BE    SETOK              YES, EVERYTHING IS OK             AJR
         ST    R7,MAXOUT          NO, SET MAXOUT TO LRECL VALUE     AJR
         B     SETOK              EVERYTHING IS OK                  TSO
         SPACE 1                                                    TSO
MSG6LST  DC    A(MSG6L)         ADDRESS OF MESSAGE LENGTH           AJR
         DC    A(MSG6)          ADDRESS OF MESSAGE                  AJR
         SPACE 1                                                    AJR
MSG7LST  DC    A(MSG7L)         ADDRESS OF MESSAGE LENGTH           AJR
         DC    A(MSG7)          ADDRESS OF MESSAGE                  AJR
         SPACE 1                                                    AJR
MSG8LST  DC    A(MSG8L)         ADDRESS OF MESSAGE LENGTH           AJR
         DC    A(MSG8)          ADDRESS OF MESSAGE                  AJR
         SPACE 1                                                    TSO
MSG15LST DC    A(MSG15L)        ADDRESS OF MESSAGE LENGTH           AJR
         DC    A(MSG15)         ADDRESS OF MESSAGE                  AJR
         SPACE 2
********************************************************************TSO
*                                                                  *TSO
*        SET UP BLOCK SIZE                                         *TSO
*                                                                  *TSO
********************************************************************TSO
SETBLKSZ L     R6,=A(HELPFLG)     GET ADDRESS OF HELPFLAG           AJR
         CLI   0(R6),X'00'        CHECK IT                          AJR
         BE    SETBLKS            NOT HELP REQUEST                  AJR
         LA    R1,MSG9LST       GET ADDRESS OF MESSAGE LIST         AJR
         L     R15,=A(MESG)     GET ADDRESS OF "MESG" SUBROUTINE    AJR
         BALR  R14,R15          GO DO IT!                           AJR
         B     LRECLHLP         GO DO SOME MORE MESSAGES            AJR
         SPACE 1                                                    AJR
SETBLKS  PARSE SETBLK,ATTN=SETOK,ERR=SETERR                         TSO
         CHECKPDL BAD=SETERR                                        TSO
         L     R6,SETBLSZ       GET ADDRESS OF STRING               TSO
         L         R15,=A(GETNUM)      Get decimal number [20]      TSO
         BALR      R14,R15             Use common routine [20]      TSO
         LR    R3,R7              PASS BLKSIZE                      TSO
         LH    R2,LRECL           PASS LRECL                        TSO
         LA    R1,RFM             PASS ADDRESS OF RECFM             TSO
         L     R15,=A(SETCHKLR)   GET ADDRESS OF CHECK ROUTINE      SEB
         BALR  R14,R15            GO CHECK LRECL/BLKSIZE            SEB
         STH   R7,BLKSIZE         SET THE BLKSIZE VALUE             TSO
         B     *+4(R15)           BRANCH ON RETURN CODE             SEB
         B     SETOK              0 - BLKSIZE IS OK                 SEB
         B     LRLPRMT            4 - GO PROMPT FOR NEW LRECL   AJR SEB
         SPACE 1                                                    SEB
BLKPRMT  LINEDIT TEXT='LRECL STORED= .....',SUB=(DEC,(R7))          AJR
         PROMPT 'Enter new BLKSIZE value: '                         SEB
         B     *+4(R15)           BRANCH ON RETURN CODE             SEB
         B     BLKSZNEW           0 - GOT A NEW BLKSIZE             SEB
         B     SETERR             4 - ATTENTION, RETURN ERROR       SEB
         SPACE 1                                                    SEB
BLKSZNEW LH    R0,0(,R1)          GET LENGTH OF COMMAND BUFFER      SEB
         S     R0,=F'4'           SUBTRACT LENGTH OF HEADER         SEB
         BZ    BLKPRMT            PROMPT AGAIN IF NULL LINE         SEB
         ST    R1,CMDBUF          SAVE COMMAND BUFFER ADDRESS       TSO
         ST    R1,PPLCBUF         SAVE IN PPL TOO               AJR SEB
         B     SETBLKS            PROCESS BLKSIZE               AJR SEB
         SPACE 1                                                    AJR
STBLKHLP LA    R1,MSG9LST       GET ADDRESS OF MESSAGE LIST         AJR
         L     R15,=A(MESG)     GET ADDRESS OF "MESG" SUBROUTINE    AJR
         BALR  R14,R15          GO DO IT!                           AJR
         B     SETOK                                                AJR
         SPACE 1                                                    AJR
MSG9LST  DC    A(MSG9L)         ADDRESS OF MESSAGE LENGTH           AJR
         DC    A(MSG9)          ADDRESS OF MESSAGE                  AJR
         SPACE 2                                                    TSO
********************************************************************TSO
*                                                                  *TSO
*        SET UP PRIMARY ALLOCATION                                 *TSO
*                                                                  *TSO
********************************************************************TSO
SETPRIME L     R6,=A(HELPFLG)     GET ADDRESS OF HELPFLAG           AJR
         CLI   0(R6),X'00'        CHECK IT                          AJR
         BE    STPRIME            NOT HELP REQUEST                  AJR
STALOHLP LA    R1,MSG10LST      GET ADDRESS OF MESSAGE LIST         AJR
         L     R15,=A(MESG)     GET ADDRESS OF "MESG" SUBROUTINE    AJR
         BALR  R14,R15          GO DO IT!                           AJR
         B         SETOK                                            AJR
         SPACE 1                                                    AJR
STPRIME  PARSE SETPRI,ATTN=SETOK,ERR=SETERR                         TSO
         CHECKPDL BAD=SETERR                                        TSO
         L     R6,SETPRIM       GET ADDRESS OF STRING               TSO
         L         R15,=A(GETNUM)      Get decimal number [20]      TSO
         BALR      R14,R15             Use common routine [20]      TSO
         STH   R7,PRIME           SET THE PRIMARY ALLOCATION VALUE  TSO
         B         SETOK                                            TSO
         SPACE 1                                                    TSO
MSG10LST DC    A(MSG10L)        ADDRESS OF MESSAGE LENGTH           AJR
         DC    A(MSG10)         ADDRESS OF MESSAGE                  AJR
         SPACE 2                                                    TSO
********************************************************************TSO
*                                                                  *TSO
*        SET UP SECONDARY ALLOCATION                               *TSO
*                                                                  *TSO
********************************************************************TSO
SETSECND L     R6,=A(HELPFLG)     GET ADDRESS OF HELPFLAG           AJR
         CLI   0(R6),X'00'        CHECK IT                          AJR
         BE    STSECND            NOT HELP REQUEST                  AJR
         B     STALOHLP           GET HELP                          AJR
         SPACE 1                                                    AJR
STSECND  PARSE SETSEC,ATTN=SETOK,ERR=SETERR                         TSO
         CHECKPDL BAD=SETERR                                        TSO
         L     R6,SETSECN       GET ADDRESS OF STRING               TSO
         L         R15,=A(GETNUM)      Get decimal number [20]      TSO
         BALR      R14,R15             Use common routine [20]      TSO
         STH   R7,SECOND          SET THE SECONDARY ALLOC VALUE     TSO
         B         SETOK                                            TSO
         SPACE 2                                                    TSO
********************************************************************TSO
*                                                                  *TSO
*        SET UP PDS DIRECTORY BLOCKS                               *TSO
*                                                                  *TSO
********************************************************************TSO
SETDIRCT L     R6,=A(HELPFLG)     GET ADDRESS OF HELPFLAG           AJR
         CLI   0(R6),X'00'        CHECK IT                          AJR
         BE    STDIRCT            NOT HELP REQUEST                  AJR
         LA    R1,MSG11LST      GET ADDRESS OF MESSAGE LIST         AJR
         L     R15,=A(MESG)     GET ADDRESS OF "MESG" SUBROUTINE    AJR
         BALR  R14,R15          GO DO IT!                           AJR
         B         SETOK                                            AJR
         SPACE 1                                                    AJR
STDIRCT  PARSE SETDIR,ATTN=SETOK,ERR=SETERR                         TSO
         CHECKPDL BAD=SETERR                                        TSO
         L     R6,SETDIRC       GET ADDRESS OF STRING               TSO
         L         R15,=A(GETNUM)      Get decimal number [20]      TSO
         BALR      R14,R15             Use common routine [20]      TSO
         STH   R7,DIRCTY          SET THE DIRECTORY VALUE FOR PDS   TSO
         B         SETOK                                            TSO
         SPACE 1                                                    TSO
MSG11LST DC    A(MSG11L)        ADDRESS OF MESSAGE LENGTH           AJR
         DC    A(MSG11)         ADDRESS OF MESSAGE                  AJR
         SPACE 2                                                    TSO
********************************************************************TSO
*                                                                  *TSO
*        SET UP END-OF-LINE CHARACTER                              *TSO
*                                                                  *TSO
********************************************************************TSO
SETEND   L     R6,=A(HELPFLG)     GET ADDRESS OF HELPFLAG           AJR
         CLI   0(R6),X'00'        CHECK IT                          AJR
         BE    SETEN              NOT HELP REQUEST                  AJR
         LA    R1,MSG12LST      GET ADDRESS OF MESSAGE LIST         AJR
         L     R15,=A(MESG)     GET ADDRESS OF "MESG" SUBROUTINE    AJR
         BALR  R14,R15          GO DO IT!                           AJR
         B         SETOK                                            AJR
         SPACE 1                                                    AJR
SETEN    PARSE SETSUBEN,ATTN=SETOK,ERR=SETERR                       TSO
         CHECKPDL BAD=SETERR                                        TSO
         L     R6,SETEOL        GET END-OF-LINE CHARACTER           TSO
         L         R15,=A(GETNUM)      Get decimal number [20]
         BALR      R14,R15             Use common routine [20]
         STC       R7,SEOL             SET SEND EOL VALUE
         B         SETOK
         SPACE 1                                                    TSO
MSG12LST DC    A(MSG12L)        ADDRESS OF MESSAGE LENGTH           AJR
         DC    A(MSG12)         ADDRESS OF MESSAGE                  AJR
         SPACE 2
********************************************************************TSO
*                                                                  *TSO
*        SET UP PACKET SIZE                                        *TSO
*                                                                  *TSO
********************************************************************TSO
SETPACET L     R6,=A(HELPFLG)     GET ADDRESS OF HELPFLAG           AJR
         CLI   0(R6),X'00'        CHECK IT                          AJR
         BE    SETPACE            NOT HELP REQUEST                  AJR
         LA    R1,MSG13LST      GET ADDRESS OF MESSAGE LIST         AJR
         L     R15,=A(MESG)     GET ADDRESS OF "MESG" SUBROUTINE    AJR
         BALR  R14,R15          GO DO IT!                           AJR
         B         SETOK                                            AJR
         SPACE 1                                                    AJR
SETPACE  PARSE SETSUBPC,ATTN=SETOK,ERR=SETERR                       TSO
         CHECKPDL BAD=SETERR                                        TSO
         L     R6,SETPACK       GET ADDRESS OF STRING               TSO
         L         R15,=A(GETNUM)      Get decimal number [20]
         BALR      R14,R15             Use common routine [20]
         ST        R7,RPSIZ            USE THIS VALUE NOW
         C     R7,=F'94'        SETTING LONG PACKETS?               TSO
         BNH   SETOK            NO                                  TSO
         WRTERM 'Type 0 long packets specified'                     TSO
         B         SETOK
         SPACE 1                                                    TSO
MSG13LST DC    A(MSG13L)        ADDRESS OF MESSAGE LENGTH           AJR
         DC    A(MSG13)         ADDRESS OF MESSAGE                  AJR
         SPACE 2
********************************************************************TSO
*                                                                  *TSO
*        SET UP EBCDIC TO ASCII TRANSLATE TABLE CHANGE             *TSO
*                                                                  *TSO
********************************************************************TSO
* Use common code to change ATOE or ETOA.  R9 points to table to edit.
* SETETOA sets translate table used for everything except NCP.      AJR
* SETETOAN sets translate table used for NCP only.                  AJR
         SPACE 1
SETETOA  LA    R8,ETOA          ADDRESS OF TABLE TO CHANGE          TSO
SETET0   L     R6,=A(HELPFLG)   GET ADDRESS OF HELPFLAG             AJR
         CLI   0(R6),X'00'      CHECK IT                            AJR
         BE    SETE0                                                AJR
         LA    R1,MSG14LST      GET ADDRESS OF MESSAGE LIST         AJR
         L     R15,=A(MESG)     GET ADDRESS OF "MESG" SUBROUTINE    AJR
         BALR  R14,R15          GO DO IT!                           AJR
         B         SETOK                                            AJR
SETE0    SETSEMI                  GO SET SEMICOLON                  AJR
         PARSE SETSUBET,ATTN=SETOK,ERR=SETERR                       TSO
         CHECKPDL BAD=SETERR                                        TSO
         L     R6,SETTRAN1      GET ADDRESS OF STRING               TSO
         L         R15,=A(GETNUM)      Get table offset
         BALR      R14,R15             Use common routine
         LR        R2,R7               Save table offset here
         L     R6,SETTRAN2       GET ADDRESS OF STRING              TSO
         L         R15,=A(GETNUM)      Get value to change it to
         BALR      R14,R15
         AR    R8,R2              Location of byte to change        TSO
         STC   R7,0(R8)           Change value                      TSO
         B         SETOK               All done
         SPACE 1                                                    TSO
MSG14LST DC    A(MSG14L)        ADDRESS OF MESSAGE LENGTH           AJR
         DC    A(MSG14)         ADDRESS OF MESSAGE                  AJR
         SPACE 1                                                    AJR
SETETOAN L     R8,ETOANCPA        Address of table to change (NCP)  AJR
         B         SETET0         Treat same as ETOA                AJR
         SPACE 2
********************************************************************TSO
*                                                                  *TSO
*        SET UP ASCII TO EBCDIC TRANSLATE TABLE CHANGE             *TSO
*                                                                  *TSO
********************************************************************TSO
* SETATOE sets translate table used for everything except NCP.      AJR
* SETATOEN sets translate table used for NCP only.                  AJR
SETATOE  LA    R8,ATOE            Addr of table to edit             TSO
         B     SETET0             TREAT SAME AS ETOA                TSO
SETATOEN L     R8,ATOENCPA        Addr of table to edit  (NCP)      AJR
         B     SETET0             TREAT SAME AS ETOA                AJR
         SPACE 2
********************************************************************TSO
*                                                                  *TSO
*        SET UP TABS                                               *TSO
*                                                                  *TSO
********************************************************************TSO
SETTABS  L     R6,=A(HELPFLG)     GET ADDRESS OF HELPFLAG           AJR
         CLI   0(R6),X'00'        CHECK IT                          AJR
         BE    SETTABSS           NOT HELP REQUEST                  AJR
         LA    R1,MSG17LST        GET ADDRESS OF MESSAGE LIST       AJR
         L     R15,=A(MESG)       GET ADDRESS OF "MESG" SUBROUTINE  AJR
         BALR  R14,R15            GO DO IT!                         AJR
         B     SETOK              ALL THROUGH                       AJR
         SPACE 1                                                    AJR
SETTABSS DS    0H                                                   AJR
         L     R1,CMDBUF          GET ADDRESS OF COMMAND BUFFER     TSO
         L     R3,NWOFFSET        GET OFFSET TO CURRENT SEMI-COLON  TSO
         LA    R3,3(R3,R1)        POINT TO SEMI-COLON               TSO
         MVI   0(R3),C' '         REMOVE THE SEMI-COLON             TSO
         SPACE 1                                                    TSO
STTSETTB PARSE SETTABLS,ATTN=SETOK,ERR=SETERR                       TSO
         CHECKPDL BAD=SETERR                                        TSO
         CLI   SETTBSWI+1,1       WAS "ON" SPECIFIED?               TSO
         BE    STTABON            YES                               TSO
         CLI   SETTBSWI+1,2       WAS "OFF" SPECIFIED?              TSO
         BE    STTABOFF           YES                               TSO
         SPACE 1                                                    TSO
*        "DEFAULT" WAS SPECIFIED. SET UP DEFAULTS.                  TSO
         SPACE 1                                                    TSO
         MVC   TABCOUNT,MAXTABS   SET UP DEFAULT TAB COUNT          TSO
         MVC   TABTBL(&NUMTABS),DFLTTABS                            TSO
         MVI   TABSWI,1           SET TABS ON                       TSO
         B     SETRET             ALL THROUGH                       TSO
         SPACE 1                                                    TSO
MSG17LST DC    A(MSG17L)          ADDRESS OF MESSAGE LENGTH         AJR
         DC    A(MSG17)           ADDRESS OF MESSAGE                AJR
         SPACE 1                                                    TSO
*        PROCESS "OFF" REQUEST                                      TSO
         SPACE 1                                                    TSO
STTABOFF MVI   TABSWI,0           SET TABS OFF                      TSO
         B     SETRET             ALL THROUGH                       TSO
         SPACE 1                                                    TSO
*        PROCESS "ON" REQUEST                                       TSO
         SPACE 1                                                    TSO
STTABON  MVI   TABSWI,1           SET TABS ON                       TSO
         TM    SETTBSET+6,X'80'   WAS A SET OF TABS SPECIFIED?      TSO
         BZ    SETRET             NO, ALL THROUGH                   TSO
         SPACE 1                                                    TSO
         SR    R2,R2              CLEAR COUNTER                     TSO
         SR    R4,R4              CLEAR HI TAB REG                  TSO
         LA    R3,TABTBL          POINT TO START OF TAB TABLE       TSO
         LA    R5,SETTBSET        POINT TO START OF LIST            TSO
STTABLOP L     R6,0(,R5)          GET ADDRESS OF TAB SETTING        TSO
         L     R15,=A(GETNUM)     GET DECIMAL NUMBER                TSO
         BALR  R14,R15            USE COMMON ROUTINE                TSO
         CR    R4,R7              IS NEXT TAB HIGHER THAN PREVIOUS? TSO
         BNL   STTABSEQ           NO, TAB OUT OF SEQUENCE           TSO
         LR    R4,R7              SET UP TO COMPARE NEXT TAB        TSO
         LA    R2,1(,R2)          BUMP COUNTER                      TSO
         CH    R2,MAXTABS         EXCEEDED CAPACITY?                TSO
         BH    STTABHI            YES                               TSO
         STC   R7,0(,R3)          SAVE TAB SETTING                  TSO
         LA    R3,1(,R3)          POINT TO NEXT TAB POSITION        TSO
         L     R5,8(,R5)          GET POINTER TO NEXT LIST ELEMENT  TSO
         C     R5,=X'FF000000'    END OF LIST?                      TSO
         BNE   STTABLOP           NO, CONTINUE WITH LIST            TSO
         STH   R2,TABCOUNT        SAVE THE TAB COUNT                TSO
         B     SETOK              ALL THROUGH                       TSO
         SPACE 1                                                    TSO
STTABHI  WRTERM 'Too many tab settings; rest ignored'               TSO
         BCTR  R2,0               ADJUST FOR OVER COUNTING          TSO
         STH   R2,TABCOUNT        USE THIS MANY TABS                TSO
         B     SETERR             RETURN ERROR                      TSO
STTABSEQ WRTERM 'Specified tab settings out of sequence'            TSO
         MVI   TABSWI,0           SET TABS OFF                      TSO
         B     SETERR             RETURN AN ERROR                   TSO
         SPACE 2                                                    TSO
********************************************************************TSO
*                                                                  *TSO
*        SET UP "SEND" COMMAND DELAY                               *TSO
*                                                                  *TSO
********************************************************************TSO
SETDELAY L     R6,=A(HELPFLG)     GET ADDRESS OF HELPFLAG           AJR
         CLI   0(R6),X'00'        CHECK IT                          AJR
         BE    SETDELY            NOT HELP REQUEST                  AJR
         LA    R1,MSG16LST      GET ADDRESS OF MESSAGE LIST         AJR
         L     R15,=A(MESG)     GET ADDRESS OF "MESG" SUBROUTINE    AJR
         BALR  R14,R15          GO DO IT!                           AJR
         B         SETOK                                            AJR
         SPACE 1                                                    AJR
SETDELY  PARSE SETDLAY,ATTN=SETOK,ERR=SETERR                        TSO
         CHECKPDL BAD=SETERR                                        TSO
         L     R6,SETDLAYN        GET ADDRESS OF STRING             TSO
         L     R15,=A(GETNUM)     CONVERT IT TO DECIMAL             TSO
         BALR  R14,R15            USE COMMON ROUTINE                TSO
         MH    R7,=H'100'         CONVERT TO HUNDREDTHS OF A SECOND TSO
         ST    R7,DELAY           SAVE DELAY VALUE                  TSO
         B     SETOK              ALL THROUGH                       TSO
         SPACE 1                                                    TSO
MSG16LST DC    A(MSG16L)        ADDRESS OF MESSAGE LENGTH           AJR
         DC    A(MSG16)         ADDRESS OF MESSAGE                  AJR
         SPACE 2                                                    TSO
********************************************************************TSO
*                                                                  *TSO
*        SET UP BLOCK HEADER USED BY SERIES-1/IBM7171 SCREENS      *TSO
*                                                                  *TSO
********************************************************************TSO
SETHEAD  L     R6,=A(HELPFLG)     GET ADDRESS OF HELPFLAG           AJR
         CLI   0(R6),X'00'        CHECK IT                          AJR
         BNE   ONOFFHLP           GO HANDLE HELP REQUEST            AJR
         PARSE SETONOFF,ATTN=SETOK,ERR=SETERR                       TSO
         CHECKPDL BAD=SETERR                                        TSO
         L     R6,SETONOF         GET STRING ADDRESS                TSO
         CLC   =C'ON',0(R6)       SET BLOCK HEADER ON?              TSO
         BNE   SETHDOFF           NO                                TSO
         OI    SRFLAGS,SRBLOCK    TURN BLOCK HEADER ON              TSO
         B     SETOK              ALL THROUGH                       TSO
         SPACE 1                                                    TSO
SETHDOFF NI    SRFLAGS,255-SRBLOCK  TURN BLOCK HEADER OFF           TSO
         B     SETOK              ALL THROUGH                       TSO
         SPACE 1                                                    TSO
SETERR   LA        R15,4               SET A NON-ZERO RETCODE       AJR
         B         SETRET
         SPACE 1                                                    TSO
SETOK    SR        R15,R15             RETCODE OF 0
*
SETRET   LR    R4,R15             PRESERVE RETURN CODE              TSO
         IKJRLSA PDLADDR          RELEASE THE PDL                   TSO
         LR    R15,R4             RESTORE RETURN CODE               TSO
         XC    PDLADDR,PDLADDR    CLEAR THE PDL ADDRESS             TSO
         RET   ,                                                    TSO
         EXIT                                                       TSO
         EJECT                                                      TSO
* R6 points to input.  Read and convert to binary.  Return value
* in R7.  Indicate error by returning -1.  Also uses R4 and R3.
         SPACE 1
GETNUM   DS    0H                                                   AJR
         USING GETNUM,R15         ESTABLISH BASE ADDRESSABILITY     AJR
         SR        R7,R7                                            AJR
         BCTR      R7,0                Set to -1, error condition
         STM   R3,R4,GETNUMSV          SAVE WORKING REGS            TSO
         XC        PKVAR,PKVAR         Clear it out
         SR        R4,R4               Length of input
         LR        R3,R6               Don't lose pointer to input
GETN0    CLI       0(R3),C' '          Any more input
         BE        GETN1               No, pick it data
         CLI   0(R3),0            ANY MORE INPUT?                   TSO
         BE    GETN1              NO                                TSO
         CLI   0(R3),C';'         ANY MORE INPUT?                   TSO
         BE    GETN1              NO                                TSO
         CLI   0(R3),C','         ANY MORE INPUT?                   TSO
         BE    GETN1              NO                                TSO
         CLI   0(R3),C')'         ANY MORE INPUT?                   TSO
         BE    GETN1              NO                                TSO
         CLI   0(R3),C':'         ANY MORE INPUT?                   TSO
         BE    GETN1              NO                                TSO
         CLI       0(R3),X'F0'         Must be between 0-9
         BL        GETN5
         CLI       0(R3),X'F9'
         BH        GETN5
         LA        R3,1(R3)            Bump input pointer
         LA        R4,1(R4)            Bump counter
         C         R4,=F'8'            At our limit?
         BNE       GETN0               No go for more
GETN1    BCTR      R4,0                Decrement for next call
         EX        R4,PCK              Get the input
         CVB       R7,PKVAR            Convert to binary
GETN5    LM    R3,R4,GETNUMSV     RESTORE WORKING REGS              AJR
         BR    14                 RETURN                            AJR
         SPACE 3                                                    TSO
GETNUMSV DS    2F                                                   TSO
         SPACE 1                                                    TSO
PCK      PACK      PKVAR(8),0(0,R6)
         LTORG                                                      AJR
         DROP  R15                                                  AJR
* [20 end]
         EJECT                                                      AJR
*        MESG IS A MESSAGE SUBROUTINE TO HELP THE USER OF KERMIT    AJR
*        WHEN HE KEYS IN "SET XXXXX ?".                             AJR
*        R1 CONTAINS THE ADDRESS OF THE MESSAGE LIST.               AJR
MESG     DS 0H                                                      AJR
         SAVE  (14,12)            SAVE REGISTERS                    AJR
         LR    9,15                                                 AJR
         USING MESG,9             ESTABLISH BASE ADDRESSABILITY     AJR
         ST    R13,MESGSV+4                                         AJR
         LA    R13,MESGSV                                           AJR
         L     R6,0(R1)           GET ADDRESS OF MESSAGE LENGTH     AJR
         L     R0,0(R6)           GET LENGTH OF MESSAGE             AJR
         L     R1,4(R1)           GET ADDRESS OF MESSAGE            AJR
         DS 0H                                                      AJR
         L     R15,=A(PUTLINE)    GET ADDRESS OF PUTLINE ROUTINE    AJR
         BALR  14,15              GO SEND MESSAGE TO TERMINAL       AJR
         L     R13,MESGSV+4                                         AJR
         RETURN (14,12),RC=0      RETURN OK                         AJR
         SPACE 1                                                    AJR
MESGSV   DS    18F                                                  AJR
ENTRSV   DS    2F                                                   AJR
MSG1L    DC    A(L'MSG1)                                            AJR
MSG1     DC    C'ON or OFF'                                         AJR
MSG2L    DC    A(L'MSG2)                                            AJR
MSG2     DC    C'BINARY, TEXT, or V-BINARY'                         AJR
MSG3L    DC    A(L'MSG3)                                            AJR
MSG3     DC    C'1, 2, or 3'                                        AJR
MSG4L    DC    A(L'MSG4)                                            AJR
MSG4     DC    C'U, V, or F'                                        AJR
MSG5L    DC    A(L'MSG5)                                            AJR
MSG5     DC    C'ASCII char with decimal value 33-62 or 123-126'    AJR
MSG6L    DC    A(L'MSG6)                                            AJR
MSG6     DC    C'Value between 0 and 32760 (Default = 80)'          AJR
MSG7L    DC    A(L'MSG7)                                            AJR
MSG7     DC C'BLKSIZE must be an even multiple of LRECL for RECFM=F'
MSG8L    DC    A(L'MSG8)                                            AJR
MSG8     DC    C'BLKSIZE must be 4 greater than LRECL for RECFM=V'  AJR
MSG9L    DC    A(L'MSG9)                                            AJR
MSG9     DC    C'Value between 1 and 32760 (Default = 3600)'        AJR
MSG10L   DC    A(L'MSG10)                                           AJR
MSG10    DC    C'Value between 1 and 32760 (Default = 5)'           AJR
MSG11L   DC    A(L'MSG11)                                           AJR
MSG11    DC    C'Value between 1 and 32760 (Default = 10)'          AJR
MSG12L   DC    A(L'MSG12)                                           AJR
MSG12    DC    C'Two digit decimal value less than 31 (Default=13)' AJR
MSG13L   DC    A(L'MSG13)                                           AJR
MSG13    DC    C'Value between 26 and 9024 (Default = 94)'          AJR
MSG14L   DC    A(L'MSG14)                                           AJR
MSG14    DC    C'Two numbers 0-255:  Translate table OFFSET and NEW VAL+
               UE'                                                  AJR
MSG15L   DC    A(L'MSG15)                                           AJR
MSG15    DC C'BLKSIZE must be greater than LRECL and less than tracksiz+
               e for RECFM=U'                                       AJR
MSG16L   DC    A(L'MSG16)                                           AJR
MSG16    DC    C'Value between 1 and 99999 (Default = 20 Seconds)'  AJR
MSG17L   DC    A(L'MSG17)                                           AJR
MSG17    DC    C'ON, OFF, or ON(tab-list)  (Default = ON)'          AJR
         LTORG                                                      AJR
         DROP  R9                                                   AJR
         EJECT                                                      AJR
*        VALIDITY CHECKING ROUTINE FOR SET COMMANDS THAT REQUIRE    TSO
*        A VALUE TO BE EITHER "ON" OR "OFF".                        TSO
         SPACE 1                                                    TSO
ONOFF    DS    0H                                                   TSO
         SAVE  (14,12)            SAVE REGISTERS                    TSO
         USING ONOFF,R15          ESTABLISH BASE ADDRESSABILITY     TSO
         L     R10,0(,R1)         GET PDE ADDRESS                   TSO
         LH    R3,4(,R10)         GET LENGTH OF STRING              TSO
         L     R4,0(,R10)         GET ADDRESS OF STRING             TSO
         CH    R3,=H'3'           IS STRING LENGTH = 3?             TSO
         BE    ONOCKOFF           YES, CHECK IF "OFF"               TSO
         CH    R3,=H'2'           IS STRING LENGTH = 2?             TSO
         BE    ONOCKON            YES, CHECK IF "ON"                AJR
         B     ONOFFER            NEITHER OF THESE; RETURN ERROR    TSO
         SPACE 1                                                    TSO
ONOCKOFF CLC   =C'OFF',0(R4)      WAS "OFF" SPECIFIED?              TSO
         BE    ONOFFOK            YES, RETURN OK                    TSO
         B     ONOFFER            NO, RETURN ERROR                  TSO
         SPACE 1                                                    TSO
ONOCKON  CLC   =C'ON',0(R4)       WAS "ON" SPECIFIED?               TSO
         BE    ONOFFOK            YES, RETURN OK                    TSO
         B     ONOFFER            NO, RETURN ERROR                  TSO
         SPACE 1                                                    TSO
ONOFFOK  RETURN (14,12),RC=0      RETURN OK                         TSO
         SPACE 1                                                    TSO
ONOFFER  RETURN (14,12),RC=4      RETURN ERROR                      TSO
         LTORG                                                      TSO
         DROP  R15                                                  TSO
         EJECT                                                      TSO
*        VALIDITY CHECKING ROUTINE FOR SET COMMANDS THAT REQUIRE    TSO
*        A VALUE TO BE EITHER "BINARY" OR "TEXT".                   TSO
         SPACE 1                                                    TSO
BINTXT   DS    0H                                                   TSO
         SAVE  (14,12)            SAVE REGISTERS                    TSO
         USING BINTXT,R15         ESTABLISH BASE ADDRESSABILITY     TSO
         L     R10,0(,R1)         GET PDE ADDRESS                   TSO
         L     R4,0(,R10)         GET ADDRESS OF STRING             AJR
         CLC   =C'B',0(R4)        WAS "BINARY" SPECIFIED?           AJR
         BE    BINTXOK            YES, RETURN OK                    AJR
         CLC   =C'T',0(R4)        WAS "TEXT" SPECIFIED?             AJR
         BE    BINTXOK            YES, RETURN OK                    AJR
         CLC   =C'V',0(R4)        WAS "V-BINARY" SPECIFIED?         AJR
         BE    BINTXOK            YES, RETURN OK                    AJR
         RETURN (14,12),RC=4      RETURN ERROR                      AJR
         SPACE 1                                                    AJR
BINTXOK  RETURN (14,12),RC=0      RETURN OK                         AJR
         SPACE 1                                                    AJR
         LTORG                                                      AJR
         DROP  R15                                                  AJR
         EJECT                                                      AJR
*        BLKCHK; VALIDITY CHECKING FOR "SET BLOCK"                  TSO
*                                                                   TSO
*        VALID RANGE 1 - 3                                          TSO
         SPACE 1                                                    TSO
BLKCHK   DS    0H                                                   TSO
         SAVE  (14,12)            SAVE REGISTERS                    TSO
         USING BLKCHK,R15         ESTABLISH BASE ADDRESSABILITY     TSO
         SR    R0,R0              CHECK FOR LOW                     TSO
         LA    R2,1               MINIMUM VALUE                     TSO
         BAL   R6,CHEKIT          GO CHECK FOR MINIMUM              TSO
         LA    R0,4               CHECK FOR HIGH                    TSO
         LA    R2,3               MAXIMUM VALUE                     TSO
         BAL   R6,CHEKIT          GO CHECK FOR MAXIMUM              TSO
         RETURN (14,12),RC=0                                        TSO
         LTORG                                                      TSO
         DROP  R15                                                  TSO
         EJECT                                                      TSO
*        RECFM; VALIDITY CHECK FOR "SET RECFM"                      TSO
*        VALUE MUST BE EITHER "V" , "U", OR "F"                     AJR
         SPACE 1                                                    TSO
RECFM    DS    0H                                                   TSO
         SAVE  (14,12)            SAVE REGISTERS                    TSO
         USING RECFM,R15          ESTABLISH BASE ADDRESSABILITY     TSO
         L     R10,0(,R1)         GET PDE ADDRESS                   TSO
         L     R4,0(,R10)         GET ADDRESS OF STRING             TSO
         CLI   0(R4),C'V'         WAS "V" SPECIFIED?                TSO
         BE    RECOK              YES, RETURN OK                    TSO
         CLI   0(R4),C'U'         WAS "U" SPECIFIED?                AJR
         BE    RECOK              YES, RETURN OK                    AJR
         CLI   0(R4),C'F'         WAS "F" SPECIFIED?                AJR
         BE    RECOK              YES, RETURN OK                    AJR
         RETURN (14,12),RC=4      RETURN ERROR                      AJR
         SPACE 1                                                    AJR
RECOK    RETURN (14,12),RC=0      RETURN OK                         AJR
         SPACE 1                                                    AJR
         LTORG                                                      TSO
         DROP  R15                                                  TSO
         EJECT                                                      TSO
*        LRECL; VALIDITY CHECKING FOR "SET LRECL" & "SET BLKSIZE"   TSO
*                                                                   TSO
*        VALID RANGE 1 - 32760                                      AJR
         SPACE 1                                                    TSO
LRECLN   DS    0H                                                   TSO
         SAVE  (14,12)            SAVE REGISTERS                    TSO
         USING LRECLN,R15         ESTABLISH BASE ADDRESSABILITY     TSO
         SR    R0,R0              CHECK FOR LOW                     TSO
         LA    R2,1               MINIMUM VALUE                     TSO
         BAL   R6,CHEKIT          GO CHECK FOR MINIMUM              TSO
         LA    R0,4               CHECK FOR HIGH                    TSO
         L     R2,=F'32760'       MAXIMUM VALUE                     AJR
         BAL   R6,CHEKIT          GO CHECK FOR MAXIMUM              TSO
         RETURN (14,12),RC=0                                        TSO
         LTORG                                                      TSO
         DROP  R15                                                  TSO
         EJECT                                                      TSO
*        DELAY; VALIDITY CHECKING FOR "SET DELAY"                   TSO
*                                                                   TSO
*        VALID RANGE 1 - 99999                                      TSO
         SPACE 1                                                    TSO
DELAYN   DS    0H                                                   TSO
         SAVE  (14,12)            SAVE REGISTERS                    TSO
         USING DELAYN,R15         ESTABLISH BASE ADDRESSABILITY     TSO
         SR    R0,R0              CHECK FOR LOW                     TSO
         LA    R2,1               MINIMUM VALUE                     TSO
         BAL   R6,CHEKIT          GO CHECK FOR MINIMUM              TSO
         LA    R0,4               CHECK FOR HIGH                    TSO
         L     R2,=F'99999'       MAXIMUM VALUE                     TSO
         BAL   R6,CHEKIT          GO CHECK FOR MAXIMUM              TSO
         RETURN (14,12),RC=0                                        TSO
         LTORG                                                      TSO
         DROP  R15                                                  TSO
         EJECT                                                      TSO
*        EOL; VALIDITY CHECKING FOR "SET END"                       TSO
*                                                                   TSO
*        VALID RANGE 1 - 31                                         TSO
         SPACE 1                                                    TSO
EOL      DS    0H                                                   TSO
         SAVE  (14,12)            SAVE REGISTERS                    TSO
         USING EOL,R15            ESTABLISH BASE ADDRESSABILITY     TSO
         SR    R0,R0              CHECK FOR LOW                     TSO
         SR    R2,R2              MINIMUM VALUE                     TSO
         BAL   R6,CHEKIT          GO CHECK FOR MINIMUM              TSO
         LA    R0,4               CHECK FOR HIGH                    TSO
         LA    R2,31              MAXIMUM VALUE                     TSO
         BAL   R6,CHEKIT          GO CHECK FOR MAXIMUM              TSO
         RETURN (14,12),RC=0                                        TSO
         LTORG                                                      TSO
         DROP  R15                                                  TSO
         EJECT                                                      TSO
*        PACKET; VALIDITY CHECKING FOR "SET PACKET"                 TSO
*                                                                   TSO
*        VALID RANGE 26 - 9024                                      AJR
         SPACE 1                                                    TSO
PACKET   DS    0H                                                   TSO
         SAVE  (14,12)            SAVE REGISTERS                    TSO
         USING PACKET,R15         ESTABLISH BASE ADDRESSABILITY     TSO
         SR    R0,R0              CHECK FOR LOW                     TSO
         LA    R2,26              MINIMUM VALUE                     AJR
         BAL   R6,CHEKIT          GO CHECK FOR MINIMUM              TSO
         LA    R0,4               CHECK FOR HIGH                    TSO
         L     R2,=F'9024'        MAXIMUM VALUE                     TSO
         BAL   R6,CHEKIT          GO CHECK FOR MAXIMUM              TSO
         RETURN (14,12),RC=0                                        TSO
         LTORG                                                      TSO
         DROP  R15                                                  TSO
         EJECT                                                      TSO
*        TRANTABL; VALIDITY CHECKING FOR "SET ETOA", "SET ATOE",    AJR
*                                  "SET ETOANCP" OR "SET ATOENCP"   AJR
*        VALID RANGE 0 - 255. THIS IS A LIST OF TWO NUMBERS         TSO
         SPACE 1                                                    TSO
TRANTABL DS    0H                                                   TSO
         SAVE  (14,12)            SAVE REGISTERS                    TSO
         USING TRANTABL,R15       ESTABLISH BASE ADDRESSABILITY     TSO
         SR    R0,R0              CHECK FOR LOW                     TSO
         SR    R2,R2              MINIMUM VALUE                     TSO
         BAL   R6,CHEKIT          GO CHECK FOR MINIMUM              TSO
         LA    R0,4               CHECK FOR HIGH                    TSO
         LA    R2,255             MAXIMUM VALUE                     TSO
         BAL   R6,CHEKIT          GO CHECK FOR MAXIMUM              TSO
         RETURN (14,12),RC=0                                        TSO
         LTORG                                                      TSO
         DROP  R15                                                  TSO
         EJECT                                                      TSO
*        THIS SUBROUTINE VALIDITY CHECKS THE NUMBER PASSED BY THE   TSO
*        CALLER WITH THE NUMBER IN THE PDE                          TSO
*                                                                   TSO
*        ON ENTRY:                                                  TSO
*          R0  HAS ENTRY CODE                                       TSO
*            0 - CHECK IF LOW                                       TSO
*            4 - CHECK IF HIGH                                      TSO
*            8 - CHECK IF EQUAL                                     TSO
*          R1 -> LIST PASSED BY IKJPARSE FOR VALIDCK                TSO
*          R2  HAS NUMBER FOR COMPARISON                            TSO
         SPACE 1                                                    TSO
CHEKIT   DS    0H                                                   TSO
         BALR  R9,0               EST. BASE                         TSO
         USING *,R9               AND ADDRESSABILITY                TSO
         LR    R5,R0              SAVE ENTRY CODE                   TSO
         L     R7,0(R1)           GET PDE ADDRESS                   TSO
         LH    R3,4(R7)           GET LENGTH OF STRING              TSO
         L     R7,0(R7)           GET STRING POINTER                TSO
         SR    R0,R0              CLEAR NUMBER ACCUMULATOR          TSO
         ST    R0,CHKDBLWD        CLEAR NUMERIC FIELD               TSO
CNVLOOP  CLI   0(R7),C'0'         IS CHARACTER NUMERIC?             TSO
         BL    CHEKERR            NO, RETURN                        TSO
         MVN   CHKDBLWD+3(1),0(R7) SAVE NUMERIC PORTION             TSO
         MH    R0,=H'10'          DO DECIMAL SHIFT                  TSO
         A     R0,CHKDBLWD        ADD IN NEW NUMBER                 TSO
         LA    R7,1(R7)           POINT TO NEXT CHARACTER           TSO
         BCT   R3,CNVLOOP         KEEP GOING                        TSO
         B     *+4(R5)            BRANCH ON ENTRY CODE              TSO
         B     CHEKLO             0  CHECK IF LOW                   TSO
         B     CHEKHI             4  CHECK IF HIGH                  TSO
         B     CHEKEQ             8  CHECK IF EQUAL                 TSO
CHEKLO   CR    R0,R2              COMPARE NUMBERS                   TSO
         BL    CHEKERR            ERROR IF LOW                      TSO
         BR    R6                 OTHERWISE RETURN                  TSO
         SPACE 1                                                    TSO
CHEKHI   CR    R0,R2              COMPARE NUMBERS                   TSO
         BH    CHEKERR            ERROR IF HIGH                     TSO
         BR    R6                 OTHERWISE RETURN                  TSO
         SPACE 1                                                    TSO
CHEKEQ   CR    R0,R2              COMPARE NUMBERS                   TSO
         BNE   CHEKERR            ERROR IF NOT EQUAL                TSO
         BR    R6                 OTHERWISE RETURN                  TSO
         SPACE 1                                                    TSO
CHEKERR  RETURN (14,12),RC=4      RETURN WITH ERROR                 TSO
         SPACE 1                                                    TSO
CHKDBLWD DC    D'0'               DOUBLE WORD WORK AREA             TSO
         LTORG                                                      TSO
         DROP  R9                 DROP BASE ADDRESSABILITY          TSO
         SPACE 1                                                    TSO
         PUSH  PRINT                                                TSO
         PRINT NOGEN                                                TSO
SETPARM  IKJPARM ,                                                  TSO
SETCMDS  IKJKEYWD ,                                                 TSO
         IKJNAME 'IBM7171'                                          TSO
         IKJNAME 'SERIES1'                                          TSO
         IKJNAME 'WARNING'                                          AJR
         IKJNAME 'FILE'                                             TSO
         IKJNAME 'DEBUG'                                            TSO
         IKJNAME 'BLOCK'                                            TSO
         IKJNAME 'RECFM'                                            TSO
         IKJNAME 'QUOTE'                                            TSO
         IKJNAME 'BLKSIZE'                                          TSO
         IKJNAME 'LRECL'                                            TSO
         IKJNAME 'END'                                              TSO
         IKJNAME 'PACKET'                                           TSO
         IKJNAME 'ETOA'                                             TSO
         IKJNAME 'ATOE'                                             TSO
         IKJNAME 'ETOANCP'                                          AJR
         IKJNAME 'ATOENCP'                                          AJR
         IKJNAME 'PRIMARY'                                          TSO
         IKJNAME 'SECONDARY'                                        TSO
         IKJNAME 'DIRECTORY'                                        TSO
         IKJNAME 'TABS'                                             TSO
         IKJNAME 'DELAY'                                            TSO
         IKJNAME 'HEADER'                                           TSO
         IKJENDP ,                                                  TSO
         SPACE 1                                                    TSO
SETONOFF IKJPARM ,                                                  TSO
SETONOF  IKJIDENT 'OPERAND',MAXLNTH=3,FIRST=ALPHA,OTHER=ALPHA,      TSO+
               PROMPT='ON or OFF',VALIDCK=ONOFF,                    AJR+
               HELP='either ON or OFF'                              TSO
         IKJENDP ,                                                  TSO
         SPACE 1                                                    TSO
SETSUBFL IKJPARM ,                                                  TSO
SETKYFIL IKJIDENT 'OPERAND',MAXLNTH=6,FIRST=ALPHA,OTHER=ALPHA,      TSO+
               PROMPT='BINARY, TEXT, or V-BINARY',VALIDCK=BINTXT,   AJR+
               HELP='either BINARY, TEXT, or V-BINARY'              AJR
         IKJENDP ,                                                  TSO
         SPACE 1                                                    TSO
SETSUBBL IKJPARM ,                                                  TSO
SETBLKCK IKJIDENT 'CHECKSUM LENGTH',MAXLNTH=1,FIRST=NUMERIC,        TSO+
               PROMPT='CHECKSUM LENGTH',VALIDCK=BLKCHK,             TSO+
               HELP='a 1, 2, or 3'                                  TSO
         IKJENDP ,                                                  TSO
         SPACE 1                                                    TSO
SETSUBRC IKJPARM ,                                                  TSO
SETRCFRM IKJIDENT 'RECORD FORMAT',MAXLNTH=1,FIRST=ALPHA,            TSO+
               PROMPT='RECORD FORMAT',VALIDCK=RECFM,                TSO+
               HELP='either U, V, or F'                             AJR
         IKJENDP ,                                                  TSO
         SPACE 1                                                    TSO
SETSUBQT IKJPARM ,                                                  TSO
SETQT    IKJIDENT 'QUOTE CHARACTER',MAXLNTH=1,FIRST=ANY,            TSO+
               PROMPT='QUOTE CHARACTER',                            AJR+
               HELP='an ASCII char with decimal value 33-62 or 123-126 +
               (Default = #)'                                       AJR
         IKJENDP ,                                                  TSO
         SPACE 1                                                    TSO
SETSUBLR IKJPARM ,                                                  TSO
SETLR    IKJIDENT 'LOGICAL RECORD LENGTH',MAXLNTH=5,FIRST=NUMERIC,  TSO+
               OTHER=NUMERIC,DEFAULT='80',VALIDCK=LRECLN,           TSO+
               HELP='a value between 1 and 32760 (Default = 80)'    AJR
         IKJENDP ,                                                  TSO
         SPACE 1                                                    TSO
SETBLK   IKJPARM ,                                                  TSO
SETBLSZ  IKJIDENT 'DATA SET BLKSIZE',MAXLNTH=5,FIRST=NUMERIC,       TSO+
               OTHER=NUMERIC,DEFAULT='3600',VALIDCK=LRECLN,         TSO+
               HELP='a value between 1 and 32760 (Default = 3600)'  AJR
         IKJENDP ,                                                  TSO
         SPACE 1                                                    TSO
SETPRI   IKJPARM ,                                                  TSO
SETPRIM  IKJIDENT 'PRIMARY ALLOCATION',MAXLNTH=5,FIRST=NUMERIC,     TSO+
               OTHER=NUMERIC,DEFAULT='5',VALIDCK=LRECLN,            TSO+
               HELP='a value between 1 and 32760 (Default = 5)'     AJR
         IKJENDP ,                                                  TSO
         SPACE 1                                                    TSO
SETSEC   IKJPARM ,                                                  TSO
SETSECN  IKJIDENT 'SECONDARY ALLOCATION',MAXLNTH=5,FIRST=NUMERIC,   TSO+
               OTHER=NUMERIC,DEFAULT='5',VALIDCK=LRECLN,            TSO+
               HELP='a value between 1 and 32760 (Default = 5)'     AJR
         IKJENDP ,                                                  TSO
         SPACE 1                                                    TSO
SETDIR   IKJPARM ,                                                  TSO
SETDIRC  IKJIDENT 'PDS DIRECTORY ALLOCATION',MAXLNTH=5,             TSO+
               FIRST=NUMERIC,OTHER=NUMERIC,DEFAULT='10',            TSO+
               VALIDCK=LRECLN,                                      TSO+
               HELP='a value between 1 and 32760 (Default = 10)'    AJR
         IKJENDP ,                                                  TSO
         SPACE 1                                                    TSO
SETSUBEN IKJPARM ,                                                  TSO
SETEOL   IKJIDENT 'END-OF-LINE CHARACTER',MAXLNTH=2,FIRST=NUMERIC,  TSO+
               OTHER=NUMERIC,VALIDCK=EOL,                           TSO+
               PROMPT='END-OF-LINE CHARACTER',                      TSO+
               HELP='a two digit decimal value less than 31 (Default = +
               13)'                                                 AJR
         IKJENDP ,                                                  TSO
         SPACE 1                                                    TSO
SETSUBPC IKJPARM ,                                                  TSO
SETPACK  IKJIDENT 'RECEIVE PACKET SIZE',MAXLNTH=4,FIRST=NUMERIC,    TSO+
               OTHER=NUMERIC,VALIDCK=PACKET,                        TSO+
               PROMPT='RECEIVE PACKET SIZE',                        TSO+
               HELP='a value between 26 and 9024 (Default = 94)'    AJR
         IKJENDP ,                                                  TSO
         SPACE 1                                                    TSO
SETSUBET IKJPARM ,                                                  TSO
SETTRAN1 IKJIDENT 'TRANSLATE TABLE OFFSET',MAXLNTH=3,               TSO+
               FIRST=NUMERIC,OTHER=NUMERIC,VALIDCK=TRANTABL,        TSO+
               PROMPT='table offset',                               TSO+
               HELP='a number between 0 and 255 (decimal)'          AJR
SETTRAN2 IKJIDENT 'TRANSLATE TABLE VALUE',MAXLNTH=3,                TSO+
               FIRST=NUMERIC,OTHER=NUMERIC,VALIDCK=TRANTABL,        TSO+
               PROMPT='translate table value',                      TSO+
               HELP='a number between 0 and 255 (decimal)'          AJR
         IKJENDP ,                                                  TSO
         SPACE 1                                                    TSO
SETTABLS IKJPARM ,                                                  TSO
SETTBTB  IKJKEYWD DEFAULT='TABS'                                    TSO
         IKJNAME 'TABS'                                             TSO
SETTBSWI IKJKEYWD DEFAULT='ON'                                      TSO
         IKJNAME 'ON',SUBFLD=SETTBLST                               TSO
         IKJNAME 'OFF'                                              TSO
         IKJNAME 'DEFAULT'                                          TSO
SETTBLST IKJSUBF ,                                                  TSO
SETTBSET IKJIDENT 'TAB SETTINGS',MAXLNTH=3,LIST,                    TSO+
               FIRST=NUMERIC,OTHER=NUMERIC                          AJR
         IKJENDP ,                                                  TSO
         SPACE 1                                                    TSO
SETDLAY  IKJPARM ,                                                  TSO
SETDLAYN IKJIDENT 'SEND COMMAND DELAY',MAXLNTH=5,FIRST=NUMERIC,     TSO+
               OTHER=NUMERIC,DEFAULT='20',VALIDCK=DELAYN,           TSO+
               HELP='a value between 1-99999 (Default = 20)'        TSO
         IKJENDP ,                                                  TSO
         DROP  R10                DROP PPL ADDRESSABILITY           TSO
         TITLE '(SETCHKLR) Verify BLKSIZE/LRECL'                    SEB
****************                                                    AJR
*      IF RECFM=F, BLKSIZE MUST BE EVEN MULTIPLE OF LRECL.          AJR
*      IF RECFM=V, BLKSIZE MUST BE 4 GREATER THAN LRECL.            AJR
*      IF RECFM=U, BLKSIZE MUST BE GREATER THAN LRECL AND LESS THAN AJR
*           DEVICE TRACKSIZE.                                       AJR
*                                                                   TSO
*        ON ENTRY:                                                  TSO
*          R1 -> RECFM VALUE                                        TSO
*          R2 CONTAINS LRECL VALUE                                  TSO
*          R3 CONTAINS BLKSIZE VALUE                                TSO
*                                                                   SEB
*        ON EXIT:                                                   SEB
*          R15 CONTAINS RETURN CODE:  0 - VALUES CHECK              SEB
*                                     4 - VALUES DON'T CHECK        SEB
****************                                                    AJR
         SPACE 3                                                    SEB
SETCHKLR ENTER ,                                                    SEB
         SR    R15,R15            ASSUME RC=0                       SEB
         CLC   0(1,R1),=C'F'      IS RECFM=F?                       SEB
         BE    SETCHKEV           YES, CHECK FOR EVEN MULTIPLE      TSO
         CLC   0(1,R1),=C'U'      IS RECFM=U?                       AJR
         BE    SETCHKGR           YES, CHECK IF GREATER             AJR
         LA    R2,4(,R2)          ADD 4 TO LRECL                    TSO
         CR    R2,R3              IS BLKSIZE 4 GT LRECL?            AJR
         BNH   SETCHKRT           YES EVERYTHING IS OK              SEB
         WRTERM 'BLKSIZE must be 4 greater than LRECL for RECFM=V'  AJR
         LA    R15,4              SET RETURN CODE                   SEB
         B     SETCHKRT           RETURN AN ERROR                   SEB
         SPACE 1                                                    TSO
SETCHKGR CR    R2,R3              IS BLKSIZE GT LRECL?              AJR
         BNH   SETCHKRT           YES EVERYTHING IS OK          SEB AJR
         WRTERM 'BLKSIZE must be greater than LRECL for RECFM=U'    AJR
         LA    R15,4              SET RETURN CODE                   SEB
         B     SETCHKRT           RETURN AN ERROR                   SEB
         SPACE 1                                                    AJR
SETCHKEV LR    R5,R2        LRECL(R5)=DIVISOR,BLKSIZE(R3)=DIVIDEND  AJR
         SR    R2,R2              CLEAR FOR DIVIDE                  TSO
         DR    R2,R5              SEE IF EVEN MULTIPLE              TSO
         LTR   R2,R2              IS THERE A REMAINDER?             TSO
         BZ    SETCHKRT           NO, EVEN MULTIPLE                 SEB
         WRTERM 'BLKSIZE must be an even multiple of LRECL for RECFM=F'
         LA    R15,4              SET RETURN CODE                   SEB
SETCHKRT RET   ,                  RETURN                            SEB
         EXIT                                                       SEB
         TITLE '(SERVER) Server processor'
SERVER   ENTER ,                                                    TSO
         OI        LFLAGS,SERVON       SERVER mode is on
         TM        FLAGS,DEBUG         In DEBUG mode?
         BO        SERV00              Yes, then don't ignore attn
         STAX      SRVATTN             Else ignore attention
SERV00   TM    S1FLAGS,ISS1       IS TERMINAL A SERIES1/IBM7171?    TSO
         BZ    SERV000            NO, PUT OUT NORMAL SERVER MSGS    TSO
         STFSMODE ON,INITIAL=YES,NOEDIT=YES  FULL-SCREEN MODE       TSO
         BLOCKLET =C'SERVER',6    PUT BLOCK HEADER ON SCREEN        TSO
         LA    R2,1(,R1)          SKIP A LINE ON THE SCREEN         TSO
         FULLSCR SM1,L'SM1,ROW=(R2),COLUMN=1                        TSO
         LA    R2,1(,R2)          DISPLAY ON NEXT SCREEN LINE       TSO
         FULLSCR SM2,L'SM2,ROW=(R2),COLUMN=1                        TSO
         LA    R2,1(,R2)          DISPLAY ON NEXT SCREEN LINE       TSO
         FULLSCR SM3,L'SM3,ROW=(R2),COLUMN=1                        TSO
         LA    R2,1(,R2)          DISPLAY ON NEXT SCREEN LINE       TSO
         FULLSCR SM4,L'SM4,ROW=(R2),COLUMN=1                        TSO
         LA    R2,1(,R2)          DISPLAY ON NEXT SCREEN LINE       TSO
         FULLSCR SM5,L'SM5,ROW=(R2),COLUMN=1                        TSO
         LA    R2,1(,R2)          DISPLAY ON NEXT SCREEN LINE       TSO
         FULLSCR SM6,L'SM6,ROW=(R2),COLUMN=1                        TSO
         PUTCRSR ROW=21,COLUMN=1                                    TSO
         STIMER WAIT,BINTVL==F'500'  WAIT TO PAINT SCREEN           TSO
         LA    R0,S1ORDSL         GET LENGTH TO WRITE               TSO
         L     R1,ASND7171        GET BUFFER TO WRITE               TSO
         TPUT  (1),(0),NOEDIT                                       TSO
         LTR   R15,R15            I/O SUCCESSFUL?                   SEB
         BZ    *+8                YES                               SEB
         NOP   *+4                NO; THIS NOP PROVIDES TEST POINT  SEB
         B     SERV0              START PROCESSING SERVER PACKETS   TSO
         SPACE 1                                                    TSO
SERV000  WRTERM SM1,L'SM1                                           TSO
         WRTERM SM2,L'SM2                                           TSO
         WRTERM SM3,L'SM3                                           TSO
         WRTERM SM4,L'SM4                                           TSO
         WRTERM SM5,L'SM5                                           TSO
         WRTERM SM6,L'SM6                                           TSO
         STIMER WAIT,BINTVL==F'50'  WAIT FOR DISPLAY OF MESSAGES    TSO
SERV0    MVI       CHKLEN,DCHKLEN      Set checksum length to one
         XC        NUMTRY,NUMTRY       Trial counter
         XC        SPKNUM,SPKNUM       Packet number we'll use
         L         15,=A(RPACK)
         BALR      R14,R15             Read in a packet
         SPACE 1                                                    TSO
*        PROCESS RECEIVE REQUEST                                    TSO
         SPACE 1                                                    TSO
         CLI       RTYPE,AS            Other side sending us a file?
         BNE       SERV1               Nope
SERV01   L         R15,=A(RECEIVE)     Get the file
         BALR      R14,R15
         CLI   STATE,C'A'         WAS THIS OPERATION ABORTED        TSO
         BNE   SERVRCOK           NO, DON'T DO CLOSE ETC.           TSO
         TM    SENDRCV+(DCBOFLGS-IHADCB),DCBOFOPN  IS DCB OPEN?     TSO
         BNO   SERVUNAL           NO                                TSO
         CLOSE (SENDRCV)          CLOSE DATA SET                    TSO
         FREEPOOL SENDRCV         FREE THE QSAM BUFFER POOL         TSO
SERVUNAL LA    R8,ALLOCCB         POINT TO ALLOCATION CONTROL BLOCK TSO
         USING ALCCB,R8           MAKE IT ADDRESSABLE               TSO
         UNALLOC DSNAME,ADDR=ALCDSN  UNALLOCATE THE DATA SET        TSO
         DROP  R8                 DROP ALCCB ADDRESSABILITY         TSO
SERVRCOK DS    0H                                                   TSO
         MVC       OLDERR(1),ERRNUM
         MVI       ERRNUM,X'FF'        Reset error number
         B         SERV0               Go around again
         SPACE 1                                                    TSO
*        PROCESS INIT PACKET                                        TSO
         SPACE 1                                                    TSO
SERV1    CLI       RTYPE,AI            Init packet
         BNE       SERV2               Nope
         L         R5,LRDAT            Number of pieces of data
         L         R15,=A(SPAR)
         BALR      R14,R15             Read data from other host
         L         R15,=A(PACKLEN)     Get max send packet size
         BALR      R14,R15
         L         R15,=A(RPAR)        Our paramters to send
         BALR      R14,R15
         ST        R15,LSDAT           Length of reply
         MVI       STYPE,AY            Send an ACK
         L         R15,=A(SPACK)
         BALR      R14,R15
         MVC       OLDERR(1),ERRNUM
         MVI       ERRNUM,X'FF'        Reset error number
         B         SERV0               Loop again no matter what
         SPACE 1                                                    TSO
*        PROCESS GENERIC COMMANDS                                   TSO
         SPACE 1                                                    TSO
SERV2    CLI       RTYPE,AG            Generic command
         BNE       SERV3
         L    R3,ARDAT            POINT TO FIRST DATA CHARACTER     TSO
         CLI       0(R3),AF            Finish command
         BE        SERV21              Yes go handle
         CLI       0(R3),AL            Logout command
         BNE       SERV24              No
SERV21   XC        LSDAT,LSDAT         No data
         MVI       STYPE,AY            Send an ACK
         L         R15,=A(SPACK)
         BALR      R14,R15
         CLI       0(R3),AL            Logout?
         BNE       SERV22              No, reset things
         SPACE 1                                                    TSO
*        OTHER KERMIT HAS REQUESTED LOGOFF                          TSO
         SPACE 1                                                    TSO
         L     R2,CPPLADDR        GET ADDRESS OF KERMIT CPPL        TSO
         MVC   ATCHCPPL(16),0(R2) INITIALIZE ATTACH CPPL            TSO
         LA    R2,ATCHCPPL        GET ADDRESS OF ATTACH CPPL        TSO
         USING CPPL,R2            MAKE ATTACH CPPL ADDRESSABLE      TSO
         LA    R0,LGOFFCMD        GET ADDRESS OF COMMAND BUFFER     TSO
         ST    R0,CPPLCBUF        PUT INTO THE CPPL                 TSO
         L     R3,CPPLECT         GET THE ECT ADDRESS               TSO
         USING ECT,R3             MAKE IT ADDRESSABLE               TSO
         MVC   ECTSCMD,=CL8'LOGOFF'  SET UP ECT SUBCOMMAND FIELD    TSO
         LA    R1,ATCHCPPL        GET ADDRESS OF ATTACH CPPL        TSO
         MVI   ATCHECB,0          CLEAR THE ECB                     TSO
         ATTACH ECB=ATCHECB,EP=LOGOFF,SHSPV=78,SZERO=NO             TSO
         ST    R1,ATCHTCB         SAVE TASK'S TCB ADDRESS           TSO
         WAIT  ECB=ATCHECB        WAIT FOR TASK TO TERMINATE        TSO
         DETACH ATCHTCB           DETACH THE TASK                   TSO
         DROP  R2                 DROP CPPL ADDRESSABILITY          TSO
         DROP  R3                 DROP ECT ADDRESSABILITY           TSO
         MVI   EXTFLG,X'FF'       SET EXIT FLAG                     AJR
SERV22   MVC       OLDERR(1),ERRNUM
         MVI       ERRNUM,X'FF'        Reset error number
         NI        LFLAGS,X'FF'-SERVON    SERVER mode is off
         STAX      ,                   Reset attn address
         B         SERVRET
SERV24   MVI       ERRNUM,X'12'        Error message number
         L         R15,=A(ERRPACK)     Send an error packet
         BALR      R14,R15
         B         SERV0               And wait for more
         SPACE 1                                                    TSO
*        PROCESS GET REQUEST                                        TSO
         SPACE 1                                                    TSO
SERV3    CLI       RTYPE,AR            Other side did GET command
         BNE       SERV4
         L         R5,LRDAT            File name size
         LTR       R5,R5
         BZ        SERV35              Fail on zero length
         L     R2,=A(NULDMP)      GET ADDRESS OF NULL DUMP ROUTINE  TSO
         ST    R2,MORDEC                                            TSO
         XC    OUTBFPT,OUTBFPT    CLEAR OUTPUT BUFFER OFFSET        TSO
         MVC   TEMP,MAXOUT        SAVE MAX                          TSO
         MVC   MAXOUT,=A(MAXTXT)  USE A BIG NUMBER INSTEAD          TSO
         L     R15,=A(DECODE)     DECODE THE INPUT                  TSO
         BALR  R14,R15                                              TSO
         MVC   MAXOUT,TEMP        RESET MAX                         TSO
         L     R5,OUTBFPT         GET LENGTH OF DECODED DATA        TSO
         ST    R5,LRDAT           KEEP LENGTH HERE                  TSO
         MVC   NAME,=44X'20'      BLANK OUT FILE NAME               TSO
         STH   R5,NAMELN          HERE TOO                          TSO
         L     R9,ARBUF           GET BUFFER ADDRESS                TSO
         LA    R9,4(,R9)          ADJUST FOR VARIABLE RECORD RDW    TSO
         BCTR  R5,0               ADJUST FOR EX                     TSO
         EX    R5,SERVMV1         MOVE IN FILE NAME                 TSO
*SERVMV1 MVC   NAME(*-*),0(R9)                                      TSO
         TR    NAME,ATOE          TRANSLATE TO EBCDIC               TSO
         OC    NAME,BLANKS        UPCASE THE NAME                   TSO
         L     R9,ARBUF           ADDRESS OF PLACE TO BLD CMD BUF   TSO
         XC    0(4,R9),0(R9)      CLEAR FOR LENGTH & OFFSET         TSO
         MVC   4(L'NAME,R9),NAME  PUT FILE NAME INTO COMMAND BUF    TSO
         LA    R5,1+4(,R5)        ADJUST LENGTH FOR LENGTH FIELD    TSO
         STH   R5,0(,R9)          PUT INTO COMMAND BUFFER           TSO
         LA    R10,PPLAREA        POINT TO PARSE PARAMETER LIST     TSO
         USING PPL,R10            MAKE IT ADDRESSABLE               TSO
         ST    R9,PPLCBUF         COMMAND BUFFER ADDRESS IN PPL     TSO
         PARSE SRVPARM,ATTN=SRVERR,ERR=SRVERR                       TSO
         CHECKPDL BAD=SRVERR                                        TSO
         USING IKJPARMD,R9        MAKE PDL ADDRESSABLE              TSO
         SPACE 1                                                    TSO
         MVC   FILNAM,BLANKS      CLEAR FILE NAME                   TSO
         TM    SRVDSN+6,X'80'     IS DSNAME PRESENT?                TSO
         BNO   SRVERR             NO, RETURN ERROR                  TSO
         LH    R2,SRVDSN+4        GET LENGTH OF DSNAME              TSO
         STH   R2,FILNAMLN        SAVE LENGTH OF FILE NAME          TSO
         STH   R2,NAMELN          AND HERE ALSO                     TSO
         L     R3,SRVDSN          GET ADDRESS OF FILE NAME          TSO
         BCTR  R2,0               ADJUST FOR EX                     TSO
         EX    R2,SRVMVDS         SET UP FILE NAME                  TSO
*SRVMVDS MVC   FILNAM(*-*),0(R3)                                    TSO
         MVC   NAME,FILNAM        SAVE UNPREFIXED FILE NAME         TSO
         SPACE 1                                                    TSO
         XC    MBRNAMLN,MBRNAMLN  CLEAR MEMBER NAME LENGTH          TSO
         TM    SRVDSN+14,X'80'    IS MEMBER NAME PRESENT?           TSO
         BZ    SRVPREFX           NO, GO PREFIX FILE NAME           TSO
         LH    R2,SRVDSN+12       GET LENGTH OF MEMBER NAME         TSO
         STH   R2,MBRNAMLN        SAVE LENGTH                       TSO
         L     R3,SRVDSN+8        GET ADDRESS OF MEMBER NAME        TSO
         BCTR  R2,0               ADJUST FOR EX                     TSO
         EX    R2,SRVMVMB         SET UP MEMBER NAME                TSO
*SRVMVMB MVC   MBRNAM(*-*),0(R3)                                    TSO
         SPACE 1                                                    TSO
SRVPREFX TM    SRVDSN+6,X'40'     IS DSNAME QUOTED?                 TSO
         BZ    SRVPRFX            NO, GO PREFIX THE SUPPLIED FILE   TSO
         LOCATE DATASET           SEE IF DATA SET EXISTS            TSO
         LTR   R15,R15            WAS DATA SET FOUND?               TSO
         BNZ   SVNOTFND           NO, GO SAY DATA SET NOT FOUND     TSO
         B     SVOK               YES, GO ALLOCATE THE DATA SET     TSO
         SPACE 1                                                    TSO
SRVPRFX  IKJRLSA PDLADDR          RELEASE THE PDL                   TSO
         XC    PDLADDR,PDLADDR    CLEAR PDL ADDRESS                 TSO
         LA    R1,FILNAMLN        GET FILE NAME LENGTH              TSO
         L     R15,=A(PREFIXDS)   GET ADDRESS OF PREFIXING ROUTINE  TSO
         BALR  R14,R15            GO PREFIX FILE NAME               TSO
         B     *+4(R15)           BRANCH ON RETURN CODE             TSO
         B     SVOK               0  - OLD DATA SET                 TSO
         B     SVNOTFND           4  - NEW DATA SET                 TSO
         B     SVERR              8  - UNABLE TO PREFIX             TSO
         SPACE 1                                                    TSO
SVERR    MVI   ERRNUM,27          SAY "ERROR PREFIXING FILE"        TSO
         B     SERV8                                                TSO
         SPACE 1                                                    TSO
SVOK     DS    0H                                                   TSO
         LA    R8,ALLOCCB         POINT TO ALLOCATION CONTROL BLOCK TSO
         USING ALCCB,R8           MAKE IT ADDRESSABLE               TSO
         LA    R0,ALCTOLD         INDICATE "OLD" ALLOCATION         TSO
         ST    R0,ALCTYPE         PUT INTO ALCCB                    TSO
SVALCDS  LA    R0,FILNAMLN        GET ADDRESS OF FILE NAME & LENGTH TSO
         ST    R0,ALCDSN          PUT INTO ALCCB                    TSO
         XC    ALCMEMBR,ALCMEMBR  ASSUME NO MEMBER NAME             TSO
         SR    R0,R0              CLEAR FOR ICM                     TSO
         ICM   R0,3,MBRNAMLN      GET LENGTH OF MEMBER NAME         TSO
         BZ    SRVALC             NO, MEMBER NAME; DO ALLOCATE      TSO
         LA    R0,MBRNAMLN        GET ADDRESS OF MEMBER NAME        TSO
         ST    R0,ALCMEMBR        PUT INTO ALCCB                    TSO
SRVALC   LR    R1,R8              PASS ADDRESS OF ALCCB             TSO
         L     R15,=A(ALLOCDSN)   GET ALLOCATE ROUTINE ADDRESS      TSO
         BALR  R14,R15            GO ALLOCATE THE DATA SET          TSO
         B     *+4(R15)           BRANCH ON RETURN CODE             TSO
         B     SVOPEN             0  -  ALLOCATION SUCCESSFUL       TSO
         B     SVNOTFND           4  -  DATA SET NOT FOUND          TSO
         B     SVALCERR           8  -  ALLOCATION ERROR            TSO
         B     SVINCOMP           12 -  INCOMPATIBLE DATA SET TYPES TSO
         B     SVUNSUPT           16 -  UNSUPPORTED DATA SET TYPE   TSO
         SPACE 1                                                    TSO
SRVERR   MVI   ERRNUM,11          SAY "INVALID FILE NAME"           TSO
         B     SERV8                                                TSO
         SPACE 1                                                    TSO
SVNOTFND MVI   ERRNUM,21          SAY "FILE NOT FOUND"              TSO
         B     SERV8                                                TSO
         SPACE 1                                                    TSO
SVALCERR MVI   ERRNUM,28          SAY "ERR ALLOCATING FILE"         TSO
         B     SERV8                                                TSO
         SPACE 1                                                    TSO
SVINCOMP MVI   ERRNUM,14          SAY "INCOMPAT FILE TYPE"          TSO
         B     SERV8                                                TSO
         SPACE 1                                                    TSO
SVUNSUPT MVI   ERRNUM,30          SAY "UNSUPPORTD FILE TYPE"        TSO
         B     SERV8                                                TSO
         SPACE 1                                                    TSO
SVOPEN   MVC   SENDRCV+40(8),BLANKS  CLEAR DCB DDNAME               TSO
         LR    R2,R0              SAVE LENGTH OF DDNAME             TSO
         BCTR  R2,0               ADJUST FOR EX                     TSO
         EX    R2,SVMVDDN         PUT DDNAME INTO DCB               TSO
*SVMVDDN MVC   SENDRCV+40(*-*),0(R1)                                TSO
         L     R0,=A(INBUFEOD)    GET EODAD ROUTINE ADDRESS         TSO
         STCM  R0,7,SENDRCV+(DCBEODA-IHADCB)  PUT INTO DCB          TSO
         L     R0,=A(INBUF0)      GET ADDRESS OF SYNAD ROUTINE      TSO
         STCM  R0,7,SENDRCV+(DCBSYNA-IHADCB)  PUT INTO DCB          TSO
         OPEN  (SENDRCV,INPUT)    OPEN THE DATA SET FOR INPUT       TSO
         TM    SENDRCV+(DCBOFLGS-IHADCB),DCBOFOPN  OPEN SUCCESSFUL  TSO
         BO    SVSEND             YES, CONTINUE SEND OPERATION      TSO
         CLI   ERRNUM,X'FF'       ERROR DURING OPEN?                TSO
         BNE   SVERDALC           YES                               TSO
         MVI   ERRNUM,29          SAY "ERROR OPENING FILE"          TSO
SVERDALC UNALLOC DSNAME,ADDR=ALCDSN  UNALLOCATE THE DATA SET        TSO
         B     SERV8                                                TSO
         SPACE 1                                                    TSO
SERVMV1  MVC   NAME(*-*),0(R9)                                      TSO
SVMVDDN  MVC   SENDRCV+40(*-*),0(R1)                                TSO
SRVMVDS  MVC   FILNAM(*-*),0(R3)                                    TSO
SRVMVMB  MVC   MBRNAM(*-*),0(R3)                                    TSO
         SPACE 1                                                    TSO
SVSEND   DS    0H                                                   TSO
         OI        FLAGS,FLG1          Sending first file
         XC        NFSENT,NFSENT       No files sent yet
         L         R15,=A(SEND)
         BALR      R14,R15
         CLOSE (SENDRCV)          CLOSE DATA SET                    TSO
         FREEPOOL SENDRCV         FREE THE QSAM BUFFER POOL         TSO
         UNALLOC DSNAME,ADDR=ALCDSN  UNALLOCATE THE DATA SET        TSO
         MVC       OLDERR(1),ERRNUM
         MVI       ERRNUM,X'FF'        Reset error number
         B     SERV0              GO AROUND AGAIN                   TSO
SERV35   MVI       ERRNUM,X'0B'        Error message number
         L         R15,=A(ERRPACK)     Send an error packet
         BALR      R14,R15
         B         SERV0               And wait for more
         SPACE 1                                                    TSO
*        PROCESS ERROR PACKET                                       TSO
         SPACE 1                                                    TSO
SERV4    CLI       RTYPE,AE            Error packet
         BNE       SERV5
         B         SERV0               Ignore it
         SPACE 1                                                    TSO
SERV5    CLI       RTYPE,AN            Packet garbled?
         BNE       SERV6
         MVI       STYPE,AN            Send a NAK
         XC        LSDAT,LSDAT         No data
         L         R15,=A(SPACK)
         BALR      R14,R15
         B         SERV0               And try again
         SPACE 1                                                    TSO
SERV6    CLI       RTYPE,X'00'         Series/1 error?
         BNE       SERV7
         MVI       ERRNUM,S1ERRNUM     Try to send error packet
         L         R15,=A(ERRPACK)     Send an error packet
         BALR      R14,R15
         B         SERV0
         SPACE 1                                                    TSO
SERV7    MVI       ERRNUM,X'13'        Error message number
         SPACE 1                                                    TSO
SERV8    DS    0H                                                   TSO
         L         R15,=A(ERRPACK)     Send an error packet
         BALR      R14,R15
         B         SERV0
*
SRVATTN  BR        R14                 Ignore attention
*
SERVRET  TM    S1FLAGS,ISS1       IS IT SERIES1/IBM 7171?           SEB
         BNO   SRVN7171           NO                                SEB
         STFSMODE OFF             MAKE SURE FULL SCREEN MODE IS OFF SEB
SRVN7171 RET   ,                                                    SEB
         SPACE 1                                                    TSO
SM1 DC C'KERMIT-TSO server starting...'                             AJR
SM2 DC C'Return to your local machine by typing its escape sequence'
SM3 DC C'and issue further commands there.'                         AJR
SM4 DC C'The GET and SEND commands are used to transfer files.'     AJR
SM5 DC C'To terminate SERVER mode and return to Kermit-TSO enter the FI+
               NISH command.'                                       AJR
SM6 DC C'To terminate Kermit-TSO and logoff TSO enter the BYE command.'
         SPACE 1                                                    TSO
         PRINT NOGEN                                                TSO
SRVPARM  IKJPARM ,                                                  TSO
SRVDSN   IKJPOSIT DSNAME                                            TSO
         IKJENDP ,                                                  TSO
         PRINT GEN                                                  TSO
         EXIT                                                       TSO
         DROP  R8                 DROP ALLOCATE CB ADDRESSABILITY   TSO
         DROP  R9                 DROP PDL ADDRESSABILITY           TSO
         DROP  R10                DROP PPL ADDRESSABILITY           TSO
         TITLE '(SHOW) SHOW command processor'
*        THIS ROUTINE PROCESSES THE "SHOW" COMMAND.  IT DISPLAYS    TSO
*        THE VALUES SET BY THE "SET" COMMAND OR SET BY DEFAULT.     TSO
*                                                                   TSO
*        THE FOLLOWING COMMANDS ARE PROCESSED:                      TSO
*                                                                   TSO
*        "SHOW IBM7171"                                             TSO
*        "SHOW SERIES1"                                             TSO
*        "SHOW WARNING"                                             AJR
*        "SHOW FILE"                                                TSO
*        "SHOW DEBUG"                                               TSO
*        "SHOW BLOCK"                                               TSO
*        "SHOW RECFM"                                               TSO
*        "SHOW QUOTE"                                               TSO
*        "SHOW BLKSIZE"                                             TSO
*        "SHOW LRECL"                                               TSO
*        "SHOW END"                                                 TSO
*        "SHOW PACKET"                                              TSO
*        "SHOW ALL"                                                 TSO
*        "SHOW PRIMARY"                                             TSO
*        "SHOW SECONDARY"                                           TSO
*        "SHOW DIRECTORY"                                           TSO
*        "SHOW TABS"                                                TSO
*        "SHOW DELAY"                                               TSO
*        "SHOW HEADER"                                              TSO
         SPACE 3                                                    TSO
SHOW     ENTER ,
         SETSEMI                  GO INSERT SEMICOLON               TSO
         LA    R10,PPLAREA        GET ADDRESS OF PPL                TSO
         USING PPL,R10            MAKE IT ADDRESSABLE               TSO
         ST    R1,PPLCBUF         PUT ADDR OF COMMAND BUFFER IN PPL TSO
         PARSE SHOWPARM,ATTN=SHOWOK,ERR=SHOWERR                     TSO
         CHECKPDL GOOD=SHOKEYWD                                     TSO
         WRTERM 'PARSE found invalid parameters on the SHOW command'
         B     SHOWERR                                              TSO
         SPACE 1                                                    TSO
         USING IKJPARMD,R9        MAKE PDL ADDRESSABLE              TSO
         SPACE 1                                                    TSO
SHOKEYWD NI        LFLAGS,X'FF'-ALLFL  Turn off just in case
         LH    R8,SHOCMDS         GET VALUE OF KEYWORD              TSO
         IKJRLSA PDLADDR          RELEASE THE PDL                   TSO
         XC    PDLADDR,PDLADDR    CLEAR PDL ADDRESS                 TSO
         CLRSCR ,                 CLEAR SCREEN BEFORE DISPLAY       TSO
         MH    R8,=H'4'           SET UP BRANCH LIST                TSO
         B     *+4(R8)            BRANCH ON KEYWORD LIST            TSO
         B     SHOWERR             0 - NO KEYWORD                   TSO
         B     SHOSERIE            4 - IBM7171; USE SERIES/1 CODE   TSO
         B     SHOSERIE            8 - SERIES1                      TSO
         B     SHOWARN            12 - WARNING                      TSO
         B     SHOFILE            16 - FILE                         TSO
         B     SHODEBUG           20 - DEBUG                        TSO
         B     SHOBLOCK           24 - BLOCK                        TSO
         B     SHORECFM           28 - RECFM                        TSO
         B     SHOQUOTE           32 - QUOTE                        TSO
         B     SHOBLKSZ           36 - BLKSIZE                      TSO
         B     SHOLRECL           40 - LRECL                        TSO
         B     SHOEND             44 - END                          TSO
         B     SHOPACET           48 - PACKET                       TSO
         B     SHOWALL            52 - ALL                          TSO
         B     SHOWPRIM           56 - PRIMARY                      TSO
         B     SHOWSECN           60 - SECONDARY                    TSO
         B     SHOWDIR            64 - DIRECTORY                    TSO
         B     SHOWTABS           68 - TABS                         TSO
         B     SHOWDLAY           72 - DELAY                        TSO
         B     SHOWHEAD           76 - HEADER                       TSO
         SPACE 1                                                    TSO
SHOWALL  OI        LFLAGS,ALLFL        SHOW ALL requested
         B     SHOFILE            START SHOWING ALL PARAMETERS      TSO
         SPACE 3                                                    TSO
SHOFILE  LA        R3,FILMSG1          Assume text mode
         LA        R4,L'FILMSG1        Get msg length
         TM        FLAGS,BINF          Is text mode on?
         BNO       SHO01               Yes.
         LA        R3,FILMSG2          Mode is binary
         LA        R4,L'FILMSG2
         CLI       TYPFIL,C'V'         Is V-Binary on?              AJR
         BNE       SHO01               No.                          AJR
         LA        R3,FILMSG3          Mode is V-binary             AJR
         LA        R4,L'FILMSG3                                     AJR
SHO01    WRTERM    (R3),(R4)           Print mode
         TM        LFLAGS,ALLFL        Do they want it all
         BO    SHORECFM           YES, CONTINUE                     AJR
         B         SHOWOK              [1 end]
         SPACE 3                                                    TSO
SHODEBUG LA        R3,DEBMSG2          Assume debug mode is on
         LA        R4,L'DEBMSG2        Get length
         TM        FLAGS,DEBUG         Is debug mode on?
         BO        SHO11               Yes.
         LA        R3,DEBMSG1
         LA        R4,L'DEBMSG1
SHO11    WRTERM    (R3),(R4)
         TM        LFLAGS,ALLFL        More to show
         BO    SHOBLOCK           YES, CONTINUE                     TSO
         B         SHOWOK              Else end [10 end]
         SPACE 3                                                    TSO
SHOBLOCK MVC       TMP(1),CHKLEN       Munge it here
         OI        TMP,X'F0'           Make it printable
         LINEDIT   TEXT='BLOCK check is .',SUB=(CHARA,TMP,1)        SEB
         TM        LFLAGS,ALLFL        More to show
         BO    SHOQUOTE           YES, CONTINUE                     AJR
         B         SHOWOK
         SPACE 3                                                    TSO
SHOSERIE LA        R3,SERMSG1          Assume S/1 mode is off
         LA        R4,L'SERMSG1
         TM        S1FLAGS,ISS1        S/1 mode on?
         BNO       SHO31               No
         LA        R3,SERMSG2
         LA        R4,L'SERMSG2
SHO31    WRTERM    (R3),(R4)
         TM        LFLAGS,ALLFL
         BO    SHOWHEAD                                             AJR
         B         SHOWOK              [12 end]
         SPACE 3                                                    TSO
SHOWARN  LA        R3,WARMSG1          Assume warning is off
         LA        R4,L'WARMSG1        Get length
         TM        LFLAGS,WARFL        Is warning off?
         BNO       SHO41               Yes.
         LA        R3,WARMSG2
         LA        R4,L'WARMSG2
SHO41    WRTERM    (R3),(R4)
         TM        LFLAGS,ALLFL        More to show
         BO    SHODEBUG           YES,CONTINUE                      AJR
         B         SHOWOK              Else end  [18 end]
         SPACE 3                                                    TSO
SHORECFM LINEDIT   TEXT='RECFM   is   .',SUB=(CHARA,RFM,1)      AJR SEB
         TM        LFLAGS,ALLFL
         BO    SHOLRECL                                             TSO
         B         SHOWOK
         SPACE 3                                                    TSO
SHOQUOTE TR        RQUOTE(1),ATOE   GET EBCDIC VERSION              TSO
         LINEDIT   TEXT='QUOTE character is .',                     SEB+
               SUB=(CHARA,RQUOTE,1)                                 TSO
         TR        RQUOTE(1),ETOA    KEEP THE ASCII FORM AROUND     TSO
         TM        LFLAGS,ALLFL
         BO    SHOEND                                               AJR
         B         SHOWOK
         SPACE 3                                                    TSO
SHOLRECL LH    R4,LRECL                                             TSO
         LINEDIT   TEXT='LRECL   is .....',SUB=(DEC,(R4))       AJR SEB
         TM        LFLAGS,ALLFL
         BO    SHOBLKSZ                                             TSO
         B         SHOWOK
         SPACE 3                                                    TSO
SHOBLKSZ LH    R4,BLKSIZE                                           TSO
         LINEDIT TEXT='BLKSIZE is .....',SUB=(DEC,(R4))             SEB
         TM    LFLAGS,ALLFL                                         TSO
         BO    SHOWPRIM                                             TSO
         B     SHOWOK                                               TSO
         SPACE 3                                                    TSO
SHOWPRIM LH    R4,PRIME                                             TSO
         LINEDIT TEXT='PRIMARY  allocation is  .....',              SEB+
               SUB=(DEC,(R4))                                       TSO
         TM    LFLAGS,ALLFL                                         TSO
         BO    SHOWSECN                                             TSO
         B     SHOWOK                                               TSO
         SPACE 3                                                    TSO
SHOWSECN LH    R4,SECOND                                            TSO
         LINEDIT TEXT='SECONDARY allocation is .....',              SEB+
               SUB=(DEC,(R4))                                       TSO
         TM    LFLAGS,ALLFL                                         TSO
         BO    SHOWDIR                                              TSO
         B     SHOWOK                                               TSO
         SPACE 3                                                    TSO
SHOWDIR  LH    R4,DIRCTY                                            TSO
         LINEDIT TEXT='DIRECTORY block allocation is .....',        SEB+
               SUB=(DEC,(R4))                                       TSO
         TM    LFLAGS,ALLFL                                         TSO
         BO    SHOWARN                                              AJR
         B     SHOWOK                                               TSO
         SPACE 3                                                    TSO
SHOEND   SR        R4,R4               ZERO IT OUT
         IC        R4,SEOL
         LINEDIT   TEXT='END-of-Line character is .. (decimal)',    TSO*
               SUB=(DEC,(R4))
         TM        LFLAGS,ALLFL
         BO    SHOPACET                                             TSO
         B         SHOWOK
         SPACE 3                                                    TSO
SHOPACET LINEDIT   TEXT='Receive PACKET size is .... (decimal)',    TSO*
               SUB=(DECA,RPSIZ)
         TM    LFLAGS,ALLFL                                         TSO
         BO    SHOWDLAY                                             TSO
         B         SHOWOK
         SPACE 3                                                    TSO
SHOWTABS DS    0H                                                   TSO
         LA    R3,TABMSG2         ASSUME TAB EXPANSION IS ON        TSO
         LA    R4,L'TABMSG2       GET MESSAGE LENGTH                TSO
         CLI   TABSWI,1           IS TAB EXPANSION ON?              TSO
         BE    SHOTBMSG           YES, GO SEND MESSAGE              TSO
         LA    R3,TABMSG1         GET TAB EXPANSION OFF MESSAGE     TSO
         LA    R4,L'TABMSG1       GET LENGTH                        TSO
SHOTBMSG WRTERM (R3),(R4)                                           TSO
         MVC   WORKAREA(L'TABMSGPR),TABMSGPR  PUT IN MSG PREFIX     TSO
         LH    R2,TABCOUNT        GET COUNT OF ACTIVE TABS          TSO
         LA    R3,TABTBL          POINT TO TABLE OF TABS            TSO
         SR    R4,R4              CLEAR TAB REG                     TSO
         LA    R5,WORKAREA+L'TABMSGPR  POINT TO START OF TAB AREA   TSO
SHOTBLOP IC    R4,0(,R3)          GET A TAB                         TSO
         CVD   R4,SHODBLWD        CONVERT IT                        TSO
         MVC   SHOTBPRT(8),SHOTBPAT  MOVE IN EDIT PATTERN           TSO
         ED    SHOTBPRT(8),SHODBLWD+4  CONVERT THE NUMBER           TSO
         LA    R6,1               ASSUME LENGTH OF 1                TSO
         C     R4,=F'10'          CHECK LENGTH OF TAB SETTING       TSO
         BL    SHOTBMOV           MOVE ONE CHARACTER                TSO
         LA    R6,2               ASSUME LENGTH OF 2                TSO
         C     R4,=F'100'         CHECK LENGTH OF TAB SETTING       TSO
         BL    SHOTBMOV           MOVE TWO CHARACTERS               TSO
         LA    R6,3               MOVE THERE CHARACTERS             TSO
SHOTBMOV LA    R1,SHOTBPRT+8      POINT TO END OF CNVRTD TAB        TSO
         SR    R1,R6              POINT TO 1ST CHARACTER TO MOVE    TSO
         BCTR  R6,0               ADJUST LENGTH FOR EX              TSO
         EX    R6,SHOTBMV         MOVE IN PRINTABLE TAB SETTING     TSO
*SHOTBMV MVC   0(*-*,R5),0(R1)                                      TSO
         LA    R5,1(R6,R5)        POINT TO PLACE TO PUT COMMA       TSO
         MVI   0(R5),C','         PUT IN COMMA                      TSO
         LA    R5,1(,R5)          POINT TO NEXT BUFFER POSITION     TSO
         LA    R3,1(,R3)          POINT TO NEXT TAB IN TAB LIST     TSO
         LA    R14,WORKAREA       GET ADDRESS OF START OF WORK AREA TSO
         LR    R15,R5             CALCULATE LENGTH                  TSO
         SR    R15,R14            OF OUTPUT LINE                    TSO
         C     R15,=F'72'         IS THE LINE FILLED?               TSO
         BL    SHOTBBCT           NO                                TSO
         SPACE 1                                                    TSO
*        THE LINE HAS GOTTEN TOO LONG.  DISPLAY THIS LINE AND       TSO
*        START A NEW ONE WITH NO MESSAGE PREFIX                     TSO
         SPACE 1                                                    TSO
         WRTERM (R14),(R15)       OUTPUT THE LINE                   TSO
         MVC   WORKAREA(L'TABMSGPR),BLANKS  CLEAR FIRST PART OF MSG TSO
         LA    R5,WORKAREA+L'TABMSGPR  POINT TO PLACE TO PUT TABS   TSO
SHOTBBCT BCT   R2,SHOTBLOP        GO GET NEXT TAB SETTING           TSO
         BCTR  R5,0               OVERWRITE LAST COMMA              TSO
         MVI   0(R5),C')'         WITH A PARENTHESIS                TSO
         LA    R5,1(,R5)          POINT PAST END OF MESSAGE         TSO
         LA    R2,WORKAREA        POINT TO START OF BUFFER          TSO
         SR    R5,R2              GET LENGTH TO DISPLAY             TSO
         WRTERM (R2),(R5)         DISPLAY TAB SETTINGS              TSO
         TM    LFLAGS,ALLFL                                         TSO
         BO    SHOSERIE                                             AJR
         B     SHOWOK             ALL THROUGH                       TSO
         SPACE 1                                                    TSO
SHOTBMV  MVC   0(*-*,R5),0(R1)                                      TSO
         SPACE 1                                                    TSO
TABMSGPR DC    C'Current TAB settings: ('                           AJR
SHOTBPRT DC    D'0'               TAB CONVERT AREA                  TSO
SHOTBPAT DC    X'4020202020202120'  EDIT PATTERN                    TSO
         SPACE 3                                                    TSO
SHOWDLAY L     R5,DELAY                                             TSO
         SR    R4,R4              SET UP DIVIDE                     TSO
         D     R4,=F'100'         CALCULATE SECONDS                 TSO
         LINEDIT TEXT='Send command DELAY in seconds is .....',     AJR+
               SUB=(DEC,(R5))                                       TSO
         TM    LFLAGS,ALLFL                                         TSO
         BO    SHOWTABS                                             AJR
         B     SHOWOK             ALL THROUGH                       TSO
         SPACE 3                                                    TSO
SHOWHEAD LA    R3,HEADMSG1        ASSUME BLOCK HEADER IS ON         TSO
         LA    R4,L'HEADMSG1      GET LENGTH OF MESSAGE             TSO
         TM    SRFLAGS,SRBLOCK    IS BLOCK HEADER ON?               TSO
         BO    SHOWHDPR           YES, GO PRINT MESSAGE             TSO
         LA    R3,HEADMSG2        GET BLOCK HEADER OFF MESSAGE      TSO
         LA    R4,L'HEADMSG2      GET MESSAGE LENGTH                TSO
SHOWHDPR WRTERM (R3),(R4)                                           TSO
         B     SHOWOK             ALL THROUGH                       TSO
         SPACE 3                                                    TSO
SHOWERR  LA        R15,4               SET A NON-ZERO RETCODE
         B         SHOWRET
SHOWOK   SR        R15,R15             ZERO RETCODE
*
SHOWRET  RET   ,
SHODBLWD DC    D'0'               DOUBLEWORD WORK AREA              TSO
         EXIT                                                       TSO
         PUSH  PRINT                                                TSO
         PRINT NOGEN                                                TSO
SHOWPARM IKJPARM ,                                                  TSO
SHOCMDS  IKJKEYWD DEFAULT='ALL',                                    AJR
         IKJNAME 'IBM7171'                                          TSO
         IKJNAME 'SERIES1'                                          TSO
         IKJNAME 'WARNING'                                          AJR
         IKJNAME 'FILE'                                             TSO
         IKJNAME 'DEBUG'                                            TSO
         IKJNAME 'BLOCK'                                            TSO
         IKJNAME 'RECFM'                                            TSO
         IKJNAME 'QUOTE'                                            TSO
         IKJNAME 'BLKSIZE'                                          TSO
         IKJNAME 'LRECL'                                            TSO
         IKJNAME 'END'                                              TSO
         IKJNAME 'PACKET'                                           TSO
         IKJNAME 'ALL'                                              TSO
         IKJNAME 'PRIMARY'                                          TSO
         IKJNAME 'SECONDARY'                                        TSO
         IKJNAME 'DIRECTORY'                                        TSO
         IKJNAME 'TABS'                                             TSO
         IKJNAME 'DELAY'                                            TSO
         IKJNAME 'HEADER'                                           TSO
         IKJENDP ,                                                  TSO
         POP   PRINT                                                TSO
         TITLE '(TDUMP) TDUMP command processor'                    TSO
*        THIS ROUTINE PROCESSES THE TDUMP COMMAND WHICH DUMPS THE   TSO
*        TRANSLATE TABLES.  IT IS USED TO DISPLAY THESE TABLES SO   TSO
*        THAT THE "SET ATOE", "SET ETOA", "SET ATOENCP", AND        AJR
*        "SET ETOANCP" COMMANDS CAN BE USED TO ALTER THE TABLES.    AJR
*                                                                   TSO
*        THE FOLLOWING COMMANDS ARE PROCESSED:                      TSO
*                                                                   TSO
*          "TDUMP ATOE"                                             TSO
*          "TDUMP ETOA"                                             TSO
*          "TDUMP ATOENCP"                                          AJR
*          "TDUMP ETOANCP"                                          AJR
         SPACE 3                                                    TSO
TDUMP    ENTER ,                                                    TSO
         SETSEMI                  GO INSERT SEMICOLON               TSO
         LA    R10,PPLAREA        GET ADDRESS OF PPL                TSO
         USING PPL,R10            MAKE IT ADDRESSABLE               TSO
         ST    R1,PPLCBUF         PUT ADDR OF COMMAND BUFFER IN PPL TSO
         PARSE TDUMPARM,ATTN=TDUMOK,ERR=TDUMERR                     TSO
         CHECKPDL GOOD=TDUKEYWD                                     TSO
         WRTERM 'PARSE found invalid parameters on the TDUMP command'
         B     TDUMERR                                              TSO
         SPACE 1                                                    TSO
         USING IKJPARMD,R9        MAKE PDL ADDRESSABLE              TSO
         SPACE 1                                                    TSO
TDUKEYWD NI        LFLAGS,X'FF'-ALLFL  Turn off just in case        TSO
         LH    R8,TDUCMDS         GET VALUE OF KEYWORD              TSO
         IKJRLSA PDLADDR          RELEASE THE PDL                   TSO
         XC    PDLADDR,PDLADDR    CLEAR THE PDL ADDRESS             TSO
         MH    R8,=H'4'           SET UP BRANCH LIST                TSO
         B     *+4(R8)            BRANCH ON KEYWORD LIST            TSO
         B     TDUMERR             0 - NO KEYWORD                   TSO
         B     TDUETOA             4 - ETOA                         TSO
         B     TDUATOE             8 - ATOE                         TSO
         B     TDUETOAN           12 - ETOANCP                      AJR
         B     TDUATOEN           16 - ATOENCP                      AJR
         SPACE 1                                                    TSO
TDUETOA  SR        R4,R4                                            TSO
         LA        R3,ETOA                                          AJR
TD1      C         R4,=F'16'                                        TSO
         BE        TDUMOK              All lines displayed          TSO
         LINEDIT   TEXT='....................................',     TSO*
               SUB=(HEX4A,(R3)),DOT=NO                              TSO
         LA        R4,1(R4)            Increment counter            TSO
         LA        R3,16(R3)           Point to next line           TSO
         B         TD1                                              TSO
         SPACE 3                                                    TSO
TDUETOAN SR        R4,R4                                            AJR
         L         R3,ETOANCPA                                      AJR
         B         TD1                                              AJR
         SPACE 1                                                    AJR
TDUATOE  SR        R4,R4                                            TSO
         LA        R3,ATOE                                          TSO
         B         TD1                                              TSO
         SPACE 1                                                    TSO
TDUATOEN SR        R4,R4                                            AJR
         L         R3,ATOENCPA                                      AJR
         B         TD1                                              AJR
         SPACE 1                                                    AJR
TDUMERR  LA        R15,4               SET A NON-ZERO RETCODE       TSO
         B         TDUMRET                                          TSO
TDUMOK   SR        R15,R15             ZERO RETCODE                 TSO
*                                                                   TSO
TDUMRET  RET   ,                                                    TSO
         EXIT                                                       TSO
         PUSH  PRINT                                                TSO
         PRINT NOGEN                                                TSO
TDUMPARM IKJPARM ,                                                  TSO
TDUCMDS  IKJKEYWD ,                                                 TSO
         IKJNAME 'ETOA'                                             TSO
         IKJNAME 'ATOE'                                             TSO
         IKJNAME 'ETOANCP'                                          AJR
         IKJNAME 'ATOENCP'                                          AJR
         IKJENDP ,                                                  TSO
         POP   PRINT                                                TSO
         TITLE '(SETSEMI) Insert semi-colon into command buffer'    TSO
*        This routine inserts a semi-colon into the command buffer  TSO
*        following the parameter pointed to by the offset field of  TSO
*        the command buffer.  This will cause parse to terminate    TSO
*        parsing at the semi-colon.  A new offset to the next       TSO
*        parameter is also calculated so that parse can begin       TSO
*        again, if desired, beyond the semi-colon.                  TSO
*                                                                   TSO
*        The purpose of doing this at all is to maintain the        TSO
*        original syntax of virtually every KERMIT in existance.    TSO
*        Moving the semi-colon around in the command buffer         TSO
*        controls IKJPARS in a way that allows the syntax to        TSO
*        remain unchanged.                                          TSO
*                                                                   TSO
*        On entry:                                                  TSO
*        R1 -> Command Buffer                                       TSO
         SPACE 3                                                    TSO
SETSEMI  ENTER ,                                                    TSO
         LA    R4,1               SET UP BXLE INCREMENT             TSO
         LR    R5,R1              POINT TO COMMAND BUFFER           TSO
         AH    R5,0(,R1)          POINT PAST LAST CHAR OF COMMAND   TSO
         BCTR  R5,0               POINT TO LAST CHARACTER OF CMD    TSO
         L     R3,NWOFFSET        GET OFFSET TO CURRENT SEMI-COLON  TSO
         LA    R3,4(R3,R1)        POINT TO PLACE TO START SCAN      TSO
         BCTR  R3,0               REMOVE AN                         TSO
         MVI   0(R3),C' '         EXISTING                          TSO
         LA    R3,1(,R3)          SEMI-COLON                        TSO
         MVI   SEMILOOK,C' '      SCAN FOR BLANK BY DEFAULT         TSO
         CLI   0(R3),C'?'         IS THE CHARACTER A "?"            AJR
         BE    SETHELP            GO SET HELP FLAG                  AJR
         LA    R6,X'00'           TAKE DOWN THE FLAG                AJR
         STC   R6,HELPFLG         RESET HELP FLAG                   AJR
SEMILIST CLI   0(R3),C'('         IS THE CHARACTER A LIST?          TSO
         BNE   SEMISCAN           NO, THEN CHECK FOR A BLANK        TSO
         MVI   SEMILOOK,C')'      SCAN FOR END OF LIST              TSO
SEMISCAN CLC   0(1,R3),SEMILOOK   END OF PARAMETER?                 TSO
         BE    SEMIBLNK           YES                               TSO
         BXLE  R3,R4,SEMISCAN     CONTINUE SCAN                     TSO
         B     SEMIRTRN           RETURN IF END OF BUFFER           TSO
         SPACE 1                                                    TSO
SETHELP  LA    R6,X'FF'           GET FLAG                          AJR
         STC   R6,HELPFLG         SET HELP FLAG                     AJR
         B     SEMILIST                                             AJR
         SPACE 1                                                    AJR
SEMIBLNK BXH   R3,R4,SEMIRTRN     CHECK FOR END OF COMMAND STRING   TSO
         CLI   0(R3),C' '         IS IT A BLANK?                    TSO
         BE    SEMIBLNK           NO, CONTINUE SCAN                 TSO
         BCTR  R3,0               POINT TO PREVIOUS BLANK           TSO
         MVI   0(R3),C';'         INSERT SEMI-COLON                 TSO
         LA    R3,1(,R3)          POINT BEYOND SEMI-COLON           TSO
         LA    R1,4(,R1)          GET POINTER TO COMMAND            TSO
         SR    R3,R1              GET NEW OFFSET                    TSO
         ST    R3,NWOFFSET        SAVE NEW OFFSET                   TSO
         SPACE 2                                                    TSO
SEMIRTRN RET   ,                                                    TSO
SEMILOOK DC    C' '               CHARACTER TO SCAN FOR             TSO
HELPFLG  DS    1B                                                   AJR
         EXIT                                                       TSO
         TITLE '(PREFIX) Prefix data set name'                      TSO
*        THIS SUBROUTINE PREFIXES THE DATA SET NAME PASSED IN R1    TSO
*        WITH THE USER'S USERID TO FORM A FULLY QUALIFIED DATA      TSO
*        SET NAME.                                                  TSO
*                                                                   TSO
*        ON ENTRY:                                                  TSO
*          R1 -> H'DSNAME-LENGTH',CL44'DSNAME'                      TSO
*                                                                   TSO
*        ON EXIT:                                                   TSO
*          R15 CONTAINS A RETURN CODE                               TSO
*              0 - PREFIXING WAS NORMAL                             TSO
*              4 - DATA SET NOT FOUND                               TSO
*              8 - ERROR IN PREFIXING                               TSO
         SPACE 3                                                    TSO
PREFIXDS ENTER ,                                                    TSO
         LA    R2,PRFXDFPB        GET DFPB ADDRESS                  TSO
         USING DFPB,R2            MAKE IT ADDRESSABLE               TSO
         LR    R4,R1              PRESERVE ADDR OF UNPREFIXED NAME  TSO
         STCM  R1,7,DFPBDSN+1     PUT IN LENGTH AND DSNAME          TSO
         DROP  R2                 DROP DFPB ADDRESSABILITY          TSO
         MVI   CPECB,0            CLEAR ECB                         TSO
         LA    R1,PRFXDFPL        GET ADDRESS OF DFPL               TSO
         LINK  EP=IKJEHDEF        ADD USERID TO DSNAME              TSO
         B     *+4(R15)           BRANCH ON RETURN CODE             TSO
         B     PRFXNORM           0  - SUCCESSFUL                   TSO
         B     PRFXPERR           4  - PUTLINE OR PUTGET ERROR      TSO
         B     PRFXGT44           8  - LENGTH > 44 CHARACTERS       TSO
         B     PRFXCTIO           12 - CATALOG I/O ERROR            TSO
         B     PRFXLOW            16 - LOWER LEVEL DSNAME           TSO
         B     PRFXNOT            20 - DATA SET NOT FOUND           TSO
         B     PRFXATTN           24 - ATTENTION                    TSO
         DC    2H'0'              28 - SHOULD NOT HAPPEN            TSO
         DC    2H'0'              32 - SHOULD NOT HAPPEN            TSO
         B     PRFXNQL            36 - NO QUALIFIERS FOUND          TSO
         SPACE 1                                                    TSO
PRFXNORM SR    R15,R15            SET RETURN CODE                   TSO
         B     PRFXRTN            GO RETURN TO CALLER               TSO
         SPACE 1                                                    TSO
PRFXNOT  LA    R15,4              SET RETURN FOR NOT FOUND          TSO
         AIF   ('&PREFIX' NE 'DISTRIB').NPRFX1                      TSO
*        THIS CODE PREFIXES DATA SET NAMES IF IKJDFLT RETURNS       TSO
*        WITH A DATA SET NOT FOUND CONDITION.  THE STANDARD         TSO
*        IKJDFLT DOES NOT PREFIX A DATA SET THAT IS NOT IN THE      TSO
*        CATALOG.                                                   TSO
         SPACE 1                                                    TSO
         L     R5,CPPLADDR        GET CPPL ADDRESS                  TSO
         L     R5,CPPLUPT-CPPL(,R5)  GET THE UPT ADDRESS            TSO
         USING UPT,R5             MAKE UPT ADDRESSABLE              TSO
         LH    R6,0(,R4)          GET LENGTH OF UNPREFIXED NAME     TSO
         MVC   PRFXDSNX,2(R4)     PRESERVE THE UNPREFIXED NAME      TSO
         SR    R2,R2              CLEAR FOR IC                      TSO
         IC    R2,UPTPREFL        GET THE LENGTH OF THE PREFIX      TSO
         LA    R6,1(R2,R6)        COMPUTE LENGTH OF PREFIXED NAME   TSO
         CL    R6,=F'44'          IS NAME TOO LONG?                 TSO
         BH    PRFXGT44           YES, GO RETURN ERROR              TSO
         BCTR  R2,0               ADJUST FOR EX                     TSO
         EX    R2,PRFXMPX         PUT PREFIX INTO DSNAME AREA       TSO
*PRFXMPX MVC   2(*-*,R4),UPTPREFX                                   TSO
         LA    R3,3(R2,R4)        PLACE TO PUT "."                  TSO
         MVI   0(R3),C'.'         INSERT LEVEL MARKER               TSO
         LH    R2,0(,R4)          GET LENGTH OF UNPREFIXED NAME     TSO
         BCTR  R2,0               ADJUST FOR EX                     TSO
         EX    R2,PRFXMDS         MOVE DSNAME BACK PAST PREFIX      TSO
*PRFXMDS MVC   1(*-*,R3),PRFXDSNX                                   TSO
         STH   R6,0(,R4)          SET LENGTH TO NEW VALUE           TSO
.NPRFX1  ANOP                                                       TSO
         B     PRFXRTN            GO RETURN ERROR TO CALLER         TSO
         SPACE 1                                                    TSO
PRFXPERR LA    R2,PRFXPER         GET ADDRESS OF MESSAGE            TSO
         LA    R3,L'PRFXPER       GET LENGTH OF MESSAGE             TSO
         B     PRFXERR            GO RETURN ERROR TO CALLER         TSO
         SPACE 1                                                    TSO
PRFXGT44 LA    R2,PRFXG44         GET ADDRESS OF MESSAGE            TSO
         LA    R3,L'PRFXG44       GET LENGTH OF MESSAGE             TSO
         B     PRFXERR            GO RETURN ERROR TO CALLER         TSO
         SPACE 1                                                    TSO
PRFXCTIO LA    R2,PRFXCIO         GET ADDRESS OF MESSAGE            TSO
         LA    R3,L'PRFXCIO       GET LENGTH OF MESSAGE             TSO
         B     PRFXERR            GO RETURN ERROR TO CALLER         TSO
         SPACE 1                                                    TSO
PRFXLOW  LA    R2,PRFXALOW        GET ADDRESS OF MESSAGE            TSO
         LA    R3,L'PRFXALOW      GET LENGTH OF MESSAGE             TSO
         B     PRFXERR            GO RETURN ERROR TO CALLER         TSO
         SPACE 1                                                    TSO
PRFXATTN LA    R2,PRFXATN         GET ADDRESS OF MESSAGE            TSO
         LA    R3,L'PRFXATN       GET LENGTH OF MESSAGE             TSO
         B     PRFXERR            GO RETURN ERROR TO CALLER         TSO
         SPACE 1                                                    TSO
PRFXNQL  LA    R2,PRFXQLM         GET ADDRESS OF MESSAGE            TSO
         LA    R3,L'PRFXQLM       GET LENGTH OF MESSAGE             TSO
         SPACE 1                                                    TSO
PRFXERR  TM    SRFLAGS,SRINTO     DSNAME ON COMMAND?                TSO
         BZ    PRFXRERR           NO, RETURN ERROR CODE ONLY        TSO
         WRTERM (R2),(R3)                                           TSO
PRFXRERR LA    R15,8              SET UP RETURN CODE                TSO
PRFXRTN  RET   ,                                                    TSO
         SPACE 3                                                    TSO
         AIF   ('&PREFIX' NE 'DISTRIB').NPRFX2                      TSO
PRFXMPX  MVC   2(*-*,R4),UPTPREFX                                   TSO
PRFXMDS  MVC   1(*-*,R3),PRFXDSNX                                   TSO
PRFXDSNX DC    CL44' '            WORK AREA FOR UNPREFIXED DSNAME   TSO
         SPACE 1                                                    TSO
.NPRFX2  ANOP                                                       TSO
PRFXQLM  DC    C'No qualifiers found during prefix processing'      TSO
PRFXATN  DC    C'Attention received during prefix processing'       TSO
PRFXALOW DC    C'Data set name exists at a lower level'             TSO
PRFXCIO  DC    C'Catalog I/O error during prefix processing'        TSO
PRFXG44  DC    C'Data set name length greater than 44 characters'   TSO
PRFXPER  DC    C'PUTLINE or PUTGET error during prefix processing'  TSO
         EXIT                                                       TSO
         TITLE '(ALLOCDSN) Allocate a data set'                     TSO
*        THIS SUBROUTINE ALLOCATES A DATA SET USING SVC 99          TSO
*        FACILITIES.                                                TSO
*                                                                   TSO
*        ON ENTRY:                                                  TSO
*          R1 -> ALLOCATION CONTROL BLOCK; DSECT ALCCB              TSO
*                                                                   TSO
*        ON EXIT:                                                   TSO
*                                                                   TSO
*          R1 -> DDNAME ASSIGNED TO ALLOCATION                      TSO
*          R0 CONTAINS LENGTH OF DDNAME                             TSO
*          R15  CONTAINS A RETURN CODE                              TSO
*               0 -- SUCCESSFUL ALLOCATION                          TSO
*               4 -- "OLD" ALLOCATION; DATA SET NOT FOUND           TSO
*               8 -- ALLOCATION FAILED                              TSO
*              12 -- INCOMPATABLE DATA SET TYPES                    TSO
*              16 -- UNSUPPORTED DATA SET TYPE                      TSO
         SPACE 3                                                    TSO
ALLOCDSN ENTER ,                                                    TSO
         LR    R10,R1             PRESERVE ALLOCATION CB ADDRESS    TSO
         USING ALCCB,R10          MAKE ALLOCATION CB ADDRESSABLE    TSO
         MVC   ALCDSNAM+6(44),BLANKS  CLEAR DSNAME AREA             TSO
         L     R4,ALCDSN          GET ADDRESS OF DSNAME & LENGTH    TSO
         LH    R2,0(,R4)          GET LENGTH OF DSNAME              TSO
         BCTR  R2,0               SET UP FOR EX                     TSO
         EX    R2,ALCMVDS         PUT DSNAME INTO TEXT UNIT         TSO
*ALCMVDS MVC   ALCDSNAM+6(*-*),2(R4)                                TSO
         MVC   ALCBLKSI+6(2),BLKSIZE  PUT BLKSIZE INTO TEXT UNIT    TSO
         MVC   ALCLRECL+6(2),LRECL  PUT LRECL INTO TEXT UNIT        TSO
         LH    R0,PRIME           PUT PRIMARY SPACE ALLOCATION      TSO
         STCM  R0,7,ALCPRIME+6    INTO TEXT UNIT                    TSO
         LH    R0,SECOND          PUT SECONDARY SPACE ALLOCATION    TSO
         STCM  R0,7,ALCSECON+6    INTO TEXT UNIT                    TSO
         LH    R0,DIRCTY          PUT DIRECTORY BLOCK VALUE         TSO
         STCM  R0,7,ALCDIR+6      INTO TEXT UNIT                    TSO
         CLI   RFM,C'V'           RECFM=VB?                         AJR
         BE    ALCSETVB           YES                               AJR
         CLI   RFM,C'U'           RECFM=U?                          AJR
         BE    ALCSETU            YES                               AJR
         MVI   ALCRECFM+6,X'90'   SET UP RECFM=FB                   TSO
         B     ALCSETXT           CONTINUE                          TSO
         SPACE 1                                                    TSO
ALCSETU  MVI   ALCRECFM+6,X'C0'   SET UP RECFM=U                    AJR
         MVC   ALCLRECL+6(2),ZEROS    PUT ZEROS INTO ALCLRECL       AJR
         B     ALCSETXT           CONTINUE                          AJR
         SPACE 1                                                    AJR
ALCSETVB MVI   ALCRECFM+6,X'50'   SET UP RECFM=VB                   TSO
         SPACE 1                                                    TSO
ALCSETXT LA    R0,ALCDSTXT        GET ADDR OF DSNAME TEXT UNIT LIST TSO
         ST    R0,ALCRBTXT        PUT INTO RB                       TSO
         TM    ALCTYPE+3,ALCTNEW  IS IT ALLOCATION OF NEW DATA SET  TSO
         BZ    ALCCKMEM           NO, GO CHECK FOR MEMBER NAME      TSO
         LA    R0,ALCNWDSN        GET ADDR OF NEW DSNAME TEXT UNIT  TSO
         ST    R0,ALCRBTXT        PUT INTO RB                       TSO
         SPACE 1                                                    TSO
ALCCKMEM ICM   R4,15,ALCMEMBR     GET ADDRESS OF MEMBER NAME        TSO
         BZ    ALCALC             NO MEMBER NAME, ALLOCATE DATA SET TSO
         MVC   ALCMEM+6(8),BLANKS CLEAR MEMBER NAME TO BLANKS       TSO
         LH    R2,0(,R4)          GET LENGTH OF DSNAME              TSO
         BCTR  R2,0               SET UP FOR EX                     TSO
         EX    R2,ALCMVME         PUT IN MEMBER NAME                TSO
*ALCMVME MVC   ALCMEM+6(*-*),2(R4)                                  TSO
         LA    R0,ALCMEMTX        GET ADDR OF MEMBER TEXT UNIT LIST TSO
         ST    R0,ALCRBTXT        PUT INTO RB                       TSO
         TM    ALCTYPE+3,ALCTNEW  IS IT ALLOCATION OF NEW DATA SET? TSO
         BZ    ALCALC             NO, GO ALLOCATE                   TSO
         LA    R0,ALCNWMEM        GET ADDR OF NEW MEMBER TEXT UNIT  TSO
         ST    R0,ALCRBTXT        PUT INTO RB                       TSO
         SPACE 1                                                    TSO
ALCALC   LA    R1,ALCRBPTR        POINT TO RB POINTER               TSO
         DYNALLOC                 ALLOCATE THE DATA SET             TSO
         LTR   R15,R15            ALLOCATION OK?                    TSO
         BZ    ALCNORM            YES, RETURN TO CALLER             TSO
         TM    ALCTYPE+3,ALCTOLD  "OLD" ALLOCATION ATTEMPT?         TSO
         BZ    ALCFAIL            NO                                TSO
         CL    R15,=F'4'          RETURN CODE OF 4?                 TSO
         BNE   ALCFAIL            NO, PROCESS REGULAR FAILURE       TSO
         CLC   =X'1708',ALCERRCD  DATA SET NOT FOUND?               TSO
         BNE   ALCFAIL            NO                                TSO
         LA    R15,4              SET "NOT FOUND" RETURN CODE       TSO
         B     ALCRTRN            GO RETURN TO CALLER               TSO
         SPACE 1                                                    TSO
ALCFAIL  TM    SRFLAGS,SRINTO     FILE NAME SPECIFIED ON COMMAND?   TSO
         BZ    ALCERR             NO, RETURN ERROR CODE ONLY        TSO
         LA    R1,ALCRB           PASS ADDRESS OF FAILING RB        TSO
         LR    R0,R15             PASS RETURN CODE FROM DYNALLOC    TSO
         L     R15,=A(DAIRFAIL)   GET DAIRFAIL ROUTINE ADDRESS      TSO
         BALR  R14,R15            GO SEND ERROR MESSAGE             TSO
         SPACE 1                                                    TSO
ALCERR   LA    R15,8              SET ERROR RETURN CODE             TSO
         B     ALCRTRN            AND RETURN TO CALLER              TSO
         SPACE 1                                                    TSO
ALCINCMP LA    R15,12             SET INCOMPATIBLE DATA SET TYPES   TSO
         B     ALCRTRN            AND RETURN TO CALLER              TSO
         SPACE 1                                                    TSO
ALCUNSPT LA    R15,16             SET UNSUPPORTED DATA SET TYPE     TSO
         B     ALCRTRN            AND RETURN TO CALLER              TSO
         SPACE 1                                                    TSO
*        DETERMINE TYPE OF DATA SET AND WHETHER THE USER SPECIFIED  TSO
*        THE CORRECT TYPE IN HIS ALLOCATION REQUEST.                TSO
         SPACE 1                                                    TSO
ALCNORM  DS    0H                                                   TSO
         TM    ALCTYPE+3,ALCTOLD  WAS THIS OLD ALLOCATION?          TSO
         BZ    ALCCCAT            NO, GO ADD DDNAME TO CONCAT TABLE TSO
         TM    ALCTYPE+3,ALCCMPAT CHECK FOR COMPATIBILITY?          TSO
         BO    ALCCCAT            NO, GO ADD DDNAME TO CONCAT TABLE TSO
         CLC   =X'0200',ALCRTORG+6 IS DATA SET A PDS?               TSO
         BNE   ALCPS              NO, GO LOOK A DSORG=PS            TSO
         NC    ALCMEMBR,ALCMEMBR  WAS MEMBER NAME SPECIFIED?        TSO
         BNZ   ALCCCAT            YES, ALLOCATION OK                TSO
         TM    SRFLAGS,SRINTO     FILE NAME SPECIFIED ON COMMAND?   TSO
         BZ    ALCDEALC           NO, DEALLOCATE FIRST              TSO
         WRTERM 'Data set specified is partitioned but no member name w+
               as specified'                                        TSO
ALCDEALC UNALLOC DSNAME,ADDR=ALCDSN  UNALLOCATE THE DATA SET        TSO
         TM    SRFLAGS,SRINTO     FILE NAME SPECIFIED ON COMMAND?   TSO
         BZ    ALCINCMP           NO, RETURN ERROR CODE ONLY        TSO
         B     ALCERR             GO FAIL ALLOCATION                TSO
         SPACE 1                                                    TSO
ALCPS    CLC   =X'4000',ALCRTORG+6 IS DATA SET DSORG=PS?            TSO
         BNE   ALCINVDS           NO, INVALID DATA SET TYPE         TSO
         NC    ALCMEMBR,ALCMEMBR  WAS MEMBER NAME SPECIFIED?        TSO
         BZ    ALCCCAT            NO, ALLOCATION OK                 TSO
         TM    SRFLAGS,SRINTO     FILE NAME SPECIFIED ON COMMAND?   TSO
         BZ    ALCDEAL                                              TSO
         WRTERM 'Data set specified is not a partitioned data set'  TSO
ALCDEAL  UNALLOC DSNAME,ADDR=ALCDSN  UNALLOCATE THE DATA SET        TSO
         TM    SRFLAGS,SRINTO     FILE NAME SPECIFIED ON COMMAND?   TSO
         BZ    ALCINCMP           NO, RETURN ERROR CODE ONLY        TSO
         B     ALCERR             GO FAIL ALLOCATION                TSO
         SPACE 1                                                    TSO
ALCINVDS TM    SRFLAGS,SRINTO     FILE NAME SPECIFIED ON COMMAND?   TSO
         BZ    ALCUNSPT           NO, RETURN ERROR CODE ONLY        TSO
         WRTERM 'Data set specified has unsupported data organization'
         B     ALCERR             GO FAIL ALLOCATION                TSO
         SPACE 1                                                    TSO
*        ADD DDNAME TO CONCATENATION TABLE                          TSO
         SPACE 1                                                    TSO
ALCCCAT  TM    ALCTYPE+3,ALCNCONC ADD TO CONCATENATION TABLE?       TSO
         BO    ALCRTNDD           NO                                TSO
         DROP  R10                DROP ALCCB ADDRESSABILITY         TSO
         LH    R2,ALCDDNAM+4      GET DDNAME LENGTH                 TSO
         L     R3,CONCPTR         GET POINTER TO NEXT CONCTABL ENTRYTSO
         STCM  R2,3,0(R3)         SAVE LENGTH OF DDNAME             TSO
         BCTR  R2,0               ADJUST FOR EX                     TSO
         EX    R2,MOVDDN          PUT IN DDNAME                     TSO
*MOVDDN  MVC   2(*-*,R3),ALCDDNAM+6                                 TSO
         LA    R3,3(R2,R3)        CALCULATE POINTER TO NEXT ENTRY   TSO
         ST    R3,CONCPTR         PUT POINTER BACK                  TSO
         LH    R1,CONCCNT         GET CURRENT CONCTABL COUNT        TSO
         LA    R1,1(,R1)          BUMP COUNT BY 1                   TSO
         STH   R1,CONCCNT         PUT IT BACK                       TSO
         SPACE 1                                                    TSO
ALCRTNDD LA    R1,ALCDDNAM+6      POINT TO DDNAME                   TSO
         LH    R0,ALCDDNAM+4      GET LENGTH OF DDNAME              TSO
         SR    R15,R15            SET RETURN CODE                   TSO
         SPACE 1                                                    TSO
ALCRTRN  RET   (2,12)                                               TSO
         SPACE 3                                                    TSO
ALCMVDS  MVC   ALCDSNAM+6(*-*),2(R4)                                TSO
ALCMVME  MVC   ALCMEM+6(*-*),2(R4)                                  TSO
MOVDDN   MVC   2(*-*,R3),ALCDDNAM+6                                 TSO
         SPACE 1                                                    TSO
ALCRBPTR DC    0F'0',X'80',AL3(ALCRB)  POINTER TO DYN RB            TSO
         SPACE 1                                                    TSO
ALCRB    DS    0F                 DYN RB                            TSO
         DC    AL1(20,1,X'20',0)  X'20' FLAG IS S99NOMNT            TSO
ALCERRCD DC    A(0)               ERROR AND INFORMATION CODES       TSO
ALCRBTXT DC    A(*-*,0)           POINT TO TEXT POINTERS, RESERVED  TSO
         DC    A(0)               FLAGS2                            TSO
         SPACE 1                                                    TSO
ALCDSTXT DS    0F                 OLD DATA SET, NON-PDS             TSO
         DC    A(ALCDDNAM)                                          TSO
         DC    A(ALCDSNAM)                                          TSO
         DC    A(ALCSHR)                                            TSO
         DC    A(ALCNKEEP)                                          TSO
         DC    A(ALCCKEEP)                                          TSO
         DC    A(ALCRTORG)                                          TSO
         ORG   *-4                                                  TSO
         DC    X'80'                                                TSO
         ORG   ,                                                    TSO
         SPACE 1                                                    TSO
ALCNWDSN DS    0F                 NEW DATA SET, NON-PDS             TSO
         DC    A(ALCDDNAM)                                          TSO
         DC    A(ALCDSNAM)                                          TSO
         DC    A(ALCNEW)                                            TSO
         DC    A(ALCNCTLG)                                          TSO
         DC    A(ALCCDELT)                                          TSO
         DC    A(ALCTRK)                                            TSO
         DC    A(ALCPRIME)                                          TSO
         DC    A(ALCSECON)                                          TSO
         DC    A(ALCBLKSI)                                          TSO
         DC    A(ALCDSOPS)                                          TSO
         DC    A(ALCLRECL)                                          TSO
         DC    A(ALCRECFM)                                          TSO
         ORG   *-4                                                  TSO
         DC    X'80'                                                TSO
         ORG   ,                                                    TSO
         SPACE 1                                                    TSO
ALCMEMTX DS    0F                 OLD DATA SET, PDS                 TSO
         DC    A(ALCDDNAM)                                          TSO
         DC    A(ALCDSNAM)                                          TSO
         DC    A(ALCMEM)                                            TSO
         DC    A(ALCSHR)                                            TSO
         DC    A(ALCNKEEP)                                          TSO
         DC    A(ALCCKEEP)                                          TSO
         DC    A(ALCRTORG)                                          TSO
         ORG   *-4                                                  TSO
         DC    X'80'                                                TSO
         ORG   ,                                                    TSO
         SPACE 1                                                    TSO
ALCNWMEM DS    0F                 NEW DATA SET, PDS                 TSO
         DC    A(ALCDDNAM)                                          TSO
         DC    A(ALCDSNAM)                                          TSO
         DC    A(ALCMEM)                                            TSO
         DC    A(ALCNEW)                                            TSO
         DC    A(ALCDIR)                                            TSO
         DC    A(ALCNCTLG)                                          TSO
         DC    A(ALCCDELT)                                          TSO
         DC    A(ALCTRK)                                            TSO
         DC    A(ALCPRIME)                                          TSO
         DC    A(ALCSECON)                                          TSO
         DC    A(ALCBLKSI)                                          TSO
         DC    A(ALCDSOPO)                                          TSO
         DC    A(ALCLRECL)                                          TSO
         DC    A(ALCRECFM)                                          TSO
         ORG   *-4                                                  TSO
         DC    X'80'                                                TSO
         ORG   ,                                                    TSO
         SPACE 1                                                    TSO
ALCDDNAM DC    AL2(X'0055',1,8),CL8' '     DDNAME RETURNED          TSO
ALCRTORG DC    AL2(X'0057',1,2),X'0000'    DSORG RETURNED           TSO
ALCDSNAM DC    AL2(X'0002',1,44),CL44' '   DSNAME                   TSO
ALCMEM   DC    AL2(X'0003',1,8),CL8' '     MEMBER NAME              TSO
ALCSHR   DC    AL2(X'0004',1,1),X'08'      STATUS = SHR             TSO
ALCNEW   DC    AL2(X'0004',1,1),X'04'      STATUS = NEW             TSO
ALCNKEEP DC    AL2(X'0005',1,1),X'08'      NDISP = KEEP             TSO
ALCNCTLG DC    AL2(X'0005',1,1),X'02'      NDISP = CATLG            TSO
ALCCKEEP DC    AL2(X'0006',1,1),X'08'      CDISP = KEEP             TSO
ALCCDELT DC    AL2(X'0006',1,1),X'04'      CDISP = DELETE           TSO
ALCTRK   DC    AL2(X'0007',0)              ALLOCATION IN TRACKS     TSO
ALCPRIME DC    AL2(X'000A',1,3),AL3(*-*)   PRIMARY ALLOCATION (5)   TSO
ALCSECON DC    AL2(X'000B',1,3),AL3(*-*)   SECONDARY ALLOCATION (5) TSO
ALCDIR   DC    AL2(X'000C',1,3),AL3(*-*)   DIRECTORY BLKS = 10      TSO
         SPACE 1                                                    TSO
*        DCB ATTRIBUTE TEXT UNITS                                   TSO
         SPACE 1                                                    TSO
ALCBLKSI DC    AL2(X'0030',1,2),AL2(*-*)   BLKSIZE = 3600 (DEFAULT) TSO
ALCDSOPS DC    AL2(X'003C',1,2),X'4000'    DSORG = PS               TSO
ALCDSOPO DC    AL2(X'003C',1,2),X'0200'    DSORG = PO               TSO
ALCLRECL DC    AL2(X'0042',1,2),AL2(*-*)   LRECL = 80 (DEFAULT)     TSO
ALCRECFM DC    AL2(X'0049',1,1),X'90'      RECFM = FB               TSO
         EXIT                                                       TSO
         TITLE '(DEALLOC) Unallocate a data set'                    TSO
*        THIS ROUTINE DEALLOCATES A DATA SET BY DATA SET NAME       TSO
*        OR DDNAME                                                  TSO
*                                                                   TSO
*        ON ENTRY:                                                  TSO
*          R0 CONTAINS DEALLOCATION CODE                            TSO
*            0 -- DEALLOCATE BY DSNAME                              TSO
*            4 -- DEALLOCATE BY DDNAME                              TSO
*          R1 -> H'length',C'data set name'  IF BY DSNAME           TSO
*          R1 -> H'length',C'ddname'         IF BY DDNAME           TSO
*                                                                   TSO
*        ON EXIT:                                                   TSO
*          R15 CONTAINS RETURN CODE                                 TSO
*            0 -- NORMAL DEALLOCATION                               TSO
*            4 -- DEALLOCATION ERROR                                TSO
         SPACE 3                                                    TSO
DEALLOC  ENTER ,                                                    TSO
         LTR   R0,R0              IS THIS DSNAME DEALLOCATION?      TSO
         BZ    DEADSN             YES, DEALLOCATE BY DSNAME         TSO
         SR    R2,R2              CLEAR FOR ICM                     TSO
         ICM   R2,3,0(R1)         GET LENGTH OF DDNAME              TSO
         BNP   DEANULL            ZERO LENGTH, SEND MSG & RETURN    TSO
         STH   R2,DEADDNAM+4      PUT LENGTH INTO TEXT UNIT         TSO
         BCTR  R2,0               ADJUST FOR EX                     TSO
         MVC   DEADDNAM+6(8),BLANKS  CLEAR DDNAME AREA              TSO
         EX    R2,DEAMVDD         PUT DDNAME INTO TEXT UNIT         TSO
*DEAMVDD MVC   DEADDNAM+6(*-*),2(R1)                                TSO
         LA    R0,DEADDTXT        GET ADDRESS OF DDNAME TEXT UNITS  TSO
         ST    R0,DEARBTXT        PUT INTO RB                       TSO
         B     DEADEALC           GO DEALLOCATE BY DDNAME           TSO
         SPACE 1                                                    TSO
DEADSN   SR    R2,R2              CLEAR FOR ICM                     TSO
         ICM   R2,3,0(R1)         GET LENGTH OF DATA SET NAME       TSO
         BNP   DEANULL            ZERO LENGTH, SEND MSG & RETURN    TSO
         STH   R2,DEADSNAM+4      PUT LENGTH INTO TEXT UNIT         TSO
         BCTR  R2,0               ADJUST FOR EX                     TSO
         MVC   DEADSNAM+6(44),BLANKS  CLEAR DSNAME AREA             TSO
         EX    R2,DEAMVDS         PUT DSNAME INTO TEXT UNIT         TSO
*DEAMVDS MVC   DEADSNAM+6(*-*),2(R1)                                TSO
         LA    R0,DEADSTXT        GET ADDRESS OF DSNAME TEXT UNITS  TSO
         ST    R0,DEARBTXT        PUT INTO RB                       TSO
         SPACE 1                                                    TSO
DEADEALC LA    R1,DEARBPTR        GET RB POINTER ADDRESS            TSO
         DYNALLOC                                                   TSO
         LTR   R15,R15            DEALLOCATION OK?                  TSO
         BZ    DEAOK              YES                               TSO
         CLC   =X'0440',DEAERRCD  WAS ERROR DATA SET NOT ALLOC?     TSO
         BE    DEAOK              YES, TREAT AS A NORMAL SITUATION  TSO
         TM    SRFLAGS,SRINTO     FILE NAME SPECIFIED ON COMMAND?   TSO
         BZ    DEAFAIL            NO,  RETURN ERROR CODE ONLY       TSO
         LA    R1,DEARB           PASS ADDRESS OF FAILING RB        TSO
         LR    R0,R15             PASS RETURN CODE FROM DYNALLOC    TSO
         L     R15,=A(DAIRFAIL)   GET DAIRFAIL ROUTINE ADDRESS      TSO
         BALR  R14,R15            GO SEND ERROR MESSAGE             TSO
         SPACE 1                                                    TSO
DEAFAIL  LA    R15,4              SET ERROR RETURN CODE             TSO
         B     DEARTRN            AND RETURN TO CALLER              TSO
         SPACE 1                                                    TSO
DEANULL  TM    SRFLAGS,SRINTO     NAME SPECIFIED ON COMMAND?        TSO
         BZ    DEAFAIL            NO                                TSO
         WRTERM 'Deallocation error.  Zero length DDNAME or DSNAME' TSO
         B     DEAFAIL            GO RETURN ERROR                   TSO
         SPACE 1                                                    TSO
DEAOK    SR    R15,R15            SET SUCCESSFUL RETURN CODE        TSO
         SPACE 1                                                    TSO
DEARTRN  RET   ,                                                    TSO
         SPACE 3                                                    TSO
DEAMVDD  MVC   DEADDNAM+6(*-*),2(R1)                                TSO
DEAMVDS  MVC   DEADSNAM+6(*-*),2(R1)                                TSO
         SPACE 3                                                    TSO
DEARBPTR DC    0F'0',X'80',AL3(DEARB)  POINTER TO DYN RB            TSO
         SPACE 1                                                    TSO
DEARB    DS    0F                 DYN RB                            TSO
         DC    AL1(20,2,X'20',0)  X'20' FLAG IS S99NOMNT            TSO
DEAERRCD DC    A(0)               ERROR AND INFORMATION CODES       TSO
DEARBTXT DC    A(*-*,0)           POINT TO TEXT POINTERS, RESERVED  TSO
         DC    A(0)               FLAGS2                            TSO
         SPACE 1                                                    TSO
DEADSTXT DS    0F                 DEALLOCATE BY DSNAME              TSO
         DC    A(DEADSNAM)                                          TSO
         ORG   *-4                                                  TSO
         DC    X'80'                                                TSO
         ORG   ,                                                    TSO
         SPACE 1                                                    TSO
DEADDTXT DS    0F                 DEALLOCATE BY DDNAME              TSO
         DC    A(DEADDNAM)                                          TSO
         ORG   *-4                                                  TSO
         DC    X'80'                                                TSO
         ORG   ,                                                    TSO
         SPACE 1                                                    TSO
DEADDNAM DC    AL2(X'0001',1,8),CL8' '    DEALLOCATE BY DDNAME      TSO
DEADSNAM DC    AL2(X'0002',1,44),CL44' '  DEALLOCATE BY DSNAME      TSO
DEAREMOV DC    AL2(X'0008',0)             REMOVE IN-USE ATTRIBUTE   TSO
         EXIT                                                       TSO
         TITLE '(CONCAT) Concatenate data sets'                     TSO
*        CONCATENATE DATA SETS.  WHEN THIS SUBROUTINE IS ENTERED    TSO
*        THE TEXT UNIT "CONCTXT" CONTAINS THE DDNAMES TO BE         TSO
*        CONCATENATED.                                              TSO
*                                                                   TSO
*        ON EXIT:                                                   TSO
*          R1 -> DDNAME OF THE CONCATENATED DATA SETS               TSO
*          R0 CONTAINS THE LENGTH OF THE DDNAME                     TSO
         SPACE 3                                                    TSO
CONCAT   ENTER ,                                                    TSO
         CLC   CONCCNT,=H'2'      ANYTHING TO CONCATENATE?          TSO
         BL    CONCOK             NO, ALL THROUGH                   TSO
         LA    R0,CONCTXT         GET ADDRESS OF CONCAT TEXT UNIT   TSO
         ST    R0,CNCTXT          PUT INTO TEXT UNIT POINTER        TSO
         MVI   CNCTXT,X'80'       SET END OF LIST                   TSO
         LA    R1,CNCRBPTR        POINT TO RB POINTER               TSO
         DYNALLOC                 DO CONCATENATION                  TSO
         LTR   R15,R15            CONCATENATION OK?                 TSO
         BZ    CONCOK             YES                               TSO
         LA    R1,CNCRB           PASS ADDRESS OF FAILING RB        TSO
         LR    R0,R15             PASS RETURN CODE FROM DYNALLOC    TSO
         L     R15,=A(DAIRFAIL)   GET DAIRFAIL ROUTINE ADDRESS      TSO
         BALR  R14,R15            GO SEND ERROR MESSAGE             TSO
         LA    R15,4              SET ERROR RETURN CODE             TSO
         B     CONCRTN                                              TSO
         SPACE 1                                                    TSO
CONCOK   LA    R0,CONCTABL        GET ADDRESS OF CONCTABL           TSO
         ST    R0,CONCPTR         RESET CONCTABL TO START           TSO
         LH    R0,CONCTABL        GET LENGTH OF DDNAME              TSO
         LA    R1,CONCTABL+2      POINT TO DDNAME                   TSO
         OI    CONCFLAG,CONCON    INDICATE DATA SETS CONCATENATED   TSO
         SR    R15,R15            SET RETURN CODE                   TSO
         SPACE 1                                                    TSO
CONCRTN  RET   (2,12)                                               TSO
         SPACE 3                                                    TSO
CNCRBPTR DC    0F'0',X'80',AL3(CNCRB)  POINTER TO DYN RB            TSO
         SPACE 1                                                    TSO
CNCRB    DS    0F                 DYN RB                            TSO
         DC    AL1(20,3,X'20',0)  X'20' FLAG IS S99NOMNT            TSO
CNCERRCD DC    A(0)               ERROR AND INFORMATION CODES       TSO
         DC    A(CNCTXT,0)        POINT TO TEXT POINTERS, RESERVED  TSO
         DC    A(0)               FLAGS2                            TSO
         SPACE 1                                                    TSO
CNCTXT   DS    0F                                                   TSO
         DC    A(0)               POINTER TO TEXT UNIT              TSO
         EXIT                                                       TSO
         TITLE '(DECONCAT) Deconcatenate data sets'                 TSO
*        THIS ROUTINE DECONCATENATES THE DATA SETS IN THE           TSO
*        CONCATENATION TABLE                                        TSO
*                                                                   TSO
*        ON EXIT:                                                   TSO
*          R15 CONTAINS RETURN CODE                                 TSO
*           0 -- NORMAL DECONCATENATION                             TSO
*           4 -- ABNORMAL DECONCATENATION                           TSO
         SPACE 3                                                    TSO
DECONCAT ENTER ,                                                    TSO
         TM    CONCFLAG,CONCON    ARE DATA SETS CONCATENATED?       TSO
         BZ    DECONOK            NO, RETURN NORMAL COMPLETION      TSO
         CLC   CONCCNT,=H'2'      ARE DATA SETS CONCATENATED?       TSO
         BL    DECONOK            NO, RETURN NORMAL COMPLETION      TSO
         LH    R2,CONCTABL        GET LENGTH OF DDNAME              TSO
         STH   R2,DECDDNAM+4      PUT INTO TEXT UNIT                TSO
         BCTR  R2,0               ADJUST FOR EX                     TSO
         MVC   DECDDNAM+6,BLANKS  CLEAR DDNAME AREA                 TSO
         EX    R2,DECONMV         PUT DDNAME INTO TEXT UNIT         TSO
*DECONMV MVC   DECDDNAM+6,CONCTABL+2                                TSO
         LA    R1,DECRBPTR        GET ADDRESS OF RB POINTER         TSO
         DYNALLOC                                                   TSO
         LTR   R15,R15            DECONCATENATION GO OK?            TSO
         BZ    DECONOK            YES                               TSO
         LA    R1,DECRB           POINT TO FAILING RB               TSO
         LR    R0,R15             PASS RETURN CODE FROM DYNALLOC    TSO
         L     R15,=A(DAIRFAIL)   GET DAIRFAIL ROUTINE ADDRESS      TSO
         BALR  R14,R15            GO SEND ERROR MESSAGE             TSO
         LA    R15,4              SET FAIL RETURN CODE              TSO
         B     DECONRTN           GO RETURN ERROR                   TSO
         SPACE 1                                                    TSO
DECONOK  SR    R15,R15            SET NORMAL RETURN CODE            TSO
         NI    CONCFLAG,255-CONCON  DATA SETS NO LONGER CONCATENATEDTSO
         SPACE 1                                                    TSO
DECONRTN RET   ,                                                    TSO
         SPACE 1                                                    TSO
DECONMV  MVC   DECDDNAM+6,CONCTABL+2                                TSO
         SPACE 3                                                    TSO
DECRBPTR DC    0F'0',X'80',AL3(DECRB)  POINTER TO DYN RB            TSO
         SPACE 1                                                    TSO
DECRB    DS    0F                 DYN RB                            TSO
         DC    AL1(20,4,X'20',0)  X'20' FLAG IS S99NOMNT            TSO
DECERRCD DC    A(0)               ERROR AND INFORMATION CODES       TSO
         DC    A(DECTXT,0)        POINT TO TEXT POINTERS, RESERVED  TSO
         DC    A(0)               FLAGS2                            TSO
         SPACE 1                                                    TSO
DECTXT   DS    0F                                                   TSO
         DC    A(DECDDNAM)        POINTER TO TEXT UNIT              TSO
         ORG   *-4                                                  TSO
         DC    X'80'                                                TSO
         ORG   ,                                                    TSO
         SPACE 1                                                    TSO
DECDDNAM DC    AL2(X'0001',1,8),CL8' '  DECONCATENATE               TSO
         EXIT                                                       TSO
         TITLE '(DAIRFAIL) Process DYNALLOC errors'                 TSO
*        THIS SUBROUTINE CALLS THE DAIRFAIL PROGRAM (IKJEFF18) TO   TSO
*        SEND THE USER A MESSAGE ABOUT WHY AN ALLOCATION FAILED.    TSO
*                                                                   TSO
*        ON ENTRY:                                                  TSO
*          R1 -> FAILING RB                                         TSO
*          R0 CONTAINS RETURN CODE FROM DYNAMIC ALLOCATION          TSO
         SPACE 3                                                    TSO
DAIRFAIL ENTER ,                                                    TSO
         ST    R0,FAILRC          SAVE RETURN CODE                  TSO
         L     R0,CPPLADDR        GET THE CPPL ADDRESS              TSO
         ST    R0,DFCPPLP         PUT INTO DAIRFAIL PARM LIST       TSO
         ST    R1,DFS99RBP        PUT ADDRESS OF RB INTO PARM LIST  TSO
         LA    R0,FAILRC          GET ADDRESS OF RETURN CODE        TSO
         ST    R0,DFRCP           PUT INTO DAIRFAIL PARM LIST       TSO
         LA    R0,ZEROS           GET ADDRESS OF ZEROS              TSO
         ST    R0,DFJEFF02        PUT INTO DAIRFAIL PARM LIST       TSO
         LA    R0,FAILIDP         GET ADDRESS OF SWITCHES           TSO
         ST    R0,DFIDP           PUT INTO DAIRFAIL PARM LIST       TSO
         XC    DFBUFP,DFBUFP      CLEAR BUFFER ADDRESS              TSO
         LA    R1,DFPARMS         GET ADDRESS OF PARM LIST          TSO
         LINK  EP=IKJEFF18        GO TO DAIRFAIL                    TSO
FAILRTN  RET   ,                                                    TSO
         SPACE 3                                                    TSO
FAILIDP  DC    X'0032'            INDICATE SVC 99 CALL              TSO
FAILRC   DC    F'0'               RETURN CODE FROM FAILING DYNALLOC TSO
         SPACE 1                                                    TSO
         IKJEFFDF                                                   TSO
         EXIT                                                       TSO
         TITLE '(PUTLINE) Write a message to the terminal'          TSO
PUTLINE  ENTER ,                                                    TSO
         LTR   R0,R0              IS THIS A "DATA" PUTLINE?         TSO
         BM    PUTLDATA           YES                               TSO
         MVI   CPECB,0            CLEAR ECB                         TSO
         LR    R2,R0              SET UP LENGTH                     TSO
         LA    R2,4+1(,R2)        ADD LENGTH OF HEADER + BLANK      TSO
         STH   R2,PUTLBLEN        PUT MESSAGE LENGTH INTO BUFFER    TSO
         MVI   PUTLTEXT,C' '      PUT BLANK IN FRONT OF TEXT        TSO
         LR    R3,R0              SET UP                            TSO
         BCTR  R3,0               TO MOVE MESSAGE                   TSO
         EX    R3,PUTLMOV         PUT MESSAGE TEXT INTO BUFFER      TSO
*PUTLMOV MVC   PUTLTEXT+1(*-*),0(R1)                                TSO
         SPACE 1                                                    TSO
*        SET UP PUTLINE CONTROL BLOCKS AND SEND MESSAGE             TSO
         SPACE 1                                                    TSO
         PUTLINE PARM=PTPBAREA,OUTPUT=(OLD),TERMPUT=(EDIT),         TSO*
               MF=(E,IOPLAREA)                                      TSO
         SPACE 1                                                    TSO
         B     *+4(R15)           BRANCH ON RETURN CODE             TSO
         B     PUTLRTN            0  -  PUTLINE WAS SUCCESSFUL      TSO
         B     PUTLRTN            4  -  ATTENTION (IGNORE)          TSO
         DC    2H'0'              8  -  NOWAIT OPTION SPECIFIED     TSO
         DC    2H'0'              12 -  BAD PARM LIST               TSO
         B     PUTLSTOR           16 -  INSUFFICIENT STORAGE        TSO
         B     PUTLDISC           20 -  TERMINAL DISCONNECTED       TSO
         SPACE 3                                                    TSO
PUTLDATA N     R0,=X'7FFFFFFF'    CLEAR HIGH ORDER BIT              TSO
         TPUT  (1),(0),CONTROL                                      TSO
         B     *+4(R15)           BRANCH ON RETURN CODE             TSO
         B     PUTLRTN            0  -  TPUT WAS SUCCESSFUL         TSO
         DC    2H'0'              4  -  NOWAIT OPTION SPECIFIED     TSO
         B     PUTLRTN            8  -  ATTENTION (IGNORE)          TSO
         DC    2H'0'              12 -  ASID OPTION                 TSO
         DC    2H'0'              16 -  BAD PARM LIST               TSO
         B     PUTLDISC           20 -  TERMINAL DISCONNECTED       TSO
         SPACE 1                                                    TSO
*        INSUFFICIENT STORAGE TO DO PUTLINE.  THIS IS VERY UNUSUAL. TSO
*        ABEND THE COMMAND WITH ABEND USER=001.                     TSO
         SPACE 1                                                    TSO
PUTLSTOR ABEND 1                                                    TSO
         SPACE 2                                                    TSO
*        THE TERMINAL HAS DISCONNECTED. QUIT USING SVC 3            TSO
         SPACE 1                                                    TSO
PUTLDISC SVC   3                  QUIT                              TSO
         SPACE 2                                                    TSO
*        NORMAL RETURN.  R15 MAY BE SET TO SOME VALUE               TSO
         SPACE 1                                                    TSO
PUTLRTN  RET   ,                                                    TSO
         SPACE 1                                                    TSO
PUTLMOV  MVC   PUTLTEXT+1(*-*),0(R1)                                TSO
         SPACE 1                                                    TSO
PTPBAREA PUTLINE MF=L             SKELETON PTPB                     TSO
         EXIT                                                       TSO
         TITLE '(GETLINE) Get line of data from asynch terminal'    TSO
*        THIS ROUTINE USES THE TSO GETLINE FACILITY TO GET A        TSO
*        LINE OF DATA FROM AN ASYNCHRONOUS TERMINAL.  A PHYSICAL    TSO
*        LINE IS GOTTEN ASIS.                                       TSO
*                                                                   TSO
*        ON ENTRY:                                                  TSO
*          R0 CONTAINS LENGTH OF BUFFER TO PUT DATA INTO            TSO
*          R1 -> BUFFER TO PUT DATA INTO                            TSO
*                                                                   TSO
*        ON EXIT:                                                   TSO
*          R1 CONTAINS LENGTH OF DATA LINE READ                     TSO
*          R15 CONTAINS RETURN CODE                                 TSO
*            0 INDICATES READ WAS SUCCESSFUL                        TSO
         SPACE 3                                                    TSO
GETLINE  ENTER ,                                                    TSO
         TGET  (1),(0),ASIS                                         TSO
         B     *+4(R15)           BRANCH ON RETURN CODE             TSO
         B     GETLGOOD           0  - TGET WAS SUCCESSFUL          TSO
         DC    2H'0'              4  - NOWAIT OPTION SPECIFIED      TSO
         B     GETLGOOD           8  - ATTENTION (IGNORE)           TSO
         DC    2H'0'              12 - BUFFER TOO SMALL             TSO
         DC    2H'0'              16 - BAD PARM LIST                TSO
         B     GETLDISC           20 - TERMINAL DISCONNECTED        TSO
         SPACE 1                                                    TSO
*        THE TERMINAL HAS DISCONNECTED.  QUIT USING SVC 3           TSO
         SPACE 1                                                    TSO
GETLDISC SVC   3                  QUIT                              TSO
         SPACE 1                                                    TSO
GETLGOOD SR    R15,R15                                              TSO
         RET   (2,12)                                               TSO
         EXIT                                                       TSO
         TITLE '(PUTGET) Prompt for input and get reply'            TSO
*        THIS ROUTINE USES THE PUTGET ROUTINE TO PROMPT THE USER    TSO
*        FOR INPUT AND THEN PASSES THE MESSAGE RECEIVED BACK TO     TSO
*        THE CALLING ROUTINE.                                       TSO
*                                                                   TSO
*        ON ENTRY:                                                  TSO
*          R1 -> MESSAGE TO BE SENT                                 TSO
*          R0 CONTAINS THE LENGTH OF THE MESSAGE                    TSO
*                                                                   TSO
*        ON EXIT:                                                   TSO
*          R1 -> INPUT BUFFER RETURNED FORMATED AS FOLLOWS:         TSO
*                H'LENGTH',H'0',C'INPUT-MESSAGE-FROM-USER'          TSO
         SPACE 3                                                    TSO
PUTGET   ENTER ,                                                    TSO
         MVI   CPECB,0            CLEAR ECB                         TSO
         LR    R2,R0              SET UP LENGTH                     TSO
         LA    R2,4+1(,R2)        ADD LENGTH OF HEADER + BLANK      TSO
         STH   R2,PUTLBLEN        PUT MESSAGE LENGTH INTO BUFFER    TSO
         MVI   PUTLTEXT,C' '      PREFIX MESSAGE WITH BLANK         TSO
         LR    R3,R0              SET UP                            TSO
         BCTR  R3,0               TO MOVE MESSAGE                   TSO
         EX    R3,PTGTMOV         PUT MESSAGE TEXT INTO BUFFER      TSO
*PTGTMOV MVC   PUTLTEXT+1(*-*),0(R1)                                TSO
         SPACE 1                                                    TSO
*        FREE ANY PREVIOUS INPUT BUFFER THAT IS STILL AROUND        TSO
         SPACE 1                                                    TSO
         LA     R4,PGPBAREA       GET ADDRESS OF PGPB               TSO
         USING  PGPB,R4           MAKE IT ADDRESSABLE               TSO
         L      R1,PGPBIBUF       GET INPUT BUFFER ADDRESS          TSO
         LTR    R1,R1             IS THERE ONE?                     TSO
         BZ     PTGTGET           NO, GO DO PROMPT                  TSO
         LH     R0,0(,R1)         GET LENGTH OF BUFFER              TSO
         ICM    R0,8,=X'01'       FREE FROM SP=1                    TSO
         FREEMAIN R,LV=(0),A=(1)  FREE THE PUTGET BUFFER            TSO
         XC     PGPBIBUF,PGPBIBUF CLEAR POINTER TO PUTGET BUFFER    TSO
PTGTGET  PUTGET PARM=PGPBAREA,OUTPUT=(OLD,SINGLE,MODE),             TSO+
               TERMPUT=ASIS,MF=(E,IOPLAREA)                         TSO
         SPACE 1                                                    TSO
         B     *+4(R15)           BRANCH ON RETURN CODE             TSO
         B     PTGTNORM           0  - NORMAL COMPLETION            TSO
         B     PTGTNORM           4  - NORMAL COMPLETION            TSO
         B     PTGTATTN           8  - NORMAL COMPLETION (ATTENTION)TSO
         B     PTGTNPRM           12 - NO PROMPTING ALLOWED         TSO
         DC    2H'0'              16 - NOWAIT OPTION ON TPUT        TSO
         DC    2H'0'              20 - NOWAIT OPTION ON TGET        TSO
         DC    2H'0'              24 - INVALID PARM LIST            TSO
         B     PTGTSTOR           28 - INSUFFICIENT STORAGE         TSO
         B     PTGTDISC           32 - TERMINAL HAS DISCONNECTED    TSO
         SPACE 1                                                    TSO
PTGTNPRM WRTERM 'Prompting has been disallowed for this session'    TSO
         ABEND 2                                                    TSO
         SPACE 1                                                    TSO
*        INSUFFICIENT STORAGE TO DO PUTGET.  THIS IS VERY UNUSUAL.  TSO
*        ABEND THE COMMAND WITH ABEND USER=001                      TSO
         SPACE 1                                                    TSO
PTGTSTOR ABEND 1                                                    TSO
         SPACE 3                                                    TSO
*        THE TERMINAL HAS DISCONNECTED.  QUIT USING SVC 3           TSO
         SPACE 1                                                    TSO
PTGTDISC SVC   3                                                    TSO
         SPACE 1                                                    TSO
PTGTATTN LA    R15,4              ATTENTION RETURN CODE             TSO
         B     PTGTRTN            GO RETURN                         TSO
         SPACE 3                                                    TSO
*        NORMAL RETURN.  PUT ADDRESS OF RETURNED BUFFER IN R1       TSO
         SPACE 1                                                    TSO
PTGTNORM L     R1,PGPBIBUF        GET ADDRESS OF INPUT BUFFER       TSO
         SR    R15,R15            NORMAL RETURN CODE                TSO
         SPACE 1                                                    TSO
PTGTRTN  RET   (2,12)                                               TSO
         SPACE 1                                                    TSO
PTGTMOV  MVC   PUTLTEXT+1(*-*),0(R1)                                TSO
         DROP  R4                 DROP PGPB ADDRESSABILITY          TSO
         SPACE 1                                                    TSO
PGPBAREA PUTGET MF=L                                                TSO
         EXIT                                                       TSO
         TITLE '(SCANCBUF) Scan command buffer for command'         TSO
*        ROUTINE TO SCAN THE STANDARD TSO COMMAND BUFFER AND RETURN TSO
*        THE ADDRESS OF THE COMMAND SCANNED AND THE OFFSET TO ANY   TSO
*        PARAMETERS PRESENT IN THE COMMAND BUFFER.                  TSO
*                                                                   TSO
*        ON ENTRY:                                                  TSO
*          R1 -> TSO COMMAND BUFFER TO BE SCANNED                   TSO
*                                                                   TSO
*        ON EXIT:                                                   TSO
*          R0 -> LENGTH OF COMMAND THAT WAS FOUND                   TSO
*          R1 -> UPDATED COMMAND BUFFER                             TSO
*          R2 -> COMMAND THAT WAS FOUND                             TSO
         SPACE 3                                                    TSO
SCANCBUF ENTER ,                                                    TSO
         MVI   CPECB,0            CLEAR ECB                         TSO
         LA    R4,CSPLAREA        GET CSPL ADDRESS                  TSO
         USING CSPL,R4            MAKE CSPL ADDRESSABLE             TSO
         ST    R1,CSPLCBUF        PUT COMMAND BUFFER ADDR INTO CSPL TSO
         LA    R1,CSPL            GET ADDRESS OF CSPL               TSO
         LINK  EP=IKJSCAN         GO SCAN FOR COMMAND               TSO
         B     *+4(R15)           BRANCH ON RETURN CODE             TSO
         B     SCANOK             0  - SCAN WAS SUCCESSFUL          TSO
         DC    2H'0'              4  - INVALID PARAMETER LIST       TSO
         SPACE 1                                                    TSO
SCANOK   L     R5,CSPLOA          GET ADDRESS OF CSOA               TSO
         USING CSOA,R5            MAKE CSOA ADDRESSABLE             TSO
         L     R1,CSPLCBUF        POINT TO COMMAND BUFFER           TSO
         LH    R1,2(,R1)          GET BUFFER OFFSET                 TSO
         ST    R1,NWOFFSET        SET UP FOR PLACING SEMI-COLON     TSO
         SR    R0,R0              ASSUME NO COMMAND                 TSO
         SR    R1,R1              ASSUME NO COMMAND                 TSO
         TM    CSOAFLG,CSOAVWP+CSOAVNP+CSOAQM  VALID COMMAND?       TSO
         BZ    SCANRTN            NO, RETURN TO CALLER              TSO
         LH    R0,CSOALNM         RETURN LENGTH OF COMMAND NAME     TSO
         L     R2,CSOACNM         RETURN ADDRESS OF COMMAND NAME    TSO
         L     R1,CSPLCBUF        RETURN ADDRESS OF COMMAND BUFFER  TSO
SCANRTN  RET   (3,12)                                               TSO
         EXIT                                                       TSO
         TITLE '(PARSE) Parse the command buffer'                   TSO
*        THIS ROUTINE PARSES THE COMMAND BUFFER THAT IS PASSED      TSO
*        IN THE PARSE PARAMETER LIST                                TSO
*                                                                   TSO
*        ON ENTRY:                                                  TSO
*          R1 -> PARSE PARAMETER LIST                               TSO
*                                                                   TSO
*        ON EXIT:                                                   TSO
*          R15 CONTAINS RETURN CODE                                 TSO
*              0  -  NORMAL PARSING                                 TSO
*              4  -  PARSE ERROR                                    TSO
         SPACE 3                                                    TSO
PARSE    ENTER ,                                                    TSO
         MVI   CPECB,0            CLEAR ECB                         TSO
         LINK  EP=IKJPARS         PARSE THE COMMAND BUFFER          TSO
         B    *+4(R15)            BRANCH ON RETURN                  TSO
         B     PARSNORM           0  - NORMAL PARSING               TSO
         B     PARSBAD            4  - UNABLE TO PARSE              TSO
         B     PARSATTN           8  - ATTENTION INTERRUPTION       TSO
         DC    2H'0'              12 - INVALID PPL                  TSO
         B     PARSNSTO           16 - NO STORAGE AVAILABLE         TSO
         DC    2H'0'              20 - BAD VALIDITY CHECKING ROUTINETSO
         DC    2H'0'              24 - CONFLICTING PARAMETERS       TSO
         B     PARSQUIT           28 - TERMINAL DISCONNECTED        TSO
         SPACE 1                                                    TSO
PARSATTN LA    R15,4              SET ATTENTION RETURN CODE         TSO
         B     PARSRTN            GO RETURN TO CALLER               TSO
         SPACE 1                                                    TSO
PARSBAD  WRTERM 'PARSE unable to prompt for command parameters'     TSO
         B     PARSERR            RETURN AN ERROR                   TSO
         SPACE 1                                                    TSO
PARSNSTO WRTERM 'No storage available for PARSE'                    TSO
         B     PARSERR            RETURN AN ERROR                   TSO
         SPACE 1                                                    TSO
PARSQUIT SVC   3                  THROW IN THE TOWEL                TSO
         SPACE 1                                                    TSO
PARSERR  LA    R15,8              SET ERROR RETURN CODE             TSO
         B     PARSRTN            GO RETURN TO CALLER               TSO
         SPACE 1                                                    TSO
PARSNORM SR    R15,R15            SET RETURN CODE                   TSO
PARSRTN  RET   ,                                                    TSO
         EXIT                                                       TSO
         TITLE '(LINEDIT) Format a line and send to terminal'       TSO
*        THIS ROUTINE PROCESSES "LINEDIT" REQUESTS                  TSO
*                                                                   TSO
*        ON ENTRY                                                   TSO
*          R1 -> PARAMETER LIST AS FOLLOWS:                         TSO
*            AL1(function)               FUNCTION TO BE PERFORMED   TSO
*            AL1(flags)                  FLAGS                      TSO
*            AL2(length of substitution value)                      TSO
*            AL2(length of text string)                             TSO
*            C'text string to be substituted into'                  TSO
*                                                                   TSO
*              WHERE:                                               TSO
*                function is:  0 => HEX                             TSO
*                              1 => HEXA                            TSO
*                              2 => HEX4A                           TSO
*                              3 => DEC                             TSO
*                              4 => DECA                            TSO
*                              5 => CHARA                           TSO
*                                                                   TSO
*                flags are:  X'80' => DOT=YES was specified         TSO
*                            X'40' => substitution value is containedSO
*                                     in R0.                        TSO
         SPACE 3                                                    TSO
LINEDIT  ENTER ,                                                    TSO
         LR    R10,R1             PRESERVE PARM LIST ADDRESS        TSO
         USING LINPARMS,R10       MAKE PARM LIST ADDRESSABLE        TSO
         MVI   LINTXTAR,C' '      CLEAR TEXT                        TSO
         MVC   LINTXTAR+1(L'LINTXTAR),LINTXTAR  STRING AREA         TSO
         SR    R2,R2              CLEAR FOR ICM                     TSO
         ICM   R2,3,LINTEXTL      GET TEXT LENGTH                   TSO
         BCTR  R2,0               ADJUST FOR EX                     TSO
         EX    R2,LMOVTXT         PUT TEXT STRING INTO WORK AREA    TSO
*LMOVTXT MVC   LINTXTAR(*-*),LINTEXT                                TSO
         SPACE 1                                                    TSO
*        DETERMINE POSITION OF SUBSTITUTION AREA AND ITS LENGTH     TSO
         SPACE 1                                                    TSO
         LA    R2,LINTXTAR-1      GET ADDRESS OF START OF STRING-1  TSO
LINLOOP1 LA    R2,1(,R2)          POINT TO NEXT CHARACTER           TSO
         CLI   0(R2),C'.'         FOUND SUBSTITUTION AREA?          TSO
         BNE   LINLOOP1           NO, CONTINUE SCAN                 TSO
         SPACE 1                                                    TSO
         ST    R2,LINSUBAR        PRESERVE START OF SUBST AREA      TSO
         SPACE 1                                                    TSO
LINLOOP2 MVI   0(R2),C' '         CHANGE DOT TO BLANK               TSO
         LA    R2,1(,R2)          POINT TO NEXT CHARACTER           TSO
         CLI   0(R2),C'.'         FOUND END OF SUBSTITUTION AREA?   TSO
         BE    LINLOOP2           NO, CONTINUE SCAN                 TSO
         SPACE 1                                                    TSO
*        CALCULATE LENGTH OF SUBSTITUTION AREA                      TSO
         SPACE 1                                                    TSO
         S    R2,LINSUBAR         CALCULATE LENGTH OF AREA          TSO
         STH  R2,LINSUBLN         SAVE IT FOR LATER                 TSO
         SPACE 1                                                    TSO
         LR    R9,R0              PUT INTO R9 IN CASE OF ADDRESS    TSO
*        SPLIT OUT THE FUNCTION TO BE PERFORMED                     TSO
         SPACE 1                                                    TSO
LINFUNCT DS    0H                                                   TSO
         SR    R15,R15            CLEAR FOR IC                      TSO
         IC    R15,LINFUNC        GET FUNCTION TO BE PERFORMED      TSO
         MH    R15,=H'4'          CHANGE INTO A BRANCH LIST         TSO
         B     *+4(R15)           BRANCH ON FUNCTION CODE           TSO
         B     LIHEX               0  -  HEX                        TSO
         B     LIHEXA              4  -  HEXA                       TSO
         B     LIHEX4A             8  -  HEX4A                      TSO
         B     LIDEC              12  -  DEC                        TSO
         B     LIDECA             16  -  DECA                       TSO
         B     LICHARA            20  -  CHARA                      TSO
         SPACE 3                                                    TSO
*        PERFORM HEX SUBSTITUTION                                   TSO
         SPACE 1                                                    TSO
LIHEX    DS    0H                                                   TSO
         ST    R0,LINSUBVL        R0 HAS VALUE TO BE SUBSTITUTED    TSO
         LA    R9,LINSUBVL        POINT TO SUBSTITUTION VALUE       TSO
         SPACE 1                                                    TSO
LIHEXA   DS    0H                                                   TSO
         MVC   LIHEX4WA,0(R9)     COPY DATA INTO WORK AREA          TSO
         LH    R7,LINSUBLN        GET LENGTH OF SUBSTITUTION AREA   TSO
         CH    R7,=H'8'           LONGER THAN 8 CHARACTERS?         TSO
         BL    *+8                NO, CONTINUE                      TSO
         LA    R7,8               ALLOW ONLY 8 CHARACTERS           TSO
         UNPK  LIHEX8W1(8),LIHEX4WA(5) UNPACK IT                    TSO
         TR    LIHEX8W1(8),LINTRTBL    TRANSLATE IT                 TSO
         SPACE 1                                                    TSO
*        PUT BCD HEX STRING INTO SUBSTITUTION POSITION              TSO
         SPACE 1                                                    TSO
         L     R8,LINSUBAR        POINT TO START OF SUBST AREA      TSO
         LA    R4,LIHEX8W1+7      POINT TO LAST CHAR OF STRING      TSO
         SR    R4,R7              POINT TO 1ST CHARACTER TO MOVE    TSO
         BCTR  R7,0               ADJUST FOR EX                     TSO
         EX    R7,LIMVSUB         MOVE IN SUBSTITUTION VALUE        TSO
*LIMVSUB MVC   0(*-*,R8),0(R4)                                      TSO
         B     LINSEND            GO FINISH UP SUBSTITUTION & SEND  TSO
         SPACE 3                                                    TSO
*        PROCESS HEX4A FUNCTION                                     TSO
         SPACE 1                                                    TSO
LIHEX4A  DS    0H                                                   TSO
         LH    R7,LINSUBLN        GET LENGTH OF SUBSTITUTION AREA   TSO
*        COMPUTE REQUIRED FIELD SIZE TO CONTAIN THE SUBSTITUTION    TSO
*        VALUE.                                                     TSO
*                                                                   TSO
*        REQUIRED LENGTH = (L-1)/4*9 + 2*MOD(L-1,4) + 2             TSO
*                                                                   TSO
         SR    R0,R0                                                TSO
         SR    R1,R1                                                TSO
         ICM   R1,3,LINSUBL       GET SUBST STRING LENGTH           TSO
         BNP   LIH4GO             IF NONE GO BY DOT PATTERN         TSO
         BCTR  R1,0               R1 CONTAINS (L-1)                 TSO
         LTR   R1,R1              WAS ORIGINAL LENGTH = 0?          TSO
         BM    LINSEND            YES, ALL THROUGH                  TSO
         D     R0,=F'4'           DIVIDE BY 4                       TSO
         MH    R1,=H'9'           R1 HAS (L-1)/4*9                  TSO
         AR    R0,R0              R0 HAS 2*MOD(L-1,4)               TSO
         AR    R1,R0              R1 HAS (L-1)/4*9 + 2*MOD(L-1),4)  TSO
         LA    R1,2(,R1)          BUMP BY 2                         TSO
         CLR   R1,R7              TAKE SMALLEST                     TSO
         BNL   *+6                OF TWO                            TSO
         LR    R7,R1              LENGTHS                           TSO
         SPACE 1                                                    TSO
*        4 BYTES ARE CONVERTED AT A TIME INTO 8 AND INSERTED INTO   TSO
*        THE SUBSTITUTION AREA                                      TSO
         SPACE 1                                                    TSO
LIH4GO   LR    R8,R7              GET ACTUAL SUBSTITUTION SIZE      TSO
         L     R14,LINSUBAR       GET START OF SUBSTITUTION AREA    TSO
         LR    R15,R9             POINT TO START OF SOURCE AREA     TSO
         SPACE 1                                                    TSO
LIH4LOOP LR    R1,R8              NUMBER OF BYTES REMAINING TO MOVE TSO
         L     R2,0(,R15)         GET 4 BYTES TO CONVERT            TSO
         ST    R2,LIHEX4WA        PUT INTO WORK AREA                TSO
         UNPK  LIHEX8W1(9),LIHEX4WA(5)  CONVERT                     TSO
         TR    LIHEX8W1(8),LINTRTBL     4 BYTES                     TSO
         CH    R1,=H'8'           AT LEAST 8 BYTES LEFT TO CONVERT? TSO
         BL    *+8                NO, MOVE ONLY WHAT IS THERE       TSO
         LA    R1,8               MOVE ONLY 8 AT A TIME             TSO
         BCTR  R1,0               ADJUST FOR EX                     TSO
         EX    R1,LIH4MOV         MOVE REQUIRED BYTES               TSO
*LIH4MOV MVC   1(*-*,R14),LIHEX8W1                                  TSO
         LA    R14,9(,R14)        NEXT TARGET POSITION              TSO
         LA    R15,4(,R15)        NEXT SOURCE POSITION              TSO
         SH    R8,=H'9'           NEW REMAINING BYTES TO MOVE       TSO
         BP    LIH4LOOP           CONTINUE IF MORE TO MOVE          TSO
         B     LINSEND            GO FINISH UP                      TSO
         SPACE 3                                                    TSO
*        PROCESS DEC AND DECA FUNCTIONS                             TSO
         SPACE 1                                                    TSO
LIDEC    DS    0H                                                   TSO
         ST    R0,LINSUBVL        R0 HAS VALUE TO BE SUBSTITUTED    TSO
         LA    R9,LINSUBVL        POINT TO SUBSTITUTION VALUE       TSO
         SPACE 1                                                    TSO
LIDECA   DS    0H                                                   TSO
         LH    R7,LINSUBLN        GET LENGTH OF SUBSTITUTION AREA   TSO
         L     R8,LINSUBAR        GET ADDRESS OF SUBSTITUTION AREA  TSO
         L     R0,0(,R9)          GET VALUE TO BE CONVERTED         TSO
         LTR   R6,R0              IS IT NEGATIVE? (ORIG NUM IN R6)  TSO
         BNM   LINDECVD           NO, CONTINUE                      TSO
         SPACE 1                                                    TSO
*        ADJUST POINTERS TO BE ABLE TO PUT IN MINUS SIGN            TSO
         SPACE 1                                                    TSO
         LA    R8,1(,R8)          BUMP TARGET POINTER               TSO
         BCTR  R7,0               DECREASE SUBST FIELD LENGTH       TSO
         LPR   R0,R0              MAKE NUMBER POSITIVE              TSO
         SPACE 1                                                    TSO
LINDECVD CH    R7,=H'15'          BUFFER LENGTH EXCEED 15?          TSO
         BL    *+8                NO, CONTINUE                      TSO
         LA    R7,15              MAX LENGTH IS 15                  TSO
         CVD   R0,LIHEX8W1        CONVERT THE NUMBER                TSO
         MVC   LIHEX8W2(16),LIEDPAT  PUT IN EDIT PATTERN            TSO
         ED    LIHEX8W2(16),LIHEX8W1 CONVERT THE NUMBER             TSO
         SPACE 1                                                    TSO
*        COPY ONLY THE RIGHTMOST CHARACTERS THAT WILL FIT INTO      TSO
*        THE FIELD.                                                 TSO
         SPACE 1                                                    TSO
         LA    R1,LIHEX8W2+16     POINT TO LAST CHARACTER           TSO
         SR    R1,R7              POINT TO 1ST CHARACTER TO MOVE    TSO
         BCTR  R7,0               REDUCE BY 1                       TSO
         EX    R7,LIDECMV         PUT IN CONVERTED STRING           TSO
*LIDECMV MVC   0(*-*,R8),0(R1)                                      TSO
         SPACE 1                                                    TSO
*        IF NUMBER WAS NEGATIVE PUT IN A MINUS SIGN                 TSO
         SPACE 1                                                    TSO
         LTR   R6,R6              IS NUMBER NEGATIVE?               TSO
         BNM   LINSEND            NO, FINISHED CONVERSION           TSO
         BCTR  R8,0               BACK UP SUBST POINTER BY 1        TSO
         LA    R7,1(,R7)          RESET SUBSTITUTION FIELD LENGTH   TSO
         SPACE 1                                                    TSO
         LR    R1,R8              R1 -> BLANK BEFORE SUBST AREA     TSO
         LA    R1,1(,R1)          BUMP POINTER                      TSO
         CLI   0(R1),C' '         IS IT A BLANK?                    TSO
         BE    *-8                YES, CONTINUE SEARCH              TSO
         BCTR  R1,0               POINT TO BLANK BEFORE DIGITS      TSO
         MVI   0(R1),C'-'         PUT IN MINUS SIGN                 TSO
         B     LINSEND            FINISHED CONVERSION               TSO
         SPACE 3                                                    TSO
*        PROCESS CHARA FUNCTION                                     TSO
         SPACE 1                                                    TSO
LICHARA  DS    0H                                                   TSO
         LH    R7,LINSUBLN        GET LENGTH OF SUBSTITUTION AREA   TSO
         L     R8,LINSUBAR        GET ADDRESS OF SUBSTITUTION AREA  TSO
         LTR   R7,R7              IS SUBSTITUTION LENGTH 0?         TSO
         BNP   LINSEND            YES, ALL THROUGH                  TSO
         SR    R6,R6              CLEAR FOR ICM                     TSO
         ICM   R6,3,LINSUBL       GET LENGTH OF SUBSTITUTION VALUE  TSO
         BNP   LICHGO             IF NONE GO BY DOT PATTERN         TSO
         CR    R6,R7              USE                               TSO
         BNL   *+6                SMALLER                           TSO
         LR    R7,R6              VALUE                             TSO
LICHGO   BCTR  R7,0               REDUCE BY 1                       TSO
         EX    R7,LICHMOV         PUT IN CHARACTER STRING           TSO
*LICHMOV MVC   1(*-*,R8),0(R9)                                      TSO
         B     LINSEND            ALL THROUGH                       TSO
         SPACE 3                                                    TSO
LINSEND  DS    0H                                                   TSO
         SR    R2,R2              CLEAR FOR ICM                     TSO
         ICM   R2,3,LINTEXTL      GET LENGTH OF TEXT                TSO
         LA    R3,LINTXTAR(R2)    POINT PAST END OF TEXT            TSO
         TM    LINFLAGS,LINDOT    IS DOT REQUESTED.                 TSO
         BZ    LINWRITE           NO, WRITE AS IS                   TSO
         MVI   0(R3),C'.'         PUT IN DOT                        TSO
         LA    R2,1(,R2)          BUMP COUNT                        TSO
LINWRITE WRTERM LINTXTAR,(R2)     WRITE MESSAGE TO TERMINAL         TSO
         SPACE 1                                                    TSO
         RET   ,                                                    TSO
         EJECT                                                      TSO
LMOVTXT  MVC   LINTXTAR(*-*),LINTEXT                                TSO
LIMVSUB  MVC   0(*-*,R8),0(R4)                                      TSO
LIH4MOV  MVC   1(*-*,R14),LIHEX8W1                                  TSO
LIDECMV  MVC   0(*-*,R8),0(R1)                                      TSO
LICHMOV  MVC   0(*-*,R8),0(R9)                                      TSO
         SPACE 2                                                    TSO
LINTXTAR DC    CL132' '           TEXT STRING WORKAREA              TSO
LINSUBAR DC    A(0)               ADDRESS OF START OF SUBST AREA    TSO
LINSUBLN DC    H'0'               LENGTH OF SUBSTITUTION AREA       TSO
         DC    H'0'               RESERVED                          TSO
LINSUBVL DC    F'0'               SUBSTITUTION VALUE IF IN R0       TSO
LIHEX4WA DC    F'0'               4 BYTE WORK AREA                  TSO
LIHEX8W1 DC    D'0'               8 BYTE WORK AREA                  TSO
LIHEX8W2 DC    D'0'               8 BYTE WORK AREA                  TSO
LIHEX8W3 DC    D'0'               8 BYTE WORK AREA                  TSO
LIEDPAT  DC    X'40202020202020202020202020202120'                  TSO
LINTRTBL EQU   *-C'0'             ADJUST TR TABLE BACK              TSO
         DC    C'0123456789ABCDEF'  TRANSLATE TABLE                 TSO
         EXIT                                                       TSO
         TITLE '(FULLSCR) Write data in fullscreen mode'            TSO
*        This routine writes a message in full-screen mode to a     TSO
*        3270 type device.  A message and length plus the row       TSO
*        and column where the message is to be placed on the screen TSO
*        is passed in a parm list.                                  TSO
*                                                                   TSO
*        On entry:                                                  TSO
*          R1 -> parameter list consisting of the following:        TSO
*            A(message)                                             TSO
*            A(message-length)                                      TSO
*            AL2(row-value)                                         TSO
*            AL2(column-value)                                      TSO
*            C'message to be displayed'  (when a literal)           TSO
         SPACE 3                                                    TSO
FULLSCR  ENTER ,                                                    TSO
         LR    R4,R1              PRESERVE PARM LIST ADDRESS        TSO
         MVI   FSMSGBF,C' '       FILL THE BUFFER                   TSO
         MVC   FSMSGBF+1(L'FSMSGBF-1),FSMSGBF  WITH BLANKS          TSO
         L     R2,0(,R4)          GET MESSAGE ADDRESS               TSO
         L     R3,4(,R4)          GET MESSAGE LENGTH                TSO
         BCTR  R3,0                                                 TSO
         EX    R3,FSMVMSG         PUT MESSAGE IN BUFFER             TSO
*FSMVMSG MVC   FSMSGBF(*-*),0(R2)                                   TSO
         LH    R1,8(,R4)          GET ROW VALUE                     TSO
         LH    R2,10(,R4)         GET COLUMN VALUE                  TSO
         L     R15,=A(RCTO3270)   GET ADDRESS OF CONVERSION ROUTINE TSO
         BALR  R14,R15            GO CONVERT ROW-COLUMN VALUE       TSO
         STCM  R1,3,FSSBA+1       FILL IN SBA ORDER                 TSO
         LA    R0,FSSPECLN        GET LENGTH OF FULLSCREEN WRITE    TSO
         TPUT  FSSPEC,(0),FULLSCR WRITE MESSAGE                     TSO
         RET   ,                                                    TSO
         SPACE 1                                                    TSO
FSMVMSG  MVC   FSMSGBF(*-*),0(R2)                                   TSO
         SPACE 1                                                    TSO
FSSPEC   DC    X'C2'              WCC                               TSO
FSSBA    DC    X'110000'          SBA: to be filled in              TSO
         DC    X'1D',X'C9'        SF: unprotected; intense; MDT     TSO
FSMSGBF  DC    CL132' '           MESSAGE BUFFER                    TSO
FSSPECLN EQU   *-FSSPEC                                             TSO
         EXIT                                                       TSO
         TITLE '(CLRSCR) CLEAR SCREEN OF A FULL-SCREEN TERMINAL'    TSO
*        This routine clears the screen of a full-screen terminal.  TSO
*        It enters full-screen mode, sends an SBA sequence to       TSO
*        clear the screen and then gets out of full-screen mode.    TSO
*                                                                   SEB
*        ON ENTRY:                                                  SEB
*           R0 CONTAINS:  0 - TURN FSMODE OFF AT EXIT               SEB
*                         1 - LEAVE FSMODE ON AT EXIT               SEB
*           R1 CONTAINS:  0 - IF NULL FILL IS TO BE USED            SEB
*                         1 - IF BLANK FILL IS TO BE USED           SEB
         SPACE 3                                                    TSO
CLRSCR   ENTER ,                                                    TSO
         LR    R4,R0              PRESERVE FSMODE CODE              SEB
         LR    R5,R1              PRESERVE FILL CHARACTER CODE      SEB
         TM    S1FLAGS,ISS1       IS THIS A FULL-SCREEN TERMINAL?   TSO
         BNO   CLRRET             NO, JUST RETURN                   TSO
         STFSMODE ON,INITIAL=YES  GET INTO FULL-SCREEN MODE         TSO
         B     *+4(R5)            BRANCH ON FILL CHARACTER CODE     SEB
         B     CLRNLFIL           0 - FILL WITH NULLS               SEB
         B     CLRSPFIL           4 - FILL WITH BLANKS              SEB
         SPACE 1                                                    SEB
CLRNLFIL LA    R1,CLRNULL         GET ADDRESS OF NULL SPEC          SEB
         LA    R0,CLRNULLL        GET LENGTH OF NULL SPEC           SEB
         B     CLRCLEAR           GO CLEAR SCREEN WITH NULLS        SEB
         SPACE 1                                                    SEB
CLRSPFIL LA    R1,CLRBLNK         GET ADDRESS OF BLANK SPEC         SEB
         LA    R0,CLRBLNKL        GET LENGTH OF BLANK SPEC          SEB
         SPACE 1                                                    SEB
CLRCLEAR TPUT  (1),(0),FULLSCR    CLEAR THE SCREEN                  SEB
         B     *+4(R4)            BRANCH ON FSMODE CODE             SEB
         B     CLRFSOFF           0 - TURN OFF FSMODE               SEB
         B     CLRRET             4 - LEAVE FSMODE ON               SEB
         SPACE 1                                                    SEB
CLRFSOFF STFSMODE OFF                                               SEB
CLRRET   RET   ,                                                    TSO
CLRBLNK  DC    X'C2'              WCC                               SEB
         DC    X'114040',X'3C404040'  CLEAR SCREEN WITH BLANKS      SEB
CLRBLNKL EQU   *-CLRBLNK          LENGTH OF CLEAR SCREEN            SEB
         SPACE 1                                                    SEB
CLRNULL  DC    X'C2'              WCC                               SEB
         DC    X'114040',X'3C404000'  CLEAR SCREEN WITH NULLS       SEB
CLRNULLL EQU   *-CLRNULL          LENGTH OF CLEAR SCREEN            SEB
         EXIT  ,                                                    TSO
         TITLE '(RCTO3270) Convert row-column to 3270 address'      TSO
*        This routine converts a row-column value passed to it      TSO
*        into a 3270 address.                                       TSO
*                                                                   TSO
*        On Entry:                                                  TSO
*          R1 contains the row value                                TSO
*          R2 contains the column value                             TSO
*                                                                   TSO
*        On Exit:                                                   TSO
*          R1 contains a two byte 3270 address                      TSO
         SPACE 3                                                    TSO
RCTO3270 ENTER ,                                                    TSO
         TM    SRFLAGS,SRBIGSCR   BIG SCREEN TERM; ROW*COL > 4096   TSO
         BO    RCRTRN             YES, NO CONVERSION NECESSARY      TSO
         BCTR  R2,0               ADJUST COLUMN VALUE               TSO
         BCTR  R1,0               ADJUST ROW VALUE                  TSO
         MH    R1,LINESIZE+2      MULTIPLY BY TERMINAL LINE SIZE    TSO
         AR    R1,R2              GET BINARY OFFSET RELATIVE TO 0   TSO
         SLDL  R0,26              SEPARATE ADDRESS PARTS            TSO
         SRL   R1,2               PUT TWO BITS BETWEEN              TSO
         SRDL  R0,24              RECOMBINE PARTS                   TSO
         STH   R1,RCOUTADR        SAVE ADDRESS                      TSO
         TR    RCOUTADR,RCTR12    TRANSLATE TO TRUE 12 BIT FORM     TSO
         LH    R1,RCOUTADR        PASS IT BACK                      TSO
RCRTRN   RET   (2,12)                                               TSO
         SPACE 1                                                    TSO
RCOUTADR DC    H'0'               3270 12 BIT ADDRESS               TSO
RCTR12   DC    X'40C1C2C3C4C5C6C7C8C94A4B4C4D4E4F'                  TSO
         DC    X'50D1D2D3D4D5D6D7D8D95A5B5C5D5E5F'                  TSO
         DC    X'6061E2E3E4E5E6E7E8E96A6B6C6D6E6F'                  TSO
         DC    X'F0F1F2F3F4F5F6F7F8F97A7B7C7D7E7F'                  TSO
         EXIT                                                       TSO
         TITLE '(PUTCRSR) Place the 3270 cursor in a row/column'    TSO
*        This routine places the cursor of a 3270 like device       TSO
*        in a specific row and column position.                     TSO
*                                                                   TSO
*        On entry:                                                  TSO
*          R1 -> parameter list consisting of the following:        TSO
*            AL2(row-value)                                         TSO
*            AL2(column-value)                                      TSO
         SPACE 3                                                    TSO
PUTCRSR  ENTER ,                                                    TSO
         LH    R2,2(,R1)          GET COLUMN VALUE                  TSO
         LH    R1,0(,R1)          GET ROW VALUE                     TSO
         L     R15,=A(RCTO3270)   GET ADDRESS OF CONVERSION ROUTINE TSO
         BALR  R14,R15            GO CONVERT ROW-COLUMN VALUE       TSO
         STCM  R1,3,CSRSBA+1      FILL IN SBA ORDER                 TSO
         LA    R0,CSRLEN          GET LENGTH OF FULL-SCREEN WRITE   TSO
         TPUT  CSRPOSIT,(0),FULLSCR  POSITION CURSOR                TSO
         RET   ,                                                    TSO
         SPACE 1                                                    TSO
*        SBA ORDER TO SET CURSOR                                    TSO
         SPACE 1                                                    TSO
CSRPOSIT DC    X'C2'              WCC                               TSO
CSRSBA   DC    X'110000'          SBA: to be filled in              TSO
         DC    X'1DC1'            SF: UNPROTECTED; MDT              TSO
         DC    X'13'              IC (INSERT CURSOR)                TSO
CSRLEN   EQU   *-CSRPOSIT                                           TSO
         EXIT
         TITLE '(BLOCKLET) Display block letters on the terminal'   TSO
*        This routine displays up to 8 characters consisting of     TSO
*        the alphabetics and numerics in block letters.  The string TSO
*        of characters is passed to the routine in R1.  Its length  TSO
*        is in r0.                                                  TSO
*                                                                   TSO
*        On Entry:                                                  TSO
*          R0 contains length of string pointed to in R1            TSO
*          R1 -> string to be blocked                               TSO
*                                                                   TSO
*          On exit:                                                 TSO
*            R1 contains the number of the next available output    TSO
*               line on the screen.                                 TSO
           SPACE 3                                                  TSO
BLOCKLET ENTER ,                                                    TSO
         SPACE 1                                                    TSO
*        CHECK THE FLAG TO SEE IF BLOCK LETTERS ARE DESIRED.  IF    TSO
*        THEY AREN'T THEN CENTER THE MESSAGE IN THE MIDDLE OF THE   TSO
*        SCREEN PRINT THE MESSAGE AND RETURN.                       TSO
         SPACE 1                                                    TSO
         TM    SRFLAGS,SRBLOCK    ARE BLOCK LETTERS DESIRED?        TSO
         BO    BLKGO              YES                               TSO
         MVC   BLKOUTBF,BLANKS    CLEAR BUFFER TO BLANKS            TSO
         LR    R5,R0              GET WORKING COPY OF LENGTH        TSO
         LA    R7,22(,R5)         SPACE NEEDED FOR MESSAGE          TSO
         L     R4,LINESIZE        TERMINAL LINE LENGTH              TSO
         SR    R4,R7              LENGTH OF UNUSED SPACE            TSO
         BP    BLKCNTR            IF LESS THAN LINESIZE CENTER IT   TSO
         L     R5,LINESIZE        USE TERMINAL LINESIZE FOR LENGTH  TSO
         BCTR  R5,0               ADJUST FOR ATTRIBUTE CHARACTER    TSO
         BCTR  R5,0               ADJUST FOR EX                     TSO
         EX    R5,BLKMVSG         MOVE IN SINGLE LINE               TSO
*BLKMVSG MVC   BLKOUTBF(*-*),0(R1)                                  TSO
         B     BLKSNDSG           GO SET UP THE BUFFER              TSO
         SPACE 1                                                    TSO
BLKCNTR  SRA   R4,1               DIVIDE BY 2 FOR AMOUNT BUF SHIFT  TSO
         LA    R6,BLKOUTBF(R4)    POINT TO PLACE TO PUT LINE MSG    TSO
         MVC   0(10,R6),BLKASTRK  PRECEED MESSAGE WITH "*"S         TSO
         BCTR  R5,0               ADJUST FOR EX                     TSO
         EX    R5,BLKMVMS         PUT IN MESSAGE                    TSO
*BLKMVMS MVC   11(*-*,R6),0(R1)                                     TSO
         LA    R6,13(R5,R6)       POINT TO PLACE TO PUT "*"S        TSO
         MVC   0(10,R6),BLKASTRK  FOLLOW MESSAGE WITH "*"S          TSO
BLKSNDSG LA    R0,BLKLINLN        GET LENGTH TO DISPLAY             TSO
         TPUT  BLKCMD,(0),FULLSCR DISPLAY MESSAGE                   TSO
         LA    R1,2               POINT TO NEXT BLANK SCREEN LINE   TSO
         B     BLKRTRN            GO RETURN                         TSO
         SPACE 3                                                    TSO
*        CHECK TO SEE THAT STRING WHEN EXPRESSED IN BLOCK LETTERS   TSO
*        WILL FIT ON THE SCREEN.  IF NOT DON'T DISPLAY THE STRING.  TSO
         SPACE 1                                                    TSO
BLKGO    L     R5,LINESIZE        GET LINE SIZE                     TSO
         SR    R4,R4              SET UP FOR DIVIDE                 TSO
         D     R4,=F'10'          DIVIDE BY WIDTH OF A BLOCK LETTER TSO
         CR    R0,R5              IS STRING TOO LONG?               TSO
         BH    BLKRTRN            YES, DON'T DO ANYTHING            TSO
         SPACE 1                                                    TSO
*        CLEAR THE BLOCK LETTER BUFFERS AND INITIALIZE THEM WITH    TSO
*        THE SBA ORDERS.                                            TSO
         SPACE 1                                                    TSO
         LA    R2,BLKOUTBF        GET ADDRESS OF AREA TO CLEAR      TSO
         LA    R3,BLKBUFLN        GET LENGTH TO CLEAR               TSO
         LR    R14,R2             MAKE 2ND OPERAND SAME AS 1ST      TSO
         SR    R15,R15            CLEAR TO ZEROS                    TSO
         MVCL  R2,R14             CLEAR ALL THE BUFFERS             TSO
         SPACE 2                                                    TSO
         MVC   BLKOUTB2(3),BLKR2C1  SBA ORDERS FOR R2,C1            TSO
         MVC   BLKOUTB3(3),BLKR3C1  SBA ORDERS FOR R3,C1            TSO
         MVC   BLKOUTB4(3),BLKR4C1  SBA ORDERS FOR R4,C1            TSO
         MVC   BLKOUTB5(3),BLKR5C1  SBA ORDERS FOR R5,C1            TSO
         MVC   BLKOUTB6(3),BLKR6C1  SBA ORDERS FOR R6,C1            TSO
         MVC   BLKOUTB7(3),BLKR7C1  SBA ORDERS FOR R7,C1            TSO
         MVC   BLKOUTB8(3),BLKR8C1  SBA ORDERS FOR R8,C1            TSO
         MVC   BLKOUTB9(3),BLKR9C1  SBA ORDERS FOR R9,C1            TSO
         MVC   BLKOUT10(3),BLKR10C1 SBA ORDERS FOR R10,C1           TSO
         SPACE 1                                                    TSO
*        CENTER THE BLOCK ON THE SCREEN                             TSO
         SPACE 1                                                    TSO
         LR    R5,R0              GET WORKING COPY OF LENGTH        TSO
         MH    R5,=H'10'          SPACE NEEDED FOR BLOCK LETTERS    TSO
         L     R4,LINESIZE        TERMINAL LINE LENGTH              TSO
         SR    R4,R5              LENGTH OF UNUSED SPACE            TSO
         SRA   R4,1               DIVIDE BY 2 FOR AMOUNT BUF SHIFT  TSO
         LA    R5,BLKOUTBF(R4)    PLACE TO START BLOCK LETTERS      TSO
         LA    R6,BLKOUTB2+4(R4)  PLACE TO START BLOCK LETTERS      TSO
         STM   R5,R6,BLKOBFPT     SET UP BUFFER POINTERS            TSO
         SPACE 1                                                    TSO
*        LOCATE THE BLOCK LETTER THAT CORRESPONDS TO THE LETTER     TSO
*        POINTED TO BY R1.                                          TSO
         SPACE 1                                                    TSO
         LR    R5,R0              SAVE LENGTH OF STRING             TSO
BLKLOOP1 SR    R2,R2              CLEAR FOR TRT                     TSO
         TRT   0(1,R1),BLKTABLE   GET POSITION OF CHARACTER         TSO
         MH    R2,=H'100'         POINT TO CHARACTER WITHIN TABLE   TSO
         LA    R4,BLKLETRS(R2)    POINT TO SPECIFIC CHARACTER       TSO
         SPACE 1                                                    TSO
*        PUT BLOCK LETTERS INTO BUFFER                              TSO
         SPACE 1                                                    TSO
         LM    R6,R7,BLKOBFPT     GET ADDRESS OF OUTPUT BUFFERS     TSO
         LR    R9,R7              GET WORKING BUFFER POINTER        TSO
         MVC   0(10,R6),0(R4)     PUT IN CONTENTS OF CHARACTER LINE TSO
         LA    R8,9               SET UP TO FILL OTHER NINE BUFFERS TSO
BLKCHLOP LA    R4,10(,R4)         POINT TO NEXT LINE OF BLK CHAR    TSO
         MVC   0(10,R9),0(R4)     PUT IN CONTENTS OF CHARACTER LINE TSO
         LA    R9,135(,R9)        POINT TO NEXT OUTPUT BUFFER       TSO
         BCT   R8,BLKCHLOP        FILL ALL BUFFERS FOR THIS CHAR    TSO
         LA    R1,1(,R1)          POINT TO NEXT CHARACTER TO BLOCK  TSO
         LA    R6,10(,R6)         POINT TO NEXT BUFFER POSITION     TSO
         LA    R7,10(,R7)         POINT TO NEXT BUFFER POSITION     TSO
         STM   R6,R7,BLKOBFPT     SAVE NEW ADDRESSES OF OUTPUT BUFS TSO
         BCT   R5,BLKLOOP1        CONTINUE TO PROCESS CHARACTERS    TSO
         SPACE 1                                                    TSO
*        DISPLAY BLOCK LETTERS ON THE TERMINAL                      TSO
         SPACE 1                                                    TSO
         LA    0,BLKCMDLN                                           TSO
         TPUT  BLKCMD,(0),FULLSCR                                   TSO
         LA    R1,11              NEXT AVAILABLE OUTPUT LINE        TSO
BLKRTRN  RET   (2,12)                                               TSO
         SPACE 1                                                    TSO
BLKMVMS  MVC   11(*-*,R6),0(R1)                                     TSO
BLKMVSG  MVC   BLKOUTBF(*-*),0(R1)                                  TSO
         SPACE 1                                                    TSO
BLKASTRK DC    C'**********'      ASTERISKS FOR ENCLOSING LINE MSG  TSO
BLKOBFPT DC    A(BLKOUTBF)                                          TSO
BLKOBFP2 DC    A(BLKOUTBF+83)                                       TSO
BLKTABLE DC    256X'00'               TABLE USED FOR TRT            TSO
         ORG   BLKTABLE+C' '          POSITION FOR BLANK            TSO
         DC    AL1(0)                                               TSO
         ORG   BLKTABLE+C'a'                                        TSO
         DC    X'010203040506070809'                                TSO
         ORG   BLKTABLE+C'j'                                        TSO
         DC    X'0A0B0C0D0E0F101112'                                TSO
         ORG   BLKTABLE+C's'                                        TSO
         DC    X'131415161718191A'                                  TSO
         ORG   BLKTABLE+C'A'                                        TSO
         DC    X'010203040506070809'                                TSO
         ORG   BLKTABLE+C'J'                                        TSO
         DC    X'0A0B0C0D0E0F101112'                                TSO
         ORG   BLKTABLE+C'S'                                        TSO
         DC    X'131415161718191A'                                  TSO
         ORG   BLKTABLE+C'1'                                        TSO
         DC    X'1B1C1D1E1F2021222324'                              TSO
         ORG   ,                                                    TSO
         SPACE 1                                                    TSO
*        STORAGE AND DEFINITION OF OUTPUT BUFFERS                   TSO
         SPACE 1                                                    TSO
BLKCMD   DC    X'7A'              WCC                               TSO
         DC    X'114040',X'3C404040'  CLEAR SCREEN                  TSO
BLKL1C1  DC    X'114040'          SBA: R1C1                         TSO
         DC    X'1D',X'C9'        SF: unprotected; intense; MDT     TSO
BLKOUTBF DC    CL132' '                                             TSO
BLKLINLN EQU   *-BLKCMD           LENGTH FOR SINGLE LINE DISPLAY    TSO
BLKOUTB2 DC    CL135' '                                             TSO
BLKOUTB3 DC    CL135' '                                             TSO
BLKOUTB4 DC    CL135' '                                             TSO
BLKOUTB5 DC    CL135' '                                             TSO
BLKOUTB6 DC    CL135' '                                             TSO
BLKOUTB7 DC    CL135' '                                             TSO
BLKOUTB8 DC    CL135' '                                             TSO
BLKOUTB9 DC    CL135' '                                             TSO
BLKOUT10 DC    CL135' '                                             TSO
BLKBUFLN EQU   *-BLKOUTBF         LENGTH OF BLOCK LETTER BUFFERS    TSO
BLKCMDLN EQU   *-BLKCMD           LENGTH OF BLOCK DISPLAY           TSO
         SPACE 1                                                    TSO
*        SBA ORDERS FOR OUTPUT BUFFERS 2 THROUGH 10                 TSO
         SPACE 1                                                    TSO
BLKR2C1  DC    X'11C150'          SBA: R2C1                         TSO
BLKR3C1  DC    X'11C260'          SBA: R3C1                         TSO
BLKR4C1  DC    X'11C3F0'          SBA: R4C1                         TSO
BLKR5C1  DC    X'11C540'          SBA: R5C1                         TSO
BLKR6C1  DC    X'11C650'          SBA: R6C1                         TSO
BLKR7C1  DC    X'11C760'          SBA: R7C1                         TSO
BLKR8C1  DC    X'11C8F0'          SBA: R8C1                         TSO
BLKR9C1  DC    X'114A40'          SBA: R9C1                         TSO
BLKR10C1 DC    X'114B50'          SBA: R10C1                        TSO
         SPACE 1                                                    TSO
         EXIT  ,                                                    TSO
BLKLETRS DS 0C                                                      TSO
BLKSPACE DC C'          '                                           TSO
         DC C'          '                                           TSO
         DC C'          '                                           TSO
         DC C'          '                                           TSO
         DC C'          '                                           TSO
         DC C'          '                                           TSO
         DC C'          '                                           TSO
         DC C'          '                                           TSO
         DC C'          '                                           TSO
         DC C'          '                                           TSO
*                                                                   TSO
BLKA     DC C'   ***    '                                           TSO
         DC C'  *****   '                                           TSO
         DC C' **   **  '                                           TSO
         DC C'**     ** '                                           TSO
         DC C'**     ** '                                           TSO
         DC C'********* '                                           TSO
         DC C'********* '                                           TSO
         DC C'**     ** '                                           TSO
         DC C'**     ** '                                           TSO
         DC C'**     ** '                                           TSO
*                                                                   TSO
BLKB     DC C'********  '                                           TSO
         DC C'********* '                                           TSO
         DC C'**     ** '                                           TSO
         DC C'**     ** '                                           TSO
         DC C'********  '                                           TSO
         DC C'********  '                                           TSO
         DC C'**     ** '                                           TSO
         DC C'**     ** '                                           TSO
         DC C'********* '                                           TSO
         DC C'********  '                                           TSO
*                                                                   TSO
BLKC     DC C' *******  '                                           TSO
         DC C'********* '                                           TSO
         DC C'**     ** '                                           TSO
         DC C'**        '                                           TSO
         DC C'**        '                                           TSO
         DC C'**        '                                           TSO
         DC C'**        '                                           TSO
         DC C'**     ** '                                           TSO
         DC C'********* '                                           TSO
         DC C' *******  '                                           TSO
*                                                                   TSO
BLKD     DC C'********  '                                           TSO
         DC C'********* '                                           TSO
         DC C'**     ** '                                           TSO
         DC C'**     ** '                                           TSO
         DC C'**     ** '                                           TSO
         DC C'**     ** '                                           TSO
         DC C'**     ** '                                           TSO
         DC C'**     ** '                                           TSO
         DC C'********* '                                           TSO
         DC C'********  '                                           TSO
*                                                                   TSO
BLKE     DC C'********* '                                           TSO
         DC C'********* '                                           TSO
         DC C'**        '                                           TSO
         DC C'**        '                                           TSO
         DC C'******    '                                           TSO
         DC C'******    '                                           TSO
         DC C'**        '                                           TSO
         DC C'**        '                                           TSO
         DC C'********* '                                           TSO
         DC C'********* '                                           TSO
*                                                                   TSO
BLKF     DC C'********* '                                           TSO
         DC C'********* '                                           TSO
         DC C'**        '                                           TSO
         DC C'**        '                                           TSO
         DC C'******    '                                           TSO
         DC C'******    '                                           TSO
         DC C'**        '                                           TSO
         DC C'**        '                                           TSO
         DC C'**        '                                           TSO
         DC C'**        '                                           TSO
*                                                                   TSO
BLKG     DC C' *******  '                                           TSO
         DC C'********* '                                           TSO
         DC C'**     ** '                                           TSO
         DC C'**        '                                           TSO
         DC C'**        '                                           TSO
         DC C'**   **** '                                           TSO
         DC C'**   **** '                                           TSO
         DC C'**     ** '                                           TSO
         DC C'********* '                                           TSO
         DC C' *******  '                                           TSO
*                                                                   TSO
BLKH     DC C'**     ** '                                           TSO
         DC C'**     ** '                                           TSO
         DC C'**     ** '                                           TSO
         DC C'**     ** '                                           TSO
         DC C'********* '                                           TSO
         DC C'********* '                                           TSO
         DC C'**     ** '                                           TSO
         DC C'**     ** '                                           TSO
         DC C'**     ** '                                           TSO
         DC C'**     ** '                                           TSO
*                                                                   TSO
BLKI     DC C' ******   '                                           TSO
         DC C' ******   '                                           TSO
         DC C'   **     '                                           TSO
         DC C'   **     '                                           TSO
         DC C'   **     '                                           TSO
         DC C'   **     '                                           TSO
         DC C'   **     '                                           TSO
         DC C'   **     '                                           TSO
         DC C' ******   '                                           TSO
         DC C' ******   '                                           TSO
*                                                                   TSO
BLKJ     DC C'       ** '                                           TSO
         DC C'       ** '                                           TSO
         DC C'       ** '                                           TSO
         DC C'       ** '                                           TSO
         DC C'       ** '                                           TSO
         DC C'       ** '                                           TSO
         DC C'       ** '                                           TSO
         DC C'**     ** '                                           TSO
         DC C'********* '                                           TSO
         DC C' *******  '                                           TSO
*                                                                   TSO
BLKK     DC C'**     ** '                                           TSO
         DC C'**    **  '                                           TSO
         DC C'**   **   '                                           TSO
         DC C'**  **    '                                           TSO
         DC C'****      '                                           TSO
         DC C'****      '                                           TSO
         DC C'**  **    '                                           TSO
         DC C'**   **   '                                           TSO
         DC C'**    **  '                                           TSO
         DC C'**     ** '                                           TSO
*                                                                   TSO
BLKL     DC C'**        '                                           TSO
         DC C'**        '                                           TSO
         DC C'**        '                                           TSO
         DC C'**        '                                           TSO
         DC C'**        '                                           TSO
         DC C'**        '                                           TSO
         DC C'**        '                                           TSO
         DC C'**        '                                           TSO
         DC C'********* '                                           TSO
         DC C'********* '                                           TSO
*                                                                   TSO
BLKM     DC C'*       * '                                           TSO
         DC C'**     ** '                                           TSO
         DC C'***   *** '                                           TSO
         DC C'**** **** '                                           TSO
         DC C'** *** ** '                                           TSO
         DC C'**  *  ** '                                           TSO
         DC C'**     ** '                                           TSO
         DC C'**     ** '                                           TSO
         DC C'**     ** '                                           TSO
         DC C'**     ** '                                           TSO
*                                                                   TSO
BLKN     DC C'*      ** '                                           TSO
         DC C'**     ** '                                           TSO
         DC C'***    ** '                                           TSO
         DC C'****   ** '                                           TSO
         DC C'** **  ** '                                           TSO
         DC C'**  ** ** '                                           TSO
         DC C'**   **** '                                           TSO
         DC C'**    *** '                                           TSO
         DC C'**     ** '                                           TSO
         DC C'**      * '                                           TSO
*                                                                   TSO
BLKO     DC C' *******  '                                           TSO
         DC C'********* '                                           TSO
         DC C'**     ** '                                           TSO
         DC C'**     ** '                                           TSO
         DC C'**     ** '                                           TSO
         DC C'**     ** '                                           TSO
         DC C'**     ** '                                           TSO
         DC C'**     ** '                                           TSO
         DC C'********* '                                           TSO
         DC C' *******  '                                           TSO
*                                                                   TSO
BLKP     DC C'********  '                                           TSO
         DC C'********* '                                           TSO
         DC C'**     ** '                                           TSO
         DC C'**     ** '                                           TSO
         DC C'********* '                                           TSO
         DC C'********  '                                           TSO
         DC C'**        '                                           TSO
         DC C'**        '                                           TSO
         DC C'**        '                                           TSO
         DC C'**        '                                           TSO
*                                                                   TSO
BLKQ     DC C' *******  '                                           TSO
         DC C'********* '                                           TSO
         DC C'**     ** '                                           TSO
         DC C'**     ** '                                           TSO
         DC C'**     ** '                                           TSO
         DC C'**     ** '                                           TSO
         DC C'**  *  ** '                                           TSO
         DC C'**   **** '                                           TSO
         DC C'********  '                                           TSO
         DC C' ****** * '                                           TSO
*                                                                   TSO
BLKR     DC C'********  '                                           TSO
         DC C'********* '                                           TSO
         DC C'**     ** '                                           TSO
         DC C'**     ** '                                           TSO
         DC C'********* '                                           TSO
         DC C'********  '                                           TSO
         DC C'**  **    '                                           TSO
         DC C'**   **   '                                           TSO
         DC C'**    **  '                                           TSO
         DC C'**     ** '                                           TSO
*                                                                   TSO
BLKS     DC C' *******  '                                           TSO
         DC C'********* '                                           TSO
         DC C'**     ** '                                           TSO
         DC C'**        '                                           TSO
         DC C'********  '                                           TSO
         DC C' ******** '                                           TSO
         DC C'       ** '                                           TSO
         DC C'**     ** '                                           TSO
         DC C'********* '                                           TSO
         DC C' *******  '                                           TSO
*                                                                   TSO
BLKT     DC C'********  '                                           TSO
         DC C'********  '                                           TSO
         DC C'   **     '                                           TSO
         DC C'   **     '                                           TSO
         DC C'   **     '                                           TSO
         DC C'   **     '                                           TSO
         DC C'   **     '                                           TSO
         DC C'   **     '                                           TSO
         DC C'   **     '                                           TSO
         DC C'   **     '                                           TSO
*                                                                   TSO
BLKU     DC C'**     ** '                                           TSO
         DC C'**     ** '                                           TSO
         DC C'**     ** '                                           TSO
         DC C'**     ** '                                           TSO
         DC C'**     ** '                                           TSO
         DC C'**     ** '                                           TSO
         DC C'**     ** '                                           TSO
         DC C'**     ** '                                           TSO
         DC C'********* '                                           TSO
         DC C' *******  '                                           TSO
*                                                                   TSO
BLKV     DC C'**     ** '                                           TSO
         DC C'**     ** '                                           TSO
         DC C'**     ** '                                           TSO
         DC C'**     ** '                                           TSO
         DC C'**     ** '                                           TSO
         DC C'**     ** '                                           TSO
         DC C' **   **  '                                           TSO
         DC C'  ** **   '                                           TSO
         DC C'   ***    '                                           TSO
         DC C'    *     '                                           TSO
*                                                                   TSO
BLKW     DC C'**     ** '                                           TSO
         DC C'**     ** '                                           TSO
         DC C'**     ** '                                           TSO
         DC C'**     ** '                                           TSO
         DC C'**     ** '                                           TSO
         DC C'**     ** '                                           TSO
         DC C'**  *  ** '                                           TSO
         DC C'** *** ** '                                           TSO
         DC C' *** ***  '                                           TSO
         DC C'  *   *   '                                           TSO
*                                                                   TSO
BLKX     DC C'**     ** '                                           TSO
         DC C'**     ** '                                           TSO
         DC C' **   **  '                                           TSO
         DC C'  ** **   '                                           TSO
         DC C'   ***    '                                           TSO
         DC C'   ***    '                                           TSO
         DC C'  ** **   '                                           TSO
         DC C' **   **  '                                           TSO
         DC C'**     ** '                                           TSO
         DC C'**     ** '                                           TSO
*                                                                   TSO
BLKY     DC C'**    **  '                                           TSO
         DC C'**    **  '                                           TSO
         DC C'**    **  '                                           TSO
         DC C' **  **   '                                           TSO
         DC C'  ****    '                                           TSO
         DC C'   **     '                                           TSO
         DC C'   **     '                                           TSO
         DC C'   **     '                                           TSO
         DC C'   **     '                                           TSO
         DC C'   **     '                                           TSO
*                                                                   TSO
BLKZ     DC C'********* '                                           TSO
         DC C'********* '                                           TSO
         DC C'      **  '                                           TSO
         DC C'     **   '                                           TSO
         DC C'    **    '                                           TSO
         DC C'   **     '                                           TSO
         DC C'  **      '                                           TSO
         DC C' **       '                                           TSO
         DC C'********* '                                           TSO
         DC C'********* '                                           TSO
*                                                                   TSO
BLK1     DC C'     *    '                                           TSO
         DC C'    **    '                                           TSO
         DC C'   ***    '                                           TSO
         DC C'    **    '                                           TSO
         DC C'    **    '                                           TSO
         DC C'    **    '                                           TSO
         DC C'    **    '                                           TSO
         DC C'    **    '                                           TSO
         DC C'  ******  '                                           TSO
         DC C'  ******  '                                           TSO
*                                                                   TSO
BLK2     DC C' *******  '                                           TSO
         DC C'********* '                                           TSO
         DC C'**     ** '                                           TSO
         DC C'      **  '                                           TSO
         DC C'     **   '                                           TSO
         DC C'    **    '                                           TSO
         DC C'   **     '                                           TSO
         DC C'  **      '                                           TSO
         DC C' ******** '                                           TSO
         DC C'********* '                                           TSO
*                                                                   TSO
BLK3     DC C'********* '                                           TSO
         DC C'********* '                                           TSO
         DC C'**    **  '                                           TSO
         DC C'     **   '                                           TSO
         DC C'    ****  '                                           TSO
         DC C'   ****** '                                           TSO
         DC C'       ** '                                           TSO
         DC C'**     ** '                                           TSO
         DC C'********* '                                           TSO
         DC C' *******  '                                           TSO
*                                                                   TSO
BLK4     DC C'      *   '                                           TSO
         DC C'     **   '                                           TSO
         DC C'    ***   '                                           TSO
         DC C'   ****   '                                           TSO
         DC C'  ** **   '                                           TSO
         DC C' **  **   '                                           TSO
         DC C'********* '                                           TSO
         DC C'********* '                                           TSO
         DC C'     **   '                                           TSO
         DC C'     **   '                                           TSO
*                                                                   TSO
BLK5     DC C'********* '                                           TSO
         DC C'********* '                                           TSO
         DC C'**        '                                           TSO
         DC C'********  '                                           TSO
         DC C' ******** '                                           TSO
         DC C'       ** '                                           TSO
         DC C'       ** '                                           TSO
         DC C'**     ** '                                           TSO
         DC C'********* '                                           TSO
         DC C' *******  '                                           TSO
*                                                                   TSO
BLK6     DC C' *******  '                                           TSO
         DC C'********* '                                           TSO
         DC C'**     ** '                                           TSO
         DC C'**        '                                           TSO
         DC C'********  '                                           TSO
         DC C'********* '                                           TSO
         DC C'**     ** '                                           TSO
         DC C'**     ** '                                           TSO
         DC C'********* '                                           TSO
         DC C' *******  '                                           TSO
*                                                                   TSO
BLK7     DC C'********* '                                           TSO
         DC C'********* '                                           TSO
         DC C'**    **  '                                           TSO
         DC C'     **   '                                           TSO
         DC C'    **    '                                           TSO
         DC C'   **     '                                           TSO
         DC C'  **      '                                           TSO
         DC C'  **      '                                           TSO
         DC C'  **      '                                           TSO
         DC C'  **      '                                           TSO
*                                                                   TSO
BLK8     DC C' *******  '                                           TSO
         DC C'********* '                                           TSO
         DC C'**     ** '                                           TSO
         DC C'**     ** '                                           TSO
         DC C' *******  '                                           TSO
         DC C' *******  '                                           TSO
         DC C'**     ** '                                           TSO
         DC C'**     ** '                                           TSO
         DC C'********* '                                           TSO
         DC C' *******  '                                           TSO
*                                                                   TSO
BLK9     DC C' *******  '                                           TSO
         DC C'********* '                                           TSO
         DC C'**     ** '                                           TSO
         DC C'**     ** '                                           TSO
         DC C'********* '                                           TSO
         DC C' ******** '                                           TSO
         DC C'       ** '                                           TSO
         DC C'**     ** '                                           TSO
         DC C'********* '                                           TSO
         DC C' *******  '                                           TSO
*                                                                   TSO
BLK0     DC C'  *****   '                                           TSO
         DC C' *******  '                                           TSO
         DC C'**     ** '                                           TSO
         DC C'**     ** '                                           TSO
         DC C'**     ** '                                           TSO
         DC C'**     ** '                                           TSO
         DC C'**     ** '                                           TSO
         DC C'**     ** '                                           TSO
         DC C' *******  '                                           TSO
         DC C'  *****   '                                           TSO
         SPACE 3                                                    TSO
         END
