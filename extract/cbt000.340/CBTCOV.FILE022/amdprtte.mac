AMDPRTTE TITLE 'AMDAHL AMDPRDMP TRACE TABLE ENTRY FORMATTER.'
         MACRO
         REGISTER
         LCLA  &N
.LOOP    ANOP
R&N      EQU   &N
&N       SETA  &N+1
         AIF   (&N LE 15).LOOP
         MEND
         SPACE 1
         MACRO
&L       PRINTBUF &TEXT
         LCLC  &L2
&L2      SETC  '&L'
         AIF   ('&TEXT' EQ '').NOMOVE
&L2      L     R15,ADPLBUF         GET BUFFER ADDRESS.
         MVC   0(121,R15),BLANKS   BLANK OUT PREVIOUS JUNK.
         MVC   0(L'&TEXT,R15),&TEXT MOVE ITEM TO BUF'R.
&L2      SETC  ''
.NOMOVE  ANOP
&L2      LA    R1,ABDPL            ADDRESS PARAMETER LIST.
         L     R15,ADPLPRNT        EXTRACT PRINT ROUTINE ADDR.
         BALR  R14,R15             BRANCH TO PRINT SUBROUTINE.
         MEND
         SPACE 1
         MACRO
&L       FORMAT &PATTERN,&BADRC=
&L       LA    R0,&PATTERN         ADDRESS FORMAT PATTERN.
         LA    R1,ABDPL            ADDRESS PARAMETER LIST.
         L     R15,ADPLFRMT        EXTRACT FORMAT ROUTINE ADDR.
         BALR  R14,R15             BRANCH TO FORMAT SUBROUTINE.
         AIF   ('&BADRC' EQ '').NORC
         LTR   R15,R15             TEST RETURN CODE.
         BNZ   &BADRC              NON-ZERO, TAKE ABNORMAL EXIT.
.NORC    ANOP
         MEND
         SPACE 1
         MACRO
&LABEL   LOAD  &RESULT,&INPUT,&BADRC=
&LABEL   LA    R0,&INPUT           ADDRESS INPUT WITH REGISTER 0.
         LA    R1,ABDPL            ADDRESS PARAMETER LIST.
         L     R15,ADPLMEMA        LOAD ADDR OF MEMORY ROUTINE.
         BALR  R14,R15             BRANCH TO MEMORY SERVICE ROUTINE.
         LTR   R15,R15             MEMORY AVAILABLE?
         BNZ   &BADRC              NO, WE CAN'T CONTINUE.
         LR    R1,R0               LOAD RESULT POINTER INTO R1.
         ICM   &RESULT,B'1111',0(R1) LOAD AND TEST ACQUIRED STORAGE.
         MEND
         SPACE 1
         PRINT OFF
         MACRO
         AMDTTE &LIST=NO,&DSECT=NO
         PUSH  PRINT
         AIF   ('&LIST' EQ 'YES').LIST
         PRINT OFF
         AGO   .DOIT
.LIST    ANOP
         PRINT ON,GEN
.DOIT    ANOP
**********************************************************************
*                                                                    *
*                      TRACE TABLE ENTRY                             *
*                                                                    *
*     THERE IS NO STANDARD MAPPING MACRO AVAILABLE FOR THE MVS/1.3   *
*     TRACE TABLE ENTRY.  THIS ENTRY WAS DEVELOPED FOR DOCUMENTA-    *
*     PURPOSES ONLY.                                                 *
*                                                                    *
*     THE TRACE TABLE IS LOCATED VIA THE TRACE TABLE DESIGNATOR      *
*     (TTD) AT REAL MEMORY LOCATION X'54'.  IN MVS TERMINOLOGY,      *
*     THIS IS PSA+X'54' OR "FLCTRACE".  THIS POINTER POINTS TO A     *
*     LOGICAL ADDRESS WHICH IS DOUBLE WORD ALIGNED.  THIS FIELD      *
*     CONTAINS THE TRACE-TABLE-ENTRY HEADER - THREE WORDS CONTAIN-   *
*     ING THE ADDRESS OF THE CURRENT, THE FIRST AND LOCATION AFTER   *
*     THE LAST TRACE TABLE ENTRIES.                                  *
*                                                                    *
*     IF THE POINTER AT REAL LOCATION X'54' IS ZERO, TRACING IS NOT  *
*     YET ACTIVE.  IF BIT ZERO OF LOCATION X'54' IS OFF, THEN DUAL   *
*     ADDRESS SPACE (DAS) TRACING IS NOT ACTIVE, OTHERWISE DAS       *
*     TRACING IS ACTIVE.  DAS TRACING REFERS ONLY TO TRACE ENTRY     *
*     TYPES "9", "A" AND "B" WHICH ARE TRACED VIA HARDWARE.          *
*                                                                    *
*     REAL           +----------+                                    *
*     LOCATION  ---  × FLCTRACE ×                                    *
*     84 (X'54')     +----------+                                    *
*                         ×                                          *
*                         ×                                          *
*                         ×     +----------+----------+----------+   *
*                         --->  × CURRENT  × START    × END      ×   *
*                               +----------+----------+----------+   *
*                                                                    *
*     EACH TRACE TABLE ENTRY IS 32 BYTES LONG AND ALIGNED TO A 32    *
*     BYTE BOUNDARY.  THERE ARE TWELVE DIFFERENT TYPES OF ENTRIES    *
*     WHICH ARE IDENTIFIED BY BITS 16-19 OF THE ENTRY.  EACH ENTRY   *
*     SHOWN BELOW IS MAPPED SEPARATELY ACCORDING TO ITS TYPE IN      *
*     BITS 16-19 AS FOLLOWS:                                         *
*                                                                    *
*          0  -  START I/O (OR START I/O FAST RELEASE)               *
*          1  -  EXTERNAL INTERRUPTION                               *
*          2  -  SUPERVISOR CALL INTERRUPTION                        *
*          3  -  PROGRAM INTERRUPTION                                *
*          4  -  INITIAL SERVICE REQUEST DISPATCH                    *
*          5  -  INPUT / OUTPUT INTERRUPTION                         *
*          6  -  SUSPENDED SERVICE REQUEST REDISPATCH                *
*          7  -  TASK DISPATCH                                       *
*          8  -  SUPERVISOR CALL RETURN                              *
*          9  -  PROGRAM CALL        *** DAS ***                     *
*          A  -  PROGRAM TRANSFER    *** DAS ***                     *
*          B  -  SET SECONDARY ASID  *** DAS ***                     *
*                                                                    *
**********************************************************************
         SPACE 2
         AIF   ('&DSECT' EQ 'YES').DODSECT
TTE      DS    0F             TRACE TABLE ENTRY
         AGO   .MAPEM
.DODSECT ANOP
TTE      DSECT ,              TRACE TABLE ENTRY
.MAPEM   ANOP
         EJECT
**********************************************************************
*                                                                    *
*                         START I/O ENTRY                            *
*                                                                    *
**********************************************************************
         SPACE 1
         ORG   TTE
SIOCC    DS    X              CONDITION CODE FROM START I/O
SIOCH    DS    X              BITS 0-3 ARE RESERVED,
*                             BITS 4-7 ARE THE SIO CHANNEL ADDRESS
*                             ABOVE 16 CHANNELS.
SIOFLAG  DS    X              BITS 0-3 ARE THE SIO ENTRY FLAG (0).
*                             BITS 4-7 ARE THE SIO CHANNEL ADDRESS
*                             BELOW 16 CHANNELS.
SIODEV   DS    X              SIO CONTROL UNIT AND DEVICE ADDRESS.
SIOCAW   DS    A              CONTENTS OF THE CHANNEL ADDRESS WORD.
SIOCSW   DS    D              CHANNEL STATUS WORD.  NOTE - THIS FIELD
*                             IS ONLY VALID IF THE SIOCC FIELD IS
*                             NON-ZERO.
SIOIOSB  DS    A              I/O SUPERVISOR BLOCK ADDRESS FROM IOS.
SIOILC   DS    X              INSTR. LENGTH / COND. CODE / PGM. MASK
SIOCSID  DS    0X             BITS 0-3 CONTAIN CHANNEL SET ID.
SIOCPUID DS    X              BITS 4-7 CONTAIN PHYSICAL CPU ID.
SIOASID  DS    H              ADDRESS SPACE IDENTIFIER.
SIOTCB   DS    A              ADDRESS OF TCB FROM SRB.
SIOTIMER DS    F              BYTES 3-6 OF THE TOD CLOCK
         EJECT
**********************************************************************
*                                                                    *
*                   EXTERNAL INTERRUPTION ENTRY                      *
*                                                                    *
**********************************************************************
         SPACE 1
         ORG   TTE
EXTOPSW0 DS    2X             FIRST TWO BYTES OF EXTERNAL OLD PSW.
EXTFLAG  DS    X              BITS 0-3 ARE THE EXTERNAL FLAG (1).
*                             BITS 4-7 ARE THE HIGH ORDER INTERRUPT
*                             CODE.
EXTCODE  DS    X              BYTE TWO OF INTERRUPT CODE AS FOLLOWS:
INTTIMER EQU   X'80'           - INTERVAL TIMER.
INTRPKEY EQU   X'40'           - INTERRUPT KEY.
EXTRSGNL EQU   X'3F'           - EXTERNAL SIGNALS.
MALALERT EQU   X'00'           - IN CONJUNCTION WITH BYTE 1, BIT 6 ON
*                                MEANS MALFUNCTION ALERT.
EMERSGNL EQU   X'01'           - IN CONJUNCTION WITH BYTE 1, BIT 6 ON
*                                MEANS EMERGENCY SIGNAL.
EXTRCALL EQU   X'02'           - IN CONJUNCTION WITH BYTE 1, BIT 6 ON
*                                MEANS EXTERNAL CALL.
TODSYNC  EQU   X'03'           - TIME OF DAY CLOCK SYNCHRONIZATION.
CLKCOMPR EQU   X'04'           - CLOCK COMPARATOR.
CPUTIMER EQU   X'05'           - CPU TIMER.
EXTOPSW4 DS    F              SECOND HALF OF EXTERNAL OLD PSW.
EXTEMSI  DS    F              FOR EMERGENCY SIGNAL, PCCAEMSI.
*                             OTHERWISE, PSW S-BIT, PASID AND SASID.
EXTEMSP  DS    F              FOR EMERGENCY SIGNAL, PCCAEMSP.
*                             FOR EXTERNAL CALL, PCCARBP.
*                             OTHERWISE, REGISTER ZERO CONTENTS.
EXTEMSE  DS    F              CONTENTS OF REGISTER 1 AT INTERRUPTION.
*                             FOR EXTERNAL CALL, PSASPAD.
*                             OTHERWISE, REGISTER ONE CONTENTS.
EXTILC   DS    X              INSTR. LENGTH / COND. CODE / PROG. MASK.
EXTCPUID DS    X              CPU IDENTIFIER (PHYSICAL).
EXTASID  DS    H              ADDRESS SPACE IDENTIFIER.
EXTTCB   DS    A              CURRENT (OR TIMER QUEUE ELEMENT) TCB.
EXTTIMER DS    A              BYTES 3-6 OF THE TIME-OF-DAY CLOCK.
         EJECT
**********************************************************************
*                                                                    *
*                     SUPERVISOR CALL ENTRY                          *
*                                                                    *
**********************************************************************
         SPACE 1
         ORG   TTE
SVCOPSW0 DS    2X             FIRST TWO BYTES OF SUPERVISOR OLD PSW.
SVCFLAG  DS    X              BITS 0-3 ARE THE SVC FLAG (2).
*                             BITS 4-7 ARE BITS 20-23 OF THE SVC
*                             OLD PSW.
SVCCODE  DS    X              SUPERVISOR CALL INTERRUPTION CODE.
SVCOPSW4 DS    F              SECOND HALF OF THE SUPERVISOR OLD PSW.
*                              + IF ADDRESS IS X'FFFFFFFF', THIS IS
*                              + AN SVC ERROR ENTRY (MARKED + BELOW).
SVCGPR15 DS    0F             CONTENTS OF REGISTER 15 AT INTERRUPTION.
SVCPASID DS    H               + BIT  0    - PSW S-BIT.
*                              + BITS 1-15 - PRIMARY ASID.
SVCSASID DS    H               + SECONDARY ASID.
SVCGPR0  DS    0F             CONTENTS OF REGISTER 0 AT INTERRUPTION.
SVCHLHI  DS    F               + PSAHLHI CONTENTS (HIGHEST LOCK HELD)
SVCGPR1  DS    0F             CONTENTS OF REGISTER 1 AT INTERRUPTION.
SVCMODEW DS    F               + PSAMODEW CONTENTS (SYSTEM MODE WORD)
SVCILC   DS    X              INSTR. LENGTH / COND. CODE / PGM. MASK.
SVCCPUID DS    X              CPU IDENTIFIER (PHYSICAL).
SVCASID  DS    H              ADDRESS SPACE IDENTIFIER.
SVCTCB   DS    A              CURRENT TCB ADDRESS.
SVCTIMER DS    A              BYTES 3-6 OF THE TIME-OF-DAY CLOCK.
         EJECT
**********************************************************************
*                                                                    *
*                     PROGRAM CHECK ENTRY                            *
*                                                                    *
**********************************************************************
         SPACE 1
         ORG   TTE
PGMOPSW0 DS    2X             FIRST TWO BYTES OF PROGRAM OLD PSW.
PGMFLAG  DS    X              BITS 0-3 ARE THE PROGRAM FLAG (3).
*                             BITS 4-7 ARE THE RESPECTIVE BITS OF THE
*                             PROGRAM INTERRUPTION CODE
PGMCODE  DS    X              BITS 8-15 OF THE PROGRAM INTERRUPT CODE.
PGMOPSW4 DS    F              SECOND HALF OF THE PROGRAM OLD PSW.
PGMPASID DS    H              BIT  0    - PSW S-BIT.
*                             BITS 1-15 - PRIMARY ADDRESS SPACE ID.
PGMSASID DS    H              SECONDARY ADDRESS SPACE IDENTIFIER.
PGMTRANS DS    F              TRANSLATION EXCEPTION ADDRESS.
PGMGPR1  DS    F              CONTENTS OF REGISTER 1 AT INTERRUPTION.
PGMILC   DS    X              INSTR. LENGTH / COND. CODE / PGM. MASK.
PGMCPUID DS    X              CPU IDENTIFIER (PHYSICAL).
PGMASID  DS    H              ADDRESS SPACE IDENTIFIER.
PGMTCB   DS    A              CURRENT TCB ADDRESS.
PGMTIMER DS    A              BYTES 3-6 OF THE TIME-OF-DAY CLOCK.
         EJECT
**********************************************************************
*                                                                    *
*               INITIAL SERVICE REQUEST DISPATCH                     *
*                                                                    *
**********************************************************************
         SPACE 1
         ORG   TTE
ISDNPSW0 DS    2X             FIRST TWO BYTES NEW PSW.
ISDFLAG  DS    X              BITS 0-3 ARE THE SRB FLAG (4).
*                             BITS 4-7 ARE BITS 20-23 OF THE NEW
*                             PROGRAM STATUS WORD.
ISDNPSW4 DS    5X             REMAINDER OF THE PROGRAM NEW PSW.
         DS    H              *** RESERVED - CONTAINS ZEROS ***
ISDNASID DS    H              PURGE ADDRESS SPACE ID.
ISDGPR0  DS    F              CONTENTS OF REGISTER 0 (SRB ADDRESS).
ISDGPR1  DS    F              CONTENTS OF REGISTER 1 (PARM LIST ADDR.).
         DS    X              ZERO.
ISDCPUID DS    X              CPU IDENTIFIER (PHYSICAL).
ISDASID  DS    H              ADDRESS SPACE IDENTIFIER OF ADDRESS SPACE
*                             WHICH CREATED THE SERVICE REQUEST BLOCK.
ISDPTCBA DS    A              PURGE TCB ADDRESS.
ISDTIMER DS    A              BYTES 3-6 OF THE TIME-OF-DAY CLOCK.
         EJECT
**********************************************************************
*                                                                    *
*                 INPUT / OUTPUT INTERRUPT ENTRY                     *
*                                                                    *
**********************************************************************
         SPACE 1
         ORG   TTE
IOOPSW0  DS    X              FIRST BYTE OF I/O OLD PSW.
IOCH     DS    X              BITS 0-3 ARE BITS 8-11 OF I/O OLD PSW.
*                             BITS 4-7 ARE THE INTERRUPTING ADDRESS
*                             ABOVE 16 CHANNELS.
IOFLAG   DS    X              BITS 0-3 ARE THE IO ENTRY FLAG (5).
*                             BITS 4-7 ARE THE INTERRUPTING ADDRESS
*                             BELOW 16 CHANNELS.
IODEV    DS    X              INTERRUPTING CTL. UNIT AND DEVICE.
IOOPSW4  DS    F              REMAINDER OF THE I/O OLD PSW.
IOCSW    DS    D              CONTENTS OF THE CHANNEL STATUS WORD.
         DS    A              *** RESERVED ***
IOILC    DS    X              INSTR. LENGTH / COND. CODE / PGM. MASK.
IOCSID   DS    0X             BITS 0-3 - CHANNEL SET ID.  ZEROS IF NO
*                                        CHANNEL SET SWITCHING AVAIL.
IOCPUID  DS    X              BITS 4-7 - PHYSICAL CPU ID.
IOASID   DS    H              ADDRESS SPACE IDENTIFIER.
IOTCB    DS    A              ADDRESS OF CURRENT TCB.
IOTIMER  DS    F              BYTES 3-6 OF THE TOD CLOCK
         EJECT
**********************************************************************
*                                                                    *
*               SUSPENDED SERVICE REQUEST REDISPATCH                 *
*                                                                    *
**********************************************************************
         SPACE 1
         ORG   TTE
SSRNPSW0 DS    2X             FIRST TWO BYTES NEW PSW.
SSRFLAG  DS    X              BITS 0-3 ARE THE SRB FLAG (6).
*                             BITS 4-7 ARE BITS 20-23 OF THE NEW
*                             PROGRAM STATUS WORD.
SSRNPSW4 DS    5X             REMAINDER OF THE PROGRAM NEW PSW.
SSRPASID DS    H              BIT  0    - PSW S-BIT.
*                             BITS 1-15 - PRIMARY ASID.
SSRSASID DS    H              SECONDARY ASID.
         DS    H              ZEROS.
SSRPURAS DS    H              PURGE ASID.
SSRGPR1  DS    F              CONTENTS OF REGISTER 1 OR PARM LIST ADDR.
SSRILC   DS    X              INSTR. LENGTH / COND. CODE / PGM. MASK.
SSRCPUID DS    X              CPU IDENTIFIER (PHYSICAL).
SSRASID  DS    H              CURRENT ADDRESS SPACE IDENTIFIER.
SSRPTCB  DS    A              PURGE TCB ADDRESS.
SSRTIMER DS    A              BYTES 3-6 OF THE TIME-OF-DAY CLOCK.
         EJECT
**********************************************************************
*                                                                    *
*                     TASK DISPATCH ENTRY                            *
*                                                                    *
**********************************************************************
         SPACE 1
         ORG   TTE
DSPNPSW0 DS    2X             FIRST TWO BYTES OF NEW PSW.
DSPFLAG  DS    X              BITS 0-3 ARE THE DISPATCH FLAG (7).
*                             BITS 4-7 ARE BITS 20-23 OF THE NEW PSW.
DSPNPSW3 DS    5X             REMAINDER OF THE NEW PSW.
DSPPASID DS    H              BIT  0    - PSW S-BIT.
*                             BITS 1-15 - PRIMARY ASID.
DSPSASID DS    H              SECONDARY ASID.
DSPGPR0  DS    F              NEW CONTENTS OF REGISTER 0.
DSPGPR1  DS    F              NEW CONTENTS OF REGISTER 1.
DSPILC   DS    X              INSTR. LENGTH / COND. CODE / PGM. MASK.
DSPCPUID DS    X              CPU IDENTIFIER (PHYSICAL).
DSPASID  DS    H              ADDRESS SPACE IDENTIFIER.
DSPTCB   DS    A              NEW TCB ADDRESS.
DSPTIMER DS    A              BYTES 3-6 OF THE TIME-OF-DAY CLOCK.
         EJECT
**********************************************************************
*                                                                    *
*                    SUPERVISOR RETURN ENTRY                         *
*                                                                    *
**********************************************************************
         SPACE 1
         ORG   TTE
RETNPSW0 DS    2X             FIRST TWO BYTES OF NEW PSW.
RETFLAG  DS    X              BITS 0-3 ARE THE SVC FLAG (8).
*                             BITS 4-7 ARE BITS 20-23 OF THE SVC
*                             OLD PSW.
RETCODE  DS    X              SUPERVISOR CALL INTERRUPTION CODE.
RETNPSW4 DS    F              SECOND HALF OF THE NEW PSW.
RETGPR15 DS    F              CONTENTS OF REGISTER 15 (NEW).
RETGPR0  DS    F              CONTENTS OF REGISTER 0 (NEW).
RETGPR1  DS    F              CONTENTS OF REGISTER 1 (NEW).
RETILC   DS    X              INSTR. LENGTH / COND. CODE / PGM. MASK.
RETCPUID DS    X              CPU IDENTIFIER (PHYSICAL).
RETASID  DS    H              ADDRESS SPACE IDENTIFIER.
RETTCB   DS    A              INTERRUPTED TCB ADDRESS.
RETTIMER DS    A              BYTES 3-6 OF THE TIME-OF-DAY CLOCK.
         EJECT
**********************************************************************
*                                                                    *
*                      PROGRAM CALL ENTRY                            *
*                                                                    *
**********************************************************************
         SPACE 1
         ORG   TTE
PCNPSW0  DS    2X             FIRST TWO BYTES OF NEW PSW.
PCFLAG   DS    X              BITS 0-3 ARE THE PC FLAG (9).
*                             BITS 4-7 ARE BITS 20-23 OF THE PSW.
PCNPSW3  DS    XL5            SECOND HALF OF THE NEW PSW.
PCPASID  DS    H              NEW PRIMARY ASID.
PCSASID  DS    H              NEW SECONDARY ASID.
PCGPR14  DS    F              REGISTER 14 CONTENTS (NEW).
         DS    F              ZEROS.
PCILC    DS    X              INSTR. LENGTH / COND. CODE / PGM. MASK
PCCPUID  DS    X              CPU IDENTIFIER (PHYSICAL).
         DS    H              ZEROES.
PCNUM    DS    F              PC NUMBER.
PCTIMER  DS    A              BYTES 3-6 OF THE TIME-OF-DAY CLOCK.
         EJECT
**********************************************************************
*                                                                    *
*                     PROGRAM TRANSFER ENTRY                         *
*                                                                    *
**********************************************************************
         SPACE 1
         ORG   TTE
PTNPSW0  DS    2X             FIRST TWO BYTES OF NEW PSW.
PTFLAG   DS    X              BITS 0-3 ARE THE PT FLAG (A).
*                             BITS 4-7 ARE BITS 20-23 OF THE PSW.
PTNPSW3  DS    XL5            SECOND HALF OF THE NEW PSW.
PTPASID  DS    H              NEW PRIMARY ASID.
         DS    H              ZEROS.
PTOASID  DS    H              OLD PRIMARY ASID.
         DS    3H             ZEROS.
PTILC    DS    X              INSTR. LENGTH / COND. CODE / PGM. MASK
PTCPUID  DS    X              CPU IDENTIFIER (PHYSICAL).
         DS    3H             ZEROES.
PTTIMER  DS    A              BYTES 3-6 OF THE TIME-OF-DAY CLOCK.
         EJECT
**********************************************************************
*                                                                    *
*              SET SECONDARY ADDRESS SPACE IDENTIFIER                *
*                                                                    *
**********************************************************************
         SPACE 1
         ORG   TTE
SSANPSW0 DS    2X             FIRST TWO BYTES OF NEW PSW.
SSAFLAG  DS    X              BITS 0-3 ARE THE SSAR FLAG (B).
*                             BITS 4-7 ARE BITS 20-23 OF THE PSW.
SSANPSW3 DS    XL5            SECOND HALF OF THE NEW OLD PSW.
SSAPASID DS    H              NEW PRIMARY ASID.
SSASASID DS    H              NEW SECONDARY ASID.
         DS    H              ZEROS.
SSAOASID DS    H              OLD SECONDARY ASID.
         DS    F              ZEROS.
SSAILC   DS    X              INSTR. LENGTH / COND. CODE / PGM. MASK
SSACPUID DS    X              CPU IDENTIFIER (PHYSICAL).
         DS    3H             ZEROES.
SSATIMER DS    A              BYTES 3-6 OF THE TIME-OF-DAY CLOCK.
         EJECT
         POP   PRINT
         MEND
         PRINT ON,GEN,NODATA
         SPACE 1
*** NOW THAT YOU'VE SEEN THE MACROS, WE'LL SAVE SOME PAPER.
         EJECT
***********************************************************************
*                                                                     *
*                         AMDPRTTE                                    *
*                                                                     *
*     THIS PROGRAM IS DESIGNED TO EXECUTE AS A USER EXIT TO THE       *
*     MVS AMDPRDMP SERVICE AID.  ITS FUNCTION IS TO FORMAT THE        *
*     MVS TRACE TABLE ENTRIES PRODUCED BY  MVS SYSTEM AND THE DAS     *
*     HARDWARE.  THE PROGRAM IS EXECUTED WHENEVER THE "PRTTE"         *
*     CONTROL CARD IS ENCOUNTERED IN THE AMDPRDMP SYSIN FILE.  IN     *
*     ORDER TO RECOGNIZE THIS CONTROL CARD, A USER ENTRY MUST BE      *
*     MADE IN THE AMDPRECT USER EXIT MODULE.  APPENDIX "C" OF THE     *
*     "OS/VS2 S.P.L.:  SERVICE AIDS" MANUAL DESCRIBED HOW TO PERFORM  *
*     THIS FUNCTION.                                                  *
*                                                                     *
*     AT THE START, THIS EXIT USES THE CVT POINTER IN THE ABDUMP      *
*     PARAMETER LIST TO ACCESS THE CST.  THIS IS USED TO SCAN THE     *
*     SCD'S.  THE SOLE FUNCTION OF THIS EXERCISE IS TO PICK UP        *
*     A RECENT SYSTEM TIME STAMP SO THAT THE TTE CLOCK VALUE CAN      *
*     BE FORMATTED ACCURATELY.                                        *
*                                                                     *
*     NEXT, SINCE THIS IS RE-ENTRANT CODE, THE AMDPRDMP PATTERN       *
*     ARE RELOCATED IN GETMAINED MEMORY.  THE TRACE TABLE VECTOR      *
*     POINTER AND THE TRACE TABLE VECTORS ARE THEN EXTRACTED.         *
*                                                                     *
*     THEN EACH TRACE TABLE ENTRY IS FORMATTED.  FIRST, A COMMON      *
*     LINE IS PRINTED WITH THE TRACE TABLE TYPES AND INFORMATION      *
*     COMMON TO EACH ENTRY IS PRINTED.  NEXT THE LINE INFORMATION     *
*     WHICH IS UNIQUE TO EACH TRACE ENTRY IS FORMATTED AND IT IS      *
*     FOLLOWED BY A BLANK LINE.                                       *
*                                                                     *
*     OPTIONAL OPERANDS:                                              *
*                                                                     *
*          LIMIT=ASIDNNN - THE OUTPUT IS TO BE LIMITED TO THE SEL-    *
*                          ECTED ADDRESS SPACE (ASID NNN).  IF THIS   *
*                          OPERAND IS OMITTED, ENTRIES FROM ALL THE   *
*                          ADDRESS SPACES WILL BE FORMATTED.          *
*                                                                     *
*          RTM2WA=TCBNNA - THE COPIED TRACE TABLE FROM AN RTM2WA IS   *
*                          TO BE FORMATTED RATHER THAN THE SYSTEM     *
*                          TRACE TABLE ANCHORED IN LOCATION X'54'.    *
*                          THE TCB SPECIFICATION IS IN IPCS SYMBOL    *
*                          FORMAT - NUMERIC ASID FOLLOWED BY ALPHA-   *
*                          BETIC TCB INDEX (E.G., TCB80F IS THE       *
*                          SIXTH TCB IN ASID 80).                     *
*                                                                     *
*          OPERANDS ARE OPTIONAL AND MUST BE SEPARATED BY A COMMA.    *
*          A TRAILING BLANK TERMINATES THE OPERANDS.                  *
*                                                                     *
*     THIS PROGRAM FOLLOWS ALL CONVENTIONS SPECIFIED IN THE ABOVE     *
*     MENTIONED MANUAL.  IT IS REENTRANT AND MAY BE PLACED IN LPA     *
*     TO IMPROVE PERFORMANCE (IF YOU'RE HAVING TO FORMAT TRACE        *
*     TABLES OFTEN).  OR, IT MAY BE PLACED IN LINKLIB OF A USER'S     *
*     STEP LIBRARY.                                                   *
*                                                                     *
***********************************************************************
         SPACE 2
         REGISTER
         EJECT
***********************************************************************
*                                                                     *
*        PERFORM O/S HOUSEKEEPING - ACQUIRE AND CLEAR USER AREA.      *
*                                                                     *
***********************************************************************
         SPACE 1
AMDPRTTE CSECT ,                   ESTABLISH PROGRAM ENTRY POINT.
         SAVE  (14,12),,AMDPRTTE_V03M00_&SYSDATE_&SYSTIME_COPYRIGHT_198*
               5_AMDAHL_CORP_SE_TOOLS_SETT010_AMDIPCSE
         LR    R12,R15             LOAD PROGRAM BASE.
         USING AMDPRTTE,R12        MAKE CODE ADDRESSABLE.
         LR    R10,R1              PRESERVE PARAMETER REGISTER.
         USING ABDPL,R10           MAKE PARAMETER DSECT ADDRESSABLE.
         LA    R0,$LENGTH          GET LENGTH OF REENTRANT DSECT.
         ICM   R0,8,ADPLSBPL       INSERT PRDMP SUPPLIED SUBPOOL.
         GETMAIN R,LV=(0)          GETMAIN REENTRANT AREA.
         LR    R2,R1               LOAD ADDRESS IN EVEN REGISTER.
         LA    R3,$LENGTH          GET LENGTH TO ZERO.
         XR    R5,R5               SET FILL CHARACTER.
         MVCL  R2,R4               ZERO THE REENTRANT AREA.
         LR    R11,R1              LOAD REENTRANT BASE REGISTER.
         USING $DSECT,R11          MAKE AREA ADDRESSABLE.
         ST    R13,$SAVE+4         FORWARD CHAIN SAVE AREAS.
         LR    R2,R13              HOLD OLD SAVE ADDRESS.
         LA    R13,$SAVE           ADDRESS NEW SAVE AREA.
         ST    R13,8(,R2)          BACK CHAIN SAVE AREAS.
         SPACE 1
         ICM   R2,B'1111',ADPLCVT  LOAD DUMP'S CVT ADDRESS.
         BZ    BADCVT              NONE SUPPLIED, CAN'T CONTINUE.
         LOAD  R3,CVTDCB(,R2),BADRC=BADCVT GET LOGREC-DCB POINTER.
         BP    NOTXA               HIGH BIT OFF, IT'S NOT AN XA-DUMP.
         PRINTBUF XAMSG1           TELL USER:  ENVIRONMENT ERROR.
         PRINTBUF XAMSG2           TELL USER:  AMDPRDMP - USE TRACE.
         PRINTBUF XAMSG3           TELL USER:  IPCS - USE IEAVETFC.
         PRINTBUF ,                BLANK LINE.
         B     RETURN              AND QUIT.
         SPACE 1
NOTXA    DS    0H
         LOAD  R3,CVTFQCB(,R2),BADRC=BADCVT GET FIRST QCB POINTER.
         BZ    SP3SYS              ON MVS/SP 1.3, SHOULD BE ZERO.
         PRINTBUF SP3MSG1          TELL USER:  ENVIRONMENT ERROR.
         PRINTBUF SP3MSG2          TELL USER:  WATCH OUT!
         PRINTBUF ,                BLANK LINE
         SPACE 1
SP3SYS   DS    0H
         L     R15,ADPLBUF         GET ADDRESS OF OUTPUT BUFFER.
         MVC   0(121,R15),BLANKS   CLEAR THE OUTPUT BUFFER.
         MVC   0(L'TITLE,R15),TITLE MOVE IN THE TITLE TEXT.
         L     R14,ADPLEXT         GET EXTENSION POINTER.
         ICM   R2,B'1111',0(R14)   WAS THERE AN EXTENSION?
         BZ    PRINTITL            NOPE, JUST PRINT THE TITLE.
         LR    R1,R2               PRESERVE POINTER TO TEXT.
BLNKLOOP DS    0H
         LA    R2,1(,R2)           POINT AT NEXT CHARACTER.
         CLC   0(4,R2),BLANKS      TRAILING BLANKS?
         BNE   BLNKLOOP            NOPE, KEEP ON LOOKING.
         SR    R2,R1               COMPUTE LENGTH.
         MVC   L'TITLE(L'OPMSG,R15),OPMSG  MOVE IN OPERANDS MSG.
         LA    R15,L'TITLE+L'OPMSG(,R15) POINT AT AVAILABLE SPACE.
         EX    R2,MVC1             MOVE DATA INTO OUTPUT LINE.
PRINTITL DS    0H
         PRINTBUF ,                OUTPUT THE TITLE LINE.
         PRINTBUF ,                AND A BLANK LINE.
         EJECT
***********************************************************************
*                                                                     *
*     GET THE MOST RECENT I/O INTERRUPT CLOCK VALUE.                  *
*                                                                     *
***********************************************************************
         SPACE 1
         ICM   R2,B'1111',ADPLCVT GET THE DUMP'S CVT ADDRESS
         BZ    BADCVT         ABEND IF IT'S ZERO.
         LOAD  R2,CVTCST(,R2),BADRC=BADCVT GET THE CST POINTER.
         BZ    BADCST         ABEND IF IT'S ZERO.
         LOAD  R2,CSTSCDP(,R2),BADRC=BADCST GET THE 1ST SCD PTR.
         BZ    BADSCD         ERROR IF ZERO.
         LA    R3,16          LOAD SCD COUNTER.
SCDLOOP  DS    0H
         LOAD  R4,SCDTIME(,R2),BADRC=BADSCD GET CLOCK VALUE.
         BZ    NEXTSCD        SKIP IT IF IT'S ZERO.
         CL    R4,$STCK       GREATER THAN PREVIOUS HIGH?
         BL    NEXTSCD        NO, SKIP IT.
         ST    R4,$STCK       SAVE THE NEW CLOCK VALUE.
NEXTSCD  DS    0H
         LA    R2,16(,R2)     INCREMENT SCD POINTER.
         BCT   R3,SCDLOOP     CHECK EACH SCD.
         SPACE 3
***********************************************************************
*                                                                     *
*     RELOCATE THE VARIABLE FORMAT PATTERNS IN GETMAINED MEMORY.      *
*                                                                     *
***********************************************************************
         SPACE 1
RELOCATE DS    0H
         L     R1,=A(PATTERNS) ADDRESS SKELATON FORMAT PATTERNS.
         LA    R2,4           LOAD BXLE INDEX VALUE (1 PATTERN ENTRY).
         LA    R3,LPATTERN-1(,R1) POINT AT LAST ENTRY.
         LA    R4,$PATX       ADDRESS DSECT PATTERNS.
RLCLOOP  DS    0H
         ICM   R5,B'1111',0(R1) LOAD PATTERN ENTRY.
         BZ    NEXTRLC        ZERO MEANS LEAVE IT ALONE.
         CLM   R5,B'1100',=H'0' RELOCATABLE?
         BNE   NEXTRLC        NO, DON'T MESS WITH IT.
         LA    R5,$DSECT(R5)  OFFSET INTO GETMAINED MEMORY.
NEXTRLC  DS    0H
         ST    R5,0(,R4)      SAVE VALUE IN DSECT.
         AR    R4,R2          UPDATE OUTPUT POINTER.
         BXLE  R1,R2,RLCLOOP  LOOP THROUGH FOR ALL ENTRIES.
         EJECT
***********************************************************************
*                                                                     *
*        SCAN THE OPERAND BUFFER FOR OPERANDS.                        *
*                                                                     *
***********************************************************************
         SPACE 1
         L     R14,ADPLEXT         GET THE PARM. LIST EXTENSION ADDR.
         ICM   R9,B'1111',0(R14)   IS AN OPERAND POINTER AVAILABLE?
         BZ    NOOPERND            NOPE, USE DEFAULTS.
         SPACE 1
         LR    R1,R9               COPY POINTER TO GPR 1.
SCANLOOP DS    0H
         XR    R2,R2               ZONK FUNCTION BYTE REGISTER.
         LA    R3,79(,R9)          POINT PAST END OF OPERANDS.
         SR    R3,R1               COMPUTE RESIDUAL LENGTH.
         EX    R3,TRT1             LOOKING FOR ALPHABETIC.
         BZ    SYNTAXER            NOTHING FOUND, SYNTAX ERROR.
         B     *(R2)               BRANCH ACCORDING TO FUNCTION BYTE.
         B     ENDOPS               4 - BLANK.
         B     DELIMERR             8 - COMMA.
         B     SYNTAXER            12 - NUMERIC.
         CLC   0(10,R1),=C'RTM2WA=TCB'  USE RTM2WA TRACE TABLE?
         BE    RTM2WA              YES, GO EXTRACT TCB NUMBER.
         CLC   0(10,R1),=C'LIMIT=ASID'  LIMIT ASID DISPLAY?
         BE    LIMIT               YES, GO EXTRACT ASID NUMBER.
         L     R14,ADPLEXT         GET EXTENSION POINTER.
         LA    R0,8                LOAD SECONDARY RETURN CODE.
         B     SET2ND              GO SET 2NDARY RETURN CODE.
         SPACE 1
RTM2WA   DS    0H
         LA    R1,9(,R1)           POINT AT JUST BEFORE 1ST DIGIT.
         LA    R4,1(,R1)           COPY ADDRESS TO R4 FOR LATER.
RTMLOOP1 DS    0H
         LA    R1,1(,R1)           INCREMENT BUFFER POINTER.
         LA    R3,79(,R9)          POINT PAST END OF OPERANDS.
         SR    R3,R1               COMPUTE RESIDUAL LENGTH.
         EX    R3,TRT1             LOOKING FOR ALPHABETIC.
         BZ    SYNTAXER            NOTHING FOUND, SYNTAX ERROR.
         B     *(R2)               BRANCH ACCORDING TO FUNCTION BYTE.
         B     DELIMERR             4 - BLANK (EXPECTING ALPHA).
         B     DELIMERR             8 - COMMA (EXPECTING ALPHA).
         B     RTMLOOP1            12 - NUMERIC.
         SR    R1,R4               COMPUTE CHARACTER COUNT OF ASID.
         BZ    SYNTAXER            ZERO, SYNTAX ERROR.
         CH    R1,=H'4'            MORE THAN FOUR?
         BH    ASIDERR             YES, ALSO A SYNTAX ERROR.
         BCTR  R1,0                DECREMENT FOR PACK.
         EX    R1,PACKASID         PACK THE ASID VALUE.
         CVB   R0,$DOUBLE          CONVERT TO BINARY.
         CH    R0,=H'1100'         OVER THEORETICAL MAXIMUM?
         BH    ASIDERR             YES, ISSUE ERROR MESSAGE.
         STH   R0,ADPLASID         NO, STORE ASID IN PARAMETER LIST.
         LA    R1,0(R1,R4)         POINT AT LAST NUMERIC DIGIT.
         LA    R4,1(,R1)           POINT AT FIRST ALPHA CHARACTER.
RTMLOOP2 DS    0H
         LA    R1,1(,R1)           POINT AT NEXT ALPHA. TCB INDEX.
         LA    R3,79(,R9)          POINT PAST END OF OPERANDS.
         SR    R3,R1               COMPUTE RESIDUAL LENGTH.
         EX    R3,TRT1             LOOKING FOR COMMA OR BLANK.
         BZ    SYNTAXER            NOTHING FOUND, SYNTAX ERROR.
         B     *(R2)               BRANCH ACCORDING TO FUNCTION BYTE.
         B     RTMDELIM             4 - BLANK.
         B     RTMDELIM             8 - COMMA.
         B     SYNTAXER            12 - NUMERIC.
         B     RTMLOOP2            16 - ALPHABETIC.
RTMDELIM DS    0H
         SR    R1,R4               COMPUTE LENGTH OF TCB INDEX.
         BCTR  R1,0                DECREMENT FOR COMPARE.
         CH    R1,=H'1'            WERE THERE MORE THAN TWO DIGITS?
         BH    TCBERR              YES, ISSUE MESSAGE AND QUIT.
         BL    ONEDIGIT            ONE DIGIT, SKIP NEXT BIT.
         TRT   0(1,R4),TRTABLE2    GET ALPHABETIC OFFSET.
         MH    R2,=H'26'           MULTIPLY BY #-OF-LETTERS.
         STH   R2,$TCB#            SAVE IN TCB NUMBER.
         LA    R4,1(,R4)           POINT AT SECOND DIGIT.
ONEDIGIT DS    0H
         TRT   0(1,R4),TRTABLE2    GET ALPHABETIC OFFSET.
         AH    R2,$TCB#            ADD TO TCB NUMBER.
         STH   R2,$TCB#            SAVE UPDATED VALUE.
         LA    R1,2(,R4)           POINT PAST DELIMITER.
         B     SCANLOOP            SEE IF THERE ARE OTHER OPERANDS.
         SPACE 1
LIMIT    DS    0H
         LA    R1,9(,R1)           POINT JUST BEFORE 1ST DIGIT.
         LA    R4,1(,R1)           COPY ADDRESS TO R4 FOR LATER.
LIMLOOP1 DS    0H
         LA    R1,1(,R1)           POINT AT NEXT ASID DIGIT.
         LA    R3,79(,R9)          POINT PAST END OF OPERANDS.
         SR    R3,R1               COMPUTE RESIDUAL LENGTH.
         EX    R3,TRT1             LOOKING FOR DELIMITER.
         BZ    SYNTAXER            NOTHING FOUND, SYNTAX ERROR.
         B     *(R2)               BRANCH ACCORDING TO FUNCTION BYTE.
         B     LIMDELIM             4 - BLANK.
         B     LIMDELIM             8 - COMMA.
         B     LIMLOOP1            12 - NUMERIC.
         B     SYNTAXER            16 - ALPHABETIC.
LIMDELIM DS    0H
         SR    R1,R4               COMPUTE LENGTH OF ASID.
         BZ    SYNTAXER            ZERO, SYNTAX ERROR.
         CH    R1,=H'4'            MORE THAN FOUR?
         BH    ASIDERR             YES, ALSO A SYNTAX ERROR.
         BCTR  R1,0                DECREMENT FOR PACK.
         EX    R1,PACKASID         PACK THE ASID VALUE.
         CVB   R0,$DOUBLE          CONVERT TO BINARY.
         CH    R0,=H'1100'         OVER THEORETICAL MAXIMUM?
         BH    ASIDERR             YES, ISSUE ERROR MESSAGE.
         STH   R0,$LIMIT           NO, STORE ASID IN PARAMETER LIST.
         LA    R1,2(R1,R4)         POINT AT ALPHABETIC TCB INDEX.
         B     SCANLOOP            SEE IF THERE ARE OTHER OPERANDS.
         SPACE 1
ENDOPS   DS    0H
         LH    R5,$TCB#            LOAD TCB INDEX.
         LTR   R5,R5               USING THE RTM2WA TRACE TABLE?
         BZ    NOOPERND            NOPE, USE THE SYSTEM TRACE TABLE.
         L     R2,ADPLCVT          LOAD UP THE CVT POINTER.
         LOAD  R3,CVTASVT(,R2),BADRC=BADCVT  GET THE ASVT POINTER.
         LH    R4,ADPLASID         LOAD THE ASID NUMBER.
         SLL   R4,2                MULTIPLY FOR TABLE OFFSET.
         LOAD  R3,ASVTFRST(R3,R4),BADRC=BADASVT   GET THE ASCB POINTER.
         LOAD  R3,ASCBRCTP(,R3),BADRC=BADASCB  GET THE RCT TCB POINTER.
         B     TCBBCT              SEE IF WE'VE GOT THE RIGHT ONE.
TCBLOOP  DS    0H
         LOAD  R3,TCBTCB(,R3),BADRC=BADTCB CHAIN TO NEXT TCB.
         BZ    BADTCB              POINTER WAS ZERO, ERROR.
TCBBCT   DS    0H
         BCT   R5,TCBLOOP          COUNT OFF THE SPECIFIED TCBS.
         SPACE 1
         LOAD  R2,TCBRTWA(,R3),BADRC=BADTCB  LOAD THE RTM2WA POINTER.
         BZ    NOTRACE             ZERO, THERE'S NO TABLE.
         LA    R6,RTM2TRCU         LOAD OFFSET TO TABLES.
         B     NODAS               GO LOAD THE REQUESTED VALUES.
NOOPERND DS    0H
         EJECT
***********************************************************************
*                                                                     *
*     GET THE TTE VECTOR POINTER AND LOAD UP THE TTE VECTORS.         *
*                                                                     *
***********************************************************************
         SPACE 1
         XR    R6,R6          INDEX ZERO FOR SYSTEM TRACE VECTORS.
         LOAD  R2,FLCTRACE,BADRC=BADPSA GET THE VECTOR POINTER.
         BZ    NOTRACE        ZERO, TRACING NOT ACTIVE.
         BP    NODAS          HIGH BIT OFF, NO DAS TRACING.
         PRINTBUF DASACTIV    INDICATE DAS TRACING IS ACTIVE.
         PRINTBUF ,           AND A BLANK LINE.
NODAS    DS    0H
         LOAD  R3,0(R6,R2),BADRC=BADTRVEC GET CURRENT POINTER.
         LOAD  R4,4(R6,R2),BADRC=BADTRVEC GET 1ST POINTER.
         LOAD  R5,8(R6,R2),BADRC=BADTRVEC GET LAST POINTER.
         STM   R3,R5,$TTEVEC  SAVE VALUES.
         SPACE 3
***********************************************************************
*                                                                     *
*     LOAD UP THE TRACE TABLE ENTRY.  DETERMINE ENTRY TYPE.           *
*                                                                     *
***********************************************************************
         SPACE 1
         L     R2,$TTE1ST     LOAD NEXT ENTRY TO BE DISPLAYED.
TTELOOP  DS    0H
         C     R2,$TTELAST    LAST ENTRY?
         BE    RETURN         YES, WE'RE DONE.
         LA    R3,8           INDICATE NUMBER OF WORDS TO LOAD.
         XR    R4,R4          ZERO OFFSET POINTER.
TTELOOP2 DS    0H
         LOAD  R5,0(R4,R2),BADRC=BADTTE LOAD TRACE TABLE ENTRY WORD.
         ST    R5,$TTELINE(R4) SAVE IT IN OUR MEMORY.
         LA    R4,4(,R4)      INCREMENT OFFSET POINTER.
         BCT   R3,TTELOOP2    AND DO IT 8 TIMES.
         SPACE 1
         OC    $LIMIT,$LIMIT  WAS AN ASID LIMIT SPECIFIED?
         BZ    NOLIMIT        NOPE, SKIP ASID CHECK.
         LH    R0,$TTELINE+22 LOAD ASID VALUE FROM TRACE ENTRY.
         N     R0,=X'00007FFF' TURN OFF S-BIT.
         CH    R0,$LIMIT      ASID MATCH?
         BNE   NEXTTTE        NOPE, SKIP TTE ENTRY.
NOLIMIT  DS    0H
         SPACE 1
         IC    R4,$TTELINE+2  GET ENTRY TYPE BYTE.
         SRL   R4,4           SHIFT OUT LOW NIBBLE.
         CH    R4,=H'11'      OVER MAX ENTRIES?
         BNH   *+8            NO, SKIP RELOAD.
         LA    R4,12          USE "UNKNOWN" ENTRY.
         STC   R4,$TYPE       SAVE ENTRY TYPE.
         SPACE 3
***********************************************************************
*                                                                     *
*     DETERMINE IF INTERRUPT CODE SHOULD BE DISPLAYED ON LINE 1.      *
*     DETERMINE IF TRACE TYPE DIGIT SHOULD BE ZONKED ON LINE 2.       *
*                                                                     *
***********************************************************************
         SPACE 1
         NI    $FLAG,255-($ZAP+$INT) ASSUME NEITHER TO BE SET.
         CLI   $TYPE,0        SIO TYPE ENTRY?
         BE    NOZAP          YES, DON'T OVERLAY THE TYPE CODE.
         CLI   $TYPE,12       INVALID ENTRY?
         BNL   NOZAP          YES, DON'T OVERLAY THE TYPE CODE.
         OI    $FLAG,$ZAP     SET THE ZAP FLAG FOR LATER.
NOZAP    DS    0H
         CLI   $TYPE,3        SIO, EXT, SVC OR PGM TYPE?
         BNH   DOCODE         YES, NEED TO GET INTERRUPT CODE.
         CLI   $TYPE,5        I/O INTERRUPT?
         BE    DOCODE         YES, NEED TO GET INTERRUPT CODE.
         CLI   $TYPE,8        SVC RETURN?
         BNE   NOCODE         NO, SKIP INTERRUPT CODE.
DOCODE   DS    0H
         OI    $FLAG,$INT     SET INTERRUPT CODE FLAG.
NOCODE   DS    0H
         LH    R1,EXTFLAG     LOAD FLAG BYTE AND INTERRUPT CODE.
         N     R1,=X'00000FFF' ISOLATE THE INTERRUPT CODE.
         STH   R1,$INTCODE    SAVE THE INTERRUPT CODE
         SPACE 3
***********************************************************************
*                                                                     *
*     BUILD FORMAT PATTERN FOR THE FIRST LINE TO BE PRINTED.          *
*     ISOLATE DATA ITEM TO BE FORMATTED ON THE FIRST LINE.            *
*                                                                     *
***********************************************************************
         SPACE 1
         SLL   R4,2           MULTIPLY BY 4 FOR OFFSET.
         LA    R1,TYPTABLE(R4) ADDRESS ELEMENT TYPE'S LABEL.
         ST    R1,$PATX+4     SAVE IN LINE 1'S FORMAT PATTERN.
         SPACE 1
         MVC   $PATX+32(20),$PATXTCB ASSUME WE NEED TCB.
         CLI   $TYPE,9        PROGRAM CALL?
         BNE   NOTPC          NO, TRY FOR PT OR SSAR.
         MVC   $PATX+32(16),$PATXPC# MOVE IN PC PATTERN SUFFIX.
         B     FMTLINE        GO FORMAT THE LINE.
NOTPC    CLI   $TYPE,10       PT OR SSAR?
         BL    FMTLINE        NO, JUST FORMAT THE LINE.
         XC    $PATX+32(4),$PATX+32 END THE PATTERN EARLY.
         SPACE 1
*** SETUP ILC, CC AND PGM. MASK.
         SPACE 1
FMTLINE  DS    0H
         XR    R0,R0          ZONK!
         XR    R1,R1          ZONK, AGAIN.
         IC    R0,SIOILC      INSERT ILC, CC AND PGM. MASK.
         SRDL  R0,4           SHIFT PGM. MASK TO R1.
         SRL   R1,24          MOVE PGM. MASK TO LOW BYTE.
         STC   R1,$PM         SAVE PROGRAM MASK.
         SRDL  R0,2           SHIFT COND. CODE TO R1.
         SRL   R1,26          MOVE COND. CODE TO LOW BYTE.
         STC   R1,$CC         SAVE CONDITION CODE.
         SLL   R0,4           MOVE TO HIGH DIGIT.
         STC   R0,$ILC        SAVE INTERRUPT LENGTH CODE.
         SPACE 1
*** GET CPU ID AND CHANNEL SET ID.
         IC    R0,SIOCPUID    INSERT CPUID AND CSID.
         SRDL  R0,4           SHIFT CPUID TO R1.
         SRL   R1,24          SHIFT CPUID TO LOW BYTE.
         STC   R0,$CSID       SAVE CHANNEL SET ID.
         STC   R1,$CPUID      SAVE CPU ID.
         SPACE 3
***********************************************************************
*                                                                     *
*     FORMAT THE LINE USING AMDPRDMP'S SERVICE ROUTINE.  IF THE       *
*     INTERRUPT CODE IS NOT TO BE DISPLAYED, BLANK IT OUT.  THEN      *
*     FILL IN THE DATE FROM THE MERGED CLOCK VALUES AND PRINT THE     *
*     FIRST LINE OF THE TRACE ENTRY.                                  *
*                                                                     *
***********************************************************************
         SPACE 1
         FORMAT $PATX,BADRC=BADFMT FORMAT THE LINE.
         L     R15,ADPLBUF    ADDRESS THE AMDPRDMP BUFFER.
         MVI   4(R15),C' '    WE ONLY WANT 3 CHAR. 'RUPT CODE.
         TM    $FLAG,$INT     LIST THE INTERRUPT CODE?
         BO    DOTIME         YES, SKIP THE BLANK-OUT.
         MVC   5(3,R15),BLANKS BLANK OUT THE FORMATTED 'RUPT CODE.
         SPACE 1
DOTIME   DS    0H
         MVC   $STCK+3(4),SIOTIMER MOVE IN THE MIDDLE CLOCK DIGITS.
         LM    R0,R1,$STCK    LOAD PARAMETER REGISTERS.
         BAL   R14,MICROZ     BRANCH TO CONVERSION ROUTINE.
         CVD   R0,$DOUBLE     CONVERT DATE TO PACKED.
         CVD   R1,$DOUBLE2    LIKEWISE FOR TIME.
         L     R1,$DOUBLE+4   LOAD SIGNED DATE.
         SRL   R1,4           GET RID OF SIGN.
         STCM  R1,B'0111',$DOUBLE SAVE IN 1ST 3 BYTES OF DOUBLE.
         L     R1,$DOUBLE2+4  LOAD SIGNED TIME.
         SRL   R1,4           GET RID OF SIGN.
         STCM  R1,B'0111',$DOUBLE+3 SAVE IN BYTES 3-6 OF DOUBLE.
         CVD   R15,$DOUBLE2   CONVERT MICROSECONDS TO PACKED.
         L     R1,$DOUBLE2+4  LOAD SIGNED VALUE INTO R1.
         SLL   R1,4           SHIFT LEFT ONE NIBBLE.
         STCM  R1,B'1111',$DOUBLE+6 SAVE IN BYTES 6-10 OF AREA.
         L     R15,ADPLBUF    GET OUTPUT BUFFER ADDRESS.
         MVC   9(L'EDITMASK,R15),EDITMASK MOVE IN EDITMASK.
         ED    9(L'EDITMASK,R15),$DOUBLE EDIT DATA.
         SPACE 1
         CLI   $TYPE,10       PT, SSAR OR INVALID?
         BL    *+8            NO, CPUID IS ALREADY TAKEN CARE OF.
         MVI   68(R15),C' '   BLANK OUT 2ND CPUID DIGIT.
         SPACE 1
         PRINTBUF ,           PRINT THE FIRST LINE.
         SPACE 3
***********************************************************************
*                                                                     *
*     ISOLATE PASID, SASID AND PSW S-BIT.  THEN GET THE CORRECT       *
*     FORMAT PATTERN FOR THE CORRESPONDING TRACE ENTRY TYPE.          *
*     SPECIAL CONSIDERATION IS MADE FOR EMERGENCY SIGNAL EXTERNAL     *
*     INTERRUPTS AND SVC ERROR INTERRUPTS.  THEN FORMAT THE LINE,     *
*     ZONK OUT TYPE BYTE IN PSW AND PRINT IT.                         *
*                                                                     *
***********************************************************************
         SPACE 1
         XC    $PSWSBIT,$PSWSBIT ASSUME S-BIT IS ZERO.
         ICM   R1,B'1111',PGMPASID LOAD UP S-BIT, PASID AND SASID.
         BP    *+8            HIGH BIT OFF, S-BIT IS ZERO.
         OI    $PSWSBIT,X'10' TURN ON SECONDARY ADDRESSING BIT.
         N     R1,=X'7FFFFFFF' TURN OFF S-BIT IN REGISTER.
         STCM  R1,B'1100',$PASID SAVE PRIMARY ASID.
         STCM  R1,B'0011',$SASID SAVE SECONDARY ASID.
         SPACE 1
*** GET CORRECT FORMAT PATTERN ADDRESS.
         CLI   $TYPE,1        EXTERNAL INTERRUPT?
         BNE   TRYSVC         NO, TRY SVC INTERRUPT.
         CLI   EXTCODE,EMERSGNL EMERGENCY SIGNAL?
         BNE   DEFAULT        NO, USE DEFAULT FORMAT LIST.
         TM    EXTOPSW0+1,X'02' BIT 6 ALSO ON?
         BNO   DEFAULT        NO, NOT AN EMERGENCY SIGNAL.
         LA    R1,$PAT1A      GET ALTERNATE EXTERNAL FORMAT LINE.
         B     FMTLINE2       GO FORMAT LINE 2.
TRYSVC   DS    0H
         CLI   $TYPE,2        SVC INTERRUPT?
         BNE   DEFAULT        NO, USE DEFAULT FORMAT CODE.
         CLC   SVCOPSW4,=X'FFFFFFFF' ADDRESS = X'FFFFFFFF'?
         BNE   DEFAULT        NO, USE DEFAULT SVC FORMAT LIST.
         LA    R1,$PAT2A      USE SVC ALTERNATE FORMAT LIST.
         B     FMTLINE2       AND FORMAT THE LINE.
DEFAULT  XR    R1,R1          ZONK FOR INSERT.
         IC    R1,$TYPE       LOAD UP THE ENTRY TYPE.
         SLL   R1,2           MULTIPLY BY 4.
         L     R1,$PATINDX(R1) ADDRESS CORRECT FORMAT LIST.
FMTLINE2 DS    0H
         FORMAT 0(,R1),BADRC=BADFMT FORMAT THE LINE.
         SPACE 1
*** ZAP OUT ENTRY TYPE AND INTERRUPT CODE IF REQUIRED.
         SPACE 1
         L     R15,ADPLBUF    ADDRESS OUTPUT BUFFER.
         TM    $FLAG,$ZAP     ZAP OUT ENTRY TYPE?
         BNO   PUTLINE2       NO, JUST WRITE OUT THE ENTRY.
         MVI   23(R15),C'*'   ZONK THE ENTRY TYPE IN PSW.
         TM    $FLAG,$INT     INTERRUPT CODE?
         BNO   PUTLINE2       NO, WRITE THE LINE.
         CLI   $TYPE,2        SVC INTERRUPT?
         BE    USE2           YES, ONLY ZAP TWO BYTES.
         CLI   $TYPE,8        SVC RETURN?
         BE    USE2           YES, ONLY USE 2 HERE ALSO.
         MVC   24(3,R15),STARS MOVE IN A FEW ASTERISKS.
         B     PUTLINE2       AND WRITE THE LINE.
USE2     DS    0H
         MVC   25(2,R15),STARS ZONK OUT INTERRUPT CODE.
         SPACE 1
PUTLINE2 DS    0H
         PRINTBUF ,           WRITE THE BUFFER.
         PRINTBUF ,           WRITE A BLANK LINE ALSO.
         SPACE 1
         C     R2,$TTECUR     CURRENT ENTRY?
         BNE   NEXTTTE        NO, SKIP 'CURRENT ENTRY' MESSAGE.
         PRINTBUF MSGCURNT    TELL USER IT'S THE CURRENT ENTRY.
         PRINTBUF ,           AND WRITE A BLANK LINE.
NEXTTTE  DS    0H
         LA    R2,32(,R2)     UPDATE TTE POINTER.
         B     TTELOOP        AND RETURN UNTIL FINISHED.
         EJECT
**********************************************************************
*                                                                    *
*        TIME-OF-DAY CLOCK CONVERSION ROUTINE.                       *
*                                                                    *
*        ON INPUT:                                                   *
*             R0 AND R1 CONTAIN TIME OF DAY CLOCK VALUE TO CONVERT.  *
*                                                                    *
*        ON OUTPUT:                                                  *
*             R0  = JULIAN DATE IN BINARY (YYDDD).                   *
*             R1  = TIME OF DAY IN BINARY (HHMMSS)                   *
*             R15 = TIME OF DAY REMAINDER IN MICROSECONDS.           *
*                                                                    *
*        RETURN VIA REGISTER 14.                                     *
*                                                                    *
*        REGISTERS USED:  15, 0, 1, 2, 3                             *
*                                                                    *
**********************************************************************
         SPACE 1
MICROZ   DS    0H
         STM   R2,R3,28(R13)  SAVE CALLER'S REGISTER.
         SRDL  R0,12          SHIFT OUT LOW 12 BITS OF ZEROS.
         D     R0,=F'60000000' GET VALUE IN MINUTES.
         LR    R3,R1          R3=# MINUTES SINCE JAN 1, 1900.
         SRDL  R0,32          MOVE 0 TO 1, CLEAR 0.
         D     R0,=F'1000000' COMPUTE REMAINDER IN SECONDS.
         LR    R15,R0         LOAD REMAINDER OF MICROSECONDS.
         XR    R2,R2          ZONK.
         D     R2,=F'60'      COMPUTE MINUTES.
         MH    R2,=H'100'     MULTIPLY REMAINDER BY 100.
         AR    R1,R2          ADD TO TIME REG.
         XR    R2,R2          ZONK.
         D     R2,=F'24'      COMPUTE HOURS.
         MH    R2,=H'10000'   SHIFT LEFT 4 DECIMALS.
         AR    R1,R2          ADD TO TIME REG.
         XR    R2,R2          ZONK.
         SLDL  R2,2           MULTIPLY BY 4 (YEARS IN DIVIDEND).
         D     R2,=F'1461'    DIVIDE BY # DAYS IN 4 YEARS.
         MH    R3,=H'1000'    MULTIPLY YEARS BY 1000.
         SRL   R2,2           DIVIDE DAYS BY 4.
         LA    R2,2(,R2)      LOAD 1976 FUDGE FACTOR.
         AR    R2,R3          COMPUTE DAYS (YYDDD).
         LR    R0,R2          LOAD INTO ZERO.
         LM    R2,R3,28(R13)  RESTORE UNUSED REGISTERS.
         BR    R14            RETURN TO CALLER.
         EJECT
**********************************************************************
*                                                                    *
*     ABNORMAL SITUATION MESSAGE ISSUING AND RECOVERY (MAYBE).       *
*                                                                    *
**********************************************************************
         SPACE 1
NOTRACE  DS    0H
         PRINTBUF NOTACTIV    INDICATE TRACE IS NOT ACTIVE.
         B     RETURN         AND FINISH PROCESSING.
         SPACE 1
ASIDERR  DS    0H
         LA    R14,L'ASIDMSG  LOAD LENGTH OF MESSAGE.
         LA    R1,ASIDMSG     LOAD ADDRESS OF MESSAGE.
         B     ABENDMSG       GO ISSUE MESSAGE.
         SPACE 1
TCBERR   DS    0H
         LA    R14,L'TCBMSG   LOAD LENGTH OF MESSAGE.
         LA    R1,TCBMSG      LOAD ADDRESS OF MESSAGE.
         B     ABENDMSG       GO ISSUE MESSAGE.
         SPACE 1
BADPSA   DS    0H
         LA    R14,L'ERRPSA   LOAD LENGTH OF MESSAGE.
         LA    R1,ERRPSA      LOAD ADDRESS OF MESSAGE.
         B     ABENDMSG       GO ISSUE MESSAGE.
         SPACE 1
BADTRVEC DS    0H
         LA    R14,L'ERRTRVEC LOAD LENGTH OF MESSAGE.
         LA    R1,ERRTRVEC    LOAD ERROR MESSAGE ADDRESS.
         B     ABENDMSG       ISSUE ERROR MESSAGE.
         SPACE 1
BADCVT   DS    0H
         LA    R14,L'ERRCVT   LOAD LENGTH OF MESSAGE.
         LA    R1,ERRCVT      LOAD ERROR MESSAGE ADDRESS.
         B     ABENDMSG       ISSUE ERROR MESSAGE.
         SPACE 1
BADASVT  DS    0H
         LA    R14,L'ERRASVT  LOAD LENGTH OF MESSAGE.
         LA    R1,ERRASVT     LOAD ERROR MESSAGE ADDRESS.
         B     ABENDMSG       ISSUE ERROR MESSAGE.
         SPACE 1
BADASCB  DS    0H
         LA    R14,L'ERRASCB  LOAD LENGTH OF MESSAGE.
         LA    R1,ERRASCB     LOAD ERROR MESSAGE ADDRESS.
         B     ABENDMSG       ISSUE ERROR MESSAGE.
         SPACE 1
BADTCB   DS    0H
         LA    R14,L'ERRTCB   LOAD LENGTH OF MESSAGE.
         LA    R1,ERRTCB      LOAD ERROR MESSAGE ADDRESS.
         B     ABENDMSG       ISSUE ERROR MESSAGE.
         SPACE 1
BADCST   DS    0H
BADSCD   DS    0H
         PRINTBUF ERRTIME     ISSUE WARNING MESSAGE.
         B     RELOCATE       AND CONTINUE PROCESSING.
         SPACE 1
BADTTE   DS    0H
         LA    R14,L'ERRTTE   LOAD LENGTH OF MESSAGE.
         LA    R1,ERRTTE      LOAD ERROR MESSAGE ADDRESS.
         B     ABENDMSG       ISSUE ERROR MESSAGE.
         SPACE 1
BADFMT   DS    0H
         LA    R14,L'ERRFMT   LOAD LENGTH OF MESSAGE.
         LA    R1,ERRFMT      LOAD ERROR MESSAGE ADDRESS.
         SPACE 1
ABENDMSG DS    0H
         LR    R2,R15         SAVE SERVICE ROUTINE'S RETURN CODE.
         L     R15,ADPLBUF    POINT TO MESSAGE BUFFER.
         MVC   0(121,R15),BLANKS CLEAR PREVIOUS GARBAGE.
         BCTR  R14,0          DECREMENT LENGTH VALUE.
         EX    R14,MVC1       MOVE MESSAGE TO BUFFER.
         PRINTBUF ,           PRINT THE BUFFER.
         B     ABEND          AND GO BARF OUT.
         SPACE 1
DELIMERR DS    0H
         LA    R0,4           LOAD SECONDARY RETURN CODE.
         B     SET2ND         GO SAVE IN EXTENSION.
         SPACE 1
OPERROR  DS    0H
         LA    R0,8           LOAD SECONDARY RETURN CODE.
         B     SET2ND         GO SAVE IN EXTENSION.
         SPACE 1
SYNTAXER DS    0H
         LA    R0,12          LOAD SECONDARY RETURN CODE.
SET2ND   DS    0H
         L     R14,ADPLEXT    POINT AT PARM. LIST EXTENSION.
         ST    R0,0(,R14)     SAVE RETURN CODE.
         LA    R2,4           LOAD PRIMARY RETURN CODE.
         B     ABEND          AND GO BARF OUT.
         SPACE 2
***********************************************************************
*                                                                     *
*     NORMAL AND ABNORMAL RETURN POINT.  AN ENDING MESSAGE IS         *
*     PRINTED, AND THE REENTRANT WORK AREA IS FREED (SUBPOOL NUMBER   *
*     WAS PROVIDED IN THE ABDUMP PARAMETER LIST).                     *
*                                                                     *
***********************************************************************
         SPACE 1
RETURN   PRINTBUF ENDMSG           PRINT ENDING MESSAGE.
         XR    R2,R2               ZERO RETURN CODE.
ABEND    LA    R0,$LENGTH          LOAD LENGTH TO FREEMAIN.
         ICM   R0,8,ADPLSBPL       INSERT SUBPOOL.
         LR    R1,R11              SET ADDRESS TO BE FREED.
         L     R13,4(,R13)         BACK TO CALLER'S SAVE AREA.
         FREEMAIN R,LV=(0),A=(1)   FREE REENTRANT AREA.
         ST    R2,16(,R13)         PUT RETURN CODE IN R15 SLOT.
         LM    R14,R12,12(R13)     RESTORE CALLER'S REGISTERS.
         BR    R14                 RETURN TO CALLING PROGRAM.
         EJECT
***********************************************************************
*                                                                     *
*                    CONSTANTS AND EQUATES                            *
*                                                                     *
***********************************************************************
         SPACE 2
XAMSG1   DC    C'ENVIRONMENT ERROR:  YOU ARE EXAMINING A DUMP FROM AN M*
               VS/XA SYSTEM.'
XAMSG2   DC    C'  - AMDPRDMP USERS:  SPECIFY THE ''TRACE'' VERB.'
XAMSG3   DC    C'  - IPCS USERS:  SPECIFY MODULE ''IEAVETFC'' ON THE VE*
               RBEXIT COMMAND.'
SP3MSG1  DC    C'ENVIRONMENT ERROR:  YOU ARE EXAMINING A DUMP FROM A NO*
               N-MVS/SP 1.3 SYSTEM.'
SP3MSG2  DC    C'  - PROCEED AT YOUR OWN RISK.'
TITLE    DC    C'AMDAHL TRACE TABLE FORMATTING PROGRAM.'
OPMSG    DC    C'  EXIT OPERANDS:  '
ENDMSG   DC    C'END OF TRACE TABLE FORMATTING PROGRAM.'
BLANKS   DC    CL121' '       A FEW HANDY BLANKS.
NOTACTIV DC    C'TRACE TABLE POINTER IS ZERO - CAN NOT FORMAT TABLE.'
DASACTIV DC    C'DUAL ADDRESS SPACE TRACING IS ACTIVE.'
MSGCURNT DC    C'************** CURRENT TRACE TABLE ENTRY IS ON THE PRE*
               CEEDING LINE.  THE OLDEST TRACE TABLE ENTRY FOLLOWS. ****
               ***************'
ERRTIME  DC    C'CLOCK PREFIX COULD NOT BE LOCATED.  TIME VALUES WILL B*
               E INCORRECT.'
ERRCVT   DC    C'STORAGE FOR CVT CAN NOT BE ACCESSED.'
ERRASVT  DC    C'STORAGE FOR ASVT CAN NOT BE ACCESSED.'
ERRASCB  DC    C'STORAGE FOR REQUESTED ASCB CAN NOT BE ACCESSED.'
ERRTCB   DC    C'STORAGE FOR REQUESTED TCB CAN NOT BE ACCESSED.'
ASIDMSG  DC    C'ASID MUST BE LESS THAN 1100.'
TCBMSG   DC    C'TCB MUST BE ONE OR TWO ALPHABETIC CHARACTERS.'
ERRPSA   DC    C'STORAGE FOR TRACE POINTER CAN NOT BE ACCESSED.'
ERRTRVEC DC    C'STORAGE FOR TRACE VECTORS CAN NOT BE ACCESSED.'
ERRTTE   DC    C'STORAGE FOR TRACE ENTRY CAN NOT BE ACCESSED.'
ERRFMT   DC    C'FORMAT ROUTINE RETURNED ABNORMAL COMPLETION CODE.'
         SPACE 1
MVC1     MVC   0(0,R15),0(R1)
TRT1     TRT   0(0,R1),TRTABLE1
PACKASID PACK  $DOUBLE,0(0,R4)
         SPACE 1
         SPACE 1
EDITMASK DC    X'40202120612020206B4021207A20207A20204B212020202020'
         SPACE 1
TYPTABLE DC    CL4'SIO '
         DC    CL4'EXT '
         DC    CL4'SVC '
         DC    CL4'PGM '
         DC    CL4'ISD '
         DC    CL4'I/O '
         DC    CL4'SSR '
         DC    CL4'DSP '
         DC    CL4'RET '
         DC    CL4'PC  '
         DC    CL4'PT  '
         DC    CL4'SSAR'
STARS    DC    CL4'****'
         SPACE 1
LINE1    DC    C', ILC='
         DC    C', CC='
         DC    C', PGM.MASK='
         DC    C', CPUID='
         DC    C', TCB='
         DC    C', ASID='
         SPACE 1
TYPE0    DC    C'CC='
         DC    C', CAW='
         DC    C',        CSW='
         DC    C','
         DC    C', IOSB='
CSID     DC    C', CSID='
         SPACE 1
TYPE1    DC    C'EXTOPSW='
         DC    C','
SBIT     DC    C', S-BIT='
PASID    DC    C', PASID='
         DC    C', SASID='
REG0     DC    C', R0='
REG1     DC    C', R1='
         SPACE 1
TYPE1A   DC    C', PCCAEMSI='
         DC    C', PCCAEMSP='
         DC    C', PCCAEMSE='
         SPACE 1
TYPE2    DC    C'SVCOPSW='
         DC    C','
REG15    DC    C', R15='
         SPACE 1
TYPE2A   DC    C', PSAHLHI='
         DC    C', PSAMODEW='
         SPACE 1
TYPE3    DC    C'PGMOPSW='
         DC    C','
TYPE3TEA DC    C', FLCTEAA='
         SPACE 1
NEWPSW   DS    0C
TYPE4    DC    C'NEW PSW='
         DC    C','
PURGASID DC    C', PURGE ASID='
         SPACE 1
TYPE5    DC    C'I/OOPSW='
         DC    C','
         DC    C', CSW='
         DC    C','
         SPACE 1
NEWPASID DC    C', NEW PASID='
NEWSASID DC    C', NEW SASID='
NEWR14   DC    C', NEW R14='
PGMCALL# DC    C', PC#='
OLDPASID DC    C', OLD PASID='
OLDSASID DC    C', OLD SASID='
INVALID  DC    C'INVALID'
         SPACE 2
         LTORG ,
         SPACE 1
TRTABLE2 EQU   *-X'C0'
TRTABLE1 DS    0X 0 1 2 3 4 5 6 7 8 9 A B C D E F
         DC    X'00010203040506070809000000000000' 00-0F C0-CF
         DC    X'000A0B0C0D0E0F101112000000000000' 10-1F D0-DF
         DC    X'0000131415161718191A000000000000' 20-2F E0-EF
         DC    X'00000000000000000000000000000000' 30-3F
         DC    X'04000000000000000000000000000000' 40-4F
         DC    X'00000000000000000000000000000000' 50-5F
         DC    X'00000000000000000000000800000000' 60-6F
         DC    X'00000000000000000000000000000000' 70-7F
         DC    X'00000000000000000000000000000000' 80-8F
         DC    X'00000000000000000000000000000000' 90-9F
         DC    X'00000000000000000000000000000000' A0-AF
         DC    X'00000000000000000000000000000000' B0-BF
         DC    X'00101010101010101010000000000000' C0-CF
         DC    X'00101010101010101010000000000000' D0-DF
         DC    X'00001010101010101010000000000000' E0-EF
         DC    X'0C0C0C0C0C0C0C0C0C0C000000000000' F0-FF
         EJECT
***********************************************************************
*                                                                     *
*        FORMAT PATTERNS FOR ALL TYPES OF TRACE ENTRIES.              *
*                                                                     *
***********************************************************************
         SPACE 1
*** FORMAT PATTERN BIT SETTINGS.
         SPACE 1
NX       EQU   X'20'               DON'T CONVERT TO HEX.
CS       EQU   X'10'               DATA IS IN CALLER'S STORAGE
@D       EQU   X'0C'               DATA POINTER FOLLOWS
DD       EQU   X'04'               DATA IS TO BE PLACED IN BUFFER.
@L       EQU   X'03'               LABEL POINTER FOLLOWS.
LL       EQU   X'01'               LABEL IS TO BE PLACED IN BUFFER.
         SPACE 1
PATTERNS DS    0F
         DC    AL1(CS+@D+@L,3*16+1,0,4)
         DC    A(0)                LABEL ADDRESS FILLED IN LATER.
         DC    A($INTCODE-$DSECT)
         DC    AL1(CS+DD+@L,5*16+0,34,40)    INT. LENGTH CODE
         DC    A(LINE1)
         DC    AL1(CS+DD+LL,4*16+0,41,46)    COND. CODE
         DC    AL1(CS+DD+LL,10*16+0,47,58)   PROGRAM MASK
         DC    AL1(CS+DD+LL,7*16+0,59,67)    CPU ID.
         DC    5A(0)                         FILLER FOR TCB.
         SPACE 1
         DC    AL1(CS+@D+LL,5*16+7,68,74)    TCB.
         DC    A(SIOTCB-$DSECT)
         DC    AL1(CS+@D+LL,6*16+1,82,89)    ASID
         DC    A(SIOASID-$DSECT)
         DC    A(0)
         SPACE 1
         DC    AL1(CS+@D+@L,5*16+3,68,74)    PROGRAM CALL NUMBER
         DC    A(PGMCALL#)
         DC    A(PCNUM-$DSECT)
         DC    A(0)
         SPACE 1
         DC    AL1(CS+@D+@L,2*16+0,11,14)    SIO COND. CODE
         DC    A(TYPE0)
         DC    A(SIOCC-$DSECT)
         DC    AL1(CS+@D+LL,5*16+3,15,21)    CAW
         DC    A(SIOCAW-$DSECT)
         DC    AL1(CS+DD+LL,12*16+3,29,42)   CSW WORD 1
         DC    AL1(CS+DD+LL,0*16+3,50,51)    CSW WORD 2
         DC    AL1(CS+DD+LL,6*16+3,59,66)    IOSB ADDRESS
         DC    AL1(CS+@D+LL,6*16+0,74,81)    CHANNEL SET ID
         DC    A($CSID-$DSECT)
         DC    A(0)
         SPACE 1
         DC    AL1(CS+@D+@L,7*16+3,11,19)    EXTERNAL OLD PSW WORD 1
         DC    A(TYPE1)
         DC    A(EXTOPSW0-$DSECT)
         DC    AL1(CS+DD+LL,0*16+3,27,28)    EXTERNAL OLD PSW WORD 2
         DC    AL1(CS+@D+LL,7*16+0,36,44)    PSW S-BIT
         DC    A($PSWSBIT-$DSECT)
         DC    AL1(CS+DD+LL,7*16+1,45,53)    PASID
         DC    AL1(CS+DD+LL,7*16+1,57,65)    SASID
         DC    AL1(CS+@D+LL,4*16+3,69,74)    REGISTER 0
         DC    A(EXTEMSP-$DSECT)
         DC    AL1(CS+DD+LL,4*16+3,82,87)    REGISTER 1
         DC    A(0)
         SPACE 1
         DC    AL1(CS+@D+@L,7*16+3,11,19)    EXTERNAL OLD PSW WORD 1
         DC    A(TYPE1)
         DC    A(EXTOPSW0-$DSECT)
         DC    AL1(CS+DD+LL,0*16+3,27,28)    EXTERNAL OLD PSW WORD 2
         DC    AL1(CS+DD+@L,10*16+3,36,47)   PCCAEMSI
         DC    A(TYPE1A)
         DC    AL1(CS+DD+LL,10*16+3,55,66)   PCCAEMSP
         DC    AL1(CS+DD+LL,10*16+3,74,85)   PCCAEMSE
         DC    A(0)
         SPACE 1
         DC    AL1(CS+@D+@L,7*16+3,11,19)    SVC OLD PSW WORD 1
         DC    A(TYPE2)
         DC    A(SVCOPSW0-$DSECT)
         DC    AL1(CS+DD+LL,0*16+3,27,28)    SVC OLD PSW WORD 2
         DC    AL1(CS+DD+LL,5*16+3,36,42)    REGISTER 15
         DC    AL1(CS+DD+@L,4*16+3,50,55)    REGISTER 0
         DC    A(REG0)
         DC    AL1(CS+DD+LL,4*16+3,63,68)    REGISTER 1
         DC    A(0)
         SPACE 1
         DC    AL1(CS+@D+@L,7*16+3,11,19)    SVC OLD PSW WORD 1
         DC    A(TYPE2)
         DC    A(SVCOPSW0-$DSECT)
         DC    AL1(CS+DD+LL,0*16+3,27,28)    SVC OLD PSW WORD 2
         DC    AL1(CS+@D+@L,7*16+0,36,44)    PSW S-BIT.
         DC    A(SBIT)
         DC    A($PSWSBIT-$DSECT)
         DC    AL1(CS+DD+LL,7*16+1,45,53)    PASID
         DC    AL1(CS+DD+LL,7*16+1,57,65)    SASID
         DC    AL1(CS+@D+@L,9*16+3,69,79)    PSAHLHI
         DC    A(TYPE2A)
         DC    A(SVCHLHI-$DSECT)
         DC    AL1(CS+DD+LL,10*16+3,87,98)   PSAMODEW
         DC    A(0)
         SPACE 1
         DC    AL1(CS+@D+@L,7*16+3,11,19)    PGM OLD PSW WORD 1
         DC    A(TYPE3)
         DC    A(PGMOPSW0-$DSECT)
         DC    AL1(CS+DD+LL,0*16+3,27,28)    PGM OLD PSW WORD 2
         DC    AL1(CS+@D+@L,7*16+0,36,44)    PSW S-BIT.
         DC    A(SBIT)
         DC    A($PSWSBIT-$DSECT)
         DC    AL1(CS+DD+LL,7*16+1,45,53)    PASID
         DC    AL1(CS+DD+LL,7*16+1,57,65)    SASID
         DC    AL1(CS+@D+@L,9*16+3,69,79)    TRANSLATE EX. ADDRESS
         DC    A(TYPE3TEA)
         DC    A(PGMTRANS-$DSECT)
         DC    AL1(CS+DD+@L,4*16+3,87,92)    REGISTER 1
         DC    A(REG1)
         DC    A(0)
         SPACE 1
         DC    AL1(CS+@D+@L,7*16+3,11,19)    SRB NEW PSW WORD 1
         DC    A(TYPE4)
         DC    A(ISDNPSW0-$DSECT)
         DC    AL1(CS+DD+LL,0*16+3,27,28)    SRB NEW PSW WORD 2
         DC    AL1(CS+DD+LL,12*16+1,36,49)   PURGE ASID
         DC    AL1(CS+DD+@L,4*16+3,53,58)    REGISTER 0
         DC    A(REG0)
         DC    AL1(CS+DD+LL,4*16+3,66,71)    REGISTER 1
         DC    A(0)
         SPACE 1
         DC    AL1(CS+@D+@L,7*16+3,11,19)    I/O OLD PSW WORD 1
         DC    A(TYPE5)
         DC    A(IOOPSW0-$DSECT)
         DC    AL1(CS+DD+LL,0*16+3,27,28)    I/O OLD PSW WORD 2
         DC    AL1(CS+DD+LL,5*16+3,36,42)    CSW WORD 1
         DC    AL1(CS+DD+LL,0*16+3,50,51)    CSW WORD 2
         DC    AL1(CS+@D+@L,6*16+0,59,66)    CSID
         DC    A(CSID)
         DC    A($CSID-$DSECT)
         DC    A(0)
         SPACE 1
         DC    AL1(CS+@D+@L,7*16+3,11,19)    SRB NEW PSW WORD 1
         DC    A(NEWPSW)
         DC    A(SSRNPSW0-$DSECT)
         DC    AL1(CS+DD+LL,0*16+3,27,28)    SRB NEW PSW WORD 2
         DC    AL1(CS+@D+@L,7*16+0,36,44)    PSW S-BIT
         DC    A(SBIT)
         DC    A($PSWSBIT-$DSECT)
         DC    AL1(CS+DD+LL,7*16+1,45,53)    PASID
         DC    AL1(CS+DD+LL,7*16+1,57,65)    SASID
         DC    AL1(CS+@D+@L,12*16+1,69,82)   PURGE ASID
         DC    A(PURGASID)
         DC    A(SSRPURAS-$DSECT)
         DC    AL1(CS+DD+@L,4*16+3,86,91)    REGISTER 1
         DC    A(REG1)
         DC    A(0)
         SPACE 1
         DC    AL1(CS+@D+@L,7*16+3,11,19)    DSP NEW PSW WORD 1
         DC    A(NEWPSW)
         DC    A(DSPNPSW0-$DSECT)
         DC    AL1(CS+DD+LL,0*16+3,27,28)    DSP NEW PSW WORD 2
         DC    AL1(CS+@D+@L,7*16+0,36,44)    PSW S-BIT
         DC    A(SBIT)
         DC    A($PSWSBIT-$DSECT)
         DC    AL1(CS+DD+LL,7*16+1,45,53)    PASID
         DC    AL1(CS+DD+LL,7*16+1,57,65)    SASID
         DC    AL1(CS+@D+@L,4*16+3,69,74)    REGISTER 0
         DC    A(REG0)
         DC    A(EXTEMSP-$DSECT)
         DC    AL1(CS+DD+LL,4*16+3,82,87)    REGISTER 1
         DC    A(0)
         SPACE 1
         DC    AL1(CS+@D+@L,7*16+3,11,19)    SVC RETURN NEW PSW WORD 1
         DC    A(NEWPSW)
         DC    A(RETNPSW0-$DSECT)
         DC    AL1(CS+DD+LL,0*16+3,27,28)    SVC RETURN NEW PSW WORD 2
         DC    AL1(CS+DD+@L,5*16+3,36,42)    REGISTER 15
         DC    A(REG15)
         DC    AL1(CS+DD+@L,4*16+3,50,55)    REGISTER 0
         DC    A(REG0)
         DC    AL1(CS+DD+LL,4*16+3,63,68)    REGISTER 1
         DC    A(0)
         SPACE 1
         DC    AL1(CS+@D+@L,7*16+3,11,19)    PGM. CALL NEW PSW WORD 1
         DC    A(NEWPSW)
         DC    A(PCNPSW0-$DSECT)
         DC    AL1(CS+DD+LL,0*16+3,27,28)    PGM. CALL NEW PSW WORD 2
         DC    AL1(CS+@D+@L,11*16+1,36,48)   NEW PASID
         DC    A(NEWPASID)
         DC    A(PCPASID-$DSECT)
         DC    AL1(CS+DD+LL,11*16+1,52,64)   NEW SASID
         DC    AL1(CS+DD+LL,9*16+3,68,78)    NEW REGISTER 14
         DC    A(0)
         SPACE 1
         DC    AL1(CS+@D+@L,7*16+3,11,19)    PGM. XFER NEW PSW WORD 1
         DC    A(NEWPSW)
         DC    A(PTNPSW0-$DSECT)
         DC    AL1(CS+DD+LL,0*16+3,27,28)    PGM. CALL NEW PSW WORD 2
         DC    AL1(CS+@D+@L,11*16+1,36,48)   NEW PASID
         DC    A(NEWPASID)
         DC    A(PTPASID-$DSECT)
         DC    AL1(CS+@D+@L,11*16+1,52,64)   OLD PASID
         DC    A(OLDPASID)
         DC    A(PTOASID-$DSECT)
         DC    A(0)
         SPACE 1
         DC    AL1(CS+@D+@L,7*16+3,11,19)    SSAR NEW PSW WORD 1
         DC    A(NEWPSW)
         DC    A(SSANPSW0-$DSECT)
         DC    AL1(CS+DD+LL,0*16+3,27,28)    SSAR NEW PSW WORD 2
         DC    AL1(CS+@D+@L,11*16+1,36,44)   PASID
         DC    A(PASID)
         DC    A(SSAPASID-$DSECT)
         DC    AL1(CS+DD+@L,11*16+1,48,60)   NEW SASID
         DC    A(NEWSASID)
         DC    AL1(CS+@D+@L,11*16+1,64,76)   OLD SASID
         DC    A(OLDSASID)
         DC    A(SSAOASID-$DSECT)
         DC    A(0)
         SPACE 1
         DC    AL1(CS+@D+@L,6*16+3,11,19)  INVALID TYPE.
         DC    A(INVALID)
         DC    A($TTELINE-$DSECT)
         DC    AL1(CS+DD,3,0,28)
         DC    AL1(CS+DD,3,0,37)
         DC    AL1(CS+DD,3,0,46)
         DC    AL1(CS+DD,3,0,56)
         DC    AL1(CS+DD,3,0,65)
         DC    AL1(CS+DD,3,0,74)
         DC    AL1(CS+DD,3,0,83)
         DC    A(0)
         SPACE 1
         DC    A($PAT0-$DSECT)
         DC    A($PAT1-$DSECT)
         DC    A($PAT2-$DSECT)
         DC    A($PAT3-$DSECT)
         DC    A($PAT4-$DSECT)
         DC    A($PAT5-$DSECT)
         DC    A($PAT6-$DSECT)
         DC    A($PAT7-$DSECT)
         DC    A($PAT8-$DSECT)
         DC    A($PAT9-$DSECT)
         DC    A($PATA-$DSECT)
         DC    A($PATB-$DSECT)
         DC    A($PATC-$DSECT)
         SPACE 1
LPATTERN EQU   *-PATTERNS
         SPACE 2
ASVTFRST EQU   X'20C'              1ST ASCB POINTER OFFSET IN ASVT.
ASCBRCTP EQU   X'7C'               RCT TCB POINTER OFFSET IN ASCB.
CSTSCDP  EQU   X'08'               SCD POINTER OFFSET IN CST.
CVTASVT  EQU   X'22C'              ASVT POINTER OFFSET IN CVT.
CVTDCB   EQU   X'74'               LOGREC DCB POINTER OFFSET IN CVT.
CVTFQCB  EQU   X'280'              FIRST QCB POINTER OFFSET IN CVT.
CVTCST   EQU   X'41C'              CST POINTER OFFSET IN CVT.
FLCTRACE EQU   X'54'               TRACE VECTOR POINTER OFFSET IN PSA.
RTM2TRCU EQU   X'37C'              CURRENT TRACE PTR. OFFSET IN RTM2WA.
SCDTIME  EQU   X'10'               TOD-CLOCK OFFSET IN SCD.
TCBTCB   EQU   X'74'               NEXT TCB POINTER OFFSET IN TCB.
TCBRTWA  EQU   X'E0'               RTM2WA POINTER OFFSET IN TCB.
         EJECT
$DSECT   DSECT ,                   REENTRANT WORK AREA.
$SAVE    DS    18A                 O/S SAVE AREA.
$STCK    DS    D                   CLOCK SAVE AREA.
$DOUBLE  DS    D                   CONVERSION WORK AREA.
$DOUBLE2 DS    D                   CONVERSION WORK AREA.
$TTELINE DS    0CL32               TRACE ENTRY (DOUBLEWORD ALIGNED).
         AMDTTE LIST=NO,DSECT=NO   TTE MAPPING MACRO.
$TTEVEC  DS    0A                  TRACE TABLE VECTOR.
$TTECUR  DS    A                   CURRENT POINTER
$TTE1ST  DS    A                   POINTER TO FIRST (NEXT) ENTRY.
$TTELAST DS    A                   POINTER PAST LAST ENTRY.
$LIMIT   DS    H                   LIMIT OUTPUT TO THIS ASID.
$TCB#    DS    H                   TCB NUMBER FOR RTM2WA TRACE.
$INTCODE DS    H                 × INTERRUPT CODE.
$ILC     DS    X                 × INTERRUPT LENGTH CODE.
$CC      DS    X                 × CONDITION CODE.
$PM      DS    X                 × PROGRAM MASK.
$CPUID   DS    X                 × CPU ID.
$CSID    DS    X                   CHANNEL SET ID.
$TYPE    DS    X                   TYPE OF TRACE ENTRY.
$FLAG    DS    X                   FLAG BYTE AS FOLLOWS:
$ZAP     EQU   X'80'               ZAP OUT TRACE ENTRY CODE IN LINE 2.
$INT     EQU   X'40'               PRINT INTERRUPT CODE ON LINE 1.
$PSWSBIT DS    X                 × PSW SECONDARY ADDRESSING BIT.
$PASID   DS    H                 × PRIMARY ASID.
$SASID   DS    H                 × SECONDARY ASID.
         SPACE 1
$PATX    DS    13A               ×
$PATXTCB DS    5A                ×
$PATXPC# DS    4A                ×
$PAT0    DS    11A               ×
$PAT1    DS    12A               ×
$PAT1A   DS    9A                ×
$PAT2    DS    9A                ×
$PAT2A   DS    14A               ×
$PAT3    DS    15A               ×
$PAT4    DS    9A                ×
$PAT5    DS    10A               ×
$PAT6    DS    15A               ×
$PAT7    DS    14A               ×
$PAT8    DS    10A               ×
$PAT9    DS    10A               ×
$PATA    DS    11A               ×
$PATB    DS    13A               ×
$PATC    DS    11A               ×
         SPACE 1                 ×
$PATINDX DS    13A               ×
$LENGTH  EQU   *-$DSECT
         SPACE 1
         PRINT ON,GEN,NODATA       WE'LL LET YOU SEE THE PARM LIST.
         EJECT
         IHAABDPL DSECT=YES        GENERATE DUMP PARAMETER LIST.
         SPACE 2
         END   AMDPRTTE
