.section 'QKSRT1 - Quick Sort Macro'
.ix Macros QKSRT1
.ix 'QKSRT1 Sorting Macro'
.pp
QKSRT1 is a quick sort macro sub-routine for assembler language code.
The syntax is:
.sp
.fo off
         QKSRT1 &NAME,&TYPE,&LENGTH=0,&STRTKY=1,&KYLGTH=0,&ORDER=A,    X
               &EXTRA=0,&OVRTYP=NONE,&DISP=1,&INLINE=NO
.fo on
.pp
QKSRT1 is a macro-subroutine based on CACM algorithm number 271 with
the following changes and additions:
.point begin
Calculation of P as P:=(I+J)/2 was changed to: P:=I+(J-I)/2
.point
The line 'FOR Q:=Q STEP -1 UNTIL K DO' was changed to:
'FOR Q:=Q STEP -1 UNTIL K+1 DO'
.point
Option: Corresponding elements in up to five extra arrays may
be exchanged, when elements in the sorted array are
exchanged.  Each extra array must contain the same number
of elements, and have element sizes equal to those of the
sorted array.
.point
Option: With 'TYPE' set to 'C' (character format) other types
of compares may be made by specifying one or two
overriding parameters.
.point
Option: In line code may be generated, if desired, by
specifying INLINE=YES.  A dummy program name is still
required.  Registers will be saved in a special savearea.
.point end
.pa
Explanation of Keyword and Positional operands:
.point begin
NAME (POSITIONAL): THE SUBROUTINE MUST BE NAMED ARBITRARILY
(ONE TO SIX CHARACTERS MAXIMUM) BY THE USER. FORTRAN OR COBOL
RULES MUST BE FOLLOWED IN CHOOSING A NAME.
.point
TYPE (POSITIONAL): THE TYPE OF VARIABLES TO BE SORTED MUST BE
CONVEYED TO THE MACRO.  ADMISSIBLE VALUES ARE: P=PACKED;
C=CHARACTER OR ALPHANUMERICS (= A-FORMAT VARIABLES); H=HALFWORD
INTEGERS (=INTEGER*2); F=FULLWORD (=INTEGER*4); E=SINGLE
PRECISION FLOATING POINT (=REAL*4); D=DOUBLE PRECISION FLOATING
POINT (=REAL*8).
.point
LENGTH (KEYWORD): THE LENGTH IN BYTES OF THE FIELDS OF TYPES P
AND C MUST BE SPECIFIED.  THE LENGTH MUST BE LESS THAN 256
BYTES FOR C OR 16 BYTES FOR P.
.point
STRTKY (KEYWORD): THE COLUMN THE SORTING KEY BEGINS AT MAY BE
CHANGED FROM ITS NULL VALUE OF COLUMN 1.
.point
KYLGTH (KEYWORD): THE LENGTH OF THE DESIRED SORTING KEY.  IF
KYLGTH IS OMITTED, LENGTH MINUS STRTKY IS THE DEFAULT OPTION.
.point
ORDER (KEYWORD): THE ORDER OF THE DESIRED SORT. OPTIONS ARE:
A=ASCENDING ORDER; D=DESCENDING ORDER. IF ORDER IS NOT
SPECIFIED, ASCENDING ORDER IS THE ASSUMED DEFAULT OPTION.
.point
EXTRA (KEYWORD): THE NUMBER OF ADDITIONAL ARRAYS (RANGE: 0 - 5)
EXTRA=0 IS THE DEFAULT OPTION.
.point
OVRTYP (KEYWORD): OVRTYP=(D,E,F, OR H) ALLOWS FIXED OR FLOATING
POINT COMPARES WITHIN LONGER FIELDS.  TYPE MUST EQUAL "C".
.point
DISP (KEYWORD): WHEN OVRTYP IS SPECIFIED, THIS SPECIFIES THE
COLLUMN AT WHICH COMPARISON BEGINS.  DEFAULT IS COLLUMN 1.
.point
INLINE (KEYWORD): INLINE=YES GENERATES IN LINE CODE WITHIN AN
ASSEMBLER ROUTINE.  DEFAULT IS A CSECT CALLABLE BY FORTRAN.
.point end
.pa
THE FOLLOWING PARAMETER LIST IS REQUIRED IN THE FORTRAN CALL:
.sp
 THE NAME OF THE ARRAY TO BE SORTED.
 THE NUMBER OF ELEMENTS OF THE ARRAY TO BE SORTED.
 THE NAMES OF "EXTRA" ARRAYS, IF ANY.
.sp 2
.fo off
SEVERAL EXAMPLES WILL MAKE THE USE OF A MACRO SUBROUTINE CLEAR:

PROBLEM 1: SORT THE CHARACTER ARRAY CALLED A OF 500 ELEMENTS OF 80
BYTES EACH ACCORDING TO AN 8 BYTE KEY STARTING IN COLUMN 20.
SOLUTION:  THE FOLLOWING CARDS ARE NEEDED:
// JOB CARD
// EXEC ASMGC
//ASM.SYSIN DD *
(QUICKERSORT MACRO DEFINITION SOURCE CODE IF NOT IN SYSTEM LIBRARY)
         QKRSRT SORT1,C,LENGTH=80,STRTKY=20,KYLGTH=8
         END
(COMMENT: THE NAME SORT1 WAS ARBITRARILY CHOSEN. ONLY THE QKRSRT
AND END CARD NEED APPEAR IF THE MACRO IS IN THE SYSTEM LIBRARY)
/*
// EXEC FORTGCLG
//FORT.SYSIN DD *
(FORTRAN DECK WHICH WILL CONTAIN THE FOLLOWING STATEMENT)
    .
    .
    .
      CALL SORT1(A,500)
    .
    .
    .
/*
//GO.SYSIN DD *
(DATA, IF ANY)
/*

PROBLEM 2: SUPPOSE AN ARRAY OF DOUBLE PRECISION FLOATING POINT
NUMBERS IS TO BE SORTED.  SUPPOSE THE NAME DBLSRT IS CHOSEN FOR
THE SUBROUTINE.  THE MACRO PROTOTYPE CARD WOULD THEN READ:
         QKRSRT DBLSRT,D
HERE THE LENGTH IS IMPLIED TO BE 8 BYTES.  IN THE FORTRAN PROGRAM
THE STATEMENT "CALL DBLSRT(.....)" WOULD APPEAR.

PROBLEM 3: SUPPOSE AN ARRAY OF FIXED POINT NUMBERS IS TO BE SORTED.
ALSO TO BE SORTED ELEMENT FOR ELEMENT WITH THE FIRST ARRAY ARE
THREE ADDITIONAL ARRAYS.  THE MACRO PROTOTYPE WOULD THEN READ:
         QKRSRT EXSRT,F,EXTRA=3
HERE THE LENGTH IS IMPLIED TO BE 4 BYTES.  IN THE FORTRAN PROGRAM
THE STATEMENT "CALL EXSRT(.., .., .., .., ..)" WOULD APPEAR.

PROBLEM 4: SUPPOSE A REAL*4 ARRAY WITH DIMENSION ARR(3,100) IS TO
BE SORTED ON THE SECOND COLLUMN.  THE MACRO PROTOTYPE STATEMENT
WOULD THEN READ:
         QKRSRT OVRSRT,C,LENGTH=12,OVRTYP=E,DISP=5
HERE SORTING WOULD BE DONE ACCORDING TO THE SECOND COLLUMN.  IN THE
FORTRAN PROGRAM THE STATEMENT "CALL OVRSRT(ARR,100)" WOULD APPEAR.

PROBLEM 5: SUPPOSE AN IN LINE SORT IS DESIRED IN AN ASSEMBLER
ROUTINE, WITH FIXED POINT COMPARES.  THE MACRO PROTOTYPE WOULD
THEN READ:
         QKRSRT XYZ,F,INLINE=YES
HERE THE DUMMY NAME "XYZ" IS NOT GENERATED.  ENTERING THE SORT
ROUTINE, REGISTER 1 MUST CONTAIN THE ADDRESS OF A PARAMETER LIST
WITH THE ADDRESSES OF: THE ARRAY TO BE SORTED, THE ARRAY LENGTH
VARIABLE, AND EXTRA ARRAY ADDRESSES IF ANY.  THE CONTAINING CSECT
MUST USE R(15) FOR A BASE REGISTER.

EFFECTIVELY THE USER PROVIDES A ONE INSTRUCTION ASSEMBLY LANGUAGE
PROGRAM.  THE USER IS NOW ABLE TO SORT ANYTHING ANY WAY.
.fo on
