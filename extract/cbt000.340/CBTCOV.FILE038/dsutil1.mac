*-PROGRAM NAME:
*-
*-  DSUTIL
*-
*-ABSTRACT:
*-
*-  DSUTIL IS AN UTILITY PROGRAM WHICH, WITH A MINIMUM AMOUNT OF
*-  PROGRAMMER EFFORT, MAY BE USED TO PERFORM A VARITY OF FUNCTIONS
*-  WHILE SEQUENTIALLY COPYING, PRINTING,, LOADING, UNLOADING
*-  OR RE-ORGANIZING ANY PHYSICAL SEQUENTIAL, INDEXED SEQUENTIAL
*-  OR DIRECT DATA SET.  THE FUNCTIONS PROVIDE THE CAPABILITY OF
*-  STARTING AT,, STOPING AT, DELETING, MODIFYING, EDITING OR
*-  INSERTING RECORDS.  THE RECORDS MAY BE SELECTED BY RECORD NUMBER
*-  FULL OR PARTIAL KEYS OR A USER EXIT WRITTEN IN COBOL.
*-
*-NARRATIVE:  OPERATING INSTRUCTIONS
*-
*-DSUTIL IS CONTROLLED BY THE PRESENCE OR ABSENCE OF DD STATEMENTS AND
*-BY KEYWORD PARM VALUES.
*-
*-1.  THE //SYSUT1  DD STATEMENT DESCRIBES THE INPUT DATA SET AND MUST
*-    BE PRESENT.  DCB PARAMETERS FROM THE DATA SET LABEL ARE USED
*-    UNLESS OVERRIDDEN ON THE DD STATEMENT.
*-
*-      AN ALTERNATIVE DDNAME INSTEAD OF SYSUT1 CAN BE USED IN
*-      COMBINATION WITH THE PARMFIELD PARAMETER O-DDNAME OR
*-      SYSUT1=DDNAME.
*-
*-2.  THE //SYSUT2  DD STATEMENT DESCRIBES A DATA SET TO WHICH THE
*-    DATA IS TO BE COPIED.  IF OMITTED, NO COPY IS MADE.  THE
*-    RECFM, LRECL, AND BLKSIZE OF THE INPUT DATA SET ARE USED IF
*-    NOT PROVIDED ON THE DATA SET LABEL OR DD STATEMENT.  DSORG=IS,
*-    RKP AND KEYLEN MUST BE SPECIFIED IF OUTPUT IS AN ISAM DATA
*-    SET.  DSORG=DA MUST BE SPECIFIED IF OUTPUT IS A BDAM DATA SET.
*-    SEE THE JCL MANUAL FOR OTHER APPLICABLE DCB SUBPARAMETERS.
*-
*-      AN ALTERNATE DDNAME INSTEAD OF SYSUT2 CAN BE USED IN
*-      COMBINATION WITH THE PARMFIELD PARAMETER P=DDNAME OR
*-      SYSUT2=DDNAME.
*-
*-3.  THE //SYSPRINT  DD STATEMENT DESCRIBES THE MESSAGE AND PRINT
*-    DATA SET.  IF OMITTED, NO MESSAGES OR RECORDS ARE PRINTED.
*-    PRINTED RECORDS ARE INCLUDED IN THIS DATA SET IF SELECTED
*-    BY THE PARM SUBPARAMETERS.
*-
*-4.  THE //SYSIN  DD STATEMENT (USUALLY //SYSIN  DD *) DESCRIBES
*-    AN OPTIONAL INPUT DATA SET USED TO MODIFY THE DEFAULT OR
*-    LOADED VALID-CHARACTER-TABLE OR TRANSLATE-TABLE (TYPE=TR,
*-    BE OR BA).  IF OMITTED, DEFAULT TABLES ARE USED.
*-
*-5.  THERE ARE A VARIETY OF OPTIONS WHICH MAY BE SELECTED BY THE
*-    PARM VALUE.  THE PARM VALUE TAKES THE FORM:
*-
*-      PARM=('KEYWORD=VALUE', 'KEYWORD=VALUE',..., 'KEYWORD=VALUE')
*-
*-      NOTE:  JCL RESTRICTIONS LIMIT THE TOTAL LENGTH OF A PARM
*-             TO 100 CHARACTERS.
*-
*-    THE TERM "KEY" IS USED THROUGHOUT THIS WRITE-UP TO MEAN A
*-    PARTIAL OR COMPLLETE ISAM KEY OR A STRING OF CHARACTERS,
*-    LOGICALLY CONSTRUED AS A KEY, IN A PHYSICAL SEQUENTIAL DATA
*-    SET.  THE RKP KEYWORD SUBPARAMETER IS REQUIRED IF A "KEY"
*-    IS USED FOR A PHYSICAL SEUENTIAL INPUT DATA SET.
*-
*-    THE PARM KEYWORDS AND THEIR VALUES ARE:
*-    OPTIONS                 MEANING
*-
*-    A.  SYSPRINT=           NUMBER OF RECORDS TO BE PRINTED IN
*-        OR SPT  =           MESSAGE DATA SET (SYSPRINT).  DEFAULT
*-        OR C    =           VALUE IS 0.
*-
*-    NOTE:  DOES NOT AFFECT THE NUMBER OF RECORDS COPIED OR PRINTED
*-           IN SYSUT2.
*-
*-    B.  TYPE  = HX           RECORDS WILL BE PRINTED 50 CHARACTERS
*-        OR TYP= (DEFAULT)    PER LINE IN HEXADECIMAL FORMAT WITH
*-        OR A  =              PRINTABLE GRAPHICS ON THE NEXT LINE ON
*-                             SYSPRINT.
*-
*-           NP                RECORDS WIL BE PRINTED 100 CHARACTERS
*-                             PER LINE ON SYSPRINT WITH ONLY PRINTABLE
*-                             GRAPHICS PRINTED.
*-
*-           L2                RECORDS WILL BE PRINTED AS FOR NP
*-                             EXCEPT NO RECORD NUMBERS ARE PRINTED.
*-
*-           L1                SAME AS L2 EXCEPT SINGLE SPACE
*-                             BETWEENN RECORDS.
*-
*-           HN                SAME AS HX, WITHOUT LINES OF GRAPHICS.
*-
*-           TR                ALL CHARACTERS OF THE INPUT RECORD ARE
*-                             TRANSLATED BY AN INTERNAL TABLE TO
*-                             SUPPRESS ALL UNPRINTABLE GRAPHICS.  THIS
*-                             TABLE MAY BE MODIFIED BY INCLUDING
*-                             PAIRS OF CARDS IN THE SYSIN DATA SET.
*-                             EACH CHARACTER PUNCHED IN THE FIRST
*-                             CARD IS REPLACED BY THE CORRESPONDING
*-                             CHARACTERS ON THE SECOND CARD.
*-
*-            BE               ALL CHARACTERS OF THE INPUT RECORD
*-                             ARE SCANNED BY AN INTERNAL TABLE.
*-                             ANY NON-EBCDIC CHARACTER FOUND IS
*-                             REPLACED BY AN ASTERISK WITH A
*-                             MESSAGE *** NTH CHARACTER IS
*-                             HEX** ***
*-                             THE ERROR RECORD IS PRINED.  THE TABLE
*-                             MAY BE RESET BY INCLUDING A CARD IN THE
*-                             SYSIN DATA SET.  EACH CHARACTER PUNCHED
*-                             IN THE CARD (INCLUDING BLANK) IS
*-                             CONSIDERED VALID.  IF BLANK IS NOT TO
*-                             BE VALID, REPEAT THE LAST CHARACTER
*-                             THROUGHOUT THE CARD.
*-
*-             BA              SAME AS BE EXCEPT ALL RECORDS ARE
*-                             PRINTED.
*-
*-    C.  LINES  =             NUMBER OF LINES PRINTED PER PAGE IN
*-        OR LNS =             MESSAGE DATA SET (SYSPRINT).  NO
*-        OR B   =             RECORD WILL BE STARTED WITHIN FOUR
*-                             LINES OF THE BOTTOM OF A PAGE.  DEFAULT
*-                             VALUE IS 62.
*-
*-    D.  START  =             THE NUMBER OF LOGICAL RECORDS FROM THE
*-        OR STRT=             BEGINNING OF THE INPUT DATA SET AT
*-        OR D   =             WHICH TO START PROCESSING.  DEFAULT
*-                             VALUES IS 0.
*-
*-    E.  STOP  =              THE MAXIMUM NUMBER OF RECORDS THAT WILL
*-        OR STP=              BE ACCEPTED BY THE PROGRAM.  THE
*-        OR E  =              DEFAULT VALUE IS 999999999999999.
*-
*-    F.  SKIP  =              THE LOGICAL RECORD NUMBER OR RANGE OF
*-        OR SKP=              NUMBEERS TO BE SKIPPED FOR OUTPUT.
*-        OR F                 (I.E. SKIP = 144, SKIP RECORD #144;
*-                             SKIP = 144-178, MEANS SKIP RECORD
*-                             NUMBER 114 THROUGH 178.)  DEFAULT
*-                             VALUE IS 0.
*-
*-    G.  LAST  =              THE NUMBER OF LOGICAL RECORDS FROM THE
*-        OR LST=              END OF THE INPUT DATA SET THAT WILL BE
*-        OR G  =              PROCESSED.  (I.E. LAST=10, MEANS
*-                             PROCESS THE LAST 10 RECORDS OF THE
*-                             INPUT DATA SET).  DEFAULT IS NO ACTION
*-                             TAKEN.
*-
*-                             NOTE:  THIS ACTION IS EFFECTED BY
*-                             COUNTING RECORDS WHILE READING TO EOF
*-                             THE DATA SET IS THEN CLOSED (REWOUND)
*-                             AND RE-OPENDED, AND RECORDS ARE COUNTED
*-                             FORWARD UNTIL THE REQUIRED RECORD IS
*-                             REACHED.
*-
*-   *H.  STARTKEY=            A KEY AT WHICH TO START PROCESSING.
*-        OR STKY =            DEFAULT IS NO ACTION TAKEN.
*-        OR H    =
*-
*-   *I.  ENDKEY  =            A KEY AT WHICH TO END PROCESSING.
*-        OR NDKY =            DEFAULT IS NO ACTION TAKEN.
*-        OR I    =
*-
*-   *J.  SKIPKEY  =           A KEY THAT INDICATES WHICH INPUT
*-        OR SKKY  =           RECORDS WILL BE SKIPPED.  DEFAULT IS NO
*-        OR J     =           ACTION TAKEN.
*-
*-   *K.  ALLKEY  =            A KEY THAT INDICATES WHICH RECORDS ARE
*-        OR ALKY =            TO BE SELECTED FOR OUTPUT;  RECORDS
*-        OR K    =            WITHOUT THIS KEY ARE IGNORED.  DEFAULT
*-                             IS NO ACTION TAKEN.
*-
*-    L.  RKP     =            THE RELATIVE KEY POSITION OF A
*-        OR L    =            LOGICALLY CONSTRUED KEY FOR A
*-                             PHYSICAL SEQUENTIAL DATA SET.  THE
*-                             KEYWORD IS REQUIRED OF A STARTKEY,
*-                             ENDKEY, SKIPKEY OR ALLKEY SUB-
*-                             PARAMETER IS INCLUDED AND THE LOGICAL
*-                             KEY BEGINS IN OTHER THAN THE FIRST
*-                             POSITION OF THE RECORD.  IF THE
*-                             RECORD IS VARIBLE THEN RKP MUST
*-                             INCLUDE THE 4 BYTES FOR THE RECORD
*-                             DESCRIPTOR WORD.  DEFAULT VALUE IS 0.
*-                             RKP IS OBTAINED FROM THE DATA SET
*-                             LABEL FOR INDEXED SEQUENTIAL DATA
*-                             SETS.
*-
*-    M.  MAXIOERR =           NUMBER OF I/O ERRORS TO BE ACCEPTED
*-        OR IOER              BEFORE TERMINATION WITH RETURN CODE
*-                             16.  DEFAULT VALUE IS 0.
*-
*-    N.  MXRECERR =           NUMBER OF ERROR MESSAGES PER RECORD
*-        OR RCER  =           WHEN BA OR BE IS SPECIFIED.  DEFAULT
*-                             VALUE IS 20.
*-    O.  MODNAME =            NAME OF MODIFICATION ROUTINE IN
*-        OR MNM  =            STEPLIB TO BE LOADED TO PERFORM
*-                             RECORD MODIFICATIONS.  SEE SUB-
*-                             SECTION ENTITLED MODIFICATION ROUTINES
*-                             ON NEXT PAGE.  DEFAULT IS NO ACTION
*-                             TAKEN.
*-
*-    P.  TRNAME  =            NAME OF THE TRANSLATE TABLE TO BE
*-        OR TNM  =            LOADED FROM STEPLIB; USED IN
*-                             CONJUNCTION WITH AND HAS THE SAME
*-                             MEANING AS TYPE-TR, TYPE-BE, OR
*-                             TYPE=BA.  DEFAULT IS NO ACTION TAKEN.
*-
*-    Q.  CMPRESS  = NO        DEFAULT IS NO DATA COMPRESSION.
*-        OR CMP   = YES       RECORDS WILL HAVE ALL BLANKS, LOW-
*-                             VALUES, OR REPEATED STRINGS OF
*-                             CHARACTERS COMPRESSED.  RECFM, LRECL,
*-                             AND BLKSIZE MUST BE SPECIFIED ON THE
*-                             SYSUT2 DD STATEMENT.  THE OUTPUT
*-                             RECORD FORMAT MUST BE VARIABLE TO TAKE
*-                             ADVANTAGE OF THE COMPRESSED RECORDS
*-                             WHICH WILL BE VARIABLE IN LENGTH.
*-
*-
*-    R.  EXPAND  = NO         DEFAULT IS NO DATA EXPANSION.
*-        OR EXP  = YES        DATA RECORDS THAT HAVE BEEN PREVIOUSLY
*-        OR N    =            COMPRESSED, USING THE CMPRESS=YES
*-                             OPTION, WILL BE EXPANDED TO THEIR FORM
*-                             PRIOR TO COMPRESSION.  ANY RECORD NOT
*-                             PREVIOUSLY COMPRESSED WILL REMAIN
*-                             UNCHANGED.  RECFM, LRECK. AND BLKSIZE
*-                             MUST BE SPECIFIED ON THE SYSUT2 DD
*-                             STATEMENT.
*-
*-        SYSUT1  =            NAME OF AN ALTERNATE DDNAME.
*-        OR O    =
*-
*-        SYSUT2  =            NAME OF AN ALTERNATE DDNAME.
*-        OR P    =
*-
*-
*-*FOR PHYSICALLY SEQUENTIAL DATA SETS THESE KEYS CAN BE OF DIFFERENT
*- LENGTHS.
*-
*-
*-ALL OF THE ABOVE KEYWORD SUBPARAMETERS MAY BE USED IN ANY ORDER OR
*-COMBINATIONS; NONE ARE MUTUALLY EXCLUSIVE.  HOWVER, SOME KEYWORDS
*-TAKES PRECEDENCE OVER OTHERS.  THE ORDER OF PRECEDENCE AMONG THE
*-RELEVENT KEYWORDS IS IN HIGHEST PRECEDENCE FROM TOP TO BOTTOM AS
*-LISTED:
*-
*-STOP
*-LAST
*-SKIP
*-STARTKEY
*-SKIPKEY
*-ALLKEY
*-ENDKEY
*-START
*-
*-A GIVEN KEYWORD SUBPARAMETER CANNOT BE USED MORE THAN ONCE.
*-
*-NARRATIVE:  MODIFICATION ROUTINES:
*-
*-AN EXIT ROUTINE WRITTEN IN COBOL MAY BE LOADED TO PROCESS EACH
*-INPUT RECORD.  THE ADDRESS PASSED TO THE EXIT ROUTINE ARE:
*-
*-1.  ADDRESS OF INPUT/OUTPUT AREA
*-2.  ADDRESS OF HALF-WORD FOR ENTRY-CODE AND RETURN CODE
*-3.  ADDRESS OF A HALF-WORD FOR LENGTH OF RECORD
*-
*-THE ANS COBOL EXIT ROUTINE IS CODED AS FOLLOWS:
*-
*-IDENTIFICATION DIVISION.
*-PROGRAM-ID.  PGMNAME.
*-ENVIRONMENT DIVISION.
*-DATA DIVISION.
*-LINKAGE SECTION.
*-01 RECORD-AREA.
*-   02 ENTRIES
*-01 ENTRY-RETURN-CODE PICTURE S99 USAGE COMPUTATIONAL.
*-01 REC-LENGTH PICTURE S99 USAGE COMPUTATIONAL.
*-PROCEDUR DIVISION USING RECORD-AREA, ENTRY-RETURN-CODE, REC-LENGTH.
*-
*-PROCEDURE DIVISION STATEMENTS TO EDIT OR MODIFY THE RECORD IN RECORD-
*-AREA.
*-.
*-
*-.
*-
*-MOVE NN TO ENTRY-RETURN-CODE.
*-GOBACK.
*-
*-THE SIZE OF THE INPUT RECORD IN RECORD-AREA IS IN LENGTH AT ENTRY.
*-IF THE LENGTH OF THE RECORD IS CHANGED BY THE EXIT ROUTINE, THE
*-NEW SIZE MUST NOT EXCEED FOUR TIMES THE SIZE OF THE INPUT RECORD.
*-
*-THE VALUE OF THE ENTRY-RETURN-CODE UPON ENTRY TO THE EXIT ROUTINE IS:
*-
*-  0 IF A RECORD IS AVAILABLE IN RECORD-AREA
*-  8 IF NO RECORD IS AVAILABLE (SYSUT1 END-OF-DATA-SET)
*-
*-A RETURN CODE MUST BE PLACED IN ENTRY-RETURN-CODE PRIOR TO RETURNING
*-TO DSUTIL.  THE MEANINGS OF THE RETURN CODE VALUES ARE:
*-
*-  0 THE RECORD IN RECORD-AREA IS TO BE ACCEPTED (MAY OR MAY NOT HAVE
*-    BEEN MODIFIED.)
*-  4 DELETE THE RECORD IN RECORD-AREA.
*-  8 DO NOT CALL THIS EXIT AGAIN (END OF DATA SET ON SYSUT1)
*- 12 A NEW RECORD HAS BEEN PLACED IN RECORD-AREA TO BE INSERTED
*-    BEFORE THE CURRENT RECORD (DSUTIL WILL PLACE THE CURRENT RECORD
*-    BACK IN RECORD-AREA WHEN IT CALLS THIS EXIT ROUTINE AGAIN).
*-
*-JCL EXAMPLES
*-
*-1.  COPY A CATALOGED DATA SET
*-
*-    //COPY EXEC PGM=DSUTIL
*-    //SYSUT1 DD DSN=DSNAME,DISP=OLD
*-    //SYSUT2 DD DSN=DSNAME,DISP=(,CATLG),UNIT=UNIT,VOL=SER=SER,
*-    //SPACE=SPACE
*-
*-2.  CREATE AN ISAM DATA SET FROM A PHYSICAL SEQUENTIAL INPUT DATA
*-    SET AND EDIT EACH RECORD WITH A COBOL EXIT ROUTINE NAMED COBXIT
*-    WHICH HAS BEEN COMPILED AND LINKED INTO TEST.LINKLIB
*-
*-    //CREATE EXEC PGM=DSUTIL,PARM='MODNAME'COBXIT'
*-    //STEPLIB DD DNS=TEST.LINKLIB,DISPR=SHR
*-    //SYSUT1 DD DSN=DSNAME,DISP=OLD
*-    //SYSUT2 DD DSN=DSNAME,UNIT=UNIT,SPACE=SPACE,
*-    //VOL=SER=SER,DCB=(DSORG=IS,RKP=N,KEYLEN=N,CYLOFL=N)
*-
*-3.  DUPE A CARD DECK AND TRANSLATE ALL BLANKS (B/) TO ZEROS AND ALL
*-    + SIGNS TO - SIGNS.
*-
*-    //XLATE EXEC PGM=DSUTIL,PARM='TYPE=TR'
*-    //SYSUT2 DD SYSOUT=B
*-    //SYSIN DD*
*-          +B/
*-          -O
*-    /*
*-    //SYSUT1 DD *
*-         DATA
*-         .
*-         .
*-         .
*-    /*
*-
*-4.  SEARCH A CATALOGED ISAM DATA SET AND PRINT, IN HEX, ALL RECORDS
*-    WHICH HAVE A PARTIAL KEY BEGINNING WITH "A".
*-
*-    //PRT EXEC PGM=DSUTIL,PARM=('ALLKEY=A','SYSPRINT=99999')
*-    //SYSPRINT DD SYSOUT=A
*-    //SYSUT1 DD DSN=DSNAME,DISP=OLD
*-
*-5.  PRINT THE LAST 10 RECORDS OF A DATA SET.
*-
*-    //PRT10 EXEC PGM=DSUTIL,PARM='LAST=10'
*-    //SYSUT1 DD DSN=DSNAME,DISP=OLD
*-    //SYSUT2 DD SYSOUT=A
*-
*-RESOURCE REQUIREMENTS
*-
*-  12K MAIN STORAGE; UNITS(S) FOR INPUT AND OUTPUT DATA SETS.
*-
       EJECT
***********************************************************************
*                      LINKAGE MACRO                                  *
***********************************************************************
         MACRO
&NAME    LINKAGE &TYPE=CSECT,&BASE=12,&ARG=2,&SAVE=,&GET=
         LCLA  &N
         AIF   ('&TYPE(1)' EQ 'ENTRY').ENTRY
&NAME    CSECT
         AGO   .BR
.ENTRY   AIF   ('&NAME' EQ '').NOID1
         ENTRY &NAME
.NOID1   ANOP
&NAME    DS    0D
.BR      AIF   (N'&BASE GE 1).BASE
         USING *,15
         AGO   .NAME
.BASE    USING *,&BASE
         USING NEXTGET,12
.NAME    AIF   ('&NAME' EQ '').NOID
         B     14(,15) BRANCH AROUND ID
         DC    X'9',CL9'&NAME' ID
.NOID    STM   14,12,12(13) SAVE REGISTERS
         AIF   ('&ARG(1)' EQ '').ARG0
         LR    &ARG(1),1
.ARG0    AIF   ('&ARG(2)' EQ '').BASE1
         LR    &ARG(2),0
.BASE1   AIF   (N'&BASE EQ 0).SAVE1
         LR    &BASE(1),15 BASE REG
         LA    12,(NEXTGET-&NAME)(11)
         AIF   (N'&BASE EQ 1).SAVE1
         LA    1,1
&N       SETA  2
.BASE2   LA    &BASE(&N),X'FFF'(1,&BASE(&N-1))
&N       SETA  &N+1
         AIF   (&N LE N'&BASE).BASE2
.SAVE1   AIF   ('&SAVE' EQ '').GETSAVE
         AIF   ('&GET' NE '').GETWORK
         LA    1,&SAVE
         USING &SAVE,13 BASE REG FOR WORK AREA
         AGO   .FWDCHN
.GETWORK GETMAIN R,LV=&GET GET STG FOR REG SAVE AND WORK
         USING &SAVE,13 BASE REG FOR WORK AREA
         AGO   .FWDCHN
.GETSAVE GETMAIN R,LV=72
.FWDCHN  ST    1,8(0,13) FORWARD CHAIN
         ST    13,4(0,1) BACK CHAIN
         LR    13,1 NEW SAVE AREA
         LR    1,2  RESTORE R1
         SPACE
         MEND
         EJECT
***********************************************************************
*                      EXITLKG MACRO                                  *
***********************************************************************
         MACRO
&NAME    EXITLKG &T,&RC=0,&SAVE=,&FREE=
&NAME    L     13,4(0,13) PTR TO PREV SAVE
         L     14,12(0,13) RESTORE RETURN
         LM    2,12,28(13) RESTORE REGS 2-12
         AIF   ('&SAVE' NE '' AND '&FREE' EQ '').GOBACK
         STM   14,15,12(13)   SAVE 14 AND 15
         L     1,8(,13) PTR TO AREA TO FREE
         LA    1,0(,1)
         AIF   ('&FREE' EQ '').FREE72
         LA    0,&FREE SIZE OF REG SAVE AND WORK
         AGO   .FREE
.FREE72  LA    0,72(0,0) SIZE OF REG SAVE AREA
.FREE    FREEMAIN R,LV=(0),A=(1)
         LM    14,15,12(13)
.GOBACK  RETURN ,&T,RC=&RC
         SPACE
         MEND
         EJECT
***********************************************************************
*                    REGISTER USAGE                                   *
***********************************************************************
*                            R0  WORK
*                            R1  WORK
*                            R2  WORK FOR PARM
*                            R3  WORK FOR PARM
*                            R4  PTR TO INPUT DCB
*                            R5  PTR TO OUTPUT DCB
*                            R6  PTR TO INPUT RECORD
*                            R7  # BYTES LEFT TO BE PRINTED
*                            R8  PTR TO PRINT RECORD
*                            R9  # LINES LEFT ON PAGE
*                            R10 WORK FOR HEX LINE
*                            R11 WORK FOR HEX LINE
*                            R12 BASE REG
*
***********************************************************************
*             PARM FIELD KEYWORD DESCRIPTIONS                         *
***********************************************************************
*
*LEN KEYWORD  PROGRAM  DEFAULT DOC COMMENTS
*             SYMBOL   VALUE   FLD
* * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *
*  2 TYPE     PRNTPARM HX      E   SELECTS INTERNAL RECORD PROCESSING
*  8 LINES    #LINES   P'59'   G   # OF LINES PRINTED PER PAGE
* 15 STOP     MAXACCPT P'9'    J   MAX # OF RECORDS ACCEPTED FOR OUTPUT
*256 STARTKEY STARTKEY X'0'    K1  STARTIG KEY FOR OUTPUT (IS OR PS)
*  2 RKP      PSPOS    X'0'    H   RELATIVE KEY POSITION (PS ONLY)
*  4 SYSPRINT MXTOTREC P'0'    K   # OF RCDS TO BE PRINTED (SYSPRINT)
*  4 START    #START   P'0'        START OUTPUT AFTER N LOGICAL RCDS
*  4 SKIP     SKIPST & SKIPND P'0' DON'T OUTPUT REC # N OR N THRU N+M
*  8 LAST     LAST     P'0'        OUTPUT ONLY THE LAST N RECORDS
*  4 MAXIOERR MAXIOERR P'0'    D   MAX I/O ERRS BEFORE QUIT WITH RC=16
*  8 MODNAME  MODNAME  BLANK   C   NAME OF MODIFICATION RTN (//STEPLIB)
*  8 TRNAME   TRNAME   BLANK   F   TRANSLATE TABLE NAME (//STEPLIB)
*  4 MXRECERR MXRECERR P'0'    I   # OF ERR MSGS/REC WHEN TYPE=BA OR BE
*256 ENDKEY   ENDKEY   X'0'        ENDING KEY FOR OUTPUT (IS OR PS)
*256 ALLKEY   ALLKEY   X'0'        OUTPUT ALL RCDS,THIS KEY ONLY (IS,PS
*256 SKIPKEY  SKIPKEY  X'0'        DON'T OUTPUT RCDS, THIS KEY (IS,PS)
*  1 ABEND    ABEND    X'0'       ABEND WITH U0016 AT END OF JOB
*  8 EXITNAME EXITNAME E15COBOL    NAME OF EXIT RTN FOR COBOL INTERFACE
*  1 COMPRESS COMPRESS C'N'        COMPRESS OPTION
*  1 EXPAND   EXPAND   C'N'        EXPAND OPTION
***********************************************************************
         EJECT
DSUTIL   LINKAGE SAVE=SAVEAREA,GET=2048,BASE=11
         ST    13,SAVE13
R0       EQU   0
R1       EQU   1
R2       EQU   2
R3       EQU   3
R4       EQU   4
R5       EQU   5
R6       EQU   6
R7       EQU   7
R8       EQU   8
R9       EQU   9
R10      EQU   10
R11      EQU   11
R12      EQU   12
R13      EQU   13
R14      EQU   14
R15      EQU   15
  EJECT
***********************************************************************
*                 SCAN PARM KEYWORDS                                  *
***********************************************************************
         KWPARM PARMS=18
         SPACE 5
         LA    R1,PARM1     SET PARM TO DSHEX
         L     R15,=V(DSHEX)  CONVERT ANY X'...'  TO TRUE HEX STRING
         BALR  R14,R15
  EJECT
***********************************************************************
*          SET UP SAVE AREA ACCORDING TO DSECT SPECIFICATIONS         *
***********************************************************************
         XC    WORK(256),WORK          CLEAR WORK AREA
         XC    WORK+256(256),WORK+256
         XC    WORK+512(256),WORK+512
         XC    WORK+768(256),WORK+768
         XC    WORK+1024(256),WORK+1024
         XC    WORK+1280(256),WORK+1280
         XC    WORK+1536(256),WORK+1536
         XC    WORK+1792(184),WORK+1792
         ZAP   #LINES,=P'59'           SET FOR 59 LINES PER PAGE
         ZAP   MXTOTREC,=P'0'          ONLY MSG UNLESS PARM VALUE 3 ..4
         ZAP   MXRECERR,=P'20'
         ZAP   #IOERRS,=P'0'
         ZAP   MAXIOERR,=P'0'
         ZAP   #START,=P'0'
         ZAP   RECCTR,=P'0'
         ZAP   RECINSRT,=P'0'
         ZAP   RECDLETE,=P'0'
         ZAP   RECOUT,=P'0'
         ZAP   MAXACCPT,=P'999999999999999'
         ZAP   LAST,=P'0'
         ZAP   LASTSV,=P'0'
         ZAP   SKIPST,=P'0'
         ZAP   SKIPND,=P'0'
         MVC   MODNAME,BLANKS
         MVC   TRNAME,BLANKS
         MVC   PTRVALID,=A(VALIDTBL)
         MVC   PTRXLATE,=A(XTABLE)
         MVI   CORECOM,C'N'
         MVI   COREEXP,C'N'
IN       EQU   4
OUT      EQU   5
         SPACE 4
***********************************************************************
*                       OPEN PRINTER                                  *
***********************************************************************
         LA    R9,1             1ST LINE ON NEW PAGE
         OPEN  (PRINT,OUTPUT)
         BAL   R14,PRINTIT      OBTAIN ADDR OF PRINT BUFFER
         EJECT
***********************************************************************
*                     SCAN PARM TABLE ROUTINE                         *
*     TO DETERMINE IF KEY IS SUPPLIED & IF RKP IS SUPPLIED            *
*     PACK IT AND SAVE                                                *
***********************************************************************
         LA    R2,PARM1            PT R2 TO PARM LIST
KWPRE1   EQU   *
         CLC   0(8,R2),=CL8'RKP'
         BE    FNDRKP
         CLC   0(8,R2),=CL8'L'     L IS AN RKP ALIAS
         BE    FNDRKP
         CLC   0(8,R2),=CL8'STARTKEY'
         BNE   KWPRE5
         MVI   KEYIN,C'Y'
KWPRE5   EQU   *
          CLC   0(8,R2),=CL8'SYSUT1'
          BE    KWPREY       B. IF KW FOUND
          CLC   0(8,R2),=CL8'O'
          BE    KWPREY
          CLC    0(8,R2),=CL8'SYSUT2'
          BE    *+14
          CLC   0(8,R2),=CL8'P'
          BNE   KWPREX      B. IF NOT SYSUT1 OR 2
          LA    R3,SYSUT2
          L     R4,=A(OUTDCB)
          L     R5,=A(OUTIS)
          B     KWPREZ
KWPREY    LA    R3,SYSUT1
          L     R4,=A(PSDCB)
          L     R5,=A(ISDCB)
KWPREZ    SR    R1,R1
          IC    R1,8(R2)
          L     R14,8(R2)
          MVC   0(8,R3),BLANKS
          MVC   40(8,R4),BLANKS
          MVC   40(8,R5),BLANKS
          EX    R1,KWPMVC1
          EX    R1,KWPMVC2
          EX    R1,KWPMVC3
KWPREX    EQU   *
         CLC   0(8,R2),BLANKS      END OF PARM LIST ?
         BE    KWPREDNE             YES
         LA    R2,12(R2)
         B     KWPRE1
FNDRKP   EQU   *
         SR    R1,R1               ZERO R1
         IC    R1,8(0,R2)          R1 = KEYWORD VALUE LENGTH CODE
         L     R8,8(0,R2)          R8 = A(KEYWORD VALUE)
         LA    R14,KWRET
         BAL   R7,NUMERIC
         B     KWERR2              NOT NUMERIC, PRINT ERR
         EX    R1,PACKPOS          PACK RKP
         CVB   R1,WORK
         STH   R1,PSPOS            SAVE IT
KWRET    LA    R2,12(R2)
         B     KWPRE1
KWPREDNE EQU   *
   EJECT
***********************************************************************
*               DSORG ON SYSUT1 AND SYSUT2                            *
***********************************************************************
         SPACE
***********************************************************************
* READ SYSUT1 JFCB FOR DSORG DETERMINATION
         RDJFCB MF=(E,RDJFCB1)
         LTR   R15,R15            SYSUT1 DD STATEMENT PRESENT
         BNZ   NOSYSUT1
         MVC   JFCBDSN1,JFCB1
         MVC   MEMBER1,JFCBMEM1    SAVE PDS MEMBER NAME
         CLI   DSORG1,X'00'        DSORG ON DD?
         BE    DTYPE1               NO
         TM    DSORG1,X'80'        DSORG = IS?
         BO    ISDSORG1             YES
         B     PSDSORG1             NO
         SPACE
**********************************************************************
DTYPE1   EQU   *
         DEVTYPE SYSUT1,SYSUT1A
         TM    DEVTYPE1,X'20'      DEV TYPE = DISK?
         BNO   PSDSORG1             NO
         OBTAIN DSCB1
         LTR   R15,R15             OBTAIN SUCCESSFUL?
         BNZ   OBTAIN1              NO
OK1      TM    DSCBDSOR,X'80'      DSORG = IS?
         BO    ISDSORG1             YES
PSDSORG1 EQU   *
         L     IN,=A(PSDCB)        SET FOR PS INPUT
         B     JFCBCNT1
         SPACE
**********************************************************************
ISDSORG1 EQU   *
         CLI   KEYIN,C'Y'          IS KEY SUPPLIED ?
         BNE   NOKEYTYP             NO
         MVI   KEYTYPE,C'K'        INDICATES IS KEY IS  USED
NOKEYTYP EQU   *
         L     IN,=A(ISDCB)        SET FOR IS INPUT
JFCBCNT1 EQU   *
         SPACE
*********************************************************************
*   READ SYSUT2 JFCB FOR DSORG DETERMINATION
         RDJFCB MF=(E,RDJFCB2)
         MVC   JFCBDSN2,JFCB2
         MVC   MEMBER2,JFCBMEM2    SAVE PDS MEMBER NAME
         CLI   JFCB2,X'00'         IS THERE A SYSUT2 DD?
         BE    JFCBCNT2             NO
         CLI   DSORG2,X'00'        DSORG ON DD ?
         BE    DTYPE2               NO
         TM    DSORG2,X'80'        DSORG = IS?
         BO    ISDSORG2             YES
         B     PSDSORG2             NO
         SPACE
***********************************************************************
DTYPE2   EQU   *
         TM    JFCDISP2,X'C0'      DISP = NEW?
         BO    NEWDISP2             YES
         DEVTYPE SYSUT2,SYSUT2A
         TM    DEVTYPE2,X'20'      DEV TYPE = DISK?
         BNO   PSDSORG2             NO
         OBTAIN DSCB2
         LTR   R15,R15             OBTAIN SUCCESSFUL?
         BNZ   OBTAIN2              NO
OK2      TM    DSCBDSOR,X'80'      DSORG = IS?
         BO    ISDSORG2             YES
         TM    DSCBDSOR,X'02'     IS DSORG=PO ?
         BZ    PSDSORG2           B. IF NOT
         CLI   MEMBER2,C' '
         BNE   PSDSORG2           B. IF MEMBER PRESENT
         LA    R15,24             SET UP RC
         B     OBTAIN2            PRINT ERROR
NEWDISP2 EQU   *
         TM    DSORG2,X'80'        DSORG = IS ?
         BO    ISDSORG2             YES
         SPACE
***********************************************************************
PSDSORG2 EQU   *
         L     OUT,=A(OUTDCB)      SET FOR PS OUTPUT
         B     JFCBCNT2
ISDSORG2 EQU   *
         L     OUT,=A(OUTIS)       SET FOR IS OUTPUT
         B     JFCBCNT2
         SPACE
**********************************************************************
*   ERROR ROUTINES FOR SYSUT1 AND SYSUT2
         SPACE
NOSYSUT1 L      R1,PRINTBUF        R1=A(PRINT BUFFER)
         MVC   0(L'NOSYS1,R1),NOSYS1
         B     ERRPRT
         SPACE
OBTAIN1  L     R1,PRINTBUF         R1=A(PRINT BUFFER)
         MVC   0(7,R1),MSYSUT1      'SYSUT1' TO MESSAGE
         B     *+4(R15)
         B     OK1                 NO ERROR
         B     MOUNT               VOLUME NOT MOUNTED
         B     NODSCB              DATASET NOT IN VTOC
         B     IOERR               PERMANENT I/O ERROR
         B     INTERN              INVALID WORK AREA PTR.
         B     SHUDNOT             INVALID CCHH (SEEK MODE ONLY)
         SPACE
OBTAIN2  L     R1,PRINTBUF         R1=A(PRINT BUFFER)
         MVC   0(7,R1),MSYSUT2      'SYSUT2' TO MESSAGE
         B     *+4(R15)
         B     OK2
         B     MOUNT                VOLUME NOT MOUNTED
         B     NODSCB               DATASET NOT IN VTOC
         B     IOERR                PERMANENT I/O ERROR
         B     INTERN               INVALID WORK AREA PTR.E
         B     SHUDNOT              INVALID CCHH (SEEK MODE ONLY)
         B     @UT2NOM
         SPACE
MOUNT    MVC 8(L'MT,R1),MT          MESSAGES TO BUFFER
         B     ERRPRT
NODSCB   MVC   8(L'DSCB,R1),DSCB
         B     ERRPRT
IOERR    MVC   8(L'IO,R1),IO
         B     ERRPRT
INTERN   MVC   8(L'IN,R1),INVAL
         B     ERRPRT
SHUDNOT  MVC   8(L'SH,R1),SH
         B     ERRPRT
@UT2NOM  MVC   8(L'UT2NOM,R1),UT2NOM
         B     ERRPRT
         SPACE
NOSYS1   DC    C'1NO SYSUT1 DD STATEMENT'
MT       DC    C'VOLUME NOT MOUNTED'
DSCB     DC    C'DATASET NOT FOUND'
IO       DC    C'PERMANENT I/O ERROR'
INVAL    DC    C'INVALID WORK AREA...SEE SYSTEMS PROGRAMMING'
SH       DC    C'INVALID CCHH...SEE SYSTEMS PROGRAMMING'
MSYSUT1   DC    C'1SYSUT1'
MSYSUT2   DC    C'1SYSUT2'
UT2NOM   DC    C'NO MEMBER'
         SPACE
ERRPRT   BAL   R14,PRINTIT
         L     R2,=A(ENDMSG32)
         MVC   0(L'ENDMSG32,R1),0(R2)  END DSUTIL NOT SUCCESSFUL
         CLOSE PRINT
         B     ERETURN
  EJECT
***********************************************************************
*             KEYWORD BRANCH ROUTINE (USES R2 & R3)                   *
***********************************************************************
JFCBCNT2 EQU   *
         LA    R2,PARM1            PT R2 TO PARM LIST
KWOVR    EQU   *
         L     R3,=A(KWNAMES)      PT R3 TO KEYWORD NAME BRANCH LIST
KWOVR1   EQU   *
         CLC   0(8,R2),0(R3)       PARM KEYWORD = BR LIST KEYWORD ?
         BE    KWMATCH              YES, GO BR
         CLC   0(8,R2),BLANKS      END OF PARM LIST ?
         BE    PARMDONE             YES, GO TO PARMDONE
         CLC   0(8,R3),BLANKS      END OF KEYWORD BRANCH LIST ?
         BE    KWERR1               YES, PRINT ERROR MSG
         LA    R3,12(R3)           LOOK AT NEXT BR LIST KEYWORD
         B     KWOVR1              DO LOOP AGAIN
KWMATCH  EQU   *
         SR    R1,R1               CLEAR R1
         IC    R1,8(0,R2)          INSERT KEYWORD VALUE LENGTH CODE
         L     R8,8(0,R2)          R8 = A(KEYWORD VALUE)
         L     R15,8(0,R3)         *
         BALR  R14,R15             * BR TO BR LIST ROUTINE
         LA    R2,12(R2)           LOOK AT NEXT PARM KEYWORD
         B     KWOVR               DO IT ALL OVER
  EJECT
***********************************************************************
*                   KEYWORD ROUTINES                                  *
***********************************************************************
AABEND   EQU   *
         MVI   ABENDCDE,X'16'      SET EOJ ABEND
         BR    R14                 RETURN
ATYPE    EQU   *
         MVC   PRNTPARM,0(R8)      MOVE PRINT OPTION
         BR    R14                 RETURN
ALINES   EQU   *
         BAL   R7,NUMERIC
         B     KWERR2              NOT NUMERIC, PRINT ERROR
         EX    R1,PACKLINE         SET NR LINES PER PAGE
         BR    R14                 RETURN
ASTOP    EQU   *
         BAL   R7,NUMERIC
         B     KWERR2              NOT NUMERIC, PRINT ERROR
         EX    R1,PACKACPT         MAX NR OF REC ACCEPTED BY PROGRAM
         BR    R14                 RETURN
ASTARTKE EQU   *
         EX    R1,MVCSTKY          MOVE KEY TO AREA - TRAILING ZEROS
         STC   R1,PSCLC2+1         SET KEY LENGTH CODE
         STC   R1,STKYLEN          SAVE KEY LENGTH
         MVC   WORK(2),PSPOS       USE WORK AREA
         OC    WORK(1),PSCLC2+2    OR IN BASE REG
         MVC   PSCLC2+2(2),WORK    SET RKP FOR KEY COMPR
         LA    R1,1(R1)            LENGTH = LENGTH CODE + 1
         STC   R1,KEYLENTH         SAVE KEY LENGTH
         MVI   BKWTST2+1,X'00'     NOP THE BRANCH AROUND KEY COMPR
         BR    R14                 RETURN
ARKP     EQU   *   DUMMY RTN SINCE RKP KEYWORD IS TESTED 1ST
         BR    R14                 RETURN
ASYSPRIN EQU   *
         CLC   0(3,R8),=C'TSO'     IF PARM "SYSPRINT=TSO", ALL
         BNE   ANUM                ...SYSPRINT OUTPUT VIA TPUT.
         MVC   SYSPRINT(3),=C'TSO'
         BR    R14
ANUM     BAL   R7,NUMERIC
         B     KWERR2              NOT NUMERIC, PRINT ERROR
         EX    R1,PACKTPRT         PACK MAX OUTPUT RECORDS FOR SYSPRINT
         EX    R1,PACKSYSP         PACK & SAVE FOR EOJ STATS.
         BR    R14                 RETURN
ASTART   EQU   *
         BAL   R7,NUMERIC
         B     KWERR2              NOT NUMERIC, PRINT ERROR
         EX    R1,PACKSTRT         PACK # OF RCDS SKIPPED BEFORE OUTPUT
         BR    R14                 RETURN
ASKIP    EQU   *
         LR    R6,R8
         LR    R3,R1
         LA    R3,1(R3)
ASKIP1   EQU   *
         CLI   0(R6),C'-'          DASH FOUND ?
         BE    ASKIP2               YES
         LA    R6,1(R6)            BUMP PARM PTR
         BCT   R3,ASKIP1           DECR PARM LENGTH CTR
         BAL   R7,NUMERIC
         B     KWERR2              NOT NUMERIC, PRINT ERROR
         EX    R1,PACKSKST         PACK REC # TO BE SKIPPED
         EX    R1,PACKSKND
         BR    R14
ASKIP2   EQU   *
         LR    R6,R1               SAVE R1 LENGTH CODE
         SR    R1,R3               SKIP START LENGTH CODE
         BAL   R7,NUMERIC
         B     KWERR2              NOT NUMERIC, PRINT ERROR
         EX    R1,PACKSKST         PACK START REC # TO BE SKIPPED
         AR    R8,R1
         LA    R8,2(R8)            PT TO SKIP END REC #
         LR    R1,R6               *
         SR    R6,R3               *
         LA    R6,2(R6)            *
         SR    R1,R6               * COMPUTE LENGTH CODE
         BAL   R7,NUMERIC
         B     KWERR2              NOT NUMERIC, PRINT ERROR
         EX    R1,PACKSKND
         BR    R14
ALAST    EQU   *
         BAL   R7,NUMERIC
         B     KWERR2              NOT NUMERIC, PRINT ERROR
         EX    R1,PACKLAST         PACK # OF RECS TO BE OUTPUT AT THE
         ZAP   LASTSV,LAST         SAVE FOR EOJ STATS.
         BR    R14                      END OF THE DATA SET
AMAXIOER EQU   *
         BAL   R7,NUMERIC
         B     KWERR2              NOT NUMERIC, PRINT ERROR
         EX    R1,PACKIOER         PACK MAX I/O ERRS ACCEPTED
         BR    R14                 RETURN
AMODNAME EQU   *
         MVC   MODNAME(8),BLANKS
         CLI   0(R8),C'A'          CHECK FOR NAME 1ST CHAR ALPHA
         BL    KWERR3
         CLI   0(R8),C'Z'
         BH    KWERR3
         CH    R1,=H'8'
         BL    *+8                 LENGTH OK
         LA    R1,7                TOO LONG - TRY FIRST 8
         EX    R1,MOVEMODN         SAVE MOD RTN NAME
         LOAD  EPLOC=EXITNAME
         ST    R0,PTRMOD           STORE ADDR OF MOD RTN LOADED
         BR    R14                 RETURN
ATRNAME  EQU   *
         CLI   0(R8),C'A'          CHECK FOR NAME 1ST CHAR ALPHA
         BL    KWERR3
         CLI   0(R8),C'Z'
         BH    KWERR3
         CH    R1,=H'8'
         BL    *+8                 LENGTH OK
         LA    R1,7                TOO LONG - TRY 1ST 8
         EX    R1,MOVETRNM         SAVE TRANSLATE TABLE NAME
         LOAD  EPLOC=TRNAME
         ST    R0,PTRVALID
         ST    R0,PTRXLATE
         BR    R14                 RETURN
AMXRECER EQU   *
         BAL   R7,NUMERIC
         B     KWERR2              NOT NUMERIC, PRINT ERROR
         EX    R1,PACKERMS         PACK # OF ERR MSG PER RECORD
         BR    R14                 RETURN
AENDKEY  EQU   *
         EX    R1,MVCNDKY          MOVE KEY TO AREA
         STC   R1,PSCLC5+1         SET KEY LENGTH CODE
         STC   R1,NDKYLEN          SAVE KEY LENGTH
         MVC   WORK(2),PSPOS       USE WORK AREA
         OC    WORK(1),PSCLC5+2    OR IN BASE REG
         MVC   PSCLC5+2(2),WORK    SET RKP FOR KEY COMPR
         MVI   BKWTST5+1,X'00'     NOP THE BRANCH AROUND KEY COMPR
         BR    R14                 RETURN
AALLKEY  EQU   *
         EX    R1,MVCALKY
         STC   R1,PSCLC4+1
         STC   R1,ALKYLEN          SAVE KEY LENGTH
         MVC   WORK(2),PSPOS
         OC    WORK(1),PSCLC4+2
         MVC   PSCLC4+2(2),WORK
         MVI   BKWTST4+1,X'00'
         BR    R14
ASKIPKEY EQU   *
         EX    R1,MVCSKKY          MOVE KEY TO AREA
         STC   R1,PSCLC3+1         SET KEY LENGTH CODE
         STC   R1,SKKYLEN          SAVE KEY LENGTH
         MVC   WORK(2),PSPOS       USE WORK AREA
         OC    WORK(1),PSCLC3+2    OR IN BASE REG
         MVC   PSCLC3+2(2),WORK    SET RKP FOR KEY COMPR
         MVI   BKWTST3+1,X'00'     NOP THE BRANCH AROUND KEY COMPR
         BR    R14                 RETURN
AEXITNAM EQU   *
         MVC   EXITNAME(8),BLANKS
         EX    R1,MOVEXITN        MOVE  EXIT RTN NAME
         BR    R14                 RETURN
ACOMPRES EQU   *
         CLI   0(R8),C'Y'          COMPRESS OPTION?
         BNE   ACOMPRE1             NO
         MVC   COMPRESS,=C'YES'    SET COMPRESS FLAG
ACOMPRE1 EQU   *
         BR    R14                 RETURN
AEXPAND  EQU   *
         CLI   0(R8),C'Y'          EXPAND OPTION?
         BNE   AEXPAND1             NO
         MVC   EXPAND,=C'YES'      SET EXPAND FLAG
AEXPAND1 EQU   *
         BR    R14                 RETURN
KWPUT1X   EQU  *
KWPUT2X   BR   R14
        EJECT
***********************************************************************
*                   EXECUTE INSTRUCTIONS                              *
***********************************************************************
MOVEXITN MVC   EXITNAME(0),0(8)
PACKLINE PACK  #LINES,0(0,8)
PACKTPRT PACK  MXTOTREC,0(0,8)
PACKSYSP PACK  SYSPRINT,0(0,8)
PACKERMS PACK  MXRECERR,0(0,8)
PACKIOER PACK  MAXIOERR,0(0,8)
PACKACPT PACK  MAXACCPT,0(0,8)
PACKSTRT PACK  #START,0(0,8)
MOVEMODN MVC   MODNAME(0),0(8)
MOVETRNM MVC   TRNAME(0),0(8)
MVCSTKY  MVC   STARTKEY(0),0(8)
PACKPOS  PACK  WORK,0(0,8)
MVCSKKY  MVC   SKIPKEY(0),0(8)
MVCALKY  MVC  ALLKEY(0),0(8)
MVCNDKY  MVC  ENDKEY(0),0(8)
PACKSKST PACK  SKIPST,0(0,8)
PACKSKND PACK  SKIPND,0(0,8)
PACKLAST PACK  LAST,0(0,8)
KWPMVC1   MVC   0(1,R3),0(R14)
KWPMVC2   MVC   40(1,R4),0(R14)
KWPMVC3   MVC   40(1,R5),0(R14)
  EJECT
***********************************************************************
*               PARM KEYWORD ERROR ROUTINES                           *
***********************************************************************
KWERR1   EQU   *
         L     R1,PRINTBUF         R1 = A(PRINT BUFFER)
         MVC   KWPRT1+27(8),0(R2)  MOVE KEYWORD
         MVC   0(L'KWPRT1,R1),KWPRT1   MOVE MSG TO BUFFER
         BAL   R14,PRINTIT
         LA    R2,12(R2)           LOOK AT NEXT KEYWOR
         OI    KWFLAG,X'01'        SET ERROR FLAG
         B     KWOVR
KWERR2   EQU   *
         ST    R14,RETREG
         L     R1,PRINTBUF         R1 = A(PRINT BUFFER)
         MVC   KWPRT2+1(8),0(R2)   MOVE KEYWORD
         MVC   0(L'KWPRT2,R1),KWPRT2  MOVE MSG TO BUFFER
         BAL   R14,PRINTIT
         OI    KWFLAG,X'01'        SET ERROR FLAG
         L     R14,RETREG
         BR    R14                 RETURN
KWERR3   EQU   *
         ST    R14,RETREG
         L     R1,PRINTBUF         R1 = A(PRINT BUFFER)
         MVC   KWPRT3+27(8),0(R2)     MOVE KEYWORD
         MVC   0(L'KWPRT3,R1),KWPRT3      MOVE MSG TO BUFFER
         BAL   R14,PRINTIT
         OI    KWFLAG,X'01'        SET ERROR FLAG
         L     R14,RETREG
         BR    R14                 RETURN
  SPACE 2
KWPRT1   DC    C' INVALID KEYWORD IGNORED - XXXXXXXX'
KWPRT2   DC    C' XXXXXXXX - KEYWORD NOT NUMERIC'
KWPRT3   DC    C' 1ST CHARACTER NOT ALPHA - XXXXXXXX'
         SPACE
RETREG   DS    F
  EJECT
***********************************************************************
*              RDJFCB'S   AND  OBTAIN CAMLLST'S                       *
***********************************************************************
RDJFCB1  RDJFCB PSDCB,MF=L
EXLIST1  DC    X'07'
         DC    AL3(JFCB1)
         DC    X'85',AL3(UT1EXIT)     -- MVS STORAGE PROT
JFCB1    DS    44F
JFCBMEM1 EQU   JFCB1+44
DSORG1   EQU   JFCB1+98
JFCBVOL1 EQU   JFCB1+118
RDJFCB2  RDJFCB OUTDCB,MF=L
UT2EXLST DC    0F'0'
         DC    X'07'
         DC    AL3(JFCB2)
         DC    X'85'
         DC    AL3(UT2EXIT)
JFCB2    DC    44F'0'
JFCBMEM2 EQU   JFCB2+44
DSORG2   EQU   JFCB2+98
JFCBVOL2 EQU   JFCB2+118
JFCDISP2 EQU   JFCB2+87
  SPACE 3
SYSUT1A  DS    D
SYSUT2A  DS    D
SYSUT1   DS    0D
         DC    C'SYSUT1  '
SYSUT2   DS    0D
         DC    C'SYSUT2  '
DSCB1    CAMLST SEARCH,JFCB1,JFCBVOL1,DSCBWK
DSCB2    CAMLST SEARCH,JFCB2,JFCBVOL2,DSCBWK
DSCBWK   DS    0D
         DS    CL148
DSCBDSOR EQU   DSCBWK+38
DEVTYPE1 EQU   SYSUT1A+2
DEVTYPE2 EQU   SYSUT2A+2
         DS    F        * * * STRANGE DUMMY THING TO AVOID 0C5 * * *
         EJECT
***********************************************************************
*                                                                     *
***********************************************************************
*  NUMERIC RECIEVES
*    R8  POINTER TO ELEMENT
*    R1  LENGTH CODE FOR ELEMENT
*  NUMERIC RETURNS TO
*        RETURN ADDRESS+4 IF ELEMENT IS ALL NUMERIC
*        RETURN ADDRESS IF ELEMENT IS NOT ALL NUMERIC
         SPACE
NUMERIC  MVC   NUMCHECK,=C'0000000'    RESET CHECK AREA
         EX    R1,MOVEZONE
         CLC   NUMCHECK,=C'0000000'    CHECK IF NUMERIC
         BNE   0(R7)               RETURN ADDRESS IF NOT NUMERIC
         B     4(R7)               RETURN ADDRESS+4 IF NUMERIC
MOVEZONE MVZ   NUMCHECK(0),0(8)
         SPACE 3
UT1EXIT  OC    24(2,IN),24(IN)  IS BUFL=0    --MVS STORAGE PROT
         BNZ   0(R14)    B. IF NOT
         LH    R15,62(IN)  LOAD BLKSIZE
         LA    R15,133(R15)  ADJUST PADDING
         STH   R15,24(IN)  STORE IN BUFL
         BR    R14   RETURN
    SPACE 3
UT2EXIT  EQU   *
         OC    62(2,OUT),62(OUT)
         BNZ   UT2EXIT1             NO - USE INPUT BLKSIZE
         CLI   COMPRESS,C'Y'       COMPRESS OPTION?
         BE    DCBERR1              YES
         CLI   EXPAND,C'Y'         EXPAND OPTION?
         BE    DCBERR1              YES
         MVC   62(2,OUT),62(IN)          NO - USE INPUT BLKSIZE
UT2EXIT1 EQU   *
         OC    82(2,OUT),82(OUT)
         BNZ   UT2EXIT2             NO - USE INPUT LRECL
         CLI   COMPRESS,C'Y'       COMPRESS OPTION?
         BE    DCBERR1              YES
         CLI   EXPAND,C'Y'         EXPAND OPTION?
         BE    DCBERR1              YES
         MVC   82(2,OUT),82(IN)          NO - USE INPUT LRECL
UT2EXIT2 EQU   *
         OC    36(1,OUT),36(OUT)
         BNZ   UT2EXIT3             NO - USE INPUT RECFM
         CLI   COMPRESS,C'Y'       COMPRESS OPTION?
         BE    DCBERR1              YES
         CLI   EXPAND,C'Y'         EXPAND OPTION?
         BE    DCBERR1              YES
         MVC   36(1,OUT),36(IN)          NO - USE INPUT RECFM
UT2EXIT3 EQU   *
         BR    14            RETURN
   SPACE 3
DCBERR1  EQU   *
         L     R1,PRINTBUF
         MVC   0(L'DCBPRT1,R1),DCBPRT1   PRINT DCB ERROR MSG
         ST    R14,WORK4
         BAL   R14,PRINTIT
         L     R14,WORK4
         BR    R14
  SPACE
DCBPRT1  DC    C'1* * * ERROR - OUTPUT DCB REQUIRED FOR COMPRESS OR EXP-
               AND OPTION * * *'
         SPACE
PRTEXIT  EQU   *
         OC    62(2,1),62(1)
         BCR   7,14          RETURN IF BLKSIZE SPECIFIED
         MVC   62(2,1),82(1) USE LRECL IF NOT
         BR    14            RETURN
         EJECT
PARMDONE EQU   *
         ENQ   (QNAME,JFCB1,S,44,SYSTEM)
         OPEN  ((IN),INPUT)
         SPACE 3
         LH    R15,82(IN)     ** NSC - MVS FIX **
         LTR   R15,R15
         BNZ   *+14
         XC    NSCSR1(4),NSCSR1 **
         B     NSCL010
         LA    R15,120(R15)   ** ADD MARGIN **
         LR    R0,R15
         GETMAIN R,LV=(0)
         ST    R1,NSCSR1   ***
NSCL010  EQU   *           ***  END OF MVS FIX -- NSC **
         MVC   INRECFM,36(IN)      SET INPUT RECFM
*                                   USED TO FAKE VARIABLE INPUT
*                                    WHEN COMPRESS OPTION IS USED
         CLI   JFCB2,X'00'         IS THERE A SYSUT2 DD ?
         BE    NOSYSUT2             NO
         CLC   JFCB1(44),JFCB2
         BE    OPEN2
         ENQ   (QNAME,JFCB2,E,44,SYSTEM)
OPEN2    EQU   *
         OPEN  ((OUT),OUTPUT)
NOSYSUT2 EQU   *
         CLI   EXPAND,C'Y'         EXPAND OPTION?
         BNE   NOEXPAND             NO
         CLI   CORECOM,C'Y'        HAS COMPRESS ALREADY GOT CORE?
         BE    NOEXPAND             YES
         LH    R1,62(0,IN)         INPUT BLKSIZE
         LA    R1,4(R1)            ALLOW FOR RDW
         GETMAIN R,LV=(R1)
         LA    R1,4(R1)            ALLOW FOR RDW
         ST    R1,DATAAD           SAVE RECORD AREA ADDR
         LH    R1,62(0,IN)         INPUT BLKSIZE
         LA    R1,4(R1)             + 4 FOR WORKAREA
         GETMAIN R,LV=(R1)
         ST    R1,DATAWORK         SAVE WORKAREA ADDRESS
         MVI   COREEXP,C'Y'        SET GOT CORE FLAG FOR EXPAND
NOEXPAND EQU   *
         CLI   COMPRESS,C'Y'       COMPRESS OPTION?
         BNE   NOCOMPRE             NO
         NI    INRECFM,X'3F'       CLEAR F,V, OR U BITS IN INPUT RECFM
         OI    INRECFM,X'40'       SET V BIT IN INPUT RECFM
         CLI   COREEXP,C'Y'        HAS EXPAND GOT CORE ALREADY?
         BE    NOCOMPRE             YES
         LH    R1,62(0,IN)         INPUT BLKSIZE
         LA    R1,4(R1)            ALLOW FOR RDW
         GETMAIN R,LV=(R1)
         LA    R1,4(R1)            ALLOW FOR RDW
         ST    R1,DATAAD           SAVE RECORD   ADDRESS
         LH    R1,62(0,IN)         INPUT BLKSIZE
         LA    R1,4(R1)             + 4 FOR WORKAREA
         GETMAIN R,LV=(R1)
         ST    R1,DATAWORK         SAVE WORKAREA ADDRESS
         MVI   CORECOM,C'Y'        SET GOT CORE  FLAG FOR COMPRESS
NOCOMPRE EQU   *
         CLI   PRNTPARM,C'T'
         BE    *+12                    GO SEE IF XLATE CHARACTERS INPUT
         CLI   PRNTPARM,C'B'
         BNE   PARMBXIT                NOT VALIDATE
         OPEN  (CDDCB,INPUT)           OPEN FOR SET OF VALID CHAR
         OI    FIRSTSW,1
         L     3,=A(CDDCB)
         TM    48(3),X'10'
         BZ    PARMBXIT                USE DEFAULT TABLE
PARMBGET EQU   *
         GET   (3)
         LR    6,1                     POINTER TO INPUT RECORD
         L     1,=A(PRINT)
         TM    48(1),X'10'             CHECK IF OPEN
         BZ    NOMSCD1
         PUT   (1)
         MVI   0(1),C'0'               DOUBLE SPACE
         MVC   1(80,1),0(6)
         MVC   81(52,1),BLANKS
NOMSCD1  EQU   *
         LH    7,82(,3)
         CLI   PRNTPARM,C'T'
         BNE   BINPUT                  GO SET VALID CHAR TABLE
         MVC   CARD1,0(6)
         GET   (3)
         LR    6,1                     POINTER TO INPUT RECORD
         L     1,=A(PRINT)
         TM    48(1),X'10'             CHECK IF OPEN
         BZ    NOMSCD2
         PUT   (1)
         MVI   0(1),C' '
         MVC   1(80,1),0(6)
         MVC   81(52,1),BLANKS
NOMSCD2  EQU   *
         SR    2,2
         SR    0,0
XTBLOOP  IC    0,0(2,6)
         SR    1,1
         IC    1,CARD1(2)                REPLACES CORRESPONDING
         A     1,PTRXLATE
         STC   0,0(1)                  CHAR ON CARD1
         LA    2,1(,2)
         BCT   7,XTBLOOP
         B     PARMBGET
BINPUT   EQU   *
         L     2,=A(VALIDTBL)
         TM    FIRSTSW,1
         BNO   PARMBSET
         MVI   0(2),C'*'
         MVC   1(255,2),0(2)           RESET TABLE TO *
         NI    FIRSTSW,255-1
PARMBSET SR    1,1
         IC    1,0(,6)                 VALID CHAR
         AR    1,2
         MVI   0(1),0                  SET VALID CHAR IN TABLE
         LA    6,1(,6)
         BCT   7,PARMBSET              SET NEXT CHAR
         B     PARMBGET                GET NEXT CARD
SYSERR   EQU   *
         L     1,=A(PRINT)
         TM    48(1),X'10'             CHECK IF OPEN
         BZ    PARMBEOF
         PUT   (1)
         MVC   0(53,1),=CL53'0I/O ERROR ON SYSIN - REMAINING CARDS IGNOR
               RED'
         MVC   53(80,1),BLANKS
PARMBEOF EQU   *
         CLOSE CDDCB
  EJECT
PARMBXIT EQU   *
         TM    48(IN),X'10'
         BZ    NOINPUT
         CLI   KEYTYPE,C'K'            CHECK IF KEY SPECIFIED
         BNE   ENDSETL                   NO
         CLC   KEYLENTH,16(IN)
         BL    SETLKC                  KEY SPECIFIED SHORTER THAN KEYLN
         SETL  (IN),K,STARTKEY     SET START RECORD KEY
         B     ENDSETL
SETLKC   SETL  (IN),KC,STARTKEY    YES - SETL FOR KEY CLASS
ENDSETL  EQU   *
         MVI   MODCODE,8
         OC    PTRMOD,PTRMOD
         BZ    NEXTGET                 NO MODULE LOADED
         MVI   MODCODE,0
         ST    IN,MODPARM2
         MVC   MODPARM3,=A(PRINT)
         MVI   MODPARM3,X'80'
  EJECT
***********************************************************************
*                      GET     (SYSUT1)                               *
***********************************************************************
NEXTGET  EQU   *
         ZAP   CHARCTR,=P'0'           RESET CHAR CTR
         CLI   MODCODE,12
         BNE   *+12
         LH    0,SAVLRECL
         B     MODINSED                RECORD INSERTED - GO BACK
         SPACE
         GET   (IN)
         NI    ERRFLAG,0               RESET ERROR FLAGS
         AP    RECCTR,=P'1'
         ZAP   RECNR,RECCTR
         LH    7,82(0,IN)              LRECL
         TM    36(IN),X'80'
         BO    NOTVAR                  NOT VARIABLE LENGTH RECORDS
         CLC   0(2,1),82(IN)           LENGTH FIELD : MAX LRECL
         BH    NOTVAR                    TOO HIGH
         MVC   WORK2,0(1)                OK - USE LENGTH FIELD
         LH    7,WORK2
NOTVAR   EQU   *
         STH   7,SAVLRECL
          SPACE 5
         STM   R2,R5,NSCS25   *** MVS FIX -- NSC **
          L     R2,NSCSR1    ** MNS FIX -- NSC **
          LTR   R2,R2
          BZ    NSCL020
          LR    R3,R7     LRECL
          LR    R5,R7     LRECL
          LR    R4,R1     FROM
          MVCL  R2,R4     MOVE BUFFER
          L     R1,NSCSR1    NEW BUFFER PTR
          LM   R2,R5,NSCS25   *** MVS FIX -- NSC **
NSCL020   EQU   *            ** END MVS FIX -- NSC **
          SPACE 3
         LR    0,7
         A     0,#CHAREAD              ACCUMULATE TOTAL CHARACTERS READ
         ST    0,#CHAREAD
* R1 PTS TO INPUT RECORD; R7 = LRECL
         CLI   EXPAND,C'Y'         EXPAND THE RECORD?
         BNE   NOEXP                NO
         STM   R2,R6,R2TR6         SAVE REGS
         L     R2,DATAAD           ADDR OF DATA AREA (FOR EXPAND)
         LR    R3,R7               LRECL
         SLL   R3,8                *  CLEAR H--ORDER BYTE FOR MVCL
         SRL   R3,8                 *
         LR    R5,R3
         TM    36(IN),X'80'        VAR LENGTH REC?
         BO    *+14                 NO
         LA    R1,4(R1)            BYPASS RDW OF REC
         SH    R3,=H'4'            LRECL - 4 FOR RDW
         LR    R5,R3
*
         ST    R3,DATALNGH         SAVELENGTH IN CASE REC DOESN'T
*                                   GET EXPANDED
         LR    R4,R1
         MVCL  R2,R4               MOVE REC TO DATA AREA FOR EXPAND
         LA    R1,PARMLIST
         L     R15,CEEXPAND
         BALR  R14,R15             GO EXPAND THE DATA
         L     R7,DATALNGH         RESET LRECL
         L     R1,DATAAD           RELOAD REC PTR
         L     IN,R2TR6+8          RESET IN  DCB PTR
         TM    36(IN),X'80'        VAR LENGTH REC?
         BO    *+22                 NO
         SH    R1,=H'4'            PT TO WHERE RDW SHOULD BE
         LA    R7,4(R7)            LRECL + 4 FOR RDW
         STH   R7,0(0,R1)          STORE RDW IN REC
         MVC   2(2,R1),=H'0'       ZEROES IN RIGHT HALF OF RDW
*
         STH   R7,SAVLRECL
         LM    R2,R6,R2TR6         RESTORE REGS
NOEXP    EQU   *
         CLI   MODCODE,8
         BE    MODACPT1
         ST    1,MODPARM1
         LR    0,7
         SPACE
MODINSED EQU   *
         L     15,PTRMOD
         LA    1,MODPARM1
         BALR  14,15
         STC   15,MODCODE
         B     *+4(15)
         B     MODACCPT            0   ACCEPT OR REPLACE
         B     MODELETE            4   DELETE
         B     EXITNOMO            8 DONOT RETURN                74.072
         B     MODINSRT           12   INSERT
         SPACE
MODELETE AP    RECDLETE,=P'1'          COUNT DELETES
         B     NEXTGET
MODNOT   L     1,MODPARM1
         LH    7,SAVLRECL
         LTR   1,1
         BNZ   MODACPT1
         B     EXITNOMO                EOF ON SYSUT1 - NO INSERT
MODINSRT AP    RECINSRT,=P'1'          COUNT RECORDS INSERTED
MODACCPT EQU   *
         LA    2,MODPARM1
         CR    1,2
         BE    MODNOT                  REG 1 HAS NOT BEEN CHANGED
         LR    7,0                     LENGTH ACCEPTED
MODACPT1 EQU   *         R1 POINTS TO INPUT RCD
         CP    LAST,=P'0000000'    OUTPUT LAST  N  RECORDS ?
         BNE   NEXTGET              YES, SPIN THRU FILE FOR GETTING CNT
         CP    RECOUT,MAXACCPT     MAX. # OF RECORDS ACCEPTED ?
         BNL   EXITNOMO             YES, GO QUIT
         CP    RECCTR,#START       AT STARTING POINT FOR OUTPUTTING
         BL    NEXTGET              NO, GO SPIN THRU INPUT
         CP    RECCTR,SKIPST
         BL    KWTST1
         CP    RECCTR,SKIPND
         BNH   NEXTGET
KWTST1   EQU   *
         LR    R6,R1               PT R6 TO INPUT RECORD
BKWTST2  B     KWTST2              NO KEY PROVIDED
PSCLC2   CLC   0(0,R1),STARTKEY    START ALLOWING OUTPUT ?
         BNE   NEXTGET              NO                           74.052
         MVI   BKWTST2+1,X'F0'     RESET THE BRANCH              74.052
         B     KWTST5              BRANCH AROUND THE ENDKEY LOGIC74.052
KWTST2   EQU   *
BKWTST3  B     KWTST3
PSCLC3   CLC   0(0,R1),SKIPKEY     SKIP THIS RCD ?
         BE    NEXTGET              YES
KWTST3   EQU   *
BKWTST4  B     KWTST4
PSCLC4   CLC   0(0,R1),ALLKEY      ALLOW THIS TO BE OUTPUT ?
         BNE   NEXTGET              NO
KWTST4   EQU   *
BKWTST5  B     KWTST5
PSCLC5   CLC   0(0,R1),ENDKEY      END OF ALLOWABLE OUTPUT ?
         BE    EXITNOMO             YES, GO QUIT                 74.052
KWTST5   EQU   *
         LR    0,7
         CVD   0,WORK8
         ZAP   LRECLIN,WORK8
         LR    8,6                     PTR TO RECORD
         LR    10,7                    LENGTH OF RECORD
         TM    36(IN),X'80'
         BO    *+12                    NOT VARIABLE LENGTH
         LA    8,4(0,8)                PTR TO DATA
         SH    10,=H'4'
         CLI   PRNTPARM,C'B'
         BNE   SCANDONE                NOT BCD SCAN
         ZAP   SCNMXREC,MXRECERR
         L     3,PTRVALID
         BCTR  10,0                    LENGTH CODE
SCANNXT  EX    10,SCANBCD
         BNZ   SCANERR                 NON BCD CHAR FOUND
         SRDL  10,8                    LENGTH CODE TO REG 11
         SLA   10,8                    # CHAR REMAINING TO SCAN
         BZ    SCANDONE
         SRL   11,24                   # CHAR SCANNED MINUS 1
         LA    8,1(11,8)               PTR TO NEXT CHAR
         BCT   10,SCANNXT
SCANBCD  TRT   0(0,8),0(3)
SCANERR  UNPK  WORK(3),0(2,1)
         STC   2,0(,1)                 REPLACE NON-BCD CHAR
         LA    11,1(,1)                PTR TO NEXT CHAR
         LR    1,11
         SR    1,6                     OFFSET TO NON-BCD CHAR
         CVD   1,WORK8
         L     1,=A(PRINT)
         TM    48(1),X'10'
         BZ    SCNMSGDN                NO SYSPRINT DD
         CLI   PRNTPARM+1,C'A'
         BE    *+12                    PRINT ERROR MSG
         CLI   PRNTPARM+1,C'E'
         BNE   SCNMSGDN                NOT PRINT ERROR MSG
         SP    SCNMXREC,=P'1'
         BM    SCNMSGDN                MAX ERROR LINES PER RECORD
         OI    ERRFLAG,4
         PUT   (1)
         MVC   0(1,1),NXTLNCTL
         MVI   NXTLNCTL,C' '
         BCT   9,*+12                  COUNT LINES
         CVB   9,#LINES
         MVI   0(1),C'1'               NEW PAGE
         MVC   1(132,1),BLANKS
         MVC   1(33,1),=CL33'*** TH CHAR IS HEX **  ***'
         ED    4(8,1),WORK4
         TR    WORK(2),HEXTABLE-C'0'
         MVC   27(2,1),WORK            HEX DIGITS TO MSG
SCNMSGDN LR    1,11
         SR    1,8                     # CHAR SCANNED
         LR    8,11                    PTR TO NEXT CHAR TO BE SCANNED
         SR    10,1                    # CHAR TO BE SCANNED
         BNM   SCANNXT                 GO CONTINUE SCAN
SCANDONE EQU   *
         CLI   PRNTPARM,C'T'
         BNE   NOTXLATE
         L     3,PTRXLATE
         SRDA  10,8                    NR OF 256 BYTE SEGMENTS
         LTR   10,10
         BZ    *+18                      NONE
         TR    0(256,8),0(3)           TRANSLATE 256 CHARACTERS
         LA    8,256(0,8)              PTR TO NEXT RECORD SEGMENT
         BCT   10,*-10
         SRA   11,24                   RESIDUAL COUNT
         BZ    NOTXLATE                NONE LEFT
         BCTR  11,0                    RESIDUAL LENGTH CODE
         EX    11,TRNSLATE
NOTXLATE EQU   *
*  R6 PTS TO INPUT  RECORD;  R7 = LRECL
         CLI   COMPRESS,C'Y'       COMPRESS THE RECORD?
         BNE   NOCOM                NO
         STM   R2,R5,R2TR6         SAVE REGS
         L     R2,DATAAD           ADDR OF COMPRESS DATA AREA
         LR    R3,R7               LRECL
         SLL   R3,8                * CLEAR HI-ORDER BYTE FOR MVCL
         SRL   R3,8                 *
         LR    R5,R3
         TM    36(IN),X'80'        VAR LENGTH REC?
         BO    *+14                 NO
         LA    R6,4(R6)            BYPASS RDW OF REC
         SH    R3,=H'4'            (LRECL - 4) FOR RDW
         LR    R5,R3
*
         ST    R3,DATALNGH         DATA LENGTH PARM
         LR    R4,R6
         MVCL  R2,R4               MOVE REC TO DATA AREA FOR COMPRESS
         LA    R1,PARMLIST
         L     R15,CECMPRES
         BALR  R14,R15             GO COMPRESS THE DATA
         L     R7,DATALNGH         COMPRESSED DATA LENGTH
         L     R6,DATAAD           RELOAD REC PTR
         SH    R6,=H'4'            PT TO WHERE RDW SHOULD BE
         LA    R7,4(R7)            (LRECL + 4) FOR RDW
         STH   R7,0(0,R6)          STORE RDW IN REC
         MVC   2(2,R6),=H'0'       ZEROES IN RIGHT HALF OF RDW
         LM    R2,R5,R2TR6         RESTORE REGS
NOCOM    EQU   *
         AP    RECOUT,=P'1'        COUNT RECORDS OUT
         TM    48(OUT),X'10'           CHECK IF SYSUT2 OPEN
         BZ    NOOUTPUT
         LR    8,6                     POINTER TO OUTPUT DATA
         LR    10,7                    LENGTH OF OUTPUT DATA
         TM    36(OUT),X'40'
         BZ    FIXLRECL                OUTPUT RECFM=F
         TM    36(OUT),X'80'
         BO    *+20                    OUTPUT RECFM=U
         TM    INRECFM,X'80'       VAR LENGTH REC?
         BZ    *+12                    OUTPUT RECFM=V - INPUT RECFM=V
         OI    FIRSTSW,2               INDICATE CREATE V LENGTH REC
         LA    10,4(0,7)               INCREASE LRECL BY 4
         STH   10,82(0,OUT)            STORE LRECL FOR RECFM V OR U
         LH    1,62(0,OUT)             OUT BLKSIZE
         TM    36(OUT),X'80'
         BO    *+8                     OUT RECFM=U
         SH    1,=H'4'                 OUT RECFM=V BLKSIZE MINUS 4
         CR    10,1
         BNH   PUTOUT                  OK
         LR    10,1                      TOO HIGH -
         STH   10,82(0,OUT)                USE OUT BLKSIZE
         B     PUTOUT
FIXLRECL EQU   *
         TM    INRECFM,X'80'       VAR LENGTH REC?
         BO    *+12
         SH    10,=H'4'                OUTPUT RECFM=F - INPUT RECFM=V
         LA    8,4(,8)                   DROP CONTROL CHARACTERS
         CH    10,82(0,OUT)            DATA LENGTH : LRECL OUT
         BNH   PUTOUT                    OK
         LH    10,82(0,OUT)              TOO HIGH - USE LRECL
***********************************************************************
*                     PUT     (SYSUT2)                                *
***********************************************************************
PUTOUT   EQU   *
         LR    R0,R10              * ACCUMULATE
         CVD   R0,WORK8             * TOTAL
         A     R0,#CHAROUT           * CHARACTER
         ST    R0,#CHAROUT            * OUT
         PUT   (OUT)
         TM    FIRSTSW,2
         BZ    *+24                    NOT CREATE V LENGTH REC
         SH    10,=H'4'
         MVC   0(2,1),82(OUT)          MOVE LRECL TO OUTPUT V REC
         XC    2(2,1),2(1)
         LA    1,4(0,1)
         BCTR  10,0
         EX    10,MOVEOUT              MOVE UP TO 256 CHAR
         SRDL  10,8
         LTR   10,10                   NR 256 BYTE SEGMENTS REMAINING
         BZ    *+34                      NONE
         SRL   11,24
         LA    1,1(11,1)
         LA    8,1(11,8)
         MVC   0(256,1),0(8)           MOVE 256 MORE CHAR
         LA    1,256(0,1)
         LA    8,256(0,8)
         BCT   10,*-14                 GO MOVE NEXT 256 CHAR
NOOUTPUT EQU   *
         CLI   PRNTPARM,C'H'
         BE    SETHEX
         TM    INRECFM,X'80'       VAR LENGTH REC?
         BO    FRSTOUT                 NOT VARIABLE INPUT
         SH    7,=H'4'
         LA    6,4(0,6)                PTR TO DATA
         B     FRSTOUT
*
MOVEOUT  MVC   0(0,1),0(8)
TRNSLATE TR    0(0,8),0(3)
*
SETHEX   EQU   *
         LR    10,6                    SET FOR HEX PRINT
         AR    7,7                     TWICE AS MANY CHAR
         SPACE
FRSTOUT  EQU   *
         L     1,=A(PRINT)
         TM    48(1),X'10'             CHECK IF OPEN
         BO    *+16                    GO PRINT RECORD
         TM    ERRFLAG,1               PROCESSING ERROR REC
         BZ    NEXTGET                   NO - GO GET NEXT REC
         B     SYNADXIT                  YES - NO PRINT
         TM    ERRFLAG,1     HEX PRINT ERR REC ONLY
         BO    NEXTOUT                 PRINT ALL ERROR RECORDS
         CLC   PRNTPARM,=C'BE'
         BNE   *+12                    NOT ERROR MSG ONLY
         TM    ERRFLAG,4
         BNO   NEXTREC                 PRINT ERROR RECORD ONLY
         ZAP   MXTOTREC,MXTOTREC
         BH    *+16
         TM    48(OUT),X'10'
         BO    NEXTGET                 CONTINUE COPY
         B     EXITNOMO      MAX RECS PRINTED - NO COPY - ALL DONE
         SP    MXTOTREC,=P'1'
         SPACE
NEXTOUT  EQU   *
         L     1,=A(PRINT)
         PUT   (1)
         LR    8,1                     PTR TO PRINT BUFFER
         TM    ERRFLAG,1
         BO    *+22                    REC NR PRINTED FOR I-O ERROR
         CLI   PRNTPARM,C'L'
         BNE   *+14                    NOT LIST - PRINT REC NR
         MVC   1(22,8),BLANKS          LIST - REC NR NOT PRINTED
         B     *+16
         MVC   0(23,8),RECEDMSK
         ED    0(23,8),RECNR
         ZAP   RECNR,=P'0'
         ZAP   LRECLIN,=P'0'
         MVC   0(1,8),NXTLNCTL
         MVI   NXTLNCTL,C' '
         BCT   9,SAMEPAGE              LINE COUNT
         CVB   9,#LINES
         MVI   0(8),C'1'               PRINT CTL - SKIP TO CHAN 1
SAMEPAGE EQU   *
         MVC   123(10,8),BLANKS
         TM    ERRFLAG,1               PROCESSING ERROR RECORD
         BO    SYNADCOM
         CLI   PRNTPARM,C'H'
         BE    HEXLINE                 HEX PRINT
         L     2,=A(PRNTABLE)
         SH    7,=H'100'               -(100-#CHAR)
         BL    LASTLINE
         MVC   23(100,8),0(6)          FULL LINE
         TR    23(100,8),0(2)
         BZ    NEXTREC
         AP    CHARCTR,=P'100'
         LA    6,100(0,6)
         B     NEXTOUT
MOVEDATA MVC   23(0,8),0(6)
LASTLINE LA    1,99(0,7)               NR OF DATA BYTES MINUS 1
         EX    1,MOVEDATA              PARTIAL LINE
         TR    23(100,8),0(2)
         LA    8,1(1,8)                END OF DATA
         LA    6,BLANKS
         LPR   1,7                     100 - NR OF DATA BYTES
         BCTR  1,0                       MINUS 1
         EX    1,MOVEDATA              PAD WITH BLANKS
         SPACE
NEXTREC  EQU   *
         CH    9,=H'4'                 NEW PAGE IF WITHIN 4 LINES
         BH    NEXTSPC
         LA    9,1
         B     NEXTGET
NEXTSPC  EQU   *
         CLI   PRNTPARM+1,C'1'
         BE    NEXTGET                 SINGLE SPACE BETWEEN RECORDS
         MVI   NXTLNCTL,C'0'
         BCT   9,NEXTGET               COUNT EXTRA SPACE AND BRANCH
         SPACE
EXIT     EQU   *
         SR    1,1
         ST    1,MODPARM1              INDICATE EOF
         LH    0,SAVLRECL
         CLI   MODCODE,8
         BNE   MODINSED                GO BACK TO MOD RTN FOR INSERTS
         SPACE
EXITNOMO EQU   *
         CP    LAST,=P'0000000'    OUTPUT LAST N RECORDS ONLY ?
         BE    EXITOK               NO
         ZAP   #START,RECCTR       TOTAL RCDS INPUT
         AP    #START,=P'1'         +1
         SP    #START,LAST         START AT LAST N RCDS
         ZAP   RECCTR,=P'0'                  * INITIALIZE
         XC    #CHAREAD(4),#CHAREAD          *
         ZAP   LAST,=P'0'                    *
         CLOSE ((IN),REREAD)
         OPEN  ((IN),INPUT)
         B     NEXTGET             START OVER TO OUTPUT LAST N RCDS
***********************************************************************
*                  PRINT ENDING STATISTICS                            *
***********************************************************************
EXITOK   EQU   *
         STM   R0,R15,ALLREGS
         TIME
         ST    R1,DATE
         ST    R0,TIME
         L     R1,=A(PRINT)
         TM    48(1),X'10'         PRINT DCB OPEN ?
         BZ    EXIT1                NO - THEN SKIP END MSG
         BAL  R14,PRINTIT
         CLC  SYSPRINT(3),=C'TSO'  TSO OPTION SPECIFIED?
         BE   EXITTSO                  YES-DONT PRINT STATISTICS
         L     R2,=A(ENDMSG1)
         MVC   0(L'ENDMSG1,1),0(R2) INPUT DSN =
         MVC   13(44,1),JFCBDSN1    DSNAME
         CLI   MEMBER1,C' '        PRINT MEMBER NAME?
         BE    NOMEM1               NO
         MVI   57(1),C'('
         MVI   66(1),C')'
         MVC   58(8,1),MEMBER1
NOMEM1   EQU   *
         BAL   R14,PRINTIT
         LA    R2,L'ENDMSG1(R2)
         LR    R6,IN
         BAL   R14,MVCDCB          RECFM, LRECL, BLKSIZE, DSORG
         BAL   R14,PRINTIT
         LA    R2,L'ENDMSG2(R2)
         CLI   JFCBDSN2,X'00'      SYSUT2 DD ?
         BE    SKIPIT1              NO
         MVC   0(L'ENDMSG3,1),0(R2) OUTPUT DSN =
         MVC   14(44,1),JFCBDSN2     DSNAME
         CLI   MEMBER2,C' '        PRINT MEMBER NAME?
         BE    NOMEM2               NO
         MVI   58(1),C'('
         MVI   67(1),C')'
         MVC   59(8,1),MEMBER2
NOMEM2   EQU   *
         BAL   R14,PRINTIT
         LA    R2,L'ENDMSG3(R2)
         LR    R6,OUT
         BAL   R14,MVCDCB
         BAL   R14,PRINTIT
         LA    R2,L'ENDMSG4(R2)
         B     SKIPIT2
SKIPIT1  EQU   *
         LA    R2,L'ENDMSG3(R2)
         LA    R2,L'ENDMSG4(R2)
SKIPIT2  EQU   *
         MVC   0(L'ENDMSG5,1),0(R2) STATISTICS:
         BAL   R14,PRINTIT
         LA    R2,L'ENDMSG5(R2)
         MVC   0(L'ENDMSG6,1),0(R2) RECORDS IN
         ED    31(10,1),RECCTR
         BAL   R14,PRINTIT
         LA    R2,L'ENDMSG6(R2)
         MVC   0(L'ENDMSG7,1),0(R2)  CHARACTERS IN
         L     0,#CHAREAD
         CVD   0,WORK8
         ED    21(20,1),WORK8
         BAL   R14,PRINTIT
         LA    R2,L'ENDMSG7(R2)
         MVC   0(L'ENDMSG8,1),0(R2)  RECORDS OUT
         ED    31(10,1),RECOUT
         BAL   R14,PRINTIT
         LA    R2,L'ENDMSG8(R2)
         MVC   0(L'ENDMSG9,1),0(R2)  CHARACTERS OUT
         L     0,#CHAROUT
         CVD   0,WORK8
         ED    21(20,1),WORK8
         BAL   R14,PRINTIT
         LA    R2,L'ENDMSG9(R2)
         MVC   0(L'ENDMSG10,1),0(R2) RECORDS INSERTED
         ED    31(10,1),RECINSRT
         BAL   R14,PRINTIT
         LA    R2,L'ENDMSG10(R2)
         MVC   0(L'ENDMSG11,1),0(R2) RECORDS DELETED
         ED    31(10,1),RECDLETE
         BAL   R14,PRINTIT
         LA    R2,L'ENDMSG11(R2)
         MVC   0(L'ENDMSG12,1),0(R2) I10 ERRORS
         ED    31(10,1),#IOERRS
         BAL   R14,PRINTIT
         LA    R2,L'ENDMSG12(R2)
         MVC   0(L'ENDMSG13,1),0(R2) OPTIONS:
         BAL   R14,PRINTIT
         LA    R2,L'ENDMSG13(R2)
         MVC   0(L'ENDMSG14,1),0(R2) TYPE
         MVC   13(2,1),PRNTPARM
         BAL   R14,PRINTIT
         LA    R2,L'ENDMSG14(R2)
         MVC   0(L'ENDMSG15,1),0(R2) LINES
         ED    12(4,1),#LINES+6
         BAL   R14,PRINTIT
         LA    R2,L'ENDMSG15(R2)
         MVC   0(L'ENDMSG16,1),0(R2) START
         ED    12(8,1),#START
         BAL   R14,PRINTIT
         LA    R2,L'ENDMSG16(R2)
         MVC   0(L'ENDMSG17,1),0(R2) STOP
         ED    12(16,1),MAXACCPT
         BAL   R14,PRINTIT
         LA    R2,L'ENDMSG17(R2)
         MVC   0(L'ENDMSG18,1),0(R2) SKIP
         ED    12(8,1),SKIPST
         ED    22(8,1),SKIPND
         BAL   R14,PRINTIT
         LA    R2,L'ENDMSG18(R2)
         MVC   0(L'ENDMSG19,1),0(R2) LAST
         ED    12(8,1),LASTSV
         BAL   R14,PRINTIT
         LA    R2,L'ENDMSG19(R2)
         MVC   0(L'ENDMSG20,1),0(R2) SYSPRINT
         ED    12(8,1),SYSPRINT
         BAL   R14,PRINTIT
         LA    R2,L'ENDMSG20(R2)
         MVC   0(L'ENDMSG21,1),0(R2) RKP
         LH    0,PSPOS
         CVD   0,WORK8
         ED    12(6,1),WORK3
         BAL   R14,PRINTIT
         LA    R2,L'ENDMSG21(R2)
         MVC   0(L'ENDMSG22,1),0(R2) STARTKEY
         MVC   13(67,1),STARTKEY
         BAL   R14,PRINTIT
         LA    R2,L'ENDMSG22(R2)
         MVC   0(L'ENDMSG23,1),0(R2) ENDKEY
         MVC   13(67,1),ENDKEY
         BAL   R14,PRINTIT
         LA    R2,L'ENDMSG23(R2)
         MVC   0(L'ENDMSG24,1),0(R2) SKIPKEY
         MVC   13(67,1),SKIPKEY
         BAL   R14,PRINTIT
         LA    R2,L'ENDMSG24(R2)
         MVC   0(L'ENDMSG25,1),0(R2) ALLKEY
         MVC   13(67,1),ALLKEY
         BAL   R14,PRINTIT
         LA    R2,L'ENDMSG25(R2)
         MVC   0(L'ENDMSG26,1),0(R2) MODNAME
         MVC   13(8,1),MODNAME
         BAL   R14,PRINTIT
         LA    R2,L'ENDMSG26(R2)
         MVC   0(L'ENDMSG27,1),0(R2) TRNAME
         MVC   13(8,1),TRNAME
         BAL   R14,PRINTIT
         LA    R2,L'ENDMSG27(R2)
         MVC   0(L'ENDMSG28,1),0(R2) MAXIOERR
         ED    12(8,1),MAXIOERR
         BAL   R14,PRINTIT
         LA    R2,L'ENDMSG28(R2)
         MVC   0(L'ENDMSG29,1),0(R2) MXRECERR
         ED    12(8,1),MXRECERR
         BAL   R14,PRINTIT
         LA    R2,L'ENDMSG29(R2)
         MVC   0(L'ENDMSG33,1),0(R2)   COMPRESS
         MVC   13(3,1),COMPRESS
         BAL   R14,PRINTIT
         LA    R2,L'ENDMSG33(R2)
         MVC   0(L'ENDMSG34,1),0(R2)  EXPAND
         MVC   13(3,1),EXPAND
         BAL   R14,PRINTIT
         LA    R2,L'ENDMSG34(R2)
         MVC   0(L'ENDMSG30,1),0(R2) DATE & TIME
         ED    11(7,1),DATE+1
         ED    27(9,1),TIME
         BAL   R14,PRINTIT
***********************************************************************
*                      EXIT ROUTINES                                  *
***********************************************************************
EXITTSO  L     R2,=A(ENDMSG31)
         TM    ERRFLAG,1             SUCCESSFUL COMPLETION?
         BZ    *+18                   YES
         LA    R2,L'ENDMSG31(R2)       NO
         MVC   0(L'ENDMSG32,1),0(R2) END DSUTIL - NOT SUCCESSFUL
         B     *+10
         MVC   0(L'ENDMSG31,1),0(R2) END DSUTIL - SUCCESSFUL
         BAL   R14,PRINTIT
         CLI   ABENDCDE,X'00'      EOJ ABEND SET ?
         BNE   EOJABEND             YES
         CLOSE PRINT
EXIT1    EQU   *
         CLC   MODNAME,BLANKS
         BE    NOMODNM
         DELETE  EPLOC=MODNAME
NOMODNM  EQU   *
         CLC   TRNAME,BLANKS
         BE    NOTRNM
         DELETE  EPLOC=TRNAME
NOTRNM   EQU   *
         CLOSE ((IN),,(OUT))
         DEQ   (QNAME,JFCBDSN1,44,SYSTEM)
         CLI   JFCBDSN2,X'00'      NO SYSUT2 DD?
         BE    EXIT2
         CLC   JFCBDSN1(44),JFCBDSN2   SAME NAMES?
         BE    EXIT2
         DEQ   (QNAME,JFCBDSN2,44,SYSTEM)
EXIT2    EQU   *
         LA    15,0
         TM    ERRFLAG,1
         BZ    *+8
GOBACK16 LA    15,16                   MAX I/O ERRORS OR NO SYSUT1
         TM    KWFLAG,X'01'         ANY KEYWORD INPUT ERROR ?
         BZ    *+8                  NO
ERETURN  LA    R15,16
         L     13,SAVE13
         EXITLKG SAVE=SAVEAREA,FREE=2048,RC=(15)
  SPACE
***********************************************************************
*                     PRINT ROUTINE                                   *
***********************************************************************
PRINTIT  EQU   *
         ST    R14,REG14
         CLC   SYSPRINT(3),=C'TSO'    TSO OPTION SPECIFIED
         BNE   NOTSO
         LA    R0,133                  BUFFER LENGTH
         L     R1,PRINTBUF          ADDR OF PRINT BUFFER
         TPUT  (1),(0)                 TPUT MESSAGE TO TERMINAL
         L     R1,PRINTBUF          ADDR OF PRINT BUFFER
         B     TSORET
NOTSO    L     R1,=A(PRINT)
         TM    48(1),X'10'         CHECK IF OPEN?
         BZ    PRINTRET             NO
         PUT   (1)
TSORET   MVC   0(133,1),BLANKS
         ST    R1,PRINTBUF
         L     R14,REG14
PRINTRET BR    R14
REG14    DS    F
  SPACE
***********************************************************************
*      ENDING STATISTICS - - RECFM, LRECL, BLKSIZE, DSORG             *
***********************************************************************
MVCDCB   EQU   *
         MVC   0(L'ENDMSG2,1),0(R2)     DCB PATTERN
         MVI   8(1),C'U'                RECFM
         TM    36(R6),X'C0'
         BNM   *+32
         MVI   8(1),C'V'
         TM    36(R6),X'80'
         BZ    *+8
         MVI   8(1),C'F'
         TM    36(R6),X'10'
         BZ    *+8
         MVI   9(1),C'B'
         TM    36(R6),X'04'
         BZ    *+8
         MVI   10(1),C'A'
         TM    36(R6),X'02'
         BZ    *+8
         MVI   10(1),C'M'
         LH    0,82(0,R6)
         CVD   0,WORK8
         ED    19(6,1),WORK3            LRECL
         LH    0,62(0,R6)
         CVD   0,WORK8
         ED    35(6,1),WORK3            BLKSIZE
         MVC   50(2,1),IS          DSORG
         TM    26(R6),X'80'
         BO    *+24
         MVC   50(2,1),PS
         TM    26(R6),X'40'
         BO    *+10
         MVC   50(2,1),DA
         BR    R14                 RETURN
  SPACE
NOINPUT  EQU   *
         L     1,=A(PRINT)
         TM    48(1),X'10'             CHECK IF OPEN
         BO    NOINPTMS
         WTO   'DSUTIL   - NO SYSUT1 DD'
         B     GOBACK16
NOINPTMS EQU   *
         PUT   (1)
         MVC   1(132,1),BLANKS
         MVC   0(23,1),=CL23' OPEN ERROR ON SYSUT1 '
         B     GOBACK16
         SPACE
***********************************************************************
*           SYNAD ERROR ROUTINES     (SYSUT1 & SYSUT2)                *
***********************************************************************
ISERR    SYNADAF ACSMETH=QISAM
         OI    ERRFLAG,1               TURN ON ERR RTN FLAG
         STM   14,1,SAVE14
         L     13,4(0,13)
         B     FRSTOUT
         SPACE
PSERR    SYNADAF ACSMETH=QSAM
         OI    ERRFLAG,1               TURN ON ERR RTN FLAG
         STM   14,1,SAVE14
         L     13,4(0,13)
         B     FRSTOUT
         SPACE
SYNADCOM EQU   *
         TM    ERRFLAG,2
         BO    HEXLINE                 GO OUTPUT NEXT HEX LINE
         L     11,SAVE0
         L     1,SAVE1
         MVC   55(79,8),49(1)
         L     10,8(0,1)
         MVC   1(54,8),NODATA
         B     *+4(11)
         B     SYNADXIT                BYTES 8-13 CONTAIN BLANKS
         B     UNPACK
         B     SYNADXIT                SYNADAF NOT SUCCESSFUL
         SPACE
UNPACK   EQU   *
         ZAP   RECNR,RECCTR
         LH    11,12(0,1)
         CVD   11,0(0,8)
         MVI   0(8),C'0'               DOUBLE SPACE
         UNPK  1(4,8),5(3,8)           UNPACK NR OF CHAR READ
         MVZ   4(1,8),3(8)
         LA    7,0(11,11)
         OI    ERRFLAG,2               HEX LINES TO FOLLOW
         MVC   5(20,8),=CL20'/'
         LTR   11,11
         BZ    NEXTOUT
         CH    11,=H'48'
         BL    *+8                     ENTIRE RECORD TO MESSAGE
         LA    11,48                      ELSE FIRST 48 CHAR TO MSG
         BCTR  11,0
         EX    11,*+8
         B     NEXTOUT
         MVC   6(0,8),0(10)
         SPACE
HEXLINE  EQU   *
         CH    9,=H'1'
         BH    *+8
         LA    9,2                     FORCE CHAR LINE ON SAME PAGE
         AP    CHARCTR,=P'50'
         LA    1,23(,8)
         LA    2,HEXCHAR+23
         LA    11,5                    5 GROUPS PER LINE
NXHXLINE EQU   *
         UNPK   0(11,1),0(6,10)
         UNPK  10(11,1),5(6,10)
         MVC   20(2,1),=X'EFEF'
         MVO    1(9,2),0(9,1)          SET ZONES FOR CHAR
         MVO   11(9,2),10(9,1)
         MVN   0(20,2),0(1)
         NC    0(20,2),=10X'00FF'
         LA    1,22(,1)
         LA    2,22(,2)
         LA    10,10(,10)
         BCT   11,NXHXLINE
         TR    23(110,8),HEXTABLE-C'0'
         SPACE
         MVC   HEXSV15,=A(NEXTOUT)     SET FOR MORE
         SH    7,=H'100'               -(100-#CHAR)
         BH    HEXMORE                 GO PUT CHAR LINE
         BE    HEXEND
         LA    1,100(,7)               #CHAR
         LR    0,1                     #CHAR
         LPR   7,7                     100-#CHAR
         LA    7,11(,7)                111-#CHAR
         SH    0,=H'20'                TWO BLANK ADDED PER 20 CHAR
         BM    *+16
         SH    7,=H'2'                 111-(#CHAR+#BLANKS)
         LA    1,2(,1)                 #CHAR+BLANKS
         B     *-16
         AR    8,1                     PTR TO LAST CHAR +1
         LA    6,BLANKS
         EX    7,MOVEDATA
         LA    8,HEXCHAR(1)            PTR TO LAST CHAR + 1
         EX    7,MOVEDATA
         ZAP   CHARCTR,=P'0'           RESET CHAR CTR
HEXEND   EQU   *
         MVC   HEXSV15,=A(SYNADXIT)    SET FOR END OF RECORD
HEXMORE  EQU   *
         CLI   PRNTPARM+1,C'N'
         BE    HEXNOCHR
         L     1,=A(PRINT)
         PUT   (1)
         MVC   0(133,1),HEXCHAR
         L     2,=A(PRNTABLE)
         TR    23(110,1),0(2)
         BCTR  9,0
HEXNOCHR EQU   *
         L     15,HEXSV15
         BR    15                      CONTINUE
         SPACE
SYNADXIT EQU   *
         TM    ERRFLAG,1
         BZ    NEXTREC                 NOT PRINTING ERROR
         L     13,8(0,13)
         SYNADRLS
         AP    #IOERRS,=P'1'
         CP    #IOERRS,MAXIOERR
         BH    EXITNOMO                NR I/O ERRORS EXCEEDED MAX SPEC
         L     14,SAVE14
         BR    14
  EJECT
***********************************************************************
*                        ABEND                                        *
***********************************************************************
EOJABEND EQU   *
         ABEND 69,DUMP
  EJECT
***********************************************************************
*                    SNAP ROUTINE                                     *
***********************************************************************
SNAPIT   EQU   *
         STM   R15,R1,SNAPREGS
         SNAP DCB=SNAP,PDATA=(REGS,SPLS),STORAGE=(SNAPREGS,KWNAMES)
         LM    R15,R1,SNAPREGS
         BR    R14                 RETURN
SNAPREGS DC    3F'0'
***********************************************************************
*                    CONSTANTS AND LTORGS                             *
***********************************************************************
         LTORG
CECMPRES DC    V(CECMPRES)
CEEXPAND DC    V(CEEXPAND)
PARMLIST DC    A(DATALNGH)
*
DATALNGH DC    A(0)                * THESE
DATAAD   DC    F'0'                *  CONSTANTS
DATAWORK DC    A(0)                *    MUST BE CONTIGUOUS
*
QNAME    DC    CL8'DSNAME'
JFCBDSN1 DS    CL44
MEMBER1  DS    CL8
JFCBDSN2 DS    CL44
MEMBER2  DS    CL8
COMPRESS DC    C'NO '
EXPAND   DC    C'NO '
IS       DC    C'IS'
PS       DC    C'PS'
DA       DC    C'DA'
NODATA   DC    CL54'*** NO DATA READ ***'
ERRFLAG  DC    X'0'
NXTLNCTL DC    C' '
KEYIN    DC    C'N'
PRNTPARM DC    CL2'HX'
EXITNAME DC    CL8'E15COBOL'
RECCTR   DC    P'0000000'
RECNR    DC    P'0000000'    RECNR AND CHARCTR MUST BE ADJACENT
LRECLIN  DC    P'00000'  ### CHANGED FROM DS TO DC TO FIX PROB
*                            OF 0C7 ABEND WHEN NO IP RECORDS
CHARCTR  DC    P'00000'
RECEDMSK DC    X'4020202020202020402020202020402020202120404040'
HEXSV15  DC    F'0'
SAVE13   DC    F'0'
SAVE14   DC    F'0'
SAVE15   DC    F'0'
SAVE0    DC    F'0'
SAVE1    DC    F'0'
BLANKS   DC    CL133' '                BLANKS MUST PRECEDE HEXTABLE
HEXTABLE DC    C'0123456789ABCDEF'
HEXCHAR  DC    CL133' '
         ORG   DSUTIL+(*+31-DSUTIL)/32*32    MUST IMMEDIATELY
*                                              FOLLOW HEXCHAR
  EJECT
***********************************************************************
*                       SNAP DCB                                      *
***********************************************************************
SNAP     DCB   DDNAME=SNAPDUMP,DSORG=PS,RECFM=VBA,MACRF=W,BLKSIZE=1632,X
               LRECL=125
   EJECT
***********************************************************************
*                     SYSIN DCB                                       *
***********************************************************************
CDDCB    DCB   DDNAME=SYSIN,DSORG=PS,EODAD=PARMBEOF,SYNAD=SYSERR,      C
               MACRF=GL
         SPACE
***********************************************************************
*                    SYSPRINT DCB                                     *
***********************************************************************
PRINT    DCB   DDNAME=SYSPRINT,DSORG=PS,MACRF=PL,EROPT=ACC,            X
               LRECL=133,RECFM=FBA,EXLST=PRTEXLST
PRTEXLST DC    0F'0',X'85',AL3(PRTEXIT)
        SPACE
***********************************************************************
*                    SYSUT1 DCB...PS                                  *
***********************************************************************
PSDCB    DCB   DDNAME=SYSUT1,DSORG=PS,EODAD=EXIT,EROPT=ACC,MACRF=GL,   X
               SYNAD=PSERR,EXLST=EXLIST1
         SPACE
***********************************************************************
*                      SYSUT1 DCB...IS                                *
***********************************************************************
ISDCB    DCB   DDNAME=SYSUT1,DSORG=IS,EODAD=EXIT,SYNAD=ISERR,          C
               MACRF=(GL,SK)
         SPACE
***********************************************************************
*                      SYSUT2 DCB...PS                                *
***********************************************************************
OUTDCB   DCB   DDNAME=SYSUT2,DSORG=PS,MACRF=PL,EXLST=UT2EXLST,         C
               SYNAD=PSERR
        SPACE
***********************************************************************
*                     SYSUT2 DCB...IS                                 *
***********************************************************************
OUTIS    DCB   DDNAME=SYSUT2,DSORG=IS,MACRF=PL,EXLST=UT2EXLST,         C
               SYNAD=ISERR
  EJECT
***********************************************************************
*                    PARM KEYWORD TABLE                               *
***********************************************************************
KWNAMES  DS    0F
         DC    CL8'ABEND'
         DC    A(AABEND)
         DC    CL8'TYPE'
         DC    A(ATYPE)
         DC    CL8'LINES'
         DC    A(ALINES)
         DC    CL8'STOP'
         DC    A(ASTOP)
         DC    CL8'STARTKEY'
         DC    A(ASTARTKE)
         DC    CL8'RKP'
         DC    A(ARKP)
         DC    CL8'SYSPRINT'
         DC    A(ASYSPRIN)
         DC    CL8'START'
         DC    A(ASTART)
         DC    CL8'SKIP'
         DC    A(ASKIP)
         DC    CL8'LAST'
         DC    A(ALAST)
         DC    CL8'MAXIOERR'
         DC    A(AMAXIOER)
         DC    CL8'MODNAME'
         DC    A(AMODNAME)
         DC    CL8'TRNAME'
         DC    A(ATRNAME)
         DC    CL8'MXRECERR'
         DC    A(AMXRECER)
         DC    CL8'ENDKEY'
         DC    A(AENDKEY)
         DC    CL8'ALLKEY'
         DC    A(AALLKEY)
         DC    CL8'SKIPKEY'
         DC    A(ASKIPKEY)
         DC    CL8'EXITNAME'
         DC    A(AEXITNAM)
         DC    CL8'COMPRESS'
         DC    A(ACOMPRES)
         DC    CL8'CMPRESS'
         DC    A(ACOMPRES)
         DC    CL8'EXPAND'
         DC    A(AEXPAND)
         DC    CL8'TYP'
         DC    A(ATYPE)
         DC    CL8'LNS'
         DC    A(ALINES)
         DC    CL8'STP'
         DC    A(ASTOP)
         DC    CL8'STKY'
         DC    A(ASTARTKE)
         DC    CL8'SPRT'
         DC    A(ASYSPRIN)
         DC    CL8'STRT'
         DC    A(ASTART)
         DC    CL8'SKP'
         DC    A(ASKIP)
         DC    CL8'LST'
         DC    A(ALAST)
         DC    CL8'IOER'
         DC    A(AMAXIOER)
         DC    CL8'MNM'
         DC    A(AMODNAME)
         DC    CL8'TNM'
         DC    A(ATRNAME)
         DC    CL8'RCER'
         DC    A(AMXRECER)
         DC    CL8'NDKY'
         DC    A(AENDKEY)
         DC    CL8'ALKY'
         DC    A(AALLKEY)
         DC    CL8'SKKY'
         DC    A(ASKIPKEY)
         DC    CL8'ABN'
         DC    A(AABEND)
         DC    CL8'CMP'
         DC    A(ACOMPRES)
         DC    CL8'EXP'
         DC    A(AEXPAND)
         DC    CL8'A'
         DC    A(ATYPE)
         DC    CL8'B'
         DC    A(ALINES)
         DC    CL8'C'
         DC    A(ASYSPRIN)
         DC    CL8'D'
         DC    A(ASTART)
         DC    CL8'E'
         DC    A(ASTOP)
         DC    CL8'F'
         DC    A(ASKIP)
         DC    CL8'G'
         DC    A(ALAST)
         DC    CL8'H'
         DC    A(ASTARTKE)
         DC    CL8'I'
         DC    A(AENDKEY)
         DC    CL8'J'
         DC    A(ASKIPKEY)
         DC    CL8'K'
         DC    A(AALLKEY)
         DC    CL8'L'
         DC    A(ARKP)
         DC    CL8'M'
         DC    A(ACOMPRES)
         DC    CL8'N'
         DC    A(AEXPAND)
          DC    CL8'SYSUT1'
          DC    A(KWPUT1X)
          DC     CL8'SYSUT2'
          DC    A(KWPUT2X)
         DC    CL8'O'
          DC    A(KWPUT1X)
        DC    CL8'P'
          DC    A(KWPUT2X)
         DC    CL8' '              * END OF TABLE INDICATOR
         DC    A(0)                *
  EJECT
***********************************************************************
*                       SAVEAREA WORKAREA                             *
***********************************************************************
SAVEAREA DSECT
         DS    18F
WORK     DS    D
WORK8    DS    0D
         DS    CL4
WORK4    DS    0CL4
         DS    CL1
WORK3    DS    0CL3
         DS    CL1
WORK2    DS    0CL2
         DS    C
WORK1    DS    C
DATE     DS    D
TIME     DS    D
ALLREGS  DS    16F
R2TR6    DS    5F
PRINTBUF DS    F
PTRMOD   DS    F
PTRVALID DS    F
PTRXLATE DS    F
MODPARM1 DC    F'0'                * THESE DC'S
MODPARM2 DC    F'0'                *  MUST
MODPARM3 DC    F'0'                *      BE
MODNAME  DS    2F                  *       CONTIGUOUS
SAVLRECL DS    H
MODCODE  DS    C
KEYLENTH DS    C
KEYTYPE  DC    CL2'  '
FIRSTSW  DC    X'0'
INRECFM  DS    C
CORECOM  DC    C'N'
COREEXP  DC    C'N'
ABENDCDE DC    X'00'
KWFLAG   DC    X'00'
STKYLEN  DC    X'00'
NDKYLEN  DC    X'00'
ALKYLEN  DC    X'00'
SKKYLEN  DC    X'00'
SYSPRINT DC    P'0000000'
LAST     DC    P'0000000'
LASTSV   DC    P'0000000'
SKIPST   DC    P'0000000'
SKIPND   DC    P'0000000'
#START   DC    P'0000000'
MXRECERR DC    P'0000000'
MXTOTREC DC    P'0000000'
SCNMXREC DC    P'0000000'
MAXIOERR DS    P'0000000'
#IOERRS  DS    P'0000000'
RECINSRT DS    P'0000000'
RECDLETE DS    P'0000000'
RECOUT   DS    P'0000000'
MAXACCPT DS    P'999999999999999'
NUMCHECK DC    C'0000000'
#CHAREAD DS    F
#CHAROUT DS    F
TRNAME   DS    D
#LINES   DS    D
PSPOS    DS    H
CARD1    DS    CL80
STARTKEY DC    XL256'0'
ENDKEY   DC    XL256'0'
ALLKEY   DC    XL256'0'
SKIPKEY  DC    XL256'0'
NSCSR1   DS    A        SAVE PTR TO NEW BUFFER
NSCS25   DS    4F
   EJECT
***********************************************************************
*                      MESSAGES                                       *
***********************************************************************
MESSAGES CSECT
ENDMSG1  DC    C'1INPUT DSN ='
ENDMSG2  DC    C'  RECFM=   , LRECL= , BLKSIZE= , DSORG=   .'
ENDMSG3  DC    C'0OUTPUT DSN ='
ENDMSG4  DC    C'  RECFM=   , LRECL= , BLKSIZE= , DSORG=   .'
ENDMSG5  DC    C'0STATISTICS:'
ENDMSG6  DC    C'0 RECORDS IN       =            ,,'
ENDMSG7  DC    C'  CHARACTERS IN    =  ,,,,'
ENDMSG8  DC    C'  RECORDS OUT      =            ,,'
ENDMSG9  DC    C'  CHARACTERS OUT   =  ,,,,'
ENDMSG10 DC    C'  RECORDS INSERTED =            ,,'
ENDMSG11 DC    C'  RECORDS DELETED  =            ,,'
ENDMSG12 DC    C'  I/O ERRORS       =            ,,'
ENDMSG13 DC    C'0OPTIONS:'
ENDMSG14 DC    C'0 TYPE     ='
ENDMSG15 DC    C'  LINES    = '
ENDMSG16 DC    C'  START    = '
ENDMSG17 DC    C'  STOP     = '
ENDMSG18 DC    C'  SKIP     =  - '
ENDMSG19 DC    C'  LAST     = '
ENDMSG20 DC    C'  SYSPRINT = '
ENDMSG21 DC    C'  RKP      = '
ENDMSG22 DC    C'  STARTKEY ='
ENDMSG23 DC    C'  ENDKEY   ='
ENDMSG24 DC    C'  SKIPKEY  ='
ENDMSG25 DC    C'  ALLKEY   ='
ENDMSG26 DC    C'  MODNAME  ='
ENDMSG27 DC    C'  TRNAME   ='
ENDMSG28 DC    C'  MAXIOERR = '
ENDMSG29 DC    C'  MXRECERR = '
ENDMSG33 DC    C'  COMPRESS ='
ENDMSG34 DC    C'  EXPAND   ='
ENDMSG30 DC    C'0   DATE =  ., TIME =  ..'
ENDMSG31 DC    C' NORMAL END '
ENDMSG32 DC    C' U N S U C C E S S F U L   E N D'
         EJECT
***********************************************************************
*            PRINTABLE CHARACTER TABLES                               *
***********************************************************************
*  THIS PRINTABLE CHAR TABLE IS SET FOR A 60 CHARACTER SET
XTABLE   CSECT
         DC    64X'0'
         DC    C' '
         DC    10X'00'
         DC    C'.<(+&&'
         DC    10X'00'
         DC    C'$*);^-/'
         DC    9X'00'
         DC    C',%_>?'
         DC    10X'00'
         DC    C':#@''="'
         DC    65X'00'
         DC    C'ABCDEFGHI'
         DC    7X'00'
         DC    C'JKLMNOPQR'
         DC    8X'00'
         DC    C'STUVWXYZ'
         DC    6X'00'
         DC    C'0123456789'
         DC    6X'00'
*  THIS PRINTABLE CHAR TABLE IS SET FOR A 60 CHARACTER SET
PRNTABLE CSECT
         DC    64X'0'
         DC    C' '
         DC    10X'00'
         DC    C'.<(+&&'
         DC    10X'00'
         DC    C'$*);^-/'
         DC    9X'00'
         DC    C',%_>?'
         DC    10X'00'
         DC    C':#@''="'
         DC    65X'00'
         DC    C'ABCDEFGHI'
         DC    7X'00'
         DC    C'JKLMNOPQR'
         DC    8X'00'
         DC    C'STUVWXYZ'
         DC    6X'00'
         DC    C'0123456789'
         DC    6X'00'
* THIS TABLE OF VALID CHARACTERS IS SET FOR EBCDIC CHARACTERS
VALIDTBL CSECT
VALIDBCD DC    64C'*',X'0',9C'*',7X'0',9C'*',8X'0',8C'*',6X'0'
         DC    9C'*',7X'0',C'*',9X'0',7C'*',9X'0',7C'*',9X'0'
         DC    22C'*',10X'0',2C'*',X'0',C'*',X'0',C'*',10X'0'
         DC    6C'*',X'0',C'*',8X'0',2C'*',X'0',3C'*',11X'0',5C'*'
DSUTIL   CSECT
         END
