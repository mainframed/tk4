         MACRO
         IDFIN10
         COPY IDFGBL
         AIF   (NOT &PIB(48)).TR
         MNOTE *,'IDF100 IN TRACE MODE ENTERING IDFIN10'
.TR      ANOP
         AIF   (&PIB(11)).IF2X
.**********************************************************************
.*                                                                    *
.*                       COMMAND OPERAND                              *
.*                                                                    *
.**********************************************************************
&M       SETA  4
&PIB(1)  SETB  (&PIB(2) AND &PIA(10) NE &M AND N'&SYSLIST(&M) GT 0)
         AIF   (NOT &PIB(1)).I0325
         IDFMSG1 100
.I0325   ANOP ,
&PIB(15) SETB  (&PIB(15) OR &PIB(1))
         AIF   (&PIB(2) AND &PIA(10) NE &M).CMDX
&PIB(1)  SETB  (&PIB(2) AND N'&SYSLIST(&M) EQ 0)
         AIF   (NOT &PIB(1)).I0326
         IDFMSG1 102
.I0326   ANOP ,
&PIB(15) SETB  (&PIB(15) OR &PIB(1))
&B(17)   SETB  (&PIB(2) AND &B(17))     SAVE FLAG ACROSS CONTINUATION
&PIB(2)  SETB  0                        STOP CONTINUATION
         AIF   (N'&SYSLIST(&M) EQ 0).CMDX
&B(8)    SETB  0
         AIF   (K'&SYSLIST(&M) LE 4 OR '&SYSLIST(&M)'(1,1) NE          X
               '(').CMD2
&I       SETA  2
&N       SETA  1
.CMD1    ANOP
&B(8)    SETB  ('&SYSLIST(&M)'(&I,1) EQ '(' OR '&SYSLIST(&M)'(&I,1) EQ *
               ',')
         AIF   (&B(8)).CMD2
&B(8)    SETB  (&N GT 1)
&C(1)    SETC  '&SYSLIST(&M,&N)'
&B(1)    SETB  (&B(1) AND &B(8) OR '&C(1)' EQ 'STOP' OR                X
               '&C(1)' EQ 'CANCEL')
&B(2)    SETB  (&B(2) AND &B(8) OR '&SYSLIST(&M,&N)' EQ 'CLEAR(STG)')
&B(3)    SETB  (&B(3) AND &B(8) OR '&C(1)' EQ 'SEND' OR                X
               '&C(1)' EQ 'DISC' OR '&SYSLIST(&M,&N)' EQ 'CLEAR(INQ)')
&B(4)    SETB  (&B(4) AND &B(8) OR                                     C
               '&SYSLIST(&M,&N)' EQ 'READ(RDR)')
&B(4)    SETB  (&B(4) OR '&C(1)' EQ 'PUNCH' OR '&SYSLIST(&M,&N)'       X
               EQ 'CLEAR(PCH)' AND NOT &PIB(24))
&B(4)    SETB  (&B(4) OR '&SYSLIST(&M,&N)' EQ 'CLEAR(RPB)' AND         X
               &PIB(24))
&B(5)    SETB  (&B(5) AND &B(8) OR '&C(1)' EQ 'PRINT' OR               X
               '&SYSLIST(&M,&N)' EQ 'CLEAR(LPB)')
         AIF   (K'&SYSLIST(&M,&N) LT 7).CMD1A
&B(5)    SETB  (&B(5) AND &B(8) OR '&SYSLIST(&M,&N)'(1,5) EQ 'SKIP('   *
               OR '&SYSLIST(&M,&N)'(1,7) EQ 'SKIPTO(')
.CMD1A   ANOP  , TOO FEW CHARACTERS FOR SKIP(D) OR SKIPTO(D)
&B(6)    SETB  (&B(6) AND &B(8) OR '&SYSLIST(&M,&N)' EQ 'READ(IDR)' OR *
               '&SYSLIST(&M,&N)' EQ 'CLEAR(IDR)')
&B(7)    SETB  (&B(7) AND &B(8) OR '&SYSLIST(&M,&N)' EQ 'READ(CCR)' OR *
               '&SYSLIST(&M,&N)' EQ 'CLEAR(CCR)')
&B(17)   SETB  (&B(17) AND &B(8) OR '&C(1)' EQ 'READ')            FSDB
&B(18)   SETB  (&B(18) AND &B(8) OR '&C(1)' EQ 'WRITE' OR '&C(1)' EQ   C
               'PURGE' OR '&SYSLIST(&M,&N)' EQ 'CLEAR(IOB)')      FSDB
         AIF   (K'&SYSLIST(&M,&N) LE 8).CM1B                      FSDB
&B(19)   SETB  ('&SYSLIST(&M,&N)'(1,5) EQ 'READ(')                FSDB
&B(18)   SETB  (&B(18) OR '&SYSLIST(&M,&N)'(1,6) EQ 'GETKEY' OR        C
               '&SYSLIST(&M,&N)' EQ 'PURGE(FILE)')                FSDB
         AIF   ('&SYSLIST(&M,&N)'(1,6) NE 'WRITE(' AND NOT &B(19)).CM1B
&C(1)    SETC  '&SYSLIST(&M,&N)'(7-&B(19),3)                      FSDB
&B(18)   SETB  (&B(18) OR '&C(1)' EQ 'KEY')                       FSDB
         AIF   (K'&SYSLIST(&M,&N) LE 10-&B(19)).CM1B              FSDB
&C(1)    SETC  '&SYSLIST(&M,&N)'(7-&B(19),4)                      FSDB
&B(18)   SETB  (&B(18) OR '&C(1)' EQ 'FILE' OR '&C(1)' EQ 'SAVE') FSDB
         AIF   (K'&SYSLIST(&M,&N) LE 13-&B(19)).CM1B              FSDB
&C(1)    SETC  '&SYSLIST(&M,&N)'(7-&B(19),7)                      FSDB
&B(18)   SETB  (&B(18) OR '&C(1)' EQ 'KEYNOTE' OR '&C(1)' EQ 'KEYLAST')
.CM1B    ANOP  ,                                                  FSDB
&J       SETA  &B(1)+&B(2)+&B(3)+&B(4)+&B(5)+&B(6)+&B(7)+&B(18)   FSDB
         AIF   (&J GT 1).CMD2
&B(8)    SETB  (&B(8) AND '&SYSLIST(&M,&N)' EQ 'C' AND &N EQ           *
               N'&SYSLIST(&M))
&I       SETA  &I+1+K'&SYSLIST(&M,&N)
&N       SETA  &N+1
         AIF   (&I LT K'&SYSLIST(&M)).CMD1
&B(8)    SETB  (&B(8) OR &B(17) AND NOT (&B(18) OR &B(4)))        FSDB
.CMD2    ANOP
 IDFDSP A
&A(4)    SETA  K'&SYSLIST(&M)-&B(8)
&N       SETA  1
&I       SETA  1+&B(8)
&A(3)    SETA  &A(4)+&B(8)*(K'&SYSLIST(&M,1)+1-&A(4))
.CMD3    ANOP
         AIF   (&I GT &A(3)).CMD20
&B(8)    SETB  ('&SYSLIST(&M)'(&I,1) EQ '(')
&I       SETA  &I+&B(8)
&B(1)    SETB  0                       3735
&B(2)    SETB  0                       STG
&B(3)    SETB  0                       INQ
&B(4)    SETB  0                       RDR/PCH/RPB
&B(5)    SETB  0                       LPB
&B(6)    SETB  0                       IDR
&B(7)    SETB  0                        CCR
&B(9)    SETB  0                        ABSOLUTE LINE NUMBER MODE
&B(16)   SETB  0                        LAST ACTION WAS PRINT
&B(18)   SETB  0                        FILE                      FSDB
&A(2)    SETA  0
         AIF   (&I+7 GT &A(3)).CMD6
         AIF   ('&SYSLIST(&M)'(&I,6) NE 'CLEAR,').CMD6
&J       SETA  &I+6
.CMD4    AIF   (&J+4 GT &A(3)).CMD5
&C(1)    SETC  '&SYSLIST(&M)'(&J,5)
&B(3)    SETB  ('&C(1)' EQ 'SEND,' OR '&C(1)' EQ 'SEND)' OR '&C(1)'    X
               EQ 'DISC,' OR '&C(1)' EQ 'DISC)')
&B(4)    SETB  ('&C(1)' EQ 'READ,' OR '&C(1)' EQ 'READ)')
&B(5)    SETB  ('&C(1)' EQ 'SKIP(')
&B(18)   SETB  ('&C(1)' EQ 'PURGE')     FILE PURGE                FSDB
         AIF   (&B(3) OR &B(4) OR &B(5) OR &B(18)).CMD6           FSDB
&J       SETA  &J+5
         AIF   (&J GT &A(3)).CMD5
&C(1)    SETC  '&C(1)'.'&SYSLIST(&M)'(&J,1)
         AIF   ('&C(1)' EQ 'CLEAR,').CMD4
&B(4)    SETB  ('&C(1)' EQ 'PUNCH,' OR '&C(1)' EQ 'PUNCH)')
&B(5)    SETB  ('&C(1)' EQ 'PRINT,' OR '&C(1)' EQ 'PRINT)')
         AIF   (&B(4) OR &B(5)).CMD6
&J       SETA  &J+1
         AIF   (&J GT &A(3)).CMD5
&B(5)    SETB  ('&C(1)'.'&SYSLIST(&M)'(&J,1) EQ 'SKIPTO(')
         AIF   (&B(5)).CMD6
&C(1)    SETC  '&C(1)'.'&SYSLIST(&M)'(&J,1)                       FSDB
&B(8)    SETB  ('&C(1)'(1,5) EQ 'READ(')
&B(18)   SETB  ('&C(1)' EQ 'GETKEY(')                             FSDB
         AIF   (&B(18)).CMD6            IF GETKEY GO PROCESS      FSDB
         AIF   (NOT &B(8) AND '&C(1)'(1,6) NE 'CLEAR(').CMD5
&J       SETA  &J-&B(8)
         AIF   (&J+4 GT &A(3)).CMD5
&J       SETA  &J+&B(8)                                           FSDB
&C(1)    SETC  '&C(1)'(6,2).'&SYSLIST(&M)'(&J,4)
&B(2)    SETB  ('&C(1)' EQ '(STG),' OR '&C(1)' EQ '(STG))')
&B(3)    SETB  ('&C(1)' EQ '(INQ),' OR '&C(1)' EQ '(INQ))')
&B(4)    SETB  ('&C(1)' EQ 'RDDR),' OR '&C(1)' EQ 'RDDR))' OR &PIB(24) X
               AND ('&C(1)' EQ '(RPB),' OR '&C(1)' EQ '(RPB))'))
&B(4)    SETB  (&B(4) OR NOT &PIB(24) AND ('&C(1)' EQ '(PCH),' OR      X
               '&C(1)' EQ '(PCH))'))
&B(5)    SETB  ('&C(1)' EQ '(LPB),' OR '&C(1)' EQ '(LPB))')
&B(6)    SETB  ('&C(1)' EQ 'IDDR),' OR '&C(1)' EQ 'IDDR))')
&B(7)    SETB  ('&C(1)' EQ 'CCCR),' OR '&C(1)' EQ 'CCCR))')
&B(18)   SETB  ('&C(1)' EQ '(IOB),' OR '&C(1)' EQ '(IOB))')       FSDB
         AIF   (&B(2) OR &B(3) OR &B(4) OR &B(5) OR &B(6) OR &B(7) OR  C
               &B(18)).CMD6  ANY VALID OP FOUND?                  FSDB
         AIF   (NOT &B(8) OR &J+3 GT &A(3)).CMD5 NOT READ OR VALIDFSDB
&B(18)   SETB  ('&SYSLIST(&M)'(&J-1,5) EQ 'FILE)' OR                   C
               '&SYSLIST(&M)'(&J-1,5) EQ 'SAVE)') FILE OP         FSDB
         AIF   (&B(18)).CMD6            FILE COMMAND?             FSDB
.CMD5    ANOP
&PIB(1)  SETB  1
         AIF   (NOT &PIB(1)).I0327
         IDFMSG 041  ILLEGAL USE OF CLEAR
.I0327   ANOP ,
&PIB(15) SETB  1
         AGO   .CMD20
.CMD6    ANOP  , RETURN FOR NEXT COMMAND WITHOUT ACCUMULATION
&B(10)   SETB  0                       CLEAR
&B(11)   SETB  0                       CANCEL/SKIP(D)
&B(12)   SETB  0                       STOP/SKIPTO(D)
&B(13)   SETB  0                       SKIP BEFORE PRINT
&B(14)   SETB  0                       OUTPUT/SEND
&B(15)   SETB  0                       INPUT/DISC
&B(19)   SETB  1                        SEQUENTIAL (TCP)          FSDB
&B(20)   SETB  1                        SAVE (TCP)                FSDB
&B(21)   SETB  0                        PURGE COMMAND             FSDB
&B(22)   SETB  0                        WRITE(KEYLAST)            FSDB
.CMD7    ANOP  , RETURN FOR NEXT COMMAND WITH ACCUMULATION
         AIF   (&I+3 GT &A(3)).CMD19
&C(1)    SETC  '&SYSLIST(&M)'(&I,4)
&I       SETA  &I+4
&B(1)    SETB  (&B(1) OR '&C(1)' EQ 'STOP')
&B(3)    SETB  (&B(3) OR '&C(1)' EQ 'SEND' OR '&C(1)' EQ 'DISC')
&B(12)   SETB  (&B(12) OR '&C(1)' EQ 'STOP')
&B(14)   SETB  (&B(14) OR '&C(1)' EQ 'SEND')
&B(15)   SETB  (&B(15) OR '&C(1)' EQ 'DISC' OR '&C(1)' EQ 'READ')
         AIF   ('&C(1)' EQ 'STOP' OR '&C(1)' EQ 'SEND' OR              X
               '&C(1)' EQ 'DISC').CMD11
         AIF   ('&C(1)' EQ 'READ').CMD9AA                         FSDB
         AIF   (&I GT &A(3)).CMD19
&C(1)    SETC  '&C(1)'.'&SYSLIST(&M)'(&I,1)
&I       SETA  &I+1
         AIF   (&B(15) AND '&C(1)' EQ 'CLEAR').CMD10A
&B(10)   SETB  (&B(10) OR '&C(1)' EQ 'CLEAR')
         AIF   ('&C(1)' EQ 'CLEAR').CMD9A                         FSDB
&B(8)    SETB  1
         AIF   ('&C(1)' EQ 'SKIP(').CMD8
&B(4)    SETB  (&B(4) OR '&C(1)' EQ 'PUNCH')
&B(5)    SETB  (&B(5) OR '&C(1)' EQ 'PRINT')
         AIF   ('&C(1)' EQ 'PRINT' AND &B(10) AND &B(5)).CMD9
&B(13)   SETB  (&B(13) OR (&B(11) OR &B(12)) AND '&C(1)' EQ 'PRINT')
&B(14)   SETB  (&B(14) OR '&C(1)' EQ 'PUNCH' OR '&C(1)' EQ 'PRINT')
         AIF   ('&C(1)' EQ 'PRINT' AND &B(16)).CMD19  NOT PRINT,PRINT
&B(16)   SETB  ('&C(1)' EQ 'PRINT')
         AIF   ('&C(1)' EQ 'PUNCH' OR '&C(1)' EQ 'PRINT').CMD11
&B(21)   SETB  ('&C(1)' EQ 'PURGE')                               FSDB
&B(14)   SETB  (&B(14) OR '&C(1)' EQ 'WRITE' OR '&C(1)' EQ 'PURGE')
&B(18)   SETB  (&B(18) OR '&C(1)' EQ 'WRITE' OR '&C(1)' EQ 'PURGE')
         AIF   ('&C(1)' EQ 'PURGE' OR '&C(1)' EQ 'WRITE').CMD9B   FSDB
         AIF   (&I GT &A(3)).CMD19
&C(1)    SETC  '&C(1)'.'&SYSLIST(&M)'(&I,1)
&I       SETA  &I+1
&B(1)    SETB  (&B(1) OR '&C(1)' EQ 'CANCEL')
&B(11)   SETB  (&B(11) OR '&C(1)' EQ 'CANCEL')
         AIF   ('&C(1)' EQ 'CANCEL').CMD11
&B(15)   SETB  (&B(15) OR '&C(1)' EQ 'GETKEY')                    FSDB
&B(18)   SETB  (&B(18) OR '&C(1)' EQ 'GETKEY')                    FSDB
         AIF   ('&C(1)' EQ 'GETKEY').CMD14A                       FSDB
         AIF   (&I GT &A(3)).CMD19
&C(1)    SETC  '&C(1)'.'&SYSLIST(&M)'(&I,1)
&I       SETA  &I+1
         AIF   ('&C(1)' NE 'SKIPTO(').CMD19
&B(8)    SETB  0
&PIB(1)  SETB  (&PIB(5) OR &PIB(8))
         AIF   (NOT &PIB(1)).I0328
         IDFMSG 042  SKIP ILLEGAL IN CYCLE OR SUMMARY
.I0328   ANOP ,
&PIB(15) SETB  (&PIB(15) OR &PIB(1))
         AIF   (&PIB(1)).CMD20
.CMD8    ANOP
&B(5)    SETB  1
&C(1)    SETC  '0000000'
&C(2)    SETC  '&SYSLIST(&M)'(&I,1)
.CMD8L   ANOP
&PIB(1)  SETB  ('&C(2)' LT '0' OR '&C(2)' GT '9')
         AIF   (NOT &PIB(1)).I0329
         IDFMSG 043  NONDECIMAL SKIP
.I0329   ANOP ,
&PIB(15) SETB  (&PIB(15) OR &PIB(1))
         AIF   (&PIB(1)).CMD20
&C(1)    SETC  '&C(1)'(2,6).'&C(2)'
&I       SETA  &I+1
&C(2)    SETC  '&SYSLIST(&M)'(&I,1)
         AIF   ('&C(2)' NE ')' AND '&C(1)'(1,1) EQ '0').CMD8L
&A(1)    SETA  &C(1)
&A(5)    SETA  2-&B(8)+&B(9)*(1-&B(8))*(&A(2)-2+&B(8))  LOWER LIMIT
&A(6)    SETA  16383
&PIB(1)  SETB  (&A(1) LT &A(5) OR &A(1) GT &A(6))
         AIF   (NOT &PIB(1)).I0330
         IDFMSG1 151  SKIP OR SKIPTO VALUE OUT OF RANGE
.I0330   ANOP ,
&PIB(15) SETB  (&PIB(15) OR &PIB(1))
         AIF   (&PIB(1)).CMD20
&B(12)   SETB  (&B(9) OR NOT &B(9) AND NOT &B(8))
&B(11)   SETB  (NOT &B(12))
&A(2)    SETA  &A(1)+&B(8)*&A(2)-&B(8)*&B(16)
&B(9)    SETB  (&B(12))
&B(16)   SETB  0
&I       SETA  &I+1
         AGO   .CMD11
.CMD9    ANOP
&PIB(1)  SETB  1
         AIF   (NOT &PIB(1)).I0332
         IDFMSG 045  PRINT COMMAND ILLEGAL AFTER CLEAR(LPB)
.I0332   ANOP ,
&PIB(15) SETB  1
         AGO   .CMD20
.CMD9A   AIF   (&I GT &A(3)).CMD11      NOT QUALIFIED CLEAR       FSDB
&C(1)    SETC  '&SYSLIST(&M)'(&I,1)     LOOK FOR DELIMITER        FSDB
         AIF   ('&C(1)' EQ ',' OR '&C(1)' EQ ')').CMD11           FSDB
         AIF   (&I+4 GT &A(3)).CMD19    NOT ENOUGH LEFT           FSDB
&C(1)    SETC  '&SYSLIST(&M)'(&I-1,6)   PICK UP QUALIFIER         FSDB
&B(8)    SETB  ('&C(1)' EQ 'R(IOB)')    CLEAR IOB COMMAND         FSDB
&B(19)   SETB  (NOT &B(8))              TURN OFF IF CLEAR         FSDB
&B(20)   SETB  (NOT &B(8))              TURN OFF IF CLEAR         FSDB
&B(18)   SETB  (&B(18) OR &B(8))        SAVE FILE STATUS          FSDB
&I       SETA  &I+&B(8)*5               BUMP PTR IF CLEAR         FSDB
         AIF   (&B(8)).CMD11            GO GEN CLEAR BYTES        FSDB
         AGO   .CMD10                   GO CHECK OTHER CLEARS     FSDB
.CMD9AA  AIF   (&I GT &A(3)).CMD11      END OF CMD GROUP          FSDB
         AIF   ('&SYSLIST(&M)'(&I,1) NE ',' OR &I+6 GT &A(3)).CMD9B
&B(8)    SETB  ('&SYSLIST(&M)'(&I+1,5) EQ 'WRITE') READ,WRITE     FSDB
&B(18)   SETB  (&B(18) OR &B(8))        ANY FILE COMMAND          FSDB
         AIF   (&B(8)).CMD11            READ,WRITE FOUND          FSDB
.CMD9B   AIF   (&I GT &A(3)).CMD11      NOT QUALIFIED             FSDB
&C(1)    SETC  '&SYSLIST(&M)'(&I,1)     LOOK FOR DELIMITER        FSDB
         AIF   ('&C(1)' EQ ',' OR '&C(1)' EQ ')').CMD11           FSDB
         AIF   (&I+4 GT &A(3)).CMD19    NOT ENOUGH LEFT           FSDB
&C(1)    SETC  '&SYSLIST(&M)'(&I,5)     PICK UP QUALIFIER         FSDB
&B(8)    SETB  ('&C(1)' EQ '(KEY)' AND NOT &B(21)) KEY NOT PURGE  FSDB
&B(18)   SETB  (&B(18) OR &B(8))        ANY FILE COMMAND          FSDB
&B(19)   SETB  (NOT &B(8))              TURN OFF FOR READ OR      FSDB
&B(20)   SETB  (NOT &B(8))               WRITE KEY COMMAND        FSDB
&I       SETA  &I+&B(8)*5               BUMP PTR IF COMMAND FOUND FSDB
         AIF   (&B(8)).CMD11            GO GEN BYTES              FSDB
         AIF   (&I+5 GT &A(3)).CMD10    GO CHECK OTHER CMDS       FSDB
&C(1)    SETC  '&C(1)'.'&SYSLIST(&M)'(&I+5,1) APPEND NEXT CHAR    FSDB
&B(8)    SETB  ('&C(1)' EQ '(SAVE)' AND NOT &B(21))               FSDB
&B(20)   SETB  (NOT &B(8))              TURN OFF IF SAVE NOT PURGEFSDB
&B(8)    SETB  (&B(8) OR '&C(1)' EQ '(FILE)') FILE QUALIFIER      FSDB
&B(18)   SETB  (&B(18) OR &B(8))        ANY FILE COMMAND          FSDB
&I       SETA  &I+&B(8)*6               BUMP IF COMMAND FOUND     FSDB
         AIF   (&B(8)).CMD11            GO GEN BYTES              FSDB
         AIF   (&I+8 GT &A(3)).CMD10    GO CHECK OTHER CMDS       FSDB
         AIF   ('&SYSLIST(&M)'(&I,1) NE '(').CMD19 NOT VALID      FSDB
&C(1)    SETC  '&SYSLIST(&M)'(&I+1,8)   GET QUALIFIER             FSDB
&B(8)    SETB  ('&C(1)' EQ 'KEYNOTE)' AND NOT &B(21)) NOT PURGE   FSDB
&B(22)   SETB  ('&C(1)' EQ 'KEYLAST)' AND &B(14) AND NOT &B(21))  FSDB
&B(19)   SETB  (NOT (&B(8) OR &B(22)))  OFF IF KEYNOTE OR KEYLAST FSDB
&B(20)   SETB  (NOT &B(22))             OFF IF KEYLAST            FSDB
&B(8)    SETB  (&B(8) OR &B(22))        EITHER QUALIFIER          FSDB
&B(18)   SETB  (&B(18) OR &B(8))        ANY FILE COMMAND          FSDB
&I       SETA  &I+&B(8)*9               BUMP PTR IF VALID         FSDB
         AIF   (&B(8)).CMD11            GO GEN BYTES              FSDB
         AGO   .CMD19                   INVALID COMMAND           FSDB
.CMD10   AIF   (&I GT &A(3)).CMD11
&C(1)    SETC  '&SYSLIST(&M)'(&I,1)
         AIF  ('&C(1)' EQ ',' OR '&C(1)' EQ ')').CMD11
         AIF   (&I+4 GT &A(3)).CMD19
&C(1)    SETC  '&SYSLIST(&M)'(&I-1,6)
&I       SETA  &I+5
&B(8)    SETB  ('&C(1)' EQ 'R(STG)')
&B(2)    SETB  (&B(2) OR &B(8))
         AIF   (&B(8)).CMD11
&B(8)    SETB  ('&C(1)' EQ 'R(INQ)')
&B(3)    SETB  (&B(3) OR &B(8))
         AIF   (&B(8)).CMD11
&B(8)    SETB  ('&C(1)' EQ 'D(RDR)' OR (NOT &PIB(24) AND '&C(1)' EQ    X
               'R(PCH)' OR &PIB(24) AND '&C(1)' EQ 'R(RPB)'))
&B(4)    SETB  (&B(4) OR &B(8))
         AIF   (&B(8)).CMD11
&B(8)    SETB ('&C(1)' EQ 'R(LPB)')
&B(5)    SETB  (&B(5) OR &B(8))
         AIF   (&B(8)).CMD11
&B(8)    SETB  ('&C(1)' EQ 'D(IDR)' OR '&C(1)' EQ 'R(IDR)')
&B(6)    SETB  (&B(6) OR &B(8))
         AIF   (&B(8)).CMD11
&B(8)    SETB  ('&C(1)' EQ 'D(CCR)' OR '&C(1)' EQ 'R(CCR)')
&B(7)    SETB  (&B(7) OR &B(8))
         AIF   (&B(8)).CMD11
.CMD10A  ANOP
&PIB(1)  SETB  1
         AIF   (NOT &PIB(1)).I0333
         IDFMSG 046  ILLEGAL CLEAR OR READ
.I0333   ANOP ,
&PIB(15) SETB  1
         AGO   .CMD20
.CMD11   AIF   (&I GT &A(3)).CMD12
&C(2)    SETC  '&SYSLIST(&M)'(&I,1)
         AIF   ('&C(2)' EQ ',' OR '&C(2)' EQ ')' AND &I EQ &A(3)).CMD12
&PIB(1)  SETB  1
         AIF   (NOT &PIB(1)).I0334
         IDFMSG1 103  INVALID CHARACTER
.I0334   ANOP ,
&PIB(15) SETB  1
         AGO   .CMD20
.CMD12   ANOP
&B(4)    SETB  (&B(4) OR &B(15) AND NOT (&B(1) OR &B(3) OR &B(5) OR    *
               &B(6) OR &B(7) OR &B(18)))                         FSDB
&J       SETA  &B(1)+&B(2)+&B(3)+&B(4)+&B(5)+&B(6)+&B(7)+&B(18)   FSDB
&PIB(1)  SETB  (&J NE 1)
         AIF   (NOT &PIB(1)).I0335
         IDFMSG 047  WRONG NUMBER OF DEVICES IN COMMAND GROUP
.I0335   ANOP ,
&PIB(15) SETB  (&PIB(15) OR &PIB(1))
         AIF   (&PIB(1)).CMD20
         AIF   ((&B(6) OR &B(7)) AND &I LT &A(3)).CMD7
         AIF   (NOT &B(1)).CMD13
&A(1)    SETA  104+&B(12)
         IDFASM A                       STOP, CANCEL
&PIB(11) SETB  (NOT &PIB(41))  UNCOND CANCEL OR STOP SETS DEAD CODE
&PIB(42) SETB  (&PIB(41))          IMPLICIT GOTO WHEN IF IS CODED
&PIB(1)  SETB  (&I LT &A(4))
         AIF   (NOT &PIB(1)).I0336
         IDFMSG1 105  EXCESS CHARACTERS IGNORED
.I0336   ANOP ,
         AGO   .CMDX
.CMD13   AIF   (NOT &B(2) AND NOT &B(3)).CMD14
&A(1)    SETA  113+&B(3)
         IDFASM A                       STG, INQ, CLEAR, SEND, DISC
&A(1)    SETA  64*&B(10)+32*&B(14)+16*&B(15)
         IDFASM A
&J       SETA  1+&B(3)
         AIF   (&B(2) OR NOT &B(14)).CMD17       PTR 72861        FSJW
&J       SETA  3                        POINT TO TIMEOUT R/O INDICATOR
         AGO   .CMD17A                  GO TO R/O INDICATOR ROUTINE
.CMD14   AIF   (NOT &B(4)).CMD14B       NOT 5496                  FSDB
&A(1)    SETA  115
         IDFASM A                       RDR, PCH, RPB
&A(1)    SETA  32*&B(10)*(1+&PIB(24))+16*&B(15)+8*&B(14)
         IDFASM A
&J       SETA  3
         AGO   .CMD17
.CMD14A  AIF   (&I+4 GT &A(3)).CMD19    INVALID COMMAND           FSDB
         AIF   ('&SYSLIST(&M)'(&I,2) NE '(''').CMD19 INVALID      FSDB
&I       SETA  &I+2                     POINT TO FIRST KEY CHAR   FSDB
         IDFASM (,4572)                 EMITTED DATA SOURCE       FSDB
         IDFASM (,4071)                 DATA TYPE - FUNCTION      FSDB
&A(1)    SETA  &A(3)-&I-1               GUESS CHAR COUNT          FSDB
&J       SETA  &PIA(6)                  SAVE COUNT BYTE LOCATION  FSDB
         IDFASM A                       COUNT BYTE                FSDB
&TB(3)   SETB  0                        INDICATE UNRESTRICTED     FSDB
&TB(4)   SETB  0                         CHARACTER KIND           FSDB
&TB(5)   SETB  0                          FOR TRANSLATE           FSDB
         AIF   (&PIB(23)).CMD14AA       KATAKANA                  FSDB
         IDFTR &SYSLIST(&M)             TRANSLATE                 FSDB
         AGO   .CMD14AB                                           FSDB
.CMD14AA IDFTRK &SYSLIST(&M)            TRANSLATE KATAKANA        FSDB
.CMD14AB IDFASM (,4174)                 RECORD SEPARATOR          FSDB
         AIF   (NOT &TB(4)).CMD14AC     VALID CHARACTERS          FSDB
&PIB(1)  SETB  1                        ISSUE MESSAGES            FSDB
&N       SETA  0                        SET SUBOPERAND PTR        FSDB
         IDFMSG1 103                    INVALID CHAR              FSDB
&PIB(15) SETB  1                        SET ERROR BIT             FSDB
         AGO   .CMD20                   EXIT                      FSDB
.CMD14AC ANOP  ,                                                  FSDB
&PIB(1)  SETB  1                        ISSUE MESSAGES            FSDB
         AIF   (NOT &TB(6)).CMD14AD     VALID CHAR                FSDB
         IDFMSG3 501                    UNPRINTABLE               FSDB
.CMD14AD AIF   (NOT &TB(7)).CMD14AE     VALID CHAR                FSDB
         IDFMSG3 502                    UNPRINTABLE ASCII         FSDB
.CMD14AE AIF   (NOT &TB(8)).CMD14AF     VALID CHAR                FSDB
         IDFMSG3 503                    UNPRINTABLE EBCDIC        FSDB
.CMD14AF ANOP  ,                                                  FSDB
&I       SETA  &I+2                     POINT TO NEXT DELIMITER   FSDB
         AIF   (&I GT &A(3)).CMD14AG    END OF GROUP              FSDB
&C(2)    SETC  '&SYSLIST(&M)'(&I,1)     PICK UP DELIMITER         FSDB
         AIF   ('&C(2)' EQ ',' OR '&C(2)' EQ ')' AND &I EQ             C
               &A(3)).CMD14AG           VALID DELIMITER           FSDB
&N       SETA  0                        SET SUBOPERAND PTR        FSDB
         IDFMSG1 103                    INVALID CHAR              FSDB
&PIB(15) SETB  1                        SET ERROR BIT             FSDB
         AGO   .CMD20                   EXIT                      FSDB
.CMD14AG ANOP  ,                                                  FSDB
&A(2)    SETA  &J+2+(&J-&J/486*486)/478*18 KEY START LOCATION     FSDB
&A(2)    SETA  &PIA(6)-&A(2)-(&PIA(6)/486-&A(2)/486)*18 KEY COUNT FSDB
&A(2)    SETA  &A(2)/2                  PACKED KEY COUNT          FSDB
         AIF   (&A(2) GE 2 AND &A(2) LE 16).CMD14AH VALID COUNT   FSDB
         MNOTE 8,'IDF780 KEY PARAMETER OF GETKEY COMMAND NOT'     FSDB
         MNOTE 0,'       BETWEEN 1 AND 15 CHARACTERS LONG'        FSDB
&PIB(15) SETB  1                        SET ERROR BIT             FSDB
         AGO   .CMD20                   EXIT                      FSDB
.CMD14AH AIF   (&A(1) EQ &A(2)).CMD14AI GUESS COUNT WAS OK        FSDB
&PIA(6)  SETA  &J                       GO BACK TO COUNT BYTE     FSDB
&A(1)    SETA  &A(2)                     AND GEN CORRECT          FSDB
         IDFASM A                         COUNT                   FSDB
&PIA(6)  SETA  &PIA(3)+&PIA(4)+&PIA(4)/480*18 GET BACK TO HIGHEST FSDB
.CMD14AI ANOP  ,                                                  FSDB
         IDFASM (,4170)                 FUNCTION - DATA SINK      FSDB
         IDFASM (,4075)                 DATA SINK - IOB           FSDB
         IDFASM (,4070)                 START BYTE 1              FSDB
         IDFASM (,4074)                 START BYTE 2              FSDB
         IDFASM A                       SINK COUNT                FSDB
         IDFASM (,4070)                 END CONTROL BYTE          FSDB
&B(19)   SETB  0                        SET UP BITS FOR           FSDB
&B(20)   SETB  1                         READ(KEYNOTE)            FSDB
&J       SETA  5                        SET INDEX TO IOB IN BUFB  FSDB
&BUFB(&J+53) SETB 0                     LAST OP NOT CLEAR         FSDB
&BUFB(&J+79) SETB 1                     DELIMIT TO IOB            FSDB
.CMD14B  AIF   (NOT &B(18)).CMD15       NO FILE COMMANDS          FSDB
         IDFASM (,4776)                 FILE IMMEDIATE BYTE       FSDB
&B(19)   SETB  (&B(19) AND NOT(&B(10) OR &B(21))) NOT CLEAR/PURGE FSDB
&B(20)   SETB  (&B(20) AND NOT(&B(10) OR &B(21))) NOT CLEAR/PURGE FSDB
&A(1)    SETA  64*&B(10)+32*&B(15)+16*&B(14)+8*&B(21)+4*&B(22)+2*&B(19)C
               +&B(20)                                            FSDB
         IDFASM A                       OPERATION BYTE            FSDB
&B(14)   SETB  (&B(14) AND NOT &B(21))  NOT OUTPUT IF PURGE       FSDB
&J       SETA  4                        PTR TO NRF IN ROIB ARRAY  FSDB
&ROIB(&J+57) SETB (NOT(&B(19) OR &B(10) OR &B(21))) KEY READ/WRITEFSDB
&ROIB(&J+29) SETB (NOT &ROIB(&J+1) AND &PIB(10) AND &ROIB(&J+29)) FSDB
&ROIB(&J+1) SETB (&ROIB(&J+57))         NRF IND IN USE            FSDB
&ROIB(1) SETB  (&ROIB(&J+57))           ANY RO IND IN USE         FSDB
&J       SETA  5                        PTR TO IOB IN BUFB ARRAY  FSDB
         AIF   (NOT &BUFB(&J+53) AND &BUFB(&J+79) OR &B(10) OR &B(19)  C
               OR &B(21)).CMD14C POSSIBLE ERROR?                  FSDB
         MNOTE 0,'IDF466 KEY AND/OR DELIMITER MAY NOT HAVE BEEN'
         MNOTE 0,'       PLACED INTO IOB BEFORE CURRENT OPERATION'
.CMD14C  AIF   (NOT &BUFB(&J+66) OR NOT &B(20) OR &B(19) OR &B(10) OR  C
               &B(21)).CMD14D                                     FSDB
         MNOTE 0,'IDF467 FILE SAVE PTR MAY HAVE BEEN ALTERED'
         MNOTE 0,'       WITHOUT PRIOR USE'                       FSDB
.CMD14D  AIF   (&BUFB(&J+66) OR &BUFB(&J+53) OR NOT &B(19) OR &B(10)   X
               OR &B(21)).CMD14E AJU 4/23/73                  FSDB
         MNOTE 0,'IDF468 FILE SAVE PTR MAY HAVE BEEN USED'        FSDB
         MNOTE 0,'       WITHOUT PRIOR SET'                       FSDB
.CMD14E  ANOP  ,                                                  FSDB
&BUFB(&J+66) SETB (&B(20))              LAST OP KEYNOTE OR FILE   FSDB
&BUFB(&J+79) SETB (&BUFB(&J+79) AND NOT &B(10)) RESET IF CLEAR    FSDB
         AGO   .CMD17                   GO CHECK BUFB             FSDB
.CMD15   AIF   (NOT &B(5)).CMD16
         AIF   (NOT &B(10) AND (&B(11) OR &B(12)) AND &B(14) OR        *
               &I GE &A(3)).CMD15B      TEST FOR NON-ACCUM OF COMMANDS
&I       SETA  &I+1                     ELSE PASS OVER COMMA
         AGO   .CMD7                    BACK FOR ANOTHER
.CMD15B  ANOP  , HERE WHEN READY TO ASSEMBLE FOR LINE PRINTER
&B(11)   SETB  (&B(11) AND &A(2) GT 0)
&B(12)   SETB  (&B(12) AND (NOT &B(17) OR &A(2) NE                     *
               &PRTA(14)+&B(14)-&B(13)))
&B(13)   SETB  ((&B(11) OR &B(12)) AND &B(13))
&B(17)   SETB  (&B(17) OR NOT &B(17) AND &B(9))
&J       SETA  4
         AIF   (NOT (&B(10) OR &B(11) OR &B(12) OR &B(14))).CMD15A
&A(1)    SETA  116                      LPB
         IDFASM A
&A(1)    SETA  64*&B(10)+32*&B(11)+16*&B(12)+8*&B(13)+4*&B(14)
         IDFASM A
         AIF   (NOT &B(11) AND NOT &B(12)).CMD15A
&PIB(1)  SETB  (&B(12) AND &A(2) LE &PRTA(14))
         AIF   (NOT &PIB(1)).I0337
         IDFMSG 044
.I0337   ANOP ,
&A(1)    SETA  (&A(2)-&B(12))/128       HIGH BYTE, ZERO ORIGIN
         IDFASM A
&A(1)    SETA  &A(2)-&B(12)-&A(1)*128   LOW BYTE, ZERO ORIGIN
         IDFASM A
.CMD15A  AIF   (NOT &B(12) AND NOT &B(9)).CMD17
&B(8)    SETB  (&B(14) AND &B(12) EQ &B(13))
&PRTA(14) SETA &A(2)+&B(8)
&A(2)    SETA  &PRTA(14)
&B(8)    SETB  (&PRTA(14) GT &PRTA(15))
&PRTA(15) SETA &PRTA(15)+&B(8)*(&PRTA(14)-&PRTA(15))
         AGO   .CMD17
.CMD16   AIF   (&I GE &A(3)).CMD16A     TEST FOR END OF SCAN
&I       SETA  &I+1                     NOT END, PASS COMMA
         AGO   .CMD7                    BACK FOR NEXT COMMAND
.CMD16A  ANOP
&A(1)    SETA  117
         IDFASM A
&A(1)    SETA  64*&B(10)+16*&B(15)*(1+&B(6))*(1-&B(10))
         IDFASM A
&J       SETA  12+&B(7)
         AIF   (NOT &B(10) OR NOT &B(15)).CMD17
&A(1)    SETA  117
         IDFASM A
&A(1)    SETA  16+16*&B(6)
         IDFASM A
.CMD17   ANOP  , SET UP BUFFER BITS FOR PATH/SEGMENT MESSAGES
&PIB(1)  SETB  (NOT &BUFB(&J+1) AND (&PIB(10) OR NOT (&B(10) OR        *
               &B(15))))
         AIF   (NOT &PIB(1)).I0338
         IDFMSG1 132  FIRST BUF OP NOT UNCOND CLEAR OR INPUT
.I0338   ANOP ,
&PIB(1)  SETB  ((&B(10) OR &B(15)) AND &BUFB(&J+40) AND &BUFB(&J+1))
         AIF   (NOT &PIB(1)).I0340
         IDFMSG1 133  MAY HAVE BEEN CLEARED/INPUT WITHOUT PRIOR OUTPUT
.I0340   ANOP ,
&PIB(1)  SETB  (&B(14) AND NOT &BUFB(&J+40) AND &BUFB(&J+1))
         AIF   (NOT &PIB(1)).I0342
         IDFMSG1 134  MAY HAVE BEEN OUTPUT WITHOUT PRIOR INPUT
.I0342   ANOP ,
&BUFB(&J+53) SETB (&B(10))              LAST OP CLEAR             FSDB
&BUFB(&J+40) SETB (&B(3) AND &B(14) OR &B(15)) INPUT              FSDB
&BUFB(&J+27) SETB (&BUFB(&J+1) AND &BUFB(&J+27) OR NOT &BUFB(&J+1)     *
               AND &B(14))
&B(8)    SETB  (&PIB(10) OR NOT (&B(10) OR &B(3) AND &B(14) OR &B(15)))
&BUFB(&J+14) SETB (&BUFB(&J+1) AND &BUFB(&J+14) OR NOT &BUFB(&J+1)     *
               AND &B(8))
&BUFB(&J+1) SETB 1
&BUFB(1) SETB  1
&B(8)    SETB  (&B(10) AND (NOT &B(4) OR &B(4) AND &PIB(24)) OR        *
               &B(14) AND &B(3) OR &B(15) AND NOT &B(3))
&BUFA(3*&J-2) SETA &BUFA(3*&J-2)+&B(8)*(1-&BUFA(3*&J-2))  SOURCE RESET
&B(8)    SETB  (&B(10) OR &B(14))
&BUFA(3*&J-1) SETA &BUFA(3*&J-1)+&B(8)*(1-&BUFA(3*&J-1))  SINK RESET
         AIF   (NOT &B(4) OR NOT &B(15)).CMD18  RETAIN ONLY READ(RDR)
&J       SETA  2                        POINT TO EOF(RDR) R/O INDICATOR
.CMD17A  ANOP  , READ-ONLY INDICATOR PROCESSING
&PIB(1)  SETB  (NOT &ROIB(&J+1) AND (&PIB(10) OR NOT (&B(3) AND &B(14) *
               OR &B(4) AND &B(15))))
         AIF   (NOT &PIB(1)).I03431
         IDFMSG1 140  FIRST OPERATION NOT UNCOND SEND OR READ
.I03431  ANOP  ,
&PIB(1)  SETB  (&ROIB(&J+1) AND &ROIB(&J+57) AND (&B(3) AND &B(14) OR  *
               &B(4) AND &B(15)))
         AIF   (&PIB(1)).I03432
         IDFMSG1 141  R/O IND MAY HAVE BEEN CLEARED WITHOUT TEST
.I03432  ANOP  ,
&ROIB(&J+57) SETB 1                     SHOW LAST OPERATION NOT TEST
&ROIB(&J+29) SETB (&ROIB(&J+1) AND &ROIB(&J+29) OR NOT &ROIB(&J+1) AND *
               (&PIB(10) OR NOT(&B(3) AND &B(14) OR &B(4) AND &B(15))))
&ROIB(&J+1) SETB 1                      SHOW THIS R/O INDIC USED
&ROIB(1) SETB  1                        SHOW SOME R/O INDIC USED
.CMD18   AIF   (&I GT &A(3)).CMD20
         AIF   ('&SYSLIST(&M)'(&I,1) EQ ')' AND &I EQ &A(3)).CMD20
&I       SETA  &I+1                     MUST BE COMMA, PASS OVER
         AGO   .CMD6
.CMD19   ANOP
&PIB(1)  SETB  1
         AIF   (NOT &PIB(1)).I0344
         IDFMSG1 150  COMMAND GROUP INVALID
.I0344   ANOP ,
&PIB(15) SETB  1
.CMD20   ANOP
&I       SETA  &A(3)+2
&N       SETA  &N+1
&A(3)    SETA  &A(3)+1+K'&SYSLIST(&M,&N)
&PIB(2)  SETB  ('&SYSLIST(&M,&N)' EQ 'C' AND &N EQ N'&SYSLIST(&M))
         AIF   (&I LT &A(4) AND NOT &PIB(2)).CMD3
&PIA(10) SETA  &M
.CMDX    ANOP
.**********************************************************************
.*                                                                    *
.*                 GOTO OPERAND                                       *
.*                                                                    *
.*********************************************************************
         AIF   (NOT &PIB(40)).GTX  IGNORE GOTO
&M       SETA  6
&N       SETA  1
         AIF   (T'&SYSLIST(&M) EQ 'O').GTX
&PIB(1)  SETB  (&PIB(2)) CONTINUATION
         AIF   (NOT &PIB(1)).I0361
         IDFMSG1 100     GOTO IGNORED
.I0361   ANOP ,
         AIF   (&PIB(1)).GTX
&PIB(1)  SETB  (K'&SYSLIST(&M,&N) GT 8)  EXCESS CHARS?
         AIF   (NOT &PIB(1)).I0362
         IDFMSG1 105   EXCESS CHARS IGNORED
.I0362   ANOP ,
.**********************************************************************
.*                                                                    *
.*                 SAVELOC - PART 4 (END SAVELOC)                     *
.*                                                                    *
.**********************************************************************
&I       SETA  &QA3(1) GET DESTQ PTR
&PIB(1)  SETB  (&I LE 0) DESTQ EMPTY
         IDFMSG 0 FDM SYSTEM ERROR
         IDFMSG3 511 DESTQ EMPTY
&PIB(15) SETB  (&PIB(15) OR &PIB(1))
         AIF   (&PIB(1)).GTX
.** THE FOLLOWING SEVEN CARDS WERE USED TO CONCATENATE
.** BLANKS BECAUSE OF A PROBLEM WITH DOS/VS (IPK089)
.** -- SETC SYMBOL GREATER THAN 8 CHARACTERS.
         AIF   (K'&SYSLIST(&M,&N)  GE 8).SL10A
&A(1)    SETA  K'&SYSLIST(&M,&N)
&A(2)    SETA  8-&A(1)
&C(1)    SETC  '&SYSLIST(&M,&N)'(1,&A(1)).'       '(1,&A(2))
         AGO   .SL2
.SL10A   ANOP
&C(1)    SETC  '&SYSLIST(&M,&N)'(1,8)
.SL2     ANOP
&J       SETA  &I J FOLLOWS I
&I       SETA  &QA1(&I)/65536 CHAIN TO NEXT
         AIF   (&I EQ 0).SL3X EMPTY OR END
         AIF   ('&C(1)' NE '&QC(&I)').SL2 NO SAVELOC FOR THIS NAME
&B(1)    SETB  (&PIB(5) NE &QB4(&I))                           A01301
         AIF   (NOT &B(1)).SL21                                A01301
&PIB(15) SETB  1                                               A01301
         MNOTE 8,'IDF791 INVALID BRANCH INTO CYCLE OR SUMMARY BLOCK'
.**                                                            A01301
.SL21    ANOP  ,                                               A01301
&A(3)    SETA  &PRTA(7)  SAVE ORIGIN LINE
&A(4)    SETA  &PRTA(12)  AND COLUMN
&A(5)    SETA  &QA4(&I)/256  SAVE DESTINATION LINE
&A(6)    SETA  &QA4(&I)-&A(5)*256 AND COLUMN
&B(1)    SETB  (&A(6) GT &ECA(1))
&ECA(3)  SETA  &A(6)+&B(1)*(&ECA(1)-&A(6))
&ECA(4)  SETA  &ECA(3)
.SL3     AIF   (&PTAB(&ECA(3))).SL4
&B(1)    SETB  (&ECA(3) GE &A(6))
&ECA(3)  SETA  2*&A(6)-&ECA(3)-&B(1)
&ECA(4)  SETA  2*&A(6)-&ECA(3)
         AGO   .SL3
.SL4     ANOP
&PIB(1)  SETB  (&A(3) GT &A(5)) SCROLL ERROR
         IDFMSG3 505
&PIB(15) SETB  (&PIB(15) OR &PIB(1))
         AIF   (&PIB(1)).GTX
&PIA(6)  SETA  &PIA(3)+&PIA(4)+&PIA(4)/480*18
&N       SETA  &A(4)
         AIF   (&A(3)*256+&A(4) EQ &QA4(&I)).SL11
&B(1)    SETB  (&A(3) EQ &A(5))
&B(2)    SETB  (&A(3)+75 GT &A(5) OR &PIB(8) OR &PIB(5))
&B(3)    SETB  (&B(2) AND &N LT &ECA(3) AND &N LT &ECA(4) AND          C
               (&B(1) OR &N NE &DFA(2)))
&B(5)    SETB  ((&N LE &ECA(3) OR &N LE &ECA(4)) AND &N NE &DFA(2))
&B(6)    SETB  (&N GT &ECA(1) AND 2*&A(6) GT &ECA(1)+&N AND            C
               (&B(1) OR &A(6) LE &DFA(2)+127))
&B(4)    SETB  ((&B(5) OR &B(6)) AND &B(2) AND NOT &B(3) AND &N        C
               NE &A(6))
         IDFASM (,4770)
         AIF   (&B(4)).SL7
         AIF   (NOT &B(3)).SL8
&A(1)    SETA  32 TABS
.SL6     ANOP
&N       SETA  &N+1
&A(1)    SETA  &A(1)+&PTAB(&N)
         AIF   (&N NE &ECA(3) AND &A(1) NE 47).SL6
         IDFASM A
&A(4)    SETA  &N
         AIF   (&A(3)*256+&A(4) EQ &QA4(&I)).SL11
         IDFASM (,4770)
&A(1)    SETA 32
         AIF   (&N NE &ECA(3)).SL6
         AIF   (&A(3) NE &A(5)).SL8
.SL7     ANOP
&A(1)    SETA  (&A(6)-&N)*2
&A(1)    SETA  31-(&A(1)+31)/(&A(1)+30)*(15+&A(1)/2)+(&A(1)+3)/(&A(1)+2C
               )*(&A(1)-16)+(&A(1)-29)/(&A(1)-30)*(15-&A(1)/2)
&N       SETA  &N+&A(1)+&A(1)/16*2*(8-&A(1))
&A(4)    SETA  &N
         IDFASM A
         AIF   (&A(3)*256+&A(4) EQ &QA4(&I)).SL11
         IDFASM (,4770)
         AIF   (&N NE &A(6)).SL7
.SL8     ANOP
&B(1)    SETB  ((&N NE &ECA(3) OR &ECA(3) EQ &DFA(2)) AND (&N NE       C
               &A(6) OR &A(6) EQ &DFA(2)))
&A(1)    SETA  2*&A(5)-2*&A(3)
&A(1)    SETA  (&A(1)-27)/(&A(1)-28)*(15-&A(1)/2)+&A(1)/2+&B(1)*16+48
&N       SETA  &N+&B(1)*(&DFA(2)-&N)
&A(3)    SETA  &A(3)+&A(1)-&A(1)/16*16
         IDFASM A
         AIF   (&A(3) EQ &A(5) AND &N NE &DFA(2)).SL9
         AIF   (&A(3)*256+&A(4) EQ &QA4(&I)).SL11
         IDFASM (,4770)
         AIF   (&A(3) NE &A(5)).SL8
         AIF   (&N EQ &ECA(3)).SL7
&A(1)    SETA  32
         AGO   .SL6
.SL9     ANOP
         IDFASM (,4676)
&A(1)    SETA  &N-&DFA(2)
         IDFASM A
         AIF   (&N EQ &A(6)).SL11
         IDFASM (,4770)
         AGO   .SL7
.SL11    ANOP
         IDFASM (,4671) GEN BRANCH BYTE
&A(2)    SETA  &QA2(&I) GET LOCATION TO BRANCH TO
&A(1)    SETA  &PIA(6)+4+(&PIA(6)-&PIA(6)/486*486)/476*18
&A(2)    SETA  &A(1)-&A(2)-(&A(1)/486-&A(2)/486)*18
&A(2)    SETA  &A(2)/2
&A(1)    SETA  64+&A(2)/234*2+(&A(2)-&A(2)/234*234)/128
         IDFASM A
&A(2)    SETA  &A(2)-&A(2)/234*234
&A(1)    SETA  &A(2)-&A(2)/128*128
         IDFASM A
         AIF   (&QA3(&I) GT 255).SL12
&QA3(&I) SETA  &QA3(&I)-1
         AIF   (&QA3(&I) GT 0).SL12
&QA1(&J) SETA  &QA1(&J)-&QA1(&J)/65536*65536+&QA1(&I)/65536*65536
&QA1(&I) SETA  &QA1(&I)-&QA1(&I)/65536*65536+&QA4(1)*65536
&QA4(1)  SETA  &I
.SL12    ANOP
&A(5)    SETA  &QA1(&I)-&QA1(&I)/65536*65536
&A(6)    SETA  &A(5)-&A(5)/256*256
&A(5)    SETA  &A(5)/256
&PIB(1)  SETB  1
         IDFMSG 017  BRANCH TO PATH SEGMENT
&PIB(42) SETB  (&PIB(41)) IMPLICIT GOTO IF 'IF'
&PIB(11) SETB  (NOT &PIB(41)) DEAD CODE
         IDFDSP 'AFTER SAVELOC PART 3',QUEUE
         AGO   .GTX
.SL3X    ANOP
.**********************************************************************
.*                                                                    *
.*                 EXPLICIT GOTO PROCESSOR                            *
.*                                                                    *
.**********************************************************************
&K       SETA  &QA4(1)  GET FREE Q PTR
&PIB(1)  SETB  (&K EQ 0)
         AIF   (NOT &PIB(1)).I0363
         IDFMSG3 510
.I0363   ANOP ,
&PIB(15) SETB  (&PIB(15) OR &PIB(1))
         AIF   (&PIB(1)).GTX
.** THE FOLLOWING SEVEN CARDS WERE USED TO CONCATENATE
.** BLANKS BECAUSE OF A PROBLEM WITH DOS/VS (IPK089)
.** -- SETC SYMBOL GREATER THAN 8 CHARACTERS.
         AIF   (K'&SYSLIST(&M,&N)  GE 8).GT1A
&A(1)    SETA  K'&SYSLIST(&M,&N)
&A(2)    SETA  8-&A(1)
&QC(&K)  SETC  '&SYSLIST(&M,&N)'(1,&A(1)).'       '(1,&A(2))
         AGO   .GT1B
.GT1A    ANOP
&QC(&K)  SETC  '&SYSLIST(&M,&N)'(1,8)
.GT1B    ANOP
&PIB(1)  SETB  (N'&SYSLIST(&M) GT 1)
         IDFMSG1 104 EXCESS SUBOPS IGNORED
&J       SETA  0
&I       SETA  &QA1(1)  GET ORGIN Q PTR
.GT2     AIF   (&I EQ 0).GT3 IF NEW ENTRY WILL BE FIRST OR LAST, BRANCH
.* SCAN QUEUE FOR INSERTION POINT IN EXPLICIT REGION
         AIF   ('&QC(&I)' GE '&QC(&K)' AND NOT &QB1(&I)).GT3
&J       SETA  &I  SAVE PTR TO THIS ENTRY
&I       SETA  &QA1(&I)/65536  POINT AT NEXT CHAINED ENTRY
         AGO   .GT2  CONTINUE SCAN
.GT3     ANOP
&QA4(1)  SETA  &QA1(&K)/65536  UPDATE FREE Q PTR
&QA1(&K) SETA  &I*65536  SET CHAIN PTR IN NEW ENTRY
         AIF   (&J EQ 0).GT4 IS NEW ENTRY 1ST ON CHAIN?
.* UPDATE CHAIN PTR OF PREVIOUS ENTRY TO POINT TO NEW ENTRY
&QA1(&J) SETA  &QA1(&J)-&QA1(&J)/65536*65536+&K*65536
         AGO   .GT5
.GT4     ANOP
&QA1(1)  SETA  &K POINT ORIGIN Q PTR TO NEW ENTRY WHICH IS NOW 1ST
.GT5     ANOP
&I       SETA  &QA3(1) GET DESTINATION Q PTR
&PIB(1)  SETB  (&I EQ 0)
         AIF   (NOT &PIB(1)).I0365
         IDFMSG 0
         IDFMSG3 511
.I0365   ANOP ,
&PIB(15) SETB  (&PIB(15) OR &PIB(1))
         AIF   (&PIB(1)).GTX
.* GET PATH/SEGMENT FROM 1ST DESTQ ENTRY - PUT IN THIS ENTRY
&QA1(&K) SETA  &QA1(&K)/65536*65536+(&QA1(&I)-&QA1(&I)/65536*65536)
.* SET LENGTH OF 13 AND LOC CTR IN THIS ENTRY
&J       SETA  13
&QA2(&K) SETA  &J*65536+&PIA(3)+&PIA(4)+&PIA(4)/480*18
.*  SET LINE/COLUMN IN THIS ENTRY
&QA4(&K) SETA  &PRTA(7)*256+&PRTA(12)
&QA3(&I) SETA  &QA3(&I)+65536  BUMP NO. OF UNRESOLVED BRANCHES IN DESTQ
&PIB(10) SETB  1 INDICATE CONDITIONAL SEGMENT
&QB1(&K) SETB  0    ZERO THE
&QB2(&K) SETB  0
&QB3(&K) SETB  0      OF THIS ORIGIN
&QB4(&K) SETB  (&PIB(5)) IN CYCLE
&QB5(&K) SETB  (&PIB(8)) IN SUMMARY
&PIA(6)  SETA  &PIA(3)+&PIA(4)+&PIA(4)/480*18
&PIA(8)  SETA  &PIA(6)+2*&J+(&PIA(6)-&PIA(6)/486*486+2*&J)/480*18
&PIB(42) SETB  (&PIB(41)) NO 'IF' - NO IMPLICIT GOTO
&PIB(30) SETB  1             BEGIN A NEW SEGMENT
&PIB(11) SETB  (NOT &PIB(41)) UNCOND GOTO SETS DEAD CODE
&PIB(9)  SETB  (&PIB(8) AND NOT &PIB(41)) POST SUMMARY
.GTX     ANOP
         AIF   (NOT &PIB(47)).DSP15                            A01301
         IDFDSP 'AFTER EXPLICIT GOTO',QUEUE,PIB
.DSP15   ANOP
.**********************************************************************
.*                                                                    *
.*                           IF OPERAND PROCESSOR - PART 2            *
.*                                                                    *
.**********************************************************************
         AIF   (NOT &PIB(41)).IF2X  'IF' NOT CODED
&PIB(41) SETB  0   RESET 'IF' CODED BIT
         AIF   (&PIA(8) LE &PIA(3)+&PIA(4)).IF10 'GOTO' NOT CODED
&J       SETA  13 GENERATE NOP'S
.IF9     IDFASM (,4670)      TO FILL SPACE
&J       SETA  &J-1         RESERVED FOR
         AIF   (&J GE 1).IF9      'GOTO'
.* IF ADDR IN 'IF' IS ALREADY POINTING TO NEXT FCD, EXIT
.IF10    AIF   (&FA(1)+30 EQ &PIA(6)-(&PIA(6)/486-&FA(1)/486)*18).IF11
.*  CALCULATE DISPLACEMENT TO DESTINATION IN UNPACKED BYTES
&A(2)    SETA  &FA(1)+4+(&FA(1)-&FA(1)/486*486)/476*18
&A(2)    SETA  &PIA(6)-&A(2)-(&PIA(6)/486-&A(2)/486)*18
&A(2)    SETA  &A(2)/2 CONVERT TO PACKED BYTE DISP
.*  CALCULATE HIGH ORDER DISP ADDR BYTE IN SECTOR/BYTE FORMAT
&A(1)    SETA  &A(2)/234*2+(&A(2)-&A(2)/234*234)/128
&PIA(6)  SETA  &FA(1)  ORG BACK TO FILL IN 'IF' ADDR
         IDFASM A
.*  CALCULATE LOW ORDER DISP ADDR BYTE IN BYTE FORMAT
&A(2)    SETA  &A(2)-&A(2)/234*234
&A(1)    SETA  &A(2)-&A(2)/128*128
         IDFASM A
.IF11    ANOP
&K       SETA  &QA3(1)  PICK UP DEST Q PTR
&PIB(1)  SETB  (&K LE 0)  DEST Q EMPTY?
         AIF   (NOT &PIB(1)).I0366
         IDFMSG 0
         IDFMSG3 511
.I0366   ANOP ,
&PIB(15) SETB  (&PIB(15) OR &PIB(1))
         AIF   (&PIB(1)).IF2X
&PIB(10) SETB  (&QA3(&K)/65536 GT 0)  SET CONDITIONAL BIT
.IF2X    ANOP
         AIF   (NOT &PIB(48)).TX
         MNOTE *,'IDF100 IN TRACE MODE LEAVING IDFIN10'
.TX      ANOP
         MEND
