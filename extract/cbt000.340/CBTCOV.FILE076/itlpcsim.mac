         MACRO
         ITLPCSIM &TYPE=FULL,&CTRLPGM=
         GBLA  &GTR   MAY BE SET TO NONZERO EXTERNALLY TO TRACE
         GBLC  &COUNTS   MAY BE SET TO 'Y' EXTERNALLY TO COUNT
         GBLC  &GCP
         LCLA  &TRDSPL
&GCP     SETC  'O'
         AIF   ('&TYPE' EQ 'NULL').NORELOC                     1/6/76
         TITLE 'ITEL RELOCATABLE 370 INSTRUCTION SIMULATOR MODULE'
***********************************************************************
* INSTRUCTION SIMULATION MODULE                                       *
*                                                                     *
* COPYRIGHT 1974 BY                                                   *
*        ITEL CORPORATION                                             *
*        DATA PRODUCTS GROUP                                          *
*        3460 WEST BAYSHORE ROAD                                      *
*        PALO ALTO, CALIFORNIA 94303                                  *
*                                                                     *
***********************************************************************
ITLSIS&GCP CSECT
         USING *,QR15
         B     *+24
         DC    C'COPYRIGHT ITEL 1974 '
         AIF   (&GTR EQ 0).NOTRACE
&TRDSPL  SETA  8*&GTR-8
         AIF   (&GTR EQ 1).TRACE1
         MVC   TRACETBL(&TRDSPL),TRACETBL+8 * MOVE TRACE TABLE DOWN
.TRACE1  ANOP
         MVC   TRACETBL+&TRDSPL.(8),QPRGOLD * TRACE PGM OLD PSW
.NOTRACE ANOP
         TM    QSW1,REENTRY *          PGM CHK DURINT SIS
         BO    SISPC *                 YES, SIS GENERATED PGM CHK
         OI    QSW1,REENTRY *          SET SIS IN CTL (FOR  REENTRY)
         L     QR1,IHLCON1           GET POINTER TO IEAPKSAV
         MVC   QPCSV(64),0(QR1) *       SAVE PFLIH REGS
         LM    QR0,QR1,QPRGOLD       GET PRG OLD
         STM   QR0,QR1,QPGOPSW       SAVE PSW
         TM    QPRGADR+3,X'01'       TEST IF ODD BNDRY BRANCH
         BO    QPCEX0                YES,EXIT
* BACK UP PSW ADDR (QR1) TO START OF INST
         TM    QPRGADR,B'11000000'   TEST IF ILC=0
         BZ    QPCEX0                YES-IMPRECISE-EXIT
         L     QR10,QPRGADR          GET ADDR PART OF PSW
         L     QR11,Q4N02            GET ILC&LEN FACTOR
         SLR   QR10,QR11               SUBTRACT MINIM
         CLR   QR10,QR11               TEST IF DONE
         BNL   *-4                     LOOP
         LA    QR1,0(,QR10)          QR1 POINTS TO FAILING INST
         ALR   QR10,QR11             AT  LEAST 2
         TM    0(QR1),B'11000000'    TEST OP CDE FORMAT
         BM    *+10                  LENGTH 4
         BZ    *+8                   LENGTH 2
         ALR   QR10,QR11             LENGTH 6
         ALR   QR10,QR11             ADD LENGTH MINIM
         ST    QR10,QPRGADR          SAVE NEXT ADDR
         EJECT
****************************************************************
*
QFMTDCDE DS    0H                    INST FORMAT DECODE
* INSTRUCTION DECODE
* RR TYPE  QR1 POINTS TO INST
*          QR2 POINTS TO SAVED R1
*          QR6 POINTS TO SAVED R2
* RS TYPE  QR1 POINTS TO INST
*          QR2 POINTS TO SAVED R1
*          QR3 CONTAINS M3 OR R3
*          QR5 CONTAINS SUM(B2)+D2
* SI TYPE  QR1 POINTS TO INST
*          QR3 CONTAINS I2 OR EXTENDED OP CODE
*          QR4 POINTS TO B1 D1
* RX TYPE QR1 POINTS TO INST
*          QR2 POINTS TO SAVED R1
*         QR7 CONTAINS SUM(X2 NE 0)+(B2 NE 0)+D2
* SS TYPE  QR1 POINTS TO INST
*          QR3 CONTAINS L1/I3
*          QR4 CONTAINS SUM(B1)+D1
*          QR5 CONTAINS SUM(B2)+D2
*
***********************************************************************
         SPACE 2
         LH    QR11,2(,QR1)          GET B2 D2
         BAL   QR14,QB1D1            COMPUTE SUM (B2 NE 0)+D2
         LR    QR4,QR5               SET QR4=SUM(B1 NE 0)+D1
         SR    QR3,QR3               CLEAR QR3
         IC    QR3,1(,QR1)           R1/R2,R1/R3,R1/M3,R1/X2
         BAL   QR14,QR1R2              POINT QR2/QR6 TO SAVED R1/R2
         TM    0(QR1),B'11000000'    TEST IF SS TYPE
         BNO   *+12                  NO,SKIP B1D1 CALC
         LH    QR11,4(,QR1)          GET B1 D1
         BAL   QR14,QB1D1            COMPUTE SUM (B1 NE 0)+D1
         SR    QR11,QR11             CLEAR QR11
         TM    1(QR1),X'0F'          TEST IF X2=0
         BZ    *+8                   YES SKIP INDEX COMP
         L     QR11,0(,QR6)          GET SAVED X2
         LA    QR7,0(QR11,QR4)         QR7=SUM(X2NE0)+(B1NE0)+D2
*                                    END DECODE
         EJECT
****************************************************************
* TEST FOR AND PROCESS EXECUTE INST
         CLI   0(QR1),X'44'          TEST IF EXECUTE INST
         BNE   QPCNORM               NO,NORMAL
         LH    QR11,0(,QR7)          TEST INST BOUNDARY
         CLI   QNTCD2,QEXEX          TEST IF EX EXC
         BE    QPCEX0                YES,TERMINATE
* MOVE IT TO SPECIAL EXECUTION AREA
         MVC   QTMP0-4(6),0(QR7)     MOVE TARGET TO XEQ AREA
         TM    1(QR1),X'F0'          TEST IF R1 FIELD 0
         BZ    *+10                  YES,SKIP EX MODIFIER
         OC    QTMP0-3(1),3(QR2)     OR 'EX' MODIFIER(BYTE 3 OF R1)
         LA    QR1,QTMP0-4           SET INST ADDR TO SP AREA
         B     QFMTDCDE              DECODE EXECUTE TARGET
* END EXECUTE PROCESSING
****************************************************************
QPCNORM  DS    0H                    NORMAL PROCESS
         L     QR12,QPRGADR          SET UP USER CC&PRG MASK
         IC    QR10,QAMWP            GET USER KEY/AMWP
         N     QR10,QF0              ISOLATE KEY
         BAL   QR14,QSTEXTMD         SET STG&PSW KEY TO USERS
         EJECT
***********************************************************************
* LOOK UP OP CODE IN TAB - FORMAT OPCDE/DESCRIPTION/PROCESSOR
QPCOP    DS    0H                    OPERATION EXCEPTION
         LA    QR9,QINSTB            START OP TBL
         LA    QR10,3                BYTES/ENTRY
         LA    QR11,QINSTBL-2        END OF OP TBL
         IC    QR8,0(,QR1)           GET OP CODE
         STC   QR8,QCDS+1            SAVE FOR COMPARE
QCDS     CLI   0(QR9),00             OP FILLIN=TABL VAL
         BE    QDCDE                 YES GO DECODE INST
         BXLE  QR9,QR10,QCDS         LOOP
         CLI   QNTCD2,QSPEX          TEST IF SPEC EX
         BNE   QPCEX0                NOT HANDLED-ERR EXIT
         BAL   QR14,QSPCEX           DO SPECIFICATION EXCEPTIONS
         B     QPCEX1                EXIT
QDCDE    DS    0H                    DECODE INSTRUCTION
         MVC   QTMP6(2),1(QR9)       ALIGN ADDR
         LH    QR11,QTMP6            LOAD IT
         LA    QR11,QINSTBE(QR11)    ADDRESS QUASI EXECUTOR
         SPM   QR12                  SET USER CC&PRG MASK
         BALR  QR14,QR11             GO TO QUASI
         B     QPCEX1                EXIT COMPLETE
         EJECT
QINSTB   DS    0H                    INSTRUCTION TABLE
         DC    X'BA'                 COMPARE AND SWAP
         DC    AL2(QCS-QINSTBE)
         DC    X'BB'                 COMPARE DOUBLE AND SWAP
         DC    AL2(QCDSI-QINSTBE)
         AIF   ('&TYPE' EQ 'SHORT').BYPREST                 1/6/76
         DC    X'AC' *                  STNSM
         DC    AL2(QSTNSM-QINSTBE) *    STNSM QUASI RTN
         DC    X'AD' *                  STOSM
         DC    AL2(QSTOSM-QINSTBE) *    STOSM QUASI RTN
         DC    X'B1' *                 LRA
         DC    AL2(QLRA-QINSTBE) *     LRA QUASI RTN
         DC    X'B2'                 STIDP/STIDC/SCK/STCK
         DC    AL2(QCSUB-QINSTBE)    CSUB QUASI RTN
         DC    X'BD'                 CLM
         DC    AL2(QCLM-QINSTBE)     CLM  QUASI RTN
         DC    X'BE'                 STCM
         DC    AL2(QSTCM-QINSTBE)    STCM QUASI RTN
         DC    X'BF'                 ICM
         DC    AL2(QICM-QINSTBE)     ICM  QUASI RTN
         DC    X'0E'                 MVCL
         DC    AL2(QMVCL-QINSTBE)    MVCL QUASI RTN
         DC    X'0F'                 CLCL
         DC    AL2(QCLCL-QINSTBE)    CLCL QUASI RTN
         DC    X'B6'                 STCTL
         DC    AL2(QSTCTL-QINSTBE)   STCTLQUASI RTN
         DC    X'B7'                 LCTL
         DC    AL2(QLCTL-QINSTBE)    LCTL QUASI RTN
         DC    X'F0'                 SRP
         DC    AL2(QSRP-QINSTBE)     SRP  QUASI RTN
.BYPREST ANOP                                             1/6/76
QINSTBL  EQU   *                     END OF INST TBL
QINSTBE  DS    0H                    INSTRUCTION TABLE END
         EJECT
*
* COMPARE AND SWAP / COMPARE DOUBLE AND SWAP
*
CS       SUBTAG BA                     COMPARE AND SWAP ENTRY
         ST    QR4,QTMP1
         TM    QTMP1+3,X'03'
         BNZ   QCSSPEX                  SPECIFICATION EXCEPTION
         LA    QR8,3                    LENGTH FOR CS
         B     QCS01
CDSI     SUBTAG BB
         ST    QR4,QTMP1
         TM    QTMP1+3,X'07'
         BNZ   QCSSPEX                  SPECIFICATION EXCEPTION
         TM    1(QR1),X'11'
         BNZ   QCSSPEX                  SPECIFICATION EXCEPTION
         LA    QR8,7                    LENGTH FOR CDS
QCS01    EX    QR8,QCSCLC
         BNE   QCS02                    FIRST OPERAND NOT EQ SECOND
         BAL   QR9,QAR4                 TEST STORAGE ADDR
         EX    QR8,QCSMVCEQ             THIRD OPERAND TO SECOND
         SR    QR12,QR12                SET CC=0
         BR    QR14                     RETURN
QCS02    EX    QR8,QCSMVCNE             SECOND OPERAND TO FIRST
         L     QR12,QCSCC1              SET CC=1
         BR    QR14                     RETURN
QCSSPEX  MVI   QNTCD2,QSPEX             SET SPECIFICATION EXCEPTION
         B     QPCEX0                   EXCEPTION RETURN
QCSCLC   CLC   0(0,QR2),0(QR4)
QCSMVCEQ MVC   0(0,QR4),0(QR6)
QCSMVCNE MVC   0(0,QR2),0(QR4)
QCSCC1   DS    0F
         DC    X'10000000'              CONDITION CODE 1
         AIF   ('&TYPE' EQ 'SHORT').B360SM                    1/6/76
         EJECT
STNSM    SUBTAG AC
         BAL   QR10,QSTNOSM *           STNSM/STOSM COMMON RTN
         NC    QPSWMSK,1(QR1) *         AND SYSTEM MASK
         TM    QPSWMSK,X'02' *          IS I/O MASK ONE?
         BCR   1,QR14 *                 YES, RETURN
         NI    QPSWMSK,X'01' *          SET ALL CHANNEL MASKS ZERO
         BR    QR14 *                   RETURN
STOSM    SUBTAG AD
         BAL   QR10,QSTNOSM *           STNSM/STOSM COMMON RTN
         OC    QPSWMSK,1(QR1) *         OR SYSTEM MASK
         TM    QPSWMSK,X'02' *          IS I/O MASK ONE?
         BCR   8,QR14 *                 NO, RETURN
         OI    QPSWMSK,X'FE' *          SET ALL CHANNEL MASKS ONE
         BR    QR14 *                   RETURN
QSTNOSM  DS    0H                       STNSM/STOSM COMMON RTN
         MVI   QNTCD2,QPRVEX *          PRESET PRV EXCEPTION
         TM    QAMWP,QPP *              IS IT PROB PROG?
         BO    QPCEX0 *                 YES,PRV EXC
         IC    QR8,QPSWMSK *            GET MASK
         STC   QR8,0(QR4) *             STORE MASK IN 1ST OPERAND LOC
         NI    0(QR4),X'03' *           TURN CH 1-5 MASKS OFF
         BR    QR10 *                   RETURN
         EJECT
LRA      SUBTAG B1
         MVI   QNTCD2,QPRVEX *          PRESET PRV EXC
         TM    QAMWP,QPP *              IS IT PROB PROG?
         BO    QPCEX0 *                 YES,PRV EXC
         IC    QR8,0(QR7) *             GEN ADDR EXCP IF OUTSIDE MCH
         SR    QR8,QR8 *               CLEAR R8
         IC    QR8,1(QR1) *            GET R1/X2
         SRL   QR8,4 *                 SHIFT X2 TO LOW ORDER
         SLL   QR8,2 *                 MULTIPLY BY 4
         ST    QR7,QR0SV(QR8) *        STORE D2(X2,B2)
         SR    QR12,QR12
         BR    QR14 *                  RETURN
         EJECT
****************************************************************
.COMCP12 ANOP
SRP      SUBTAG F0
         BAL   QR9,QAR4                TEST IF VALID STG ARG
* TEST VALIDITY OF MASK
         STC   QR3,QSRPLA+3
         NI    QSRPLA+3,X'0F'
         CLI   QSRPLA+3,X'0A'
         BL    QSRPMOK BRANCH IF MASK < 10
         ZAP   QTMP1+QW17(1),*      GENERATE DATA EXCEPTION
QSRPMOK  EQU   * MASK IS OK
* GENERATE SIGN AND TEST FOR VALID DATA
         LR    QR9,QR3 L1/I3 TO QR9
         SRL   QR9,4 LENGTH TO RIGHT NIBBLE
         STC   QR9,QSRPLAS+3
         EX    QR9,QSRPZAP1 GENERATE SIGN AND/OR DATA EXCEPTION
         MVC   QTMP1+QSS(1),QTMP1+QW17+16 SAVE SIGN
         NI    QTMP1+QSS,X'0F' CLEAR RIGHT NIBBLE
         NI    QTMP1+QW17+16,X'F0' CLEAR SIGN
         MVI   QTMP1+QW17,X'00' CLEAR HI ORDER BYTE OF WORK AREA
* TEST SHIFT ARGUMENT FOR EVEN/ODD, LEFT/RIGHT
         LR    QR10,QR5 SHIFT ARGUMENT TO QR10
         SRDL QR10,1 EVEN/ODD BIT POS TO QR11
         LTR   QR11,QR11 TEST
         BNM   QSRPLRT BRANCH IF EVEN SHIFT
         SR    QR9,QR9 CLEAR
         IC    QR9,QTMP1+QW17+1 HIGH ORDER BYTE TO R9
         SLL   QR9,4 LEFT NIBBLE TO RIGHT NIBBLE
         STC   QR9,QTMP1+QW17 NEW HIGH ORDER BYTE
         MVO QTMP1+QW17+1(16),QTMP1+QW17+1(16) SHIFT RIGHT ONE NIBBLE
QSRPLRT  XC    QTMP1+QW32(32),QTMP1+QW32 CLEAR QW32
         SLL   QR10,27 SHIFT ARGUMENT TO BIT POS 0-4
         LTR   QR10,QR10
         SRL   QR10,27 SHIFT ARG TO BIT POS 27-31
         BNM   QSRPLEFT BRANCH IF LEFT SHIFT
* PERFORM RIGHT SHIFT
         LA    QR8,QTMP1+QW32+31 LOW QRDER BYTE ADDRESS
         SR    QR8,QR10 SUBTRACT SHIFT ARG/2
         MVC   0(16,QR8),QTMP1+QW17 MOVE AND SHIFT INTO QW32
         IC    QR9,QTMP1+QW32+15 ROUNDING DIGIT TO QR9
         NI    QTMP1+QW32+15,X'F0' CLEAR SIGN POS
         OC    QTMP1+QW32+15(1),QTMP1+QSS INSERT SIGN
QSRPSLL  SLL   QR9,28 CLEAR LEFT  NIBBLE
         SRL   QR9,28
QSRPLA   LA    QR9,0(QR9) ADD ROUNDING FACTOR TO ROUNDING DIGIT
         CH    QR9,QSRPH10 TEST FOR ROUND UP
         BL    QSRPLFIN BRANCH IF SUM < 10 (DONT ROUND UP)
         AP    QTMP1+QW32(16),QSRPSLL+3(1) ROUND UP
QSRPLFIN EX    QR3,QSRPZAP2 ZAP RESULT TO USER FIELD
         BALR  QR12,QR14 COND CODE TO QR12 AND RETURN
* PERFORM LEFT SHIFT
QSRPLEFT LA    QR8,QTMP1+QW32+15  HIGH ORDER BYTE ADDRESS
         SR    QR8,QR10 SUBTRACT SHIFT ARG/2
         MVC   0(17,QR8),QTMP1+QW17 MOVE AND SHIFT INTO QW32
         OC    QTMP1+QW32+31(1),QTMP1+QSS INSERT SIGN
         EX    QR3,QSRPZAP3  ZAP RESULT TO USER FIELD
         BALR  QR12,0 COND CODE TO QR12
         OC    QTMP1+QW32(16),QTMP1+QW32 TEST FOR FORCED OVERFLOW
         BCR   8,QR14 RETURN IF NO OVERFLOW
QSRPLAS  LA    QR10,0(QR4) ADDR OF SIGN POS
         NI    0(QR10),X'F0' CLEAR SIGN POS
         OC    0(1,QR10),QTMP1+QSS ENSURE PROPER SIGN
         ZAP   QTMP1+QW17(1),QSRPSLL(4) FORCE OVERFLOW CONDITION
         BALR  QR12,QR14 COND CODE TO QR14 AND RETURN
QSRPZAP1 ZAP   QTMP1+QW17+1(16),0(0,QR4)
QSRPZAP2 ZAP   0(0,QR4),QTMP1+QW32(16)
QSRPZAP3 ZAP   0(0,QR4),QTMP1+QW32+16(16)
QSRPH10  DC    H'10' CONSTANT TO TEST FOR ROUND UP
QW17     EQU   0       17 BYTE WORK AREA FOR INTERMEDIATE RESULT
QSS      EQU   17      1 BYTE SAVE AREA FOR SIGN
QW32     EQU   18      32 BYTE WORK AREA TO DEVELOP RESULT
         EJECT
CLM      SUBTAG BD
         LA    QR11,QCLC
         SR    QR12,QR12             PRESET CC=0
         B     QCOMMONM
ICM      SUBTAG BF
         LA    QR11,QIC
         ST    QR14,QICMST14 *       SAVE RETURN ADDRESS
         LA    QR14,QICMSCC *        LOAD ADDR OF SET CC RTN
         B     QCOMMONM
STCM     SUBTAG BE
         LA    QR11,QSTC
         BAL   QR9,QAR4
QCOMMONM SLL   QR3,28                   SHIFT MASK TO HI POSITIONS
         LR    QR9,QR2               COPY LOC OF R1
QSTCM1   LTR   QR3,QR3               TEST MASK
         BP    QSTCM3                BIT POSITION IS ZERO
         BM    QSTCM2                BIT POSITION IS ONE
         BR    QR14                  RETURN,REMAINDER OF MASK = 0
QSTCM2   SR    QR8,QR8               FORCE CC=0
         EX    0,0(,QR11)            EXEC BYE INSERT/ST/CL
         BE    QCLMA                 SKIP IF CC=0
         BALR  QR12,QR14               SET CC&EXIT
QCLMA    LA    QR5,1(,QR5)           NEXT STG ADDR
QSTCM3   SLL   QR3,1                 NEXT BIT POSITION IN MASK
         LA    QR9,1(,QR9)           NEXT LOC IN REG
         B     QSTCM1                LOOP
QICMSCC  SR    QR5,QR4 *             CALCULATE B2D2 LENGTH
         BZ    QICMEXIT *            EXIT IF LENGTH =0. (CC=0)
         CLC   QICM7F,0(QR4) *       IS STORAGE OPERAND NEGATIVE?
         BL    QICMEXIT *            YES, EXIT. (CC=1)
         BCTR  QR5,0 *               CALCULATE LENGTH-1
         EX    QR5,QICMCLC *         SET CC. (0 IF ALL ZERO, ELSE 2)
QICMEXIT L     QR14,QICMST14 *       RESTORE RETURN ADDRESS
         BALR  QR12,QR14 *           SET CC AND RETURN
QCLC     CLC   0(1,QR9),0(QR5)       COMPARE PSEUDO REG BYTE TO STG
QIC      MVC   0(1,QR9),0(QR5)       STG TO PSEUDO REG
QSTC     MVC   0(1,QR5),0(QR9)       PSEUDO REG TO STG
QICMCLC  CLC   0(0,QR4),QICM0 *      TEST STORAGE OPERAND FOR ZERO
QICM7F   DC    X'7F' *               CONSTANT TO TEST FOR NEGATIVE
QICM0    DC    F'0' *                CONSTANT TO TEST FOR ZERO
QICMST14 DS    F *                   SAVE AREA FOR ICM RETURN
         EJECT
MVCL     SUBTAG 0E
         MVI   QNTCD2,QSPEX            PRESET SPEC EXCEPT
         TM    1(QR1),X'11'            TEST IF R1,RI EVEN
         BNZ   QPCEX0                  NO,EXIT
         L     QR4,0(QR2)              B1D1 A.
         L     QR5,0(QR6)              B2D2 A.
         LA    QR4,0(QR4)              CLEAR HI ORDER BYTE
         LA    QR5,0(QR5)              CLEAR HI ORDER BYTE
         L     QR7,4(QR2)              L1
         L     QR8,4(QR6)              L2
         LA    QR7,0(QR7)              CLEAR HI ORDER BYTE
         LA    QR8,0(QR8)              CLEAR HI ORDER BYTE
         BAL   QR9,QAR4 *            TEST STG ARG ADDR
         EJECT
***********************************************************************
*
*              TEST MVCL OPERANDS FOR DESTRUCTIVE OVERLAP
*
*              DEFINITION OF DESTRUCTIVE OVERLAP
*
*              IF SECOND OPERAND DOES NOT WRAP AROUND STORAGE,
*              MOVEMENT OCCURS IF EITHER
*
*                   1:   ADDR1 <= ADDR2
*
*              OR   2:   ADDR1 >= ADDR2 + MIN (LENGTH1, LENGTH2)
*
*              IF SECOND OPERAND DOES WRAP AROUND STORAGE,
*              MOVEMENT OCCURS ONLY IF
*
*                   1:   ADDR1 <= ADDR2
*
*              AND  2:   ADDR1 >= ADDR2 + MIN (LENGTH1, LENGTH2)
*
***********************************************************************
         SPACE
         LR    QR9,QR8        QR9 <- MIN (LENGTH1, LENGBTH2)
         CR    QR7,QR8        IS LENGTH 1 < LENGTH2
         BNL   QMVCL01             NO, USE LENGTH2
         LR    QR9,QR7             YES, USE LENGTH 1
QMVCL01  EQU   *
         LA    QR9,0(QR5,QR9) QR9 <- ADDR2 + MIN (LENGTH1,LENGTH2)
         CR    QR9,QR5        DOES OPERAND 2 WRAP AROUND STORAGE?
         BL    QMVCLW0             YES, PERFORM WRAP AROUND TESTS
         SPACE 2
***********************************************************************
*
*              TESTS FOR NON-WRAP AROUND CASE
*
***********************************************************************
         SPACE
         CR    QR4,QR5        ADDR1 <= ADDR2 ?
         BNH   QMVCL30             YES, PERFORM MOVE
         CR    QR4,QR9        ADDR1 >= ADDR2 + MIN (LENGTH1, LENGTH2) ?
         BNL   QMVCL30             YES, PERFORM MOVE
         B     QMVCL15             NO, DESTRUCTIVE OVERLAP, SUPPRESS
         SPACE 2
***********************************************************************
*
*              TESTS FOR STORAGE WRAP AROUND CASE
*
***********************************************************************
         SPACE
QMVCLW0  EQU   *
         CR    QR4,QR5        ADDR1 <= ADDR2 ?
         BH    QMVCL15             NO, DESTRUCTIVE OVERLAP
         CR    QR4,QR9        ADDR1 >= ADDR2 + MIN (LENGTH1, LENGTH2) ?
         BNL   QMVCL30             YES, PERFORM MOVE: BOTH TESTS TRUE
         B     QMVCL15             NO, DESTRUCTIVE OVERLAP
         EJECT
***********************************************************************
*
*              DESTRUCTIVE OVERLAP OF OPERANDS
*              SET CONDITION CODE = 3 AND EXIT
*
***********************************************************************
         SPACE
QMVCL15  TM    0(QR1),X'08'            FORCE CC=3
         BALR  QR12,QR0                SAVE CC
QMVCL18  ST    QR4,0(QR2)              RESET R1
         ST    QR5,0(QR6)              RESET R2
         BR    QR14                    RETURN
QMVCL30  CR    QR7,QR8                 L1=L2
         BALR  QR12,QR0                SAVE CC
         LTR   QR7,QR7                 L1=0
         BZ    QMVCL18                 YES-EXIT
         LTR   QR8,QR8                 L2=0
         BZ    QMVCL52                 YES-SET SHORT LOOP
QMVCL50  XC    QFWQR8,QFWQR8           CLEAR QFWQR8 TO ZERO
         CR    QR8,QR7                 SENDING LGTH > RECVNG LGTH?
         BNH   QMVCL51                 NO
         SR    QR8,QR7                 YES, BY HOW MUCH ?
         ST    QR8,QFWQR8              STORE BY HOW MUCH (RESIDUAL)
         LR    QR8,QR7                 TRUNCATE SENDING TO RECVING
QMVCL51  C     QR8,QFW256              GREATER THAN 256 ?
         BH    QMVCL70                 YES
         BCTR  QR8,QR0                 NO, RECUDE FOR EXECUTE
         EX    QR8,QMVCL100            MOVE REMAINING
         LA    QR8,1(QR8)              BUMP BACK
         AR    QR5,QR8                 UPDATE B2D2
         AR    QR4,QR8                 UPDATE B1D1
         SR    QR7,QR8                 REDUCE L1
         L     QR8,QFWQR8              LOAD UP RESIDUAL
QMVCL52  LTR   QR7,QR7                 TEST IF ZERO
         BZ    QMVCL65                 IF YES, FINISHED
         LA    QR10,4(QR6)             POINT TO PADDING CHARACTER
QMVCL54  C     QR7,QFW256              GREATER THAN 256?
         BH    QMVCL75                 YES
         BCTR  QR7,QR0                 REDUCE FOR ONE CHAR MOVE
         MVC   0(1,QR4),0(QR10)        MOVE IN FIRST CHAR
         LTR   QR7,QR7                 ZERO AFTER FIRST ?
         BZ    QMVCL56                 YES
         BCTR  QR7,QR0                 REDUCE FOR EXECUTE
         EX    QR7,QMVCL105            MOVE MORE
         LA    QR7,1(QR7)              BUMP BACK UP
QMVCL56  LA    QR7,1(QR7)              ONCE AGAIN FOR FIRST MOVE
         AR    QR4,QR7                 UPDATE B1D1
         SR    QR7,QR7                 ZERO QR7
QMVCL65  IC    QR10,4(QR6)             SAVE PADDING CHARACTER
         ST    QR8,4(QR6)              SET L2 COUNT
         STC   QR10,4(QR6)             RESTORE PADDING CHAR
         IC    QR10,4(QR2)             BYTE 0 OF R1+1
         ST    QR7,4(QR2)              SAVE L1 COUNT
         STC   QR10,4(QR2)             RESTORE BYTE 0
         B     QMVCL18                 EXIT
QMVCL70  MVC   0(256,QR4),0(QR5)       MOVE 256 CHARACTERS
         LA    QR4,256(QR4)            UPDATE B1D1
         LA    QR5,256(QR5)            UPDATE B2D2
         S     QR8,QFW256              REDUCE L2
         S     QR7,QFW256              REDUCE L1
         B     QMVCL51                 GO BACK
QMVCL75  MVC   0(1,QR4),0(QR10)        MOVE 256 PADDING CHARACTERS
         MVC   1(255,QR4),0(QR4)
         LA    QR4,256(QR4)            UPDATE B1D1
         S     QR7,QFW256              REDUCE L1
         B     QMVCL54
QFW256   DC    F'256'                  CONSTANT
QFWQR8   DC    F'0'                    SAVE RESIDUAL
QMVCL100 MVC   0(0,QR4),0(QR5)         MOVE DATA
QMVCL105 MVC   1(0,QR4),0(QR4)         MOVE PADDING
         EJECT
CLCL     SUBTAG 0F
         MVI   QNTCD2,QSPEX          PRESET SPEC EX
         TM    1(QR1),X'11'          TEST IF EVEN REGS
         BNZ   QPCEX0                NO,EXIT-SPEC EX
         L     QR7,0(QR2)              B1D1
         L     QR8,4(QR2)              L1
         L     QR9,0(QR6)              B2D2
         L     QR10,4(QR6)             L2
         LA    QR8,0(QR8)              CLEAR HIGH ORDER BYTES
         LA    QR10,0(QR10)            .COUNT REGISTERS
QCLCL30  LR    QR11,QR8                R11=L1
         AR    QR11,QR10               R11=L1+L2
         BZ    QCLCL60                 L1=L2=0; END
         LTR   QR8,QR8                 TEST IF L1=0
         BZ    QCLCL80                 L1=0; LOOP PAD:S2
         LTR   QR10,QR10               TEST IF L2=0
         BZ    QCLCL70                 L2=0; LOOP S1:PAD
         B     QCLCL40                 L1#0;L2#0; LOOP S1:S2
* LOOP PAD:S2  (L1=0,L2#0)
QCLCL80  CLC   4(1,QR6),0(QR9)         COMPARE PAD:S2
         BNE   QCLCL60                 PAD NE S2- END
QCLCL85  LA    QR9,1(,QR9)             S2=S2+1
         BCT   QR10,QCLCL80            L2=L2-1
         B     QCLCL60                 L2=0; END
* LOOP S1:PAD  (L1#0,L2=0)
QCLCL70  CLC   0(1,QR7),4(QR6)         COMPARE S1:PAD
         BNE   QCLCL60                 S1 NE PAD; END
         LA    QR7,1(,QR7)             S1=S1+1
         BCT   QR8,QCLCL70             L1=L1-1
         B     QCLCL60                 L1=0; END
* LOOP S1:S2   (L1#0,L2#0)
QCLCL40  CLC   0(1,QR7),0(QR9)         COMPARE S1:S2
         BNE   QCLCL60                 S1 NE S2; END
         LA    QR7,1(,QR7)             S1=S1+1
         BCT   QR8,QCLCL45             L1=L1-1
         B     QCLCL85                 L1=0; LOOP PAD:S2
QCLCL45  LA    QR9,1(,QR9)             S2=S2+1
         BCT   QR10,QCLCL40            L2=L2-1
         B     QCLCL70                 L2=0; LOOP S1:PAD
QCLCL60  BALR  QR12,QR0              SAVE CONDITION CODE
         IC    QR3,4(QR6)              PICK UP PADDING CHAR
         ST    QR10,4(QR6)             SAVE L2
         STC   QR3,4(QR6)              RESTORE PADDING CHAR
         IC    QR3,4(QR2)              PICK UP BYTE 0 OF R1+1
         ST    QR8,4(QR2)              SAVE L1
         STC   QR3,4(QR2)              RESTORE BYTE 0
         ST    QR7,0(QR2)              STORE UPDATED S1
         ST    QR9,0(QR6)              STORE UPDATED S2
         BR    QR14                    RETURN
         EJECT
.B360SM  ANOP
* SUBROUTINE FOR HANDLING SPEC EXCEPTIONS
* QR1 POINTS TO ORIGINAL INSTRUCTION
* QR2 POINTS TO SAVED R1
* QR4 POINTS TO OPERAND ADDRESS
* TEST IF PROPER FOR SPEC EXCP
SPCEX    SUBTAG 00
         AIF  ('&TYPE' NE 'SHORT').B360SMY
         B     QPCEX0                FOR 155/165 ALL SPEC BAD
         AGO   .B360SMX
.B360SMY ANOP
         TM    0(QR1),B'11000000'    TEST OP FORMAT
         BC    8+1,QPCEX0            FLUSH RR/SS TYPES
* PROCESS RX & LM/STM ONLY
         TM    0(QR1),B'01000000'    TEST IF RX TYPE
         BO    QPCSRX                YES-GO PROCESS RX
         LA    QR2,QR0SV             BURNS' INTERFACE
         CLI   0(QR1),X'90'          LM
         BE    QSTM                  YES
         CLI   0(QR1),X'98'          STM
         BE    QLM                   YES
         B     QPCEX0                FLUSH REMAINDER
***********************************************************************
QPCSRX   DS    0H                    RX INTERFACE
         LR    QR10,QR7                TEST STG ARG ADR
         CLI   0(QR1),X'4E' *           IS IT CVD
         BE    *+12 *                   YES, TEST STG
         TM    0(QR1),X'8F' *           IS IT NOT STG MOD INSTRUCTION?
         BNZ   *+8 *                    NOT STG MOD, DONT TEST STG
         BAL   QR9,QA                  TEST
         MVC   QTMP5(8),0(QR7)       ALIGN INST ARG TO DBLWD
         MVC   QRXDMI(2),0(QR1)      MOVE OP & R1/X2 TO PROTO
         NI    QRXDMI+1,X'F0'        CLEAR X2
         TM    0(QR1),B'01100000'    TEST IF FLT PNT
         BO    QPCSRX1               YES USE ORIG R1
* TRANSLATE USER R1 DESIGNATION TO QR10 OR QR11
         NI    QRXDMI+1,X'10'        SAVE R1 ODD BIT
         OI    QRXDMI+1,X'A0'        OR QR10
         MVZ   QILM+1(1),QRXDMI+1    SET UP REG LOAD
         MVZ   QRSTM+1(1),QRXDMI+1   SET UP RESTORE REGS
QPCSRX1  SPM   QR12                  SET USER CC
*        PROTO INSTRUCTION
QILM     LM    QR10,QR11,0(QR2)      SET UP PROTO R1&R1+1
QRXDMI   L     QR10,QTMP5            PROTO OPERATION
QRSTM    STM   QR10,QR11,0(QR2)      SAVE PROTO R1 & R1+1
         BALR  QR12,0                SAVE CC
         CLC   0(8,QR7),QTMP5          TEST IF STG MOD GPS 09/20/73
         BE    *+10                    NO,SKIP RESTORE
         MVC   0(8,QR7),QTMP5        RESTORE STG ARG
         BR    QR14                  EXIT
         EJECT
LCTL     SUBTAG B7
         LA    QR2,QCONREG
         EX    0,QLM                 SET TO LOAD
         B     QLSTCOM               GO TO COMMON
STCTL    SUBTAG B6
         LA    QR2,QCONREG
         EX    0,QSTM                SET TO STORE
QLSTCOM  DS    0H                    CONNECY
         MVI   QNTCD2,QPRVEX         PRESET PRV EXC
         TM    QAMWP,QPP             TEST IF PROB PRG
         BO    QPCEX0                YES,PRV EXC
         B     QLSTMCTL              CONTINUE
QLM      MVC   QTMP4(6),QPROTOLM     SET UP LOAD PROTO
         B     QLSTMCTL              DO IT
QSTM     MVC   QTMP4(6),QPROTOSM     SET UP STORE PROTO
QLSTMCTL DS    0H                    CONNECT
         CLI   0(QR1),X'90' *           IS IT STM?
         BE    *+12 *                   YES, TEST STG
         CLI   0(QR1),X'B6' *           IS IT STCTL
         BNE   *+8 *                    NO, DONT TEST STG
         BAL   QR9,QAR4                TEST IF VALID STG ARG
         SR    QR8,QR8
         SR    QR9,QR9               CLEAR REG 9
         IC    QR8,1(QR1)              PICK UP R1R3 FROM INST
         SRDL  QR8,4                   R1 IN QR8
         SRL   QR9,26                  R3 IN QR9 IN WORDS
         SLL   QR8,2                   R1 IN WORDS- STARTING INDEX
*                                      .CONTROL REGS
         LA    QR4,64                  .AND LENGTH
         SR    QR10,QR10               B2D2 INDEX
QLCTL20  EQU   *                     LOOP
         LA    QR6,0(QR8,QR2)        COMPUTE SOURCE
         LA    QR7,0(QR10,QR5)       COMPUTE DESTINATION
         EX    0,QTMP4               MOVE WORD
         CR    QR8,QR9                 DONE?
         BE    0(QR14)                 YES-RETURN
         LA    QR8,4(QR8)              UP CONTROL REG INDEX
         LA    QR10,4(QR10)          UP STG REG
         CR    QR8,QR4                 OVERLAP?
         BL    QLCTL20                 NO-MOVE NEXT REG.
         SR    QR8,QR8                 YES-CLEAR INDEX
         B     QLCTL20                 GET NEXT REG.
QPROTOLM MVC   0(4,QR6),0(QR7)       LOAD PROTO INST
QPROTOSM MVC   0(4,QR7),0(QR6)       STORE PROTO INST
         EJECT
CSUB     SUBTAG B2
         CLI   1(QR1),X'05'          TEST IF STCK
         BE    QSTCK                 OK,STORE CLOCK
         TM    QPOPSWSV+1,X'01'      TEST IF PROBLEM STATE
         BZ    QSPVRN                NO,OK
         MVI   QPOPSWSV+3,QPRVEX     SET PRIVIGED CHK
         B     QPCEX0                EXIT 0 TO DOS PC
QSPVRN   DS    0H                    NOT SPVR OP
         CLI   1(QR1),X'0D' *           IS IT PTLB?
         BE    QPTLB *                  PTLB QUASI RTN
         CLI   1(QR1),X'13' *           IS IT RRB?
         BE    QRRB *                   QRRB QUASI RTN
         CLI   1(QR1),X'04' *           IS SUB OP IN LIST
         BH    QPCEX0 *                 NO, ILLEGAL OP
         SLL   QR3,2                 *4
         B     BTBVEC(QR3)           B VECTOR
BTBVEC   B     QPCEX0                I2=0 ILLEGAL SUB OP
         B     QPCEX0                I2=1 ILLEGAL SUB OP
         B     QSTIDP                I2=2 ST CPU ID
         B     QSTIDC                I2=3 ST CHN ID
         B     QSCK                  I2=4 SET CLOCK
***********************************************************************
PTLB     SUBTAG 0D
         BR    QR14 *                   RETURN
***********************************************************************
RRB      SUBTAG 13
         L     QR8,0(QR4) *             GEN ADDR EXCP IF OUTSIDE MCH
         SR    QR12,QR12 *              SET CC=0
         BR    QR14 *                   RETURN
***********************************************************************
QSTIDC   DS    0H                    STORE CHN ID
         SR    QR11,QR11             SET CC=0
         BALR  QR12,0                RECORD
         ST    QR4,QTMP1             SAVE B2D2
         CLI   QTMP1+2,X'00'         TEST IF CHNL 0
         MVC   168(4),QSELID         MOVE SELECTOR ID
         BCR   7,QR14                EXIT IF NOT MPXR
         MVC   168(4),QMPXID         MOVE MULTIPLEXOR ID
         BR    QR14                  EXIT
***********************************************************************
QSTIDP   DS    0H                    STORE CPU ID
         ST    QR4,QTMP1             SAVE B1D1
         TM    QTMP1,X'07'           TEST IF DBL WD BND
         BZ    QSTIDPA               YES,SKIP
         MVI   QPOPSWSV+3,QSPEX      SET SPECIFICATION EXCEPTION
         B     QPCEX0                ERROR EXIT
QSTIDPA  MVC   0(8,QR4),VCPUID          MOVE CPU ID
         BR    QR14                  EXIT
***********************************************************************
QSCK     DS    0H                    SET CLOCK
         TM    *,X'FF'                  SET CC=1 (CLOCK SECURE)
         BALR  QR12,QR14             SET CC AND EXIT
***********************************************************************
QSTCK    DS    0H                    STORE CLOCK
         BAL   QR9,QAR4                TEST IF STG ARG ADR OK
         OC    0(8,QR4),0(QR4)          PRETEST STG LOC FOR PROT EXCPT
         ST    QR14,QVQR14SV            SAVE RETURN REG
         SR    QR10,QR10                SET KEY 0
         BAL   QR14,QRSTRPSW            SET PSW KEY TO 0
         BAL   QR14,QSTEXTMD            SET STG KEY TO 0
         STM   QR0,QR15,QVSTCKSV        SAVE REGS
         SR    QR1,QR1                  INDICATE TIMER UNITS
         L     QR3,QVCVTADR             LOAD CVT ADDRESS
         L     QR15,QVIGC011            LOAD ADDRESS OF IGC011
         BALR  QR14,QR15                CALL IGC011
QVTMPORG DS    0H                       TEMPORARY ORIGIN
         STM   QR0,QR1,QVTU-QVTMPORG(QR14) STORE TIME AND DATE
         LM    QR0,QR15,QVSTCKSV-QVTMPORG(QR14) RESTORE REGS
         CLC   QVDATE+2(2),QV000F       IS DAY > 0?
         BH    QVSTCKOK                 YES, COMPUTE CLOCK VALUE
         TM    *,X'FF'                  SET CC=1 (NOT-SET STATE)
         B     QVXIT                    EXIT
QVSTCKOK DS    0H                       COMPUTE CLOCK VALUE
         MVO   QVPACKED,QVDATE+1(1)     GET YR (PACKED)
         CVB   QVRWORK,QVPACKED         GET YR (BINARY)
         STH   QVRWORK,QVHWYEAR         STORE YR
         MVC   QVPACKED+6(2),QVDATE+2    GET DATE (PACKED)
         CVB   QVRWORK,QVPACKED         GET DAY (BINARY)
         BCTR  QVRWORK,0                SUBTRACT 1
         LH    QR9,QVHWYEAR             GET YR
         LTR   QR9,QR9                  IS YR ZERO?
         BZ    QVMLTPLY                 YES, USE DATE ONLY
         SR    QR8,QR8                  CLEAR EVEN REG
         D     QR8,QVFOUR               DIVIDE BY FOUR
         MH    QR9,QVHW4YR              MULTIPLY QUOTIENT BY 1461
         MH    QR8,QVHW1YR              MULTIPLY REMAINDER BY 365
         LTR   QR8,QR8                  IS REMAINDER ZERO?
         BNZ   QVADDTOT                 NO, ALL GROUPS ARE 1461 DAYS
         BCTR  QR9,0                    SUBTRACT 1 FOR 1460 DAY GROUP
QVADDTOT AR    QVRWORK,QR9              ADD 1461 DAY GROUPS TO TOTAL
         AR    QVRWORK,QR8              ADD 365 DAY GROUPS TO TOTAL
QVMLTPLY LR    QR9,QVRWORK              TOTAL DAYS TO QR9
         M     QR8,QVDAYSEC             MULTIPLY BY SECS PER DAY
         SL    QR9,MAXNEG               SUBTRACT CONSTANT (FOR NEG)
         M     QR8,QVMEG                COMPUTE MICROSECONDS
         A     QR8,QVHMEG               ADD CONSTANT (CORRECT FOR SL)
         STM   QR8,QR9,QVRESULT         STORE TOTAL MICROSECONDS
         SR    QR8,QR8                  CLEAR EVEN REG
         L     QR9,QVTU                 GET TIMER UNITS
         D     QR8,QV384                DIVIDE BY 384
         LR    QR11,QR8                 SAVE REMAINDER
         M     QR8,QV10000              MULTIPLY QUOTIENT BY 10000
         M     QR10,QV10000             MULTIPLY REMAINDER BY 10000
         D     QR10,QV384               DIVIDE REMAINDER BY 384
         ALR   QR9,QR11                 ADD REMAINDER/QUOTIENT TOTALS
         BC    12,*+8                   BRANCH IF NO CARRY
         A     QR8,QV1                  ADD 1 FOR CARRY
         A     QR8,QVRESULT             ADD TOTAL FROM DATE CALCULATION
         AL    QR9,QVRESULT+4           ADD TOTAL FROM DATE CALCULATION
         BC    12,*+8                   BRANCH IF NO CARRY
         A     QR8,QV1                  ADD 1 FOR CARRY
         SLDL  QR8,QVTWELVE             SHIFT TO TOD CLOCK POS
         STM   QR8,QR9,QVRESULT         STORE CLOCK VALUE
         CLC   QVRESULT,QVLASTCL        IS CLOCK VALUE SAME AS LAST
         BNE   QVUNIQUE                 NO, GO TO NEW VALUE SETUP
         L     QVRWORK,QVLASTAD         LOAD LAST ADJUSTMENT VALUE
         AH    QVRWORK,QV4096           ADD ADJUSTMENT CONSTANT
         ST    QVRWORK,QVLASTAD         STORE NEW ADJUSTMENT VALUE
         ALR   QR9,QVRWORK              ADD TO TOD CLOCK VALUE
         BC    12,*+8                   BRANCH IF NO CARRY
         AL    QR8,QV1                  ADD 1 FOR CARRY
         STM   QR8,QR9,QVRESULT         STORE ADJUSTED VALUE
         B     QVENDUP                  RETURN VALUE TO USER
QVUNIQUE MVC   QVLASTCL,QVRESULT        SAVE THIS CLOCK VALUE
         XC    QVLASTAD,QVLASTAD        ZERO ADJUSTMENT VALUE
QVENDUP  MVC   0(8,QR4),QVRESULT        MOVE TO USER AREA
         SR    QR12,QR12                SET CC=0 (SET STATE)
QVXIT    L     QR14,QVQR14SV            LOAD RETURN REG
         BALR  QR12,QR14                LOAD CC AND EXIT
QVSTCKSV DS    16F                      REGISTER SAVE AREA
QVIGC011 DC    V(IGC011)                ADDRESS OG IGC011
QVCVTADR EQU   X'10'                    DISPLACEMENT OF CVT POINTER
QVPACKED DS    0D
         DC    X'000000000000000F'      WORK AREA FOR CVB
QVRESULT DS    D                        AREA FOR PARTIAL 9ES4
QVLASTCL DC    D'0'                     LAST TOD CLOCK VALUE
QVQR14SV DS    F                        QR14 SAVE AREA
QVTU     DS    F                        AREA TO HOLD TIMER UNITS
QVDATE   DS    F                        AREA TO HOLD DATE
QVFOUR   DC    F'4'                     CONSTANT
QVDAYSEC DC    F'86400'                 SECONDS IN A DAY
MAXNEG   DC    X'80000000'              CORRECTION FACTOR
QVMEG    DC    F'1000000'               MICROSECONDS IN A SECOND
QVHMEG   DC    F'500000'                CORRECTION FACTOR
QV384    DC    F'384'                   CONSTANT TO CONVERT TIMER UNITS
QV10000  DC    F'10000'                 CONSTANT TO CONVERT TIMER UNITS
QV1      DC    F'1'                     CONSTANT TO ADD FOR CARRY
QVLASTAD DS    F                        LAST ADJUSTMENT VALUE
QVHWYEAR DS    H                        AREA TO HOLD YEAR
QVHW4YR  DC    H'1461'                  DAYS IN 4 YEARS
QVHW1YR  DC    H'365'                   DAYS IN YEAR
QV4096   DC    H'4096'                  ADJUSTMENT CONSTANT
QV000F   DC    X'000F'                  VALUE TO TEST FOR VALID DAY
QVTWELVE EQU   12                       CONSTANT FOR TOD CLOCK SHIFT
QVRWORK  EQU   7
.B360SMX ANOP                                               2/5/76
***********************************************************************
QSTEXTMD DS    0H                    SET RESET EXTERNAL ENVIRON
         LA    QR11,ITLSIS&GCP            START OF INST SIM          IT
         N     QR11,QFFF800          SET UP FOR SSK
         SSK   QR10,QR11             SET STG KEY
         LA    QR11,2048(QR11) *        SET UP FOR NEXT 2K
         SSK   QR10,QR11 *              SET STG KEY
         LA    QR11,SISEND *            END OF INST EMU STG
         N     QR11,QFFF800 *           SET UP SSK
         SSK   QR10,QR11             SET STG KEY
QRSTRPSW ST    QR14,QPMRKA           SAVE RETURN IN NEXT PSW
         STC   QR10,QPMRK+1          SAVE KEY IN NEXT PSW
         OI    QPMRK+1,X'04'           SET MACH CHK ENABLE
         LPSW  QPMRK                 LOAD NEXT PSW (RETURN)
****************************************************************
QR1R2    DS    0H                      POINT QRI/QR6 TO SAVED R1/R2
         LR    QR11,QR3              COPY R1/X
         SRL   QR11,4                R1 ONLY
         SLL   QR11,2                *4
         LA    QR2,QR0SV(QR11)       POINT TO SAVED R1
         LR    QR11,QR3              COPY R1/X
         N     QR11,QF               R2,X2 ONLY
         SLL   QR11,2                *4
         LA    QR6,QR0SV(QR11)       POINT TO SAVED R2/X2
         BR    QR14                    EXIT
****************************************************************
QB1D1    DS    0H                    COMPUTE SUM (B1 NE 0)+D1
         LR    QR5,QR11                COPY B1D1
         N     QR11,QF000              ISOLATE B1
         BCR   8,QR14                  B1=0,EXIT
         N     QR5,QFFF                ISOLATE D1
         SRL   QR11,10                 SHIFT B1*4
         AL    QR5,QR0SV(QR11)         ADD D1 TO REG(B1)
         LA    QR5,0(,QR5)             CLEAR HI BYTE
         BR    QR14                    EXIT
*******************************************************************
QAR4     LR    QR10,QR4                SET UP STG ARG TEST R4
QA       DS    0H                      TEST FOR SELF DESTRUCTION
         TM    QAMWP,X'F0' *         PSW PROTECT KEY ZERO?
         BCR   8,QR9 *               YES,RETURN
         N     QR10,QFFF800 *        GET ADDR OF BEGINNING OF BLOCK
         LA    QR0,SISEND *             END OF PROT KEY ALTERED STG
         CR    QR10,QR0 *               IS IT KILL ZONE
         BCR   2,QR9                 OK,RETURN
         MVI   QNTCD2,QPRTEX         SET PROT EXC
         B     QPCEX0                  EXIT TO DOS PC RTN
***********************************************************************
SISPC    DS    0H *                     PGM CHK DURINT SIS
         LH    QR11,QPRGOLD+2 *         GET CURRENT EXCEPTION
         STH   QR11,QPOPSWSV+2 *        SET SECOND STAT TO 1ST INT
         L     QR1,IHLCON1 *            GET POINTER TO PFLIH REGS
         XC    0(64,QR1),QPCSV *        RESTORE ORIGINAL REGS/
         XC    QPCSV(64),0(QR1) *       AND SAVE 2ND PC RGS FOR DEBUG
         XC    0(64,QR1),QPCSV *
         B     QPCEX0A                  BRANCH AROUND STM QR0,QR15
QPCEX0   DS    0H *                     PGM DETERMINED PGM CHK
         AIF   ('&CTRLPGM' EQ 'MFT').MFT00                          DSX
         STM   QR0,QR15,QPCSV *         SAVE REGS FOR DEBUG
         AGO   .NOTMFT0                                             DSX
.MFT00   ANOP                                                       DSX
         STM   RA,R9,QPCSV *            SAVE REGS FOR DEBUG         DSX
.NOTMFT0 ANOP                                                       DSX
QPCEX0A  DS    0H                       CONNECT
         SR    QR10,QR10 *              SET KEY 0
         BAL   QR14,QRSTRPSW            SET PSW KEY TO 0
         BAL   QR14,QSTEXTMD            SET STG KEY TO /
         NI    QSW1,X'FF'-REENTRY
         USING IPLPSW,0        ITEL FLIH STORAGE ADDRESSABILITY    UNCC
         NI    PCNPSWCC,X'CF'  RESET REENTRY SWITCH FOR ITEL FLIH  UNCC
         MVC   QPRGOLD(8),QPGOPSW
         MVC   LASTPRGO(8),QPRGOLD
         AIF   ('&CTRLPGM' EQ 'MFT').MFT01                          DSX
         LM    QR0,QR14,QPCSV
         AGO   .NOTMFT1                                             DSX
.MFT01   ANOP                                                       DSX
         LM    QR10,QR9,QPCSV                                       DSX
.NOTMFT1 ANOP                                                       DSX
         L     QR15,VENTRY *            GET OS PFLIH EP
         BR    QR15 *                   TRANSFER CTL TO OS PFLIH
QPCEX1   DS    0H *                     SIMULATED EXIT
         MVI   QNTCD2,X'00' *           CLEAR EXCEPTION
         N     QR12,Q3000000 *          CLEAR NON CC BITS IN 12
         NI    QPRGMSK,X'CF' *          CLEAR CC BITS IN PSW
         AL    QR12,QPRGADR *           ADD RT HALF PSW TO NEW CC
         ST    QR12,QPRGADR *           RESTORE PSW WITH NEW CC
         SR    QR10,QR10 *              SET KEY 0
         BAL   QR14,QRSTRPSW *          SET PSW KEY TO 0
         BAL   QR14,QSTEXTMD *          SET STG KEY TO 0
         NI    QSW1,X'FF'-REENTRY
         MVC   QPRGOLD(8),QPGOPSW
         LM    QR0,QR15,QPCSV *         RESTORE REGS
         NI    PCNPSWCC,X'CF'  SET REENTRY SWITCH FOR ITEL FLIH    UNCN
         LPSW  QPRGOLD *                RETURN TO NEXT INSTR
         DROP  QR15
         DS    0D
VCPUID   DC    X'00060379006500C0'
QMPXID   DC    X'10000060'           MOCK MPX ID
QSELID   DC    X'00000060'           MOCK SELCTR ID
QFFF800  DC    X'00FFF800'           ISK MASK
Q4N02    DC    X'40000002'           INSTRUCTION MINIM
Q3000000 DC    X'30000000'           COND CODE MASK
QF000    DC    X'0000F000'             BASE REG MASK
QFFF     DC    X'00000FFF'           DISPLACEMENT ISOLATION MASK
QF0      DC    X'000000F0'           HI ORDER HEX DIGIT MASK
QF       DC    X'0000000F'           LOW ORDER HEX DIGIT MASK
QPCMSK   DC    X'00'                 PROG CHK MOD STAT MSK
QPGOPSW  DC    D'0'                  HOLD PRG OLD OVER I/O
QPOPSWSV EQU   QPGOPSW               POPSWSV=PGOPSW
         ORG   *-8
QPSWMSK  DS    X                     SYSTEM MASK
QAMWP    DS    X                     KEY&AMWP
QNTCD1   DS    X                     INTERRUPT CODE 1
QNTCD2   DS    X                     INTERRUPT CODE 2
QPRGMSK  DS    X                     ILC/CC/PRG MASK
         ORG   *-1
QPRGADR  DS    F                     INTRPTD PRG ADDR
QPMRK    DS    0D                      PSW INTERNAL
         DC    X'00040000' *            PSW USED TO SWITCH STATES
QPMRKA   DC    A(0)                  PSW ADDR
QPCSV    DS    0H                      FLASH RE-ENTRANT FIX
         AIF   ('&CTRLPGM' EQ 'MFT').MFT03                          DSX
.MFT02   ANOP                                                       DSX
QR0SV    DS    F                     SAVED R0
QR1SV    DS    F                     SAVED R1
QR2SV    DS    F                     SAVED R2
QR3SV    DS    F                     SAVED R3
QR4SV    DS    F                     SAVED R4
QR5SV    DS    F                     SAVED R5
QR6SV    DS    F                     SAVED R6
QR7SV    DS    F                     SAVED R7
QR8SV    DS    F                     SAVED R8
QR9SV    DS    F                     SAVED R9
         AIF   ('&CTRLPGM' EQ 'MFT').MFT04                          DSX
.MFT03   ANOP                                                       DSX
QR10SV   DS    F                     SAVED R10
QR11SV   DS    F                     SAVED R11
QR12SV   DS    F                     SAVED R12
QR13SV   DS    F                     SAVED R13
QR14SV   DS    F                     SAVED R14
QR15SV   DS    F                     SAVED R15
         AIF   ('&CTRLPGM' EQ 'MFT').MFT02                          DSX
.MFT04   ANOP                                                       DSX
         DS    F                     QTMP0-4
QTMP0    DS    F                     QTMP0
QTMP1    DS    F                     TEMP SCRATCH
QTMP2    DS    F                     TEMP SCRATCH
QTMP3    DS    F                     TEMP SCRATCH
QTMP4    DS    F                     TEMP SCRATCH
QTMP5    DS    F                     TEMP SCRATCH
QTMP6    DS    F                     TEMP SCRATCH
QTMP7    DS    F                     TEMP SCRATCH
QTMP8    DS    F                     TEMP SCRATCH
QTMP9    DS    F                     TESMP SCRATCH
QTMP10   DS    F                     TESMP SCRATCH
QTMP11   DS    F                     TESMP SCRATCH
QTMP12   DS    F                     TESMP SCRATCH
QTMP13   DS    F                     TESMP SCRATCH
QTMP14   DS    F                     TESMP SCRATCH
QCONREG  DC    16F'0'                PSEUDO CONTROL REGS
QSW1     DC    X'00'
LASTPRGO DC    D'0'
         AIF   (&GTR EQ 0).NOTRTBL
TRACETBL DC    &GTR.D'0'
.NOTRTBL ANOP
         COUNTS
SISEND   EQU   * *                      END OF PROT KEY ALTERED STG
         AIF   ('&CTRLPGM' EQ 'MFT').MFT05                          DSX
IHLCON1  DC    V(IEAPKSAV) *            PI SAVE AREA IN LOW CORE
         AGO   .NOTMFT2                                             DSX
.MFT05   ANOP                                                       DSX
IHLCON1  DC    V(PISAV) *               PI SAVE AREA IN LOW CORE    DSX
.NOTMFT2 ANOP                                                       DSX
VENTRY   DC    V(ENTRY2) *            OS PFLIH ENTRY
REENTRY  EQU   X'80'
QPRGOLD  EQU   X'28'                 PRG OLD PSW
QMCHOLD  EQU   X'30'                 MACHINE OLD PSW
QIOOLD   EQU   X'38'                 I/O OLD PSW
QEXTNEW  EQU   X'58'                 EXTERNAL NEW PSW
QSVCNEW  EQU   X'60'                 SVC NEW
QPRGNEW  EQU   X'68'                 PRG NEW
QMCHNEW  EQU   X'70'                 MCH NEW
QIONEW   EQU   X'78'                 I/O NEW
QCSW     EQU   X'40'                 CSW LOC
QCAW     EQU   X'48'                 CHNL ADDR WORD
QOPEX    EQU   X'01'                 OPERATION EXCEPTION
QPRVEX   EQU   X'02'                 PRIVILIGED  EXCEPTION
QEXEX    EQU   X'03'                 EXECUTE EXCEPTION
QPRTEX   EQU   X'04'                 PROTECTION EXCEPTION
QADREX   EQU   X'05'                   ADDRESS EXCEPTION
QSPEX    EQU   X'06'                 SPECIFICATION ERROR
QTMESET  EQU   X'20'                 SET CLCK EXECUTED
QPP      EQU   X'01'                 PROBLEM STATE
QR0      EQU   0                     R0 NOT USED
QR1      EQU   1                     R1 POINTS TO EXCEPTED OP
QR2      EQU   2                     R2 POINTS TO SAVED R1
QR3      EQU   3                     R3 CONTAINS IMMEDIATE
QR4      EQU   4                     R4 CONTAINS SUM(B1)+D1
QR5      EQU   5                     R5 CONTAINS SUM(B2)+D2
QR6      EQU   6                     R6 POINTS TO SAVED R2
QR7      EQU   7                     SUM (X2)+(B2)+D2
QR8      EQU   8                     R8  UTILITY
QR9      EQU   9                     R9  UTILITY
QR10     EQU   10                    R10 UTILITY
QR11     EQU   11                    R11 UTILITY
QR12     EQU   12                    R12 CONTAIN USER COND CODE
QR13     EQU   13                    R13 POINTS TO SAVE TABLE
QR14     EQU   14                    INTERNAL LINKAGE
QR15     EQU   15                    BASE REG
         AIF   ('&TYPE' EQ 'RELOC').MFT09
.NORELOC ANOP                                               1/6/76
         AIF   ('&CTRLPGM' EQ 'MFT').MFT06                          DSX
IEAQFX00 CSECT
         AGO   .NOTMFT3                                             DSX
.MFT06   ANOP                                                       DSX
IEAAIH00 CSECT
.NOTMFT3 ANOP                                                       DSX
 TITLE 'NON-RELOCATABLE PORTION OF ITEL 370 INSTRUCTION SIMULATOR'
****************************************************************     TM
*                                                              *     TM
*        PROGRAM CHECK RECOVERY ROUTINE                        *     TM
*                                                              *     TM
* COPYRIGHT (1975) BY THE ITEL CORPORATION                     *     TM
*  1 EMBARCADERO CENTER                                        *     TM
*   SAN FRANCISCO, CALIFORNIA                                  *     TM
*                                                              *     TM
* FUNCTION                                                     *     TM
*   THE FUNCTION OF THE PROGRAM CHECK RECOVERY ROUTINE IS TO   *     TM
*   RESOLVE PROGRAM CHECKS OCCURRING ON S/360 DUE TO           *     TM
*   THE USE OF 370 INSTRUCTIONS OR FACILITIES NOT PRESENT      *     TM
*   ON S/360                                                   *     TM
*                                                              *     TM
*   THE RECOVERY PROCEDURES ARE SPLIT INTO TWO PARTS           *     TM
*     1. ITLPCSIM - SERVICES THE MOST COMMONLY OCCURRING       *     TM
*                RECOVERABLE PROGRAM CHECKS                    *     TM
*                  ICM FOR MASK VALUES 1,3,7,8,C,F             *     TM
*                  STCM     SAME                               *     TM
*                  CLM      SAME                               *     TM
*                  RX INSTRUCTION OPERAND MIS-ALIGNMENT        *     TM
*     2. ITLSISO - SERVICES ALL OTHER RECOVERABLE              *     TM
*                   PROGRAM CHECKS                             *     TM
*                                                              *     TM
*                                                              *     TM
*   UNRECOVERABLE PROGRAM CHECKS ARE PASSED
*      TO ITLSISO FOR FURTHER PROCESSING.
*
* ENTRY POINTS                                                 *     TM
*   ITLPCSIM - THE PROGRAM NEW PSW POINTS TO ITLPCSIM                *
*                                                              *     TM
* INPUT                                                        *     TM
*   THE PROGRAM OLD PSW                                        *     TM
*                                                              *     TM
* OUTPUT                                                       *     TM
*   PROGRAM OLD PSW (CONDITION CODE AS APPROPRIATE)            *     TM
*   REGISTER OR STORAGE MODIFICATION AS APPROPRIATE            *     TM
*                                                              *     TM
* SUBROUTINES CALLED                                           *     TM
*   ITLSISO (THE GENERAL RECOVERY ROUTINE)                     *
*                                                              *     TM
* EXTERNAL REFERENCES                                          *     TM
*   PROGRAM NEW PSW                                            *     TM
*   PROGRAM OLD PSW                                            *     TM
*   MAIN STORAGE TO ACCESS OR STORE OPERANDS                   *     TM
*                                                              *     TM
* EXITS - NORMAL                                               *     TM
*   RETURN TO THE INTERRUPTED PROGRAM AT THE INSTRUCTION       *     TM
*   FOLLOWING THE ONE WHICH FAILED                             *     TM
*                                                              *     TM
* EXITS - ABNORMAL                                             *     TM
*                                                              *     TM
*   LPSW TO OS PROGRAM CHECK FLIH
* TABLES/WORK AREAS                                            *     TM
*
*   MSK3TB - ICM,STCM AND CLM MASK TABLE                       *     TM
*   RXAL   - RX INSTRUCTION STORAGE OPERAND LENGTH             *     TM
*   RXNDX  - RX INSTRUCTION TYPE BY OPCODE                     *     TM
*   RXTYP  - RX INSTRUCTION TYPE (E.G. LOAD,COMPARE,STORE)     *     TM
*                                                              *     TM
* ATTRIBUTES - RE-USABLE,PRIVILIGED,DISABLED, AND ITLPCSIM        *
*   MUST BE LOCATED BELOW MEMORY LOCATION 4096.                *     TM
*   ITLPCSIM  & ITLSISO ARE PARTIALY RE-ENTRANT. SECONDARY          *
*   PROGRAM CHECKS DURING RECOVERY ARE ACCEPTED AND            *     TM
*   PROCESSED.                                                 *     TM
*        E.G. A STCM IN A PP ATTEMPTS TO STORE INTO THE        *     TM
*             SUPERVISOR                                       *     TM
*             (A RECOVERABLE OPERATION EXCEPTION HAS       )   *     TM
*             (BECOME AN UNRECOVERABLE PROTECTION EXCEPTION)   *     TM
*                                                              *     TM
* NOTES                                                        *     TM
*   ITLPCSIM EXECUTES WITHOUT A BASE REGISTER.                    *
*   PROGRAM PARTITION INTEGRITY IS MAINTAINED BY-              *     TM
*        ENABLING STORAGE PROTECT IN THE USER KEY BEFORE STORE *     TM
*        ENABLING THE USER PROGRAM MASK                        *     TM
*   TABLE RXTYP CONTAINS 1 BYTE ADCONS, THEREFORE              *     TM
*   SUB-PROCESSORS RXLDT, RXMCC, RXSTG AND RXNVAL              *     TM
*   MUST FOLLOW AND BE WITHIN 250 BYTES OF RXPRC.              *     TM
*                                                              *     TM
*   1/29/78 UNIVERSITY OF NEBRASKA MODIFICATION:               *   UNCN
*        THE ORIGINAL CODE USED THE CONDITION CODE OF THE      *   UNCN
*        PROGRAM NEW PSW AS A RE-ENTRY GATE IN THE EVENT THAT  *   UNCN
*        PROGRAM CHECK OCURRED INSIDE THE PROGRAM CHECK        *   UNCN
*        RECOVERY ROUTINES.  THIS WAS MODIFIED SO THAT ALL     *   UNCN
*        REFERENCES TO PCNPSW WERE CHANGED TO PCNPSWCC (A BYTE *   UNCN
*        DEFINED IN THE STORAGE SECTION OF ITLPCSIM) SO THAT   *   UNCN
*        PROGRAMS THAT MODIFY PROGRAM NEW PSW WILL NOT AFFECT  *   UNCN
*        THE EXECUTION OF ITEL'S PROGRAM CHECK RECOVERY.       *   UNCN
*                                                              *   UNCN
****************************************************************     TM
*                                                                    TM
****************************************************************     TM
* ITLPCSIM IS ENTERED VIA THE PROGRAM NEW PSW. THE CONDITION      *
* CODE OF THE PROGRAM NEW IS USED AS A RE-ENTRY GATE IN        *     TM
* CASE SECONDARY PROGRAM CHECKS OCCUR DURING RECOVERY.         *     TM
*   CC=0 NORMAL ENTRY                                          *     TM
*   CC=1 RE-ENTRY - A PROGRAM CHECK DURING RECOVERY            *     TM
*   CC=2 THE PROGRAM CHECK HAS BEEN GIVEN TO THE               *     TM
*        GENERAL RECOVERY ROUTINE                              *     TM
*   CC=3 RE-ENTRY - A PROGRAM CHECK DURING RECOVERY            *     TM
****************************************************************     TM
*                                                                    TM
.NRLC2   ANOP                                              1/12/76
         ENTRY PIXT2
PIXT2    SVC   3
         USING IPLPSW,0
         AIF   ('&TYPE' NE 'NULL').NONULL                   1/6/76
ITLPCSIM LPSW  PCNPSW2 YOU DUMMY-THIS IS A 370 GO TO PCFLIH 1/6/76
         AGO   .NULLSM2                                     1/6/76
.NONULL  ANOP                                               1/6/76
ITLPCSIM TM    PCNPSWCC,X'30'      TEST RE-ENTRY SWITCH            UNCN
         BC    1,GPCRENT2                                          UNCN
         BC    4,PCRENT2
*
****************************************************************     TM
* INITIAL ENTRY-                                               *     TM
*   SAVE USER'S REGISTERS                                      *     TM
*   SAVE THE INITIAL ENTRY PROGRAM OLD PSW                     *     TM
*   GATE THE PROGRAM NEW TO PCRENT2 IN                         *     TM
*    CASE OF RE-ENTRY                                          *     TM
****************************************************************     TM
         STM   R0,R2,SVRG0        SAVE USER REGISTERS 0,1,2          TM
         LM    R0,R1,PCOLDP       SAVE PROGRAM OLD PSW               TM
         STM   R0,R1,COPYPSW      IN COPYPSW                         TM
         AIF   ('&TYPE' NE 'SHORT').NOTSHRT                 1/6/76
*   SIMULATION TO BE DONE FOR NON-DAT 370                   1/6/76
         B     GPCRCV             GO TO THE GENERAL ROUTINE 2/25/76
         AGO   .NOFXSIM                                     1/6/76
.NOTSHRT ANOP                                               1/6/76
         OI    PCNPSWCC,X'10'     SET CC=1 IN THE PROGRAM NEW      UNCN
*   ASSUME THE INTERRUPTED INST. IS 4 BYTES                          TM
         SL    R1,Q8N04           SUBTRACT ILC 4 AND 4 BYTES         TM
         LR    R0,R1              COPY RESULT                        TM
         N     R0,QCN01           TEST ASSUMPTION                    TM
         BNZ   GPCRCV              NOT TRUE,GO TO THE GENERAL
*                                 ROUTINE                            TM
         MVC   COPYI(4),0(R1)     COPY THE INSTRUCTION               TM
*                                                                    TM
*   CHECK IF THE INSTRUCTION IS AN RX TYPE                           TM
*                                                                    TM
         TM    COPYI,B'01000000'  TEST IF RX                         TM
         BO    RXRCV              YES,GO TO THE RX ROUTINE           TM
*                                                                    TM
*   ASSUME THE INSTRUCTION IS ICM, STCM OR CLM                       TM
*   GO TO THE ICM,STCM & CLM SET UP ROUTINE                          TM
*                                                                    TM
         B     MSK370             GO SET UP ICM, STCM & CLM          TM
*                                                                    TM
.NOFXSIM ANOP                                               1/6/76
****************************************************************     TM
* PROGRAM CHECK RE-ENTRY                                       *     TM
*   THE HARDWARE FACILITIES ARE USED TO DETERMINE              *     TM
*   INSTRUCTION VALIDITY DURING RECOVERY-                      *     TM
*        STORAGE PROTECT IS ENABLED.                           *     TM
*        INVALID REGISTER SPECIFICATION ETC IS TRAPPED         *     TM
*        THE USER'S PROGRAM MASK IS ENABLED                    *     TM
*   IF A SECONDARY PROGRAM INTERRUPT OCCURS                    *     TM
*   THE INTERRUPT CODE FROM THE SECOND INTERRUPT               *     TM
*   IS STORED INTO THE COPY OF THE ORIGINAL INTERRUPT.         *     TM
*   THE UPDATED COPY IS PUT BACK INTO THE PROGRAM OLD PSW      *     TM
*   AND THE INTERRUPT IS GIVEN TO THE OS/MVT ROUTINE.          *     TM
****************************************************************     TM
PCRENT2  MVC   COPYPSW+2(2),PCOLDP+2 MOVE NEW INT. CODE TO THE       TM
*                                 COPIED ORIGINAL PRG. OLD           TM
         MVC   PCOLDP(8),COPYPSW  RESTORE THE UPDATED ORIGINAL       TM
         LM    R0,R2,SVRG0        RESTORE USER REGISTERS             TM
*   SET GATE TO NORMAL ENTRY                                         TM
PCRENT2X NI    PCNPSWCC,X'CF'     SET RE-ENTRY GATE TO NORMAL      UNCN
         MVC   LSTVPC(8),COPYPSW  SAVE LAST VALID PROGRAM CHECK      TM
         LPSW  PCNPSW2            EXIT TO OS/MVT ROUTINE             TM
*                                                                    TM
****************************************************************     TM
* GENERAL PROGRAM INTERRUPT ROUTINE CALL                       *     TM
*   THE PROGRAM CHECK CANNOT BE RECOVERED HERE                 *     TM
*   THE GENERAL ROUTINE IS CALLED                              *     TM
****************************************************************     TM
GPCRCV   LM    R0,R2,SVRG0        RESTORE USER REGISTERS
         OI    PCNPSWCC,X'20'     SET GATE TO RE-ENTER THE         UNCN
*                                 GENERAL ROUTINE                    TM
*                                                                    TM
****************************************************************     TM
*   THE GENERAL RECOVERY ROUTINE (ITLSISO)
*   LOCATION IS IN AGPCRCV.
****************************************************************     TM
*   SECONDARY PROGRAM CHECKS WHILE THE GENERAL ROUTINE         *     TM
*   IS ACTIVE RE-ENTER HERE                                    *     TM
****************************************************************     TM
GPCRENT2 DS    0H                                                   DSX
         AIF  ('&CTRLPGM' EQ 'MFT').MFT07                           DSX
         STM   R0,RF,IEAPKSAV     SAVE ALL REGISTERS                 TM
         AGO   .NOTMFT4                                             DSX
.MFT07   ANOP                                                       DSX
         STM   RA,R9,PISAV *       SAVE ALL REGISTERS               DSX
.NOTMFT4 ANOP                                                       DSX
         L     RF,AGPCRCV         GET ADDRESS OF GEN'L
         BALR  RE,RF              CALL IT                            TM
         AIF   ('&TYPE' EQ 'SHORT').NOSIMFX                 1/6/76
*                                                                    TM
****************************************************************     TM
* ICM,STCM & CLM SIMULATION - SET UP.                          *     TM
*                                                              *     TM
*   SET UP INSTRUCTIONS SAVOR1 AND GETADD TO                   *     TM
*   STORE REGISTER OPERAND 1 AND                               *     TM
*   OBTAIN THE ADDRESS OF STORAGE OPERAND 2                    *     TM
****************************************************************     TM
MSK370   MVZ   SAVOR1+1(1),COPYI+1 COPY REGISTER FIELD               TM
         L     R0,COPYI           COPY B2 D2 OPERAND                 TM
         STH   R0,GETADD00+2      INTO GETADD                        TM
         LM    R0,R1,SVRG0        RESTORE USER'S REGISTERS.          TM
*                                                                    TM
*   THE XXX FIELDS OF SVOR1 AND GETADD HAVE BEEN FILLED              TM
*   IN BY FIELDS FROM THE INTERRUPTED INSTRUCTION                    TM
*                                                                    TM
SAVOR1   ST    XXX,REGOP1         STORE REGISTER OPERAND 1           TM
GETADD00 LA    R1,XXX(0,XXX)      GET STORAGE OPERAND ADDR           TM
*                                                                    TM
*   GET OPERAND 3 MASK AND ACCESS THE MASK TABLE                     TM
*   FOR DEFINITION.                                                  TM
*                                                                    TM
         IC    R2,COPYI+1         GET OPERAND3 MASK                  TM
         N     R2,F               ISOLATE MASK BITS                  TM
         IC    R2,MSK3TB(R2)      GET EXECUTE TABLE VALUE            TM
*                                                                    TM
*   SPLIT UP INSTRUCTIONS FOR SIMULATION                             TM
*                                                                    TM
         CLI   COPYI,X'BF'        ICM ?                              TM
         BE    ICMRCV             YES,GO                             TM
         CLI   COPYI,X'BE'        STCM ?                             TM
         BE    STCMRCV            YES,GO                             TM
         CLI   COPYI,X'BD'        CLM ?                              TM
         BE    CLMRCV             YES,GO                             TM
         B     GPCRCV              GO TO GENERAL ROUTINE              T
*                                                                    TM
****************************************************************     TM
*                                                              *     TM
*ICM SIMULATOR                                                 *     TM
*                                                              *     TM
*   THE ICM SIMULATION IS TO-                                  *     TM
*        PRESET  THE EXIT PSW (PROG. OLD)  COND. CODE =0       *     TM
*        MOVE THE PROPER NUMBER OF STORAGE BYTES INTO          *     TM
*              THE PROPER POSITIONS OF THE STORED REGISTER     *     TM
*        DETERMINE AND SET THE PROPER COND. CODE               *     TM
*        RESTORE THE REGISTER OPERAND                          *     TM
*                                                              *     TM
****************************************************************     TM
ICMRCV   NI    PCOLDP+4,X'CF'     PRESET USER CC=0                   TM
         EX    0,ICMV(R2)         MOVE BYTES FROM                    TM
*                                 OPERAND 2 TO OPERAND 1             TM
         EX    0,ICMCL(R2)        TEST IF ALL MOVED BYTES            TM
*                                 ARE ZERO                           TM
         BC    8,ICMRCVX          CC=0 (PRESET) GO TO EXIT           TM
         OI    PCOLDP+4,X'20'     SET CC=2 (MOVED BYTES              TM
*                                 ARE NON ZERO (1ST BIT 0))          TM
         TM    0(R1),X'80'        TEST IF FIRST BIT=0                TM
         BZ    ICMRCVX            YES,GO TO ICM EXIT                 TM
         XI    PCOLDP+4,X'30'     SET CC=1 (BYTES MOVED NON          TM
*                                 ZERO (1ST BIT =1))                 TM
*                                                                    TM
*   REGISTER OPERAND 1 MUST BE RESTORED                              TM
*   SET UP LOAD INSTRUCTION                                          TM
*                                                                    TM
ICMRCVX  LM    R0,R2,SVRG0        RESTORE USER'S REGISTERS           TM
         MVZ   ICMLD1+1(1),COPYI+1 COPY REG NO.                      TM
ICMLD1   L     XXX,REGOP1         RESTORE REGISTER                   TM
         B     RXEXIT             GO TO COMMON EXIT                  TM
*                                                                    TM
* ICMV   MVC INSTRUCTION TABLE                                       TM
*   MOVE BYTES FROM THE STORAGE OPERAND 2 TO MASK                    TM
*   CORRESPONDING POSITIONS IN REGISTER OPERAND 1                    TM
ICMV     MVC   REGOP1+3(1),0(R1)  M1                                 TM
         MVC   REGOP1+2(2),0(R1)  M3                                 TM
         MVC   REGOP1+1(3),0(R1)  M7                                 TM
         MVC   REGOP1+0(1),0(R1)  M8                                 TM
         MVC   REGOP1+0(2),0(R1)  MC                                 TM
         MVC   REGOP1+0(4),0(R1)  MF                                 TM
         B     GPCRCV              M0,2,4,5,6,9,A,B,D & E             T
*                                                                    TM
* ICMCL  CLC INSTRUCTION TABLE                                       TM
*   COMPARE ZERO TO THE OPERAND 2 BYTES AS PER THE MASK              TM
ICMCL    CLC   QZERO(1),0(R1)     M1                                 TM
         CLC   QZERO(2),0(R1)     M3                                 TM
         CLC   QZERO(3),0(R1)     M7                                 TM
         CLC   QZERO(1),0(R1)     M8                                 TM
         CLC   QZERO(2),0(R1)     MC                                 TM
         CLC   QZERO(4),0(R1)     MF                                 TM
*                                                                    TM
****************************************************************     TM
*                                                              *     TM
*STCM SIMULATOR                                                *     TM
*                                                              *     TM
*   THE STCM SIMULATION IS TO-                                 *     TM
*        SET THE CURRENT PSW TO THE USER'S KEY                 *     TM
*        MOVE THE PROPER BYTES FROM THE REGISTER OPERAND       *     TM
*              TO THE STORAGE OPERAND                          *     TM
*                                                              *     TM
****************************************************************     TM
STCMRCV  MVZ   STCMPSW+1(1),PCOLDP+1 SET USER KEY INTO               TM
*                                 THE NEXT USED PSW                  TM
         LPSW  STCMPSW            ENABLE STORAGE PROTECT             TM
STCMRCV1 EX    0,STCMV(R2)        STORE PROPER REGISTER              TM
*                                 BYTES INTO OPERAND 2               TM
         LM    R0,R2,SVRG0        RESTORE USER'S REGISTERS           TM
         LPSW  RSMPSW             RESTORE KEY 0 AND GO               TM
*                                 TO COMMON EXIT (RXEXIT)            TM
*                                                                    TM
* STCMV  MVC INSTRUCTION TABLE                                       TM
*   MOVE OPERAND 1 BYTES (CORRESPONDING TO THE MASK) TO THE          TM
*   STORAGE OPERAND 2 ADDRESS                                        TM
STCMV    MVC   0(1,R1),REGOP1+3   M1                                 TM
         MVC   0(2,R1),REGOP1+2   M3                                 TM
         MVC   0(3,R1),REGOP1+1   M7                                 TM
         MVC   0(1,R1),REGOP1+0   M8                                 TM
         MVC   0(2,R1),REGOP1+0   MC                                 TM
         MVC   0(4,R1),REGOP1+0   MF                                 TM
         LPSW  GPCRPSW            M0,2,4,5,6,9,A,B,D & E             TM
*                                                                    TM
****************************************************************     TM
*                                                              *     TM
*CLM SIMULATOR                                                 *     TM
*                                                              *     TM
*   THE CLM SIMULATION IS TO-                                  *     TM
*        PRESET THE COND CODE TO ZERO                          *     TM
*        COMPARE THE PROPER BYTES FROM THE REGISTER            *     TM
*              OPERAND TO THE STORAGE OPERAND                  *     TM
*        SET THE APPROPRIATE CC                                *     TM
*                                                              *     TM
****************************************************************     TM
CLMRCV   NI    PCOLDP+4,X'CF'     PRESET USER CC=0                   TM
         EX    0,CLMCL(R2)        COMPARE  THE PROPER                TM
*                                 BYTES FROM 'REGISTER'              TM
*                                 OPERAND TO THE STORAGE             TM
*                                 OPERAND                            TM
         LM    R0,R2,SVRG0        RESTORE USER'S REGISTERS           TM
         B     COMCCSET           GO TO COMMON CC SET                TM
*                                 AND EXIT                           TM
*                                                                    TM
* CLMCL CLC INSTRUCTION TABLE                                        TM
*   COMPARE BYTES FROM OPERAND 1 (CORRESPONDING TO THE               TM
*   MASK) TO OPERAND 2                                               TM
CLMCL    CLC   REGOP1+3(1),0(R1)  M1                                 TM
         CLC   REGOP1+2(2),0(R1)  M3                                 TM
         CLC   REGOP1+1(3),0(R1)  M7                                 TM
         CLC   REGOP1+0(1),0(R1)  M8                                 TM
         CLC   REGOP1+0(2),0(R1)  MC                                 TM
         CLC   REGOP1+0(4),0(R1)  MF                                 TM
         B     GPCRCV              M0,2,4,5,6,9,A,B,D & E             T
*                                                                    TM
****************************************************************     TM
*                                                              *     TM
* SPECIFICATION EXCEPTION RECOVERY                             *     TM
*                                                              *     TM
*   RXRCV RESOLVES SPECIFICATION EXCEPTIONS INCURRED           *     TM
*   BY RX INSTRUCTIONS DUE TO STORAGE OPERAND MISALIGNMENT     *     TM
*                                                              *     TM
*   THE RECOVERY IS TO-                                        *     TM
*        GENERATE THE STORAGE OPERAND ADDRESS                  *     TM
*        MOVE THE OPERAND TO AN ALIGNED LOCATION               *     TM
*        RETRY THE OPERATION                                   *     TM
*        SET THE CONDITION CODE AS REQUIRED                    *     TM
*        RESTORE THE STORAGE OPERAND AS REQUIRED               *     TM
*                                                              *     TM
****************************************************************     TM
RXRCV    CLI   PCOLDP+3,X'06'     TEST IF A SPECIFICATION            TM
*                                 EXCEPTION                          TM
         BNE   GPCRCV              NO,GO TO GENERAL RTN               T
*   SET UP A LOAD ADDRESS INSTRUCTION TO OBTAIN THE ADDRESS          TM
*   OF THE STORAGE OPERAND.                                          TM
         L     R0,COPYI           GET INSTRUCTION                    TM
         STH   R0,GETADR+2        STORE B2 D2 IN LA                  TM
         MVN   GETADR+1(1),COPYI+1 MOVE X2 TO LA                     TM
*   SET UP A RETRY INSTRUCTION                                       TM
         LH    R0,COPYI           GET OPCDE,R1,X2                    TM
         STH   R0,RETRYOP         STORE OP,R1,X2 IN RETRY            TM
         NI    RETRYOP+1,X'F0'    CLEAR THE X2 FIELD                 TM
*                                                                    TM
*   GET AND SET THE USER'S PROGRAM MASK                              TM
*                                                                    TM
         L     R1,PCOLDP+4        GET USER PRGRAM MASK               TM
         SPM   R1                 SET IT                             TM
*                                                                    TM
*   PRESET CC=0. FOR ACCESS INSTRUCTIONS                             TM
*   THERE CAN BE NO MORE CC MODIFYING INSTRUCTIONS                   TM
*   BEFORE EXECUTING RETRYOP                                         TM
*                                                                    TM
         SR    R1,R1              CLEAR R1                           TM
*                                                                    TM
*   USE THE OP CODE TO GET THE INSTRUCTION DESCRIPTION INDEX         TM
*                                                                    TM
         IC    R1,COPYI           GET OP CODE                        TM
         IC    R1,RXNDX-X'40'(R1) GET ASSOCIATED INDEX               TM
         IC    R0,RXAL(R1)        GET THE ARGUMENT LENGTH            TM
         IC    R1,RXTYP(R1)       GET THE INSTRUCTION TYPE           TM
         B     RXPRC(R1)          GO TO PROPER PROCESSOR             TM
*                                 E.G. LOAD,COMPARE,STORE            TM
*                                                                    TM
RXPRC    EQU   *                  DUMMY WHICH MUST PRECEDE           TM
*                                 AND BE AT MOST 250 BYTES           TM
*                                 FROM RXNVAL, RXMCC, RXLDT          TM
*                                 AND RXSTG                          TM
*                                                                    TM
****************************************************************     TM
*   SPECIFICATION EXCEPTIONS NOT CAUSED BY MISALIGNED          *     TM
*   STORAGE OPERANDS ARE GIVEN TO THE GENERAL PROGRAM          *     TM
*   CHECK ROUTINE                                              *     TM
****************************************************************     TM
RXNVAL   B     GPCRCV              GO TO GENERAL ROUTINE              T
*                                                                    TM
****************************************************************     TM
*   RX STORAGE MODIFICATION INSTRUCTIONS COME HERE             *     TM
****************************************************************     TM
RXSTG    STC   R0,RALIGN+1        STORE ARGUMENT LENGTH IN MVC       TM
         LM    R0,R1,SVRG0        RESTORE USER'S REGISTERS           TM
         EX    0,RETRYOP          RETRY THE INSTRUCTION              TM
         ST    R1,SVRG1           SAVE USER R1                       TM
         EX    0,GETADR           GET THE STORAGE OPERAND            TM
*                                 ADDRESS                            TM
*                                                                    TM
*   ENABLE STORAGE PROTECT                                           TM
*                                                                    TM
         MVZ   PRTPSW+1(1),PCOLDP+1 SET USER KEY IN NEXT PSW         TM
         LPSW  PRTPSW             CONTINUE IN USER KEY               TM
RALIGN   MVC   0(XXX,R1),DBLWRD   STORE RESULTANT OPERAND            TM
         L     R1,SVRG1           RESTORE USER'S R1                  TM
         LPSW  RSMPSW             RE-INSTATE KEY 0 AND               TM
*                                 GO TO RXEXIT                       TM
*                                                                    TM
****************************************************************     TM
*   INSTRUCTIONS WHICH MODIFY THE CONDITION CODE COME HERE     *     TM
****************************************************************     TM
RXMCC    NI    PCOLDP+4,X'CF'     PRESET USER CC=0                   TM
*                                                                    TM
****************************************************************     TM
*   ACCESS ONLY INSTRUCTIONS ENTER HERE                        *     TM
****************************************************************     TM
RXLDT    STC   R0,PALIGN+1        STORE OPERAND 2 LENGTH             TM
*                                 INTO ALIGNMENT MVC                 TM
         LM    R0,R1,SVRG0        RESTORE USER'S REGISTERS           TM
GETADR   LA    R1,XXX(XXX,XXX)    GET THE STORAGE OPERAND            TM
*                                 ADDRESS                            TM
PALIGN   MVC   DBLWRD(XXX),0(R1)  ALIGN THE STORAGE OPERAND          TM
         L     R1,SVRG1           RESTORE USER'S R1                  TM
RETRYOP  LA    XXX,DBLWRD         RETRY THE INSTRUCTION              TM
*                                                                    TM
COMCCSET BC    8,RXEXIT           EXIT IF CC=0 OR IF                 TM
*                                 CC NOT TO BE SET                   TM
         BC    4,RXCC1            GO SET CC=1                        TM
         BC    2,RXCC2            GO SET CC=2                        TM
         OI    PCOLDP+4,X'30'     SET CC=3                           TM
         B     RXEXIT             EXIT                               TM
RXCC1    OI    PCOLDP+4,X'10'     SET CC=1                           TM
         B     RXEXIT             EXIT                               TM
RXCC2    OI    PCOLDP+4,X'20'     SET CC=2                           TM
*                                                                    TM
****************************************************************     TM
*   COMMON EXIT                                                *     TM
*   SET ENTRY GATE IN THE PROGRAM NEW TO NORMAL ENTRY          *     TM
*   LOAD PSW OF THE PROGRAM OLD RESUMES THE USER PROGRAM       *     TM
*        AT THE INSTRUCTION FOLLOWING THE PROGRAM CHECK        *     TM
****************************************************************     TM
RXEXIT   NI    PCNPSWCC,X'CF'     SET NORMAL ENTRY GATE            UNCN
         MVC   COPYPSW(8),PCOLDP  COPY EXIT PSW                      TM
         MVC   PCOLDP(8),LSTVPC   SET LAST VALID PROGRAM CHECK       TM
         LPSW  COPYPSW            RESUME INTERRUPTED PROGRAM         TM
*                                                                    TM
****************************************************************     TM
*                                                              *     TM
*              TABLES/BLOCKS                                   *     TM
*                                                                    TM
****************************************************************     TM
*   TABLE RXTYP CONTAINS 1 BYTE ADCONS TO ACCESS THE           *     TM
*   DIFFERENT SUB-PROCESSORS FOR :                             *     TM
*        STORAGE ACCESS INSTRUCTIONS                           *     TM
*        CONDITION CODE MODIFICATION INSTRUCTIONS              *     TM
*        STORAGE MODIFICATION INSTRUCTIONS                     *     TM
*   EACH VALID TYPE HAS THREE TABLE ENTRIES FOR                *     TM
*   2,4 OR 8 BYTE STORAGE OPERAND LENGTHS RESPECTIVELY         *     TM
****************************************************************     TM
RXTYP    DC    AL1(RXNVAL-RXPRC)  UNDEFINED, GO TO THE               TM
*                                 GENERAL ROUTINE                    TM
         DC    3AL1(RXLDT-RXPRC)  ACCESS ONLY                        TM
         DC    3AL1(RXMCC-RXPRC)  CONDITION CODE MODIFICATION        TM
         DC    3AL1(RXSTG-RXPRC)  STORAGE MODIFICATION               TM
*                                                                    TM
****************************************************************     TM
*   TABLE RXAL CONTAINS 1 BYTE STORAGE OPERAND LENGTHS (-1)    *     TM
*   EACH VALID LENGTH IS IN THE TABLE THREE TIMES              *     TM
*   FOR LOAD, COMPARE AND STORE INSTRUCTIONS RESPECTIVELY      *     TM
****************************************************************     TM
RXAL     DC    X'00'              UNDEFINED                          TM
         DC    X'010307'          2,4,8 BYTE OPERANDS (ACCESS)       TM
         DC    X'010307'          2,4,8 BYTE OPERANDS (CC)           TM
         DC    X'010307'          2,4,8 BYTE OPERANDS (STORE)        TM
*                                                                    TM
****************************************************************     TM
*   TABLE RXNDX CONTAINS 1 BYTE ENTRIES GIVING THE PROPER      *     TM
*   INDEX INTO RXTYP AND RXAL FOR THE 360 RX SET               *     TM
****************************************************************     TM
*                                                                    TM
RXNDX    DC    X'07000000'        X'40' STH,LA,STC,IC                TM
         DC    X'00000000'        X'44' EX,BAL,BCT,BC                TM
         DC    X'01040404'        X'48' LH,CH,AH,SH                  TM
         DC    X'01000903'        X'4C' MH,U,CVD,CVB                 TM
         DC    X'08000000'        X'50' ST,U,U,U                     TM
         DC    X'05050505'        X'54' N,CL,O,X                     TM
         DC    X'02050505'        X'58' L,C,A,S                      TM
         DC    X'02020505'        X'5C' M,D,AL,SL                    TM
         DC    X'09000000'        X'60' STD,U,U,U                    TM
         DC    X'00000000'        X'64' U,U,U,U                      TM
         DC    X'03060606'        X'68' LD,CD,AD,SD                  TM
         DC    X'03030606'        X'6C' MD,DD,AW,SW                  TM
         DC    X'08000000'        X'70' STE,U,U,U                    TM
         DC    X'00000000'        X'74' U,U,U,U                      TM
         DC    X'02050505'        X'78' LE,CE,AE,SE                  TM
         DC    X'02020505'        X'7C' ME,DE,AU,SU                  TM
*                                                                    TM
****************************************************************     TM
*   TABLE MSK3TB CONTAINS 1 BYTE EQUIVALENTS TO ICM,STCM,CLM   *     TM
*   MASK VALUES IN THE FORM OF OFFSETS TO MVC OR CLC           *     TM
*   INSTRUCTIONS.                                              *     TM
****************************************************************     TM
MSK3TB   DC    X'24002406'        MASK VALUES 0,1,2,3                TM
         DC    X'2424240C'                    4,5,6,7                TM
         DC    X'12242424'                    8,9,A,B                TM
         DC    X'1824241E'                    C,D,E,F                TM
.NOSIMFX ANOP                                               1/6/76
*                                                                    TM
****************************************************************     TM
*                                                              *     TM
*              PSWS                                            *     TM
*                                                              *     TM
****************************************************************     TM
*                                                                    TM
.NULLSM2 ANOP                                               1/6/76
         DS    0D                 ALIGN DOUBLE WORD                  TM
*                                                                    TM
*   PSW TO ENTER OS/MVT PROGRAM INTERRUPT ROUTINE                    TM
PCNPSW2  DC    X'00040000'        ENABLE MACHINE ONLY                TM
         AIF   ('&CTRLPGM' EQ 'MFT').MFT08                          DSX
         DC    V(IEAQPK00)          OS/MVT INTERRUPT ROUTINE
         AGO   .NOTMFT5                                             DSX
.MFT08   ANOP                                                       DSX
         DC    V(IEAAPK00) *        OS/MFT INTURRUPT ROUTINE        DSX
.NOTMFT5 ANOP                                                       DSX
         AIF   ('&TYPE' EQ 'NULL').MFT09                    1/6/76
*                                                                    TM
*   PSWS USED TO ENABLE STORAGE PROTECT                              TM
*        THE PSWS ARE INITIALIZED TO THE USER'S KEY                  TM
*        PRIOR TO STORAGE MODIFICATION                               TM
         AIF   ('&TYPE' EQ 'SHORT').GPXRPSW
STCMPSW  DC    X'00040000'        ENABLE FOR MACHINE ONLY            TM
         DC    A(STCMRCV1)        RETURN TO STCMRCV1                 TM
PRTPSW   DC    X'00040000'        DISABLED                           TM
         DC    A(RALIGN)          CONTINUE                           TM
*                                                                    TM
*   PSWS USED TO RETURN TO KEY 0                                     TM
RSMPSW   DC    X'00040000'        ENABLE MACHINE ONLY                TM
         DC    A(RXEXIT)          GO TO COMMON EXIT                  TM
.GPXRPSW ANOP
GPCRPSW  DC    X'00040000'        ENABLE FOR MACHINE ONLY            TM
         DC    A(GPCRCV)          GO TO GPCRCV FOR STCM              TM
*                                                                    TM
****************************************************************     TM
*                                                              *     TM
*              STORAGE                                         *     TM
*                                                              *     TM
****************************************************************     TM
*                                                                    TM
COPYPSW  DC    D'0'               COPY OF THE PROGRAM OLD            TM
LSTVPC   DC    D'0'               LAST VALID PROGRAM CHECK           TM
DBLWRD   DC    D'0'               DOUBLE WORD WORK AREA              TM
COPYI    DC    F'0'               COPY INTERRUPTED INST.             TM
REGOP1   DC    F'0'               REGISTER OPERAND 1 SAVE            TM
SVRG0    DC    F'0'               SAVE USER REG 0                    TM
SVRG1    DC    F'0'               SAVE USER REG 1                    TM
SVRG2    DC    F'0'               SAVE USER REG 2                    TM
QZERO    DC    F'0'               ZERO                               TM
Q8N04    DC    X'80000004'        ILC 4 AND ADDRESS 4                TM
QCN01    DC    X'C0000001'        ILC 6 AND ODD ADDRESS              TM
F        DC    X'0000000F'        ISOLATE LOW ORDER X DIGIT          TM
PCNPSWCC DC    X'00'     PROGRAM NEW PSW CONDITION CODE BYTE       UNCN
*                                                                    TM
****************************************************************     TM
*                                                              *     TM
*              EQUATES                                         *     TM
*                                                              *     TM
****************************************************************     TM
*                                                                    TM
XXX      EQU   0                  FILLER FOR INSTRUCTION             TM
*                                 MODIFICATION                       TM
*                                                                    TM
PCNPSW   EQU   X'68'              PROGRAM NEW PSW                    TM
PCOLDP   EQU   X'28'              PROGRAM OLD PSW                    TM
AGPCRCV  DC    V(ITLSISO)
         AIF   ('&CTRLPGM' EQ 'MFT').MFT09                          DSX
R0       EQU   0                  R0                                 TM
R1       EQU   1                  R1                                 TM
R2       EQU   2                  R2                                 TM
RE       EQU   14                 RE                                 TM
RF       EQU   15                 RF                                 TM
.MFT09   ANOP                                                       DSX
         MEND                                                        TM
