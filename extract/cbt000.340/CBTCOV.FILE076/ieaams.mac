         MACRO
         IEAAMS  &VALIDCK,&SPCHK,&LCSTORE,&SMFCORE,&ATTACH
         LCLB  &LCS,&SMF,&ATT
IGC010   CSECT
         TITLE 'IEAAMS INTRODUCTION REL 21.7'
* &VALIDCK AND &SPCHK PARMS ARE IGNORED,SINCE VALIDITY CHECKING IS
* ALWAYS DONE.  &VALIDCK AND &SPCHK WERE LEFT IN SO THAT  IEAAMS
* WOULD BE COMPATIBLE WITH SGIEA2MS.
&LCS     SETB  ('&LCSTORE' EQ 'Y')
&SMF     SETB  ('&SMFCORE' EQ '1')
&ATT     SETB  ('&ATTACH'  EQ 'Y')
***********************************************************************
*              MFT  GETMAIN/FREEMAIN INTRODUCTORY COMMENTS            *
*              *******************************************            *
*                                                                     *
*                                                                     *
*                                                                     *
* STATUS:  CHANGE LEVEL 0                                             *
*                                                                     *
* FUNCTION:  IEAAMS CONTROLS THE ALLOCATION AND RELEASE OF ALL        *
*            DYNAMIC MAIN STORAGE AND OF THE SYSTEM QUEUE AREA .      *
*            IEAAMS IS A TYPE1 SVC ROUTINE WHICH GETS CONTROL AS      *
*            THE  RESULT OF SVC 4, SVC 5, OR SVC 10 BEING ISSUED.     *
         AIF   (NOT &SMF).NOSMFNX
*            IF SMF IS SYSGENED AND ACTIVE IN THE SYSTEM, IEAAMS      *
*            MAINTAINS THE LOW WATER MARK, THE HIGH WATER MARK,       *
*            AND THE MINIMUM DIFFERENCE IN 2K BLOCKS BETWEEN          *
*            HIGH AND LOW WATER MARKS.                                *
.NOSMFNX ANOP
*                                                                     *
*                                                                     *
*            IEAAMS CONSISTS OF 3 ENTRY ROUTINES AND 5-7 SUBROUTINES  *
*            DEPENDING ON WHICH SYSGEN OPTIONS ARE PRESENT. THE       *
*            ENTRY ROUTINES ARE IGC010,IGC004 AND IGC005. THE         *
*            SUBROUTINES ARE SPGET,GETCORE,FREECORE,FQECHECK          *
*            ABTERM SETUP                                             *
         AIF   (NOT &ATT).NOATTFN
*            GQESRCH                                                  *
.NOATTFN ANOP
         AIF   (NOT &SMF).NOSMFN2
*            SMFGET
.NOSMFN2 ANOP
*                                                                     *
*                  ***** ENTRY ROUTINES *****                         *
*                                                                     *
*            IGC010-FOR A FREEMAIN, BALR TO'SPGET'TO VALIDATE PARMS,  *
*                   AND GET ADDRESS OF THE BOUNDARY BOX. NEXT,        *
*                   BALR TO'FREECORE' AND EXIT.                       *
*                                                                     *
*                  -FOR A GETMAIN, BALR TO 'SPGET' TO VALIDATE        *
*                   PARMS, AND GET ADDRESS OF THE BOUNDARY BOX.       *
*                   NEXT, BALR TO 'GETCORE'. IF'GETCORE' WAS          *
*                   SUCCESSFUL, ZERO REG15 AND EXIT. IF 'GETCORE'     *
*                   WAS UNSUCCESSFUL, AND STEAL CORE CONDITION        *
*                   EXISTS,RETURN CODE=4 AND EXIT. IF NO STEAL        *
*                   CORE CONDITION EXISTS, GO TO'ABTERM SETUP'        *
*                   WITH 80A.                                         *
*                                                                     *
*            IGC004-BALR TO 'SPGET' TO VALIDATE PARMS AND GET THE     *
*                   ADDRESS OF THE BOUNDARY BOX.                      *
*                   BALR TO 'GETCORE'(FOR A VARIABLE REQUEST,USE      *
*                   MAXIMUM SIZE). IF GETCORE WAS SUCCESSFUL, PUT     *
*                   ADDRESS OF ALLOCATED CORE IN PARMLIST, ZERO       *
*                   RETURN CODE, AND EXIT.                            *
*                                                                     *
*                   IF GETCORE WAS UNSUCCESSFUL FOR A VARIABLE        *
*                   REQUEST AND THE LARGEST FQE IS GREATER THAN       *
*                   THE MINIMUM SIZE, BALR TO 'GETCORE' WITH LAR-     *
*                   GEST FQE SIZE. FOR A CONDITIONAL REQUEST,         *
*                   RETURN CODE=4 AND EXIT.                           *
*                   FOR AN UNCONDITIONAL'GETCORE' FAILURE AND         *
*                   A STEAL CORE CONDITION RETURN CODE=4 AND EXIT.    *
*                   IF THE UNCONDITIONAL REQUEST IS NOT FOR STEAL     *
*                   CORE, GO TO ABTERM SETUP WITH AN 804.             *
*                                                                     *
*            IGC005-BALR TO 'SPGET' TO VALIDATE PARMS AND GET         *
*                   ADDR OF THE BOUNDARY BOX. NEXT, BALR TO           *
*                   'FREECORE' AND EXIT.                              *
*                                                                     *
*                           ***** SUBROUTINES *****                   *
*                                                                     *
*            SPGET- CALLED BY IGC004,IGC005,AND IGC010                *
*                   SPGET VALIDATES THE PARAMETERS AND GETS THE       *
         AIF   (NOT &LCS).NOLCSP
*                   ADDR OF THE CORRECT HIERARCHY BOUNDARY BOX        *
         AGO   .SPGEND
.NOLCSP  ANOP
*                   ADDR OF THE JOBSTEP BOUNDARY BOX                  *
.SPGEND  ANOP
*                                                                     *
*            GETCORE-CALLED BY IGC004,IGC010-GETMAIN                  *
*                   SEARCH DOWN THE FQE CHAIN FOR AN FQE TO SATISFY   *
*                   THE GETMAIN REQUEST. VALIDATE EACH FQE BY BALRS   *
*                   TO THE 'FQECHECK' SUBROUTINE. FOR A HIGH CORE     *
*                   REQUEST, USE THE 1ST FQE FOUND WHICH IS LARGE     *
*                   ENOUGH. FOR A LOW CORE REQUEST, SEARCH DOWN       *
*                   THE ENTIRE FQE CHAIN AND USE THE LOWEST FQE       *
*                   WHICH SATISFIES THE REQUEST. IF NO FQE IS         *
*                   LARGE ENOUGH, RETURN'NOT FOUND' TO CALLER.        *
*                   OTHERWISE, UPDATE THE FQE CHAIN TO ACCOUNT FOR    *
*                   THE ALLOCATED CORE.                               *
         AIF   (NOT &ATT).GTNOAT
*                   NEXT, IF THE REQUESTING TCB IS A SUBTASK, BUILD   *
*                   A GQE AND QUEUE IT'PUSH-DOWN' FROM THE SUBTASK    *
*                   DUMMY BOUNDARY BOX.                               *
.GTNOAT  ANOP
         AIF   (NOT &SMF).GTNOSM
*                   BALR TO SMFGET FOR SMF CALCULATING.               *
.GTNOSM  ANOP
*                   RETURN TO CALLER                                  *
*                                                                     *
*            FREECORE-CALLED BY IGC005,IGC010-FREEMAIN                *
         AIF   (NOT &ATT).NOFRAT
*                   WHEN A SUBTASK REQUESTS FREEING OF A SUBPOOL      *
*                   OTHER THAN SUBPOOL 240, FIND THE GQE WHICH        *
*                   DESCRIBES THE AREA TO FREE . THE GQE CHAIN        *
*                   OF THE REQUESTING SUBTASK IS 1ST SEARCHED VIA A   *
*                   BALR TO 'GQESRCH' SUBROUTINE. IF THE CORRECT      *
*                   GQE IS NOT FOUND IN THE REQUESTING TCB'S CHAIN,   *
*                   BALR TO 'GQESRCH' FOR EACH TCB IN THE JOBSTEP     *
*                   TCB FAMILY UNTIL THE GQE IS FOUND. IF THE GQE     *
*                   IS NOT FOUND (THE GETMAIN MAY HAVE BEEN ISSUED    *
*                   BY THE JOBSTEP TCB) BEGIN THE FQE SEARCH.IF       *
*                   THE GQE IS FOUND, UPDATE THE GQE CHAIN, AND       *
*                   BEGIN THE FQE SEARCH.                             *
*                                                                     *
.NOFRAT  ANOP
*                   FREECORE SEARCHES DOWN THE FQE CHAIN FOR THE      *
*                   FQES ON EITHER SIDE OF THE AREA TO BE FREED.      *
*                   EACH FQE IS VALIDATED VIA BALR TO 'FQECHECK'      *
*                   ADJUST THE FQE CHAIN TO INCLUDE THE AREA          *
*                   BEING FREED AND RETURN TO CALLER.                 *
*                                                                     *
*            FQECHECK-CALLED BY GETCORE OR FREECORE                   *
*                  VALIDITY CHECK THE FQE (FQE ADDRESS IN REG7) BY    *
*                  ASSURING THAT THE FOLLOWING IS TRUE:               *
*                  1. THE HIGH ORDER BYTES OF THE FQE FORWARD PTR     *
*                     AND SIZE FIELDS ARE BOTH=0                      *
*                  2. THE FQE FORWARD POINTER AND THE FQE SIZE ARE    *
*                     BOTH MULTIPLES OF 8.                            *
*                  3. ADDRESS + SIZE OF FQE IS LESS THAN ADDRESS      *
*                     OF PREVIOUS FQE                                 *
*                  4. ADDRESS OF NEXT FQE IS LESS THAN ADDRESS OF     *
*                     THIS FQE                                        *
*                  5. FQE ADDRESS IS WITHIN BOUNDS OF BOUNDARY BOX    *
*                                                                     *
*                  IF ANY OF THE ABOVE CONDITIONS FAIL, ZERO THE      *
*                  FORWARD PTR IN THE PREVIOUS FQE TO END THE CHAIN   *
*                  BEFORE THE BAD FQE AND GO TO'ABTERM SETUP' FOR     *
*                  A 60X-2 ABEND. OTHERWISE, RETURN TO CALLER.        *
*                                                                     *
*            ABTERM SETUP-PUT PROBLEM DETERMINATION INFORMATION       *
*                  INTO A WORK BUFFER. IF AN ENTRY IS AVAILABLE       *
*                  IN IEAQMSGS, COPY THE WORK BUFFER INTO THE         *
*                  IEAQMSGS ENTRY. SET UP THE REGS FOR ABTERM         *
*                  AND GO TO ABTERM                                   *
*                                                                     *
         AIF   (NOT &ATT).NOGQ                                        *
*            GQESRCH-CALLED BY FREECORE                               *
*                   SEARCH DOWN THE CHAIN OF GQES OF THE TCB WHICH    *
*                   IS PASSED IN REG7 FOR THE GQE DESCRIBING THE      *
*                   AREA TO BE FREED. IF NO GQE IN THE CHAIN MATCHES  *
*                   THE AREA TO FREE, RETURN TO 'FREECORE' TO HAVE    *
*                   THE NEXT TCB IN THE JOBSTEP LOADED.               *
*                   IF THE GQE IS FOUND, ADJUST THE GQE CHAIN TO      *
*                   DELETE THE AREA FREED AND RETURN TO 'FREECORE'    *
*                   FOR FQE PROCESSING                                *
*                                                                     *
.NOGQ    ANOP
         AIF   (NOT &SMF).NOSMF
*            SMFGET-CALLED BY GETCORE                                 *
*                   UPDATE THE TIMING CONTROL TABLE(TCT) STORAGE      *
*                   TABLES TO REPRESENT THE AMOUNT OF CORE USED       *
*                   BY NON-SYSTEM TASKS.                              *
*                   UPDATE THE HIGH WATER MARK WITH THE ADDRESS OF    *
*                   THE ALLOCATED AREA IF THE ADDRESS OF THE END      *
*                   OF THE ALLOCATED AREA= THE HIGH WATER MARK.       *
*                   UPDATE THE LOW WATER MARK WITH THE ADDRESS OF     *
*                   THE END OF THE ALLOCATED AREA IF THE ADDRESS      *
*                   OF THE ALLOCATED AREA= THE LOW WATER MARK.        *
*                   UPDATE THE TCTMINC  AS THE DIFFERENCE BETWEEN     *
*                   THE LOW AND HIGH MARKS BECOMES SMALLER.           *
*                                                                     *
.NOSMF   ANOP
*                                                                     *
* ENTRY POINTS:                                                       *
*            IGC010- R-TYPE GETMAIN AND FREEMAIN ENTRY POINT.         *
*                    GIVEN CONTROL BY SVC FIRST LEVEL INTERRUPT       *
*                    HANDLER (FLIH) VIA LPSW IN ORDER TO PERFORM      *
*                    THE GETMAIN OR FREEMAIN FUNCTION REQUESTED       *
*                    BY THE CALLER. AN SVC 10 IS ISSUED BY THE        *
*                    CALLER.                                          *
*                                                                     *
*            IGC004- S-TYPE GETMAIN ENTRY POINT. GIVEN CONTROL BY     *
*                    SVC FLIH VIA LPSW IN ORDER TO PERFORM THE        *
*                    GETMAIN FUNCTION REQUESTED BY THE CALLER. AN     *
*                    SVC 4 IS ISSUED BY THE CALLER.                   *
*                                                                     *
*            IGC005- S-TYPE FREEMAIN ENTRY POINT. GIVEN CONTROL BY    *
*                    SVC FLIH VIA LPSW IN ORDER TO PERFORM THE        *
*                    FREEMAIN FUNCTION REQUESTED BY THE CALLER. AN    *
*                    SVC 5 IS ISSUED BY THE CALLER.                   *
*                                                                     *
* INPUT:                                                              *
*            REGISTERS 0 AND 1, DEPEND ON WHICH SVC WAS ISSUED.       *
*            SVC 10--REGISTER 0 CONTAINS THE NUMBER OF THE SUBPOOL    *
*            IN THE HIGH ORDER BYTE AND THE NUMBER OF BYTES REQUESTED *
*            IN THE LOW ORDER THREE BYTES. REGISTER 1 CONTAINS A      *
*            NEGATIVE VALUE IF THE REQUEST IS FOR GETMAIN  OR         *
*            FOR FREEMAIN, THE ADDRESS OF THE AREA TO FREE.           *
*                                                                     *
*            SVC 4 AND SVC 5-REGISTER 1 CONTAINS THE ADDRESS OF THE   *
*            PARAMETER LIST AND REGISTER 0 CONTAINS THE CONTENTS AT   *
*            THE TIME THE SVC WAS ISSUED.                             *
*                                                                     *
*            REGISTER 3 CONTAINS THE ADDRESS OF THE CVT.              *
*            REGISTER 4 CONTAINS THE ADDRESS OF THE TCB.              *
*            REGISTER 5 CONTAINS THE ADDRESS OF THE RB.               *
*            REGISTER 14 CONTAINS THE ADDRESS OF TYPE 1 SVC EXIT      *
*            HANDLER.                                                 *
*            REGISTERS 2,6-13,AND 15 CONTAIN THE CONTENTS AT THE      *
*            TIME THE SVC WAS ISSUED.                                 *
*                                                                     *
* OUTPUT:                                                             *
*            REGISTERS 3-5,AND 14 REMAIN UNCHANGED.                   *
*            FOR SVC 10-GETMAIN,REG 1 CONTAINS THE ADDRESS OF THE     *
*            ALLOCATED CORE.                                          *
*            FOR SVC 4  THE ADDRESS OF THE ALLOCATED CORE IS          *
*            PUT AT THE ADDRESS POINTED TO BY THE SECOND WORD         *
*            IN THE PARMLIST.                                         *
*                                                                     *
*            FOR SUCCESSFUL GETMAINS, REG15 CONTAINS RETURN CODE=0.   *
*            FOR UNSUCCESSFUL GETMAINS WHICH ARE EITHER CONDITIONAL   *
*            OR 'STEAL CORE' CONDITIONS, REG15 CONTAINS A RETURN      *
*            CODE= 4.                                                 *
*                                                                     *
* EXTERNAL REFERENCES:                                                *
*            1. ABENDSUC-LABEL IN IEAATA00 FOR STEAL CORE TESTS       *
*            2. IEACVT -CVT ADDRESS                                   *
*            3. IEA04B00- ABTERM ADDRESS                              *
*            4. IEAQMSGS- ADDR PROBLEM DETERMINATION BUFFER           *
*            5. IEEMSER- ADDR MASTER SCHEDULER RESIDENT AREA          *
*                        CONTAINING ADDRESS OF SQA BOUNDARY BOX       *
*            6. SVRBPOOL- ADDRESS OF THE 1ST SVRB IN THE STEAL        *
*                        CORE SVRB POOL.                              *
*                                                                     *
* EXITS,NORMAL: BRANCH ON REGISTER 14 TO THE TYPE 1 SVC EXIT          *
*            HANDLER.
*
* EXITS,ERROR: BRANCH TO ABTERM TO CAUSE THE ISSUING TASK TO BE
*            TERMINATED. REGISTER 0 CONTAINS THE TCB ADDR, REGISTER 1
*            THE COMPLETION CODE , REG12 THE CVT ADDRESS AND
*            REGISTER 15 THE ADDRESS OF ABTERM.                       *
*            PROBLEM DETERMINATION INFORMATION FOR EACH ABEND CODE    *
*            IS LOCATED AT THE TEMPORARY WORK BUFFER--PDBUFFER.       *
*            THE ABEND CODES ARE AS FOLLOWS:
*                   604-1  PARAMETER OUTSIDE OF USER'S CORE           *
*                   605-1                                             *
*                                                                     *
*                   604-2  INVALID FQE                                *
*                   605-2                                             *
*                   60A-2                                             *
*                                                                     *
         AIF   (NOT &ATT).NO60X3
*                   604-3  INVALID GQE                                *
*                   605-3                                             *
*                   60A-3                                             *
*                                                                     *
.NO60X3  ANOP                                                         *
*                   704    LIST TYPE REQUEST (INVALID IN MFT)         *
*                   705                                               *
*                                                                     *
*                   804-1  MAIN STORAGE NOT AVAILABLE                 *
*                   80A-1                                             *
*                                                                     *
*                   804-2  ZERO OR NEGATIVE SIZE SPECIFIED            *
*                   80A-2                                             *
*                                                                     *
*                   905-1  AREA TO FREE NOT ON DOUBLEWORD BDY         *
*                   90A-1                                             *
*                   905-2  AREA TO FREE NOT IN USER'S BBOX            *
*                   90A-2                                             *
*                   905-3  AREA TO FREE GOES BEYOND GQE               *
*                   90A-3                                             *
*                                                                     *
*                   A05    AREA TO FREE OVERLAPSE FQE                 *
*                   A0A                                               *
*                                                                     *
*                   B04    INVALID SUBPOOL ID                         *
*                   B05                                               *
*                   B0A                                               *
*                                                                     *
* TABLES/WORK AREAS:                                                  *
*            1.'DATAWORK',AT THE BEGINNING OF IEAAMS' CONSTANT AREA,  *
*              IS A WORK AREA CONTAINING SWITCHES SUCH AS:            *
*              LOW CORE GETMAIN REQUEST SWITCH                        *
         AIF   (NOT &ATT).NOGQSW
*              GQE SWITCH FOR SUBTASK REQUESTORS                      *
.NOGQSW  ANOP
         AIF   (NOT &LCS).NOLCSWT
*              LCS SWITCH FOR HIERARCHY=1 REQUEST                     *
*              DUMMY LCS SWITCH IF THE JOBSTEP DOESN'T HAVE THE       *
*              HIERARCH REQUESTED                                     *
.NOLCSWT ANOP
*              DATAWORK ALSO CONTAINS SAVE AREAS FOR THE ROUNDED      *
*              SIZE, LARGEST FQE SIZE, ETC.                           *
*              DATAWORK IS ZEROD AT ENTRY TO IGC004,IGC005,IGC010.    *
*                                                                     *
*            2.'PDBUFFER',PROBLEM DETERMINATION TEMPORARY BUFFER,     *
*              CONTAINS THE ABEND INFORMATION. PDBUFFER IS            *
*              COPIED OVER TO THE IEAQMSGS BUFFER IF AN ENTRY         *
*              BUFFER IS AVAILABLE.                                   *
*                                                                     *
* CONTROL BLOCKS REFERENCED:                                          *
*            BOUNDARY BOX                                             *
*            FQE                                                      *
         AIF   (NOT &ATT).NOGQES
*            GQE                                                      *
.NOGQES  ANOP
*            RB                                                       *
*            TCB                                                      *
         AIF   (NOT &SMF).NOTCT
*            TCT                                                      *
.NOTCT   ANOP
*                                                                     *
* ATTRIBUTES: RE-USABLE, OPERATES IN SUPERVISOR STATE,RESIDENT,       *
*            DISABLED FOR ALL MASKABLE INTERRUPTS EXCEPT MACHINE      *
*            CHECK.TYPE 1 SVC ROUTINE.                                *
*                                                                     *
* NOTES:                                                              *
*              ..... PARAMETER LIST FORMAT .....                      *
*                                                                     *
*            ************************************************         *
*            * LENGTH REQUESTED IF SINGLE AREA REQUEST OR   *         *
*            * ADDR OF LIST OF LENGHTS FOR VARIABLE REQUEST *         *
*            ************************************************         *
         AIF   (NOT &LCS).NOLCPAR
*            * HIERARCHY * ADDRESS OF AREA LIST FOR ADDRESS *         *
*            *  IDENT   * OF ALLOCATED AREA INFO            *         *
         AGO   .PARMFLG
.NOLCPAR ANOP
*            * ADDRESS OF AREA LIST FOR THE ADDRESS OF THE  *         *
*            * ALLOCATED AREA INFORMATION.                  *         *
.PARMFLG ANOP
*            ************************************************         *
*            * REQUEST  * SUBPOOL  *                        *         *
*            *  TYPE    *   ID     *                        *         *
*            ************************************************         *
*                                                                     *
*            REQUEST TYPES                                            *
*              X'00' - UNCONDITIONAL SINGLE ELEMENT REQUEST           *
*              X'20' - CONDITIONAL   SINGLE ELEMENT REQUEST           *
*              X'C0' - UNCONDITIONAL VARIABLE REQUEST                 *
*              X'E0' - CONDITIONAL   VARIABLE REQUEST                 *
*                                                                     *
*                                                                     *
*                                                                     *
*                 ..... LIST FORMATS .....                            *
*                                                                     *
*            SINGLE ELEMENT REQUEST                                   *
*                                                                     *
*              AREA LIST                                              *
*                   **********************************                *
*                   *    * ADDRESS OF AREA ALLOCATED *                *
*                   **********************************                *
*                                                                     *
*                                                                     *
*            VARIABLE REQUEST                                         *
*                                                                     *
*              LENGTH LIST                                            *
*                   **********************************                *
*                   * 0 * MINIMUM LENGTH REQUESTED   *                *
*                   **********************************                *
*                   * 0 * MAXIMUM LENGTH REQUESTED   *                *
*                   **********************************                *
*                                                                     *
*              AREA LIST                                              *
*                   **********************************                *
*                   *    * ADDRESS OF AREA ALLOCATED *                *
*                   **********************************                *
*                   *    * ACTUAL LENGTH ALLOCATED   *                *
*                   **********************************                *
*                                                                     *
***********************************************************************
         EJECT
** REGISTER EQUATES **
         SPACE 2
*REGS USED BY ALL ROUTINES *
REG0     EQU   0              PARM REG
REG1     EQU   1              PARM REG
REG3     EQU   3              CURRENTLY NOT BEING USED
REG4     EQU   4              TCB REG
REG14    EQU   14             SVC TYPE 1 EXIT ADDR
REG15    EQU   15
RETREG   EQU   2              BRANCH AND LINK REG1
RETREG2  EQU   5              BRANCH AND LINK REG2
BASEREG  EQU   12             BASE REG
BBOXREG   EQU   6              ADDR JOBSTEP BBOX
CURFQREG EQU   7 .             ADDR CURRENT FQE
LSTFQREG EQU   9 .             ADDR LAST FQE
LOWBBREG EQU   8 .             BBOX LOWEST ADDR
NXTFQREG EQU   11 .            ADDR NEXT FQE
WORKREGA EQU   10 .            WORKREG
*SPGET REGISTERS*
SPLOW    EQU   7             BBOX LOWEST ADDR
SPHI     EQU   8             BBOX HIGHEST ADDR
SPWORK2  EQU   9             WORK REG
*GETCORE REGISTERS*
GTWORK2  EQU   RETREG         WORK REG
GETADDR  EQU   13 .          ADDR ALLOCATED AREA
*FREECORE REGISTERS*
FRCURTCB EQU   7                    ADDR CURRENT TCB
FRLSTCB EQU   9
FREESIZE EQU   REG15          LENGTH OF AREA TO BE FREED
FREEADDR EQU   13
*ABEND REGISTERS*
ABWORK1  EQU   7 .           WORK REG
ABWORK2  EQU   9     WRK REG                                   @SA66514
ABPDBUF  EQU   8 .           ADDR IEAQMSGS ENTRY
ABPDEND  EQU   9 .           ADDR END FO IEAQMSGS
*SMF REGISTERS*
SMJSTCB  EQU   11       .     JOB STEP TCB                          SMF
SMTCT    EQU   9        .     TCT REG                               SMF
SMFSZ       EQU   10 .         LARGEST FQE SIZE                     SMF
SMWORK1  EQU   8        .      WORK REG                             SMF
SMFQE    EQU   7         .     ADDR FQE                             SMF
*GQESRCH REGISTERS*
GQCURTCB EQU   7        .    ADDR CURRENT TCB                       ATT
GQEREG EQU   11      .      ADDR GQE                                ATT
GQDUMBBX EQU   8        .     ADDR DUMMY BBOX                       ATT
GQWORK1  EQU   10      .     WORK REG                               ATT
GQWORK2  EQU   7             WORK REG                               ATT
GQWORK3  EQU   8              WORK REG                              ATT
         EJECT
***  SUBPOOL IDS  ***
SP128    EQU   128            VALID SUBPOOL ID
SP240    EQU   240            VALID SUBPOOL ID
SP243    EQU   243            VALID SUBPOOL ID
SP244    EQU   244            VALID SUBPOOL ID
SP245    EQU   245            VALID SUBPOOL ID
SP249    EQU   249            VALID SUBPOOL ID
SP255    EQU   255            VALID SUBPOOL ID
         SPACE 2
***  TCB DISPLACEMENTS  ***
TCBFTJST EQU   44             JOB STEP TCB DISPLACEMT
TCBMSS   EQU   24             BBOX TCB DISPLACEMT
TCBFLGS  EQU   29 .                TCBFLGS DISPLACEMT
TCBNTC   EQU   128            SISTER TCB DISPLACEMT
TCBLTC   EQU   136            DAUGHTER TCB DISPLACEMT
TCBOTC   EQU   132            MOTHER TCB DISPLACEMT
TCBTCT   EQU   164 .          DISPLACMT TIMING CONTROL TABLE IN TCB SMF
TCBTCTGF EQU   164 .          DISPLCMT OF SMF CALCULATION FLAG      SMF
SMFCALC EQU   X'80' .        IF BIT=1,GETMAIN CALCULATES SMF INFO   SMFX
                             IF BIT=0 DON'T CALCULATE JOB SCHED CORESMF
         SPACE 2
***  TCT DISPLACEMENTS  ***
TCTLWM   EQU   0 .            HIGH WATER MARK IN PROCESSOR STORAGE  SMF
TCTHWM   EQU   4 .            LOW  WATER MARK IN PROCESSOR STORAGE  SMF
TCTMINC  EQU   8 .            MINIMUM DIFF BETWEEN TCTLWM & TCTHWM  SMF
TCTCRTBL EQU   8 .            ADDR OF HOT STORAGE TABLE             SMF
         SPACE 2
***  BOUNDARY BOX DISPLACEMENTS  ***
BBLCS    EQU   0                   LCS FLAG FOR 1ST BBOY
BBFQE    EQU   0                   ADDR FIRST FQE
BBHI     EQU   8                   TOP STORAGE ADDRESS
BBLOW    EQU   4                   BOTTOM STORAGE ADDRESS
LOWADDR0 EQU    4 .              LOWEST HIER=0 ADDR
LOWADDR1 EQU    16 .               LOWEST HIER=0 ADDR
HIADDR0  EQU   8             HIGHEST HIERARCHY=0 ADDR DISPLACEMT
HIADDR1  EQU   20            HIGHEST HIERARCHY=1 ADDR DISPLACEMT    LCS
         SPACE 2
***  OTHER EQUATES  ***
FQELNGTH EQU   4             FQE LENGTH DISPLACEMT
FQEPTR   EQU   0             FQE POINTER DISPLACEMT
GQESIZE  EQU   4             GQE LENGTH DISPLACEMT                  ATT
GQEPTR   EQU   0             GQE POINTER DISPLACEMT                 ATT
GQEBBOX  EQU   0             GQEPTR IN DUMMY BBOX DISPLACEMT        ATT
SVCOPSW  EQU   32  .         BEGIN OF SVC OPSW
SVC10    EQU   X'0A' .        REGMAIN SVC
SVC5     EQU   X'05' .        FREEMAIN SVC
SVC4     EQU   X'04'          GETMAIN SVC
BUFLNG   EQU   X'20'          LENGTH OF IEAQMSGS ENTRY           A49808
RBNAME   EQU   0 .                 RB PROGRAM NAME
KEYF     EQU   X'F0'          ZERO PROTECT KEY MASK
SUPVSTAT EQU   X'01'          SUPERVISOR MASK IN PSW+8
MSBBOX   EQU   X'64' .      DISP OF SQA BBOX ADDR IN MS RESI AREA
STEALUSR EQU   X'1B0'  . DISPLCMT OF TCB IN STEAL CORE SVRB POOL
SVRB3    EQU   X'120' .  DISPLCMT 3RD SVRB IN SVRB POOL
RBSIZE   EQU   9 .           RBSIZE DISPLACEMENT
ZERO     EQU   0              DISPLACEMENT OR MASK
ONE      EQU   1              ONE
TWO      EQU   2              DISPLACEMENT OR MASK
THREE    EQU   3             DISPLACEMENT 3
FOUR     EQU   4              DISPLACEMENT OR MASK
SEVEN    EQU   7              DISPLACEMENT OR MASK
EIGHT    EQU   8              DISPLACEMENT OR MASK
ELEVEN   EQU   11 .          DISPLACEMENT OR MASK
TWELVE   EQU   12             DISPLACEMENT OR MASK
SIXTN    EQU   16      .      DISPLACEMENT OR MASK
         TITLE 'IGC010 ENTRY ROUTINE'
         ENTRY IGC004,IGC005
         ENTRY GETCORE,SPGET,FQECHECK,FREECORE,PDBUFFER
         AIF (NOT &ATT).NOGQEN
         ENTRY GQESRCH
.NOGQEN  ANOP
         AIF (NOT &SMF).NOSMFEN
         ENTRY SMFGET
.NOSMFEN ANOP
         AGO .AMS1
*/*IGC010: CHART REGMAIN SVC10 */
*/*IGC010: E IGC010 */
*/*    P  ZERO DATAWORK AREA */
*/*    D  (YES,RMGETM,NO,) GETMAIN REQUEST? */
*/*    D  (YES,%RM1,NO,) IS ADDR OF AREA TO FREE ON DBL WORD BDY*/
*/*    P  PUT 90X-1 INFO IN BUFFER*/
*/*    R  ERROR EXIT TO ABTSETUP SUBROUTINE*/
*/*%RM1:    S  SPGET:VALIDITY CK PARMS, GET BBOX */
*/*    S  FREECORE:GO TO FREE CORE */
*/*    R  GO TO TYPE 1 EXIT */
*/*RMGETM:   D (YES,,NO,RMGOVAL) IS REQUEST HIER=1 */
*/*    P  SET LCS SWITCH ON */
*/*RMGOVAL:  S  SPGET:VALIDITY CK PARMS, GET BBOX */
*/*    S  GETCORE:GO GET CORE */
*/*    D  (YES,,NO,ABNOCORE)  WAS GETCORE SUCCESSFUL */
*/*    P  RETURN CODE = 0*/
*/*    R  GO TO TYPE 1 SVC EXIT*/
*/*ABNOCORE:  D (YES,%ABSTL,NO,) IS REQUESTOR ABEND OR ABTERM*/
*/*    D  (YES,,NO,%ABTSTE) IS REQUESTOR SVC FLIH*/
*/*%ABSTL:    P  RETURN CODE=4 */
*/*    R  GO TO TYPE 1 SVC EXIT*/
*/*%ABTSTE: D (YES,,NO,AB80X1) IS SUBPOOL = 245 OR 255*/
*/*    P  (,%RMEX)  PUT E04 INFO IN BUFFER*/
*/*AB80X1: P  PUT 80X-1 INFO IN BUFFER*/
*/*%RMEX:    R  ERROR EXIT TO ABTSETUP SUBROUTINE*/
*/*IGC010:   END */
.AMS1    ANOP
*IGC010 ENTRY *
RMBEGIN  BALR  BASEREG,0           GET
         USING *,BASEREG               ADDRESSABILITY
         XC    DATAWORK(END-BEGIN),DATAWORK .ZERO WORKAREA
         ST    REG0,SAVELNGT .     SAVE LENGTH &SUBPOOL
         MVC   SAVESPID(ONE),SAVELNGT .MOVE SUBPOOL ID
         MVI   SAVELNGT,ZERO .     ZERO HI SUBPOOL BYTE
         LTR   REG1,REG1 .         IS THIS GETMAIN FORM OF REGMAIN
         SPACE 1
** FREEMAIN  FUNCTION  OF  REGMAIN  ***
         SPACE 1
         BM    RMGETM .            YES
         ST    REG15,FRSAV15 .SAVE REG15 FOR FREEMAIN CALLER
         LA    FREEADDR,ZERO(REG1) .ZERO HIGH BYTE OF ADDR TO FREEM4916
         LA    WORKREGA,SEVEN .    GET DOUBLEWORD MASK
         NR    WORKREGA,FREEADDR . IS ADDR AREA TO FREE ON DBLWORD BDY
         BNZ   AB90X1 .              NO,90X-1 ABEND
         L     FREESIZE,SAVELNGT . SET UP REG FOR FREECORE
         BAL   RETREG2,SPGET .     GO VALIDITY CHECK, GET BBOX
         BAL   RETREG2,FREECORE .  GO FREE CORE
         AIF   (NOT &LCS).RMEND
         BAL   RETREG,COMMLCS .GO RESTORE LCS FLAG                  LCS
.RMEND   ANOP
         L     REG15,FRSAV15 .RESTORE REG15 FOR FREEMAIN CALLER
         BR    REG14 .             RETURN TO SVE TYPE 1 EXIT
         SPACE 1
** GETMAIN FUNCTION OF  REGMAIN ***
         SPACE 1
RMGETM   EQU   *
         OI    SWITCHES,GETMAIN .SET GETMAIN REQUEST FLAG
         AIF   (NOT &LCS).RMGOVAL
         CL    REG1,LCSREGM .      IS REQUEST FOR HIER=1            LCS
         BNE   RMGOVAL .           NO, GO VALIDITY CHECK            LCS
         OI    SWITCHES,LCSW .     SET LCS SWITCH                   LCS
.RMGOVAL ANOP
RMGOVAL  BAL   RETREG2,SPGET .     GO VALIDITY CK, GET BBOX
         BAL   RETREG2,GETCORE .   GO GET CORE
         B     RMSUCCES .          SUCCESSFUL GETMAIN
         BNO   ABTSTE04      CORE NOT AVAILABLE                @SA66514
RMSUCCES EQU   *
         AIF   (NOT &LCS).RMEXIT
         BAL   RETREG,COMMLCS .GO RESTORE LCS FLAG                  LCS
.RMEXIT  ANOP
         LR    REG1,GETADDR .      REG1=ADDR ALLOC AREA
         SR    REG15,REG15 .      REG15=0 FOR SUCCESFUL REGMAIN
         BR    REG14 .             GO TO SVC TYPE 1 EXIT
         TITLE 'IGC004 ENTRY ROUTINE'
         AGO .AMS2
*/*IGC004: CHART GETMAIN SVC4*/
*/*IGC004:    E  IGC004   */
*/*    P  ZERO DATAWORK AREA */
*/*    D  (YES,%GM1,NO,)  IS PARM PTR ON WORD BDY*/
*/*    P   PUT 60X-1 INFO IN BUFFER*/
*/*    R  ERROR EXIT TO ABTSETUP SUBROUTINE*/
*/*%GM1:    D  (YES,,NO,GMVALCK)  IS REQUEST HIER=1 */
*/*    P  SET LCS SWITCH ON */
*/*GMVALCK:  S SPGET:VALIDITY CK PARMS, GET BBOX */
*/*    D  (YES,,NO,GMGOGET) VARIABLE REQUEST? */
*/*    P  GETMAIN LENGTH=MAXIMUM LENGTH */
*/*GMGOGET: S GETCORE:GO GET CORE*/
*/*    D  (YES,GMSUCCES,NO,) WAS GETCORE SUCCESSFUL */
*/*    D  (YES,GMCKMIN,NO,) VARIABLE REQUEST*/
*/*GMCKCOND: D (YES,,NO,ABNOCORE)  CONDITIONAL  REQUEST? */
*/*    P  RETURN CODE=4 */
*/*    R  GO TO TYPE 1 SVC EXIT */
*/*GMSUCCES: P RETURN CODE=0 */
*/*    R  GO TO TYPE 1 EXIT */
*/*GMCKMIN:  D (YES,GMCKCOND,NO,) IS MINIMUM SIZE GT LARGEST FQE */
*/*    P  (,GMGOGET)  GETMAIN LENGTH= LARGEST FQE SIZE */
*/*ABNOCORE: D (YES,%ABSTL,NO,) IS REQUESTOR ABEND OR ABTERM*/
*/*        D (YES,,NO,%ABTSTE) IS REQUESTOR SVC FLIH*/
*/*%ABSTL:        P RETURN CODE=4 */
*/*        R GO TO TYPE 1 SVC EXIT*/
*/*%ABTSTE: D (YES,,NO,AB80X1) IS SUBPOOL= 245 OR 255*/
*/*    P  (,%GMEX) PUT E04 INFO IN BUFFER*/
*/*AB80X1: P  PUT 80X-1 INFO IN BUFFER*/
*/*%GMEX:    R  ERROR EXIT TO ABTSETUP SUBROUTINE*/
*/*IGC004:   END  */
.AMS2    ANOP
         DS    0D
IGC004   EQU   *
GMBEGIN  BALR  BASEREG,0           SET UP ADDRESSABILITY
         LA    WORKREGA,GMBEGIN-RMBEGIN .AJUST
         SLR   BASEREG,WORKREGA .             ADDRESSABILITY
         USING GETDSECT,REG1       SET UP PARMLIST DSECT
         XC    DATAWORK(END-BEGIN),DATAWORK .ZERO WORKAREA
         OI    SWITCHES,GETMAIN .SET GETMAIN REQUEST FLAG
         LA    WORKREGA,THREE .    GET WORD MASK
         NR    WORKREGA,REG1 .      IS PARMLIST PTR ON WORD BDY
         BNZ   AB60X1            NO, 60X ABEND
         MVC   SAVESPID(1),GETSPID .SAVE SUBPOOL
         MVC   SAVELNGT(FOUR),GETLNGTH .SAVE LENGTH
         AIF   (NOT &LCS).GMVALCK
         CLI   GETHID,HIERAR1      IS REQUEST HIER=1                LCS
         BNE   GMVALCK             NO                               LCS
         OI    SWITCHES,LCSW       YES, SET HIER=1 SWITCH           LCS
.GMVALCK ANOP
GMVALCK  BAL   RETREG2,SPGET        GO VALIDITY CK SP , GET BBOX
         TM    GETYPE,UNCONDVA .   IS THIS A VARIABLE REQ
         BNO   GMGOGET .           NO
         TM    GETLNGTH+3,THREE .IS PTR TO DBLEWD LENGTH ON WORD BDY
         BNZ   AB60X1 .           NO,60X-1 ABEND
         L     WORKREGA,GETLNGTH .  GET PTR TO DBLEWD LENGTH
         MVC   SAVELNGT(FOUR),FOUR(WORKREGA) .SAVE MAXIMUM REQ SIZE
GMGOGET  BAL   RETREG2,GETCORE .   GO GET CORE
         B     GMSUCCES .          GETCORE SUCCESSFUL
         SPACE 2
****GETMAIN WAS UNSUCCESSFUL ****
         SPACE 1
* GETCORE= RETURN+4 FOR CORE NOT FOUND ***
         TM    GETYPE,UNCONDVA .   IS THIS VARIABLE REQ
         BO    GMCKMIN .           YES
* REQUEST CAN NOT BE SATISFIED, CHECK FOR CONDITIONAL REQUEST
GMCKCOND TM    GETYPE,CONDSE .     IS THIS A CONDITIONAL REQ
         BNO   ABTSTE04      CORE NOT AVALABLE, UNCOND REQUEST @SA66514
         LA    REG15,FOUR .        SET RETURN CODE =4
         AIF   (NOT &LCS).GMEXIT2
         BAL   RETREG,COMMLCS .GO RESTORE LCS FLAG                  LCS
.GMEXIT2 ANOP
         BR    REG14 .             GO TO SVC TYPE 1 EXIT
         SPACE 2
**** GETMAIN WAS SUCCESSFUL ****
GMSUCCES EQU   * .      ***GETMAIN WAS SUCCESSFUL ***
         L     WORKREGA,GETADD .    GET USER'S PARM ADDR
         ST    GETADDR,ZERO(WORKREGA) .GIVE USER ALLOC AREA ADDR
         AIF   (NOT &LCS).GMEXIT
         BAL   RETREG,COMMLCS .GO RESTORE LCS FLAG                  LCS
.GMEXIT  ANOP
         TM    GETYPE,UNCONDVA .   IS THIS A VARIABLE REQ
         BNO   GMEXIT              NO, GO EXIT
         MVC   FOUR(FOUR,WORKREGA),ROUNDSIZ .2ND WORD=LNGTH ALLOC
GMEXIT   SR    REG15,REG15 .       RETURN CODE=0
         BR    REG14 .             GO TO SVC TYPE 1 EXIT
         SPACE 2
GMCKMIN  L     WORKREGA,GETLNGTH .  GET PTR TO DBLEWD LENGTH
         L     WORKREGA,ZERO(WORKREGA) .GET MINIMUM LENGTH
         CL    WORKREGA,LARFQSIZ .  IS MINIMUM GT LARGEST FQE
         BH    GMCKCOND .          YES, GETCORE UNSUCCESSFUL
         AIF   (NOT &ATT).GMVC
         TM    SWITCHES,GQESW .          IS THIS A GQE        AC A61243
         BZ    GMMVC .                   NO ,BYPASS SIZE ADJ  AC A61243
         L     WORKREGA,LARFQSIZ  .      YES,GET FQE SIZE     AC A61243
         SH    WORKREGA,EIGHTDC .        REDUCE SIZE BY 8     AC A61243
         ST    WORKREGA,LARFQSIZ .       SAVE NEW SIZE        AC A61243
.GMVC    ANOP
GMMVC    EQU   * .                                            AC A61243
         MVC   SAVELNGT(FOUR),LARFQSIZ .GIVE USER LARGEST FQE
         B     GMGOGET .           GO GET CORE
         TITLE                'IGC005 ENTRY ROUTINE'
         AGO .AMS3
*/*IGC005: CHART FREEMAIN SVC5*/
*/*IGC005:  E  IGC005*/
*/*    P  ZERO DATAWORK AREA */
*/*    D  (YES,%FM1,NO,) IS PARM PTR ON WORD BOUNDARY */
*/*    P    PUT 60X-1 INFO IN BUFFER*/
*/*    R  ERROR EXIT TO ABTSETUP SUBROUTINE*/
*/*%FM1:    D (YES,%FM2,NO,) IS ADDR OF AREA TO FREE ON DBL WORD BDY*/
*/*    P PUT 90X-1 INFO IN BUFFER*/
*/*    R  ERROR EXIT TO ABTSETUP SUBROUTINE*/
*/*%FM2:     S  SPGET:GO VALIDITY CHECK PARMS, GET BBOX */
*/*    S  FREECORE:GO FREE CORE */
*/*    R  GO TO SVC TYPE 1 EXIT */
*/*IGC005: END*/
.AMS3    ANOP
         DS    0D
IGC005   EQU   *
FMBEGIN  BALR  BASEREG,0 .         SET UP ADDRESSABILITY
         LA    WORKREGA,FMBEGIN-RMBEGIN .ADJUST
         SLR   BASEREG,WORKREGA .               ADDRESSABILITY
         USING GETDSECT,REG1 .     SET UP PARMLIST DSECT
         ST    REG15,FRSAV15 .SAVE REG15 FOR FREEMAIN CALLER
         XC    DATAWORK(END-BEGIN),DATAWORK .ZERO WORKAREA
         LA    WORKREGA,THREE .    GET WORD MASK
         NR    WORKREGA,REG1 .      IS PARMLIST PTR ON WORD BDY
         BNZ   AB60X1            NO, 60X ABEND
         MVC   SAVESPID(ONE),GETSPID .PUT SUBPOOL IN WORK AREA
         TM    GETADD+3,THREE .   IS PTR TO ADDR TO FREE ON WORD BDY
         BNZ   AB60X1 .           NO,60X-1 ABEND
         L     WORKREGA,GETADD .   GET PTR TO ADDR OF AREA TO FREE
         TM    THREE(WORKREGA),SEVEN .IS ADDR AREA TO FREE DBLWORD BDY
         BNZ   AB90X1 .             NO,90X-1 ABEND
         L     FREEADDR,ZERO(WORKREGA) .GET ADDR TO FREE
         LA    FREEADDR,ZERO(FREEADDR) .CLEAR HI BYTE
         TM    GETYPE,UNCONDVA .  IS THIS A VARIABLE FREEMAIN
         BNO   FMSINELE .         NO SINGLE ELEMENT REQ
         L     FREESIZE,FOUR(WORKREGA) .GET LENGTH TO FREE
         B     FMGOVAL .          GO VALIDITY CHECK
FMSINELE L     FREESIZE,GETLNGTH . GET LENGTH TO FREE
FMGOVAL  BAL   RETREG2,SPGET .     GO VALIDITY CHECK PARMS,GET BBOX
         BAL   RETREG2,FREECORE .  GO ADJUST FQE'S
         AIF   (NOT &LCS).FMEND
         BAL   RETREG,COMMLCS .GO RESTORE LCS FLAG                  LCS
.FMEND  ANOP
         L     REG15,FRSAV15 .RESTORE REG15 FOR FREEMAIN CALLER
         BR    REG14 .             RETURN TO SVC TYPE 1 EXIT
         SPACE 3
         AIF   (NOT &LCS).COMZEND
*** THIS CODE RESTORES THE LCS FLAGS IN THE BOUNDARY BOX WHICH      LCS
*** SPGET ZEROED OUT FOR FQE PROCESSING.                            LCS
COMMLCS  EQU   *                                                    LCS
         TM    SWITCHES,SQSREQ .IS REQUEST FOR SUBPOOL 245,255    M4914
         BCR   ONE,RETREG .     YES,NO LCS FLAG, RETURN           M4914
         AIF   (NOT &ATT).COMNOAT
         L     BBOXREG,TCBFTJST(REG4) .GET JOBSTEP TCB              ATT
         L     BBOXREG,TCBMSS(BBOXREG) .GET JOBSTEP BBOX            ATT
         AGO   .COMLCS
.COMNOAT ANOP
         L     BBOXREG,TCBMSS(REG4) .GET BBOX                       LCS
.COMLCS  ANOP
         MVC   BBLCS(ONE,BBOXREG),LCSFLGSV .RESTORE FLAG            LCS
         BR    RETREG .RETURN TO PROLOGUE                           LCS
.COMZEND ANOP
         TITLE 'GETCORE SUBROUTINE'
        AGO .AMS4
*/*GETCORE: CHART */
*/*GETCORE: E  ENTRY */
*/*    P  ROUND SIZE TO DOUBLEWORD */
*/*    D  (YES,%GT,NO,)  IS SIZE POSITIVE */
*/*    P    PUT 80X-2 INFO IN BUFFER*/
*/*    R  ERROR EXIT TO ABTSETUP SUBROUTINE*/
*/*%GT:    D  (YES,,NO,%GTINIT) IS GQE SWITCH ON */
*/*    P  INCREMENT SIZE BY 8 FOR GQE */
*/*%GTINIT:    P  GET ADDR 1ST FQE IN BBOX */
*/*    P  GET TOP & BOTTOM OF PARTITION */
*/*    D  (YES,,NO,GTCKFQE) IS 1ST FQE=0 */
*/*    R  RETURN NOT FOUND */
*/*GTCKFQE: S  FQECHECK:GO VALIDITY CHECK FQE */
*/*    D  (YES,,NO,GTCKSIZ) IS THIS THE LARGEST FQE */
*/*    P  SAVE LARGEST FQE SIZE */
*/*GTCKSIZ: D  (YES,,NO,GTNEXTFQ) DOES FQE SATISY REQUEST? */
*/*    D  (YES,GTFNDFQE,NO,) IS THIS A HIGH CORE REQUEST? */
*/*    P  SAVE LAST,CURR FQE ADDRESSES */
*/*GTNEXTFQ: P  GET NEXT FQE */
*/*    D  (YES,GTCKFQE,NO,) ANY MORE FQES? */
*/*    D  (YES,,NO,%GT1) IS THIS HIGH CORE REQUEST */
*/*    R  RETURN NOT FOUND  */
*/*%GT1: P  RESTORE CURRENT,LAST FQE ADDRESSES */
*/*    D  (YES,GTFNDFQE,NO,) WAS FQE FOUND TO SATISFY REQ */
*/*    R  RETURN NOT FOUND */
*/*GTFNDFQE: P SUBTRACT ALLOCATED AREA FROM FQE SIZE */
*/*    D  (YES,GTDROPFQ,NO,) IS NEW SIZE=0 */
*/*    D  (YES,GTLOWREQ,NO,) LOW CORE REQUEST? */
*/*    P  (,GTALLOC) STORE NEW SIZE IN FQE,ADD FQE SIZE TO ALLOC ADDR*/
*/*GTLOWREQ: P ADD REQ SIZE TO ADDR OF FQE AND STORE IN PREV FQE ADDR*/
*/*    P  (,GTALLOC) STORE NEW SIZE IN NEW FQE,
*/*                  NEW FQE PTR=ADDR NEXT FQE */
*/*GTDROPFQ: P MOVE OLD FQE PTR TO NEW FQE */
*/*GTALLOC:  D (YES,,NO,GTSMFCK) IS GQE SWITCH ON */
*/*    P  STORE GQE SIZE IN NEW GQE*/
*/*    P  GET ADDRESS OF DUMMY BBOX */
*/*    P  MOVE CURRENT GQEPTR IN DUMMY BBOX TO NEW GQE */
*/*    P  STORE NEM GQE PTR IN DUMMY BBOX*/
*/*GTSMFCK:    D   (YES,GTSMRET,NO,)  IS REQUEST FOR SQS */
*/*    S  SMFGET: GO UPDATE SMF RECORDS*/
*/*GTSMRET: R  RETURN CORE FOUND */
*/*GETCORE: END */
.AMS4    ANOP
*-----------------------------------------------------------------
* THE INPUT TO GETCORE IS THE BOUNDARY BOX ADDRESS IN REG 6.
* GETCORE SEARCHES DOWN THE FQE CHAIN, VALIDITY CHECKING ON ITS
* WAY, TO SATISFY THE GETMAIN REQUEST, UDATES THE FQE CHAIN, AND
         AIF  (NOT &ATT).NOGQESR
* BUILDS A GQE FOR A SUBTASK REQUEST,
.NOGQESR  ANOP
          AIF  (NOT &SMF).NOSMCAL
* GOES TO SMF FOR UPDATING.
.NOSMCAL ANOP
* THE OUTPUT IS THE ADDR OF THE ALLOCATED AREA  IN REG 13.
*-----------------------------------------------------------------
         SPACE 2
         DS 0F
GETCORE  EQU *
         L     WORKREGA,SAVELNGT    GET SIZE
         LA    GETADDR,SEVEN .  ROUND                            A57386
         AR    WORKREGA,GETADDR .     SIZE                       A57386
         OR    WORKREGA,GETADDR .          TO DBLEWORD           A57386
         XR    WORKREGA,GETADDR .                      BOUNDARY  A57386
         LTR   WORKREGA,WORKREGA     TEST SIZE
         BNP   AB80X2 .           FOR ZERO OR NEGATIVE SIZE ABEND
         AIF   (NOT &ATT).GTSAVSZ
         TM    SWITCHES,GQESW      IS THIS A GQE REQUEST            ATT
         BZ    GTSAVSIZ            NO                               ATT
         LA    WORKREGA,EIGHT(WORKREGA) INCREASE SIZE 8 FOR GQE     ATT
.GTSAVSZ ANOP
GTSAVSIZ EQU   *
         ST    WORKREGA,ROUNDSIZ    SAVE ROUNDED SIZE
         SPACE 2
****  SEARCH FOR AN FQE TO SATISFY THE GETMAIN REQUEST ****
         SPACE 1
* INITIALIZE REG7 WITH 1ST FQE ADDR, REG9 WITH TOP PARTITION
*            ADDRESS+1, AND REG 8 WITH BOTTOM PARTITION ADDR.
         LM    CURFQREG,LSTFQREG,BBLCS(BBOXREG)  INIT REGS FOR 1ST FQE X
                                        TOP AND BOTTOM OF PARTITION
         LA    LSTFQREG,ONE(LSTFQREG)   TOP BOUNDARY=HI ADDR+1
         LTR   CURFQREG,CURFQREG        IS 1ST FQE=0
         BZ    FOUR(RETREG2)            YES, RETURN NOT FOUND
GTCKFQE  BAL   RETREG,FQECHECK     GO VALIDITY CHECK 1ST FQE
*  WITH RETURN, THE FQE IS VALID
         CLC   LARFQSIZ(FOUR),FQELNGTH(CURFQREG) SAVE BIGGEST FQE
*  FOR A HIGH-CORE REQUEST, LARFQSIZ DOESNT TRULY REPRESENT THE  *
*  LARGEST FQE, BUT ONLY THE FIRST FQE FOUND TO SATISFY REQUEST. *
         BH    GTCKSIZ             NOT LARGER
         MVC   LARFQSIZ(FOUR),FQELNGTH(CURFQREG) SET LARGER SIZ
GTCKSIZ  CLC   FQELNGTH(FOUR,CURFQREG),ROUNDSIZ DOES FQE SATISFY REQ
         BL    GTNEXTFQ            NO
         TM    SWITCHES,LOCORESW   IS THIS A LOWCORE REQ
         BZ    GTFNDFQE            NO, FQE IS FOUND FOR HICORE
         STM   CURFQREG,LSTFQREG,LOCORSAV  SAVE CUR,LAST FQES
GTNEXTFQ LR    LSTFQREG,CURFQREG   UPDATE LAST FQE
         LR    CURFQREG,NXTFQREG   UPDATE CURRENT FQE
         LTR   CURFQREG,CURFQREG   IS THIS END OF FQES
         BNZ   GTCKFQE             NO
* END OF FQES HAS BEEN REACHED *
         TM    SWITCHES,LOCORESW   IS THIS LOCORE REQ
         BZ    FOUR(RETREG2)       NO, RETURN NOT FOUND-HI REQ
         LM    CURFQREG,LSTFQREG,LOCORSAV RESTORE CUR,LAST FQES
         LTR   CURFQREG,CURFQREG . WAS FQE FOUND TO SATISFY REQ
         BZ    FOUR(RETREG2) .  NO,RETURN NOT FOUND
         L     NXTFQREG,FQEPTR(CURFQREG) RESTORE NEXT FQE
         SPACE 2
**** AN FQE HAS BEEN FOUND TO SATISFY THE GETMAIN REQUEST ****
         SPACE 1
*  IN THE CASE OF EITHER AN EXACT FIT OR A LOW CORE REQUEST IN WHICH
*  THE 1ST FQE WILL BE ALTERED,THE PREVIOUS FQE PTR IS UPDATED TO
*  THE ADDR OF THE BOUNDARY BOX.
GTFNDFQE CL    CURFQREG,BBFQE(BBOXREG) . IS 1ST FQE BEING CHANGED
         BNE   GTNOT1ST .         NO
         LR    LSTFQREG,BBOXREG .  YES,LAST FQE PTR=ADDR BBOX
GTNOT1ST L     WORKREGA,FQELNGTH(CURFQREG) GET FQE SIZE
         S     WORKREGA,ROUNDSIZ SUBTRACT ALLOCATED AREA FROM FQE
         LTR   WORKREGA,WORKREGA     IS RESULT=0
         BZ    GTDROPFQ            YES
         TM    SWITCHES,LOCORESW   IS THIS LOWCORE REQ
         BO    GTLOWREQ            YES
         SPACE 1
* FOR A HIGH CORE REQUEST DECREMENT FQE SIZE
         ST    WORKREGA,FQELNGTH(CURFQREG) UPDATE SIZE IN CUR FQE
         A     WORKREGA,FQEPTR(LSTFQREG) GET ADDR ALLOC AREA
         B     GTALLOC
         SPACE 1
* BUILD A NEW FQE FOR LOW CORE REQUEST.
GTLOWREQ L     GTWORK2,ROUNDSIZ     GET REQ SIZE
         AR    GTWORK2,CURFQREG    ADD CURR FQE ADDR TO REQ SIZE
         ST    GTWORK2,FQEPTR(LSTFQREG) UPDATE PREVIOUS FQEPTR
         ST    NXTFQREG,FQEPTR(GTWORK2) BUILD 1ST WORD NEW FQE
         ST    WORKREGA,FQELNGTH(GTWORK2) BUILD 2ND WORD NEW FQE
         LR    WORKREGA,CURFQREG         GET ADDR ALLOC AREA
         B     GTALLOC
         SPACE 1
* FOR A PERFECT MATCH REMOVE CURRENT FQEFROM CHAIN *
GTDROPFQ ST NXTFQREG,FQEPTR(LSTFQREG)  REMOVE CURRENT FQE
         LR    WORKREGA,CURFQREG  GET ADDR ALLOC AREA
* WORKREGA NOW CONTAINS THE ADDRESS OF THE ALLOCATED CORE.
GTALLOC  LR    GETADDR,WORKREGA .  GET ADDR ALLOCATED AREA IN REG 13
         AIF   (NOT &ATT).GTSMFCK
         SPACE 2
*FOR A GQE REQUEST BUILD A GQE AND CHAIN TO DUMMY BOUNDARY BOX.
         TM    SWITCHES,GQESW      IS SUBTASK REQUESTOR             ATT
         BZ    GTSMFCK             NO ,BYPASS GQE PROCESS           ATT
* WORKREGA CONTAINS THE ADDR OF THE ALLOCATED AREA.                 ATT
         L     GTWORK2,ROUNDSIZ     GET REQ SIZE                    ATT
         ST    GTWORK2,GQESIZE(WORKREGA) PUT SIZE IN GQE            ATT
         SH    GTWORK2,EIGHTDC .SUBTRACT 8 FOR BEGIN ALLOC AREA     ATT
         ST    GTWORK2,ROUNDSIZ .UPDATE ALLOC SIZE FOR VAR REQUEST  ATT
         L     GTWORK2,TCBMSS(REG4)  GET ADDR DUMMY BBOX            ATT
         MVC   GQEPTR(FOUR,WORKREGA),GQEBBOX(GTWORK2) MOVE CURRENT  ATT*
                            GQE PTR IN DUMMY BBOX TO NEW GQE        ATT
         ST    WORKREGA,GQEBBOX(GTWORK2) STORE CUR GQE IN DUM BBOX  ATT
         LA    GETADDR,EIGHT(GETADDR) .ADD 8 TO ALLOC ADDR FOR GQE  ATT
.GTSMFCK ANOP
GTSMFCK  EQU   *
         AIF   (NOT &SMF).GTENDGT
         SPACE 2
         TM   SWITCHES,SQSREQ  IS REQUEST FOR SUBPOOL 245,255     M4914
         BCR  ONE,RETREG2      YES, BYPASS SMF CALCULATIONS       M4914
* GO CALCULATE SMF INFORMATION                                      SMF
         BAL   RETREG,SMFGET       GO UPDATE SMF RECORDS            SMF
.GTENDGT ANOP
         BR    RETREG2             RETURN TO CALLER,CORE FOUND
         TITLE 'SPGET SUBROUTINE'
         AGO .AMS5
*/*SPGET: CHART */
*/*SPGET: E ENTRY */
*/*    D  (YES,SPCKSPVR,NO,) IS THIS SVC 10*/
*/*SPCKLST:    D  (NO,SPCKSPVR,YES,) LIST REQUEST */
*/*    P  (,ABTERM)  PUT 70X INFO IN BUFFER*/
*/*SPCKSPVR: D (YES,SPSPVR,NO,) IS REQUESTOR KEY=0 OR SUPV STATE*/
*/*SPROBPGM:    D  (YES,%SP,NO,) SUBPOOL < 128 */
*/*ABB0X:    P  (,ABTERM)  PUT B0X INFO IN BUFFER*/
*/*%SP:    D  (YES,SPJSTCB,NO,) SVC 10 */
*/*    D  (YES,,NO,AB60X1) 2ND WORD IN PARMLIST ON WORD BDY */
*/*    D  (YES,SPJSTCB,NO,AB60X1)
*/*            ARE PARMPTR & 2ND WORD IN HIER 0 OR 1 */
*/*SPSPVR: D (YES,,NO,SPNOTSQA) IS REQUEST FOR SQS */
*/*    P  GET ADDR SQS BBOX FROM MASTER SCHED DATA AREA */
*/*    R  RETURN */
*/*SPNOTSQA: D  (YES,%SPGQ,NO,) IS THIS FREEMAIN*/
*/*     D (YES,SPCKLOWR,NO,) IS REQ JOBSTEP */
*/*SPTST240: D (YES,SPJSTCB,NO,) IS REQ FOR SUBPOOL 240*/
*/*%SPGQ:    P  SET GQE SWITCH ON */
*/*SPCKLOWR: D  (YES,,NO,SPGT127) IS SUBPOOL < 128 */
*/*    D  (YES,,NO,SPSTEAL) IS REQUESTOR IN SUPV STATE*/
*/*    P  (,SPJSTCB) SET LOWCORE SWITCH */
*/*SPGT127: D  (YES,SPJSTCB,NO,)  IS SUBPOOL = 249-254 */
*/*         D  (YES,SPJSTCB,NO,)  IS SUBPOOL = 243-244 */
*/*         D  (YES,SPJSTCB,NO,)  IS SUBPOOL = 240*/
*/*         D  (YES,,NO,ABB0X)  IS SUBPOOL=128 */
*/*SPJSTCB: P  GET JOBSTEP HIERARCHY=0 BBOX ADDR */
*/*    D  (YES,SPFREEM,NO,) FREEMAIN */
*/*SPGETM:  D  (YES,SPTSTH1,NO,) IS LCS SWITCH ON */
*/*    D  (YES,,NO,%SP1) ANY HIERARCHY=0 */
*/*R  RETURN */
*/*%SP1:     P  (,SPGETH1) SET DUMMY HIERARCHY SWITCH ON */
*/*SPTSTH1: D  (YES,SPGETH1,NO,)  ANY HIERARCHY=1  */
*/*    P   SET DUMMY HIERARCHY SWITCH ON */
*/*    R  RETURN */
*/*SPGETH1:  P GET ADDR 2ND BBOX */
*/*    R  RETURN */
*/*SPFREEM:  D (YES,,NO,SPSTEAL)
*/*            IS ADDR AREA TO FREE HIER=0 OR HIER=1*/
*/*    R  RETURN */
*/*SPSTEAL: D  (YES,,NO,AB90X2) IS REQ IN SUPV STATE, KEY=0*/
*/*         D (YES,,NO,AB90X2) IS REQ TCB = STEALCORE TCB*/
*/*         D  (YES,,NO,AB90X2) IS AREA TO FREE A SVRB IN SVRB POOL*/
*/*        P  FREE SVRB BY ZEROING SVRB SIZE BYTE*/
*/*         R  GO TO SVC TYPE 1 EXIT*/
*/*AB90X2: P  (,ABTERM) PUT 90X-2 INFO IN BUFFER*/
*/*AB60X1: P   PUT 60X-1 INFO IN BUFFER*/
*/*ABTERM: R  ERROR EXIT TO ABTSETUP SUBROUTINE*/
*/*SPGET: END*/
.AMS5    ANOP
*--------------------------------------------------------------------
* SPGET IS A SUBROUTINE WHICH CHECKS THE SUBPOOL NUMBER AND GETS      *
*       THE ADDRESS OF THE BOUNDARY BOX. INPUT IS THE SUBPOOL AT      *
*       SAVESPID, AND TCB IN REG4, FOR FREEMAIN THE ADDR OF THE
*       AREA TO FREE IN REG 13,SIZE TO FREE IN REG15 .
*       OUTPUT IS THE ADDR OF THE BOUNDARY BOX IN REG 6.
*--------------------------------------------------------------------
        SPACE 3
        DS 0F
SPGET    EQU *
         CLI   SVCOPSW+3,SVC10 .IS THIS REGMAIN
         BE    SPCKSPVR .         YES
SPCKLST  CLI   GETYPE,CONDLST .   IS THIS A LIST REQUEST
          BE   ABEND70X .         YES,GO ABEND
         CLI   GETYPE,UNCONDLS .  IS THIS A LIST REQUEST
         BE    ABEND70X .         YES,GO ABEND
SPCKSPVR TM    SVCOPSW+1,KEYF  .IS REQUESTOR KEY=0
         BZ    SPSPVR  .           YES, GO CHECK SUPERVISOR REQ
         TM    SVCOPSW+1,SUPVSTAT .IS REQUESTOR IN SUPV STATE
         BZ    SPSPVR .      YES,GO CHECK SUPV REQ
SPROBPGM CLI    SAVESPID,SP128 .    IS SUBPOOL VALID FOR P/P
         BNL   ABB0X .           NO, B0X ABEND
         SPACE 3
* VALIDITY CHECK PARMS FROM P/P SVC4,SVC5
         CLI   SVCOPSW+3,SVC10 .   IS THIS REGMAIN
         BE     SPJSTCB             YES,GO GET BBOX
         TM    GETADD+3,THREE .    IS 2ND WORD PARMLIST ON WORD
         BNZ   AB60X1            NO
         L     WORKREGA,GETADD .    GET 2ND WORD IN PARMLIST
         LA    WORKREGA,ZERO(WORKREGA) .CLEAR HIGH BYTE FOR HIER
        AIF   (NOT &ATT).SPNOATT
         L     BBOXREG,TCBFTJST(REG4) .GET JOBSTEP TCB              ATT
         L      BBOXREG,TCBMSS(BBOXREG) .GET BBOX                   ATT
        AGO   .SPCONT
.SPNOATT ANOP
         L     BBOXREG,TCBMSS(REG4) .GET BBOX
.SPCONT  ANOP
         LA    SPWORK2,TWO .      INIT BCT COUNT LOOP
* CHECK FIRST IF PARM PTR IN VALID BOUNDARIES AND THEN 2ND PARM WORD
SPBDYCK EQU   *
         LM    SPLOW,SPHI,LOWADDR0(BBOXREG) .GET HIER=0 LOW AND HI
         BAL   RETREG,SPCKPARM .   GO CHECK HIER 0 PARMS
         AIF   (NOT &LCS).SPCKH0
         B     SPTSTNXT .         PARM FOUND                        LCS
         LM    SPLOW,SPHI,LOWADDR1(BBOXREG) .GET HIER=1 LOW AND HI  LCS
         BAL   RETREG,SPCKPARM .   GO CHECK HIER=1 PARMS            LCS
.SPCKH0  ANOP
         B     SPTSTNXT .         PARM FOUND
         B     AB60X1 .         PARM NOT FOUND
SPTSTNXT LR    WORKREGA,REG1         . GET PTR TO PARM LIST
         LA    WORKREGA,ZERO(WORKREGA) .ZERO HIGH BYTE
         BCT   SPWORK2,SPBDYCK .  GO CHECK NEXT PARM
         LA    WORKREGA,TWELVE(WORKREGA) .GET END PARMLIST
         CLR   WORKREGA,SPHI .     IS END GT HIGHEST
         BH    AB60X1 .         YES
         B     SPJSTCB .            GO CHECK IF FREE OR GET
* END OF PROBLEM PGM STATE SPECIAL VALIDITY CHECKING ***
         SPACE 2
* THIS SUBROUTINE VALIDITY CHECKS TO INSURE THAT THE PARM PASSED
* IS WITHIN THE BOUNDARIES PASSED.BRANCH ON RETREG IF FOUND
* BRANCH ON RETREG+4 IF NOT FOUND.*
SPCKPARM LTR   SPHI,SPHI .         ANY HIER CORE
         BZ     FOUR(RETREG) .    NO,RETURN NOT FOUND
         CLR   WORKREGA,SPHI .     IS PARM LT HIGHEST
         BNL   FOUR(RETREG) .     NO,RETURN NOT FOUND
         CLR   WORKREGA,SPLOW .     IS   PARM GT LOWEST
         BL    FOUR(RETREG) .     NO,RETURN NOT FOUND
         BR    RETREG .
         SPACE 2
*  VALIDITY CHECKING FOR SUPERVISOR  STATE---CHECK SUBPOOL ID  *
SPSPVR   EQU   *
         CLI   SAVESPID,SP255 .     IS REQUEST FOR SQA
         BE    SPSQA               YES
         CLI   SAVESPID,SP245 .     IS REQUEST FOR SQA
         BNE   SPNOTSQA .
SPSQA    L     BBOXREG,VCMSER
         LA    BBOXREG,MSBBOX(BBOXREG) .GET ADDR SQA BBOX
         OI   SWITCHES,SQSREQ  SET SWITCH FOR SQS REQUEST         M4914
         BR    RETREG2 .      RETURN TO PROLOGUE
SPNOTSQA EQU   *
         AIF   (NOT &ATT).SPCKLOW
         TM    SWITCHES,GETMAIN .IS THIS GETMAIN                    ATT
         BNO   SPGQSWON .  NO GO TO GQESEARCH FOR ALL FREEMAINS     ATT
         CL    REG4,TCBFTJST(REG4) .IS REQUESTOR JOBSTEP            ATT
         BE    SPCKLOWR .          YES                              ATT
SPTST240 CLI   SAVESPID,SP240 .     IS REQUESTOR SUBPOOL 240        ATT
         BE    SPJSTCB .          YES                               ATT
SPGQSWON OI    SWITCHES,GQESW .    SET GQE FLAG,REQ=SUPV SUBTASK    ATT
.SPCKLOW ANOP
SPCKLOWR CLI   SAVESPID,SP128 .     IS SUBPOOL LT 128
         BNL   SPGT127             NO, GO VALIDITY CHECK 128-254
         TM    SVCOPSW+1,SUPVSTAT .IS REQUESTOR IN SUPV STATE
         BNZ   SPJSTCB .NO,HIGH CORE REQUEST
         OI    SWITCHES,LOCORESW . YES, LOW CORE REQUEST SW SET
         B     SPJSTCB             GO GET BBOX
SPGT127  EQU   *    REMAINING VALID SUBPOOLS ARE 249-254,243-244,128
         CLI   SAVESPID,SP249 .     IS SUBPOOL 249-254
         BNL   SPJSTCB .           YES
         CLI   SAVESPID,SP244 .     IS SUBPOOL= 244
         BE    SPJSTCB .           YES
         CLI   SAVESPID,SP243 .     IS SUBPOOL= 243
         BE    SPJSTCB .           YES
         CLI   SAVESPID,SP240 .   IS SUBPOOL=240
         BE    SPJSTCB .          YES
         CLI   SAVESPID,SP128 .  IS SUBPOOL=128
         BNE   ABB0X .         NO INVALID SUBPOOL
* END OF SUPERVISOR STATE SPECIAL VALIDITY CHECKING **
         SPACE 2
SPJSTCB  EQU   *
         AIF   (NOT &ATT).SPRQTCB
         L     BBOXREG,TCBFTJST(REG4) .  GET JOBSTEP TCB            ATT
         L     BBOXREG,TCBMSS(BBOXREG) .  GET JOBSTEP'S BBOX        ATT
         AGO   .SPCKLCS
.SPRQTCB ANOP
         L     BBOXREG,TCBMSS(REG4) .    GET TCB'S BBOX
.SPCKLCS  ANOP
         AIF   (NOT &LCS).SPCKFG
         MVC   LCSFLGSV(ONE),BBLCS(BBOXREG) .SAVE LCS FLAG          LCS
         MVI   BBLCS(BBOXREG),ZERO .ZERO LCS FLAG                   LCS
.SPCKFG  ANOP
         TM   SWITCHES,GETMAIN . IS THIS GETMAIN
         BNO   SPFREEM .      NO
         SPACE 3
SPGETM   EQU   *  FOR GETMAIN REQUESTS GET ADDR OF BBOX IN BBOXREG-REG.
         AIF   (NOT &LCS).SPNOLCS
* WITH LCS, IF THE REQUESTED HIERARCHY DOESN'T EXIST, SET DUMHIER SWLCS
* AND GET OTHER HIER BBOX. OTHERWISE GET BBOX REQUESTED AND RETURN. LCS
         TM    SWITCHES,LCSW       REQUEST FOR HIER=1               LCS
         BO    SPTSTH1             YES                              LCS
         NC    HIADDR0(FOUR,BBOXREG),HIADDR0(BBOXREG) ANY HIER=0    LCS
         BCR   SEVEN,RETREG2       YES, RETURN, 1ST BBOX IN BBOXREG LCS
         OI    SWITCHES,DUMHIER    NO,SET DUMMY HIER SWITCH         LCS
         B     SPGETH1             GO GET 2ND BBOX                  LCS
SPTSTH1  NC    HIADDR1(FOUR,BBOXREG),HIADDR1(BBOXREG) ANY HIER=1    LCS
         BNZ   SPGETH1             YES                              LCS
         OI    SWITCHES,DUMHIER    NO, SET DUMMY HIER SWITCH        LCS
         BR    RETREG2             RETURN ADDR 1ST BBOX IN REGA     LCS
SPGETH1  LA    BBOXREG,TWELVE(BBOXREG) GET ADDR SECOND BBOX         LCS
.SPNOLCS   ANOP
         BR    RETREG2             RETURN,   BBOX IN REGA
         SPACE 2
SPFREEM  EQU   *   INSURE THAT THE AREA TO FREE BEGINS IN BBOX .
         LR    WORKREGA,FREEADDR . SET UP FOR SPCKPARM
         LM    SPLOW,SPHI,LOWADDR0(BBOXREG) . GET HIER=0 LOW,HI
         BAL   RETREG,SPCKPARM .  GO CHECK IF FREEADDR IS IN HIER=0
         B     ZERO(RETREG2) .     YES,RETURN WITH HIER0BBOX
         AIF   (NOT &LCS).SPFRH0
*  FREEAREA NOT IN HIER=0,TRY HIER=1                                LCS
         LM    SPLOW,SPHI,LOWADDR1(BBOXREG) . GET HIER=1 LOW,HI     LCS
         BAL   RETREG,SPCKPARM .  GO CHECK IF FREEADDR IS IN HIER=1 LCS
         B     SPGETH1 .          YES,GO GET HIER=1BBOX             LCS
         MVC   BBLCS(ONE,BBOXREG),LCSFLGSV .RESTORE FLAG            LCS
.SPFRH0  ANOP
         SPACE 5
SPSTEAL  EQU *
***  THE FOLLOWING CODE WILL COVER THE STEAL CORE CONDITION
***  IN WHICH EXIT WANTS TO FREE THE SVRB. THE SVRB IS FREED
***  BY ZEROING THE SVRBSIZE BYTE.
         TM    SVCOPSW+1,SUPVSTAT+KEYF .IS REQ KEY0 AND SUPV STATE
         BNZ   AB90X2 .           NO
         L     WORKREGA,VCSVRBS . GET ADDR STEAL CORE POOL
         CL    REG4,STEALUSR(WORKREGA) .IS REQUESTOR THE STEALOR
         BNE   AB90X2 .           NO
         CLR   FREEADDR,WORKREGA .IS AREA TO FREE LT 1ST SVRB
         BL    AB90X2 .           NO
         LA    WORKREGA,SVRB3(WORKREGA) .GET ADDR LAST SVRB
         CLR   FREEADDR,WORKREGA .IS AREA TO FREE GT 3RD SVRB
         BH    AB90X2 .                  NO
         MVI   RBSIZE(FREEADDR),ZERO .FREE THE SVRB
         L     REG15,FRSAV15 .     RESTORE USER'S REG 15
         BR    REG14 .            GO TO SVC TYPE 1 EXIT
         TITLE 'FQECHECK SUBROUTINE'
         AGO .AMS6
*/*FQECHECK: CHART  FQE VALIDITY CHECK ROUTINE */
*/*FQECHECK: E ENTRY */
*/*    D  (YES,,NO,FQEBAD) IS SIZE MULTIPLE OF 8 */
*/*    D  (YES,,NO,FQEBAD) IS HIGH BYTE OF SIZE=0 */
*/*    P  UPPER BOUND= SIZE OF FQE + ADDR FQE */
*/*    D  (YES,FQEBAD,NO,) IS UPPER BOUND GT OR EQ LAST FQE */
*/*    D  (YES,,NO,FQEBAD) IS FQE PTR ON DOUBLE WORD*/
*/*    D  (YES,,NO,FQEBAD) IS HIGH BYTE OF FQEPTR =0*/
*/*    D  (YES,,NO,FQEBAD) IS FQEPTR LT ADDR FQE */
*/*    D  (YES,,NO,%FQ1) IS FQEPTR LT BOTTOM OF BBOX*/
*/*    D  (YES,,NO,FQEBAD) IS FQEPTR = 0 */
*/*%FQ1: R  RETURN */
*/*FQEBAD: P ZERO FQEPTR IN PREVIOUS FQE TO TERMINATE CHAIN*/
*/*        P  PUT 60X-2 INFO IN BUFFER*/
*/*    R  ERROR EXIT TO ABTSETUP SUBROUTINE*/
*/*FQECHECK: END*/
.AMS6    ANOP
*---------------------------------------------------------------------
* FQECHECK  IS A SUBROUTINE WHICH VALIDITY CHECKS THE FQES. THE  *
*           INPUT IS: FQE TO CHECK IN REG7,THE PREVIOUS FQE    *
*           IN REG9 AND THE LOWEST VALID ADDR IN REG8.      *
*           OUTPUT IS: ADDR OF NEXT FQE IN CHAIN IN REG 11.
*---------------------------------------------------------------------
         SPACE 3
         DS 0F
FQECHECK EQU   *
         CLI   FQELNGTH(CURFQREG),ZERO IS HIGH BYTE OF SIZE=0
         BNE   FQEBAD              NO, ERROR
         TM    FQELNGTH+3(CURFQREG),SEVEN .IS SIZE MULT OF 8
         BNZ   FQEBAD .           NO, BAD FQE
*    CHECK  IF SIZE  IS =0
         NC    FQELNGTH+1(THREE,CURFQREG),FQELNGTH+1(CURFQREG)
         BZ    FQEBAD .           NO SIZE=0
         LR    WORKREGA,CURFQREG       SAVE FQE ADDR
         A     WORKREGA,FQELNGTH(WORKREGA) GET UPPER BOUND
         CR    WORKREGA,LSTFQREG       IS UPPERBND GT OR EQ LASTFQE
         BNL   FQEBAD              YES, ERROR
         TM    FQEPTR+3(CURFQREG),SEVEN IS FQE ON DOUBLEWORD
         BNZ   FQEBAD              NO, ERROR
         CLI   FQEPTR(CURFQREG),ZERO IS HI BYTE OF FQEPTR=0
         BNE   FQEBAD              NO
         L     NXTFQREG,FQEPTR(CURFQREG)  GET NEXT FQE
         CR    NXTFQREG,CURFQREG   IS NEXT FQE LESS THAN CURRENT
         BNL   FQEBAD              NO, ERROR
         CR    NXTFQREG,LOWBBREG    IS NEXT FQE LESS OR EQ TO LOW BBOX
         BCR   10,RETREG          NO, RETURN
         LTR   NXTFQREG,NXTFQREG   IS NEXT FQE=0
         BCR   EIGHT,RETREG        YES, RETURN
         SPACE 3
FQEBAD   EQU   *
         CL    CURFQREG,BBFQE(BBOXREG) .IS 1ST FQE BAD
         BNE   FQZERPTR .        NO
         LR    LSTFQREG,BBOXREG .  SET LAST TO BBOX
FQZERPTR XC    FQEPTR(FOUR,LSTFQREG),FQEPTR(LSTFQREG)  ZERO FORWARD    *
                                   PTR IN LAST RQE TO END BAD CHAIN
         B     AB60X2
         TITLE 'FREECORE SUBROUTINE'
         AGO .AMS7
*/*FREECORE: CHART */
*/*FREECORE: E ENTRY */
*/*    P  ROUND SIZE TO DOUBLEWORD*/
*/*    D  (YES,,NO,%FR1) IS SIZE TO FREE = 0 */
*/*    R  RETURN */
*/*%FR1: D   (YES,FRGQETST,NO,) IS GQE SWITCH ON */
*/*FRCKSIZ:    D  (YES,,NO,%FR2) IS SIZE=0 AFTER GQESEARCH*/
*/*    R  RETURN */
*/*%FR2: P GET TOP OF PARTITION & ADDR 1ST FQE */
*/*    D  (YES,FR1STNEW,NO,)  IS ALL CORE ALLOC (1ST FQE=0)*/
*/*    S  FQECHECK:VALIDITY CHECK 1ST FQE */
*/*    D  (YES,,NO,FRNEXTFQ) IS ADDR OF AREA TO FREE GT 1ST FQE */
*/*    D  (>,ABA0X,=,FRUP1SIZ,<,)
*/*            COMPARE END OF FQE WITH ADDR TO FREE */
*/*FR1STNEW: P NEW FQEPTR= ADDR CURRENT FQE, NEW FQESIZE= SIZE OF REQ*/
*/*          P BBOX FQE = ADDR OF AREA TO FREE */
*/*    R  RETURN */
*/*ABA0X: P  PUT A0X INFO IN BUFFER*/
*/*    R  ERROR EXIT TO ABTSETUP SUBROUTINE*/
*/*FRUP1SIZ: P ADD REQUEST SIZE TO SIZE OF 1ST FQE */
*/*    R  RETURN */
*/*FRNEXTFQ: D (YES,FRNEWLOW,NO,) IS NEXT FQE  ADDR=0*/
*/*    S  FQECHECK:VALIDITY CK NEXT FQE */
*/*    D  (YES,,NO,FRNEXTFQ) IS ADDR OF AREA TO FREE GT CURRENT FQE*/
*/*    D  (>,ABA0X,=,FRADDSIZ,<,)
*/*            COMPARE END OF FQE WITH ADDR AREA TO FREE*/
*/*    P  NEW FQESIZE= SIZE OF REQUEST */
*/*    P  NEW FQEPTR= ADDR CURRENT FQE*/
*/*   P  (,FRBACKPT)    NEW FQE = CURRENT FQE */
*/*FRADDSIZ: P  ADD SIZE OF REQUEST TO SIZE OF CURRENT FQE */
*/*FRBACKPT: P (>,ABA0X,=,FRBIGFQE,<,)
*/*            COMPARE END OF NEW FQE WITH ADDR PREVIOUS FQE */
*/*    P  PREVIOUS FQE PTR= NEW FQE */
*/*    R  RETURN */
*/*FRBIGFQE: P ADD SIZE OF PREVIOUS FQE TO NEW FQE */
*/*    P  DROP PREVIOUS FQE FROM CHAIN */
*/*    R  RETURN */
*/*FRNEWLOW: P (>,ABA0X,<,FRBLDLOW,=,)
*/*            COMPARE END OF AREA TO FREE WITH CURRENT FQE*/
*/*    P LAST FQEPTR= ADDR AREA TO FREE */
*/*    P NEW FQEPTR=0 ,NEW FQESIZE= REQUEST SIZE+ CURRENT FQESIZE*/
*/*    R  RETURN */
*/*FRBLDLOW: P  NEW FQEPTR= 0, CURRENT FQEPTR= ADDR AREA TO FREE*/
*/*    P  NEW FQESIZE = REQUESTED SIZE */
*/*    R  RETURN */
*/*FRGQETST: D  (YES,%FRDAU,NO,) IS REQUESTOR = JOBSTEP*/
*/* S GQESRCH:SEARCH FOR GQE ON REQUESTOR'S TCB BBOX */
*/*    D  (YES,FRCKSIZ,NO,) WAS GQE FOUND */
*/*%FRDAU:    S  (,FRCKSIZ) GQESRCH:
*/*      SEARCH DOWN  TCBS IN TCB TREE FOR GQE */
*/*FREECORE: END*/
.AMS7    ANOP
*---------------------------------------------------------------------
* INPUT TO FREECORE IS: THE ADDR OF AREA TO BE FREED IN REG 13
*                     : THE SIZE TO FREE IN REG 15
*---------------------------------------------------------------------
         SPACE 3
         DS 0F
FREECORE EQU *
         LA    FREESIZE,SEVEN(FREESIZE) .    ROUND UP BY 7
         SRL   FREESIZE,THREE CLEAR THE ROUND
         SLL   FREESIZE,THREE .    UP BITS
          LTR    FREESIZE,FREESIZE . IS LENGTH TO BE FREED=0
          BCR    EIGHT,RETREG2 .   YES, RETURN
         AIF   (NOT &ATT).FREECO1
         SPACE 2
*** A DESIGN CHANGE WAS  MADE(APAR 56028) TO ALLOW PROBLEM PGM   A56028
*** AS WELL AS SUPERVISOR TO FREE GQES.....THUS  AVOIDING THE    A56028
*** 90A'S AND A0A'S.                                             A56028
         TM    SWITCHES,SQSREQ .    IS REQUEST FOR SQS           A56028
         BZ    FRGQETST .          NO                            A56028
FRCKSIZ  LTR   FREESIZE,FREESIZE . IS SIZE=0 AFTER GQESEARCH        ATT
         BCR   EIGHT,RETREG2 .    YES,RETURN                        ATT
.FREECO1 ANOP
         SPACE 3
**** SEARCH FOR FQES ABOVE AND BELOW ADDRESS OF AREA TO FREE
         SPACE 1
* INITIALIZE CURFQREG WITH 1ST FQE ADDR, LSTFQREG WITH TOP PARTITION
*            ADDRESS+1, AND LOWBBREG WITH BOTTOM PARTITION ADDR.
         LM    CURFQREG,LSTFQREG,BBLCS(BBOXREG) .INIT REGS FROM BBOX
         LA    LSTFQREG,ONE(LSTFQREG) .TOP BOUNDS=HIGH ADDR+1
         LA    WORKREGA,ZERO(FREESIZE,FREEADDR) . END OF FREE   SA75913
         CLR   WORKREGA,LSTFQREG  .  IS END IN FREE CORE        SA75913
         BNL   AB60X1             .  IF YES GO TO ERROR         SA75913
         LTR   CURFQREG,CURFQREG . IS ALL CORE ALLOCATED
         BZ    FR1STNEW .          YES, GO BUILD IST FQE
         BAL   RETREG,FQECHECK .   GO VALIDITY CHECK 1ST FQE
        LR    LSTFQREG,BBOXREG .  INIT LST IN CASE OF 1ST FQE CHANGED
         CLR   FREEADDR,CURFQREG . IS ADDR TO FREE GT 1ST FQE
         BL    FRNEXTFQ .          NO, GO GET NEXT FQE
         SPACE 3
***THE FQES HAVE BEEN FOUND WHICH SURROUND AREA TO FREE
         SPACE 1
* THE AREA TO BE FREE LIES BETWEEN BBOX AND 1ST FQE *
         LR    WORKREGA,CURFQREG .  GET CURRENT FQE ADDR
         A     WORKREGA,FQELNGTH(CURFQREG) .GET BEGIN ALLOC AREA
         CLR   WORKREGA,FREEADDR .  IS AREA TO FREE IN ALLOC AREA
         BH    ABA0X .            NO, AREA TO FREE IN FQE -A0A
         BE    FRUP1SIZ .          YES, FROM BEGIN OF ALLOC AREA *
* BUILD NEW FQE PTR AND CHAIN FROM BBOX *
FR1STNEW ST    CURFQREG,FQEPTR(FREEADDR) .BUILD 1ST WORD FQE
         ST    FREESIZE,FQELNGTH(FREEADDR) .     BUILD 2ND WORD
         ST    FREEADDR,BBLCS(BBOXREG) .UPDATE BBOX FQE
.FRRTN   ANOP
         BR    RETREG2 .           RETURN TO PROLOGUE
FRUP1SIZ A     FREESIZE,FQELNGTH(CURFQREG) . INCREASE 1ST FQE SIZE
         ST    FREESIZE,FQELNGTH(CURFQREG) . STORE INCREASED SIZE
         BR    RETREG2 .           RETURN TO PROLOGUE
         SPACE 1
FRNEXTFQ LTR   NXTFQREG,NXTFQREG . IS NEXT FQE ADDR=0
         BZ    FRNEWLOW .          YES
         LR    LSTFQREG,CURFQREG . UPDATE LAST FQE
         LR    CURFQREG,NXTFQREG . UPDATE CURRENT FQE
         BAL   RETREG,FQECHECK .   GO VALIDITY CHECK NEXT FQE
         CLR   FREEADDR,CURFQREG . IS ADDR TO FREE GT CURRENT FQE
         BL    FRNEXTFQ .     NO, CONTINUE FQE SCAN
         SPACE 1
* AREA TO FREE IS BETWEEN CURRENT AND PREVIOUS FQE *
         LR    WORKREGA,CURFQREG . GET CURRENT FQE
         A     WORKREGA,FQELNGTH(CURFQREG) . GET BEGIN ALLOC AREA
         CLR   WORKREGA,FREEADDR . IS AREA TO FREE IN ALLOC AREA
         BH    ABA0X .            NO, AREA TO FREE IN FREE AREA
         BE    FRADDSIZ .          YES, AREA BEGINS AFTER FQE
* BUILD NEW FQE BETWEEN CURRENT AND LAST FQES *
         ST    FREESIZE,FQELNGTH(FREEADDR) . BUILD 2ND WORD OF FQE
         ST    CURFQREG,FQEPTR(FREEADDR) . BUILD 1ST WORD OF FQE
         LR    CURFQREG,FREEADDR .
         B     FRBACKPT .
* ADD AREA TO FREE TO THE CURRENT FQE *
FRADDSIZ AR    WORKREGA,FREESIZE  .  ADD NEW FREE SPACE         SA75913
         CLR   WORKREGA,LSTFQREG  .  OVERLAP WITH PREVIOUS FQE  SA75913
         BH    ABA0X              .  IF YES, GO TO ERROR        SA75913
         A     FREESIZE,FQELNGTH(,CURFQREG) . AD INCR TO CURFQE SA75913
         ST    FREESIZE,FQELNGTH(CURFQREG) . SAVE FQE INCR SIZE
* CHECK TO SEE IF AREA TO FREE JOINS PREVIOUS FQE *
FRBACKPT LR    WORKREGA,CURFQREG .  GET CURRENT FQE FOR ADD
         A     WORKREGA,FQELNGTH(CURFQREG) .GET END OF FREED AREA
         CLR   WORKREGA,LSTFQREG .  DOES AREA TO FREE JOIN PREV FQE
         BH    ABA0X .            NO, OVERLAPS INTO PREV FQE
         BE    FRBIGFQE .          YES, MEETS EXACTLY
* AREA TO FREE DOESN'T MEET PREVIOUS FQE
         ST    CURFQREG,FQEPTR(LSTFQREG) .PREV FQEPTR= AREA FREED
         BR    RETREG2 .           RETURN TO PROLOGUE
         SPACE 1
* AREA TO FREE JOINS PREV FQE. ADD JOINED SIZE TO AREA TO BE FREED, *
* DROP PREV FQE FROM CHAIN, AND ADJUST FQEPTR IN FQE BEFORE PREVFQE *
FRBIGFQE L     WORKREGA,FQELNGTH(CURFQREG) .GET SIZE CURRENT FQE
         A     WORKREGA,FQELNGTH(LSTFQREG) .ADD SIZE PREV FQE JOIN
         ST    WORKREGA,FQELNGTH(CURFQREG) .STORE JOINED SIZE
        LR     WORKREGA,BBOXREG .   GET ADDR BBOX
FRGETNXT CL    LSTFQREG,FQEPTR(WORKREGA) . IS FORWARD PTR=DROP FQE
         BE    FRDROPFQ .          YES
         L     WORKREGA,FQEPTR(WORKREGA) .GET NEXT FQE
         B     FRGETNXT .               KEEP LOOKING FOR FQE
FRDROPFQ ST    CURFQREG,FQEPTR(WORKREGA) .DROP PREV FQE FROM CHAIN
         BR    RETREG2 .           RETURN TO PROLOGUE
         SPACE 1
FRNEWLOW EQU   *
* BUILD OR JOIN NEW FQE BELOW LAST FQE ON CHAIN ***
         LR    WORKREGA,FREESIZE . GET SIZE
        AR     WORKREGA,FREEADDR . GET END OF AREA TO FREE
         CR    WORKREGA,CURFQREG . DOES AREA TO FREE MEET CURFQE
         BL    FRBLDLOW .         NO BUILD NEW LAST FQE ON CHAIN
        BH    ABA0X .         GT, OVERLAPS INTO CUR FQE
* COMBINE NEW FQE WITH LAST FQE ON CHAIN,DROP LAST FROM CHAIN **
         ST    FREEADDR,FQEPTR(LSTFQREG) .DROP LAST FROM CHAIN
         MVC   FQEPTR(FOUR,FREEADDR),FQEPTR(CURFQREG) .1ST NEW WORD
         A     FREESIZE,FQELNGTH(CURFQREG) .NEW SIZE=CUR+NEW SIZE
         ST    FREESIZE,FQELNGTH(FREEADDR) .2ND WORD NEW FQE
        BR     RETREG2 .          RETURN TO PROLOUGE
         SPACE 1
* BUILD NEW FQE BELOW LAST FQE ON CHAIN ***
FRBLDLOW MVC   FQEPTR(FOUR,FREEADDR),FQEPTR(CURFQREG) .1ST WORD NEW
         ST    FREEADDR,FQEPTR(CURFQREG) .CHAIN CUR TO NEW
         ST    FREESIZE,FQELNGTH(FREEADDR) .2ND WORD NEW FQE
         BR    RETREG2 .          RETURN TO PROLOGUE
         AIF   (NOT &ATT).FRCOEND
         SPACE 3
**** THIS CODE LOADS REG 7 WITH THE TCB ADDR FOR GQESRCH TO USE
****IN SEARCHING DOWN THE GQE CHAIN  FOR THE GQE DESCRIBING THE
****AREA BEING FREED.
         SPACE 1
FRGQETST EQU   *                                                    ATT
         LR    FRCURTCB,REG4 .     GET REQUESTING SUBTASK           ATT
         CL    REG4,TCBFTJST(REG4) . IS REQUESTOR JOBSTEP           ATT
         BE    FRGSVCUR .        YES, SKIP CURRENT TCB SEARCH       ATT
         BAL   RETREG,GQESRCH .    GO SEE IF GQE IS FOR REQ SUBTASK ATT
         B     FRCKSIZ .          YES, GQES ADJUSTED, GO CK FQES    ATT
         L     FRCURTCB,TCBFTJST(FRCURTCB) .CURR TCB= JOBSTEP       ATT
*  BEGINNING WITH JOBSTEP'S 1ST DAUGHTER, SEARCH DOWN COMPLETE      ATT
*  FAMILY TCB TREE FOR EACH OF JOBSTEP'S DAUGHTERS FOR THE GQE      ATT
*  DESCRIBING THE AREA TO BE FREED.                                 ATT
FRGSVCUR LR    FRLSTCB,FRCURTCB .  SAVE CURRENT TCB IN LAST TCB     ATT
         L     FRCURTCB,TCBLTC(FRLSTCB) .GET DAUGHTER IN CUR TCB    ATT
FRGETDAU LTR   FRCURTCB,FRCURTCB . ANY DAUGHTERS ?                  ATT
         BNZ   FRGCKDAU .          YES. GO SEARCH DAUGHTER GQES     ATT
         L     FRCURTCB,TCBNTC(FRLSTCB) .CURR TCB=SISTER            ATT
         C     FRLSTCB,TCBFTJST(FRLSTCB) .IS THIS LAST TCB          ATT
         BE    FRCKSIZ .          YES,END TCB SEARCH                ATT
         L     FRLSTCB,TCBOTC(FRLSTCB) .LOAD MOTHER OF LAST TCB     ATT
         B     FRGETDAU .          GO GET DAUGHTER                  ATT
FRGCKDAU BAL   RETREG,GQESRCH .                                     ATT
         B     FRCKSIZ .          GQE FOUND, GO CHECK FQES          ATT
         B     FRGSVCUR .          GQE NOT FOUND, TRY AGAIN         ATT
         TITLE 'GQESRCH SUBROUTINE'
         AGO   .AMS8
*/*GQESRCH: CHART */
*/*GQESRCH: E ENTRY */
*/*    P  GET ADDR DUMMY BBOX AND ADDR 1ST FQE */
*/*%GQ:  D  (YES,%GQ1,NO,) IS HIGH BYTE GQEPTR=0*/
*/*AB60X3: P  ZERO GQE PTR IN PREVIOUS GQE TO CLEAN UP CHAIN*/
*/*     P  PUT 60X-3 INFO IN BUFFER */
*/*    R  ERROR EXIT TO ABTSETUP SUBROUTINE*/
*/*%GQ1:  D  (YES,,NO,AB60X3) IS GQEPTR ON DOUBLE WORD BDY*/
*/*    D  (YES,,NO,AB60X3) IS HIGH BYTE OF GQESIZE=0*/
*/*    D  (YES,,NO,AB60X3) IS GQESIZE A MULTIPLE OF 8 */
*/*    D  (YES,,NO,AB60X3) IS GQE IN BOUNDS OF JOBSTEP BBOX*/
*/*    D  (YES,GQCKUPBD,NO,) IS ADDR AREA TO FREE GT GQE ADDR*/
*/*GQNXTGQE: P (,GQCKLAST) GET NEXT GQE */
*/*GQCKUPBD:   D  (YES,,NO,GQNXTGQE) IS ADDR AREA TO FREE LT GQE END*/
*/*    D  (YES,AB90X3,NO,) IS ADDR TO FREE IN GQE BLOCK*/
*/*    D  (YES,AB90X3,NO,) IS END OF AREA TO FREE GT END OF GQE*/
*/*    D  (YES,,NO,GQCKPART) IS ENTIRE GQE BEING FREED*/
*/*    P  DROP GQE FROM CHAIN*/
*/*    P  ADDR AREA TO FREE=BEGIN GQE, SIZE TO FREE= SIZE+8*/
*/*    R  RETURN FOUND */
*/*GQCKPART: D (YES,,NO,GQMID) IS ADDR AREA TO FREE AT BEGIN OF GQE*/
*/*    P  ADDR AREA TO FREE= BEGIN OF GQE*/
*/*    P  BUILD NEW GQE AT END OF AREA TO FREE */
*/*    R  RETURN FOUND */
*/*GQCKLAST: D (YES,,NO,%GQ) IS THIS END OF GQES*/
*/*    R  RETURN NOT FOUND */
*/*GQMID: D  (YES,,NO,GQNEWGQ) IS END OF AREA TO FREE = END OF GQE*/
*/*    P  GQESIZE = GQESIZE - LENGTH OF AREA TO FREE */
*/*    R  RETURN FOUND*/
*/*GQNEWGQ: P   SIZE TO FREE= SIZE TO FREE-8 */
*/*    P  BUILD NEW GQE AT ADDR AREA TO FREE+ SIZE */
*/*    P  ADJUST CURRENT GQE*/
*/*    R  RETURN FOUND*/
*/*AB90X3:  P  PUT 90X-3 INFO IN BUFFER*/
*/*    R  ERROR EXIT TO ABTSETUP SUBROUTINE*/
*/*GQESRCH: END*/
.AMS8    ANOP
*---------------------------------------------------------------------
*        GQESRCH SEARCHES DOWN THE GQE CHAIN OF THE TCB PASSED IN  ATT
*        REG7.  REG 11 IS USED AS THE GQE ADDR.  IF THE GQE IS     ATT
*        FOUND,ADJUST THE GQES TO ACCOUNT FOR THE AREA FREED       ATT
*        AND RETURN+0 TO FREECORE.  IF NOT FOUND, RETURN+4.        ATT
*---------------------------------------------------------------------
         SPACE 2
         DS  0F
GQESRCH  EQU   *                                                    ATT
         L     GQDUMBBX,TCBMSS(GQCURTCB) .GET ADDR DUMMY BBOX       ATT
         L     GQEREG,GQEPTR(GQDUMBBX) .GET ADDR 1ST GQE            ATT
         LTR   GQEREG,GQEREG .IS GQE CHAIN EMPTY                    ATT
         BZ    FOUR(RETREG) .YES,RETURN NOT FOUND                   ATT
         C     GQEREG,GQEPTR(GQEREG) . GQE CHAINED TO ITSELF   @SA71329
         BE    GQEBAD .            YES                         @SA71329
         ST    GQDUMBBX,SAVEGQE .  INIT ADDR LAST GQE               ATT
         CLI   GQEPTR(GQDUMBBX),ZERO .  IS HI BYTE ADDR=0           ATT
         BNZ   GQEBAD .         NO,ERROR                            ATT
         TM    GQEPTR+3(GQDUMBBX),SEVEN . IS 1ST GQE ON DBLEWD      ATT
         BNZ   GQEBAD .        NO,ERR                               ATT
GQCKLAST LTR   GQEREG,GQEREG .     IS THIS LAST GQE                 ATT
         BZ    FOUR(RETREG) .      YES, RETURN NOT FOUND            ATT
         SPACE 2
* VALIDITY CHECK THE GQE *                                          ATT
         CLI   GQEPTR(GQEREG),ZERO . IS HI BYTE PTR=0               ATT
         BNZ   GQEBAD .         NO,ERR                              ATT
         TM    GQEPTR+3(GQEREG),SEVEN .IS GQE PTR ON DBLEWD         ATT
         BNZ   GQEBAD .         NO,ERR                              ATT
         L     GQWORK1,GQESIZE(GQEREG) .GET GQE LENGTH              ATT
         LTR   GQWORK1,GQWORK1 .   IS LENGTH ZERO              @SA71329
         BZ    GQEBAD .            YES                         @SA71329
         CLI   GQESIZE(GQEREG),ZERO . IS HI BYTE OF SIZE=0          ATT
         BNZ   GQEBAD .         NO,ERR                              ATT
         TM    GQESIZE+3(GQEREG),SEVEN . IS SIZE A MULTIPLE OF 8    ATT
         BNZ   GQEBAD .         NO,ERR                              ATT
         AR    GQWORK1,GQEREG .    GET GQE UPPER BOUNDS             ATT
         AIF   (&LCS).GQCKBTH
         CL    GQWORK1,BBHI(BBOXREG) .GQE GT HIGHEST ADDR PARTIT?   ATT
         BH    GQEBAD .          YES                                ATT
         CL    GQEREG,BBLOW(BBOXREG) .GQE LT LOWEST ADDR IN PARTIT? ATT
         BNL    GQEGOOD .          YES                              ATT
         AGO   .GQEBAD
.GQCKBTH ANOP
         L     GQWORK3,TCBFTJST(REG4) .GET  JOBSTEP TCB           M4913
         L     GQWORK3,TCBMSS(GQWORK3) .GET ADDR  BBOX            M4913
         CL    GQWORK1,HIADDR0(GQWORK3) .GQE GT HIGH ADDR HIER0?  M4913
         BH    GQCKBB2 .  YES,GO CK 2ND BBOX                      LCATT
         CL    GQEREG,LOWADDR0(GQWORK3) .GQE LT LOW ADDR HIER0?   M4913
         BNL   GQEGOOD .GQE IS HIER0 BOUNDS                       LCATT
GQCKBB2  CL    GQWORK1,HIADDR1(GQWORK3) .GQE GT HIGH ADDR HIER1?  M4913
         BH    GQEBAD .GQE IS INVALID                             LCATT
         CL    GQEREG,LOWADDR1(GQWORK3) .GQE LT LOW ADDR HIER1?   M4913
         BNL   GQEGOOD .GQE IS IN HIER1 BOUNDS                    LCATT
.GQEBAD  ANOP
* THE GQE IS INVALID.  ZERO THE GQE PTR IN THE PREVIOUS GQE TO      ATT
* END THE CHAIN AT THE LAST VALID GQE.                              ATT
GQEBAD   L     GQWORK1,SAVEGQE .GET ADDR OF PREVIOUS GQE            ATT
         XC    GQEPTR(FOUR,GQWORK1),GQEPTR(GQWORK1) .ZERO GQE PTR   ATT
         B     AB60X3 .           GO SET UP 60X3 INFO               ATT
         SPACE 2
* THE GQE HAS BEEN SUCESSFULLY VALIDITY CKECKED. *                  ATT
GQEGOOD  CLR   FREEADDR,GQEREG .  IS ADDR TO BE FREED GT GQE        ATT
         BE    GQEBAD .NO, ADDR TO FREE IS GQE BLOCK                ATT
         BH    GQCKUPBD .                                           ATT
GQNXTGQE EQU   *                                               @SA71329
         C     GQEREG,GQEPTR(GQEREG) . GQE CHAINED TO ITSELF   @SA71329
         BE    GQEBAD                                          @SA71329
         ST    GQEREG,SAVEGQE .    SAVE PREVIOUS GQE PTR       @SA71329
         L     GQEREG,GQEPTR(GQEREG) .  GET PTR TO NEXY GQE         ATT
         B     GQCKLAST .          GO CK FOR LAST GQE               ATT
* REG GQWORK1 CONTAINS GQE UPPER BOUND FROM GQE VALIDITY CHECK.     ATT
GQCKUPBD CLR   FREEADDR,GQWORK1 .  IS ADDR TO FREE LT END OF GQE    ATT
         BNL    GQNXTGQE .          NO, GO GET NEXT GQE             ATT
         LA     GQWORK2,EIGHT(GQEREG) .GET ADDR ALLOC AREA          ATT
         CLR    FREEADDR,GQWORK2 .IS ADDR TO FREE IN ALLOC AREA     ATT
         BL     AB90X3 .         NO,ADDR TO FREE IN GQE BLOCK       ATT
         LR     GQWORK2,FREEADDR .GET ADDR OF AREA TO FREE          ATT
         AR     GQWORK2,FREESIZE .GET END ADDR OF AREA TO FREE      ATT
         CLR    GQWORK2,GQWORK1 .IS END OF AREA TO FREE GT GQE END  ATT
         BH     AB90X3 .         YES TRYING TO FREE TOO MUCH        ATT
         SPACE 3
* THE GQE HAS BEEN FOUND *                                          ATT
         LA    GQWORK1,EIGHT(FREESIZE) .GET AREA TO FREE+8          ATT
         CL    GQWORK1,GQESIZE(GQEREG) .IS ENTIRE GQE FREED         ATT
         BNE   GQCKPART .          NO                               ATT
         SPACE 2
* ENTIRE GQE IS BEING FREED . DROP GQE FROM CHAIN AND ADJUST        ATT
*        FREEADDR AND FREESIZE BY 8. *                              ATT
         L     GQWORK1,SAVEGQE                                      ATT
         MVC   GQEPTR(FOUR,GQWORK1),GQEPTR(GQEREG) .                ATT
         LA    FREESIZE,EIGHT(FREESIZE) .UPDATE SIZE FOR GQE        ATT
         SH    FREEADDR,EIGHTDC .  UPDATE AREA TO FREE FOR GQE      ATT
         BR    RETREG .            RETURN TO FREECORE               ATT
         SPACE 2
* PARTIAL GQE IS BEING FREED *                                      ATT
GQCKPART LR    GQWORK1,FREEADDR .  GET ADDR TO FREE                 ATT
         SR    GQWORK1,GQEREG .    GET LNGTH BEGIN GQE TO FREEADDR  ATT
         CH    GQWORK1,EIGHTDC .   IS SIZE=8                        ATT
         BNE   GQMID               NO, SIZE TO FREE IN MIDDLE       ATT
* THE GQE IS BEING FREED FROM THE BEGINNING. FREE GQE AT BEGINNING  ATT
* AND MOVE IT TO LAST 8 BYTES OF FREED AREA.                        ATT
         LR    FREEADDR,GQEREG .   NEW ADDR TO FREE=BEGIN GQE       ATT
         LR    GQWORK1,GQEREG .    GET GQE ADDR                     ATT
         AR    GQWORK1,FREESIZE .  GET ADDR NEW GQE                 ATT
         MVC   GQEPTR(FOUR,GQWORK1),GQEPTR(GQEREG) . INIT 1ST WORD  ATT
         L     GQWORK2,GQESIZE(GQEREG) .GET OLD GQE SIZE            ATT
         SR    GQWORK2,FREESIZE .  GET LENGTH NEW GQE               ATT
         ST    GQWORK2,GQESIZE(GQWORK1) .INIT 2ND WORD NEW GQE      ATT
         L     GQWORK2,SAVEGQE . GET ADDR PREVIOUS GQE              ATT
         ST    GQWORK1,GQEPTR(GQWORK2) .UPDATE PREV PTR             ATT
         BR    RETREG .            RETURN TO FREECORE               ATT
         SPACE 2
* THE PARTIAL GQE TO FREE BEGINS IN THE MIDDLE OF THE GQE           ATT
GQMID    LR    GQWORK2,FREEADDR .  GET ADDR OF                      ATT
         AR    GQWORK2,FREESIZE .              END AREA TO FREE     ATT
         LR    GQWORK3,GQEREG .    GET ADDR OF                      ATT
         A     GQWORK3,GQESIZE(GQEREG) .       END OF GQE           ATT
         CLR   GQWORK2,GQWORK3 .   IS END AREA TO FREE=END GQE      ATT
         BNE   GQNEWGQ                                              ATT
* PARTIAL GQE ENDS AT GQE END. DECREMENT SIZE OF GQE.               ATT
         ST    GQWORK1,GQESIZE(GQEREG) .                            ATT
         BR    RETREG .            RETURN TO FREECORE               ATT
         SPACE 2
GQNEWGQ  EQU   *              AREA TO FREE IS IN MIDDLE OF GQE      ATT
         SH    FREESIZE,EIGHTDC .  DECREMT SIZE FOR NEW GQE         ATT
         LR    GQWORK2,FREEADDR .  GET ADDR                         ATT
         AR    GQWORK2,FREESIZE .           OF NEW GQE              ATT
         MVC   GQEPTR(FOUR,GQWORK2),GQEPTR(GQEREG) .FORWARD CHAIN   ATT
         L     GQWORK3,GQESIZE(GQEREG) .                            ATT
         SR    GQWORK3,FREESIZE .  GET SIZE OF                      ATT
         SR    GQWORK3,GQWORK1 .               NEW GQE              ATT
         ST    GQWORK3,GQESIZE(GQWORK2) . INIT SIZE OF NEW GQE      ATT
         ST    GQWORK1,GQESIZE(GQEREG) .ADJUST CURR GQE SIZE        ATT
         ST    GQWORK2,GQEPTR(GQEREG) .ADJUST CURR GQE PTR          ATT
         BR    RETREG .            RETURN TO FREECORE               ATT
.FRCOEND ANOP
         TITLE 'ABTSETUP SUBROUTINE'
         AGO .AMS9
*/*ABTSETUP: CHART */
*/*ABTSETUP: E ENTRY */
*/*    P  FILL WORK BUFFER WITH PROBLEM DETERMINATION INFO*/
*/*    D  (YES,,NO,ABGETCC) ENTRY AVAILABLE IN IEAQMSG BUFFER*/
*/*    P  COPY WORK BUFFER TO IEAQMSG ENTRY */
*/*ABGETCC:  P SET UP COMPLETION CODE IN REG1, TCB IN REG 0 */
*/*    R   GO TO ABTERM */
*/*ABTSETUP: END */
.AMS9    ANOP
****ABTERM INTERFACE AREA****
*---------------------------------------------------------------------
         SPACE 2
ABNOCORE EQU   *
* CHECK  IF REQUESTOR IS ABEND/ABTERM OR SVC FLIH
         TM    TCBFLGS(REG4),X'A0' . HAS ABTERM BEEN ENTERED
         BCR   EIGHT,RETREG2   NO, NOT RECURSIVE ABEND         @SA66514
         L     ABWORK2,ZERO(REG4)   GET TOP RB                 @SA66514
         CLC   RBNAME+6(TWO,ABWORK2),SVC13ID IS ABEND REQUEST? @SA72568
         BE    ABRECUR .
         CLC   SVCOPSW+5(3),IEAATADD+1 .IS SVC FLIH GETTING ABEND SVRB
         BCR   SEVEN,RETREG2   NO, DON'T WANT STEAL CORE       @SA66514
ABRECUR   EQU   *
         LA    REG15,FOUR .        SET RETURN CODE=4
         AIF   (NOT &LCS).ABEXIT
         BAL   RETREG,COMMLCS .GO RESTORE LCS FLAG                  LCS
.ABEXIT  ANOP
         BR    REG14 .             GO TO SVC TYPE 1 EXIT
         SPACE 4
AB60X1 EQU   *  **PARM IS OUTSIDE USER'S CORE 60X-1ABEND
         BAL   RETREG2,ABNOCORE CHECK FOR RECURSIVE ABEND 1ST  @SA66514
         MVI   PDCOMPCD,X'06' .   SET 1ST BYTE COMP CODE
         MVI   PDRCNUM,X'24' .    REASONCODE=1,LENGTH=4
         ST    REG1,PDVAR1 .      PUT ADDR PARMLIST IN VAR DATA 1
         B     ABFINISH .         GO FINISH
         SPACE 3
AB60X2 EQU   *         **** FQE INVALID- 60X-2 ABEND ***
         BAL   RETREG2,ABNOCORE CHECK FOR RECURSIVE ABEND 1ST  @SA66514
         MVI   PDRCNUM,X'50' .     REASON CODE=2,LNGTH=16
         CLI   SVCOPSW+3,SVC5 .   IS THIS SVC 5
         BE   ABCKSP .           YES
         MVI   PDRCNUM,X'4C' .    REASON CODE=2,LNGTH=12
ABCKSP   MVI   PDCOMPCD,X'06' .    SET 1ST BYTE COMP CODE
         ST    CURFQREG,CLOBBERD . SAVE ADDR BAD FQE OR GQE
         CLI   SVCOPSW+3,SVC5 .    IS THIS SVC 5
         BE    ABFQ5 .             YES
         MVC   PDVAR2(EIGHT),FQEPTR(CURFQREG) .PUT FQE IN VAR DATA2,3
         B     ABCKLCS .          GO FINISH BUFFER
ABFQ5    ST    FREEADDR,PDVAR2 .  PUT ADDR TO FREE IN VAR DATA2
         MVC   PDVAR3(EIGHT),FQEPTR(CURFQREG) .PUT FQE IN VAR DATA3,4
         B     ABCKLCS .
         SPACE 3
         AIF   (NOT &ATT).ABNOATT
AB60X3 EQU   *   ***GQE INVALID-60X-3 ABEND***                      ATT
         LR    CURFQREG,GQEREG . FQEREG=GQEREG FOR 604-2 CODE       ATT
         BAL   RETREG2,ABNOCORE CHECK FOR RECURSIVE ABEND 1ST  @SA66514
         MVI   PDRCNUM,X'70' .    FOR SVC5,REASONCODE=3,LNGTH=16    ATT
         CLI   SVCOPSW+3,SVC5 .   IS THIS SVC5                      ATT
         BE    ABCKSP .           YES                               ATT
         MVI   PDRCNUM,X'6C' .    REASON CODE=3,LNGTH=12            ATT
         B     ABCKSP .           GO USE 60X-2                      ATT
.ABNOATT ANOP
         SPACE 3
ABEND70X  EQU  *   ***LIST TYPE REQUEST  70X COMP CODE
         BAL   RETREG2,ABNOCORE CHECK FOR RECURSIVE ABEND 1ST  @SA66514
         MVI   PDCOMPCD,X'07' .SET 1ST BYTE COMP CODE
         MVI   PDRCNUM,X'04' .REASON CODE=0,LNGTH=4
         ST    REG1,PDVAR1 .       1ST VARDATA=PARMLIST
         B     ABFINISH .         GO FINISH BUFFER
         SPACE 3
AB80X1   EQU   *    ***  MAIN STORAGE NOT AVAILABLE  80X-1 ***
         BAL   RETREG2,ABNOCORE CHECK FOR RECURSIVE ABEND 1ST  @SA66514
         MVI   PDRCNUM,X'28' .     REASON CODE=1,LNGTH=8
AB80XX   MVI   PDCOMPCD,X'08' .    SET 1ST BYTE COMP CODE
         MVC   PDVAR2(FOUR),LARFQSIZ .VAR DATA2=LARGEST FQE
         B     ABCKLCS .          GO GET SUBPOOL
         SPACE 3
AB80X2   EQU   *   ***ZERO OR NEGATIVE SIZE SPECIFIED  80X-2 ABEND
         BAL   RETREG2,ABNOCORE CHECK FOR RECURSIVE ABEND 1ST  @SA66514
         MVI   PDCOMPCD,X'08' .   GET 1ST BYTE COMP CODE
         MVI   PDRCNUM,X'44' .    REASON CODE=2,LENGTH=4
         B     ABCKLCS .         GO FINISH BUFFER
         SPACE 3
AB90X1    EQU   *    ***AREA TO FREE NOT ON DBLEWORD BDY ***
         BAL   RETREG2,ABNOCORE CHECK FOR RECURSIVE ABEND 1ST  @SA66514
          MVI   PDRCNUM,X'28' . REASON CODE=1,LNGTH=8
AB90XXX  MVI   PDCOMPCD,X'09' .   SET 1ST BYTE COMPLETION CODE
         ST    FREEADDR,PDVAR2 .PUT ADDR TO FREE IN DATA 2
         B     ABSPIDCK .     GO FINISH BUFFER
         SPACE 3
AB90X2   EQU    *    ***AREA TO FREE NOT IN USERS BBOX ***
         BAL   RETREG2,ABNOCORE CHECK FOR RECURSIVE ABEND 1ST  @SA66514
         MVI   PDRCNUM,X'48' .REASON CODE=2,LNGTH=8
         B     AB90XXX .   GO USE 90X-1 CODE
         SPACE 3
         AIF (NOT &ATT).NO90X3
AB90X3   EQU *  ****AREA TO FREE GOES BEYOND GQE ****               ATT
         BAL   RETREG2,ABNOCORE CHECK FOR RECURSIVE ABEND 1ST  @SA66514
         MVI   PDRCNUM,X'6C'  REASON CODE=6,LNGTH=12              M5279
         MVI   PDCOMPCD,X'09' .SET 1ST BYTE COMP CODE               ATT
         ST    FREEADDR,PDVAR2 . VAR DATA 2 = ADDR AREA TO FREE     ATT
         ST    GQEREG,PDVAR3 .VAR DATA 3= GQE ADDR                M5279
         B     ABCKLCS          GO FINISH BUFFER                    ATT
.NO90X3  ANOP
         SPACE 3
ABA0X  EQU   *         **** AREA TO FREE RUNS INTO FQE -AOX ****
         BAL   RETREG2,ABNOCORE CHECK FOR RECURSIVE ABEND 1ST  @SA66514
         MVI   PDCOMPCD,X'0A' .    SET 10T BYTE COMP CODE
ABRC8    MVI   PDRCNUM,X'08' .     REASON CODE=0,LNGTH=8
         ST    FREEADDR,PDVAR2 .   PUT ADDR TO FREE IN VAR DATA2
         B     ABCKLCS .          GO FINISH BUFFER
         SPACE 3
ABB0X  EQU   * .      ****  SUBPOOL ID IS INVALID- BOX ABEND ****
         BAL   RETREG2,ABNOCORE CHECK FOR RECURSIVE ABEND 1ST  @SA66514
         MVI   PDCOMPCD,X'0B' .    SET 1ST BYTE COMPLET CODE
         CLI   SVCOPSW+3,SVC5 .    IS THIS SVC 5
         BE    ABB0XFR .             YES
         MVI   PDRCNUM,FOUR .      REASON CODE=0, LNGTH=4
         B     ABSPIDCK
ABB0XFR  MVI   PDRCNUM,X'08' .REASON CODE=0,LNGTH=8
         ST    FREEADDR,PDVAR2 . PUT ADDR TO FREE IN VAR DATA2
         B     ABSPIDCK .     GO FINISH BUFFER
          SPACE 3
ABTSTE04 EQU *    ***SQA STORAGE NOT AVAILABLE***
         TM    SWITCHES,SQSREQ .IS REQUEST FOR SQS                M4914
         BZ    AB80X1 .          NO, NOT SQS E04                  M4914
         BAL   RETREG2,ABNOCORE CHECK FOR RECURSIVE ABEND 1ST  @SA66514
ABE04    MVC   PDCOMPCD(TWO),CCE04 .COMP CODE= E04
         MVI   PDRCNUM,X'08' .REASON CODE=0 LENGTH=8
         MVC   PDVAR2(FOUR),LARFQSIZ  . VAR DATA2= LARGEST FQE
         SPACE 5
ABCKLCS EQU   *
         AIF   (NOT &LCS).ABSPID
*** ERROR CODE 60X-1,60X-2,70X,90X-1,90X-2,B0X HAVE NOT ZEROED      LCS
*** THE LCS BOUNDARY BOX FLAG,SO DON'T BALR TO COMMLCS.             LCS
         BAL   RETREG,COMMLCS .GO RESTORE LCS FLAG                  LCS
.ABSPID  ANOP
*  THE FOLLOWING CODE PUTS THE SUBPOOL ID AND LENGTH IS VAR DATA 1
ABSPIDCK CLI   SVCOPSW+3,SVC10 .  IS THIS REGMAIN
         BNE   ABSVC45 .           NO
         ST    REG0,PDVAR1 .       GET SUBPOOL ID, LENGTH
         B     ABFINISH .         GO CONTINUE BUFFER FILL
ABSVC45  MVC   PDVAR1(1),SAVESPID . GET SUBPOOL ID
         MVC   PDVAR1+1(3),GETLNGTH+1 .GET SUBPOOL LENGTH
ABFINISH EQU   *
         CLI   PDCOMPCD,X'0E' .  IS THIS E04
         BE    ABSTCB .          YES, COMP CODE DONE
         MVC   PDCOMPCD+1(1),SVCOPSW+3 .GET SVC ID
ABSTCB   ST    REG4,PDTCB .       PUT TCB IN BUFFER
**  PROBLEM DETERMINATION CODE FOLLOWS IN WHICH IEAQMSG BUFFER IS
** FILLED IF A BUFFER IS AVAILABLE.
         L     ABPDBUF,VCQMSG .GET ADDR IEAQMSGS INFOLIST
         L     ABPDEND,ZERO(ABPDBUF) .GET ADDR END OF LIST
         LA    ABPDBUF,FOUR(ABPDBUF) .GET ADDR OF 1ST ENTRY
         SR    ABWORK1,ABWORK1 .ZERO WORK REG
ABTSTEND CR    ABPDBUF,ABPDEND .MORE ENTRIES?
         BE    ABGETCC .          NO, GO SET UP FOR ABTERM
         C     ABWORK1,ZERO(ABPDBUF) .ENTRY AVAILABLE?
         BE    ABFILBUF .       YES, GO FILL ENTRY
         LA    ABPDBUF,BUFLNG(ABPDBUF) .GET NEXT ENTRY
         B     ABTSTEND .           GO CHECK NEXT ENTRY
ABFILBUF MVC   ZERO(BUFLNG,ABPDBUF),PDBUFFER .COPY TO ENTRY     A49808
ABGETCC  LH    REG1,PDCOMPCD .    GET COMPLETION CODE
         SLL   REG1,TWELVE .      SET UP REG1 FOR ABEND
         O     REG1,DUMPMASK .    SET HIGH BIT ON FOR DUMP
         LR    REG0,REG4 .        SET UP TCB IN REG0 FOR ABTERM
         L     REG15,VCABTERM .   GET ADDR ABTERM
         L     BASEREG,VCCVT .    GET CVT ADDR FOR ABTERM
         BR    REG15 .            GO TO ABTERM
         TITLE 'SMFGET SUBROUTINE'
         AGO   .AMS10
*/*SMFGET: CHART */
*/*SMFGET: E ENTRY */
*/*    P  GET JOBSTEP TCB AND TCT */
*/*    D  (YES,SMTSTH1,NO,) IS REQUEST FOR HIER=1 */
*/*    D  (YES,SMGETH1,NO,) IS DUMMY HIERARCHY SWITCH ON*/
*/*SMGETH0:  P (,SMTSTHWM) GET ADDR HIER=0 STORAGE TABLE*/
*/*SMTSTH1:  D (YES,SMGETH0,NO,) IS DUMMY HIERARCHY SWITCH ON*/
*/*SMGETH1:  P GET ADDR HIER=1 STORAGE TABLE */
*/*SMTSTHWM: D (YES,%SM1,NO,) IS SMF RECORDING (HWM NOT =0)*/
*/*    R  RETURN */
*/*%SM1: D  (YES,,NO,SMTSTLWM) DOES END OF ALLOC AREA JOIN HWM*/
*/*    P  (,SMLARGFQ) NEW HWM= ADDR ALLOCATED ARGA*/
*/*SMTSTLWM: D (YES,,NO,SMLARGFQ) DOES BEGIN OF ALLOC AREA JOIN LWM*/
*/*    P  NEW LWM= ADDR OF END OF ALLOCATED AREA */
*/*SMLARGFQ: P POSSIBLE DELTA=(LARGEST FQE-ALLOC SIZE)/2K */
*/*    D   (YES,%SM2,NO,) IS POSSIBLE DELTA < TCTMINC*/
*/*    R  RETURN */
*/*%SM2:  P  ZERO SMFSZ AND GET 1ST FQE */
*/*SMTSTEND:    D  (YES,SMFQEND,NO,) IS THIS LAST FQE*/
*/*    D  (YES,,NO,SMNXTFQE) IS FQE GT SMFSZ*/
*/*    P     SMFSZ= FQE SIZE */
*/*SMNXTFQE: P  (,SMTSTEND)  GET NEXT FQE*/
*/*SMFQEND:  D (YES,,NO,%SM3) IS SMFSZ/2K < TCTMINC*/
*/*    P  TCTMINC = SMFSZ/2K */
*/*%SM3: R RETURN */
*/*SMFGET: END */
.AMS10   ANOP
         AIF   (NOT &SMF).SMFEND                                    SMF
*---------------------------------------------------------------------
*    SMFGET UPDATES THE LOW WATER  AND HIGH WATER MARKS AND THE     SMF
*    MINIMUM DIFFERENCE BETWEEN THE WATER MARKS.                    SMF
*    HWM = LOWEST ADDR ALLOCATED FROM HIGH END OF PARTITION         SMF
*    LWM = HIGHEST ADDR ALLOCATED FROM LOW END OF PARTITION         SMF
*    HWM AND LWM MAY OVERLAP                                        SMF
*    TCTMINC = LARGEST FQE (IN 2K BLOCKS) NOT USED BY JOB           SMF
*    INPUT IS THE ADDR OF THE ALLOCATED AREA  IN REG 13 AND THE     SMF
*    THE SIZE ALLOCATED AT ROUNDSIZ.                                SMF
*---------------------------------------------------------------------
          SPACE 2
          DS 0F
SMFGET   EQU   *                                                    SMF
         L     SMJSTCB,TCBFTJST(REG4) .GET JOBSTEP TCB              SMF
         TM    TCBTCTGF(SMJSTCB),SMFCALC .JOB SCHEDULER IN TERMINAT?SMF
         BCR   EIGHT,RETREG .YES DON'T CALCULATE SMF INFO           SMF
         L     SMTCT,TCBTCT(SMJSTCB) .GET TIMING CNTRL TABLE        SMF
         LA    SMTCT,ZERO(SMTCT) . ZERO HIGH BYTE                   SMF
         LTR   SMTCT,SMTCT .IS THER A TCT TABLE                     SMF
         BCR   EIGHT,RETREG .NO,MUST BE SYSTEM TASK                 SMF
         L     SMTCT,TCTCRTBL(SMTCT) . GET ADDR HOT STORAGE TABLE   SMF
         AIF   (NOT &LCS).SMNOLCS                                   SMF
         TM    SWITCHES,LCSW .     IS REQUEST FOR HER=1           LCSMF
         BO    SMTSTH1 .           YES                            LCSMF
         TM    SWITCHES,DUMHIER .  IS HIER=0 REQ BUT HIER=1 USED  LCSMF
         BO    SMGETH1 .           YES                            LCSMF
         B     SMTSTHWM .    USE HOT STOR TABLE                   LCSMF
SMTSTH1  TM    SWITCHES,DUMHIER .  IS HIER=1 REQ BUT HIER=0 USED  LCSMF
         BO    SMTSTHWM .          YES, USE HOT STOR TABLE        LCSMF
SMGETH1  LA    SMTCT,SIXTN(SMTCT) .GET ADDR LCS STOR TABLE        LCSMF
.SMNOLCS ANOP                                                       SMF
* THE ADDR OF THE PROCESSOR STORAGE TABLE(HOT STORAGE) OR THE       SMF
* HIERARCHY SUPPORT TABLE(LCS STORAGE) IS NOW IN REG SMTCT.         SMF
SMTSTHWM EQU   *                                                    SMF
         NC    TCTHWM(FOUR,SMTCT),TCTHWM(SMTCT) .IS SMF RECORDING   SMF
         BCR   EIGHT,RETREG .      NO, RETURN TO GETCORE            SMF
         SPACE 2
*** CHECK FOR UPDATES TO HWM AND LWM***                             SMF
         LR    SMWORK1,GETADDR .   GET ADDR AREA ALLOCATED          SMF
         A     SMWORK1,ROUNDSIZ .  GET   END OF AREA ALLOCATED      SMF
         CL    SMWORK1,TCTHWM(SMTCT) .DOES ALLOC AREA JOIN HWM      SMF
         BL    SMTSTLWM .          NO, TRY LWM                   A56743
         CL    GETADDR,TCTHWM(SMTCT) IS BEGIN ALLOC AREA LT HWM  A56743
         BNL   SMTSTLWM  NO CK LWM IN CASE OF OVERLAP            A56743
         ST    GETADDR,TCTHWM(SMTCT) .UPDATE HWM                    SMF
         B     SMLARGFQ .          GO CHECK DELTA                   SMF
SMTSTLWM CL    GETADDR,TCTLWM(SMTCT) .DOES ALLOC AREA JOIN LWM      SMF
         BH    SMLARGFQ .NO, GO CK DELTA                         A56743
         CL    SMWORK1,TCTLWM(SMTCT) IS END ALLOC AREA GT LWM    A56743
         BNH   SMLARGFQ NO GO CK DELTA                           A56743
         ST    SMWORK1,TCTLWM(SMTCT) .UPDATE LWM                    SMF
         SPACE 2
****CHECK IF THE LARGEST FQE IN SCAN IS LESS THAN PREVIOUS LARGEST  SMF
SMLARGFQ L     SMFSZ+1,LARFQSIZ .  GET LARGEST FQE FOUND IN GETCORE SMF
* LARFQSIZ CONTAINS THE LARGEST FQE ONLY FOR LOW-CORE REQUEST.      SMF
         S     SMFSZ+1,ROUNDSIZ .GET POSSIBLE NEW DELTA =PD         SMF
         SR    SMFSZ,SMFSZ .ZERO EVEN REG FOR DIVIDE                SMF
         D     SMFSZ,TWOKDC .     DIVIDE BY 2K FOR DELTA COMPARE    SMF
         CH    SMFSZ+1,TCTMINC(SMTCT) .QUOTIENT LT CURRENT DELTA?   SMF
         BCR   ELEVEN,RETREG .     NO,EXISTING DELTA OKAY,RETURN    SMF
         SR    SMFSZ,SMFSZ .       ZERO EVEN REG FOR DIVIDE         SMF
         SR    SMFSZ+1,SMFSZ+1 .  ZERO LARGEST FQE HOLDER           SMF
* SCAN DOWN ALL FQES LOOKING FOR LARGEST .                          SMF
         L     SMFQE,BBFQE(BBOXREG) .GET 1ST FQE ADDR               SMF
SMTSTEND LTR   SMFQE,SMFQE .       IS THIS LAST FQE                 SMF
         BZ    SMFQEND .           YES                              SMF
         CL    SMFSZ+1,FQELNGTH(SMFQE) .IS FQE GT SMFZE             SMF
         BH    SMNXTFQE .          NO,GET NEXT FQE                  SMF
         L     SMFSZ+1,FQELNGTH(SMFQE) .UPDATE SMFZE                SMF
SMNXTFQE L     SMFQE,FQEPTR(SMFQE) .GET NEXT FQE                    SMF
         B     SMTSTEND .          GO CHECK IF END OF FQES          SMF
SMFQEND  D     SMFSZ,TWOKDC .     ROUND CORE TO 2K                  SMF
         CH   SMFSZ+1,TCTMINC(SMTCT) .IS LARGEST FQE LT DELTA       SMF
         BCR   TWO,RETREG .        NO                               SMF
         STH   SMFSZ+1,TCTMINC(SMTCT) .UPDATE DELTA                 SMF
         BR    RETREG .            RETURN TO GETCORE                SMF
         TITLE 'IEAAMS CONSTANTS'
.SMFEND  ANOP                                                       SMF
***  CONSTANTS   ***
         SPACE 5
DATAWORK EQU   *     DATA AREA WHICH IS CLEARED IN PROLOGUES
         SPACE 2
BEGIN    EQU   *              BEGIN OF AREA TO CLEAR
SWITCHES DC    1X'00'         SWITCH FLAGS
LOCORESW EQU   X'80'          GET CORE FROM BOTTOM OF PARTITION
GQESW    EQU   X'40'          REQUESTOR=SUBTASK                     ATT
LCSW     EQU   X'20'          HIERARCHY=1 REQUEST                   LCS
DUMHIER  EQU   X'10'              PARTITION DOESNT HAVE HIER REQUESTED
GETMAIN  EQU   X'08' .            GETMAIN REQUEST
SQSREQ   EQU   X'04' .   SUBPOOL 245, 255 REQUEST                 M4914
LARFQSIZ DS    1F                  SAVE AREA FOR LARGEST FQE SIZE
LOCORSAV DS    3F . SAVEAREA FOR LOW CORE HUNT OF FQES-CUR,PREV,LAST
ROUNDSIZ DS    1F                  REQUESTOR'S SIZE ROUNDED TO DOUBLEW
         AIF   (NOT &ATT).NOSVGQE
SAVEGQE  DS    1F .          SAVE AREA FOR LAST GQE                 ATT
.NOSVGQE ANOP
SAVELNGT DS    1F
FRSAV15  DS    1F .REG15 SAVE AREA FOR FREEMAIN
         AIF   (NOT &LCS).NOLCSAV
LCSFLGSV DS    1X                   SAVE AREA FOR BBOX LCS FLAG     LCS
.NOLCSAV ANOP
SAVESPID DS    1X
END      EQU   *              END OF AREA TO CLEAR
         SPACE 2
* PROBLEM DETERMINATION AREA
          DS 0F
PDBUFFER EQU   *
PDTJID   DS    1F .           NOT USED- FOR MVT-TSO              A49808
PDTCB    DS    1F .           REQUESTING TCB
         DS    1F .           NOT USED- FOR BRANCH ENTRIES
PDRCNUM  DS    1X .           BITS 0-2=REASON CODE                     X
                              BITS 3-7=NUMBER BYTES VARIABLE DATA
         DS    1X .           NOT USED- BRANCH ENTRY FLAG
PDCOMPCD DS    2X .           SYSTEM COMPLETION CODE
PDVAR1   DS    1F .           VARIABLE INFO ACCORDING TO COMP CODE
PDVAR2   DS    1F .           VARIABLE INFO ACCORDING TO COMP CODE
PDVAR3   DS    1F .           VARIABLE INFO ACCORDING TO COMP CODE
PDVAR4   DS    1F .           VARIABLE INFO ACCORDING TO COMP CODE
         SPACE 2
CLOBBERD DC    F'0' .  SAVE AREA FOR ADDR OF BAD FQE OR GQE
         AIF   (NOT &ATT).NOATTDC
EIGHTDC  DC  H'8'                SUBTRACT FACTOR FOR GQE            ATT
SIXTNDC  DC     H'16' .           GQE MINIMUM SIZE                  ATT
.NOATTDC ANOP
SVC13ID  DC   X'F1C3' .          SVRB ABEND ID
CCE04    DC   X'0E04' .          COMPETION CODE E04
         DS    0F
DUMPMASK DC    X'80000000' .      HIGH BIT MASK FOR ABTERM TO DUMP
         AIF   (NOT &LCS).NOLCT
LCSREGM  DC     X'80D3C3E3' .     REG1 VALUE FOR LCS GETMAIN-REGMAINLCS
.NOLCT   ANOP
         AIF   (NOT &SMF).NO2KSMF
TWOKDC   DC    F'2048' .         2K DIVIDER FOR DELTA COMPARE       SMF
.NO2KSMF ANOP
IEAATADD DC    V(ABENDSUC) .
VCABTERM DC    V(IEA0AB00) .  ENTRY POINT ABTERM
VCMSER   DC    V(IEEMSER) .  ADDR MASTER SCHE RESIDENT DATA AREA
VCQMSG   DC    V(IEAQMSGS) .ADDR IEAQMSGS  ENTRIES
VCCVT    DC    V(IEACVT)  .ADDR CVT
VCSVRBS  DC    V(SVRBPOOL) .ADDR STEAL CORE SVRB POOL IN IEAATA
SAVEWORK DC    10F'0' .       HELP AREA
         SPACE 2
**** PARAMETER LIST DESECT ****
GETDSECT DSECT
GETLNGTH DS    1F             LENGTH OR ADDR LENGTH PARM LIST
GETHID   DS    1C             HIERARCHY ID
HIERAR1  EQU   X'01'          HIERARCHY=1 REQUEST
         ORG   *-1
GETADD   DS    4C             ADDR OF AREA GETMAIN FILLS WITH RESULT
GETYPE   DS    1C             FLAGS
CONDSE   EQU   X'20'          CONDITIONAL SINGLE REQUEST
UNCONDSE EQU   X'00'          UNCONDITIONAL SINGLE REQUEST
CONDLST  EQU   X'A0'          CONDITIONAL LIST REQUEST
UNCONDLS EQU   X'80'          UNCONDITIONAL LIST REQUEST
CONDVAR  EQU   X'E0'          CONDITIONAL VARIABLE REQUEST
UNCONDVA EQU   X'C0'          UNCONDITIONAL VARIABLE REQUEST
GETSPID  DS    1C             SUBPOOL NUMBER
         DS    2C             RESERVED
         MEND
