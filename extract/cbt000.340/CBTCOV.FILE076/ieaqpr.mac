         MACRO
         IEAQPR     &RORI,&LCS,&MPS
         LCLB  &MP                                                 MP1A
.*0467002000-902000                                                MO17
.*3612                                                             MP2K
.*3612,147600,354600,684000-684900                                 3645
.*3612,149400,450900,477000,481500                                 SWS
.*3612,587740-588420,599400,665100                                 MP2A
         TITLE ' MVT GETPART / FREEPART ROUTINE '
.*0467                                                             8499
*2970,140400-140800,145100-145500,477480,547200                   9400
&MP  SETB ('&MPS' EQ '1' OR '&MPS' EQ 'M65MP' OR '&MPS' EQ 'Y')    MP1A
IEAQPRT0 CSECT
         ENTRY DISPINIT                                            SWS
         AIF   (NOT &MP).MP01PTM                                   MP1A
         ENTRY IEAMPSTR                                            MP1A
.MP01PTM ANOP                                                      MP1A
         EXTRN IEAMSTCB
         EXTRN GOVRFLB
         SPACE 10
         EJECT
***********************************************************************
***********************************************************************
*    THE GETPART/FREEPART FUNCTION IS AN EXTENSION OF  GETMAIN        *
*  (IEAQGM)    IT IS ENTERED VIA A BRANCH FROM GETMAIN WHEN SUBPOOL   *
*     246-247-OR-248 HAS BEEN SPECIFIED. THE GETPART MACRO CAN BE     *
*  ASSEMBLED WITH ANY OR ALL OF THREE OPTIONS -- '&LCS' INDICATING    *
*  LCS SUPPORT, '&RORI' FOR SUPPORT OF ROLLOUT/ROLLIN, AND '&MPS'     *
*  FOR MULTIPROCESSING SUPPORT.                                       *
*                                                                    *
*  ENTRIES TO GETPART INDICATE THE FOLLOWING                         *
*                                                                    *
*  SUBPOOL 247 - R-FORM  VIA SVC 10                                  *
*                                                                    *
*              R1 MINUS - GET PARTITION                              *
*                                                                    *
*              R1 PLUS OF ZERO - FREE PARTITION                      *
*                                                                    *
*              LIST FORM - VIA SVC 4                                 *
*                                                                    *
*              R1 - ZERO - GET PARTITION                             *
*                                                                    *
*              R1 - NON-ZERO - GET PARTITION AT THE ADDRESS          *
*            SPECIFIED IN R1                                         *
*                                                                    *
* SUBPOOL 246   R-FORM   VIA SVC  10                                 *
*                                                                    *
*              FREE THE PRESENT PARTITION AND THEN GET ANOTHER       *
*            OF THE SPECIFIED LENGTH                                 *
*                                                                    *
*              LIST FORM   VIA SVC 4                                 *
*                                                                    *
*              R1 - ZERO  SAME AS R-FORM                             *
*                                                                    *
*              R1 - NON-ZERO FREE PRESENT PARTITION AND OBTAIN NEW   *
*            PARTITION AT ADDRESS SPECIFIED IN R1                    *
*                                                                    *
*  SUBPOOL 248  INDICATES REQUEST FROM ROLLOUT/ROLLIN                *
*                                                                    *
*  NOTE- THE LENGTHS OF REQUESTS ARE OBTAINED THE SAME AS IN GETMAIN *
*                                                                    *
*                                                                    *
*  RETURNS FROM GETPART                                              *
*                                                                    *
*            RETURN= '00'  SUCCESSFUL IN OBTAINING PARTITION         *
*                                                                    *
*            RETURN = '04'  REQUEST CANNOT BE SATISFIED              *
*         EC OR LC  ONLY                                             *
*                                                                    *
*            RETURN = '08' THE REQUEST IS NOT VALID - REQUEST IS TOO *
*         LARGE OR FOR AN INVALID ADDRESS                            *
*                                                                    *
*            IF THE REQUEST IS UNCONDITIONAL AND CANNOT BE SATISFIED *
*         BUT IS VALID THE REQUESTING TCB IS PLACED IN A WAIT FOR    *
*         CORE                                                        *
*                                                                    *
*                                                                    *
*            IF A REQUEST IS MADE FOR A SPECIFIC ADDRESS AND CANNOT   *
*                                                                    *
*         NOW BE SATISFIED ALL FOLLOWING REQUESTS FOR CORE WILL      *
*         NOT BE HONORED UNTIL THE ACTUAL ADDRESS REQUEST            *
*         IS SATISFIED                                               *
*                                                                    *
*                                                                    *
*                                                                    *
***********************************************************************
***********************************************************************
*
*
         SPACE 2
         DS  0D
         BALR  RBASE,0
         USING PART,RBASE
PART     STM   RRETURN,RIN1,RINSAVE  SAVE INPUT REGISTERS
         MVC   SWITCHES(3),ZEROES
         LA    RWORK2,247
         CR    RSPID,RWORK2   IS THIS A FREE-GET REQUEST
         BL    FREXCHNG       YES- SUBPOOL 246 SPECIFIED
         AIF   ('&RORI' NE 'Y').GO01
         BH    RORI           SUBPOOL 248 REQUEST FROM FOLLOUT/ROLLIN
.GO01    ANOP
CKSVCBYT L     RWORK1,ADSVCB    ADDRESS OF SVC BYTE
         CLI   0(RWORK1),4    IS THIS AN SVC 4
         BE    SVC4       YES
         LTR   RIN1,RIN1      IS REQUEST FREEPART
         BC    10,FREEPART   YES
         B     REGREQ     HAS TO BE REGISTER REQUEST FOR GETPART
SVC4     OI    SWITCHES,X'01'        INDICATE REQUEST VIA SVC 4
         CLI   WAITSW,X'FF'  IS WAIT SW ON
         BE    CKTCB
TCBOK    TM    8(RIN1),X'DF'  TEST FOR ELEMENT REQUEST
         BZ    ELEREQ
         SPACE 2
*****                                                              ****
*                                                                     *
*                      THIS CODE OBTAINS THE  DESIRED PARTITION(S)    *
*                                                                     *
*****                                                              ****
         SPACE 2
GPART    LR    RWORK1,RIN1
         AIF   ('&LCS' EQ 'Y').GO03
         LA    RWORK3,0       CLEAR TOTAL LENGTH REG
.GO03    ANOP
         L     RWORK1,0(RWORK1)    PICK UP POINTER TO LENGTH LIST
         L     RADDR,4(RIN1)     PICK UP ADDRESS POINTER
         AIF   ('&LCS' EQ 'N').GO39
LISTGP   ST    RWORK1,WORK1SV
         ST    RADDR,ADDRSV
.GO39    ANOP
         L     RADDR,0(RADDR)    PICK UP ADDRESS ENTRY
NLCSGP   L     RWORK2,0(RWORK1)  PICK UP LENGTH
***      THIS SECTION OF CODE DETERMINES THE NUMBER OF 2K    BL A59054
*        BLOCKS NEEDED FOR A PARTITION AND GETS THEM         BL A59054
         LA    RWORK2,0(RWORK2) .       CLEAR HI BYTE        AC  M5282
         LA    RSIZE,2047 .                                  AC  M5282
         LR    RIN0,RSIZE .                                  AC  M5282
         AR    RSIZE,RWORK2 .  RWORK2 CONTAINS THE LENGTH    AC  M5282
         OR    RSIZE,RIN0 .                                  AC  M5282
         XR    RSIZE,RIN0 .                                  AC  M5282
         LR    RWORK2,RSIZE .                                AC  M5282
         AIF   ('&LCS' EQ 'N').GO10
         ST    RADDR,HSAVE       SAVE HIARCHY INDICATION
         CLI   HSAVE,X'01'       HAS H1 BEEN SPECIFIED
         BNE   NOTH1DUM          NO SKIP PQE CHECK
         L     RWORK4,OVRFLB     GOVERFLB
         L     RWORK4,8(RWORK4)  ADDRESS OF DUMMY PQE - 8
         L     RWORK4,PQEPREV(RWORK4)   ADDRESS OF REAL PQE
         OC    PQEPREV(4,RWORK4),PQEPREV(RWORK4)  IS THER A SECOND PQE
         BC    7,NOTH1DUM     YES
         OI    SWITCHES,X'10' INDICATE H1 REQUEST -H1 NOT ON SYSTEM
         MVI   HSAVE,X'00'    INDICATE H0 REQUEST
NOTH1DUM DS    0H
.GO10    ANOP
         CLI   0(RWORK1),X'80'   IS THIS THE END OF THE LIST
         BNE   NOSET
         OI    SWITCHES,X'04'    SET END OF LIST SWITCH
         AIF   ('&LCS' EQ 'Y').GO16
         LA    RADDR,0(RADDR) .         INSURE REQUEST IS FOR H0  M6377
         LTR   RADDR,RADDR  CHECK FOR A SPECIFIC REQUEST
         BNZ   GETSPEC
         B     ENDLST            END OF LIST PROCESSING
         AIF   ('&LCS' EQ 'N').GO06
.GO16    ANOP
NOSET    LA    RADDR,0(RADDR)    CLEAR HIARCHY INDICATION
         LTR   RADDR,RADDR       CHECK FOR A SPECIFIC ADDRESS REQUEST
         AGO   .GO07
.GO06    ANOP
NOSET    LTR   RADDR,RADDR       CHECK FOR A SPECIFIC ADDRESS
.GO07    ANOP
         BNZ   GETSPEC
         AIF   ('&LCS' EQ 'Y').GO18
NOTH1    AR    RWORK3,RWORK2  COMBINE LENGTH
         LA    RWORK1,4(RWORK1)  PICK UP PTR TO NEXT LENGTH
         B     NLCSGP
ENDLST   AR    RWORK2,RWORK3  COMBINE FINAL ENTRY
.GO18    ANOP
****   CHECK FOR SUFFICIENT SPACE IN SQS
*A REQUEST FOR A PARTITION WILL NOT BE SATISFIED UNLESS THERE IS   SWS
*AT LEAST 2K OF QUEUE SPACE AVAILABLE.  THE 2K LIMIT WILL BE       SWS
*COMPUTED BY SCANNING THE FREE QUEUE ELEMENTS. THE PURPOSE OF
*THRESHOLD ON QUEUE SPACE IS TO PREVENT THE INITIATION OF NEW WORK SWS
*WHENEVER AVAILABLE QUEUE SPACE FALLS BELOW THE PEAK QUEUE SPACE   SWS
*REQUIREMENTS OF THE AVERAGE JOB.  THE REASON FORCOMPUTING THE 2K FROM
*ONLY THOSE BLOCKS WHICH ARE EQUAL TO OR LARGER THAN 144 BYTES IS  SWS
*TO MINIMIZE THE POSSIBILITY OF A E04 WAIT STATE BY INCREASING
*THE AVERAGE SIZE OF THE FREE BLOCKS CLOSER TO THE AVERAGE SIZE    SWS
*REQUEST GENERETED BY THE INITIATION OF NEW WORK.                  SWS
*
*        FORMAT OF GOVRFLB                                         SWS
*
*        ****************************************
*        *                                       *
*        * FLAG    *  UPPER BOUND OF             *                 SWS
*  +0    *  BYTE   *                             *                 SWS
*        *         *           S. Q. S.          *                 SWS
*        *         *                             *
*        *****************************************
*        *                                       *
*        *  ADDRESS  OF  D.Q.E.                  *                 SWS
*  +4    *                                       *
*        *   FOR S. Q. S.                        *                 SWS
*        *                                       *
*        *****************************************
*        *                                       *
*        *  ADDRESS OF  PQE                      *                 SWS
*  +8    *                                       *
*        * FOR AVAILABLE MAIN STORAGE            *                 SWS
*        *                                       *
*        *****************************************
*        *                                       *
*        *         AVAILABLE                     *                 SWS
*  +12   *                                       *                 SWS
*        *      CORE STORAGE SIZE IN H0          *                 SWS
*        *                                       *
*        *****************************************
*        *                                       *
*        *  CORE STORAGE AVAILABLE IN H1         *                 SWS
*   +16  *                                       *                 SWS
*        *****************************************
*        *                                       *
*        *  ORIGIN OF THE VQE QUEUE FOR MP65     *                 SWS
*  +20   *                                       *                 SWS
*        *****************************************
*        *                                       *
*        * NIPSQSBD SQS BOUNDRY FOR NIP & RORI   *
*  +24   *                                       *
*        *****************************************
*
*
*  FLAG BYTE AT OFFSET 0                                           SWS
*
*
*  SET TO X'80' WHEN A TASK IA MADE NON-DISPATCHABLE BECAUSE       SWS
* INSUFFICIENT QUEUE SPACE WAS AVAILABLE TO START NEW WORK.        SWS
*  THIS FLAG BYTE WILL BE RESET TO ZERO WHENEVER EITHER A FREEPART SWS
*IS ISSUED OR WHENEVER QUEUE SPACE IS FREED.                       SWS
         SPACE 4
NOSET1   TM    SWITCHES,X'80'      IS THIS AN EXCHANGE REQUEST   A29400
         BO    COMP2KB             YES, BYPASS CHECK ON SQS      A29400
         AIF   ('&LCS' EQ 'N').GOAA                            @SA70977
         TM    SWITCHES,X'20'      CHECK ONE DONE SW           @SA70977
         BO    COMP2KB             YES-BYPASS 2ND SQA CHK      @SA70977
.GOAA    ANOP                                                  @SA70977
         SR    RADDR,RADDR                                       A29400
         L     RWORK3,OVRFLB      GOVRFLB
         L     RWORK3,4(RWORK3)   PTR TO SQS AREA
         L     RWORK3,FQENXT(RWORK3) .  PTR TO FIRST FQE         A40395
         LTR   RWORK3,RWORK3          END OF QUEUE
         BZ    NOSQS          YES-NO SQS AVAILABLE             @JK69023
CKLOOP   A     RADDR,FQELNTH(RWORK3)  INCR COUNT OF FREE SQS     A40395
CKTTL    C     RADDR,SQSMIN   IS THERE SUFFICIENT SYS QUE SPACE TO 3645
*                             INITIATE A JOB STEP
         BC    10,COMP2KB         YES, 2K OR MORE IS AVAILABLE.  GO
*                                 TO PROCESS GETPART REQUEST       SWS
         L     RWORK3,FQENXT(RWORK3) .    PTR TO NEXT FQE        A40395
         LTR   RWORK3,RWORK3 .            END OF QUEUE           A40395
         BNE   CKLOOP .                 NO                       A40395
NOSQS    L     RWORK3,OVRFLB NO-2K OF SQS IS NOT           SWS @JK69023
         OI    0(RWORK3),X'80'     AVAILABLE.                      SWS
         B     INITWAIT           SET FLAG IN GOVRFLB AND MAKE TASKSWS
*                                 NON-DISPATCHABLE                 SWS
COMP2KB  DS    0H                                                  SWS
*****  THIS CODE DETERMINES IF THE REQUEST IS VALID
         L     RWORK3,OVRFLB          GOVRFLB
         L     RWORK3,8(RWORK3)       DUMMY PQE - 8
         L     RWORK3,PQEPREV(RWORK3)   LAST OR ONLY PQE
         AIF   ('&LCS' EQ 'N').GO20
         CLI   HSAVE,X'01'       WAS H1 SPECIFIED
         BNE   CKNOTH1           NO
         CLI   PQEHID(RWORK3),X'01'   IS THIS H1 PQE
         BE    CKPQEFND
         OC    PQEPREV(4,RWORK3),PQEPREV(RWORK3) 2361 ONLINE ?     I283
         BNZ   CKOTHPQE            YES  GET OTHER PQE              I283
         MVI   HSAVE,X'00'         INDICATE CORE FROM HIAR ZERO    I283
         OI    SWITCHES,X'10'      H1 REEQUEST & 2361 OFFLINE      I283
         B     CKPQEFND            PROCESS AS H0 REQUEST         I283
CKOTHPQE L     RWORK3,PQEPREV(RWORK3) HAS TO BE OTHER PQE
         B     CKPQEFND
CKNOTH1  CLI   PQEHID(RWORK3),X'00'   IS THIS H0 PQE
         BE    CKPQEFND               YES
         B     CKOTHPQE               THE OTHER IS H1
.GO20    ANOP
CKPQEFND L     RWORK3,PQERGSZ(RWORK3) SIZE OF CORE DESCRIBED BY PQE
         LA    RWORK2,0(RWORK2)    CLEAR HI ORDER BYTE
         CR    RWORK2,RWORK3  IS REQUEST FOR MORE THAN IS
         AIF   ('&LCS' EQ 'N').GO71
         BH    RETURN08  AVAILABLE - BRANCH IF YES
         AGO   .GO68
.GO71    ANOP
         BH    RTN08                  AVAILABLE - BRANCH IF YES
.GO68    ANOP
*        THIS SECTION OF CODE DETERMINES THE NUMBER OF 2K BLOCKS
*        NEEDED FOR A PARTITION AND GETS THEM
         LA    RWORK1,2047
         LR    RWORK3,RWORK1
         AR    RWORK1,RWORK2          RWORK2 CONTAINS THE LENGTH
         OR    RWORK1,RWORK3
         XR    RWORK1,RWORK3
         AIF   ('&LCS' EQ 'N').GO21
         L     RWORK3,ADSVCB  ADDRESS OF SVC BYTE - SVC BYTE + 1 IS
         MVC   1(1,RWORK3),HSAVE      HIARCHY BYTE IN GETMAIN
.GO21    ANOP
         L     RCOMRET1,FBSRCH
         BALR  RCOMRET1,RCOMRET1
** OUTPUT OF FBQSRCH  RBLOCK = ADDRESS OF FIRST AVAILABLE BLOCK (14)
****                  RSIZE  = NUMBER OF BYTES (15)
COREOK   B     CKONEDN        CORE HAS BEEN OBTAINED
SRTN04   DS    0H             FROM SPECIFIC REQUEST WHEN UNSATISFIED
         AIF   ('&LCS' EQ 'N' AND '&RORI' EQ 'N').GO22
         TM    SWITCHES,X'20' CORE NOT GOTTEN - CHECK ONE DONE SW
         BZ    RTN04
         AIF   ('&RORI' EQ 'N').GO23
         TM    SWITCHES,X'40' CHECK FOR RO/RI REQUEST
         BO    RTN04          YES-RO/RI DON'T FREE ANY CORE
.GO23    ANOP
         OI    SWITCHES+1,X'02'    INDICATE  UNSATISFIED REQUEST
         B     FREEPART
         AGO   .GO24
.GO22    ANOP
         B     RTN04
.GO24    ANOP
CKONEDN  DS    0H
         L     QGM2BS,DBASADR .            LOAD QGM'S 2ND BAS     M2883
         A     QGM2BS,CON1K .      ADD 1 K DISP FOR 2ND BAS       M2883
         TM    SWITCHES,X'80'      IS THIS AN EXCHANGE REQUEST
         BO    PQENH1A        DO NOT OBTAIN CORE FOR PQE'S
         AIF   ('&LCS' EQ 'N' AND '&RORI' EQ 'N').GO26
         TM    SWITCHES,X'20'      CHECK ONE DONE SW
         BO    NODUMMY             YES-DUMMY EXISTS
.GO26    ANOP
         LA    RIN1,DUMPQESZ       LENGTH NEED FOR PQE
         L     RCOMRET,PQEMAIN
         BALR  RCOMRET,RCOMRET     GETMAIN FOR DUMMY
         SH    RIN1,DUMQELTH+2     TCB POINTS TO DUMMY - 8
         ST    RIN1,TCBPQE(RTCB)   INITIALIZE TCBPQE TO POINT TO DUMMY
NODUMMY  LA    RIN1,PQESIZE
         L     RCOMRET,PQEMAIN
         BALR  RCOMRET,RCOMRET     GETMAIN FOR PQE
         AIF   ('&RORI' EQ 'N').GO28
         ST    RIN1,PQESAVE        SAVE PTR TO GIVE BACK FOR RORI
.GO28    ANOP
         AIF   ('&LCS' EQ 'N').GO34
         TM    SWITCHES,X'10' CHECK H1 SW - H1 REQUEST BUT NO H1 ON SYS
         BZ    PQEH1OK
         MVI   PQEHID(RIN1),X'01'   INDICATE H1 IN PQE
         B     PQENH1
PQEH1OK  MVC   PQEHID(1,RIN1),HSAVE  PLACE ACTUAL HIARCHY ID IN PQE
.GO34    ANOP
PQENH1   ST    RIN1,FWDPTR(RBLOCK)     INITIALIZE FBQE BACKWARD POINTER
         ST    RIN1,BCKPTR(RBLOCK)     INITIALIZE FBQE BACKWRD POINTER
         ST    RSIZE,FBQESIZE(RBLOCK)  PUT SIZE IN FBQE
         ST    RBLOCK,PQESTADD(RIN1)   INITIALIZE REGION START ADDR
         ST    RSIZE,PQERGSZ(RIN1)     INITIALIZE REGION SIZE
         ST    RBLOCK,FWDPTR(RIN1)     INITIALIZE PQE FORWARD POINTER
         ST    RBLOCK,BCKPTR(RIN1)     INITIALIZE PQE BACKWARD POINTER
         TM    SWITCHES,X'80'      CHECK FOR EXCHANGE REQUEST
         BO    CKENDLST       SKIP PQE POINTER INITIALIZATION
         ST    RTCB,PQETCB(RIN1)       INITIALIZE  PQE TCB POINTER
         L     RWORK1,TCBPQE(RTCB)     PICK UP DUMMY
         AIF   ('&LCS' EQ 'N' AND '&RORI' EQ 'N').GO31
         AIF   ('&RORI' EQ 'N').GO96
         TM    SWITCHES,X'60' CHECK RO/RI AND ONE DONE SWITCH
         BO    RTN00       RO/RI REQUEST - DON'T QUEUE PQE'S
         AIF   ('&LCS' EQ 'N').GO31
         BM    PQEQUE    ONE DONE SWITCH ON ALONE
         AGO   .GO97
.GO96    ANOP
         TM    SWITCHES,X'20'          CHECK ONE DONE SW
         BNZ   PQEQUE
.GO97    ANOP
         ST    RIN1,PQENXT(RWORK1)     SET UP DUMMY TO POINT TO PQE
         ST    RIN1,PQEPREV(RWORK1)
         B     CKENDLST
PQEQUE   L     RWORK1,PQEPREV(RWORK1)  PICK UP HIGH ADDR PQE
         LTR   RWORK1,RWORK1   WAS PREVIOUS PQE LAST
         BZ    INSRTFST        YES INSERT NEW PQE AS FIRST
         CLC   PQESTADD+1(3,RIN1),PQESTADD+1(RWORK1) IS NEW REG ADDR
         BL    PQEQUE         LOWER THAN PREVIOUS PQE IF NOT FALL THRU
         CLC   PQENXT+1(3,RIN1),PQENXT+1(RWORK1)  CHECK PQENXT = 0
         BE    INSRTLST     YES INSERT NEW PQE LAST
INSRTBTW MVC   PQENXT+1(3,RIN1),PQENXT+1(RWORK1) NEW PQENXT EQU OLD
         ST    RWORK1,PQEPREV(RIN1)  OLD NOW PREV TO NEW
         ST    RIN1,PQENXT(RWORK1)   NEW NOW NEXT TO OLD
         L     RWORK1,PQENXT(RIN1)   NEW PQE'S NEXT
         ST    RIN1,PQEPREV(RWORK1)  OLD PREVIOUS NOW POINTS TO NEW
         B     CKENDLST
INSRTFST L     RWORK1,TCBPQE(RTCB)  DUMMY - QUEUE FIRST PQE
         L     RSIZE,PQENXT(RWORK1)   OLD NEXT
         ST    RIN1,PQENXT(RWORK1)    NEW NOW NEXT OFF DUMMY
         ST    RIN1,PQEPREV(RSIZE)    OLD PREVIOUS NOW NEW PQE
         ST    RSIZE,PQENXT(RIN1)     OLD NOW NEXT FOR NEW
         B     CKENDLST
INSRTLST ST    RWORK1,PQEPREV(RIN1)   OLD NEW PREVIOUS TO NEW
         ST    RIN1,PQENXT(RWORK1)    NEW NOW NEXT FOR OLD
         L     RWORK1,TCBPQE(RTCB)    DUMMY
         ST    RIN1,PQEPREV(RWORK1)   DUMMY LAST NOW POINTS TO NEW
         B     CKENDLST
         AGO   .GO35
.GO31    ST    RIN1,PQENXT(RWORK1)    SET UP DUMMY TO POINT TO PQE
         ST    RIN1,PQEPREV(RWORK1)
.GO35    ANOP
CKENDLST DS    0H
         AIF   ('&LCS' EQ 'N' AND '&RORI' EQ 'N').GO35A
         TM    SWITCHES,X'20'         CHECK ONE DONE SW
         BO    LISTENCK               YES SPACE ALREADY OBTAINED IN 252
.GO35A   ANOP
         TM    SWITCHES,X'08'      WAS REQUEST ACTUAL
         BO    LISTENCK            YES DON'T GET CORE IN SUBPOOL 252
GET252   L     RIN0,RESERVE   SET UP TO GET 8 BYTES FROM SP 252
         LCR   RIN1,RIN1      TO RESERVE 2K BLOCK
         L     RBLOCK,REGMAIN
         BALR  RBLOCK,RBLOCK
LISTENCK DS    0H
         AIF   ('&LCS' EQ 'N').GO38
         TM    SWITCHES,X'84' END OF LIST OR FREE EXCHANGE REQUEST
         BC    7,COMRTN0   YES
         OI    SWITCHES,X'20'      SET ONEDONE SW
         L     RWORK1,WORK1SV         PICK UP POINTER TO
         L     RADDR,ADDRSV              NEXT LENGTH ENTRY
         LA    RWORK1,4(RWORK1)       PICK UP POINTER TO
         LA    RADDR,4(RADDR)            NEXT ADDRESS ENTRY
         B     LISTGP
         AGO   .GO40
.GO38    ANOP
         B     COMRTN0
.GO40    ANOP
REGREQ   LR    RWORK2,RLENGTH LENGTH OF REGION REQUEST AND SPID
         AIF   ('&LCS' EQ 'N').GO95
         L     RWORK3,ADSVCB ADDRESS SVCBYTE + 1 IS ADDRESS OF     I283
         MVC   HSAVE(1),1(RWORK3)  HIARCHY BYTE IN GETMAIN         I283
.GO95    ANOP
         B     SETLSTED
ELEREQ   L     RWORK2,0(RIN1) LENGTH OF REGION REQUEST
         AIF   ('&RORI' EQ 'N').GO45
         TM    SWITCHES,X'40'   IS REQUEST FROM RORI
         BZ    NOTELROR
         OI    SWITCHES,X'20'      SET ONE DONE SWITCH
NOTELROR DS    0H
.GO45    ANOP
         AIF   ('&LCS' EQ 'N').GO43
         MVC   HSAVE(4),4(RIN1)    SAVE HIARCHY INDICATION
.GO43    ANOP
SETLSTED DS    0H
         AIF   ('&LCS' EQ 'N').GO44
         OI    SWITCHES,X'04'     SET END OF LIST INDICATION
.GO44    ANOP
         B     NOSET1
FREXCHNG OI    SWITCHES,X'80'     INDICATE REQUEST IS EXCHANGE
         L     RWORK1,ADSVCB       ADDRESS OF SVC BYTE
         CLI   0(RWORK1),4          IS THIS AN SVC 4
         BNE   FREEPART
         OI    SWITCHES,X'01'  INDICATE SVC 4
FREEPART L     RRET,PURGE
         BALR  RRET,RRET          BRANCH TO COPURGE
         NOP   *+4
         AIF   (NOT &MP).MP02PTM                                   MP1A
FREEMPST DS    0H
.MP02PTM ANOP                                                      MP1A
         AIF   ('&RORI' EQ 'N').GO86
          L     RWORK2,RORIQUE PICK UP ADDRS OF QUEUED ROLLOUT REQUESTS
          L     RWORK2,0(RWORK2)
          LTR  RWORK2,RWORK2 ARE ANY REQUESTS OUTSTANDING
         BZ    SETINIT  NO CONTINUE
         LR    RWORK1,RBASE SAVE BASE REGISTER OF GETPART
         L     RBASE,GETIQE GET ADDRESS OF GETIQE SUBROUTINE
         BALR  RCOMRET,RBASE  GET AN IQE
         LR    RBASE,RWORK1  RESTORE BASE
         SR    RWORK1,RWORK1
         L     RWORK2,ADDRSNEW PICK UP ADDRESS OF 'NEW'
         ST    RWORK1,0(RWORK2) ZERO OUT NEW TO CAUSE TASK SWITCH
         ST    RWORK1,4(RIQE) ZERO LINK FIELD OF IQE FOR DEQUEUE
         LCR   RIQE,RIQE  COMPLEMENT IQE ADDRESS
         L     RRETURN,16(0) PICK UP CVT
         L     RRETURN,CVT0EF00(RRETURN)
         BALR  RRETURN,RRETURN  SCHEDULE IRB FOR ROLLOUT
SETINIT  DS    0H
.GO86    ANOP
         CLI   WAITSW,X'FF'    WAIT SWITCH ON
         BE    WAITOFF
         AIF   ('&LCS' EQ 'N').GO86A                             A32425
         TM    SWITCHES+1,X'02' .    WAS REQ SATISFIED           A32425
         BO    SUBPOLCK .            NO, RELE SPQE FROM SQA      A32425
.GO86A   ANOP                                                    A32425
         BAL   RCOMRET,DISPINIT
         SPACE 1
*
*        THIS ROUTINE RELEASES THE EIGHT BYTES IN SUBPOOL 252 USED TO
*        RESERVE A 2K BLOCK
*
SUBPOLCK EQU   *                   ENTRY TO RELEASE STORAGE        MP1A
         AIF   (NOT &MP).MP06                                      MP1A
         TM    SWITCHES+1,X'40'   TEST FOR A MP BRANCH ENTRY       MP1A
         BO    RETURN  YES - BYPASS RELEASE STORAGE                MP1A
.MP06    ANOP                                                      MP1A
         L     RSPQE,TCBMSS(RTCB)  PICK UP ADDRESS OF FIRST SPQE   MP1A
         LA    RSPQE,0(RSPQE)     CLEAR HI ORDER BYTE
         LTR   RSPQE,RSPQE         Q-TCBMSS ZERO                   MP2K
         BZ    RETURN              YES EXIT                        MP2K
         B     SPQE252B
SPQE252  L     RSPQE,0(RSPQE)     PICK UP NEXT SPQE
SPQE252B CLI   SPQID(RSPQE),252   IS IT SPQE FOR SUBPOOL 252
         BE    SPQE252A
         TM    SPQEFLGS(RSPQE),SPQELAST
         BC    1,SPQECHK2         LAST SPQE
         B     SPQE252            CHECK NEXT SPQE
SPQE252A L     RDQE,SPQEDQE(RSPQE) PICK UP ADDRESS OF DQE
         LA    RDQE,0(RDQE)
         LTR   RDQE,RDQE          HAS SUBPOOL 252 BEEN FREED
         BZ    SPQECHK2           YES
         L     RFQE,DQEFQE(RDQE)  PICK UP ADDRESS OF FQE
         L     RIN1,FQELNTH(RFQE) PICK UP LENGTH FROM FQE
         C     RIN1,FQE252  IS 2K BLOCK FREE EXCEPT FOR 8 BYTES    3645
         BNE   GERROR2 ALL CORE NOT FREE   (GERROR2)
         LA    RFQE,0(RFQE)        CLEAR HIGH ORDER BYTE
         AR    RIN1,RFQE  COMPUTE ADDRESS OF CORE TO BE FREED
         L     RIN0,RESERVE       SET UP REG 0 FOR REGMAIN
         L     RRETURN,REGMAIN    PICK UP ADDRESS OF REGMAIN
         BALR  RRETURN,RRETURN    FREE 8 BYTES USED TO RESERVE 2K BLCOK
         SPACE 1
SPQECHK2 L     RSPQE,TCBMSS(RTCB) PICK UP SPQE POINTER
         LA    RSPQE,0(RSPQE)     CLEAR HI ORDER BYTE
         LTR   RSPQE,RSPQE         Q-TCBMSS ZERO                   MP2K
         BZ    RETURN              YES EXIT                        MP2K
SPQECHK  L     RDQE,SPQEDQE(RSPQE) PICK UP DQE POINTER FROM SPQE
         TM    SPQEFLGS(RSPQE),SPQESHRD  IS THIS A SHARED SUBPOOL
         BZ    NOSHARE1      NO NOT SHARED
         L     RDQE,SPQEDQE(RDQE) PICK UP DQE POINTER FROM OWNER
NOSHARE1 LA    RDQE,0(RDQE) CLEAR HI ORDER BYTE
         LTR   RDQE,RDQE          ANY STORAGE ASSIGNED TO SUBPOOL
         BC    7,GERROR2  ERROR
         TM    SPQEFLGS(RSPQE),SPQELAST    IS THIS LAST SPQE
         BO    FREEPQE            YES
         L     RSPQE,SPQENXT(RSPQE) NO- PICK UP POINTER TO NEXT SPQE
         B     SPQECHK             CHECK NEXT SUBPOOL
FREEPQE  DS    0H
         AIF   ('&LCS' EQ 'N').GO52
         TM    SWITCHES,X'80'      IS THIS AN EXCHANGE REQUEST
         BO    YESEXCH0       YES - JUST FREE THE REGION NOT THE PQE
         L     RIN1,TCBPQE(RTCB)
         LA    RIN1,0(RIN1)        CLEAR HI ORDER BYTE         @AS77039
         LTR   RIN1,RIN1           CHECK FOR ZERO              @AS77039
         BZ    RETURN              IF ZERO RETURN V1           @AS77039
         MVC   PQESAVE(4),PQEPREV(RIN1) SAVE ADDR OF LAST OR ONLY PQE
         L     RIN1,PQEPREV(RIN1)  LAST PQE
FRNXTPQE L     RBLOCK,FWDPTR(RIN1) ADDRESS OF PARTITION
         L     RSIZE,FBQESIZE(RBLOCK)   PICK UP PARTITION SIZE
         L     RPQE,OVRFLB
         L     RPQE,8(RPQE)   POINTER TO DUMMY
         L     RPQE,PQENXT(RPQE)       &OINTER TO FIRST PQE
         CLI   PQEHID(RIN1),X'01'  WAS THIS PQE FOR H1
         BNE   NOTPQEH1       NO
         OC    PQENXT(4,RPQE),PQENXT(RPQE) IS THERE AN H1 PQE OFF GOVFB
         BZ    NOTPQEH1       NO GIVE CORE BACK TO H0 PQE
         L     RPQE,PQENXT(RPQE)      H1 PQE
NOTPQEH1 L     RCOMRET,RELEASE
         OC    PQEPREV(4,RIN1),PQEPREV(RIN1)  IS THIS THE LAST PQE
         BNZ   NLASTPQE    NO
         OI    SWITCHES+1,X'01'  INDICATE LAST PQE
NLASTPQE BALR  RCOMRET,RCOMRET  GO TO MRELEASE TO FREE REGION
         L     RIN1,PQESAVE  PQE TO BE FREED
         L     RWORK1,PQEPREV(RIN1)   ADDRESS OF NEXT PQE TO BE FREED
         L     OWNGTCB,PQETCB(RIN1) .   GET OWNING TCB       BL   M0459
         ST    RWORK1,PQESAVE
         L     RIN0,QELNTH    SET REG 0 FOR REGMAIN
         L     RRETURN,REGMAIN
         BALR  RRETURN,RRETURN  FREE PQE
         TM    SWITCHES+1,X'01'   WAS THIS LAST PQE
         BO    ALLBUTDM
         L     RIN1,PQESAVE     NEXT PQE TO BE FREED
         B     FRNXTPQE
         AGO   .GO54
.GO52    ANOP
         L     RIN1,TCBPQE(RTCB)  PICK UP ADDRESS OF DUMMY
         LA    RIN1,0(RIN1) . CLEAR HIGH ORDER BYTE            @JK69389
         LTR   RIN1,RIN1 .    IS  IT ZERO                      @JK69389
         BZ    RETURN .       YES                              @JK69389
         L     RIN1,DUMFWD(RIN1)  PICK UP PQE ADDRESS
         ST    RIN1,PQESAVE   SAVE PQE ADDR FOR USE IN GETPART
         L     RBLOCK,FWDPTR(RIN1) ADDRESS OF PARTITION
         L     RSIZE,FBQESIZE(RBLOCK)  PICK UP PARTITION SIZE
         L     RPQE,OVRFLB
         L     RPQE,8(RPQE)   ADDRESS OF SYSTEM DUMMY
         L     RPQE,DUMBWD(RPQE)
         L     RCOMRET,RELEASE
         BALR  RCOMRET,RCOMRET            RELEASE PARTITION
         TM    SWITCHES,X'80' .         IS THIS AN EXCHANGE      A36202
         BO    YESEXCH1 .                   REQUEST              A36202
         AIF   (NOT &MP).MP01                                      MP1A
         STM   R0,R15,VQERSAV     SAVE REGS WHILE TEST FOR VQES    MP1A
         L     R2,TCBPQE(RTCB)    ADDR OF DUMMY PQE                MP1A
         L     R2,DUMFWD(R2)      ACTUAL PQE                       MP1A
         BAL   R1,IFSVRYOF        TEST IF VQE WAIT FOR PARTN STRG  MP1A
         USING *,R1               ADDRESSSIBILITY                  MP1A
         LM    R0,R15,VQERSAV     RESTORE REGS                     MP1A
         DROP  R1                                                  MP1A
.MP01    ANOP
         L     RIN1,TCBPQE(RTCB)       ADDRESS OF DUMMY
         L     RIN1,DUMFWD(RIN1)   ACTUAL PQE
         L     OWNGTCB,PQETCB(RIN1) .   GET OWING TCB        BL   M0459
         L     RIN0,QELNTH SET REG 0 FOR REGMAIN
         L     RRETURN,REGMAIN
         BALR  RRETURN,RRETURN     FREE REAL PQE
.GO54    ANOP
ALLBUTDM L RIN1,TCBPQE(RTCB)  POINTER TO DUMMY - 8
         LA    RIN1,8(RIN1)       POINTER TO DUMMY
         L     RIN0,DUMQELTH      SET REG 0 FOR REGMAIN FOR DUMMY
         L     RRETURN,REGMAIN
         XC    TCBPQE(4,OWNGTCB),TCBPQE(OWNGTCB) . 0 TCBPQE  BL   M0459
         XC    TCBPQE(4,RTCB),TCBPQE(RTCB) SET TCB POINTER TO ZERO
         BALR  RRETURN,RRETURN
         B     RTN00
         AIF   ('&LCS' EQ 'N').GO55
YESEXCH0 L RIN1,TCBPQE(RTCB)   DUMMY
         L     RIN1,DUMFWD(RIN1)   FIRST PQE
         CLI   PQEHID(RIN1),X'00'  IS THIS H0 PQE
         BE    RIGHTPQE
         OC    PQENXT(4,RIN1),PQENXT(RIN1) NO - IS THIS ONLY PQE ? I283
         BE    RIGHTPQE            YES - REPLACING H1 SEGMENT      I283
         L     RIN1,PQENXT(RIN1)   THIS MUST BE H0 PQE
RIGHTPQE L     RBLOCK,FWDPTR(RIN1) ADDRESS OF PARTITION
         L     RSIZE,PQERGSZ(RIN1)   ADDR OF REGION TO BE FREED
         ST    RIN1,PQESAVE   SAVE PQE ADDR FOR USE IN GETPART
         L     RPQE,OVRFLB
         L     RPQE,8(RPQE)       ADDRESS OF DUMMY
         L     RPQE,PQENXT(RPQE)   ADDRESS OF H0 PQE
         L     RWORK3,ADSVCB       ADDR TABLE IN GETMAIN WITH      I283
*                                   HIARCHY BYTE                   I283
         MVI   1(RWORK3),0         GETPART IS FOR H0 AT THIS PT.   I283
         CLC   PQEHID(1,RPQE),PQEHID(RIN1) REPLACING H1 SEGMENT ?  I283
         BE    SAMEID              NO - RETURN CORE TO H0 PQE      I283
         MVI   1(RWORK3),1           GETPART FOR H1                I283
         OC    PQENXT(4,RPQE),PQENXT(RPQE) IS 2361 ONLINE ?        I283
         BE    SAMEID              NO - RETURN CORE TO H0 PQE      I283
         L     RPQE,PQENXT(RPQE)   RETURN CORE TO H1 PQE           I283
SAMEID   DS    0H                                                  I283
         L     RCOMRET,RELEASE
         BALR  RCOMRET,RCOMRET     RELEASE PARTITION
.GO55    ANOP
YESEXCH1 LM    RRETURN,RIN1,RINSAVE
         TM    SWITCHES,X'01' IS REQUEST SVC 4
         BO    GPART
         LR    RLENGTH,RIN0                                        SWS
         LA    RLENGTH,0(RLENGTH)  CLEAR HIGH ORDER BYTE           I283
         B     REGREQ
COMRTN0 DS     0H
         AIF   ('&LCS' EQ 'N').GO57
         L     RWORK1,TCBPQE(RTCB)   POINTER TO DUMMY
         L     RWORK1,PQENXT(RWORK1)    FIRST PQE
         OC    PQENXT(4,RWORK1),PQENXT(RWORK1) ARE THERE 2 PQE'S
         BZ    NOCKNEED       NO
         L     RWORK2,PQENXT(RWORK1)
         CLC   PQESTADD(4,RWORK1),PQESTADD(RWORK2) ARE PQE'S IN
         BL    NOCKNEED    ASCENDING ORDER  -  YES
         MVC   PQENXT(4,RWORK2),PQEPREV(RWORK2)   SWAP PQE'S
         MVC   PQEPREV(4,RWORK2),ZEROES
         MVC   PQEPREV(4,RWORK1),PQENXT(RWORK1)
         MVC   PQENXT(4,RWORK1),ZEROES
         L     RWORK1,TCBPQE(RTCB)   NOW SWAP DUMMY
         MVC   PQESAVE(4),PQENXT(RWORK1)
         MVC   PQENXT(4,RWORK1),PQEPREV(RWORK1)
         MVC   PQEPREV(4,RWORK1),PQESAVE
NOCKNEED DS    0H
.GO57    ANOP
         TM    SWITCHES,X'C0'  IS THIS AN EXCHANGE OR RORI REQ. ?
         BNZ   RTN00               YES
         CLI   WAITSW,X'FF'        WAIT SW ON
         BNE   RTN00         NO RETURN
         TM    SWITCHES,X'08'                  G/P SPEC REG       M3865
         BZ    RTN00                            NO RETURN         M3865
         BAL   RCOMRET,DISPINIT  SET INITIATORS WAITING FOR A REGION
***                          DISPATCHABLE
         MVI   WAITSW,X'00'  TURN OFF WAIT SW
         B     RTN00
*
*
*  THIS ROUTINE IS ENTERED TO SCAN THE TCB READY QUEUE FOR TASKS   SWS
* WHICH ARE NON-DISPATCHABLE EITHER BECAUSE A GETPART COULD NOT BE SWS
* SATISFIED OR BECAUSE THE 2K THRESHOLD ON QUEUE SPACE HAD BEEN    SWS
* REACHED.                                                         SWS
*  IT IS ENTERED EITHER WHEN A FREEPART IS ISSUED OR A FREEMAIN FORSWS
* QUEUE SPACE.                                                     SWS
*  IT WILL RESET THE FLAG IN GOVRFLB IN ORDER TO PREVENT FREEMAIN  SWS
* FROM EXECUTING THIS ROUTINE WHEN IT IS NOT NECESSARY.            SWS
*  FREEMAIN E WILL EXECUTE THIS SUBROUTINE ONLY WHEN THE FLAG      SWS
* IS ON.                                                           SWS
         SPACE 4
DISPINIT STM   RIN0,RSIZE,RIPSAVE  SAVE ALL XRS                    SWS
         L     RCVT,OVRFLB        GET ADDRESS OF GOVRFLB           SWS
         NI    0(RCVT),X'7F'       RESET GOVRFLB FLAG            A29400
         L     RCVT,16(0)               LOAD CVT POINTER
         L     TSWCH,CVTHEAD(RCVT) LOAD HIGHEST PRIORITY TCB IN SYSTEM
RIP1     LTR   TSWCH,TSWCH         ARE WE AT END OF READY QUEUE
         BC    7,RIP2              YES - RETURN
         LM    RIN0,RSIZE,RIPSAVE  RESTORE XRS                     SWS
         BR    RCOMRET
RIP2     TM    TCBFCD1(TSWCH),2    IS TCB IN WAIT FOR CORE
         BZ    RIP3                NO - GET NEXT TCB
         AIF   ('&RORI' EQ 'N').GO88
         L     RWORK1,TCBPQE(TSWCH)
         LTR   RWORK1,RWORK1
         BNZ   RIP3
.GO88    ANOP
         NI    TCBFCD1(TSWCH),X'FD' TURN OFF WAIT BIT
         LR    RSWCH,RBASE         SAVE BASE REGISTER OVER TSWITCH
         L     RBASE,TASKSWCH      GO TO TASK SWITCH ROUTINE
         BALR  RRETURN,RBASE
         LR    RBASE,RSWCH         RESTORE BASE REG
RIP3     L     TSWCH,TCBTCB(TSWCH) NEXT TCB ON READY QUEUE
         B     RIP1
RTN08    LA    RRETREG,8
         B     RETURN
RTN04    LA    RRETREG,4
         TM    SWITCHES,X'08'  WAS REQUEST SPECIFIC
         BZ    CKFORIWT
         L     RWORK1,RINSAVE+12   R1 AT ENTRY                 @AS75900
         TM    8(RWORK1),X'20'     CONDITIONAL REQUEST         @AS75900
         BO    RETURN              YES,NO WAIT NEEDED          @AS75900
         MVI   WAITSW,X'FF'  TURN ON WAIT SW
         ST    RTCB,TCBSAVE
CKFORIWT TM    SWITCHES,X'01' IS REQUEST SVC 4
         BZ    INITWAIT            NO CAN'T BE A CONDITIONAL REQUEST
         L     RWORK1,RINSAVE+12   R1 WHEN ENTERED
         TM    8(RWORK1),X'20'     WAS REQUEST CONDITIONAL
         BZ    INITWAIT       NO - NOT CONDITIONAL
RETURN   L     RRETURN,RINSAVE
         LM    RIN0,RIN1,RINSAVE+8 RESTORE REGS
         AIF   ('&RORI' EQ 'N').GO64
         TM    SWITCHES,X'40'  IS REQUEST FROM RO/RI
         BZ    NORORI      NO
         LTR   RRETREG,RRETREG  HAS REQUEST BEEN SATISFIED
         BP    NORORI   NO
         L     RWORK1,4(RIN1)  POINTER TO PARM LIST ENTRY
         MVC   0(4,RWORK1),PQESAVE  PLACE ADDRESS OF PQE IN PARM LIST
.GO64    ANOP
NORORI   BR    RRETURN  RETURN
INITWAIT OI    TCBFCD1(RTCB),2     INDICATE INITIATOR WAITING FOR
**                             PARTITION OR SQS SPACE
         XC    TCBPQE(4,RTCB),TCBPQE(RTCB)
         L     RWORK1,36       LOAD RIGHT HALF OF PSW
         LA    RWORK2,2
         LTR   RWORK1,RWORK1  TEST ILC                         @JK69024
         BNM   STUPRISS .     ILC FOR HALF WORD                @JK69024
         AR    RWORK2,RWORK2  ILC FOR FULL WORD                @JK69024
STUPRISS SR    RWORK1,RWORK2  ADDRESS FOR REISSUE              @JK69024
         ST    RWORK1,36       STORE PSW
         L     RCVT,16(0)      RELOAD CVT ADDR
         L     RWORK3,CVTTCB(RCVT)  LOAD ADDRESS OF NEW
         CLC   0(4,RWORK3),4(RWORK3)
         BNE   RETURN .
         SR    RWORK1,RWORK1
         ST    RWORK1,0(RWORK3)  SET NEW TO 0  CAUSE TASK SWITCH
         B     RETURN .
RTN00    LA    RRETREG,0
         AIF   ('&LCS' EQ 'N').GO82
         TM    SWITCHES+1,X'06'  WAS THIS AN UNSATISFIED REQUEST
         BO    RTN08             YES - FROM RETURN08
         BM    RTN04             YES - FROM FBQSRCH
.GO82    ANOP
         B     RETURN
GERROR2  LA    RIN1,X'20A'  SUBTASKS EXIST FOR THE TASK REQUESTING GET,
***            FREE,OR REPLACE PARTITION
         L     RRETURN,SVCXT      LOAD ADD OF SVC EXIT ROUTINE     8499
         L     RTCB,16(0)         GET THE CVT ADDRESS              8499
         L     RTCB,0(RTCB)       GET THE NEW/OLD DOUBLE WD (PSW)  8499
         L     RTCB,4(RTCB)       TCB OF CURRENT TASK TO ABTERM    8499
         TM    TCBTSTSK(RTCB),TSOTASK .IF TSO TASK, THEN          21016
         BO    GERROR2C .                DON'T MAKE ENTRY         21016
         L     RCVT,16(0) .            ADDR CVT                   21016
         L     RCVT,CVTQMSG(RCVT) .    ADDR INFOLIST              21016
         L     RABTERM,0(RCVT) .       END OF INFOLIST         AC 21016
         LA    RCVT,4(RCVT) .          FIRST ENTRY                21016
*                                                                 21016
         USING INFOLIST,RCVT .                                    21016
*                                                                 21016
GERROR2A CR    RCVT,RABTERM  .         NO ROOM FOR ENTRY          21016
         BNL   GERROR2C .               - THEN BYPASS          AC 21016
         CLC   ZEROES,INFTCB .         THIS ENTRY AVAILABLE?      21016
         BE    GERROR2B .              YES. GO SET UP INFO        21016
         LA    RCVT,INFLEN(RCVT) .     NO. CHECK IF MORE ENTRIES  21016
         B     GERROR2A .              SEARCH ALL ENTRIES.        21016
GERROR2B ST    RTCB,INFTCB .           SET UP TCB ADDRESS         21016
         TM    TCBTSTSK(RTCB),TSOTASK . IS THIS A TSO TASK    AC A49808
         BZ    ERRM2 .                 NO, BYPASS USERID      AC A49808
         L     Q13,TCBJSCB(RTCB) .     ADDR OF JSCB           AC A49808
         LA    Q13,0(Q13) .            CLEAR HI BYTE          AC A49808
         MVC   INFTJID(2),JSCBTJID(Q13) .USER ID IN INFO LIST AC A49808
ERRM2    EQU   * .                                            AC A49808
         STH   RIN1,INFCC .            SET COMPLETION CODE        21016
         ST    RTCB,INFVAR1 .          @TCB                       21016
         MVC   INFVAR2(1),4(RSPQE) .   SPID                       21016
         OI    INFRCL,X'05' .          LENGTH                     21016
         DROP    RCVT                                             21016
GERROR2C L     RABTERM,ABTERM .                                   21016
         L     RCVT,16(0) .        GET CVT ADDR FOR ABTERM   BL   M1531
         BR    RABTERM
CKTCB    C     RTCB,TCBSAVE        IS THIS THE INITIATOR THAT IS
         BE    TCBOK           WAITING - TRY FOR REGION
         B     INITWAIT
WAITOFF  L     TSWCH,TCBSAVE    ADDR OF WAITING TCB
         NI    TCBFCD1(TSWCH),X'FD'  TURN OFF WAIT BIT
         LR    RSWCH,RBASE SAVE BASE REGISTER OVER TSWITCH
         L     RBASE,TASKSWCH YES- GO TO TASK SWITCH ROUTINE
         BALR  RRETURN,RBASE
         LR    RBASE,RSWCH  RESTORE BASE REGISTER
         B     SUBPOLCK
         AIF   ('&LCS' EQ 'N').GO69
RETURN08 OI    SWITCHES+1,X'06'  INDICATE UNSATISFIED REQUEST
         TM     SWITCHES,X'20'    CHECK ONE DONE SWITCH
         BZ    RTN08
         AIF    ('&RORI' EQ 'N').GO70
         TM    SWITCHES,X'40'    IS THIS A RORI REQUEST
         BO    RTN04             DON'T FREE CORE
.GO70    ANOP
         B     FREEPART
.GO69    ANOP
         AIF   (NOT &MP).MP03PTM                                   MP1A
IEAMPSTR DS    0H
         BALR  RBASE,RIN0    ESTABLISH ADDRESSIBILITY              MP1A
         USING MPBASPTM,RBASE                                      MP1A
MPBASPTM L     RBASE,PARTBASE  PICK UP BASE ADDRESS                MP1A
         USING PART,RBASE                                          MP1A
         STM   RRETURN,RIN1,RINSAVE     SAVE REGS                  MP1A
         MVC   SWITCHES(3),ZEROES  CLEAR SWITCHES                  MP1A
         OI    SWITCHES+1,X'40'   SET MP SW FOR BRANCH ENTRY       MP1A
         B     FREEMPST    SKIP SUBPOOL CHECKING                   MP1A
.MP03PTM ANOP                                                      MP1A
***********************************************************************
*        THIS SECTION OF CODE OBTAINS CORE AT AN ACTUAL ADDRESS       *
*                                                                     *
*        OUTPUT =  RSISE= SIZE OF REGION OBTAINED IN BYTES            *
*                                                                     *
*                  RBLOCK=ADDRESS OF REGION OBTAINED                  *
*                                                                     *
*        RETURNS- COREOK = REGION OBTAINED                            *
*                                                                     *
*                SRTN04 = REGION CANNOT NOW BE OBTAINED               *
*                                                                     *
*                SRTN08 = INVALID REQUEST                             *
*                                                                     *
***********************************************************************
GETSPEC  OI    SWITCHES,X'08'  INDICATE REQUEST SPECIFIC
         LA    RWORK2,0(RWORK2) CLEAR END OF LIST INDICATOR
         L     RWORK1,OVRFLB    GOVRFLB
         L     RWORK1,8(RWORK1)         POINTER TO DUMMY  -  8
         L     RWORK1,PQENXT(RWORK1)  POINTER TO FIRST OR ONLY PQE
RETRY    C     RADDR,PQESTADD(RWORK1) IS THIS A VALID REQUEST
         BL    SRTN08            INVALID REQUEST NOT WITHIN FREE CORE
         L     RWORK3,PQESTADD(RWORK1) BEGIN ADDRESS OF SYSTEM PQE
         A     RWORK3,PQERGSZ(RWORK1)   END ADDRESS +1 OF SYSTEM REGION
         CR    RADDR,RWORK3             IS REQUEST VALID FOR THIS PQE
         AIF   ('&LCS' EQ 'N').GO72
         BNL   TRYOTHR
         AGO   .GO73
.GO72    ANOP
         BNL   SRTN08
.GO73    ANOP
         ST    RWORK2,WK2SV
         AR    RWORK2,RADDR       END ADDRESS + 1 OF REQUESTED REGION
         CR    RWORK2,RWORK3       IS THIS AN INVALID REQUEST
         BH    SRTN08
         LR    RWORK6,RWORK1      PQE ADDRESS
FBQELOOP L     RWORK6,FWDPTR(RWORK6)       PICK UP ADDRESS OF FBQE
         CR    RWORK1,RWORK6       END OF FBQE CHAIN
         AIF   (&MP).MP06A                                         MP2A
         BE    SRTN04
.MP06A   AIF   (NOT &MP).MP07                                      MP2A
         BE    CHKFSMAP            CHK FSSEMAP FOR OFFLINE         MP2A
.MP07    ANOP                                                      MP2A
         CR    RWORK6,RADDR        IS FBQE START GREATER THAN DESIRED
         AIF   (&MP).MP08                                          MP2A
         BH    SRTN04              YES REQUEST CANNOT BE SATISFIED
.MP08    AIF   (NOT &MP).MP09                                      MP2A
         BH    CHKFSMAP            CHK FSSEMAP FOR OFFLINE         MP2A
.MP09    ANOP                                                      MP2A
         L     RWORK4,FBQESIZE(RWORK6)
         AR    RWORK4,RWORK6  END ADDR + 1 OF SEGMENT DESCRIBED BY FBQE
         CR    RWORK4,RADDR        IS END ADDRESS GREATER THAN DESIRED
         BL    FBQELOOP
         CR    RWORK2,RWORK4  IS END ADDR OF REQ GREATER THAN END ADDR
         AIF   (&MP).MP11                                          MP2A
         BH    SRTN04     OF FBQE - YES - CANNOT BE SATISFIED
         AIF   (NOT&MP).NMP                                        MP2A
.MP11    BH    CHKFSMAP            OF FBQE YES CANNOT BE SATISFIEDMP2A
.NMP     LR    RSIZE,RADDR                                         MP2A
         SR    RSIZE,RWORK6   DESIRED START MINUS FBQE START
         LTR   RSIZE,RSIZE    BOTH STARTS EQUAL
         BZ    SET1
         ST    RSIZE,FBQESIZE(RWORK6)
OTHREND  SR    RWORK4,RWORK2  END ADDR OF FBQE (-) END ADDR OF REQUEST
         LR    RBLOCK,RADDR
         L     RSIZE,WK2SV
         LTR   RWORK4,RWORK4  RESULT ZERO
         BZ    CKSWX
         TM    SWITCHES+1,X'20' IS NEW FBQE NEEDED
         BO    USEOLD         NO
         ST    RWORK4,FBQESIZE(RWORK2)
         L     RADDR,FWDPTR(RWORK6)    OLD FBQE FWD PTR NOW NEW FWD
         ST    RADDR,FWDPTR(RWORK2)
         ST    RWORK2,BCKPTR(RADDR)    OLD BACK NOW POINTS TO NEW
         ST    RWORK6,BCKPTR(RWORK2)   OLD IS NOW PREVIOUS TO NEW
         ST    RWORK2,FWDPTR(RWORK6)    NEW FWD TO PREVIOUS OLD
         B     COREOK
USEOLD   MVC   0(8,RWORK2),0(RWORK6) MOVE FWD/BCK PTRS TO NEW LOCATION
         ST    RWORK4,FBQESIZE(RWORK2) STORE NEW SIZE IN DISPLACED FBQE
         L     RWORK3,FWDPTR(RWORK2) STORE NEW ADDR IN BACK POINTER
         ST    RWORK2,BCKPTR(RWORK3)   OF THE FOLLOWING FBQE
         L     RWORK3,BCKPTR(RWORK2) STORE NEW ADDR IN FORWARD PTR
         ST    RWORK2,FWDPTR(RWORK3)   OF THE PREVIOUS FBQE
         B     COREOK
CKSWX    TM    SWITCHES+1,X'20'  SHOULD FBQE BE ELIMINATED
         BZ    COREOK        NO
         L     RWORK4,BCKPTR(RWORK6)    PREVIOUS OF ONE TO ELIMINATE
         L     RADDR,FWDPTR(RWORK6)     NEXT OF ONE TO ELIMINATE
         ST    RADDR,FWDPTR(RWORK4)
         ST    RWORK4,BCKPTR(RADDR)
         B     COREOK
SRTN08   DS    0H
         AIF   ('&LCS' EQ 'N').GO76
         B     RETURN08
         AGO   .GO80
.GO76    ANOP
         B     RTN08
.GO80    ANOP
         AIF   ('&LCS' EQ 'N').GO74
TRYOTHR  TM    SWITCHES+1,X'10'         SECOND PQE ALREADY TRIED
         BO    SRTN08
         L     RWORK1,PQENXT(RWORK1)    OBTAIN NEXT PQE
         OI    SWITCHES+1,X'10'        INDICATE NOW ON SECOND PQE
         B     RETRY
.GO74    ANOP
SET1     OI    SWITCHES+1,X'20' INDICATE REQUEST AND FBQE START EQUAL
         B     OTHREND
         AIF   ('&RORI' EQ 'N').GO78
RORI     OI    SWITCHES,X'40'       INDICATE RORI REQUEST
         B     CKSVCBYT
.GO78    ANOP
PQENH1A  L     RIN1,PQESAVE
         B     PQENH1
         AIF   (NOT &MP).MP05A                                     MP2A
         SPACE 2
*        THIS RTN HAS BEEN ADDED FOR C/R IN AN MP SYSTEM.          MP2A
*        IT INTERCEPTS REQUESTS FOR A SPECIFIC REGION THAT         MP2A
*        CANNOT BE SATISFIED. IF ANY OF THE SPECIFIED 2K           MP2A
*        BLOCKS IS MARKED OFFLINE IN THE FSSEMAP, RETURN           MP2A
*        IS MADE TO CALLER VIA RTN08.   OTHERWISE IT               MP2A
*        REENTERS THE MAIN CODE AT SRTN04 AS BEFORE.               MP2A
         SPACE
*        REGS 7-10,12,14-15 ARE DESTROYED BUT SHOULD NOT           MP2A
*        BE REQUIRED BY CODE EXECUTED AFTER CHKFSMAP               MP2A
         SPACE
*        IT USES RTN IFSSEM00. REG SYMBOLS BEGINNING WITH          MP2A
*        X ARE DEFINED IN THAT RTN.                                MP2A
         SPACE 2
CHKFSMAP DS    0H                                                  MP2A
         LR    XLIMT,RWORK2        SET UP PARM FOR IFSSEM00 END ADDMP2A
         LR    XADDR,RADDR         START ADDR                      MP2A
         L     XENT,IFSSEMAP       ENTRY PT                        MP2A
         LR    RWORK2,RBASE        SAVE BASE                       MP2A
         USING PART,RWORK2         TEMP BASE                       MP2A
         DROP  RBASE MP2A                                          MP2A
CHKLOOP  BALR  XRETN,XENT                                          MP2A
         B     NONEOFF             RET HERE IF LAST 2K BLK         MP2A
         EX    XMASK,TESTMAP       HERE IF NOT LAST TEST FOR       MP2A
*                                  OFFINE IN FSSEMAP               MP2A
*        NOTE ONLY RIGHTMOST OF 2 BITS TESTED BOTH BITS1=OFFLINE   MP2A
         BZ    CHKLOOP             IF NOT CHK NEXT BLK             MP2A
         LR    RBASE,RWORK2        OFFLINE RELOAD BASE             MP2A
         B     RTN08               RETURN WITH CODE 8              MP2A
NONEOFF  LR    RBASE,RWORK2        UNAVAILABILITY OF REG NOT DUE   MP2A
*                                  TO STORAGE OFFLINE IN MP        MP2A
         B     SRTN04              RESUME NORMAL PROCESSING        MP2A
TESTMAP  TM    0(XMAPA),0          XMAPA PTS TO BYTE IN FSSEMAP    MP2A
         DROP  RWORK2                                              MP2A
         USING PART,RBASE MP2A                                     MP2A
.MP05A   ANOP                                                      MP2A
ABTERM   DC    V(IEA0AB01)
SVCXT    DC    V(IEA0XE00)                                         8499
* END
CON1K    DC    A(4096) .               CONSTANT OF 1K             M2883
DBASADR  DC    V(MSSBASE) .             QGM'S BASE ADDRESS        M2883
PQEMAIN  DC    V(GETMAINB)
OVRFLB   DC    A(GOVRFLB)
TASKSWCH DC    V(IEA0DS02)
REGMAIN  DC    V(RMBRANCH)
PURGE    DC    V(CDPURGE)
RELEASE  DC    V(MRELEASE)
ADSVCB   DC    V(SVCBYTE)
FBSRCH   DC    V(FBQSRCH)
         AIF   ('&RORI' EQ 'N').GO87
MASTER   DC    V(IEAMSTCB)  ADDRESS OF MASTER SCHEDULER TCB
GETIQE   DC    V(GETIQE) ADDRESS OF GETIQE SUBROUTINE
RORIQUE  DC    V(IEAROQUE) ADDRESS OF QUEUE OF ROLLOUT REQUESTS
ADDRSNEW DC    V(IEATCBP) ADDRESS OF H'NEW' AND 'OLD'
.GO87    ANOP
         AIF   (NOT &MP).MP02                                      MP1A
VQERSAV  DC    16F'0'              REG SAVE AREA WHILE PROCESS VQES
PARTBASE DC    A(PART)                                             MP1A
.MP02    ANOP                                                      MP1A
RIPSAVE  DS    16F                SAVE AREA                        MP2A
TCBSAVE  DC    F'0'
RINSAVE  DS    4F
WK2SV    DC    F'0'
SWITCHES DC    F'0'
* SWITCHES  BY BIT   BYTE 0
*              BIT  7 =  SVC 4 REQUEST       BIT 3 =H1 SWITCH
*              BIT  6 =  UNUSED              BIT 2 = ONE DONE SWITCH
*             BIT 6 =  RO/RI REQUEST       BIT 2 =  ONE DONE SWITCH
*              BIT  5 =  END OF LIST         BIT 1 = RORI REQUEST
*              BIT  4=   SPECIFIC REQUEST    BIT 0 = EXCHANGE REQUEST
* SWITCHES BY BIT BYTE 1
*             BIT 7 =  UNUSED              BIT 3 =  UNUSED
*             BIT 6 = MP SW FOR BRAN ENTY  BIT 2 =  UNUSED
*             BIT 6 =  MP SW FOR BRAN ENTY BIT 2 =  UNUSED
*             BIT 5 =  UNUSED              BIT 1 =  SATISFACTORY REQ
*             BIT 4 =  UNUSED              BIT 0 =  UNUSED
WAITSW   DC    X'00'
         AIF   ('&LCS' EQ 'N').GODCS00
ADDRSV   DS    F
WORK1SV  DS    F
HSAVE    DC    F'0'
.GODCS00    ANOP
PQESAVE  DC    F'0'
ZEROES   DC    F'0'
DUMQELTH DC    X'FF000008'
QELNTH   DC    X'FF000020'  SUBPOOL NUMBER AND LENGTH FOR PQE
RESERVE  DC    X'FC000008'
FQE252   DC    F'2040'                                             3645
SQSMIN   DC    F'2048'                                             3645
*
*        PQE  FIELDS
*
FWDPTR   EQU   0
BCKPTR   EQU   4
PQENXT   EQU   8
PQEPREV  EQU   12
PQETCB   EQU   16
PQERGSZ  EQU   20
PQESTADD EQU   24
PQEHID   EQU   29
PQESIZE  EQU   32
FBQESIZE EQU   8
         AIF   (NOT &MP).MP03                                      MP1A
*
*        VQE FIELDS
*
VRYPTR   EQU   0                   POINTER TO NEXT VQE
VRYBEG   EQU   4                   LOWER BOUND OF AREA TO BE VARIED
VRYLNG   EQU   8                   LENGTH OF AREA TO BE VARIED OFFLINE
VRYECB   EQU   12                  VARY TASK ECB, POST WHEN REMOV STORG
*
*        GOVRFLB FIELDS
*
SQBOUND  EQU   0                   ADDR OF FIRST BYTE BEYOND SQS
DQESQS   EQU   4                   ADDR OF DQE DESCRIBING SQS
PQEPTR   EQU   8                   ADDR OF PQE FOR UNASSIGNED STORAGE
MSBOUND  EQU   12      ADDR OF 1ST BYTE BEYOND DYNAMIC FREE AREA   MP1A
SZDPRS   EQU   12                                                  MO17
SZDLCS   EQU   16                                                  MO17
VQEPTR   EQU   20                  POINTER TO FIRST VARY QUEUE ELEMENT
.MP03    ANOP                                                      MP1A
*
CVTQMSG  EQU   X'10C' .           ADDR OF INFO LIST               21016
TSOTASK  EQU   X'80' .            TIME SHARING TASK FLAG          21016
TCBTSTSK EQU   148 .              DISP TO TIME SHARING FLAGS      21016
TCBJSCB  EQU   X'B4'              DISP OF JSCB IN TCB         AC A49808
JSCBTJID EQU   X'10C'             DISP OF USERID IN JSCB      AC A49808
Q0       EQU   0                  NUMERIC 0                        MP1A
Q1       EQU   1                  NUMERIC 1                        MP1A
Q4       EQU   4                  NUMERIC 4                        MP1A
Q8       EQU   8                  NUMERIC 8                        MP1A
Q10      EQU   10                 NUMERIC 10                       MP1A
Q11      EQU   11                 NUMERIC 11                       MP1A
Q13      EQU   13                 NUMERIC 13                       MP1A
Q2048    EQU   2048               NUMERIC 2048                     MP1A
QX01     EQU   X'01'              HEX 01                           MP1A
*
OWNGTCB  EQU   9 .         REG TO GET OWNING TCB ADD OF PQE  BL   M0459
R0       EQU   0                  REGISTER 0                       MP1A
R1       EQU   1                  REGISTER 1                       MP1A
R2       EQU   2                  REGISTER 2                       MP1A
R15      EQU   15                 REGISTER 15                      MP1A
RIN0     EQU   0
RIN1     EQU   1
RIQE     EQU   1
RADDR    EQU   2
RDQE     EQU   2
RPQE     EQU   2
RWORK6   EQU   3
QGM2BS   EQU   3 .                   QGM' 2DN BAS REG             M2883
RCVT     EQU   3
RTCB     EQU   4
RSPID    EQU   5
RWORK1   EQU   6
RCOMRET1 EQU   7
RWORK2   EQU   7
RFQE     EQU   7
RWORK3   EQU   9
RCOMRET  EQU   9
RLENGTH  EQU   10
RWORK4   EQU   10
TSWCH    EQU   10
RBASE    EQU   11
RSWCH    EQU   12
RSPQE    EQU   12
RRET     EQU   13
RABTERM  EQU   13
RRETURN  EQU   14
RBLOCK   EQU   14
RRETREG  EQU   15
RSIZE    EQU   15
SPQEDQE  EQU   4
SPQENXT  EQU   0     NEXT SPQE POINTER - 1
SPQEFLGS EQU   0     FLAG BYTE
SPQID    EQU   4
SPQELAST EQU   X'40' MASK FOR FLAG BIT INDICATING LAST SPQE FOR TCB
SPQESHRD EQU   X'80'        MASK INDICATING SUBPOOL IS SHARED
TCBMSS   EQU   24   SPQE POINTER -1
TCBFCD1  EQU   33    FIFTH FLAG BYTE - BIT 6 IS USED
TCBTCB   EQU   116
TCBOTC   EQU   132
TCBPQE   EQU   152
CVTTCB   EQU   0
CVT0EF00 EQU   4
CVTHEAD  EQU   160
FQENXT   EQU   0
FQELNTH  EQU   4
DQEFQE   EQU   0
DUMPQESZ EQU   8
DUMFWD   EQU   8
DUMBWD   EQU   12
         AIF   (NOT &MP).MP04                                      MP1A
         TITLE 'V A R Y    S T O R A G E    O F F L I N E'
*           INPUT - XPQE - ADDR OF PQE FOR PARTITION BEING PROCESSED
*                   XITR - RETURN ADDRESS
*           OUTPUT - FREE STORAGE FBQE CHAIN IS MODIFIED
*                  - FSSEMAP IS UPDATED TO INDICATE STORAGE REMOVED
*                  - POST 'VARY TASK' TO INDICAT STORAG WAS PUT OFFLINE
*           REGISTERS 3-15 ARE DESTROYED BY THE VARY OFFLINE ROUTINE.
*             THE USER IS RESPONSIBLE FOR SAVNG AND RESTORNG THESE REGS
         SPACE
         ENTRY IFSVRYOF
IFSVRYOF BALR  XBASE,R0           VARY STOARGE OFFLINE SUBR        MP1A
         USING IEAQFX00,R0        ADDRESSIBILITY                   MP1A
         USING IFSVRYBS,XBASE
IFSVRYBS DS    0H                  BASE ADDRESS
*
*        WHEN STORAGE HAS BEEN RELEASED FROM A PARTITION, TEST IF THERE
*        ARE ANY OUTSTANDING VARY QUEUE ELEMENTS, REPRESENTING DEFERRED
*        VARY STORAGE OFFLINE REQUESTS, WHICH APPLY TO THE STORAGE AREA
*        DESCRIBED BY THE GIVEN PQE
*
         L     XGVR,GVRFLB         VQE LIST ORIGIN IS IN -GOVRFLB-
         LA    XVQE,VQEPTR(,XGVR)  INITIALIZE TO VQE LIST ORIGIN
VQELOOP  L     XVQE,VRYPTR(,XVQE)  STEP TO NEXT VQE
         LA    XVQE,Q0(,XVQE)     ZERO HIGH ORDER BYTE             MP1A
         LTR   XVQE,XVQE           TEST IF HAVE VARY QUEUE ELEMENT
         BCR   Q8,XITR            ALL DONE, RETURN FROM SUBR       MP1A
         L     XBEG,PQESTADD(,XPQE)  GET PARTITION BEG ADDR
         L     XEND,PQERGSZ(,XPQE)  PICK PARTITION SIZE
         AR    XEND,XBEG           GET PARTITION ENDING ADDRESS
         LM    XXBG,XXND,VRYBEG(XVQE) GET BEGIN ADDR OF VARY AREA
         AR    XXND,XXBG           GET ENDING ADDRESS OF VARY AREA
         BAL   XRET,IFSAPPLY       TEST IF VQE APPLIES TO PARTITION
         BNL   VQELOOP            NO - GO GET NEXT VQE             MP1A
         STM   XBEG,XEND,SAVBOUND  STORE LIMITS OF VARY AREA IN PARTITN
*
*        POST VARY TASK TO INDICATE THAT A PARTITION WITHIN THE RANGE
*        OF THE VQE HAS BEEN PROCESSED.  THE VARY TASK WILL EXAMINE
*        THE FSSEMAP STATUS BITS TO DETERMINE IF THE VQE HAS BEEN
*        COMPLETELY SATISFIED (THE ENTIRE -VARY- AREA RECONFIGURED OUT)
*
         LA    XECB,VRYECB(,XVQE)  ECB ON WHICH -VARY- WAITS IS IN VQE
         SR    XPST,XPST           INDICATE COMPLETION CODE OF ZERO
         L     XLNK,POSTADDR       ADDR OF BRANCH ENTRY POINT TO -POST-
         BALR  XRET,XLNK           POST VARY TASK - VQE WAS USED
*                                  POST RTN HAS REGS 0-9,14 TRANSPARENT
         USING *,XRET
         L     XBASE,IFSSEVRY      REESTABLISH ADDRESSABILITY
         DROP  XRET
*
*        STEP THROUGH THE FBQES ON THE MSS FREE STORAGE QUEUE, AND TEST
*        EACH FBQE TO SEE IF THE CURRENT VQE APPLIES TO IT
*
         L     XDMY,PQEPTR(,XGVR)  INITIALIZE TO FBQE LIST ORIG IN MSS
         L     XFBQ,DUMFWD(,XDMY)  PICK REAL PQE ADDR FROM DUMMY
FBQLOOP  L     XFBQ,FWDPTR(,XFBQ)  STEP TO NEXT FBQE
         C     XFBQ,PQEPTR(,XDMY)  TEST IF FBQE QUEUE END (AT FREE PQE)
         BE    VQELOOP               YES - GO GET NEXT VQE
         LM    XBEG,XEND,SAVBOUND  SETUP LIMITS OF VARY STORAGE AREA
         LR    XXBG,XFBQ           GET FREE BLOCK AREA BEGIN ADDR
         LR    XXND,XFBQ
         A     XXND,FBQESIZE(,XFBQ) GET FREE BLOCK AREA END ADDRESS
         BAL   XRET,IFSAPPLY       TEST IF FBQE APPLIES TO VARY AREA
         BNL   FBQLOOP            NO - GO GET NEXT FBQE            MP1A
*
*        REMOVE STORAGE FROM AREA DESCRIBED BY FBQE
*           IF REMOV LOWER PART - ALSO REMOVE ORIGINAL FBQE
*           IF REMOV UPPER PART - CHANGE ORIG FBQE SIZE TO SIZE LOWER
*           IF LEAVE UPPER PART - CREATE NEW FBQE IN REMAING UPPER PART
*           IF REMOV MIDDL PART - UPDAT SIZE LOWR FBQE, CREAT UPPR FBQE
*
         SR    XXBG,XBEG           DOES FBQE START BEFORE VARY AREA
         BNL   FBQE1DEL           NO - DELETE OLD FBQE             MP1A
         LCR   XXBG,XXBG             YES - GET SIZE BEFORE VARY AREA
         ST    XXBG,FBQESIZE(,XFBQ) STORE NEW SIZE IN OLD FBQE
         B     FBQE2BLD            GO TO TEST END OF VARY AREA
FBQE1DEL L     XFWD,FWDPTR(,XFBQ)
         L     XBCK,BCKPTR(,XFBQ)
         ST    XFWD,FWDPTR(,XBCK)  ELIMINATE FBQE FROM FWD,BCK QUEUES
         ST    XBCK,BCKPTR(,XFWD)
         LR    XFBQ,XBCK           PREV FBQE BECOMES CURRENT FBQE
FBQE2BLD SR    XXND,XEND           DOES VARY AREA END BEFORE FBQE AREA
         BNP   MAPUPDAT           NO, DO NOT BUILD NEW FBQE        MP1A
         L     XFWD,FWDPTR(,XFBQ)    YES - GET ADDR OF NEXT FBQE IN Q
         ST    XEND,FWDPTR(,XFBQ)  POINT PREV FBQE TO NEW BUILT FBQE
         ST    XFWD,FWDPTR(,XEND)
         ST    XFBQ,BCKPTR(,XEND)  INSERT (BUILD) NEW FBQE
         ST    XXND,FBQESIZE(,XEND)
         ST    XEND,BCKPTR(,XFWD)  POINT NEXT FBQE TO NEW BUILT FBQE
         LR    XFBQ,XEND           NEW BUILT FBQE BECOMES CURRENT FBQE
*
*        UPDATE -FSSEMAP- IN THE CPU FAIL-SOFT SAV AREA TO INDICAT THAT
*        THE STORAGE RANGE GIVEN BY -XBEG,XEND- HAS BEEN RECONFIGURED,
*        AND NO LONGER APPEARS ON ANY MAIN STORAGE SUPERVISOR QUEUES
*
MAPUPDAT L     XMAP,IFSSEMAP       BASE ADDR FOR SSEMAP INSPECT ROUTINE
         BALR  XRET,XMAP           SET MAP REGISTERS FOR ADDR IN -XBEG-
         B     MAPMOVE               EXIT WHEN STEPPD TO ADDR IN -XEND-
         LR    XWRK,XMSK           SAVE CONTENTS SO CAN INCREMENT MASK
         ALR   XMSK,XWRK           DOUBLE MASK TO SETON LEFT BIT OF TWO
         ALR   XMSK,XWRK           TRIPLE MASK TO SETON RGHT BIT OF TWO
         EX    XMSK,ORMAPA         MARK STORAGE -RECONFIGURED OUT- IN
         BR    XMAP                GO INSPECT NEXT 2K BLK STATUS IN MAP
*
*        UPDATE -FSSEMAP- IN THE OTHER CPU FAIL-SOFT SAVE AREA
*
MAPMOVE  TM    CPUSTAT,QX01       TEST IF PARTITIONED MODE         MP1A
         BO    FBQLOOP            YES, BYPASS UPDATE OTHER CPU MAP MP1A
         L     XWRK,PREFIX2        GET ADDR OF OTHER CPU PSA
         MVC   FSSEMAP-IEAQFX00(,XWRK),FSSEMAP    UPDATE OTHER CPU MAP
         B     FBQLOOP             GO TEST NEXT FBQE AGAINST VARY AREA
*
*        SUBROUTINE TO DETERMINE THE STORAGE COMMON TO TWO GIVEN AREAS,
*        BY SELECTING THE RIGHTMOST BEG ADDR AND THE LEFTMOST END ADDR,
*        AND THEN TEST THAT THE SELECTED BEG IS TO THE LEFT OF SEL END
*
IFSAPPLY CR    XBEG,XXBG           TEST IF ELEM CROSSES AREA LOW BOUND
         BNL   *+6                YES - USE AREA BOUND AS LOW      MP1A
         LR    XBEG,XXBG             NO - USE ELEMENT BOUNDARY AS LOW
         CR    XXND,XEND           TEST IF ELEM CROSSES AREA HIGH BOUND
         BNL   *+6                YES - USE AREA BOUND AS HIGH     MP1A
         LR    XEND,XXND             NO - USE ELEMENT BOUNDARY AS HIGH
         CR    XBEG,XEND           COND. CODE SHOWS IF HAVE AREA LEFT
         BR    XRET                RETURN TO MAINLINE OF -IFSVRYOF-
*
*        EXECUTED INSTRUCTIONS
*
ORMAPA   OI    Q0(XMPA),Q0        INSERT EX MASK BITS, CPU A MAP   MP1A
         DROP  R0                                                  MP1A
         DROP  XBASE
*
*        CONSTANTS AND SAVE AREAS
*
GVRFLB   DC    A(GOVRFLB)          ADDR OF MSS LIST ORIGIN TABLE
IFSSEVRY DC    A(IFSVRYBS)         BASE ADDR FOR VARY STORAGE OFLIN RTN
POSTADDR DC    V(IEA0PT01)         ADDR OF BRANCH ENTRY POINT TO -POST-
IFSSEMAP DC    A(IFSSEM00)         ADDR OF FSSEMAP INSPECTION ROUTINE
SAVBOUND DC    2F'0'               SAVE AREA FOR VARY STORAGE LIMITS
*
*        REGISTER EQUATES
*
XITR     EQU   1         RETURN ADDRESS TO CALLING ROUTINE
XPQE     EQU   2         ADDR OF PQE TO GIVE SCOPE OF APPLICABLE STORAG
XVQE     EQU   3         ADDR OF VARY QUEUE ELEMENT BEING PROCESSED
XFBQ     EQU   4         ADDR OF CURRENT FBQE BEING INSPECTED
XGVR     EQU   5         POINTER TO MSS LIST ORIGIN TABLE -GOVRFLB-
XXBG     EQU   6         BEG ADDR OF AREA DESCRIBED BY CURR QUEUE ELEM
XXND     EQU   XXBG+1    END ADDR OF AREA DESCRIBED BY CURR QUEUE ELEM
XWRK     EQU   7         WORK REG USED TO SETON BOTH MAP BITS FOR 2K
XBEG     EQU   8         BEG ADDR OF AREA COMMON TO MULTIPLE QUEUE ELEM
XEND     EQU   XBEG+1    END ADDR OF AREA COMMON TO MULTIPLE QUEUE ELEM
XFWD     EQU   10        POINTER TO FBQE FOLLOWING CURR FBQE IN CHAIN
XMPA     EQU   10        POINTER TO PROPER BYTE WITHIN OWN CPU FSSEMAP
XPST     EQU   10        POST INPUT PARAMETER - COMPLETION CODE
XBCK     EQU   11        POINTER TO FBQE PRECEDING CURR FBQE IN CHAIN
XMSK     EQU   11        IFSSEM00 OUTPT - BIT CONFIG APPLIED TO FSSEMAP
XECB     EQU   11        POST INPUT PARAMETER - ECB ADDR
XMAP     EQU   12        LINK REGISTER USED TO BRANCH TO -IFSSEMAP- RTN
XDMY     EQU   13       ADDR OF REAL DYNAMIC FREE STORAGE PQE
XRET     EQU   14        RETURN REGISTER USED BY POST,MAP SUBROUTINES
XLNK     EQU   15        POST ENTRY POINT ADDRESS
XBASE    EQU   15        BASE REGISTER FOR ADDRESSABILITY
         TITLE '-F S S E M A P-    S C A N    S U B R O U T I N E'
*           INPUT  -  8 - BEG ADDR OF STORAGE AREA FOR WHICH SCAN
*                     9 - END ADDR OF STORAGE AREA FOR WHICH SCAN
*                    12 - ADDR OF ENTRY POINT (BASE ADDRESS)
*                    14 - RETURN ADDRESS
*           OUTPUT -  8 - ADDR OF NEXT 2K BLOCK OF STORAGE (PREV X8+2K)
*                    10 - ADDR OF MAP BYTE WITHIN OWN CPU -FSSEMAP-
*                    11 - MASKREG WITH '01' BITS POSITND FOR 2K IN BYTE
*                    12 - ADDR OF ENTRY PT TO SCAN MAP FOR NXT 2K BLOCK
*
*
*           REGISTERS 0-7,13-15 ARE NOT CHANGD DURING -IFSSEM00-.  REGS
*           8,10-12 WILL BE ALTERED.  THE USER OF -IFSSEM00- IS HIMSELF
*           RESPONSIBLE FOR SAVING AND RESTORING THE PROPER REGISTERS.
         SPACE
         ENTRY IFSSEM00       FAIL-SOFT STORAGE ELEMENT MAP SCAN SUBRTN
IFSSEM00 DS    0H                  BRANCH ENTRY POINT
         USING IFSSEM00,XENT       BASE REGISTER IS PRELOADED BY USER
         USING IEAQFX00,R0        ADDRESSIBILITY                   MP1A
*
         SRL   XLIMT,11            TRUNCATE END ADDR TO 2K BLOCK BOUND
         SLL   XLIMT,11            RESTORE END ADDR FOR COMPARISON
         BAL   XENT,IFSETEST       ESTABLISH ADDR FOR LOOP ENTRY POINT
         USING *,XENT
*
*        SCAN LOOP.  DETERMINE MAP BYTE BY TRUNCATING THE GIVEN ADDR IN
*        -XADDR-.  POSITION A BIT MASK TO CORRESPOND TO THE PROPER TWO
*        BITS (DESCRIBING THE STATUS OF THE 2K BLOCK) WITHIN THE MAP
*        BYTE.  INCREMENT -XADDR- SO THAT WHEN THE LOOP IS AGAIN
*        ENTERED, THE NEXT 2K BLOCK STATUS WILL BE SCANNED.
*
         LA    XADDR,Q2048(,XADDR) INCR INPUT ADDR TO NEXT 2K BLK  MP1A
IFSETEST CR    XADDR,XLIMT         TEST IF HAVE EXCEEDED STORAGE AREA
         BCR   Q10,XRETN          YES - FINAL EXIT                 MP1A
         LM    XSHFT,XMASK,IFSEMCON PICK MASKS USED TO SELECT BITS
         NR    XSHFT,XADDR         PICK LOW 2 BITS OF 2K BLOCK ADDR
         SRL   XSHFT,10            GET DISPLACMT OF 2K FRM 16K BOUNDARY
         SRL   XMASK,0(XSHFT)      SHFT MASK FOR 2K POS WITHIN MAP BYTE
         LA    XBYTE,Q0(,XADDR)   CLEAR HIGH ORDER BITS OF ADDR    MP1A
         SRL   XBYTE,13            GET DISPLACMT OF MAP BYT FOR 16K BLK
         LA    XMAPA,FSSEMAP(XBYTE) GET ADDR OF MAP BYTE IN OWN IFSAREA
         B     Q4(,XRETN)         GO TO USERS PROCESS ROUTINE      MP1A
*
         DROP  XENT
         DROP  R0                                                  MP1A
*
*        CONSTANTS AND SAVE AREAS
*
IFSEMCON DC    F'6144,64'     MASKS TO SEL SHFT AMT, TEST BIT 1 IN BYTE
*
*        REGISTER EQUATES
*
XADDR    EQU   8         ADDR OF 2K STRG BLOCK WHOSE MAP STATUS SOUGHT
XLIMT    EQU   9         ADDR OF 1ST BYTE BEYOND STRG AREA TO BE SCANND
XMAPA    EQU   10        POINTER TO PROPER BYTE WITHIN OWN CPU FSSEMAP
XBYTE    EQU   10        DISPLACEMENT OF BYTE FROM FSSEMAP BEGINNING
XSHFT    EQU   10        DISPLACEMENT OF PROPR 2 BITS WITHIN 8 BIT BYTE
XMASK    EQU   XSHFT+1   OUTPUT REG - '01' MASK POSITND OVR WANTED BITS
XENT     EQU   12        BASE REGISTER FOR ADDRESSABILITY
XRETN    EQU   14        RETURN ADDRESS TO CALLING ROUTINE
         TITLE '0 - 4K    S T O R A G E    M A P'
         IEAQFX 65,MCH,1
.MP04    ANOP                                                      MP1A
         EJECT
***************************************************************
*        DSECT TO COVER INFORMATION LIST ENTRY
***************************************************************
         SPACE 1
INFOLIST DSECT
INFRESV  DS    H                        RESERVED              AC A49808
INFTJID  DS    H                                              AC A49808
INFTCB   DS    F
INFBADDR DS    F
INFRCL   DS    X     BITS 0-2 USED FOR REASON CODE(0=>NO RC)
*                    BITS 3-7 USED FOR COUNT OF VARIABLE DATA BYTES
INFFLG   DS    X     FLAG BYTE
INFFLG0  EQU   X'10' BIT 0 ON => BRANCH ENTRY
INFCC    DS    H     COMPLETION CODE
INFVAR   DS    4F    VARIABLE INFORMATION
         ORG   INFVAR
INFVAR1  DS    F
INFVAR2  DS    F
INFVAR3  DS    F
INFVAR4  DS    F
INFEND   EQU   *
INFLEN   EQU   (INFEND-INFRESV)  LENGTH OF ENTRY
         MEND
