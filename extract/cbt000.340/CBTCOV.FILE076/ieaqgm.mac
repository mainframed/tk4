        MACRO
         IEAQGM &RORI,&LCS,&MPS,&SMF,&TSO                         20021
.*316200                                                       @AS75933
.* A     339100-339200,322500-322590,328300                    @SA77169
.* A     547240-547440                                         @SA77070
.*316500-316740                                                @AS75933
.* C     794500                                                @SA78255
.* A 712510-712680                                             @SA78437
         TITLE ' MVT GETMAIN / FREEMAIN SERVICE ROUTINE '
.*
.* THE FOLLOWING TABLE IDENTIFIES THE FLAG FIELDS (COL. 68 - 71)
.* OF RECORDS SUBMITTED AS DEVELOPMENT CHANGES TO INTEGRATION TO
.* SUPPORT THE INDICATED OS/360 COMPONENT FOR THE SPECIFIED RELEASE.
.*
.* FLAG             OS/360 COMPONENT        REL. NO.       INTEG. START
.*                                                             DATE
.* TS0A    TIME SLICING                        16             2-26-68
.* LC0A    LARGE CAPACITY STORAGE (LCS)        17             5-27-68
.* MP65    M65 MULTIPROCESSING                 17             5-27-68
.* 20021   TIME SHARING OPTION(TSO)            20             8-07-70
.*
.* REL.  APARS FIXED
.* 20    26046, 29420, 30185, 32583, 33335
IEAQGM00 START 0
         ENTRY IGC004
         ENTRY IGC005
         ENTRY IGC010
         ENTRY RMBRANCH
         ENTRY GMBRANCH
         ENTRY FMBRANCH
         ENTRY GOVRFLB
         ENTRY CDPURGE
         ENTRY MRELEASE
         ENTRY GETMAINB
         ENTRY FBQSRCH
         ENTRY MSSBASE
         EXTRN IEATCBP
         EXTRN IEA0AB01
         EXTRN CDHKEEP
         EXTRN CDDESTRY
         EXTRN IEAMSTCB
         EXTRN IEA0XE00
         EXTRN DISPINIT                                            SWS
         EXTRN IEAQPRT0                                            SWS
         ENTRY SVCBYTE
         ENTRY SPIDSAV .                                         A32912
         ENTRY IEA10FS                                            M3806
         AIF   ('&MPS' NE 'Y').MP01                                MP65
         ENTRY VQEPTR                                              MP65
.MP01    ANOP                                                      MP65
         AIF   ('&RORI' NE 'Y').GOG1                               LC0A
         ENTRY IEAROSW
.GOG1    ANOP
         EJECT
*ROUTINE NAME-           IEAQGM00-MAIN STORAGE SUPERVISOR
*
*FUNCTION-               THE BASIC FUNCTION OF THE MAIN STORAGE
*                        SUPERVISOR IS TO ASSIGN STORAGE BLOCKS FOR THE
*                        USE OF VARIOUS TASKS IN THE MULTIPROGRAMMING
*                        ENVIRONMENT ACCORDING TO THEIR NEEDS AND IN
*                        ORDER OF THEIR PRIORITY WITHIN THE SYSTEM.
*                        THIS INVOLVES
*                          1) ALLOCATION OF STORAGE BLOCKS ON REQUEST.
*                          2) RELEASE OF STORAGE BLOCKS ON REQUEST.
*                          3) MAINTAINING OWNERSHIP OF ALL 2K BLOCKS.
*                              A) MAINTAINING A RECORD OF ALL 2K BLOCKS
*                                 ASSIGNED TO EACH TASK AND TO EACH
*                                 SUB-POOL BELONGING TO THAT TASK.
*                              B) MAINTAINING A QUEUE OF FREE AREAS
*                                 WITHIN THE MAIN STORAGE ASSIGNED TO
*                                 EACH TASK SUB-POOL.
*                              C) MAINTAINING A RECORD OF ASSOCIATION
*                                 OF STORAGE ALLOCATED FROM SUPERVISOR
*                                 OWNED STORAGE WHEN REQUESTED TO DO SO
         AIF   (&SMF EQ 0).MSSMFA                                   SMF
*                                                                   SMF
*                        A SECONDARY FUNCTION IN SUPPORT OF SYSTEMS SMF
*                        MANAGEMENT FACILITIES IS TO PRODUCE        SMF
*                        ACTUAL CORE USED VALUES.                   SMF
*                        THIS INVOLVES                              SMF
*                          1) MONITORING REQUESTS FOR NON ZERO      SMF
*                             PROTECT KEY AND SUB POOL 252, AND     SMF
*                             MAINTAINING CORE USED FIELDS          SMF
*                             ASSOCIATED WITH EACH PP TCB.          SMF
*                          2) THE FIELDS MAINTAINED ARE             SMF
*                              A) LOW WATER MARK.                   SMF
*                              B) HIGH WATER MARK.                  SMF
*                              C) MINIMUM DIFFERENCE BETWEEN MARKS. SMF
*                          3) EACH TYPE OF CORE AVAILABLE HAS A SET SMF
*                             OF RELATED FIELDS.                    SMF
         AIF   ('&RORI' NE 'Y').MSSMFA                              SMF
*                                                                   SMF
*                        IN ADDITION BORROWED CORE FIELDS ARE       SMF
*                        MAINTAINED IN THE TCT FOR EACH PP TCB.     SMF
*                        THIS INVOLVES                              SMF
*                          1) KEEPING A CURRENT VALUE OF BORROWED   SMF
*                             CORE IN 2K BLOCKS.                    SMF
*                          2) UPDATEING A MAXIMUM VALUE OF BORROWED SMF
*                             CORE IN 2K BLOCKS.                    SMF
.MSSMFA  ANOP                                                       SMF
         AIF   (&TSO NE 1).TSOP000                                20021
*                                                                 20021
*                        FOR THE TIME SHARING OPTION(TSO)         20021
*                        PROVIDE THE CAPIBILITY TO:               20021
*                        1) MAP SUBPOOLS 253, 254, AND 255 INTO   20021
*                        LOCAL SQS(LSQS) FOR TIME SHARING TASKS.  20021
*                        2) TO ABTERM A TIME SHARING TASK THAT    20021
*                        EXHAUSTS ITS LSQS.  TO PREVENT AN ABTERM 20021
*                        RECURSION AND ALLOW THE ABTERMING TASK   20021
*                        TO COMPLETE, MAIN STORAGE(253, 254 ,255) 20021
*                        REQUESTS DURING ABTERM WILL BE HONORED   20021
*                        FROM SQS.                                20021
*
.TSOP000 ANOP                                                     20021
*                        REQUEST FOR SUBPOOLS 243, 244, 245 WILL  20021
*                        BE HONORED UNCONDITIONALLY FROM SQS FOR  20021
*                        BOTH TIME SHARING AND NON-TIME SHARING   20021
*                        TASKS.                                   20021
*
*ENTRY POINT NAMES-      IGC004-SVC 4 - S-TYPE GETMAIN ENTRY POINT.
*                        IGC005-SVC 5 - S-TYPE FREEMAIN ENTRY POINT.
*                        IGC010-SVC 10- R-TYPE GETMAIN AND FREEMAIN
*                                       ENTRY POINT.
*                        GMBRANCH-BRANCH ENTRY - S-TYPE GETMAIN.
*                        FMBRANCH-BRANCH ENTRY - S-TYPE FREEMAIN.
*                        RMBRANCH-BRANCH ENTRY - R-TYPE GETMAIN AND
*                                                FREEMAIN.
*
*CONTAINED IN MODULE-    IEAQGM - MAIN STORAGE SUPERVISOR.
*
*ATTRIBUTES-             NON-REENTRANT, OPERATES IN SUPERVISOR STATE,
*                        RESIDENT, DISABLED FOR ALL MASKABLE INTERRUPTS
*                        EXCEPT MACHINE CHECK, TYPE 1 SVC ROUTINE.
*
*APPLICABILITY-          OPTION 4 ONLY.
*
*EXTERNAL REFERENCES-    IEA0AB01 - ABTERM
*                        CDHKEEP  - CDDESTRY BASE ADDRESS
*                        CDDESTRY - CDDESTRY ROUTINE
*                        IEAQPRT0 - GET-FREE PARTITION
*                        IEATCBP  - LOCATION 'NEW' AND 'OLD'
*
*SVCS USED-              NONE
*
*ENTRY POINTS-         1.IGC004 - S-TYPE GETMAIN ENTRY POINT.  GIVEN
*                        CONTROL BY SVC FIRST LEVEL INTERRUPT HANDLER
*                        (FLIH) VIA LPSW IN ORDER TO PERFORM THE
*                        GETMAIN FUNCTION REQUESTED BY THE CALLER.  AN
*                        SVC 4 IS ISSUED BY THE CALLER.
*
*                      2.THE PSW MUST BE DISABLED FOR ALL MASKABLE
*                        INTERRUPTS EXCEPT MACHINE CHECK, IN SUPERVISOR
*                        MODE, AND HAVE SUPERVISOR PROTECT KEY.
*
*                      3.THE REGISTERS CONTAIN
*                          REGISTER 1 CONTAINS THE ADDRESS OF THE
*                          PARAMETER LIST.
*                          REGISTER 3 CONTAINS THE ADDRESS OF THE CVT
*                          TABLE.
*                          REGISTER 4 CONTAINS THE ADDRESS OF THE
*                          CURRENT TCB.
*                          REGISTER 5 CONTAINS THE ADDRESS OF THE RB AT
*                          THE TOP OF THE RB QUEUE.
*                          REGISTER 13 CONTAINS THE ADDRESS OF THE
*                          ABTERM ROUTINE.
*                          REGISTER 14 CONTAINS THE ADDRESS OF THE TYPE
*                          1 SVC EXIT HANDLER.
*                          REGISTERS 0,2,6-12, AND 15 CONTAIN THE
*                          CONTENTS AT THE TIME THE SVC 4 WAS GIVEN.
*
*                      1.IGC005 - S-TYPE FREEMAIN ENTRY POINT.  GIVEN
*                        CONTROL BY SVC FIRST LEVEL INTERRUPT HANDLER
*                        (FLIH) VIA LPSW IN ORDER TO PERFORM THE
*                        FREEMAIN FUNCTION REQUESTED BY THE CALLER.  AN
*                        SVC 5 IS ISSUED BY THE CALLER.
*
*                      2.THE PSW MUST BE DISABLED FOR ALL MASKABLE
*                        INTERRUPTS EXCEPT MACHINE CHECK, IN SUPERVISOR
*                        MODE, AND HAVE SUPERVISOR PROTECT KEY.
*
*                      3.THE REGISTERS CONTAIN
*                          REGISTER 1 CONTAINS THE ADDRESS OF THE
*                          PARAMETER LIST.
*                          REGISTER 3 CONTAINS THE ADDRESS OF THE CVT
*                          TABLE.
*                          REGISTER 4 CONTAINS THE ADDRESS OF THE
*                          CURRENT TCB.
*                          REGISTER 5 CONTAINS THE ADDRESS OF THE RB AT
*                          THE TOP OF THE RB QUEUE.
*                          REGISTER 13 CONTAINS THE ADDRESS OF THE
*                          ABTERM ROUTINE.
*                          REGISTER 14 CONTAINS THE ADDRESS OF THE TYPE
*                          1 SVC EXIT HANDLER.
*                          REGISTERS 0,2,6-12, AND 15 CONTAIN THE
*                          CONTENTS AT THE TIME THE SVC 5 WAS GIVEN.
*
*                      1.IGC010 - R-TYPE GETMAIN AND FREEMAIN ENTRY
*                        POINT.  GIVEN CONTROL BY SVC FIRST LEVEL
*                        INTERRUPT HANDLER (FLIH) VIA LPSW IN ORDER TO
*                        PERFORM THE GETMAIN OR FREEMAIN FUNCTION
*                        REQUESTED BY THE CALLER.  AN SVC 10 IS ISSUED
*                        BY THE CALLER.
*
*                      2.THE PSW MUST BE DISABLED FOR ALL MASKABLE
*                        INTERRUPTS EXCEPT MACHINE CHECK, IN SUPERVISOR
*                        MODE, AND HAVE SUPERVISOR PROTECT KEY.
*
*                      3.THE REGISTERS CONTAIN
*                          REGISTER 0 CONTAINS THE NUMBER OF THE
*                          SUBPOOL REQUESTED IN THE HIGH ORDER BYTE AND
*                          THE NUMBER OF BYTES REQUESTED IN THE LOW
*                          ORDER THREE BYTES.  IF THE REQUEST IS FOR A
*                          FREEMAIN FOR AN ENTIRE SUBPOOL, THE LOW
*                          ORDER THREE BYTES MUST BE ZERO.
*                          REGISTER 1 CONTAINS ANY NEGATIVE VALUE IF
*                          THE REQUEST IS FOR A GETMAIN, OR THE ADDRESS
*                          OF THE STORAGE TO BE FREED IF THE REQUEST IS
*                          FOR A FREEMAIN.  IF THE REQUEST IS FOR A
*                          FREEMAIN FOR AN ENTIRE SUBPOOL, THE ENTIRE
*                          REGISTER MUST BE ZERO.
*                          REGISTER 3 CONTAINS THE ADDRESS OF THE CVT
*                          TABLE.
*                          REGISTER 4 CONTAINS THE ADDRESS OF THE
*                          CURRENT TCB.
*                          REGISTER 5 CONTAINS THE ADDRESS OF THE RB AT
*                          THE TOP OF THE RB QUEUE.
*                          REGISTER 13 CONTAINS THE ADDRESS OF THE
*                          ABTERM ROUTINE.
*                          REGISTER 14 CONTAINS THE ADDRESS OF THE TYPE
*                          1 SVC EXIT HANDLER.
*                          REGISTERS 2,6-12, AND 15 CONTAIN THE
*                          CONTENTS AT THE TIME THE SVC 10 WAS GIVEN.
*
*                      1.GMBRANCH - S-TYPE GETMAIN BRANCH ENTRY POINT.
*                        GIVEN CONTROL BY THE CALLING SUPERVISOR
*                        ROUTINE VIA A BRANCH IN ORDER TO PERFORM THE
*                        GETMAIN FUNCTION REQUESTED BY THE CALLER.
*
*                      2.THE PSW MUST BE DISABLED FOR ALL MASKABLE
*                        INTERRUPTS EXCEPT MACHINE CHECK, IN SUPERVISOR
*                        MODE, AND HAVE SUPERVISOR PROTECT KEY.
*
*                      3.THE REGISTERS CONTAIN
*                          REGISTER 1 CONTAINS THE ADDRESS OF THE
*                          PARAMETER LIST.
*                          REGISTER 3 CONTAINS THE ADDRESS OF THE CVT.
*                          REGISTER 4 CONTAINS THE ADDRESS OF THE TCB
*                          UNDER WHICH STORAGE IS TO BE ALLOCATED.
*                          REGISTER 14 CONTAINS THE ADDRESS OF THE
*                          LOCATION TO WHICH CONTROL IS TO BE RETURNED.
*                          REGISTERS 0,2,5-13 AND 15 CONTAIN
*                          INFORMATION FROM THE CALLER WHICH IS NOT
*                          USEFUL TO THE MAIN STORAGE SUPERVISOR
*                          ROUTINES.
*
*                      1.FMBRANCH - S-TYPE FREEMAIN BRANCH ENTRY POINT.
*                        GIVEN CONTROL BY THE CALLING SUPERVISOR
*                        ROUTINE VIA A BRANCH IN ORDER TO PERFORM THE
*                        FREEMAIN FUNCTION REQUESTED BY THE CALLER.
*
*                      2.THE PSW MUST BE DISABLED FOR ALL MASKABLE
*                        INTERRUPTS EXCEPT MACHINE CHECK, IN SUPERVISOR
*                        MODE, AND HAVE SUPERVISOR PROTECT KEY.
*
*                      3.THE REGISTERS CONTAIN
*                          REGISTER 1 CONTAINS THE ADDRESS OF THE
*                          PARAMETER LIST.
*                          REGISTER 3 CONTAINS THE ADDRESS OF THE CVT.
*                          REGISTER 4 CONTAINS THE ADDRESS OF THE TCB
*                          UNDER WHICH STORAGE IS TO BE RELEASED.
*                          REGISTER 14 CONTAINS THE ADDRESS OF THE
*                          LOCATION TO WHICH CONTROL IS TO BE RETURNED.
*                          REGISTERS 0,2,5-13 AND 15 CONTAIN
*                          INFORMATION FROM THE CALLER WHICH IS NOT
*                          USEFUL TO THE MAIN STORAGE SUPERVISOR
*                          ROUTINES.
*
*                      1.RMBRANCH - R-TYPE GETMAIN AND FREEMAIN ENTRY
*                        POINT.  GIVEN CONTROL BY THE CALLING
*                        SUPERVISOR ROUTINE VIA A BRANCH IN ORDER TO
*                        PERFORM THE GETMAIN OR FREEMAIN FUNCTION
*                        REQUESTED BY THE CALLER.
*
*                      2.THE PSW MUST BE DISABLED FOR ALL MASKABLE
*                        INTERRUPTS EXCEPT MACHINE CHECK, IN SUPERVISOR
*                        MODE, AND HAVE SUPERVISOR PROTECT KEY.
*
*                      3.THE REGISTERS CONTAIN
*
*                          REGISTER 0 CONTAINS THE NUMBER OF THE
*                          SUBPOOL REQUESTED IN THE HIGH ORDER BYTE AND
*                          THE NUMBER OF BYTES REQUESTED IN THE LOW
*                          ORDER THREE BYTES.  IF THE REQUEST IS FOR A
*                          FREEMAIN FOR AN ENTIRE SUBPOOL, THE LOW
*                          ORDER THREE BYTES MUST BE ZERO.
*                          REGISTER 1 CONTAINS ANY NEGATIVE VALUE IF
*                          THE REQUEST IS FOR A GETMAIN, OR THE ADDRESS
*                          OF THE STORAGE TO BE FREED IF THE REQUEST IS
*                          FOR A FREEMAIN.  IF THE REQUEST IS FOR A
*                          FREEMAIN FOR AN ENTIRE SUBPOOL, THE ENTIRE
*                          REGISTER MUST BE ZERO.
*                          REGISTER 3 CONTAINS THE ADDRESS OF THE CVT.
*                          REGISTER 4 CONTAINS THE ADDRESS OF THE TCB
*                          UNDER WHICH THE STORAGE IS TO BE ALLOCATED
*                          OR RELEASED.
*                          REGISTER 14 CONTAINS THE ADDRESS OF THE
*                          LOCATION TO WHICH CONTROL IS TO BE RETURNED.
*                          REGISTERS 2,5-13, AND 15 CONTAIN INFORMATION
*                          FROM THE CALLER WHICH IS NOT USEFUL TO THE
*                          MAIN STORAGE SUPERVISOR ROUTINES.
*
*EXIT POINTS-          1.TO THE TYPE 1 SVC EXIT ROUTINE VIA A BRANCH ON
*                        REGISTER 14 IF ENTRY WAS BY AN SVC OR TO A
*                        LOCATION SPECIFIED BY THE CALLER IF ENTRY WAS
*                        BY A BRANCH.
*
*                      2.THE PSW IS DISABLED FOR ALL MASKABLE
*                        INTERRUPTS EXCEPT MACHINE CHECK, IN SUPERVISOR
*                        MODE, AND HAS SUPERVISOR PROTECT KEY.
*
*                      3.THE REGISTERS CONTAIN
*                          REGISTERS 0-15 CONTAIN MEANINGLESS INFORM-
*                          ATION UPON EXIT IF ENTRY WAS BY AN SVC
*                          EXCEPT FOR A GETMAIN REQUEST UNDER SVC 10,
*                          IN WHICH CASE REGISTER 1 CONTAINS THE
*                          ADDRESS OF THE STORAGE ALLOCATED.
*                          REGISTERS 2-7 AND 9-14 ARE UNALTERED AND
*                          REGISTERS 0,1,8, AND 15 CONTAIN MEANINGLESS
*                          INFORMATION IF ENTRY WAS BY A BRANCH EXCEPT
*                          FOR A GETMAIN REQUEST UNDER AN ENTRY TO
*                          RMBRANCH, IN WHICH CASE REGISTER 1 CONTAINS
*                          THE ADDRESS OF THE STORAGE ALLOCATED.
*
*ERROR EXIT POINTS-    1.TO ABTERM IN ORDER TO CAUSE THE ISSUING TASK
*                        TO BE TERMINATED.
*
*                      2.THE PSW IS DISABLED FOR ALL MASKABLE
*                        INTERRUPTS EXCEPT MACHINE CHECK, IN SUPERVISOR
*                        MODE, AND HAS SUPERVISOR PROTECT KEY.
*
*                      3.REGISTER 1 CONTAINS THE ERROR CODE.
*                        THE REMAINING REGISTERS CONTAIN MEANINGLESS
*                        INFORMATION.
*
*                      4.THE ERROR CODES ARE
         AIF   (&TSO NE 1).TSOP100                                20021
*                          X'0104' ERROR CODE #1 - OUT OF LOCAL   20021
*                          X'010A'                 SQS            20021
*                                  ERROR CODE #2 - NOT USED       20021
.TSOP100 ANOP                                                     20021
*                          X'0305' ERROR CODE #3 - STORAGE NOT IN
*                          X'030A'                 SPECIFIED SUBPOOL.
*                          X'040A' ERROR CODE  4 - PROBLEM PROGRAM
*                                                  ATTEMPTING TO FREE
*                                                  ALL OF SUBPOOL 0.
*                          X'0504' ERROR CODE  5 - LENGTH LIST AND
*                          X'0505'                 ADDRESS LIST HAVE
*                                                  COMMON LOCATIONS
*                          X'0604' ERROR CODE  6 - PARAMETER LIST NOT
*                                                  IN PROBLEM PROGRAM
*                                                  AREA, INPUT LIST
*                                                  ADDRESS NOT ON WORD
*                                                  BOUNDARY, OR FQE
*                                                  QUEUE DESTROYED.
*                          X'0804' ERROR CODE #8 - REQUEST FOR MORE
*                          X'080A'                 STORAGE THAN IS
*                                                  AVAILABLE - UNCONDI-
*                                                  TIONAL REQUEST.
*                          X'0905' ERROR CODE  9 - ADDRESS OF AREA TO
*                                                  BE FREED NOT A
*                                                  MULTIPLE OF 8.
*                          X'0A05' ERROR CODE #10- AREA BEING FREED
*                          X'0A0A'                 OVERLAPS A FREE AREA
*                          X'0B04' ERROR CODE #11- PROBLEM PROGRAM
*                          X'0B05'                 REQUESTS SUBPOOLS
*                          X'0B0A'                 128-255.
*                          X'0C04' ERROR CODE =12- GENERAL LCS     LC0A
*                                                  ERROR - RELATINGLC0A
*                                                  TO INVALID      LC0A
*                                                  HIERARCHY       LC0A
*                                                  REQUESTS.       LC0A
*                          X'0D05' ERROR CODE =13- REQUEST TO FREE 8098
*                          X'0D0A'                 CORE FROM SQS - 8098
*                                                  NOT OWNED BY    8098
*                                                  REQUESTING TASK.8098
*
*TABLES AND CONTROL
*BLOCKS REFERENCED-    1.TCB - TASK CONTROL BLOCK
*                        THE CONTROL BLOCK UNDER WHICH THE TASK IS
*                        OPERATING.
*
*                        FIELDS USED BY MAIN STORAGE SUPERVISOR
*
*                          TCBMSS - POINTER TO THE QUEUE OF SPQES
*                                   (SUBPOOL QUEUE ELEMENTS).
*
*                          TCBJSTCB - JOB STEP TCB POINTER.
*
*                          TCBPKF - PROTECT KEY.
*
*                          TCBJPQ - JOB PACK QUEUE POINTER.
*
*                          TCBPQE - PARTITION QUEUE ELEMENT POINTER OR,
*                                   IF ROLLOUT/ROLLIN, A POINTER TO THE
*                                   DUMMY PQE.
*
*                          TCBAQE - POINTER TO QUEUE OF SUPERVISOR
*                                   QUEUE SPACE ALLOCATED TO THIS TASK.
         AIF   (&SMF EQ 0).MSSMFB                                   SMF
*                                                                   SMF
*                          TCBTCT - POINTER TO TIMING CONTROL TABLE.SMF
.MSSMFB  ANOP                                                       SMF
         AIF   (&TSO NE 1).TSOP200                                20021
*                                                                 20021
*                          TCBRBP - ADDR. OF FIRST RB             20021
*                                                                 20021
*                          TCBFLGS - TCB FLAGS                    20021
*                                                                 20021
*                          TCBTSLFG - TCB TSO FLAGS               20021
.TSOP200 ANOP                                                     20021
*
*                      2.PQE - PARTITION QUEUE ELEMENT
*                        A QUEUE ELEMENT IDENTIFYING THE FIRST AND LAST
*                        FBQES IN AN FBQE QUEUE, THE NEXT AND PREVIOUS
*                        PQES IN A ROLLOUT/ROLLIN ENVIRONMENT, THE SIZE
*                        OF THE REGION BEING DESCRIBED AND ITS STARTING
*                        ADDRESS.
*
*                        THESE FIELDS ARE REFERENCED
*
*                          FWDPTR - A FOUR BYTE FIELD IN WHICH THE
*                                   FIRST BYTE IS ZERO AND IN WHICH THE
*                                   LAST THREE BYTES CONTAIN A POINTER
*                                   TO THE LOWEST ADDRESS FBQE IN THE
*                                   REGION OR THE ADDRESS OF THE PQE.
*
*                          BCKPTR - A FOUR BYTE FIELD IN WHICH THE
*                                   FIRST BYTE IS ZERO AND IN WHICH THE
*                                   LAST THREE BYTES CONTAIN A POINTER
*                                   TO THE HIGHEST ADDRESS FBQE IN THE
*                                   REGION OR THE ADDRESS OF THE PQE.
*
*                          PQENXT - A FOUR BYTE FIELD IN WHICH THE
*                                   FIRST BYTE IS ZERO AND IN WHICH THE
*                                   LAST THREE BYTES CONTAIN A POINTER
*                                   TO THE PQE OF THE NEXT HIGHEST
*                                   ADDRESSED PARTITION.
*
*                          PQEPREV - A FOUR BYTE FIELD IN WHICH THE
*                                    FIRST BYTE IS ZERO AND IN WHICH
*                                    THE LAST THREE BYTES CONTAIN A
*                                    POINTER TO THE PQE OF THE NEXT
*                                    LOWEST ADDRESSED PARTITION.
*
*                          PQETCB - A FOUR BYTE FIELD IN WHICH THE
*                                   FIRST BYTE IS ZERO AND IN WHICH THE
*                                   LAST THREE BYTES CONTAIN A POINTER
*                                   TO THE OWNING TCB.
*
*                          PQERGSZ - A FOUR BYTE FIELD IN WHICH THE
*                                    FIRST BYTE IS ZERO AND IN WHICH
*                                    THE LAST THREE BYTES CONTAIN THE
*                                    SIZE OF THE REGION.
*
*                          PQESTADD - A FOUR BYTE FIELD IN WHICH THE
*                                     FIRST BYTE IS ZERO AND IN WHICH
*                                     THE LAST THREE BYTES CONTAIN A
*                                     POINTER TO THE STARTING ADDRESS
*                                     OF THE REGION.
*
*                          BORROWED PARTITION BIT - BIT INDICATOR WHICH
*                                                   INDICATES THAT THIS
*                                                   PARTITION IS OWNED
*                                                   BY ANOTHER TASK.
*
         AIF   ('&LCS' NE 'Y').LC16                                LC0A
*                          PQEHIID - A ONE BYTE FIELD CONTAINING   LC0A
*                                    THE HIERARCHY IDENTIFICATION  LC0A
.LC16    ANOP                                                      LC0A
*                                                                  LC0A
*                      3.FBQE - FREE BLOCK QUEUE ELEMENT
*                        A QUEUE ELEMENT WHICH IDENTIFIES AND DESCRIBES
*                        ONE OR MORE CONTIQUOUS FREE 2K BLOCKS.
*
*                        THESE FIELDS ARE REFERENCED
*
*                          FWDPTR - A FOUR BYTE FIELD IN WHICH THE
*                                   FIRST BYTE IS ZERO AND IN WHICH THE
*                                   LAST THREE BYTES CONTAIN A POINTER
*                                   TO THE LOWEST ADDRESS FBQE IN THE
*                                   REGION.
*
*                          BCKPTR - A FOUR BYTE FIELD IN WHICH THE
*                                   FIRST BYTE IS ZERO AND IN WHICH THE
*                                   LAST THREE BYTES CONTAIN A POINTER
*                                   TO THE HIGHEST ADDRESS FBQE IN THE
*                                   REGION.
*
*                          SIZE - A FOUR BYTE FIELD IN WHICH THE FIRST
*                                 BYTE IS ZERO AND IN WHICH THE LAST
*                                 THREE BYTES CONTAIN THE SIZE OF THE
*                                 FREE AREA.  THIS IS ALWAYS A MULTIPLE
*                                 OF 2K.
*
*                      4.SPQE - SUBPOOL QUEUE ELEMENT
*                        THE QUEUE ELEMENT ESTABLISHED TO IDENTIFY A
*                        SUBPOOL.
*
*                        THESE FIELDS ARE REFERENCED
*
*                          SHARED SUBPOOL BIT - BIT INDICATOR WHICH
*                                               INDICATES THAT THIS
*                                               SUBPOOL IS OWNED BY
*                                               ANOTHER TASK.
*
*                          LAST SPQE BIT - BIT INDICATOR WHICH
*                                          INDICATES THAT THIS IS THE
*                                          LAST SPQE IN THE QUEUE.
*
*                          NEXT SPQE FIELD - A THREE BYTE FIELD WHICH
*                                            CONTAINS THE ADDRESS OF
*                                            THE NEXT SPQE IN THE QUEUE
*                                            EXCEPT IN THE LAST SPQE IN
*                                            THE QUEUE IN WHICH CASE IT
*                                            CONTAINS ZERO.
*
*                          SPQEID FIELD - A ONE BYTE FIELD CONTAINING
*                                         THE SUBPOOL ID NUMBER.
*
*                          SPQEDQE FIELD - A THREE BYTE FIELD
*                                          CONTAINING THE POINTER TO
*                                          THE FIRST DQE (DESCRIPTOR
*                                          QUEUE ELEMENT) BELONGING TO
*                                          THIS SUBPOOL EXCEPT IN A
*                                          SHARED SUBPOOL IN WHICH CASE
*                                          THIS FIELD POINTS TO THE
*                                          OWNING SPQE.
*
*                      5.DQE - DESCRIPTOR QUEUE ELEMENT
*                        A QUEUE ELEMENT WHICH IDENTIFIES A SET OF
*                        CONTIGUOUS 2048 BYTE BLOCKS BELONGING TO A
*                        SUBPOOL.
*
*                        THESE FIELDS ARE REFERENCED
*
*                          DQEFQE FIELD - THIS IS A THREE BYTE FIELD
*                                         WHICH POINTS TO THE FIRST FQE
*                                         IN THE SET OF 2048 BYTE
*                                         BLOCKS EXCEPT WHEN THERE ARE
*                                         NO FREE AREAS.  IT IS THEN
*                                         ZERO.
*
*                          NEXT DQE POINTER FIELD - THIS IS A THREE
*                                                   BYTE FIELD WHICH
*                                                   POINTS TO THE NEXT
*                                                   DQE IN THE QUEUE
*                                                   EXCEPT IN THE LAST
*                                                   DQE IN THE QUEUE IN
*                                                   WHICH IT IS ZERO.
         AIF   ('&LCS' NE 'Y').LC17                                LC0A
*                                                                  LC0A
*                          DQEHIID - A ONE BYTE FIELD CONTAINING   LC0A
*                                    THE HIERARCHY IDENTIFICATION  LC0A
.LC17    ANOP                                                      LC0A
*
*                          DQE ADDRESS FIELD - THIS IS A FOUR BYTE
*                                              FIELD IN WHICH THE FIRST
*                                              BYTE IS ZERO AND THE
*                                              LAST THREE BYTES CONTAIN
*                                              THE ADDRESS OF THE FIRST
*                                              2048 BYTE BLOCK
*                                              DESCRIBED BY THIS DQE.
*
*                          DQE LENGTH FIELD - THIS IS A FOUR BYTE FIELD
*                                             IN WHICH THE FIRST BYTE
*                                             IS ZERO AND THE LAST
*                                             THREE BYTES CONTAIN THE
*                                             NUMBER OF BYTES IN THE
*                                             SET OF CONTIGUOUS 2048
*                                             BYTE BLOCKS DESCRIBED BY
*                                             THIS DQE.
*
*                      6.FQE - FREE AREA QUEUE ELEMENT
*                        A QUEUE ELEMENT WHICH IDENTIFIES AND DESCRIBES
*                        A FREE AREA WITHIN THE SET OF 2048 BYTE BLOCKS
*                        DESCRIBED BY A DQE.
*
*                        THESE FIELDS ARE REFERENCED
*
*                          NEXT FQE FIELD - A FOUR BYTE FIELD IN WHICH
*                                           THE FIRST BYTE IS ZERO AND
*                                           IN WHICH THE LAST THREE
*                                           BYTES CONTAIN A POINTER TO
*                                           THE NEXT FREE AREA EXCEPT
*                                           IN THE LAST FREE AREA IN
*                                           THE QUEUE IN WHICH THIS
*                                           FIELD IS ZERO.
*
*                          FQE LENGTH FIELD - A FOUR BYTE FIELD IN
*                                             WHICH THE FIRST BYTE IS
*                                             ZERO AND IN WHICH THE
*                                             LAST THREE BYTES CONTAIN
*                                             THE NUMBER OF BYTES IN
*                                             THIS FREE AREA (THIS
*                                             INCLUDES THE QUEUE
*                                             ELEMENT).
*
*                      7.AQE - QUEUE ELEMENT FOR STORAGE ALLOCATED TO
*                        SUBPOOL 253 OR 254.
*
*                        THESE FIELDS ARE REFERENCED
*
*                          NEXT AQE FIELD - A FOUR BYTE FIELD IN WHICH
*                                           THE FIRST BYTE IS ZERO AND
*                                           IN WHICH THE LAST THREE
*                                           BYTES CONTAIN A POINTER TO
*                                           THE NEXT AQE FOR THIS TASK
*                                           EXCEPT IN THE LAST AQE IN
*                                           THE QUEUE FOR THIS TASK IN
*                                           WHICH THIS FIELD IS ZERO.
*
*                          AQE LENGTH FIELD - A FOUR BYTE FIELD IN
*                                             WHICH THE FIRST BYTE IS
*                                             ZERO AND IN WHICH THE
*                                             LAST THREE BYTES CONTAIN
*                                             THE NUMBER OF BYTES IN
*                                             THIS ALLOCATED AREA (THIS
*                                             INCLUDES THE QUEUE
*                                             ELEMENT).
*
*                      8.CDE - CONTENTS DIRECTORY ENTRY
*
*                        THESE FIELDS ARE REFERENCED
*
*                          CDATTR2 - A ONE BYTE FIELD CONTAINING
*                                    ATTRIBUTE FLAGS.
*
*                          REL - AN ATTRIBUTE FLAG IN CDATTR2
*                                INDICATING THAT THE LOAD MODULE IS
*                                INACTIVE AND MAY BE RELEASED.
*
*                      9.DUMMY PQE
*                        A QUEUE ELEMENT INDENTIFYING THE FIRST AND
*                        LAST PQES ON THE PQE CHAIN
         AIF   (&SMF EQ 0).MSSMFC                                   SMF
*                                                                   SMF
*                     10.TCT - TIMING CONTROL TABLE.                SMF
*                                                                   SMF
*                        THESE FIELDS ARE REFERENCED.               SMF
*                                                                   SMF
*                          TCTLWM - HIGHEST ADDRESS ALLOCATED FROM  SMF
*                                   LOW END OF REGION.              SMF
*                                                                   SMF
*                          TCTHWM - LOWEST ADDRESS ALLOCATED FROM   SMF
*                                   HIGH END OF REGION.             SMF
*                                                                   SMF
*                          TCTMINC - MINIMUM DIFFERENCE BETWEEN LWM SMF
*                                    AND HWM IN 2K VALUE.           SMF
         AIF   ('&RORI' NE 'Y').MSSMFC                              SMF
*                                                                   SMF
*                          TCTRBC - CURRENT BORROWED CORE IN 2K BLKSSMF
*                                                                   SMF
*                          TCTMBC - MAXIMUM BORROWED CORE IN 2K BLKSSMF
.MSSMFC  ANOP                                                       SMF
*
*LIST ORIGINS, TABLES
*AND CONTROL BLOCKS
*INCLUDED-               NONE
*
*RESTRICTIONS ON
*USE OF ROUTINE-       1.PROBLEM PROGRAMS MAY ONLY USE SUBPOOLS 0-127.
*
*                      2.PROGRAMS IN SUPERVISOR MODE MAY ALSO USE
*                        SUBPOOLS 128-255, BUT ONLY AS  DEFINED BY THE
*                        SUPERVISOR.
*
*                      3.DISABLED ROUTINES MAY NOT USE THE
*                        UNCONDITIONAL FORM OF SVC 4 OR THE GETMAIN
*                        FORM OF SVC 10.
*
*NOTES-                  NONE
         EJECT
*        INPUT PARAMETERS
*
*    TO REGMAIN (SVC 10)
*
*        REGISTER 0 = SUBPOOL ID IN THE HIGH ORDER BYTE
*                   = LENGTH IN THE LOW ORDER THREE BYTES
*
*        REGISTER 1 = ANY NEGATIVE VALUE IF REQUEST IS TO GETMAIN
*                   = THE POSITIVE ADDRESS OF THE AREA TO BE FREED IF
*                          THE REQUEST IS TO FREEMAIN
*
*
*    TO GETMAIN (SVC 4)
*
*        REGISTER 1 = ADDRESS OF A PRAMETER LIST
*
*
*    TO FREEMAIN (SVC 5)
*
*        REGISTER 1 = ADDRESS OF A PARAMETER LIST
*
*    TO BRANCH ENTRY POINTS
*
*        SAME INPUT AS FOR CORRESPONDING SVC ENTRY EXCEPT THAT IN
*        ADDITION THE ENVIRONMENTAL REGISTERS AND THE RETURN REGISTER
*        MUST BE SET UP BY THE CALLER SINCE THE INTERRUPT HANDLER IS
*        BYPASSED.
*
*
*    PARAMETER LIST FORMAT
*
*              ********************************************
*              * LENGTH REQUESTED IF SINGLE AREA REQUEST  *
*              *  OR ADDRESS OF A LIST OF LENGTHS         *
*              ********************************************
         AIF   ('&LCS' NE 'Y').LC18                                LC0A
*              * HIERARCHY*     ADDRESS OF AREA LIST      *        LC0A
*              *   IDENT  *                               *        LC0A
         AGO   .LC19                                               LC0A
.LC18    ANOP                                                      LC0A
*              * ADDRESS OF A LIST IN WHICH THE ADDRESSES *
*              *  OF ALLOCATED AREAS IS TO BE RETURNED    *
.LC19    ANOP                                                      LC0A
*              ********************************************
*              * CODE     * SUBPOOL  *
*              *          *   ID     *
*              ***********************
*
*          CODE VALUES
*              X'00' - UNCONDITIONAL SINGLE ELEMENT REQUEST
*              X'20' - CONDITIONAL     ''     ''      ''
*              X'C0' - UNCONDITIONAL VARIABLE REQUEST
*              X'E0' - CONDITIONAL      ''      ''
*              X'80' - UNCONDITIONAL LIST REQUEST
*              X'A0' - CONDITIONAL    ''    ''
         EJECT
*    LIST FORMATS
*
*        SINGLE ELEMENT REQUEST
*
*           AREA LIST
*              ********************************************
*              *          * ADDRESS OF AREA ALLOCATED     *
*              ********************************************
*
*        VARIABLE REQUEST
*
*           LENGTH LIST
*              ********************************************
*              *    0     * MINIMUM LENGTH REQUESTED      *
*              ********************************************
*              *    0     * MAXIMUM LENGTH REQUESTED      *
*              ********************************************
*
*           AREA LIST
*              ********************************************
*              *          * ADDRESS OF AREA ALLOCATED     *
*              ********************************************
*              *          * ACTUAL LENGTH ALLOCATED       *
*              ********************************************
*
*        LIST REQUEST
*
*           LENGTH LIST
*              ********************************************
*              * SIGN = 0 * FIRST LENGTH REQUESTED        *
*              ********************************************
*              * SIGN = 0 * SECOND LENGTH REQUESTED       *
*              ********************************************
*              /                                          /
*              ********************************************
*              * SIGN = 1 * LAST LENGTH REQUESTED         *
*              ********************************************
*
*           AREA LIST
*              ********************************************
*              *          * ADDR OF AREA FOR FIRST LENGTH *
*              ********************************************
*              *          * ADDR OF AREA FOR SECOND LENGTH*
*              ********************************************
*              /                                          /
*              ********************************************
*              *          * ADDR OF AREA FOR LAST LENGTH  *
*              ********************************************
         EJECT
         SPACE
         SPACE 2
*    PQE - PARTITION QUEUE ELEMENT
         SPACE
*********************************************************************
*        *  FORWARD FBQE POINTER  *        * BACKWARD FBQE POINTER  *
*   0    *  OR PQE ADDRESS        *   0    * OR PQE ADDRESS         *
*        *         (FWDPTR)       *        *        (BCKPTR)        *
*********************************************************************
*        *                        *        *                        *
*   0    *   FORWARD PQE POINTER  *   0    *  BACKWARD PQE POINTER  *
*        *        (PQENXT)        *        *       (PQEPREV)        *
*********************************************************************
*        *                        *        *                        *
*   0    *      TCB POINTER       *    0   *    SIZE OF REGION      *
*        *        (PQETCB)        *        *      (PQERGSZ)         *
*********************************************************************
*        *   ADDRESS OF FIRST     *        *        *               *
*   0    *    BYTE IN REGION      * FLAGS  * HI ID  *        0      *
*        *      (PQESTADD)        *        *        *               *
*********************************************************************
         SPACE
*        FLAGS- X'80' - PQE REGION IS BORROWED BY ROLLOUT
         SPACE 3
*    FBQE - FREE BLOCK QUEUE ELEMENT
         SPACE
*********************************************************************
*        *                        *        *                        *
*   0    *     FORWARD POINTER    *    0   *    BACKWARD POINTER    *
*        *         (FWDPTR)       *        *        (BCKPTR)        *
*********************************************************************
*        *                        *
*   0    *          SIZE          *
*        *                        *
***********************************
         SPACE 3
*    SPQE - SUBPOOL QUEUE ELEMENT
         SPACE
*********************************************************************
*        *  SPQE POINTER OR       * SUBPOOL*  DQE ADDRESS OR        *
* FLAGS  *    ZERO (IF LAST SPQE) *   ID   *   SPQE OF HIGHER LEVEL *
*        *                        *        *   TASK SHARING SUBPOOL *
*********************************************************************
         SPACE
*        FLAGS- X'80' - SUBPOOL IS SHARED
*             - X'40' - LAST SPQE ON CHAIN
         SPACE 3
*    DQE - DESCRIPTOR QUEUE ELEMENT
         SPACE
*********************************************************************
*        *                        *        *                        *
*   0    *    FQE POINTER         *    0   *      DQE POINTER       *
*        *   (0 = NO FQES)        *        * (0 = LAST DQE ON CHAIN)*
*********************************************************************
*        *                        *        *    NUMBER OF BYTES     *
         AIF   ('&LCS' NE 'Y').LC20                                LC0A
* HI ID  *  FIRST BLOCK ADDRESS   *    0   *       IN BLOCKS        *
         AGO   .LC21                                               LC0A
.LC20    ANOP                                                      LC0A
*   0    *  FIRST BLOCK ADDRESS   *    0   *       IN BLOCKS        *
.LC21    ANOP                                                      LC0A
*        *                        *        *                        *
*********************************************************************
         SPACE 3
*    FQE - FREE QUEUE ELEMENT
         SPACE
*********************************************************************
*        *                        *        *                        *
*   0    *    FQE POINTER         *    0   * LENGTH OF FREE AREA    *
*        *                        *        *                        *
*********************************************************************
         SPACE 4
*    AQE - ALLOCATED SUPERVISOR QUEUE SPACE QUEUE ELEMENT (FOR SUBPOOLS
*          253-254)
         SPACE
*********************************************************************
*        *                        *        *                        *
*   0    *    AQE POINTER         *    0   *       LENGTH OF        *
*        *                        *        *     ALLOCATED AREA     *
*********************************************************************
         AIF   (&SMF EQ 0).MSSMFD                                   SMF
         SPACE 4                                                    SMF
*    TCT - TIMING CONTROL TABLE CORE USED AREA.                     SMF
         SPACE 1                                                    SMF
********************************************************************SMF
*        *                        *        *                        SMF
*   0    *    LOW WATER MARK      *   0    *     HIGH WATER MARK    SMF
*        *                        *        *                        SMF
********************************************************************SMF
*                *                *                                 SMF
* MINIMUM DIFF.  *  REGION SIZE   *                                 SMF
* (2K BLOCKS)    *  (2K BLOCKS)   *                                 SMF
********************************************************************SMF
         AIF   ('&RORI' NE 'Y').MSSMFD                              SMF
         SPACE 1                                                    SMF
********************************************************************SMF
*                                 *                *                SMF
*                                 * CUR BORWD CORE * MAX BORWD CORE SMF
*                                 *  (2K BLOCKS)   *  (2K BLOCKS)   SMF
********************************************************************SMF
.MSSMFD  ANOP                                                       SMF
         EJECT
*        GETMAIN ENTRY POINT
*
         DS    0D
IGC004   BALR  RBASE,0
         USING MSSBASE,RBASE,FREBAS   ESTABLISH DOUBLE BASE       20021
*
MSSBASE  L     FREBAS,DBASADR      ESTABLISH DOUBLE BASE          20021
         MVC   MODEBYTE(1),33(0)   MOVE INTO MODE BYTE            20021
         AIF   ('&RORI' NE 'Y').GO60                               LC0A
         MVI   ENTRANT,X'F4'  SET ENTRY SWITCH TO NON-BRANCH CODE
.GO60    ANOP
GMBASE   MVI   SVCBYTE,4
         AIF   ('&LCS' NE 'Y').LC01                                LC0A
         MVC   HIBYTE(1),4(RIN1)   ISOLATE HIERARCHY IDENT         LC0A
.LC01    ANOP                                                      LC0A
         L     IPVLBASE,IPVAL
         BALR  RCOMRET1,IPVLBASE   VALIDITY CHECK INPUT PARAMETERS
*                  RETURN WITH - RLENGTH = LENGTH/ADDR OF LENGTH LIST
*                                 RADDR   = ADDR OF AREA LIST
*                                 RSPID   = SUBPOOL ID
         SPACE
         TM    8(RIN1),X'C0'       CHECK TYPE OF REQUEST
         BC    4,GLIST             LIST
         BC    1,GVAR              VARIABLE
*
         BAL   RGMRET,GMCOMMON     ELEMENT - BRANCH TO GET STORAGE
         B     GMSEXIT              BRANCH TO S-TYPE REQUEST EXIT
         B     GNOTSAT             EXIT-REQUEST NOT SATISFIED
         SPACE
*        LIST REQUEST PROCESSING
*
GLIST    LR    RLST,RLENGTH        SAVE LENTH LIST ADDR
         LA    RGMRET,GMCOMMON     ADDR OF COMMON ROUTINE
GLIST1   L     RLENGTH,0(RLST)     LOAD REQUESTED LENGTH
         AIF   ('&LCS' NE 'Y').LC02                                LC0A
         CLI   4(RIN1),X'80'       Q. CTL PGM MIXED HIERARCHY REQ. LC0A
         BNE   GLIST1A             NO                              LC0A
         MVC   HIBYTE(1),0(RADDR)  INSERT HIERARCHY IDENT FROM LISTLC0A
.LC02    ANOP                                                      LC0A
GLIST1A  LA    RLENGTH,0(RLENGTH)  CLEAR LAST ENTRY INDICATOR      LC0A
         BALR  RGMRET,RGMRET       BRANCH TO COMMON ROUTINE
         B     GLEFND              ENTRY FOUND
*
*        LIST REQUEST NOT SATISFIED-RELEASE CORE ALREADY ALLOCATED
*
         B     GNOTSAT
GLIST2   C     RLST,0(RIN1)        IF FIRST LIST ENTRY FAILED
         AIF   ('&RORI' NE 'Y').GOR5                               LC0A
         BCR   8,RORIREG  BYPASS FREEING ENTRIES
         AGO   .GOR6
.GOR5    ANOP
         BE    GNOTSAT4  BYPASS FREEING ENTRIES
.GOR6    ANOP
         LA    RWORK2,4            DECREMENT LIST ADDRESS TO LAST
         SR    RLST,RWORK2           ENTRY ALLOCATED
         OI    0(RLST),X'80'     SET TEMPORARY END OF LIST FOR FREEMAIN
         ST    RLST,SAVEREGS+LSTREG     SAVE CURRENT LIST ADDR    ****
         L     RLST,0(RIN1)        LOAD STARTING LIST ADDRESSES
         L     RADDR,4(RIN1)
         LA    RFMRET,FCOMMON1
         BAL   RRETURN,FLISTADV    FREE LIST ENTRIES ALREADY ALLOCATED
         NI    FREESW,255-X'08'                                   21016
         LM    RADDR,FREBAS,SAVEREGS  RESTORE REGS (11-3)         20021
         XI    0(RLST),X'80'       TURN OFF TEMPORARY END OF LIST BIT
         AIF   ('&RORI' NE 'Y').GOR7                               LC0A
         BCR   15,RORIREG  EXIT-REQUEST NOT SATISFIED
         AGO   .GOR8
.GOR7    ANOP
         B     GNOTSAT4  EXIT-REQUEST NOT SATISFIED
.GOR8    ANOP
*
*        CHECK FOR MORE LIST ENTRIES
*
GLEFND   TM    0(RLST),X'80'       IS THIS LAST ENTRY IN LIST
         AIF   ('&RORI' NE 'Y').GO101                              LC0A
         MVI   PQESTAT,X'00'       RESET SEARCH TO OWNED CORE
.GO101   ANOP
         BO    GMSEXIT               YES - EXIT
*
         LA    RLST,4(RLST)          NO  - CHECK NEXT ENTRY
         AIF   ('&RORI' NE 'Y').GO102                              LC0A
         L     RADDR,SAVEREGS
.GO102   ANOP
         LA    RADDR,4(RADDR)
         LA    RGMRET,GCOMMON1     ADDR OF COMMON ROUTINE BYPASSING
*                                     SPQE SEARCH
         B     GLIST1
*
*
*        VARIABLE REQUEST PROCESSING
*
GVAR     LR    RLST,RLENGTH
         L     RLENGTH,4(RLST)     LOAD MAXIMUM REQUESTED
         BAL   RGMRET,GMCOMMON     GET STORAGE
         B     GVARFND             CORE FOUND
*                                  CORE NOT FOUND
         BAL   RRET,CDPURGE        PURGE JPA AND LPA
         AIF   ('&RORI' NE 'Y').GO70                               LC0A
         B     PURGSW             IF STORAGE FREED
         AGO   .GO71
.GO70    ANOP
         B     GMREPEAT            IF STORAGE FREED
.GO71    ANOP
         AIF   ('&RORI' NE 'Y').GO72                               LC0A
         TM    IEAROSW,X'FF'  IS ROLLOUT DATA SET OPEN.
         BO    GVFNDR  NO. TRY TO SATISFY MINIMUM.
         TM    8(RIN1),X'E0'    IS THIS A VAR COND REQ?         SA63045
         BC    1,GVFNDR .                YES, BR TO SAT MIN NOT  A26046
*                                            CAUSING A ROLLOUT   A26046
         ST    RADDR,SAVEREGS      SAVE ADDR. OF AREA ALLOCATED
         L     FPQEBASE,FRBASEAD
         L     RORIREG,VARUNCAD
         BR    RORIREG
.GO72    ANOP
GVFNDR   EQU   * .                                               A31213
         LTR   RSPID,RSPID         REQUEST FOR SUBPOOL 253 OR 254
         BC    11,GMINCK             NO-CHECK MINIMUM LENGTH
         LA    RGMRET,8            DECREMENT MAXIMUM AVAILABLE TO ALLOW
         SR    RLRGSIZ,RGMRET       FOR QEC
*
GMINCK   EQU   * .                                               A31213
         LR    RGMRET,RLENGTH .          SAVE MAX LENGTH         A31213
         L     RLENGTH,0(RLST) .         LOAD MIN LENGTH         A31213
         C     RLENGTH,FBQESIZ .         IS LENGHT > THAN FBQE?  A31213
         BH    CKMAX .                   YES, BRANCH             A31213
         L     RLENGTH,FBQESIZ .         LOAD SIZE FOR ALLOC     A31213
         B     GETMIN .                                          A31213
GNTST4   EQU   * .                                               A31213
         AIF   ('&RORI' EQ 'Y').RO0                              A31213
         B     GNOTSAT4 .              PROCESS CONDITIONAL REQ   A31213
         AGO   .RO1                                              A31213
.RO0     ANOP                                                    A31213
         SR    RLENGTH,RGMRET .    RESTORE MAX SIZ FOR RORI      A31213
         L     FPQEBASE,FRBASEAD .      LOAD BASE FOR BRANCH     A31213
         L     RORIREG,GNSAT4AD .       LOAD ADDR OF GNOTSAT4    A31213
         BR    RORIREG .                BRANCH TO GNOTSAT4       A31213
.RO1     ANOP                                                    A31213
CKMAX    EQU   * .                                               A31213
         C     RLENGTH,K4080 .      CAN REQUEST BE SAT BY FQE    A31213
         BH    GNTST4 .             NO, PROCESS CONDITIONAL REQ  A31213
         L     RLENGTH,K4080 .         LARGEST FQE CAN ALLOC  BC A49843
         L     RADDR,SAVEREGS .                               BC A49843
         BAL   RGMRET,GCOMMON1 .      INIT FQESIZE FIELD      BC A49843
         B     GVARFND .              CORE FOUND              BC A49843
         L     RLENGTH,0(RLST) .     RELOAD MIN LENGTH        BC A49843
         C     RLENGTH,FQESIZ .     IS FREE CORE AVAIL IN FQE    A31213
         BH    GNTST4 .             NO, PROCESS CONDITIONAL REQ  A31213
         L     RLENGTH,FQESIZ .     LOAD SIZE OF LARGEST FQE     A31213
GETMIN   EQU   * .                                               A31213
         L     RADDR,SAVEREGS .                                  A31213
*
         BAL   RGMRET,GCOMMON1       -BYPASS SPID CHECK
         B     GVARFND             CORE FOUND
         AIF   ('&RORI' NE 'Y').GO77                               LC0A
         L     FPQEBASE,FRBASEAD
         L     RORIREG,ROTST5AD
         BR    RORIREG
         AGO   .GO78
.GO77    ANOP
         B     GNTST4   NO CORE AVAILABLE, PROCESS COND. REQ    SA66067
.GO78    ANOP
*
         AIF   ('&RORI' NE 'Y').GO103                              LC0A
GVARFND  L     RADDR,SAVEREGS      LOAD ADDRESS OF AREA LIST IN REG. A
         ST    RLENGTH,4(RADDR)    STORE ALLOCATED LENGTH IN LIST
         AGO   .GO104
.GO103   ANOP
GVARFND  ST    RLENGTH,4(RADDR)    STORE ALLOCATED LENGTH IN LIST
.GO104   ANOP
         B     GMSEXIT
*
         SPACE 2
*        BRANCH ENTRY PROCESSING
         SPACE
         DROP  FREBAS .            DROP BASE FOR ADDRESSABILITY   M0105
GMBRANCH LR    RIN15,RBASE         SAVE REGISTER 8
         BALR  RBASE,0
         USING *,RBASE
         L     RBASE,MSSADR
         USING MSSBASE,RBASE,FREBAS                               20021
         SSM   CLHIBYTE .           DISABLE                       M3872
         ST    RIN15,BRANCHSV+24   RIN15 = ENTRY CONTENTS OF REG8
         LA    RIN15,GMBASE        SET UP BRANCH TO GETMAIN
GMBRNCOM STM   RLST,RCOMRET3,BRANCHSV SAVE REGISTERS FOR CALLER   M3872
         STM   RCOMRET1,RRETURN,BRANCHSV+28
         L     FREBAS,DBASADR      INITIALIZE SECOND BASE         20021
         ST    RRETURN,BRNREG   SAVE RETURN REG FOR ABEND INFO    21016
         MVI   MODEBYTE,0          SET MODE AS SUPERVISOR
         MVI   BESW,X'FF'              SET BRANCH ENTRY SWITCH
.A       BALR  RRETURN,RIN15            BRANCH TO GETMAIN OR FREEMAIN
         MVI   BESW,X'00'               RESET BRANCH ENTRY SWITCH
.B       LM    RLST,RRETURN,BRANCHSV    RESTORE REGISTERS FOR CALLER
         BR    RRETURN             RETURN TO CALLER
         AIF   ('&RORI' NE 'Y').GO13                               LC0A
         SPACE 2
IEAFRPQE CSECT
         ENTRY FRBRBASE
         ENTRY FREBRF
         ENTRY GETIQE
         ENTRY GNOTSAT4
         ENTRY ROTEST5
         ENTRY TESTRO
         ENTRY VARUNCD
FREBRPQE BALR FPQEBASE,0
         USING *,FPQEBASE
FRBRBASE CLI   CDPRGSW,X'FF'       WAS THERE A SUCCESSFUL PURGE
         BNE   RESTORE             NO, BYPASS PQE TEST
FREBRF   EQU   * .                                               A30185
         L     RTCB,TCBJSTCB(RTCB) .    GET JOBSTP TCB ADDR      A30185
         L     RWORK1,TCBPQE(RTCB) .    PICK UP DUMMY PQE        A30185
         NI    31(RTCB),X'BF'           TURN OFF TCBFRI FLAG
         LTR   RWORK1,RWORK1
         BZ    RESTORE
         L     RWORK1,DUMFWD(RWORK1) PICK UP REAL PQE
MOREPQE  TM    RORIFLG(RWORK1),RGNSHRD IS THE REGION BORROWED
         BO    TSTFBQE            YES, DETERMINE IF IT IS FREE
NXTPQE   L     RWORK1,PQENXT(RWORK1)
         LTR   RWORK1,RWORK1      IS THIS THE END OF THE CHAIN
         BZ    RESTORE            GO TO RESTORE AND RETURN
         B     MOREPQE
TSTFBQE  L     RWORK2,FWDPTR(RWORK1) PICK UP FIRST FBQE
         CR    RWORK2,RWORK1      IS FBQE PTR EQUAL TO PQE PTR
         BE    SETRIFLG .            YES,SET RORI FLAG           A32583
         CLC   FBQESIZE(4,RWORK2),PQERGSZ(RWORK1) IS THE AREA FREE
         BE    SCHEDRRI
SETRIFLG EQU   *                                                SA63886
*****    THE NEXT STATEMENTS DETERMINE IF WE'RE RUNNING ******  SA63886
*****    UNDER AN INITIATOR FOR A JSTCB, IF SO DON'T TURN ON *  SA63886
*****    TCBFRI FLAG IN THE TCB                        *******  SA63886
         L     RWORK2,132(RTCB)   PICK UP MOTHER TCB            SA63886
         L     RWORK2,132(RWORK2) PICK UP MOTHER'S MOTHER       SA63886
         L     RWORK3,MSCEDADD     PICK UP M/S TCB              SA63886
         CR    RWORK2,RWORK3   IS GRANDMOTHER TCB THE M/S?      SA63886
         BE    RESTORE         YES, DON'T TURN ON TCBFRI        SA63886
         OI    31(RTCB),X'40'  TURN ON TCBFRI FLAG              SA63886
         B     NXTPQE
SCHROUT  LCR   RWORK4,RWORK4            COMPLEMENT IQE ADDRESS
         ST    RRETURN,BASEHOLD
         L     RRETURN,16(0)
         L     RRETURN,CVT0EF00(RRETURN)
         BALR  RRETURN,RRETURN          SCHEDULE IRB
         L     RRETURN,BASEHOLD         RESTORE AND RETURN
         BR    RORIREG
SCHEDRRI L     RORIREG,PQETCB(RWORK1)     IS THIS THE SYSTEM QUEUE
         LTR   RORIREG,RORIREG
         BZ    DEQUESYS                 YES
UPD3     L     RORIREG,PQEPREV(RWORK1)    IS THIS THE FIRST PQE
         LTR   RORIREG,RORIREG
         BZ    DUMFIR
         L     RORIREG,PQEPREV(RWORK1)    UPDATE PQE POINTER
         MVC   PQENXT(4,RORIREG),PQENXT(RWORK1)
UPD1     L     RORIREG,PQENXT(RWORK1)
         LTR   RORIREG,RORIREG              IS THIS THE LAST PQE
         BZ    DUMLST
         MVC   PQEPREV(4,RORIREG),PQEPREV(RWORK1)
UPD2     MVC   IQESAVE(4),PQERET       SAVE PQERET OVER GET IQE
         BAL   RORIREG,GETIQE          GET IQE
         MVC   PQERET(4),IQESAVE       RESTORE PQERET
         LA    RORIREG,16(RWORK4)  ADDRESS OF PARAMETER LIST
         ST    RWORK1,4(RORIREG)     ADDRESS OF PQE
         ST    RTCB,0(RORIREG)       ADDRESS OF TCB
         MVI   4(RORIREG),0          INITIALIZE REMAINDER OF LIST
         LCR   RORIREG,RORIREG
         ST    RORIREG,4(RWORK4)     ADDRESS OF LIST IN COMPLEMENT FORM
         BAL   RORIREG,SCHROUT       SCHEDULE IRB
         B     NXTPQE
DUMFIR   L     RORIREG,TCBPQE(RTCB)       DUMMY
         MVC   DUMFWD(4,RORIREG),PQENXT(RWORK1)
         B     UPD1
DUMLST   L     RORIREG,TCBPQE(RTCB)       DUMMY
         MVC   DUMBWD(4,RORIREG),PQEPREV(RWORK1)
         L     RORIREG,PQEPREV(RWORK1)
         MVC   PQENXT(4,RORIREG),PQENXT(RWORK1)
         B     UPD2
DEQUESYS L     RPQE,GOVRFLB+8           ADDRESS OF PQE
         L     RPQE,DUMFWD(RPQE)   PICK UP ADDRS OF REAL PQE
         AIF   ('&LCS' NE 'Y').LCR1                                LC0A
COMPARE  CLC   29(1,RPQE),29(RWORK1) FREE AREA IN THIS HIERARCHY   LC0A
         BE    STORE                    YES, BRANCH                LC0A
         L     RPQE,8(RPQE)             GET NEXT SYSTEM PQE        LC0A
         B     COMPARE                  TEST THIS ONE              LC0A
STORE    ST    RRETURN,BASEHOLD         SAVE REGISTER E            LC0A
         AGO   .LCR2                                               LC0A
.LCR1    ANOP                                                      LC0A
         ST    RRETURN,BASEHOLD                                    LC0A
.LCR2    ANOP                                                      LC0A
         ST    RWORK1,BASEHOLD+4     SAVE PQE ADDRESS             20021
         L     RBLOCK,FWDPTR(RWORK1)    ADDRESS OF PARTITION
         L     RSIZE,FBQESIZE(RBLOCK)   PARTITION SIZE
         BAL   RCOMRET1,MRELEASE        RELEASE TO SYSTEM PQE
         L     RWORK1,BASEHOLD+4  RESTORE PQE ADDRESS             20021
         AIF   ('&MPS' NE 'Y').MP02                                MP65
         STM   RIN0,RIN15,VQERISAV SAVE REGS WHILE TEST VQES       MP65
         LR    RWORK5,RWORK1       PICK PQE FOR RETD STORAGE       MP65
         L     RIN1,VQBASE         ADDR OF DEFERRED VARY RTN       MP65
         BALR  RIN1,RIN1           LINK TO PROCESS VQES            MP65
         USING *,RIN1                                              MP65
         LM    RIN0,RIN15,VQERISAV RESTORE REGISTERS               MP65
         DROP  RIN1                                                MP65
.MP02    ANOP                                                      MP65
         L     RRETURN,BASEHOLD
         B     UPD3
ROTEST5  TM    IEAROSW,X'FF'     IS ROLLOUT IN THE SYSTERM         MO18
         BO    GNOTSAT6          NO  - CANNOT ATTEMPT ROLLOUT      MO18
         CL    RSPID,C252        IS REQUEST FOR SQS                MO18
         BH    GNOTSAT6          YES - CANNOT ATTEMPT ROLLOUT      MO18
TESTRO   TM    IEAROSW,X'FF'       IS ROLLOUT DATA SET OPEN
         BO GNOTSAT8  NO.  CAN OT SATISFY REQUEST
         CLI   PQESTAT,X'FF'      HAS REQUEST SEARCHED BORROWED
         BE    ROTEST             YES, TEST FOR ROLLOUT ELIGIBILITY
         MVI   PQESTAT,X'FF'      SET BORROWED SWITCH
         B     GMREPEAT
ROTEST   TM    ENTRANT,X'F0'  WAS THIS A BRANCH ENTRY
         BZ    ROTEST1  YES, ROLLOUT CANNOT BE INVOKED
         CLI   ENTRANT,X'FA'  WAS THIS A SVC 10
         BE    SETRTRN
         TM    8(RIN1),X'C0'  IS THIS A LIST REQUEST
         BC    9,ROCONTST  NO, TEST FOR CONDITIONAL
         BAL   RORIREG,GLIST2  YES. FREE UP CORE ALREADY GOTTEN.
         BALR  FPQEBASE,0
         USING *,FPQEBASE
         L     FPQEBASE,FRBASE
         USING FRBRBASE,FPQEBASE
ROCONTST TM    8(RIN1),32  CONDITIONAL
         BC    1,GNOTST1  YES. CANNOT ROLLOUT.
SETRTRN  LA    RGMRET,GRETURN1
         ST    RGMRET,PQERET
         B     ROTEST2
ROTEST1  LA    RGMRET,GNOTSAT6  SET UP RETURN POINT
         B     PQESETP
ROTEST2  L     RCVT,16(0)  PICK UP CVT
         L     RTCB,CVTTCB(RCVT)  PICK UP 'NEW'
         L     RTCB,4(RTCB)  PICK UP 'OLD'
         TM    TCBABND(RTCB),X'C0'  IS ABEND IN PROGRESS FOR STEP
         BC    5,GNOTSAT8  YES.  DON'T SCHEDULE ROLLOUT
         L     RORIREG,TCBJSTCB(RTCB)  PICK UP JOBSTEP TCB
         TM    TCBFMC(RORIREG),X'20'  CAN THIS TASK CAUSE ROLLOUT.
         BZ    GNOTSAT8            NO
         AIF   ('&LCS' NE 'Y').LC51                                LC0A
         CLI   HIBYTE,X'01'        Q. IS REQUEST FOR HIERARCHY 1   LC0A
         BNE   TSTH0MAX            NO - CHECK H0 MAX. AVAIL. CORE  LC0A
         C     RLENGTH,GOVRFLB+16  Q. IS REQUEST GT AVAIL. H1 CORE LC0A
         BH    GNOTSAT8            YES - ERROR                     LC0A
         B     SHEDRO             NO - SCHEDULE ROLLOUT            MO18
TSTH0MAX C     RLENGTH,GOVRFLB+12  Q. IS REQUEST GT AVAIL. H0 CORE LC0A
         AGO   .LC52                                               LC0A
.LC51    ANOP                                                      LC0A
         C     RLENGTH,GOVRFLB+12  DOES REQUEST EXCEED AVAIL CORE SIZE
.LC52    ANOP                                                      LC0A
         BH    GNOTSAT8            YES. ZONK IDIOT TASK
SHEDRO   MVC   IQESAVE(8),SAVEREGS+20  SAVE REGS ACROSS GETIQE     MO18
         MVC   IQESAVE+8(4),PQERET
         BAL   RORIREG,GETIQE      GET AN IQE
         MVC   SAVEREGS+20(8),IQESAVE
         MVC   PQERET(4),IQESAVE+8
         LA    RORIREG,16(RWORK4)  ADDRESS OF ROLLOUT PARAMETER LIST
         ST    RTCB,0(RORIREG)           ADDRESS OF TCB
         TM    8(RIN1),X'C0' .    IS IT A LIST REQUEST       BC  A37143
         BC    9,SHEDONE .        NO, USE ONE LENGTH         BC  A37143
         LR    RLST,RIN1 .        YES, SAVE LIST ADDR        BC  A37143
SHEDLST  L     RWORK1,0(RLST) .   ADD LENGTHS                BC  A37143
         LA    RLENGTH,RWORK1 .   CLEAR BYTE AND ADD         BC  A37143
         TM    0(RLST),X'80' .    IS TI LAST ENTRY           BC  A37143
         BO    SHEDONE .          YES, USE TOTAL             BC  A37143
         LA    RLST,4(RLST) .     NO, REPEAT                 BC  A37143
         B     SHEDLST .          ADD NEXT ELEMENT           BC  A37143
SHEDONE  ST    RLENGTH,4(RORIREG) .     SIZE OF STORAGE      BC  A37143
         AIF   ('&LCS' NE 'Y').LCR0                                LC0A
         MVC   4(1,RORIREG),HIBYTE      INSERT HIERARCHY IDENT     LC0A
.LCR0    ANOP                                                      LC0A
         ST    RORIREG,4(RWORK4)         ADDRESS OF LIST IN TRUE FORM
         BAL   RORIREG,SCHROUT           SCHEDULE IRB
         OI   TCBFCD1(RTCB),X'20' .    INDICATE TASK WAITING     A33335
*                                   FOR CORE                     A33335
         L     RWORK1,36        LOAD RIGHT HALF OF PSW
         LA    RWORK2,2
         SR    RWORK1,RWORK2    BACK UP PSW
         ST    RWORK1,36        STORE PSW
         L     RWK3CVT,16(0)          RELOAD CVT ADDR             20021
         L     RWORK3,0(RWK3CVT)      LOAD ADDRESS OF NEW         20021
         CLC   0(4,RWORK3),4(RWORK3)  TASK SWITCH ALREADY INDICATED
         BNE   NOSWITCH
         SR    RWORK1,RWORK1
         ST    RWORK1,0(RWORK3) SET 'NEW' TO 0, CAUSE A TASK SWITCH
NOSWITCH LM    RIN0,RIN1,SAVEREGS+20  RESTORE REGISTERS
         L     14,SVCXT .          GET ADDR OF SPECIAL EXIT
         XC    PQESTAT(3),PQESTAT . TURN OFF SW FOR EXIT
         BR    14 .                GO TO SPECIAL EXIT IN QNU BL
GNOTSAT8 XC    PQESTAT(3),PQESTAT .   TURN OFF SW FOR EXIT        M3872
         B     SETERR8
VARUNCD  CLI   PQESTAT,X'FF'      HAS REQUEST BEEN REISSUED
         BE    VARSRCH            YES, TEST TO ALLOCATE OR ROLLOUT
         MVI   PQESTAT,X'FF'      SEARCH BORROWED PQE
         ST    RLRGSIZ,ORGLRG     KEEP LARGEST SIZE
         B     GMREPEAT           REISSUE REQUEST
VARSRCH  C     RLRGSIZ,ORGLRG     IS BORROWED LARGER THEN ORIGINAL
         BNH   FURCOM             NO, ORIGINAL WILL BE ASSIGNED
VARORG   C     RLRGSIZ,0(RLST)    IS BORROWED GREAT OR EQ TO MINIMUM
         BNL   GVFNDR             YES, ASSIGN THE CORE
         LTR   RSPID,RSPID        REQUEST FOR SUBPOOL 253 OR 254
         BC    11,ROTEST          NO, SCHEDULE ROLLIN/ROLLOUT
         LA    RGMRET,8           DECREMENT TO ALLOW FOR QEC
         SR    RLRGSIZ,RGMRET
         C     RLRGSIZ,0(RLST)
         BNH   GNOTSAT4  CORE CANNOT BE ALLOCATED
         B     ROTEST             TEST FOR ROLLOUT ELIGIBILITY
FURCOM   L     RLRGSIZ,ORGLRG     GET OWNED LARGEST CORE
         B     VARORG             ALLOCATE OR ROLLOUT
GNOTSAT6 TM    ENTRANT,X'F0'  WAS THIS A BR ENTRY             A36468
         BZ    GNOTSAT4 .                                        A57079
         CLI   ENTRANT,X'FA' .         WAS IT SVC 10          BC A36468
         BE    COND2
         TM    8(RIN1),X'C0'  IS THIS A LIST REQUEST
         BC    9,GNOTSAT4  NO, TEST FOR CONDITIONAL
         BAL   RORIREG,GLIST2  YES. FREE UP CORE ALREADY GOTTEN.
         BALR  FPQEBASE,0
         USING *,FPQEBASE
         L     FPQEBASE,FRBASE
         USING FRBRBASE,FPQEBASE
GNOTSAT4 TM    8(RIN1),32          IS THIS CONDITIONAL
         BC    14,COND2            NO
GNOTST1  LA    RIN15,4             SET RETURN CODE OF 4
         B     GRETURN             RETURN
COND2    CL    RSPID,C252          IS REQUEST FOR SQ SPACE
         BH    GNOTSAT5            YES
         B     GNOTSAT8
RESTORE  L     RGMRET,PQERET
         BR    RGMRET
*
* GETIQE SUBROUTINE
*
* THE FOLLOWING INSTRUCTIONS ESTABLISH PROPER ADDRESSABILITY FOR
* ROUTINES WHICH ACCESS GETIQE FROM EXTERNAL REFERENCES.
*
GETIQE   BALR  FPQEBASE,0
         USING *,FPQEBASE
         STM   RIN1,RIN0,RIVSAVE
         L     FPQEBASE,FRBASE
         USING FRBRBASE,FPQEBASE
*
         L     RCVT,16(0)               GET ADDRESS OF CVT
         L     RTCB,CVTTCB(RCVT)        GET ADDRESS OF 'NEW'
         L     RTCB,4(RTCB)             GET ADDRESS OF 'OLD'
         L     RPQE,AROIRB
         L     RIN1,RBNEXAVL(RPQE)      GET NEXT AVAILABLE IQE ADDRESS
         LTR   RIN1,RIN1                IS THERE AN AVAILABLE IQE
         BC    7,DEQIQE                 DEQUEUE IQE FROM AVAILABLE Q
         LM    RIN0,RIN1,RMBRCONS       LOAD SP, SIZE AND GETM FLAG
         L     RRETURN,REGMAIN         GET STORAGE FOR AN IQE.
         BALR  RRETURN,RRETURN
         MVI   0(RIN1),X'00'           CLEAR THE IQE.
         MVC   1(23,RIN1),0(RIN1)
         MVC   IQEIRB(8,RIN1),AROIRB    INITIALIZE IRB ADDRESS IN IQE
*                                       AND TCB ADDRESS
         B     RETIQE
DEQIQE   L     RWORK1,0(RIN1)           GET NEXT IQE
         ST    RWORK1,RBNEXAVL(RPQE)    UPDATE AVAILABLE IQE POINTER
RETIQE   LM    RDQE,RLENGTH,RIVSAVE+4   RESTORE
         LM    RSPQE,RIN0,RIVSAVE+44    AND RETURN WITH IQE ADDRESS
         BR    RORIREG
RIVSAVE  DS    16F
IQESAVE  DS    3F
RMBRCONS DC    X'FF00001880000000'
REGMAIN  DC    V(RMBRANCH)
FRBASE   DC    V(FRBRBASE)
         AIF   ('&MPS' NE 'Y').MP03                                MP65
VQBASE   DC    V(IFSVRYOF)                                         MP65
VQERISAV DS    16F                                                 MP65
.MP03    ANOP                                                      MP65
*
** THE FOLLOWING PAIR OF VCONS ARE POSITIONALLY DEPENDENT FOR GETIQE **
AROIRB   DC    V(IEAROIRB)
ADROTCB  DC    V(IEAROTCB)
*
RBNEXAVL EQU   96
IQEIRB   EQU   8
         DROP  FPQEBASE
         AIF   ('&MPS' NE 'Y').MP0118                              MP2K
.GO13    ANOP
         AIF   ('&MPS' NE 'Y').GO13Z18
         EJECT
IEAMP2K  CSECT                                                     MP2K
*
* THIS CSECTS PRIMARY FUNCTION IS TO FREE ALL SPQES, DQES AND ZERO THE
* TCBMSS FIELD WHEN THE USER COMPLETION CODE X'0F4' IS FOUND IN THE
* MAIN LINE PROGRAM. THIS SPECIAL SUBROUTINE NEGATES THE FREEING OF
* SUBPOOL ZERO AS THIS IS NO LONGER POSSIBLE BECAUSE OF STORAGE
* RECONFIGURATION. ENTRY IS VIA A BRANCH AND RETURN IS TO THE CALLER
* OF FREEMAIN ACCORDING TO CONVENTION.
*
         BALR  MP65BASE,RIN0           ESTABLISH ADDRESSIBILITY    MP2K
         USING *,MP65BASE                                          MP2K
         XC    TCBCMCDE(1,RTCB),TCBCMCDE(RTCB) TURN OFF COMP CODE  MP2K
         ST    RRETURN,MP2KRTUN   SAVE MP2K EXIT ADDRESS           MP2K
         L     RWORK2,TCBMSS(RTCB) GET ADDR OF SPQE IN REG 7       MP2K
         LA    RWORK2,0(RWORK2)    ZERO HIGH ORDER BYTE            MP2K
         LTR   RWORK2,RWORK2       IS TCBMSS FIELD ZERO            MP2K
         BZ    MPEXIT  BRANCH ON NO SPQES AT ALL                   MP2K
NXTSPQE1 L     RWORK5,0(RWORK2)         GET 1ST WD OF SPQE (REG2)  MP2K
         L     RWORK3,SPQEDQE(RWORK2)   GET 2ND WD OF SPQE (REG9)  MP2K
         TM    0(RWORK2),SPQESHRD  IS THIS SPQE SHARED             MP2K
         BNZ   SHSPQE                   SPQE IS SHARED - BRANCH    MP2K
         ST    RWORK5,SPQESAVE          SAVE POINTER TO NEXT SPQE  MP2K
NXTDQE1  LA    RWORK3,0(RWORK3)  0 HIGH ORDER BYTE OF DQE POINTER  MP2K
         LTR   RWORK3,RWORK3            IS THE DQE FIELD ZERO      MP2K
         BZ    NXTSPQE                  BRANCH TO GET NEXT SPQE    MP2K
         LR    RIN1,RWORK3      PUT ADDR OF DQE IN REG1            MP2K
         L     RIN0,MP2KFDQE    PUT LENGTH, SUBPOOL IN REG0        MP2K
         MVC   DQESAVE(4),DQENXT(RWORK3)  POINTER TO THE NEXT PQE  MP2K
         BAL   RRETURN,RMBRANCH    FREE DQE CORE                   MP2K
         L     RWORK3,DQESAVE   REFRESH DQE POINTER                MP2K
         B     NXTDQE1          PROCESS DQE NEXT                   MP2K
NXTSPQE  L     RWORK5,SPQESAVE  REFRESH SPQE NEXT POINTER          MP2K
         XC    K5(LEN3,RWORK2),K5(RWORK2) MAKE DQE PTR ZERO     MP2K
         LA    RWORK2,0(RWORK5) ZERO HIGH ORDER BYTE SPQE POINTER  MP2K
         LTR   RWORK2,RWORK2  IS THE SPQE POINTER NEXT ZERO        MP2K
         BZ    FMBRSPQE  BRANCH ZERO FOR ALL DQES FREED ON CHAIN   MP2K
         B     NXTSPQE1  GET NEXT SPQE                             MP2K
SHSPQE   LR    RWORK2,RWORK3  TREAT A BORROWING SPQE AS ANY SPQE   MP2K
         ST    RWORK5,SHSPQESV  SAVE CHAIN SPQE POINTERS           MP2K
         OI    TCBCMCDE(RTCB),X'B4'   SET SWITCH FOR BORROWED SPQE MP2K
         B     NXTSPQE1   GET NEXT SPQE                            MP2K
FMBRSPQE CLI   TCBCMCDE(RTCB),X'B4'  WAS THERE A BORROWED SPQE     MP2K
         BNE   FMSPQES                                             MP2K
         L     RWORK2,SHSPQESV  REFRESH THE SPQE POINTER           MP2K
         XC    TCBCMCDE(1,RTCB),TCBCMCDE(RTCB) TURN OFF BROWED COCEMP2K
         LA    RWORK2,0(RWORK2)         CLEAR OUT HIGH ORDER BYTE  MP2K
         LTR   RWORK2,RWORK2            IS A SPQE PRESENT          MP2K
         BNZ   NXTSPQE1                 YES, GET NEXT SPQE         MP2K
FMSPQES  L     RWORK2,TCBMSS(RTCB) GET ADDR OF 1ST SPQE            MP2K
         LA    RWORK2,0(RWORK2)    ZERO HIGH ORDER BYTE            MP2K
FMNXTSPQ L     RWORK5,0(RWORK2)    GET ADDR OF NEXT SPQE           MP2K
         ST    RWORK5,SPQESAVE     SAVE ADDR OF NEXT SPQE          MP2K
FREESPQE LR    RIN1,RWORK2         PUT ADDR OF SPQE IN REG1        MP2K
         L     RIN0,MP2KFSPQ       PUT LENGTH, SUBPOOL IN REG0     MP2K
         BAL   RRETURN,RMBRANCH    FREE SPQE                       MP2K
         L     RWORK5,SPQESAVE     REFRESH SPQE NEXT POINTER       MP2K
         LA    RWORK5,0(RWORK5)  0 HIGH ORDER BYTE                 MP2K
         LTR   RWORK5,RWORK5  IS POINTER TO NEXT SPQE ZERO         MP2K
         BZ    NOSPQES        BRANCH NO MORE SPQES                 MP2K
         LR    RWORK2,RWORK5    GET NEXT SPQE POINTER              MP2K
         B     FMNXTSPQ         FREEMAIN NEXT SPQE                 MP2K
LEN3     EQU   3                                                MP2K
K5       EQU   5                                                MP2K
NOSPQES  XC    TCBMSS+1(3,RTCB),TCBMSS+1(RTCB)  ZERO TCBMSS FIELD  MP2K
         L     RRETURN,MP2KRTUN   REFRESH MP2K RETURN ADDRESS      MPIK
MPEXIT   BR    RRETURN                                             MP2K
*                                                                  MP2K
*       FREEMAIN CONSTANTS FOR 2K STORAGE RECONFIGURATION          MP2K
*                                                                  MP2K
         DS    0F                                                  MP2K
MP2KFDQE DC    X'FF000010' MASK FOR FREEING DQE                    MP2K
MP2KFSPQ DC    X'FF000008' MASK FOR FREEING SPQE                   MP2K
SPQESAVE DS    F                                                   MP2K
SHSPQESV DS    F                                                   MP2K
MP2KRTUN DS    F                                                   MP2K
TCBCMCDE EQU   19                                                  MP2K
         DROP  MP65BASE                                            MP2K
         EJECT
.MP0118  ANOP                                                      MP2K
IEAQGM00 CSECT
.GO13Z18 ANOP                                                      MO18
         EJECT
*        REGMAIN ENTRY POINT
*
         DS    0D
         DROP  FREBAS .    DROP SECOND BASE                       M0105
IGC010   BALR  RBASE,0
         USING *,RBASE
         L     RBASE,MSSADR
         USING MSSBASE,RBASE,FREBAS                               20021
         L     FREBAS,DBASADR      INITIALIZE SECOND BASE         20021
         MVC   MODEBYTE(1),33(0)   MODE INTO MODE BYTE
         AIF   ('&RORI' NE 'Y').GOB1                               LC0A
         LTR   RIN1,RIN1    IIS THIS A FREEMAIN REQUEST
         BC    10,RMBASE    YES. DO NOT SET GETMAIN NON-BRANCH SWTCH
         MVI   ENTRANT,X'FA'  SET ENTRY SWITCH
.GOB1    ANOP
RMBASE   LA    RERROR,GERRCODE     SET UP ERROR CODE REGISTER      LC0A
         MVI   SVCBYTE,10
         LR    RLENGTH,RIN0        LOAD REQUEST LENGTH
         LA    RLENGTH,0(RLENGTH)  CLEAR SPID FROM HIGH ORDER BYTE
         LR    RSPID,RIN0          LOAD INPUT SUBPOOL ID
         SRL   RSPID,24            SHIFT TO LOW ORDER BYTE
         STC   RSPID,SPIDSAV .           SAVE SPID               A32912
         STH   RSPID,@SPSAVE       SAVE SUBPOOL ID             @AS76397
         LA    RADDR,RECURSE       LOAD ADDRESS OF ACSAVE AREA TO
*                                   MAKE REQUEST LOOK LIKE S-TYPE REQ
         ST    RIN1,0(RADDR)       SAVE INPUT ADDR FOR FREEMAIN
         NI    0(RADDR),0          CLEAR HIGH ORDER BYTE
*
*
*        DETERMINE TYPE OF REQUEST
*
         LTR   RIN1,RIN1
         BZ    SPFRMAIN            SUBPOOL FREEMAIN
         BP    FELEMENT            BRANCH TO FREE MAIN
*
*        INTERFACE TO S-TYPE GETMAIN
*
         AIF   ('&LCS' NE 'Y').LC03                                LC0A
         MVI   HIBYTE,0            INITIALIZE HIERARCHY IDENT      LC0A
         CL    RIN1,HIMASK         Q. IS REQUEST FOR HIERARCHY 1   LC0A
         BNE   RMGM                NO                              LC0A
         MVI   HIBYTE,1            INSERT HIERARCHY IDENT OF 1     LC0A
.LC03    ANOP                                                      LC0A
RMGM     BAL   RGMRET,GMCOMMON                                     LC0A
         B     RMEXIT              CORE FOUND
         BAL   RRET,CDPURGE        PURGE JPA AND LPA
         B     FREEA                                           @AS76858
         B     GNOTSAT1                                        @AS76858
FREEA    STC   RSPID,SPIDSAV                                   @AS76858
         MVI   SVCBYTE,10                                      @AS76858
         B     GMREPEAT                                        @AS76858
*
RMEXIT   LR    RIN1,RFQE           LOAD ADDR OF ASSIGNED CORE
         B     GRETURN
         SPACE 2
*        BRANCH ENTRY PROCESSING
         SPACE
         DROP  FREBAS .    DROP SECOND BASE                       M0105
RMBRANCH LR    RIN15,RBASE         SAVE REGISTER 8
         BALR  RBASE,0
         USING *,RBASE
         L     RBASE,MSSADR
         USING MSSBASE,RBASE,FREBAS                               20021
         SSM   CLHIBYTE .          DISABLE                        M3872
         LTR   RIN1,RIN1           IS IT A FREEMAIN              A28819
         BC    10,FMBREN           IF POSITIVE, FREEMAIN        A28819
         ST    RIN15,BRANCHSV+24   RIN15 = ENTRY CONTENTS OF REG8
         LA    RIN15,RMBASE        SET UP BRANCH TO REGMAIN
         B     GMBRNCOM            TO BRANCH ENTRY COMMON ROUTINE
FMBREN   ST    RIN15,FMBRSAV+24                                  A28819
         LA    RIN15,RMBASE                                      A28819
         B     FMBRNCOM                                          A28819
         EJECT
*        REQUEST NOT SATISFIED - PUT TASK IN WAIT STATE
*
*
*
GNOTSAT  BAL   RRET,CDPURGE        PURGE JPA AND LPA
         AIF   ('&RORI' NE 'N').GO63A                          @SA77169
         B     XRETRY                                          @SA77169
         B     NORETRY                                         @SA77169
XRETRY   STC   RSPID,SPIDSAV                                   @SA77169
         MVI   SVCBYTE,X'04'                                   @SA77169
.GO63A   ANOP                                                  @SA77169
         AIF   ('&RORI' NE 'Y').GO63                               LC0A
         B     PURGSW             IF STORAGE FREED, SET PURGE SWITCH
         L     FPQEBASE,FRBASEAD
         L     RORIREG,ROTST5AD
         BR    RORIREG
         AGO   .GO64
.GO63    ANOP
         B     GMREPEAT            IF STORAGE FREED
NORETRY  EQU   *                                               @SA77169
         TM    8(RIN1),X'C0'       IS IT LIST REQUEST
         BM    GLIST2              YES
GNOTSAT4 TM    8(RIN1),32          IS REQUEST CONDITIONAL
         BC    14,GNOTSAT1         NO
         LA    RIN15,4    SET RETURN CODE OF 4
         AIF   ('&RORI' NE 'Y').GO92                               LC0A
.GO64    ANOP
PQESETP  ST    RGMRET,PQERET
         L     FPQEBASE,FREPQEAD
         BR    FPQEBASE            FREE UP PQE'S
         AGO   .GOPRG
.GO92    ANOP
         B     GRETURN             RETURN
.GOPRG   ANOP
         SPACE
         AIF   ('&RORI' NE 'Y').GO62                               LC0A
         SPACE
PURGSW   MVI   CDPRGSW,X'FF'      SET SWITCH TO INDICATE SUCCESSFUL
         STC   RSPID,SPIDSAV                                   @SA77169
         MVI   SVCBYTE,X'04'                                   @SA77169
*                                 PURGE
         B     GMREPEAT           REISSUE INITIAL REQUEST
.GO62    ANOP
         SPACE 2
*        ROUTINE FOR HANDLING REQUEST-NOT-SATISFIED CONDITION
*        DETERMINE WHETHER TO ABEND OR PLACE SYSTEM IN WAIT
         SPACE
GNOTSAT1 CL    RSPID,C252          IS REQUEST FOR SQ SPACE
         BH    GNOTSAT5            YES
         AIF   ('&RORI' NE 'Y').GO90                               LC0A
         L     FPQEBASE,FRBASEAD   NO - ESTABLISH ADDRESSABILITY
         L     RORIREG,TESTROAD    SET UP ENTRY
         BR    RORIREG             TEST FOR ROLLOUT
.GO90    ANOP
SETERR8  LA    RERROR,GERRCODE     SET UP ERROR CODE REGISTER      LC0A
         MVC   ABNDATA(4),ORGLRG   SAVE LARGEST SIZE              21016
         L     RADDR,ABNDATA                                      21016
         MVI   MSGLEN,X'28'        SET REASON CODE AND LENGTH     21016
         B     GERROR8
*THIS ROUTINE IS ENTERED WHEN A REQUEST FOR SUPERVISOR QUEUE SPACE SWS
*CANNOT BE SATISFIED.                                              SWS
*IN AN ATTEMPT TO AVOUD A WAIT STATE, THIS ROUTINE WILL EXAMINE THESWS
*SIZE OF THE REQUEST.  IF THE SIZE OF THE REQUEST IS LARGER THAN   SWS
*144 BYTES,THE REQUESTOR WILL BE ABTERMED WITH A E04 COMPLETION    SWS
*CODE                                                              SWS
*IF THE SIZE OF THE REQUEST IS EQUAL TO OR LESS THAN 144 BYTES, A  SWS
*DISABLED WAIT STATE PSW WILL BE LOADED.                           SWS
*                                                                  SWS
GNOTSAT2 DS    0H                                                  SWS
         LA    RWORK1,144         SET UP XR FOR COMPARE            SWS
         C     RWORK1,REQSIZE     ABTERM REQUESTOR IF SIZE         SWS
         BL    TERM               IS LARGER THAN 144               SWS
         L     RIN1,WAIT+4        PICK UP ABEND CODE               SWS
         SLL   RIN1,12       SET UP COMPLETION CODE                SWS
         ST    RIN1,16(RTCB)     STORE CODE IN TCB                 SWS
         L     RIN15,CVTPTR        LOCATE CVT                     21014
         L     RIN15,CVTPURG(RIN15)   LOCATE SUBSYSTEM PURGE ROUT 21014
         LR    RIN1,RTCB           MOVE TCB ADDR TO REG 1         21014
         BALR  RRETURN,RIN15       GO TO SUBSYSTEM PURGE          21014
         OI    16(RTCB),X'80'    SET FLAG BIT                      SWS
         OI    33(RTCB),X'01'     SET NON-DISPATCHABILITY BIT      SWS
         OI    173(RTCB),X'40'     INDICATE OUT OF STORAGE         SWS
         LPSW  WAIT               PLACE MACHINE IN WAIT STATE      SWS
TERM     L     RIN1,WAIT+4        PICK UP ABEND CODE               SWS
         B     ERRF11                                              SWS
*
GNOTSAT5 EQU   *                                                  20021
         AIF   (&TSO NE 1).TSO1000                                20021
         TM    LSQSSW,LSQSMSK      IS REQUEST FOR LSQS?           20021
         BNZ   GNOLSQS            YES-BRANCH TO LSQS PROCSSNG     20021
.TSO1000 ANOP                                                     20021
         BAL   RCOMRET1,GNOTSAT3   ATTEMPT TO GET MORE SQS SPACE  20021
GMREPEAT LM    RADDR,FREBAS,SAVEREGS  RESTORE REGS (11-3) RETRY   20021
         B     GCOMMON2            TO REPEAT REQUEST
         EJECT
         AIF   (&TSO NE 1).TSO1100                                20021
*                                                                 20021
*        THIS ROUTINE HANDLES AN OUT OF LSQS CONDITION.  IF THE   20021
*        CALLING TASK IS NOT ABENDING, IT IS ABENDED. IF THE      20021
*        TASK IS ABENDING, THE REQUEST IS RETRIED FROM SQS.       20021
*        SUBPOOL 254, RTCB=JOBSTEP TCB AND A DAUGHTER MAY BE      20021
*        ABENDING.  ALSO, CHECK CURRENT TCB                       20021
GNOLSQS  SR    RERROR,RERROR -     SET FIRST TCB                  20021
GNOLSQS1 TM    TCBFLG1(RTCB),TCBFA IS CALLING TASK ABENDING       20021
         BNZ   GETSQS -            YES-ALLOCATE FROM SQS          20021
         TM    TCBFLG3(RTCB),TCBABTRM IS CALLING TASK ABTERMING   20021
         BNZ   GETSQS -             YES-ALLOCATE FROM SQS         20021
         TM    TCBFLG2(RTCB),TCBMC -TASK MUST COMPLETE            20021
         BNZ   GETSQS -             YES-ALLOCATE FROM SQS         20021
         TM    TCBSTAE(RTCB),TCBSTABE IS CALLING TASK STAE EXIT   20021
         BNZ   GETSQS -             YES-ALLOCATE FROM SQS         20021
         L     RIN1,TCBRBP(RTCB) -  GET CURR RB ADDRSS            20021
         TM    RBSTAB(RIN1),X'C0' - IS IT AN SVRB?                20021
         BNO   GNOLSQS2 -          NO, CHECK FOR 254              M3872
         CLC   RBEXSAVE+DISP(L5,RIN1),ABENDMSK .  ABEND SVRB ?   M3872
         BE    GETSQS -            YES-USE SQS                    20021
GNOLSQS2 LTR   RERROR,RERROR -     CHECKING SECOND TCB            20021
         BNZ   OUTLSQS -           TWO TCBS AND YOUR OUT          20021
         LCR   RWORK2,RSPID -      COMPLEMENT SUBPOOL NUMBER      20021
         CL    RWORK2,C254 -       SUBPOOL 254                    20021
         BNE   OUTLSQS -           NO, TERMINATE TASK             20021
         LR    RERROR,RTCB -       SAVE THE JOBSTEP TCB           20021
         L     RTCB,16(0) -        GET CURRENT TCB ADDR.          20021
         L     RTCB,0(RTCB) -      *                              20021
         L     RTCB,4(RTCB) -      *                              20021
         B     GNOLSQS1 -          CHECK CURRENT TCB              20021
OUTLSQS  LA    RERROR,GERRCODE -   TASK OUT OF LSQS-TERMINATE     20021
         B     GERROR1 -           CALLING TASK (LOADS RTCB)      20021
GETSQS   MVI   LSQSSW,LSQSOFF -    CLEAR LSQS SWITCH              20021
         LTR   RERROR,RERROR -     SECOND TCB                     20021
         BZ    GETSQS1 -           NO                             20021
         LR    RTCB,RERROR -       YES, RE LOAD TCB ADDR.         20021
GETSQS1  LA    RSPQE,SQESPQE -     ADDR. OF SQS SPQE              20021
         ST    RSPQE,SAVEREGS+4 -  STORE IN RETRY REGS(REG 12)    20021
         LM    RADDR,FREBAS,SAVEREGS RESTORE REGS(11-3) RETRY     20021
         B     GCOMMON2 -          RETRY REQUEST                  20021
         EJECT                                                    20021
.TSO1100 ANOP                                                     20021
*        THIS ROUTINE ATTEMPTS TO MAKE STORAGE AVAILABLE FOR SUPERVISOR
*        QUEUE SPACE BY PURGING THE JPA AND THE LPA.  IF THIS IS NOT
*        SUCCESSFUL IN MAKING ENOUGH STORAGE AVAILABLE, THIS ROUTINE
*        WILL EXTEND THE SUPERVISOR QUEUE SPACE BY ONE 2K BLOCK AT A
*        TIME IF THE NEXT ADJACENT 2K BLOCK IS AVAILABLE.  IF THIS
*        ROUTINE IS UNSUCCESSFUL IN MAKING SUFFICIENT SUPERVISOR
*        STORAGE AVAILABLE TO SATISFY THE REQUEST, IT WILL ENTER A
*        MACHINE WAIT STATE.
*           INPUT - RCOMRET1 - RETURN ADDRESS
*           OUTPUT - NONE
*           REGISTERS USED - RCOMRET1,RRET,RWORK1,RDISP,RCOMRET3,
*                           RBLOCK,RDQE,RFQE,RQESIZ,RSIZE,RWORK4,
*                           RWORK5
         SPACE
GNOTSAT3 LR    RWORK1,RTCB         SAVE TCB ADDRESS
         LA    RWORK4,2            INITIALIZE CORE FREED INDICATOR
         LA    RRET,NEXTTCB        SET UP RETURN FROM CDPURGE
         L     RTCB,MSCEDADD       PICK UP MASTER SCHEDULER TCB ADDRESS
         B     TSTPRG              TO CHECK FOR PURGE OF M.S. JPQ
NEXTTCB  L     RTCB,TCBTCB(RTCB)   PICK UP NEXT TCB ON TCB QUEUE
         LTR   RTCB,RTCB           IS THIS END OF QUEUE
         BZ    RSTRTCB             YES
TSTPRG   TM    TCBJPQ(RTCB),X'80'  IS PURGE FLAG IN TCB SET
         BZ    NEXTTCB             NO - GET NEXT TCB
         AIF   (&TSO NE 1).TSO1200                                20021
*                                                                 20021
* DON'T PURGE JPAQ FOR A TIME-SHARING TASK. PURGE WOULD ONLY      20021
* MAKE LSQS AVAILABLE NOT SQS. PURGE COULD RESULT IN AN ABEND     20021
* BECAUSE FREEMAIN FOR A TIME-SHARING TASK WILL GET THE TCB       20021
* ADDRESS FROM 'OLD' WHICH IS NOT THE TCB BEING PURGED.           20021
         SPACE 1                                                  20021
         TM    TCBTSFLG(RTCB),TCBTSTSK  IS THIS A TIME-SHARING    20021
*                                       TASK?                     20021
         BO    NEXTTCB             YES. GET NEXT TCB.             20021
.TSO1200 ANOP                                                     20021
         AIF   ('&RORI' NE 'Y').GOJB1                              LC0A
         TM    TCBFCD1(RTCB),X'10'  HAS TASK BEEN ROLLED OUT
         BO    NEXTTCB  YES.  GET NEXT TCB.
.GOJB1   ANOP
         LA    RWORK4,0            SET INDICATOR FOR STORAGE FREED
         B     CDPURGE             PURGE JOB PACK QUEUE
RSTRTCB  LR    RTCB,RWORK1         RESTORE TCB ADDRESS
         B     RETN(RWORK4)
RETN     BR    RCOMRET1            IF CORE FREED AS RESULT OF PURGES
         L     RBLOCK,GOVRFLB+8    GET PTR TO FREE AREA PQE    @SA70721
         L     RBLOCK,PQENXT(RBLOCK)    GET ONLY OR H0 PQE     @SA70721
         L     RWORK1,GOVRFLB      FIRST BYTE BEYOND SQA       @SA70721
         LA    RWORK1,0(RWORK1)    CLEAR POSSIBLE FLAG         @SA70721
         C     RWORK1,0(RBLOCK)    CONTIGUOUS EXPNSN POSBLE?   @SA70721
         BNE   GNOTSAT2            NO                          @SA70721
         LA    RWORK1,2048         SIZE OF A 2K BLOCK
         SR    RDISP,RDISP         SET DISPLACEMENT FOR FBQE POINTER
         LR    RSIZE,RDISP         INITIALIZE REGISTER
         BAL   RCOMRET3,FREEPTR    GET A 2K BLOCK
         B     CONTIGCH            2K BLOCK FOUND
         B     GNOTSAT2            NO UNASSIGNED STORAGE
CONTIGCH EQU   *                                                 A29420
         TM    GOVRFLB,X'80' .           IS SQS TRIGGER SET      A29420
         BC    14,CONTIGCK .             NO, BRANCHTO EXPND SQS  A29420
         LR    RDQE,RCOMRET1 .           SAVE REGISTER           A29420
         LR    RFQE,RADDR .              SAVE REGISTER           A29420
         L     RADDR,ADPART .            LOAD BASE FOR GET/FRE - A29420
*                                            PART                A29420
         L     RCOMRET1,ADDISP .         LOAD ADDRESS FOR BALR   A29420
         BALR  RCOMRET1,RCOMRET1 .       GO TO GET/FREEPART IN   A29420
*                                            IEAQPR              A29420
         LR    RCOMRET1,RDQE .           RESTORE REG             A29420
         LR    RADDR,RFQE .              RESTORE REG             A29420
CONTIGCK EQU   *
         NI    GOVRFLB,X'00' .           CLEAR HIGH ORDER BYTE   A29420
*                                         FOR COMPARE            A29420
         L     RDQE,GOVRFLB+4      PICK UP PTR TO SUPERVISOR DQE
         L     RFQE,DQEFQE(RDQE)   PICK UP FIRST FQE
         LA    RFQE,0(RFQE)
         L     RQESIZ,DQELNTH(RDQE) PICK UP SIZE FROM DQE
         LTR   RFQE,RFQE               IS THERE AN FQE FOR SQS @JK70115
         BZ    NEWSQFQE                NO CREATE NEW FQE       @JK70115
         L     RFQEUB,FQELNTH(RFQE) PICK UP SIZE OF FREE AREA
         AR    RFQEUB,RFQE         COMPUTE UPPER BOUND OF FREE AREA
         CR    RFQEUB,RBLOCK       IS IT CONTIGUOUS TO NEW BLOCK
         BNE   NEWSQFQE            NO - CREATE NEW FQE
         A     RSIZE,FQELNTH(RFQE) COMBINE SIZES
         ST    RSIZE,FQELNTH(RFQE) PUT NEW SIZE IN FQE
NEWSQSIZ LA    RQESIZ,2048(RQESIZ) INCREMENT DQE SIZE
         ST    RQESIZ,DQELNTH(RDQE) PUT NEW SIZE IN DQE
         L     RBLOCK,GOVRFLB+8        PICK UP PTR TO PQE
         L     RBLOCK,DUMFWD(RBLOCK)   PICK UP ADDRS OF REAL PQE
         L     RWORK5,PQERGSZ(RBLOCK)  PICK UP REGION SIZE
         SH    RWORK5,KTWO             DECREMENT SIZE BY ONE BLOCK
         ST    RWORK5,PQERGSZ(RBLOCK)  UPDATE RGN SIZE IN PQE
         L     RWORK5,GOVRFLB      PICK UP SQ SPACE UPPER BOUND
         LA    RWORK5,2048(RWORK5) UPDATE SQ SPACE UPPER BOUND
         ST    RWORK5,GOVRFLB
         ST    RWORK5,PQESTADD(RBLOCK) UPDATE START ADD IN PQE
         L     RWORK5,16               LOAD ADDR OF CVT            0697
         MVC   CVTNUCB(4,RWORK5),GOVRFLB    UPDATE CVT             0697
         BR    RCOMRET1            RETURN
NEWSQFQE ST    RSIZE,FQELNTH(RBLOCK) STORE SIZE IN NEW FQE
         ST    RFQE,FQENXT(RBLOCK) PUT POINTER TO NEXT FQE IN NEW FQE
         ST    RBLOCK,DQEFQE(RDQE) PUT ADDRESS OF NEW FQE IN DQE
         B     NEWSQSIZ            ADJUST DQE
         EJECT
*        TERMINATION PROCEDURES - CORE ALLOCATED
         SPACE
GMSEXIT  TM    8(RIN1),32          WAS REQUEST CONDITIONAL
         BC    14,GRETURN
GRETURN1 SR    RIN15,RIN15         YES-SET ERROR CODE TO ZERO.
*
         AIF   ('&RORI' NE 'Y').GOG2                               LC0A
GRETURN  XC    PQESTAT(3),PQESTAT . TURN OFF SW FOR EXIT          M3872
         BR    RRETURN             RETURN TO CALLER
         AGO   .GOG3
.GOG2    ANOP
GRETURN  BR    RRETURN             RETURN TO CALLER
.GOG3    ANOP
         EJECT
*        MAINLINE CONTROL ROUTINE FOR GETMAIN
*           INPUT - RLENGTH - REQUESTED LENGTH
*                   RSPID   - REQUESTED SUBPOOL ID
*                   RADDR   - ADDR OF LIST ENTRY TO STORE AREA ADDR
*                   RTCB    * ADDR OF TCB FOR REQUESTING TASK
*                   RGMRET  * RETURN REG
*           OUTPUT -
*              IF REQUEST IS SATISFIED (RETURN TO  RGMRET')
*                   ADDRESS OF ALLOCATED AREA IS IN LIST ENTRY
*              IF REQUEST IS NOT SATISFIED (RETURN TO 'RGMRET + 4')
*                   RLRGSIZ - SIZE OF LARGEST AVAILABLE FREE AREA
*           REGISTERS USED - EXCLUDING THOSE USED BY SUBROUTINES
*                   RCOMRET1,RMASK,RWORK1,RLENGTH,RSPID,RFQE,RADDR,
*                   RGMRET
*
GMCOMMON ST    RLENGTH,REQSIZE  SAVE SIZE OF REQUEST FOR LATER USE SWS
         BAL   RCOMRET1,CSPCHK    GET SPQE FOR REQUESTED SUBPOOL   SWS
         B     GSPQESPC            NOT FOUND-CREATE SPQE
         SPACE 2
*        ALTERNATE ENTRY POINT USED FOR LIST AND VARIABLE REQUESTS-
*          AFTER THE FIRST ENTRY IN THE LIST WAS SATISFIED FOR LIST
*          REQUESTS OR TO GET THE MAXIMUM AVAILABLE CORE FOR VARIABLE
*          REQUESTS.     (RSPQE MUST POINT TO THE SPQE FOR THE REQ SP)
         SPACE
GCOMMON1 LTR   RLENGTH,RLENGTH     Q. IS NEGATIVE LENGTH SPECIFIED 5020
         BC    10,RNDLNGTH            NO - PROCESS NORMALLY        5020
         TM    8(RIN1),32          Q. IS REQUEST CONDITIONAL       5020
         BC    1,SETRET4              YES - SET RETURN CODE 4      5020
         LA    RERROR,GERRCODE     SET UP ERROR CODE REGISTER      5020
         MVI   MSGLEN,X'44'        LENGTH AND REASON CODE         21016
         B     GERROR8                                             5020
SETRET4  LA    RIN15,4             SET RETURN CODE TO 4            5020
         B     GRETURN                                             5020
RNDLNGTH BAL   RCOMRET1,CRNDLNTH   ROUND UP LENGTH TO DOUBLE WORD  5020
         STM   RADDR,FREBAS,SAVEREGS  SAVE REGSTRS (11-3)         20021
GCOMMON2 L     RMASK,CLHIBYTE      LOAD MASK TO CLEAR HIGH ORDER BYTE
         CL    RSPID,C252          IS REQUEST FOR SQ SPACE
         BNH   GCOMPSP             NO
         BAL   RCOMRET1,GFRECORE   SEARCH SQ AREA FOR FREE AREA
         B     GNOTFND             SQ SPACE NOT FOUND
         LTR   RSPID,RSPID         IF REQUEST IS FOR SUBPOOL 253-254
         BM    GAQE                 BUILD AN AQE FOR ASSIGNED AREA
         B     GFQEADJ
GCOMPSP  DS    0H                                                  I283
        AIF ('&LCS' EQ 'N').LCS01                                  I283
         SPACE
* IF REGION CONSISTS ONLY OF ONE SEGMENT, THIS SECTION OF CODE     I283
*   FUNNELS ALL REQUESTS TO THAT SEGMENT; OTHERWISE THE            I283
*   SPECIFIED HIERARCH IS USED.                                    I283
         SPACE
         LA    WORK15,2            SET UP TO TEST FOR 2 SEGMENTS   I283
         L     PQE6,TCBPQE(RTCB)   @ DUMMY                         I283
OWNPQE   LR    PQE9,PQE6           SAVE @ LAST PQE IF NECESSARY    I283
GETPQE   L     PQE6,PQENXT(PQE6)   @ NEXT PQE ON CHAIN             I283
         LTR   PQE6,PQE6           IS THERE ANOTHER PQE ?          I283
         BE    ONESEG              NO - MUST ONLY BE ONE SEGMENT   I283
         TM    RORIFLG(PQE6),RGNSHRD  PQE OWNED BY THIS TCB ?      I283
         BO    GETPQE              NO - TEST NEXT PQE              I283
         BCT   WORK15,OWNPQE       DECREMENT SEGMENT CTR,CK NXT    I283
         B     FINHIER             IF 0, REGION HAS 2 SEGMENTS     I283
ONESEG   MVI   HIBYTE,1            SET UP TO ISOLATE HIER          I283
         NC    HIBYTE(1),PQEHIID(PQE9) ISOLATE SEGMENT HIER ID     I283
FINHIER  DS    0H                                                  I283
.LCS01   ANOP                                                      I283
         LA    RWORK1,4080         IS REQ. LENGTH GREATER THAN     I283
         CR    RWORK1,RLENGTH       MAXIMUM AVAILABLE IN AN FQE
         BL    GM2KPREF           YES - GET FREE 2K BLOCKS
*
         BAL   RCOMRET1,GFRECORE  SEARCH SUBPOOL FOR FREE AREA
         B     GM2KT               AREA NOT FOUND-GET FREE 2K BLOCKS
*
GFQEADJ  BAL   RCOMRET1,GFQEUPDT   REMOVE ASSIGNED AREA FROM FQE
         SPACE
*        RETURN - REQUEST SATISFIED
*             (RFQE = ADDR OF ASSIGNED AREA)
GFNDRET  LM    RADDR,FREBAS,SAVEREGS  RESTORE REGS (11-3)         20021
         ST    RFQE,0(RADDR)       STORE AREA'S ADDR IN CALLER'S LIST
         AIF   ('&RORI' NE 'Y').GO94                               LC0A
         ST    RGMRET,PQERET
         L     FPQEBASE,FREPQEAD
         BR    FPQEBASE
         AGO   .GO95
.GO94    ANOP
         BR    RGMRET              RETURN
.GO95    ANOP
         SPACE 2
*
GAQE     BAL   RCOMRET1,GBLDAQE    BUILD AQE FOR ASSIGNED 253/254 CORE
         B     GFNDRET             RETURN - STORAGE IS ALLOCATED
         EJECT
*        GET STORAGE FROM UNASSIGNED 2K BLOCKS
*
GM2KPREF SR    RLRGBLK,RLRGBLK     INITIALIZE ADDR OF LARGEST BLOCK
GM2KPRF1 L     RDQE,DQENXT(RSPQE)  GET ADDRESS OF DQE              LC0A
         NR    RDQE,RMASK               FOR SUBPOOL REQUESTED
         BZ    GM2K
         LR    RPREDQE,RDQE
         B     GM2KPRF1
*
GM2KT    LTR   RLENGTH,RLENGTH     IS REQUEST FOR ZERO BYTES
         BZ    GFNDRET             YES - RETURN
GM2K     LA    RWORK1,2047         DETERMINE NUMBER OF 2K BLOCKS NEEDED
         LR    RWORK4,RWORK1
         AR    RWORK1,RLENGTH        TO SATISFY REQUEST
         OR    RWORK1,RWORK4
         XR    RWORK1,RWORK4
*
         BAL   RCOMRET2,G2KSRCH    SEARCH FOR FREE 2K BLOCKS
         B     GFNDRET             CORE FOUND-RETURN
GSIZCK   LR    RLRGSIZ,RSIZE       SAVE SIZE OF LARGEST SET OF FREE BLK
GNOTFND  LM    RADDR,FREBAS,SAVEREGS  RESTORE REGS (11-3)         20021
         B     4(RGMRET)           RETURN - CORE NOT FOUND
         EJECT
*        SEARCH FREE AREAS OF SUBPOOL FOR AN AREA LARGE ENOUGH TO
*           SATISFY THE REQUEST
*           INPUT - RLENGTH - REQUESTED LENGTH
*                   RSPQE - ADDRESS OF SUBPOOL QUEUE ELEMENT
*           OUTPUT -
*              IF RETURN IS TO  RCOMRET1' (NOT FOUND)
*                RPREDQE = ADDRESS OF LAST DQE FOR SUBPOOL(OR OF SPQE)
*                RLRGSIZ = SIZE OF LARGEST FREE AREA - REQUESTED LENGTH
*                RLRGBLK = ADDR OF FQE FOR LARGEST FREE AREA
*              IF RETURN IS TO 'RCOMRET1 + 4' (FOUND)
*                RFRELNTH- SIZE REMAINING IN FQE
*                RFQE    = ADDR OF FQE SATISFYING REQUEST
*                RPREFQE = ADDR OF PREVIOUS FQE (OR OF DQE)
*           REGISTERS USED - RMASK,RDQE,RPREDQE(=RSPQE),RFQE,RPREFQE,
*                      RLRGBLK,RFRELNTH,RLENGTH,RCOMRET1,RLRGSIZ
*
*
GFRECORE SR    RLRGSIZ,RLRGSIZ     LOAD REGISTERS TO SAVE LENGTH AND
         LR    RLRGBLK,RLRGSIZ     ADDR OF LARGEST AVAILABLE FREE AREA
GDQESRCH L     RDQE,DQENXT(RPREDQE)  LOAD ADDRESS OF NEXT DQE
         NR    RDQE,RMASK            IS THERE A DQE
         ST    RLRGSIZ,FQESIZ .     STORE SIZE OF LARGEST FQE    A31213
         BCR   8,RCOMRET1             NO-RETURN-FREE AREA NOT FOUND
         AIF   ('&RORI' NE 'Y').GO204                              LC0A
         CL    RSPID,C252          IF REQUEST IS FOR SQS BYPASS CHECK
         BH    FQESRCH             FOR OWNED AND BORROWED CORE
         L     RIN1,TCBPQE(RTCB)                 GET PQE AND TEST
PQE1     L     RIN1,DUMBWD(RIN1)                 DQE STARTING ADDR TO
         CLC   DQEADDR+1(3,RDQE),PQESTADD+1(RIN1) REGION IN PQE
         BL    PQE1
         CLI   PQESTAT,X'FF'                     IF SEARCH IS FOR
         BE    PQE2                              BORROWED CORE BRANCH
         TM    RORIFLG(RIN1),RGNSHRD             IF PQE OWNED CONTINUE
         BC    1,GDQEADV                         OTHERWISE BRANCH
         B     FQESRCH                           IF PQE OWNED BRANCH
PQE2     TM    RORIFLG(RIN1),RGNSHRD             OTHERWISE CONTINUE TO
         BC    8,GDQEADV                         FQESRCH
.GO204   ANOP
*
*        SEARCH FQE CHAIN OF DQE FOR FREE AREA
*
FQESRCH  LR    RPREFQE,RDQE
         AIF   ('&LCS' NE 'Y').LC05                                LC0A
         CLC   DQEHIID(1,RPREFQE),HIBYTE  Q. IS THIS DQE FOR THE   LC0A
*                                         REQUESTED HIERARCHY      LC0A
         BNE   GDQEADV                                             LC0A
.LC05    ANOP                                                      LC0A
         L     RFQE,FQENXT(RPREFQE) LOAD ADDRESS OF FIRST FQE
         NR    RFQE,RMASK            IS THERE AN FQE
         BZ    GDQEADV                NO - CHECK NEXT DQE
GFQESRCH TM    FQENXT+3(RPREFQE),7 .    CHK FQE ADD FOR VALIDITY A39433
         BC    7,BADFQE                                           21016
         TM    FQENXT(RPREFQE),X'FF'   CHK FOR NON-ZERO HIBYTE @SA68309
         BC    7,BADFQE                NOT ZERO BRANCH         @SA68309
         L     RFRELNTH,FQELNTH(RFQE) .  IS FREE AREA SUFFICIENT A39433
         SR    RFRELNTH,RLENGTH           FILL REQUEST
         BC    11,4(RCOMRET1)        YES -RETURN-FREE AREA FOUND
*
         AR    RFRELNTH,RLENGTH
         CR    RFRELNTH,RLRGSIZ         IS FREE AREA LARGEST SO FAR
         BNH   GFQEADV               NO-CHECK NEXT FQE
         LR    RLRGSIZ,RFRELNTH    SAVE SIZE OF FREE AREA
         ST    RLRGSIZ,ORGLRG .    LRGEST BLK OF CORE AVAIL       21016
         LR    RLRGBLK,RFQE        SAVE ADDR OF FQE (FOR VARIABLE)
*
GFQEADV  LR    RPREFQE,RFQE        CHECK NEXT FQE
         TM    FQENXT+3(RPREFQE),7 DOES NEXT FQE SPECIFY DOUBLE WORD
         BC    7,BADFQE                NO BRANCH OUT           @SA68309
         TM    FQENXT(RPREFQE),X'FF'   CHK FOR NON-ZERO HIBYTE @SA68309
         BC    7,BADFQE                NOT ZERO BRANCH OUT     @SA68309
FQEOK    L     RFQE,FQENXT(RPREFQE) LOAD ADDRESS OF NEXT FQE      21016
         NR    RFQE,RMASK          IS THERE AN FQE
         BZ    GDQEADV             NO - CHECK NEXT DQE
         CR    RFQE,RPREFQE        IS FQE LESS THAN PREVIOUS FQE
         BL    GFQESRCH            YES
SPECERR  LA    RERROR,GERRCODE     NO - ERROR - FQE QUEUE DESTROYEDLC0A
         B     GERROR6
*
GDQEADV  LR    RPREDQE,RDQE        CHECK NEXT DQE
         B     GDQESRCH
         EJECT
*        SEARCH FOR FREE 2K BLOCKS
*           INPUT - RWORK1 = NUMBER OF 2K BLOCKS NEEDED
*                   RPREDQE= ADDRESS OF LAST DQE FOR SPQE
*
*           OUTPUT -
*              IF CORE IS FOUND (RETURN TO 'RCOMRET2')
*                RFQE - ADDRESS OF ALLOCATED STORAGE
*              IF CORE IS NOT FOUND (RETURN TO 'RCOMRET2 + 4')
*                RSIZE  = NUMBER OF BLOCKS IN SET OF FREE BLOCKS
*
*        REGISTERS USED - RCDPRGIN,RCOMRET1,RCOMRET2,RCOMRET3,RBLOCK
*
G2KSRCH  BAL   RCOMRET3,FBQSRCH    SEARCH FOR FREE BLOCKS
         B     GDQEBLD             BLOCKS FOUND - CREATE DQE
         B     4(RCOMRET2)         RETURN - BLOCKS NOT AVAILABLE
         SPACE
*        CREATE DQE
         SPACE
GDQEBLD  LR    RBLOCK1,RBLOCK      SAVE BLOCK NUMBER AND SIZE
         LR    RSIZE1,RSIZE
         SRL   RSIZE1,DIV2048      GET NUMBER OF BLOCKS
         LA    RIN1,16             LOAD DQE SIZE
*
         BAL   RCOMRET1,GETMAINB   GET 16 BYTES FOR DQE
         ST    RBLOCK1,DQEADDR(RIN1) STORE BLOCK ADDRESS IN DQE
         ST    RSIZE,DQELNTH(RIN1) STORE SIZE IN DQE
         AIF   ('&LCS' NE 'Y').LC06                                LC0A
         MVC   DQEHIID(1,RIN1),HIBYTE   INSERT HIERARCHY IDENT     LC0A
.LC06    ANOP                                                      LC0A
*
*        SET STORAGE KEYS IN 2K BLOCKS ASSIGNED
         LR    RBLOCK1,RBLOCK
         LA    RBLOCK1,0(RBLOCK1)  CLEAR HI BYTE                SA66792
         SR    RWORK2,RWORK2
         CL    RSPID,C252          IF REQUEST IS FOR SP 252-255
         AIF   (&SMF EQ 0).GMCOMM                                   SMF
         BE    GOCORE                  BRANCH IF 252-NOT SET KEY    SMF
         BH    GFQEBLD                 DO NOT SET STORAGE KEY       SMF
         AGO   .GMCOMN                                              SMF
.GMCOMM  ANOP                                                       SMF
         BNL   GFQEBLD              DO NOT SET STORAGE KEY
.GMCOMN  ANOP                                                       SMF
         IC    RWORK2,TCBPKF(RTCB) LOAD TASKS PROTECT KEY
*
GSBSK    SSK   RWORK2,RBLOCK1      SET STORAGE KEY TO TASK'S PROTECT
         LA    RBLOCK1,2048(RBLOCK1)  KEY IN ALL ALLOCATED 2K BLOCKS
         BCT   RSIZE1,GSBSK
*
         AIF   (&SMF EQ 0).GMCOMA                                   SMF
         SPACE 2                                                    SMF
*                                                                   SMF
*        GO TO SMF CORE ROUTINE FOR GETMAIN                         SMF
*                                                                   SMF
GOCORE   L     GMSMFB,GMSMFAD          LOAD GETMAIN SMF CORE BASE   SMF
         L     RWORK1,SMFPQESV         LOAD ALLOCATION PQE POINTER  SMF
         BALR  GMSMFRT,GMSMFB          GO TO PROCESS CORE           SMF
         SPACE 2                                                    SMF
.GMCOMA  ANOP                                                       SMF
*        BUILD FQE FOR ANY REMAINING CORE
*
GFQEBLD  O     RIN1,DQENXT(RPREDQE)     STORE DQE ADDRESS IN PREV DQE
         ST    RIN1,DQENXT(RPREDQE)
         SR    RSIZE,RLENGTH            GET EXCESS LENGTH IN 2K BLOCKS
         LA    RFQE,0(RSIZE,RBLOCK)  LOAD ADDR OF ASSIGNED CORE
         BZ    GAQETST             IF LENGTH IS ZERO-CHECK AQE NEEDED
*
         ST    RBLOCK,DQEFQE(RIN1) STORE FQE ADDRESS IN DQE
         ST    RSIZE,FQELNTH(RBLOCK)    STORE REMAINING LENGTH IN FQE
GAQETST  SR    RWORK3,RWORK3       CLEAR POINTER
         ST    RWORK3,FQENXT(RBLOCK)       TO NEXT FQE
*
         LA    RIN1,0(RIN1)        CLEAR HIGH ORDER BYTE
         BR    RCOMRET2            RETURN-CORE ALLOCATED
         EJECT
*        SEARCH FREE BLOCK QUEUE FOR AVAILABLE BLOCKS
*           INPUT - RWORK1 - NUMBER OF BYTES NEEDED
*           OUTPUT - RBLOCK - ADDRESS OF FIRST AVAILABLE BLOCK
*                    RSIZE  - NUMBER OF BYTES AVAILABLE
*           REGISTERS USED - RWORK1,RBLOCK,RSIZE,RDISP,RSPID,RTCB,
*                            RCOMRET3,RWORK4,RWORK5
         SPACE
FBQSRCH  ST    RCOMRET3,RREGSAVE      SAVE BAL LINK REG FOR EXIT  20021
         SR    RSIZE,RSIZE            INITIALIZE SIZE REGISTER    20021
         ST    RSIZE,FBQESIZ .      STORE SIZE OF LARGEST FBQE   A31213
         LA    RDISP,BCKPTR        INITIALIZE FBQE PTR DISPLACEMENT
         CH    RSPID,C246          IS IT PP SUBPOOL
         BL    TCBPART             YES - PICK UP TCBPQE
         C     RSPID,C252          IS IT REQUEST FOR SP 252
         BE    TCBPART             YES - PICK UP TCBPQE
         CH    RSPID,C248          IS IT REQUEST FOR PARTITION
         BNH   FREEPTR             YES - PICK UP PTR FROM GOVRFLB+8
         SR    RDISP,RDISP         NO - SET DISPLACEMENT FOR FWD PTR
TCBPART  L     RBLOCK,TCBPQE(RTCB) PICK UP TCBPQE
         LTR   RBLOCK,RBLOCK     IS THERE A REGION              SA64994
         L     RCOMRET3,RREGSAVE LOAD UP RETURN REG             SA64994
         BZ    4(RCOMRET3)       NO, DON'T GO ANY FURTHER       SA64994
NEXTPQE  L     RBLOCK,PQEPREV(RBLOCK)   PICK UP NEXT PQE.
         LTR   RBLOCK,RBLOCK       IS THIS THE END OF PQE CHAIN    LC0A
         L     RCOMRET3,RREGSAVE      RESTORE RETURN REGISTER     20021
         BZ    4(RCOMRET3)         EXIT - CORE NOT IN OWNED PQE    LC0A
         AIF   ('&LCS' NE 'Y').LC07                                LC0A
         CLC   PQEHIID(1,RBLOCK),HIBYTE Q. IS THIS PQE FOR THE     LC0A
*                                       REQUESTED HIERARCHY        LC0A
         BNE   NEXTPQE                  NO - GET NEXT PQE          LC0A
.LC07    ANOP                                                      LC0A
         AIF   ('&RORI' NE 'Y').GO30                               LC0A
TESTPQE  CLI   PQESTAT,X'FF'       SEARCH BORROWED.
         BE    TCBPART1            YES. SEARCH BORROWED CORE.
         TM    RORIFLG(RBLOCK),RGNSHRD  IS THE REGION OWNED
         BO    NEXTPQE            NO - PICK UP NEXT PQE
.GO30    ANOP
TCBPART1 LR    RWORK2,RBLOCK          SAVE PQE ADDRESS            20021
FBQLOOP  L     RBLOCK,0(RBLOCK,RDISP) PICK UP ADDRESS OF FBQE
         CR    RBLOCK,RWORK2          IS THIS THE OWNING PQE      20021
         BE    NEXTPQE            SEARCH FOR OWNED PQE
         C     RSIZE,FBQESIZE(RBLOCK) IS BLOCK LARGEST THUS FAR
         BNL   CKLSTBLK            NO - CHECK IF LAST FBQE         LC0A
         L     RSIZE,FBQESIZE(RBLOCK) PICK UP SIZE OF BLOCK
         ST    RSIZE,FBQESIZ .      STORE SIZE OF LARGEST FBQE   A31213
         ST    RSIZE,ORGLRG .      LARGEST BLOCK AVAILABLE        21016
         CR    RSIZE,RWORK1        IS BLOCK LARGE ENOUGH
         BL    CKLSTBLK            NO - CHECK IF LAST FBQE         LC0A
         AIF   (&SMF EQ 0).GMCOMZ                                   SMF
         ST    RWORK2,SMFPQESV  SAVE ALLOCATION PQE FOR SMF       20021
.GMCOMZ  ANOP                                                       SMF
         BH    FBQREPR(RDISP)      TOO LARGE
         L     RWORK4,FWDPTR(RBLOCK) BLOCK IS EXACT SIZE NEEDED
         L     RWORK5,BCKPTR(RBLOCK)
         ST    RWORK4,FWDPTR(RWORK5) ELIMINATE BLOCK FROM QUEUE
         ST    RWORK5,BCKPTR(RWORK4)
         B     FBBEGOUT            RETURNING                      20021
CKLSTBLK C     RWORK2,0(RBLOCK,RDISP)   Q. LAST FBQE              20021
         BNE   FBQLOOP             NO - CHECK NEXT FBQE            LC0A
         LR    RBLOCK,RWORK2 YES - RESTORE PQE ADDRESS AND        20021
         B     NEXTPQE                   CONTINUE THE SEARCH       LC0A
FREEPTR  L     RBLOCK,GOVRFLB+8    PICK UP PTR TO FREE AREA PQE
         ST    RCOMRET3,RREGSAVE  SAVE RETURN ADDRESS             20021
         B     NEXTPQE
FBQREPR  B     FBBEG               SUBPOOLS 0-127
         SR    RSIZE,RWORK1        FIND NUMBER OF SURPLUS BYTES
         ST    RSIZE,FBQESIZE(RBLOCK) ADJUST FBQE FOR ALLOCATED BLOCKS
         AR    RBLOCK,RSIZE        COMPUTE ADDRESS OF ALLOCATED BLOCK
         LR    RSIZE,RWORK1        RETURN SIZE OF ALLOCATED BLOCK
         B     FBBEGOUT            RETURNING                      20021
FBBEG    SR    RSIZE,RWORK1        FIND NUMBER OF SURPLUS BYTES
         ST    RSIZE,FBQESIZE(RBLOCK) PUT CORRECTED SIZE IN OLD FBQE
         LR    RSIZE,RWORK1        RETURN SIZE OF ALLOCATED BLOCK
         AR    RWORK1,RBLOCK       COMPUTE ADDRESS OF NEW FBQE
         L     RWORK4,FWDPTR(RBLOCK) PICK UP FWD PTR FROM OLD FBQE
         L     RWORK5,BCKPTR(RBLOCK) PICK UP BACK PTR FROM OLD FBQE
         MVC   0(FBQELNTH,RWORK1),0(RBLOCK) MOVE FBQE TO NEW LOCATION
         ST    RWORK1,FWDPTR(RWORK5) PUT NEW FBQE ADDRESS IN PREVIOUS
*                                     BLOCK FWD PTR
         ST    RWORK1,BCKPTR(RWORK4) PUT NEW FBQE ADDRESS IN FOLLOWING
*                                     BLOCK BACK POINTER
FBBEGOUT L     RCOMRET3,RREGSAVE   RESTORE RETURN REGISTER        20021
         BR    RCOMRET3            RETURN
         EJECT
*        UPDATE FQE TO REMOVE ASSIGNED AREA
*           INPUT - RFRELNTH - LENGTH OF REMAINING FREE AREA
*                   RFQE   - FQE TO BE UPDATED
*                   RPREFQE- PREVIOUS FQE ON QUEUE
*           OUTPUT- RFQE   - ADDR OF ASSIGNED AREA
*           REGISTERS USED - RFRELNTH,RFQE,RPREFQE,RCOMRET1,RCOMRET2,
*                            RVALCKIN
*
GFQEUPDT CL    RSPID,C252          IS REQUEST FOR SP 252-255
         BC    11,GFQEUP1          YES - BYPASS VALIDITY CHECK
         MVI   MSGLEN,X'0C'   SET TEMP MSG LEN IN CASE OF ABEND   21016
         BAL   RCOMRET2,CFQECHK    CHK THAT FQE & PREV FQE IN USER CORE
         MVI   MSGLEN,X'00'        TURN OFF MSG LEN               21016
GFQEUP1  LTR   RFRELNTH,RFRELNTH   IF LENGTH REMAINING IN FQE IS ZERO
         BZ    GFQEOUT             REMOVE FQE FROM QUEUE
         ST    RFRELNTH,FQELNTH(RFQE) STORE REMAINING LNTH IN FQE
         AR    RFQE,RFRELNTH       GET ADDRESS OF ASSIGNED AREA
GFQEUP2  CL    RSPID,C252          IS REQUEST FOR SP 252-255
         BCR   11,RCOMRET1         YES - RETURN
         LA    RWORK4,0(RFQE,RLENGTH) COMPUTE UPPER BOUND OF FQE
         CR    RPREFQE,RDQE        IS PREVIOUS QE A DQE
         BE    GFQEUP3             YES
         CR    RWORK4,RPREFQE      IS UPPER BOUND OF FQE AREA LESS
*                                   THAN PREVIOUS FQE
         BCR   4,RCOMRET1          YES - RETURN
         B     BADFQE              NO - ERROR                     21016
GFQEUP3  CR    RWORK4,RWORK6       IS UPPER BOUND OF FQE AREA GREATER
*                                   THAN DQE UPPER BOUND
         BCR   13,RCOMRET1         NO - RETURN
         B     BADFQE              YES - ERROR                    21016
GFQEOUT  MVC   FQENXT+1(3,RPREFQE),FQENXT+1(RFQE) DEQUEUE 0 LENGTH FQE
         B     GFQEUP2             CHECK FOR DESTROYED FQE
         EJECT
*        BUILD QUEUE ELEMENT (AQE) FOR SUBPOOL 253 OR 254 CORE
*           INPUT - RFRELNTH - LENGTH OF REMAINING FREE AREA
*                   RFQE   - ADDRESS OF FQE
*                   RPREFQE - ADDRESS OF PREVIOUS FQE
*
*           OUTPUT- RFQE   - ADDRESS OF ASSIGNED CORE
*           REGISTERS USED - RFRELNTH,RFQE,RLENGTH,RAQE,RTCB
*                            RCOMRET1
*
GBLDAQE  ST    RFRELNTH,FQELNTH(RFQE)   STORE REMAINING LENGTH IN FQE
         LA    RAQE,0(RFRELNTH,RFQE)    GET ADDRESS OF AQE
         LTR   RFRELNTH,RFRELNTH        IF FQE LENGTH IS ZERO
         BC    7,GBLDAQE2
         MVC   FQENXT+1(3,RPREFQE),FQENXT+1(RFQE) IF FQE LNTH IS 0,
*                                              REMOVE FROM QUEUE
GBLDAQE2 MVC   AQENXT(4,RAQE),TCBAQE(RTCB) PUT POINTER IN NEW AQE
         ST    RAQE,TCBAQE(RTCB)   PUT AQE IN QUEUE
         ST    RLENGTH,AQELNTH(RAQE) PUT LENGTH IN AQE
          LA    RFQE,8
          SR    RLENGTH,RFQE
         LA    RFQE,8(RAQE)        GET ADDR OF ASSIGNED CORE
         BR    RCOMRET1                 RETURN
*
*
*
*        CREATE AN SPQE FOR A NEW SUBPOOL
*           INPUT - RTCB - ADDRESS OF TCB
*
*
*
*
GSPQESPC LR    RWORK1,RIN1         SAVE INPUT REG
         LA    RIN1,8
         BAL   RCOMRET1,GETMAINB   GET 8 BYTES FOR AN SPQE
         LR    RSPQE,RIN1
         MVC   SPQENXT+1(3,RSPQE),TCBMSS+1(RTCB) NXT SPQE PTR TO SPQE
         IC    RWORK4,TCBMSS(RTCB)
         ST    RSPQE,TCBMSS(RTCB)       NEW SPQE ADDR TO TCB
         STC   RWORK4,TCBMSS(RTCB)
         STC   RSPID,SPQEID(RSPQE)      STORE SUBPOOL ID IN SPQE
***************  CREATE INITIAL SPQE FOR TASK  ***************
         OC    SPQENXT+1(3,RSPQE),SPQENXT+1(RSPQE) FIRST SPQE IF PTR=0
         BNE   GSPQESP1                 BRANCH IF NOT FIRST SPQE
         MVI   SPQEFLGS(RSPQE),SPQELAST SET FLAG-SPQE IS LAST ON CHAIN
*************************************************************
GSPQESP1 LR    RIN1,RWORK1
         B     GCOMMON1
         EJECT
*        ENTRY POINT TO FREEMAIN
         SPACE
         DS    0D
         DROP  FREBAS .          DROP SECOND BASE                 M0105
IGC005   BALR  RBASE,0
         USING *,RBASE
         L     RBASE,MSSADR
         USING MSSBASE,RBASE,FREBAS                               20021
         SPACE 2
*        ROUTINE TO PICK UP SUBPOOL ID, BRANCH TO VALIDITY CHECK
*           ROUTINE TO CHECK LISTS, AND TO CHECK FOR LIST REQUEST
*           INPUT REGISTER
*              RIN1 - ADDRESS OF PARAMETER LIST
*           OUTPUT REGISTERS
*              RSPID   - SUBPOOL ID
*              RLENGTH - LENGTH OR ADDRESS OF LENGTH LIST
*              RADDR   - ADDRESS OF AREA LIST OR ADDRESS OF LENGTH-AREA
*                          LIST
         SPACE
         L     FREBAS,DBASADR .    ESTABLISH SECOND BASE          20021
         MVC   MODEBYTE(1),33(0)   MODE INTO MODE BYTE
FMBASE   MVI   SVCBYTE,5 .           SAVE THE SVC NUMBER
         L     IPVLBASE,IPVAL .    LOAD ADD OF VALIDY CK RTN      M2198
         BALR  RCOMRET1,IPVLBASE   VALIDITY CHECK INPUT PARAMETERS
         TM    TYPE(RIN1),CODE
         BC    NOTLIST,FVARCHK     IF NOT A LIST REQUEST
         SPACE 2
*        ROUTINE TO HANDLE FREEING OF LIST REQUESTS
*           INPUT REGISTERS
*              RLENGTH - ADDRESS OF LENGTH LIST
*              RADDR   - ADDRESS OF AREA LIST
*           OUTPUT REGISTERS
*              RLST    - ADDRESS OF CURRENT LENGTH IN LENGTH LIST
*              RADDR1  - ADDRESS OF CURRENT AREA IN AREA LIST
*              RLENGTH - CURRENT LENGTH
*              RADDR   - CURRENT AREA ADDRESS
         SPACE
         LR    RLST,RLENGTH        SAVE LENGTH LIST ADDRESS
         LA    RFMRET,FMCOMMON
FLISTADV L     RLENGTH,0(RLST)     PICK UP LENGTH FROM LIST
         LA    RLENGTH,0(RLENGTH)  CLEAR LAST ENTRY INDICATOR
         TM    0(RLST),X'80'       IS THIS LAST ENTRY IN LIST
         BC    1,FLAST
         BALR  RFMRET,RFMRET       BRANCH TO FREEMAIN COMMON ROUTINE
         LA    RLST,4(RLST)        PICK UP NEXT ENTRY
         LA    RADDR,4(RADDR)
         LA    RFMRET,FCOMMON1     BYPASS SPQE SEARCH
         B     FLISTADV
FLAST    BALR  RFMRET,RFMRET       TO FREE LAST ELEMENT IN LIST
         BR    RRETURN
         SPACE 2
*        ROUTINE TO HANDLE FREEING OF VARIABLE REQUESTS
*           INPUT REGISTER
*              RADDR   - ADDRESS OF LENGTH-ADDRESS LIST
*           OUTPUT REGISTERS
*              RLENGTH - LENGTH OF AREA TO BE FREED
*              RADDR   - ADDRESS OF AREA TO BE FREED
         SPACE
FVARCHK  BC    ELEMENT,FELEMENT    IF ELEMENT REQUEST
         L     RLENGTH,VLNTH(RADDR)
         SPACE 2
*        ROUTINE TO HANDLE FREEING OF ELEMENT REQUESTS
*           INPUT REGISTERS
*              RLENGTH - LENGTH
*              RADDR   - ADDRESS OF LOCATION CONTAINING AREA ADDRESS
*           OUTPUT REGISTERS
*              RLENGTH - LENGTH OF AREA TO BE FREED
*              RADDR   - ADDRESS OF AREA TO BE FREED
         SPACE
FELEMENT OI    FREESW,X'08'                                       21016
         BAL   RFMRET,FMCOMMON     ELEMENT - BR TO FREE STORAGE   21016
         BR    RRETURN
         SPACE 2
*        BRANCH ENTRY PROCESSING
         SPACE
         DROP  FREBAS .          DROP SECOND BASE                 M0105
FMBRANCH LR    RIN15,RBASE         SAVE REGISTER 8
         BALR  RBASE,0
         USING *,RBASE
         L     RBASE,MSSADR
         USING MSSBASE,RBASE,FREBAS                               20021
         SSM   CLHIBYTE .          DISABLE                        M3872
         ST    RIN15,FMBRSAV+24    RIN15=ENTRY CONTENTS OF REG8  A28819
         LA    RIN15,FMBASE        SET UP BRANCH TO FREEMAIN      M3872
FMBRNCOM EQU   *                                                  M3872
         STM   RLST,RCOMRET3,FMBRSAV                             A28819
         STM   RCOMRET1,RRETURN,FMBRSAV+28                       A28819
         L     FREBAS,DBASADR .     ESTABLISH SECOND BASE         M0105
         ST    RRETURN,BRNREG    SAVE RETURN REG                  21016
         MVI   MODEBYTE,0 .        SET SUPERVISOR MODE           PIT032
         MVI   BESW,X'FF'          SET BRANCH ENTRY SWITCH        21016
         BALR   RRETURN,RIN15
         MVI   BESW,X'00'          RESET BRANCH ENTRY SWITCH     A28819
.D       LM    RLST,RRETURN,FMBRSAV RESTORE CALLERS REGS         A28819
         BR    RRETURN                                           A28819
*               SAVE AREAS
BRANCHSV DS    13F .                                              M2279
IEA10FS  EQU   *                           REF USED BY ABEND      M3806
FMBRSAV  DS    16F .     SAVE AREA FOR FM BRANCH ENTRY            M2279
FMSAVE   DS    16F .                                              M2279
SAVREG2  DS    16F .                                              M2279
SAVEAREA DS    16F .                                              M2279
SAVEREGS DS    12F .                                              M2279
DBASADR  DC    A(MSSBASE+4096) .                                  M2279
CLHIBYTE DC    X'00FFFFFF' .                                      M2279
MSSADR   DC    A(MSSBASE)                                         21016
         EJECT
*        SPECIAL SUBPOOL FREEMAIN TO HANDLE FREEING OF A COMPLETE
*        SUBPOOL
         SPACE
SPFRMAIN OI    FREESW,X'08'        SET FREEMAIN SWITCH            21016
         LTR   RLENGTH,RLENGTH     IS LENGTH ZERO                 21016
         BZ    LENOK                                              21016
         MVI   MSGLEN,X'8C'       REASON CODE(4) AND LENGTH(12)   21016
         ST    RTCB,ABNDATA       STORE TCB SEARCHED              21016
         SR    RADDR,RADDR        SET ZERO FOR SUBPOOL FREEMAIN   21016
         B     GERROR3                                            21016
LENOK    LA    RWORK3,254                 (21016) ***** TEMPORARY ****
         CR    RSPID,RWORK3                       ***** TEMPORARY *****
         BNL   GERR4   **TEMP** 254-255 SUBPOOL FREEMAIN ILLEGAL  21016
.*       AIF   (&TSO NE 1).TSO1300        *516620*             @AS76386
         LA    RWORK3,243         FREEMAIN OF SUBPOOLS            20021
         CR    RSPID,RWORK3       243,244,245 IS ILLEGAL          20021
         BL    SPOK                                               20021
         LA    RWORK3,245                                         20021
         CR    RSPID,RWORK3                                       20021
         BNH   GERR4                                              21016
SPOK     EQU   *                                                  20021
         SPACE                                                    20021
.TSO1300 ANOP                                                     20021
         OI    MODEBYTE,2          INDICATE SUBPOOL FREEMAIN
         BAL   RCOMRET1,CSPCHK     TO LOCATE SPQE
         BR    RRETURN             SPQE NOT FOUND
         BCR   0,RRET              NOP
         TM    MODEBYTE,X'F0'      SUPERVISOR KEY
         BZ    SPFRMNSV            YES
         LTR   RSPID,RSPID         SUBPOOL ZERO?
         BNZ   SPFRMNSV                                           21016
GERR4    SR    RADDR,RADDR                                        21016
         MVI   MSGLEN,X'08'                                       21016
         B     GERROR4             PROBLEM PGM ATTEMPTING TO FREE 21016
*                                   ALL OF SUBPOOL ZERO
SPFRMNSV LTR   RSPID,RSPID         IS IT SUBPOOL 253
         BM    SP253FRE            YES, SP253 OR SP254             MP2K
         AIF   ('&MPS' NE 'Y').MP0218                              MP2K
         BP    NOTRMS  NOT NEGATIVE OR SUBPOOL 0                   MP2K
         CLI   TCBCMCDE(RTCB),X'F4'                                MP2K
         BNE   NOTRMS                                              MP2K
         L     RWORK2,ENPTMP2K  GET ENTRY POINT TO MP SUBROUTINE   MP2K
         BR    RWORK2           BRANCH TO MP SUBROUTINE            MP2K
.MP0218  ANOP                                                      MP2K
NOTRMS   LA    RFMRET,SPFRMRET          SET UP RETURN              MP2K
         STM   RRETURN,RFMRET,FMSAVE SAVE REGISTERS
SPFRMRET L     RDQE,SPQEDQE(RSPQE)      PICK UP DQE
         LA    RDQE,0(RDQE)        CLEAR OUT SPID
         LTR   RDQE,RDQE           END OF QUEUE IF ZERO
         BCR   8,RRETURN           END OF QUEUE - EXIT
         SR    RSIZE,RSIZE
         LR    RBLOCK,RSIZE
         L     RSIZE,DQELNTH(RDQE) PICK UP NUMBER OF BYTES
         L     RBLOCK,DQEADDR(RDQE) ADDRESS OF FIRST 2K BLOCK
         AIF   ('&LCS' NE 'Y').LC50                                LC0A
         LA    RBLOCK,0(RBLOCK)    CLEAR HIERARCHY IDENT           LC0A
.LC50    ANOP                                                      LC0A
         LR    RWORK4,RSIZE
SPFSTDQE ST    RSPQE,PREVDQSV      SPQE IS ALWAYS PREVIOUS DQE
         L     RPQE,TCBPQE(RTCB)        PICK UP ADDR OF PQE
         AIF   (&SMF NE 1).NOSMFSV
         ST    RTCB,SMFTCBSV            SAVE TCB POINTER            SMF
.NOSMFSV ANOP
         L     RPQE,DUMBWD(RPQE)        PICK UP PTR TO PQE         MP2K
LOOP1    C     RBLOCK,PQESTADD(RPQE)   9IS CORE IN THIS REGION     MP2K
         BNL   FCOMMON3                 YES                        MP2K
         L     RPQE,DUMBWD(RPQE)        PICK UP END OF PQE CHAIN   MP2K
         LTR   RPQE,RPQE               IS THIS END OF CHAIN?  SC A63059
         BNZ   LOOP1                                              21016
         MVI   MSGLEN,X'6C'         REASON CODE(3) AND LENGTH(12) 21016
         ST    RTCB,ABNDATA     STORE TCB SEARCHED                21016
         SR    RADDR,RADDR      SET 0 INPUT TO SUBPOOL FREEMAIN   21016
         B     GERROR3                                            21016
         SPACE
*        ROUTINE TO FREE SUBPOOL FOR SUBPOOL 253
         SPACE
SP253FRE LA    RFMRET,SP253RET
         AIF   (&TSO NE 1).TSO1400                                20021
         L     RWORK2,TCBPQE(RTCB)                                20021
         LTR   RWORK2,RWORK2           BRANCH IF NO               20021
         BZ    SP253RET        PQE                                20021
         L     RWORK2,PQENXT(RWORK2)                              20021
         L     RWORK2,PQESTADD(RWORK2)  GET LSQS SPQE ADDRESS     20021
         AGO   .TSO1500                                           20021
.TSO1400 ANOP                                                     20021
         L     RDQE,SPQEDQE(RSPQE) PICK UP DQE
         LA    RDQE,0(RDQE)        CLEAR HIGH ORDER BYTE
.TSO1500 ANOP                                                     20021
SP253RET L     RADDR,TCBAQE(RTCB)  PICK UP ADDRESS OF FIRST AREA
         LTR   RADDR,RADDR         IS IT ZERO
         BCR   8,RRETURN           YES - END OF QUEUE             20021
         AIF   (&TSO NE 1).TSO1600                                20021
         L     RSPQE,SQSBOUND .    LOAD SQS + 1 ADDRESS           M1389
         LA    RSPQE,0(RSPQE) .    ZERO HIGH ORDER BYTE           M1389
         CR    RADDR,RSPQE .       IS AQE IN SQS                  M1389
         LA    RSPQE,SQESPQE .     LOAD SQS SPQE                  M1389
         BL    *+6                   YES-BRANCH                   20021
         LR    RSPQE,RWORK2       NO-LOAD LSQS SPQE               20021
         L     RDQE,SPQEDQE(RSPQE) LOAD DQE                       20021
         LA    RDQE,0(RDQE)                                       20021
.TSO1600 ANOP                                                     20021
         L     RLENGTH,AQELNTH(RADDR) PICK UP LENGTH OF AREA
         LA    RAREAUB,0(RADDR,RLENGTH) FIND UPPER BOUND OF AQE AREA
         STM   RRETURN,RFMRET,FMSAVE SAVE REGISTERS
         B     FCOMMON4
         EJECT
*        **************************************************************
*                           FREEMAIN COMMON ROUTINES
*        **************************************************************
         SPACE 2
*        THE FREEMAIN COMMON ROUTINES CONSIST OF THE CODE WHICH IS
*        COMMON TO ALL FORMS OF FREEMAIN EXCEPT THE SPECIAL R-FORM
*        FREEING A COMPLETE SUBPOOL.  THIS CODE MAKES USE OF OTHER
*        SUBROUTINES WHICH ARE COMMON TO GETMAIN AND FREEMAIN AND
*        WHICH ARE LOCATED ELSEWHERE IN THIS MODULE.
*           INPUT REGISTERS
*              RSPID   - SUBPOOL ID
*              RLENGTH - LENGTH OF AREA TO BE FREED (IN BYTES)
*              RADDR   - BEGINNING ADDRESS OF AREA TO BE FREED
*              RTCB    - TCB OF REQUESTING TASK
         SPACE
FMCOMMON BAL   RCOMRET1,CSPCHK     TO LOCATE SPQE
         B     SUBPERR             ERROR - NOT IN SUBPOOL NAMED   21016
         SPACE 2
         AIF   (&TSO NE 1).TSO1700                                20021
*        IF REQUEST IS FOR LSQS SUBPOOL- CHECK IF AREA WAS        20021
*        OBTAINED FROM LSQS OR SQS. SQS IS ALLOCATED WHEN         20021
*        LSQS IS FULL.                                            20021
         TM    LSQSSW,LSQSMSK      IS REQUEST FOR LSQS?           20021
         BZ    FCOMMON1          NO- CONTINUE.                    20021
         LA    RSPQE,0(RSPQE)     CLEAR HI-BYTE OF SPQE           20021
         C     RSPQE,0(RADDR)      STORAGE IN SQS?                20021
         BL    FCOMMON1            NO- CONTINUE                   20021
         LA    RSPQE,SQESPQE       LOAD SQS SPQE                  20021
         MVI   LSQSSW,LSQSOFF      CLEAR LSQS SWITCH.             20021
         SPACE 2                                                  20021
.TSO1700 ANOP                                                     20021
*        ROUTINE TO LOCATE THE DQE CONTAINING THE STORAGE TO BE FREED
*           A SUCCESSFUL RETURN FROM GSPCHK RETURNS TO THIS POINT
*           INPUT REGISTERS
*              RSPQE   - SPQE ADDRESS
*              RADDR   - ADDRESS OF STORAGE TO BE FREED
*              RLENGTH - LENGTH OF STORAGE TO BE FREED
*           OUTPUT REGISTERS
*              RDQE    - ADDRESS OF DQE CONTAINING STORAGE TO BE FREED
*              RDQELB  - LOWER BOUND OF AREA DESCRIBED BY DQE
*              RDQEUB  - UPPER BOUND OF AREA DESCRIBED BY DQE
*              RAREAUB - UPPER BOUND OF AREA TO BE FREED
*              RPREVDQ - ADDRESS OF PREVIOUS DQE
         SPACE
FCOMMON1 STM   RRETURN,RFMRET,FMSAVE SAVE REGISTERS
         L     RADDR,0(RADDR)      PICK UP ADDRESS
         LA    RADDR,0(RADDR)  CLEAR HI-ORDER BYTE.
FCOMMON2 BAL   RCOMRET1,CRNDLNTH   TO ROUND UP LENGTH
         LTR   RLENGTH,RLENGTH
         BZ    FCOMRET             RETURN IF LENGTH=0 FOR SUBPOOL
*                                   OTHER THAN 253 OR 254
         NR    RWORK2,RADDR        RWORK2 CONTAINS 7 FROM CRNDLNTH
         BE    ADROK               ERR - ADDR NOT MULTIPLE OF 8   21016
         MVI   MSGLEN,X'0C'        SET LENGTH EQUAL 12            21016
         ST    RTCB,ABNDATA        SAVE TCB ADDR                  21016
         CLI   SVCBYTE,X'05'       SVC 5?                         21016
         BE    GERROR9             YES. TEMP DATA CORRECT         21016
         MVI   MSGLEN,X'08'        NO. CHANGE LENGTH TO 8         21016
         ST    RADDR,ABNDATA       SAVE ALTERNATE DATA            21016
         B     GERROR9             GO TO ABEND                    21016
ADROK    LTR   RSPID,RSPID         IS THIS SUBPOOL 253 OR 254     21016
         BC    NN,STRTSRCH         NO
         LA    RWORK3,QESIZE       YES
         SR    RADDR,RWORK3        BACK UP ADDRESS TO BEGINNING OF QE
STRTSRCH LR    RDQE,RSPQE
FADVDQE  LR    RPREVDQ,RDQE        SAVE ADDRESS OF PREVIOUS DQE
         L     RDQE,DQENXT(RDQE)   PICK UP ADDRESS OF DQE
         N     RDQE,CLHIBYTE       CLEAR HIGH ORDER BYTE
         BNZ   ADRDQE                                             21016
         MVI   MSGLEN,X'2C'         REASON CODE(1) AND LENGTH(12) 21016
         ST    RTCB,ABNDATA         STORE TCB SEARCHED            21016
         B     GERROR3                                            21016
ADRDQE   L     RDQELB,DQEADDR(RDQE) PICK UP ADDR OF FIRST BLOCK   21016
         AIF   ('&LCS' NE 'Y').LC23                                LC0A
         LA    RDQELB,0(RDQELB)    CLEAR HIERARCHY IDENT           LC0A
.LC23    ANOP                                                      LC0A
         L     RDQEUB,DQELNTH(RDQE) PICK UP NUMBER OF BYTES
FCUPRBND AR    RDQEUB,RDQELB       COMPUTE UPPER BOUND OF DQE AREA
*                                  COMPUTE UPPER BOUND OF AREA TO BE
*                                   FREED
         LR    RAREAUB,RADDR                                   @JK69892
         AR    RAREAUB,RLENGTH                                 @JK69892
*                                  IS AREA TO BE FREED WITHIN DQE
*                                   BOUNDS - IF NOT, PICK UP NEXT DQE
         CR    RADDR,RDQELB
         BL    FADVDQE
         CR    RAREAUB,RDQEUB
         BH    FADVDQE
         CR    RADDR,RDQEUB        IS START GREATER DQE END    @SA77070
         BH    FADVDQE                                         @SA77070
         CR    RAREAUB,RDQELB      IS END LESS THAN DQE START  @SA77070
         BL    FADVDQE                                         @SA77070
         CR    RADDR,RAREAUB       IS START GREATER THAN END   @SA77070
         BH    FADVDQE             *                           @SA77070
         ST    RPREVDQ,PREVDQSV    SAVE ADDRESS OF PREVIOUS DQE
         SPACE
         LTR   RSPID,RSPID         IS THIS SUBPOOL 253 OR 254
         BC    NN,FRECOMBN         NO
         SPACE 2
*        ROUTINE TO REMOVE FREE SUBPOOL 253 OR 254 STORAGE FROM QUEUE
*           INPUT REGISTERS
*              RADDR   - ADDRESS OF STORAGE TO BE FREED
*              RLENGTH - LENGTH OF STORAGE TO BE FREED
*              RAREAUB - UPPER BOUND OF AREA TO BE FREED
*              RDQE    - ADDRESS OF DQE CONTAINING STORAGE TO BE FREED
         SPACE
*        LOCATE QE LESS THAN OR EQUAL TO RADDR.  SAVE PREVIOUS QE ADDR
         SPACE
FCOMMON4 LA    RQE,TCBAQE(RTCB)
         L     RWORK1,0(0,RQE)     GET AQE ADDRESS                 8098
         LTR   RWORK1,RWORK1       Q. IS AQE ADDRESS ZERO          8098
         BNZ   FC4LOOP             NO - PROCESS NORMALLY           8098
         LA    RERROR,GERRCODE     YES- SET UP ERROR CODE REGISTER 8098
FCOMMN4B MVI   MSGLEN,X'08'                                       21016
         ST    RADDR,ABNDATA                                      21016
         B     GERROR13                                            8098
FC4LOOP  LR    RPREVQE,RQE         SAVE PREVIOUS AQE ADDRESS
         L     RQE,0(0,RQE)        PICK UP AQE ADDRESS
         CR    RADDR,RQE           IS THIS AQE WANTED
         BL    FC4LOOP             NO - CHECK NEXT AQE
         LA    RERROR,GERRCODE  SET UP ERROR CODE IN REGISTER SIX  9774
         LTR   RQE,RQE  Q. THIS THE END OF THE AQE CHAIN           9774
         BC    8,FCOMMN4B     THIS CORE ALREADY FREED             21016
         SPACE
*        COMPUTE UPPER BOUND OF AQE AREA
         SPACE
         L     RQESIZ,AQELNTH(RQE) PICK UP SIZE
         LA    RAQEUB,0(RQE,RQESIZ) COMPUTE UPPER BOUND
         CR    RAREAUB,RAQEUB      IS AREA WITHIN AQE AREA
         BH    FC4LOOP             NO - PICK UP NEXT AQE
         BL    FAQELOWR            NOT FREEING UPPER PART OF AQE AREA
         CR    RADDR,RQE
         BNE   FAQEUPPR            NOT FREEING LOWER PART OF AQE AREA
*                                  THE FOLLOWING INSTRUCTION REMOVES
*                                   THE FREE AREA FROM THE QUEUE
         MVC   AQENXT+PTROFST(ADRLNTH,RPREVQE),AQENXT+PTROFST(RQE)
         B     FRECOMBN
         SPACE
*        FREEING UPPER PART OF STORAGE DESCRIBED BY AQE
         SPACE
FAQEUPPR LA    RWORK3,QESIZE
         AR    RADDR,RWORK3        ADJUST ADDRESS AND SIZE FOR PORTION
         SR    RLENGTH,RWORK3       ACTUALLY BEING FREED
         BZ    FCOMRET             RETURN IF LENGTH=0
         SR    RQESIZ,RLENGTH      COMPUTE NEW SIZE FOR AQE (BYTES)
         B     FAQEUPR1
         SPACE
*        FREEING LOWER PART OF STORAGE DESCRIBED BY AQE
         SPACE
FAQELOWR LA    RWORK1,QESIZE       REMOVE 8 BYTES FROM FREE AREA FOR
         SR    RAREAUB,RWORK1       NEW AQE
         SR    RLENGTH,RWORK1
         ST    RAREAUB,AQENXT(RPREVQE) PUT NEW AQE IN QUEUE
         SR    RAQEUB,RAREAUB      NUMBER OF BYTES FOR NEW AQE
         LR    RWORK3,RAREAUB      RAREAUB IS REG 0 AND CANNOT BE USED
*                                   AS INDEX
         ST    RAQEUB,AQELNTH(RWORK3)
         CR    RQE,RADDR
         BNE   FAQEMID             FREEING MIDDLE OF AQE AREA
         MVC   AQENXT(4,RWORK3),AQENXT(RQE) PTR INTO NEW AQE
         B     FRECOMBN
         SPACE
*        FREEING MIDDLE PART OF STORAGE DESCRIBED BY AQE
         SPACE
FAQEMID  ST    RQE,0(RWORK3) POINT NEW AQE TO NEXT QE
         AR    RADDR,RWORK1        ADJUST ADDRESS AND SIZE FOR PORTION
         SR    RLENGTH,RWORK1       ACTUALLY BEING FREED
         LR    RWORK1,RADDR
         SR    RWORK1,RQE          SIZE OF REMAINING LOWER PART (BYTES)
FAQEUPR1 ST    RWORK1,AQELNTH(RQE)
         SPACE 2
*        ROUTINE TO PUT FREE STORAGE INTO THE QUEUE AND TO COMBINE
*         ADJOINING FREE AREAS
*           INPUT REGISTERS
*              RADDR   - ADDRESS OF STORAGE TO BE FREED
*              RLENGTH - LENGTH OF STORAGE TO BE FREED
*              RAREAUB - UPPER BOUND OF AREA TO BE FREED
*              RDQE    - ADDRESS OF DQE CONTAINING STORAGE TO BE FREED
*              RSPID   - SUBPOOL ID OF STORAGE TO BE FREED
*           OUTPUT REGISTERS
*              RFQE    - ADDRESS OF FQE CONTAINING STORAGE FREED
*              RPREVQE - ADDRESS OF QUEUE ELEMENT PREVIOUS IN QUEUE TO
*                         FQE CONTAINING STORAGE FREED
*              RLENGTH - LENGTH OF STORAGE DESCRIBED BY FQE
         SPACE
*        LOCATE QE LESS THAN OR EQUAL TO RAREAUB. SAVE PREVIOUS QE ADDR
         SPACE
FRECOMBN EQU   *                                                  20021
         BAL   RCOMRET1,QELOCATE
         CL    RSPID,C252          IS REQUEST FOR SP 252-255
         BC    11,FRECMBN1         YES - BYPASS VALIDITY CHECK
         LR    RWORK3,RDQELB       SAVE DQE LOWER BOUND ACROSS CFQECHK
         MVI   MSGLEN,X'10'    SET TEMP MSG LEN IN CASE OF ABEND  21016
         BAL   RCOMRET2,CFQECHK
         MVI   MSGLEN,X'00'        TURN OFF MSG LENGTH            21016
         LR    RDQELB,RWORK3       RESTORE DQE LOWER BOUND
         SPACE
*        THE 'STRAIGHT THROUGH' PATH IN THIS ROUTINE COMBINES A FREE
*         AREA WITH AN ADJACENT UPPER FREE AREA AND AN ADJACENT LOWER
*         FREE AREA
         SPACE
FRECMBN1 CR    RQE,RAREAUB
         BNE   FQENDTST            UPPER AREA NOT ADJACENT
         A     RLENGTH,FQELNTH(RQE) COMBINE LENGTH OF FREE AREA AND
*                                    ADJACENT UPPER FREE AREA
FQEADV   L     RQE,FQENXT(RQE)     PICK UP NEXT QE ADDRESS
         LTR   RQE,RQE             IS IT END OF QUEUE
         BZ    FQREPAIR            YES - TIE ONTO END OF QUEUE
*                                   255
* THE HIGH ORDER BYTE OF AN FQE IS ALWAYS ZERO WHEN CORRECT        MP2K
FCHOVRLP TM    FQENXT(RQE),X'FF'   CHECK IT                        MP2K
         BNE   BADFQE                                             21016
         LR    RQEUB,RQE
         A     RQEUB,FQELNTH(RQE)  COMPUTE UPPER BOUND OF FQE AREA
         CL    RSPID,C252          IS REQUEST FOR SP 252-255
         BC    11,FQECH2           YES - BYPASS VALIDITY CHECK
         CR    RPREVQE,RDQE        IS PREVIOUS QE A DQE
         BNE   FQECH1              NO
         CR    RQEUB,RWORK6        IS UPPER BOUND OF FQE AREA GREATER
*                                   THAN DQE UPPER BOUND
         BC    13,FQECH2           NO
BADFQE   MVI   MSGLEN,X'4C'        SET REASON CODE(2) AND LEN(12) 21016
         LM    13,14,FQENXT(RQE)
         STM   13,14,ABNDATA
         CLI   SVCBYTE,X'05'       SVC 4, 5, OR A?                21016
         BL    SPECERR             PROB DETERM DATA OK FOR SVC 04 21016
         BE    BADFQEX             SVC 5                          21016
         NI    FREESW,X'FF'-X'08'  SVC A , DUMMY FREESW           21016
         B     SPECERR                                            21016
BADFQEX  MVI   MSGLEN,X'50'        SET REASON CODE(2) AND LEN(16) 21016
         B     SPECERR                                            21016
OVRLAP   SR    RQEUB,RADDR                                        21016
         ST    RQEUB,ABNDATA                                      21016
         MVI   MSGLEN,X'0C'        LENGTH OF VARIABLE DATA        21016
         B     GERROR10                                           21016
FQECH1   CR    RQEUB,RPREVQE       IS UPPER BOUND OF FQE AREA LESS
*                                   THAN ADDRESS OF PREVIOUS FQE
         BNL   BADFQE              NO - ERROR                     21016
FQECH2   CR    RQEUB,RADDR
         LA    RERROR,GERRCODE     SET UP ERROR CODE REGISTER      LC0A
         BH    OVRLAP              ERROR - OVERLAP                21016
         BL    FQREPAIR            LOWER AREA IS NOT ADJACENT
         A     RLENGTH,FQELNTH(RQE) COMBINE LENGTH OF ADJACENT FREE
*                                   AREAS
FCOMPRPR ST    RLENGTH,FQELNTH(RQE) COMBINED SIZE IN FQE
         ST    RQE,FQENXT(RPREVQE) REPAIR QUEUE
         SPACE 2
*        ROUTINE TO DETERMINE WHETHER 2K BLOCKS CAN BE RELEASED
*        IF 2K BLOCKS CAN BE RELEASED, THIS ROUTINE WILL RESTRUCTURE
*         THE QUEUES AS NECESSARY AND RELEASE THE BLOCKS TO FBMAP
*           INPUT REGISTERS
*              RFQE    - ADDRESS OF FQE CONTAINING STORAGE FREED
*              RLENGTH - LENGTH OF STORAGE DESCRIBED BY FQE
*              RPREVQE - ADDRESS OF QUEUE ELEMENT PREVIOUS IN QUEUE TO
*                         FQE CONTAINING STORAGE FREED
*              RDQE    - ADDRESS OF DQE CONTAINING STORAGE FREED
*              RDQEUB  - UPPER BOUND OF STORAGE DESCRIBED BY DQE
*                         CONTAINING STORAGE FREED
*              RPREVDQ - ADDRESS OF DQE PREVIOUS IN QUEUE TO DQE
*                         CONTAINING STORAGE FREED
         SPACE
*        DETERMINE WHETHER THERE ARE 2K BLOCKS TO BE RELEASED
         SPACE
         CL    RSPID,C252          IS IT SQ AREA
         BH    FCOMRET             YES - DO NOT RELEASE BLOCK
         LA    RAREAUB,0(RFQE,RLENGTH) DETERMINE UPPER BOUND OF AREA
         LA    RWORK1,2047
         LR    RFQRND,RFQE
         LR    RUBRND,RAREAUB
         AR    RFQRND,RWORK1
         OR    RFQRND,RWORK1
         XR    RFQRND,RWORK1       RFQRND CONTAINS FQE ADDR. ROUNDED UP
*                                   TO NEXT 2K BOUNDARY
         OR    RUBRND,RWORK1
         XR    RUBRND,RWORK1       RUBRND CONTAINS UPPER BOUND OF FQE
*                                   ROUNDED DOWN TO PREVIOUS 2K BOUND.
         LR    RSIZE,RUBRND
         SR    RSIZE,RFQRND
         BC    NP,FCOMRET          NO 2K BLOCKS TO BE RELEASED
         SPACE
*        DETERMINE NUMBER OF 2K BLOCKS TO BE RELEASED, BLOCK NUMBER OF
*         FIRST BLOCK TO BE RELEASED, THEN TO RELEASE THE BLOCKS TO
*         THE FBQE QUEUE AND SET THE STORAGE KEYS TO ZERO
         SPACE
         ST    RPREVQE,PREVQESV
         LR    RBLOCK,RFQRND
         L     RPQE,TCBPQE(RTCB)   PICK UP ADDRESS OF PQE
LOOP2    L     RPQE,DUMBWD(RPQE)   PICK UP END OF PQE CHAIN.
         C     RADDR,PQESTADD(RPQE)  IS CORE IN THIS REGION.
         BL    LOOP2                 NO. CHECK NEXT PQE.
         AIF   (&SMF EQ 0).NOTSTCB                                  SMF
         ST    RTCB,SMFTCBSV           SAVE TCB POINTER             SMF
.NOTSTCB ANOP                                                       SMF
         LR    RFQE1,RFQE          SAVE FQE ADDRESS
         ST    RAREAUB,AREAUBSV    SAVE AREA UPPER BOUND
         MVC   FQESAVE(FQNXTFLD),FQEOFSET(RFQE1) SAVE FQE PTR
FCOMMON3 BAL   RCOMRET1,MRELEASE   RELEASE 2K BLOCKS
         SR    RWORK1,RWORK1
         LR    RIN0,RSIZE
         LR    RIN1,RBLOCK
         SRL   RIN0,11             NUMBER OF 2K BLOCKS
         BAL   RCOMRET1,MSETKEYS   SET KEYS OF RELEASED BLOCKS TO ZERO
         L     RAREAUB,AREAUBSV
         SPACE
*        DETERMINE WHETHER ALL OF SPACE DESCRIBED BY DQE IS FREE AND,
*         IF SO, TO FREE THE SPACE USED BY THE DQE AND REMOVE THE DQE
*         FROM THE QUEUE
         SPACE
         L     RPREVDQ,PREVDQSV    PICK UP ADDRESS OF PREVIOUS DQE
         L     RDQE,DQENXT(RPREVDQ) PICK UP ADDRESS OF DQE
         N     RDQE,CLHIBYTE   CLEAR OUT HI ORDER BYTE          SA66492
         L     RDQESIZ,DQELNTH(RDQE) PICK UP SIZE
FDQECMPR CR    RDQESIZ,RSIZE IS STORAGE DESCRIBED BY DQE ALL FREE 20021
         BNE   DQENDFCH            NO IF TAKEN
         MVC   DQENXT+PTROFST(ADRLNTH,RPREVDQ),DQENXT+PTROFST(RDQE)
*                                  THE ABOVE INSTRUCTION REMOVES THE
*                                   DQE FROM THE QUEUE
         LA    RADDR,0(RDQE)
         LA    RLENGTH,16
         SPACE
*        FREE SPACE USED FOR DQE
         SPACE
         AIF   (&TSO NE 1).M138900                                M1389
FREEDQE  L     RSPQE,SQSBOUND .     LOAD SQS+1 ADDRESS            M1389
         LA    RSPQE,0(RSPQE) .     ZERO HIGH ORDER BYTE          M1389
         CR    RADDR,RSPQE .        IS AQE IN SQS                 M1389
.M138900 ANOP                                                     M1389
         LA    RSPQE,SQESPQE .      LOAD SQS SPQE                 M1389
         AIF   (&TSO NE 1).TSO1800                                20021
         BL    FREEDQE1            YES, USE SQS SPQE              20021
         BAL   RCOMRET1,GETLSQS    GET LSQS SPQE IF TIME-SHRNG    20021
FREEDQE1 EQU   *                                                  20021
.TSO1800 ANOP                                                     20021
         LA    RSPID,255           INDICATE SUPERVISOR SUBPOOL
         LA    RERROR,GERRCODE     SET UP ERROR CODE REGISTER      LC0A
         B     FCOMMON2            FREE SPACE USED FOR DQE
         SPACE
*        DETERMINE WHETHER SPACE AT UPPER END OF AREA DESCRIBED BY DQE
*         IS FREE AND, IF SO, TO CHANGE THE NUMBER OF BLOCKS IN THE DQE
*         AND TO CHANGE THE LENGTH IN THE FQE
         SPACE
DQENDFCH LR    RSIZE2,RSIZE        SAVE NUMBER OF BLOCKS
         L     RDQEUB,DQEADDR(RDQE) PICK UP BLOCK ADDRESS
         AIF   ('&LCS' NE 'Y').LC25                                LC0A
         LA    RDQEUB,0(RDQEUB)    CLEAR HIERARCHY IDENT           LC0A
.LC25    ANOP                                                      LC0A
         AR    RDQEUB,RDQESIZ      UPPER BOUND OF DQE
         CR    RDQEUB,RUBRND       IS UPPER END OF AREA DESCRIBED BY
*                                   DQE FREE
         BNE   DQBEGFCH            NO IF TAKEN
         L     RDQESIZ,DQELNTH(RDQE) PICK UP NUMBER OF BYTES
         SR    RDQESIZ,RSIZE2      COMPUTE NUMBER OF BYTES FOR DQE
         ST    RDQESIZ,DQELNTH(RDQE) CHANGE NUMBER OF BYTES IN DQE
         SR    RFQRND,RFQE1        DOES PART OF FQE REMAIN
         BC    NZ,CHNGFQE          YES IF TAKEN
         MVC   DQEFQE+PTROFST(ADRLNTH,RDQE),FQESAVE+1
*                                  THE ABOVE INSTRUCTION PUTS THE
*                                   POINTER TO THE NEXT FQE IN THE DQE
         B     FCOMRET             RETURN - 2K BLOCKS RELEASED
CHNGFQE  ST    RFQRND,FQELNTH(RFQE1) STORE NEW LENGTH IN FQE
         B     FCOMRET             RETURN - 2K BLOCKS RELEASED
         SPACE
*        DETERMINE WHETHER SPACE AT BEGINNING OF AREA DESCRIBED BY DQE
*         IS FREE AND, IF SO, TO CHANGE THE NUMBER OF BLOCKS IN THE
*         DQE, THE BLOCK NUMBER IN THE DQE, AND TO ADJUST THE FQE QUEUE
         SPACE
DQBEGFCH L     RPREVQE,PREVQESV
         CR    RDQELB,RFQE1        IS BEGINNING OF AREA DESCRIBED BY
*                                   DQE FREE
         BNE   DQMIDFRE            NO IF TAKEN
         L     RDQEBLK,DQEADDR(RDQE) PICK UP BLOCK ADDRESS
         AR    RDQEBLK,RSIZE2      COMPUTE NEW BLOCK ADDRESS
         ST    RDQEBLK,DQEADDR(RDQE) CHANGE BLOCK ADDRESS IN DQE
         L     RDQESIZ,DQELNTH(RDQE) PICK UP NUMBER OF BYTES
         SR    RDQESIZ,RSIZE2      COMPUTE NUMBER OF BYTES FOR DQE
         ST    RDQESIZ,DQELNTH(RDQE) CHANGE NUMBER OF BYTES IN DQE
         SR    RAREAUB,RUBRND      DOES PART OF FQE REMAIN
         BC    NZ,MOVEFQE          YES IF TAKEN
         ST    RAREAUB,FQENXT(RPREVQE) ZERO POINTER IN PREVIOUS FQE.
*                                       IT IS NOW LAST IN QUEUE
         B     FCOMRET             RETURN - 2K BLOCKS RELEASED
MOVEFQE  ST    RUBRND,FQENXT(RPREVQE) CHANGE POINTER IN PREVIOUS FQE TO
         MVC   FQEOFSET(FQNXTFLD,RUBRND),FQESAVE
*                                  THE ABOVE INSTRUCTION MOVES THE FQE
*                                   TO THE BEGINNING OF THE NEW FREE
*                                   AREA
         ST    RAREAUB,FQELNTH(RUBRND) STORE SIZE IN NEW FQE
         B     FCOMRET             RETURN - 2K BLOCKS RELEASED
         SPACE
*        FREE SPACE IS IN MIDDLE OF AREA DESCRIBED BY DQE.
         SPACE
*        THIS SECTION OF CODE GETS STORAGE FOR THE ADDITIONAL DQE
*         NEEDED, PUTS IT INTO THE DQE QUEUE, PUTS THE NEW NUMBER OF
*         BLOCKS INTO EACH DQE, AND PUTS THE BLOCK NUMBER INTO THE NEW
*         DQE
DQMIDFRE LA    RIN1,16             SIZE FOR DQE
         BAL   RCOMRET1,GETMAINB   GET STORAGE FOR NEW DQE
         MVC   DQENXT+PTROFST(ADRLNTH,RNEWDQE),DQENXT+PTROFST(RDQE)
*                                  THE ABOVE INSTRUCTION MOVES THE DQE
*                                   POINTER FROM THE OLD DQE TO THE NEW
*                                   DQE
         ST    RNEWDQE,DQENXT(RDQE) POINT OLD DQE TO NEW DQE
         LR    RWORK1,RDQEUB
         SR    RWORK1,RUBRND       COMPUTE SIZE OF AREA DESCRIBED BY
*                                   NEW DQE
         LA    RWORK1,0(RWORK1) .                                A39883
         ST    RWORK1,DQELNTH(RNEWDQE) PUT SIZE IN DQE
         ST    RUBRND,DQEADDR(RNEWDQE) PUT ADDRESS IN DQE
         AIF   ('&LCS' NE 'Y').LC22                                LC0A
         MVC   DQEHIID(1,RNEWDQE),DQEHIID(RDQE) INSERT HI ID  BC A50611
.LC22    ANOP                                                      LC0A
         LR    RWORK1,RFQRND
         L     RWORK3,DQEADDR(RDQE)
         SR    RWORK1,RWORK3       COMPUTE ADDRESS FOR OLD DQE
         LA    RWORK1,0(RWORK1) .   CLEAR HI ORDER BYTE          A34874
         ST    RWORK1,DQELNTH(RDQE) PUT FIRST BYTE ADDRESS IN OLD DQE
         SPACE
*        THIS SECTION OF CODE ADJUSTS THE FQE QUEUE FOR THE NEW DQE AND
*         PUTS THE POINTER TO THE QUEUE INTO THE DQE
STNEWFQE L     RWORK1,DQEFQE(RDQE) PICK UP FQE POINTER FROM OLD DQE
         LA    RWORK1,0(RWORK1)    CLEAR HIGH ORDER BYTE
         CR    RWORK1,RFQE1
         BH    MVFQEPTR            THE BRANCH WILL BE TAKEN IF A PART
*                                   OF THE OLD FQE QUEUE LIES WITHIN
*                                   THE AREA DESCRIBED BY THE NEW DQE.
*                                   OTHERWISE THE FOLLOWING INSTRUCTION
*                                   WILL CLEAR THE FQE POINTER FIELD
*                                   FROM THE NEW DQE
         XC    DQEFQE+PTROFST(ADRLNTH,RNEWDQE),DQEFQE+PTROFST(RNEWDQE)
         B     UPRREMCH
*                                  IF PART OF THE OLD FQE LIES WITHIN
*                                   THE AREA DESCRIBED BY THE NEW DQE,
*                                   IT IS THE BEGINNING OF THE OLD FQE
*                                   QUEUE AND THE FQE POINTER FROM THE
*                                   OLD DQE BECOMES THE FQE POINTER FOR
*                                   THE NEW DQE. THE NEXT INSTRUCTION
*                                   PUTS THE OLD FQE POINTER INTO THE
*                                   NEW DQE
MVFQEPTR MVC   DQEFQE+PTROFST(ADRLNTH,RNEWDQE),DQEFQE+PTROFST(RDQE)
*                                  THE NEXT FEW INSTRUCTIONS DETERMINE
*                                   THE END OF THE FQE QUEUE FOR THE
*                                   NEW DQE AND COMPLETE THIS QUEUE
UPRREMCH SR    RAREAUB,RUBRND      IS THERE A REMAINDER OF FREE AREA
*                                   ABOVE THE 2K BLOCKS BEING FREED
         BZ    STPREVFQ            NO IF BRANCH TAKEN
         XC    FQENXT(FQNXTFLD,RUBRND),FQENXT(RUBRND)            A36201
*                                      CLEAR NEW FQE PTR        A36201
         ST    RAREAUB,FQELNTH(RUBRND) .PUT LENGTH IN NEW FQE    A36201
         CR    RPREVQE,RDQE .           WAS PREV FQE A DQE      A36201
         BE    FQENEWS .                YES NEW FQE IS FIRST     A36201
         ST    RUBRND,FQENXT(RPREVQE) . PT PREV FQE TO NEW FQE   A36201
         B     STOLDFQE .                                        A36201
FQENEWS  ST    RUBRND,FQENXT(RNEWDQE) . THIS IS FIRST FQE        A36201
         B     STOLDFQE
STPREVFQ ST    RAREAUB,FQENXT(RPREVQE) CLEAR POINTER IN PREVIOUS FQE
*                                       IT IS LAST ONE IN THIS QUEUE
         SPACE
*        THIS SECTION OF CODE ADJUSTS THE FQE QUEUE FOR THE OLD DQE AND
*         PUTS THE POINTER TO THE QUEUE INTO THE DQE
STOLDFQE SR    RFQRND,RFQE1        IS THERE A REMAINDER OF FREE AREA
*                                   BELOW THE 2K BLOCKS BEING FREED
         BZ    NOLWRREM            NO IF BRANCH TAKEN
         ST    RFQRND,FQELNTH(RFQE1) YES - CHANGE LENGTH IN FQE FOR
*                                    AREA TO SIZE OF THIS REMAINDER
         ST    RFQE1,DQEFQE(RDQE)  PUT POINTER TO FQE QUEUE IN OLD DQE
         B     FCOMRET             RETURN - 2K BLOCKS RELEASED
*                                  IF THERE IS NO LOWER REMAINDER OF
*                                   FREE AREA, THE NEXT INSTRUCTION
*                                   WILL PLACE THE POINTER TO THE LOWER
*                                   PART OF THE OLD FQE QUEUE INTO THE
*                                   OLD DQE AS THE FQE QUEUE POINTER
NOLWRREM MVC   DQEFQE+PTROFST(ADRLNTH,RDQE),FQESAVE+PTROFST
         B     FCOMRET             RETURN - 2K BLOCKS RELEASED
         SPACE
*        COMMON RETURN TO MAINLINE
         SPACE
         AIF   ('&RORI' NE 'Y').GO202                              LC0A
FCOMRET  LM    RRETURN,RFMRET,FMSAVE  RESTORE REGISTERS
         LA    RFMRET,FMRET
         TM    BESW,X'FF'               WAS THIS A BRANCH ENTRY
         BCR   1,RFMRET   YES, BYPASS ROLLIN
         TM    IEAROSW,X'FF'       IS ROLLOUT DATA SET OPEN.
         BCR   1,RFMRET            NO. BYPASS ROLLIN.
         ST    RFMRET,PQERET
         L     FPQEBASE,FRBASEAD   ESTABLISH ADDRESSABILITY -
         L     RWORK1,FREBRFAD     SET UP ENTRY -
         BR    RWORK1              AND TEST FOR ROLLIN CONDITIONS
FMRET    LM    RRETURN,RFMRET,FMSAVE   RESTORE REGISTERS.
         XC    ABNDATA(ABNDATAL),ABNDATA CLEAR MSG SWITCHES       21016
         BR    RFMRET                  RETURN TO CALLER
         AGO   .GO203
.GO202   ANOP
FCOMRET  LM    RRETURN,RFMRET,FMSAVE  RESTORE REGISTERS
         BR    RFMRET              RETURN
.GO203   ANOP
SUBPERR  L     RADDR,0(RADDR)  FREEMAIN ADDRESS                   21016
         MVI   MSGLEN,X'4C'        REASON CODE(2) AND LENGTH(12)  21016
         ST    RTCB,ABNDATA         STORE TCB SEARCHED            21016
         B     GERROR3                                            21016
         EJECT
*        ROUTINE TO LOCATE AN FQE EQUAL TO OR LESS THAN A GIVEN ADDRESS
*           INPUT REGISTERS
*              RDQE   - DQE ADDRESS
*              RWORK1 - GIVEN ADDRESS
*           OUTPUT REGISTERS
*              RQE     - REQUESTED QUEUE ELEMENT ADDRESS
*              RPREVQE - ADDRESS OF QUEUE ELEMENT PREVIOUS TO REQUESTED
*                         QUEUE ELEMENT
         SPACE
QELOCATE LR    RPREVQE,RDQE        SAVE ADDRESS OF PREVIOUS QE
         L     RQE,FQENXT(RPREVQE) PICK UP QE PTR
         LA    RQE,0(RQE)          CLEAR OUT BLOCK NUMBER
FADVQE   CR    RQE,RAREAUB         IS IT REQUESTED QUEUE ELEMENT  20021
         BCR   13,RCOMRET1         YES - RETURN
         LR    RPREVQE,RQE         SAVE ADDRESS OF PREVIOUS QE
         TM    FQENXT+3(RPREFQE),7 DOES NEXT FQE SPECIFY DOUBLE WORD
         BC    7,BADFQE            NO - FQE DESTROYED             21016
         L     RQE,FQENXT(RPREVQE) PICK UP QE PTR
         LA    RQE,0(RQE)          CLEAR HIGH ORDER BYTE (IF DESTROYED
*                                   BY PROBLEM PROGRAM)
         CR    RQE,RPREFQE         IS FQE LESS THAN PREVIOUS FQE
         BL    FADVQE              YES
         B     BADFQE                                             21016
         SPACE 2
*        PART OF ROUTINE TO PUT FREE STORAGE INTO THE QUEUE AND TO
*         COMBINE ADJOINING FREE AREAS
         SPACE
*        UPPER AREA NOT ADJACENT
         SPACE
FQENDTST LTR   RQE,RQE             IS IT END OF QUEUE
         BC    7,FCHOVRLP          NO - CHECK FOR OVERLAP
         SPACE
*        LOWER AREA NOT ADJACENT
         SPACE
FQREPAIR ST    RQE,FQENXT(RADDR)   POINTER TO NEXT QE IN NEW FQE
         LR    RQE,RADDR           QE POINTER TO NEW QE
         B     FCOMPRPR            TO COMPLETE REPAIR OF QUEUE
         SPACE 2
*        THIS ROUTINE SETS THE STORAGE KEYS OF A NUMBER OF CONSECUTIVE
*         BLOCKS
*           INPUT REGISTERS
*              RWORK1 - KEY IN BITS 24 - 27
*              RIN0   - NUMBER OF 2K BLOCKS
*              RIN1   - ADDRESS OF FIRST 2K BLOCK
         SPACE
MSETKEYS SSK   RWORK1,RIN1         SET STORAGE KEY
         LA    RIN1,TWOK(RIN1)     INCREMENT TO NEXT BLOCK
         BCT   RIN0,MSETKEYS       COUNT DOWN NUMBER OF BLOCKS
* FREEMAIN NO LONGER DOES SMF PROCESSING DUE TO PTF 00110
         BR    RCOMRET1            RETURN
         SPACE 2
         EJECT
***********************************************************************
*        SUBROUTINES COMMON TO GETMAIN AND FREEMAIN
***********************************************************************
         SPACE 2
*
*        SUBROUTINE TO DETERMINE SUBPOOL REQUEST AND TO GET SPQE FOR
*              REQUESTED SUBPOOL
*           INPUT
*              RTCB  - TCB OF REQUESTING TASK
*              RSPID - SUBPOOL ID REQUESTED
*           OUTPUT
*              RSPQE - SPQE ADDRESS
*              RSPID - IS COMPLEMENTED IF REQUEST IS FOR SP253 OR 254
*              RLENGTH- IS INCREMENTED BY 8 IF SPID IS 253 OR 254
CSPCHK   LA    RWORK2,128
         AIF   (&TSO NE 1).TSO2000                                20021
         MVI   LSQSSW,LSQSOFF          CLEAR LSQS SWITCH          20021
.TSO2000 ANOP                                                     20021
         SR    RWORK2,RSPID
         BP    PGETSPQE            PROBLEM PROGRAM SUBPOOL REQUESTED
*        DETERMINE WHICH SUPERVISOR SUBPOOL IS REQUESTED
         AIF   (&TSO NE 1).TSO2100                                20021
         TM    TCBTSFLG(RTCB),TCBTSTSK TIME-SHARING TASK?         20021
         BZ    *+8                                                20021
         MVI   LSQSSW,LSQSMSK          YES-SET LSQS SWITCH        20021
.TSO2100 ANOP                                                     20021
         LA    RWORK2,243                                         20021
         SR    RWORK2,RSPID        IS REQUEST FOR A SUPERVISOR
         LCR   RWORK2,RWORK2        SUBPOOL LESS THAN 243?        20021
         BM    GERRB               YES - INVALID SUBPOOL          21016
         SLL   RWORK2,2
         TM    MODEBYTE,X'F0'      IS REQUESTOR IN KEY OF ZERO
         BZ    TABLE(RWORK2)       DETERMINE REQUESTED SUBPOOL
         TM    MODEBYTE,1              IS REQUESTOR IN SUPVR MODE  699
         BZ    TABLE(RWORK2)           DETERMINE REQUESTED SUBPOOL 699
GERRB    L     RADDR,0(RADDR)                                     21016
         MVI   MSGLEN,X'04'       SET REASON CODE(0) AND LENGTH(4)21016
         CLI   SVCBYTE,X'05'      IS IT SVC 5 ?                   21016
         BNE   GERROR11           IF NOT SVC 5 MSGLEN = X'04'     21016
         MVI   MSGLEN,X'08'       FOR SVC 5, MSGLEN = 8           21016
         B     GERROR11            NOT KEY OF ZERO - ERROR
         SPACE
TABLE    B     SP243                                              20021
         B     SP244                                              20021
         B     SP245                                              20021
         B     PART                                               20021
         B     PART
         AIF   ('&RORI' NE 'Y').LC13                               LC0A
         B     PART                                                LC0A
         AGO   .LC14                                               LC0A
.LC13    ANOP                                                      LC0A
         B     GERRB .            INVALID SUBPOOL            BL   M1536
.LC14    ANOP                                                      LC0A
         B     GERRB .            INVALID SUBPOOL            BL   M1536
         B     SP250
         B     SP251
         B     SP251
         B     SP253
         B     SP254
         B     SP255
*
SP245    LA    RSPID,10(RSPID)          CHANGE SP NUMBER TO SQS   20021
SP243    EQU   SP245                                              20021
SP244    EQU   SP245                                              20021
         AIF   (&TSO NE 1).TSO2200                                20021
         MVI   LSQSSW,LSQSOFF          FORCE ALLOCATION FROM SQS  20021
.TSO2200 ANOP                                                     20021
         LA    RWORK2,40(RWORK2)       CHANGE BRANCH TABLE DIS-   20021
*                                      PLACEMENT TO SUBPOOL 253,  20021
*                                      254, OR 255.               20021
         B     TABLE(RWORK2)           BRANCH TO PROCESS REQUEST  20021
*                                                                 20021
*
*        SUBPOOL 250 - SYNONYM FOR SUBPOOL ZERO
*
SP250    SR    RSPID,RSPID
         B     GETSPQE
*
*        SUPERVISOR REQUEST FOR PP STORAGE - CONVERT TO SP 252
*
SUPVPPSP TM    MODEBYTE,2
         BC    1,GETSPQE
         LA    RSPID,252
*
*        SUBPOOL 251 - GET JOB STEP TCB ADDRESS (JOB PACK AREA SUBPOOL)
*        ALSO SUBPOOL 252 (LINK PACK AREA WITHIN PARTITION)
*
SP251    L     RTCB,TCBJSTCB(RTCB) PICK UP ADDRESS OF JOB STEP TCB
         B     GETSPQE
*
*        SUBPOOL 254 - GET JOB STEP TCB ADDRESS
*
SP254    L     RTCB,TCBJSTCB(RTCB) PICK UP ADDRESS OF JOB STEP TCB
*
*        SUBPOOL 253 - COMPLEMENT SPID TO INDICATE AQE NEEDED
*
SP253    LCR   RSPID,RSPID
*
*        SUBPOOL 255 - LOAD ADDRESS OF SPQE FOR SUPERVISOR CORE
*                         (ALSO FOR SP253 AND SP254)
SP255    LA    RSPQE,SQESPQE
*
*BEFORE RETURNING TO MAINLINE, THIS ROUTINE WILL DETERMINE WHETHER SWS
*THE TCB READY QUEUE SHOULD BE SCANNED FOR ANY TASKS WHICH ARE     SWS
*NON-DISPATCHABLE BECAUSE THE 2K LIMIT ON QUEUE SPACE HAD BEEN     SWS
*REACHED.  IT WILL PROCEED AS FOLLOWS                              SWS
*DETERMINE IF THE REQUEST IS A FREEMAIN.  AT THIS POINT WE         SWS
*ALREADY KNOW THAT THE REQUEST PERTAINS TO QUEUE SPACE.            SWS
*IF THIS IS A REQUEST TO FREE QUEUE SPACE, THE HIGH ORDER BYTE     SWS
*OF GOB GOVRFLB WILL BE EXAMINED                                   SWS
*IF THE FLAG IS ZERO, THIS ROUTINE WILL RETURN TO MAINLINE         SWS
*IF IT IS NON-ZERO, IT MEANS ONE OR MORE TASKS ARE NON-DISPATCHABLESWS
*BECAUSE OF THE 2K LIMIT ON QUEUE SPACE.  THEREFORE, THIS ROUTINE WILL
*BALR TO A SUBROUTINE WITHIN GETPART/FREEPART CALLED  DISPINIT     SWS
*TO MAKE THESE TASKS DISPATCHABLE AND RESET THE FLAG IN GOVRFLB    SWS
*TO ZERO.                                                          SWS
*THE  DISPINIT  SUBROUTINE WILL SAVE ALL THE XRS ON ENTRY.         SWS
         TM    GOVRFLB,X'80'      IS THE TRIGGER SET               SWS
         BZ    OK                 NO                               SWS
*        FALL THRU HERE MEANS 2K LIMIT IS IN EFFECT AND ONE OR     SWS
*        QUEUE SPACE (SVC 10,SVC 5, OR BRANCH ENTRY )              SWS
*        MORE TASKS ARE NON-DISPATCHABLE.                          SWS
         CLI   SVCBYTE,4          IS THIS A GETMAIN REQUEST - SVC 4SWS
         BE    OK                 YES                              SWS
         LTR   RIN1,RIN1          IS THIS A GETMAIN REQUEST - SVC 1SWS
         BM    OK                 YES                              SWS
         AIF   (&TSO NE 1).TSO2250                                20021
*        FREEMAIN REQUESTS FOR LSQS HAVE NO EFFECT ON SQS.        20021
         TM    LSQSSW,LSQSMSK                                     20021
         BO    OK                                                 20021
.TSO2250 ANOP                                                     20021
*        FALL THRU HERE MEANS REQUEST IS A FREEMAIN FOR            SWS
*        AND THE 2K LIMIT IS IN EFFECT.                            SWS
         LR    RIN15,RCOMRET1     SAVE VOLATILE XRS                SWS
         LR    RWORK2,RADDR                                        SWS
         L     RADDR,ADPART       LOAD BASE XR FOR GETPART         SWS
         L     RCOMRET1,ADDISP    LOAD ADDR FOR BALR               SWS
         BALR  RCOMRET1,RCOMRET1  LINK TO SUBROUTINE WITHIN GETPARTSWS
         LR    RADDR,RWORK2       RESTORE VOLATILE XRS             SWS
         LR    RCOMRET1,RIN15                                      SWS
OK       DS    0H                                                  SWS
         AIF   (&TSO NE 1).TSO2300                                20021
         TM    LSQSSW,LSQSMSK          LSQS REQUESTED?            20021
         BZ    4(RCOMRET1)             NO-RETURN                  20021
         L     RSPQE,TCBPQE(RTCB)      YES-LOAD LSQS SPQE         20021
         L     RSPQE,PQENXT(RSPQE)                                20021
         L     RSPQE,PQESTADD(RSPQE)                              20021
.TSO2300 ANOP                                                     20021
         BC    15,4(RCOMRET1)      RETURN-SPQE FOUND
*
*        FIND SUBPOOL QUEUE ELEMENT FOR PROBLEM PROGRAM SUBPOOLS
*              AND FOR SUBPOOL 250 AND 251
*              TEMPORARILY FOR SP128 ALSO                         *****
*
PGETSPQE TM    MODEBYTE,1              IS REQUESTOR IN SUPVR MODE  699
         BO    GETSPQE                 NO                          699
         TM    MODEBYTE,X'F0'          IS REQUESTOR IN KEY OF ZERO 699
         BZ    SUPVPPSP                YES, DETERMINE SUBPOOL      699
GETSPQE  L     RSPQE,TCBMSS(RTCB)  LOAD FIRST SPQE FOR TASK
         LA    RSPQE,0(RSPQE)
         AIF   (&TSO NE 1).TSO2350                                20021
         MVI   LSQSSW,LSQSOFF      NOT LSQS REQUEST. RESET SWTCH  20021
.TSO2350 ANOP                                                     20021
         LTR   RSPQE,RSPQE         RETURN NOT FOUND IF           ******
         BCR   8,RCOMRET1             SPQE PTR IS ZERO           ******
         SR    RWORK2,RWORK2
GETSPQE1 IC    RWORK2,SPQEID(RSPQE)     CHECK IF ID OF SPQE
         CR    RWORK2,RSPID           IS REQUESTED SPID
         BE    GETSPQE2                 YES-BRANCH-CHECK IF SP SHARED
         TM    SPQEFLGS(RSPQE),SPQELAST IS THIS LAST SPQE
         BCR   1,RCOMRET1               YES-RETURN-SPQE NOT FOUND
         L     RSPQE,SPQENXT(RSPQE)     LOAD NEXT SPQE
         B     GETSPQE1
*
GETSPQE2 TM    SPQEFLGS(RSPQE),SPQESHRD  IS SUBPOOL SHARED
         BC    8,4(RCOMRET1)       NO-RETURN-OWNING SPQE FOUND
         L     RSPQE,SPQEDQE(RSPQE)  LOAD OWNING  SPQE
         BC    15,4(RCOMRET1)      RETURN-SPQE FOUND
         EJECT
*        GETMAIN FOR AN MSS QUEUE ELEMENT
*           INPUT - RIN1- LENGTH OF REQUEST
*           OUTPUT-RIN1- ADDRESS OF ASSIGNED CORE
*           REGISTERS USED - RIN1,RIN0,RLENGTH,RSPQE,RCOMRET1,RCOMRET2
*
*
GETMAINB STM   RLST,RIN1,SAVREG2
         LR    RLENGTH,RIN1
         L     RMASK,CLHIBYTE
GMBREPET LA    RSPQE,SQESPQE       LOAD SPQE FOR SUPERVISOR
         AIF   (&TSO NE 1).TSO2400                                20021
         BAL   RCOMRET1,GETLSQS -  GET LSQS SPQE IF TIME-SHRNG    20021
NOSQSPC1 LA    RSPID,255 -         SUBPOOL ID FOR MSS QUEUE ELE   20021
         AGO   .TSO2405                                           20021
.TSO2400 ANOP                                                     20021
         LA    RSPID,255 -         SUBPOOL ID FOR MSS QUEUE ELE   20021
.TSO2405 ANOP                                                     20021
         AIF   ('&LCS' NE 'Y').LC26                                LC0A
         MVC   HISAVE(1),HIBYTE    SAVE HIBYTE OVER GETMAINB RTN.  LC0A
         MVI   HIBYTE,0            RESET HIERARCHY IDENT           LC0A
.LC26    ANOP                                                      LC0A
         BAL   RCOMRET1,GFRECORE   SEARCH FOR FREE AREA
         B     NOSQSPC2            NOT FOUND
         BAL   RCOMRET1,GFQEUPDT   FOUND-REMOVE ASSIGNED CORE FROM FQE
         LR    RIN1,RFQE           LOAD ADDR OF ASSIGNED AREA
         BCTR  RLENGTH,0           DECREMENT LENGTH TO CLEAR CORE
         EX    RLENGTH,CLRCORE     CLEAR QUEUE ELEMENT SPACE
         LM    RLST,RIN0,SAVREG2
         AIF   ('&LCS' NE 'Y').LC27                                LC0A
         MVC   HIBYTE(1),HISAVE    RESTORE HIERARCHY IDENT         LC0A
.LC27    ANOP                                                      LC0A
         BR    RCOMRET1            RETURN
         AIF   (&TSO NE 1).TSO2410                                20021
NOSQSPC2 TM    LSQSSW,LSQSMSK -    LSQS FAIL                      20021
         BO    NOSQSPC3 -          YES, CANNOT GET MORE LSQS      20021
         BAL   RCOMRET1,GNOTSAT3 - ATTEMPT TO GET MORE SQ SPACE   20021
NOSQSPC3 MVI   LSQSSW,LSQSOFF -    RE SET LSQS SWITCH             20021
         LA    RSPQE,SQESPQE -     LOAD SPQE FOR SUPERVISOR       20021
         B     NOSQSPC1 -          REPEAT REQUEST                 20021
         AGO   .TSO2415                                           20021
.TSO2410 ANOP                                                     20021
NOSQSPC2 BAL   RCOMRET1,GNOTSAT3   ATTEMPT TO GET MORE SQ SPACE
         B     GMBREPET            REPEAT REQUEST
.TSO2415 ANOP                                                     20021
*
*
CLRCORE  XC    0(0,RIN1),0(RIN1)
         EJECT
*        ROUND UP REQUESTED LENGTH TO DOUBLE WORD BOUNDRY
*           INPUT - RLENGTH - REQUESTED LENGTH
*           OUTPUT- RLENGTH - ROUNDED LENGTH
*           REGISTERS USED - RLENGTH,RWORK2,RCOMRET1
*
CRNDLNTH LA    RWORK2,7
         AR    RLENGTH,RWORK2
         OR    RLENGTH,RWORK2
         XR    RLENGTH,RWORK2
         LTR   RSPID,RSPID         IF SUBPOOL 253 IS REQUESTED
         BCR   11,RCOMRET1
         LA    RLENGTH,8(RLENGTH)  ADD 8 BYTES TO LENGTH FOR AQE
         BR    RCOMRET1
         AIF   (&TSO NE 1).TSO2500                                20021
*                                                                 20021
*        GET LSQS SPQE IF THE CALLING TASK IS A TIME-SHARING      20021
*        TASK.                                                    20021
GETLSQS  L     RSPID,16(0) -       GET TCB ADDRESS                20021
         L     RSPID,0(RSPID) -    *                              20021
         L     RSPID,4(RSPID) -    *                              20021
         TM    TCBTSFLG(RSPID),TCBTSTSK - TIME SHARING TASK       20021
         BCR   8,RCOMRET1 - (BZ)   NO, RETURN                     20021
         L     RSPID,TCBPQE(RSPID) GET PQE ADDRESS                20021
         L     RSPID,PQENXT(RSPID) *                              20021
         L     RSPQE,PQESTADD(RSPID) GET LSQS SPQE ADDRESS        20021
         MVI   LSQSSW,LSQSMSK -    SET LSQS SWITCH                20021
         BR    RCOMRET1 -          RETURN                         20021
         EJECT                                                    20021
.TSO2500 ANOP                                                     20021
*
*
*
*
*        INPUT PARAMETERS VALIDITY CHECK ROUTINE
*           INPUT - RIN1 -ADDR OF PARAMETER LIST
*           OUTPUT- RLENGTH - LENGTH/ADDR OF LENGTH LIST
*                 - RADDR   - ADDR OF AREA LIST
*
*
IEAQVLCH CSECT
IPVALCHK BALR  IPVLBASE,0          SET UP BASE REGISTER
         USING *,IPVLBASE
         TM    MODEBYTE,X'F0'     IS CALLER IN KEY ZERO
         LA    RERROR,GERRCODE     SET UP ERROR CODE REGISTER      LC0A
         ST   FREBAS,SAVE3BAS .    SAVE ALTERNATE BASE REG        M0550
         BZ    IPVLRET1                 RETURN
         SR    RSPID,RSPID         . CLEAR REG                 @SA78437
         L     RWORK2,4(RIN1)      . GET ADDRS OF AREA LIST    @SA78437
         LA    RLENGTH,X'10'       . PUT X'FFFFFFF0' IN        @SA78437
         LCR   RLENGTH,RLENGTH     . RLENGTH FOR AND OF RWORK2 @SA78437
         NR    RWORK2,RLENGTH      . ZERO BITS 28-31           @SA78437
         ISK   RSPID,RWORK2        . GET PROTECT KEY OF PARMADR@SA78437
         SR    RWORK2,RWORK2       .                           @SA78437
         IC    RWORK2,MODEBYTE     . GET PROTECT KEY OF TASK   @SA78437
         NR    RWORK2,RLENGTH      .                           @SA78437
         CR    RSPID,RWORK2        . PROTECT KEYS MUST MATCH   @SA78437
         BNE   BADPARM             .                           @SA78437
         TM    7(RIN1),X'03'       . WORD BOUNDARY CHECK       @SA78437
         BNZ   BADPARM             .                           @SA78437
         B     PARMSOK             .                           @SA78437
BADPARM  EQU   *                                               @SA78437
         LR    RSPID,RIN1          . GET BAD PARM ADDRESS      @SA78437
         B     PARMERR             . ERROR GET OUT             @SA78437
PARMSOK  EQU   *                                               @SA78437
         LA   RGMRET,PARMERR                                      21016
         LR    RSPID,RIN1          SAVE INPUT REG
         L     RVALBAS,VALIDCHK    ADDRESS OF VALIDITY CHECK RTN.  TS0A
         L     FREBAS,16(,0) .     PICK UP CVT ADDR               M0550
         BAL   RVALRET,4(RVALBAS)  CHECK PARAMETER LIST ADDR
         L     FREBAS,SAVE3BAS .       RESTORE SEC BASE           M2752
         BCR   7,RGMRET .              RETURN                     M2752
*
         L     RIN1,4(RSPID)       CHECK AREA LIST STARTING ADDRESS
         AIF   ('&LCS' NE 'Y').LC08                                LC0A
         LA    RIN1,0(RIN1)        CLEAR HIERARCHY IDENT           LC0A
.LC08    ANOP                                                      LC0A
         BAL   RVALRET,TSTALIN    ALIGNMENT & IN MACHINE       @JK69031
         AIF   ('&LCS' NE 'Y').LC09                                LC0A
*                                                                  LC0A
         CLI   HIBYTE,X'01'        Q. IS REQUEST FOR A HIERARCHY   LC0A
         BH    GERROR12               GREATER THAN 1 - YES - ERROR LC0A
.LC09    ANOP                                                      LC0A
*
         TM    8(RSPID),X'C0'      IF REQUEST IS FOR A SINGLE AREA
         BZ    IPVALRET              RETURN
         BO    FREEVAR             VARIABLE REQUEST
*
LENCHK   L     RIN1,0(RSPID)       CHECK LENGTH LIST STARTING ADDRESS
         BAL   RVALRET,TSTALIN    ALIGNMENT & IN MACHINE       @JK69031
*
         LM    RLENGTH,RADDR,0(RSPID)
         TM    8(RSPID),X'C0'      IF REQUEST IS VARIABLE,
         BO    IPV1                 CONTINUE
         TM    0(RLENGTH),X'80'    IF ENTRY IS NOT LAST ON LIST
         BZ    IPV1                 CONTINUE
         LA    RWORK2,4            LENGTH OF LIST
         B     IPVLOVLP            SINGLE ENTRY IN LIST REQUEST
IPV1     SR    RWORK2,RWORK2
         SPACE
IPV2     LA    RWORK2,4(RWORK2)    INCREMENT COUNT OF ENTRIES
*
         LA    RIN1,0(RWORK2,RLENGTH)   CHECK LENGTH LIST ENTRY
         BAL   RVALRET,INMACH      ADDR IN MACHINE             @JK69031
*
         LA    RIN1,0(RWORK2,RADDR)     CHECK AREA LIST ENTRY
FREEVAR1 EQU   *                                                  M2752
         L     FREBAS,16(0)  PICK UP THE CVT ADDRESS              20021
         BALR  RVALRET,RVALBAS                                    20021
         L     FREBAS,SAVE3BAS .       RESTORE SEC BASE           M2752
         BCR   7,RGMRET .              RETURN                     M2752
*
         TM    8(RSPID),X'C0'      IF REQUEST IS VARIABLE, ALL ENTRIES
         BO    IPVALRET            OMIT CHECK FOR OVERLAP FOR VARIABLE
*
         LA    RIN1,0(RWORK2,RLENGTH)
         TM    0(RIN1),X'80'       IF ENTRY IS NOT LAST ON LIST
         BZ    IPV2                  CHECK NEXT ENTRY
         SPACE
IPVLOVLP SR    RLENGTH,RADDR       GET NUMBER OF BYTES BETWEEN
         BC    11,IPVL3             STARTING ADDRESSES OF LISTS
         LCR   RLENGTH,RLENGTH
IPVL3    SR    RLENGTH,RWORK2      GREATER THAN LENGTH OF LIST
         BNM   IPVALRET                                           21016
         LR    RLENGTH,RSPID       SET BAD PARM ADDR AS INPUT REG 21016
         SR    RSPID,RSPID                                        21016
         MVI   MSGLEN,X'04'        LENGTH OF VARIABLE DATA        21016
         B     GERROR5             NO - ERROR LISTS OVERLAP       21016
IPVALRET LR    RIN1,RSPID          RESTORE PARAMETER REG
IPVLRET1 LM    RLENGTH,RADDR,0(RIN1)    LOAD ADDRS OF LENGTH & AREA LST
         SR    RSPID,RSPID
         IC    RSPID,SPID(RIN1)    LOAD SUBPOOL ID
         STC   RSPID,SPIDSAV .      SAVE SPID                    A32912
         BR    RCOMRET1            RETURN
FREEVAR  LA    RCOMRET1,0(RCOMRET1) CLEAR HIGH ORDER BYTE
         CLI   SVCBYTE,5           IS IT VARIABLE FREEMAIN
         BNE   LENCHK              NO - CONTINUE
         L     RADDR,4(RSPID)      YES
         LA    RIN1,4(RADDR)       VALIDITY CHECK SECOND ENTRY IN LIST
         B     FREEVAR1             AND RETURN
PARMERR  LR    RLENGTH,RSPID      SET BAD PARM ADDR AS INPUT REG  21016
         SR    RSPID,RSPID                                        21016
         MVI   MSGLEN,X'24'     LENGTH AND REASON CODE            21016
         B     GERROR6                                            21016
TSTALIN  EX    RIN1,WDTEST         ON FULL WORD BOUNDARY       @JK69031
         BCR   5,RGMRET            NO                          @JK69031
INMACH   L     FREBAS,16           GET CVT     M2752           @JK69031
         LA    RIN1,0(RIN1)                                    @JK69031
         CL    RIN1,164(FREBAS)    ADDR WITHIN MACHINE         @JK69031
         L     FREBAS,SAVE3BAS     RESTORE 2ND BASE  M2752     @JK69031
         BCR   2,RGMRET            NO                          @JK69031
         BR    RVALRET                                         @JK69031
SAVE3BAS DC    1F'0'                                              20021
WDTEST   TM    WORD,X'00'          BOUNDARY ALIGNMENT          @JK69031
WORD     DC    X'03'                                           @JK69031
         DROP  IPVLBASE
IEAQGM00 CSECT
         SPACE 5
*        VALIDITY CHECK FQE AND PREVIOUS FQE ADDRESSES
*        INPUT - RFQE - ADDRESS OF FQE
*                RPREFQE - ADDRESS OF PREVIOUS FQE
*        OUTPUT- NONE
*        REGISTERS USED -RERROR,RCOMRET2,RVALBAS,RVALRET,RIN1,RFQE,
*                        RPREFQE,RCVT,RTCB,
*
*
CFQECHK  ST    RDQE,DQESAVE        SAVE DQE ADDRESS ACROSS CFQECHK
         L     RWORK4,DQEADDR(RDQE) PICK UP BLOCK ADDRESS
         AIF   ('&LCS' NE 'Y').LC28                                LC0A
         LA    RWORK4,0(RWORK4)    CLEAR HIERARCHY IDENT           LC0A
.LC28    ANOP                                                      LC0A
         L     RWORK6,DQELNTH(RDQE) PICK UP BLOCK SIZE
         AR    RWORK6,RWORK4       COMPUTE UPPER BOUND OF DQE AREA
         LTR   RFQE,RFQE           IS Q ELEMENT ZERO
         BZ    FQEZERO             YES - BYPASS FQETEST
         CR    RFQE,RWORK4         IS FQE WITHIN DQE BOUNDS
         BL    BADFQE              NO - FQE QUEUE DESTROYED       21016
         CR    RFQE,RWORK6
         BNL   BADFQE              NO - FQE QUEUE DESTROYED       21016
         CLI   4(RFQE),X'00' .          HI-ORDER BYTE VALID   BC A45998
         BNE   BADFQE .            NO- INVALID FQE (60A)      BL  M1723
         TM    7(RFQE),X'07' .     BOUNDARY ALIGNMENT OK      BC A45998
         BC    7,BADFQE .           NO- INVALID FQE (60A)     BL  M1723
         CLI   0(RFQE),X'00' .     HI ORDER BYTE VALID FOR NEXT
         BNE   BADFQE .            NO- INVALID FQE
         TM    3(RFQE),X'07' .     DOUBLEWORD ALIGNMENT FOR NEXT
         BC    7,BADFQE .          NO- INVALID FQE
         ST    RFQE,RFQESAVE .                                BC A45998
         A     RFQE,4(RFQE) .      IS FQE LENGTH              BC A45998
         CR    RFQE,RWORK6 .       WITHIN DQE BOUNDS          BC A45998
         BH    FQEBAD .            NO LENGTH IS BAD
         L     RFQE,RFQESAVE .     RESTORE FQE ADDRESS          SA57395
         L     RFQE,0(RFQE) .      GET NEXT FQE
         LTR   RFQE,RFQE .         IS NEXT ZERO
         BZ    NFTHRCHK .          YES
         CR    RFQE,RWORK4 .       IS FQE WITHIN DQE BOUNDS
         BL    FQEBAD .            NO- INVALID FQE
         CR    RFQE,RWORK6
         BNL   FQEBAD .            NO- INVALID FQE
NFTHRCHK L     RFQE,RFQESAVE .     RESTORE PREVIOUS POINTER
*
FQEZERO  C     RPREFQE,DQESAVE     IS PREVIOUS QE A DQE
         BE    CFQERETN            YES, DO NOT CHECK PREVIOUS QE
         CR    RPREFQE,RWORK4      IS PREVIOUS FQE WITHIN DQE BOUNDS
         BL    BADFQE              NO - FQE QUEUE DESTROYED       21016
         CR    RFQE,RWORK6
         BNL   BADFQE              NO - FQE QUEUE DESTROYED       21016
CFQERETN L     RDQE,DQESAVE        RESTORE DQE ADDRESS
         BR    RCOMRET2            NO ERROR-RETURN
FQEBAD   L     RFQE,RFQESAVE .     RESTORE REAL FQE FOR
         B     BADFQE .            ABEND
         EJECT
*        RETURN FREE BLOCKS TO QUEUE OF FREE STORAGE FOR PARTITION
*        RETURN FREE PARTITIONS TO QUEUE OF UNASSIGNED STORAGE
         SPACE
*           INPUT - RBLOCK - BLOCK NUMBER OF FIRST BLOCK
*                   RSIZE  - NUMBER OF BLOCKS
*                   RPQE - ADDRESS OF PQE
*                   RCOMRET1 - RETURN REG
*           REGISTERS USED - RBLOCK,RSIZE,RCOMRET1,RCOMRET3,RFBQE,RPQE,
*                            RFBQEUB,RDISP1,RPRQE,RMASK1
         SPACE
MRELEASE ST    RSIZE,FBQESIZE(RBLOCK) PUT SIZE IN NEW FBQE
         LA    RDISP1,BCKPTR       SET UP DISPLACEMENT FOR BACK QUEUE
         LA    RMASK1,X'20'        SET MASK FOR BH
         LR    RPRQE,RPQE          INITIALIZE RPRQE
         BAL   RCOMRET3,MRELEAS1   TO ADJUST BACK POINTERS
         SR    RDISP1,RDISP1       SET UP DISPLACEMENT FOR FORWARD Q
         LA    RMASK1,X'40'        SET MASK FOR BL
         LR    RPRQE,RPQE          INITIALIZE RPRQE
         BAL   RCOMRET3,MRELEAS1   TO ADJUST FORWARD POINTERS
         LR    RBLOCK2,RBLOCK
         CR    RPQE,RPRQE          IS PREVIOUS PTR POINTING TO PQE
         BE    MRELADV             YES - NEW BLOCK IS FIRST IN QUEUE
         BAL   RCOMRET3,MRELCOMB   TO COMBINE NEW BLOCK AND PREVIOUS
*                                   BLOCK IF POSSIBLE
MRELADV  LR    RPRQE,RBLOCK        ADVANCE ALL BLOCK POINTERS
         LR    RBLOCK2,RFBQE
         L     RFBQE,FWDPTR(RFBQE)
         BAL   RCOMRET3,MRELCOMB   TO COMBINE NEW BLOCK AND NEXT BLOCK
*                                   IF POSSIBLE
         BR    RCOMRET1                 RETURN
         BR    RCOMRET1                 RETURN
         SPACE
*        THIS CODE ELIMINATES FORWARD OR BACK POINTER FROM QUEUE
*        ACCORDING TO SETTING OF RDISP1 AND RMASK
         SPACE
MRELEAS2 LR    RPRQE,RFBQE         ADVANCE PTR TO PREVIOUS BLOCK
MRELEAS1 L     RFBQE,0(RPRQE,RDISP1) ADVANCE PTR TO FOLLOWING BLOCK
         CR    RFBQE,RPQE          DOES NEW BLOCK BELONG ON END OF Q
         BE    MRELENDQ            YES
         CR    RFBQE,RBLOCK        IS THIS BLOCK WHICH FOLLOWS NEW BLK
         EX    RMASK1,MRELBR       NO - ADVANCE PTRS
MRELBR   BC    0,MRELEAS2          NO - ADVANCE PTRS
MRELENDQ ST    RFBQE,0(RBLOCK,RDISP1) POINT NEW BLOCK TO FOLLOWING BLK
         ST    RBLOCK,0(RPRQE,RDISP1) POINT PREVIOUS BLOCK TO NEW BLOCK
         BR    RCOMRET3            RETURN TO MRELEASE MAINLINE
         SPACE
*        THIS CODE CHECKS WHETHER TWO ADJACENT FREE AREAS ARE
*        CONTIGUOUS AND IF SO, COMBINES THEM AND ELIMINATES THE SECOND
*        FBQE FROM THE QUEUE
         SPACE
MRELCOMB L     RSIZE3,FBQESIZE(RPRQE) COMPUTE UPPER BOUND OF PREVIOUS
         LR    RFBQEUB,RPRQE           BLOCK
         AR    RFBQEUB,RSIZE3
         CR    RFBQEUB,RBLOCK2     ARE BLOCKS ADJACENT
         BCR   7,RCOMRET3          NO - RETURN TO MRELEASE MAINLINE
         A     RSIZE3,FBQESIZE(RBLOCK2) COMPUTE COMBINED SIZE OF BLOCKS
         ST    RSIZE3,FBQESIZE(RPRQE) PUT SIZE IN COMBINED FBQE
         ST    RFBQE,FWDPTR(RPRQE) PUT PTR TO NEXT FBQE IN COMBINED QE
         ST    RPRQE,BCKPTR(RFBQE) PUT BACK PTR TO NEW BLK IN NEXT BLK
         B     2(RCOMRET3)              RETURN TO MRELEASE MAINLINE
         EJECT
PART     EQU   *                                                  20021
         AIF   (&TSO NE 1).TSO2510                                20021
*        A GETPART OR FREEPART FOR A TIME-SHARING TASK IS         20021
*        INVALID.                                                 20021
         TM    TCBTSFLG(RTCB),TCBTSTSK  TIME-SHARING TASK?        20021
         BZ    NOTSPART           NO. CONTINUE                    20021
         SR    RIN15,RIN15        CLEAR RETURN REGISTER.          20021
         BR    RRETURN            RETURN TO CALLER.               20021
NOTSPART EQU   *                                                  20021
.TSO2510 ANOP                                                     20021
         L     RBASE1,PARTADDR
         BR    RBASE1              BRANCH TO GET-FREE PARTITION MODULE
***********************************************************************
*                        JOB PACK PURGE ROUTINE                       *
***********************************************************************
         SPACE
*           INPUT - NONE
*           OUTPUT - NONE
         SPACE 2
CDPURGE  STM   0,15,SAVEAREA       SAVE REGISTERS
         SR    RSWITCH,RSWITCH     INITIALIZE SWITCH
         L     RTCB,TCBJSTCB(RTCB) PICK UP ADDRESS OF JOB STEP TCB
         TM    TCBJPQ(RTCB),X'80'  IS PURGE FLAG IN TCB SET
         BC    8,CDRETURN          NO - RETURN
         MVI   TCBJPQ(RTCB),X'00'  CLEAR PURGE FLAG
         L     RCDE,TCBJPQ(RTCB)   GET ADDRESS OF CDE PTR
CDNEXT   LA    RCDE,0(RCDE)        CLEAR HIGH ORDER BYTE
         LTR   RCDEIN,RCDE         ANY MORE ENTRIES
         BC    8,CDRETURN          NO - RETURN - PURGE COMPLETE
CDNEXT1  L     RCDE,0(RCDE)        LOAD ADDR OF CD ENTRY
         LA    RCDE,0(RCDE)
         LTR   RCDE,RCDE           ANY MORE ENTRIES
         BZ    CDREL               NO
         TM    CDATTR(RCDE),MIN    IS IT MINOR
         BO    CDNEXT1             YES
CDREL    TM    CDATTR2(RCDEIN),REL CAN LOAD MODULE BE RELEASED
         BZ    CDNEXT              NO - CHECK NEXT ENTRY
         L     REXBAS,XCDEXBAS     SET UP BASE ADDRESS FOR CDDESTRY
         L     RRET1,XCDDSTRY      SET UP ENTRY POINT TO CDDESTRY
         LA    RSWITCH,4           INDICATE STORAGE FREED
         BALR  RRET1,RRET1         TO CDDESTRY
         BALR  RBASE,0
         USING *,RBASE
         L     RBASE,MSSADR2                                      21016
         USING MSSBASE,RBASE
         B     CDNEXT              CHECK NEXT ENTRY
CDRETURN LTR   RSWITCH,RSWITCH
         LM    0,15,SAVEAREA
         BZ    4(RRET)             IF NO STORAGE HAS BEEN FREED
         BR    RRET                IF STORAGE HAS BEEN FREED
RFQESAVE DC    F'0' .                                         BC A45998
MSSADR2  DC    A(MSSBASE)                                         21016
         EJECT
*        ERROR EXITS - TERMINATE REQUESTING TASK
*
         AIF   (&TSO NE 1).TSO2600                                20021
GERROR1  BCTR  RERROR,0 -          TASK OUT OF LSQS               20021
NOTUSED  BCTR  RERROR,0 -                                         20021
.TSO2600 ANOP                                                     20021
GERROR3  BCTR  RERROR,0            STORAGE NOT IN SPECIFIED SUBPOOL
GERROR4  BCTR  RERROR,0            PP ATTEMPTING TO FREE ALL OF SP 0
GERROR5  BCTR  RERROR,0            LENGTH LIST AND ADDRESS LIST HAVE
*                                   COMMON LOCATIONS
GERROR6  BCTR  RERROR,0            PARAMETER LIST OR FQE NOT IN PP AREA
*                                 OR INPUT LIST ADDRS NOT ON WORD BNDRY
         BCTR  RERROR,0
GERROR8  BCTR  RERROR,0            CORE UNAVAILABLE - UNCONDITIONAL
*                                   REQUEST
GERROR9  BCTR  RERROR,0            ADDR TO FREE NOT A MULTIPLE OF 8
GERROR10 BCTR  RERROR,0            AREA BEING FREED OVERLAPS A FREEAREA
GERROR11 BCTR  RERROR,0            PROB. PROG. REQUESTS SP 128-255 LC0A
GERROR12 BCTR  RERROR,0            GENERAL LCS GM ERROR CODE       LC0A
GERROR13 LR    RIN1,RERROR         TCBAQE FIELD IS ZERO            8098
*                                  INDICATES A REQUEST TO FREE SQS 8098
*                                  NOT OWNED BY REQUESTING TASK    8098
H8       EQU   *+2
         SLL   RIN1,8
         IC    RIN1,SVCBYTE
ERRF11   DS    0H                                                 21016
         L     RRETURN,SVCXT .    SET UP RETURN TO SVCXT          21016
         L     RABTERM,ABTERM                                     21016
         L     RWORK3,16(0)             GET CVT ADDR              21016
         L     RTCB,0(RWORK3)           GET OLD NEW               21016
         L     RTCB,4(RTCB)        ABTERM CURRENT TASK            21016
*
         C     RIN1,WAIT+4             E04 ABEND                  21016
         BE    ERRMSGX     YES, DO NOT BUILD INFO LIST            21016
         L     RIN15,CVTABEND(RWORK3) ADDR OF SECONDARY CVT(SCVT) 21016
         TM    SCVTFMSA(RIN15),SCVTSW1  CONDITIONAL FREEMAIN ?    21016
         BO    ERRMSGX             YES. BYPASS.                   21016
         L     RIN15,CVTQMSG(RWORK3) ADDR OF INFOLIST             21016
         L     RWORK3,0(RIN15)       ADDR END OF LIST             21016
         LA    RIN15,4(RIN15)        ADDR OF 1ST ENTRY            21016
         SR    RWORK2,RWORK2         ZERO REG FOR COMPARE         21016
         AIF   ('&RORI' NE 'Y').GOR21K                            M3872
         XC    PQESTAT(6),PQESTAT .  TURN OFF SW FOR EXIT       A36468
.GOR21K  ANOP                                                     M3872
         USING INFOLIST,RIN15                                     21016
ERRMSG1  CR    RIN15,RWORK3       ANY MORE ENTRIES TO SEARCH?     21016
         BE    ERRMSGX            NO. BYPASS SETTING INFO         21016
         C     RWORK2,INFTCB      THIS ENTRY AVAILABLE?           21016
         BE    ERRMSG2            YES. SET UP ENTRIES.            21016
         LA    RIN15,INFLEN(RIN15) NEXT ENTRY.                    21016
         B     ERRMSG1            CHECK NEXT.                     21016
*                                                                 21016
ERRMSG2  ST    RTCB,INFTCB        STORE TCB ADDRRESS              21016
         AIF   (&TSO NE 1).TSONOID                               A49808
         TM    TCBTSFLG(RTCB),TCBTSTSK  IS THIS TSO TASK?        A49808
         BZ    ERRM2              NO,BYPASS USER ID              A49808
         L     RWORK3,TCBJSCB(RTCB) GET ADDR JSCB                A49808
         LA    RWORK3,0(RWORK3) CLEAR HIGH BYTE                  A49808
         MVC   INFTJID(2),JSCBTJID(RWORK3) PUT USERID IN INFOLISTA49808
.TSONOID ANOP                                                    A49808
ERRM2    TM    BESW,X'FF'    IS THIS BRANCH ENTRY ?              A49808
         BZ    SVCENTR       MOVE VARIABLE DATA SWITCH            21016
         OI    INFFLG,INFFLG0        SET BRANCH ENTRY SW          21016
         MVC   INFBADDR(4),BRNREG       STORE RETURN ADDRESS      21016
SVCENTR  STH   RIN1,INFCC         STORE ABEND CODE                21016
         LTR   RSPID,RSPID        IS THIS SUBPOOL 253 OR 254 ?    21016
         BC    NN,ERRMSG2A        NO. CONTINUE                    21016
         LCR   RSPID,RSPID        YES. SUBPOOL WAS COMPLIMENTED.  21016
         SH    RLENGTH,H8         - LENGTH INCLUDES 8 BYTE AQE    21016
         AH    RADDR,H8           - RADDR WAS ADDR OF AQE.        21016
         CH    RIN1,H60A          CC '60A' OR '80A'?              21016
         BL    ERRMSG2A           NO.                             21016
         CH    RIN1,H80A          CC '60A' OR '80A'?              21016
         BH    ERRMSG2A           NO.                             21016
         L     RWORK3,ABNDATA     YES.                            21016
         AH    RWORK3,H8          ADDR OF AREA MUST BE INCRE-     21016
         ST    RWORK3,ABNDATA       MENTED BY LENGTH OF AQE.      21016
ERRMSG2A EQU   *                                                  21016
         ST    RLENGTH,INFVAR1    ROUNDED LENGTH                  21016
         STC   RSPID,INFVAR1      STORE SUBPOOL                   21016
         TM    FREESW,X'08'           IS THIS A FREEMAIN          21016
         BO    FREE                                               21016
         MVC   INFVAR2(8),ABNDATA       VARIABLE DATA             21016
         B     ERRMSG3                                            21016
FREE     MVC   INFVAR3(8),ABNDATA                                 21016
         ST    RADDR,INFVAR2                                      21016
ERRMSG3  MVC   INFRCL(1),MSGLEN   SET REASON CODE AND LENGTH      21016
ERRMSGX  XC    ABNDATA(ABNDATAL),ABNDATA   CLEAR LIST AND SW      21016
         L     CVTREG,16(0)                                       21016
         BR    RABTERM                                            21016
         EJECT                                                    21016
BESW     DC    X'00'                                              21016
ORGLRG   DC    F'0'               LARGEST FREECORE IN OWNED REGION21016
         AIF   ('&RORI' NE 'Y').GO40                               LC0A
IEAROSW  DC    X'00'               RO/RI DATA SET SWITCH
PQESTAT  DC    X'00'              PQE INTERROGATION SWITCH
ENTRANT  DC    X'00'              ENTRY TYPE SWITCH
CDPRGSW  DC    X'00'              AREA HAS BEEN PURGED SUCCESSFULLY SW
PQERET   DC    F'0'
.GO40    ANOP
         AIF   (&TSO NE 1).TSO2700                                20021
**************TS DATA**********                                   20021
TCBRBP   EQU   0 -                 RB ADDRS IN TCB                20021
TCBFLG1  EQU   29 -                TCB FLAGS BYTE 1               20021
TCBFLG2  EQU   30 -                STATUS FLAGS IN TCB            20021
TCBFLG3  EQU   31 -                TCB FLAGS BYTE 3               20021
TCBTSFLG EQU   148 -               TCB TIME-SHARING FLAGS         20021
TCBSTAE  EQU   160 -               TCB STAE FLAGS                 20021
TCBFA    EQU   X'80' -             ABEND IN PROGRESS BIT          20021
TCBMC    EQU   X'18' -             SET COMPLETE BITS              20021
TCBABTRM EQU   X'20' -             TASK ABTERM BIT                20021
TCBTSTSK EQU   X'80' -             TIME SHARING TASK BIT          20021
TCBSTABE EQU   X'80' -             STAE EXIT BIT                  20021
LSQSMSK  EQU   X'FF' -             MASK FOR TESTING LSQS SWITCH   20021
LSQSOFF  EQU   X'00' -             MASK FOR RESETTING LSQS SWTCH  20021
LSQSSW   DC    X'00' -             LSQS SWITCH                    20021
ABENDMSK DC    C'ABEND' .           MASK TO TEST FOR ABEND SVRB   M3872
RBEXSAVE EQU   X'60'  .            BEGIN OF EXSAVE AREA           M3872
DISP     EQU   X'28' .             DISP INTO EXT SAVE -ABEND SVRB-M3872
L5       EQU   5 .                 LENGTH OF FIVE                 M3872
RBABOPSW EQU   4 -                 NAME FIELD IN SVRB             20021
RBSTAB   EQU   10 -                STATUS FLAGS IN RB             20021
TCBJSCB  EQU   X'B4'   DISPLACEMT OF JSCB IN TCB                 A49808
JSCBTJID EQU   X'10C'  DISPLACEMT OF USERID IN JSCB              A49808
*******************************                                   20021
.TSO2700 ANOP                                                     20021
MODEBYTE DC    X'00'               KEY INDICATION
SVCBYTE  DC    X'00'               SVC INDICATION
         AIF   ('&LCS' NE 'Y').LC10                                LC0A
HIBYTE   DC    X'00'               HIERARCHY IDENT SAVE AREA       LC0A
HISAVE   DC    X'00'               HIERARCHY SAVE AREA             LC0A
         DS    0F                                                  LC0A
HIMASK   DC    X'80D3C3E3'         HIERARCHY 1 IDENT - R-FORM      LC0A
.LC10    ANOP                                                      LC0A
*******************************************************************LC0A
*                                 GOVRFLB                         *LC0A
*******************************************************************LC0A
         DS    0D                                                 M2279
GOVRFLB  DS    0CL28                                             A36186
SQSBOUND DC    F'0'                UPPER BOUND OF SQS              LC0A
DQESQES  DC    F'0'                ADDR. OF DQE DESCRIBING SQS     LC0A
PQEPTR   DC    F'0'                PQE ADDR. DESCRIBING DYN. CORE  LC0A
SZDPRS   DC    F'0'                SIZE OF DYNAMIC PROC. STORAGE   LC0A
SZDLCS   DC    F'0'                SIZE OF DYNAMIC LCS STORAGE     LC0A
VQEPTR   DC    F'0'                VARY QUEUE ELEM. LIST ORIG. PTR MP65
NIPSQSBD DC    F'0'                SQS BOUNDARY FOR NIP & RORI   A36186
*******************************************************************LC0A
RECURSE  DC    F'0'
SVCXT    DC    A(IEA0XE00)
MSCEDADD DC    A(IEAMSTCB)
ABTERM   DC    A(IEA0AB01)
VALIDCHK DC    V(IEA0VL01)                                         TS0A
C246     DC    H'246'
C248     DC    H'248'
C252     DC    A(252)
         AIF   (&TSO NE 1).TSO2750                                20021
C254     DC    A(254)                                             20021
.TSO2750 ANOP                                                     20021
C255     DC    A(255)
SPIDSAV  DC    X'00' .             SAVE AREA FOR SUBPOLL ID      A32912
@SPSAVE  DC    H'0'                SUBPOOL ID SAVE AREA        @AS76397
KTWO     DC    H'2048' .                                         A31213
K4080    DC    F'4080' .                                         A31213
FBQESIZ  DC    F'0' .              SAVE AREA FOR LARGEST FBQE    A31213
FQESIZ   DC    F'0' .              SAVE AREA FOR LARGEST FQE     A31213
         AIF   ('&RORI' NE 'Y').GOR3                               LC0A
FRBASEAD DC    V(FRBRBASE)
FREPQEAD DC    V(IEAFRPQE)
GNSAT4AD DC    V(GNOTSAT4)
ROTST5AD DC    V(ROTEST5)
TESTROAD DC    V(TESTRO)
VARUNCAD DC    V(VARUNCD)
FREBRFAD DC    V(FREBRF)
BASEHOLD DS    2F
.GOR3    ANOP
XCDEXBAS DC    A(CDHKEEP+2)
XCDDSTRY DC    A(CDDESTRY)
PARTADDR DC    V(IEAQPRT0)
IPVAL    DC    A(IEAQVLCH)
         AIF   ('&MPS' NE 'Y').MP0318                              MP2K
ENPTMP2K DC    A(IEAMP2K)       ENTRY POINT TO THE MP CSECT        MP2K
.MP0318  ANOP                                                      SMF
         AIF   (&SMF EQ 0).FMCOMG                                   SMF
GMSMFAD  DC    A(GMSMFCRE)             ADDRESS OF GM CORE PROCESSOR SMF
         ENTRY SMFTCBSV                                             SMF
SMFTCBSV DC    F'0'                    TCB POINTER SAVE AREA        SMF
SMFPQESV DC    F'0'                    PQE POINTER SAVE AREA        SMF
.FMCOMG  ANOP                                                       SMF
ABNDATA  DC    2F'0'                                              21016
BRNREG   DC     F'0'                                              21016
MSGLEN   DC    X'00'                                              21016
FREESW   DC    X'00'                                              21016
ABNDATAL EQU   (*-ABNDATA)                                        21016
H60A     DC    X'060A'                                            21016
H80A     DC    X'080A'                                            21016
         SPACE                                                    21016
PREVDQSV DS    F
AREAUBSV DS    F
PREVQESV DS    F
DQESAVE  DS    F
FQESAVE  DS    F
RREGSAVE DS    F                                                  20021
         SPACE 2
TCBFRA   EQU   29                  DISPATCHABILITY BIT
CVTPTR   EQU   16                                                 21014
CVTTCB   EQU   0
LSTREG   EQU   28                                                ******
CVTPURG  EQU   260      CVT PTR TO SUBSYSTEM PURGE ROUTINE        21014
SQESPQE  EQU   GOVRFLB
GERRCODE EQU   X'0D'               BASIC ERROR CODE                8098
         SPACE 2                                                  20021
*        WAIT STATE PSW - DIASTER CONDITION                       20021
         SPACE                                                    20021
         DS    0D                                                 20021
WAIT     DC    X'00020000'         WAIT STATE PSW              @SA78255
         DC    X'00000E04'                                        20021
REQSIZE  DS    1F                  SAVE AREA FOR SIZE OF SQS      20021
*                                  REQUEST                        20021
ADPART   DC    A(IEAQPRT0+2)       BASE ADDRESS OD GETPART        20021
ADDISP   DC    A(DISPINIT)         ARRR OF RTN WITHIN GETPART     20021
       EJECT                                                      20021
         DS    0F                                                 20021
SAVSIX1  DC    1F'0'                                              20021
SAVSIX2  DC    1F'0'                                              20021
         AIF   (&SMF EQ 0).EQCOMA                                   SMF
         EJECT                                                      SMF
********************************************************************SMF
*                                                                   SMF
**************  SMF GETMAIN ROUTINE                           CH A45474
*                                                                   SMF
********************************************************************SMF
         SPACE 2                                                    SMF
*          INPUT - INITIALIZED CORE USED FIELDS IN TCT.             SMF
*                  FIELDS ARE INITIALIZED BY SCHEDULAR.             SMF
*                  REGS:RWPQE=PQE ADDR,RBLOCK=ADDR ALLOC CORE,CH A45474
*                  RSIZE=NUMBER BYTES ALLOCATED.              CH A45474
*                                                                   SMF
*          OUTPUT - MODIFIED CORE USED FIELDS IN TCT.               SMF
*                                                             CH A45474
*        FUNCTION-                                            CH A45474
*                                                             CH A45474
*        DETERMINE IF THERE IS A TCT ASSOCIATED WITH THIS REQUEST.  SMF
*        DETERMINE IF MAIN OR LCS CORE.                             SMF
*        DETERMINE WHEATHER REGION CORE OR BORROWED CORE.           SMF
*              UPDATE WATER MARKS IF NECESSARY.               CH A45474
*              HWM=LOWEST ADDR FROM HIGH END OF REGION.       CH A45474
*              LWM=HIGHEST ADDR FROM LOW END OF REGION.       CH A45474
*              HWM AND LWM MAY OVERLAP                        CH A45474
*              TCTMINC= LARGEST FBQE (IN 2K BLOCKS)NOT USED   CH A45474
*              BY JOB.                                        CH A45474
         SPACE 1                                                    SMF
IEASMFGF CSECT                                                      SMF
         ENTRY GMSMFCRE                                             SMF
GMSMFCRE BALR  GMSMFB,0                                             SMF
         USING *,GMSMFB                                             SMF
         STM   10,12,GFSMFSVE          SAVE WORK REGISTERS          SMF
         TM    TCBTCT(RTCB),TCBTCTGF . SHOULD TCT BE UPDATED  BC A32900
         BZ    RCEXIT .            BRANCH IF NO               BC A32900
         L     RTCT,TCBTCT(RTCB)       GET TCT POINTER              SMF
         LA    RTCT,0(RTCT)                                         SMF
         LTR   RTCT,RTCT               IS THERE A TCT               SMF
         BZ    RCEXIT                  BRANCH IF NO                 SMF
         L     RCORE,TCTCRTBL(RTCT)   INITIALIZE TCT CORE AREA PTR  SMF
         AIF   ('&LCS' NE 'Y').GMCOMB                               SMF
         CLI   PQEHIID(RWPQE),X'01'    TEST FOR LCS                 SMF
         BNE   NOLCS                   BRANCH IF NOT LCS            SMF
         LA    RCORE,TCTCSZE(RCORE)    STEP POINTER TO LCS AREA     SMF
NOLCS    NOP   *                                                   SSMF
.GMCOMB  ANOP                                                       SMF
         AIF   ('&RORI' NE 'Y').GMCOMC                              SMF
         TM    RORIFLG(RWPQE),RGNSHRD  IS IT SHARED CORE           SSMF
         BZ    NOSHRE                  BRANCH IF NOT SHARED         SMF
         LR    RCWRK,RSIZE             GET CURRENT BORROWED CORE    SMF
         SRL   RCWRK,DIV2048           DEVELOP NUMBER OF 2K BLOCKS  SMF
         AH    RCWRK,TCTRBC(RCORE)     ADD CURRENT 2K BLOCKS        SMF
         STH   RCWRK,TCTRBC(RCORE)     UPDATE CURRENT BORROWED CORE SMF
         CH    RCWRK,TCTMBC(RCORE)     IS NEW CURRENT MORE THAN MAX SMF
         BNH   NOTHI                   BRANCH IF NO                 SMF
         STH   RCWRK,TCTMBC(RCORE)     STORE NEW MAXIMUM            SMF
NOTHI    B     RCEXIT                                               SMF
.GMCOMC  ANOP                                                       SMF
NOSHRE   LA    RCWRK,0(RSIZE,RBLOCK) .  GET END OF ALLOC AREA CH A45474
         C     RBLOCK,TCTLWM(RCORE)  .  IS BEGIN GT LWM       BC A45474
         BH    GMTSTHWM .               YES , TRY HWM UPDATE  BC A47474
         C     RCWRK,TCTLWM(RCORE) .    IS END GT LWM         BC A45474
         BNH   GMTSTHWM .               NO , TRY HWM          BC A45474
         ST    RCWRK,TCTLWM(RCORE)   .  STORE NEW LWM         CH A45474
         B     GMCKFBQ                  GO CK MIN DIFF        CH A45474
GMTSTHWM C     RCWRK,TCTHWM(RCORE)      IS END LT HWM         BC A45474
         BL    GMCKFBQ .                YES , NO HWM CHANGE   BC A45474
         C     RBLOCK,TCTHWM(RCORE) .   IS BEGIN LT HWM       BC A45474
         BNL   GMCKFBQ .                NO , GO CK MIN DIFF   BC A45474
         ST    RBLOCK,TCTHWM(RCORE)  .  STORE NEW HWM         CH A45474
* SEARCH FOR LARGEST FBQE .IF LARGEST FBQE IS GRTR THAN THE   CH A45474
* MINIMUM DIFFERENCE, MAKE IT NEW TCTMINC.                    CH A45474
GMCKFBQ  SR    RCWRK,RCWRK           .  INIT LARGEST SIZE=0   CH A45474
         CH    RCWRK,TCTMINC(RCORE)  .  IS TCTMINC=0          CH A45474
         BE    RCEXIT                   YES, BYPASS FBQE SRCH CH A45474
         L     RCFBQREG,FWDPTR(RWPQE) . GET LOWEST FBQE       CH A45474
GMLSTFBQ CLR   RCFBQREG,RWPQE           IS THIS END OF CHAIN  CH A45474
         BE    GMCKMIN                  YES, GO CK IF NEW MIN CH A45474
         C     RCWRK,FBQESIZE(RCFBQREG) IS THIS LARGEST FBQE  CH A45474
         BNL   GMNXTFBQ                 NO                    CH A45474
         L     RCWRK,FBQESIZE(RCFBQREG) SAVE LARGEST FBQE     CH A45474
GMNXTFBQ L     RCFBQREG,FWDPTR(RCFBQREG) GET NEXT HIGHER FBQE CH A45474
         B     GMLSTFBQ                 GO CHECK FOR END CHAINCH A45474
GMCKMIN  SRL   RCWRK,DIV2048            CONVERT TO 2K BLOCKS  CH A45474
         CH    RCWRK,TCTMINC(RCORE)     IS THIS A NEW MIN DIFFCH A45474
         BNL   RCEXIT                   NO                    CH A45474
         STH   RCWRK,TCTMINC(RCORE)     STORE NEW TCTMINC     CH A45474
RCEXIT   LM    10,12,GFSMFSVE           RESTORE WORK REGS     CH A45474
         BR    GMSMFRT                  RETURN                CH A45474
         DROP  GMSMFB                                         CH A45474
         SPACE 2                                              BC A45474
         LR    RCWRK1,RSIZE .                                    A57388
         SLR   RCWRK1,DIV2048 .                                  A57388
RCFBQREG EQU   12                      ADDR FBQE              BC A45474
         SPACE 1                                                    SMF
SMF252   DC    X'FC' .                                           A32912
GFSMFSVE DC    3F'0'                   SMF CORE ROUTINES SAVE AREA  SMF
SMFFQESV DC    F'0'                    FQE POINTER SAVE AREA        SMF
ASMFTCB  DC    A(SMFTCBSV)             ADDRESS OF TCB PTR SAVE      SMF
ADSPSAV  DC     V(SPIDSAV) .        ADDR OF SPIDSAV IN QGM       A32912
         SPACE 1                                                    SMF
         SPACE 2                                                    SMF
FMSMFRT  EQU   1                       RETURN REGISTER              SMF
TCBTCTGF EQU   X'80' .                                        BC A32900
GMSMFB   EQU   2                       BASE REGISTER                SMF
RWPQE1   EQU   2                       DEALLOCATION PQE POINTER     SMF
RCWRK2   EQU   4 .                                            BC A32900
FMSMFB   EQU   6                       BASE REGISTER                SMF
RWPQE    EQU   6                       ALLOCATION PQE POINTER       SMF
GMSMFRT  EQU   7 RETURN REGISTER TO GETMAIN                       20021
RTCT     EQU   10                      TCT POINTER                  SMF
RTCT1    EQU   10                      TCT POINTER                  SMF
RCORE    EQU   10                      CORE AREA POINTER            SMF
RCORE1   EQU   10                      CORE AREA POINTER            SMF
RCWRK    EQU   11                      WORK REGISTER                SMF
RCWRK1   EQU   11                      WORK REGISTER                SMF
RCWRKA   EQU   12                      WORK REGISTER                SMF
         SPACE 1                                                    SMF
TCBTCT   EQU   164                       TCT POINTER                SMF
TCTCSZE  EQU   16                      SIZE OF CORE AREA OF TCT     SMF
TCTCRTBL EQU   8                      ADDR OF TCT CORE TABLE        SMF
TCTLWM   EQU   0                       LOW WATER MARK OF CORE USED  SMF
TCTHWM   EQU   4                       HI WATER MARK OF USED CORE   SMF
TCTMINC  EQU   8                       MINIMUM DIFF BETWEEN LWM/HWM SMF
TCTRBC   EQU   12                      CURRENT BORROWED CORE        SMF
TCTMBC   EQU   14                      MAXIMUM BORROWED CORE        SMF
.EQCOMA  ANOP                                                       SMF
         SPACE
TWOK     EQU   2048
MULT8    EQU   3
MULT2048 EQU   11                  SHIFT TO MULTIPLY BY 2048
DIV2048  EQU   11                  SHIFT TO DIVIDE BY 2048
         SPACE
*        CONDITION CODES
         SPACE
NZ       EQU   7                   NOT ZERO
NN       EQU   10                  NOT NEGATIVE
NOTLIST  EQU   11                  NOT LIST REQUEST
ELEMENT  EQU   8                   ELEMENT REQUEST
NP       EQU   12                  NOT POSITIVE
         SPACE
*        PARAMETER LIST OFFSETS
         SPACE
SPID     EQU   9                   OFFSET OF SUBPOOL ID IN PARAMETER
*                                   LIST
TYPE     EQU   8                   OFFSET OF TYPE CODE IN PARAMETER
*                                   LIST
VLNTH    EQU   4                   OFFSET OF LENGTH IN VARIABLE
*                                   LENGTH-ADDRESS LIST
         SPACE
PTROFST  EQU   1                   OFFSET OF POINTER IN AQE, FQE, DQE
FQEOFSET EQU   0                   OFFSET OF BEGINNING OF FQE
         SPACE
QESIZE   EQU   8                   SIZE OF QUEUE ELEMENT
FBQELNTH EQU   12                  SIZE OF FBQE
FQNXTFLD EQU   4                   LENGTH OF POINTER IN FQE
ADRLNTH  EQU   3                   NUMBER OF BYTES OCCUPIED BY ADDRESS
         SPACE
DQETEST  EQU   0                   MASK TO TEST FOR LARGE DQE
CODE     EQU   X'C0'               MASK FOR CHECKING TYPE CODE IN
*                                   PARAMETER LIST
         SPACE 2
*
*        SPQE FIELDS
*
SPQEFLGS EQU   0         FLAG BYTE
SPQENXT  EQU   0         NEXT SPQE POINTER -1
SPQEID   EQU   4         SUBPOOL ID
SPQEDQE  EQU   4         FIRST DQE POINTER -1
SPQESHRD EQU   X'80'     MASK FOR FLAG BIT INDICATING SPQE IS SHARED
SPQELAST EQU   X'40'     MASK FOR FLAG BIT INDICATING LAST SPQE FOR TCB
*
*        DQE FIELDS '
*
DQEFQE   EQU   0         FIRST FQE POINTER -1
DQENXT   EQU   4         NEXT DQE POINTER -1
         AIF   ('&LCS' NE 'Y').LC11                                LC0A
DQEHIID  EQU   8                   HIERARCHY IDENT                 LC0A
.LC11    ANOP                                                      LC0A
DQEADDR  EQU   8                   ADDRESS OF AREA DEFINED BY DQE
DQELNTH  EQU   12                  LENGTH OF AREA DEFINED BY DQE
*
*        FQE FIELDS
*
FQENXT   EQU   0         NEXT FQE POINTER
FQELNTH  EQU   4         LENGTH OF FREE AREA
*
*        AQE FIELDS
*
AQENXT   EQU   0                   POINTER TO NEXT AQE
AQELNTH  EQU   4                   LENGTH OF ASSIGNED AREA
*
*        PQE FIELDS
PQENXT   EQU   8                  OFFSET OF NEXT PQE PTR IN PQE
PQEPREV  EQU   12                 OFFSET OF PREVIOUS PQE PTR IN PQE
*
*        FBQE FIELDS
*
*
*        DUMMY PQE FIELDS
*
DUMFWD   EQU   PQENXT             OFFSET OF FORWARD PQE PTR IN DUMMY
DUMBWD   EQU   PQEPREV            OFFSET OF BACKWARD PQE PTR IN DUMMY
PQETCB   EQU   16                  OFFSET OF TCB POINTER IN PQE
PQERGSZ  EQU   20                      OFFSET OF REGION SIZE IN PQE
PQESTADD EQU   24                      OFFSET OF RGN STRT ADD IN PQE
RORIFLG  EQU   28                 ROLLOUT FLAG IN PQE
         AIF   ('&LCS' NE 'Y').LC12                                LC0A
PQEHIID  EQU   29                  HIERARCHY IDENT                 LC0A
.LC12    ANOP                                                      LC0A
RGNSHRD  EQU   X'80'              MASK FOR FLAG BIT INDICATING REGION
*                                 IS BORROWED
*                        PQES ON THE PQE QUEUE.
*
*                        THESE FIELDS ARE REFERENCED
*
*                          DUMFWD - A FOUR BYTE FIELD IN WHICH THE
*                                   FIRST BYTE IS ZERO AND IN WHCIH THE
*                                   LAST THREE BYTES CONTAIN A POINTER
*                                   TO THE FIRST PQE ON THE CHAIN
*
*                          DUMBWD - A FOUR BYTE FIELD IN WHICH THE
*                                   FIRST BYTE IS ZERO AND IN WHICH THE
*                                   LAST THREE BYTES CONTAIN A POINTER
*                                   TO THE LAST PQE ON THE CHAIN.
FWDPTR   EQU   0                   OFFSET OF FORWARD POINTER IN PQE
BCKPTR   EQU   4                   OFFSET OF BACKWARD POINTER IN PQE
FBQESIZE EQU   8                   OFFSET OF SIZE FIELD IN PQE
*
*        TCB FIELDS REFERENCED
*
TCBABND  EQU   29
TCBFMC   EQU   30
TCBTCB   EQU   116
TCBJSTCB EQU   124                 JOB STEP TCB POINTER
TCBMSS   EQU   24        SPQE POINTER -1
TCBFCD1  EQU   33               FIFTH FLAG BYTE IN TCB
TCBPKF   EQU   28        PROTECT KEY
TCBJPQ   EQU   44                  OFFSET FOR TCBJPQ FIELD IN TCB
TCBPQE   EQU   152                 OFFSET OF TCBPQE IN TCB
TCBAQE   EQU   156                 OFFSET OF TCBAQE IN TCB
*
*        REFERENCES TO CDE
*
CDATTR   EQU   0                   OFFSET FOR ATTRIBUTE FIELD IN CDE
CDATTR2  EQU   20                  OFFSET FOR ATTRIBUTE FIELD IN CDE
REL      EQU   X'40'               MASK FOR INACTIVE FLAG IN CDE ATTR.
MIN      EQU   X'04'               MASK FOR MINOR FLAG IN CDE ATTR.
*        SYMBOLIC REGISTER ASSIGNMENTS
*
RIN0     EQU   0
RMASK    EQU   0
RFBQEUB  EQU   0
RAREAUB  EQU   0
RIN1     EQU   1
RPRQE    EQU   1
RDISP    EQU   1
RAQEUB   EQU   1
RQEUB    EQU   1
RDQEBLK  EQU   1
RWORK4   EQU   1
RNEWDQE  EQU   1
RVALBAS  EQU   2
RLST     EQU   2
RDQE     EQU   2
RWORK5   EQU   2
RPQE     EQU   2
RBLOCK1  EQU   2
REXBAS   EQU   2
FREBAS   EQU   3 BASE REGISTER FOR FREEMAIN                       20021
CVTREG   EQU   3                        CVT REGISTER
RCVT     EQU   4                                                  20021
RTCB     EQU   4
RFQE1    EQU   4
RSPID    EQU   5
RUBRND   EQU   5
RCDE     EQU   5
        AIF ('&LCS' EQ 'N').LCSEQ01                                I283
PQE6     EQU   6                   REGISTER 6 - @ PQE              I283
PQE9     EQU   9                                                   I283
WORK15   EQU   15                                                  I283
.LCSEQ01 ANOP                                                      I283
RWORK1   EQU   6
RERROR   EQU   6
RLRGSIZ  EQU   6
RQESIZ   EQU   6
RDQESIZ  EQU   6
RSWITCH  EQU   6
RFBQE    EQU   6                                                  20021
RSIZE1   EQU   6                                                  20021
RWORK6   EQU   6                                                  20021
RWORK2   EQU   7
RFQE     EQU   7
RCOMRET3 EQU   7
RQE      EQU   7
RBASE    EQU   8
RCOMRET1 EQU   9
RORIREG  EQU   9
RWK3CVT  EQU   9                                                  20021
RWORK3   EQU   9
RLENGTH  EQU   10
RSIZE2   EQU   10
RSIZE3   EQU   10
RMASK1   EQU   10
RADDR    EQU   11
RFQRND   EQU   11
RLRGBLK  EQU   11
RCDEIN   EQU   11
RBASE1   EQU   11
FPQEBASE EQU   11
RVALRET  EQU   12
RSPQE    EQU   12
RPREDQE  EQU   12
RAQE     EQU   12
RPREVDQ  EQU   12
RDISP1   EQU   12
RRET1    EQU   12
RBLOCK2  EQU   12
RFQEUB   EQU   12
RABTERM  EQU   13
RGMRET   EQU   13
RFMRET   EQU   13
RCOMRET2 EQU   13
RDQELB   EQU   13
RRET     EQU   13
MP65BASE EQU   13                                                  MP2K
RRETURN  EQU   14
RPREFQE  EQU   14
RBLOCK   EQU   14
RPREVQE  EQU   14
RIN15    EQU   15
RFRELNTH EQU   15
RSIZE    EQU   15
RDQEUB   EQU   15
IPVLBASE EQU   15
         SPACE
***************************************************************   21016
*        DSECT TO COVER INFORMATION LIST ENTRY                    21016
***************************************************************   21016
         SPACE 1                                                  21016
INFOLIST DSECT                                                    21016
INFENTRY DS    H      NOT USED                                   A49808
INFTJID  DS    H      USER TSO ID FIELD                          A49808
INFTCB   DS    F                                                  21016
INFBADDR DS    F                                                  21016
INFRCL   DS    X     BITS 0-2 USED FOR REASON CODE(0=>NO RC)      21016
*                    BITS 3-7 USED FOR COUNT OF VARIABLE DATA BYTE21016
INFFLG   DS    X     FLAG BYTE                                    21016
INFFLG0  EQU   X'80' BIT 0 ON => BRANCH ENTRY                     21016
INFCC    DS    H     COMPLETION CODE                              21016
INFVAR   DS    4F    VARIABLE INFORMATION                         21016
         ORG   INFVAR                                             21016
INFVAR1  DS    F                                                  21016
INFVAR2  DS    F                                                  21016
INFVAR3  DS    F                                                  21016
INFVAR4  DS    F                                                  21016
INFEND   EQU   *                                                  21016
INFLEN   EQU   (INFEND-INFENTRY)  LENGTH OF ENTRY                A49808
         EJECT                                                    21016
SCVTMSGS EQU   X'94'                                              21016
SCVTFMSA EQU   X'98'           ADDR OF CONDITIONAL FREEMAIN BITS  21016
SCVTSW1  EQU   X'80'           CONDITIONAL FREEMAIN BITS.         21016
         SPACE 2                                                  21016
CVT0EF00 EQU   4                                                  21016
CVTNUCB  EQU   128                                                21016
CVTCRTTR EQU   X'B8'                                              21016
CVTABEND EQU   X'C8'                                              21016
CVTQMSG  EQU   X'10C'                                             21016
         SPACE 2                                                  21016
         MEND
          IEAQGM Y,Y,Y,1,1
          END
