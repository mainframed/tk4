 * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *
 *                                                                     *
 *  Purpose: To determine which usermods will be regressed following a *
 *           an I/O or SYS GEN.                                        *
 *                                                                     *
 *  Developed by: Rank Xerox Limited - 1984.                           *
 *                                                                     *
 *  Company Address: Phoenix House,                                    *
 *                      Kemp Place,                                    *
 *                         Bushey,                                     *
 *                            Herts.,                                  *
 *                               WD2 1DN                               *
 *                                                                     *
 *  Contents: The following four sections, which can be located by the *
 *            presence of the string '///' in colums 2 to 4, have been *
 *            included:-                                               *
 *             ///DOC     - Documentation                              *
 *             ///COMP    - Program completion codes                   *
 *             ///SAMPJCL - Sample JCL                                 *
 *             ///SYSMOD  - Source code etc. in SMP format.            *
 *                                                                     *
 * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *

 ///DOC

 * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *
 *                                                                     *
 *             ///DOC     - Documentation                              *
 *                                                                     *
 * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *

    PROBLEM:
    After an I/O or SYS GEN has been completed, some user mods may have
    been regressed.


    SOLUTION:
    We need to find out which SYSMODS will be regressed,(before
    updating the SMP datasets using the STAGE 2 deck as JCLIN),
    so that these SYSMODS may be reviewed and reapplied.


    APPROACH:
    The required information can be obtained from the input job
    stream to STAGE 2 processing (i.e. from output produced by
    STAGE 1).

    We are only interested in NEW load modules created and their
    element modules.

    A list of these load modules and module names, (i.e. the
    LISTCDS LMOD & LISTCDS MOD listings), can be obtained by
    running the SMP program.


    STEP01: GENERATION OF SMP CONTROL CARDS
    execute PGM=SMPCNTL

    input:      a set of DDnames each followed by control cards

    processing: writes control cards to file with preceding DDname

    output:     file with DDname SYSUTA
                containing:               LISTCDS LMOD(

                file with DDname SYSUTB
                containing:               LISTCDS MOD(

                file with DDname SYSUTC
                containing:               LISTCDS NOACC SYSMOD(

                file with DDname SYSUTD
                containing:               ).

    These files are used later on to produce the required SMP listings.


    STEP02: FIND NAMES OF LOAD MODULES/MODULES IN STAGE 2 DECK
    execute PGM=SMPPARS

    input:      STAGE 2 JCL deck

    processing: extracts the names of all the load modules/modules
                specified on the cards with keywords
                'SELECT MEMBER='     (produced by PGM=IEBCOPY in
                                      STAGE 2 processing)
                'INCLUDE'     }
                'ORDER'       }      (produced by PGM=IEWL in
                'ALIAS'       }       STAGE 2 processing)
                'ENTRY'       }
                'NAME'        }

    output:     list of unique load module/module names in collated
                sequence


    STEP03: PRODUCE SMP LISTINGS OF LMOD & MOD ENTRIES
    execute PGM=HMASMP

    input: the SMP control cards
           LISTCDS LMOD(--------)     using SYSUTA & SYSUTD from STEP01
           LISTCDS MOD(--------)      using SYSUTB & SYSUTD from STEP01
           with the names from STEP02 inserted between the brackets

    output: SMP LISTCDS LMOD listing & LISTCDS MOD listing written
            to disk

    STEP04: (optional) PRODUCE PRINTED COPY OF LISTINGS
    execute PGM=IEBGENER

    input:       listings from STEP03

    output:      printed copies of LISTCDS LMOD listing
                                 & LISTCDS MOD listing


    STEP05:
    We are only interested in LMOD entries at this point, as there may
    be sysmods with JCLIN that have affected an LMOD entry (e.g. in the
    nucleus).

    execute PGM=SMPLMOD

    input:       LISTCDS LMOD listing from STEP03

    processing:  extracts from the LISTCDS LMOD listing the linkage
                 editor control statements for each load module with
                 keywords 'ENTRY','ALIAS' & 'ORDER'

    output:      linkage editor control cards


    STEP06: FIND ALL MODULES POSSIBLY AFFECTED BY GEN

    execute PGM=SMPPARS

    input:       the original STAGE 2 deck concatenated with the
                 linkage editor control cards just retrieved

    processing: extracts the names of all the modules specified
                on the cards with keywords
                'SELECT MEMBER='     (produced by PGM=IEBCOPY in
                                      STAGE 2 processing)
                'INCLUDE'     }
                'ORDER'       }      (produced by PGM=IEWL in
                'ALIAS'       }       STAGE 2 processing)
                'ENTRY'       }
                'NAME'        }

     output:     list of unique module names in collated sequence


     STEP07: PRODUCE SMP LISTINGS OF MOD ENTRIES
     execute PGM=HMASMP

     input:the SMP control cards
           LISTCDS MOD(--------)      using SYSUTB & SYSUTD from STEP01
           with the names from STEP06 inserted between the brackets

     output: SMP LISTCDS MOD listing written to disk


     STEP08: FIND ALL SYSMODS POSSIBLY REGRESSED
     A possible canditate for regression is a module which has
     the RMID name different from the FMID name &/or
     the UMID name different from the FMID name.

     execute PGM=SMPSCAN

     input:      the LISTCDS MOD listing from STEP07

     processing: extracts the names of all UMIDs & RMIDs that are
                 different from the FMID name

     output:     a list of unique SYSMODS in collated sequence, that
                 may have been regressed


     STEP09:
     execute PGM=HMASMP

     input: the SMP control cards
       LISTCDS NOACC SYSMOD(--------)  using SYSUTC & SYSUTD from STEP01
            with the names from STEP08 inserted between the brackets

     output: printed list of all the SYSMODS that have not been
     accepted (i.e. are still in the 'APPLY' stage of the SMP
     processing function)

 * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *
 * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *
 * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *

 ///COMP

 * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *
 *                                                                     *
 *             ///COMP    - Program completion codes                   *
 *                                                                     *
 * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *

 SMPCNTL
      4 - NO 'DDNAME=' ON FIRST INPUT CARD
      8 - UNSUCCESSFUL OUTPUT FILE OPENING
     16 - UNSUCCESSFUL INPUT FILE OPENING

 SMPPARS
      4 - UNSUCCESSFUL INPUT &/OR OUTPUT FILE OPENING
     16 - TABLE IN SOURCE CODE NOT LARGE ENOUGH FOR ALL NAMES THAT OCCUR
          (IMPROBABLE, BUT IF HAPPENS CHANGE SOURCE CODE)

 SMPLMOD
      4 - UNSUCCESSFUL INPUT &/OR OUTPUT FILE OPENING

 SMPSCAN
      4 - UNSUCCESSFUL INPUT &/OR OUTPUT FILE OPENING
     16 - TABLE IN SOURCE CODE NOT LARGE ENOUGH FOR ALL NAMES THAT OCCUR
          (IMPROBABLE, BUT IF HAPPENS CHANGE SOURCE CODE)

 * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *
 * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *
 * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *

 ///SAMPJCL

 * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *
 *                                                                     *
 *             ///SAMPJCL - Sample JCL                                 *
 *                                                                     *
 * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *

//*
//*        *******       *******    ***********************************
//*          *****       *****      *                                 *
//*            ****     ****        *   R E A D   T H I S             *
//*              **** ****          *                                 *
//*                *****            ***********************************
//*                 ***
//*                 ***
//*            *************
//*              *********
//*                *****
//*                  *
//*
//*  *********** N O T E S ********************************************
//*  ******************************************************************
//*  **                                                              **
//*  ** *******************                                          **
//*  ** * JOB DESCRIPTION *                                          **
//*  ** *******************                                          **
//*  **                                                              **
//*  ** PRODUCE A REPORT OF ALL SYSMODS REGRESSED BY THE I/O GEN     **
//*  ** THAT WE ARE ABOUT TO DO.                                     **
//*  **                                                              **
//*  ** *******************                                          **
//*  ** * THINGS TO DO !  *                                          **
//*  ** *******************                                          **
//*  **                                                              **
//*  ** EXAMINE ALL JCL BELOW AND MODIFY TO LOCAL STANDARDS          **
//*  **                                                              **
//*  ******************************************************************
//*  *********** N O T E S ********************************************
//*
//STEP01   EXEC  PGM=SMPCNTL
//*
//* *******************************************************************
//* **                                                               **
//* ** GENERATE SMP CONTROL CARDS                                    **
//* **                                                               **
//* *******************************************************************
//*
//SYSPRINT DD  SYSOUT=*
//SYSUTA   DD  DISP=(NEW,PASS),UNIT=SYSDA,SPACE=(TRK,1),
//             DCB=(RECFM=FB,LRECL=80,BLKSIZE=3120)
//SYSUTB   DD  DISP=(NEW,PASS),UNIT=SYSDA,SPACE=(TRK,1),
//             DCB=(RECFM=FB,LRECL=80,BLKSIZE=3120)
//SYSUTC   DD  DISP=(NEW,PASS),UNIT=SYSDA,SPACE=(TRK,1),
//             DCB=(RECFM=FB,LRECL=80,BLKSIZE=3120)
//SYSUTD   DD  DISP=(NEW,PASS),UNIT=SYSDA,SPACE=(TRK,1),
//             DCB=(RECFM=FB,LRECL=80,BLKSIZE=3120)
//SYSUT1   DD  *
DDNAME=SYSUTA
  LISTCDS LMOD
    (
          /***************************************************/
          /**                                               **/
          /***************************************************/

DDNAME=SYSUTB
  LISTCDS MOD
    (
          /***************************************************/
          /**                                               **/
          /***************************************************/

DDNAME=SYSUTC
  LISTCDS NOACC SYSMOD
    (
          /***************************************************/
          /**                                               **/
          /***************************************************/

DDNAME=SYSUTD

    ).
//*
//STEP02   EXEC  PGM=SMPPARS,REGION=800K
//*
//* *******************************************************************
//* **                                                               **
//* ** CREATE SMP  LISTCDS LMOD(..........). CONTROL CARDS           **
//* **             LISTCDS  MOD(..........). CONTROL CARDS           **
//* **                                                               **
//* ** BASED ON THE FOLLOWING STATEMENTS FROM THE STAGE2 JCL DECK -  **
//* **                                                               **
//* ** PGM=IEBCOPY  SELECT MEMBER=........                           **
//* **                                                               **
//* ** PGM=IEWL     INCLUDE LIBRARY(........)                        **
//* **              ORDER   ........                                 **
//* **              ALIAS   ........                                 **
//* **              NAME    ........(R)                              **
//* **                                                               **
//* *******************************************************************
//*
//SYSPRINT DD  SYSOUT=*
//SYSLIST  DD  DUMMY
//SYSUT1   DD  DISP=SHR,DSN=......STAGE 2 INPUT.......................
//SYSUT2   DD  DISP=(NEW,PASS),UNIT=SYSDA,SPACE=(TRK,(1,1)),
//             DCB=(RECFM=FB,LRECL=80,BLKSIZE=3120)
//*
//STEP03   EXEC PGM=HMASMP,REGION=4096K
//*
//* *******************************************************************
//* **                                                               **
//* ** PRODUCE A LISTCDS MOD AND LISTCDS LMOD LISTING                **
//* **                                                               **
//* *******************************************************************
//*
//SMPLOG   DD  DUMMY
//SMPOUT   DD  DUMMY
//SYSPRINT DD  SYSOUT=*
//SMPCDS   DD  DISP=SHR,DSN=SYS1.SMPCDS
//SMPLIST  DD  DISP=(NEW,PASS),SPACE=(CYL,(10,1)),UNIT=SYSDA,
//             DCB=(RECFM=FBA,LRECL=121,BLKSIZE=121)
//SMPCNTL  DD  DISP=(OLD,PASS),DSN=*.STEP01.SYSUTA,
//             VOL=REF=*.STEP01.SYSUTA
//         DD  DISP=(OLD,PASS),DSN=*.STEP02.SYSUT2,
//             VOL=REF=*.STEP02.SYSUT2
//         DD  DISP=(OLD,PASS),DSN=*.STEP01.SYSUTD,
//             VOL=REF=*.STEP01.SYSUTD
//         DD  DISP=(OLD,PASS),DSN=*.STEP01.SYSUTB,
//             VOL=REF=*.STEP01.SYSUTB
//         DD  DISP=(OLD,PASS),DSN=*.STEP02.SYSUT2,
//             VOL=REF=*.STEP02.SYSUT2
//         DD  DISP=(OLD,PASS),DSN=*.STEP01.SYSUTD,
//             VOL=REF=*.STEP01.SYSUTD
//*
//STEP04   EXEC  PGM=IEBGENER
//*
//* *******************************************************************
//* **                                                               **
//* ** PRINT THE LISTCDS MOD AND LISTCDS LMOD LISTINGS               **
//* **                                                               **
//* *******************************************************************
//*
//SYSPRINT DD  DUMMY
//SYSUT1   DD  DISP=(OLD,PASS),DSN=*.STEP03.SMPLIST
//SYSUT2   DD  DUMMY
//*YSUT2   DD  SYSOUT=*
//SYSIN    DD  DUMMY,DCB=BLKSIZE=80
//*
//STEP05   EXEC  PGM=SMPLMOD
//*
//* *******************************************************************
//* **                                                               **
//* ** EXTRACT FROM THE LISTCDS LMOD LISTING THE LINKEDIT ORDER      **
//* ** CARDS                                                         **
//* **                                                               **
//* *******************************************************************
//*
//SYSPRINT DD  SYSOUT=*
//SYSUT1   DD  DISP=(OLD,PASS),DSN=*.STEP03.SMPLIST
//SYSUT2   DD  DISP=(NEW,PASS),SPACE=(TRK,(1,1)),UNIT=SYSDA,
//             DCB=(RECFM=FB,LRECL=80,BLKSIZE=3120)
//*
//STEP06   EXEC  PGM=SMPPARS
//*
//* *******************************************************************
//* **                                                               **
//* ** CREATE      LISTCDS  MOD(..........). CONTROL CARDS           **
//* **                                                               **
//* ** BASED ON THE FOLLOWING STATEMENTS FROM THE STAGE2 JCL DECK    **
//* ** AND THE LINKEDIT ORDER CARDS EXTRACTED IN THE PREVIOUS STEP   **
//* **                                                               **
//* **                                                               **
//* ** PGM=IEBCOPY  SELECT MEMBER=........                           **
//* **                                                               **
//* ** PGM=IEWL     INCLUDE LIBRARY(........)                        **
//* **              ORDER   ........                                 **
//* **              ALIAS   ........                                 **
//* **              NAME    ........(R)                              **
//* **                                                               **
//* *******************************************************************
//*
//*
//SYSPRINT DD  SYSOUT=*
//SYSLIST  DD  DUMMY
//SYSUT1   DD  DISP=(OLD,PASS),DSN=*.STEP05.SYSUT2
//         DD  DISP=SHR,DSN=.........STAGE 2 INPUT...................
//SYSUT2   DD  DISP=(NEW,PASS),UNIT=SYSDA,SPACE=(TRK,(1,1)),
//             DCB=(RECFM=FB,LRECL=80,BLKSIZE=3120)
//*
//STEP07   EXEC PGM=HMASMP,REGION=4096K
//*
//* *******************************************************************
//* **                                                               **
//* ** PRODUCE A LISTCDS MOD LISTING                                 **
//* **                                                               **
//* *******************************************************************
//*
//SMPLOG   DD DUMMY
//*
//SMPCDS   DD  DISP=SHR,DSN=SYS1.SMPCDS
//*
//SYSPRINT DD  SYSOUT=*
//SMPLIST  DD  DISP=(NEW,PASS),SPACE=(CYL,(10,1)),UNIT=SYSDA,
//             DCB=(RECFM=FBA,LRECL=121,BLKSIZE=121)
//SMPOUT   DD  DUMMY
//SMPCNTL  DD  DISP=(OLD,PASS),DSN=*.STEP01.SYSUTB,
//             VOL=REF=*.STEP01.SYSUTB
//         DD  DISP=(OLD,PASS),DSN=*.STEP06.SYSUT2,
//             VOL=REF=*.STEP06.SYSUT2
//         DD  DISP=(OLD,PASS),DSN=*.STEP01.SYSUTD,
//             VOL=REF=*.STEP01.SYSUTD
//*
//STEP08   EXEC  PGM=SMPSCAN,REGION=800K
//*
//* *******************************************************************
//* **                                                               **
//* ** GENERATE SMP LISTCDS NOACC SYSMOD(........) CONTROL CARDS     **
//* **                                                               **
//* ** BASED ON THE RMID AND UMID FIELDS FROM THE LISTCDS MOD        **
//* ** LISTING PRODUCED IN THE PREVIOUS STEP.                        **
//* **                                                               **
//* *******************************************************************
//*
//*
//SYSPRINT DD  SYSOUT=*
//SYSLIST  DD  DUMMY
//SYSUT1   DD  DISP=(OLD,PASS),DSN=*.STEP07.SMPLIST
//SYSUT2   DD  DISP=(NEW,PASS),UNIT=SYSDA,SPACE=(TRK,(1,1)),
//             DCB=(RECFM=FB,LRECL=80,BLKSIZE=3120)
//*
//STEP09   EXEC PGM=HMASMP,REGION=4096K
//*
//* *******************************************************************
//* **                                                               **
//* ** PRODUCE A LISTCDS NOACC SYSMOD(........) LISTING              **
//* **                                                               **
//* ** THIS SHOULD REPRESENT THE SYSMODS REGRESSED BY THE LATEST     **
//* ** I/O GEN.                                                      **
//* **                                                               **
//* *******************************************************************
//*
//SMPLOG   DD DUMMY
//*
//SMPCDS   DD  DISP=SHR,DSN=SYS1.SMPCDS
//SMPACDS  DD  DISP=SHR,DSN=SYS1.SMPACDS
//SYSPRINT DD  SYSOUT=*
//SMPOUT   DD  DUMMY
//SMPLIST  DD  SYSOUT=*
//SMPCNTL  DD  DISP=(OLD,PASS),DSN=*.STEP01.SYSUTC,
//             VOL=REF=*.STEP01.SYSUTC
//         DD  DISP=(OLD,PASS),DSN=*.STEP08.SYSUT2,
//             VOL=REF=*.STEP08.SYSUT2
//         DD  DISP=(OLD,PASS),DSN=*.STEP01.SYSUTD,
//             VOL=REF=*.STEP01.SYSUTD

 * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *
 * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *
 * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *

 ///SYSMOD

 * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *
 *                                                                     *
 *             ///SYSMOD  - Source code etc. in SMP format.            *
 *                                                                     *
 * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *

++USERMOD(NZ90121)

  /*  <<<<<<<<<<<<<<<<<<<<<<<<<<<<<>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
      <<                                                         >>
      << TAILOR TO COMPLY WITH LOCAL STANDARDS OR EXTRACT SOURCE >>
      <<                                                         >>
      <<<<<<<<<<<<<<<<<<<<<<<<<<<<<>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>

       SYSMOD REGRESSION CHECKING PROGRAMS ...
          SMPCNTL WRITES SMP CONTROL STATEMENTS FROM INPUT STREAM TO
                  SPECIFIED FILES
          SMPLMOD EXTRACTS FROM AN SMP LISTCDS LMOD LISTING THE
                  LINKAGE EDITOR CONTROL STATEMENTS WITH KEYWORDS
                  'ENTRY','ALIAS' & 'ORDER'
          SMPPARS EXTRACTS FROM THE STAGE2 JCL DECK THE NAMES OF ALL
                  THE MODULES/LOAD MODULES SPECIFIED ON RECORDS WITH
                  KEYWORDS 'ALIAS',ENTRY',ORDER','NAME','INCLUDE' &
                  'SELECT'
          SMPSCAN EXTRACTS THE SYSMOD ID'S OF THOSE MODULES WITH UMID
                  ID &/OR RMID ID DIFFERENT FROM THE FMID ID

  */.
++VER(Z038) FMID(EDM1102)       /* BASE VERSION */ .
++JCLIN.
//LKED     EXEC PGM=IEWL,PARM='XREF,LET,LIST'
//SYSLMOD  DD   DSN=LIB2.LIB2LINK,DISP=SHR    (REALLY LIB2.LINKLIB)
//SYSLIN   DD   *
  INCLUDE AUSU0(SMPCNTL)
  NAME SMPCNTL(R)
  INCLUDE AUSU0(SMPLMOD)
  NAME SMPLMOD(R)
  INCLUDE AUSU0(SMPPARS)
  NAME SMPPARS(R)
  INCLUDE AUSU0(SMPSCAN)
  NAME SMPSCAN(R)
++SRC(SMPCNTL) DISTLIB(RXASRC).
SMPCNTL  CSECT
*******************************************************************
*
*  PROGRAM SMPCNTL
*
*  LOOKS IN THE INPUT STREAM FOR CONTROL RECORDS
*  COMMENCING 'DDNAME=' IN COLUMN 1
*  WRITES ALL THE FOLLOWING DATA RECORDS TO THE FILE SPECIFIED
*  IN THE CONTROL CARD
*  DDNAME: SYSUT1
*
*  WRITES OUT 80 BYTE RECORDS
*  IF PARM=NUM SPECIFIED IN JCL EXEC STATEMENT:
*     NUMBERED FROM 100 IN INCREMENTS OF 100
*  ELSE UN-NUMBERED
*  DDNAMES: VARIOUS, AS DEFINED IN INPUT STREAM
*
*  E.G.
*  INPUT: DDNAME=SYSUT5
*         DATA RECORD 1
*         DATA RECORD 2
*         DATA RECORD 3
*
*
*  WRITES TO FILE WITH DDNAME=SYSUT5
*  DATA RECORD 1
*  DATA RECORD 2
*  DATA RECORD 3
*
*  RETURN CODES:
*               0000 = ALL PROCESSING COMPLETED SUCCESSFULLY
*               0004 = IF DO NOT FIND 'DDNAME=' IN COL1 OF FIRST CARD
*               0008 = UNSUCCESSFUL OUTPUT FILE OPENING
*               0016 = UNSUCCESSFUL INPUT FILE OPENING
*
*
*
*
*
*
*
*
*
*
*
*
*
*
*
*
********************************************************************
         EJECT
R0       EQU   0
R1       EQU   1
R2       EQU   2
R3       EQU   3
R4       EQU   4
R5       EQU   5
R6       EQU   6
R7       EQU   7
R8       EQU   8
R9       EQU   9
R10      EQU   10
R11      EQU   11
R12      EQU   12
R13      EQU   13
R14      EQU   14
R15      EQU   15
         EJECT
* * * * *
*ENTRY *
* * * * *
*
*
         USING SMPCNTL,R15
         B     BEGIN
*
*
         DC    AL1(BEGIN-*),C'SMPCNTL &SYSDATE'
*
*
BEGIN    DS    0F
         STM   R14,R12,12(R13)   STORE REGISTERS
*
*
         DROP  R15
         USING SMPCNTL,R12       SET UP ADDRESSABILITY INTO PROGRAM
         LR    R12,R15
         LR    R2,R13            LOAD ADDR OF PROVIDED SAVE AREA IN GR2
         LA    R13,MYSAVE        LOAD ADDR OF MYSAVE AREA IN GR13
         ST    R13,8(R2)         FORWARD POINTER
         ST    R2,4(R13)         BACKWARD POINTER
         EJECT
***********************************************************************
*
* TEST PARAMETERS PASSED TO PROGRAM FROM JCL EXEC STATEMENT
* IF PARM=NUM: NUMBERING IN COLUMNS 73-80 OCCURS
* IF NO PARM OR PARM EQUALS ANYTHING OTHER THAN 'NUM': NO NUMBERING
*
***********************************************************************
         L     R2,0(R1)          R2 POINTS TO PARM LENGTH FIELD
         LH    R3,0(R2)          R3 CONTAINS LENGTH OF PARMS
         LTR   R3,R3
         BZ    SWITCH00          ZERO LENGTH
         CH    R3,=H'03'         LENGTH OF PARM=3?
         BNE   SWITCH00          NO
         CLC   2(3,R2),=C'NUM'   'NUM' IN PARM OPERAND?
         BNE   SWITCH00           NO
         MVI   SWITCH,X'01'       SWITCH = 01 :NUMBERING
         B     REFDCBS
SWITCH00 MVI   SWITCH,X'00'       SWITCH = 00 :NO NUMBERING
         EJECT
***********************************************************************
*
* SET UP BASE REGISTERS TO REFERENCE DCB CONSTANTS
*
* OPEN INPUT FILE : RETURN CODE 0016 IF UNSUCCESSFUL & TERMINATE
*
***********************************************************************
REFDCBS  DS    0H
         USING IHADCB,R5
*
         LA    R5,FILEIN         TO REFERENCE FILEIN DCB CONSTANTS
*
OPENIN   OPEN  (FILEIN,(INPUT))
         TM    DCBOFLGS,X'10'
         BO    NEXTR5
         BNO   SETCD16
*
NEXTR5   LA    R5,FILEOUT        TO REFERENCE FILEOUT DCB CONSTANTS
*
         EJECT
********************************************************************
* READ A RECORD
* LOOK FOR 'DDNAME=' IN FIRST RECORD
*   IF NO 'DDNAME=' RETURN CODE 0004 & TERMINATE
*
* IF NOT FIRST DDNAME CLOSE PREVIOUS OUTPUT FILE (UNLESS FOLLOWING
* FILE HAS SAME DDNAME)
*
* IF 'DDNAME=' ZERO OUT NUMBER FIELD (FOR COLS 73-80 OF OUTPUT REC)
* SAVE DDNAME FOR LATER USE
* INSERT DDNAME IN DCBDDNAM FIELD OF DCB
*
* IF NOT FIRST CARD & NOT DDNAME BRANCH TO PROCESS
*
********************************************************************
*
*
*
*
         BAL   R10,READ
*
FINDD    CLC   RECORD(7),=C'DDNAME='  CONTROL RECORD?
         BE    SAVEDD
         CLI   SAVDDNAM,C' '          1ST CARD DOES NOT HAVE 'DDNAME='
         BE    SETCD4
         B     PROCESS
*
SAVEDD   CLC   SAVDDNAM(8),DDNAM        FILE ALREADY OPEN?
         BNE   FIRSTREC
         BAL   R10,READ
         B     PROCESS
FIRSTREC CLI   SAVDDNAM,C' '            FIRST RECORD OF INPUT FILE?
         BE    MOVEDD
         CLOSE FILEOUT                  CLOSE OUTPUT FILE
MOVEDD   SP    NUMBER,NUMBER            ZERO OUT NUMBER
         MVC   SAVDDNAM(8),DDNAM        SAVE DDNAME
         MVC   DCBDDNAM(8),DDNAM        INSERT DDNAME INTO DCB
         EJECT
* * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *
*
* OPEN FILE
* IF OUTPUT FILE NOT OPENED RC=0008 & TERMINATE
*
* * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *
*
         OPEN  (FILEOUT,(OUTPUT))    OPEN OUTPUT FILE
         TM    DCBOFLGS,X'10'        TEST IF SUCCESSFUL OPENING
         BNO   SETCD8
         BAL   R10,READ
         B     FINDD
*
*
*
         EJECT
********************************************************************
*
* TEST SWITCH   : 00 NO NUMBERING IN COLS 73-80
*                 01 NUMBERING IN COLS 73-80
* IF SWITCH = 01: INCREMENT PACKED NUMBER BY 100,EDIT NUMBER & INSERT
*                 INTO COLS 73-80 OF OUTPUT RECORD
*
* WRITE RECORD TO OUTPUT FILE
*
* READ NEXT RECORD & BRANCH TO FINDD
*
*********************************************************************
*
*
PROCESS  CLI   SWITCH,X'00'
         BE    OUTPUT
         AP    NUMBER,=P'100'           INCREMENT NUMBER BY 100
         MVC   WKPATERN(10),EDPATERN    MOVE EDIT PATTERN TO WORK AREA
         ED    WKPATERN,NUMBER          EDIT PACKED FIELD 'NUMBER'
         MVC   OUTNUM(8),WKPATERN+2     DON'T WANT FILL CHARACTER
OUTPUT   MVC   OUTREC(72),RECORD        INPUT RECORD INTO OUTPUT FIELD
         PUT   FILEOUT,OUTREC
         BAL   R10,READ
         B     FINDD
         EJECT
***********************************************************************
*
* READ ROUTINE
*
***********************************************************************
         SPACE
         SPACE
READ     GET   FILEIN,RECORD
         BR    R10
         SPACE
         SPACE
         SPACE
         SPACE
***********************************************************************
*
* ERROR ROUTINES
*
***********************************************************************
SETCD4   MVC   RETCODE,=H'04'
         B     TERM
         SPACE
         SPACE
         SPACE
         SPACE
SETCD8   MVC   RETCODE,=H'08'        RETURN CODE 0004 IF
         B     SETCODE               UNSUCCESSFUL FILE OPENING
         SPACE
         SPACE
         SPACE
         SPACE
SETCD16  MVC   RETCODE,=H'16'
         B     SETCODE
         EJECT
* * *  * * * *
* CLOSE FILES
* * *  * * * *
*
*
*
TERM     CLOSE (FILEIN,,FILEOUT,)     CLOSE INPUT FILE
SETCODE  LH    15,RETCODE
*
* * * * * *
* RETURN *
* * * * * *
RETRN    L     13,MYSAVE+4       ADDR OF PROV'D SAVE AREA INTO GR13
         L     14,12(13)         LOAD DATA BACK INTO GR 14
         LM    0,12,12+4+4(13)   LOAD DATA BACK INTO GR'S 0 TO 12
         BR    14                ALWAYS BRANCH TO RETURN ADDR OF
*                                CALLING PGM
         EJECT
*
* * * * * * * * * * * *
*STORAGE DEFINITIONS *
* * * * * * * * * * * *
*
         LTORG
*
MYSAVE   DS    9D
RETCODE  DC    H'0'
RECORD   DS    0CL80
         DS    CL7
DDNAM    DS    CL8
         DS    CL65
SAVDDNAM DC    CL8' '
EDPATERN DC    X'F0202020202020202020'
NUMBER   DC    PL5'0'
WKPATERN DC    CL10' '
SWITCH   DS    CL1
OUTREC   DS    0CL80
         DC    CL72' '
OUTNUM   DS    CL8' '
*
         PRINT NOGEN
*
FILEIN   DCB   DSORG=PS,              PHSICAL SEQUENTIAL DATA SET      C
               DDNAME=SYSUT1,                                          C
               RECFM=FB,                                               C
               LRECL=80,                                               C
               MACRF=GM,                                               C
               EODAD=TERM
*
FILEOUT  DCB   DSORG=PS,              PHSICAL SEQUENTIAL DATA SET      C
               RECFM=FB,                                               C
               LRECL=80,                                               C
               MACRF=PM
*
         DCBD  DSORG=PS
*
SMPCNTL  CSECT
LOCALMOD DC    CL8'NZ90121'                                     NZ90121
         END
++SRC(SMPLMOD) DISTLIB(RXASRC).
SMPLMOD  CSECT
******************************************************************
*
*  PROGRAM SMPLMOD
*
*  EXTRACTS FROM AN SMP LISTCDS LMOD LISTING THE LINKAGE EDITOR
*  CONTROL STATEMENT KEYWORDS ' ENTRY ',' ALIAS ' & ' ORDER '
*  DDNAME: SYSUT1
*
*  WRITES OUT 80 BYTE RECORDS
*  DDNAME: SYSUT2
*
*  E.G.
*  INPUT: IGC0006A LASTUPD         = JCLIN    TYPE=ADD
*                  SYSTEM LIBRARY  = LPALIB
*                  LKED ATTRIBUTES = RENT
*                  LKED CONTROLS   =  ORDER IGC0006A(P)
*                                     ENTRY IGC0006A
*                                     ALIAS IGC0009G
*
*  GIVES OUTPUT:
*  ORDER IGC0006A(P)
*  ENTRY IGC0006A
*  ALIAS IGC0009G
*
*  RETURN CODES:
*               0000 = ALL PROCESSING COMPLETED SUCCESSFULLY
*               0004 = UNSUCCESSFUL INPUT &/OR OUTPUT FILE OPENING
*
*
*
*
*
*
*
*
*
*
*
*
*
*
*
*
******************************************************************
*
*
         EJECT
R0       EQU   0
R1       EQU   1
R2       EQU   2
R3       EQU   3
R4       EQU   4
R5       EQU   5
R6       EQU   6
R7       EQU   7
R8       EQU   8
R9       EQU   9
R10      EQU   10
R11      EQU   11
R12      EQU   12
R13      EQU   13
R14      EQU   14
R15      EQU   15
* * * * *
*ENTRY *
* * * * *
*
*
         USING SMPLMOD,R15       SET UP ADDRESSABILITY
         B     BEGIN
*
*
         DC    AL1(BEGIN-*),C'SMPLMOD &SYSDATE'
*
*
BEGIN    DS    0F
         STM   R14,R12,12(R13)   STORE REGISTERS
*
*
         DROP  R15
         USING SMPLMOD,R12       SET UP ADDRESSABILITY INTO PROGRAM
         LR    R12,R15
         LR    R2,R13            LOAD ADDR OF PROVIDED SAVE AREA IN GR2
         LA    R13,MYSAVE        LOAD ADDR OF MYSAVE AREA IN GR13
         ST    R13,8(R2)         FORWARD POINTER
         ST    R2,4(R13)         BACKWARD POINTER
*
*
* OPEN FILES
*
*
OPENFIL  OPEN  (FILEIN,(INPUT))      OPEN INPUT FILE
         TM    FILEIN+48,X'10'       TEST IF SUCCESSFUL OPENING
         BO    OPENOUT
         B     SETCD4
OPENOUT  OPEN  (FILEOUT,(OUTPUT))    OPEN OUTPUT FILE
         TM    FILEOUT+48,X'10'      TEST IF SUCCESSFUL OPENING
         BO    READ
*
*
SETCD4   MVC   RETCODE,=H'04'        RETURN CODE 0004 IF
         B     SETCODE               UNSUCCESSFUL FILE OPENING
*
*
* PROCESS: EXTRACT KEYWORDS 'ENTRY/ALIAS/ORDER'
*
*
READ     GET   FILEIN,RECORD         GET A RECORD
*
         LA    R4,RECORD+29          R4 POINTS TO 30TH COLUMN
COMPARE  CLC   0(7,R4),=C' ENTRY '   LOOK FOR ' ENTRY '
         BE    PRINT
         CLC   0(7,R4),=C' ALIAS '   LOOK FOR ' ALIAS '
         BE    PRINT
         CLC   0(7,R4),=C' ORDER '   LOOK FOR ' ORDER '
         BE    PRINT
*
         LA    R4,1(R4)              R4 POINTS TO NEXT COLUMN
         C     R4,ACOL87             DOES R4 POINT TO COL87?
         BL    COMPARE               NO: GOTO COMPARE
         BNL   READ                  YES: GOTO READ
*
PRINT    LA    R5,RECORD+100         R5 POINTS TO 101ST COL
         SR    R5,R4                 R5:LENGTH OF RECORD TO BE MOVED
         EX    R5,MOVE
         PUT   FILEOUT,OUTREC
         MVC   OUTREC,OUTREC-1
         B     READ
*
MOVE     MVC   OUTREC(1),0(R4)
*
* CLOSE FILES
*
*
EOF      CLOSE (FILEIN,,FILEOUT,)     CLOSE FILES
SETCODE  LH    15,RETCODE
*
* * * * * *
* RETURN *
* * * * * *
RETRN    L     13,MYSAVE+4       ADDR OF PROV'D SAVE AREA INTO GR13
         L     14,12(13)         LOAD DATA BACK INTO GR 14
         LM    0,12,12+4+4(13)   LOAD DATA BACK INTO GR'S 0 TO 12
         BR    14                ALWAYS BRANCH TO RETURN ADDR OF
*                                CALLING PGM
*
* * * * * * * * * * * *
*STORAGE DEFINITIONS *
* * * * * * * * * * * *
*
*
MYSAVE   DS    9D
RETCODE  DC    H'0'
RECORD   DC    CL121' '
         DC    CL1' '
OUTREC   DC    CL80' '
ACOL87   DC    A(RECORD+86)
*
         LTORG
         PRINT NOGEN
*
FILEIN   DCB   DSORG=PS,         PHYSICAL SEQUENTIAL DATA SET          C
               DDNAME=SYSUT1,    DATA SET BEING PROCESSED              C
               RECFM=FBA,        FIXED BLOCK RECORD FORMAT             C
               LRECL=121,        LOGICAL RECORD LENGTH                 C
               MACRF=GM,         MACRO=GET,TRANSMITTAL MODE=MOVE       C
               EODAD=EOF
*
FILEOUT  DCB   DSORG=PS,         PHYSICAL SEQUENTIAL DATA SET          C
               DDNAME=SYSUT2,    DATA SET BEING PROCESSED              C
               RECFM=FB,         FIXED BLOCK RECORD FORMAT             C
               LRECL=80,         LOGICAL RECORD LENGTH                 C
               MACRF=PM          MACRO=PUT,TRANSMITTAL MODE=MOVE
*
SMPLMOD  CSECT
LOCALMOD DC    CL8'NZ90121'                                     NZ90121
         END
++SRC(SMPPARS) DISTLIB(RXASRC).
SMPPARS  CSECT
* * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *
*
*  PROGRAM SMPPARS
*
*  EXTRACTS FROM THE STAGE2 I/O GEN JCL DECK THE NAMES OF ALL THE
*  MODULES/CSECTS SPECIFIED ON THE CARDS WITH KEYWORDS 'ALIAS',
*  'INCLUDE','NAME','ORDER','ENTRY' & 'SELECT'
*  DDNAME: SYSUT1
*
*  WRITES OUT 80 BYTE RECORDS
*  WITH MODULE/CSECT NAMES IN SORTED FORMATS
*  DDNAME: SYSUT2
*
*  E.G.
*  INPUT: SELECT MEMBER=(IGC019FR,IGC019FS)
*         INCLUDE SYSPUNCH(IEFWMAS1)
*         NAME DEVNAME(R)
*         ORDER IEFDB400
*         ALIAS IKJDAIR,IKJEFD00
*         ENTRY IKJEFLF
*
*
*  GIVES OUTPUT:
*  DEVNAME
*  IEFDB400
*  IEFWMAS1
*  IGC019FR
*  IGC019FS
*  IKJDAIR
*  IKJEFD00
*  IKFEFLF
*
*  RETURN CODES:
*               0000 = ALL PROCESSING COMPLETED SUCCESSFULLY
*               0004 = UNSUCCESSFUL INPUT &/OR OUTPUT FILE OPENING
*               0016 = TABLE IN SOURCE CODE NOT LARGE ENOUGH FOR
*                      ALL NAMES THAT OCCUR
*                      (IMPROBABLE: BUT IF HAPPENS CHANGE SOURCE CODE)
*
*
*
*
*
*
*
*
*
*
*
*
*
*
*
*
* * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *
         EJECT
R0       EQU   0
R1       EQU   1
R2       EQU   2
R3       EQU   3
R4       EQU   4
R5       EQU   5
R6       EQU   6
R7       EQU   7
R8       EQU   8
R9       EQU   9
R10      EQU   10
R11      EQU   11
R12      EQU   12
R13      EQU   13
R14      EQU   14
R15      EQU   15
         EJECT
* * * * *
*ENTRY *
* * * * *
*
*
         USING SMPPARS,R15
         B     BEGIN
*
*
         DC    AL1(BEGIN-*),C'SMPPARS &SYSDATE'
*
*
BEGIN    DS    0F
         STM   R14,R12,12(R13)   STORE REGISTERS
*
*
         DROP  R15
         USING SMPPARS,R12     SET UP ADDRESSABILITY INTO PROGRAM
         LR    R12,R15
         LR    R2,R13            LOAD ADDR OF PROVIDED SAVE AREA IN GR2
         LA    R13,MYSAVE        LOAD ADDR OF MYSAVE AREA IN GR13
         ST    R13,8(R2)         FORWARD POINTER
         ST    R2,4(R13)         BACKWARD POINTER
         EJECT
* * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *
*
* OPEN FILES
* IF INPUT &/OR OUTPUT FILES NOT OPENED RC=0004 & TERMINATE
*
* * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *
*
OPENFIL  OPEN  (FILEIN,(INPUT))      OPEN INPUT FILE
         TM    FILEIN+48,X'10'       TEST IF SUCCESSFUL OPENING
         BO    OPENOUT
         B     SETCD4
OPENOUT  OPEN  (FILEOUT,(OUTPUT))    OPEN OUTPUT FILE
         TM    FILEOUT+48,X'10'      TEST IF SUCCESSFUL OPENING
         BO    READ
*
*
SETCD4   MVC   RETCODE,=H'04'        RETURN CODE 0004 IF
         B     SETCODE               UNSUCCESSFUL FILE OPENING
*
         EJECT
* * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *
*
* PROCESSING: LOCATE KEYWORDS = ALIAS/INCLUDE/NAME/ORDER/SELECT
*
* 1) DISCARD ALL RECORDS WHICH DO NOT START
*    'ÖA','ÖI','ÖN','ÖO','ÖE' & 'ÖS'
*    WHERE Ö = ONE OR MORE SPACES
*
* 2) LOCATE EACH KEYWORD
*
* 3) FIND FIRST NON-BLANK CHARACTER AFTER KEYWORD
*
* 4) ENSURE THAT NON-BLANK CHARACTER IS PART OF LMOD/CSECT NAME
*
* 5) MOVE NAME INTO A WORK AREA CHARACTER BY CHARACTER
*
* 6) MOVE NAME INTO TABLE,FROM BACK TO FRONT OF TABLE
*    ENSURING THAT NAMES INSERTED INTO TABLE IN SORTED FORMAT
*
* 7) AT END OF INPUT FILE PRINT OUT EACH ENTRY IN TABLE
*
* * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *
*
         EJECT
READ     GET   FILEIN,RECORD          READ A RECORD
* * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *
*
* ONLY WANT RECORDS WITH FIRST CHARACTER BLANK
*
* * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *
         CLI   RECORD,X'40'           FIRST CHARACTER BLANK ?
         BNE   READ
         MVI   RECORD+71,X'FF'        SET COL72 = X'FF'
*
         LA    R7,RECORD+1            R7 POINTS TO 2ND CHARACTER
         BAL   R10,NONBLANK           FIND FIRST NON-BLANK CHARACTER
*
* * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *
*
* DISCARD ALL RECORDS WHICH DO NOT START 'ÖA','ÖI','ÖN','ÖO','ÖE','ÖS'
* WHERE Ö = ONE OR MORE SPACES
*
* * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *
*
LETTER   CLI   0(R7),C'A'             IS CHARACTER 'A' ?
         BE    ALIAS                  YES: GOTO PROCESS ALIAS
         CLI   0(R7),C'I'             IS CHARACTER 'I' ?
         BE    INCLUDE                YES: GOTO PROCESS INCLUDE
         CLI   0(R7),C'N'             IS CHARACTER 'N' ?
         BE    NAME                   YES: GOTO PROCESS NAME
         CLI   0(R7),C'O'             IS CHARACTER 'O' ?
         BE    ORDER                  YES: GOTO PROCESS ORDER
         CLI   0(R7),C'E'             IS  CHARACTER 'E' ?
         BE    ENTRY                  YES: GOTO PROCESS ENTRY
         CLI   0(R7),C'S'             IS CHARACTER 'S' ?
         BE    SELECT                 YES: GOTO PROCESS SELECT
         B     READ                   NO KEYWORD IN RECORD
*
         EJECT
* * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *
*
*
* PROCESS KEYWORDS:
*
* LOCATE EACH KEYWORD
* FIND FIRST NON-BLANK CHARACTER AFTER KEYWORD
*
* * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *
*
ALIAS    CLC   0(5,R7),=C'ALIAS'      DOES 'A' INDICATE 'ALIAS' ?
         BNE   COL72                  NOT 'ALIAS'
         LA    R7,6(R7)               R7 POINTS 2 BYTES ON FROM ALIAS
         BAL   R10,NONBLANK           FIND NEXT NON-BLANK CHARACTER
         B     IFCOL72                GOTO IFCOL72 ROUTINE
*
*
INCLUDE  CLC   0(7,R7),=C'INCLUDE'    DOES 'I' INDICATE 'INCLUDE' ?
         BNE   COL72                  NOT 'INCLUDE'
         LA    R7,8(R7)               R7 POINTS 2 CHS ON FROM INCLUDE
         BAL   R10,NONBLANK           FIND NEXT NON-BLANK CHARACTER
         CLI   0(R7),X'FF'            DOES R7 POINT TO COL72 ?
         BE    IFCOL72                GET NEXT RECORD
NEXTCH   LA    R7,1(R7)               R7 POINTS AT NEXT CHARACTER
         CLI   0(R7),X'4D'            DOES R7 POINT TO '(' ?
         BE    INCNAME                YES GOTO INCNAME
         CLI   0(R7),X'40'            DOES R7 POINT TO ' ' ?
         BE    COL72                  YES: GET NEXT RECORD
         CLI   0(R7),X'6B'            DOES R7 POINT TO ',' ?
         BE    COL72                  YES: GET NEXT RECORD
         BNE   NEXTCH                 NO: ADDRESS NEXT CHARACTER
INCNAME  LA    R7,1(R7)               ADDRESS NEXT CHARACTER
         B     IFCOL72
*
*
NAME     CLC   0(4,R7),=C'NAME'       DOES 'N' INDICATE 'NAME' ?
         BNE   COL72                  NOT 'NAME'
         LA    R7,5(R7)               R7 POINTS 2 CHS ON FROM NAME
         BAL   R10,NONBLANK           FIND NEXT NON-BLANK CHARACTER
         B     IFCOL72
*
*
ORDER    CLC   0(5,R7),=C'ORDER'      DOES 'O' INDICATE 'ORDER' ?
         BNE   COL72                  NOT 'ORDER'
         LA    R7,6(R7)               R7 POINTS 2 CHS ON FROM ORDER
         BAL   R10,NONBLANK           FIND NEXT NON-BLANK CHARACTER
         B     IFCOL72
*
*
ENTRY    CLC   0(5,R7),=C'ENTRY'      DOES 'E' INDICATE 'ENTRY' ?
         BNE   COL72                  NOT 'ENTRY'
         LA    R7,6(R7)               R7 POINTS 2 CHS ON FROM ENTRY
         BAL   R10,NONBLANK           FIND NEXT NON-BLANK CHARACTER
         B     IFCOL72
*
*
SELECT   CLC   0(6,R7),=C'SELECT'     DOES 'S' INDICATE 'SELECT' ?
         BNE   COL72                  NOT 'SELECT'
         LA    R7,7(R7)               R7 POINTS 2 CHS ON FROM SELECT
         BAL   R10,NONBLANK           FIND NEXT NON-BLANK CHARACTER
         LA    R7,7(R7)               R7 POINTS TO CH AFTER 'MEMBER='
         CLI   0(R7),X'4D'            DOES R7 POINT TO A '('
         BNE   IFCOL72                NO: GOTO IFCOL72
         LA    R7,1(R7)               YES: POINT R7 TO NEXT CH
         B     IFCOL72
*
         EJECT
* * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *
*
* ENSURE THAT HAVE NOT REACHED END OF RECORD
*
* ENSURE THAT NON-BLANK CHARACTER IS PART OF LMOD/CSECT NAME
* I.E. NOT ','    '('    ')'
* * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *
*
COL72    LA    R7,RECORD+71           R7 POINTS AT COL 72
IFCOL72  CLI   0(R7),X'FF'            IS COL 72 = X'FF'
         BE    READ                   YES: READ NEXT RECORD
*
* * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *
*
* MOVE LOAD MODULE/CSECT NAME INTO A WORK AREA (NAMEWORK)
* CHARACTER BY CHARACTER
*
* * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *
*
GETANAME MVC   NAMEWORK,NAMEWORK-1    BLANK OUT NAMEWORK
         LA    R8,NAMEWORK            R8 POINTS TO 1ST CH IN NAMEWORK
*
ISBLANK  CLI   0(R7),X'40'            DOES R7 POINT TO A BLANK ?
         BE    GOTNAME
         CLI   0(R7),X'6B'            DOES R7 POINT TO A COMMA ?
         BE    NEXT1
         CLI   0(R7),X'5D'            DOES R7 POINT TO ')'?
         BE    GOTNAME
         CLI   0(R7),X'4D'            DOES R7 POINT TO '('?
         BE    NEXT3
         CLI   0(R7),X'FF'            DOES R7 POINT TO COL72?
         BE    GOTNAME
*
         MVC   0(1,R8),0(R7)          STORE CHARACTER IN NAMEWORK
         LA    R7,1(R7)               R7: NEXT CH IN LMOD/CSECT NAME
         LA    R8,1(R8)               R8: NEXT CH IN NAMEWORK AREA
         B     ISBLANK
*
NEXT3    LA    R7,3(R7)               R7 POINTS 3 CHS ON
         B     ISBLANK
NEXT1    LA    R7,1(R7)               R7 POINTS 1 CH ON
*
GOTNAME  CLI   NAMEWORK,X'40'         IS FIRST CH OF NAMEWORK ' '?
         BE    READ                   NAMEWORK EMPTY, GET NEXT RECORD
*
         EJECT
* * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *
*
* FILL IN TABLE
*
* MOVE NAME INTO TABLE,FROM BACK TO FRONT OF TABLE
* ENSURING THAT NAMES INSERTED INTO TABLE IN SORTED FORMAT
*
* IF TABLE NOT LARGE ENOUGH RC=0016 & TERMINATE
*
* DO NOT CHANGE VALUE IN R9 (=8)
*
* * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *
*
         LA    R9,8                   LOAD VALUE 8 INTO R9
         L     R11,=A(TABLAST)        R11 ADDRESSES LAST TABLE ENTRY
COMPNAME CLC   NAMEWORK(8),0(11)      NAMEWORK > , < , = TABLE ENTRY
         BE    GETANAME               NAME ALREADY IN TABLE
         BL    PREVIOUS
*
         CLI   TABLE,X'00'            ROOM IN TABLE ?
         BNE   SETCD16                NO ROOM IN TABLE SET RC=16
*
         LA    R2,TABLE               R2 POINTS TO START OF TABLE
         LA    R4,TABLE+8             R4 POINTS TO 2ND ENTRY OF TABLE
         LR    R3,R11                 R3 POINTS TO SMALLER ENTRY
         SR    R3,R2                  FIND LENGTH TO BE SHIFTED
         LR    R5,R3                  R5 & R3 CONTAIN LENGTH TO SHIFT
         MVCL  R2,R4                  MOVE NAMES LEFT:FREEING SPACE
         MVC   0(8,R11),NAMEWORK      MOVE NAME INTO FREED SPACE
         B     GETANAME               GET NEXT NAME
*
*
PREVIOUS SLR   R11,R9                 R9 POINTS TO PREVIOUS NAME
         B     COMPNAME
*
SETCD16  MVC   RETCODE,=H'16'         SET RC=16 & TERMINATE
         B     TERM
*
         EJECT
* * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *
*
* TO FIND FIRST NON-BLANK CHARACTER POINTED TO BY R7
*
* * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *
*
NONBLANK CLI   0(7),X'40'             IS CHARACTER BLANK ?
         BNER  R10                    FOUND FIRST NON-BLANK CHARACTER
         LA    R7,1(R7)               R7 POINTS TO NEXT CHARACTER
         B     NONBLANK               TEST CHARACTER AGAIN
*
         EJECT
* * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *
*
* AT END OF INPUT FILE PRINT OUT EACH ENTRY IN TABLE
*
* * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *
*
EOF      L     R11,=A(TABLE-8)        ADDRESS 8 BYTES BEFORE TABLE
LOOP     DS    0H
         LA    R11,8(R11)             R11 POINTS TO ENTRY IN TABLE
         CLI   0(R11),X'FF'           DOES R11 POINT BEYOND TABLE ?
         BE    TERM                   YES: TERMINATE
         CLI   0(R11),X'00'           IS ENTRY POINTED TO EMPTY ?
         BE    LOOP                   YES: ADDRESS NEXT ENTRY
FILLOUT  MVC   OUTNAME(8),0(R11)      MOVE NAME INTO OUTPUT RECORD
         PUT   FILEOUT,OUTREC
         B     LOOP
*
         EJECT
* * *  * * * *
* CLOSE FILES
* * *  * * * *
*
TERM     CLOSE (FILEIN,,FILEOUT,)     CLOSE FILES
SETCODE  LH    15,RETCODE
*
* * * * * *
* RETURN *
* * * * * *
RETRN    L     13,MYSAVE+4       ADDR OF PROV'D SAVE AREA INTO GR13
         L     14,12(13)         LOAD DATA BACK INTO GR 14
         LM    0,12,12+4+4(13)   LOAD DATA BACK INTO GR'S 0 TO 12
         BR    14                ALWAYS BRANCH TO RETURN ADDR OF
*                                CALLING PGM
         EJECT
*
* * * * * * * * * * * *
*STORAGE DEFINITIONS *
* * * * * * * * * * * *
*
         LTORG
*
MYSAVE   DS    9D
RETCODE  DC    H'0'
RECORD   DC    CL80' '
         DC    CL1' '
NAMEWORK DS    CL8
OUTREC   DS    0CL80
         DC    CL10' '
OUTNAME  DS    CL8
         DC    CL62' '
*
         PRINT NOGEN
*
FILEIN   DCB   DSORG=PS,              PHSICAL SEQUENTIAL DATA SET      C
               DDNAME=SYSUT1,                                          C
               RECFM=FB,                                               C
               LRECL=80,                                               C
               MACRF=GM,                                               C
               EODAD=EOF
*
FILEOUT  DCB   DSORG=PS,              PHSICAL SEQUENTIAL DATA SET      C
               DDNAME=SYSUT2,                                          C
               RECFM=FB,                                               C
               LRECL=80,                                               C
               MACRF=PM
*
         DC    XL8'00'
TABLE    DC    2000XL8'00'
TABLAST  EQU   *-8
         DC    X'FF'
*
SMPPARS  CSECT
LOCALMOD DC    CL8'NZ90121'                                     NZ90121
         END
++SRC(SMPSCAN) DISTLIB(RXASRC).
SMPSCAN  CSECT
* * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *
*
*  PROGRAM SMPSCAN
*
*  EXTRACTS THE SYSMOD ID'S OF THOSE MODULES WITH UMID & RMID ID'S
*  DIFFERENT FROM THE FMID ID:GIVING A LIST OF THE SYSMODS THAT MAY
*  HAVE BEEN REGRESSED BY AN I/O GEN
*  DDNAME: SYSUT1
*
*  WRITES OUT 80 BYTE RECORDS
*  WITH SYSMOD ID'S IN SORTED FORMATS
*  DDNAME: SYSUT2
*
*  E.G.
*  INPUT: IGG0191N  LASTUPD         = JCLIN    TYPE=UPD
*                   LIBRARIES       = DISTLIB=AOSD0
*                   FMID            = EDM1102
*                   RMID            = UZ62568
*                   LKED ATTRIBUTES = RENT       REFR
*                   UMID            = AZ73702
*                   LMOD            = IGG0191A
*
*  GIVES OUTPUT:
*  AZ73702
*  UZ62568
*
*  RETURN CODES:
*               0000 = ALL PROCESSING COMPLETED SUCCESSFULLY
*               0004 = UNSUCCESSFUL INPUT &/OR OUTPUT FILE OPENING
*               0016 = TABLE IN SOURCE CODE NOT LARGE ENOUGH FOR
*                      ALL NAMES THAT OCCUR
*                      (IMPROBABLE: BUT IF HAPPENS CHANGE SOURCE CODE)
*
*
*
*
*
*
*
*
*
*
*
*
*
*
*
*
* * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *
         EJECT
R0       EQU   0
R1       EQU   1
R2       EQU   2
R3       EQU   3
R4       EQU   4
R5       EQU   5
R6       EQU   6
R7       EQU   7
R8       EQU   8
R9       EQU   9
R10      EQU   10
R11      EQU   11
R12      EQU   12
R13      EQU   13
R14      EQU   14
R15      EQU   15
         EJECT
* * * * *
*ENTRY *
* * * * *
*
*
         USING SMPSCAN,R15
         B     BEGIN
*
*
         DC    AL1(BEGIN-*),C'SMPSCAN &SYSDATE'
*
*
BEGIN    DS    0F
         STM   R14,R12,12(R13)   STORE REGISTERS
*
*
         DROP  R15
         USING SMPSCAN,R12       SET UP ADDRESSABILITY INTO PROGRAM
         LR    R12,R15
         LR    R2,R13            LOAD ADDR OF PROVIDED SAVE AREA IN GR2
         LA    R13,MYSAVE        LOAD ADDR OF MYSAVE AREA IN GR13
         ST    R13,8(R2)         FORWARD POINTER
         ST    R2,4(R13)         BACKWARD POINTER
         EJECT
* * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *
*
* OPEN FILES
* IF INPUT &/OR OUTPUT FILES NOT OPENED RC=0004 & TERMINATE
*
* * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *
*
OPENFIL  OPEN  (FILEIN,(INPUT))      OPEN INPUT FILE
         TM    FILEIN+48,X'10'       TEST IF SUCCESSFUL OPENING
         BO    OPENOUT
         B     SETCD4
OPENOUT  OPEN  (FILEOUT,(OUTPUT))    OPEN OUTPUT FILE
         TM    FILEOUT+48,X'10'      TEST IF SUCCESSFUL OPENING
         BO    READ
*
*
SETCD4   MVC   RETCODE,=H'04'        RETURN CODE 0004 IF
         B     SETCODE               UNSUCCESSFUL FILE OPENING
*
         EJECT
* * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *
*
* PROCESSING
*
* SWITCH = 00  UNTIL REACH FIRST GROUP STARTING 'LASTUPD'
* SWITCH = 01  AFTERWARDS
*
* EOFSW = 00  AS LONG AS END OF FILE NOT REACHED
* EOFSW = 01  AT EOF
*
*
* SWITCH = 00: READ A RECORD UNTIL FIND 'LASTUPD' AT OFFSET 12
* SWITCH = 01: READ A RECORD LOOK FOR KEYWORD FMID/RMID/UMID
*              IF 'FMID' SET SAVFMID,SAVRMID & SAVUMID TO FMID ID
*              IF 'RMID' SET SAVRMID TO RMID ID
*              IF 'UMID' SET SAVUMID TO UMID ID
*              ELSE IGNORE
*
* IF 'LASTUPD':ADD RMID ID & UMID ID OF PREVIOUS LASTUPD GROUP
*              TO TABLE UNLESS ID = FMID ID
*              LOOK FOR KEYWORD IN CURRENT LASTUPD GROUP
*
* AT EOF(EOFSW=01): ADD RMID ID & UMID ID OF LAST LASTUPD GROUP
*                   TO TABLE UNLESS ID = FMID ID
*                   PRINT TABLE
*
* * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *
*
         EJECT
READ     GET   FILEIN,RECORD          READ A RECORD
*
         CLC   RECORD+11(7),=C'LASTUPD'
         BNE   SW0OR1                      REACHED LASTUPD GROUPS?
         MVI   SWITCH,X'01'                YES:SWITCH NOW 01
*
COMPRMID CLC   SAVFMID(7),SAVRMID          FMID ID =RMID ID ?
         BE    COMPUMID                    YES:GOTO COMPUMID
         MVC   NAMEWORK(7),SAVRMID         NO:MOVE ID INTO NAMEWORK
         BAL   R10,FILLTAB
*
COMPUMID CLC   SAVFMID(7),SAVUMID          FMID ID = UMID ID ?
         BE    WATSWICH
         MVC   NAMEWORK(7),SAVUMID         NO:MOVE ID INTO NAMEWORK
         BAL   R10,FILLTAB
WATSWICH CLI   EOFSW,X'01'                 EOF?
         BE    PRINT
         B     READ
*
         EJECT
SW0OR1   CLI   SWITCH,X'00'                REACHED LASTUPD GROUPS?
         BE    READ                        NO: READ NEXT RECORD
*
IFFMID   CLC   RECORD+11(4),=C'FMID'       FOUND 'FMID'?
         BNE   IFRMID                      NO:TEST IF FOUND 'RMID'
         MVC   SAVFMID(7),RECORD+29        YES:SAVFMID = FMID ID
         MVC   SAVRMID(7),RECORD+29            SAVRMID = FMID ID
         MVC   SAVUMID(7),RECORD+29            SAVUMID = FMID ID
         B     READ                        READ NEXT RECORD
*
IFRMID   CLC   RECORD+11(4),=C'RMID'       FOUND 'RMID'?
         BNE   IFUMID                      NO:TEST IF FOUND 'UMID'
         MVC   SAVRMID(7),RECORD+29        YES:SAVRMID = RMID ID
         B     READ
*
IFUMID   CLC   RECORD+11(4),=C'UMID'       FOUND 'UMID'?
         BNE   READ                        NO:GET NEXT RECORD
         MVC   SAVUMID(7),RECORD+29        YES:SAVUMID = UMID ID
         B     READ
*
         EJECT
* * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *
*
* FILL IN TABLE
*
* MOVE NAME INTO TABLE,FROM BACK TO FRONT OF TABLE
* ENSURING THAT NAMES INSERTED INTO TABLE IN SORTED FORMAT
*
* IF TABLE NOT LARGE ENOUGH RC=0016 & TERMINATE
*
*
* * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *
*
FILLTAB  LA    R9,7                   LOAD VALUE 7 INTO R9
         L     R11,=A(TABLAST)        R11 ADDRESSES LAST TABLE ENTRY
COMPNAME CLC   NAMEWORK(7),0(11)      NAMEWORK > , < , = TABLE ENTRY
         BE    ENDFILL                NAME ALREADY IN TABLE
         BL    PREVIOUS
*
         CLI   TABLE,X'00'            ROOM IN TABLE ?
         BNE   SETCD16                NO ROOM IN TABLE SET RC=16
*
         LA    R2,TABLE               R2 POINTS TO START OF TABLE
         LA    R4,TABLE+7             R4 POINTS TO 2ND ENTRY OF TABLE
         LR    R3,R11                 R3 POINTS TO SMALLER ENTRY
         SR    R3,R2                  FIND LENGTH TO BE SHIFTED
         LR    R5,R3                  R5 & R3 CONTAIN LENGTH TO SHIFT
         MVCL  R2,R4                  MOVE NAMES LEFT:FREEING SPACE
         MVC   0(7,R11),NAMEWORK      MOVE NAME INTO FREED SPACE
*
*
ENDFILL  MVC   NAMEWORK,NAMEWORK-1    CLEAR NAMEWORK
         BR    R10
*
PREVIOUS SLR   R11,R9                 R9 POINTS TO PREVIOUS NAME
         B     COMPNAME
*
SETCD16  MVC   RETCODE,=H'16'         SET RC=16 & TERMINATE
         B     TERM
*
         EJECT
* * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *
*
* AT END OF INPUT FILE PRINT OUT EACH ENTRY IN TABLE
*
* * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *
*
EOF      MVI   EOFSW,X'01'            TURN EOF SWITCH ON
         B     COMPRMID
PRINT    L     R11,=A(TABLE-7)        ADDRESS 7 BYTES BEFORE TABLE
LOOP     DS    0H
         LA    R11,7(R11)             R11 POINTS TO ENTRY IN TABLE
         CLI   0(R11),X'FF'           DOES R11 POINT BEYOND TABLE ?
         BE    TERM                   YES: TERMINATE
         CLI   0(R11),X'00'           IS ENTRY POINTED TO EMPTY ?
         BE    LOOP                   YES: ADDRESS NEXT ENTRY
FILLOUT  MVC   OUTNAME(7),0(R11)      MOVE NAME INTO OUTPUT RECORD
         PUT   FILEOUT,OUTREC
         B     LOOP
*
         EJECT
* * *  * * * *
* CLOSE FILES
* * *  * * * *
*
TERM     CLOSE (FILEIN,,FILEOUT,)     CLOSE FILES
SETCODE  LH    15,RETCODE
*
*
*
* * * * * *
* RETURN *
* * * * * *
*
*
*
RETRN    L     13,MYSAVE+4       ADDR OF PROV'D SAVE AREA INTO GR13
         L     14,12(13)         LOAD DATA BACK INTO GR 14
         LM    0,12,12+4+4(13)   LOAD DATA BACK INTO GR'S 0 TO 12
         BR    14                ALWAYS BRANCH TO RETURN ADDR OF
*                                CALLING PGM
         EJECT
         PRINT NOGEN
*
FILEIN   DCB   DSORG=PS,              PHSICAL SEQUENTIAL DATA SET      C
               DDNAME=SYSUT1,                                          C
               RECFM=FBA,                                              C
               LRECL=121,                                              C
               MACRF=GM,                                               C
               EODAD=EOF
*
FILEOUT  DCB   DSORG=PS,              PHSICAL SEQUENTIAL DATA SET      C
               DDNAME=SYSUT2,                                          C
               RECFM=FB,                                               C
               LRECL=80,                                               C
               MACRF=PM
*
*
* * * * * * * * * * * *
*STORAGE DEFINITIONS *
* * * * * * * * * * * *
*
         LTORG
*
MYSAVE   DS    9D
RETCODE  DC    H'0'
RECORD   DC    CL121' '
         DC    CL1' '
NAMEWORK DC    CL7' '
SAVFMID  DC    XL7'00'
SAVRMID  DC    XL7'00'
SAVUMID  DC    XL7'00'
SWITCH   DC    XL1'00'
EOFSW    DC    XL1'00'
OUTREC   DS    0CL80
         DC    CL10' '
OUTNAME  DS    CL7
         DC    CL63' '
*
         DC    XL7'00'
TABLE    DC    2000XL7'00'
TABLAST  EQU   *-7
         DC    X'FF'
*
SMPSCAN  CSECT
LOCALMOD DC    CL8'NZ90121'                                     NZ90121
         END
