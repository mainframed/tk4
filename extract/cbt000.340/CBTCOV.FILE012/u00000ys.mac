AMM. TITLE 'RT5003M - CARD IMAGE DATA SET LISTING UTILITY - A.MORRISH.'
         PUNCH '   ENTRY       RT5003M'
         PUNCH '   ALIAS       RTPPRNT'
         EJECT                                                        *
RT5003M  CSECT
***********************************************************************
*                                                                     *
*              VERSION 3     LEVEL 3.                                 *
*  THIS PROGRAMME PRODUCES A SELECTIVE LISTING OF ANY LIBRARY OF 80   *
* BYTE RECORDS. THIS LISTING MAY BE BY TYPE AND APPLICATION AND/OR    *
* MEMBER NAME. GROUP AND APPLICATION INDICATORS ARE HELD IN THE SSI   *
* OF THE DIRECTORY ENTRY FOR A MEMBER AND INTERPRETED BY REFERENCE TO *
* THE CSECT TSGAM07.                                                  *
*                                                                     *
*  THE PROGRAMME MAINTAINS A LINE COUNT ON OUTPUT AND WILL PLACE MORE *
* THEN ONE MEMBER (WITH THE SAME GROUP AND APPLICATION) ON A PAGE     *
* UNLESS THE LATER MEMBER CAN BE HELD ON ONE PAGE IF STARTED AT THE   *
* HEAD OF A PAGE BUT MUST BE SPLIT IF STARTED ON THE SAME PAGE AS THE *
* EARLIER MEMBER.                                                     *
*                                                                     *
*  OPTIONS AVAILABLE ARE :                                            *
*                                                                     *
*              PRINT               DEFAULT.                           *
*              PUNCH               SPECIFIED BY SYSIN CONTROL CARD.   *
*                                                                     *
*              LIST ALL MEMBERS    DEFAULT.                           *
*              LIST SELECTED TYPE  SPECIFIDD IN PARAMETER LIST.       *
*              LIST SELECTED NAME  SPECIFIED BY SYSIN CONTROL CARD.   *
*                                                                     *
*              LINES PER PAGE      PARAMETER LIST (DEFAULT = 56).     *
*                                                                     *
*              NUMBER OF COPIES    PARAMETER LIST (DEFAULT = 1).      *
*                                                                     *
*
*  THIS PROGRAM ISSUES A LINK TO RTPDIRD, AND RTPDIRD MUST EITHER BE
*  PLACED IN ONE OF YOUR LNKLST LIBRARIES OR BE AVAILABLE IN STEPLIB OR
*  JOBLIB LIBRARY WHEN RTPPRNT IS EXECUTED
*
***********************************************************************
         SPACE 1
* V3 L1  DATA SET MAY BE SDS OR A MEMBER OF A PDS.                  3.1
* V3 L2  RTPDIRD ENTERED BY LINK. RTPOPEN REPLACED BY DCB EXIT.     3.2
* 09630000-09635000   06.10.70                                      3.2
* V3 L3  TITLE MAY BE SPECIFIED AS DATA SET NAME. SSI PRINTED ONLY  3.3
*        IF PRESENT. USER GROUPS ADDED. PUNCH IMPLEMENTED.          3.3
* 03560000-03600000,14860000-14860000                      29.06.71 3.3
         SPACE 2
*        GENERAL PURPOSE REGISTER USAGE.
         SPACE 1
R0       EQU   0                   WORK REGISTER.
R1       EQU   1                   WORK REGISTER / PARAMETER REGISTER.
R2       EQU   2                   WORK REGISTER.
R3       EQU   3                   WORK REGISTER / RETURN ADDRESS.
R4       EQU   4                   RETURN ADDRESS.
R5       EQU   5                   CURRENT RECORD ADDRESS IN DYNAMIC AR
R6       EQU   6                   LAST RECORD ADDRESS IN DYNAMIC AREA.
R7       EQU   7                   RESIDUAL LINE COUNT.
R8       EQU   8                   CURRENT MEMBER NAME ADDRESS.
R9       EQU   9
R10      EQU   10                  ADDRESS OF TSGAM07 CSECT.
R11      EQU   11
RBASE    EQU   12                  BASE REGISTER.
R13      EQU   13                  SAVE AREA POINTER.
R14      EQU   14                  RETURN ADDRESS.
R15      EQU   15                  ENTRY POINT ADDRESS / RETURN CODE.
         EJECT
*        BEGIN SAVE,BASE=RBASE
         STM   14,12,12(13)
         BALR  RBASE,0
         USING *,RBASE
         LA    15,SAVE
         ST    15,8(13)
         ST    13,4(15)
         LR    13,15
         L     R10,TABPTR          SET GR10 -> TABLE CSECT.
         SPACE 1
***********************************************************************
*                                                                     *
*        TRANSLATE PARAMETERS AND USE DEFAULTS IF OMITTED.            8
*                                                                     *
***********************************************************************
         SPACE 1
         L     R9,0(R1)            SET GR9 -> PARAMETER LIST.
         LH    R0,0(R9)            SET GR0 = PARAMETER LIST LENGTH.
         LTR   R0,R0               TEST FOR NULL PARAMETER LIST.
         BZ    PARMEND             IF NULL THEN USE DEFAULTS.
         LA    R9,2(R9)            SET GR9 -> FIRST PARA,ETER.
         AR    R0,R9               SET GR0 -> END OF PARAMETER LIST.
PARMLOOP LA    R6,KEYTAB2-KEYTAB   SET GR6 = LENGTH OF KEY TABLE ENTRY.
         LA    R4,KEYTAB           SET GR4 -> KEY-WORD TABLE.
         LA    R7,KEYTABND         SET GR7 -> END OF KEY-WORD TABLE.
         SR    R5,R5               SET GR5 = 0.
         IC    R5,KEYLNG(R4)       SET GR5 = LENGTH FOR EXEC.
         EX    R5,PARMCLC          COMPARE KEY-WORD WITH TABLE ENTRY.
         BE    *+12                IF EQUAL THEN GO TO PROCESS.
         BXLE  R4,R6,*-12          LOOP UNTIL TABLE EXHAUSTED.
         B     ERR01               IF NOT FOUND THEN ERROR.
         LA    R1,1(R9,R5)         SET GR1 -> KEY-WORD OPERAND.
         IC    R5,KEYIDM(R4)       SET GR5 = IDENTIFIER.
         EX    R5,PARMTM           CHECK FOR PREVIOUS USE OF PARAMETER.
         BO    ERR01               IF PREVIOUS USE THEN ERROR.
         OC    OPTSW(1),KEYIDM(R4) SET ON USE SWITCH.
         BAL   R14,KEYBRN(R4)      GO TO APPROPRIATE SUB-ROUTINE.
         CR    R1,R0               COMPARE FOR END OF PARAMETER LIST.
         BE    PARMEND             IF SO THEN EXIT.
         CLI   0(R1),C' '          IS NEXT CHARACTER A BLANK ?
         BE    PARMEND             IF SO THEN EXIT.
         CLI   0(R1),C','          IS NEXT CHARACTER A COMMA ?
         BNE   ERR01               IF NOT THEN ERROR.
         LA    R9,1(R1)            SET GR9 -> NEXT PARAMETER.
         B     PARMLOOP            GO TO CHECK NEXT KEY-WORD.
PARMCLC  CLC   0(0,R9),KEYWRD(R4)  MODEL STATEMENT.
PARMTM   TM    OPTSW,0             MODEL STATEMENT.
PARMEND  DS    0H
         SPACE 1
***********************************************************************
*                                                                     *
*        SET UP SPACE FOR ONE PAGE OF DATA.
*                                                                     *
***********************************************************************
         SPACE 1
         LH    R2,NOLNS            SET GR2 = NUMBER OF LINES / PAGE.
         TM    SW,SWNS             TEST WHETHER SUB-TITLES ARE REQUIRED
         BO    *+8                 IF NOT THEN SKIP SUB-TITLE DECREMENT
         S     R2,F2               DECREMENT GR2 FOR SUB-TITLE
         S     R2,F3               DECREMENT GR2 FOR TITLE
         BP    *+8                 USE LENGTH IF VALID.
         LA    R2,51               SET GR2 = DEFAULT PAGE SIZE.
         STH   R2,NOLNS            STORE NUMBER OF DATA LINES / PAGE.
         LA    R2,1(R2)            SET GR2 = LINES REQ'D FOR ONE PAGE.
         MH    R2,F80+2            SET GR2 = SPACE REQ'D FOR ONE PAGE.
         GETMAIN R,LV=(R2)         OBTAIN DYNAMIC STORAGE SPACE.
         ST    R1,LNFRST+4         STORE START ADDRESS OF LINES.
         AR    R1,R2               SET GR1 -> END OF LINE LIST.
         ST    R1,LNFRST           STORE END ADDRESS OF LINES.
         SPACE 1
***********************************************************************
*                                                                     *
*        SCAN TIOT FOR SYSIN, SYSUT1, SYSLIB AND SYSPRINT.            *
*                                                                     *
***********************************************************************
         SPACE 1
         L     R1,16               SET GR1 -> CVT
         L     R1,0(R1)            SET GR1 -> TCB POINTERS.
         L     R1,4(R1)            SET GR1 -> CURRENT TCB.
         L     R1,12(R1)           SET GR1 -> TIOT.
         LA    R1,24(R1)           SET GR1 -> 1ST DD ENTRY IN TIOT.
         SR    R0,R0               SET GR0 = 0.
DDNEXT   LM    R3,R5,DDLOOPC       INITIALISE GRS 3,4,5 FOR LOOP.
         CLC   4(8,R1),4(R3)       COMPARE FOR DDNAME.
         BE    *+12                IF EQUAL THEN GO TO STORE UCB PTR.
         BXLE  R3,R4,*-10          LOOP UNTIL FOUND OR LIST EXHAUSTED.
         B     *+20                IF NOT FOUND THEN NO STORE.
         TM    0(R3),X'80'         IS DD ALREADY PRESENT ?
         BO    *+12                IF SO THEN NO STORE.
         ST    R1,0(R3)            STORE TIOT DD-ENTRY POINTER.
         OI    0(R3),X'80'         SET ON DD PRESENT SWITCH
         IC    R0,0(R1)            SET GR0 = LENGTH OF DD-ENTRY.
         BXH   R1,R0,DDNEXT        LOOP UNTIL END FOUND.
         SPACE 1                                                    3.1
*                                                                   3.1
*        OBTAIN DSCB TO DETERMONE DSORG.                            3.1
*                                                                   3.1
         SPACE 1                                                    3.1
         L     R3,DDLIB            SET GR3 -> SYSLIB DD ENTRY.      3.3
         LTR   R3,R3               TEST SIGN OF GR3.                3.3
         BNM   ERR02               IF NOT MINUS THEN ERROR.         3.1
         RDJFCB MF=(E,OPENL5)      READ JOB FILE CONTROL BLOCK.     3.1
         L     R1,16(R3)           SET GR1 -> UCB FOR SYSLIB.       3.3
         CLI   18(R1),X'20'        IS DEVICE A DASD ?               3.3
         BNE   SETSEQ              IF NOT THEN MUST BE SEQUENTIAL.  3.3
         OBTAIN CAMLST             OBTAIN DSCB.                     3.1
         LTR   R15,R15             TEST RETURN CODE.                3.1
         BNZ   ERR03               IF NOT ZERO THEN ERROR.          3.1
         TM    DSCB+38,X'02'       IS DSORG PO ?                    3.1
         BZ    SETSEQ              IF NOT THEN GO TO SET PS.        3.3
         TM    JFCB+86,X'01'       IS DATA SEF MEMBER OF PDS ?      3.1
         BZ    *+16                IF NOT THEN USE FILL PDS.        3.1
SETSEQ   OI    SW1,SWPSE+SWPSF     SET PS EXPECTED AND FOUND.       3.3
         MVI   LIB+46,X'40'        SET DSORG=PS IN DCB.             3.1
         B     NODIRD              GO TO SKIP DIRECTORY READ.       3.1
         SPACE 1
***********************************************************************
*                                                                     *
*        READ DIRECTORY OF SYSLIB.                                    *
*                                                                     *
***********************************************************************
         SPACE 1
         TM    DDLIB,X'80'         IS SYSLIB DATA SET PRESENT ?
         BZ    ERR02               IF NOT THEN ERROR.
         LA    R1,DIRPARM          SET GR1 -> DIRECTORY READ PARAMETERS
         LINK  SF=(E,DIRLINK),MF=(E,(1)) LINK TO READ DIRECTORY.    3.2
         C     R15,F4              COMPARE RETURN CODE WITH 4.
         BH    ERR03               IF GREATER THEN ERROR.
         SPACE 1
***********************************************************************
*                                                                     *
*        SET OFF ALL ALIAS AND TTR INDICATORS.                        *
*                                                                     *
***********************************************************************
         SPACE 1
         L     R2,DIRPARM          SET GR2 -> DYNAMIC AREA.
         LH    R1,DIRPARM+4        SET GR1 = LENGTH OF AREA.
         LH    R0,2(R2)            SET GR0 = LENGTH PRR MEMBER.
         AR    R1,R2               SET GR1 -> END OF DYNAMIC AREA.
         SR    R1,R0               DECREMENT GR1 FOR COUNT.
         LA    R2,4(R2)            SET GR2 -> FIRST MEMBER.
         MVI   11(R2),0            SET OFF ALIAS AND TTR INDICATORS.
         BXLE  R2,R0,*-4           LOOP UNTIL END OF MEMBERS.
         SPACE 1
***********************************************************************
*                                                                     *
*        READ SYSIN CONTROL CARDS.
*                                                                     *
***********************************************************************
         SPACE 1
NODIRD   TM    DDIN,X'80'          IS SYSIN PRESENT ?
         BZ    SINEXIT             IF NOT THEN USE DEFAULTS.
         OPEN  MF=(E,OPENL1)       OPEN SYSIN DATA SET.
SINGET   GET   IN                  READ SYSIN DATA SET.
         LA    R2,C' '             SET GR2 FOR EXECUTE.
         BAL   R14,SUB1            LINK TO FIND END OF NAME.
         BE    *+4                 RETURN WHEN FOUND.
         BAL   R14,SUB1            LINK TO FIND OPERATION.
         BNE   *+4                 RETURN WHEN FOUND.
         CLC   0(6,R1),CTITLE      IS TITLE SPECIFIED ?
         BE    SINTITLE            IF SO THEN GO TO PROCESS TITLE.
         CLC   0(7,R1),CMEMBER     IS MEMBER SPECIFIED ?
         BE    SINMEMB             IF SO THEN GO TO PROCESS MEMBER.
         CLC   CPRINT,0(R1)        IS PRINT SPECIFIED ?             3.1
         BE    SINPRINT            IF SO THEN GO TO PROCESS PRINT.  3.1
         CLC   CPUNCH,0(R1)        IS PUNCH SPECIFIED ?             3.3
         BNE   SINGET              IF NOT THEN IGNORE INVALID CARD. 3.3
         MVI   TITLE,X'03'         )                                3.3
         MVI   SPACE1,X'63'        )                                3.3
         MVI   SPACE2,X'63'        )    SET ALL CODES TO PUNCH.     3.3
         MVI   SPACE3,X'63'        )                                3.3
         MVI   SKIPC1,X'63'        )                                3.3
         MVI   BUFFER,X'03'        )                                3.3
         B     SINGET              GO TO READ NEXT CARD.
SINTITLE LA    R1,6(R1)            SET GR1 -> FIRST BYTE AFTER TITLE ID
         BAL   R14,SUB1            LINK TO FIND OPERAND.
         BNE   *+4                 RETURN WHEN FOUND.
         CLC   0(5,R1),CITEM       COMPARE IDENT WITH 'ITEM='.
         BNE   SINGET              IF NOT THEN IGNORE CARD.
         LA    R3,TITLE+1          SET GR3 -> START OF TITLE.
         LA    R4,48               SET GR4 -> LENGTH OF TITLE.
         LA    R1,1(R1)            SET GR1 -> USER TITLE.ITEM.
         CLI   0(R1),C'('          IS FIRST BYTE PARENTHESIS ?
         BNE   *+8                 IF NOT THEN MUST BE QUOTE.
         LA    R1,1(R1)            INCREMENT GR1 FOR QUOTE.
         CLI   0(R1),C''''         IS FIRST BYTE A QUOTE ?
         BNE   SINGET              IF NOT THEN GO TO READ SYSIN.
         LA    R1,1(R1)            SET GR1 -> FIRST BYTE AFTER QUOTE.
         LR    R5,R1               SAVE ADDRESS FOR MOVE.
         LA    R2,C''''            SET GR2 FOR EXECUTE.
SINLOOP1 BAL   R14,SUB1            LINK TO FIND QUOTE.
         BE    *+4                 RETURN WHEN FOUND.
         SR    R1,R5               SET GR1 = LENGTH FOR MOVE.
         BNP   SINNULLT            IF ZERO THEN NO MOVE.
         SR    R4,R1               SET GR4 = RESIDUAL LENGTH.
         BP    *+6                 IF PLUS THEN MOVE IS OK.
         AR    R1,R4               SET GR1 = RESIDUAL LENGTH ALLOWED.
         MVI   TITLE+1,C' '        BLANK FIRST BYTE OF DEFAULT TITLE.
         MVC   TITLE+2(47),TITLE+1 BLANK DEFAULT TITLE.
         BCTR  R1,R0               DECREMENT GR1 FOR MOVE.
         EX    R1,SINMVC1          MOVE TITLE TO TITLE AREA.
SINNULLT LA    R3,1(R3,R1)         SET GR3 -> NEXT CHAR IN TITLE.
         LA    R5,1(R5,R1)         SET GR5 -> NEXT CHAR IN ITEM.
         LR    R1,R5               SET GR1 -> NEXT CHAR IN ITEM.
         CLI   1(R1),C''''         IS DOUBLE QUOTE SPEC'D ?
         BNE   SINGET              IF NOT THEN GO TO READ NEXT SYSIN.
         LA    R1,1(R1)            INCREMENT GR1 FOR NEXT.
         LTR   R4,R4               TEST SIGN OF GR4.
         BP    SINLOOP1            GO TO SCAN REMAINDER
         B     SINGET              GO TO READ NEXT CARD.
SINMEMB  LA    R1,7(R1)            SET GR1 -> 1ST BYTE AFTER MEMBER ID.
         BAL   R14,SUB1            LINK TO FIND OPERAND.
         BNE   *+4                 RETURN WHEN FOUND.
         CLC   0(5,R1),CNAME       COMPARE IDENT WITH 'NAME='
         BNE   SINGET              IF NOT THEN IGNORE CARD.
         LA    R1,5(R1)            SET GR1 -> FIRST CHAR AFTER NAME ID.
         CLI   0(R1),C'('          ARE MULTIPLE NAMES SPECIFIED ?
         BNE   *+8                 IF NOT THEN GO TO STORE 1 MEMBER.
         LA    R1,1(R1)            SET GR1 -> FIRST MEMBER SPEC'D.
SINLOOP4 LR    R5,R1               SET GR5 -> FIRST MEMBER NAME SPEC'D.
         LA    R0,9                SET COUNT FOR LOOP .
SINLOOP2 CLI   0(R1),C','          COMPARE FOR DELIMITER.
         BE    SINNMFND            IF FOUND THEN GO TO PROCESS.
         CLI   0(R1),C')'          COMPARE FOR DELIMITER.
         BE    SINNMFND            IF FOUND THEN GO TO PROCESS.
         CLI   0(R1),C' '          COMPARE FOR DELIMITER.
         BE    SINNMFND            IF FOUND THEN GO TO PROCESS.
         LA    R1,1(R1)            INCREMENT GR1 FOR NEXT CHARACTER.
         BCT   R0,SINLOOP2         LOOP UNTIL FOUND.
         B     SINGET              IF INVALID NAME THEN GO TO NEXT CARD
SINNMFND SR    R1,R5               SET GRI = LENGTH OF CHARACTER.
         BZ    SINONAME            IF ZERO THEN NAME IS OMITTED.
         MVI   DOUBWD,C' '         BLANK FIRST BYTE OF DOUBLE WORD.
         MVC   DOUBWD+1(7),DOUBWD  BLANK REMAINDER OF DOUBLE WORD.
         BCTR  R1,R0               DELREMENT GR1 FOR EXECUTE.
         EX    R1,SINMVC2          MOVE MEMBER NAME TO WORK AREA.
         LA    R5,1(R5,R1)         SET GR5 -> DELIMITER.
         L     R1,DIRPARM          SET GR3 -> BUILD LIST.
         LH    R0,0(R1)            SET GR0 = NUMBER OF ENTRIES.
         LH    R2,2(R1)            SET GR2 = BYTES PER ENTRY.
         LA    R3,4(R1)            SET GR3 -> FIRST MEMBER.
SINLOOP3 CLI   0(R3),X'FF'         IS IT END OF LIST ?
         BE    SINONAME            IF SO THEN NAME NOT FOUND.
         CLC   DOUBWD,0(R3)        COMPARE NAMES.
         BE    SINNAME             IF SO THEN GO TO SET NAME REQ'D.
         AR    R3,R2               SET GR3 -> NEXT MEMBER.
         BCT   R0,SINLOOP3         LOOP UNTIL FOUND OR LIST EXHAUSTED.
SINONAME CLI   0(R5),C','          IS DELIMITER A COMMA ?
         BNE   SINGET              IF NOT THEN END OF CARD.
         LA    R1,1(R5)            SET GR1 -> NEXT MEMBER NAME SPEC'D.
         B     SINLOOP4            GO TO PROCESS NEXT MEMBER.
SINNAME  OI    11(R3),X'80'        SET ON MEMBER REQ'D SWITCH.
         OI    SW1,SWMEMB          SET ON MEMBER NAME SPEC SWITCH.
         B     SINONAME            GO TO TEST NEXT NAME.
SINPRINT LA    R1,6(R1)            SET GR1 -> FIRST BYTE AFTER PRINT ID
         BAL   R14,SUB1            LINK TO FIND OPERAND.            3.1
         BNE   *+4                 EXIT WHEN FOUND.                 3.1
         CLC   CTYPORG,0(R1)       COMPARE FOR 'TYPORG=PS'          3.1
         BNE   SINGET              IF NOT THEN GO RO READ NEXT CARD.3.1
         OI    SW1,SWPSF           SET ON PS FOUND.                 3.1
         B     SINGET              GO TO READ NEXT CARD.            3.1
         SPACE 1
SINMVC1  MVC   0(0,R3),0(R5)       MODEL STATEMENT.
SINMVC2  MVC   DOUBWD(0),0(R5)     MODEL STATEMENT.
         SPACE 1
SINCLOSE CLOSE MF=(E,CLOSEL1)      CLOSE SYSIN DATA SET.
SINEXIT  TM    SW1,SWPSE+SWPSF     IS PS CONFLICT ?                 3.1
         BM    ERR03               IF SO THEN ERROR.                3.1
         BZ    *+8                 IF NO PS THEN USE.               3.1
         OI    SW,SWNS             SET ON 'T=LAL'.                  3.1
         CLI   TITLE+1,C'*'        IS 'ITEM=('*')' SPECIFIED ?      3.3
         BNE   NODEFTIT            IF NOT THEN NO DEFAULT TITLE.    3.3
         MVC   TITLE+1(44),JFCB    STORE DATA SET NAME.             3.3
         LA    R1,TITLE+1          SET GR1 -> TITLE NAME.           3.3
         LA    R0,1                SET GR0 = 1.                     3.3
         CLI   0(R1),C' '          IS CHARACTER BLANK ?             3.3
         BE    *+8                 IF SO THEN END FOUND.            3.3
         BXH   R1,R0,*-8           LOOP UNTIL END FOUND.            3.3
         LA    R0,TITLE+40         SET GR0 -> HIGHEST ADDR FOR SER. 3.3
         CLR   R1,R0               COMPARE FOR FIT.                 3.3
         BH    NODEFTIT            IF NO FIT THEN LEAVE.            3.3
         MVC   2(6,R1),JFCB+118    STORE SERIAL NUMBER.             3.3
NODEFTIT DS    0H                                                   3.3
         SPACE 1
*                                                                     *
*                                                                     *
*        OPEN DATA SETS                                               *
*                                                                     *
*                                                                     *
         SPACE 1
         TM    DDPRNT,X'80'        IS SYSPRINT PRESENT ?
         BZ    ERR02               IF NOT THEN ERROR.
         OPEN  MF=(E,OPENL2)       OPEN ALL DATA SETS.              3.2
         SPACE 1
*                                                                     *
*                                                                     *
*        ALLOCATE SPACE FOR SYSLIB READ.                              *
*                                                                     *
*                                                                     *
         SPACE 1
         LH    R0,LIB+62           SET GR0 = BLOCKSIZE.
         STH   R0,READL+6          STORE LENGTH FOR READ.
         GETMAIN R,LV=(0)          OBTAIN DYNAMIC STORAGE SPACE.
         ST    R1,READL+12         STORE AREA ADDRESS FOR READ.
         SPACE 1
*                                                                     *
*                                                                     *
*        STORE TIME AND DATE IN HEADING.                              *
*                                                                     *
*                                                                     *
         SPACE 1
         TIME  DEC                 OBTAIN TIME AND DATE.
         STM   R0,R1,DOUBWD        STORE DATE AND TIME IN DOUBLE WORD.
         ED    DATE,DOUBWD+5       EDIT DATE INTO HEADER LINE.
         MVO   DOUBWD+4(4),DOUBWD(2) REMOVE SECONDS.
         ED    TIME,DOUBWD+5       EDIT TIME INTO HEADER LINE.
         SPACE 1
*                                                                     *
*                                                                     *
*        INITIALISE LOOP TO SET TYPE AND APPLICATION.                 *
*                                                                     *
*                                                                     *
         SPACE 1
         TM    SW,SWNS             IS T=ALL SPECIFIED ?
         BO    SETEND              IF SO THEN IGNORE TYPES.
         L     R9,0(R10)           SET GR  -> TYPE TABLE.
SCANTYPE TM    0(R9),X'40'         IS THIS TYPE TO BE LISTED ?
         BZ    NEXTTYPE+4          IF NOT THEN GO TO TRY NEXT TYPE.
         ST    R9,TYPSTORE         SAVE ADDRESS OF CURRENT TYPE ENTRY.
         L     R0,0(R10)           SET GR0 -> TYPE TABLE.
         SR    R9,R0               SET GR9 = OFFSET WITHIN TABLE.
         SRL   R9,2                SET GR9 = TYPE NUMBER.
         STC   R9,TYPSTORE+8       SAVE TYPE NUMBER.
         MVI   TYPSTORE+9,X'00'    SET APPLICATION CODE = 0.
         CH    R9,12(R10)          COMPARE WITH MAXIMUM NON-APPLCN TYPE
         BNH   SETEND              IF NOT GREATER THEN USE A=0.
         CH    R9,8(R10)           COMPARE WITH LIMIT.
         BL    *+8                 IF NOT GREATER THEN USE.
         OI    SW1,SWTENDA         SET ON TYPE INVALID SWITCH.
         NI    SW1,X'FF'-SWAENDA   SET OFF APPLICATION INVALID SWITCH.
         L     R9,4(R10)           SET GR9 -> APPLICATION TABLE.
SCANAPPL TM    SW,SWAA             ARE ALL APPLICATIONS REQUESTED ?
         BO    *+12                IF SO THEN IGNORE APPLICATION PRSNT.
         TM    0(R9),X'40'         IS APPLICATION REQUESTED.
         BZ    NEXTAPPL+4          IF NOT THEN GO TO TRY NEXT APPLICN.
         ST    R9,TYPSTORE+4       SAVE ADDRESS OF CURRENT APPLCN ENTRY
         L     R0,4(R10)           SET GR0 -> APPLICATION TABLE.
         SR    R9,R0               SET GR9 = OFFSET WITHIN TABLE.
         SRL   R9,2                SET GR9 = APPLICATION NUMBER.
         STC   R9,TYPSTORE+9       STORE APPLICATION NUMBER.
         CH    R9,10(R10)          COMPARE WITH LIMIT.
         BL    SETEND              IF LESS THEN USE.
         OI    SW1,SWAENDA         SET ON APPLICATION INVALID SWITCH.
SETEND   OI    SW,SWST             SET ON NEW SUB-TITLE SWITCH.
         TM    SW1,SWPSE+SWPSF     IS PS PRESENT ?                  3.1
         BNZ   READ                IF SO THEN GO TO READ.           3.1
         SPACE 1
*                                                                     *
*                                                                     *
*        SCAN DIRECTORY FOR REQUIRED MEMBERS.                         *
*                                                                     *
*                                                                     *
         SPACE 1
         L     R8,DIRPARM          SET GR8 -> BUILD LIST.
         LA    R8,4(R8)            SET GR8 -> FIRST MEMBER.
SCANMEMB CLI   0(R8),X'FF'         IS IT END OF TYPE AND APPLICATION.?
         BE    NEXTAPPL            IF SO THEN GO TO TRY NEXT APPLICATN.
         TM    SW1,SWMEMB          IS MEMBER NAME SPECIFICATION PRESENT
         BZ    *+12                IF NOT THEN GO TO TEST TYPE & APPLN.
         TM    11(R8),X'80'        IS THIS MEMBER SPECIFIED ?
         BZ    NEXTMEMB            IF NOT THEN GO TO TRY NEXT MEMBER.
         TM    SW,SWNS             WAS T=ALL SPECIFIED ?
         BO    FIND                IF SO THEN GO TO FIND MEMBER.
         CLC   14(1,R8),TYPSTORE+8 COMPARE TYPE NO WITH TYPE REQUESTED.
         BL    NEXTMEMB            IF LESS THEN GO TO TRY NEXT MEMBER.
         BE    *+12                IF EQUAL THEN GO TO TEST APPLICATION
         TM    SW1,SWTENDA         IS TYPE INVALID SWITCH ON ?
         BZ    NEXTMEMB            IF NOT THEN GO TO TRY NEXT MEMBER.
         CLC   15(1,R8),TYPSTORE+9 COMPARE APPLICN NO. WITH REQUESTED.
         BL    NEXTMEMB            IF GREATER THEN GO TO TRY NEXT MEMBR
         BE    FIND                IF EQUAL THEN GO TO FIND MEMBER.
         TM    SW1,SWAENDA         IS APPLICATION INVALID SWITCH ON ?
         BZ    NEXTMEMB            IF NOT THEN GO TO TRY NEXT MEMBER.
FIND     MVI   11(R8),0            SET CONCATENATION TO ZERO.
         FIND  LIB,8(R8),C         ESTABLISH BEGINNING OF MEMBER.
         SPACE 1
*                                                                     *
*                                                                     *
*        READ MEMBER INTO DYNAMIC STORAGE AREA.                       *
*                                                                     *
*                                                                     *
         SPACE 1
READ     L     R6,LNFRST+4         SET GR6 -> START OF PAGE AREA.
READLOOP READ  READL,SF,MF=E       READ BLOCK OF MEMBER RECORDS.
         OI    SW,SWEP             SET ON END OF PAGE SWITCH.
         CHECK READL               CHECK READ.
         TM    SW1,SWSYNAD         HAS I/O ERROR OCCURRED ?
         BO    PUTSYNAD            IF SO THEN GO TO WRITE ERROR MESSAGE
         L     R1,READL+16         SET GR1 -> IOB.
         LH    R0,READL+6          SET GR0 = BLOCK-SIZE.
         SH    R0,14(R1)           SET GR0 = SIZE OF BLOCK READ.
         L     R1,READL+12         SET GR1 -> READ AREA.
         AR    R0,R1               SET GR0 -> END OF AREA.
READNEXT MVC   0(80,R6),0(R1)      MOVE RECORD TO RECORD AREA.
         LA    R1,80(R1)           SET GR1 -> NEXT RECORD IN BLOCK.
         LA    R6,80(R6)           SET GR6 -> NEXT RECORD AREA.
         C     R6,LNFRST           IS RECORD AREA FULL ?
         BNL   PUTOUT              IF SO THEN GO TO WRITE OUT.
READMV   CR    R1,R0               IS IT END OF BLOCK ?
         BL    READNEXT            IF NOT THEN GO TO MOVE NEXT.
         B     READLOOP            GO TO READ NEXT RECORD OF MEMBER.
         SPACE 1
*                                                                     *
*                                                                     *
*        WRITE LAST RECORD OF PREVIOUS MEMBER AND START OF CURRENT.   *
*                                                                     *
*                                                                     *
         SPACE 1
*        END OF MEMBER ENTRY.
ENDLIB   NI    SW,X'FF'-SWEP       SET OFF SAVE AREA FULL SWITCH.
         C     R6,LNFRST+4         COMPARE FOR NULL MEMBER.
         BNE   PUTOUT              IF NOT THEN GO TO PROCESS.
         TM    SW,SWCT             IS THIS A CONTINUATION ?
         BO    PUTCONTA            IF SO THEN GO TO SET FOR NEXT MEMBER
         MVC   0(L'MSGNULL,R6),MSGNULL  SET UP ERROR MESSAGE.
         MVC   L'MSGNULL(80-L'MSGNULL,R6),L'MSGNULL-1(R6) BLANK AREA.
PUTSYNAD LA    R6,80(R6)           INCREMENT GR6 FOR MESSAGE.
         NI    SW1,X'FF'-SWSYNAD   SET OFF I/O ERROR SWITCH.
         SPACE 1
*        END OF PAGE ENTRY.
PUTOUT   STM   R0,R1,LNFRST+8      SAVE REGISTERS FOR RETURN.
         LR    R1,R6               SET GR1 -> LAST AREA (+1).
         S     R6,F80              SET GR6 -> LAST AREA.
         L     R5,LNFRST+4         SET GR5 -> FIRST AREA.
         TM    SW,SWCT             IS THIS A CONTINUATION ?
         BO    PUTCONTB            IF SO THEN GO TO WRITE CONTINUATION.
         TM    SW,SWST+SWMP        IS A NEW SUB-TITLE REQUIRED ?
         BNZ   PUTHDGS             IF SO THEN GO TO WRITE HEADINGS.
         TM    SW,SWEP             IS MEMBER MORE THAN A PAGE LONG ?
         BO    PUTSAME             IF SO THEN GO TO WRITE ON SAME PAGE.
         SR    R1,R5               SET GR1 = NO. RECORDS X80.
         SR    R0,R0               SET GR0 = 0.
         D     R0,F80              SET GR1 = NO. RECORDS.
         CR    R1,R7               COMPARE NO. RECORDS WITH RESIDUAL CT
         BH    PUTHDGS             IF GREATER THEN GO TO WRITE HEADINGS
PUTSAME  MVC   BUFFER(1),SPACE3    SET SPACE 3 COMMAND CODE.        3.3
         BAL   R4,SUB2             LINK TO WRITE LAST RECORD PREV MEMB.
PUTMEMB  BAL   R4,SUB3             LINK TO CLEAR BUFFER.
         MVC   BUFFER(1),SPACE1    SET SPACE 1 COMMAND CODE.        3.3
         MVC   BUFFER+1(6),CMEMBER MOVE MEMBER ID TO BUFFER.
         MVC   BUFFER+9(8),0(R8)   MOVE MEMBER NAME TO BUFFER.
         TM    OPTSW,KEYS          IS SSI INFORMATION REQUIRED ?
         BZ    PUTMEMBA            IF NOT THEN USE BUFFER.
         MVC   BUFFER+31(4),CSSI   MOVE SSI INFORMATION  TO BUFFER.
         TM    11(R8),X'1F'        TEST FOR USER DATA PRESENT.      3.3
         BZ    PUTMEMBA            IF NONE THEN CANNOT STOTE SSI.   3.3
         SPACE 1
* HEXPRINT MACRO-INSTRUCTION.
         UNPK  BUFFER+35(9),12(5,R8)    UNPACK SSI DATA.
         TR    BUFFER+35(8),HEXPTL      CONVERT TO PRINTABLE FORMAT.
         MVI   BUFFER+43,C' '      CLEAR EXTRA BYTE.
         SPACE 1
PUTMEMBA BAL   R4,SUB2             LINK TO WRITE BUFFER.
         MVC   BUFFER+1(80),0(R5)  MOVE RECORD TO BUFFER.
         CR    R5,R6               IS IT LAST RECORD ?
         BE    PUTLAST             IF SO THEN DO NOT WRITE.
         LA    R5,80(R5)           INCREMENT GR5 FOR NEXT RECORD.
PUTCONTB BCT   R7,*-20             LOOP UNTIL PAGE FILLED.
PUTHDGS  MVC   BUFFER(1),SKIPC1    SET SKIP TO CHANNEL COMMAND.     3.3
         BAL   R4,SUB2             LINK TO WRITE LAST RECORD ON PAGE.
         MVC   BUFFER(1),SPACE1    SET SPACE 1 COMMAND CODE.        3.3
         OI    PNO+1,X'0F'         REMOVE ZONE FROM PAGE NUMBER.
         UNPK  PAGE,PNO            STORE PAGE NUMBER IN HEADING.
         AP    PNO,P1              INCREMENT PAGE NUMBER.
         LA    R2,TITLE            SET GR2 -> TITLE LINE.
         BAL   R4,SUB2A            LINK TO WRITE TITLE LINE.
         LH    R7,NOLNS            SET GR7 = NEW RESIDUAL COUNT.
         TM    SW1,SWPSE+SWPSF     IS SPS PRESENT ?                 3.1
         BNZ   PUTMEMBA+4          IF SO THEN GO TO WRITE DATA.     3.1
         TM    SW,SWNS             WAS T=ALL SPECIFIED ?
         BO    PUTMEMB             IF SO THEN GO TO WRITE MEMBER NAME.
         BAL   R4,SUB3             LINK TO CLEAR BUFFER ROUTINE.
         L     R2,TYPSTORE         SET GR2 -> TYPE ENTRY.
         LA    R3,BUFFER+1         SET GR3 -> FIRST BYTE IN BUFFER.
         BAL   R4,SUB4             LINK TO STORE TYPE IN SUB-TITLE.
         CLC   TYPSTORE+8(1),13(R10) COMPARE FOR HIGHEST NON-APPLCN TYP
         BNH   *+12                IF NOT GREATER THEN NO APPLICATION.
         L     R2,TYPSTORE+4       SET GR2 -> APPLICATION ENTRY
         BAL   R4,SUB4             LINK TO STORE APPLCN IN SUB-TITLE.
         MVC   BUFFER(1),SPACE2    SET SPACE 2 COMMAND CODE.        3.3
         BAL   R4,SUB2             LINK TO WRITE SUB-TITLE.
         B     PUTMEMB             GO TO WRITE MEMBER LINE.
PUTLAST  TM    SW,SWEP             IS CONTINUATION REQUIRED ?
         BZ    PUTCONTA            IF NOT THEN GO TO SET FOR NO CONT.
         L     R6,LNFRST+4         SET GR6 -> START OF PAGE AREA.
         LM    R0,R1,LNFRST+8      RESTORE REGISTERS FOR COMPARE.
         OI    SW,SWCT             SET ON CONTINUATION INDICATOR.
         B     READMV              GO TO MOVE REMAINDER OF MEMBER.
PUTCONTA NI    SW,X'FF'-SWCT-SWST  SET OFF CONTINUE & SUB-TITLE INDS.
         S     R7,F4               DECREMENT GR7 FOR SPACES.
         C     R7,F1               COMPARE FOR ONE LINE LEFT ON PAGE.
         BH    NEXTMEMB            IF SO THEN NO NEW SUB-TITLE REQUIRED
         OI    SW,SWST             SET NEW SUB-TITLE REQUIRED.
         SPACE 1
*                                                                     *
*                                                                     *
*        END OF LOOP CONTROL.                                         *
*                                                                     *
*                                                                     *
         SPACE 1                                                    3.3
NEXTMEMB TM    SW1,SWPSE+SWPSF     IS DATA SET SEQUENTIAL ?         3.3
         BNZ   ENDPH1              IF SO THEN DATA SET FOUND.       3.3
         LA    R8,16(R8)           SET GR8 -> NEXT MEMBER           3.3
         B     SCANMEMB            GO TO TEST NEXT MEMBER.
         SPACE 1
NEXTAPPL L     R9,TYPSTORE+4       SET GR9 -> A&PLICATION ENTRY.
         TM    SW,SWNS             IS G=ALL SPECIFIED ?
         BO    ENDPH1              IF SO THEN GO TO END PHASE 1.
         CLC   TYPSTORE+8(1),13(R10) IS TYPE > MAX NON-APPLICATION TYPE
         BNH   NEXTTYPE            IF NOT THEN GO TO TEST NEXT TYPE.
         CLC   TYPSTORE+9(1),11(R10) IS APPLICATION NO. = MAXIMUM ?
         BNL   NEXTTYPE            IF NOT THEN GO TO TEST NEXT TYPE.
         TM    0(R9),X'20'         IS IT END OF APPLICATIONS ?      3.2
         BO    NEXTTYPE            IF SO THEN GO TO TEST NEXT TYPE. 3.2
         LA    R9,4(R9)            SET GR9 -> NEXT APPLICATION ENTRY.
         B     SCANAPPL            GO TO TEST NEXT APPLICATION.
         SPACE 1
NEXTTYPE L     R9,TYPSTORE         SET GR9 -> TYPE ENTRY.
         TM    0(R9),X'20'         IS TYPE NO. = MAXIMUM.
         BO    ENDPH1              IF SO THEN GO TO END PHASE 1.
         LA    R9,4(R9)            SET GR9 -> NEXT TYPE ENTRY.
         B     SCANTYPE            GO TO TEST NEXT TYPE.
         SPACE 1
*                                                                     *
*                                                                     *
*        PHASE 1 END-UP ROUTINE.                                      *
*                                                                     *
*                                                                     *
         SPACE 1
ENDPH1   MVC   BUFFER(1),SKIPC1    SET SKIP TO CHANNEL 1 COMMAND.   3.3
         BAL   R4,SUB2             LINK TO WRITE LAST RECORD.
         CLOSE MF=(E,CLOSEL2)      CLOSE SYSLIB AND SYSUT1.
         LM    R0,R1,LNFRST        SET GR0 & GR1 FOR FREEMAIN.
         SR    R0,R1               SET GR0 = LENGTH OF DYNAMIC AREA.
         FREEMAIN R,LV=(0),A=(1)   RELEASE DYNAMIC PAGE AREA.
         TM    SW1,SWPSE+SWPSF     IS SYSLIB SEQUENTIAL ?
         BNZ   NODIRD1             IF SO THEN SKIP NEXT FREEMAIN.
         L     R1,DIRPARM          SET GR1 -> DYNAMIC BUILD LIST.
         LH    R0,DIRPARM+4        SET GR0 = LENGTH OF BUILD LIST.
         FREEMAIN R,LV=(0),A=(1)   RELEASE DYNAMIC BUILD LIST.
NODIRD1  L     R1,READL+12         SET GR0 -> DYNAMIC READ AREA.
         LH    R0,READL+6          SET GR0 = LENGTH OF READ LIST.
         FREEMAIN R,LV=(0),A=(1)   RELEASE DYNAMIC READ AREA.
         TM    DDUT1,X'80'         IS SYSUT1 DATA SET PRESENT ?
         BZ    RETURN              IF NOT THEN COMPLETE.
         LH    R10,NOPRT           SET GR10 = NUMBER OF COPIES REQUIRED
         BCTR  R10,R0              DECREMENT GR10 FOR COPY ALREADY OUT.
         LTR   R10,R10             TEST SIGN OF GR10.
         BNP   RETURN              IF NOT PLUS THEN RETURN.
         SPACE 1
*                                                                     *
*                                                                     *
*        COPY MEMBERS TO OUTPUT DEVICE.                               *
*                                                                     *
*                                                                     *
         SPACE 1
PH2PRNT  OPEN  MF=(E,OPENL3)       OPEN SYSUT1 FOR INPUT.
         BAL   R4,SUB2B            LINK TO READ FIRAT SYSUT1 RECORD.
         LR    R2,R1               SET GR2 -> RECORD READ.
         B     SUB2A               GO TO WRITE RECORD AND READ NEXT.
         SPACE 1
*  END OF DATA SET EXIT FOR SYSUT1.
ENDUT1   CLOSE MF=(E,CLOSEL3)      CLOSE SYSUT1 DATA SET.
         BCT   R10,PH2PRNT         LOOP TO PRINT NO. COPIES REQ'D.
RETURN   CLOSE MF=(E,CLOSEL4)      CLOSE SYSPRINT DATA SET.
         L     R15,RC              SET GR15 = RETURN CODE.
*        GOBACK  SAVE,RC=(15)
         L     13,4(13)
         L     14,12(13)
         LM    0,12,20(13)
         MVI   12(13),255
         BR    14
         EJECT
* SYNAD ROUTINE FOR SYSLIB,
         SPACE 1
SYNADL   SYNADAF ACSMETH=BPAM      OBTAIN ERROR BUFFER.
         MVC   0(L'MSGSYN,R6),MSGSYN    STORE ERROR IDENTIFIER.
         MVC   L'MSGSYN(15,R6),91(R1)   STORE I/O ERROR QUALIFIER.
         MVC   L'MSGSYN+15(5,R6),MSGSYN STORE CLOSING ASTERISKS.
         MVC   L'MSGSYN+20(60-L'MSGSYN,R6),L'MSGSYN+19(R6)  BLANK AREA.
         SYNADRLS
         NI    SW,X'FF'-SWEP       SET OFF SAVE AREA FULL SWITCH.
         OI    SW1,SWSYNAD         SET ON I/O ERROR SWITCH.
         BR    R14                 RETURN.
         EJECT
*    THE FOLLOWING SUB-ROUTINES ARE USED BY THE MAIN PROGRAMME.
         SPACE 1
SUB1     EX    R2,*+16             COMPARE CURRENT COLUMN FOR REQ'D CH.
         EX    R0,0(R14)           TEST FOR RETURN.
         LA    R1,1(R1)            IF NOT THEN INCREMENT GR1 FOR NEXT.
         B     SUB1                GO TO TEST NEXT COLUMN.
         CLI   0(R1),0             MODEL STATEMENT,
         SPACE 2
SUB2     LA    R2,BUFFER           SET GR2 -> BUFFER.
SUB2A    CLI   0(R2),X'03'         IS OPERATION A NOP ?             3.3
         BCR   8,R4                IF SO THEN IGNORE OUTPUT.        3.3
         PUT   PRNT,(R2)           WRITE RECORD TO SYSPRINT.        3.3
         TM    UT1+48,X'10'        IS SYSUT1 PRESENT ?
         BCR   14,R4               IF NOT THEN RETURN.
SUB2B    PUT   UT1,(R2)            WRITE RECORD ON SYSUT1.
         BR    R4                  RETURN.
         SPACE 2
SUB3     MVI   BUFFER+1,C' '       BLANK FIRST BYTE OF BUFFER.
         MVC   BUFFER+2(79),BUFFER+1 SET BUFFER TO BLANKS.
         BR    R4                  RETURN.
         SPACE 2
SUB4     L     R2,0(R2)            SET GR2 -> TYPE / APPLICATION ID.
         SR    R1,R1               SET GR1 = 0.
         IC    R1,0(R2)            SET GR1 = LENGTH OF ID FOR EXECUTE.
         EX    R1,SUB4A            MOVE TYPE/APPLICATION ID TO BUFFER.
         LA    R3,1(R3,R1)         SET GR3 -> FIRST BYTE FOLLOWING ID.
         BR    R4                  RETURN
SUB4A    MVC   0(0,R3),1(R2)       MODEL STATEMENT.
         EJECT
* FOLLOWING ROUTINES PROCESS INPUT PARAMETER LIST.
         SPACE 1
PARML    BAL   R3,PARMSUB1         LINK TO CALCULATE NO. LINES/PAGE.
         STH   R2,NOLNS            STORE NUMBER OF LINES PER PAGE.
PARMS    BR    R14           RETURN.
         SPACE 2
PARMC    BAL   R3,PARMSUB1         LINK TO CALCULATE NO. COPIES REQ'D.
         STH   R2,NOPRT            STORE NUMBER OF COPIES REQ'D.
         LA    R5,1                SET GR5 = 1.
         CLR   R2,R5               COMPARE FOR MORE THAN ONE COPY.
         BCR   12,R14              IF NOT THEN RETURN.
         NI    OPENL2+4,X'7F'      ALLOW OPEN OF SYSUT1.
         BR    R14                 RETURN.
         SPACE 2                                                      *
PARMP    OI    SW,SWMP             SET ON NEW PAGE/MEMBER SWITCH.
         BR    R14                 RETURN.
         SPACE 2
PARMT    SR    R5,R5               SET GR5 = 0.
         BAL   R4,PARMSUB2         LINK TO COMPARE FOR ALL SPECIFIED
         NI    SW,X'FF'-SWNS       SET OFF T=ALL SPECIFIED.
         BR    R14                 RETURN
         SPACE 2
PARMA    LA    R5,2                SET GR5 = 2
         BAL   R4,PARMSUB2         LINK TO COMPARE FOR ALL SPECIFIED.
         NI    SW,X'FF'-SWAA       SET OFF A=ALL SPECIFIED.
         BR    R14                 RETURN.
         SPACE 3
* FOLLOWING ARE SUBROUTINES FOR PARAMETER PROCESSING.
         SPACE 1
PARMSUB1 LR    R2,R1               SET GR2 -> FIRST BYTE OF PARAMETER.
         TM    0(R2),C'0'          IS BYTE NUMERIC ?
         BNO   *+14                IF NOT THEN USE AS DELIMITER.
         LA    R2,1(R2)            SET GR2 -> NEXT BYTE.
         CR    R2,R0               IS IT END OF PARM LIST ?
         BL    PARMSUB1+2          IF NOT THEN REPEAT TEST.
         SR    R2,R1               SET GR2 = LENGTH OF PARAMETER.
         BNP   ERR01               IF ZERO THEN ERROR.
         C     R2,F16              COMPARE LENGTH WITH MAXIMUM.
         BH    ERR01               IF GREATER THEN ERROR.
         BCTR  R2,R0               DECREMENT GR2 FOR PACK.
         EX    R2,*+14             PACK VALUE INTO DOUBLE WORD.
         LA    R1,1(R2,R1)         SET GR1 -> DELIMITER.
         CVB   R2,DOUBWD           SET GR2 = VALUE OF PARAMETER.
         BR    R3                  RETURN.
         PACK  DOUBWD,0(0,R1)      MODEL STATEMENT.
         SPACE 2
PARMSUB2 CLC   CALL,0(R1)          ARE ALL SPECIFIED ?
         BNE   *+10                IF NOT THEN GO TO PROCESS
         LA    R1,L'CALL(R1)       SET GR1 -> DELIMITER.
         BR    R14                 RETURN.
         LA    R7,8(R5,R10)        SET GR7 -> LIMIT VALUE.
         AR    R5,R5               SET GR5 = OFFSET IN TABLE CSECT.
         L     R5,0(R5,R10)        SET GR5 -> REQUIRED TABLE.
         CLI   0(R1),C'('          IS A SUBLIST SPECIFIED ?
         BE    *+14                IF SO THEN GO TO PROCESS.
         BAL   R3,PARMSUB1         LINK TO CALCULATE PARAMETER VALUE.
         BAL   R3,PARMSUB3         LINK TO SET PARAMETER INDICATOR.
         BR    R4                  RETURN.
         LA    R1,1(R1)            SET GR1 -> PARAMETER IN SUBLIST.
         BAL   R3,PARMSUB1         LINK TO CALCULATE PARAMETER VALUE.
         BAL   R3,PARMSUB3         LINK TO SET PARAMETER INDICATOR.
         CLI   0(R1),C','          IS DELIMITER A COMMA ?
         BE    *-16                IF SO THEN GO TO PROCESS NEXT PARM.
         CLI   0(R1),C')'          IS DELIMITER A RH PARENTHESIS ?
         BNE   ERR01               IF NOT THEN ERROR.
         LA    R1,1(R1)            SET GR1 -> PARAMETER DELIMITER.
         BR    R4                  RETURN.
         SPACE 2
PARMSUB3 CH    R2,0(R7)            COMPARE GR2 WITH LIMIT
         BCR   2,R3                IF GREATER THEN IGNORE.
         SLL   R2,2                SET GR2 = VALUE X4.
         AR    R2,R5               SET GR2 -> TABLE ENTRY.
         OI    0(R2),X'40'         SET ON ENTRY REQUIRED BIT.
         BR    R3                  RETURN.
         EJECT                                                      3.2
* FOLLOWING IS THE DCB EXIT FOR THE SYSPRINT DATA SET.              3.2
         SPACE 1                                                    3.2
PRNTEXIT DCBEXITS                                                   3.3
         EJECT
* FOLLOWING ARE ERROR ROUTINES.FOR THE MAIN PROGRAMME.
         SPACE 1
* PARAMETER LIST ERROR :
ERR01    MVC   BUFFER+1(L'MSGPARM),MSGPARM   STORE ERROR MESSAGE.
         B     ERRCOM              GO TO COMMON ROUTINE.
         SPACE 1
* REQUIRED DATA SET(S) NOT PRESENT :
ERR02    MVC   BUFFER+1(L'MSGDDS),MSGDDS     STORE ERROR MESSAGE.
         B     ERRCOM              GO TO COMMON ROUTINE.
         SPACE 1
* SYSLIB DATASSET HAS ILLEGAL FORMAT :
ERR03    MVC   BUFFER+1(L'MSGDIR),MSGDIR     STORE ERROR MESSAGE.
*        B     ERRCOM              GO TO COMMON ROUTINE.
         SPACE 1
* COMMON ERROR ROUTINE.
ERRCOM   TM    PRNT+48,X'10'       IS SYSPRINT OPEN ?
         BO    ERRPUT              IF SO THEN GO TO WRITE.
         OPEN  MF=(E,OPENL4)       OPEN SYSPRINT DATA SET.
         TM    PRNT+48,X'10'       IS SYSPRINT DATA SET OPEN ?
         BZ    ERRABEND            IF NOT THEN GO TO ABEND.
ERRPUT   PUT   PRNT,BUFFER         WRITE ERROR MESSAGE.
ERRABEND MVI   RC+3,16             SET RETURN CODE.
         B     RETURN              GO TO END ROUTINE.
         EJECT
*  FOLLOWING ARE CONSTANTS AND WORK AREAS USED BY THE PROGRAMME.
         SPACE 2
* DATA CONTROL BLOCKS.
         SPACE 1
IN       DCB   BFALN=D,BFTEK=S,BUFNO=3,DDNAME=SYSIN,DEVD=DA,DSORG=PS,  *
               EODAD=SINCLOSE,EROPT=ABE,LRECL=80,MACRF=GL,OPTCD=C,     *
               RECFM=FB,BLKSIZE=80,EXLST=PRNTEXIT                   3.3
PRNT     DCB   BFALN=D,BFTEK=S,BUFNO=3,DDNAME=SYSPRINT,DEVD=DA,        *
               EXLST=PRNTEXIT,BLKSIZE=1620,                         3.2*
               DSORG=PS,EROPT=ABE,LRECL=81,MACRF=PM,OPTCD=C,RECFM=FBM
LIB      DCB   BFALN=D,BUFNO=3,DDNAME=SYSLIB,DEVD=DA,DSORG=PO,         *
               EODAD=ENDLIB,LRECL=80,MACRF=R,NCP=1,OPTCD=C,RECFM=FB,   *
               SYNAD=SYNADL,EXLST=LIBEXIT
UT1      DCB   BFALN=D,BFTEK=S,BUFNO=3,DDNAME=SYSUT1,DEVD=DA,DSORG=PS, *
               EODAD=ENDUT1,EROPT=ACC,LRECL=81,MACRF=(GL,PM),OPTCD=C,  *
               RECFM=FBM,EXLST=PRNTEXIT
         SPACE 1
RC       DC    F'0'
F1       DC    F'1'
F2       DC    F'2'
F3       DC    F'3'
F4       DC    F'4'
F16      DC    F'16'
F80      DC    F'80'
         SPACE 1
TABPTR   DC    V(TSGAM07)
DIRLINK  LINK  EP=RTPDIRD,SF=L     LIST FORM OF LINK TO READ DIR.   3.2
LIBEXIT  DC    0F'0',X'87',AL3(JFCB)                                3.1
         SPACE 2
OPENL1   OPEN  (IN,(INPUT,DISP)),MF=L
OPENL2   OPEN  (LIB,INPUT,PRNT,(OUTPUT,LEAVE)),MF=L
         OPEN  (UT1,(OUTPUT,REREAD)),MF=L
OPENL3   OPEN  (UT1,(INPUT,REREAD)),MF=L
OPENL4   EQU   OPENL2+8            OPEN SYSPRINT DATA SET.
OPENL5   RDJFCB LIB,MF=L
CLOSEL1  CLOSE (IN,DISP),MF=L
CLOSEL2  CLOSE (LIB,DISP,UT1,REREAD),MF=L
CLOSEL3  EQU   CLOSEL2+4           CLOSE SYSUT1 DATA SET.
CLOSEL4  CLOSE (PRNT,DISP),MF=L
         READ  READL,SF,LIB,MF=L   READ SYSLIB DATA SET.
CAMLST   CAMLST SEARCH,JFCB,JFCB+118,DSCB                           3.1
HEXPTL   EQU   *-X'F0'             DEFINE ORIGIN OF TRANSLATE TABLE.
         DC    C'0123456789ABCDEF' TRANSLATE TABLE FOR SSI.
         SPACE 2
KEYTAB   DC    AL1(1,KEYL),X'47F0',S(PARML),C'L='      LINES/PAGE
KEYTAB2  DC    AL1(1,KEYC),X'47F0',S(PARMC),C'C='      NUMBER OF COPIES
         DC    AL1(0,KEYP),X'47F0',S(PARMP),C'P '      NEW PAGE/MEMBER.
         DC    AL1(0,KEYS),X'47F0',S(PARMS),C'S '      SSI INFO REQ'D.
         DC    AL1(1,KEYT),X'47F0',S(PARMT),C'T='      TYPES REQUESTED.
KEYTABND DC    AL1(1,KEYA),X'47F0',S(PARMA),C'A='      APPLICATIONS.
         SPACE 1
* DISPLACEMENT OF INFORMATION WITHIN KEY-WORD TABLE ELEMENTS.
KEYLNG   EQU   0                   KEY-WORD LENGTH.
KEYIDM   EQU   1                   IDENTIFIER MASK.
KEYBRN   EQU   2                   BRANCH INSTRUCTION.
KEYWRD   EQU   6                   KEY-WORD.
         SPACE 1
* KEY-WORD TABLE IDENTIFIER MASK VALUES.
KEYL     EQU   X'80'               LINES/PAGE PARAMETER.
KEYC     EQU   X'40'               NUMBER OF COPIES REQ'D.PARAMETER.
KEYP     EQU   X'20'               NEW PAGE/MEMBER PARAMETER.
KEYT     EQU   X'10'               TYPE(S) REQUIRED PARAMETER.
KEYA     EQU   X'08'               APPLICATIONS REQUIRED PARAMETER.
KEYS     EQU   X'04'         SSI INFORMATION REQUIRED.
         SPACE 2
DDLOOPC  DC    A(DDIN,12,DDLIB)
DDIN     DC    F'0',CL8'SYSIN'
DDUT1    DC    F'0',CL8'SYSUT1'
DDPRNT   DC    F'0',CL8'SYSPRINT'
DDLIB    DC    F'0',CL8'SYSLIB'
         SPACE 1
         DS    0A
DIRPARM  DC    AL1(2)              NUMBER OF USER DATA HALF-WORDS.
         DC    AL3(LIB)            ADDRESS OF SYSLIB DCB.
         DC    2A(0)               WORK SPACE FOR RETURNED VALUE.
         SPACE 1
NOLNS    DC    H'56'               DEFAULT LINES/PAGE.
NOPRT    DC    H'0'                DEFAULT NUMBER OF COPIES.
PNO      DC    PL2'1'              PAGE NUMBER.
P1       DC    P'1'                PAGE NUMBER INCREMENT.
         SPACE 2
* SWITCH BYTES AND VALUES.
SW       DC    AL1(SWST+SWNS+SWAA)
SWST     EQU   X'80'               NEW SUB-TITLE REQUIRED.
SWNS     EQU   X'40'               T=ALL SPECIFIED - NO SUB-TITLES.
SWAA     EQU   X'20'               A=ALL SPECIFIED.
SWEP     EQU   X'10'               FULL PAGE READ W/OUT END OF MEMBER
SWCT     EQU   X'08'               CONTINUATION OF MEMBER PRESENT.
SWMP     EQU   X'04'               NEW PAGE FOR EACH MEMBER.
         SPACE 1
SW1      DC    AL1(0)
SWPUNCH  EQU   X'80'               MEMBERS TO BE PUNCHED.
SWMEMB   EQU   X'40'               MEMBER NAMES ARE SELECTED.
SWAENDA  EQU   X'20'               INVALID APPLICATIONS ARE TO BE LSTED
SWTENDA  EQU   X'10'               INVALID TYPES ARE TO BE LISTED.
SWSYNAD  EQU   X'08'               I/O ERROR HAS OCCURRED ON SYSLIB.
SWPSE    EQU   X'04'               PS DATA SET EXPECTED.            3.1
SWPSF    EQU   X'02'               PS DATA SET FOUND.               3.1
         SPACE 1
OPTSW    DC    AL1(0)              PARAMETER OPTION CHECK SWITCH.
SPACE1   DC    X'09'                                                3.3
SPACE2   DC    X'11'                                                3.3
SPACE3   DC    X'19'                                                3.3
SKIPC1   DC    X'89'                                                3.3
         SPACE 2
* CHARACTER CONSTANTS.
         SPACE 1
CTITLE   DC    CL6'TITLE'
CMEMBER  DC    CL7'MEMBER'
CITEM    DC    CL5'ITEM='
CNAME    DC    CL5'NAME='
CALL     DC    CL3'ALL'
CTYPORG  DC    C'TYPORG=PS'
CPRINT   DC    CL6'PRINT'
CPUNCH   DC    CL6'PUNCH'                                           3.3
         SPACE 2
* OUTPUT AREAS.
         SPACE 1
TITLE    DC    X'11',CL48'*',C'TIME'                                3.3
TIME     DC    X'402120204B2020',C' DATE'
DATE     DC    X'4021204B202020',C' PAGE '
PAGE     DC    C'000'
         SPACE 1
BUFFER   DC    X'89',80C' '
         SPACE 2
* ERROR MESSAGES.
         SPACE 1
MSGNULL  DC    C'* * *  NULL MEMBER  * * *'
         SPACE 1
MSGPARM  DC    C'* * *  PARAMETER ERROR  * * *'
         SPACE 1
MSGDIR   DC    C'* * *  DIRECTORY READ ERROR  * * *'
         SPACE 1
MSGDDS   DC    C'* * *  REQUIRED DATA SET(S) NOT PRESENT  * * *'
         SPACE 1
MSGSYN   DC    C'* * *  I/O ERROR -  '
         SPACE 1
CSSI     DC    C'SSI='
         EJECT
*  WORK AND SAVE AREAS.
DYNAR    DS    0D                  MAY BE CHANGED TO DSECT LATER.
SAVE     DS    18F                 SAVE AREA.
DOUBWD   DS    D                   8 BYTE WORK AREA.
LNFRST   DS    4A                  DYNAMIC PAGE AREA ADDRESSES.
TYPSTORE DS    2A,2C               CURRENT TYPE AND APPLICATION INDS.
JFCB     DS    44F                 JOB FILE CONTROL BLOCK AREA.     3.1
DSCB     DS    0D,350C             DATA PORTION OF DSCB.            3.1
         EJECT
TSGAM07  CSECT
         DC    A(GT,SGT)           TABLE ADDRESSES.
         DC    H'5,16,2'           LIMIT POINTERS.
GT       DC    A(G0,G1,G2,G3,G4),X'20',AL3(G5)
SGT      DC    A(S0,S1,S2,S3,S4,S5,S6,S7,S8,S9,SA,SB,SC,SD,SE,SF)
         DC    X'20',AL3(SZ)
G0       DC    AL1(22),C'IBM SUPPLIED PROCEDURES'
G1       DC    AL1(13),C'TSG PROCEDURES'
G2       DC    AL1(30),C'IBM SUPPLIED MACRO-INSTRUCTIONS'           3.3
G3       DC    AL1(16),C'USER PROCEDURES -'
G4       DC    AL1(23),C'NON-PROCEDURAL ENTRIES - '
G5       DC    AL1(25),C'USER MACRO-INSTRUCTIONS - '                3.3
         SPACE 2
S0       DC    AL1(7),C'STANDARD'
S1       DC    AL1(2),C'AAS'
S2       DC    AL1(3),C'CCOP'
S3       DC    AL1(2),C'CEA'
S4       DC    AL1(3),C'DACS'
S5       DC    AL1(3),C'DCTS'
S6       DC    AL1(2),C'IRS'
S7       DC    AL1(2),C'MIS'
S8       DC    AL1(2),C'OCS'
S9       DC    AL1(4),C'SCOPE'
SA       DC    AL1(3),C'PICS'                                       3.3
SB       DC    AL1(4),C'AASTP'                                      3.3
SC       DC    AL1(5),C'CE-MRS'
SD       DC    AL1(18),C'APPLICATION INVALID'
SE       DC    AL1(8),C'EDUCATION'
SF       DC    AL1(11),C'MACHINE ROOM'
SZ       DC    AL1(18),C'APPLICATION INVALID'
         END
