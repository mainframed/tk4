AMM.     TITLE 'LINKAGE EDITOR SELECTOR AND OPTIMISER - A.MORRISH'
LINKEDIT CSECT
***********************************************************************
*                                                                     *
*  THIS PROGRAM SELECTS THE LARGEST LINKAGE EDITOR THAT WILL FIT THE  *
* PARTITION/REGION/USER-CORE  AND SETS THE SIZE PARAMETER TO USE ALL  *
* AVAILABLE SPACE GIVING THE LARGEST POSSIBLE SIZE TO THE LOAD MODULE *
* BUFFERS COMPATABLE WITH BLOCKING FACTORS OF UP TO 5 ON SYSIN,SYSLIN *
* AND SYSPRINT. THE PROGRAM THEN EXECUTES THE SELECTED LINKAGE EDITOR.*
*                                                                     *
*  THE PROGRAM WILL NOT CHANGE THE SIZE PARAMETER IF SPECIFIED BY THE *
* USER, NOR WILL IT ATTEMPT ANY VERIFICATION OF ANY PARAMETER. IT     *
* WILL, HOWEVER, ENSURE THAT THE INDICATED LINKAGE EDITOR PROGRAM IS  *
* ONE THAT IS INCLUDED.IN THE SYSTEM. IF NONE CAN BE FOUND TO SUIT    *
* THE CORE REQUIREMENTS THE PROGRAM WILL TERMINATE WITH A RETURN CODE *
* OF 20. ALL OTHER RETURN CODES ARE THOSE GENERATED BY THE LINKAGE    *
* EDITOR PROGRAM.                                                     *
*                                                                     *
*  THIS PROGRAM ALSO ISSUES AN ENQ ON 'RTPUPDTE' AND THE NAME OF THE
*  SYSLMOD DATA SET TO PREVENT MULTIPLE UPDATING OF THE SAME DATA SET
*  BY MORE THAN ONE TASK CONCURRENTLY - THE SAME MAJOR AND MINOR NAMES
*  ARE USED AT RESPOND FOR ALL USES OF IEBUPDTE AND IEBCOPY.
*
***********************************************************************
         SPACE 1
* REGISTER USAGE.
R0       EQU   0                   WORK REGISTER.
R1       EQU   1                   WORK REGISTER.
R2       EQU   2
R3       EQU   3
R4       EQU   4
R5       EQU   5
R6       EQU   6
R7       EQU   7
R8       EQU   8
R9       EQU   9
R10      EQU   10
SBASE    EQU   11                  BASE REGISTER FOR OVERLAY SEGMENT.
RBASE    EQU   12                  BASE REGISTER FOR ROOT SEGMENT.
R13      EQU   13                  SAVE AREA POINTER.
R14      EQU   14                  RETURN ADDRESS.
R15      EQU   15                  ENTRY POINT ADDRESS / RETURN CODE.
         EJECT
*        BEGIN (DYNAMIC,DYNL,DYNAR),BASE=RBASE,ID=
         STM   14,12,12(13)
         BALR  RBASE,0
         USING *,RBASE
         LA    0,DYNL
         BAL   1,*+4
         SVC   10
         LR    15,1
         LM    0,1,20(13)
         ST    15,8(13)
         ST    13,4(15)
         LR    13,15
         USING DYNAR,13
         L     R15,VCON1
         BR    R15
VCON1    DC    V(LKED1)
VCON2    DC    V(LKED2)
VCON3    DC    V(LKED3)
VCON4    DC    V(LKED4)
VCON5    DC    V(LKED5)
         EJECT
LKED1    CSECT
         USING *,R15               DEFINE BASE REGISTER.
         MVC   DYNPTRS(8),0(R1)    MOVE PARAMETER POINTERS TO NEW AREA.
         L     R1,0(R1)            SET GR1 -> PARAMETER LIST.
         LH    R2,0(R1)            SET GR2 = LENGTH OF PARAMETERS.
         LA    R2,1(R2)            INCREMENT GR2 FOR MOVE.
         EX    R2,LK1MV            MOVE PARAMETERS TO NEW AREA.
         XC    DYNPTRS+1(3),DYNPTRS+1   CLEAR PARAMETER POINTER.
         LA    R0,DYNPARMS         SET GR0 -> DYNAMIC PARM LIST.
         O     R0,DYNPTRS          SET ON VL BIT.
         ST    R0,DYNPTRS          STORE NEW PARAMETER POINTER.
         SR    R10,R10             SET GR10 = 0.
         L     R1,16               SET GR1 -> CVT.
         L     R1,0(R1)            SET GR1 -> TCB POINTERS.
         L     R1,4(R1)            SET GR1 -> CURRENT TCB.
         L     R1,24(R1)           SET GR1 -> BOUNDARY BOX.
LK1LOOP  L     R1,0(R1)            SET GR1 -> FREE LIST ELEMENT.
         LTR   R1,R1               TEST FOR END OF CHAIN.
         BZ    LK1GOOD             IF END THEN GO TO EXIT.
         C     R10,4(R1)           COMPARE TO FIND LARGEST FREE AREA.
         BNL   LK1LOOP             IF NOT LARGER THEN GO TO FIND NEXT.
         L     R10,4(R1)           SET GR10 = LARGEST FREE AREA.
         B     LK1LOOP             GO TO SCAN FOR LARGER AREA.
         SPACE 1
LK1GOOD  SRL   R10,10              SHIFT TO CONVERT TO K.
         MVC   DYNBLDL(8),LK1CI    INITIALISE BUILD LIST.
         L     R15,VCON2           SET GR15 -> RTN TO DETERMINE MODEL.
         BR    R15                 GO TO DETERMINE MODEL.
         SPACE 1
LK1MV    MVC   DYNPARMS(0),0(R1)   MODEL STATEMENT.
LK1CI    DC    H'1,58',C'IEWL'
         EJECT
LKED2    CSECT
         BALR  SBASE,R0            INITIALISE BASE REGISTER.
         USING *,SBASE             DEFINE BASE REGISTER.
         LA    R4,LK2TB            SET GR4 -> MODEL TABLE.
         LA    R2,8                SET GR2 = LENGTH OF TABLE.
         LA    R3,LK2TBND          SET GR3 -> END OF TABLE.
LK2LOOP  CH    R10,4(R4)           COMPARE FOR FIT.
         BL    LK2NXT              IF NO FIT THEN GO TO TRY NEXT.
         MVC   DYNBLDL+8(4),0(R4)  STORE FULL NAME.
         BLDL  0,DYNBLDL           BUILD LIST.
         LTR   R15,R15             TEST RETURN CODE.
         BZ    LK2GOOD             IF ZERO THEN NAME FOUND.
LK2NXT   BXLE  R4,R2,LK2LOOP       LOOP UNTIL FOUND.
*        GOBACK (DYNAMIC,DYNL),RC=20    RETURN.
         LR    1,13
         L     13,4(13)
         LA    0,DYNL
         SVC   10
         LM    14,12,12(13)
         MVI   12(13),255
         BR    14
         SPACE 1
LK2GOOD  LH    R9,4(R4)            SET GR9 = MODEL MINIMUM.
         LH    R8,6(R4)            SET GR8 = LBUFF MINIMUM.
         L     R15,VCON3           SET GR15 -> ROUTINE TO ANALYSE PARMS
         BR    R15                 GO TO ANALYSE PARAMETERS.
         SPACE 1
         DS    0H
LK2TB    DC    C'F128',H'128,56'
         DC    C'F880',H'88,36'
         DC    C'F440',H'52,6'
         DC    C'E180',H'18,0'
LK2TBND  DC    C'E150',H'15,0'
         EJECT
LKED3    CSECT
         BALR  SBASE,0             INITIALISE BASE REGISTER.
         USING *,SBASE             DEFINE BASE REGISTER.
         LOAD  DE=DYNBLDL+4        LOAD LINKAGE EDITOR.
         ST    R0,DYNBLDL          SAVE ENTRY POINT.
         LTR   R8,R8               IS LEVEL E REQUIRED ?
         BE    LK3NS               IF SO THEN NO SIZE PARAMETER.
         LA    R2,DYNPARMS+1       SET GR2 -> FIRST PARAMETER.(-1)
         LH    R1,DYNPARMS         SET GR1 = LENGTH.
         AR    R1,R2               SET GR1 -> END OF PARMLIST.
         LA    R0,1                SET GR0 = 0.
LK3LOOP1 LA    R2,1(R2)            SET GR2 -> FIRST PARAMETER.
         CLC   0(5,R2),LK3CS+1     IS SIZE PARAMETER SPECIFIED ?
         BE    LK3NS               IF SO THEN USE.
LK3LOOP2 CLI   0(R2),C','          IS CHARACTER A DELIMITER ?
         BE    LK3LOOP1            IF SO THEN GO TO TEST FOR SIZE.
         CLI   0(R2),C' '          IS CHARACTER A BLANK ?
         BE    *+8                 IF SO THEN END OF PARMS.
         BXLE  R2,R0,LK3LOOP2      LOOP UNTIL END OF PARMS.
         MVC   0(17,R2),LK3CS      STORE ',SIZE=(' IN PARM LIST.
         CVD   R10,DYNLINK         CONVERT AVAILABLE CORE TO DECIMAL.
         OI    DYNLINK+7,X'0F'     REMOVE ZONE.
         UNPK  7(3,R2),DYNLINK+6(2)     UNPACK INTO PARM LIST.
         SR    R10,R9              SET GR10 = EXCESS.OVER MODEL SIZE.
         AR    R10,R8              SET GR10 = VALUE 2.
         LA    R0,100              SET GR0 = 100
         CR    R10,R0              COMPARE FOR LIMIT.
         BNH   *+6                 IF LESS THEN USE.
         LR    R10,R0              SET GR10 = LIMIT.
         CVD   R10,DYNLINK         CONVERT VALUE 2 TO DECIMAL.
         OI    DYNLINK+7,X'0F'     REMOVE ZONE.
         UNPK  12(3,R2),DYNLINK+6(2)    UNPACK INTO PARM LIST.
         LH    R1,DYNPARMS         SET GR1 = LENGTH OF PARM LIST.
         LA    R1,17(R1)           INCREMENT GR1 FOR SIZE.
         STH   R1,DYNPARMS         STORE INCREMENTED PARMLIST LENGTH.
LK3NS    L     R15,VCON4           SET GR15 -> RDJFCB ROUTINE.
         BR    R15                 GO TO READ JFCB.
         SPACE 1
LK3CS    DC    C',SIZE=(000K,000K)'
         EJECT
LKED4    CSECT
         BALR  SBASE,R0            INITIALISE BASE REGISTER.
         USING *,SBASE             DEFINE BASE REGISTER.
         GETMAIN R,LV=200          OBTAIN SPACE FOR READ JFCB.
         LR    R9,R1               SET GR9 -> RDJFCB AREA.
         ST    R9,176(R9)          SET EXIT LIST POINTER ADDRESS.
         MVI   176(R9),X'87'       SET EXIT LIST.
         LA    R0,176(R9)          SET GR0 -> EXIT LIST.
         ST    R0,184(R9)          STORE EXIT LIST ADDRESS IN DCB.
         LA    R0,148(R9)          SET GR0 -> DCB.
         ST    R0,180(R9)          SET DCB ADDRESS IN OPEN MF=L.
         MVI   180(R9),X'80'       SET OPEN MF=L.
         MVC   188(8,R9),LK4CS     STORE 'SYSLMOD' DD NAME.
         XC    196(4,R9),196(R9)   CLEAR POSSIBLE OPENFLGS AND EXCP.
         MVI   196(R9),X'02'       SET OFF LOCK BIT.
         TM    DYNPTRS,X'80'       ARE OVER-RIDE DDNAMES SPECIFIED ?
         BO    LK4DEF              IF NOT THEN USE DEFAULTS.
         L     R1,DYNPTRS+4        SET GR1 -> DDNAME OVER-RIDES.
         CLI   1(R1),24            COMPARE LENGTH FOR SYSLMOD
         BL    LK4DEF              IF LESS THEN USE DEFAULTS.
         CLI   18(R1),0            IS SYSLMOD OVER-RIDDEN ?
         BE    LK4DEF              IF NOT THEN USE DEFAULTS.
         MVC   188(8,R9),18(R1)    STORE OVER-RIDE DDNAME.
LK4DEF   RDJFCB MF=(E,180(R9))     READ JFCB.
         MVC   DYNBLDL+12(44),0(R9)  SAVE DSNAME FOR STEP 5.
         FREEMAIN R,LV=200,A=(R9)  RELEASE DYNAMIC AREA.
         L     R15,VCON5           SET GR15 -> ENQUEUE AND LINK ROUTINE
         BR    R15                 GO TO ENQUEUE AND LINK ROUTINE.
         SPACE 1
LK4CS    DC    CL8'SYSLMOD'
         EJECT
LKED5    CSECT
         BALR  SBASE,R0            INITIALISE BASE REGISTER.
         USING *,SBASE             DEFINE BASE REGISTER.
         MVC   DYNENQL,LK5NQ       SET ENQUEUE MODEL.
         LA    R1,DYNBLDL+55       SET GR1 -> END OF DSNAME.
         CLI   0(R1),C' '          IS CHARACTER BLANK ?
         BNE   *+8                 IF NOT THEN END FOUND.
         BCT   R1,*-8              LOOP UNTIL NON-BLANK FOUND.
         LA    R0,DYNBLDL+11       SET GR0 FOR SUBTRACT.
         SR    R1,R0               SET GR1 = LENGTH OF DSNAME.
         STC   R1,DYNENQL+1        STORE LENGTH IN ENQUEUE.
         LA    R0,DYNBLDL+12       SET GR0 -> START OF DSNAME.
         ST    R0,DYNENQL+8        STORE ADDRESS OF MINOR ELEMENT.
         ENQ   MF=(E,DYNENQL)      ENQUEUE ON LOAD MODULE LIBRARY.
         L     R15,DYNBLDL         SET GR15 -> ENTRY POINT.
         LA    R1,DYNPTRS          SET GR1 -> PARAMETER LIST.
         BALR  R14,R15             LINK TO LINKAGE EDITOR.
         LR    R10,R15             SAVE RETURN CODE.
         DEQ   MF=(E,DYNENQL)      DEQUEUE ON LOAD MODULE LIBRARY.
         DELETE EPLOC=DYNBLDL+4    DELETE LINKAGE EDITOR.
         LR    R15,R10             RESTORE RETURN CODE.
*        GOBACK (DYNAMIC,DYNL),RC=(15)  RETURN.
         LR    1,13
         L     13,4(13)
         LA    0,DYNL
         SVC   10
         L     14,12(13)
         LM    0,12,20(13)
         MVI   12(13),255
         BR    14
         SPACE 1
LK5NQ    ENQ   (LK5MN,0,E,0,SYSTEM),MF=L
LK5MN    DC    CL8'RTPUPDTE'
         EJECT
DYNAR    DSECT
         DS    18F                 SAVE AREA.
DYNLINK  DS    D                   WORK AREA.
DYNPTRS  DS    2F                  POINTERS TO PARAMETERS.
DYNENQL  DS    CL12                ENQUEUE/DEQUEUE L-FORM.
DYNBLDL  DS    2H,CL58             BUILD LIST FOR LINK EDIT/ DSNAME
DYNPARMS DS    H'0',CL102' '       PARAMETERS FOR LINK EDIT.
DYNL     EQU   *-DYNAR             LENGTH FOR GETMAIN.
         END   LINKEDIT
