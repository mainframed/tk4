         TITLE   'RARDUMP BUILD FDRDSF JCL FOR ARCHIVE'
         REGISTER
*
* REGISTERS USED OVER WHOLE PROGRAM
*  R11=BASE2    R12=BASE    R13=SAVE CHAIN
*
         SUBR  RARDUMP
*
         L     R11,BASE2
         USING RARDUMP+4096,R11
         MVI   RC,0             DEFAULT RETUEN CODE
         EJECT
*
* OPEN SYSPRINT FOR MESSAGES
*
         OPEN  (DCBSYSP,(OUTPUT))
         LA    R5,DCBSYSP
         USING IHADCB,R5
         TM    DCBOFLGS,DCBOFOPN IS DATASET OPEN OK
         BO    SYSPOK
         DROP  R5
         WTO   'RARDU14I UNABLE TO OPEN DATASET - DDNAME=SYSPRINT',    +
               ROUTCDE=1,DESC=3
         B     FAIL
SYSPOK   EQU   *
         OI    FLAG2,FLGSYSP       SET FLAG FOR OPEN
         EJECT
*
*        LOCK QUEUE AND OPEN IT
*
         ENQ   (QNAME,RNAME,E,,SYSTEM) EXCLUSIVE CONTROL OF Q
         OI    FLAG2,FLGENQ       MARK AS ENQUED
         OPEN  (DCBQUEUE,(INOUT))
         LA    R5,DCBQUEUE
         BAL   R4,TESTOPEN         LOOK TO SEE IF OPEN
         OI    FLAG2,FLGQUEUE      SET FLAG FOR OPEN
         EJECT
*
* READ DATA FROM 'ARCHIVE.QUEUE' INTO MEMORY.
*   R5=BUFFER CHAIN POINTER   R6=CURRENT DATA AREA POINTER
*
PROCESS  EQU   *
         LA    R5,CHAIN
STARTP   EQU      *
         GETMAIN R,LV=BLKSIZE+4  GET ENOUGH MEMORY TO READ A BLOCK
         LA    R6,4(R1)          ADDRESS OF BUFFER.
         ST    R1,0(R5)          CHAIN IT OFF THE REST
         ZR    R5
         ST    R5,0(R1)          KILL END OF CHAIN
         LR    R5,R1             THIS IS THE BEGINNING OF CHAIN.
         READ  DECBQUE,SF,DCBQUEUE,(6) READ A BUFFER.
         CHECK DECBQUE           MAKE SURE READ HAS FINISHED
         TM    BLKSIZE-1(R6),BLKEND QUICK CHECK FOR QUEUE VALIDITY
         BZ    CORRUPTQ
         TM    BLKSIZE-1(R6),QUEEND LAST BLOCK ?
         BZ    STARTP               YES !
         EJECT
**********************************************************************
*       CREATE NEW Q CONTAINING ONLY REQUESTS FOR OTHER PROCESS      *
*       ALSO REMOVES SCRATCHED REQUESTS                              *
*         R2=NEW QUEUE BUFFER ADDRESS R5=CURRENT BUFFER POINTER      *
*         R6=CURRENT RECORD POINTER   R4=NEW RECORD POINTER          *
*         R7=COUNT OF ARCHIVE ENTRIES                                *
**********************************************************************
NEWQ     EQU   *
         BAL   R14,GETRECOR        GET FIRST RECORD OFF OLD QUEUE
*                                  NOTE FIRST RECORD IS A DUMMY
         ZR    R7                  ZERO COUNT OF ARCHIVE REQUESTS
         POINT DCBQUEUE,BLOCKADR   POINT TO START OF DS READY FOR WRT
         GETMAIN R,LV=BLKSIZE      GET A BUFFER FOR NEW QUEUE
         ST    R1,NEWQBUFF         SAVE ADDRESS
         LR    R2,R1               ADDRESS OF BLOCK
         B     ZEROQUE
*
* SEARCH QUEUE PICKING OUT THE RETURN REQUESTS AND WRITE THEM BACK
*
QENQUIRE EQU   *
         BAL   R14,GETRECOR        GET ANOTHER REQUEST
         USING QUEUEMAP,R6         MAP OLD COPY OF QUEUE
         TM    QACTION,BADBITS     ANY BITS SET THAT SHOULD NOT BE SET
         BNZ   CORRUPTQ            MAKE SURE REQUEST GETS NO FURTHER
         TM    QACTION,FLAGDEL     IS IT A SCRATCHED RECORD ?
         BO    LASTREQ             IF SO IGNORE IT
         TM    QACTION,FLAGRET     IS IT RET. REQUEST ?
         BO    RETURNDS            SAVE AWAY RETURN REQUESTS
         TM    QACTION,FLAGARC     IS IT ARC REQUEST ?
         BZ    CORRUPTQ            WHAT ON EARTH IS IT THEN
         INCR  R7                  COUNT ARCHIVE REQUESTS
         OI    FLAG1,FLGWORK       INDICATE THERE IS SOME WORK TO DO
LASTREQ  EQU   *
         TM    QEND,FLAGEND        LAST RECORD ?
         BZ    QENQUIRE
         B     WRITNEWQ            WRITE LAST BLOCK OF NEW QUEUE
         DROP  R6
         EJECT
*
* HERE TO INSERT A NEW RECORD IN THE OUTPUT BUFFER
*
RETURNDS EQU   *
         USING QUEUEMAP,R4
         NI    QEND,X'FF'-FLAGEND  TURN OFF MARKER FOR LAST RECORD
         TM    QEND,BLKEND         IS BUFFER FULL ?
         BZ    MVTOBUF             NO SO TRANSFER RECORD
         NI    QEND,X'FF'-QUEEND   TURN OF END OF QUEUE MARKER
WRITNEWQ EQU   *
         WRITE DECBQUE,SF,DCBQUEUE,(2),MF=E
         CHECK DECBQUE             WAIT FOR WRITE TO FINISH
         TM    BLKSIZE-1(R2),QUEEND WAS THIS THE LAST BLOCK OF QUEUE
         BO    FREEQ               GO AND CLOSE IT UP
ZEROQUE  EQU   *
         ZR    R9                  PADD,SOURCE LENGTH FOR MVCL
         LA    R3,BLKSIZE          DESTINATION LENGTH FOR MVCL
         MVCL  R2,R8               ZERO THE BLOCK
         L     R2,NEWQBUFF         RECOVER BLOCK ADDRESS
         MVI   BLKSIZE-1(R2),BLKEND+QUEEND MARK THE END OF THE QUEUE
         LR    R4,R2               POINT TO FIRST RECORD
         B     ADDQ02
MVTOBUF  EQU   *
         INCR  R4,127              MOVE DOWN TO NEXT RECORD
ADDQ02   EQU   *
         MVC   0(RECSIZE,R4),0(R6) MOVE REQUEST TO NEW QUEUE
         OI    QEND,FLAGEND        CURRENT RECORD LAST
         B     LASTREQ             AND GO BACK FOR ANOTHER
         DROP  R4
         EJECT
*
*        CLOSE AND UNLOCK THE QUEUE
*
FREEQ    EQU   *
         ST    R7,NUMARCS          SAVE NUMBER OF ARCHIVE REQUESTS
         FREEMAIN R,LV=BLKSIZE,A=(2) FREE UP BUFFER AGAIN
         ZERO  NEWQBUFF,4          MARK AS FREED
         CLOSE (DCBQUEUE,FREE)
         NI    FLAG2,X'FF'-FLGQUEUE MARK AS CLOSED NOW
         DEQ   (QNAME,RNAME,,SYSTEM)
         NI    FLAG2,X'FF'-FLGENQ   MARK AS DEQUEUED
         EJECT
**********************************************************************
*        IF THERE IS ANYTHING TO PROCESS THEN OPEN NAMES FILE
*        AND READ IN THE DATA
**********************************************************************
         TM    FLAG1,FLGWORK
         BO    ARCS
         PUT   DCBSYSP,MSG41       NO REQUESTS TO PROCES
         MVI   RC,4                SET RETURN CODE
         B     FINISH
ARCS     EQU   *
         OPEN  (DCBNAMES,(INOUT))
         LA    R5,DCBNAMES         POINT AT DCB TO BE TESTED
         BAL   R4,TESTOPEN         LOOK TO SEE IF OPEN
         OI    FLAG2,FLGNAMES      SET FLAG FOR OPEN
         READ  DECBNAME,SF,DCBNAMES,NAMES
         OPEN  (DCBFDR,(OUTPUT))   WHILE THAT IS READING, OPEN THIS
         LA    R5,DCBFDR           POINT AT DCB TO BE TESTED
         BAL   R4,TESTOPEN         LOOK TO SEE IF OPEN
         OI    FLAG2,FLGFDR        SET FLAG FOR OPEN
         CHECK DECBNAME
         EJECT
*
* BRANCH BACK TO HERE IF VOLSER OF TAPE CHANGES HENCE WE NEED TO
* START ANOTHER JOB. WE DO THIS SO THAT THE JOB REQUIRING THE NEW
* TAPES STAYS IN THE JES3 QUEUE WITHOUT HOLDING UP THE REQUESTS FOR
* THE PREVIOUS TAPE.
* CONVERT THE TAPE LABEL TO BINARY AND ALLOW AN OVER SHOOT OF 50MB
*    ON THE SIZE OF TAPE TO TRY TO GET ALL THIS RUN ON ONE TAPE
*
NEWNAMES EQU   *
         NI    FLAG3,X'FF'-FLAGJOB RESET FLAG
         NI    FLAG1,X'FF'-FLGJOBCD WE NEED A NEW JOB CARD NOW
         PACK  CPACK,TAPELBL       SET UP TAPE LABELS FOR THIS RUN
         CVB   R3,CPACK            CONVERT LAST TAPE LABEL TO BINARY
         L     R4,BYTSLEFT         GET NO. OF BYTES REMAINING ON TAPE
         A     R4,MARGIN           WE ALLOW A MARGIN TO TRY TO AVOID
         ST    R4,BYTSLEFT         USING ANOTHER SET OF TAPES TODAY
*
* NOW SCAN THE QUEUE FOR A NEW DATASET TO PROCESS
*    R5=CURRENT BLOCK POINTER   R6=CURRENT RECORD POINTER
*    R3=LAST TAPE LABEL USED
*
DISKJCL  EQU   *
         NI    FLAG1,X'FF'-FLGFIRST-FLGDISK-FLGGOOD RESET FLAGS
QPROCESS EQU   *
         BAL   R14,GETRECOR        GET A RECORD
         USING QUEUEMAP,R6
         TM    QACTION,FLAGDEL     REQUEST DELETED
         BO    QLOOP               YES
         TM    QACTION,FLAGARC     IS IT ARCHIVE REQUEST
         BO    XPROCESS
QLOOP    EQU   *
         TM    QEND,FLAGEND        ALL REQUESTS FOR THIS DISK DONE
         BZ    QPROCESS
         TM    FLAG1,FLGDISK       WERE ANY REQUESTS DONE THIS TIME
         BZ    ALLDONE             ALL FINISHED
         PUT   DCBFDR,FDR4         SYSIN TERMINATOR
         B     DISKJCL             ANOTHER DISK
         EJECT
*
* WRITE THE JOB CARD ETC IF NOT ALREADY DONE
*
XPROCESS EQU   *
         TM    FLAG1,FLGHEAD      PRINT HEADER ON LISTING
         BO    HEADDONE
         OI    FLAG1,FLGHEAD
         PUT   DCBSYSP,MSG05      LISTING HEADING
         PUT   DCBSYSP,MSG09       AND COLUMN TITLES
HEADDONE EQU   *
         TM    FLAG1,FLGJOBCD      JOB CARD WRITTEN ?
         BO    JOBDONE
         MVZ   JCL2Q,HASHZ
         MVN   JCL2Q,HASHN
         ZR    R4                 UPDATE THE JOB NAME INDEX
         IC    R4,JCL1INDX        TO CYCLE ROUND B-I,A-I,A-I ...
         INCR  R4
         STC   R4,JCL1INDX        PUT IT BACK
         CLI   JCL1INDX,X'CA'     REACHED THE TOP YET ?
         BNE   INDEXOK
         MVI   JCL1INDX,C'A'      THEN GO BACK TO THE START
INDEXOK  EQU   *
         LA    R4,JCL1             JOBCARD,CONT,CONT
         LA    R7,3                NUMBER OF CARDS
         BAL   R8,PUTFDR
         OI    FLAG1,FLGJOBCD      MARK JOB CARD NOW WRITTEN
JOBDONE  EQU   *
         EJECT
*
* IF WE HAVE FOUND A NEW DISK TO PROCESS THEN WE NEED TO GET DEVICE
* CHARACTERISTICS, UPDATE TAPE LABEL, WRITE OUT IDENTIFICATION LINES
* FOR DEBUG, THEN WRITE OUT JCL FOR CALL OF FDR
*
         TM    FLAG1,FLGDISK       DO WE HAVE A NEW DISK VOLSER
         BO    NOUPDT
         MVC   DISK,QVOLSER        SAVE THE DISK ID
         BAL   R14,DEVCHAR         GET DEV TYPE AND SEE IF VOL IS HERE
         CH    R3,=H'9999'        WE CAN ONLY HAVE 4 DIGIT TAPE LABELS
         BNL   NEWJOB             IF REACHED LIMIT START A NEW TAPE
         INCR  R3,1                INCREMENT TAPE LABEL BY 1
         LR    R1,R3
         BAL   R14,BINDEC          CONVERT TO DECIMAL TEXT
         MVC   TAPELBL,12(R1)      SAVE NEW TAPE LABEL
NOUPDT   EQU   *
         CLC   QVOLSER,DISK        REQUEST FOR CURRENT DISK
         BNE   QLOOP               IF NOT SAVE IT FOR LATER
         LA    R9,FDR2             POINT TO FDR2 CONTROL RECORD
         USING FDRCNTL,R9
         MVC   FDR2DSK,QVOLSER     SAVE DISK IN FDR CARD FOR TRACE
         MVC   FDR2USR,QUSERID     REQUESTOR USERID
         MVC   FDR2TPE,TAPEVOL     INSERT TAPE VOLSER
         MVC   FDR2LBL,TAPELBL     TAPE LABEL
         MVC   FDR2DSN,QDSN        PUT DSN INTO FDR CONTROL CARD
         MVI   FDR2ID,C'2'         INSERT CARD ID
         LA    R9,FDR3             POINT TO FDR3 CONTROL RECORD
         MVC   FDR3KEY,QKEY        PUT KEY INTO COMMENT CARD FOR TRACE
         MVI   FDR3ID,C'3'         INSERT CARD ID
         DROP  R9
         PUT   DCBSYSP,FDR2        PUT ONTO LISTING
         PUT   DCBSYSP,FDR3        TO LISTING AS WELL
         TM    FLAG1,FLGDISK       DO WE HAVE A NEW DISK VOLSER
         BO    DSPRCESS
         OI    FLAG1,FLGDISK       MARK GOOD DATASET FOUND
         EJECT
*
* WRITE THE JCL FOR EXEC OF FDRDSF
*
         MVC   JCL5VOL,DISK        INSERT DISK IN DD CARD
         MVC   JCL4STEP,DISK       SET UP STEP NAME AS DVOLSER
         MVC   JCL7LBL,TAPELBL     INSERT IT INTO DD LABEL PARAMETER
         MVC   JCL7DSN1,TAPELBL    AND TAPE DSNAME
         MVC   JCL7DSN2,TAPELBL      TWICE
         MVC   JCL6VOL,TAPEVOL     INSERT TAPE VOLSER
         LA    R4,JCL4             EXEC,STEPLIB,DISK1,TAPE1,CONT
         LA    R7,5
         BAL   R8,PUTFDR
         MVI   JCL6+7,C'1'         MODIFY TAPE1 DDCARD TO TAPE11
         MVI   JCL6VOL+1,C'F'      FOR FIRESTORE COPY
         L     R1,NUMARCS
         SLA   R1,1                DOUBLE IT
         BAL   R14,BINDEC
         LA    R4,FDR1
         USING FDRCNTL,R4
         MVC   FDR1NUM,12(R1)      MOVE IT IN AS MAXCARDS VALUE
         MVI   FDR1ID,C'1'         INSERT CARD ID
         DROP  R4
         LA    R4,JCL6             TAPE11,CONT,SYSPRINT,CONT,SYSIN,DUMP
         LA    R7,6
         BAL   R8,PUTFDR
         MVI   JCL6+7,C' '         CONVERT IT BACK FOR NEXT TIME
         MVI   JCL6VOL+1,C'M'
         EJECT
*
* HERE TO INSERT THE DUMP REQUESTS INTO THE JCL CREATED ABOVE
*   NOTE A LOT OF INFORMATION IS WRITTEN HERE IN COMMENT FORM FOR
*        LATER RETRIEVAL BY RARTRACE
*
DSPRCESS EQU   *
         BAL   R14,CHKSPACE        GET SPACE FOR DS
         PUT   DCBFDR,FDR2         WRITE CONTROL CARD
         PUT   DCBFDR,FDR3         WRITE THIS CARD
         OI    FLAG1,FLGGOOD       MARK AS GOOD ENTRY WRITTEN
GETNEXT  EQU   *
         OI    QACTION,FLAGDEL     MARK REQUEST AS DELETED
         L     R4,NUMARCS          UPDATE COUNT OF NO LEFT TO PROCESS
         DECR  R4
         ST    R4,NUMARCS
         LT    R4,BYTSLEFT         HAVE WE GONE PAST OUR SAFETY MARGIN
         BP    QLOOP
         B     NEWJOB             IF SO START A NEW TAPE
*
* HERE IF THE CURRENT ENTRY COULD NOT BE PROCESSED FOR ANY REASON
*
SKIPENT  EQU   *
         TM    FLAG1,FLGGOOD       HAVE WE DONE A GOOD ONE ON THIS DSK
         BO    GETNEXT             IF SO THEN CARRY ON AS NORMAL
         DECR  R3                  GO BACK ONE LABEL ON THE TAPE
         LR    R1,R3
         BAL   R14,BINDEC          CONVERT TO DECIMAL
         MVC   TAPELBL,12(R1)      AND SAVE IT
         OI    QACTION,FLAGDEL     SKIP THIS ENTRY
         L     R4,NUMARCS          UPDATE COUNT OF NO LEFT TO PROCESS
         DECR  R4
         ST    R4,NUMARCS
         B     DISKJCL             START AGAIN AS IF FOR NEW DISK
         DROP  R6
         EJECT
*
*        WE NEED A NEW JOB TO PROCESS THE REST OF THE REQUESTS
*        BECAUSE WE WANT THE JOB TO HOLD IN JES3 WHILE THE NEW
*        TAPES ARE LABELED
*        SO SET UP NEW NAMES INFO
*
NEWJOB   EQU   *
         PUT   DCBFDR,FDR4         SYSIN TERMINATOR
         BAL   R14,TAPENAME        UPDATE THE TAPE INFO AND INFORM OPS
         OI    FLAG3,FLAGJOB       MARK A NEW JOB WILL BE REQUIRED
*
*        NOW WRITE JCL FOR TRACE BACKUP AND ANALYSIS AFTER FDR RUNS
*
ALLDONE EQU    *
         TM    FLAG1,FLGJOBCD      HAVE WE WRITTEN A JOB CARD
         BZ    NAMESWRT
         LA    R4,JCL20            EXEC,TRACE,BTRACE,SYSPRINT,SYSIN
         LA    R7,8                REPRO,TERMINATOR,EXEC
         BAL   R8,PUTFDR
*        PUT   DCBFDR,JCL12A       STEPLIB ******** TESTING ONLY *****
         LA    R4,JCL13            FDRLOG,SYSPRINT,TRACE
         LA    R7,3
         BAL   R8,PUTFDR
         EJECT
*
*        NOW WRITE NEW VERSION OF NAMES FILE
*
NAMESWRT EQU   *
         TM    FLAG3,FLAGJOB       NEW JOB NEEDED ?
         BO    NEWNAMES            IF SO THEN LOOP BACK
         CH    R3,=H'9999'        IF WE WROTE THE LAST FILE ON TAPE
         BNL   NEWTAPE            THEN START ANOTHER ONE
         L     R4,BYTSLEFT         THIS MANY BYTES LEFT
         S     R4,MARGIN           SUBTRACT OUR MARGIN
         ST    R4,BYTSLEFT         SAVE IT BACK
         BP    PLENTY              IS THERE ANY LEFT REALY
NEWTAPE  EQU   *
         BAL   R14,TAPENAME        IF NOT START A NEW TAPE NEXT TIME
PLENTY   EQU   *
         POINT DCBNAMES,BLOCKADR   POINT TO START OF FILE
         WRITE DECBNAME,SF,DCBNAMES,NAMES,MF=E   & WRITE
         CHECK DECBNAME
         CLOSE (DCBNAMES,,DCBFDR)  CLOSE THE FILES
         NI    FLAG2,X'FF'-FLGNAMES-FLGFDR MARK AS CLOSED
         PUT  DCBSYSP,MSG07        'CONVERSION COMPLETE'
         EJECT
*
* FREE ALL MEMORY USED BY QUEUE
*
FINISH   EQU   *
         L     R5,CHAIN          POINT TO START OF CHAIN
FREEG1   EQU   *
         LTR   R1,R5             ZERO = END OF CHAIN.
         BZ    ENDFREE           YES, 'TIS ALL DONE
         L     R5,0(R1)          POINTS TO NEXT BLOCK.
         FREEMAIN R,LV=BLKSIZE+4,A=(1)
         B     FREEG1            BACK FOR NEXT.
ENDFREE  EQU   *
         ZERO  CHAIN,4           MARK STORE AS FREE
         CLOSE (DCBSYSP)           CLOSE MESSAGES FILE
         NI    FLAG2,X'FF'-FLGSYSP MARK AS CLOSED
         B     THEEND
         EJECT
*
* HERE IF QUEUE IS CORRUPT
*
CORRUPTQ EQU   *                   CORRUPTED FLAG
         PUT   DCBSYSP,MSG06       TOO CORRUPT TO CONTINUE
*
* HERE FOR ALL FAILURES
*
* FREE NEW QUEUE BUFFER AND CLOSE QUEUE
*
FAIL     EQU   *
         MVI   RC,16                SET RETURN CODE
         LT    R2,NEWQBUFF          GET ADDRESS OF NEW QUEUE BUFFER
         BZ    NONFREE
         FREEMAIN R,LV=BLKSIZE,A=(2) FREE UP BUFFER AGAIN
NONFREE  EQU   *
         TM    FLAG2,FLGQUEUE       IS QUEUE STIL OPEN
         BZ    QNOTOPN
         CLOSE (DCBQUEUE,FREE)
QNOTOPN  EQU   *
*
* NOW WE MUST RELEASE LOCK ON QUEUE FILE
*
         TM    FLAG2,FLGENQ         IS QUEUE ENQUED STILL
         BZ    FAILDQ
         DEQ   (QNAME,RNAME,,SYSTEM)
FAILDQ   EQU   *
         EJECT
*
* REWIND AND CLOSE JCL FILE, AND CLOSE NAMES FILE
*
         TM    FLAG2,FLGFDR
         BZ    CLOSE3
* WE MUST REWIND DCBFDR HERE TO STOP JCL FROM BEING PROCESSED
         CLOSE (DCBFDR)
CLOSE3   EQU   *
         TM    FLAG2,FLGNAMES
         BZ    CLOSE4
         CLOSE (DCBNAMES)
CLOSE4   EQU   *
*
* FREMAIN QUEUE STORAGE
*
         L     R5,CHAIN          POINT TO START OF CHAIN
FAILG1   EQU   *
         LTR   R1,R5             ZERO = END OF CHAIN.
         BZ    FAILG2            YES, 'TIS ALL DONE
         L     R5,0(R1)          POINTS TO NEXT BLOCK.
         FREEMAIN R,LV=BLKSIZE+4,A=(1)
         B     FAILG1            BACK FOR NEXT.
FAILG2   EQU   *
         EJECT
*
* FINALLY CLOSE MESSAGES FILE IF REQUIRED
*
         TM    FLAG2,FLGSYSP
         BZ    CLOSE1
         CLOSE (DCBSYSP)
CLOSE1   EQU   *
*
THEEND   EQU   *
         ZR    R10
         IC    R10,RC              FETCH RETURN CODE
         CH    R10,=H'8'           ARE THERE ANY ERROR MESSAGES
         BL    NOWTO
         WTO   'RARDU99I **********************************************+
               ****************',ROUTCDE=1,DESC=3
WTOAGAIN EQU   *
         WTO   'RARDU99I IMPORTANT MESSAGES ON SYSPRINT - PLEASE READ O+
               UTPUT AND TAKE REQUIRED ACTION',ROUTCDE=1,DESC=7
         WTO   'RARDU99I **********************************************+
               ****************',ROUTCDE=1,DESC=7
         MVI   WTORECB,0          INITIALIZE ECB
         WTOR  'RARDU99I REPLY C TO CONTINUE OR R TO RESHOW MESSAGE',  +
               WTOREPLY,1,WTORECB,ROUTCDE=1
         WAIT  ECB=WTORECB,RELATED=WTOR
         CLI   WTOREPLY,C'C'      ARE WE TO CONTINUE
         BNE   WTOAGAIN           IF NOT REPEAT MESSAGE
NOWTO    EQU   *
         GOODBY RC=(10)
         EJECT
*
* SUBROUTINE TO TEST A DCB FOR OPEN AND ISSUE A MESSAGE IF NOT
* USES R0,R1
*
TESTOPEN EQU   *
         USING IHADCB,R5
         TM    DCBOFLGS,DCBOFOPN   OPENED ?
         BOR   R4                  YES
         MVC   MSG02DD,DCBDDNAM    YES SO WRITE A MESSAGE
         DROP  R5                  DCB NO LONGER NEEDED
         PUT   DCBSYSP,MSG02
         B     FAIL
         EJECT
*  ______________________
* × SUBROUTINE GETRECORD.×
*  ----------------------
* GET A RECORD FROM THE BUFFERS.
* RETURNS R6=POINTER TO NEW RECORD
*     R5 (BLOCK POINTER) MUST BE PRESERVED BETWEEN CALLS
* USES R8
*
GETRECOR EQU   *
         ST    R14,SAVEDR14     SAVE RETURN ADDRESS.
         TM    FLAG1,FLGFIRST   FIRST TIME ?
         BZ    GET001           YES
         LR    R8,R6            POINT TO PREVIOUS RECORD
         USING QUEUEMAP,R8
         INCR  R6,127           INCREMENT POINTER
         TM    QEND,BLKEND      WAS IT THE LAST IN THE BLOCK
         BZ    GET002           IF NOT RETURN POINTER
         TM    QEND,QUEEND      IF SO HAVE WE RUN OFF END
         BO    CORRUPTQ
         DROP  R8
         B     GET001A
GET001   EQU   *
         LA    R5,CHAIN         YES, GET BEGINNING OF CHAIN.
         OI    FLAG1,FLGFIRST   SET 'FIRST-TIME-DONE' FLAG.
GET001A  EQU   *
         L     R5,0(R5)         GET ADDRESS OF NEXT BIT.
         LA    R6,4(R5)         POINTS TO FIRST RECORD.
GET002   EQU   *
         L     R14,SAVEDR14     RESTORE RETURN ADDRESS.
         BR    R14
         EJECT
*
* SUBROUTINE PUTFDR TO WRITE A NUMBER OF RECORDS TO FDR/JCL FILE
* ENTRY WITH R4-> FIRST RECORD
*            R7 = NUMBER OF RECORDS
*
PUTFDR   EQU   *
         PUT   DCBFDR,(4)
         INCR  R4,80          MOVE ON TO NEXT RECORD
         BCT   R7,PUTFDR
         BR    R8             RETURN
*
*  ___________________
* × SUBROUTINE BINDEC ×
*  -------------------
*
*       ON ENTRY R1 CONTAINS NUMBER TO BE CONVERTED
*       ON EXIT R1 CONTAINS ADDRESS OF CONVERTED NUMBER
*
BINDEC   EQU   *
         CVD   R1,CPACK
         UNPK  CUNPK,CPACK
         OI    CUNPK+15,X'F0'     MAKE LAST DIGIT A NUMBER
         LA    R1,CUNPK
         BR    R14
         EJECT
*        _______________________
*        × SUBROUTINE SENDMESG ×
*        -----------------------
*
* A ROUTINE TO SEND A MESSAGE TO THE REQUESTOR USING OUR OWN SVC
*  ON ENTRY
*        R1 POINTS TO PARM LIST AS FOLLOWS
*          0 ->DSN                 DATASET NAME
*          4 ->USERID              REQUESTOR
*          8 ->MISSMSG             INFO MESSAGE
*         12 ->MISSMSGL            INFO MESSAGE LENGTH
*  RESTORES ALL REGISTERS BEFORE RETURN
*
SENDMESG EQU   *
         STM   R1,R5,GSAVE
         L     R2,0(R1)            POINT TO DSN
         CLI   0(R1),C' '          DON'T PROCESS IF BLANK
         BER   R14
         LA    R3,43(R2)           POINT TO END OF DSN
         LA    R4,44               MAX POSS LENGTH
SEND01   EQU   *
         CLI   0(R3),C' '          FIND LENGTH OF DSN
         BNE   SEND02
         DECR  R4
         BCT   R3,SEND01
SEND02   EQU   *
         BLANK SENDMSG+6,75        BLANK TARGET FOR MEESSAGE
         MVC   SENDMSG+6(44),0(R2) & MOVE IT
         LA    R5,SENDMSG+6(R4)    POINT TO END OF DSN
         MVI   0(R5),C'"'          INSERT TRAILING QUOTE
         L     R3,12(R1)           POINT TO LENGTH
         LH    R2,0(R3)            & LOAD IT
         DECR  R2                  FOR EXECUTE
         L     R3,8(R1)            POINT TO MESSAGE
         EX    R2,MOVESEND         MOVE MESSAGE TO TARGET
         LA    R4,8(R2,R4)         GET FINAL MESSAGE LENGTH
         STC   R4,SENDMSG          & INSERT IT
         L     R2,4(R1)            POINT TO USERID
         MVC   SENDUSER,0(R2)      MOVE IT
         LA    R1,SENDPTR
         SVC   241                 ISSUE NOTIFY SVC
         LM    R1,R5,GSAVE
         BR    R14
MOVESEND MVC   2(0,R5),0(R3)       MOVE MESSAGE
         DS    0H
         EJECT
*        -----------------------
*        × SUBROUTINE TAPENAME ×
*        -----------------------
*
*        CREATE NEW TAPE INFO ON NAMES FILE
* NO PARAMETERS
* RESTORES ALL REGISTERS BEFORE RETURN
*
TAPENAME EQU   *
         STM   R14,R5,GSAVE
         MVC   MSG45TAP,TAPEVOL    INSERT CURRENT TAPE VOLSER
         MVI   MSG45TAP+1,C'F'     FOR FIRESTORE INTO MESSAGE
         PUT   DCBSYSP,MSG44
         PUT   DCBSYSP,MSG45       PRINT THIS TO LISTING
         MVI   RC,8                SET RETURN CODE
         MVC   TAPELBL,=C'0000'    ZERO FOR LAST USED LABEL
         MVC   BYTSLEFT,MAXBYTS    NO OF BYTES ON TAPE
         LA    R4,4                NUMBER OF DIGITS IN VOLSER
         LA    R2,TAPEVOL+5        POINT TO LAST DIGIT OF VOLSER
         BAL   R14,UPDATEL         INCREMENT IT BY ONE
         PUT   DCBSYSP,MSG47
         MVC   MSG45TAP,TAPEVOL    INSERT NEW TAPE VOLSER
         PUT   DCBSYSP,MSG45       PRINT THIS TO LISTING
         MVI   MSG45TAP+1,C'F'     FOR FIRESTORE INTO MESSAGE
         PUT   DCBSYSP,MSG45       PRINT THIS TO LISTING
         LM    R14,R5,GSAVE
         BR    R14
         EJECT
*        _______________________
*        × SUBROUTINE CHKSPACE ×
*        -----------------------
*
*         CALC  SPACE OF DS. AND UPDATE SPACE REMAINING ON TAPE
* ALL REGISTERS RESTORED ON RETURN EXCEPT R1
*
CHKSPACE EQU   *
         STM   R2,R9,GSAVE
         USING QUEUEMAP,R6
         MVC   OBDSN,QDSN          DATASET NAME
         MVC   OBVOLSER,QVOLSER    VOLUME
         OBTAIN DSCB1OB            GET FMT 1 DSCB
         LTR   R15,R15
         BZ    OBCONT
         PUT   DCBSYSP,MSG43
         MVI   RC,8                SET RETURN CODE (USER ERROR)
         LM    R2,R9,GSAVE         RESTORE REGISTERS
         LA    R1,QDSN             SET UP PARM LIST FOR SEND
         ST    R1,SENDPARM         BECAUSE DATASET NOT FOUND
         LA    R1,QUSERID
         ST    R1,SENDPARM+4
         LA    R1,MISSMSG
         ST    R1,SENDPARM+8
         LA    R1,MISSMSGL
         ST    R1,SENDPARM+12
         LA    R1,SENDPARM
         BAL   R14,SENDMESG
         DROP  R6
         B     SKIPENT             SKIP THIS ENTRY
OBCONT   EQU   *
         LA    R8,DSCB1            ADDRESS OF FMT1 DSCB
         USING IECSDSL1+44,R8      ONLY FIRST 96 FOR DSCB1
         CLI   DS1NOEPV,X'03'      IF <= 3 ONLY DSCB1 NEEDED
         BNH   CLCAVAIL
         MVC   CCHHR,DS1PTRDS      POINT TO NEXT DSCB
         OBTAIN DSCB3OB            GET FMT 3 DSCB
         LTR   R15,R15
         BZ    CLCAVAIL            IF THIS FAILS THE VTOC IS CORRUPT
         MVI   DS1NOEPV,X'03'      ONLY 3 EXTENTS FOUND IGNORE REST
*                                  ALL INFO GOT TO CALC SPACE
CLCAVAIL EQU   *
         DROP  R8
         EJECT
*
* NOW WE MUST CALCULATE THE SPACE USED IN BYTES BY THIS DATASET
*
         LA    R1,DSCB1            POINT TO 236 BYTES CONTAINING DSCBS
         ZR    R9                  TOTALLING REG
         USING IECSDSL1+44,R1      MAP DSCB1
         ZR    R3
         IC    R3,DS1NOEPV         GET NO OF EXTENTS
         LA    R2,3                NO OF EXTENTS AT THIS LOCATION
         LA    R4,DS1EXT1          POINT TO EXTENT INFO
         CR    R3,R2               HAVE WE AS MANY AS THIS
         BH    CALC1               MORE THAN 3
         LR    R2,R3               IF NOT THEN LOOK AT LESS
CALC1    BAL   R7,CALCEXT          CALC THESE EXTENTS
         SH    R3,=H'3'            KNOCK 3 OFF THE RUNNING COUNT
         BNP   FINCALC             ALL DONE ?
         DROP  R1
         LA    R1,96(R1)           LOOK AT DSCB FMT3
         USING IECSDSL3,R1        MAP THIS DSCB
         LA    R2,4                NO EXTENTS AT THIS LOCATION
         LA    R4,DS3EXTNT         POINT TO EXTENT INFO
         CR    R3,R2               HAVE WE AS MANY AS THIS
         BH    CALC2               MORE THAN 4
         LR    R2,R3               IF NOT THEN LOOK AT LESS
CALC2    BAL   R7,CALCEXT          CALC THESE EXTENTS
         SH    R3,=H'4'            KNOCK 4 OF THE RUNNING COUNT
         BNP   FINCALC             ALL DONE ?
         LR    R2,R3               THIS MANY LEFT (MAX 9)
         LA    R4,DS3ADEXT         POINT TO EXTENT INFO
         DROP  R1
         BAL   R7,CALCEXT
FINCALC  EQU   *
         M     R8,MAXBLOCK         CONVERT TRACKS TO BYTES
         C     R9,MAXSIZE          IS IT TOO BIG FOR US TO PROCESS
         BNL   TOOBIG
         L     R5,BYTSLEFT
         SR    R5,R9               CHOP THIS OFF THE RUNNING TOTAL
         ST    R5,BYTSLEFT         AND SAVE BACK
         LM    R2,R9,GSAVE
         BR    R14                 RETURN
         EJECT
*
* DATASET IS TOO BIG FOR US TO PROCESS
*
TOOBIG   EQU   *
         PUT   DCBSYSP,MSG42         PRINT OUT MESSAGE
         MVI   RC,8                  SET RETURN CODE (USER ERROR)
         LM    R2,R9,GSAVE           RESTORE REGISTERS
         USING QUEUEMAP,R6
         LA    R1,QDSN             SET UP PARM LIST FOR SEND
         ST    R1,SENDPARM         BECAUSE DATASET TOO BIG FOR US
         LA    R1,QUSERID
         ST    R1,SENDPARM+4
         LA    R1,DBIGMSG
         ST    R1,SENDPARM+8
         LA    R1,DBIGMSGL
         ST    R1,SENDPARM+12
         LA    R1,SENDPARM
         BAL   R14,SENDMESG
         DROP  R6
         B     SKIPENT
         EJECT
*
* SUBROUTINE TO
*        CALCULATE SPACE FOR EACH EXTENT
* ON ENTRY R2 = NO OF EXTENT DESCRIPTIONS AT THIS POINT
*          R4 -> THE FIRST EXTENT DESCRIPTION
*          R9 = RUNNING TOTAL OF TRACKS FOR THIS DS
* USES R5,R6
*
CALCEXT  EQU   *
         ZR    R5
         ICM   R5,3,6(R4)        ENDING CYL ADDR
         ZR    R6
         ICM   R6,3,2(R4)         STARTING CYL ADDR
         SR    R5,R6
         MH    R5,TRKPCYL        DIFFERENCE IN TRACKS
         ICM   R6,3,8(R4)         ENDING TRACK ADDR
         AR    R5,R6
         ICM   R6,3,4(R4)         STARTING TRACK ADDR
         SR    R5,R6              = NO OF TRACKS THIS EXTENT
         LA    R9,1(R9,R5)      TOTAL TRACKS
         INCR  R4,10               POINT TO NEXT EXTENT
         BCT   R2,CALCEXT     CALCULATE TRACKS FOR NEXT EXTENT
         BR    R7
         EJECT
*
*        ----------------------
*        × SUBROUTINE DEVCHAR ×
*        ----------------------
*
*        GET   DEVICE CHARACTERISTICS
* WE ALLOCATE THE DRIVE TO ENSURE IT STAYS MOUNTED
*  WHILE WE ARE PROCESSING THE DATASETS ON IT
*
DEVCHAR  EQU   *
         MVC   VOLSER,DISK         THIS DISK
         LA    R1,RBPTR
         DYNALLOC
* PROBLEM HERE WHAT DO WE DO WITH MOUNTABLE PACKS ?
* WE MAY REQUIRE MORE VOLUMES THAN THERE ARE AVAILABLE DRIVES
* FOR THE MOMENT WE WILL IGNORE THOSE REQUESTS
         LTR   R15,R15
         BNZ   DEVERR
         DEVTYPE DDDISK,DISKCHAR,DEVTAB,RPS
         BR    R14
*
* ISSUE DYNAMIC ALLOCATION ERROR MESSAGE
*
DEVERR   EQU   *
         STM   R2,R5,GSAVE
         UNPK  CUNPK(5),ERROR(3)     CONVERT ERROR CODE TO CHARS
         TR    CUNPK(4),HEXTAB-C'0'  NOW TO PROPER EBCDIC
         MVC   MSG01ERR,CUNPK        MOVE TO MESSAGE
         UNPK  CUNPK(5),INFO(3)      DITTO FOR INFO CODE
         TR    CUNPK(4),HEXTAB-C'0'
         MVC   MSG01INF,CUNPK
         LR    R1,R15                GET RETURN CODE
         BAL   R14,BINDEC            TO DECIMAL
         MVC   MSG01RC,14(R1)        MOVE TO MESSAGE
         PUT   DCBSYSP,MSG01         PRINT OUT MESSAGE
         MVC   MSG46VOL,DISK         INSERT VOLSER INTO MESSAGE BECAUSE
         PUT   DCBSYSP,MSG46         IDENT LINES NOT PRINTED OUT YET.
         MVI   RC,12                 SET RETURN CODE
         LM    R2,R5,GSAVE           RESTORE REGISTERS
         USING QUEUEMAP,R6
         LA    R1,QDSN             SET UP PARM LIST FOR SEND
         ST    R1,SENDPARM         BECAUSE UNABLE TO ALLOCATE VOLUME
         LA    R1,QUSERID
         ST    R1,SENDPARM+4
         LA    R1,UALCMSG
         ST    R1,SENDPARM+8
         LA    R1,UALCMSGL
         ST    R1,SENDPARM+12
         LA    R1,SENDPARM
         BAL   R14,SENDMESG
         DROP  R6
         B     GETNEXT               AND TRY FOR NEXT DATASET
         EJECT
*
* SUBROUTINE TO INCREMENT A CHARACTER NUMBER
* ON ENTRY R4=NUMBER OF DIGITS
*          R2->LAST DIGIT OF NUMBER
*
UPDATEL  EQU   *
         XR    R3,R3               ZERO THIS REG. TO RECIEVE CHAR.
         IC    R3,0(R2)            FETCH THE CHARACTER.
         INCR  R3                  INCREMENT IT.
         STC   R3,0(R2)            SAVE IT.
         CLI   0(R2),X'FA'         OVER THE TOP ?
         BNER  R14                 NO, ALL DONE
         MVI   0(R2),C'0'          WAS, SO RESET TO ZERO.
         DECR  R2                  DECREMENT POINTER.
         BCT   R4,UPDATEL          DECREMENT COUNT.
         BR    R14                 RETURN.
         EJECT
         LTORG
         DROP  R12,R11
         EJECT
*
*        DATA AREAS  - BASE AND FLAGS
*
BASE2    DC    A(RARDUMP+4096)
*
FLAG1    DC    X'00'
FLGDISK  EQU   X'80'        ON FOR DSN FOR CURRENT STEP
FLGJOBCD EQU   X'40'        ON TO GENERATE JCL FOR FDR
FLGFIRST EQU   X'20'        FIRST TIME ON INPUT FLAG.
FLGWORK  EQU   X'10'        WORK TO DO FLAG
FLGHEAD  EQU   X'08'        LISTING HEADER PRINTED
FLGGOOD  EQU   X'04'        MARK GOOD DATASET PROCESSED FOR THIS DISK
*
FLAG2    DC    X'00'
FLGSYSP  EQU   X'80'        SYSPRINT OPEN
FLGFDR   EQU   X'40'        FDR/JCL FILE OPEN
FLGNAMES EQU   X'08'        NAMES FILE OPEN
FLGQUEUE EQU   X'04'        QUEUE FILE OPEN
FLGENQ   EQU   X'02'        QUEUE ENQUEUED
*
FLAG3    DC    X'00'
FLAGJOB  EQU   X'80'        SECOND JOB REQUIRED FOR THIS RUN
*
RC       DC    X'00'        RETURN CODE
* VALUES ARE   0 - SUCCESSFUL RUN
*              4 - NO REQUESTS TO PROCESS
*              8 - OPERATOR ACTION REQUIRED (OR AT LEAST 1 USER ERROR)
*             12 - AT LEAST ONE REQUEST FAILED
*             16 - SERIOUS ERROR ALL REQUESTS ABANDONED
         EJECT
*
*        MESSAGES
*
* COLS 1'ST LINE   0----+----1----+----2----+----3----+----4----+----51
*      2'ND   52--+----6----+----7----+----80
MSG01    DC    CL80'RARDU01I ERROR DURING DYNAMIC ALLOCATION OF DISK RC+
               =00, ERROR=0000, INFO=0000'
MSG01RC  EQU   MSG01+52,2
MSG01ERR EQU   MSG01+62,4
MSG01INF EQU   MSG01+73,4
MSG02    DC    CL80'RARDU02I UNABLE TO OPEN DATASET - DDNAME=ABCDEFGH'
MSG02DD  EQU   MSG02+41,8
MSG05    DC    CL80'RARDU05I FDR CONTROL CARDS'
MSG06    DC    CL80'RARDU06I CORRUPT ENTRY ON QUEUE PROCESSING ENDS'
MSG07    DC    CL80'RARDU07I CONVERSION COMPLETE.'
MSG09    DC    CL80'       DATASETNAME                                 +
                 DISK  USER   TAPE  LABEL'
MSG41    DC    CL80'RARDU41I NO ARCHIVE REQUESTS TO PROCESS'
MSG42    DC    CL80'RARDU42I DATASET TO LARGE TO PROCESS - USER ERROR -+
                REQUEST IGNORED'
MSG43    DC    CL80'RARDU43I DATASET NOT FOUND TO PROCESS - USER ERROR +
               - REQUEST IGNORED'
MSG44    DC    CL80'RARDU44I *** TRANSFER THE FOLLOWING TAPE TO THE FIR+
               ESTORE AFTER USE TODAY'
MSG45    DC    CL80'RARDU45I VOLSER - ABCDEF'
MSG45TAP EQU   MSG45+18,6
MSG46    DC    CL80'RARDU46I - REQUEST IGNORED (VOLSER=ABCDEF)'
MSG46VOL EQU   MSG46+35,6
MSG47    DC    CL80'RARDU47I *** ENSURE THAT THE FOLLOWING 2400 FT. 625+
               0 BPI SL TAPES EXIST ***'
*
MISSMSGL DC    AL2(MISSLGTH)
MISSMSG  DC    C'DATASET NOT FOUND'
MISSLGTH EQU   *-MISSMSG
*
UALCMSGL DC    AL2(UALCLGTH)
UALCMSG  DC    C'ALLOCATION ERROR'
UALCLGTH EQU   *-UALCMSG
*
DBIGMSGL DC    AL2(DBIGLGTH)
DBIGMSG  DC    C'DATASET TOO LARGE'
DBIGLGTH EQU   *-DBIGMSG
         EJECT
*
*       CARD IMAGES FOR FDR JCL ETC
* NOTE: THE ORDER OF THESE STATEMENTS IS IMPORTANT
*
         PRINT OFF
HASHZ    DC    XL8'C0C0C0C0C0C0C0C0'
         PRINT ON
* COLS 1'ST LINE   0----+----1----+----2----+----3----+----4----+----5-
*      2'ND   52--+----6----+----7----+----80
* JOBCARD GROUP
JCL1     DC    CL80'//JOBNAMEA JOB ,ARCHIVE, **ARCHIVE GENERATED JOB'
JCL1INDX EQU   JCL1+9
JCL2     DC    CL80'//        MSGLEVEL=(1,1),PASSWORD=????????,'
JCL2Q    EQU   JCL2+34,8
JCL3     DC    CL80'//        USER=USERIDX,MSGCLASS=A'
* FDR GROUP 1
JCL4     DC    CL80'//DVOLSER EXEC PGM=FDRDSF,COND=EVEN'
JCL4STEP EQU   JCL4+3,6
JCL4A    DC    CL80'//STEPLIB DD DSN=SYS2.FDRCPK,DISP=SHR'
JCL5     DC    CL80'//DISK1  DD UNIT=SYSDA,DISP=SHR,VOL=SER=VOLSER'
JCL5VOL  EQU   JCL5+40,6
* FDR GROUP 2 (NOTE OVERLAPS FDR GROUP 1)
JCL6     DC    CL80'//TAPE1  DD UNIT=TAPE62,DISP=(NEW,PASS),VOL=SER=VOL+
               SER,'
JCL6VOL  EQU   JCL6+48,6
JCL7     DC    CL80'//       LABEL=(0000,SL),DSN=ARC0000.AAA0000'
JCL7LBL  EQU   JCL7+16,4
JCL7DSN1 EQU   JCL7+32,4
JCL7DSN2 EQU   JCL7+40,4
*
JCL9     DC    CL80'//SYSPRINT DD DISP=(MOD,PASS),UNIT=VIO,DSN=&&PRT,'
JCL10    DC    CL80'//         DCB=(LRECL=121,BLKSIZE=6050,RECFM=FBA)'
JCL11    DC    CL80'//SYSIN DD *'
* NOTE: THE FORMAT OF THE FDR CARDS MUST BE REFLECTED BY RARTRACE CODE
FDR1     DC    CL80'  DUMP    TYPE=DSF,MAXCARDS='
*
FDR2     DC    CL80' S DSN='
*
FDR3     DC    CL80'*'
* BACKUP/ANALYSIS GROUP
JCL20    DC    CL80'//BCKUPTRA EXEC PGM=IDCAMS,COND=EVEN'
JCL21    DC    CL80'//TRACE    DD DISP=SHR,DSN=SYS2.ARCHIVE.TRACE'
JCL22    DC    CL80'//BTRACE DD DISP=OLD,DSN=SYS2.ARCHIVE.TRACE.BACKUP'
JCL23    DC    CL80'//SYSPRINT DD  SYSOUT=*'
JCL23A   DC    CL80'//SYSIN    DD *'
JCL23B   DC    CL80' REPRO INFILE(TRACE) OUTFILE(BTRACE)'
FDR4     DC    CL80'/*'
JCL12    DC    CL80'//ANALYSIS EXEC PGM=RARTRACE,COND=EVEN'
* NOTE STEPLIB *********** TESTING ONLY ****************
* JCL12A DC    CL80'//STEPLIB DD DSN=A012006.ARCHIVE.LOAD,DISP=SHR'
* ANALYSIS/WTO GROUP
JCL13    DC    CL80'//FDRLOG   DD DISP=OLD,DSN=&&PRT'
JCL15    DC    CL80'//SYSPRINT DD SYSOUT=*'
JCL16    DC    CL80'//TRACE    DD DSN=SYS2.ARCHIVE.TRACE,DISP=SHR'
         PRINT OFF
HASHN    DC    XL8'0101010101010101'
         PRINT ON
         EJECT
*
*        DYNAMIC ALLOCATION PARAMETERS
*
         DS    0F
RBPTR    DC    X'80',AL3(RB)
RB       DC    X'14'
DYNVERB  DC    X'01'               ALLOC ON DSNAME
DYNFLG1  DC    X'00'
DYNFLG2  DC    X'00'
ERROR    DC    H'0'
INFO     DC    H'0'
LISTPTR  DC    A(DYNLIST)
         DC    2F'0'
DYNLIST  EQU    *
TP55     DC    A(TU55)
TP4      DC    A(TU4)
TP7      DC    A(TU7)
TPA      DC    A(TUA)
TP10     DC    A(TU10)
TP15     DC    X'80',AL3(TU15)
*
TU55     DC    X'0055',X'0001'     DDNAME RETURN
         DC    X'0008'
DDDISK   DS    CL8
TU4      DC    X'0004',X'0001',X'0001'
         DC    X'04'               NEW
TU7      DC    X'0007',X'0000'
TUA      DC    X'000A',X'0001',X'0003'
         DC    X'000000'
TU10     DC    X'0010',X'0001',X'0006'
VOLSER   DS    CL6
TU15     DC    X'0015',X'0001',X'0005',C'SYSDA'
         EJECT
*
*        GENERAL WORK AREAS AND DATA
*
QNAME    DC    CL8'ARCHIVE'
RNAME    DC    CL8'QUEUE'
*
CHAIN    DC    A(0)        BEGINNING OF THE INPUT CHAIN.
NEWQBUFF DC    A(0)        ADDRESS OF BUFFER FOR NEW QUEUE
SAVEDR14 DS    A           SAVED RETURN ADDRESS.
GSAVE    DS    16F         GENERAL SAVE AREA
SENDPARM DS    4A          PARAMETERS FOR SENDMESG SUBROUTINE
SENDUSER DS    CL7         USERID FOR SVC SEND
SENDMSG  DS    0XL81               MESSAGE WORK AREA FOR SVC
         DS    X                   LENGTH OF MESSAGE FOR SVC
         DC    CL80'ARC "'         MESSAGE FOR SVC
SENDPTR  DC    A(SENDUSER) POINT TO USERID FOR SVC
         DC    A(SENDMSG)  POINT TO MESSAGE
*
NAMES    DS    CL80        TAPE INFO FROM NAMES FILE
         ORG   NAMES
TAPEVOL  DS    CL6           VOLSER OF CURRENT TAPE
TAPELBL  DS    CL4           LAST LABEL USED ON TAPE
DUMPNO   DS    CL6           NOT USED
BYTSLEFT DS    F             BYTES LEFT ON TAPE
MAXBYTS  DS    F             MAX BYTES ON TAPE
MAXLABEL DS    CL4           MAX LABEL ON TAPE
         ORG
*
BLOCKADR DC    F'1'         POINTS TO FIRST BLOCK.
NUMARCS  DS    F             TOTAL NUMBER OF ARCHIVE REQUESTS
DISK     DS    CL6           CURRENT DISK VOLSER
*
HEXTAB   DC    C'0123456789ABCDEF'
DSCB1    DS    XL96
DSCB3    DS    XL140
DSCB1OB  CAMLST SEARCH,OBDSN,OBVOLSER,DSCB1
DSCB3OB  CAMLST SEEK,CCHHR,OBVOLSER,DSCB3
CCHHR    DS    XL5             CYL/TRACK/RECORD INFO.
OBDSN    DS    CL44
OBVOLSER DS    CL6
MARGIN   DC    F'52428800'         50 MEGABYTES OVERSPILL ALLOWED
MAXSIZE  DC    F'104857600'        100 MEGABYTES MAX DATASET SIZE
*
DISKCHAR DS    0F                  6 WORDS FOR DEVCHAR
DISKTYPE DS    F             UCB TYPE
MAXBLOCK DS    F             MAX BLOCK SIZE
NUMCYLS  DS    H             NUMBER OF CYLINDERS ON VOLUME
TRKPCYL  DS    H             TRACKS PER CYLINDER
BYTSPTRK DS    H             BYTES PER TRACK
         DS    H             OTHER DATA
         DS    2F                      ETC.
*
CPACK    DS    D
CUNPK    DS    CL16
WTORECB  DS    A                  ECB FOR WTO REPLY
WTOREPLY DS    C                  MESSAGE FROM WTOR
         EJECT
*
* THE DCB'S
*
         PRINT  NOGEN
DCBQUEUE DCB   DDNAME=QUEUE,DSORG=PS,MACRF=(RP,WP),RECFM=F,            *
               LRECL=BLKSIZE,BLKSIZE=BLKSIZE,EODAD=CORRUPTQ
DCBNAMES DCB   DDNAME=NAMES,DSORG=PS,MACRF=(RP,WP),RECFM=F,            *
               LRECL=80,BLKSIZE=80
DCBFDR   DCB   DDNAME=FDRJCL,DSORG=PS,MACRF=(PM),RECFM=FB,             *
               LRECL=80,BLKSIZE=3120
DCBSYSP  DCB   DDNAME=SYSPRINT,DSORG=PS,MACRF=(PM),RECFM=FB,           *
               EROPT=ACC,LRECL=80,BLKSIZE=3120
         PRINT GEN
         EJECT
*
*        MAP   QUEUE AND GET FLAGS ON QUEUE
*
         RARMACRO
*
         PRINT NOGEN
         IECSDSL1 (1,3)           MAPD DSCB'S
         DCBD  DSORG=PS,DEVD=DA
         END
