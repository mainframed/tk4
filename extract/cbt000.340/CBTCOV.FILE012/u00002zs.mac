AMM.     TITLE 'RTP5005M - CONSOLE CONTROLLED DASD LISTING PROGRAM - A.*
               MORRISH.'
RT5005M  CSECT
***********************************************************************
*                                                                     *
*  THIS PROGRAM SCANS A DIRECT ACCESS DEVICE SPECIFIED BY THE USER    *
* VIA THE SYSTEM CONSOLE BETWEEN THE USER SPECIFIED LIMITS, AND LISTS $
* THE TRACKS SCANNED ON THE SYSPRINT DATA SET. THE USER MAY REQUEST   $
* A CONSOLE LISTING OF TRACKS ALLOCATED TO ANY DATA SET ON THE DEVICE *
* SPECIFIED. VARIOUS OTHER OPTIONS ARE AVAILABLE,                     *
*                                                                     *
***********************************************************************
         SPACE 1
* REGISTER USAGE.
R0       EQU   0                   WORK REGISTER.
R1       EQU   1                   WORK REGISTER / PARAMETER REGISTER.
R2       EQU   2                   POINTER TO TRANSLATE TABLE.
R3       EQU   3
R4       EQU   4                   PREVIOUSLY PRINTED DATA.
R5       EQU   5                   OFFSET OF DATA FOR PRINT.
R6       EQU   6                   ADDRESS OF DATA FOR PRINT.
R7       EQU   7                   DATA RESIDUAL COUNT.
R8       EQU   8                   LINK REGISTER.
R9       EQU   9                   LINK REGISTER.
R10      EQU   10                  UCB ADDRESS FOR LISTING.
R11      EQU   11                  ADDRESS OF TIOT DD ENTRY FOR SYSUT1.
RBASE    EQU   12                  BASE REGISTER.
R13      EQU   13                  SAVE AREA POINTER.
R14      EQU   14                  RETURN ADDRESS.
R15      EQU   15                  ENTRY POINT ADDRESS / RETURN CODE.
         EJECT
         BEGIN (SAVE,,SAVE),BASE=RBASE  INITIALISE AND DEFINE BASE REGS
         SPACE 1
*
*        LINK TO INITIALISATION ROUTINE.
*
         SPACE 1
         L     R15,VINIT           SET GR15 -> INITIALISATION CSECT.
         BR    R15                 GO TO INITIALISE.
AFTINIT  DS    0H
         SPACE 1
*
*        WAIT FOR REPLY.
*
         SPACE 1
WAIT1    BAL   R9,WAIT             LINK TO WAIT FOR DEVICE SPECIFICATN.
         SPACE 1
*
*        CHECK DEVICE SPECIFICATION.
*
         SPACE 1
         CLI   REP+3,C' '          IS FOURTH CHARACTER OF REPLY BLANK ?
         BE    FINDUCB             IF SO THEN MUST BE ADDRESS.
         CLI   REP+3,C'/'          IS FOURTH CHARACTER OF REPLY SLASH ?
         BE    FINDUCB             IF SO THEN MUST BE ADDRESS.
         L     R1,16               SET GR1 -> CVT.
         L     R1,40(R1)           SET GR1 -> CVT LOOK-UP TABLE.
LOOP6    LH    R10,0(R1)           SET GR1 -> UCB.
         LTR   R10,R10             TEST SIGN OF GR10.
         BM    ERR01               IF MINUS THEN NOT FOUND.
         BZ    GAP                 IF ZERO THEN GAP IN TABLE.
         CLI   18(R10),X'20'       IS DEVICE DASD ?
         BNE   GAP                 IF NOT THEN GO TO TEST FOR GAP.
         CLC   28(6,R10),REP       COMPARE SERIAL NUMBERS.
         BE    SERFND              IF EQUAL THEN SERIAL FOUND.
GAP      LA    R1,2(R1)            INCREMENT GR1 FOR NEXT UCB.
         B     LOOP6               GO TO TEST NEXT UCB.
FINDUCB  FINDUCB DEVADDR=REP,TO=(R10)   FIND UCB ADDRESS.
         CLC   13(3,R10),REP       COMPARE UNIT NAME WITH SPECIFIED NM.
         BNZ   ERR01               IF INVALID UCB THEN GO TO REPEAT REQ
         CLI   28(R10),0           IS DEVICE MOUNTED ?
         BE    ERR01               IF NOT THEN GO TO REPEAT REQUEST.
         CLI   18(R10),X'20'       IS DEVICE DASD ?
         BNE   ERR01               IF NOT THEN GO TO REPEAT REQUEST.
SERFND   XC    REP,REP             CLEAR REPLY AREA.
         MVC   WTOR2+43(6),28(R10) STORE SERIAL NUMBER IN REPLY.
         MVC   WTOR2+53(3),13(R10) STORE DEVICE ADDRESS IN REPLY.
         SPACE 1
*
*        REQUEST LISTING LIMITS.
*
         SPACE 1
         LA    R1,WTOR2            SET GR1 -> REQUEST LIMITS MESSAGE.
         BAL   R9,WTOR             LINK TO WRITE TO OPERATOR.
         SPACE 1
*
*        SET UP HEADING AND OPEN DATA SET.
*
         SPACE 1
         L     R1,TIOTPTR          SET GR1 -> TIOT DD ENTRY
         SPMODE PROB,0,MF=(E,SPML) ALLOW UPDATE TO TIOT FOR MVT.
         STH   R10,18(R1)          STORE UCB ADDRESS IN TIOT.
         SPMODE PROB,*,MF=(E,SPML) RESTORE USER PROTECT KEY.
         MVI   JFCB,X'04'          STORE X'04' IN FORST BYTE OF JFCB.
         MVC   JFCB+1(43),JFCB     STORE NAME OF VTOC IN JFCB.
         MVC   JFCB+118(6),28(R10) STORE VOLUME SERIAL NUMBER IN JFCB.
         OPEN  MF=(E,OPENL2),TYPE=J     OPEN SYSUT1 DATA SET.
         LM    R15,R0,TIOTPTR      LOAD ADDRESSES FOR RESTORE.
         SPMODE PROB,0,MF=(E,SPML) ALLOW UPDATE TO TIOT FOR MVT.
         STH   R0,18(R15)          RESTORE OLD TIOT UCB ADDRESS.
         SPMODE PROB,*,MF=(E,SPML) RESTORE USER PROTECT KEY.
         L     R1,UT1+44           SET GR1 -> DEB.
         MVC   F4DSCB,38(R1)       SAVE FORMAT 4 DSCB SEEK ADDRESS.
         MVC   HDRSER,28(R10)      STORE VOLUME SERIAL NUMBER IN HEADER
         MVC   HDRUNIT,13(R10)     STORE DEVICE ADDRESS IN HEADER.
         SPACE 1
*
*        WAIT FOR RESPONSE.
*
         SPACE 1
LOOP1    BAL   R9,WAIT             LINK TO WAIT FOR COMPLETION.
         SPACE 1
*
*        CHECK AND SET UP LISTING LIMITS.
*
         SPACE 1
         LA    R0,125              SET GR0 = LENGTH OF LINE.
         STH   R0,LN               STORE LENGTH OF MESSAGE.
         MVC   HDRFROM,REP         STORE 'FROM' ADDRESS IN HEADER.
         MVC   HDRTO,REP+9         STORE 'TO' ADDRESS IN HEADER.
         MVI   LNCT+1,1            SET RESIDUAL LINE COUNT TO FORCE HDR
         TRT   REP(8),VALIDHEX     CHECK VALIDITY OF LOWER LIMIT.
         BNZ   ERR02               IF NOT VALID THEN ERROR.
         TRT   REP+9(8),VALIDHEX   CHECK VALIDITY OF UPPER LIMIT.
         BNZ   ERR02               IF NOT VALID THEN ERROR.
         TR    REP(8),TRANS        CONVERT FOR PACK.
         PACK  DW(5),REP(9)        PACK LOWER LIMIT.
         BAL   R9,SUBCHK           LINK TO CHECK VALUE.
         MVC   RHA+35(4),DW        STORE CCHH IN RHA IOB.
         TR    REP+9(8),TRANS      CONVERT FOR PACK.
         PACK  DW(5),REP+9(9)      PACK UPPER LIMIT.
         BAL   R9,SUBCHK           LINK TO CHECK VALUE.
         CLC   DW(4),RHA+35        COMPARE WITH LOWER LIMIT.
         BL    ERR02               IF LESS THEN RANGE IS INVALID.
         LA    R2,ASCTAB           SET GR2 -> ASCII TABLE.
         CLI   REP+18,C'A'         IS ASCII CONVERSION SPECIFIED ?
         BE    *+8                 IF SO THEN USE.
         LA    R2,EBCTAB           SET GR2 -> EBCDIC TABLE.
         SPACE 1
*
*        REQUEST NEXT LIMITS
*
         SPACE 1
         LA    R1,WTOR2            SET GR1 -> SPECIFY LIMITS MESSAGE.
         BAL   R9,WTOR             LINK TO WRITE TO OPERATOR.
         SPACE 1
*
*        READ HOME ADDRESS AND RECORD ZERO.
*
         SPACE 1
         LA    R0,CPRHA            SET GR0 -> 1ST TRACK CHANNEL PROGRAM
LOOP2    ST    R0,RHA+16           STORE CHANNEL PROGRAM ADDRESS IN IOB
         CLC   RHA+35(4),DW        COMPARE FOR UPPER LISTING LIMIT.
         BE    LOOP1               IF EQUAL THEN GO TO WAIT FOR REPLY.
         EXCP  RHA                 READ HOME ADDRESS AND RECORD ZERO.
         WAIT  1,ECB=ECB           WAIT FOR COMPLETION.
         MVC   RHA+35(4),HA        SET ADDRESS FOR NEXT RHA.
         SPACE 1
*
*        EDIT AND PRINT HA AND R0.
*
         SPACE 1
         UNPK  LINEHA+17(9),HA(5)  EDIT HOME ADDRESS TO OUTPUT LINE.
         TR    LINEHA+17(8),HEXTAB CONVERT TO READABLE FORMAT.
         MVI   LINEHA+25,C' '      RESTORE BLANK.
         UNPK  LINEHA+40(9),RZ(5)  EDIT RECORD ZERO TO OUTPUT LINE.
         UNPK  LINEHA+48(9),RZ+4(5)     EDIT RECORD ZERO TO OUTPUT LINE
         TR    LINEHA+40(16),HEXTAB     CONVERT TO READABLE FORMAT.
         MVI   LINEHA+56,0         RESTORE ZERO.
         LA    R8,LINEHA           SET GR8 -> HOME ADDRESS LINE.
         BAL   R9,SUBPUT           LINK TO WRITE OUTPUT.
         SPACE 1
*
*        CHECK FOR NEW TRACK.
*
         SPACE 1
LOOP5    CLC   RHA+35(4),COUNT         IS A NEW TRACK REQUIRED ?
         BNE   NEXTHA              GO TO READ NEW HOME ADDRESS.
         SPACE 1
*
*        EDIT AND PRINT COUNT FIELD.
*
         SPACE 1
         UNPK  LINECT+17(9),COUNT(5)    EDIT COUNT TO OUTPUT LINE.
         UNPK  LINECT+25(9),COUNT+4(5)  EDIT COUNT TO OUTPUT LINE.
         TR    LINECT+17(16),HEXTAB     CONVERT TO READABLE FORMAT.
         MVI   LINECT+33,0         RESTORE ZERO.
         LA    R8,LINECT           SET GR8 -> COUNT LINE.
         BAL   R9,SUBPUT           LINK TO WRITE OUTPUT.
         SPACE 1
*
*        CHECK FOR NO DATA.
*
         SPACE 1
         SR    R7,R7               SET GR7 = 0.
         IC    R7,COUNT+5          SET GR7 = KEY LENGTH.
         AH    R7,COUNT+6          SET GR7 = KEY LENGTH + DATA LENGTH.
         BZ    EOD                 IF ZERO THEN GO TO READ NEXT COUNT.
         SPACE 1
*
*        READ DATA AND NEXT COUNT FIELD.
*
         SPACE 1
         MVC   RDATA+35(5),COUNT   STORE ADDRESS FOR READ DATA.
         EXCP  RDATA               READ KEY AND DATA.
         L     R6,CCWDATA          SET GR6 -> DATA AREA.
         SR    R5,R5               SET GR5 = 0.
         WAIT  1,ECB=ECB           WAIT FOR COMPLETION.
         SPACE 1
*
*        EDIT DATA.
*
         SPACE 1
         ST    R5,DW+4             STORE GR5 FOR EDIT.
LOOP4    UNPK  LN+5(7),DW+5(4)     EDIT ADDRESS FOR PRINT PUR.
         TR    LN+5(6),HEXTAB      CONVERT TO READABLE FORMAT.
         MVI   LN+11,C' '          RESTORE BLANK.
         MVC   LN+14(74),LN+13     CLEAR HEX AREA.
         XC    LN+92(32),LN+92     CLEAR CHARACTER AREA.
         S     R7,F16              DECREMENT GR7 TO TEST FOR END.
         BNP   EOD1                IF END THEN GO TO END DATA ROUTINE.
         HEXPRINT   (R6),MF=(E,HEXPD1)  EDIT DATA TO HEX AREA.
         MVC   LN+92(16),0(R6)     MOVE DATA TO CHARACTER AREA.
         S     R7,F16              DECREMENT GR7 TO TEST FOR END.
         BNP   EOD2                IF END THEN GO TO END DATA ROUTINE.
         HEXPRINT   16(R6),MF=(E,HEXPD2)     EDIT DATA TO HEX AREA.
         MVC   LN+108(16),16(R6)   MOVE DATA TO CHARACTER AREA.
         TR    LN+92(32),0(R2)     TRANSLATE CHARACTERS FOR PRINT.
         LA    R8,LN               SET GR1 -> LINE.
         BAL   R9,SUBPUT           LINK TO WRITE LINE.
LOOP3    LR    R4,R6               SET GR4 -> OLD AREA.
         LA    R5,32(R5)           INCREMENT GR5 FOR STORE.
         ST    R5,DW+4             STORE NEW OFFSET.
         LA    R6,32(R6)           SET GR6 FOR NEXT LINE.
         C     R7,F32              IS NEXT LINE LAST ?
         BNH   TESTSKP             IF SO THEN GO TO TEST FOR LINES SKPD
         CLC   0(32,R4),0(R6)      IS NEXT LINE SAME AS LAST ?
         BNE   TESTSKP             IF NOT THEN GO TO TEST FOR SKIPS.
         TM    SW,X'10'            ARE SKIPS ALREADY PRESENT ?
         BO    SKIPEND             IF SO THEN SET END LIMIT ONLY
         OI    SW,X'10'            SET ON SKIPS PRESENT SWITCH.
         UNPK  LINESKIP+16(7),DW+5(4)   EDIT LOWER LIMIT FOR PRINT OUT.
         TR    LINESKIP+16(6),HEXTAB    CONVERT TO READABLE FORMAT.
         MVI   LINESKIP+22,C' '    RESTORE BLANK.
SKIPEND  UNPK  LINESKIP+26(7),DW+5(4)   EDIT UPPER LIMIT FOR PRINT OUT.
         TR    LINESKIP+26(6),HEXTAB    CONVERT TO READABLE FORMAT.
         MVI   LINESKIP+32,C' '    RESTORE BLANK.
         S     R7,F32              DECREMENT GR7 FOR SKIPPED LINE.
         B     LOOP3               GO TO TEST FOR ADDITIONAL LINES
TESTSKP  TM    SW,X'10'            IS A SKIP PRESENT ?
         BZ    LOOP4               IF NOT THEN GO TO PRINT NEXT LINE.
         NI    SW,X'E0'            SET OFF SKIP SWITCH
         LA    R8,LINESKIP         SET GR8 -> SKIP LINE.
         BAL   R9,SUBPUT           LINK TO WRITE OUTPUT.
         B     LOOP4               GO TO PRINT NEXT LINE.
         SPACE 1
EOD1     LA    R7,16(R7)           RESET GR7
         HEXPRINT (R6),,(R7),MF=(E,HEXPD1)   EDIT DATA TO HEX AREA.
         BCTR  R7,R0               DECREMENT GR7 FOR EXECUTE.
         EX    R7,MVC1             MOVE DATA TO CHARACTER AREA.
         B     EODCOM              GO TO COMMON END DATA ROUTINE.
EOD2     LA    R7,16(R7)           RESET GR7
         HEXPRINT 16(R6),,(R7),MF=(E,HEXPD2) EDIT DATA TO HEX AREA.
         BCTR  R7,R0               DECREMENT GR7 FOR EXECUTE.
         EX    R7,MVC2             MOVE DATA TO CHARACTER AREA.
         SPACE 1
EODCOM   TR    LN+92(32),0(R2)     TRANSLATE CHARACTERS FOR PRINT.
         LA    R8,LN               SET GR8 -> LINE.
         MVI   LN+4,X'11'          SET SPACE 2 AFTER PRINT.
         BAL   R9,SUBPUT           LINK TO WRITE OUTPUT.
         MVI   LN+4,X'09'          SET SPACE 1 AFTER PRINT.
         LA    R0,16               SET GR0 = 16.
         STH   R0,HEXPD1+8         RESTORE LENGTH IN FIRST HEXPRINT.
         STH   R0,HEXPD2+8         RESTORE LENGTH IN SECOND HEXPRINT.
         B     LOOP5               GO TO CHECK FOR END OF LISTING.
         SPACE 1
*
*        SET UP FOR NEXT READ HA.
*
         SPACE 1
NEXTHA   LA    R0,CPRHA1           SET GR0 -> NEW TRACK CHANNEL PROGRAM
         B     LOOP2               GO TO READ NEW HOME ADDRESS.
         SPACE 1
*
*        READ PAST NULL BLOCK.
*
         SPACE 1
EOD      MVC   EODAD+35(5),COUNT   SET ADDRESS IN IOB.
         EXCP  EODAD               READ TO SKIP NULL BLOCK.
         WAIT  1,ECB=ECB           WAIT FOR COMPLETION.
         B     LOOP5               GO TO CHECK FOR END OF LISTING.
         SPACE 1
MVC1     MVC   LN+92(0),0(R6)      MODEL STATEMENT.
MVC2     MVC   LN+108(0),16(R6)    MODEL STATEMENT.
 TITLE 'RTP5005M - MAIN SEGMENT SUB-ROUTINES - A.MORRISH.'
WTO      TM    IN+48,X'10'         IS SYSIN ACTIVE ?
         BO    WTOM                IF SO THEN GO TO WRITE TO PRINT.
         TM    SW,X'C0'            IS REMOTE CONSOLE PRESENT AND ACTIVE
         BNO   WTOA                IF NOT THEN GO TO WRITE TO CONSOLE.
         BAL   R8,WTOB             LINK TO BUILD LIST FOR WTO.
         BR    R9                  RETURN.
         SPACE 1
WTOR     ST    R1,WTORLAST         SAVE ADDRESS FOR SWITCH OR INV.RESP.
         TM    IN+48,X'10'         IS SYSIN ACTIVE ?
         BO    WTOC                IF SO THEN GO TO GET.
         TM    SW,X'C0'            IS REMOTE CONSOLE PRESENT AND ACTIVE
         BNO   WTOA                IF NOT THEN GO TO WRITE TO CONSOLE.
         LA    R1,4(R1)            SET GR1 -> WTO PORTION.
         BAL   R8,WTOB             LINK TO BUILD LIST FOR WTO.
         L     R7,WTOPTR           SET GR7 -> FIRST WTO BLOCK.
         SR    R6,R6               SET GR6 = 0
         AH    R6,4(R7)            INCREMENT GR6 FOR TOTAL LENGTH.
         L     R7,0(R7)            SET GR7 -> NEXT WTO BLOCK.
         LTR   R7,R7               TEST FOR BLOCK PRESENT.
         BNZ   *-10                LOOP UNTIL ALL BLOCKS RELEASED.
         LA    R6,1(R6)            INCREMENT GR6 FOR SMI.
         STH   R6,CCWADDR+6        STORE LENGTH OF MESSAGE IN CCW.
         GETMAIN R,LV=(R6)         OBTAIN SPACE FOR MESSAGE.
         ST    R1,CCWADDR          STORE ADDRESS IN CCW.
         LR    R5,R1               SET GR5 -> WTO AREA.
         L     R1,WTOPTR           SET GR1 -> FIRST WTO BLOCK.
         XC    WTOPTR,WTOPTR       CLEAR WTO BLOCK POINTER.
WTOE     L     R7,0(R1)            SET GR7 -> NEXT WTO BLOCK.
         LH    R6,4(R1)            SET GR6 = LENGTH FOR MOVE.
         LA    R0,256              SET GR0 = 256.
         LA    R2,6(R7)            SET GR2 FOR MOVE.
WTOL     CR    R6,R0               COMPARE FOR LAST MOVE.
         BNH   WTOK                IF LAST MOVE THEN GO TO EXECUTE.
         MVC   0(256,R5),0(R2)     MOVE DATA TO WTO AREA.
         SR    R6,R0               DECREMENT GR0 FOR NEXT MOVE.
         AR    R2,R0               INCREMENT GR2 FOR NEXT MOVE.
         AR    R5,R0               INCREMENT GR5 FOR NEXT MOVE.
         B     WTOL                GO TO NEXT TEST.
WTOK     BCTR  R6,R0               DECREMENT GR6 FOR MOVE.
         EX    R6,WTOD             MOVE DATA TO WTO AREA.
         LA    R5,1(R5,R6)         SET GR5 FOR NEXT STORE.
         FREEMAIN R,LV=1024,A=(1)  RELEASE DYNAMIC AREA.
         LTR   R1,R7               SET GR1 -> NEXT WTO BLOCK.
         BNZ   WTOE                IF PRESENT THEN GO TO STORE NEXT.
         LH    R0,CCWADDR+6        SET GR0 = LENGTH TO BE TRANSLATED.
         L     R7,CCWADDR          SET GR7 -> AREA TO BE TRANSLATED.
         TRNSLATE ,SSCI,(R7),(0)   TRANSLATE AREA.
         MVI   0(R5),X'BD'         STORE START MANUAL INPUT.
         EXCP  ADDRIOB             WRITE TO REMOTE OPERATOR.
         BR    R9                  RETURN.
         SPACE 1
WTOA     MVI   WECB,0              CLEAR WTOR ECB.
         MVC   LN(89),0(R1)        STORE WTO IN OUTPUT AREA.
         LA    R1,LN               SET GR1 -> OUTPUT AREA.
         CLI   LN,0                IS IT A WTO ?
         BE    *+8                 IF SO THEN LEAVE.
         LA    R1,8(R1)            SET GR1 -> WTO PORTION OF WTOR.
         MVC   2(2,R1),MCSFLAGS    STORE MCSFLAGS.
         AH    R1,0(R1)            SET GR1 -> ROUTE CODES.
         MVC   0(2,R1),MCSFLAGS+2  STORE ROUTE CODES.
         WTO   MF=(E,LN)           WRITE MESSAGE TO OPERATOR.
         BR    R9                  RETURN.
         SPACE 1
WTOC     LA    R8,8(R1)            SET GR8 -> WTO.
         GET   IN,REP              READ CONTROL RECORD.
         LR    R1,R8               SET GR1 -> WTO.
         B     WTOM                GO TO WRITE MESSAGE TO PRINT.
         SPACE 1
WTOB     LA    R6,4(R1)            SET GR6 -> MESSAGE.
         LH    R5,0(R1)            SET GR5 = MESSAGE LENGTH.
         SH    R5,WTOB+2           DECREMENT GR5 FOR TRUE LENGTH.
         LA    R7,WTOPTR           SET GR7 -> WTO BLOCK POINTER.
         OC    WTOPTR,WTOPTR       TEST FOR FIRST BLOCK PRESENT.
         BZ    WTOG                IF NOT THEN GO TO GETMAIN.
WTOF     L     R1,0(R7)            SET GR1 -> NEXT WTO BLOCK
         LTR   R1,R1               TEST FOR BLOCK PRESENT.
         BZ    *+10                IF NOT THEN EXIT.
         LR    R7,R1               SET GR7 -> NEXT WTO BLOCK.
         B     WTOF                GO TO REPEAT TEST.
         LH    R1,4(R7)            SET GR1 = LENGTH SO FAR.
         AR    R1,R5               SET GR1 = LENGTH AFTER MOVE.
         LA    R0,1017             SET GR0 = MAXIMUM LENGTH.
         CR    R1,R0               COMPARE FOR FIT.
         BNH   WTOH                IF FIT THEN GO TO STORE.
WTOG     GETMAIN R,LV=1024         GET A IK BLOCK.
         ST    R1,0(R7)            SET POINTER FROM PREVIOUS BLOCK.
         LR    R7,R1               SET GR7 -> NEW BLOCK.
         XC    0(6,R7),0(R7)       CLEAR POINTER AND LENGTH FIELDS.
WTOH     LH    R4,4(R7)            SET GR4 = LENGTH SO FAR.
         LA    R1,6(R7,R4)         SET GR1 -> ADDRESS FOR MOVE.
         EX    R5,WTOI             MOVE MESSAGE TO WTO BLOCK.
         AR    R4,R5               SET GR4 = LENGTH SO FAR.
         LA    R0,80               SET GR0 = 80
         CR    R5,R0               COMPARE FOR FULL LINE.
         BE    WTOJ                IF SO THEN GO TO STORE LENGTH.
         LA    R4,1(R4)            INCREMENT GR4 FOR NEW LINE SYMBOL.
         AR    R1,R5               SET GR1 -> NEW LINE SYMBOL POINT.
         MVI   0(R1),X'15'         STORE NEW LINE SYMBOL.
WTOJ     STH  R4,4(R7)             STORE UPDATED LENGTH SO FAR.
         BR    R8                  RETURN.
WTOM     LH    R8,0(R1)            SET GR8 = LENGTH OF WTO MESSAGE.
         LA    R8,1(R8)            INCREMENT FOR LENGTH OF LINE.
         STH   R8,LN               STORE LENGTH OF LINE.
         LA    R0,6                SET GR0 = 6.
         SR    R8,R0               SET GR8 FOR EXECUTE.
         EX    R8,WTON             MOVE MESSAGE DATA TO LINE.
         LA    R8,LN               SET GR8 -> MESSAGE TO BE PRINTED.
         B     SUBPUT              GO TO WRITE MESSAGE TO SYSPRINT.
         SPACE 1
WTOD     MVC   0(0,R5),0(R2)       MODEL STATEMENT.
WTOI     MVC   0(0,R1),0(R6)       MODEL STATEMENT.
WTON     MVC   LN+5(0),4(R1)       MODEL STATEMENT.
         SPACE 2
WAIT     ST    R9,SAVER9           SAVE RETURN ADDRESS.
         TM    IN+48,X'10'         IS SYSIN ACTIVE ?
         BO    WAITA               IF SO THEN NO WAIT.
         WAIT  1,ECB=WECB          WAIT FOR RESPONSE.
         TM    SW,X'C0'            IS REMOTE CONSOLE ACTIVE ?
         BNO   WAITB               IF NOT THEN SKIP POLL.
WAITC    STIMER WAIT,BINTVL=DELAY  WAIT BEFORE POLLING.
         EXCP  POLLIOB             POLL FOR REPLY.
         WAIT  1,ECB=WECB          WAIT FOR REPLY.
         CLI   WECB,X'7F'          IS COMPLETION NORMAL ?
         BNE   WAITC               IF NOT THEN GO TO REPOLL.
         TR    REP,IECTRSCI        TRANSLATE REPLY TO ASCII.
WAITB    OC    REP,BLANKS          CONVERT TO UPPER CASE.
WAITA    LA    R1,REP+L'REP        SET GR1 -> END OF REPLY AREA.
         CLI   0(R1),C' '          IS CHARACTER BLANK ?
         BNE   *+8                 IF NOT THEN END OF MESSAGE FOUND.
         BCT   R1,*-8              LOOP UNTIL END FOUND.
         LA    R0,REP-6            SET GR0 FOR SUBTRACT.
         SR    R1,R0               SET GR1 = LENGTH OF MESSAGE.
         STH   R1,REP-5            STORE LENGTH OF MESSAGE IN LINE.
         LA    R8,REP-5            SET GR1 -> MESSAGE.
         BAL   R9,SUBPUT           LINK TO WRITE TO OUTPUT.
         L     R9,SAVER9           RESTORE GR9
         TM    REP,X'F0'           IS FIRST CHARACTER NUMERIC ?
         BCR   1,R9                IF SO THEN RETURN.
         L     R15,VEND            SET GR15 -> END ROUTINE.
         CLC   CEND,REP            COMPARE FOR TERMINATE MESSAGE.
         BCR   8,R15               IF SO THEN GO TO RETURN.
         LA    R1,OPTTAB1          SET GR1 -> OPTIONS TABLE.
         LA    R14,1               SET GR14 = 1.
         LA    R15,OPTTABND        SET GR15 -> END OF OPTIONS TABLE.
WAITE    CLC   REP(1),0(1)         COMPARE FOR OPTION.
         BE    WAITD               IF FOUND THEN GO TO SET UP LINK.
         BXLE  R1,R14,WAITE        LOOP UNTIL FOUND OR EXHAUSTED.
         BR    R9                  RETURN.
WAITD    LA    R0,OPTTAB1          SET GR0 -> OPTION TABLE.
         SR    R1,R0               SET GR1 = OFFSET.
         SLL   R1,2                MULTIPLY BY 4 FOR OFFSET IN TABLE 2.
         L     R15,OPTTAB2(R1)     SET GR15 -> PROCESS MODULE.
         LA    R0,0(R15)           SET GR0 TO TEST IF OVERLAY.
         LTR   R0,R0               TEST FOR MODULE PRESENT.
         BCR   8,R9                IF NOT THEN DO NOT ATTEMPT PROCESS.
         BR    R15                 GO TO PROCESS OPTION.
         SPACE 2
ENDIN    CLOSE MF=(E,CLOSEL1)      CLOSE SYSIN.
         FREEPOOL IN               RELEASE BUFFER POOL.
         L     R1,WTORLAST         RESTORE GR1.
         B     WTOR                GO TO PROCESS CONSOLE ACTIVITY.
         EJECT
SUBPUT   TM    PRT+48,X'10'        IS SYSPRINT OPEN ?
         BCR   8,R9                IF NOT THEN RETURN.
         LH    R1,LNCT             SET GR1 = RESIDUAL COUNT.
         BCT   R1,SUBPUT1          DECREMENT AND TEST FOR NEW PAGE.
         AP    PNO,P1              INCREMENT PAGE NUMBER.
         OI    PNO+2,X'0F'         REMOVE ZONE
         UNPK  HDRPG,PNO           STORE PAGE NUMBER IN HEADER.
         PUT   PRT,LINESKP         WRITE SKIP TO CHANNEL 1.
         PUT   PRT,LINEHDR         WRITE HEADER.
         LA    R1,56               SET GR1 = RESIDUAL COUNT.
SUBPUT1  STH   R1,LNCT             STORE NEW RESIDUAL COUNT.
         LTR   R8,R8               TEST FOR SECOND ENTRY.
         BCR   8,R9                IF SO THEN RETURN.
         PUT   PRT,(R8)            WRITE OUTPUT LINE.
         CLI   4(R8),X'09'         IS PUT SPACE 1 ?
         BCR   8,R9                IF SO THEN RETURN.
         SR    R8,R8               SET GR8 = 0.
         B     SUBPUT              GO TO RE-DECREMENT COUNT.
         SPACE 2
SUBCHK   L     R1,16               SET GR1 ->     CVT
         L     R1,64(R1)           SET GR1 -> I/O DEVICE CHARS TABLE.
         SR    R2,R2               SET GR2 = 0
         IC    R2,19(R10)          SET GR2 = INDEX TO TABLE INDEX.
         IC    R2,0(R1,R2)         SET GR2 -> INDEX TO DEVICE CHARS TAB
         AR    R1,R2               SET GR1 -> DEVICE CHARS TABLE ENTRY.
         CLC   DW(2),0(R1)         COMPARE FOR CYLINDER/CELL.
         BNL   SUBCHKA             IF INVALID THEN ERROR.
         CLC   DW+1(1),1(R1)       COMPARE FOR CYLINDER/SUBCELL.
         BNL   SUBCHKA             IF INVALID THEN ERROR.
         CLC   DW+2(2),2(R1)       COMPARE FOR TRACK/CYLINDER.
         BNL   SUBCHKA             IF INVALID THEN ERROR.
         CLC   DW+3(1),3(R1)       COMPARE FOR TRACK NUMBER.
         BCR   4,R9                IF VALID THEN RETURN.
SUBCHKA  LA    R1,WTOR4            SET GR1 -> INVALID ADDRESS MESSAGE.
         BAL   R9,WTOR+4           LINK TO WRITE MESSAGE.
         L     R9,SAVER9           RESTORE GR9.
         B     WAIT                GO TO WAIT FOR RESPONSE.
         SPACE 2
ERR01    EQU   SUBCHKA
ERR02    EQU   SUBCHKA
         SPACE 2
REPEAT   L     R1,WTORLAST   SET GR1 -> LAST WTOR MESSAGE.
         BAL   R9,WTOR+4           LINK TO WRITE TO OPERATOR.
         L     R9,SAVER9     RE    RESTORE GR9 FOR WAIT.
         B     WAIT                GO TO WAIT FOR RESPONSE.
         SPACE 3
DCBEXIT  DCBEXITS
 TITLE 'RTP5005M - CONSTANTS AND WORK AREAS - A.MORRISH.'
SAVE     DC    9D'0'
DW       DS    D
         SPACE 1
CPRHA1   CCW   X'16',*,X'70',1     POSITION TO READ RECORD ZERO.
         CCW   X'9A',HA-1,X'60',5  READ HOME ADDRESS.
         CCW   X'08',CPRHA+8,0,0   GO TO READ RECORD ZERO.
CPRHA    CCW   X'1A',HA-1,X'60',5       READ HOME ADDRESS.
         CCW   X'16',COUNT,X'60',16     READ RECORD ZERO.
         CCW   X'92',COUNT,0,8          READ COUNT OF NEXT RECORD.
         SPACE 1
CPRDATA  CCW   X'31',RDATA+35,X'40',5   SEARCH ID EQUAL.
         CCW   X'08',CPRDATA,0,0        TIC UNTIL FOUND.
CCWDATA  CCW   0,0,0,0             READ DATA.
         CCW   X'92',COUNT,0,8          READ COUNT OF NEXT RECORD.
         SPACE 1
CPEODAD  CCW   X'31',EODAD+35,X'40',5   SEARCH ID EQUAL.
         CCW   X'08',CPEODAD,0,0        TIC UNITL FOUND.
         CCW   X'92',COUNT,0,8          READ COUNT OF NEXT RECORD.
         SPACE 1
JFCB     DS    44F                      JOB FILE CONTROL BLOCK.
EXIT     DC    X'87',AL3(JFCB)          EXIT LIST.
         SPACE 1
UT1      DCB   DDNAME=SYSWK,EXLST=EXIT,EOEA=WF,MACRF=E,DEVD=DA
CNS      DCB   DDNAME=CONSOLE,MACRF=E
PRT      DCB   DDNAME=SYSPT,DSORG=PS,MACRF=PM,LRECL=125,RECFM=VBM,     *
               BLKSIZE=2178,EXLST=DCBEXIT
IN       DCB   DDNAME=SYSIN,DSORG=PS,MACRF=GM,LRECL=80,EODAD=ENDIN
         SPACE 1
ECB      DC    F'0'                ECB FOR I/O.
WECB     DC    F'0'                ECB FOR WTOR.
COUNT    DS    2F                  COUNT FIELD.
RZ       DS    2F                  RECORD ZERO FIELD.
         DS    F                   PADDING.
HA       DS    F                   HOME ADDRESS FIELD.
         SPACE 1
RHA      DC    X'42',A(ECB,0,0,CPRHA,UT1),4A(0)
RDATA    DS    0D
IOB      DC    X'42',A(ECB,0,0,CPRDATA,UT1),4A(0)
EODAD    DC    X'42',A(ECB,0,0,CPEODAD,UT1),4A(0)
         SPACE 1
OPENL2   OPEN  UT1,MF=L            OPEN SYSUT1.
ADDRIOB  DC    X'42',A(WECB,0,0,CPADDR,CNS),4A(0)
POLLIOB  DC    X'42',A(WECB,0,0,CPPOLL,CNS),4A(0)
CPADDR   CCW   X'01',SOH,X'60',4        WRITE 'SOH' DOWN LINE.
         CCW   X'02',RDACK,X'60',1      READ RESPONSE.
         CCW   X'01',STX,X'A0',2        WRITE 'STX' DOWN LINE.
CCWADDR  CCW   0,0,X'60',0         WRITE DATA.
         CCW   0,ETX,X'60',1            WRITE 'ETX' DOWN LINE.
         CCW   X'02',RDACK,X'20',1      READ RESPONSE.
CPPOLL   CCW   X'01',EOT,X'60',4        WRITE 'EOT' DOWN LINE.
         CCW   X'02',RDACK,X'A0',2
         CCW   0,REP,X'20',80           READ REPLY.
         SPACE 1
CLOSEL1  CLOSE UT1,MF=L                 CLOSE SYSUT1 DATA SET.
         SPACE 1
HEXTAB   EQU   *-C'0'              TRANSLATE TABLE FOR HEXPRINT.
         DC    C'0123456789ABCDEF'
HEXPD1   HEXPRINT   ,LN+14,16,(4,1),MF=L     EDIT FIRST HALF LINE.
HEXPD2   HEXPRINT ,LN+53,16,(4,1),MF=L       EDIT SECOND HALF LINE.
         SPACE 1
TRANS    EQU   *-42
VALIDHEX DC    151X'1',X'0A0B0C0D0E0F',36X'1',6X'0'
         DC    X'010203040506070809'
         DC    32X'1',10X'0',6X'1'
         SPACE 1
F16      DC    F'16'
F32      DC    F'32'
SAVER9   DS    A
WTORLAST DS    A
MCSFLAGS DC    F'0'                MCS FLAGS AND ROUTE CODES.
         SPACE 1
WTOR1    WTOR  'SPECIFY DEVICE OR OPTION',REP,80,WECB,MF=L
WTOR2    WTOR  'SPECIFY LISTING LIMITS FOR VOL 000000 ON 000 OR OPTION'*
               ,REP,80,WECB,MF=L
WTOR3    WTOR  'INVALID DEVICE-RESPECIFY',REP,3,WECB,MF=L
WTOR4    WTOR  'INVALID LIMITS-RESPECIFY',REP,80,WECB,MF=L
         SPACE 1
         DC    2H'0',X'11'         CONTROL TO WRITE REPLY TO SYSPRINT.
REP      DS    CL80
BLANKS   DC    CL80' '
         SPACE 1
LINESKP  DC    AL2(6,0),X'8B'
LINEHDR  DC    AL2(LINEHA-LINEHDR,0),X'11',C'RT5005M LISTING OF PACK #'
HDRSER   DC    C'000000',C'  ON DRIVE '
HDRUNIT  DC    C'000',C'  FROM '
HDRFROM  DC    C'00000000',C' TO '
HDRTO    DC    C'00000000',C'      PAGE '
HDRPG    DC    C'0000'
LINEHA   DLINE 11,'**** TRACK  00000000      R0 DATA  0000000000000000'
LINECT   DLINE 11,'     COUNT  0000000000000000'
         DS    0A                  CONTROL TO ALIGN LN FOR WTOR.
LN       DC    H'125,0',X'09',CL120' '
         ORG   LN+91
         DC    C'*',32C' ',C'*'
         ORG
LINESKIP DLINE 09,'  LINE(S)  000000 TO 000000  AS ABOVE'
         SPACE 1
*                 0 1 2 3 4 5 6 7 8 9 A B C D E F
ASCTAB   DC    X'40404040404040404040407B7C7D7E7F'    0
         DC    X'40404040404040404040406B6C6D6E6F'    1
         DC    X'40404040404040404040405B5C5D5E5F'    2
         DC    X'40404040404040404040404B4C4D4E4F'    3
         DC    X'F0F1F2F3F4F5F6F7F8F9404040404040'    4
         DC    X'4040E2E3E4E5E6E7E8E9404040404040'    5
         DC    X'60D1D2D3D4D5D6D7D8D9404040404040'    6
         DC    X'50C1C2C3C4C5C6C7C8C9404040404040'    7
         DC    X'40404040404040404040407B7C7D7E7F'    8
         DC    X'40404040404040404040406B6C6D6E6F'    9
         DC    X'40404040404040404040405B5C5D5E5F'    A
         DC    X'40404040404040404040404B4C4D4E4F'    B
         DC    X'F0F1F2F3F4F5F6F7F8F9404040404040'    C
         DC    X'4040E2E3E4E5E6E7E8E9404040404040'    D
         DC    X'60D1D2D3D4D5D6D7D8D9404040404040'    E
         DC    X'50C1C2C3C4C5C6C7C8C9404040404040'    F
         SPACE 1
*                 0 1 2 3 4 5 6 7 8 9 A B C D E F
EBCTAB   DC    X'40404040404040404040404040404040'    0
         DC    X'40404040404040404040404040404040'    1
         DC    X'40404040404040404040404040404040'    2
         DC    X'40404040404040404040404040404040'    3
         DC    X'404040404040404040404A4B4C4D4E4F'    4
         DC    X'504040404040404040405A5B5C5D5E5F'    5
         DC    X'60614040404040404040406B6C6D6E6F'    6
         DC    X'404040404040404040407A7B7C7D7E7F'    7
         DC    X'40404040404040404040404040404040'    8
         DC    X'40404040404040404040404040404040'    9
         DC    X'40404040404040404040404040404040'    A
         DC    X'40404040404040404040404040404040'    B
         DC    X'40C1C2C3C4C5C6C7C8C9404040404040'    C
         DC    X'40D1D2D3D4D5D6D7D8D9404040404040'    D
         DC    X'4040E2E3E4E5E6E7E8E9404040404040'    E
         DC    X'F0F1F2F3F4F5F6F7F8F9404040404040'    F
         ASMTRTAB RSCI,SSCI
         SPACE 1
LNCT     DC    H'1'
SW       DC    AL1(0)
SWA      DC    X'40'
CEND     DC    C'END'
DELAY    DC    FS8'100'
PNO      DC    PL3'0'
P1       DC    P'1'
EOT      DC    X'04'
SOH      DC    X'01'
CONSADDR DC    2X'0',X'E0'
STX      DC    X'02'
ETX      DC    X'03'
RDACK    DS    X,X
SPML     DC    V($SPMODE)
VINIT    DC    V(INIT)
VEND     DC    V(END)
OPTTAB1  DC    C'ABCDEFGHIJKLMNOPQRSTUVWXYZ'
OPTTABND EQU   *-1
OPTTAB2  DC    V(A,B,C,D,E,F,G,H,I,J,K,L,M,N,O,P,Q,R,S,T,U,V,W,X,Y,Z)
F4DSCB   DC    F'0'
WTOPTR   DC    A(0)
TIOTPTR  DS    2A
 TITLE 'RTP5005M - INITIALISATION CSECT - A.MORRISH.'
INIT     CSECT
         BALR  R11,R0              INITIALISE BASE REGISTER.
         USING *,R11               DEFINE BASE REGISTER.
         SPACE 1
*
*        TEST FOR REMOTE CONSOLE ADDRESS.
*
         SPACE 1
         L     R1,0(R1)            SET GR1 -> PARAMETER LIST.
         LH    R15,0(R1)           SET GR15 = LENGTH OF PARAMETERS.
         LTR   R15,R15             TEST FOR PARAMETERS OMITTED.
         BZ    INITA               IF OMITTED THEN ASSUME MASTER CONSOL
         BCTR  R15,R0              DECREMENT GR15 FOR EXECUTE.
         EX    R15,INITH           MOVE SWITCH CODE TO REPLY AREA.
         MVI   REP,C'S'            SIMULATE OPERATOR SWITCH REQUEST.
         L     R15,OPTTAB2+4*18    SET GR15 -> SWITCH MODULE.
         LA    R0,WTOR1            SET GR0 -> FIRST WTOR.
         ST    R0,WTORLAST         STORE ADDRESS OF MESSAGE FOR RESTART
         LA    R0,INITA            SET GR0 -> RESUME INITIALISATION ADP
         ST    R0,SAVER9           STORE ADDRESS FOR RESTART.
         BR    R15                 GO TO SET UP CONSOLE ADDRESS.
INITH    MVC   REP+2(0),2(R1)      MODEL STATEMENT.
INITA    LA    R0,INITE-INITB      SET GR0 = LENGTH OF OPEN LIST.
         GETMAIN R,LV=(0)          OBTAIN DYNAMIC SPACE FOR OPEN LIST.
         LR    R2,R1               SET GR2 -> DYNAMIC OPEN LIST.
         MVC   0(INITE-INITB,R2),INITB  MOVE OPEN LIST TO DYNAMIC AREA.
         L     R1,16               SET GR1 -> CVT.
         LR    R15,R2              SET GR15 -> DYNAMIC OPEN LIST.
         L     R1,0(R1)            SET GR1 -> TCB POINTERS.
         L     R1,4(R1)            SET GR1 -> CURRENT TCB.
         L     R1,12(R1)           SET GR1 -> TIOT.
         LA    R3,24(R1)           SET GR3 -> FIRST DD-ENTRY.
INITL    L     R14,0(R15)          SET GR14 -> CURRENT DCB.
         LR    R1,R3               SET GR1 -> FIRST DD-ENTRY.
         SR    R0,R0               SET GR0 = 0.
         CLC   4(8,R1),40(R14)     COMPARE FOR DD-NAME PRESENT.
         BE    INITK               IF SO THEN GO TO INCREMENT GR15.
         IC    R0,0(R1)            SET GR0 = LENGTH OF DD-ENTRY.
         BXH   R1,R0,*-14          LOOP UNTIL FOUND.
         TM    0(R15),X'80'        IS IT END OF LIST ?
         MVC   0(INITE-INITB-4,R15),4(R15)   ELIDE MISSING ENTRY.
         BZ    INITL               IF NOT THEN GO TO TEST NEXT
         LA    R0,4                SET GR0 = 4.
         SR    R15,R0              DECREMENT GR15 FOR MISSING LAST PAR.
         B     INITM               GO TO OPEN DATA SETS PRESENT.
INITK    TM    0(R15),X'80'        IS IT END OF LIST ?
         BO    INITM               IF SO THEN GO TO OPEN.
         LA    R15,4(R15)          INCREMENT GR15 FOR NEXT.
         B     INITL               GO TO TEST NEXT DCB.
INITM    CLR   R15,R2              COMPARE FOR ANY DATA SETS.
         BL    INITN               IF NOT THEN LEAVE.
         OI    0(R15),X'80'        SET END OF LIST.
         OPEN  MF=(E,(R2))         OPEN ALL PRESENT DATA SETS.
INITN    LA    R0,INITE-INITB      SET GR0 = LENGTH OF OPEN LIST.
         FREEMAIN R,LV=(0),A=(R2)  RELEASE DYNAMIC OPEN LIST.
         TM    CNS+48,X'10'        IS CONSOLE DATA SET OPEN.
         BZ    *+8                 IF SO THEN LEAVE.
         OI    SW,X'80'            SET ON CONSOLE PRESENT MESSAGE.
         SPACE 1
*
*        ISSUE FIRST WTOR.
*
         SPACE 1
         LA    R1,WTOR1            SET GR1 -> REQUEST DEVICE MESSAGE.
         BAL   R9,WTOR             LINK TO WRITE TO OPERATOR.
         SPACE 1
*
*        SCAN TIOT FOR SYSUT1.
*
         SPACE 1
         L     R1,16               SET GR1 -> CVT
         L     R1,0(R1)            SET GR1 -> TCB POINTERS.
         L     R1,4(R1)            SET GR1 -> CURRENT TCB.
         L     R1,12(R1)           SET GR1 -> TIOT.
         LA    R1,24(R1)           SET GR1 -> FIRST.DDENTRY.
         SR    R0,R0               SET GR0 = 0.
INITD    CLC   4(8,R1),UT1+40      IS ENTRY FOR SYSUT1 ?
         BE    INITC               IF SO THEN GO TO STORE.
         IC    R0,0(R1)            SET GR0 = LENGTH OF DD ENTRY.
         BXH   R1,R0,INITD         LOOP UNTIL FOUND.
         ABEND 0                   ABEND.
INITC    ST    R1,TIOTPTR          STORE ADDRESS OF TIOT ENTRY.
         LH    R0,18(R1)           SET GR0 -> UCB.
         ST    R0,TIOTPTR+4        STORE ADDRESS OF UCB.
         SPACE 1                                                      *
*
*        OBTAIN DYNAMIC DATA AREA.
*
         SPACE 1
         GETMAIN MF=(E,INITE)      OBTAIN DYNAMIC STORAGE.
         MVI   CCWDATA,X'0E'       SET READ KEY AND DATA CODE.
         MVI   CCWDATA+4,X'60'     SET CHAINING AND SILI BITS.
         SPACE 1
*
*        READ JFCB AND SET FOR VTOC.
*
         SPACE 1
         RDJFCB MF=(E,INITG)       READ JFCB.
         MVI   JFCB,X'04'          SET FIRST BYTE OF DSNAME TO X'04'
         MVC   JFCB+1(43),JFCB     SET DSNAME TO VTOC.
         OI    JFCB+52,X'0E'       SUPPRESS JFCB AND DSCB MODIFICATION.
         SPACE 1
*
*        RETURN TO MAIN CSECT.
*
         SPACE 1
         B     AFTINIT
         SPACE 1
*
*        CONSTANTS AND CONTROL FIELDS.
*
         SPACE 1
INITB    OPEN  (IN,,PRT,OUTPUT,CNS,OUTPUT),MF=L
INITE    GETMAIN VC,LA=INITF,A=CCWDATA,MF=L
INITF    DC    A(7294,20483)
INITG    RDJFCB UT1,MF=L
 TITLE 'RTP5005M - TERMINATION CSECT - A.MORRISH.'
END      CSECT
         BALR  R11,R0              INITIALISE BASE REGISTER.
         USING *,R11               DEFINE BASE REGISTER.
         SPACE 1
*
*        CLOSE DATA SETS.
*
         SPACE 1
         CLOSE MF=(E,ENDA)         CLOSE ALL DATA SETS.
         FREEPOOL PRT              RELEASE BUFFER POOL.
         SPACE 1
*
*        RELEASE DYNAMIC AREA.
*
         SPACE 1
         L     R1,CCWDATA          SET GR1 -> DYNAMIC AREA.
         LA    R1,0(R1)            CLEAR HIGH ORDER BYTE.
         LH    R0,CCWDATA+6        SET GR0 = LENGTH OF DYNAMIC AREA.
         LTR   R0,R0               TEST FOR DYNAMIC AREA PRESENT.
         BZ    *+6                 IF NONE THEN GO TO RETURN.
         FREEMAIN R,LV=(0),A=(1)   RELEASE DYNAMIC AREA.
         SPACE 1                                                      *
*                                                                     *
*        TEST FOR ACTIVE SUB-TASK  AND RETURN.                        *
*                                                                     *
         SPACE 1                                                      *
         L     R2,16               SET GR2 -> CVT.
         L     R2,0(R2)            SET GR2 -> TCB POINTERS.
         L     R2,4(R2)            SET GR2 -> CURRENT TCB.
ENDC     L     R1,136(R2)          SET GR1 -> LAST SUB-TASK.
         LTR   R1,R1               TEST FOR SUB-TASK PRESENT.
         BZ    ENDB                IF NO SUB-TASK THEN END.
         STIMER WAIT,BINTVL=DELAY  WAIT TO ALLOW SUB-TASK COMPLETION.
         B     ENDC                GO TO REPEAT SUB-TASK TEST.
ENDB     GOBACK SAVE,RC=0          RETURN.
         SPACE 1                                                      *
*                                                                     *
*        CONTROL BLOCKS.                                              *
*                                                                     *
         SPACE 1                                                      *
ENDA     CLOSE (IN,,UT1,,CNS,,PRT,),MF=L
 TITLE 'RTP5005M - OPTION LIST CSECT - A.MORRISH.'
O        CSECT
         BALR  R11,R0              INITIALISE BASE REGISTER.
         USING *,R11               DEFINE BASE REGISTER.
         SPACE 1
*
*        SCAN THROUGH LIST OF WRITES TO OPERATOR.
*
         SPACE 1
         LA    R3,OD1              SET GR3 -> START OF LIST.
         SR    R2,R2               SET GR2 = 0.
         LA    R4,OD2+4            SET GR4 -> START OF MESSAGE AREA.
         LA    R5,2                SET GR5 = 2.
OD       IC    R2,0(R3)            SET GR2 = INDEX TO INSTRUCTION.
         EX    R0,OB(R2)           TEST FOR VALIDITY.
         BNO   OC                  IF NOT ONES THEN SKIP WTO.
         MVC   0(36,R4),1(R3)      MOVE MESSAGE TO AREA.
         LA    R4,36(R4)           INCREMENT GR4 FOR NEXT.
         BCT   R5,OC               TEST FOR END - IF NOT GO TEST NEXT.
         LA    R1,OD2              SET GR1 -> MESSAGE.
         BAL   R9,WTO              LINK TO WRITE TO OPERATOR.
         LA    R4,OD2+4            SET GR4 -> START OF MESSAGE AREA.
         LA    R5,2                SET GR5 = 2.
OC       LA    R3,37(R3)           SET GR3 -> NEXT MESSAGE SEGMENT.
         B     OD                  GO TO SET NEXT SEGMENT.
         SPACE 1
OB       TM    *+1,X'FF'           SET RETURN CODE TO 1.
         TM    UT1+48,X'10'        IS SYSUT1 OPEN ?
         TM    SW,X'80'            IS REMOTE CONSOLE PRESENT ?
         TM    SW,X'C0'            IS REMOTE CONSOLE ENABLED.
         TM    SW,X'08'            IS ZAP ENABLED ?
         TM    SW,X'04'            IS A CORE ZAP ENABLED ?
         TM    SWA,X'80'           IS OUTPUT DATA SET OPEN ?
         TM    SWA,X'40'           IS OUTPUT DATA SET CLOSED ?
         B     REPEAT              GO TO RE-ISSUE WTOR.
         SPACE 1                                                      *
*                                                                     *
*        TABLE OF MESSAGE SEGMENTS.                                   *
*                                                                     *
         SPACE 1                                                      *
OD1      DC    AL1(00),CL36'A PROG,PARM-ATTACH A SUB-TASK.'     '
         DC    AL1(12),CL36'C COMMAND  -OPERATOR COMMAND.'      '
         DC    AL1(04),CL36'D DSN      -DELETE A DATA SET.'     '
         DC    AL1(04),CL36'D DSN(M)   -DELETE A PDS MEMBER.'   '
         DC    AL1(04),CL36'E DSN      -LIST DATA SET EXTENTS.' '
         DC    AL1(04),CL36'I CCHHR    -INSPECT A BLOCK ON DASD.'
         DC    AL1(00),CL36'J          -LIST ACTIVE JOBS.'      '
         DC    AL1(00),CL36'K          -LIST THE SYSTEM CATALOG.'
         DC    AL1(00),CL36'K CUA/SER  -LIST A CATALOG.'        '
         DC    AL1(00),CL36'K NODE     -LIST A CATALOG NODE.'   '
         DC    AL1(00),CL36'K DEV,NODE -LIST A CATALOG NODE.'   '
         DC    AL1(00),CL36'L DSN      -LOCATE A DATA SET.'     '
         DC    AL1(00),CL36'M MSG      -MESSAGE TO MASTER CONS. '
         DC    AL1(00),CL36'M ROUT,MSG -MESSAGE TO MCS CONSOLE. '
         DC    AL1(08),CL36'M ADDR,MSG -MESSAGE TO REMOTE 2260. '
         DC    AL1(04),CL36'N          -END CURRENT DEVICE.     '
         DC    AL1(00),CL36'O          -LIST CURRENT OPTIONS.   '
         DC    AL1(04),CL36'P DSN      -LIST PDS MEMBER NAMES.  '
         DC    AL1(04),CL36'P DSN(M)   -LIST PDS MEMBER ENTRY.  '
         DC    AL1(04),CL36'R DSN,DSN1 -RENAME A DATA SET.      '
         DC    AL1(04),CL36'R DSN(M),M1-RENAME A PDS MEMBER.    '
         DC    AL1(00),CL36'S MSG      -SWITCH TO MASTER CONS.  '
         DC    AL1(00),CL36'S ROUT,MSG -SWITCH TO MCS CONSOLE.  '
         DC    AL1(08),CL36'S ADDR,MSG -SWITCH TO REMOTE 2260.  '
         DC    AL1(00),CL36'U          -LIST ALL UCBS.          '
         DC    AL1(00),CL36'U CUA/SER  -LIST UCB CONTENTS.'     '
         DC    AL1(04),CL36'V          -LIST VTOC (NAMES ONLY). '
         DC    AL1(24),CL36'W DATA     -WRITE OUTPUT DATA SET.  '
         DC    AL1(28),CL36'W DDNAME   -SPECIFY OUTPUT DATA SET.'
         DC    AL1(00),CL36'X ADDR     -INSPECT CORE.           '
         DC    AL1(20),CL36'Y ADDR,DATA-MODIFY CORE.            '
         DC    AL1(16),CL36'Z ADDR,DATA-MODIFY DATA ON DASD.    '
         DC    AL1(32)
OD2      DC    H'76,0',CL72' '
 TITLE 'RTP5005M - TERMINATE DEVICE CSECT - A.MORRISH.'
N        CSECT
         BALR  R11,R0              INITIALISE BASE REGISTER.
         USING *,R11               DEFINE BASE REGISTER.
         SPACE 1
*
*        TEST FOR VALIDITY.
*
         SPACE 1
         TM    UT1+48,X'10'        IS SYSUT1 OPEN ?
         BCR   8,R9                IF NOT THEN RETURN.
         SPACE 1
*
*        CLOSE SYSUT1 DATA SET.
*
         SPACE 1
         CLOSE MF=(E,NA)           CLOSE SYSUT1 DATA SET.
         SPACE 1
*
*        REQUEST DEVICE.
*
         SPACE 1
         LA    R1,WTOR1            SET GR1 -> SPECIFY DEVICE MESSAGE.
         BAL   R9,WTOR             LINK TO WRITE TO OPERATOR.
         SPACE 1
*
*        RESET HEADER SERIAL NUMBER, DEVICE AND TRACK ADDRESSES.      *
*
         SPACE 1
         MVI   HDRFROM,C'0'        CLEAR FIRST BYTE OF FROM ADDRESS.
         MVC   HDRFROM+1(L'HDRFROM-1),HDRFROM     SET ADDRESS TO ZEROS.
         MVC   HDRTO,HDRFROM       SET TO ADDRESS TO ZEROS.
         MVC   HDRSER,HDRFROM      SET SERIAL NUMBER TO ZERS.
         B     WAIT1               GO TO WAIT FOR REPLY.
         SPACE 1                                                      *
*                                                                     *
*        CONTROL BLOCK.                                               *
*                                                                     *
         SPACE 1                                                      *
NA       CLOSE UT1,MF=L            CLOSE SYSUT1 DATA SET.
 TITLE 'RTP5005M - SCRATCH/RENAME A DATA SET/MEMBER CSECT - A.MORRISH.'
D        CSECT
         ENTRY R
R        BALR  R11,R0              INITIALISE BASE REGISTER.
         USING *,R11               DEFINE BASE REGISTER.
         SPACE 1
*
*        CHECK VALIDITY
*
         SPACE 1
         TM    UT1+48,X'10'        IS SYSUT1 OPEN ?
         BCR   8,R9                IF NOT THEN RETURN.
         SPACE 1
*
*        FIND DATA SET NAME.
*
         SPACE 1
         LA    R15,REP+2           SET GR15 FOR SCAN FOR DATA SET NAME.
         LA    R14,1               SET GR14 = 1.
         CLI   0(R15),C' '         IS CHARACTER BLANK ?
         BNE   *+8                 IF NOT THEN FOUND.
         BXH   R15,R14,*-8         LOOP UNTIL DATA SET NAME FOUND.
         SPACE 1
*
*        FIND END OF NAME.
*
         SPACE 1
         LA    R14,REP+79          SET GR14 -> END OF REPLY.
         SR    R14,R15             SET GR14 = LENGTH FOR SCAN.
         BCR   4,R9                IF NEGATIVE THEN NAME ABSENT.
         LA    R1,REP+80           SET GR1 FOR NO DELIMITER.
         EX    R14,D1              SCAN TO FIND DELIMITER.
         SPACE 1
*
*        STORE NAME IN JFCB.
*
         SPACE 1
         SR    R1,R15              DECREMENT GR1 FOR MOVE.
         BCTR  R1,R0               DECREMENT GR1 FOR EXECUTE.
         MVI   JFCB,C' '           BLANK FIRST BYTE OF JFCB.
         MVC   JFCB+1(43),JFCB     BLANK OUT NAME.
         EX    R1,D2               MOVE DSNAME TO JFCB.
         SPACE 1
*
*        TEST FOR PDS.
*
         SPACE 1
         LA    R15,1(R15,R1)       SET GR15 -> DELIMITER.
         LA    R0,REP+80           SET GR0 FOR COMPRE.
         CR    R15,R0              COMPARE FOR END.
         BNL   D3                  IF END THEN GO TO TEST FOR DELETE.
         CLI   0(R15),C' '         IS DELIMITER BLANK ?
         BE    D3                  IF EQUAL THEN GO TO TEST FOR DELETE.
         CLI   0(R15),C'('         IS A MEMBER SPECIFIED ?
         BE    D4                  IF SO THEN GO TO PROCESS MEMBER.
         CLI   0(R15),C','         IS DELIMITER A COMMA ?
         BCR   7,R9                IF NOT THEN RETURN.
         CLI   REP,C'R'            IS RENAME SPECIFIED ?
         BCR   7,R9                IF NOT THEN RETURN.
         LA    R15,1(R15)          SET GR15 -> CHARACTER BEYOND.DELIMIT
         LA    R1,REP+80           SET GR1 FOR EXECUTE FAIL.
         LA    R14,REP+79          SET GR14 -> END OF REPLY.
         SR    R14,R15             SET GR14 = LENGTH FOR SCAN.
*        LR    R0,R1               SAVE ADDRESS FOR EXECUTE FAIL.
         EX    R14,D1              SCAN TO FIND DELIMITER.
         BZ    *+10                IF EXECUTE FAIL THEN LEAVE.
         CLI   0(R1),C' '          IS DELIMITER BLANK ?
         BCR   7,R9                IF NOT THEN RETURN.
         SPACE 1
*
*        ISSUE RENAME.
*
         SPACE 1
         SR    R1,R15              DECREMENT GR1 FOR MOVE.
         BCTR  R1,R0               DECREMENT GR1 FOR EXECUTE.
         MVI   D5,C' '             BLANK FIRST BYTE OF NEW NAME.
         MVC   D5+1(43),D5         CLEAR NEW NAME.
         EX    R1,D6               STORE NEW NAME.
         MVC   D7+2(4),16(R10)     STORE DEVICE TYPE.
         MVC   D7+6(6),28(R10)     STORE VOLUME SERIAL.
         LR    R0,R10              SET GR0 -> UCB.
         RENAME D8                 ISSUE RENAME.
         LA    R15,X'F0'(R15)      SET RETURN CODE TO NUMERIC.
         STC   R15,D9+25           STORE RETURN CODE IN MESSAGE.
         MVC   D9+27(1),D7+13      STORE VOLUME CODE IN MESSAGE.
         OI    D9+27,X'F0'         SET ZONE ON VOLUME CODE.
         LA    R1,D9               SET GR1 -> WTO MESSAGE.
D25      BAL   R9,WTO              LINK TO WRITE TO OPERATOR.
         B     REPEAT              GO TO RE-ISSUE WTOR.
         SPACE 1
D1       TRT   0(0,R15),D10        SCAN FOR DELIMITER.
D2       MVC   JFCB(0),0(R15)      MOVE DSNAME TO JFCB.
D6       MVC   D11(0),0(R15)       MOVE NEW NAME TO NEW NAME FIELD.
         SPACE 1
*
*        PROCESS SCRATCH.
*
         SPACE 1
D3       CLI   REP,C'D'            IS DELETE REQUESTED ?
         BCR   7,R9                IF NOT THEN RETURN.
         MVC   D7+2(4),16(R10)     STORE DEVICE TYPE.
         MVC   D7+6(6),28(R10)     STORE VOLUME SERIAL.
         LR    R0,R10              SET GR0 -> UCB.
         SCRATCH D12               SCRATCH DATA SET.
         LA    R15,X'F0'(R15)      SET RETURN CODE TO NUMERIC
         STC   R15,D13+26          STORE RETURN CODE IN MESSAGE.
         MVC   D13+28(1),D7+13     STORE VOLUME CODE IN MESSAGE.
         OI    D13+28,X'F0'        SET ZONE ON VOLUME CODE.
         LA    R1,D13              SET GR1 -> WTO MESSAGE.
         B     D25                 GO TO RE-ISSUE WTOR.
         SPACE 1
*
*        SET UP FOR OPEN BPAM DATA SET.
*
         SPACE 1
D4       MVI   D5,C' '             BLANK FIRST BYTE OF MEMBER NAME.
         MVC   D5+1(16),D5         BLANK NAME AND NEW NAME FIELD.
         LA    R15,1(R15)          INCREMENT GR15 FOR FIRST BYTE.
         LA    R14,REP+79          SET GR14 -> END OF REPLY.
         SR    R14,R15             SET GR14 = LENGTH FOR EXECUTE.
         BCR   4,R9                IF MINUS THEN RETURN.
*        LA    R1,REP+80           SET GR1 FOR TRT FAIL.
         EX    R14,D1              TRANSLATE AND TEST.
         BCR   8,R9                IF NO END DELIMITER THEN RETURN.
         CLI   0(R1),C')'          IS DELIMITER CLOSING PARENTHESIS ?
         BCR   7,R9                IF NOT THEN RETURN.
         SR    R1,R15              DECREMENT GR1 FOR LENGTH.
         LA    R0,8                SET GR0 = MAX LENGTH.
         CLR   R1,R0               COMPARE FOR FIT.
         BCR   2,R9                IF NO FIT THEN RETURN.
         BCTR  R1,R0               DECREMENT GR1 FOR EXECUTE.
         EX    R1,D14              MOVE MEMBER NAME TO LIST AREA.
         LA    R15,2(R15,R1)       SET GR15 -> DELIMITER PAST PAREN,
         LA    R0,REP+80           SET GR0 FOR COMPARE.
         CR    R15,R0              COMPARE FOR FIT.
         BNL   D15                 IF END OF REPLY THEN GO TO TEST DEL.
         CLI   0(R15),C' '         IS DELIMITER A BLANK ?
         BE    D15                 IF SO THEN GO TO TEST DELETE.
         CLI   0(R15),C','         IS DELIMITER A COMMA ?
         BCR   7,R9                IF NOT THEN RETURN.
         LA    R15,1(R15)          SET GR15 FOR NEW NAME.
         CLI   REP,C'R'            IS RENAME SPECIFIED ?
         BCR   7,R9                IF NOT THEN RETURN.
         LA    R14,REP+79          SET GR14 -> END OF REPLY.
         SR    R14,R15             SET GR14 = LENGTH FOR EXECUTE.
         LA    R1,REP+80           SET GR1 FOR TRT FAIL.
         BCR   4,R9                RETURN IF MINUS.
         EX    R14,D1              SCAN FOR DELIMITER.
         BZ    *+10                IF NONE FOUND THEN EXIT.
         CLI   0(R1),C' '          IS DELIMITER BLANK ?
         BCR   7,R9                IF NOT THEN RETURN.
         SR    R1,R15              DECREMENT GR1 FOR MOVE.
         LA    R0,8                SET GR0 = 8.
         CR    R1,R0               COMPARE FOR FIT.
         BCR   2,R9                RETURN IF NO FIT.
         BCTR  R1,R0               DECREMENT GR1 FOR EXECUTE.
         EX    R1,D16              MOVE NEW NAME TO LIST AREA.
         B     D17                 GO TO OPEN.
         SPACE 1
D14      MVC   D5(0),0(15)         MOVE MEMBER NAME TO AREA.
D16      MVC   D5+8(0),0(15)       MOVE NEW NAME TO AREA.
         SPACE 1
D15      CLI   REP,C'D'            IS DELETE SPECIFIED.
         BCR   7,R9                IF NOT THEN RETURN.
         SPACE 1
*
*        SCAN TO FIND WHETHER DATA SET EXISTS.
*
         SPACE 1
D17      GETMAIN R,LV=350          OBTAIN DYNAMIC AREA FOR OBTAIN.
         ST    R1,D18+12           STORE ADDRESS FOR OBTAIN.
         OBTAIN D18                OBTAIN DSCB
         LTR   R15,R15             TEST FOR DSNAME PRESENT.
         BZ    D19                 IF PRESENT THEN GO TO OPEN.
         L     R1,D18+12           SET GR1 -> DYNAMIC ADDRESS.
D21      FREEMAIN R,LV=350,A=(1)   RELEASE DYNAMIC AREA.
         LA    R1,D20              SET GR1 -> DATA SET NOT FOUND MSG.
         B     D25                 GO TO RE-ISSUE WTOR.
         SPACE 1
*
*        TEST FOR DSORG = PO.
*
         SPACE 1
D19      L     R1,D18+12           SET GR1 -> DYNAMIC AREA.
         TM    38(R1),X'02'        IS DSORG PO ?
         BZ    D21                 IF NOT THEN GO TO RELEASE.
         FREEMAIN R,LV=350,A=(1)   RELEASE DYNAMIC AREA.
         SPACE 1
*
*        OPEN DATA SET.
*
         SPACE 1
         OPEN  MF=(E,D22),TYPE=J   OPEN DATA SET.
         SPACE 1
*
*        ISSUE STOW.
*
         SPACE 1
         LA    R1,D23              SET GR1 -> DCB.
         LA    R0,D5               SET GR0 -> LIST.
         CLI   REP,C'O'            IS DELETE SPECIFIED ?
         BE    *+8                 IF SO THEN GO TO SET DELETE.
         LCR   R1,R1               SET RENAME.
         LCR   R0,R0               SET GR0 FOR RESET.
         LCR   R0,R0               SET DELETE.
         SVC   21                  STOW.
         SPACE 1
*
*        SET RETURN CODE FROM STOW.
*
         SPACE 1
         CVD   R15,DW              CONVERT TO DECIMAL.
         OI    DW+7,X'0F'          REMOVE ZONE.
         UNPK  D24+23(2),DW+6(2)   UNPACK.
         CLOSE MF=(E,D22)          CLOSE DATA SET.
         SPACE 1
*
*        RETURN.
*
         SPACE 1
         LA    R1,D24              SET GR1 -> MESSAGE.
         B     D25                 GO TO RE-ISSUE WTOR.
         EJECT
*
*        CONSTANTS AND WORK AREAS.
*
         SPACE 1
D23      DCB   DDNAME=SYSWK,EXLST=EXIT,DSORG=PO,MACRF=W
D22      OPEN  (D23,OUTPUT),MF=L
D8       CAMLST RENAME,JFCB,D5,D7
D12      CAMLST SCRATCH,JFCB,,D7
D18      CAMLST SEARCH,JFCB,JFCB+118,0
D11      DS    0C
D5       DC    CL44' '
D9       WTO   'RETURN FROM RENAME = 0,0',MF=L
D13      WTO   'RETURN FROM SCRATCH = 0,0',MF=L
D20      WTO   'DS ABSENT OR NOT DSORG = PO',MF=L
D24      WTO   'RETURN FROM STOW = 00',MF=L
D7       DC    H'1',X'00000000',C'000000',H'0'
D10      DC    256X'0'
         ORG   D10+C' '
         DC    X'1'
         ORG   D10+C','
         DC    X'1'
         ORG   D10+C'('
         DC    X'1'
         ORG   D10+C')'
         DC    X'1'
         ORG
 TITLE 'RTP5005M - VTOC LISTING CSECT - A.MORRISH.'
V        CSECT
         BALR  R11,R0              INITIALISE BASE REGISTER.
         USING *,R11               DEFINE BASE REGISTER.
         SPACE 1
*
*        TEST VALIDITY.
*
         SPACE 1
         TM    UT1+48,X'10'        IS SYSUT1 OPEN ?
         BCR   8,R9                IF NOT THEN RETURN.
         SPACE 1                                                      *
*                                                                     *
*        SCAN TO CHECK FOR SPACE ONLY REQUESTED.                      *
*                                                                     *
         SPACE 1                                                      *
         LA    R15,REP+2           SET GR15 TO START SCAN.
         LA    R14,1               SET GR14 = 1.
         CLI   0(R15),C' '         IS CHARACTER BLANK ?
         BNE   *+8                 EXIT WHEN FOUND.
         BXH   R15,R14,*-8         LOOP UNTIL FOUND.
         LA    R14,REP+75          SET GR14 TO CHECK FOR NAME.
         SR    R14,R15             SET GR14 = LENGTH REMAINING.
         BM    *+14                IF MINUS THEN NO SPACE.
         CLC   VO,0(R15)           COMPARE FOR 'SPACE'
         BE    VN                  IF SO THEN GO TO PRODUCE 'SPACE' MSG
         SPACE 1                                                      *
*
*        READ FORMAT 4 DSCB.
*
         SPACE 1
         LA    R0,VK               SET GR0 -> INITIAL CHANNEL PROGRAM.
         ST    R0,VA+16            STORE ADDRESS OF CHANNEL PROGRAM.
         MVC   VA+35(4),F4DSCB     SET POINTER TO FORMAT 4 DSCB.
         MVI   VA+39,1             SET POINTER TO RECORD ONE.
         EXCP  VA                  READ FORMAT 4 DSCB.
         WAIT  1,ECB=ECB           WAIT FOR COMPLETION.
         SPACE 1
*
*        SET VTOC LIMIT.
*
         SPACE 1
         MVC   VB,VC+1             SAVE VTOC LIMIT FROM FORMAT 4 DSCB.
         SPACE 1
*
*        INITIALISE POINTER FOR WTO MESSAGE.
*
         SPACE 1
         LA    R2,VD+3             SET GR2 -> START OF WTO.
         SPACE 1
*
*        READ KEY.
*
         SPACE 1
         LA    R0,VL               SET GR0 -> CONTINUATION CHANNEL PROG
         ST    R0,VA+16            STORE ADDRESS OF CHANNEL PROGRAM.
VJ       EXCP  VA                  READ KEY OF NEXT RECORD.
         WAIT  1,ECB=ECB           WAIT FOR COMPLETION.
         SPACE 1
*
*        CHECK FOR TYPE 1 DSCB.
*
         SPACE 1
         CLI   VC+44,C'1'          IS DSCB TYPE 1 ?
         BNE   VF                  IF NOT THEN GO TO TEST FOR END.
         SPACE 1
*
*        MOVE NAME TO WTO.
*
         SPACE 1
         LA    R1,VC+43            SET GR1 -> END OF NAME.
         CLI   0(R1),C' '          IS NAME BLANK ?
         BNE   *+8                 IF NOT THEN EXIT.
         BCT   R1,*-8              LOOP UNTIL END FOUND.
         LA    R0,VC               SET GR0 FOR SUBTRACT.
         SR    R1,R0               SET GR1 = LENGTH FOR MOVE.
         LA    R0,VD+82            SET GR0 -> END OF WTO AREA.
         SR    R0,R2               SET GR0 = LENGTH REMAINING.
         CR    R1,R0               COMPARE FOR FIT.
         BL    VG                  IF FIT THEN GO TO MOVE.
         ST    R1,VH               STORE LENGTH FOR RETURN.
         LA    R0,VD-1             SET GR0 FOR SUBTRACT.
         SR    R2,R0               SET GR2 = LENGTH OF AREA.
         STH   R2,VD               STORE LENGTH FOR WTO.
         LA    R1,VD               SET GR1 -> WTO AREA.
         BAL   R9,WTO              LINK TO WRITE TO OPERATOR.
         LA    R2,VD+3             SET GR2 FOR MOVE.
         L     R1,VH               RESTORE GR1.
VG       EX    R1,VI               MOVE DATA TO WTO AREA.
         LA    R2,2(R1,R2)         SET GR2 -> CHARACTER AFTER MESSAGE.
         MVI   0(R2),C','          SET DELIMITER.
         SPACE 1
*
*        CHECK FOR END OF DSCB.
*
         SPACE 1
VF       CLC   VB,VA+35            COMPARE FOR LAST FORMAT 1 DSCB.
         BNL   VJ                  IF NOT GREATER THEN RETURN TO EXCP.
         SPACE 1
*
*        CHECKFOR ANY WTO.
*
         SPACE 1
         LA    R0,CPRDATA          ***  RESTORE IOB.   ***  TEMPORARY *
         ST    R0,RDATA+16         ***                 ***  PRECAUTION*
         LA    R0,VD+3             SET GR0 -> START FOR WTO.
         CR    R0,R2               COMPARE FOR NO OUTPUT.
         BE    VN                  IF NONE THEN GO TO WRITE SPACE.
         SPACE 1
*
*        WRITE LAST WTO.
*
         SPACE 1
*        MVI   0(R2),C' '
         LA    R1,VD               SET GR0 -> WTO MESSAGE.
         SR    R2,R1               SET GR2 = LENGTH FOR WTO.
         STH   R2,VD               STORE LENGTH IN WTO
         BAL   R9,WTO              LINK TO WRITE TO OPERATOR.
VN       L     R1,UT1+44           SET GR1 -> DEB
         LH    R0,34(R1)           SET GR0 -> UCB
         LA    R1,VD+4             SET GR1 -> REPLY AREA.
         SVC   78                  ISSUE LSPACE SVC
         LA    R1,VD               SET GR1 -> WTO.
         MVI   VD+1,34             STORE MESSAGE LENGTH.
         BAL   R9,WTO              LINK TO WRITE LSPACE MESSAGE.
         B     REPEAT              GO TO RE-ISSUE WTOR.
         SPACE 3
*        CONSTANTS AND WORK AREAS.
         SPACE 1
VA       EQU   RDATA
VH       DC    F'0'
VD       DC    H'84,0',CL80' '     MESSAGE CREATION AREA.
VB       DC    XL5'0'
VC       DC    CL45' '
VI       MVC   1(0,R2),VC          MODEL STATEMENT.
VK       CCW   X'31',VA+35,X'40',5 SEARCH FOR FORMAT 4 DSCB.
         CCW   X'08',VK,0,6        TIC UNTIL FOUND.
         CCW   X'06',VC,X'60',6    READ DATA
VM       CCW   X'92',VA+35,X'60',5 READ COUNT FIELD OF NEXT RECORD.
         CCW   X'49',VK+15,X'60',1 SEARCH FOR KEY GREATER THAN X'06'.
         CCW   X'08',VM,0,0        TIC UNTIL FOUND
         CCW   X'03',0,0,1         NOP TO END CHANNEL PROGRAM.
         SPACE 1
VL       CCW   X'31',VA+35,X'40',5 SEARCH FOR DSCB.
         CCW   X'08',VL,0,0        TIC UNTIL FOUND.
         CCW   X'0E',VC,X'60',45   READ KEY AND DATA.
         CCW   X'08',VM,0,0        GO TO SEARCH FOR NEXT FORMAT 1 DSCB.
VO       DC    C'SPACE'
 TITLE 'RTP5005M - LIST PDS CSECT - A.MORRISH.'
P        CSECT
         BALR  R11,R0              INITIALISE BASE REGISTER.
         USING *,R11               DEFINE BASE REGISTER.
         SPACE 1
*
*        CHECK VALIDITY.
*
         SPACE 1
         TM    UT1+48,X'10'        IS SYSUT1 OPEN ?
         BCR   8,R9                IF NOT THEN RETURN.
         SPACE 1
*
*        SCAN TO FIND DATA SET NAME.AND MEMBER NAME.
*
         SPACE 1
         LA    R15,REP+2           SET GR15 TO START SCAN.
         LA    R14,1               SET GR14 = 1.
         CLI   0(R15),C' '         IS CHARACTER BLANK ?
         BNE   *+8                 EXIT WHEN FOUND.
         BXH   R15,R14,*-8         LOOP UNTIL FOUND.
         LA    R14,REP+79          SET GR14 FOR SCAN.
         LA    R1,REP+80           SET GR1 FOR SCAN FAIL.
         SR    R14,R15             SET GR14 FOR EXECUTE.
         BCR   4,R9                IF NO DATA SET NAME THEN RETURN.
         EX    R14,PA              SCAN FOR DELIMITER.
         SR    R1,R15              SET GR1 = LENGTH OF PARAMETER.
         MVI   PB,C' '             BLANK FIRST BYTE OF DATA SET.
         MVC   PB+1(51),PB         BLANK REMAINDER OF DATA SET NAME.
         LA    R0,44               SET GR0 = MAXIMUM LENGTH.
         CR    R1,R0               COMPARE FOR FIT.
         BCR   2,R9                IF NO FIT THEN RETURN.
         BCTR  R1,R0               DECREMENT GR1 FOR MOVE.
         EX    R1,PC               MOVE DSNAME TO DSNAME AREA.
         LA    R15,1(R1,R15)       SET GR15 -> DELIMITER.
         LA    R0,REP+80           SET GR0 FOR TEST.
         CR    R15,R0              COMPARE FOR FULL BUFFER
         BNL   PD                  IF NO FIT THEN GO TO LIST MEMBERS.
         CLI   0(R15),C' '         IS DELIMITER BLANK ?
         BE    PD                  IF SO THEN GO TO LIST MEMBERS.
         CLI   0(R15),C'('         IS DELIMITER A PARENTHESIS ?
         BCR   7,R9                IF NOT THEN RETURN.
         LA    R15,1(R15)          INCREMENT GR15 FOR MEMBER NAME.
         LA    R14,REP+79          SET GR14 FOR SUBTRACT.
         SR    R14,R15             SET GR14 = LENGTH FOR SCAN.
         EX    R14,PA              SCAN FOR DELIMITER.
         BCR   8,R9                RETURN IF NONE FOUND.
         CLI   0(R1),C')'          IS DELIMITER A CLOSING PARENTHESIS ?
         BCR   7,R9                IF NOT THEN RETURN.
         SR    R1,R15              SET GR1 = LENGTH OF MEMBER NAME.
         LA    R0,8                SET GR0 = MAXIMUM LENGTH.
         CR    R1,R0               COMPARE FOR FIT.
         BCR   2,R9                IF GREATER THEN ERROR.
         BCTR  R1,R0               DECREMENT GR1 FOR EXECUTE.
         EX    R1,PE               MOVE MEMBER NAME TO AREA.
         SPACE 1
*
*        FIND DSCB.
*
         SPACE 1
PD       MVC   PF+35(4),F4DSCB     STORE START OF VTOC IN IOB.
         EXCP  PF                  SCAN FOR DSNAME.
         WAIT  1,ECB=ECB           WAIT FOR COMPLETION.
         LA    R0,PG               SET GR0 -> END OF CHANNEL PROGRAM.
         L     R1,PF+8             SET GR1 -> LAST CCW EXECUTED.
         LA    R1,0(R1)            CLEAR HIGH ORDER BIT.
         CR    R1,R0               TEST FOR DATA SET NOT FOUND.
         BE    PH                  IF SO THEN GO TO NOTE.
         TM    PI+38,X'02'         IS DSORG PO ?
         BZ    PJ                  IF NOT THEN GO TO NOTE.
         SPACE 1
*
*        CHECK FOR MEMBER LISTING.
*
         SPACE 1
         CLI   PB+44,C' '          IS A MEMBER SPECIFIED ?
         BNE   PK                  IF SO THEN GO TO PROCESS.
         SPACE 1
*
*        SET UP TO READ DIRECTORY AND WRITE TO OPERATOR.
*
         SPACE 1
         MVC   PL+35(4),PI+63      STORE CCHH IN IOB.
         MVI   PL+39,1             SET R IN IOB.
         LA    R2,PM+4             SET GR2 -> FIRST NAME AREA.
         SPACE 1
*
*        READ DIRECTORY.
*
         SPACE 1
PT       EXCP  PL                  READ DIRECTORY BLOCK.
         WAIT  1,ECB=ECB           READ MEMBER.
         SPACE 1
*
*        SCAN BLOCK AND STORE MEMBERS.
*
         SPACE 1
         LH    R0,PI               SET GR0 = LENGTH USED IN BLOCK.
         BCTR  R0,R0               DECREMENT GR0.
         BCTR  R0,R0               DECREMENT GR0.
         LA    R15,PI+2            SET GR15 -> FIRST MEMBER.
PU       CLI   0(R15),X'FF'        IS IT END OF DIRECTORY ?
         BE    PN                  IF SO THEN GO TO FINAL WRITE.
         MVC   0(8,R2),0(R15)      STORE MEMBER NAME IN WTO.
         LA    R2,9(R2)            INCREMENT GR2 FOR NEXT STORE.
         LA    R1,PO               SET GR1 -> END OF WTO.
         CR    R2,R1               COMPARE FOR FIT.
         BL    PQ                  IF FIT THEN GO TO WRITE.
         STM   R15,R0,PR           STORE REGS.
         LA    R1,PM               SET GR1 -> WTO AREA.
         BAL   R9,WTO              LINK TO WRITE TO OPERATOR.
         MVI   PM+4,C' '           BLANK FIRST BYTE OF WTO.
         MVC   PM+5(79),PM+4       BLANK OUT WTO AREA.
         LM    R15,R0,PR           RESTORE REGISTERS.
         LA    R2,PM+4             SET GR2 FOR NEXT WTO.
PQ       LH    R1,10(R15)          SET GR1 = USER DATA HALF-WORDS.
         N     R1,PS               CLEAR EXTRANEOUS BITS.
         LA    R1,12(R1,R1)        SET GR1 = LENGTH OF ENTRY.
         SR    R0,R1               DECREMENT GR0 FOR RESIDUAL COUNT.
         BNP   PT                  IF MINUS THEN GO TO READ NEXT BLOCK.
         AR    R15,R1              INCREMENT GR15 FOR NEXT MEMBER.
         B     PU                  GO TO STORE NEXT MEMBER.
         SPACE 1
PA       TRT   0(0,R15),PV         MODEL STATEMENT.
PC       MVC   PB(0),0(R15)        MODEL STATEMENT.
PE       MVC   PB+44(0),0(R15)     MODEL STATEMENT.
         SPACE 1
*
*        FINAL WRITE.
*
         SPACE 1
PN       LA    R1,PM               SET GR1 -> WTO.
         SR    R2,R1               SET GR2 = LENGTH FOR WTO.
         STH   R2,PM               STORE LENGTH IN WTO.
         LA    R0,4                SET GR0 = 4
         CR    R2,R0               COMPARE FOR NO WTO.
         BE    REPEAT              IF NO WTO THEN RETURN.
         BAL   R9,WTO              LINK TO WRITE TO OPERATOR.
         B     REPEAT              GO TO RETURN.
         EJECT
*
*        SCAN FOR SPECIFIED MEMBER.
*
         SPACE 1
PK       MVC   PW+35(4),PI+63      STORE CCHH IN IOB.
         EXCP  PW                  SCAN FOR MEMBER.
         WAIT  1,ECB=ECB           WAIT FOR COMPLETION.
         TM    PW+12,X'01'         IS UNIT EXCEPTION ?
         BO    PX                  IF SO THEN MEMBER NOT FOUND.
         SPACE 1
*
*        SCAN BLOCK FOR MEMBER.
*
         SPACE 1
         LH    R0,PI               SET GR0 = LENGTH OF BLOCK.
         BCTR  R0,R0               DECREMENT GR0.
         BCTR  R0,R0               DECREMENT GR0.
         LA    R15,PI+2            SET GR15 -> FIRST MEMBER.
PZ       CLI   0(R15),X'FF'        IS IT END OF DIRECTORY ?
         BE    PX                  IF SO THEN MEMBER NOT FOUND.
         LH    R1,10(R15)          SET GR1 = USER DATA HALF WORDS.
         N     R1,PS               CLEAR EXTRANEOUS BITS.
         LA    R1,12(R1,R1)        SET GR1 = LENGTH OF ENTRY.
         CLC   0(8,R15),PB+44      IS THIS MEMBER ?
         BH    PX                  IF HIGH THEN MEMBER NOT FOUND.
         BE    PY                  IF SO THEN GO TO SET WTO.
         SR    R0,R1               SET GR0 = RESIDUAL COUNT.
         BNP   PX                  IF NOT PLUS THEN NOT FOUND.
         AR    R15,R1              SET GR15 -> NEXT MEMBER.
         B     PZ                  GO TO TEST NEXT MEMBER.
         SPACE 1
*
*        SET UP WTO.
*
         SPACE 1
PY       MVC   P0+4(8),0(R15)      MOVE MEMBER NAME TO WTO.
         MVC   P0+13(71),P0+12     CLEAR AREA.
         LR    R2,R1               SET GR2 = LENGTH OF ENTRY.
         LA    R3,12(R15)          SET GR3 -> USER DATA.
         UNPK  PM+13(9),8(5,R15)   EDIT TTRC TO OUTPUT MESSAGE.
         TR    PM+13(8),HEXTAB     CONVERT TO READABLE FORMAT.
         MVI   PM+21,C' '          RESTORE BLANK.
         LA    R0,12               SET GR0 = 12.
         SR    R2,R0               DECREMENT GR2 FOR NAME AND TTRC.
         BNP   P2                  IF ZERO THEN NO USER DATA.
P4       LA    R0,25               SET GR0 = BYTES PER LINE.
         CR    R2,R0               COMPARE FOR FIT.
         BNH   P3                  IF FIT THEN GO TO EDIT.
         HEXPRINT (R3),MF=(E,P5)   EDIT DATA TO USER AREA.
         SR       R2,R0            DECREMENT GR2 FOR RESIDUAL LENGTH.
         AR       R3,R0            INCREMENT GR3 FOR EDIT.
         STM      R2,R3,PR         SAVE REGISTERS.
         LA    R1,P0               SET GR1 -> WTO AREA.
         BAL   R9,WTO              LINK TO WRITE TO OPERATOR.
         MVI   P0+4,C' '           BLANK FIRST BYTE.
         MVC   P0+5(79),P0+4       CLEAR AREA.
         LM    R2,R3,PR            RESTORE REGISTERS.
         B     P4                  GO TO WRITE NEXT LINE.
P3       HEXPRINT (R3),,(R2),MF=(E,P5) EDIT DATA TO USER AREA.
         LA    R0,25               SET GR0 = 25.
         STH   R0,P5+8             RESTORE LENGTH FOR HEXPRINT.
P2       LA    R1,P0               SET GR1 -> WTO AREA.
P7       BAL   R9,WTO              LINK TO WRITE TO OPERATOR.
         B     REPEAT              GO TO RE-ISSUE WTOR.
         SPACE 1
*
*        ERROR ROUTINES.
*
         SPACE 1
PH       LA    R1,P6               SET GR1 -> WTO MESSAGE (DS NOT FOUND
         B     P7                  GO TO WRITE TO OPERATOR.
PJ       LA    R1,P8               SET GR1 -> NOT PO WTO MESSAGE.
         B     P7                  GO TO WRITE MESSAGE.
PX       LA    R1,P9               SET GR1 -> MEMBER NOT FOUND MESSAGE.
         B     P7                  GO TO WRITE MESSAGE.
         EJECT
*        CONSTANTS AND WORK AREAS.
         SPACE 1
PB       DS    CL52
PI       DS    CL256
PF       DC    0F'0',X'42',A(ECB,0,0,P10,UT1,0,0),A(0,1)
PL       DC    0F'0',X'42',A(ECB,0,0,P11,UT1,0,0),A(0,1)
PW       DC    0F'0',X'42',A(ECB,0,0,P12,UT1,0,0),A(0,1)
PM       WTO   L80' ',MF=L
PO       EQU   *-7
P0       EQU   PM
P6       WTO   'DATA SET NOT FOUND',MF=L
P8       WTO   'DATA SET NOT DSORG=PO',MF=L
P9       WTO   'MEMBER NOT FOUND',MF=L
PR       DC    2F'0'
PS       DC    F'31'
P5       HEXPRINT ,PM+22,25,(5,1),MF=L
PV       DC    256X'0'
         ORG   PV+C' '
         DC    X'1'
         ORG   PV+C','
         DC    X'1'
         ORG   PV+C'('
         DC    X'1'
         ORG   PV+C')'
         DC    X'1'
         ORG
P10      CCW   X'31',PF+35,X'40',5 SEARCH FOR FORMAT 4 DSCB.
         CCW   X'08',P10,0,0       TIC UNTIL FOUND.
         CCW   X'06',PI,X'60',6    READ FIRST PART OF DATA.
P14      CCW   X'29',PB,X'40',44   SEARCH ON KEY EQUAL.
         CCW   X'08',P13,0,0       TIC IF NOT FOUND.
         CCW   X'06',PI,X'00',96   READ DSCB.
P13      CCW   X'D1',PI+1,X'40',5  SEARCH FOR HIGH ID.
         CCW   X'08',P14,0,0       TIC UNTIL FOUND.
         CCW   X'03',0,0,1         NOP.
PG       EQU   *
P11      CCW   X'31',PL+35,X'40',5 SEARCH FOR BLOCK.
         CCW   X'08',P11,0,0       TIC UNTIL FOUND.
         CCW   X'06',PI,X'40',256  READ BLOCK.
         CCW   X'92',PL+35,X'20',5 READ ADDRESS OF NEXT BLOCK.
P12      CCW   X'31',PW+35,X'40',5 SEARCH FOR START OF DIRECTORY.
         CCW   X'08',P12,0,0       TIC UNTIL FOUND.
P16      CCW   X'E9',PB+44,X'40',8 SEARCH FOR KEY EQUAL OR HIGH.
         CCW   X'08',P15,0,0       TIC TO READ SKIP.
         CCW   X'06',PI,0,256      READ DIRECTORY BLOCK.
P15      CCW   X'06',*,X'70',1     READ SKIP.
         CCW   X'08',P16,0,0       TIC TO SEARCH KEY EQUAL
         TITLE 'RT5005M - LOCATE DATA SET EXTENTS CSECT - A.MORRISH.'
E        CSECT
         BALR  R11,R0              INITIALISE BASE REGISTER.
         USING *,R11               DEFINE BASE REGISTER.
         SPACE 1
*
*        CHECK VALIDITY.
*
         SPACE 1
         TM    UT1+48,X'10'        IS SYSUT1 OPEN ?
         BCR   8,R9                IF NOT THEN RETURN.
         SPACE 1
*
*        FIND DATA SET NAME.
*
         SPACE 1
         LA    R15,REP+2           SET GR15 FOR SCAN FOR DATA SET NAME.
         LA    R14,1               SET GR14 = 1.
         CLI   0(R15),C' '         IS CHARACTER BLANK ?
         BNE   *+8                 IF NOT THEN FOUND.
         BXH   R15,R14,*-8         LOOP UNTIL DATA SET NAME FOUND
         SPACE 1
*
*        FIND END OF NAME.
*
         SPACE 1
         LA    R14,REP+79          SET GR14 -> END OF REPLY.
         SR    R14,R15             SET GR14 = LENGTH FOR SCAN.
         BCR   4,R9                IF NEGATIVE THEN NAME ABSENT.
         LA    R1,REP+80           SET GR1 FOR NO DELIMITER.
         EX    R14,E1              SCAN TO FIND DELIMITER.
         SPACE 1
*
*        STORE NAME IN JFCB
*
         SPACE
         SR    R1,R15              DECREMENT GR1 FOR MOVE.
         BCTR  R1,R0               DECREMENT GR1 FOR EXECUTE.
         MVC   JFCB(44),BLANKS     BLANK OUT OLD NAME.
         EX    R1,E2               MOVE DSNAME TO JFCB.
         SPACE 1
*
*        SCAN TO FIND DSCB.
*
         SPACE 1
         MVC   E3+35(4),F4DSCB     STORE START OF VTOC IN IOB.
         EXCP  E3                  SCAN FOR DSNAME.
         WAIT  1,ECB=ECB           WAIT FOR COMPLETION.
         SPACE 1
*
*        CHECK FOR DATA SET FOUND.
*
         SPACE 1
         LA    R0,E21              SET GR0 -> DSCB FOUND CHAN PROG EXIT
         L     R1,E3+8             SET GR1 -> LAST CCW +8.
         LA    R1,0(R1)            CLEAR HIGH ORDER BYTE.
         CR    R1,R0               COMPARE FOR DSCB FOUND.
         BE    E5                  IF FOUND THEN GO TO PROCESS.
         LA    R1,E6               SET GR1 -> NOT FOUND MESSAGE.
E18      BAL   R9,WTO              LINK TO WRITE TO OPERATOR.
         B     REPEAT              GO TO RE-ISSUE WTOR.
         SPACE 1
*
*        SET UP FIRST 3 EXTENTS.
*
         SPACE 1
E5       TM    E7+61,X'FF'         DOES ANY EXTENT EXIST ?
         BZ    E8                  IF NOT THEN GO TO WRITE NO EXTENT.
         LA    R2,E7+61            SET GR2 -> FIRST EXTENT.
         LA    R3,E9+4             SET GR8 -> OUTPUT AREA.
         LA    R15,3               SET COUNT FOR 3.
E11      UNPK  0(9,R3),2(5,R2)     STORE LOWER LIMIT OF EXTENT.
         UNPK  9(9,R3),6(5,R2)     STORE UPPER LIMIT OF EXTENT.
         TR    0(17,R3),E10        TRANSLATE TO READABLE FORMAT.
         LA    R2,10(R2)           SET GR2 -> NEXT EXTENT.
         MVI   8(R3),C'-'          SET LIMIT INDICATOR.
         MVI   17(R3),C','         SET LIMIT SEPARATOR.
         LA    R3,18(R3)           INCREMENT GR3 FOR NEXT.
         TM    0(R2),X'FF'         IS NEXT EXTENT PRESENT ?
         BZ    *+8                 IF NOT THEN GO TO WRITE MESSAGE.
         BCT   R15,E11             LOOP UNTIL EXHAUSTED.
         CLI   E7+15,3             DOES FORMAT 3 DSCB EXIST ?
         BNH   E12                 IF NOT THEN GO TO WRITE OUTPUT.
         SPACE 1
*
*        READ FORMAT 3 DSCB.
*
         SPACE 1
         MVC   E3+35(5),E7+91      SET ADDRESS OF FORMAT 3 DSCB.
         LA    R0,E13              SET GR0 -> READ F3 DSCB CHAN PROG.
         ST    R0,E3+16            STORE CHANNEL PROGRAM ADDRESS.
E15      EXCP  E3                  READ FORMAT 3 DSCB.
         WAIT  1,ECB=ECB           WAIT FOR COMPLETION.
         CLI   E7,X'03'            IS DSCB FORMAT 3 ?
         BE    E14                 IF SO THEN GO TO PROCESS.
         MVC   E3+35(5),E7+135     STORE ADDRESS OF FORMAT 3 DSCB.
         B     E15                 GO TO READ FORMAT 3 DSCB.
         SPACE 1
*
*        RESTORE IOB.
*
         SPACE 1
E14      LA    R0,E16              SET GR0 -> SCAN FOR DSCB CHAN PROG.
         ST    R0,E3+16            STORE CHANNEL PROGRAM ADDRESS.
         MVI   E3+39,1             SET RECORD 1 ADDRESS.
         SPACE 1
*
*        SET AREA FOR CONTINUOUS SCAN.
*
         SPACE 1
         MVC   E7+44(95),E7+45     MAKE ALL EXTENTS CONTIGUOUS.
         LA    R15,1               SET GR15 TO COMPLETE FIRST LINE.
         LA    R2,E7+4             SET GR2 -> FIRST EXTENT IN FORMAT 3.
         SPACE 1
*
*        LOOP TO SET UP OUTPUT LINES.
*
         SPACE 1
E17      UNPK  0(9,R3),2(5,R2)     STORE LOWER LIMIT OF EXTENT.
         UNPK  9(9,R3),6(5,R2)     STORE UPPER LIMIT OF EXTENT.
         TR    0(17,R3),E10        TRANSLATE TO READABLE FORMAT.
         MVI   8(R3),C'-'          SET LIMIT INDICATOR.
         MVI   17(R3),C','         SET LIMIT SEPARATOR.
         LA    R2,10(R2)           SET GR2 -> NEXT EXTENT.
         LA    R3,18(R3)           SET GR3 FOR NEXT EXTENT.
         TM    0(R2),X'FF'         DOES NEXT EXTENT EXIST ?
         BZ    E12                 IF NOT THEN GO TO WRITE OUTPUT
         BCT   R15,E17             LOOP UNTIL END FOUND.
         LA    R1,E9               SET GR1 -> MESSAGE.
         SR    R3,R1               SET GR3 = LENGTH OF MESSAGE.
         STH   R3,0(R1)            STORE LENGTH.
         BAL   R9,WTO              LINK TO WRITE TO OPERATOR.
         LA    R3,E9+4             SET GR3 FOR NEXT LINE.
         LA    R15,4               SET GR15 = 4.
         B     E17                 GO TO SET UP NEXT LINE.
         SPACE 1
*
*        WRITE LAST LINE.
*
         SPACE 1
E12      LA    R1,E9               SET GR1 -> MESSAGE.
         SR    R3,R1               SET GR3 = LENGTH OF MESSAGE.
         BCTR  R3,R0               DECREMENT GR3 FOR COMMA.
         STH   R3,E9               STORE LENGTH IN MESSAGE.
         B     E18                 GO TO WRITE LAST.
         SPACE 1
*
*        WRITE 'NO EXTENTS' MESSAGE.
*
         SPACE 1
E8       LA    R1,E19              SET GR1 -> 'NO EXTENTS' MESSAGE.
         B     E18                 GO TO WRITE LAST MESSAGE.
         SPACE 2
E1       TRT   0(0,R15),E20        MODEL STATEMENT.
E2       MVC   JFCB(0),0(R15)      MODEL STATEMENT.
         SPACE 2
E3       DC    0F'0',X'42',A(ECB,0,0,E16,UT1,0,0),A(0,1)
E6       WTO   'DATA SET NOT FOUND',MF=L
E7       DC    XL140'0'
E9       WTO   L72' ',MF=L
E10      EQU   HEXTAB
E19      WTO   'DATA SET HAS NO EXTENTS',MF=L
E13      CCW   X'31',E3+35,X'40',5
         CCW   X'08',E13,0,0
         CCW   X'0E',E7,0,140
         SPACE 1
E16      CCW   X'31',E3+35,X'40',5
         CCW   X'08',E16,0,0
         CCW   X'06',E7,X'60',6
E22      CCW   X'29',JFCB,X'40',44
         CCW   X'08',E21,0,0
         CCW   X'06',E7,0,96       READ DATA.
E21      CCW   X'D1',E7+1,X'40',5  SCAN FOR INDEX HIGH.
         CCW   X'08',E22,0,0
         CCW   X'03',0,0,1
E4       EQU   *
         SPACE 1
E20      DC    256X'0'
         ORG   E20+C' '
         DC    X'1'
         TITLE 'RT5005M - COMMAND SCHEDULING CSECT - A.MORRISH.'
C        CSECT
         BALR  R11,R0              INITIALISE BASE REGISTER.
         USING *,R11               DEFINE BASE REGISTER.
         SPACE 1
*
*        CHECK VALIDITY.
*
         SPACE 1
         TM    SW,X'C0'            IS REMOTE CONSOLE ENABLED ?
         BCR   14,R9               IF NOT THEN RETURN.
         SPACE 1
*
*        FIND COMMAND.
*
         SPACE 1
         LA    R15,REP+2           SET GR15 FOR SCAN FOR COMMAND.
         LA    R14,1               SET GR14 = 1.
         CLI   0(R15),C' '         IS CHARACTER BLANK ?
         BNE   *+8                 IF NOT THEN FOUND.
         BXH   R15,R14,*-8         LOOP UNTIL COMMAND FOUND.
         SPACE 1
*
*        SCAN FOR END OF COMMAND.
*
         SPACE 1
         LA    R14,REP+79          SET GR14 -> END OF REPLY AREA.
         CLI   0(R14),C' '         IS CHARACTER BLANK ?
         BNE   *+8                 IF NOT THEN END FOUND.
         BCT   R14,*-8             LOOP UNTIL END FOUND.
         SPACE 1
*
*        SET UP COMMAND FOR CSCB.
*
         SPACE 1
         SR    R14,R15             SET GR14 = LENGTH FOR EXECUTE.
         BCR   4,R9                RETURN IF MINUS.
         EX    R14,C1              MOVE COMMAND TO CSCB.
         LA    R14,1(R14)          INCREMENT GR14 FOR COMMAND.LENGTH.
         STH   R14,C2              STORE LENGTH IN CSCB.
         SPACE 1
*
*        ISSUE COMMAND.
*
         SPACE 1
         LA    R1,C2               SET GR1 -> CSCB.
         SPMODE SUPV,0,MF=(E,SPML) ALLOW MGCR SVC.
         SVC   34                  ISSUE MGCR SVC.
         SPMODE PROB,*,MF=(E,SPML) RESTORE PROBLEM STATE AND USER KEY.
         SPACE 1
*
*        RETURN.
*
         SPACE 1
         B     REPEAT              GO TO RE-ISSUE WTOR.
         SPACE 2
C1       MVC   C2+4(0),0(R15)      MODEL STATEMENT.
         SPACE 2
C2       DC    H'82,0',CL78' '
         TITLE 'RT5005M - LOCATE A DATA SET CSECT - A.MORRISH.'
L        CSECT
         BALR  R11,R0              INITIALISE BASE REGISTER.
         USING *,R11               DFINE BASE REGISTER.
         SPACE 1
*
*        FIND DATA SET NAME.
*
         SPACE 1
         LA    R15,REP+2           SET GR15 FOR SCAN FOR DATA SET NAME.
         LA    R14,1               SET GR14 = 1.
         CLI   0(R15),C' '         IS CHARACTER BLANK ?
         BNE   *+8                 IF NOT THEN FOUND.
         BXH   R15,R14,*-8         LOOP UNTIL DATA SET FOUND.
         SPACE 1
*
*        FIND END OF NAME
*
         SPACE 1
         LA    R14,REP+79          SET GR14 -> END OF REPLY.
         SR    R14,R15             SET GR14 = LENGTH FOR SCAN.
         BCR   4,R9                IF NEGATIVE THEN NAME ABENT.
         LA    R1,REP+80           SET GR1 FOR NO DELIMITER.
         EX    R14,L1              SCAN TO FIND DELIMITER.
         SPACE 1
*
*        STORE NAME IN JFCB.
*
         SPACE 1
         SR    R1,R15              DECREMENT GR1 FOR MOVE.
         BCTR  R1,R0               DECREMENT GR1 FOR EXECUTE.
         MVC   JFCB(44),BLANKS     BLANK OUT NAME.
         EX    R1,L2               MOVE DSNAME TO JFCB.
         SPACE 1
*
*        ISSUE LOCATE
*
         SPACE 1
         GETMAIN R,LV=265          OBTAIN DYNAMIC AREA FOR LOCATE.
         ST    R1,L3+12            STORE ADDRESS FOR LOCATE.
         ST    R1,L18+12           STORE WORK A
         LA    R1,252(1)           SET GR1 -> CHAIN ADDRESS.
         ST    R1,L18+4            STORE ADDRESS FOR LOCATE.
         LOCATE L3                 LOCATE DATA SET.
         LTR   R15,R15             TEST RETURN CODE.
         BNZ   L4                  IF NOT ZERO THEN GO TO WRITE ERROR.
         SPACE 1
*
*        SET UP TO WRITE DEVICES.
*
         SPACE 1
         LA    R7,L5+4             SET GR7 -> FIRST OUTPUT LOCATION.
L19      LA    R3,20               SET GR3 = 20.
         L     R2,L3+12            SET GR2 -> DYNAMIC AREA.
         CH    R3,0(R2)            TEST FOR ADDITIONAL VOLUME CTL BLOCK
         BNH   *+8                 IF SO THEN USE 20.
         LH    R3,0(R2)            SET GR3 = NUMBER OF BLOCKS.
         LA    R2,2(R2)            SET GR2 -> FIRST BLOCK.
L16      MVI   0(R7),C'('          SET OPENING PARENTHESIS.
         CLI   2(R2),X'80'         IS DEVICE TAPE ?
         BNE   L6                  IF NOT THEN GO TO SET DASD.
         MVC   1(10,R7),L7         SET TYPE = 2400(7T-DC)
         LA    R7,5(R7)            INCREMENT GR7 OVER 2400.
         TM    0(R2),X'04'         IS PHASE ENCODING SPECIFIED ?
         BZ    L8                  IF NOT THEN GO TO TEST FOR 7-TRACK.
         MVC   1(5,R7),L9          SET 'PE-DD' IN TYPE.
         LA    R7,3(R7)            INCREMENT GR7 OVER PE.
         B     L10                 GO TO TEST FOR DD.
L8       TM    1(R2),X'80'         IS 7-TRACK SPECIFIED ?
         BZ    L11                 IF NOT THEN GO TO STORE SERIAL.
         LA    R7,3(R7)            INCREMENT GR7 OVER 7T.
L10      TM    1(R2),X'60'         TEST FOR DC/DD.
         BZ    *+8                 IF ABSENT THEN LEAVE R7.
         LA    R7,3(R7)            INCREMENT GR7 OVER DC/DD.
         MVI   0(R7),C')'          STORE CLOSING PARENTHESIS.
         LA    R7,1(R7)            INCREMENT GR7 OVER CLOSING PAREN.
L11      MVI   0(R7),C'-'          SET DELIMITER.
         MVC   1(6,R7),4(R2)       SET VOLUME SERIAL.
         LA    R7,7(R7)            SET GR7 BEYOND VOLUME SERIAL.
         OC    10(2,R2),10(R2)     TEST FOR DATA SET SEQUENCE NUMBER.
         BZ    L12                 IF NONE THEN GO TO STORE PARENTHESIS
         LH    R0,10(R2)           SET GR0 = SEQUENCE NUMBER.
         CVD   R0,DW               CONVERT TO DECIMAL.
         OI    DW+7,X'0F'          REMOVE ZONE.
         MVI   0(R7),C'-'          SET DELIMITER.
         LA    R7,1(R7)            SET GR7 FOR SEQUENCE NUMBER.
         UNPK  0(6,R7),DW          UNPACK.
         LR    R1,R7               SET GR1 -> SEQUENCE NUMBER.
         LA    R0,1                SET GR0 = 1.
         CLI   0(R1),C'0'          IS DIGIT ZERO ?
         BNE   *+8                 IF NOT THEN END FOUND
         BXH   R1,R0,*-8           LOOP UNTIL END FOUND.
         MVC   0(5,R7),0(R1)       LEFT JUSTIFY.
         SR    R1,R7               SET GR1 = OFFSET.
         LNR   R1,R1               MAKE NEGATIVE.
         LA    R7,6(R1,R7)         SET GR7 FOR STORE PARENTHESIS.
L12      MVI   0(R7),C')'          SET CLOSING PARENTHESIS.
         MVI   1(R7),C','          SET DELIMITER.
         LA    R7,2(R7)            SET GR7 FOR NEXT VOLUME SERIAL.
         LA    R0,L5+84            SET GR0 -> END OF WTO AREA.
         CR    R7,R0               COMPARE FOR FIT.
         BL    L13                 IF FIT THEN GO TO SET UP NEXT.
         LR    R0,R7               SET GR0 -> CURRENT LOCATION.
         S     R7,L14              DECREMENT GR7 FOR PREVIOUS DELIMITER
         CLI   0(R7),C','          COMPARE FOR DELIMITER.
         BE    *+8                 EXIT WHEN FOUND.
         BCT   R7,*-8              LOOP UNTIL FOUND.
         ST    R7,L15              STORE ADDRESS FOR NEXT MOVE.
         SR    R0,R7               SET GR0 = LENGTH.
         STC   R0,L15              STORE LENGTH FOR MOVE.
         LA    R1,L5               SET GR1 -> WTO.
         SR    R7,R1               SET GR7 = LENGTH FOR WTO.
         LA    R7,1(R7)            INCREMENT FOR COMMA.
         STH   R7,L5               STORE LENGTH IN WTO.
         BAL   R9,WTO              LINK TO WRITE TO OPERATOR.
         L     R7,L15              SET GR7 -> ADDRESS FOR MOVE.
         MVC   L5+4(26),1(R7)      STORE PARAMETER FOR NEXT WRITE.
         SR    R1,R1               SET GR1 = 0
         IC    R1,L15              SET GR1 = LENGTH.
         LA    R7,L5+3(R1)         SET GR7 FOR NEXT VOLUME.
L13      LA    R2,12(R2)           INCREMENT GR2 FOR NEXT.
         BCT   R3,L16              LOOP UNTIL BLOCK EXHAUSTED.
         L     R2,L3+12            SET GR2 -> VOLUME LIST BLOCK.
         LA    R3,20               SET GR3 = 20.
         CH    R3,2(R2)            COMPARE FOR LAST BLOCK.
         BNH   L17                 IF LAST THEN GO TO WRITE LAST.
         LOCATE L18                LOCATE NEXT BLOCK.
         LTR   R15,R15             TEST RETURN CODE.
         BZ    L19                 IF ZERO THEN GO TO PROCESS
L4       L     R1,L20-4(R15)       SET GR1 -> MESSAGE.
L21      BAL   R9,WTO              LINK TO WRITE TO OPERATOR.
         L     R1,L3+12            SET GR1 -> DYNAMIC AREA.
         FREEMAIN R,LV=265,A=(1)   RELEASE DYNAMIC AREA.
         B     REPEAT              GO TO RE-ISSUE WTOR.
         SPACE 1
*
*        SET UP FINAL WRITE AND EXIT.
*
         SPACE 1
L17      BCTR  R7,R0               DECREMENT GR7 FOR COMMA.
         LA    R1,L5               SET GR1 -> MESSAGE.
         SR    R7,R1               SET GR7 = LENGTH OF MESSAGE.
         STH   R7,L5               STORE LENGTH IN MESSAGE.
         B     L21                 GO TO WRITE TO OPERATOR.
         SPACE 1
*
*        TEST FOR DIRECT ACCESS DEVICE.
*
         SPACE 1
L6       CLI   2(R2),X'20'         IS DEVICE DASD ?
         BNE   L22                 IF NOT THEN GO TO SET ERROR.
         SR    R1,R1               SET GR1 = 0
         IC    R1,3(R2)            SET GR1 = DEVICE CODE.
         AR    R1,R1               DOUBLE FOR TWO CHARS.
         LA    R1,L23-2(R1)        SET GR1 -> DASD QUALIFIER.
         MVC   1(2,R7),L24         MOVE '23' TO OUTPUT AREA.
         MVC   3(2,R7),0(R1)       MOVE QUALIFIER TO OUTPUT AREA.
         LA    R7,5(R7)            SET GR7 OVER '23XX'
         B     L11                 GO TO STORE SERIAL NUMBER.
         SPACE 1
*
*        STORE UNKNOWN DEVICE TYPE.
*
         SPACE 1
L22      UNPK  1(9,R7),0(5,R2)     UNPACK TYPE CODE.
         TR    1(8,R7),HEXTAB      CONVERT TO READABLE FORMAT.
         LA    R7,9(R7)            SET GR7 OVER TYPE CODE.
         B     L11                 GO TO STORE SERIAL NUMBER.
         SPACE 2
L1       TRT   0(0,R15),L25        MODEL STATEMENT.
L2       MVC   JFCB(0),0(R15)      MODEL STATEMENT.
         EJECT
*        CONSTANTS AND WORK AREAS.
         SPACE 1
L3       CAMLST NAME,JFCB,,0
L18      CAMLST BLOCK,0,,0
L14      DC    F'14'
L15      DS    F
L20      DC    A(LX4,LX8,LX12,LX16,LX20,LX24,LX28,LX32)
L5       DC    H'84,0',CL80' ',CL26' '
L7       DC    C'2400(7T-DC'
L9       DC    C'PE-DD'
L23      DC    C'1101030221    14'
L24      DC    C'23'
L25      DC    256X'0'
         ORG   L25+C' '
         DC    X'1'
         ORG
         SPACE 1
LX4      WTO   '4 CONTROL VOLUME NOT MOUNTED',MF=L
LX8      WTO   '8 NAME NOT FOUND',MF=L
LX12     WTO   '12 NAME NOT DATA SET',MF=L
LX16     WTO   '16 DATA SET FOUND BEFORE NAME COMPLETED',MF=L
LX20     WTO   '20 SYNTAX ERROR',MF=L
LX24     WTO   '24 PERMANENT I/O ERROR',MF=L
LX28     WTO   '28 INVALID TTR',MF=L
LX32     WTO   '32 INVALID WORK AREA POINTER',MF=L
         TITLE 'RT5005M - SWITCH/MESSAGE TO OTHER CONSOLE - A.MORRISH.'
S        CSECT
         ENTRY M
M        BALR  R11,R0              INITIALISE BASE REGISTER.
         USING *,R11               DEFINE BASE REGISTER.
         SPACE 1
*
*        SCAN FOR ADDRESS.
*
         SPACE 1
         LA    R15,REP+2           SET GR15 TO START SCAN.
         LA    R14,1               SET GR14 = 1.
         CLI   0(R15),C' '         IS CHARACTER BLANK ?
         BNE   *+8                 IF NOT THEN FOUND.
         BXH   R15,R14,*-8         LOOP UNTIL FOUND.
         SPACE 1
*
*        TEST FOR VALID ADDRESS.
*
         SPACE 1
         MVC   S3+3(1),REP         SAVE COMMAND CODE.
         MVC   S3(2),CONSADDR      SAVE CURRENT CONSOLE ADDRESS.
         MVC   S3+2(1),SW          SAVE SWITCH.
         MVC   S3+4(4),MCSFLAGS    SAVE MCS FLAGS.
         LA    R14,REP+80          SET GR14 BEYOND REPLY.
         CR    R15,R14             TEST FOR OVER-SHOOT.
         BNL   S1                  IF OVERSHOOT THEN MUST BE 'S'.
         CLI   0(R15),C''''        IS FIRST CHARACTER A QUOTE ?
         BE    S2                  IF SO THEN MUST BE 'M'.
         CLI   0(R15),C'('         IS A GROUP OF ROUTE CODES SPEC'D ?
         BE    S10                 IF SO THEN GO TO SET ROUTE CODES.
         TRT   0(4,R15),VALIDHEX   TEST FOR VALID HEX CHARACTERS.
         BCR   7,R9                IF INVALID THEN RETURN.
         TR    0(4,R15),TRANS      CONVERT FOR PACK.
         PACK  CONSADDR(3),0(5,R15) STORE NEW CONSOLE ADDRESS.
         MVI   CONSADDR+2,X'E0'    RESTORE WRITE ERASE CODE.
         OI    SW,X'40'            SET CONSOLE ACTIVE.
         CLI   4(R15),C','         IS DELIMITER A COMMA ?
         BNE   S6                  IF NOT THEN GO TO SWITCH.
         LA    R15,5(R15)          SET GR15 -> DELIMITER.
S17      CLI   0(R15),C''''        IS DELIMITER A QUOTE ?
         BNE   S6                  IF NOT THEN GO TO SWITCH.
         SPACE 1
*
*        SET UP AND WRITE MESSAGE.
*
         SPACE 1
S12      LA    R2,S5+4             SET GR2 -> START OF WTO AREA.
S9       LA    R15,1(R15)          SET GR15 -> BEYOND QUOTE.
         LA    R14,REP+79          SET GR14 -> END OF REPLY AREA.
         SR    R14,R15             SET GR14 = LENGTH FOR SCAN.
         BM    S6                  SKIP MESSAGE IF MINUS.
         EX    R14,S7              SCAN FOR QUOTES.
         BZ    S6                  SKIP MESSAGE IF NONE FOUND.
         SR    R1,R15              SET GR1 = LENGTH FOR MOVE.
         EX    R1,S8               MOVE MESSAGE TO WTO AREA.
         LA    R2,1(R1,R2)         SET GR2 -> BEYOND QUOTES.
         LA    R15,1(R1,R15)       SET GR15 BEYOND QUOTES.
         CLI   0(R15),C''''        IS CHARACTER A DOUBLE QUOTE ?
         BE    S9                  IF SO THEN GO TO MOVE REMAINDER.
         BCTR  R2,R0               DECREMENT GR2 FOR QUOTE.
         LA    R1,S5               SET GR1 -> WTO AREA.
         SR    R2,R1               SET GR2 = LENGTH FOR WTO.
         STH   R2,S5               STORE LENGTH IN WTO.
         TM    SW,X'C0'            IS REMOTE CONSOLE ENABLED ?
         LA    R15,WTO             SET GR15 -> WTO ROUTINE.
         BNO   *+12                IF NOT THEN GO TO WTO.
         S     R1,S11              DECREMENT GR1 FOR WTOR.
         LA    R15,WTOR+4          SET GR15 TO FORCE WRITE TO CONSOLE.
         BALR  R9,R15              LINK TO WRITE TO OPERATOR.
         SPACE 1
*
*        RETURN.
*
         SPACE 1
S6       CLI   S3+3,C'M'           IS MESSAGE INTENDED ?
         BNE   REPEAT              IF NOT THEN MUST BE SWITCH.
         MVC   CONSADDR(2),S3      RESTORE CONSOLE ADDRESS.
         MVC   SW(1),S3+2          RESTORE SWITCH.
         MVC   MCSFLAGS(4),S3+4    RESTORE MCS FLAGS.
         B     REPEAT              GO TO RE-ISSUE WTOR
         SPACE 1
*
*        SET UP FOR SWITCH.
*
         SPACE 1
S1       NI    SW,X'BF'            SET REMOTE CONSOLE INACTIVE.
         B     S6                  GO TO SWITCH.
         SPACE 1
S2       NI    SW,X'BF'            SET REMOTE CONSOLE INACTIVE.
         B     S12                 GO TO SET UP MESSAGE.
         SPACE 2
S7       TRT   0(0,R15),S13        MODEL STATEMENT.
S8       MVC   0(0,R2),0(R15)      MODEL STATEMENT.
S15      PACK  DW,0(0,R15)         MODEL STATEMENT.
         SPACE 1                                                      *
*                                                                     *
*                                                                     *
*                                                                     *
         SPACE 1                                                      *
S10      NI    SW,X'BF'            SET OFF REMOTE CONSOLE ACTIVE.
         XC    MCSFLAGS,MCSFLAGS   CLEAR MCS INDICATORS.
         CLC   S4,0(R15)           IS BROADCAST SPECIFIED ?
         BE    S14                 IF SO THEN GO TO PROCESS.
S16      LA    R15,1(R15)          INCREMENT GR15 OVER COMMA.OR PAREN.
         LR    R1,R15              SET GR1 -> ROUTE CODE.
         LA    R0,1                SET GR0 = 1.
         TM    0(R1),X'F0'         IS CHARACTER NUMERIC ?
         BNO   *+8                 IF NOT THEN END FOUND.
         SR    R1,R15              SET GR1 = LENGTH FOR PACK.
         BZ    S6                  IF ZERO THEN ASSUME MASTER CONSOLE.
         BCTR  R1,R0               DECREMENT GR1 FOR EXECUTE.
         EX    R1,S15              PACK DIGIT(S) INTO DOUBLE WORD.
         CVB   R14,DW              CONVERT TO BINARY.
         LA    R0,X'100'           SET GR0 FOR SHIFT.
         SLL   R0,8                SHIFT READY FOR SHIFT RIGHT.
         SRL   R0,0(R14)           SHIFT RIGHT.
         O     R0,MCSFLAGS         SET ON BIT.
         ST    R0,MCSFLAGS         STORE NEW MCSFLAGS.
         LA    R15,1(R1,R15)       SET GR15 -> DELIMITER.
         CLI   0(R15),C','         IS DELIMITER A COMMA ?
         BE    S16                 IF SO THEN GO TO SET UP NEXT.
         CLI   0(R15),C')'         IS DELIMITER A CLOSING PAREN ?
         BNE   *+8                 IF NOT THEN MAY BE IMMEDIATE QUOTE.
         LA    R15,1(R15)          INCREMENT GR15 OVER QUOTES.
         NI    MCSFLAGS+1,X'FE'    REMOVE BIT LEFT BY ROUTE CODE 0.
         OC    MCSFLAGS+2(2),MCSFLAGS+2 ANY VALID ROUTE CODES ?
         BZ    S17                 IF NOT THEN GO TO TEST FOR MESSAGE.
         OI    MCSFLAGS,X'80'      SET ON ROUTE CODES PRESENT.
         B     S17                 GO TO TEST FOR MESSAGE.
S14      OI    MCSFLAGS,X'04'      SET ON BROADCAST FLAG.
         LA    R15,L'S4(R15)       SET GR15 -> START OF MESSAGE.
         B     S17                 GO TO TEST FOR MESSAGE.
         EJECT                                                        *
         SPACE 1                                                      *
*                                                                     *
*        CONSTANTS AND WORK AREAS.                                    *
*                                                                     *
         SPACE 1                                                      *
S3       DC    XL8'0'
S11      DC    F'4'
S5       DC    H'82,0',CL78' '
S13      DC    256X'0'
         ORG   S13+C''''
         DC    X'1'
         ORG
S4       DC    C'(BRDCST)'
         TITLE 'RT5005M - UCB LIST CSECT - A.MORRISH.'
U        CSECT
         BALR  R11,R0              INITIALISE BASE REGISTER.
         USING *,R11               DEFINE BASE REGISTER.
         SPACE 1
*
*        TEST FOR UNIT OR SERIAL NUMBER
*
         SPACE 1
         LA    R15,REP+2           SET GR15 TO START SCAN.
         LA    R14,1               SET GR14 = 1.
         CLI   0(R15),C' '         IS CHARACTER BLANK ?
         BNE   *+8                 EXIT WHEN FOUND.
         BXH   R15,R14,*-8         LOOP UNTIL END FOUND.
         SPACE 1
*
*        TEST FOR VALID UCB OR SERIAL NUMBER.
*
         SPACE 1
         LA    R14,REP+77          SET GR14 -> END OF REPLY AREA.
         SR    R14,R15             SET GR14 = RESIDUAL LENGTH.
         BM    U1                  IF MINUS THEN GO TO LIST ALL UCBS.
         LA    R0,3                SET GR0 = 3.
         CR    R14,R0              COMPARE FOR FIT.
         BL    U2                  IF LESS THEN MUST BE ADDRESS.
         CLI   3(R15),C' '         IS FOURTH CHARACTER BLANK ?
         BE    U2                  IF SO THEN MUST BE ADDRESS.
         CLI   3(R15),C'/'         IS FOURTH CHARACTER A SLASH ?
         BE    U2                  IF SO THEN MUST BE ADDRESS.
         SPACE 1
*
*        SCAN FOR VOLUME SERIAL.
*
         SPACE 1
         L     R1,16               SET GR1 -> CVT.
         L     R1,40(R1)           SET GR1 -> UCB LOOK-UP TABLE.
U8       LH    R2,0(R1)            SET GR2 -> UCB
         LTR   R2,R2               TEST SIGN OF GR2
         BM    U3                  IF MINUS THEN SERIAL NOT FOUND.
         BZ    U4                  IF ZERO THEN GAP IN TABLE.
         CLI   18(R2),X'80'        IS DEVICE TAPE DRIVE ?
         BE    U5                  IF SO THEN GO TO TEST.
         CLI   18(R2),X'20'        IS DEVICE DASD ?
         BNE   U4                  IF NOT THEN SKIP TEST.
         CLI   19(R2),X'05'        IS DEVICE DATA CELL ?
         BE    U6                  IF SO THEN GO TO SPECIAL SCAN.
U5       CLC   0(6,R15),28(R2)     TEST FOR SERIAL NUMBER.
         BE    U7                  IF FOUND THEN GO TO PROCESS.
U4       LA    R1,2(R1)            SET GR1 -> NEXT TABLE ENTRY.
         B     U8                  GO TO TEST NEXT TABLE ENTRY.
         SPACE 1
*
*        SPECIAL SCAN FOR 2321.
*
         SPACE 1
U6       LA    R0,10               SET GR0 = NUMBER OF SUB-CELLS.
         LA    R3,56(R2)           SET GR3 -> FIRST SUB-CELL.
         CLC   0(6,R15),4(R3)      TEST FOR SERIAL NUMBER.
         BE    U9                  IF FOUND THEN GO TO SET UP ADDRESS.
         LA    R3,16(R3)           SET GR3 -> NEXT SUB-CELL.
         BCT   R0,*-14             LOOP UNTIL SUB-CELLS EXHAUSTED.
         B     U4                  GO TO TEST NEXT UCB.
         SPACE 1
*
*        WRITE TO OPERATOR.
*
         SPACE 1
U3       LA    R1,U10              SET GR1 -> SERIAL NOT FOUND MESSAGE.
U31      BAL   R9,WTO              LINK TO WRITE TO OPERATOR.
         B     REPEAT              GO TO RE-ISSUE WTOR.
         SPACE 1
*
*        FIND UCB FROM ADDRESS SPECIFIED.
*
         SPACE 1
U2       LR    R3,R15              SAVE POINTER TO REPLY.
         FINDUCB DEVADDR=0(R3),TO=(R2),VALID=YES
         LTR   R15,R15             TEST RETURN CODE.
         BNZ   U11                 IF NON-ZERO THEN GO TO WRITE NONE.
         CLI   18(R2),X'20'        IS DEVICE DASD ?
         BNE   U7                  IF NOT THEN NOT CELL.
         CLI   19(R2),X'05'        IS DEVICE A DATA CELL ?
         BNE   U7                  IF NOT THEN GO TO NORMAL PROCESS.
         IC    R3,4(R2)            SET GR3 = SUB-CELL NUMBER.
         N     R3,U12              REMOVE ZONE.
         SLL   R3,4                MULTIPLY BY 16.
         LA    R3,56(R3,R2)        SET GR3 -> SUB-CELL.
         SPACE 1
*
*        SET UP MESSAGE FOR DATA CELL.
*
         SPACE 1
U9       MVC   U13+4(3),13(R2)     STORE ADDRESS IN MESSAGE.
         MVC   U13+7(8),U14        STORE '10 2321 ' IN MESSAGE.
         LH    R1,0(R3)            SET GR1 = BIN NUMBER.
         LA    R1,240(R1)          SET ZONE.
         STC   R1,U13+8            STORE BIN NUMBER.
         MVC   U13+15(85),U13+14   BLANK OUT REPLY AREA.
         MVC   U13+15(6),4(R3)     STORE VOLUME SERIAL.
         MVC   U15(2),2(R3)        SAVE STATUS BYTES.
         MVC   U15+2(1),11(R3)     SAVE NUMBER OF DCBS.
         LA    R15,U13+22          SET GR15 -> FIRST LOCATION FOR MSG.
         B     U16                 GO TO SET UP REMAINDER AS DASD.
         SPACE 1
*
*        SET UP FOR NON-DATA CELL.
*
         SPACE 1
U7       MVI   U13+7,C' '          BLANK OUT FIRST BYTE BEYOND ADDRESS.
         MVC   U13+8(92),U13+7     CLEAR MESSAGE AREA.
         MVC   U13+4(3),13(R2)     STORE ADDRESS IN MESSAGE.
         TM    18(R2),X'20'+X'80'  TEST FOR TAPE OR DASD.
         BZ    U17                 IF NONE THEN SKIP SERIAL.
         MVC   U13+13(6),28(R2)    STORE VOLUME SERIAL.
         MVC   U13+8(4),U18        STORE '2400' IN MESSAGE.
         CLI   18(R2),X'80'        IS DEVICE TAPE ?
         BE    U19                 IF SO THEN GO TO SET UP ON/OFF LINE.
         MVI   U13+9,C'3'          SET '2300' IN MESSAGE.
         SR    R1,R1               SET GR1 = 0.
         IC    R1,19(R2)           SET GR1 = TYPE CODE.
         AR    R1,R1               DOUBLE CODE.
         LA    R1,U20-2(R1)        SET GR1 -> CHARACTER CODE.
         MVC   U13+10(2),0(R1)     STORE TYPE CODE.
         B     U19                 GO TO SET UP ON/OFF LINE.
         SPACE 1
*
*        FIND DEVICE TYPE IF NOT TAPE OR DASD.
*
         SPACE 1
U17      LA    R1,U21              SET GR1 -> TYPE TABLE
         LA    R15,U22             SET GR15 -> END OF TABLE.
         LA    R14,7               SET GR14 = 7.
         CLC   18(2,R2),0(R1)      COMPARE FOR TYPE.
         BE    *+8                 EXIT WHEN FOUND.
         BXLE  R1,R14,*-10         LOOP UNTIL FOUND.
         MVC   U13+8(5),2(R1)      STORE DEVICE TYPE.
         SPACE 1
*
*        SET UP FOR ONLINE/OFFLINE.
*
         SPACE 1
U19      MVC   U15(1),34(R2)       STORE STATUS BYTE B.
         MVC   U15+1(1),3(R2)      STORE STATUS BYTE A.
         MVC   U15+2(1),35(R2)     STORE NUMBER OF DATA SETS.
         LA    R15,U13+20          SET GR15 -> FIRST LOCATION FOR MSG.
         SPACE 1
*
*        SET UP REMAINDER OF MESSAGE.
*
         SPACE 1
U16      SR    R3,R3               SET GR3 = 0.
         LA    R1,U23              SET GR1 -> TABLE OF MESSAGES.
         LA    R14,U15+1           SET GR14-> STATUS BYTE A.
U28      CLI   0(R1),X'FF'         IS IT END OF TABLE ?
         BE    U24                 IF SO THEN EXIT.
         IC    R3,0(R1)            SET GR3 = CODE.
         EX    R3,U25              TEST FOR ADDITION TO MESSAGE.
         BZ    U27                 IF NOT THEN SKIP.
         L     R4,0(R1)            SET GR4 -> MESSAGE.
         IC    R3,0(R4)            SET GR3 = LENGTH OF MESSAGE.
         EX    R3,U26              MOVE ADDITION TO MESSAGE.
         AR    R15,R3              INCREMENT GR15 FOR COMMA.
         MVI   0(R15),C','         SET DELIMITER.
         LA    R15,1(R15)          INCREMENT GR15 FOR NEXT.
U27      LA    R1,4(R1)            INCREMENT GR1 FOR NEXT TEST.
         B     U28                 GO TO SET UP NEXT ENTRY.
         SPACE 1
*
*        END OF TABLE PROCESSING.
*
         SPACE 1
U24      CLI   18(R2),X'20'        IS DEVICE DASD ?
         BNE   U29                 IF NOT THEN END.
         LA    R1,U30              SET GR1 -> TABLE OF MESSAGES.
         LA    R0,U15              SET GR0 -> STATUS BYTE B.
         CR    R0,R14              COMPARE FOR SECOND ENTRY.
         BE    U29                 IF SECOND ENTRY THEN END.
         LR    R14,R0              SET GR14 -> STATUS BYTE B.
         B     U28                 GO TO PROCESS STATUS B.
         SPACE 1
*
*        WRITE MESSAGE.
*
         SPACE 1
U29      BCTR  R15,R0              DECREMENT GR15 FOR FINAL COMMA.
         LA    R1,U13              SET GR1 -> WTO.
         SR    R15,R1              SET GR15 = LENGTH.
         STH   R15,U13             STORE LENGTH IN WTO.
         B     U31                 GO TO WRITE TO OPERATOR.
         SPACE 1
*
*        WRITE ADDRESS NOT FOUND.
*
         SPACE 1
U11      LA    R1,U32              SET GR1 -> INVALID ADDRESS MESSAGE.
         B     U31                 GO TO WRITE TO OPERATOR.
         EJECT
*
*        LIST ALL DEVICES.
*
         SPACE 1
U1       L     R1,16               SET GR1 -> CVT.
         LA    R15,U13+4           SET GR15 -> WTO AREA.
         L     R2,40(R1)           SET GR2 -> UCB LOOK-UP TABLE.
U38      LH    R3,0(R2)            SET GR3 -> UCB.
         LTR   R3,R3               TEST SIGN OF GR3.
         BM    U33                 IF MINUS THEN END FOUND.
         BZ    U34                 IF ZERO THEN GAP IN TABLE.
         TM    3(R3),X'24'         IS DEVICE RESERVED OR P/R ?
         BZ    *+12                IF NOT THEN LEAVE.
         MVI   0(R15),C'*'         SET INDICATOR.
         LA    R15,1(R15)          INCREMENT GR15 OVER INDICATOR.
         MVC   0(3,R15),13(R3)     STORE ADDRESS IN TABLE.
         MVI   3(R15),C'-'         SET DELIMITER.
         SPACE 1
*
*        SET UP DEVICE TYPE.
*
         SPACE 1
         MVC   4(4,R15),U18        STORE DEVICE TYPE = 2400.
         CLI   18(R3),X'80'        IS DEVICE TYPE TAPE ?
         BE    U35                 IF SO THEN GO TO SET UP END.
         CLI   18(R3),X'20'        IS DEVICE TYPE DASD ?
         BNE   U36                 IF NOT THEN GO TO SCAN FOR TYPE.
         MVI   5(R15),C'3'         SET DEVICE TYPE = 2300.
         SR    R1,R1               SET GR1 = 0.
         IC    R1,19(R3)           SET GR1 = DEVICE CODE.
         AR    R1,R1               DOUBLE CODE.
         LA    R1,U20-2(R1)        SET GR1 -> DEVICE TYPE SUFFIX.
         MVC   6(2,R15),0(R1)      STORE DEVICE TYPE.
         CLI   19(R3),X'05'        IS DEVICE 2321 ?
         BE    U37                 IF SO THEN SKIP VOLUME SERIAL.
U35      CLI   28(R3),0            IS VOLUME MOUNTED ?
         BE    U37                 IF NOT THEN NO UPDATE.
         MVI   8(R15),C'-'         SET DELIMITER.
         MVC   9(6,R15),28(R3)     STORE VOLUME SERIAL.
         LA    R15,7(R15)          INCREMENT GR15 FOR VOLUME SERIAL.
         B     U37                 GO TO STORE COMMA.
         SPACE 1
*
*        FIND DEVICE TYPE FOR NON TAPE OR DASD.
*
         SPACE 1
U36      LA    R1,U21              SET GR1 -> TYPE TABLE.
         LR    R9,R15              SAVE GR15.
         LA    R15,U22             SET GR15 -> END OF TABLE.
         LA    R14,7               SET GR14 = 7
         CLC   18(2,R3),0(R1)      COMPARE FOR TYPE.
         BE    *+8                 EXIT WHEN FOUND.
         BXLE  R1,R14,*-10         LOOP UNTIL FOUND.
         LR    R15,R9              RESTORE GR15.
         MVC   4(5,R15),2(R1)      STORE DEVICE TYPE.
         CLI   8(R15),C' '         IS LAST CHARACTER BLANK ?
         BE    U37                 IF SO THEN GO TO STORE COMMA.
         LA    R15,1(R15)          INCREMENT GR1 FOR LAST CHARACTER.
         SPACE 1
*
*        STORE COMMA AND TEST FOR END.
*
         SPACE 1
U37      MVI   8(R15),C','         STORE COMMA.
         LA    R15,9(R15)          INCREMENT GR15 OVER COMMA.
         LA    R0,U13+69           SET GR0 -> LIMIT FOR NEXT.
         CR    R15,R0              COMPARE FOR FIT.
         BL    U34                 IF FIT THEN GO TO SET UP NEXT.
         BCTR  R15,R0              DECREMENT GR15 FOR WRITE.
         LA    R1,U13              SET GR1 -> WTO.
         SR    R15,R1              SET GR15 = LENGTH FOR WTO.
         STH   R15,U13             STORE LENGTH IN WTO.
         BAL   R9,WTO              LINK TO WRITE TO OPERATOR.
         LA    R15,U13+4           SET GR15 FOR NEXT.
U34      LA    R2,2(R2)            SET GR2 -> NEXT TABLE ENTRY.
         B     U38                 GO TO TEST NEXT.
         SPACE 1
*
*        WRITE LAST LINE.
*
         SPACE 1
U33      LA    R0,U13+4            SET GR0 TO TEST FOR START.
         CR    R15,R0              TEST FOR NULL LINE.
         BE    REPEAT              IF NULL THEN NO WTOR.
         B     U29                 GO TO WRITE LAST WTO.
         SPACE 2
U25      TM    0(R14),0            MODEL STATEMENT.
U26      MVC   0(0,R15),1(R4)      MODEL STATEMENT.
         EJECT
*
*        CONSTANTS AND WORK AREAS.
*
         SPACE 1
U10      WTO   'SERIAL NUMBER NOT FOUND',MF=L
U13      DC    H'100,0',CL96' '
U32      EQU   WTOR3+8
U12      DC    F'15'
U14      DC    C'10 2321 '
U15      DS    3X
U18      DC    C'2400'
U20      DC    C'1101030221000014'
         SPACE 2
U21      DC    X'0801',C'2540R'
         DC    X'0802',C'2540P'
         DC    X'0803',C'1442 '
         DC    X'0804',C'2501 '
         DC    X'0805',C'2520 '
         DC    X'0808',C'1403 '
         DC    X'0810',C'2671 '
         DC    X'080A',C'1443 '
         DC    X'0820',C'1052 '
         DC    X'0821',C'2150 '
         DC    X'1002',C'2250 '
         DC    X'1003',C'2260 '
         DC    X'1004',C'1053 '
         DC    X'1005',C'2280 '
         DC    X'1006',C'2282 '
         DC    X'1007',C'85CNS'
         DC    X'4001',C'2702 '
         DC    X'4002',C'2701 '
         DC    X'4082',C'2701 '
         DC    X'4003',C'2703 '
         DC    X'4013',C'2703 '
U22      EQU   *-1
         DC    X'0000',C'**** '
         SPACE 2
U23      DS    0A
         DC    X'80',AL3(U39)
         DC    X'40',AL3(U40)
         DC    X'20',AL3(U41)
         DC    X'10',AL3(U42)
         DC    X'08',AL3(U43)
         DC    X'04',AL3(U44)
         DC    X'02',AL3(U45)
         DC    X'FF',AL3(0)
U30      DS    0A
         DC    X'10',AL3(U46)
         DC    X'08',AL3(U47)
         DC    X'04',AL3(U48)
         DC    X'02',AL3(U49)
         DC    X'01',AL3(U50),X'FF'
         SPACE 2
U39      DC    AL1(6),C'ONLINE'
U40      DC    AL1(8),C'*OFFLINE'
U41      DC    AL1(3),C'RSV'
U42      DC    AL1(7),C'*UNLOAD'
U43      DC    AL1(5),C'ALLOC'
U44      DC    AL1(2),C'PR'
U45      DC    AL1(11),C'SRV/CONSOLE'
U46      DC    AL1(7),C'PRIVATE'
U47      DC    AL1(6),C'PUBLIC'
U48      DC    AL1(7),C'STORAGE'
U49      DC    AL1(6),C'JOBLIB'
U50      DC    AL1(4),C'CVOL'
         TITLE 'RT5005M - CATALOG LIST CSECT - A.MORRISH.'
K        CSECT
         BALR  R11,R0              INITIALISE BASE REGISTER.
         USING *,R11               DEFINE BASE REGISTER.
         L     R1,16               SET GR1 -> CVT.
         L     R2,48(R1)           SET GR2 -> SYSRES VOLUME UCB.
         L     R15,TIOTPTR         SET GR15 -> TIOT ENTRY FOR WORK.
         LH    R3,18(R15)          SET GR3 -> CIRRENT UCB.
         STH   R3,K68              SAVE CURRENT UCB.
         SPACE 1                                                      *
*                                                                     *
*        FIND DEVICE AND NODE (IF SPECIFIED) AND MOVE TO OUTPUT AREA. *
*                                                                     *
         SPACE 1                                                      *
         LA    R15,REP+2           SET GR15 FOR SCAN FOR NODE.
K91      LA    R14,1               SET GR14 = 1.
         CLI   0(R15),C' '         IS CHARACTER BLANK ?
         BNE   *+8                 IF NOT THEN DEVICE OR NODE FOUND.
         BXH   R15,R14,*-8         LOOP UNTIL DEVICE OR NODE FOUND.
         MVC   K1+4(80),BLANKS     CLEAR OUTPUT AREA.
         LA    R14,REP+79          SET GR14 FOR SUBTRACT.
         SR    R14,R15             SET GR14 = LENGTH FOR SCAN.
         BM    K2                  IF MINUS THEN NO NODE SPECIFIED.
         TM    0(R15),X'F0'        IS FIRST CHARACTER NUMERIC ?
         BNO   K72                 IF NOT THEN MUST BE NODE.
         SPACE 1                                                      *
*                                                                     *
*        TEST FOR VALID UCB OR SERIAL NUMBER.                         *
*                                                                     *
         SPACE 1                                                      *
         TM    3(R15),X'80'        IS FOURTH CHARACTER A DELIMITER ?
         BZ    K82                 IF SO THEN MUST BE ADDRESS.
         L     R1,16               SET GR1 -> CVT.
         L     R1,40(R1)           SET GR1 -> UCB LOOK-UP TABLE.
K87      LH    R2,0(R1)            SET GR2 -> UCB.
         LTR   R2,R2               TEST SIGN OF GR2.
         BM    K83                 IF MINUS THEN SERIAL NOT FOUND.
         BZ    K84                 IF ZERO THEN GAP IN TABLE.
         CLI   18(R2),X'20'        IS DEVICE A DASD ?
         BNE   K84                 IF NOT THEN SKIP TEST.
         CLI   19(R2),X'05'        IS DEVICE A DATA CELL ?
         BE    K85                 IF SO THEN GO TO SPECIAL ROUTINE.
         CLC   0(6,R15),28(R2)     TEST FOR SERIAL NUMBER.
         BE    K86                 IF FOUND THEN GO TO PROCESS.
K84      LA    R1,2(R1)            SET GR1 -> NEXT TABLE ENTRY.
         B     K87                 GO TO TEST NEXT TABLE ENTRY.
K86      LA    R4,3(R15)           SET GR45TO CONTINUE SCAN.
         B     K90                 GO TO TEST FOR NODE.
         SPACE 1                                                      *
*                                                                     *
*        SPECIAL SCAN FOR 2321                                        *
*                                                                     *
         SPACE 1                                                      *
K85      LA    R0,10               SET GR0 = NUMBER OF SUB-CELLS.
         LA    R2,56(R2)           SET GR2 -> FIRST SUB-CELL.
         CLC   0(6,R15),4(R2)      TEST FOR SERIAL NUMBER.
         BE    K86                 IF FOUND THEN GO TO PROCESS.
         LA    R2,16(R2)           SET GR2 -> NEXT SUB-CELL.
         BCT   R0,*-14             LOOP UNTIL SUB-CELLS EXHAUSTED.
         B     K84                 GO TO TEST NEXT TABLE ENTRY.
         SPACE 1                                                      *
*                                                                     *
*        WRITE TO OPERATOR.                                           *
*                                                                     *
         SPACE 1                                                      *
K83      LA    R1,K88              SET GR1 -> DEVICE NOT MOUNTED MSG.
K93      BAL   R9,WTO              LINK TO WRITE TO OPERATOR.
         B     K97                 GO TO RESTORE UCB ADDRESS.
         SPACE 1                                                      *
*                                                                     *
*        FIND UCB FROM ADDRESS SPECIFIED.                             *
*                                                                     *
         SPACE 1                                                      *
K82      LR    R4,R15              SAVE POINTER TO REPLY.
         FINDUCB DEVADDR=0(R4),TO=(R2),VALID=YES
         LTR   R15,R15             TEST RETURN CODE.
         BNZ   K89                 IF NON-ZERO THEN GO TO WRITE MESSAGE
         CLI   18(R2),X'20'        IS DEVICE A DASD ?
         BNE   K89                 IF NOT THEN GO TO WRITE MESSAGE.
         CLI   19(R2),X'05'        IS DEVICE A DATA CELL ?
         BNE   K90                 IF NOT THEN LEAVE.
         IC    R1,4(R4)            SET GR1 = SUB-CELL NUMBER.
         CLI   3(R4),C'/'          IS SUB-CELL NUMBER VALID ?
         BE    *+10                IF SO THEN LEAVE.
         SR    R1,R1               SET DEFAULT SUB-CELL = 0.
         BCTR  R4,R0              ) DECREMENT GR4 FOR MISSING SUB-CELL.
         BCTR  R4,R0              )
         LA    R0,15               SET GR0 = 15.
         NR    R1,R0               REMOVE ZONE.
         SLL   R1,4                SHIFT GR1 TO MULTIPLY BY 16
         LA    R2,56(R1,R2)        SET GR2 -> SUB-CELL.
         LA    R4,2(R4)            INCREMENT GR15 FOR SUB-CELL NUMBER.
K90      LA    R15,4(R4)           INCREMENT GR15 FOR NODE.
         CLI   3(R4),C','          IS A DELIMITER SPECIFIED ?
         BE    K91                 IF SO THEN GO TO SCAN FOR NODE.
         B     K2                  GO TO PROCESS FULL CATALOG.
K89      LA    R1,K92              SET GR1 -> MESSAGE.
         B     K93                 GO TO WRITE TO OPERATOR.
         SPACE 1                                                      *
*                                                                     *
*        SET UP NODE.                                                 *
*                                                                     *
         SPACE 1                                                      *
K72      LA    R1,REP+80           SET GR1 FOR TRT FAIL.
         LR    R4,R2               SAVE GR2 THROUGH TRT.
         EX    R14,K3              SCAN FOR BLANK
         LR    R2,R4               RESTORE GR2.
         SR    R1,R15              SET GR1 = LENGTH FOR MOVE.
         BCTR  R1,R0               DECREMENT GR1 FOR EXECUTE.
         EX    R1,K5               MOVE NAME INTO WTO AREA.
         SPACE 1
*
*        OPEN SYSCTLG DATA SET.
*
         SPACE 1
K2       L     R15,TIOTPTR         SET GR1 -> UT1 TIOT ENTRY.
         SPMODE PROB,0,MF=(E,SPML) ALLOW UPDATE TO TIOT FOR MVT.
         STH   R2,18(R15)          STORE UCB ADDRESS IN TIOT DD ENTRY.
         SPMODE PROB,*,MF=(E,SPML) RESTORE USER PROTECT KEY.
         MVC   JFCB(L'K6),K6       STORE NAME 'SYSCTLG' IN JFCB.
         MVC   JFCB+L'K6(44-L'K6),BLANKS CLEAR REMAINING CHARACTERS.
         MVC   JFCB+118(6),28(R2)  STORE VOLUME SERIAL NUMBER IN JFCB.
         GETMAIN R,LV=350          OBTAIN DYNAMIC WORK SPACE.
         ST    R1,K94+12           STORE ADDRESS OF DYNAMIC WORK SPACE.
         OBTAIN K94                SEARCH FOR SYSCTLG DATA SET.
         LR    R2,R15              SAVE RETURN CODE.
         L     R1,K94+12           SET GR1 -> DYNAMIC WORK SPACE.
         FREEMAIN R,LV=350,A=(R1)  RELEASE DYNAMIC WORK SPACE.
         LTR   R15,R2              TEST RETURN CODE.
         BNZ   K95                 IF NOT ZERO THEN ERROR
         OPEN  MF=(E,K7),TYPE=J    OPEN SYSCTLG DATA SET.
         L     R1,K8+44            SET GR1 -> DEB.
         MVC   K9+33(6),36(R1)     STORE DATA SET START ADDRESS.
         MVI   K9+39,1             STORE RECORD NUMBER ONE.
         SPACE 1
*
*        START SCAN THROUGH BLOCK.
*
         SPACE 1
         LA    R2,K10              SET GR2 -> FIXED DATA AREA
         USING K10,R2              DEFINE BASE FOR DATA AREA.
         LA    R8,K1+4             SET GR8 FOR START OF SCAN.
K37      ST    R2,K11              STORE ADDRESS IN READ CCW.
         MVI   K11,X'06'           RESTORE OP CODE IN READ CCW.
         EXCP  K9                  READ INDEX BLOCK.
         WAIT  1,ECB=ECB           WAIT FOR COMPLETION.
         CLI   ECB,X'7F'           IS COMPLETION NORMAL ?
         BNE   K12                 IF NOT THEN ERROR.
         TM    K13,X'80'           IS BLOCK A VOLUME CONTROL BLOCK ?
         BO    K14                 IF SO THEN GO TO PROCESS VCB.
         SPACE 1
*
*        SCAN THROUGH BLOCK.
*
         SPACE 1
         LA    R3,K10+2            SET GR3 -> FIRST ENTRY IN BLOCK.
K27      TM    0(R3),X'FF'         TEST FOR INDEX CONTROL/LINK ENTRY.
         BZ    K15                 GO TO IGNORE INDEX CONTROL BLOCK.
         BO    K16                 GO TO PROCESS INDEX LINK BLOCK.
         TM    K13,X'40'           IS NAME FOR GDG ?
         BZ    *+10                IF NOT THEN LEAVE NAME.
         XC    1(4,R3),K17         COMPLEMENT FOR PRINT.
         CLI   0(R8),C' '          IS NAME PRESENT ?
         BNE   K18                 IF SO THEN GO TO COMPARE FOR NODE.
         SPACE 1
*
*        ANALYZE ENTRY TYPE.
*
         SPACE 1
K62      CLI   11(R3),5            TEST FOR DATA SET POINTER.
         BH    K19                 IF SO THEN GO TO PROCESS DSP.
         SR    R15,R15             SET GR15 = 0.
         IC    R15,11(R3)          SET GR15 = TYPE CODE.
         SLL   R15,2               MULTIPLY BY 4.
         B     *+4(R15)            GO TO ROUTINE FOR ENTRY TYPE.
         B     K20                 GO TO INDEX POINTER ROUTINE.
         B     K21                 GO TO VOLUME CONTROL BLOCK PTR RTN.
         B     K22                 GO TO GENERATION INDEX POINTER RTN.
         B     K15                 GO TO IGNORE INDEX CONTROL ENTRY.
         B     K23                 GO TO ALIAS ROUTINE.
         SPACE 1
*
*        CVOL POINTER ROUTINE.
*
         SPACE 1
         MVC   0(8,R8),0(R3)       STORE NAME IN MESSAGE.
         LA    R4,12(R3)           SET GR4 -> DEVICE CODE.
         BAL   R9,K24              LINK TO DECODE DEVICE TYPE.
         MVC   K1+58(6),16(R3)     STORE VOLUME SERIAL NUMBER IN MSG.
         MVC   K1+43(4),K25        STORE 'CVOL' IN MESSAGE.
         SPACE 1
*
*        WRITE TO OPERATOR.
*
         SPACE 1
K29      BAL   R9,K26              LINK TO WRITE TO OPERATOR.
         SPACE 1
*
*        RESET WTO AREA FOR NEXT ENTRY.
*
         SPACE 1
         BAL   R9,K65              LINK TO BACKSPACE NAME.
         SPACE 1
*
*        INDEX TO NEXT ENTRY.
*
         SPACE 1
K15      SR    R15,R15             SET GR15 = 0.
         IC    R15,11(R3)          SET GR15 = LENGTH CODE OF BLOCK
         LA    R15,12(R15,R15)     SET GR15 = LENGTH OF ENTRY.
         AR    R3,R15              SET GR3 -> NEXT ENTRY.
         B     K27                 GO TO PROCESS NEXT ENTRY.
         SPACE 1
*
*        ALIAS ROUTINE.
*
         SPACE 1
K23      MVC   K1+43(5),K28        STORE 'ALIAS' IN MESSAGE.
         MVC   K1+57(8),12(R3)     STORE PRIMARY NAME IN MESSAGE.
         B     K29                 GO TO WRITE MESSAGE.
         SPACE 1
*
*        GENERATION INDEX POINTER ROUTINE.
*
         SPACE 1
K22      MVC   K1+79(3),K30        STORE MASK IN MESSAGE.
         SR    R0,R0               SET GR0 = 0.
         IC    R0,13(R3)           SET GR0 = NUMBER OF ENTRIES.
         CVD   R0,DW               CONVERT TO DECIMAL.
         ED    K1+78(4),DW+6       EDIT TO MESSAGE.
         MVC   K1+76(3),K31        STORE 'GDG' IN MESSAGE.
         TM    12(R3),X'01'        IS 'EMPTY' SPECIFIED ?
         BZ    *+8                 IF NOT THEN LEAVE.
         MVI   K1+82,C'E'          STORE 'EMPTY' INDICATOR IN MESSAGE.
         TM    12(R3),X'02'        IS 'DELETE' SPECIFIED ?
         BZ    *+8                 IF NOT THEN LEAVE.
         MVI   K1+83,C'D'          STORE 'DELETE' INDICATOR IN WTO.
         OI    K13,X'40'           SET ON GDG PRESENT SWITCH.
         DS    0H                  DROP THROUGH INTO INDEX POINTER RTN.
         SPACE 1
*
*        INDEX POINTER ROUTINE.
*
         SPACE 1
K20      OI    K13,X'20'           SET ON INDEX PRESENT SWITCH.
         CLI   0(R8),C' '          IS THIS SEARCH FOR NODE ?
         BNE   K32                 IF SO THEN GO TO UPDATE GR8.
         MVC   0(8,R8),0(R3)       STORE NAME IN WTO.
         LA    R8,7(R8) ,          SET GR8 -> END OF NEW NAME LEVEL.
         CLI   0(R8),C' '          IS CHARACTER BLANK ?
         BNE   *+8                 IF NOT THEN END FOUND.
         BCT   R8,*-8              LOOP UNTIL END FOUND.
         MVI   1(R8),C'.'          STORE DELIMITER.
         LA    R8,2(R8)            SET GR8 FOR NEXT INDEX LEVEL.
         SPACE 1
*
*        OBTAIN NEW BLOCK FOR READ.
*
         SPACE 1
K42      L     R1,K33              SET GR1 -> NEXT DATA AREA.
         LTR   R1,R1               TEST FOR NEXT DATA AREA PRESENT.
         BNZ   K34                 IF PRESENT THEN SKIP GETMAIN.
         LA    R0,K35-K10          SET GR0 = LENGTH FOR GETMAIN.
         GETMAIN R,LV=(0)          OBTAIN DYNAMIC STORAGE.
         ST    R1,K33              STORE ADDRESS OF NEW DATA AREA.
         XC    K33-K10(4,R1),K33-K10(R1)     CLEAR FORWARD CHAIN.
K34      STM   R2,R3,K33+4-K10(R1) STORE BACKWARD CHAIN REGISTERS.
         LR    R2,R1               SET GR2 -> NEW DATA AREA.
         SPACE 1
*
*        SET UP MBBCCHHR TO READ NEXT BLOCK.
*
         SPACE 1
K38      STM   R10,R2,K36          SAVE REGISTERS.
         LH    R0,8(R3)            SET GR0 = RELATIVE TRACK NUMBER.
         SLL   R0,8                SHIFT TO LOAD RECORD NUMBER.
         IC    R0,10(R3)           SET GR0 = TTR.
         SLL   R0,8                SET GR0 = TTRZ.
         L     R1,K8+44            SET GR1 -> DEB.
         LA    R2,K9+32            SET GR2 -> IOBSEEK.
         L     R15,16              SET GR15 -> CVT.
         L     R15,28(R15)         SET GR15 -> RESIDENT CONVERT RTN.
         BALR  R14,R15             LINK TO CONVERT TO MBBCCHHR.
         USING *,R14               DEFINE BASE REGISTER FOR RESTORE.
         LM    R10,R2,K36          RESTORE REGISTERS.
         DROP  R14                 DROP VOLATILE REGISTER.
         B     K37                 GO TO READ NEXT BLOCK.
         SPACE 1
*
*        INCREMENT GR8 FOR NODE SEARCH.
*
         SPACE 1
K32      LA    R1,7(R3)            SET GR1 -> END OF NAME.
         CLI   0(R1),C' '          IS CHARACTER BLANK ?
         BNE   *+8                 IF NOT THEN END OF NAME FOUND.
         BCT   R1,*-8              LOOP UNTIL END FOUND.
         SR    R1,R3               SET GR1 = LENGTH OF NAME.
         LA    R8,1(R1,R8)         SET GR8 -> PUTATIVE DELIMITER.
         MVI   0(R8),C'.'          STORE OR RESTORE DELIMITER.
         LA    R8,1(R8)            INCREMENT GR8 OVER DELIMITER.
         B     K38                 GO TO SET UP FOR NEXT READ.
         SPACE 1
*
*        INDEX LINK ROUTINE.
*
         SPACE 1
K16      OC    8(3,R3),8(R3)       IS IT END OF INDEX ?
         BNZ   K38                 IF NOT THEN GO TO READ NEXT BLOCK.
         TM    K13,X'20'           IS INDEX STILL ACTIVE ?
         BZ    *+14                IF NOT THEN LEAVE.
         MVC   K1+43(5),K39        STORE 'INDEX' IN WTO.
         BAL   R9,K26              LINK TO WRITE TO OPERATOR.
         BAL   R9,K65              LINK TO BACKSPACE NAME.
K52      NI    K13,X'9F'           SET OFF GDG AND INDEX FLAGS.
         LM    R2,R3,K33+4         RESTORE POINTERS TO PREVIOUS BLOCKS.
         LTR   R2,R2               TEST FOR END OF VOL INDEX OR NODE.
         BNZ   K15                 IF NOT THEN GO TO TEST NEXT BLOCK.
         SPACE 1
*
*        END-UP ROUTINE.
*
         SPACE 1
K57      CLOSE MF=(E,K7)           CLOSE SYSCTLG DATA SET.
         L     R2,K33-K-2(R11)     SET GR2 -> FIRST DYNAMIC AREA.
K41      LTR   R1,R2               SET GR1 -> NEXT DYNAMIC AREA.
*
         BZ    K40                 IF NO AREA THEN EXIT.
         L     R2,K33-K10(R1)      SET GR2 -> NEXT DATA AREA.
         LA    R0,K35-K10          SET GR0 = LENGTH FOR FREEMAIN.
         FREEMAIN R,LV=(0),A=(1)   RELEASE DYNAMIC AREA.
         B     K41                 GO TO TEST FOR NEXT DYNAMIC AREA
K40      LA    R0,0                SET GR0 = 0
         DROP  R2                  END WITH DYNAMIC AREA POINTER.
         ST    R0,K33              STORE NO DYNAMIC AREA.
         USING K10,R2              REDEFINE BASE FOR DATA AREA.
K97      L     R15,TIOTPTR         SET GR15 -> DD ENTRY FOR WORK.
         LH    R3,K68              SET GR3 -> CUEEENT UCB.
         SPMODE PROB,0,MF=(E,SPML) ALLOW UPDATE TO TIOT FOR MVT.
         STH   R3,18(R15)          RESTORE CURRENT UCB.
         SPMODE PROB,*,MF=(E,SPML) RESTORE USER'S PROTECT KEY.
         B     REPEAT              GO TO RE-ISSUE WTOR.
         SPACE 1
*
*        VOLUME CONTROL BLOCK POINTER ROUTINE.
*
         SPACE 1
K21      OI    K13,X'80'           SET ON 'VCB PRESENT' SWITCH.
*        LA    R6,K1+58            SET GR6 -> START OF SERIAL AREA.
         CLI   0(R8),C' '          IS NAME PART OF NODE ?
         BNE   K38                 IF SO THEN GO TO READ NEXT BLOCK.
         MVC   0(8,R8),0(R3)       STORE NAME IN MESSAGE.
         B     K42                 GO TO OBTAIN NEW BLOCK FOR READ.
         SPACE 1
*
*        VOLUME CONTROL BLOCK ROUTINE.
*
         SPACE 1
K14      LH    R5,K10              SET GR5 = VOLUME COUNT.
         LA    R4,K10+2            SET GR4 -> FIRST VOLUME BLOCK.
         TM    K13,X'10'           IS THIS A CONTINUATION ?
         BZ    K43                 IF NOT THEN MUST SET TYPE CODE.
         CLC   K10+2(4),K44        IS TYPE SAME AS LAST TIME ?
         BE    K45                 IF SO THEN LEAVE TYPE.
         BAL   R9,K26              LINK TO WRITE TO OPERATOR.
K43      BAL   R9,K24              LINK TO SET UP DEVICE CODE.
         LA    R6,K1+58            SET GR6 -> START OF SERIAL AREA.
K45      NI    K13,X'EF'           SET OFF CONTINUATION INDICATOR.
         LA    R0,20               SET GR0 = 20.
         CR    R5,R0               COMPARE FOR LESS THAN 21.
         BNH   *+10                IF LESS THEN NO CONTINUATION.
         LR    R5,R0               SET GR5 = VOLUME COUNT FOR THIS BLK.
         OI    K13,X'90'           SET CONTINUATION EXPECTED.
         B     K46                 GO TO COMMON DSP/VCB CODE.
         SPACE 1
*
*        DATA SET POINTER ROUTINE.
*
         SPACE 1
K19      LH    R5,12(R3)           SET GR5 = VOLUME COUNT.
         LA    R4,14(R3)           SET GR4 -> FIRST VOLUME ENTRY.
         MVC   0(8,R8),0(R3)       STORE NAME IN MESSAGE.
K53      BAL   R9,K24              LINK TO SET UP DEVICE CODE.
         LA    R6,K1+58            SET GR6 -> START OF SERIAL AREA.
         SPACE 1
*
*        COMMON CODE FOR DATA SET POINTER AND VOLUME CONTROL BLOCK.
*
         SPACE 1
K46      MVC   K47,4(R4)           STORE SERIAL FOR BUILD UP.
         NI    K13,X'DF'           SET OFF INDEX FLAG.
         LH    R0,10(R4)           SET GR0 = FILE SEQUENCE NUMBER.
         LA    R7,5                SET GR7 = 5.
         LTR   R0,R0               TEST FOR SEQUENCE MISSING.
         BZ    K48                 IF MISSING THEN NO BUILD UP.
         CVD   R0,DW               CONVERT TO DECIMAL.
         OI    DW+7,X'0F'          REMOVE ZONE.
         UNPK  K47+7(5),DW+5(3)    UNPACK SEQUENCE NUMBER.
         LA    R0,1                SET GR0 = 1.
         MVI   K47+6,C'-'          STORE HYPHEN.
         LA    R1,K47+7            SET GR1 -> UNPACKED FILE SEQUENCE.
         CLI   0(R1),C'0'          IS CHARACTER A ZERO ?
         BNE   *+8                 EXIT WHEN FOUND.
         BXH   R1,R0,*-8           LOOP UNTIL FOUND.
         MVC   K47+7(5),0(R1)      LEFT JUSTIFY FILE SEQUENCE.
         LA    R7,K47+18           SET GR7 FOR SUBTRACT.
         SR    R7,R1               SET GR7 = LENGTH FOR EXECUTE.
K48      LA    R0,K1+83            SET GR0 -> END OF AREA.
         CLI   K1+76,C'G'          IS 'GDG' SPECIFIED ?
         BNE   *+8                 IF NOT THEN MAY USE ALL AREA.
         LA    R0,K1+75            SET GR6 -> END OF AREA IF GDG.
         SR    R0,R6               SET GR0 = LENGTH REMAINING
         CR    R7,R0               COMPARE FOR FIT.
         BL    *+8                 IF LESS THEN FIT.
         BAL   R9,K26              LINK TO WRITE TO OPERATOR.
         EX    R7,K49              MOVE SERIAL AND SEQUENCE INTO WTO.
         LA    R6,1(R6,R7)         SET GR6 -> BEYOND SERIAL AND SEQ.
         BCT   R5,K50              TEST FOR END OF VCB/DSP.
         TM    K13,X'10'           IS THERE A CONTINUATION ?
         BO    K51                 IF SO THEN GO TO SET UP FOR READ.
         BAL   R9,K26              LINK TO WRITE MESSAGE TO OPERATOR.
         MVC   0(8,R8),BLANKS      CLEAR DATA SET NAME ELEMENT.
         TM    K13,X'80'           IS BLOCK A VOLUME CONTROL BLOCK ?
         BZ    K15                 IF NOT THEN GO TO PROCESS NEXT ENTRY
         B     K52                 GO TO CHAIN BACK ONE BLOCK.
K51      LA    R3,K10+243          SET GR3 FOR NEXT VOLUME CONTROL BLK.
         B     K38                 GO TO READ NEXT BLOCK.
K50      MVI   0(R6),C','          STORE DELIMITER.
         LA    R6,1(R6)            INCREMENT GR6 FOR NEXT.
         LA    R4,12(R4)           INCREMENT GR4 FOR NEXT POINTER.
         CLC   0(4,R4),K44         IS THIS SAME DEVICE TYPE ?
         BE    K46                 IF SO THEN GO TO CONTINUE SET-UP.
         BAL   R9,K26              LINK TO WRITE TO OPERATOR.
         B     K53                 GO TO SET UP NEW TYPE.
         SPACE 1
*
*        SCAN FOR NODE.
*
         SPACE 1
K18      LA    R1,8(R8)            SET GR1 AS STOPPER.
         LA    R0,1                SET GR0 = 1
         LR    R15,R8              SET GR15 TO START SCAN.
K55      CLI   0(R15),C' '         IS IT END OF NAME ?
         BE    K54                 IF SO THEN GO TO COMPARE.
         CLI   0(R15),C'.'         IS IT END OF INDEX ?
         BE    K54                 IF SO THEN GO TO COMPARE.
         BXLE  R15,R0,K55          LOOP UNTIL END FOUND.
K58      LA    R1,K56              SET GR1 -> 'INVALID SPECS' MESSAGE.
K64      BAL   R9,WTO              LINK TO WRITE TO OPERATOR.
         B     K57                 GO TO EXIT.
K54      SR    R15,R8              SET GR15 = LENGTH OF NAME.
         BZ    K58                 IF ZERO THEN INVALID NAME.
         BCTR  R15,R0              DECREMENT GR15 FOR EXECUTE.
         EX    R15,K59             COMPARE NAME IN INDEX WITH NODE.
         BL    K15                 IF LESS THEN GO TO SCAN NEXT BLOCK.
         BH    K60                 IF GREATER THEN NODE NOT FOUND.
         LA    R0,7                SET GR0 = 7.
         CLR   R0,R15              COMPARE FOR FULL NAME.
         BE    K61                 IF EQUAL THEN GO TO 'NODE FOUND'.
         LA    R1,1(R8,R15)        SET GR1 -> BYTE FOLLOWING NAME.
         CLI   0(R1),C' '          IS CHARACTER BLANK ?
         BNE   K60                 IF NOT THEN NODE NOT FOUND.
K61      DS    0H
         CLI   11(R3),5            IS ENTRY FOR CVOL ?
         BNE   K62                 IF NOT THEN GO TO ANALYZE ENTRY.TYPE
         L     R1,16               SET GR1 -> CVT.
         L     R1,40(R1)           SET GR1 -> UCB LOOK-UP TABLE.
K69      LH    R9,0(R1)            SET GR9 -> UCB.
         LTR   R9,R9               TEST SIGN OF GR9.
         BM    K66                 IF MINUS THEN NO CVOL MOUNTED.
         BZ    K67                 IF ZERO THEN GAP IN TABLE.
         CLC   18(2,R9),14(R3)     IS DEVICE TYPE AS REQUESTED.
         BNE   K67                 IF NOT THEN GO TO SCAN NEXT.
         CLC   28(6,R9),16(R3)     IS SERIAL AS REQUESTED ?
         BNE   K67                 IF NOT THEN GO TO SCAN NEXT.
         CLOSE MF=(E,K7)           CLOSE SYSCTLG DATA SET.
         LR    R2,R9               SET GR2 -> UCB.
         B     K2                  GO TO RE-OPEN SYSCTLG.
K67      LA    R1,2(R1)            INCREMENT GR1 FOR NEXT UCB.
         B     K69                 GO TO TEST NEXT UCB.
K66      LA    R1,K70              SET GR1 -> 'CVOL NOT MOUNTED' MSG.
         B     K64                 GO TO WRITE MESSAGE.
K60      LA    R1,K63              SET GR1 -> 'NODE NOT FOUND' MSG.
         B     K64                 GO TO WRITE MESSAGE.
K95      LA    R1,K96              SET GR1 -> 'NOT A CVOL' MESSAGE.
         B     K93                 GO TO EXIT.
         EJECT
*
*        SUB-ROUTINES AND ERROR ROUTINES.
*
         SPACE 1
K12      LA    R1,K71              SET GR1 -> 'I/O ERROR ON CATLG' MSG.
         B     K64                 GO TO WRITE MESSAGE.
         SPACE 3
K24      MVC   K44(4),0(R4)        SAVE DEVICE TYPE.
         MVC   K1+51(6),K73        STORE DEVICE = '2400'
         TM    2(R4),X'80'         IS DEVICE MAGNETIC TAPE ?
         BO    K74                 IF SO THEN GO TO TEST SPECIAL FTURES
         MVI   K1+52,C'3'          SET DEVICE = '2300'
         SR    R15,R15             SET GR15 = 0.
         IC    R15,3(R4)           SET GR15 = DEVICE CODE.
         AR    R15,R15             DOUBLE GR15 FOR LOOK-UP
         LA    R15,K75(R15)        SET GR15 -> DASD TYPE.
         MVC   K1+53(2),0(R15)     STORE DASD TYPE.
         BR    R9                  RETURN.
K74      TM    0(R4),X'04'         IS MODEL 3 OR 4 ?
         BNZ   K76                 IF SO THEN GO TO SET UP.
         TM    1(R4),X'C0'         IS MODEL 2 ?
         BCR   8,R9                IF NOT THEN LEAVE.
         MVI   K1+56,C'2'          STORE MODEL 2.
K77      MVC   K1+55,C'-'          STORE HYPHEN.
         BR    R9                  RETURN.
K76      MVI   K1+56,C'3'          STORE MODEL 3.
         TM    1(R4),X'20'         IS MODEL 3 ?
         BZ    K77                 IF SO THEN GO TO STORE HYPHEN.
         MVI   K1+56,C'4'          STORE MODEL 4.
         B     K77                 GO TO STORE HYPHEN.
         SPACE 3
K26      LA    1,K1                SET GR1 -> WTO.
         STM   R8,R9,DW            SAVE REGS DESTROYED BY WTO.
         BAL   R9,WTO              LINK TO WRITE TO OPERATOR.
         LM    R8,R9,DW            RESTORE REGS DESTROYED BY WTO.
         MVC   K1+51(33),BLANKS    CLEAR SERIAL AREA.
         LA    R6,K1+58            SET GR6 -> START OF SERIAL AREA.
         BR    R9                  RETURN.
         SPACE 3
K65      LA    R1,K1+3             SET GR1 AS A STOPPER.
         LA    R0,1                SET GR0 = 1.
         LNR   R0,R0               SET GR0 = -1.
         BCTR  R8,R0               DECREMENT GR8 TO POINT TO DELIMITER.
         BCTR  R8,R0               DECREMENT GR8 TO SKIP DELIMITER.
         CR    R8,R1               COMPARE WITH GR1.
         BNH   K78                 IF NOT GREATER THEN USE GR1.
         CLI   0(R8),C'.'          IS BYTE AN INDEX DELIMITER ?
         BE    K79                 IF SO THEN END OF BACKSPACE FOUND.
         BXH   R8,R0,*-8           LOOP UNTIL END FOUND.
K78      LR    R8,R1               SET GR8 -> STOPPER ADDRESS.
K79      LA    R8,1(R8)            SET GR8 -> START FOR CLEAR.
         LA    R15,K1+83           SET GR15 FOR SUBTRACT.
         SR    R15,R8              SET GR15 FOR EXECUTE.
         EX    R15,K81             CLEAR UNWANTED CHARACTERS IN WTO.
         BR    R9                  RETURN.
         EJECT
*
*        MODEL STATEMENTS.
*
         SPACE 1
K3       TRT   0(0,R15),K4         SCAN FOR BLANK.
K5       MVC   K1+4(0),0(R15)      MOVE NAME INTO WTO AREA.
K49      MVC   0(0,R6),K47         MOVE SERIAL AND SEQUENCE INTO WTO.
K59      CLC   0(0,R3),0(R8)       COMPARE NAME IN INDEX WITH NODE.
K81      MVC   0(0,R8),BLANKS      CLEAR UNWANTED CHARACTERS IN WTO.
         EJECT
*
*        CONSTANTS AND WORK AREAS.
*
         SPACE 1
K1       DC    H'84,0',CL80' '
K4       DC    64X'0',C' ',191X'0'
K7       OPEN  K8,MF=L
K8       DCB   DDNAME=SYSWK,EXLST=EXIT,MACRF=E
K9       DC    X'42',A(ECB,0,0,K80,K8),4A(0)
K36      DC    9A(0)
K94      CAMLST SEARCH,JFCB,JFCB+118,0
K56      WTO   'INVALID NODE SPECIFIED',MF=L
K68      DS    H
K63      WTO   'NODE NOT FOUND',MF=L
K70      WTO   'CVOL NOT MOUNTED',MF=L
K71      WTO   'I/O ERROR ON CATALOG',MF=L
K88      WTO   'DEVICE NOT MOUNTED',MF=L
K92      EQU   WTOR3+8
K96      WTO   'DEVICE IS NOT A CVOL',MF=L
K80      CCW   X'31',K9+35,X'40',5
         CCW   X'08',K80,0,0
K11      CCW   X'06',0,0,256
K6       DC    C'SYSCTLG'
K13      DC    AL1(0)
K17      DC    4X'FF'
K25      DC    C'CVOL'
K28      DC    C'ALIAS'
K30      DC    X'202120'
K31      DC    C'GDG'
K39      DC    C'INDEX'
K44      DC    XL4'0'
K47      DS    2CL6
K73      DC    CL6'2400'
K75      EQU   *-2
         DC    C'1101030221....14'
K10      DC    64F'0'
K33      DC    3A(0)
K35      DS    0F
         TITLE 'RT5005M - WRITE DATA SET AND ATTACH CSECT - A.MORRISH.'
W        CSECT
         ENTRY A
         BALR  R11,R0              INITIALISE BASE REGISTER.
         USING *,R11               DEFINE BASE REGISTER.
         SPACE 1                                                      *
*                                                                     *
*        FIND WHETHER DATA SET IS OPEN AND IF SO GO TO PUT.           *
*                                                                     *
         SPACE 1                                                      *
         TM    W1+48,X'10'         IS DATA SET OPEN ?
         BZ    W2                  IF NOT THEN GO TO OPEN.
         PUT   W1,REP+2            WRITE DATA.
         B     REPEAT              GO TO RE-ISSUE WTOR.
         SPACE 1                                                      *
*                                                                     *
*        FIND DD-NAME AND STORE IN DCB.                               *
*                                                                     *
         SPACE 1                                                      *
W2       LA    R15,REP+2           SET GR15 FOR SCAN FOR DATA SET NAME.
         LA    R14,1               SET GR14 = 1.
         CLI   0(R15),C' '         IS CHARACTER BLANK ?
         BNE   *+8                 IF NOT THEN FOUND.
         BXH   R15,R14,*-8         LOOP UNTIL DD NAME FOUND.
         MVC   W1+40(8),0(R15)     STORE DD-NAME.
         SPACE 1                                                      *
*                                                                     *
*        CHECK FOR DATA SET AND DD STATEMENT PRESENT.                 *
*                                                                     *
         SPACE 1                                                      *
         GETMAIN R,LV=526          OBTAIN SPACE FOR RDJFCB AND OBTAIN.
         ST    R1,W3               STORE ADDRESS OF WORK AREA IN RDJFCB
         MVI   W3,X'87'            RESTORE AS AN EXIT LIST.
         ST    R1,W4+4             STORE JFCB ADDRESS IN CAMLST.
         LA    R0,118(R1)          SET GR0 -> VOLUME SERIAL NO.
         ST    R0,W4+8             STORE ADDRESS OF VOLUME SERIAL.
         LA    R0,176(R1)          SET GR0 -> OBTAIN WORK AREA.
         ST    R0,W4+12            STORE ADDRESS OF WORK AREA IN CAMLST
         LR    R2,R1               SET GR2 -> DYNAMIC WORK AREA.
         MVI   0(R2),0             CLEAR FIRST BYTE OF JFCB AREA.
         RDJFCB MF=(E,W5)          READ JOB FILE CONTROL BLOCK.
         CLI   0(R2),0             IS A JFCB PRESENT.
         LA    R1,W6               SET GR1 -> ERROR MESSAGE.
         BE    W7                  IF NO JFCB THEN GO TO WRITE ERROR.
         OBTAIN W4                 OBTAIN DSCB.
         LA    R1,W8               SET GR1 -> ERROR MESSAGE.
         MVC   W8+4(44),0(R2)      STORE DATA SET NAME IN ERROR MESSAGE
         MVC   W8+48(6),118(R2)    STORE VOLUME SERIAL IN ERROR MESSAGE
         LTR   R15,R15             WAS A DSCB FOUND ?
         BNZ   W7                  IF NOT THEN GO TO WRITE ERROR.
         MVC   W9+4(50),W8+4       STORE MESSAGE TO 'GOOD' MESSAGE.
         LH    R15,102(R2)         SET GR15 = JFCB BLOCK SIZE.
         LTR   R15,R15             TEST SIGN OF GR15.
         BNZ   *+8                 IF NOT ZERO THEN LEAVE.
         LH    R15,218(R2)         SET GR15 = DSCB BLOCK SIZE.
         SR    R14,R14             SET GR14 = 0.
         LTR   R15,R15             TEST SIGN OF GR15.
         BZ    W10                 IF ZERO THEN LEAVE.
         LH    R1,W1+82            SET GR1 = RECORD LENGTH.
         DR    R14,R1              DIVIDE TO CALCULATE BLOCKING FACTOR.
         MR    R14,R1              MULTIPLY TO CALCULATE VALID BLOCKSI.
         LTR   R15,R15             TEST SIGN OF GR15.
         BZ    W10                 IF ZERO THEN LEAVE.
         STH   R15,W1+62           STORE NEW BLOCK SIZE.
W10      OPEN  MF=(E,W5),TYPE=J    OPEN DATA SET.
         TM    W1+48,X'10'         IS DATA SET OPEN ?
         LA    R1,W8               SET GR1 -> ERROR MESSAGE.
         BZ    W7                  IF DATA SET NOT OPEN THEN ERROR.
         XI    SWA,X'C0'           SET OUTPUT DATA SET OPEN SWITCHES.
         LA    R1,W9               SET GR1 -> 'OPENED' MESSAGE.
W7       BAL   R9,WTO              LINK TO WRITE TO OPERATOR.
         FREEMAIN R,LV=526,A=(R2)  RELEASE DYNAMIC AREA.
         B     REPEAT              GO TO RE-ISSUE WTOR.
         SPACE 3                                                      *
*                                                                     *
*        ATTACH ROUTINE.                                              *
*                                                                     *
         SPACE 1                                                      *
A        BALR  R11,R0              INITIALISE BASE REGISTER.
         USING *,R11               DEFINE BASE REGISTER.
         SPACE 1                                                      *
*                                                                     *
*        FIND AND STORE PROGRAM NAME.                                 *
*                                                                     *
         SPACE 1                                                      *
         LA    R15,REP+2           SET GR15 FOR SCAN FOR PROGRAM NAME.
         LA    R14,1               SET GR14 = 1.
         CLI   0(R15),C' '         IS CHARACTER BLANK ?
         BNE   *+8                 IF NOT THEN PROGRAM NAME FOUND.
         BXH   R15,R14,*-8         LOOP UNTIL PROGRAM NAME FOUND.
         LA    R14,REP+79          SET GR14 -> END OF REPLY AREA.
         SR    R14,R15             SET GR14 = LENGTH FOR SCAN.
         LA    R0,7                SET GR0 = 7.
         CLR   R14,R0              COMPARE FOR MORE THAN 8 CHARACTERS.
         BNH   *+6                 IF NOT THEN LEAVE.
         LR    R14,R0              SET LIMIT OF 8 CHARACTERS ON SCAN.
         LA    R1,8(R15)           SET GR1 FOR SCAN NOT SATISFIED.
         EX    R14,A1              SCAN FOR DELIMITER.
         MVC   A2+4(8),BLANKS      CLEAR NAME.
         SR    R1,R15              SET GR1 = LENGTH OF NAME.
         BCR   13,R9               IF NOT PLUS THEN NAME OMITTED.
         BCTR  R1,R0               DECREMENT GR1 FOR EXECUTE.
         EX    R1,A3               MOVE NAME TO ENTRY POINT NAME.
         SPACE 1                                                      *
*                                                                     *
*        FIND AND STORE PARAMETER LIST.                               *
*                                                                     *
         SPACE 1                                                      *
         LA    R15,1(R1,R15)       SET GR15 -> DELIMITER.
         XC    A4+6(2),A4+6        CLEAR PARAMETER LENGTH.
         CLI   0(R15),C' '         IS DELIMITER A BLANK ?
         BE    A5                  IF SO THEN LEAVE NULL LIST.
         CLI   0(R15),C','         IS DELIMITER A COMMA.
         BNE   *+8                 IF NOT THEN MUST BE FULL NAME.
         LA    R15,1(R15)          INCREMENT GR15 OVER PARMS.
         MVC   A4+8(76),0(R15)     STORE PARAMETERS.
         LA    R1,A4+83            SET GR1 -> END OF PARAMETER LIST.
         CLI   0(R1),C' '          IS CHARACTER NULL ?
         BNE   *+8                 IF NOT THEN END FOUND.
         BCT   R1,*-8              LOOP UNTIL END FOUND.
         LA    R0,A4+7             SET GR0 FOR SUBTRACT.
         SR    R1,R0               SET GR1 = PARAMETER LENGTH.
