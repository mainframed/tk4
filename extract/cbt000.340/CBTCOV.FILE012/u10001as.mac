         TITLE     'VTOCLIST - LIST VTOC OF SYSUT1'
********** REQUIRES MACRO #START   *************
*
* THIS PROGRAM PRODUCES A FORMATED LISTING OF A DIRECT ACCESS DEVICE
* TYPE VTOC (BUT MAYBE NOT A DATA CELL). THE OUTPUT MUST BE SEEN TO BE
* BELIEVED.
*
* THE OUTPUT LISTING IS IN ALPHABETICAL ORDER OF DATA SET NAME. ALL
* RELEVANT INFORMATION PERTAINING TO A DATA SET APPEARS ON JUST ONE
* LINE, SECONDARY EXTENTS REQUIRING EXTRA LINES.
*
* THIS PROGRAM IS NORMALLY QUICKER THAN IEHLIST, FORMAT OR NOT.
*
* SAMPLE JCL REQUIRED FOR EXECUTION -
* //STEPNAME EXEC PGM=VTOCLIST
* //SYSPRINT DD SYSOUT=A
* //SYSUT1 DD VOL=SER=DISKNO,UNIT=DISK,DISP=OLD
*
*
         MACRO
&NAME    #SORT     &FIELDS=(1,1,CH,A),&FIRST=,&LAST=,&A=,&FORMAT=,     *
               &LENGTH=
.*  AUTHOR - PETER HAVERCAN
         GBLC      &##EQU
         LCLA      &X,&Y,&Z,&LEN
         LCLC      &HI,&LO,&R0,&R1,&R14,&R15
&X       SETA      N'&FIELDS
         AIF       (&X NE 3 AND &X NE 4).ERR1
         AIF       (&X EQ 4 AND '&FIELDS(3)' NE 'CH').ERR2
&HI      SETC      'H'
&LO      SETC      'L'
         AIF      ('&FIELDS(&X)' NE 'D').TESTA
&HI      SETC      'L'
&LO      SETC      'H'
         AGO       .SETREGS
.TESTA   AIF       ('&FIELDS(&X)' EQ 'A').SETREGS
         MNOTE     *,'*** SORT TYPE NOT A OR D - A ASSUMED'
.SETREGS ANOP
&R0      SETC      '&##EQU.0'
&R1      SETC      '&##EQU.1'
&R14     SETC      '&##EQU.14'
&R15     SETC      '&##EQU.15'
         AIF       ('&LENGTH' EQ '').NOLNGTH
&LEN     SETA      &LENGTH
         AGO       .LENSET
.NOLNGTH ANOP
&LEN     SETA      L'&FIRST
.LENSET  ANOP
&X       SETA      &FIELDS(1)-1        OFFSET WITHIN RECORD
&Y       SETA      &FIELDS(2)          LENGTH OF SORT-KEY
&Z       SETA      &X+&LEN             OFFSET WITHIN NEXT RECORD
         AIF       ('&FIRST&LAST' EQ '').ATYPE
&NAME    LA        &R15,&FIRST         ADDRESS FIRST ENTRY
         LA        &R0,&LENGTH         LOAD WIDTH OF TABLE
         LA        &R1,&LAST           ADDRESS LAST ENTRY
         AGO       .STEPBCK
.ATYPE   AIF       ('&A' EQ '').ERR3
&NAME    LM        &R15,&R1,&A         FIRST ENTRY,WIDTH,LAST ENTRY
.STEPBCK ANOP
         SR        &R1,&R0             REG1 POINTS AT PENULTIMATE
         CLC       &X.(&Y,&R15),&Z.(&R1) COMPARE FIRST & LAST ENTRIES
         B&LO      *+22                RECDS IN SEQUENCE
         XC        0(&LEN,&R15),&LEN.(&R1) SWITCH FIRST AND
         XC        &LEN.(&LEN,&R1),0(&R15) LAST ENTRIES INTO
         XC        0(&LEN,&R15),&LEN.(&R1) CORRECT SEQUENCE
         LA        &R14,&LEN.(&R15)    ADDRESS NEXT RECORD
         CLC       &X.(&Y,&R14),&X.(&R15) COMPARE SORT KEYS
         BN&LO     *+26                IN SEQUENCE FROM FRONT
         XC        0(&LEN,&R14),0(&R15) SWITCH FIELDS
         XC        0(&LEN,&R15),0(&R14) WHICH ARE OUT
         XC        0(&LEN,&R14),0(&R15) OF SEQUENCE
         B         *+32                GO TO LOOP CONTROL
         CLC       &X.(&Y,&R14),&Z.(&R1) COMPARE WITH FINAL RECORD
         BN&HI     *+22                IN SEQUENCE FROM REAR
         XC        0(&LEN,&R14),&LEN.(&R1) SWITCH FIELDS
         XC        &LEN.(&LEN,&R1),0(&R14) WHICH ARE OUT
         XC        0(&LEN,&R14),&LEN.(&R1) OF SEQUENCE
         BXLE      &R14,&R0,*-60       INCREMENT & LOOP BACK
         SR        &R1,&R0             DECREMENT END POINTER
         BXLE      &R15,&R0,*-98       ADVANCE FRONT POINTER
         MEXIT
.ERR1    MNOTE     8,'INVALID NO. OF ENTRIES IN FIELDS PARAMETER'
         MEXIT
.ERR2    MNOTE     4,'FORMAT TYPE IS NOT SUPPORTED'
         MEXIT
.ERR3    MNOTE     8,'NEITHER A NOR FIRST AND LAST ARE SPECIFIED'
         MEND
         MACRO
&NAME    DSCB      &FORMAT=(1),&KEY=YES
.*  AUTHOR - PETER HAVERCAN - 11/12/72
         GBLB      &DSCBFLG(6)
         LCLA      &KOUNT
         LCLC      &ID,&LABEL
&LABEL   SETC      'DSCB&SYSNDX'
         AIF       ('&NAME' EQ '').NONAME
&LABEL   SETC      '&NAME'
.NONAME  ANOP
&LABEL   DS        0F                  ORIGIN ON WORD BOUNDARY
.LOOP    ANOP
&KOUNT   SETA      &KOUNT+1
         AIF       (&KOUNT GT N'&FORMAT).END
&ID      SETC      '&FORMAT(&KOUNT)'
         AIF       ('&ID' NE '0').FMT1
***********************************************************************
*                                                                     *
*        FORMAT 0 DSCB                                                *
*                                                                     *
***********************************************************************
         ORG       &LABEL
         AIF       ('&KEY' EQ 'NO').KEY0
         DC        XL44'00' .          * FORMAT ZERO - KEY PORTION
.KEY0    ANOP
         DC        XL96'00' .          * FORMAT ZERO - DATA PORTION
         AGO       .LOOP
.FMT1    AIF       ('&ID' NE '1').FMT2
         AIF       (&DSCBFLG(1)).ERR2
&DSCBFLG(1) SETB   1
***********************************************************************
*                                                                     *
*        FORMAT 1 DSCB                                                *
*                                                                     *
***********************************************************************
         ORG       &LABEL
         AIF       ('&KEY' EQ 'NO').KEY1
DS1DSNAM DS        CL44 .              * DATASET NAME
.KEY1    ANOP
DS1FMTID DS        C'1' .              * DSCB IDENTIFIER
DS1DSSN  DS        CL6 .               * DATASET SERIAL NUMBER
DS1VOLSQ DS        XL2 .               * VOLUME SEQ NO (BINARY)
DS1CREDT DS        XL3 .               * CREATION DATE - YDD
DS1EXPDT DS        XL3 .               * EXPIRY DATE - YDD
DS1NOEPV DS        X .                 * NO. OF SEPARATE EXTENTS
DS1NOBDB DS        X .                 * NO. OF BYTES IN LAST PDS DIR
*                                      * BLOCK
         DS        X .                 * RESERVED
DS1SYSCD DS        XL13 .              * SYSTEM CODE
         DS        XL7 .               * RESERVED
DS1DSORG DS        XL2 .               * DATASET ORGANIZATION
DS1RECFM DS        X .                 * RECORD FORMAT
DS1OPTCD DS        X .                 * OPTION CODE
DS1BLKL  DS        XL2 .               * BLOCK LENGTH
DS1LRECL DS        XL2 .               * RECORD LENGTH
DS1KEYL  DS        X .                 * KEY LENGTH
DS1RKP   DS        XL2 .               * RELATIVE KEY POSITION
DS1DSIND DS        X .                 * DATA SET INDICATORS
DS1SCALO DS        XL4 .               * SEC ALLOC PARAMETERS
DS1LSTAR DS        XL3 .               * LAST BLOCK POINTER - TTR
DS1TRBAL DS        XL2 .               * NO. OF BYTES REMAINING ON TRK
         DS        XL2 .               * RESERVED
DS1EXT1  DS        XL10 .              * 1ST EXTENT DESCRIPTION
DS1EXT2  DS        XL10 .              * 2ND EXTENT DESCRIPTION
DS1EXT3  DS        XL10 .              * 3RD EXTENT DESCRIPTION
DS1PTRDS DS        XL5 .               * POINTER TO FORMAT 2 OR 3
         AGO       .LOOP
.FMT2    AIF       ('&ID' NE '2').FMT3
         AIF       (&DSCBFLG(2)).ERR2
&DSCBFLG(2) SETB   1
***********************************************************************
*                                                                     *
*        FORMAT 2 DSCB                                                *
*                                                                     *
***********************************************************************
         ORG       &LABEL
         AIF       ('&KEY' EQ 'NO').KEY2
         DS        X'02' .             * KEY FIELD
DS22MIND DS        XL7 .               * 2ND LEVEL MASTR INDX - MBBCCHH
DS2L2MEN DS        XL5 .               * CCHHR LAST ACTIVE INDEX IN 2ND
*                                        LEVEL MASTER INDEX
DS23MIND DS        XL7 .               * 3RD LEVEL MASTR INDX - MBBCCHH
DS2L3MIN DS        XL5 .               * CCHHR LAST ACTIVE INDEX IN 3RD
*                                        LEVEL MASTER INDEX
         DS        XL19 .              * RESERVED
.KEY2    ANOP
DS2FMTID DS        C'2' .              * FORMAT IDENTIFIER
DS2NOLEV DS        X .                 * NO. OF INDEX LEVELS
DS2DVIND DS        X .                 * NO. TRK DTRMG DEV OF MSTR INDX
DS21RCYL DS        XL3 .               * HHR OF 1ST DATA RECD ON EA CYL
DS2LTCYL DS        XL2 .               * HH OF LAST DATA TRK ON EA CYL
DS2CYLOV DS        X .                 * NO. TRKS OF OVFLO ON EA CYL
DS2HIRIN DS        X .                 * HI-EST R ON TRK W/HI-LVL INDX
DS2HIRPD DS        X .                 * HI-EST R ON PRIME DATA TRKS
DS2HIROV DS        X .                 * HI-EST R ON OVFLO DATA TRKS
DS2RSHTR DS        X .                 * R OF LAST DATA RECD SHRD TRK
DS2HIRTI DS        X .                 * HIEST R UNSHRD TRK OF TRK INDX
DS2HIIOV DS        X .                 * HI-EST R INDEP OVFLO DATA TRKS
DS2TAGDT DS        XL2 .               * NO. RECDS TAGGED FOR DELETION
DS2RORG3 DS        XL3 .               * READ/WRITE CNTR
DS2NOBYT DS        XL2 .               * CORE REQD FOR HI-LVL INDEX
DS2NOTRK DS        X .                 * NO. TRKS IN HI-LVL INDEX
DS2PRCTR DS        XL4 .               * NO. RECDS IN PRIME DATA AREA
DS2STIND DS        X .                 * STATUS INDICATORS
DS2CYLAD DS        XL7 .               * ADDR OF CYL INDEX - MBBCCHH
DS2ADLIN DS        XL7 .               * ADDR LO-LVL MASTR INDEX
DS2ADHIN DS        XL7 .               * ADDR HI-LVL INDEX - MBBCCHH
DS2LPRAD DS        XL8 .               * ADDR LAST RECD IN PRIME AREA
DS2LTRAD DS        XL5 .               * CCHHR LAST ENTRY IN TRK INDX
DS2LCYAD DS        XL5 .               * CCHHR LST ENTRY IN CYL INDX
DS2LMSAD DS        XL5 .               * CCHHR LST ENTRY IN MASTR INDX
DS2LOVAD DS        XL8 .               * ADDR LAST RECD IN INDEP OVFLO
DS2BYOVL DS        XL2 .               * BYTES LEFT ON INDEP OVFLO TRK
DS2RORG2 DS        XL2 .               * TRKS LEFT IN INDEP OVFLO
DS2OVRCT DS        XL2 .               * NO. RECDS IN OVFLO AREA
DS2RORG1 DS        XL2 .               * NO. FULL CYL OVFLO AREAS
DS2NIRT  DS        XL3 .               * HHR OF DUMMY TRK INDX ENTRY
DS2PTRDS DS        XL5 .               * POINTER TO FORMAT 3 - CCHHR
         AGO       .LOOP
.FMT3    AIF       ('&ID' NE '3').FMT4
         AIF       (&DSCBFLG(3)).ERR2
&DSCBFLG(3) SETB   1
***********************************************************************
*                                                                     *
*        FORMAT 3 DSCB                                                *
*                                                                     *
***********************************************************************
         ORG       &LABEL
         AIF       ('&KEY' EQ 'NO').KEY3
         DS        X'03030303' .       * KEY IDENTIFIER
DS3EXTNT DS        4XL10 .             * EXTENT DESCRIPTIONS 4 - 7
.KEY3    ANOP
DS3FMTID DS        C'3' .              * FORMAT IDENTIFIER
DS3ADEXT DS        9XL10 .             * EXTENT DESCRIPTIONS 8 - 16
DS3PTRDS DS        XL5 .               * RESERVED
         AGO       .LOOP
.FMT4    AIF       ('&ID' NE '4').FMT5
         AIF       (&DSCBFLG(4)).ERR2
&DSCBFLG(4) SETB   1
***********************************************************************
*                                                                     *
*        FORMAT 4 DSCB                                                *
*                                                                     *
***********************************************************************
         ORG       &LABEL
         AIF       ('&KEY' EQ 'NO').KEY4
DS4DSNAM DS        CL44 .              * VTOC KEY
.KEY4    ANOP
DS4IDFMT DS        C'4' .              * FORMAT IDENTIFIER
DS4HPCHR DS        XL5 .               * HIGHEST FORMAT 1 ADDR - CCHHR
DS4DSREC DS        XL2 .               * NO. OF AVAIL FORMAT 0'S
DS4HCCHH DS        XL4 .               * NEXT ALTERNATE TRK - CCHH
DS4NOATK DS        XL2 .               * NO. OF ALT TRKS REMAINING
DS4VTOCI DS        X .                 * VTOC INDICATORS
DS4NOEXT DS        AL1(1) .            * NO OF EXTENTS IN VTOC
         DS        XL2 .               * RESERVED
DS4DEVSZ DS        XL4 .               * DEVICE SIZE
DS4DEVTK DS        XL2 .               * DEVICE TRACK LENGTH
DS4DEVZ  DS        0XL2 .              * OVERHEAD FOR KEYED BLOCK
DS4DEVI  DS        X .                 * OVERHEAD NON-LAST KEYED RECD
DS4DEVL  DS        X .                 * OVRHEAD LAST KEYED RECD ON TRK
DS4DEVK  DS        X .                 * OVERHEAD NON-KEYED RCDS
DS4DEVFG DS        X .                 * DEVICE INDICATORS
DS4DEVTL DS        XL2 .               * DEVICE TOLERANCE
DS4DEVDT DS        X .                 * NO. OF DSCB'S PER TRK
DS4DEVDB DS        X .                 * NO. OF PDS DIRECT BLK / TRK
         DS        XL24 .              * RESERVED
DS4F6PTR DS        XL5 .               * FORMAT 6 POINTER
DS4VTOCE DS        XL10 .              * VTOC EXTENT
         DS        XL25 .              * RESERVED
         AGO       .LOOP
.FMT5    AIF       ('&ID' NE '5').FMT6
         AIF       (&DSCBFLG(5)).ERR2
&DSCBFLG(5) SETB   1
***********************************************************************
*                                                                     *
*        FORMAT 5 DSCB                                                *
*                                                                     *
***********************************************************************
         ORG       &LABEL
         AIF       ('&KEY' EQ 'NO').KEY5
DS5KEYID DS        X'05050505' .       * KEY IDENTIFICATION
DS5AVEXT DS        XL5 .               * AVAILABLE EXTENT
*                                      BYTES 1-2 = TT OF 1ST TRK
*                                      BYTES 3-4 = NO. UNUSED CYLS
*                                      BYTE 5 = NO. OF EXTRA UNUSED TRK
DS5EXTAV DS        XL35 .              * 7 MORE AVAIL EXTENTS
.KEY5    ANOP
DS5FMTID DS        C'5' .              * FORMAT IDENTIFIER
DS5MAVET DS        XL90 .              * 18 MORE AVAIL EXTENTS
DS5PTRDS DS        XL5 .               * CCHHR OF NEXT FORMAT5
         AGO       .LOOP
.FMT6    AIF       ('&ID' NE '6').ERR1
         AIF       (&DSCBFLG(6)).ERR2
&DSCBFLG(6) SETB   1
***********************************************************************
*                                                                     *
*        FORMAT 6 DSCB                                                *
*                                                                     *
***********************************************************************
         ORG       &LABEL
         AIF       ('&KEY' EQ 'NO').KEY6
DS6KEYID DS        X'06060606' .       * KEY IDENTIFIER
DS6AVEXT DS        XL5 .               * EXTENT OF SPACE SHARED
*                                      BYTES 1-2 = TT OF 1ST CYL
*                                      BYTES 3-4 = NO. OF CYLS SHRD
*                                      BYTE 5 = NO. OF DATASETS SHRING
DS6EXTAV DS        XL35 .              * 7 SHARED EXTENTS
.KEY6    ANOP
DS6FMTID DS        C'6' .              * FORMAT IDENTIFIER
DS6MAVET DS        XL90 .              * 18 MORE SHARED EXTENTS
DS6PTRDS DS        XL5 .               * POINTER TO NEXT FORMAT 6
         AGO       .LOOP
.ERR1    MNOTE     *,'*** INVALID FORMAT &ID SPECIFIED'
         AGO       .LOOP
.ERR2    MNOTE     4,'*** ATTEMPT TO DEFINE FORMAT&ID DSCB'
         MNOTE     *,'    MORE THAN ONCE - ATTEMPT IGNORED'
         AGO       .LOOP
.END     MEND
         MACRO
&NAME    ERROR     &A
&NAME    ABEND     &A
         MEND
         EJECT
VTOCLIST CSECT
*      AUTHOR - P.E.HAVERCAN - C.A.V. LIMITED
         #START    *,BASE=(13,12)
         LM        R10,R11,0(R1)       * PICK UP PARM ADDR & DCB ADDR
         LTR       R10,R10             * ONLY PARM SUPPLIED ?
         BNM       SKIPOPEN            * NO-OMIT INITIALIZATION OF DCB
         RDJFCB    MF=(E,OPENVTOC)     * READ VTOC JFCB
         MVI       JFCBDSNM,X'04'      * SET UP
         MVC       JFCBDSNM+1(43),JFCBDSNM VTOC DSNAME
         OI        JFCBAREA+52,X'08'   * INDICATE NO JFCB WRITE-BACK
         OPEN      MF=(E,OPENVTOC),TYPE=J    OPEN VTOC
         LA        R11,VTOC            * ADDRESS THE OPENED DCB
SKIPOPEN ST        R11,VTOCDECB+8      * AND SAVE IN DECB
         TM        48(R11),X'10'       * CHECK DCB IS OPEN
         BO        GOODOPEN            * LOOKS OK
ERR1     EQU       *
         ERROR     1
GOODOPEN TM        48(R11),X'02'       * DO I HAVE THE DCB TO MYSELF?
         BO        NOUSER              * I THINK SO
         ERROR     2                   * MAYBE NOT
NOUSER   EQU       *
         OPEN      (PRINTER,OUTPUT)    * OPEN PRINT FILE
         TM        PRINTER+48,X'10'    * TEST THAT OPEN WORKED
         BZ        ERR1                * ERROR OPENING PRINTER
*  SET UP HDR1 LINE FOR HEAD OF PAGE
         MVC       HDR1VOL,JFCBVOLS
         TIME      DEC                 * GET TIME OF JOB
         ST        R0,DWORK+4          * SAVE TIME IN WORKAREA
         ED        HDR1TIME,DWORK+4    * MOVE TO OUTPUT
         SR        R0,R0               * CLEAR OUT R0
         STM       R0,R1,DWORK         * SAVE DECIMAL DATE
         CVB       R1,DWORK            * CONVERT DEC DATE TO BIN
         D         R0,=F'1000'         * SPLIT INTO YEAR & DAY
         ST        R0,DWORK+4          * STORE BINARY DAYS
         STH       R1,DWORK+4          * STORE BINARY YEAR
         BAL       R9,DATECONV         * GO CONVERT DATE
         ED        HDR1DATE,DWORK+4    * THEN USE CNVRTED RESULT
         EJECT
* SETUP TO READ FORMAT 4 DSCB
         L         R3,44(R11)          * PICK UP DEB ADDR FROM DCB
         MVC       VTOCFDAD+1(6),36(R3)  MOVE BBCCHH OF EXTENT START
         MVI       VTOCFDAD+7,1        * POINT TO 1ST RECD = FMT4
         BAL       R9,READDSCB+6       * READ THE FORMAT 4
         CLI       DS1FMTID,C'4'       * IS IT REALLY A FORMAT 4 ?
         BE        MOVEFMT4            * FORTUNATELY, YES
         ERROR     3                   * HOW DID WE GET HERE??
MOVEFMT4 MVC       DS4DATA(71),DS1FMTID  MOVE FORMAT4 DATA TO SPEC AREA
         BAL       R9,POINTF5          * GO DO THE CALCULATION PROPERLY
         LH        R4,46(R3)           * PICK # TRKS IN VTOC FROM DEB
         SR        R5,R5               * CLEAR R5
         IC        R5,DS4DEVDT         * INSERT NO OF DSCB'S PER TRK
         MR        R4,R4               * WHENCE FIND # OF DSCBS IN VTOC
         SH        R5,DS4DSREC         * TAKE OFF THE NO OF FORMAT 0'S
         M         R4,TBLWIDTH         * MULT BY AMT OF CORE PER ENTRY
GETMAIN  GETMAIN   EC,LV=(5),A=TABLADDR  ESTIMATE CORE REQ FOR FORMAT1S
         B         *+4(R15)            * SEE IF CORE WAS AVAILABLE
         B         GOTCORE             * YES - GO BUILD TABLE
* INSUFFICIENT CORE TO SORT FORMAT1 DSCBS - POINT ROUTINE TO PICK UP
* THE SORTED ENTRIES TO THE ROUTINE WHICH READS THEM THE FIRST TIME
         LA        R2,READFMT1         * GET ROUTINE ADDR
         ST        R2,RTNADDR          * SAVE IT
         LA        R2,ENDUP            * GET END-OF-FILE ROUTINE
         ST        R2,EODADDR          * SAVE IT
         B         PRNTDSCB            * AND GO IMMEDIATELY TO PRINT
         EJECT
GOTCORE  EQU       *
         L         R4,TABLADDR
BLDLOOP  BAL       R9,READFMT1         * READ A FORMAT1 DSCB
         MVC       0(1,R4),DS1DSORG    * DSORG IS HI-ORDER SORT-KEY
         NI        0(R4),B'10000000'   * TO DISTINGUISH ISAM FILES
         MVC       1(44,R4),DS1DSNAM   * MOVE DSNAME INTO TABLE
         MVC       45(5,R4),VTOCFDAD+3 * SET RECORD ADDR OF THIS DSCB
         LA        R4,50(R4)           * BUMP TABLE POINTER
         B         BLDLOOP             * AND GO READ NEXT FORMAT 1
VTOCEOD  EQU       *                   * COME HERE WHEN DSCBS EXHAUSTED
         S         R4,TBLWIDTH         * POINT TO LAST TABLE ENTRY
         ST        R4,TABLEND          * SAVE IN #SORT LIST
         CP        FMT1CNT,=P'1'       * HOW MANY DATA SETS ON VOLUME
         BE        VTOCEOD1            * ONLY 1 - BYPASS THE SORT
         BL        PRNTDSCB            * NO FORMAT 1 DSCBS READ
         #SORT     FIELDS=(1,45,CH,A),A=TABLADDR,LENGTH=50 SORT TABLE
VTOCEOD1 EQU       *
         L         R4,TABLADDR         * RESET R4 -> TABLE OF DSCBS
         S         R4,TBLWIDTH         * THEN POINT TO PREVIOUS AREA
         EJECT
PRNTDSCB PUT       PRINTER             * GET A PRINT BUFFER
         USING     HDRLINE,R1
         MVI       0(R1),C' '          * SINGLE SPACE NORMALLY
         SP        LINECNTR,=P'1'      * DECREMENT LINE-COUNTER
         BP        PRINTBR             * NOT HEAD OF PAGE
         MVC       0(133,R1),HDR1      * MOVE IN A PAGE HEADER
         AP        PAGECNTR,=P'1'      * ADD 1 TO PAGE-COUNTER
         ED        HDPAGCNT,PAGECNTR   * AND MOVE TO HEADER LINE
         PUT       PRINTER             * GET BUFFER FOR LINE2
         MVC       0(133,R1),HDR2      * MOVE SECOND LINE
         PUT       PRINTER
         MVC       0(133,R1),HDR3      * MOVE THIRD LINE
         PUT       PRINTER
         ZAP       LINECNTR,MAXLINES   * RESET LINE-COUNTER
         CP        FMT1CNT,=P'1'       * HOW MANY DATA SETS ON VOLUME
         BL        ENDUP               * NO FORMAT 1 DSCBS READ
         MVI       0(R1),C'0'          * FIRST DETAIL LINE DOUBLE SPACE
PRINTBR  NOP       XDPRLPND            * BR IF MULTIPLE EXTENT
         EJECT
GETDSCB  LR        R10,R1              * SAVE POINTER TO BUFFER
         USING     DSNLINE,R10         * AND SET DSECT
         L         R15,RTNADDR         * ADDR OF ROUTINE TO READ DSCB
         BALR      R9,R15              * GO AND DO IT
         MVC       LNDSN,DS1DSNAM      * MOVE DSNAME
         MVC       LNCREDT(88),LNEDMSK * MOVE EDIT MASKS FOR OTHER FLDS
         MVC       DWORK+5(3),DS1CREDT * MOVE CREATION DATE TO WORKAREA
         BAL       R9,DATECONV         * CONVERT IT TO DECIAML
         ED        LNCREDT,DWORK+4     * MOVE TO OUTPUT LINE
         OC        DS1EXPDT,DS1EXPDT   * CHECK FOR ZERO EXPIRY DATE
         BNZ       CNVEXPDT            * NON-ZERO - GO CONVERT IT
         MVC       LNEXPDT+1(8),LNEXPDT  ELSE CLEAR TO SPACES
         B         CNVDSORG            * AND CONTINUE WITH DSORG
CNVEXPDT MVC       DWORK+5(3),DS1EXPDT * MOVE EXPIRY DATE
         BAL       R9,DATECONV         * CONVERT TO DECIMAL
         ED        LNEXPDT,DWORK+4     * MOVE OUTPUT LINE
CNVDSORG EQU       *
         TM        DS1DSORG,B'00000001'  UNMOVABLE DATA?
         BNO       *+8                 * NO - SKIP NEXT INSTR
         MVI       LNDSORGU,C'U'       * INDICATE UNMOVABLE
         LH        R0,DS1DSORG         * LOAD DSORG INTO REG 0
         SLL       R0,16               * AND SHIFT TO LHS OF REG
         LA        R1,7                * LOAD # OF BITS TO TEST
DSORGLP  LTR       R0,R0               * IS HI-ORDER BIT ON?
         BM        DSORGFND            * YES - ASSUME ONLY BIT SET
         SLL       R0,1                * NO - SLIDE NEXT BIT TO SIGN
         BCT       R1,DSORGLP          * AND TEST THAT
DSORGFND SLL       R1,1                * MULTIPLY R1 BY 2
         LA        R2,ORGTYPES(R1)     * USE IT TO ADDRESS TABLE
         MVC       LNDSORG,0(R2)       * MOVE CORRESPONDING DSORG
         EJECT
         LA        R2,LNRECFM          * ADDRESS OUTPUT RECFM
         L         R0,DS1RECFM         * LOAD INPUT RECFM
         LA        R1,FMTYPES          * ADDRESS TABLE OF RECFM TYPES
         LA        R3,7                * NO OF BITS TO TEST
         TM        DS1RECFM,B'11000000'  FIRST CHECK FOR 'U'
         BNO       FMLOOP              * NOT UNDEFINED
         MVI       0(R2),C'U'          * MOVE IN 'U'
         N         R0,=X'3FFFFFFF'     * OFF 'F' & 'V' BITS
         B         FMJUMP              * AND JOIN LOOP
FMLOOP   LTR       R0,R0               * TEST SIGN BIT
         BNM       FMEND               * BIT IS OFF
         MVC       0(1,R2),0(R1)       * MOVE CORRESP CHAR
FMJUMP   LA        R2,1(R2)            * POINT TO NEXT OUTPUT SPOT
FMEND    EQU       *
         LA        R1,1(R1)            * POINT TO NEXT TYPE IN LIST
         SLL       R0,1                * SHIFT OVER NEXT BIT
         BCT       R3,FMLOOP           * AND GO TEST IT
         LH        R0,DS1BLKL          * PICK UP BLKSIZE
         CVD       R0,DWORK            * CONVERT TO DECIMAL
         ED        LNBLKSI,DWORK+5     * MOVE TO OUTPUT
         LH        R0,DS1LRECL         * PICK UP LRECL
         CH        R0,=X'8000'         * IF LRECL = X'8000'
         BNE       NOT32K              * THIS INDICATES  SPANNED RECDS
         MVC       LNLRECL+1(5),=C' >32K'  WITH RECD LENGTH > 32756
         B         CNVKEYLE            * AND THAT'S ALL
NOT32K   CVD       R0,DWORK            * OTHERWISE WE JUST
         ED        LNLRECL,DWORK+5     * MOVE VALUE TO OUTPUT
CNVKEYLE EQU       *
         SR        R0,R0               * CLEAR REGISTER
         IC        R0,DS1KEYL          * INSERT KEYLEN
         CVD       R0,DWORK            * DECIMALISE
         ED        LNKEYLE,DWORK+6     * AND OUTPUT
         EJECT
* PICK UP SECONDARY ALLOCATION TYPE AND QUANTITY
         MVC       DWORK(4),DS1SCALO   * ALIGNMENT
         L         R2,DWORK            * LOAD SECONDARY ALLOC
         LA        R1,0(R2)            * SAVE IN R1 WITH HI-ORDER OFF
         SRL       R2,30               * SHIFT OVER 2 BIT INDICATOR
         LA        R0,0(R2,R2)         * DOUBLE IT
         ALR       R2,R0               * MAKE IT TRIPLE
         BNZ       NOTABSTR            * NOT ABSOLUTE TRACK
         MVC       LNSCALO(10),=C'     ABSTR' INDICATE ABSTR
         B         SECALEND            * FINISHED
NOTABSTR LA        R2,SECTYPES-3(R2)   * ADDRESS BLK, TRK OR CYL
         MVC       LNSCTYPE,0(R2)      * AND MOVE IT TO OUTPUT
         CVD       R1,DWORK            * CNVRT SEC ALLOC QTY
         ED        LNSCALO,DWORK+5     * MOVE TO OUTPUT
SECALEND EQU       *                   * THROUGH WITH SEC ALLOC
         SR        R0,R0               * CLEAR A REG
         IC        R0,DS1NOEPV         * INSERT NO. OF EXTENTS
         CVD       R0,DWORK            * CONVERT TO DECIMAL
         ED        LNNOEXT,DWORK+6     * MOVE TO OUT-PUT LINE
         EJECT
* NOW FOR SOMETHING TRICKY AFTER ALL THOSE STRAIGHTFORWARD EDITS
*  - FIND THE NUMBER OF TRACKS ALLOCATED
         MVC       LASTBLK,DS1LSTAR    * FIRST SAVE LAST-BLK POINTER
         XC        XTNTAREA,XTNAREA    * CLEAR AREA
         MVC       XTNTAREA(30),DS1EXT1  MOVE 1ST 3 EXTENT DESCRIPTS
CHKCHAIN OC        DS1PTRDS,DS1PTRDS   * IS THERE A FORMAT2 OR 3 ?
         BZ        NOCHAIN             * NO - CHAINING NOT NECC
         MVC       VTOCFDAD+3(5),DS1PTRDS * YES - SET ADDRESS
         BAL       R9,READDSCB+6       * AND READ FORMAT3
         CLI       DS1FMTID,C'3'       * IS IT A FORMAT 3?
         BNE       CHKCHAIN            * NO SO CHAIN AGAIN
         MVC       XTNTAREA+30(40),DS1DSNAM+4 MOVE EXTENTS 4 THRU 7
         MVC       XTNTAREA+70(90),DS1DSSN    MOVE EXTENTS 8 THRU 16
NOCHAIN  EQU       *
         LA        R5,XTNAREA          * SET UP BEGINNING,
         LA        R6,10                   INCREMENT,
         LA        R7,XTNTAREA+150           AND END POINTER FOR LOOP
         SR        R0,R0               * ZERO REGISTER TO STORE RESULT
XTNTLOOP CLI       0(R5),X'00'         * IS THIS A VALID EXTENT?
         BE        XTNTEXIT            * NO
         LH        R1,6(R5)            * PICK UP CC FOR EXTENT END
         SH        R1,2(R5)            * SUBTRACT CC FOR EXTENT START
         MH        R1,DS4DEVSZ+2       * MULTIPLY BY # TRKS/CYL
         AH        R1,8(R5)            * ADD HH FOR EXTENT END
         SH        R1,4(R5)            * SUBTRACT HH FOR EXTENT START
         LA        R1,1(R1)            * ALLOW FOR LAST TRK OF EXTENT
         STH       R1,6(R5)            * SAVE # OF TRKS IN TABLE
         AR        R0,R1               * ADD IN TO TOTAL TRKS
         BXLE      R5,R6,XTNTLOOP      * CHECK NEXT EXTENT
XTNTEXIT SR        R5,R6               * POINT R5 BACK TO LAST EXTENT
         LR        R7,R5               * RESET BXLE LIMIT
         CVD       R0,DWORK            * CNVERT NO. OF TRKS
         ED        LNNOTRKS,DWORK+5    * AND MOVE TO OUTPUT
         BNZ       CNVUSAGE            * OFF TO CONVERT % USAGE
         MVC       LNUSAGE+1(3),LNUSAGE  EXCEPT WHEN INDETERMINATE
         B         XDPRNT              * BECAUSE ZERO ALLOC
         EJECT
CNVUSAGE LH        R3,LASTBLK          * PICK UP TT OF LAST BLOCK
         LA        R3,1(R3)            * ALLOW FOR LAST (PART-USED) TRK
         MH        R3,DS4DEVTK         * CONVERT TO # BYTES USED
         MH        R0,DS4DEVTK         * ALSO CONVERT TOTAL ALLOC
         LR        R1,R0               @ COPY TOTAL BYTES ALLOC
         SRL       R1,1                * HALVE IT
         MVC       DWORK+6(2),LASTBLK+3  MOVE FOR ALIGNMENT
         SH        R3,DWORK+6          * SUBTRACT TRACK BALANCE
         M         R2,=F'100'          * MULT BY 100 FOR PERCENT
         AR        R3,R1               * ROUND UP BY HALF TOTAL ALLOC
         DR        R2,R0               * AND DIVIDE BY TOTAL ALLOCATION
         CVD       R3,DWORK            * CNVERT RESULT TO DECIMAL
         ED        LNUSAGE,DWORK+6     * THEN MOVE TO OUTPUT LINE
XDPRNT   LA        R5,XTNTAREA         * RESET PNTR TO WORKAREA
XDPRLOOP SR        R0,R0               * CLEAR WORK REG
         IC        R0,1(R5)            * OBTAIN EXTENT NUMBER (M)
         CVD       R0,DWORK            * CONVERT TO DECIMAL
         ED        LNXDM,DWORK+6       * MOVE TO LINE
         LH        R15,2(R5)           * PICK UP CYL ADDRESS IN HEX
         CVD       R15,DWORK           * GET IN PACKED DECIMAL
         ED        LNXDCCHH(4),DWORK+6 * SET CYL ADDRESS IN PRINT LINE
         LH        R15,4(R5)           * PICK UP TRK ADDRESS IN HEX
         CVD       R15,DWORK           * GET IN PACKED DECIMAL
         ED        LNXDCCHH+4(4),DWORK+6 * SET CYL ADD IN PRINT LINE
         LH        R0,6(R5)            * PICK UP # TRKS
         CVD       R0,DWORK            * CONVERT
         ED        LNXD#TRK,DWORK+5    * AND EDIT TO LINE
         BXH       R5,R6,PRNTDSCB      * FINISH IF ALL EXTENTS DONE
         MVI       PRINTBR+1,X'F0'     * MAKE A BRANCH
         B         PRNTDSCB            * GO PRINT A LINE
XDPRLPND MVI       PRINTBR+1,X'00'     * RESET TO NOP
         LR        R10,R1              * SET BUFFER POINTER
         MVI       LNCC+1,C' '         * INITIALISE
         MVC       LNCC+2(112),LNCC    * TO SPACES
         MVC       LNXDM(19),LNEXTDSC  * MOVE IN NEW EDIT MSK
         B         XDPRLOOP            * CONTINUE WITH NEXT EXTENT
         EJECT
READDSCB MVC       VTOCFDAD,VTOCNEXT   * MOVE ADDRESS OF NEXT DSCB
         READ      VTOCDECB,DIR,VTOC,DS1FMTID,'S',DS1DSNAM,            *
               VTOCFDAD,VTOCNEXT
         CHECK     VTOCDECB            * WAIT FOR IT TO ARRIVE
         TM    VTOCDECB+1,B'10000100'  * NO RECD FND / EOF
         L         R15,EODADDR         * PICK UP EODAD
         BCR       7,R15               * GO THERE IF NRF OR EOF
POINTF5  EQU       *
         MVC       VTOCNEXT,VTOCFDAD   * MOVE OLD DISC ADDRESS
         SR        R15,R15             * CLEAR R15
         SR        R1,R1               * AND R1
         LA        R0,1                * SET R0 TO 1
         IC        R15,VTOCNEXT+7      * PICK UP RECD NO. ON TRK
         IC        R1,DS4DEVDT         * PICK UP MAX RECDS PER TRK
         BXH       R15,R0,NEXTTRK      * BRANCH IF HIGH
         STC       R15,VTOCNEXT+7      * ELSE SAVE BUMPED VALUE
         BR        R9                  * THEN RETURN
NEXTTRK  MVI       VTOCNEXT+7,1        * RESET R TO 1
         LH        R15,VTOCNEXT+5      * PICK UP CC
         LH        R1,DS4DEVSZ+2       * AND NO. TRKS/CYL
         BCTR      R1,0                * MINUS ONE
         BXH       R15,R0,NEXTCYL      * BUMP AND TEST
         STH       R15,VTOCNEXT+5      * SAVE INCREMENTED VALUE
         BR        R9                  * AND EXIT
NEXTCYL  AH        R0,VTOCNEXT+3       * ADD 1 TO CC
         SLL       R0,16               * INSERT ZEROS ON RIGHT
         ST        R0,VTOCNEXT+3       * SAVE NEW CCHH
         BR        R9                  * THEN RETURN
         EJECT
READFMT1 EQU       *                   * READ A FORMAT 1
         LR        R3,R9               * SAVE LINK REG
TSTHPCHR CLC       VTOCFDAD+3(5),DS4HPCHR IS ADDR HIGHER THAN
*                                            HIGHEST FORMAT 1 ?
         L         R15,EODADDR         * PICK UP EODAD
         BCR       2,R15               * GO THERE IF FINISHED
         BAL       R9,READDSCB         * READ A DSCB
         CLI       DS1FMTID,C'1'       * IS IT A FORMAT1?
         BNE       TSTHPCHR            * IF NO - TRY AGAIN
         AP        FMT1CNT,=P'1'       * INCLUDE THIS DSCB IN COUNT
         LR        R9,R3               * RESTORE LINK
         BR        R9                  * AND RETURN
         EJECT
READTABL EQU       *
         LA        R4,50(R4)           * BUMP POINTER
         C         R4,TABLEND          * FINISHED ?
         BH        ENDUP               * YES
         MVC       VTOCFDAD+3(5),45(R4)  MOVE CCHHR FROM TABLE
         B         READDSCB+6          * GO READ NEXT DSCB
         EJECT
ENDUP    ED        FLINE1CT,FMT1CNT+1  * SET NO OF DATA SETS IN PRT LNE
         MVC       0(133,R10),FLINE1   * SET PRINT LINE PROPER
         CLOSE     (VTOC,,PRINTER)     * CLOSE FILES
         L         R13,4(R13)          * RESTORE R13
         LM        R14,R12,12(R13)     * AND THE REST
         BR        R14                 * AND RETURN TO CALLER
         EJECT
* DATE CONVERSION - DATE IN FORMAT YDD IS ASSUMED TO BE IN LAST
*                   THREE BYTES OF DWORK
DATECONV EQU       *                   * CONVERT DATE TO DECIMAL
         LA        R0,28               * LOAD 28 DAYS FOR FEBRUARY
         TM        DWORK+5,3           * TEST FOR LEAP YEAR
         BNZ       *+8                 * NO -SKIP NEXT INSTR
         LA        R0,29               * YES - 29 DAYS IN FEB
         STH       R0,DATETABL+2       * STORE FEB DAYS
         LA        R15,DATETABL        * POINT TO TABLE START
         LA        R1,DATETABL+22      * AND TABLE END
         LA        R0,2                * LOAD BXLE INCREMENT
         LH        R14,DWORK+6         * PICK UP # DAYS IN YEAR
DATELOOP SH        R14,0(R15)          * SUBTRACT TABLE ENTRY
         BNP       MNTHFND             * IF -VE, HAVE HIT REQD MONTH
         BXLE      R15,R0,DATELOOP     * ELSE LOOP AGAIN
         XC        DWORK,DWORK         * IF NO MATCH, THEN ERROR
         BR        R9                  * SO RETURN
MNTHFND  AH        R14,0(R15)          * ALLOW FOR LAST SUBTRACT
         S         R15,=A(DATETABL-2)  * FIND TABLE DISPLACEMENT
         MH        R15,=H'50'          * OBTAIN MONTH*100
         MH        R14,=H'10000'       * AND DAY*10000
         SR        R0,R0               * CLEAR R0
         IC        R0,DWORK+5          * GET YEAR NO. 000000YY
         AR        R0,R15              * ADD MONTH    0000MMYY
         AR        R0,R14              * AND DAY      00DDMMYY
         CVD       R0,DWORK            * CONVERT      0DDMMYYC
         MVO       DWORK,DWORK         * AND SHIFT    DDMMYYCC
         BR        R9                  * RETURN FOR EDIT
DATETABL DC        H'31,28,31,30,31,30'  TABLE USED TO FIND
         DC        H'31,31,30,31,30,31'  THE NUMBER OF THE MONTH
         EJECT
IOERR    EQU       *                   * SYNAD ROUTINE
         USING     *,R15               * R13 IS CLOBBERED
         SYNADAF   ACSMETH=BDAM        * PERFORM SYSTEM ERROR ANALYSIS
         MVC       SYNERMSG(60),68(R1) * MOVE USEFUL PART OF SYSMSG
         MVC       SYNADVOL,JFCBVOLS   * SET VOL SER NO IN MESSAGE
         WTO       MF=(E,SYNADMSG)     * ISSUE ERROR MESSAGE
         BALR      R15,0               * R15 DESTROYED BY WTO
         USING     *,R15               * SO BASE MUST BE RESET
         MVI       DS1FMTID,X'00'      * ENSURE BAD DSCB IGNORED
         ABEND     1,DUMP,,SYNADMSG
         SYNADRLS  ,                   * RESTORE R13
         DROP      R15                 * RELEASE R15
         BR        R14                 * RETURN TO CHECK ROUTINE
         EJECT
DWORK    DC        D'0'                * WORKAREA
VTOCFDAD DC        D'0'                * FULL DISC ADDR - MBBCCHHR
TABLADDR DC        A(0)                * ADDRESS OF TABLE OF DSCB'S
TBLWIDTH DC        A(50)               * SIZE OF TABLE ENTRY
TABLEND  DC        A(0)                * END OF TABLE
RTNADDR  DC        A(READTABL)         * DEFAULT ROUTINE
EODADDR  DC        A(VTOCEOD)          * END-OF-FILE ROUTINE
FMT1CNT  DC        PL4'0'              * NO OF FORMAT 1 DSCBS READ
LASTBLK  DC        XL5'00'             * SAVEAREA FOR LAST BLOCK PNTR
VTOCNEXT DC        XL8'00'             * MUST ALIGN AT FULLWD+1
LINECNTR DC        P'000'
MAXLINES DC        P'55'
PAGECNTR DC        P'000'
FMTYPES  DC        CL8'FVTBSAM'        * PERMISSIBLE RECFM'S
ORGTYPES DC        C'  POMQCQCXDAPSIS' * DSORG TYPES
SECTYPES DC        C'BLKTRKCYL'        * TYPES OF ALLOCATION
LNEDMSK  DS        0CL88               * EDIT MASK FOR DSN OUTPUT LINE
         DC        2X'402120612020612020' * CREATION DATE/EXPIRY DATE
         DC        C' '
         DC        CL3' '                 * DSORG(U)
         DC        C' '
         DC        CL5' '                 * RECFM
         DC        X'402020202020'        * BLKSIZE
         DC        X'402020202020'        * LRECL
         DC        X'40202020'            * KEYLEN
         DC        C' '
         DC        X'402020202120'        * TRKS ALLOC
         DC        X'40202120'            * PERCENT USE
         DC        X'40202120'            * NUMBER OF EXTENTS
         DC        X'402020202120'        * SECONDARY EXTENT QUANTITY
         DC        C' '
         DC        CL3' '                 * SECONDARY EXTENT TYPE
LNEXTDSC DS        0CL19                  * EXTENT DESCRIPTION
         DC        X'40202120'               * EXTENT NUMBER
         DC        C' '
         DC        X'4020212040202120' CCHH OF EXTENT
         DC        X'402020202120'           * NO OF TRKS IN EXTENT
         PRINT     NOGEN
PRINTER  DCB       DDNAME=SYSPRINT,DSORG=PS,MACRF=PL,LRECL=133,        *
               BLKSIZE=133,RECFM=FBA
VTOC     DCB   DDNAME=SYSUT1,DSORG=DA,MACRF=RIC,OPTCD=A,               *
               SYNAD=IOERR,RECFM=FS,BLKSIZE=96,KEYLEN=44,EXLST=VTOCXLST
OPENVTOC OPEN      (VTOC,INPUT),MF=L   * LIST FOR E-TYPE OPEN, RDJFCB
VTOCXLST DC        X'87',AL3(JFCBAREA) * JFCB ENTRY IN EXIT LIST
SYNADMSG DC        AL2(JFCBDSNM+44-*,0)  WTO RECD DESCRIPTOR WORD
         DC        C'VTOCLIST - I/O ERROR READING VTOC ON '
SYNADVOL DC        C'******'
         DC        C', SYNADAF INFO ='
SYNERMSG DC        CL16' '             * INITIALISE TO SPACES
         ORG       *-4                 * BACKSPACE
         DS        0F                  * ALIGN TO FULLWORD
JFCBAREA DS        0CL176              * SPACE FOR VTOC JFCB
JFCBDSNM DS        CL44                * VTOC DSN - ALSO SYNAD WRKAREA
         DS        CL132               * SPACE FOR REST OF JFCB
JFCBVOLS EQU       JFCBAREA+118        * VOLUME SERIAL NO.
         EJECT
         PRINT     GEN
         DSCB      FORMAT=(1)
DS4DATA  DS        0CL71
         DSCB      FORMAT=(4),KEY=NO
         ORG       DS4DATA+71          * SAVE UNUSED SPACE
         EJECT
HDR1     DC        133C'*'
         ORG       HDR1
         DC        C'1*** CONTENTS OF '
HDR1FILE DC        C'THE VOLUME TABLE OF CONTENTS'
         DC        C' ON VOLUME '
HDR1VOL  DC        C'******'
         DC        C' *** DATE ='
HDR1DATE DC        X'402120612020612020'
         DC        C' *** TIME ='
HDR1TIME DC        X'4021204B20204B2020'
         ORG       HDR1+120
         DC        C'PAGE'
         DC        X'4020202040'
         ORG       HDR1+133
HDR2     DC    CL33'-                                              '
         DC    C'               DATE     DATE   DS-        BLK-    '
         DC    C'   KEY- TRKS   %  NO.   SEC-ALLOC EXTENT-DESCRIPTN.'
HDR3     DC    CL33'    DATASET NAME                               '
         DC    C'              CREATED  EXPIRES ORG RECFM  SIZE LRE'
         DC    C'CL LEN  ALLOC USE EXTS  QTY TYPE  M  CYL TRK #TRKS'
FLINE1   DC        CL15'0 *** THERE ARE'
FLINE1CT DC        X'402020202120'
         DC        CL112' DATA SETS ON THIS VOLUME.'
         LTORG
         DC        0F'0'               * ENSURE XTNTAREA ALIGNED
XTNTAREA DC        XL160'00'
XTNAREA  EQU       XTNTAREA
         EJECT
HDRLINE  DSECT
         DS        CL124
HDPAGCNT DS        XL4
DSNLINE  DSECT
LNCC     DS        C                   * CARRIAGE CONTROL BYTE
LNDSN    DS        CL44                * DATASET NAME
LNCREDT  DS        CL9                 * CREATION DATE
LNEXPDT  DS        CL9                 * EXPIRY DATE
         DS        C
LNDSORG  DS        CL2                 * DSORG
LNDSORGU DS        C                   * UNMOVABLE FLAG
         DS        C
LNRECFM  DS        5C                  * RECFM
LNBLKSI  DS        CL6                 * BLKSIZE
LNLRECL  DS        CL6                 * LRECL
LNKEYLE  DS        CL4                 * KEYLEN
         DS        C
LNNOTRKS DS        CL6                 * TOTAL NO. OF TRKS ALLOCATED
LNUSAGE  DS        CL4                 * PERCENTAGE USE OF ALLOC SPACE
LNNOEXT  DS        CL4                 * NUMBER OF EXTENTS
LNSCALO  DS        CL6                 * SECONDARY ALLOCATION QTY
         DS        C
LNSCTYPE DS        CL3                 * TYPE OF ALLOC - TRK/CYL/BLK
LNXDM    DS        CL4                 * EXTENT-DESCRIPTION - M
         DS        C
LNXDCCHH DS        CL8                 * EXTENT DESCRIPTION - CCHH
LNXD#TRK DS        CL6                 * EXTENT DESCRIPTION - NO OF TRK
         END
