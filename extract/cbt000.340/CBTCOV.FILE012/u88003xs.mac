         TITLE 'RARTRACE - ADD ANY ENTRIES TO TRACE - INFORM USER'
*
*   RARTRACE
*   ~~~~~~~~
*        ANALYSE FDRDSF OUTPUT TO SEE IF ARCHIVE & RETURN HAS BEEN
*        SUCCESSFUL.USERS ARE NOTIFIED VIA NOTIFY(SVC241).
*        FDR MESSAGES ARE WRITTEN TO SYSPRINT
*        FOR ARCHIVE THE TRACE IS UPDATED FOR EACH FILE ARCHIVED
*
         MACRO
&LABEL   MSGV  &TEXT
&LABEL.  DC    AL2(&LABEL.L,0)
&LABEL.S DC    C&TEXT.
&LABEL.L EQU   *-&LABEL.
         MEND
         REGISTER
         SUBR  RARTRACE
         L     R11,BASE2
         USING RARTRACE+4096,R11 SET UP ADDRESSABILITY.
         MVI   RC,0              DEFAULT RETURN CODE
         EJECT
*
* OPEN SYSPRINT FOR MESSAGES
*
         OPEN  (DCBSYSP,(OUTPUT)) TRY & OPEN SYSPSRINT O/P
         USING IHADCB,R5
         LA    R5,DCBSYSP
         TM    DCBOFLGS,DCBOFOPN OPEN ?
         BO    SYSPOK
         DROP  R5
         WTO   'RARTR02I UNABLE TO OPEN DATASET - DDNAME=SYSPRINT',    +
               ROUTCDE=1,DESC=3
         B     FAIL
SYSPOK   EQU   *
         OI    FLAG2,FLGSYSP     SET OPEN FLAG.
         EJECT
*
* NOW OPEN FDR OUTPUT FILE FOR ANALYSIS
*
         OPEN  (DCBFDR,(INPUT)) TRY & OPEN FDR O/P FILE.
         LA    R5,DCBFDR
         BAL   R14,TESTOPEN      LOOK TO SEE IF OPEN
         OI    FLAG2,FLGFDR      SET OPEN FLAG.
*
* INITIALIZE FDR CONTROL CARD MEMORY AREA - THESE CARDS ARE PUT ASIDE
* UNTIL THE RUN HAS BEEN PROVED SUCCESSFULL
* R5-> MEMORY CHAIN
*
         ZERO  CHAIN,4           MARK CHAIN AS NULL
NEWRUN   EQU   *
         BAL   R14,CHKLAST       MAKE SURE ALL PREVIOUS RECORDS DONE
         LA    R5,CHAIN
         ZERO  CURENTNO,4        SAY NO ENTRIES IN MEMORY
         EJECT
*
* SCAN THE FDR LOG FOR RECOGNISABLE MESSAGES
* R4->FDRLOG RECORD
*
GETFDR   EQU   *
         GET   DCBFDR              READ FDR MESSAGE
         LR    R4,R1               REMEMBER RECORD POINTER
         MVC   PRTFDRM,0(R4)       FOR PRINTING
MESGCHK  EQU   *
         L     R2,MSGCOUNT         NO OF MESSAGES WE DEAL WITH
         LA    R3,MSGTABLE         TABLE OF MESSAGES AND ROUTINE ADDRS
MESGSRCH EQU   *
         CLC   =C'FDR',1(R4)       CHECK IT IS AN FDR MESSAGE
         BNE   PRINTFDR            IF NOT IGNORE IT
         CLC   0(3,R3),4(R4)       ONE OF OUR MESSAGES ?
         BE    MSGMATCH
         INCR  R3,7                LOOK AT NEXT IN TABLE
         BCT   R2,MESGSRCH
PRINTFDR EQU   *
         PUT   DCBSYSP,PRTFDR      PRINT ALL OTHER MESSAGES FROM FDR
UNKFDR   EQU   *
         PUT   DCBSYSP,MSG66       UNEXPECTED MESSAGE NUMBER
         MVI   RC,12
         B     GETFDR
*
*        USEFUL FDR MESSAGE GET BRANCH ADDRESS & GO THERE
*
MSGMATCH EQU   *
         L     R3,3(R3)            GET BRANCH ADDRESS
         BR    R3                  AND GO TO IT
         EJECT
*
* NORMAL SEQUENCE OF MESSAGES FROM FDR DUMP IS AS FOLLOWS
*    FDR101 TITLE
*    FDR303 CONTROL CARD     DUMP    TYPE=DSF
*    FDR303 CONTROL CARD    S DSN=???      )
*    FDR303 CONTROL CARD   *               ) REPEATED FOR EACH DATASET
*           ...
*    FDR101 TITLE
*    FDR392 DATASET SELECTED  REPEATED FOR EACH DATASET SELECTED
*           ...
*    FDR007 STARTING TIME
*    FDR007 ENDING TIME
*    FDR122 HEADINGS FOR LINE BELOW
*    FDR122 DUMP STATISTICS
*    FDR107 DUMP SUCCESSFULL
*     FDR101 TITLE                 ONLY IF LINES EXIST BELOW
*     FDR316 DATASET NOT SELECTED  REPEATED FOR EACH NOT SELECTED
*            ...
*
* NORMAL SEQUENCE OF MESSAGES FROM FDR RETURN IS AS FOLLOWS
*    FDR101 TITLE
*    FDR303 CONTROL CARD     RESTORE TYPE=DSF
*    FDR303 CONTROL CARD    S DSN=???
*    FDR303 CONTROL CARD   * NEWNAME=??? (* INCLUDED IF NO NEWNAME)
*    FDR101 TITLE
*    FDR110 RESTORE DSN SELECTED
*    FDR007 STARTING TIME
*    FDR007 ENDING TIME
*    FDR107 RESTORE SUCCESSFULL
*
* USER FAILURE SEQUENCE OF MESSAGES FROM FDR RETURN IS AS FOLLOWS
*    FDR101 TITLE
*    FDR303 CONTROL CARD     RESTORE TYPE=DSF
*    FDR303 CONTROL CARD    S DSN=???
*    FDR303 CONTROL CARD   * NEWNAME=??? (* INCLUDED IF NO NEWNAME)
*    FDR101 TITLE
*    FDR110 RESTORE DSN SELECTED
*    FDR007 STARTING TIME
*    FDR106 DATASET NOT ON DISK
*     OR
*    FDR111 DATASET TOO SMALL (WITH OTHER FDR111 LINES GIVING DETAILS)
*    FDR101 TITLE
*    FDR319 ABEND 1F6 (CONTROL STMT IN ERROR)
         EJECT
*
* FDR101
*
* HERE TO GET THE DATE FROM RUN.
*
GETDATE  EQU   *
         TM    FLAG1,FLGDATE        SEEN IT BEFORE ?
         BNZ   GETFDR               YES, DONT DO THIS.
         PUT   DCBSYSP,PRTFDR       PRINT THIS MESSAGE ONCE ONLY
GETABYTE EQU   *                    SCAN ALONG LINE LOOKING FOR DATE
         INCR  R4                   INCREMENT POINTER.
         CLC   =C'DATE=',0(R4)      FOUND IT ?
         BNE   GETABYTE             BRANCH IF NOT.
         MVC   DATE,5(R4)           SAVE DATE OF RUN
         OI    FLAG1,FLGDATE
         B     GETFDR
         EJECT
*
* FDR303
*
*       SAVE CONTROL CARDS IN MEMORY AREA FOR LATER CHECK AFTER
*       VERIFYING THAT RUN WAS OK.
*
CNTRLCRD EQU   *
         LA    R6,23(R4)           POINT TO CONTROL CARD
         USING FDRCNTL,R6
         CLI   FDR1ID,C'1'         TYPE 1 CARD ?
         BE    GETTYPE             DONT NEED TO SAVE THIS
         PUT   DCBSYSP,PRTFDR      PRINT THIS MESSAGE
         CLI   FDR2ID,C'2'         TYPE 2 CARD ?
         BNE   UNKFDR              IF NOT WE ARE OUT OF SEQUENCE
         LR    R7,R5               REMEMBER LAST BLOCK POINTER
         LT    R5,0(R5)            GET ADDRESS OF NEXT BLOCK
         BNZ   GOTBLOCK            SEE IF THERE IS ONE
         GETMAIN RU,LV=164         GET A BLOCK OF MEMORY
         ST    R1,0(R7)            CHAIN IT OFF THE PREVIOUS ONE
         ZR    R5
         ST    R5,0(R1)            KILL THE END OF THE CHAIN
         LR    R5,R1               GET BUFFER POINTER
GOTBLOCK EQU   *
         MVC   4(80,R5),FDRR2      SAVE CONTROL CARD
         L     R7,CURENTNO         GET COUNT OF CARDS
         INCR  R7
         ST    R7,CURENTNO         SAVE NO OF ENTRIES
         EJECT
*
* FIND AND SAVE LENGTH OF DSN FOR LATER AND READ SECOND CARD
*
         LA    R6,4(R5)            ADDRESS OF CARD
         LA    R7,FDR2DSN          POINT TO DSN
         BAL   R14,COUNT           COUNT THE LENGTH
         DECR  R7                  LESS 1 FOR CONVENIENCE
         STC   R7,1(R6)            SAVE LENGTH HERE
         GET   DCBFDR              READ NEXT FDR MESSAGE
         LR    R4,R1               REMEMBER RECORD POINTER
         MVC   PRTFDRM,0(R4)       FOR PRINTING
         CLC   =C'FDR303',1(R4)    IS IT THE SAME AGAIN
         BNE   MESGCHK             WE ARE OUT OF SEQ TRY TO GET BACK
         LA    R6,23(R4)           POINT TO CONTROL CARD
         CLI   FDR3ID,C'3'         TYPE 3 CARD ?
         BNE   CNTRLCRD            WE ARE OUT OF SEQ TRY TO GET BACK
         PUT   DCBSYSP,PRTFDR      PRINT THIS MESSAGE
         MVC   84(80,R5),FDRR3     SAVE CONTROL CARD
         B     GETFDR
         EJECT
*
* FIND OUT WHAT TYPE OF RUN WE HAVE GOT (DUMP OR RETURN)
*
GETTYPE  EQU   *
         TM    FLAG2,FLGDUMP+FLGRETN DO WE ALREADY KNOW THE TYPE
         BNZ   NEWRUN              ALL INPUT MUST BE OF THE SAME TYPE
         PUT   DCBSYSP,PRTFDR      PRINT THIS MESSAGE ONCE ONLY
         CLC   FDR1TYPE,=C'DUMP   ' IS IT A DUMP RUN
         BNE   TYPERETN             IF NOT IT MUST BE RESTORE
         OI    FLAG2,FLGDUMP        MARK AS DUMP RUN
         MVC   SENDMSG+1(3),=C'ARC' CHANGE NOTIFY MESSAGE HEADER
         B     NEWRUN               THIS MARKS THE START OF A NEW RUN
TYPERETN EQU   *
         OI    FLAG2,FLGRETN        MARK AS RETURN RUN
         B     NEWRUN               AND START A NEW RUN
         DROP  R6
         EJECT
*
* FDR392/FDR110
*
* HERE WE MARK ALL THE DATASETS THAT WERE SELECTED FOR ACTION
*
SELECT   EQU   *
         PUT   DCBSYSP,PRTFDR      PRINT THIS MESSAGE
         BAL   R14,GETRECOR        R6 POINTS TO FDR CONTROL CARDS
         MVI   0(R6),C'+'          INSERT A MARKER TO SAY OK
         B     GETFDR
         EJECT
*
* FDR107
*
* THE OPERATION HAS BEEN SUCCESSFULL
* NOW WE TAKE ALL THE CONTROL CARDS AND GENERATE TRACE RECORDS FOR THEM
*
TRACELOG EQU   *
         PUT   DCBSYSP,PRTFDR      PRINT THIS MESSAGE
         LT    R9,CURENTNO         NO OF CARDS FOR THIS RUN
         BZ    GETFDR              IF NONE THEN NOTHING TO DO
         TM    FLAG2,FLGDUMP       IS IT A DUMP RUN ?
         BZ    RETURN2             DIFFERENT ACTION FOR RETURN
         TM    FLAG2,FLGTRACE      TRACE OPENED ?
         BO    ADDTRACE
         OPEN  (ACBTRACE)
         LTR   R15,R15
         BNZ   ERRORVOC
         OI    FLAG2,FLGTRACE      SET FLAG FOR OPEN
ADDTRACE EQU   *
         EJECT
*
* SCAN THE MEMORY OF CONTROL CARDS, ADD A TRACE RECORD AND NOTIFY
* THE USER FOR EACH SUCCESSFULL ARCHIVE DONE. SKIP THE ONES NOT
* SELECTED FOR THE MOMENT
*
         LA    R5,CHAIN            GET START OF BUFFER CHAIN
FTESTBLK EQU   *
         LT    R5,0(R5)            GET NEXT BLOCK
         BZ    GMEMERR             IF NONE THEN INTERNAL ERROR
         CLI   4(R5),C'+'          WAS DSN SELECTED
         BE    SELFOUND
SELNEXT  EQU   *
         BCT   R9,FTESTBLK
         B     GETFDR              ALL DONE NOW
SELFOUND EQU   *
         LA    R6,4(R5)            POINT TO RECORD
         EJECT
*
* INSERT REQUIRED INFORMATION ONTO TRACE RECORD
*
         USING FDRCNTL,R6
         MVC   TRACEDSN,FDR2DSN          DSN
         MVC   TRACEDSK,FDR2DSK          XFER VOLID.
         MVC   TRACEUSR,FDR2USR          XFER USERID.
         MVC   TRACETPE,FDR2TPE          XFER TAPE VOLID
         MVC   TRACELBL,FDR2LBL          XFER TAPE LABEL.
         INCR  R6,80               NEXT CARD
         MVC   TRACEKEY,FDR3KEY    SAVE KEY
         DROP  R6
         MVC   TRACEDAT,DATE
         EJECT
*
* USE OBTAIN TO GET THE DSCBS REQUIRED FOR THE TRACE
*
         OBTAIN DSCB1OB
         LA    R3,TRACEDS1
         USING IECSDSL1+44,R3      ADDRESS DSCB1
         CLI   DS1NOEPV,X'03'
         BNH   NOEXTNT
         MVC   CCHHR,DS1PTRDS      POINTER TO NEXT DSCB
         OBTAIN DSCB3OB
NOEXTNT  EQU   *
         DROP  R3
         MVC   VOLSER,TRACEDSK           GET DEVICE CHARACTERISTICS
         BAL   R14,DEVCHAR               FOR VOLUME
         MVC   TRACEDVC,DISKTYPE         SAVE THE DEVICE TYPE.
         PUT   RPL=RPLTRACE
         LTR   R15,R15
         BNZ   PUTVSERR
         EJECT
*
* INFORM THE USERS OF OUR SUCCESS
*
         LA    R1,TRACEDSN         SET UP PARM LIST FOR SEND
         ST    R1,SENDPARM
         LA    R1,TRACEUSR
         ST    R1,SENDPARM+4
         LA    R1,MESARC
         ST    R1,SENDPARM+8
         LA    R1,MSARCL
         ST    R1,SENDPARM+12
         LA    R1,SENDPARM
         BAL   R14,SENDMESG        PROCESS MESSAGE & ISSUE SVC TO SEND
         B     SELNEXT             RETURN TO DO NEXT
         EJECT
*
* FDR107
*
* SCAN THE MEMORY OF CONTROL CARDS (THERE WILL BE ONLY ONE) INFORM
* THE USER FOR SUCCESSFULL RETURN DONE. SKIP THE IF NOT
* SELECTED FOR THE MOMENT
*
RETURN2  EQU   *
         LT    R5,CHAIN            GET START OF BUFFER CHAIN
         BZ    GMEMERR             IF NONE THEN INTERNAL ERROR
         CLI   4(R5),C'+'          WAS DSN SELECTED
         BNE   GETFDR              IGNORE IT FOR THE MOMENT
         LA    R6,4(R5)            POINT TO RECORD
*
* INFORM THE USERS OF OUR SUCCESS
*
         USING FDRCNTL,R6
         LA    R1,FDR2DSN          SET UP PARM LIST FOR SEND
         ST    R1,SENDPARM
         LA    R1,FDR2USR
         DROP  R6
         ST    R1,SENDPARM+4
         LA    R1,MESRET
         ST    R1,SENDPARM+8
         LA    R1,MSRETL
         ST    R1,SENDPARM+12
         LA    R1,SENDPARM
         BAL   R14,SENDMESG        PROCESS MESSAGE & ISSUE SVC TO SEND
         B     GETFDR              LOOK AT NEXT FDR MESSAGE
         EJECT
*
* FDR316
*
* HERE IF DSN NOT SELECTED BY FDR
*
DSNOTFND EQU      *
         PUT   DCBSYSP,PRTFDR      PRINT THIS MESSAGE
         BAL   R14,GETRECOR         FIND RECORD IN QUEUE
         USING FDRCNTL,R6
         LA    R1,FDR2DSN          SET UP PARM LIST FOR SEND
         ST    R1,SENDPARM
         LA    R1,FDR2USR
         DROP  R6
         ST    R1,SENDPARM+4
         LA    R1,MES316
         ST    R1,SENDPARM+8
         LA    R1,MS316L
         ST    R1,SENDPARM+12
         LA    R1,SENDPARM
         BAL   R14,SENDMESG        PROCESS MESSAGE & ISSUE SVC TO SEND
         MVI   4(R5),C'-'          SAY WE HAVE PROCESSED IT
         MVI   RC,8                USER ERROR
         B     GETFDR               BACK FOR MORE.
         EJECT
*
* FDR106 & FDR111
*
* HERE IF DATASET NOT FOUND ON INDICATED DISK FOR RESTORE
* THIS IS PROBABLY CAUSED BY THE USER DELETEING IT DURING ARCHRET RUN
*
DSMISS   EQU      *
         PUT   DCBSYSP,PRTFDR      PRINT THIS MESSAGE
         LT    R5,CHAIN            MUST BE FIRST ENTRY IN MEMORY
         BZ    GMEMERR             IF NOT INTERNAL ERROR
         CLI   4(R5),C'-'          HAVE WE ALREADY SAID IN ERROR
         BE    GETFDR              IF SO THEN SKIP IT
         LA    R6,4(R5)            POINT TO RECCORD
         USING FDRCNTL,R6
         LA    R1,FDR2DSN          SET UP PARM LIST FOR SEND
         ST    R1,SENDPARM
         LA    R1,FDR2USR
         DROP  R6
         ST    R1,SENDPARM+4
         LA    R1,MESMISS
         ST    R1,SENDPARM+8
         LA    R1,MESMISSL
         ST    R1,SENDPARM+12
         LA    R1,SENDPARM
         BAL   R14,SENDMESG        PROCESS MESSAGE & ISSUE SVC TO SEND
         MVI   4(R5),C'-'          SAY WE HAVE PROCESSED IT
         MVI   RC,8                USER ERROR
         B     GETFDR              BACK FOR MORE.
         EJECT
*
* FDR319
*
* HERE IF FDR ABENDED
* IF WE HAVE ALREADY DETECTED AN ERROR THEN SUPPRESS THIS MESSAGE
*
ABEND    EQU      *
         CLI   RC,8                 ERROR ?
         BNL   GETFDR               IF SO THEN SUPPRESS IT
         B     PRINTFDR             OTHERWISE IT IS ALL WRONG
         EJECT
*
* HERE FOR VSAM FAILURES IN OPEN/CLOSE
*
ERRORVOC EQU   *
         ST    R15,SAVEDR14        SAVE RETURN CODE
         PRINT NOGEN
         SHOWCB ACB=ACBTRACE,AREA=FDBK,LENGTH=4,FIELDS=ERROR
         PRINT GEN
         LTR   R15,R15
         BNZ   ERRORVS
         L     R15,SAVEDR14        RESTORE RETURN CODE
         L     R0,FDBK             GET ERROR CODE
*
* HERE FOR VSAM FAILURES IN SHOWCB (AND OPEN/CLOSE EVENTUALLY)
*        ERROR CODE IN R0, RETURN CODE IN R15
*
ERRORVS  EQU   *
         LR    R1,R15              GET RETURN CODE
         BAL   R14,BINDEC          CONVERT TO DECIMAL
         MVC   MSG03RC,13(R1)      INSERT INTO MESSAGE
         LR    R1,R0               GET ERROR CODE
         BAL   R14,BINDEC          CONVERT TO DECIMAL
         MVC   MSG03ERR,13(R1)     INSERT INTO MESSAGE
         PUT   DCBSYSP,MSG03
         B     FAIL
         EJECT
*
* HERE FOR ERROR WRITING TO TRACE FILE
*
PUTVSERR EQU   *
         ST    R15,SAVEDR14     SAVE RETURN CODE TEMPORARILY
         PRINT NOGEN
         SHOWCB RPL=RPLTRACE,AREA=FDBK,LENGTH=4,FIELDS=FDBK
         PRINT GEN
         LTR   R15,R15
         BNZ   ERRORVS
         L     R1,SAVEDR14      RECOVER RETURN CODE
         BAL   R14,BINDEC       CONVERT TO DECIMAL
         MVC   MSG04RC,13(R1)   INSERT INTO MESSAGE
         ZR    R1
         IC    R1,FDBK+3        GET FEED BACK CODE
         BAL   R14,BINDEC       CONVERT TO DECIMAL
         MVC   MSG04FDB,13(R1)  INSERT INTO MESSAGE
         PUT   DCBSYSP,MSG04
         B     FAIL
         EJECT
*
* HERE IF END OF FDR LOG REACHED. - CLOSE TRACE FILE
*
FINISH   EQU   *
         PUT   DCBSYSP,MSG61     "LOG ANALYSIS COMPLETE"
         TM    FLAG2,FLGTRACE    TRACE OPEN ?
         BZ    FINISH1           BRANCH IF NOT.
         CLOSE (ACBTRACE)        CLOSE TRACE
         LTR   R15,R15           OK?
         BNZ   ERRORVOC
         NI    FLAG2,X'FF'-FLGTRACE TURN OFF FLAG
         PUT   DCBSYSP,MSG62     "TRACE UPDATE COMPLETE"
FINISH1  EQU   *
*
* FREE CONTROL CARD MEMORY
*
         BAL   R14,CHKLAST       FIRST CHECK ALL RECORDS PROCESSED
         L     R5,CHAIN
FREEG1   EQU   *
         LTR   R1,R5             ZERO=END OF CHAIN
         BZ    ENDFREE
         L     R5,0(R1)          GET ADDRESS NEXT BUFFER
         FREEMAIN RU,LV=164,A=(1)
         B     FREEG1
ENDFREE  EQU   *
         ZERO  CHAIN,4
*
* CLOSE FDRLOG INPUT FILE AND SYSPRINT
*
         CLOSE (DCBFDR)          CLOSE FDR LOG
         NI    FLAG2,X'FF'-FLGFDR TURN OFF FLAG
         CLOSE (DCBSYSP)         CLOSE SYSPRINT DD
         NI    FLAG2,X'FF'-FLGSYSP TURN OFF FLAG
         B     THEEND
         EJECT
*
* HERE FOR ALL FAILURES
*
FAIL     EQU   *
         MVI   RC,16             SET RETURN CODE
         TM    FLAG2,FLGFDR      FDR LOG OPEN ?
         BZ    FAIL1             BRANCH IF NOT.
         CLOSE (DCBFDR)          CLOSE THE LOG FILE.
FAIL1    EQU   *
         L     R5,CHAIN
FAILG1   EQU   *
         LTR   R1,R5             ZERO=END OF CHAIN
         BZ    FAILG2
         L     R5,0(R1)          GET ADDRESS NEXT BUFFER
         FREEMAIN RU,LV=164,A=(1)
         B     FAILG1
FAILG2   EQU   *
         TM    FLAG2,FLGTRACE    TRACE OPEN ?
         BZ    FAIL4             BRANCH IF NOT.
         CLOSE (ACBTRACE)        CLOSE TRACE
FAIL4    EQU   *
         TM    FLAG2,FLGSYSP     SYSPRINT OPEN ?
         BZ    FAIL6             BRANCH IF NOT.
         CLOSE (DCBSYSP)         CLOSE SYSPRINT DD
FAIL6    EQU   *
*
THEEND   EQU   *
         ZR    R10
         IC    R10,RC             COLLECT RETURN CODE
         CH    R10,=H'8'           ARE THERE ANY ERROR MESSAGES
         BL    NOWTO
         WTO   'RARTR99I **********************************************+
               ****************',ROUTCDE=1,DESC=7
WTOAGAIN EQU   *
         WTO   'RARTR99I IMPORTANT MESSAGES ON SYSPRINT - PLEASE SAVE O+
               UTPUT AND TAKE REQUIRED ACTION',ROUTCDE=1,DESC=7
         WTO   'RARTR99I **********************************************+
               ****************',ROUTCDE=1,DESC=7
         MVI   WTORECB,0          INITIALIZE ECB
         WTOR  'RARTR99I REPLY C TO CONTINUE OR R TO RESHOW MESSAGE',  +
               WTOREPLY,1,WTORECB,ROUTCDE=1
         WAIT  ECB=WTORECB,RELATED=WTOR
         CLI   WTOREPLY,C'C'      ARE WE TO CONTINUE
         BNE   WTOAGAIN           IF NOT REPEAT MESSAGE
NOWTO    EQU   *
         GOODBY RC=(10)
         EJECT
*
* SUBROUTINE TO TEST A DCB FOR OPEN AND ISSUE A MESSAGE IF NOT
* USES R0,R1 ENTRY WITH DCB ADDRESS IN R5 RETURN VIA R14
*
TESTOPEN EQU   *
         USING IHADCB,R5
         TM    DCBOFLGS,DCBOFOPN   OPENED ?
         BOR   R14                 YES
         MVC   MSG02DD,DCBDDNAM    NO SO WRITE A MESSAGE
         DROP  R5
         PUT   DCBSYSP,MSG02
         B     FAIL
         EJECT
*
* SUBROUTINE CHKLAST
* TO CHECK ALL RECORDS IN MEMORY HAVE GIVEN SOME SORT OF NOTIFICATION
* TO THE USER
*
CHKLAST  EQU   *
         ST    R14,SAVEDR14
         LA    R5,CHAIN         GET START OF BUFFER CHAIN
CTESTBLK EQU   *
         LT    R5,0(R5)         GET NEXT BLOCK
         BZ    CDONE            LOOK AT ALL RECORDS
         CLI   4(R5),C' '       ANY MARKER AT ALL
         BNE   CTESTBLK         IF SO IGNORE RECORD
         PUT   DCBSYSP,MSG63    RECORD THIS ON SYSPRINT
         LA    R6,4(R5)         POINT TO RECORD
         USING FDRCNTL,R6
         LA    R1,FDR2DSN       SET UP PARM LIST FOR SEND
         ST    R1,SENDPARM
         LA    R1,FDR2USR
         ST    R1,SENDPARM+4
         DROP  R6
         LA    R1,MESNSEL       DATASET NOT SELECTED
         ST    R1,SENDPARM+8
         LA    R1,MESNSELL
         ST    R1,SENDPARM+12
         LA    R1,SENDPARM
         BAL   R14,SENDMESG
         L     R14,SAVEDR14
         MVI   4(R5),C'-'      SAY WE HAVE PROCESSED IT
         MVI   RC,12           ERROR
         B     CTESTBLK        GO BACK FOR THE NEXT
CDONE    EQU   *
         BR    R14
         EJECT
*
* SUBROUTINE DEVCHAR
*
*    GET DEVICE CHARACTERISTICS
*
DEVCHAR  EQU   *
         LA    R1,RBPTR
         DYNALLOC
         LTR   R15,R15
         BNZ   DEVERR
         DEVTYPE DDDISK,DISKCHAR,DEVTAB,RPS
         BR    R14
*
* ISSUE DYNAMIC ALLOCATION ERROR MESSAGE
*
DEVERR   EQU   *
         STM   R2,R5,GSAVE
         UNPK  CUNPK(5),ERROR(3)   CONVERT ERROR CODE TO CHARS
         TR    CUNPK(4),HEXTAB-C'0' NOW TO PROPER EBCDIC
         MVC   MSG01ERR,CUNPK      MOVE TO MESSAGE
         UNPK  CUNPK(5),INFO(3)    CONVERT INFO CODE TO CHARS
         TR    CUNPK(4),HEXTAB-C'0' NOW TO PROPER EBCDIC
         MVC   MSG01INF,CUNPK      MOVE TO MESSAGE
         LR    R1,R15              GET RETURN CODE
         BAL   R14,BINDEC          TO DECIMAL
         MVC   MSG01RC,14(R1)      MOVE TO MESSAGE
         PUT   DCBSYSP,MSG01
         PUT   DCBSYSP,MSG67
         MVI   RC,12               SET RETURN CODE
         LM    R2,R5,GSAVE
         LA    R1,TRACEDSN         SET UP PARM LIST FOR SEND
         ST    R1,SENDPARM         BECAUSE UNABLE TO ALLOCATE VOLUME
         LA    R1,TRACEUSR
         ST    R1,SENDPARM+4
         LA    R1,UALCMSG
         ST    R1,SENDPARM+8
         LA    R1,UALCMSGL
         ST    R1,SENDPARM+12
         LA    R1,SENDPARM
         BAL   R14,SENDMESG
         MVI   4(R5),C'-'          MARK RECORD AS A FAILURE
         B     SELNEXT             IGNORE THIS ONE
         EJECT
*
* SUBROUTINE TO COUNT THE LENGTH OF A FIELD STARTING FROM (R7)
* RETURN LENGTH IN R7, USES R8
*
COUNT    EQU   *
         LR    R8,R7               SAVE FOR LATER
COUNT1   EQU   *
         CLI   0(R7),C' '          SPACE ?
         BE    COUNT2
         CLI   0(R7),C','          OR COMMA
         BE    COUNT2
         INCR  R7
         B     COUNT1
COUNT2   EQU   *
         MVI   0(R7),C' '          MAKE SURE ITS A SPACE FOR ERRORS
         SR    R7,R8               LENGTH OF DSN FIELD
         BR    R14
         EJECT
*
* SUBROUTINE BINDEC
*
* ON ENTRY R1 CONTAINS NUMBER TO BE CONVERTED
* ON EXIT R1 CONTAINS ADDRESS ON CONVERTED NUMBER
*
BINDEC   EQU   *
         CVD   R1,CPACK           CONVERT TO DECIMAL
         UNPK  CUNPK,CPACK        NOW TO CHARACTERS
         OI    CUNPK+15,X'F0'     LAST DIGIT TO CHARACTER
         LA    R1,CUNPK           POIINT TO NEW STRING
         BR    R14
         EJECT
*
*        -----------------------
*        × SUBROUTINE SENDMESG ×
*        -----------------------
*
*        R1 POINTS TO PARMS BELOW
*                   0 ->           DSN ADDRESS
*                   4 ->           USERID ADDRESS
*                   8 ->           INFO MESSAGE ADDRESS
*                  12 ->           INFO MESSAGE LENGTH ADDRESS
*
SENDMESG EQU   *
         STM   R1,R5,GSAVE
         L     R2,0(R1)            POINT TO DSN
         CLI   0(R1),C' '          DON'T PROCESS IF BLANK
         BER   R14
         LA    R3,43(R2)           POINT TO END OF DSN
         LA    R4,44               MAX POSS LENGTH
SEND01   EQU   *
         CLI   0(R3),C' '          FIND LENGTH OF DSN
         BNE   SEND02
         DECR  R4
         BCT   R3,SEND01
SEND02   EQU   *
         BLANK SENDMSG+6,75        BLANK TARGET FOR MEESSAGE
         MVC   SENDMSG+6(44),0(R2) & MOVE IT
         LA    R5,SENDMSG+6(R4)    POINT TO END OF DSN
         MVI   0(R5),C'"'         INSERT TRAILING QUOTE
         L     R3,12(R1)           POINT TO LENGTH
         LH    R2,0(R3)            & LOAD IT
         DECR  R2
         L     R3,8(R1)            POINT TO MESSAGE
         EX    R2,MOVESEND         MOVE MESSAGE TO TARGET
         LA    R4,8(R2,R4)         GET FINAL MEESSAGE LENGTH
         STC   R4,SENDMSG          & INSERT IT
         L     R2,4(R1)            POINT TO USERID
         MVC   SENDUSER,0(R2)      MVE IT
         LA    R1,SENDPTR
         SVC   241                 ISSUE OUR SEND SVC
         LM    R1,R5,GSAVE
         BR    R14
MOVESEND MVC   2(0,R5),0(R3)       MOVE MESSAGE
         EJECT
*
* SUBROUTINE GETRECOR
* FIND RECORD IN THE MEMORY SAVED FROM FDR LOG CONTROL CARDS WITH
* SAME DSN AS FDR SELECTED MESSAGE
* USES R5,R6,R7,R8,R9
* RETURNS R6-> RECORD ON SUCCESS
*
GETRECOR EQU   *
         ST    R14,SAVEDR14        SAVE RETURN ADDRESS.
         LR    R9,R4               ADDRESS OF SELECTED MESSAGE
GFINDDSN EQU   *
         INCR  R9
         CLC   =C'DSN=',0(R9)      SEARCH FOR DSN= IN SELECTED MESSAGE
         BE    GFONDDSN
         CLC   =C'DSG=',0(R9)      SEARCH FOR DSG= IN SELECTED MESSAGE
         BNE   GFINDDSN
GFONDDSN EQU   *
         LA    R9,4(R9)            POINT TO FIRST CHARACTER OF DSN
         LR    R7,R9               COUNT THE CHARACTERS IN IT
         BAL   R14,COUNT           RETURNED IN R7
         DECR  R7                  -1 FOR EXECUTE INSTRUCTION
         LT    R8,CURENTNO         NO OF CARDS FOR THIS RUN
         BZ    GNOTFND
         LA    R5,CHAIN            GET START OF BUFFER CHAIN
GTESTBLK EQU   *
         LT    R5,0(R5)            GET NEXT BLOCK
         BZ    GMEMERR             IF NONE THEN PROBLEM
         LA    R6,4(R5)            POINT TO RECORD
         CLM   R7,1,1(R6)          DOES LENGTH MATCH
         BNE   GNOGOOD
         EX    R7,CLCDSN           DOES RECORD MATCH
         BE    GETFOUND
GNOGOOD  EQU   *
         BCT   R8,GTESTBLK
GNOTFND  EQU   *
         PUT   DCBSYSP,MSG65       DSN NOT FOUND ON CONTROL CARDS
         B     FAIL
GMEMERR  EQU   *
         PUT   DCBSYSP,MSG64       INTERNAL ERROR
         B     FAIL
GETFOUND EQU   *
         L     R14,SAVEDR14
         BR    R14
         USING FDRCNTL,R6          MAP CONTROL CARDS
CLCDSN   CLC   FDR2DSN(0),0(R9)    DOES RECORD MATCH
         DROP  R6
         EJECT
         LTORG
         DROP  R12,R11
         EJECT
*
* DATA AREAS - BASE AND FLAGS
*
BASE2    DC    A(RARTRACE+4096)
*
FLAG1    DC    X'0'              SECOND FLAG2 WORD.
FLGDATE  EQU   X'40'
EODS     EQU   X'20'
FIRSTI   EQU   X'04'             SET AFTER FIRST BLOCK READ.
DUMPF    EQU   X'02'             SET WHEN NO DUMP MES TO BE O/P.
*
FLAG2    DC    X'0'
FLGSYSP  EQU   X'80'             SYSPRINT OPEN.
FLGTRACE EQU   X'40'             TRACE OPEN.
FLGDUMP  EQU   X'20'             DUMP MODE RUN
FLGRETN  EQU   X'10'             RETURN MODE RUN
FLGFDR   EQU   X'04'             FDR LOG OPEN.
*
FLAG3    DC    X'0'
FLG2RET  EQU   X'80'
*
RC       DC    X'00'             RETURN CODE
* VALUES       0 - NORMAL COMPLETION
*              4 - NOT USED
*              8 - AT LEAST ONE USER ERROR
*             12 - AT LEAST ONE REQUEST FAILED
*             16 - SERIOUS ERROR ALL REQUESTS ABANDONED
         EJECT
*
* MESSAGES.
*
* COLS 1'ST    0----+----1----+----2----+----3----+----4----+----5----+
*      2'ND   56---6----+----7----+----80
MSG01    MSGV  ' RARTR01I ERROR DURING DYNAMIC ALLOCATION OF DISK RC=00+
               , ERROR=0000, INFO=0000'
MSG01RC  EQU   MSG01S+53,2
MSG01ERR EQU   MSG01S+63,4
MSG01INF EQU   MSG01S+74,4
MSG02    MSGV  ' RARTR02I UNABLE TO OPEN DATASET - DDNAME=ABCDEFGH'
MSG02DD  EQU   MSG02S+42,8
MSG03    MSGV  ' RARTR03I VSAM ERROR R15 = 000 R0 = 000'
MSG03RC  EQU   MSG03S+27,3
MSG03ERR EQU   MSG03S+36,3
MSG04    MSGV  ' RARTR04I VSAM ERROR R15 = 000 FDBK = 000'
MSG04RC  EQU   MSG04S+27,3
MSG04FDB EQU   MSG04S+38,3
MSG61    MSGV  ' RARTR61I LOG ANALYSIS COMPLETE.'
MSG62    MSGV  ' RARTR62I TRACE UPDATE COMPLETE.'
MSG63    MSGV  ' RARTR63I A DATASET WE REQUESTED HAS NOT BEEN SELECTED'
MSG64    MSGV  ' RARTR64I INTERNAL ERROR'
MSG65    MSGV  ' RARTR65I DSN ON LOG MESSAGE NOT FOUND ON CONTROL CARD'
MSG66    MSGV  ' RARTR66I UNEXPECTED MESSAGE RECEIVED FROM FDRDSF'
MSG67    MSGV  ' RARTR67I - TRACE UPDATE BYPASSED'
*
PRTFDR   DC    AL2(125,0)
PRTFDRM  DS    CL121          FOR FDR LOG MESSAGES FOR PRINTING
*
MSRETL   DC    AL2(MRETL)
MESRET   DC    C'RETURNED'
MRETL    EQU   *-MESRET
*
MS316L   DC    AL2(M316L)
MES316   DC    C'DATASET NOT FOUND'
M316L    EQU   *-MES316
*
MESMISSL DC    AL2(MMISSL)
MESMISS  DC    C'TARGET DATASET ERROR'
MMISSL   EQU   *-MESMISS
*
MESNSELL DC    AL2(MSNSELL)
MESNSEL  DC    C'NOT SELECTED - REASON UNKNOWN'
MSNSELL  EQU   *-MESNSEL
*
MSARCL   DC    AL2(MARCL)
MESARC   DC    C'ARCHIVED'
MARCL    EQU   *-MESARC
*
UALCMSGL DC    AL2(UALCLGTH)
UALCMSG  DC    C'ALLOCATION ERROR'
UALCLGTH EQU   *-UALCMSG
         EJECT
*
* GENERAL WORK AREAS AND DATA
*
CHAIN    DC    A(0)            BEGINNING OF 'GETMAIN' AREA
SAVEDR14 DS    1F              SAFE PLACE FOR R14.
GSAVE    DS    16F             SAFE AREA FOR THE REGISTERS.
SENDPARM DS    4A                 PARAMETERS FOR SENDMESG SUBROUTINE
SENDUSER DS    CL7                 USERID FOR SVC SEND
SENDMSG  DS    0XL81               MESSAGE FOR SVC
         DS    X                   LENGTH OF MESSAGE FOR SVC
         DC    CL80'RTN "'         MESSAGE FOR SVC
SENDPTR  DC    AL4(SENDUSER)       POINT TO USERID FOR SVC
         DC    AL4(SENDMSG)        POINT TO MESSAGE
CURENTNO DS    F               NO. OF CARDS FOR A FDRDSF RUN
HEXTAB   DC    C'0123456789ABCDEF'
DSCB1OB  CAMLST SEARCH,TRACEDSN,TRACEDSK,TRACEDS1
DSCB3OB  CAMLST SEEK,CCHHR,TRACEDSK,TRACEDS3
CCHHR    DS    XL5           TTR INFO TO OBTAIN DSCB3
DISKCHAR DS    0F            6 WORDS FOR DEVCHAR
DISKTYPE DS    F        UCB TYPE
MAXBLOCK DS    F        MAX BLOCK SIZE
NUMCYLS  DS    H        NUMBER OF CYLINDERS ON VOLUME
TRKPCYL  DS    H        TRACKS PER CYLINDER
BYTSPTRK DS    H        BYTES PER TRACK
         DS    H        OTHER DATA
         DS    2F                 ETC.
*
CPACK    DS    D
CUNPK    DS    CL16
FDBK     DS    F
WTORECB  DS    A                  ECB FOR WTO REPLY
WTOREPLY DS    C                  MESSAGE RETURNED FROM WTOR
DATE     DS    CL6                SAVE DATE OF RUN
         EJECT
*
* DYNAMIC ALLOCATION PARAMETERS
*
         DS    0F
RBPTR    DC    X'80',AL3(RB)
RB       DC    X'14'
DYNVERB  DC    X'01'               ALLOC ON DSNAME
DYNFLG1  DC    X'00'
DYNFLG2  DC    X'00'
ERROR    DC    H'0'
INFO     DC    H'0'
LISTPTR  DC    A(DYNLIST)
         DC    2F'0'
DYNLIST EQU    *
TP55     DC    A(TU55)
TP4      DC    A(TU4)
TP7      DC    A(TU7)
TPA      DC    A(TUA)
TP10     DC    A(TU10)
TP15     DC    X'80',AL3(TU15)
*
TU55     DC    X'0055',X'0001'     DDNAME RETURN
         DC    X'0008'
DDDISK   DS    CL8
TU4      DC    X'0004',X'0001',X'0001'
         DC    X'04'               NEW
TU7      DC    X'0007',X'0000'
TUA      DC    X'000A',X'0001',X'0003'
         DC    X'000000'
TU10     DC    X'0010',X'0001',X'0006'
VOLSER   DS    CL6
TU15     DC    X'0015',X'0001',X'0005',C'SYSDA'
         EJECT
*
* THE FDR MESSAGE CODES.
*
MSGTABLE DS    0F
         DC    C'101',AL4(GETDATE)      HEADER
         DC    C'303',AL4(CNTRLCRD)     CONTROL CARD
         DC    C'392',AL4(SELECT)       DUMP SELECTED
         DC    C'110',AL4(SELECT)       RESTORE SELECTED
         DC    C'007',AL4(GETFDR)       START/END OF DUMP/RESTORE
         DC    C'122',AL4(GETFDR)       STATISTICS
         DC    C'107',AL4(TRACELOG)     SUCCESS
         DC    C'316',AL4(DSNOTFND)
         DC    C'035',AL4(GETFDR)       NO CONTROL CARDS
         DC    C'106',AL4(DSMISS)       DATASET MISSING FOR RESTORE
         DC    C'111',AL4(DSMISS)       DATASET TOO SMALL FOR RESTORE
         DC    C'319',AL4(ABEND)        FDR ABENDED (COULD BE USER ERR)
MSGNO    EQU   (*-MSGTABLE)/7
MSGCOUNT DC    A(MSGNO)            MUST CONTAIN NO. OF MESGS IN ABOVE
         EJECT
*
* THE DCB'S, ACB'S AND RPL'S
*
         PRINT NOGEN
ACBTRACE ACB   DDNAME=TRACE,MACRF=(ADR,OUT)
RPLTRACE RPL   ACB=ACBTRACE,AREA=TRACEMAP,AREALEN=321,RECLEN=321,      X
               OPTCD=(ADR,SEQ,MVE)
DCBSYSP  DCB   DDNAME=SYSPRINT,DSORG=PS,MACRF=(PM),RECFM=VBA,          *
               EROPT=ACC,LRECL=125,BLKSIZE=6160
DCBFDR   DCB   DDNAME=FDRLOG,DSORG=PS,MACRF=(GL),RECFM=FB,             *
               EODAD=FINISH,LRECL=121,BLKSIZE=6050
         PRINT GEN
         EJECT
*
*        MAP TRACE AND GET FLAGS
*
         PRINT GEN
         RARMACRO RARTRACE
         PRINT NOGEN
         IECSDSL1 (1,3)            MAP DSCB S
         DCBD  DSORG=PS,DEVD=DA
         END
