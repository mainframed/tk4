         MACRO
&NAME    BEGIN &SAVE,&BASE=12,&ID=*
.*
.* THE BEGIN MACRO PROVIDES THE FOLLOWING FACILITIES....
.*   1.  REGISTER SAVING
.*
.*       THE SAVE MACRO IS USED TO SAVE REGISTERS 14,12 IN THE SAVE
.*       AREA ADDRESSED BY REG 13.
.*   2.  IDENTIFIER.
.*
.*       YOU MAY PROVIDE ANY IDENTIFIER (TO HELP FIND THE ENTRY POINT
.*       IN A DUMP) BY CODING 'ID=STRING OF UP TO 70 CHARS' - THE
.*       DEFAULT ID IS THE NAME OF THE MACRO OR THE CSECT NAME UNLESS
.*       YOU CANCEL THE PARAMETER BY CODING 'ID='
.*   3.  DEFINING BASE REGISTERS.
.*       YOU MAY PREVENT ANY BASE REGISTER INITIALIZATION BY CODING
.*       'BASE=NONE', OR SET UP ONE OR MORE BASE REGISTERS BY CODING
.*       'BASE=(10,11,12...)'.  IF THE BASE PARAMETER IS OMITTED REG 12
.*       IS INITIALIZED AS A BASE BY DEFAULT.  NOTE THAT YOU CANNOT USE
.*       SYMBOLIC NAMES FOR THE BASE REGISTERS OTHER THAN THE FIRST.
.*       E.G. BASE=(R10,11,12) IS VALID BUT 'BASE=(R10,R11,R12) IS NOT
.*   4.  SAVE AREA PROVISION.
.*       THIS IS DEFINED BY THE FIRST POSITIONAL PARAMETER.  BY DEFAULT
.*       A 72 BYTE SAVE AREA IS GENERATED IN THE MACRO EXPANSION.
.*       YOU MAY ALSO CODE ONE OF.....
.*       A)  'NOSAVE' CAUSES NO SAVE AREA TO BE GENERATED AND LEAVES
.*             REG 13 AS AT ENTRY. UNLESS NOSAVE IS CODED REG 13 IS
.*             ALWAYS SET TO POINT TO THE NEW SAVE AREA.
.*       B)    IF YOU DEFINE THE SAVE AREA IN YOUR PROGRAM YOU CODE THE
.*             SAVE AREA NAME E.G. 'BEGIN SAVE'.
.*             BY CODING 'BEGIN (SAVE,,SAVE)' YOU WILL GENERATE A
.*             STATEMENT 'USING SAVE,13' TO BE GENERATED AND THIS CAN
.*             BE A USEFUL WAY OF CREATING A SECOND BASE REGISTER FOR
.*       WHAT COMES AFTER THE SAVE AREA IN YOUR PROGRAM.
.*       C)    IF YOU WISH TO ACQUIRE CORE DYNAMICALLY FOR THE SAVE
.*             AREA BEGIN WILL ISSUE A GETMAIN FOR YOU IF YOU CODE
.*             'BEGIN DYNAMIC'.  BY DEFAULT A 72 BYTE AREA WILL BE
.*             ACQUIRED AND REG 13 WILL BE SET TO POINT TO IT.
.*             IF YOU WISH TO ACQUIRE A LARGER AREA FOR OTHER PURPOSES
.*             IN ADDITION TO THE SAVE AREA YOU CODE THE TOTAL LENGTH
.*             AND DSECT NAME FOR THE AREA E.G. ........
.*             'BEGIN (DYNAMIC,240,DYNAR)'.  THIS EXAMPLE WILL RESULT
.*             IN A GETMAIN FOR 240 BYTES FROM SUBPOOL 0, REG 13 WILL
.*             BE SET TO THE ACQUIRED ADDRESS, AND A 'USING DYNAR,13'
.*             WILL BE GENERATED.
.*
.*       FORMAT OF MACRO....
.* NAME  BEGIN NOSAVE                            OR        (POS PARM 1)
.*             (SAVEAREA ADDRESS,,DSECT NAME)    OR
.*             (DYNAMIC,LENGTH,DSECT NAME)
.*             ,BASE=NONE                        OR        (KEYWORD 1)
.*             ,BASE=(REGISTER LIST)
.*             ,ID='CHARACTER STRING'                      (KEYWORD 2)
.*
         LCLA  &A(15),&A0,&A1,&R1,&R2
         LCLC  &GNAME,&C1,&C(5)
&NAME    SAVE  (14,12),T,&ID       SAVE REGISTERS.
         AIF   ('&BASE' EQ ''  OR '&BASE'EQ 'NONE').C10
         BALR  &BASE(1),0          SET FIRST (OR ONLY) BASE REGISTER.
         AIF   (N'&BASE EQ 1).C1
&A0      SETA  1
&A1      SETA  2
.C18     AIF   (K'&BASE LE (&A1+8)).C2
&C(&A0)  SETC  '&BASE'(&A1,8)
&A0      SETA  &A0+1
&A1      SETA  &A1+8
         AGO   .C18
.C2      ANOP
&C(&A0)  SETC  '&BASE'(&A1,K'&BASE-&A1)
         USING *,&C(1)&C(2)&C(3)&C(4)&C(5)   DEFINE BASE REGISTER(S).
&GNAME   SETC  'IHB'.'&SYSNDX'
&C1      SETC  '&GNAME'.'A'
&GNAME   EQU   *                   DEFINE BASE REGISTER ORIGIN.
&A0      SETA  2
.C4      AIF   (&A0 GT N'&BASE).C3
&A1      SETA  &BASE(&A0)
&A(&A1)  SETA  4096*(&A0-1)
&A0      SETA  &A0+1
         AGO   .C4
.C1      USING *,&BASE(1)
         AGO   .C10
.C3      ANOP
&A0      SETA  0
&R1      SETA  1
.C11     ANOP
&R2      SETA  &R1+1
         AIF   (&A(&R1) EQ 0).C5
.C7      AIF   (&A(&R2) EQ 0).C6
&R2      SETA  &R2+1
         AIF   (&R2 LT 16).C7
.C6      AIF   (&R1 EQ (&R2-1)).C8
&A1      SETA  &R2-1
         LM    &R1,&A1,&GNAME.A+&A0     INITIALISE BASE REGISTER(S).
         AGO   .C9
.C8      L     &R1,&GNAME.A+&A0    INITIALISE BASE REGISTER(S).
.C9      ANOP
&A0      SETA  &A0+4*(&R2-&R1)
.C5      AIF   (&R2 GE 16).C10
&R1      SETA  &R2
         AGO   .C11
.C10     AIF   ('&SAVE(1)' EQ '').C12
         AIF   ('&SAVE' EQ 'NOSAVE').C13
         AIF   ('&SAVE(1)' EQ 'DYNAMIC').C14
         LA    15,&SAVE(1)         SET GR15 -> NEW SAVE AREA.
         AGO   .C15
.C12     CNOP  0,4                 FORCE ALIGNMENT ON WORD BOUNDARY.
         BAL   15,*+76             SET GR15-> NEW SAVE AREA.
         DC    18F'0'              NEW SAVE AREA.
         AGO   .C15
.C14     AIF   ('&SAVE(2)' EQ '').C20
         LA    0,&SAVE(2)(0,0)    SET GR0 = LENGTH OF DYNAMIC AREA.
         AGO   .C19
.C20     LA    0,72(0,0)           SET GR0 = LENGTH OF DYNAMIC AREA.
.C19     GETMAIN R,LV=(0)          OBTAIN DYNAMIC NEW SAVE AREA.
         LR    15,1                SET GR15 -> NEW SAVE AREA.
         LM    0,1,20(13)          RESTORE PARAMETER REGISTERS.
.C15     ST    15,8(13,0)          STORE NSA ADDR. IN LSA.
         ST    13,4(15,0)          STORE LSA ADDR.IN NSA.
         LR    13,15               SET GR13 -> NEW SAVE AREA.
         AIF   ('&SAVE(3)' EQ '').C13
         USING &SAVE(3),13         DEFINE GR13 AS BASE REGISTER.
.C13     AIF   (N'&BASE LE 1).EXIT
         BC    15,&GNAME.B         BRANCH ROUND BASE REGISTER VALUE(S).
&A0      SETA  1
.C17     AIF   (&A(&A0) EQ 0).C16
&C1      DC    A(&GNAME+&A(&A0))   BASE REGISTER VALUE.
&C1      SETC  ''
.C16     ANOP
&A0      SETA  &A0+1
         AIF   (&A0 LE 15).C17
&GNAME.B EQU   *
 AIF (&A(13)NE 0 OR &A(15)NE 0 OR(&A(1)NE 0 AND'&SAVE'EQ'DYNAMIC')).E1
.EXIT    MEXIT
.E1      MNOTE 12,'***  IHBNNN  INVALID REGISTER SPECIFIED'
         MEND
