AMM.     TITLE 'RT5021M - UNIT GROUP NAME MODIFICATION AND LISTING PROG*
               RAM. - A.MORRISH.'
RT5021M  CSECT
***********************************************************************
*                                                                     *
*  THIS PROGRAM CAN BE USED TO MODIFY THE DEVICE NAME TABLE AND THE   *
* DEVICE MASK TABLE DEFINED FOR THE INSTALLATION AT SYSTEM GENERATION.*
* THE PROGRAM CAN CHANGE A GROUP NAME AND CAN CHANGE THE DEVICES THAT *
* ARE SPECIFIED BY A GROUP NAME. THE PROGRAM CAN NEITHER DELETE NOR   *
* ADD GROUP NAMES TO THE EXISTING LIST.                               *
*                                                                     *
*  THIS PROGRAM IS NOT APPLICABLE TO ANY OPERATING SYSTEM RELEASE     *
* PRIOR TO RELEASE 19.                                                *
*                                                                     *
*  THE PROGRAM IS CONTROLLED BY A PARAMETER LIST AND BY CONTROL       *
* RECORDS FROM A SYSIN DATA SET.                                      *
*                                                                     *
*  THE PARAMETER LIST DEFINES THE LIMITS IN WHICH THE PROGRAM CAN     *
* OPERATE. THESE LIMITS ARE DEFINED BY THE FOLLOWING CONTROL WORDS :  *
*                                                                     *
*        DASD  THE MODIFIED DEVICE MASK TABLE IS WRITTEN TO LINKLIB.  *
*                                                                     *
*        CORE  THE MODIFIED DEVICE MASK AND DEVICE NAME TABLES        *
*              REPLACE THE TABLES THAT HAVE BEEN MADE RESIDENT IN     *
*              THE LINK PACK AREA.                                    *
*                                                                     *
*        OVRD  CHANGES TO UNIT TYPE NAMES (E.G. 2314) WHICH THE       *
*              PROGRAM WOULD OTHERWISE REJECT ARE ALLOWED.            *
*                                                                     *
*        ABEW  ABEND IF A CODE OF 4 OR GREATER IS DEVELOPED.          *
*                                                                     *
*        ABEE  ABEND IF A CODE OF 8 OR GREATER IS DEVELOPED.          *
*                                                                     *
*        ABES  ABEND IF A CODE IF 12 OR 16 IS DEVELOPED.              *
*                                                                     *
*        ABET  ABEND IF A CODE OF 16 IS DEVELOPED.                    *
*                                                                     *
*                                                                     *
*  CONTROL RECORDS HAVE THE FOLLOWING FORMAT :                        *
*                                                                     *
*        BYTE  0    THE GROUP NAME FOR WHICH A CHANGE IS REQUIRED.    *
*                                                                     *
*        BYTE  8    BLANK.                                            *
*                                                                     *
*        BYTE  9    ONE OF THE FOLLOWING OPERATORS :                  *
*                                                                     *
*                   R    RENAME THE GROUP.                            *
*                   A    ADD NEW UNITS.                               *
*                   D    DELETE UNITS.                                *
*                   C    CHANGE UNITS TO NEW SPECIFICATION.           *
*                                                                     *
*        BYTE 10    BLANK.                                            *
*                                                                     *
*        THE REMAINDER OF THE CONTROL RECORD CONTAINS THE NEW GROUP   *
*        NAME (IF 'R' IS SPECIFIED) OR A LIST OF DEVICE ADDRESSES     *
*        THAT SPECIFIES THE UNITS THAT ARE TO BE ADDED OR  DELETED    *
*        IN THE EXISTING SPECIFICATION OR THAT ARE TO REPLACE THE     *
*        EXISTING SPECIFICATION.                                      *
*                                                                     *
*        CONTINUATION RECORDS ARE INDICATED BY A COMMA FOLLOWED BY A  *
*        BLANK IN THE PRECEDING RECORD. CONTINUATION DATA MAY BEGIN   *
*        IN ANY POSITION BUT THE FIRST (BYTE ZERO) WHICH MUST BE      *
*        BLANK.                                                       *
*                                                                     *
*                                                                     *
*  JOB CONTROL STATEMENTS :                                           *
*                                                                     *
*                                                                     *
*        THE FOLLOWING DD STATEMENTS ARE APPLICABLE TO THIS PROGRAM : *
*                                                                     *
*        SYSLIB     DEFINES THE LIBRARY FROM WHICH THE DEVICE NAME    *
*                   AND MASK TABLES ARE TO BE READ FOR MODIFICATION.  *
*                   IF 'DASD' IS SPECIFIED THEN THIS DD STATEMENT     *
*                   ALSO DEFINES THE LIBRARY TO WHICH THE MODIFIED    *
*                   TABLES ARE TO BE WRITTEN.                         *
*                   IF THIS STATEMENT IS OMITTED THE PROGRAM DOES     *
*                   NOTHING.                                          *
*                                                                     *
*        SYSPRINT   DEFINES A SEQUENTIAL OUTPUT DATA SET. THIS DATA   *
*                   SET CONTAINS A LISTING OF THE CONTROL STATEMENTS  *
*                   AND A DESCRIPTIVE LIST OF THE MODIFIED DEVICE     *
*                   NAME AND MASK TABLES.                             *
*                                                                     *
*        SYSIN      DEFINES A SEQUENTIAL INPUT DATA SET THAT CONTAINS *
*                   THE CONTROL RECORDS. IF THIS STATEMENT IS OMITTED *
*                   THE PROGRAM PRODUCES A LISTING OF THE DEVICE NAME *
*                   AND MASK TABLES IN READABLE FORMAT.               *
*                                                                     *
*                                                                     *
*  EXAMPLES :                                                         *
*                                                                     *
*        EXAMPLE 1 : TO DELETE DEVICES 590 THROUGH 595 FROM THE UNIT  *
*        GROUP NAME 'SIN' IN SYS1.LINKLIB   :                         *
*                                                                     *
*        //JOBNAME JOB                                                *
*        //NAME    EXEC PGM=RT5021M,PARM=DASD                         *
*        //SYSPRINT DD  SYSOUT=A                                      *
*        //SYSLIB   DD  DISP=SHR,DSNAME=SYS1.LINKLIB                  *
*        //SYSIN    DD  *                                             *
*        SIN      D 590-595                                           *
*        /*                                                           *
*        //                                                           *
*                                                                     *
*        EXAMPLE 2 : TO ADD DEVICE 237 TO THE UNIT NAME '2314' IN     *
*        SYS1.LINKLIB AND TO ADD THE MODIFICATION TO THE DEVICE NAME  *
*        AND MASK TABLES THAT ARE RESIDENT IN THE LINK PACK AREA  :   *
*                                                                     *
*        //JOBNAME JOB                                                *
*        //NAME   EXEC  PGM=RT5021M,PARM=(CORE,DASD,OVRD)             *
*        //SYSPRINT DD  SYSOUT=A                                      *
*        //SYSLIB   DD  DISP=SHR,DSNAME=SYS1.LINKLIB                  *
*        //SYSIN    DD  *                                             *
*        2314     A 237                                               *
*        /*                                                           *
*        //                                                           *
*                                                                     *
*        EXAMPLE 3 : TO CHANGE THE GROUP NAME 'WORK' TO 'TEMP' IN A   *
*        TEST LIBRARY AND TO CHANGE THE UNITS DEFINED IN THE GROUP    *
*        NAME :                                                       *
*                                                                     *
*        //JOBNAME JOB                                                *
*        //NAME   EXEC  PGM=RT5021M,PARM=DASD                         *
*        //SYSPRINT DD  SYSOUT=A                                      *
*        //SYSLIB   DD  DISP=SHR,DSNAME=T.TESTLIB                     *
*        //SYSIN    DD  *                                             *
*        WORK     R TEMP                                              *
*        TEMP     C 130,132-137,230,231,235-237,331-334,337,430,      *
*                   432,437,530-537,                                  *
*                   590-595                                           *
*        /*                                                           *
*        //                                                           *
*                                                                     *
***********************************************************************
         SPACE 1                                                      *
* REGISTER USAGE.                                                     *
R0       EQU   0                   WORK REGISTER.
R1       EQU   1                   WORK REGISTER / PARAMETER REGISTER.
R2       EQU   2                   WORK REGISTER.
R3       EQU   3                   WORK REGISTER.
R4       EQU   4                   WORK REGISTER.
R5       EQU   5                   ADDRESS OF MASK TABLE WORK AREA.
R6       EQU   6                   ADDRESS OF MASK TABLE ENTRY.
R7       EQU   7                   LINK REGISTER.
R8       EQU   8                   ADDRESS OF DEVICE NAME TABLE.
R9       EQU   9                   ADDRESS OF DEVICE MASK TABLE.
R10      EQU   10                  INCREMENT FOR DEVICE MASK TABLE.
R11      EQU   11                  ADDRESS OF UCB LOOK-UP TABLE.
RBASE    EQU   12                  BASE REGISTER.
R12      EQU   12                  INSERTED FOR SAVE INSTRUCTIONS.
R13      EQU   13                  SAVE AREA POINTER.
R14      EQU   14                  RETURN ADDRESS.
R15      EQU   15                  ENTRY POINT ADDRESS / RETURN CODE.
         EJECT
         BEGIN (SAVE,,SAVE),BASE=RBASE
         SPACE 1                                                      *
*                                                                     *
*        DECODE PARAMETER LIST AND STORE IN TITLE.                    *
*                                                                     *
         SPACE 1                                                      *
         L     R1,0(R1)            SET GR1 -> PARAMETER LIST.
         LH    R0,0(R1)            SET GR0 = LENGTH OF PARAMETER LIST.
         LTR   R0,R0               TEST FOR PARAMETER LIST PRESENT.
         BNP   PARMEND             IF NOT THEN USE DEFAULTS.
         LA    R1,2(R1)            SET GR1 -> FIRST PARAMETER.
         LA    R15,TITPARMS        SET GR15 -> TITLE PARAMETERS.
PARMLP2  LA    R14,4               SET GR14 = MINIMUM LENGTH FOR VALID.
         CR    R0,R14              IS RESIDUE LONG ENOUGH FOR PARM ?
         BL    PARMEND             IF NOT THEN END.
         LA    R14,PARMTAB         SET GR14 -> PARAMETER DECODING TABLE
PARMLP1  CLC   0(4,R1),0(R14)      TEST FOR PARAMETER.
         BE    PARMFND             IF EQUAL THEN FOUND.
         LA    R14,5(R14)          SET GR14 -> NEXT TABLE ENTRY.
         CLI   0(R14),X'FF'        IS IT END OF TABLE ?
         BNE   PARMLP1             IF NOT THEN GO TO TEST NEXT.
PARMFNDA LA    R1,1(R1)            INCREMENT GR1 TO TEST NEXT.
         BCT   R0,PARMLP2          DECREMENT GR0 TO TEST NEXT.
PARMFND  IC    R14,4(R14)          SET GR14 = SWITCH TO BE SET.
         EX    R14,PARMTM          CHECK FOR PREVIOUS USE.
         BNZ   PARMFNDA            IF PREVIOUS USE THEN IGNORE.
         EX    R14,PARMOI          SET SWITCH.
         MVC   0(4,R15),0(R1)      MOVE PARAMETER TO TITLE.
         LA    R15,5(R15)          SET GR15 -> NEXT ENTRY.
         LA    R1,4(R1)            INCREMENT GR1 FOR NEXT.
         SH    R0,*-2              DECREMENT GR0 FOR NEXT.
         B     PARMLP2             GO TO TEST NEXT.
PARMTM   TM    SW,0                MODEL STATEMENT.
PARMOI   OI    SW,0                MODEL STATEMENT.
         SPACE 1                                                      *
*                                                                     *
*        STORE TIME AND DATE IN TITLE.                                *
*                                                                     *
         SPACE 1                                                      *
PARMEND  TIME  DEC                 OBTAIN DECIMAL TIME AND DATE.
         STM   R0,R1,DW            STORE TIME AND DATE.
         ED    TITDATE,DW+5        EDIT DATE TO TITLE.
         MVO   DW+5(3),DW(2)       MOVE TIME FOR EDIT.
         ED    TITIME,DW+5         EDIT TIME TO TITLE.
         SPACE 1                                                      *
*                                                                     *
*        OPEN ALL DATA SETS.                                          *
*                                                                     *
         SPACE 1                                                      *
         OPEN  MF=(E,OPENL)        OPEN ALL DATA SETS.
         TM    LIB+48,X'10'        IS SYSLIB OPEN ?
         BZ    ERR01               IF NOT THEN NO OPERATION POSSIBLE.
         SPACE 1                                                      *
*                                                                     *
*        FIND DEVICE NAME AND MASK TABLES.                            *
*                                                                     *
         SPACE 1                                                      *
         BLDL  LIB,LIST            BUILD LIST.
         LTR   R15,R15             TEST FOR SUCCESSFUL COMPLETION
         BNZ   ERR02               IF NOT THEN NO OPERATION POSSIBLE.
         SPACE 1                                                      *
*                                                                     *
*        OBTAIN SPACE FOR DEVICE NAME AND MASK TABLES.                *
*                                                                     *
         SPACE 1                                                      *
         CLC   LIST+4+25(2),LIST+4+27   IS MASK TABLE SINGLE TEXT BLOCK
         BNE   ERR03                    IF NOT THEN CANNOT PROCESS.
         CLC   LIST+62+25(2),LIST+62+27 IS NAME TABLE SINGLE TEXT BLOCK
         BNE   ERR03                    IF NOT THEN CANNOT PROCESS.
         MVC   CCWMREAD+6(2),LIST+4+25  STORE LENGTH OF DEVICE MASK TAB
         MVC   CCWNREAD+6(2),LIST+62+25 STORE LENGTH OF DEVICE NAME TAB
         LH    R0,CCWMREAD+6       SET GR0 = LENGTH OF DEVICE MASK TABL
         AH    R0,CCWNREAD+6       SET GR0 = LENGTH OF TABLES.
         GETMAIN R,LV=(0)          OBTAIN DYNAMIC SPACE FOR NAME&MASK.
         LR    R9,R1               SET GR9 -> MASK TABLE SPACE.
         LH    R8,CCWMREAD+6       SET GR8 = LENGTH OF MASK TABLE.
         AR    R8,R9               SET GR8 -> NAME TABLE SPACE.
         ST    R9,CCWMREAD         STORE ADDRESS OF MASK TABLE SPACE.
         ST    R8,CCWNREAD         STORE ADDRESS OF NAME TABLE SPACE.
         MVI   CCWMREAD,X'06'      RESTORE READ CCW.
         MVI   CCWNREAD,X'06'      RESTORE READ CCW.
         SPACE 1                                                      *
*                                                                     *
*        READ IN DEVICE NAME AND MASK TABLES.                         *
*                                                                     *
         SPACE 1                                                      *
         XC    DW,DW               CLEAR DOUBLE WORD WORK AREA
         MVC   DW(3),LIST+4+14     STORE TTR OF MASK TABLE TEXT BLOCK,
         MVC   DW+4(3),LIST+62+14  STORE TTR OF NAME TABLE TEXT BLOCK,
         L     R1,16               SET GR1 -> CVT.
         L     R11,40(R1)          SET GR11 -> UCB LOOK-UP TABLE.
         L     R15,28(R1)          SET GR15 -> CONVERSION ROUTINE.
         L     R1,LIB+44           SET GR1 -> DEB.
         STM   R14,R12,12(R13)     SAVE REGISTERS.
         LR    R3,R13              SAVE GR13.
         L     R0,DW               SET GR0 = TTRZ.FOR DEVICE MASK TABLE
         LA    R2,IOBM+32          SET GR2 -> MBBCCHAR FOR MASK TABLE.
         BALR  R14,R15             LINK TO CONVERT TTR TO MBBCCHHR.
         LR    R13,R3              RESTORE GR13.
         EXCP  IOBM                READ IN DEVICE MASK TABLE.
         LM    R14,R12,12(R13)     RESTORE REGISTERS.
         L     R0,DW+4             SET GR0 = TTRZ FOR DEVICE NAME TABLE
         LA    R2,IOBN+32          SET GRZ -> MBBCCHHR FOR NAME TABLE.
         LR    R3,R13              SAVE GR13.
         BALR  R14,R15             LINK TO CONVERT TTR TO MBBCCHHR.
         LR    R13,R3              RESTORE GR13
         EXCP  IOBN                READ IN DEVICE NAME TABLE.
         LM    R14,R12,12(R13)     RESTORE REGISTERS.
         SPACE 1                                                      *
*                                                                     *
*        CALCULATE SIZE OF DEVICE MASK TABLE.                         *
*                                                                     *
         SPACE 1                                                      *
         LR    R10,R11             SET GR10 -> UCB LOOK-UP TABLE.
         LA    R10,2(R10)          SET GR10 -> NEXT UCB ENTRY.
         CLI   0(R10),X'FF'        IS IT END OF TABLE ?
         BNE   *-8                 IF NOT THEN GO TO TEST NEXT ENTRY.
         SR    R10,R11             SET GR10 = LENGTH OF LOOK-UP TABLE.
         LA    R10,190(R10)        INCREMENT GR10 FOR LENGTH.
         SRL   R10,6               SHIFT TO CLEAR ODD BITS.
         SLL   R10,2               SET GR10 = INCREMENT FOR DEVMASKT.
         SPACE 1                                                      *
*                                                                     *
*        OBTAIN DYNAMIC SPACE FOR DEVICE MASK CREATION.               *
*                                                                     *
         SPACE 1                                                      *
         GETMAIN R,LV=(R10)        OBTAIN DYNAMIC DEVICE MASK AREA.
         LR    R5,R1               SET GR5 -> WORK AREA.
         SPACE 1                                                      *
*                                                                     *
*        WAIT FOR READS TO COMPLETE.                                  *
*                                                                     *
         SPACE 1                                                      *
         WAIT  2,ECBLIST=ECBLIST   WAIT FOR COMPLETION OF READS.
         CLI   ECBM,X'7F'          IS MASK READ NORMALLY ?
         BNE   ERR04               IF NOT THEN ERROR.
         CLI   ECBN,X'7F'          IS NAME READ NORMALLY ?
         BNE   ERR04               IF NOT THEN ERROR.
         SPACE 1                                                      *
*                                                                     *
*        CHECK FOR SYSIN PRESENT.                                     *
*                                                                     *
         SPACE 1                                                      *
         TM    IN+48,X'10'         IS SYSIN DATA SET PRESENT ?
         BZ    ENDINPUT            IF NOT THEN SIMULATE EOF.
         SPACE 1                                                      *
*                                                                     *
*        READ A CONTROL STATEMENT.                                    *
*                                                                     *
         SPACE 1                                                      *
GETINPUT BAL   R7,GETSUB           LINK TO READ SYSIN DATA SET.
         SPACE 1                                                      *
*                                                                     *
*        IDENTIFY GROUP NAME.                                         *
*                                                                     *
         SPACE 1                                                      *
         L     R14,0(R8)           SET GR14 = NUMBER OF DEVICES.
         LA    R15,4(R8)           SET GR15 -> FIRST NAME ENTRY.
NAMESCAN CLC   INCARD(8),0(R15)    IS NAME ENTRY FOR NAME SPECIFIED ?
         BE    NAMEFND             IF SO THEN GO TO CHECK OVER-RIDE.
         LA    R15,12(R15)         INCREMENT GR15 FOR NEXT.
         BCT   R14,NAMESCAN        LOOP UNTIL NAME FOUND OR LIST ENDED.
         B     ERR05               IF NAME NOT FOUND THEN ERROR.
         SPACE 1                                                      *
*                                                                     *
*        VERIFY THAT NAME CAN BE MODIFIED.                            *
*                                                                     *
         SPACE 1                                                      *
NAMEFND  TM    SW,SWOVRD           IS OVER-RIDE SPECIFIED ?
         BO    *+12                IF SO THEN SKIP CHECK.
         CLI   11(R15),0           IS GROUP NAME A UNIT TYPE. ?
         BNE   ERR06               IF SO THEN ERROR.
         SPACE 1                                                      *
*                                                                     *
*        IDENTIFY OPERATION REQUESTED AND PROCESS DEVICES.            *
*                                                                     *
         SPACE 1                                                      *
         CLI   INCARD+9,C'R'       IS 'RENAME' REQUESTED ?
         BE    RENAME              IF SO THEN GO TO ISSUE RENAME.
         MVC   GROUPN,0(R15)       SAVE GROUP NAME.
         MVC   OPCODE,INCARD+9     SAVE OPERATION CODE.
         SR    R15,R8              SET GR15 = OFFSET IN NAME TABLE.
         SR    R14,R14             SET GR14 = 0
         LA    R0,12               SET GR0 = 12.
         DR    R14,R0              SET GR15 = OFFSET NUMBER (GR14=4).
         MR    R14,R10             SET GR15 = INDEX TO MASK TABLE ENTRY
         LA    R6,4(R9,R15)        SET GR6 -> MASK TABLE ENTRY.
         LR    R1,R10              SET GR1 = LENGTH OF WORK AREA.
         BCTR  R1,R0               DECREMENT GR1 FOR EXECUTE.
         EX    R1,CLEARDYN         CLEAR DYNAMIC AREA.
         LA    R4,INCARD+11        SET GR4 -> START OF SCAN AREA.
SETSCAN  LA    R2,1                SET GR2 = 1.
         LA    R3,INCARD+L'INCARD-3 SET GR3 TO STOP SCAN.
         CLI   0(R4),C' '          IS CHARACTER NULL ?
         BNE   FINDNEXT            IF NOT THEN START TO PROCESS.
         BXLE  R4,R2,*-8           LOOP UNTIL START FOUND OR CARD ENDED
         B     ERR07               IF NO OPERAND THEN ERROR.
FINDNEXT BAL   R7,FINDUCB          LINK TO FIND AND VERIFY THE UCB.
         LR    R3,R14              SET GR3 -> UCB POINTER.
         SR    R14,R11             SET GR14 = OFFSET IN LOOK-UP TABLE.
         SRDL  R14,4               SET GR14 = BYTE OFFSET.
         SRL   R15,29              SET GR15 = BIT OFFSET.
         LA    R1,X'80'            SET GR1  = 128.
         SRL   R1,0(R15)           SHIFT GR1 FOR STORE.
         LA    R14,8(R14,R5)       SET GR14 -> BYTE TO BE SET.
         EX    R1,SETDEV1          SET DEVICE PRESENT.
         CLI   3(R4),C'-'          IS AN ADDRESS RANGE SPECIFIED ?
         BE    SETRANGE            IF SO THEN GO TO SET RANGE.
SETNEXT  CLI   3(R4),C' '          IS IT END OF OPERATION ?
         BE    SETCHNGE            IF SO THEN GO TO READ NEXT.
         CLI   3(R4),C','          IS ANOTHER DEVICE TO FOLLOW ?
         BNE   ERR08               IF NOT COMMA THEN ERROR.
         LA    R4,4(R4)            SET GR4 FOR NEXT.
         CLI   0(R4),C' '          IS A CONTINUATION REQUIRED ?
         BNE   FINDNEXT            IF NOT THEN GO TO FIND NEXT UCB.
         BAL   R7,GETSUB           LINK TO READ CONTINUATION.
         CLI   INCARD,C' '         IS FIRST CHARACTER BLANK ?
         BNE   ERR09               IF NOT THEN ERROR.
         LA    R4,INCARD+1         SET GR4 TO START SCAN.
         B     SETSCAN             GO TO SCAN FOR DEVICE ADDRESSES.
         SPACE 1                                                      *
*                                                                     *
*        SET A RANGE OF DEVICE ADDRESSES.                             *
*                                                                     *
         SPACE 1                                                      *
SETRANGE LA    R4,4(R4)            SET GR4 -> END OF RANGE UNIT ADDRESS
         BAL   R7,FINDUCB          GO TO FIND UCB.
         LR    R2,R14              SET GR2 -> RANGE END ADDRESS.
         CLR   R3,R2               TEST FOR VALID RANGE.
         BNH   SETLOOP1            IF SO THEN USE.
         LR    R2,R3               SET GR2 -> HIGH END.
         LR    R3,R14              SET GR3 -> LOW END.
SETLOOP1 LH    R1,0(R3)            SET GR1 -> UCB.
         LTR   R1,R1               TEST SIGN OF GR1.
         BNP   SETRNGEA            IF NO UCB THEN GO TO TEST NEXT.
         LR    R14,R3              SET GR14 -> UCB POINTER.
         SR    R14,R11             SET GR14 = OFFSET IN LOOK-UP TABLE.
         SRDL  R14,4               SET GR14 = BYTE OFFSET IN MASK TABLE
         SRL   R15,29              SET GR15 = BIT OFFSET IN MASK TABLE.
         LA    R1,X'80'            SET GR1 = 128.
         SRL   R1,0(R15)           SHIFT GR1 FOR EXECUTE.
         LA    R14,8(R14,R5)       SET GR14 -> BYTE TO BE SET.
         EX    R1,SETDEV1          SET DEVICE ADDRESS PRESENT.
SETRNGEA LA    R3,2(R3)            INCREMENT GR3 FOR NEXT.
         CLR   R3,R2               TEST FOR END OF RANGE.
         BNH   SETLOOP1            IF NOT THEN GO TO SET NEXT.
         B     SETNEXT             GO TO STORE NEXT ADDRESS.
CLEARDYN XC    0(0,R5),0(R5)       MODEL STATEMENT.
SETDEV1  OI    0(R14),0            MODEL STATEMENT.
         SPACE 1                                                      *
*                                                                     *
*        SET NEW BIT PATTERN.                                         *
*                                                                     *
         SPACE 1                                                      *
SETCHNGE LR    R1,R10                   SET GR1 = LENGTH OF MASK TABLE.
         LA    R0,9                     SET GR0 = 9
         SR    R1,R0                    DECREMENT GR1 FOR EXECUTE
         CLI   OPCODE,C'A'         IS NEW PATTERN TO BE ADDED ?
         BE    ADD                 IF SO THEN GO TO ADD.
         CLI   OPCODE,C'D'         IS NEW PATTERN TO BE DELETED ?
         BE    DELETE              IF SO THEN GO TO DELETE.
         CLI   OPCODE,C'C'         IS NEW PATTERN TO BE A REPLACEMENT ?
         BNE   ERR10               IF NOT THEN ERROR.
         EX    R1,CHANGEXC         CLEAR OLD PATTERN.
ADD      EX    R1,ADDOC            STORE NEW PATTERN.
         B     GETINPUT            GO TO READ INPUT.
DELETE   LA    R14,1(R1)           SET GR14 = NUMBER OF BYTES.
         LA    R15,8(R5)           SET GR15 -> FIRST BYTE.
         XI    0(R15),X'FF'        RESET BITS.
         LA    R15,1(R15)          INCREMENT GR15 FOR NEXT.
         BCT   R14,*-8             LOOP UNTIL ALL SET.
         EX    R1,DELETENC         DELETE ALL SET BITS.
         B     GETINPUT            GO TO READ INPUT.
CHANGEXC XC    8(0,R6),8(R6)       MODEL STATEMENT.
ADDOC    OC    8(0,R6),8(R5)       MODEL STATEMENT.
DELETENC NC    8(0,R6),8(R5)       MODEL STATEMENT.
         SPACE 1                                                      *
*                                                                     *
*        RENAME A GROUP.                                              *
*                                                                     *
         SPACE 1                                                      *
RENAME   LA    R4,INCARD+11        SET GR4 -> START OF SCAN AREA.
         LA    R2,1                SET GR2 = 1.
         LA    R3,INCARD+L'INCARD-8     SET GR3 TO STOP SCAN.
         CLI   0(R4),C' '          IS CHARACTER BLANK ?
         BNE   *+12                IF NOT THEN START TO PROCESS.
         BXLE  R4,R2,*-8           LOOP UNTIL START FOUND.
         B     ERR07A              IF NO OPERAND THEN ERROR.
         L     R14,0(R8)           SET GR14 = NUMBER OF DEVICES.
         LA    R1,4(R8)            SET GR1 -> FIRST NAME ENTRY.
RENAMELP CLC   0(8,R4),0(R1)       DOES NAME ALREADY EXIST ?
         BE    ERR11               IF SO THEN ERROR.
         LA    R1,12(R1)           INCREMENT GR1 FOR NEXT.
         BCT   R14,RENAMELP        LOOP UNTIL ALL NAMES CHECKED.
         MVC   0(8,R15),0(R4)      STORE NEW NAME.
         B     GETINPUT            GO TO READ NEXT INPUT.
         SPACE 1                                                      *
*                                                                     *
*        PRODUCE LISTING OF MODIFIED TABLES.                          *
*                                                                     *
         SPACE 1                                                      *
ENDINPUT LA    R0,1                SET GR0 = 1.
         ST    R0,LINECT           RESET LINE COUNT.
         FREEMAIN R,LV=(R10),A=(R5)     RELEASE DYNAMIC WORK AREA.
         L     R7,0(R8)            SET GR7 = NUMBER OF ENTRIES.
         LA    R9,4(R9)            SET GR9 -> FIRST MASK ENTRY.
         LA    R8,4(R8)            SET GR8 -> FIRST NAME ENTRY.
PRINTJ   ST    R7,DEVICECT         STORE COUNT.
         XC    NEXTUCB,NEXTUCB    CLEAR SEQUENTIAL UCB CHECK FIELD.
         MVC   LINE+5(8),0(R8)     STORE UNIT GROUP NAME.
         SR    R0,R0               SET GR0 = 0.
         ST    R0,DEVNUM           STORE NUMBER OF DEVICES = 0.
         MVC   LINE+14(LINEEND-LINE-14),LINE+13   CLEAR LINE.
         CLI   11(R8),0            IS GROUP NAME A UNIT TYPE ?
         BE    PRINTA              IF NOT THEN LEAVE.
         UNPK  LINE+14(9),8(5,R8)  UNPACK DEVICE TYPE.
         TR    LINE+14(8),TRTAB    CONVERT TO PRINTABLE FORMAT.
PRINTA   LA    R2,LINE+22          SET GR2 -> START OF LINE.
         LR    R6,R10              SET GR6 = LENGTH OF MASK ENTRY.
         LA    R0,8                SET GR0 = 8.
         SR    R6,R0               SET GR6 = NUMBER OF MASK BYTES.
         LA    R3,8(R9)            SET GR3 -> MASK.
         SR    R4,R4               SET GR4 = 0.
PRINTF   LA    R5,X'80'            SET GR5 = 128.
PRINTE   EX    R5,PRINTTM          TEST FOR DEVICE PRESENT.
         BZ    PRINTB              IF NOT THEN NO LIST.
         L     R1,DEVNUM           SET GR1 = NUMBER OF DEVICES SO FAR.
         LA    R1,1(R1)            INCREMENT DEVICE NUMBER.
         ST    R1,DEVNUM           STORE INCREMENTED DEVICE NUMBER.
         LH    R1,0(R4,R11)        SET GR1 -> UCB.
         CLI   0(R2),C'-'          IS A RANGE INDICATED ?
         BE    PRINTC              IF SO THEN GO TO CONTINUE RANGE.
PRINTK   MVC   1(3,R2),13(R1)      STORE UNIT ADDRESS.
         CLC   1(3,R2),NEXTUCB+1   IS THIS SEQUENTIAL UCB.?
         BNE   PRINTD              IF NOT THEN GO TO SET NEXT UCB.
         MVI   0(R2),C'-'          SET RANGE START.
PRINTL   L     R1,NEXTUCB          SET GR1 = NEXT UCB.
         LA    R1,1(R1)            INCREMENT FOR NEXT.
         ST    R1,NEXTUCB          STORE INCREMENTED UCB.
         CLI   NEXTUCB+3,X'FA'     IS IT 'A' UNIT ADDRESS ?
         BNE   *+8                 IF NOT THEN LEAVE.
         MVI   NEXTUCB+3,C'A'      STORE 'A' UNIT ADDRESS.
         CLI   NEXTUCB+3,C'G'      IS IT A NEW CONTROL UNIT ADDRESS ?
          BNE  PRINTM              IF NOT THEN LEAVE.
         LA    R1,X'129'(R1)       INCREMENT GR1 FOR STORE
         ST    R1,NEXTUCB          STORE NEW NEXT UNIT ADDRESS.
          CLI  NEXTUCB+2,X'FA'     IS IT CONTROL UNIT 'A' ?
          BNE  PRINTM              IF NOT THEN LEAVE.
          MVI  NEXTUCB+2,C'A'      STORE 'A' CONTROL UNIT ADDRESS.
PRINTM    LA   R0,LINEEND-3        SET GR0 -> END OF LINE.
         CR    R2,R0               COMPARE FOR FULL LINE.
         BL    PRINTB              IF NOT FULL THEN GO TO SET NEXT.
         LA    R2,LINE             SET GR2 -> LINE.
         MVI   LINE+22,C' '        CLEAR FIRST COMMA
         BAL   R7,PUTSUB           LINK TO WRITE OUTPUT.
         XC    NEXTUCB,NEXTUCB     CLEAR SEQUENTIAL UCB CHECK FIELD.
         MVI   LINE+5,C' '         CLEAR FIRST BYTE OF LINE.
         MVC   LINE+6(LINEEND-LINE-6),LINE+5 CLEAR LINE.
         LA    R2,LINE+22          SET GR2 FOR CONTINUATION.
PRINTB   LA    R4,2(R4)            INCREMENT GR4 FOR NEXT
         SRA   R5,1                SHIFT GR5 FOR NEXT EXECUTE.
         BP    PRINTE              IF NOT END THEN GO TO TEST.
         LA    R3,1(R3)            INCREMENT GR3 FOR NEXT BYTE.
         BCT   R6,PRINTF           LOOP UNTIL END OF MASK BYTES.
         LA    R0,LINEEND-L'DEVMSG SET GR0 -> LAST LOCATOON FOR DEVS.
         CLR   R2,R0               COMPARE FOR FIT.
         BL    PRINTG              IF FIT THEN GO TO STORE.
         MVI   LINE+22,C' '        CLEAR FIRST COMMA.
         LA    R2,LINE             SET GR2 -> MESSAGE.
         BAL   R7,PUTSUB           LINK TO WRITE OUTPUT.
         MVI   LINE+5,C' '         CLEAR FORST BYTE OF LINE.
         MVC   LINE+6(LINEEND-LINE-6),LINE+5      CLEAR LINE.
PRINTG   MVC   LINEEND-L'DEVMSG(L'DEVMSG),DEVMSG  STORE DEVICE NUMBER M
         L     R1,DEVNUM           SET GR1 = NUMBER OF DEVICES.
         LA    R0,1                SET GR0 = 1.
         CLR   R1,R0               COMPARE FOR ONE DEVICE ONLY.
         BNE   *+8                 IF NOT THEN LEAVE.
         MVI   LINEEND-1,C' '      CLEAR 'S' FROM 'D%VICES' IN MESSAGE.
         STH   R1,2(R9)            STORE DEVICE NUMBER IN MASK TABLE.
         CVD   R1,DW               CONVERT TO DECIMAL.
         ED    LINEEND-L'DEVMSG(4),DW+6 EDIT DEVICE NUMBER TO MESSAGE.
         MVI   LINE+22,C' '        CLEAR FIRST COMMA.
         LA    R2,LINE             SET GR2 -> MESSAGE.
         BAL   R7,PUTSUB           LINK TO WRITE MESSAGE.
         LA    R8,12(R8)           INCREMENT GR8 FOR NEXT NAME ENTRY.
         AR    R9,R10              INCREMENT GR9 FOR NEXT MASK ENTRY.
         L     R7,DEVICECT         SET GR7 = RESIDUAL GROUP NAME COUNT.
         BCT   R7,PRINTJ           LOOP UNTIL ALL NAMES PROCESSED.
         B     RESET               GO TO RESET UNIT NAMES AS REQUESTED.
         SPACE 1
PRINTC   CLC   13(3,R1),NEXTUCB+1  IS THIS SEQUENTAL UCB ?
         BE    PRINTK              IF SO THEN GO TO STORE.
         LA    R2,4(R2)            INCREMENT GR2 FOR NEXT.
         LA    R0,LINEEND-3        SET GR0 -> END OF LINE.
         CR    R2,R0               COMPARE FOR FULL LINE.
         BL    PRINTD              IF NOT FULL THEN GO TO SET NEXT.
         LA    R2,LINE             SET GR2 -> LINE.
         MVI   LINE+22,C' '        CLEAR FIRST COMMA.
         ST    R1,NEXTUCB          SET GR1 IN SAVE AREA
         BAL   R7,PUTSUB           LINK TO WRITE OUTPUT.
         L     R1,NEXTUCB          RESTORE GR1.
         MVI   LINE+5,C' '         CLEAR FIRST BYTE OF LINE.
         MVC   LINE+6(LINEEND-LINE-6),LINE+5 CLEAR LINE.
         LA    R2,LINE+22          SET GR2 FOR CONTINUATION
PRINTD   MVC   1(3,R2),13(R1)      STORE UNIT ADDRESS.
         MVI   0(R2),C','          STORE COMMA.
         MVC   NEXTUCB+1(3),13(R1) STORE UNIT ADDRESS FOR NEXT TEST.
         LA    R2,4(R2)            INCREMENT GR2 FOR NEXT.
         B     PRINTL              GO TO CALCULATE NEXT UCB.
PRINTTM  TM    0(R3),0             MODEL STATEMENT.
         SPACE 1                                                      *
*                                                                     *
*        STORE NEW DEVICE NAME/MASK TABLES AS REQUESTED.              *
*                                                                     *
         SPACE 1                                                      *
RESET    LA    R0,1                SET GR0 = 1
         ST    R0,LINECT           STORE NEW RESIDUAL LINE COUNT.
         TM    SW,SWDASD           ARE NEW TABLES TO BE WRITTEN TO DISK
         BZ    RESETA              IF NOT THEN GO TO CHECK FOR CORE.
         MVI   CCWMREAD,X'05'      SET 'MASK' CHANNEL PROGRAM TO WRITE.
         EXCP  IOBM                WRITE DEVICE MASK TABLE TO DASD.
         MVI   CCWNREAD,X'05'      SET 'NAME' CHANNEL PROGRAM TO WRITE.
         EXCP  IOBN                WRITE DEVICE NAME TABLE TO DASD.
RESETA   TM    SW,SWCORE           ARE NEW TABLES TO BE WRITTEN TO CORE
         BZ    RESETB              IF NOT THEN GO TO CHECK WRITE COMPLT
*                                                                     *
*  THE USER HAS REQUESTED THAT THE IN-CORE TABLES ARE TO BE REPLACED. I
* MUST THEREFORE CHECK THAT THE TABLES ARE RESIDENT. I FIRST ISSUE A
* BUILD LIST MACRO WITHOUT A DCB. IF THIS FAILS THEN THE OPERATING
* SYSTEM IS PRE RELEASE 19 AND IS BEING USED TO MODIFY A RELEASE 19 OR
* LATER LINK LIBRARY. IF THE BUILD LIST MACRO SUCCEEDS I THEN ISSUE TWO
* 'LOAD' MACRO INSTRUCTION TO BRING THE TABLES INTO CORE HAVING FIRST
* ENSURED THAT THE RE-ENTRANT ATTRIBUTE IS NOT SPECIFIED. I CAN NOW
* DETERMINE WHETHER THE TABLES HAVE BEEN MADE RESIDENT BY TESTING THE
* STORAGE KEY. AS I HAVE PREVENTED THE MODULES FROM BEING LOADED INTO
* SUB-POOL 252 (MVT) BY REMOVING THE RE-ENTRANT ATTRIBUTE I CAN ASSUME
* THAT THE TABLES ARE RESIDENT IN THE LINK PACK AREA IF THE STORAGE KEY
* IS ZERO.
*                                                                     *
*  TO TEST THE STORAGE KEY AND TO REPLACE THE TABLES I MUST ENTER
* SUPERVISOR STATE AND PROTECT KEY ZERO. THIS I DO BY MEANS OF THE
* LOCAL MACRO - 'SPMODE'.
*                                                                     *
         BLDL  0,LIST              BUILD LIST FROM SYS1.LINKLIB.
         LTR   R15,R15             TEST FOR NORMAL COMPLETION.
         BNZ   ERR12               IF NOT NORMAL COMPLETION THEN ERROR.
         NI    LIST+4+22,X'7F'     REMOVE RE-ENTRANT ATTRIB. FROM MASK.
         NI    LIST+62+22,X'7F'    REMOVE RE-ENTRANT ATTRIB. FROM NAME.
         LOAD  DE=LIST+4           LOAD MASK TABLE.
         LR    R9,R0               SET GR9 -> MASK TABLE.
         LOAD  DE=LIST+62          LOAD NAME TABLE.
         LR    R8,R0               SET GR8 -> NAME TABLE.
         SPMODE SUPV,0             ENTER SUPERVISOR MODE,PROTECT KEY 0.
         SR    R4,R4               SET GR4 = 0
         N     R9,ISKMASK          SET BITS 28-31 TO ZERO.
         ISK   R4,R9               INSERT STORAGE KEY OF MASK TABLE.
         LTR   R4,R4               TEST FOR ZERO STORAGE KEY.
         BNZ   ERR13               IF NOT ZERO STORAGE KEY THEN ERROR.
         L     R6,CCWMREAD         SET GR6 -> MODIFIED MASK TABLE.
         LH    R1,CCWMREAD+6       SET GR1 = LENGTH OF MASK TABLE.
         BAL   R7,MOVESUB          LINK TO STORE NEW MASK TABLE IN CORE
RESETD   DELETE EPLOC=LIST+4       REMOVE LIST.
         N     R8,ISKMASK          SET BITS 28-31 TO ZERO.
         ISK   R4,R8               INSERT STORAGE KEY OF NAME TABLE.
         LTR   R4,R4               TEST FOR ZERO STORAGE KEY.
         BNZ   ERR14               IF NOT ZERO STORAGE KEY THEN ERROR.
         LR    R9,R8               SET GR9 FOR MOVE.
         L     R6,CCWNREAD         SET GR6 -> MODIFIED DEVICE NAME TAB.
         LH    R1,CCWNREAD+6       SET GR1 = LENGTH OF DEVICE NAME TAB.
         MVC   MSGMOVE+9(8),LIST+62     STORE 'DEVNAMET' IN MESSAGE.
         BAL   R7,MOVESUB          LINK TO STORE NEW NAME TABLE IN CORE
RESETE   DELETE EPLOC=LIST+62      REMOVE TABLE.
         SPMODE PROB,*             RESTORE PROBLEM STATE & USER PROTECT
         SPACE 1                                                      *
*                                                                     *
*        CHECK FOR COMPLETION OF WRITE.                               *
*                                                                     *
         SPACE 1                                                      *
RESETB   TM    SW,SWDASD           IS WRITE TO DISK REQUESTED ?
         BZ    RESETC              IF NOT THEN GO TO WINDUP.
         WAIT  2,ECBLIST=ECBLIST   WAIT FOR COMPLETION.
         CLI   ECBM,X'7F'          WAS MASK WRITTEN NORMALLY ?
         BNE   ERR15               IF NOT THEN ERROR.
RESETF   CLI   ECBN,X'7F'          WAS NAME TABLE WRITTEN NORMALLY ?
         BNE   ERR16               IF NOT THEN ERROR.
RESETG   LA    R2,MSGIOEND         SET GR2 -> I/O END MESSAGE.
         BAL   R7,PUTSUB           LINK TO WRITE I/O END MESSAGE.
         SPACE 1                                                      *
*                                                                     *
*        WIND-UP                                                      *
*                                                                     *
         SPACE 1                                                      *
RESETC   L     R1,CCWMREAD         SET GR1 -> DYNAMIC AREA.
         LA    R1,0(R1)            CLEAR HIGH ORDER BYTE.
         LH    R0,CCWMREAD+6       SET GR0 = LENGTH OF MASK TABLE.
         AH    R0,CCWNREAD+6       SET GR0 = LENGTH OF DYNAMIC AREA.
         FREEMAIN R,LV=(0),A=(1)   RELEASE DYNAMIC AREA.
CLOSE    CLOSE MF=(E,OPENL)        CLOSE ALL DATA SETA.
         SPACE 1                                                      *
*                                                                     *
*        RETURN.                                                      *
*                                                                     *
         SPACE 1                                                      *
         L     R15,RETURNCD        SET GR15 = RETURN CODE.
         GOBACK SAVE,RC=(15)       RETURN.
         EJECT
*                                                                     *
*        SUB-ROUTINES.                                                *
*                                                                     *
         SPACE 1                                                      *
GETSUB   GET   IN,INCARD           READ INPUT.
         LA    R1,INCARD+79        SET GR1 -> END OF INPUT.
         CLI   0(R1),C' '          IS CHARACTER BLANK ?
         BNE   *+8                 IF NOT THEN END FOUND
         BCT   R1,*-8              LOOP UNTIL END FOUND.
         LA    R0,OUTCARD-1        SET GR0 FOR SUBTRACT.
         SR    R1,R0               SET GR1 = LENGTH OF MESSAGE.
         LA    R0,5                SET GR0 = 5.
         CLR   R1,R0               COMPARE FOR BLANK CARD.
         BNH   ERR18               IF BLANK THEN ERROR.
         STH   R1,OUTCARD          STORE LENGTH OF MESSAGE.
         LA    R2,OUTCARD          SET GR2 -> OUTPUT MESSAGE.
         SPACE 3                                                      *
PUTSUB   TM    PRT+48,X'10'        IS SYSPRINT PRESENT ?
         BCR   8,R7                IF NOT THEN IGNORE.
         L     R1,LINECT           SET GR1 = LINE COUNT.
         BCT   R1,PUTSUBA          TEST FOR NEW PAGE REQUIRED.
         PUT   PRT,SKIP            SKIP TO A NEW PAGE.
         AP    PAGENO,P1           INCREMENT PAGE NUMBER.
         MVC   TITPAGE,PAGEMASK   STORE MASK FOR EDIT.
         ED    TITPAGE,PAGENO     EDIT PAGE NUMBER INTO TITLE.
         PUT   PRT,TITLE           WRITE TITLE.
         LA    R1,56               SET GR1 = LINE COUNT.
PUTSUBA  ST    R1,LINECT           STORE NEW RESIDUAL LINE COUNT.
         PUT   PRT,(R2)            WRITE OUTPUT.
         BR    R7                  RETURN.
         SPACE 3                                                      *
FINDUCB  FINDUCB DEVADDR=(R4),TO=(R1)   FIND UNIT CONTROL BLOCK.
         LTR   R14,R14             TEST GR14 FOR VALID ADDRESS.
         BNP   ERR17               IF NOT VALID THEN ERROR.
         LTR   R1,R1               TEST GR1 FOR VALID ADDRESS.
         BNP   ERR17               IF NOT VALID THEN ERROR.
         CLC   0(3,R4),13(R1)      IS DEVICE ADDRESS AS SPECIFIED ?
         BNE   ERR17               IF NOT THEN ERROR.
         BR    R7                  RETURN.
         SPACE 3                                                      *
MOVESUB  BCTR  R1,R0               DECREMENT GR1 FOR EXECUTE.
         LA    R0,255              SET GR0 = 255.
MOVESUBB CR    R1,R0               CHECK FOR 256 BYTES REMAINING.
         BNH   MOVESUBA            IF NOT GREATER THEN GO TO LAST MOVE.
         MVC   0(256,R9),0(R6)     MOVE 256 BYTES.
         LA    R9,256(R9)          INCREMENT GR9 FOR NEXT MOVE.
         LA    R6,256(R6)          INCREMENT GR6 FOR NEXT MOVE.
         SH    R1,*-2              DECREMENT GR1 FOR TEST.
         B     MOVESUBB
MOVESUBA EX    R1,MOVESUBC         MOVE REMAINING BYTES.
         LA    R2,MSGMOVE          SET GR2 -> MESSAGE FOR PRINTING.
         B     PUTSUB              GO TO PRINT MESSAGE.
MOVESUBC MVC   0(0,R9),0(R6)       MODEL STATEMENT.
         EJECT
*                                                                     *
*        ERROR ROUTINES.                                              *
*                                                                     *
         SPACE 1                                                      *
ERR01    LA    R2,MSGERR01         SET GR2 -> ERROR MESSAGE.
ERR01A   BAL   R7,PUTSUB           LINK TO WRITE ERROR MESSAGE.
         LA    R15,16              SET GR15 = RETURN CODE.
         BAL   R7,ERRSUB           LINK TO SET ERROR CODE.
         B     CLOSE               GO TO CLOSE DATA SETS.
         SPACE 3                                                      *
ERR02    LA    R2,MSGERR02         SET GR2 -> ERROR MESSAGE
         B     ERR01A              GO TO COMMON CODE.
         SPACE 3                                                      *
ERR03    LA    R2,MSGERR03         SET GR2 -> ERROR MESSAGE.
         B     ERR01A              GO TO COMMON CODE.
         SPACE 3                                                      *
ERR04    LA    R2,MSGERR04         SET GR2 -> ERROR MESSAGE.
         BAL   R7,PUTSUB           LINK TO WRITE ERROR MESSAGE.
         LA    R15,16              SET GR15 = RETURN CODE.
         BAL   R7,ERRSUB           LINK TO SET ERROR CODE.
         B     RESETC              GO TO RELEASE DYNAMIC AREA.
         SPACE 3                                                      *
ERR05    LA    R2,MSGERR05         SET GR2 -> ERROR MESSAGE.
ERR05A   BAL   R7,PUTSUB           LINK TO WRITE ERROR MESSAGE.
         LA    R15,8               SET GR15 = RETURN CODE.
         BAL   R7,ERRSUB           LINK TO SET ERROR CODE.
         B     GETINPUT            GO TO READ NEXT INPUT.
         SPACE 3                                                      *
ERR06    LA    R2,MSGERR06         SET GR2 -> ERROR MESSAGE.
         B     ERR05A              GO TO COMMON CODE.
         SPACE 3                                                      *
ERR07    LA    R2,MSGERR07         SET GR2 -> ERROR MESSAGE.
ERR07B   BAL   R7,PUTSUB           LINK TO WRITE ERROR MESSAGE.
         LA    R15,4               SET GR15 = 4.
         BAL   R7,ERRSUB           LINK TO SET ERROR CODE.
         B     SETCHNGE            GO TO STORE NEW BIT PATTERN.
         SPACE 1                                                      *
ERR07A   LA    R2,MSGERR07         SET GR2 -> ERROR MESSAGE.
         B     ERR05A              GO TO COMMON CODE.
         SPACE 3                                                      *
ERR08    LA    R2,MSGERR08         SET GR2 -> ERROR MESSAGE.
         B     ERR07B              GO TO COMMON CODE.
         SPACE 3                                                      *
ERR09    LA    R2,MSGERR09         SET GR2 -> ERROR MESSAGE.
         B     ERR07B              GO TO COMMON CODE.
         SPACE 3                                                      *
ERR10    LA    R2,MSGERR10         SET GR2 -> ERROR MESSAGE.
         B     ERR05A              GO TO COMMON CODE.
         SPACE 3                                                      *
ERR11    LA    R2,MSGERR11         SET GR2 -> ERROR MESSAGE.
         B     ERR05A              GO TO COMMON ERROR ROUTINE.
         SPACE 3                                                      *
ERR12    LA    R2,MSGERR12         SET GR2 -> ERROR MESSAGE.
         BAL   R7,PUTSUB           LINK TO WRITE ERROR MESSAGE.
         LA    R15,12              SET GR15 = 12.
         BAL   R7,ERRSUB           LINK TO STORE ERROR CODE.
         B     RESETB              GO TO CONTINUE DASD PROCESSING.
         SPACE 3                                                      *
ERR13    LA    R2,MSGERR13         SET GR2 -> ERROR MESSAGE.
         BAL   R7,PUTSUB           LINK TO WRITE ERROR MESSAGE.
         LA    R15,12              SET GR15 = 12.
         BAL   R7,ERRSUB           LINK TO STORE ERROR CODE.
         B     RESETD              GO TO DELETE LOAD MODULE.
         SPACE 3                                                      *
ERR14    LA    R2,MSGERR14         SET GR2 -> ERROR MESSAGE.
         BAL   R7,PUTSUB           LINK TO WRITE ERROR MESSAGE.
         LA    R15,12              SET GR15 = 12
         BAL   R7,ERRSUB           LINK TO STORE ERROR CODE.
         B     RESETE              GO TO DELETE LOAD MODULE.
         SPACE 3                                                      *
ERR15    LA    R2,MSGERR15         SET GR2 -> ERROR MESSAGE.
         BAL   R7,PUTSUB           LINK TO WRITE ERROR MESSAGE.
         LA    R15,12              SET GR15 = 12.
         BAL   R7,ERRSUB           LINK TO STORE ERROR CODE.
         B     RESETF              GO TO TEST NAME TABLE WRITE.
         SPACE 3                                                      *
ERR16    LA    R2,MSGERR16         SET GR2 -> ERROR MESSAGE.
         BAL   R7,PUTSUB           LINK TO WRITE ERROR MESSAGE.
         LA    R15,12              SET GR15 = 12.
         BAL   R7,ERRSUB           LINK TO STORE ERROR CODE.
         B     RESETG              GO TO STORE I0O COMPLETE MESSAGE.
         SPACE 3                                                      *
ERR17    MVC   MSGERR17+9(3),0(R4) STORE FAILING UNIT ADDRESS.
         LA    R2,MSGERR17         SET GR2 -> ERROR MESSAGE.
         BAL   R7,PUTSUB           LINK TO WRITE ERROR MESSAGE.
         LA    R15,4               SET GR15 = 4 .
         BAL   R7,ERRSUB           LINK TO STORE ERROR CODE.
         CLI   3(R4),C'-'          IS DEVICE ADDRESS START OF A RANGE ?
         BNE   SETNEXT             IF NOT THEN GO TO CHECK DELIMITER.
         MVI   3(R4),C','          SIMULATE NON-RANGE SPECIFICATION.
         B     SETNEXT             GO TO SET NEXT DEVICE.
         SPACE 3                                                      *
ERR18    LA    R2,MSGERR18         SET GR2 -> ERROR MESSAGE.
         LR    R3,R7               SAVE RETURN ADDRESS.
         BAL   R7,PUTSUB           LINK TO WRITE ERROR MESSAGE.
         LA    R15,4               SET GR15 = 4.
         BAL   R7,ERRSUB           LINK TO STORE ERROR CODE.
         LR    R7,R3               RESTORE RETURN ADDRESS.
         B     GETSUB              GO TO READ NEXT RECORD.
         SPACE 3                                                      *
ERRSUB   C     R15,RETURNCD        COMPARE RETURN CODE WITH HIGHEST.
         BCR   13,R7               IF NOT GREATER THEN LEAVE.
         ST    R15,RETURNCD        STORE NEW GREATEST RETURN CODE.
         EX    R0,ERRSUBA(R15)     TEST FOR ABEND.
         BCR   8,R7                IF NOT THEN RETURN.
         LR    R2,R15              SAVE ABEND CODE.
         CLOSE MF=(E,OPENL)        CLOSE ALL DATA SETS.
         ABEND (R2),DUMP           ABEND.
ERRSUBA  TM    SW,0
         TM    SW,SWABEW           ABEND IF ON WARNING.
         TM    SW,SWABEW+SWABEE    ABEND IF ON WARNING/ERROR.
         TM    SW,SWABEW+SWABEE+SWABES  ABEND IF ON WARNING/ERR/S ERROR
         TM    SW,SWABE            ABEND IF ON ANY CONDITION.
         EJECT
*                                                                     *
*        EXIT ROUTINES.                                               *
*                                                                     *
         SPACE 1                                                      *
DCBEXIT  DCBEXITS
         EJECT
*                                                                     *
*        CONSTANTS AND WORK AREAS.                                    *
*                                                                     *
         SPACE 1                                                      *
SAVE     DC    9D'0'
DW       DS    D
CPN      CCW   X'31',IOBN+35,X'40',5
         CCW   X'08',CPN,0,0
CCWNREAD CCW   X'06',0,0,0
CPM      CCW   X'31',IOBM+35,X'40',5
         CCW   X'08',CPM,0,0
CCWMREAD CCW   X'06',0,0,0
IN       DCB   DDNAME=SYSIN,DSORG=PS,MACRF=GM,RECFM=FB,LRECL=80,       *
               EODAD=ENDINPUT
LIB      DCB   DDNAME=SYSLIB,MACRF=E
         DC    A(0)                PADDING TO AVOID USER TOTALLING.
PRT      DCB   DDNAME=SYSPRINT,DSORG=PS,MACRF=PM,RECFM=VBM,LRECL=133,  *
               BLKSIZE=2178,EXLST=DCBEXIT
OPENL    OPEN  (IN,,LIB,OUTPUT,PRT,OUTPUT),MF=L
ECBLIST  DC    A(ECBN),X'80',AL3(ECBM)
ECBN     DC    A(0)
ECBM     DC    A(0)
IOBN     DC    0A(0),X'42',A(ECBN,0,0,CPN,LIB,0,0),2A(0)
IOBM     DC    0A(0),X'42',A(ECBM,0,0,CPM,LIB,0,0),2A(0)
LINECT   DC    A(1)
DEVICECT DS    F
DEVNUM   DC    A(0)                NUMBER OF DEVICES IN GROUP.
NEXTUCB  DC    A(0)
RETURNCD DC    A(0)
LIST     DC    H'2,58',CL58'DEVMASKT',CL58'DEVNAMET'
GROUPN   DS    CL8
TRTAB    EQU   *-C'0'
         DC    C'0123456789ABCDEF'
OUTCARD  DC    H'0,0',X'09'
INCARD   DS    CL80
SW       DC    AL1(0)
SWDASD   EQU   X'80'
SWCORE   EQU   X'40'
SWOVRD   EQU   X'20'
SWABE    EQU   X'10'         'UMBRELLA' SWITCH FOR ABEND SPEC'D.
SWABEW   EQU   X'08'
SWABEE   EQU   X'04'
SWABES   EQU   X'02'
SWABET   EQU   X'01'
LINE     DC    H'137,0',X'09',CL132' '
LINEEND  DS    0C
PAGENO   DC    PL2'0'             PAGE NUMBER.
P1       DC    P'1'
OPCODE   DS    C
PAGEMASK DC    X'40202020'
ISKMASK  DC    0F'0',X'FFFFFFF0'   MASK FOR ISK INSTRUCTIONS.
TITLE    DC    0H'0',AL2(TITEND-TITLE,0),X'19'
         DC    C'RT5021M  DEVICE NAME/MASK  UPDATE/LISTING PROGRAM. '
         DC    C'PARAMETERS USED='
TITPARMS DC    4CL5' ',C'TIME='
TITIME   DC    X'402021204B2020',C' DATE= '
TITDATE  DC    X'4021204B202020',C'       PAGE'
TITPAGE  DC    X'40202020'
TITEND   DS    0C
SKIP     DC    H'6,0',X'89',C' '   SKIP TO A NEW PAGE.
PARMTAB  DC    C'DASD',AL1(SWDASD)
         DC    C'CORE',AL1(SWCORE)
         DC    C'OVRD',AL1(SWOVRD)
         DC    C'ABEW',AL1(SWABEW+SWABE)
         DC    C'ABEE',AL1(SWABEE+SWABE)
         DC    C'ABES',AL1(SWABES+SWABE)
         DC    C'ABET',AL1(SWABET+SWABE)
         DC    X'FF'
         EJECT
MSGERR01 DLINE 09,'001 SYSLIB DATA SET NOT SPECIFIED.'
MSGERR02 DLINE 09,'002 DEVICE NAME/MASK NOT FOUND IN SYSLIB.'
MSGERR03 DLINE 09,'003 PROGRAM CANNOT PROCESS TABLES THAT ARE SPLIT INT*
               O MULTIPLE TEXT BLOCKS.'
MSGERR04 DLINE 09,'004 I/O ERROR READING THE MASK OR NAME TABLE FROM TH*
               E SYSLIB DATA SET.'
MSGERR05 DLINE 09,'005 THE GROUP NAME SPECIFIED DOES NOT EXIST.'
MSGERR06 DLINE 09,'006 THE GROUP NAME SPECIFIED IS A UNIT TYPE NAME.'
MSGERR07 DLINE 09,'007 NO OPERAND SPECIFIED OR BLANK DELIMITER - SCAN T*
               ERMINATED.'
MSGERR08 DLINE 09,'008 INVALID DELIMITER - SCAN TERMINATED.'
MSGERR09 DLINE 09,'009 INVALID CONTINUATION - SCAN TERMINATED.'
MSGERR10 DLINE 09,'010 INVALID OPERATION'
MSGERR11 DLINE 09,'011 THE NEWNAME SPECIFIED IN THE RENAME OPERATION AL*
               READY EXISTS IN THE NAME TABLE.'
MSGERR12 DLINE 09,'012 DEVICE NAME/MASK NOT FOUND IN SYS1.LINKLIB - UNA*
               BLE TO SATISFY ''CORE'' PARAMETER.'
MSGERR13 DLINE 09,'013 DEVICE MASK TABLE NOT FOUND IN LINK PACK AREA - *
               UNABLE TO SATISFY ''CORE'' PARAMETER.'
MSGERR14 DLINE 09,'014 DEVICE NAME TABLE NOT FOUND IN LINK PACK AREA - *
               UNABLE TO SATISFY ''CORE'' PARAMETER.'
MSGERR15 DLINE 09,'015 I/O ERROR WRITING THE MASK TABLE TO THE SYSLIB D*
               ATA SET.'
MSGERR16 DLINE 09,'016 I/O ERROR WRITING THE NAME TABLE TO THE SYSLIB D*
               ATA SET.'
MSGERR17 DLINE 09,'017     IS AN INVALID DEVICE ADDRESS - IGNORED.'
MSGERR18 DLINE 09,'018 NULL INPUT IGNORED.'
MSGIOEND DLINE 09,'*** I/O OPERATION COMPLETE. NORMAL UNLESS 015 OR 016*
                APPEAR.'
MSGMOVE  DLINE 09,'*** DEVMASKT TABLE MOVED TO LINK PACK AREA.'
         SPACE 3
DEVMSG   DC    C' 000 DEVICES'
         ORG   DEVMSG
         DC    X'40202120'
         ORG
         END
