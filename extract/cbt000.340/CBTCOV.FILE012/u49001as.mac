          TITLE 'PROGRAM TO SQUISH A DISK VOLUME                      '
***********************************************************************
*                                                                     *
* SQUISH                                                              *
*         DIRECT ACCESS VOLUME COPY PROGRAM                           *
*         SHARE PROGRAM LIBRARY AGENCY PROGRAM NUMBER 360D-00.5.007   *
*         AUTHOR : KARL BARNHARDT                                     *
*                  BELL TELEPHONE LABORATORIES INC                    *
*                  6200 E. BROAD STREET                               *
*                  COLUMBUS, OHIO 43213.                              *
*                  TEL 614-868-2151                                   *
*                                                                     *
*        THIS UTILITY PROGRAM COMPRESSES USED DIRECT ACCESS SPACE ON  *
*        AN OS VOLUME INTO CONTIGUOUS AREAS THEREBY GATHERING FREE    *
*        AREAS INTO ONE OR MORE LARGER FREE AREAS.  THIS IS DONE BY   *
*        COPYING ALL DATASETS FROM ONE DIRECT ACCESS VOLUME TO ANOTHER*
*        VOLUME OF THE SAME TYPE.  INDEXED SEQUENTIAL AND UNMOVABLE   *
*        DATASETS ARE COPIED TO THE SAME LOCATION ON THE RECIEVING    *
*        VOLUME AS THEY OCCUPIED ON THE ORIGINAL VOLUME.  THE USED    *
*        EXTENTS OF ALL REMAINING DATASETS ARE ALLOCATED ON THE       *
*        RECIEVING VOLUME STARTING AT THE FIRST AVAILABLE TRACK AFTER *
*        THE VOLUME LABEL AND PROCEEDING UPWARD.  PARTITIONED DATASETS*
*        ARE NOT COMPRESSED WHEN COPIED.  IF A CATALOG DATASET EXISTS *
*        IT IS ALLOCATED NEXT TO THE VTOC.  ASSUMING SOME ORIGINAL    *
*        FRAGMENTATION THE RESULT IS A DIRECT ACCESS VOLUME WITH      *
*        LARGER CONTIGUOUS FREE AREAS.  THE NUMBER OF FREE AREAS      *
*        DEPENDS ON THE LOCATION AND NUMBER OF LOCATION DEPENDENT     *
*        DATASETS.  AN OPTION ADDED AT LUCAS GROUP COMPUTER CENTRE    *
*        ALLOWS DATASETS TO BE PRE-ALLOCATED ON THE RECIEVING VOLUME. *
*                                                                     *
*                                                                     *
* PROGRAM USE                                                         *
*                                                                     *
* (1) SQUISH YYYYYY ONTO ZZZZZZ                                       *
* //SQUISH EXEC PGM=SQUISH,REGION=90K                                 *
* //SYSPRINT DD SYSOUT=A                                              *
* //SYSUT1   DD UNIT=XXXX,VOL=SER=YYYYYY,DISP=OLD                     *
* //SYSUT2   DD UNIT=XXXX,VOL=SER=ZZZZZZ,DISP=OLD                     *
*          WHERE XXXX IS ANY DIRECT ACCESS DEVICE UNIT NAME,          *
*          YYYYYY IS THE NAME OF THE VOLUME TO BE COPIED, AND         *
*          ZZZZZZ IS THE NAME OF THE VOLUME WHICH WILL CONTAIN THE    *
*          COPY OF VOLUME YYYYYY.                                     *
*                                                                     *
* (2) SQUISH YYYYYY ONTO ZZZZZZ WITH PRE-ALLOCATED DATASETS ON ZZZZZZ *
* //SQUISH EXEC PGM=SQUISH,PARM='PRE-ALLOCATED DATASETS',REGION=90K   *
* //SYSPRINT DD SYSOUT=A                                              *
* //SYSUT1   DD UNIT=XXXX,VOL=SER=YYYYYY,DISP=OLD                     *
* //SYSUT2   DD UNIT=XXXX,VOL=SER=ZZZZZZ,DISP=OLD                     *
* //SYSUT3   DD UNIT=SYSDA,SPACE=(TRK,(1,1))                          *
*          WHERE XXXX IS ANY DIRECT ACCESS DEVICE UNIT NAME,          *
*          YYYYYY IS THE NAME OF THE VOLUME TO BE COPIED,             *
*          ZZZZZZ IS THE NAME OF THE VOLUME WHICH WILL CONTAIN THE    *
*          COPY OF VOLUME YYYYYY.  SYSUT3 IS USED TO HOLD A COPY OF   *
*          FORMAT 1 AND 3 DSCBS IN THE VTOC OF THE RECIEVING VOLUME.  *
*                                                                     *
***********************************************************************
         EJECT
         MACRO
&LABEL   CRASH
&LABEL   BAL   14,CRASH        GO TO CRASH ROUTINE
         MEND
         SPACE
         MACRO
&LABEL   WRTVTOC &LOC,&ADR,&IND
&LABEL   MVI   OUTER,0        CLEAR ERROR BYTE
         MNOTE *,' WRITE VTCOUTDB,DI,,&LOC+44,,&LOC,MF=E'
         WRITE VTCOUTDB,DI,,&LOC+44,,&LOC,MF=E
         MNOTE *,'CHECK VTOUTDB        WAIT TILL FINISHED'
         CHECK VTCOUTDB       WAIT TILL FINISHED
         AIF   (T'&IND NE 'O').OUT
         CLI   OUTER,0        SEE IF GOOD WRITE
         BE    *+8             GOODIE
         BAL   14,CRASH        GO CRASH
.OUT     ANOP
         AIF   (T'&ADR EQ 'O').OUT2
         L     14,VTCOUTDB+16  GET IOB ADDRESS
         IHBINNRA &ADR         GET PARM IN REG 1
         MVC   0(5,1),CCHHR(14) MOVE CCHHR OF ADDRESS
.OUT2    ANOP
         L     14,BLOCKAD      GET BLOCK #
         LA    14,1(14)        INCR
         ST    14,BLOCKAD      SAVE
         MEND
         SPACE
         MACRO
&LABEL   TTRABS &DCB,&ABSAD    CONVERT FROM TTR TO ABSOLUTE ADDRESS
&LABEL   L     1,&DCB+44       GET DEB ADDRESS
         LA    2,&ABSAD        GET ADDRESS OF ABSOULTE ADDRESS
         L     14,16           GET CVT ADDRESS
         L     15,X'1C'(14)    GET CONVERT ROUTINE ADDRESS
         LA    3,RGSAV         POINT TO SAVE AREA
         STM   9,13,0(3)       SAVE THEM
         BALR  14,15           GO TO IT
         LM    9,13,0(3)       RESTORE REGS.
         MEND
         SPACE 2
         MACRO
&LABEL   ABSTTR &DCB,&ABSAD    CONVERT FROM ABSOLUTE ADDRESS TO TTR
&LABEL   L     1,&DCB+44       GET DEB ADDRESS
         LA    2,&ABSAD        GET ADDRESS OF ABSOLUTE ADDRESS
         L     14,16           GET CVT ADDRESS
         L     15,X'20'(14)    GET CONVERT ROUTINE ADDRESS
         LA    3,RGSAV         GET ADDRESS OF SAVEA AREA
         STM   9,13,0(3)       SAVE REGS
         BALR  14,15           GO TO ROUTINE
         LM    9,13,0(3)       RESTORE REGS.
         MEND
         SPACE
         MACRO
&LABEL   READVTOC &LOC
         MNOTE *,'POINT DISKIN,FULL      POINT AT RECORD'
&LABEL   POINT DISKIN,FULL     POINT AT RECORD
         MVI   OUTER,0        CLEAR ERROR
         MNOTE *,'READ  VTOCINDB,SF,,&LOC,MF=E          '
         READ  VTOCINDB,SF,,&LOC,MF=E
         MNOTE *,'CHECK VTOCINDB         WAIT TO STOP'
         CHECK VTOCINDB        WAIT TO STOP
         CLI   OUTER,0        MAKE SURE NO ERROR
         BE    *+8            IF NOT, GOODIE
         BAL   14,CRASH       OTHERWISE, GO CRASH
         MEND
         EJECT
SQUISH   CSECT
         USING *,15
         B     START           GO AROUND MESSAGE
         DROP  15
         DC    AL1(L'STRTMES)
STRTMES  DC    C'SQUISHVOL - CONTACT KARL BARNHARDT (LOC-CB) IF ANY PROB
               BLEMS'
START    DS    0H
         SAVE  (14,12)
         BALR  12,0            12 IS PROGRAM BASE
         USING *,12
         ST    13,SAVE+4       SAVE    13
         LA    11,SAVE
         ST    11,8(13)        SET FORWARD CHAIN
         LR    13,11
         USING SAVE,13
         SPACE 3
* LOOK FOR PARM
         MVI   PREALFLG,0          ASSUME NO PRE-ALLOCATED DATASETS
         L     R1,0(R1)            R1 -> PARM
         LH    R2,0(R1)            LENGTH OF PARM
         LTR   R2,R2               +VE ?
         BNP   PRENONO             NO; NO PARM
         MVI   PREALFLG,X'FF'      ASSUME PRE-ALLOCATED DATASETS WANTED
         BCTR  R2,0                LESS 1 FOR CLC
         B     *+10                AROUND EX-EECUTED INSTRUCTION
PRECLC   CLC   2(0,R1),=C'PRE-ALLOCATED DATASETS'
         SPACE 1
         EX    R2,PRECLC           PRE-ALLOCATED DATASETS ???????
         BE    PRENONO             YES; SKIP
ABEND10  ABEND 10,DUMP             I JUST DONT UNDERSTAND
         SPACE 2
PRENONO  DS    0H
         SPACE 3
         OPEN  (SYSPRINT,OUTPUT)
         RDJFCB DISKIN
         MVI   INJFCB,4        SET VTOC AS DSNAME
         MVC   INJFCB+1(43),INJFCB
         OPEN  DISKIN,TYPE=J   OPEN VTOC
         RDJFCB DISKOUT        SET UP OUTPUT VTOC
         MVI   OUTJFCB,4       SET UP VTOC AS DSNAME
         MVC   OUTJFCB+1(43),OUTJFCB
         OI    OUTJFCB+52,X'08'        DON'T WRITE BACK JFCB
         OPEN  (DISKOUT,UPDAT),TYPE=J  OPEN OUTPUT VTOC
         L     4,DISKOUT+44    GET DEB ADDRESSES
         L     5,DISKIN+44
         L     4,32(4)         GET UCB ADDRESSES
         L     5,32(5)
         MVC   WTOR+X'20'(6),28(5)     MOVE VOL SER #
         MVC   WTOR+X'2C'(6),28(4)     MOVE VOL SER #
         CLC   16(4,4),16(5)   SEE IF UCBS THE SAME
         BE    UCBSMTCH        IF SO, GOODIE
DUMP     DS    0H
ABEND1   ABEND 1,DUMP          OTHERWISE BLAST OUT
UCBSMTCH DS    0H
         CLI   18(4),X'20'     MAKE SURE DIRECT ACCESS
         BNE   DUMP            IF NOT, THEN FORGET IT
 SPACE
ASKOP    DS    0H
         MVI   INECB,0         CLEAR ECB
         WTOR  MF=(E,WTOR)     SAK HIM
         WAIT  ECB=INECB       WAIT FOR ANSWER
         OI    FULL,X'40'      UP CASE REPLY
         CLI   FULL,C'Y'       DID HE SAY YES
         BE    OPSDYES         GOODIE
         CLI   FULL,C'N'       DID HE SAY NO
         BNE   ASKOP           IF NOT, THEN ASK HIM AGAIN
 SPACE
         LA    1,BDOPMES       GET ADDRESS OF MESSAGE
         BAL   11,WRTLINE      GO TELL USER
         L     13,SAVE+4       RESTORE REG 13
         RETURN (14,12),RC=8   RETURN WITH BAD RETURN CODE
 SPACE
OPSDYES  DS    0H
         ENQ   MF=(E,ENQL)     ENQ ON THE TWO VTOCS
 EJECT
         READ  VTOCINDB,SF,,VTOCIN,MF=E
         CHECK VTOCINDB
         SR    5,5             CLEAR 5
         IC    5,19(4)         GET LAST PART OD DEVICE TYPE
         SLL   5,1             MULT BY 2
         LH    5,DACYLS(5)     GET # OF CYLS
         STH   5,INCYLS
         STH   5,OUTCYLS
         MH    5,TRKPCYL       GET TOTAL # OF TRACKS
         STH   5,#TRKS         SAVE # OF TRACKS
         MVC   ABSAD,VTOCIN+45 GET TTR
         SR    0,0             OF LAST FMT 1
         ABSTTR DISKIN,ABSHD
         ST    0,LSTFM1        SAVE FOR FUTURE
 EJECT
         MVC   INDKAD,VTOCIN+45        MOVE LAST DS ADDRESS
         LH    5,INDKAD        GET CYL #
         MH    5,TRKPCYL       GET TRACK #
         AH    5,INDKAD+2      NOW HAVE REL TRK #
         MVC   OTDKAD,VTOCIN+107       MOVE EXTENT START
         LH    6,OTDKAD        GET CYL # OF START
         MH    6,TRKPCYL       GET TRACK #
         AH    6,OTDKAD+2      NOW HAVE REL TRK # OF START
         LA    5,1(5)          UP 1 FOR SUBTRACT
         SR    5,6             5 HAS # OF TRACKS
         SR    6,6             CLEAR 6
         IC    6,VTOCIN+74     GET DSCBS PER TACK
         MR    4,6             GET # OF DSCBS IN 5
         SLL   5,2             MULT 5 BY 4
         GETMAIN R,LV=(5)      GET CORE FOR DSCB LIST
         LA    1,0(1)          CLEAR HIGH BYTE
         S     1,=F'4'         REDUCE BY 4
         ST    1,DSLSTAD       SAVE ADDRESS-4
 EJECT
         POINT DISKIN,THIRD    POINT TO THIRD RECORD
         L     10,THIRD        GET FIRST TTR IN 10
         L     2,DSLSTAD       POINT TO DSLST
VTOCRD2  DS    0H
         LA    2,4(2)          UP TO BEGINNING
VTOCRD   DS    0H
         C     10,LSTFM1       SEE IF ON LAST DATA SET
         BNL   LFM1            IF SO, THEN START WORK
         READ  VTOCINDB,SF,,FMT1,MF=E
         CHECK VTOCINDB        WAIT FOR COMPLETION
         NOTE  DISKIN          GET TTR OF ONE JUST REASD
         LR    10,1            SAVE CURRENT TTR POINTER
         ST    1,0(2)          SAVE FOR FUTURE
         CLI   FMT1+44,X'F1'   SEE IF TYPE 1
         BNE   VTOCRD          IF NOT, READ AGAIN
         MVI   3(2),0          CLEAR ENDING BYTE
         TM    FMT1+82,X'80'   IS THIS IS DATA SET
         BZ    NTIS01          IF NOT, SKIP SETTING BIT
         OI    3(2),X'80'      TURN ON IS BIT
NTIS01   DS    0H
         TM    FMT1+82,X'01'   IS IT UNMOVABLE
         BZ    NTABS01         IF NOT, DON'T FLIP BIT
         OI    3(2),X'40'      TURN ON BIT
NTABS01  DS    0H
         CLC   CTLG,FMT1       IS IT THE SYSCTLG DATA SET
         BNE   NOTCT01         IF NOT, DON'T FLIP BIT
         OI    3(2),X'20'      TURN ON CTLG BIT
NOTCT01  DS    0H
         TM    FMT1+94,X'C0'   SEE IF CYLINDER ALLOCATION
         BNO   NOTCYL01        IF NOT, DON'T FLIP BIT
         OI    3(2),X'10'      TURN ON CYLINDER BIT
         B     VTOCRD2         GO INCR AND READ
NOTCYL01 DS    0H
         OI    3(2),X'08'      TURN ON TRACK BIT
         B     VTOCRD2
         EJECT
LFM1     DS    0H
         MVC   0(4,2),ZEROES   MOVE ZEROES TO END OF LIST
         READ  VTCOUTDB,DI,,VTOCOUT+44,,VTOCOUT,MF=E
         CHECK VTCOUTDB        WAIT FOR COMPLETION
         EJECT
* IF PRE-ALLOCATED DATASETS ARE  BEING USED NOW IS THE TIME TO
* COPY THE NEEDED DSCBS FROM THE VTOC ON THE OUTPUT DISK.
         SPACE 3
         CLI   PREALFLG,0
         BE    PRENONE         SKIP CALL
         L     R15,=A(PREALPTC)    @ OF RTN
         BALR  R14,R15             GET DSCBS
         SPACE 1
PRENONE  DS    0H
         EJECT
*        INITIALIZE FREE SPACE
*        MARK TRACK ZERO AS ALLOCATED
         MVI   FREESPAC,X'FF'
         MVC   STAD,VTOCOUT+107        GET VTOC START
         MVC   ENDAD,VTOCOUT+111       VTOC END
         LA    1,STAD          1 POINTS TO EXTENT
         BAL   14,ABSALC       GO ALLOCATE THE VTOC
         LH    14,ENDAD        GET VTOC ENDING CYLINDER
         MH    14,TRKPCYL      GET TRACK NUMBER
         AH    14,ENDAD+2      ADD IN TRACK
         STH   14,OTVTCEND     SAVE LAST TRACK NUMBER IN OUTPUT VTOC
         SPACE 2
         OI    FMT4+58,X'84'   TURN ON BAD VTOC BITS
         XC    BLOCKAD,BLOCKAD CLEAR RECORD #
         WRTVTOC FMT4          REWRITE FMT4
         NI    FMT4+58,X'FF'-X'84'     WIPE OUT BAD BITS
         LA    14,2            SET UP FIR FIRSFT DSCB BLOCK
         STH   14,REC#         SAVE IT
         EJECT
         OPEN  (OUTDISK,OUTPUT,INDISK),TYPE=J  OPEN DISK PACKS
         GETMAIN R,LV=400*8    GET SPACE FOR READ COUNTS AND DATA
         LA    1,0(1)          WIPE OUT HIGH BYTE
         ST    1,RDCNTAD       SAVE ADDRESS
         MVI   RDCNTAD,X'08'   REPLACE TIC CCW
         LA    2,1600(1)       POINT 2 AT COUNT AREA
         LA    3,199           SET UP 199 READ COUNT CCWS
         LA    4,8             DATA LENGTH OF 8
INITCCW  ST    2,0(1)          STORE DATA ADDRESS IN CCW
         ST    4,4(1)          STORE LENGTH
         MVI   0(1),X'12'      MOVE IN READ COUNT CCW
         MVI   4(1),X'40'      PUT IN COMMAND CHAINING
         LA    1,8(1)          INCREMENT TO NEXT CCW
         LA    2,8(2)          INCREMENT TO NEXT DATA AREA
         BCT   3,INITCCW       KEEP DOING IT
         ST    3,0(1)          PUT IN ADDRESS
         MVI   0(1),X'03'      PUT IN NO-OP CCW
         ST    4,4(1)          PUT IN ANY LENGTH
         MVI   4(1),X'20'      TURN ON SILI BIT
         GETMAIN R,LV=22600    GET CORE FOR DATA AND CCWS
         ST    1,DACCWADI      SAVE ADDRESS
         MVI   DACCWADI,X'08'  PUT BACK TIC
         LA    1,1600(1)       POINT TO DATA AREA
         ST    1,DATADI        SAVE IT
         GETMAIN R,LV=22600    GET CORE FOR OUTPUT DATA & CCWS
         ST    1,DACCWADO      SAVE CCW ADDRESS
         MVI   DACCWADO,X'08' PUT TIC OP CODE BACK
         LA    1,1600(1)       GET 1 UP TO DATA AREA
         ST    1,DATADO        SAVE ADDRESS OF DATA AREA
         EJECT
* IF PRE-ALLOCATED DATASETS ARE BEING USED, THEN COPY THEM NOW
         SPACE 1
         CLI   PREALFLG,0
         BE    PRENOMOV
         L     R15,=A(PREMOVE)
         BALR  R14,R15
PRENOMOV DS    0H
         EJECT
         L     4,DSLSTAD       POINT TO DSLST
INC1     LA    4,4(4)          UPDATE 4
         CLC   0(4,4),ZEROES   ARE WE THROUGH
         BE    GETCTLG         IF SO, GO FIND AND COPY SYSCTLG
         TM    3(4),X'C0'      IS IT UNMOVABLE
         BZ    INC1            IF NOT, THEN LOOK AGAIN
         BAL   11,GETVTOCS     GO READ THE VTOCS OF DS
         SR    0,0             CLEAR 0
         LA    1,INEXTS        GET EXTENT ADDRESS
         LA    2,16            16 MAX EXTENTS
ABSTST1  DS    0H
         CLC   0(8,1),ZEROES   ARE WE FINISHED
         BE    ABSOUT1         IF SO, DON'T DO IT AGAIN
         BAL   14,ABSALC       GO ALLOC ABS
         AH    0,TRKALC        ACCUM TRACKS ALLOCATED
         LA    1,8(1)          INCR. 1
         BCT   2,ABSTST1       KEEP IT UP
         SPACE
ABSOUT1  MVC   OUTEXTS(16*8),INEXTS    MOVE ALL EXTENTS
         STH   0,TRKUSD        SAVE FOR PUTDS
         BAL   11,PUTDS        GO WRITE DSCBS
         MVI   3(4),0          CLEAR LIST
         B     INC1            GO LOOK FOR NEXT
         EJECT
GETCTLG  DS    0H
         SR    7,7
         LA    2,PFMT5         GET FMT 5 ADDRESS
         LH    15,#TRKS        GET # OF TRKS
         LA    14,1
         LA    3,FREESPAC(15)  POINT PAST LAST TRACK
         MVI   0(3),X'FF'      SET AS ALLOCATED
         BCTR  15,0            REDUCE TO LAST TRACK
         SR    3,3
LKFREE1  LA    5,FREESPAC(3)   GET ADDRESS OF NEXT TRACK
         CLI   0(5),X'FF'      SEE IF ALLOCATED
         BNE   FFREE           IF SO, GOODIE
LKUP1    BXLE  3,14,LKFREE1    KEEP LOOKING
         B     PFMT5OUT        GET OUT IF ALL TRACKS
FFREE    DS    0H
         STH   3,4(2)          SAVE EXTENT START
LKFREE2  LA    3,1(3)          UPDATE 3
         LA    5,FREESPAC(3)   GET ADDRESS OF NEXT TRACK
         CLI   0(5),X'FF'      IS THIS FREE
         BNE   LKFREE2         IF SO, KEEP GOING
         LR    6,3
         LH    9,4(2)          GET STARTING TRACK IN 9
         LH    10,TRKPCYL      GET TRACK PER CYL
         AR    9,10            ADD TO 9
         BCTR  9,0             REDUCE BY 1
         SR    8,8             CLEAR 8 FOR DIVIDE
         DR    8,10
         MR    8,10            NOW REG 9 HAS NEXT HIGHEST CYL ADDRESS
         SH    6,4(2)          GET TOTAL TRACKS
         SH    9,4(2)          GET # TRKS BEFORE CYL
         CR    9,6             SEE WHICH IS BIGGER
         BNH   FIGR1           IF MORE THAN 1 CYL BRANCH
         STH   6,6(2)          STORE THE #
         B     LKINC1
FIGR1    DS    0H
         STH   9,6(2)          SAVE TRKS BEFORE CYL
         LCR   9,9             SET 9 NEGATIVE
         AR    9,6             NOW HAVE TRACKS LEFT
         DR    8,10            GET CY  S AGAIN
         STH   8,10(2)         SAVE TRKS AFTER LAST CYL
         MR    8,10            GET BACK TO TRACKS ON CYL
         STH   9,8(2)          SAVE TRKS ON CYL BOUND
LKINC1   LA    2,12(2)         INCR. 2
         LA    7,1(7)          INCR. EXT #
         B     LKUP1           GO LOOK FOR NEXT FREE EXTENT
PFMT5OUT DS    0H
         STH   7,#FREXTS       SAVE # OF FREE EXTENTS
         L     9,PFMT5AD       GET EXTENT POINTER
         LA    8,12(9)         8POINTS TO NEXT ONE
         LA    6,25            ONE LESS THAN FMT5 CAN HAVE
FRSETUP  ST    8,0(9)
         LA    9,12(9)         INCR 9
         LA    8,12(8)         INCR 8
         BCT   6,FRSETUP       DO IT FOR ALL
         ST    2,FPFMT5AD      SAVE FIRST FREE POINTER
         SH    2,=H'12'        GET TO LAST USED ELEMENT
         XC    0(4,2),0(2)     WIPE OUT CHAIN POINTER
         EJECT
         SR    6,6             CLEAR REG 6
         LA    5,3             GO THROUGH 3 TIMES
GETDS    DS    0H
         STM   5,6,R5R6        SAVE REGS 5 & 6
         L     4,DSLSTAD       POINT TO DSLST
INC2     LA    4,4(4)          INCR LIST POINTER
         CLC   0(4,4),ZEROES   ARE WE AT END OF LIST
         BE    THISDONE
         L     6,R5R6+4        RESTORE REG 6
         EX    0,TEST(6)       MAKE THE TEST
         BZ    INC2            BRANCH TO LOOK AT NEXT DS
         BAL   11,GETVTOCS     GO READ THE VTOC
         XC    OUTEXT(16*8),OUTEXT     CLEAR EXTENT AREA
         LH    11,FMT1+98      GET TTR OF LAST WRITTEN BLOCK
         LA    0,1(11)         NOW HAVE # OF TRACKS USED
         CLC   CTLG,FMT1       IT THIS THE CATALOG DATA SET
         BNE   GOON99          IF NOT, THEN PLAY DUMB
         LH    0,BIGGIE        GET A BIG NUMBER FOR TRACKS USER
GOON99   DS    0H
         STH   0,TRKUSD        SAVE FOR LATER
         SR    15,15           CLEAR 15
         SR    1,1             CLEAR 1
         LA    2,16            MAX @ OF EXTENTS
CYLEXT1  SR    3,3             CLEAR 3
         C     3,INEXT(1)      IS THIS EXTENT GOOD
         BE    CYLOUT          IF NOT, THEN WE'RE FINISHED
         BAL   14,ALCDS        GO ALLOCATE THE EXTENT
         LA    15,1(15)        INCR EXTENT REG
         LH    R14,TRKALC          ACCUMULATE TRACKS ALLOCATED
         AH    R14,TRKALL
         STH   R14,TRKALL
         SH    0,TRKALC        SUBTRACT TRACKS ALLOC.
         BZ    CYLOUT          IF ZERO, DATA FITS ON THIS EXTENT
         BM    ADD1TRK         IF MINUS - ADD 1 FOR GOOD MEASURE
         LA    1,8(1)          INCR EXTENT POINTER
         BCT   2,CYLEXT1       KEEP IT UP
ADD1TRK  DS    0H
         LH    1,TRKUSD        GET USED TRKS
         LA    1,1(1)          ADD 1
         STH   1,TRKUSD        AND SAVE FOR COPIER
CYLOUT   DS    0H
         STC   15,FMT1+59      SAVE # OF EXTENTS
         CLC   CTLG,FMT1       IF THIS THE CATALOG DATA SET
         BNE   GOON100         IF NOT, THEN NORMAL
         LCR   0,0             MAKE NUM NEGATIVE
         AH    0,BIGGIE        NOW REG 0 HAS TRACKS ALLOCATED
         STH   0,TRKUSD        MOVE DS WILL USE THIS NUMBER
GOON100  DS    0H
         BAL   11,PUTDS        WRITE THE DATA SET
         MVI   3(4),0          CLEAR FLAG BYTE
         B     INC2            LOOK FOR NEXT DATA SET
THISDONE DS    0H
         LM    5,6,R5R6        REATORE REGS 5 & 6
         LA    6,4(6)          INCR REG 6
         BCT   5,GETDS         KEEP GOING
         B     PDONE           WE'RE FINISHED COPYING DATA SETS
 SPACE
TEST     TM    3(4),X'20'      IS THIS THE SYSCTLG DATA SET
         TM    3(4),X'10'      IS THIS CYLINDER ALLOCATION
         CLI   3(4),0          HAS THIS BEEN COPIED
 EJECT
PDONE    DS    0H
         CLOSE (INDISK,,OUTDISK)       CLOSE BIGGIES
         XC    FMT5(140),FMT5  WIPE OUT FORMAT 5 DSCB
         LH    7,TRKPCYL       GET TRAKS PER CYL
         LA    8,FMT5+5        FIRST EXTENT LOC
         L     9,PFMT5AD       GET FIRST FORMAT 5 POINTER
         LA    14,26           MAX # OF FREE EXTENTS IN FORMAT 5
EXTST10  LTR   9,9             SEE IF GOOD EXTENT
         BZ    FMT5DONE        IF FINISHED GET OUT
         MVC   0(2,8),4(9)     MOVE EXTENT START
         SR    10,10           CLEAR 10
         LH    11,8(9)         GET TRKS ON CYL
         DR    10,7            GET CYLS
         STH   11,TCYL         STORE
         MVC   2(2,8),TCYL     MOVE TO EXTENT
         LH    11,6(9)         GET TRAKS BEFORE CYL
         AH    11,10(9)        ADD TRACKS AFTER LAST CYL
         STC   11,4(8)         SAVE IN EXTENT
         LA    8,5(8)          POINT TO NEXT EXTENT
         L     9,0(9)          POINT TO NEXT EXTENT
         BCT   14,EXTST10      KEEP MOVING
         CRASH ,               MORE THAN 26 FREE EXTENTS - DIE
FMT5DONE DS    0H
         L     14,VTCOUTDB+16  GET IOB ADDRESS
         MVC   FMT4+45(5),CCHHR(14)    MOVE CCHHR
         SR    8,8             CLEAR 8
         XC    FMT2(140),FMT2  WIPE OUT BIG AREA
WRT0     WRTVTOC FMT2,,A       WRITE A FMT0
         CLI   OUTER,0        SEE IF GOOD
         BNE   NOMORE          IF NOT, THEN WE RAN OUT OF ROOM
         LA    8,1(8)          ONE MORE GOOD FMT 0
         B     WRT0            GO TRY AGAIN
NOMORE   STH   8,FMT4+50       SAVE # OF AVAIL DSCB'S
         MVC   FMT5+4(40),FMT5+5       SET UP FMT5
         MVI   FMT5+44,X'F5'   PUT IN ID
         MVI   FMT5,5
         MVC   FMT5+1(3),FMT5  NOW HAVE GOOD FORMAT 5
         LA    9,1             GET REL REC # OF FMT5
         ST    9,BLOCKAD       SAVE
         WRTVTOC FMT5          WRITE OUT FMR 5
         XC    BLOCKAD,BLOCKAD CLEAR BLOCK ADDRESS
         WRTVTOC FMT4          WRITE IT OUT
         CLOSE (DISKIN,,DISKOUT)       CLOSE THE VTOCS
         CLOSE (INDISK,,OUTDISK)       CLOSE VOLS
         LH    R1,TRKCOPY      # TRACKS COPIED
         CVD   R1,WKDW         DECIMALISE
         ED    LTRKCOPY,WKDW+5 AND CHARACTERISE.
         LH    R1,TRKALL       # TRACKS ALLOCATED
         CVD   R1,WKDW         DECIMALISE
         ED    LTRKALL,WKDW+5  AND CHARACTERISE
         LA    1,ENDMES        GET ADDRESS OF ENDING MESSAGE
         BAL   11,WRTLINE      GO WRITE IT
         CLOSE SYSPRINT
         DEQ   MF=(E,ENQL)     DEQ THE TWO VTOCS
         L     13,SAVE+4       RESTORE REG 13
         RETURN (14,12),RC=0   RETURN WITH GOOD RETURN CODE
         SPACE
CRASH    DS    0H
EX       EX    0,EX            BLOW WIHT 0C3
         EJECT
ABSALC   LH    11,0(1)         GET STARTING CYL
         MH    11,TRKPCYL
         AH    11,2(1)         GET STARTING TRL
         LH    10,4(1)         GET ENDING CYL
         MH    10,TRKPCYL
         AH    10,6(1)         ADD ENDING TRK
         LA    10,1(10)        INCR.
         SR    10,11           GET LENGTH
         STH   10,TRKALC       SAVE # OF TRACKS IN EXTENT
         LA    11,FREESPAC(11) GET FREE SPACE
ABSLOOP  DS    0H
         CLI   0(11),X'FF'     IS THIS TRACK ALREADY ALLOCATED
         BE    BADNEWS         IF SO, VTOC PROBABLY HERE
         MVI   0(11),X'FF'     SET IT ALLOCATED
         LA    11,1(11)        INCR. 11
         BCT   10,ABSLOOP      KEEP    IT UP
         LH    R10,TRKALC      ACCUMULATE TRACKS ALLOCATED
         AH    R10,TRKALL
         STH   R10,TRKALL
         BR    14              RETURN
 SPACE
BADNEWS  DS    0H
ABEND3   ABEND 3,DUMP          KILL WITH A DUMP
         EJECT
*        THIS IS THE GETVTOCS SUBROUTINE
GETVTOCS MVC   FULL(3),0(4)    MOVE DSCB TTR
         MVI   FULL+3,0        CLEAR LAST BYTE
         READVTOC FMT1         READ THE DSCB
         XC    INEXTS(16*8),INEXTS     CLEAR EXTENTS
         LA    9,FMT1+105      POINT TO FIRST EXTENT
         LA    10,INEXTS       POINT TO IN CORE LIST
         LA    8,3             MAX OF THREE EXTENTS IN FMT 1
MVEXT11  MVC   0(8,10),2(9)    MOVE THE EXTENT
         LA    10,8(10)        INCR. 10
         LA    9,10(9)         INCR 9
         BCT   8,MVEXT11       KEEP IT UP
         LA    3,FMT1+135      ADDRESS FOR FMT 3 DSCB
         TM    3(4),X'80'      SEE IF IS
         BZ    NOTIS1          IF NOT, THEN FORGET IT
         MVC   ABSAD,0(3)      MOVE FMT2 ADDRESS
         SR    0,0             CLEAR 0
         ABSTTR DISKIN,ABSHD   GET TTR
         ST    0,FULL          SAE IT
         READVTOC FMT2         READ THE FORMAT2 DSCB
         LA    3,FMT2+135      POINT TO FMT 3 DSCB
NOTIS1   CLC   0(5,3),ZEROES   IS THERE A FMT 3
         BER   11              IF NONE, GO BACK
         MVC   ABSAD,0(3)      MOVE FMT3 POINTER
         SR    0,0             CLEAR 0
         ABSTTR DISKIN,ABSHD   CONVERT TO TTR
         ST    0,FULL          SAVE TTR
         READVTOC FMT3         READ THE DSCB
         LA    8,4             4 EXTENTS
         LA    9,FMT3+4        START OF 4TH EXTENT
MVEXT21  MVC   0(8,10),2(9)    MOVE AN EXTENT
         LA    10,8(10)        INCR 10
         LA    9,10(9)         INCR 9
         BCT   8,MVEXT21       KEEP IT UP
         LA    8,9             9 EXTENTS
         LA    9,FMT3+45       START OF 8TH EXTENT
MVEXT22  MVC   0(8,10),2(9)    MOVE THE EXTENT
         LA    10,8(10)        UPDATE 10
         LA    9,10(9)         UPDATE 9
         BCT   8,MVEXT22       KEEP IT UP
         BR    11              AND RETURN
         EJECT
PUTDS    DS    0H
         LH     R2,TRKUSD      ACCUMULATE TRACKS COPIED
         AH     R2,TRKCOPY
         STH    R2,TRKCOPY
PUTVTOCS LA    2,FMT1
         TM    3(4),X'80'      IS IT IS
         BZ    PTNOIS1         IF NOT, THEN FORGET IT
         LA    2,FMT2          GET FMT2 ADDRESS I N 2
PTNOIS1  DS    0H
         XC    135(5,2),135(2) WIPE OUT FMT 3 POINTER
         CLI   FMT1+59,3       ARE THERE MORE THAN 3 EXTENTS
         BNH   PTNOFMT3        IF <= 3 - NO FORMAT 3
         LA    5,FMT3+4        POINT TO FIRST
         LA    6,OUTEXTS+3*8   POINT TO THIRD EXTENT
         LA    7,4             FOUR EXTENTS
PT3MV1   MVC   2(8,5),0(6)     MOVE AN EXTENT
         CLC   0(8,6),ZEROES   SEE IF EXTENT IS ZERO
         BNE   GOON1           IF NOT, THEN GOOD
         XC    0(2,5),0(5)     WIPE OUT FIRST TWO BYTES
GOON1    DS    0H
         BAL   14,TRKCYLB     **LUCAS CHECK**
         LA    5,10(5)         INCR 10
         LA    6,8(6)          INCR 6
         BCT   7,PT3MV1        KEEP IT UP
         LA    5,FMT3+45
         LA    7,9             9 EXTENTS DOWN HERE
PT3MV2   MVC   2(8,5),0(6)     MOVE AN EXTENT
         CLC   0(8,6),ZEROES   SEE IF EXTENT IS ZERO
         BNE   GOON2           IF NOT, THEN GOOD
         XC    0(2,5),0(5)     WIPR OUT FIRST TWO BYTES
GOON2    DS    0H
         BAL   14,TRKCYLB     **LUCAS CHECK**
         LA    5,10(5)         INCR 5
         LA    6,8(6)          INCR 6
         BCT   7,PT3MV2
         WRTVTOC FMT3,135(2)   WRITE FORMAT3 AND MOVE ADDRESS
PTNOFMT3 TM    3(4),X'80'      SEE IF IS
         BZ    PTNOIS2         IF NOT, THEN FORGET IT
         WRTVTOC FMT2,FMT1+135 MOVE AND WRITE FORMAT 2
PTNOIS2  DS    0H
         LA    6,OUTEXT        POINT TO OUT EXTENT
         LA    5,FMT1+105      IN DSCB TOO
         LA    7,3             ONLY THREE EXTENTS IN FMT1
PT3MV3   MVC   2(8,5),0(6)     MOVE THE EXTENT
         CLC   0(8,6),ZEROES   SEE IF EXTENT IS ZERO
         BNE   GOON3           IF NOT, THEN GOOD
         XC    0(2,5),0(5)     WIPE OUT FIRST TWO BYTES
GOON3    DS    0H
         BAL   14,TRKCYLB     **LUCAS CHECK**
         LA    6,8(6)          INCR 6
         LA    5,10(5)         INCR 5
         BCT   7,PT3MV3        KEEP MOVEIN G
         WRTVTOC FMT1          WRITE OUT THE FORMAT 1
         CLI   FMT1+59,0       ARE THERE NO EXTENTS
         BE    TELLDS          IF SO, JUST SAY WE COPIED IT
         EJECT
*        THIS CODE WILL COPY THE DATASET TRACK BY TRACK
         ST    11,SVR11        SAVE REG 11
         MVI   FKEOF,0        CLEAR FAKE END OF FILE SWITCH
         LA    5,INEXT         GET INPUT EXTENT ADDRESSS IN 5
         LA    6,OUTEXT        GET OUT EXTENT ADDRESS IN 6
         MVC   INDKAD,INEXT    MOVE FIRST EXTENT
         MVC   OTDKAD,OUTEXT   MOVE OUTPUT EXTENT
         MVC   FRSTSW,ZEROES   CLEAR SWITCHES
MVTRK    DS    0H
         STM   5,6,SVR5R6      SAVE REGS 5 & 6
         LA    7,RDCNTCCW      GET ADDRESS OF READ COUNT CCWS
         ST    7,INCCWAD       STORE IN IOB
         MVC   INCCHH,INDKAD   MOVE FIRST TRACK ADDRESS TO IOB
         CLC   INCCHH,ZEROES  SEE IF TRACK ZERO
         BNE   FRSTREAD       IF NOT, LET THE READ GO
         CLI   FKEOF,255      ONE FAKE EOF ALREADY?
         BE    IOABEND        IF SO, KILL US
         MVI   FKEOF,255      TURN ON FAKE EOF
FAKEEOF  DS    0H             FAKE READING AN EOF RECORD
         L     2,DACCWADI     GET ADDRESS OF READ R0
         MVI   16(2),3        PUT IN NO-OP AT 3RD CCW
         MVI   20(2),X'20'    TURN ON SLI BIT IN NO-OP CCW
         MVC   14(2,2),=H'8'  MOVE IN LENGTH FOR EOF RECORD
         MVI   23(2),1        MAKE LENGTH AT LEAST 1 IN NO-OP CCW
         L     3,DATADI       ADDRESS OF DATA
         XC    0(24,3),0(3)   WIPE OUT DATA AREA
         MVI   12(3),1         PUT IN RECORD 1
         B     NOALT          GO LOOK AT LAST WRITE
FRSTREAD DS    0H
         MVI   INECB,0         CLEAR ECB
         MVI   INIOB,X'42'     SET CC & UNREL BITS
         EXCP  INIOB           READ COUNTS ON THIS TRACK
         WAIT  ECB=INECB       WAIT FOR I/O TO COMPLETE
         CLI   INECB,X'41'     SEE IF ERROR DETECTED
         BNE   IOABEND         IF NOT, THEN SOMETHING WRONG
         CLI   INIOB+3,X'08'   SEE IF NO RECORD FOUND
         BNE   IOABEND         IF NOT, THEN KILL
         L     7,INCSW         GET LAST CCWADDRESS+8
         LA    7,0(7)          CLEAR HIGH BYTE
         L     8,RDCNTAD       GET COUNT AREA ADDRESS
         LA    8,0(8)          CLEAR I/O OP CODE
         SR    7,8             SUBTRACT STARTING ADDRESS
         BNP   IOABEND         IF NOT POSITIVE KILL
         SRL   7,3             DIVIDE BY 8
         C     7,=F'1'         EMPTY TRACK READ ?
         BE    FAKEEOF         YES; FAKE READING AN EOF RECORD
         LR    11,7            SAVE REG 7
         L     3,DATADI        GET INPUT DATA ADDRESS IN O
         L     2,DACCWADI      GET ADDRESS OF INPUT CCWS
         L     8,RDCNTAD       GET ADDRESS OF FIRST CCWS
         LA    8,1600(8)       POINT TO COUNT AREAS
         LA    9,8             DATA LENGTH OF RECORD 0
         ST    3,0(2)          STORE ADDRESS
         MVI   0(2),X'06'      PUT IN READ DATA
         B     ADDLNGTH        GO TO MAIN ROUTINE
INSETUP  DS    0H
         ST    3,0(2)          STORE DATA ADDRESS INTO CCW
         MVI   0(2),X'1E'      PUT IN READ CKD
         LA    9,8             START COUNT WITH 8 BYTES CCHHRKDD
         SR    1,1             CLEAR 1 FOR IC
         IC    1,5(8)          GET KEYLENGTH IN 1
         LH    10,6(8)         GET DATA LENGTH
         LA    8,8(8)          POINT 8 AT NEXT COUNT AREA
         AR    1,10            GET KEY+DATA IN
         LTR   10,10           SEE IF DATA LENGTH NON-ZERO
         BNZ   LNGTHOK         IF NOT EOF GOODIE
         SR    1,1             CLEAR 1
         MVI   0(2),X'12'      CHANGE TO READ COUNT
LNGTHOK  AR    9,1             GET TOTAL LENGTH IN 9
ADDLNGTH DS    0H
         ST    9,4(2)          STORE LENGTH IN CCW
         MVI   4(2),X'40'      TURN ON CC BIT
         AR    3,9             GET 3 UP TO NEXT DATA AREA
         LA    2,8(2)          POINT 2 AT NEXT CCW
         BCT   7,INSETUP       KEEP GENERATING
         XC    0(8,2),0(2)     CLEAR NEXT CCW
         MVI   0(2),X'03'      SET UP NO-OP
         ST    9,4(2)          MAKE LENGTH NON-ZERO
         MVI   4(2),X'20'      TURN ON SLI BIT
TRYRAGN  DS    0H
         L     2,DATADI        GET ADDRESS OF INPUT
         MVI   INECB,0         CLEAR ECB
         MVI   INIOB,X'42'     TURN ON CC&UNRELATED BIT
         LA    15,RDDACCW      GET DATA READ CCW ADDRESS
         ST    15,INCCWAD      STORE INTO INPUT IOB
         EXCP  INIOB           READ THE WHOLE TRACK
         WAIT  ECB=INECB       WAIT FOR IT
         CLI   INECB,X'7F'     LOOK GOOD?
         BE    NOALT           IF GOOD, THEN ALL IS WELL
         CLI   INECB,X'41'     COMPLETE WITH ERRORS
         BNE   IOABEND         IF NOT, THEN KILL
         CLC   INCSW+4(2),=X'0C40'     SEE IF INCOR. LNGTH WITHOUT UC
         BNE   IOABEND         IF NOT, THEN BLOW OFF
         MVI   OVSW,255        TURN ON OVERFLOW SWITCH
NOALT    DS    0H
         CLI   FRSTSW,0        SEE IF WE'VE WRITTEN YET
         BE    ARND1           IF NOT, THEN DON'T WAIT ON LAST
OWAIT    DS    0H
         TM    OUTECB,X'40'    HAS LAST WRITE FINISHED
         BO    NOWAIT          IF SO, THEN GO AROUND WAIT
         WAIT  ECB=OUTECB      WAIT FOR WRITE TO FINISH
NOWAIT   DS    0H
         CLI   OUTECB,X'7F'    WAS LAST WRITE GOOD
         BNE   IOABEND         IF NOT, THEN KILL THYSELF
         L     7,DATADO        GET STARTING ADDRESS OF OUTPUT R0 DATA
         L     6,DACCWADO      GET ADDRESS OF WRITE CCWS
         CLC   INR0DATA,0(7)   SEE IF EQUAL TO INPUT
         BE    OTR0GOOD        IF SO, WE'RE HAPPY
         MVC   4(4,7),INR0DATA+4       MOVE TRACK BALANCE PART
         CLC   INR0DATA(4),ZEROES      DISK ADDRESS IN INPUT?
         BE    ZR0             IF NOT, THEN MAKE IT ZERO
         MVC   0(4,7),OUTCCHH  MOVE IN OUTPUT TRACK ADDRESS
         B     STWRTR0         GO WRITE R0 DATA
ZR0      DS    0H
         MVC   0(4,7),ZEROES ZERO IT
STWRTR0  DS    0H
         MVI   0(6),X'05'      CHANGE TO WRITE DATA
         MVI   4(6),X'00'      TURN OFF COMMAND CHAIN
         MVI   OUTIOB,X'42'    SET CC & UNRELATED
         MVI   OUTECB,0        CLEAR ECB
         EXCP  OUTIOB          WRITE R0 DATA
         WAIT  ECB=OUTECB      WAIT FOR IT TO STOP
         CLI   OUTECB,X'7F'    SEE IF GOOD
         BNE   IOABEND         IF NOT, WIPE OUT
OTR0GOOD DS    0H
         CLI   LSTSW,0         SEE IF THAY WAS
         BNE   DSCOMPLT        IF SO, WE'RE FINISHED
         CLC   OTDKAD,ZEROES   IS OUTPUT ADDRESS ZERO
         BE    DSCOMPLT        IF SO, NO MORE OF THIS DATA SET
ARND1    DS    0H
         L     7,DATADO        GET ADDRESS OF TRACK OUTPUT DATA
         L     6,DACCWADO      GET ADDRESS OF WRITE CCWS
         L     2,DACCWADI      GET ADDRESS OF READ CCWS
         B     GSOCCW          GO PAST SOME CODE THE FIRST TIME
GENOCCW  DS    0H
         L     3,0(2)          GET CCHH AREA OF COUNT IN INPUT DATA
         MVC   0(4,3),OTDKAD   PUT IN NEW DASD ADDRESS
GSOCCW   DS    0H
         ST    7,0(6)          SAVE DATA ADDRESS IN OUPUT CCW
         MVI   0(6),X'1D'      PUT IN WRTIE CKD CCW
         LH    9,6(2)          GET LENGTH FROM READ CCW
         ST    9,4(6)          STORE IN WRTIE CCW
         MVI   4(6),X'40'      TURN ON CC BIT
         AR    7,9             7 NOW POINTS AT NEXT DATA AREA
         LA    6,8(6)          POINT 6 AT NEXT OUTPUT CCW
         LA    2,8(2)          POINT 2 AT NEXT INPUT CCW
         CLI   0(2),X'03'      IS THIS A NO-OP CCW
         BNE   GENOCCW         IF NOT, KEEP GENERATING
         CLI   OVSW,255        SEE IF WE HAVE AN OVERFLOW SEGMENT
         BNE   NOOV            IF NOT, THEN FORGET IT
         L     1,=F'-8'        SET UP 1
         AR    1,6             POINT 1 TO LAST WRITE CCW
         MVI   0(1),X'01'      CHANGE TO SPECIAL WRITE CKD
         MVI   OVSW,0          CLEAR THE SWITCH
NOOV     DS    0H
         MVC   0(8,6),0(2)     MOVE THE NO-OP CCW
         L     3,DACCWADO      GET ADDRESS OF FIRST OUTPUT CCW
         MVI   0(3),X'06'      CHANGE TO READ OUTPUT TRACK R0
         L     6,DATADO        GET START OF OUTPUT DATA
         L     2,DATADI        GET START OF INPUT ADDRESS IN 2
         SR    7,6             GET LENGTH OF TRACK DATA IN R7
         LR    3,7             GET LENGTH IN 3 ALSO
         MVCL  6,2             MOVE A TRACKS WORTH OF DATA
         MVC   OUTCCHH,OTDKAD  MOVE NEXT TRACK ADDRESS TO IOB
         MVI   OUTECB,0        CLEAR ECB
         MVI   OUTIOB,X'42'    SET CC & UNRELATED
         EXCP  OUTIOB          WRITE THE WHOLE TRACK
         L     15,DATADI       GET ADDRESS OF INPUT DATA
         MVC   INR0DATA,0(15)  MOVE INPUT R0 DATA
         MVI   FRSTSW,X'FF'    RESET FIRST WRITE SWITCH
         LH    9,TRKUSD        GET TRACKS USED
         BCT   9,NXTRK         REDUCE BY 1
         MVI   LSTSW,X'FF'     SET LAST WRITE SWITCH
         B     OWAIT           GO WAIT FOR LAST WRITE TO STOP
NXTRK    DS    0H
         STH   9,TRKUSD        SAVE REMAINING TRACKS
         LM    5,6,SVR5R6      RESTORE REGS 5 & 6
         LH    9,INDKAD+2      GET INPUT TRACK ADDR
         LA    9,1(9)          INCR BY 1
         CH    9,TRKPCYL       CHECK WITH HIGHEST TRACK
         BL    INTRKGD         IF LOW, GOOS
         LH    9,INDKAD        GET CYL #
         LA    9,1(9)          INCR
         STH   9,INDKAD        STORE BACK
         SR    9,9             CLEAR TRK #
INTRKGD  STH   9,INDKAD+2      SAVE TRACK #
         CLC   INDKAD,4(5)     CHECK EXTENT
         BNH   INEXTOK         IF NOT HIGH THIS EXTENT STILL GOOD
         LA    5,8(5)          POINT AT NEXT EXTENT
         MVC   INDKAD,0(5)     MOVE FIRST TRACK ADDR OF THIS EXTENT
INEXTOK  DS    0H
         LH    9,OTDKAD+2      GET OUTPUT TRACK #
         LA    9,1(9)          INCR
         CH    9,TRKPCYL       CHECK WITH HIGHEST TRACK
         BL    OTTRKGD         IF LOW, GOOD
         LH    9,OTDKAD        GET CYLINDER #
         LA    9,1(9)          INCR
         STH   9,OTDKAD        STORE CYL# BACK
         SR    9,9             CLEAR 9
OTTRKGD  DS    0H
         STH   9,OTDKAD+2      SAVE TRK
         CLC   OTDKAD,4(6)     CHECK WITH EXTENT END
         BNH   OTEXTOK         IF NOT HIGH, ALL IS WELL
         LA    6,8(6)          POINT TO NEXT EXTENT
         MVC   OTDKAD,0(6)     MOVE NEW EXTENT START
OTEXTOK  DS    0H
         B     MVTRK           GO MOVE NEXT TRK
DSCOMPLT DS    0H              FINISHED COPYING DATA SET
         L     11,SVR11        RESTORE R11
TELLDS   DS    0H
         MVC   DSNAME,FMT1     MOVE DATA SET NAME
         LA    1,DSNAME-1      GET ADDRESS
         EJECT
WRTLINE  DS    0H
         LR    6,1             SAVE PARM REG
         IC    7,0(6)          GET ORIG CC
         CP    LINE#,=P'55'    SEE IF PAST END OF PAGE
         BNH   LINEOK
         AP    PAGE#,=P'1'     ADD 1 TO PAGE NUMBER
         OI    PAGE#+L'PAGE#-1,X'0F'   MAKE LAST DIGIT READABLE
         UNPK  PAGE#UP,PAGE#
         PUT   SYSPRINT,HEADER WRITE HEADER PAGE
         MVI   0(6),C'-'       MOVE IN PROPER CC
         ZAP   LINE#,=P'1'     START LINE # AT 1
         B     PUTIT           GO WRITE IT
LINEOK   DS    0H
         AP    LINE#,=P'1'
         CLI   0(6),C' '       SEE IF ONE LINE
         BE    PUTIT           IF  SO, THEN GO DO IT
         AP    LINE#,=P'1'     ADD ANOTHER
PUTIT    PUT   SYSPRINT,(6)    WRITE THE LINE
         STC   7,0(6)          RESTORE ORIGINAL CC
         BR    11              AND RETURN
 SPACE 2
ABEND2   DS    0H
IOABEND  ABEND 2,DUMP          I/O ERROR - BLOW
         SPACE 2
SAVE     DS    18F            MY SAVE AREA
         EJECT
ALCDS    DS    0H              THIS ROUTINE ALLOCATES EXTENTS
         STM   15,2,RGSAV      SAVE 15-2
         LH    10,TRKPCYL      GET TRACKS PER CYLINDER IN 10
         L     11,=F'-1'
         AR    11,10           11 HAS LAST TRACK ADDR. ON CYL
         LH    3,INEXT+4(1)    GET ENDING CYL
         MR    2,10            GET REL CYL START
         TM    3(4),X'28'      NOT CYLINDER?
         BNZ   JUSTAD          IF NOT, ADD IN TRACKS
         AR    3,11            GET UP TO LAST TRK
         B     ALCOMM
JUSTAD   AH    3,INEXT+6(1)    ADD IN LAST TRACK
ALCOMM   LA    3,1(3)          NOW HAVE # OF LAST TRACK
         LH    7,INEXT(1)      GET STARTING CYL
         MR    6,10            GET REL CYL START
         TM    3(4),X'28'      CYLINDER?
         BZ    ALNOAD1         IF SO, BRANCH
         AH    7,INEXT+2(1)    ADD IN FIRST TRK
ALNOAD1  SR    3,7             3 HAS # OF TRKS TO ALLOCATE
         STH   3,TRKALC        SAVE TRACKS ALLOCATED
         L     6,PFMT5AD       GET START OF FREE EXTENT LIST
         LA    15,PFMT5AD      GET ADDRESS OF FORMAT 5 ADDRESS
SPCLOK1  DS    0H
         TM    3(4),X'20'      SYSCTLG DATA SET?
         BZ    NTCTLG02        IF NOT, NORMAL ALLOC
         CLC   OTVTCEND,4(6)   SEE IF EXTENT PAST VTOC
         BNL   LKNXTFRE        IF NOT, LOOK AT NEXT FREE EXTENT
NTCTLG02 DS    0H
         LH    5,8(6)          GET TRKS ON CYL
         AH    5,10(6)         ADD LEFT OVER TRKS O END
         TM    3(4),X'10'      IS THIS FOR CYLINDER
         BO    ALNOAD2
         AH    5,6(6)          ADD IN TRKS BEFORE CYL
ALNOAD2  CR    3,5             SEE IF ENOUGH SPACE
         BNH   SPCFND1         IF SO, WE'RE IN
LKNXTFRE DS    0H
         LR    15,6           SAVE REG. 6
         L     6,0(15)         POINT TO NEXT  FREE EXTENT
         LTR   6,6             MAKE SURE SOME LEFT
         BNZ   SPCLOK1         OH GOODIE
         CRASH , IF NOT, THEN KILL THYSELF
SPCFND1  LH    9,4(6)          GET EXTENT START
         TM    3(4),X'10'      IS IT CYLINDER
         BNO   ALNOAD3
         AH    9,6(6)          ADD TRKS BEFORE CYL
ALNOAD3  LR    0,9             SAVE #
         SR    8,8             CLEAR 8 FOR DIVIDE
         DR    8,10            GET STARTING EXTENT ADDRESS
         STH   9,OUTEXT(1)     SAVE CYL START
         STH   8,OUTEXT+2(1)   & TRK START
         LR    9,0             GET START BACK
         AR    9,3             ADD IN # OF TRKS
         BCTR  9,0             REDUCE TO LAST TRACK ADDRESS
         SR    8,8             CLEAR 8 AGAIN
         DR    8,10            GET ENDING TRACK ADDRESS
         STH   9,OUTEXT+4(1)   SAVE ENDING CYL
         STH   8,OUTEXT+6(1)   SAVE    ENDING TRACK
         L     7,FPFMT5AD      GET START OF FERE AREA
         TM    3(4),X'10'      SEE IF CYLINDER ALLOCATION
         BNO   NOHDTRKS        IF NOT,AT BEGINNING
         SR    8,8             CLEAR 8 FOR COMPARE
         CH    8,6(6)          SEE IF TRKS BEFORE CYL IS ZERO
         BE    NOHDTRKS        IF NOT, THEN GET OUT
         LH    2,4(6)          GET EXTENT START
         AH    2,6(6)          ADD TRKS BEFORE CYL
         AR    2,3             ADD TRACKS ALLOCATED
         STH   2,4(7)          SAVE START OF NEW EXTENT
         LH    2,8(6)          GET # OF CYLS BEFORE ALLOC
         SR    2,3             SUBTRACT THOSE ALLOC
         STH   2,8(7)          SAVE THEM IN NEW EXTENT
         AH    2,10(6)         ADD IN EXTRA TRACKS
         BZ    FXTHSEXT        IF ZERO, NO NEW EXTENT
         MVC   10(2,7),10(6)   MOVE EXTRA TRACKS OVER
         MVC   FPFMT5AD,0(7)   MOVE FREE POINTER
         MVC   0(4,7),0(6)     MOVE EXT POINTER
         ST    7,0(6)          KEEP LINKING
         XC    6(2,7),6(7)     WIPE OUT TRKS BEFORE CYL
FXTHSEXT XC    8(4,6),8(6)     WIPE OUT CYLS & EXT TRKS
         B     BLASTOUT        GO BACK
NOHDTRKS DS    0H
         LH    2,4(6)          GE T EXTENT START
         AR    2,3             UP TO WHERE EXTENT WOULD END
         STH   2,4(6)          SAVE NEW EXTENT START
         LH    2,8(6)          GET # OF ORIG TRKS
         AH    2,6(6)          ADD IN TRKS BEFORE CYL
         SR    2,3             SUBTRACT THOSE ALLOCATEDC
         BP    HITIT1          IF A GOOD NUMBER, USE IT
         AH    2,10(6)         ADD IN TRKS AFTER CYL
         MVC   8(4,6),ZEROES   CLEAR IT AND ONE BEFORE
         BP    HITIT2          GO STORE TRLS
         BZ    GIVEBACK        GIVE BACK EXTENT IF ZERO
         CRASH ,               IF HERE - A REAL GOOF
HITIT1   DS    0H
         LR    3,2             LOAD 3 WITH LEFT OVER TRACKS
         SR    2,2             CLEAR 2 FOR DIVIDE
         DR    2,10            GET CYLS AND LEFT OVER TRACKS
         MH    3,TRKPCYL       GET BACK TRACKS ON CYL BOUNDARY
         STH   3,8(6)          STORE TRACKS ON CYL BOUNDARY
HITIT2   DS    0H
         STH   2,6(6)          STORE TRACKS BEFORE CYL
         B     BLASTOUT        GET OUT
GIVEBACK DS    0H
*        IF ZERO WE JUST USED UP AN EXTENT & HAVE TO GIVE IT BACK
         XC    4(8,6),4(6)     WIPE OUT EXTENT INFO
         L     2,0(6)          GET NEXT ENTRY POINTER
         ST    2,0(15)         STORE IT IN LAST ENTRY
         ST    7,0(6)          SAVE IN MINE
         ST    6,FPFMT5AD      MAKE NEW START
BLASTOUT DS    0H
         LM    15,2,RGSAV      RESTORE 15-2
         BR    14              &RETURN
         SPACE
IOER     DS    0H             I/O ERROR ROUTINE
         USING *,15           15 IS BASE FOR A WHILE
         MVI   OUTER,255      INDICATE ERROR
         BR    14             AND RETURN
         DROP  R15
         EJECT
VTOC     DC    CL8'SYSVTOC'    MAJOR QUEUE NAME
HEADER   DC    CL121'1DISK SQUISHER'
         ORG   *-8
         DC    C'PAGE '
PAGE#UP  DS    CL3
         ORG
         DC    CL121' '
         ORG   *-120
DSNAME   DS    CL44
         DC    C'  COPIED SUCCESSFULLY'
         ORG
PAGE#    DC    PL3'0'
LINE#    DC    P'60'
ENDMES   DC    CL121'0DISK SQUISHER COMPLETE'
         ORG   ENDMES+30
LTRKCOPY DC    X'402020202120'    EDIT PATTERN FOR TRACKS COPIED
         DC    C' TRACKS COPIED       '
LTRKALL  DC    X'402020202120'    EDIT PATTERN FOR TRACKS ALLOCATED
         DC    C' TRACKS ALLOCATED'
         ORG   ENDMES+121
WKDW     DS    D
TRKCOPY  DC    H'0'
TRKALL   DC    H'0'
         SPACE 1
PREALFLG DS    X
PREBASE  DC    A(PREBASEM)
ENQL     ENQ   (VTOC,WTOR+X'20',E,6,SYSTEM,VTOC,WTOR+X'2C',E,6,        +
               SYSTEM),MF=L
WTOR     WTOR  'OK TO SQUISH VOLUME XXXXXX ONTO YYYYYY ?',FULL,3,      +
               INECB,MF=L
BDOPMES  DC    CL121' OPERATOR DENIED YOUR REQUEST TO SQUISH VOLUME.'
R5R6     DS    2F
CTLG     DC    CL44'SYSCTLG'   NAME OF CATALOG DATA SET
BIGGIE   DC    H'10000'
OTVTCEND DS    H               LAST TRACK NUMBER IN OUTPUT VTOC
OUTER    DS    X              IOERROR BYTE
         DS    0D
ABSHD    DC    AL3(0)
ABSAD    DS    XL5
LSTFM1   DS    F
THIRD    DC    AL3(3),AL1(0)
ZEROES   DC    XL8'0'
OVSW     DC    X'0'            OVERFLOW SWITCH
FKEOF    DS    X
#TRKS    DS    H
FULL     DS    F
STAD     DS    F
ENDAD    DS    F
SVR11    DS    F
INDKAD   DS    F
OTDKAD   DS    F
DSLSTAD  DS    A
RGSAVE   DS    18F
PFMT5AD  DC    A(PFMT5)
FPFMT5AD DS    A
PFMT5    DC    (26*3)F'0'
INDISK   DCB   MACRF=E,DDNAME=SYSUT1,EXLST=INJFCBAD,EOEA=WA,           +
               IOBAD=INIOB
OUTDISK  DCB   MACRF=E,DDNAME=SYSUT2,EXLST=OTJFCBAD,EOEA=WA,           +
               IOBAD=OUTIOB
BLOCKAD  DC    F'0'
REC#     EQU   BLOCKAD+2
CCHHR    EQU   X'23'           OFFSET OF CCHHR IN IOB
FMT1     DS    140C
FMT2     DS    140C
FMT3     DS    140C
FMT5     DS    140C
VTOCOUT  DS    140C
FMT4     EQU   VTOCOUT
VTOCIN   DS    140C
DACYLS   DC    H'0,200,25,80,246,980,48,96,200,404'   CYLINDR TABLE
#EXTS    DS    H
TCYL     DS    H
TRKALC   DS    H
TRKUSD   DS    H
INEXTS   DC    16D'0'
OUTEXTS  DC    16D'0'
OUTEXT   EQU   OUTEXTS
INEXT    EQU   INEXTS
DISKIN   DCB   DSORG=PS,MACRF=RP,DDNAME=SYSUT1,RECFM=F,KEYLEN=44,      +
               LRECL=96,BLKSIZE=96,EXLST=INJFCBAD
INJFCBAD DS    0F
         DC    X'87'
         DC    AL3(INJFCB)
INJFCB   DS    44F
         READ  VTOCINCB,SF,DISKIN,MF=L
DISKOUT  DCB   DSORG=DA,MACRF=(RIC,WIC),DDNAME=SYSUT2,OPTCD=R,         +
               RECFM=F,KEYLEN=44,BLKSIZE=96,EXLST=OTJFCBAD,SYNAD=IOER
OTJFCBAD DS    0F
         DC    X'87'
         DC    AL3(OUTJFCB)
OUTJFCB  DS    44F
         READ  VTCOUTDB,DI,DISKOUT,,'S',,BLOCKAD+1,MF=L
         EJECT
INIOB    DS    0D
         DC    X'42'           CC AND UNRELATED
         DS    XL3
         DC    A(INECB)
INCSW    DC    2A(0)
INCCWAD  DS    A
         DC    A(INDISK)
         DC    2A(0)
         DC    XL3'0'
INCCHH   DC    XL4'0'
         DC    X'0'
         DC    C'SQUV'
         DC    A(VTOCIN)
INCYLS   DS    H
INECB    DC    F'0'
OUTIOB   DS    0D
         DC    X'42'
         DS    XL3
         DC    A(OUTECB)
OUTCSW   DC    2A(0)
         DC    A(OUTCCW)       ADDRESS OF OUTPUT CCW
         DC    A(OUTDISK)
         DC    2A(0)
         DC    XL3'0'
OUTCCHH  DC    XL4'0'
         DC    X'0'
         DC    C'SQUV'
         DC    A(FMT4)
OUTCYLS  DS    H
OUTECB   DC    F'0'
NOREC    EQU   X'20'
OUTCCW   CCW   X'31',OUTCCHH,X'40',5   SEARCH FOR RECORD 0
         CCW   X'08',OUTCCW,0,0        KEEP LOOKING
DACCWADO CCW   X'08',0,0,0     THIS TIC WILL BE MODIFIED BY PROG
RDDACCW  CCW   X'31',INCCHH,X'40',5    LOOK FOR RECORD 0
         CCW   X'08',RDDACCW,0,0       TIC *-8
DACCWADI CCW   X'08',0,0,0     TIC TO GOTMAIN CCW
RDCNTCCW CCW   X'31',INCCHH,X'40',5    SEARCH FOR RECORD 0
         CCW   X'08',RDCNTCCW,0,0
RDCNTAD  CCW   X'80',0,0,0     WILL BE FILLED IN BY INIT ROUTINE
DATADI   DS    F               ADDRESS OF INPUT DATA
DATADO   DS    F               ADDRESS OF OUTPUT DATA
FRSTSW   DS    CL2
LSTSW    EQU   FRSTSW+1
SVR5R6   DS    2F              OTHER SAVE AREA FOR REGS 5 & 6
INR0DATA DS    CL8
         EJECT
SYSPRINT DCB   DSORG=PS,MACRF=PM,DDNAME=SYSPRINT,RECFM=FBA,LRECL=121,  +
               BLKSIZE=968
          EJECT
* CHECK IF PREVIOUSLY TRK ALLOC DATASET IS NOW NOT ON
* CYL BOUNDS - REMOVE 'ROUND CYLS' BIT IF SO   **LUCAS**
TRKCYLB  DS    0H
         TM    3(4),8
         BCR   8,14          NO,IGNORE
         CLI   0(5),X'81'    WAS IT ON CYL BOUNDS?
         BNE   SPLITCYL      NO; CHECK IF SPLIT CYLINDER
         XR    15,15
         AH    15,4(5)       ARE THERE ANY ODD TRKS ON START ADDR
         BNZ   ADJUST         YES - CORRECT ROUND CYL FLAG
         AH    15,8(5)        ADD TRKS ON END OF EXTENT
         LA    15,1(5)        ADD 1
         CH    15,TRKPCYL     IF = TRK PER CYL MUST STILL BE ROUND CYLS
         BCR   8,14           YES,RETURN
ADJUST   MVI   0(5),1         CHANGE '81' TO '01'
         BR    14
         SPACE 1
SPLITCYL DS    0H
         CLI   0(5),X'80'    DID THIS DS SHARE A CYLINDER ?
         BE    ADJUST         YES; GO CHANGE SPLIT CYL TO TRK ALLOC
         BR    14             NO; RETURN
         SPACE 5
         LTORG
FREESPAC DC    7676X'0'        EVERYTHING UNALLOCATED AT FIRST
         DC    X'FF'           TO INSURE THE END
VTOCINDB EQU   VTOCINCB
RGSAV    EQU   RGSAVE
#FREXTS  EQU   #EXTS
TRKPCYL  EQU   VTOCIN+64
#CYL     EQU   VTOCIN+62
         EJECT
* PATCH TO ALLOW PRE-ALLOCATED DATASETS TO BE USED
         SPACE 3
PREALPTC DS    0H
         USING *,R15
         STM   R0,R15,PRESAV
         BALR  R11,0
         USING *,R11
PREBASEM DS    0H
         DROP  R15
         ST    R11,PREBASE
         CLOSE (DISKIN,,DISKOUT)
         OPEN  (PRECOPYV,OUTPUT)
         OPEN  (PREDSKI,INPUT,PREDSKO,INPUT),TYPE=J
         SPACE 1
* GET CORE FOR LIST OF TTR ADDRESSES.
* THIS IS TO ALLOW DATASETS TO BE COPIED IN THE ORDER OF THEIR
* DSCBS IN THE OUTPUT VTOC; IT IS IMPORTANT FOR EXAMPLE THAT THE
* DSCB FOR A SYSCTLG DATASET BE THE FIRST IN THE VTOC.
         LA    R0,400              UP TO 100 PRE-ALLOCATED DATASETS
         GETMAIN R,LV=(0)
         LA    R1,0(R1)            CLEAR HIGH BYTE
         ST    R1,PRETTRL@         SAVE @ OF LIST
         ST    R1,PRETTRLN         SAVE @ OF NEXT ENTRY
         LA    R1,400(R1)          UPPER BOUND
         ST    R1,PRETTRND         SAVE IT.
         SPACE 3
         XC    PREABSAD,PREABSAD
         MVC   PREABSAD+3(5),FMT4+45 ABSOLUTE DISK @ OF LAST FMT1
         SR    R0,R0
         ABSTTR PREDSKO,PREABSAD     CONVERT TO TTR
         ST    R0,PRELSTF1           SAVE TTR OF LAST FMT1 DSCB
         SPACE 1
         SR    R0,R0
         IC    R0,FMT4+74            # DSCBS PER TRACK
         ST    R0,PREDSPTR
         SPACE 1
         MVC   PRETTRO,=X'00000200'  START READING WITH 3RD DSCB
         MVC   PREBLKO,PRETTRO         "     "       "   "   "
         SPACE 3
PRERDSCB DS    0H                  TOP OF DSCB-READ LOOP
         SPACE 1
         CLC   PRELSTF1,PREBLKO    HAVE WE READ THE LAST FMT1 ?
         BNH   PREOUTL             YES; GET OUT OF LOOP
         BAL   R14,PRERDVTO        READ NEXT OUTPUT DSCB
         CLI   PREDSCBO+44,C'1'    FMT1 DSCB ?
         BNE   PRERDSCB            NO; READ NEXT DSCB
PRECOPY  DS    0H                  COPY DSCB
         WRITE PREDECBV,SF,MF=E
         CHECK PREDECBV
         SPACE 1
* FIND DSCB IN VTOC OF INPUT DISK
         MVC   PREDSCBI(44),PREDSCBO COPY DSNAME
         MVC   PREBLKI,=X'00000200' START LOOKING FROM 2ND DSCB
         MVI   OUTER,0              CLEAR BAD IO FLAG
         READ  PREDECBI,DKF,MF=E
         CHECK PREDECBI
         CLI   OUTER,0
         BNE   PREBADIO
* NOW LOOK FOR ITS ENTRY ON DSLIST SO WE CAN MARK IT
         L     R2,DSLSTAD          R2 -> BEHIND 1ST ENTRY
         SPACE 1
PRELOOP2 DS    0H
         LA    R2,4(R2)            BUMP PTR
         CLC   0(3,R2),ZEROES      ARE WE THROUGH ?
         BE    PREBOOB             SHOULDN'T BE.
         CLC   0(3,R2),PREBLKI     IS THIS THE ENTRY ?????
         BNE   PRELOOP2            NO; TRY AGAIN
         OI    3(R2),X'01'         FLAG AS PRE-ALLOCATED
         SPACE 1
* SAVE ADDRESS OF TTR ENTRY
         L     R1,PRETTRLN         @ OF NEXT ENTRY
         C     R1,PRETTRND         LIST ALREADY FULL ?
         BNL   PREVMANY            YES; BLOW
         ST    R2,0(R1)            SAVE @ OF TTR
         LA    R1,4(R1)            BUMP NEXT ENTRY PTR
         ST    R1,PRETTRLN         AND SAVE IT
         SPACE 1
         CLI   PREDSCBO+59,3       MORE THAN 3 EXTENTS ?
         BNH   PRERDSCB            NO; READ NEXT DSCB
         SPACE 1
PRENEXTD DS    0H
         CLC   PREDSCBO+135(5),ZEROES -> ANOTHER DSCB ?
         BE    PRERDSCB            NO; READ NEXT FMT1
         MVC   PREABSAD+3(5),PREDSCBO+135 COPY @ OF NEXT DSCB
         SR    R0,R0               CONVERT TO TTR
         ABSTTR PREDSKO,PREABSAD
         ST    R0,PREBLKO
         BAL   R14,PRERVTOC        READ DSCB
         CLI   PREDSCBO+44,C'3'    FMT 3 DSCB ?
         BNE   PRENEXTD            NO; THIS MUST BE FMT 2
         SPACE 1
         WRITE PREDECBV,SF,MF=E
         CHECK PREDECBV
         B     PRERDSCB            GO READ NEXT DSCB
         SPACE 3
         SPACE 3
PREOUTL  DS    0H
         CLOSE (PREDSKI,,PREDSKO,,PRECOPYV)
         OPEN  (DISKIN,,DISKOUT,UPDAT),TYPE=J
         LM    R0,R15,PRESAV
         BR    R14                 RETURN
         EJECT
* MOVE PRE-ALLOCATED DATSETS
         SPACE 1
PREMOVE  DS    0H
         USING *,R15
         STM   R0,R15,PRESAV
         L     R11,PREBASE
         DROP  R15
         SPACE 1
         OPEN  PRECOPYV
         MVC   HEADER+15(24),=CL24': PRE-ALLOCATED DATASETS'
         MVC   PRETTRND,PRETTRL@   INITIALISE TTR @ PTR
         SPACE 1
PREMVLP  DS    0H
         L     R1,PRETTRND         R1 -> TTR @
         C     R1,PRETTRLN         HAVE WE FINISHED ?
         BNL   PREMEND             YES; GET OUT.
         L     R4,0(R1)            R4 -> TTR
         LA    R1,4(R1)            BUMP TTR @ PTR
         ST    R1,PRETTRND         AND SAVE IT
         SPACE 1
         BAL   R11,GETVTOCS        GO READ DSCBS OF INPUT DS
         L     R11,PREBASE         RESTORE BASE REG
* GET DSCBS OF OUTPUT DS
         MVC   PREBLKV,=X'00000100' START AT THE BEGINING
         POINT PRECOPYV,PREBLKV    POINT TO 1ST RECORD
PREMLOOK DS    0H
         READ  PREDECBV,SF,MF=E    READ A RECORD
         CHECK PREDECBV
         CLI   PREDSCBO+44,C'1'    FMT 1 DSCB ?
         BNE   PREMLOOK            NO; LOOK AGAIN
         CLC   PREDSCBO(44),FMT1   THIS THE 1 WE WANT ?
         BNE   PREMLOOK            NO; TRY NEXT
         SPACE 1
         MVC   FMT1+59(1),PREDSCBO+59   COPY # OF EXTENTS
         MVC   FMT1+94(4),PREDSCBO+94   COPY SEC ALLO INFO
         MVC   FMT1+105(30),PREDSCBO+105 COPY EXTENTS; ALL WE REALLY
*                                 NEED IS THE 1ST 2 BYTES OF EXTENTS
         XC    OUTEXTS(16*8),OUTEXTS
         LA    R9,PREDSCBO+105     R9 -> 1ST EXTENT
         LA    R8,3                3 EXTENTS ON FMT 1
         LA    R10,OUTEXTS         R10 -> OUTPUT EXTENTS
         SPACE 1
PREMVEX1 DS    0H
         MVC   0(8,R10),2(R9)      MOVE EXTENT
         LA    R10,8(R10)          BUMP R10
         LA    R9,10(R9)           BUMP R9
         BCT   R8,PREMVEX1         LOOP
         SPACE 1
         CLI   PREDSCBO+59,3       MORE THAN 3 EXTENTS ??
         BNH   PREMVF1             NO; JUMP
         READ  PREDECBV,SF,MF=E    READ FMT3 DSCB
         CHECK PREDECBV
         CLI   PREDSCBO+44,C'3'    FORMAT 3 DSCB ?
         BE    *+8                 YES; SKIP
         BAL   R14,PREBOOB         NO; FUNNY FUNNY
         MVC   FMT3(140),PREDSCBO  COPY EXTENTS; ONLY REALLY NEED THE
*                                  1ST 2 BYTES OF EACH EXT. DESCR.
* COLLECT EXTENTENTS FROM FMT3 DSCB
         LA    R8,4                4 EXTENTS IN KEY
         LA    R9,PREDSCBO+4       START OF 4TH EXTENT
PREMVEX2 DS    0H
         MVC   0(8,R10),2(R9)      MOVE EXTENT
         LA    R10,8(R10)          BUMP R10
         LA    R9,10(R9)           BUMP R9
         BCT   R8,PREMVEX2         LOOP
         SPACE 1
         LA    R8,9                9 MORE EXTENTS
         LA    R9,PREDSCBO+45      START OF 8TH EXTENT
PREMVEX3 DS    0H
         MVC   0(8,R10),2(R9)      MOVE EXTENT
         LA    R10,8(R10)          BUMP R10
         LA    R9,10(R9)           BUMP R9
         BCT   R8,PREMVEX3         LOOP
 SPACE 2
PREMVF1  DS    0H
         TM    3(R4),X'C0'         UNMOVEABLE OR IS ?
         BZ    PREMVF2             NO; SKIP
         CLC   INEXTS(16*8),OUTEXTS YES; INPUT EXTENTS=OUTPUT EXTENTS?
         BE    PREMVF2             YES; SKIP
ABEND13  ABEND 13,DUMP             NO; DUMP
         SPACE 1
PREMVF2  DS    0H
* ALLOCATE EXTENTS
         SR    R0,R0               CLEAR R0
         LA    R1,OUTEXTS          GET EXTENT @
         LA    R2,16               MAX 16 EXTENTS
PREALLP1 DS    0H
         CLC   0(8,R1),ZEROES      ARE WE FINISHED ?
         BE    PREALLOT            YES; GET OUT
         BAL   R14,ABSALC          GO ALLOC
         L     R11,PREBASE         RESTORE BASE REG
         AH    R0,TRKALC           ACCUM TRACKS ALLOCATED
         LA    R1,8(R1)            BUMP PTR
         BCT   R2,PREALLP1         LOOP
         SPACE 1
PREALLOT DS    0H
         STH   R0,TRKUSD           SAVE OUTPUT TRACKS ALLOCATED
         SPACE 1
* COUNT INPUT TRACKS
         SR    R0,R0               CLEAR ACCUMULATOR
         LA    R2,16                UP TO 16 EXTENTS
         LA    R1,INEXTS
PREMCNTL DS    0H
         CLC   0(8,R1),ZEROES      END ?
         BE    PREMCNOT            YES; GET OUT
         LH    R15,0(R1)           STARTING CYL
         MH    R15,TRKPCYL
         AH    R15,2(R1)           + STARTING TRACKS
         LH    R10,4(R1)           ENDING CYL
         MH    R10,TRKPCYL
         AH    R10,6(R1)           + ENDING TRACKS
         LA    R10,1(R10)          INCR BEFORE SUBTRACT
         SR    R10,R15             GET LENGTH
         AR    R0,R10              ADD TO PREVIOUS EXTENT
         LA    R1,8(R1)            BUMP EXTENT PTR
         BCT   R2,PREMCNTL
         SPACE 1
         SPACE 1
PREMCNOT DS    0H
         SPACE 1
         LH    R1,TRKUSD           # TRACKS IN OUTPUT DS
         STH   R0,TRKUSD           # TRACKS IN INPUT DS
         CH    R1,TRKUSD           SIZE OF OUTPUT DS ^< INPUT DS ?
         BNL   PREMVF3             YES; SKIP
ABEND14  ABEND 14,DUMP             NO; GIVE UP, ITS TOO MUCH.
         SPACE 1
PREMVF3  DS    0H
         TM    3(R4),X'20'         IS THIS A SYSCTLG DS ?
         BO    PREPUTDS            GO COPY IT ALL.
         LH    R1,FMT1+98          TTR OF LAST BLOCK WRITTEN
         LTR   R1,R1               CHECK IF NEGATIVE
         BM    PREFDSCB            YES; BLOW
         LA    R1,1(R1)            # OF TRACKS USED
         CH    R1,TRKUSD
         BH    PREFDSCB            FUNNY DSCB
         BE    *+8                 SKIP INCR IF EQUAL
         LA    R1,1(R1)            PLUS 1 FOR LUCK
         STH   R1,TRKUSD           COPY ONLY TACKS USED
PREPUTDS DS    0H                  COPY DS
         BAL   R11,PUTDS           COPY DS
         L     R11,PREBASE         RESTORE MY BASE REG
         MVI   3(R4),0             CLEAR LIST ENTRY
         B     PREMVLP             GO MOVE NEXT DS
         SPACE 3
PREMEND  DS    0H
         MVC   LINE#,=P'99'        NEW PAGE NEXT TIME
         MVC   HEADER+15(24),=CL24' '
         SPACE 1
         LA    R0,400              LENGTH OF TTR @ LIST
         L     R1,PRETTRL@         @ OF LIST
         FREEMAIN R,LV=(0),A=(1)   FREE SPACE
         SPACE 1
         LM    R0,R15,PRESAV
         BR    R14                 RETURN
         SPACE 3
         EJECT
PRERDVTO DS    0H
         SPACE 1
* READ NEXT DSCB FROM OUTPUT DISK
         SR    R1,R1               INCREASE TTR
         IC    R1,PRETTRO+2
         LA    R1,1(R1)            NEXT RECORD #
         C     R1,PREDSPTR         TOO MUCH ?
         BNH   PREROK              NO; SO SKIP
         LH    R1,PRETTRO
         LA    R1,1(R1)           BUMP TT
         STH   R1,PRETTRO         AND SAVE IT
         LA    R1,1               RECORD # IS 1
         SPACE 1
PREROK   DS    0H
         STC   R1,PRETTRO+2        SAVE NEW RECORD #
         MVC   PREBLKO,PRETTRO     SET BLOCK # FOR READ
         SPACE 1
PRERVTOC DS    0H
         ST    R14,PRESVR14        SAVE RETURN @
         MVI   OUTER,0
         READ  PREDECBO,DI,MF=E    READ DSCB
         CHECK PREDECBO
         CLI  OUTER,0              OK ?
         BNE   PREBADIO            NO; DROP OUT
         L     R14,PRESVR14
         BR    R14                 RETURN
         SPACE 3
ABEND11  DS    0H
PREBADIO ABEND 11,DUMP
         SPACE 1
ABEND12  DS    0H
PREBOOB  ABEND 12,DUMP
         SPACE 3
ABEND15  DS    0H
PRECPEOF ABEND 15,DUMP             SHOULD NEVER GET EOF ON VTOC COPY
         SPACE 3
ABEND16  DS    0H
PREFDSCB ABEND 16,DUMP             BAD DS1LSTAR IN FMT1
         SPACE 2
ABEND17  DS    0H
PREVMANY ABEND 17,DUMP             TOO MANY PRE-ALLOCATED DATASETS
         EJECT
PRESAV   DS    16F
PRESVR14 DS    F
PRETTRL@ DS    A
PRETTRLN DS    A
PRETTRND DS    A
         SPACE 1
PREDSKI  DCB   DDNAME=SYSUT1,                                          *
               MACRF=RKC,                                              *
               DSORG=DA,                                               *
               LIMCT=999999,                                           *
               BLKSIZE=96,KEYLEN=44,RECFM=F,                           *
               EXLST=INJFCBAD,                                         *
               SYNAD=IOER,                                             *
               OPTCD=EF
         READ  PREDECBI,DKF,PREDSKI,PREDSCBI+44,'S',PREDSCBI,PREBLKI,  *
               MF=L
PREDSCBI DS    XL140
PREBLKI  DS    F
PREDSKO  DCB   DDNAME=SYSUT2,                                          *
               MACRF=RIC,                                              *
               DSORG=DA,                                              **
               BLKSIZE=96,KEYLEN=44,RECFM=F,                           *
               EXLST=OTJFCBAD,                                         *
               SYNAD=IOER
         READ  PREDECBO,DI,PREDSKO,PREDSCBO+44,'S',PREDSCBO,PREBLKO,   *
               MF=L
PREDSCBO DS    XL140
PREBLKO  DS    F
PREABSAD DS    D
PRELSTF1 DS    F
PREDSPTR DS    F
PRETTRO  DS    F
PRECOPYV DCB   DDNAME=SYSUT3,                                          *
               MACRF=(RP,W),                                           *
               BLKSIZE=140,RECFM=F,                                    *
               DSORG=PS,                                               *
               EODAD=PRECPEOF
         WRITE PREDECBV,SF,PRECOPYV,PREDSCBO,MF=L
PREBLKV  DS    F
         SPACE 5
R0       EQU   0
R1       EQU   1
R2       EQU   2
R3       EQU   3
R4       EQU   4
R5       EQU   5
R6       EQU   6
R7       EQU   7
R8       EQU   8
R9       EQU   9
R10      EQU   10
R11      EQU   11
R12      EQU   12
R13      EQU   13
R14      EQU   14
R15      EQU   15
         END
