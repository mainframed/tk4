./       ADD   NAME=BEGIN
 DUMMY MEMBER TO ENSURE FOLLOWING REPL WORKS
./       ADD   NAME=GOBACK
 DUMMY MEMBER TO ENSURE FOLLOWING REPL WORKS
./       ADD   NAME=HEXPRINT
 DUMMY MEMBER TO ENSURE FOLLOWING REPL WORKS
./       ADD   NAME=PRINCORE
 DUMMY MEMBER TO ENSURE FOLLOWING REPL WORKS
./       ADD   NAME=TSGSNAP
 DUMMY MEMBER TO ENSURE FOLLOWING REPL WORKS
./       ADD   NAME=FINDUCB
 DUMMY MEMBER TO ENSURE FOLLOWING REPL WORKS
./       ADD   NAME=SPMODE
 DUMMY MEMBER TO ENSURE FOLLOWING REPL WORKS
./       ADD   NAME=DATE
 DUMMY MEMBER TO ENSURE FOLLOWING REPL WORKS
./       ADD   NAME=TSGINNRA
 DUMMY MEMBER TO ENSURE FOLLOWING REPL WORKS
./       ADD   NAME=TSGINNRB
 DUMMY MEMBER TO ENSURE FOLLOWING REPL WORKS
./       ADD   NAME=TSGINNRC
 DUMMY MEMBER TO ENSURE FOLLOWING REPL WORKS
./       ADD   NAME=TSGINNRD
 DUMMY MEMBER TO ENSURE FOLLOWING REPL WORKS
./       ADD   NAME=DCBEXITS
 DUMMY MEMBER TO ENSURE FOLLOWING REPL WORKS
./       ADD   NAME=DLINE
 DUMMY MEMBER TO ENSURE FOLLOWING REPL WORKS
./        REPL  LIST=ALL,SSI=00200500,NAME=BEGIN
./       NUMBER NEW1=0,INCR=20000
         MACRO
&NAME    BEGIN &SAVE,&BASE=12,&ID=*
.*
.* THE BEGIN MACRO PROVIDES THE FOLLOWING FACILITIES....
.*   1.  REGISTER SAVING
.*
.*       THE SAVE MACRO IS USED TO SAVE REGISTERS 14,12 IN THE SAVE
.*       AREA ADDRESSED BY REG 13.
.*   2.  IDENTIFIER.
.*
.*       YOU MAY PROVIDE ANY IDENTIFIER (TO HELP FIND THE ENTRY POINT
.*       IN A DUMP) BY CODING 'ID=STRING OF UP TO 70 CHARS' - THE
.*       DEFAULT ID IS THE NAME OF THE MACRO OR THE CSECT NAME UNLESS
.*       YOU CANCEL THE PARAMETER BY CODING 'ID='
.*   3.  DEFINING BASE REGISTERS.
.*       YOU MAY PREVENT ANY BASE REGISTER INITIALIZATION BY CODING
.*       'BASE=NONE', OR SET UP ONE OR MORE BASE REGISTERS BY CODING
.*       'BASE=(10,11,12...)'.  IF THE BASE PARAMETER IS OMITTED REG 12
.*       IS INITIALIZED AS A BASE BY DEFAULT.  NOTE THAT YOU CANNOT USE
.*       SYMBOLIC NAMES FOR THE BASE REGISTERS OTHER THAN THE FIRST.
.*       E.G. BASE=(R10,11,12) IS VALID BUT 'BASE=(R10,R11,R12) IS NOT
.*   4.  SAVE AREA PROVISION.
.*       THIS IS DEFINED BY THE FIRST POSITIONAL PARAMETER.  BY DEFAULT
.*       A 72 BYTE SAVE AREA IS GENERATED IN THE MACRO EXPANSION.
.*       YOU MAY ALSO CODE ONE OF.....
.*       A)  'NOSAVE' CAUSES NO SAVE AREA TO BE GENERATED AND LEAVES
.*             REG 13 AS AT ENTRY. UNLESS NOSAVE IS CODED REG 13 IS
.*             ALWAYS SET TO POINT TO THE NEW SAVE AREA.
.*       B)    IF YOU DEFINE THE SAVE AREA IN YOUR PROGRAM YOU CODE THE
.*             SAVE AREA NAME E.G. 'BEGIN SAVE'.
.*             BY CODING 'BEGIN (SAVE,,SAVE)' YOU WILL GENERATE A
.*             STATEMENT 'USING SAVE,13' TO BE GENERATED AND THIS CAN
.*             BE A USEFUL WAY OF CREATING A SECOND BASE REGISTER FOR
.*       WHAT COMES AFTER THE SAVE AREA IN YOUR PROGRAM.
.*       C)    IF YOU WISH TO ACQUIRE CORE DYNAMICALLY FOR THE SAVE
.*             AREA BEGIN WILL ISSUE A GETMAIN FOR YOU IF YOU CODE
.*             'BEGIN DYNAMIC'.  BY DEFAULT A 72 BYTE AREA WILL BE
.*             ACQUIRED AND REG 13 WILL BE SET TO POINT TO IT.
.*             IF YOU WISH TO ACQUIRE A LARGER AREA FOR OTHER PURPOSES
.*             IN ADDITION TO THE SAVE AREA YOU CODE THE TOTAL LENGTH
.*             AND DSECT NAME FOR THE AREA E.G. ........
.*             'BEGIN (DYNAMIC,240,DYNAR)'.  THIS EXAMPLE WILL RESULT
.*             IN A GETMAIN FOR 240 BYTES FROM SUBPOOL 0, REG 13 WILL
.*             BE SET TO THE ACQUIRED ADDRESS, AND A 'USING DYNAR,13'
.*             WILL BE GENERATED.
.*
.*       FORMAT OF MACRO....
.* NAME  BEGIN NOSAVE                            OR        (POS PARM 1)
.*             (SAVEAREA ADDRESS,,DSECT NAME)    OR
.*             (DYNAMIC,LENGTH,DSECT NAME)
.*             ,BASE=NONE                        OR        (KEYWORD 1)
.*             ,BASE=(REGISTER LIST)
.*             ,ID='CHARACTER STRING'                      (KEYWORD 2)
.*
         LCLA  &A(15),&A0,&A1,&R1,&R2
         LCLC  &GNAME,&C1,&C(5)
&NAME    SAVE  (14,12),T,&ID       SAVE REGISTERS.
         AIF   ('&BASE' EQ ''  OR '&BASE'EQ 'NONE').C10
         BALR  &BASE(1),0          SET FIRST (OR ONLY) BASE REGISTER.
         AIF   (N'&BASE EQ 1).C1
&A0      SETA  1
&A1      SETA  2
.C18     AIF   (K'&BASE LE (&A1+8)).C2
&C(&A0)  SETC  '&BASE'(&A1,8)
&A0      SETA  &A0+1
&A1      SETA  &A1+8
         AGO   .C18
.C2      ANOP
&C(&A0)  SETC  '&BASE'(&A1,K'&BASE-&A1)
         USING *,&C(1)&C(2)&C(3)&C(4)&C(5)   DEFINE BASE REGISTER(S).
&GNAME   SETC  'IHB'.'&SYSNDX'
&C1      SETC  '&GNAME'.'A'
&GNAME   EQU   *                   DEFINE BASE REGISTER ORIGIN.
&A0      SETA  2
.C4      AIF   (&A0 GT N'&BASE).C3
&A1      SETA  &BASE(&A0)
&A(&A1)  SETA  4096*(&A0-1)
&A0      SETA  &A0+1
         AGO   .C4
.C1      USING *,&BASE(1)
         AGO   .C10
.C3      ANOP
&A0      SETA  0
&R1      SETA  1
.C11     ANOP
&R2      SETA  &R1+1
         AIF   (&A(&R1) EQ 0).C5
.C7      AIF   (&A(&R2) EQ 0).C6
&R2      SETA  &R2+1
         AIF   (&R2 LT 16).C7
.C6      AIF   (&R1 EQ (&R2-1)).C8
&A1      SETA  &R2-1
         LM    &R1,&A1,&GNAME.A+&A0     INITIALISE BASE REGISTER(S).
         AGO   .C9
.C8      L     &R1,&GNAME.A+&A0    INITIALISE BASE REGISTER(S).
.C9      ANOP
&A0      SETA  &A0+4*(&R2-&R1)
.C5      AIF   (&R2 GE 16).C10
&R1      SETA  &R2
         AGO   .C11
.C10     AIF   ('&SAVE(1)' EQ '').C12
         AIF   ('&SAVE' EQ 'NOSAVE').C13
         AIF   ('&SAVE(1)' EQ 'DYNAMIC').C14
         LA    15,&SAVE(1)         SET GR15 -> NEW SAVE AREA.
         AGO   .C15
.C12     CNOP  0,4                 FORCE ALIGNMENT ON WORD BOUNDARY.
         BAL   15,*+76             SET GR15-> NEW SAVE AREA.
         DC    18F'0'              NEW SAVE AREA.
         AGO   .C15
.C14     AIF   ('&SAVE(2)' EQ '').C20
         LA    0,&SAVE(2)(0,0)    SET GR0 = LENGTH OF DYNAMIC AREA.
         AGO   .C19
.C20     LA    0,72(0,0)           SET GR0 = LENGTH OF DYNAMIC AREA.
.C19     GETMAIN R,LV=(0)          OBTAIN DYNAMIC NEW SAVE AREA.
         LR    15,1                SET GR15 -> NEW SAVE AREA.
         LM    0,1,20(13)          RESTORE PARAMETER REGISTERS.
.C15     ST    15,8(13,0)          STORE NSA ADDR. IN LSA.
         ST    13,4(15,0)          STORE LSA ADDR.IN NSA.
         LR    13,15               SET GR13 -> NEW SAVE AREA.
         AIF   ('&SAVE(3)' EQ '').C13
         USING &SAVE(3),13         DEFINE GR13 AS BASE REGISTER.
.C13     AIF   (N'&BASE LE 1).EXIT
         BC    15,&GNAME.B         BRANCH ROUND BASE REGISTER VALUE(S).
&A0      SETA  1
.C17     AIF   (&A(&A0) EQ 0).C16
&C1      DC    A(&GNAME+&A(&A0))   BASE REGISTER VALUE.
&C1      SETC  ''
.C16     ANOP
&A0      SETA  &A0+1
         AIF   (&A0 LE 15).C17
&GNAME.B EQU   *
 AIF (&A(13)NE 0 OR &A(15)NE 0 OR(&A(1)NE 0 AND'&SAVE'EQ'DYNAMIC')).E1
.EXIT    MEXIT
.E1      MNOTE 12,'***  IHBNNN  INVALID REGISTER SPECIFIED'
         MEND
./        REPL  LIST=ALL,SSI=00200500,NAME=GOBACK
./       NUMBER NEW1=0,INCR=20000
         MACRO
&NAME    GOBACK     &SAVE,&RC=0
.*
.* THE GOBACK MACRO PROVIDES..........
.*   1.  RESETTING OF REG 13.
.*       REG 13 WILL BE RESET ACCORDING TO THE HSA POINTER IN THE
.*       CURRENT SAVE AREA UNLESS YOU CODE 'GOBACK NOSAVE' (IMPLYING
.*       THE YOU ISSUED 'BEGIN NOSAVE')
.*   2.   FREEMAIN OF DYNAMIC SAVE AREA.
.*       IF YOU CODE 'GOBACK (DYNAMIC,LENGTH)' A FREEMAIN WILL BE
.*       ISSUED FOR THE LENGTH YOU SPECIFY FROM THE ADDRESS GIVEN BY
.*       REG 13 (BEFORE RESETTING).
.*   3.  RETURN CODE.
.*       YOU MAY EITHER CODE 'RC=NUMBER' OR PUT THE NUMBER IN REG 15
.*       AND CODE 'RC=(15)'.  BY DEFAULT REG 15 IS SET TO ZERO.
.*   4.        RESTORING REGISTERS.
.*       GOBACK ISSUES 'RETURN (14,12),T,RC=(15)' AFTER OPERATIONS
.*       DESCRIBED IN 2 AND 3 UNLESS YOU CODE 'NOSAVE'.
.*
         AIF   ('&SAVE' EQ 'NOSAVE').C1
         AIF   ('&SAVE(1)' EQ 'DYNAMIC').C2
&NAME    L     13,4(13,0)          SET GR13 -> PREVIOUS SAVE AREA.
.C3      AIF   ('&RC' EQ '' OR '&RC' EQ '(15)').C3A
         AIF   ('&RC'(1,1) NE '(').C3A
         LR    15,&RC(1)           SET GR15 = RETURN CODE.
.C1B     RETURN     (14,12),T,RC=(15)
         MEXIT
.C3A     RETURN     (14,12),T,RC=&RC
         MEXIT
.C1      AIF   ('&RC' EQ '' OR '&RC' EQ '(15)').C1A
         AIF   ('&RC'(1,1) NE '(').C1A
&NAME    LR    15,&RC(1)           SET GR15 = RETURN CODE.
         AGO   .C1B
.C1A     ANOP
&NAME    RETURN     (14,12),T,RC=&RC
         MEXIT
.C2      ANOP
&NAME    LR    1,13                SET GR1 -> CURRENT SAVE AREA.
         L     13,4(13,0)          SET GR13 -> PREVIOUS SAVE AREA.
         AIF   ('&SAVE(2)' NE '').C4
         LA    0,72(0,0)           SET GR0 = LENGTH OF DYNAMIC AREA.
         AGO   .C5
.C4      LA    0,&SAVE(2)(0,0)     SET GR0 = LENGTH OF DYNAMIC AREA.
.C5      SVC   10                  ISSUE FREEMAIN SVC.
         AGO   .C3
         MEND
./        REPL  LIST=ALL,SSI=00200500,NAME=HEXPRINT
./       NUMBER NEW1=0,INCR=20000
         MACRO
&NAME    HEXPRINT &H,&C,&L,&SP,&MF=I
.*
.*  THE HEXPRINT MACRO TRANSLATES ANY STRING OF EBCDIC CHARACTERS
.*  INTO A STRING OF HEX CHARACTERS (READY FOR PRINTING A DUMP IMAGE).
.*  IT WILL OPTIONALLY INSERT A GIVEN NUMBER OF SPACES AFTER EACH NTH
.*  CHARACTER.
.*  THERE ARE FOUR POSITIONAL PARAMETERS....
.*   1.  ADDRESS OF ORIGINAL DATA TO BE TRANSLATED.
.*   2.  ADDRESS OF RECEIVING AREA FOR TRANSLATED DATA.
.*   3.  LENGTH OF ORIGINAL DATA TO BE TRANSLATED.  THE RECEIVING AREA
.*       LENGTH IS THE USERS RESPONSIBILITY AND MUST BE AT LEAST TWICE
.*       THE LENGTH OF THE ORIGINAL DATA (OR LONGER IF SEPARATOR
.*       BLANKS ARE REQUESTED).
.*   4.  DEFINITION OF SEPARATOR BLANKS TO BE INSERTED AS.....
.*       (NO. OF ORIGINAL BYTES TO BE TRANSLATED AS ONE BLOCK, NO. OF
.*       BLANKS TO FOLLOW EACH BLOCK).
.*       BY DEFAULT NO SEPARATOR BLANKS ARE PROVIDED.
.*
.*  EXAMPLE....    'HEXPRINT  FROM,TO,100,(5,1)'
.*
         GBLB  &GTSGHEX
         LCLC  &GNAME
&GNAME   SETC  '&NAME'
         AIF   ('&MF' EQ 'L').LROUT
         AIF   ('&MF(1)' EQ 'E' AND N'&MF EQ 2).EROUT
         AIF   ('&MF' NE 'I').E1
         CNOP  0,4
&NAME    BAL   1,*+36
&GNAME   SETC  ''
.LROUT   ANOP
&GNAME TSGINNRB (A,A,H,AL1,AL1),(&C,&H,&L,&SP(1),&SP(2)),(,,1),MF=&MF
         DC    CL16'0123456789ABCDEF',V(TSGHEXPT)
         AIF   ('&MF' EQ 'I').C1
         MEXIT
.EROUT   ANOP
&NAME    IHBINNRA &MF(2)
.C1 TSGINNRC (A,A,A,A,A),(,,H,C,C),(&C,&H,&L,&SP(1),&SP(2)),MF=&MF(1)
         L     15,28(1,0)          SET GR15 -> ENTRY POINT ADDRESS.
         BALR  14,15               LINK TO CONVERT.
         AIF   (&GTSGHEX).END
&GTSGHEX SETB  1
TSGHEXPT CSECT
         STM   0,7,20(13)          SAVE REGISTERS.
         LM    4,5,0(1)            SET GR4 -> CHAR, GR5 -> HEX FIELD.
         LH    0,8(1,0)            SET GR0 = LENGTH OF HEX FIELD.
         SR    3,3                 SET GR3 = 0.
         SR    6,6                 SET GR6 = 0.
         SR    7,7                 SET GR7 = 0.
         IC    6,10(1,0)           SET GR6 = NUMBER OF HEX BETWEEN BLNK
         IC 7,11(1,0)              SET GR7 = NUMBER OF BLANKS.
         IC    3,0(5,0)            SET HEX BYTE IN LO-ORDER BYTE GR3.
         SLDL  2,28                SET HEX VALUE IN LO-ORDER BYTE GR2.
         SRL   3,28                SET HEX VALUE IN LO-ORDER BYTE GR3.
         IC    2,12(1,2)           SET CHARACTER IN LO-ORDER BYTE GR2.
         IC    3,12(1,3)           SET CHARACTER IN LO-ORDER BYTE GR3.
         STC   2,0(4,0)            STORE CHARACTER.
         STC   3,1(4,0)            STORE CHARACTER.
         LA    4,2(4,0)            INCREMENT GR4 FOR NEXT CHAR BYTE.
         LA    5,1(5,0)            INCREMENT GR5 FOR NEET HEX BYTE.
         BCT   6,72(15,0)          LOOP UNTIL BLANKS REQUIRED.
         AR    4,7                 INCREMENT GR4 FOR BLANKS.
         IC    6,10(1,0)           RESTORE GR6 FOR LOOP.
         BCT   0,26(15,0)          LOOP UNTIL HEX CHARS EXHAUSTED.
         LM    0,7,20(13)          RESTORE REGISTERS.
         BR    14                  RETURN.
&SYSECT  CSECT
         MEXIT
.E1      MNOTE 12,'***  IHB002  INVA6ID MF OPERAND SPECIFIED-&MF'
.END     MEND
./        REPL LIST=ALL,SSI=00200500,NAME=PRINCORE
./       NUMBER  NEW1=10,INCR=10
         MACRO
&NAME    PRINCORE   &FROM,&TO,&DCB,&RES=0
.*     *     *     *    *    *    *    *    *    *    *    *    *     *
.*
.* THIS MACRO IS USED TO PRINT OUT AREAS OF CORE TO A SPECIFIED FILE.
.* IT IS INTENDED ESPECIALLY TO PRINT AREAS NOT WITHIN THE USER'SOWN
.* CORE.  THE USER MUST GIVE THE START AND END ADDRESSES OF THE AREA,
.* AND INDICATE THE DCB TO BE USED. IF HE SUPPLIES HIS OWN DCB IT MUST
.* HAVE THE CHARACTERISTICS RECFM=FM (OR FBM) WITH LRECL=133, AND IT
.* MUST BE ALREADY OPEN.
.* THE MACRO ASSUMES BY DEFAULT THAT NO PAGING IS REQUIRED.  IF &RES IS
.* GIVEN A NON-ZERO VALUE 'N' THEN N-1 LINES WILL BE PRINTED ON THE
.* CURRENT PAGE, FOLLOWED BY A THROW TO A NEW PAGE ON WHICH 56 LINES
.* WILL BE PRINTED.  THIS ALLOWS THE USER TO START HIS OUTPUT ON A NEW
.* PAGE (BY RES=1) OR TO POSITION HIMSELF ANYWHERE ON A PAGE AND TELL
.* PRINCORE TO FINISH THE PAGE CORRECTLY BY GIVING IT A RESIDUAL COUNT
.* OF NOT MORE THAN 56.
.*  DEFAULT PARAMS           FROM ADD IN REG 1
.*                 TO ADD IN REG 0
.*                 DCB NAME CORPRINT (DDNAME CORPRINT)
.*                 RESIDUAL LINE COUNT = 0
.*
.*     *     *     *    *    *    *    *    *    *    *    *    *     *
         GBLB  &GDECLN,&GDCB
         LCLC  &GNAME
&GNAME   SETC  'IHB'.'&SYSNDX'
&NAME    STM   14,12,12(13)
         AIF   ('&FROM' EQ '').C1            BLANK _SO IN REG 1
         AIF   ('&FROM'(1,1) NE '(').C2      NOT REG. _IGNORE HERE
         ST    &FROM(1),&GNAME.A+0
         AGO   .C2
.C1      ST    1,&GNAME.A+0
.C2      AIF   ('&TO' EQ '').C3              BLANK _SO IN REG 0
         AIF   ('&TO'(1,1) NE '(').C4        NOT REGISTER  _IGNORE HERE
         ST    &TO(1),&GNAME.A+4
         AGO   .C4
.C3      ST    0,&GNAME.A+4
.C4      CNOP  0,4
         BAL   14,*+16
.*
.* SET UP &GNAME.A
         AIF   ('&FROM' EQ '').B1
         AIF   ('&FROM'(1,1) EQ '(').B1
&GNAME.A DC    A(&FROM)                 NON-REG. FROM-ADDR (EG X'1234')
         AGO   .B2
.B1      ANOP
&GNAME.A DC    A(0)                     REGISTER FROM-ADDR
.B2      AIF   ('&TO' EQ '').B3
         AIF   ('&TO'(1,1) EQ '(').B3
         DC    A(&TO)                   NON-REG. TO_ADDR
         AGO   .B4
.B3      DC    A(0)                     REGISTER TO_ADDR
.B4      DC    V($PRINCOR)              CSECT
         LM    1,3,0(14)
         ST    1,$FROM-$PRINCOR(3)
.* SET UP REG& WITH ADDRESS OF DCB REQUIRED (SUPPLIED OR DEFAULT)
         AIF   ('&DCB' EQ '').A1
         AIF   ('&DCB'(1,1) EQ '(').A2
         LA    8,&DCB
         AGO   .A3
.A2      LR    8,&DCB(1)
         AGO   .A3
.A1      OPEN  (CORPRINT,(OUTPUT))
         LA    8,CORPRINT-$PRINCOR(3)
.* SET UP LINE COUNTING IF REQUIRED
.A3      AIF   ('&RES'(1,1) NE '(').A4
         ST    &RES,$LINECT-$PRINCOR(3)
         AGO   .A5
.A4      LA    0,&RES
         ST    0,$LINECT-$PRINCOR(3)
.A5      ANOP
.* BRANCH TO $PRINCOR CSECT
         BAL   10,$PRINCO1-$PRINCOR(3)
         LM    14,12,12(13)
         AIF   (&GDECLN AND &GDCB).EXIT
         AIF   (&GDECLN AND '&DCB' NE '').EXIT
$PRINCOR CSECT
         AIF   (&GDECLN).C41            NOT FIRST USE MACRO
&GDECLN  SETB  1
*DECLARATIONS                                                         *
$MTCB    MVC   0(1,5),$SPACES-$PRINCOR(3)    EXECUTED INSTRUCTIONS
$MTC     MVC   $CHARS-$PRINCOR(1,3),$SPACES-$PRINCOR(3)
$SPACES  DC    CL40' '                       CONSTANT
$ADDR    DC    F'0'                          ADDRESS FIELD
$LINECT  DC    A(0)          LINE COUNT
$CHARTAB DC    256C' '
         ORG   $CHARTAB+C'A'
         DC    C'ABCDEFGHI'
         ORG   $CHARTAB+C'J'
         DC    C'JKLMNOPQR'
         ORG   $CHARTAB+C'S'
         DC    C'STUVWXYZ'                   TRANSLATE TABLE
         ORG   $CHARTAB+C'0'
         DC    C'0123456789'
         ORG
$THREE   DC    X'1B'
$SKIP    DC    X'8B'         PAGE THROW ON PRINT
$LINE    DC    X'09'                         OUTPUT LINE (133 CHARS)
$HEXAD   DC    CL6' '                        ADDR
         DC    CL4' '
$FLDA    DC    CL35' '
         DC    CL4' '
$FLDB    DC    CL35' '
         DC    CL4' '
$CHARS   DC    CL32' '                       CHAR REPRESENTN. OF HEX
         DC    CL18' '
$SAVE    DC    18F'0'                        SAVE AREA
$FROM    DC    F'0'
* MAIN HANDLING OF EACH LINE (32 CHARS) DONE HERE                     *
*       FOR CORE SPECIFIED:  HEXPRINT IS USED TO DO CONVERSIONS OF THE*
*       DATA,WHICH IS THEN OUTPUT TO THE APPROPRIATE FILE (SUPPLIED   *
*       BY USER,OR DEFAULT IS CORPRINT                                *
$PRINCO1 ST    13,$SAVE+4-$PRINCOR(3)
         LA    15,$SAVE-$PRINCOR(3)
         ST    15,8(13)
         LA    13,$SAVE-$PRINCOR(3)
         L     1,$FROM-$PRINCOR(3)
         CR    2,1
         BNL   $ROUND-$PRINCOR(3)
         LR    2,1
$ROUND   LA    9,31
         LR    4,9
         NR    9,1
         NR    4,2
         SRL   1,5
         SLL   1,5
         ST    1,$FROM-$PRINCOR(3)
&GNAME.C L     1,$FROM-$PRINCOR(3)
         ST    1,$ADDR-$PRINCOR(3)
*        HEXPRINT  $ADDR+1,$HEXAD,3         DUMMY STMT
         CNOP  0,4
         BAL   1,*+36-$PRINCOR(3)
         DC    A($HEXAD)
         DC    A($ADDR+1)
         DC    H'3'
         DC    AL1(0)
         DC    AL1(0)
         DC    CL16'0123456789ABCDEF',V(TSGHEXPT)
         L     15,28(1,0)
         BALR  14,15
TSGHEXPT CSECT
         STM   0,7,20(13)
         LM    4,5,0(1)
         LH    0,8(1,0)
         SR    3,3
         SR    6,6
         SR    7,7
         IC    6,10(1,0)
         IC    7,11(1,0)
         IC    3,0(5,0)
         SLDL  2,28
         SRL   3,28
         IC    2,12(1,2)
         IC    3,12(1,3)
         STC   2,0(4,0)
         STC   3,1(4,0)
         LA    4,2(4,0)
         LA    5,1(5,0)
         BCT   6,72(15,0)
         AR    4,7
         IC    6,10(1,0)
         BCT   0,26(15,0)
         LM    0,7,20(13)
         BR    14  RETURN
$PRINCOR CSECT
         L     5,$FROM-$PRINCOR(3)
*        HEXPRINT  (5),$FLDA,16,(4,1)
         CNOP  0,4
         BAL   1,*+36-$PRINCOR(3)
         DC    A($FLDA)
         DC    A(0)
         DC    H'16'
         DC    AL1(4)
         DC    AL1(1)
         DC    CL16'0123456789ABCDEF',V(TSGHEXPT)
         ST    5,4(1,0)
         L     15,28(1,0)
         BALR  14,15
         LA    5,16(5)
*        HEXPRINT  (5),$FLDB,16,(4,1)       DUMMY STMT
         CNOP  0,4
         BAL   1,*+36-$PRINCOR(3)
         DC    A($FLDB)
         DC    A(0)
         DC    H'16'
         DC    AL1(4)
         DC    AL1(1)
         DC    CL16'0123456789ABCDEF',V(TSGHEXPT)
         ST    5,4(1,0)
         L     15,28(1,0)
         BALR  14,15
         L     1,$FROM-$PRINCOR(3)
         MVC   $CHARS-$PRINCOR(32,3),0(1)
         TR    $CHARS-$PRINCOR(L'$CHARS,3),$CHARTAB-$PRINCOR(3)
         LTR   9,9
         BZ    &GNAME.E-$PRINCOR(3)
         LR    5,9
         BCTR  5,0
         EX    5,$MTC-$PRINCOR(3)       MVC  $CHARS(1),$SPACES
         LA    5,$FLDA-$PRINCOR(3)
         LA    6,4
         LA    7,4
&GNAME.D MVC   0(2,5),$SPACES-$PRINCOR(3)
         BCT   9,*+8-$PRINCOR(3)
         B     &GNAME.E-$PRINCOR(3)
         LA    5,2(5)
         BCT   6,&GNAME.D-$PRINCOR(3)
         LA    6,4
         LA    5,1(5)
         BCT   7,&GNAME.D-$PRINCOR(3)
         LA    7,4
         LA    5,3(5)
         B     &GNAME.D-$PRINCOR(3)
&GNAME.E LA    1,32(1)
         ST    1,$FROM-$PRINCOR(3)
         SR    9,9
         CR    2,1
         BH    &GNAME.G-$PRINCOR(3)     PUT & THEN CONSIDERNEXT LINE
         BE    &GNAME.H-$PRINCOR(3)     END
         LR    9,1
         SR    9,2
         LA    4,32
         SR    4,9
         LA    5,$CHARS-$PRINCOR(4,3)
         LR    2,9
         BCTR  9,0
         EX    9,$MTCB-$PRINCOR(3)      MVC  0(1,5),$SPACES
         LA    5,$FLDB+33-$PRINCOR(3)
         LA    6,4
         LA    7,4
&GNAME.F MVC   0(2,5),$SPACES-$PRINCOR(3)
         BCT   2,*+8-$PRINCOR(3)
         B     &GNAME.H-$PRINCOR(3)     PUT & THEN END
         BCTR  5,0
         BCTR  5,0
         BCT   6,&GNAME.F-$PRINCOR(3)
         LA    6,4
         BCTR  5,0
         BCT   7,&GNAME.F-$PRINCOR(3)
         LA    7,4
         LA    1,3
         SR    5,1
         B     &GNAME.F-$PRINCOR(3)
&GNAME.G BAL   11,$PUTSVB-$PRINCOR(3)
         B     &GNAME.C-$PRINCOR(3)     CONVERT NEXT LINE
&GNAME.H BAL   11,$PUTSVB-$PRINCOR(3)
&GNAME.J LA    12,$THREE-$PRINCOR(3)
         BAL   11,$PUTSVB+4-$PRINCOR(3)
         L     13,$SAVE+4-$PRINCOR(3)
         BR    10
         SPACE
$PUTSVB  LA    12,$LINE-$PRINCOR(3)
         L     1,$LINECT-$PRINCOR(3)
         BCT   1,$PUTSVBA-$PRINCOR(3)
         PUT   (8),$SKIP-$PRINCOR(3)
         LA    1,56
$PUTSVBA  ST   1,$LINECT-$PRINCOR(3)
         PUT   (8),(12)
         BR    11
.C41     AIF   ('&DCB' NE '').CSECT
         AIF   (&GDCB).CSECT
&GDCB    SETB  1
CORPRINT DCB   DSORG=PS,                                               *
               DDNAME=CORPRINT,                                        *
               MACRF=(PM),                                             *
               RECFM=FBM,                                              *
               LRECL=133,                                              *
               BLKSIZE=1463
.CSECT   ANOP
&SYSECT  CSECT
.EXIT    MEND
./        REPL  LIST=ALL,SSI=00200500,NAME=TSGSNAP
./       NUMBER NEW1=0,INCR=20000
         MACRO
&NAME    TSGSNAP &TCB=0,&SDATA=,&PDATA=,&STORAGE=,&LIST=,&ID=,&MF=I
.*  THE TSGSNAP MACRO PROVIDES THE USER WITH THE NORMAL FACILITIES OF
.*  THE SNAP MACRO WITHOUT HAVING TO SET UP AND OPEN AN APPROPRIATE DCB
.*  TSGSNAP CRATES AND OPENS ITS OWN DCB AND ALL THE USER HAS TO DO IS
.*  TO PROVIDE A //SNAPOUT DD CARD ( E.G. //SNAPOUT DD SYSOUT=A)
.*  IN SOME CIRCUMSTANCES THE PROGRAM MUST CLOSE THE TSGSNAPA DCB IF IT
.*  IS NOT TO LOSE THE SYSPRINT (E.G. IF THE PROGRAM CORRUPTS THE DEB
.*  CHAIN AND THEN ABENDS LEAVING THE DCB UNCLOSED AND THE TIOT ENTRY
.*  LOOKING AS IF IT IS A NULL SYSOUT DATA SET.
         GBLB  &GSNAPSW
         LCLA  &A1,&A2
         LCLB  &B1,&B2,&B3,&B4,&B5,&B6,&B7,&B8,&B9,&BA,&BB,&BC,&BD,&BE
         LCLC  &GNAME,&C1
&GNAME   SETC  'IHB'.'&SYSNDX'
.C2      AIF   (&A1 GE N'&SDATA).C1
&A1      SETA  &A1+1
&C1      SETC  '&SDATA(&A1)'
&B2      SETB  (&B2 OR '&C1' EQ 'ALL' OR '&C1' EQ 'CB')
&B3      SETB  (&B3 OR '&C1' EQ 'ALL' OR '&C1' EQ 'TRT')
&B4      SETB  (&B4 OR '&C1' EQ 'ALL' OR '&C1' EQ 'NUC')
&B7      SETB  (&B7 OR '&C1' EQ 'ALL' OR '&C1' EQ 'Q')
         AGO   .C2
.C1      AIF   ('&LIST' NE '' AND '&STORAGE' NE '').E1
&B5      SETB  ('&STORAGE' NE '')
&A1      SETA  2*(N'&STORAGE/2)
         AIF   (&A1 NE N'&STORAGE OR N'&LIST GT 1).E1
&B1      SETB  ('&TCB' NE '0' AND '&TCB' NE '''S''')
&B6      SETB  ('&ID' NE '')
&A1      SETA  128+64*&B1+32*&B2+16*&B3+8*&B4+4*&B5+2*&B6+&B7
.C4      AIF   (&A2 GE N'&PDATA).C3
&A2      SETA  &A2+1
&C1      SETC  '&PDATA(&A2)'
&B8      SETB  (&B8 OR'&C1'EQ'ALL'OR'&C1'EQ'SAH'OR'&C1'EQ'SA')
&B9      SETB  (&B9 OR'&C1'EQ'SAH')
&BA      SETB  (&BA OR'&C1'EQ'ALL'OR'&C1'EQ'REGS')
&BB      SETB  (&BB OR'&C1'EQ'ALL'OR'&C1'EQ'ALLPA'OR'&C1'EQ'LPA')
&BC      SETB  (&BC OR'&C1'EQ'ALL'OR'&C1'EQ'ALLPA'OR'&C1'EQ'JPA')
&BD      SETB  (&BD OR'&C1'EQ'ALL'OR'&C1'EQ'PSW')
&BE      SETB  (&BE OR'&C1'EQ'ALL'OR'&C1'EQ'SPLS')
         AGO   .C4
.C3      ANOP
&A2      SETA  128*&B8+64*&B9+32*&BA+16*&BB+8*&BC+4*&BD+2*&BE
         AIF   ('&MF'EQ 'L').LROUT
         AIF   ('&MF(1)' EQ 'E' AND N'&MF EQ 2).EROUT
         AIF   ('&MF' NE 'I').E2
         CNOP  0,4
&NAME    STM   14,1,28(13)         SAVE REGISTERS.
         BAL   1,&GNAME            BRANCH AROUND DATA.
.C15     AIF   ('&ID' EQ '').C5
         AIF   ('&ID'(1,1) EQ '(').C5
         DC    AL1(&ID)            ID NUMBER.
         AGO   .C6
.C5      DC    AL1(0)              ID NUMBER.
.C6      DC    AL1(0)
         DC    AL1(&A1,&A2)        OPTION FLAGS.
         DC    A(TSGSNAPA)         DCB ADDRESS.
         DC    A(0)                TCB ADDRESS.
         AIF   ('&LIST' EQ '').C7
         AIF   ('&LIST'(1,1) EQ '(').C8
         DC    A(&LIST)            ADDRESS OF SNAPSHOT LIST.
         AGO   .C9
.C8      DC    A(0)                ADDRESS OF SNAPSHOT LIST.
         AGO   .C9
.C7      AIF   ('&STORAGE' EQ '').C8
         DC    A(*+4)              ADDRESS OF SNAPSHOT LIST.
&A1      SETA  0
.C11     AIF   (&A1 GE N'&STORAGE).C12
&A1      SETA  &A1+1
         AIF   ('&STORAGE(&A1)' EQ '').C10
         AIF   ('&STORAGE(&A1)'(1,1) EQ '(').C10
         DC    A(&STORAGE(&A1))    STARTING/ENDING ADDRESS.
         AGO   .C11
.C10     DC    A(0)                STARTING/ENDING ADDRESS.
         AGO   .C11
.C12     ORG   *-4
         DC    X'80'
         ORG   *+3
.C9      AIF   ('&MF' EQ 'L').C13
&GNAME   DS    0H
         AGO   .C14
.LROUT   ANOP
&NAME    DS    0A
         AGO   .C15
.EROUT   ANOP
&NAME    STM   14,1,28(13)         SAVE REGISTERS.
         IHBINNRA &MF(2)
         AIF   (&A1 EQ 128).C16
         MVI   2(1),&A1            SET OPTION FLAGS.
.C16     AIF   ('&TCB' EQ '''S''').C17
         NI    2(1),X'BF'          SPECIFY CURRENT TCB.
.C17     AIF   (&A2 EQ 0).C14
         MVI   3(1),&A2            SET OPTION FLAGS.
.C14     AIF   (NOT &B1).C19
         AIF   ('&TCB'(1,1) EQ '(').C20
         L     0,&TCB              GET TCB ADDRESS.
         ST    0,8(0,1)            STORE INTO PARAMETER LIST.
         AGO   .C19
.C20     ST    &TCB(1),8(0,1)      STORE TCB ADDRESS.
.C19     AIF   ('&ID' EQ '').C21
         AIF   ('&ID'(1,1) EQ '(').C22
         AIF   ('&MF' EQ 'I').C21
         MVI   0(1),&ID            STORE ID NUMBER.
         AGO   .C21
.C22     STC   &ID(1),0(0,1)       STORE ID NUMBER.
.C21     AIF   (NOT &B5).C23
&A1      SETA  0
         AIF   ('&MF' EQ 'I').C24
         LA    0,16(0,1)           GET ADDRESS OF SNAPSHOT LIST.
         ST    0,12(0,1)           STORE IN PARAMETER LIST.
.C24     AIF   (&A1 GE N'&STORAGE).C25
&A1      SETA  &A1+1
&A2      SETA  12+4*&A1
         AIF   ('&STORAGE(&A1)' EQ '').C24
         AIF   ('&STORAGE(&A1)'(1,1) EQ '(').C26
         AIF   ('&MF' EQ 'I').C24
         LA    0,&STORAGE(&A1)     GET STARTING/ENDING ADDRESS.
         ST    0,&A2.(0,1)         STORE STARTING/ENDING ADDRESS.
         AGO   .C24
.C26     ST    &STORAGE(&A1),&A2.(0,1)   STORE STARTING/ENDING ADDRESS.
         AGO   .C24
.C25     AIF   ('&MF' EQ 'I' AND '&STORAGE(&A1)'(1,1) NE '(').C27
         MVI   &A2.(1),X'80'       SET END OF LIST INDICATOR.
         AGO   .C27
.C23     AIF   ('&LIST' EQ '').C27
         AIF   ('&LIST'(1,1) EQ '(').C28
         AIF   ('&MF' EQ 'I').C27
         LA    0,&LIST             GET ADDRESS OF SNAPSHOT LIST.
         ST    0,12(0,1)           STORE IN PARAMETER LIST.
         AGO   .C27
.C28     ST    &LIST(1),12(0,1)    STORE LIST ADDRESS IN PARM LIST.
.C27     CNOP  0,4
         B     *+8                 BRANCH ROUND BALR ADDRESS.
         DC    A(TSGSNAP)          ENTRY POINT ADDRESS.
         L     15,*-4              SET GR15 -> ENTRY ADDRESS.
         BALR  14,15               GO TO SNAP ROUTINE.
         LM    14,1,28(13)         RESTORE REGISTERS.
.C13     AIF   (&GSNAPSW).EXIT
TSGSNAP  CSECT
         STM   14,1,12(13)         SAVE REGISTERS.
         TM    TSGSNAPA+48-TSGSNAP(15),X'10' IS SNAPOUT OPEN ?
         BO    &GNAME.A-TSGSNAP(15) IF SO THEN GO TO SNAP.
         LA    1,&GNAME.B-TSGSNAP(15) SET GR1 -> L-FORM OPEN.
         SVC   19                  ISSUE OPEN SVC.
         L     1,24(0,13)          RESTORE GR1.
&GNAME.A SVC   51                  ISSUE SNAP SVC.
         L     14,12(0,13)         RESTORE GR14.
         BR    14                  RETURN.
&GNAME.B DC    0F'0',AL1(143),AL3(TSGSNAPA)
TSGSNAPA DC    4F'0',A(0,1),H'0',X'40',A(1,1),X'54',0A(0),CL8'SNAPOUT'
         DC    X'02000020',A(1,1,882,0,1,1),A(1,125,1)
&SYSECT  CSECT
&GSNAPSW SETB  1
.EXIT    MEXIT
.E1      IHBERMAC 189
         MEXIT
.E2      IHBERMAC 35,,&MF
         MEND
./        REPL  LIST=ALL,SSI=00200500,NAME=FINDUCB
./       NUMBER NEW1=0,INCR=20000
         MACRO
&NAME    FINDUCB &DEV=,&DEVADDR=,&TO=,&VALID=NO
.* PARAMETERS FOR THIS MACRO ARE...
.*       DEV=  A 3 CHARACTER UNIT NAME - THIS IS AN ALTERNATIVE TO
.*             USING DEVADDR=.....
.*       DEVADDR=  THE ADDRESS OF A 3 CHARACTER UNIT NAME
.*             (NOTE THAT IF REGISTER NOTATION IS USED IT IS NECESSARY
.*             TO GIVE BASE AND DISPLACEMENT E.G. DEVADDR=0(5)  )
.*             A NORMAL  EXAMPLE WOULD BE DEVADDR=UNIT WHERE THE
.*             FIELD LABELLED 'UNIT' CONTAINS E.G. C'134'
.*       TO=  SPECIFY A REGISTER OR A FULLWORD IN WHICH THE UCB
.*             ADDRESS WILL BE RETURNED TO YOU IF THE UCB IS FOUND.
.*       VALID=YES  THIS SPECIFIES THAT THE 3 CHARACTER UNIT NAME AT
.*             UCB + 13 WILL BE COMPARED WITH THE UNIT NAME GIVEN.
.*
.*             IF VALID IS USED YOU MAY FOLLOW THE MACRO BY A BRANCH
.*             INSTRUCTION OF YOUR OWN WHICH WILL BE DEPENDENT ON THE
.*             RESULT OF THE CLC BETWEEN THE UNIT NAMES (E.G. YOU COULD
.*             FOLLOW THE MACRO BY 'BNE NOUCB')
.*
.*
         LCLB  &B
          LCLC &GNAME,&C,&D        CHARACTER VARIABLES.
         AIF   ('&DEV&DEVADDR' EQ '').E1
&B       SETB  ('&DEV' NE '')
         AIF   (&B AND '&DEVADDR' NE '').E2
&NAME    IHBINNRA &DEVADDR
&GNAME   SETC  'IHB'.'&SYSNDX'
         AIF   (&B).C1
          AIF  ('&DEVADDR'(1,1) NE '(').C19
&D        SETC '0'                 SET D FOR REGISTER SPECIFICATION.
.C19      ANOP
         LA    0,3(0,0)      SET COUNT FOR LOOP.
         IC    15,0(0,1)     SET GR15 = CHARACTER.
         CLI   0(1),X'F0'    IS CHARACTER NUMERIC ?
         BNL   *+8           IF SO THEN USE.
         LA    15,9(0,15)    INCREMENT FOR HEX.
         SLL   15,8          SHIFT FOR NEXT CHARACTER.
         LA    1,1(0,1)      INCREMENT GR1 FOR NEXT CHARAATER.
         BCT   0,*-24        LOOP UNTIL COUNT EXHAUSTED.
         N     15,&GNAME     CLEAR EXTRANEOUS BITS.
.C1      L     1,16(0,0)     SET GR1 -> CVT.
         L     0,40(0,1)     SET GR0 -> IECILK2
         L     1,36(0,1)     SET GR1 -> IECILK2.
         AIF   (&B).C4
         SR    14,14         SET GR14 = 0.
         SLDL  14,8          SET GR14 = CHANNEL.
         AGO   .C5
.C4      ANOP
&C       SETC  '&DEV'(1,1)
         LA    14,X'&C'      SET GR14 = CHANNEL NUMBER.
.C5      IC    14,0(1,14)    SET GR14 = CHANNEL CONSTANT.
         AR    1,14          SET GR1 FOR CONTROL UNIT ADD.
         AIF   (&B).C6
         SR    14,14         SET GR14 = 0.
         SLDL  14,8          SET GR14 = CONTROL UNIT NUMBER.
         AGO   .C7
.C6      ANOP
&C       SETC  '&DEV'(2,1)
         LA    14,X'&C'      SET GR14 = CONTROL UNIT NUMBER.
.C7      IC    14,0(1,14)    SET GR14 = OFFSET IN IECILK2 FOR CU.
         AR    14,14         SET GR14 = OFFSET IN IECILK2 FOR CU.
         AR    0,14          SET GR0 -> FIRST ENTRY FOR CU IN IECILK2.
         AIF   (&B).C8
         SR    14,14         SET GR14 = 0.
         SLDL  14,8          SET GR14 = UNIT NUMBER.
         AGO   .C9
.C8      ANOP
&C       SETC  '&DEV'(3,1)
         LA    14,X'&C'      SET GR14 = UNIT NUMBER.
.C9      AR    14,14         SET GR14 FOR ADD.
         AR    14,0          SET GR14 -> UCB POINTER IN IECILK2.
         AIF   ('&TO' EQ '').C10
         AIF   ('&TO'(1,1) EQ '(').C11
         LH    1,0(0,14)     SET GR1 -> UCB.
         ST    1,&TO         STORE ADDRESS IN USER FIELD.
         AGO   .C12
.C10     LH    1,0(0,14)     SET GR1 -> UCB.
         AGO   .C12
.C11     LH    &TO(1),0(0,14)   LOAD USER REG. WITH UCB ADDRESS.
.C12     AIF   (&B AND '&VALID' EQ 'NO').EXIT
         AIF   ('&VALID' EQ 'NO').C13
         SR    15,15         SET RETURN CODE OF ZERO.
         AIF   ('&TO' EQ '').C14
         AIF   ('&TO'(1,1) NE '(').C14
         AIF   ('&TO' EQ '(0)').C15
         AIF   (&B).C16
          CLC  13(3,&TO(1)),&D&DEVADDR  COMPARE UNIT NAME WITH SPEC'D.
         AGO   .C17
.C16     CLC   13(3,&TO(1)),&GNAME COMPARE UNIT NAME WITH SPEC'D.
         AGO   .C17
.C15     LR    1,0           SET GR1 -> UCB.
.C14     AIF   (&B).C18
          CLC  13(3,1),&D&DEVADDR       COMPARE UNIT NAME WITH SPEC'D.
         AGO   .C17
.C18     CLC   13(3,1),&GNAME        COMPARE UNIT NAME WITH SPEC'D.
.C17     BE    *+8           IF EQUAL THEN USE ZERO RETURN CODE.
         LA    15,4(0,0)     SET RETURN CODE OF 4.
         AIF   (NOT &B).C13
         B     *+8           BRANCH AROUND CONSTANT.
&GNAME   DC    CL4'&DEV'
         MEXIT
.C13     ANOP
         CNOP  0,4           FORCE ALIGNMENT.
         B     *+8           BRANCH AROUND CONSTANT.
&GNAME   DC    X'0F0F0F00'
.EXIT    MEXIT
.E1      MNOTE 12,'***  IHB004  REQUIRED OPERAND(S) NOT SPECIFIED'
         MEXIT
.E2      MNOTE 12,'***  IHB018  BOTH DEV AND DEVADDR OPERANDS SPECIFIED*
               .'
         MEND
./        REPL  LIST=ALL,SSI=00200500,NAME=SPMODE
./       NUMBER  NEW1=10,INCR=10
         MACRO
&N       SPMODE &MODE,&PK,&MF=I
         GBLB  &GSPMDSW
         LCLA  &A
         LCLC  &GN
.*
.*  THE SPMODE MACRO ALLOWS USERS TO CONTROL BOTH THE MODE (PROBLEM OR
.*  SUPERVISOR) AND THE PROTECTION KEY (ZERO OR USER TASK) UNDER WHICH
.*  THEIR TASK WILL RUN.
.*
.*  TO DO THIS IT USES SVC 54, WHICH ISAM USES TO ENTER ITS PRIVILEGED
.*  MACRO TIME ROUTINES.  SPMODE WILL FUNCTION IN ANY SYSTEM IN WHICH
.*  ISAM WAS SPECIFIED AT SYSGEN.
.*
.*  TWO PARAMETERS ARE REQUIRED - THE FIRST SPECIFIES THE MODE AS
.*  'PROB' OR 'SUPV' ('PROB' IS THE DEFAULT), THE SECOND SPECIFIES THE
.*  PROTECTION KEY AS '0' OR '*' ('*' IS THE DEFAULT AND MEANS USE THE
.*  KEY FROM THE TCB).
.*
.*  EXAMPLES OF USE...
.*       SPMODE  PROB,0      GIVES USER ZERO PROTECT KEY.
.*       SPMODE  PROB,*      REVERT TO NORMAL USER PROTECT KEY
.*       SPMODE  SUPV,0      ALLOWS PRIVILEGED OPERATIONS WITH ZERO KEY
.*
.*
.*  THIS MACRO WAS UPDATED TO BE COMPATIBLE WITH REL 20 ON 9 SEP 71
.*  BY RALPH HOLLINS - CHANGED CARDS MARKED 'R20' IN COL 68.
.*
.*  FOR REL 20 SVC 54 REQUIRES REG 1 TO POINT TO THE ISAM DCB AS WELL
.*  AS HAVING REG 2 POINTING TO THE DECB..  REL 20 SVC 54 ALSO HAS
.*  ADDED CODE WHICH UPDATES FIELDS IN THE DCB IF THE MACRF DOES NOT
.*  INDICATE QISAM SCAN MODE WITH DISP = SHR.  WE FORCE THE PATH
.*  THROUGH SVC 54 BY SETTING DCB + 42 = X'00' AND MAKING DCB + 232
.*  POINT TO AN ADDRESS WITH A ZERO BYTE AT ADDRESS + 60.
.*
.*  WE ALSO HAVE TO CHANGE THE REGISTER FOR COMMUNICATING THE 'TYPE OF
.*  OPERATION' REQUESTED BY USER FROM REG 1 TO REG 5 ($SPMODE CSECT
.*  USES REG 3 AND SVC 54 USES REG 4), AND SO WE HAVE TO SAVE REGS
.*  14,5 THROUGH THE WHOLE MACR
.*
.*
         AIF   ('&MF' EQ 'L').LROUT
         AIF   ('&MODE' EQ 'PROB').C1
         AIF   ('&MODE' NE 'SUPV').E1
&A       SETA  8
.C1      AIF   ('&PK' EQ '*').C2
         AIF   ('&PK' NE '0').E2
&A       SETA  &A+4
.C2      ANOP
&N       STM   14,5,12(13) .                                       R20
         AIF   ('&MF' EQ 'I').C3
         AIF   ('&MF(1)' EQ 'E' AND N'&MF EQ 2).C4
         MNOTE 4,'INVALID MF IGNORED'
.C3      CNOP  0,4
         BAL   15,*+8              BRANCH AROUND CONSTANT.
         DC    V($SPMODE)          ADDRESS OF SUPVR MODE ROUTINE.
         L     15,0(0,15)          SET GR15 -> SUPVR MODE ROUTINE.
         AGO   .C5
.C4      AIF   ('&MF(2)'(1,1) EQ '(').C6
         L     15,&MF(2)           SET GR15 -> SUPVR MODE ROUTINE.
         AGO   .C5
.C6      LR    15,&MF(2)           SET GR15 -> SUPVR MODE ROUTINE.
.C5      AIF   (&A EQ 0).C7
         LA    5,&A.(0,0) .            SET R5 = MODE CODE          R20
         AGO   .C8
.C7      SR    5,5 .                   SET R5 = MODE CODE          R20
.C8      BALR  14,15               LINK TO SUPVR MODE ROUTINE.
         LM    14,5,12(13) .           RESTORE REGISTERS           R20
         AIF   (&GSPMDSW).EXIT
&GSPMDSW SETB  1
$SPMODE  CSECT
&GN      SETC  'IHB'.'&SYSNDX'
         LA    2,&GN.A-8-$SPMODE(15)    SET GR2 -> PSEUDO DECB.
         LR    1,15 .                                              R20
         S     1,&GN.E-$SPMODE(15)   . SET R1 = PSEUDO DCB ADD     R20
         SVC   54                  ISSUE DISABLE SVC.
         BR    14                  RETURN.
&GN.B    LPSW  &GN.C-*(12)         FORCE PROTECT KEY ZERO TO RESET RB.
         L     2,16(0,0)           SET GR2 -> CVT.
         L     2,0(0,2)            SET GR2 -> TCB POINTERS.
         L     3,4(0,2)            SET GR3 -> CURRENT TCB.
         L     2,0(0,3)            SET GR2 -> CURRENT REQUEST BLOCK.
         L     2,28(0,2)           SET GR2 -> PREVIOUS REQUEST BLOCK.
         MVZ   17(1,2),28(3)       STORE PROTECT KEY IN PSW IN PRB.
         OI    17(2),X'01'         SET PROBLEM PROGRAM MODE IN PSW IN P
         EX    0,&GN.D-&GN.B(12,5)      .                          R20
         BR    13                  RETURN.
&GN.A    DC    2A(*-40),A(&GN.B)
&GN.D    OI    17(2),X'01'         SET P/P MODE WITH USER KEY.
         NI    17(2),X'0F'         SET P/P MODE WITH ZERO KEY.
         NI    17(2),X'FE'         SET SUP MODE WITH USER KEY.
         NI    17(2),X'0E'         SET SUP MODE WITH ZERO KEY.
&GN.C    DC    0D'0',X'FF040000',A(&GN.B+4)  PSW FOR RESET RB.
&GN.E    DC    F'40' .                                             R20
         ORG   &GN.E+60   .                                        R20
         DC    X'00' .                                             R20
         ORG   $SPMODE+232-40   .                                  R20
         DC    A(&GN.E) .                                          R20
&SYSECT  CSECT
.EXIT    MEXIT
.E1      MNOTE *,'INVALID MODE SPECIFICATION - ''PROB'' ASSUMED'
         AGO   .C1
.E2      MNOTE *,'INVALID PROTECT KEY SPECIFICATION - ''*'' ASSUMED'
         AGO   .C2
.LROUT   ANOP
&N       DC    V($SPMODE)          ADDRESS OF SUPVR MODE ROUTINE.
         MEXIT
         MEND
./        REPL  LIST=ALL,SSI=00200500,NAME=DATE
./       NUMBER NEW1=0,INCR=20000
         MACRO
&NAME    DATE  &TO,&FORMAT='YYDDD',&PREFORM=NO,&FROM='S'
         GBLC  &GSS(5)
         LCLA  &A(6),&A1,&A2,&A3,&A4,&A5,&A6
         LCLB  &B1,&B2
         LCLC  &GNAME,&C1,&C2,&C3,&C4
.*
.*
.*  THE DATE MACRO-INSTRUCTION ENABLES THE PROGRAMMER TO EDIT A PACKED
.* DECIMAL DATE IN THE FORM 'YYDDD+' TO HIS OWN SPECIFICATIONS.
.*
.*  THE PARAMETERS ARE GIVEN AS FOLLOWS  :
.*
.*  TO         THE ADDRESS OF THE FIRST BYTE OF THE AREA THAT IS TO
.*             CONTAIN THE EDITED DATE.
.*
.*  FORMAT     SPECIFIES A CHARACTER STRING WHICH IS SCANNED BY THE
.*             MACRO-INSTRUCTION FOR THE FOLLOWING IDENTIFIERS WHICH
.*             ARE REPLACED AS SHEWN  :
.*
.*             YYDDD               YEAR NUMBER AND DAY NUMBER.
.*             MMM                 MONTH IN CHARACTER FORM (JAN-DEC).
.*             DDD                 DAY NUMBER.
.*             YY                  YEAR NUMBER.
.*             MM                  MONTH NUMBER (01=JAN  12=DEC)
.*             DD                  DAY OF THE MONTH.
.*
.*             IF THIS PARAMETER IS OMITTED 'YYDDD' IS ASSUMED.
.*       THE REMAINDER OF THE LIST IS TREATED AS SPECIFIED IN THE
.* 'PREFORM' PARAMETER. NOTE THAT THE 'FORMAT' PARAMETER MUST ALWAYS
.* BE ENCLOSED WITHIN QUOTES.
.*
.*  PREFORM    SPECIFIES THE TREATMENT OF THE PARTS OF THE FORMAT LIST
.*             THAT ARE NOT IDENTIFIERS.
.*             'PREFORM=NO' SPECIFIES THAT NON-IDENTIFIER PARTS OF THE
.*             FORMAT LIST ARE TO BE STORED IN THE TO-AREA AS LITERALS.
.*             'PREFORM=YES' SPECIFIES THAT NON-IDENTIFIER PARTS OF THE
.*             FORMAT LIST ARE TO BE IGNORED.
.*             IF THIS PARAMETER IS OMITTED 'NO' IS ASSUMED.
.*
.*  FROM       SPECIFIES THE ADDRESS OF A 3 BYTE PACKED DECIMAL FIELD
.*             CONTAINING THE DATE THAT IS TO BE EDITED OR 'S' WHICH
.*             SPECIFIES THAT THE CURRENT MACHINE DATE IS TO BE USED.
.*             IF THIS PARAMETER IS OMITTED 'S' IS ASSUMED.
.*
.*
&NAME    DS    0H                  FORCE ALIGNMENT.
&GNAME   SETC  'IHB'.'&SYSNDX'
         AIF   ('&TO' EQ '').E1
         TSGINNRA  &TO
         AIF   ('&GSS(5)' EQ '').C1
&C1      SETC  '('
&C2      SETC  ')'
&C3      SETC  ','
.C1      ANOP
&A(1)    SETA  0
&A(2)    SETA  0                   MMM POINTER
&A(3)    SETA  0                   DDD POINTER
&A(4)    SETA  0                   YY POINTER.
&A(5)    SETA  0                   MM POINTER.
&A(6)    SETA  0                   DD POINTER.
&A1      SETA  2                   START OF FIELD.
&A2      SETA  2                   START OF CHARACTER FIELD.
&A3      SETA  0                   LITERAL COUNT.
&A4      SETA  K'&FORMAT-1         END COUNT INDICATOR.
.C2      AIF   (&A1+1 GT &A4).C3   NO SPACE FOR YY/MM/DD.
         AIF   (&A1+2 GT &A4).C4   NO SPACE FOR MMM/DDD.
         AIF   (&A1+4 GT &A4).C5   NO SPACE FOR YYDDD.
&A5      SETA  1                   FIELD TYPE INDICATOR.
&A6      SETA  5                   SET COUNT FOR INCREMENT.
         AIF   ('&FORMAT'(&A1,5) EQ 'YYDDD').C6
.C5      ANOP
&A5      SETA  2                   FIELD TYPE INDICATOR.
&A6      SETA  3                   SET COUNT FOR INCREMENT.
         AIF   ('&FORMAT'(&A1,3) EQ 'MMM').C6
&A5      SETA  3                   FIELD TYPE INDICATOR.
         AIF   ('&FORMAT'(&A1,3) EQ 'DDD').C6
.C4      ANOP
&A5      SETA  4                   FIELD TYPE INDICATOR.
&A6      SETA  2                   SET COUNT FOR INCREMENT,
.C7      AIF   ('&FORMAT'(&A1,2) EQ 'YYMMDD'((&A5-4)*2+1,2)).C6
&A5      SETA  &A5+1               INCREMENT FIELD TYPE INDICATOR.
         AIF   (&A5 LT 7).C7       LOOP UNTIL FOUND OR EXHAUSTED.
.C8      ANOP
&A1      SETA  &A1+1               INCREMENT FIELD COUNT.
         AGO .C2
.C6      AIF   (&A(&A5) NE 0).C8   IS ALREADY FOUND.
&A(&A5)  SETA  &A1-1               SET OFFSET ADDRESS.
.C13     ANOP
&A5      SETA  &A1-&A2             LENGTH OF REQUIRED LITERAL.
&A1      SETA  &A1+&A6             START OF NEXT AREA.
&A6      SETA  &A2-2               OFFSET IN TARGET AREA.
         AIF   (&A5 EQ 0 OR '&PREFORM' EQ 'YES').C9
         AIF   (&A5 EQ 1).C10      MVI REQUIRED.
&B2      SETB  1                   LITERALS PRESENT.
         AIF   (&B1).C11           SECOND ENTRY.
         MVC   &GSS(1)&GSS(2)&GSS(3)+&A6.(&A5&GSS(4)&GSS(5)),&GNAME.A+&*
               A3                  MOVE LITERAL.
&A3      SETA  &A3+&A5             UPDATE LITERAL COUNT.
.C9      AIF   (&A1 GT &A4).CX     END OF SCAN.
&A2      SETA  &A1                 RESTORE START OF CHARACTER FIELD.
         AGO   .C2
.C10     AIF   (&B1).C9
&C4      SETC  '&FORMAT'(&A2,1)
   MVI   &GSS(1)&GSS(2)&GSS(3)+&A6&C1&GSS(5)&C2,C'&C4'  MOVE LITERAL.
         AGO   .C9
.C11     AIF   (&A3 NE 0).C12      NOT FIRST TIME.
&GNAME.A DS    0C                  ORIGIN OF LITERALS.
.C12     AIF   (&A5 LE 8).C14
&C4      SETC  '&FORMAT'(&A2,8)
         DC    CL8'&C4'
&A2      SETA  &A2+8
&A5      SETA  &A5-8
         AGO   .C12
.C14     ANOP
&C4      SETC  '&FORMAT'(&A2,&A5)
         DC    CL&A5'&C4'
&A3      SETA  1                   INDICATE NOT FIRST.
         AGO   .C9
.C3      ANOP
&A1      SETA  &A4                 SET END INDICATOR.
         AGO   .C13
.CX      AIF   (&B1).B1            IF SECOND ENTRY GO TO FLDS.
.*
.*       END OF FORMAT SCAN - NOW TO GENERATE INSTRUCTIONS.
.*
         AIF   (&A(1)+&A(2)+&A(3)+&A(4)+&A(5)+&A(6) EQ 0).AX
         AIF   ('&FROM' NE '''S''').A1   NOT CVTDATA.
         L     1,16(0,0)           SET GR1 -> CVT.
&A1      SETA  57                  OFFSET WITHIN CVT.
         AGO   .A2
.A1      IHBINNRA  &FROM           SET GR1 -> DATE FIELD.
&A1      SETA  0                   OFFSET FIELD.
.A2      AIF   (&A(1) EQ 0).A3     YYDDD NOT REQUIRED.
&A2      SETA  &A(1)-1             OFFSET OF YYDDD FIELD.
         UNPK  &GSS(1)&GSS(2)&GSS(3)+&A2.(5&GSS(4)&GSS(5)),&A1.(3,1)   *
                                   SET YYDDD.
&A2      SETA  &A2+4               SET OFFSET FOR OR IMMEDIATE.
         OI    &GSS(1)&GSS(2)&GSS(3)+&A2&C1&GSS(5)&C2,X'F0' REMOVE ZONE
         AIF   (&A(4) EQ 0).A4     YY NOT REQUIRED.
&A2      SETA  &A(4)-1             OFFSET OF YY ENTRY.
&A3      SETA  &A(1)-1             OFFSET OF YYDDD ENTRY.
         MVC   &GSS(1)&GSS(2)&GSS(3)+&A2.(2&GSS(4)&GSS(5)),&GSS(1)&GSS(*
               2)&GSS(3)+&A3&C1&GSS(5)&C2  SET YY.
.A4      AIF   (&A(3) EQ 0).A5     DDD NOT REQUIRED.
&A2      SETA  &A(3)-1             OFFSET OF DDD.
&A3      SETA  &A(1)+1             OFFSET OF DDD IN YYDDD ENTRY.
         MVC   &GSS(1)&GSS(2)&GSS(3)+&A2.(3&GSS(4)&GSS(5)),&GSS(1)&GSS(*
               2)&GSS(3)+&A3&C1&GSS(5)&C2   SET DDD.
.A5      AIF   (&A(2)+&A(5)+&A(6) EQ 0).AX
.A3      AIF   (NOT(&A(4) NE 0 AND &A(1) EQ 0) AND &A(2)+&A(5)+&A(6) EQ*
                0).A6
         MVO   &GNAME.B+6(2),&A1.(1,1) MOVE YEAR NO. TO WORK AREA.
         AIF   (NOT(&A(4) NE 0 AND &A(1) EQ 0)).A7
         OI    &GNAME.B+7,X'0F'    REMOVE ZONE.
&A2      SETA  &A(4)-1             OFFSET OF YY ENTRY.
         UNPK  &GSS(1)&GSS(2)&GSS(3)+&A2.(2&GSS(4)&GSS(5)),&GNAME.B+6(2*
               )                   SET YY.
.A7      AIF   (&A(2)+&A(5)+&A(6) EQ 0).A6
         CVB   0,&GNAME.B          SET GR0 = YY.
.A6      AIF   (NOT(&A(3) NE 0 AND &A(1) EQ 0) AND &A(2)+&A(5)+&A(6) EQ*
                0).AX
&A2      SETA  &A(3)-1
&A1      SETA  &A1+1
         AIF   (&A(2)+&A(5)+&A(6) NE 0).A8
         UNPK  &GSS(1)&GSS(2)&GSS(3)+&A2.(3&GSS(4)&GSS(5)),&A1.(2,1)
&A2      SETA  &A2+2
         OI    &GSS(1)&GSS(2)&GSS(3)+&A2&C1&GSS(5)&C2,X'F0' REMOVE ZONE
         AGO   .AX
.A8      MVC   &GNAME.B+6(2),&A1.(1)   MOVE DDD TO WORK AREA.
         AIF   (NOT(&A(3) NE 0 AND &A(1) EQ 0)).A9
         OI    &GNAME.B+7,X'0F'    REMOVE ZONE.
         UNPK  &GSS(1)&GSS(2)&GSS(3)+&A2.(3&GSS(4)&GSS(5)),&GNAME.B+6(2*
               )                   STORE DDD.
.A9      AIF   (&A(2)+&A(5)+&A(6) EQ 0).AX
         LR    1,0                 SET GR1 = YEAR NUMBER.
         CVB   0,&GNAME.B          SET GR0 = DAY NUMBER.
         MVI   &GNAME.C+10,28      SET FEBRUARY = 28 DAYS.
         EX    1,&GNAME.D          TEST FOR LEAP YEAR.
         BNZ   *+8                 IF NOT THEN GO TO FIND DD/MM/MMM.
         MVI   &GNAME.C+10,29      SET FEBRUARY = 29 DAYS.
         LA    1,&GNAME.C+11       SET GR1 -> JANUARY ENTRY.
         SR    15,15               SET GR15 = 0.
         IC    15,0(1,0)           SET GR15 = DAYS / MONTH.
         SR    0,15                DECREMENT DAY NUMBER.
         BNP   *+8                 IF NOT PLUS THEN MONTH FOUND.
         BCT   1,*-10              LOOP UNTIL FOUND.
         AIF   (&A(6) EQ 0).A10    DD NOT REQUIRED.
         AR    0,15                RESTORE DD.
         CVD   0,&GNAME.B          STORE DD IN WORK AREA.
         OI    &GNAME.B+7,X'0F'    REMOVE ZONE.
&A2      SETA  &A(6)-1             OFFSET OF DD.
         UNPK  &GSS(1)&GSS(2)&GSS(3)+&A2.(2&GSS(4)&GSS(5)),&GNAME.B+6(2*
               )                   SET DD.
         AIF   (&A(2)+&A(5) EQ 0).AX
.A10     LA    0,&GNAME.C+12       SET GR0 FOR SUBTRACT.
         SR    0,1                 SET GR0 = MONTH NUMBER.
         AIF   (&A(5) EQ 0).A11    MM NOT REQUIRED.
         CVD   0,&GNAME.B          MOVE MM TO WORK AREA.
         OI    &GNAME.B+7,X'0F'    REMOVE ZONE.
&A2      SETA  &A(5)-1             OFFSET OF MM ENTRY.
         UNPK  &GSS(1)&GSS(2)&GSS(3)+&A2.(2&GSS(4)&GSS(5)),&GNAME.B+6(2*
               )                   SET MM.
         AIF   (&A(2) EQ 0).AX     MMM NOT REQUIRED.
.A11     LR    1,0                 SET GR1 = MM.
         AR    1,0                 SET GR1 = MM * I.
         AR    1,0                 SET GR1 = MM * 3.
         LA    1,&GNAME.E-3(1)     SET GR1 -> REQUIRED CHAR FLD.
&A2      SETA  &A(2)-1             OFFSET OF MMM ENTRY.
         MVC   &GSS(1)&GSS(2)&GSS(3)+&A2.(3&GSS(4)&GSS(5)),0(1) SET MMM
.AX AIF (NOT(&B2 OR &A(2)+&A(5)+&A(6) NE 0 OR(&A(1) EQ 0 AND &A(4) NE 0*
               ))).END
         B     &GNAME.F
.*
.*       END OF INSTRUCTION GENERATION-NOW GENERATE CONSTANTS.
.*
  AIF (NOT(&A(2)+&A(5)+&A(6) NE 0 OR (&A(1) EQ 0 AND &A(4) NE 0))).B2
         DS    0D
         AIF   (&A(2)+&A(5)+&A(6) EQ 0).B2
&GNAME.B DC    PL8'0'
&GNAME.D TM    *+4,0               MODEL INSTRUCTION.
         DC    AL1(3)
&GNAME.C DC    AL1(31,30,31,30,31,31,30,31,30,31,28,31)
         AIF   (&A(2) EQ 0).B2
&GNAME.E DC    C'JANFEBMARAPRMAYJUNJULAUGSEPOCTNOVDEC'
.B2      AIF   (&B2 EQ 0).B1
&B1      SETB  1
         AGO   .C1
.B1      ANOP
&GNAME.F DS    0H
.END     MEXIT
.E1      MNOTE 12,'***  IHB004  REQUIRED OPERAND(S) NOT SPECIFIED'
         MEND
./        REPL  LIST=ALL,SSI=00200500,NAME=TSGINNRA
./       NUMBER NEW1=0,INCR=20000
         MACRO
         TSGINNRA  &P
         GBLC  &GSS(5)
         LCLA  &A
         AIF   ('&P'(K'&P,1) EQ ')').C1
&GSS(2)  SETC  '+'
&GSS(4)  SETC  ''
&GSS(5)  SETC  ''
.C4      AIF   (&A GE K'&P).C2
&A       SETA  &A+1
         AIF   ('&P'(&A,1) EQ '+').C3
         AGO   .C4
.C2      ANOP
&GSS(1)  SETC  '&P'
&GSS(3)  SETC  '0'
         MEXIT
.C3      ANOP
&GSS(1)  SETC  '&P'(1,&A-1)
&GSS(3)  SETC  '&P'(&A+1,K'&P-&A)
         MEXIT
.C1      ANOP
&GSS(1)  SETC  ''
&GSS(2)  SETC  ''
&GSS(3)  SETC  '0'
.C6      ANOP
&A       SETA  &A+1
         AIF   ('&P'(&A,1) EQ '(').C5
         AGO   .C6
.C5      AIF   (&A EQ 1).C7
&GSS(3)  SETC  '&P'(1,&A-1)
.C7      ANOP
&GSS(4)  SETC  ','
&GSS(5)  SETC  '&P'(&A+1,K'&P-&A-1)
         MEND
./        REPL  LIST=ALL,SSI=00200500,NAME=TSGINNRB
./       NUMBER NEW1=0,INCR=20000
         MACRO
&NAME    TSGINNRB &C,&P,&D,&MF=I   SET UP PARAMETER LIST.
         LCLC  &N
         LCLA  &A
&N       SETC  '&NAME'
.C3      AIF   (&A GE N'&C).END
&A       SETA  &A+1
         AIF   ('&P(&A)' EQ '').C1
         AIF   ('&P(&A)'(1,1) EQ '(').C2
         AIF   ('&P(&A)'(K'&P(&A),1) EQ ')').C2
&N       TSGINNRD &C(&A),&P(&A)
.C5      ANOP
&N       SETC  ''
         AGO   .C3
.C1      AIF   ('&D(&A)' EQ '').C4
&N       TSGINNRD &C(&A),&D(&A)
         AGO   .C5
.C2      AIF   ('&MF' EQ 'I').C4
         MNOTE 12,'***  IHB006  INVALID REGISTER NOTATION W/MF=L'
.C4      ANOP
&N       TSGINNRD &C(&A),0
         AGO   .C5
.END     MEND
./        REPL  LIST=ALL,SSI=00200500,NAME=TSGINNRC
./       NUMBER NEW1=0,INCR=20000
         MACRO
&NAME    TSGINNRC &L,&S,&P,&GR=1,&MF=I  STORE PARAMETER VALUES.
         LCLA  &A1,&A2
         LCLB  &B1,&B2,&B3,&B4
         LCLC  &C1
.C3      AIF   (&A1 GE N'&P).END
&A1      SETA  &A1+1
         AIF   ('&P(&A1)' EQ '').C5
         AIF   ('&P(&A1)'(1,1) EQ '(').C2
         AIF   ('&MF' EQ 'I').C1
.C4      L&L(&A1)   0,&P(&A1)      LOAD PARAMETER VALUE.
         ST&S(&A1)   0,&A2.(&GR,0) STORE PARAMETER VALUE.
         AGO   .C5
.C2      ANOP
&C1      SETC  '&P(&A1)'(2,K'&P(&A1)-2)
         ST&S(&A1)   &C1,&A2.(&GR,0) STORE PARAMETER VALUE.
         AGO   .C5
.C1      AIF   ('&P(&A1)'(K'&P(&A1),1) EQ ')').C4
.C5      ANOP
&C1      SETC  '&S(&A1)'
&B1      SETB  ('&C1' EQ 'C')
&B2      SETB  ('&C1' EQ 'H')
&B3      SETB  ('&C1' EQ 'E' OR '&C1' EQ '')
&B4      SETB  ('&C1' EQ 'D')
&A2      SETA  &A2+&B1+2*&B2+4*&B3+8*&B4
         AGO   .C3
.END     MEND
./        REPL  LIST=ALL,SSI=00200500,NAME=TSGINNRD
./       NUMBER NEW1=0,INCR=20000
         MACRO
&NAME    TSGINNRD   &C,&P
         LCLC  &T
&T       SETC  '&C'(1,1)
         AIF ('&T'EQ'A'OR'&T'EQ'Q'OR'&T'EQ'V'OR'&T'EQ'S'OR'&T'EQ'Y').C1
&NAME    DC    &C'&P'
         MEXIT
.C1      ANOP
&NAME    DC    &C.(&P)
.END     MEND
./        REPL  LIST=ALL,SSI=00200500,NAME=DCBEXITS
./       NUMBER NEW1=0,INCR=20000
         MACRO
&N       DCBEXITS   &OPN,&LIST=YES
         AIF   ('&LIST' EQ 'NO').C1
&N       DC    0F'0',X'85',AL3(*+3)     EXIT LIST.
         L     15,16(0,0)          SET GR15 -> CVT.
         AGO   .C2
.C1      ANOP
&N       L     15,16(0,0)          SET GR15 -> CVT.
.C2      L     15,0(15)            SET GR15 -> TCB POINTERS.
         L     15,4(15)      SET GR15 -> CURRENT TCB.
         L     15,0(15)      SET GR15 -> REQUEST BLOCK.
         L     15,28(15)     SET GR15 -> SVRB FOR IGG0190M
         L     15,104(15)    SET GR15 -> GOTTEN CORE.
         LH    0,202(15)     SET GR0 = USER SPECIFIED BLOCK SIZE.
         LTR   0,0           TEST FOR OVER-RIDE.
         AIF   ('&OPN' EQ 'OPEN').C3
         BCR   8,14          IF NONE THEN RETURN.
         AGO   .C4
.C3      BZ    *+8                 IF NONE THEN LEAVE.
.C4      STH   0,62(0,1)           STORE USER SPECIFIED BLOCK SIZE.
         AIF   ('&OPN' EQ 'OPEN').END
         BR    14            RETURN.
.END     MEND
./        REPL  LIST=ALL,SSI=00200500,NAME=DLINE
./       NUMBER NEW1=0,INCR=20000
         MACRO
&NAME    DLINE &HEX,&CHAR
         LCLC  &GNAME
         AIF   ('&CHAR' EQ '').C1
&GNAME   SETC  'IHB'.'&SYSNDX'
&NAME    DC    0H'0',AL2(&GNAME-*,0),X'&HEX',C&CHAR
&GNAME   DS    0C
         MEXIT
.C1      ANOP
&NAME    DC    H'5,0',X'&HEX'
         MEND
