RARARCIV  TITLE   'ARCHIVE COMMAND PROCESSOR'
***********************************************************************
*                                                                     *
* FUNCTION                                                            *
*           A TSO COMMAND TO SUPPORT NON-STANDARD FEATURES            *
*            1 - QUEUE ARCHIVE REQUESTS FOR DATASETS.                 *
*                                                                     *
*      COMMAND FORMAT:                                                *
*                                                                     *
*               ARCHIVE DATASETNAME/DSNAME('DSNAME')/                 *
*                       USERID('USER')/ALL                            *
*                       VOLUME/VOLSER('VOLSER')                       *
*                       SAVE/SCRATCH/RETURN('DSNAME')/TRACE/QUEUE     *
*                       ARCDATE('DATE')                               *
*                       KEY('KEY')                                    *
*                       FULL                                          *
*                                                                     *
*  MEANING OF KEYS:                                                   *
*                                                                     *
* 1). SAVE                                                            *
*     ARCHIVE THE DATASET. ONLY ONE ENTRY PER DSN ALLOWED.            *
* 2). SCRATCH                                                         *
*     DELETE THE QUEUE ENTRY.                                         *
* 3). RETURN                                                          *
*     RETURN THE DATASET. ONLY ONE ENTRY PER DSN ALLOWED              *
*     USES INDEX FOR DSN                                              *
* 4). TRACE                                                           *
*     EXAMINE THE TRACE LOG FILE                                      *
*  A) IF DA('DS') SPEC. FIND ALL ARCHIVES FOR THIS DS.                *
*  B) IF USERID('USERID')  FIND ALL DS HAVING FIRST QUALIFIER         *
*           WITH THIS USERID, OR REQUESTED BY THIS USER               *
*  C) IF NEITHER OF THE ABOVE, DEFAULT TO THE LOGGED ON USER          *
*    A,B & C USE INDEX FOR DSN, B & C ALSO USE INDEX FOR USERID/KEY   *
*    THESE CAN BE QUALIFIED BY                                        *
*  I) KEY('KEY')  FIND ALL ARCHIVED WITH THIS KEY                     *
*  J) ARCDATE(YY.DDD)  FIND ALL ARCHIVED WITH THIS DATE FOR           *
*  K) FULL  LIST ALL INFORMATION (FROM TRACE ONLY)                    *
* 5). QUEUE                                                           *
*     INSPECT THE QUEUE FILE                                          *
*     USE THE SAME CRITERIA AS FOR 4)                                 *
*                                                                     *
***********************************************************************
         EJECT
***********************************************************************
*                                                                     *
* ATTRIBUTES                                                          *
*           REENTRANT,REUSABLE                                        *
*                                                                     *
* INPUT                                                               *
*                                                                     *
*           COMMAND PROCESSOR PARAMETER LIST VIA REG1                 *
*           DATASET AS SPECIFIED.                                     *
*                                                                     *
* OUTPUT                                                              *
*                                                                     *
*           DATASET NAME & PSEUDO NAME FOR ARCHIVE DUMP LATER SAME    *
*           DAY, RECORD ALSO CONTAINS VOLUME ID WHERE DATASET         *
*           RESIDES.                                                  *
*                                                                     *
***********************************************************************
         EJECT
         MACRO
&LABEL   TUPL  &TU,&V=NO
&LABEL.  LA    R6,USER&TU.
         ST    R6,S99TUPTR
         MVC   S99TUNIT(&TU.L),&TU.
         AIF   ('&V' EQ 'NO').INCR
         MVI   S99TUPTR,S99TUPLN
         AGO   .END
.INCR    INCR  R3,4
.END     MEND
         MACRO
&LABEL   MSG   &TEXT
&LABEL.  DC    A(1,&LABEL.S)
&LABEL.S DC    AL2(&LABEL.L,0)
         DC    C&TEXT.
&LABEL.L EQU   *-&LABEL.S
         MEND
         MACRO
&LABEL   MSGV  &TEXT
&LABEL.  DC    AL2(&LABEL.L,0)
         DC    C&TEXT.
&LABEL.L EQU   *-&LABEL.
         MEND
         EJECT
*
* REGISTER DEFINITIONS.
*
         REGISTER
         EJECT
         SUBR  RARARCIV,RENT=YES,SP=100,LV=USERLEN
         L     R10,BASE2          ADDRESS OF SECOND HALF
         USING RARARCIV+4096,R10 SET UP CSECT.
         LR    R2,R1              GET COMMAND PROCESSOR LIST.
         USING CPPL,R2
         LR    R11,R0             GET WORK AREA ADDRESS.
         USING USERAREA,R11
         ST    R2,USERCPPL     SAVE CPPL ADDRESS FOR FAIL ROUTINES
         ZERO  USERAREA,X'90'     ZERO USERAREA.
         EJECT
*
* SET UP I/O PARAMETER LIST.
*
         LA    R8,USERIOPL
         USING IOPL,R8
         MVC   IOPLUPT,CPPLUPT
         MVC   IOPLECT,CPPLECT
         LA    R5,USERECB         OUR ECB (ZEROED EACH TIME USED).
         ST    R5,IOPLECB
         LA    R5,USERPTPB        POINTER TO PTPB.
         ST    R5,IOPLIOPB
         DROP  R8
*
* EXTRACT INFORMATION FROM PSCB.
*
         L     R4,CPPLPSCB        GET ADDRESS OF PROTECTED BLOCK.
         USING PSCB,R4
         MVC   USERUID,PSCBUSER   GET ACTUAL USERID.
         MVC   USERUIDL,PSCBUSRL  LENGTH OF THIS USERID
         DROP  R4
         MVC   USERUIDT,USERUID   CREATE A COPY
         ZR    R4                 CLEAR FOR IC
         IC    R4,USERUIDL        GET THE LENGTH
         LA    R4,USERUIDT(R4)    POINT BEYOND THE USERID
         MVI   0(R4),C'.'         INSERT A DOT
*
*        CHECK FOR RACF OPERATIONS ATTRIBUTE
*
         USING PSA,0
         L     R4,PSAANEW
         USING ASCB,R4
         L     R4,ASCBASXB
         USING ASXB,R4
         LT    R4,ASXBSENV
         BZ    NOTOPER             ONLY IF RACF INACTIVE
         USING ACEE,R4
         TM    ACEEFLG1,ACEEOPER   OPERATIONS ATTRIBUTE ?
         BZ    NOTOPER
         OI    USERFLG1,FLAGOPER   REMEMBER THIS FACT
         DROP  R4
NOTOPER  EQU   *
*
* INITILAISE PARSE PARAMETER LIST (PPL).
*
         LA    R4,USERPPL          AREA FOR PPL.
         USING PPL,R4
         MVC   PPLUPT,CPPLUPT        USER PROFILE TABLE
         MVC   PPLECT,CPPLECT
         LA    R5,USERECB            OUR ECB.
         ST    R5,PPLECB
         L     R5,=A(PCL)            PARAMETER CONTROL LIST
         ST    R5,PPLPCL
         LA    R5,USERANS            SPACE FOR ADDRESS OF PDL.
         ST    R5,PPLANS
         MVC   PPLCBUF,CPPLCBUF      COMMAND BUFFER ADDRESS.
         ST    R11,PPLUWA              GIVE VALIDCK ACCESS TO USERAREA
         DROP  R4,R2
         EJECT
*
* PARSE COMMAND
*
          CALLTSSR EP=IKJPARS,MF=(E,(4))
          MVI     USERECB,0            FINISHED WITH ECB.
          LTR     R15,R15
          BZ      PARSOK               OK, PARSE SUCCEEDED.
          CH      R15,=H'4'
          BE      FAIL                 NO MESSAGE FOR RC=4.
          CH      R15,=H'20'
          BE      FAIL                 OR RC=20.
          LA      R4,GFPARSE           IKJPARS FAILURE MASSAGE.
          B       GENFAIL
*
BASE2     DC      A(RARARCIV+4096)   *********BASE2************
*
PARSOK    EQU     *
          L       R4,USERANS
          USING   IKJPARMD,R4
          EJECT
*
* DETERMINE DSNAME ETC.
*
         BLANK USERDSN,44
         CLC   #DADD,#NONE
         BE    NODAUSER
         CLC   #DADD,#USER
         BE    SAIDUSER
         CLC   #DADD,#ALL
         BE    SAIDALL
         OI    USERFLG4,FLAGDSNF   FLAG FULL DSN SPECIFIED
         L     R3,#DSN             ADDRESS OF DSN
         LH    R5,#DSN+4           LENGTH OF IT.
         DECR  R5
         EX    R5,MOVEDSN          FETCH DSN.
         LA    R0,MSG21            "MEMBERNAME NOT ALLOWED".
         LT    R3,#DSN+8           FETCH POSSIBLE MEMBERNAME.
         BNZ   ERROR               ERROR !
         B     DONEDAUS
NODAUSER EQU   *
         LA    R0,MSG73
         CLC   #KEEP,#TRACE
         BE    IDINSERT
         CLC   #KEEP,#QUEUE
         BNE   ERROR
*
* DEFAULT TO USER(&SYSUID) FOR QUEUE AND TRACE SEARCHES
*                                 NOTE THIS IS NOT &SYSPREF
*
IDINSERT EQU   *
         MVC   USERUSER,USERUID   USERID
         MVC   USERDSN(8),USERUIDT USERID WITH TRAILING .
         MVC   USERULEN,USERUIDL  LENGTH OF USERID
         OI    USERFLG4,FLAGUID   FLAG FOR ONLY USERID
         B     DONEDAUS
SAIDUSER EQU   *
         OI    USERFLG4,FLAGUID    FLAG FOR ONLY USERID
         L     R3,#ID              GET ADDRESS OF USERID
         LH    R5,#ID+4
         STC   R5,USERULEN        SAVE LENGTH OF USERID
         LA    R6,USERDSN(R5)     BEYOND USERID
         MVI   0(R6),C'.'         INSERT A TRAILING .
         DECR  R5
         EX    R5,MOVEDSN         INSERT INTO DSN FIELD
         BLANK USERUSER,7
         EX    R5,MOVEUSER        AND BY ITSELF
         B     DONEDAUS
SAIDALL  EQU   *
         LA    R0,MSG74
         TM    USERFLG1,FLAGOPER   MUST BE OPERATIONS
         BZ    ERROR               IF NOT THEN ERROR
         LA    R0,MSG75
         CLC   #KEEP,#QUEUE        ALL ONLY VALID IF QUEUE INSPECT
         BNE   ERROR              IF NOT THEN ERROR
         OI    USERFLG4,FLAGALL    FLAG FOR ALL
DONEDAUS EQU   *
         EJECT
*
* DETERMINE VOLUME
*
         BLANK USERVOL,6
         CLC   #VOL,#VOLUME
         BNE   NOTVOL
         OI    USERFLG1,FLAGVOL
         L     R3,#VOLSER          FETCH ADDRESS OF VOL.
         LH    R5,#VOLSER+4        FETCH LENGTH.
         DECR  R5
         EX    R5,MOVEVOL      FETCH VOLUME (MVC USERVOL(0),0(R3))
NOTVOL   EQU     *
*
* DETERMINE FULL.
*
         CLC   #FULL,#FULPRES      WAS FULL TRACE INFORMATION REQUESTED
         BNE   NOTFULL             I.E. ALL STORED INFO FOR DS
         OI    USERFLG1,FLAGFULL
NOTFULL  EQU   *
         EJECT
*
*        DETERMINE KEY
*
         BLANK USERKEY,8
         CLC   #KEY,#KEYPRES
         BNE   NOTKEY
         L     R3,#KEYKEY
         OI    USERFLG4,FLAGKEY    FLAG KEY PRESENT
         LH    R5,#KEYKEY+4
         DECR  R5
         EX    R5,MOVEKEY
NOTKEY   EQU   *
*
* DETERMINE 'SAVE'/'SCRATCH'/'RETURN'/'TRACE'
*
          MVC     USERKEEP,#KEEP      TRANSFER 'KEEP' KEYWORD REPLY.
          CLC     USERKEEP,#RETURN    GET THE 'KEEP' CODE.
          BNE  NORETURN              NO.
*
* HERE WE DETERMINE THE RETURNED DSN.
*
         L     R3,#RTDSN          GET ADDRESS OF DSN.
         LHT   R5,#RTDSN+4        AND THE LENGTH.
         BZ    NORETURN           NO RETURNED DSN
         OI    USERFLG2,FLAGTDSN  MARK AS SEEN
         DECR  R5
         BLANK USERTDSN,44        CLEAR IT OUT.
         EX    R5,MOVETDSN        FETCH RETURN DSN.
*
* COMPARE THE RETURN DSN WITH THE SOURCE DSN, IF THEY ARE THE SAME
* TREAT AS IF NOT 'RETURN AS'.
*
         CLC   USERDSN,USERTDSN   COMPARE THE 2 DSN'S
         BNE   DIFDSN             THEY ARE DIFFERENT.
         NI    USERFLG2,X'FF'-FLAGTDSN TURN OFF MARKER AGAIN
DIFDSN   EQU   *
         LA    R0,MSG34           "CANNOT RETURN MEMBERS".
         LT    R3,#RTDSN+8        FETCH POSSIBLE MEMBER NAME.
         BNZ   ERROR              SEND A RUDE MESSAGE.
NORETURN EQU   *
         EJECT
*
*        DETERMINE THE DATE FIELD
*
         BLANK USERDATE,6
         CLC   #RTDATE,#DATPRES    IS DATE SPECIFIED
         BNE   NOTRTSW
         L     R3,#DATE            POINT TO DATE
         OI    USERFLG4,FLAGDATE   FLAG DATE SPECIFIED
         MVC   USERDATE(6),0(R3)  XFER DATE TO SAFE PLACE.
NOTRTSW  EQU   *
         EJECT
         IKJRLSA USERANS            RELEASE PARSE GETMAINS.
         DROP  R4
*
* SET UP SVC99 REQUEST BLOCK.
*
          LA      R1,USERRB
          ST      R1,USERRBP        SET UP REQUEST BLOCK (RB) POINTER.
          MVI     USERRBP,S99RBPND
          MVC     USERRB(S99RBLEN),RBCON    MOVE RB TO USER WORK AREA.
          USING   S99RB,R1
          LA      R3,USERTUPL
          ST      R3,S99TXTPP           STORE TUPL POINTER IN RB.
          DROP    R1
*
* SEE WHAT MODE WE ARE RUNNING IN
*
         CLC   USERKEEP,#TRACE     KEYWORD = TRACE ?
         BE    TRACEDS             YES, TRACE THE TRACE LOG.
         CLC   USERKEEP,#QUEUE     KEYWORD = QUEUE ?
         BE    QUEUEDS             YES, GO THERE.
         LA    R0,MSG23
         TM    USERFLG4,FLAGDSNF   MAKE SURE FULL DSN SPECIFIED
         BZ    ERROR               IF NOT THERE IS NOTHING TO DO
         CLC   USERKEEP,#RETURN    KEYWORD = RETURN ?
         BE    RETURNDS            YES, TRY & RETURN DS FROM TAPE.
         CLC   USERKEEP,#SCRATCH     KEYWORD = SCRATCH ?
         BE    GETARCH                YES BYPASS LOCATE/RACHECK
         EJECT
*
*        SAVE REQUESTS ONLY
*
* GET THE VOLID, EITHER FROM (A) VOLID GIVEN IN COMMAND LIST OR
* (B) VOLID GIVEN AT LOCATE TIME.
*
         TM    USERFLG1,FLAGVOL  DO WE ALREADY KNOW THE VOLSER
         BO    OKCARRY
         MVC   ULOCDSN(LOCLEN),LOCDSN TRANSFER PROTO-CAMLST.
         LA    R3,USERDSN        ADDRESS OF DSN.
         ST    R3,ULOCDSN+4      PUT DSN ADDR INTO CAMLST.
         LA    R3,LOCAREA        GET ADDRESS OF AREA.
         ST    R3,ULOCDSN+12     PUT INTO CAMLST.
         LOCATE ULOCDSN          TRY & LOCATE VOLID.
         LTR   R15,R15           NOT RETURN, IF ERROR, FAIL !
         BZ    NERRLOC
         LA    R0,MSG20       "CANNOT LOCATE VOLUME FOR THIS DSN."
         B     ERROR
NERRLOC  EQU   *
         MVC   USERVOL,LOCVOL    TRANSFER VOLID.
         OI    USERFLG1,FLAGVOL+FLAGLOC  WE NOW HAVE A VOLSER
OKCARRY  EQU   *
*
* HERE WE HAVE OUR INFO, DO A 'RACHECK' TO CHECK RACF AUTHORISATION.
*
         MVC   USERRACK(RALEN),RACHECK TRANSFER RACHECK LIST.
         RACHECK ENTITY=USERDSN,VOLSER=USERVOL,ATTR=READ,              +
               MF=(E,USERRACK)
         LTR   R15,R15        CHECK RETURN CODE.
         BZ    GETARCH
         LA    R0,MSG33       "RACF FAILURE FOR THIS DSN."
         B     ERROR
         EJECT
*
*        NOW SEARCH QUEUE FOR RECORD/END OF QUEUE
*        SAVE & SCRATCH REQUESTS COME TOGETHER HERE
*
GETARCH  EQU   *
         OI    USERFLG3,FLAGENQX   WANT QUEUE EXCLUSIVELY
         BAL   R14,INQUEUE        ALLOCATE, OPEN & READ QUEUE.
CHKLOOP  EQU   *
         BAL   R14,GETRECOR       GET A RECORD FROM I/P BUFFER.
         USING QUEUEMAP,R8
         TM    QACTION,FLAGDEL    IF THIS RECORD SCRATCHED
         BO    QENDFND            LOOK FOR ANOTHER ONE
         CLC   USERDSN,QDSN          COMPARE THE DATASET NAMES.
         BE    EQUALS             IF SAME , GOTO SPECIAL CODE.
* WE ONLY ALLOW ONE ENTRY PER DSN REGARDLESS OF REQUESTOR/DATE/KEY/VOL
*    AT PRESENT.
QENDFND  EQU   *
         TM    QEND,FLAGEND          TERMINATOR ?
         BZ    CHKLOOP            NO, GO BACK FOR MORE.
         CLC   USERKEEP,#SCRATCH     RECORD NOT FOUND...FAIL IF SCRATCH
         BNE   NOSCRAT            NO.
         LA    R0,MSG32          "RECORD NOT IN QUEUE."
         B     ERROR
NOSCRAT  EQU   *
*
*        ADD RECORD TO QUEUE
*
         BAL   R14,ADDQREC
         LA    R0,MSG29          "REQUEST QUEUED."
         BAL   R14,MESSAGE
         B     WRTQUEUE
         EJECT
*
*        PROCESS SCRATCH REQUESTS
*
* FIRST CHECK THAT USERID IS THE SAME AS THE REQUESTOR
*
EQUALS   EQU     *
         CLC   USERKEEP,#SCRATCH          SCRATCH ?
         BNE   OPER2
         CLC   USERUID,QUSERID    COMPARE USERIDS.
         BNE   NOTSAM           THE'RE DIFFERENT.
         OI    QACTION,FLAGDEL     SCRATCH
         OI    USERFLG1,FLAGQWRT   SET THE WRITE QUEUE FLAG TO WRITE
         LA    R0,MSG31         "ENTRY DELETED"
         BAL   R14,MESSAGE
         B     WRTQUEUE
NOTSAM   EQU   *
         LA    R0,MSG30     "SCRATCH NOT ALLOWED FOR DIFF UIDS".
         B     ERROR
OPER2    EQU   *
         LA    R0,MSG71         'RETURN ALREADY REQUESTED FOR DSN'
         TM    QACTION,FLAGRET  RETURN ?
         BO    RETT             YES, SEND A DIFFERENT MESSAGE.
         LA    R0,MSG70         'ARCHIVE ALREADY REQUESTED FOR DSN'
RETT     EQU   *
         BAL   R14,MESSAGE
         LA    R0,MSG72         'PLEASE SCRATCH BEFORE TRYING AGAIN'
         B     ERROR
         DROP  R8
         EJECT
*
*         PROCESS RETURN REQUESTS
*
RETURNDS EQU   *
         TM    USERFLG2,FLAGTDSN  IS THIS RETURN WITH NEWNAME
         BO    COMR             BRANCH IF SO
         MVC   USERTDSN,USERDSN   THIS IS WHERE WE PUT IT.
COMR     EQU   *
         MVC   ULOCDSN(LOCLEN),LOCDSN TRANSFER PROTO-CAMLST.
         LA    R3,USERTDSN
         ST    R3,ULOCDSN+4     PUT IT INTO THE CAMLST.
         LA    R3,LOCAREA
         ST    R3,ULOCDSN+12    PUT IT INTO THE CAMLST.
         LOCATE ULOCDSN
         LTR   R15,R15          IF ^0, NON-EXISTENT DS.
         BNZ   NOTLOC
         OI    USERFLG1,FLAGLOC MARK AS LOCATED
         TM    USERFLG1,FLAGVOL HAS USER SAID WHERE TO PUT IT
         BO    NOTLOC
         MVC   USERVOL,LOCVOL   TRANSFER VOLID.
         OI    USERFLG1,FLAGVOL NOW WE KNOW THE VOLSER
NOTLOC   EQU   *
*
* WE ARE ONLY ALLOWED TO RETURN OUR OWN USERID PREFIXED DATASETS.
*        UNLESS WE HAVE THE OPERATIONS ATTRIBUTE (RACF)
*        OR THE DATASET EXISTS AND WE HAVE ALTER AUTHORITY
*           (ALTER IS REQUIRED TO PROTECT DATABASES WITH UACC=UPDATE)
*
         TM    USERFLG1,FLAGOPER   HAVE WE GOT OPERATIONS ATTRIBUTE
         BO    OKRET               IF SO ALLOW IT
         ZR    R15                CLEAR FOR IC
         IC    R15,USERUIDL       GET LENGTH OF USERID
         EX    R15,CLCUIDT        COMPARE USERIDS INCLUDING TRAILING .
         BE    OKRET            OK, CARRY ON.
         LA    R0,MSG36
         TM    USERFLG1,FLAGVOL DO WE HAVE A DATASET TO CHECK
         BZ    ERROR            IF NOT THAT IS ALL WE CAN TRY
         MVC   USERRACK(RALEN),RACHECK
         RACHECK ENTITY=USERTDSN,VOLSER=USERVOL,ATTR=ALTER,            +
               MF=(E,USERRACK)
         LA    R0,MSG36
         LTR   R15,R15          WAS IT FOUND BY RACF
         BNZ   ERROR
OKRET    EQU   *
         EJECT
*
*        SCAN QUEUE FOR ENTRY ALREADY PRESENT
*
         OI    USERFLG3,FLAGENQX   WANT QUEUE EXCLUSIVELY
         BAL   R14,INQUEUE      ALLOC, OPEN & READ 'ARCHIVE.QUEUE'
RETURND1 EQU   *
         BAL   R14,GETRECOR     GET NEXT RECORD FROM QUEUE
         USING QUEUEMAP,R8
         TM    QACTION,FLAGDEL     IS THIS RECORD SCRATCHED
         BO    RETURND             IF SO TRY FOR NEXT
         CLC   QDSN,USERDSN        SAME DSN ?
         BE    OPER2               NO.
RETURND  EQU   *
         TM    QEND,FLAGEND       EOF ?
         BZ    RETURND1           NO
         DROP  R8
         EJECT
*
* HERE GRAB A RECORD FROM 'ARCHIVE.TRACE' & SEE IF THIS DATASET
* EXISTS IN THE LOG. IF MORE THAN ONE ENTRY IS FOUND THEN THE LAST
* IS USED WHICH MATCHES THE REQUIREMENTS OF DATE AND KEY.
*
         BAL   R14,ALLOCTRA        ALLOC & OPEN 'ARCHIVE.TRACE'.
         LA    R1,CONTIN           WHERE TO GO ON EOD
         ST    R1,USERTEOD         SAVE IT
         MVC   USERMDAT,=C'00.000' MINIMUM DATE
GETRC    EQU     *
         BAL   R14,GETRACE         GET A RECORD FROM 'TRACE'.
         L     R9,USERBUFP         POINT TO RECORD
         USING TRACEMAP,R9
         CLC   TRACEDSN,USERDSN    IF NOT SAME HAVE RETRIEVED ALL
         BNE   CONTIN              TRACE RECORDS FOR THIS DS
*                                  CHECK THE AUTHORITY TO RETURN IT
         CLC   TRACEUSR,USERUID    DID USER ARCHIVE DS.
         BE    RETKCHK             YES SO HE CAN RETURN IT
         ZR    R15                CLEAR FOR IC
         IC    R15,USERUIDL       GET LENGTH OF USERID
         EX    R15,CLCUIDTR       IS IT PREFIXED WITH OUR USERID
         BE    RETKCHK             YES SO HE CAN RETURN IT
         TM    USERFLG1,FLAGOPER   OPERATOR /
         BZ    GETRC               IF NOT THEN LOOK FOR ANOTHER ONE
RETKCHK  EQU   *
         TM    USERFLG4,FLAGKEY    WAS KEY SPECIFIED
         BNO   RETNOKEY
         CLC   TRACEKEY,USERKEY    DOES KEY MATCH
         BNE   GETRC
RETNOKEY EQU   *
         TM    USERFLG4,FLAGDATE   WAS KEY SPECIFIED
         BNO   RETNODAT
         CLC   TRACEDAT,USERDATE   DOES KEY MATCH
         BNE   GETRC
RETNODAT EQU   *
         CLC   USERMDAT,TRACEDAT   LOOK FOR LATEST COPY
         BH    GETRC               OLDER THAN ONE WE HAVE ALREADY GOT
         MVC   USERMDAT,TRACEDAT   REMEMBER THIS DATE
         OI    USERFLG2,FLAGTFND   MARK AS HAVING FOUND GOOD ONE
*
*       ADD RECORD TO QUEUE (OVER WRITING ANY EARLIER ONES)
*
         BAL   R14,ADDQREC
         B     GETRC               GET NEXT OCCURRENCE
CONTIN   EQU   *
         TM    USERFLG2,FLAGTFND   HAVE WE ALREADY FOUND A GOOD ONE
         BO    NOMORE
NOTRACE  EQU   *
         LA    R0,MSG35            GET ERROR MESSAGE.
         B     ERROR
         EJECT
*
* DO THE BEST WE CAN TO CHECK CATALOG AND DEVICE TYPE VALIDITY
*
NOMORE   EQU   *
         TM    USERFLG1,FLAGLOC   DID WE FIND THE DATASET IN CATALOG
         BZ    NOWARN             IF NOT THEN NO PROBLEM
         USING QUEUEMAP,R8
         CLC   QVOLSER,LOCVOL     DO RETURN/LOCATED VOLSERS MATCH
         BE    CHKTYPE            IF SO THEN CHECK DEVICE TYPE
         DROP  R8
         LA    R0,MSG24           THE RETURN MAY FAIL BECAUSE RACF DOES
         BAL   R14,MESSAGE        NOT ALLOW TWO DATASETS WITH THE SAME
         LA    R0,MSG25           NAME AT OUR INSTALLATION.
         BAL   R14,MESSAGE
         B     NOWARN
CHKTYPE  EQU   *
         CLC   LOCTYPE,USEROTYP   DOES DEVICE TYPE MATCH ORIGINAL
         LA    R0,MSG26
         BNE   ERROR              IF NOT WE CANT DO IT
NOWARN   EQU   *
*
* UNFORTUNATELY IT IS NOT POSSIBLE TO DO ANY FURTHER CHECKS ON RETURN
* POSSIBILITY BECAUSE DATASET SIZE AND DEVICE TYPE CHECKS ALL REQUIRE
* THE VOLUME TO BE MOUNTED WHICH IS NOT DESIRABLE DURING A TSO SESSION.
*
* WE HAVE FOUND A GOOD ENTRY IN THE TRACE FILE NOW WRITE QUEUE BACK
*
         LA    R0,MSG29         "DONE"
         BAL   R14,MESSAGE      SEND MESSAGE.
         B     WRTQUEUE
         DROP  R9
         EJECT
*
* TRACEDS
* -------
* THIS PART OF THE PROGRAM SEARCHES THE TRACE FILE AND COMPARES EACH
* RECORD IN TURN WITH THE DATASET NAME GIVEN BY THE CUSTOMER
* IF THE ARE NO MATCHES AT ALL, THEN AN ERROR MESSAGE IS GIVEN.
* IF THERE IS A MATCH (OR MATCHES) THE THE DSN & DATE ARE O/P
*
TRACEDS   EQU     *
         LA    R9,TREND1
TRACEAL  EQU   *
         ST    R9,USERTEOD      SET UP RETURN ADDRESS FOR EOD
         BAL   R14,ALLOCTRA     ALLOC & OPEN TRACE IN DSN MODE.
*
* HERE, WE GET EACH RECORD IN TURN.
*
GET01    EQU   *
         BAL   R14,GETRACE      GET A RECORD FROM 'ARCHIVE.TRACE'
         L     R9,USERBUFP         POINT TO BUFFER
         USING TRACEMAP,R9
         EJECT
*
*        SEE IF ALL DETAILS CORRECT
*
         TM    USERFLG4,FLAGDSNF   ARE WE SEARCHING ON FULL DSN
         BZ    GETNDSN
         CLC   TRACEDSN,USERDSN    DOES DSN MATCH
         BNE   TREND1              IF NOT THEN END OF SEARCH
         B     GETTKEY             SKIP USERID TEST
GETNDSN  EQU   *
*                                  MUST BE USERID THEN
         TM    USERFLG4,FLAGPTH2   IS THIS PATH2 (USERID/KEY)
         BO    GETPTH2
         ZR    R15                CLEAR FOR IC
         IC    R15,USERULEN       GET LENGTH OF USERID
         EX    R15,CLCUSRTR       IS IT PREFIXED WITH OUR USERID
         BNE   TREND1              IF NOT THEN END OF SEARCH
         B     GETTKEY             SKIP PATH 2 TESTS
GETPTH2  EQU   *
         CLC   TRACEUSR,USERUSER   DOES USERID MATCH REQUESTOR
         BNE   TREND2              IF NOT THEN END OF IT ALL
         TM    USERFLG4,FLAGKEY    ARE WE SEARCHING FOR A KEY
         BZ    GETNKEY2
         CLC   TRACEKEY,USERKEY    DOES KEY MATCH
         BNE   TREND2              IF NOT THEN END OF IT ALL
GETNKEY2 EQU   *
         ZR    R15                CLEAR FOR IC
         IC    R15,USERULEN       GET LENGTH OF USERID
         EX    R15,CLCUSRTR       IS IT PREFIXED WITH OUR USERID
         BE    GET01               IF SO THEN WE HAVE DONE THIS ONE
         B     GETTDAT             GO TEST DATE
GETTKEY  EQU   *
         TM    USERFLG4,FLAGKEY    ARE WE SEARCHING FOR A KEY
         BZ    GETNKEY
         CLC   TRACEKEY,USERKEY    DOES KEY MATCH
         BNE   GET01               IF NOT THEN SKIP THIS ONE
GETNKEY  EQU   *
GETTDAT  EQU   *
         TM    USERFLG4,FLAGDATE   ARE WE SEARCHING FOR A DATE
         BZ    GETNDAT
         CLC   TRACEDAT,USERDATE   DOES DATE MATCH
         BNE   GET01               IF NOT THEN SKIP THIS ONE
GETNDAT  EQU   *
         EJECT
*
* HERE, WE O/P THE TOP MESSAGE.
*
         TM    USERFLG2,FLAGTFND   HAVE WE FOUND ONE BEFORE ?
         BNZ   GET04               YES
         LA    R0,MSG39
         BAL   R14,MESSAGE
         OI    USERFLG2,FLAGTFND   SET 'FOUND' FLAG.
GET04    EQU   *
         BLANK USERMSG,84
         MVC   USERMSG(4),=AL2(84,0) INSERT LENGTH HEADER
         MVC   USERMSG+4(44),TRACEDSN DATASET NAME
         MVC   USERMSG+49(2),=C'BY'
         MVC   USERMSG+52(7),TRACEUSR REQUESTOR
         MVC   USERMSG+60(2),=C'ON'
         MVC   USERMSG+63(6),TRACEDAT DATE
         CLC   TRACEKEY,=CL8' '    ARCHIVED WITH KEY ?
         BE    GET05
         MVC   USERMSG+69(5),=C',KEY:'
         MVC   USERMSG+74(8),TRACEKEY KEY
GET05    EQU   *
         LA    R0,USERMSG
         BAL   R14,MESSAGE2
         TM    USERFLG1,FLAGFULL   FULL TRACE INFORMATION
         BZ    GET01               IF NOT RETURN FOR NEXT
         BLANK USERMSG,84
         MVC   USERMSG(4),=AL2(84,0) INSERT LENGTH HEADER
         MVC   USERMSG+6(5),=C'DISK:'
         MVC   USERMSG+11(6),TRACEDSK
         MVC   USERMSG+17(6),=C',TAPE:'
         MVC   USERMSG+23(6),TRACETPE
         MVC   USERMSG+29(7),=C',LABEL:'
         MVC   USERMSG+36(4),TRACELBL
         DROP  R9
         LA    R0,USERMSG
         BAL   R14,MESSAGE2
         B     GET01               GO BACK FOR ANOTHER ONE
         EJECT
TREND1   EQU   *
         TM    USERFLG4,FLAGDSNF   WAS FULL DSN SPECIFIED
         BO    TREND2              IF SO NO SECOND SCAN
         NI    USERFLG2,X'FF'-FLAGTOPN SET MARKER OFF
         L     R9,USERACBP
         CLOSE ((9)),MF=(E,USERDML) CLOSE TRACE FILE
         LTR   R15,R15
         BNZ   ERRORVOC
         OI    USERFLG4,FLAGPTH2   SCAN PATH 2 NEXT
         LA    R9,TREND2           NEW EOD ADDRESS
         B     TRACEAL
TREND2   EQU   *
         TM    USERFLG2,FLAGTFND WAS THERE A MATCH ?
         BNZ   FINISH           YES.
         LA    R0,MSG35
         BAL   R14,MESSAGE
         B     FINISH
         EJECT
*
* QUEUEDS
* -------
* SEE IF THE CHOSEN DS IS IN THE QUEUE.
*
QUEUEDS   EQU     *           EXCLUSIVE ACCESS NOT REQUIRED
         BAL   R14,INQUEUE    ALLOC, OPEN & READ IN 'ARCHIVE.QUEUE'
Q01      EQU   *
         BAL   R14,GETRECOR     GET A RECORD.
         USING QUEUEMAP,R8
         TM    QACTION,FLAGDEL     IS THE RECORD SCRATCHED
         BO    Q01Z                LOOK FOR ANOTHER ONE
         TM    USERFLG4,FLAGALL    IS ALL LISTING REQUIRED
         BO    Q01B                IF SO THEN ALLOW IT
         TM    USERFLG4,FLAGUID    DO WE REQUIRE ALL FOR THIS USERID
         BZ    Q01A                IF NOT THEN LOOK FOR ONE
         ZR    R15                CLEAR FOR IC
         IC    R15,USERULEN       GET LENGTH OF USERID
         EX    R15,CLCUSRQ        IS IT PREFIXED WITH OUR USERID
         BE    Q01B
         CLC   QUSERID,USERUSER   OR IS IT THE SAME REQUESTOR
         BE    Q01B
         B     Q01Z                IF NOT THEN TRY NEXT
Q01A     EQU   *
         CLC   QDSN,USERDSN        COMPARE QUEUE AGAINST CHOSEN DSN.
         BNE   Q01Z                THEN NO GOOD FOR US LOOK FOR NEXT
*
* O/P SOME INFO, I.E. SAVE/RETURN. ETC.
*
* HERE WE CHECK IF SAVE OR RETURN REQUEST.
*
Q01B     EQU   *
         TM    USERFLG2,FLAGTFND HAVE WE FOUND ONE BEFORE ?
         BNZ   Q04              YES.
Q01C     EQU   *                   IF NOT PRINT HEADER
         LA    R0,MSG37         GET ADDRESS OF MESSAGE.
         BAL   R14,MESSAGE      SEND IT.
         OI    USERFLG2,FLAGTFND FOUND RECORD, SO SET FLAG.
Q04      EQU   *
         BLANK USERMSG,84          BLANK OUTPUT LINE
         MVC   USERMSG(4),=AL2(84,0) INSERT LENGTH HEADER
         MVC   USERMSG+4(7),QUSERID USER WHO ISSUED REQUEST
         MVC   USERMSG+12(3),=C'ARC'
         MVC   USERMSG+61(2),=C'ON'
         TM    QACTION,FLAGRET     RETURN REQUEST ?
         BZ    Q04B                IF SO THEN MODIFY THE TEXT
         MVC   USERMSG+12(3),=CL7'RTN'
         MVC   USERMSG+61(2),=C'TO'
Q04B     EQU   *
         MVC   USERMSG+16(44),QDSN DATASET NAME CONCERNED
         MVC   USERMSG+64(6),QVOLSER VOLUME ON OR TO
         CLC   QKEY,=CL8' '        IS THERE A KEY
         BE    Q04C
         MVC   USERMSG+70(5),=C',KEY:'
         MVC   USERMSG+75(8),QKEY
Q04C     EQU   *
         LA    R0,USERMSG
         BAL   R14,MESSAGE2        SEND FIRST LINE OF MESSAGE
         TM    QACTION,FLAGRET     RETURN REQUEST ?
         BZ    Q01Y                THEN PRINT ANOTHER LINE
         BLANK USERMSG,84          BLANK OUTPUT LINE
         MVC   USERMSG(4),=AL2(84,0) INSERT LENGTH HEADER
         CLC   QDATE,=CL6' '       IS THERE A DATE
         BE    Q04D
         MVC   USERMSG+61(8),=C'ARCDATE:'
         MVC   USERMSG+69(6),QDATE
Q04D     EQU   *
         TM    QACTION,FLAGNNME    RETURN WITH NEW NAME ?
         BNO   Q04E                GET ANOTHER RECORD
         MVC   USERMSG+6(9),=C'RETURN AS'
         MVC   USERMSG+16(44),QNEWDSN NEW DATASET NAME
Q04E     EQU   *
         LA    R0,USERMSG
         BAL   R14,MESSAGE2        SEND SECOND LINE OF MESSAGE
         TM    USERFLG1,FLAGFULL   FULL QUEUE INFORMATION REQUIRED ?
         BZ    Q01Y
         BLANK USERMSG,84          BLANK OUTPUT LINE
         MVC   USERMSG(4),=AL2(84,0) INSERT LENGTH HEADER
         MVC   USERMSG+8(10),=C'FROM TAPE:'
         MVC   USERMSG+18(6),QTAPE TAPE VOLSER
         MVC   USERMSG+25(6),=C'LABEL:'
         MVC   USERMSG+31(4),QTLBL TAPE LABEL NUMBER
         LA    R0,USERMSG
         BAL   R14,MESSAGE2        SEND THIRD LINE OF MESSAGE
Q01Y     EQU   *
         TM    USERFLG4,FLAGDSNF   LOOKING FOR FULL DSN ?
         BO    FINISH              IF SO THERE CAN ONLY BE ONE
Q01Z     EQU   *
         TM    QEND,FLAGEND     END OF DATA ?
         BZ    Q01              NO GO READ NEXT
         TM    USERFLG2,FLAGTFND WAS THERE A RECORD FOUND ?
         BNZ   FINISH           YES.
         LA    R0,MSG38         'RECORD NOT IN QUEUE.'
         BAL   R14,MESSAGE      PRINT MESSAGE.
         B     FINISH
         DROP  R8
          EJECT
*
* HERE, TO WRITE AWAY 'ARCHIVE.QUEUE'.
*
WRTQUEUE EQU   *
         POINT USERQDCB,BLOCKADR  POINT TO THE START.
         L     R5,CHAIN           GET FIRST ADDRESS.
WRTG1    EQU   *
         LA    R6,4(R5)           GET PROPER POINTER.
         WRITE USERDECB,SF,USERQDCB,(6),MF=E WRITE BLOCK AWAY.
         CHECK USERDECB           AWAIT COMPLETION.
         TM    BLKSIZE-1(R6),QUEEND IS THIS THE END OF THE QUEUE
         BO    ENDWRT
         L     R5,0(R5)           POINT TO NEXT BLOCK.
         B     WRTG1
ENDWRT   EQU   *
*
*        ALL DONE NOW WIND UP AND CLOSE DOWN
*
FINISH   EQU   *
*
* NOW, CLOSE QUEUE
*
         TM    USERFLG1,FLAGQOP   IS QUE FILE OPEN ?
         BZ    NOQOPEN            NO.
         XI    USERFLG1,FLAGQOP   SWITCH OFF FLAG
         CLOSE (USERQDCB),MF=(E,USERDML) CLOSE I/P FILE.
         EJECT
*
* RELEASE CONTROL OF RESOURCE. MOST IMPORTANT.
*
         TM    USERFLG2,FLAGENQQ       ARE WE ENQ'ED ?
         BZ    NODEQ                   BRANCH IF NOT.
         XI    USERFLG2,FLAGENQQ       CLEAR ENQ FLAG.
         DEQ   (QNAME,RNAME,8,SYSTEM),RET=HAVE,MF=(E,ENQQLST)
         LTR   R15,R15                TEST RETURN CODE.
         BZ    NODEQ
         LA    R0,MSG28               "DEQ FAILURE".
         B     ERROR                  SEND THE MESSAGE.
NODEQ    EQU   *
         STAX  ,DEFER=NO              ENABLE ATTENTIONS AGAIN
         EJECT
*
*        FREMAIN STORAGE AQUIRED FOR EACH QUEUE BLOCK
*
         L     R5,CHAIN           GET FIRST ADDRESS.
FREEG1   EQU   *
         LTR   R5,R5              IF ZERO, ALL DONE.
         BZ    ENDFREE
         LR    R1,R5              ADDRESS FOR FREEMAIN.
         L     R5,0(R5)           POINTS TO NEXT BLOCK.
         FREEMAIN RU,LV=BLKSIZE+4,A=(1)  FREE MEMORY.
         B     FREEG1
ENDFREE  EQU   *
         ZERO  CHAIN,4            MARK STORE AS FREED
NOQOPEN  EQU   *
         EJECT
*
*        NOW CLOSE TRACE IF IT WAS OPEN
*
         TM    USERFLG2,FLAGTOPN   TRACE OPEN ?
         BZ    NOTOPEN             NO !
         XI    USERFLG2,FLAGTOPN   SWITCH OFF FLAG
         L     R9,USERACBP
         CLOSE ((9)),MF=(E,USERDML) CLOSE TRACE FILE
         LTR   R15,R15
         BNZ   ERRORVOC
NOTOPEN  EQU   *
         LA    R6,0        RETURN CODE 0.
         B     RETURN
         EJECT
ERROR    EQU   *
         BAL   R14,MESSAGE   SEND OUR MESSAGE.
FAIL     EQU   *
*
* CLOSE QUEUE IN THE EVENT OF FAILURE
*
         TM    USERFLG1,FLAGQOP   IS QUE FILE OPEN ?
         BZ    FAIL6              NO.
         XI    USERFLG1,FLAGQOP   SWITCH OFF FLAG
         CLOSE (USERQDCB),MF=(E,USERDML) CLOSE I/P FILE.
FAIL6    EQU   *
         EJECT
*
* RELEASE CONTROL OF RESOURCE. MOST IMPORTANT.
*
         TM    USERFLG2,FLAGENQQ       ARE WE ENQ'ED ?
         BZ    FAIL2                   BRANCH IF NOT.
         XI    USERFLG2,FLAGENQQ       CLEAR ENQ FLAG.
         DEQ   (QNAME,RNAME,8,SYSTEM),RET=HAVE,MF=(E,ENQQLST)
         LTR   R15,R15                TEST RETURN CODE.
         BZ    FAIL2
         LA    R0,MSG28               "DEQ FAILURE".
         B     ERROR                  SEND THE MESSAGE.
FAIL2    EQU   *
         STAX  ,DEFER=NO              ENABLE ATTENTIONS AGAIN
*
*        NOW MAKE SURE TRACE CLOSED
*
         TM    USERFLG2,FLAGTOPN   TRACE OPEN ?
         BZ    FAIL7               NO !
         XI    USERFLG2,FLAGTOPN   SWITCH OFF FLAG
         L     R9,USERACBP
         CLOSE ((9)),MF=(E,USERDML) CLOSE TRACE FILE
FAIL7    EQU   *
         EJECT
*
*        FREE STORAGE FOR QUEUE
*
         L     R5,CHAIN           GET FIRST ADDRESS.
FREEF1   EQU   *
         LTR   R5,R5              IF ZERO, ALL DONE.
         BZ    FAIL3
         LR    R1,R5              ADDRESS FOR FREEMAIN.
         L     R5,0(R5)           POINTS TO NEXT BLOCK.
         FREEMAIN RU,LV=BLKSIZE+4,A=(1)  FREE MEMORY.
         B     FREEF1
FAIL3    EQU   *
         LA    R6,12               SET RETURN CODE
         EJECT
RETURN   EQU   *
         GOODBY  RC=(6),RENT=YES,SP=100,LV=USERLEN
         EJECT
*
* SUBROUTINE GETMEM TO GET A BLOCK OF MEMORY TO HOLD QUEUE BLOCK.
* RETURNS R6 -> DATA AREA, R5 -> BLOCK OF MEMORY
* R5 MUST BE PRESERVED BETWEEN CALLS
* USES    R1
*
* DATA STRUCTURE
*
*         +-----------------------+
*         × POINTER TO NEXT BLOCK ×
*         +-----------------------+
*         ×         DATA          ×
*
GETMEM    EQU     *
          GETMAIN RU,LV=BLKSIZE+4  GET ANOTHER CHUNK.
          LA      R6,4(R1)         POINT TO BUFFER.
          ST      R1,0(R5)         LINK THIS BUFFER TO CHAIN.
          ZR      R5
          ST      R5,0(R1)         KILL END OF CHAIN.
          LR      R5,R1            FOR COMPLETENESS.
          BR      R14              RETURN.
          EJECT
*
* SUBROUTINE GETRACE
* GET A RECORD FROM THE TRACE
* USES  R0,R1
*
GETRACE  EQU     *
         ST      R14,USERSR14      SAVE RETURN ADDRESS.
         TM    USERFLG4,FLAGSEQ    SEQUENTIAL RETRIEVAL ?
         BO    GETT01
         L     R1,USERRPLP
         POINT RPL=(1)
         LTR   R15,R15
         BNZ   GETTEOF             SEE IF RECORD NOT FOUND
         OI    USERFLG4,FLAGSEQ    MARK AS SEQUENTIAL RETRIEVAL
GETT01   EQU   *
         L     R1,USERRPLP
         GET   RPL=(1)            GET A RECORD
         LTR   R15,R15
         BNZ   GETTEOF             SEE IF END OF FILE
         L     R14,USERSR14
         BR    R14
         EJECT
*
* HANDLE VSAM ERRORS HERE FROM POINT AND GET
*
GETTEOF  EQU   *
         ST    R15,USERSR14            SAVE RETURN CODE TEMPORARILY
         PRINT NOGEN
         SHOWCB RPL=(*,USERRPLP),AREA=(S,USERFDBK),                    X
               LENGTH=4,FIELDS=FDBK,MF=(G,(S,USERSHOW),USERSLEN)
         PRINT GEN
         LTR   R15,R15
         BNZ   ERRORVS
         ZR    R1
         IC    R1,USERFDBK+3           GET FEEDBACK CODE
         L     R15,USERSR14            RECOVER REAL RETURN CODE
         CH    R15,=H'8'
         BNE   GETVSERR
         L     R14,USERTEOD
         CH    R1,=H'4'                END OF FILE ?
         BER   R14
         CH    R1,=H'16'               RECORD NOT FOUND
         BER   R14
GETVSERR EQU   *
         BLANK USERMSG,80
         MVC   USERMSG(MSG04L+8),MSG04  SKELETON MESSAGE
         LA    R0,USERMSG+8             INTERNAL POINTER
         ST    R0,USERMSG+4
         CVD   R15,USERCVD              CONVERT RC TO DECIMAL
         UNPK  USERMSG+12+25(3),USERCVD+6(2) THEN CHARACTERS
         OI    USERMSG+12+27,X'F0'       CHANGE LAST DIGIT TO CHAR FORM
         CVD   R1,USERCVD               CONVERT FDBK TO DECIMAL
         UNPK  USERMSG+12+36(3),USERCVD+6(2) THEN CHARACTERS
         OI    USERMSG+12+38,X'F0'       CHANGE LAST DIGIT TO CHAR FORM
         LA    R0,USERMSG
         B     ERROR
         EJECT
*
* SUBROUTINE 'INQUEUE'
* ------
* A SUBROUTUNE TO ALLOCATE, OPEN & READ IN 'ARCHIVE.QUEUE'
* USES R3,R6,R1,R4,R5
*
INQUEUE   EQU     *
          ST      R14,USERSR14     SAVE THIS FOR LATER.
          USING   S99TUPL,R3
          USING   S99TUNIT,R6
          LA      R3,USERTUPL
*
* ALLOCATE THE QUEUE
*
          TUPL    TU2               DSNAME=
          MVC     S99TULNG(ARCHLEN),ARCHQUEU  TRANSFER DSNAME OF QUEUE.
          TUPL    TU4               DISP=(
          MVI     S99TUPAR,X'08'          SHR,
          TUPL    TU55,V=YES         RETURN DDNAME.
          LA      R1,USERRBP
          DYNALLOC
          LTR     R15,R15                 TEST RETURN CODE.
          BNZ     DAIRFAIL             IF ZERO, BRANCH TO...
*                                      ...ERROR RECOVERY ROUTINE.
         MVC   USERDDS,RETDDN        GET DDNAME
         OI    USERFLG3,FLAGQALL      SET ALLOCATED FLAG.
         EJECT
*
* DEFER ATTENTIONS AND REQUEST CONTROL OF THIS RESOURCE
*
         STAX  ,DEFER=YES
         MVC   ENQQLST(ENQLEN),ENQQLSTL
         TM    USERFLG3,FLAGENQX   EXCLUSIVE USE OF QUEUE ?
         BO    ENQX                YES
         ENQ   (QNAME,RNAME,S,8,SYSTEM),RET=HAVE,MF=(E,ENQQLST)
         B     ENQTEST
ENQX     EQU   *
         ENQ   (QNAME,RNAME,E,8,SYSTEM),RET=HAVE,MF=(E,ENQQLST)
*                                  TIDY UP BEFORE EXITING
ENQTEST  EQU   *
         LA    R0,MSG22             "ENQ FAILURE".
         LTR   R15,R15              TEST RETURN CODE.
         BNZ   ERROR                BRANCH IF AN ERROR.
         OI    USERFLG2,FLAGENQQ      SET ENQ FLAG.
         EJECT
*
* OPEN THE QUEUE
*
         MVC   USERQDCB(QDCBLEN),QDCB TRANSFER DCB.
         LA    R4,USERQDCB        GET ADDRESS OG I/P DCB.
         USING IHADCB,R4
         MVC   DCBDDNAM,USERDDS   INSERT QUEUE DDNAME
         MVI   USERDML,X'80'      SET UP DATA MAN LIST
         OPEN  ((4),INOUT),MF=(E,USERDML)
         LA    R0,MSG27           "QUEUE OPEN FAILURE,INPUT".
         TM    DCBOFLG,DCBOFOPN
         BZ    ERROR
         DROP  R4
         OI    USERFLG1,FLAGQOP   MARK INPUT FILE AS OPEN.
*
* READ 'ARCHIVE.QUEUE' IN.
*
         LA    R5,CHAIN             POINT TO CHAIN START (DUMMY)
STARTP   EQU   *
         BAL   R14,GETMEM           GET A BLOCK OF MEMORY
         READ  USERDECB,SF,USERQDCB,(6),MF=E  READ A BLOCK IN.
         CHECK USERDECB           AWAIT READIN.
         TM    BLKSIZE-1(R6),BLKEND QUICK CHECK ON QUEUE VALIDITY
         BZ    CORRUPTQ
         TM    BLKSIZE-1(R6),QUEEND    TERMINATOR ?
         BZ    STARTP             BACK FOR MORE.
         L     R14,USERSR14       RESTORE RETURN ADDRESS.
         BR    R14                RETURN.
*
CORRUPTQ EQU   *              HERE ON END OF FILE
         LA    R0,MSG06       GET ERROR MESSAGE.
         B     ERROR
         EJECT
*
* THIS ROUTINE TRIES BOTH TO ALLOCATE & OPEN 'SYS2.ARCHIVE.TRACE'
* USES R3,R6,R1,R9,
* NOTE THIS ROUTINE CAN BE CALLED TWICE IN ONE RUN
*
ALLOCTRA EQU   *
         ST    R14,USERSR14    SAVE RETURN ADDRESS.
         NI    USERFLG3,X'FF'-FLAGTALL SWITCH OFF ALLOCATED FLAG
         USING S99TUPL,R3
         USING S99TUNIT,R6
         LA    R3,USERTUPL     GET ADDRESS OF TU POINTER LIST.
         TUPL  TU2             SET UP DSN.
         ZR    R9              DEFAULT TO FULL KEY SEARCH
         TM    USERFLG4,FLAGPTH2 USE PATH TO USERID/KEY
         BZ    APATH1            IF NOT BRANCH
         MVC   S99TULNG(PATH2L),PATH2  ALLOCATE PATH TO KEY
         MVC   USERVKEY(7),USERUSER
         MVC   USERVKEY+7(8),USERKEY
         TM    USERFLG4,FLAGKEY  WAS KEY SPECIFIED
         BO    ATRDD             IF NOT THEN USE FULL KEY SEARCH
         LA    R9,7              SET TO 7 FOR GENERIC SEARCH ON USERID
*                                 INCLUDE TRAILING SPACES IN KEY
         B     ATRDD
APATH1   EQU   *
         MVC   S99TULNG(PATH1L),PATH1 ALLOCATE PATH TO DSN
         MVC   USERVKEY(44),USERDSN
         TM    USERFLG4,FLAGUID IS IT HLQ ONLY
         BZ    ATRDD             IF NOT THEN USE FULL KEY SEARCH
         IC    R9,USERULEN       SET FOR GENERIC SRCH ON HLQ
         INCR  R9                 KEY FOR SEARCH INCLUDES TRAILING .
ATRDD    EQU   *
         TUPL  TU4             DISP =(
         MVI   S99TUPAR,X'08'         SHR,
         TUPL  TU55,V=YES       RETURN DDNAME.
         BLANK RETDDN,8        CLEAR DDNAME FROM POSSIBLE LAST TIME
         LA    R1,USERRBP
         DYNALLOC              ALLOCATE 'ARCHIVE.TRACE'
         LTR   R15,R15         TEST RETURN CODE.
         BNZ   DAIRFAIL
         OI    USERFLG3,FLAGTALL SET ALLOCATED FLAG.
         MVC   USERDDT,RETDDN  GET DDNAME
         DROP  R3,R6
         EJECT
*
*        NOW GENERATE THE ACB/RPL FOR THE OPEN
*
         PRINT NOGEN
         GENCB BLK=ACB,DDNAME=(*,USERDDT),MF=(G,(S,USERACB),USERACBL)
         PRINT GEN
         LTR   R15,R15
         BNZ   ERRORVS
         ST    R1,USERACBP         SAVE ACB ADDRESS
         PRINT NOGEN
         GENCB BLK=RPL,ACB=(*,USERACBP),AREA=(S,USERBUFP),             X
               ARG=(S,USERVKEY),OPTCD=LOC,MF=(G,(S,USERRPL),USERRPLL)
         PRINT GEN
         LTR   R15,R15
         BNZ   ERRORVS
         ST    R1,USERRPLP         SAVE RPL ADDRESS
         LTR   R9,R9               IS FULL KEY SEARCH REQUIRED
         BZ    TRACOPEN            IF SO SKIP MODIFICATION
         PRINT NOGEN
         MODCB RPL=(*,USERRPLP),KEYLEN=(9),OPTCD=GEN,                  X
               MF=(G,(S,USERMOD),USERMODL)
         PRINT GEN
         LTR   R15,R15
         BNZ   ERRORVS
*
*        NOW OPEN TRACE FILE
*
TRACOPEN EQU   *
         NI    USERFLG2,X'FF'-FLAGTOPN
         L     R9,USERACBP
         MVI   USERDML,X'80'    SET UP DATA MAN LIST
         OPEN  ((9)),MF=(E,USERDML)
         LTR   R15,R15
         BNZ   ERRORVOC
         OI    USERFLG2,FLAGTOPN TELL US ITS OPEN.
         NI    USERFLG4,X'FF'-FLAGSEQ MAKE SURE WE POINT FIRST
         L     R14,USERSR14     RESTORE RETURN ADDRESS.
         BR    R14
         EJECT
*
* SUBROUTINE GETRECOR
* GET A RECORD FROM QUEUE
* RETURNS R8=POINTER TO NEW RECORD
*    R5 (BLOCK POINTER) & R6 (RECORD POINTER) MUST BE PRESERVED
*    BETWEEN CALLS.
*
GETRECOR EQU   *
         ST    R14,USERSR14   SAVE RETURN ADDRESS.
         TM    USERFLG2,FLAGQ1ST FIRST TIME THROUGH ?
         BZ    GET001         YES
         LR    R8,R6          POINT TO PREVIOUS RECORD
         USING QUEUEMAP,R8
         INCR  R6,127         INCREMENT POINTER.
         TM    QEND,BLKEND    WAS IT THE LAST IN THE BLOCK
         BZ    GET002         IF NOT RETURN POINTER
         TM    QEND,QUEEND    WAS IT LAST IN QUEUE
         BO    CORRUPTQ       IF SO WE HAVE RUN OFF THE END
         DROP  R8
         B     GET001A
GET001   EQU   *
         LA    R5,CHAIN       GET ADDRESS.
         OI    USERFLG2,FLAGQ1ST SET FLAG TO INDICATE NOT FIRST TIME
GET001A  EQU   *
         L     R5,0(R5)       GET ADDRESS OF NEXT BLOCK IN CHAIN
         LA    R6,4(R5)       POINT TO FIRST RECORD OF THIS BLOCK.
GET002   EQU   *
         LR    R8,R6          RETURN POINTER TO RECORD
         L     R14,USERSR14   RESTORE RETURN ADDRESS.
         BR    R14
         EJECT
*
*       SUBROUTINE ADDQREC
*
*       ADD A NEW RECORD TO THE QUEUE
*    R5 (BLOCK POINTER) MUST BE PRESERVED
*    FROM PREVIOUS CALLS TO GETRECOR, ALSO R8 MUST BE POINTING TO
*    THE LAST RECORD IN THE QUEUE, I.E. AFTER A FULL SEARCH OF QUEUE
*    BY GETRECOR SUBROUTINE.
*    USES R6,R7,R9
*
ADDQREC  EQU   *
         ST    R14,USERSR14
         TM    USERFLG1,FLAGQWRT   HAVE WE ALREADY MOVED ON
         BO    ADDQ02                TO THE NEXT RECORD?
         USING QUEUEMAP,R8
         NI    QEND,X'FF'-FLAGEND  SWITCH OFF LAST REC FLAG
         TM    QEND,BLKEND         FULL BLOCK ?
         BZ    ADDQ01
         NI    QEND,X'FF'-QUEEND   THIS MUST BE THE END OF THE QUEUE
         BAL   R14,GETMEM          RETURN R6-> DATA AREA
         ZR    R9                  PADD,SOURCE LENGTH FOR MVCL
         LA    R7,BLKSIZE          DESTINATION LENGTH FOR MVCL
         MVCL  R6,R8               ZERO OUT THE GOTTEN BLOCK
         LA    R8,4(R5)            GET ADDR OF DATA AREA (1ST RECORD)
         MVI   BLKSIZE-1(R8),BLKEND+QUEEND SET BLOCK TERMINATORS
         B     ADDQ02              AND GO FILL UP RECORD
ADDQ01   EQU   *
         INCR  R8,127              MOVE DOWN TO NEXT RECORD
ADDQ02   EQU   *
         OI    QEND,FLAGEND        MARK AS LAST RECORD
         MVI   QACTION,FLAGARC     MARK AS ARCHIV REQUEST
         MVC   QDSN,USERDSN        INSERT DSN
         MVC   QUSERID,USERUID     INSERT USERID
         MVC   QKEY,USERKEY        INSERT KEY
         MVC   QVOLSER,USERVOL     INSERT DISK VOLSER
         CLC   USERKEEP,#RETURN    RETURN  REQUEST ?
         BNE   ADDQ10              NO
         L     R9,USERBUFP         POINT TO BUFFER
         USING TRACEMAP,R9
         MVI   QACTION,FLAGRET     MARK AS RETURN
         MVC   QKEY,TRACEKEY       INSERT ACTUAL KEY
         MVC   QDATE,TRACEDAT      TRANSFER DATE
         MVC   QTAPE,TRACETPE     TRANSFER TAPE INFO
         MVC   QTLBL,TRACELBL     TRANSFER TAPE INFO
         TM    USERFLG1,FLAGVOL   DO WE KNOW WHERE TO PUT IT ON RETURN
         BO    ADDQ05             IF SO DO IT
         MVC   QVOLSER,TRACEDSK   OTHERWISE PUT IT BACK WHERE IT WAS
ADDQ05   EQU   *
         MVC   USEROTYP,TRACEDVC   REMEMBER DEVICE TYPE
         TM    USERFLG2,FLAGTDSN   RETURN WITH NEW NAME ?
         BZ    ADDQ10              NO
         OI    QACTION,FLAGNNME    MARK AS NEWNAME
         MVC   QNEWDSN,USERTDSN    INSERT NEW NAME
         DROP  R9
ADDQ10   EQU   *
         OI    USERFLG1,FLAGQWRT   MARK TO RE WRITE QUEUE AFTER
         L     R14,USERSR14
         BR    R14
         DROP  R8
         EJECT
*
* SUBROUTINE TO PRINT A WARNING MESSAGE AND RETURN.
*
* ENTRY DATA R0 = ADDRESS OF ,MESSAGE (PUTLINE FORMAT).
*
MESSAGE  EQU   *
         ST    R14,USERSR14    SAVE RETUEN ADDRESS.
         PUTLINE OUTPUT=((0),SINGLE,INFOR),MF=(E,USERIOPL),            *
               TERMPUT=()
         MVI   USERECB,0       RESET ECB FOR NEXT TIME.
         L     R14,USERSR14    RECOVER RETURN ADDRESS.
         LTR   R15,R15         WAS PUTLINE OK ?
         BZR   R14             RETURN & CONTINUE IF OK.
         LA    R4,GFPUTL
         B     GENFAIL         RASPBERRY IF FAILED.
         EJECT
MESSAGE2 EQU   *
         ST    R14,USERSR14    SAVE RETUEN ADDRESS.
         PUTLINE OUTPUT=((0),SINGLE,DATA),MF=(E,USERIOPL),             *
               TERMPUT=()
         MVI   USERECB,0       RESET ECB FOR NEXT TIME.
         L     R14,USERSR14    RECOVER RETURN ADDRESS.
         LTR   R15,R15         WAS PUTLINE OK ?
         BZR   R14             RETURN & CONTINUE IF OK.
         LA    R4,GFPUTL
         B     GENFAIL         RASPBERRY IF FAILED.
         EJECT
*
*        HERE FOR VSAM FAILURES IN OPEN/CLOSE
*
ERRORVOC EQU   *
         ST    R15,USERSR14    SAVE RETURN CODE
         PRINT NOGEN
         SHOWCB ACB=(*,USERACBP),AREA=(S,USERFDBK),                    X
               LENGTH=4,FIELDS=ERROR,MF=(G,(S,USERSHOW))
         PRINT GEN
         LTR   R15,R15
         BNZ   ERRORVS
         L     R15,USERSR14             RESTORE RETURN CODE
         L     R0,USERFDBK              GET ERROR CODE
*
* HERE FOR VSAM FAILURES IN GEN/MOD/SHOWCB (AND OPEN/CLOSE EVENTUALLY)
*      ERROR CODE IN R0, RETURN CODE IN R15
*
ERRORVS  EQU   *
         BLANK USERMSG,80
         MVC   USERMSG(MSG03L+8),MSG03  SKELETON MESSAGE
         LA    R1,USERMSG+8             INTERNAL POINTER
         ST    R1,USERMSG+4
         CVD   R15,USERCVD              CONVERT RC TO DECIMAL
         UNPK  USERMSG+12+25(3),USERCVD+6(2) THEN CHARACTERS
         OI    USERMSG+12+27,X'F0'       CHANGE LAST DIGIT TO CHAR FORM
         CVD   R0,USERCVD               CONVERT R0 TO DECIMAL
         UNPK  USERMSG+12+34(3),USERCVD+6(2) THEN CHARACTERS
         OI    USERMSG+12+36,X'F0'       CHANGE LAST DIGIT TO CHAR FORM
         LA    R0,USERMSG
         B     ERROR
         EJECT
*
* DAIRFAIL ROUTINE.
*
DAIRFAIL EQU   *
         USING DFDSECTD,R1
         LA    R4,DFSVC99C
         LA    R5,USERRB
         LA    R1,USERDFPL
         ST    R5,DFDAPLP
         ST    R15,USERCODE
         LA    R5,USERCODE
         ST    R5,DFRCP
         LA    R5,=F'0'
         ST    R5,DFJEFF02
         L     R2,USERCPPL
         ST    R2,DFCPPLP
         ST    R4,DFIDP
         DROP  R1
         LINK  EP=IKJEFF18,MF=(E,(1))
         B     FAIL
*
* GENERAL FAIL ROUTINE.
*
GENFAIL  EQU   *
         LA    R5,USERECB
         ST    R5,GFECBP
         STH   R4,GFCALLID
         ST    R15,GFRCODE            RETURN CODE.
         L     R2,USERCPPL
         ST    R2,GFCPPLP             CPPL ADDRESS.
         LINK  EP=IKJEFF19,PARAM=USERGFPB,MF=(E,USERGFPL) CALL GNRLFAIL
         MVI   USERECB,0
         B     FAIL
         DROP  R10,R12
          EJECT
*
* VALIDATE THE DATE.
*
VALIDATE EQU     *
         SAVE  (14,12)
         LR    R10,R15
         USING VALIDATE,R10     SET UP ADDRESSABILITY.
         ZR    R15
         L     R2,0(R1)            POINT TO PDE
         CLC   4(2,R2),=H'6'       LENGTH OF DATE=6
         BNE   BADDATE
         L     R2,0(R2)            POINT TO DATE
         CLI   2(R2),C'.'          DATE SHOULD BE YY.DDD
         BNE   BADDATE
         LA    R3,2
TESTYR   EQU   *
         CLI   0(R2),X'F0'         NUMERIC ?
         BL    BADDATE             NO
         INCR  R2
         BCT   R3,TESTYR
         LA    R3,3
TESTDAY  EQU   *
         INCR  R2
         CLI   0(R2),X'F0'         NUMERIC ?
         BL    BADDATE             NO
         BCT   R3,TESTDAY
         B     OKVAL
BADDATE  EQU   *
         LA    R3,MSGV1            RETURN ADDRESS OF MESSAGE
         ST    R3,8(R1)
         LA    R15,4               RETURNCODE
OKVAL    EQU   *
         RETURN (14,12),RC=(15)  GO BACK.
         DROP  R10
         EJECT
         LTORG
         EJECT
*
*        EXECUTED INSTRUCTIONS
*
MOVEDSN  MVC   USERDSN(0),0(R3)
MOVEUSER MVC   USERUSER(0),0(R3)
MOVEVOL  MVC   USERVOL(0),0(R3)
MOVETDSN MVC   USERTDSN(0),0(R3)
MOVEKEY  MVC   USERKEY(0),0(R3)
CLCUIDT  CLC   USERUIDT(0),USERTDSN
         USING TRACEMAP,R9
CLCUIDTR CLC   TRACEDSN(0),USERUIDT
CLCUSRTR CLC   TRACEDSN(0),USERDSN
         DROP  R9
         USING QUEUEMAP,R8
CLCUSRQ  CLC   QDSN(0),USERDSN
         DROP  R8,R11
*
*
*        OFFSETS FOR PDL
*
#NONE    DC    H'0'
#VOLUME  DC    H'1'
#KEYPRES EQU   #VOLUME
#DATPRES EQU   #VOLUME
#FULPRES EQU   #VOLUME
#SAVE    EQU   #VOLUME
#SCRATCH DC    H'2'
#RETURN  DC    H'3'
#TRACE   DC    H'4'
#QUEUE   DC    H'5'
#DA      EQU   #VOLUME
#USER    EQU   #SCRATCH
#ALL     EQU   #RETURN
*
*         CONSTANTS
*
         PRINT NOGEN
QDCB     DCB   DDNAME=QUEUE,DSORG=PS,MACRF=(RP,WP),RECFM=FB,           *
               LRECL=BLKSIZE,BLKSIZE=BLKSIZE,EODAD=CORRUPTQ
QDCBLEN  EQU   *-QDCB
         PRINT GEN
*
         READ  DECB,SF,,,,MF=L
DECBL    EQU   *-DECB
*
ARCHQUEU DC    AL2(ARCHLEN-2)
ARCHNAME DC    C'SYS2.ARCHIVE.QUEUE'
*RCHNAME DC    C'A012006.ARCHIVE.QUEUE'   ***** TESTING VALUE *****
ARCHLEN  EQU   *-ARCHQUEU
*
PATH2    DC    AL2(PATH2L-2)
         DC    C'SYS2.ARCHIVE.TRACE.KEY.PATH'
PATH2L   EQU   *-PATH2
*
PATH1    DC    AL2(PATH1L-2)
         DC    C'SYS2.ARCHIVE.TRACE.DSN.PATH'
PATH1L   EQU   *-PATH1
*
ENQQLSTL ENQ   (QNAME,RNAME,E,8,SYSTEM),RET=HAVE,MF=L
ENQLEN   EQU   *-ENQQLSTL
*
QNAME    DC    CL8'ARCHIVE'
*NAME    DC    CL8'TARCHIVE'      ******** TESTING VALUE ***********
RNAME    DC    CL8'QUEUE   '
*
         DS    0H           HALF WORD BOUNDARISE IT.
DFSVC99C DC    X'0032'      DAIRFAIL SVC99 ERROR CALL.
*
LOCDSN   CAMLST NAME,LOCDSN,,LOCDSN
LOCLEN   EQU   *-LOCDSN
*
RACHECK  RACHECK CLASS='DATASET',MF=L
RALEN    EQU    *-RACHECK      LENGTH OF OUR 'RACHECK' LIST.
*
BLOCKADR DC    F'1'           USED BY POINT MACRO.
*
* SVC99 CONSTANTS
*
RBCON    DC    AL1(S99RBLEN),AL1(S99VRBAL),3XL2'0',3AL4(0)
TU55     DC    AL2(DALRTDDN,1,8) RETURN DDNAME.
TU55L    EQU   *-TU55
TU2      DC    AL2(DALDSNAM,1)         DSNAME.
TU2L     EQU   *-TU2
TU4      DC    AL2(DALSTATS,1,1)       STATS.
TU4L     EQU   *-TU4
         PRINT NOGEN
*
* MESSAGES FOR ERRORS ETC.
*
MSG03    MSG   'RARAR03I VSAM ERROR R15 = 000 R0 = 000 INFORM OPERATION+
               S'
MSG04    MSG   'RARAR04I VSAM ERROR R15 = 000 FDBK = 000 INFORM OPERATI+
               ONS'
MSG06    MSG   'RARAR06I CORRUPT ENTRY ON QUEUE INFORM OPERATIONS'
MSG20    MSG   'RARAR20I DATASET NOT CATALOGUED USE VOLUME PARAMETER'
MSG21    MSG   'RARAR21I MEMBERS OF PDS''S CANNOT BE ARCHIVED'
MSG22    MSG   'RARAR22I ENQ FAILURE INFORM OPERATIONS'
MSG23    MSG   'RARAR23I DATASET NAME REQUIRED FOR THIS FUNCTION'
MSG24    MSG   'RARAR24I WARNING: THE RETURN DATASET NAME IS CATALOGUED+
                ON A VOLUME DIFERENT TO THAT SPECIFIED -'
MSG25    MSG   'RARAR25I ARCHIVE MAY BE UNABLE TO RETURN THE DATASET AS+
               REQUESTED'
MSG26    MSG   'RARAR26I CANNOT RETURN DATASET TO DIFFERENT DEVICE TYPE+
               '
MSG27    MSG   'RARAR27I QUEUE OPEN FAILURE INFORM OPERATIONS'
MSG28    MSG   'RARAR28I DEQ FAILURE INFORM OPERATIONS'
MSG29    MSG   'RARAR29I REQUEST QUEUED'
MSG30    MSG   'RARAR30I SCRATCH NOT PERMITED WHEN USERIDS DIFFERENT'
MSG31    MSG   'RARAR31I ENTRY SCRATCHED'
MSG32    MSG   'RARAR32I REQUEST NOT IN THE QUEUE'
MSG33    MSG   'RARAR33I DATASET NOT FOUND OR RACF DENIES ACCESS'
MSG34    MSG   'RARAR34I MEMBERS OF PDS''S CANNOT BE RETURNED'
MSG35    MSG   'RARAR35I NO REQUESTS IN ARCHIVE TRACE MEET YOUR SEARCH +
               CRITERIA'
MSG36    MSG   'RARAR36I THIS RESTORE CANNOT BE AUTHORISED - SEE HELP F+
               ILE FOR CONDITIONS'
MSG37    MSG   'RARAR37I FOLLOWING REQUESTS FOUND IN QUEUE'
MSG38    MSG   'RARAR38I NO REQUESTS IN ARCHIVE QUEUE MEET YOUR SEARCH +
               CRITERIA'
MSG39    MSG   'RARAR39I FOLLOWING REQUESTS FOUND IN ARCHIVE TRACE'
MSG70    MSG   'RARAR70I ARCHIVE ALREADY REQUESTED FOR THIS DATASET'
MSG71    MSG   'RARAR71I RETURN ALREADY REQUESTED FOR THIS DATASET,'
MSG72    MSG   'RARAR72I PLEASE SCRATCH REQUEST BEFORE TRYING AGAIN.'
MSG73    MSG   'RARAR73I DATA SET NAME REQUIRED FOR SAVE,RETURN OR SCRA+
               TCH'
MSG74    MSG   'RARAR74I ALL KEYWORD VALID FOR OPERATIONS STAFF ONLY'
MSG75    MSG   'RARAR75I ALL KEYWORD VALID FOR QUEUE INSPECT ONLY'
MSGV1    MSGV  'DATE MUST BE IN FORM YY.DDD '
         EJECT
         LTORG
*
* PARAMETER CONTROL LIST (PCL)
*
PCL      IKJPARM
#KEEP    IKJKEYWD
         IKJNAME 'SAVE'
         IKJNAME 'SCRATCH'
         IKJNAME 'RETURN',SUBFLD=#RETSUB
         IKJNAME 'TRACE'
         IKJNAME 'QUEUE',ALIAS='INSPECT'
#DADD    IKJKEYWD
         IKJNAME 'DATASETNAME',ALIAS='DSNAME',SUBFLD=#DASUB
         IKJNAME 'USERID',ALIAS='ID',SUBFLD=#USERSUB
         IKJNAME 'ALL'
#VOL     IKJKEYWD
         IKJNAME 'VOLUME',ALIAS='VOLSER',SUBFLD=#VOLSUB
#RTDATE  IKJKEYWD
         IKJNAME 'ARCDATE',SUBFLD=#DATESUB
#KEY     IKJKEYWD
         IKJNAME 'KEY',SUBFLD=#KEYSUB
#FULL    IKJKEYWD
         IKJNAME 'FULL'
*
#DASUB   IKJSUBF
#DSN     IKJPOSIT DSNAME,USID,PROMPT='DATASET NAME'
*
#USERSUB IKJSUBF
#ID      IKJPOSIT USERID,PROMPT='USERID'
*
#RETSUB  IKJSUBF
#RTDSN   IKJPOSIT DSNAME,USID
*
#VOLSUB  IKJSUBF
#VOLSER  IKJIDENT 'VOLSER',FIRST=ALPHANUM,OTHER=ALPHANUM,MAXLNTH=6,    *
               PROMPT='VOLUME SERIAL'
*
#DATESUB IKJSUBF
#DATE    IKJIDENT 'ARCHIVE DATE',VALIDCK=VALIDATE,FIRST=NUMERIC,       *
               PROMPT='ARCHIVE DATE',MAXLNTH=6,OTHER=ANY,ASIS
*
#KEYSUB  IKJSUBF
#KEYKEY  IKJIDENT 'KEY',FIRST=ALPHANUM,OTHER=ANY,MAXLNTH=8,            *
               PROMPT='KEY,FIRST CHAR ALPHANUMERIC'
*
         IKJENDP
         EJECT
*
* COMMAND PROCESSOR PARAMETER LIST (CPPL)
*
          IKJCPPL
*
* DATA CONTROL BLOCK
*
          DCBD    DSORG=PS,DEVD=DA
*
* PARSE PARAMETER LIST (PPL)
*
          IKJPPL
PPLLEN    EQU     *-PPL
*
* I/O PARAMETER LIST
*
          IKJIOPL
IOPLLEN   EQU     *-IOPL
*
* CVT ADDRESSABILITY FOR CALLTSSR
*
          CVT     DSECT=YES
*
* PROTECTED STEP CONTROL BLOCK.
*
          IKJPSCB
*
* DAIRFAIL PARAMETER LIST.
*
*      CANNOT BE CODED AS GNRLFAIL BECAUSE OF RUBBISH IN MACRO.
*
          IKJEFFDF DFDSECT=YES
*
* SVC99 MAPPING MACROS.
*
          IEFZB4D0
          IEFZB4D2
S99RBLEN  EQU     S99RBEND-S99RB
*
*        ACCESS CONTROL ENVIRONMENT ELEMENT (RACF CONTROL BLOCK)
*
         IHAACEE
*
*        ADDRESS SPACE CONTROL BLOCK
*
         IHAASCB
*
*        ADDRESS SPACE EXTENSION BLOCK
*
         IHAASXB
*
*        PREFIXED STORAGE AREA
*
         IHAPSA
         EJECT
*
*        OUR MACRO FOR MAPPING THE ARCHIVE QUEUE AND TRACE DATASETS
*
         PRINT GEN
         RARMACRO
         EJECT
*
* USER WORK AREA.
*
USERAREA DSECT
* FULL WORD ALIGNED.
*
USERECB  DS    F            GENERAL PURPOSE ECB
USERPPL  DS    0A
         ORG   *+PPLLEN
USERIOPL DS    0A
         ORG   *+IOPLLEN    I/O PARAMETER LIST.
USERPTPB PUTLINE MF=L
USERDFPL DS    0A           DAIRFAIL PARAMETER LIST.
         ORG   *+DFLEN
         ORG   USERDFPL     OVERLAY THIS WITH GNRLFAIL.
USERGFPB DS    0F           GNRLFAIL PARAMETER BLOCK.
         PRINT NOGEN
         IKJEFFGF
         PRINT GEN
*
         DS    0F
* NOT ALIGNED
*
USERFLG1 DS    X
FLAGLOC  EQU   X'80'       SET IF DATASET WAS LOCATED IN CATALOG
FLAGFULL EQU   X'40'       FULL LISTING REQUESTED
FLAGQOP  EQU   X'20'       QUEUE FILE OPEN
FLAGOPER EQU   X'10'       OPERATIONS ATTRIBUTE AVAILABLE
FLAGVOL  EQU   X'08'       VOLUME SPECIFIED ON COMMAND (OR FOUND FROM
FLAGQWRT EQU   X'01'       WRITE BACK QUEUE                   LOCATE)
*
USERFLG2 DS    X
FLAGENQQ EQU   X'40'       ENQUED.
FLAGTDSN EQU   X'20'       RETURN DSN SPECIFIED ON COMMAND
FLAGQ1ST EQU   X'08'       'FIRST-TIME-THRO' FLAG.
FLAGTOPN EQU   X'04'       TRACE IS OPEN.
FLAGTFND EQU   X'01'       TRACE RECORD FOUND
*
USERFLG3 DS    X
FLAGTALL EQU   X'40'       'ARCHIVE.TRACE' IS ALLOCATED.
FLAGQALL EQU   X'20'       'ARCHIVE.QUEUE' IS ALLOCATED.
FLAGENQX EQU   X'01'       SET FOR EXCLUSIVE ENQUE REQD. FOR Q
*
USERFLG4 DS    X
FLAGSEQ  EQU   X'40'       SEQUENTIAL RETRIEVAL
FLAGPTH2 EQU   X'20'       USE PATH2 - USERID/KEY
FLAGKEY  EQU   X'10'       KEY SPECIFIED
FLAGALL  EQU   X'08'       ALL SPECIFIED
FLAGDATE EQU   X'04'       DATE SPECIFIED
FLAGUID  EQU   X'02'       JUST USERID SPECIFIED
FLAGDSNF EQU   X'01'       FULL DSN SPECIFIED
*
          ORG
ZEROLEN   EQU     *-USERAREA
*
* DOUBLE WORD ALIGNED.
*
USERCVD  DS    D               WORK SPACE FOR CVD.
*
* FULL WORD ALIGNED.
*
USERCPPL DS    A               SAVE CPPL POINTER FOR FAIL ROUTINES
ULOCDSN  DS    0F
         ORG   *+LOCLEN        RESERVE RIGHT NO OF BYTES.
USERRACK DS    0F              RACHECK "LIST-FORM".
         ORG   *+RALEN         RESERVE RIGHT NO OF BYTES.
ENQQLST  DS    0F              ENQ PARAMETER LIST
         ORG   *+ENQLEN
USERANS  DS    A               RESULTS OF PARSE.
USERDML OPEN   (,),MF=L        DATA MANAGEMENT LIST
USERGFPL DS    A               GNRLFAIL PARAMETER LIST.
USERCODE DS    F               RETURN CODE FOR DAIRFAIL.
USERQDCB DS    0F              INPUT DCB.
         ORG   *+QDCBLEN
USERRBP  DS    F               REQUEST BLOCK POINTER.
USERRB   DS    0F              REQUEST BLOCK.
         ORG   *+S99RBLEN
USERTUPL DS    11F
USERSR14 DS    F              SAVE AREA FOR R14 IN SUBROUTINES.
CHAIN    DS    F              BEGINNING OF 'GETMAIN' CHAIN.
RECOUNT  DS    F              RECORD COUNT FOR 'GETRECOR'.
USERTEOD DS    F           SAFE PLACE FOR EODAD.
RETURNCO DS    F           RETURN CODE STORE AREA.
*
*        VSAM  USERAREA
*
USERACBP DS    F                   ACB ADDRESS
USERRPLP DS    F                   RPL ADDRESS
USERBUFP DS    F                   BUFFER ADDRESS
USERACB  DS    0F
         ORG   *+USERACBL
USERRPL  DS    0F
         ORG   *+USERRPLL
USERMOD  DS    0F
         ORG   *+USERMODL
USERSHOW DS    0F
         ORG   *+USERSLEN
USERFDBK DS    F
USERVKEY DS    CL44                KEY FOR KEYED SEARCHES OF TRACE
*
* NOT ALIGNED.
*
USERDDS  DS    CL8             RETURNED QUEUE DDNAME
USERDDT  DS    CL8             RETURNED TRACE DDNAME
USERUID  DS    CL7                USERID FROM PSCB
USERUIDT DS    CL8                USERID WITH TRAILING DOT
USERUIDL DS    X                  LENGTH OF USERID
LOCAREA  DS    0F
         DS    CL265
LOCTYPE  EQU   LOCAREA+2,4     LOCATED DEVICE TYPE
LOCVOL   EQU   LOCAREA+6,6     LOCATED VOLUME
*
*
USERDATE DS    CL6             SAFE PLACE FOR THE DATE.
USERMDAT DS    CL6             MAXIMUM DATE SEEN SO FAR
         DS    0F
USERMSG  DS    CL84               MESSAGE GENERATION AREA
*
* SVC99 TEXT UNITS AND DATA.
*
USERTU55 DS    CL(TU55L)
RETDDN   DS    CL8            RETURN DDNAME.
USERTU2  DS    CL(TU2L),AL2,CL44 DSNAME
USERTU4  DS    CL(TU4L),XL1   STATS.
*
* GENERAL WORK AREAS
*
USERDSN  DS    CL44          SAVE AREA FOR GIVEN DSN.
USERUSER DS    CL7                SAVE AREA FOR USER PARAMETER
USERULEN DS    X                  LENGTH OF USER PARAMETER
USERVOL  DS    CL6           SAVE AREA FOR GIVEN VOLID.
USERTDSN DS    CL44          SAVE AREA FOR RETURN DSN.
USERKEY  DS    CL8           SAVE AREA FOR GIVEN KEY.
USEROTYP DS    F             DEVICE TYPE OF ARCHIVED DATASET
USERKEEP DS    H             REQUEST ACTION FLAG SAVED FROM PDL
USERDECB DS    0F
         ORG   *+DECBL       OUR 'DATA EVENT CONTROL BLOCK'
USERLEN  EQU   *-USERAREA
         END
