* UTLPRINT                                                           **
* UTLPRINT IS A GENERALIZED PRINTING ROUTINE.  IT CAN PRINT          **
* IN DISPLAY FORMAT OR HEX.  THIS ROUTINE CAN ACCEPT AN              **
* ALTERNATE DDNAME LIST LIKE THE IBM UTILITIES, BUT                  **
* IN THIS DESCRIPTION I SHALL USE THE DEFAULT DDNAMES.               **
*                                                                    **
* UTLSYS01 - INPUT FILE                                              **
* UTLSYS02 - OUTPUT (PRINT FILE)                                     **
* UTLSYS04 - OUTPUT IMAGE FILE.  RECORDS SELECTED                    **
*      FOR PRINTING ARE COPIED TO THIS FILE.                         **
* UTLSYS05 - COMPLEMENT IMAGE FILE. RECORDS NOT SELECTED             **
*      FOR PRINTING ARE COPIED TO THIS FILE.                         **
*                                                                    **
* EACH FILE IS CHECKED TO SEE IF A DD CARD IS PROVIDED.              **
* IF SO THE FILE IS OPENED.  A SERIES OF CLOSED SUBROUTINES          **
* ARE USED FOR ALL IO AGAINST THE FILES.  IF THE OPEN BIT            **
* IN THE DCB IS NOT ON THE IO ON THE FILE IS BYPASSED.  THIS         **
* HAS THE EFFECT OF DUMMYING ALL UNDECLARED FILES.                   **
*                                                                    **
* UTLPRINT IS DIVIDED (BADLY) INTO THREE SEGMENTS                    **
*       1 - CONTROL BLOCKS AND INITIALIZATION                        **
*       2 - CONTROL CARD SCAN                                        **
*       3 - FILE PROCESSING.                                         **
* DUE TO THE SIZE OF UTLPRINT THE BASE REGISTERS 10-12 MUST          **
* BE ROLLED OVER AS THE PROGRAM MOVES FROM SEGMENT TO                **
* SEGMENT.  REGISTER 9 POINTS TO THE BEGINNING OF THE FIRST          **
* SEGMENT AND THEREFORE ALLOWS ADDRESSING OF CONTROL                 **
* BLOCKS THROUGH OUT EXECUTION.  WHEN ADDING FUNCTIONS               **
* BE SURE TO ADD CONTROL INFORMATION IN THE FIRST SEGMENT            **
* AND CODE TO WHAT EVER AREA NEEDS IT.                               **
* YOU MAY HAVE TO ADJUST THE LTORGS TO INSURE PROPER ADDRESSABILITY. **
*                                                                    **
* PROCESSING -                                                       **
* 1. LOOK FOR USER EXIT IN PARM LIST AND ALTERNATE DDNAME LIST.      **
* 2. CHECK TO SEE IF UTLSYS01 IS AN ISAM FILE AND ALTER THE          **
*       DCB POINTER IF IT IS.                                        **
* 3. OPEN THE FILES                                                  **
* 4. BUILD HEADING INFORMATION                                       **
* 5. SCAN THE CONTROL CARDS - DONE BY SCANNING FIRST FIELD           **
*       THEN SHIFTING WHOLE CARD TO THE LEFT AND REPEATING.          **
*       THE RESULT IS A SERIES OF CONTROL BLOCKS ONE FOR EACH START  **
*       STOP PAIR.                                                   **
* 6. COMPLETE CONTROL BLOCKS BY PROVIDING DEFAULT                    **
*      VALUES WHERE NOT GIVEN IN CONTROLS.                           **
* 7. INIITALIZE COUNTERS ET. AL.                                     **
* 8. CONTROL BLOCKS ARE NOW USED TO OVERLAY BRANCH                   **
*       CONDITIONAL MASKS THRU OUT THE CODE THEREBY                  **
*       ROUTING THE LOGIC TO PROPER OPTIONS.                         **
*       (AND THE STANDARDS VIOLATIONS ABOUND)                        **
* 9. MAIN PROCESSOR HARD TO DESCRIBE BECAUSE THE                     **
*       CODE HAS BEEN ALTERED BY NUMBER 8.                           **
* 10. FINALLY THE SUMMARIES ARE WRITTEN AND OPEN FILES ARE CLOSED.   **
* 11. CURRENTLY UTLPRINT ALWAYS GIVES A RETURN CODE                  **
*       OF 8.                                                        **
         TITLE ' UTLPRINT - PRINT UTILITY  '
         MACRO
&NAME    CHKPUT &OUTDCB,&BUFFER
&NAME    LA    R1,&OUTDCB
         USING IHADCB,R1
         TM    DCBOFLGS,MJOPNBIT - IF FILE IS CLOSE
         BNO   IHB&SYSNDX -           BY-PASS PUT
         PUT   (1),&BUFFER -        WRITE THE RECORD
IHB&SYSNDX EQU *
         DROP  R1
         MEND
         MACRO
&NAME    CHKCLOSE &DCBADDR
&NAME    LA    R1,&DCBADDR -       IS FILE OPEN
         USING IHADCB,R1
         TM    DCBOFLGS,MJOPNBIT
         BNO   IHB&SYSNDX -           NO - BYPASS CLOSE
         CLOSE &DCBADDR -          CLOSE THE DATA SET
IHB&SYSNDX EQU  *
         MEND
         GBLC  &UPDATE
         GBLA  &BYTE
&UPDATE  SETC   'A76300 '         *DATE UPDATED*
UTLPRINT CSECT ,    UTILITY PRINT ROUTINE                          MBJ1
         ENTRY AAENTER
AAENTER  SAVE  (14,12),,UTLPRINT-&UPDATE                           MBJ5
* ENTRY TO PROGRAM, INITIALIZING REGISTERS
         BALR  9,0
         USING AAINTLZ,9,10,11,12
AAINTLZ  LM    10,12,AABASEAD
         B     AASTRREG
* BRANCHING TO OPEN FILE ROUTINE
AABASEAD DC    A(AAINTLZ+4096,AAINTLZ+8192,AAINTLZ+12288)
AASTRREG ST    13,XZSAVERG+4
         LA    2,XZSAVERG
         ST    2,8(0,13)
         LA    13,XZSAVERG
         B     ABOPEN
*
*
*                        REGISTER  NAMES
*
*
R8       EQU   8
ASMDAT   DC    C'        '        *DATE UPDATED*   Y ASSEMBLY DATE MBJ1
         TITLE 'MODIFICATION HISTORY'
* COL 68-71
*
*  MBJ1        CHANGES BY M.B. JENCKS
*                UTLSIEVE (UTLSYS04) FEATURE
*                USER EXIT
*                ALTERNATE DDNAME LIST
*
*  RHC1        CHANGES BY R.H. CLINTON
*                ISAM INPUT SUPPORT
*
*  RHC2        CHANGES BY R.H. CLINTON
*                COMPLEMENT FILE (UTLSYS05)
*                FILE SUMMARY
*                EXIT NAME PARAMETER ON CONTROL CARD
*  MBJ3        CHANGES BY M.B. JENCKS
* CORRECT ALTERNATE DDNAME TRUCATION             DEC 74            MBJ3
* MBJ4         CHANGES BY MURRAY JENCKS JUNE 75
*               EXPAND USER EXIT PARM
*               RESTORE FREE POOL
* MBJ5         PREVENT KEY FROM OVER RUNNING END OF RECORD (0C4 MVS)
         TITLE ' UTLPRINT  DCB  '                                  MBJ1
         PRINT NOGEN          NO NEED TO EXPAND THE DCB'S          MBJ1
* * * * THIS FILE CONTAINS THE UTLPRINT CONTROL CARDS WHICH SPECIFY
*       THE DESIRED OPTIONS.
CARDIN    DCB  DSORG=PS,MACRF=GL,                                      -
               DDNAME=UTLSYSIN,                                        -
               RECFM=FB,LRECL=80,                                      -
               EODAD=AQEOFCRD
         SPACE 3                                                   MBJ1
* * * * THIS FILE IS FOR DISPLAYING A LISTING OF THE CONTROL CARDS,
*       ERROR MESSAGES AND PROCESSING MESSAGES ON SYSOUT
SSOUTSET DCB   DSORG=PS,MACRF=PM,                                      -
               DDNAME=SYSOUT,                                          -
               RECFM=FBA,LRECL=120,BLKSIZE=120,                        -
               EODAD=DEOFDATA
         SPACE 3                                                   MBJ1
* * * * THIS IS THE OUTPUT FILE FOR THE DATA CONVERTED TO DISPLAY OR
*       HEX FORMAT - THE FILE MAY BE SPOOLED OR DIRECTED TO SYSOUT
PRINTSET DCB   DSORG=PS,MACRF=PM,                                      -
               DDNAME=UTLSYS02,                                        -
               RECFM=FBA,LRECL=132,BLKSIZE=3432,                       -
               EODAD=DEOFDATA
         SPACE 3                                                   MBJ1
* * * * THIS FILE IS FOR CONTROL CARDS GENERATED FROM RECORD NUMBERS
*       WHICH ARE USED BY PTA IN A PROGRAM TO DROP RECORDS FROM A
*       FILE.
CNTRSET  DCB   DSORG=PS,MACRF=PM,                                      -
               DDNAME=UTLSYS03,                                        -
               RECFM=F,LRECL=80,BLKSIZE=80,                            -
               EODAD=DEOFDATA
         SPACE 3                                                   MBJ1
* * * * THIS IS THE INPUT FILE TO BE PRINTED. WHEN DCB ATTRIBUTES
*       CANNOT BE FOUND INTERNALLY AS WITH A NO LABEL TAPE, THEY
*       MUST BE SPECIFIED IN THE JCL.
DATASET  DCB   DSORG=PS,MACRF=GL,                                      -
               DDNAME=UTLSYS01,                                        -
               EXLST=AAEXLST,                                          -
               EODAD=DEOFDATA
         SPACE 3                                                   MBJ1
ISAMSET  DCB  DDNAME=UTLSYS01,                                     RHC1X
               DSORG=IS,                                           RHC1X
               MACRF=(GL),                                         RHC1X
               EXLST=AAEXLST,                                      RHC2X
               EODAD=DEOFDATA                                      RHC1
         EJECT
MJSIEVE  DCB   DDNAME=UTLSYS04,                                        -
               DEVD=DA,                                                -
               DSORG=PS,                                               -
               MACRF=PM,                                               -
               EXLST=UT4LST
*                                  ADD AN OPEN EXIT
* * * * THIS OPEN EXIT MOVES THE DCB INFORMATION FROM UTLSYS01 TO  RHC2
*       UTLSYS05 IF NO DCB INFO IS CODED ON THE UTLSYS05 DD CARD.  RHC2
UTLSYS05 DCB   DDNAME=UTLSYS05,                                    RHC2X
               DEVD=DA,                                            RHC2X
               DSORG=PS,                                           RHC2X
               MACRF=PM,                                           RHC2X
               EXLST=UT5LST                                        RHC2
         SPACE 1                                                   MBJ5
* * * * THIS OPEN EXIT MOVES THE DCB INFORMATION FROM UTLSYS01 TO
*       UTLSYS04 IF NO DCB INFO IS CODED ON THE UTLSYS04 DD CARD.
UT4LST   DS    0F                  INDICATES AN OPEN-EXIT
         DC    X'85'
         DC    AL3(COMPDCB)
COMPDCB  LA    REG04,MJSIEVE                      LOOKING AT UTLSYS04,
         USING IHADCB,REG04                            IF NO RECFM
         CLC   DCBRECFM,=X'00'                         CODED MOVE FROM
         BNZ   LLRECL                                  UTLSYS01
         MVC   DCBRECFM(1),DATASET+(DCBRECFM-IHADCB)
LLRECL   CLC   DCBLRECL,=X'0000'                       IF NO LRECL
         BNZ   BBLKSZ                                  CODED MOVE FROM
         MVC   DCBLRECL(2),DATASET+(DCBLRECL-IHADCB)   UTLSYS01
BBLKSZ   CLC   DCBBLKSI,=X'0000'                       IF NO BLKSIZE
         BNZ   END                                     CODED MOVE FROM
         MVC   DCBBLKSI,DATASET+(DCBBLKSI-IHADCB)      UTLSYS01
         DROP   REG04
END      BR    14
UT5LST   DS    0F                                                  RHC2
         DC    X'85'                                               RHC2
         DC    AL3(COMPDCB5)                                       RHC2
COMPDCB5 LA    REG04,UTLSYS05                                      RHC2
         USING IHADCB,REG04                                        RHC2
         CLC   DCBRECFM,=X'00'                                     RHC2
         BNZ   LLRECL5                                             RHC2
         MVC   DCBRECFM(1),DATASET+(DCBRECFM-IHADCB)               RHC2
LLRECL5  CLC   DCBLRECL,=X'0000'                                   RHC2
         BNZ   BBLKSZ5                                             RHC2
         MVC   DCBLRECL(2),DATASET+(DCBLRECL-IHADCB)               RHC2
BBLKSZ5  CLC   DCBBLKSI,=X'0000'                                   RHC2
         BNZ   END5                                                RHC2
         MVC   DCBBLKSI,DATASET+(DCBBLKSI-IHADCB)                  RHC2
         DROP  REG04                                               RHC2
END5     BR    14                                                  RHC2
         SPACE 1                                                   MBJ5
         USING MJDDLIST,RDDALT     ADDRESS ALTERNATE NAMES         MBJ1
*        TARGETS OF EXECUTES - INDEXING CAUSES PROPER ONE TO GO    MBJ1
MJLADDNM LA     R3,MJDDIN          ALTERNATE TO 'UTLSYSIN'         MBJ1
         LA     R3,MJDDOUT                      'SYSOUT'           MBJ1
         LA     R3,MJDD1                        'UTLSYS01'         MBJ1
         LA     R3,MJDD2                        'UTLSYS02'         MBJ1
         LA     R3,MJDD3                        'UTLSYS03'         MBJ1
         LA     R3,MJDD4                        'UTLSYS04'         MBJ1
         LA    R3,MJDD5                         'UTLSYS05'         RHC2
MJMAXDD  DC    Y(*-MJLADDNM)       HIGHESTOF RDDCONT AT MJNEXTDD   MBJ3
MJLADCBS LA     R2,CARDIN          DCB FOR DDNAME 'UTLSYSIN'       MBJ1
         LA     R2,SSOUTSET                       'SYSOUT'         MBJ1
         L     R2,ADATASET                        'UTLSYS01'       RHC1
         LA    R2,PRINTSET         'UTLSYS02'                      RHC1
         LA     R2,CNTRSET                        'UTLSYS03'       MBJ1
         LA     R2,MJSIEVE                        'UTLSYS04'       MBJ1
         LA    R2,UTLSYS05                        'UTLSYS05'       RHC2
         DROP  RDDALT                                              MBJ1
ADATASET DC    A(DATASET)          INCOMING DCB                    RHC1
         TITLE ' UTLPRINT '                                        MBJ1
         PRINT GEN            GET MACROS BACK                      MBJ1
ANPTSYS2 MVI   WSWDMP,C'1'
* * * * PRINTING OF ERROR MESSAGES, CONTROL CARDS OR SUMMARY
*       PROCESSING INFORMATION
ANPTSYS1 EQU   *                                                   MBJ1
         CHKPUT SSOUTSET,SYSLINE                                   MBJ1
         MVC   SYSDATA,SYSDATA-1
         BALR  REG08,REG08
* * * * PRINTING OF FIRST HEADER LINE OF PRINTED DATA AT TOP OF PAGE
ANPTHDRA EQU   *                                                   MBJ1
         CHKPUT PRINTSET,AHEADRLN                                  MBJ1
         BALR  REG08,REG08
* * * * PRINTING OF SECOND HEADER LINE OF PRINTED DATA AT TOP OF PAGE
*       OR AT BOTTOM OF PAGE
ANPTHDRB EQU   *                                                   MBJ1
         CHKPUT PRINTSET,BHEADRLN                                  MBJ1
         BALR  REG08,REG08
* * * * PRINTING A LINE OF DATA IN DISPLAY OR HEX FORMAT
ANPTDTAC EQU   *                                                   MBJ1
         CHKPUT PRINTSET,CDATALN                                   MBJ1
         MVC   CDATALN,CDATALN-1
         BALR  REG08,REG08
         TITLE ' UTLPRINT - CONSTANTS AND CONTROL BLOCKS'          MBJ1
         DS    D
AAEXLST  DC   X'87'
         DC    AL3(XZJFCBDS)
ABJFCB1  RDJFCB (DATASET),MF=L
* * * * PRINTLINE FOR FIRST HEADER LINE OF PRINTED DATA
AHEADRLN DS    0CL132
         DC    CL1'1'
         DC    CL1' '
AHDRDD   DC    CL3' '
AHDRMM   DC    CL5' '
AHDRYY   DC    CL2' '
         DC    CL3' '
AHDRHOUR DC    CL2' '
         DC    CL1'.'
AHDRMIN  DC    CL2' '
         DC    CL3' '
AHDRDSNM DC    CL44' '
AHDRTITL DC    CL59' '
AHDRPGNR DC    CL6' '
         DS    F
* * * * PRINTLINE FOR SECOND AND FINAL HEADER LINE OF PRINTED DATA
BHEADRLN DS    0CL132
         DC    CL1'0'
         DC    CL17' '
BHDRDATA DS    0CL100
* HEADER LINE 2 OF THE PRINT DATA SET
         DC    CL40'....5...10....5...20....5...30....5...40'
         DC    CL40'....5...50....5...60....5...70....5...80'
         DC    CL20'....5...90....5...00'
         DC    CL14' '
         DC    CL4' '
* * * * PRINTLINE FOR CONVERTED DATA IN HEX OR DISPLAY FORMAT
CDATALN  DS    0CL132
CCDIG    DS    CL1
         DS    CL4
CDATARNR DS    CL10
         DS    CL3
CDATAINF DS    CL100
         DS    CL8
CDATATO  DS    CL6
         DS    D
* * * * PRINTLINE FOR SYSOUT MESSAGES
SYSLINE  DS    0CL120
         DC    CL10' '
SYSDATA  DC    CL100' '
         DC    CL10' '
         ORG   SYSDATA                                             RHC2
SYSDT1   DS    C'DDNAME'                                           RHC2
         ORG   SYSDATA+10                                          RHC2
SYSDT2   DS    C'DSORG'                                            RHC2
         ORG   SYSDATA+17                                          RHC2
SYSDT3   DS    C'RECFM'                                            RHC2
         ORG   SYSDATA+24                                          RHC2
SYSDT4   DS    C'LRECL'                                            RHC2
         ORG   SYSDATA+31                                          RHC2
SYSDT5   DS    C'BLKSIZE'                                          RHC2
         ORG   SYSDATA+13                                          RHC2
SYSDT6   DS    C'FILE SUMMARY'                                     RHC2
         ORG   SYSDATA                                             RHC2
SYSDDDNM DS    CL8                                                 RHC2
         ORG   SYSDATA+11                                          RHC2
SYSDDSOR DS    CL3                                                 RHC2
         ORG   SYSDATA+17                                          RHC2
SYSDRECF DS    CL5                                                 RHC2
         ORG   SYSDATA+24                                          RHC2
SYSDLREC DS    CL5                                                 RHC2
         ORG   SYSDATA+32                                          RHC2
SYSDBLKS DS    CL5                                                 RHC2
         ORG   SYSDATA+110                                         RHC2
* * * * STORAGE AREAS AND CONTANTS FOR SUMMARY LINE
EOJCNST  DS    0CL100
         DC    CL32'****  PROCESSING ENDED AT EOD'
EOJINREC DS    CL10
         DC    CL12' RECORDS IN'
EOJPRREC DS    CL10
         DC    CL19' RECORDS PROCESSED'
EOJPRPGS DS    CL6
         DC    CL11' PAGES ****'
* * * * HEADER FOR HEX PRINTING
WCHDRHEX DS    0CL100
         DC    CL34'. . . 1 . . . 2  . . . 3 . . . 4'
         DC    CL34'. . . 5 . . . 6  . . . 7 . . . 8'
         DC    CL32'...1...2...3...4...5...6...7...8'
* * * * HOLDING AREAS FOR CONTROL CARD PARMETERS
HOLDAREA DS    0CL160
HOLDCARD DC    CL80' '
         DC    XL8'FFFFFFFFFFFFFFFF'
         DC    CL72' '
* * * * FLAGS FOR THE VARIOUS OPTIONS
WSWNOSPC DC    CL1' '
WSWHEX   DC    X'00'
WSWDMPNO DC    CL1'0'
WSWDMP   DC    CL1'0'
WSWSRCH  DC    X'F0'
WSWCTRST DC    X'F0'
WCSPACES DC    CL32' '
SRCHOR   DC    CL1'0'
* * * * WORK AREAS FOR CONVERSION OF DATA TO HEX.
WDHLDHX2 DS    CL32
         DS    CL32
WDHLDHX3 DS    CL32
         DS    CL32
* * * * COUNTERS FOR NUMBER OF BYTES TO BE PRINTED, FROM AND TO
*       VALUES OF BYTES PRINTED, AND LINE AND PAGE NUMBERS.
XDCHARS  DC    PL3'0'
XDDATAFR DC    PL3'0'
XDDATATO DC    PL3'0'
XDFRCON  DC    PL2'0'
XDLNCNT  DC    PL2'0'
XDPGCNT  DC    PL3'0'
* * * * SAVE AREAS FOR REGISTER VALUES
XDSTRG00 DS    F
XDSTRG01 DS    F
XDSTRG08 DS    F
* * * * BYTE COUNTERS AND VARIABLE LENGTH RECORD CONSTANT
XDMVCHAR DS    CL1
XDRECLAD DC    PL1'0'
XDRECLST DC    PL3'0'
XDRECLW1 DC    PL3'0'
XDRECLW2 DC    PL3'0'
XDRECLW3 DC    PL3'0'
* * * * AREAS ASSOCIATED WITH REFORMATING SYSTEM DATE
XDDAYSUB DS    PL2
XDYYDIV  DS    PL3
* * * * STORAGE FOR OPTION VALUES AND RECORD COUNTERS
XDSTUNPK DS    CL8
XGSTRT   DC    PL5'0'
XGPRNT   DC    PL5'999999999'
XGSKIP   DC    PL5'1'
XGSTRT1  DC    CL9'000000000'
XGPRNT1  DC    CL9'999999999'
XGSKIP1  DC    CL9'000000001'
XGSTRT2  DC    CL9'000000000'
XGPRNT2  DC    CL9'999999999'
XGSKIP2  DC    CL9'000000001'
XGSTRT3  DC    CL9'000000000'
XGPRNT3  DC    CL9'999999999'
XGSKIP3  DC    CL9'000000001'
         DC    CL9'999999999'
ZEROS    DC    PL5'0'
XGRECCNT DC    PL5'0'
XGRECPRC DC    PL5'0'
XGTOTPRT DC    PL5'0'
XGSKPPRC DC    PL5'999999997'
XHSCNOPT DS    CL4
* * * * STORAGE FOR SEARCH KEYWORDS, DELIMITERS AND THEIR VALUES
*       FOR VERIFICATION
XKDLMTR  DS    CL1
SEQNUM   DS    CL1
         DC    CL1'0'
XENUMTST DS    CL9
* * * * EDIT PATTERNS FOR RECORD NUMBER AND NUMBER OF BYTES PRINTED
XPTRN9   DC    X'40202020202020202020'
XPTRN5   DC    X'402020202020'
* * * * FROM-TO AREA AND CONSTANT
XPFROMTO DS    0CL9
XPTRNFR  DS    CL6
         DC    C' TO'
         DS    F
* * * * STORAGE FOR SS-1 OPTIONS
XHS1OPT  DS    0CL34
XHS1FL   DS    F
XHS1SW1  DC    CL1'0'
XHS1SW2  DC    CL1'0'
XHS1SW3  DC    X'FF'
XHS1SW4  DC    X'FF'
XHS1F    DC    CL4'0000'
XHS1C    DC    X'B0'
XHS1L    DC    X'FF'
XHS1K    DC    CL20' '
         DS    F
* * * * STORAGE FOR SS-2 OPTIONS
XHS2OPT  DS    0CL34
XHS2FL   DS    F
XHS2SW1  DC    CL1'0'
XHS2SW2  DC    CL1'0'
XHS2SW3  DC    X'FF'
XHS2SW4  DC    X'FF'
XHS2F    DC    CL4'0000'
XHS2C    DC    X'B0'
XHS2L    DC    X'FF'
XHS2K    DC    CL20' '
         DS    F
* * * * STORAGE FOR SS-3 OPTIONS
XHS3OPT  DS    0CL34
XHS3FL   DS    CL4
XHS3SW1  DC    CL1'0'
XHS3SW2  DC    CL1'0'
XHS3SW3  DC    X'FF'
XHS3SW4  DC    X'FF'
XHS3F    DC    CL4'0000'
XHS3C    DC    X'B0'
XHS3L    DC    X'FF'
XHS3K    DC    CL20' '
         DS    F
* * * * STORAGE FOR SS-4 OPTIONS
XHS4OPT  DS    0CL34
XHS4FL   DS    F
XHS4SW1  DC    CL1'0'
XHS4SW2  DC    CL1'0'
XHS4SW3  DC    X'FF'
XHS4SW4  DC    X'FF'
XHS4F    DC    CL4'0000'
XHS4C    DC    X'B0'
XHS4L    DC    X'FF'
XHS4K    DC    CL20' '
         DS    F
* * * * STORAGE FOR SH-1 OPTIONS
XHH1OPT  DS    0CL34
XHH1FL   DS    F
XHH1SW1  DC    CL1'0'
XHH1SW2  DC    CL1'0'
XHH1SW3  DC    X'FF'
XHH1SW4  DC    X'FF'
XHH1F    DC    CL4'0000'
XHH1C    DC    X'B0'
XHH1L    DC    X'FF'
XHH1K    DC    CL20' '
         DS    F
* * * * STORAGE FOR SH-2 OPTIONS
XHH2OPT  DS    0CL34
XHH2FL   DS    F
XHH2SW1  DC    CL1'0'
XHH2SW2  DC    CL1'0'
XHH2SW3  DC    X'FF'
XHH2SW4  DC    X'FF'
XHH2F    DC    CL4'0000'
XHH2C    DC    X'B0'
XHH2L    DC    X'FF'
XHH2K    DC    CL20' '
         DS    F
* * * * STORAGE FOR SH-3 OPTIONS
XHH3OPT  DS    0CL34
XHH3FL   DS    F
XHH3SW1  DC    CL1'0'
XHH3SW2  DC    CL1'0'
XHH3SW3  DC    X'FF'
XHH3SW4  DC    X'FF'
XHH3F    DC    CL4'0000'
XHH3C    DC    X'B0'
XHH3L    DC    X'FF'
XHH3K    DC    CL20' '
         DS    F
* * * * STORAGE FOR SH-4 OPTIONS
XHH4OPT  DS    0CL34
XHH4FL   DS    F
XHH4SW1  DC    CL1'0'
XHH4SW2  DC    CL1'0'
XHH4SW3  DC    X'FF'
XHH4SW4  DC    X'FF'
XHH4F    DC    CL4'0000'
XHH4C    DC    X'B0'
XHH4L    DC    X'FF'
XHH4K    DC    CL20' '
         DS    F
* * * * WORKING STORAGE FOR ALL OF THE SEARCH OPTIONS
XHHLDSCN DS    0CL34
XHHLDFL  DS    F
XHHLDSW  DC    CL1'0'
XHHLDSW2 DC    CL1'0'
*        MASK FIRST HALF BYTE.  ANDED INTO RECORD KEY FOR CLC      MBJ5
XHHLDSW3 DC    X'FF'
*        MASK LAST HALF BYTE.  ANDED INTO RECORD KEY FOR HALT CLC  MBJ5
XHHLDSW4 DC    X'FF'
XHHLDF   DC    CL4'0000'
XHHLDC   DC    X'B0'
*                                   LENGTH OF SCAN KEY (LESS ONE   MBJ5
*                                   FOR EX  USAGE)                 MBJ5
XHMOVCHR DC    X'FF'
*                                   SCAN KEY HOLDER                MBJ5
XHKFLD   DC    CL20' '
XZSAVERG DS    18F'0'
XZHLDNR  DS    D
         DS    D
WCTRNTB1 DS    0CL256
* TRANSLATE AREA USED TO TRANSFORM UNPRINTABLE CHARACTERS INTO
* ASTERISKS
         DC    C'****************'
         DC    C'****************'
         DC    C'****************'
         DC    C'****************'
         DC    C' **********.*(+*'
         DC    C'&&**********$*)+*' 5                              MBJ1
         DC    C'-/*********,****'  6  PERCENT UNPRINTABLE         MBJ1
         DC    C'*************''=*' 7  AT AND POUND UNPRINTABLE    MBJ1
         DC    C'****************'
         DC    C'****************'
         DC    C'****************'
         DC    C'****************'
         DC    C'*ABCDEFGHI******'
         DC    C'*JKLMNOPQR******'  D                              MBJ1
         DC    C'**STUVWXYZ******'
         DC    C'0123456789******'
WCTRNTB2 DS    0CL256
* TRANSLATE TABLE USED FOR HEXADECIMAL REPRESENTATION OF THE FIRST
* FOUR BITS OF A BYTE
         DC    C'00000000000000001111111111111111'
         DC    C'22222222222222223333333333333333'
         DC    C'44444444444444445555555555555555'
         DC    C'66666666666666667777777777777777'
         DC    C'88888888888888889999999999999999'
         DC    C'AAAAAAAAAAAAAAAABBBBBBBBBBBBBBBB'
         DC    C'CCCCCCCCCCCCCCCCDDDDDDDDDDDDDDDD'
         DC    C'EEEEEEEEEEEEEEEEFFFFFFFFFFFFFFFF'
WCTRNTB3 DS    0CL256
* TRANSLATE TABLE FOR HEXADECIMAL REPRESENTATION OF THE SECOND
* FOUR BITS OF A BYTE
         DC    C'0123456789ABCDEF0123456789ABCDEF'
         DC    C'0123456789ABCDEF0123456789ABCDEF'
         DC    C'0123456789ABCDEF0123456789ABCDEF'
         DC    C'0123456789ABCDEF0123456789ABCDEF'
         DC    C'0123456789ABCDEF0123456789ABCDEF'
         DC    C'0123456789ABCDEF0123456789ABCDEF'
         DC    C'0123456789ABCDEF0123456789ABCDEF'
         DC    C'0123456789ABCDEF0123456789ABCDEF'
XZTRTTBL DS    0CL256
XZJFCB   DS    0CL352
XZJFCBDS DC    CL44' '
XZJFCBXX DS    CL308
         TITLE ' UTLPRINT '                                        MBJ1
ABOPEN   EQU   *                   CHECK FOR PARM -                MBJ1
*                           WORD1  EXEC PARM='EXIT=EXITNAME'       MBJ1
*                           WORD2  ALTERNATE DDNAME LIST           MBJ1
*  IF SYSIN DD STMT IS PRESENT AND UTLSYSIN IS NOT,                RHC2
*  THEN MAKE DDNAME FIELD OF CARDIN DCB = SYSIN.                   RHC2
*
         LR    RPARM,R1            SAVE PARM LIST POINTER          RHC2
         DEVTYPE CARDIN+40,MJDDBOX                                 RHC2
         LTR    15,15                                              RHC2
         BZ    SYSIN099                                            RHC2
         DEVTYPE =CL8'SYSIN   ',MJDDBOX                            RHC2
         LTR   15,15                                               RHC2
         BNZ   SYSIN099                                            RHC2
         MVC   CARDIN+40(8),=CL8'SYSIN   '                         RHC2
SYSIN099 EQU   *
         LTR   RPARM,RPARM         IS THERE A PARM LIST?           RHC2
         BZ    NOPARM              NO- GO ON WITH OPENS            MBJ1
         L     REXIT,0(RPARM)      GET ADDRESS OF EXEC PARM        MBJ1
         CALL  EXITPARM,((REXIT),SSOUTSET,MJEXITEP,MJEXITIN),VL,   MBJ5X
               ID=*-UTLPRINT       PULL EXIT NAMES                 MBJ5
MJTRYDDS EQU   *   SEE IF A DDNAME LIST EXISTS AND IF SO           MBJ1
*                  MOVE DDNAMES INTO ASSOCIATED DCBS.              MBJ1
         LTR   REXIT,REXIT         IS END OF LIST FLAG ON          MBJ1
         BM    MJOPEN              YES - NO DDNAMES                MBJ1
*                                  DON'T ALLOW BYPASS OF UTLSYSIN  MBJ5
*                                  WHEN ALTERNATE DDNAMES COMEIN   MBJ5
         LA    R2,CARDIN                                           MBJ5
         USING IHADCB,R2                                           MBJ5
         MVC   DCBDDNAM,=CL8'UTLSYSIN' FORCE CONTROL DDNAME        MBJ5
*                                  ALLOWING USER TO USE IT UNMOLESTED
         DROP  R2                                                  MBJ5
         L     RDDALT,4(RPARM)     GET ADDRESS OF ALTERNATE        MBJ1
*                                      DDNAME LIST                 MBJ1
         USING MJDDLIST,RDDALT                                     MBJ1
         LH    RLEN,MJDDLEN        GET LENGTH OF LIST              MBJ1
         LA    RDDEND,0(RLEN,RDDALT)   POINT TO END OF TABLE       MBJ1
         SR    RDDCONT,RDDCONT     CLEAR DDNAME CONTROLLER         MBJ1
MJNEXTDD EQU   *                   CHECK TO SEE IF FIRST/NEXT      MBJ1
*                                       DDNAME IN LIST IF SO SEE   MBJ1
*                                       IF ENTRY NON-ZERO,         MBJ1
*                                       IF SO MOVE INTO APROPO     MBJ1
*                                       DCB                        MBJ1
         EX    R0,MJLADDNM(RDDCONT)     LOAD ADDR OF 1ST/NEXT DDNAME
*                                  INTO R3                        MBJ3
         CR    R3,RDDEND           IS ENTRY IN TABLE               MBJ1
         BNL   MJOPEN              NO - GOTO OPEN                 MBJ3
*                                  YES- SEE IF ENTRY PRESENT       MBJ1
         CLC   MJ8ZEROS,0(R3)      IS ENTRY BINARY ZEROS           MBJ1
         BE    MJDDBUMP            YES - BYPASS MOVE               MBJ1
         EX    R0,MJLADCBS(RDDCONT)     LA R2,-DCB IN QUESTION     MBJ1
         USING IHADCB,R2           ADDRESS THE DCB                 MBJ1
         MVC   DCBDDNAM,0(R3)      MOVE IN NEW DDNAME              MBJ1
MJDDBUMP EQU   *                   BUMP TO NEXT DDNAME AND TRY AGAIN
         LA    RDDCONT,4(RDDCONT)  CHANGE ALL EXECUTES             MBJ1
         CH    RDDCONT,MJMAXDD     GEN ONLY MJMAXDD ENDTIES        MBJ3
         BNL   MJOPEN                                              MBJ3
         B     MJNEXTDD                                            MBJ1
         DROP  RDDALT                                              MBJ1
         SPACE 1                                                   MBJ1
MJOPLA   LA    R2,SSOUTSET                                         MBJ1
         LA    R2,PRINTSET                                         MBJ1
         L     R2,ADATASET                                         RHC1
         LA    R2,MJSIEVE                                          MBJ1
         LA    R2,UTLSYS05                                         RHC2
MJOPLIST LA    R1,MJSOLIST         LOAD ADDRESS OF OPENLISTS       MBJ1
         LA    R1,MJPOLIST                                         MBJ1
         LA    R1,MJDOLIST                                         MBJ1
         LA    R1,MJSVLIST                                         MBJ1
         LA    R1,UTL5LIST                                         RHC2
MJSOLIST OPEN  (SSOUTSET,(OUTPUT)),MF=L                            MBJ1
MJPOLIST OPEN  (PRINTSET,(OUTPUT)),MF=L                            MBJ1
MJDOLIST OPEN  (DATASET,(INPUT)),MF=L,TYPE=J                       RHC2
MJSVLIST OPEN  (MJSIEVE,(OUTPUT)),MF=L                            MBJ1
UTL5LIST OPEN  (UTLSYS05,(OUTPUT)),MF=L
*        CHECK TO SEE THAT A DD CARD IS PRESENT - THEN OPEN        MBJ1
*        THE DCB - SSOUTSET PRINTSET, DATASET MJSIEVE              MBJ1
MJOPEN   EQU   *                                                   MBJ1
NOPARM   EQU   *                   MJOPEN OTHER NAME
         RDJFCB MF=(E,ABJFCB1)
*  IF DSORG=IS OR ISU CODED ON DD STMT                             RHC1
*  THEN POINT INPUT TO QISAM DCB                                   RHC1
         TM    XZJFCBDS+98,X'80'                                   RHC1
         BZ    NOTISAM                                             RHC1
         LA    R2,ISAMSET                                          RHC1
         ST    R2,ADATASET                                         RHC1
         L     R2,MASKFF
         N     R2,MJDOLIST                                         RHC1
         O     R2,ADATASET                                         RHC1
         ST    R2,MJDOLIST                                         RHC1
         MVC   DCBDDNAM,DATASET+(DCBDDNAM-IHADCB)
         MVC   ISAMSET+26(2),XZJFCBDS+98                           RHC1
NOTISAM  EQU   *                                                   RHC1
         CALL  VTOCCK1,(XZJFCBDS),VL READ VTOC IF REQUESTED        MBJ5
         LA    RDDLOOP,5           CHECK FOR PRESENCE OF 5 DDNAMES RHC2
*                                  AND OPEN THEM                   MBJ1
         SR    RDDCONT,RDDCONT     CLEAR EX CONTROLER              MBJ1
MJOPLOOP EQU   *                                                   MBJ1
         EX    *-*,MJOPLA(RDDCONT) LA R2,- DCB OF FIRST/ NEXT FILE MBJ1
*                                  R2 STILL ADDRESSING IHADCB      MBJ1
         DEVTYPE DCBDDNAM,MJDDBOX  IS THIS DD NAME PRESENT         MBJ1
         LTR   R15,R15                                             MBJ1
         BNZ   MJOP2               NON-ZERO RETURN - NO DD CARD    MBJ1
         C     R15,MJDDBOX         IF ANSWER BOX ZERO - DD DUMMY   MBJ1
         BE    MJOP2                                               MBJ1
         EX    *-*,MJOPLIST(RDDCONT)   LA R1,- OPEN PARM LIST      MBJ5
         OPEN  ,MF=(E,(1))         OPEN THE DCB                    MBJ1
MJOP2    EQU   *                   LOOK AT  NEXT DCB               MBJ1
         LA    RDDCONT,4(RDDCONT)  BUMP EX TARGETS                 MBJ1
         BCT   RDDLOOP,MJOPLOOP    OPEN ALL FOUR DCB'S IF PRESENT  MBJ1
         DROP  R2                                                  MBJ1
* * * * INPUT DATA SET IS CHECKED FOR VARIABLE LENGTH RECORDS
*       SO THAT THE FIRST FOUR BYTES OF LLBB ON EACH RECORD WILL
*       NOT BE PRINTED IF THE RECORDS ARE VARIABLE LENGTH.
         USING IHADCB,REG03
         L     REG03,ADATASET                                      RHC1
         TM    DCBRECFM,DCBRECF    FIXED LENGTH RECORDS            MBJ5
         BO    TIMEDATE            YES - NO VARIALE ADJUSTMENT     MBJ5
         ZAP   XDRECLAD,=P'4'
* * * * THE TIME AND DATE OF JOB EXECUTION ARE RETRIEVED FOR THE
*       MAIN HEADING LINE OF THE PRINTED DATA.
TIMEDATE TIME
         ST    REG00,XDSTRG00
         ST    REG01,XDSTRG01
         UNPK  XDSTUNPK,XDSTRG00
         MVC   AHDRHOUR(2),XDSTUNPK+1
         MVC   AHDRMIN(2),XDSTUNPK+3
         UNPK  XDSTUNPK,XDSTRG01
         MVC   AHDRYY(2),XDSTUNPK+3
         PACK  XDYYDIV,AHDRYY
         MVC   XDDAYSUB(2),XDSTRG01+2
         MVC   AHDRMM,=C' JAN '
         BAL   REG08,ABCMPR31
         MVC   AHDRMM,=C' FEB '
         DP    XDYYDIV,=P'4'
         CP    XDYYDIV+2(1),=P'0'
         BE    LEAPYEAR
         CP    XDDAYSUB,=P'29'
         BL    ABMOVDAY
         B     CHKMARCH
LEAPYEAR CP    XDDAYSUB,=P'30'
         BL    ABMOVDAY
         SP    XDDAYSUB,=P'1'
CHKMARCH SP    XDDAYSUB,=P'28'
         MVC   AHDRMM,=C' MAR '
         BAL   REG08,ABCMPR31
         MVC   AHDRMM,=C' APR '
         BAL   REG08,ABCMPR30
         MVC   AHDRMM,=C' MAY '
         BAL   REG08,ABCMPR31
         MVC   AHDRMM,=C' JUN '
         BAL   REG08,ABCMPR30
         MVC   AHDRMM,=C' JUL '
         BAL   REG08,ABCMPR31
         MVC   AHDRMM,=C' AUG '
         BAL   REG08,ABCMPR31
         MVC   AHDRMM,=C' SEP '
         BAL   REG08,ABCMPR30
         MVC   AHDRMM,=C' OCT '
         BAL   REG08,ABCMPR31
         MVC   AHDRMM,=C' NOV '
         BAL   REG08,ABCMPR30
         MVC   AHDRMM,=C' DEC '
         B     ABMOVDAY
ABCMPR30 CP    XDDAYSUB,=P'31'
         BL    ABMOVDAY
         SP    XDDAYSUB,=P'30'
         BALR  REG08,REG08
ABCMPR31 CP    XDDAYSUB,=P'32'
         BL    ABMOVDAY
         SP    XDDAYSUB,=P'31'
         BALR  REG08,REG08
ABMOVDAY UNPK  AHDRDD,XDDAYSUB
         MVI   AHDRDD,X'40'
         OI    AHDRDD+2,X'F0'
* * * * RETRIEVE DATA SET NAME FROM JOB CONTROL BLOCK FOR THE
*       MAIN HEADING LINE OF THE PRINTED DATA.
         CALL  TITLDSN,(XZJFCBDS,AHDRDSNM)  PLACE DSNAME IN HDING  MBJ5
         LA    R2,CARDIN           IF INPUT FILE ABSENT OR DUMMIED MBJ1
*                                       USE DEFAULTS               MBJ1
         DROP  REG03                                               MBJ1
         USING IHADCB,R2                                           MBJ1
         DEVTYPE DCBDDNAM,MJDDBOX                                  MBJ1
         LTR   R15,R15             IS IT PRESENT                   MBJ1
         BNZ   AQEOFCRD            NO - ACT AS IF EODAD HI7        MBJ1
         C     R15,MJDDBOX         DUMMIED                         MBJ1
         BE    AQEOFCRD            YES- EODAD                      MBJ1
         OPEN  (CARDIN,(INPUT))                                    MBJ1
         DROP  R2                                                  MBJ1
         EJECT
ABREADCD GET   CARDIN
         MVC   HOLDCARD,0(REG01)
         MVC   SYSDATA,SYSDATA-1
         BAL   REG08,ANPTSYS1
* * * * PRINT CONTROL CARD
         MVC   SYSDATA(80),HOLDCARD
         BAL   REG08,ANPTSYS1
* * * * SCAN CONTROL CARDS FOR VARIOUS OPTIONS
         CLC   HOLDCARD(9),=C'UTLPRINT,'
         BE    TITLE
         MVC   SYSDATA(39),=C'-- REJECTED  EXPECTED UTLPRINT, - FOUND '
         MVC   SYSDATA+39(9),HOLDCARD
         BAL   REG08,ANPTSYS2
         B     ABREADCD
* * * * THE TITLE OPTION PROVIDES FOR A 50 CHARACTER TITLE OF THE
*       USER'S CHOICE WHICH WILL BE INCLUDED IN THE FIRST HEADING
*       LINE ON EACH PAGE OF PRINTED OUTPUT. THIS OPTION MUST BE
*       ON A CARD BY ITSELF.
TITLE    CLC   HOLDCARD+9(5),=C'TITLE'
         BNE   ABNXTOPT
         MVC   AHDRTITL(50),HOLDCARD+15
         B     ABREADCD
         TITLE ' UTLPRINT - CONTROL CARD SCANNER '                 MBJ1
ABNXTOPT BAL   REG08,AKDLMTR1
* * * * THE BLANKLINE OPTION ALLOWS FOR DOUBLESPACING BETWEEN RECORDS.
         CLC   HOLDCARD(9),=C'BLANKLINE'
         BNE   PRINTHEX
         MVI   WSWNOSPC,X'F0'
         B     ABNXTOPT
* * * * THE PRINTHEX OPTION CAUSES PRINTING OF THE INPUT DATA TO BE
*       IN HEX FORMAT RATHER THAN DISPLAY.
PRINTHEX CLC   HOLDCARD(8),=C'PRINTHEX'
         BNE   EXIT                                                RHC2
         MVI   WSWHEX,X'F0'
         B     ABNXTOPT
* * * * THE EXIT PARAMETER ALLOWS SPECIFICATION OF THE NAME OF     RHC2
*       THE USER EXIT ROUTINE ON A CONTROL CARD                    RHC2
EXIT     CLC   HOLDCARD(5),=C'EXIT='                               RHC2
         BNE   DUMP                                                RHC2
         CALL  EXITCARD,(HOLDCARD,SSOUTSET,MJEXITEP,MJEXITIN),     MBJ5X
               ID=*-UTLPRINT       PUT EXIT NAMES OUT AND LOAD     MBJ5
         B     ABNXTOPT                                            MBJ5
* * * * DUMP=NO WILL LET THE PROGRAM CONTINUE EXECUTING IF OPTION
*       ERRORS HAVE BEEN DETECTED.
DUMP     CLC   HOLDCARD(7),=C'DUMP=NO'
         BNE   UTLSYS03
         MVI   WSWDMPNO,C'1'
         B     ABNXTOPT
* * * * UTLSYS03 WILL CAUSE A CONTROL CARD BEARING THE RECORD NUMBER
*       OF THE RECORD CURRENTLY BEING PRINTED TO BE WRITTEN TO AN
*       OUTPUT DATASET. THIS WAS ORIGINALLY INTENDED FOR GENERATING
*       CONTROL CARDS FOR A PTA PROGRAM THAT DROPPED RECORDS FROM THE
*       FILE THE CARDS WERE MADE FROM.
UTLSYS03 CLC   HOLDCARD(8),=C'UTLSYS03'
         BNE   STARTOPT
         MVI   WSWCTRST,C'1'
         B     ABNXTOPT
* * * * THE START OPTION SPECIFIES WHICH RECORD TO START PROCESSING
*       ON BASED UPON RECORD COUNT.
STARTOPT CLC   HOLDCARD(5),=C'START'
         BE    AGSTART
* * * * PRINT DEFINES HOW MANY RECORDS TO PRINT BASED UPON RECORD
*       COUNT.
         CLC   HOLDCARD(5),=C'PRINT'
         BE    AGPRINT
* * * * THE SKIP OPTION FACILITATES PRINTING RECORDS AT DESIRED
*       INTERVALS, BASED UPON RECORD COUNT.
         CLC   HOLDCARD(4),=C'SKIP'
         BE    AGSKIP
* * * * THE SS AND SH OPTIONS ARE USED WHEN SEARCHING FOR A RANGE OF
*       RECORDS BASED UPON RECORD VALUES, NOT RECORD COUNT. UP TO 4
*       SS VALUES MAY BE SPECIFIED FOR THE RECORD TO BEGIN PRINTING
*       ON AND UP TO 4 SH VALUES FOR THE RECORD TO END PRINTING.
         CLC   HOLDCARD(2),=C'SS'
         BE    AHSRCH
         CLC   HOLDCARD(2),=C'SH'
         BE    AHSRCH
* * * *  SEARCH=OR ALLOWS PRINTING BASED ON ANY OF THE SS/SH VALUES
*       GIVEN WHETHER OR NOT THEY OCCUR IN THE SAME FIELD OF A RECORD.
         CLC   HOLDCARD(9),=C'SEARCH=OR'
         BNE   SRCHONLY
         MVI   SRCHOR,C'1'
         B     ABNXTOPT
* * * * SEARCH=ONLY WILL PRINT ALL THE RECORDS IN A FILE THAT SATISFY
*       THE VALUES GIVEN BY THE SS PARAMETER(S).  NO SH PARAMETERS
*       ARE NECESSARY.
SRCHONLY CLC   HOLDCARD(11),=C'SEARCH=ONLY'
         BNE   ERRORMSG
         MVI   WSWSRCH,X'00'
         B     ABNXTOPT
ERRORMSG MVI   XZTRTTBL+126,X'7E'
         MVC   SYSDATA(35),=C'-- OPTION ERROR - SCAN CONTINUED --'
         MVC   SYSDATA+36(12),HOLDCARD
         TRT   SYSDATA+36(13),XZTRTTBL
         MVI   0(REG01),X'40'
         MVC   1(12,REG01),0(REG01)
         BAL   REG08,ANPTSYS2
         B     ABNXTOPT
* * * * THE START, PRINT AND SKIP OPTIONS ARE CHECKED FOR VALID
*       DELIMITERS. AN ERROR CONDITION PRODUCES A MESSAGE AND THE
*       OPTION IS IGNORED, OTHERWISE CODE FOR CHECKING THE OPTIONS'
*       VALUES IS BRANCHED TO.
AGSTART  MVC   SEQNUM,HOLDCARD+5
         MVC   XKDLMTR,HOLDCARD+6
         MVC   HOLDAREA(80),HOLDAREA+7
         CLI   XKDLMTR,C'='
         BE    CHKVALUE
         MVC   SYSDATA(36),=C'-- START CNTR DLMTR ERR - DROPPED --'
         BAL   REG08,ANPTSYS2
         B     ABNXTOPT
CHKVALUE MVC   SYSDATA(9),=C'-- START '
         BAL   REG08,AKNUMTST
         CLC   SEQNUM,=C'1'
         BNE   CHKS2
         MVC   XGSTRT1,XENUMTST
         B     ABNXTOPT
CHKS2    CLC   SEQNUM,=C'2'
         BNE   CHKS3
         MVC   XGSTRT2,XENUMTST
         B     ABNXTOPT
CHKS3    CLC   SEQNUM,=C'3'
         BNE   SEQERR
         MVC   XGSTRT3,XENUMTST
         B     ABNXTOPT
SEQERR   MVC   SYSDATA+9(34),=C'SEQ NUMBER NOT 1,2 OR 3 - DROPPED '
         BAL   REG08,ANPTSYS2
         B     ABNXTOPT
AGPRINT  MVC   SEQNUM,HOLDCARD+5
         MVC   XKDLMTR,HOLDCARD+6
         MVC   HOLDAREA(80),HOLDAREA+7
         CLI   XKDLMTR,C'='
         BE    CHKPDATA
         MVC   SYSDATA(36),=C'-- PRINT CNTR DLMTR ERR - DROPPED --'
         BAL   REG08,ANPTSYS2
         B     ABNXTOPT
CHKPDATA MVC   SYSDATA(9),=C'-- PRINT '
         BAL   REG08,AKNUMTST
         CLC   SEQNUM,=C'1'
         BNE   CHKP2
         MVC   XGPRNT1,XENUMTST
         B     ABNXTOPT
CHKP2    CLC   SEQNUM,=C'2'
         BNE   CHKP3
         MVC   XGPRNT2,XENUMTST
         B     ABNXTOPT
CHKP3    CLC   SEQNUM,=C'3'
         BNE   SEQERR2
         MVC   XGPRNT3,XENUMTST
         B     ABNXTOPT
SEQERR2  MVC   SYSDATA+9(34),=C'SEQ NUMBER NOT 1,2 OR 3 - DROPPED '
         BAL   REG08,ANPTSYS2
         B     ABNXTOPT
AGSKIP   MVC   SEQNUM,HOLDCARD+4
         MVC   XKDLMTR,HOLDCARD+5
         MVC   HOLDAREA(80),HOLDAREA+6
         CLI   XKDLMTR,C'='
         BE    CHKSKIP
         MVC   SYSDATA(36),=C'-- SKIP  CNTR DLMTR ERR - DROPPED --'
         BAL   REG08,ANPTSYS2
         B     ABNXTOPT
CHKSKIP  MVC   SYSDATA(9),=C'-- SKIP '
         BAL   REG08,AKNUMTST
         CLC   SEQNUM,=C'1'
         BNE   CHKSK2
         MVC   XGSKIP1,XENUMTST
         B     ABNXTOPT
CHKSK2   CLC   SEQNUM,=C'2'
         BNE   CHKSK3
         MVC   XGSKIP2,XENUMTST
         B     ABNXTOPT
CHKSK3   CLC   SEQNUM,=C'3'
         BNE   SEQERR3
         MVC   XGSKIP3,XENUMTST
SEQERR3  MVC   SYSDATA+8(35),=C'SEQ NUMBER NOT 1, 2 OR 3 - DROPPED '
         BAL   REG08,ANPTSYS2
         B     ABNXTOPT
* * * * SS AND SH OPTIONS ARE SORTED ON THE THREE POSSIBLE TYPES.
AHSRCH   MVC   XHSCNOPT,HOLDCARD
         MVC   XKDLMTR,HOLDCARD+4
         MVC   HOLDCARD,HOLDAREA+5
         MVC   SYSDATA(2),=C'--'
         MVC   SYSDATA+3(4),XHSCNOPT
         CLI   XHSCNOPT+3,C'1'
         BL    AHSCNER1
         CLI   XHSCNOPT+3,C'4'
         BH    AHSCNER1
         CLI   XHSCNOPT+2,C'F'
         BE    AHSCNF
         CLI   XHSCNOPT+2,C'C'
         BE    AHSCNC
         CLI   XHSCNOPT+2,C'K'
         BE    AHSCNK
         B     AHSCNER1
* * * * F TYPE, REPRESENTING THE LOCATION OF THE COMPARE DATA WITHIN
*       THE RECORD, IS CHECKED FOR VALID DELIMITER AND FOR BEING LESS
*       THAN 4097. IF THE CONDITIONS ARE SATISFIED, THE VALUE IS
*       PAIRED WITH THE PROPER SS OR SH SET AND STORED, ELSE THE
*       VALUE IS IGNORED.
AHSCNF   CLI   XKDLMTR,C'='
         BNE   AHSCNER2
         BAL   REG08,AKNUMTST
         CLC   XENUMTST,=C'000004096'
         BNH   SORTDATA
         MVC   SYSDATA+9(35),=C'CNTR GREATER THAN 4096 - DROPPED --'
         BAL   REG08,ANPTSYS2
         B     ABNXTOPT
SORTDATA MVC   SYSDATA,SYSDATA-1
         CLC   XHSCNOPT,=C'SSF1'
         BNE   SSF2
         MVC   XHS1F,XENUMTST+5
         B     ABNXTOPT
SSF2     CLC   XHSCNOPT,=C'SSF2'
         BNE   SSF3
         MVC   XHS2F,XENUMTST+5
         B     ABNXTOPT
SSF3     CLC   XHSCNOPT,=C'SSF3'
         BNE   SSF4
         MVC   XHS3F,XENUMTST+5
         B     ABNXTOPT
SSF4     CLC   XHSCNOPT,=C'SSF4'
         BNE   SHF1
         MVC   XHS4F,XENUMTST+5
         B     ABNXTOPT
SHF1     CLC   XHSCNOPT,=C'SHF1'
         BNE   SHF2
         MVC   XHH1F,XENUMTST+5
         B     ABNXTOPT
SHF2     CLC   XHSCNOPT,=C'SHF2'
         BNE   SHF3
         MVC   XHH2F,XENUMTST+5
         B     ABNXTOPT
SHF3     CLC   XHSCNOPT,=C'SHF3'
         BNE   SHF4
         MVC   XHH3F,XENUMTST+5
         B     ABNXTOPT
SHF4     MVC   XHH4F,XENUMTST+5
         B     ABNXTOPT
* * * * C TYPE, REPRESENTING THE COMPARE CONDITION, IS CHECKED FOR
*       VALID DELIMITER AND THEN CONVERTED TO HEX EQUIVALENT OF
*       CONDITION GIVEN. CONDITION IS PAIRED WITH PROPER SS OR SH
*       SET FOR STORAGE.
AHSCNC   CLI   XKDLMTR,C'='
         BNE   AHSCNER2
         MVI   XHHLDC,X'B0'
         CLC   HOLDCARD(2),=C'EQ'
         BNE   EG
         MVI   XHHLDC,X'80'
         B     AHSCNCPT
EG       CLC   HOLDCARD(2),=C'EG'
         BNE   GE
         MVI   XHHLDC,X'B0'
         B     AHSCNCPT
GE       CLC   HOLDCARD(2),=C'GE'
         BNE   EL
         MVI   XHHLDC,X'B0'
         B     AHSCNCPT
EL       CLC   HOLDCARD(2),=C'EL'
         BNE   LE
         MVI   XHHLDC,X'D0'
         B     AHSCNCPT
LE       CLC   HOLDCARD(2),=C'LE'
         BNE   GT
         MVI   XHHLDC,X'D0'
         B     AHSCNCPT
GT       CLC   HOLDCARD(2),=C'GT'
         BNE   LT
         MVI   XHHLDC,X'20'
         B     AHSCNCPT
LT       CLC   HOLDCARD(2),=C'LT'
         BNE   NE
         MVI   XHHLDC,X'40'
         B     AHSCNCPT
NE       CLC   HOLDCARD(2),=C'NE'
         BNE   AHSCNER3
         MVI   XHHLDC,X'70'
AHSCNCPT MVC   SYSDATA,SYSDATA-1
         CLC   XHSCNOPT,=C'SSC1'
         BNE   SSC2
         MVC   XHS1C,XHHLDC
         B     ABNXTOPT
SSC2     CLC   XHSCNOPT,=C'SSC2'
         BNE   SSC3
         MVC   XHS2C,XHHLDC
         B     ABNXTOPT
SSC3     CLC   XHSCNOPT,=C'SSC3'
         BNE   SSC4
         MVC   XHS3C,XHHLDC
         B     ABNXTOPT
SSC4     CLC   XHSCNOPT,=C'SSC4'
         BNE   SHC1
         MVC   XHS4C,XHHLDC
         B     ABNXTOPT
SHC1     CLC   XHSCNOPT,=C'SHC1'
         BNE   SHC2
         MVC   XHH1C,XHHLDC
         B     ABNXTOPT
SHC2     CLC   XHSCNOPT,=C'SHC2'
         BNE   SHC3
         MVC   XHH2C,XHHLDC
         B     ABNXTOPT
SHC3     CLC   XHSCNOPT,=C'SHC3'
         BNE   SHC4
         MVC   XHH3C,XHHLDC
         B     ABNXTOPT
SHC4     MVC   XHH4C,XHHLDC
         B     ABNXTOPT
* * * * K TYPE, REPRESENTING THE DATA FOR COMPARISON, IS CHECKED FOR
*       VALID DELIMITER AND THEN CHECKED FOR ZONED DECIMAL OR HEX
*       FORMAT.
AHSCNK   CLI   XKDLMTR,C'='
         BNE   AHSCNER2
         MVI   XHHLDSW,C'0'
         MVI   XHHLDSW3,X'FF'
         MVI   XHHLDSW4,X'FF'
         CLI   HOLDCARD,C'X'
         BE    AHSCNHEX
         CLI   HOLDCARD,C'D'
         BE    AHSCNDEC
         CLI   HOLDCARD,C'('
         BE    AHSCNDEC+6
         B     AHSCNER3
* * * * ZONED DECIMAL COMPARE DATA IS CHECKED FOR BEING LESS THAN
*       21 CHARACTERS LONG. IF DATA IS OKAY, IT IS STORED TEMPORARILY
*       IN WORKING STORAGE AREA FOR SEARCH OPTIONS.
AHSCNDEC MVC   HOLDCARD,HOLDAREA+1
         MVC   HOLDCARD,HOLDAREA+1
         LA    REG04,HOLDCARD
         XC    XZTRTTBL,XZTRTTBL
         MVI   XZTRTTBL+93,X'5D'
         MVI   XZTRTTBL+255,X'FF'
         TRT   HOLDCARD,XZTRTTBL
         CLI   0(REG01),X'5D'
         BNE   AHSCNER3
         SR    REG01,REG04
         S     REG01,=F'1'
         C     REG01,=F'19'
         BH    AHSCNER4
         STC   REG01,XHMOVCHR
         MVI   XHKFLD,X'40'
         MVC   XHKFLD+1(19),XHKFLD
         MVC   *+7(1),XHMOVCHR
         MVC   XHKFLD,HOLDCARD
         MVC   *+7(1),XHMOVCHR
         MVC   HOLDCARD,WCTRNTB1
         B     AHKMOVE
* * * * HEX COMPARE DATA IS FIRST TESTED FOR LEFT PAREN AND THEN FOR A
*       LEADING PERIOD. A PERIOD SIGNIFIES THE HIGH ORDER FOUR BITS
*       OF THE DATA WILL BE IGNORED AND A '0F' IS STORED IN THE SW3
*       OF THE OPTION FOR LATER ADJUSTMENT OF THE VALUE.  THE DATA
*       IS THEN CHECKED FOR BEING LESS THAN 21 CHARACTERS LONG.
AHSCNHEX MVC   HOLDCARD,HOLDAREA+1
         CLI   HOLDCARD,C'('
         BNE   AHSCNER3
         MVC   HOLDCARD,HOLDAREA+1
         CLI   HOLDCARD,C'.'
         BNE   CKLENGTH
         MVI   HOLDCARD,C'0'
         MVI   XHHLDSW3,X'0F'
CKLENGTH LA    REG04,HOLDCARD
         MVI   XZTRTTBL,X'01'
         MVC   XZTRTTBL+1(255),XZTRTTBL
         XC    XZTRTTBL+193(6),XZTRTTBL+193
         XC    XZTRTTBL+240(10),XZTRTTBL+240
         MVI   XZTRTTBL+93,X'5D'
         TRT   HOLDCARD,XZTRTTBL
         CLI   0(REG01),X'5D'
         BNE   AHSCNER3
         LR    REG02,REG01
         SR    REG01,REG04
         LR    REG04,REG02
         C     REG01,=F'40'
         BH    AHSCNER4
         XC    WDHLDHX2,WDHLDHX2
         XC    WDHLDHX3,WDHLDHX3
         L     REG00,=F'0'
         LA    REG01,WDHLDHX2
         LA    REG02,WDHLDHX3
         LA    REG05,HOLDCARD
* * * * THE VALID HEX DATA IS SEPARATED INTO HOLD AREAS BY EVEN AND
*       ODD BYTES.  IF THE VALUE HAS AN ODD NUMBER OF DIGITS, THE LOW
*       ORDER 4 BITS ARE TO BE IGNORED AND A 'F0' IS STORED IN THE
*       OPTION'S SW4 FOR LATER ADJUSTMENT OF THE DATA.
AHSCNXST CR    REG05,REG04
         BNL   AHSCNXTR
         MVC   0(1,REG01),0(REG05)
         A     REG00,=F'1'
         LA    REG05,1(0,REG05)
         LA    REG01,1(0,REG01)
         CR    REG05,REG04
         BNL   SETSW4
         MVC   0(1,REG02),0(REG05)
         LA    REG05,1(0,REG05)
         LA    REG02,1(0,REG02)
         B     AHSCNXST
SETSW4   MVI   0(REG02),C'0'
         MVI   XHHLDSW4,X'F0'
* * * * THE SEPARATED BYTES ARE TRANSLATED TO HEX AND MERGED TOGETHER.
AHSCNXTR S     REG00,=F'1'
         STC   REG00,XHMOVCHR
         XC    XZTRTTBL,XZTRTTBL
         MVC   XZTRTTBL+193(6),=X'A0B0C0D0E0F0'
         MVC   XZTRTTBL+240(10),=X'00102030405060708090'
         TR    WDHLDHX2,XZTRTTBL
         MVC    XZTRTTBL+193(6),=X'0A0B0C0D0E0F'
         MVC   XZTRTTBL+240(10),=X'00010203040506070809'
         TR    WDHLDHX3,XZTRTTBL
         OC    WDHLDHX2,WDHLDHX3
         MVC   *+7(1),XHMOVCHR
         MVC   XHKFLD,WDHLDHX2
* * * * THE HEX OR ZONED DECIMAL DATA PLACED IN THE TEMPORARY WORKING
*       STORAGE AREA IS MATCHED TO ITS SSK OPTION AND STORED ALONG
*       WITH ITS LENGTH VALUE PREVIOUSLY CALCULATED ABOVE. TWO SWITCHES
*       ARE SET TO F0 SIGNIFYING DATA EXISTS FOR A PARTICULAR SSK
*       OPTION.
AHKMOVE  MVC   SYSDATA,SYSDATA-1
         CLC   XHSCNOPT,=C'SSK1'
         BNE   SSK2
         MVC   XHS1SW3,XHHLDSW3
         MVC   XHS1SW4,XHHLDSW4
         MVC   XHS1L,XHMOVCHR
         MVC   XHS1K,XHKFLD
         B     ABNXTOPT
SSK2     CLC   XHSCNOPT,=C'SSK2'
         BNE   SSK3
         MVC   XHS2SW3,XHHLDSW3
         MVC   XHS2SW4,XHHLDSW4
         MVC   XHS2L,XHMOVCHR
         MVC   XHS2K,XHKFLD
         B     ABNXTOPT
SSK3     CLC   XHSCNOPT,=C'SSK3'
         BNE   SSK4
         MVC   XHS3SW3,XHHLDSW3
         MVC   XHS3SW4,XHHLDSW4
         MVC   XHS3L,XHMOVCHR
         MVC   XHS3K,XHKFLD
         B     ABNXTOPT
SSK4     CLC   XHSCNOPT,=C'SSK4'
         BNE   SHK1
         MVC   XHS4SW3,XHHLDSW3
         MVC   XHS4SW4,XHHLDSW4
         MVC   XHS4L,XHMOVCHR
         MVC   XHS4K,XHKFLD
         B     ABNXTOPT
SHK1     CLC   XHSCNOPT,=C'SHK1'
         BNE   SHK2
         MVC   XHH1SW3,XHHLDSW3
         MVC   XHH1SW4,XHHLDSW4
         MVC   XHH1L,XHMOVCHR
         MVC   XHH1K,XHKFLD
         B     ABNXTOPT
SHK2     CLC   XHSCNOPT,=C'SHK2'
         BNE   SHK3
         MVC   XHH2SW3,XHHLDSW3
         MVC   XHH2SW4,XHHLDSW4
         MVC   XHH2L,XHMOVCHR
         MVC   XHH2K,XHKFLD
         B     ABNXTOPT
SHK3     CLC   XHSCNOPT,=C'SHK3'
         BNE   SHK4
         MVC   XHH3SW3,XHHLDSW3
         MVC   XHH3SW4,XHHLDSW4
         MVC   XHH3L,XHMOVCHR
         MVC   XHH3K,XHKFLD
         B     ABNXTOPT
SHK4     MVC   XHH4SW3,XHHLDSW3
         MVC   XHH4SW4,XHHLDSW4
         MVC   XHH4L,XHMOVCHR
         MVC   XHH4K,XHKFLD
         B     ABNXTOPT
AHSCNER1 MVC   SYSDATA+9(32),=C'INVALID SCAN OPTION - DROPPED --'
         BAL   REG08,ANPTSYS2
         B     ABNXTOPT
AHSCNER2 MVC SYSDATA+9(L'AHDELMSG),AHDELMSG  DELIMITER ERROR       MBJ1
         BAL   REG08,ANPTSYS2
         B     ABNXTOPT
AHDELMSG DC    C'INVALID DELIMITER - DROPPED --'                   MBJ1
AHSCNER3 MVC   SYSDATA+9(30),=C'PARAMETER INVALID - DROPPED --'
         BAL   REG08,ANPTSYS2
         B     ABNXTOPT
AHSCNER4 MVC   SYSDATA+9(31),=C'MORE THAN 20 CHARS - DROPPED --'
         BAL   REG08,ANPTSYS2
         B     ABNXTOPT
* * * * VALUES FOR START, PRINT, SKIP AND SSF/SHF OPTIONS ARE TESTED
*       FOR BEING LESS THAN 10 CHARACTERS AND NUMERIC. INVALID DATA
*       IS DROPPED.
AKNUMTST ST    REG08,XDSTRG08
         MVC   XENUMTST,XENUMTST-1
         LA    REG04,HOLDCARD
         TRT   HOLDCARD,XZTRTTBL
         SR    REG01,REG04
         S     REG01,=F'1'
         C     REG01,=F'8'
         BNH   NUMRCTST
         MVC   SYSDATA+9(37),=C'CNTR GREATER THAN 9 CHARS - DROPPED--'
         BAL   REG08,ANPTSYS2
         B     ABNXTOPT
NUMRCTST LA    REG05,XENUMTST+8
         SR    REG05,REG01
         STC   REG01,*+5
         MVC   0(0,REG05),HOLDCARD
         MVI   XZTRTTBL,X'01'
         MVC   XZTRTTBL+1(255),XZTRTTBL
         XC    XZTRTTBL+240(10),XZTRTTBL+240
         L     REG08,XDSTRG08
         TRT   XENUMTST,XZTRTTBL
         BNE   NUMERROR
         BR    REG08
NUMERROR MVC   SYSDATA+9(29),=C'CNTR NOT NUMERIC - DROPPED --'
         BAL   REG08,ANPTSYS2
         B     ABNXTOPT
* * * * THIS CODE DETERMINES WHETHER THE PHYSICAL END OF A CONTROL
*       CARD HAS BEEN REACHED (FF), OR END-OF-OPTIONS FOR A CARD
*       (BLANK), OR ANOTHER OPTION EXISTS (COMMA). END OF CARD AND
*       END-OF-OPTIONS SIGNALS THE READING OF ANOTHER CONTROL CARD.
*       A COMMA CAUSES THE POINTER OF THE LAST OPTION TO BE SHIFTED
*       TO THE NEXT ONE AND SCANNING RESUMES.
AKDLMTR1 XC    XZTRTTBL,XZTRTTBL
         MVI   XZTRTTBL+64,X'40'
         MVI   XZTRTTBL+107,X'6B'
         MVI   XZTRTTBL+255,X'FF'
         TRT   HOLDAREA,XZTRTTBL
         MVC   XKDLMTR,0(REG01)
         CLI   XKDLMTR,X'FF'
         BE    ABREADCD
         CLI   XKDLMTR,X'40'
         BE    ABREADCD
         MVC   HOLDAREA(80),1(REG01)
         BALR  REG08,REG08
         TITLE ' UTLPRINT '                                        MBJ1
* * * * BEGINNING CONSTANTS FOR THE BYTES-PRINTED COUNTER ARE
*       INITIALIZED TO -99 FOR DISPLAY PRINTING AND -31 FOR HEX
*       PRINTING.  WHEN THE FIRST LINE OF A RECORD IS PRINTED, THESE
*       VALUES ARE CHANGED TO 1 BY ADDITION. THIS CODE ALSO OVERLAYS
*       THE DISPLAY HEADER WITH THE HEX ONE WHEN HEX FORMAT IS DESIRED.
*       COUNT IS INITIALIZED AND FINALLY THE TRANSLATE TABLE IS
*       PRINTED OUT FOR USER REFERENCE.
AQEOFCRD SP    XDFRCON,=P'99'
         CLI   WSWHEX,X'F0'
         BNE   CLEARLNE
         AP    XDFRCON,=P'68'
         MVC   BHDRDATA,WCHDRHEX
********SET UP TO CALL SUBROUTINE WHICH WILL WRITE TRANSLATE       MBJ1
*        TABLE.  LINKAGE INCLUDES THE LIBE TRANSLATE TABLE         MBJ1
*        ROUTINE USES THIS TABLE TO GET CORRECT HEADING INFO
CLEARLNE EQU   *                                                   MBJ1
         ZAP   XDLNCNT,=P'8'       FOR COMPATIBILITY               MBJ1
         MVC   CDATALN,CDATALN-8   CLEAR PRINT LINE                MBJ4
         CALL  UTLPRHTR,(PRINTSET,CDATALN,WCTRNTB1),VL,ID=50       MBJ4
         B     DRSETRG                                             MBJ1
         EJECT
         LTORG
         EJECT
DRSETRG  BALR  10,0
         USING DDINTLZ,10,11,12
DDINTLZ  LM    11,12,BASEADR2
         B     DASETSWS
BASEADR2 DC    A(DDINTLZ+4096,DDINTLZ+8192)
* * * * ACCUMULATED DATA FOR EACH SET OF SS/SH PARAMETERS IS VERIFIED
*       FOR COMPLETENESS. SEE NOTE AT LOCATION DASRHCHK.
DASETSWS MVC   XHSCNOPT,=C'SS-1'
         MVC   XHHLDSCN,XHS1OPT
         BAL   REG08,DASRHCHK
         MVC   XHS1OPT,XHHLDSCN
         MVC   XHSCNOPT,=C'SS-2'
         MVC   XHHLDSCN,XHS2OPT
         BAL   REG08,DASRHCHK
         MVC   XHS2OPT,XHHLDSCN
         MVC   XHSCNOPT,=C'SS-3'
         MVC   XHHLDSCN,XHS3OPT
         BAL   REG08,DASRHCHK
         MVC   XHS3OPT,XHHLDSCN
         MVC   XHSCNOPT,=C'SS-4'
         MVC   XHHLDSCN,XHS4OPT
         BAL   REG08,DASRHCHK
         MVC   XHS4OPT,XHHLDSCN
         MVC   XHSCNOPT,=C'SH-1'
         MVC   XHHLDSCN,XHH1OPT
         BAL   REG08,DASRHCHK
         MVC   XHH1OPT,XHHLDSCN
         MVC   XHSCNOPT,=C'SH-2'
         MVC   XHHLDSCN,XHH2OPT
         BAL   REG08,DASRHCHK
         MVC   XHH2OPT,XHHLDSCN
         MVC   XHSCNOPT,=C'SH-3'
         MVC   XHHLDSCN,XHH3OPT
         BAL   REG08,DASRHCHK
         MVC   XHH3OPT,XHHLDSCN
         MVC   XHSCNOPT,=C'SH-4'
         MVC   XHHLDSCN,XHH4OPT
         BAL   REG08,DASRHCHK
         MVC   XHH4OPT,XHHLDSCN
         CLI   WSWDMP,C'1'
         BNE   DASETSW2
         CLI   WSWDMPNO,C'1'
         BE    DASETSW2
         MVC   SYSDATA(31),=C'-- ERROR FOUND - NOT DUMP=NO --'
         BAL   REG08,ANPTSYS1
         B     DEOFDATA
* * * * BRANCHES USED WITH THE SEARCH OPTIONS ARE MADE INTO
*       UNCONDITIONAL BRANCHES IF DATA DOES NOT EXIST OR IS IN
*       ERROR FOR A SS OR SH OPTION, ELSE THEY ARE LEFT NO-OPS SO THAT
*       CODE FOR PROCESSING SEARCH DATA WILL BE EXECUTED INSTEAD OF
*       BEING BRANCHED AROUND.  THE CONDITION VALUES ARE INSERTED
*       INTO THE BRANCHES WHICH TEST THE COMPARE DATA DEPENDING ON THE
*       PRESENCE OF SEARCH=OR.  ONE SET OF BRANCHES ARE SET FOR THE
*       'AND' CONDITION, ANOTHER SET FOR 'OR'.  IF HEX FORMAT IS
*       REQUIRED, A NO-OP BRANCH IS CHANGED FROM DISPLAY SETUP TO HEX
*       SETUP.  THE START, PRINT AND SKIP OPTIONS OF THE FIRST SET ARE
*       PACKED INTO THE COUNTERS.
DASETSW2 MVC   DDSS1SW1+1(1),XHS1SW1
         MVC   DDSS2SW1+1(1),XHS2SW1
         MVC   DDSS3SW1+1(1),XHS3SW1
         MVC   DDSS4SW1+1(1),XHS4SW1
         MVC   DDSH1SW1+1(1),XHH1SW1
         MVC   DDSH2SW1+1(1),XHH2SW1
         MVC   DDSH3SW1+1(1),XHH3SW1
         MVC   DDSH4SW1+1(1),XHH4SW1
         CLI   SRCHOR,C'1'
         BE    SETORSWS
         MVC   DDSS1SW2+1(1),XHS1C
         MVC   DDSS2SW2+1(1),XHS2C
         MVC   DDSS3SW2+1(1),XHS3C
         MVC   DDSS4SW2+1(1),XHS4C
         MVC   DDSH1SW2+1(1),XHH1C
         MVC   DDSH2SW2+1(1),XHH2C
         MVC   DDSH3SW2+1(1),XHH3C
         MVC   DDSH4SW2+1(1),XHH4C
         MVI   DDSS1OR+1,X'00'
         MVI   DDSS2OR+1,X'00'
         MVI   DDSS3OR+1,X'00'
         MVI   DDSS4OR+1,X'00'
         MVI   DDSH1OR+1,X'00'
         MVI   DDSH2OR+1,X'00'
         MVI   DDSH3OR+1,X'00'
         MVI   DDSH4OR+1,X'00'
         B     CONTPROC
SETORSWS MVC   DDSS1OR+1(1),XHS1C
         MVC   DDSS2OR+1(1),XHS2C
         MVC   DDSS3OR+1(1),XHS3C
         MVC   DDSS4OR+1(1),XHS4SW1
         MVI   DDSS4SW1+1,X'00'
         MVC   DDSS4SW2+1(1),XHS4C
         MVC   DDSH1OR+1(1),XHH1C
         MVC   DDSH2OR+1(1),XHH2C
         MVC   DDSH3OR+1(1),XHH3C
         MVC   DDSH4OR+1(1),XHH4SW1
         MVI   DDSH4SW1+1,X'00'
         MVC   DDSH4SW2+1(1),XHH4C
CONTPROC MVC   DDHEXSW+1(1),WSWHEX
         ZAP   XDLNCNT,=P'99'
         MVC   SYSDATA,SYSDATA-1
         LA    REG06,XGSTRT1
         PACK  XGSTRT(5),0(9,REG06)
         PACK  XGPRNT(5),9(9,REG06)
         PACK  XGSKIP(5),18(9,REG06)
* * * * IF A CONTROL CARD DATA SET IS TO BE CREATED, IT IS OPENED
*       HERE.
         CLI   WSWCTRST,C'1'
         BNE   DDREAD
         LA    R1,CNTRSET          FIND OUT IF DDCARD              MBJ1
         USING IHADCB,R1                                           MBJ1
         DEVTYPE DCBDDNAM,MJDDBOX  'UTLSYSO3'  IS                  MBJ1
         LTR   R15,R15             PRESENT                         MBJ1
         BNZ   DDREAD              NO - GO ON AND READ             MBJ1
         C     R15,MJDDBOX         DUMMIED                         MBJ1
         BE    DDREAD              YES - GO READ                   MBJ1
         DROP  R1                                                  MBJ1
         OPEN  (CNTRSET,(OUTPUT))
         MVC   HOLDCARD(80),SYSDATA
         B     DDREAD
* * * * SS AND SH DATA ARE TESTED FOR HAVING A LENGTH VALUE AND
*       LOCATION VALUE FOR THE COMPARE DATA WITHIN A RECORD. ONE
*       WITHOUT THE OTHER CREATES AN ERROR CONDITION, THUS THE
*       BRANCH SWITCH REMAINS F0. THE SWITCH IS CHANGED TO 00 UPON
*       SUCCESSFUL VALIDATION. IF VARIABLE LENGTH RECORDS ARE TO BE
*       PRINTED, THE LOCATION ADDRESS IS ADJUSTED 4 BYTES.
DASRHCHK ST    REG08,XDSTRG08
         MVI   XHHLDSW,X'F0'
         MVC   SYSDATA(2),=C'--'
         MVC   SYSDATA+3(4),XHSCNOPT
         CLI   XHMOVCHR,X'FF'
         BNE   CHKLOC
         CLC   XHHLDF,=C'0000'
         BNE   DASRHERR
         BALR  REG08,REG08
CHKLOC   CLC   XHHLDF,=C'0000'
         BE    DASRHERR
         MVI   XHHLDSW,X'00'
         PACK  XZHLDNR,XHHLDF
         CVB   REG02,XZHLDNR
         L     REG03,ADATASET      INPUT DCB                       MBJ5
         USING IHADCB,REG03                                        MBJ5
         TM    DCBRECFM,DCBRECF    TEST FOR FIXED INPUT            MBJ5
         BO    DLENGTH             IF FIXED ONWARD                 MBJ5
         LA    REG02,4(,REG02)     VARIABLE ADD 4 TO OFFSET OF     MBJ5
*                                  KEY TO ADJUST FOR LLBB          MBJ5
         DROP  REG03                                               MBJ5
DLENGTH  S     REG02,=F'1'
         ST    REG02,XHHLDF
         L     REG04,=F'0'
         IC    REG04,XHMOVCHR
         AR    REG02,REG04
         ST    REG02,XHHLDFL
         BALR  REG08,REG08
DASRHERR MVC   SYSDATA+8(23),=C'INCOMPLETE - DROPPED --'
         BAL   REG08,ANPTSYS2
         L     REG08,XDSTRG08
         BALR  REG08,REG08
         EJECT
* * * * A RECORD FROM THE INPUT DATA IS READ, THE RECORD COUNTER
*       INCREMENTED AND THE RECORD COUNTER COMPARED TO THE START VALUE.
*       RECORDS ARE NOT PROCESSED UNTIL THE RECORD COUNT IS
*       EQUAL TO THE START VALUE.
DDREAD   EQU   *                                                   MBJ1
*  IF PREVIOUS RECORD WAS NOT SELECTED FOR PRINTING WRITE IT TO    RHC2
*  UTLSYS05 IF PROVIDED. SELECT SWITCH WILL BE SET TO INHIBIT      RHC2
*  OUTPUT TO UTLSYS05 ON FIRST PASS THRU.                          RHC2
         CLI   SELECTED,X'40'      FIRST PASS ?                    RHC2
         BNE   RECSEL01                                            RHC2
         MVI   SELECTED,X'00'      YES - CLR REC SELECTED SW       RHC2
         B     RECSEL                                              RHC2
RECSEL01 EQU   *                                                   RHC2
         CLI   SELECTED,X'80'      WAS RECORD SELECTED ?           RHC2
         BE    RECSEL                                              RHC2
         L     R3,XDSTRG01                                         RHC2
         CHKPUT UTLSYS05,0(R3)                                     RHC2
RECSEL   EQU   *                                                   RHC2
         MVI   SELECTED,X'00'      CLEAR SELECT SWITCH             RHC2
         L     R1,ADATASET        SEE IF INPUT DATASET             RHC1
         USING IHADCB,R1                                           MBJ1
         TM    DCBOFLGS,MJOPNBIT       OPEN                        MBJ1
         BZ    DEOFDATA            IF NOT - GO TO EODAD            MBJ1
         GET   (1)                 GET A RECORD                    MBJ1
         DROP  R1                                                  MBJ1
         ST    REG01,XDSTRG01      SAVE LOCATION OF INPUT REC      MBJ5
         MVI   MJGETFLG,BIN00      CLEAR GET FLAG -IMAGE REC WRITE MBJ1
         AP    XGRECCNT,=P'1'
         USING IHADCB,REG03
         L     REG03,ADATASET                                      RHC1
         LH    REG05,DCBLRECL
         CVD   REG05,XZHLDNR
         L     REG00,=F'0'
         DROP  REG03                                               MBJ1
*
* LOAD THE ADDRESS OF THE USER INPUT EXIT
* IF NONE WAS REQUESTED THE ADDRESS OF THE EXIT WILL BE SET TO
* POINT TO IEFBR14.
* THE PARM VALUE PASSED TO THE SUBROUTINE IS THE SAME ONE PASSED TO
* THE OUTPUT EXIT.  NOTE THAT THE PRINT LINE BUFFER IS PASSED TO THE
* INPUT EXIT BUT DOES NOT YET CONTAIN USEFUL INFORMATION
*
         ST    REG01,MJINADDR      TELL EXIT LOCATION OF INPUT REC MBJ5
         MVC   MJINDCB,ADATASET    AND DCB                         MBJ5
         L     R15,MJEXITIN        GET ADDRESS OF INPUT EXIT       MBJ5
         LA    R1,MJUSRPRM         GIVE PARM TO USER               MBJ5
         BALR  R14,R15             CALL USER EXIT                  MBJ5
         SRL  R15,2                INSURE MULT OF 4                MBJ5
         SLL  R15,2                                                MBJ5
         CL   R15,=F'8'            ONLY 0, 4, 8 ALLOWED            MBJ5
         BNH   CHKXRET                                             MBJ5
         SR    R15,R15                                             MBJ5
CHKXRET  DS    0H                                                  MBJ5
         B     *+4(R15)            PROCESS RETURN CODE             MBJ5
         B     MJNORMSL            0 - NORMAL SELECTION            MBJ5
         B     DDSETUP             4 - FORCE  SELECT               MBJ5
         B     DDREAD              8 - FORCE  NON-SELECT           MBJ5
MJNORMSL DS    0H
         CP    XGRECCNT,XGSTRT     ARE WE TO START1 LOC. YET       MBJ5
         BL    DDREAD                                              MBJ5
* * * * THIS NO-OP IS FOR THE SEARCH=ONLY OPTION. WHEN THE FIRST SET
*       OF START VALUES ARE SATISFIED FOR A RECORD, THE VALUE OF THE
*       SEARCH=ONLY FLAG IS PLACED IN THIS INSTRUCTION, 00 FOR THE
*       OPTION, F0 THAT THE OPTION IS NOT DESIRED.  AN F0 WILL CAUSE
*       SEARCHING ONLY FOR THE HALTING RECORD, AS THE STARTING RECORD
*       HAS BEEN LOCATED.  THE 00 LEAVES THE INSTUCTION A NO-OP, THUS,
*       REPEATED SEARCHING ON THE SAME START DATA MAY CONTINUE.
DDPRTSW  NOP   DDSH1SW1
* * * * THE INCOMING RECORD IS FIRST CHECKED FOR BEING LONG ENOUGH
*       TO CONTAIN THE COMPARISON FIELD. IF SO, THE DATA IS EXTRACTED
*       FROM THE RECORD, THE HIGH AND/OR LOW FOUR BITS ARE TURNED OFF
*       ACCORDING TO THE VALUES IN SWITCHES 3 AND 4 FOR THE SS1 OPTION,
*       AND FINALLY THE DATA IS COMPARED TO THE GIVEN VALUE. ANOTHER
*       RECORD IS READ IF THE RECORD WAS TOO SHORT. IF SS1 DATA WAS NOT
*       SUPPLIED OR WAS FOUND IN ERROR, THIS CODE IS BRANCHED AROUND
*       TO THE CODE FOR SS2.
DDSS1SW1 B     DDSS2SW1
         MVC   XHHLDSCN,XHS1OPT    MOVE STARTING-1 CONTROL BLOCK   MBJ5
*                                  TO THE COMMON WORK AREA USED    MBJ5
*                                  BY SUBROUTINE MJTESTER          MBJ5
         BAL   R14,MJTEST1         TEST KEY.  R15 WILL BE SET SO   MBJ5
*                                  THAT A LTR WILL RECREATE        MBJ5
*                                  CONDITION CODE OF CLC.          MBJ5
         LTR   R15,R15                                             MBJ5
* * * * IF THE RECORD DATA SATISFIES THE COMPARE WITH THE GIVEN VALUE,
*       A BRANCH IS TAKEN TO THE CODE FOR INSPECTING SS2 FOR A
*       REGULAR SEARCH.  AN 'OR' SEARCH WILL CAUSE BRANCHING TO THE
*       CODE THAT PRINTS THE RECORD.
DDSS1OR  B     DDONLYSW
DDSS1SW2 B     DDSS2SW1
         B     DDREAD
* * * * THIS CODE FOR COMPARING SS2 DATA IS THE SAME AS THAT FOR SS1.
DDSS2SW1 B     DDSS3SW1
         MVC   XHHLDSCN,XHS2OPT    MOVE STARTING-2 CB TO COMMON    MBJ5
         BAL   R14,MJTEST1         TEST FOR DESIRED KEY            MBJ5
         LTR   R15,R15                                             MBJ5
DDSS2OR  B     DDONLYSW
DDSS2SW2 B     DDSS3SW1
         B     DDREAD
* * * * AGAIN, THE CODE BELOW FOR THE SS3 DATA IS THE SAME AS THAT
*       FOR SS1 AND SS2.
DDSS3SW1 B     DDSS4SW1
         MVC   XHHLDSCN,XHS3OPT    MOVE STARTING-3 CB TO COMMON    MBJ5
         BAL   R14,MJTEST1         TEST FOR DESIRED KEY            MBJ5
         LTR   R15,R15                                             MBJ5
DDSS3OR  B     DDONLYSW
DDSS3SW2 B     DDSS4SW1
         B     DDREAD
* * * * CODE FOR SS4 IS BASICALLY THE SAME AS ABOVE.  IN 'AND' LOGIC,
*       ANOTHER RECORD IS NOT READ IF NO SS4 DATA EXISTS.  RATHER,
*       HAVING MATCHED WHICHEVER DATA GIVEN, THE PROGRAM BRANCHES
*       TO CODE THAT WILL ALLOW FOR THE SEARCH=ONLY OPTION OR ALLOWS
*       COMPARISON FOR THE HALTING RECORD ONLY.  IF NO SS4 DATA IS
*       PRESENT FOR 'OR' LOGIC, ANOTHER RECORD IS READ.  IN BOTH
*       CASES IF DATA IS PRESENT, PROCESSING CONTINUES TO THE BRANCHES
*       WHICH CAUSE PRINTING IF THE GIVEN CONDITION WAS MET, OR TO
*       READ-ANOTHER-RECORD IF THE CONDITION WAS NOT MET.
DDSS4SW1 B     DDONLYSW
         MVC   XHHLDSCN,XHS4OPT    MOVE  STARTING-4 CB TO COMMON   MBJ5
         BAL   R14,MJTEST1         TEST  FOR DESIRED KEY           MBJ5
         LTR   R15,R15                                             MBJ5
DDSS4OR  B     DDREAD
DDSS4SW2 B     DDONLYSW
         B     DDREAD
* THIS SUBROUTINE MAKES KEY TESTING (SLIGHTLY) MORE RATIONAL       MBJ5
* IF  REG005 (LOGICAL RECORD LENGTH) TOO SHORT TO CONTAIN KEY      MBJ5
* (HELD IN CONTROL BLOCK AT XHHLDFL) BRANCH OUT OF SUB ROUTINE     MBJ5
* TO 'DDREAD' (POOR BUT REAL)                                      MBJ5
*                                                                  MBJ5
* OPERATION IS PERFORMED USING CONTROL BLOCK AT XHHLDSCN.          MBJ5
* CALLER MUST MOVE APROPREATE   BLOCK INTO THIS WORK AREA          MBJ5
* BEFORE CALLING.                                                  MBJ5
* THE RECORD LOCATION IS RETRIEVED (XDSTRG01)                      MBJ5
* FIELD FOUND WITHIN RECORD        (                               MBJ5
* FIELD MOVED TO TEST FIELD                                        MBJ5
* FIRST AND LAST HALF BYTE ARE FORCED  IF NEED BE TO ALLOW HALF    MBJ5
* BYTE TESTING                                                     MBJ5
* KEY IS COMPARED TO TEST FIELD                                    MBJ5
* REG15 IS SET TO 4, 0 OR -4 DEPENDING ON RESULT                   MBJ5
* A LTR  15,15 WILL SET CONDITION CODE TO SAVE VALUE               MBJ5
* AS CLC  (IT'S UGLY BUT ALLOWS OLD MASKING OF BC INSTRUCTIONS     MBJ5
* TO CONTINUE)                                                     MBJ5
MJTEST1  DS    0H                                                  MBJ5
         SAVE  (14,12)             THESE MAY BE MODIFIED           MBJ5
         L     REG03,ADATASET      GET LOGICAL                     MBJ5
         USING IHADCB,REG03                                        MBJ5
         TM    DCBRECFM,DCBRECF    VARIABLE RECORDS                MBJ5
         BO    MJ1FXED             AROUND IF FIXED                 MBJ5
         L     REG04,XDSTRG01      RECORD ADDRESS                  MBJ5
         LH    REG06,0(,REG04)     GET LLBB                        MBJ5
         B     MJT1CM                                              MBJ5
MJ1FXED  DS    0H                                                  MBJ5
         LH    REG06,DCBLRECL      GET RECORD LENGTH               MBJ5
MJT1CM   DS    0H                  RECORD LENGTH IN REG06          MBJ5
         SR    REG01,REG01                                         MBJ5
         IC    REG01,XHMOVCHR      LENGTH OF KEY LESS ONE          MBJ5
         LR    REG07,REG01                                         MBJ5
         A     REG07,XHHLDF        ADD OFF SET OF KEY LESS ONE     MBJ5
         LA    REG07,1(,REG07)     BUMP TO COMPENSATE FOR THE EXTRAMBJ5
*                                  LESS ONE                        MBJ5
         CR    REG07,REG06         IS END INSIDE THE RECORD        MBJ5
         BH    DDREADEX            NO IGNORE THE RECORD            MBJ5
         L     REG04,XHHLDF        GET OFF SET OF KEY              MBJ5
         AL    REG04,XDSTRG01      ADD ADDRESS OF RECORD           MBJ5
*                                  GIVING ADDRESS OF KEY           MBJ5
         DROP  REG03
         EX    REG01,MVCKEYWK   MOVE KEYFIELD TO WORK AREA         MBJ5
         LA    REG04,KEYWK(REG01)    PLACE ADDRESS OF LAST BYTE    MBJ5
*                                    INTO REG02                    MBJ5
         NC    0(1,REG04),XHHLDSW4   FORCE LAST HALF BYTE OF KEY   MBJ5
         NC    KEYWK(1),XHHLDSW3     FORCE FIRST HALF BYTE OF KEY  MBJ5
         EX    REG01,CLCKEYWK   CLC  KEYWK,XHKFLD                  MBJ5
         BH    MJTESTHI              KEY IS HI                     MBJ5
         BL    MJTESTLO              KEY IS LOW                    MBJ5
         SR    R15,R15               KEY EQUAL                     MBJ5
*                                    LTR ON REG 15 WILL RECREATE   MBJ5
*                                    THE CONDITION CODE OF CLC     MBJ5
         B     MJTESTEX                                            MBJ5
MJTESTLO DS    0H                                                  MBJ5
         L     R15,=F'-4'            KEY IS LOW R15 NEGATIVE       MBJ5
         B     MJTESTEX                                            MBJ5
MJTESTHI LA    R15,4                 KEY IS HIGH                   MBJ5
         B     MJTESTEX                                            MBJ5
MJTESTEX DS    0H                                                  MBJ5
         RETURN (14,12),RC=(15)                                    MBJ5
DDREADEX DS    0H                                                  MBJ5
         LM    14,12,12(13)        RESTORE REGES                   MBJ5
         B     DDREAD              FORCE BRANCH TO DD READ         MBJ5
KEYWK    DC    CL20'  '            COMPARE KEY HOLDER              MBJ5
MVCKEYWK MVC   KEYWK(*-*),0(REG04) MOVE KEY TO WORK AREA           MBJ5
*                                  LENGTH SUPPLIED BY XHMOVCHR     MBJ5
CLCKEYWK CLC   KEYWK(*-*),XHKFLD   COMPARE RECORD KEY TO C.B.      MBJ5
         SPACE  4                                                  MBJ5
DDONLYSW NOP   DDSH1SW1
         MVI   DDONLYSW+1,X'F0'
         MVC   DDPRTSW+1(1),WSWSRCH
* * * * THE CODE FOR THE SH1-4 VALUES BELOW IS ESSENTIALLY THE SAME
*       AS THAT FOR SS'S. THE ONLY DIFFERENCE IS THAT THE RECORD
*       IS TESTED FOR BEING SKIPPED IF IT WAS TOO SHORT TO INCLUDE
*       THE COMPARISON DATA OR DID NOT COMPARE WITH THE GIVEN DATA.
*       AS THE CODE IS EXECUTED A NO-OP INSTRUCTION IS CHANGED TO
*       AN UNCONDITIONAL BRANCH TO END-OF-JOB SO THAT THE CASE OF
*       BRANCHING AROUND SH4'S CODE WHEN THE HALTING RECORD IS FOUND
*       IS TAKEN CARE OF. THE OTHER PATH TO END-OF-JOB IS WHEN SH4
*       SUCCESSFULLY COMPARES WITH THE GIVEN DATA OR WHEN A RECORD
*       MATCHES ANY OF THE CONDITIONS UNDER 'OR' LOGIC.
DDSH1SW1 B     DDSH2SW1
         MVC   XHHLDSCN,XHH1OPT    MOVE HALTING 1 CB TO COMMON     MBJ5
         BAL   R14,MJTEST2         TEST  FOR DESIRED KEY           MBJ5
         LTR   R15,R15                                             MBJ5
DDSH1OR  B     DREQDONE
DDSH1SW2 B     DDSH2SW1
         B     DDSKPCHK
DDSH2SW1 B     DDSH3SW1
         MVC   XHHLDSCN,XHH2OPT    MOVE  HALTING-2 CB TO COMMON    MBJ5
         BAL   R14,MJTEST2         TEST  FOR DESIRED KEY           MBJ5
         LTR   R15,R15                                             MBJ5
DDSH2OR  B     DREQEND
DDSH2SW2 B     DDSH3SW1
         B     DDSKPCHK
DDSH3SW1 B     DDSH4SW1
         MVC   XHHLDSCN,XHH3OPT    MOVE  HALTING-3 CB TO COMMON    MBJ5
         BAL   R14,MJTEST2         TEST  FOR DESIRED KEY           MBJ5
         LTR   R15,R15                                             MBJ5
DDSH3OR  B     DREQEND
DDSH3SW2 B     DDSH4SW1
         B     DDSKPCHK
DDSH4SW1 B     DDFINSW
         MVC   XHHLDSCN,XHH4OPT    MOVE  HALTING-4 CB TO COMMON    MBJ5
         BAL   R14,MJTEST2         TEST  FOR DESIRED KEY           MBJ5
         LTR   R15,R15                                             MBJ5
DDSH4OR  B     DDSKPCHK
DDSH4SW2 B     DREQEND
         B     DDSKPCHK
MJTEST2  DS    0H                                                  MBJ5
         SAVE  (14,12)             PRESERVE REGS                   MBJ5
         L     REG03,ADATASET                                      MBJ5
         USING IHADCB,REG03                                        MBJ5
         TM    DCBRECFM,DCBRECF    VARIABLE RECORDS                MBJ5
         BO    MJ2FXED             AROUND IF FIXED                 MBJ5
         L     REG04,XDSTRG01      RECORD ADDRESS                  MBJ5
         LH    REG06,0(,REG04)     GET LLBB                        MBJ5
         B     MJT2CM                                              MBJ5
MJ2FXED  DS    0H                                                  MBJ5
         LH    REG06,DCBLRECL      GET RECORD LENGTH               MBJ5
MJT2CM   DS    0H                  RECORD LENGTH IN REG06          MBJ5
         SR    REG01,REG01                                         MBJ5
         IC    REG01,XHMOVCHR      LENGTH OF KEY LESS ONE          MBJ5
         LR    REG07,REG01                                         MBJ5
         A     REG07,XHHLDF        ADD OFF SET OF KEY LESS ONE     MBJ5
         LA    REG07,1(,REG07)     BUMP TO COMPENSATE FOR THE EXTRAMBJ5
*                                  LESS ONE                        MBJ5
         CR    REG07,REG06         IS END INSIDE THE RECORD        MBJ5
         BH    MJTEST2A            NO IGNORE THE RECORD            MBJ5
         L     REG04,XHHLDF        GET OFF SET OF KEY              MBJ5
         AL    REG04,XDSTRG01      ADD ADDRESS OF RECORD           MBJ5
*                                  GIVING ADDRESS OF KEY           MBJ5
         DROP  REG03
         MVI   DDFINSW+1,X'F0'     MAKE NOP A BRANCH               MBJ5
         EX    REG01,MVCKEYWK      MOVE KEY TO                     MBJ5
         LA    REG04,KEYWK(REG01)  PLACE ADDRESS OF LAST BYTE      MBJ5
*                                  INTO REG02                      MBJ5
         NC    0(1,REG04),XHHLDSW4                                 MBJ5
         NC    KEYWK(1),XHHLDSW3                                   MBJ5
         EX    REG01,CLCKEYWK      CLC KEYWK,XHKFLD                MBJ5
         BH    MJTEST2H              KEY IS HI                     MBJ5
         BL    MJTEST2L              KEY IS LOW                    MBJ5
         SR    R15,R15               KEY EQUAL                     MBJ5
*                                    LTR ON REG 15 WILL RECREATE   MBJ5
*                                    THE CONDITION CODE OF CLC     MBJ5
         B     MJTEST2X                                            MBJ5
MJTEST2L DS    0H                                                  MBJ5
         L     R15,=F'-4'            KEY IS LOW R15 NEGATIVE       MBJ5
         B     MJTEST2X                                            MBJ5
MJTEST2H LA    R15,4                 KEY IS HIGH                   MBJ5
         B     MJTEST2X                                            MBJ5
MJTEST2X DS    0H                                                  MBJ5
         RETURN (14,12),RC=(15)                                    MBJ5
MJTEST2A DS    0H                                                  MBJ5
         LM    14,12,12(13)        RESTORE REGES                   MBJ5
         B     DDSKPCHK                                            MBJ5
DDFINSW  NOP   DREQEND
* * * * THE END-OF-JOB NO-OP INSTRUCTION IS RE-INITIALIZED, THEN THE
*       RECORD-SKIPPED COUNTER IS INCREMENTED BEFORE COMPARING THE
*       COUNTER SUM TO THE GIVEN SKIP VALUE. IF THE COUNT IS LESS
*       THAN THE SKIP CONSTANT, ANOTHER CARD IS READ, OTHERWISE
*       THE COUNTER IS RE-INITIALIZED AND PRINT PROCESSING BEGINS.
DDSKPCHK MVI   DDFINSW+1,X'00'
         AP    XGSKPPRC,=P'1'
         CP    XGSKPPRC,XGSKIP
         BL    DDREAD
         ZAP   XGSKPPRC,=P'0'
         EJECT
* * * * BEFORE A RECORD IS PRINTED, THE RECORDS-PROCESSED COUNTER IS
*       INCREMENTED, THE RECORD LENGTH SAVED, BYTE COUNTER AND RECORD
*       CARRIAGE CONTROL INITIALIZED, RECORD COUNT EDITED INTO OUTPUT
*       LINE, AND IF A CONTROL CARD IS DESIRED, AN 80 BYTE RECORD
*       WITH FIRST 9 BYTES CONTAINING THE RECORD COUNT IS WRITTEN
*       TO THE CONTROL CARD DATASET.
DDSETUP  AP    XGRECPRC,=P'1'
         AP    XGTOTPRT,=P'1'
         L     REG05,ADATASET      GET LOGICAL RECORD LENGTH       MBJ5
         LH    REG05,DCBLRECL-IHADCB(,REG05)                       MBJ5
         CVD   REG05,XZHLDNR       PLACE INTO WORK AREA            MBJ5
         ZAP   XDRECLST,XZHLDNR
         ZAP   XDRECLW1,XDRECLAD
         ZAP   XDRECLW2,XDRECLAD
         ZAP   XDDATAFR,XDFRCON
         ZAP   XDDATATO,=P'0'
         MVC    CCDIG,WSWNOSPC
         MVC   CDATARNR,XPTRN9
         EDMK  CDATARNR,XGRECCNT
         S     REG01,=F'5'
         MVC   0(4,REG01),=C'RECD'
         CLI   WSWCTRST,C'1'
         BNE   DDHEXSW
         UNPK  XENUMTST,XGRECCNT
         OI    XENUMTST+8,X'F0'
         MVC   HOLDCARD(9),XENUMTST
         PUT   CNTRSET,HOLDCARD
* * * * IF HEX PRINTING WILL BE DONE, THE NO-OP INSTRUCTION WILL BE
*       AN UNCONDITIONAL BRANCH TO THE CODE FOR HEX FORMAT, OTHERWISE
*       IT WILL REMAIN A NO-OP FOR DISPLAY FORMAT. FOR DISPLAY THE
*       BYTE COUNTER IS INCREMENTED BY 100 AND THE VALUE IS EDITED
*       INTO THE 'FROM' LOCATION OF THE PRINTLINE. PRINTLINE LENGTH
*       (100) IS ADDED TO A COUNTER FOR RECORD LENGTH AND THE RECORD
*       LRECL COMPARED TO IT. IF THE RECORD IS SHORTER THAN LENGTH
*       COUNTER, ITS LRECL IS USED TO MOVE THE RECORD FOR PRINTING,
*       ELSE 100 IS USED TO START PRINTING PART OF THE RECORD.
DDHEXSW  NOP   DDHEXSET
         AP    XDDATAFR,=P'100'
         MVC   XPTRNFR,XPTRN5
         ED    XPTRNFR,XDDATAFR
         AP    XDRECLW2,=P'100'
         CP    XDRECLST,XDRECLW2
         BL    STLRECL
         ZAP   XDCHARS,=P'100'
         B     DDMVDATA
STLRECL  ZAP   XDCHARS,XDRECLST
         SP    XDCHARS,XDRECLW1
* * * * AFTER ADJUSTING FOR VARIABLE LENGTH RECORD, THE ENTIRE RECORD
*       OR PART OF IT IS MOVED TO THE OUTPUT LINE WHERE THE DATA IS
*       TRANSLATED TO PRINTABLE CHARACTERS AND ASTERISKS.
DDMVDATA ZAP   XZHLDNR,XDCHARS
         CVB   REG02,XZHLDNR
         S     REG02,=F'1'
         STC   REG02,XDMVCHAR
         ZAP   XZHLDNR,XDRECLW1
         CVB   REG02,XZHLDNR
         L     REG01,XDSTRG01
         AR    REG01,REG02
         MVC   *+7(1),XDMVCHAR
         MVC   CDATAINF,0(REG01)
         TR    CDATAINF,WCTRNTB1
         B     DDSETLIN
         EJECT
* * * * HEX FORMAT INITIALIZING IS THE SAME AS THAT FOR DISPLAY
*       FORMAT EXCEPT 32 IS USED AS THE LINE LENGTH OF PRINTED DATA.
DDHEXSET AP    XDDATAFR,=P'32'
         MVC   XPTRNFR,XPTRN5
         ED    XPTRNFR,XDDATAFR
         AP    XDRECLW2,=P'32'
         CP    XDRECLST,XDRECLW2
         BL    STOLRECL
         ZAP   XDCHARS,=P'32'
         B     DDHEXMV1
STOLRECL ZAP   XDCHARS,XDRECLST
         SP    XDCHARS,XDRECLW1
* * * * THE ENTIRE RECORD OR 32 BYTES WORTH OF IT IS MOVED TO THE
*       RIGHTMOST 32 BYTES OF THE PRINTLINE.  THIS DATA IS THEN
*       UNPACKED AND FORMATTED FOR HEX INTO THE HEX PORTION OF THE
*       LINE.  THE RIGHTMOST 32 BYTES ARE TRANSLATED INTO DISPLAY
*       FORMAT.
DDHEXMV1 ZAP   XZHLDNR,XDCHARS
         CVB   REG02,XZHLDNR
         S     REG02,=F'1'
         STC   REG02,XDMVCHAR
         ZAP   XZHLDNR,XDRECLW1
         CVB   REG02,XZHLDNR
         L     REG01,XDSTRG01
         AR    REG01,REG02
         MVC   *+7(1),XDMVCHAR
         MVC   CDATAINF+68(32),0(REG01)
         B     HEXRTN
SPACES   DC    CL67' '
MVSPC    MVC   0(0,REG02),SPACES      EXEC. 5 INSTS PAST CLEARLN
         ORG   *-240                  TRANSLATE TABLE FOR UNPACKED DATA
TRTBL    EQU   *
         ORG
         DC    CL16'0123456789ABCDEF'
CVBWKA   DC    D'0'                   WORK AREA FOR 'CVB' INST.
HEXRTN   LA    REG02,CDATAINF-1       BEGINNING OF HEX PORTION OF LINE
         LA    REG03,CDATAINF+68      BEGINNING OF CHAR PORTION OF LINE
         LA    REG04,4                CONSTANT FOR LOOPING 4 TIMES
UNPACK   EQU   *
         UNPK  0(9,REG02),0(5,REG03)  FORM 16 HEX BYTES FROM 8 CHAR
         UNPK  8(9,REG02),4(5,REG03)    BYTES
         LA    REG02,17(REG02)        INCREMENT HEX POINTER
         LA    REG03,8(REG03)         INCREMENT CHAR POINTER
         BCT   REG04,UNPACK           UNPACK 4 TIMES FOR ONE LINE
         TR    CDATAINF-1(67),TRTBL   MOVE PRNTABL CHARS INTO HEX LINE
         MVI   CDATAINF+15,C' '       FORMAT HEX LINE WITH SPACES
         MVI   CDATAINF+32,C' '
         MVI   CDATAINF+49,C' '
         MVC   CDATAINF+66(2),SPACES
         CP    XDCHARS,=P'32'         IF THERE ARE LESS THAN 32 CHARS
         BNL   SECTRANS                 IN THE LINE, REMAINDER OF LINE
*                                       MUST BE BLANKED
         ZAP   CVBWKA,XDCHARS
         CVB   REG02,CVBWKA
         SLL   REG02,1                MULTIPLY LENGTH BY 2 TO = HEX LEN
         SR    REG03,REG03            START WITH ZERO OFFSET: 67-1 FOR
         LA    REG04,66                 LENGTH OF MOVE
SCANLINE EQU   *
         S     REG02,=F'16'           SUBTRACT 16 FROM NO-CHARS &
         BNP   CLEARLN                  ADJUST START LOCATION & LENGTH
         LA    REG03,17(REG03)          IF VALUE STILL POSITIVE
         S     REG04,=F'17'
         B     SCANLINE
CLEARLN  EQU   *
         LA    REG02,16(REG02)        ADD 16 BACK INTO COUNT TO GET
*                                       NUMBER OF BYTES IN LAST BLOCK
         AR    REG03,REG02            ADD RESIDUAL COUNT TO START
         SR    REG04,REG02              LOCATION & SUBTRACT IT FROM
         LA    REG02,CDATAINF-1(REG03)  LENGTH
         EX    REG04,MVSPC            MOVE SPACES PER LENGTH CALCULATED
SECTRANS TR    CDATAINF+68(32),WCTRNTB1
* * * * THE BYTE COUNTER IS UPDATED BY THE NUMBER OF BYTES TRANSLATED,
*       AND THAT VALUE IS ALSO EDITED INTO THE OUTPUT LINE AT THE
*       'TO' LOCATION. AT END OF PAGE THE NUMBER AND DOT HEADER IS
*       PRINTED BEFORE SKIPPING TO THE NEXT PAGE. THE PAGE COUNTER
*       IS INCREMENTED, EDITED INTO THE TITLE HEADER AND THE TWO
*       TOP HEADERS ARE PRINTED. IF END OF PAGE HAS NOT BEEN REACHED,
*       THIS CODE IS BRANCHED AROUND.
DDSETLIN AP    XDRECLW1,XDCHARS
         AP    XDDATATO,XDCHARS
         MVC   CDATATO,XPTRN5
         EDMK  CDATATO,XDDATATO
         S     REG01,=F'10'
         MVC   2(7,REG01),XPFROMTO+2
         CP    XDLNCNT,=P'58'
         BL    DDPRTLN
         CP    XDPGCNT,=P'0'
         BE    PAGECNTR
MJFORCPG EQU   *                   BOTTOM CURRENT PAGE AND START   MBJ1
*                                  A NEW ONE                       MBJ1
         BAL   REG08,ANPTHDRB
PAGECNTR AP    XDPGCNT,=P'1'
         MVC   AHDRPGNR,XPTRN5
         EDMK  AHDRPGNR,XDPGCNT
         S     REG01,=F'6'
         MVC   0(5,REG01),=C' PAGE'
         BAL   REG08,ANPTHDRA
         BAL   REG08,ANPTHDRB
         ZAP   XDLNCNT,=P'3'
         MVI    CCDIG,X'F0'
* * * * LINE COUNTER IS INCREMENTED, CARRIAGE CONTROL CHANGED TO
*       SINGLE SPACING AND THE TRANSLATED DATA IS PRINTED. IF THE
*       NUMBER OF BYTES PRINTED IS LESS THAN THE RECORD LENGTH,
*       PRINTING OF THE RECORD CONTINUES, ELSE RECORDS-PROCESSED
*       IS COMPARED TO THE PRINT OPTION VALUE. IF RECORDS-PROCESSED
*       IS EQUAL TO THE PRINT VALUE, THE PROGRAM CHECKS FOR ANOTHER
*       START VALUE.  IF PRESENT, START, SKIP & PRINT ARE REINITIALIZED
*       & PROCESSING RESUMES.  IF NO MORE STARTS EXIST OR IF THE
*       FINAL PRINT HAS BEEN SATISFIED, EOJ IS BRANCHED TO.
DDPRTLN  AP    XDLNCNT,=P'1'
         CLI    CCDIG,X'40'
         BE    PRNTDATA
         AP    XDLNCNT,=P'1'
*******CHECK FOR EXIT - IF EXIT REQUESTED TAKE IT                  MBJ1
*      IF RC=4 START A NEW PAGE (MJPGSW INSURES EXIT               MBJ1
*      IS TAKEN ONLY ONCE PER RECORD)                              MBJ1
PRNTDATA EQU   *                                                   MBJ1
         MVI   SELECTED,X'80'      SET RECORD-SELECTED SWITCH      RHC2
         TS    MJPGSW              IF EXIT ALREADY TAKEN           MBJ1
         BNZ   MJPRNTDA                GO ON WITH WRITING          MBJ1
         MVC   MJINADDR,XDSTRG01   POINT PARM LIST TO INPUT REC    MBJ1
         L     R15,MJEXITEP        TAKE USER EXIT                  MBJ1
         LA    R1,MJUSRPRM         GIVE PARM TO USER               MBJ1
         BALR  R14,R15             *                               MBJ1
         C     R15,=F'4'           RC=4                            MBJ1
         BE    MJFORCPG            USER WANTS NEW   PAGE           MBJ1
MJPRNTDA EQU   *                                                   MBJ1
         MVI   MJPGSW,BIN00        CLEAR THE EXIT SWITCH           MBJ1
         BAL   REG08,ANPTDTAC      WRITE ON PRINTSET               MBJ1
         TS    MJGETFLG            HAS IMAGE BEEN WRITTEN          MBJ1
         BNZ   MJNOIMAG            YES - BY-PASS IMAGE WRITING     MBJ1
         L     R2,XDSTRG01                                         MBJ1
         CHKPUT  MJSIEVE,0(R2)     WRITE IMAGE IF NEEDED           MBJ1
MJNOIMAG EQU   *                                                   MBJ1
         CP    XDRECLW1,XDRECLST
         BL    DDHEXSW
         CP    XGRECPRC,XGPRNT
         BL    DDREAD
         A     REG06,=F'27'
COMPDATA CLC   0(9,REG06),=C'999999999'
         BE    DREQDONE
         CLC   0(9,REG06),=C'000000000'
         BNE   PACKDATA
         A     REG06,=F'27'
         B     COMPDATA
PACKDATA PACK  XGSTRT(5),0(9,REG06)
         PACK  XGPRNT(5),9(9,REG06)
         PACK  XGSKIP(5),18(9,REG06)
         ZAP   XGRECPRC,ZEROS
         B     DDREAD
         EJECT
* * * * THE FINAL DOTS AND NUMBER HEADER IS PRINTED BEFORE PRINTING
*       OUT SUMMARY INFORMATION ABOUT THE PRINTED DATA. IF NO RECORDS
*       WERE PROCESSED BECAUSE OF AN ERROR CONDITION, THE DOT/NUMBER
*       HEADER IS NOT PRINTED, BUT THE SUMMARY LINE IS.  AFTER PRINTING
*       THE SUMMARY LINE, ALL FILES ARE CLOSED.
DREQEND  DS    0H                                                  RHC2
         L     R3,XDSTRG01         FLUSH RANGE-END RECORD          RHC2
         CHKPUT UTLSYS05,0(R3)                                     RHC2
DREQDONE MVC   EOJCNST(32),=C'**** REQUESTED RECORDS WRITTEN'
         TM    UTLSYS05+48,X'10'   IS COMPLEMENT FILE OPEN ?       RHC2
         BNO   DEOFDATA                                            RHC2
LASTLOOP L     R1,ADATASET                                         RHC2
         USING IHADCB,R1                                           RHC2
         TM    DCBOFLGS,MJOPNBIT                                   RHC2
         BZ    DEOFDATA                                            RHC2
         GET   (1)                                                 RHC2
         DROP  R1                                                  RHC2
         LR    R3,R1                                               RHC2
         CHKPUT UTLSYS05,0(R3)                                     RHC2
         B     LASTLOOP                                            RHC2
DEOFDATA CP    XGRECPRC,=P'0'
         BE    PRNTHDR1
         BAL   REG08,ANPTHDRB
         B     SUMMARY
PRNTHDR1 BAL   REG08,ANPTHDRA
SUMMARY  MVC   EOJINREC,=X'40202020202020202120'
         MVC   EOJPRREC,=X'40202020202020202120'
         MVC   EOJPRPGS,=X'402020202120'
         ED    EOJINREC,XGRECCNT
         ED    EOJPRREC,XGTOTPRT
         ED    EOJPRPGS,XDPGCNT
         MVC   BHDRDATA,EOJCNST
         BAL   REG08,ANPTHDRB
         MVI    CCDIG,X'F1'
         BAL   REG08,ANPTDTAC
         BAL   REG08,ANPTSYS1
         MVC   SYSDATA,EOJCNST
         BAL   REG08,ANPTSYS1
*     PRINT FILE SUMMARY                                           RHC2
         BAL   REG08,ANPTSYS1      PRINT BLANK LINE                RHC2
         MVC   SYSDT6,=C'FILE SUMMARY'                             RHC2
         BAL   REG08,ANPTSYS1      PRINT FILE SUMMARY TITLE        RHC2
         BAL   REG08,ANPTSYS1      PRINT BLANK LINE                RHC2
         MVC   SYSDT1,=C'DDNAME'                                   RHC2
         MVC   SYSDT2,=C'DSORG'                                    RHC2
         MVC   SYSDT3,=C'RECFM'                                    RHC2
         MVC   SYSDT4,=C'LRECL'                                    RHC2
         MVC   SYSDT5,=C'BLKSIZE'                                  RHC2
         BAL   REG08,ANPTSYS1      PRINT COLUMN HEADINGS           RHC2
         BAL   REG08,ANPTSYS1      PRINT BLANK LINE                RHC2
         EXTRACT MJDDBOX,FIELDS=(TIOT)                             RHC2
         LA    RDDLOOP,7           7 FILES TO SUMMARIZE            RHC2
RTIOT    EQU   4                                                   RHC2
         L     RTIOT,MJDDBOX       ADDRESS TIOT                    RHC2
         USING IHADCB,R2                                           RHC2
         SR    RDDCONT,RDDCONT                                     RHC2
FSUM0010 EQU   *                                                   RHC2
         EX    *-*,MJLADCBS(RDDCONT)                               RHC2
         TM    DCBOFLGS,MJOPNBIT   IS FILE OPEN                    RHC2
         BNO   FSUM0020            NO - BRANCH                     RHC2
         LH    R1,DCBTIOT          OFFSET TO TIOT ENTRY            RHC2
         AR    R1,RTIOT            ADD TIOT BASE ADR               RHC2
         LA    R1,4(R1)            ADD OFFSET TO DDNAME            RHC2
         MVC   SYSDDDNM(8),0(R1)   MOVE DDNAME TO MSG              RHC2
         TM    DCBDSORG,X'80'      ISAM                            RHC2
         BNO   FSUM0031                                            RHC2
         MVC   SYSDDSOR(2),=C'IS'                                  RHC2
         B     FSUM0039                                            RHC2
FSUM0031 TM    DCBDSORG,X'40'      SEQUENTIAL                      RHC2
         BNO   FSUM0032                                            RHC2
         MVC   SYSDDSOR(2),=C'PS'                                  RHC2
         B     FSUM0039                                            RHC2
FSUM0032 TM    DCBDSORG,X'20'      DIRECT                          RHC2
         BNO   FSUM0033                                            RHC2
         MVC   SYSDDSOR(2),=C'DA'                                  RHC2
         B     FSUM0039                                            RHC2
FSUM0033 TM    DCBDSORG,X'02'      PARTITIONED                     RHC2
         BNO   FSUM0034                                            RHC2
         MVC   SYSDDSOR(2),=C'PO'                                  RHC2
         B     FSUM0039                                            RHC2
FSUM0034 MVC   SYSDDSOR(2),=C'**'                                  RHC2
FSUM0039 TM    DCBDSORG,X'01'      UNMOVABLE                      RHC2
         BNO   FSUM0038                                            RHC2
         MVC   SYSDDSOR+2(1),=C'U'                                 RHC2
FSUM0038 EQU   *                                                   RHC2
         TM    DCBRECFM,X'C0'      RECFM=U                         RHC2
         BNO   FSUM0041                                            RHC2
         MVI   SYSDRECF,C'U'                                       RHC2
         B     FSUM0049                                            RHC2
FSUM0041 TM    DCBRECFM,X'80'      RECFM=FX                        RHC2
         BNO   FSUM0042                                            RHC2
         MVI   SYSDRECF,C'F'                                       RHC2
         B     FSUM0049                                            RHC2
FSUM0042 TM    DCBRECFM,X'40'      RECFM=VX                        RHC2
         BNO   FSUM0043                                            RHC2
         MVI   SYSDRECF,C'V'                                       RHC2
         B     FSUM0049                                            RHC2
FSUM0043 MVI   SYSDRECF,C'*'                                       RHC2
FSUM0049 EQU   *                                                   RHC2
         TM    DCBRECFM,X'10'      RECFM=XB                        RHC2
         BNO   FSUM0051                                            RHC2
         MVI   SYSDRECF+1,C'B'                                     RHC2
FSUM0051 EQU   *                                                   RHC2
         TM    DCBRECFM,X'08'      RECFM=XXS                       RHC2
         BNO   FSUM0061                                            RHC2
         MVI   SYSDRECF+2,C'S'                                     RHC2
FSUM0061 EQU   *                                                   RHC2
         TM    DCBRECFM,X'20'      RECFM=XXXT                      RHC2
         BNO   FSUM0071                                            RHC2
         MVI   SYSDRECF+3,C'T'                                     RHC2
FSUM0071 EQU   *                                                   RHC2
         TM    DCBRECFM,X'04'      RECFM=XXXXA                     RHC2
         BNO   FSUM0081                                            RHC2
         MVI   SYSDRECF+4,C'A'                                     RHC2
         B     FSUM0089                                            RHC2
FSUM0081 TM    DCBRECFM,X'02'      RECFM=XXXXM                     RHC2
         BNO   FSUM0082                                            RHC2
         MVI   SYSDRECF+4,C'M'                                     RHC2
         B     FSUM0089                                            RHC2
FSUM0082 MVI   SYSDRECF+4,C' '                                     RHC2
FSUM0089 EQU   *                                                   RHC2
         LH    R8,DCBLRECL                                         RHC2
         MVC   SYSDLREC-1(6),FSUMEDPT                              RHC2
         CVD   R8,FSUMDBL                                          RHC2
         ED    SYSDLREC-1(6),FSUMDBL+5                             RHC2
         OI    SYSDLREC+4,X'F0'                                    RHC2
         LH    R8,DCBBLKSI                                         RHC2
         MVC   SYSDBLKS-1(6),FSUMEDPT                              RHC2
         CVD   R8,FSUMDBL                                          RHC2
         ED    SYSDBLKS-1(6),FSUMDBL+5                             RHC2
         OI    SYSDBLKS+4,X'F0'                                    RHC2
         B     FSUM0099                                            RHC2
FSUM0020 MVC   SYSDDDNM(8),DCBDDNAM                                RHC2
         MVC   SYSDDSOR(8),=C'NOT OPEN'                            RHC2
FSUM0099 BAL   REG08,ANPTSYS1                                      RHC2
         LA    RDDCONT,4(RDDCONT)  NEXT DCB                        RHC2
         BCT   RDDLOOP,FSUM0010                                    RHC2
*      CLOSE DOWN ALL FILES NOW OPEN                               MBJ1
         XC    MJCLOSEP(7*4),MJCLOSEP CLEAR CLOSE PARM             MBJ5
         SR    RDDCONT,RDDCONT     INITALIZE OFFSET-EX             MBJ1
         LA    RDDLOOP,7           7 FILES TO CLOSE                RHC2
         SR    RCLSOFF,RCLSOFF     INITALIZE OFFSET-PARM           MBJ1
MJCLSLP  EQU   *                                                   MBJ1
         EX    *-*,MJLADCBS(RDDCONT)  LA R2,- DCB OF FILE          MBJ1
         USING IHADCB,R2                                           MBJ1
         TM    DCBOFLGS,MJOPNBIT     FILE OPEN                     MBJ1
         BZ    MJCLSNXT              NO - DON'T ADD TO PARM        MBJ1
         ST    R2,MJCLOSEP(RCLSOFF)  YES - ADD TO CLOSE LIST       MBJ1
         LA    RCLSOFF,4(RCLSOFF)    BUMP PARM OFF SET             MBJ1
MJCLSNXT EQU   *                                                   MBJ1
         LA    RDDCONT,4(RDDCONT)  BUMP OFF SET IN LA LIST       MBJ1
         BCT   RDDLOOP,MJCLSLP     LOOP TILL ALL OPEN FILES IN LISTMBJ1
         LTR   RCLSOFF,RCLSOFF     ARE ANY BEING CLOSED            MBJ4
         BZ    DXRTRN                NO - BY PASS CLOSE AND FREE   MBJ4
         SH    RCLSOFF,=H'4'       BACK OFF ONE DCB ADDRESS        MBJ1
         LA    R15,MJCLOSEP(RCLSOFF)   LOAD ADDRESS OF END OF PARM MBJ1
         OI    0(R15),X'80'        TURN ON END OF CLOSE LIST FLAG  MBJ1
         CLOSE ,MF=(E,MJCLOSEP)    CLOSE ALL FILES                 MBJ1
*                                  DO A FREE POOL IF INPUT         MBJ4
*                                  FILE IS A QSAM FILE             MBJ4
*                                  (DATASET) DO NOT FREEPOOL       MBJ4
*                                  IF ISAM                         MBJ4
         LA    RDDLOOP,7           UP TO 7 FILES TO FREEPOOL       MBJ4
         LA    R8,ISAMSET                                          MBJ4
         CLC   =X'80000000',MJCLOSEP  IF NO FREEPOOLS              MBJ4
         BE    DXRTRN              GOTO DXRTRN                     MBJ4
         LA    REG04,MJCLOSEP      FREE DCB'S ONE AT A TIME        MBJ4
*                                  AVOIDING ISAMSET                MBJ4
FREELP   DS    0H                                                  MBJ4
         L     R2,0(,REG04)        GET FIRST/NEXT DCB ADDR         MBJ4
         LA    R2,0(,R2)                                           MBJ4
         CR    R2,R8               AVOID ISAMSET                   MBJ4
         BE    FREENXT                                             MBJ4
         LTR   R2,R2               DISREGARD ZERO ENTRIES          MBJ4
         BZ    FREENXT                                             MBJ4
         FREEPOOL (R2)                                             MBJ4
FREENXT  DS    0H                                                  MBJ4
         TM    0(REG04),X'80'      END OF PARM                     MBJ4
         BO    DXRTRN              YES - END IT                    MBJ4
         LA    REG04,4(,REG04)     ADVANCE ONE DCB                 MBJ4
         BCT   RDDLOOP,FREELP                                      MBJ4
DXRTRN   L     13,XZSAVERG+4
         RETURN (14,12),RC=0        RETURN TO CALLER               MBJ5
*   DICTIONARY TO PATCH MBJ1                                       MBJ1
R14      EQU   14
R15      EQU   15
R1       EQU   1                   REG1                            MBJ1
R2       EQU   2                                                   MBJ1
R10      EQU   10                                                  MBJ5
REXIT    EQU   7                                                   MBJ1
RDDALT   EQU   15                                                  MBJ1
RDDEND   EQU   14                                                  MBJ1
R3       EQU   3                                                   MBJ1
RDDCONT  EQU   7                                                   MBJ1
R0       EQU   0                                                   MBJ1
BIN00    EQU   X'00'
RCLSOFF  EQU   R1                  CONTROLS THE CLOSE OFFSET
RDDCOUNT EQU   RDDCONT
MJOPNBIT EQU   X'10'               DCB OPEN FLAG                   MBJ1
R4       EQU   4                                                   MBJ5
RPARM    EQU   R4                                                  MBJ5
RLEN     EQU   R3                  USED FOR LENGTH DURING EX INST  MBJ5
RHOLD    EQU   R8                                                  MBJ5
RTEXT    EQU   R10
TAKEEXIT EQU   X'40'               TAKE USER PUT EXIT FLAG         MBJ1
RDDLOOP  EQU   R3                                                  MBJ1
MJEXIT   DC    C'EXIT='             LITERAL FOR PARM CLC           MBJ1
FSUMDBL  DS    D                                                   RHC2
MASKFF   DC    0F'0',XL4'FF000000'
H6       DC    H'6'                                                MBJ1
MJGETFLG DC    X'00'               PREVENT DOUBLE IMAGE FLAG       MBJ1
MJPGSW   DS    X                                                   MBJ1
MJEXITSW DC    X'00'               EXIT SWITCH                     MBJ1
SELECTED DC    X'40'               RECORD-SELECTED SWITCH          RHC2
FSUMEDPT DC    X'402020202021'
MJEXITEP DC    V(IEFBR14)          OUTPUT USER EXIT ADDRESS        MBJ5
MJEXITIN DC    V(IEFBR14)          INPUT PROCESSING EXIT           MBJ5
MJ8ZEROS DC    XL8'00'                                             MBJ1
MJDDBOX  DS    6F                  DEVTYPE ANSWER BOX              MBJ1
MJCLOSEP DC    8F'0'               7 ENTRIES FOR CLOSE             MBJ4
*                                  USER PARM                       MBJ1
MJUSRPRM DS    0F                                                  MBJ1
MJINADDR DS    F                   IN COMING RECORD ADDRESS        MBJ1
         DC    A(CDATALN)          OUT GOING RECORD                MBJ1
MJINDCB  DS    0F                  ADDRESS OF INPUT DCB MAY VARY   MBJ5
         DC    A(DATASET)          INCOMING DCB                    MBJ1
         DC    A(PRINTSET)         OUTGOING  DCB (02)              MBJ4
         DC    A(CNTRSET)                        (03)              MBJ4
         DC    A(MJSIEVE)                        (04)              MBJ4
         DC    A(UTLSYS05)                       (05)              MBJ4
         DC    A(SSOUTSET)                       (SYSOUT)          MBJ4
         DC    AL1(128),AL3(CARDIN)              (UTLSYSIN)        MBJ4
         EJECT
         LTORG
* DUMMY DCB FOR USE IN REFERENCING AREAS IN THE DATA CONTROL BLOCK
* OF THE INPUT DATA SET AND PRINT DATA SET
         PRINT  NOGEN
         DCBD  DSORG=PS,DEVD=DA
         PRINT GEN
               EJECT
PARMIMAG DSECT ,                   PARM PASSED FROM EXEC
PLEN     DS    H                   NOT ON A DOUBLE WORD BOUND
PKEYWORD DC    C'EXIT='            STRING DESIRED IN PARM
PEXITNM  DS    CL8                 NAME OF EXIT
MJDDSECT DSECT ,                   ALTERNATE DDNAMES FROM CALLER
         CNOP  2,4                 ODD HALF WORD
MJDDLIST EQU   *
MJDDLEN  DS    H                   LENGTH OF LIST
         DC    4XL8'0'             4 UNUSED ENTRIES
MJDDIN   DC    C'UTLSYSIN'         ALTERNATE CONTROL FILE
MJDDOUT  DC    C'SYSOUT  '
         DC    XL8'0'              UNUSED
MJDD1    DC    C'UTLSYS01'
MJDD2    DC    C'UTLSYS02'
MJDD3    DC    C'UTLSYS03'
MJDD4    DC    C'UTLSYS04'
MJDD5    DC    C'UTLSYS05'                                         RHC2
* PULL EXIT NAMES AND ADDRESSES OUT OF EXIT KEY WORD               MBJ5
* ONE FOR PARM LIST ONE FOR CONTROL CARDS.
*
* PARM, MESSAGE DCB, ADDRESS OF OUTPUT EXIT, ADDRESS OF INPUT EXIT
EXITPARM CSECT ,
*LINKAGE
         SAVE  (14,12),,EXITPARM&UPDATE
         BALR  USBASE,0
         USING *,USBASE
         LA    USRWORK,EXPSAVE
         ST    USR13,4(,USRWORK)   CHAIN SAVE AREAS
         ST    USRWORK,8(,USR13)
         LR    USR13,USRWORK
         MVC   EXTEXT,=CL30' '     CLEAR WORK AREA
         LR    RPARM,R1            SAVE PARM INFO
         L     RTEXT,0(,RPARM)     ADDRESS INFO FROM EXEC CARD
         LH    RLEN,0(,RTEXT)      GET LENGTH
         LTR  RLEN,RLEN            BE SURE THAT CHAR COUNT POS.
         BNP   EXRET               IF NO TEXT - RETURN
         C     RLEN,=A(L'EXTEXT)   DON'T MOVE MORE THAN TEXT HOLDS
         BH    EXRET
         BCTR  RLEN,*-*            REDUCE BY ONE
         EX    RLEN,EXMVC          MOVE PARM TEXT TO WORK AREA
         LA    USRWORK,EXTEXT       REPLACE CARD TEXT WITH OUR TEXT
         ST    USRWORK,0(,RPARM)    IN PARM LIST
         LR    R1,RPARM
         CALL  EXCOMMON            GO TO STANDARD ROUTINE
EXRET    DS    0H
         GOBACK RC=0               RETURN TO UTLPRINT
EXMVC    MVC   EXTEXT(*-*),2(RTEXT) MOVE TEXT PORTION
EXPSAVE  DC    18F'0'              SAVE AREA
         LTORG
         ENTRY EXITCARD
EXITCARD DS    0H
*LINKAGE
         SAVE  (14,12),,EXITCARD&UPDATE
         BALR  USBASE,0
         USING *,USBASE
         LA    USRWORK,EXCDSAVE
         ST    USR13,4(,USRWORK)   CHAIN SAVE AREAS
         ST    USRWORK,8(,USR13)
         LR    USR13,USRWORK
         MVC   EXTEXT,=CL30' '     CLEAR WORK AREA
         LR    RPARM,R1            SAVE PARM INFO
         L     RTEXT,0(,RPARM)     GET EXIT TEXT
         USING EXDSECT,RTEXT
         CLC   =C'EXIT=(',EXKEYWD  IS THERE A PAREN
         BE    EXMULTI             YES - MULTIPLE EXITS
         XC    EXTRTBL,EXTRTBL     CLEAR TABLE
         MVI   EXTRTBL+C' ',C' '   SET UP TRT TO LOOK FOR END
         MVI   EXTRTBL+X'FF',X'FF' OF KEY WORD
         MVI   EXTRTBL+C',',C','
         LA    R1,EXKEYWD+5        SET DEFAULT END
         TRT   EXKEYWD+5,EXTRTBL   FIND END
         LA    RLEN,EXKEYWD        START OF KEYWORD
         SR    R1,RLEN             R1 CONTAINS LENGTH OF KEY WORD
*                                  LESS ONE
         LR    RLEN,R1
         B     EX2MOV              STANDARD MOVE
EXMULTI  DS    0H
         XC    EXTRTBL,EXTRTBL
         MVI   EXTRTBL+C' ',C' '   FIND END OF KEY WORD
         MVI   EXTRTBL+C')',C')'        EXIT=(XXX,XXXX)
         LA    R1,EXKEYWD+5        DEFAULT END
         TRT   EXKEYWD+5,EXTRTBL   FIND END
         LA    RLEN,EXKEYWD
         SR    R1,RLEN             R1 NOW CONTAINS LENGTH OF KWD -1
         LR    RLEN,R1
         B     EX2MOV              STANDARD MOVE
EX2MOV   DS    0H
         EX    RLEN,EX2MVC         MOVE KEYWORD TO COMMON AREA
         EX    RLEN,EX2MVSTR       SMASH KYWD SO COMMA AND () DON'T
*                                  CONFUSE ANY ONE
         LA    USRWORK,EXTEXT       REPLACE CONT CARD TEXT WITH OURS
         ST    USRWORK,0(,RPARM)
         LR    R1,RPARM
         CALL  EXCOMMON
         GOBACK RC=0
         DROP  RTEXT
EX2MVC   MVC   EXTEXT(*-*),0(RTEXT) MOVE TEXT FROM CONTROL CARD
EX2MVSTR MVC   0(*-*,RTEXT),=C'*************************'
EXTEXT   DC    CL30' '             HOLD AREA FOR EXIT= TEXT
EXCDSAVE DS    18F
         LTORG
         ENTRY EXCOMMON
EXCOMMON DS    0H
         SAVE  (14,12),,EXCOMMON&UPDATE
         BALR  USBASE,0
         USING *,USBASE
         LA    USRWORK,EXCMSAVE
         ST    USR13,4(,USRWORK)   CHAIN SAVE AREAS
         ST    USRWORK,8(,USR13)
         LR    USR13,USRWORK
         LR    RPARM,R1            SAVE PARM
         L     RTEXT,0(,RPARM)     GET KEY WORD
         USING EXDSECT,RTEXT       ADDRESS THE KEY WORD MAP
         MVC   EXBOX1,=CL8' '      SET DEFAULT
         MVC   EXBOX2,=CL8' '      SET DEFAULT
         CLC   =C'EXIT=(',EXKEYWD  MULTIPLE EXITS
         BE    EXCMULT             YES HANDLE 2
         XC    EXTRTBL,EXTRTBL
         MVI   EXTRTBL+C' ',4      FIND END OF THE OPERAND THAT
         MVI   EXTRTBL+C',',4      STARTS AT EXKEYWD+5
         MVI   EXTRTBL+X'FF',4
         LA    RLEN,EXKEYWD+5
         TRT   EXKEYWD+5,EXTRTBL   END OF NAME FOUND
         SR    R1,RLEN             LENGTH FOUND
         LTR   RLEN,R1
         BNP   EXCNO1              IF NULL - EXIT
         BCTR  RLEN,*-*            REDUCE FOR EX
         EX    RLEN,EXMVC1         MOVE EXIT NAME TO BOX1
EXCNO1   DS    0H
         B     EXLOADM             GO LOAD IN THE EXITS
         SPACE 1
EXCMULT  DS    0H
         XC    EXTRTBL,EXTRTBL
         MVI   EXTRTBL+C' ',4      ANY ONE OF THESE WILL END OPERAND
         MVI   EXTRTBL+C')',4
         MVI   EXTRTBL+C',',8
         MVI   EXTRTBL+X'FF',4
         LA    R2,4                SET DEFAULT END CHARACTER
         LA    R1,EXKEYWD+6        SET DEFAULT END
         TRT   EXKEYWD+6,EXTRTBL   FIND END OF OPERAND
         LA    RLEN,EXKEYWD+6      STARTING LOCATION
         LR    RHOLD,R1
         SR    R1,RLEN             MINUS END GIVES LENGTH OF FIRST
*                                  MODULE NAME
         LTR   RLEN,R1             IF NO CHARACTERS
         BNP   EX2NO1ST            NO FIRST
         C     RLEN,=F'8'          MAX 8 CHARACTERS IN NAME
         BH    EX2NO1ST
         BCTR  RLEN,*-*            REDUCE LENGTH FOR EX
         EX    RLEN,EXMVC1B        MOVE NAME OF FIRST MODULE
EX2NO1ST DS    0H
*        IF SEARCH FOR END OF FIRST WAS CLOSED WITH A ')' OR BLANK
*        THERE IS NO SECOND
*        ONLY A COMMA (TRT CODE 8) INDICATES A SECOND EXIT.
         CH    R2,=Y(4)            DID TRT SET 4 FOR CLOSURE
         BE    EX2NO2ND            NO SECOND MODULE SUPPLIED
* I'M SITTING WITH RHOLD POINTING TO A COMMA
         LA    RLEN,1(,RHOLD)      SET DEFAULT END OF SCAN
         TRT   1(9,RHOLD),EXTRTBL  LOOK FOR END OF SECOND NAME
         SR    R1,RLEN             COMPUTE LENGTH OF MOVE
         LTR   RLEN,R1
         BNP   EX2NO2ND            IF NO CHARACTERS - DON'T MOVE
         BCTR  RLEN,*-*            REDUCE LENGTH FOR EX
         EX    RLEN,EXMVC2         MOVE NAME TO BOX2
EX2NO2ND DS    0H
EXLOADM  DS    0H
* TIME TO LOAD IN THE EXITS TO BE PASSED BACK (IF APPROPRIATE)
* FIRST EXIT NAMED IN BOX1
         CLC   EXBOX1,=CL8' '      DON'T LOAD IF NOTHING SUPPLIED
         BE    EXNOLD1
         LOAD  EPLOC=EXBOX1        GET THE USERS EXIT
         L     USRWORK,4(,RPARM)   GET POINTER TO EXIT ADDRESS
*                                       (MJEXITEP)
         ST    R0,0(,USRWORK)      STORE EXIT ADDRESS
*        MESSAGE TO USER
EXNOLD1  DS    0H
         CLC   EXBOX2,=CL8' '      DON'T LOAD EXIT 2 IF NOTHING
         BE    EXNOLD2
         LOAD  EPLOC=EXBOX2        GET 2ND EXIT
         L     USRWORK,8(,RPARM)   GET POINTER TO EXIT ADDRESS
*                                       (MJEXITIN)
         ST    R0,0(,USRWORK)      STORE INPUT EXIT ADDRESS
*        MESSAGE USER
* EXNOLD2
EXNOLD2  DS    0H
         GOBACK RC=0
EXMVC1   MVC   EXBOX1(*-*),EXKEYWD+5
EXMVC1B  MVC   EXBOX1(*-*),EXKEYWD+6
EXMVC2   MVC   EXBOX2(*-*),1(RHOLD)
         DROP  RTEXT
EXBOX1   DC    CL8' '               NAME OF FIRST EXIT
EXBOX2   DC    CL8' '              NAME OF SECOND EXIT
EXTRTBL  DC    256X'00'            DELIMITER TRTTABLE
EXCMSAVE DS    18F                 SAVEAREA
         LTORG
EXDSECT  DSECT ,
EXKEYWD  DS    C'EXIT=(IEFBR14,IEFBR14)  '
*  ALLOW USER TO PUT 'FORMAT4.DSCB' INTO DSNAME TO READ VTOC
*
         SPACE 5
VTOCCK1  CSECT ,                   ALLOW FORMAT4.DSCB
         SAVE  (14,12),,VTOCCK1&UPDATE
         BALR  USBASE,0
         USING *,USBASE
         LA    USRWORK,VTOCSAVE
         ST    USR13,4(,USRWORK)   CHAIN SAVE AREAS
         ST    USRWORK,8(,USR13)
         LR    USR13,USRWORK
RJFCB    EQU   11
         L     RJFCB,0(,R1)        GET ADDRESS OF JFCB
         USING JFCBDSEC,RJFCB
         CLC   =C'FORMAT4.DSCB',JFCBDSNM DOES USER WANT VTOC
         BNE   XITVTOC1            NO - EXIT
         MVC   JFCBDSNM(8),=X'0404040404040404'   CREATE DSNAME
         MVC   JFCBDSNM+8(36),JFCBDSNM
*
*        ADD   DCB INFO FOR          VTOC
*  AT ADD DCB INFO
* READ THE VTOC.  A FIXED UNBLOCK DATASET.
* 44 BYTE KEYS
* 96 BYTES OF DATA.
         MVC   JFCBLKSI,=Y(96)     DATA SIZE
         MVC   JFCLRECL,=Y(96)     DATA SIZE
         MVI   JFCKEYLE,44         DECLARE KEY SIZE
*        FORCE  RECFM=F
*
XITVTOC1 DS    0H
         GOBACK  RC=0
VTOCSAVE DC    18F'0'              SAVE AREA
         LTORG
JFCBDSEC DSECT ,                   MAP JFCB
         PRINT NOGEN
         IEFJFCBN
         PRINT GEN
         SPACE 4
* PLACE DSNAME INTO TITLE
* (MAIN LINE AHDRDSNM)
* IF DSNAME IS X'040404....' TITLE SAYS VOLUME TABLE OF CONTENTS
TITLDSN  CSECT ,
         SAVE  (14,12),,TITLDSN
         BALR  USBASE,0
         USING *,USBASE
         LA    USRWORK,TITLSAVE
         ST    USR13,4(,USRWORK)   CHAIN SAVE AREAS
         ST    USRWORK,8(,USR13)
         LR    USR13,USRWORK
RTITLE   EQU   10
         L     RJFCB,0(,R1)        GET JFCB ADDRESS
         L     RTITLE,4(,R1)       GET TITLE LINE (AHDRDSNM)
         USING JFCBDSEC,RJFCB
         USING TITLLINE,RTITLE
         MVC   TITLELIN,=CL40' '   CLEAR TITLE
         CLC   =X'04040404',JFCBDSNM    VTOC BEING READ
         BNE   TITLNORM            NO - GET NAME FROM JFCB
         MVC   TITLELIN,=CL44' VOLUME TABLE OF CONTENTS FROM  '
         MVC   TITLEVOL,JFCBVOLS   PLACE VOL SER INTO TITLE
         B     XITTITL             EXIT
TITLNORM DS    0H
         MVC   TITLELIN,JFCBDSNM
XITTITL  DS    0H
         GOBACK RC=0
TITLSAVE DS    18F                 SAVE AREA
         LTORG
TITLLINE DSECT ,                   MAP AHDRDSNM
TITLELIN DS    CL44                WHOLE DSN TITLE
         ORG   TITLELIN+32
TITLEVOL DS    CL6                 VOLUME SERIAL
         ORG
*********SUBROUTINE TO WRITE TRANSLATE TABLE AT HEAD OF LISTING
*        CALLER GIVE THE DCB ADDRESS, A BUFFER ADDRESS AND
*        THE TRANSLATE TABLE ADDRESS. A LINE OF HEX VERSION IS
*        PRINTED FOLLOWED BY THE TRANSLATED RESULT.  CHANGES
*        IN THE TRANSLATE TABLE AUTOMATCALLY CHANGE THE HEADING
*        ADDED NOVEMBER 72
UTLPRHTR CSECT ,                   MAY BE SEPARATELY ASSEMBLED
USBASE   EQU   12                  BASE FOR UTLPRHTR
USRWORK  EQU   11                  WORK REG
USR13    EQU   13
USRDCB   EQU   2                   SYSOUT DCB ADDRESS POINTER
USRBUF   EQU   3                   OUTPUT BUFFER IN UTLPRINT POINTER
USRTRTAB EQU   4                   TRANSLATE TABLE USED BY PRINT
*                                  HEX ROUTINE POINTER
USRHEX   EQU   5                   POINTS INTO FIRST OF TABLE PAIR
USRTRUE  EQU   6                   POINTS INTO 2ND   OF TABLE PAIR
USRLOOP  EQU   7                   CONTROLS LOOP OF 8 PAIRS
USRNEXT  EQU   8                   DESTINATION OF BCTR LOOP
         SAVE  (18,12),,*          ALL SYMBOLS START US
         BALR  USBASE,0            ADDRESSING
         USING  *,USBASE
         LA    USRWORK,USAVREG
         ST    USR13,4(USRWORK)    CHAIN
         ST    USRWORK,8(USR13)     SAVE
         LR    USR13,USRWORK         AREAS
         LM    USRDCB,USRTRTAB,0(1) LOAD DCB, BUFFER AND TR TABLE
         USING USDBUF,USRBUF       ADDRESS BUFFER VIA DSECT
         MVI   USDCONT+1,C' '      CAUSE SKIP TO NEW PAGE
         MVI   USDCONT,C'1'        BY PRINTING A BLANK LINE
         MVC   USDCONT+2(USDEND-USDCONT-2),USDCONT+1
         TM    X'30'(USRDCB),X'10'   IS FILE OPEN
         BZ    USNOFILE
         PUT   (USRDCB),USDBUF     WRITE THE BLANK LINE
         MVI   USDCONT,C'0'        DOUBLE SPACE
         LA    USRHEX,USPATRN1     LOAD ADDRESS OF HEX REPRESENTATIONS
         LA    USRTRUE,USPATRN2    LOAD ADDRESS OF TRUE BYTE REP.
         LA    USRLOOP,8           WRITE 8    PAIRS
*        PRINT HEX LINE.  MOVE THE 256 BYTES (32) AT A TIME)
*        TRANSLATE THEM AND PRINT.  REPEAT FOR ALL 8 PAIRS (32*8=256)
         BALR  USRNEXT,0           WILL LOOP TO NEXT INSTR FROM BCTR
         MVC   USDLINE,0(USRHEX)   FIRST/NEXT HEX LINE
         PUT   (USRDCB),USDBUF       WRITE TO PRINTER
         MVC   USDLINE,0(USRTRUE)  MOVE BINARY BYTES
         TR    USDLINE,0(USRTRTAB) TRANSLATE USING USER TR TABLE
         PUT   (USRDCB),USDBUF       WRITE TRANSLATED LINE SO USER KN
*                                  WHAT TO EXPECT AT RIGHT OF HEX PRINT
         LA    USRHEX,32*3(USRHEX)   BUMP TO NEXT HEADER
         LA    USRTRUE,32*3(USRTRUE)
         BCTR  USRLOOP,USRNEXT     PRINT ANOTHER HEADING
         MVC   USDCONT+2(USDEND-USDCONT-2),USDCONT+1
*                                  CLEAR BUFFER
USNOFILE EQU   *
         L     USR13,4(USR13)      BACK CHAIN
         RETURN  (14,12),RC=0
USAVREG  DC    18F'0'              SAVE AREA
USPATRN1 DS    0CL768              HEX HEADING
         DC    C' 00 01 02 03 04 05 06 07 08 09 0A 0B 0C 0D 0E 0F'
         DC    C' 10 11 12 13 14 15 16 17 18 19 1A 1B 1C 1D 1E 1F'
         DC    C' 20 21 22 23 24 25 26 27 28 29 2A 2B 2C 2D 2E 2F'
         DC    C' 30 31 32 33 34 35 36 37 38 39 3A 3B 3C 3D 3E 3F'
         DC    C' 40 41 42 43 44 45 46 47 48 49 4A 4B 4C 4D 4E 4F'
         DC    C' 50 51 52 53 54 55 56 57 58 59 5A 5B 5C 5D 5E 5F'
         DC    C' 60 61 62 63 64 65 66 67 68 69 6A 6B 6C 6D 6E 6F'
         DC    C' 70 71 72 73 74 75 76 77 78 79 7A 7B 7C 7D 7E 7F'
         DC    C' 80 81 82 83 84 85 86 87 88 89 8A 8B 8C 8D 8E 8F'
         DC    C' 90 91 92 93 94 95 96 97 98 99 9A 9B 9C 9D 9E 9F'
         DC    C' A0 A1 A2 A3 A4 A5 A6 A7 A8 A9 AA AB AC AD AE AF'
         DC    C' B0 B1 B2 B3 B4 B5 B6 B7 B8 B9 BA BB BC BD BE BF'
         DC    C' C0 C1 C2 C3 C4 C5 C6 C7 C8 C9 CA CB CC CD CE CF'
         DC    C' D0 D1 D2 D3 D4 D5 D6 D7 D8 D9 DA DB DC DD DE DF'
         DC    C' E0 E1 E2 E3 E4 E5 E6 E7 E8 E9 EA EB EC ED EE EF'
         DC    C' F0 F1 F2 F3 F4 F5 F6 F7 F8 F9 FA FB FC FD FE FF'
USPATRN2 DS    0CL768              TRUE BINARY BYTES
&BYTE    SETA  0
XZPATRN2 DS    0CL768
.NEXTBYT ANOP
         PRINT  ON
         DC    C'  ',AL1(&BYTE)
         PRINT  OFF
&BYTE    SETA  &BYTE+1
         AIF   (&BYTE LT 256).NEXTBYT
         PRINT ON
USDBUF   DSECT ,                   SAME AS CDATALN IN MAINLINE
USDCONT  DS    CL1                 CARRAGE CONTROL
         ORG   USDCONT+18
USDLINE  DS    CL96                OUTPUT LINE
USDEND   EQU   USDCONT+132           END OF LINE CLEARING
           END
