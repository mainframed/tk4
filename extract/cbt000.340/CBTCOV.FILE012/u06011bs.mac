     TITLE   'FORTRAN IN-CORE LINK EDITOR'
         MACRO
&NAME    ESDGEN    &OP
         LCLA      &K,&N
&K       SETA      N'&OP
&NAME    EQU       *
.LOOP    ANOP
&N       SETA      &N+1
         DC        CL8'&OP(&N)'
.*  FOLLOWING DC SETS UP SPECIAL SIGNAL TO INDICATE IBM ROUTINE
         DC        X'10'
         DC      VL3(&OP(&N))
         AIF       (&N LT &K).LOOP
         MEND
 EJECT
         MACRO
         FORTLINK  &NSUBPG=20,&TXTSIZE=100000,&NEXTREF=50,&NREFAHD=100,*
               &MAP=ASUSED
         LCLA      &VAL1,&VAL2,&VAL3,&VAL4
&VAL1    SETA      &TXTSIZE+(&NEXTREF*4)+(&NREFAHD*8)
.*   ABOVE VALUE FOR GETMAIN AND FREEMAIN
&VAL2    SETA      &NEXTREF*4
.*   ABOVE VALUE FOR SECOND VALUE OF 'LENSTOR'
&VAL3    SETA      &NREFAHD*8
.*   ABOVE VALUE FOR THIRD  VALUE OF 'LENSTOR'
&VAL4    SETA      (&NSUBPG+2)*24-1
.*   ABOVE VALUE FOR DS TO SET UP USERESD SPACE
 TITLE ' IN-CORE LINK-EDITOR          ROOT CSECT '
***********************************************************************
***   FORMAT OF TABLES
   SPACE 2
***     ESD TABLE.
***       *    NAME    * TYPE * POINTER *
***       *******************************
***        8 BYTES      1 BYTE  3 BYTES
***
***            SD       X'00'    ADDRESS OF SD
***            LD       X'01'    ADDRESS OF LD
***            ER       X'02'    ADDRESS OF 1ST ADCON IN UNRESOLVD CHAN
***            CM       X'05'    ADDRESS OF LENGTH OF COMMON
***        IBM ROUTINE  X'10'    ADDRESS OF THIS ROUTINE
   SPACE 2
***     ESID TABLE
***      4 BYTE ENTRIES CONTAINING ADDRESS OF ENTRY IN ESD TABLE
***        FOR THIS ESID# IN THIS CSECT - IN ORDER '01'  UPWARDS
   SPACE 2
***     ADCON TABLE.
***       * ADDRESS OF ADCON *  POINTER  *
***       ********************************
***         4 BYTES              4 BYTES
***        POINTER IS ADDRESS OF NEXT ADCON FOR SAME ER OR CM.
***        IT IS X'FF' IF THIS IS LAST ENTRY IN ANY CHAIN
***      NOTE...  FOR COMMON, ESD TABLE ENTRY POINTS TO ENTRY
***      STORED IN ADCON TABLE.  THIS CONTAINS CURRENT MAXIMUM
***      LENGTH OF THIS COMMON IN FIRST 4 BYTES, AND POINTER TO
***      FIRST ADCON ENTRY PROPER (FOR THIS COMMON)
***      IN SECOND 4 BYTES.
***********************************************************************
 EJECT
***********************************************************************
***   ROOT   ---   FUNCTIONS.                                       ***
***     1. OPEN SYSLIN AND SYSPRINT.
***     2. GET DYNAMIC CORE FOR PROGRAM TEXT AND TABLES
***     3. CALL CSECT TO PROCESS SYSLIN
***     4. ON ENDFILE(SYSLIN) ALLOCATE COMMON STORAGE
***     AND RESOLVE COMMON ADCONS,, CHECK FOR UNRESOLVED REFERENCES
***     5.   FREE UNUSED TEXT AND TABLE STORAGE
**     6. CHECK FOR VALID ENTRY POINT (MAIN)
**      7. CALL CSECT TO PRINT CORE MAP, CLOSE SYSLIN AND SYSPRINT
**      8. BRANCH TO CONSTRUCTED PROGRAM IF NO ERRORS DETECTED
**      9. RETURN TO CALLING PROGRAM.
***********************************************************************
 EJECT
ROOT   CSECT
RA  EQU  11
RB  EQU  2
RC  EQU  3
RD  EQU  4
RE  EQU  7
RF  EQU  8
RG  EQU  5
RH  EQU  9
RI  EQU  6
RJ  EQU  10
RK  EQU  12
RL  EQU  14
***   SAVING CONVENTIONS
  USING  *,RB
  STM  14,12,12(13)
  BAL  RB,80(0,15)
  DC  18F'0'    SAVE AREA
  ST  13,4(0,RB)
  ST  RB,8(0,13)
  LR  13,RB
  LR   RB,15      SAVING CONVENTIONS NOW COMPLETE
*  OPEN  (SYSLIN,(INPUT),SYSPRINT,(OUTPUT))
   OPEN  (SYSLIN,(INPUT),SYSPRINT,(OUTPUT))
   MVI   RPARAM,X'FF'  SET UP SIGNAL FOR HEADING
   LA   RL,HEADRET    AND GO TO PRINT IT
   B   CALLOL2
HEADRET   EQU   *
*  GETMAIN   EC,LV=&VAL1,A=ADSTOR
   GETMAIN   EC,LV=&VAL1,A=ADSTOR
   LTR   15,15    IS CORE AVAILABLE
   BZ   COREOK      IF YES CONTINUE
  MVI   RPARAM,X'01'   SET UP ERROR MESSAGE
SETABEND   EQU   *     AND
   LA   RL,ABENDLE
   B   CALLOL2    GO TO    PRINT IT
COREOK  L  RD,ADSTOR        SPLIT DYNAMIC CORE INTO
   LR   RG,RD       THREE SECTIONS
   A   RG,LENSTOR      AND STORE BASE ADDRESSES
   ST   RG,ADSTOR+4    IN REGISTERS AND
   LR   RI,RG           TOP LIMIT ADDRESSES
   A   RI,LENSTOR+4     IN LIMITS
   ST   RI,ADSTOR+8
   LR   RE,RI
   A   RE,LENSTOR+8
   STM    RG,RE,LIMITS
   LA   1,PLISTRT1
   L   15,=V(PRSYSLIN)
   BALR   14,15          GO TO PROCESSING CSECT
***   RETURN HERE INDICATES ERROR CONDITION DETECTED IN PRSYSLIN
   CLI  RETCODE,X'01'    IS SUBSEQUENT ABEND REQUIRED
   BE   SETABEND         BRANCH IF YES
   CLI  RETCODE,X'02'    IS SUBSEQUENT IBM LINK EDITOR REQUIRED
   BE   SETNOLE          BRANCH IF NO
   LA   14,USEIBMLE      IF YES SET RETURN ADDRESS ACCORDINGLY
CALLOL2  EQU  *
   LA   1,PLISTRT2
   L   15,=V(PRINTMSG)
   BR   15               GO TO PRINTING CSECT
*ABENDLE  ABEND   16,DUMP
ABENDLE   ABEND   16,DUMP
SETNOLE   LA   RL,NOIBMLE       SET RETURN ADDRESS FOR NO USE OF IBM LE
   B   CALLOL2
 EJECT
ENTPROG   EQU   *        ENTER HERE ON ENDFILE FOR SYSLIN
*****      FIRST RESTORE ENVIRONMENT FOR ROOT SEGMENT
   L   13,4(0,13)
   LM   14,3,12(13)  LEAVE OTHER REGISTERS AS THEY WERE IN PRSYSLIN
****   PROCESS COMMONS
***   AND ALSO CHECK FOR UNRESOLVED EXTERNAL REFERENCES
   LA   RE,USERESD-12    SET RE TO POINT TO USER ENTRIES IN ESDTAB
PRCOML1  LA  RE,12(RE)   INDEX ALONG ESDTAB
   CLI   0(RE),X'FF'   END OF CHAIN
   BE   ALCOMFIN         YES SO GO TO PREPARE FOR EXECUTION
   CLC   0(8,RE),=C'MAIN    '      IS IT MAIN PROCEDURE ENTRY
   BNE   NOENTRY         NO
   MVC   EP,8(RE)        YES SO STORE ENTRY ADDRESS
NOENTRY   EQU   *
   CLI   8(RE),X'05'   IS IT COMMON
   BE   RSLVCM           YES SO GO TO ALLOCATE STORAGE
   CLI   8(RE),X'02'  IS IT UNRESOLVED ER
   BNE   PRCOML1         NO SO GO TO REPEAT LOOP
   OI   QUITSW,X'01'     YES
   MVI   RPARAM,X'06'    SO SET UP ERROR MESSAGE
   MVC   RPARAM+1(7),0(RE)
   LA   14,PRCOML1       AND GO TO
   B   CALLOL2           PRINT IT
RSLVCM   EQU   *
   L   RH,8(RE)  A(LENGTH) TO RH
   LR   RJ,RH            SET RJ TO FOLLOW RLD CHAIN
PRCOML2   CLI   4(RJ),X'FF'   END OF RLD CHAIN
   BE   UPRD             IF YES GO TO SET RD FOR NEXT COMMON IF ANY
   L   RJ,4(RJ)   A(A(ADCON)) TO RJ
   L   RK,0(RJ)          A(ADCON) TO RK
   LR   RC,RD            SET BASE OF COMMON IN RC
   A   RC,0(RK)          ADD ON DISPLACEMENT ,  IF ANY
   ST   RC,0(RK)   COMPUTED ADDRESS OF COMMON TO ADCON
   B   PRCOML2           REPEAT SEARCH OF CHAIN
UPRD   ST   RD,WK2
   MVC   9(3,RE),WK2+1   ACTUAL ADDRESS TO COMMON TABLE ENTRY
   CLI   0(RE),C' '   IS IT BLANK COMMON
   BNE   *+10   BRANCH IF NOT
   MVC   0(8,RE),=C'BLANKCOM'  SET UP NAME FIELD IF SO
       A   RD,0(RH)      BUMP RD BY LENGTH OF COMMON
   AH   RD,=H'7'   ROUND UP TO NEXT DOUBLE WORD
   N   RD,PATDBWD1       TO NEXT DOUBLE WORD
NOBMP1  C   RD,LIMITS   HAVE WE EXCEEDED AVAILABLE CORE RE COMMON
   BL   PRCOML1          NO
   MVI   RPARAM,X'07'    YES SO SET UP ERROR MESSAGE
   LA   RL,USEIBMLE      AND RETURN ADDRESS TO USE IBM LE
   B   CALLOL2           GO TO PRINT
ALCOMFIN  EQU  *
   TM   QUITSW,X'01'     ANY UNRESOLVED ERS DETECTED IN PRCOML1
   BO   NOIBMLE   IF UNRESOLVED EXTERNAL REFEENCES DETECTED
   L   0,LIMITS          SET R0 TO TOP LIMIT OF TEXT AREA
   SR   0,RD   LEAVES FREE CORE LENGTH IN R0
   A   0,LENSTOR+4       BUMP UP R0 BY SPACE
   A   0,LENSTOR+8       USED FOR TABLES
   LR   1,RD   A(START OF FREE CORE)TO R1
*  FREEMAIN   R,LV=(0),A=(1)
   FREEMAIN   R,LV=(0),A=(1)
   L   0,EP              SEE IF MAIN PROCEDURE
   LTR   0,0             HAS BEEN PROCEESSED
   BC   7,GOGO1          IF YES,BRANCH
   MVI   RPARAM,X'04'    IF NO SET UP ERROR MESSAGE
   LA   RL,EOJ
   B   CALLOL2           PREPARE FOR EXIT, AND GO TO PRINT
GOGO1  EQU  *
   AIF   ('&MAP' EQ 'NO').NOMAP1
        MVI   RPARAM,X'00'         SET SIGNAL FOR MAP PRINTING
   LA   RL,GOGO2         SET RETURN TO NSI
   LR   0,RD   END OF PROGRAM ADDRESS TO RD
   S   0,ADSTOR   SUBTRACT START OF PROGRAM ADDRESS
   B   CALLOL2   PRINT MAP
.NOMAP1   ANOP
GOGO2   EQU   *
         BAL   5,CLS
   LA   RL,EOJ           SET RETURN TO CLOSE OUT
   L   15,EP             SET ENTRY ADDRESS OF MAIN
   BR   15   BRANCH TO BUILT PROGRAM
****       RETURN  TO INVOKING  PROGRAM  ***  ***
EOJ   EQU   *
   L   13,4(0,13)
  LM  14,12,12(13)
   XR   15,15   SET ZERO RETURN CODE
  BR  14
USEIBMLE   MVI   RETCODE,X'04'     SET UNSUCCESSFUL RETURN CODE
   B   *+8
NOIBMLE   MVI   RETCODE,X'00'      SET QUASI-SUCCESSFUL RETURN CODE
*  FREEMAIN   E,LV=&VAL1,A=ADSTOR
   FREEMAIN   E,LV=&VAL1,A=ADSTOR
NOFREE   BAL   5,CLS
   XR   15,15
   IC   15,RETCODE
   L   13,4(0,13)
   L   14,12(13)
***   DO NOT DISTURB REG 15
   LM   0,12,20(13)
   BR   14               BACK TO CALLING PROGRAM (MONITOR)
CLS      LA    3,SYSPRINT
         BAL   4,CLF
         LA    3,SYSLIN
         BAL   4,CLF
         BR    5
CLF      TM    48(3),16
         BCR   8,4
         CLOSE ((3))
         FREEPOOL (3)
         BR    4
*SYSLIN DCB  DSORG=PS,MACRF=GL,DDNAME=SYSLIN,DEVD=DA,
*              OPTCD=C,BUFNO=8,BFALN=D,BFTEK=S,EODAD=ENTPROG,LRECL=80
SYSLIN  DCB  DSORG=PS,MACRF=GL,DDNAME=SYSLIN,DEVD=DA,                  *
               OPTCD=C,BUFNO=8,BFALN=D,BFTEK=S,EODAD=ENTPROG,LRECL=80
*SYSPRINT DCB  DSORG=PS,MACRF=PM,DDNAME=SYSPRINT,RECFM=FBA,
*              BLKSIZE=480,LRECL=120
SYSPRINT  DCB  DSORG=PS,MACRF=PM,DDNAME=SYSPRINT,RECFM=FBA,            *
               BLKSIZE=480,LRECL=120
  DS  0F
ESDTAB  EQU  *
F2       ESDGEN (ARSIN,ATAN,ATAN2,COS,DEBUG#,DCOTAN,DEXP,DIOCS#,DLOG)
F3       ESDGEN (DLOG10,DMAX1,DMIN1,DMOD,DSQRT,DTAN,EXP,FDXPD#)
F4       ESDGEN (FDXPI#,FDXPR#,FIXPI#,FRXPI#,IBCOM#,IBERH#,IBERR#)
F5       ESDGEN (MAX0,MAX1,MDUMP,MIN0,MIN1,SIN,SPIE,SQRT)
 EJECT
USERESD   EQU   *
  DC  X'FF'    END OF TABLE SIGNAL
   DS   CL&VAL4
RETCODE   DC   X'00'
QUITSW  DC  X'00'
WK2   DC   F'0'
RPARAM  DS  CL8
ADSTOR  DS  3F
LENSTOR  DC   A(&TXTSIZE)   TEXT BUFFER
         DC   A(&VAL2)         SPACE FOR ESID TABLE
         DC   A(&VAL3)        SPACE FOR ADCON TABLE
EP   DC   F'0'
   DS   0F
PATDBWD1   DC   X'FFFFFFF8'
LIMITS  DS  3F
PLISTRT1  EQU  *
  DC  A(RPARAM)
  DC  A(ESDTAB)
   DC   A(RETCODE)
  DC  A(SYSLIN)
  DC  A(LIMITS)
PLISTRT2  EQU  *
  DC  A(RPARAM)
  DC  A(SYSPRINT)
   DC  A(ESDTAB)
   LTORG
 TITLE ' IN-CORE LINK-EDITOR          SYSLIN PROCESSOR CSECT'
***********************************************************************
**      PRSYSLIN  ---   FUNCTIONS.
***     ESD CARDS.
***       A.  SD --  PLACE ENTRY INTO ESD TABLE. RESOLVE ADCONS
***           IF PREVIOUS ER OF THIS NAME ENCOUNTERED.
***           SET UP POINTER IN ESID TABLE.
***       B.  LD  --  DITTO, BUT NO POINTER IN ESID TABLE.
***       C. ER -- IF SD/LD OF SAME NAME ALREADY IN ESD TABLE,
***           SIMPLY SET UP POINTER IN ESID TABLE.
***           IF ER OF SAME NAME, DITTO.
***           IF NEW ENTRY, PLACE ENTRY INTO ESD TABLE, AND ALSO
***           SET UP POINTER IN ESID TABLE.
***       D. CM -- IF CM OF SAME NAME ALREADY IN ESD TABLE,
***           UPDATE LENGTH IF NEW CM LONGER.
***           AGAIN, SET UP POINTER IN ESID TABLE.
***           IF CM IS NEW ENTRY, TREAT AS FOR NEW ER.
   SPACE 2
***     TXT CARDS.
***       MOVE TEXT DIRECTLY TO CORE.
   SPACE 2
***     RLD CARDS.
***      USE ESID TABLE TO DETERMINE ESD TABLE ENTRY FOR A GIVEN ADCON
***      IF CORE ALLOCATED FOR THIS ENTRY, RESOLVE ADCON IMMEDIATELY.
***      IF NOT(IE ENTRY IS ER OR CM) ADD ADCON TO CHAIN POINTED TO
***      BY ESD TABLE  ENTRY
   SPACE 2
***     END CARDS.
***      EXTRACT  LENGTH OF CSECT, IF THIS NOT IN SD ENTRY ORIGINALLY.
***      ROUND UP STORAGE BASE FOR NEXT CSECT TO DOUBLE WORD.
***********************************************************************
 EJECT
PRSYSLIN   CSECT
***   SAVING   CONVENTIONS
   USING   *,RB
   USING  WORK,1
   STM   14,12,12(13)
   BAL   RB,80(0,15)
   DC   18F'0'   SAVE  AREA
        ST   13,4(0,RB)
   ST   RB,8(0,13)
   LR   13,RB
   LR   RB,15   SAVING  COMPLETE
   MVC   ADRPARAM(16),0(1)
   L   1,16(1)
   MVC   UPLIMTXT(12),0(1)   MOVE ACROSS INFO FROM LIMITS
 EJECT
L1  EQU  * NEW RECORD  INTO WORK AT THIS POINT
   L   1,ADSYSLIN
*  GET   (1)
   GET   (1)
 CLC TYPE,=C'ESD'
  BE  PROCESD
 CLC TYPE,=C'TXT'
  BE  PROCTXT
 CLC TYPE,=C'RLD'
  BE  PROCRLD
 CLC TYPE,=C'END'
  BE  PROCEND
   MVI   OPARAM,X'02'    IF NOT RECOGNISED LE INPUT
SETRTAB   L   1,UPLIMESD   A(RETCODE) TO R1
   MVI   0(1),X'01'   SET RETCODE TO INDICATE ABEND
   B   ERRETRN
 EJECT
PROCESD  LH  RA,LENGTH   USE RA AS INCREMENT FOR 16 BYTE ENTRIES
   CLC   ESID,=C'  '   IS ESID BLANK
   BE   NOMODRG   IF SO, LEAVE RG UNALTERED
   LH   RJ,ESID   ELSE ESID# TO RJ
   BCTR   RJ,0   LESS 1
   SLL   RJ,2   * BY 4 TO MODIFY ESIDTAB CORRECTLY
   L   RG,UPLIMTXT   A(ESIDTAB) TO RG
   AR   RG,RJ    AND MODIFY BY ESID OFFSET
NOMODRG   EQU   *
 LA RC,VARBLE-16         USE RC   TO  INDEX ALONG ENTRIES
ESDL1  LA  RC,16(RC)
 B      ESDTABSC         GO TO PROCESS ESD ENTRY
ESDRET1  SH  RA,=H'16'   LOOP
 BP ESDL1                CONTROL
   ST  RG,RGSTORE   STORE   POINTER TO NEXT AVAILABLE POSN IN ESID TABL
 B L1                    LOGIC
ESDTABSC  L  RE,ADESDTAB TEST FOR  ESD TYPE
 CLI  8(RC),X'00'        SD
 BE  PROCSD
 CLI  8(RC),X'01'        LD
 BE  PROCLD
 CLI  8(RC),X'02'        ER
 BE  PROCER
 CLI  8(RC),X'05'        CM
 BE  PROCCM
   MVI   OPARAM,X'03'    IF NONE OF THESE
   B   SETRTAB           TREAT AS ERROR
PROCSD  CLI  0(RE),X'FF'           END OF ESDTAB
 BE NEWSD                BRANCH IF YES TO TREAT AS NEW ENTRY
  CLC  0(8,RE),0(RC)     IS NAME ALREADY IN ESDTAB
   ST   RD,CURCSBAS  STORE BASE INCASE ADCONS TO BE RESOLVED
  LA  RL,NEWSD           SET RETURN IN CASE
  BE  RESLVER            BRANCH IF YES
 LA  RE,12(RE)  UPDATE LOOP
 B PROCSD                AND GO TO SCAN ONWARD
NEWSD  MVC  0(8,RE),0(RC)          SET UP NEW NAME ENTRY
   MVI   12(RE),X'FF'    SET NEW END MARKER
   MVI   8(RE),X'00'  ENTER HERE IF REPLACING IBM ROUTINE
***  SET UP RELOC FACTOR FOR CSECT SD IN RF,
***      AND  UPDATE ASS ORG FIELD IN ESD TABLE FROM  RD
  LR  RF,RD              BASE OF CSECT TO RF
   MVC  WK1+1(3),9(RC)   ASSEMBLED ORIGIN TO WK1
  S  RF,WK1              SUBTRACT ASS ORG(USUALLY 0) TO GIVE CORRECT
  ST  RD,WK1             RELOCATION ---   STORE CSECT BASE
  MVC  9(3,RE),WK1+1     VIA WK1 INTO ESDTAB ENTRY
   ST   RD,CURCSBAS   SET CURRENT BASE  ADDRESS
   CLC  13(3,RC),=X'000000'        IS CSECT LENGTH PROVIDED
 BE NOSDLGTH             BRANCH IF NOT
   MVC  CSECTLGT,13(RC)  ELSE STORE IN CSECTLGT
   A   RD,CSECTLGT-1
   AH   RD,=H'7'   ROUND UP TO NEXT DOUBLE WORD
   N   RD,PATDBLWD   CLEAR LAST 3 BITS
NOSDLGTH  B   ESDUPLP1   BRANCH TO UPDATE POINTERS
RESLVER  CLI  8(RE),X'02'          IS EXISTING NAME AN ER
   BE   RSLCT1           BRANCH IF YES
   TM    8(RE),X'10'     IS IT AN IBM LIBRARY ROUTINE
   BO   RSLCT2           BRANCH IF YES
   CLI   8(RE),X'05'   IS IT A COMMON  FOR WHICH BLOCK DATA APPEARING
   BE   RSLCT3   YESS, SO PROCESS ALMOST AS THOUGH RESOLVING REFS
DUPNAME  MVI  OPARAM,X'05'         IF NONE OF THESE, TREAT AS ERROR
   MVC   OPARAM+1(7),0(RE)         SO SET UP ERROR MESSAGE
   L   1,UPLIMESD        AND
   MVI   0(1),X'02'   SET NO LINK TO IBM LE IN RETCODE
   B   ERRETRN           EXIT
RSLCT2   MVC   FRIGCON+8(4),CURCSBAS   A(ENTRY) TO FRIGCON
   L   RH,8(RE)   A(IBM ROUTINE)TO RH
   MVC   0(12,RH),FRIGCON   MOVE FRIGCON TO OVERWRITE START OF IBM RTN
   B   10(RL)            RETURN TO NEWSD  OR NEWLD VIA RL
RSLCT1  EQU  *
  L RH,8(RE)   POINTER TO RH       FOR A(A(FIRST UNRESOLVED ADCON))
RSL1  L  RJ,0(RH)          A(ADCON) TO RJ
 MVC WK1,0(RJ)           ADCON TO RK
 L RK,WK1                VIA WK1
   A   RK,CURCSBAS   ADD ABSOLUTE BASE
 ST RK,WK1               REPLACE MODIFIED ADCON TO ORIGINAL LOCATION
  MVC  0(4,RJ),WK1       VIA WK1
  CLI  4(RH),X'FF'       IS IT LAST ADCON IN CHAIN
   BE   10(RL)   IF END OF CHAIN REACHED     RETURN TO NEWSD OR NEWLD
  L  RH,4(RH)   PICK UP NEXT POINTER TO A(ADCON)
 B RSL1                  LOOP BACK TO RESOLVE NEXT ADCON
RSLCT3  L   RH,8(RE)  POINTER TO LENGTH FIELD   TO RH
   L   RH,4(RH)   POINTER TO ADDRESS OF FIRST UNRESOLVED ADCON
   B   RSL1   BACK TO MAIN LINE
PROCCM   CLI   0(RE),X'FF'   END OF TABLE    OF ESDS
   BE   NEWCOM           YES SO TREAT AS NEW ENTRY
   CLC   0(8,RE),0(RC)   IS COMMON NAME ALREADY IN ESDTABLE
   BE    TSTCOMLG        YES SO BRANCH TO PROCESS
   LA   RE,12(RE)        NO SO INCREMENT INDEX
   B   PROCCM             AND REPEAT LOOP
NEWCOM  MVI  12(RE),X'FF'          SET NEW MARKER FOR END OF ESDTABLE
   MVC   0(9,RE),0(RC)   ENTER HERE IF OVERWRITING ENTRY FOR IBM RTN
   ST    RI,WK1          STORE POINTER TO NEXT FREE LOC IN ADCON CHAIN
   MVC   9(3,RE),WK1+1   VIA WK1 - USED TO  HOLD LENGTH OF COMMON
   MVC   WK1+1(3),13(RC) PICK UP
   MVC   0(4,RI),WK1   LENGTH OF COMMON  FROM ESD CARD AND ADD TO CHAIN
   MVI   4(RI),X'FF'   END OF CHAIN MARKER
   LA   RI,8(RI)         INCREMENT POINTER TO FREE LOC IN ADCON CHAIN
   C   RI,UPLIMRLD   HAS END OF ALLOCATED STORE FOR ADCON TABLE COME
   BL   ESDUPLP1   CONTINUE IF NOT
   MVI   OPARAM,X'0A'   ELSE SET UP ERROR CODE
      B   ERRETRN   AND GO TO PRINT ERROR MESSAGE
TSTCOMLG   CLI   8(RE),X'05'  IS PREVIOUS ENTRY ALSO COMMON
   BE   COMCT1           IF YES GO TO CHECK LENGTH
   TM    8(RE),X'10'   IBM ROUTINE
   BO   NEWCOM+4         IF YES GO TO OVERWRITE OLD ENTRY
   CLI   8(RE),X'00'   IS THERE BLOCK DATA FOR THIS COMMON
   BNE   DUPNAME   NO SO TREAT AS ERROR
   B   ESDUPLP1   YES SO SIMPLY SET UP POINTER TO EXISTING ENTRY
COMCT1   EQU   *         TESTS TO ENSURE MAXIMUM LENGTH OF COMMON KEPT
   L   RH,8(RE)  A(LENGTH) TO RH
   MVC   WK1+1(3),9(RC)  NEW LENGTH TO WK1
   L   RJ,0(RH)  OLD LENGTH TO RJ
   C   RJ,WK1            IS OLD LENGTH GREATER THAN NEW
   BNL   *+10            IF YES, IGNORE NEW
   MVC   0(4,RH),WK1     ELSE OVERWRITE OLD LENGTH WITH NEW
   B   ESDUPLP1          JOIN MAIN LINE
PROCLD    CLI 0(RE),X'FF'  END OF TABLE
 BE NEWLD                IF SO TREAT AS NEW ENTRY
   CLC   0(8,RE),0(RC)   IS THIS LD ALREADY IN TABLE
   LA   RL,SETRDER2-10  PREPARE RETURN REGISTER IN CASE SO
   BE   SETRDER1  BUT RETURN VIA SETRDER2
  LA  RE,12(RE)         INCREMENT LOOP ALONG ESDTABLE
 B PROCLD                AND REPEAT
SETRDER1   L   0,CURCSBAS   BASE FRO CSECT TO R0
   MVC   WK1+1(3),9(RC)  ADD VIA WK1 OFFSET OF THIS LD
   A   0,WK1
   ST   0,WK1   SAVE CURRENT CONTENTS OF CURCSBAS IN R0,
   L   0,CURCSBAS          AND SET ADJUSTED VALUE FOR OFFSET
   MVC   CURCSBAS,WK1     IN CURCSBAS FOR RESLVER ROUTINE
   B   RESLVER   GOTO RESOLVE REFERENCES
SETRDER2   ST   0,CURCSBAS   RESTORE CURCSBAS TO ORIGINAL VALUE
   B   NEWLD+10
NEWLD  MVC  0(8,RE),0(RC)          ADD NEW LD NAME
   MVI   12(RE),X'FF'    SET NEW END MARKER FOR ESDTABLE
   MVI   8(RE),X'01'  ENTER HERE IF REPLACING IBM ROUTINE
   L   RK,CURCSBAS    BASE FOR CSECT TO RK
  MVC WK1+1(3),9(RC)      ADD VIA WK1 OFFSET OF THIS LD
  A  RK,WK1              TO CSECT BASE
  ST  RK,WK1             AND STORE,VIA WK1, ENTRY ADDRESS
  MVC  9(3,RE),WK1+1     INTO ESDTABLE
  B  ESDUPLP2            REJOIN MAIN LINE BUT NB NO ENTRY IN ESIDTABLE
PROCER  CLI  0(RE),X'FF'     IS THIS END OF TABLE
  BE  NEWER              TREAT AS NEW ENTRY IF SO
   CLC  0(8,RE),0(RC)    IS THIS ER ALREADY IN TABLE
  BE  DUPER              BRANCH IF YES
  LA  RE,12(RE)  UPDATE LOOP
   B  PROCER             LOOP BACK
NEWER  MVC  0(9,RE),0(RC)          ADD NAME AND ER CODE TO ESDTABLE
  MVC  9(3,RE),=X'FF0000'  SET UP NULL POINTER
  MVI  12(RE),X'FF'   SET NEW EOT
  B  ESDUPLP1            REJOIN MAIN LINE
DUPER  CLI  8(RE),X'02'       IS ENTRY IN ESDTABLE ALREADY AN ER,LD,SD
   BNH   DUPCT1          BRANCH IF YES
   TM    8(RE),X'10'   IBM RTN
   BZ    DUPNAME   NO    , SO BRANCH AND TREAT AS ERROR
DUPCT1   EQU  *
ESDUPLP1  ST  RE,0(RG)  POINTER TO ESDTAB ENTRY STORED INTO ESIDTABLE
   C   RG,UPLIMEIT       STILL ROOM IN ESIDTABLE FOR THIS CSECT
   BL   ESDCT1           BRANCH IF YES
   MVI   OPARAM,X'08'    SET UP ERROR CODE
   B   ERRETRN            AND PREPARE TO TERMINATE PROCESSING
ESDCT1  LA  RG,4(RG)   UP TO NEXT AVAILABLE POSN IN ESIDTABLE
ESDUPLP2   LA   RE,12(RE)     INCREMENT RE TO TEST
   C   RE,UPLIMESD       IF LIMIT OF ESDTABLE CAPACITY REACHED
    BL   ESDRET1   RETURN   IF NOT TO TAKE NEXT ESD CARD/ENTRY
   MVI   OPARAM,X'09'    SET UP ERROR CODE
   B   ERRETRN           AND PREPARE TO TERMINATE PROCESSING
 EJECT
PROCTXT  LH  RA,LENGTH     LENGTH OF TEXT TO RA
  BCTR  RA,0  LESS 1 FOR MOVE
   LH   RG,ESID   ESID# TO RG
   BCTR   RG,0   LESS 1
   SLL   RG,2   * BY 4, TO ADDRESS ESIDTABLE OFFSET
    L   RJ,UPLIMTXT   A(ESIDTAB) TO RJ --ESIDTAB DIRECTLY FOLLOWS TEXT
   LA   RG,0(RG,RJ)   ADJUST BY OFFSET OF ESID#
   L   RG,0(RG)  POINTER FROM ESID TABLE TO RG
   L   RC,8(RG)   BASE FOR CSECT TO RC
   L   RJ,ASSORG-1   ASSEMBLED ORIGIN OF TEXT TO RJ
   LA   RC,0(RC,RJ)   AND ADD ONTO CSECT BASE
   LR   RE,RC   TRANSFER TO RE FOR BOUNDARY TEST
   AR   RE,RA             ADD LENGTH TO ORIGIN
   C   RE,UPLIMTXT       DOES IT GO BEYOND TEXT BUFFER
   BL   TXTCT1           IF NO,GO TO CONTINUE
   MVI   OPARAM,X'07'    IF YES, SET UP ERROR CODE
   B   ERRETRN           AND PREP TO TERMINATE PROC
TXTCT1  EX  RA,MOVETXT      MOVE TEXT INTO PLACE
   B  L1                 GO TO PROCESS NEXT SYSLIN RECORD
 EJECT
PROCRLD   LH   RA,LENGTH    LENGTH OF RLD CARD ENTRIES TO RA
  LA  RC,VARBLE          ADDRESS OF FIRST ENTRY TO RC
   B   PRPROC   START OFF, ASSUME R & P FIELDS FIRST
RLDL2  L  RG,0(RC)   ASSUME RELOCATION NECESSARY -- A(ADCON) TO RG
***   ASSUME THAT RF CONTAINS APPROP BASE FOR ADDRESSING ADCON ---
***   IE THAT RLD ITEMS FOR A CSECT ARE ENCOUNTERED WITH
***   TEXT FOR THAT CSECT, AND P POINTER ALWAYS EQUALS 1
   LA   RG,0(RF,RG)  ADD ON RELOC FOR CONTAINING CSECT
   LR   RH,RE  PICK UP RELOC FACTOR FOR APPROP CSECT REFERENCED
   MVC   WK1,0(RG)       ADD ,VIA WK1,
  A   RH,WK1             THE ADCON TO ITS RELOCATION FACTOR
   ST  RH,WK1            AND REPLACE
   MVC   0(4,RG),WK1     IN ITS ORIGINAL LOCATION
***     RELOCATION HAS NOW BEEN DONE,IF POSSIBLE
   XR   RH,RH
   ST   RH,WK1   CLEAR ANY HIGH ORDER BITS IN WK1
RLDNXT  SH  RA,=H'4'     DECREMENT COUNT OF RLD ENTRIES
   BZ   L1               GOTO NEXT  CARD IF EXHAUSTED
   TM   0(RC),X'01'      IS  NEXT ADCON WITH SAME R & P
   LA   RC,4(RC)   BUMP UP POINTER
   BO   RLDL2   IF SAME RP FIELD IN FORCE    ,BRANCH
PRPROC   EQU  *
***   SCAN CHAIN OF ESD ENTRIES, PICK UP CSECT BASE IF KNOWN,
***   OTHERWISE ADD ADCON(S) TO UNRESOLVED CHAIN,
***  AND GO ON TO NEXT P & R OR RETURN TO L1 IF RLD CARD FINISHED
   LH   RG,0(RC)         R POINTER TO RG
   BCTR   RG,0   PICK UP ESID# FROM R POINTER, LESS 1
   LTR   RG,RG
   BM   SETRTAB-4   BRANCH TO ABEND IF NEGATIVE FOR ANY REASON
   SLL   RG,2   * BY 4
    L   RJ,UPLIMTXT   A(ESIDTAB) TO RJ --ESIDTAB DIRECTLY FOLLOWS TEXT
   LA   RG,0(RG,RJ)      MODIFY RJ BY ESID# FROM RG & SAVE IN RG
   C   RG,RGSTORE     ENSURE VALID ESID POINTER BEING ADDRESSED
   BNL   SETRTAB-4      BRANCH IF INVALID TO ABEND
   L   RG,0(RG) POINTER TO ESDTABLE NOW IN RG,EXTRACTED FROM ESIDTABLE
   LA   RC,4(RC)  BUMP TO  POINT TO FOLLOWING ADCON    AND
   SH   RA,=H'4'   DECREMENT WORD COUNT  - HOUSEKEEPING FOR LOOP CNTRL
   CLI   8(RG),X'02'  IS ENTRY IN ESDTABLE AN UNRESOLVED ER
   BE   UNRESRLD         BRANCH IF YES
   CLI   8(RG),X'05'     IS IT COMMON
   BE   UNRESRLD   BRANCH IF COMMON   -- ELSE CAN RESOVE IMMEDIATELY
   CLI   8(RG),X'10'   IS IT IBM ROUTINE
   BNE   *+8   BRANCH IF NOT, OR IF SO BUT ALREADY USED
   OI   8(RG),X'20'   SET USED BIT ON
   MVC   WK1+1(3),9(RG)   SD/CSECT BASE TO RE   FROM ESDTABLE
   L   RE,WK1       DITTO
   B   RLDL2             GO TO RESOLVE THIS ADCON NOW
UNRESRLD     EQU   *
***  MOVE ADCON TO UNRESOLVED RLD CHAIN, FIRST MODIFYING ADDRESS OF
***   ADCON TO POINT TO ACTUAL CORE LOCATION  IE BUMP UP BY RF
   L   RE,0(RC)          ADCON TO RE
   LA   RE,0(RF,RE)      ADD ON RELOC FACTOR FOR CSECT
   ST   RE,0(RI)         STORE ADCON IN UNRESOLVED CHAIN
   CLI   9(RG),X'FF'   ANY ENTRY IN ER POINTER YET
   BNE   CHAINRTN    YES SO GO TO FIND LAST ENTRY IN CHAIN
   ST   RI,WK1           NO SO STORE POINTER TO THIS ADCON IN ER ENTRY
   MVC   9(3,RG),WK1+1   VIA WK1
RLDRET1  MVI  4(RI),X'FF'          SEE BELOW
   LA   RI,8(RI)   SET NEW END OF CHAIN AND BUMP UP RI
   C   RI,UPLIMRLD       HAS END OF ALLOCATED STORE FOR ADCONS ARRIVED
   BL   RLDCT1           BRANCH IF NOT
   MVI   OPARAM,X'0A'    ELSE SET UP ERROR CODE
   B   ERRETRN           AND PREP TO TER PROC
RLDCT1  SH  RA,=H'4'     DECREMENT LENGTH OF RLD ENTRIES
   BZ   L1               GOTO GET NEXT SYSLIN IF CARD EXHAUSTED
   TM   0(RC),X'01'   SAME R&P IN FORCE
   LA   RC,4(RC)         INCREMENT TO POINT TO NEXT ADCON OR R&P CODE
   BZ   PRPROC   IF NEW P&R TO BE PROCESSED  ,BRANCH
   L   RE,0(RC)          ELSE NEXT ADCON TO RE
   LA   RE,0(RF,RE)      MODIFY BY RELOC FACTOR FOR CSECT
   ST   RE,0(RI)         STORE ADCON IN CHAIN
   LR   RG,RI            PICK UP ADDRESS OF THIS ADCON INTO RG
   S   RG,=F'8'           AND DECREMENT TO POINT TO PREVIOUS ADCON
   ST   RI,4(RG)   POINTER TO NEW RLD ENTRY IN LAST ONE
   B   RLDRET1           LOOP BACK
CHAINRTN   L  RG,8(RG)      POINTER TO FIRST ADCON INTO RG
CHL1  CLI  4(RG),X'FF'   END OF CHAIN
   BNE   UPCHL1          NO SO  GO TO CONTINUE SEARCH
   ST  RI,4(RG)   YES    SO STORE IN IT POINTER TO NEW ADCON
   B   RLDRET1           LOOP BACK
UPCHL1  L  RG,4(RG)         POINTER TO NEXT ADCON IN CHAIN, TO RG
   B   CHL1              LOOP BACK TO CONTINUE SEARCH
 EJECT
PROCEND   L   RA,CSECTLGT-1   IS CSECT LENGTH ALREADY KNOWN
   LTR   RA,RA
   BNZ   NOBUMP
   MVC   CSECTLGT,VARBLE+13   ELSE PICK UP LENGTH FROM END CARD
SKIP2  A  RD,CSECTLGT-1     ADD LENGTH ONTO CSECT BASE TO GIVE NEXT BAS
   AH   RD,=H'7'   ROUND UP TO NEXT DOUBLE WORD
   N   RD,PATDBLWD       CLEAR LAST THREE BITS
NOBUMP  EQU  *
   XC   CSECTLGT,CSECTLGT     CLEAR CSECTLGT TO ZEROS
   B   L1                GO TO PROCESS NEXT SYSLIN RECORD
   EJECT
ERRETRN  EQU  *
   L   1,ADRPARAM        SET UP PARAMETER FOR PASSING
   MVC   0(8,1),OPARAM     VIA ROOT TO MESSAGE PRINTING ROUTINE
   L   13,4(0,13)
   LM   14,3,12(13)   PARTIALLY RESTORE ENVIRONMENT
   BR   14   RETURN TO ROOT
   EJECT
***     ***    ***      ***     ***     ***    ***    ***    ***
**  DEFINED AREAS ETC
MOVETXT  MVC  0(0,RC),VARBLE
     DS    0F
    DC  X'00'  FILLER
CSECTLGT  DC  X'000000'
PATDBLWD  DC  X'FFFFFFF8'
WK1  DC  F'0'
CURCSBAS   DC   F'0'
RGSTORE  DC  F'0'
UPLIMTXT   DS  F
UPLIMEIT   DS  F
UPLIMRLD   DS  F
ADRPARAM  DS  F
ADESDTAB  DS  F
UPLIMESD  DS  F
ADSYSLIN  DS  F
OPARAM   DS   CL8
FRIGCON  DC X'58F0F00807FF070000000000'  WITH ACKS TO P. SAMET
     LTORG
   EJECT
WORK    DSECT         ************     ************     ********
 DS CL1
TYPE DS CL3
 DS CL1
ASSORG  DS  CL3
  DS  CL2
LENGTH  DS  CL2
  DS  CL2
ESID  DS  CL2
VARBLE  DS  CL56
PROGID  DS  CL8
 TITLE ' IN-CORE LINK-EDITOR          MESSAGE PRINTING CSECT'
***********************************************************************
***   PRINTMSG.  --  FUNCTIONS
***   1. IF ERROR MESSAGE, PRINT IT.
***   2,  IF MAP, SORT ESDTABLE INTO CORE ADDRESS ORDER AND PRINT IT.
***********************************************************************
   EJECT
PRINTMSG   CSECT
***   SAVING   CONVENTIONS
   USING   *,RB
   STM   14,12,12(13)
   BAL   RB,80(0,15)
   DC   18F'0'   SAVE  AREA
        ST   13,4(0,RB)
   ST   RB,8(0,13)
   LR   13,RB
   LR   RB,15   SAVING  COMPLETE
   MVC   ADSYSPRT(8),4(1)   PICK UP TWO PARAMETERS AT ONCE
   L   1,0(1)  PICK UP RPARAM ADDRESS
   CLI   0(1),X'FF'      IS HEADING TO BE PRINTED
   BE   HEADPRT          GO IF YES
   XR   RH,RH            CLEAR RH
   IC   RH,0(1)          MESSAGE NUMBER TO RH
   CVD   RH,CVAREA       CONVERT TO DEC
   UNPK   UNPACK,CVAREA+6(2)  AND UNPACK FOR PRINTING
   OI   UNPACK+2,X'F0'  FORCE DIGIT SIGN
   AIF   ('&MAP' EQ 'NO').NOMAP2
   LTR   RH,RH           WAS IT ZERO
   LR   RK,0   SAVE PROGRAM LENGTH IN RK, IN CASE SO
   LR   RJ,RD   AND UPPER LIMIT OF PROGRAM IN RJ
   BZ   MAPLIST          YES SO GO  TO PRINT MAP
.NOMAP2   ANOP
   SLL   RH,2   * BY 4   IF NOT
   LA   RJ,MSTAB1-4(RH)
   IC   RH,0(RJ)
   BCTR  RH,0
   L   RJ,0(RJ)
   CLI     0(1),X'05'
   BL   NONAME
   CLI     0(1),X'06'
   BH   NONAME
   MVC   23(7,RJ),1(1)   MOVE NAME TO MESSAGE IF APPROPRIATE
NONAME  EX  RH,MOVEMSG          MESSAGE TO PRINT AREA
   L   1,ADSYSPRT
*  PUT   (1),PRTWORK
   PUT   (1),PRTWORK
   MVI   PRTTXT,C' '     CLEAR PRINT
   MVC   PRTTXT+1(70),PRTTXT     AREA
   MVI   PRTWORK,C'0'       AND RESET FOR DOUBLE SPACING
OLEXIT2   EQU   *
   L   13,4(0,13)        RETURN
   LM   14,12,12(13)     TO
   BR   14               ROOT
   AIF   ('&MAP' EQ 'NO').NOMAP3
MAPLIST  MVI   CVAREA,X'00'   FIRST SORT ENTRIES INTO ASCENDING ORDER
SORTLP1  L  RE,ADUSERSD
SORTLP2 CLC 9(3,RE),21(RE)
   BL   NOSWOP
   BH   SWOP
   CLC 8(1,RE),20(RE)
   BL   NOSWOP
SWOP   MVC   PRTTXT+1(12),0(RE)
   MVC   0(12,RE),12(RE)
   MVC   12(12,RE),PRTTXT+1
   MVI   CVAREA,X'01'
NOSWOP   LA   RE,12(RE)
   CLI   12(RE),X'FF'
   BNE   SORTLP2
   CLI   CVAREA,X'01'
   BE   MAPLIST
          L   RE,ADUSERSD
   LM   RC,RG,LOOPCONS
MAPLP1   CLI   0(RE),X'FF'
   BNE   MAPCT3
   S   RE,TWELVE   TO TRAP NEXT TIME ROUND
   C   RC,LOOPCONS
   BE   PRTLNGTH   IF NO INCOMPLETE LINE TO PRINT FIRST
   B   MAPCT4
MAPCT3   EQU   *
   AIF   ('&MAP' EQ 'FULL').FULL
   CLI   8(RE),X'10'  IS IT UNUSED IBM ROUTINE
   BE   MAPCT1   IF SO, DO NOT PRINT IT
.FULL   ANOP
   CLI   12(RE),X'FF'   ARE WE PROCESSING LAST ENTRY IN ESDTABLE
   BNE   *+8   BRANCH IF NOT
   ST   RJ,20(RE)   STORE UPLIM IN PLACE IF SO
   CLI   8(RE),X'00'   IS IT A CSECT NAME
   BNE   MAPCT2   IF NO, BRANCH TO CONTINUE
   CLC   9(3,RE),21(RE)  IF CSECT, DOES  USER ROUTINE NAME FOLLOW
   BE   MAPCT1   IF SO, DO NOT PRINT IT
MAPCT2   EQU   *
   MVC   0(8,RC),0(RE)   NAME FIELD ACROSS
   UNPK   CVAREA(7),9(4,RE)
   TR   CVAREA(6),HEXTAB-240
   MVC   8(6,RC),CVAREA   ADDRESS TO PRINT FIELD
   MVI   14(RC),C'/'
   UNPK   CVAREA(7),21(4,RE)
   TR   CVAREA(6),HEXTAB-240
   MVC   15(6,RC),CVAREA   HIGH ADDRESS TO PRINT FIELD
   BXLE   RC,RD,MAPCT1
MAPCT4   EQU   *
   L   1,ADSYSPRT
*  PUT   (1),PRTWORK
   PUT   (1),PRTWORK
   MVI   PRTTXT,C' '
   MVC   PRTTXT+1(113),PRTTXT
   LM   RC,RG,LOOPCONS
MAPCT1   LA   RE,12(RE)
   B   MAPLP1
PRTLNGTH   LTR   RK,RK  HAVE WE ALREADY PRINTED LENGTH OF PROGRAM
   BZ   PAGESKIP    BRANCH IF SO
   CVD   RK,CVAREA
   ED   EDITLNG,CVAREA+4
   MVC   PRTTXT+1(43),LNGMSG
   XR   RK,RK   ZEROISE RK FOR RETURN
   B   MAPCT4   BRANCH TO PRINT LENGTH OF PROGRAM
.NOMAP3   ANOP
HEADPRT   LA   RH,58
   LA   RJ,HEAD1    SET UP REGS AS FOR MESSAGE
   MVI   PRTWORK,C'1'   THROW NEW PAGE
   B   NONAME   BACK TO MAIN LINE TO PRINT
PAGESKIP   MVI   PRTWORK,C'1'
   MVC   PRTWORK+1(6),PRTTXT   BLANK OUT MESSAGE NUMBER
   B   NONAME+4  GO TO PRINT SKIP AND EXIT
   EJECT
LNGMSG   DC   C'LENGTH OF PROGRAM ='
EDITLNG   DC   X'40202020206B202020'
   DC   C' BYTES(DECIMAL)'
HEAD1  DC  C'FORTRAN IN-CORE LINK EDITOR-MAP OF TRUE START/END'
   DC  C' ADDRESSES'
DIAG1  DC  C'INSUFFICIENT CORE AVAILABLE FOR OPERATION'
DIAG2  DC  C'NON-STANDARD LINK INPUT'
DIAG3  DC  C'UNKNOWN ESD TYPE'
DIAG4  DC  C'NO MAIN PROGRAM-NOTE FORTRAN NAME OPTION NOT USABLE'
   DC   C' WITH THIS PROCEDURE'
DIAG5  DC  C'DUPLICATE NAME -               '
DIAG6  DC  C'UNRESOLVED REFERENCE -         '
DIAG7  DC  C'PROGRAM TOO LARGE'
DIAG8  DC  C'TOO MANY EXTERNAL REFERENCES'
DIAG9  DC  C'TOO MANY SUBPROGRAMS'
DIAG10 DC  C'TOO MANY UNRESOLVED REFERENCES'
PRTWORK  DC  C'0IZZ'
UNPACK   DC   CL3' '
PRTTXT   DC   CL114' '
   DS   0F
MSTAB1  DC  HL1'41'
        DC  AL3(DIAG1)
        DC  HL1'23'
        DC  AL3(DIAG2)
        DC  HL1'16'
        DC  AL3(DIAG3)
   DC   HL1'71'
        DC  AL3(DIAG4)
        DC  HL1'31'
        DC  AL3(DIAG5)
        DC  HL1'31'
        DC  AL3(DIAG6)
        DC  HL1'17'
        DC  AL3(DIAG7)
        DC  HL1'28'
        DC  AL3(DIAG8)
        DC  HL1'20'
        DC  AL3(DIAG9)
        DC  HL1'30'
        DC  AL3(DIAG10)
ADSYSPRT  DS  F
ADUSERSD  DS  F
LOOPCONS   DC   A(PRTTXT+1)   RC -- START POINT OF LOOP
   DC   A(26)   RD   ---   INCREMENT
   DC   A(PRTTXT+79)   RG   ---   LIMIT(LAST VALID VALUE FOR LOOP)
TWELVE   DC   F'12'
CVAREA  DC  D'0'
MOVEMSG  MVC   PRTTXT+1(1),0(RJ)
HEXTAB  DC   C'0123456789ABCDEF'
   LTORG
         MEND
   PRINT ON
 EJECT
         FORTLINK TXTSIZE=70000
   END
