./ ADD NAME=TMAILCPY 0156-89334-93153-0645-00181-00027-00000-$A1238
        /* ---------------------  rexx procedure  ----------------------
        /* Name:      TMAILCPY
        /*
        /* Function:  COPY files received by the TSOMAIL exec
        /*            by prompting the user for target information
        /*            and invoking either IEBCOPY or Execio.
        /*
        /* Author:    Lionel B. Dyck
        /*            Rockwell International
        /*            P.O. Box 2515
        /*            Seal Beach, California 90740
        /*            (310) 797-1125
        /*            IBMLINK:  ROK2027
        /*
        /* History:
        /*            02/27/92 - Lionel Dyck
        /*            - add variable for vio
        /*            07/25/91 - Lionel Dyck
        /*            - correction to copy fully qualified dsns
        /*            07/23/91 - Lionel Dyck
        /*            - correction for messages
        /*            - use EXECIO rather than IEBGENER for sequentials
        /*            12/21/90 - Lionel Dyck
        /*            - Correction to copy seq to new pds
        /*            06/25/90 - Lionel Dyck
        /*            - Correction to listdsi return code test
        /*              for DFHSM migration
        /*            06/06/90 - Lionel Dyck
        /*            - Update to add this header data
        /*            - Update to correct problem with call of iebgener
        /*              to use "CALL 'SYS1.LINKLIB(IEBGENER)')
        /*            - Update to browse IEBCOPY SYSPRINT file
        /*            - Update to reallocate SYSPRINT to terminal
        /*            - Update to reallocate SYSIN to terminal
        /*            06/05/90 - Mike Theys
        /*            - Update to fix IEBCOPY control card
        /*            - Update to correct problem with call of iebcopy
        /*              to use "TSOEXEC IEBCOPY"
        /*            11/30/89 - Lionel Dyck
        /*            - Creation of this procedure
        /*
        /* -------------------------------------------------------------

        parse arg mailtds m1 m2 m3 mailfloc mailfid

        parse value mailfid with mailfid debug

        upper debug
        if debug = "DEBUG" then trace i

        /* set the vio variable to your vio generic */
        vio = "SYSVIO"

        mailsubj = m1 m2 m3

        x = pos(".",m3)
        newname = substr(m3,x+1,length(m3)-x)
        new_member = ""

        x = listdsi(newname)
            select
              when sysreason =  0 then newdisp = "SHR"
              when sysreason =  9 then newdisp = "SHR"
              when sysreason = 26 then newdisp = "SHR"
              otherwise newdisp = "NEW"
              end

        if sysdsorg = "PO" & newdisp = "SHR" then newrep = "NO"
                                             else newrep = "YES"

        maillmsg = " "
        Address ISPEXEC,
           "VPUT (MAILTDS MAILSUBJ MAILFLOC MAILFID",
                 "MAILLMSG NEWNAME NEWDISP NEWREP) SHARED"

        copyfile:
              parse value '' with zcmd newstat
              Address ISPEXEC "DISPLAY PANEL(TMAILCPY)"
              sysdsorg = " "
              if rc = 0 then do
                  if pos("(",newname) = 0 then newdsn = newname
                     else do
                          if left(newname,1) <> "'" then do
                             newdsn = substr(newname,1,pos("(",newname)-
                             end
                             else do
                               newdsn1 = strip(newname,,"'")
                             newdsn = "'"substr(newdsn1,1,pos("(",newdsn
                                  end
                          parse value newname with . "(" new_member ")"
                          end
                  x = sysdsn(newdsn)
                  if x <> "OK" & newdisp <> "NEW" & newdisp <> "MOD" the
                     maillmsg = "Target data set" newname "does not exis
                        "Specify Disposition of NEW."
                     signal copyfile
                     end
                  if x = "OK" & newdisp = "NEW" then do
                     maillmsg = "Target data set",
                                 newname "exists and Disposition",
                        "NEW specified"
                     signal copyfile
                     end
              if x <> "OK" & newdisp = "MOD" then newdisp = "NEW"
              x = listdsi(mailtds directory)
              x = MSG("OFF")
              if sysdsorg = "PO" & newdisp = "MOD" then do
                     maillmsg = "Disposition of 'MOD' is not allowed for
                        "- specify SHR or OLD"
                     signal copyfile
                     end
              if sysdsorg = "PO" then do
                 if newrep = "YES" then
                    y.1 = '  COPY I=((SYSUT1,R)),O=SYSUT2'
                          else
                    y.1 = '  COPY I=SYSUT1,O=SYSUT2'
                   "FREE FILE(SYSUT1 SYSUT2 SYSIN SYSPRINT)"
                   if newdisp = "NEW" then
                   "ALLOC FILE(SYSUT2) DS("newname") NEW REUSE",
                          "LIKE("mailtds") DIR("sysadirblk")"
                       else
                   "ALLOC FILE(SYSUT2) DS("newname")" newdisp "REUSE"
                   "ALLOC FILE(SYSUT1) DS("mailtds") SHR REUSE"
                   "ALLOC FILE(SYSIN) UNIT("vio") SPACE(1,1) TRACKS",
                         "RECFM(F) BLKSIZE(80) NEW"
                   "EXECIO 1 DISKW SYSIN (FINIS STEM y.)"
                   "ALLOC FILE(SYSPRINT) DS(TMAILCPY.REPORT)",
                          "NEW SPACE(15,15) TR"
                   "TSOEXEC IEBCOPY"
                   prc = rc
                   Address ISPEXEC "BROWSE DATASET(TMAILCPY.REPORT)"
                   x = msg("off")
                   "FREE FILE(SYSUT1 SYSUT2 SYSIN SYSPRINT)"
                   "DELETE TMAILCPY.REPORT"
                   x = msg("on")
                        end
              else do
                   "FREE FILE(SYSUT1 SYSUT2 SYSIN SYSPRINT)"
                   if newdisp = "NEW" then do
                   if pos("(",newname) > 0 then dir = "DIR(5)"
                                           else dir = ""
                   "ALLOC FILE(SYSUT2) DS("newname") NEW REUSE",
                          "LIKE("mailtds")" dir
                          end
                       else
                   "ALLOC FILE(SYSUT2) DS("newname")" newdisp "REUSE"
                   "ALLOC FILE(SYSUT1) DS("mailtds") SHR REUSE"
                   "Execio * diskr SYSUT1 (Finis Stem gener."
                   "Execio * diskw SYSUT2 (Finis Stem gener."
                   prc = rc
                   size = gener.0
                   gener. = ""
                   if length(new_member) > 0 & newstat = "YES" then do
                      "Alloc f(sysut2) ds("newdsn") shr reuse"
                      Address ISPEXEC "LMINIT   DATAID(DATAID) DDNAME(SY
                      Address ISPEXEC "LMOPEN   DATAID("dataid")"
                      Address ISPEXEC,
                         "LMMSTATS DATAID("dataid") Member("new_member")
                                      "Modlevel(0) Created("date('O')")"
                                      "Moddate("date('O')")",
                                      "Modtime("left(time(),5)")",
                                      "Cursize("size") Initsize("size")"
                                      "Modrecs(0)",
                                      "User("sysvar('sysuid')")"
                      Address ISPEXEC "LMCLOSE  DATAID("dataid")"
                      Address ISPEXEC "LMFREE   DATAID("dataid")"
                      end
                   "FREE FILE(SYSUT1 SYSUT2)"
                   end
              mailsmsg = "Copied rc:" prc
              maillmsg = mailtds "copied to" newname "rc =" prc
              end
              else do
                   mailsmsg = "Cancelled"
                   maillmsg = "Copy operation cancelled by user request"
                   end

              Address ISPEXEC "SETMSG MSG(MAIL000)"
              "ALLOC FILE(SYSPRINT) DS(*) REUSE"
              "ALLOC FILE(SYSIN)    DS(*) REUSE"
              exit 0
./ ADD NAME=TMAILDEF 0114-89347-93085-0657-00032-00004-00000-$A1238
        /* Rexx exec to establish defaults for tso mail processing */

        /* ------------------------------------------------------- */
        /*                                                         */
        /*      Build the information to identify the sender       */
        /*      for messages that are to be sent:                  */
        /*                                                         */
        /* ------------------------------------------------------- */
            Address ISPEXEC "VGET (SENDFRM1) PROFILE"
            if length(sendfrm1) = 0 then do
            "SHOWTSO NAME"
            sendfrm1 = name
            end

            Address ISPEXEC "VGET (SENDFRM2) PROFILE"
            if length(sendfrm2) = 0 then do
            "SHOWTSO FDS DEPT GROUP MAIL PHONE"
            sendfrm2 = "D/"fds"-"dept"-"group"," mail phone
            end

            Address ISPEXEC "VGET (SENDFRM3) PROFILE"
            if length(sendfrm3) = 0 then do
            "SHOWTSO CENTER"
            sendfrm3 = "TSO Mail Addr:" center"."sysvar(sysuid)
            sendctr = center
            Address ISPEXEC "VPUT (SENDCTR) PROFILE"
            end

        Address ISPEXEC "DISPLAY PANEL(TMAILDEF)"

        Address ISPEXEC "DISPLAY PANEL(TMAILSUF)"
        exit
./ ADD NAME=TMAILEDM 0120-91022-93172-0628-00050-00038-00000-$A1238
        /*           rexx exec          *
         *                              *
         * used by tmailsend exec to    *
         * establish edit environment   *
         * for outgoing notes.          *
         *                              */


        Address ISREDIT

        "MACRO"

        "PROFILE UNLOCK"
        "RECOVERY OFF"
        "NUMBER OFF"
        "CAPS OFF"
        "NULL ON"
        "AUTOLIST OFF"
        "PACK OFF"
        "HEX OFF"
        "AUTOSAVE ON"
        "BOUNDS = 1 72"
        "RESET"
        Address ISPEXEC "VGET (FWD)"
        "(BOT) = LINENUM .ZLAST"
        if rc > 0 then bot = 0
        if bot = 0 then do
           "TENTER .ZF"
           if fwd <> "NEVER" then
              fwd = ""
           end
        "DEFINE TMIBMFAX MACRO CMD"
        "DEFINE FAXIBM ALIAS TMIBMFAX"
        "DEFINE TMAILEME MACRO CMD"
        "DEFINE TMAILEMC MACRO CMD"
        "DEFINE END ALIAS TMAILEME"
        "DEFINE CANCEL ALIAS TMAILEMC"
        if fwd = "YES" then do
                            "BOUNDS = 1 80"
                            "RESET"
                            do i = 1 to bot
                                   "SHIFT )" i "2"
                               end
                               "CHANGE ' ' '>' 1 ALL"
                            "BOUNDS = 1 72"
                            "LINE_AFTER 0 = ",
      "'>----------------- Forwarding the following message ------------
                            "LINE_AFTER .ZLAST = ",
      "'>------------------ End of the forwarded message ---------------
                            end
./ ADD NAME=TMAILEDX 0108-89325-93085-0657-00081-00036-00000-$A1238
        /* rexx exec */

        Address ISREDIT MACRO
        Address ISREDIT
        "(SENDLINE) = LINENUM .ZLAST"
        if sendline  = 0 then do
                              "CANCEL"
                              exit
                              end

        Address ISPEXEC "VGET (SENDID,SENDSUBJ,SENDSTMP) SHARED"
        Address ISPEXEC "VGET (SENDFRM1,SENDFRM2,SENDFRM3,SENDCTR) PROFI
        Address ISPEXEC "VGET (EPILOG1 EPILOG2 EPILOG3 EPILOG4 EPILOG5)"
               "PROFILE"
        Address ISPEXEC "VGET (EPILOG6 EPILOG7 EPILOG8 EPILOG9 EPILOG10)
               "PROFILE"
        Address ISPEXEC "VGET (TMAILEPI)" PROFILE

        "RECOVERY OFF"

        "LINE_BEFORE .ZF = '    '"
        subj = "Subject:" sendsubj
        Address ISPEXEC "VPUT (SUBJ)"
        "LINE_BEFORE .ZF = (SUBJ)"
        "LINE_BEFORE .ZF = 'From:   " sendfrm1"'"

        to   = sendid
        from = sysvar(sysuid) "on" sendctr
        "LINE_BEFORE .ZF =",
             "'Sender: " from "'"
        "LINE_BEFORE .ZF =",
             "'To:     " to "'"
        "LINE_BEFORE .ZF =",
             "'Date:   " sendstmp "'"
        "LINE_AFTER .ZL =",
            " '         '"

        /* do epilog */

        "LINE_BEFORE .ZL = '    '"
        "LINE_BEFORE .ZL = 'Signed: " sendfrm1"'"
         if length(sendfrm3) > 0 then
            "LINE_BEFORE .ZL = '         "sendfrm2"'"
         if length(sendfrm2) > 0 then
            "LINE_BEFORE .ZL = '         "sendfrm3"'"

        if tmailepi = 'Y' then do
          if length(epilog1) > 0 then do
             "LINE_BEFORE .ZL ='"epilog1"'"
             end
          if length(epilog2) > 0 then do
             "LINE_BEFORE .ZL ='"epilog2"'"
             end
          if length(epilog3) > 0 then do
             "LINE_BEFORE .ZL ='"epilog3"'"
             end
          if length(epilog4) > 0 then do
             "LINE_BEFORE .ZL ='"epilog4"'"
             end
          if length(epilog5) > 0 then do
             "LINE_BEFORE .ZL ='"epilog5"'"
             end
          if length(epilog6) > 0 then do
             "LINE_BEFORE .ZL ='"epilog6"'"
             end
          if length(epilog7) > 0 then do
             "LINE_BEFORE .ZL ='"epilog7"'"
             end
          if length(epilog8) > 0 then do
             "LINE_BEFORE .ZL ='"epilog8"'"
             end
          if length(epilog9) > 0 then do
             "LINE_BEFORE .ZL ='"epilog9"'"
             end
          if length(epilog10) > 0 then do
             "LINE_BEFORE .ZL ='"epilog10"'"
             end
        end

        "SAVE"
        "END"
./ ADD NAME=TMAILEMC 0106-90022-93085-0657-00016-00014-00000-$A1238
        /*  Rexx ISPF Edit Macro                                       *

        /* ----------------------------------------------------------- *
        /*                                                             *
        /*  This ISPF Edit Macro is used as an Alias for the ISPF EDIT *
        /*  'CANCEL' command by the TMAILSND exec.                     *
        /*                                                             *
        /* ----------------------------------------------------------- *
        Address ISREDIT "MACRO (PARM) NOPROCESS"

        Address ISREDIT "DEFINE CANCEL RESET"  /* reset CANCEL back to n
        Address ISREDIT "DEFINE END    RESET"  /* reset END    back to n

        Address ISREDIT "END"
        mailend = "CANCEL"
        Address ISPEXEC "VPUT (MAILEND)"
./ ADD NAME=TMAILEME 0105-90022-93085-0657-00018-00014-00000-$A1238
        /*  Rexx ISPF Edit Macro                                       *

        /* ----------------------------------------------------------- *
        /*                                                             *
        /*  This ISPF Edit Macro is used as an Alias for the ISPF EDIT *
        /*  'END' command by the TMAILSND exec.                        *
        /*                                                             *
        /* ----------------------------------------------------------- *
        Address ISREDIT "MACRO (PARM) NOPROCESS"

        Address ISREDIT "DEFINE END RESET"     /* reset END back to norm
        Address ISREDIT "DEFINE CANCEL RESET"  /* reset CANCEL back to n

        Address ISREDIT "SAVE"
        Address ISREDIT "END"

        mailend = "END"
        Address ISPEXEC "VPUT (MAILEND)"
./ ADD NAME=TMAILEPF 0130-90241-93085-0657-00117-00016-00000-$A1238
        /* ---------------------  rexx procedure  ----------------------
         * Name:      TMAILEPF
         *
         * Function:  Update the message to be transmitted to
         *            a non-TSO user with valid PROFS header and
         *            trailer information
         *
         * Syntax:    ISPEXEC EDIT DATASET(...) MACRO(TMAILEPF)
         *
         * Author:    Lionel B. Dyck
         *            Rockwell International
         *            P.O. Box 2515
         *            Seal Beach, California 90740
         *            (310) 797-1125
         *            IBMLINK:  ROK2027
         *
         * Change History:
         *            05/07/92 - Set bounds for shift
         *            04/16/92 - Fixup code for smtp to remove for profs
         *            02/28/92 - Remove smtp address from From:
         *            02/14/92 - Remove SMTP headers if present
         *            11/05/91 - Shift everything right 1 column for
         *                       standardization with IBM Mail Exchange
         *                       'standards'.
         *            09/30/91 - Correction to support quotes in the sub
         *            08/29/90 - Creation of this REXX Procedure
         *
         * -------------------------------------------------------------

        Address ISREDIT  "MACRO"

        /* -------------------------------------------------------------
         * Extract mailling information
         * -------------------------------------------------------------
        Address ISPEXEC "VGET (SENDID SENDSUBJ SENDCTR TONODE ",
                         "TOID ACK) SHARED"

        sender = sysvar(sysuid)

        Address ISREDIT

        "(LINE) = LINE 1"

        /* -------------------------------------------------------------
         * Determine if SMTP headers exist and remove them
         * -------------------------------------------------------------
         "FIND 'helo' 1 FIRST"
         if rc = 0 then do
            "DELETE 1 4"
            "Find 'To:' 1 "
            if rc = 0 then do
              "(LINE) = CURSOR"
              "(DATA) = LINE" line
              parse value data with from "<" .
              to = strip(to)
              "Line" line "= 'To:      "sendid "'"
              end
             "Find 'Sender:' 1"
              if rc = 0 then do
                 "(LINE) = CURSOR"
                 "Delete" Line
                 end
            "Find 'From:' 1"
            if rc = 0 then do
              "(LINE) = CURSOR"
              "(DATA) = LINE" line
              parse value data with from "<" .
              from = strip(from)
              "Line" line "= '"from "'"
              end
          end

        /* -------------------------------------------------------------
         * Determine if this is the first time, otherwise delete the
         * previously inserted PROFS header and trailer
         * -------------------------------------------------------------
        if substr(line,2,10) = "MSG:FROM: " then do
             "DELETE .zfirst"
             "DELETE .zlast"
             end
             else call shift_right

        "(LAST) = LINENUM .ZLAST"

        /* -------------------------------------------------------------
         * Fix up the PROFS Header record
         * -------------------------------------------------------------
        "LINE_BEFORE 1 = ' MSG:FROM:" left(sender,8)"--"left(sendctr,8)
            left(toid,8)"--"left(tonode,18)date('u') time()"'"

        "CHANGE ' ' x'FE' 1 FIRST"
        if ack = "Y"
           then "CHANGE ' ' x'01' 80 FIRST"

        /* -------------------------------------------------------------
         * Fix up the PROFS Trailer record
         * -------------------------------------------------------------
        subject = left(" ",6)left(sendsubj,65)
        "LINE_AFTER" last+1 " = (subject)"

        "CHANGE '      ' x'FFFF00000011' 1 LAST"
        "CHANGE '         ' x'000000000000000000' 72 LAST"

        "SAVE"
        "END"
        exit 0

        Shift_right:
        if tonode <> "IBMMAIL" then return
            "(LAST) = LINENUM .ZLAST"
            "(BNDL,BNDR) = BOUNDS"
               "BOUNDS = 1 255"
            do i = 1 to last
               "SHIFT )" i "1"
               end
               "BOUNDS =" bndl bndr
        return
./ ADD NAME=TMAILESM 0125-92045-93085-0657-00072-00038-00000-$A1238
        /* ---------------------  rexx procedure  ----------------------
         * Name:      TMAILESM
         *
         * Function:  Update the message to be transmitted to
         *            an SMTP (aka SMTPID) address.
         *
         * Syntax:    ISPEXEC EDIT DATASET(...) MACRO(TMAILESM)
         *
         * Author:    Lionel B. Dyck
         *            Rockwell International
         *            P.O. Box 2515
         *            Seal Beach, California 90740
         *            (310) 797-1125
         *            IBMLINK:  ROK2027
         *
         * History:
         *            02/14/92 - Created
         *
         * -------------------------------------------------------------

        Address ISREDIT  "MACRO"

        /* -------------------------------------------------------------
         * Extract mailling information
         * -------------------------------------------------------------
        Address ISPEXEC "VGET (SMTPID SMTPHOST) SHARED"

        sendid = sysvar(sysuid)"@"smtphost

        Address ISREDIT

        "FIND 'rcpt to:' FIRST"
        if rc > 0 then option = "FIRST"
                  else do
                       option = "NEXT"
                       "(CLINE) = CURSOR"
                       cline = cline + 1
                       "CURSOR =" cline
                       end
        "FIND 'To:'" option
        "(CLINE) = CURSOR"
        "LINE" cline "= 'To:     " smtpid "'"
        "FIND 'Sender: ' FIRST"
        "(CLINE) = CURSOR"
        "LINE" cline "= 'Sender: " sendid "'"

        "Find 'rcpt to:' FIRST"
         if rc = 0 then do
           "(LINE) = CURSOR"
           "Line" line "= 'rcpt to:   <"smtpid">'"
           end

        "Find 'helo ' FIRST 1"
        if rc <> 0 then do
           "Line_Before .ZF = 'helo "smtphost "'"
           "Line_After  .ZF = 'mail from: <"sendid">'"
           "Line_After  2 = 'rcpt to:   <"smtpid">'"
           "Line_After  3 = 'data'"

           "Find 'From:'"
            if rc = 0 then do
              "(LINE) = CURSOR"
              "(DATA) = LINE" line
              parse value data with from "<" .
              from = strip(from)
              "Line" line "= '"from "<"sendid">'"
              end
           end

        "SAVE"
        "END"
        exit 0
./ ADD NAME=TMAILLOG 0111-92280-93085-0657-00345-00315-00000-$A1238
        /* ---------------------  rexx procedure  ----------------------
         * Name:      TMAILLOG
         *
         * Function:  Display TSO/E Mail Log Data Sets
         *            Create  TSO/E Mail Log Data Sets
         *
         * Syntax:    %TMAILLOG options
         *
         * options:   DEBUG      Provide REXX instruction tracing
         *            LOG n      Return information on log data set 'n'
         *
         * Logic:
         *
         *  1.  Process initialization options
         *  2.  Determine if started under ISPF applid MAIL
         *      and if not then re-invoke under MAIL
         *  3.  Open log data set and create if necessary
         *  4.  If startup option LOG is specified then
         *      -  display selection table to return selected informatio
         *      or
         *      -  return information for specified log
         *      -  then exit
         *  5.  Display table of available and defined logs
         *      -  allow display of information on a log
         *      -  allow delete of a log data set and entry
         *      -  read/process a log
         *
         * Author:    Lionel B. Dyck
         *            Rockwell International
         *            P.O. Box 2515
         *            Seal Beach, California 90740
         *            (213) 797-1125
         *            IBMLINK:  ROK2027
         *
         * History:
         *            05/06/92 - Allow command S row or C row
         *                       Set default Address to ISPEXEC
         *            06/28/91 - cleanup
         *            06/20/91 - Creation by Lionel Dyck
         * -------------------------------------------------------------

        Arg options

        if wordpos("DEBUG",options) > 0 then trace i

        if "ACTIVE" = sysvar(sysispf) then do
           Address ISPEXEC
           "VGET ZAPPLID"
           if zapplid ^= "MAIL" then do
           cmd = sysvar(sysicmd)
           "SELECT CMD(%"cmd options") NEWAPPL(MAIL)"
           exit 0
           end

        parse value options with "LOG" log_number .

        if wordpos("LOG",options) > 0 then log_process = "on"
                                      else log_process = "off"

        prefix = sysvar(syspref)
        table_log = "'"prefix".TSOMAIL.TABLE'"
        "CONTROL ERRORS RETURN"

        crp = 0
        rowcrp = 0
        hcc = 0

        "LIBDEF TSOMLOG DATASET ID("table_log")"

        open_it:
        "TBOPEN TSOMLOG LIBRARY(TSOMLOG) WRITE"
        lrc = rc

        select
            when lrc = 8 then do
                 "TBCREATE TSOMLOG KEYS(lognum)",
                 "NAMES(Logdesc Logds) LIBRARY(TSOMLOG) WRITE"
                 parse value "" with logdesc logds
                 lognum = 1
                 "TBADD TSOMLOG"
                 "TBDELETE TSOMLOG"
                 "TBSORT TSOMLOG FIELDS (LOGNUM N,A)"
                 "TBSAVE TSOMLOG LIBRARY(TSOMLOG) REPLCOPY"
                 end
            when lrc = 12 then do
                 if retry_open = 1 then do
                    maillmsg = "TSO/E Mail Log error code" lrc
                    "Setmsg Msg(MAIL000)"
                    exit 4
                    end
                    else do
                         retry_open = 1
                         "TBEND TSOMLOG"
                         signal open_it
                         end
                    end
            when lrc > 12 then do
                 mailsmsg = "Error"
                 maillmsg = "TSO/E Mail Log error code" lrc
                 "Setmsg Msg(MAIL000)"
                 exit 4
                 end
            otherwise nop;
            end

        if length(log_number) > 0 then do
           lognum = log_number
           "TBSCAN TSOMLOG ARGLIST(lognum)"
           if rc = 0 then do
              "VPUT (logds lognum)"
              "TBEND TSOMLOG"
              "LIBDEF TSOMLOG"
              exit 0
              end
          else do
              mailsmsg = ""
              maillmsg = "The selected log data set" log_number,
                          "does not exist - try again"
              "SETMSG MSG(Mail000)"
              end
           end

        if log_process = "off" then log_panel = "TMLOG1"
                               else log_panel = "TMLOG2"

        display:
        do forever
           parse value "" with zcmd zsel mailsmsg maillmsg

        if hcc == 4 then "TBDISPL TSOMAIL"
           else do
                "TBTOP TSOMLOG"
                "TBSKIP TSOMLOG NUMBER("crp")"
                if rowcrp = 0 then
                "TBDISPL TSOMLOG PANEL("log_panel")"
                else
                "TBDISPL TSOMLOG PANEL("log_panel")",
                        "CSRROW("rowcrp") AUTOSEL(NO)"
                end

        crp = ztdtop

        hcc = rc  /* save return code */

        if hcc > 4 then do
             "TBCLOSE TSOMLOG REPLCOPY LIBRARY(TSOMLOG)"
             "LIBDEF TSOMLOG"
             mailsmsg = 'Complete'
             maillmsg = 'ISPF TSO Mail Log Process Complete'
             "SETMSG MSG(MAIL000)"
             exit
             end

        if ztdsels = 0 & length(zcmd) = 0 then signal display

        hit = 0
        rowcrp = 0

        if zsel ^= ""  then do
           "TBQUERY TSOMLOG",
                  "POSITION(ROWCRP)"
                  crp = crp + rowcrp - 1
                  rowcrp = 1
                  end

        upper zcmd

        sel_opt:
        if words(zcmd) > 1 then do
           parse value zcmd with v1 row
           if datatype(row) <> "NUM" then do
              mailsmsg = "Error"
              maillmsg = "Invalid command:" zcmd
              "Setmsg MSG(MAIL000)"
              signal display
              end
           if wordpos(v1,"C S") = 0 then do
              mailsmsg = "Error"
              maillmsg = "Invalid command:" zcmd
              "Setmsg MSG(MAIL000)"
              signal display
              end
           else do
                lognum = row
                "TBTOP TSOMLOG"
                "TBSCAN TSOMLOG ARGLIST(lognum)"
                if rc > 0 then do
                   mailsmsg = "Not Found"
                   maillmsg = "Desired row not found for command:",
                               zcmd
                   msg = 1
                   end
                else do
                   zsel = v1
                   end
                end
           end

        if zcmd = "NEW" then do
        new_log:
           "TBBOTTOM TSOMLOG"
           if rc = 8 then lognum = 1
                     else lognum = lognum + 1
           parse value "" with logds logdesc
           "Display Panel(TMLOG3)"
           if rc > 0 then do
              mailsmsg = "Cancelled"
              maillmsg = "Creation of TSO/E Mail Log has been cancelled"
              "Setmsg MSG(MAIL000)"
              signal display
              end
           if left(logds,1) <> "'" then logds ="'"prefix"."logds"'"
           if sysdsn(logds) = "OK" then do
              mailsmsg = "Error"
              maillmsg = "Specified TSO/E Mail Log data set current exis
                         " - try again"
              "Setmsg MSG(MAIL000)"
              signal new_log
              end
           Address TSO
           "Alloc ds("logds") NEW Like("table_log")"
           "Free  ds("logds")"
           Address ISPEXEC
           mailsmsg = "Created"
           maillmsg = "TSO/E Mail Log data set" logds "has been allocate
           "TBADD TSOMLOG"
                 "TBSAVE TSOMLOG LIBRARY(TSOMLOG) REPLCOPY"
           "LIBDEF TM"lognum "DATASET ID("logds")"
           "TBCREATE TM"lognum "KEYS(MAILNUM)",
           "NAMES(MAILFLOC MAILFID MAILTLOC MAILTID MAILDATN MAILDATD",
           "MAILTIME MAILACTN MAILSUBJ MAILFDS MAILTDS)",
           "LIBRARY(TM"lognum") WRITE"
               "TBSAVE TM"lognum "LIBRARY(TM"lognum") REPLCOPY"
               "TBEND  TM"lognum
               "LIBDEF TM"lognum
           msg = 1
        end

        if abbrev("RENUMBER",zcmd,3) = 1 then do
             "LMINIT DATAID(dataid) DATASET("table_log") ENQ(SHRW)"
             "LMOPEN DATAID("dataid") OPTION(OUTPUT)"
             "LMMDEL DATAID("dataid") MEMBER(TSOMLOGX)"
             "LMCLOSE DATAID("dataid")"
             "LMFREE DATAID("dataid")"
           "TBCREATE TSOMLOGX KEYS(lognum)",
                 "NAMES(Logdesc Logds) LIBRARY(TSOMLOG) WRITE"
           "TBTOP TSOMLOG"
              log_count = 0
              "TBQUERY TSOMLOG ROWNUM("rows")"
           loop_num: do rows
             "TBSKIP TSOMLOG"
             if rc = 0 then do
               log_count = log_count + 1
               if lognum <> log_count then do
                 "LMINIT DATAID(dataid) DATASET("logds") ENQ(SHRW)"
                 "LMOPEN DATAID("dataid") OPTION(OUTPUT)"
                 "LMMREN DATAID("dataid") MEMBER(TM"lognum")",
                     "NEWNAME(TM"log_count")"
                 "LMCLOSE DATAID("dataid")"
                 "LMFREE DATAID("dataid")"
                 lognum = log_count
                 end
               "TBADD TSOMLOGX"
               end
             end
           "TBSORT TSOMLOGX FIELDS (LOGNUM N,A)"
           "TBSAVE TSOMLOGX LIBRARY(TSOMLOG) REPLCOPY"
           "TBEND TSOMLOGX"
           "TBEND TSOMLOG"
           "LIBDEF TSOMLOG"
             "LMINIT DATAID(dataid) DATASET("table_log") ENQ(SHRW)"
             "LMOPEN DATAID("dataid") OPTION(OUTPUT)"
             "LMMDEL DATAID("dataid") MEMBER(TSOMLOG)"
             "LMMREN DATAID("dataid") MEMBER(TSOMLOGX)",
                 "NEWNAME(TSOMLOG)"
             "LMCLOSE DATAID("dataid")"
             "LMFREE DATAID("dataid")"
           "LIBDEF TSOMLOG DATASET ID("table_log")"
           "TBOPEN TSOMLOG LIBRARY(TSOMLOG) WRITE"
           "TBTOP  TSOMLOG"
           mailsmsg = "Updated"
           maillmsg = "TSO/E Mail Log information has been updated."
           "SETMSG MSG(Mail000)"
           signal display
           end

        do_sel:
        if log_process = "on" then do
           Select
             When zsel = "I" then do
                  "DISPLAY PANEL(TMLOGI)"
                  end
             When zsel = "C" then do
                  "DISPLAY PANEL(TMLOGC)"
                  if rc = 0 then call update_log
                  end
             When zsel = "S" then do
                  "VPUT (logds lognum)"
                  "TBEND TSOMLOG"
                  "LIBDEF TSOMLOG"
                  exit 0
                  end
             otherwise nop;
             end
        end

        if log_process = "off" then do
           Select
             When zsel = "D" then do
                  mailsmsg = "Deleted"
                  maillmsg = "Log entry deleted........"
                  msg = 1
                  Address TSO "Delete" logds
                  "TBDELETE TSOMLOG"
                  "TBSAVE TSOMLOG LIBRARY(TSOMLOG) REPLCOPY"
                  end
             When zsel = "I" then do
                  "DISPLAY PANEL(TMLOGI)"
                  end
             When zsel = "C" then do
                  "DISPLAY PANEL(TMLOGC)"
                  if rc = 0 then call update_log
                  end
             When zsel = "S" then do
                  table = logds
                  tablet = strip(logds,,"'")
                  ispftbl = "TM"lognum
                  maillog = logdesc
                  "VPUT (table tablet ispftbl maillog) SHARED"
                  "Select CMD(%TSOMAIL LOG)"
                  end
             otherwise nop;
             end
        end

        if msg = 1 then "SETMSG MSG(Mail000)"
        end

        update_log:
           "TBMOD TSOMLOG"
           "TBSAVE TSOMLOG LIBRARY(TSOMLOG) REPLCOPY"
           mailsmsg = "Updated"
           maillmsg = "TSO/E Mail Log information has been updated."
           "SETMSG MSG(Mail000)"
           return
./ ADD NAME=TMAILNIK 0127-91345-93153-0646-00856-00752-00000-$A1238
        /* ---------------------  rexx procedure  ----------------------
         * Name:      TMAILNIK
         *
         * Function:  Maintain the user's Nick Names for TSO Transmit
         *            processing.
         *
         * Syntax:    %TMAILNIK
         *
         * Dependencies:
         *            The name of the nick name file is defined in
         *            either load module INMXPARM or in SYS1.PARMLIB
         *            member IKJTSOxx via LOGSEL(xx) and LOGNAME(xx).
         *
         *            The name is set in variable names_file and must
         *            conform to the above.
         *
         *            ISPF Command Table MAILCMDS must contain:
         *
         *            Verb    T   Action
         *            RFIND   0   &USRFIND
         *                        Allow RFIND to be processed by me.
         *
         * Author:    Lionel B. Dyck
         *            Rockwell International
         *            P.O. Box 2515
         *            Seal Beach, California 90740
         *            (310) 797-1125
         *            IBMMail:  USROKNTN
         *
         * History:
         *            07/06/92 - change to use delword instead of overla
         *            01/31/92 - General cleanup
         *            01/11/92 - Add 'Found' message for successful
         *                       search
         *            12/11/91 - Creation of this procedure
         *
         * -------------------------------------------------------------

        arg option
        if option = "DEBUG" then trace i

        names_file = "'"sysvar(syspref)".NAMES.TEXT'"

        if "ACTIVE" = sysvar('sysispf') then do
           Address ISPEXEC "VGET ZAPPLID"

           cmd = sysvar('sysicmd')

           if zapplid <> "MAIL" then do
           Address ISPEXEC "SELECT CMD(%"cmd options") NEWAPPL(MAIL)"
           exit
           end

        end

        null = ""

        "Showtso Center"

        dd_name = "NK"random()

        type = "Primary"
        call init_all

        if sysdsn(names_file) = "OK" then
           call read_it
           else do
                new_table = "on"
                in.0 = 0
                "Alloc ds("names_file") New Space(15,15) Tracks",
                  "RECFM(F B) LRECL(80) BLKSIZE(0) DSORG(PS)"
                "Free ds("names_file")"
                prim = names_file
                signal do_table
                end

        Disp_query:
        usrfind = null
        Address ISPEXEC "VPUT USRFIND"
        parse value null with zp z1 z2 z3 z4 z5 z6 z7 z8 z9 zcmd
        Address ISPEXEC "Display Panel(TMAILNIK)"
        if rc > 0 then exit 0

           select
             when length(zp) > 0 then new_nick = prim
             when length(z1) > 0 then new_nick = alt1
             when length(z2) > 0 then new_nick = alt2
             when length(z3) > 0 then new_nick = alt3
             when length(z4) > 0 then new_nick = alt4
             when length(z5) > 0 then new_nick = alt5
             when length(z6) > 0 then new_nick = alt6
             when length(z7) > 0 then new_nick = alt7
             when length(z8) > 0 then new_nick = alt8
             when length(z9) > 0 then new_nick = alt9
             otherwise new_nick = null
             end

        if length(new_nick) = 0 then do
           mailsmsg = null
           maillmsg = "You must select one data set or exit via PF3"
           Address ISPEXEC "SETMSG MSG(MAIL000)"
           signal disp_query
           end

        if prim = new_nick then type = "Primary"
                           else type = "Alternate"

        if sysdsn(new_nick) <> "OK" then do
             mailsmsg = "Error"
             maillmsg = new_nick "could not be found"
             Address ISPEXEC "Setmsg Msg(MAIL00)"
             signal disp_query
             end

           names_file = new_nick
           nickds = new_nick
           call init_all
           call read_it

        /* --------------------------------------------------------
           Now build the appropriate ISPF information for the selected
           data set.
           -------------------------------------------------------- */

        do i = 1 to in.0
         in_u = in.i
         upper in_u
         select
          when pos(":ALTCTL.",in_u) > 0 then do
             if type = "Primary" then do
                parse value in_u with ":ALTCTL." val
                c = altctl.0 + 1
                altctl.c = strip(val)
                altctl.0 = c
                end
             end
          when pos(":LOGSEL.",in_u) > 0 then do
             if type = "Primary" then
               parse value in_u with ":LOGSEL." logsel .
               end
          when pos(":LOGNAME.",in_u) > 0 then do
             if type = "Primary" then
               parse value in_u with ":LOGNAME." logname .
               end
          when pos(":PROLOG.",in_u) > 0 then do
             if type = "Primary" then do
                pos = pos(":PROLOG.",in_u)
                val = substr(in.i,pos+8)
                c = prolog.0 + 1
                prolog.c = strip(val)
                prolog.0 = c
                end
             end
          when pos(":EPILOG.",in_u) > 0 then do
             if type = "Primary" then do
                pos = pos(":EPILOG.",in_u)
                val = substr(in.i,pos+8)
                c = epilog.0 + 1
                epilog.c = strip(val)
                epilog.0 = c
                end
             end
          otherwise do
            if pos(":NICK.",in_u) > 0 then do
               if have_nick = "on" then do
                 c = nick.0
                 if node.c = null then node.c = center
                 end
               have_nick = "on"
               c = nick.0 + 1
                parse value in_u with ":NICK." val ":" .
               nick.c = strip(val)
               nick.0 = c
               end
            if pos(":LIST.",in_u) > 0 then do
               node.c = "*List*"
               parse value in_u with ":LIST." val ':' .
               list.c = list.c strip(val)
               end
            if pos(":NODE.",in_u) > 0 then do
               c = nick.0
                parse value in_u with ":NODE." val ":" .
               node.c = strip(val)
               end
            if pos(":USERID.",in_u) > 0 then do
               c = nick.0
               parse value in_u with ":USERID." val ":"  .
               userid.c = strip(val)
               end
            if pos(":PHONE.",in_u) > 0 then do
               c = nick.0
               parse value in_u with ":PHONE." val ":"  .
               phone.c = strip(val)
               end
            if pos(":INTERNET.",in_u) > 0 then do
               c = nick.0
               pos = pos(":INTERNET.",in_u)
               val = substr(in.i,pos+10)
               x = pos(":",val)
               if x = 0 then
                        Internet.c = strip(val)
                        else
                        Internet.c = strip(substr(val,1,x-1))
               end
            if pos(":ADDRESS1.",in_u) > 0 then do
               c = nick.0
               pos = pos(":ADDRESS1.",in_u)
               val = substr(in.i,pos+10)
               x = pos(":",val)
               if x = 0 then
                        Address1.c = strip(val)
                        else
                        Address1.c = strip(substr(val,1,x-1))
               end
            if pos(":ADDRESS2.",in_u) > 0 then do
               c = nick.0
               pos = pos(":ADDRESS2.",in_u)
               val = substr(in.i,pos+10)
               x = pos(":",val)
               if x = 0 then
                        Address2.c = strip(val)
                        else
                        Address2.c = strip(substr(val,1,x-1))
               end
            if pos(":ADDRESS3.",in_u) > 0 then do
               c = nick.0
               pos = pos(":ADDRESS3.",in_u)
               val = substr(in.i,pos+10)
               x = pos(":",val)
               if x = 0 then
                        Address3.c = strip(val)
                        else
                        Address3.c = strip(substr(val,1,x-1))
               end
            if pos(":ADDRESS4.",in_u) > 0 then do
               c = nick.0
               pos = pos(":ADDRESS4.",in_u)
               val = substr(in.i,pos+10)
               x = pos(":",val)
               if x = 0 then
                        Address4.c = strip(val)
                        else
                        Address4.c = strip(substr(val,1,x-1))
               end
            if pos(":NAME.",in_u) > 0 then do
               c = nick.0
               pos = pos(":NAME.",in_u)
               val = substr(in.i,pos+6)
               x = pos(":",val)
               if x = 0 then
                        name.c = strip(val)
                        else
                        name.c = strip(substr(val,1,x-1))
               end
            end
          end
        end

        do_table:
        table = random()

        Address ISPEXEC

        "TBcreate NICK"table" KEYS(NICKNAME)",
                        "NAMES(NODE USERID NAME INTERNET",
                        "PHONE ADDRESS1 ADDRESS2 ADDRESS3",
                        "ADDRESS4 SEARCH) Nowrite"

        "TBcreate LIST"table" KEYS(NICKNAME)",
                        "NAMES(LIST SEARCH) Nowrite"

        "TBcreate CTRL"table,
                        "NAMES(Option Value Search) Nowrite"

        if new_table = "on" then do
           parse value null with nickname node user name,
                            phone internet address1 address2,
                            address3 address4 search
           nick.0 = 0
           altctl.0 = 0
           prolog.0 = 0
           epilog.0 = 0
           end

        do i = 1 to nick.0
           if node.i <> "*List*" then do
                     nickname = nick.i
                     node     = node.i
                     userid   = userid.i
                     name     = name.i
                     internet = internet.i
                     phone    = phone.i
                     address1 = address1.i
                     address2 = address2.i
                     address3 = address3.i
                     address4 = address4.i
                     search = nickname node userid name internet,
                              phone address1 address2 address3 address4
                     upper search
                     "TBADD NICK"table
                     end
                else do
                     nickname = nick.i
                     list     = strip(list.i)
                     search = nickname list
                     upper search
                     "TBADD LIST"table
                     parse value null with userid name
                     nickname = nick.i
                     node     = node.i
                     search = nickname node
                     upper search
                     "TBADD NICK"table
                     end
           end

        if type = "Primary" then do i = 1 to altctl.0
           option = ":Altctl."
           value = altctl.i
           search = option value
           upper search
           "TBADD CTRL"table
           end

        if type = "Primary" then do i = 1 to prolog.0
           option = ":Prolog."
           value = prolog.i
           search = option value
           upper search
           "TBADD CTRL"table
           end

        if type = "Primary" then do i = 1 to epilog.0
           option = ":Epilog."
           value = epilog.i
           search = option value
           upper search
           "TBADD CTRL"table
           end

        if type = "Primary" then
           if length(logsel) > 0 then do
           option = ":Logsel."
           value = logsel
           search = option value
           upper search
           "TBADD CTRL"table
           end

        if type = "Primary" then
           if length(logname) > 0 then do
           option = ":Logname."
           value = logname
           search = option value
           upper search
           "TBADD CTRL"table
           end

        "TBSORT NICK"table "FIELDS(NICKNAME)"
        "TBTOP NICK"table
        "TBSORT LIST"table "FIELDS(NICKNAME)"
        "TBTOP LIST"table
        "TBTOP CTRL"table

        if new_table = "on" then call do_Primary

        do until lrc > 4
           zcmd = null
          "DISPLAY PANEL(TMNIKT0)"
          lrc = rc

          trc = 0
          select
            when zcmd = 1 then call do_Primary
            when zcmd = 2 then call do_lists
            when zcmd = 3 then call do_control
            when zcmd = 4 then call save_it
            otherwise if lrc = 0 then do
                      mailsmsg = null
                      maillmsg = "Invalid option selected"
                      "SETMSG MSG(MAIL000)"
                      end
            end
        end

        Complete:
        /* ----------------------------------------------
           Processing is now about to terminate so we
           have to close the ISPF Tables and reset things
           in REXX.
           ---------------------------------------------- */

        "TBEND NICK"table
        "TBEND LIST"table
        "TBEND CTRL"table
        Address TSO
        signal Disp_query

        /* the following code is called or signaled only */

        do_lists:
           trc = 0
           zcmd = null
              do until trc > 4
              if trc = 4 then "TBDispl LIST"table
                         else "TBDispl LIST"table "PANEL(TMNIKTL)"
               trc = rc
               select
               when zcmd = "CANCEL" then signal complete
               when zcmd = "SAVE" then call save_it
               when zcmd = "I" then do
                     zcmd = null
                     "Display Panel(TMNIKTLN)"
                     if rc = 0 then do
                        nickname = listnick
                        list = ''
                        "TBADD LIST"table "ORDER"
                        if rc = 0 then
                           change_nick = "on"
                           else do
                                mailsmsg = "Error"
                           maillmsg = "Error adding duplicate nickname l
                                listnick"' to the table"
                                "Setmsg Msg(MAIL000)"
                                end
                        change_list = "on"
                        end
                     end
               when length(zcmd) > 0 then do
                    ab = word(zcmd,1)
                    if ab = "L" then do
                       /*  do search in table */
                       end
                    end
               when zsel = "S" then call list_sel
               when zsel = "D" then do
                  "TBDELETE LIST"table
                  end
               otherwise nop
               end
           end
        return

        list_sel:
            "TBcreate TEMP Keys(LISTNICK) Nowrite Replace"
            do i = 1 to words(list)
               listnick = word(list,i)
               "TBADD TEMP ORDER"
               end
           "TBSORT TEMP FIELDS(LISTNICK)"
           "TBTOP  TEMP"
            change_list = null
            list_exit = null
            do_list_sel:
            do until list_exit = "on"
               zcmd = null
               if xtrc = 4 then "TBDispl TEMP"
                           else "TBDispl TEMP Panel(TMNIKTLL)"
                  xtrc = rc
                  if xtrc > 4 then do
                     if change_list = "on" then do
                        mailsmsg = "Warning"
                     maillmsg = "Changes have been made - Enter PF3 to c
                                    "or Save to save it"
                        "SETMSG MSG(MAIL000)"
                        change_list = null
                        end
                        else do
                             "TBEND TEMP"
                             list_exit = "on"
                             end
                  end
                  if abbrev("CANCEL",zcmd,2) = 1 then do
                     "TBEND TEMP"
                      list_exit = "on"
                     mailsmsg = "Cancelled"
                     maillmsg = "Nickname list update has been cancelled
                     "SETMSG MSG(MAIL000)"
                     end
                  if zcmd = "I" then do
                     zcmd = null
                     "Display Panel(TMNIKTLI)"
                     if rc = 0 then do
                        list = list newid
                        listnick = newid
                        "TBADD TEMP ORDER"
                        if rc = 0 then
                           change_nick = "on"
                           else do
                                mailsmsg = "Error"
                           maillmsg = "Error adding duplicate nickname l
                                nickname"' to the table"
                                "Setmsg Msg(MAIL000)"
                                end
                        change_list = "on"
                        end
                     end
                  if abbrev("SAVE",zcmd,2) = 1 then do
                     savetop = ztdtop
                         "TBTOP TEMP"
                         new_list = null
                     do forever
                         "TBSKIP TEMP"
                         if rc > 0 then leave
                         new_list = new_list listnick
                         end
                         list = new_list
                     "TBPUT LIST"table
                     savetop = ztdtop
                     call save_it
                       "TBTOP TEMP"
                       "TBSKIP TEMP ROW("savetop")"
                     mailsmsg = "Saved"
                     maillmsg = "Nickname List has been saved"
                     "SETMSG MSG(MAIL000)"
                      change_list = null
                      end
                  if  zsel = "D" then do
                      dw = wordpos(listnick,list)
                      dw  = wordindex(list,dw)
                      x = delword(list,dw)
                      change_list = "on"
                      list = x
                      "TBDelete TEMP"
                      end
             end
        return

        do_control:
           if type <> "Primary" then do
              mailsmsg = "Error"
              maillmsg = "Control processing is not allowed for other th
                         "the Primary data set"
              "SETMSG MSG(MAIL000)"
              return
              end
           "TBTOP CTRL"table
           trc = 0
           zcmd = null
           do until trc > 4
              if trc = 4 then "TBDispl CTRL"table
                         else "TBDispl CTRL"table "PANEL(TMNIKT2)"
               trc = rc
               select
               when zcmd = "CANCEL" then signal complete
               when zcmd = "SAVE" then call save_it
               when zcmd = "I" then do
                  option = null
                  value = null
                  "TBADD CTRL"table
                  end
               when zsel = "I" then do
                  option = null
                  value = null
                  "TBADD CTRL"table
                  end
               when zsel = "U" then do
                  "TBPUT CTRL"table
                  end
               when zsel = "D" then do
                  "TBDELETE CTRL"table
                  end
               otherwise
                  "TBPUT CTRL"table
               end
           end
           return

        do_Primary:
           change_nick = null
           do until trc > 4
                zcmd = null
                if disp_panel = "row" then
                   "TBDISPL NICK"table "PANEL(TMNIKT1) CSRROW("skiprow")
                   else do
                   if trc = 4 then "TBDispl NICK"table
                              else "TBDISPL NICK"table" PANEL(TMNIKT1)"
                   trc = rc
                   end
                disp_panel = null

           if word(zcmd,1) = "DEBUG" then do
              parse value zcmd with w1 w2
              if w2 = "OFF" then trace off
              if length(w2) = 0 then trace i
              if w2 = "ON" then trace i
              end

           if zcmd = "I" & length(zsel) = 0  then do
              zsel = zcmd
              zcmd = null
              end

           if zcmd = "CANCEL" then signal complete

           if zcmd = "SAVE" then do
              savetop = ztdtop
              call save_it
                "TBTOP NICK"table
                "TBSKIP NICK"table "ROW("savetop")"
              change_nick = null
              end

           if zcmd = "RFIND" then do
              zcmd = "FIND" argument
              zsel = null
                 "TBSKIP NICK"table "POSITION(SKIPROW) ROWID(ROWID)"
              end

           if abbrev("FIND",word(zcmd,1),1) = 1 then do
              /* perform search */
              usrfind = "PASSTHRU"
              save_top = ztdtop
              rowid = save_top + 1
              "VPUT USRFIND"
              find_loop = null
              "TBSKIP NICK"table "ROW("ROWID")"
              parse value zcmd with x argument
              do forever
                 if pos(argument,search) > 0 then do
                    "TBTOP NICK"table
                    "TBSKIP NICK"table "ROW("ROWID")"
                    disp_panel = "row"
                        mailsmsg = "Found"
                        maillmsg = argument "found during search"
                        "Setmsg Msg(MAIL000)"
                    leave
                    end
                 "TBSKIP NICK"table "POSITION(SKIPROW) ROWID(ROWID)"
                 if rc > 0 then do
                       "TBTOP NICK"table
                    if find_loop = "on" then do
                        mailsmsg = "Not Found"
                        maillmsg = argument "Not found during search"
                        "Setmsg Msg(MAIL000)"
                        rowid = save_top
                        "TBTOP NICK"table
                        "TBSKIP NICK"table "ROW("ROWID")"
                        disp_panel = "row"
                        leave
                        end
                        else find_loop = "on"
                    end
                 zsel = null
                 end
              end

           upper zsel
           select
             when zsel = "I" then do
                  parse value null with nickname node userid name,
                              address1 address2 address3 address4,
                              internet
                  zcmd = null
                  "DISPLAY PANEL(TMNIKT1A)"
                  if rc = 0 then do
                     "TBADD NICK"table "ORDER"
                     if rc = 0 then
                        change_nick = "on"
                        else do
                             mailsmsg = "Error"
                             maillmsg = "Error adding duplicate nickname
                             nickname"' to the table"
                             "Setmsg Msg(MAIL000)"
                             end
                     end
                  end
             when zsel = "N" then do
                  "Select CMD(%TMAILSND" nickname ")"
                  end
             when zsel = "S" then do
                  zcmd = null
                  if left(node,6) = "*List*"
                     then "Display Panel(TMNIKT1B)"
                     else "DISPLAY PANEL(TMNIKT1A)"
                  if rc = 0 then do
                     "TBMOD NICK"table "ORDER"
                     change_nick = "on"
                     end
                  end
             when zsel = "D" then do
                  if left(node,6) = "*List*" then do
                     mailsmsg = "Error"
                     maillmsg = "Cannot delete list entry from this opti
                     "Setmsg Msg(MAIL000)"
                     end
                     else do
                          "TBDELETE NICK"table
                          change_nick = "on"
                          end
                  end
             otherwise nop;
             end
        end
        if change_nick = "on" then do
          mailsmsg = null
       maillmsg = "Warning: Issue '4' to save your changes or they will
          "Setmsg Msg(MAIL000)"
          end
        return

        Save_it:
        /* ----------------------------------------------
           Save the current nick name data set
           ---------------------------------------------- */
            "TBTOP NICK"table
            "TBTOP LIST"table
            "TBTOP CTRL"table
            out. = null
            out.0 = 0
            if type = "Primary" then do forever
              "TBSKIP CTRL"table
              if rc > 0 then leave
                if length(option) > 0 then do
                  c = out.0 + 1
                  out.c = option""value
                  out.0 = c
                end
            end
            do forever
              "TBSKIP NICK"table
              if rc > 0 then leave
              if "*List*" = left(node,6) then iterate
              c = out.0 + 1
              out.c = ":Nick."left(nickname,8) ":Node."left(node,8),
                      ":Userid."left(userid,8) ":Name."name
              out.0 = c
              if length(internet) > 0 then do
                c = out.0 + 1
                out.c = ":Internet."internet
                out.0 = c
                end
              if length(phone) > 0 then do
                c = out.0 + 1
                out.c = ":Phone."phone
                out.0 = c
                end
              if length(address1) > 0 then do
                c = out.0 + 1
                out.c = ":Address1."address1
                out.0 = c
                end
              if length(address2) > 0 then do
                c = out.0 + 1
                out.c = ":Address2."address2
                out.0 = c
                end
              if length(address3) > 0 then do
                c = out.0 + 1
                out.c = ":Address3."address3
                out.0 = c
                end
              if length(address4) > 0 then do
                c = out.0 + 1
                out.c = ":Address4."address4
                out.0 = c
                end
            end
            do forever
              "TBSKIP LIST"table
              if rc > 0 then leave
              c = out.0 + 1
              if words(list) > 7 then do
                 out.c = ":Nick."left(nickname,8)
                 c = c + 1
                 out.c = ":List."subword(list,1,7)
                 out.0 = c
                 do cx = 8 to words(list) by 7
                    c = c + 1
                    out.c = ":List."subword(list,cx,7)
                    out.0 = c
                    end
                 end
                 else do
                      out.c = ":Nick."left(nickname,7)
                      c = c + 1
                      out.c = ":List."list
                      end
              out.0 = c
            end
            Address TSO
            "Alloc f("dd_name") ds("names_file") SHR REUSE"
            "Execio * diskw" dd_name "(finis stem out."
            "Free F("dd_name")"
             Address ISPEXEC
             mailsmsg = "Saved"
             maillmsg = names_file" has been saved..............."
             Address ISPEXEC "SETMSG MSG(MAIL000)"
        return

        Read_it:
        /* ----------------------------------------------
           Read in the nick name data set and prepare for
           processing:
           ---------------------------------------------- */
        in. = null
        "Alloc f("dd_name") ds("names_file") SHR REUSE"
        "Execio * diskr" dd_name "(finis stem in."
        "Free F("dd_name")"

        if type = "Primary" then do
           /* --------------------------------------------------------
              Determine which nick name library the user wishes to
              process.
              -------------------------------------------------------- *

        parse value null with prim alt1 alt2 alt3 alt4 alt5 alt6 alt7 al
           parse value null with zp z1 z2 z3 z4 z5 z6 z7 z8 z9

           c = 0
           prim = names_file

           do i = 1 to in.0
              in_u.i = in.i
              upper in_u.i
              if pos(":ALTCTL.",in_u.i) > 0 then do
                 parse value in_u.i with ":ALTCTL." val .
                 c = c + 1
                 vu = strip(val)
                 interpret "alt"c "=" "'''"vu"'''"
                 end
           end
         end
        return


        Init_all:
        /* ----------------------------------------------
           Perform the initializations of all the common
           variables used in this REXX procedure.
           ---------------------------------------------- */
        if type = "Primary" then do
           altctl. = null
           altctl.0 = 0
           logsel = null
           logname = null
           prolog. = null
           epilog. = null
           prolog.0 = 0
           epilog.0 = 0
           end
        nick. = null
        name. = null
        node. = null
        list. = null
        userid. = null
        phone. = null
        address1. = null
        address2. = null
        address3. = null
        address4. = null
        internet. = null
        other. = null
        nick.0 = 0
        have_nick = "off"
        return
./ ADD NAME=TMAILPTF 0120-90186-93153-0647-00119-00025-00000-$A1238
        /* ---------------------  rexx procedure  ----------------------
        /* Name:      TMAILPTF
        /*
        /* Function:  Un-Terse Files from IBMLINK
        /*
        /*            Called by the TSOMAIL Rexx Procedure
        /*
        /* Syntax:    %TMAILPTF orig-dsn tsomail-dsn target-dsn
        /*
        /*            orig-dsn   Original DSn as deteremined by
        /*                       TSOMAIL during the RECEIVE process.
        /*            tsomail-dsn  This is the data set that TSOMAIL
        /*                       placed the data into during the
        /*                       RECEIVE.
        /*            target-dsn   This is optional and is the data set
        /*                       name into which the PTF will be
        /*                       untersed.
        /*
        /*            Defaults:
        /*            orig-dsn    -  none
        /*            tsomail-dsn -  none
        /*            target-dsn  -  userid.IBMLINK.xxxxxxxx
        /*                           where xxxxxxxx is the qualifier
        /*                           that immediately preceeds the
        /*                           ".SERVLINK" suffix of the
        /*                           orig-dsn.
        /*
        /* Author:    Lionel B. Dyck
        /*            Rockwell International
        /*            P.O. Box 2515
        /*            Seal Beach, California 90740
        /*            (213) 797-1125
        /*            IBMMAIL:  USROKNTN
        /*            IBMLINK:  ROK2027
        /*
        /* History:
        /*            02/27/92 - Lionel Dyck
        /*            Add variable 'vio' for VIO generic unit type
        /*
        /*            03/28/91 - Lionel Dyck
        /*            Remove DCB from output file allocation to allow
        /*            for FB and VB files to be untersed
        /*
        /*            01/08/91 - Lionel Dyck
        /*            Update to indicate called by TSOMAIL exec
        /*
        /*            07/09/90 - Lionel Dyck
        /*            Update to work with TMAILFIL exec
        /*
        /*            07/05/90 - Lionel Dyck
        /*            Creation of Rexx Procedure
        /*
        /* -------------------------------------------------------------

        arg mailfds mailtds targdsn

        if options = '' then exit 12

        parse value mailfds with "A." ptfname ".SERVLINK" c
        vio = "SYSVIO"

        x = msg("off")

        x = listdsi(mailtds)
        if syslrecl ^= 1024 then do
           parse value "" with ptferr1 ptferr2 ptferr3 ptferr4 ptferr5 p
                               ptferr7 ptferr8 ptferr9 ptferr10
              ptferr2 = "The requested File does not have the correct DC
              ptferr3 = "characteristics to be a tersed file."
              ptferr5 = "Browse the file to verify it's contents."
              ptferr6 = "Tersed files should be",
                        "DCB=(RECFM=F,LRECL=1024,BLKSIZE=1024*n)"
              ptferr7 = "otherwise it is not a valid terse",
                        "file for MVS Unterse."
              ptferr9 = "Original Data Set:" mailfds
              ptferr10 = "TSO Mail Data Set:" mailtds
              Address ISPEXEC "DISPLAY PANEL(TMAILPTE)"
              exit 0
              end

        "FREE F(SYSPRINT INFILE OUTFILE)"

        "ALLOC F(SYSPRINT) UNIT("vio") SPACE(1,1) TRACKS REUSE"

        parse value mailfds with "A." ptfname ".SERVLINK" waste

        if targdsn = "" then targdsn = "IBMLINK."ptfname

        "DEL" targdsn

        "ALLOC F(OUTFILE) DS("targdsn") NEW SPACE(30,30) TRACKS REUSE"

        "ALLOC F(INFILE) DS("mailtds") SHR"

        "CALL 'AISC.VENDOR.LOAD(TRSUNPCK)' 'UNPACK'"

        lc = rc

        if rc ^= 0 then do
           out. = ""
           "EXECIO * DISKR SYSPRINT (FINIS STEM out."
           parse value "" with ptferr1 ptferr2 ptferr3 ptferr4 ptferr5 p
                               ptferr7 ptferr8 ptferr9 ptferr10
              ptferr1  = out.1
              ptferr2  = out.2
              ptferr3  = out.3
              ptferr4  = out.4
              ptferr5  = out.5
              ptferr6  = out.6
              ptferr7  = out.7
              ptferr8  = out.8
              ptferr9  = out.9
              ptferr10 = out.10
              Address ISPEXEC "DISPLAY PANEL(TMAILPTE)"
              end
              else Address ISPEXEC "DISPLAY PANEL(TMAILPTF)"

        "FREE F(SYSPRINT INFILE OUTFILE)"
        "ALLOC F(SYSPRINT) DS(*)"
./ ADD NAME=TMAILSAF 0119-90121-93217-0947-00345-00046-00000-$A1238
        /* --------------------  rexx procedure  --------------------  *
         * Name:       TMAILSAF                                        *
         *                                                             *
         * Function:   This is the driver exec for processing the      *
         *             SAFE Mail functions:                            *
         *                                                             *
         *             - If the READ option is specified then TSO      *
         *               RECEIVE command will be processed to          *
         *               receive any mail sent to this userid and      *
         *               "SAFEMAIL ADD/DELETE" messages will be        *
         *               scanned for and processed.  No files are      *
         *               allowed to be sent to this userid.            *
         *                                                             *
         *               This option will also perform the SAFE        *
         *               function.                                     *
         *                                                             *
         *             - If the SAFE option is specified then TSO      *
         *               Mail Safe Mail Userid data set is read and    *
         *               the TSOMAIL exec is processed using the       *
         *               SAFE option for every userid specified.       *
         *                                                             *
         *               During this process the user's mail will      *
         *               be received and recorded in the user's        *
         *               TSO Mail log (userid.TSOMAIL.LOG) and         *
         *               files are received into unique data sets      *
         *               with date and time stamps.  The TSO Mail      *
         *               Table data set will not be updated at this    *
         *               time.                                         *
         *                                                             *
         * Process Notes:                                              *
         *                                                             *
         *             1.  Messages may be sent to the SAFEMAIL userid *
         *                 by the user to have their userid added      *
         *                 and/or removed from SAFEMAIL processing.    *
         *                 The messages are of the format within the   *
         *                 TSO Transmit message and may be in any      *
         *                 column.                                     *
         *                                                             *
         *                 SAFEMAIL: ADD userid                        *
         *                 SAFEMAIL: DELETE userid                     *
         *                                                             *
         *             2.  It is assumed that the normal process will  *
         *                 be to run the SAFEMAIL started task at      *
         *                 least once per day with the following       *
         *                 commands:                                   *
         *                                                             *
         *                 TMAILSAF READ                               *
         *                 TMAILSAF SAFE                               *
         *                                                             *
         *             3.  The SAFEMAIL userid data set is of the      *
         *                 format:                                     *
         *                                                             *
         *                 column  contents                            *
         *                 1-8     Userid                              *
         *                                                             *
         *                 RECFM=FB,LRECL=80,BLKSIZE=80*n              *
         *                                                             *
         *                 Comments have an * is column 1.             *
         *                                                             *
         * Syntax:     TMAILSAF Option (userids)                       *
         *                                                             *
         *             Valid Options:                                  *
         *                                                             *
         *                   READ                                      *
         *                   SAFE                                      *
         *                                                             *
         * Diagnostic Note:  DEBUG can be specified as a parameter     *
         *             with any option and it will enable REXX         *
         *             tracing to help identify problems with this     *
         *             exec.                                           *
         *                                                             *
         * Additional Notes:                                           *
         *                                                             *
         *        This REXX procedure should be processed at least     *
         *        once per day by a started task with the name of      *
         *        SAFEMAIL and thus a userid of SAFEMAIL.  It should   *
         *        be non-cancellable so that it can update data sets   *
         *        owned by other users.  The data set that it will     *
         *        be updating is the user's userid.TSOMAIL.LOG.        *
         *        This exec must also be able to read the user's       *
         *        userid.NAMES.TEXT if one exists.                     *
         *                                                             *
         *        The READ process WILL use a userid of SAFEMAIL       *
         *        on the RECEIVE command.                              *
         *                                                             *
         *        During the processing of this REXX procedure it      *
         *        will issue status messages indicating where it is    *
         *        in it's process.  These messages are written to      *
         *        the SYSTSPRT output data set which is normally       *
         *        defined as SYSOUT.  I suggest that this SYSOUT       *
         *        data be written to a SYSOUT class defined as hold    *
         *        for TSO to allow someone (probably the TSO           *
         *        administrator) to view it using a spool viewing      *
         *        utility.                                             *
         *                                                             *
         * Author:     Lionel B. Dyck                                  *
         *             Rockwell International                          *
         *             P.O. Box 2515                                   *
         *             Seal Beach, California 90740                    *
         *             (310) 797-1125                                  *
         *             IBMLINK:  ROK2027                               *
         *                                                             *
         * History:                                                    *
         *             08/04/93 - Lionel Dyck                          *
         *                      - add use of TMAILQRY                  *
         *             09/25/91 - Lionel Dyck                          *
         *                      - remove SHOWTSO and index for cds     *
         *             05/01/90 - Lionel Dyck                          *
         *                      - Creation of this exec                *
         *             05/02/90 - Lionel Dyck                          *
         *                      - cleanup and improve doc              *
         *             06/11/90 - Lionel Dyck                          *
         *                      - Fix receive for userid of SAFEMAIL   *
         *                        for logdsn                           *
         *             06/20/90 - Lionel Dyck                          *
         *                      - change initialization of ?.0 = 0     *
         *                        to ?. = 0 for speed                  *
         *                                                             *
         * ----------------------------------------------------------  *

        arg option parms

        if wordpos("DEBUG",parms,1) > 0 then do
           trace i
          n = wordpos("DEBUG",parms,1)
           y = delword(parms,n,5)  /* remove the word debug */
           parms = y /* reset parms without the word debug in it */
           end

        /* ----------------------------------------------------------  *
         * This is the control data set name to be used ************** *
         * ----------------------------------------------------------  *

        safedsn = "'AISC.SAFEMAIL.CDS'"

        x = msg("OFF")

        if sysdsn(safedsn) <> "OK" then do
           say date("U") time(),
               "Error encountered in locating the SAFE Mail Control Data
           say date("U") time(),
               "SAFE Mail procedure terminating - contact your TSO Coord
           exit  8
           end
           else "ALLOC F(SAFEMAIL) SHR REUSE DS("safedsn")"
        if rc > 0 then do
           say date("U") time(),
               "SAFEMAIL Processing is terminating because of an allocat
               "failure for the"
           say date("U") time(),
               "SAFE Mail Control Data Set:" safedsn
           exit 12
           end

        x = msg("ON")

        /* -------------------------------------------------------- *
         *                                                          *
         * Option: READ                                             *
         *                                                          *
         * Logic:                                                   *
         *                                                          *
         * 1.  Issue the TSO RECEIVE Command.                       *
         *                                                          *
         * 2.  Loop thru the captured output looking for SAFEMAIL:  *
         *     which will indicate that we have a userid to add or  *
         *     to DELETE from the Safe Mail Control Data Set.       *
         *                                                          *
         * 3.  If found then update appropriate variables.          *
         *                                                          *
         * 4.  Invoke the CDS Update routine if any updates are     *
         *     to occur.                                            *
         *                                                          *
         * 5.  Set the option to SAFE and perform SAFE Mail         *
         *     processing now.                                      *
         *                                                          *
         * -------------------------------------------------------- */

        if option = "READ" then do

        say date("U") time() "Starting the SAFEMAIL READ Processing"

        option = "SAFE"
        index  = "AISC"

        x = OUTTRAP("output.",'*',"CONCAT")

        "RECEIVE USERID(SAFEMAIL) LOGDSNAME('"index".LOG.DATA')"

        /* delete the log data set as it is not required or wanted */
        "DELETE '"index".LOG.DATA'"

        x = OUTTRAP('OFF')

        add.     =
        add.0    = 0
        delete.  =
        delete.0 = 0

        do i = 1 to output.0
           upper output.i
           if word(output.i,1) = "SAFEMAIL:" then do
               opt = word(output.i,2)
               uid = word(output.i,3)
               if opt = "ADD" then do
                         add.0 = add.0 + 1
                         x = add.0
                         add.x = uid
                         update = "yes"
                         end
               if opt = "DELETE" then do
                         delete.0 = delete.0 + 1
                         x = delete.0
                         delete.x = uid
                         update = "yes"
                         end
               end
           end

        say date("U") time() "Beginning update of the SAFEMAIL CDS" safe

        if update = "yes" then do
           nsafe.   =
           nsafe.0  = 0
              "EXECIO * DISKR SAFEMAIL (FINIS STEM safe."

              do i = 1 to safe.0

                      do d = 1 to delete.0
                           if substr(safe.i,1,8) = delete.d then do
                              safe.i = ""
                              say date("U") time(),
                                  "Userid" delete.d "deleted from SAFEMA
                              end    /* end of compare */
                           end       /* end of delete scan */

                           if safe.i <> "" then do
                               nsafe.0 = nsafe.0 + 1
                               idc = nsafe.0
                               nsafe.idc = safe.i
                               end

               end   /* end of safe.0 loop */

                      do a = 1 to add.0
                           nsafe.0 = nsafe.0 + 1
                           idc = nsafe.0
                           nsafe.idc = add.a
                           say date("U") time(),
                               "Userid" add.a "added to SAFEMAIL"
                         end

             "EXECIO * DISKW SAFEMAIL (FINIS STEM nsafe."

        say date("U") time() "Completed update of the SAFEMAIL CDS:" saf
        end

        /* -------------------------------------------------------- *
         *                                                          *
         * Option:  SAFE                                            *
         *                                                          *
         * Logic:                                                   *
         *                                                          *
         * 1.  Read the SAFE Mail control data set.                 *
         * 2.  Determine if the user is currently logged on         *
         *     and skip SAFE processing if they are.                *
         *     otherwise;                                           *
         * 3.  For every userid invoke the TMAILQRY and if there    *
         *     is mail then                                         *
         * 4.  For every userid invoke the TSOMAIL exec with        *
         *     the SAFE option.                                     *
         *                                                          *
         * -------------------------------------------------------- */

        if option = "SAFE" then do
        pid = 0  /* initialize our counter */
        say date("U") time() "Beginning SAFEMAIL SAFE Processing"
           "EXECIO * DISKR SAFEMAIL (FINIS STEM safe."
           do idc = 1 to safe.0
              if substr(safe.idc,1,1) <> "*" then do
                 uid = strip(substr(safe.idc,1,8),)
                 call testid
                 if exec <> "on" then do
                    say date("U") time() "Invoking TSOMAIL for user:" ui
                    "%TSOMAIL SAFE USERID("uid")"
                    say date("U") time() "Completed TSOMAIL for user:" u
                    pid = pid + 1
                                      end
                 else if tmq = 0 then do
                    say date("U") time(),
                        "TSOMAIL Processing bypassed for user:",
                         uid "because the user is currently logged on"
                      end
                 end
              end
        say date("U") time() "SAFEMAIL SAFE Processing Completed for",
            pid "users"
        end

        Exitsafe:
           x = msg("OFF")
           "FREE F(SAFEMAIL)"
           exit 0

        /* -------------------------------------------------------- *
         *                                                          *
         * TESTID subroutine                                        *
         *                                                          *
         * Purpose:  The purpose of this routine is to test the     *
         *           status of the userid passed in variable uid    *
         *           and return the status in variable exec.        *
         *                                                          *
         * -------------------------------------------------------- */
        Testid:

        tmq = 0
        "TMAILQRY" uid
        if rc = 4 then do
           say date("U") time() "Userid" uid ,
               "has no mail to be received at this time"
           exec = "on"
           tmq  = 1
           return
           end

        x = OUTTRAP("output.",'*',"CONCAT")

        "ST" uid

        x = OUTTRAP('OFF')

        opt = "JOB" uid

        exec = "off"

        do i = 1 to output.0
           if  pos(opt,output.i,1) > 0 then do
              x = pos("EXECUTING+",output.i,1)
              if x = 0 then iterate
              exec = "on"
              leave
           end
        end

        return exec
./ ADD NAME=TMAILSM  0106-90122-93085-0657-00049-00041-00000-$A1238
        /* --------------------  rexx procedure  --------------------  *
        /* Name:      TMAILSM                                          *
        /*                                                             *
        /* Function:  Registration Dialog for the TSO/E Safe Mail      *
        /*            function.                                        *
        /*                                                             *
        /*                                                             *
        /* Author:    Lionel B. Dyck                                   *
        /*            Rockwell International                           *
        /*            P.O. Box 2515                                    *
        /*            Seal Beach, California 90740                     *
        /*            (310) 797-1125                                   *
        /*            IBMLINK:  ROK2027                                *
        /*                                                             *
        /* History:   05/02/90 - Lionel Dyck                           *
        /*            Creation of this exec                            *
        /*                                                             *
        /* ----------------------------------------------------------  *

        arg opt

        if opt = "DEBUG" then trace i

        unit = "SYSVIO"            /* Rockwell unique */
        "SHOWTSO CENTER"           /* Rockwell unique */

        Address ISPEXEC "DISPLAY PANEL(TMAILSM)"
        if rc > 4 then exit

        "ALLOC F(SAFEMAIL) UNIT("unit") SPACE(1) TRACKS RECFM(F) LRECL(8

        msg.1 = "SAFEMAIL:" opt userid

        "EXECIO 1 DISKW SAFEMAIL (FINIS STEM msg."

        /*  trap transmit messages so user does not see them  */
        if opt <> "DEBUG" then
           x = OUTTRAP("output.",'*',"CONCAT")

        "XMIT" center".SAFEMAIL MSGDD(SAFEMAIL) NOLOG NONOTIFY",
               "NOPROLOG NOEPILOG"

        "FREE F(SAFEMAIL)"

        mailsmsg = "Registered"
        if opt = "ADD" then opt = "registered with"
                       else opt = "withdrawn from"
        maillmsg = "Your userid ("userid") has been" opt "the SAFEMAIL s
        Address ISPEXEC "SETMSG MSG(MAIL000)"
./ ADD NAME=TMAILSND 0133-92351-93224-0444-01020-00961-00000-$A1238
        /* ---------------------  rexx procedure  ----------------------
         * Name:      TMAILSND
         *
         * Function:  Transmit messages and files to TSO and non-TSO
         *            systems.
         *
         *            When directed to TSO systems then TSO TRANSMIT
         *            is used.
         *
         *            If non-TSO then the TSO/E PRINTDS command
         *            is used with DEST(node.userid) SYSOUT(B)
         *            NOTITLE specified.
         *
         *            If sending a message data set that exceeds 80
         *            bytes the transmission will occur sending the
         *            message data set as a file as the TSO/E Transmit
         *            command will not accept any MSGDS with greater
         *            than LRECL=80.  Messages of this type will be
         *            sent to VM/PROFS as files as I can find no other
         *            means to do this process.
         *
         * Syntax:    %TMAILSND target-user-id(s) options
         *
         *            valid options:
         *
         *            DA(data-set-name) or
         *            DS(data-set-name) or
         *            DSN(data-set-name) or
         *            FILE(data-set-name)
         *
         *            DEBUG   - enable REXX tracing
         *
         *            NOMSG    - indicate sending file and no message
         *            SENDFILE - sending only a file, no message
         *
         *            MSG(dsn) - used to forward dsn as a message
         *            SEQ      - send PDS member as sequential d/s
         *
         *            MLOG     - Log the transmission
         *            MACK     - Request acknowledgement on receipt
         *
         *
         * Author:    Lionel B. Dyck
         *            Rockwell International
         *            P.O. Box 2515
         *            Seal Beach, California 90740
         *            (310) 797-1125
         *            IBMLINK:  ROK2027
         *            Internet: LBDyck@OSREQ48.Rockwell.Com
         *
         * Local Dependencies:
         *
         *   Variables to change based upon your local environment:
         *
         *   tso_nodes should contain a list of nje nodes that are
         *             mvs/tso and thus will receive mail using the
         *             tso transmit command
         *
         *   vio       defines the esoteric device name for temporary
         *             work data used in this exec
         *
         *   use_sdb   Yes to use system determined blksize or
         *             anything else to use a pre-defined blksize
         *
         *   smtpnode  the name of the nje node where the smtp address
         *             space is running
         *
         *   smtpjob   the name of the smtp job name
         *
         *   center    must be the name of the currently active nje
         *             node on which this exec is running.  This is
         *             set in this exec using the SHOWTSO command.
         *
         * History:
         *            08/11/93 - fix for forward when lrecl < 80
         *
         *            07/01/93 - minor bug fix for null variable
         *
         *            06/30/93 - Add test to issue an error if an
         *                       attempt is made to send a PDS as a
         *                       message.
         *
         *            06/22/93 - Fix for Profs note (to recfm=F)
         *
         *            06/14/93 - Change for sending files to vm/ip
         *
         *            02/17/93 - fix for fwd flag test.
         *
         *            02/05/93 - fix for :list. processing from Paul
         *                       Crossland of Xerox.
         *                     - fix for new mail forward option
         *
         *            12/16/92 - Add support for ABMKE2 for non-smtp
         *
         *            11/25/92 - Add support for x.400 via IBMMAIL using
         *                       vm-smtp at node inet.
         *
         *            10/20/92 - eliminate any duplicate addresses if
         *                       specified
         *
         *            10/19/92 - bug fix introduced by 10/15
         *
         *            10/15/92 - general cleanup
         *
         *            09/14/92 - add ABMKE2 (Allen-Bradley) to tsonodes
         *
         *            09/04/92 - Increased size of vio secondary
         *                       Set variable for System Determined
         *                       Blocksize (use_sdb)
         *
         *            07/20/92 - Add IBMMAIL as a TSO type node
         *
         *            06/12/92 - Fix for SMTP message if lrecl>80
         *
         *            06/10/92 - Fix for SWCC smtpnode
         *
         *            06/01/92 - Fix for CANCEL
         *
         *            05/19/92 - Fix for sendfile only
         *
         *            05/11/92 - Set vio variable
         *                       Define permanent Edit profile
         *                       Support forwarding SMTP (long) messages
         *
         *            04/21/92 - Fixes for RFC822 Headers
         *
         *            04/16/92 - Fix TNAMES 'bug'
         *                       fix multi-line :LIST.
         *
         *            02/27/92 - Cleanup for SMTP support
         *
         *            02/14/92 - Add SMTP support (aka Internet)
         *
         *            01/07/92 - Updated to support log and ack options
         *
         *            05/02/91 - Fix to PROFS Message header for date to
         *                       have 2 digit day.
         *
         *            05/01/91 - Fix to prevent duplicate logging when
         *                       sending to both TSO and VM
         *
         *            03/14/91 - Fix to test for existence of a member
         *                       in a sending data set.
         *
         *            09/12/90 - Correction if the user does not have
         *                       a userid.NAMES.TEXT data set to
         *                       allocate one.
         *
         *            09/11/90 - Correction for non-PROFS node to not
         *                       use PRintds instead to directly
         *                       allocate the sysout(b) and use EXECIO.
         *
         *            08/29/90 - Rewrite of REXX procedure
         *
         * -------------------------------------------------------------
         *            Rexx exec to transmit messages and files
         *            based upon TSO CLIST IDTFXMIT developed
         *            by Mike Theys
         * -------------------------------------------------------------

        parse arg w1

        Address ISPEXEC "CONTROL ERRORS RETURN"
        Address ISPEXEC "VGET (ZAPPLID SENDCTR)"

        if zapplid <> "MAIL" then do
           cmd = sysvar(sysicmd)
           Address ISPEXEC "SELECT CMD(%"cmd w1") NEWAPPL(MAIL)"
           call exit_here 0
        end

        "SHOWTSO CENTER"

        /* set tso node defaults */
        tso_nodes = "WCC1 WCC2 WCC3 WCC6 SWCC SWC2 SWC4 RSOC1"
        tso_nodes = tso_nodes "SWC31 SWC32 CGAD GSD1 GSD2 GSD3"
        tso_nodes = tso_nodes "ABMKE2"

        /* set vio device type */
        vio = "SYSVIO"

        /* set System Determined Blksize */
        use_sdb = "yes"

        /* --------- SMTP Defaults  --------- */
        smtpnode = center
        smtpjob  = "SMTP"
        select
          when smtpnode = "WCC1" then
               smtphost = "WCC1A.Rockwell.Com"
          when smtpnode = "SWCC" then
               smtphost = "SWC1.Rockwell.Com"
          otherwise  smtphost = smtpnode".Rockwell.Com"
          end
        /* ---------------------------------- */

        pl = pos("(",w1)
        pr = pos(")",w1)
        if pl = 1 then do
           wx = overlay(" ",w1,pl)
           w1 = overlay(" ",wx,pr)
           do until p1 = 0
                p1 = pos(',',w1)
                if p1 > 1 & p1 < pr then do
                   pw = overlay(" ",w1,p1)
                   w1 = pw
                end
           end
        end

        if length(sendctr) = 0 then
           Address ISPEXEC "SELECT CMD(%TMAILDEF) NEWAPPL(MAIL)"

        xw = w1
        upper xw
        erc = 0

        if length(w1) > 0 then do
             n = words(xw) /* retrieve number of words in the input */
             x = word(xw,n) /* get the last word */
             if x = "DEBUG" then do
                trace i
                y = delword(w1,n,5)  /* remove the word debug */
                w1 = y /* reset w1 without the word debug in it */
             end
        end

        /* set values to null to start with */
        parse value "" with msgdsn filedsn msg1 msg2 outdd null

        x = wordpos("SENDFILE",xw)
        if x > 0 then do
                      sendpanl = "TMAILSFL"
                      wx = delword(w1,x,8)  /* remove SENDFILE */
                      w1 = wx
                      end
                 else sendpanl = "TMAILSND"

        x = wordpos("NOMSG",xw)
        if x > 0 then do
                      nomsg = "on"
                      wx = delword(w1,x,5)
                      w1 = wx
                      end
                 else nomsg = "off"

        x = wordpos("MLOG",xw)
        if x > 0 then do
                      log = "Y"
                      wx = delword(w1,x,5)
                      w1 = wx
                      end
                 else log  = "N"

        x = wordpos("MACK",xw)
        if x > 0 then do
                      ack = "Y"
                      wx = delword(w1,x,5)
                      w1 = wx
                      end
                 else ack  = "N"

        x = wordpos("SEQ",xw)
        if x > 0 then do
                      seq = "SEQ"
                      wx = delword(w1,x,3)
                      w1 = wx
                      end
                 else seq = null

        x = pos("MSG(",xw)
        if x > 0 then do
            y = substr(xw,x) /* truncate to put msg(..) as 1st word */
            y = word(y,1) /* retrieve first word */
            msgdsn = substr(y,5,length(y)-5)
            wx = overlay(" ",w1,x,length(y)," ")
            w1 = wx
        end

        x = pos("DS(",xw)
        if x > 0 then do
            y = substr(xw,x) /* truncate to put ds(..) as 1st word */
            y = word(y,1) /* retrieve first word */
            filedsn = substr(y,4,length(y)-4)
            wx = overlay(" ",w1,x,length(y)," ")
            w1 = wx
        end

        x = pos("DSN(",xw)
        if x > 0 then do
            y = substr(xw,x) /* truncate to put dsn(..) as 1st word */
            y = word(y,1) /* retrieve first word */
            filedsn = substr(y,4,length(y)-4)
            wx = overlay(" ",w1,x,length(y)," ")
            w1 = wx
        end

        x = pos("DA(",xw)
        if x > 0 then do
            y = substr(xw,x) /* truncate to put ds(..) as 1st word */
            y = word(y,1) /* retrieve first word */
            filedsn = substr(y,4,length(y)-4)
            wx = overlay(" ",w1,x,length(y)," ")
            w1 = wx
        end

        x = pos("FILE(",xw)
        if x > 0 then do
            y = substr(xw,x) /* truncate to put file(..) as 1st word */
            y = word(y,1) /* retrieve first word */
            filedsn = substr(y,6,length(y)-6)
            wx = overlay(" ",w1,x,length(y)," ")
            w1 = wx
        end

        if length(filedsn) > 0 then do
        x = listdsi(filedsn)
        if sysreason > 0 then do
                    mailsmsg = "Error"
                    maillmsg = "Requested data set" filedsn "does not ex
                    Address ISPEXEC "SETMSG MSG(MAIL000)"
                    call exit_here 4
                    end
        if sysdsorg = "PO" then do
           wx = sysdsn(filedsn)
              if wx <> "OK" then do
                       mailsmsg = "Error"
                       maillmsg = "Requested data set" filedsn wx
                       Address ISPEXEC "SETMSG MSG(MAIL000)"
                       call exit_here 4
                       end
                    end
        if sysdsorg = "PS" & seq = "SEQ" then seq = null
                              end
                              else seq = null

        sendid = strip(w1)
        upper sendid

        Address ISPEXEC "VGET (ZSCREEN)"

        if length(sendid) = 0 then call noid

        if nomsg = "off" then do
        /* generate a unique dd name based on the current ispf screen nu
            if length(msgdsn) > 0 then do
               call listdsi(msgdsn)
               if sysdsorg <> "PS" then
                  if pos("(",msgdsn) = 0 then do
                     mailsmsg = null
                     maillmsg = "Unable to send a PDS as a message." ,
                                "Specified message dsn is:" msgdsn
                     Address ISPEXEC "SETMSG MSG(MAIL000)"
                     exit 4
                     end
               if length(sysrecfm) > 1 then do
                  recfm = substr(sysrecfm,1,1)" "substr(sysrecfm,2,1),
                          substr(sysrecfm,3,3)
                  dcb = dcb "Recfm("strip(recfm)")"
                  sysrecfm = recfm
                  end
               end
               else
                  syslrecl = 0

            if left(sysrecfm,1) = "V" then
               if syslrecl < 84 then
                  syslrecl = 0
            if syslrecl < 80 then
                  parse value "80 11440 F B" with syslrecl sysblksize sy

            dcb = "Lrecl("syslrecl") Blksize("sysblksize")",
                  "Recfm("strip(sysrecfm)")"

            if use_sdb = "yes" then sysblksize = 0

            xmitdd = "XMITMSG"zscreen
            "ALLOC FI("xmitdd") REUSE",
            "RECFM("sysrecfm") LRECL("syslrecl") BLKSIZE("sysblksize")",
            "DSORG(PS) SPACE(15 90) TRACK NEW KEEP UNIT("vio")"

        if length(msgdsn) > 0 then do
            msgdd = 'MSG'zscreen
            "ALLOC F("msgdd") SHR DS("msgdsn") REUSE"
            "EXECIO * DISKR " msgdd " (FINIS STEM msg."
            "EXECIO * DISKW " xmitdd " (FINIS STEM msg."
            "FREE F("msgdd")"
        end

        Address ISPEXEC "LMINIT DATAID(XMITED) DDNAME("xmitdd")"

        sendstmp = left(date('W'),3)',' left(date('n'),6) right(date('e'
                   time('n')
        Address ISPEXEC "VPUT (SENDSTMP,SENDID,SENDCTR) SHARED"
        Address ISPEXEC "VGET (SENDFRM1) PROFILE"

        if length(sendfrm1) = 0 then do
            Address ISPEXEC "SELECT CMD(%TMAILDEF)"
        end

        Address ISPEXEC "VGET (FWD SENDSUBJ)"

        save_fwd = fwd

        if length(msgdsn) = 0 then do
           fwd = null
           end

        if fwd <> "YES" then
                Address ISPEXEC,
               "EDIT DATAID("xmited") PANEL(TMAILEDT) MACRO(TMAILEDM)",
               "PROFILE(TSOMAIL)"
             else
                Address ISPEXEC,
                 "EDIT DATAID("xmited") PANEL(TMAILEDT) MACRO(TMAILEDM)"
                 "PROFILE(TSOMAIL)"
           Address ISPEXEC "VGET (MAILEND)"
           if mailend = "CANCEL" then rc = 4

           fwd = save_fwd

        edrc = rc
        erc = edrc
        if erc = 4 then call exit_here 4
        end /* end of processing for building the message */
        else do
             call redo
             Address ISPEXEC "SETMSG MSG(MAIL000)"
             if datatype(erc) <> "NUM" then erc = 0
             call exit_here erc
             end

        if edrc = 0 then do
            x = PROMPT("OFF")
            x = MSG("ON")
            /* Add on the subject and date/time stamp */
            Address ISPEXEC,
              "EDIT DATAID("xmited") MACRO(TMAILEDX)",
                 "PROFILE(TSOMAIL)"
            xerc = rc /* XERC=4 NOTHING SAVED */
            if xerc = 0 then call redo
        else do
            mailsmsg = "No message"
            maillmsg = "No Transmit message for" sendid". Transmit abort
            erc = 4
            edrc = 4
        end
        end
        else if edrc = 4 then do /* nothing saved. xmit msg cancelled */
            mailsmsg = "Message cancelled"
            maillmsg = "The Transmit message to" sendid "was aborted."
            erc = 4
            end
        else do
        mailsmsg = "Edit error"
        maillmsg = "An unexpected error occurred in Transmit Edit.",
            " Message cancelled."
            erc = 4
            end
        Address ISPEXEC "SETMSG MSG(MAIL000)"
        x = MSG("OFF")
        "FREE FI("xmitdd")"
        Address ISPEXEC "LMFREE DATAID("xmited")"
        /* end */
        if length(erc) = 0 then erc = 0
        call exit_here erc

        Noid:
             Address ISPEXEC "SELECT PANEL("sendpanl")"
             call exit_here erc

        REDO:
           x = outtrap("TRAP","*","NOCONCAT")
           if log = "N" then mlog = "NOLOG"
           else mlog = null
           if ack = "Y" then mack = NOTIFY
               else mack = "NONOTIFY"
           if nomsg = "off" then do
           call tmailnik sendid
           tmailnik_status = "on"
           if syslrecl > 80 then do
              tnick.tso = tnick.tso
              end
           xmrc = rc
           if xmrc > 0 then call cancel
             if length(tnick.tso) > 0 then do
                if syslrecl = 80 then
                "TRANSMIT ("tnick.tso") MSGDD("xmitdd") NOPROLOG NOEPILO
                             mlog mack
                else
                "TRANSMIT ("tnick.tso") FILE("xmitdd") NOPROLOG NOEPILOG
                             mlog mack
                /* prevent duplicate logging under VM */
                xmrc = rc
                if mlog = null then mlog = "NOLOG"
                end
             if length(tnick.smtp) > 0
                then do i = 1 to words(tnick.smtp)
                     smtpid = word(tnick.smtp,i)
                     Address ISPEXEC "VPUT (SMTPID SMTPHOST) SHARED"
                     Address ISPEXEC,
                      "EDIT DATAID("xmited") MACRO(TMAILESM)",
                      "PROFILE(TSOMAIL)"
                      call sendtovm xmitdd smtpnode"."smtpjob  syslrecl,
                           sysblksize sysrecfm
                     xmrc = rc
                     if mlog = null then mlog = "NOLOG"
                     end
             if length(tnick.inet) > 0
                then do i = 1 to words(tnick.inet)
                     smtpid = word(tnick.inet,i)
                     Address ISPEXEC "VPUT (SMTPID SMTPHOST) SHARED"
                     Address ISPEXEC,
                      "EDIT DATAID("xmited") MACRO(TMAILESM)",
                      "PROFILE(TSOMAIL)"
                      if syslrecl > 80 then
                        "TRANSMIT INET.VM-SMTP FILE("xmitdd")",
                        "NOPROLOG NOEPILOG" mlog mack
                      else
                        "TRANSMIT INET.VM-SMTP MSGDD("xmitdd")",
                        "NOPROLOG NOEPILOG" mlog mack
                     xmrc = rc
                     if mlog = null then mlog = "NOLOG"
                     end
             if length(tnick.vm) > 0
                then do i = 1 to words(tnick.vm)
                     parse value word(tnick.vm,i) with tonode "." toid
                     Address ISPEXEC "VGET (TSOLOG) SHARED"
                     Address ISPEXEC "VPUT (ACK TONODE TOID SENDCTR) SHA
                     Address ISPEXEC,
                      "EDIT DATAID("xmited") MACRO(TMAILEPF)",
                      "PROFILE(TSOMAIL)"
                      call sendtovm xmitdd word(tnick.vm,i) syslrecl,
                           sysblksize sysrecfm
                     if mlog = null then call do_vmlog
                     /* prevent duplicate logging under VM */
                    if mlog = null then mlog = "NOLOG"
                     end
           msg1 = "Message"
           msg2  = "A TSO Mail message was sent to"
           erc = 0

                    end
                    else xmrc = 0
           if length(filedsn) > 0 then do
           if tmailnik_status <> "on" then
              call tmailnik sendid
           if rc > 0 then call cancel
              send_file = null
              if words(tnick.tso) > 0 then send_file = tnick.tso
              if words(tnick.vm)  > 0 then send_file = send_file tnick.v
              if words(send_file) > 0 then do
                 "TRANSMIT ("send_file") DS("filedsn")" mlog mack seq
                  if nomsg = "off" then msg1 = "Message and File"
                                   else msg1 = "File"
                  if nomsg = "off" then
                                   msg2 = "A TSO Mail message and data s
                                           filedsn
                                   else msg2 = "File" filedsn
              end
              if words(tnick.smtp) > 0 then
                 Address ISPEXEC "DISPLAY PANEL(TMAILSFE)"
           end
           x = outtrap("OFF")
           if xmrc = 0 then do
               mailsmsg = msg1 "sent"
               maillmsg = msg2 "sent to" sendid
           end
           else do
               mailsmsg = "Transmit error"
               maillmsg = "An unexpected error occurred in Transmit. RC=
               erc = 4
               if trap.0 > 0 then maillmsg = trap.1
               Address ISPEXEC "DISPLAY PANEL(TMAILRDO)"
               if rc = 0 THEN signal redo
           end
           filedsn = null
           return

        do_vmlog:
           if vm_log = "on" then return
           if sysdsn("'"tsolog"'") = "OK" then
              "ALLOC F(TSOLOG"zscreen") DS('"TSOLOG"') MOD"
              else
              "ALLOC F(TSOLOG"zscreen") DS('"TSOLOG"') NEW",
                 "SPACE(1,1) TRACKS RECFM(V B) LRECL(255) BLKSIZE(3120)"
            "EXECIO * DISKR" xmitdd "(FINIS STEM m."
               mv.0 = 4
               mv.1 = substr("-",1,79,"-")
               date = date()
               upper date
               if substr(date,2,1) = ' ' then date = '0'date
               mv.2 = left("TRANSMIT",16)left("**MESSAGE**",46)date time
               mv.3 = left(" TO:",16)left(tonode,8) toid
               mv.4 = " Specified users:" word(tnick.vm,1)
               do ivm = 2 to words(tnick.vm) by 2
                  mv.0 = mv.0 + 1
                  c = mv.0
                  mv.c = "                 " word(tnick.vm,ivm),
                         "      " word(tnick.vm,ivm+1)
                  end
               mv.0 = mv.0 + 1
               c = mv.0
               mv.c = "   "
            do ivm = 2 to m.0
               mv.0 = mv.0 + 1
               c = mv.0
               mv.c = m.ivm
               end
               mv.0 = mv.0 - 1  /* bypass Profs trailer record */
            "EXECIO" mv.0 "DISKW TSOLOG"zscreen "(FINIS STEM mv."
            "FREE F(TSOLOG"zscreen")"
            vm_log = "on"
            return

        cancel:
            mailsmsg = "Message cancelled"
            maillmsg = "The Transmit message to" sendid "was aborted."
            Address ISPEXEC "SETMSG MSG(MAIL000)"
            call exit_here 4

        tmailnik:
        /* ---------------------  rexx procedure  ----------------------
        /* Name:      TMAILTNIK
        /*
        /* Function:  Perform Nick Name validation for the TSO/E
        /*            Mail dialog.
        /*
        /* Syntax:   call tmailnik sendid
        /*
        /*           ISPF Panels used are:
        /*           TMAILNV
        /*
        /*           This rexx procedure is imbedded within
        /*           the TMAILSND REXX procedure.
        /*
        /* Author:    Lionel B. Dyck
        /*            Rockwell International
        /*            P.O. Box 2515
        /*            Seal Beach, California 90740
        /*            (310) 797-1125
        /*            IBMLINK:  ROK2027
        /*
        /* History:   08/29/90 - Creation of procedure
        /*
        /* -------------------------------------------------------------

        arg nick_names

        orig_names = nick_names

        start_over:

        w = words(nick_names)

        do i = 1 to w
           nick_in.i = word(nick_names,i)
           if pos("@",nick_in.i) = 0 then do
           if pos(".",nick_in.i) > 0 then do
              parse value nick_in.i with node "." userid
              if length(userid) > 8 then do
                 wl = length(userid)
                 wo = wordindex(nick_names,i)
                 new_nick = overlay(nick_in.i,nick_names,wo,wl)
                 nick_names = new_nick
                 nick_in.i = node"."left(userid,8)
                 end
              end
           else if length(nick_in.i) > 8
                   then do
                     if pos("@",nick_in.i) = 0 then do
                        userid = left(nick_in.i,8)
                        wl = length(nick_in.i)
                        wo = wordindex(nick_names,i)
                        new_nick = overlay(userid,nick_names,wo,wl)
                        nick_names = new_nick
                        nick_in.i = userid
                        end
                   end
           end
        end

        nick_in.0 = w

        call tstnick nick_names

        parse value null with inv. tnames
        parse value "0" with inv.0

        do i = 1 to tnick.0
           do j = 1 to nick_in.0
              if wordpos(nick_in.j,substr(tnick.i,1,20)) > 0
                 then do
                      call test_node
                      nick_in.j = null
                      tnick.i = null
                      end
              if left(tnick.i,1) = "*" then
                 if strip(substr(tnick.i,2,9)) = strip(nick_in.j)
                    then do
                    if left(tnick.i,2) <> "**" then do
                          nick_in.j = null
                          tnick.i   = null
                          end
                    end
              end
        end

        do i = 1 to tnick.0
           if length(tnick.i) > 0 then do
                       call test_node
                       tnick.i = null
                       end
           end

        do j = 1 to nick_in.0
           if nick_in.j <> null then
              call set_inv
              end

        do i = 1 to inv.0
           x = wordpos(inv.i,orig_names)
           w = delword(orig_names,x,1)
           orig_names = w
           tnames = tnames inv.i
           end

        if inv.0 > 0 then do
            Address ISPEXEC "DISPLAY PANEL(TMAILNV)"
              if rc > 4 then return 8
              nick_names = orig_names tnames
              orig_names = nick_names
              signal start_over
              end

        return tnick.

        /* -------------------------------------------------------------
        /*  This section will validate a node as either TSO or no-TSO If
        /*  a node is not in the list then the default is to set it to
        /*  VM.
        /* -------------------------------------------------------------
        test_node:
        /* first bypass nicknames/lists */
        if left(tnick.i,1) = "*" then
           if left(tnick.i,2) <> "**" then return

        /* test for internet addresses (@) */
        if pos("@",tnick.i) > 0 then call set_smtp
          else do  /* now check for tso or vm */
               if wordpos(word(tnick.i,2),tso_nodes) > 0 then call set_t
               else call set_vm
               end
        return

        set_inv:
           x = pos(".",nick_in.j)
           select
           when pos("@",nick_in.j) > 0 then do
                    tnick.0 = tnick.0 + 1
                    i = tnick.0
                    tnick.i = left("********",10) nick_in.j
                    call test_node
                    end
           when x = 0 then do
                    inv.0 = inv.0 + 1
                    c = inv.0
                    inv.c = nick_in.j
                    end
           when x > 0 then do
                    parse value nick_in.j with node "." userid
                    tnick.0 = tnick.0 + 1
                    i = tnick.0
                    tnick.i = left("********",10) left(node,10) userid
                    call test_node
                    end
           otherwise nop;
           end
        return

        set_tso:
           new_nick  =  word(tnick.i,2)"."word(tnick.i,3)
           if wordpos(new_nick,tnick.tso) > 0 then return
           tnick.tso = tnick.tso word(tnick.i,2)"."word(tnick.i,3)
           return

        set_vm:
           new_nick  =  word(tnick.i,2)"."word(tnick.i,3)
           if wordpos(new_nick,tnick.vm) > 0 then return
           tnick.vm  = tnick.vm  new_nick
           return

        set_smtp:
           new_nick = word(tnick.i,2)
           if left(new_nick,6) = "ABMKE2" then do
              tnick.tso = tnick.tso word(tnick.i,2)"."word(tnick.i,3)
              return
              end
           if pos('C=',word(tnick.i,2)) > 0 then do
              if wordpos(new_nick,tnick.inet) = 0 then
                 tnick.inet = tnick.inet new_nick
              end
           else do
                if wordpos(new_nick,tnick.smtp) = 0 then
                   tnick.smtp = tnick.smtp new_nick
                end
           return

        tstnick: procedure expose tnick.

        arg nick_names

        parse value "" with null

        nick.  = null
        nick.0 = 0
        tnick.  = null
        tnick.0 = 0

        nick_name.  = null
        nick_node.  = null
        nick_id.    = null
        nick_name.0 = 0

        logsel  = null
        logname = null

        /* -------------------------------------------------------------
        /*  Allocate a NAMES.TEXT for the user if they do not have one
        /*  as we will use it in the nick name management dialog.
        /* -------------------------------------------------------------
        if sysdsn("NAMES.TEXT") <> "OK" then do
           new_names_dd = "NN"random()
           "ALLOC DS(NAMES.TEXT) NEW SPACE(1,1) TRACKS RECFM(F B)",
                 "F("new_names_dd") BLKSIZE(6160)"
           "EXECIO 1 DISKW" new_names_dd "(FINIS STEM nick."
           "FREE F("new_names_dd")"
        end

        nick_file = sysvar(syspref)".NAMES.TEXT"
        signal get_nick

        nick_loop:
                do i = 1 to nick.0
                   name = strip(nick.i)
                   upper name
                   if logsel = null then do
                      if pos(":LOGSEL.",name) > 0 then do
                         parse value name with ":LOGSEL." logsel x
                         nick.i = null
                         end
                      end
                   if logname = null then do
                      if pos(":LOGNAME.",name) > 0 then do
                         parse value name with ":LOGNAME." logname x
                         nick.i = null
                         end
                      end
                   if left(name,8) = ":ALTCTL." then do
                          parse value name with ":ALTCTL." nick_file
                          nick.i = " "
                          signal get_nick
                          end
                 end

        if logsel  = null then logsel = "LOG"
        if logname = null then logname = "MISC"

        tsolog = sysvar(syspref)"."logsel"."logname
        Address ISPEXEC "VPUT (TSOLOG) SHARED"
        list_opt = 0

        one_more_time:
        i_count = 1

        do_it:
           if list_opt = 0 then do
              parse value null with do_nick do_node do_id
              end
              else list_opt = 0
        do i = i_count to nick.0
           temp = nick.i
           upper temp
           parse value temp with ":NICK." temp_name more
              if length(temp_name) > 0 then do
                 current_nick = temp_name
                 if length(do_nick) > 0 then do
                    if wordpos(do_nick,nick_names) = 0 then do
                          parse value null with do_nick do_node do_id
                          do_nick = word(temp_name,1)
                          end
                    else do
                         in = nick_name.0 + 1
                         nick_name.0 = in
                         nick_name.in = do_nick
                         nick_node.in = do_node
                         nick_id.in   = do_id
                         wi = wordindex(nick_names,wordpos(do_nick,nick_
                         wo = overlay(" ",nick_names,wi,length(do_nick))
                         nick_names = wo
                         if words(nick_names) = 0 then leave
                         parse value null with do_nick do_node do_id
                         end
                    end
                 do_nick = word(temp_name,1)
                 end
           parse value temp with ":NODE." temp_node more
             if length(temp_node) > 0 then do
                do_node = word(temp_node,1)
                parse value do_node with do_node ":" more
                end
           parse value temp with ":USERID." temp_id more
             if length(temp_id) > 0 then do_id = word(temp_id,1)
           parse value temp with ":INTERNET." temp_id more
             if length(temp_id) > 0 then do
                do_id = word(temp_id,1)
                do_node = ''
                end
           parse value temp with ":LIST." nick_list
             if length(nick_list) > 0 then
                if wordpos(current_nick,nick_names) > 0 then do
                   wo = wordpos(current_nick,nick_names)
                   wi = wordindex(nick_names,wo)
                   wn = delword(nick_names,wo,1)
                   nick_names = wn nick_list
                    in = nick_name.0 + 1
                    nick_name.0 = in
                    nick_name.in = "*"current_nick
                   list_opt = 1
                   il = i + 1
                   if il <= nick.0 then do
                      t_list = nick.il
                      upper t_list
                      If pos(":LIST.",t_list) > 0 & pos(":NICK.",t_list)
                         then do
                         i = i + 1
                         parse value t_list with ":LIST." nick_list
                         nick_names = nick_names nick_list
                         end
                      end
                   end
           end
           if length(do_nick) > 0 then do
              if wordpos(do_nick,nick_names) > 0 then do
                    in = nick_name.0 + 1
                    nick_name.0 = in
                    nick_name.in = do_nick
                    nick_node.in = do_node
                    nick_id.in   = do_id
                    wi = wordindex(nick_names,wordpos(do_nick,nick_names
                    wo = overlay(" ",nick_names,wi,length(do_nick))
                    nick_names = wo
                    end
              end
              if list_opt = 1 then signal one_more_time

        do i = 1 to nick_name.0
           tnick.0 = tnick.0 + 1
           t = tnick.0
           if pos("@",nick_id.i) = 0 then
             tnick.t = left(nick_name.i,10) left(nick_node.i,10),
                       left(nick_id.i,8)
           else
             tnick.t = left(nick_name.i,10) left(nick_node.i,10) nick_id
           end

        return tnick.


        get_nick:

        if sysdsn("'"nick_file"'") <> "OK" then signal nick_loop

        x = msg("off")
            s = time("L")  /* get the current time hh:mm:ss.th */
            t = substr(s,1,2)substr(s,4,2)substr(s,7,2)substr(s,10,1)
            suf = "F"t

        "ALLOC F("suf") DS('"nick_file"') SHR"
        "EXECIO * DISKR" suf "(FINIS STEM n."
        "FREE F("suf")"

        x= msg("on")

        do i = 1 to n.0
           if left(n.i,1) <> "*" then do
              nick.0 = nick.0 + 1
              j = nick.0
              nick.j = n.i
              end
           end

        signal nick_loop

        sendtovm: procedure
        /* -------------------------------------------------------------
        /* Perform the sysout operation to punch to non-TSO node locatio
        /* -------------------------------------------------------------

        arg indd toid syslrecl sysblksize sysrecfm
        if length(outdd) = 0 then
           outdd = "O"random()

        if left(sysrecfm,1) = "F" then sysblksize = syslrecl


        "ALLOC F("outdd") SYSOUT(B) DEST("toid") Reuse",
             "Recfm("sysrecfm") Lrecl("syslrecl") Blksize("sysblksize")"

        "EXECIO * DISKR" indd "(FINIS STEM in."
        "EXECIO * DISKW" outdd "(FINIS STEM in."
        "FREE F("outdd")"

        return
        Exit_Here:
        arg value
        if length(value) = 0 then value = 0
        if fwd <> "NEVER" then fwd = "No"
        Address ISPEXEC "VPut FWD"
        Exit value
./ ADD NAME=TMIBMFAX 0105-93138-93168-0943-00044-00002-00000-$A1238
        /* rexx */
        Address ISREDIT
        "MACRO NOPROCESS"

        Address ISPEXEC "Display Panel(TMIBMFAX)"
        if rc > 0 then exit

        line = 0

        Address ISREDIT
        "LINE_After" line "= '/BA'"
            line = line + 1
        "LINE_After" line "= '/AK                  '"
            line = line + 1
        "LINE_After" line "= '/From" faxf1  "'"
            line = line + 1
        if length(faxf2) > 0 then call insert faxf2
        if length(faxf3) > 0 then call insert faxf3
        if length(faxf4) > 0 then call insert faxf4
        if length(faxf5) > 0 then call insert faxf5
        if length(faxf6) > 0 then call insert faxf6
        if length(faxf7) > 0 then call insert faxf7
        if length(faxf8) > 0 then call insert faxf8
        "LINE_After" line "= '/Fax" faxphone   "C=1'"
            line = line + 1
        "LINE_After" line "= '/To  " faxt1  "'"
            line = line + 1
        if length(faxt2) > 0 then call insert faxt2
        if length(faxt3) > 0 then call insert faxt3
        if length(faxt4) > 0 then call insert faxt4
        if length(faxt5) > 0 then call insert faxt5
        if length(faxt6) > 0 then call insert faxt6
        if length(faxt7) > 0 then call insert faxt7
        if length(faxt8) > 0 then call insert faxt8
        "LINE_After" line "= '/Subject" faxsub    "'"
            line = line + 1
        "LINE_After" line "= '/EA                  '"

        exit 0
        Insert:
        arg data
        "LINE_After" line "= '"data "'"
            line = line + 1
            return
./ ADD NAME=TSOMAIL  0150-92329-93168-1005-02015-01890-00000-$A1238
        /* ----------------- tso rexx procedure ------------------------
        tmver = "2.31"
        /* This is a REXX exec that is intended to provide full mail
         * processing capabilities for the TSO user.
         *
         * Logic:
         *
         * 1)  Process entry options
         *   - debug will cause the REXX instruction tracing to be activ
         *   - USERID(userid) causes this exec to receive for another us
         *     (executing user must have TSO OPER)
         *   - SAFE is used by the SAFEMAIL facility that will be
         *     implemented as a started task or regularly scheduled batc
         *     job (BATCH is assumed when this option is specified).
         *   - READ will display the mail table immediately without read
         *     any new mail.
         *   - NOMSG will only display the panels and table if there is
         *     mail to read as determined by the RECEIVE command receivi
         *     anything.
         *   - BATCH will build the table in batch and then exit with no
         *     display processing occuring - AND NO RECEIVE PROCESSING.
         *     This must be executed under that TMP in batch as:
         *     PROFILE PREFIX(userid)
         *     * allocate necessary ispf data sets *
         *     ISPF CMD(%TSOMAIL BATCH USERID(userid)) NEWAPPLID(MAIL)
         * 1b) Verify that the TSOMAIL Table data set exists and if not
         *     do a 1 time test:
         *     - test if a log data set previously exists
         *       - if not continue
         *       - if it does then allow the user to:
         *         - delete it
         *         - edit it to remove old/unwanted messages
         * 2)  Process the TSO RECEIVE command using the LOGDSNAME to
         *     file all messages into the dataset:
         *     userid.TSOMAIL.LOG
         *     Files are received into datasets of the form:
         *     userid.TSOMAIL.Dyymmdd.Thhmmss.DATA
         * 3)  Terminate the exec if SAFE was specified
         * 4)  Verify that we were entered under the ISPF Applid of MAIL
         * 5)  Process the userid.TSOMAIL.LOG and create an ISPF
         *     table entry for every message and file.
         *   - use LISTDSI to determine if the table data set is large
         *     enough or has enough room, if not create, copy and delete
         *     (it must have less than 10 extents and more than 5 free
         *      directory blocks to be acceptable)
         *   - messages are placed into the partitioned data set in whic
         *     the ISPF table is stored
         *   - files will remain in the data sets in which they were rec
         *     into
         * 6)  Display the ISPF Mail table
         *   - Command options:
         *     - Find any character string in any row in the table (1.50
         *     - Refresh
         *       processes new mail into the table
         *     - Sendmail
         *       invoke the send mail dialog to send a message or file
         *     - Sort field-name value (or Sort blank to display menu) (
         *     - Defaults
         *       establish or change the current TSO Mail defaults
         *   - Line options:
         *     - A:  Send a message to the sender of the message/file
         *     - B:  alias for 'S'
         *     - C:  Change subject in table
         *     - D:  Delete the message or file
         *     - E:  Edit the message or file
         *     - F:  Forward the message or file to another user
         *     - L:  Log the message into a log table/data set
         *     - P:  Print the message or file
         *     - M:  Merge the data set into the message
         *     - R:  alias for 'S'
         *     - S:  Select a message for reading or a file for processi
         *           - 0:  Read the message that accompanied the data se
         *           - 1:  Browse the data set
         *           - 2:  Edit the data set
         *           - 3:  Print the data set
         *           - 4:  Rename the data set
         *           - 5:  Copy the data set
         *           - 6:  Use the PDS Command on the data set
         *           - 7:  Delete the data set
         *           - 8:  Process the file using the UNTERSE utility
         *           - 9:  Forward the data set to another user
         *
         * -------------------------------------------------------------
         * Change history:
         *
         *  06/15/93 - 2.31   Fix Delete prompt that deleted even if PF3
         *
         *  06/14/93 - 2.30   Allow a file to be Forwarded as a Message
         *                    Add 'recall' to listdsi for log data set.
         *
         *  06/07/93 - 2.29   Add 'DN' Delete-all Noprompt option
         *
         *  06/03/93 - 2.28   Add correction for 72 '-' within a note te
         *
         *  06/02/93 - 2.27   Add verification for profs invalid files
         *                    date stamp.
         *
         *  06/01/93 - 2.26   Add MF (Merge Force) option
         *                    Add DF (Delete File) option
         *
         *  04/27/93 - 2.25   Fix prof_pause bug
         *
         *  04/19/93 - 2.24   Add TMQILQRY test for inboung mail
         *
         *  03/23/93 - 2.23   Fix mail forward flag processing.
         *
         *  02/10/93 - 2.22   Pre-allocate log if not already allocated
         *                    increase the default allocation size.
         *
         *  02/05/93 - 2.21   Update Mail Forward flag options
         *
         *  01/14/93 - 2.20   Improve file delete option and fix from
         *                    Bill Horton (Eastman Chemical)
         *
         *  12/08/92 - 2.18   Limit size of invalid.file's processed for
         *
         *  12/06/92 - 2.17   fix for :msg with invalid.file
         *
         *  12/04/92 - 2.16   Fix for receive.invalid.file
         *
         *  11/25/92 - 2.15   Correction for minus scrolling
         *
         *  11/24/92 - 2.14   Add ACK: for subject for 2.13 change
         *
         *  11/05/92 - 2.13   Add code to handle X.RECEIVE.INVALID.FILE
         *                    messages
         *
         *  10/06/92 - 2.12   Correct RFIND and current row location
         *
         *  10/02/92 - 2.10   Correct SMTP to userid/node
         *
         *  09/26/92 - 2.09   fix length test of acknowledgement
         *
         *  09/25/92 - 2.07/8 add panel TMAILNTW when copying table
         *
         *  09/24/92 - 2.06: Bug fix
         *
         *  09/24/92 - 2.05: Minor correction for incoming dsn's
         *
         *  09/16/92 - 2.04: Refinement of 2.03
         *
         *  09/01/92 - 2.03: Fix error of lost messages if data deleted
         *                   via manual receive command.
         *
         *  06/16/92 - 2.02: Bug fix on SMTP name
         *
         *  05/27/92 - 2.01: Add support for SMTP From: information
         *                   to support Answer and Forward *
         *
         *  05/06/92 - 2.00: Changed to version 2.0 to reset level
         *                   Set default REXX address to ISPEXEC
         *                   Several minor performance enhancements
         *
         *  11/10/89 - creation of this application
         *
         * -------------------------------------------------------------
         *  Author:   Lionel B. Dyck
         *            Rockwell International
         *            Mail Code 110-SE28
         *            2201 Seal Beach Blvd.
         *            P.O. Box 2515
         *            Seal Beach, California 90740
         *            310-797-1125
         *            IBMMail:  USROKNTN
         *            Internet: LBDyck@OSREQ48.Rockwell.Com
         * -------------------------------------------------------------
        arg options
        null = ""

        if "ACTIVE" = sysvar('sysispf') then do
           Address ISPEXEC
           "VGET ZAPPLID"

           cmd = sysvar('sysicmd')

           if zapplid <> "MAIL" then do
           "SELECT CMD(%"cmd options") NEWAPPL(MAIL)"
           exit
           end
        end

        start:

        parse value null with debug safe read check batch nodel

        if wordpos("DEBUG",options,1) > 0 then do
                          trace i
                          debug = "DEBUG"
                          end

        if wordpos("SAFE",options,1) > 0 then do
                 safe = "on"
                 batch = "on"
                 end

        if wordpos("READ",options,1) > 0 then
                 read = "on"

        if wordpos("NOMSG",options,1) > 0 then
                 check = "on"

        if wordpos("BATCH",options,1) > 0 then
                 batch = "on"

        if wordpos("NODEL",options,1) > 0 then
                 nodel = "on"

        if wordpos("LOG",options,1) > 0 then do
                 log_opt = "on"
                 end
                 else log_opt = "off"

         parse upper var options "USERID(" user ")" .
         parmw = strip(user,,"'")
         parm = "PARM("user")"

         if length(user) > 0 then do
                                  userid = user
                                  prefix = user
                                 end
                            else do
                              userid = sysvar('sysuid')
                              prefix = sysvar('syspref')
                              end

        message_ds =  prefix".TSOMAIL.MESSAGE.M"
        message_ds_l = length(message_ds)
        mail_dd = "MAIL"random()

        /* ---------------------------------------------------- *
         * Extract the current node name from the user cvt      *
         * ---------------------------------------------------- */
        Address TSO "SHOWTSO CENTER"

        if log_opt    = "off" then do
           table      = "'"prefix".TSOMAIL.TABLE'"
           tablet     =    prefix".TSOMAIL.TABLE"
           ntable     = "'"prefix".TSOMAIL.NTABLE'"
           otable     = "'"prefix".TSOMAIL.OTABLE'"
           ispf_table = "TSOMAIL"
           tblpanel   = "TMAILTBL"
           end
        else do
             "Vget (table tablet ispftbl maillog)"
             ispf_table = ispftbl
             read = "on"
             tblpanel = "TMLOGTBL"
             end

        months = "JAN FEB MAR APR MAY JUN JUL ",
                 "AUG SEP OCT NOV DEC"
        table_log = "'"prefix".TSOMAIL.TABLE'"
        middle    = "LOG"
        suffix    = "MISC"
        logsel    = null
        logname   = null

        if log_opt = "on" then do
           rcount  = 0
           newmail = "off"
           signal do_table
           end

        /* ---------------------------------------------------- *
         * Determine if there is a prefix.NAMES.TEXT and if so: *
         * 1.  Open it and read it                              *
         * 2.  Determine if the user has specified either       *
         *     :logsel.  or  :logname.                          *
         *     (:logsel. is the middle qualifier)               *
         *     (:logname. is the suffix)                        *
         * 3.  Use the specified log name if found              *
         * 4.  Otherwise use prefix.LOG.MISC                    *
         * ---------------------------------------------------- */

        dash = insert('-','-',1,79,'-')

        names = "'"prefix".NAMES.TEXT'"

        x = listdsi(names)
        nts = sysreason
        nts_dd = "LOG"random()

        if nts = 0 then do
          Address TSO
          "ALLOC FILE("nts_dd") DS("names") SHR"
          "EXECIO * DISKR" nts_dd "(FINIS STEM nt."
          Address ISPEXEC
          do i = 1 to nt.0
             upper nt.i
             x = pos(':LOGSEL.',nt.i)
             if x > 0 then do
                p = substr(nt.i,x,40)
                parse var p w1 w2
                l = wordlength(w1,1)
                middle_name = substr(nt.i,x+8,l-8)
                if length(middle_name) > 0 then do
                   logsel = "on"
                   middle = middle_name
                   end
                if logname = "on" then i = nt.0
                end
             x = pos(':LOGNAME.',nt.i)
             if x > 0 then do
                p = substr(nt.i,x,40)
                parse var p w1 w2
                l = wordlength(w1,1)
                suffix_name = substr(nt.i,x+9,l-9)
                if length(suffix_name) > 0 then do
                   logname = "on"
                   suffix = suffix_name
                   end
                if logsel = "on" then i = nt.0
                end
           end  /* end loop for logsel and logname */
        end /* end ok loop */

        if nts = 0 then Address TSO "FREE FILE("nts_dd")"

        maildsn ="'"prefix"."middle"."suffix"'"

        /* ---------------------------------------------------- *
         * Test to see if the tsomail table data set exists     *
         * and bypass this code if it does.                     *
         *                                                      *
         * Bypass if SAFE process is occuring                   *
         *                                                      *
         * Then test if a current tso log data set exists       *
         *                                                      *
         * If it does then prompt the user to:                  *
         *     - delete the current tso log data set            *
         * or  - edit it to remove old/unwanted messages        *
         * ---------------------------------------------------- */

        log_ds_stat = sysdsn(maildsn)

        if safe <> "on" then do
           x = sysdsn(table)   /* does the table data set exist */
           if x <> "OK" then do
              if log_ds_stat = "OK" then do
                 /* there currently exists a log data set         */
                 "DISPLAY PANEL(TMAILTLG)"
                 if zcmd = "D" then
                    Address TSO "DELETE" maildsn
                 if zcmd = "E" then,
                    "EDIT DATASET("maildsn")"
               end
           end
        end

       if safe <> "on" then do
           Address TSO,
              "Tmailqry"
           new_rc = rc
           if new_rc > 0  then do
         /*   read = "on" */
              signal do_table
              end
           end

        if log_ds_stat <> "OK" then do
           Address TSO
             "Alloc ds("maildsn") New Spa(15,30) Tr",
               "Recfm(V B) Lrecl(255) Blksize(3120) Dsorg(PS)"
             "Free  ds("maildsn")"
           Address ISPEXEC
           end

        rcount = 0 /* receive counter for receive ispf wait panel */
        newmail = "off"  /* set initial value off */

        if read = "on" then signal do_table

        if safe <> "on" then
           if batch = "on" then signal do_table

        /* Clear RMBFISCN "Mail Waiting" on PDF Primary and ISC Master M
        if safe <> "on" then do
           "SELECT CMD(%RMBFMAIL) NEWAPPL(ISR)"
           "SELECT CMD(%RMBFMAIL) NEWAPPL(ISP)"
           end

        x = OUTTRAP("profile.",'*')

        Address TSO "PROFILE"

        if pos('NOMSGID',profile.1) = 0 then msg = "MSGID"
                                         else msg = NOMSGID

        if pos('NOINTERCOM',profile.1) = 0
                       then intercom = "INTERCOM"
                       else intercom = "NOINTERCOM"

        if pos('NOWTPMSG',profile.1) = 0
                       then wtpmsg = "WTPMSG"
                       else wtpmsg = "NOWTPMSG"

        if pos('NOPAUSE',profile.1) = 0
                       then prof_pause = "PAUSE"
                       else prof_pause = "NOPAUSE"

        x = OUTTRAP('OFF')

        /*    end of profile testing for the message id option   */

        /* set the julian date  */
        d = date(u)
        date = substr(d,7,2)substr(d,1,2)substr(d,4,2)

        /* set first pass flag */
        first = "on"

        Signal Receive

        Again:

        /* reset the message profile option */
        x = OUTTRAP("p.",'*')
        Address TSO "PROFILE" msg
        x = OUTTRAP('OFF')

        parse value null with rec_del do_receive

        /* -------------------------------------------------------- *
         *                                                          *
         *   Loop thru the captured output looking for INMR901I     *
         *   which will indicate that we need to receive a data set.*
         *                                                          *
         *   If found then generate a unique data set name based on *
         *   prefix.TSOMAIL.Ddate.Ttime.DATA                        *
         *                                                          *
         *   If INMR060I is found then queue a DELETE as we can't   *
         *   handle that data set.                                  *
         *                                                          *
         *   Then branch to the Receive subroutine.                 *
         *                                                          *
         *   Also reply DELETE for message INMR933A....             *
         *   Also reply Dsname for message INMR907A....             *
         *                                                          *
         * -------------------------------------------------------- */

        do i = 1 to output.0

        if "INMR003I" == substr(output.i,1,8) then
           signal do_table

        inmr_msg = substr(output.i,1,8)

        if wordpos(inmr_msg,"INMR060I INMR108I INMR933A") > 0
            then do
            rec_del = "DELETE"
            log_dd = "LOG"random()
            e_m.1 = dash
            e_m.2 = "ERROR during Receive"
            Address TSO
            "ALLOC F("log_dd") MOD DS("maildsn")"
            "EXECIO 2 DISKW" log_dd "(FINIS STEM e_m."
            "EXECIO" output.0 "DISKW" log_dd "(FINIS STEM output."
            "FREE F("log_dd")"
          Address ISPEXEC
            dataset = null
            do_receive = "on"
            end

        if "INMR907A" == substr(output.i,1,8) then do
            s = time("L")  /* get the current time hh:mm:ss.th */
            t = substr(s,1,2)substr(s,4,2)substr(s,7,2)substr(s,10,1)
            rdsn = "DATASET('"prefix".TSOMAIL.D"date".T"t".DATA')"
            dataset = "receive"
            newmail = "on"  /* set the new mail flag on */
            do_receive = "on"
            end

        if "INMR901I Dataset" == substr(output.i,1,16) then do
            s = time("L")  /* get the current time hh:mm:ss.th */
            t = substr(s,1,2)substr(s,4,2)substr(s,7,2)substr(s,10,1)
            rdsn = "DATASET('"prefix".TSOMAIL.D"date".T"t".DATA')"
            dataset = "receive"
            newmail = "on"  /* set the new mail flag on */
            do_receive = "on"
            end

        end       /* end do loop for output trapped */

        if do_receive = "on" then signal receive

        signal do_table
        exit

        Receive:

        /* set the profile envionment for our needs */
        x = OUTTRAP("p.",'*')
        Address TSO "PROFILE MSGID NOINTERCOM NOWTPMSG NOPAUSE"
        prof_change = "on"
        x = OUTTRAP('OFF')

        Address TSO "DELSTACK"
        Address TSO "DELSTACK"

        x = PROMPT("ON") /* enable prompting */
        x = MSG("ON")    /* turn messages on */

        if first = "on" then do
           queue 'END'  /* stack an END record */
           first = "off"
           end

        /* -------------------------------------------------------- *
         * Check for rec_del and queue out "DELETE" if non-blank    *
         * as we can't handle that data set                         *
         * -------------------------------------------------------- */
         if rec_del = "DELETE" then queue "DELETE"

        /* -------------------------------------------------------- *
         *   Queue out the TSO RECEIVE response to indicate the     *
         *   data set name to be used to receive the first          *
         *   data set in the stack.  The SYSOUT(0) is used to       *
         *   direct the IEBCOPY messages to a sysout class that     *
         *   is defined as copies=0 as we do not want to see them   *
         *   and there is no other way to keep them from the screen *
         * -------------------------------------------------------- */

        if dataset = "receive" then do
           queue rdsn "SYSOUT(0)"   /* queue out the dsn to receive into
           queue 'END'  /* stack an END record */
           dataset = "queued"
           end

        rcount = rcount + 1

        if "ACTIVE" = sysvar('sysispf') then do
           if safe <> "on" & check <> "on" & batch <> "on" then do
           "CONTROL DISPLAY LOCK"
           "DISPLAY PANEL(TMAILRW)"                  /* RECEIVE Wait Pan
           end
        end

        x = OUTTRAP("output.",'*')

        if "USERID" <> userid then
           Address TSO,
           "RECEIVE USERID("userid") LOGDSNAME("maildsn")"
            else
            Address TSO,
            "RECEIVE LOGDSNAME("maildsn")"

        receive_rc = rc
        if receive_rc < -50 then signal do_table

        x = OUTTRAP('OFF')

        if p == on then x = PROMPT("OFF")
        x = MSG("OFF")   /* turn off messages for now */

        Address TSO "DELSTACK"
        Address TSO "DELSTACK"

        Signal again  /* continue with the process */

        do_table:

        if "ACTIVE" <> sysvar('sysispf') then exit  /* exit if not under

        if read = "on" then maildsn = null

        last_sort = "FROMUSER"
        mcount = 0   /* initialize the message count received value */
        fcount = 0   /* initialize the message files received value */

        if "OK" <> sysdsn(table) then do
           Address TSO,
           "ALLOC DS("table") NEW DIR(60) SPACE(30,90) TRACKS DSORG(PO)"
           "RECFM(F B) LRECL(80) BLKSIZE(23440)"
           end
        else do
           x = listdsi(table directory)
           if sysextents > 10 then newtable = "yes"
           if (sysadirblk-sysudirblk) < 5 then do
                newtable = "yes"
                sysadirblk = sysadirblk + 15
                end
           end

        if newtable == "yes" then do
           if batch <> "on" & check <> "on" then do
             members = sysmembers
             "CONTROL DISPLAY LOCK"
             "DISPLAY PANEL(TMAILNTW)"
             end
          x = msg("OFF")
          Address TSO,
           "Delete" ntable
          Address TSO,
           "ALLOC DS("ntable") NEW DIR("sysadirblk")",
           "SPACE("sysalloc",90) TRACKS DSORG(PO)",
           "RECFM(F B) LRECL(80) BLKSIZE(23440)"
          "LMINIT DATAID(tblin) DATASET("table")"
          "LMINIT DATAID(tblout) DATASET("ntable")"
          "LMCopy FROMID("tblin")",
                 "TODATAID("tblout") FROMMEM(*)"
          "LMFREE Dataid("tblin")"
          "LMFREE Dataid("tblout")"
          Address TSO "DELETE" otable
          Address TSO "RENAME" table  otable
          Address TSO "RENAME" ntable table
          newtable = null
          end

        if length(maildsn) > 0 then do
           if batch <> "on" & check <> "on" then do
           "CONTROL DISPLAY LOCK"
           "DISPLAY PANEL(TMAILWAT)"
           end
        end

        "LIBDEF" ispf_table "DATASET ID("table")"

        "CONTROL ERRORS RETURN"
        "TBOPEN "ispf_table" WRITE LIBRARY("ispf_table")"
          lcc = rc  /* save the return code */
          zsel = null
          if lcc == 0 then mailnum = 0

        if lcc == 12 then do
           mailsmsg = 'In use'
           maillmsg = 'The TSO Mail Table is currently in use',
                      'probably is a split session '
           if batch <> "on" then "DISPLAY PANEL(TMAILUSE)"
              else say "*****" maillmsg "*****"
            "TBEND "ispf_table
            "LIBDEF "ispf_table
           /* reset the profile environment back to normal */
           if prof_change = "on" then
           Address TSO,
           "PROFILE" intercom wtpmsg prof_pause
           exit
        end

        if lcc > 12 then do
           mailsmsg = 'Severe Error'
           maillmsg = 'A Severe Error has been encountered - ',
                'contact systems support'
           if batch <> "on" then "SETMSG MSG(MAIL000)"
              else say "*****" maillmsg "*****"
           exit
           /* reset the profile environment back to normal */
           if prof_change = "on" then
           Address TSO,
           "PROFILE" intercom wtpmsg prof_pause
            "TBEND "ispf_table
            "LIBDEF "ispf_table
        end

        if lcc == 8 then do
           "TBCREATE "ispf_table" KEYS(MAILNUM)",
           "NAMES(MAILFLOC MAILFID MAILTLOC MAILTID MAILDATN MAILDATD",
           "MAILTIME MAILACTN MAILSUBJ MAILFDS MAILTDS)",
           "LIBRARY("ispf_table") WRITE"

            mailnum = 0
        end

        build:
        x = listdsi(maildsn)

        if sysreason = 0 & sysused > 0 then do
          Address TSO
           "ALLOC FILE("mail_dd") DS("maildsn") SHR"
           "EXECIO * DISKR "mail_dd" (FINIS STEM data."
           "FREE FILE("mail_dd")"
           Address ISPEXEC
           msgcount = 0
           parse value null with type mailsubj mailsmtp long_message mai
           msgl.0 = 4
           msgl.1 = "Message exceeding 80 characters received"
           msgl.2 = "and has been placed into a data set."
           msgl.3 = " "
           msgl.4 = " "

        buildtbl:
        do i = 1 to data.0

        /* test for start of message indicator of 79 '-' */

        if substr(dash,1,79) = substr(data.i,1,79) then do
           i = i + 1
           if wordpos(word(data.i,1),"ERROR TRANSMIT RECEIVE") > 0 then
              hit = 1
              else do
                   hit = 0
                   i = i - 1
                   end
        end

        if hit = 1 then do
              hit = 0
              if msgcount > 0 then do
                              call store_msg
                              end
                              else do
                                parse value null with mailsubj mailfds,
                                               msg. mailtds type mailsmt
                              end
              end

        if "ERROR " == substr(data.i,1,6) & length(type) = 0 then do
           type = "M"
           mailsubj = "Data Set Reception Error"
           mailactn = "Received"
           end

        if "TRANSMIT" == substr(data.i,1,8) & length(type) = 0 then do
           type = "M"
           if "** MESSAGE " = substr(data.i,17,11),
              | "**MESSAGE**" = substr(data.i,17,11) then do
                msg.1 = data.i
                call toinfo1
                i = i + 1
                msgcount = 1
                call toinfo2
                mailactn = "Sent"
                end
           else do  /* must be a sent file */
               msg.1 = data.i
               mailsubj = "Sent file:" substr(data.i,17,44)
               call toinfo1
               i = i + 1
               msgcount = 1
               call toinfo2
               mailactn = "Sent"
               end
        end

        if "RECEIVE" == substr(data.i,1,7) & length(type) = 0 then do
           if "** MESSAGE **" = substr(data.i,17,13) then do
              type = "M"
              newmail = "on"  /* set the new mail flag on */
              mailactn = "Received"
              parse value null with mailsubj mailfds mailfloc
              call finfo1
              end

           if "** ACKNOWLEDGMENT **" = substr(data.i,17,21) then do
              parse value null with mailfds mailfloc
              mailsubj = "Acknowledgement"
              mailactn = "Received"
              type = "M"
              call finfo1
              end

        if type = null then do
          type = "F"
             mailactn = "Received"
             newmail = "on"  /* set the new mail flag on */
             mailsubj = "Original DSN:" substr(data.i,17,44)
             mailfds  = substr(data.i,17,44)
             call finfo1
             parse value "???? ???? ???? ????" with,
                   mailfloc mailfid mailtid mailtloc
        end

        end    /*  end of RECEIVE processing  */

        if type = "M" then do
           if substr(data.i,2,6) == "FROM: " then
              if length(mailfloc) = 0 then
                  call finfo2
              x = i + 1
              if word(data.x,1) = "STORED" then long_message = "off"
           end

        if type = "F" then do
           if substr(data.i,2,6) == "FROM: " then do
              call finfo2
              end
           if substr(data.i,5,5) == "DSN: " then do
              mailtds = substr(data.i,10,44)
              mailtds = "'"strip(mailtds)"'"
              type = "D"
              fcount = fcount + 1
              end
           else do
              msgcount = msgcount + 1
              msg.msgcount = data.i
              if type = "D" then call store_msg
              end
        end

        if type = "M" then do
           if length(mailsubj) = 0 then do
              x = pos("SUBJECT:",data.i)
           if x = 0 then x = pos("Subject:",data.i)
           if x > 0 then
              mailsubj = "Message:" substr(data.i,x+9,70)
           end
           if length(mailsmtp) = 0 then do
              x = 0
              if left(data.i,6) = "From: " then x = 1
              if left(data.i,9) = "Reply-To:" then x = 2
              if left(data.i,8) = "rcpt to:" then x = 3
              select
                when x = 1 then do
                   x = pos("<",data.i)
                   if x = 0 then parse value data.i with "From: " mailsm
                      else parse value data.i with "<" mailsmtp ">"
                   end
                when x = 2 then do
                   x = pos("<",data.i)
                   if x = 0 then parse value data.i with "Reply-To: " ma
                      else parse value data.i with "<" mailsmtp ">"
                   end
                when x = 3 then do
                   x = pos("<",data.i)
                   if x = 0 then parse value data.i with "rcpt to: " mai
                      else parse value data.i with "<" mailsmtp ">"
                   end
                 otherwise nop;
              end
           end

           msgcount = msgcount + 1
           msg.msgcount = data.i
           if long_message = null then
              if msgcount > 2 then
                 if length(msg.msgcount) > 80 then long_message = "on"
        end  /* end of do for type = "M" */

          end  /* end do to process recently received mail */

          if msgcount > 0 then call store_msg
        end     /* end of the build process */

        drop data.

        if length(maildsn) > 0 then do
        if mcount = 0 then do
           x = outtrap("del.","*")
           Address TSO "DELETE" maildsn
           x = outtrap("off")
           mailsmsg = '0 New Messages'
           maillmsg = 'There were no new messages or files to ',
               'receive at this time'
           if batch <> "on" then do
                  if check <> "on" then
                  "SETMSG MSG(MAIL000)"
                  end
              else say "*****" maillmsg "*****"
           end
           else do
            mailsmsg = mcount 'New Messages'
            maillmsg =,
            'There were' mcount 'new messages including' fcount 'files r
            if batch <> "on" then do
                  if check <> "on" | newmail = "on" then
                     "SETMSG MSG(MAIL000)"
                     end
               else say "*****" maillmsg "*****"
            x = MSG("OFF")
            "Vget (tmdel) Profile"
            if tmdel = "Y" then nodel = "on"
            if nodel <> "on" then Address TSO "DELETE" maildsn
            else do
               Address TSO
               "DELETE '"prefix"."middle".HOLD3."suffix"'"
               "RENAME '"prefix"."middle".HOLD2."suffix"'",
                       "'"prefix"."middle".HOLD3."suffix"'"
               "RENAME '"prefix"."middle".HOLD1."suffix"'",
                       "'"prefix"."middle".HOLD2."suffix"'"
               "RENAME"  maildsn  "'"prefix"."middle".HOLD1."suffix"'"
               Address ISPEXEC
               end   /* end rename for NODEL option */
             end  /* end else do for mcount > 0 */
        end  /* end do for length(maildsn) > 0 */

        if check = "on" then do
                   if mcount = 0 then batch = "on"
                   if newmail = "off" then batch = "on"
                   end

        /* reset the profile environment back to normal */
        if read <> "on" then
           if prof_change = "on" then
              Address TSO "PROFILE" intercom wtpmsg prof_pause

        if batch = "on" then do
              "TBSAVE "ispf_table" REPLCOPY LIBRARY("ispf_table")"
              "TBCLOSE "ispf_table" REPLCOPY LIBRARY("ispf_table")"
              x = msg('off')
              if tsomnum_alloc = "on" then do
                Address TSO  "Free F("tsomnum")"
                drop tsomnum_alloc
                end
              x = msg('on')
              "LIBDEF "ispf_table
              exit
              end

        "TBTOP" ispf_table
        "TBSAVE" ispf_table "REPLCOPY LIBRARY("ispf_table")"
        "TBSORT" ispf_table "FIELDS (MAILNUM C,D)"

        "VGET (MAILDISP)"
          if log_opt = "off" then do
             select
                when maildisp = "LONG"   then tblpanel = "TMAILTBL"
                when maildisp = "SHORT"  then tblpanel = "TMAILTBS"
                when maildisp = "XLONG"  then tblpanel = "TMAILTBX"
                otherwise tblpanel = "TMAILTBL"
                end
             end
             else do
             select
                when maildisp = "LONG"   then tblpanel = "TMLOGTBL"
                when maildisp = "SHORT"  then tblpanel = "TMLOGTBS"
                when maildisp = "XLONG"  then tblpanel = "TMLOGTBX"
                otherwise tblpanel = "TMLOGTBL"
                end
             end

        parse value '0 0 0' with crp rowcrp last_find
        parse value null with save_zverb save_zscrolln

        "Control Errors Return"

        display:
        do forever

        parse value null with zcmd mailsmsg maillmsg zsel

        usrfind = "PASSTHRU"
        "VPUT USRFIND"

        if ispfds = "on" then do
           "CONTROL DISPLAY RESTORE"
           ispfds = "off"
           end

        "VGET (ZVERB ZSCROLLN)"

        if save_zverb <> null then do
           zverb = save_zverb
           zscrolln = save_zscrolln
           parse value null with save_zverb save_zscrolln
           end

        if hcc == 4 then "TBDISPL "ispf_table
           else do
                "TBTOP" ispf_table
                "TBSKIP" ispf_table "NUMBER("crp")"
                if zscrolln <> null then do
                  if zverb = "UP" then "TBSkip" ispf_table "Number(-"zsc
                  if zverb = "DOWN" then
                     "TBSkip" ispf_table "Number("zscrolln")"
                  end
                if rowcrp = 0 then
                  "TBDISPL "ispf_table" PANEL("tblpanel")"
                else
                "TBDISPL "ispf_table" PANEL("tblpanel")",
                        "CSRROW("rowcrp") AUTOSEL(NO)"
                end

        crp = ztdtop
        rowcrp = 0

        hcc = rc  /* save return code */

        "VGET (ZVERB ZSCROLLN)"
        if wordpos(zverb,"UP DOWN") > 0 then do
           save_zverb = zverb
           save_zscrolln = zscrolln
           end
           else parse value null with save_zverb save_zscrolln

        usrfind = null
        "VPUT USRFIND"

        ispfds = "off"

        if hcc > 4 then do
              "TBCLOSE" ispf_table "REPLCOPY LIBRARY("ispf_table")"
              "LIBDEF" ispf_table
              x = msg('off')
              if tsomnum_alloc = "on" then do
                Address TSO "Free F("tsomnum")"
                drop tsomnum_alloc
                end
              x = msg('on')
             if log_opt = "on" then do
                mailsmsg = 'Complete'
                maillmsg = 'ISPF TSO Mail Log Processing Complete'
                                    end
                else do
                     mailsmsg = 'Complete'
                     maillmsg = 'ISPF TSO Mail Dialog Processing Complet
                     end
             "SETMSG MSG(MAIL000)"
             exit 0
             end

        if ztdsels = 0 & length(zcmd) = 0 then signal display

        rowcrp = 0

        if zsel <> null then
           "TBQUERY "ispf_table,
                  "POSITION(ROWCRP)"

        if ztdsels > 0 & zsel = null then do
           "TBQUERY "ispf_table,
                  "POSITION(ROWCRP)"
                  crp = crp + rowcrp - 1
                  rowcrp = 1
                  end

        if length(zcmd) > 0 then do
           parse value zcmd with w1 w2 w3
           upper w1

           select

           when abbrev('SHORT',w1,2) then do
              maildisp = "SHORT"
              if log_opt = "off" then tblpanel = "TMAILTBS"
                                 else tblpanel = "TMLOGTBS"
              hcc = 0
              "VPUT (MAILDISP) PROFILE"
              end

           when abbrev('LONG',w1,3) then do
              maildisp = "LONG"
              if log_opt = "off" then tblpanel = "TMAILTBL"
                                 else tblpanel = "TMLOGTBL"
              hcc = 0
              "VPUT (MAILDISP) PROFILE"
              end

           when abbrev('XLONG',w1,2) then do
              maildisp = "XLONG"
              if log_opt = "off" then tblpanel = "TMAILTBX"
                                 else tblpanel = "TMLOGTBX"
              hcc = 0
              "VPUT (MAILDISP) PROFILE"
              end

           when abbrev('SENDMAIL',w1,4) then do
           "CONTROL DISPLAY SAVE"
           ispfds = "on"
                sendsubj = null
                "VPUT (SENDSUBJ) SHARED"
                "SELECT CMD(%TMAILSND" w2 w3 debug")"
                end

           when abbrev('DEFAULTS',w1,3) then do
           "CONTROL DISPLAY SAVE"
           ispfds = "on"
                if log_opt = "on" then do
                   mailsmsg = "Error"
                   maillmsg = "Option DEFAULTS is not supported when",
                               " processing a Mail LOG."
                   end
                else do
                     "SELECT CMD(%TMAILDEF)"
                     end
                end

           when abbrev('DEBUG',w1,3) then do
           "CONTROL DISPLAY SAVE"
           ispfds = "on"
                if length(w2) = 0 then do
                                  trace i
                                  debug = "DEBUG"
                                  end
                   else do
                        trace off
                        debug = null
                        end
                   end

           when w1 = "LOG"  then do
                if log_opt = "on" then do
                   mailsmsg = "Error"
                   maillmsg = "Option LOG is not supported when processi
                              " a Mail LOG."
                   end
                else do
                     "TBCLOSE "ispf_table" REPLCOPY LIBRARY("ispf_table"
                     x = msg('off')
                     if tsomnum_alloc = "on" then do
                       Address TSO "Free F("tsomnum")"
                       drop tsomnum_alloc
                       end
                     x = msg('on')
                     "LIBDEF "ispf_table
                     if ispfds = "on" then
                        "CONTROL DISPLAY RESTORE"
                     "Select CMD(%TMAILLOG)"
                     read = "on"
                     signal do_table
                     end
                end

           when abbrev('REFRESH',w1,3) then do
                if log_opt = "on" then do
                   mailsmsg = "Error"
                   maillmsg = "Option REFRESH is not supported when proc
                               " a Mail LOG."
                   end
                else do
                     "TBCLOSE "ispf_table" REPLCOPY LIBRARY("ispf_table"
                     x = msg('off')
                     if tsomnum_alloc = "on" then do
                       Address TSO "Free F("tsomnum")"
                       drop tsomnum_alloc
                       end
                     x = msg('on')
                     "LIBDEF "ispf_table
                     y = wordpos("READ",options)
                     if y > 0 then do
                                   xopt = delword(options,y,4)
                                   options = xopt
                                   end
                     signal start
                     end
                end

        /* ---      ***FIND***     --- */
           when abbrev('FIND',w1,1)  | zcmd = "RFIND" then do
              if zcmd <> "RFIND" then
                 argument = w2 w3
              upper argument
              argument = strip(argument)
              zsel = null
              hcc = 0
              crp = ztdtop
              find_loop = null
              search = null
              if zcmd = "RFIND" then do
                  "TBTOP" ispf_table
                  last_find = last_find + 1
                  "TBSKIP" ispf_table "POSITION(ROWID) NUMBER("last_find
                  end
                 else
                 "TBSKIP" ispf_table "POSITION(ROWID)"
              if rc = 8 then f_smsg = "Wrapped"
                        else f_smsg = "Found"

              /* perform search */

              do forever
                 search = MAILFLOC MAILFID MAILTLOC MAILTID MAILDATN,
                  MAILDATD MAILTIME MAILACTN MAILSUBJ MAILTDS
                  upper search
                 if pos(argument,search) > 0 then do
                    crp = rowid + 0
                    rowcrp = crp
                    last_find = rowcrp
                        mailsmsg = f_smsg
                        maillmsg = argument "found during search in row:
                        "Setmsg Msg(MAIL000)"
                    leave
                    end
                 "TBSKIP" ispf_table "POSITION(ROWID)"
                 if rc = 8 then do
                       "TBTOP" ispf_table
                       f_smsg = "Wrapped"
                    if find_loop = "on" then do
                        mailsmsg = "Not Found"
                        maillmsg = argument "Not found during search"
                        "Setmsg Msg(MAIL000)"
                        rowid = crp
                        leave
                        end
                        else find_loop = "on"
                    end
                 zsel = null
                 end
              end

           when abbrev('SORT',w1,4) then do
            if length(w2) > 1 then do
                upper w2 w3
                if w2 = "DATE" & length(w3) = 0 then w3 = "D"
                if w2 = "TIME" & length(w3) = 0 then w3 = "D"
                if length(w3) > 0 then w3 = substr(w3,1,1)
                   else w3 = "A"
                   if w3 <> "A" & w3 <> "D" then w3 = "A"
                x = wordpos(w2,"FROMNODE FROMUSER TONODE TOUSER",
                    "DATE TIME ACTION")
                if x = 0 then do
                   mailsmsg = 'Error'
                   maillmsg = 'Enter valid sort option: ',
                   'FROMNODE FROMUSER TONODE TOUSER DATE TIME ACTION'
                   end
                else do
                   w4 = "C"
                   wh2 = w2  /* save the value to report on */
                   last_sort = w2

                   select
                   when w2 = "DATE" then do
                        w2 = "MAILDATN"
                        w4 = "N"
                        end
                    when w2 = "FROMNODE" then w2 = "MAILFLOC"
                    when w2 = "FROMUSER" then w2 = "MAILFID"
                    when w2 = "TONODE"   then w2 = "MAILTLOC"
                    when w2 = "TOUSER"   then w2 = "MAILTID"
                    when w2 = "DATE"     then w2 = "MAILDATN"
                    when w2 = "TIME"     then w2 = "MAILDATN" /* was MAI
                    when w2 = "ACTION"   then w2 = "MAILACTN"
                    otherwise nop;
                    end

           if w2 <> "MAILDATN" then
              "TBSORT "ispf_table" FIELDS ("w2 w4","w3")"
              else
              "TBSORT "ispf_table" FIELDS (MAILDATN" w4","w3" MAILTIME C
              mailsmsg = 'Sorted'
              maillmsg = 'Mail sorted using field' wh2 'in order' w3
              end  /* end sort processing */
            end
            else do
                 zcmd = ''
                 "DISPLAY PANEL(TMAILSRT)"
                 if rc = 0 then do
                    sort_parm = ''
                    if length(action) = 1 then sort_parm = "MAILACTN C"
                       if length(action) = 1 then last_sort = "ACTION"
                    if length(date)   = 1 then sort_parm = sort_parm,
                       " MAILDATN N" date "MAILTIME C" date
                       if length(date)   = 1 then last_sort = "DATE"
                    if length(tonode) = 1 then sort_parm = sort_parm,
                        " MAILTLOC C" tonode
                       if length(tonode) = 1 then last_sort = "TONODE"
                    if length(touser) = 1 then
                        sort_parm = sort_parm "MAILTID C" touser
                       if length(touser) = 1 then last_sort = "TOUSER"
                    if length(fromuser) = 1 then sort_parm = sort_parm,
                         " MAILFID C" fromuser
                       if length(fromuser) = 1 then last_sort = "FROMUSE
                    if length(fromnode) = 1 then sort_parm = sort_parm,
                          " MAILFLOC C" fromnode
                       if length(fromnode) = 1 then last_sort = "FROMNOD
                    "TBSORT "ispf_table" FIELDS ("sort_parm")"
                      trc = rc
                    end
                    else do
                         mailsmsg = "Cancelled"
                         maillmsg = "Sort cancelled"
                         end
                 end

           end /* end of the when SORT process */

          otherwise do
                   mailsmsg = "Error"
                   maillmsg = "Invalid TSO Mail Table Command entered:"
                   end

          end
        end

        /* Begin processing the individual message selections */

        if substr(mailtds,2,message_ds_l) = message_ds then
           message_ds_opt = "on"
           else message_ds_opt = null

        if zsel <> null then do
        if zsel = "F" then do
           "CONTROL DISPLAY SAVE"
           ispfds = "on"
           if message_ds_opt = "on" then do
              "Display Panel(TMAILFWD)"
              end
              else do
                   if length(mailtds) = 0 then
                        "DISPLAY PANEL(TMAILFWD)"
                                          else
                        "DISPLAY PANEL(TMAILFWF)"
                   end
           if rc = 0 then do
              call fixsubj
              "VPUT (FWD SENDSUBJ) SHARED"
              Select
                 when fwdfile = "Y" then fwdfile = "FILE("mailtds")"
                 when fwdfile = "M" then do
                      fwdfile = null
                      message_ds_opt = "on"
                      end
                 otherwise fwdfile = null
                 end
              if message_ds_opt = "on" then
                "SELECT CMD(%TMAILSND" fwdid,
                    "MSG("mailtds")" debug
              else
                "SELECT CMD(%TMAILSND" fwdid,
                    fwdfile "MSG('"tablet"(M"mailnum")')" debug
              erc = rc
              if erc = 0 then do
                 if fwd <> "NEVER" then fwd = null
                 sendsubj = null
                 "VPUT (FWD SENDSUBJ) SHARED"
                 mailactn = "Forwarded"
                 call save_table
                 mailsmsg = 'Forwarded'
                 maillmsg = 'This message has been forwarded to' fwdid
                 end
                 else do
                      mailsmsg = "Cancelled"
                      maillmsg = "Forward cancelled"
                      end
           end
        end

        /* ----------------------------------------------- *
         *            Merge data set into Message          *
         * ----------------------------------------------- */
        if zsel = "MF" then do
           merge_force = "on"
           zsel = "M"
           end
           else merge_force = null
        if zsel = "M" then do
           merge = null
           if length(mailtds) = 0 then do
              mailsmsg = "Error"
              maillmsg = "Invalid option for this message"
              merge = "No"
              end
           if sysdsn(mailtds) <> "OK" then do
              mailsmsg = "Error"
              maillmsg = "The data set associated with this message no",
                         "longer exists" mailtds
              merge = "No"
              end
           if merge <> "No" then do
              x = listdsi(mailtds)
              if syslrecl > 80 then merge_ds = "ng"
                 else merge_ds = "ok"
              if left(sysrecfm,1) = "V" then do
                 if syslrecl > 84 then merge_ds = "ng"
                    else merge_ds = "ok"
                 end
              if merge_force = "on" then merge_ds = "ok"
              if merge_ds = "ng" then do
                 mailsmsg = "Error"
                 maillmsg = "Reqeuested data set cannot be merged into",
                            "the message.  Record size" syslrecl,
                            " greater than 80"
                 end
              else do
                 m_ddn = "M"random()
                 parse value '' with md. mm.
                 Address TSO
                 "Alloc f("m_ddn") ds("mailtds") SHR REUSE"
                 "Execio * Diskr" m_ddn "(Finis Stem md."
                 "Free f("m_ddn")"
                 "Alloc f("m_ddn") ds('"tablet"(M"mailnum")') Shr Reuse"
                 "Execio * Diskr" m_ddn "(Finis Stem mm."
                 x = mm.0 + 1
                 mm.0 = x
                 mm.x = center("Converted Data",72,'-')
                 "Execio * Diskw" m_ddn "(Stem mm."
                 "Execio * Diskw" m_ddn "(Finis Stem md."
                 Address ISPEXEC
                  Address TSO "Free f("m_ddn")"
                 mailsmsg = "Done"
                 maillmsg = "Data set merged into Message and the data s
                            "has been deleted"
                 x = Msg("OFF")
                 Address TSO "Delete" mailtds
                 x = Msg("ON")
                 mailtds = null
                 mailfds = null
                 mailactn = "Merged"
                 call save_table
                 end
              end
        end

        if zsel = "A" then do
           call fixsubj
           "CONTROL DISPLAY SAVE"
           ispfds = "on"
           "VPUT (SENDSUBJ) SHARED"
           if length(mailfloc) = 0 then
              "SELECT CMD(",
              "%TMAILSND" mailfid debug ")"
           else
              "SELECT CMD(",
              "%TMAILSND" strip(mailfloc)"."strip(mailfid) debug ")"
           erc = rc
           sendsubj = null
           "VPUT (SENDSUBJ) SHARED"
           if erc = 0 then do
                mailactn = "Answered"
                call save_table
                mailsmsg = 'Answered'
                maillmsg = 'An Answer has been sent to',
                          strip(mailfloc)"."strip(mailfid)
                end
           else do
                mailsmsg = 'Cancelled'
                maillmsg = 'Answer has been cancelled to',
                          strip(mailfloc)"."strip(mailfid)
                end
           end

        if zsel = "P" then do
           "VGET (TSOMPRT TSOMPRTO) PROFILE"
           if length(tsomprt) = 0 then do
                 "CONTROL DISPLAY SAVE"
                 ispfds = "on"
                 if message_ds_opt = "on" then
                 "SELECT CMD(",
                 "%RPRINT "mailtds" NODEL) NEWAPPL(ISR)"
                 else "SELECT CMD(",
                 "%RPRINT '"tablet"(M"mailnum")' NODEL) NEWAPPL(ISR)"
                 end
                 else do
                 if message_ds_opt = "on" then
                    "SELECT CMD(",
                    "PR DS("mailtds") NOTRC DEST("tsomprt")" tsomprto
                    else "SELECT CMD(",
                    "PR DS('"tablet"(M"mailnum")') NOTRC DEST("tsomprt")
                        tsomprto
                 end
           mailactn = "Printed"
           call save_table
           mailsmsg = 'Printed'
           maillmsg = 'Message has been processed by the Rockwell PRINT
           end

        if zsel = "U" then do
           mailactn = "Un-Read"
           call save_table
           mailsmsg = 'Flaged'
           maillmsg = 'Message has been flaged for future reading'
           end

        if zsel = "C" then do
           "CONTROL DISPLAY SAVE"
           ispfds = "on"
           "DISPLAY PANEL(TMAILCML)"
           if rc = 0 then do
              call save_table
              mailsmsg = 'Changed'
              maillmsg = 'Message information has been updated'
              end
           end

        /* Perform logging of messages in this routine */
        if zsel = "L" then do
           "CONTROL DISPLAY SAVE"
           parse value null with logds lognum
           "VPUT (LOGDS LOGNUM)"
           if length(logsel) = 0 then log_n = ''
           if length(logsel) > 0 then log_n = logsel
           if pos(".",logsel) > 0 then log_n = strip(logsel,,'.')
           "Select CMD(%TMAILLOG LOG" log_n")"
           "VGET (LOGDS LOGNUM)"
           if length(lognum) = 0 then do
                 mailsmsg = 'Cancelled'
                 maillmsg = 'Log processing has been cancelled'
                 "SETMSG MSG(MAIL000)"
                 end
                 else do
                     call copy_to_log
                     mailsmsg = 'Logged'
                     maillmsg = 'Log processing successfully completed'
                     "SETMSG MSG(MAIL000)"
                     end
           "CONTROL DISPLAY Restore"
           end

        if zsel = "S" | zsel = "B" | zsel = "E" | zsel = "R" then do
           "CONTROL DISPLAY SAVE"
           ispfds = "on"
           x = listdsi(mailtds "norecall")
               select
                 when sysreason = 0  then x = "OK"
                 when sysreason = 9  then x = "OK"
                 when sysreason = 26 then x = "OK"
                 otherwise x = "NG"
                 end
           if length(mailtds) > 0 & x = "OK" & message_ds_opt = null the
              do until drc > 0
              if subopt <> null then do
                x = pos(".",subopt)
                if x > 0 then subopt = substr(subopt,x+1,1)
                end
              if subopt = null then do
                   "DISPLAY PANEL(TMAILFIL)"
                                 end
                 else do
                   zcmd = subopt
                   rc = 0
                      end
              drc = rc  /* save return code */
              if drc > 0 then do
                 mailsmsg = 'Processed'
                 maillmsg = 'File' mailtds 'has been processed'
                 "SETMSG MSG(MAIL000)"
                 mailactn = "File Select"
                 call save_table
                 end
            else do
                 select
                 when zcmd = 0 then do
                      "BROWSE DATASET('"tablet"(M"mailnum")')"
                      end
                 when zcmd = 1 then do
                      "BROWSE DATASET("mailtds")"
                      end
                 when zcmd = 2 then do
                      "EDIT DATASET("mailtds")"
                      end
                 when zcmd = 3 then do
                 "VGET (TSOMPRT) PROFILE"
                      if length(tsomprt) = 0 then
                      "SELECT CMD(",
                      "%RPRINT"  mailtds "NODEL) NEWAPPL(ISR)"
                      else
                      "SELECT CMD(",
                      "%RPRINT"  mailtds "DEST("tsomprt") NODEL) NEWAPPL
                      sel_msg = "on"
                      end
                 when zcmd = 4 then do
                      parse var mailsubj x1 x2 x3
                       x = pos(".",x3)
                       newname = substr(x3,x+1,length(x3)-x)
                      "DISPLAY PANEL(TMAILFRN)"
                      if rc = 0 then do
                             x = listdsi(newname "norecall")
                             if sysreason = 5 then do
                                     Address TSO,
                                     "RENAME" mailtds newname
                                      mailtds = newname
                                      mailactn = "Rename"
                              mailsmsg = 'File Renamed'
                              maillmsg = 'File' mailtds 'has been',
                                        'renamed to' newname
                              call save_table
                                             end
                              else do
                              mailsmsg = 'Rename Failure'
                              maillmsg = 'File' newname 'currently exist
                                         'choose another name'
                                             end
                      end
                 end  /* end of the '4' select */

                 when zcmd = 5 then do
                      "SELECT CMD(",
                      "%TMAILCPY" mailtds mailsubj mailfloc mailfid debu
                      sel_msg = "on"
                      end

                 when zcmd = 6 then do
                      Address TSO "PDS" mailtds
                      end

                 when zcmd = 7 then do
                      drc = 4
                      x = MSG("OFF")
                      Address TSO "DELETE" mailtds
                      mailsmsg = 'File Deleted'
                      maillmsg = 'File' mailtds 'has been deleted'
                      mailtds = null
                      call save_table
                      end

                 when zcmd = 8 then do
                      if pos(".SERVLINK",mailfds) > 0 then do
                         parse value mailfds with "A." ptfname ".SERVLIN
                         targdsn = "IBMLINK."ptfname
                         end
                         else targdsn = null
                      zcmd = null
                      "DISPLAY PANEL(TMAILUNT)"
                       if rc > 0 then do
                             mailsmsg = 'Cancelled'
                             maillmsg = 'Unterse processing for:' ,
                                          mailtds 'has been cancelled'
                             end
                      else do
                           Address TSO,
                           "%TMAILPTF" mailfds mailtds targdsn
                           sel_msg = "on"
                           end
                      end

                 when zcmd = 9 then do
                      zcmd = null
                      "DISPLAY PANEL(TMAILFFL)"
                         if rc > 0 then do
                            mailsmsg = 'Cancelled'
                            maillmsg = 'Forward of file:',
                                         mailtds 'has been cancelled'
                            end
                         else do
                            if ffnick <> null then do
                                Address TSO,
                               '%TMAILSND' ffnick 'DS('mailtds') Sendfil
                                           'nomsg' ffllog fflack
                               sel_msg = "on"
                               end
                             else do
                                Address TSO,
                               '%TMAILSND' ffnode'.'ffuser 'DS('mailtds'
                                           'Sendfile nomsg' ffllog fflac
                               sel_msg = "on"
                               end
                         end
                      end

                 otherwise nop;
                 end /* end select processing */
                 if subopt <> null then do
                       subopt = null
                       drc = 4
                       if sel_msg <> "on" then do
                          if mailsmsg = null then do
                             mailsmsg = 'Processed'
                             maillmsg = 'File' mailtds 'has been process
                             end
                          "SETMSG MSG(MAIL000)"
                          end
                          else sel_msg = "off"
                       mailactn = "File Select"
              call save_table
                       end
           end /* end actual processing */
           end
        else do
           if zsel = "S" | zsel = "B" | zsel = "R" then do
              if message_ds_opt = null then
                 "BROWSE DATASET('"tablet"(M"mailnum")')"
                 else
                 "BROWSE DATASET("mailtds")"
              mailactn = "Read"
              call save_table
              mailsmsg = 'Read'
              maillmsg = 'Message has been reviewed using ISPF BROWSE'
              end
              else if zsel = "E" then do
              if message_ds_opt = null then
                 "EDIT DATASET('"tablet"(M"mailnum")')"
                 else
                 "EDIT DATASET("mailtds")"
                 if rc = 0 then mailactn = "Edited"
                           else mailactn = "Read"
              call save_table
              mailsmsg = mailactn
              maillmsg = 'Message has been reviewed/updated using ISPF E
              end
           end
        end

        if zsel = "D" then do
           "CONTROL DISPLAY SAVE"
           ispfds = "on"
           dm = null
           if length(mailtds) > 0 then do
               x = listdsi(mailtds "norecall")
                   select
                     when sysreason = 0  then x = "OK"
                     when sysreason = 9  then x = "OK"
                     when sysreason = 26 then x = "OK"
                     otherwise x = "NG"
                     end
              if message_ds_opt = "on" then do
                 if sysreason = 9 then Address TSO "HDEL" mailtds
                 if sysreason = 0 then Address TSO "DEL"  mailtds
                 parse value null with mailtds dm
                 end
            if x = "OK" & message_ds_opt = null then do
              "DISPLAY PANEL(TMAILCFD)"
              hrc = rc
              if hrc = 8 then dm = "nono"
              if hrc = 0 then do /* delete the table entry */
                if pos(dmopt,"YES FILE") > 0 then do /* delete the data
                  if sysreason = 9,
                  then Address TSO "HDEL" mailtds
                  else Address TSO "DEL"  mailtds
                  dm = 'and related file' mailtds
                  end
                mailtds = null
              end
            else if pos(dmopt,"NO FILE") > 0 then dm = "nono"
            end
         end
         if dm <> "nono" then do
              "TBDELETE "ispf_table
              x = outtrap("x.",'*')
              rowcrp = 0
              Address TSO "DEL '"tablet"(M"mailnum")'"  /* delete messag
              x = outtrap('OFF')
              "TBSAVE "ispf_table" REPLCOPY LIBRARY("ispf_table")"
              mailsmsg = 'Deleted'
              maillmsg = 'Messages' dm 'have been deleted'
              end
              else do
                   mailsmsg = "Delete Cancelled"
                   maillmsg = "Mail delete has been cancelled, use DM to
                              "delete only the message"
                   end
        end

        if zsel = "DN" then do
           x = outtrap("x.",'*')
           Address TSO,
           "DEL '"tablet"(M"mailnum")'"  /* delete message */
           x = listdsi(mailtds "norecall")
               if sysreason = 9 then Address TSO "HDEL" mailtds
               if sysreason = 0 then Address TSO "DEL"  mailtds
           x = outtrap('OFF')
           "TBDELETE "ispf_table
           "TBSAVE "ispf_table" REPLCOPY LIBRARY("ispf_table")"
           mailsmsg = 'Deleted'
           maillmsg = 'Message (and file) have been deleted'
           end

        if zsel = "DM" then do
           x = outtrap("x.",'*')
           Address TSO,
           "DEL '"tablet"(M"mailnum")'"  /* delete message */
           x = outtrap('OFF')
           "TBDELETE "ispf_table
           "TBSAVE "ispf_table" REPLCOPY LIBRARY("ispf_table")"
           mailsmsg = 'Deleted'
           maillmsg = 'Message has been deleted'
           end

        if zsel = "DF" then do
           x = outtrap("x.",'*')
               x = listdsi(mailtds "norecall")
               if sysreason = 9 then Address TSO "HDEL" mailtds
               if sysreason = 0 then Address TSO "DEL"  mailtds
           x = outtrap('OFF')
           mailtds = null
           mailsmsg = 'Deleted'
           maillmsg = 'Data set has been deleted'
           end

        end /* end of zsel processing */


            if hcc = 0 & length(mailsmsg) > 0 then,
                       "SETMSG MSG(MAIL000)"

        end  /* end of do forever table processing */

        copy_to_log:
        /* The current message and ISPF table entry are copied by this
           routine from the primary TSO Mail data set and ISPF Table
           into the designated log data set and ISPF table. */

           /*  Check for available space before doing the log  */
           x = listdsi(logds "directory" "recall")
           if sysextents > 10 then newtable = "yes"
           if (sysadirblk-sysudirblk) < 5 then do
                newtable = "yes"
                sysadirblk = sysadirblk + 15
                end
           if newtable = "yes" then do
              new_logds = strip(logds,,"'")
              x = length(new_logds)
              old_logds = overlay('O',new_logds,x)
              new_logds = overlay('N',new_logds,x)
              x = MSG("OFF")
              Address TSO "DELETE '"new_logds"'"
              Address TSO,
              "Alloc ds('"new_logds"') NEW Like("table")"
              Address TSO "Free  ds('"new_logds"')"
              "LMINIT DATAID(tblin) DATASET("logds")"
               "LMINIT DATAID(tblout) DATASET('"new_logds"')"
               "LMCopy FROMID("tblin")",
                      "TODATAID("tblout") FROMMEM(*)"
               "LMFREE Dataid("tblin")"
               "LMFREE Dataid("tblout")"
             Address TSO
             "DELETE  '"old_logds"'"
             x = MSG("ON")
             "RENAME" logds "'"old_logds"'"
             "RENAME  '"new_logds"'" logds
             Address ISPEXEC
             newtable = null
             end

           "LIBDEF TM"lognum "DATASET ID("logds")"
           "TBOPEN TM"lognum "LIBRARY(TM"lognum") WRITE"
           mailactn = "Logged"
           "TBADD TM"lognum
           "TBCLOSE TM"lognum "LIBRARY(TM"lognum") REPLCOPY"
           "LIBDEF TM"lognum
           "TBDELETE "ispf_table
           "TBSAVE "ispf_table" REPLCOPY LIBRARY("ispf_table")"
           logdst = strip(logds,,"'")
           "LMINIT DATAID(msgin) DATASET('"tablet"')"
           "LMINIT DATAID(msgout) DATASET('"logdst"')"

           "LMMove FROMID("msgin")",
                  "TODATAID("msgout") FROMMEM(M"mailnum") REPLACE"

           "LMFREE Dataid("msgin")"
           "LMFREE Dataid("msgout")"
          return

        finfo1:    day      = substr(data.i,63,2)  /* day of month   */
                   month    = substr(data.i,66,3)  /* month name abr */
                   year     = substr(data.i,72,2)  /* year           */
                   mailtime = substr(data.i,75,8)  /* time hh:mm     */
                   mailtds  = null /* reset the target data set */
                   call fixdate
                   return

        finfo2:    mailfloc = substr(data.i,17,8)  /* from node name */
                   mailfid  = substr(data.i,26,8)  /* from userid    */
                   mailtid  = userid
                   mailtloc = center
                   return

        toinfo2:   mailtloc = substr(data.i,17,8)  /*  to node name  */
                   mailtid  = substr(data.i,26,8)  /*  to userid     */
                   return

        toinfo1:   day      = substr(data.i,63,2)  /* day of month   */
                   month    = substr(data.i,66,3)  /* month name abr */
                   year     = substr(data.i,72,2)  /* year           */
                   mailtime = substr(data.i,75,8)  /* time hh:mm     */
                   mailfid  = userid
                   mailfloc = center
                   call fixdate
                   return

        store_msg:
        if type = "F" | type = null then do
            /* type = null is not wanted in the table */
           /* turn off flag as this is an */
           msgcount = 0
           parse value null with mailsubj mailfds long_message,
                                 msg. mailtds type mailsmtp
           return     /* incomplete file receive     */
           end

        call getnum
        if mailactn = null then mailactn = 'Received'

        if mailfid =  "SMTP" then do
           mailfloc = null
           mailfid  = mailsmtp
           end

        if mailtid =  "SMTP" then do
           mailtloc = null
           mailtid  = mailsmtp
           end
        if mailfds = "X.RECEIVE.INVALID.FILE" then call do_invalid_file

        "TBADD "ispf_table

        mailsmtp = null

        mcount = mcount + 1
        "VPUT (MCOUNT FCOUNT)"
        if batch <> "on" & check <> "on" then do
           "CONTROL DISPLAY LOCK"
           "DISPLAY PANEL(TMAILWAT)"
           end
        else do
           if batch = "on" | safe = "on" then
           say "Message" mcount "has been added to the table with",
                msgcount "records"
           end

        if long_message <> "on" then do
           Address TSO
           "ALLOC FILE(MSG) DS('"tablet"(M"mailnum")') SHR REUSE"
           "EXECIO" msgcount "DISKW MSG (FINIS STEM msg."
           "FREE FILE(MSG)"
           Address ISPEXEC
           end
        else do
             mailtds =  "'"message_ds''mailnum"'"
             upper mailtds
             msgl.4 =   "Data set with your message is:" mailtds
             call save_table
             Address TSO
             "ALLOC FILE(MSG) DS("mailtds")",
                   " NEW LIKE("maildsn")"
             "EXECIO * DISKW MSG (FINIS STEM msg."
             "FREE FILE(MSG)"
             "ALLOC FILE(MSG) DS('"tablet"(M"mailnum")') SHR REUSE"
             "EXECIO *  DISKW MSG (FINIS STEM msgl."
             "FREE FILE(MSG)"
             Address ISPEXEC
             end
        msgcount = 0
        parse value null with mailsubj mailactn mailtds type msg. long_m
        return

        do_invalid_file:
         invalid. = null
         if "OK" <> sysdsn(mailtds) then return
        inv_dd = "INV"random()
        /*  Check space allocation for file *
         *  to ignore large files:          *
         *  > 10 blocks                     *
         *  > 4 tracks                      *
         *  > 1 cyl                         */
        call listdsi mailtds
        select
           when sysunits = "BLOCK" then
                if sysused > 10 then return
           when sysunits = "TRACK" then
                if sysused > 4  then return
           when sysunits = "CYLINDER" then
                if sysused > 1  then return
           otherwise nop
           end
        Address TSO
          "Alloc f("inv_dd") DS("mailtds") SHR"
          "Execio * Diskr" inv_dd "(Finis Stem invalid."
          "Free f("inv_dd")"
          profs_msg_hdr = 'FE'x"MSG"
          Select
             when left(invalid.1,4) = profs_msg_hdr then do
                  parse value invalid.1 with . "From:" ,
                     mailfid "--" mailfloc "To:",
                     mailtid "--" mailtloc maildatd mailtime
                  mailfid  = strip(mailfid)
                  mailfloc = strip(mailfloc)
                  mailtid  = strip(mailtid)
                  mailtloc = strip(mailtloc)
                  "Delete" mailtds
                  mailtds = null
                  mailfds = null
                  parse value maildatd with month '/' day '/' year
                  /* now verify that the month/day/year are valid */
                  if datatype(month) <> "NUM" then month = 00
                  if datatype(day)   <> "NUM" then day = 00
                  if datatype(year)  <> "NUM" then year = 00
                  month = month + 100
                  day   = day   + 100
                  maildatn = year''right(month,2)''right(day,2)
                  parse value invalid.3 with 7 subject 77 .
                  mailsubj = "Ack:" subject
                  msgcount = 5
                  msg. = null
                  msg.0 = 5
                  msg.1 = " From:    " mailfid "at" mailfloc "  on " mai
                           mailtime
                  msg.2 = " To:      " mailtid "at" mailtloc
                  msg.3 = " Subject: " subject
                  msg.4 = " "
                  msg.5 = left(invalid.2,79)
                  end
             otherwise nop;
          end
        Address ISPEXEC
        return

        save_table:
              "TBMOD "ispf_table
              "TBSAVE "ispf_table" REPLCOPY LIBRARY("ispf_table")"
              return

        getnum:  Address TSO
                   if mailnum = 0 then do
                   /* open - read tsomnum */
                   tsomnum = "TS"random()
                   tso_numds = sysdsn("'"tablet"(TSOMNUM)'")
                   "Alloc f("tsomnum") ds('"tablet"(TSOMNUM)') SHR"
                   tsomnum_alloc = "on"
                   if tso_numds = "OK" then
                      "Execio * diskr" tsomnum "(Finis Stem numi."
                      else do
                           numi.0 = 1
                           numi.1 = 0
                           end
                      if numi.0 = 2 then do
                         mailnum = substr(numi.2,50,7)
                         end
                         else mailnum = numi.1
                   end
                dj = date(o)
                tyear = substr(dj,1,2)
                if tyear <> substr(mailnum,1,2) then do
                   mailnum = tyear*100000
                   end
                if mailnum = null then do
                   mailnum = tyear*100000
                   end
                else mailnum = mailnum + 1
                /* now save it */
                num. = null
                num.1 = mailnum
                "Execio * diskw" tsomnum "(Finis stem num."
                Address ISPEXEC
                return

        fixdate:   x = wordpos(month,months)
                   x = x + 100
                   month = right(x,2)
                   maildatn = year''month''day
                   maildatd = month"/"day"/"year
                   return

        fixsubj:   if "Message: " = substr(mailsubj,1,9) then
                   sendsubj = substr(mailsubj,9,length(mailsubj)-9)
                   else
                   sendsubj = mailsubj
                   return
./ ADD NAME=TSOMAILM 0100-91352-91352-1336-00008-00008-00000-$A1238
/*  Rexx EXEC for the TSO Mail Menu */

arg option

if length(option) = 0 then
   Address ISPEXEC "SELECT PANEL(TMAILMNU) NEWAPPL(MAIL)"
   else
   Address ISPEXEC "SELECT PANEL(TMAILMNU) OPT("option") NEWAPPL(MAIL)"
