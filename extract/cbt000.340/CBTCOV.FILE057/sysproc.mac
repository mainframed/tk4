./ ADD NAME=BROWSE                                 12SEP93 17.34 --
ISREDIT MACRO (DSNAME)
CONTROL NOMSG MAIN NOLIST NOCONLIST NOSYMLIST
IF &STR(&DSNAME) = ? THEN +
  DO
    ISPEXEC SELECT PGM(ISPTUTOR) PARM(#BROWSE)
    EXIT
  END
IF &STR(&DSNAME) ^= &STR() THEN -
  DO
    ISREDIT (EDITDSN) = DATASET
    SET &RPAREN = &NRSTR())
    /*  DATASET NAME? */
    IF &SYSINDEX(&RPAREN,&STR(&DSNAME),1) < 1 AND -
       &SYSINDEX(&STR('),&STR(&DSNAME),1) < 1 AND -
       &SYSINDEX(&STR(.),&STR(&DSNAME),1) < 1 THEN -
      DO
        /*  MEMBER NAME OR PATTERN? */
        IF &STR(&SYSDSN('&EDITDSN(&DSNAME)')) = &STR(OK) OR -
           &SYSINDEX(&STR(*),&STR(&DSNAME),1) > 0 THEN -
          SET DSNAME = &STR('&EDITDSN(&DSNAME)')
      END
    IF &SUBSTR(1,&STR(&DSNAME)) = ' -
      THEN -
        SET DSNS = &SUBSTR(2:&LENGTH(&STR(&DSNAME))-1,&STR(&DSNAME))
      ELSE -
        SET DSNS = &STR(&SYSUID..&DSNAME)
    ISPEXEC CONTROL ERRORS RETURN
    ISPEXEC BROWSE DATASET('&DSNS')
    SET &BROWCC = &LASTCC
    IF &BROWCC > 4 THEN -
      DO
        SET &ZEDSMSG = &STR(DSN OR MEMBER NOT FOUND)
        SET &ZEDLMSG = &STR(DATASET '&DSNS' NOT FOUND)
        ISPEXEC SETMSG MSG(ISRZ001W)
      END
    ISPEXEC CONTROL ERRORS CANCEL
  END
ELSE -
  DO
    ISPEXEC SELECT PGM(ISRBRO)
  END
/* J. KALINICH, X4521 */
/* EDIT MACRO TO INVOKE BROWSE                          */
./ ADD NAME=BROWZE                                 12SEP93 17.34 --
PROC 0 DEBUG DATASET() PANEL(ISRBROBF)
IF &DEBUG = &STR(DEBUG) THEN -
  CONTROL MSG NOFLUSH LIST CONLIST SYMLIST PROMPT ASIS
ELSE -
  CONTROL NOMSG NOFLUSH NOLIST NOCONLIST NOSYMLIST ASIS
ISPEXEC CONTROL ERRORS RETURN
ISPEXEC BROWSE DATASET('&DATASET') PANEL(&PANEL)
ISPEXEC CONTROL ERRORS CANCEL
END
/* J.KALINICH, X4521 */
/* CLIST TO INVOKE BROWSE WITH OPTIONAL CUSTOM BROWSE PANEL      */
./ ADD NAME=COMPUTE                                12SEP93 17.34 --
/* REXX -
 +------------------------------------------------------------------+
 | Name:       COMPUTE                                              |
 | Type:       REXX exec                                            |
 | Purpose:    Calculator                                           |
 | Release:    MVS/ESA v3.1.3 and TSO/E v2.1                        |
 | Programmer: Norman Pearl                                         |
 |             TSO Times $250 winner, 1992                          |
 | Abstract:   The result of any valid Rexx expression will be      |
 |             displayed in the ISPF message area.                  |
 | Mods:       If no expression is given as an argument, then a     |
 |             pop-up window is displayed that prompts for input    |
 |             (ISPF mode only).                                    |
 +------------------------------------------------------------------+ */
TRACE OFF
NUMERIC DIGITS 20  /* M.F. Cowlishaw */
ARG formula
IF formula = '' &,
   SYSVAR('SYSISPF') = 'ACTIVE' THEN
  DO
    DO WHILE poprc < 8
      zwinttl = 'Calculator'
      ADDRESS ISPEXEC "ADDPOP ROW(3) COLUMN(1)"
      ADDRESS ISPEXEC "DISPLAY PANEL(CALCP)"
      poprc = rc
      ADDRESS ISPEXEC "REMPOP"
      formula = xpreshun
      INTERPRET 'result = ' formula
      zedsmsg = result
      zedlmsg = formula '===>' result
      ADDRESS ISPEXEC "SETMSG MSG(ISRZ001W)"
    END
    zedsmsg = ''
    zedlmsg = ''
    ADDRESS ISPEXEC "SETMSG MSG(ISRZ000W)"
    EXIT
  END
INTERPRET 'result = ' formula
IF SYSVAR('SYSISPF') = 'ACTIVE' THEN
  DO
    zedsmsg = result
    zedlmsg = formula '===>' result
    ADDRESS ISPEXEC "SETMSG MSG(ISRZ001W)"
  END
ELSE
  SAY formula '===>' result
EXIT
/* J. KALINICH, X4521 */
/* EXEC TO COMPUTE EXPRESSIONS (from TSO Times)        */
./ ADD NAME=DSK33XX                                12SEP93 17.34 --
PROC 0 DEBUG
IF &DEBUG = &STR(DEBUG) THEN -
  CONTROL MSG NOFLUSH LIST CONLIST SYMLIST PROMPT
ELSE -
  CONTROL NOMSG NOFLUSH NOLIST NOCONLIST NOSYMLIST
PANEL: +
ISPEXEC DISPLAY PANEL(DSK33XX)
IF &LASTCC = 8 THEN EXIT
CALC3350: +
IF &DLEN > 19069 THEN -
  DO
    SET &UTRK5 = 0
    SET &PTRK5 = 0
    SET &WTRK5 = 0
    SET &BTRK5 = 0
    SET &BCYL5 = 0
    SET &TTRK5 = 0
    SET &TCYL5 = 0
    SET &TVOL5 = 0
    GOTO CALC3380
  END
IF &KLEN = 0 OR &LENGTH(&KLEN) = 0 -
  THEN -
    DO
      SET C = 185
    END
  ELSE -
    DO
      SET C = 267
    END
SET BTRK5 = 19254 / (&C + &KLEN + &DLEN)
IF &NUMREC < &BTRK5 -
  THEN -
    SET UTRK5 = &DLEN * &NUMREC
  ELSE -
    SET UTRK5 = &DLEN * &BTRK5
SET WTRK5 = 19069 - &UTRK5
SET BCYL5 = 30 * &BTRK5
SET TTRK5 = &NUMREC // &BTRK5
IF &TTRK5 = 0 -
  THEN -
    SET TTRK5 = &NUMREC / &BTRK5
  ELSE -
    SET TTRK5 = (&NUMREC / &BTRK5) + 1
SET TCYL5 = &TTRK5 // 30
IF &TCYL5 = 0 -
  THEN -
    SET TCYL5 = &TTRK5 / 30
  ELSE -
    SET TCYL5 = (&TTRK5 / 30) + 1
/* SINGLE DENSITY */
SET TVOL5 = &TCYL5 // 555
IF &TVOL5 = 0 -
  THEN -
    SET TVOL5 = &TCYL5 / 555
  ELSE -
    SET TVOL5 = (&TCYL5 / 555) + 1
SET PTRK5 = (&UTRK5 * 1000) / 19069
IF &PTRK5 > 999 THEN -
  DO
    SET PTRK5 = &SUBSTR(1:3,&PTRK5)&STR(.)&SUBSTR(4:4,&PTRK5)
    GOTO CALC3380
  END
IF &PTRK5 > 99 THEN -
  DO
    SET PTRK5 = &SUBSTR(1:2,&PTRK5)&STR(.)&SUBSTR(3:3,&PTRK5)
    GOTO CALC3380
  END
IF &PTRK5 > 9 THEN -
  DO
    SET PTRK5 = &SUBSTR(1:1,&PTRK5)&STR(.)&SUBSTR(2:2,&PTRK5)
    GOTO CALC3380
  END
SET PTRK5 = &STR(.)&SUBSTR(1:1,&PTRK5)
CALC3380: +
IF &DLEN > 47476 THEN -
  DO
    SET &UTRK8 = 0
    SET &PTRK8 = 0
    SET &WTRK8 = 0
    SET &BTRK8 = 0
    SET &BCYL8 = 0
    SET &TTRK8 = 0
    SET &TCYL8 = 0
    SET &TVOL8 = 0
    GOTO CALC3390
  END
IF &KLEN = 0 OR &LENGTH(&KLEN) = 0 -
  THEN -
    DO
      SET C = 15
      SET K = 0
    END
  ELSE -
    DO
      SET C = 22
      SET K = (&KLEN + 12) // 32
      IF &K = 0 -
        THEN -
          SET K = (&KLEN + 12) / 32
        ELSE -
          SET K = ((&KLEN + 12) / 32) + 1
    END
SET D = (&DLEN + 12) // 32
IF &D = 0 -
  THEN -
    SET D = (&DLEN + 12) / 32
  ELSE -
    SET D = ((&DLEN + 12) / 32) + 1
SET BTRK8 = 1499 / (&C + &K + &D)
IF &NUMREC < &BTRK8 -
  THEN -
    SET UTRK8 = &DLEN * &NUMREC
  ELSE -
    SET UTRK8 = &DLEN * &BTRK8
SET WTRK8 = 47476 - &UTRK8
SET BCYL8 = 15 * &BTRK8
SET TTRK8 = &NUMREC // &BTRK8
IF &TTRK8 = 0 -
  THEN -
    SET TTRK8 = &NUMREC / &BTRK8
  ELSE -
    SET TTRK8 = (&NUMREC / &BTRK8) + 1
SET TCYL8 = &TTRK8 // 15
IF &TCYL8 = 0 -
  THEN -
    SET TCYL8 = &TTRK8 / 15
  ELSE -
    SET TCYL8 = (&TTRK8 / 15) + 1
/* DOUBLE DENSITY */
SET TVOL8 = &TCYL8 // 1770
IF &TVOL8 = 0 -
  THEN -
    SET TVOL8 = &TCYL8 / 1770
  ELSE -
    SET TVOL8 = (&TCYL8 / 1770) + 1
SET PTRK8 = (&UTRK8 * 1000) / 47476
IF &PTRK8 > 999 THEN -
  DO
    SET PTRK8 = &SUBSTR(1:3,&PTRK8)&STR(.)&SUBSTR(4:4,&PTRK8)
    GOTO CALC3390
  END
IF &PTRK8 > 99 THEN -
  DO
    SET PTRK8 = &SUBSTR(1:2,&PTRK8)&STR(.)&SUBSTR(3:3,&PTRK8)
    GOTO CALC3390
  END
IF &PTRK8 > 9 THEN -
  DO
    SET PTRK8 = &SUBSTR(1:1,&PTRK8)&STR(.)&SUBSTR(2:2,&PTRK8)
    GOTO CALC3390
  END
SET PTRK8 = &STR(.)&SUBSTR(1:1,&PTRK8)
CALC3390: +
IF &KLEN = 0 OR &LENGTH(&KLEN) = 0 -
  THEN -
    DO
      SET C = 19
      SET K = 0
    END
  ELSE -
    DO
      SET C = 28
      SET KN = (&KLEN + 6) // 232
      IF &KN = 0 -
        THEN -
          SET KN = (&KLEN + 6) / 232
        ELSE -
          SET KN = ((&KLEN + 6) / 232) + 1
      SET K = (&KLEN + (&KN * 6) + 6) // 34
      IF &K = 0 -
        THEN -
          SET K = (&KLEN + (&KN * 6) + 6) / 34
        ELSE -
          SET K = ((&KLEN + (&KN * 6) + 6) / 34) + 1
    END
SET DN = (&DLEN + 6) // 232
IF &DN = 0 -
  THEN -
    SET DN = (&DLEN + 6) / 232
  ELSE -
    SET DN = ((&DLEN + 6) / 232) + 1
SET D = (&DLEN + (&DN * 6) + 6) // 34
IF &D = 0 -
  THEN -
    SET D = (&DLEN + (&DN * 6) + 6) / 34
  ELSE -
    SET D = ((&DLEN + (&DN * 6) + 6) / 34) + 1
SET BTRK9 = 1729 / (&C + &K + &D)
IF &NUMREC < &BTRK9 -
  THEN -
    SET UTRK9 = &DLEN * &NUMREC
  ELSE -
    SET UTRK9 = &DLEN * &BTRK9
SET WTRK9 = 56664 - &UTRK9
SET BCYL9 = 15 * &BTRK9
SET TTRK9 = &NUMREC // &BTRK9
IF &TTRK9 = 0 -
  THEN -
    SET TTRK9 = &NUMREC / &BTRK9
  ELSE -
    SET TTRK9 = (&NUMREC / &BTRK9) + 1
SET TCYL9 = &TTRK9 // 15
IF &TCYL9 = 0 -
  THEN -
    SET TCYL9 = &TTRK9 / 15
  ELSE -
    SET TCYL9 = (&TTRK9 / 15) + 1
/* DOUBLE DENSITY */
SET TVOL9 = &TCYL9 // 2226
IF &TVOL9 = 0 -
  THEN -
    SET TVOL9 = &TCYL9 / 2226
  ELSE -
    SET TVOL9 = (&TCYL9 / 2226) + 1
SET PTRK9 = (&UTRK9 * 1000) / 56664
IF &PTRK9 > 999 THEN -
  DO
    SET PTRK9 = &SUBSTR(1:3,&PTRK9)&STR(.)&SUBSTR(4:4,&PTRK9)
    GOTO PANEL
  END
IF &PTRK9 > 99 THEN -
  DO
    SET PTRK9 = &SUBSTR(1:2,&PTRK9)&STR(.)&SUBSTR(3:3,&PTRK9)
    GOTO PANEL
  END
IF &PTRK9 > 9 THEN -
  DO
    SET PTRK9 = &SUBSTR(1:1,&PTRK9)&STR(.)&SUBSTR(2:2,&PTRK9)
    GOTO PANEL
  END
SET PTRK9 = &STR(.)&SUBSTR(1:1,&PTRK9)
GOTO PANEL
END
/* J.KALINICH, X4521 */
/* CLIST TO COMPUTE 3350/3380/3390 SPACE CALCULATIONS            */
./ ADD NAME=DVOL                                   12SEP93 17.34 --
PROC 0 DEBUG
IF &DEBUG = &STR(DEBUG) THEN -
  CONTROL MSG NOFLUSH LIST CONLIST SYMLIST PROMPT
ELSE -
  CONTROL MSG NOFLUSH NOLIST NOCONLIST NOSYMLIST
PANEL: +
ISPEXEC DISPLAY PANEL(DVOL)
IF &LASTCC = 8 THEN EXIT
CREATE: +
ISPEXEC TBCREATE DVOL NAMES(DVOLSER DVOLF1 DVOLUNIT DVOLF2 +
  DVOLTOT DVOLF3 DVOLLINE) NOWRITE REPLACE
IF &LASTCC > 4 THEN -
  DO
    WRITE TBCREATE FAILED
    EXIT
  END
SET &VOL = 1
/* PROCESS ALL 5 VOLUMES */
DO WHILE &VOL < 6
  SET LINELIM = 2000
  SET SYSOUTTRAP = &LINELIM
  CONTROL NOPROMPT
  IF &VOL = 1 THEN -
    DVOL &DSER1 &DTYPE
  IF &VOL = 2 THEN -
    IF &DSER2 = &STR() THEN -
      GOTO NEXTVOL
    ELSE -
      DVOL &DSER2 &DTYPE
  IF &VOL = 3 THEN -
    IF &DSER3 = &STR() THEN -
      GOTO NEXTVOL
    ELSE -
      DVOL &DSER3 &DTYPE
  IF &VOL = 4 THEN -
    IF &DSER4 = &STR() THEN -
      GOTO NEXTVOL
    ELSE -
      DVOL &DSER4 &DTYPE
  IF &VOL = 5 THEN -
    IF &DSER5 = &STR() THEN -
      GOTO NEXTVOL
    ELSE -
      DVOL &DSER5 &DTYPE
  SET MAXLINE = &SYSOUTLINE
  IF &DTYPE = &STR(SHORT) THEN -
    SET NUM = 3
  ELSE -
    SET NUM = 1
  DO WHILE &NUM ^> &MAXLINE AND &NUM ^> &LINELIM
    SET SYSSCAN = 0
    SET HVAL1 = &SYSOUTLINE
    SET SYSSCAN = 1
    SET HVAL2 = &HVAL1&NUM
    SET SYSSCAN = 16
    SET &DVOLSER  = &SUBSTR(1:6,&STR(&HVAL2))
    SET &DVOLF1   = &SUBSTR(8:10,&STR(&HVAL2))
    SET &DVOLUNIT = &SUBSTR(12:15,&STR(&HVAL2))
    SET &DVOLF2   = &SUBSTR(17:40,&STR(&HVAL2))
    SET &DVOLTOT  = &SUBSTR(42:46,&STR(&HVAL2))
    SET &DVOLF3   = &SUBSTR(48:80,&STR(&HVAL2))
    SET &DVOLLINE = &SUBSTR(1:80,&STR(&HVAL2))
    ISPEXEC TBADD DVOL
    IF &LASTCC NE 0 THEN -
      DO
        WRITE TBADD FAILED
      END
    SET NUM = &NUM + 1
  END
  NEXTVOL: +
    SET VOL = &VOL + 1
END
SORT: +
IF &DTYPE = &STR(SHORT) THEN -
  DO
    ISPEXEC TBSORT DVOL FIELDS(DVOLUNIT,C,D,DVOLSER,C,A)
    SET &KEY2 = &STR(SKEY-1) /* PRIMARY SORT KEY */
    SET &KEY1 = &STR(SKEY-2) /* SECONDARY SORT KEY */
    SET &KEY3 = &STR( )
  END
ISPEXEC TBTOP  DVOL
ISPEXEC VGET (ZSCR) PROFILE
DISPLAY: +
SET CSSR = 1
SET RC   = 0
DO WHILE &RC < 8
  ISPEXEC TBDISPL DVOL  PANEL(DVOLTBL&SUBSTR(1:1,&DTYPE)) +
    CURSOR(ZCMD) CSRROW(&CSSR)
  SET RC = &LASTCC
  IF &LENGTH(&STR(&ZCMD)) > 2 THEN -
    IF &SUBSTR(1:2,&ZCMD) = &STR(F ) OR -
       &SUBSTR(1:2,&ZCMD) = &STR(L ) THEN -
      IF &DTYPE = &STR(SHORT) THEN -
        DO
            DO
              ISPEXEC TBVCLEAR DVOL
              SET DVOLSER = &SUBSTR(3:&LENGTH(&STR(&ZCMD)),&STR(&ZCMD))+
                            &STR(*)
              ISPEXEC TBTOP  DVOL
              ISPEXEC TBSARG DVOL
              ISPEXEC TBSCAN DVOL
              ISPEXEC TBQUERY DVOL POSITION(CSSR)
            END
        END
  IF &LENGTH(&STR(&ZCMD)) > 5 THEN -
    IF &SUBSTR(1:5,&ZCMD) = &STR(SORT) THEN -
      IF &DTYPE = &STR(SHORT) THEN -
        DO
          SET &SORTKEY = DVOLSER
          SET &SORTSEQ = A
          IF &SUBSTR(6:6,&ZCMD) = &STR(S) THEN -
            DO
              SET &SORTKEY = DVOLSER
              SET &SORTSEQ = A
              SET &KEY2 = &STR(SKEY-1) /* PRIMARY SORT KEY */
              SET &KEY1 = &STR(SKEY-2) /* SECONDARY SORT KEY */
              SET &KEY3 = &STR( )
            END
          IF &SUBSTR(6:6,&ZCMD) = &STR(T) THEN -
            DO
              SET &SORTKEY = DVOLTOT
              SET &SORTSEQ = D
              SET &KEY2 = &STR(SKEY-1) /* PRIMARY SORT KEY */
              SET &KEY1 = &STR( )
              SET &KEY3 = &STR(SKEY-2) /* SECONDARY SORT KEY */
            END
          ISPEXEC TBSORT DVOL +
            FIELDS(DVOLUNIT,C,D,&SORTKEY,C,&SORTSEQ)
          ISPEXEC TBTOP  DVOL
        END
  IF &LENGTH(&STR(&ZCMD)) = 4 THEN -
    IF &SUBSTR(1:4,&ZCMD) = &STR(SORT) THEN -
      IF &DTYPE = &STR(SHORT) THEN -
        DO
          SET &KEY2 = &STR(SKEY-1) /* PRIMARY SORT KEY */
          SET &KEY1 = &STR(SKEY-2) /* SECONDARY SORT KEY */
          SET &KEY3 = &STR( )
          ISPEXEC TBSORT DVOL +
            FIELDS(DVOLUNIT,C,D,DVOLSER,C,A)
          ISPEXEC TBTOP  DVOL
        END
END
IF &RC = 8 THEN -
  DO
    ISPEXEC TBCLOSE DVOL
    GOTO PANEL
  END
GOTO DISPLAY
/* J. KALINICH, X4521 */
/* CLIST TO DISPLAY DISK FREE SPACE USING DVOL (CBT FILE 296) */
./ ADD NAME=EB                                     12SEP93 17.34 --
PROC 0 DEBUG
IF &DEBUG = &STR(DEBUG) THEN -
  CONTROL MSG NOFLUSH LIST CONLIST SYMLIST PROMPT
ELSE -
  CONTROL NOMSG NOFLUSH NOLIST NOCONLIST NOSYMLIST
ISPEXEC VGET (EB1  EB2  EB3  EB4  EB5  EB6  EB7  EB8  EB9  EB10 +
              EB11 EB12 EB13 EB14 EB15 EB16 EB17 EB18 EB19 +
              EM1  EM2  EM3  EM4  EM5  EM6  EM7  EM8  EM9  EM10 +
              EM11 EM12 EM13 EM14 EM15 EM16 EM17 EM18 EM19) PROFILE
ISPEXEC VGET ZTRAIL
IF &LENGTH(&STR(&ZTRAIL)) > 0 THEN -
  DO
    ISPEXEC  CONTROL NONDISPL ENTER
    SET PDS = &STR(&ZTRAIL)
  END
PANEL: +
ISPEXEC DISPLAY PANEL(EB01A) MSG(&MSGID)
IF &LASTCC > 0 THEN EXIT
SET MSGID = &STR()
IF &PDS = 0 THEN -
  DO
    SET INDX = 1
    DO WHILE &INDX < 20
      SET HOLD = &&EB&INDX
      SET EO&INDX = &HOLD
      SET INDX = &INDX + 1
    END
    ISPEXEC DISPLAY PANEL(EB01B)
    SET HOLDCC = &LASTCC
    IF &HOLDCC = 0 THEN -
      DO
        SET INDX = 1
        DO WHILE &INDX < 20
          SET OLD = &&EO&INDX
          SET NEW = &&EB&INDX
          IF &LENGTH(&NEW) > 0 AND &OLD ^= &NEW THEN -
            DO
              ALLOC DA(&NEW) SHR
              IF &LASTCC = 0 THEN -
                DO
                  FREE DA(&NEW)
                  SET EO&INDX = &NEW
                END
              ELSE -
                DO
                  ISPEXEC DISPLAY PANEL(EB01B) MSG(EB005) +
                     CURSOR(EB&INDX)
                  SET HOLDCC = &LASTCC
                  IF &HOLDCC > 0 THEN -
                    DO
                      SET INDXB = 1
                      DO WHILE &INDXB < 20
                        SET HOLD = &&EO&INDXB
                        SET EB&INDXB = &HOLD
                        SET INDXB = &INDXB + 1
                      END
                      SET INDX = 20
                    END
                  ELSE -
                    SET INDX = 0
                END
            END
          SET INDX = &INDX + 1
        END
        IF &HOLDCC = 0 THEN -
          DO
            ISPEXEC VPUT (EB1 EB2 EB3 EB4 EB5 EB6 EB7 EB8 EB9 EB10 +
                EB11 EB12 EB13 EB14 EB15 EB16 EB17 EB18 EB19 +
                EM1  EM2  EM3  EM4  EM5  EM6  EM7  EM8  EM9  EM10 +
                EM11 EM12 EM13 EM14 EM15 EM16 EM17 EM18 EM19) PROFILE
            SET MSGID = &STR(EB004)
          END
      END
  END
ELSE -
  IF &PDS = 20 OR &LENGTH(&DSNAME) = 0 THEN -
    ISPEXEC SELECT PGM(ISREDIT)
  ELSE -
    DO
      IF &STR(&MODE) = E OR &STR(&MODE) = B THEN -
        DO
          IF &STR(&MODE) = B THEN -
            SET MODE = BROWSE
          ELSE -
            SET MODE = EDIT
          ISPEXEC CONTROL ERRORS RETURN
          IF &STR(&MEMBER) = &STR() THEN -
            ISPEXEC &MODE DATASET(&DSNAME)
          ELSE -
            DO
              IF &SUBSTR(1:1,&DSNAME) = &STR(') THEN -
                DO
                  SET DSNAME = &SUBSTR(2:&LENGTH(&DSNAME)-1,+
                    &DSNAME)
                  ISPEXEC &MODE DATASET('&DSNAME(&STR(+
                    &MEMBER))')
                END
              ELSE -
                ISPEXEC &MODE DATASET(&DSNAME(&STR(&MEMBER)))
            END
          SET HOLDCC = &LASTCC
          ISPEXEC CONTROL ERRORS CANCEL
          IF &HOLDCC = 14 AND &MODE = &STR(BROWSE) THEN -
            SET MSGID = &STR(EB001)
          IF &HOLDCC = 14 AND &MODE = &STR(EDIT) THEN -
            SET MSGID = &STR(EB006)
          IF &HOLDCC = 16 THEN -
            SET MSGID = &STR(EB007)
          IF &HOLDCC = 20 THEN -
            SET MSGID = &STR(EB008)
        END
      ELSE -
        DO
          IF &STR(&MODE) = &STR(LE) THEN -
            DO
              IF &SYSINDEX(&STR(*),&STR(&MEMBER),1) > 0 OR -
                &STR(&MEMBER) = &STR() THEN -
                SET &CMD = &STR(LIST)
              ELSE -
                SET &CMD = &STR(EDIT)
              ISPEXEC SELECT PGM(ELIPS) +
                NEWAPPL(LIB@) +
                NEWPOOL +
                PARM( +
                     CMD('&CMD &MEMBER') +
                     DSN(&DSNAME) +
                     )
            END
          IF &STR(&MODE) = &STR(LB) THEN -
            DO
              IF &SYSINDEX(&STR(*),&STR(&MEMBER),1) > 0 OR -
                &STR(&MEMBER) = &STR() THEN -
                SET &CMD = &STR(LIST)
              ELSE -
                SET &CMD = &STR(BROWSE)
              ISPEXEC SELECT PGM(ELIPS) +
                NEWAPPL(LIB@) +
                NEWPOOL +
                PARM( +
                     CMD('&CMD &MEMBER') +
                     DSN(&DSNAME) +
                     )
            END
          IF &STR(&MODE) = &STR(PDS) THEN -
            DO
              SET &PDSPDSN = &STR(&DSNAME)
              ISPEXEC VPUT PDSPDSN SHARED
              ISPEXEC CONTROL NONDISPL ENTER
              ISPEXEC SELECT PANEL(PDS@PRIM)
            END
        END
    END
GOTO PANEL
EXIT CODE(0)
/* J. KALINICH/M. RESCHKE, X4521                            */
/* CLIST TO EDIT/BROWSE A MENU OF LIBRARIES                 */
/*                                                          */
/* CLIST FUNCTIONS:                                         */
/*                                                          */
/* 1.  ISPF EDIT/BROWSE FOR PDS AND SEQUENTIAL DATASETS     */
/* 2.  LIBRARIAN ELIPS EDIT/BROWSE FOR LIBRARIAN DATASETS   */
/* 3.  PDS FUNCTIONS FOR PDS AND SEQUENTIAL DATASETS        */
./ ADD NAME=EOL                                    12SEP93 17.34 --
/* REXX */
ADDRESS ISREDIT
"ISREDIT MACRO (HELP)"
TRACE
IF help = '?' |,
   help = 'help' THEN
  DO
    ADDRESS ISPEXEC "DISPLAY PANEL(#EOL)"
    EXIT 1
  END
"ISREDIT (CL,CC) = CURSOR"
IF cl = 0 THEN EXIT
"ISREDIT (WIDTH) = DATA_WIDTH"
"ISREDIT (LINE) = LINE " cl
DO cc = width to 1 by -1
  IF SUBSTR(line,cc,1) /= ' ' THEN
    LEAVE
END
IF cc = width THEN
  "ISREDIT CURSOR = " cl cc
ELSE
  "ISREDIT CURSOR = " cl cc+1
EXIT
/* J. KALINICH, X4521 */
/* EDIT MACRO TO SET CURSOR AT END OF CURRENT SCREEN LINE          */
./ ADD NAME=FX                                     12SEP93 17.34 --
/* SPF/PC Version 3.0 */
"ISREDIT MACRO (FXSTRING COL1 COL2)"
/*                                                                    */
/* FX Edit Macro - FIND ALL in eXcluded lines (incl seq numbers)      */
/*                                                                    */
/*    1 Oct 91 - Support FIRST/LAST columns as parameters             */
/*    9 Mar 92 - Support CLIST &variables as string arguments         */
/*   21 Apr 92 - Support (P)icture, He(X), (T)ext, and (C)haracter    */
/*               string arguments                                     */
/*   14 May 93 - Convert to Rexx for SPF/PC Version 3.0               */
/*   20 May 93 - Quoted strings must be entered as:  FX "'edit mac'"  */
/*               because of multiple arguments on macro prototype     */
/*                                                                    */
TRACE
IF fxstring = "" THEN
  DO
    zedsmsg = "ENTER FIND STRING"
    zedlmsg = "FX REQUIRES A STRING AS AN ARGUMENT"
    "ISPEXEC SETMSG MSG(ISRZ001W)"
    EXIT 12
  END
IF DATATYPE(fxstring) = "NUM" THEN
  fxstring = "'"fxstring"'"
IF SUBSTR(fxstring,1,2) = "C'" |,
   SUBSTR(fxstring,1,2) = "c'" |,
   SUBSTR(fxstring,1,2) = "P'" |,
   SUBSTR(fxstring,1,2) = "p'" |,
   SUBSTR(fxstring,1,2) = "T'" |,
   SUBSTR(fxstring,1,2) = "t'" |,
   SUBSTR(fxstring,1,2) = "X'" |,
   SUBSTR(fxstring,1,2) = "x'" |,
   SUBSTR(fxstring,1,1) = "'"  |,
   SUBSTR(fxstring,1,1) = '"'     THEN
  quote = ''
ELSE
  quote = "'"
"ISREDIT (STAT,VALUE) = NUMBER"  /* SAVE NUMBER SETTING */
"ISREDIT NUMBER OFF"             /* SEARCH SEQUENCE NUMBERS ON 'FIND' */
"ISREDIT EXCLUDE ALL"
"ISPEXEC CONTROL ERRORS RETURN"
"ISREDIT FIND ALL" fxstring col1 col2
 findcc = rc
"ISREDIT (FINDS) = FIND_COUNTS"
"ISREDIT (LEFT,RIGHT) = BOUNDS"
SELECT
       WHEN col1 = ""  &,
            col2 = ""  THEN
         NOP
       OTHERWISE
         DO
           IF col1 ^= "" THEN
             left = col1
           IF col2 ^= "" THEN
             right = col2
           IF col1 ^= "" &,
                col2  = "" THEN
             right = (left + LENGTH(fxstring)) - 1
         END
END  /* SELECT */
IF findcc > 0
  THEN
    DO
      zedsmsg = "NO CHARS "quote||fxstring||quote" FOUND"
      zedlmsg = "CHARS "quote||fxstring||quote" - NOT FOUND "||,
                "ON ANY LINES (COLS "left+0" TO "right+0")."
      "ISPEXEC SETMSG MSG(ISRZ001W)"
      "ISREDIT RESET EXCLUDED"
    END
  ELSE
    DO
      zedsmsg = finds+0" CHARS "quote||fxstring||quote
      zedlmsg = "CHARS "quote||fxstring||quote" FOUND "||,
                 finds+0" TIMES WITHIN COLUMNS "left+0" TO "right+0"."
      "ISPEXEC SETMSG MSG(ISRZ000W)"
    END
IF stat = "OFF" THEN
  NOP
ELSE
  DO
    PARSE VAR value std cobol display
    restore = ""
    IF std = "STD" THEN
      restore = restore || " " || std
    IF cobol = "COBOL" THEN
      restore = restore || " " || cobol
    IF display = "DISPLAY" THEN
      restore = restore || " " || display
    "ISREDIT NUMBER = "stat restore        /* RESTORE NUMBER SETTING */
  END
EXIT
/* J. KALINICH, X4521 */
/* EDIT MACRO TO DO FIND ALL FROM EXCLUDED LINES */
./ ADD NAME=FXC                                    12SEP93 17.34 --
ISREDIT MACRO
/*                                                                 */
/* FXC EDIT MACRO - FIND ALL IN EXCLUDED LINES (INCL SEQ NUMBERS)  */
/*                  USING THE 'STRING' THE CURSOR IS SITTING ON    */
/*                                                                 */
/*   20 MAY 93 - ZERO SUPPRESS &FINDS, &LEFT, AND &RIGHT VARIABLES */
/*                                                                 */
CONTROL NOFLUSH NOMSG NOLIST NOCONLIST NOSYMLIST
ISREDIT (LINE) = LINE .ZCSR
ISREDIT (END)  = LRECL
ISREDIT (CL,CC) = CURSOR
IF &CC = 0 OR -
   &CC > &END THEN -
  DO
    SET &ZEDSMSG = &STR(PUT CURSOR ON A STRING)
    SET &ZEDLMSG = &STR(FXC NEEDS THE CURSOR IN THE DATA AREA)
    ISPEXEC SETMSG MSG(ISRZ001W)
    IF &CC > &END THEN -
      SET &CC = 0
    ISREDIT CURSOR = (CL,CC)
    EXIT CODE(0)
  END
/* STRING DELIMITERS BELOW - MODIFY AS APPROPRIATE */
SET &DELIM = &NRSTR(~`!@#$%^()-_=+|\{Ö×};:"'<,>?/ )

SET &START = 1
DO &I = &CC TO &START BY -1
  IF &SYSINDEX(&SUBSTR(&I,&NRSTR(&LINE)),&NRSTR(&DELIM),1) > 0 THEN -
    SET &START = &I + 1
END

DO &I = &CC TO &END
  IF &SYSINDEX(&SUBSTR(&I,&NRSTR(&LINE)),&NRSTR(&DELIM),1) > 0 THEN -
    SET &END = &I - 1
END

IF &START > &END THEN -
  DO
    SET &ZEDSMSG = &STR(PUT CURSOR ON A STRING)
    SET &ZEDLMSG = &STR(FXC NEEDS THE CURSOR ON A NON-DELIMITER)
    ISPEXEC SETMSG MSG(ISRZ001W)
    ISREDIT CURSOR = (CL,CC)
    EXIT CODE(0)
  END

SET &FXSTRING = &NRSTR(&SUBSTR(&START:&END,&NRSTR(&LINE)))

ISREDIT (STAT,VALUE) = NUMBER  /* SAVE NUMBER SETTING */
ISREDIT NUMBER OFF             /* SEARCH SEQUENCE NUMBERS ON 'FIND' */
SET &SCAN = ON
IF &STR(&SUBSTR(1:1,&STR(&FXSTRING))) = &STR(&&) THEN -
  SET &SCAN = OFF
ISREDIT EXCLUDE ALL
ISPEXEC CONTROL ERRORS RETURN
ISREDIT SCAN &SCAN
ISREDIT FIND ALL '&FXSTRING'
SET &FINDCC = &LASTCC
ISREDIT (FINDS) = FIND_COUNTS
ISREDIT (LEFT,RIGHT) = BOUNDS
SET &FINDS = &FINDS + 0
SET &LEFT  = &LEFT  + 0
SET &RIGHT = &RIGHT + 0
IF &FINDCC > 0 -
  THEN -
    DO
      SET &ZEDSMSG = &STR(NO CHARS '&FXSTRING' FOUND)
      SET &ZEDLMSG = &STR(CHARS '&FXSTRING' - NOT FOUND ON ANY LINES +
                          (COLS &LEFT TO &RIGHT).)
      ISPEXEC SETMSG MSG(ISRZ001W)
      ISREDIT RESET EXCLUDED
    END
  ELSE -
    DO
      SET &ZEDSMSG = &STR(&FINDS CHARS '&FXSTRING')
      SET &ZEDLMSG = &STR(CHARS '&FXSTRING' FOUND &FINDS TIMES +
                          WITHIN COLUMNS &LEFT TO &RIGHT.)
      ISPEXEC SETMSG MSG(ISRZ000W)
    END
ISREDIT NUMBER = (STAT,VALUE)  /* RESTORE NUMBER SETTING */
EXIT CODE(1)                   /* RETURN CURSOR TO COMMAND LINE */
END
/* J. KALINICH, X4521 */
/* EDIT MACRO TO DO FIND ALL FROM EXCLUDED LINES ON WORD AT CURSOR */
./ ADD NAME=GETATTR                                12SEP93 17.34 --
/* REXX -
 +------------------------------------------------------------------+
 | Name:       GETATTR                                              |
 | Type:       REXX exec                                            |
 | Purpose:    Get the TSO user attributes                          |
 | Release:    MVS/ESA v3.1.3  and TSO/E v2.1                       |
 | Programmer: John Kalinich                                        |
 | Date:       4/09/93                                              |
 | Abstract:   A sub-function to return the TSO user attributes     |
 |             from the Protected Step Control Block                |
 |                                                                  |
 | Call Format:  GETATTR()                                          |
 |                                                                  |
 | Logic: Extracts address of TCB (PSATOLD at x'21C')               |
 |        Extracts address of JSCB (TCB+x'B4')                      |
 |        Extracts address of PSCB (JSCB+x'108')                    |
 |        Tests PSCBATR1, bit 0 for OPERATOR authority              |
 |        Tests PSCBATR1, bit 1 for ACCOUNT  authority              |
 |        Tests PSCBATR1, bit 2 for SUBMIT   authority              |
 +------------------------------------------------------------------+ */
trace

numeric digits 10          /* Required for 31-bit addresses */
tcb_ptr = get_ptr(21c,0)
jscb_ptr  = get_ptr(tcb_ptr,'b4')
pscb_ptr  = get_ptr(jscb_ptr,'108')
pscbatr1 = c2d(get_data(pscb_ptr,'10',1))
if (pscbatr1 // 256) > 127 then
  oper = 'OPER  '
else
  oper = 'NOOPER'
if (pscbatr1 // 128) > 63 then
  account = 'ACCOUNT  '
else
  account = 'NOACCOUNT'
if (pscbatr1 // 64) > 31 then
  submit = 'SUBMIT  '
else
  submit = 'NOSUBMIT'
tsoattr = oper||account||submit
exit tsoattr

/* +-----------------------------------------+
   | Procedures and functions defined below. |
   +-----------------------------------------+ */

get_ptr: procedure
    /* +-----------------------------------------+
       | returns a 4 byte pointer as hexadecimal |
       | string at address addr+offset.          |
       | ADDR and OFFSET must be HEX strings.    |
       +-----------------------------------------+ */
  arg addr, offset
  temp = d2x(x2d(addr) + x2d(offset))
  return c2x(storage(temp,4))
  exit

get_data: procedure
    /* +-----------------------------------------+
       | returns LENGTH bytes at ADDR+OFFSET as  |
       | an EBCDIC string.                       |
       | ADDR and OFFSET must be HEX strings.    |
       | LENGTH must be a decimal string.        |
       +-----------------------------------------+ */
  arg addr, offset, length
  temp = d2x(x2d(addr) + x2d(offset))
  return storage(temp,length)
  exit
/* J. KALINICH, X4521 */
/* EXEC TO GET THE TSO USER ATTRIBUTES               */
./ ADD NAME=GETCPUM                                12SEP93 17.34 --
/* REXX -
 +------------------------------------------------------------------+
 | Name:       GETCPUM                                              |
 | Type:       REXX exec                                            |
 | Purpose:    Extract the CVTMDL of the System you are on          |
 | Release:    MVS/ESA v3.1.3 and TSO/E v2.1                        |
 | Programmer: John Kalinich                                        |
 | Date:       3/22/93                                              |
 | Abstract:   A sub-function to extract the cpu model number from  |
 |             the CVT prefix.                                      |
 |                                                                  |
 | Call Format:  GETCPUM()                                          |
 |                                                                  |
 | Logic: Extracts address of CVT (at x'10')                        |
 |        Addresses the CVTFIX+250 (CVT-x'6')                       |
 |        Extracts CVTMDL                                           |
 +------------------------------------------------------------------+ */
trace

cvt_ptr = get_ptr(10,0)
cvtmdl_ptr = d2x(x2d(cvt_ptr) - x2d(6))
cvtmdl = c2x(get_data(cvtmdl_ptr,'0',2))
exit substr(cvtmdl,1,4)

/* +-----------------------------------------+
   | Procedures and functions defined below. |
   +-----------------------------------------+ */

get_ptr: procedure
    /* +-----------------------------------------+
       | returns a 4 byte pointer as hexadecimal |
       | string at address addr+offset.          |
       | ADDR and OFFSET must be HEX strings.    |
       +-----------------------------------------+ */
  arg addr, offset
  temp = d2x(x2d(addr) + x2d(offset))
  return c2x(storage(temp,4))
  exit

get_data: procedure
    /* +-----------------------------------------+
       | returns LENGTH bytes at ADDR+OFFSET as  |
       | an EBCDIC string.                       |
       | ADDR and OFFSET must be HEX strings.    |
       | LENGTH must be a decimal string.        |
       +-----------------------------------------+ */
  arg addr, offset, length
  temp = d2x(x2d(addr) + x2d(offset))
  return storage(temp,length)
  exit
/* J. KALINICH, X4521 */
/* EXEC TO GET THE CPU MODEL NUMBER                  */
./ ADD NAME=GETDEST                                12SEP93 17.34 --
/* REXX -
 +------------------------------------------------------------------+
 | Name:       GETDEST                                              |
 | Type:       REXX exec                                            |
 | Purpose:    Get the TSO default SYSOUT destination               |
 | Release:    MVS/ESA v3.1.3  and TSO/E v2.1                       |
 | Programmer: John Kalinich                                        |
 | Date:       4/09/93                                              |
 | Abstract:   A sub-function to return the TSO user's default      |
 |             SYSOUT destination                                   |
 |                                                                  |
 | Call Format:  GETDEST()                                          |
 |                                                                  |
 | Logic: Extracts address of TCB (PSATOLD at x'21C')               |
 |        Extracts address of JSCB (TCB+x'B4')                      |
 |        Extracts address of PSCB (JSCB+x'108')                    |
 |        Extracts the PSCBDEST                                     |
 +------------------------------------------------------------------+ */
trace

numeric digits 10          /* Required for 31-bit addresses */
tcb_ptr = get_ptr(21c,0)
jscb_ptr  = get_ptr(tcb_ptr,'b4')
pscb_ptr  = get_ptr(jscb_ptr,'108')
dest = get_data(pscb_ptr,'28',8)
exit dest

/* +-----------------------------------------+
   | Procedures and functions defined below. |
   +-----------------------------------------+ */

get_ptr: procedure
    /* +-----------------------------------------+
       | returns a 4 byte pointer as hexadecimal |
       | string at address addr+offset.          |
       | ADDR and OFFSET must be HEX strings.    |
       +-----------------------------------------+ */
  arg addr, offset
  temp = d2x(x2d(addr) + x2d(offset))
  return c2x(storage(temp,4))
  exit

get_data: procedure
    /* +-----------------------------------------+
       | returns LENGTH bytes at ADDR+OFFSET as  |
       | an EBCDIC string.                       |
       | ADDR and OFFSET must be HEX strings.    |
       | LENGTH must be a decimal string.        |
       +-----------------------------------------+ */
  arg addr, offset, length
  temp = d2x(x2d(addr) + x2d(offset))
  return storage(temp,length)
  exit
/* J. KALINICH, X4521 */
/* EXEC TO GET THE TSO DEFAULT SYSOUT DESTINATION    */
./ ADD NAME=GETDFPL                                12SEP93 17.34 --
/* REXX -
 +------------------------------------------------------------------+
 | Name:       GETDFPL                                              |
 | Type:       REXX exec                                            |
 | Purpose:    Extract the DFAREL of the System you are on          |
 | Release:    MVS/ESA v3.1.3 and TSO/E v2.1                        |
 | Programmer: John Kalinich                                        |
 | Date:       3/22/93                                              |
 | Abstract:   A sub-function to extract the DFP level from the     |
 |             Data Facilities Area (DFA).                          |
 |                                                                  |
 | Call Format:  GETDFPL()                                          |
 |                                                                  |
 | Logic: Extracts address of CVT (at x'10')                        |
 |        Extracts address of DFA (CVT+x'4C0')                      |
 |        Extracts DFAREL                                           |
 +------------------------------------------------------------------+ */
trace

numeric digits 10          /* Required for 31-bit addresses */
cvt_ptr = get_ptr(10,0)
dfa_ptr = get_ptr(cvt_ptr,'4c0')
dfarel = c2x(get_data(dfa_ptr,'2',2))
exit substr(dfarel,1,1)'.'substr(dfarel,2,1)'.'substr(dfarel,3,1)

/* +-----------------------------------------+
   | Procedures and functions defined below. |
   +-----------------------------------------+ */

get_ptr: procedure
    /* +-----------------------------------------+
       | returns a 4 byte pointer as hexadecimal |
       | string at address addr+offset.          |
       | ADDR and OFFSET must be HEX strings.    |
       +-----------------------------------------+ */
  arg addr, offset
  temp = d2x(x2d(addr) + x2d(offset))
  return c2x(storage(temp,4))
  exit

get_data: procedure
    /* +-----------------------------------------+
       | returns LENGTH bytes at ADDR+OFFSET as  |
       | an EBCDIC string.                       |
       | ADDR and OFFSET must be HEX strings.    |
       | LENGTH must be a decimal string.        |
       +-----------------------------------------+ */
  arg addr, offset, length
  temp = d2x(x2d(addr) + x2d(offset))
  return storage(temp,length)
  exit
/* J. KALINICH, X4521 */
/* EXEC TO GET THE DFP LEVEL                         */
./ ADD NAME=GETIPLD                                12SEP93 17.34 --
/* REXX -
 +------------------------------------------------------------------+
 | Name:       GETIPLD                                              |
 | Type:       REXX exec                                            |
 | Purpose:    Extract the SMCAIDTE of the System you are on        |
 | Release:    MVS/ESA v3.1.3 and TSO/E v2.1                        |
 | Programmer: John Kalinich                                        |
 | Date:       3/19/93                                              |
 | Abstract:   A sub-function to extract the IPL date from the      |
 |             System Management Control Area (SMCA).               |
 |                                                                  |
 | Call Format:  GETIPLD()                                          |
 |                                                                  |
 | Logic: Extracts address of CVT (at x'10')                        |
 |        Extracts address of SMCA (CVT+x'C4')                      |
 |        Extracts SMCAIDTE                                         |
 +------------------------------------------------------------------+ */
trace

numeric digits 10          /* Required for 31-bit addresses */
cvt_ptr = get_ptr(10,0)
smca_ptr = get_ptr(cvt_ptr,'c4')
smcaidte = c2x(get_data(smca_ptr,'154',4))
exit substr(smcaidte,3,2)'.'substr(smcaidte,5,3)

/* +-----------------------------------------+
   | Procedures and functions defined below. |
   +-----------------------------------------+ */

get_ptr: procedure
    /* +-----------------------------------------+
       | returns a 4 byte pointer as hexadecimal |
       | string at address addr+offset.          |
       | ADDR and OFFSET must be HEX strings.    |
       +-----------------------------------------+ */
  arg addr, offset
  temp = d2x(x2d(addr) + x2d(offset))
  return c2x(storage(temp,4))
  exit

get_data: procedure
    /* +-----------------------------------------+
       | returns LENGTH bytes at ADDR+OFFSET as  |
       | an EBCDIC string.                       |
       | ADDR and OFFSET must be HEX strings.    |
       | LENGTH must be a decimal string.        |
       +-----------------------------------------+ */
  arg addr, offset, length
  temp = d2x(x2d(addr) + x2d(offset))
  return storage(temp,length)
  exit
/* J. KALINICH, X4521 */
/* EXEC TO GET THE MVS IPL DATE                      */
./ ADD NAME=GETIPLT                                12SEP93 17.34 --
/* REXX -
 +------------------------------------------------------------------+
 | Name:       GETIPLT                                              |
 | Type:       REXX exec                                            |
 | Purpose:    Extract the SMCAITME of the System you are on        |
 | Release:    MVS/ESA v3.1.3 and TSO/E v2.1                        |
 | Programmer: John Kalinich                                        |
 | Date:       3/19/93                                              |
 | Abstract:   A sub-function to extract the IPL time from the      |
 |             System Management Control Area (SMCA).               |
 |                                                                  |
 | Call Format:  GETIPLT()                                          |
 |                                                                  |
 | Logic: Extracts address of CVT (at x'10')                        |
 |        Extracts address of SMCA (CVT+x'C4')                      |
 |        Extracts SMCAITME                                         |
 +------------------------------------------------------------------+ */
trace

numeric digits 10          /* Required for 31-bit addresses */
cvt_ptr = get_ptr(10,0)
smca_ptr = get_ptr(cvt_ptr,'c4')
smcaitme = c2x(get_data(smca_ptr,'150',4))
total_seconds = x2d(smcaitme) % 100
seconds = total_seconds // 60
minutes = (total_seconds % 60) // 60
hours   = (total_seconds / 60) % 60
if seconds < 10 then
  seconds = insert('0',seconds,0)
if minutes < 10 then
  minutes = insert('0',minutes,0)
if hours < 10 then
  hours = insert('0',hours,0)
exit hours'.'minutes'.'seconds

/* +-----------------------------------------+
   | Procedures and functions defined below. |
   +-----------------------------------------+ */

get_ptr: procedure
    /* +-----------------------------------------+
       | returns a 4 byte pointer as hexadecimal |
       | string at address addr+offset.          |
       | ADDR and OFFSET must be HEX strings.    |
       +-----------------------------------------+ */
  arg addr, offset
  temp = d2x(x2d(addr) + x2d(offset))
  return c2x(storage(temp,4))
  exit

get_data: procedure
    /* +-----------------------------------------+
       | returns LENGTH bytes at ADDR+OFFSET as  |
       | an EBCDIC string.                       |
       | ADDR and OFFSET must be HEX strings.    |
       | LENGTH must be a decimal string.        |
       +-----------------------------------------+ */
  arg addr, offset, length
  temp = d2x(x2d(addr) + x2d(offset))
  return storage(temp,length)
  exit
/* J. KALINICH, X4521 */
/* EXEC TO GET THE MVS IPL TIME                      */
./ ADD NAME=GETJES2                                12SEP93 17.34 --
/* REXX -
 +------------------------------------------------------------------+
 | Name:       GETJES2                                              |
 | Type:       REXX exec                                            |
 | Purpose:    Get the JES2 product name                            |
 | Release:    MVS/ESA v3.1.3 and TSO/E v2.1                        |
 | Programmer: John Kalinich                                        |
 | Date:       3/22/93                                              |
 | Abstract:   A sub-function to return the JES2 product name       |
 |             from HASPSSSM.                                       |
 |                                                                  |
 | Call Format:  GETJES2()                                          |
 |                                                                  |
 | Logic: Extracts address of CVT (at x'10')                        |
 |        Extracts address of JESCT (CVT+x'128')                    |
 |        Extracts address of SSCVT (JESCT+x'18')                   |
 |        Extracts address of SSCTSUSE (SSCVT+x'14')                |
 |        Extracts JES2 product name from HASPSSSM+x'C'             |
 +------------------------------------------------------------------+ */
trace

numeric digits 10          /* Required for 31-bit addresses */
cvt_ptr = get_ptr(10,0)
jesct_ptr = get_ptr(cvt_ptr,'128')
sscvt_ptr = get_ptr(jesct_ptr,'18')
haspsssm_plus12 = get_ptr(sscvt_ptr,'14')
jeslevel = get_data(haspsssm_plus12,'0',8)
exit jeslevel

/* +-----------------------------------------+
   | Procedures and functions defined below. |
   +-----------------------------------------+ */

get_ptr: procedure
    /* +-----------------------------------------+
       | returns a 4 byte pointer as hexadecimal |
       | string at address addr+offset.          |
       | ADDR and OFFSET must be HEX strings.    |
       +-----------------------------------------+ */
  arg addr, offset
  temp = d2x(x2d(addr) + x2d(offset))
  return c2x(storage(temp,4))
  exit

get_data: procedure
    /* +-----------------------------------------+
       | returns LENGTH bytes at ADDR+OFFSET as  |
       | an EBCDIC string.                       |
       | ADDR and OFFSET must be HEX strings.    |
       | LENGTH must be a decimal string.        |
       +-----------------------------------------+ */
  arg addr, offset, length
  temp = d2x(x2d(addr) + x2d(offset))
  return storage(temp,length)
  exit
/* J. KALINICH, X4521 */
/* EXEC TO GET THE JES2 PRODUCT LEVEL                */
./ ADD NAME=GETJOBID                               12SEP93 17.34 --
/* REXX -
 +------------------------------------------------------------------+
 | Name:       GETJOBID                                             |
 | Type:       REXX exec                                            |
 | Purpose:    Extract the SSIBJBID from the SSIB.                  |
 | Release:    MVS/ESA v3.1.3  and TSO/E v2.1                       |
 | Programmer: John Kalinich                                        |
 | Date:       3/22/93                                              |
 | Abstract:   A sub-function to extract the job id from the        |
 |             Subsystem Identification Block (SSIB).               |
 |                                                                  |
 | Call Format:  GETJOBID()                                         |
 |                                                                  |
 | Logic: Extracts address of TCB (PSATOLD at x'21C')               |
 |        Extracts address of JSCB (TCB+x'B4')                      |
 |        Extracts address of SSIB (JSCB+x'13C')                    |
 |        Extracts the SSIBJBID                                     |
 +------------------------------------------------------------------+ */
trace

numeric digits 10          /* Required for 31-bit addresses */
tcb_ptr = get_ptr(21c,0)
jscb_ptr  = get_ptr(tcb_ptr,'b4')
ssib_ptr  = get_ptr(jscb_ptr,'13c')
ssibjbid = get_data(ssib_ptr,'c',8)
exit ssibjbid

/* +-----------------------------------------+
   | Procedures and functions defined below. |
   +-----------------------------------------+ */

get_ptr: procedure
    /* +-----------------------------------------+
       | returns a 4 byte pointer as hexadecimal |
       | string at address addr+offset.          |
       | ADDR and OFFSET must be HEX strings.    |
       +-----------------------------------------+ */
  arg addr, offset
  temp = d2x(x2d(addr) + x2d(offset))
  return c2x(storage(temp,4))
  exit

get_data: procedure
    /* +-----------------------------------------+
       | returns LENGTH bytes at ADDR+OFFSET as  |
       | an EBCDIC string.                       |
       | ADDR and OFFSET must be HEX strings.    |
       | LENGTH must be a decimal string.        |
       +-----------------------------------------+ */
  arg addr, offset, length
  temp = d2x(x2d(addr) + x2d(offset))
  return storage(temp,length)
  exit
/* J. KALINICH, X4521 */
/* EXEC TO GET THE JES2 JOB ID                       */
./ ADD NAME=GETLPAR                                12SEP93 17.34 --
/* REXX -
 +------------------------------------------------------------------+
 | Name:       GETLPAR                                              |
 | Type:       REXX exec                                            |
 | Purpose:    Extract the Logical Partition mode (YES or NO)       |
 | Release:    MVS/ESA v3.1.3 and TSO/E v2.1                        |
 | Programmer: John Kalinich                                        |
 | Date:       4/09/93                                              |
 | Abstract:   A sub-function to extract the LPAR mode from the     |
 |             Service Call Control Block (SCCB).                   |
 |                                                                  |
 | Call Format:  GETLPAR()                                          |
 |                                                                  |
 | Logic: Extracts address of CVT (at x'10')                        |
 |        Extracts address of SCCP (CVT+x'340')                     |
 |        Tests SCCBCON1, bit 0 for LPAR configuration              |
 +------------------------------------------------------------------+ */
trace

numeric digits 10          /* Required for 31-bit addresses */
cvt_ptr = get_ptr(10,0)
sccb_ptr = get_ptr(cvt_ptr,'340')
sccbcon1 = c2d(get_data(sccb_ptr,'50',1))
if (sccbcon1 // 256) > 127 then
  lpar = 'YES'
else
  lpar = 'NO'
exit lpar

/* +-----------------------------------------+
   | Procedures and functions defined below. |
   +-----------------------------------------+ */

get_ptr: procedure
    /* +-----------------------------------------+
       | returns a 4 byte pointer as hexadecimal |
       | string at address addr+offset.          |
       | ADDR and OFFSET must be HEX strings.    |
       +-----------------------------------------+ */
  arg addr, offset
  temp = d2x(x2d(addr) + x2d(offset))
  return c2x(storage(temp,4))
  exit

get_data: procedure
    /* +-----------------------------------------+
       | returns LENGTH bytes at ADDR+OFFSET as  |
       | an EBCDIC string.                       |
       | ADDR and OFFSET must be HEX strings.    |
       | LENGTH must be a decimal string.        |
       +-----------------------------------------+ */
  arg addr, offset, length
  temp = d2x(x2d(addr) + x2d(offset))
  return storage(temp,length)
  exit
/* J. KALINICH, X4521 */
/* EXEC TO GET THE LOGICAL PARTITION MODE            */
./ ADD NAME=GETREALM                               12SEP93 17.34 --
/* REXX -
 +------------------------------------------------------------------+
 | Name:       GETREALM                                             |
 | Type:       REXX exec                                            |
 | Purpose:    Extract the CVTRLSTG from the CVT.                   |
 | Release:    MVS/ESA v3.1.3  and TSO/E v2.1                       |
 | Programmer: John Kalinich                                        |
 | Date:       3/22/93                                              |
 | Abstract:   A sub-function to extract the real storage size      |
 |             online at IPL.  Returns value in number of           |
 |             megabytes (M).                                       |
 |                                                                  |
 | Call Format:  GETREALM()                                         |
 |                                                                  |
 | Logic: Extracts address of CVT (at x'10')                        |
 |        Extracts CVTRLSTG                                         |
 +------------------------------------------------------------------+ */
trace

numeric digits 10          /* Required for 31-bit addresses */
cvt_ptr = get_ptr(10,0)
cvtrlstg = c2d(get_data(cvt_ptr,'358',4)) / 1024
exit cvtrlstg

/* +-----------------------------------------+
   | Procedures and functions defined below. |
   +-----------------------------------------+ */

get_ptr: procedure
    /* +-----------------------------------------+
       | returns a 4 byte pointer as hexadecimal |
       | string at address addr+offset.          |
       | ADDR and OFFSET must be HEX strings.    |
       +-----------------------------------------+ */
  arg addr, offset
  temp = d2x(x2d(addr) + x2d(offset))
  return c2x(storage(temp,4))
  exit

get_data: procedure
    /* +-----------------------------------------+
       | returns LENGTH bytes at ADDR+OFFSET as  |
       | an EBCDIC string.                       |
       | ADDR and OFFSET must be HEX strings.    |
       | LENGTH must be a decimal string.        |
       +-----------------------------------------+ */
  arg addr, offset, length
  temp = d2x(x2d(addr) + x2d(offset))
  return storage(temp,length)
  exit
/* J. KALINICH, X4521 */
/* EXEC TO GET THE REAL STORAGE SIZE                 */
./ ADD NAME=GETREGK                                12SEP93 17.34 --
/* REXX -
 +------------------------------------------------------------------+
 | Name:       GETREGK                                              |
 | Type:       REXX exec                                            |
 | Purpose:    Extract the LDAREGRQ from the LDA.                   |
 | Release:    MVS/ESA v3.1.3  and TSO/E v2.1                       |
 | Programmer: John Kalinich                                        |
 | Date:       3/22/93                                              |
 | Abstract:   A sub-function to extract the region size requested  |
 |             from the Local Data Area (LDA).  Returns value in    |
 |             number of kilobytes (K).                             |
 |                                                                  |
 | Call Format:  GETREGK()                                          |
 |                                                                  |
 | Logic: Extracts address of ASCB (PSAAOLD at x'224')              |
 |        Extracts address of LDA  (ASCB+x'30')                     |
 |        Extracts LDAREGRQ                                         |
 +------------------------------------------------------------------+ */
trace

numeric digits 10          /* Required for 31-bit addresses */
ascb_ptr = get_ptr(224,0)
lda_ptr  = get_ptr(ascb_ptr,'30')
ldaregrq = c2d(get_data(lda_ptr,'cc',4)) / 1024
exit ldaregrq

/* +-----------------------------------------+
   | Procedures and functions defined below. |
   +-----------------------------------------+ */

get_ptr: procedure
    /* +-----------------------------------------+
       | returns a 4 byte pointer as hexadecimal |
       | string at address addr+offset.          |
       | ADDR and OFFSET must be HEX strings.    |
       +-----------------------------------------+ */
  arg addr, offset
  temp = d2x(x2d(addr) + x2d(offset))
  return c2x(storage(temp,4))
  exit

get_data: procedure
    /* +-----------------------------------------+
       | returns LENGTH bytes at ADDR+OFFSET as  |
       | an EBCDIC string.                       |
       | ADDR and OFFSET must be HEX strings.    |
       | LENGTH must be a decimal string.        |
       +-----------------------------------------+ */
  arg addr, offset, length
  temp = d2x(x2d(addr) + x2d(offset))
  return storage(temp,length)
  exit
/* J. KALINICH, X4521 */
/* EXEC TO GET THE REGION SIZE (IN K)                */
./ ADD NAME=GETSCPN                                12SEP93 17.34 --
/* REXX -
 +------------------------------------------------------------------+
 | Name:       GETSCPN                                              |
 | Type:       REXX exec                                            |
 | Purpose:    Extract the CVTPRODN of the System you are on        |
 | Release:    MVS/ESA v3.1.3 and TSO/E v2.1                        |
 | Programmer: John Kalinich                                        |
 | Date:       3/22/93                                              |
 | Abstract:   A sub-function to extract the system control program |
 |             product name (e.g., SP3.1.3) from the CVT prefix.    |
 |                                                                  |
 | Call Format:  GETSCPN()                                          |
 |                                                                  |
 | Logic: Extracts address of CVT (at x'10')                        |
 |        Addresses the CVTFIX+216 (CVT-x'28')                      |
 |        Extracts CVTPRODN                                         |
 +------------------------------------------------------------------+ */
trace

cvt_ptr = get_ptr(10,0)
cvtprod = d2x(x2d(cvt_ptr) - x2d(28))
cvtprodn = get_data(cvtprod,'0',8)
cvtprodn = insert(' ',cvtprodn,2)
exit cvtprodn

/* +-----------------------------------------+
   | Procedures and functions defined below. |
   +-----------------------------------------+ */

get_ptr: procedure
    /* +-----------------------------------------+
       | returns a 4 byte pointer as hexadecimal |
       | string at address addr+offset.          |
       | ADDR and OFFSET must be HEX strings.    |
       +-----------------------------------------+ */
  arg addr, offset
  temp = d2x(x2d(addr) + x2d(offset))
  return c2x(storage(temp,4))
  exit

get_data: procedure
    /* +-----------------------------------------+
       | returns LENGTH bytes at ADDR+OFFSET as  |
       | an EBCDIC string.                       |
       | ADDR and OFFSET must be HEX strings.    |
       | LENGTH must be a decimal string.        |
       +-----------------------------------------+ */
  arg addr, offset, length
  temp = d2x(x2d(addr) + x2d(offset))
  return storage(temp,length)
  exit
/* J. KALINICH, X4521 */
/* EXEC TO GET THE MVS SCP PRODUCT NAME              */
./ ADD NAME=GETSMFID                               12SEP93 17.34 --
/* REXX -
 +------------------------------------------------------------------+
 | Name:       GETSMFID                                             |
 | Type:       REXX exec                                            |
 | Purpose:    Extract the SMCASID of the System you are on         |
 | Release:    MVS/ESA v4.1   and TSO/E v2.1                        |
 | Programmer: Paul S. Waterhouse                                   |
 |             (Code modified from apf list routine put on          |
 |              exchange by Joe Millar)                             |
 | Date:       1/24/92                                              |
 | Abstract:   A sub-function to extract the smfid from the         |
 |             System Management Control Area (SMCA).               |
 |                                                                  |
 | Call Format:  GETSMFID('smf-id')                                 |
 |                                                                  |
 |               When 'smf-id' is null, function returns            |
 |               the SMF-ID.                                        |
 |               When 'smf-id' is four bytes long, a 1 will be      |
 |               returned if current SMF-ID = smf-id or a 0 if      |
 |               not equal.                                         |
 |                                                                  |
 | Logic: Extracts address of CVT (at x'10')                        |
 |        Extracts address of SMCA (CVT+x'C4')                      |
 |        Extracts SMCASID                                          |
 |                                                                  |
 |        If arg is null, return smfid                              |
 |        If arg len = 4 then compare                               |
 |           If equal return 1                                      |
 |           If not equal return 0                                  |
 +------------------------------------------------------------------+ */
trace

numeric digits 10          /* Required for 31-bit addresses */
parse arg check_id, .
cvt_ptr = get_ptr(10,0)
smca_ptr = get_ptr(cvt_ptr,'c4')
smcasid = get_data(smca_ptr,'10',4)
select
      when check_id = "" then
           do
             exit smcasid
           end
      when length(check_id) ^= 4 then
           do
             exit -3
           end
otherwise
         do
           if check_id =  smcasid then
              do
                exit 1
              end
         end
end

exit 0

/* +-----------------------------------------+
   | Procedures and functions defined below. |
   +-----------------------------------------+ */

get_ptr: procedure
    /* +-----------------------------------------+
       | returns a 4 byte pointer as hexadecimal |
       | string at address addr+offset.          |
       | ADDR and OFFSET must be HEX strings.    |
       +-----------------------------------------+ */
  arg addr, offset
  temp = d2x(x2d(addr) + x2d(offset))
  return c2x(storage(temp,4))
  exit

get_data: procedure
    /* +-----------------------------------------+
       | returns LENGTH bytes at ADDR+OFFSET as  |
       | an EBCDIC string.                       |
       | ADDR and OFFSET must be HEX strings.    |
       | LENGTH must be a decimal string.        |
       +-----------------------------------------+ */
  arg addr, offset, length
  temp = d2x(x2d(addr) + x2d(offset))
  return storage(temp,length)
  exit
/* J. KALINICH, X4521 */
/* EXEC TO GET THE SMF SYSTEM ID (from NaSPA)        */
./ ADD NAME=GETSMS                                 12SEP93 17.34 --
/* REXX -
 +------------------------------------------------------------------+
 | Name:       GETSMS                                               |
 | Type:       REXX exec                                            |
 | Purpose:    Get the status of SMS (ON or OFF)                    |
 | Release:    MVS/ESA v3.1.3 and TSO/E v2.1                        |
 | Programmer: John Kalinich                                        |
 | Date:       3/22/93                                              |
 | Abstract:   A sub-function to return the status of SMS in the    |
 |             system.                                              |
 |                                                                  |
 | Call Format:  GETSMS()                                           |
 |                                                                  |
 | Logic: Extracts address of CVT (at x'10')                        |
 |        Extracts address of JESCT (CVT+x'128')                    |
 |        Extracts address of JESCTEXT (JESCT+x'64')                |
 |        Tests pointer to JESSMSIB                                 |
 +------------------------------------------------------------------+ */
trace

numeric digits 10          /* Required for 31-bit addresses */
cvt_ptr = get_ptr(10,0)
jesct_ptr = get_ptr(cvt_ptr,'128')
jesctext_ptr = get_ptr(jesct_ptr,'64')
jessmsib = c2x(get_data(jesctext_ptr,'54',4))
if x2d(jessmsib) = 0 then
  smsstat = 'OFF'
else
  smsstat = 'ON'
exit smsstat

/* +-----------------------------------------+
   | Procedures and functions defined below. |
   +-----------------------------------------+ */

get_ptr: procedure
    /* +-----------------------------------------+
       | returns a 4 byte pointer as hexadecimal |
       | string at address addr+offset.          |
       | ADDR and OFFSET must be HEX strings.    |
       +-----------------------------------------+ */
  arg addr, offset
  temp = d2x(x2d(addr) + x2d(offset))
  return c2x(storage(temp,4))
  exit

get_data: procedure
    /* +-----------------------------------------+
       | returns LENGTH bytes at ADDR+OFFSET as  |
       | an EBCDIC string.                       |
       | ADDR and OFFSET must be HEX strings.    |
       | LENGTH must be a decimal string.        |
       +-----------------------------------------+ */
  arg addr, offset, length
  temp = d2x(x2d(addr) + x2d(offset))
  return storage(temp,length)
  exit
/* J. KALINICH, X4521 */
/* EXEC TO GET THE STATUS OF SMS                     */
./ ADD NAME=GETSWA                                 12SEP93 17.34 --
/* REXX -
 +------------------------------------------------------------------+
 | Name:       GETSWA                                               |
 | Type:       REXX exec                                            |
 | Purpose:    Get the location of SWA (ABOVE or BELOW)             |
 | Release:    MVS/ESA v3.1.3  and TSO/E v2.1                       |
 | Programmer: John Kalinich                                        |
 | Date:       4/09/93                                              |
 | Abstract:   A sub-function to return the status of SWA in the    |
 |             system.                                              |
 |                                                                  |
 | Call Format:  GETSWA()                                           |
 |                                                                  |
 | Logic: Extracts address of TCB (PSATOLD at x'21C')               |
 |        Extracts address of JSCB (TCB+x'B4')                      |
 |        Extracts address of JCT prefix (JSCB+x'104')              |
 |        Addresses the JCT (JCT+x'10')                             |
 |        Tests JCTSTAT2, bit 7 for location of SWA                 |
 +------------------------------------------------------------------+ */
trace

numeric digits 10          /* Required for 31-bit addresses */
tcb_ptr = get_ptr(21c,0)
jscb_ptr  = get_ptr(tcb_ptr,'b4')
jct_prefix_ptr  = get_ptr(jscb_ptr,'104')
jct_ptr = d2x(x2d(jct_prefix_ptr) + x2d(10))
jctstat2 = c2x(get_data(jct_ptr,'f4',1))
if (x2d(jctstat2) // 2) > 0 then
  jctswaup = 'ABOVE'
else
  jctswaup = 'BELOW'
exit jctswaup

/* +-----------------------------------------+
   | Procedures and functions defined below. |
   +-----------------------------------------+ */

get_ptr: procedure
    /* +-----------------------------------------+
       | returns a 4 byte pointer as hexadecimal |
       | string at address addr+offset.          |
       | ADDR and OFFSET must be HEX strings.    |
       +-----------------------------------------+ */
  arg addr, offset
  temp = d2x(x2d(addr) + x2d(offset))
  return c2x(storage(temp,4))
  exit

get_data: procedure
    /* +-----------------------------------------+
       | returns LENGTH bytes at ADDR+OFFSET as  |
       | an EBCDIC string.                       |
       | ADDR and OFFSET must be HEX strings.    |
       | LENGTH must be a decimal string.        |
       +-----------------------------------------+ */
  arg addr, offset, length
  temp = d2x(x2d(addr) + x2d(offset))
  return storage(temp,length)
  exit
/* J. KALINICH, X4521 */
/* EXEC TO GET THE LOCATION OF SWA                   */
./ ADD NAME=GETTRID                                12SEP93 17.34 --
/* REXX -
 +------------------------------------------------------------------+
 | Name:       GETTRID                                              |
 | Type:       REXX exec                                            |
 | Purpose:    Extract the ACEETRID from the RACF ACEE.             |
 | Release:    MVS/ESA v3.1.3  and TSO/E v2.1                       |
 | Programmer: John Kalinich                                        |
 | Date:       3/10/93                                              |
 | Abstract:   A sub-function to extract the VTAM terminal id from  |
 |             the RACF Accessor Environment Element.  The ACEE is  |
 |             not fetch protected.  This function works in ACF2    |
 |             systems.                                             |
 |                                                                  |
 | Call Format:  GETTRID()                                          |
 |                                                                  |
 | Logic: Extracts address of ASCB (PSAAOLD at x'224')              |
 |        Extracts address of ASXB (ASCB+x'6C')                     |
 |        Extracts address of ACEE (ASXB+x'C8')                     |
 |        Extracts ACEETRID                                         |
 +------------------------------------------------------------------+ */
trace

ascb_ptr = get_ptr(224,0)
asxb_ptr = get_ptr(ascb_ptr,'6c')
acee_ptr = get_ptr(asxb_ptr,'c8')
aceetrid = get_data(acee_ptr,'40',8)
exit aceetrid

/* +-----------------------------------------+
   | Procedures and functions defined below. |
   +-----------------------------------------+ */

get_ptr: procedure
    /* +-----------------------------------------+
       | returns a 4 byte pointer as hexadecimal |
       | string at address addr+offset.          |
       | ADDR and OFFSET must be HEX strings.    |
       +-----------------------------------------+ */
  arg addr, offset
  temp = d2x(x2d(addr) + x2d(offset))
  return c2x(storage(temp,4))
  exit

get_data: procedure
    /* +-----------------------------------------+
       | returns LENGTH bytes at ADDR+OFFSET as  |
       | an EBCDIC string.                       |
       | ADDR and OFFSET must be HEX strings.    |
       | LENGTH must be a decimal string.        |
       +-----------------------------------------+ */
  arg addr, offset, length
  temp = d2x(x2d(addr) + x2d(offset))
  return storage(temp,length)
  exit
/* J. KALINICH, X4521 */
/* EXEC TO GET THE RACF ACEE TERMINAL ID             */
./ ADD NAME=GO                                     12SEP93 17.34 --
ISREDIT MACRO (PARM)
CONTROL NOMSG MAIN NOLIST NOCONLIST NOSYMLIST
IF &STR(&PARM) ^= &STR() -
  THEN -
    DO
      ISREDIT SUBMIT
      /* DO NOT INVOKE IOF IF ANY PARM PASSED */
      EXIT
    END
  ELSE -
    DO
      ISREDIT SUBMIT
      ISPEXEC SELECT PGM(IOFSPF) NEWAPPL(IOF) PASSLIB
    END
/* J. KALINICH, X4521 */
/* EDIT MACRO TO SUBMIT JOB AND INVOKE IOF */
./ ADD NAME=ISFP                                   12SEP93 17.34 --
PDF
/* J. KALINICH, X4521 */
/* FOR THOSE OF USE WHO CAN'T SPELL */
./ ADD NAME=JC                                     12SEP93 17.34 --
ISREDIT MACRO (JCCLASS)
/**********************************************************************/
/*    JOB CARD MACRO:                                                 */
/*                                                                    */
/*    IF INVOKED WITH A JOB CLASS PARAMETER (E.G., "JC B"), THEN      */
/*    THE PANEL WILL NOT BE DISPLAYED AND THE JOB CARD WILL BE BUILT  */
/*    WITH THE PROFILE VARIABLES THAT HAVE BEEN SAVED.                */
/*                                                                    */
/**********************************************************************/
CONTROL NOMSG NOFLUSH NOLIST NOCONLIST NOSYMLIST
ISPEXEC VGET (JCPRE,JCSU,JCACC,JCNAME,JCNOTIFY,JCMC,JCRM,+
              JCTIME,JCOTHER1,JCOTHER2,JCOTHER3,+
              JCPROC,JCJXEQ,JCJPRT) PROFILE
IF &STR(&JCCLASS) ^= &Z -
  THEN -
    DO
      ISPEXEC CONTROL NONDISPL ENTER
      ISPEXEC DISPLAY PANEL(JC)
      IF &LASTCC > 0 -
        THEN -
          EXIT
    END
  ELSE -
    DO
      ISPEXEC DISPLAY PANEL(JC)
      IF &LASTCC > 0 -
        THEN -
          EXIT
    END
ISPEXEC VPUT (JCPRE,JCSU,JCACC,JCNAME,JCNOTIFY,JCMC,JCRM,+
              JCTIME,JCOTHER1,JCOTHER2,JCOTHER3,+
              JCPROC,JCJXEQ,JCJPRT) PROFILE
IF &STR(&JCPROC) ^= &Z -
  THEN -
    DO
      IF &SUBSTR(1,&STR(&JCPROC)) = ' -
        THEN -
          SET JCPROC = &SUBSTR(2:&LENGTH(&STR(&JCPROC))-1,&STR(&JCPROC))
        ELSE -
          SET JCPROC = &STR(&SYSUID..&STR(&JCPROC))
    END
IF &STR(&JCOTHER1) ^= &Z -
  THEN -
    DO
      IF &SUBSTR(&LENGTH(&STR(&JCOTHER1)),&STR(&JCOTHER1)) ^= &STR(,) -
        THEN -
          SET JCOTHER1 = &STR(&JCOTHER1)&STR(,)
    END
IF &STR(&JCOTHER2) ^= &Z -
  THEN -
    DO
      IF &SUBSTR(&LENGTH(&STR(&JCOTHER2)),&STR(&JCOTHER2)) ^= &STR(,) -
        THEN -
          SET JCOTHER2 = &STR(&JCOTHER2)&STR(,)
    END
IF &STR(&JCOTHER3) ^= &Z -
  THEN -
    DO
      IF &SUBSTR(&LENGTH(&STR(&JCOTHER3)),&STR(&JCOTHER3)) ^= &STR(,) -
        THEN -
          SET JCOTHER3 = &STR(&JCOTHER3)&STR(,)
    END
SET JOB1  = &STR(//&JCPRE.&JCSU JOB (&JCACC),'&JCNAME',)
SET JOBO1 = &STR(//             &JCOTHER1)
SET JOBO2 = &STR(//             &JCOTHER2)
SET JOBO3 = &STR(//             &JCOTHER3)
SET JOB2  = &STR(//             CLASS=&JCCLASS,)
SET JOB3  = &STR(//             TIME=(&JCTIME),)
SET JOB4  = &STR(//             NOTIFY=&JCNOTIFY,)
SET JOB5  = &STR(//             MSGCLASS=&JCMC)
SET JOB6  = &STR(&STR(/*)JOBPARM R=&JCRM,T=9999,L=9999)
SET JOB7  = &STR(&STR(/*)ROUTE XEQ   &JCJXEQ)
SET JOB8  = &STR(&STR(/*)ROUTE PRINT &JCJPRT)
SET JOB9  = &STR(//PROCLIB  DD  DSN=&JCPROC,DISP=SHARE)
ISREDIT (TOP,BOT) = DISPLAY_LINES
IF &TOP = 1                                  /* IS THERE A LINE 1? */ -
  THEN                                       /* YES */ -
    DO
      IF &STR(&JCPROC) ^= &Z -
        THEN -
          ISREDIT LINE_BEFORE .ZFIRST = "&JOB9"
      IF &STR(&JCJPRT) ^= &Z -
        THEN -
          ISREDIT LINE_BEFORE .ZFIRST = "&JOB8"
      IF &STR(&JCJXEQ) ^= &Z -
        THEN -
          ISREDIT LINE_BEFORE .ZFIRST = "&JOB7"
      ISREDIT LINE_BEFORE .ZFIRST = "&JOB6"
      ISREDIT LINE_BEFORE .ZFIRST = "&JOB5"
      IF &STR(&JCNOTIFY) ^= &Z -
        THEN -
          ISREDIT LINE_BEFORE .ZFIRST = "&JOB4"
      IF &STR(&JCTIME) ^= &Z -
        THEN -
          ISREDIT LINE_BEFORE .ZFIRST = "&JOB3"
      ISREDIT LINE_BEFORE .ZFIRST = "&JOB2"
      IF &STR(&JCOTHER3) ^= &Z -
        THEN -
          ISREDIT LINE_BEFORE .ZFIRST = "&JOBO3"
      IF &STR(&JCOTHER2) ^= &Z -
        THEN -
          ISREDIT LINE_BEFORE .ZFIRST = "&JOBO2"
      IF &STR(&JCOTHER1) ^= &Z -
        THEN -
          ISREDIT LINE_BEFORE .ZFIRST = "&JOBO1"
      ISREDIT LINE_BEFORE .ZFIRST = "&JOB1"
    END
  ELSE                                       /* NO, THEN NEW MEMBER */ -
    DO
      ISREDIT LINE_AFTER .ZFIRST = "&JOB1"
      IF &STR(&JCPROC) ^= &Z -
        THEN -
          ISREDIT LINE_AFTER .ZFIRST = "&JOB9"
      IF &STR(&JCJPRT) ^= &Z -
        THEN -
          ISREDIT LINE_AFTER .ZFIRST = "&JOB8"
      IF &STR(&JCJXEQ) ^= &Z -
        THEN -
          ISREDIT LINE_AFTER .ZFIRST = "&JOB7"
      ISREDIT LINE_AFTER .ZFIRST = "&JOB6"
      ISREDIT LINE_AFTER .ZFIRST = "&JOB5"
      IF &STR(&JCNOTIFY) ^= &Z -
        THEN -
          ISREDIT LINE_AFTER .ZFIRST = "&JOB4"
      IF &STR(&JCTIME) ^= &Z -
        THEN -
          ISREDIT LINE_AFTER .ZFIRST = "&JOB3"
      ISREDIT LINE_AFTER .ZFIRST = "&JOB2"
      IF &STR(&JCOTHER3) ^= &Z -
        THEN -
          ISREDIT LINE_AFTER .ZFIRST = "&JOBO3"
      IF &STR(&JCOTHER2) ^= &Z -
        THEN -
          ISREDIT LINE_AFTER .ZFIRST = "&JOBO2"
      IF &STR(&JCOTHER1) ^= &Z -
        THEN -
          ISREDIT LINE_AFTER .ZFIRST = "&JOBO1"
    END
/* J. KALINICH, X4521 */
/* EDIT MACRO TO BUILD JOBCARD SEQUENCE */
./ ADD NAME=JCI                                    12SEP93 17.34 --
ISREDIT MACRO (JCCLASS)
/**********************************************************************/
/*    JOB CARD INITIAL MACRO:                                         */
/*                                                                    */
/*    USE AS AN INITIAL MACRO TO BUILD A JOB CARD AFTER FILE          */
/*    TAILORING HAS CREATED ALL THE OTHER JCL.                        */
/*                                                                    */
/*    THE PANEL WILL BE DISPLAYED AND THE JOB CARD WILL BE BUILT      */
/*    WITH THE PROFILE VARIABLES THAT HAVE BEEN SAVED.                */
/*                                                                    */
/**********************************************************************/
CONTROL NOMSG NOFLUSH NOLIST NOCONLIST NOSYMLIST
ISPEXEC VGET (JCPRE,JCSU,JCACC,JCNAME,JCNOTIFY,JCMC,JCRM,+
              JCTIME,JCOTHER1,JCOTHER2,JCOTHER3,+
              JCPROC,JCJXEQ,JCJPRT) PROFILE
IF &STR(&JCCLASS) ^= &Z -
  THEN -
    DO
      ISPEXEC CONTROL NONDISPL ENTER
      ISPEXEC DISPLAY PANEL(JC)
      IF &LASTCC > 0 -
        THEN -
          EXIT
    END
  ELSE -
    DO
      ISPEXEC DISPLAY PANEL(JC)
      IF &LASTCC > 0 -
        THEN -
          EXIT
    END
ISPEXEC VPUT (JCPRE,JCSU,JCACC,JCNAME,JCNOTIFY,JCMC,JCRM,+
              JCTIME,JCOTHER1,JCOTHER2,JCOTHER3,+
              JCPROC,JCJXEQ,JCJPRT) PROFILE
IF &STR(&JCPROC) ^= &Z -
  THEN -
    DO
      IF &SUBSTR(1,&STR(&JCPROC)) = ' -
        THEN -
          SET JCPROC = &SUBSTR(2:&LENGTH(&STR(&JCPROC))-1,&STR(&JCPROC))
        ELSE -
          SET JCPROC = &STR(&SYSUID..&STR(&JCPROC))
    END
IF &STR(&JCOTHER1) ^= &Z -
  THEN -
    DO
      IF &SUBSTR(&LENGTH(&STR(&JCOTHER1)),&STR(&JCOTHER1)) ^= &STR(,) -
        THEN -
          SET JCOTHER1 = &STR(&JCOTHER1)&STR(,)
    END
IF &STR(&JCOTHER2) ^= &Z -
  THEN -
    DO
      IF &SUBSTR(&LENGTH(&STR(&JCOTHER2)),&STR(&JCOTHER2)) ^= &STR(,) -
        THEN -
          SET JCOTHER2 = &STR(&JCOTHER2)&STR(,)
    END
IF &STR(&JCOTHER3) ^= &Z -
  THEN -
    DO
      IF &SUBSTR(&LENGTH(&STR(&JCOTHER3)),&STR(&JCOTHER3)) ^= &STR(,) -
        THEN -
          SET JCOTHER3 = &STR(&JCOTHER3)&STR(,)
    END
SET JOB1  = &STR(//&JCPRE.&JCSU JOB (&JCACC),'&JCNAME',)
SET JOBO1 = &STR(//             &JCOTHER1)
SET JOBO2 = &STR(//             &JCOTHER2)
SET JOBO3 = &STR(//             &JCOTHER3)
SET JOB2  = &STR(//             CLASS=&JCCLASS,)
SET JOB3  = &STR(//             TIME=(&JCTIME),)
SET JOB4  = &STR(//             NOTIFY=&JCNOTIFY,)
SET JOB5  = &STR(//             MSGCLASS=&JCMC)
SET JOB6  = &STR(&STR(/*)JOBPARM R=&JCRM,T=9999,L=9999)
SET JOB7  = &STR(&STR(/*)ROUTE XEQ   &JCJXEQ)
SET JOB8  = &STR(&STR(/*)ROUTE PRINT &JCJPRT)
SET JOB9  = &STR(//PROCLIB  DD  DSN=&JCPROC,DISP=SHARE)
SET JOBA  = &STR(//         DD  DSN=&JCPROC,DISP=SHARE)
ISREDIT FIND FIRST "//PROCLIB " 1 10
IF &LASTCC = 0 && &STR(&JCPROC) ^= &Z -
  THEN -
      ISREDIT LINE_AFTER .ZCSR = "&JOBA"
  ELSE -
    IF &STR(&JCPROC) ^= &Z -
      THEN -
        ISREDIT LINE_BEFORE .ZFIRST = "&JOB9"
IF &STR(&JCJPRT) ^= &Z -
  THEN -
    ISREDIT LINE_BEFORE .ZFIRST = "&JOB8"
IF &STR(&JCJXEQ) ^= &Z -
  THEN -
    ISREDIT LINE_BEFORE .ZFIRST = "&JOB7"
ISREDIT LINE_BEFORE .ZFIRST = "&JOB6"
ISREDIT LINE_BEFORE .ZFIRST = "&JOB5"
IF &STR(&JCNOTIFY) ^= &Z -
  THEN -
    ISREDIT LINE_BEFORE .ZFIRST = "&JOB4"
IF &STR(&JCTIME) ^= &Z -
  THEN -
    ISREDIT LINE_BEFORE .ZFIRST = "&JOB3"
ISREDIT LINE_BEFORE .ZFIRST = "&JOB2"
IF &STR(&JCOTHER3) ^= &Z -
  THEN -
    ISREDIT LINE_BEFORE .ZFIRST = "&JOBO3"
IF &STR(&JCOTHER2) ^= &Z -
  THEN -
    ISREDIT LINE_BEFORE .ZFIRST = "&JOBO2"
IF &STR(&JCOTHER1) ^= &Z -
  THEN -
    ISREDIT LINE_BEFORE .ZFIRST = "&JOBO1"
ISREDIT LINE_BEFORE .ZFIRST = "&JOB1"
/* RETURN CURSOR TO COMMAND LINE */
EXIT CODE(1)
/* J. KALINICH, X4521 */
/* INITIAL EDIT MACRO TO BUILD JOBCARD SEQUENCE FOR JCL SKELETONS */
./ ADD NAME=LISTDSI                                12SEP93 17.34 --
ISREDIT MACRO (DSNAME)
CONTROL NOMSG MAIN NOLIST NOCONLIST NOSYMLIST
IF &DSNAME ^= &STR() THEN -
  DO
    IF &SUBSTR(1,&DSNAME) = ' -
      THEN -
        SET DSNS = &SUBSTR(2:&LENGTH(&DSNAME)-1,&DSNAME)
      ELSE -
        SET DSNS = &STR(&SYSUID..&DSNAME)
  END
ELSE -
  DO
    ISREDIT (DSNS) = DATASET
  END
LISTDSI '&DSNS' DIRECTORY
SET &DSNS    = &STR(&SYSDSNAME)
SET &ZALVOL  = &STR(&SYSVOLUME)
SET &DEVT    = &STR(&SYSUNIT)
SET &DSORG   = &STR(&SYSDSORG)
SET &ZALRF   = &STR(&SYSRECFM)
SET &ZALLREC = &STR(&SYSLRECL)
SET &ZALBLK  = &STR(&SYSBLKSIZE)
SET &TOTA    = &STR(&SYSALLOC)
SET &TOTU    = &STR(&SYSUSED)
SET &ZAL1EX  = &STR(&SYSPRIMARY)
SET &ZAL2EX  = &STR(&SYSSECONDS)
SET &ZALSPC  = &STR(&SYSUNITS)
SET &EXTA    = &STR(&SYSEXTENTS)
SET &CRDT    = &STR(&SYSCREATE)
IF &SYSEXDATE = 0 -
  THEN -
    SET &EXDATE  = &STR(**NONE**)
  ELSE -
    SET &EXDATE  = &STR(&SYSEXDATE)
SET &ZALDIR  = &STR(&SYSADIRBLK)
SET &DIRU    = &STR(&SYSUDIRBLK)
SET &NRMEM   = &STR(&SYSMEMBERS)
SET &EXTU    = &STR(N/A)
ISPEXEC DISPLAY PANEL(ISRUAIPO)
END
/* J. KALINICH, X4521 */
/* EDIT MACRO TO LISTDSI AND DISPLAY INFO WITH =3.2 PANEL */
./ ADD NAME=MEMLIST                                12SEP93 17.34 --
ISREDIT MACRO (FROM,TO)
CONTROL NOMSG NOFLUSH NOLIST NOCONLIST NOSYMLIST
ISREDIT (WORKDSN) = DATASET
ISREDIT (XLINE) = DISPLAY_LINES
IF &STR(&XLINE) = &STR() THEN -
  DO
    SET ZEDSMSG = &STR(EMPTY DATASET)
    SET ZEDLMSG = &STR(ML COMMAND NOT VALID FOR EMPTY DATASET)
    ISPEXEC SETMSG MSG(ISRZ001W)
    EXIT CODE(4)
  END
SET &MAX = 1
SET &Z9 = Z9999999
IF &FROM = ? THEN DO
  ISPEXEC DISPLAY PANEL(#MEMLIST)
  EXIT
END
IF &TO = THEN SET &TO = &Z9
IF &FROM = THEN -
  SET &RT = &STR()
ELSE -
  SET &RT = &STR(FROM &FROM TO &TO)
SET &TARGET1 = &FROM
SET T1 = &LENGTH(&TARGET1)
IF &FROM =  THEN SET &T1 = 8
SET &TARGET2 = &TO
SET T2 = &LENGTH(&TARGET2)
SET PDSDSN = &WORKDSN
/* INITIALIZE DATASET */
ISPEXEC  LMINIT DATAID(PDSID) DATASET('&PDSDSN') +
                ENQ(SHRW)                        +
                ORG(PDSORG)
SET LMRC = &LASTCC
IF &LMRC ^= 0 THEN +
   DO
     SET ZEDSMSG = &STR(LMINIT FAILED - RETURN CODE &LMRC)
     SET ZEDLMSG = &STR(DATA SET IS NOT ALLOCATED OR NOT PARTITIONED)
     ISPEXEC SETMSG MSG(ISRZ001W)
     EXIT CODE(8)
   END
/* OPEN DATA SET */
ISPEXEC LMOPEN DATAID(&PDSID) OPTION(INPUT)
SET LMRC = &LASTCC
DO WHILE (&LMRC = 0)
  /* BUILD MEMBER LIST AND RETURN NEXT MEMBER */
  ISPEXEC LMMLIST DATAID(&PDSID) -
    OPTION(LIST) MEMBER(MEMBER) -
    STATS(NO)
  SET LMRC = &LASTCC
  IF &LMRC = 0 THEN /* NOT END OF MEMBER LIST */ +
    DO
      IF &SUBSTR(1:&T1,&MEMBER) GE &TARGET1 AND +
         &SUBSTR(1:&T2,&MEMBER) LE &TARGET2  THEN -
        DO
          SET &X = &STR(&&L&MAX)
          IF &LENGTH(&STR(&X)) > 60 THEN -
            DO
              SET &MAX = &MAX + 1
              SET &L&MAX = &STR()
              SET &X = &STR(&&L&MAX)
            END
          SET &X = &STR(&X)&STR(&MEMBER  )
          SET &L&MAX = &STR(&X)
        END
    END
END
ISREDIT LINE_AFTER &XLINE = NOTELINE ' '
/* SEND OUT IN REVERSE ORDER */
SET I = &MAX
DO WHILE (&I > 0)
  SET X = &STR(&&L&I)
  ISREDIT LINE_AFTER &XLINE = NOTELINE '&X'
  SET I = &I - 1
END
ISREDIT LINE_AFTER &XLINE = +
    MSGLINE 'MEMLIST:  &RT'
ISREDIT LINE_AFTER &XLINE = NOTELINE ' '
/* FREE MEMBER LIST */
ISPEXEC LMMLIST DATAID(&PDSID) OPTION(FREE)
/* CLOSE DATA SET */
ISPEXEC LMCLOSE DATAID(&PDSID)
/* FREE DATA ID */
ISPEXEC LMFREE  DATAID(&PDSID)
EXIT CODE(0)
/* J. KALINICH, X4521 */
/* EDIT MACRO TO DISPLAY A PDS MEMBER LIST                          */
/* SIMA MODIFICATION TO CBT FILE 095 - USE =NOTE= INSTEAD OF WRITE  */
./ ADD NAME=OPER                                   12SEP93 17.34 --
ISREDIT MACRO (PARM) NOPROCESS
CONTROL NOFLUSH NOMSG NOLIST NOCONLIST NOSYMLIST ASIS
IF &PARM = HELP OR   +
   &PARM = ?    THEN +
 DO
  ISPEXEC SELECT PGM(ISPTUTOR) PARM(#OPER)
  EXIT
 END
/* PROCESS LINE COMMANDS, CHECK IF "C" WAS SPECIFIED */
ISPEXEC CONTROL ERRORS RETURN
ISREDIT PROCESS RANGE C
IF &LASTCC > 0 THEN +
   DO
     SET ZEDSMSG = &STR(ENTER "C" LINE CMD)
     SET ZEDLMSG = &STR(SDSF OPER REQUIRES A "Cn" OR "CC" LINE COMMAND)
     ISPEXEC SETMSG MSG(ISRZ001W)
     EXIT CODE(12)
   END
ISREDIT (LINE1) = LINENUM .ZFRANGE   /* FIRST LINE IN RANGE */
ISREDIT (LINE2) = LINENUM .ZLRANGE   /* LAST LINE IN RANGE  */
/*                                                          */
/*  )INIT SECTION OF PANEL ISFPANEL HAS BEEN MODIFIED TO    */
/*  ISSUE .RESP=END IF &SDSFOPER HAS BEEN SET TO 'END'      */
/*  BY THIS EDIT MACRO.  CAUSES SDSF PANEL NOT TO DISPLAY   */
/*  AFTER EACH OPERATOR COMMAND HAS BEEN ISSUED.            */
/*                                                          */
SET &SDSFOPER = &STR(END)
ISPEXEC VPUT (SDSFOPER) SHARED
/* PASS THE COMMAND LINES TO SDSF */
SET I = &LINE1
DO WHILE &I <= &LINE2
  ISREDIT (SDSFCMD) = LINE &I
  /* IF NO '/' IN COLUMN 1, THEN ADD ONE FOR SDSF */
  IF &SUBSTR(1:1,&SDSFCMD) ^= &STR(/) THEN -
    SET &SDSFCMD = &STR(/)&STR(&SDSFCMD)
  ISPEXEC SELECT PGM(ISFISP) PARM(&STR(&SDSFCMD))
  /* LEAVE OUT NEWAPPL(ISF) OR SDSFOPER VARIABLE NOT PASSED */
  SET I = &I + 1
END
EXIT CODE(1)  /* RETURN CURSOR TO COMMAND LINE */
/* J. KALINICH, X4521 */
/* EDIT MACRO TO PASS MVS/JES2 OPERATOR COMMANDS TO SDSF */
./ ADD NAME=PLUG                                   12SEP93 17.34 --
/* SPF/PC Version 3.0 */
"ISREDIT MACRO (PLUGSTR COL) NOPROCESS"
TRACE
IF plugstr = '' THEN
  DO
    zedsmsg = 'INVALID ARGUMENT'
    zedlmsg = 'YOU MUST SPECIFY THE PLUG STRING'
    "ISPEXEC SETMSG MSG(ISRZ001W)"
    EXIT 12
  END
/* IF NO COLUMN SPECIFIED, THEN USE CURSOR POSITION */
IF col = '' THEN
  DO
    "ISREDIT (END)  = LRECL"
    "ISREDIT (CL,CC) = CURSOR"
    IF cc = 0 | cc > end THEN
      DO
        zedsmsg = 'SPECIFY STARTING COL'
        zedlmsg = 'USE ARGUMENT OR CURSOR LOCATION FOR START OF PLUG'
        "ISPEXEC SETMSG MSG(ISRZ001W)"
        EXIT 12
      END
    ELSE
      col = cc
  END
/* PROCESS LINE COMMANDS, CHECK IF O WAS SPECIFIED */
"ISPEXEC CONTROL ERRORS RETURN"
"ISREDIT PROCESS RANGE O"
IF rc > 0 THEN
  DO
    zedsmsg = 'ENTER "O" LINE CMD'
    zedlmsg = 'YOU MUST SPECIFY THE LINES',
              'TO BE PLUGGED, USING "On" OR "OO"'
    "ISPEXEC SETMSG MSG(ISRZ001W)"
    EXIT 12
  END
"ISREDIT (FR)  = LINENUM .ZFRANGE"
"ISREDIT (LR)  = LINENUM .ZLRANGE"
SELECT
       WHEN (fr = 0) |,
            (fr = 0 & lr = 0) THEN
         DO
           zedsmsg = 'ENTER "O" LINE CMD'
           zedlmsg = 'YOU MUST SPECIFY THE LINES',
                     'TO BE PLUGGED, USING "On" OR "OO"',
                     'ON A LINE NUMBER'
           "ISPEXEC SETMSG MSG(ISRZ001W)"
           EXIT 12
         END
       OTHERWISE
         DO
           IF lr = 0 THEN
            "ISREDIT (LR)  = LINENUM .ZLAST"
         END
END  /* SELECT */
/* SET CURSOR ON FIRST LINE IN RANGE */
"ISREDIT CURSOR = .ZFRANGE 1"
pluglen = LENGTH(plugstr)
/* CHECK FOR PLUG STRING DELIMITERS */
IF SUBSTR(plugstr,1,1) = "'" |,
   SUBSTR(plugstr,1,1) = '"' THEN
  pluglen = pluglen - 2
ELSE
  plugstr = "'"plugstr"'"
anychar = COPIES('=',80)
i = fr
DO WHILE i <= lr
  "ISREDIT CHANGE P'"SUBSTR(anychar,1,pluglen)"'" plugstr col
  chgcc = rc
  IF chgcc > 0 THEN
    DO
      zedsmsg = "PLUG FAILED, RC="chgcc
      zedlmsg = "TARGET LINES "fr+0" TO "lr+0" AT COLUMN" col+0
      "ISPEXEC SETMSG MSG(ISRZ001W)"
      EXIT 12
    END
  i = i + 1
END
zedsmsg = "CHARS "plugstr" PLUGGED"
zedlmsg = "CHARS "plugstr" PLUGGED IN LINES "fr+0" TO "lr+0" AT COLUMN"
"ISPEXEC SETMSG MSG(ISRZ001W)"
EXIT 0
/* J. KALINICH, X4521 */
/* EDIT MACRO TO PLUG DATA INTO EDIT BUFFER                  */
./ ADD NAME=RUN                                    12SEP93 17.34 --
ISREDIT MACRO (PARM)
CONTROL NOMSG MAIN NOLIST NOCONLIST NOSYMLIST ASIS
ISPEXEC CONTROL DISPLAY LINE START(1)
ISREDIT (DSN) =  DATASET
ISREDIT (MEM) =  MEMBER
IF &STR(&PARM) = &STR() -
  THEN -
    EXEC '&DSN.(&MEM)'
  ELSE -
    EXEC '&DSN.(&MEM)' '&PARM'
/* J. KALINICH, X4521 */
/* EDIT MACRO TO 'EXECUTE' THE CLIST CURRENTLY BEING EDITED  */
./ ADD NAME=SHOWCUT                                12SEP93 17.34 --
ISREDIT MACRO (PARM1) NOPROCESS
CONTROL NOMSG NOFLUSH NOLIST NOCONLIST NOSYMLIST
ISPEXEC VGET (CUTNAME) PROFILE
SET CT = &CUTNAME
IF &LENGTH(&STR(&PARM1)) > 0 THEN -
  SET CT = &PARM1
SET CUTPST = CUTPST&CT
ISPEXEC CONTROL ERRORS RETURN
ISPEXEC TBOPEN &CUTPST NOWRITE SHARE
ISPEXEC TBTOP  &CUTPST
DO WHILE &RC < 8
  ISPEXEC TBDISPL &CUTPST PANEL(SHOWCUT)
  SET RC = &LASTCC
END
/* J. KALINICH, X4521 */
/* MACRO TO DISPLAY THE PDS 8.4 CUT (EDIT) TABLES       */
./ ADD NAME=SORTWORK                               12SEP93 17.34 --
/* REXX */
PARSE ARG debug .
IF debug = "debug" THEN
  TRACE RESULTS
ELSE
  TRACE OFF
dispcc = 0
DO WHILE dispcc < 8
  "ISPEXEC DISPLAY PANEL(SORTWORK)"
  dispcc = rc
  IF dispcc = 8 THEN EXIT
  SELECT
  WHEN dtyp = 3330 THEN
    DO
      trkcap = 13030
      trkcyl = 19
    END
  WHEN dtyp = 3350 THEN
    DO
      trkcap = 19069
      trkcyl = 30
    END
  WHEN dtyp = 3380 THEN
    DO
      trkcap = 47476
      trkcyl = 15
    END
  WHEN dtyp = 3390 THEN
    DO
      trkcap = 56664
      trkcyl = 15
    END
  END
/* SYNCSORT RELEASE 3.2 (PAGE 11.09) */
ttrk = (numrec * lrecl * 1.3) / trkcap
IF ((numrec * lrecl * 1.3) // trkcap) ^= 0 THEN
  ttrk = (ttrk + 1) % 1
tcyl = ttrk / trkcyl
IF (ttrk // trkcyl) ^= 0 THEN
  tcyl = (tcyl + 1) % 1
ttrksw = ttrk / numsw
IF (ttrk // numsw) ^= 0 THEN
  ttrksw = (ttrksw + 1) % 1
tcylsw = tcyl / numsw
IF (tcyl // numsw) ^= 0 THEN
  tcylsw = (tcylsw + 1) % 1
/* RECOMPUTE TOTAL TRACKS AND CYLINDERS AFTER ROUNDING */
ttrk = ttrksw * numsw
tcyl = tcylsw * numsw
END
/* J.KALINICH, X4521 */
/* EXEC TO COMPUTE SYNCSORT SORTWORK SPACE CALCULATION          */
./ ADD NAME=SUPERC                                 12SEP93 17.34 --
PROC 0 DEBUG
IF &DEBUG = &STR(DEBUG) THEN -
  CONTROL MSG NOFLUSH LIST CONLIST SYMLIST PROMPT
ELSE -
  CONTROL NOMSG NOFLUSH NOLIST NOCONLIST NOSYMLIST
PANEL: +
ISPEXEC DISPLAY PANEL(ISRSFSPR)
IF &LASTCC = 8 THEN EXIT
IF &STR(&ZSSFNDSN) = &STR() THEN -
  SET &NEWDD = &ZSSFNPRJ..&ZSSFNGR1..&ZSSFNTYP
ELSE -
  DO
    IF &SUBSTR(1,&ZSSFNDSN) = &STR(') THEN -
      SET &NEWDD = &STR(&ZSSFNDSN)
    ELSE -
      SET &NEWDD = &STR(&SYSUID..&ZSSFNDSN)
    /* STRIP OUT (*) IF ENTERED WITH OTHER DSNAME               */
    IF &SUBSTR(&LENGTH(&STR(&NEWDD))-3:+
       &LENGTH(&STR(&NEWDD)),&STR(&NEWDD)) = &STR((*)') THEN -
      SET &NEWDD = &SUBSTR(2:&LENGTH(&STR(&NEWDD))-4,&STR(&NEWDD))
    IF &SUBSTR(&LENGTH(&STR(&NEWDD))-2:+
       &LENGTH(&STR(&NEWDD)),&STR(&NEWDD)) = &STR((*)) THEN -
      SET &NEWDD = &SUBSTR(1:&LENGTH(&STR(&NEWDD))-3,&STR(&NEWDD))
  END
IF &ZSSFNVOL = &STR() THEN -
  SET &NEWVOL = &STR()
ELSE -
  SET &NEWVOL = &STR(,VOL=SER=&ZSSFNVOL,UNIT=SYSALLDA)
IF &ZSSFMULT = &STR(YES) THEN -
  DO
    ISPEXEC DISPLAY PANEL(ISRSFSST)
    IF &LASTCC = 8 THEN GOTO PANEL
  END
SET I = 1
DO WHILE &I <= 10
  SET &SRCH&I = &STR()
  SET &SFS = &&ZSSFS&I
  IF &STR(&SFS) ^= &STR() THEN -
    DO
      IF &SUBSTR(1:1,&STR(&SFS)) ^= &STR(') THEN -
        DO
          IF &LENGTH(&STR(&SFS)) > 5 THEN -
            DO
              IF &SUBSTR(&LENGTH(&STR(&SFS))-4:+
                 &LENGTH(&STR(&SFS)),&STR(&SFS)) = &STR( WORD) THEN -
                SET &SFS = &SUBSTR(1:&LENGTH(&STR(&SFS))-3,&STR(&SFS))
            END
          IF &LENGTH(&STR(&SFS)) > 7 THEN -
            DO
              IF &SUBSTR(&LENGTH(&STR(&SFS))-6:+
                 &LENGTH(&STR(&SFS)),&STR(&SFS)) = &STR( PREFIX) THEN -
                SET &SFS = &SUBSTR(1:&LENGTH(&STR(&SFS))-5,&STR(&SFS))
            END
          IF &LENGTH(&STR(&SFS)) > 7 THEN -
            DO
              IF &SUBSTR(&LENGTH(&STR(&SFS))-6:+
                 &LENGTH(&STR(&SFS)),&STR(&SFS)) = &STR( SUFFIX) THEN -
                SET &SFS = &SUBSTR(1:&LENGTH(&STR(&SFS))-5,&STR(&SFS))
            END
          IF &SUBSTR(&LENGTH(&STR(&SFS))-1:+
                     &LENGTH(&STR(&SFS)),&STR(&SFS)) = &STR( C) OR -
             &SUBSTR(&LENGTH(&STR(&SFS))-1:+
                     &LENGTH(&STR(&SFS)),&STR(&SFS)) = &STR( P) OR -
             &SUBSTR(&LENGTH(&STR(&SFS))-1:+
                     &LENGTH(&STR(&SFS)),&STR(&SFS)) = &STR( S) OR -
             &SUBSTR(&LENGTH(&STR(&SFS))-1:+
                     &LENGTH(&STR(&SFS)),&STR(&SFS)) = &STR( W) THEN -
            DO
              SET &SFS = &STR(')+
                         &SUBSTR(1:&LENGTH(&STR(&SFS))-2,&STR(&SFS))+
                         &STR(',)+
                         &SUBSTR(&LENGTH(&STR(&SFS)),&STR(&SFS))
            END
          ELSE -
            SET &SFS = &STR('&STR(&SFS)')
        END
      IF &SUBSTR(&LENGTH(&STR(&SFS)),&STR(&SFS)) = &STR(C) THEN -
        DO
          SET &SFS = &SUBSTR(1:&LENGTH(&STR(&SFS))-2,&STR(&SFS))
          SET &SRCH&I = &STR(SRCHFORC)
        END
      ELSE -
        DO
          SET &SRCH&I = &STR(SRCHFOR)
        END
      SET &SFS&I = &STR(&SFS)
    END
  SET I = &I + 1
END
ISPEXEC FTOPEN
ISPEXEC FTINCL SUPERC
ISPEXEC FTCLOSE NAME(SUPERC)
/* INVOKE INITIAL JOBCARD MACRO AND PUT USER IN EDIT */
ISPEXEC EDIT DATASET(GEN.CNTL(SUPERC)) MACRO(JCI)
/* J. KALINICH, X4521 */
/* CLIST TO CREATE JCL TO RUN OPTION 3.14 SEARCH-FOR IN BATCH     */
./ ADD NAME=SYSLOG                                 12SEP93 17.34 --
PROC 0 DEBUG
IF &DEBUG = &STR(DEBUG) THEN -
  CONTROL MSG NOFLUSH LIST CONLIST SYMLIST PROMPT
ELSE -
  CONTROL NOMSG NOFLUSH NOLIST NOCONLIST NOSYMLIST ASIS
DO WHILE &LOGCC < 8
  ISPEXEC DISPLAY PANEL(SYSLOG)
  SET &LOGCC = &LASTCC
  IF &LOGCC = 8 THEN EXIT
  IF &STR(&LOGDAY) = &STR(*) THEN -
      ISPEXEC SELECT PGM(ISFISP) PARM('LOG') NEWAPPL(ISF) PASSLIB
    ELSE -
      ISPEXEC BROWSE DATASET('AS.LOGA1&LOGDAY')
END
/* J.KALINICH, X4521 */
/* CLIST TO BROWSE SYSLOG DATASETS OR CURRENT SYSLOG VIA SDSF */
./ ADD NAME=TM                                     12SEP93 17.34 --
/*   REXX                                                       */
/*   Test under Mask (TM):                                      */
/*                                                              */
/* Bit 0:  Byte // 256, IF remainder > 127 THEN 'ON' ELSE 'OFF' */
/* Bit 1:  Byte // 128, IF remainder >  63 THEN 'ON' ELSE 'OFF' */
/* Bit 2:  Byte //  64, IF remainder >  31 THEN 'ON' ELSE 'OFF' */
/* Bit 3:  Byte //  32, IF remainder >  15 THEN 'ON' ELSE 'OFF' */
/* Bit 4:  Byte //  16, IF remainder >   7 THEN 'ON' ELSE 'OFF' */
/* Bit 5:  Byte //   8, IF remainder >   3 THEN 'ON' ELSE 'OFF' */
/* Bit 6:  Byte //   4, IF remainder >   1 THEN 'ON' ELSE 'OFF' */
/* Bit 7:  Byte //   2, IF remainder >   0 THEN 'ON' ELSE 'OFF' */
/*                                                              */
/* EXAMPLE:                                                     */
     pscbatr1 = 'C7'x
     say "PSCBATR1 = X'"c2x(pscbatr1)"'"
     pscbatr1 = c2d(pscbatr1)  /* must be decimal for divide */
     IF (pscbatr1 // 256) > 127 THEN
       say 'Bit 0 - ON'
     ELSE
       say 'Bit 0 - OFF'
     IF (pscbatr1 // 128) >  63 THEN
       say 'Bit 1 - ON'
     ELSE
       say 'Bit 1 - OFF'
     IF (pscbatr1 //  64) >  31 THEN
       say 'Bit 2 - ON'
     ELSE
       say 'Bit 2 - OFF'
     IF (pscbatr1 //  32) >  15 THEN
       say 'Bit 3 - ON'
     ELSE
       say 'Bit 3 - OFF'
     IF (pscbatr1 //  16) >   7 THEN
       say 'Bit 4 - ON'
     ELSE
       say 'Bit 4 - OFF'
     IF (pscbatr1 //   8) >   3 THEN
       say 'Bit 5 - ON'
     ELSE
       say 'Bit 5 - OFF'
     IF (pscbatr1 //   4) >   1 THEN
       say 'Bit 6 - ON'
     ELSE
       say 'Bit 6 - OFF'
     IF (pscbatr1 //   2) >   0 THEN
       say 'Bit 7 - ON'
     ELSE
       say 'Bit 7 - OFF'
/*                                                              */
/*  Test for 2 bits turned on                                   */
/*                                                              */
     IF (pscbatr1 // 256) > 127 &,
        (pscbatr1 //   2) >   0 THEN
       say 'Bit 0 and Bit 7 - ON'
     ELSE
       say 'Bit 0 and Bit 7 - not ON'
     IF (pscbatr1 // 256) > 127 &,
        (pscbatr1 //  64) >  31 THEN
       say 'Bit 0 and Bit 2 - ON'
     ELSE
       say 'Bit 0 and Bit 2 - not ON'
/* J. KALINICH, X4521 */
/* EXEC TO SHOW BIT TESTING WITH REXX                */
./ ADD NAME=TRAPCMD                                12SEP93 17.34 --
/* REXX */
PARSE ARG tsocmd debug .
IF debug = "debug" THEN
  TRACE RESULTS
ELSE
  TRACE OFF
ADDRESS ISPEXEC
"ISPEXEC TBCREATE TRAPTBL NAMES(CMDLINE) NOWRITE REPLACE"
IF rc > 4 THEN
  DO
    SAY TBCREATE failed
    EXIT
  END
dquayle = outtrap("sysoutline.","*")
ADDRESS TSO
tsocmd
ADDRESS ISPEXEC
DO i = 1 to sysoutline.0
  cmdline = sysoutline.i
  "ISPEXEC TBADD TRAPTBL"
  IF rc <> 0 THEN
    DO
      SAY TBADD failed
    END
END
"ISPEXEC TBTOP TRAPTBL"
"ISPEXEC VGET (ZSCR) PROFILE"
tbcc = 0
DO WHILE tbcc < 8
  "ISPEXEC TBDISPL TRAPTBL PANEL(TRAPTBL) CURSOR(ZCMD)"
  tbcc = rc
END
"ISPEXEC TBCLOSE TRAPTBL"
EXIT
/* J. KALINICH, X4521 */
/* EXEC TO TRAP AND DISPLAY TSO COMMAND OUTPUT IN ISPF TABLE         */
./ ADD NAME=UNX                                    12SEP93 17.34 --
ISREDIT MACRO (NLINES)
/*
/* UNX EDIT MACRO - SHOW FIRST N LINES OF EACH 'X-CLUDED' BLOCK
/*                  IN THE MEMBER
/*                  DEFAULT = 1 LINE
/*
CONTROL NOFLUSH NOMSG NOLIST NOCONLIST NOSYMLIST
IF &NLINES = HELP OR -
   &NLINES = ?  THEN -
  DO
    ISPEXEC SELECT PGM(ISPTUTOR) PARM(#UNX)
    EXIT
  END
IF &NLINES = &STR() THEN -
  SET &NLINES = 1
ISPEXEC CONTROL ERRORS RETURN
SET &RC  = 0
SET &LINE = 1
DO WHILE &RC < 12
  ISREDIT (XSTATUS) = XSTATUS &LINE
  SET &RC = &LASTCC
  IF &RC = 12 THEN -
    EXIT
  IF &XSTATUS = &STR(X) THEN -
    DO
      SET &XLINES = 0
      DO WHILE &XLINES < &NLINES
        ISREDIT (XSTATUS) = XSTATUS &EVAL(&LINE+&XLINES)
        SET &RC = &LASTCC
        IF &RC = 12 THEN -
          EXIT
        ISREDIT XSTATUS &EVAL(&LINE+&XLINES) = NX
        SET &RC = &LASTCC
        IF &RC = 12 THEN -
          EXIT
        SET &XLINES = &XLINES + 1
      END
      SET &LINE = &LINE + &EVAL(&NLINES)
      DO WHILE &XSTATUS = &STR(X)
        ISREDIT (XSTATUS) = XSTATUS &LINE
        SET &RC = &LASTCC
        IF &RC = 12 THEN -
          EXIT
        SET &LINE = &LINE + 1
      END
    END
  ELSE -
    SET &LINE = &LINE + 1
END
ISREDIT LOCATE 0
EXIT CODE(1)  /* RETURN CURSOR TO COMMAND LINE */
END
/* J. KALINICH, X4521 */
/* EDIT MACRO TO SHOW FIRST N LINES IN EACH 'X-CLUDED' BLOCK    */
