C          DATA SET GU683000   AT LEVEL 009 AS OF 04/07/77
C
C     PGM-ID.  GU683000.
C     AUTHOR.  DON HIGGINS.
C     DATE.    08/27/75.
C     REMARKS. GET/PUT SUBROUTINES TO ACCESS A DIRECT ACCESS FILE
C              WHICH IS USED TO MAINTAIN MULTIPLE FIFO QUEUES OF
C              USER DATA RECORDS.
C     CALLS.
C
C              QUECLR - INITIALIZE THE QUEUE
C              QUEPUT - ADD RECORD TO THE END OF A QUEUE
C              QUEGET - GET NEXT RECORD FROM A QUEUE
C
C     ARGUMENTS.
C
C              QUEUE - NUMBER OF THE QUEUE (SEE MAXQUE)
C              REC   - RECORD ARRAY NAME
C              STATUS- RESULT INDICATOR
C
C                        1 - SUCCESSFUL GET OR PUT
C                        2 - NO FREE SPACE IN FILE (SEE MAXREC)
C                        3 - INVALID QUEUE NUMBER (SEE MAXQUE)
C                        4 - NO RECORDS ON SPECIFIED QUEUE
C
C              TQUE  - TOTAL NUMBER OF RECORDS ON SPECIFIED QUEUE
C                      AFTER THE GET OR PUT OPERATION
C
C     CONSTANTS.
C
C              MAXQUE - MAXIMUM NUMBER OF QUEUES ALLOWED
C              MAXREC - MAXIMUM NUMBER OF RECORDS ON FILE
C              MAXL  -  MAXIMUM NUMBER OF WORDS IN A RECORD
C              NF    - DIRECT ACCESS FILE NUMBER (FTXXF001)
C
C     NOTES.
C
C                  1.    THE FILE MUST BE INITIALIZED ONCE BY QUECLR
C                        WHENEVER A NEW FILE IS ALLOCATED AND WHENEVER
C                        ANY OF THE ABOVE CONSTANTS ARE CHANGED. IT
C                        SHOULD NOT NEED TO BE INITIALIZED DUE TO
C                        SYSTEM CRASHES UNLESS THE FILE ITSELF HAS BEEN
C                        DAMAGED.
C                        RECORDS LEFT ON THE QUEUE AT THE TIME OF A
C                        CRASH CAN BE PROCESSED AT A LATER DATE.
C                  2.    NOTE THE DEFINE FILE STATEMENT IS IN DEFINE
C                        PROCEDURE AT END OF PROGRAM AND MUST BE
C                        UPDATED WHENEVER THE ABOVE CONSTANTS ARE
C                        CHANGED.
C                  3.    IN ORDER TO SAVE 2 I/O OPERATIONS FOR EACH
C                        QUEPUT, A FREE SLOT IS ALLWAYS CHAINED
C                        TO THE LAST RECORD ON EACH QUEUE. (I.E. EACH
C                        QUEUE HAS 1 FREE SLOT PREALLOCATED TO IT)
C                        ALSO A FREE SLOT IS RESERVED FOR RETURNING
C                        SLOTS TO FREE QUEUE WITHOUT ALLOWING SYSTEM
C                        CRASHES TO LEAVE FILE QUEUES INVALID.
C
C                  4.    THE LENGTH OF EACH RECORD MUST BE AT LEAST
C                        ENOUGH TO HOLD THE CHECKPOINT VARIABLES.
C                  5.    IF OVER 32767 RECORDS ARE ALLOWED, THE QUEUE
C                        CHECKPOINT ARRAYS MUST BE CHANGED TO FULL
C                        WORD INSTEAD OF HALF WORDS.
C                  6.    THIS SUBROUTINE CANNOT BE IN OVERLAY SINCE
C                        IT CONTAINS A DEFINE FILE AND LOCAL VARIABLE
C                        FIRST TIME THROUGH SWITCH.
      SUBROUTINE QUEPUT(QUEUE,REC,STATUS,TQUE)
      IMPLICIT INTEGER(A-Z)
      INTEGER NF/11/,MAXREC/2500/,MAXL/35/,MAXQUE/10/
      INTEGER REC(35)
      INTEGER FREE,HOLD
      INTEGER*2 QSTRT(10),QNEXT(10),QTOT(10)
      INTEGER ZERO/0/
      INTEGER FIRST/0/,TRUE/0/,FALSE/1/
C
C     PERFORM PARAMETER CHECK AND FIRST TIME SWITCH
C
      PM  CHECK
C
C     IS THERE ANY FREE SPACE LEFT IN FILE
C
      IF  (FREE.EQ.ZERO)
          STATUS=2
          TQUE=QTOT(QUEUE)
          RETURN
      FI
C
C     GET NEXT FREE SLOT
C
      NEXT=FREE
      READ(NF'FREE)FREE
C
C     ADD RECORD TO QUEUE ON FILE
C
      LAST=QNEXT(QUEUE)
      WRITE(NF'LAST)NEXT,REC
      QNEXT(QUEUE)=NEXT
      QTOT(QUEUE)=QTOT(QUEUE)+1
C
C     PERFORM CHECKPOINT
C
      PM  CHKPT
      STATUS=1
      TQUE=QTOT(QUEUE)
      RETURN
C
C     ENTRY POINT FOR GET OPERATION
C
      ENTRY QUEGET(QUEUE,REC,STATUS,TQUE)
C
C     PERFORM PARAMETER CHECK AND FIRST TIME SWITCH
C
      PM  CHECK
C
C     IS THERE A RECORD ON QUEUE
C
      NEXT=QSTRT(QUEUE)
      IF  (NEXT.EQ.QNEXT(QUEUE))
          STATUS=4
          TQUE=0
          RETURN
      FI
C
C     FREE HOLD SLOT
C
      WRITE(NF'HOLD)FREE
      FREE=HOLD
C
C     PUT NEXT RECORD ON HOLD
C
      HOLD=NEXT
C
C     GET NEXT RECORD OFF QUEUE
C
      READ(NF'NEXT)NEXT,REC
      QSTRT(QUEUE)=NEXT
      QTOT(QUEUE)=QTOT(QUEUE)-1
C
C     PERFORM CHECKPOINT
C
      PM  CHKPT
      TQUE=QTOT(QUEUE)
      STATUS=1
      RETURN
C
C     CHECK QUEUE AND FIRST ENTRY
C
      PENTRY CHECK
      IF  (FIRST.EQ.TRUE)
          FIRST=FALSE
          PM   DEFINE
          READ(NF'1)FREE,HOLD,QSTRT,QNEXT,QTOT
      FI
      IF  ((QUEUE.LT.1).OR.(QUEUE.GT.MAXQUE))
          STATUS=3
          TQUE=0
          RETURN
      FI
      PEXIT
C
C     ENTRY POINT FOR INITIALIZING QUEUE
C
      ENTRY QUECLR
      PM  DEFINE
C
C     INITIALIZE CHECKPOINT RECORD
C
      FREE=MAXQUE+3
      HOLD=2
      DO  I=1,MAXQUE
          QSTRT(I)=I+2
          QNEXT(I)=I+2
          QTOT(I)=0
      OD
C
      PM  CHKPT
C
C     INITIALIZE FREE QUEUE
C
      DO  LAST=FREE,MAXREC
          NEXT=LAST+1
          WRITE(NF'LAST)NEXT
      OD
      WRITE(NF'MAXREC)ZERO
      RETURN
C
C     EXECUTE DEFINE FILE LINKAGE CODE PRIOR TO FIRST I/O
C
      PENTRY DEFINE
      DEFINE FILE 11(2500,36,U,IX11)
      PEXIT
C
C     CHECKPOINT FILE QUEUE POINTERS
C
      PENTRY CHKPT
      WRITE(NF'1)FREE,HOLD,QSTRT,QNEXT,QTOT
      PEXIT
      END
