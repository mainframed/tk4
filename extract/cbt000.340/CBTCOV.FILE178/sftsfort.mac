C          DATA SET GU119000   AT LEVEL 025 AS OF 09/08/76
C     PGM-ID.  GU119000 (ALIAS ER011900).
C     AUTHOR.  DON HIGGINS.
C              FLORIDA POWER CORPORATION, B-3
C              P.O. BOX 14042
C              ST. PETERSBURG, FLORIDA 33733
C              (813) 866-4145
C     DATE.    08/30/74
C     REMARKS. TRANSLATE STRUCTURED FORTRAN SOURCE PROGRAM
C              INTO ANS FORTRAN AS FOLLOWS.
C              REVISION 1 - 8/26/76 BY DSH
C                   1.   ADD  ELSEIF (TEST) EXTENSION
C                   2.   FIX ERROR- 0 IS NOT A CONTINUE IN COL. 6
C
C              INPUT STATEMENT  /  OUTPUT STATEMENTS
C
C        1.    IF(TEST)            IF(TEST)GOTO 100
C                                  GOTO 110
C                              100 CONTINUE
C
C        1.1   ELSEIF(TEST)        GOTO 120
C                              110 IF(TEST) GOTO 130
C                                  GOTO 140
C                              130 CONTINUE
C
C        2.    ELSE                GOTO 150
C                              140 CONTINUE
C
C        3.    FI              150 CONTINUE
C                              120 CONTINUE
C
C        4.    PERFORM RTN         ASSIGN 4 TO RTN
C              (OR PM  RTN)        GO TO 5
C                                4 CONTINUE
C
C        5.    PENTRY  RTN       5 CONTINUE
C
C        6.    PEXIT               GOTO 6
C
C        7.    IF(TEST)PEXIT       IF(TEST)GOTO 6
C
C        8.    END               6 GOTO RTN,(4)
C                                  END
C
C        9.    DO I=J,K,L          DO 7 I=J,K,L
C
C       10.    OD                7 CONTINUE
C
C       11.    DO WHILE,(TEST)   8 IF(TEST)GO TO 9
C                                  GOTO 10
C                                9 CONTINUE
C
C       12.    OD                  GOTO 8
C                               10 CONTINUE
C
C       13     DO UNTIL,(TEST)     GOTO 12
C                               11 IF(TEST)GOTO 13
C                               12 CONTINUE
C
C       14.    OD                  GOTO 11
C                               13 CONTINUE
C
C       15.    DO FOREVER       14 CONTINUE
C
C       16.    OD                  GOTO 14
C
C       17.    DOCASE I            GOTO 15
C
C       18.    CASE 1,3,5       17 CONTINUE
C
C       19.    ESAC                GOTO 16
C
C       20.    CASE ELSE        18 CONTINUE
C
C       21.    ESAC                GOTO 16
C
C       22     ESACOD           15 GOTO(17,18,17,18,17),I
C                                  GOTO 18
C                               16 CONTINUE
C
C     LIMITATIONS.
C        1.    MAXIMUM NESTING OF IF, DO, AND DOCASE
C              STATEMENTS IS LIMITED BY THE ARRAYS
C              IFSTK, DOSTK, AND DOCSTK AND THE VARIABLE
C              MAXLVL.
C
C        2.    MAXIMUM NUMBER OF PERFORMED ROUTINES LIMITED
C              ONLY BY THE ARRAY MEMORY AND THE VARIABLE
C              MAXMIM.  EACH ROUTINE REQUIRES 11 ELEMENTS
C              PLUS 2 ELEMENTS PER REFERENCE.  THE NUMBER
C              OF REFERENCES TO A SINGLE ROUTINE IS LIMITED
C              TO 218 DUE TO MAXIMUM CONTINUATIONS ON THE
C              ASSIGNED GOTO STATEMENT.  MEMORY IS FREED AT
C              EACH END STATEMENT.  EACH ROUTINE NAME MUST
C              BE A VALID VARIABLE FOR USE IN ASSIGN AND
C              ASSIGNED GOTO STATEMENTS.
C        3.    MAXIMUM NUMBER OF DOCASE AND CASE STATEMENTS
C              LIMITED ONLY BY THE ARRAY MEMORY AND THE
C              VARIABLE MAXMIM.  EACH DOCASE STATEMENT
C              REQUIRES 12 ELEMENTS AND EACH CASE VALUE
C              REQUIRES  4 ELEMENTS.  MEMORY IS FREED AT
C              EACH ESACOD STATEMENT.  CASE VALUES MUST BE
C              IN THE RANGE OF 1 TO 218 DUE TO MAXIMUM
C              CONTINUATIONS ON COMPUTED GOTO STATEMENT.
C              THE DOCASE INDEX MUST BE A VALID VARIABLE
C              FOR USE IN COMPUTED GOTO.
C        4.    GENERATED STATEMENT NUMBERS START
C              AT THE INITIAL
C              VALUE OF MAXSTM LESS ONE AND ARE GENERATED IN
C              DESCENDING ORDER.  MAXMIN IS RESET AT EACH
C              END STATEMENT.  ANY USER ASSIGNED STATEMENT
C              NUMBERS FOR FORMATS AND I/O EXITS MUST NOT
C              CONFLICT WITH GENERATED STATEMENT NUMBERS
C              AND THEREFORE SHOULD BE ASSIGNED IN THE
C              SMALL POSITIVE INTEGER RANGE.
C        5.    THE FOLLOWING PROGRAM ASSUMPTIONS ARE NOT
C              DEFINED IN THE ANS FORTRAN STANDARD X3.9
C              AND MAY BE MACHINE/COMPILER DEPENDENT.
C                  A.    ANY VALID FORTRAN CHARACTER READ
C                        INTO AN INTEGER VARIABLE UNDER
C                        A1 FORMAT WILL COMPARE EQUAL TO
C                        ANOTHER INTEGER VARIABLE WHICH HAS
C                        BEEN INITIALIZED TO THE SAME
C                        CHARACTER WITH A HOLLERITH DATA
C                        STATEMENT.
C                  B.    THE ALPHA CHARACTERS COMPARE IN
C                        ASCENDING ORDER AND CONTAIN NO
C                        SPECIAL CHARACTERS WITHIN THEIR
C                        RANGE.
C                  C.    THE NUMERIC CHARACTERS COMPARE IN
C                        ASCENDING ORDER AND CONTAIN NO
C                        SPECIAL CHARACTERS WITHIN THEIR
C                        RANGE.
C                  D.    THE DATA STATEMENT INITIALIZATION
C                        VALUE FOR MAXSTM AND RSTMAX OF
C                        100000 IS
C                        WITHIN THE POSITIVE INTEGER RANGE.
C                        THESE MAY BE SET TO 32767 FOR
C                        MANY 16 BIT WORD COMPUTERS.
C                  E.    THE HASHING ROUTINE (GETP43)
C                        ASSUMES THE INTEGER VALUE OF A
C                        CHARACTER CAN BE DIVIDED BY A
C                        CONSTANT AND ADDED TO AN
C                        ACCUMULATOR TO CONVERT THE NAME
C                        TO A NUMERIC INDEX.  THE CONSTANT
C                        SHIFT SHOULD BE RESET TO 2 FOR 16
C                        BIT COMPUTERS FOR BETTER HASHING.
C        6.    THE GENERATED ANS FORTRAN CODE IN ESACOD
C              ASSUMES THAT THE OBJECT CODE FOR A
C              COMPUTED GOTO WILL LIMIT CHECK THE
C              INDEX VARIABLE AND FALL THROUGH IF
C              IT IS OUT OF RANGE.  IF THIS ASSUMPTION
C              IS FALSE FOR A GIVEN COMPILER, THE
C              TRANSLATOR MUST BE MODIFIED TO GENERATE
C              LIMIT CHECK CODE PRECEEDING THE COMPUTED
C              GOTO STATEMENT.
C
C
C     FILES.
C
C        1.    INPUT - DEFINES 80 CHARACTER INPUT FILE
C                      CONTAINING STRUCTURED FORTRAN.
C
C        2.    OUTPUT- DEFINES 80 CHARACTER OUTPUT FILE
C                      CONTAINING ANS FORTRAN.
C
C        3.    LIST  - DEFINES 120 CHARACTER PRINT FILE
C
C
C    STACK ARRAYS
C
      INTEGER  IFSTK(10),DOSTK(10,3),DOCSTK(10),MAXLVL
      DATA     MAXLVL/10/
      INTEGER  IFLVL,DOLVL,DOCLVL
      DATA     IFLVL/0/,DOLVL/0/,DOCLVL/0/
      INTEGER  ELFSTK(10),ELSEIF,AELSE1,AELSE2
      DATA     ELSEIF/0/
C
C     MEMORY ARRAY
C
      INTEGER MEMORY(2000),MAXMEM
      DATA   MAXMEM/2000/
      INTEGER INDEX,INDEX1,MEMPTR
      DATA   MEMPTR/1/
C
C     FILES AND RELATED VARIABLES
C
      INTEGER  INPUT,OUTPUT,LIST
      DATA     INPUT/5/,OUTPUT/7/,LIST/6/
      INTEGER  TRUE,FALSE,PEND,EOF
      DATA     TRUE/1/,FALSE/0/,PEND/2/,EOF/0/
      INTEGER  RECTYP,FORT,COMM,OTHER
      DATA     FORT/0/,COMM/1/,OTHER/3/
      INTEGER  PAGE,LINE,MAXLIN,TLINE
      DATA     PAGE/0/,LINE/0/,MAXLIN/60/
C
C     CHARACTERS
C
      INTEGER  C,D,E,F,I,N,O,P,M,A,Z,T,G,H,S,U
      DATA     C/1HC/,D/1HD/,E/1HE/,F/1HF/,I/1HI/,N/1HN/
      DATA     O/1HO/,P/1HP/,M/1HM/,A/1HA/,Z/1HZ/,T/1HT/
      DATA     G/1HG/,H/1HH/,S/1HS/,U/1HU/
      INTEGER  BLANK,ASTRK,EOR,EQUAL,COMMA,OPENP,CLOSEP
      INTEGER  QUOTE
      DATA     BLANK/1H /,ASTRK/1H*/,EOR/1H /,EQUAL/1H=/
      DATA     COMMA/1H,/,OPENP/1H(/,CLOSEP/1H)/
      DATA     QUOTE/1H'/
C
C     KEYWORD ARRAY AND POINTERS
C
      INTEGER  KEY(50)
      INTEGER  NC,PC,KEYWRD
      INTEGER  PASE,PELSE,PCASE,PWHILE
      INTEGER  PUNTIL,PFOREV,PLSE,PSAC,PEXIT,PNTRY,PRFORM
      INTEGER  PXIT
      DATA     PASE/1/,PELSE/4/,PCASE/8/,PWHILE/12/
      DATA     PUNTIL/17/,PFOREV/22/,PLSE/29/,PSAC/32/
      DATA     PEXIT/35/,PNTRY/39/,PRFORM/43/,PXIT/48/
      DATA     KEY/
     *         1HA,1HS,1HE,
     *         1HE,1HL,1HS,1HE,
     *         1HC,1HA,1HS,1HE,
     *         1HW,1HH,1HI,1HL,1HE,
     *         1HU,1HN,1HT,1HI,1HL,
     *         1HF,1HO,1HR,1HE,1HV,1HE,1HR,
     *         1HL,1HS,1HE,
     *         1HS,1HA,1HC,
     *         1HE,1HX,1HI,1HT,
     *         1HN,1HT,1HR,1HY,
     *         1HR,1HF,1HO,1HR,1HM,
     *         1HX,1HI,1HT/
C
C     NUMERICS
C
      INTEGER DIGIT(10),PDIGIT
      DATA DIGIT/
     *    1H0,1H1,1H2,1H3,1H4,1H5,1H6,1H7,1H8,1H9/
      INTEGER  D0,D1,D2,D3,D4,D5,D6,D7,D8,D9
      EQUIVALENCE   (DIGIT(1),D0),(DIGIT(2),D1)
     *             ,(DIGIT(3),D2),(DIGIT(4),D3)
     *             ,(DIGIT(5),D4),(DIGIT(6),D5)
     *             ,(DIGIT(7),D6),(DIGIT(8),D7)
     *             ,(DIGIT(9),D8),(DIGIT(10),D9)
C
C     MEMORY CONTROL BLOCK OFFSETS, LENGTHS, AND POINTERS
C
C
C         DOCASE AND CASE CONTROL BLOCKS
C
C
C              DOCINT - 6 CHARACTER DOCASE INDEX NAME
C              DOCGO  - STMT# OF COMPUTED GOTO AT ESACOD
C              DOCEXT - STMT# OF EXIT FROM ESACOD
C              DOCLCS - MEMORY POINTER TO LAST CASE BLOCK
C              DOCCAS - ELSE CASE VALUE (ALWAYS ZERO)
C              DOCELS - STMT# OF ELSE CASE ENTRY OR ZERO
C              DOCNCS - MEMORY POINTER TO NEXT CASE OR ZERO
C
C              CASVAL - CASE INDEX VALUE (1-218)
C              CASSTM - STMT# OF CASE ENTRY CONTINUE
C              CASNCS - MEMORY POINTER TO NEXT CASE OR ZERO
C              CASPCS - MEMORY POINTER TO LAST CASE OR ZERO
C
      INTEGER  DOCINT,DOCGO,DOCEXT,DOCLCS,DOCCAS,DOCELS
      INTEGER  DOCNCS,DOCLNG
      DATA     DOCINT/0/,DOCGO /6/,DOCEXT/7/,DOCLCS/8/
      DATA     DOCCAS/9/,DOCELS/10/,DOCNCS/11/,DOCLNG/12/
      INTEGER  CASVAL,CASSTM,CASNCS,CASPCS,CASLNG
      DATA     CASVAL/0/,CASSTM/1/,CASNCS/2/,CASPCS/3/
      DATA     CASLNG/4/
      INTEGER MAXCAS
      DATA MAXCAS/218/
C
C         PENTRY AND PERFORM REFERENCE CONTROL BLOCKS
C
C
C              PNTINT - 6 CHARACTER ROUTINE NAME
C              PNTSTM - STMT# OF ROUTINE ENTRY CONTINUE
C              PNTEXT - STMT# OF ASSIGNED GOTO AT END
C              PNTREF - MEMORY POINTER TO REF.BLK OR ZERO
C              PNTDUP - MEMORY POINTER TO DUP. PNTBLK/ZERO
C              PNTNXT - MEMORY POINTER TO NEXT PNTBLK/ZERO
C
C              PRFNXT - MEMORY POINTER TO NEXT PRFBLK/ZERO
C              PRFSTM - STMT# OF CONTINUE AFTER PERFORM
C
      INTEGER  PNTINT,PNTSTM,PNTEXT,PNTREF,PNTDUP,PNTNXT
      INTEGER  PNTLNG
      DATA     PNTINT/0/,PNTSTM/6/,PNTEXT/7/,PNTREF/8/
      DATA     PNTDUP/9/,PNTNXT/10/,PNTLNG/11/
      INTEGER  PRFNXT,PRFSTM,PRFLNG
      DATA     PRFNXT/0/,PRFSTM/1/,PRFLNG/2/
C
C         CONTROL BLOCK POINTERS AND QUEUE POINTERS
C
      INTEGER  DOCPTR,CASPTR,PNTPTR,PRFPTR
      INTEGER  PCSPTR,NCSPTR,LCSPTR
      INTEGER  DOCFQE,CASFQE,PNTFQE,PRFFQE
      INTEGER  PNTAQE
      DATA     DOCFQE/0/,CASFQE/0/,PNTFQE/0/,PRFFQE/0/
      DATA     PNTAQE/0/
      INTEGER  GOTOI
      INTEGER  PNTPTR,CUREXT
      DATA CUREXT/0/
C
C     GENERATED STATEMENT NUMBER CONTROL VARIABLES
C
      INTEGER MAXSTM,RSTMAX
      DATA MAXSTM/100000/,RSTMAX/100000/
C
C     HASHED DIRECTORY FOR RANDOM ACCESS TO PENTRY CONTROL
C     BLOCKS BY NAME
C
      INTEGER HASH(97),PHASH
      INTEGER SHIFT,PRIME
      DATA    SHIFT/16/,PRIME/97/
      INTEGER LSTPNT,LSTPRF
      DATA HASH/97*0 /
C
C     RECORD AREAS  72 + 19 * 66 = 1326 + 67 PAD = 1393
C
      INTEGER  RECORD(1393),ALTREC(1393),AREA(2786)
C
C         EQUIVALENCE ALLOWS OUTPUT ROUTINE TO REFERENCE
C         EITHER RECORD AREA BY SINGLE ARRAY REFERENCE.
C
      EQUIVALENCE (RECORD(1),AREA(1)),(ALTREC(1),AREA(1394))
      INTEGER  BUFFER(80),OUTREC(80),DSEQ(8)
      EQUIVALENCE (DSEQ(1),OUTREC(73))
      DATA OUTREC/80*1H /
C
C     RECORD POINTERS, VARIABLES, AND CONSTANTS
C
      INTEGER  PREC,PALT,POUT,POUTR,PENDR,PCHART
      DATA     PREC/1/,PALT/1394/
      INTEGER PADEND,ALLBLK
      INTEGER  CHAR,PCHAR,PEOR,NEWREC,RECEOR,APCHAR,PCSAVE
      DATA     NEWREC/0/,RECEOR/1326/
      INTEGER MAXCOL
      DATA MAXCOL/72/
C
C     PROCESSING ROUTINE VARIABLES
C
C         GETN16    NUM=(NEXT NUMBER IN TEXT OR ZERO)
C
      INTEGER NUM
C
C         GETV20  VARBLE=(TRUE/FALSE), INT=(VARIABLE NAME)
C
      INTEGER  VARBLE,INT(6),PINT
C
C         FIND29  NP=(PAREN. COUNT), CTLCHR=(TRUE/FALSE)
C
      INTEGER  NP,CTLCHR,SAVPCP
C
C         PEXT33  IFPEXT=(TRUE/FALSE)
C
      INTEGER IFPEXT
C
C         GETM34  MEMORY BLOCK LENGTH AND POINTER
C
      INTEGER  BLKLNG,BLKPTR
C
C         GETS35, GOTO36, CONT39, ADDN41, ADGO45
C
      INTEGER  STMTNO,SAVSTM,STMWRK,STMD10,STMPTR
C
C         DO18, DOWH37,DOUN38, DOEV42, OD30
C
      INTEGER  DOFORT,DOWH,DOUN,DOFOR
      DATA     DOFORT/1/,DOWH/2/,DOUN/3/,DOFOR/4/
      INTEGER  DOLOOP,DOEXIT,DOTYPE,DOIDX
      DATA     DOLOOP/1/,DOEXIT/2/,DOTYPE/3/
C
C         PERR40
C
      INTEGER PERRS
      DATA PERRS/0/
C
C     ROUTINES
C
      INTEGER  READ02,GETR03,SCAN04,PUTR05,PUTL06,GETC07
      INTEGER  SCNC08,SCND09,SCNE10,SCNF11,SCNI12,SCNO13
      INTEGER  SCNP14,WOUT05,COMP15,GETN16,CASE17,DO18
      INTEGER  DOCS19,GETV20,CPYT22,CPYF23,ELSE24,ESAC25
      INTEGER  SCOD26,FI27  ,IF28  ,FIND29,OD30  ,PENT31
      INTEGER  PM32  ,PEXT33,GETM34,GETS35,GOTO36,DOWH37
      INTEGER  DOUN38,CONT39,PERR40,ADDN41,DOEV42,GETP43
      INTEGER  END44,ADGO45,CSTK46
      INTEGER  ELIF47
C
C     FORMATS
C
   10 FORMAT(80A1)
   20 FORMAT(39H1STRUCTURED FORTRAN TRANSLATION LISTING,
     * 22X,4HPAGE,I4,
     *//1X, 40H1...5...10...15...20...25...30...35...40,
     *      40H...45...50...55...60...65...70...75...80,
     * /)
   30 FORMAT(13H0TOTAL ERRORS,I5)
   40 FORMAT(1X,80A1)
   50 FORMAT(38H *** CASE NOT PRECEEDED BY DOCASE *** ,8A1)
   60 FORMAT(38H *** CASE IS A DUPLICATE ELSE     *** ,8A1)
   70 FORMAT(38H *** CASE VALUE EXCEEDS 218 LIMIT *** ,8A1)
   80 FORMAT(38H *** CASE IS A DUPLICATE VALUE    *** ,8A1)
   90 FORMAT(38H *** INVALID INPUT RECORD FORMAT  *** ,8A1)
  100 FORMAT(38H *** DOCASE MAX NESTING EXCEEDED  *** ,8A1)
  110 FORMAT(38H *** ELSE NOT PRECEEDED BY IF     *** ,8A1)
  120 FORMAT(38H *** ESAC NOT PRECEEDED BY DOCASE *** ,8A1)
  130 FORMAT(38H *** ESACOD NOT PRECEEDED BY DOCASE * ,8A1)
  140 FORMAT(38H *** DOCASE HAS NO CASES          *** ,8A1)
  150 FORMAT(38H *** FI NOT PRECEEDED BY IF       *** ,8A1)
  160 FORMAT(38H *** IF MAX NESTING EXCEEDED      *** ,8A1)
  170 FORMAT(38H *** OD NOT PRECEEDED BY DO       *** ,8A1)
  180 FORMAT(38H *** PENTRY DUPLICATE NAME        *** ,8A1)
  190 FORMAT(38H *** PEXIT NOT PRECEEDED BY PENTRY ** ,8A1)
  200 FORMAT(38H *** MEMORY EXCEEDED - JOB ABORTED ** ,8A1)
  210 FORMAT(38H *** DO MAXIMUM NESTING EXCEEDED   ** ,8A1)
  220 FORMAT(05H *** ,6A1,25H NOT DEFINED BY PENTRY * ,8A1)
  230 FORMAT(05H *** ,6A1,25H NOT REFERENCED        * ,8A1)
  240 FORMAT(38H *** MISSING OD     IN THIS PROGRAM * ,8A1)
  250 FORMAT(38H *** MISSING FI     IN THIS PROGRAM * ,8A1)
  260 FORMAT(38H *** MISSING ESACOD IN THIS PROGRAM * ,8A1)
C
C     MAIN PROCESSING
C
C
C     PRIME BUFFER AND LOGICAL RECORD
C
      PM  READ02
      PM  GETR03
C
C     LOOP THROUGH EACH LOGICAL RECORD SCANING FORTRAN ONLY
C
      DO WHILE,(EOF.NE.TRUE)
          IF   (RECTYP.EQ.FORT)
               PM   SCAN04
          FI
          PM   PUTR05
          PM   GETR03
      OD
C
C     PRINT ERROR AND STOP RUN
C
      TLINE=1
      PM  PUTL06
      STOP
C
C     READ RECORD INTO BUFFER OR SET EOF TO PENDING
C
      PENTRY READ02
      READ(INPUT,10,END=1000)BUFFER
      PEXIT
 1000 EOF=PEND
      PEXIT
C
C     READ LOGICAL RECORD INTO RECORD AND
C     SET RECORD TYPE OR END OF FILE
C
      PENTRY GETR03
      RECTYP=OTHER
      DO  WHILE,(RECTYP.EQ.OTHER)
          IF   (EOF.EQ.PEND)
               EOF=TRUE
               PEXIT
          FI
          DO   POUTR=1,72
               RECORD(POUTR)=BUFFER(POUTR)
          OD
          PEOR=73
          DO   POUTR=73,80
               OUTREC(POUTR)=BUFFER(POUTR)
          OD
          PM   READ02
          IF   (RECORD(1).EQ.C)
               RECTYP=COMM
          ELSEIF   ((RECORD(6).EQ.BLANK).OR.(RECORD(6).EQ.D0))
                    RECTYP=FORT
                    DO   WHILE,((EOF.EQ.FALSE)
     *                          .AND.(PEOR.LT.RECEOR)
     *                          .AND.(BUFFER(1).NE.C)
     *                          .AND.(BUFFER(6).NE.BLANK)
     *                          .AND.(BUFFER(6).NE.D0)
     *                         )
                         DO   POUTR=7,72
                              RECORD(PEOR)=BUFFER(POUTR)
                              PEOR=PEOR+1
                         OD
                         PM   READ02
                    OD
          ELSE
                    TLINE=7
                    PM   PERR40
          FI
      OD
      PEXIT
C
C     SCAN FOR POSSIBLE KEYWORDS AND ROUTE CONTROL
C
      PENTRY SCAN04
      PCHAR=6
      PM     GETC07
      IF  (CHAR.EQ.C)
          PM   SCNC08
      ELSEIF (CHAR.EQ.D)
          PM   SCND09
      ELSEIF (CHAR.EQ.E)
          PM   SCNE10
      ELSEIF (CHAR.EQ.F)
          PM   SCNF11
      ELSEIF (CHAR.EQ.I)
          PM   SCNI12
      ELSEIF (CHAR.EQ.O)
          PM   SCNO13
      ELSEIF (CHAR.EQ.P)
          PM   SCNP14
      FI
      PEXIT
C
C     PUT LOGICAL RECORD FROM RECORD OR ALTREC
C
      PENTRY PUTR05
      IF  (NEWREC.EQ.TRUE)
          NEWREC=FALSE
          POUT=PALT
          PENDR=PALT+APCHAR-1
      ELSE
          POUT=PREC
          PENDR=PEOR
      FI
      PADEND=PENDR+65
      DO  POUTR=PENDR,PADEND
          AREA(POUTR)=BLANK
      OD
      DO  POUTR=1,MAXCOL
          OUTREC(POUTR)=AREA(POUT)
          POUT=POUT+1
      OD
      PM  WOUT05
      IF  (OUTREC(1).EQ.C)
          DO   POUTR=2,6
               OUTREC(POUTR)=BLANK
          OD
      ELSE
          DO   POUTR=1,5
               OUTREC(POUTR)=BLANK
          OD
          OUTREC(6)=ASTRK
      FI
      DO  WHILE,(POUT.LT.PENDR)
          ALLBLK=TRUE
          DO   POUTR=7,MAXCOL
               OUTREC(POUTR)=AREA(POUT)
               IF  (OUTREC(POUTR).NE.BLANK)ALLBLK=FALSE
               POUT=POUT+1
          OD
          IF  ((ALLBLK.NE.TRUE).OR.(POUT.LT.PENDR))
               PM   WOUT05
          FI
      OD
      PEXIT
C
C     WRITE PHYSICAL RECORD FROM OUTREC
C
      PENTRY WOUT05
      WRITE(OUTPUT,10)OUTREC
      TLINE=2
      PM  PUTL06
      PEXIT
C
C     PUT PRINT LINE WITH PAGE CONTROL
C
      PENTRY PUTL06
      LINE=LINE-1
      IF  (LINE.LE.0)
          LINE=MAXLIN
          PAGE=PAGE+1
          WRITE(LIST,20)PAGE
      FI
      DOCASE TLINE
          CASE 1
               WRITE(LIST,30)PERRS
          ESAC
          CASE 2
               WRITE(LIST,40)OUTREC
          ESAC
          CASE 3
               WRITE(LIST,50)DSEQ
          ESAC
          CASE 4
               WRITE(LIST,60)DSEQ
          ESAC
          CASE 5
               WRITE(LIST,70)DSEQ
          ESAC
          CASE 6
               WRITE(LIST,80)DSEQ
          ESAC
          CASE 7
               WRITE(LIST,90)DSEQ
          ESAC
          CASE 8
               WRITE(LIST,100)DSEQ
          ESAC
          CASE 9
               WRITE(LIST,110)DSEQ
          ESAC
          CASE 10
               WRITE(LIST,120)DSEQ
          ESAC
          CASE 11
               WRITE(LIST,130)DSEQ
          ESAC
          CASE 12
               WRITE(LIST,140)DSEQ
          ESAC
          CASE 13
               WRITE(LIST,150)DSEQ
          ESAC
          CASE 14
               WRITE(LIST,160)DSEQ
          ESAC
          CASE 15
               WRITE(LIST,170)DSEQ
          ESAC
          CASE 16
               WRITE(LIST,180)DSEQ
          ESAC
          CASE 17
               WRITE(LIST,190)DSEQ
          ESAC
          CASE 18
               WRITE(LIST,200)DSEQ
          ESAC
          CASE 19
               WRITE(LIST,210)DSEQ
          ESAC
          CASE 20
               WRITE(LIST,220)INT,DSEQ
          ESAC
          CASE 21
               WRITE(LIST,230)INT,DSEQ
          ESAC
          CASE 22
               WRITE(LIST,240)DSEQ
          ESAC
          CASE 23
               WRITE(LIST,250)DSEQ
          ESAC
          CASE 24
               WRITE(LIST,260)DSEQ
          ESAC
      ESACOD
      PEXIT
C
C     GET NEXT NON BLANK CHARACTER IN RECORD
C     OR SET PCHAR=PEOR AND CHAR=EOR
C
      PENTRY GETC07
      DO  WHILE,(PCHAR.LT.PEOR)
          PCHAR=PCHAR+1
          IF   (RECORD(PCHAR).NE.BLANK)
               CHAR=RECORD(PCHAR)
               PEXIT
          FI
      OD
      CHAR=EOR
      PCHAR=PEOR
      PEXIT
C
C     SCAN FOR CASE
C
      PENTRY SCNC08
      NC=3
      PC=PASE
      PM  COMP15
      IF  (KEYWRD.EQ.TRUE)
          PCSAVE=PCHAR
          PM   GETN16
          IF   (NUM.GT.0)
               DO   UNTIL,(NUM.EQ.0)
                    IF   (CHAR.EQ.EOR)
                         PCHAR=PCSAVE
                         CHAR=RECORD(PCHAR)
                         PM   CASE17
                         PEXIT
                    FI
                    IF   (CHAR.NE.COMMA)PEXIT
                    PM   GETN16
               OD
          ELSE
               PCHAR=PCSAVE
               CHAR=RECORD(PCHAR)
               NC=4
               PC=PELSE
               PM   COMP15
               IF   (KEYWRD.EQ.TRUE)
                    PM   GETC07
                    IF   (CHAR.EQ.EOR)
                         PM   CASE17
                    FI
               FI
          FI
      FI
      PEXIT
C
C     SCAN FOR DO, DO WHILE, DO UNTIL, DO FOREVER, DOCASE
C
      PENTRY SCND09
      PM  GETC07
      IF  (CHAR.EQ.O)
          PCSAVE=PCHAR
          NC=4
          PC=PCASE
          PM   COMP15
          IF   (KEYWRD.EQ.TRUE)
               PM   GETV20
               IF   ((VARBLE  .EQ.TRUE).AND.(CHAR.EQ.EOR))
                    PM   DOCS19
               FI
          ELSE
               PCHAR=PCSAVE
               PM   GETV20
               IF   (VARBLE.EQ.TRUE)
                    IF   (CHAR.EQ.EQUAL)
                         DO   UNTIL,(CHAR.EQ.COMMA)
                              PM   GETC07
                              IF   ((CHAR.EQ.OPENP).
     *                              OR.(CHAR.EQ.EOR))PEXIT
                         OD
                         PCHAR=PCSAVE
                         PM   DO18
                    ELSE
                         IF   (CHAR.EQ.COMMA)
                              PCHAR=PCSAVE
                              NC=5
                              PC=PWHILE
                              PM   COMP15
                              IF(KEYWRD.EQ.TRUE)
                                PM GETC07
                                IF (CHAR.EQ.COMMA)
                                   PM   GETC07
                                   IF   (CHAR.EQ.OPENP)
                                        PCSAVE=PCHAR
                                        PM   FIND29
                                        IF(CHAR.EQ.CLOSEP)
                                             PCHAR=PCSAVE
                                             PM   DOWH37
                                        FI
                                   FI
                                FI
                              ELSE
                                PCHAR=PCSAVE
                                NC=5
                                PC=PUNTIL
                                PM COMP15
                                IF(KEYWRD.EQ.TRUE)
                                 PM GETC07
                                 IF(CHAR.EQ.COMMA)
                                   PM   GETC07
                                   IF   (CHAR.EQ.OPENP)
                                        PCSAVE=PCHAR
                                        PM   FIND29
                                        IF(CHAR.EQ.CLOSEP)
                                             PCHAR=PCSAVE
                                             PM   DOUN38
                                        FI
                                   FI
                                 FI
                                FI
                              FI
                         FI
                    FI
               ELSE
                    PCHAR=PCSAVE
                    NC=7
                    PC=PFOREV
                    PM   COMP15
                    IF   (KEYWRD.EQ.TRUE)
                         PM   GETC07
                         IF   (CHAR.EQ.EOR)
                              PM   DOEV42
                         FI
                    FI
               FI
          FI
      FI
      PEXIT
C
C     SCAN FOR ELSE, ELSEIF, ESAC, ESACOD
C
      PENTRY SCNE10
      AELSE1=PCHAR
      PCSAVE=PCHAR
      NC=3
      PC=PLSE
      PM  COMP15
      IF  (KEYWRD.EQ.TRUE)
          AELSE2=PCHAR
          PM   GETC07
          IF   (CHAR.EQ.EOR)
               PM   ELSE24
          ELSEIF (CHAR.EQ.I)
               PM   GETC07
               IF   (CHAR.EQ.F)
                    PM   GETC07
                    IF   (CHAR.EQ.OPENP)
                         PM   FIND29
                         IF   (CHAR.EQ.CLOSEP)
                              PM   GETC07
                              IF   (CHAR.EQ.EOR)
                                   PM   ELIF47
                              FI
                         FI
                    FI
               FI
          FI
      ELSE
          PCHAR=PCSAVE
          NC=3
          PC=PSAC
          PM   COMP15
          IF   (KEYWRD.EQ.TRUE)
               PM   GETC07
               IF   (CHAR.EQ.EOR)
                    PM   ESAC25
               ELSE
                    IF   (CHAR.EQ.O)
                         PM   GETC07
                         IF   (CHAR.EQ.D)
                              PM   GETC07
                              IF   (CHAR.EQ.EOR)
                                   PM   SCOD26
                              FI
                         FI
                    FI
               FI
          ELSE
               PCHAR=PCSAVE
               PM   GETC07
               IF   (CHAR.EQ.N)
                    PM   GETC07
                    IF   (CHAR.EQ.D)
                         PM   GETC07
                         IF   (CHAR.EQ.EOR)
                              PM   END44
                         FI
                    FI
               FI
          FI
      FI
      PEXIT
C
C     SCAN FOR FI
C
      PENTRY SCNF11
      PM  GETC07
      IF  (CHAR.EQ.I)
          PM   GETC07
          IF   (CHAR.EQ.EOR)
               PM   FI27
          FI
      FI
      PEXIT
C
C     SCAN FOR IF(TEST) OT IF(TEST)PEXIT
C
      PENTRY SCNI12
      PM  GETC07
      IF  (CHAR.EQ.F)
      PM   GETC07
          IF   (CHAR.EQ.OPENP)
               PCSAVE=PCHAR
               PM   FIND29
               IF   (CHAR.EQ.CLOSEP)
                    PM   GETC07
                    IF   (CHAR.EQ.EOR)
                         PM   IF28
                    ELSE
                         IF   (CHAR.EQ.P)
                              PCSAVE=PCHAR
                              NC=4
                              PC=PEXIT
                              PM   COMP15
                              IF   (KEYWRD.EQ.TRUE)
                                   PM   GETC07
                                   IF   (CHAR.EQ.EOR)
                                        PCHAR=PCSAVE-1
                                        IFPEXT=TRUE
                                        PM   PEXT33
                                   FI
                              FI
                         FI
                    FI
               FI
          FI
      FI
      PEXIT
C
C     SCAN FOR OD
C
      PENTRY SCNO13
      PM  GETC07
      IF  (CHAR.EQ.D)
          PM   GETC07
          IF   (CHAR.EQ.EOR)
               PM   OD30
          FI
      FI
      PEXIT
C
C     SCAN FOR PENTRY, PERFORM, PEXIT, PM
C
      PENTRY SCNP14
      PM  GETC07
      IF  (CHAR.EQ.M)
          PM   GETV20
          IF   ((VARBLE.EQ.TRUE).AND.(CHAR.EQ.EOR))
               PM   PM32
          FI
      ELSE
          IF   (CHAR.EQ.E)
               PCSAVE=PCHAR
               NC=4
               PC=PNTRY
               PM   COMP15
               IF   (KEYWRD.EQ.TRUE)
                    PM   GETV20
                    IF   (VARBLE.EQ.TRUE)
                         IF   (CHAR.EQ.EOR)
                              PM   PENT31
                         FI
                    FI
               ELSE
                    PCHAR=PCSAVE
                    NC=5
                    PC=PRFORM
                    PM   COMP15
                    IF   (KEYWRD.EQ.TRUE)
                         PM   GETV20
                         IF   (VARBLE.EQ.TRUE)
                              IF   (CHAR.EQ.EOR)
                                   PM   PM32
                              FI
                         FI
                    ELSE
                         PCHAR=PCSAVE
                         NC=3
                         PC=PXIT
                         PM   COMP15
                         IF   (KEYWRD.EQ.TRUE)
                              PM   GETC07
                              IF  (CHAR.EQ.EOR)
                                   IFPEXT=FALSE
                                   PM   PEXT33
                              FI
                         FI
                    FI
               FI
          FI
      FI
      PEXIT
C
C     COMPARE (NC) CHARACTERS IN RECORD WITH KEY(PC)
C
      PENTRY COMP15
      KEYWRD=FALSE
      DO  UNTIL,(NC.EQ.0)
          PM   GETC07
          IF   (CHAR.NE.KEY(PC))PEXIT
          PC=PC+1
          NC=NC-1
      OD
      KEYWRD=TRUE
      PEXIT
C
C     SET NUM TO INTEGER VALUE OF ANY FOLLOWING DIGITS IN
C     RECORD OR ZERO.
C
C         NOTE - THE TRANSLATION OF DIGITS TO BINARY CAN BE
C                DONE WITH AS FEW AS 1 GENERATED MACHINE
C                INSTRUCTIONS IN MOST LANGUAGES THAT SUPPORT
C                CHARACTER STRING OPERATIONS
C
C
      PENTRY GETN16
      NUM=0
      PM  GETC07
      PDIGIT=1
      DO  UNTIL,(PDIGIT.GT.10)
          IF   (CHAR.EQ.DIGIT(PDIGIT))
               NUM=NUM*10+PDIGIT-1
               PDIGIT=1
               PM   GETC07
          ELSE
               PDIGIT=PDIGIT+1
          FI
      OD
      PEXIT
C
C     PROCESS CASE STATEMENT
C
      PENTRY CASE17
      RECORD(1)=C
      IF  (DOCLVL.EQ.0)
          TLINE=3
          PM   PERR40
          PEXIT
      FI
      PM  PUTR05
      IF  (CHAR.EQ.EOR)
          DOCPTR=DOCSTK(DOCLVL)
          INDEX=DOCPTR+DOCELS
          IF   (MEMORY(INDEX).NE.0)
               TLINE=4
               PM   PERR40
               PEXIT
          FI
          PM   GETS35
          MEMORY(INDEX)=STMTNO
          PM   CONT39
          PEXIT
      FI
      PM  GETS35
      PM  CONT39
      DO  UNTIL,(CHAR.EQ.EOR)
          PM   GETN16
          IF   (NUM.GT.MAXCAS)
               TLINE=5
               PM   PERR40
               PEXIT
          FI
          CASPTR=CASFQE
          IF   (CASPTR.GT.0)
               INDEX=CASPTR+CASNCS
               CASFQE=MEMORY(INDEX)
          ELSE
               BLKLNG=CASLNG
               PM   GETM34
               CASPTR=BLKPTR
          FI
      INDEX=CASPTR+CASNCS
      MEMORY(INDEX)=0
          INDEX=CASPTR+CASVAL
          MEMORY(INDEX)=NUM
          INDEX=CASPTR+CASSTM
          MEMORY(INDEX)=STMTNO
          INDEX=DOCPTR+DOCLCS
          PCSPTR=MEMORY(INDEX)
          INDEX=PCSPTR+CASVAL
          DO   WHILE,(NUM.LT.MEMORY(INDEX))
               INDEX=PCSPTR+CASPCS
               PCSPTR=MEMORY(INDEX)
               INDEX=PCSPTR+CASVAL
          OD
          IF   (NUM.EQ.MEMORY(INDEX))
               TLINE=6
               PM   PERR40
               PEXIT
          FI
          INDEX=PCSPTR+CASNCS
          IF   (MEMORY(INDEX).EQ.0)
               MEMORY(INDEX)=CASPTR
               INDEX=DOCPTR+DOCLCS
               MEMORY(INDEX)=CASPTR
          ELSE
               NCSPTR=MEMORY(INDEX)
               INDEX=CASPTR+CASNCS
               MEMORY(INDEX)=NCSPTR
               INDEX=NCSPTR+CASPCS
               MEMORY(INDEX)=CASPTR
               INDEX=PCSPTR+CASNCS
               MEMORY(INDEX)=CASPTR
          FI
          INDEX=CASPTR+CASPCS
          MEMORY(INDEX)=PCSPTR
      OD
      PEXIT
C
C     PROCESS FORTRAN TYPE DO
C
      PENTRY   DO18
      RECORD(1)=C
      IF  (DOLVL.EQ.MAXLVL)
          TLINE=19
          PM   PERR40
          PEXIT
      FI
      PM   PUTR05
      DOLVL=DOLVL+1
      DOSTK(DOLVL,DOTYPE)=DOFORT
      PM  CPYT22
      PM  GETS35
      ALTREC(APCHAR)=BLANK
      APCHAR=APCHAR+1
      DOSTK(DOLVL,DOLOOP)=STMTNO
      PM  ADDN41
      PCHAR=PCHAR+1
      PM  CPYF23
      PEXIT
C
C     PROCESS DOCASE
C
      PENTRY DOCS19
      RECORD(1)=C
      IF  (DOCLVL.EQ.MAXLVL)
          TLINE=8
          PM   PERR40
          PEXIT
      FI
      PM  PUTR05
      DOCLVL=DOCLVL+1
      DOCPTR=DOCFQE
      IF  (DOCPTR.GT.0)
          INDEX=DOCPTR+DOCNCS
          DOCFQE=MEMORY(INDEX)
      ELSE
          BLKLNG=DOCLNG
          PM   GETM34
          DOCPTR=BLKPTR
      FI
      INDEX=DOCPTR+DOCCAS
      MEMORY(INDEX)=0
      INDEX=DOCPTR+DOCELS
      MEMORY(INDEX)=0
      INDEX=DOCPTR+DOCNCS
      MEMORY(INDEX)=0
      DOCSTK(DOCLVL)=DOCPTR
      INDEX=DOCPTR+DOCINT
      DO  PINT=1,6
          MEMORY(INDEX)=INT(PINT)
          INDEX=INDEX+1
      OD
      PM  GETS35
      INDEX=DOCPTR+DOCGO
      MEMORY(INDEX)=STMTNO
      PM  GOTO36
      PM  GETS35
      INDEX=DOCPTR+DOCEXT
      MEMORY(INDEX)=STMTNO
      LCSPTR=DOCPTR+DOCCAS
      INDEX=DOCPTR+DOCLCS
      MEMORY(INDEX)=LCSPTR
      PEXIT
C
C     SET INT(6) TO VARIABLE NAME IN TEXT IF FOUND
C     AND SET VARBLE=TRUE/FALSE
C
C     NOTE THIS ROUTINE USES THE FOLLOWING ASSUMPTIONS TO
C          DETERMINE IF CHAR IS ALPHA-NUMERIC.  ON MOST
C          COMPUTERS THIS TEST CAN BE REDUCED TO ONE
C          ASSEMBLER MACHINE INSTRUCTION.
C             1.  ASSUMES THE ALPHA CHARACTERS WILL COMPARE
C                IN ASCENDING ORDER.
C             2.  ASSUMES THE DIGITS WILL COMPARE IN
C                ASCENDING ORDER.
C             3. ASSUMES NO SPECIAL CHARACTERS ARE WITHIN
C                THE ALPHA OR NUMERIC SEQUENCES.
      PENTRY GETV20
      VARBLE=FALSE
      PM  GETC07
      IF  ((CHAR.GE.A).AND.(CHAR.LE.Z))
          INT(1)=CHAR
          DO   PINT=2,6
               INT(PINT)=BLANK
          OD
          PINT=2
          PM   GETC07
          DO   WHILE,(((CHAR.GE.A).AND.(CHAR.LE.Z)).OR.
     *                ((CHAR.GE.D0).AND.(CHAR.LE.D9)))
               IF   (PINT.LE.6)
                    INT(PINT)=CHAR
                    PINT=PINT+1
               ELSE
                    PEXIT
               FI
               PM   GETC07
          OD
          VARBLE=TRUE
      FI
      PEXIT
C
C     COPY RECORD TO ALTREC UP TO SCAN POINTER
C
      PENTRY CPYT22
      NEWREC=TRUE
      APCHAR=1
      DO  UNTIL,(APCHAR.EQ.7)
          ALTREC(APCHAR)=BLANK
          APCHAR=APCHAR+1
      OD
      DO  WHILE,(APCHAR.LE.PCHAR)
          ALTREC(APCHAR)=RECORD(APCHAR)
          APCHAR=APCHAR+1
      OD
      PEXIT
C
C     COPY RECORD TO ALTREC FROM PCHAR TO EOR
C
      PENTRY CPYF23
      PCHART=PCHAR
      DO  WHILE,(PCHART.LT.PEOR)
          ALTREC(APCHAR)=RECORD(PCHART)
          APCHAR=APCHAR+1
          PCHART=PCHART+1
      OD
      PEXIT
C
C     PROCESS  ELSE
C
      PENTRY ELSE24
      RECORD(1)=C
      IF  (IFLVL.EQ.0)
          TLINE=9
          PM   PERR40
          PEXIT
      FI
      PM  PUTR05
      PM  GETS35
      PM  GOTO36
      PM  PUTR05
      SAVSTM=STMTNO
      STMTNO=IFSTK(IFLVL)
      PM  CONT39
      IFSTK(IFLVL)=SAVSTM
      PEXIT
C
C     PROCESS ESAC
C
      PENTRY ESAC25
      RECORD(1)=C
      IF(DOCLVL.EQ.0)
          TLINE=10
          PM   PERR40
          PEXIT
      FI
      PM  PUTR05
      DOCPTR=DOCSTK(DOCLVL)
      INDEX=DOCPTR+DOCEXT
      STMTNO=MEMORY(INDEX)
      PM  GOTO36
      PEXIT
C
C     PROCESS ESACOD
C
      PENTRY SCOD26
      RECORD(1)=C
      IF  (DOCLVL.EQ.0)
          TLINE=11
          PM   PERR40
          PEXIT
      FI
      PM  PUTR05
      DOCPTR=DOCSTK(DOCLVL)
      DOCLVL=DOCLVL-1
      INDEX=DOCPTR+DOCNCS
      CASPTR=MEMORY(INDEX)
      IF  (CASPTR.EQ.0)
          TLINE=12
          PM   PERR40
          MEMORY(INDEX)=DOCFQE
          DOCFQE=DOCPTR
          PEXIT
      FI
      NEWREC=TRUE
      APCHAR=1
      INDEX=DOCPTR+DOCGO
      STMTNO=MEMORY(INDEX)
      PM  ADDN41
      ALTREC(APCHAR  )=BLANK
      ALTREC(APCHAR+1)=G
      ALTREC(APCHAR+2)=O
      ALTREC(APCHAR+3)=T
      ALTREC(APCHAR+4)=O
      ALTREC(APCHAR+5)=OPENP
      APCHAR=APCHAR+6
      INDEX=DOCPTR+DOCEXT
      SAVSTM=MEMORY(INDEX)
      INDEX=DOCPTR+DOCELS
      IF  (MEMORY(INDEX).NE.0)
          SAVSTM=MEMORY(INDEX)
      FI
      GOTOI=1
      DO  UNTIL,(CASPTR.EQ.0)
          INDEX=CASPTR+CASVAL
          DO   WHILE,(GOTOI.LT.MEMORY(INDEX))
               STMTNO=SAVSTM
               PM   ADDN41
               ALTREC(APCHAR)=COMMA
               APCHAR=APCHAR+1
               GOTOI=GOTOI+1
          OD
          INDEX=CASPTR+CASSTM
          STMTNO=MEMORY(INDEX)
          PM   ADDN41
          ALTREC(APCHAR)=COMMA
          APCHAR=APCHAR+1
          GOTOI=GOTOI+1
          INDEX=CASPTR+CASNCS
          CASPTR=MEMORY(INDEX)
      OD
      ALTREC(APCHAR-1)=CLOSEP
      ALTREC(APCHAR)=COMMA
      APCHAR=APCHAR+1
      INDEX=DOCPTR+DOCINT
      DO  PINT=1,6
          ALTREC(APCHAR)=MEMORY(INDEX)
          APCHAR=APCHAR+1
          INDEX=INDEX+1
      OD
      PM  PUTR05
      INDEX=DOCPTR+DOCELS
      IF  (MEMORY(INDEX).NE.0)
          STMTNO=MEMORY(INDEX)
          PM   GOTO36
          PM   PUTR05
      FI
      INDEX=DOCPTR+DOCEXT
      STMTNO=MEMORY(INDEX)
      PM  CONT39
      INDEX=DOCPTR+DOCLCS
      LCSPTR=MEMORY(INDEX)
      INDEX=LCSPTR+CASNCS
      MEMORY(INDEX)=CASFQE
      INDEX=DOCPTR+DOCNCS
      CASFQE=MEMORY(INDEX)
      MEMORY(INDEX)=DOCFQE
      DOCFQE=DOCPTR
      PEXIT
C
C     PROCESS FI
C
      PENTRY FI27
      RECORD(1)=C
      IF  (IFLVL.EQ.0)
          TLINE=13
          PM   PERR40
          PEXIT
      FI
      DO  UNTIL,(ELFSTK(IFLVL+1).EQ.FALSE)
          PM   PUTR05
          STMTNO=IFSTK(IFLVL)
          PM   CONT39
          IFLVL=IFLVL-1
      OD
      PEXIT
C
C     PROCESS IF
C
      PENTRY IF28
      RECORD(1)=C
      IF  (IFLVL.EQ.MAXLVL)
          TLINE=14
          PM   PERR40
          PEXIT
      FI
      IFLVL=IFLVL+1
      IF  (ELSEIF.EQ.TRUE)
          ELFSTK(IFLVL)=TRUE
      ELSE
          ELFSTK(IFLVL)=FALSE
          PM   PUTR05
      FI
      PCHAR=PCHAR-1
      PM  CPYT22
      PM  GETS35
      PM  ADGO45
      PM  PUTR05
      SAVSTM=STMTNO
      PM  GETS35
      IFSTK(IFLVL)=STMTNO
      PM  GOTO36
      PM  PUTR05
      STMTNO=SAVSTM
      PM  CONT39
      PEXIT
C
C     SCAN FOR END OF LOGICAL TEST EXPRESSION
C         ALLOW FOR LITERALS AS ARGUMENTS TO FUNCTIONS
C         IN THE FORM WHXXX OR 'XXX'
C
C     IF FOUND, PCHAR WILL POINT TO CLOSEP IN RECORD
C
      PENTRY FIND29
      NP=1
      PM  GETN16
      DO  FOREVER
          IF   (NUM.GT.0)
               IF   (CHAR.EQ.H)
                    PCHAR=PCHAR+NUM
                    PM   GETC07
               FI
          ELSE
               DO   WHILE,(CHAR.EQ.QUOTE)
                    PM   GETC07
                    DO   WHILE,(CHAR.NE.QUOTE)
                         IF   (PCHAR.EQ.PEOR)PEXIT
                         PM   GETC07
                    OD
                    PM   GETC07
               OD
          FI
          CTLCHR=FALSE
          DO   UNTIL,(CTLCHR.EQ.TRUE)
               IF   (PCHAR.EQ.PEOR)PEXIT
               IF   (CHAR.EQ.CLOSEP)
                    NP=NP-1
                    IF   (NP.EQ.0)
                         SAVPCP=PCHAR
                         PM   GETC07
                         IF   (PCHAR.EQ.PEOR)
                              PEOR=SAVPCP+1
                         FI
                         PCHAR=SAVPCP
                         CHAR=CLOSEP
                         PEXIT
                    FI
               PM   GETC07
               ELSE
                    IF   (CHAR.EQ.OPENP)
                         NP=NP+1
                         CTLCHR=TRUE
                    ELSE
                         IF   (CHAR.EQ.COMMA)
                              CTLCHR=TRUE
                         ELSE
                              PM   GETC07
                         FI
                    FI
               FI
          OD
          PM   GETN16
      OD
C
C     PROCESS OD FOR ALL DO TYPES
C
      PENTRY OD30
      RECORD(1)=C
      IF  (DOLVL.EQ.0)
          TLINE=15
          PM   PERR40
          PEXIT
      FI
      PM  PUTR05
      DOIDX=DOSTK(DOLVL,DOTYPE)
      DOCASE DOIDX
          CASE 1
               STMTNO=DOSTK(DOLVL,DOLOOP)
               PM   CONT39
          ESAC
          CASE 2,3
               STMTNO=DOSTK(DOLVL,DOLOOP)
               PM   GOTO36
               PM   PUTR05
               STMTNO=DOSTK(DOLVL,DOEXIT)
               PM   CONT39
          ESAC
          CASE 4
               STMTNO=DOSTK(DOLVL,DOLOOP)
               PM   GOTO36
          ESAC
      ESACOD
      DOLVL=DOLVL-1
      PEXIT
C
C     PROCESS PENTRY
C
      PENTRY PENT31
      PM  CSTK46
      RECORD(1)=C
      PM  GETP43
      INDEX=PNTPTR+PNTEXT
      IF  (MEMORY(INDEX).NE.0)
          TLINE=16
          PM   PERR40
          CUREXT=0
          PEXIT
      FI
      PM  PUTR05
      INDEX=PNTPTR+PNTSTM
      STMTNO=MEMORY(INDEX)
      PM  CONT39
      PM  GETS35
      INDEX=PNTPTR+PNTEXT
      MEMORY(INDEX)=STMTNO
      CUREXT=STMTNO
      PEXIT
C
C     PROCESS PERFORM OR PM
C
      PENTRY PM32
      RECORD(1)=C
      PM  PUTR05
      PM  GETP43
      IF  (PRFFQE.NE.0)
          PRFPTR=PRFFQE
          INDEX=PRFPTR+PRFNXT
          PRFFQE=MEMORY(INDEX)
      ELSE
          BLKLNG=PRFLNG
          PM   GETM34
          PRFPTR=BLKPTR
      FI
      INDEX=PNTPTR+PNTREF
      INDEX1=PRFPTR+PRFNXT
      MEMORY(INDEX1)=MEMORY(INDEX)
      MEMORY(INDEX)=PRFPTR
      PM  GETS35
      INDEX=PRFPTR+PRFSTM
      MEMORY(INDEX)=STMTNO
      NEWREC=TRUE
      DO  APCHAR=1,6
          ALTREC(APCHAR)=BLANK
      OD
      ALTREC( 7)=A
      ALTREC( 8)=S
      ALTREC( 9)=S
      ALTREC(10)=I
      ALTREC(11)=G
      ALTREC(12)=N
      ALTREC(13)=BLANK
      APCHAR=14
      PM  ADDN41
      ALTREC(APCHAR  )=BLANK
      ALTREC(APCHAR+1)=T
      ALTREC(APCHAR+2)=O
      ALTREC(APCHAR+3)=BLANK
      APCHAR=APCHAR+4
      DO  PINT=1,6
          ALTREC(APCHAR)=INT(PINT)
          APCHAR=APCHAR+1
      OD
      PM  PUTR05
      INDEX=PNTPTR+PNTSTM
      SAVSTM=STMTNO
      STMTNO=MEMORY(INDEX)
      PM  GOTO36
      PM  PUTR05
      STMTNO=SAVSTM
      PM  CONT39
      PEXIT
C
C     PROCESS PEXIT OR IF(TEST)PEXIT
C
      PENTRY PEXT33
      RECORD(1)=C
      IF  (CUREXT.EQ.0)
          TLINE=17
          PM   PERR40
               PEXIT
      FI
      PM  PUTR05
      IF  (IFPEXT.EQ.TRUE)
          PM   CPYT22
          STMTNO=CUREXT
          PM   ADGO45
      ELSE
          STMTNO=CUREXT
          PM   GOTO36
      FI
      PEXIT
C
C     GET MEMORY FOR A CONTROL BLOCK
C
C     BLKLNG IS LENGTH AND BLKPTR IS SET TO FREE BLOCK
C
      PENTRY GETM34
      BLKPTR=MEMPTR
      MEMPTR=MEMPTR+BLKLNG
      IF  (MEMPTR.GT.MAXMEM)
          TLINE=18
          PM   PERR40
          STOP
      FI
      PEXIT
C
C     GET NEXT STATEMENT NUMBER AVAILABLE
C
      PENTRY GETS35
      MAXSTM=MAXSTM-1
      STMTNO=MAXSTM
      PEXIT
C
C     SETUP GOTO STATEMENT IN ALTREC
C
      PENTRY GOTO36
      NEWREC=TRUE
      DO  APCHAR=1,6
          ALTREC(APCHAR)=BLANK
      OD
      ALTREC( 7)=G
      ALTREC( 8)=O
      ALTREC( 9)=T
      ALTREC(10)=O
      ALTREC(11)=BLANK
      APCHAR=12
      PM  ADDN41
      PEXIT
C
C     PROCESS DO WHILE,(TEST)
C
      PENTRY DOWH37
      RECORD(1)=C
      IF  (DOLVL.EQ.MAXLVL)
          TLINE=19
          PM   PERR40
          PEXIT
      FI
      PM  PUTR05
      DOLVL=DOLVL+1
      DOSTK(DOLVL,DOTYPE)=DOWH
      PM  GETS35
      DOSTK(DOLVL,DOLOOP)=STMTNO
      PM  CONT39
      PM  PUTR05
      NEWREC=TRUE
      DO  APCHAR=1,6
          ALTREC(APCHAR)=BLANK
      OD
      ALTREC(7)=I
      ALTREC(8)=F
      APCHAR=9
      PM  CPYF23
      PM  GETS35
      SAVSTM=STMTNO
      PM  ADGO45
      PM  PUTR05
      PM  GETS35
      DOSTK(DOLVL,DOEXIT)=STMTNO
      PM  GOTO36
      PM  PUTR05
      STMTNO=SAVSTM
      PM  CONT39
      PEXIT
C
C     PROCESS DO UNTIL,(TEST)
C
      PENTRY DOUN38
      RECORD(1)=C
      IF  (DOLVL.EQ.MAXLVL)
          TLINE=19
          PM   PERR40
          PEXIT
      FI
      PM  PUTR05
      DOLVL=DOLVL+1
      DOSTK(DOLVL,DOTYPE)=DOUN
      PM  GETS35
      SAVSTM=STMTNO
      PM  GOTO36
      PM  PUTR05
      PM  GETS35
      DOSTK(DOLVL,DOLOOP)=STMTNO
      PM  CONT39
      PM  PUTR05
      NEWREC=TRUE
      DO  APCHAR=1,6
          ALTREC(APCHAR)=BLANK
      OD
      ALTREC(7)=I
      ALTREC(8)=F
      APCHAR=9
      PM  CPYF23
      PM  GETS35
      DOSTK(DOLVL,DOEXIT)=STMTNO
      PM  ADGO45
      PM  PUTR05
      STMTNO=SAVSTM
      PM  CONT39
      PEXIT
C
C     SETUP CONTINUE IN ALTREC
C
      PENTRY CONT39
      NEWREC=TRUE
      APCHAR=1
      PM  ADDN41
      ALTREC( 6)=BLANK
      ALTREC( 7)=C
      ALTREC( 8)=O
      ALTREC( 9)=N
      ALTREC(10)=T
      ALTREC(11)=I
      ALTREC(12)=N
      ALTREC(13)=U
      ALTREC(14)=E
      APCHAR=15
      PEXIT
C
C     COUNT ERRORS AND PRINT MESSAGE INDICATED BY TLINE
C
      PENTRY PERR40
      PERRS=PERRS+1
      PM  PUTL06
      PEXIT
C
C     PLACE DIGITS OF STMTNO IN ALTREC(APCHAR) THRU
C                               ALTREC(APCHAR+4)
C
C
C         NOTE - THIS ROUTINE REDUCES TO AS FEW AS FOUR
C                SEQUENTIAL MACHINE INSTRUCTIONS IN
C                MOST LANGUAGES WITH CHARACTER STRING
C                OPERATIONS.
      PENTRY ADDN41
      STMWRK=STMTNO
      STMPTR=APCHAR+4
      DO  UNTIL,(STMPTR.LT.APCHAR)
          STMD10=STMWRK/10
          PDIGIT=STMWRK-10*STMD10+1
          ALTREC(STMPTR)=DIGIT(PDIGIT)
          STMWRK=STMD10
          STMPTR=STMPTR-1
      OD
      APCHAR=APCHAR+5
      PEXIT
C
C     PROCESS  DO FOREVER
C
      PENTRY DOEV42
      RECORD(1)=C
      IF  (DOLVL.EQ.MAXLVL)
          TLINE=19
          PM   PERR40
          PEXIT
      FI
      PM  PUTR05
      DOLVL=DOLVL+1
      DOSTK(DOLVL,DOTYPE)=DOFOR
      PM  GETS35
      DOSTK(DOLVL,DOLOOP)=STMTNO
      PM  CONT39
      PEXIT
C
C     GET PENTRY CONTROL BLOCK
C
C         NOTE THE FOLLOWING HASHING ROUTINE COULD BE
C         IMPROVED BY CONSIDERING MACHINE DEPENDENT
C         CHARACTERISTICS OF CHARACTER SET REPRESENTATION.
C         WORST CASE IS ALL PENTRY CONTROL BLOCKS CHAINED
C         TO A SINGLE HASH TABLE ENTRY IN ANY EVENT.
C
      PENTRY GETP43
      PHASH=((((INT(6)/SHIFT+INT(5))/
     *                 SHIFT+INT(4))/
     *                 SHIFT+INT(3))/
     *                 SHIFT+INT(2))/
     *                 SHIFT+INT(1)
      IF(PHASH.LT.0)PHASH=-PHASH
      PHASH=PHASH-(PHASH/PRIME)*PRIME+1
      PNTPTR=HASH(PHASH)
      LSTPNT=0
      IF  (PNTPTR.NE.0)
          PINT=6
          DO   UNTIL,(PNTPTR.EQ.0)
               INDEX=PNTPTR+PINT-1
               IF   (INT(PINT).NE.MEMORY(INDEX))
                    INDEX=PNTPTR+PNTDUP
                    LSTPNT=PNTPTR
                    PNTPTR=MEMORY(INDEX)
                    PINT=6
               ELSE
                    PINT=PINT-1
                    IF  (PINT.EQ.0)PEXIT
               FI
          OD
      FI
      PNTPTR=PNTFQE
      IF  (PNTPTR.NE.0)
          INDEX=PNTPTR+PNTNXT
          PNTFQE=MEMORY(INDEX)
      ELSE
          BLKLNG=PNTLNG
          PM   GETM34
          PNTPTR=BLKPTR
      FI
      INDEX=PNTPTR+PNTEXT
      MEMORY(INDEX)=0
      INDEX=PNTPTR+PNTREF
      MEMORY(INDEX)=0
      INDEX=PNTPTR+PNTDUP
      MEMORY(INDEX)=0
      IF  (LSTPNT.EQ.0)
          HASH(PHASH)=PNTPTR
      ELSE
          INDEX=LSTPNT+PNTDUP
          MEMORY(INDEX)=PNTPTR
      FI
      DO  PINT=1,6
          INDEX=PNTPTR+PINT-1
          MEMORY(INDEX)=INT(PINT)
      OD
      INDEX=PNTPTR+PNTNXT
      MEMORY(INDEX)=PNTAQE
      PNTAQE=PNTPTR
      PM  GETS35
      INDEX=PNTPTR+PNTSTM
      MEMORY(INDEX)=STMTNO
      PEXIT
C
C     PROCESS END (GENERATE ASSIGNED GOTO'S FOR PERFORMS,
C                  CHECK STACKS FOR ERRORS, RESET FOR
C                  PROCESSING NEW PROGRAM)
C
      PENTRY END44
      PNTPTR=PNTAQE
      DO  WHILE,(PNTPTR.NE.0)
          INDEX=PNTPTR+PNTREF
          PRFPTR=MEMORY(INDEX)
          IF   (PRFPTR.NE.0)
               INDEX=PNTPTR+PNTEXT
               STMTNO=MEMORY(INDEX)
               IF   (STMTNO.NE.0)
                    NEWREC=TRUE
                    APCHAR=1
                    PM   ADDN41
                    ALTREC( 6)=BLANK
                    ALTREC( 7)=G
                    ALTREC( 8)=O
                    ALTREC( 9)=T
                    ALTREC(10)=O
                    ALTREC(11)=BLANK
                    INDEX=PNTPTR+PNTINT
                    DO   APCHAR=12,17
                         ALTREC(APCHAR)=MEMORY(INDEX)
                         INDEX=INDEX+1
                    OD
                    ALTREC(18)=COMMA
                    ALTREC(19)=OPENP
                    APCHAR=20
                    DO   UNTIL,(PRFPTR.EQ.0)
                         INDEX=PRFPTR+PRFSTM
                         STMTNO=MEMORY(INDEX)
                         PM   ADDN41
                         ALTREC(APCHAR)=COMMA
                         APCHAR=APCHAR+1
                         INDEX=PRFPTR+PRFNXT
                         LSTPRF=PRFPTR
                         PRFPTR=MEMORY(INDEX)
                         MEMORY(INDEX)=PRFFQE
                         PRFFQE=LSTPRF
                    OD
                    ALTREC(APCHAR-1)=CLOSEP
                    PM   PUTR05
               ELSE
                    TLINE=20
                    INDEX=PNTPTR+PNTINT
                    DO   PINT=1,6
                         INT(PINT)=MEMORY(INDEX)
                         INDEX=INDEX+1
                    OD
                    PM   PERR40
               FI
          ELSE
               TLINE=21
               INDEX=PNTPTR+PNTINT
               DO   PINT=1,6
                    INT(PINT)=MEMORY(INDEX)
                    INDEX=INDEX+1
               OD
               PM   PERR40
          FI
          INDEX=PNTPTR+PNTNXT
          LSTPNT=PNTPTR
          PNTPTR=MEMORY(INDEX)
          MEMORY(INDEX)=PNTFQE
          PNTFQE=LSTPNT
      OD
      PM  CSTK46
      DO  PHASH=1,PRIME
          HASH(PHASH)=0
      OD
      PNTAQE=0
      MAXSTM=RSTMAX
      PEXIT
C
C     ADD GOTO STMTNO IN ALTREC
C
      PENTRY ADGO45
      ALTREC(APCHAR  )=BLANK
      ALTREC(APCHAR+1)=G
      ALTREC(APCHAR+2)=O
      ALTREC(APCHAR+3)=T
      ALTREC(APCHAR+4)=O
      ALTREC(APCHAR+5)=BLANK
      APCHAR=APCHAR+6
      PM  ADDN41
      PEXIT
C
C     CHECK STACKS FOR ERRORS IN PREVIOUS PROGRAM SECTION
C
      PENTRY CSTK46
      IF  (DOLVL.NE.0)
          TLINE=22
          PM   PERR40
          DOLVL=0
      FI
      IF  (IFLVL.NE.0)
          TLINE=23
          PM   PERR40
          IFLVL=0
      FI
      IF  (DOCLVL.NE.0)
          TLINE=24
          PM   PERR40
          DOCLVL=0
      FI
      PEXIT
C
C     PROCESS ELSEIF
C
      PENTRY ELIF47
      PM  ELSE24
      PM  PUTR05
      DO  WHILE,(AELSE1.LE.AELSE2)
          RECORD(AELSE1)=BLANK
          AELSE1=AELSE1+1
      OD
      ELSEIF=TRUE
      PM  IF28
      ELSEIF=FALSE
      PEXIT
      END
