DS@FLSTA TITLE 'DS@FLSTA - BUILD TABLE FOR FULL-SCREEN LISTA DISPLAY'
***********************************************************************
*  PROGRAM-ID: DS@FLSTA                                               *
*  FUNCTION:                                                          *
*      THIS PROGRAM IS CALLED BY THE FSLISTA FUNCTION TO BUILD THE    *
*      ISPF TABLE FOR DISPLAY BY THE CLIST.  THE OUTPUT IS SIMILAR    *
*      TO WHAT WOULD BE OBTAINED USING THE LISTALC TSO COMMAND,       *
*      EXCEPT THAT THE OUTPUT IS IN A TABLE FORM FOR THE USER TO      *
*      SCROLL THROUGH, AND THE USER MAY FREE DDNAMES, AND OBTAIN A    *
*      MEMBER LIST FOR ALLOCATED PDS DATA SETS.  WE DISPLAY THE TABLE *
*      BUILT AND PROCESSES THE COMMANDS ENTERED.                      *
*                                                                     *
*  REGISTER USAGE:                                                    *
*      R0 - R10 GENERAL WORK REGISTERS                                *
*      R12 - BASE REGISTER                                            *
*      R13 - BASE FOR DSA                                             *
*      R14-R15 LINKAGE                                                *
*                                                                     *
*  RETURN CODES:                                                      *
*       0 - ALWAYS RETURNED--AN ISPF MESSAGE IS SET IF ANYTHING       *
*           UNEXPECTED OCCURS.                                        *
*                                                                     *
*  NOTE: THIS PROGRAM IS REENTRANT, AND REUSEABLE, AND REQUIRES       *
*        VERSION 2 OR LATER OF ISPF.                                  *
*                                                                     *
* AUTHOR:   PHIL HEROLD, SYSTEMS DEVELOPER                            *
*           SAS INSTITUTE                                             *
*           CARY, NC                                                  *
*                                                                     *
* NOTE:  SAS INSTITUTE IS NOT RESPONSIBLE FOR THE SUPPORT OF THIS     *
*        PROGRAM--PLEASE DO NOT CALL SAS INSTITUTE TECHNICAL SUPPORT. *
*        HOWEVER, THE AUTHOR WILL BE GLAD TO PROVIDE ANY ASSISTANCE   *
*        NEEDED.                                                      *
*                                                                     *
*                                                                     *
* ACKNOWLEDGEMENT:  THE AUTHOR WOULD LIKE TO ESPECIALLY THANK DAVE    *
*                   LASALLE AT FIRST COMPUTER SERVICES, CHARLOTTE,    *
*                   NC, FOR HIS SUPPORT AND ENCOURAGEMENT.            *
*                                                                     *
***********************************************************************
         COPY  DS@MACS
         TITLE 'OTHER EQUATES'
***********************************************************************
*                  O T H E R    E Q U A T E S                         *
***********************************************************************
         SPACE
FLAGON   EQU   255
FLAGOFF  EQU   0
         TITLE 'DSECTS'
**********************************************************************
*                      D S E C T S                                   *
**********************************************************************
         SPACE
         PRINT NOGEN
         IEFZB4D0
         IEFZB4D2
         TITLE 'DS@FLSTA - DSA'
***********************************************************************
*                          D S A                                      *
***********************************************************************
         SPACE
FLSTADSA DSECT
SAVEAREA DC    18F'0'
RCSAVE   DC    F'0'                    RETURN CODE SAVE AREA
LNGDDNM  DC    F'0'                    LENGTH OF DDNAME PASSED
OLDLNG   DC    F'0'                    OLD DDNAME LENGTH
         SPACE
GETSVA@  DC    A(0)                   ADDRESS OF GET SAVEAREA ROUTINE
FREESVA@ DC    A(0)                   ADDRESS OF FREE SAVEAREA ROUTINE
         SPACE
FLAGBYTE DC    AL1(0)                 FLAG BYTE (IT IS INITIALIZED)
FIRSTDD  EQU   B'10000000'              VERY FIRST DDNAME FOR TABLE
ADDTOTOP EQU   B'01000000'              ADD TO TOP OF ISPF TABLE
TBADD    EQU   B'00100000'              TABLE HAS AN ENTRY
EXCLUDE  EQU   B'00010000'              EXCLUDE THIS DDNAME
MANY     EQU   B'00001000'              "MANY" SELECTS IN TBDISPL
CMDZ     EQU   B'00000100'              PROCESSING ZCMD
         SPACE
         DS    0F
CALLPL   CALL  ,(,,,,,,,,,),MF=L      CALL PARAMETER LIST
CALLPLL  EQU   *-CALLPL               LENGTH OF ABOVE
         SPACE
DDNAME   DC    CL8' '                 DDNAME USED
SVDDNAME DC    CL8' '                 PREVIOUS DDNAME SAVED HERE
         DS    0H
TBLNAME  DC    CL8' '                 ISPF TABLE NAME
         ORG   TBLNAME+4
TBLNMTM  DC    CL4' '
AUTOSEL  DC    CL3'NO'                INITIALIZED TO NO
         SPACE
DS@DDNM  DC    CL8' '                 DDNAME PASSED
SORTDD   DC    C' '                   SORT BY DDNAME (Y OR N)
SYSNMS   DC    C' '                   EXCLUDE SYSTEM NAMES (Y OR N)
DYNONLY  DC    C' '                   ONLY DYN. ALLOC. FILES (Y OR N)
TRACE    DC    CL5' '                 TRACE FLAG FOR DEBUG
         SPACE
SEL      DC    C' '                   TEMP AREA FOR SELECT OPTION
DSNAME   DC    CL52' '                TEMP AREA FOR DATA SET NAME
TDDNAME  DC    CL8' '                 TEMP AREA FOR DDNAME
HIDDDN   DC    CL8' '                 TEMP AREA DDNAME (NOT DISPLAYED)
DSORG    DC    CL4' '                 TEMP AREA FOR DSORG
DISP     DC    CL7' '                 TEMP AREA FOR NORMAL DISPOSITION
STAT     DC    CL3' '                 TEMP AREA FOR STATUS
ATT      DC    CL2' '                 TEMP AREA FOR ATTRIBUTE BYTE
         SPACE
TBSEL    DC    C' '                   SELECT OPTION
TBDSNAME DC    CL52' '                DATA SET NAME
TBDDNAME DC    CL8' '                 DDNAME (DISPLAYED)
TBHIDDDN DC    CL8' '                 DDNAME (NOT DISPLAYED)
TBDSORG  DC    CL4' '                 DATA SET ORGANIZATION
TBDISP   DC    CL7' '                 NORMAL DISPOSITION
TBSTAT   DC    CL3' '                 STATUS
TBLNG    EQU   *-TBSEL                LENGTH OF TABLE
BLNKLNG  EQU   *-DDNAME               LENGTH OF AREA TO BLANK
         SPACE
CRP      DC    F'0'                   CURRENT ROW POINTER
ZTDTOP   DC    F'0'                   TOP ROW ON DISPLAY
ZCMD     DC    CL52' '                ZCMD FROM DISPLAY
ZCMDMRK  DC    X'FF'              *** MUST FOLLOW ZCMD (INITIALIZED)
DSN1     DC    CL44' '                DSN1 (MEMBER LIST)
DSN2     DC    CL44' '                DSN2 (MEMBER LIST)
DSN3     DC    CL44' '                DSN3 (MEMBER LIST)
DSN4     DC    CL44' '                DSN4 (MEMBER LIST)
MEMBER   DC    CL8' '                 MEMBER (MEMBER LIST)
USERID   DC    CL8' '                 USERID (MEMBER LIST)
VOL      DC    CL6' '                 VOLUME (MEMBER LIST)
SCOP     DC    C' '                   SCAN OPTION (MEMBER LIST)
USEROP   DC    C' '                   USEROP (MEMBER LIST)
SCANSTR  DC    CL64' '                SCANSTR (MEMBER LIST)
MBLNKL   EQU   *-DSN2                 LENGTH TO BLANK OUT
MODE     DC    C' '                   MODE (MEMBER LIST)
         SPACE
         DS    0F
DS@DDNML DC    AL4(L'DS@DDNM)         INPUT VARIABLES
SORTDDL  DC    AL4(L'SORTDD)
SYSNMSL  DC    AL4(L'SYSNMS)
DYNONLYL DC    AL4(L'DYNONLY)
TRACEL   DC    AL4(L'TRACE)
         SPACE
TBSELL   DC    AL4(L'TBSEL)           TABLE VARIABLES
TBDSNL   DC    AL4(L'TBDSNAME)
TBDDNL   DC    AL4(L'TBDDNAME)
TBHDDNL  DC    AL4(L'TBHIDDDN)
TBDSORGL DC    AL4(L'TBDSORG)
TBDISPL  DC    AL4(L'TBDISP)
TBSTATL  DC    AL4(L'TBSTAT)
         SPACE
CRPL     DC    AL4(L'CRP)             TABLE DISPLAY VARIABLES
ZTDTOPL  DC    AL4(L'ZTDTOP)
ZCMDL    DC    AL4(L'ZCMD)
DSN1L    DC    AL4(L'DSN1)
DSN2L    DC    AL4(L'DSN2)
DSN3L    DC    AL4(L'DSN3)
DSN4L    DC    AL4(L'DSN4)
MEMBERL  DC    AL4(L'MEMBER)
USERIDL  DC    AL4(L'USERID)
VOLL     DC    AL4(L'VOL)
SCOPL    DC    AL4(L'SCOP)
USEROPL  DC    AL4(L'USEROP)
SCANSTRL DC    AL4(L'SCANSTR)
MODEL    DC    AL4(L'MODE)
         SPACE
CSR      DC    F'0'                   PLACE CURSOR ON THIS ROW
SKIPNUM  DC    F'0'                   NUMBER FOR TBSKIP
         SPACE
VARTBLA  DC    A(0),A(0),A(0)
         SPACE
RBPTR    DC    A(0)                   POINT TO SVC 99 REQUEST BLOCK
         SPACE
REQBLK   DS    0D
RBLN     DC    AL1(20)
RBVERB   DC    AL1(7)
RBFLAG1  DC    H'0'
RBERROR  DC    H'0'
RBINFO   DC    H'0'
RBTXTPP  DC    A(0)
RBRSVD   DC    F'0'
RBFLAG2  DC    F'0'
         SPACE
RELNO    DC    AL2(DINRELNO,1,2,1)         RELATIVE REQUEST NUMBER
RTDDN    DC    AL2(DINRTDDN,1,8),CL8' '    RETURN DDNAME
RTDSN    DC    AL2(DINRTDSN,1,44),CL44' '  RETURN DSNAME
RTMEM    DC    AL2(DINRTMEM,1,8),CL8' '    RETURN MEMBER NAME
RTNDP    DC    AL2(DINRTNDP,1,1),X'00'     RETURN NORMAL DISPOSITION
RTSTA    DC    AL2(DINRTSTA,1,1),X'00'     RETURN STATUS
RTORG    DC    AL2(DINRTORG,1,2),XL2'00'   RETURN DSORG
RTATT    DC    AL2(DINRTATT,1,1),X'00'     RETURN ATTRIBUTE
RTTYP    DC    AL2(DINRTTYP,1,1),X'00'     RETURN TYPE
UNDDNM   DC    AL2(DUNDDNAM,1,8),CL8' '    UNALLOCATE DDNAME
UNALLOC  DC    AL2(DUNUNALC,0)             UNALLOCATE IT, JACK
         SPACE
BLANKS   DC    CL256' '           AREA FOR BLANKS USED
         DS    0F
         SPACE
TEXTPTRS DS    9F'0'                  TEXT UNIT POINTERS
         SPACE
TOKPTR   DC    F'0'
TOKLNG   DC    H'0'
TOKEN    DC    CL52' '
         SPACE
         DS    0F
DDTBL    DC    100XL12'00'            LINKLIST TABLE OF DDNAMES
HEADPTR  DC    AL4(0)                 POINTS TO HEAD OF TABLE
NXTAVAIL DC    AL4(0)                 NXT AVAILABLE SLOT TO ADD
PREVDD   DC    AL4(0)                 PREVIOUS DDNAME IN TABLE
PRENTRY  DC    AL4(0)                 PREVIOUS ENTRY IN TABLE
         SPACE
DS@14TO1 DC    4F'0'                  TEMP SAVE AREA FOR REGISTERS
DS@14T1L EQU   *-DS@14TO1             LENGTH OF ABOVE
         SPACE
NUMSVA   DC    F'0'                   NUMBER OF SAVE AREAS
SAVADDR  DC    A(0)                   LAST SAVE AREA
SAVMAX   EQU   16                     LEVEL OF SUBROUTINE NESTING
SAVALNG  EQU   64                     LENGTH OF A SAVE AREA
         SPACE
SAVSTCK  DS    0H                     SAVE AREA STACK
         ORG   *+(SAVMAX*SAVALNG)
         SPACE
**********************************************************************
*          M E S S A G E       P A R A M E T E R    B L O C K        *
**********************************************************************
         SPACE
         DS    0F
         DS@MSGPB DSECT=NO            MESSAGE PARAMETER BLOCK
         SPACE 3
         DS    0F
MSGDSA   DC    100F'0'                DSA FOR THE MESSAGE SYSTEM
LNGDSA   EQU   *-FLSTADSA             LENGTH OF SAVE AREA
         TITLE 'DS@FLSTA - MAINLINE CODE'
***********************************************************************
*                       D S @ F L S T A                               *
***********************************************************************
         SPACE
DS@FLSTA CSECT
         PRINT GEN
         USING *,R15
         DS@START ,
         LR    BASE,R15               LOAD FIRST BASE REGISTER
         DROP  R15                    DROP TEMPORARY BASE
         USING DS@FLSTA,BASE
         LA    R1,LNGDSA              GET DSA LENGTH
         LR    R5,R1                  COPY FOR LATER
         GETMAIN RC,LV=(R1)           GO GET SOME STORAGE
         LR    R4,R1                  COPY ADDRESS RETURNED
         SLR   R3,R3                  CLEAR THIS REGISTER
         MVCL  R4,R2                  THIS SHOULD ZERO IT OUT
         ST    R13,4(0,R1)            SET BACKWARD CHAIN
         ST    R1,8(0,R13)            SET FORWARD CHAIN
         LR    R13,R1                 GET DSA BASE
         USING FLSTADSA,R13
         MVC   SAVEAREA(4),=CL4'FLSA'
         SPACE
         L     R1,=A(GETSVA)          ADDRESS THIS ROUTINE
         ST    R1,GETSVA@             SAVE ADDRESS IN DSA
         L     R1,=A(FREESVA)         ADDRESS THIS ROUTINE
         ST    R1,FREESVA@            SAVE ADDRESS IN DSA
         DO    INIT                   GO DO ALL INITIALIZATION
         DO    PROCESS                GO PROCESS THE INPUT
         TM    FLAGBYTE,TBADD         IF NOTHING IN TABLE, THEN
         BO    CONTINUE
         LA    R1,MSG14                 SET MESSAGE NUMBER
         DO    PUTMSG                   GIVE IT TO ISPF
         B     RETURN                   AND WE'RE DONE
CONTINUE DS    0H                     ELSE
         DO    PROCTBL                  SHOW THE TABLE
*
RETURN   DS    0H
         LA    R2,TBLNAME
         CALL  ISPLINK,(=CL8'TBEND',(R2)),VL,MF=(E,CALLPL) CLOSE TABLE
         LR    R2,R13                 COPY R13
         LA    R1,LNGDSA              GET LENGTH OF STORAGE GOTTEN
         L     R3,4(0,R13)            COPY PREVIOUS REGISTER 13
         FREEMAIN RC,LV=(R1),A=(R2)   DO THE FREEMAIN
         LR    R13,R3                 RESTORE REG 13 CONTENTS
         SLR   R15,R15                SET RETURN CODE
         RETURN (14,12),T,RC=(15)     DONE
         SPACE
         LTORG
         DC    12F'0'                 ZAP SPACE
         DROP  BASE
         TITLE 'INITIALIZATION SUBROUTINE'
**********************************************************************
*                 I N I T         S U B R O U T I N E                *
*                                                                    *
*    THIS ROUTINE DOES ALL OF THE INITIALIZATION REQUIRED, WHICH     *
*  INCLUDES A CALL TO THE GETVARS SUBROUTINE TO GET DIALOG VARIABLES *
*  REQUIRED (CURRENTLY, THESE ARE JUST DISPLAY OPTIONS), A CALL TO   *
*  THE DEFVARS ROUTINE TO DEFINE THE TABLE VARIABLES, AND A CALL TO  *
*  THE INITTBL ROUTINE WHICH ISSUES THE ISPF TBCREATE.               *
*                                                                    *
**********************************************************************
         SPACE
         USING INIT,BASE
         SPACE
INIT     DS@ENTR
         LR    R1,R13                 COPY DSA ADDRESS
         AH    R1,=AL2(MSGDSA-FLSTADSA) ADD OFFSET FOR THIS
         ST    R1,MSGDSA@             SAVE IN MESSAGE PARM BLOCK
         LA    R1,1                   GET CONSTANT
         ST    R1,MSGTB               SET TABLE ID IN MSG PARM BLOCK
         MVI   FLAGBYTE,FIRSTDD       INITIALIZE THE FLAGBYTE
         GET   GETVTBL1,DS@DDNML,DS@DDNM GO GET INPUT VARIABLES
         DEFINE DEFVTBL1,TBSELL,TBSEL GO DEFINE TABLE VARIABLES
         DO    INITTBL                GO INIT ISPF TABLE
         LA    R1,DDTBL               ADDRESS DDNAME TABLE
         ST    R1,HEADPTR             SET HEAD OF LINK LIST
         ST    R1,PREVDD              SET PREVIOUS DDNAME PTR
         ST    R1,PRENTRY             SET PREVIOUS ENTRY IN TBL PTR
         LA    R1,12(,R1)             INCREMENT BY LENGTH OF TABLE
         ST    R1,NXTAVAIL            SET NEXT AVAILABLE SLOT
         MVI   BLANKS,C' '            INITIALIZE THIS FIELD IN DSA
         MVC   BLANKS+1(255),BLANKS
         MVC   REQBLK(REQBLKML),REQBLKM MOVE REQUEST BLOCK MASK
         DO    DDLNG                  GO PROCESS DDNAME PASSED
         MVC   RELNO(TXTUNITL),TXTUNITS MOVE TEXTUNITS MASK
         LA    R1,REQBLK              ADDRESS REQUEST BLOCK
         ST    R1,RBPTR               SAVE AS POINTER TO IT
         MVI   RBPTR,X'80'            SET VL INDICATOR FOR SVC 99
         LA    R1,TEXTPTRS            ADDRESS TEXT UNIT POINTER
         ST    R1,RBTXTPP             SAVE IN REQUEST BLOCK
         LA    R1,RELNO               ADDRESS TEXT UNIT
         ST    R1,TEXTPTRS            SAVE IN TEXT UNIT POINTERS
         LA    R1,RTDDN               ADDRESS TEXT UNIT
         ST    R1,TEXTPTRS+4          SAVE IN TEXT UNIT POINTERS
         LA    R1,RTDSN               ADDRESS TEXT UNIT
         ST    R1,TEXTPTRS+8          SAVE IN TEXT UNIT POINTERS
         LA    R1,RTMEM               ADDRESS TEXT UNIT
         ST    R1,TEXTPTRS+12         SAVE IN TEXT UNIT POINTERS
         LA    R1,RTNDP               ADDRESS TEXT UNIT
         ST    R1,TEXTPTRS+16         SAVE IN TEXT UNIT POINTERS
         LA    R1,RTSTA               ADDRESS TEXT UNIT
         ST    R1,TEXTPTRS+20         SAVE IN TEXT UNIT POINTERS
         LA    R1,RTORG               ADDRESS TEXT UNIT
         ST    R1,TEXTPTRS+24         SAVE IN TEXT UNIT POINTERS
         LA    R1,RTTYP               ADDRESS TEXT UNIT
         ST    R1,TEXTPTRS+28         SAVE IN TEXT UNIT POINTERS
         LA    R1,RTATT               ADDRESS TEXT UNIT
         ST    R1,TEXTPTRS+32         SAVE IN TEXT UNIT POINTERS
         MVI   TEXTPTRS+32,X'80'      SET VL INDICATOR
         DS@EXIT
         SPACE
REQBLKM  DC    AL1(20),AL1(7)
REQBLKML EQU   *-REQBLKM
         SPACE
TXTUNITS DC    AL2(DINRELNO,1,2,1)         RELATIVE REQUEST NUMBER
         DC    AL2(DINRTDDN,1,8),CL8' '    RETURN DDNAME
         DC    AL2(DINRTDSN,1,44),CL44' '  RETURN DSNAME
         DC    AL2(DINRTMEM,1,8),CL8' '    RETURN MEMBER NAME
         DC    AL2(DINRTNDP,1,1),X'00'     RETURN NORMAL DISPOSITION
         DC    AL2(DINRTSTA,1,1),X'00'     RETURN STATUS
         DC    AL2(DINRTORG,1,2),XL2'00'   RETURN DSORG
         DC    AL2(DINRTATT,1,1),X'00'     RETURN ATTRIBUTE
         DC    AL2(DINRTTYP,1,1),X'00'     RETURN TYPE
         DC    AL2(DUNDDNAM,1,8),CL8' '    UNALLOCATE DDNAME
         DC    AL2(DUNUNALC,0)             UNALLOCATE IT, JACK
TXTUNITL EQU   *-TXTUNITS             LENGTH OF THE TEXT UNITS
         SPACE
         DROP  BASE
         TITLE 'PROCESS ROUTINE'
**********************************************************************
*              P R O C E S S        R O U T I N E                    *
*                                                                    *
*   THIS ROUTINE ISSUES THE SVC 99 FOR DYNAMIC INFORMATION RETRIEVAL *
* UNTIL A BAD RETURN CODE IS RETURNED, INDICATING NO MORE DDNAMES TO *
* PROCESS.  FOR EACH DDNAME RETURNED, VARIOUS ROUTINES ARE CALLED TO *
* BUILD THE TABLE ENTRY FOR THIS DDNAME.  THE DDNAME IS FIRST EX-    *
* TRACTED FROM THE SVC 99 PARMLIST, AND THEN IS ADDED TO THE INTERN- *
* AL TABLE KEPT AS A LINKED-LIST IF SORT BY DDNAME IS SPECIFIED.     *
* THIS ROUTINE RETURNS A POINTER TO THE PREVIOUS DDNAME IN WHICH THE *
* NEXT TABLE ENTRY IS TO BE ADDED AFTER (AGAIN, ONLY IF SORT IS      *
* SPECIFIED).  THE SETTBL SUBROUTINE IS THEN CALLED TO SET THE ISPF  *
* TABLE TO THE PROPER POSITION FOR THE NEXT TBADD.  THEN, VARIOUS    *
* ROUTINES ARE CALLED TO ACTUALLY BUILD THE TABLE ENTRY, AND FINALLY *
* THE TABLE ENTRY IS ADDED TO THE TABLE.                             *
*                                                                    *
**********************************************************************
         SPACE
         USING PROCESS,BASE
         SPACE
PROCESS  DS@ENTR
PROCLOOP DS    0H
         LA    R1,RBPTR           ADDRESS REQUEST BLOCK POINTER
         SVC   99                 ISSUE SVC 99
         LTR   R15,R15            IF RC ^= 0, THEN
         BNZ   PROCRET              WE ARE DONE, SO LEAVE
         MVI   SEL,C' '           CLEAR TABLE ENTRY EACH TIME
         MVC   SEL+1(TBLNG-1),SEL PROPOGATE THE BLANK
         DO    GETDDNAM           GO GET DDNAME
         LTR   R15,R15            IF NOT A DDNAME MATCH, THEN
         BNZ   NEXTONE              SKIP THIS ONE
         MVC   HIDDDN,DDNAME      PUT DDNAME IN VAR
         MVC   TDDNAME,=CL8' '    BLANK OUT TEMPORARY DDNAME
         CLC   SVDDNAME,HIDDDN    IF SAME DD AS PREVIOUS, THEN
         BE    PNEWDDN              LEAVE DISPLAYABLE ONE BLANK
         MVC   TDDNAME,HIDDDN     ELSE MOVE NEW ONE TO VAR
PNEWDDN  DS    0H
         NI    FLAGBYTE,255-EXCLUDE RESET THIS FLAG
         DO    GETDSNAM           GO PUT DSNAME IN VAR
         TM    FLAGBYTE,EXCLUDE   IF EXCLUDE THIS ONE, THEN
         BO    NEXTONE              DO IT
         DO    GETDSORG           GO PUT DSORG IN VAR
         DO    GETSTAT            GO PUT STATUS IN VAR
         DO    GETDISP            GO PUT DISP IN VAR
         DO    SORTDDN            GO FIND PLACE IN TABLE FOR SORT
         DO    SETTBL             GO SET ISPF TABLE FOR TBADD
         MVC   TBSEL(TBLNG),SEL   NOW MOVE IN TABLE AREA BUILT
         DO    ADDTBL             GO ADD ENTRY TO TABLE
NEXTONE  DS    0H
         LH    R1,RELNO+6         GET RELATIVE REQUEST NUMBER
         LA    R1,1(R1)           INCREMENT IT FOR NEXT TIME
         STH   R1,RELNO+6         SAVE IT
         LA    R1,8               RESTORE TEXT UNIT LENGTHS NEEDED
         STH   R1,RTDDN+4
         STH   R1,RTMEM+4
         LA    R1,44
         STH   R1,RTDSN+4
         B     PROCLOOP           AND LOOP
PROCRET  DS@EXIT
         SPACE
         DROP  BASE
         TITLE 'GET DDNAME SUBROUTINE'
**********************************************************************
*               G E T D D N A M        R O U T I N E                 *
*                                                                    *
*    THIS SUBROUTINE SIMPLY EXTRACTS THE DDNAME RETURNED BY DYNAMIC  *
*    INFORMATION RETRIEVAL, AND PLACES IT INTO THE VARIABLE DDNAME.  *
*       OUTPUT: DDNAME IN VARIABLE DDNAME                            *
*                                                                    *
**********************************************************************
         SPACE
         USING GETDDNAM,BASE
         SPACE
GETDDNAM DS@ENTR
         SLR   R15,R15            ZERO RC
         MVC   DDNAME,=CL8' '     FIRST, BLANK DDNAME
         LH    R1,RTDDN+4         GET LENGTH FOR EXECUTE
         BCTR  R1,0               DECREMENT LENGTH FOR EX
         LTR   R1,R1              CHECK IF SAME DDNAME
         BNM   GETDDN1            IF SO, THEN
         L     R1,OLDLNG            GET OLD LENGTH
GETDDN1  DS    0H                 ELSE
         EX    R1,MVCDDN            MOVE IN NEW DDNAME
         ST    R1,OLDLNG            SAVE THIS LENGTH
GETDDCHK DS    0H
         L     R1,LNGDDNM         GET LENGTH OF DDNAME INPUT
         LTR   R1,R1              IF GENERIC, THEN
         BZ    GETDDNRT
         BCTR  R1,0                 GET EXECUTE LENGTH
         EX    R1,CLCDDN            SEE IF THIS ONE'S A MATCH
         BE    GETDDNRT             IF NOT,
         LA    R15,4                  SET BAD RC
GETDDNRT DS    0H
         DS@EXIT RET=R15
         SPACE
MVCDDN   MVC   DDNAME(0),RTDDN+6
CLCDDN   CLC   DS@DDNM(0),DDNAME
         SPACE
         DROP  BASE
         TITLE 'SORTDD SUBROUTINE'
**********************************************************************
*                 S O R T D D          R O U T I N E                 *
*                                                                    *
*    THIS SUBROUTINE DETERMINES THE PROPER POSITION IN THE TABLE     *
*    FOR THE DDNAME IF SORT BY DDNAME WAS SPECIFIED.  IT SEARCHES    *
*    THE LINKLIST TABLE OF DDNAMES SEQUENTIALLY FOR THE GIVEN DDNAME *
*    IN THE VARIABLE DDNAME, ADDS IT TO THE TABLE IF IT IS NEW,      *
*    UPDATES THE LINKLIST STRUCTURE, AND RETURNS A POINTER IN THE    *
*    TABLE TO THE PREVIOUS DDNAME IN THE VARIABLE PREVDD (THIS IS    *
*    THEN USED AS THE SEARCH ARGUMENT IN THE ISPF TABLE COMMANDS     *
*    AS THE DDNAME IN WHICH TO ADD AFTER).                           *
*       INPUT:  DDNAME IN THE VARIABLE DDNAME                        *
*       OUTPUT: PREVDD - THE PREVIOUS DDNAME                         *
*               ADDTOTOP FLAG SET IN FLAGBYTE IF NEED TO ADD TO TOP  *
*       NOTE:  THIS ROUTINE DEPENDS ON AND TAKES ADVANTAGE OF        *
*     THE FACT THAT THE DDNAMES WITH THE SAME VALUE ARE GIVEN TO     *
*     THIS ROUTINE ONE AFTER THE OTHER, WITH NO OTHER DDNAMES IN-    *
*     BETWEEN.                                                       *
*                                                                    *
**********************************************************************
         SPACE
         USING SORTDDN,BASE
         SPACE
SORTDDN  DS@ENTR ,
         CLI   SORTDD,C'N'        IF NOT SORTING BY DDNAME (OPTION)
         BE    SORTDDNX             THEN WE'RE DONE
         TM    FLAGBYTE,FIRSTDD   IF NOT FIRST DDNAME, THEN
         BZ    SORTDDN1             SKIP
         MVC   DDTBL(8),DDNAME    ELSE FIRST TIME, SO SIMPLY STORE
         NI    FLAGBYTE,255-FIRSTDD  TURN OFF FLAG,
         OI    FLAGBYTE,ADDTOTOP     INDICATE TO ADD IT TO TOP
         B     SORTDDNX           AND LEAVE
SORTDDN1 DS    0H
         CLC   DDNAME,SVDDNAME    IF DDNAME NOT = PREVIOUS, THEN
         BNE   SORTDDN2             SKIP
         L     R4,PRENTRY         ELSE, SET PREVDD TO POINT TO
         ST    R4,PREVDD            PREVIOUS ONE PUT IN TABLE
         B     SORTDDNX             AND LEAVE
SORTDDN2 DS    0H
         L     R4,HEADPTR         READY TO SEARCH THROUGH TABLE
         OI    FLAGBYTE,ADDTOTOP  ASSUME ADD IT TO TOP
SORTDDLP DS    0H
         CLC   DDNAME,0(R4)       IF FOUND PLACE IN TABLE
         BL    SRTDDLPX             THEN GET OUT OF LOOP
         NI    FLAGBYTE,255-ADDTOTOP NOW, NOT AT TOP
         ST    R4,PREVDD          ELSE SAVE PREVDD VALUE
         L     R4,8(R4)           GET POINTER TO NEXT
         LTR   R4,R4              IF ^ AT END OF LINKED-LIST
         BNZ   SORTDDLP             THEN LOOP
SRTDDLPX L     R4,PREVDD          ELSE SET R4 TO PREVIOUS
         L     R5,NXTAVAIL        IF HERE, FOUND PLACE IN TABLE, SO
         ST    R5,PRENTRY           STORE THIS AS PREVIOUS ENTRY
         MVC   0(8,R5),DDNAME       MOVE DDNAME TO TABLE
         LA    R6,12(R5)
         ST    R6,NXTAVAIL          INDICATE NEXT AVAILABLE SLOT
         TM    FLAGBYTE,ADDTOTOP  IF ^ ADDING TO BEGINNING OF TABLE
         BZ    SORTDDN3              THEN SKIPNNING OF LINKED-LIST
         L     R4,HEADPTR         GET BEGINNING OF LINKED LIST
         ST    R4,8(R5)           SET IT
         ST    R5,HEADPTR         AND UPDATE HEAD OF LIST
         B     SORTDDNX
SORTDDN3 DS    0H
         MVC   8(4,R5),8(R4)      UPDATE ALL POINTERS TO PRESERVE
         ST    R5,8(R4)             LINKED-LIST
SORTDDNX DS    0H
         MVC   SVDDNAME,DDNAME    COPY FOR LATER COMPARE
         DS@EXIT
         SPACE
         DROP  BASE
         TITLE 'SETTBL SUBROUTINE'
**********************************************************************
*                 S E T T B L          R O U T I N E                 *
*                                                                    *
*    THIS SUBROUTINE SIMPLY SETS THE ISPF TABLE FOR A SUBSEQUENT     *
*    TBADD.  IF WE ARE NOT SORTING BY DDNAME, THEN THERE IS NOTHING  *
*    TO DO HERE AND WE EXIT RIGHT AWAY.  IF WE ARE SORTING BY DDNAME *
*    THEN WE NEED TO POSITION THE TABLE FOR THE TBADD.  PREVDD WAS   *
*    SET BY THE SORTDDN ROUTINE TO POINT TO THE PREVIOUS DDNAME IN   *
*    WHICH WE WANT TO DO THE TBADD AFTER.  IN THIS CASE, WE SIMPLY   *
*    SET THE TABLE TO THE TOP, ISSUE A TBSCAN WITH THE GIVEN DDNAME, *
*    THEN TBSKIP UNTIL WE HAVE FOUND THE LAST PREVIOUS DDNAME WITH   *
*    THE GIVEN VALUE (THIS IS IN CASE OF DDNAMES WHICH ARE THE SAME- *
*    -WHICH IS PERFECTLY LEGAL).  IF ADDTOTOP IS SET IN FLAGBYTE,    *
*    THEN JUST THE TBTOP IS DONE, NOTHING ELSE.                      *
*       INPUT:  VARIABLE PREVDD - ADDRESSES PREVIOUS DDNAME          *
*       OUTPUT: ISPF TABLE CURRENT ROW POINTER SET TO ROW IN WHICH   *
*     THE TBADD IS TO BE DONE AFTER.                                 *
*                                                                    *
**********************************************************************
         SPACE
         USING SETTBL,BASE
         SPACE
SETTBL   DS    0H
         CLI   SORTDD,C'N'        IF NOT SORTING BY DDNAME, THEN
         BER   R14                  WE ARE DONE
         DS@ENTR ,
         LA    R2,TBLNAME
         CALL  ISPLINK,(=CL8'TBTOP',(R2)),VL,MF=(E,CALLPL)
         TM    FLAGBYTE,ADDTOTOP  IF ADDING TO TOP, THEN
         BO    SETTBLX              WE ARE DONE
         L     R4,PREVDD          ELSE GET PREVIOUS DDNAME
         MVC   TBHIDDDN,0(R4)       MOVE INTO TABLE
         LA    R2,TBLNAME
         LA    R3,=C'(TBHIDDDN)'
         CALL  ISPLINK,(=CL8'TBSCAN',(R2),(R3)),VL,MF=(E,CALLPL)
SETTLP   DS    0H
         LA    R2,TBLNAME
         CALL  ISPLINK,(=CL8'TBSKIP',(R2),SKIP1),VL,MF=(E,CALLPL)
         C     R15,=F'8'              SKIP UNTIL END OF GOT IT
         BNE   SETTBL1
         LA    R2,TBLNAME
         CALL  ISPLINK,(=CL8'TBBOTTOM',(R2)),VL,MF=(E,CALLPL)
         B     SETTBLX                AND WE ARE DONE
SETTBL1  DS    0H
         CLC   TBHIDDDN,0(R4)         IF NEXT DDNAME IS GREATER
         BNH   SETTLP                       THAN CURRENT
         LA    R2,TBLNAME               BACK UP ONE
         CALL  ISPLINK,(=CL8'TBSKIP',(R2),SKIP2),VL,MF=(E,CALLPL)
SETTBLX  DS    0H
         NI    FLAGBYTE,255-ADDTOTOP AND RESET FLAG
         DS@EXIT
         SPACE
SKIP1    DC    F'1'
SKIP2    DC    F'-1'
         DROP  BASE
         TITLE 'GET DSNAME SUBROUTINE'
**********************************************************************
*               G E T D S N A M        R O U T I N E                 *
*                                                                    *
*    THIS SUBROUTINE SIMPLY GETS THE DSNAME RETURNED BY DYNAMIC      *
*    INFORMATION RETRIEVAL.  IF A MEMBER NAME IS ALSO RETURNED, THEN *
*    THE MEMBER NAME IS CONCATENATED TO THE DSNAME AS IT IS PUT IN   *
*    TABLE                                                           *
*       OUTPUT: DSNAME IN VARIABLE DSNAME                            *
**********************************************************************
         SPACE
         USING GETDSNAM,BASE
         SPACE
GETDSNAM DS@ENTR
         TM    RTATT+6,X'08'      IF DYNAMICALLY ALLOCATED, THEN
         BO    GETDYN1              SKIP
GETDSN0  CLI   DYNONLY,C'Y'       IF DYN. ALLOCATED ONLY, THEN
         BNE   GETDYN1               LEAVE, GOING TO NEXT ONE
         OI    FLAGBYTE,EXCLUDE
         B     GETDSNX
GETDYN1  DS    0H
         CLI   RTTYP+6,X'40'      IF NOT TERMINAL FILE, THEN
         BNE   GETDSN1              SKIP
         MVC   DSNAME(L'TERMFILE),TERMFILE  ELSE INDICATE IT
         B     GETDSNX
GETDSN1  DS    0H
         CLI   RTTYP+6,X'80'      IF NOT DUMMY FILE, THEN
         BNE   GETDSN2              SKIP
         MVC   DSNAME(L'DUMMY),DUMMY     ELSE INDICATE IT
         B     GETDSNX
GETDSN2  DS    0H
         CLI   RTTYP+6,X'20'      IF NOT SYSIN FILE, THEN
         BNE   GETDSN3              SKIP
         MVC   DSNAME(L'SYSIN),SYSIN    ELSE INDICATE IT
         B     GETDSNX
GETDSN3  DS    0H
         CLI   RTTYP+6,X'10'      IF NOT SYSOUT FILE, THEN
         BNE   GETDSN4              SKIP
         MVC   DSNAME(L'SYSOUT),SYSOUT    ELSE INDICATE IT
         B     GETDSNX
GETDSN4  DS    0H
         LH    R4,RTDSN+4             GET LENGTH FOR EXECUTE
         BCTR  R4,0                   DECREMENT LENGTH FOR EX
         LTR   R4,R4                  IF LENGTH NOW NEGATIVE, THEN
         BM    GETDSNX                  GET OUT OF HERE
         EX    R4,MVCDSN                AND MOVE IT
         CLI   SYSNMS,C'Y'            IF ^EXCLUDE SYSTEM NAMES, THEN
         BNE   GETSYS1                  SKIP
         CLC   DSNAME(3),=C'SYS'      ELSE IF SYSTEM NAME, THEN
         BNE   GETSYS1                  GET OUT OF HERE
         CLI   DSNAME+9,C'T'
         BNE   GETSYS1
         OI    FLAGBYTE,EXCLUDE
         B     GETDSNX
GETSYS1  LH    R4,RTMEM+4              GET LNG OF MEMBER NAME (IF ANY)
         LTR   R4,R4                   IF NO MEMBER NAME, THEN
         BZ    GETDSNX                   RETURN TO CALLER
         LA    R5,DSNAME               ADDRESS TBDSNAME AREA
         LH    R6,RTDSN+4              GET LENGTH OF DSNAME
         AR    R5,R6                   GET PAST
         MVI   0(R5),C'('              MOVE IN FIRST PAREN
         BCTR  R4,0                    DECREMMENT FOR EX INSTRUCTION
         EX    R4,MVCMEM               MOVE IN MEMBER NAME
         AR    R5,R4                   NOW GET PAST MEMBER NAME
         MVI   2(R5),C')'              MOVE IN LAST PAREN
GETDSNX  DS@EXIT
         SPACE
MVCDSN   MVC   DSNAME(0),RTDSN+6      MOVE FOR EX INSTRUCTION
MVCMEM   MVC   1(0,R5),RTMEM+6        MOVE FOR EX INSTRUCTION
         SPACE
TERMFILE DC    C'++ TERMINAL ++'      DSNAME CONSTANT
DUMMY    DC    C'++ DUMMY ++'         DSNAME CONSTANT
SYSIN    DC    C'++ SYSIN ++'         DSNAME CONSTANT
SYSOUT   DC    C'++ SYSOUT ++'        DSNAME CONSTANT
         SPACE
         DROP  BASE
         TITLE 'GETSTAT SUBROUTINE'
**********************************************************************
*               G E T S T A T          R O U T I N E                 *
*                                                                    *
*    THIS SUBROUTINE SIMPLY CONVERTS THE STATUS (OLD, MOD, NEW, OR   *
*    SHR) RETURNED BY DYNAMIC INFORMATION RETRIEVAL TO A CORRESPOND- *
*    ING VALUE FOR DISPLAY IN THE TABLE.                             *
*       OUTPUT: PRINTABLE STATUS IN VARIABLE STAT                    *
*                                                                    *
**********************************************************************
         SPACE
         USING GETSTAT,BASE
         SPACE
GETSTAT  DS@ENTR
         LA   R5,STATTBL          ADDRESS BEGINNING OF TABLE
         LA   R6,STATBL#
GETSTALP DS   0H
         CLC  0(1,R5),RTSTA+6     IS THIS THE ONE?
         BE   GOTSTAT             Y.THEN SKIP
         LA   R5,4(R5)            ELSE NEXT STATUS TABLE ENTRY
         BCT  R6,GETSTALP         AND LOOP
GOTSTAT  DS   0H
         MVC  STAT,1(R5)          IF HERE, FOUND IT, SO MOVE TO VAR
         DS@EXIT                  RETURN TO CALLER
         SPACE
STATTBL  DC    X'01',C'OLD'
         DC    X'02',C'MOD'
         DC    X'04',C'NEW'
         DC    X'08',C'SHR'
         DC    X'00',C'-  '
STATBL#  EQU   (*-STATTBL-4)/4
         SPACE
         DROP  BASE
         TITLE 'GETDSORG SUBROUTINE'
**********************************************************************
*               G E T D S O R G        R O U T I N E                 *
*                                                                    *
*    THIS SUBROUTINE SIMPLY CONVERTS THE DS ORGANIZATION IN THE DSCB *
*    USING A TABLE LOOKUP INTO THE PRINTABLE 4-CHAR VERSION OF THE   *
*    DS ORG FOR PRINTING.                                            *
*       INPUT: DSORG IN BUF1+38                                      *
*       OUTPUT: PRINTABLE DSORG IN VARIABLE DSORG                    *
*                                                                    *
**********************************************************************
         SPACE
         USING GETDSORG,BASE
         SPACE
GETDSORG DS@ENTR
         LA   R5,DSORGTBL         ADDRESS BEGINNING OF TABLE
         LA   R6,DSORGTB#
GETDSOLP DS   0H
         CLC  0(2,R5),RTORG+6     IS THIS THE ONE?
         BE   GOTDSORG            Y.THEN SKIP
         LA   R5,6(R5)            ELSE NEXT DSORG TABLE ENTRY
         BCT  R6,GETDSOLP         AND LOOP
GOTDSORG DS   0H
         MVC  DSORG,2(R5)         IF HERE, FOUND IT, SO MOVE TO VAR
         DS@EXIT
         SPACE
DSORGTBL DC   X'8100',C'ISU '
         DC   X'8000',C'IS  '
         DC   X'4100',C'PSU '
         DC   X'4000',C'PS  '
         DC   X'2100',C'DAU '
         DC   X'2000',C'DA  '
         DC   X'1000',C'CX  '
         DC   X'0800',C'CQ  '
         DC   X'0400',C'MQ  '
         DC   X'0300',C'POU '
         DC   X'0200',C'PO  '
         DC   X'0040',C'TX  '
         DC   X'0020',C'TQ  '
         DC   X'0008',C'VSAM'
         DC   X'0004',C'TR  '
         DC   X'0000',C'**  '
DSORGTB# EQU  (*-DSORGTBL-6)/6
         SPACE
         DROP BASE
         TITLE 'GETDISP SUBROUTINE'
**********************************************************************
*               G E T D I S P          R O U T I N E                 *
*                                                                    *
*    THIS SUBROUTINE SIMPLY PUTS THE VALUE OF THE NORMAL DISPOSITION *
*    RETURNED BY DYNAMIC INFORMATION RETRIEVAL INTO THE VARIABLE     *
*    DISP.                                                           *
*       OUTPUT: VARIABLE DISP                                        *
*    WORK REGISTERS:  R4 THROUGH R6                                  *
*                                                                    *
**********************************************************************
         SPACE
         USING GETDISP,BASE
         SPACE
GETDISP  DS@ENTR
         LA    R4,DISPTBL         ADDRESS BEGINNING OF TABLE
GETDSLP1 DS    0H
         CLC   0(1,R4),RTNDP+6    IF A MATCH, THEN
         BE    GETDSL1X             GET OUT OF FIRST LOOP
         LA    R4,8(R4)           ELSE SET UP FOR NEXT TABLE ELEMENT
         B     GETDSLP1           AND LOOP
GETDSL1X DS    0H
         MVC   DISP,1(R4)       MOVE INTO VARIABLE
GETDSPRT DS@EXIT                  RETURN TO CALLER
         SPACE
DISPTBL  DC    X'01',CL7'UNCATLG'
         DC    X'02',CL7'CATLG'
         DC    X'04',CL7'DELETE'
         DC    X'08',CL7'KEEP'
         DC    X'10',CL7'PASS'
         SPACE
         DROP  BASE
         TITLE 'ISSUE ISPF TABLE ADD AND CREATE SUBROUTINES'
**********************************************************************
*              A D D T B L        S U B R O U T I N E                *
*                                                                    *
*    THIS SUBROUTINE ADDS AN ENTRY TO THE TABLE.                     *
*    INPUT: R14 - RETURN ADDRESS                                     *
*                                                                    *
**********************************************************************
         SPACE
         USING ADDTBL,BASE
         SPACE
ADDTBL   DS@ENTR
         LA    R2,TBLNAME
         CALL  ISPLINK,(=CL8'TBADD',(R2)),VL,MF=(E,CALLPL)
         OI    FLAGBYTE,TBADD
         DS@EXIT
         SPACE
         DROP  BASE
         TITLE 'INITIALIZE THE TABLE'
**********************************************************************
*              I N I T T B L      S U B R O U T I N E                *
*                                                                    *
*    THIS SUBROUTINE IS INVOKED ONLY ONCE TO SET UP THE ISPF TABLE   *
*  TO BE DISPLAYED BY THE INVOKING CLIST.  WE USE THE DEFVARS        *
*  SUBROUTINE TO DEFINE THE TABLE VARIABLES, AND WE CALL THE         *
*  TBCREATE DIALOG SERVICE TO CREATE THE TABLE.                      *
*    INPUT: R14 - RETURN ADDRESS                                     *
*                                                                    *
**********************************************************************
         SPACE
         USING INITTBL,BASE
         SPACE
INITTBL  DS@ENTR
         MVC   TBLNAME,=CL8'DS@A'     SET NAME FOR ISPF TABLE
         CLI   TRACE,C'T'             IF TRACE NOT SPECIFIED, THEN
         BE    INITTBL1
         TIME  DEC                      GET CURRENT TIME
         ST    R0,TBLNMTM               MAKE IT PART OF TABLE NAME
INITTBL1 DS    0H
         LA    R2,TBLNAME
         XC    CALLPL(CALLPLL),CALLPL
         CALL  ISPLINK,(=CL8'TBCREATE',(R2),,TBLVARS,=CL8'NOWRITE'),VL,+
               MF=(E,CALLPL)
         DS@EXIT
         SPACE
TBLVARS  DC    C'(TBSEL,TBDSNAME,TBDDNAME,TBHIDDDN,TBDSORG,TBDISP,TBSTA+
               T)'
         SPACE
         DROP  BASE
         TITLE 'PROCESS TABLE DISPLAY ROUTINE'
**********************************************************************
*              P R O C T B L        R O U T I N E                    *
*                                                                    *
*     THIS SUBROUTINE DISPLAYS THE TABLE BUILT ABOVE, AND PROCESSES  *
*   THE USER SELECTIONS FROM THE DISPLAY.  'END' FROM THE TBDISPL    *
*   (RC = 8) IS HOW WE EXIT THIS SUBROUTINE, AND THE PROGRAM ITSELF. *
*                                                                    *
**********************************************************************
         SPACE
         USING PROCTBL,BASE
         SPACE
PROCTBL  DS@ENTR
         MVI   ZCMDMRK,X'FF'          MARK END OF THIS FIELD
         MVI   RBVERB,S99VRBUN        SET SVC 99 VERB (FOR FREE)
         LA    R1,UNDDNM              TEXT UNIT POINTER
         ST    R1,TEXTPTRS            SAVE IT
         LA    R1,UNALLOC             TEXT UNIT POINTER
         ST    R1,TEXTPTRS+4          SAVE IT
         MVI   TEXTPTRS+4,X'80'       SET VL INDICATOR
         DEFINE DEFVTBL2,CRPL,CRP     DEFINE VARIABLES FOR TBDISPL
         MVC   AUTOSEL,=CL3'NO'       INITIALIZE AUTOSEL FIELD
         LA    R2,TBLNAME
         CALL  ISPLINK,(=CL8'TBTOP',(R2)),VL,MF=(E,CALLPL) ISSUE TBTOP
         CLI   TRACE,C'T'             IF TRACE NOT SPECIFIED, THEN
         BE    DSPLYTBL                 RETURN ERRORS TO US PLEASE
         CALL  ISPLINK,(=CL8'CONTROL',=CL8'ERRORS',=CL8'RETURN'),VL,   +
               MF=(E,CALLPL)
DSPLYTBL DS    0H
         XC    CALLPL(CALLPLL),CALLPL CLEAR THE PARM LIST
         LA    R2,TBLNAME             ADDRESS TABLE NAME
         LA    R3,CSR
         LA    R4,AUTOSEL               AND AUTOSEL
         CALL  ISPLINK,(=CL8'TBDISPL',(R2),=CL8'DS@FLSTA',,,(R3),,     +
               (R4),=CL8'CRP'),VL,MF=(E,CALLPL)
         ST    R15,RCSAVE             SAVE RETURN CODE FOR LATER
         MVC   SKIPNUM,ZTDTOP         COPY THIS FOR LATER
         MVC   CSR,CRP                AND ALSO THIS
         NI    FLAGBYTE,X'00'         CLEAR THE FLAG BYTE
         CLC   RCSAVE,=F'0'           IF RC FROM TBDISPL = 0
         BE    BIGLOOP                  SKIP
         CLC   RCSAVE,=F'4'           IF RC FROM TBDISPL ^= 4
         BNE   TBLDONE                  WE ARE DONE
         OI    FLAGBYTE,MANY          INDICATE MANY TO PROCESS
BIGLOOP  DS    0H
         L     R15,=A(TBLUPPER)       ADDRESS TRANSLATE TABLE
         TR    TBSEL,0(R15)           TRANSLATE TBSEL TO UPPER CASE
BGSKIP1  DS    0H
         MVC   TOKEN,BLANKS           BLANK OUT TOKEN
         MVC   TOKEN(1),TBSEL         MOVE SELECT CODE TO TOKEN
         NI    FLAGBYTE,255-CMDZ      INDICATE SELECT CODE, ^ ZCMD
         DO    GETCMD                 SEE IF COMMAND IS VALID
         LTR   R15,R15                IF R15 ^= 0 THEN
         BZ    BGBDCMD
         BALR  R14,R15                  GO PROCESS COMMAND
         LTR   R15,R15                  IF RETURN FROM COMMAND BAD,
         BNZ   SHOWTBL                    RESHOW
         B     UPDTBL                   ELSE CONTINUE
BGBDCMD  DS    0H
         MVC   AUTOSEL,=CL3'YES'      SET AUTOSEL TO YES
         NI    FLAGBYTE,255-MANY      TURN OFF MANY AND END
         LA    R1,MSG13               SET THE MESSAGE
         DO    PUTMSG                 GO GIVE IT TO ISPF
         B     UPDTBL1                UPDATE TABLE AND DISPLAY IT
UPDTBL   DS    0H
         MVC   TBSEL,BLANKS           BLANK TABLE SELECTION
         MVC   AUTOSEL,=CL3'NO'       SET AUTOSEL TO NO
UPDTBL1  DS    0H
         TM    FLAGBYTE,MANY          Q.MORE TO PROCESS?
         BO    MORE                   Y.THEN SKIP
         DO    PROCZCMD               GO SEE IF ZCMD GIVEN
SHOWTBL  DS    0H
         LA    R2,TBLNAME             REPOSITION TABLE FOR DISPLAY
         CALL  ISPLINK,(=CL8'TBTOP',(R2)),VL,MF=(E,CALLPL)
         LA    R3,SKIPNUM
         CALL  ISPLINK,(=CL8'TBSKIP',(R2),(R3)),VL,MF=(E,CALLPL)
         B     DSPLYTBL               AND LOOP
*                                     MORE ENTRIES TO PROCESS
MORE     DS    0H
         XC    CALLPL(CALLPLL),CALLPL CLEAR PARM LIST FOR CALL
         LA    R2,TBLNAME
         CALL  ISPLINK,(=CL8'TBDISPL',(R2),,,,,,,=CL8'CRP'),VL,        +
               MF=(E,CALLPL)
         MVC   CSR,CRP                  SAVE CRP VALUE
         LTR   R15,R15                IF STILL MORE THAN ONE TO PROC
         BNZ   BIGLOOP                  THEN CONTINUE
         NI    FLAGBYTE,255-MANY      ELSE INDICATE ONLY ONE LEFT
         B     BIGLOOP                  AND GO PROCESS IT
         SPACE
TBLDONE  DS    0H
         DS@EXIT ,
         SPACE
         DROP  BASE
         TITLE 'DS@FLSTA - EDIT/BROWSE/MEMBER LIST COMMANDS'
**********************************************************************
*                 C O M M A N D    P R O C E S S O R S               *
*                                                                    *
*     THE COMMAND PROCESSORS FOR BROWSE, EDIT AND MEMBER LIST ARE    *
*   BELOW.  THEY ALL INVOKE THE DS@SCPDS ISPF DIALOG AFTER SETTING   *
*   THE APPROPRIATE VARIABLES IN THE SHARED DIALOG VARIABLE POOL.    *
*                                                                    *
**********************************************************************
         SPACE
         USING EDIT,R15
         SPACE
EDIT     DS    0H
         MVI   MODE,C'E'              BE SURE THIS IS EDIT
         L     R15,=A(SCPDS)          SAME CODE AS MEMBER LIST
         BR    R15
         SPACE
         LTORG
         DROP  R15
         SPACE 3
         USING BROWSE,R15
         SPACE
BROWSE   DS    0H
         MVI   MODE,C'B'              INDICATE THIS IS BROWSE
         L     R15,=A(SCPDS)          SAME CODE AS MEMBER LIST
         BR    R15
         SPACE
         LTORG
         DROP  R15
         SPACE 3
         USING MEMLIST,R15
         SPACE
MEMLIST  DS    0H
         MVI   MODE,C'M'              INDICATE THIS IS BROWSE
         L     R15,=A(SCPDS)          SAME CODE AS MEMBER LIST
         BR    R15
         SPACE
         LTORG
         DROP  R15
         TITLE 'DS@FLSTA - INVOKE DS@SCPDS'
**********************************************************************
*              I N V O K E      D S @ S C P D S                      *
*                                                                    *
*     THIS ROUTINE INVOKES THE DS@SCPDS DIALOG PROGRAM TO PROCESS    *
*  THE EDIT/BROWSE OR MEMBER LIST COMMANDS.                          *
*                                                                    *
**********************************************************************
         SPACE
         USING SCPDS,BASE
         SPACE
SCPDS    DS@ENTR ,
         TM    FLAGBYTE,CMDZ          IF COMING FROM ZCMD,
         BZ    SCPDS20
         DO    GETTOKEN                 GO GET A OPERAND (DSNAME)
         LH    R1,TOKLNG
         LTR   R1,R1                    IF NOT GIVEN, THEN
         BNZ   SCPDS10
         LA    R1,MSG11                   SET THE MESSAGE
         DO    PUTMSG                     GIVE IT TO ISPF
         LA    R15,4                      SET RETURN CODE
         B     SCPDSX                     AND WE'RE DONE
SCPDS10  DS    0H                       ELSE
         MVC   TBDSNAME,TOKEN             MOVE IN OPERAND
         DO    FNDSNAME                   GO SEE IF DSNAME IN TABLE
         LTR   R15,R15                    IF NOT IN TABLE
         BZ    SCPDS20
         LA    R1,MSG6                      SET THE MESSAGE
         DO    PUTMSG                       GIVE IT TO ISPF
         LA    R15,4                        SET RETURN CODE
         B     SCPDSX                       AND WE'RE DONE
SCPDS20  DS    0H                         ELSE
         MVC   DSN1,TBDSNAME                MOVE IN DSNAME
         MVC   DSN2(MBLNKL),BLANKS          RESET
         MVI   USEROP,C'N'
         MVI   SCOP,C'N'
         LA    R2,VPUTVARS
         CALL  ISPLINK,(=CL8'VPUT',(R2),=CL8'SHARED'),VL,MF=(E,CALLPL)
         CALL  ISPLINK,(=CL8'CONTROL',=CL8'DISPLAY',=CL8'SAVE'),VL,    +
               MF=(E,CALLPL)
         CALL  ISPLINK,(=CL8'SELECT',=F'13',=CL13'PGM(DS@SCPDS)'),VL,  +
               MF=(E,CALLPL)
         ST    R15,RCSAVE                   SAVE RETURN CODE
         CALL  ISPLINK,(=CL8'CONTROL',=CL8'DISPLAY',=CL8'RESTORE'),    +
               VL,MF=(E,CALLPL)
         MVC   DSN1,BLANKS                  RESET THIS GUY
         CALL  ISPLINK,(=CL8'VPUT',=CL8'(DS@DSN1)',=CL8'SHARED'),VL,   +
               MF=(E,CALLPL)
         SLR   R15,R15                      CLEAR FOR RETURN
SCPDSX   DS    0H
         DS@EXIT RET=R15
         SPACE
VPUTVARS DC    C'(DS@DSN1 DS@DSN2 DS@DSN3 DS@DSN4 DS@MEM DS@UOP DS@USER+
                DS@SCOP DS@VOL DS@MODE)'
         SPACE
         DROP  BASE
         TITLE 'DS@FLSTA - CONCATENATED MEMBER LIST'
**********************************************************************
*      C M E M L I S T   C O M M A N D    P R O C E S S O R          *
*                                                                    *
*     THIS ROUTINE PROCESSES THE CMEMLIST COMMAND TO BUILD A PDS     *
*  MEMBER LIST FOR A SERIES OF UP TO 4 PDS'S CONCANTENATED UNDER     *
*  ONE DDNAME (WE ISPF SELECT THE PROGRAM DS@SCPDS) TO DO THIS AFTER *
*  SETTING THE NECESSARY VARIABLES IN THE SHARED DIALOG VARIABLE     *
*  POOL).                                                            *
*                                                                    *
**********************************************************************
         SPACE
         USING CMEMLIST,BASE
         SPACE
CMEMLIST DS@ENTR ,
         TM    FLAGBYTE,CMDZ          IF COMING FROM ZCMD,
         BZ    CMLIST20
         DO    GETTOKEN                 GO GET A OPERAND (DDNAME)
         LH    R1,TOKLNG
         LTR   R1,R1                    IF NOT GIVEN, THEN
         BNZ   CMLIST10
         LA    R1,MSG12                   SET THE MESSAGE
         DO    PUTMSG                     GIVE IT TO ISPF
         LA    R15,4                      SET RETURN CODE
         B     CMLISTX                    AND WE'RE DONE
CMLIST10 DS    0H                       ELSE
         MVC   TBHIDDDN,TOKEN             MOVE IN OPERAND
         DO    FNDDNAME                   GO SEE IF DDNAME IN TABLE
         LTR   R15,R15                    IF NOT IN TABLE
         BZ    CMLIST20
         LA    R1,MSG3                      SET THE MESSAGE
         DO    PUTMSG                       GIVE IT TO ISPF
         LA    R15,4                        SET RETURN CODE
         B     CMLISTX                      AND WE'RE DONE
CMLIST20 DS    0H
         CLC   TBDSORG,=CL4'PO'           IF DSORG IS NOT PO
         BE    CMLIST25
         LA    R1,MSG9                      SET MESSAGE NUMBER
         DO    PUTMSG                       GO SET THE MESSAGE
         LA    R15,4                        SET RETURN CODE
         B     CMLISTX                      AND GET OUT
CMLIST25 DS    0H
         MVC   SCANSTR,BLANKS             RESET
         MVC   MEMBER,BLANKS                THESE
         MVC   USERID,BLANKS                  FIELDS
         MVC   DDNAME,TBHIDDDN            SAVE DDNAME
         MVI   USEROP,C'N'
         MVI   SCOP,C'N'
         MVC   VOL,BLANKS
         MVC   DSN1,TBDSNAME              MOVE IN FIRST DSNAME
         MVC   DSNAME,TBDSNAME            COPY FOR LATER
         LA    R2,DSN2                    ADDRESS NEXT ONE
         LA    R3,3                       LOAD CONSTANT FOR LOOP
         LA    R4,TBLNAME                 ADDRESS TABLE NAME
CMLSTLP1 DS    0H
         CALL  ISPLINK,(=CL8'TBSKIP',(R4),=F'1'),VL,MF=(E,CALLPL)
         LTR   R15,R15                    IF NOT END OF TABLE, THEN
         BNZ   CMLSTL1X
         CLC   TBHIDDDN,DDNAME              IF DDNAME IS SAME, THEN
         BNE   CMLSTL1X
         CLC   TBDSORG,=CL4'PO'             IF DSORG IS NOT PO
         BE    CMLIST27
         LA    R1,MSG9                        SET MESSAGE NUMBER
         DO    PUTMSG                         GO SET THE MESSAGE
         LA    R15,4                          SET RETURN CODE
         B     CMLISTX                        AND GET OUT
CMLIST27 DS    0H
         MVC   0(44,R2),TBDSNAME              SET NEXT DSNAME
         MVC   DSNAME,TBDSNAME                COPY FOR LATER
         LA    R2,44(,R2)                     NEXT ONE
         BCT   R3,CMLSTLP1                    AND LOOP
CMLSTL1X DS    0H
         LTR   R3,R3                      IF ANY LEFT, THEN
         BZ    CMLIST30
         MVC   0(44,R2),DSNAME                SET NEXT DSNAME
         LA    R2,44(,R2)                     NEXT ONE
         BCTR  R3,0                           AND LOOP
         B     CMLSTL1X
CMLIST30 DS    0H
         MVI   MODE,C'M'
         L     R2,=A(VPUTVARS)
         CALL  ISPLINK,(=CL8'VPUT',(R2),=CL8'SHARED'),VL,MF=(E,CALLPL)
         CALL  ISPLINK,(=CL8'CONTROL',=CL8'DISPLAY',=CL8'SAVE'),VL,    +
               MF=(E,CALLPL)
         CALL  ISPLINK,(=CL8'SELECT',=F'13',=CL13'PGM(DS@SCPDS)'),VL,  +
               MF=(E,CALLPL)
         ST    R15,RCSAVE                   SAVE RETURN CODE
         CALL  ISPLINK,(=CL8'CONTROL',=CL8'DISPLAY',=CL8'RESTORE'),    +
               VL,MF=(E,CALLPL)
         MVC   DSN1,BLANKS                  RESET THIS GUY
         CALL  ISPLINK,(=CL8'VPUT',=CL8'(DS@DSN1)',=CL8'SHARED'),VL,   +
               MF=(E,CALLPL)
         SLR   R15,R15                      CLEAR FOR RETURN
CMLISTX  DS@EXIT RET=R15
         SPACE
         DROP  BASE
         TITLE 'DS@FLSTA - FREE COMMAND PROCESSOR'
**********************************************************************
*            F R E E     C O M M A N D    P R O C E S S O R          *
*                                                                    *
*     THIS ROUTINE PROCESSES THE FREE COMMAND BY SIMPLY DYNAMICALLY  *
*  UNALLOCATING THE DDNAME GIVEN.                                    *
*                                                                    *
**********************************************************************
         SPACE
         USING FREE,BASE
         SPACE
FREE     DS@ENTR ,
         TM    FLAGBYTE,CMDZ          IF COMING FROM ZCMD,
         BZ    FREEIT
         DO    GETTOKEN                 GO GET A OPERAND (DDNAME)
         LH    R1,TOKLNG
         LTR   R1,R1                    IF NOT GIVEN, THEN
         BNZ   FREE10
         LA    R1,MSG12                   SET THE MESSAGE
         DO    PUTMSG                     GIVE IT TO ISPF
         LA    R15,4                      SET RETURN CODE
         B     FREEX                      AND WE'RE DONE
FREE10   DS    0H                       ELSE
         MVC   TBHIDDDN,TOKEN             MOVE IN OPERAND
         DO    FNDDNAME                   GO SEE IF DDNAME IN TABLE
         LTR   R15,R15                    IF NOT IN TABLE
         BZ    FREEIT
         LA    R1,MSG3                      SET THE MESSAGE
         DO    PUTMSG                       GIVE IT TO ISPF
         LA    R15,4                        SET RETURN CODE
         B     FREEX                        AND WE'RE DONE
FREEIT   DS    0H                         ELSE
         CLC   TBDDNAME,BLANKS              IF DDNAME IS BLANK
         BNE   FREE15                          (SELECT ON WRONG LINE)
         LA    R1,MSG2                        SET MESSAGE
         DO    PUTMSG                         GIVE IT TO ISPF
         LA    R15,4                          SET RETURN CODE
         B     FREEX                          AND WE'RE DONE
FREE15   DS    0H                         ELSE
         MVC   UNDDNM+6(8),TBHIDDDN         MOVE DDNAME TO UNALLOCATE
         LA    R1,RBPTR                     ADDR REQUEST BLOCK PTR
         SVC   99                           ISSUE THE UNALLOCATE
         LTR   R15,R15                      IF SUCCESSFUL, THEN
         BNZ   FREE20
         LA    R1,MSG4                        SET INFO MESSAGE
         DO    PUTMSG                         GIVE IT TO ISPF
         MVC   DDNAME,TBHIDDDN                SAVE DDNAME
         MVI   TBSEL,C' '                     RESET THIS FIELD
         MVC   TBDDNAME,=CL8'**FREED'         THIS IS DISPLAYED
         LA    R2,TBLNAME                     UPDATE THE DISPLAY
FREEPLP  DS    0H
         XC    TBHIDDDN,TBHIDDDN              SAY FREED HERE, TOO
         CALL  ISPLINK,(=CL8'TBPUT',(R2)),VL,MF=(E,CALLPL)
         CALL  ISPLINK,(=CL8'TBSKIP',(R2),=F'1'),VL,MF=(E,CALLPL)
         LTR   R15,R15                        IF END OF TABLE,
         BZ    FREE16
         SLR   R15,R15                          SET RC
         B     FREEX                            AND DONE
FREE16   DS    0H                             ELSE
         CLC   TBHIDDDN,DDNAME                  IF SAME DDNAME
         BNE   FREEX
         B     FREEPLP                            AND LOOP
FREE20   DS    0H                           ELSE
         CLC   RBERROR,=X'0420'               IF DATASET OPEN, THEN
         BNE   FREE30
         LA    R1,MSG1                          SET MESSAGE
         DO    PUTMSG                           GIVE IT TO ISPF
         LA    R15,4                            SET RETURN CODE
         B     FREEX                            AND WE'RE DONE
FREE30   DS    0H                             ELSE
         CLC   RBERROR,=X'0438'                  IF DDNAME NOT FOUND,
         BNE   FREE40
         LA    R1,MSG15                           SET MESSAGE
         DO    PUTMSG                             GIVE IT TO ISPF
FREE40   DS    0H
         LA    R15,4                            SET RC
         B     FREEX                            DONE
FREEX    DS    0H
         DS@EXIT RET=R15
         SPACE
         DROP  BASE
         TITLE 'DS@FLSTA - LOCATE COMMAND PROCESSOR'
**********************************************************************
*         L O C A T E    C O M M A N D    P R O C E S S O R          *
*                                                                    *
*     THIS ROUTINE PROCESSES THE LOCATE COMMAND.  IF THE COMMAND HAS *
*   COME FROM ZCMD RATHER THAN THE SELECT CODE, IT CALLS GETTOKEN    *
*   TO GET THE DDNAME NAME.  IF NOT GIVEN, AN ERROR MESSAGE IS SET.  *
*   IF GIVEN, AN ISPF TBSARG IS DONE, THEN A TBSCAN TO ACTUALLY      *
*   LOCATE THIS TABLE ELEMENT.  IF IT IS NOT FOUND, AN ERROR MESSAGE *
*   IS SET.  IF FOUND, THEN A TBQUERY IS DONE TO GET THE CRP, AND    *
*   SKIPNUM IS RESET TO THE CRP, SO THAT WHEN THE TABLE IS REDIS-    *
*   PLAYED, THIS ROW WILL BE THE FIRST ROW.                          *
**********************************************************************
         SPACE
         USING LOCATE,BASE
         SPACE
LOCATE   DS@ENTR ,
         TM    FLAGBYTE,CMDZ          IF NOT ZCMD, THEN WE CAN
         BZ    LOCATIT                   SKIP THIS
         DO    GETTOKEN               GO GET DDNAME NAME
         LH    R6,TOKLNG              IF MEMBER NAME NOT GIVEN
         LTR   R6,R6                    THEN THIS IS AN ERROR
         BNZ   OKLOCMEM
         LA    R1,MSG12                 SET THE MESSAGE
         DO    PUTMSG                   LET ISPF SET IT
         LA    R15,4                    SET RETURN CODE
         B     LOCATEX                  AND GET OUT OF HERE
OKLOCMEM DS    0H
         BCTR  R6,0                   DECREMENT FOR EX INSTRUCTION
         MVC   TBHIDDDN,BLANKS        BLANK OUT DDNAME NAME
         EX    R6,MVCDDNAM            MOVE DDNAME NAME TO TBVAR
         CH    R6,=H'7'               IF TOKLNG < 7 THEN
         BL    TOKLNGB7                 SKIP
         MVI   TBHIDDDN+7,C'*'         ELSE PUT * AT END
         B     LOCATIT                  SKIP
TOKLNGB7 DS    0H
         LA    R7,TBHIDDDN+1             CALCULATE ADDR TO PUT *
         AR    R7,R6
         MVI   0(R7),C'*'             MOVE IN * AT PROPER PLACE
LOCATIT  DS    0H
         DO    FNDDNAME               GO FIND IT IN THE TABLE
         LTR   R15,R15                IF ^ FOUND, THEN
         BZ    LOCATED
         LA    R1,MSG3                  SET THE MESSAGE
         DO    PUTMSG                   LET ISPF SET IT
         B     LOCATEX
LOCATED  DS    0H
         XC    CALLPL(CALLPLL),CALLPL CLEAR CALL PARM LIST
         CALL  ISPLINK,(=CL8'TBQUERY',(R2),,,,,,=CL8'CRP'),VL,         +
               MF=(E,CALLPL)
         MVC   SKIPNUM,CRP              STORE IN SKIPNUM FOR LATER
LOCATEX  DS@EXIT RET=R15
         SPACE
MVCDDNAM MVC   TBHIDDDN(0),TOKEN      EX SKELETON
         SPACE
         DROP  BASE
         TITLE 'NOOPMEM - PROCESS NO-OP COMMAND'
**********************************************************************
*                N O O P M E M      R O U T I N E                    *
*                                                                    *
*     THIS ROUTINE PROCESSES THE NO-OP COMMAND.  THE NO-OP COMMAND   *
*   IS A SELECT CODE OF ALL BLANKS.  THIS HAPPENS WHEN AN INVALID    *
*   SELECT CODE IS ENTERED.  THE TABLE IS REDISPLAYED, AND THE USER  *
*   IS MADE TO CORRECT THE ERROR BEFORE PROCEEDING.  HE MAY SIMPLY   *
*   JUST BLANK OUT HIS SELECTION, AND IN THIS CASE THE ROW IS STILL  *
*   SELECT BY TBDISPL, SO WE MUST PROCESS THE BLANK SELECT CODE.     *
**********************************************************************
         SPACE
NOOP     DS    0H
         SLR   R15,R15                NOTHING TO DO HERE EXCEPT
         BR    R14                    SET RETURN CODE AND GO BACK
         TITLE 'DS@FLSTA - CLEAR COMMAND PROCESSOR'
**********************************************************************
*               C L E A R           R O U T I N E                    *
*                                                                    *
*     THIS ROUTINE PROCESSES THE CLEAR COMMAND, WHICH SERVES TO      *
*   DELETE TABLE ENTRIES FOR DDNAMES THAT HAVE BEEN FREED.  THE      *
*   PROCESS IS VERY SIMPLE.  WE DO A TBTOP, AND THEN STEP THROUGH    *
*   THE TABLE CHECKING TO SEE IF THE DDNAME WAS FREED. IF SO, THEN   *
*   WE ISSUE  A TBDELETE.  THIS IS DONE UNTIL THE END OF THE TABLE   *
*   IS REACHED, THEN THE TABLE IS PUT AT THE TOP.                    *
*     NOTE:  THIS PROCESS COULD EASILY CAUSE THE TABLE TO NOT HAVE   *
*   ANY ENTRIES, AND WHEN IT IS TBDISPLAYED NEXT TIME, A DIALOG      *
*   ERROR WILL BE THE RESULT.  BUT SINCE WE HAVE ISSUED "CONTROL     *
*   ERRORS RETURN", WE WILL GET CONTROL WITH A BAD RETURN CODE, AND  *
*   THIS PROGRAM WILL EXIT AS IF "END" HAD BEEN ENTERED.             *
**********************************************************************
         SPACE
         USING CLEAR,BASE
         SPACE
CLEAR    DS@ENTR ,
         LA    R2,TBLNAME
         CALL  ISPLINK,(=CL8'TBTOP',(R2)),VL,MF=(E,CALLPL)
         LA    R1,1
         L     R8,SKIPNUM             COPY CURRENT VALUE FOR SKIPNUM
         ST    R1,SKIPNUM             SET NUMBER FOR TBSKIP
CLRLOOP  DS    0H
         LA    R2,TBLNAME
         LA    R3,SKIPNUM
         CALL  ISPLINK,(=CL8'TBSKIP',(R2),(R3)),VL,MF=(E,CALLPL)
         LTR   R15,R15                IF END OF TABLE, THEN
         BNZ   CLRTBLX                  WE ARE DONE
         CLC   TBHIDDDN,=XL8'0'       IF THIS ONE WAS FREED, THEN
         BNE   CLRLOOP
         CALL  ISPLINK,(=CL8'TBDELETE',(R2)),VL,MF=(E,CALLPL)
         B     CLRLOOP                  LOOP
CLRTBLX  DS    0H
         ST    R8,SKIPNUM             RESTORE CURREN VALUE FOR SKIPNUM
         DS@EXIT ,
         SPACE
         DROP  BASE
         TITLE 'DS@FLSTA - PROCESS "TOP" ZCMD'
**********************************************************************
*               T O P T B L         R O U T I N E                    *
*                                                                    *
*     THIS ROUTINE PROCESSES THE TOP COMMAND, BY SIMPLY RESETTING    *
*  SKIPNUM TO 1.                                                     *
*                                                                    *
**********************************************************************
         SPACE
         USING TOP,R15
         SPACE
TOP      DS    0H
         MVC   SKIPNUM,=F'1'
         SLR   R15,R15
         BR    R14
         SPACE
         LTORG
         DROP  R15
         TITLE 'DS@FLSTA - LOOK AT ZCMD'
**********************************************************************
*              P R O C Z C M D      R O U T I N E                    *
*                                                                    *
*     THIS ROUTINE DETERMINES IF ZCMD IS NONBLANK, AND IF SO, CALLS  *
*   GETTOKEN TO GET THE ACTUAL COMMAND.  GETCMD THEN VALIDATES THIS  *
*   COMMAND, AND IF IT IS VALID, WE  CALL THE CORRECT  PROCESSING    *
*   ROUTINE.  OTHERWISE, AN ERROR MESSAGE IS SET INDICATING THAT AN  *
*   INVALID COMMAND WAS GIVEN.                                       *
*     REGISTER USAGE: R5 - R9 AS WORK REGISTERS                      *
**********************************************************************
         SPACE
         USING PROCZCMD,BASE
         SPACE
PROCZCMD DS    0H
         TM    FLAGBYTE,CMDZ          IF WE ALREADY HAVE ZCMD
         BOR   R14                          OR
         CLC   ZCMD,BLANKS               IF ZCMD IS BLANK
         BER   R14                      NOTHING TO DO
         DS@ENTR ,
         LA    R6,ZCMD                ADDRESS ZCMD
         ST    R6,TOKPTR              SET UP FOR SUBROUTINE
         DO    GETTOKEN               ELSE GO GET COMMAND IN ZCMD
         DO    GETCMD                   GO VALIDATE COMMAND
         LTR   R15,R15                  IF COMMAND IS VALID THEN
         BNZ   OKZCMD                     SKIP
         LA    R1,MSG17                   SET THE MESSAGE
         DO    PUTMSG                     AND SET IT
         B     PZRETRN                    AND LEAVE
OKZCMD   DS    0H
         OI    FLAGBYTE,CMDZ            INDICATE COMMAND IS ZCMD
         BALR  R14,R15                  GO PROCESS IT
PZRETRN  DS    0H
         DS@EXIT ,
         SPACE
         DROP  BASE
         TITLE 'DETERMINE LENGTH OF DDNAME PASSED'
**********************************************************************
*                 D D L N G       S U B R O U T I N E                *
*                                                                    *
*    THIS SUBROUTINE DETERMINES IF A GENERIC DDNAME WAS PASSED, AND  *
*  IF SO, THE LENGTH OF THE DDNAME (LESS ENDING ASTERISK) FOR        *
*  A LATER CLC.  A SINGLE ASTERISK IS THE SAME AS IF THE DDNAME WAS  *
*  BLANK.  IF THE DDNAME IS GIVEN AND IT DOES NOT END IN AN "*",     *
*  THEN WE ARE LOOKING FOR A SPECIFIC DDNAME, SO THE LENGTH IS SET   *
*  TO 8.                                                             *
*                                                                    *
**********************************************************************
         SPACE
         USING DDLNG,BASE
         SPACE
DDLNG    DS@ENTR ,
         XC    LNGDDNM,LNGDDNM        ASSUME ZERO
         CLC   DS@DDNM,BLANKS         IF BLANK DDNAME, THEN
         BE    DDLNGRT                  WE ARE DONE
         LA    R6,DS@DDNM             ADDRESS DDNAME PASSED
         LA    R7,L'DS@DDNM-1(R6)     GET TO END OF IT
DDNLOOP  DS    0H
         CLI   0(R7),C'*'             LOOP UNTIL ASTERISK OR NONBLANK
         BE    DDLNGST                  FOUND
         CLI   0(R7),C' '
         BE    DNXTBYTE
         MVC   LNGDDNM,=F'8'           IF HERE, NON-GENERIC PASSED,
         B     DDLNGRT                  SO LENGTH IS 7, AND RETURN
DNXTBYTE DS    0H
         BCTR  R7,0                   IF HERE, LOOK AT NEXT BYTE
         B     DDNLOOP                AND LOOP
         SPACE
DDLNGST  DS    0H
         SR    R7,R6                  CALCULATE LENGTH
         ST    R7,LNGDDNM             STORE THIS LENGTH AWAY
DDLNGRT  DS@EXIT ,
         SPACE
         DROP  BASE
         TITLE 'DS@FLSTA - FIND DDNAME IN TABLE'
**********************************************************************
*              F N D D N A M E      R O U T I N E                    *
*                                                                    *
*     THIS ROUTINE DETERMINES IF THE DDNAME NAMED BY TBDDNAME IS     *
*   IN THE ISPF TABLE.  IT IS CALLED BY THE COMMAND PROCESSING       *
*   ROUTINES WHEN PROCESSING A COMMAND FROM THE COMMAND LINE (ZCMD). *
*   IF THE DDNAME IS NOT FOUND, R15 IS RETURNED WITH A VALUE OF 4.   *
*   OTHERWISE R15 IS RETURNED AS ZERO.                               *
**********************************************************************
         SPACE
         USING FNDDNAME,BASE
         SPACE
FNDDNAME DS    0H
         DS@ENTR ,
FNDDNLP  DS    0H
         MVC   DDNAME,TBHIDDDN        SAVE DDNAME
         LA    R2,TBLNAME
         CALL  ISPLINK,(=CL8'TBTOP',(R2)),VL,MF=(E,CALLPL)
         MVC   TBHIDDDN,DDNAME        MOVE DDNAME BACK IN
         CALL  ISPLINK,(=CL8'TBSCAN',(R2),=CL8'TBHIDDDN'),VL,          +
               MF=(E,CALLPL)
FNDDN01  DS    0H
         DS@EXIT RET=R15
         SPACE
         DROP  BASE
         TITLE 'DS@FLSTA - FIND DSNAME IN TABLE'
**********************************************************************
*              F N D S N A M E      R O U T I N E                    *
*                                                                    *
*     THIS ROUTINE DETERMINES IF THE DSNAME NAMED BY TBDSNAME IS     *
*   IN THE ISPF TABLE.  IT IS CALLED BY THE COMMAND PROCESSING       *
*   ROUTINES WHEN PROCESSING A COMMAND FROM THE COMMAND LINE (ZCMD). *
*   IF THE DSNAME IS NOT FOUND, R15 IS RETURNED WITH A VALUE OF 4.   *
*   OTHERWISE R15 IS RETURNED AS ZERO.                               *
**********************************************************************
         SPACE
         USING FNDSNAME,BASE
         SPACE
FNDSNAME DS    0H
         DS@ENTR ,
FNDSNLP  DS    0H
         MVC   DSNAME,TBDSNAME        SAVE INPUT
         LA    R2,TBLNAME
         CALL  ISPLINK,(=CL8'TBTOP',(R2)),VL,MF=(E,CALLPL)
         MVC   TBDSNAME,DSNAME        RESET DSNAME
         CALL  ISPLINK,(=CL8'TBSCAN',(R2),=CL8'TBDSNAME'),VL,          +
               MF=(E,CALLPL)
FNDSN01  DS    0H
         DS@EXIT RET=R15
         SPACE
         DROP  BASE
         TITLE 'GETCMD - GET COMMAND FROM COMMAND TABLE'
**********************************************************************
*                G E T C M D        R O U T I N E                    *
*                                                                    *
*     THIS ROUTINE  DETERMINES IF THE COMMAND IN THE FIELD TOKEN     *
*   EXISTS IN CMDTBL.  IF IT DOES, R15 IS RETURNED WITH THE ADDRESS  *
*   OF THE PROPER PROCESSING ROUTINE.  IF THE COMMAND IS NOT FOUND   *
*   IN CMDTBL, THEN R15 IS SET TO ZERO.                              *
*     REGISTER USAGE: R6 AS A WORK REGISTER                          *
**********************************************************************
         SPACE
         USING GETCMD,BASE
         SPACE
GETCMD   DS@ENTR ,
         L     R6,=A(CMDTBL)          ADDRESS COMMAND TABLE
         LA    R7,CMDTBLSZ            GET NUMBER OF TABLE ELEMENTS
         SLR   R15,R15                ASSUME WE WON'T FIND IT
GCDLOOP  DS    0H
         CLC   0(8,R6),TOKEN          IF COMMAND FOUND IN TABLE THEN
         BE    GOTCMD                   OK, SO SKIP
         LA    R6,12(R6)              ELSE NEXT TABLE ELEMENT
         BCT   R7,GCDLOOP               AND LOOP
         B     GCMDRET                IF HERE, IT WAS NOT FOUND
GOTCMD   DS    0H
         L     R15,8(R6)              GET ADDRESS OF ROUTINE
GCMDRET  DS@EXIT RET=R15              RETURN TO CALLER
         SPACE
         DROP  BASE
         TITLE 'GETTOKEN - GET TOKEN FROM ZCMD'
**********************************************************************
*             G E T T O K E N       R O U T I N E                    *
*                                                                    *
*     THIS ROUTINE FUNCTIONS AS A SIMPLE PARSERBY PUTTING IN THE    *
*   FIELD TOKEN THE NEXT WORD FROM THE FIELD ZCMD.  THE ONLY VALID   *
*   DELIMITER BETWEEN WORDS OF THE COMMAND IS CURRENTLY A BLANK.     *
*   THE ROUTINE SAVES A POINTER TO THE PLACE IN ZCMD IN WHICH TO     *
*   BEGIN LOOKING FOR THE NEXT TOKEN.  SO TO BEGIN WITH THE FIRST    *
*   TOKEN IN ZCMD, THIS SHOULD POINT TO THE ADDRESS OF ZCMD.         *
*     INPUT: ZCMD - FIELD IN WHICH TO RETRIEVE TOKEN                 *
*            TOKPTR - PLACE IN WHICH TO BEGIN SEARCH                 *
*     OUTPUT: TOKEN - VALUE GOTTEN                                   *
*             TOKLNG - LENGTH OF TOKEN GOTTEN                        *
**********************************************************************
         SPACE
         USING GETTOKEN,BASE
         SPACE
GETTOKEN DS    0H
         DS@ENTR ,
         MVC   TOKEN,BLANKS           CLEAR TOKEN FIELD
         XC    TOKLNG,TOKLNG          CLEAR LENGTH
         L     R6,TOKPTR              ADDRESS START OF SEARCH
GBLNKLP  DS    0H
         CLI   0(R6),X'FF'            IF END OF ZCMD, THEN
         BE    GTOKRET                  WE ARE DONE, SO LEAVE
         CLI   0(R6),C' '             IF BLANK NOT FOUND THEN
         BNE   GBLNKLPX                 GET OUT OF LOOP
         LA    R6,1(R6)               ELSE NEXT CHARACTER
         B     GBLNKLP                  AND LOOP
GBLNKLPX DS    0H
         LA    R7,1(R6)               FIRST BYTE AFTER NONBLANK
GCHARLP  DS    0H
         CLI   0(R7),X'FF'            IF END OF ZCMD, THEN
         BE    GTOKRET                  WE ARE DONE, SO LEAVE
         CLI   0(R7),C' '             IF BLANK FOUND, THEN
         BE    GCHARLPX                 GET OUT OF LOOP
         LA    R7,1(R7)               ELSE NEXT CHARACTER
         B     GCHARLP                  AND LOOP
GCHARLPX DS    0H
         LA    R8,1(R7)               COPY CURRENT PLACE+1
         ST    R8,TOKPTR              SAVE POINTER FOR LATER
         SR    R7,R6                  SUBTRACT TO GET LNG OF TOKEN
         STH   R7,TOKLNG              SAVE FOR LATER
         BCTR  R7,0                   DECREMENT FOR EXECUTE
         EX    R7,MVCTOK              AND MOVE INTO TOKEN FIELD
GTOKRET  DS    0H                     RETURN TO CALLER
         DS@EXIT ,
         SPACE
MVCTOK   MVC   TOKEN(0),0(R6)
         SPACE
         DROP  BASE
         TITLE 'DS@FLSTA - SET ISPF MESSAGE SUBROUTINE'
**********************************************************************
*              P U T M S G         S U B R O U T I N E               *
*                                                                    *
*    THIS SETS UP THE MESSAGE PARAMETER BLOCK AND CALLS THE MESSAGE  *
*  PROGRAM TO SET AN ISPF MESSAGE.  INPUT TO THIS ROUTINE IS R1,     *
*  WHICH CONTAINS THE ID OF THE MESSAGE.                             *
*                                                                    *
**********************************************************************
         SPACE
         USING PUTMSG,BASE
         SPACE
PUTMSG   DS@ENTR ,
         C     R1,=AL4(MSGMAX)        IF GREATER THAN MAX MSG, THEN
         BNH   *+6
         DC    H'0'                     DIE NOW
         ST    R1,MSGID               SAVE MESSAGE IN PARM BLOCK
         LA    R2,DS@MSGPB            ADDRESS MESSAGE PARM BLOCK
         CALL  DS@FAMSG,((R2)),VL,MF=(E,CALLPL)
         DS@EXIT ,
         SPACE
         DROP  BASE
         TITLE 'GET ISPF DIALOG VARIABLES SUBROUTINE'
**********************************************************************
*              G E T V A R S       S U B R O U T I N E               *
*                                                                    *
*    THIS SUBROUTINE CYCLES THROUGHT THE NECESSARY TABLES IN ORDER   *
*  TO EFFICIENTLY ISSUE VCOPY CALLS.                                 *
*  INPUT TO THIS ROUTINE IS VARTBLA, WHICH CONTAINS THREE ADDRESSES. *
*  THE FIRST ADDRESS POINTS TO A TABLE THAT CONTAINS VARIOUS INFOR-  *
*  MATION ABOUT THE VARIABLES TO VCOPY; THE SECOND ADDRESS POINTS    *
*  TO A LENGTH TABLE WHERE THE VARIABLE LENGTHS VCOPIED WILL BE      *
*  PLACED (IN CONSECUTIVE FULLWORDS); THE THIRD ADDRESS POINTS TO    *
*  THE FIRST VARIABLE ADDRESS IN THE DSA.                            *
*                                                                    *
**********************************************************************
         SPACE
         USING GETVARS,BASE
         SPACE
GETVARS  DS@ENTR
         L     R2,VARTBLA             GET ADDRESS OF TABLE
         L     R3,VARTBLA+4           GET ADDRESS FOR FIRST LENGTH
         L     R4,VARTBLA+8           GET ADDRESS FOR FIRST VARIABLE
GVLOOP   DS    0H
         SLR   R5,R5                  CLEAR REGISTER 2
         IC    R5,0(R2)               GET LENGTH FOR VARIABLE
         LTR   R5,R5                  IF ZERO, THEN
         BZ    GVEXIT                   WE ARE DONE
         ST    R5,0(R3)               SAVE VARIABLE LENGTH IN TABLE
         LH    R5,2(R2)               GET OFFSET FOR VARIABLE
         AR    R5,R4                  ADD TO FIRST VARIABLE
         LA    R6,4(R2)               ADDRESS VARIABLE NAME
         CALL  ISPLINK,(=CL8'VCOPY',(R6),(R3),(R5),=CL8'MOVE'),VL,     +
               MF=(E,CALLPL)          ISSUE THE VCOPY
         LA    R2,VTBLLNG(,R2)        NEXT ELEMENT IN THE TABLE
         LA    R3,4(,R3)              NEXT ONE IN LENGTH TABLE
         B     GVLOOP                 AND LOOP
GVEXIT   DS@EXIT
         SPACE
         DROP  BASE
         TITLE 'DEFINE ISPF DIALOG VARIABLES SUBROUTINE'
**********************************************************************
*              D E F V A R S       S U B R O U T I N E               *
*                                                                    *
*    THIS SUBROUTINE CYCLES THROUGHT THE NECESSARY TABLES IN ORDER   *
*  TO EFFICIENTLY ISSUE VDEFINE CALLS.                               *
*  INPUT TO THIS ROUTINE IS VARTBLA, WHICH CONTAINS THREE ADDRESSES. *
*  THE FIRST ADDRESS POINTS TO A TABLE THAT CONTAINS VARIOUS INFOR-  *
*  MATION ABOUT THE VARIABLES TO VDEFINE; THE 2ND  ADDRESS POINTS    *
*  TO A LENGTH TABLE WHERE THE VARIABLE LENGTHS VDEFINED WILL BE     *
*  PLACED (IN CONSECUTIVE FULLWORDS); THE THIRD ADDRESS POINTS TO    *
*  THE FIRST VARIABLE ADDRESS IN THE DSA.                            *
*                                                                    *
**********************************************************************
         SPACE
         USING DEFVARS,BASE
         SPACE
DEFVARS  DS@ENTR
         L     R2,VARTBLA             GET ADDRESS OF TABLE
         L     R3,VARTBLA+4           GET ADDRESS FOR FIRST LENGTH
         L     R4,VARTBLA+8           GET ADDRESS FOR FIRST VARIABLE
DVLOOP   DS    0H
         SLR   R5,R5                  CLEAR REGISTER 2
         IC    R5,0(R2)               GET LENGTH FOR VARIABLE
         LTR   R5,R5                  IF ZERO, THEN
         BZ    DVEXIT                   WE ARE DONE
         ST    R5,0(R3)               SAVE VARIABLE LENGTH IN TABLE
         LH    R5,2(R2)               GET OFFSET FOR VARIABLE
         AR    R5,R4                  ADD TO FIRST VARIABLE
         LA    R6,4(R2)               ADDRESS VARIABLE NAME
         LA    R7,=C'CHAR'            ADDRESS THIS FORMAT
         CLI   1(R2),CHAR             IF NOT CHAR FORMAT, THEN
         BE    DVVDEF
         LA    R7,=C'FIXED'             TRY FIXED FORMAT
         CLI   1(R2),FIXED              IF NOT FIXED FORMAT, THEN
         BE    DVVDEF
         LA    R7,=C'BIT'                 TRY BIT FORMAT
         CLI   1(R2),BIT                  IF NOT BIT FORMAT, THEN
         BE    DVVDEF
         LA    R7,=C'HEX'                   TRY HEX FORMAT
         CLI   1(R2),HEX                    IF NOT HEX FORMAT, THEN
         BE    DVVDEF
         DC    H'0'                           DIE 0C1
DVVDEF   DS    0H
         CALL  ISPLINK,(=CL8'VDEFINE',(R6),(R5),(R7),(R3)),VL,         +
               MF=(E,CALLPL)          ISSUE THE VCOPY
         LA    R2,VTBLLNG(,R2)        NEXT ELEMENT IN THE TABLE
         LA    R3,4(,R3)              NEXT ONE IN LENGTH TABLE
         B     DVLOOP                 AND LOOP
DVEXIT   DS@EXIT
         SPACE
         DROP  BASE
         TITLE 'ASSIGN SAVE AREA FOR SUBROUTINE'
**********************************************************************
*              G E T S V A         S U B R O U T I N E               *
*                                                                    *
*    THIS SUBROUTINE ASSIGNS THE NEXT SAVE AREA IN THE STACK FOR THE *
*  CALLING SUBROUTINE.  THE ADDRESS OF THE 64-BYTE SAVEAREA IS RE-   *
*  TURNED IN REGISTER 1.                                             *
*    THIS ROUTINE IS COUPLED CLOSELY WITH THE DS@ENTR MACRO, AND     *
*  SHOULD ONLY BE USED IN THIS ENVIRONMENT.                          *
*                                                                    *
**********************************************************************
         SPACE
         USING GETSVA,R15
         SPACE
GETSVA   DS    0H
         L     R1,SAVADDR             GET CURRENT ADDRESS
         LTR   R1,R1                  IF THIS IS FIRST TIME
         BNZ   GETSVA1
         LA    R1,SAVSTCK               SET ADDRESS OF SAVE AREAS
         ST    R1,SAVADDR
         B     GETSVA2
GETSVA1  DS    0H                     ELSE
         LA    R1,SAVALNG(,R1)          CALCULATE NEXT SAVE AREA
         ST    R1,SAVADDR               AND SAVE IT
GETSVA2  DS    0H
         LH    R0,NUMSVA              GET NUMBER OF SAVE AREAS
         AH    R0,=H'1'               INCREMENT IT
         STH   R0,NUMSVA              SAVE AWAY
         CH    R0,=AL2(SAVMAX)        IF WE HAVE EXCEEDED MAXIMUM
         BNH   *+4+2                      NESTING LEVEL
         DC    H'0'                     DIE 0C1
         BR    R14                    ELSE RETURN TO CALLER
         SPACE
         LTORG
         SPACE
         DROP  R15
         TITLE 'RETURN SAVE AREA ADDRESS, REMOVE FROM STACK'
**********************************************************************
*              F R E E S V A       S U B R O U T I N E               *
*                                                                    *
*    THIS SUBROUTINE RETURNS THE ADDRESS OF THE CURRENT SAVEAREA,    *
*  AND REMOVES IT FROM THE STACK.                                    *
*    THIS ROUTINE IS COUPLED CLOSELY WITH THE DS@ENTR MACRO, AND     *
*  SHOULD ONLY BE USED IN THIS ENVIRONMENT.                          *
*                                                                    *
**********************************************************************
         SPACE
         USING FREESVA,R15
         SPACE
FREESVA  DS    0H
         LH    R1,NUMSVA              GET NUMBER ON STACK
         LTR   R1,R1                  IF ZERO, THEN
         BNZ   *+4+2
         DC    H'0'                     DIE 0C1
         BCTR  R1,0                   ELSE DECREMENT IT
         STH   R1,NUMSVA                SAVE FOR NEXT TIME
         L     R0,SAVADDR               GET CURRENT SAVE AREA ADDRESS
         LR    R1,R0                    COPY IT
         SH    R0,=AL2(SAVALNG)         CALCULATE PREVIOUS SAVEAREA
         ST    R0,SAVADDR               SAVE FOR NEXT TIME
         BR    R14                      RETURN TO CALLER
         SPACE
         LTORG
         SPACE
         DROP  R15
         TITLE 'MISCELLANEOUS STORAGE DEFINITIONS'
**********************************************************************
*              S T O R A G E    D E F I N I T I O N S                *
**********************************************************************
*
**********************************************************************
*     D I A L O G     D E F I N I T I O N S   --  L E N G T H S      *
**********************************************************************
         SPACE
GETVTBL1 DC    AL1(L'DS@DDNM),AL1(CHAR),AL2(DS@DDNM-DS@DDNM)
         DC    CL10'(DS@DDNM)'
VTBLLNG  EQU   *-GETVTBL1
         DC    AL1(L'SORTDD),AL1(CHAR),AL2(SORTDD-DS@DDNM)
         DC    CL10'(SORTDD)'
         DC    AL1(L'SYSNMS),AL1(CHAR),AL2(SYSNMS-DS@DDNM)
         DC    CL10'(SYSNMS)'
         DC    AL1(L'DYNONLY),AL1(CHAR),AL2(DYNONLY-DS@DDNM)
         DC    CL10'(DYNONLY)'
         DC    AL1(L'TRACE),AL1(CHAR),AL2(TRACE-DS@DDNM)
         DC    CL10'(TRACE)'
         DC    AL2(0)                 INDICATES END OF TABLE
         SPACE
DEFVTBL1 DC    AL1(L'TBSEL),AL1(CHAR),AL2(TBSEL-TBSEL)
         DC    CL10'(TBSEL)'
         DC    AL1(L'TBDSNAME),AL1(CHAR),AL2(TBDSNAME-TBSEL)
         DC    CL10'(TBDSNAME)'
         DC    AL1(L'TBDDNAME),AL1(CHAR),AL2(TBDDNAME-TBSEL)
         DC    CL10'(TBDDNAME)'
         DC    AL1(L'TBHIDDDN),AL1(CHAR),AL2(TBHIDDDN-TBSEL)
         DC    CL10'(TBHIDDDN)'
         DC    AL1(L'TBDSORG),AL1(CHAR),AL2(TBDSORG-TBSEL)
         DC    CL10'(TBDSORG)'
         DC    AL1(L'TBDISP),AL1(CHAR),AL2(TBDISP-TBSEL)
         DC    CL10'(TBDISP)'
         DC    AL1(L'TBSTAT),AL1(CHAR),AL2(TBSTAT-TBSEL)
         DC    CL10'(TBSTAT)'
         DC    AL2(0)                 INDICATES END OF TABLE
         SPACE
DEFVTBL2 DC    AL1(L'CRP),AL1(FIXED),AL2(CRP-CRP)
         DC    CL10'(CRP)'
         DC    AL1(L'ZTDTOP),AL1(FIXED),AL2(ZTDTOP-CRP)
         DC    CL10'(ZTDTOP)'
         DC    AL1(L'ZCMD),AL1(CHAR),AL2(ZCMD-CRP)
         DC    CL10'(ZCMD)'
         DC    AL1(L'DSN1),AL1(CHAR),AL2(DSN1-CRP)
         DC    CL10'(DS@DSN1)'
         DC    AL1(L'DSN2),AL1(CHAR),AL2(DSN2-CRP)
         DC    CL10'(DS@DSN2)'
         DC    AL1(L'DSN3),AL1(CHAR),AL2(DSN3-CRP)
         DC    CL10'(DS@DSN3)'
         DC    AL1(L'DSN4),AL1(CHAR),AL2(DSN4-CRP)
         DC    CL10'(DS@DSN4)'
         DC    AL1(L'MEMBER),AL1(CHAR),AL2(MEMBER-CRP)
         DC    CL10'(DS@MEM)'
         DC    AL1(L'USERID),AL1(CHAR),AL2(USERID-CRP)
         DC    CL10'(DS@USER)'
         DC    AL1(L'VOL),AL1(CHAR),AL2(VOL-CRP)
         DC    CL10'(DS@VOL)'
         DC    AL1(L'SCOP),AL1(CHAR),AL2(SCOP-CRP)
         DC    CL10'(DS@SCOP)'
         DC    AL1(L'USEROP),AL1(CHAR),AL2(USEROP-CRP)
         DC    CL10'(DS@UOP)'
         DC    AL1(L'SCANSTR),AL1(CHAR),AL2(SCANSTR-CRP)
         DC    CL10'(DS@SCSTR)'
         DC    AL1(L'MODE),AL1(CHAR),AL2(MODE-CRP)
         DC    CL10'(DS@MODE)'
         DC    AL2(0)                 INDICATES END OF TABLE
         SPACE
CHAR     EQU   0
FIXED    EQU   4
BIT      EQU   8
HEX      EQU   12
         TITLE 'DS@FLSTA - COMMAND TABLE'
**********************************************************************
*              C O M M A N D        T A B L E                        *
**********************************************************************
         SPACE
CMDTBL   DS    0F
         DC    CL8'S       ',AL4(BROWSE)
         DC    CL8'B       ',AL4(BROWSE)
         DC    CL8'E       ',AL4(EDIT)
         DC    CL8'C       ',AL4(CMEMLIST)
         DC    CL8'M       ',AL4(MEMLIST)
         DC    CL8'F       ',AL4(FREE)
         DC    CL8'L       ',AL4(LOCATE)
         DC    CL8'        ',AL4(NOOP)
         DC    CL8'BROWSE  ',AL4(BROWSE)
         DC    CL8'EDIT    ',AL4(EDIT)
         DC    CL8'SEL     ',AL4(BROWSE)
         DC    CL8'FREE    ',AL4(FREE)
         DC    CL8'LOC     ',AL4(LOCATE)
         DC    CL8'LOCATE  ',AL4(LOCATE)
         DC    CL8'CLEAR   ',AL4(CLEAR)
         DC    CL8'TOP     ',AL4(TOP)
CMDTBLSZ EQU   ((*-CMDTBL)/12)
         TITLE 'UPPER CASE TRANSLATE TABLE'
**********************************************************************
*        U P P E R    C A S E    T R A N S L A T E   T B L           *
**********************************************************************
         SPACE
TBLUPPER DS    0F
         DC    256AL1(*-TBLUPPER)
         ORG   TBLUPPER+X'81'
TBLGRPA  DC    9AL1(C'A'+*-TBLGRPA)
         ORG   TBLUPPER+X'91'
TBLGRPJ  DC    9AL1(C'J'+*-TBLGRPJ)
         ORG   TBLUPPER+X'A2'
TBLGRPS  DC    8AL1(C'S'+*-TBLGRPS)
         ORG   TBLUPPER+256
         TITLE 'ERROR MESSAGE NUMBER EQUATES'
**********************************************************************
*              E R R O R    M E S S A G E    N U M B E R S           *
**********************************************************************
         SPACE
MSG1     EQU   1
MSG2     EQU   2
MSG3     EQU   3
MSG4     EQU   4
MSG5     EQU   5
MSG6     EQU   6
MSG7     EQU   7
MSG8     EQU   8
MSG9     EQU   9
MSG10    EQU   10
MSG11    EQU   11
MSG12    EQU   12
MSG13    EQU   13
MSG14    EQU   14
MSG15    EQU   15
MSG16    EQU   16
MSG17    EQU   17
MSGMAX   EQU   MSG17
         END
