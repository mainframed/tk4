DS@DRIVR TITLE 'DS@DRIVR'
***********************************************************************
*  PROGRAM-ID: DS@DRIVR                                               *
*                                                                     *
*  FUNCTION:                                                          *
*      THIS PROGRAM SERVES AS A FRONT END TO DS@SCPDS, WHICH IS AN    *
*      ISPF DIALOG THAT CONSTRUCTS A PDS MEMBER LIST (AND OPTIONALLY  *
*      SCANS MEMBERS OF A PDS FOR A CHARACTER STRING).  INPUT TO THIS *
*      PROGRAM IS A SINGLE PARAMETER  "MODE", WHICH HAS ONE OF THREE  *
*      VALUES AS FOLLOWS:  "E" FOR EDIT, "B" FOR BROWSE, OR "M" FOR   *
*      SCAN PDS.  MODE IS USED TO DETERMINE WHICH APPLICATION PANEL   *
*      IS DISPLAYED.  THE PROGRAM SIMPLY DISPLAYS THE PROPER MENU,    *
*      PROCESSES EDIT RECOVERY IF NEEDED, THEN SETS THE VARIABLES FOR *
*      THE DS@SCPDS APPLICATION, AND INVOKES IT.                      *
*         NOTE THAT THIS DIALOG CAN BE RUN ONLY UNDER ISPF VERSION    *
*      2 OR LATER.                                                    *
*                                                                     *
*  REGISTER USAGE:                                                    *
*      R0 - R11 AS GENERAL WORK REGISTERS                             *
*      R12 - BASE REGISTER                                            *
*      R13-R15 STANDARD USAGE                                         *
*                                                                     *
*  RETURN CODE:                                                       *
*       0 - NORMAL TERMINATION                                        *
*                                                                     *
* AUTHOR:   PHIL HEROLD, SYSTEMS DEVELOPER                            *
*           SAS INSTITUTE                                             *
*           CARY, NC                                                  *
*                                                                     *
* NOTE:  SAS INSTITUTE IS NOT RESPONSIBLE FOR THE SUPPORT OF THIS     *
*        PROGRAM--PLEASE DO NOT CALL SAS INSTITUTE TECHNICAL SUPPORT. *
*        HOWEVER, THE AUTHOR WILL BE GLAD TO PROVIDE ANY ASSISTANCE   *
*        NEEDED.                                                      *
*                                                                     *
*                                                                     *
*  CHANGE ACTIVITY:                                                   *
*                                                                     *
***********************************************************************
         COPY  DS@MACS
         TITLE 'OTHER EQUATES'
***********************************************************************
*                     O T H E R    E Q U A T E S                      *
***********************************************************************
         SPACE
FLAGON   EQU   255
FLAGOFF  EQU   0
         SPACE
DSNML    EQU   44
         TITLE 'DSECTS'
***********************************************************************
*                        D S E C T S                                  *
***********************************************************************
         SPACE
         DS@VRSTB
         TITLE 'DSA DEFINITIONS'
***********************************************************************
*                   D S A      D E F I N I T I O N S                  *
***********************************************************************
         SPACE
DS@DRIVD DSECT
SAVEAREA DC    18F'0'
VARTBLA  DC    2A(0)                  PARM LIST FOR VARIABLE SUBR.
DSAZAP   DC    4F'0'                  EXTRA DSA SPACE FOR ZAPS
DS@14TO1 DC    4F'0'                  TEMPORARY SAVE AREA
DS@14T1L EQU   *-DS@14TO1             LENGTH OF ABOVE
GETSVA@  DC    A(0)                   ADDRESS OF GETSVA ROUTINE
FREESVA@ DC    A(0)                   ADDRESS OF FREESVA ROUTINE
ROUT@    DC    A(0)                   ADDRESS OF ROUTINE
RCSAVE   DC    F'0'                   SAVE AREA FOR RETURN CODE
TOKPTR   DC    F'0'
TOKLNG   DC    F'0'
WHATMODE DC    F'0'                   MODE (AS FOLLOWS)
PDFBROW  EQU   0                        ISPF/PDF BROWSE
PDFEDIT  EQU   4                        ISPF/PDF EDIT
SCANPDS  EQU   8                        SCAN PDS
         SPACE
MODE     DC    C' '                   MODE PASSED AS PARM=
BROWSE   EQU   C'B'                     VALUES FOR MODE
EDIT     EQU   C'E'
SCAN     EQU   C'M'
         SPACE
PANELNM  DC    CL8' '                 CURRENT PANEL NAME TO DISPLAY
         SPACE
         TITLE 'PANEL VARIABLE DEFINITIONS'
**********************************************************************
*       P A N E L     V A R I A B L E     D E F I N I T I O N S      *
**********************************************************************
         SPACE
VARBASE  EQU   *                    VARIABLE BASE
ZODSN    DC    CL55' '                "OTHER" DATASET NAME
ZOVOL    DC    CL6' '                 "OTHER" DATASET VOLUME
PRJ1     DC    CL8' '                 PDF PROJECT 1
LIB1     DC    CL8' '                 PDF LIBRARY 1
TYP1     DC    CL8' '                 PDF TYPE    1
PRJ2     DC    CL8' '                 PDF PROJECT 2  (NOT ON MENU)
LIB2     DC    CL8' '                 PDF LIBRARY 2
TYP2     DC    CL8' '                 PDF TYPE    2  (NOT ON MENU)
LIB3     DC    CL8' '                 PDF LIBRARY 3
LIB4     DC    CL8' '                 PDF LIBRARY 4
LIBCLCL  EQU   *-PRJ2                 LENGTH FOR CLC
ZMEM     DC    CL8' '                 MEMBER NAME
PROF     DC    CL8' '                 PROFILE NAME
IMAC     DC    CL8' '                 INITIAL EDIT MACRO
FNAME    DC    CL8' '                 FORMAT NAME
MIX      DC    CL3' '                 MIXED MODE (YES OR NO)
         SPACE 2
ZPREFIX  DC    CL8' '                 USER PREFIX
TRACE    DC    CL8' '                 TRACE PARAMETER
ZEDCMD   DC    C' '                   EDREC COMMAND (D, C OR BLANK)
ZCMD     DC    CL80' '                ZCMD FROM PANEL
INITBLNG EQU   *-ZODSN                LENGTH TO BLANK OUT INITIALLY
         TITLE 'DEFINITIONS FOR DS@SCPDS'
**********************************************************************
*         V A R I A B L E S     F O R     D S @ S C P D S            *
**********************************************************************
         SPACE
DS@DSN1  DC    CL(DSNML)' '           1ST DATASET
DS@DSN2  DC    CL(DSNML)' '           2ND DATASET
DS@DSN3  DC    CL(DSNML)' '           3RD DATASET
DS@DSN4  DC    CL(DSNML)' '           4TH DATASET
DS@MEM   DC    CL8' '                 MEMBER NAME
DS@VOL   DC    CL6' '                 VOLUME
DS@MIX   DC    CL3' '                 MIX MODE
DS@FNAM  DC    CL8' '                 FORMAT NAME
DS@PROF  DC    CL8' '                 PROFILE NAME
DS@IMAC  DC    CL8' '                 INITIAL EDIT MACRO
DS@MODE  DC    C' '                   MODE (E, B OR M)
DS@LNG   EQU   *-DS@DSN1              LENGTH TO BLANK OUT
DSNAME   DC    CL(DSNML)' '           <*** FOR ERROR MESSAGE ***>
DS@UOP   DC    C' '                   USERID OPTION
DS@USER  DC    CL8' '                 USERID
DS@SCOP  DC    C' '                   SCAN OPTION
DS@LVL   DC    F'0'                   LEVEL
         TITLE 'DIALOG VARIABLE LENGTH FIELDS'
**********************************************************************
*                 L E N G T H     F I E L D S                        *
**********************************************************************
         SPACE
LNGBASE  DC    F'0'                 BASE FOR LENGTHS
         TITLE 'MISCELLANEOUS DEFINITIONS'
**********************************************************************
*          M I S C E L L A N E O U S    D E F I N I T I O N S        *
**********************************************************************
         SPACE
BLANKS   DC    CL256' '
         SPACE
TRTBL    DC    XL256'00'              TRANSLATE TABLE
         SPACE
TLIBS    DS    0H
TPRJ2    DC    CL8' '
TLIB2    DC    CL8' '
TTYP2    DC    CL8' '
TLIB3    DC    CL8' '
TLIB4    DC    CL8' '
         SPACE
CALLPL   CALL  ,(,,,,,,,,,,,,,),MF=L
CALLPLL  EQU   *-CALLPL
         SPACE
SELTEXT  DC    C'PGM(DS@SCPDS)'
SELTEXTL EQU   *-SELTEXT
         SPACE 2
**********************************************************************
*          M E S S A G E       P A R A M E T E R    B L O C K        *
**********************************************************************
         SPACE
         DS    0F
         DS@MSGPB DSECT=NO            MESSAGE PARAMETER BLOCK
         SPACE
         DS    0F
         SPACE 2
**********************************************************************
*                    F   L   A   G   S                               *
**********************************************************************
         SPACE
FLAGS    DC    AL4(0)                 FLAG BYTES
         ORG   FLAGS
FLAG1    DC    AL1(0)
VARINIT  EQU   B'10000000'            VARIABLES HAVE BEEN INITIALIZED
QUALFIED EQU   B'01000000'            QUALIFIED "OTHER" DATASET NAME
FLAG2    DC    AL1(0)
FLAG3    DC    AL1(0)
FLAG4    DC    AL1(0)
         SPACE 3
**********************************************************************
*                       S A V E     A R E A                          *
**********************************************************************
         SPACE
NUMSVA   DC    F'0'                   NUMBER OF SAVE AREAS
SAVADDR  DC    A(0)                   LAST SAVE AREA
SAVMAX   EQU   8                      LEVEL OF SUBROUTINE NESTING
SAVALNG  EQU   64                     LENGTH OF A SAVE AREA
         SPACE
SAVSTCK  DS    0F                     SAVE AREA STACK
         ORG   *+(SAVMAX*SAVALNG)
         SPACE
MSGDSA   DC    100F'0'                DSA FOR THE MESSAGE SYSTEM
LNGDSA   EQU   *-DS@DRIVD             LENGTH OF DSA
         TITLE 'DS@DRIVR - MAINLINE CODE'
**********************************************************************
*                           B E G I N                                *
**********************************************************************
         SPACE
         PRINT GEN
*        PRINT NOGEN
DS@DRIVR CSECT
         USING *,R15
         DS@START ,
         LR    R12,R15                LOAD FIRST BASE REGISTER
         DROP  R15
         USING DS@DRIVR,BASE
         LR    R9,R1                  COPY INPUT PARM REGISTER
         LH    R1,=AL2(LNGDSA)        GET DSA LENGTH
         LR    R5,R1                  COPY FOR LATER
         GETMAIN RC,LV=(R1)           GO GET SOME STORAGE
         LR    R4,R1                  COPY ADDRESS RETURNED
         SLR   R3,R3                  CLEAR THIS REGISTER
         MVCL  R4,R2                  THIS SHOULD ZERO IT OUT
         ST    R13,4(0,R1)            SET BACKWARD CHAIN
         ST    R1,8(0,R13)            SET FORWARD CHAIN
         LR    R13,R1                 GET DSA BASE
         USING DS@DRIVD,R13
         MVC   SAVEAREA(4),=C'DRVR'   SET PROGRAM IDENTIFIER
         L     R1,=A(GETSVA)          ADDRESS THIS ROUTINE
         ST    R1,GETSVA@             SAVE IN DSA
         L     R1,=A(FREESVA)         ADDRESS THIS ROUTINE
         ST    R1,FREESVA@            SAVE IN DSA
         DO    DOIT                   GO DO THE PROCESSING
RETURN   DS    0H
         LR    R2,R13                 COPY R13
         LH    R1,=AL2(LNGDSA)        GET DSA LENGTH
         L     R3,4(0,R13)            COPY PREVIOUS REGISTER 13
         FREEMAIN RC,LV=(R1),A=(R2)   DO THE FREEMAIN
         LR    R13,R3                 RESTORE REG 13 CONTENTS
         SLR   R15,R15                CLEAR RETURN CODE
         RETURN (14,12),T,RC=(15)     DONE
         SPACE
         LTORG
         SPACE
PATCH    DC    15F'0'                 PATCH AREA FOR ABOVE
         SPACE
         DROP  BASE
         TITLE 'DO THE PROCESSING'
**********************************************************************
*                      P R O C E S S                                 *
*                                                                    *
*    FIRST, DETERMINE WHAT MODE WE ARE INVOKED WITH.  BASED ON THIS, *
*  VDEFINE THE NECESSARY DIALOG VARIABLES TO CONSTRUCT THE DSNAMES   *
*  FOR DS@SCPDS.  SHOW THE DATA ENTRY PANEL WHICH IS THE FRONT END.  *
*  IF EDIT, DO EDIT RECOVERY.  FINALLY, SET UP THE VARIABLES FOR     *
*  DS@SCPDS AND INVOKE THIS APPLICATION.                             *
*                                                                    *
**********************************************************************
         SPACE
         USING DOIT,BASE
         SPACE
DOIT     DS@ENTR ,
         LR    R1,R13                 COPY DSA ADDRESS
         AH    R1,=AL2(MSGDSA-DS@DRIVD) ADD OFFSET FOR THIS
         ST    R1,MSGDSA@             SAVE IN MESSAGE PARM BLOCK
         MVI   BLANKS,C' '            INIT BLANKS AREA IN DSA
         MVC   BLANKS+1(255),BLANKS
         MVC   SELTEXT,=C'PGM(DS@SCPDS)'
         L     R9,0(,R9)              ADDRES INPUT PARM
         MVC   MODE,2(R9)             SET MODE
         DO    SETMODE                GO LOOK AT IT
         LA    R1,ZODSN               ADDRESS START OF AREA TO BLANK
         LA    R2,INITBLNG            GET LENGTH TO BLANK
         DO    BLANKIT                GO INITIALIZE THESE FIELDS
         L     R1,=A(VARSMISC)        ADDRESS VARIABLE TABLE
         LA    R2,VARMISC#            GET NUMBER TO VDEFINE
         STM   R1,R2,VARTBLA          SAVE IN PARM LIST
         DO    DEFVARS                VDEFINE (COPY) THESE VARIABLES
         L     R1,=A(VARSCPDS)        ADDRESS VARIABLE TABLE
         LA    R2,VARSCPD#            GET NUMBER TO VDEFINE
         STM   R1,R2,VARTBLA          SAVE IN PARM LIST
         DO    DEFVARS                VDEFINE (COPY) THESE VARIABLES
         XC    CALLPL(CALLPLL),CALLPL CLEAR CALL PARM LIST
         L     R3,WHATMODE            GET MODE INDICATOR
         LA    R2,ROUTTBL             ADDRESS PANEL NAME TABLE
         AR    R2,R3                  CALCULATE ADDRESS OF ROUT ADDR
         L     R1,0(R2)               GET ROUTINE ADDRESS
         ST    R1,ROUT@
         LA    R2,VARS@               ADDRESS VARIABLES TABLE
         AR    R2,R3                  CALCULATE ADDRESS OF TABLE ADDR
         L     R1,0(R2)               GET TABLE ADDRESS
         ST    R1,VARTBLA             SAVE IN PARM LIST FOR ROUTINE
         LA    R2,VARSL@              ADDRESS LENGTH TABLE
         AR    R2,R3                  CALCULATE ADDRESS OF TABLE ADDR
         L     R1,0(R2)               GET LENGTH
         ST    R1,VARTBLA+4           SAVE IN PARM LIST FOR ROUTINE
         LA    R2,PNLNMTB             ADDRESS PANEL NAME TABLE
         SLL   R3,1                   DOUBLE IT TO GET OFFSET TO TBL
         AR    R2,R3                  CALCULATE ADDRESS OF PANEL NAME
         MVC   PANELNM,0(R2)          SAVE NAME
LOOP     DS    0H
         MVC   DS@DSN1(DS@LNG),BLANKS CLEAR PARM AREA
         L     R15,ROUT@              GET DISPATCH ROUTINE ADDRESS
         BALR  R14,R15                GO DO IT
         C     R15,=F'4'              IF RC <= 4, THEN
         BNH   LOOP                     LOOP
DISPLPX  DS    0H
         DS@EXIT ,
         SPACE 2
PNLNMTB  DC    CL8'DS@BRO01'          BROWSE FRONT PANEL
         DC    CL8'DS@EDT01'          EDIT FRONT PANEL
         DC    CL8'DS@SCPDM'          SCAN PDS FRONT PANEL
         SPACE
ROUTTBL  DC    A(REGBRED)             REGULAR BROWSE/EDIT ROUTINE
         DC    A(REGBRED)             REGULAR BROWSE/EDIT ROUTINE
         DC    A(SCPDS)               SCAN PDS ROUTINE
         SPACE
VARS@    DC    A(VARSBE)              BROWSE/EDIT VARIABLE TABLE
         DC    A(VARSBE)              BROWSE/EDIT VARIABLE TABLE
         DC    A(VARSSCAN)            SCAN PDS VARIABLE TABLE
         SPACE
VARSL@   DC    AL4(VARSBE#)           NUMBER IN BROWSE/EDIT TABLE
         DC    AL4(VARSBE#)
         DC    AL4(VARSCAN#)          NUMBER IN SCAN PDS TABLE
         SPACE
         DROP  BASE
         TITLE 'BROWSE/EDIT PROCESSOR'
**********************************************************************
*            B R O W S E / E D I T    P R O C E S S O R              *
*                                                                    *
*    THIS ROUTINE DOES REGULAR BROWSE/EDIT.  IT DISPLAYS THE MENU    *
*  FIRST.  IF END IS ENTERED, THEN IT RETURNS WITH A RETURN CODE     *
*  OF 8.  OTHERWISE, THE BROWSE/EDIT IS DONE, AND A RETURN CODE OF   *
*  0 IS SENT BACK.                                                   *
*                                                                    *
**********************************************************************
         SPACE
         USING REGBRED,BASE
         SPACE
REGBRED  DS@ENTR ,
         MVI   DS@UOP,C'N'              SET THIS VARIABLE
         MVI   DS@SCOP,C'N'             SET THIS VARIABLE
         DO    SCPDS                    USE GENERIC ROUTINE
         DS@EXIT RET=R15
         DROP  BASE
         TITLE 'SCAN PDS PROCESSOR'
**********************************************************************
*             S C A N P D S        P R O C E S S O R                 *
*                                                                    *
*    THIS ROUTINE DOES SCAN PDS.  IT  DISPLAYS  THE  MENU            *
*  FIRST.  IF END IS ENTERED, THEN IT RETURNS WITH A RETURN CODE     *
*  OF 8.  OTHERWISE, THE BROWSE/EDIT IS DONE, AND A RETURN CODE OF   *
*  0 IS SENT BACK.                                                   *
*                                                                    *
**********************************************************************
         SPACE
         USING SCPDS,BASE
         SPACE
SCPDS    DS@ENTR ,
         TM    FLAG1,VARINIT          IF VARIABLES NOT DEFINED, THEN
         BO    SCPDS01
         DO    DEFVARS                  GO DEFINE TABLE VARIABLES
         OI    FLAG1,VARINIT            SAY WE'VE DONE THE INIT
SCPDS01  DS    0H
         LA    R2,PANELNM             ADDRESS PANEL NAME
         XC    CALLPL(CALLPLL),CALLPL CLEAR CALL PARM LIST
         CALL  ISPLINK,(=CL8'DISPLAY',(R2)),VL,MF=(E,CALLPL)
         LTR   R15,R15                IF "END" ENTERED, THEN
         BNZ   SCPDSX                   DONE
         CLC   ZCMD,BLANKS            IF ZCMD NOT BLANK, THEN
         BE    SCPDS10
         LA    R1,MSG1                  SET MESSAGE NUMBER
         DO    PUTMSG                   GIVE IT TO ISPF
         B     SCPDSX                   AND LEAVE
SCPDS10  DS    0H
         MVC   DS@MODE,MODE           SET MODE
         DO    BLDPARMS               GO BUILD PARMS
         LTR   R15,R15                IF NOT ERROR, THEN
         BNZ   SCPDSX
         XC    CALLPL(CALLPLL),CALLPL       CLEAR CALL PARM LIST
         CALL  ISPLINK,(=CL8'SELECT',=AL4(SELTEXTL),SELTEXT),          +
               VL,MF=(E,CALLPL)             DO THE SCAN/MEMBER LIST
         ST    R15,RCSAVE                   SAVE RETURN CODE
         SLR   R15,R15                      CLEAR RETURN CODE
SCPDSX   DS    0H
         DS@EXIT RET=R15
         DROP  BASE
         TITLE 'BUILD INPUT PARAMETERS FOR THE DS@SCPDS PROGRAM'
**********************************************************************
*             B L D P A R M        S U B R O U T I N E               *
*                                                                    *
*    THIS ROUTINE BUILDS THE DIALOG VARIABLES REQUIRED FOR THE       *
*  DS@SCPDS PROGRAM AND PLACES THESE VARIABLES IN THE SHARED DIALOG  *
*  VARIABLE POOL FOR SUBSEQUENT INVOCATION OF THAT PROGRAM.  DATASET *
*  NAMES ARE VALIDATED USING A CALLED ROUTINE.  IF A DATASET IS IN-  *
*  VALID, A MESSAGE IS SET FOR ISPF, AND THIS ROUTINE SENDS BACK A   *
*  NON-ZERO (4) RETURN CODE IN REG. 15.                              *
*                                                                    *
**********************************************************************
         SPACE
         USING BLDPARMS,BASE
         SPACE
BLDPARMS DS@ENTR ,
         XC    TRTBL,TRTBL            CLEAR TRANSLATE TABLE
         NI    FLAG1,255-QUALFIED     RESET THIS FLAG
         CLC   ZODSN,BLANKS           IF NOT "OTHER" DSN, THEN
         BNE   BLDPRM10
         MVC   DS@MEM,ZMEM              MOVE IN MEMBER NAME SPECIFIED
         MVC   DS@DSN1(8),PRJ1          MOVE IN PROJECT 1
         MVI   TRTBL+C' ',C' '          INITIALIZE IT
         LA    R6,DS@DSN1               SET CURRENT POSITION
         TRT   0(L'DS@DSN1,R6),TRTBL    FIND A BLANK
         MVI   0(R1),C'.'               MOVE IN A PERIOD
         LA    R6,1(,R1)                GET PAST IT
         MVC   0(8,R6),LIB1             MOVE IN LIBRARY 1
         TRT   0(L'DS@DSN1,R6),TRTBL    FIND A BLANK
         MVI   0(R1),C'.'               MOVE IN A PERIOD
         LA    R6,1(,R1)                GET PAST IT
         MVC   0(8,R6),TYP1             MOVE IN TYPE 1
         CLC   PRJ2(LIBCLCL),BLANKS     IF OTHER "LEVELS" GIVEN, THEN
         BE    BLDPRM30
         MVC   TLIBS(LIBCLCL),PRJ2        COPY THEM TO TEMPORARY
         CLC   TPRJ2,BLANKS               IF PROJECT 2 BLANK, THEN
         BNE   *+10
         MVC   TPRJ2,PRJ1                   SET IT TO PROJECT 1
         CLC   TLIB2,BLANKS               IF LIBRARY 2 BLANK, THEN
         BNE   *+10
         MVC   TLIB2,LIB1                   SET IT TO LIBRARY 1
         CLC   TLIB3,BLANKS               IF LIBRARY 3 BLANK
         BNE   *+10
         MVC   TLIB3,TLIB2                  SET IT TO LIBRARY 2
         CLC   TLIB4,BLANKS               IF LIBRARY 4 BLANK
         BNE   *+10
         MVC   TLIB4,TLIB3                  SET IT TO LIBRARY 3
         CLC   TTYP2,BLANKS               IF TYPE 2 BLANK
         BNE   *+10
         MVC   TTYP2,TYP1                   SET IT TO TYPE 1
         MVC   DS@DSN2(8),TPRJ2         MOVE IN PROJECT 2
         LA    R6,DS@DSN2               SET CURRENT POSITION
         TRT   0(L'DS@DSN2,R6),TRTBL    FIND A BLANK
         MVI   0(R1),C'.'               MOVE IN A PERIOD
         LA    R6,1(,R1)                GET PAST IT
         MVC   0(8,R6),TLIB2            MOVE IN LIBRARY 2
         TRT   0(L'DS@DSN2,R6),TRTBL    FIND A BLANK
         MVI   0(R1),C'.'               MOVE IN A PERIOD
         LA    R6,1(,R1)                GET PAST IT
         MVC   0(8,R6),TTYP2            MOVE IN TYPE 2
         MVC   DS@DSN3(8),TPRJ2         MOVE IN PROJECT 2
         LA    R6,DS@DSN3               SET CURRENT POSITION
         TRT   0(L'DS@DSN3,R6),TRTBL    FIND A BLANK
         MVI   0(R1),C'.'               MOVE IN A PERIOD
         LA    R6,1(,R1)                GET PAST IT
         MVC   0(8,R6),TLIB3            MOVE IN LIBRARY 3
         TRT   0(L'DS@DSN3,R6),TRTBL    FIND A BLANK
         MVI   0(R1),C'.'               MOVE IN A PERIOD
         LA    R6,1(,R1)                GET PAST IT
         MVC   0(8,R6),TTYP2            MOVE IN TYPE 2
         MVC   DS@DSN4(8),TPRJ2         MOVE IN PROJECT 2
         LA    R6,DS@DSN4               SET CURRENT POSITION
         TRT   0(L'DS@DSN4,R6),TRTBL    FIND A BLANK
         MVI   0(R1),C'.'               MOVE IN A PERIOD
         LA    R6,1(,R1)                GET PAST IT
         MVC   0(8,R6),TLIB4            MOVE IN LIBRARY 4
         TRT   0(L'DS@DSN2,R6),TRTBL    FIND A BLANK
         MVI   0(R1),C'.'               MOVE IN A PERIOD
         LA    R6,1(,R1)                GET PAST IT
         MVC   0(8,R6),TTYP2            MOVE IN TYPE 2
         B     BLDPRM30
BLDPRM10 DS    0H                     ELSE ("OTHER" DSN GIVEN)
         MVC   DS@VOL,ZOVOL             MOVE IN VOLUME
         LA    R6,ZODSN                 ADDRESS ZODSN FOR DS@SCPDS
         LA    R7,DSNML-1(,R6)          GET TO END OF IT
BLDPRLP1 DS    0H
         CLI   0(R7),C' '               LOOP BACKWARD TO FIND FIRST
         BNE   *+4+4                         NON-BLANK
         BCT   R7,BLDPRLP1
         CLI   0(R6),C''''              IF QUALIFIED NAME, THEN
         BNE   BLDPRM20
         CLI   0(R7),C''''                IF NOT ENDING C'''', THEN
         BE    BLDPRM15
BLDPRMM1 LA    R1,MSG3                      SET MESSAGE
         DO    PUTMSG                       GIVE IT TO ISPF
         LA    R15,4                        SET RC
         B     BLDPARMX                     AND DONE
BLDPRM15 DS    0H                         ELSE
         OI    FLAG1,QUALFIED               SAY QUALIFIED
         LA    R6,1(,R6)                    SQUEEZE C'''' FROM
         BCTR  R7,0                               FRONT AND BACK
         B     BLDPRM22                 ELSE /* NOT QUALIFIED)
BLDPRM20 DS    0H                         IF ENDING C'''', THEN
         CLI   0(R7),C''''
         BE    BLDPRMM1                     GO SET A MESSAGE
BLDPRM22 DS    0H
         MVI   TRTBL+C'(',C'('          SET TRANSLATE TABLE WITH C'('
         TRT   0(DSNML-1,R6),TRTBL      SEE IF C'('
         BZ    BLDPRM25                 IF FOUND, THEN MEMBER GIVEN,
         LR    R7,R1
         BCTR  R7,0                       PUT R7 IN FRONT OF C'('
         MVI   TRTBL+C'(',0               CLEAR TRTBL
         MVI   TRTBL+C')',C')'            SET IT FOR C')'
         TRT   2(9,R7),TRTBL              SEE IF C')'
         BNZ   BLDPRM23                   IF NOT ENDING ')', THEN
         LA    R1,MSG4                      SET MESSAGE
         DO    PUTMSG                       GIVE IT TO ISPF
         LA    R15,4                        SET RC
         B     BLDPARMX                     AND DONE
BLDPRM23 DS    0H
         SR    R1,R7                      CALCULATE EXECUTE LENGTH
         S     R1,=F'3'                       FOR MEMBER NAME
         EX    R1,PRMMVMEM                MOVE IT
BLDPRM25 DS    0H
         SR    R7,R6                    R7 = LENGTH OF NAME
         LA    R5,DS@DSN1               ADDRESS PLACE TO MOVE NAME
         TM    FLAG1,QUALFIED           IF QUALIFIED NAME, THEN
         BO    BLDPRM27
         MVC   0(8,R5),ZPREFIX            MOVE IN PREFIX
         MVI   TRTBL+C')',0               RESET TRTBL
         MVI   TRTBL+C' ',C' '            PUT A BLANK IN IT
         TRT   0(8,R5),TRTBL              FIND A BLANK
         LR    R5,R1                      GET ADDRESS OF BLANK
         MVI   0(R5),C'.'                 MOVE IN A PERIOD
         LA    R5,1(,R5)                  GET PAST THE PERIOD
BLDPRM27 DS    0H
         EX    R7,PRMMVDSN              MOVE IT
BLDPRM30 DS    0H
         DO    DSNMVAL                VALIDATE DATASET NAMES
         LTR   R15,R15                IF ALL ARE INVALID, THEN
         BNZ   BLDPARMX
         MVC   DS@MIX,MIX                 MOVE IN MIXED MODE INDICATOR
         MVC   DS@FNAM,FNAME              MOVE IN FORMAT NAME
BLDPRM50 DS    0H
         CLI   MODE,EDIT                IF EDIT  OR
         BNE   BLDPRM70
         MVC   DS@PROF,PROF               SET PROFILE
         MVC   DS@IMAC,IMAC               SET INITIAL MACRO
BLDPRM70 DS    0H
         LA    R2,DS@VARS               ADDRESS VARIABLES
         CALL  ISPLINK,(=CL8'VPUT',(R2),=CL8'SHARED'),VL,MF=(E,CALLPL)
BLDPARMX DS    0H
         DS@EXIT RET=R15
         SPACE
PRMMVDSN MVC   0(0,R5),0(R6)          MVC SKELETON
PRMMVMEM MVC   DS@MEM(0),2(R7)        MVC SKELETON
PRMBLNK  MVC   1(0,R7),BLANKS         MVC SKELETON
         SPACE
DS@VARS  DC    C'(DS@DSN1 DS@DSN2 DS@DSN3 DS@DSN4 DS@MEM DS@VOL DS@UOP +
               DS@SCOP DS@MIX DS@FNAM DS@PROF DS@IMAC DS@MODE DS@LVL)'
         DROP  BASE
         TITLE 'DSNMVAL SUBROUTINE'
**********************************************************************
*            D S N M V A L         S U B R O U T I N E               *
*                                                                    *
*    VALIDATE THE DATASET NAMES, AND IF ANY ARE INVALID, THEN SET    *
*  A MESSAGE, AND RETURN WITH A RETURN CODE OF 4.                    *
*                                                                    *
**********************************************************************
         SPACE
         USING DSNMVAL,BASE
         SPACE
DSNMVAL  DS@ENTR ,
         LA    R1,DS@DSN1             ADDRESS FIRST DATASET NAME
         DO    DSNMV                  GO SEE IF VALID
         LTR   R15,R15                IF INVALID, THEN
         BNZ   DSNMVBD                  DONE
         LA    R1,DS@DSN2             ADDRESS NEXT DATASET NAME
         DO    DSNMV                  GO SEE IF VALID
         LTR   R15,R15                IF INVALID, THEN
         BNZ   DSNMVBD                  DONE
         LA    R1,DS@DSN3             ADDRESS NEXT DATASET NAME
         DO    DSNMV                  GO SEE IF VALID
         LTR   R15,R15                IF INVALID, THEN
         BNZ   DSNMVBD                  DONE
         LA    R1,DS@DSN4             ADDRESS NEXT DATASET NAME
         DO    DSNMV                  GO SEE IF VALID
         LTR   R15,R15                IF INVALID, THEN
         BNZ   DSNMVBD                  DONE
         SLR   R15,R15                ELSE CLEAR RC
         B     DSNMVALX                 AND DONE
DSNMVBD  DS    0H                     IF HERE, THEN
         MVC   DSNAME(DSNML),0(R1)      MOVE NAME IN FOR MESSAGE
         LA    R1,MSG2                  SET MESSAGE NUMBER
         DO    PUTMSG                   GIVE MESSAGE TO ISPF
         LA    R15,4                    SET RC
DSNMVALX DS    0H
         DS@EXIT RET=R15
         TITLE 'DSNMV SUBROUTINE'
**********************************************************************
*               D S N M V          S U B R O U T I N E               *
*                                                                    *
*    THIS SUBROUTINE DOES THE ACTUAL DATASET NAME VALIDATION. IF     *
*  RETURNS A NON-ZERO RETURN CODE IF THE DATASET NAME IS INVALID.    *
*  UPON INPUT, R1 POINTS TO THE DATASET NAME TO VALIDATE.  THE NAME  *
*  IS 44 CHARACTERS, LEFT JUSTIFIED, PADDED WITH BLANKS.             *
*                                                                    *
**********************************************************************
         SPACE
         USING DSNMV,BASE
         SPACE
DSNMV    DS@ENTR ,
         SLR   R15,R15                ASSUME VALID DATASET NAME
         LR    R8,R1                  COPY DATASET NAME ADDRESS
         XC    TRTBL,TRTBL            CLEAR TRANSLATE TABLE
         MVI   TRTBL+C' ',C' '        PUT A BLANK IN IT
         TRT   0(DSNML,R8),TRTBL      LOOK FOR A BLANK
         BC    12,DSNMV10             IF BLANK FOUND IN LAST BYTE, THEN
         L     R6,=AL4(DSNML-1)         LENGTH MUST 43
         B     DSNMV30
DSNMV10  DS    0H                     ELSE
         BNZ   DSNMV20                  IF NO BLANK, THEN
         LA    R6,DSNML                   LENGTH MUST 44
         B     DSNMV30
DSNMV20  DS    0H                       ELSE
         LR    R5,R1                      COPY CURRENT POSITION
         SR    R1,R8                      CALCULATE LENGTH OF NAME
         LR    R6,R1                      PUT IN PROPER REGISTER
         LA    R1,DSNML                   CALCULATE LENGTH OF
         SR    R1,R6                         BLANKS AFTER NAME
         BCTR  R1,0                       MAKE IT AN EX LENGTH
         EX    R1,CLCBLNKS                IF NOT ALL BLANKS AFTER NAME
         BNE   DSNMBD                       BAD NAME
DSNMV30  DS    0H
         MVI   TRTBL+C' ',0           RESET TRANSLATE TABLE
         MVI   TRTBL+C'.',C'.'        PUT A C'.' IN IT
DSNMLP   DS    0H
         LTR   R6,R6                  DO WHILE (LENGTHLEFT > 0)
         BZ    DSNMVX
         LR    R1,R6                    COPY LENGTHLEFT
         BCTR  R1,0                     MAKE IT AN EX LENGTH
         EX    R1,PERTRT                LOOK  FOR A '.'
         BNZ   DSNMV40                  IF NOT FOUND, THEN
         C     R6,=F'8'                   IF LENGTHLEFT > 8, THEN
         BH    DSNMBD                       MUST BE INVALID
         LTR   R6,R6                      IF LENGTHLEFT = 0, THEN
         BZ    DSNMBD                       MUST BE INVALID
         LR    R1,R6                      SET QUALIFIED LENGTH
         BCTR  R1,0                     MAKE IT AN EX LENGTH
         EX    R1,ALPHTRT               SEE IF ALL ALPHAMERICS
         BNZ   DSNMBD                   IF ALL ALPHAMERICS,
         CLI   0(R8),C'0'                 IF 1ST CHARACTER NOT NUMERIC
         BNL   DSNMBD                       MUST BE INVALID
         B     DSNMVX                     ELSE MUST BE OK
DSNMV40  DS    0H                       ELSE /* FOUND A '.' */
         LR    R5,R1                      COPY CURRENT POSITION
         SR    R1,R8                      CALCULATE QUALIFIED LENGTH
         SR    R6,R1                      CALCULATE
         BCTR  R6,0                           LENGTHLEFT
         LTR   R6,R6                      IF LENGTH LEFT = 0 OR
         BZ    DSNMBD
         C     R1,=F'8'                      QUALIFIED LENGTH > 8, THEN
         BH    DSNMBD                       BAD NAME
         LTR   R1,R1                      IF QUALIFIED LENGTH = 0, THEN
         BZ    DSNMBD                       BAD NAME
         BCTR  R1,0                       ELSE MAKE IT AN EX LENGTH
         EX    R1,ALPHTRT                   SEE IF ALL ALPHAMERICS
         BNZ   DSNMBD                       IF ALL ALPHAMERICS,
         CLI   0(R8),C'0'                     IF 1ST CHAR. NOT NUMERIC
         BNL   DSNMBD                           MUST BE BAD
         LA    R8,1(,R5)                  ELSE  GET PAST '.'
         B     DSNMLP                       AND LOOP
DSNMBD   DS    0H
         LA    R15,4                  SET BAD RC
DSNMVX   DS    0H
         DS@EXIT RET=R15
         SPACE
CLCBLNKS CLC   0(0,R5),BLANKS         EXECUTED CLC INSTRUCTION
PERTRT   TRT   0(0,R8),TRTBL          EXECUTED TRT INSTRUCTION
ALPHTRT  TRT   0(0,R8),TRTALPHM       EXECUTED TRT INSTRUCTION
         SPACE
TRTALPHM DC    256X'FF'               TRANSLATE TABLE FOR ALPHAMERICS
         ORG   TRTALPHM+C'$'             AND NATIONAL CHARACTERS
         DC    X'00'
         ORG   TRTALPHM+C'#'
         DC    XL2'00'
         ORG   TRTALPHM+C'A'
         DC    XL9'00'
         ORG   TRTALPHM+C'J'
         DC    XL9'00'
         ORG   TRTALPHM+C'S'
         DC    XL8'00'
         ORG   TRTALPHM+C'0'
         DC    XL10'00'
         ORG
         TITLE 'EDREC SUBROUTINE'
**********************************************************************
*               E D R E C          S U B R O U T I N E               *
*                                                                    *
*    THIS SUBROUTINE DOES EDIT RECOVERY IF MODE IS PDF EDIT.         *
*  IF THE USER RESPONDS WITH "END" TO EDIT RECOVERY, THEN            *
*  THIS SUBROUTINE RETURNS A RETURN CODE OF 8, AND THIS PROGRAM      *
*  SHOULD THEN END.                                                  *
*                                                                    *
**********************************************************************
         SPACE
         USING EDREC,BASE
         SPACE
EDREC    DS@ENTR ,
         SLR   R15,R15                CLEAR RETURN CODE
         CLC   WHATMODE,=AL4(PDFEDIT) IF PDF EDIT
         BNE   EDRECX
EDREC05  DS    0H
         CALL  ISPLINK,(=CL8'EDREC',=CL8'INIT'),VL,MF=(E,CALLPL)
EDRECLP  DS    0H                       QUERY EDIT RECOVERY
         CALL  ISPLINK,(=CL8'EDREC',=CL8'QUERY'),VL,MF=(E,CALLPL)
         LTR   R15,R15                  IF EDIT RECOVERY TO DO, THEN
         BZ    EDRECX                     SHOW RECOVERY PANEL
         CALL  ISPLINK,(=CL8'DISPLAY',=CL8'ISREDM02'),VL,MF=(E,CALLPL)
         LTR   R15,R15                    IF "END" ENTERED, THEN
         BZ    EDRECDF                      DEFER EDREC
         CALL  ISPLINK,(=CL8'EDREC',=CL8'DEFER'),VL,MF=(E,CALLPL)
         LA    R15,4                        SET RC
         B     EDRECX                       AND WE'RE DONE
EDRECDF  DS    0H
         CLI   ZEDCMD,C'D'                ELSE IF DEFER, THEN
         BNE   EDRECND                      DEFER IT
         CALL  ISPLINK,(=CL8'EDREC',=CL8'DEFER'),VL,MF=(E,CALLPL)
         B     EDRECX                       AND WE'RE DONE
EDRECND  DS    0H
         CLI   ZEDCMD,C'C'                ELSE IF CANCEL, THEN
         BNE   EDRECNC                      CANCEL IT
         CALL  ISPLINK,(=CL8'EDREC',=CL8'CANCEL'),VL,MF=(E,CALLPL)
         B     EDRECX                       AND WE'RE DONE
EDRECNC  DS    0H                         ELSE PROCESS IT
         CALL  ISPLINK,(=CL8'EDREC',=CL8'PROCESS'),VL,MF=(E,CALLPL)
         B     EDRECLP                      AND GO AGAIN
EDRECX   DS    0H
         DS@EXIT RET=R15
         SPACE
         DROP  BASE
         TITLE 'DETERMINE IF SINGLE MEMBER NAME SPECIFIED'
**********************************************************************
*               S I N G M E M     S U B R O U T I N E                *
*                                                                    *
*    THIS SUBROUTINE DETERMINES IF A SINGLE  MEMBER NAME WAS SPECI-  *
*  FIED.  IF SO, R15 IS RETURNED WITH A NON-ZERO VALUE.  OTHERWISE,  *
*  R15 IS RETURNED AS ZERO.                                          *
*                                                                    *
**********************************************************************
         SPACE
         USING SINGMEM,BASE
         SPACE
SINGMEM  DS    0H
         DS@ENTR ,
         SLR   R15,R15                ASSUME NOT SINGLE MEMBER NAME
         CLC   DS@MEM,BLANKS          IF MEMBER ^BLANK, THEN
         BE    SINGMEMX
         LA    R1,DS@MEM                ADDRESS MEMBER NAME PASSED
         LA    R1,L'DS@MEM-1(R1)        GET END OF THIS STRING
SINMEMLP DS    0H
         CLI   0(R1),C'*'               LOOP UNTIL '*' OR NON-BLANK
         BE    SINGMEMX                      FOUND
         CLI   0(R1),C' '
         BNE   SNMSETRC
         BCTR  R1,0
         B     SINMEMLP                 END /* LOOP */
SNMSETRC DS    0H
         LA    R15,4                    SET RETURN CODE
SINGMEMX DS    0H
         DS@EXIT RET=R15              RETURN TO CALLER
         SPACE
         DROP  BASE
         TITLE 'SETMODE SUBROUTINE'
**********************************************************************
*              S E T M O D E       S U B R O U T I N E               *
*                                                                    *
*    THIS SUBROUTINE LOOKS AT THE CHARACTER IN MODE, AND SETS THE    *
*  FIELD WHATMODE TO THE CORRESPONDING EQUATED SYMBOL.               *
*                                                                    *
**********************************************************************
         SPACE
         USING SETMODE,R15
         SPACE
SETMODE  DS    0H
         LA    R1,PDFBROW             ASSUME PDF/BROWSE
         CLI   MODE,BROWSE            IF ^ BROWSE, THEN
         BE    SETMODE5                 TRY EDIT
         LA    R1,PDFEDIT
         CLI   MODE,EDIT                IF ^ EDIT, THEN
         BE    SETMODE5                   MUST BE SCAN
         LA    R1,SCANPDS
SETMODE5 DS    0H
         ST    R1,WHATMODE            SAVE MODE OFFSET
         BR    R14
         SPACE
         DROP  R15
         TITLE 'DS@DRIVR - SET ISPF MESSAGE SUBROUTINE'
**********************************************************************
*              P U T M S G         S U B R O U T I N E               *
*                                                                    *
*    THIS SETS UP THE MESSAGE PARAMETER BLOCK AND CALLS THE MESSAGE  *
*  PROGRAM TO SET AN ISPF MESSAGE.  INPUT TO THIS ROUTINE IS R1,     *
*  WHICH CONTAINS THE ID OF THE MESSAGE.                             *
*                                                                    *
**********************************************************************
         SPACE
         USING PUTMSG,BASE
         SPACE
PUTMSG   DS@ENTR ,
         C     R1,=AL4(MAXMSG)        IF MESSAGE GREATER THAN MAX,
         BNH   *+6
         DC    H'0'                     DIE 0C1
         ST    R1,MSGID               SAVE MESSAGE IN PARM BLOCK
         LA    R2,1                   ASSUME MEMBER LIST MODE
         ST    R2,MSGTB               SET TABLE ID
         LA    R2,DS@MSGPB            ADDRESS MESSAGE PARM BLOCK
         CALL  DS@DRMSG,((R2)),VL,MF=(E,CALLPL)
         DS@EXIT ,
         SPACE
         DROP  BASE
         TITLE 'DEFINE ISPF DIALOG VARIABLES SUBROUTINE'
**********************************************************************
*              D E F V A R S       S U B R O U T I N E               *
*                                                                    *
*    THIS SUBROUTINE CYCLES THROUGHT THE NECESSARY TABLES IN ORDER   *
*  TO EFFICIENTLY ISSUE VDEFINE CALLS WITH A COPY OPTION.  INPUT TO  *
*  THIS ROUTINE IS VARTBLA, WHICH CONTAINS AN ADDRESS TO THE VARI-   *
*  ABLE TABLE ELEMENT TO BEGIN WITH, AND THE NUMBER OF ELEMENTS IN   *
*  THE TABLE TO VDEFINE.                                             *
*                                                                    *
**********************************************************************
         SPACE
         USING DEFVARS,BASE
         SPACE
DEFVARS  DS@ENTR ,
         LM    R8,R9,VARTBLA
         USING VARSTBL,R8
         LA    R2,=CL8'COPY'          SAY COPY
DVLOOP   DS    0H
         LA    R5,VARBASE ADDRESS VARIABLE BASE
         AH    R5,VVOFF               CALCULATE OUR VARIABLE ADDRESS
         LA    R6,VNAME               ADDRESS VARIABLE NAME
         LA    R3,LNGBASE             ADDRESS LENGTH BASE
         SLR   R4,R4                  CLEAR FOR IC
         IC    R4,VLNG                GET LENGTH OF VARIABLE
         LH    R1,VLOFF               GET LENGTH OFFSET
         LTR   R1,R1                  IF LENGTH OFFSET = 0, THEN
         BNZ   DV010                    WE DON'T NEED A LENGTH
         ST    R4,LNGBASE               SO USE LNGBASE FOR LENGTH
         B     DV020
DV010    DS    0H                     ELSE
         AR    R3,R1                    CALCULATE OFFSET
         ST    R4,0(R3)                 SAVE LENGTH
DV020    DS    0H
         LA    R7,=CL8'CHAR'            ASSUME CHARACTER
         TM    VFLAG,CHAR               IF NOT CHARACTER, THEN
         BO    DV030
         LA    R7,=CL8'FIXED'             TRY FIXED
         TM    VFLAG,FIXED                IF NOT FIXED, THEN
         BO    DV030
         LA    R7,=CL8'BIT'                 TRY BIT
         TM    VFLAG,BIT                    IF NOT BIT, THEN
         BO    DV030
         LA    R7,=CL8'HEX'                   TRY HEX
         TM    VFLAG,HEX                      IF NOT HEX, THEN
         BO    DV030
         DC    H'0'                             DIE 0C1
DV030    DS    0H
         TM    VFLAG,NOCOPY           IF COPY, THEN
         BO    DV040
         CALL  ISPLINK,(=CL8'VDEFINE',(R6),(R5),(R7),(R3),(R2)),VL,    +
               MF=(E,CALLPL)            ISSUE THE VDEFINE WITH COPY
         B     DV050
DV040    DS    0H
         CALL  ISPLINK,(=CL8'VDEFINE',(R6),(R5),(R7),(R3)),VL,         +
               MF=(E,CALLPL)            ISSUE THE VDEFINE (NOCOPY)
DV050    DS    0H
         LA    R8,VARSTBLL(,R8)       NEXT TABLE ENTRY
         BCT   R9,DVLOOP              AND LOOP
DVEXIT   DS    0H
         DS@EXIT ,
         SPACE
         DROP  BASE
         TITLE 'ASSIGN SAVE AREA FOR SUBROUTINE'
**********************************************************************
*              G E T S V A         S U B R O U T I N E               *
*                                                                    *
*    THIS SUBROUTINE ASSIGNS THE NEXT SAVE AREA IN THE STACK FOR THE *
*  CALLING SUBROUTINE.  THE ADDRESS OF THE 64-BYTE SAVEAREA IS RE-   *
*  TURNED IN REGISTER 1.                                             *
*    THIS ROUTINE IS COUPLED CLOSELY WITH THE DS@ENTR MACRO, AND     *
*  SHOULD ONLY BE USED IN THIS ENVIRONMENT.                          *
*                                                                    *
**********************************************************************
         SPACE
         USING GETSVA,R15
         SPACE
GETSVA   DS    0H
         L     R1,SAVADDR             GET CURRENT ADDRESS
         LTR   R1,R1                  IF THIS IS FIRST TIME
         BNZ   GETSVA1
         LA    R1,SAVSTCK               SET ADDRESS OF SAVE AREAS
         ST    R1,SAVADDR
         B     GETSVA2
GETSVA1  DS    0H                     ELSE
         LA    R1,SAVALNG(,R1)          CALCULATE NEXT SAVE AREA
         ST    R1,SAVADDR               AND SAVE IT
GETSVA2  DS    0H
         L     R0,NUMSVA              GET NUMBER OF SAVE AREAS
         AH    R0,=H'1'               INCREMENT IT
         ST    R0,NUMSVA              SAVE AWAY
         CH    R0,=AL2(SAVMAX)        IF WE HAVE EXCEEDED MAXIMUM
         BNH   *+4+2                      NESTING LEVEL
         DC    H'0'                     DIE 0C1
         BR    R14                    ELSE RETURN TO CALLER
         SPACE
         LTORG
         SPACE
         DROP  R15
         TITLE 'RETURN SAVE AREA ADDRESS, REMOVE FROM STACK'
**********************************************************************
*              F R E E S V A       S U B R O U T I N E               *
*                                                                    *
*    THIS SUBROUTINE RETURNS THE ADDRESS OF THE CURRENT SAVEAREA,    *
*  AND REMOVES IT FROM THE STACK.                                    *
*    THIS ROUTINE IS COUPLED CLOSELY WITH THE DS@ENTR MACRO, AND     *
*  SHOULD ONLY BE USED IN THIS ENVIRONMENT.                          *
*                                                                    *
**********************************************************************
         SPACE
         USING FREESVA,R15
         SPACE
FREESVA  DS    0H
         L     R1,NUMSVA              GET NUMBER ON STACK
         LTR   R1,R1                  IF ZERO, THEN
         BNZ   *+4+2
         DC    H'0'                     DIE 0C1
         BCTR  R1,0                   ELSE DECREMENT IT
         ST    R1,NUMSVA                SAVE FOR NEXT TIME
         L     R0,SAVADDR               GET CURRENT SAVE AREA ADDRESS
         LR    R1,R0                    COPY IT
         SH    R0,=AL2(SAVALNG)         CALCULATE PREVIOUS SAVEAREA
         ST    R0,SAVADDR               SAVE FOR NEXT TIME
         BR    R14                      RETURN TO CALLER
         SPACE
         LTORG
         SPACE
         DROP  R15
         TITLE 'BLANK AN AREA'
**********************************************************************
*              B L A N K I T       S U B R O U T I N E               *
*                                                                    *
*    THIS SUBROUTINE SIMPLY BLANKS A SPECIFIED AREA.  INPUT TO THE   *
* ROUTINE IS R1, WHICH CONTAINS THE ADDRESS OF THE AREA TO BLANK,    *
* R2, WHICH CONTAINS THE LENGTH OF THE AREA (MAY BE MORE THAN 256    *
* BYTES OF COURSE).  THE FIELD "BLANKS" IN THE DSA IS A FIELD OF     *
* 256 BYTES OF C' ' AND MUST BE INITIALIZED TO THIS BEFORE CALLING   *
* THIS ROUTINE.  THIS ROUTINE DOES NOT SAVE/RESTORE ANY REGISTERS,   *
* AND THEREFORE DOES NOT GUARANTEE THE VALUES IN REGISTER R0 - R3.   *
*                                                                    *
**********************************************************************
         SPACE
         USING BLANKIT,R15
         SPACE
BLANKIT  DS    0H
         LA    R3,255                 PUT CONSTANT IN REGISTER
BLNKITLP DS    0H
         CH    R2,=H'256'             IF > THAN 256, THEN
         BNH   BLNKLPX
         EX    R3,BLNKMVC               GO AHEAD AND BLANK 256
         LA    R1,1(R3,R1)              AHEAD 256 BYTES
         SR    R2,R3                    LESS 256 IN LENGTH
         BCTR  R2,0
         B     BLNKITLP                 AND LOOP
BLNKLPX  DS    0H
         BCTR  R2,0                   GET LENGTH FOR EX
         EX    R1,BLNKMVC             BLANK IT
BLANKITX DS    0H
         BR    R14
         SPACE
BLNKMVC  MVC   0(0,R1),BLANKS         MVC SKELTON FOR EX INSTRUCTION
         SPACE
         LTORG
         DROP  R15
         TITLE 'STATIC DEFINITIONS'
**********************************************************************
*       V A R I A B L E    T A B L E    F O R   D S @ S C P D S      *
**********************************************************************
         SPACE
VARSCPDS DC    AL2(DS@DSN1-VARBASE),AL2(0)
         DC    AL1(L'DS@DSN1),AL1(CHAR+NOCOPY),CL8'DS@DSN1'
         DC    AL2(DS@DSN2-VARBASE),AL2(0)
         DC    AL1(L'DS@DSN2),AL1(CHAR+NOCOPY),CL8'DS@DSN2'
         DC    AL2(DS@DSN3-VARBASE),AL2(0)
         DC    AL1(L'DS@DSN3),AL1(CHAR+NOCOPY),CL8'DS@DSN3'
         DC    AL2(DS@DSN4-VARBASE),AL2(0)
         DC    AL1(L'DS@DSN4),AL1(CHAR+NOCOPY),CL8'DS@DSN4'
         DC    AL2(DS@MEM-VARBASE),AL2(0)
         DC    AL1(L'DS@MEM),AL1(CHAR+NOCOPY),CL8'DS@MEM'
         DC    AL2(DS@VOL-VARBASE),AL2(0)
         DC    AL1(L'DS@VOL),AL1(CHAR+NOCOPY),CL8'DS@VOL'
         DC    AL2(DS@MIX-VARBASE),AL2(0)
         DC    AL1(L'DS@MIX),AL1(CHAR+NOCOPY),CL8'DS@MIX'
         DC    AL2(DS@FNAM-VARBASE),AL2(0)
         DC    AL1(L'DS@FNAM),AL1(CHAR+NOCOPY),CL8'DS@FNAM'
         DC    AL2(DS@PROF-VARBASE),AL2(0)
         DC    AL1(L'DS@PROF),AL1(CHAR+NOCOPY),CL8'DS@PROF'
         DC    AL2(DS@IMAC-VARBASE),AL2(0)
         DC    AL1(L'DS@IMAC),AL1(CHAR+NOCOPY),CL8'DS@IMAC'
         DC    AL2(DS@MODE-VARBASE),AL2(0)
         DC    AL1(L'DS@MODE),AL1(CHAR+NOCOPY),CL8'DS@MODE'
         DC    AL2(DS@UOP-VARBASE),AL2(0)
         DC    AL1(L'DS@UOP),AL1(CHAR),CL8'DS@UOP'
         DC    AL2(DS@USER-VARBASE),AL2(0)
         DC    AL1(L'DS@USER),AL1(CHAR),CL8'DS@USER'
         DC    AL2(DS@SCOP-VARBASE),AL2(0)
         DC    AL1(L'DS@SCOP),AL1(CHAR),CL8'DS@SCOP'
         DC    AL2(DS@LVL-VARBASE),AL2(0)
         DC    AL1(L'DS@LVL),AL1(FIXED),CL8'DS@LVL'
         DC    AL2(DSNAME-VARBASE),AL2(0)
         DC    AL1(L'DSNAME),AL1(CHAR+NOCOPY),CL8'DS@ERRNM'
VARSCPD# EQU   (*-VARSCPDS)/VARSTBLL
         SPACE 2
**********************************************************************
*       V A R I A B L E    T A B L E    B R O W S E / E D I T        *
**********************************************************************
         SPACE
VARSBE   DC    AL2(ZODSN-VARBASE),AL2(0)
         DC    AL1(L'ZODSN),AL1(CHAR+NOCOPY),CL8'ZODSN'
         DC    AL2(ZOVOL-VARBASE),AL2(0)
         DC    AL1(L'ZOVOL),AL1(CHAR+NOCOPY),CL8'ZOVOL'
         DC    AL2(PRJ1-VARBASE),AL2(0)
         DC    AL1(L'PRJ1),AL1(CHAR),CL8'PRJ1'
         DC    AL2(LIB1-VARBASE),AL2(0)
         DC    AL1(L'LIB1),AL1(CHAR),CL8'LIB1'
         DC    AL2(TYP1-VARBASE),AL2(0)
         DC    AL1(L'TYP1),AL1(CHAR),CL8'TYP1'
         DC    AL2(LIB2-VARBASE),AL2(0)
         DC    AL1(L'LIB2),AL1(CHAR),CL8'LIB2'
         DC    AL2(LIB3-VARBASE),AL2(0)
         DC    AL1(L'LIB3),AL1(CHAR),CL8'LIB3'
         DC    AL2(LIB4-VARBASE),AL2(0)
         DC    AL1(L'LIB4),AL1(CHAR),CL8'LIB4'
         DC    AL2(ZMEM-VARBASE),AL2(0)
         DC    AL1(L'ZMEM),AL1(CHAR),CL8'ZMEM'
         DC    AL2(PROF-VARBASE),AL2(0)
         DC    AL1(L'PROF),AL1(CHAR),CL8'PROF'
         DC    AL2(IMAC-VARBASE),AL2(0)
         DC    AL1(L'IMAC),AL1(CHAR),CL8'IMAC'
         DC    AL2(FNAME-VARBASE),AL2(0)
         DC    AL1(L'FNAME),AL1(CHAR),CL8'FNAM'
         DC    AL2(MIX-VARBASE),AL2(0)
         DC    AL1(L'MIX),AL1(CHAR),CL8'MIX'
         DC    AL2(TRACE-VARBASE),AL2(0)
         DC    AL1(L'TRACE),AL1(CHAR),CL8'TRACE'
VARSBE#  EQU   (*-VARSBE)/VARSTBLL
         SPACE 2
**********************************************************************
*           V A R I A B L E    T A B L E    S C A N P D S            *
**********************************************************************
         SPACE
VARSSCAN DC    AL2(ZODSN-VARBASE),AL2(0)
         DC    AL1(L'ZODSN),AL1(CHAR+NOCOPY),CL8'ZODSN'
         DC    AL2(ZOVOL-VARBASE),AL2(0)
         DC    AL1(L'ZOVOL),AL1(CHAR+NOCOPY),CL8'ZOVOL'
         DC    AL2(PRJ1-VARBASE),AL2(0)
         DC    AL1(L'PRJ1),AL1(CHAR),CL8'PRJ1'
         DC    AL2(LIB1-VARBASE),AL2(0)
         DC    AL1(L'LIB1),AL1(CHAR),CL8'LIB1'
         DC    AL2(TYP1-VARBASE),AL2(0)
         DC    AL1(L'TYP1),AL1(CHAR),CL8'TYP1'
         DC    AL2(LIB2-VARBASE),AL2(0)
         DC    AL1(L'LIB2),AL1(CHAR),CL8'LIB2'
         DC    AL2(TYP2-VARBASE),AL2(0)
         DC    AL1(L'TYP2),AL1(CHAR),CL8'TYP2'
         DC    AL2(LIB3-VARBASE),AL2(0)
         DC    AL1(L'LIB3),AL1(CHAR),CL8'LIB3'
         DC    AL2(LIB4-VARBASE),AL2(0)
         DC    AL1(L'LIB4),AL1(CHAR),CL8'LIB4'
         DC    AL2(ZMEM-VARBASE),AL2(0)
         DC    AL1(L'ZMEM),AL1(CHAR),CL8'ZMEM'
         DC    AL2(TRACE-VARBASE),AL2(0)
         DC    AL1(L'TRACE),AL1(CHAR),CL8'TRACE'
VARSCAN# EQU   (*-VARSSCAN)/VARSTBLL
         SPACE 2
**********************************************************************
*          M I S C E L L A N E O U S     V A R I A B L E S           *
**********************************************************************
         SPACE
VARSMISC DC    AL2(ZPREFIX-VARBASE),AL2(0)
         DC    AL1(L'ZPREFIX),AL1(CHAR),CL8'ZPREFIX'
         DC    AL2(TRACE-VARBASE),AL2(0)
         DC    AL1(L'TRACE),AL1(CHAR),CL8'TRACE'
         DC    AL2(ZEDCMD-VARBASE),AL2(0)
         DC    AL1(L'ZEDCMD),AL1(CHAR+NOCOPY),CL8'ZEDCMD'
         DC    AL2(ZCMD-VARBASE),AL2(0)
         DC    AL1(L'ZCMD),AL1(CHAR+NOCOPY),CL8'ZCMD'
VARMISC# EQU   (*-VARSMISC)/VARSTBLL
         SPACE
         SPACE
**********************************************************************
*          M I S C E L L A N E O U S     E Q U A T E S               *
**********************************************************************
         SPACE
MSG1     EQU   1
MSG2     EQU   2
MSG3     EQU   3
MSG4     EQU   4
MAXMSG   EQU   MSG4
         END   DS@DRIVR
