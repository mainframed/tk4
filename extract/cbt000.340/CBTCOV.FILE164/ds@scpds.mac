DS@SCPDS TITLE 'DS@SCPDS - SCAN PDS/MEMBER LIST'
         LCLA  &NUMBUFF
&NUMBUFF SETA 5             *** NUMBER OF BUFFERS USED FOR MULTI-
*                           ***  BUFFERING.  TO CHANGE, JUST PUT
*                           ***  NEW VALUE HERE AND REASSEMBLE. NOTE:
*                           ***  THIS VALUE IS USED FOR BUFFERS TO
*                           ***  READ THE PDS DIRECTORY.  FOR BUFFERS
*                           ***  TO READ PDS MEMBERS (SCAN), THIS
*                           ***  NUMBER IS DOUBLED.
*
***********************************************************************
*  PROGRAM-ID: DS@SCPDS (FORMERLY SCANPDS)                            *
*  FUNCTION:                                                          *
*      This program builds a PDS Member List Screen for ISPF display, *
*      and then processes member commands for the user.  The commands *
*      include Edit, Browse, Rename, Delete and Print.   The program  *
*      was written for the Scan PDS Function, and as such, certain    *
*      parameters (ISPF Dialog variables) are needed for this func-   *
*      tion.  Members are placed into the table if they meet the      *
*      selection criteria based on these parameters, which are the    *
*      member name (which could be in the form NAME*), the USERID     *
*      (last one to update the member), a character string to be      *
*      found in the member, and the number of members to put in the   *
*      table for display if scanning for a character string.          *
*        These parameters may form a subset of the PDS Members to     *
*      display.  However, if the Member Name, USERID and SCAN String  *
*      copied are all blank, then all of the PDS Members are selected *
*      for display.  In this manner, the program can be used to per-  *
*      form a general PDS Member List, and process the various com-   *
*      mands.  That is, simply set DSN1 and USERID in the Shared      *
*      Varible pool, and SELECT this program.                         *
*                                                                     *
*  REGISTER USAGE:                                                    *
*      R0 - R10 as general work registers                             *
*      R11 - Base for DSTBL                                           *
*      R12 - Base Register                                            *
*      R13-R15 Standard Usage                                         *
*                                                                     *
*  RETURN CODES:                                                      *
*      The program always returns 0, but an ISPF Message is set for   *
*      any errors encountered.  However, if this program is invoked   *
*      with mode B or E, and it is for a single PDS member or a PS    *
*      dataset, then the return code returned is the one from the     *
*      Browse/Edit service.                                           *
*                                                                     *
*  RESTRICTIONS:                                                      *
*      This dialog application requires Version 2 or later of ISPF.   *
*                                                                     *
* AUTHOR:   Phil Herold, Systems Developer                            *
*           SAS Institute                                             *
*           Cary, NC                                                  *
*                                                                     *
* NOTE:  SAS Institute is not responsible for the support of this     *
*        program--please do NOT call SAS Institute Technical Support. *
*        However, the author will be glad to provide any assistance   *
*        needed.                                                      *
*                                                                     *
*                                                                     *
* ACKNOWLEDGEMENT:  This program was originally developed at First    *
*                   Computer Services, Charlotte, North Carolina, and *
*                   was modified for use in the environment in which  *
*                   it now runs.  The author would like to especially *
*                   thank Dave LaSalle for his support and encourage- *
*                   ment.                                             *
*                                                                     *
***********************************************************************
         COPY  DS@MACS
         TITLE 'OTHER EQUATES'
***********************************************************************
*                  O T H E R    E Q U A T E S                         *
***********************************************************************
         SPACE
FLAGON   EQU   C'1'                   FLAG IS ON
FLAGOFF  EQU   C'0'                   FLAG IS OFF
         SPACE
MINDELAY EQU   5                      MINIMUM DELAY IN SECONDS
DEFDELAY EQU   20                     DEFAULT DELAY IN SECONDS
BUFFNO   EQU   &NUMBUFF               NUMBER OF BUFFERS
         TITLE 'DSECTS'
**********************************************************************
*                       D S E C T S                                  *
**********************************************************************
         SPACE
MEMENTRY DSECT
MEMNAME  DS    CL8                    MEMBER NAME
TTR      DS    XL3                    DASD ADDRESS
CFIELD   DS    X
USRDATA  DS    XL62
         ORG   USRDATA            *** ISPF STATISTICS
UDVERMOD DS    H                      VER/MOD PART OF USER DATA
UDFILL1  DS    H
UDFILL2  DS    X
UDCRTDT  DS    PL3                    DATE MEMBER CREATED
UDFILL3  DS    X
UDLMDT   DS    PL3                    DATE MEMBER LAST MODIFIED
UDLMTM   DS    H                      TIME MEMBER LAST MODIFIED
UDSIZE   DS    H                      SIZE OF MEMBER
UDINIT   DS    H                      INITIAL SIZE OF MEMBER
UDMOD    DS    H                      NUMBER OF LINES MODIFIED
UDUSER   DS    CL10                   USERID
         ORG   USRDATA            *** LOAD MODULE STATISTICS
UDSTRT   DS    XL4                    TTR OF FIRST TEXT BLOCK
UDNOTE   DS    XL3                    TTR OF NOTELIST
UDNOTE#  DS    X                      NUMBER OF NOTELIST ENTRIES
UDATTR   DS    X                      LOAD MODULE ATTRIBUTE BYTE 1
ATTRRN   EQU   B'10000000'              REENTRANT
ATTRRU   EQU   B'01000000'              REUSABLE
ATTROV   EQU   B'00100000'              OVERLAY
ATTRTS   EQU   B'00010000'              TEST SYMBOLS AVAIL
ATTROL   EQU   B'00001000'              ONLY LOADABLE
ATTRSC   EQU   B'00000100'              SCATTER LOADED
ATTREX   EQU   B'00000010'              EXECUTABLE
ATTRTX   EQU   B'00000001'              1 TEXT RECORD, NO RLD ITEMS
UDATTR1  DS    X                      LOAD MODULE ATTRIBUTE BYTE 2
ATTRDC   EQU   B'10000000'              NOT DOWNWARD-COMPATIBLE
ATTRZO   EQU   B'01000000'              1ST TEXT BLOCK HAS ZERO ORIGIN
ATTRP0   EQU   B'00100000'              ENTRY POINT IS OFFSET ZERO
ATTRNR   EQU   B'00010000'              NO RLD
ATTRNE   EQU   B'00001000'              ^ REPROCESSABLE BY LKED
ATTRSY   EQU   B'00000100'              CONTAINS TEST SYMBOLS
ATTRFL   EQU   B'00000010'              CREATED BY F-LEVEL LKED
ATTRRF   EQU   B'00000001'              REFRESHABLE
UDSIZEH  DS    XL3                    SIZE (HEX) OF LOAD MODULE
UDTEXTL  DS    XL2                    LENGTH OF 1ST TEXT RECORD
UDEPA    DS    XL3                    ENTRY POINT ADDRESS
UDATTR2  DS    X                      LOAD MODULE ATTRIBUTE BYTE 3
ATTROSLE EQU   B'10000000'              VS LKED CREATED THIS MODULE
ATTRPAGA EQU   B'00100000'              PAGE ALIGNMENT NEEDED
ATTRSSI  EQU   B'00010000'              SSI INFO PRESENT FOR MODULE
ATTRAPF  EQU   B'00001000'              APF INFO FOR MODULE IS VALID
UDATTR3  DS    X                        LOAD MODULE ATTRIBUTE BYTE 4
ATTRR31  EQU   B'00010000'              RMODE IS 31
ATTRA31  EQU   B'00000010'              AMODE IS 31
UDATTR4  DS    X                        LOAD MODULE ATTRIBUTE BYTE 5
UDAPF    DS    0XL2                     APF (IF NOT SCAT, SSI, ALIAS)
UDEP     DS    XL3                      ENTRY POINT (REAL MEMBER)
UDREAL   DS    CL8                      REAL NAME OF MEMBER
UDAPF2   DS    XL2                      APF (IF NOT SCAT, SSI, ALIAS)
         ORG   UDAPF                *** FOR SCATTER LOAD MODULES
UDSCLL   DS    XL2                      LENGTH OF SCATTER LIST
UDSCTL   DS    XL2                      LENGTH OF TRANSLATE TABLE
UDSCET   DS    XL2                      ESDID OF 1ST TEXT RECORD
UDSCEP   DS    XL2                      ESDID OF ENTRY POINT
UDAPF3   DS    0XL2                     APF (IF SCAT, NO SSI, NO ALIAS)
UDEPSC   DS    XL3                      ENTRY POINT (REAL MEMBER)
UDREALS  DS    CL8                      REAL NAME OF MEMBER
UDAPF4   DS    XL2                      APF INFO (SCAT, NO SSI, ALIAS)
         SPACE 2
         DS@VRSTB ,
         TITLE 'TABLE AND CMDTBL DSECTS'
**********************************************************************
*                      T A B L E     D S E C T                       *
**********************************************************************
         SPACE
TABLE    DSECT
TBLNAME  DC    CL8' '                   NAME OF TABLE
NUMMEM   DC    F'0'                     NUMBER OF MEMBERS IN TABLE
SKIPNUM  DC    F'0'                     CURRENT TOP ROW OF TABLE
TABLEL   EQU   *-TABLE                  LENGTH OF DSECT
         USING TABLE,R2
         SPACE
**********************************************************************
*                    C M D T B L     D S E C T                       *
**********************************************************************
         SPACE
CMDTBL   DSECT
CMDNAME  DC    CL8' '                 COMMAND NAME
CMDADDR  DC    A(0)                   COMMAND PROCCESSOR ADDRESS
CMDOPS   DC    AL2(0)                 NUMBER OF OPERANDS FOR COMMAND
CMDFLAGS DC    AL2(0)                 FLAG BYTES
         ORG   CMDFLAGS+1
CMDFLAG  DC    AL1(0)                 FLAG BYTE
CMDLONLY EQU   B'10000000'              ONLY VALID FROM COMMAND LINE
MEMNREQ  EQU   B'01000000'              MEMBER NAME REQUIRED
GENMEM   EQU   B'00100000'              GENERIC MEMBER NAME ALLOWED
NEWMEM   EQU   B'00010000'              MEMBER CAN BE NEW
OGENPRC  EQU   B'00001000'              COMMAND DOES OWN GENERIC PRC.
CMDTBLL  EQU   *-CMDTBL
         SPACE
         USING CMDTBL,R6
         TITLE 'SYSTEM CONTROL BLOCK MAPPINGS'
**********************************************************************
*             S Y S T E M     C O N T R O L    B L O C K S           *
**********************************************************************
         SPACE
         PRINT NOGEN
JCFBNDS  DSECT
         IEFJFCBN LIST=NO             JFCB MAPPING
         PRINT GEN
         EJECT
**********************************************************************
*           D A T A S E T      T A B L E     D S E C T               *
*                                                                    *
*   NOTE: CHANGES HERE SHOULD ALSO BE MADE AT LABEL "DSNM", WHICH IS *
*         THE MASK USED TO INITIALIZE THE TABLE IN THE DSA.          *
*                                                                    *
**********************************************************************
         SPACE
DSTBL    DSECT
DSNAME@  DS    A                      ADDRESS OF DATASET NAME
DSNLNG   DS    F                      LENGTH OF DATA SET NAME
DDNAME1  DS    CL8                    DDNAME TO READ DIRECTORY
DDNAME2  DS    CL8                    DDNAME TO READ MEMBER
DSVOL    DS    CL6                    VOLUME DATASET RESIDES ON
DIRSFB   DS    A                      SPAM FILE BLOCK PTR FOR DIRECTORY
SCNSFB   DS    A                      SPAM FILE BLOCK PTR FOR SCANNING
MEMSFB   DS    A                        "   "     "    "   "  MEMBER
DIRPTR   DS    A                      OFFSET WITH BLOCK TO CURRENT DIR
BLKCNT   DS    H                      RESIDUAL DIRECTORY BLOCK COUNT
DIRBLKU  DS    H                      NUMBER OF USED DIRECTORY BLOCKS
DIRBLKM  DS    H                      MAX DIRECTORY BLOCKS
MEMCNT   DS    H                      NUMBER OF MEMBERS
LIB#     DS    C                      LIBRARY NUMBER
FLAG     DS    X                      BYTE FOR FLAGS
ALCBSAM  EQU   B'10000000'            ALLOCATED FOR BSAM (READ DIR)
ALCBPAM  EQU   B'01000000'            ALLOCATED FOR BPAM (UPDATE)
GETBLK   EQU   B'00100000'            INDICATES PHYSICAL I/O REQUIRED
EOFDSL   EQU   B'00010000'            INDICATES LOGICAL EOF ON DIR.
EOFDSP   EQU   B'00001000'            INDICATES PHYSICAL EOF ON DIR.
OPNBSAM  EQU   B'00000100'            INDICATES DIR OPEN (BSAM)
OPNBPAM  EQU   B'00000010'            INDICATES PDS OPEN (BPAM)
OPNSCAN  EQU   B'00000001'            OPEN FOR SCANNING
FLAG2    DS    X                      2ND FLAG BYTE
RECFMU   EQU   B'10000000'            RECORD FORMAT IS U
         TITLE 'DSA DEFINITIONS'
***********************************************************************
*                   D S A      D E F I N I T I O N S                  *
***********************************************************************
         SPACE
DS@SCPDD DSECT
SAVEAREA DC    18F'0'
RECADDR  DC    F'0'                   ADDRESS OF LOGICAL RECORD READ
TIMEVAL  DC    F'0'                   DELAY INTERVAL (IN SECONDS)
VARTBLA  DC    2A(0)                  PARM LIST FOR VARIABLE SUBR.
DSAZAP   DC    4F'0'                  EXTRA DSA SPACE FOR ZAPS
DS@14TO1 DC    4F'0'                  TEMPORARY SAVE AREA
DS@14T1L EQU   *-DS@14TO1             LENGTH OF ABOVE
TOKPTR   DC    F'0'
TOD      DC    F'0'                   TIME OF DAY
CURDSN   DC    F'0'                   CURRENT ELEMENT IN DSTBL
GETSVA@  DC    A(0)                   ADDRESS OF GETSVA ROUTINE
FREESVA@ DC    A(0)                   ADDRESS OF FREESVA ROUTINE
DSTABL@  DC    A(0)                   DATA SET TABLE
PNLTBL@  DC    A(0)                   COMMAND TABLE ADDRESS
CMDTBL@  DC    A(0)                   COMMAND TABLE ADDRESS
TRTBL@   DS    A(0)                   ADDRESS OF TRT TABLE
JFCBA@   DS    A(0)                   FEEDBACK AREA
RACRWRK@ DC    A(0)                   RACROUTE WORK AREA ADDRESS
INPSFB   DC    A(0)                   INPUT FILE BLOCK POINTER
CMDTBL#  DC    F'0'                   COMMAND TABLE NUMBER OF ELEMENTS
CCLOCK   DC    D'0'                   CURRENT CLOCK VALUE
CLOCK    DC    D'0'                   CLOCK VALUE
STTIME   DC    F'0'                   STARTING TIME FOR SCAN
TXCNT    DC    F'0'                   TRANSACTION COUNT
FTXCNT   DC    F'0'                   TRANSACTION COUNT FOR FIND CMD
EDBRRC   DC    F'0'                   RETURN CODE FROM EDIT/BROWSE
         SPACE
DSAPATCH DC    4D'0'                  PATCH AREA IN DSA
         SPACE
RCSAVE   DC    H'0'                   ISPF RETURN CODE SAVE AREA
HALF0    DC    H'0'                   NUMERIC CONSTANT
LNGSCAN  DC    H'0'                   LENGTH OF SCAN STRING PASSED
NUMDS    DC    H'1'                   NUMBER OF DATA SETS
LNGMEM   DC    H'0'                   LENGTH OF MEMBER NAME PASSED
LNGUID   DC    H'0'                   LENGTH OF USERID PASSED
REFSKIP  DC    H'0'                   REFRESH SCREEN FOR STAT SHOW
STOPNUM  DC    F'0'                   NUMBER TO STOP AFTER HAVING FOUND
BND1     DC    H'0'                   COLUMN 1 BOUNDARY FOR SEARCH
BND2     DC    H'0'                   COLUMN 2 BOUNDARY FOR SEARCH
         SPACE
VERMOD   DS    XL2                    AREA FOR VERMOD CONVERSION
TIME     DS    XL2                    AREA FOR TIME CONVERSION
SIZE     DS    XL2                    AREA FOR SIZE CONVERSION
         SPACE
BLANKS   DC    CL256' '               AREA FOR BLANKS USED IN VARIOUS
CNVWORK  DC    D'0'                   WORK AREA FOR CONVERT ROUTINE
SIZEWORK DC    XL9'0'                 WORK AREA FOR CONVSIZE ROUTINE
CPYDSNAM DC    CL44' '                COPY DATA SET NAME
CPYDDNAM DC    CL8' '                 DDNAME ALLOCATED FOR COPY
         SPACE
MVCSTAT  MVC   0(0,R13),0(R13)
         SPACE
STAXUADR DC    A(STAXFLAG)
STAXFLAG DC    X'00'
         SPACE
TBSRTBUF DC    CL60' '
         ORG   TBSRTBUF
TBSORT   DC    CL8'TBSORT '
NAMETBL  DC    CL8' '
         DC    C' FIELDS('
SORTFLD1 DC    CL8' '
         DC    C',C,'
SORTOP1  DC    C'A'
         DC    C','
SORTFLD2 DC    CL8' '
         DC    C',C,'
SORTOP2  DC    C'A'
         DC    C')'
         ORG
         DS    0H
MAXTBLNM EQU   12                     MAX NUMBER OF TABLE NAMES
NUMTBLNM DC    F'0'                   CURRENT NUMBER OF TABLE NAMES
CURTBLNM DC    A(0)                   ADDRESS OF CURRENT TABLE NAME
TBLNAMES DS    0H
         ORG   (*+(MAXTBLNM*TABLEL))
         SPACE
TBPANEL  DC    CL8' '
         SPACE
RACFERRM DC    C'RACF Authorization Failed For '
RACFERRD DC    CL44' '
AUTOSEL  DC   CL8'NO'                 AUTOSEL OPTION
         SPACE
BLDLIST  DS    0H                     BLDLIST FOR BLDL MACRO
BLDNAME  DC    CL8' '                 MEMBER NAME
BLDTTR   DC    XL3'0'                 TTR FIELD
BLDK     DC    X'0'                   K FIELD
BLDZ     DC    X'0'                   Z FIELD
BLDC     DC    X'0'                   C FIELD
USERDATA DS    0X                     USER DATA IN DIRECTORY
BLVERMOD DS    H                        VER/MOD PART OF USER DATA
         DS    H                        FILLER
BLCRTDT  DS    PL4                      DATE MEMBER CREATED
BLLMDT   DS    PL4                      DATE MEMBER LAST MODIFIED
BLLMTM   DS    H                        TIME MEMBER LAST MODIFIED
BLSIZE   DS    H                        SIZE OF MEMBER
BLINIT   DS    H                        INITIAL SIZE OF MEMBER
BLMOD    DS    H                        NUMBER OF LINES MODIFIED
BLUSER   DS    CL10                     USERID
BLDLISTL EQU   *-BLDLIST-1            LENGTH FOR SPAM FEEDBACK AREA
BLDLUPDL EQU   *-BLDC-2               LENGTH FOR UPDMEM ROUTINE
         SPACE
         DS    0F
SVC99RB  DC    X'80',AL3(0)           SVC 99 REQUEST BLOCK POINTER
         SPACE
REQBLK   DS    0D                     SVC 99 REQUEST BLOCK
RBLN     DC    AL1(20)
RBVERB   DC    AL1(3)
RBFLAG1  DC    AL2(0)
RBERROR  DC    XL2'0'
RBINFO   DC    XL2'0'
RBTXTPP  DC    A(0)
RBRSVD   DC    F'0'
RBFLAG2  DC    F'0'
         SPACE
CTUPTR   DC    A(0)
         SPACE
CTUDDNAM DC    AL2(1),AL2(0),AL2(8),CL8' ',AL2(8),CL8' ',AL2(8),CL8' ',+
               AL2(8),CL8' '
         SPACE
         PRINT NOGEN
SPAMPL   CALL  ,(,),MF=L              SPAM PARAMETER LIST
CALLPL   CALL  ,(,,,,,,,,,,,,),MF=L   CALL PARAMETER LIST
CALLPLL  EQU   *-CALLPL               LENGTH OF ABOVE
         SPACE
STAXPL   STAX  0,DEFER=NO,USADDR=0,MF=L MASK FOR STAX
         SPACE
RACHKRPL RACROUTE ENTITY=0,VOLSER=0,CLASS='DATASET',ATTR=READ,DSTYPE=N,+
               REQUEST=AUTH,MF=L
RACHKUPL RACROUTE ENTITY=0,VOLSER=0,CLASS='DATASET',ATTR=UPDATE,       +
               REQUEST=AUTH,DSTYPE=N,MF=L
         SPACE
SAVSEL   DC    CL3' '
         SPACE 2
         DS    0F
WORD0L   DC    AL4(0)                 LENGTH OF 0TH WORD (COMMAND)
WORD1L   DC    AL4(0)                 LENGTH OF 1ST WORD PARSED
WORD2L   DC    AL4(0)                 LENGTH OF 2ND WORD PARSED
WORD3L   DC    AL4(0)                 LENGTH OF 3RD WORD PARSED
WORD4L   DC    AL4(0)                 LENGTH OF 4TH WORD PARSED
WORDLL   EQU   *-WORD0L
         SPACE
WORD0    DC    CL40' '                COMMAND LINE COMMAND
WORD1    DC    CL40' '                OPERANDS
WORD2    DC    CL40' '
WORD3    DC    CL40' '
WORD4    DC    CL40' '
WORDQL   EQU   *-WORD0
         TITLE 'DIALOG VARIABLE STORAGE DEFINITIONS'
**********************************************************************
*   D I A L O G    D E F I N I T I O N S   --   V A R I A B L E S    *
**********************************************************************
         SPACE
VARBASE  DS    0F
DSN1     DC    CL44' '                FIRST DATA SET NAME
DSNAMEL  EQU   *-DSN1                 LENGTH OF A DATA SET NAME
DSN2     DC    CL44' '                2ND DATA SET NAME
DSN3     DC    CL44' '                3RD DATA SET NAME
DSN4     DC    CL44' '                4TH DATA SET NAME
MEMBER   DC    CL8' '                 MEMBER NAME GOTTEN
DSNAMELL EQU   *-DSN1                 LENGTH OF ALL DSNAMES
VOL1     DC    CL6' '                 VOLUME SERIAL PASSED
USERID   DC    CL8' '                 USERID OF USER FOR SEARCH
ZPREFIX  DC    CL8' '                 PREFIX FOR USER
SCANSTR  DC    CL40' '                SCAN STRING PASSED
STP      DC    CL3' '                 STOP OPTION PASSED
SCOL1    DC    CL4'    '              SEARCH COLUMN 1 PASSED
SCOL2    DC    CL4'    '              SEARCH COLUMN 2 PASSED
DELAY    DC    CL5' '                 SECONDS FOR TIMER INTERVAL
USEROP   DC    C' '                   USER OPTION; Y = USE USER
SCOP     DC    C' '                   SCAN OPTION
MODE     DC    C' '                   B=BROWSE, E=EDIT, OTHER=SCAN
CASE     DC    C' '                   CASE OPTION
WSP      DC    C' '                   WORD, SUFFIX, PREFIX OPTION
         DS    0F
DS@LVL   DC    F'0'                   LEVEL
TRACE    DC    CL8' '                 TRACE OPTION
MIX      DC    CL3' '                 DBCS MIX (YES OR NO) - ISPF V2
FNAM     DC    CL8' '                 DBCS FORMAT NAME - ISPF V2
MAC      DC    CL8' '                 INITIAL MACRO NAME - ISPF V2
PROF     DC    CL8' '                 PROFILE NAME
ERRFIELD DC    CL80' '                ERROR MSG. FIELD FOR ALLOC. ERRS
         SPACE
INITVLNG EQU  *-DSN1                  LENGTH TO BLANK OUT
         SPACE
SAVDSNMS DC    CL(DSNAMELL)' '        PLACE TO SAVE DATASET NAMES
SAVDSNML DC    4F'0'                  SAVE DATASET NAME LENGTHS HERE
         DS    0F
*                                 *** LENGTH OF VARIABLES VCOPIED
*                                 *** TABLE VARIABLES FOLLOW
TBSEL    DC    CL3' '                 SELECT OPTION
TBMEM    DC    CL8' '                 MEMBER NAME
TBSTAT   DC    CL8' '                 STATUS FIELD
TBLIB#   DC    C' '                   LIBRARY NUMBER
TBTTR    DC    CL6' '                 PRINTABLE TTR FOR MEMBER
         DS    X                      BYTE FOR UNPACKING
TBTTRX   DC    XL3'0'                 HEX TTR
TBVERMOD DC    CL5' '                 VER AND MOD OF MEMBER
TBCRTED  DC    CL8' '                 DATE MEMBER CREATED
TBLMDT   DC    CL8' '                 LAST MODIFY DATE
TBLMDTJ  DC    PL3'0'                 JULIAN DATE
TBLMTMB  DC    XL2'0'                 LAST MODIFY TIME (BINARY)
TBLMED   DC    C' '
TBLMTM   DC    CL5' '                 LAST MODIFY TIME
TBSIZE   DC    CL5' '                 CURRENT SIZE OF MEMBER
TBISIZE  DC    CL5' '                 INIT SIZE OF MEMBER
TBMOD    DC    CL5' '                 NUMBER OF MODIFIED LINES
TBUSERID DC    CL8' '                 USERID OF OWNER
         SPACE
         ORG   TBVERMOD           *** TABLE VARIABLES FOR RECFM=U ***
         DC    C' '                   BYTE FOR UNPK INSTRUCTION
TBSIZEK  DC    CL4' '                 SIZE OF LOAD MODULE (K)
         DC    C' '                   BYTE FOR ED INSTRUCTION
TBALIAS  DC    CL8' '                 MODULE ALIAS
TBMODE   DC    CL3' '                 AMODE/RMODE INDICATOR
TBEPA    DC    CL6' '                 ENTRY POINT ADDRESS
         DC    X'0'                   BYTE FOR UNPK
TBEPAX   DC    D'0'                   ENTRY POINT ADDRESS (PACK DEC)
         DC    X'0'                   EXTRA BYTE FOR UNPK
TBATTR   DC    CL20' '                MODULE ATTRIBUTES
         ORG   TBATTR
TBRN     DC    CL2' '                   REENTRANT   ("RN")
         DC    C' '
TBRU     DC    CL2' '                   REUSABLE    ("RU")
         DC    C' '
TBRF     DC    CL2' '                   REFRESHABLE ("RF")
         DC    C' '
TBOV     DC    CL2' '                   OVERLAY     ("OV")
         DC    C' '
TBOL     DC    CL2' '                   LOAD ONLY   ("OL")
         DC    C' '
TBNX     DC    CL2' '                   ^NOT EXEC   ("NX")
         DC    C' '
TBTS     DC    CL2' '                   TEST        ("TS")
TBSSI    DC    CL8' '
         DC    C' '                   BYTE FOR UNPK INSTRUCTION
         ORG
LTBLSHRT EQU  *-TBLIB#
LTBLSHR1 EQU  *-TBVERMOD
LNGTBL   EQU  *-TBSEL
         SPACE
TBVARSVA DC   XL(LNGTBL)'0'           SAVE AREA FOR TABLE VARIABLES
         DS   0F
*                                 *** VARIABLES USED FOR TBDISPL
         SPACE
CRP      DC    F'0'                   CURRENT ROW POINTER
ZTDTOP   DC    F'0'                   CURRENT TOP OF DISPLAY
CMDLINE  DC    CL80' '                CMDLINE FROM PANEL
SAVCMDL  DC    CL80' '                CMDLINE IS PUT HERE
ENDCMDL  DC    X'FF'           ******* THIS MUST FOLLOW CMDLINE ******
ZTDMARK  DC    CL79' '                BOTTOM LINE OF TBDISPL
FINDPARM DC    CL8' '
DATAID   DC    CL8' '                 DATAID FOR LMINIT
PARM1    DC    CL8' '                 VARIABLE FOR MESSAGE
SCRHORZ  DC    CL8' '                 COMMAND TABLE VARIABLE
DS@MODE  DC    C' '                   MODE (E, B OR M)
ZDSN     DC    CL44' '
ZMEMB    DC    CL8' '
         DS    0F
         SPACE
*                                 *** VARIABLES USED FOR MEMBER PRINT
PRTDSN   DC    CL44' '                DATASET NAME
CP       DC    F'0'                   COPIES
DEST     DC    CL8' '                 SYSOUT DESTINATION
HOLD     DC    C' '                   HOLD (Y OR N)
HEAD     DC    C' '                   HEADING (Y OR N)
SNUM     DC    C' '                   SUPPRESS NUMBERS (Y OR N)
FORM     DC    CL4' '                 FORMS
UCS      DC    CL4' '                 UCS
PRTVARSL EQU   *-DEST                 LENGTH TO BLANK OUT
         DS    0F
*                                 *** LENGTH OF ABOVE VARIABLES
*                                 *** VARIABLES FOR MOVE/COPY
PROJ2    DC    CL8' '                  PROJECT
LIBR2    DC    CL8' '                  LIBRARY
TYPE2    DC    CL8' '                  TYPE
DSN02    DC    CL44' '                 "OTHER" DATASET NAME
VOL2     DC    CL6' '                  VOLUME SERIAL FOR "OTHER"
REP      DC    C' '                    REPLACE (Y OR N)
SD       DC    C' '                    SEQUENTIAL DISP (OLD OR MOD)
         DS    0F
*                                 *** LENGTHS FOR ABOVE
         SPACE
*                                 *** VARIABLES SHOWN AS STATISTICS
LASTMEM  DC    CL8' '                 LAST MEMBER PROCESSED
CPUTMED  DC    C' '                   EDIT BYTE FOR CPU TIME
CPUTM    DC    CL7' '                 CPU TIME
ELAPTM   DC    CL5'HH:MM'             ELAPSED TIME
MPR      DC    F'0'                   # OF MEMBERS TO PROCESS
MSC      DC    F'0'                   # OF MEMBER SCANNED
MSE      DC    F'0'                   # OF MEMBERS SELECT
         DS    0F
         SPACE
DIRMEM   DC    CL8' '                 MEMBER
DIRLIB   DC    C' '                   LIB NUMBER
         DC    CL2' '                 EXTRA BYTES FOR ED INSTR (DIRLNG)
DIRLNG   DC    CL2' '                 LENGTH OF DIRECTORY ENTRY
DIRINFO  DC    CL59' '
         ORG   DIRINFO
DIROFF   DS    CL4                    OFFSET
         DS    CL1
DIRHEX   DS    CL35                   HEX PART OF DUMP
         DS    CL1
DIRAST   DS    C                      PLACE FOR '*'
DIRCHAR  DS    CL16                   CHAR PART OF DUMP
         ORG
DIRBLKLG EQU   *-DIRMEM               LENGTH TO BLANK OUT
         TITLE 'DIALOG VARIABLE LENGTHS'
**********************************************************************
*             V A R I A B L E       L E N G TH S                     *
**********************************************************************
         SPACE
LNGBASE  DC    F'0'
DSN1L    DC    F'0'
DSN2L    DC    F'0'
DSN3L    DC    F'0'
DSN4L    DC    F'0'
MEMBERL  DC    F'0'
VOL1L    DC    F'0'
USERIDL  DC    F'0'
ZPREFIXL DC    F'0'
SCANSTRL DC    F'0'
STPL     DC    F'0'
SCOL1L   DC    F'0'
SCOL2L   DC    F'0'
DELAYL   DC    F'0'
*
PROJ2L   DC    F'0'
LIBR2L   DC    F'0'
TYPE2L   DC    F'0'
DSN02L   DC    F'0'
         TITLE 'FLAGS'
**********************************************************************
*                    F   L   A   G   S                               *
**********************************************************************
         SPACE
FLAGBYTE DC    AL1(0)                 FLAG BYTE NUMBER 1 (PRIMARY)
         SPACE
ALLMEM   EQU   B'10000000'               INDICATES ALL MEMBER NAMES
GENERIC  EQU   B'01000000'               GENERIC MEMBER NAME
SCAN     EQU   B'00100000'               INDICATES SCAN STR PASSED
FOUND    EQU   B'00010000'               INDICATES SCAN STR FOUND
TBINIT   EQU   B'00001000'               INDICATES TABLE CREATED
NOSTAT   EQU   B'00000100'               IND. NO ISPF STATISTICS
DSNSAME  EQU   B'00000010'               IND. DATA SET NAMES MATCH
ONEMEMBR EQU   B'00000001'               AT LEAST ONE MEMBER READ
         SPACE
FLAGBYT2 DC    AL1(0)                 FLAG BYTE NUMBER 2 (SECONDARY)
MANY     EQU   B'10000000'               INDICATES MANY MEMBERS PROC
ALCONLY  EQU   B'01000000'               ALLOCATE ONLY/DON'T OPEN
STNOSHOW EQU   B'00100000'               DON'T SHOW STAT PANEL
NOPUT    EQU   B'00010000'               DO NOT DO TBPUT
NORSKIP  EQU   B'00001000'               DON'T RESET SKIP NUM
CMDLPRC  EQU   B'00000100'               COMMAND LINE PROCESSING
*        EQU   B'00000010'               A SPARE BIT
*        EQU   B'00000001'               A SPARE BIT
***************************** NOTE: FLAGBYT2 GETS CLEARED EVERY
*****************************   TIME THE TABLE IS DISPLAYED BY
*****************************   IN THE TABLE LOOP (PROCTBL)
         SPACE
FLAGBYT3 DC    AL1(0)                 FLAG BYTE NUMBER 3
NEWEDM   EQU   B'10000000'               NEW EDIT MEMBER
NDEFSORT EQU   B'01000000'               TBL NOT SORTED BY DEFAULT
LOADLIB  EQU   B'00100000'               PROCESSING LOAD LIBRARIES
SINGMEM  EQU   B'00010000'               SINGLE MEMBER NAME SPECIFIED
NOTPODS  EQU   B'00001000'               NOT PDS (FOR EDIT/BROWSE MODE)
RETEBRC  EQU   B'00000100'               RETURN EDIT/BROWSE RETURN CODE
DONE     EQU   B'00000010'               WE ARE DONE
INITSCAN EQU   B'00000001'               INITIAL SCAN
         SPACE
FLAGBYT4 DC    AL1(0)                 FLAG BYTE NUMBER 4
MEMBLST  EQU   B'10000000'               MEMBER LIST DISPLAYED
GDGMEMBR EQU   B'01000000'               GDG MEMBER NAME
SORTOFLG EQU   B'00100000'               SORT OPERAND FLAG
         SPACE
VARDFFLG DC    AL1(0)                 VARIABLES DEFINED FLAG
TBVARDF  EQU   B'10000000'               TABLE VARIABLES DEFINED
INFVARDF EQU   B'01000000'               VARS FOR INFO WERE VDEFINED
DIRVARDF EQU   B'00100000'               VARS FOR DIR WERE VDEFINED
STVARDF  EQU   B'00010000'               STATS VARIABLES DEFINED
TBPVARDF EQU   B'00001000'               TABLE PROCESSING VARS DEFINED
         SPACE
DELFLAG  DC    AL1(0)                 DELIMITER FLAG
DELFRONT EQU   B'10000000'              DELIMITER UP FRONT
DELBACK  EQU   B'01000000'              DELIMITER IN BACK
LASTPOS  EQU   B'00100000'              STRING IN LAST POSSIBLE POS.
*        EQU   B'00010000'              SPARE
*        EQU   B'00001000'                "
*        EQU   B'00000100'                "
*        EQU   B'00000010'                "
*        EQU   B'00000001'                "
         SPACE
PRTDISP  DC    AL1(0)                 INDICATES PRINT PANEL DISPLAYED
CPYDISP  DC    AL1(0)                 INDICATES COPY PANEL DISPLAYED
PRTSYSAL DC    AL1(0)                 INDICATES PRINT SYSOUT ALLOCATED
MOVFLAG  DC    AL1(0)                 MOVE INSTEAD OF COPY COMMAND
RBLDFLAG DC    AL1(0)                 REBUILD COMMAND IS ACTIVE
STACKF   DC    AL1(0)                 STACK COMMAND EXECUTING
SWITCHF  DC    AL1(0)                 SWITCH COMMAND DONE
EDBRFLG  DC    AL1(0)                 0 IF BROWSE, ELSE EDIT
SCRLLFLG DC    AL1(0)                 0 IF LEFT BOUNDARY, 1 OTHERWISE
CMDSERV  DC    AL1(0)                 0 IF COMMAND, 1 IF A SERVICE CALL
FLUSHDIR DC    AL1(0)                 FLUSH DIR. (READ TO PHY. EOF)
         SPACE
         DS    0F
OPENLST  OPEN  (,),MF=L
CLOSLST  CLOSE (,),MF=L
         SPACE
         DS    0F
TBARRAY  DC    AL4(0),AL4(0),AL4(0),AL4(0)
DSPTRS   DC    AL4(0),AL4(0),AL4(0),AL4(0)
         TITLE 'DS@SCPDS--PARAMETER BLOCKS FOR CALLED PROGRAMS'
         PRINT GEN
**********************************************************************
*        P R I N T     P A R A M E T E R     B L O C K               *
**********************************************************************
         SPACE
         DS    0F
         DS@PRTPB DSECT=NO            PARAMETER BLOCK FOR PRINT
         SPACE 3
**********************************************************************
*     M O V E/ C O P Y     P A R A M E T E R     B L O C K           *
**********************************************************************
         SPACE
         DS    0F
         DS@CPYPB DSECT=NO            PARAMETER BLOCK FOR PRINT
         EJECT
**********************************************************************
*        S U B M I T   P A R A M E T E R     B L O C K               *
**********************************************************************
         SPACE
         DS    0F
         DS@SUBPB DSECT=NO            PARAMETER BLOCK FOR SUBMIT
         SPACE 3
**********************************************************************
*          D S I N F O   P A R A M E T E R     B L O C K             *
**********************************************************************
         SPACE
         DS    0F
         DS@INFPB DSECT=NO            PARAMETER BLOCK FOR INFO
         EJECT
**********************************************************************
*          A L L O C     P A R A M E T E R     B L O C K             *
**********************************************************************
         SPACE
         DS    0F
         DS@ALCPB DSECT=NO            PARAMETER BLOCK FOR ALLOC
         SPACE 3
**********************************************************************
*          M E S S A G E       P A R A M E T E R    B L O C K        *
**********************************************************************
         SPACE
         DS    0F
         DS@MSGPB DSECT=NO            MESSAGE PARAMETER BLOCK
         SPACE 3
**********************************************************************
*          C O N V D A T E     P A R A M E T E R    B L O C K        *
**********************************************************************
         SPACE
         DS    0F
         DS@CNDPB DSECT=NO            PARAMETER BLOCK FOR CONVERT DATE
         TITLE 'DS@SCPDS--SPAM PARAMETER BLOCK'
**********************************************************************
*          S P A M     P A R A M E T E R     B L O C K               *
**********************************************************************
         SPACE
         DS@SPPB  DSECT=NO
         TITLE 'DS@SCPDS--SPACE FOR INTERNAL SUBROUTINE REGISTER SAVE'
**********************************************************************
*                       S A V E     A R E A                          *
**********************************************************************
         SPACE
NUMSVA   DC    F'0'                   NUMBER OF SAVE AREAS
SAVADDR  DC    A(0)                   LAST SAVE AREA
SAVMAX   EQU   16                     LEVEL OF SUBROUTINE NESTING
SAVALNG  EQU   64                     LENGTH OF A SAVE AREA
         SPACE
SAVSTCK  DS    0F                     SAVE AREA STACK
         ORG   *+(SAVMAX*SAVALNG)
         SPACE
         TITLE 'DATA SET TABLE'
**********************************************************************
*                D A T A     S E T     T A B L E S                   *
*                                                                    *
*    THE REST OF THE DSA IS BEYOND THE ADDRESSABILITY OF ONE REGIS-  *
* TER (R13), SO BEWARE.                                              *
**********************************************************************
         SPACE
DSTABLE  DS    0F
         ORG   *+(DSNML*4)
         SPACE
RACRWORK DS    XL512                  RACROUTE WORK AREA
         SPACE
JFCBA    DC    XL176'0'               SPAM FEEDBACK AREA (JFCB)
JFCBALNG EQU   *-(JFCBA+1)
         SPACE
TRTBL    DS    XL256                  TABLE FOR TRT INSTRUCTION
         SPACE
         DS    0F
MSGDSA   DC    100F'0'                DSA FOR THE MESSAGE SYSTEM
SPAMDSA  DC    150F'0'                DSA FOR SPAM
ROUTDSA  DC    300F'0'                DSA FOR CALLED PROGRAMS
LNGDSA   EQU   *-DS@SCPDD             LENGTH OF THE DSA
         TITLE 'DS@SCPDS - MAINLINE CODE'
**********************************************************************
*                           B E G I N                                *
**********************************************************************
         SPACE
         PRINT GEN
*        PRINT NOGEN
DS@SCPDS CSECT
         USING *,R15
         DS@START ,
         LR    R12,R15                LOAD FIRST BASE REGISTER
         DROP  R15
         USING DS@SCPDS,BASE
         USING DSTBL,R11
         LH    R1,=AL2(LNGDSA)        GET DSA LENGTH
         LR    R5,R1                  COPY FOR LATER
         GETMAIN RC,LV=(R1)           GO GET SOME STORAGE
         LR    R4,R1                  COPY ADDRESS RETURNED
         SLR   R3,R3                  CLEAR THIS REGISTER
         MVCL  R4,R2                  THIS SHOULD ZERO IT OUT
         ST    R13,4(0,R1)            SET BACKWARD CHAIN
         ST    R1,8(0,R13)            SET FORWARD CHAIN
         LR    R13,R1                 GET DSA BASE
         USING DS@SCPDD,R13
         MVC   SAVEAREA(4),=C'SCPD'   SET PROGRAM IDENTIFIER
         L     R1,=A(GETSVA)          ADDRESS THIS ROUTINE
         ST    R1,GETSVA@             SAVE IN DSA
         L     R1,=A(FREESVA)         ADDRESS THIS ROUTINE
         ST    R1,FREESVA@            SAVE IN DSA
         DO    SETATTN                GO SET UP ATTENTION HANDLER
BUILDIT  DS    0H
         DO    INIT                   GO DO ALL INITIALIZATION
         LTR   R15,R15                IF ERROR DURING INITIALIZATION
         BZ    OKINIT
         DO    FINISH                   GO CLEAN UP
         B     RETURN
OKINIT   DS    0H                     ELSE
         DO    PROCESS                GO PROCESS THE DIRECTORY
         L     R1,MPR                 GET NUMBER OF MEMBERS IN TABLE
         LTR   R1,R1                  IF = 0 THEN
         BNZ   CONTPRC
         LA    R1,MSG6                  SET MESSAGE NUMBER
         TM    FLAGBYTE,ONEMEMBR        IF NO MEMBERS READ, THEN
         BNZ   MEMBREAD
         LA    R1,MSG35                   SET MESSAGE NUMBER
MEMBREAD DS    0H
         DO    FINISH                   GO CLEAN UP
         DO    PUTMSG                   GO SET A MESSAGE
         B     RETURN                   AND WE'RE DONE
CONTPRC  DS    0H
         TM    FLAGBYTE,SCAN          IF DOING A SCAN, THEN
         BZ    NOSCAN
         DO    SCANCMD                  GO DO IT
NOSCAN   DS    0H
         DO    PROCTBL                GO PROCESS THE TABLE DISPLAY
         L     R1,NUMTBLNM            GET NUMBER OF TABLES
         LTR   R1,R1                  IF MORE TABLES STACKED, THEN
         BNZ   NOSCAN                   LOOP
         DO    FINISH                 GO CLEANUP
         DO    CLOSECPY               GO CLOSE TARGET DS FOR COPY
         TM    FLAGBYT3,DONE          IF DONE, THEN
         BO    RETURN1                  GET US OUT OF HERE
         CLI   RBLDFLAG,FLAGON        IF REBUILD COMMAND ENTERED,
         BE    BUILDIT                  GO DO IT
RETURN1  DS    0H
         DO    FREESYS                GO FREE SYSOUT FILE
RETURN   DS    0H
         STAX ,                       TURN STAX OFF
         LR    R2,R13                 COPY R13
         LH    R1,=AL2(LNGDSA)        GET DSA LENGTH
         L     R3,4(0,R13)            COPY PREVIOUS REGISTER 13
         SLR   R4,R4                  CLEAR FOR RETURN
         TM    FLAGBYT3,RETEBRC       IF WE ARE TO RETURN EDIT/BROWSE
         BZ    *+8                          RETURN CODE, THEN
         L     R4,EDBRRC                GET IT
         FREEMAIN RC,LV=(R1),A=(R2)   DO THE FREEMAIN
         LR    R13,R3                 RESTORE REG 13 CONTENTS
         LR    R15,R4                 RETURN CODE ALWAYS 0
         RETURN (14,12),T,RC=(15)     DONE
         SPACE
         LTORG
         SPACE
PATCH    DC    15F'0'                 PATCH AREA FOR ABOVE
         SPACE
         DROP  BASE
         TITLE 'INITIALIZATION SUBROUTINE'
**********************************************************************
*                 I N I T         S U B R O U T I N E                *
*                                                                    *
*    THIS SUBROUTINE DOES ALL OF THE INITIALIZATION REQUIRED.  IT    *
*  CALLS THE GETVARS SUBROUTINE TO VCOPY THE DIALOG VARIABLES THAT   *
*  THIS PROGRAM NEEDS, CALLS DETDSN# TO DETERMINE THE NUMBER OF DATA *
*  SETS GIVEN, CALLS ALLOCDIR TO ALLOCATE AND OPEN THE PDS DIRECT-   *
*  ORY,   AND THEN PROCESSES THE INPUT PARAMETERS SCANSTR, MEMBER,   *
*  STP, SCOL1, SCOL2 AND DELAY.                                      *
*    INPUT: R14 - RETURN ADDRESS                                     *
*                                                                    *
**********************************************************************
         SPACE
         USING INIT,BASE
         SPACE
INIT     DS@ENTR ,
         CLI   RBLDFLAG,FLAGON        IF REBUILD, THEN
         BNE   INITNRB
         DO    ALLOCDIR                 ALLOCATE DIRECTORY DDNAMES
         B     INITRET                  AND WE ARE DONE
INITNRB  DS    0H
         MVC   NUMDS,=H'1'            INITIALIZE NUMDS
         OI    FLAGBYT3,INITSCAN      ANY SCAN WILL BE INITIAL ONE
         MVI   BLANKS,C' '            MOVE BLANKS TO AREA IN DSA
         MVC   BLANKS+1(255),BLANKS
         MVC   DATAID,BLANKS          SET DATAID TO BLANKS
         MVC   ERRFIELD,BLANKS
         MVC   RACFERRM,=C'RACF Authorization failed for '
         MVC   CONVTYPE,=C'JG'        SET TYPE FOR CONVERT DATE ROUTINE
         MVC   RACHKRPL(RACHKPLL),RACHRPLM MOVE IN MASK
         MVC   RACHKUPL(RACHKPLL),RACHUPLM MOVE IN MASK
         LA    R1,DSN1                ADDRESS AREA TO BLANK OUT
         LA    R2,INITVLNG            GET LENGTH OF AREA
         DO    BLANKIT                GO INIT TO BLANKS
         L     R1,=A(VTBL1)           ADDRESS VARIABLE TABLE
         LA    R2,VTBL1#              GET NUMBER IN TABLE
         STM   R1,R2,VARTBLA          SAVE IN PARM LIST
         DO    DEFVARS                GO VDEFINE THEM
         MVI   ENDCMDL,X'FF'          SET THIS FIELD FOR PARSING
         LR    R1,R13                 COPY DSA ADDRESS
         AH    R1,=AL2(DSTABLE-DS@SCPDD) ADD OFFSET FOR DATASET TABLE
         ST    R1,DSTABL@             SAVE IN DSA (ADDRESSABLE FIELD)
         LR    R1,R13                 COPY DSA ADDRESS
         AH    R1,=AL2(JFCBA-DS@SCPDD) ADD OFFSET FOR FEEDBACK AREA
         ST    R1,JFCBA@              SAVE IN DSA (ADDRESSABLE FIELD)
         LR    R1,R13                 COPY DSA ADDRESS
         AH    R1,=AL2(TRTBL-DS@SCPDD) ADD OFFSET FOR TRTBL
         ST    R1,TRTBL@              SAVE IN DSA (ADDRESSABLE FIELD)
         LR    R1,R13                 COPY DSA ADDRESS
         AH    R1,=AL2(RACRWORK-DS@SCPDD) ADD OFFSET FOR RACRWORK
         ST    R1,RACRWRK@            SAVE IN DSA (ADDRESSABLE FIELD)
         LR    R1,R13                 COPY DSA ADDRESS
         AH    R1,=AL2(SPAMDSA-DS@SCPDD) ADD OFFSET FOR THIS
         ST    R1,SPBDSA              SAVE IN PARM BLOCK
         LR    R1,R13                 COPY DSA ADDRESS
         AH    R1,=AL2(MSGDSA-DS@SCPDD) ADD OFFSET FOR THIS
         ST    R1,MSGDSA@             SAVE IN MESSAGE PARM BLOCK
         LR    R1,R13                 COPY DSA ADDRESS
         AH    R1,=AL2(ROUTDSA-DS@SCPDD) ADD OFFSET FOR THIS
         ST    R1,ALCPBDS@            SAVE IN PARM BLOCKS
         ST    R1,INFDSA@
         ST    R1,PRTDSA@
         ST    R1,CPYDSA@
         ST    R1,SUBDSA@
         LA    R1,ERRFIELD            ADDRESS AREA FOR ALLOCATION MSGS
         ST    R1,ALCPBMG@            SET IN PARM BLOCK
         DO    GETLNG                 GET LENGTHS THAT WE NEED
         CLI   SCOP,C'Y'              IF SCAN OPTION = Y, THEN
         BNE   *+4+4
         OI    FLAGBYTE,SCAN            SET FLAG SAYING SO
         DO    DETDSN#                DETERMINE NUMBER OF DATA SETS
         DO    MEMLNG                 GO PROCESS MEMBER NAME PASSED
         TM    FLAGBYT3,SINGMEM       IF SINGLE MEMBER NAME,
         BZ    INITNSM                          AND
         CLI   MODE,C'B'                  BROWSE MODE OR EDIT MODE,
         BE    INITSM
         CLI   MODE,C'E'
         BNE   INITNSM
INITSM   DS    0H
         DO    PRCEDBR                  GO DO THE EDIT/BROWSE
         OI    FLAGBYT3,RETEBRC         SAY RETURN EDIT/BROWSE RC
         LA    R15,4                    SET RETURN CODE
         B     INITRET                  AND WE'RE DONE
INITNSM  DS    0H
         DO    ALLOCDIR               ALLOCATE DIRECTORY DDNAMES
         LTR   R15,R15                IF AN ERROR, THEN
         BNZ   INITRET                  DONE
         DO    UIDLNG                 GO PROCESS USERID PASSED
         L     R0,DELAYL              GET LENGTH FOR SUBROUTINE
         LTR   R0,R0                  IF DELAY NOT GIVEN THEN
         BNZ   INITSK3                  USE DEFAULT
         LA    R2,DEFDELAY
         SLR   R15,R15                  SET RETURN CODE
         B     INITSK4
INITSK3  DS    0H
         LA    R1,DELAY               SET UP TO CONVERT DELAY TO BIN
         DO    CONVBIN                CONVERT SCOL2 OPTION PASSED
         SLR   R15,R15                SET RETURN CODE
         LTR   R1,R1                  IF DELAY IS ZERO, THEN
         BNZ   INITSK31
         OI    FLAGBYT2,STNOSHOW        DON'T SHOW STATISTICS
         B     INITRET                  AND WE'RE DONE
INITSK31 DS    0H
         LA    R2,MINDELAY            GET MINIMUM VALUE FOR DELAY
         CR    R2,R1                  IF LESS THEN MINIMUM, THEN
         BNL   *+6                      SET TO MINIMUM
         LR    R2,R1
INITSK4  DS    0H
         ST    R2,TIMEVAL             SAVE FOR LATER
INITRET  DS    0H
         DS@EXIT RET=R15
         SPACE
RACHRPLM RACROUTE ENTITY=0,VOLSER=0,CLASS='DATASET',ATTR=READ,DSTYPE=N,+
               REQUEST=AUTH,MF=L
RACHKPLL EQU   *-RACHRPLM
         SPACE
RACHUPLM RACROUTE ENTITY=0,VOLSER=0,CLASS='DATASET',ATTR=UPDATE,       +
               REQUEST=AUTH,DSTYPE=N,MF=L
         SPACE
         DROP  BASE
         TITLE 'DETDSN# - DETERMINE NUMBER OF DATA SETS'
**********************************************************************
*             D E T D S N #         R O U T I N E                    *
*                                                                    *
*     THIS SUBROUTINE DETERMINES HOW MANY OF THE UP TO FOUR DATA     *
*   SET NAMES GIVEN ARE UNIQUE.  IT SETS NUMDS TO THIS COUNT, AND    *
*   PUTS THE PROPER POINTERS TO THE UNIQUE DATA SETS OF DSTBL IN     *
*   DSPTRS.  NOTE THAT THERE IS EITHER 1 DATA SET (THE DEFAULT) OR   *
*   ALL FOUR.  WE FIRST INITIALIZE THE DATASET TABLE, AND THE TABLE  *
*   OF POINTERS TO ACTIVE ELEMENTS IN THIS TABLE (DSPTRS).           *
*                                                                    *
**********************************************************************
         SPACE
         USING DETDSN#,BASE
         SPACE
DETDSN#  DS@ENTR ,
         LA    R1,4                   MAX NUMBER OF DATASETS
         L     R11,DSTABL@            ADDRESS DATASET TABLE
         ST    R11,DSPTRS             SAVE THIS POINTER FOR NOW
         LA    R3,DSN1                ADDRESS 1ST DSNAME
         LA    R4,241                 PUT C'1' (X'F1') IN R4
         LA    R5,DSN1L               ADDRESS LENGTHS
         LA    R6,TBARRAY             ADDRESS POINTER TABLE
DETDSNLP DS    0H                     DO I = 1 TO 4
         ST    R11,0(R6)                SAVE POINTER TO THIS ONE
         MVC   0(DSNML,R11),DSNM        MOVE IN DATASET TABLE MASK
         ST    R3,DSNAME@               SAVE ADDRESS OF DSNAME
         STC   R4,LIB#                  SET LIB #
         MVC   DSNLNG,0(R5)             SAVE LENGTH OF THIS ONE
         LA    R11,DSNML(,R11)          NEXT TABLE ELEMENT
         LA    R3,DSNAMEL(,R3)          NEXT DSNAME
         LA    R4,1(,R4)                NEXT LIB NUMBER
         LA    R5,4(,R5)                NEXT LENGTH
         LA    R6,4(,R6)                NEXT IN TABLE OF POINTERS
         BCT   R1,DETDSNLP            END OF LOOP
         SPACE
         L     R8,DSN2L               CHECK 1ST FOR ONLY ONE DATA SET
         LTR   R8,R8                  IF LNGDSN2 = 0 THEN ONLY 1
         BZ    D#RET                    SO WE ARE DONE
         LA    R7,TBARRAY             ELSE READY TO CYCLE THROUGH THE
         LA    R6,DSPTRS+4              VARIOUS TABLES
         LA    R8,2                   DO I = 2 TO 4
D#LOOP1  DS    0H
         CH    R8,=H'4'
         BH    D#RET
         LA    R4,TBARRAY
         L     R11,4(R7)
         NI    FLAGBYTE,255-DSNSAME     ASSUME UNIQUE DATA SET NAME
         LA    R3,1                     DO J = 1 TO I - 1
         LR    R9,R8
         BCTR  R9,0
D#LOOP2  DS    0H
         CR    R3,R9
         BH    D#LOOPX
         L     R5,0(R4)                   ADDRESS TABLE ELEMENT
         L     R5,0(R5)                   GET ADDRESS OF DS NAME
         L     R1,DSNAME@
         CLC   0(44,R1),0(R5)             IF DSN(I) ^= DSN(J)
         BNE   D#SKIP1                      THEN SKIP
         OI    FLAGBYTE,DSNSAME           ELSE INDICATE SAME NAME
D#SKIP1  DS    0H
         LA    R4,4(R4)
         LA    R3,1(R3)
         B     D#LOOP2                  END D#LOOP2
D#LOOPX  DS    0H
         TM    FLAGBYTE,DSNSAME         IF DSN(J) MATCHED ANY AT ALL
         BO    D#SKIP2                    THEN SKIP
         ST    R11,0(R6)                ELSE SET DSPTRS(I)
         LA    R6,4(R6)
         LH    R1,NUMDS                   NUMDS = NUMDS + 1
         LA    R1,1(,R1)
         STH   R1,NUMDS
D#SKIP2  DS    0H
         LA    R7,4(R7)
         LA    R8,1(R8)
         B     D#LOOP1                END LOOP1
D#RET    DS    0H
         NI    FLAGBYTE,255-DSNSAME   RESET THIS FLAG
         DS@EXIT ,
         SPACE
DSNM     DC    A(0)                   DATA SET NAME
         DC    F'0'                   LENGTH OF DATA SET NAME
         DC    CL8' ',CL8' '          DDNAMES ALLOCATED
         DC    CL6' '                 VOLUME ON WHICH DS RESIDES
         DC    A(0),A(0),A(0)         SPAM FILE BLOCK POINTERS
         DC    A(0)                   -> CURRENT DIRECTORY ENTRY
         DC    H'0'                   BLOCK COUNT LEFT WITHIN DIRECTORY
         DC    H'0'                   # OF USED DIRECTORY BLOCKS
         DC    H'0'                   MAX # OF DIRECTORY BLOCKS
         DC    H'0'                   COUNT OF NUMBER OF MEMBERS
         DC    C'1'                   LIBRARY NUMBER
         DC    X'00'                  FLAG BYTE
         DC    X'00'                  2ND FLAG BYTE
         DS    0F
DSNML    EQU   *-DSNM
         SPACE
         DROP  BASE
         TITLE 'ALLOCDIR - ALLOCATE DIRECTORY DDNAMES'
**********************************************************************
*              A L L O C D I R      R O U T I N E                    *
*                                                                    *
*     THIS SUBROUTINE ALLOCATES AND OPENS ALL DATA SETS.  THE        *
*   ROUTINE SIMPLY SPINS THROUGH DSTBL FOR EACH DATA SET, CALLING    *
*   DS@ALLOC TO DYNAMICALLY ALLOCATE THE DATA SETS AND RETURN THE    *
*   DSORG AND DDNAME. IT CHECKS FOR DSORG OF PO, AND ALSO FOR        *
*   SUCCESSFUL ALLOCATION.  IF EITHER ERROR IS ENCOUNTERED, A RETURN *
*   CODE IS SET, AND THE CLEANUP ROUTINES ARE CALLED TO GET US OUT.  *
*   IF NO ERRORS, A FLAG IS SET IN THE TABLE TO INDICATE THE         *
*   ALLOCATION OCCURRED, AND THE APPROPRIATE DDNAME IS MOVED TO THE  *
*   SPB BEFORE THE OPEN.  THEN FOR EACH DATA SET, THE OPEN IS        *
*   ISSUED, AND IF SUCCESSFUL, THE APPROPRIATE FLAG IS SET,          *
*   OTHERWISE WE GET OUT VIA A RETURN CODE AND THE CLEANUP ROUTINES. *
*                                                                    *
*     INPUT:  NUMDS - GIVES THE NUMBER OF DATA SETS TO PROCESS       *
*             DSTBL - DATA SET TABLE                                 *
*             DSPRTS - POINTERS TO ACTIVE ELEMENTS IN DSTBL          *
**********************************************************************
         SPACE
         USING ALLOCDIR,BASE
         SPACE
ALLOCDIR DS@ENTR ,
         OI    FLAGBYT3,LOADLIB       ASSUME LOAD LIBRARIES
         L     R1,JFCBA@              ADDRESS JFCB AREA
         ST    R1,SPBFDBK             THIS IS SPAM FEEDBACK AREA
         LA    R1,JFCBALNG            GET LENGTH OF FEEDBACK AREA
         STC   R1,SPBFDBK             SAVE IN SPB
         LH    R5,NUMDS               GET NUM. OF DATA SETS TO PROCESS
         LA    R4,DSPTRS              ADDRESS TABLE OF POINTERS
ALLOCLP  DS    0H
         L     R11,0(R4)              ADDRESS DSTBL ELEMENT
         L     R1,DSNAME@
         MVC   ALCPBDSN,0(R1)         MOVE DATASET NAME
         MVC   ALCPBDNL,DSNLNG        SET DATASET NAME LENGTH
         MVC   ALCPBDDN,BLANKS        CLEAR DDNAME FOR ROUTINE
         MVC   ALCPBVOL,VOL1          SET VOLUME PARAMETER
         MVC   ALCPBMEM,BLANKS        CLEAR MEMBER NAME IN PARM BLOCK
         TM    FLAGBYT4,GDGMEMBR      IF GDG MEMBER NAME
         BZ    *+4+6
         MVC   ALCPBMEM,MEMBER          SO MOVE IT TO PARM BLOCK
         LA    R2,DS@ALCPB            ADDRESS PARAMETER BLOCK
         CALL  DS@ALLOC,((R2)),VL,MF=(E,CALLPL)
         LTR   R15,R15                IF ALLOCATION ERROR, THEN
         BZ    OKALLOC
         LA    R1,MSG29                 SET THE MESSAGE
         DO    PUTMSG                   AND GO GIVE IT TO ISPF
         B     ALLOCDX                  GO CLEANUP
OKALLOC  DS    0H
         MVC   DDNAME1,ALCPBDDN       MOVE IN DDNAME RETURNED
         MVC   DSVOL,ALCPBVOL         MOVE IN VOLUME RETURNED
         OI    FLAG,ALCBSAM           INDICATE SUCCESSFUL ALLOCATION
         CLC   ALCPBRDS,=X'0200'      IF DSORG ^ PO THEN
         BE    OKDSORG
         CLC   NUMDS,=H'1'              IF ONE DS  AND
         BH    ALLOCNPO
         CLI   MODE,C'B'                     (BROWSE  OR
         BE    ALLOCBE                         EDIT MODE)
         CLI   MODE,C'E'
         BNE   ALLOCNPO
ALLOCBE  DS    0H
         OI    FLAGBYT3,NOTPODS             SAY NOT PARTITIONED
         DO    PRCEDBR                      GO DO EDIT/BROWSE
         OI    FLAGBYT3,RETEBRC             RETURN EDIT/BROWSE RC
         LA    R15,4                        SET RETURN CODE
         B     ALLOCDX                      AND WE'RE DONE
ALLOCNPO DS    0H
         LA    R1,MSG7                  SET THE MESSAGE
         DO    PUTMSG                   AND GO GIVE IT TO ISPF
         B     ALLOCDX                  GO CLEANUP
OKDSORG  DS    0H
         TM    FLAGBYT2,ALCONLY       IF ALLOCATE ONLY, THEN
         BO    ALLCDNRU                 SKIP OPEN STUFF
         L     R6,DSNAME@             ADDRESS DATA SET FOR RACF CHECK
         LA    R7,ALCPBVOL            ADDRESS VOLSER FOR FACF CHECK
         L     R8,RACRWRK@            ADDRESS WORK AREA FOR RACROUTE
         RACROUTE ENTITY=((R6)),VOLSER=(R7),WORKA=(R8),REQUEST=AUTH,   +
               MF=(E,RACHKRPL)
         LTR   R15,R15                IF AUTHORIZED, THEN
         BZ    OKRACF                   SKIP
         L     R1,DSNAME@
         MVC   RACFERRD,0(R1)         ELSE CONSTRUCT ERROR MESSAGE
         MVC   ERRFIELD,RACFERRM
         LA    R1,MSG4                  SET THE MESSAGE
         DO    PUTMSG                   AND GO GIVE IT TO ISPF
         B     ALLOCDX                  GO CLEANUP
OKRACF   DS    0H
         MVI   SPBFUNC,SPBFOPEN       SPAM FUNCTION CODE IS OPEN
         MVI   SPBOPT1,SPBOBSAM       ACCESS METHOD IS BSAM
         MVC   SPBDDNAM,DDNAME1       MOVE IN DDNAME
         MVI   SPBOPT2,SPBOIN         OPEN THIS FOR INPUT ONLY
         MVI   SPBRECFM,SPBRECU       SET RECFM TO UNDEFINED
         MVC   SPBBLKSI,=H'256'       BLOCKSIZE TO BE 256
         MVC   SPBBUFNO,=AL4(BUFFNO)  SET NUMBER OF BUFFERS
         CALL  SPAM,(SPB),VL,MF=(E,SPAMPL)
         LH    R15,SPBRETC            GET OPEN RETURN CODE
         LTR   R15,R15                Q.SUCCESSFUL OPEN?
         BZ    OKOPENA                N.REPORT THE ERROR VIA RC
         LA    R1,MSG8                ELSE SET THE MESSAGE
         DO    PUTMSG                   AND GO GIVE IT TO ISPF
         B     ALLOCDX                  GET OUT OF HERE
OKOPENA  DS    0H
         MVC   DIRSFB,SPBSFB          SAVE FILE BLOCK POINTER
         OI    FLAG,OPNBSAM           SAY DIRECTORY OPEN
         L     R1,JFCBA@              ADDRESS FEEDBACK AREA
         TM    JFCRECFM-INFMJFCB(R1),JFCUND IF RECFM ^ U
         BO    ALLCDRU
         NI    FLAGBYT3,255-LOADLIB     NOT LOAD LIBRARY
         B     ALLCDNRU               ELSE
ALLCDRU  DS    0H
         OI    FLAG2,RECFMU             SAY RECORD FORMAT U
ALLCDNRU DS    0H
         LA    R4,4(R4)               NEXT DSPTR ELEMENT
         BCT   R5,ALLOCLP             AND LOOP
         SLR   R15,R15                CLEAR RETURN CODE
ALLOCDX  DS    0H
         XC    SPBFDBK,SPBFDBK        BE SURE THIS IS CLEAR
         DS@EXIT RET=R15
         SPACE
         DROP  BASE
         TITLE 'PROCESS PDS DIRECTORY ROUTINE'
**********************************************************************
*              P R O C E S S        R O U T I N E                    *
*                                                                    *
*     THIS SUBROUTINE IS THE MAIN LOOP FOR READING THE PDS DIREC-    *
*   TORIES AND BUILDING THE ISPF TABLE.  THE DIRECTORIES ARE READ    *
*   UNTIL EOF ON EACH, OR IF A GENERIC MEMBER NAME IS GIVEN, UNTIL   *
*   NAMES GREATER THAN THE GENERIC NAME IS ENCOUNTERED.              *
*                                                                    *
**********************************************************************
         SPACE
         USING PROCESS,BASE
         SPACE
PROCESS  DS@ENTR ,
         OI    FLAGBYT4,MEMBLST       SAY MEMBER LIST
         NI    FLAGBYTE,255-TBINIT    BE SURE TABLE IS CREATED
         MVC   LASTMEM,BLANKS         BE SURE THIS IS RESET TO BLANKS
         DO    INITDIR                GO DO INITIAL READS FOR ALL DIR.
FINDCUR  DS    0H
         DO    GETCURDR               DETERMINE PDS TO REALLY USE
         L     R11,CURDSN             GET CURDSN IN PROPER REGISTER
         L     R4,DIRPTR              ADDRESS CURRENT DIRECTORY
         USING MEMENTRY,R4
         CLC   MEMNAME,LASTMEM        IF CURRENT SAME NAME AS LAST
         BE    NEXTONE                  THEN GO GET NEXT ONE
         MVC   TBSEL(LNGTBL),BLANKS   BLANK TABLE ENTRY TO START
         MVC   LASTMEM,MEMNAME        MOVE IN MEMBER NAME AS CURRENT
         NI    FLAGBYTE,255-NOSTAT    CLEAR FLAG SAYING NO STATISTICS
         CLC   MEMNAME,ENDDIR         Q.END OF DIRECTORY?
         BE    PDRETRN                Y.THEN WE ARE DONE
MOVECUR  DS    0H
         OI    FLAGBYTE,ONEMEMBR      SAY WE FOUND A MEMBER
         LH    R1,MEMCNT              GET MEMBER COUNTER
         LA    R1,1(,R1)              INCREMENT IT
         STH   R1,MEMCNT              SAVE BACK
         TM    CFIELD,X'80'           IF ENTRY NOT AN ALIAS
         BZ    NOTALIAS                 THEN SKIP
         TM    FLAGBYT3,LOADLIB       ELSE IF LOAD LIBRARIES, THEN
         BO    NOTALIAS                 SKIP ALIAS PROCESSING
         MVC   TBVERMOD,=C'ALIAS'     SAY IT'S AN ALIAS
NOTALIAS DS    0H
         TM    CFIELD,X'0F'           IF ISPF STATISTICS DON'T EXIST
         BO    PROC10
         OI    FLAGBYTE,NOSTAT          INDICATE IT
         SPACE
PROC10   DS    0H
         MVC   TBTTRX,TTR             SET TTR FOR ROUTINE
         DO    PROCMEM                SEE IF THIS MEMBER IS GOOD
         LTR   R15,R15                IF NOT, THEN
         BNZ   NEXTONE                  TRY THE NEXT ONE
         MVC   TBLIB#,LIB#            ELSE MOVE IN LIBRARY NUMBER
         DO    BLDENTRY                 BUILD THE TABLE ENTRY
         DO    ADDTBL                   AND GO ADD IT TO THE TABLE
         SPACE
NEXTONE  DS    0H
         DO    READDIR                GET NEXT DIRECTORY ENTRY
         B     FINDCUR                AND LOOP
PDRETRN  DS    0H
         MVI   FLUSHDIR,FLAGON        SET FLAG ON FOR CLEANUP
         DO    CLEANUP                CLOSE FILES
         L     R2,CURTBLNM            ADDRESS CURRENT TABLE NAME
         LTR   R2,R2                  IF THERE, THEN
         BZ    *+4+6
         MVC   MPR,NUMMEM               SAVE NUMBER OF MEMBERS
         DS@EXIT ,
         SPACE
ENDDIR   DC    8X'FF'
         SPACE
         DROP  R4,BASE
         TITLE 'PROCESS PDS MEMBER SUBROUTINE'
**********************************************************************
*              P R O C M E M        R O U T I N E                    *
*                                                                    *
*     THIS SUBROUTINE DETERMINES IF THE GIVEN PDS MEMBER MATCHES     *
*   THE CRITERIA SET BY THE USER.  IF IT DOES, THE WE RETURN 0 TO    *
*   THE CALLING ROUTINE.  OTHERWISE, 4 IS SENT BACK.                 *
*                                                                    *
*     INPUT: R11 - CURRENTLY ACTIVE DSTBL ELEMENT                    *
*            R4  - ADDRESSES CURRENT DIRECTORY ENTRY                 *
*            R14 - RETURN ADDRESS                                    *
*                                                                    *
**********************************************************************
         SPACE
         USING PROCMEM,BASE
         USING MEMENTRY,R4
         SPACE
PROCMEM  DS@ENTR ,
         SLR   R15,R15                ASSUME A MATCH
         TM    FLAGBYTE,ALLMEM        IF LOOKING FOR ALL MEMBERS,
         BO    PRMTCH1                  SKIP
         LH    R6,LNGMEM              ELSE GET LENGTH FOR THE COMPARE
         EX    R6,CLCMEM                SEE IF MEMBER MATCHES
         BL    PRCMRET                  IF NOT LOW, THEN
         BE    PRMTCH1                    IF NOT EQUAL, THEN
         OI    FLAG,EOFDSL                  INDICATE LOGICAL EOF
         B     PRCMRET                      AND DONE
PRMTCH1  DS    0H
*        TM    FLAGBYTE,NOSTAT        IF NO STATISTICS FOR MEMBER
*        BO    PRCMRETX                 THIS ONE IS STILL GOOD
PRMTCH11 DS    0H
         CLI   USEROP,C'Y'            IF LOOKING FOR USERID, THEN
         BNE   PRCMRETX
         LH    R6,LNGUID                GET LENGTH FOR THE COMPARE
         EX    R6,CLCUID                IF USERID MATCHES, THEN
         BE    PRCMRETX                   DONE
PRCMRET  DS    0H
         LA    R15,4                  IF HERE, SET NON-ZERO RETURN CODE
PRCMRETX DS    0H
         DS@EXIT RET=R15
         SPACE
CLCMEM   CLC   MEMNAME(0),MEMBER
CLCUID   CLC   USERID(0),UDUSER
         SPACE
         DROP  R4,BASE
         TITLE 'INITDIR - INITIAL READ OF PDS DIRECTORIES'
**********************************************************************
*              I N I T D I R        R O U T I N E                    *
*                                                                    *
*     THIS SUBROUTINE DOES THE INITIAL READ OF ALL OF THE PDS        *
*   DIRECTORIES FOR EACH DATA SET IN DSTBL THAT IS ACTIVE (HAS A     *
*   POINTER IN DSPTRS).  THE READDIR SUBROUTINE IS USED TO DO THE    *
*   CALL SPAM TO DO THE I/O, AND DEBLOCK THE PDS DIRECTORY.          *
*                                                                    *
*     INPUT:  NUMDS - NUMBER OF ACTIVE DATA SETS (POINTERS IN DSPTRS)*
*             DSTBL - DATA SET TABLE                                 *
*             DSPTRS - POINTERS TO ACTIVE ELEMENTS OF DSTBL          *
*                                                                    *
**********************************************************************
         SPACE
         USING INITDIR,BASE
         SPACE
INITDIR  DS@ENTR ,
         LH    R4,NUMDS               GET NUMBER OF DATA SETS
         LA    R3,DSPTRS              ADDRESS DSPTR TABLE
IDRLOOP  DS    0H
         L     R11,0(R3)              ADDRESS DSTBL ELEMENT
         ST    R11,CURDSN             SAVE AS CURRENT
         OI    FLAG,GETBLK            INDICATE PHYSICAL I/O REQUIRED
         DO    READDIR                AND INITIAL CHECK
         LA    R3,4(R3)               NEXT DSPTRS ENTRY
         BCT   R4,IDRLOOP             AND LOOP
         DS@EXIT ,
         SPACE
         DROP  BASE
         TITLE 'READDIR - READ NEXT PDS DIRECTORY'
**********************************************************************
*              R E A D D I R        R O U T I N E                    *
*                                                                    *
*     THIS SUBROUTINE READS THE CURRENT PDS DIRECTORY FOR THE NEXT   *
*   MEMBER ENTRY.   R11   IS USED TO IDENTIFY THE CURRENTLY ACTIVE   *
*   DATA SET.  AN ACTUAL I/O MAY OR MAY NOT BE PERFORMED--IF THE     *
*   GETBLK FLAG IN DSTBL IS SET, THAN A PHYSICAL I/O OCCURS (THIS    *
*   IS NORMALLY USED FOR JUST THE INITIAL READ), OTHERWISE AN I/O    *
*   OCCURS ONLY AT THE END OF A BLOCK. THE ROUTINE SETS DIRPTR       *
*   (POINTER TO THE CURRENT MEMBER ENTRY), AND BLKCNT (THE RESIDUAL  *
*   DIRECTORY BLOCK COUNT).                                          *
*                                                                    *
*     INPUT:  R11 - CURRENT ACTIVE ELEMENT IN DSTBL                  *
*             DIRPTR/BLKCNT - IN DSTBL IF BLOCK ALREADY READ         *
*                                                                    *
*     OUTPUT: DIRPTR - POINTER TO NEW MEMBER ENTRY IN DIRECTORY      *
*             BLKCNT - UPDATED RESIDUAL BLOCK COUNT                  *
*                                                                    *
**********************************************************************
         SPACE
         USING READDIR,BASE
         SPACE
READDIR  DS@ENTR ,
         TM    FLAG,EOFDSL            IF EOF ON CURRENT DATA SET THEN
         BO    EODDIR                   BE SURE OF IT, AND LEAVE
         TM    FLAG,GETBLK            IF DIRECTORY BLOCK ^ NEEDED THEN
         BZ    READLOG                  SKIP TO READ LOGICAL ENTRY
READPHY  DS    0H
         MVC   SPBSFB,DIRSFB          SET FILE BLOCK POINTER
         MVI   SPBFUNC,SPBFGET        FUNCTION IS GET
         CALL  SPAM,(SPB),VL,MF=(E,SPAMPL) GO READ FROM THE PDS MEMBER
         LH    R15,SPBRETC            GET READ RETURN CODE
         LTR   R15,R15                IF NON-ZERO, THEN
         BNZ   EODDIRP                  ASSUME END OF FILE (DIRECTORY)
         LH    R1,DIRBLKU             GET # OF DIRECTORY BLOCKS
         LA    R1,1(,R1)              INCREMENT IT
         STH   R1,DIRBLKU             AND SAVE BACK
         L     R5,SPBREC              GET RECORD ADDRESS
         LA    R5,0(,R5)              CHOB IT
         LH    R8,0(R5)               GET COUNT FOR THIS BLOCK
         SH    R8,=H'2'               ADJUST COUNT FOR LENGTH
         STH   R8,BLKCNT              SAVE IN DSTBL FOR NEXT TIME
         LA    R8,2(R5)               ADDRESS MEMBER ENTRY
         ST    R8,DIRPTR              SAVE IN DSTBL FOR LATER
         NI    FLAG,255-GETBLK        TURN OFF FLAG
         B     RDDRET                 AND LEAVE
         SPACE
READLOG  DS    0H
         L     R7,DIRPTR              ADDRESS CURRENT MEMBER
         USING MEMENTRY,R7
         IC    R8,CFIELD              GET SIZE OF CURRENT ENTRY
         SLL   R8,27                  CLEAR TTR AND ALIAS FLAGS
         SRL   R8,26                  MULT # OF USER HALFWORDS BY 2
         LA    R8,12(R8)              GET PAST MEMBER NAME, TTR ETC
         LH    R9,BLKCNT              GET BLOCK COUNT
         SR    R9,R8                  IF NONE LEFT IN THIS BLOCK
         BC    12,READPHY               GO GET NEXT BLOCK
         AR    R8,R7                  ADDRESS OF NEXT MEMBER
         ST    R8,DIRPTR              STORE IN DSTBL FOR LATER
         STH   R9,BLKCNT              SAVE AWAY NEW BLOCK COUNT
RDDRET   DS    0H
         DS@EXIT ,
         SPACE
**********************************************************************
*     HERE WE INDICATE END OF DIRECTORY.  WE CAN GET HERE AFTER END  *
*  OF FILE IS RETURNED FROM A READ,    OR WHEN LOGICAL END OF        *
*  DIRECTORY IS REACHED BECAUSE OF A GENERIC MEMBER NAME PASSED.     *
*  IN EITHER CASE WE WAS SET DIRPTR TO POINT TO SOMETHING THAT LOOKS *
*  LIKE THE END OF THE DIRECTORY (IN THIS CASE, THE CONSTANT ENDDIR).*
**********************************************************************
         SPACE
EODDIRP  DS    0H
         OI    FLAG,EOFDSP            INDICATE PHYSICAL END DIR
EODDIR   DS    0H
         L     R8,=A(ENDDIR)          ADDRESS ENDDIR CONSTANT
         ST    R8,DIRPTR              STORE IN DSTBL FOR LATER
         B     RDDRET                 AND GET OUT
         SPACE
         LTORG
         SPACE
         DROP  R7,BASE
         TITLE 'GETCURDR - DETERMINE CURRENT PDS DIRECTORY TO USE'
**********************************************************************
*             G E T C U R D R       R O U T I N E                    *
*                                                                    *
*     THIS SUBROUTINE DETERMINES WHICH PDS DIRECTORY IS TO BE USED   *
*   BASED ON THE MEMBER NAME (THE MERGE IS DONE IN COLLATING SEQ-    *
*   UENCE). UPON RETURN, CURDSN IS SET TO POINT TO THE DSTBL ELEMENT *
*   WHOSE PDS DIRECTORY WAS DETERMINED TO BE THE CURRENT ONE TO USE. *
*                                                                    *
*     INPUT:  NUMDS - NUMBER OF ACTIVE DATA SETS (POINTERS IN DSPTRS)*
*             DSTBL - DATA SET TABLE                                 *
*             DSPTRS - POINTERS TO ACTIVE ELEMENTS OF DSTBL          *
*                                                                    *
*     OUTPUT: CURDSN - POINTS TO DSTBL ELEMENT AS THE CURRENT ONE    *
*                                                                    *
**********************************************************************
         SPACE
         USING GETCURDR,BASE
         SPACE
GETCURDR DS    0H
         LH    R1,NUMDS               GET NUMBER OF DATA SETS
         BCTR  R1,0                     LESS 1
         LTR   R1,R1                  IF ONLY 1 DS TO BEGIN WITH THEN
         BZR   R14                      LEAVE BECAUSE NOTHING TO DO
         DS@ENTR ,
         LR    R9,R1                  USE R9 FOR INDEX
         LA    R5,DSPTRS              ADDRESS DSPTR TABLE
         L     R11,0(R5)              ADDRESS FIRST DSTBL ELEMENT
         ST    R11,CURDSN             SAVE AS CURRENT
         LR    R8,R11                 COPY R11
         L     R7,DIRPTR              GET CORRESPONDING DIRECTORY PTR
GCLOOP   DS    0H
         LA    R5,4(R5)               NEXT DSPTR
         L     R11,0(R5)              ADDRESS DSTBL ELEMENT
         L     R2,DIRPTR              GET CORRESPONDING DIRECTORY PTR
         CLC   0(8,R7),0(R2)          IF CURRENT ^ LESS
         BNH   GCSKIP1
         ST    R11,CURDSN               SAVE CURRENT DSN ELEMENT
         LR    R7,R2                    NEW DIRECTORY, TOO
GCSKIP1  DS    0H
         BCT   R9,GCLOOP              AND LOOP
         DS@EXIT ,
         SPACE
         DROP  BASE
         TITLE 'PROCESS SINGLE MEMBER EDIT/BROWSE'
**********************************************************************
*              P R C E D B R        R O U T I N E                    *
*                                                                    *
*     THIS SUBROUTINE PROCESS THE EDIT/BROWSE FOR A SINGLE MEMBER    *
*   OF A PDS (OR PDS CONCATENATION).                                 *
*                                                                    *
**********************************************************************
         SPACE
         USING PRCEDBR,BASE
         SPACE
PRCEDBR  DS@ENTR ,
         XC    CALLPL(CALLPLL),CALLPL CLEAR CALL PARM LIST
         CLI   TRACE,C'T'             IF TRACE NOT SPECIFIED, THEN
         BE    PRCEDB05
         CALL  ISPLINK,(=CL8'CONTROL',=CL8'ERRORS',=CL8'RETURN'),VL,   +
               MF=(E,CALLPL)
PRCEDB05 DS    0H
         MVI   EDBRFLG,FLAGOFF        ASSUME BROWSE
         CLI   MODE,C'E'              IF EDIT MODE, THEN
         BNE   *+8
         MVI   EDBRFLG,FLAGON           SET MODE FOR EDIT/BROWSE SUB.
         MVC   TBMEM,MEMBER           MOVE IN MEMBER NAME
         TM    FLAGBYT3,NOTPODS       IF PO DATASET, THEN
         BO    PRCEDB15
         OI    FLAGBYT2,ALCONLY         SET FLAG FOR ALLOCDIR SUB.
         DO    ALLOCDIR                 GO GET US SOME DDNAMES
         LTR   R15,R15                  IF BAD RC FROM ROUTINE, THEN
         BNZ   PRCEDBRX                   GET OUT OF HERE
PRCEDB15 DS    0H
         DO    CONCAT                 GET US A DATAID
         LTR   R15,R15                IF RETURN CODE 0, THEN
         BNZ   PRCEDBRX
         DO    EDBROW                   DO THE EDIT/BROWSE
         DO    DECONCAT                 UNCONCAT IT
PRCEDBRX DS    0H
         DS@EXIT RET=R15
         SPACE
         DROP  BASE
         TITLE 'PROCESS TABLE DISPLAY ROUTINE'
**********************************************************************
*              P R O C T B L        R O U T I N E                    *
*                                                                    *
*     THIS SUBROUTINE DISPLAYS THE TABLE BUILT ABOVE, AND PROCESSES  *
*   THE USER SELECTIONS FROM THE DISPLAY.  'END' FROM THE TBDISPL    *
*   (RC = 8) IS HOW WE EXIT THIS SUBROUTINE, AND THE PROGRAM ITSELF. *
*     INPUT: R14 - RETURN ADDRESS                                    *
*            TABLE BUILT FROM BEFORE                                 *
*                                                                    *
**********************************************************************
         SPACE
         USING PROCTBL,BASE
         SPACE
PROCTBL  DS@ENTR ,
         DO    CONCAT                 CONCATENATE/LMINIT IF NEEDED
         NI    FLAGBYT3,255-DONE      RESET THE FLAG
         TM    VARDFFLG,TBPVARDF      IF NEED DEFINE TBL PROCESS. VARS
         BO    PROCTB05
         L     R1,=A(VTBL6)             ADDRESS VARIABLE TABLE
         LA    R2,VTBL6#                GET NUMBER IN TABLE
         STM   R1,R2,VARTBLA            SAVE IN PARM LIST
         DO    DEFVARS                  VDEFINE VARS FOR TABLE PROCESS
         OI    VARDFFLG,TBPVARDF        SAY NOW VDEFINED
         MVC   PRTDSN,BLANKS          SET THIS TO BLANKS
         MVC   CPYDSNAM,BLANKS        MOVE BLANKS TO COPY DSNAME
         MVC   FINDPARM,BLANKS        SET THIS TO BLANKS
         MVC   CPYDDNAM,BLANKS        SET THIS TO BLANKS
         MVC   ZTDMARK,ZTDMARKM       MOVE MASK FOR ZTDMARK
         MVI   CMDSERV,FLAGON         SET FLAG FOR SERVICE CALL
         MVC   DS@MODE,MODE           SET MODE INITIALLY
         NI    FLAGBYT3,255-INITSCAN  RESET THE FLAG
         DO    MODECMD                GO PROCESS MODE
         CLI   TRACE,C'T'             IF TRACE NOT SPECIFIED, THEN
         BE    PROCTB05
         CALL  ISPLINK,(=CL8'CONTROL',=CL8'ERRORS',=CL8'RETURN'),VL,   +
               MF=(E,CALLPL)
PROCTB05 DS    0H
         MVC   AUTOSEL,=CL8'NO'       INIT AUTO SELECT
         MVI   RBLDFLAG,FLAGOFF       BE SURE THIS IS RESET
         MVI   SWITCHF,FLAGOFF        BE SURE THIS IS RESET
DISPTBL1 DS    0H
         MVC   SAVSEL,BLANKS          BLANK OUT SAVE SELECT CODE
         MVC   SCRHORZ,=CL8'PASSTHRU' SET HORIZONTAL SCROLL TO PASSTHRU
         DO    GETPAN                 GO GET THE PANEL NAME
         DO    TBTOP                  GET TO TOP OF TABLE
         L     R2,CURTBLNM            ADDRESS TABLE NAME
         LA    R3,SKIPNUM
         CALL  ISPLINK,(=CL8'TBSKIP',(R2),(R3)),VL,MF=(E,CALLPL)
         LA    R3,TBPANEL             ADDRESS PANEL NAME
         LA    R4,CRP                 ADDRESS CURRENT ROW POINTER
         LA    R5,AUTOSEL             ADDRESS AUTOSEL PARM
         XC    CALLPL(CALLPLL),CALLPL CLEAR PARM LIST
         CALL  ISPLINK,(=CL8'TBDISPL',(R2),(R3),,,(R4),,(R5),=CL8'CRP')+
               ,VL,MF=(E,CALLPL)
         MVC   SCRHORZ,BLANKS         SET HORIZONTAL SCROLL TO DEFAULT
         MVC   SKIPNUM,ZTDTOP         SAVE ZTDTOP VALUE
         MVI   FLAGBYT2,0             CLEAR THE FLAG BYTE
         LTR   R15,R15                IF RC FROM TBDISPL = 0,
         BZ    BIGLOOP                  THEN SKIP
         C     R15,=F'4'              IF RC FROM TBDISPL ^= 4
         BNE   TBLDONE                  THEN DONE
         OI    FLAGBYT2,MANY          INDICATE MANY TO PROCESS
BIGLOOP  DS    0H
         MVC   LASTMEM,TBMEM          SAVE MEMBER NAME
         MVC   SAVCMDL,CMDLINE        SAVE CMDLINE FROM DISPLAY
         MVI   STAXFLAG,FLAGOFF       BE SURE TO RESET THIS FLAG
         CLI   TBLIB#,C' '            IF MEMBER ALREADY DELETED,
         BE    BGSKIP5                  THEN IGNORE THIS ONE
         DO    SETCURDS               SET CURRENT DATA SET
         LR    R11,R15                GET VALUE RETURNED INTO BASE
         L     R15,=A(TBLUPPER)       ADDRESS TRANSLATE TABLE
         TR    TBSEL,0(R15)           TRANSLATE TBSEL TO UPPER CASE
         CLC   TBSEL,=CL3'='          IF EQUAL ^ ENTERED THEN
         BNE   BGSKIP1                   SKIP
         MVC   TBSEL,SAVSEL           ELSE MOVE IN SELECT CODE SAVED
BGSKIP1  DS    0H
         MVC   SAVSEL,TBSEL           SAVE SEL CODE FOR LATER
         MVC   WORD0,BLANKS           BLANK WORD0
         MVC   WORD0(3),TBSEL         MOVE SELECT CODE TO WORD0
         MVC   TBSEL,BLANKS           BLANK TABLE SELECTION
         DO    GETCMD                 SEE IF COMMAND IS VALID
         LTR   R6,R15                 IF COMMAND IS INVALID  OR
         BZ    BGINVCMD
         TM    CMDFLAG,CMDLONLY            COMMAND LINE COMMAND,
         BZ    BGDSPTCH
BGINVCMD DS    0H
         MVC   TBSTAT,=C'*???'
         MVC   AUTOSEL,=CL8'YES'         SET AUTOSEL TO YES
         NI    FLAGBYT2,255-MANY         TURN OFF MANY
         LA    R1,MSG13                  SET THE MESSAGE
         DO    PUTMSG                    GO GIVE IT TO ISPF
         B     DISPTBL1                  AND LOOP
BGDSPTCH DS    0H
         L     R15,CMDADDR              ELSE GET COMMAND ADDRESS
         BALR  R14,R15                    DISPATCH IT
         LTR   R15,R15                    IF RETURN FROM COMMAND BAD
         BNZ   DISPTBL1                     RESHOW
         MVC   AUTOSEL,=CL8'NO'           ELSE SET AUTOSEL TO NO
         DO    PUTTBL                     UPDATE THE TABLE
BGSKIP5  DS    0H
         TM    FLAGBYT2,MANY          Q.MORE TO PROCESS?
         BO    MORE                   Y.THEN SKIP
         DO    PROCCMDL               GO SEE IF CMDLINE GIVEN
         CLI   RBLDFLAG,FLAGON        IF REBUILD COMMAND ENTERED,
         BE    TBLDONEX                 GET OUT OF HERE
         B     DISPTBL1               ELSE GO AGAIN
*                                     IF HERE, MORE ENTRIES TO PROCESS
MORE     DS    0H
         CLI   STAXFLAG,FLAGON        IF ATTENTION HIT, THEN
         BE    DISPTBL1                 GET OUT OF LOOP
         L     R2,CURTBLNM
         XC    CALLPL(CALLPLL),CALLPL
         CALL  ISPLINK,(=CL8'TBDISPL',(R2),,,,,=F'0',,=CL8'CRP'),VL,   +
               MF=(E,CALLPL)
         LTR   R15,R15                  IF NOT MULTIPLE "SELECTS",
         BNZ   BIGLOOP
         NI    FLAGBYT2,255-MANY          INDICATE ONLY ONE LEFT
         B     BIGLOOP                    AND GO PROCESS IT
         SPACE
TBLDONE  DS    0H
         DO    POPTBL                 DONE, SO DO TBEND
TBLDONEX DS@EXIT ,
         SPACE
ZTDMARKM DC    C'***************************** END OF MEMBER LIST *****+
               *************************'
         SPACE
         DROP  BASE
         TITLE 'POPTBL SUBROUTINE'
**********************************************************************
*                 P O P T B L       S U B R O U T I N E              *
*                                                                    *
*      THIS SUBROUTINE "POPS" THE CURRENT TABLE OFF OF THE STACK,    *
*   AND UPDATES THE TABLE NAME COUNTER.  WHEN THIS COUNTER REACHES   *
*   ZERO, THEN THE TABLE VARIABLES ARE DELETED.                      *
*                                                                    *
**********************************************************************
         SPACE
         USING POPTBL,BASE
         SPACE
POPTBL   DS@ENTR ,
         L     R3,NUMTBLNM            GET NUMBER OF TABLE NAMES
         LTR   R3,R3                  IF ALREADY ZERO, THEN
         BNZ   *+4+2                       LOGIC ERROR, SO
         DC    H'0'                     DIE 0C2
         L     R2,CURTBLNM            ELSE ADDRESS CURRENT NAME
         DO    TBEND                    GET RID OF TABLE
         MVC   TBLNAME,BLANKS           BLANK OUT THE NAME
         XC    NUMMEM,NUMMEM            ZERO NUMBER IN TABLE
         XC    SKIPNUM,SKIPNUM          CLEAR SKIPNUM
         BCTR  R3,0                     DECREMENT COUNTER
         ST    R3,NUMTBLNM              UPDATE COUNTER
         L     R1,DS@LVL                GET LEVEL
         BCTR  R1,0                     DECREMENT IT
         ST    R1,DS@LVL                SAVE IT BACK
         LTR   R3,R3                    IF STILL A CURRENT TABLE,
         BZ    POPTBL5
         S     R2,=AL4(TABLEL)            GET PREV NAME ADDRESS
         ST    R2,CURTBLNM                SAVE AS CURRENT
         L     R1,NUMMEM                  GET NUMBER IN THIS TABLE
         ST    R1,MPR                     SAVE FOR LATER
         B     POPTBLX
POPTBL5  DS    0H                       ELSE
         L     R2,=A(TBLVARS)
         TM    FLAGBYT3,LOADLIB           IF LOAD LIBRARIES, THEN
         BZ    *+8
         L     R2,=A(TBLVARSL)              USE OTHER TABLE VARIABLES
POPTBLX  DS@EXIT ,
         SPACE
         DROP  BASE
         TITLE 'TBEND SUBROUTINE'
**********************************************************************
*                T B E N D          R O U T I N E                    *
*                                                                    *
*     ISSUE ISPF TBEND SERVICE.  UPON INPUT, R2 ADDRESSES THE TABLE  *
*  NAME TO ISSUE THE TBEND FOR.                                      *
*                                                                    *
**********************************************************************
         SPACE
         USING TBEND,BASE
TBEND    DS@ENTR ,
         CALL  ISPLINK,(=CL8'TBEND',(R2)),VL,MF=(E,CALLPL)
         LTR   R15,R15                IF RETURN CODE ^= 0, THEN
         BZ    *+4+2
         DC    H'0'                     DIE 0C1
TBENDX   DS@EXIT ,
         SPACE
         DROP  BASE
         TITLE 'EDIT COMMAND PROCESSOR'
**********************************************************************
*              E D I T M E M        R O U T I N E                    *
*                                                                    *
*     THE EDITMEM CODE ISSUES THE ISPF EDIT COMMAND, AND IF THE      *
*   THE MEMBER WAS ACTUALLY SAVED TO DISK, IT GETS THE NEW DIRECTORY *
*   INFORMATION (VIA A FIND) AND CALLS THE UPDMEM   ROUTINE TO       *
*   MOVE AND CONVERT THIS INFORMATION TO THE TABLE VARIABLES.        *
**********************************************************************
         SPACE
         USING EDITMEM,BASE
         SPACE
EDITMEM  DS@ENTR ,
         NI    FLAGBYT3,255-NEWEDM    RESET THIS FLAG
         TM    FLAGBYT2,CMDLPRC       IF ^COMMAND LINE PROCESSING
         BO    EDITM05
         OI    FLAGBYT2,NORSKIP         DON'T RESET SKIP NUMBER
EDITM05  DS    0H
         DO    TBTOP                  GET TO TOP OF TABLE
         DO    FNDTBMEM               SEE IF MEMBER EXISTS
         LTR   R15,R15                IF NOT, THEN
         BZ    EDITSEL
         OI    FLAGBYT3,NEWEDM          ASSUME NEW MEMBER WANTED
EDITSEL  DS    0H
         L     R11,CURDSN             LOAD CURRENT DS VALUE INTO BASE
         MVI   EDBRFLG,FLAGON         SAY 'EDIT'
         DO    EDBROW                 GO DO THE EDIT
         MVC   TBSTAT,BLANKS          BLANK OUT STATUS
         LTR   R15,R15                IF RC ^= 0 THEN
         BZ    EDMEMOK
         CH    R15,=H'4'                IF "CANCEL", THEN
         BNE   EDITMEMX
         SLR   R15,R15                    THIS IS OK, SO CLEAR RC
         B     EDITMEMX                   AND WE'RE DONE
EDMEMOK  DS    0H
         L     R11,DSTABL@              SET CURRENT DSN
         ST    R11,CURDSN               SET HERE ALSO
         MVC   TBSTAT,=CL8'*SAVED'      SET STATUS
         DO    GETSTATS                 ELSE GO GET NEW ISPF STATS
         MVC   LASTMEM,TBMEM              SET INPUT FOR ROUTINE
         DO    UPDOTBL                    SEE IF OTHER TABLES TO UPDATE
         TM    FLAGBYT3,NEWEDM            IF NEW MEMBER, THEN
         BZ    EDITMEMX
         MVC   TBSTAT,=CL8'*NEW'            SET STATUS
         DO    ADDNMEM                      GO ADD IT TO THE TABLE
EDITMEMX DS    0H
         DS@EXIT RET=R15
         SPACE
         DROP  BASE
         TITLE 'GET ISPF STATS FOR A MEMBER'
**********************************************************************
*              G E T S T A T S      R O U T I N E                    *
*                                                                    *
*     THIS SUBROUTINE GET THE ISPF STATS FOR A MEMBER IDENTIFIED IN  *
*  TBMEM, AND BUILDS THE INFORMATION INTO THE TABLE VARIABLES.  IF   *
*  THE MEMBER IS NOT FOUND FOR SOME REASON, THEN A NON-ZERO RETURN   *
*  CODE IS RETURNED TO THE CALLER IN R15.                            *
*                                                                    *
**********************************************************************
         SPACE
         USING GETSTATS,BASE
         SPACE
GETSTATS DS    0H
         DS@ENTR ,
         MVC   BLDNAME,TBMEM            ELSE GET READY TO ISSUE BLDL
         MVI   SPBFUNC,SPBFFIND           FUNCTION CODE IS FIND
         MVC   SPBMEM,TBMEM               MOVE IN MEMBER NAME
         MVC   SPBSFB,INPSFB              SET FILE BLOCK POINTER
         LA    R1,BLDLIST                 ADDRESS BLDLIST
         ST    R1,SPBFDBK                 THIS IS FEEDBACK AREA
         LA    R1,BLDLISTL                GET LENGTH OF BLDLIST
         STC   R1,SPBFDBKL                SET AS FEEDBACK AREA LENGTH
         CALL  SPAM,(SPB),VL,MF=(E,SPAMPL) GO DO THE FIND
         XC    SPBFDBK,SPBFDBK            CLEAR FEEDBACK AREA POINTER
         LH    R15,SPBRETC                IF FOUND, THEN
         LTR   R15,R15
         BNZ   GETSTATX
         DO    UPDMEM                       GO GET NEW DIRECTORY INFO
         SLR   R15,R15                      CLEAR RETURN CODE
GETSTATX DS    0H
         DS@EXIT RET=R15
         SPACE
         DROP  BASE
         TITLE 'UPDATE OTHER TABLES ROUTINE'
**********************************************************************
*              U P D O T B L        R O U T I N E                    *
*                                                                    *
*     THIS SUBROUTINE UPDATES THE STATISTICS VARIABLES FOR IDENTICAL *
*  MEMBERS IN LOWER (STACKED) TABLES AFTER THE ISPF STATS ARE MODI-  *
*  FIED (FOR INSTANCE, AFTER EDIT, DELETE, RENAME, MOVE).  INPUT TO  *
*  THIS ROUTINE IS THE FIELD LASTMEM WHICH CONTAINS THE OLD MEMBER   *
*  NAME.                                                             *
*                                                                    *
**********************************************************************
         SPACE
         USING UPDOTBL,BASE
         SPACE
UPDOTBL  DS@ENTR ,
         L     R4,NUMTBLNM              GET NUMBER OF TABLES
         BCTR  R4,0                     DON'T DO CURRENT TABLE
         LTR   R4,R4                    SEE IF WE HAVE ANY TO DO
         BNH   UPDOTBLX
         MVC   TBVARSVA,TBSEL           SAVE CURRENT VARIABLES
         L     R3,CURTBLNM              SAVE CURRENT TABLE NAME ADDR
         LA    R2,TBLNAMES              GET 1ST TABLE NAME
UPDOLP   DS    0H                       DO WHILE (MORE TABLES)
         ST    R2,CURTBLNM                SAVE TBL NAME ADDR FOR TBTOP
         DO    TBTOP                      GET TO TOP OF TABLE
         MVC   TBMEM,LASTMEM              MOVE IN MEMBER NAME
         CALL  ISPLINK,(=CL8'TBSCAN',(R2),=C'(TBMEM)'),VL,             +
               MF=(E,CALLPL)
         LTR   R15,R15                    IF MEMBER NOT FOUND, THEN
         BZ    *+4+2
         DC    H'0'                         DIAGNOSTIC ABEND
         MVC   TBSEL(LNGTBL),TBVARSVA     ELSE SET TABLE VARIABLES
         CALL  ISPLINK,(=CL8'TBPUT',(R2)),VL,MF=(E,CALLPL) UPDATE IT
         LA    R2,TABLEL(,R2)               NEXT TABLE
         BCT   R4,UPDOLP                LOOP
         ST    R3,CURTBLNM              RESTORE CURRENT TBL NAME ADDR
UPDOTBLX DS    0H
         SLR   R15,R15                  ALWAYS RETURN RC = 0
         DS@EXIT RET=R15
         SPACE
         DROP  BASE
         TITLE 'ADD NEW MEMBER TO THE TABLE'
**********************************************************************
*              A D D N M E M        R O U T I N E                    *
*                                                                    *
*     THIS SUBROUTINE ADDS A NEW MEMBER TO THE TABLE IN ITS PROPER   *
*  PLACE.                                                            *
*                                                                    *
**********************************************************************
         SPACE
         USING ADDNMEM,BASE
         SPACE
ADDNMEM  DS    0H
         DS@ENTR ,
         L     R2,CURTBLNM                  ADDRESS TABLE NAME
         TM    FLAGBYT3,NDEFSORT           IF TABLE ^ SORTED BY TBMEM,
         BZ    ADDNM10
         CALL  ISPLINK,(=CL8'TBADD',(R2)),VL,MF=(E,CALLPL)  ADD IT
         L     R1,NUMMEM                      GET NUMBER IN TABLE
         LA    R1,1(,R1)                      INCREMENT THIS COUNT
         ST    R1,NUMMEM                      NOW PUT IT BACK
         LA    R3,=A(TBSRTBFL)                GET SORT BUFFER LENGTH
         LA    R4,TBSRTBUF                    ADDRESS SORT BUFFER
         CALL  ISPEXEC,((R3),(R4)),VL,MF=(E,CALLPL) DO THE SORT
         SLR   R15,R15                        SET RC
         B     ADDNM50                        AND DONE
ADDNM10  DS    0H                         ELSE (TABLE SORTED BY TBMEM)
         MVC   LASTMEM,TBMEM                  SAVE MEMBER NAME
         MVC   TBVARSVA,TBSEL                 SAVE NEW TABLE ENTRY
         DO    TBTOP                          GET TO TOP OF TABLE
ADDNMLP  DS    0H
         CALL  ISPLINK,(=CL8'TBSKIP',(R2),=F'1'),VL,MF=(E,CALLPL)
         LTR   R15,R15                        IF TABLE BOTTOM HIT,
         BZ    ADDNM20                           REPOSITION TO BOTTOM
         CALL  ISPLINK,(=CL8'TBBOTTOM',(R2)),VL,MF=(E,CALLPL)
         B     ADDNM30                           AND WE'RE DONE
ADDNM20  DS    0H
         CLC   TBMEM,LASTMEM              IF RIGHT PLACE IN TBL TO ADD,
         BL    ADDNMLP                             BACK UP ONE
         CALL  ISPLINK,(=CL8'TBSKIP',(R2),=F'-1'),VL,MF=(E,CALLPL)
ADDNM30  DS    0H
         MVC   TBSEL(LNGTBL),TBVARSVA              RESTORE NEW ENTRY
         CALL  ISPLINK,(=CL8'TBADD',(R2)),VL,MF=(E,CALLPL)  ADD IT
         L     R1,NUMMEM                           GET NUMBER IN TABLE
         LA    R1,1(,R1)                           INCREMENT COUNT
         ST    R1,NUMMEM                           NOW PUT IT BACK
         SLR   R15,R15                    SET RC (REMEMBER, CMDL PROC)
ADDNM50  DS    0H
         DO    TBTOP                      GET TO TOP OF TABLE
         DO    FNDTBMEM                   "LOCATE" (SCROLL) NEW MEMBER
ADDNMEMX DS    0H
         DS@EXIT RET=R15
         SPACE
         DROP  BASE
         TITLE 'PDS MEMBER BROWSE ROUTINE'
**********************************************************************
*              B R O W M E M        R O U T I N E                    *
*                                                                    *
*     THIS ROUTINE PROCESSES THE BROWSE COMMAND.                     *
*                                                                    *
**********************************************************************
         SPACE
         USING BROWMEM,BASE
         SPACE
BROWMEM  DS@ENTR ,
         MVI   EDBRFLG,FLAGOFF        SAY 'BROWSE'
         DO    EDBROW                 GO DO THE BROWSE
         MVC   TBSTAT,BLANKS          BLANK OUT STATUS
*        OI    FLAGBYT2,NOPUT         DON'T DO TBPUT
BROWMEMX DS@EXIT RET=R15              AND RETURN
         SPACE
         DROP  BASE
         TITLE 'EDIT/BROWSE'
**********************************************************************
*              E D B R O W          R O U T I N E                    *
*                                                                    *
*     THIS ROUTINE ISSUES THE EDIT/BROWSE AS SPECIFIED BY EDBRFLG,   *
*   AND ISSUES THE EDIT/BROWSE FOR A CONCATENATION IF ONE IS IN      *
*   EFFECT.                                                          *
*     UPON RETURN, REGISTER 15 CONTAINS THE RETURN CODE FROM THE     *
*  EDIT OR BROWSE.                                                   *
**********************************************************************
         SPACE
         USING EDBROW,BASE
         SPACE
EDBROW   DS@ENTR ,
         XC    RCSAVE,RCSAVE         CLEAR RCSAVE
         XC    EDBRRC,EDBRRC         CLEAR EDIT/BROWSE RC
         TM    FLAGBYT4,MEMBLST       IF MEMBER LIST, THEN
         BZ    EDBR010                  RESTORE ISPF DISPLAY
         CALL  ISPLINK,(=CL8'CONTROL',=CL8'DISPLAY',=CL8'SAVE'),VL,    +
               MF=(E,CALLPL)
EDBR010  DS    0H                         ISSUE ISPF BROWSE
         LA    R2,=CL8'EDIT'          ASSUME EDIT
         CLI   EDBRFLG,FLAGOFF        IF BROWSE, THEN
         BNE   *+8
         LA    R2,=CL8'BROWSE'          LET IT BE BROWSE
         XC    CALLPL(CALLPLL),CALLPL CLEAR PARM LIST
         LA    R3,DATAID                ADDRESS IT
         LA    R4,TBMEM                 ADDRESS MEMBER NAME
         LA    R5,MIX                   ADDRESS MIX PARM
         LA    R6,FNAM                  ADDRESS FORMAT NAME PARM
         LA    R7,MAC                   ADDRESS INITIAL MACRO PARM
         LA    R8,PROF                  ADDRESS EDIT PROFILE
         CLI   EDBRFLG,FLAGOFF          IF EDIT, THEN
         BE    EDBR015                    ISSUE EDIT
         CALL  ISPLINK,((R2),,,,,(R7),(R8),(R3),(R4),(R6),(R5)),       +
               VL,MF=(E,CALLPL)
         B     EDBR030                  ELSE /* BROWSE */
EDBR015  DS    0H                         ISSUE ISPF BROWSE
         CALL  ISPLINK,((R2),,,,,(R3),(R4),(R6),(R5)),                 +
               VL,MF=(E,CALLPL)
EDBR030  DS    0H
         ST    R15,EDBRRC             SAVE RETURN CODE IN DSA
         CH    R15,=H'8'              IF SEVERE ERROR, THEN
         BNH   EDBR040
         LA    R1,MSG34                 SET MESSAGE NUMBER
         DO    PUTMSG                   SET A MESSAGE
         MVC   TBSTAT,=CL8'*ERROR'      INDICATE AN ERROR
EDBR040  DS    0H
         TM    FLAGBYT4,MEMBLST       IF MEMBER LIST, THEN
         BZ    EDBR045                  RESTORE ISPF DISPLAY
         CALL  ISPLINK,(=CL8'CONTROL',=CL8'DISPLAY',=CL8'RESTORE'),VL, +
               MF=(E,CALLPL)
EDBR045  DS    0H
         DO    SETEMSG                  GO SET A MESSAGE (EDIT ONLY)
EDBR050  DS    0H
         L     R15,EDBRRC             GET RETURN CODE
         DS@EXIT RET=R15              RETURN
         SPACE
         DROP  BASE
         TITLE 'SET EDIT MESSAGE ROUTINE'
**********************************************************************
*              S E T E M S G        R O U T I N E                    *
*                                                                    *
*     THIS ROUTINE SETS A MESSAGE IF EDIT MODE AND IF A SAVE WAS     *
*   DONE (EDBRRC = 0).                                               *
*                                                                    *
**********************************************************************
         SPACE
         USING SETEMSG,BASE
         SPACE
SETEMSG  DS    0H
         CLI   EDBRFLG,FLAGOFF        IF EDIT COMMAND, THEN
         BER   R14
         DS@ENTR ,
         CLC   EDBRRC,=F'0'             IF RETURN CODE ZERO, THEN
         BNE   SETEMSGX
         MVC   ZDSN,DSN1                  MOVE IN DATASET NAME
         MVC   ZMEMB,TBMEM                MOVE IN MEMBER NAME
         LA    R2,=CL8'ISRE016'           ASSUME PDS EDIT
         TM    FLAGBYT3,NOTPODS           IF ^PDS, THEN
         BZ    *+8
         LA    R2,=CL8'ISRE017'             USE ANOTHER MESSAGE
         CALL  ISPLINK,(=CL8'SETMSG',(R2)),VL,MF=(E,CALLPL)
SETEMSGX DS    0H
         DS@EXIT ,
         SPACE
         DROP  BASE
         TITLE 'PDS MEMBER RENAME ROUTINE'
**********************************************************************
*                R E N M E M        R O U T I N E                    *
*                                                                    *
*     THIS ROUTINE    CHECKS FOR A NEW NAME GIVEN, AND IF NOT, A     *
*   MESSAGE IS  SET  AND THE TABLE IS REDISPLAYED.  IF THE NEW NAME  *
*   IS GIVEN, A SPAM STOW  IS ISSUED TO PERFORM THE RENAME FUNCTION. *
*     RENAME IS VALID ONLY FOR A MEMBER IN THE FIRST DATASET OF A    *
*   CONCATENATION.  IF ATTEMPTED, AN ISPF MESSAGE IS SET.            *
*                                                                    *
**********************************************************************
         SPACE
         USING RENMEM,BASE
         SPACE
RENMEM   DS@ENTR ,
         TM    FLAGBYT2,CMDLPRC       IF COMMAND LINE PROCESSING
         BZ    RENM05
         CLC   TBSTAT,BLANKS            IF NEW NAME NOT THERE, THEN
         BNE   RENM05
         MVC   TBSTAT,WORD2               GET NEW NAME FROM WORD QUEUE
RENM05   DS    0H
         CLI   TBLIB#,C'1'            IF NOT 1ST LIB IN CONCATENATION,
         BE    RENOKLIB
         MVC   PARM1,=CL8'RENAME'       SET PARM VALUE FOR MSG
         CALL  ISPLINK,(=CL8'SETMSG',=CL8'ISRU019'),VL,MF=(E,CALLPL)
         LA    R15,4                    SET RETURN CODE
         B     RENMEMX                  AND WE'RE DONE
RENOKLIB DS    0H
         CLC   TBSTAT,BLANKS          Q.NEW NAME ENTERED?
         BE    RENERR                 Y.THEN OK, SO SKIP
         CLI   TBSTAT,C'*'            IF ASTERISK THERE, THEN
         BNE   REN1                     ASSUME BAD NEW NAME
RENERR   DS    0H
         MVC   TBSTAT,=CL8'*???'        MOVE IN QUESTION MARKS
         DO    PUTTBL                   UPDATE THE TABLE ENTRY
         LA    R1,MSG10                 SET THE MESSAGE
         DO    PUTMSG                   AND GO GIVE IT TO ISPF
         B     RENMEMX                  AND RETURN
REN1     DS    0H
         L     R15,=A(TBLUPPER)       ADDRESS TRANSLATE TABLE
         TR    TBSTAT,0(R15)          ENSURE UPPER CASE NEW NAME
         TM    FLAG,OPNBPAM           IF ALREADY OPENED, THEN
         BO    REN1SKP                  SKIP OPEN
         DO    ALCOPMEM               ELSE ALLOCATE/OPEN THE DATA SET
         LTR   R15,R15                IF NOT SUCCESSFUL THEN
         BNZ   RENMEMX                   GET OUT OF HERE
REN1SKP  DS    0H
         MVI   SPBFUNC,SPBFSTOW       FUNCTION IS STOW
         MVI   SPBOPT2,SPBSTCHG         RENAME
         MVC   SPBSMEM,TBMEM          SET OLD MEMBER NAME
         MVC   SPBSMEM+8(8),TBSTAT    SET NEW MEMBER NAME
         MVC   SPBSFB,MEMSFB          SET FILE BLOCK POINTER
         CALL  SPAM,(SPB),VL,MF=(E,SPAMPL) GO DO THE RENAME
         LH    R15,SPBREASN           GET RETURN CODE
         B     *+4(R15)               BRANCH DEPENDING ON RC
         B     RENOK                     SKIP
         B     RENRC4                 HANDLE RC = 4
         B     RENRC8                 HANDLE RC = 8
         B     RENRCC                 HANDLE RC = C
RENOK    DS    0H
         MVC   LASTMEM,TBMEM          SET INPUT FOR ROUTINE
         MVC   TBMEM,TBSTAT           RENAME, AND UPDATE THE TABLE
         MVC   TBSTAT,=CL8'*RENAMED'  WITH NEW NAME AND STATUS
         DO    UPDOTBL                UPDATE ANY OTHER TABLES
         B     RENMEMX                AND RETURN
         SPACE
RENRC4   DS    0H
         LA    R1,MSG19               SET THE MESSAGE
         MVC   PARM1,=CL8'RENAME'     SET COMMAND NAME IN MESSAGE
         B     RENBADRC               SO SET ISPF MESSAGE
         SPACE
RENRC8   DS    0H
         LA    R1,MSG18               SET THE MESSAGE
         B     RENBADRC               SO SET ISPF MESSAGE
         SPACE
RENRCC   DS    0H
         LA    R1,MSG20               SET THE MESSAGE
RENBADRC DS    0H
         MVC   TBSTAT,=CL8'*ERROR'    SET ERROR INDICATION
         DO    PUTTBL                 UPDATE THE TABLE
         DO    PUTMSG                 SO SET ISPF MESSAGE
RENMEMX  DS@EXIT RET=R15
         SPACE
         DROP  BASE
         TITLE 'PDS MEMBER DELETE ROUTINE'
**********************************************************************
*                D E L M E M        R O U T I N E                    *
*                                                                    *
*     THE DELMEM CODE ALSO USES THE SPAM STOW  TO PERFORM THE        *
*   DELETE.  STOW SHOULD FAIL IF THE MEMBER NAME IS INVALID, AND WE  *
*   SET A MEESAGE IF SO.  NOTE THAT DELETE IS VALID ONLY FOR A MEM-  *
*   BER IN THE FIRST DATASET OF A CONCATENATION.                     *
**********************************************************************
         SPACE
         USING DELMEM,BASE
         SPACE
DELMEM   DS@ENTR ,
         TM    FLAG,OPNBPAM           IF ALREADY OPENED, THEN
         BO    DELSKIP                  SKIP OPEN
         DO    ALCOPMEM               ELSE ALLOCATE/OPEN THE DATA SET
         LTR   R15,R15                IF NOT SUCCESSFUL THEN
         BNZ   DELMEMX                   GET OUT OF HERE
DELSKIP  DS    0H
         DO    DELRTN                 GO DO THE DELETE
         LTR   R15,R15                IF STOW RC = 0 THEN
         BNZ   DELMEMX                  SKIP
         MVC   TBSEL,BLANKS           BLANK OUT SELECTION CODE
         MVC   TBLIB#(LTBLSHRT),BLANKS   BLANK OUT THE TABLE ENTRY
         MVC   TBSTAT,=CL8'*DELETED'  GIVE THE STATUS
         MVC   LASTMEM,TBMEM          SET INPUT FOR ROUTINE
         CLC   NUMDS,=H'1'            IF MORE THAN 1 DATA SET, THEN
         BNH   DELNGTS
         DO    GETSTATS                 GET ISPF STATS FROM LOWER LEVEL
DELNGTS  DS    0H
         DO    UPDOTBL                UPDATE ANY OTHER TABLES
DELMEMX  DS@EXIT RET=R15
         SPACE
         DROP  BASE
         TITLE 'DS@SCPDS - DELETE ROUTINE'
**********************************************************************
*    THIS ROUTINE PERFORMS A DELETE FOR THE MEMBER IN TBMEM FOR THE  *
*  DATA SET GIVEN BY R11.     THIS ROUTINE IS CALLED BY BOTH THE     *
*  DELETE MEMBER, AND MOVE MEMBER COMMAND PROCESSORS.                *
**********************************************************************
         SPACE
         USING DELRTN,BASE
         SPACE
DELRTN   DS@ENTR ,
         CLI   TBLIB#,C'1'            IF NOT 1ST LIB IN CONCATENATION,
         BE    DELOKLIB
         MVC   PARM1,=CL8'DELETE'       SET PARM VALUE FOR MSG
         CALL  ISPLINK,(=CL8'SETMSG',=CL8'ISRU019'),VL,MF=(E,CALLPL)
         LA    R15,4                    SET RETURN CODE
         B     DELRTNX                  AND GET OUT OF HERE
DELOKLIB DS    0H
         MVI   SPBFUNC,SPBFSTOW       FUNCTION IS STOW
         MVI   SPBOPT2,SPBSTDEL          DELETE
         MVC   SPBSMEM,TBMEM          SET MEMBER NAME TO DELETE
         MVC   SPBSFB,MEMSFB          SET FILE BLOCK POINTER
         CALL  SPAM,(SPB),VL,MF=(E,SPAMPL) GO DO THE RENAME
         L     R2,CURTBLNM            GET CURRENT TABLE NAME
         L     R1,NUMMEM              GET NUMBER IN TABLE
         BCTR  R1,0                   DECREMENT THIS COUNT
         ST    R1,NUMMEM              NOW PUT IT BACK
         LH    R15,SPBREASN           GET RETURN CODE
DELRTNX  DS    0H
         DS@EXIT RET=R15
         SPACE
         DROP  BASE
         TITLE 'PDS MEMBER PRINT ROUTINE'
**********************************************************************
*                 P R M E M         R O U T I N E                    *
*                                                                    *
*     THE ROUTINE TO PRINT A MEMBER CALLS A LOAD MODULE TO ACTUALLY  *
*   DO THE I/O.  THE PARM BLOCK IS USED TO COMMUNICATE WHICH MEMBER  *
*   TO PRINT, AND ANY SYSOUT FILE OPTIONS.  IF THIS IS THE FIRST     *
*   MEMBER PRINT (OR A FREE COMMAND HAS BEEN ISSUED), WE DISPLAY A   *
*   PANEL FOR THE USER TO ENTER PRINT OPTIONS (DESTINATION, COPIES,  *
*   HEADER, ETC).                                                    *
*                                                                    *
**********************************************************************
         SPACE
         USING PRMEM,BASE
         SPACE
PRMEM    DS@ENTR ,
         CLI   PRTDISP,FLAGON         IF PRINT ^ YET PANEL DISPLAYED,
         BE    PRMEM1
         CLI   PRTDSN,C' '              IF PRT DSN BLANK, THEN
         BNE   PRNODV
         L     R1,=A(VTBL2)               ADDRESS VARIABLE TABLE
         LA    R2,VTBL2#                  GET NUMBER IN TABLE
         STM   R1,R2,VARTBLA              SAVE IN PARM LIST
         DO    DEFVARS                    DO THE VDEFINE
PRNODV   DS    0H
         L     R1,DSNAME@
         MVC   PRTDSN,0(R1)             SET DATA SET NAME
         CALL  ISPLINK,(=CL8'CONTROL',=CL8'DISPLAY',=CL8'SAVE'),VL,    +
               MF=(E,CALLPL)
         CALL  ISPLINK,(=CL8'DISPLAY',=CL8'DS@SCPDP'),VL,MF=(E,CALLPL)
         STH   R15,RCSAVE               SAVE RETURN CODE
         CALL  ISPLINK,(=CL8'CONTROL',=CL8'DISPLAY',=CL8'RESTORE'),VL, +
               MF=(E,CALLPL)
         LH    R15,RCSAVE               RESTORE RETURN CODE
         LTR   R15,R15                  IF RETURN CODE NOT ZERO
         BNZ   PRMEMX                     GET OUT OF HERE
         MVI   PRTDISP,FLAGON           SAY NOW WE HAVE DONE IT
         MVC   PRTDEST,DEST             SET DESTINATION FOR PRINT
         MVC   PRTHOLD,HOLD             SET HOLD INDICATOR
         MVC   PRTHEAD,HEAD             SET HEAD INDICATOR
         MVC   PRTSNUM,SNUM             SET SNUM INDICATOR
         MVC   PRTFORM,FORM             SET FORM SPECIFIED
         MVC   PRTUCS,UCS               SET UCS SPECIFIED
         LR    R1,R13                   COPY DSA ADDRESS
         AH    R1,=AL2(SPAMDSA-DS@SCPDD) ADD OFFSET FOR THIS
         ST    R1,PRTSPMD@              SAVE IN PARM BLOCK
         L     R1,CP                    GET COPY PARM
         LTR   R1,R1                    IF NOT ZERO, THEN
         BZ    PRMEM1
         STC   R1,PRTCOPY                 SAVE IN PARM BLOCK
PRMEM1   DS    0H
         TM    FLAG,ALCBPAM           IF ALREADY ALLOCATED, THEN
         BO    PRMSKP1                  SKIP ALLOCATION
         OI    FLAGBYT2,ALCONLY       TELL ROUTINE TO ALLOCATE ONLY
         DO    ALCOPMEM               GO ALLOCATE DDNAME AND OPEN DS
         NI    FLAGBYT2,255-ALCONLY   RESET FLAG
         LTR   R15,R15                IF NOT SUCCESSFUL THEN
         BNZ   PRMEMX                    GET OUT OF HERE
PRMSKP1  DS    0H
         L     R1,DSNAME@
         MVC   PRTDSNM,0(R1)          MOVE DSNAME TO PARM BLOCK
         MVC   PRTMEM,TBMEM           MOVE MEMBER NAME
         MVC   PRTDDNM,DDNAME2        MOVE DDNAME FOR PRINT
         LA    R3,DS@PRTPB            ADDRESS PARM BLOCK
         CALL  DS@SCPDP,((R3)),VL,MF=(E,CALLPL) CALL PRINT PROGRAM
         MVC   TBSTAT,=CL8'*PRINTED'  SAY "PRINTED"
         MVI   PRTSYSAL,FLAGON        SAY PRINT SYSOUT ALLOCATED
         LTR   R15,R15                IF BAD RC, THEN
         BZ    PRMEMX
         LA    R1,MSG23                 SET ERROR MESSAGE NUMBER
         CH    R15,=H'4'                IF RETURN CODE 4
         BE    PRMSTMSG                   GO SET THIS MESSAGE
         LA    R1,MSG22                 ELSE MUST BE I/O ERROR
         MVC   TBSTAT,=CL8'*ERROR '       SET STATUS
PRMSTMSG DS    0H
         DO    PUTMSG                   LET ISPF SET IT
PRMEMX   DS@EXIT RET=R15
         SPACE
         DROP  BASE
         TITLE 'FREE ALLOCATED SYSOUT FILE'
**********************************************************************
*              F R E S Y S O U      R O U T I N E                    *
*                                                                    *
*     THE ROUTINE SIMPLY FREES THE SYSOUT FILE THAT WAS DYNAMICALLY  *
*   ALLOCATED BY THE PRINT PROGRAM BY SIMPLY SETTING A BIT IN THE    *
*   PRINT PARAMETER BLOCK, AND CALLING THE PRINT ROUTINE.            *
*                                                                    *
**********************************************************************
         SPACE
         USING FRESYSOU,BASE
         SPACE
FRESYSOU DS@ENTR ,
         CLI   PRTSYSAL,FLAGON        IF SYSOUT FILE NOT ALLOCATED
         BE    FRESYSO1
         LA    R1,MSG26                 SET ERROR MESSAGE NUMBER
         DO    PUTMSG                   LET ISPF SET IT
         B     FRESYSOX
FRESYSO1 DS    0H
         DO    FREESYS
         LA    R1,MSG25                 SET INFO MESSAGE NUMBER
         DO    PUTMSG                   LET ISPF SET IT
         SLR   R15,R15                  CLEAR RC
FRESYSOX DS@EXIT RET=R15
         SPACE 3
         DROP  BASE
         USING FREESYS,BASE
         SPACE
FREESYS  DS    0H
         CLI   PRTSYSAL,FLAGON        IF SYSOUT ALLOCATED FOR PRINT
         BNER  R14
         DS@ENTR ,                      SAVE ENTRY REGS
         OI    PRTFLAG1,PRTFREE
         LA    R2,DS@PRTPB              ADDRESS PARM BLOCK
         CALL  DS@SCPDP,((R2)),VL,MF=(E,CALLPL) GO FREE SYSOUT FILE
         MVI   PRTSYSAL,FLAGOFF         SAY NO MORE SYSOUT
         MVI   PRTDISP,FLAGOFF          RESET DISPLAY FLAG FOR PRINT
         DS@EXIT ,                      DONE
         SPACE
         DROP  BASE
         TITLE 'ADD MEMBER TO MEMBER LIST ROUTINE'
**********************************************************************
*               A D D M E M         R O U T I N E                    *
*                                                                    *
*     THE ROUTINE ADDS A MEMBER TO THE MEMBER LIST IN ITS PROPER     *
*   PLACE.  THE "ADD" COMMAND CAN BE USED TO RECOVER MEMBERS THAT    *
*   HAVE BEEN "ZAPPED", OR TO ADD MEMBERS TO A SUBSETTED MEMBER      *
*   LIST.                                                            *
*                                                                    *
**********************************************************************
         SPACE
         USING ADDMEM,BASE
         SPACE
ADDMEM   DS@ENTR ,
         OI    FLAGBYT2,NORSKIP             DON'T RESET SKIP NUMBER
         DO    FNDTBMEM                     SEE IF IN THE TABLE
         LTR   R15,R15                      IF ALREADY IN TABLE, THEN
         BNZ   ADDMEM15
         LA    R1,MSG19                       SET THE MESSAGE
         MVC   PARM1,=CL8'ADD'                SET CMD NAME IN MESSAGE
         DO    PUTMSG                         GIVE IT TO ISPF
         B     ADDMEMX                        AND WE'RE DONE
ADDMEM15 DS    0H                           ELSE
         L     R11,CURDSN                     SET DS TABLE BASE
         DO    GETSTATS                       GO GET ISPF STATS
         LTR   R15,R15                        IF ^FOUND, THEN
         BZ    ADDMEM20
         LA    R1,MSG18                         SET THE MESSAGE
         DO    PUTMSG                           GIVE IT TO ISPF
         B     ADDMEMX
ADDMEM20 DS    0H                             ELSE
         DO    ADDNMEM                          GO ADD IT TO THE TABLE
         MVC   TBSTAT,=CL8'*ADDED'              SET STATUS
         SLR   R15,R15                          CLEAR RETURN CODE
ADDMEMX  DS    0H
         DS@EXIT RET=R15
         SPACE
         DROP  BASE
         TITLE 'PDS MEMBER MOVE/COPY ROUTINES'
**********************************************************************
*          M O V E / C O P Y        R O U T I N E S                  *
*                                                                    *
*     THIS ROUTINE IS USED TO DO A PDS MEMBER COPY AND MOVE (A MOVE  *
*   IS SIMPLY A COPY FOLLOWED BY A DELETE OF COURSE). IF THIS IS THE *
*   FIRST MOVE/COPY (OR FIRST ONE AFTER A CLOSE COMMAND), A PANEL IS *
*   DISPLAYED FOR THE USER TO ENTER THE TARGET DATASET AND OPTIONS.  *
*   WE CALL AN EXTERNAL PROGRAM WHICH ACTUALLY PERFORMS THE I/O      *
*   OPERATIONS TO DO THE COPY.                                       *
*                                                                    *
**********************************************************************
         SPACE
         USING MOVMEM,R15
         SPACE
MOVMEM   DS    0H
         MVI   MOVFLAG,FLAGON         SAY COMMAND IS MOVE
         L     R15,=A(CPYMEM01)       GO TO COPY CODE
         BR    R15
         SPACE
         LTORG
         SPACE
         DROP  R15
         SPACE 2
         USING CPYMEM,R15
         SPACE
CPYMEM   DS    0H
         MVI   MOVFLAG,FLAGOFF        SAY COMMAND IS COPY
         L     R15,=A(CPYMEM01)       GO TO COPY CODE
         BR    R15
         SPACE
         LTORG
         SPACE
         DROP  R15
         SPACE 2
         USING CPYMEM01,BASE
         SPACE
CPYMEM01 DS@ENTR ,
         TM    FLAG2,RECFMU           IF RECORD FORMAT U, THEN
         BZ    CPYMNOTU
         LA    R1,MSG36                 SET THE MESSAGE
         B     CPYMERR1                 AND DONE
CPYMNOTU DS    0H
         CLI   CPYDISP,FLAGON         IF WE NEED TO SHOW PANEL,
         BE    CPYM05
         DO    CLOSECPY                 DON'T LEAVE COPY DS ALLOCATED
CPYM00   DS    0H
         MVI   CPYDISP,FLAGOFF          ENSURE FLAG IS OFF
         CALL  ISPLINK,(=CL8'CONTROL',=CL8'DISPLAY',=CL8'SAVE'),VL,    +
               MF=(E,CALLPL)
         L     R1,=A(VTBL3)               ADDRESS VARIABLE TABLE
         LA    R2,VTBL3#                  GET NUMBER IN TABLE
         STM   R1,R2,VARTBLA              SAVE IN PARM LIST
         CLI   CPYDSNAM,C' '              IF VARS NOT YET DEFINED, THEN
         BNE   CPYM005
         DO    DEFVARS                      DO THE VDEFINES
CPYM005  DS    0H
         CALL  ISPLINK,(=CL8'DISPLAY',=CL8'DS@SCPDC'),VL,MF=(E,CALLPL)
         STH   R15,RCSAVE               SAVE RETURN CODE
         CALL  ISPLINK,(=CL8'CONTROL',=CL8'DISPLAY',=CL8'RESTORE'),VL, +
               MF=(E,CALLPL)
         LH    R15,RCSAVE               RESTORE RETURN CODE
         LTR   R15,R15                  IF USER DIDN'T MEAN IT, THEN
         BNZ   CPYMEMX                    GET OUT OF HERE
         MVI   CPYDISP,FLAGON           ELSE SAY WE SHOWED IT
         DO    GETLNG                     GET LENGTHS OF VARIABLES
         MVC   CPYDSNAM,BLANKS            MOVE BLANKS TO COPY DSNAME
         DO    GETLNG                     GET LENGTHS OF PANEL VARS
         LA    R1,CPYDSNAM                ADDRESS DSN IN DSA
         CLI   DSN02,C' '                 IF NOT "OTHER DATA SET"
         BNE   CPYM01
         L     R2,PROJ2L                    GET LENGTH OF PROJECT
         LR    R4,R2                        COPY IT
         LA    R3,PROJ2                     ADDRESS THE VAR
         BCTR  R2,0                         GET EXECUTE LENGTH
         EX    R2,CPYMOVDS                  MOVE PROJ TO DSN
         LA    R1,1(R2,R1)                  GET PAST PROJ MOVED
         MVI   0(R1),C'.'                   MOVE IN PERIOD
         LA    R1,1(,R1)                    GET PAST THE PERIOD
         L     R2,LIBR2L                    GET LENGTH OF LIBRARY
         AR    R4,R2                        ADD TO TOTAL
         LA    R3,LIBR2                     ADDRESS THE VAR
         BCTR  R2,0                         GET EXECUTE LENGTH
         EX    R2,CPYMOVDS                  MOVE LIBR TO DSN
         LA    R1,1(R2,R1)                  GET PAST LIBR MOVED
         MVI   0(R1),C'.'                   MOVE IN PERIOD
         LA    R1,1(,R1)                    GET PAST THE PERIOD
         L     R2,TYPE2L                    GET LENGTH OF TYPE
         AR    R4,R2                        ADD TO TOTAL
         LA    R3,TYPE2                     ADDRESS THE VAR
         BCTR  R2,0                         GET EXECUTE LENGTH
         EX    R2,CPYMOVDS                  MOVE TYPE TO DSN
         LA    R4,2(,R4)                    SET LENGTH
         B     CPYM03
CPYM01   DS    0H                         ELSE ("OTHER" DATASET)
         CLI   DSN02,C''''                  IF DATASET QUALIFIED,
         BNE   CPYM02
         L     R2,DSN02L                      GET ITS LENGTH
         SH    R2,=H'3'                       GET EXECUTE LENGTH
         LA    R4,1(,R2)                      SET NAME LENGTH
         LA    R3,DSN02+1                     ADDRESS OF DSNAME
         EX    R2,CPYMOVDS                    MOVE NAME TO PARM BLOCK
         B     CPYM03
CPYM02   DS    0H                           ELSE (NEED TO ADD PREFIX)
         L     R2,ZPREFIXL                    GET LENGTH OF PREFIX
         LR    R4,R2                          COPY IT
         BCTR  R2,0                           GET EXECUTE LENGTH
         LA    R3,ZPREFIX                     ADDRESS PREFIX
         EX    R2,CPYMOVDS                    MOVE IN PREFIX
         LA    R1,1(R2,R1)                    GET PAST PREFIX MOVED
         MVI   0(R1),C'.'                     MOVE IN PERIOD
         LA    R1,1(,R1)                      GET PAST PERIOD MOVED
         L     R2,DSN02L                       GET LENGTH OF DSN
         LA    R4,1(R4,R2)                    ADJUST ACCUMLATED LENGTH
         BCTR  R2,0                           GET EXECUTE LENGTH
         LA    R3,DSN02                       ADDRESS SOURCE FOR MOVE
         EX    R2,CPYMOVDS                    MOVE IN REST OF DSNAME
CPYM03   DS    0H
         ST    R4,ALCPBDNL                SET DATASET NAME LENGTH
         MVC   ALCPBDSN,CPYDSNAM          MOVE IN DSNAME SERIAL
         MVC   ALCPBVOL,VOL2              MOVE IN VOLUME SERIAL
         MVC   ALCPBDDN,BLANKS            RETURN DDNAME PLEASE
         MVC   ALCPBMEM,BLANKS            NO MEMBER NAME
         LA    R2,DS@ALCPB                ADDRESS PARM BLOCK
         CALL  DS@ALLOC,((R2)),VL,MF=(E,CALLPL) GO ALLOCATE DS
         LTR   R15,R15                    IF ALLOCATE FAILED,
         BZ    CPYM04
         LA    R1,MSG29                     SET THE MESSAGE
         DO    PUTMSG                       AND GO GIVE IT TO ISPF
         B     CPYM00                       GO RESHOW PANEL
CPYM04   DS    0H
         MVC   CPYDDNAM,ALCPBDDN            SAVE DDNAME
         MVC   CPYDSORG,ALCPBRDS            MOVE DSORG TO PARM BLOCK
         TM    ALCPBRDS,X'02'               IF DSORG NOT PO OR PS
         BO    CPYM05
         TM    ALCPBRDS,X'40'
         BO    CPYM05
         LA    R1,MSG38                       SET THE MESSAGE
         DO    PUTMSG                         AND GO GIVE IT TO ISPF
         DO    CLOSECPY                       GO DEALLOCATE DDNAME
         B     CPYM00                         GO RESHOW PANEL
CPYM05   DS    0H
         OI    FLAGBYT2,ALCONLY       ASSUME COPY (NO OPEN FOR UPDAT)
         CLI   MOVFLAG,FLAGON         IF COMMAND IS MOVE,
         BNE   *+8
         NI    FLAGBYT2,255-ALCONLY     NEED TO OPEN ALSO
         DO    ALCOPMEM               ALLOCATE/OPEN DATA SET
         LTR   R15,R15                IF NOT SUCCESSFUL THEN
         BNZ   CPYMEMX                   GET OUT OF HERE
         TM    FLAGBYT2,CMDLPRC       IF COMMAND LINE PROCESSING
         BZ    CPYM0505
         CLC   TBSTAT,BLANKS            IF NEW NAME NOT THERE, THEN
         BNE   CPYM0505
         MVC   TBSTAT,WORD2               TRY WORD QUEUE
CPYM0505 DS    0H
         L     R15,=A(TBLUPPER)       ADDRESS TRANSLATE TABLE
         TR    TBSTAT,0(R15)          ENSURE UPPER CASE NEW NAME
         L     R1,DSNAME@
         CLC   CPYDSNAM,0(R1)         IF DATA SET IS THE SAME
         BNE   CPYM06
         CLC   TBSTAT,BLANKS            IF SAME MEMBER NAME
         BE    CPYM0510
         CLI   TBSTAT,C'*'
         BE    CPYM0510
         CLC   TBMEM,TBSTAT
         BNE   CPYM06
CPYM0510 DS    0H
         MVC   TBSTAT,=CL8'*SAME'         SET INDICATOR
         SLR   R15,R15                    CLEAR RC
         B     CPYMEMX                    AND DON'T DO THIS ONE
CPYM06   DS    0H
         MVC   CPYINDD,DDNAME2        SET INPUT DDNAME
         MVC   CPYINMEM,TBMEM         SET INPUT MEMBER NAME
         MVC   CPYOUTDD,CPYDDNAM      SET OUTPUT DDNAME
         MVC   CPYOUMEM,TBMEM         ASSUME SAME OUTPUT MEMBER
         CLC   TBSTAT,BLANKS          IF NEW MEMBER NAME
         BE    CPYM07
         CLI   TBSTAT,C'*'              IF FIRST CHAR ^ ASTERISK,
         BE    CPYM07
         MVC   CPYOUMEM,TBSTAT          ASSUME RENAME FIELD OK
CPYM07   DS    0H
         OI    CPYFLAG1,CPYREP+CPYMOD ASSUME MOD AND REPLACE
         CLI   REP,C'N'               IF NOT REPLACE, THEN
         BNE   *+8
         NI    CPYFLAG1,255-CPYREP      WE ASSUMED WRONG, RESET
         CLI   SD,C'O'                IF NOT MOD, THEN
         BNE   *+8
         NI    CPYFLAG1,255-CPYMOD      WE ASSUMED WRONG, RESET
         LR    R1,R13                 COPY DSA ADDRESS
         AH    R1,=AL2(SPAMDSA-DS@SCPDD) ADD OFFSET FOR THIS
         ST    R1,CPYSPMD@            SAVE IN PARM BLOCK
         LA    R2,DS@CPYPB            ADDRESS PARM BLOCK
         CALL  DS@SCPDC,((R2)),VL,MF=(E,CALLPL) GO DO THE COPY
         B     *+4(R15)               PROCESS RETURN CODE
         B     CPYMOK1                RC = 0: ALL OK
         B     CPYMOK2                RC = 4: STILL OK
         B     CPYMER1                RC = 8: NOT REPLACED
         B     CPYMER2                RC = 12: NO DIRECTORY SPACE
         B     CPYMER3                RC = 16: NO DATASET SPACE
         B     CPYMER4                RC = 20: I/O ERROR
CPYMOK1  DS    0H
         MVC   TBSTAT,=CL8'*COPIED'   SET STATUS
         CLI   REP,C'Y'               IF REPLACE, THEN
         BNE   CPYMOK10
         TM    CPYDSORG,X'02'           IF GOING TO PDS
         BZ    CPYMOK10
         MVC   TBSTAT,=CL8'*REPL'         SET REPLACED STATUS
CPYMOK10 DS    0H
         CLI   MOVFLAG,FLAGON         IF FUNCTION WAS MOVE
         BNE   CPYCHKM
         CLI   REP,C'Y'                 IF ^ REPLACE, THEN
         BE    CPYCHKM
         MVC   TBSTAT,=CL8'*MOVED'        SET MOVED STATUS
         B     CPYCHKM
CPYMOK2  DS    0H
         MVC   TBSTAT,=CL8'*COPIED'   SET STATUS
         CLI   MOVFLAG,FLAGON         IF FUNCTION WAS MOVE
         BNE   *+10
         MVC   TBSTAT,=CL8'*MOVED'      SET MOVED STATUS
         B     CPYCHKM
CPYMER1  DS    0H
         MVC   TBSTAT,=CL8'*NO-REPL'  MEMBER NOT REPLACED
         SLR   R15,R15                CLEAR RETURN CODE
         B     CPYMEMX                AND WE'RE DONE
CPYMER2  DS    0H
         LA    R1,MSG27               SET THE MESSAGE
         B     CPYMERRS               AND DONE
CPYMER3  DS    0H
         LA    R1,MSG28               SET THE MESSAGE
         B     CPYMERRS               AND DONE
CPYMER4  DS    0H
         LA    R1,MSG22               SET THE MESSAGE
CPYMERRS DS    0H
         MVI   CPYDISP,FLAGOFF        ENSURE FLAG IS OFF
CPYMERR1 DS    0H
         DO    PUTMSG                 GO GIVE IT TO ISPF
         B     CPYMEMX                AND DONE
CPYCHKM  DS    0H
         SLR   R15,R15                CLEAR RETURN CODE
         CLI   MOVFLAG,FLAGON         IF FUNCTION WAS MOVE
         BNE   CPYMEMX
         DO    DELRTN                   GO DELETE THE MEMBER
         LTR   R15,R15                  IF DELETE FAILED, THEN
         BZ    CPYOKLIB
         MVC   TBSTAT,=CL8'*COPIED'       SAY *COPIED
         SLR   R15,R15                    CLEAR RETURN CODE
         B     CPYUPDO
CPYOKLIB DS    0H                       ELSE
         MVC   TBSEL,BLANKS               BLANK OUT SELECTION CODE
         MVC   TBLIB#(LTBLSHRT),BLANKS    BLANK OUT THE TABLE ENTRY
         CLC   NUMDS,=H'1'                IF MORE THAN 1 DS, THEN
         BNH   CPYUPDO
         DO    GETSTATS                     GET ISPF STATS
CPYUPDO  DS    0H
         MVC   LASTMEM,TBMEM            SET INPUT FOR ROUTINE
         DO    UPDOTBL                  UPDATE ANY OTHER TABLES
CPYMEMX  DS@EXIT RET=R15
         SPACE
CPYMOVDS MVC   0(0,R1),0(R3)          SKELETON FOR MVC
MVERMSG2 MVC   ERRFIELD(0),1(R15)     MVC FOR EX INSTRUCTION
         SPACE
         DROP  BASE
         TITLE 'CLOSE MOVE/COPY DATA SET'
**********************************************************************
*              C L O S C P Y        R O U T I N E                    *
*                                                                    *
*     THE ROUTINE SIMPLY CLOSES THE DATA SET THAT WAS THE TARGET FOR *
*   MOVE/COPY, AND DEALLOCATES THE ASSOCIATED DDNAME.                *
*                                                                    *
**********************************************************************
         SPACE
         USING CLOSCPY,BASE
         SPACE
CLOSCPY  DS@ENTR ,
         TM    CPYFLAG1,CPYOPEN       IF COPY DATA SET ^OPEN,
         BO    CLOSCPY1
         CLI   CPYDISP,FLAGON            OR HAVE NOT SHOWN PANEL YET
         BE    CLOSCPY1
         LA    R1,MSG39                 SET INFO MESSAGE NUMBER
         DO    PUTMSG                   GO GIVE IT TO ISPF
         B     CLOSCPYX
CLOSCPY1 DS    0H                     ELSE
         DO    CLOSECPY                 GO CLOSE AND DEALLOCATE
         LA    R1,MSG37                 SET INFO MESSAGE NUMBER
         DO    PUTMSG                   GO GIVE IT TO ISPF
         SLR   R15,R15                  CLEAR RC FOR RETURN
CLOSCPYX DS    0H
         DS@EXIT RET=R15              AND DONE
         SPACE
         DROP  BASE
         SPACE 2
         USING CLOSECPY,BASE
         SPACE
CLOSECPY DS@ENTR ,
         TM    CPYFLAG1,CPYOPEN       IF COPY DS OPENED, THEN
         BZ    CLOSECP1
         OI    CPYFLAG1,CPYCLOSE        TELL ROUTINE TO CLOSE DOWN
         LA    R2,DS@CPYPB              ADDRESS PARM BLOCK
         CALL  DS@SCPDC,((R2)),VL,MF=(E,CALLPL) GO DO IT
CLOSECP1 DS    0H
         NI    CPYFLAG1,255-CPYCLOSE  RESET FUNCTION CODE
         MVI   CPYDISP,FLAGOFF        RESET THIS FLAG
         CLI   CPYDDNAM,C' '          IF DDNAME ALLOCATED, THEN
         BE    CLOSEPYX
         MVC   ALCPBDDN,CPYDDNAM        MOVE COPY DDNAME TO PARM BLOCK
         LA    R2,DS@ALCPB              ADDRESS PARAMETER BLOCK
         CALL  DS@DEALC,((R2)),VL,MF=(E,CALLPL) DO THE DEALLOCATE
CLOSEPYX DS    0H
         MVC   CPYDDNAM,BLANKS        BE SURE THIS IS RESET
         DS@EXIT ,
         SPACE
         DROP  BASE
         TITLE 'PDS MEMBER SUBMIT ROUTINE'
**********************************************************************
*               S U B M E M         R O U T I N E                    *
*                                                                    *
*     THE ROUTINE PROCESSES THE SUBMIT COMMAND WHICH SUBMITS A PDS   *
*   MEMBER TO THE JOB ENTRY SYSTEM.  A SEPARATE PROGRAM IS ACTUALLY  *
*   USED TO DO ALL OF THE I.O.                                       *
*                                                                    *
**********************************************************************
         SPACE
         USING SUBMEM,BASE
         SPACE
SUBMEM   DS@ENTR ,
         LR    R1,R13                 COPY DSA ADDRESS
         AH    R1,=AL2(SPAMDSA-DS@SCPDD) ADD OFFSET FOR THIS
         ST    R1,SUBSPMD@            SAVE IN PARM BLOCK
         TM    FLAG,ALCBPAM           IF NOT ALREADY ALLOCATED, THEN
         BO    SUBSKP1
         OI    FLAGBYT2,ALCONLY         TELL ROUTINE TO ALLOCATE ONLY
         DO    ALCOPMEM                 GO ALLOCATE DDNAME
         NI    FLAGBYT2,255-ALCONLY     RESET FLAG
         LTR   R15,R15                  IF NOT SUCCESSFUL THEN
         BNZ   SUBMEMX                    GET OUT OF HERE
SUBSKP1  DS    0H
         MVC   SUBMEMNM,TBMEM         MOVE MEMBER NAME
         MVC   SUBDDNM,DDNAME2        MOVE DDNAME FOR PRINT
         XC    CALLPL(CALLPLL),CALLPL CLEAR CALL PARM LIST
         CALL  ISPLINK,(=CL8'CONTROL',=CL8'DISPLAY',=CL8'LINE',=F'999')+
               ,VL,MF=(E,CALLPL)      SET TERMINAL FOR LINE MODE MSGS
         LA    R3,DS@SUBPB            ADDRESS PARM BLOCK
         CALL  DS@SCSUB,((R3)),VL,MF=(E,CALLPL) CALL SUBMIT PROGRAM
         MVC   TBSTAT,=CL8'*SUBMIT'   SAY "SUBMITTED"
         LTR   R15,R15                IF BAD RC, THEN
         BZ    SUBMEMX
         MVC   TBSTAT,=CL8'*NOT JCL'    ASSUME NOT JCL
         C     R15,=F'4'                IF NOT 'NOT JCL' THEN
         BNE   SUBSKP2
         SLR   R15,R15                    MINOR ERROR, SO CLEAR RC
         B     SUBMEMX                    AND WE'RE DONE
SUBSKP2  DS    0H                       ELSE
         LA    R1,MSG22                   MUST BE I/O ERROR
         MVC   TBSTAT,=CL8'*ERROR '       SET STATUS
         DO    PUTMSG                     LET ISPF SET THE MESSAGE
SUBMEMX  DS    0H
         DS@EXIT RET=R15
         SPACE
         DROP  BASE
         TITLE 'LOCMEM - PROCESS LOCATE COMMAND'
**********************************************************************
*               L O C M E M         R O U T I N E                    *
*                                                                    *
*     THIS ROUTINE PROCESSES THE LOCATE COMMAND. A TBSCAN IS DONE TO *
*   LOCATE THE  TABLE ELEMENT.  IF IT IS NOT FOUND, AN ERROR MESSAGE *
*   IS SET.  IF FOUND, THEN SKIPNUM IS RESET TO THE CRP VALUE, SO    *
*   WHEN THE TABLE IS REDISPLAYED, THIS ROW WILL BE THE FIRST ROW.   *
**********************************************************************
         SPACE
         USING LOCMEM,BASE
         SPACE
LOCMEM   DS@ENTR ,
         DO    TBTOP                  GET TO TOP OF TABLE
         TM    FLAGBYT3,NDEFSORT      IF ^ SORTED BY DEFAULT
         BZ    LOCAT10
         LA    R1,MSG42                 SET MESSAGE NUMBER
         DO    PUTMSG                   GO SET THE MESSAGE
         B     LOCMEMX                  GET OUT OF HERE
LOCAT10  DS    0H                     ELSE
         XC    CALLPL(CALLPLL),CALLPL   CLEAR CALL PARM LIST
         L     R2,CURTBLNM              GET CURRENT TABLE INTO BASE
         CALL  ISPLINK,(=CL8'TBSCAN',(R2),=C'(TBMEM)',,,=CL8'PREVIOUS',+
               ,=CL8'CRP',=C'(LE)'),VL,MF=(E,CALLPL) DO THE SCAN
         MVC   SKIPNUM,CRP              SAVE CRP FOR TBSKIP
LOCMEMX  DS@EXIT RET=R15
         SPACE
         DROP  BASE
         TITLE 'PROCESS CANCEL COMMAND'
**********************************************************************
*                C A N C E L        R O U T I N E                    *
*                                                                    *
*     THE CANCEL COMMAND SIMPLY GETS ONE OUT OF THE MEMBER LIST, OR  *
*   STACKED MEMBER LISTS.                                            *
*                                                                    *
**********************************************************************
         SPACE
         USING CANCEL,BASE
         SPACE
CANCEL   DS@ENTR ,
         DO    RBLDTBL                  GET RID OF ALL TABLES
         MVI   FLAGBYT3,DONE            SAY WE ARE DONE
CANCELX  DS@EXIT RET=R15
         SPACE
         DROP  BASE
         TITLE 'PROCESS THE "?" (LEVEL) COMMAND'
**********************************************************************
*                L E V E L          R O U T I N E                    *
*                                                                    *
*     THIS ROUTINE PROCESSES LEVEL OR "?" COMMAND, WHICH SIMPLY SETS *
*   A MESSAGE INDICATING THE LEVEL (THE NUMBER OF MEMBER LISTS)      *
*   STACKED.                                                         *
*                                                                    *
**********************************************************************
         SPACE
         USING LEVEL,BASE
         SPACE
LEVEL    DS@ENTR ,
         LA    R1,MSG45                 SET MESSAGE NUMBER
         DO    PUTMSG                   GIVE IT TO ISPF
         SLR   R15,R15                  CLEAR RC
LEVELX   DS    0H
         DS@EXIT RET=R15
         SPACE
         DROP  BASE
         TITLE 'NOOPMEM - PROCESS NO-OP COMMAND'
**********************************************************************
*                N O O P M E M      R O U T I N E                    *
*                                                                    *
*     THIS ROUTINE PROCESSES THE NO-OP COMMAND.  THE NO-OP COMMAND   *
*   IS A SELECT CODE OF ALL BLANKS.  THIS HAPPENS WHEN AN INVALID    *
*   SELECT CODE IS ENTERED.  THE TABLE IS REDISPLAYED, AND THE USER  *
*   IS MADE TO CORRECT THE ERROR BEFORE PROCEEDING.  HE MAY SIMPLY   *
*   JUST BLANK OUT HIS SELECTION, AND IN THIS CASE THE ROW IS STILL  *
*   SELECT BY TBDISPL, SO WE MUST PROCESS THE BLANK SELECT CODE.     *
*                                                                    *
**********************************************************************
         SPACE
         USING NOOPMEM,R15
         SPACE
NOOPMEM  DS    0H
         MVC   TBSTAT,BLANKS          BLANK OUT TBSTAT NAME
         SLR   R15,R15                CLEAR RC
         BR    R14                    THAT'S ALL FOLKS!!!
         SPACE
         DROP  R15
         TITLE 'SORT - PROCESS SORT COMMAND'
**********************************************************************
*                 S O R T           R O U T I N E                    *
*                                                                    *
*     THIS ROUTINE PROCESSES THE SORT COMMAND ENTERED FROM THE       *
*   COMMAND LINE (CMDL).  ONLY THE FIRST TWO SORT OPERANDS THAT ARE  *
*   SORT FIELDS ARE PROCESSED, THE REST ARE IGNORED.  THE JOB HERE   *
*   IS TO PARSE THE SORT OPERANDS, BUILD THE ISPEXEC CALL IN THE     *
*   SORT BUFFER AND ISSUE THE TBSORT.                                *
*                                                                    *
**********************************************************************
         SPACE
         USING SORT,BASE
         SPACE
SORT     DS@ENTR ,
         MVC   TBSRTBUF(TBSRTBFL),TBSRTBFM MOVE IN MASK
         L     R2,CURTBLNM
         MVC   NAMETBL,TBLNAME        MOVE TABLE NAME TO BUFFER
         NI    FLAGBYT4,255-SORTOFLG  RESET FLAG
         L     R1,WORD1L              GET 1ST OPERAND LENGTH
         LTR   R1,R1                  IF NO OPERANDS, THEN
         BNZ   SORTSK1
         MVC   SORTFLD1,=CL8'TBMEM'     DEFAULT IS SORT BY MEMBER
         MVC   SORTOP1+1(13),BLANKS
         NI    FLAGBYT3,255-NDEFSORT    INDICATE DEFAULT SORT
         B     SORTIT
SORTSK1  DS    0H
         LA    R1,WORD1               ADDRESS SORT OPTION
         DO    GETSRTOP               SEE IF VALID
         LTR   R1,R1                  IF NOT VALID,
         BZ    SORTSK5                  ERROR
         MVC   SORTFLD1,0(R1)         MOVE IN SORT OPTION
         CLC   =C'TBMEM ',SORTFLD1    IF ^SORT BY NAME, THEN
         BE    *+4+4
         OI    FLAGBYT3,NDEFSORT        SAY NOT DEFAULT SORT
         L     R1,WORD2L              GET NEXT OPERAND LENGTH
         LTR   R1,R1
         BNZ   SORTSK2
         MVC   SORTOP1+1(13),BLANKS THEN WE ARE FINISHED
         B     SORTIT
SORTSK2  DS    0H
         LA    R1,WORD2               ADDRESS SORT OPERAND
         DO    GETSRTOP               GO SEE IF SORT FIELD
         LTR   R1,R1                  IF NOT SORT FIELD, THEN
         BNZ   SORTSK4
         CLC   WORD2(2),=C'A '        IF ASCENDING OPTION, THEN
         BE    SORTSK45                 WE ALREADY HAVE IT
         CLC   WORD2(2),=C'D '        IF ^ DESCENDING OPTION, THEN
         BNE   SORTSK5                  THIS IS AN ERROR
         MVI   SORTOP1,C'D'           ELSE SAY WE HAVE DESCENDING
         B     SORTSK45               AND TRY NEXT ONE
SORTSK5  DS    0H                     ELSE
         LA    R1,MSG5                  SET THE MESSAGE
         DO    PUTMSG                   GIVE IT TO ISPF
         B     SORTX                    DONE
SORTSK4  DS    0H
         MVC   SORTFLD2,0(R1)         MOVE IN SORT OPTION
         OI    FLAGBYT4,SORTOFLG      SET FLAG
SORTSK45 DS    0H
         OI    FLAGBYT3,NDEFSORT      SAY NOT DEFAULT SORT
         L     R1,WORD3L              GET WORD3 LENGTH
         LTR   R1,R1                  IF NOTHING, THEN
         BNZ   SORTSK33
         MVC   SORTFLD2+8(4),BLANKS     BLANK SORTOP 2 STUFF
         B     SORTIT                   NOW WE'RE READY
SORTSK33 DS    0H                     ELSE
         TM    FLAGBYT4,SORTOFLG      IF SECOND OPERAND A FIELD, THEN
         BZ    SORTSK35
         CLC   WORD3(2),=C'A '          IF ASCENDING OPTION, THEN
         BE    SORTIT                     WE ALREADY HAVE IT
         CLC   WORD3(2),=C'D '          IF ^ DESCENDING OPTION, THEN
         BNE   SORTSK5                    ERROR
         MVI   SORTOP2,C'D'             ELSE SAY WE HAVE DESCENDING
         B     SORTIT                     AND WE ARE DONE
SORTSK35 DS    0H                     ELSE
         LA    R1,WORD3                 ADDRESS SORT OPERAND
         DO    GETSRTOP                 GO SEE IF SORT FIELD
         LTR   R1,R1                    IF NOT SORT FIELD, THEN
         BZ    SORTSK5                    ERROR
         MVC   SORTFLD2,0(R1)           MOVE IN SORT OPTION
         L     R1,WORD4L                GET WORD4 LENGTH
         LTR   R1,R1                    IF EXISTS, THEN
         BZ    SORTIT
         CLC   WORD4(2),=C'A '            IF ASCENDING OPTION, THEN
         BE    SORTIT                       WE ALREADY HAVE IT
         CLC   WORD4(2),=C'D '            IF ^ DESCENDING OPTION, THEN
         BNE   SORTSK5                      ERROR
         MVI   SORTOP2,C'D'               ELSE SAY WE HAVE DESCENDING
SORTIT   DS    0H
         LA    R2,=A(TBSRTBFL)        GET BUFFER LENGTH
         LA    R3,TBSRTBUF            ADDRESS BUFFER
         CALL  ISPEXEC,((R2),(R3)),VL,MF=(E,CALLPL) DO THE SORT
*        LTR   R15,R15                IF RC FROM TBSORT ^= 0, THEN
*        BZ    *+6
*        DC    H'0'                     DIE 0C1
         L     R2,CURTBLNM            GET CURRENT TABLE NAME
         XC    SKIPNUM,SKIPNUM        CLEAR SKIPNUM
         SLR   R15,R15                CLEAR RC
SORTX    DS    0H
         DS@EXIT RET=R15
         SPACE 2
TBSRTBFM DC    CL60' '
         ORG   TBSRTBFM
         DC    CL8'TBSORT '
         DC    CL8'DS@Sxxxx'
         DC    C' FIELDS('
         DC    CL8' '
         DC    C',C,'
         DC    C'A'
         DC    C','
         DC    CL8' '
         DC    C',C,'
         DC    C'A'
         DC    C')'
         ORG
TBSRTBFL EQU   *-TBSRTBFM
         SPACE 2
         DROP  BASE
         TITLE 'GETSRTOP - GET SORT FIELD/OPERAND'
**********************************************************************
*              G E T S R T O P      R O U T I N E                    *
*                                                                    *
*     THIS ROUTINE DETERMINES IF THE OPERAND ADDRESS BY R1 IS A      *
*   VALID SORT OPERAND.  IF IT IS, THEN R1 IS RETURNED TO POINT TO   *
*   THE CORRESPONDING TABLE VARIABLE THAT IS TO BE USED FOR THE      *
*   SORT.  IF THE OPERAND IS INVALID, THEN R1 IS RETURNED AS ZERO.   *
*                                                                    *
**********************************************************************
         SPACE
         USING GETSRTOP,BASE
         SPACE
GETSRTOP DS@ENTR ,
         LR    R2,R1                  COPY INPUT
         LA    R0,SRFLDTB#            GET NUMBER OF TABLE ELEMENTS
         LA    R6,SRTFLDTB            ADDRESS START OF TABLE
         SLR   R1,R1                  ASSUME WE WON'T FIND IT
         TM    FLAGBYT3,LOADLIB       IF DOING LOAD LIBS, THEN
         BZ    GETSRTLP
         LA    R0,SRFLTB2#              USE DIFFERENT TABLE
         LA    R6,SRTFLTB2
GETSRTLP DS    0H
         CLC   0(8,R2),0(R6)          IF IN TABLE, THEN
         BE    GETSRTIT                 GET OUT OF LOOP
         BL    GETSRTEX               IF OUT OF ORDER, THEN DONE
         LA    R6,16(,R6)             ELSE NEXT TABLE ELEMENT
         BCT   R0,GETSRTLP            AND LOOP
         B     GETSRTEX               IF HERE, DIDN'T FIND IT
GETSRTIT DS    0H
         LA    R1,8(,R6)              IF HERE, FOUND, SO PRIME R1
GETSRTEX DS@EXIT RET=R1
         SPACE
SRTFLDTB DC    CL8'CREATED ',CL8'TBCRTED '
         DC    CL8'ID      ',CL8'TBUSERID'
         DC    CL8'INIT    ',CL8'TBISIZE '
         DC    CL8'LAST    ',CL8'TBLMDTJ '
         DC    CL8'LIB     ',CL8'TBLIB#  '
         DC    CL8'MOD     ',CL8'TBMOD   '
         DC    CL8'NAME    ',CL8'TBMEM   '
         DC    CL8'SIZE    ',CL8'TBSIZE  '
         DC    CL8'TIME    ',CL8'TBLMTM  '
         DC    CL8'TTR     ',CL8'TBTTRX  '
         DC    CL8'VER     ',CL8'TBVERMOD'
         DC    CL8'VERMOD  ',CL8'TBVERMOD'
SRFLDTB# EQU   (*-SRTFLDTB)/16
         SPACE 2
SRTFLTB2 DC    CL8'ALIAS   ',CL8'TBALIAS '
         DC    CL8'ATTR    ',CL8'TBATTR  '
         DC    CL8'ENTRY   ',CL8'TBEPAX  '
         DC    CL8'LIB     ',CL8'TBLIB#  '
         DC    CL8'MODE    ',CL8'TBMODE  '
         DC    CL8'NAME    ',CL8'TBMEM   '
         DC    CL8'SIZE    ',CL8'TBSIZEK '
         DC    CL8'SSI     ',CL8'TBSSI   ' NOTE: SORT BY SSI ^ CORRECT
         DC    CL8'TTR     ',CL8'TBTTRX  '   (CHAR SORT ON EBCDIC HEX
SRFLTB2# EQU   (*-SRTFLTB2)/16                FIELD)
         SPACE
         DROP  BASE
         TITLE 'SCAN - PROCESS THE SCAN COMMAND'
**********************************************************************
*          S C A N     C O M M A N D     P R O C E S S O R           *
*                                                                    *
*     THIS ROUTINE PROCESSES THE SCAN COMMAND PROCESSOR.  WE DISPLAY *
*   THE SCAN STRING ENTRY PANEL, AND IF THE USER DOES NOT "END",     *
*   WE LOOP THROUGH THE CURRENT TABLE FOR EACH MEMBER, SEEING IF THE *
*   STRING IS FOUND.  IF IT IS NOT FOUND, THEN WE DELETE THIS MEMBER *
*   FROM THE TABLE.                                                  *
*                                                                    *
**********************************************************************
         SPACE
         USING SCANCMD,BASE
         SPACE
SCANCMD  DS@ENTR ,
         L     R2,CURTBLNM            ADDRESS CURRENT TABLE NAME
         MVC   MPR,NUMMEM             SET NUMBER IN TABLE
         LA    R1,MSG44               SET MESSAGE ID
         DO    PUTMSG                 PUT A MESSAGE
SCANCLP  DS    0H
         CALL  ISPLINK,(=CL8'DISPLAY',=CL8'DS@SCPDN'),VL,MF=(E,CALLPL)
         LTR   R15,R15                IF "ENTER" ENTERED, THEN
         BNZ   SCANX
         MVI   SCOP,C'Y'                SAY SCAN
         L     R1,=A(SCNVARS)           ADDRESS SCAN VARIABLES
         LA    R2,SCNVARS#              GET NUMBER OF THEM
         STM   R1,R2,VARTBLA            SAVE IN PARM LIST FOR ROUTINE
         DO    GETLNG                   GO GET LENGTHS OF SCAN VARS
         DO    SCANOPS                  GO PROCESS SCAN PARAMETERS
         LTR   R15,R15                  IF AN ERROR, THEN
         BNZ   SCANCLP                    REDISPLAY PANEL
         DO    SCANPRC                  ELSE DO THE SCAN
         OI    FLAGBYT2,NOPUT             DON'T DO TBPUT WHEN CMDLINE
         LTR   R15,R15                    IF NONE AND
         BZ    SCANX
         TM    FLAGBYT3,INITSCAN               INITIAL SCAN
         BZ    SCANX
         L     R2,CURTBLNM                  ADDRESS CURRENT TABLE NAME
         MVC   NAMETBL,TBLNAME              SAVE CURRENT TABLE NAME
         L     R3,NUMMEM                    GET COUNT OF ELEMENTS
         LA    R2,TBLNAMES                  ADDRESS FIRST TABLE NAME
         DO    TBEND                        GET RID OF IT
         LA    R1,1                         ONLY 1 TABLE NOW
         ST    R1,NUMTBLNM                  SAVE NUMBER OF TABLE NAMES
         L     R1,DS@LVL                    GET LEVEL
         BCTR  R1,0                         DECREMENT IT
         ST    R1,DS@LVL                    SAVE IT BACK
         ST    R2,CURTBLNM                  RESET NEW CURRENT NAME
         MVC   TBLNAME,NAMETBL              SECOND TABLE IS NOW 1ST
         ST    R3,NUMMEM                    SAVE COUNT OF ELEMENTS
SCANX    DS    0H
         SLR   R15,R15                CLEAR RC
         DS@EXIT RET=R15
         SPACE
         DROP  BASE
         TITLE 'PROCESS SCAN PARAMETERS'
**********************************************************************
*                S C A N O P     S U B R O U T I N E                 *
*                                                                    *
*     THIS SUBROUTINE PROCESSES THE SCAN PARAMETERS WHICH ARE        *
*   SPECIFIED ON THE SCAN ENTRY PANEL.  WE LOOK AT THE LENGTH OF     *
*   THE SCAN STRING, WE SET UP THE TRANSLATE TABLE FOR THE ROUTINE   *
*   WHICH WILL ACTUALLY SCAN FOR THE STRING, AND WE EXAMINE THE      *
*   COLUMNS LIMIT(S) SPECIFIED.  IF WE FIND AN ERROR IN THE COLUMNS  *
*   DELIMITER, WE RETURN WITH A NON-ZERO RETURN CODE.                *
*                                                                    *
**********************************************************************
         SPACE
         USING SCANOPS,BASE
         SPACE
SCANOPS  DS@ENTR ,
         NI    FLAGBYTE,255-SCAN      ASSUME NO SCAN
         L     R3,SCANSTRL            GET LENGTH OF SCAN STRING PASSED
         LTR   R3,R3                  IF NOT GIVEN, THEN
         BZ    SCANOPX                  WE ARE DONE
         BCTR  R3,0                   ELSE SUBTRACT 1 TO GET EX LENGTH
         STH   R3,LNGSCAN             STORE THIS FOR LATER
         CLI   SCOP,C'Y'              IF USER DID NOT SAY TO SCAN
         BNE   SCANOPX                  THEN WE WON'T
         CLI   CASE,C'Y'              IF USER SAID IGNORE CASE, THEN
         BNE   SCANOP05
         LA    R5,SCANSTR               ADDRESS SCAN STRING
         L     R15,=A(TBLUPPER)         ADDRESS TRANSLATE TABLE
         EX    R3,SCANOTR               TRANSLATE SCAN STRING TO UPPER
SCANOP05 DS    0H
         OI    FLAGBYTE,SCAN          INDICATE WE ARE SCANNING
         L     R4,TRTBL@              GET ADDRESS OF TRT TABLE
         LR    R1,R4                  COPY IT
         XC    0(256,R1),0(R1)        CLEAR TRANSLATE TABLE FOR SCAN
         SLR   R1,R1                  CLEAR REGISTER BEFORE IC
         IC    R1,SCANSTR             GET FIRST BYTE OF SCANSTR
         STC   R1,0(R1,R4)            NOW STORE IT INTO TABLE
         L     R0,STPL                GET LENGTH FOR SUBROUTINE
         LTR   R0,R0                  IF STP NOT GIVEN THEN
         BZ    SCANOP10                  SKIP
         LA    R1,STP                 SET UP TO CONVERT STP TO BINARY
         DO    CONVBIN                USE SUBROUTINE FOR THIS
         ST    R1,STOPNUM             STORE IT AWAY FOR LATER
         LTR   R1,R1                  Q.WAS STP 0 (NO MAX-->ALL MEMS)?
         BNZ   SCANOP20               N.THEN SKIP
SCANOP10 DS    0H
         MVC   STOPNUM,=X'7FFFFFFF'   ELSE STORE MAXIMUM FOR COMPARE
SCANOP20 DS    0H
         XC    BND1,BND1              ZERO BOUNDARY1 FOR SEARCH
         L     R0,SCOL1L              GET LENGTH FOR SUBROUTINE
         LTR   R0,R0                  IF SCOL1 NOT GIVEN THEN
         BZ    SCANOPX                   SKIP
         LA    R1,SCOL1               SET UP TO CONVERT SCOL1 TO BIN
         DO    CONVBIN                CONVERT SCOL1 OPTION PASSED
         LTR   R1,R1                  IF SCOL1 = 0 THEN
         BZ    SCANOPX                   SKIP
         STH   R1,BND1                ELSE STORE IT AWAY FOR LATER
         L     R0,SCOL2L              GET LENGTH FOR SUBROUTINE
         LTR   R0,R0                  IF SCOL2 NOT GIVEN THEN
         BZ    SCANOPX                   SKIP
         LA    R1,SCOL2               SET UP TO CONVERT SCOL2 TO BIN
         DO    CONVBIN                CONVERT SCOL2 OPTION PASSED
         STH   R1,BND2                  STORE IT AWAY FOR LATER
         CH    R1,BND1                IF BND1 >= BND2    OR
         BNH   SCANOP25
         SH    R1,BND1                    BND2-BND1 < SCANSTRL, THEN
         LA    R1,1(,R1)
         C     R1,SCANSTRL
         BNL   SCANOPX
SCANOP25 DS    0H
         LA    R1,MSG14                 SET MESSAGE NUMBER
         DO    PUTMSG                   SET THE MESSAGE
         B     SCANOPRT                 AND GET OUT OF HERE
SCANOPX  DS    0H
         SLR   R15,R15                  CLEAR FOR RC
SCANOPRT DS    0H
         DS@EXIT RET=R15
         SPACE
SCANOTR  TR    0(0,R5),0(R15)         TR FOR UPPER CASE
         SPACE
         DROP  BASE
         TITLE 'SCAN CURRENT MEMBERS IN THE TABLE'
**********************************************************************
*              S C A N P R C        R O U T I N E                    *
*                                                                    *
*     THIS SUBROUTINE CALLS THE SCANRTN ROUTINE BELOW FOR EACH       *
*   MEMBER IN THE CURRENT TABLE.  THIS ROUTINE RETURNS THE NUMBER    *
*   OF MEMBERS IN THE NEW TABLE IF ANY WERE FOUND.  OTHERWISE, IT    *
*   RETURNS 0.                                                       *
*                                                                    *
**********************************************************************
         SPACE
         USING SCANPRC,BASE
         SPACE
SCANPRC  DS@ENTR ,
         MVI   STAXFLAG,FLAGOFF       RESET ATTENTION FLAG
         DO    TBTOP                  GET TO TOP OF TABLE
         DO    SCANTIME               SET UP TIMER VALUES FOR SCAN
         NI    FLAGBYTE,255-TBINIT    BE SURE NEW TABLE IS CREATED
         L     R2,CURTBLNM            GET CURRENT TABLE NAME
         SLR   R3,R3                  WE'LL COUNT MSE IN R3
         SLR   R4,R4                  WE'LL COUNT MSC IN R3
SCANPLP  DS    0H                     DO WHILE (NOT END OF TABLE)
         ST    R3,MSE                   SAVE MEMBERS SCANNED AND
         ST    R4,MSC                     MEMBERS SELECTED (STATS)
         CLI   STAXFLAG,FLAGON          IF ATTENTION HIT, THEN
         BNE   SCANP03
         NI    FLAGBYTE,255-ALLMEM        WE DON'T HAVE ALL MEMBERS
         LA    R1,MSG21                   SET THE MESSAGE
         DO    PUTMSG
         CALL  ISPLINK,(=CL8'CONTROL',=CL8'DISPLAY',=CL8'REFRESH'),VL, +
               MF=(E,CALLPL)
         B     SCANPLPX                   GET OUT OF LOOP
SCANP03  DS    0H
         C     R3,STOPNUM               IF AT THE LIMIT
         BNL   SCANPLPX                   GET OUT OF LOOP
SCANP04  DS    0H
         CALL  ISPLINK,(=CL8'TBSKIP',(R2)),VL,MF=(E,CALLPL)
         LTR   R15,R15                  IF END OF TABLE, THEN
         BNZ   SCANPLPX                   GET OUT OF LOOP
         MVC   LASTMEM,TBMEM            SAVE MEMBER NAME
         CLI   TBLIB#,C' '              IF MEMBER DELETED, THEN
         BE    SCANP05                    CAN'T BE THIS ONE
         LA    R4,1(,R4)                ADD 1 TO SCAN COUNT
         DO    SETCURDS                 SET CURRENT DATASET BASE
         LR    R11,R15                  GET VALUE SET INTO BASE
         DO    SCANRTN                  GO SCAN THIS MEMBER
         LTR   R15,R15                  IF FOUND, THEN
         BNZ   SCANP05
         LA    R3,1(,R3)                  ADD 1 TO COUNT
         MVC   TBSTAT,BLANKS              BLANK STATUS FIELD
         DO    ADDTBL                     GO ADD TO NEW TABLE
SCANP05  DS    0H                       ELSE
         DO    STSHOW                     GO UPDATE STATS VARIABLES
         B     SCANPLP                  END /* LOOP */
SCANPLPX DS    0H
         OI    FLAGBYT2,STNOSHOW      SAY DON'T SHOW ANYTHING
         DO    STSHOW                 GO UPDATE STATS VARIABLES
         LTR   R3,R3                  IF NONE FOUND, THEN
         BNZ   SCANP20
         LA    R1,MSG43                 SET A MESSAGE SAYING
         DO    PUTMSG                     SO
         B     SCANPRCX                 AND GET OUT OF HERE
SCANP20  DS    0H                     ELSE
         ST    R3,MPR                   SAVE NUMBER IN TABLE
         CLI   STAXFLAG,FLAGON          IF NOT ATTENTION, THEN
         BE    SCANPRCX
         LA    R1,MSG40                   SET A MESSAGE NUMBER
         DO    PUTMSG                     GO SET OUR MESSAGE
SCANPRCX DS    0H
         TTIMER CANCEL                CANCEL ANY TIMER SET
         LR    R15,R3                 SET NUMBER FOR RETURN
         DS@EXIT RET=R15
         SPACE
         DROP  BASE
         TITLE 'SCAN MEMBER FOR STRING'
**********************************************************************
*              S C A N R T N        R O U T I N E                    *
*                                                                    *
*     THIS SUBROUTINE PERFORMS THE SCAN FOR A CHARACTER STRING FOR   *
*   EACH MEMBER IN THE CURRENT MEMBER.  IF THE STRING IS FOUND, THE  *
*   ROUTINE RETURNS A ZERO RETURN CODE, OTHERWISE, 4 IS RETURNED.    *
*   THIS ROUTINE REQUIRES THAT THE TTR FOR THE MEMBER BE IN TBTTRX.  *
*   ALSO, THE DATASET SHOULD BE OPENED BEFORE THIS ROUTINE IS CALLED.*
*   UPON INPUT, R2 ADDRESS THE CURRENT TABLE NAME                    *
*                                                                    *
**********************************************************************
         SPACE
         USING SCANRTN,BASE
         SPACE
SCANRTN  DS@ENTR ,
         CLC   TBTTRX,=XL3'0'         IF TTR IS ZERO, THEN
         BE    SCANLPX                  CAN'T BE THIS ONE
         L     R1,MSC                 ADD TO NUM. OF MEMBERS
         LA    R1,1(,R1)                 THAT HAVE BEEN SCANNED FOR
         ST    R1,MSC                    THE CHARACTER STRING
         DO    ALLOCSCN               GO ALLOCATE FOR SCAN IF NEEDED
         MVI   SPBFUNC,SPBFPOIN       FUNC. IS POINT (SAME AS FIND)
         XC    SPBPOSIT,SPBPOSIT      CLEAR THIS AREA
         MVC   SPBSFB,SCNSFB          SET FILE BLOCK POINTER
         MVC   SPBPOSIT(3),TBTTRX     SET TTR IN POSITION FIELD
         MVC   SPBPOSIT+4(3),TBTTRX   SPAM NEEDS TTR IN TWO PLACES
         CALL  SPAM,(SPB),VL,MF=(E,SPAMPL) GO POSITION THE PDS
         MVI   SPBFUNC,SPBFGET        FUNCTION IS GET
SCANLP   DS    0H                     DO WHILE (NOT EOF ON MEMBER)
         CALL  SPAM,(SPB),VL,MF=(E,SPAMPL) GO READ FROM THE PDS MEMBER
         LH    R15,SPBRETC              GET SPAM RETURN CODE
         LTR   R15,R15                  IF NOT ZERO, THEN
         BNZ   SCANLPX                    ASSUME END OF FILE
         DO    FINDSTR                  SEE IF STRING IN RECORD
         LTR   R15,R15                  IF FOUND, THEN
         BZ    SCANRTNX                   DONE
         B     SCANLP
SCANLPX  DS    0H                     END /* LOOP */
         LA    R15,4                  SET RETURN CODE
SCANRTNX DS@EXIT RET=R15
         SPACE
         DROP  BASE
         TITLE 'ALLOCSCN - ALLOCATE 2ND DDNAME AND OPEN FOR SCAN'
**********************************************************************
*              A L L O C S C N      R O U T I N E                    *
*                                                                    *
*     THIS SUBROUTINE ALLOCATES A SECOND DDNAME, AND ISSUES THE OPEN *
*   (VIA SPAM) FOR INPUT, SO THAT MEMBERS CAN BE READ FOR SCANNING.  *
*   THE DDNAME ALLOCATED, IS ALSO USED FOR UPDATE FOR THE COMMAND    *
*   ROUTINES ONCE THE MEMBER LIST IS DISPLAYED.                      *
*                                                                    *
**********************************************************************
         SPACE
         USING ALLOCSCN,BASE
         SPACE
ALLOCSCN DS@ENTR ,
         TM    FLAG,ALCBPAM           IF NOT ALLOCATED THEN
         BO    ALCSCN10
         L     R1,DSNAME@
         MVC   ALCPBDSN,0(R1)           MOVE DSNAME TO PARM BLOCK
         MVC   ALCPBDNL,DSNLNG          SET NAME LENGTH
         MVC   ALCPBDDN,BLANKS          CLEAR DDNAME FOR ROUTINE
         MVC   ALCPBMEM,BLANKS          CLEAR MEMBER FOR ROUTINE
         MVC   ALCPBVOL,VOL1            SET VOLUME PARAMETER
         LA    R2,DS@ALCPB              ADDRESS PARAMETER BLOCK
         CALL  DS@ALLOC,((R2)),VL,MF=(E,CALLPL) CALL ALLOCATE PGM
         OI    FLAG,ALCBPAM             INDICATE SUCCESSFUL ALLOCATION
         MVC   DDNAME2,ALCPBDDN         MOVE IN DDNAME RETURNED
ALCSCN10 DS    0H
         TM    FLAG,OPNSCAN           IF NOT YET OPEN FOR SCAN, THEN
         BO    ALCSCNX
         MVI   SPBFUNC,SPBFOPEN         FUNCTION IS OPEN
         MVI   SPBOPT1,SPBOBPAM         ACCESS METHOD IS BPAM
         MVI   SPBOPT2,SPBOIN           OPEN IT FOR INPUT
         LA    R1,BUFFNO                GET NUMBER OF BUFFERS
         SLL   R1,1                     DOUBLE IT
         ST    R1,SPBBUFNO              SAVE IN SPAM PARM BLOCK
         MVC   SPBDDNAM,DDNAME2         MOVE IN DDNAME
         XC    SPBDSORG,SPBDSORG        CLEAR DSORG
         MVI   SPBRECFM,0               CLEAR RECORD FORMAT
         XC    SPBLRECL,SPBLRECL        CLEAR LRECL
         XC    SPBBLKSI,SPBBLKSI        CLEAR BLOCK SIZE
         CALL  SPAM,(SPB),VL,MF=(E,SPAMPL) GO ISSUE THE OPEN
         MVC   SCNSFB,SPBSFB            SAVE FILE BLOCK POINTER
         OI    FLAG,OPNSCAN             SAY OPEN FOR SCAN
ALCSCNX  DS    0H
         DS@EXIT ,
         SPACE
         DROP  BASE
         TITLE 'SEARCH FOR SCAN STRING IN RECORD SUBROUTINE'
**********************************************************************
*             F I N D S T R       S U B R O U T I N E                *
*                                                                    *
*    THIS SUBROUTINE CHECKS FOR THE OCCURRENCE OF THE SCAN STRING    *
*  PASSED IN A SINGLE RECORD OF THE INPUT DATASET.  IF THE STRING    *
*  IS FOUND, R15 IS RETURNED WITH 0, OTHERWISE R15 IS RETURNED WITH  *
*  A VALUE OF 4.                                                     *
*    INPUT: SCANSTR - SCAN STRING PASSED                             *
*           SPBREC - ADDRESS OF LOGICAL RECORD PREVIOUSLY READ       *
*           SPBRECL -  LRECL OF RECORD JUST READ                     *
*           LNGSCAN - THE LENGTH OF THE SCAN STRING FOR CLC EX INSTR.*
*           BND1 - STARTING COLUMN TO LOOK FOR STRING                *
*           BND2 - LAST COLUMN TO LOOK FOR STRING                    *
*           R14 - RETURN ADDRESS                                     *
*    OUTPUT:  R15 = 0 IF STRING FOUND, ELSE EQUAL TO 4               *
*                                                                    *
*    NOTE:  THIS ROUTINE ASSUMES THAT THE SEARCH COLUMN BOUNDARIES   *
*  ARE LARGE ENOUGH TO CONTAIN THE CHARACTER STRING, AND THAT BND2   *
*  IS GREATER THAN OR EQUAL TO BND1.                                 *
*                                                                    *
**********************************************************************
         SPACE
         USING FINDSTR,BASE
         SPACE
FINDSTR  DS@ENTR ,
         L     R5,SPBREC              GET RECORD ADDRESS
         LA    R5,0(,R5)              CHOB IT
         ST    R5,RECADDR             SAVE RECORD ADDRESS
         MVI   DELFLAG,0              RESET DELIMITER FLAG
         LH    R7,LNGSCAN             GET LNGSCAN SET BEFORE
         LR    R6,R7                  SAVE FOR LATER
         LH    R2,BND1                GET COL BOUNDARY 1
         LTR   R2,R2                  IF BOUNDARY = 0 THEN
         BZ    FINDSKP2                 WE CAN IGNORE THESE PARMS
         BCTR  R2,0                   ELSE SUB 1 TO GET PROPER OFFSET
         LH    R9,BND2                GET BOUNDARY 2
         C     R9,SPBRECL             IF BOUNDARY 2 BEYOND RECL
         BNH   FINDSKP0
         L     R9,SPBRECL               SET BND 2 TO RECORD LENGTH
FINDSKP0 DS    0H
         LTR   R9,R9                  IF BND2 = 0 AND BND1 > 0 THEN
         BNZ   FINDSKP1                 NEED TO SEARCH IN JUST ONE COL
         LA    R1,0(R5,R2)              SET R1 FOR EX INSTRUCTION
         A     R5,SPBRECL               FIND END OF RECORD
         SR    R5,R7                    LESS LENGTH OF SCAN
         CR    R9,R5                    IF THIS IS LAST COLUMN
         BNE   *+8
         OI    DELFLAG,LASTPOS            SAY LAST POSITION
         B     FNDLSTB1                 NOW GO LOOK FOR IT
FINDSKP1 DS    0H
         SR    R9,R2                  SUBTRACT TO GET WIDTH
         LA    R6,1(R7)               ADJUST LENGTH FOR COMPARE
         ST    R9,SPBRECL             IF HERE, NEED TO SET RECL BASED
*                                       ON WIDTH
         AR    R5,R2                    AND START OF RECORD ON BND1
FINDSKP2 DS    0H
         L     R8,SPBRECL             GET RECORD LENGTH
         CLI   CASE,C'Y'              IF IGNORE CASE ^SPECIFIED,
         BNE   FINDNCAS                 THEN SKIP
         BCTR  R8,0                   SUBTRACT 1 FOR EX INSTR
         L     R15,=A(TBLUPPER)       ADDRESS TRANSLATE TABLE
         EX    R8,TR                  TRANSLATE TO UPPER CASE
         LA    R8,1(,R8)              PUT 1 BACK
FINDNCAS DS    0H
         AR    R8,R5                  ADD THIS TO START OF RECORD
         SR    R8,R6                  SUB TO GET LAST BYTE FOR SCAN
         XR    R1,R1                  CLEAR REG 1 BEFORE LOOP
         LA    R3,TRTMXLNG            GET MAX LENGTH FOR TRT
         L     R4,TRTBL@              GET ADDRESS OF TRT TABLE
TRTLOOP  DS    0H
         MVI   DELFLAG,0              RESET DELIMITER FLAG
         LR    R9,R8                  ADDRESS END OF RECORD
         SR    R9,R5                  SUBTRACT TO GET LENGTH
         BZ    FNDLSTB                IF LAST BYTE, GO LOOK FOR STRING
         BM    FNDRET                 IF BEYOND RECORD, THEN DONE
         CR    R9,R3                  R9 = MIN(R9, R3)
         BNH   *+6
         LR    R9,R3
         BCTR  R9,0                   LENGTH FOR TRT INSTRUCTION
         EX    R9,TRT                 NOW DO TRANSLATE AND TEST
         BNZ   TRTFOUND                 TO FIND FIRST BYTE OF SCAN
         LA    R5,TRTMXLNG+1(,R5)     IF NOT FOUND, TRY NEXT PART OF
         B     TRTLOOP                  OF RECORD
TRTFOUND DS    0H
         CR    R1,R8                  IF AT LAST POSSIBLE BYTE, THEN
         BE    FNDLSTB                  GO LOOK FOR IT THERE
         EX    R7,CLCSTR              Q.STRING AT CURRENT POSITION?
         BNE   NOFINDIT               N.THEN SKIP
         CLI   WSP,C' '               IF WORD, SUFFIX OR PREFIX,
         BE    FOUNDIT                  GO SEE IF WE HAVE ONE
         DO    PRCWSPOP
         LTR   R15,R15                IF NOT FOUND, THEN
         BZ    FOUNDIT
NOFINDIT DS    0H
         LA    R5,1(,R1)                CURRENT POSITION + 1
         B     TRTLOOP                  AND LOOP
FNDLSTB  DS    0H
         OI    DELFLAG,LASTPOS        SAY FOUND IN LAST POSITION
FNDLSTB1 DS    0H
         EX    R7,CLCSTR              LOOK FOR STRING AT LAST POSSIBLE
         BNE   FNDRET                   BYTE; IF NOT FOUND, WE'RE DONE
         CLI   WSP,C' '               IF WORD, SUFFIX OR PREFIX,
         BE    FOUNDIT                  GO SEE IF WE HAVE ONE
         DO    PRCWSPOP
         LTR   R15,R15
         BNZ   FNDRET
FOUNDIT  DS    0H
         SLR   R15,R15                IF HERE, SAY WE FOUND THE STRING
         B     FNDRETX                  AND GET OUT
FNDRET   DS    0H
         LA    R15,4                  SET RETURN CODE
FNDRETX  DS    0H
         DS@EXIT RET=R15
         SPACE
TRT      TRT   0(0,R5),0(R4)          TRT FOR ABOVE EXECUTE INSTR.
TR       TR    0(0,R5),0(R15)         TR FOR UPPER CASE
CLCSTR   CLC   0(0,R1),SCANSTR        CLC FOR ABOVE EXECUTE INSTR.
         SPACE
TRTMXLNG EQU   256
         SPACE
         DROP  BASE
         TITLE 'PROCESS WORD, SUFFIX, PREFIX OPTIONS'
**********************************************************************
*              P R C W S P O P      R O U T I N E                    *
*                                                                    *
*     THIS SUBROUTINE PROCESSES THE WSP,   WHICH INDICATES IF WORD,  *
*   SUFFIX OR PREFIX WAS SPECIFIED.  INPUT TO THIS ROUTINE IS WSP,   *
*   WHICH EQUALS "W" FOR WORD, "S" FOR SUFFIX, OR "P" FOR PREFIX,    *
*   RECADDR, WHICH IS THE ADDRESS OF THE BEGINNING OF THE LOGICAL    *
*   RECORD, R1 WHICH CONTAINS THE CURRENT POSITION, SCANSTRL, WHICH  *
*   IS THE SCAN STRING LENGTH, AND DELFLAG, WHICH INDICATES IF THE   *
*   CURRENT POSITION IS THE LAST POSSIBLE ONE.  THIS ROUTINE RETURNS *
*   A ZERO VALUE IN R15 IF THE STRING FOUND IS GOOD.                 *
*                                                                    *
**********************************************************************
         SPACE
         USING PRCWSPOP,BASE
         SPACE
PRCWSPOP DS@ENTR ,
         SLR   R15,R15                ASSUME WE HAVE IT
         LR    R0,R1                  SAVE REG 1 CONTENTS FOR LATER
         TM    DELFLAG,LASTPOS        IF LAST POSITION, THEN
         BZ    PRCWSP1
         OI    DELFLAG,DELBACK          DELIMITER IS IN BACK
         B     PRCWSP2
PRCWSP1  DS    0H
         A     R1,SCANSTRL            ADD 1 TO SCAN STRING LENGTH
         L     R2,=A(DELTBL)          ADDRESS TRANSLATE TABLE
         TRT   0(1,R1),0(R2)          SEE IF THIS IS A DELIMITER
         BNZ   *+8
         OI    DELFLAG,DELBACK
PRCWSP2  DS    0H
         LR    R1,R0                  RESTORE R1 TO ORIGINAL VALUE
         C     R1,RECADDR             IF AT BEGINNING OF RECORD
         BNE   PRCWSP3
         OI    DELFLAG,DELFRONT         THEN DELIMITER IN FRONT
         B     PRCWSP4
PRCWSP3  DS    0H
         BCTR  R1,0                   GET CHARACTER IN FRONT OF STRING
         L     R2,=A(DELTBL)          ADDRESS TRANSLATE TABLE
         TRT   0(1,R1),0(R2)          SEE IF THIS IS A DELIMITER
         BNZ   *+8
         OI    DELFLAG,DELFRONT
PRCWSP4  DS    0H
         LR    R1,R0                  RESTORE R1 AGAIN
         CLI   WSP,C'W'               IF LOOKING FOR WORD, THEN
         BNE   PRCWSP5
         TM    DELFLAG,DELFRONT         MUST BE DELIMITER IN FRONT
         BZ    PRCWSPBX                 AND IN BACK
         TM    DELFLAG,DELBACK
         BZ    PRCWSPBX
         B     PRCWSPX
PRCWSP5  DS    0H
         CLI   WSP,C'S'               IF LOOKING FOR SUFFIX, THEN
         BNE   PRCWSP6
         TM    DELFLAG,DELFRONT         MUST BE DELIMITER IN BACK
         BO    PRCWSPBX                 AND NOT ONE UP FRONT
         TM    DELFLAG,DELBACK
         BZ    PRCWSPBX
         B     PRCWSPX
PRCWSP6  DS    0H
         CLI   WSP,C'P'               IF LOOKING FOR PREFIX, THEN
         BNE   PRCWSPX
         TM    DELFLAG,DELFRONT         MUST BE DELIMITER IN FRONT
         BZ    PRCWSPBX                 AND NOT ONE IN BACK
         TM    DELFLAG,DELBACK
         BZ    PRCWSPX
PRCWSPBX DS    0H
         LA    R15,4                  BAD RETURN IF HERE
PRCWSPX  DS@EXIT RET=R15
         SPACE
         DROP  BASE
         TITLE 'SHOW THE STATISTICS FOR THE SCAN'
**********************************************************************
*              S T S H O W          R O U T I N E                    *
*                                                                    *
*     THIS SUBROUTINE SHOWS THE SCREEN GIVING THE STATISTICS ABOUT   *
*   THE SCAN SO FAR.  THE SCREEN SERVES TWO PURPOSES.  THE FIRST IS  *
*   TO GIVE THE USER SOME INFORMATION, AND THE SECOND, AND MOST      *
*   IMPORTANT PURPOSE IS TO LET THE USER KNOW THAT WE ARE STILL      *
*   CRANKING AWAY, IN CASE THE SCAN IS TAKING A WHILE.  WE SHOULD    *
*   ONLY GET TO THIS ROUTINE AFTER THE TIMER INTERVAL HAS EXPIRED,   *
*   AND THIS IMPLIES ONLY WHEN A SCAN IS BEING DONE.  THE DISPLAY    *
*   IS LOCKED BEFORE THE SCREEN IS SHOWN.  ALSO, WE RESET THE INTER- *
*   VAL TIMER ON OUR WAY OUT.  THE FIRST TIME WE GET HERE, WE DO     *
*   ALL OF THE INITIALIZATION FOR THE DIALOG VARIABLES THAT ARE      *
*   SHOWN ON OUR SCREEN.                                             *
*                                                                    *
**********************************************************************
         SPACE
         USING STSHOW,BASE
         SPACE
STSHOW   DS@ENTR ,
         CLC   TIMEVAL,=F'0'          IF TIME VALUE FOR DELAY, THEN
         BE    STSHOWX
         STCK  CLOCK                    SAVE CURRENT CLOCK
         CLC   CLOCK,CCLOCK             IF NOT TIME TO SHOW STATS,
         BH    STSHOW0
         TM    FLAGBYT2,STNOSHOW          IF WE ARE TO DISPLAY
         BZ    STSHOWX                      NOTHING TO DO FOR NOW
STSHOW0  DS    0H
         TM    VARDFFLG,STVARDF       IF VARS NOT DEFINED YET, THEN
         BO    STSHOW1                  ISSUE VDEFINE TO DEFINE
         MVI   CPUTMED,C' '             STATISTICS VARIABLES
         MVC   CPUTM,BLANKS
         L     R1,=A(VTBL7)           ADDRESS VARIABLE TABLE
         LA    R2,VTBL7#              GET NUMBER IN VAR TABLE
         STM   R1,R2,VARTBLA          SAVE IN PARM LIST
         DO    DEFVARS                VDEFINE STAT VARIABLES
         OI    VARDFFLG,STVARDF       SAY WE DID THEM
STSHOW1  DS    0H
         TTIMER ,                     GET TIME LEFT ON TIMER
         L     R1,STTIME              GET START TIMER
         SR    R1,R0                  R1 NOW HAS TIME LEFT
         LR    R0,R1                  MOVE IT TO R0
         M     R0,=F'2604166'         CONVERT TO SECONDS
         D     R0,=F'100000000'
         A     R1,=F'5'               ROUND TO HUNDREDTHS
         LR    R0,R1
         CVD   R0,CNVWORK             CONVERT IT TO DECIMAL
         MVC   CPUTM,=X'202021204B2020' MOVE IN EDIT MASK
         ED    CPUTMED(8),CNVWORK+4  MAKE IT DISPLAYABLE
         TIME  BIN                    GET CURRENT TIME VALUE
         LR    R1,R0                  COPY TO R1
         SLR   R0,R0                  CLEAR R0 FOR DIVIDE
         D     R0,=F'100'             CONVERT TO SECONDS
         L     R0,TOD                 GET TIME OF DAY AT START
         SR    R1,R0                  CALCULATE DIFFERENCE
         BNM   *+8                    IF NEGATIVE, DATE CHANGED, SO
         AH    R1,=AL2(60*60*24)        ADD NUMBER OF SECONDS IN A DAY
         SLR   R0,R0                  CLEAR R0 FOR DIVIDE
         D     R0,=F'60'              R0 HAS MINUTES; R1 HAS SECONDS
         CVD   R1,CNVWORK             CONVERT MINUTES TO DECIMAL
         UNPK  ELAPTM(2),CNVWORK+6(2) MOVE TO VARIABLE
         OI    ELAPTM+1,X'F0'         ENSURE ZONE IS DISPLAYABLE
         CVD   R0,CNVWORK             CONVERT SECONDS TO DECIMAL
         UNPK  ELAPTM+3(2),CNVWORK+6(2) MOVE TO VARIABLE
         OI    ELAPTM+4,X'F0'         ENSURE ZONE IS DISPLAYABLE
         MVI   ELAPTM+2,C':'
         TM    FLAGBYT2,STNOSHOW      IF WE ARE NOT TO DISPLAY
         BO    STSHOWX                  THEN WE ARE DONE
         CALL  ISPLINK,(=CL8'CONTROL',=CL8'DISPLAY',=CL8'LOCK'),VL,    +
               MF=(E,CALLPL)
         LH    R1,REFSKIP             GET REFRESH SKIP COUNTER
         LA    R1,1(,R1)              INCREMENT IT
         STH   R1,REFSKIP             SAVE IT
         CLC   REFSKIP,=H'5'          IF FIFTH TIME, THEN
         BL    STNOREF
         CALL  ISPLINK,(=CL8'CONTROL',=CL8'DISPLAY',=CL8'REFRESH'),VL, +
               MF=(E,CALLPL)
         XC    REFSKIP,REFSKIP          RESET FOR NEXT TIME
STNOREF  DS    0H
         LA    R2,STPANLNM
         CALL  ISPLINK,(=CL8'DISPLAY',(R2)),VL,MF=(E,CALLPL) SHOW DISP.
         DO    TIMESET                GO RESET THE TIME
STSHOWX  DS    0H
         DS@EXIT ,
         SPACE
STMVCNM  MVC   0(0,R5),0(R2)          MVC SKELETON FOR EX INSTRUCTION
STPANLNM DC    CL8'DS@SCPST'
         SPACE
         DROP  BASE
         TITLE 'DATASET INFORMATION COMMAND PROCESSOR'
**********************************************************************
*                  I N F O        P R O C E S S O R                  *
*                                                                    *
*     THE ROUTINE PROCESSES THE INFO COMMAND, WHICH DISPLAY DATASET  *
*   INFORMATION FOR A PDS IN THE MEMBER LIST.  AN OPERAND (1-4) MAY  *
*   BE SPECIFIED FOR A CONCATENATED MEMBER LIST TO OBTAIN THE INFOR- *
*   MATION FOR OTHER THAN THE FIRST DATASET (WHICH IS THE DEFAULT).  *
*                                                                    *
*                                                                    *
**********************************************************************
         SPACE
         USING DSINFO,BASE
         SPACE
DSINFO   DS@ENTR ,
         L     R11,DSTABL@              ASSUME PDS 1
         CLC   NUMDS,=H'1'              IF MORE THAN ONE DS, THEN
         BE    DSINFDEF
         L     R1,WORD1L                  SEE IF LIB SPECIFIED
         LTR   R1,R1
         BZ    DSINFDEF
         C     R1,=F'1'                     IF LENGTH OF OPERAND <= 1
         BH    DSINFDEF
         CLI   WORD1,C'1'                     IF 1 <= LIB <= 4,
         BL    DSINFDEF
         CLI   WORD1,C'4'
         BH    DSINFDEF
         MVC   TBLIB#,WORD1                     MOVE IT TO TB VAR
         DO    SETCURDS                 GO ESTABLISH TBL ELEMENT BASE
         LR    R11,R15                  GET VALUE RETURNED
         TM    FLAG,ALCBSAM             IF DIR. DDNAME ^ ALLOCATED,
         BO    DSINFDEF
         L     R11,DSTABL@                    BE 1
DSINFDEF DS    0H
         TM    FLAG,ALCBPAM             IF DDNAME ^ ALLOCATED, THEN
         BO    DSINFO05
         OI    FLAGBYT2,ALCONLY           ROUTINE TO ALLOCATE ONLY
         DO    ALCOPMEM                   GO GET A DDNAME
         NI    FLAGBYT2,255-ALCONLY       RESET FLAG
         LTR   R15,R15                    IF ALLOCATION FAILED, THEN
         BNZ   DSINFOX                      GET OUT OF HERE
DSINFO05 DS    0H
         MVC   INFDDNAM,DDNAME2         MOVE DDNAME RETURNED TO PARM
         L     R1,DSNAME@               GET ADDRESS OF DSNAME
         MVC   INFDSNAM,0(R1)           MOVE TO PARM BLOCK
         MVC   INFVOLSR,DSVOL           MOVE IN VOLUME SERIAL
         LA    R2,DS@INFPB              ADDRESS PARM BLOCK
         CALL  DS@SCINF,((R2)),VL,MF=(E,CALLPL) CALL INFO PROGRAM
         LTR   R15,R15                  IF I/O ERROR, THEN
         BZ    DSINFO10
         LA    R1,MSG22                   SET MESSAGE NUMBER
         DO    PUTMSG                     LET ISPF SET THE MESSAGE
         B     DSINFOX
DSINFO10 DS    0H
         TM    VARDFFLG,INFVARDF      IF VARIABLES NOT DEFINED, THEN
         BO    DSINFO20
         L     R1,=A(VTBL8)             ADDRESS VARIABLE TABLE
         LA    R2,VTBL8#                GET NUMBER IN TABLE
         STM   R1,R2,VARTBLA            SAVE IN PARM LIST
         DO    DEFVARS                  VDEFINE THESE VARS
         OI    VARDFFLG,INFVARDF        SAVE VARIABLES DEFINED
DSINFO20 DS    0H
         LH    R1,DIRBLKU             GET DIR. BLOCKS USED
         ST    R1,INFUSEDB            SAVE IN DIALOG VARIABLE
         LH    R1,DIRBLKM             GET DIR. BLOCKS (MAX)
         ST    R1,INFMAXDB            SAVE IN DIALOG VARIABLE
         LH    R1,MEMCNT              GET NUMBER OF MEMBERS
         ST    R1,INFMEM#             SAVE IN DIALOG VARIABLE
         LA    R2,=CL8'DS@DSINS'      ASSUME SHORT INFO
         TM    FLAGBYTE,ALLMEM        IF ALL MEMBERS, THEN
         BZ    *+8
         LA    R2,=CL8'DS@DSINL'        WE HAVE LONG INFO
         CALL  ISPLINK,(=CL8'DISPLAY',(R2)),VL,MF=(E,CALLPL)
         SLR   R15,R15                  CLEAR RETURN CODE
DSINFOX  DS    0H
         DS@EXIT RET=R15
         SPACE
         DROP  BASE
         TITLE 'DUMP DIRECTORY COMMAND PROCESSOR'
**********************************************************************
*                D I R D U M P    P R O C E S S O R                  *
*                                                                    *
*     THE ROUTINE PROCESSES THE DIR COMMAND, WHICH DISPLAYS DIREC-   *
*   TORY INFORMATION FOR MEMBER(S) IN THE PDS MEMBER LIST.  A TABLE  *
*   IS BUILT AND DISPLAYED WITH THE INFORMATION IN DUMP FORMAT.      *
*                                                                    *
**********************************************************************
         SPACE
         USING DIRDUMP,BASE
         SPACE
DIRDUMP  DS@ENTR ,
         MVC   LASTMEM,TBMEM          MOVE IN MEMBER NAME
         TM    VARDFFLG,DIRVARDF      IF VARIABLES NOT DEFINED YET,
         BNZ   DIRDMP20
         L     R1,=A(VTBL9)             ADDRESS VARIABLE TABLE
         LA    R2,VTBL9#                GET NUMBER IN TABLE
         STM   R1,R2,VARTBLA            SAVE IN PARM LIST
         DO    DEFVARS                  VDEFINE VARIABLES FOR DISPLAY
         OI    VARDFFLG,DIRVARDF        SAY VARIABLES DEFINED
DIRDMP20 DS    0H
         XC    CALLPL(CALLPLL),CALLPL CLEAR CALL PARM LIST
         CALL  ISPLINK,(=CL8'TBCREATE',=CL8'DIRDUMP',,=C'(DIRMEM DIRLIB+
                DIRLNG DIRINFO)',=CL8'NOWRITE'),VL,MF=(E,CALLPL)
         DO    TBTOP                  GET TO TOP OF TABLE
         SLR   R9,R9                  CLEAR COUNTER
         MVI   SPBFUNC,SPBFFIND       SPAM FUNCTION IS FIND
         MVC   SPBSFB,INPSFB          SET FILE BLOCK POINTER
         L     R1,JFCBA@              ADDRESS FEEDBACK ENTRY
         ST    R1,SPBFDBK             SAVE IN PARM BLOCK
         LA    R1,JFCBALNG            GET LENGTH
         STC   R1,SPBFDBK             SAVE LENGTH
DIRDMLP  DS    0H
         MVC   DIRMEM(DIRBLKLG),BLANKS CLEAR TABLE ENTRY
         MVC   TBMEM,LASTMEM          MOVE IN MEMBER NAME TO SEARCH
         OI    FLAGBYT2,NORSKIP       DON'T RESET SKIPNUM
         DO    FNDTBMEM               GO FIND IT IN TABLE
         LTR   R15,R15                IF NOT FOUND, THEN
         BZ    DIRDMP25
         LTR   R9,R9                    IF NONE IN TABLE, THEN
         BNZ   DIRDMP40
         LA    R1,MSG18                   "MEMBER NOT FOUND"
         DO    PUTMSG                     GO PUT THE MESSAGE
         B     DIRDMP50                   AND WE'RE DONE
DIRDMP25 DS    0H                     ELSE
         L     R11,CURDSN               SET DS TABLE BASE
         LA    R9,1(,R9)                INCREMENT COUNTER
         MVC   SPBMEM,TBMEM             SET MEMBER NAME FOR FIND
         CALL  SPAM,(SPB),VL,MF=(E,CALLPL) THE FIND SHOULD WORK
         MVC   DIRLIB,TBLIB#            MOVE LIB# IN FOR DISPLAY
         MVC   DIRMEM,TBMEM             AND MEMBER NAME
         DO    DIRFRMT                  GO FORMAT THE DUMP OUTPUT
         B     DIRDMLP                AND LOOP
DIRDMP40 DS    0H                     DISPLAY THE INFORMATION
         CALL  ISPLINK,(=CL8'CONTROL',=CL8'DISPLAY',=CL8'SAVE'),VL,    +
               MF=(E,CALLPL)
         CALL  ISPLINK,(=CL8'TBTOP',=CL8'DIRDUMP'),VL,MF=(E,CALLPL)
         MVC   ZTDMARK,BLANKS           BLANK ZTDMARK
         CALL  ISPLINK,(=CL8'TBDISPL',=CL8'DIRDUMP',=CL8'DS@DIRLK'),   +
               VL,MF=(E,CALLPL)
         CALL  ISPLINK,(=CL8'CONTROL',=CL8'DISPLAY',=CL8'RESTORE'),VL, +
               MF=(E,CALLPL)
         L     R1,=A(ZTDMARKM)          ADDRESS ZTDMARK MASK
         MVC   ZTDMARK,0(R1)            RESET ZTDMARK
DIRDMP50 DS    0H                     TABLE DOES NOT LAST LONG
         LA    R2,=CL8'DIRDUMP'       ADDRESS TABLE NAME
         DO    TBEND                  END THIS TABLE
         XC    SPBFDBK,SPBFDBK        CLEAR FEEDBACK AREA POINTER
         SLR   R15,R15                CLEAR RC FOR RETURN
DIRDUMPX DS    0H
         DS@EXIT RET=R15
         SPACE
         DROP  BASE
         TITLE 'FORMAT THE DIRECTORY DUMP FOR A MEMBER'
**********************************************************************
*                D I R F R M T    P R O C E S S O R                  *
*                                                                    *
*     THE ROUTINE FORMATS THE DIRECTORY DUMP FOR A MEMBER.  THE      *
*   DIRECTORY INFORMATION IS CONTAINED IN THE FEEDBACK AREA FROM     *
*   SPAM.  WE FORMAT THE DUMP AND ADD IT TO THE ALREADY CREATED      *
*   TABLE.                                                           *
*                                                                    *
**********************************************************************
         SPACE
         USING DIRFRMT,BASE
         SPACE
DIRFRMT  DS@ENTR ,
         L     R7,JFCBA@              ADDRESS FEEDBACK AREA
         MVC   11(64,R7),13(R7)       GET RID OF "K" & "Z" OF BLDL
         IC    R6,11(,R7)             GET "C" FIELD
         SLL   R6,27
         SRL   R6,26
         LA    R6,12(,R6)             R6 = LENGTH OF DIRECTORY ENTRY
         CVD   R6,CNVWORK             CONVERT IT TO DECIMAL
         MVC   DIRLNG-2(4),=X'20202021' MOVE EDIT MASK TO VAR
         ED    DIRLNG-1(3),CNVWORK+6  MAKE IT PRINTABLE
         LA    R5,DIRLNGTB            ADDRESS TABLE
DFRMTLP1 DS    0H
         LTR   R6,R6                  DO WHILE (LENGTH LEFT > 0)
         BZ    DIRFRMTX
         MVC   DIROFF,0(R5)             MOVE IN CURRENT OFFSET
         LA    R5,4(,R5)                SET UP FOR NEXT TIME
         LA    R4,DIRHEX                ADDRESS PLACE TO START
         SLR   R8,R8                    CLEAR LENGTH ACCUMULATOR
         ST    R7,CNVWORK               SAVE START POINT FOR A SECOND
         LA    R3,4                     SET INDEX TO 4
DFRMTLP2 DS    0H                       DO I = 1 TO 4
         LA    R2,4                       LOAD CONSTANT
         CR    R2,R6                      R2 = MIN(R2, R6)
         BNH   *+6
         LR    R2,R6
         LR    R15,R2                     R15 = L2 FOR UNPK
         SLL   R2,5                       MOVE OVER A NIBBLE, & DOUBLE
         AR    R2,R15                     ADD L2
         EX    R2,FRMTUNPK                DO THE UNPK
         SRL   R2,4                       MOVE BACK
         EX    R2,FRMTTR                  DO THE UNPK
         AR    R8,R15                     ADD LENGTH ACCUMULATOR
         AR    R4,R2                      GET PAST JUST CONVERTED
         MVI   0(R4),C' '                 BE SURE IT IS BLANK
         LA    R4,1(,R4)                  GET PAST BLANK
         AR    R7,R15                     NEXT BYTES OF DIRECTORY
         SR    R6,R15                     ADJUST OVERALL LENGTH
         BZ    DFRMTL2X                   IF ZERO, THEN DONE
         BCT   R3,DFRMTLP2              END /* DO I */
DFRMTL2X DS    0H
         MVI   DIRAST,C'*'              MOVE IN AN ASTERISK
         LA    R4,DIRCHAR               ADDRESS CHAR PART FOR DUMP
         BCTR  R8,0                     SET EX LENGTH
         L     R1,CNVWORK               RESTORE STARTING POINT
         EX    R8,FRMTMVC               MOVE DATA TO TRANSLATE
         LA    R4,1(R4,R8)              GET PAST DATA
         MVI   0(R4),C'*'               MOVE IN ENDING ASTERISK
         CALL  ISPLINK,(=CL8'TBADD',=CL8'DIRDUMP'),VL,MF=(E,CALLPL)
         MVC   DIRMEM(DIRBLKLG),BLANKS
         B     DFRMTLP1               END /* DO WHILE */
DIRFRMTX DS    0H
         MVC   DIRMEM(DIRBLKLG),BLANKS ADD A BLANK LINE BETWEEN
         CALL  ISPLINK,(=CL8'TBADD',=CL8'DIRDUMP'),VL,MF=(E,CALLPL)
         DS@EXIT ,
         SPACE
FRMTMVC  MVC   0(0,R4),0(R1)          EX SKELETON
FRMTUNPK UNPK  0(0,R4),0(0,R7)        EX SKELETON
FRMTTR   TR    0(0,R4),FRMTTRTB-240   DITTO
         SPACE
DIRLNGTB DC    C'0000',C'0010',C'0020',C'0030'
         SPACE
FRMTTRTB DC    C'0123456789ABCDEF'
         SPACE
         SPACE
         DROP  BASE
         TITLE 'DS@SCPDS - PROCESS ZAP COMMAND'
**********************************************************************
*                 Z A P T B L       R O U T I N E                    *
*                                                                    *
*     THIS ROUTINE PROCESSES THE ZAP COMMAND, WHICH SIMPLY DELETES   *
*   THE GIVEN LINE FROM THE TABLE (THE PDS MEMBER IS NOT DELETED).   *
*                                                                    *
**********************************************************************
         SPACE
         USING ZAPTBL,BASE
         SPACE
ZAPTBL   DS@ENTR ,
         L     R2,CURTBLNM
         CALL  ISPLINK,(=CL8'TBDELETE',(R2)),VL,MF=(E,CALLPL)
         L     R1,NUMMEM              GET NUMBER IN TABLE
         BCTR  R1,0                   LESS 1
         ST    R1,NUMMEM              SAVE IT BACK
         OI    FLAGBYT2,NOPUT         DON'T DO TBPUT
ZAPTBLX  DS@EXIT RET=R15
         SPACE
         DROP  BASE
         TITLE 'FINDID - PROCESS FIND COMMAND'
**********************************************************************
*                 F I N D I D       R O U T I N E                    *
*                                                                    *
*     THIS ROUTINE PROCESSES THE FIND COMMAND ENTERED FROM THE       *
*   COMMAND LINE (CMDL).  FIND LOOKS FOR THE USERID ON SPF STATS     *
*   FOR A GIVEN MEMBER.                                              *
*                                                                    *
**********************************************************************
         SPACE
         USING FINDID,BASE
         SPACE
FINDID   DS@ENTR ,
         L     R1,WORD1L              GET OPERAND LENGTH
         LTR   R1,R1                  IF NOTHING ENTERED, THEN
         BNZ   FINDOK1
         LA    R1,MSG1                  SET ERROR MESSAGE NUM
         DO    PUTMSG                   GIVE MESSAGE TO ISPF
         B     FINDIDX                  AND GET OUT OF HERE
FINDOK1  DS    0H
         MVC   FINDPARM,WORD1         ELSE GET USERID ENTERED
         C     R1,=H'7'               IF LENGTH > 7 THEN
         BL    FINDOK10
         MVI   TBMEM+7,C'*'             PUT * AT END
         B     DOFINDIT               ELSE
FINDOK10 DS    0H
         LA    R7,FINDPARM              CALCULATE ADDR TO PUT *
         AR    R7,R1
         MVI   0(R7),C'*'               MOVE IN * AT PROPER PLACE
DOFINDIT DS    0H
         DO    FINDIT
         SLR   R15,R15
FINDIDX  DS    0H
         OI    FLAGBYT2,NOPUT         DON'T DO TBPUT
         DS@EXIT RET=R15
         SPACE
         DROP  BASE
         TITLE 'RFINDID - PROCESS RFIND COMMAND'
**********************************************************************
*               R F I N D I D       R O U T I N E                    *
*                                                                    *
*     THIS ROUTINE PROCESSES THE RFIND COMMAND ENTERED FROM THE      *
*   COMMAND LINE (CMDL).  RFIND LOOKS FOR THE USERID ON SPF STATS    *
*   FOR A GIVEN MEMBER.  ALL WE DO HERE IS VALIDATE THAT WE ALREADY  *
*   HAVE AN OPERAND FROM A PREVIOUS FIND, THEN GO TO THE FINDID      *
*   ROUTINE TO ACTUALLY PROCESS IT.                                  *
*                                                                    *
**********************************************************************
         SPACE
         USING RFINDID,BASE
         SPACE
RFINDID  DS@ENTR ,
         CLC   FINDPARM,BLANKS        IF FIND NOT PREVIOUSLY DONE,
         BNE   RFINDID2
         LA    R1,MSG32                 SET MESSAGE NUMBER
         DO    PUTMSG                   GIVE IT TO ISPF
         B     RFINDIDX                 AND GET OUT OF HERE
RFINDID2 DS    0H
         DO    FINDIT
         SLR   R15,R15
RFINDIDX DS    0H
         OI    FLAGBYT2,NOPUT         DON'T DO TBPUT
         DS@EXIT RET=R15
         DROP  BASE
         TITLE 'PERFORM THE FIND (USERID)'
**********************************************************************
*              F I N D I T          R O U T I N E                    *
*                                                                    *
*     THIS ROUTINE PERFORMS THE FIND USERID BY ISSUING A TBSCAN FOR  *
*   THE FIELD TBUSERID.  IF IT IS FOUND, THE TABLE IS SET TO BE POS- *
*   ITIONED FOR THE NEXT TBDISPL.  IF IT IS NOT FOUND, AN ISPF       *
*   MESSAGE IS SET.                                                  *
*                                                                    *
**********************************************************************
         SPACE
         USING FINDIT,BASE
         SPACE
FINDIT   DS@ENTR ,
         L     R2,CURTBLNM            START FROM CURRENT POSITION
         LA    R3,SKIPNUM
         DO    TBTOP
         CALL  ISPLINK,(=CL8'TBSKIP',(R2),(R3)),VL,MF=(E,CALLPL)
         MVC   TBUSERID,FINDPARM      MOVE FIND STRING TO USERID
         XC    CALLPL(CALLPLL),CALLPL CLEAR CALL PARM LIST
         CALL  ISPLINK,(=CL8'TBSCAN',(R2),=C'(TBUSERID)',,,,,          +
               =CL8'CRP'),VL,MF=(E,CALLPL)     ISSUE TBSCAN
         LTR   R15,R15                IF RC ^= 0, (NOT FOUND) THEN
         BZ    FINDIT01
         DO    TBTOP                    GET TO TOP OF TABLE
         MVC   TBUSERID,FINDPARM        COPY TO TABLE VARIABLE
         XC    CALLPL(CALLPLL),CALLPL   CLEAR CALL PARM LIST
         CALL  ISPLINK,(=CL8'TBSCAN',(R2),=C'(TBUSERID)',,,,,          +
               =CL8'CRP'),VL,MF=(E,CALLPL)     ISSUE TBSCAN
         LTR   R15,R15                IF STILL NOT FOUND, THEN
         BZ    FINDIT01
         LA    R1,MSG12                 SET ERROR MESSAGE
         DO    PUTMSG                   GO PUT THE MESSAGE
         B     FINDITX                  AND GET OUT OF HERE
FINDIT01 DS    0H
         LA    R1,MSG31                 SET INFORMATIONAL MESSAGE
         DO    PUTMSG                   GO PUT THE MESSAGE
         MVC   SKIPNUM,CRP              SET CRP AS TOP TO BE DISPLAYED
FINDITX  DS    0H
         SLR   R15,R15                  CLEAR RC
         DS@EXIT RET=R15
         SPACE
         DROP  BASE
         TITLE 'CLEAR - DELETE TABLE ENTRIES FOR MEMBERS DELETED'
**********************************************************************
*               C L E A R           R O U T I N E                    *
*                                                                    *
*     THIS ROUTINE PROCESSES THE CLEAR COMMAND, WHICH SERVES TO      *
*   DELETE TABLE ENTRIES FOR MEMBERS THAT HAVE BEEN DELETED.  THE    *
*   PROCESS IS VERY SIMPLE.  WE DO A TBTOP, AND THEN STEP THROUGH    *
*   THE TABLE CHECKING TO SEE IF THE MEMBER HAS BEEN DELETED.  IF    *
*   SO, WE DO A TBDELETE.  THIS IS DONE UNTIL THE END OF THE TABLE   *
*   IS REACHED, THEN THE TABLE IS PUT AT THE TOP.                    *
*                                                                    *
**********************************************************************
         SPACE
         USING CLRTBL,BASE
         SPACE
CLRTBL   DS@ENTR ,
         L     R2,CURTBLNM
         L     R3,NUMMEM              GET NUMBER IN TABLE
         DO    TBTOP                  GET TO TOP OF TABLE
CLRLOOP  DS    0H
         CALL  ISPLINK,(=CL8'TBSKIP',(R2)),VL,MF=(E,CALLPL)
         LTR   R15,R15                IF END OF TABLE, THEN
         BNZ   CLRTBLX                  WE ARE DONE
         CLI   TBLIB#,C' '            IF MEMBER DELETED,
         BNE   CLRTBL1                  DELETE IT FROM THE TABLE
         CALL  ISPLINK,(=CL8'TBDELETE',(R2)),VL,MF=(E,CALLPL)
         BCTR  R3,0                     SUBTRACT FROM COUNTER
         B     CLRLOOP                  AND GO AGAIN
CLRTBL1  DS    0H                     ELSE
         CLC   TBSTAT,BLANKS            IF TBSTAT NOT BLANK
         BE    CLRTBL2
         MVC   TBSTAT,BLANKS              SET IT TO BLANK
         MVC   TBSEL,BLANKS               BLANK SELECTION FIELD
         B     CLRTBL3                    GO UPDATE THE TABLE
CLRTBL2  DS    0H
         CLC   TBSEL,BLANKS             IF TBSEL NOT BLANK
         BE    CLRLOOP
         MVC   TBSEL,BLANKS               BLANK SELECTION FIELD
CLRTBL3  DS    0H
         DO    PUTTBL                     GO UPDATE TABLE ENTRY
         B     CLRLOOP                    LOOP
CLRTBLX  DS    0H
         ST    R3,NUMMEM              SAVE COUNT IN TABLE
         OI    FLAGBYT2,NOPUT         DON'T DO TBPUT
         SLR   R15,R15                CLEAR RC
         DS@EXIT RET=R15
         SPACE
         DROP  BASE
         TITLE 'RBLDTBL - SET UP TO CRANK THROUGH DATASET(S) AGAIN'
**********************************************************************
*               R B L D T B L       R O U T I N E                    *
*                                                                    *
*     THIS SUBROUTINE IS CALLED BY THE SWITCH/REBUILD COMMANDS.      *
*   WE WANT TO "POP" ALL OF THE CURRENT TABLES, AND SET UP TO        *
*   START ALL OVER.                                                  *
*                                                                    *
**********************************************************************
         SPACE
         USING RBLDTBL,BASE
         SPACE
RBLDTBL  DS@ENTR ,
RPOPLOOP DS    0H
         DO    POPTBL                 DO THE TBEND
         L     R1,NUMTBLNM            GET NUMBER OF TABLE NAMES
         LTR   R1,R1                  IF MORE TABLES STACKED, THEN
         BNZ   RPOPLOOP                 CONTINUE
         MVI   RBLDFLAG,FLAGON        TURN ON REBUILD FLAG
         MVI   FLAGBYTE,0             RESET FLAGBYTE FOR REBUILD
         XC    MPR,MPR                CLEAR THIS COUNTER
         OI    FLAGBYTE,ALLMEM        SAY ALL MEMBERS, VARS INITTED
         MVI   USEROP,C'N'            NO GENERIC USERID
         OI    FLAGBYT2,NOPUT         DON'T DO TBPUT
         MVI   FLAGBYT3,0             RESET ALL OF THESE FLAGS
         LH    R2,NUMDS               GET NUMBER OF DATA SETS
         LA    R3,DSPTRS              ADDRESS DSPTR TABLE
RBLDLP2  DS    0H
         L     R11,0(R3)              ADDRESS DSTBL ELEMENT
         NI    FLAG,255-(GETBLK+EOFDSL+EOFDSP) CLEAR FLAG
         NI    FLAG2,255-RECFMU       CLEAR FLAG
         XC    DIRBLKU,DIRBLKU        CLEAR THESE FIELDS
         XC    DIRBLKM,DIRBLKM
         XC    MEMCNT,MEMCNT          CLEAR COUNT OF MEMBERS
         LA    R3,4(,R3)              NEXT ONE IN TABLE
         BCT   R2,RBLDLP2             AND DO FOR EACH ONE
         DS@EXIT ,
         SPACE
         DROP  BASE
         TITLE 'TOPTBL - PROCESS "TOP" COMMAND'
**********************************************************************
*               T O P T B L         R O U T I N E                    *
*                                                                    *
*     THIS ROUTINE PROCESSES THE TOP COMMAND, BY SIMPLY RESETTING    *
*  SKIPNUM TO 1.                                                     *
*                                                                    *
**********************************************************************
         SPACE
TOPTBL   DS    0H
         LA    R1,1
         L     R2,CURTBLNM            GET CURRENT TABLE NAME
         ST    R1,SKIPNUM             SET NUMBER FOR TBSKIP
         OI    FLAGBYT2,NOPUT         DON'T DO TBPUT
         SLR   R15,R15                CLEAR RC
         BR    R14                    AND RETURN
         TITLE 'RIGHT - PROCESS NO-OP COMMAND'
**********************************************************************
*                 R I G H T         R O U T I N E                    *
*                                                                    *
*     THIS ROUTINE PROCESSES THE RIGHT COMMAND, WHICH IS ONLY USED   *
*   VIA CMDL (EITHER TYPED ON THE COMMAND LINE, OR PFKEY).  THE ONLY *
*   THING TO DO HERE, IS SET A FLAG FOR THE GETPAN ROUTINE.          *
*                                                                    *
**********************************************************************
         SPACE
         USING RIGHT,R15
         SPACE
RIGHT    DS    0H
         MVI   SCRLLFLG,FLAGON        SET FLAG
         SLR   R15,R15                CLEAR RC
         BR    R14                    THAT'S ALL FOLKS!!!
         SPACE
         DROP  R15
         TITLE 'LEFT - PROCESS NO-OP COMMAND'
**********************************************************************
*                  L E F T          R O U T I N E                    *
*                                                                    *
*     THIS ROUTINE PROCESSES THE LEFT,  OMMAND, WHICH IS ONLY USED   *
*   VIA CMDL (EITHER TYPED ON THE COMMAND LINE, OR PFKEY).  THE ONLY *
*   THING TO DO HERE, IS SET A FLAG FOR THE GETPAN ROUTINE.          *
*                                                                    *
**********************************************************************
         SPACE
         USING LEFT,R15
         SPACE
LEFT     DS    0H
         MVI   SCRLLFLG,FLAGOFF       SET FLAG
         SLR   R15,R15                CLEAR RC
         BR    R14                    THAT'S ALL FOLKS!!!
         SPACE
         DROP  R15
         TITLE 'IOF - PROCESS IOF COMMAND'
**********************************************************************
*                  I O F            R O U T I N E                    *
*                                                                    *
*     THIS ROUTINE PROCESSES THE IOF COMMAND--THIS IS SUPPOSED TO    *
*   BE FUNNY.                                                        *
*                                                                    *
**********************************************************************
         SPACE
         USING IOF,BASE
         SPACE
IOF      DS    0H
         DS@ENTR ,
         LA    R1,MSG41                 SET MESSAGE NUMBER
         DO    PUTMSG                   GO SET IT
         SLR   R15,R15                  CLEAR RETURN CODE
IOFX     DS    0H
         DS@EXIT RET=R15
         SPACE
         DROP  BASE
         TITLE 'MODE - PROCESS MODE COMMAND'
**********************************************************************
*             M O D E    C O M M A N D    P R O C E S S O R          *
*                                                                    *
*     THIS COMMAND PROCESSES THE MODE COMMAND, WHICH ALLOWS ONE TO   *
*   SWITCH BETWEEN BROWSE, EDIT, AND MEMBER LIST MODES.              *
*                                                                    *
**********************************************************************
         SPACE
         USING MODECMD,BASE
         SPACE
MODECMD  DS    0H
         DS@ENTR ,
         CLI   CMDSERV,FLAGON         IF SERVICE (NOT COMMAND), THEN
         BE    MODE05                   DON'T LOOK FOR OPERAND
         L     R1,WORD1L              GO SEE IF MODE ENTERED
         LTR   R1,R1                  IF NOTHING ENTERED, THEN
         BZ    MODE25                   GO SET A MESSAGE
         C     R1,=F'1'               IF LENGTH > 1, THEN
         BH    MODE25                   GO SET A MESSAGE
         MVC   DS@MODE,WORD1          ELSE GET MODE ENTERED
MODE05   DS    0H
         CLI   DS@MODE,C'B'           IF BROWSE MODE THEN
         BNE   MODE10
         L     R1,=A(CMDTBLB)           ADDRESS CMD TBL (BROWSE)
         LA    R2,CMDTBSZB              GET NUMBER OF TABLE ELEMENTS
         L     R3,=A(PNLNMTBE)          ADDRESS PANEL NAME TABLE
         B     MODE20
MODE10   DS    0H                     ELSE
         CLI   DS@MODE,C'E'             IF EDIT MODE, THEN
         BNE   MODE15
         L     R1,=A(CMDTBLE)             ADDRESS CMD TBL (EDIT)
         LA    R2,CMDTBSZE                GET NUMBER OF TABLE ELEMENTS
         L     R3,=A(PNLNMTBE)            ADDRESS PANEL NAME TABLE
         B     MODE20
MODE15   DS    0H                     ELSE
         CLI   DS@MODE,C'M'             IF MEMBER LIST MODE
         BNE   MODE25
         L     R1,=A(CMDTBLM)             MEMBER LIST COMMAND TBL
         LA    R2,CMDTBLSZ                GET NUMBER OF TABLE ELEMENTS
         L     R3,=A(PNLNMTBL)            ADDRESS PANEL NAME TABLE
MODE20   DS    0H
         ST    R1,CMDTBL@             SAVE COMMAND TABLE ADDRESS
         ST    R2,CMDTBL#             SAVE NUMBER IN COMMAND TABLE
         ST    R3,PNLTBL@             SAVE PANEL NAME TABLE ADDRESS
         B     MODEX
MODE25   DS    0H                     ELSE
         LA    R1,MSG2                  SET ERROR MESSAGE
         DO    PUTMSG                   GO PUT THE MESSAGE
         B     MODECMDX
MODEX    DS    0H
         MVC   MODE,DS@MODE           BE SURE TO UPDATE THIS ONE
         MVI   CMDSERV,FLAGOFF        BE SURE THIS IS RESET
         SLR   R15,R15                CLEAR RETURN CODE
MODECMDX DS    0H
         DS@EXIT RET=R15
         DROP  BASE
         TITLE 'SWITCH - PROCESS SWITCH COMMAND'
**********************************************************************
*           S W I T C H  C O M M A N D    P R O C E S S O R          *
*                                                                    *
*     THIS COMMAND PROCESSES THE SWITCH COMMAND, WHICH ALLOWS ONE    *
*   TO BUILD A MEMBER LIST FOR A NEW PDS FROM THE CURRENT MEMBER     *
*   LIST DISPLAY (I.E., WITHOUT HAVING TO GO BACK TO THE MENU).      *
*   THE BASIC PROCESS HERE IS TO RESET THE DATASET NAMES, THEN CALL  *
*   RBLDTBL ROUTINE TO ACT LIKE A REBUILD COMMAND WAS ENTERED.       *
*                                                                    *
**********************************************************************
         SPACE
         USING SWITCH,BASE
         SPACE
SWITCH   DS    0H
         DS@ENTR ,
         L     R1,WORD1L              GO SEE IF NEW DS ENTERED
         LTR   R1,R1                  IF NOTHING ENTERED, THEN
         BNZ   SWITCH10
         LA    R1,MSG3                  SET ERROR MESSAGE
         DO    PUTMSG                   GO PUT THE MESSAGE
         B     SWITCHX                  AND WE'RE DONE
SWITCH10 DS    0H
         LR    R2,R1                  COPY LENGTH RETURNED
         L     R11,DSTABL@            ADDRESS DATASET TABLE
         XC    MEMCNT,MEMCNT          CLEAR COUNT OF MEMBERS
         MVC   DSN1(DSNAMELL),BLANKS  BLANK OUT OLD DSNAMES
         MVC   MEMBER,BLANKS          AND MEMBER NAME
         MVC   VOL1,BLANKS            AND VOLUME
         NI    FLAGBYTE,255-ALLMEM    RESET THIS FLAG
         LA    R1,DSNAMEL             GET LENGTH OF A DSNAME
         ST    R1,DSN1L               SET THIS FOR DIALOG MANAGER
         BCTR  R2,0                   GET EXECUTE LENGTH
         LA    R1,DSN1                ADDRESS AREA FOR NAME
         LR    R4,R1                  COPY THIS
         CLI   WORD1,C''''            IF DSNAME NOT QUALIFIED, THEN
         BE    SWITCH20
         MVC   0(8,R1),ZPREFIX          MOVE IN USER'S PREFIX
         A     R1,ZPREFIXL              ADD LENGTH OF PREFIX
         MVI   0(R1),C'.'               MOVE IN A PERIOD
         LA    R1,1(,R1)                GET PAST IT
         EX    R2,SWTCHMV               MOVE IN DSNAME
         LA    R1,1(R1,R2)              GET PAST STRING JUST MOVED
         B     SWITCH30                 AND CONTINUE
SWITCH20 DS    0H                     ELSE /* QUALIFIED DSNAME */
         LA    R3,WORD1                 ADDRESS THE NAME
         AR    R3,R2                    GET TO END OF STRING
         CLI   0(R3),C''''              IF ENDING APOSTROPHE, THEN
         BNE   *+6
         BCTR  R2,0                       GET EXECUTE LENGTH
         EX    R2,SWTCHMV2                MOVE IN DSNAME
         AR    R1,R2                    GET PAST STRING JUST MOVED
         MVI   0(R1),C' '               ENSURE IT IS BLANK
SWITCH30 DS    0H
         LR    R2,R1                  COPY CURRENT POINTER
         CLI   STACKF,FLAGON          IF ^STACK CALLING US, THEN
         BE    SWITCH40
         DO    RBLDTBL                  SET US UP FOR A REBUILD
         MVC   NUMDS,=H'1'              RESET NUMDS
SWITCH40 DS    0H
         BCTR  R1,0                   GET PREVIOUS BYTE IN DSNAME
         CLI   0(R1),C')'             IF ENDING ')' (MEMBER NAME)
         BNE   SWITCH60
         LR    R2,R1                    COPY R1
         SH    R2,=H'10'                POINT TO BEGINNING OF MEM NAME
         LA    R3,DSN1                  ENSURE R2 NOT IN FRONT OF R3
         CR    R2,R3
         BH    *+4
         LR    R2,R3
SWITCHLP DS    0H                       LOOP TO FIND BEGINNING '('
         CR    R2,R1
         BE    SWITCH60
         CLI   0(R2),C'('
         BE    SWTCHLPX
         LA    R2,1(,R2)
         B     SWITCHLP
SWTCHLPX DS    0H
         LA    R2,1(,R2)                GET PAST '('
         SR    R1,R2                    GET DIFFERENCE (LENGTH)
         C     R1,=F'8'                 IF GREATER THAN 8, THEN
         BH    SWITCH60                   LET IT FLY AS IT IS
         BCTR  R1,0                       MAKE IT AN EXECUTE LENGTH
         EX    R1,SWTCHMV3                MOVE DATA TO MEMBER NAME
         BCTR  R2,0                       BACK POINTER UP 1
         LA    R1,2(,R1)                  ADJUST EXECUTE LENGTH
         EX    R1,SWTCHMV4                BLANK MEMBER NAME FROM DSNAME
         DO    MEMLNG                     GO PROCESS IT
         NI    FLAGBYT3,255-SINGMEM       BE SURE THIS FLAG IS OFF
SWITCH60 DS    0H
         SR    R2,R4                  CALCULATE DS NAME LENGTH
         ST    R2,DSNLNG              SAVE IN TABLE
SWITCH70 DS    0H
         MVI   SWITCHF,FLAGON         SAY SWITCH HAS BEEN DONE
         SLR   R15,R15                CLEAR RETURN CODE
SWITCHX  DS    0H
         DS@EXIT RET=R15
         SPACE
SWTCHMV  MVC   0(0,R1),WORD1
SWTCHMV2 MVC   0(0,R1),WORD1+1
SWTCHMV3 MVC   MEMBER(0),0(R2)
SWTCHMV4 MVC   0(0,R2),BLANKS
         SPACE
         DROP  BASE
         TITLE 'REBUILD - PROCESS THE REBUILD COMMAND'
**********************************************************************
*               R E B U I L D       R O U T I N E                    *
*                                                                    *
*     THIS SUBROUTINE PROCESS THE REBUILD COMMAND, WHICH ALLOWS THE  *
*   USER TO REBUILD THE CURRENT MEMBER LIST WITH THE CURRENT DATA-   *
*   SETS, AND OPTIONALLY SPECIFY A GENERIC MEMBER NAME.              *
*                                                                    *
**********************************************************************
         SPACE
         USING REBUILD,BASE
         SPACE
REBUILD  DS@ENTR ,
         DO    RBLDTBL                GO SET UP FOR REBUILD
         MVC   MEMBER,WORD1           MOVE IN OPERAND
         DO    MEMLNG                 GO PROCESS IT
         SLR   R15,R15                CLEAR RC
         DS@EXIT RET=R15
         SPACE
         DROP  BASE
         TITLE 'STACK - PROCESS STACK COMMAND'
**********************************************************************
*           S T A C K    C O M M A N D    P R O C E S S O R          *
*                                                                    *
*     THIS COMMAND PROCESSES THE STACK COMMAND, WHICH SETS UP A      *
*   RECURSIVE INVOCATION OF THIS PROGRAM IN ORDER TO STACK MEMBER    *
*   LISTS.                                                           *
*                                                                    *
**********************************************************************
         SPACE
         USING STACK,BASE
         SPACE
STACK    DS    0H
         DS@ENTR ,
         MVC   SAVDSNMS,DSN1          SAVE DATASET NAME
         MVC   SAVDSNML(16),DSN1L     SAVE THESE LENGTHS TOO
         MVI   SCOP,C'N'              SET SCAN OPTION TO NO
         MVI   USEROP,C'N'            SET USEROP TO NO
         MVI   STACKF,FLAGON          SAY STACK COMMAND
         DO    SWITCH                 ACT LIKE IT'S A SWITCH
         LTR   R15,R15                IF OK RETURN CODE, THEN
         BNZ   STACKRX
         MVI   SWITCHF,FLAGOFF          TURN SWITCH FLAG OFF
         LA    R2,STCKVPTB              ADDRESS THE TABLE
         CALL  ISPLINK,(=CL8'VPUT',(R2),=CL8'SHARED'),VL,MF=(E,CALLPL)
         CALL  ISPLINK,(=CL8'SELECT',=F'13',=C'PGM(DS@SCPDS)',),VL,    +
               MF=(E,CALLPL)
STACKX   DS    0H
         MVC   DSN1(DSNAMELL),SAVDSNMS RESTORE DATASET NAMES
         MVC   DSN1L(16),SAVDSNML     RESTORE LENGTHS
         MVI   STACKF,FLAGOFF         BE SURE THIS IS RESET
         DO    SETATTN                RESET ATTENTION EXIT
         SLR   R15,R15                CLEAR RC
STACKRX  DS    0H
         DS@EXIT RET=R15
         SPACE
STCKVPTB DC    C'(DS@DSN1 DS@DSN2 DS@DSN3 DS@DSN4 DS@MEM DS@VOL DS@UOP +
               DS@SCOP DS@MODE DS@LVL)'
         SPACE
         DROP  BASE
         TITLE 'PROCCMDL - PROCESS THE COMMAND LINE'
**********************************************************************
*              P R O C C M D L      R O U T I N E                    *
*                                                                    *
*     THIS SUBROUTINE IS USED TO PROCESS COMMAND FROM THE COMMAND    *
*   LINE (CMDL).  BASICALLY, THE COMMAND LINE IS PARSED, AND THEN    *
*   A ROUTINE IS CALLED TO DISPATCH THE COMMAND.                     *
*                                                                    *
**********************************************************************
         SPACE
         USING PROCCMDL,BASE
         SPACE
PROCCMDL DS    0H
         CLC   SAVCMDL,BLANKS         IF CMDLINE IS NOT GIVEN
         BER   R14                      THEN LEAVE
         DS@ENTR ,
         XC    CRP,CRP                CLEAR CURRENT ROW POINTER
         DO    GETWORD                GO PARSE COMMAND LINE
         DO    GETCMD                 GO VALIDATE COMMAND
         LTR   R6,R15                 IF COMMAND NOT VALID
         BNZ   OKCMDL                   GO SET A MESSAGE
         LA    R1,MSG16                 USE THIS MESSAGE
         DO    PUTMSG                   GO GIVE IT TO ISPF
         B     PZRETRN
OKCMDL   DS    0H                     ELSE
         LH    R3,CMDOPS                GET NUMBER OF OPERANDS
         L     R2,WORD1L                GET 1ST OPERAND LENGTH
         LTR   R3,R3                    IF NONE ALLOWED, AND
         BNZ   PZ105
         LTR   R2,R2                         ONE OPERAND AT LEAST
         BZ    PZ105
         LA    R1,MSG47                   SET THE MESSAGE
         DO    PUTMSG                     GO SET THE ERROR
         B     PZRETRN                    AND LEAVE
PZ105    DS    0H                     ELSE
         TM    CMDFLAG,MEMNREQ          IF MEMBER NAME REQUIRED,
         BZ    PZ115
         LTR   R2,R2                    IF ^ GIVEN, THEN
         BNZ   PZ110
         LA    R1,MSG17                   SET THE MESSAGE
         DO    PUTMSG                     GO SET THE ERROR
         B     PZRETRN                    AND LEAVE
PZ110    DS    0H
         MVC   TBMEM,WORD1              SET MEMBER NAME FROM WORDQ
         MVC   MEMBER,TBMEM             SET VARIABLE FOR ROUTINE
         DO    MEMLNG                   SEE IF GENERIC
         TM    FLAGBYTE,GENERIC+ALLMEM  IF GENERIC OR '*' GIVEN, THEN
         BZ    PZ115
         TM    CMDFLAG,GENMEM             IF GENERIC NOT ALLOWED,
         BO    PZ115
         LA    R1,MSG46                     SET THE MESSAGE
         DO    PUTMSG                       GO GIVE IT TO ISPF
         B     PZRETRN                      AND LEAVE
PZ115    DS    0H
         L     R5,CMDADDR               GET COMMAND ADDRESS
         OI    FLAGBYT2,CMDLPRC         SAY COMMAND LINE PROCESSING
         TM    CMDFLAG,MEMNREQ          IF ^ MEMBER COMMAND  OR
         BZ    PRCC03
         TM    FLAGBYT3,SINGMEM           SINGLE MEMBER NAME, THEN
         BZ    PRCC05                     PROCESS COMMAND NOW
PRCC03   DS    0H
         TM    CMDFLAG,MEMNREQ          IF MEMBER NAME REQUIRED AND
         BZ    PRCC04
         TM    CMDFLAG,NEWMEM                NEW MEMBER NOT ALLOWED,
         BO    PRCC04
         DO    FNDTBMEM                   SEE IF IN TABLE
         LTR   R15,R15                    IF NOT FOUND, THEN
         BZ    PRCC04
         LA    R1,MSG18                     SET MESSAGE NUMBER
         DO    PUTMSG                       GIVE IT TO ISPF
         B     PZRETRN                      AND LEAVE
PRCC04   DS    0H
         L     R11,CURDSN               SET DS TABLE BASE
         LR    R15,R5                   COPY COMMAND ADDRESS
         BALR  R14,R15                  DISPATCH IT
         LTR   R15,R15                  IF RC FROM COMMAND ^= 0, THEN
         BNZ   PZRETRN                    LEAVE
         DO    PUTTBL                   UPDATE TABLE IF NEEDED
         B     PROCGENX                 AND WE'RE DONE
PRCC05   DS    0H
         TM    CMDFLAG,OGENPRC         IF COMMAND WILL DO OWN GENERIC,
         BO    PRCC04                    GO DISPATCH ABOVE
         SLR   R4,R4                    CLEAR COUNTER
         DO    TBTOP                    GET TO TOP OF TABLE
         L     R2,CURTBLNM              GET CURRENT TABLE NAME IN BASE
PRCGNLP  DS    0H
         CLI   STAXFLAG,FLAGON          IF ATTENTION HIT, THEN
         BE    PROCGENX                 GET OUT OF LOOP
         XC    CALLPL(CALLPLL),CALLPL CLEAR CALL PARM LIST
         TM    FLAGBYTE,ALLMEM          IF ALL MEMBERS, THEN
         BZ    PRCGN10                    DO TBSKIP
         CALL  ISPLINK,(=CL8'TBSKIP',(R2),,,,,,=CL8'CRP'),VL,          +
               MF=(E,CALLPL)              ISSUE TBSCAN
         B     PRCGN20
PRCGN10  DS    0H                       ELSE
         MVC   TBMEM,MEMBER               SET FOR TBSCAN
         CALL  ISPLINK,(=CL8'TBSCAN',(R2),=C'(TBMEM)',,,,,=CL8'CRP'),  +
               VL,MF=(E,CALLPL)           ISSUE TBSCAN
PRCGN20  DS    0H
         LTR   R15,R15                  IF RC ^= 0, THEN
         BZ    PRCGN30
         LTR   R4,R4                      IF NONE FOUND YET, THEN
         BNZ   PROCGENX
         LA    R1,MSG18                     SET MESSAGE NUMBER
         DO    PUTMSG                       GIVE IT TO ISPF
         B     PZRETRN                      AND LEAVE
PRCGN30  DS    0H                       ELSE (RC = 0)
*        MVC   SKIPNUM,CRP                SAVE FOR LATER
         CLI   TBLIB#,C' '                IF MEMBER ALREADY DELETED,
         BE    PRCGNLP                      THEN IGNORE THIS ONE
         LA    R4,1(,R4)                  INCREMENT COUNTER
         DO    SETCURDS                   SET CURRENT DATA SET
         L     R11,CURDSN                 GET VALUE SET
         LR    R15,R5                     LOAD COMMAND ADDRESS
         BALR  R14,R15                    DISPATCH THE COMMAND
         LTR   R15,R15                   IF RC FROM COMMAND ^= 0, THEN
         BNZ   PZRETRN                      LEAVE
         DO    PUTTBL                      ELSE UPDATE TABLE IF NEEDED
         B     PRCGNLP                       AND LOOP
PROCGENX DS    0H
         SLR   R15,R15
PZRETRN  DS    0H
         MVC   CMDLINE,BLANKS             RESET COMMAND LINE
         LTR   R15,R15                    IF RC ^= 0, THEN
         BZ    PRCCMDLX
         MVC   CMDLINE,SAVCMDL              RESTORE COMMAND LINE
PRCCMDLX DS    0H
         DS@EXIT ,
         SPACE
         DROP  BASE
         TITLE 'FNDTBMEM - FIND MEMBER IN TABLE'
**********************************************************************
*              F N D T B M E M      R O U T I N E                    *
*                                                                    *
*     THIS ROUTINE DETERMINES IF THE MEMBER NAMED BY TBMEM IS        *
*   IN THE ISPF TABLE.  IT IS CALLED BY THE COMMAND PROCESSING       *
*   ROUTINES WHEN PROCESSING A COMMAND FROM THE COMMAND LINE (CMDL). *
*   THE TABLE ELEMENT MAY NOT EXIST BECAUSE THE MEMBER NAME IS       *
*   INVALID, OR BECAUSE THE TABLE ELEMENT WAS ALREADY DELETED. IF    *
*   EITHER IS TRUE, WE SET A NON-ZERO RETURN CODE, AND RETURN.       *
*   IF THE TABLE MEMBER IS FOUND, AND IF MORE THAN ONE DATA SET,     *
*   THEN SETCURDS ROUTINE IS CALLED TO SET THE CURRENT DATASET PTR.  *
*                                                                    *
**********************************************************************
         SPACE
         USING FNDTBMEM,BASE
         SPACE
FNDTBMEM DS@ENTR ,
FNDTBLP  DS    0H
         L     R2,CURTBLNM
         XC    CALLPL(CALLPLL),CALLPL CLEAR CALL PARM LIST
         CALL  ISPLINK,(=CL8'TBSCAN',(R2),=C'(TBMEM)',,,,,=CL8'CRP'),  +
               VL,MF=(E,CALLPL)         ISSUE TBSCAN
         LTR   R15,R15                IF MEMBER FOUND THEN
         BNZ   FNDTBMX
         CLI   TBLIB#,C' '              IF MEMBER ALREADY DELETED,
         BE    FNDTBLP                    THEN TRY AGAIN
*                                       ELSE
         TM    FLAGBYT2,NORSKIP           IF ALLOWED TO RESET SKIP,
         BO    FNDTBM10
         MVC   SKIPNUM,CRP                  SAVE FOR LATER
FNDTBM10 DS    0H
         NI    FLAGBYT2,255-NORSKIP       RESET THE FLAG
         CLC   NUMDS,=H'1'                IF MORE THAN ONE DATA SET
         BE    FNDTBMX
         DO    SETCURDS                     GO SET CURRENT DATA SET
         LR    R11,R15                      PUT IT INTO BASE
         SLR   R15,R15                      CLEAR RC FOR RETURN
FNDTBMX  DS    0H
         DS@EXIT RET=R15
         SPACE
         DROP  BASE
         TITLE 'GETCMD - GET COMMAND FROM COMMAND TABLE'
**********************************************************************
*                G E T C M D        R O U T I N E                    *
*                                                                    *
*     THIS ROUTINE  DETERMINES IF THE COMMAND IN WORD1 IS A VALID    *
*   COMMAND.  IF IT IS, THEN R15 IS RETURNED WITH THE ADDRESS OF THE *
*   CORRESPONDING COMMAND TABLE ELEMENT.  IF IT IS AN INVALID        *
*   COMMAND, THEN R15 IS RETURNED AS ZERO, AND AN ISPF MESSAGE IS    *
*   SET.                                                             *
*                                                                    *
**********************************************************************
         SPACE
         USING GETCMD,BASE
         SPACE
GETCMD   DS@ENTR ,
         L     R1,TXCNT               GET TRANSACTION COUNTER
         A     R1,=F'1'               ADD 1 TO IT
         ST    R1,TXCNT               AND STORE IT BACK
         L     R6,CMDTBL@             GET COMMAND TABLE @ INTO BASE
         L     R7,CMDTBL#             GET NUMBER OF TABLE ELEMENTS
GCDLOOP  DS    0H
         CLC   CMDNAME,WORD0          IF COMMAND BEYOND IN ORDERED TBL,
         BH    GCMD010                  NOT A VALID ONE,
         BE    GCMDRET                IF WE HAVE IT, GOOD
         LA    R6,CMDTBLL(,R6)        ELSE NEXT TABLE ELEMENT
         BCT   R7,GCDLOOP               AND LOOP
GCMD010  DS    0H
         SLR   R6,R6                  CLEAR FOR RETURN
GCMDRET  DS    0H
         LR    R15,R6                   SET VALUE FOR RETURN
         DS@EXIT RET=R15
         SPACE
         DROP  BASE
         TITLE 'GETWORD - PARSE COMMAND LINE COMMAND/OPERANDS'
**********************************************************************
*             G E T W O R D         R O U T I N E                    *
*                                                                    *
*     THIS ROUTINE PARSES THE COMMAND IN SAVCMDL, WHICH IS GOTTEN    *
*   FROM THE DISPLAY COMMAND LINE.  THE COMMAND IS PLACED IN THE     *
*   FIELD WORD0, AND ANY OPERANDS ARE PLACED WORD1 THROUGH WORD4.    *
*   THE LENGTH OF EACH IS ALSO PUT IN THE CORRESPONDING FULLWORD.    *
*                                                                    *
**********************************************************************
         SPACE
         USING GETWORD,BASE
         SPACE
GETWORD  DS@ENTR ,
         MVC   WORD0(WORDQL),BLANKS   CLEAR WORD FIELDS
         XC    WORD0L(WORDLL),WORD0L  CLEAR LENGTHS
         LA    R8,WORD0               ADDRESS WORD QUEUE
         LA    R6,SAVCMDL             ADDRESS OF BUFFER
         LA    R5,WORD0L              ADDRESS START OF WORD QUEUE
         SLR   R4,R4                  CLEAR COUNTER
GWLOOP1  DS    0H
         CLI   0(R6),X'FF'            SKIP CURRENT POSITION
         BE    GETWORDX                 TO FIRST NON-BLANK
         CLI   0(R6),C' '
         BNE   GWLPX1
         LA    R6,1(,R6)
         B     GWLOOP1
GWLPX1   DS    0H
         LR    R7,R6                  COPY THIS POSITION
GWLOOP2  DS    0H
         CLI   0(R7),X'FF'            GET TO NEXT BLANK
         BE    GWLPX2
         CLI   0(R7),C' '
         BE    GWLPX2
         LA    R7,1(,R7)
         B     GWLOOP2
GWLPX2   DS    0H
         LR    R3,R7                  COPY CURRENT POSITION
         SR    R7,R6                  CALCULATE LENGTH
         ST    R7,0(,R5)              SAVE IT
         BCTR  R7,0                   DECREMENT FOR EXECUTE
         EX    R7,MVCWRD              AND MOVE INTO OPERAND
         LA    R5,4(,R5)              NEXT LENGTH
         LA    R8,L'WORD0(,R8)        NEXT WORD
         LA    R4,1(,R4)              INCREMENT OPERAND COUNT
         LR    R6,R3                  RESTORE CURRENT POSITION
         C     R4,=F'5'               IF WORD QUEUE IS FULL,
         BNL   GETWORDX                 THEN DONE
         B     GWLOOP1                ELSE LOOP
GETWORDX DS    0H
         DS@EXIT RET=R15              RETURN TO CALLER
         SPACE
MVCWRD   MVC   0(0,R8),0(R6)
         SPACE
         DROP  BASE
         TITLE 'ALCOPMEM - ALLOCATE/OPEN MEMBER DDNAMES'
**********************************************************************
*              A L C O P M E M      R O U T I N E                    *
*                                                                    *
*     THIS SUBROUTINE ALLOCATES AND OPENS FOR UPDATE THE PDS.        *
*   IT IS CALLED BY THE TABLE PROCESSING ROUTINES TO OPEN THE PDS    *
*   DIRECTORIES FOR A BLDL OR STOW.  THE ALLOCATION IS DONE ONLY IF  *
*   IF IT WAS NOT DONE DURING TABLE CONSTRUCTION (IF A SCAN STRING   *
*   WAS SPECIFIED, THEN THIS ALLOCATION HAS ALREADY OCCURRED).       *
*                                                                    *
*     INPUT:  R11 - ACTIVE DSTBL ELEMENT                             *
*     OUTPUT: R15 - ZERO IF ALL OK, NON-ZERO OTHERWISE               *
*                                                                    *
**********************************************************************
         SPACE
         USING ALCOPMEM,BASE
         SPACE
ALCOPMEM DS@ENTR ,
         SLR   R15,R15                CLEAR FOR RETURN
         TM    FLAG,ALCBPAM           IF ALREADY ALLOCATED, THEN
         BO    AOSKIP1                   SKIP ALLOCATION
         L     R1,DSNAME@
         MVC   ALCPBDSN,0(R1)         MOVE IN DS NAME FOR PROGRAM
         MVC   ALCPBDSN,0(R1)           MOVE DSNAME TO PARM BLOCK
         MVC   ALCPBDDN,BLANKS        CLEAR DDNAME FOR PROGRAM
         MVC   ALCPBMEM,BLANKS        CLEAR MEMBER FOR PROGRAM
         MVC   ALCPBVOL,VOL1          SET VOLUME PARAMETER
         LA    R2,DS@ALCPB            ADDRESS PARAMETER BLOCK
         CALL  DS@ALLOC,((R2)),VL,MF=(E,CALLPL) ALLOCATE IT
         LTR   R15,R15                IF ALLOCATION FAILED THEN
         BNZ   AOPMRET                   JUST LEAVE NOW
         OI    FLAG,ALCBPAM           INDICATE SUCCESSFUL ALLOCATION
         MVC   DDNAME2,ALCPBDDN       MOVE IN DDNAME RETURNED
AOSKIP1  DS    0H
         TM    FLAGBYT2,ALCONLY       IF ALLOCATE ONLY, THEN
         BO    AOPMRET                   LEAVE
         L     R6,DSNAME@             ADDRESS DATA SET FOR RACF CHECK
         LA    R7,ALCPBVOL            ADDRESS VOLSER FOR RACF CHECK
         L     R8,RACRWRK@            ADDRESS WORK AREA FOR RACROUTE
         RACROUTE ENTITY=((R6)),VOLSER=(R7),WORKA=(R8),REQUEST=AUTH,   +
               MF=(E,RACHKUPL)
         LTR   R15,R15                IF AUTHORIZED, THEN
         BZ    AOSKIP2                  SKIP
         L     R1,DSNAME@
         MVC   RACFERRD,0(R1)         ELSE CONSTRUCT ERROR MESSAGE
         MVC   ERRFIELD,RACFERRM
         LA    R1,MSG4                   SET THE MESSAGE
         DO    PUTMSG                    GO GIVE IT TO ISPF
         B     AOPMRET                AND GET OUT OF HERE
AOSKIP2  DS    0H
         MVI   SPBFUNC,SPBFOPEN       FUNCTION CODE IS OPEN
         MVI   SPBOPT2,SPBOUPDT         FOR UPDATE
         MVI   SPBOPT1,SPBOBPAM       ACCESS METHOD IS BPAM
         MVC   SPBDDNAM,DDNAME2       MOVE IN DDNAME
         MVC   SPBBUFNO,=F'1'         SET NUMBER OF BUFFERS
         XC    SPBDSORG,SPBDSORG      CLEAR DSORG
         MVI   SPBRECFM,0             CLEAR RECORD FORMAT
         XC    SPBLRECL,SPBLRECL      CLEAR LRECL
         XC    SPBBLKSI,SPBBLKSI      CLEAR BLOCK SIZE
         MVI   SPBOPT5,SPBNOENQ       NO ENQUEUES PLEASE
         CALL  SPAM,(SPB),VL,MF=(E,SPAMPL) GO OPEN THE PDS
         LH    R15,SPBRETC            GET OPEN RETURN CODE
         LTR   R15,R15                IF ALLOCATION FAILED THEN
         BNZ   AOPMRET                   JUST LEAVE NOW
         OI    FLAG,OPNBPAM           INDICATE SUCCESSFUL OPEN
         MVC   MEMSFB,SPBSFB          SAVE FILE BLOCK POINTER
         SLR   R15,R15                CLEAR RC
AOPMRET  DS@EXIT RET=R15
         SPACE
         DROP  BASE
         TITLE 'GETPAN - DETERMINE WHICH TBDISPL PANEL TO USE'
**********************************************************************
*                 G E T P A N     R O U T I N E                      *
*                                                                    *
*     THIS ROUTINE DETERMINES THE PANEL USED IN THE TBDISPL, WHICH   *
*   IS BASED ON THE NUMBER OF DATASETS AND WHETHER OR NOT THEY ARE   *
*   RECFM=U DATASETS.                                                *
*                                                                    *
**********************************************************************
         SPACE
         USING GETPAN,R15
         SPACE
GETPAN   DS    0H
         L     R1,PNLTBL@             ADDRESS PANEL NAME TABLE
         TM    FLAGBYT3,LOADLIB       IF LOAD LIBRARIES, THEN
         BZ    PROCTB01
         LA    R1,32(,R1)               USE THIS SET OF NAMES
PROCTB01 DS    0H
         CLC   NUMDS,=H'1'            IF MORE THAN 1 DATASET, THEN
         BNH   *+8
         LA    R1,16(,R1)               USE SECOND PANEL NAME
         CLI   SCRLLFLG,FLAGON          IF SCROLLED OVER, THEN
         BNE   *+8
         LA    R1,8(,R1)                  USE SCROLLED PANEL NAME
         MVC   TBPANEL,0(R1)          MOVE IN PANEL NAME
         BR    R14                    RETURN TO CALLER
         SPACE
         DROP  R15
         TITLE 'FINISH'
**********************************************************************
*               F I N I S H       R O U T I N E                      *
*                                                                    *
*     THIS ROUTINE IS USED TO CALL THE NECESSARY ROUTINES TO DO ALL  *
*   CLEANUP BEFORE RETURNING TO THE SYSTEM (CLOSING FILES, FREEING   *
*   DDNAMES, ETC).                                                   *
*                                                                    *
**********************************************************************
         SPACE
         USING FINISH,BASE
         SPACE
FINISH   DS@ENTR ,
         DO    CLEANUP                GO CLOSE FILES, FREE BUFFERS
         DO    FREEMEM                FREE MEMBER DDNAMES
         DO    DECONCAT               GO DO DECONCAT (IF NEEDED)
         DO    FREEDIR                FREE DIRECTORY DDNAMES
         DS@EXIT ,
         SPACE
         DROP  BASE
         TITLE 'CLEANUP ROUTINE'
**********************************************************************
*               C L E A N U P     R O U T I N E                      *
*                                                                    *
*   THIS ROUTINE CALLS SPAM TO CLOSE EACH OPEN DATASET AND TO FREE   *
* HIS DSA (FUNCTION CODE IS SCRAM).  BEFORE THIS, IF ALL MEMBERS     *
* WERE SPECIFIED, WE GO AHEAD AND READ TO THE END OF PDS DIRECTORIES *
* (PHYSICAL END), IN ORDER TO OBTAIN THE NUMBER OF DIRECTORY BLOCKS  *
* ALLOCATED (SHOWN BY THE INFO COMMAND).                             *
*                                                                    *
**********************************************************************
         SPACE
         USING CLEANUP,BASE
         SPACE
CLEANUP  DS@ENTR ,
         CLI   FLUSHDIR,FLAGON        IF WE ARE TO FLUSH THE DIRECTORY,
         BNE   CLEANUP5                             AND
         TM    FLAGBYTE,ALLMEM             ALL MEMBERS SPECIFIED,
         BZ    CLEANUP5
         LH    R6,NUMDS                 GET NUMBER OF DATA SET
         LA    R5,DSPTRS                ADDRESS DSPTRS
         MVI   SPBFUNC,SPBFGET          FUNCTION IS GET
CLEANLP1 DS    0H
         L     R11,0(R5)                ADDRESS DSTBL ELEMENT
         MVC   DIRBLKM,DIRBLKU          SET MAX = TO USED
         LH    R2,DIRBLKM               GET VALUE TO ACCUMULATE
         TM    FLAG,EOFDSP              IF NOT AT END ALREADY, THEN
         BO    CLEANNXT
         MVC   SPBSFB,DIRSFB              SET FILE BLOCK POINTER
CLEANLP2 DS    0H                         DO UNTIL (PHYSICAL EOF)
         CALL  SPAM,(SPB),VL,MF=(E,SPAMPL)  GO READ DIRECTORY BLOCK
         LH    R15,SPBRETC                  GET READ RETURN CODE
         LTR   R15,R15                      IF OK READ, THEN
         BNZ   CLEANL2X                       INCREMENT BLOCK COUNT
         LA    R2,1(,R2)
         B     CLEANLP2                   END /* LOOP */
CLEANL2X DS    0H
         STH   R2,DIRBLKM               SET ACCUMULATE VALUE
         OI    FLAG,EOFDSP              SET PHYSICAL EOF FLAG
CLEANNXT DS    0H
         LA    R5,4(R5)                 NEXT DSPTRS
         BCT   R6,CLEANLP1              AND LOOP
CLEANUP5 DS    0H
         MVI   FLUSHDIR,FLAGOFF       BE SURE FLAG IS OFF
         DO    SCRAM                  DO A SCRAM
         DS@EXIT ,
         SPACE
         DROP  BASE
         TITLE 'SCRAMOLA'
**********************************************************************
*                S C R A M          R O U T I N E                    *
*                                                                    *
*     THIS SUBROUTINE DOES CLOSES ALL OPEN DATASETS, RESETS THE      *
*  FLAGS, AND ISSUES A SPAM SCRAM (WHICH CAUSES SPAM TO FREE UP      *
*  MEMORY).                                                          *
*                                                                    *
**********************************************************************
         SPACE
         USING SCRAM,BASE
         SPACE
SCRAM    DS@ENTR ,
         MVI   SPBFUNC,SPBFCLOS       SPAM FUNCTION IS CLOSE
         LH    R2,NUMDS               GET NUMBER OF DATA SETS
         LA    R3,DSPTRS              ADDRESS DSPTR TABLE
SCRAMLP  DS    0H
         L     R11,0(R3)              ADDRESS DSTBL ELEMENT
         TM    FLAG,OPNBSAM           IF OPEN FOR DIRECTORY (INPUT),
         BZ    SCRAM10
         MVC   SPBSFB,DIRSFB            SET FILE BLOCK POINTER
         CALL  SPAM,(SPB),VL,MF=(E,SPAMPL) DO THE CLOSE
         NI    FLAG,255-OPNBSAM         CLEAR FLAG
         XC    DIRSFB,DIRSFB            CLEAR FILE BLOCK POINTER
SCRAM10  DS    0H
         TM    FLAG,OPNSCAN           IF OPEN FOR SCAN (INPUT),
         BZ    SCRAM20
         MVC   SPBSFB,SCNSFB            SET FILE BLOCK POINTER
         CALL  SPAM,(SPB),VL,MF=(E,SPAMPL) DO THE CLOSE
         NI    FLAG,255-OPNSCAN         CLEAR FLAG
         XC    SCNSFB,SCNSFB            CLEAR FILE BLOCK POINTER
SCRAM20  DS    0H
         TM    FLAG,OPNBPAM           IF OPEN FOR UPDATE, THEN
         BZ    SCRAM30
         MVC   SPBSFB,MEMSFB            SET FILE BLOCK POINTER
         CALL  SPAM,(SPB),VL,MF=(E,SPAMPL) DO THE CLOSE
         NI    FLAG,255-OPNBPAM         CLEAR FLAG
         XC    MEMSFB,MEMSFB            CLEAR FILE BLOCK POINTER
SCRAM30  DS    0H
         LA    R3,4(,R3)              NEXT ONE IN TABLE
         BCT   R2,SCRAMLP             AND DO FOR EACH ONE
         MVI   SPBFUNC,SPBFSCRM       FUNCTION CODE IS SCRAMOLA
         CALL  SPAM,(SPB),VL,MF=(E,SPAMPL) TELL SPAM TO SCRAM
         DS@EXIT ,
         SPACE
         DROP  BASE
         TITLE 'FREEDIR SUBROUTINE'
**********************************************************************
*               F R E E D I R     R O U T I N E                      *
*                                                                    *
*   THIS ROUTINE SIMPLY DEALLOCATES THE DDNAMES ALLOCATED FOR        *
* READING THE DIRECTORY, BY SPINNING THROUGH DSTBL (USING DSPTRS AND *
* NUMDS), AND CALLING DS@DEALC TO DEALLOCATE THE DDNAME INDICATED BY *
* THE ALCBSAM FLAG IN THE TABLE THAT ARE ALLOCATED.                  *
*                                                                    *
*   INPUT:  DSTBL - DATA SET TABLE                                   *
*           DSPTRS - POINTER TO ACTIVE ELEMENTS IN DSTBL             *
*           NUMDS - NUMBER OF DATA SETS WE ARE WORKING WITH          *
*                                                                    *
**********************************************************************
         SPACE
         USING FREEDIR,BASE
         SPACE
FREEDIR  DS@ENTR ,
         LH    R6,NUMDS               GET NUMBER OF DATA SET
         LA    R5,DSPTRS              ADDRESS DSPTRS
FDLOOP   DS    0H
         L     R11,0(R5)              ADDRESS DSTBL ELEMENT
         TM    FLAG,ALCBSAM           IF DDNAME NOT ALLOCATED
         BZ    FDSKIP                   THEN SKIP
         MVC   ALCPBDDN,DDNAME1       MOVE DDNAME TO PARM BLOCK
         LA    R2,DS@ALCPB            ADDRESS PARAMETER BLOCK
         CALL  DS@DEALC,((R2)),VL,MF=(E,CALLPL) DEALLOCATE IT
         NI    FLAG,255-ALCBSAM       RESET FLAG
FDSKIP   DS    0H
         LA    R5,4(R5)               NEXT DSPTRS
         BCT   R6,FDLOOP              AND LOOP
         DS@EXIT ,
         SPACE
         DROP  BASE
         TITLE 'FREEMEM SUBROUTINE'
**********************************************************************
*               F R E E M E M     R O U T I N E                      *
*                                                                    *
*   THIS ROUTINE SIMPLY DEALLOCATES THOSE DDNAMES ALLOCATED FOR      *
* READING THE PDS MEMBERS, BY BY SPINNING THROUGH DSTBL (USING       *
* DSPTRS AND NUMDS), AND CALLING DS@DEALC TO DEALLOCATE THE DDNAMES  *
* INDICATED BY THE ALCBPAM FLAG IN THAT TABLE THAT ARE ALLOCATED.    *
*                                                                    *
*   INPUT:  DSTBL - DATA SET TABLE                                   *
*           DSPTRS - POINTER TO ACTIVE ELEMENTS IN DSTBL             *
*           NUMDS - NUMBER OF DATA SETS WE ARE WORKING WITH          *
*                                                                    *
**********************************************************************
         SPACE
         USING FREEMEM,BASE
         SPACE
FREEMEM  DS@ENTR ,
         LH    R6,NUMDS               GET NUMBER OF DATA SET
         LA    R5,DSPTRS              ADDRESS DSPTRS
FMLOOP   DS    0H
         L     R11,0(R5)              ADDRESS DSTBL ELEMENT
         TM    FLAG,ALCBPAM           IF DDNAME NOT ALLOCATED
         BZ    FMSKIP                   THEN SKIP
         MVC   ALCPBDDN,DDNAME2       MOVE DDNAME TO PARM BLOCK
         LA    R2,DS@ALCPB            ADDRESS PARAMETER BLOCK
         CALL  DS@DEALC,((R2)),VL,MF=(E,CALLPL) DEALLOCATE IT
         NI    FLAG,255-ALCBPAM       RESET FLAG
FMSKIP   DS    0H
         LA    R5,4(R5)               NEXT DSPTRS
         BCT   R6,FMLOOP              AND LOOP
         DS@EXIT ,
         SPACE
         DROP  BASE
         TITLE 'SETCURDS SUBROUTINE'
**********************************************************************
*             S E T C U R D S     S U B R O U T I N E                *
*                                                                    *
*    THIS SUBROUTINE DETERMINES THE CURRENT DATA SET FROM TBLIB# AND *
*  SETS THE RETURN CODE TO POINT TO THE CORRESPONDING ENTRY IN DSTBL.*
*                                                                    *
**********************************************************************
         SPACE
         USING SETCURDS,BASE
         SPACE
SETCURDS DS@ENTR ,
         CLI   TBLIB#,C'1'            IF LIB# LESS THAN 1 OR
         BL    SETCURAB
         CLI   TBLIB#,C'4'                 GREATER THAN 4, THEN
         BNH   SETCUROK                    WE CAN'T RETURN A GOOD
SETCURAB DS    0H                          R15, SO
         DC    H'0'                     DIE 0C1
SETCUROK DS    0H                     ELSE
         SLR   R4,R4                    CLEAR WORK REGISTER
         IC    R4,TBLIB#                GET TBLIB#
         SLL   R4,28                    CLEAR ZONE NIBBLE
         SRL   R4,28                    RESTORE NOW
         BCTR  R4,0                     SUBTRACT ONE FROM LIB#
         SLL   R4,2                     X 4 TO GET TBARRAY OFFSET
         LA    R3,TBARRAY               ADDRESS TBARRAY
         AR    R3,R4                    ADD TO GET DISPLACMENT
         L     R15,0(R3)                SET CURDSN FOR RETURN
         ST    R15,CURDSN               SET IN DSA ALSO
         DS@EXIT RET=R15                AND RETURN TO CALLER
         SPACE
         DROP  BASE
         TITLE 'BUILD TABLE ENTRY SUBROUTINE'
**********************************************************************
*             B L D E N T R Y     S U B R O U T I N E                *
*                                                                    *
*    THIS SUBROUTINE BUILDS A TABLE ENTRY WHEN IT IS DETERMINED THAT *
*  WE HAVE A MATCH.  IT MOVES THE APPROPRIATE DATA TO TABLE          *
*  VARIABLES AND USES THE CONVERSION SUBROUTINES TO CONVERT THE      *
*  DATA TO DISPLAYABLE FORM.                                         *
*    INPUT: R14 - RETURN ADDRESS                                     *
*           PDS MEMBER DIRECTORY  ADDRESSED BY DSECT MEMENTRY (BASE  *
*           IS R4)                                                   *
*                                                                    *
**********************************************************************
         SPACE
         USING BLDENTRY,BASE
         USING MEMENTRY,R4
         SPACE
BLDENTRY DS@ENTR ,
         MVC   TBMEM,MEMNAME          MOVE MEMBER TO TABLE VARIABLE
         MVC   TBTTRX,TTR             PUT TTR IN TABLE
         UNPK  TBTTR(7),TTR(4)        UNPK TTR
         L     R2,=A(TRTABLE)         ADDRESS TRANSLATE TABLE
         TR    TBTTR,0(R2)            MAKE IT PRINTABLE
         CLC   TBTTRX,=XL3'0'         IF NO TTR, THEN
         BNE   BEOKTTR
         MVC   TBSTAT,=CL8'*DELETED'    SAY DELETED, AND
         MVI   TBLIB#,C' '              NO LIB
         B     BERETN                   WE'RE DONE
BEOKTTR  DS    0H
         TM    FLAGBYT3,LOADLIB       IF PROCESSING LOAD LIB, THEN
         BO    BLDLOAD                  GO BUILD THIS KIND OF ENTRY
         CLC   TBVERMOD,=C'ALIAS'     IF MEMBER IS ALIAS THEN
         BE    BERETN                   WE ARE DONE
         TM    FLAGBYTE,NOSTAT        IF MEMBER DOES NOT HAVE STATS
         BO    BERETN                   WE ARE DONE
         TM    UDCRTDT+2,X'0C'        IF INVALID DATE ON MEMBER,
         BNO   BERETN                   WE ARE DONE
BESKIP0  DS    0H
         MVC   VERMOD,UDVERMOD        MOVE VER/MOD FOR CONVERSION
         DO    CONVMOD                GO CONVERT VER/MOD
         LA    R9,TBCRTED             ADDRESS DATE ARE FOR CONVERSION
         MVC   JULDATE,UDCRTDT        MOVE IN DATE FOR SUBROUTINE
         DO    CONVDATE               GO CONVERT DATE CREATED
         LA    R9,TBLMDT              ADDRESS DATE ARE FOR CONVERSION
         MVC   JULDATE,UDLMDT         MOVE IN DATE FOR SUBROUTINE
         OI    JULDATE+2,X'0F'        ENSURE ZONE IS 'F'
         MVC   TBLMDTJ,JULDATE        SAVE IN TABLE
         DO    CONVDATE               GO CONVERT DATE LAST MODIFIED
         MVC   TIME,UDLMTM            MOVE TIME FOR CONVERSION
         DO    CONVTIME               GO CONVERT TIME OF LAST MODIFY
         MVC   SIZE,UDSIZE            GET SIZE FROM USER DATA
         LA    R1,TBSIZE              ADDRESS AREA FOR IT
         DO    CONVSIZE               SAVE IN TBL VARIABLE
         MVC   SIZE,UDINIT            GET INIT SIZE FROM USER DATA
         LA    R1,TBISIZE             ADDRESS AREA FOR IT
         DO    CONVSIZE               SAVE IN TBL VARIABLE
         MVC   SIZE,UDMOD             GET # OF MODIFIED LINES
         LA    R1,TBMOD               ADDRESS AREA FOR IT
         DO    CONVSIZE               SAVE IN TBL VARIABLE
         MVC   TBUSERID,UDUSER        MOVE IN THE USERID OF OWNER
         B     BERETN                 AND WE'RE DONE
BLDLOAD  DS    0H
         CLI   CFIELD,0             IF USER DATA, THEN
         BE    BERETN
         LR    R1,R4                  SET PARM REGISTER
         DO    BLDLOADI               GO BUILD LOAD MEMBER INFO
BERETN   DS    0H
         DS@EXIT ,
         SPACE
         DROP  R4,BASE
         TITLE 'UPDATE MEMBER INFO IN TABLE SUBROUTINE'
**********************************************************************
*               U P D M E M       S U B R O U T I N E                *
*                                                                    *
*    THIS SUBROUTINE RECONSTRUCTS THE TABLE INFORMATION FOR A MEMBER *
*  FROM THE DIRECTORY.  THIS ROUTINE IS CALLED AFTER THE BLDL INFOR- *
*  MATION IS GOTTEN.  WE FIRST DETERMINE THE LIB NUMBER, THEN DO     *
*  AWAY WITH THE K AND Z FIELDS OF BLDL, AND PASS THE BLDLIST TO THE *
*  BLDENTRY ROUTINE ABOVE, SINCE WE HAVE MADE IT LOOK LIKE A DIRECT- *
*  ORY ENTRY.                                                        *
*                                                                    *
**********************************************************************
         SPACE
         USING UPDMEM,BASE
         SPACE
UPDMEM   DS@ENTR ,
         SLR   R1,R1                  CLEAR R2 FOR IC
         IC    R1,BLDK                GET LIB LEVEL
         LA    R1,1(,R1)                -- IT IS ZERO BASED
         STC   R1,TBLIB#              SET TABLE VARIABLE
         OI    TBLIB#,C'0'            MAKE IT PRINTABLE
         MVC   BLDK(BLDLUPDL),BLDC    GET RID OF "K" & "Z" OF BLDL
         MVC   TBVERMOD(LTBLSHR1),BLANKS BLANK TABLE ELEMENT FIRST
         LA    R4,BLDLIST             SET PARM FOR ROUTINE
         DO    BLDENTRY               GO BUILD DIRECTORY INFO
         DS@EXIT ,
         SPACE
         DROP  BASE
         TITLE 'BUILD LOAD MODULE INFORMATION'
**********************************************************************
*                                                                    *
*    THIS SUBROUTINE BUILDS THE INFORMATION FOR THE A LOAD MODULE    *
*  PDS MEMBER.  UPON ENTRY, REGISTER 1 SHOULD POINT TO THE THE PDS   *
*  DIRECTORY ENTRY (NOTE--NOT A BLDL ENTRY).  THE TABLE VARIABLES    *
*  ARE UPDATED.                                                      *
*                                                                    *
**********************************************************************
         SPACE
         USING BLDLOADI,BASE
         SPACE
BLDLOADI DS@ENTR ,
         LR    R9,R1                  COPY PDS DIRECTORY BASE
         USING MEMENTRY,R9
         ICM   R1,B'0111',UDSIZEH     GET SIZE IN REG
         LA    R1,1023(,R1)           NEXT HIGHER 1K VALUE
         SRL   R1,10                  DIVIDE BY 1024
         CVD   R1,CNVWORK             CONVERT IT TO DECIMAL
         MVC   TBSIZEK-1,=X'4020202120D2' MOVE IN MASK
         ED    TBSIZEK-1(5),CNVWORK+6 MAKE IT PRINTABLE
         MVI   TBSIZEK+3,C'K'         PUT "K" IN IT
         TM    UDATTR3,ATTRA31        IF AMODE 31, THEN
         BZ    BLDLA24
         TM    UDATTR3,ATTRR31          IF RMODE 31, THEN
         BZ    BLDLNR31
         MVC   TBMODE,=C'R31'             SAY RMODE 31
         B     BLDLA24
BLDLNR31 DS    0H                       ELSE
         MVC   TBMODE,=C'A31'             SAY AMODE 31
BLDLA24  DS    0H
         SLR   R1,R1                  CLEAR FOR ICM
         ICM   R1,B'0111',UDEPA       GET ENTRY POINT ADDRESS IN R1
         CVD   R1,TBEPAX              CONVERT IT TO DECIMAL
         UNPK  TBEPA(7),UDEPA(4)      UNPK ENTRY POINT ADDRESS
         TR    TBEPA,0(R2)            MAKE IT PRINTABLE
         TM    UDATTR,ATTRRN          IF MODULE REENTRANT, THEN
         BZ    *+10
         MVC   TBRN,=C'RN'              INDICATE IT
         TM    UDATTR,ATTRRU          IF MODULE REUSABLE, THEN
         BZ    *+10
         MVC   TBRU,=C'RU'              INDICATE IT
         TM    UDATTR1,ATTRRF         IF MODULE REFRESHABLE, THEN
         BZ    *+10
         MVC   TBRF,=C'RF'              INDICATE IT
         TM    UDATTR,ATTROV          IF MODULE OVERLAY, THEN
         BZ    *+10
         MVC   TBOV,=C'OV'              INDICATE IT
         TM    UDATTR,ATTROL          IF ONLY LOADABLE, THEN
         BZ    *+10
         MVC   TBOL,=C'OL'              INDICATE IT
         TM    UDATTR,ATTREX          IF ^ EXECUTABLE, THEN
         BO    *+10
         MVC   TBNX,=C'NX'              INDICATE IT
         TM    UDATTR,ATTRTS          IF TEST SYMBOLS AVAIL, THEN
         BZ    *+10
         MVC   TBTS,=C'TS'              INDICATE IT
         TM    UDATTR2,ATTRSSI        IF SSI, THEN
         BZ    BLDLDNSI
         LA    R3,UDAPF                 ADDRESS BEGINNING OF EXTRA
         TM    UDATTR,ATTRSC            IF SCATTER, THEN
         BZ    *+8
         LA    R3,8(,R3)                  GET PAST SCATTER BYTES
         TM    CFIELD,X'80'             IF MEMBER ALIAS, THEN
         BZ    *+8
         LA    R3,11(,R3)                 GET PAST ALIAS LENGTH
         LA    R3,1(,R3)                ROUND UP TO HALFWORD
         N     R3,=F'-2'
         CLC   0(4,R3),=F'0'            IF ^ ZERO  AND
         BE    BLDLDNSI
         CLC   0(4,R3),=F'-1'               NOT -1, THEN
         BE    BLDLDNSI
         UNPK  TBSSI(9),0(5,R3)           UNPACK SSI
         TR    TBSSI,0(R2)                MAKE IT PRINTABLE
BLDLDNSI DS    0H
         TM    CFIELD,X'80'             IF ALIAS, THEN
         BZ    BLDLODIX
         MVC   TBALIAS,=CL8'*ALIAS'       INDICATE IT
         TM    CFIELD,X'10'               IF ALIAS NAME EXISTS,
         BZ    BLDLODIX
         MVC   TBALIAS,UDREAL               OBTAIN ALIAS NAME FROM
         TM    UDATTR,ATTRSC                   DIRECTORY
         BZ    *+10
         MVC   TBALIAS,UDREALS
BLDLODIX DS    0H
         DS@EXIT ,
         SPACE
         DROP  R9,BASE
         TITLE 'ATTENTION HANDLING ROUTINES'
**********************************************************************
*                                                                    *
*    THIS SUBROUTINE SETS UP THE ATTENTION (STAX), AND ALSO CONTAINS *
*  THE ATTENTION EXIT FOR PROCESSING IF AN ATTENTION OCCURS.         *
*                                                                    *
**********************************************************************
         SPACE
         USING SETATTN,BASE
         SPACE
SETATTN  DS@ENTR ,
         MVC   STAXPL(STAXML),STAXM   MOVE MASK TO DSA
         LA    R1,STAXFLAG
         ST    R1,STAXUADR
         LA    R2,STAXUADR
         STAX  ATTNEXIT,USADDR=(R2),MF=(E,STAXPL) SET UP THE ATTN EXIT
         DS@EXIT ,
         SPACE
STAXM    STAX  0,DEFER=NO,USADDR=0,MF=L MASK FOR STAX
STAXML   EQU   *-STAXM
         SPACE
         DROP  BASE
         SPACE 3
ATTNEXIT DS    0H
         L     R1,8(R1)               ADDRESS USER PARAMETER LIST
         L     R1,0(R1)               ADDRESS OF USER PARM
         MVI   0(R1),FLAGON           SAY ATTENTION WAS HIT
         BR    R14                    AND RETURN TO SYSTEM
         TITLE 'TIME ROUTINES'
**********************************************************************
*                                                                    *
*    THIS ROUTINE SAVES THE CURRENT CLOCK VALUE AND CALCULATES THE   *
*  THE TIME FOR THE NEXT TIME TO SHOW THE STATISTICS BY ADDING THE   *
*  FIELD TIMEVAL.                                                    *
*                                                                    *
**********************************************************************
         SPACE
         USING TIMESET,R15
         SPACE
TIMESET  DS    0H
         L     R1,TIMEVAL             GET TIMER VALUE GIVEN
         LTR   R1,R1                  IF ZERO, THEN
         BZR   R14                      SKIP ALL OF THIS
         STCK  CCLOCK                 SAVE CURRENT CLOCK
         L     R0,CCLOCK              GET FIRST WORD OF CLOCK VALUE
         AR    R0,R1                  ADD TIMER VALUE
         ST    R0,CCLOCK              AND SAVE AWAY
         BR    R14
         SPACE
         DROP  R15
         TITLE 'ISSUE ISPF TABLE PUT AND ADD ROUTINES'
**********************************************************************
*              P U T T B L        S U B R O U T I N E                *
*                                                                    *
*    THIS SUBROUTINE UPDATES AN ENTRY TO THE TABLE, BY ISSUEING THE  *
*  ISPF TBPUT COMMAND.                                               *
*    INPUT: R14 - RETURN ADDRESS                                     *
*           TABLE VARIABLES READY TO GO                              *
*                                                                    *
**********************************************************************
         SPACE
         USING PUTTBL,BASE
         SPACE
PUTTBL   DS@ENTR ,
         TM    FLAGBYT2,NOPUT        IF NOT NOPUT, THEN
         BO    PUTTBLX
         L     R2,CURTBLNM
         CALL  ISPLINK,(=CL8'TBPUT',(R2)),VL,MF=(E,CALLPL)
PUTTBLX  DS    0H
         DS@EXIT ,
         SPACE
         DROP  BASE
         SPACE 3
**********************************************************************
*              A D D T B L        S U B R O U T I N E                *
*                                                                    *
*    THIS SUBROUTINE ADDS AN ENTRY TO THE TABLE.  IF THE TABLE HAS   *
*  NOT YET BEEN CREATED, IT ALSO ISSUES THE TBCREATE TO CREATE       *
*  THE DIALOG TABLE.                                                 *
*    INPUT: R14 - RETURN ADDRESS                                     *
*                                                                    *
**********************************************************************
         SPACE
         USING ADDTBL,BASE
         SPACE
ADDTBL   DS@ENTR ,
         TM    FLAGBYTE,TBINIT        Q.HAS TABLE BEEN CREATED?
         BO    ADDIT                  Y.THEN NO NEED TO CREATE NOW
         DO    INITTBL                ELSE GO CREATE THE TABLE
ADDIT    DS    0H
         L     R2,CURTBLNM
         CALL  ISPLINK,(=CL8'TBADD',(R2)),VL,MF=(E,CALLPL)
         L     R1,NUMMEM              GET NUMBER IN TABLE
         LA    R1,1(,R1)              INCREMENT THIS COUNT
         ST    R1,NUMMEM              NOW PUT IT BACK
         DS@EXIT ,
         SPACE
         DROP  BASE
         TITLE 'CONCAT SUBROUTINE'
**********************************************************************
*              C O N C A T        S U B R O U T I N E                *
*                                                                    *
*    THIS SUBROUTINE DOES A DYNAMIC CONCATENATION OF OUR DATA SETS   *
*  IF THERE IS MORE THAN ONE DATA SET, AND WE ARE RUNNING VERSION    *
*  2 OF ISPF.  THIS DDNAME IS THEN USED IN THE LMINIT SERVICE TO     *
*  OBTAIN A DATAID, WHICH IS USED IN SUBSEQUENT EDIT AND BROWSE      *
*  SERVICE INVOCATIONS.  THE LMINIT RETURN CODE IS RETURNED IN       *
*  REGISTER 15 (IF NON-ZERO, LMINIT FAILED, SO DON'T DO THE EDIT OR  *
*  BROWSE).  THE CONCATENATED DDNAME IS ALSO OPENED FOR INPUT.       *
*                                                                    *
**********************************************************************
         SPACE
         USING CONCAT,BASE
         SPACE
CONCAT   DS    0H
         CLI   DATAID,C' '            IF ALREADY BEEN HERE, THEN
         BNER  R14                      GET OUT OF HERE
         DS@ENTR ,
         CLC   NUMDS,=H'1'            IF ONLY ONE DS, THEN
         BH    CONCAT01
         L     R11,DSTABL@              SET BASE
         LA    R2,DDNAME1               GET DDNAME
         B     CONCAT05                 GO GET A DATAID
CONCAT01 DS    0H
         MVC   REQBLK(REQBLKML),REQBLKM MOVE IN REQBLK MASK (SVC 99)
         MVC   CTUDDNAM(CTUDDNML),CTUDDNMM MOVE IN TEXT UNIT MASK
         LA    R1,CTUPTR                ADDRESS TEXT UNIT PTR
         ST    R1,RBTXTPP               SAVE IN REQUEST BLOCK
         LA    R1,CTUDDNAM              ADDRESS TEXT UNIT
         ST    R1,CTUPTR                SAVE IN TU POINTER
         MVI   CTUPTR,X'80'             SET VL INDICATOR
         LA    R1,REQBLK                ADDRESS REQUEST BLOCK
         ST    R1,SVC99RB               SAVE IN SVC 99 PAR MLIST
         MVI   SVC99RB,X'80'            SET VL INDICATOR
         LH    R2,NUMDS                 GET NUMBER OF DATASETS
         STH   R2,CTUDDNAM+2            PUT IN NUMBER OF DATASETS
         LA    R3,DSPTRS                ADDRESS TABLE POINTERS
         LA    R5,CTUDDNAM+6            ADDRESS 1ST DDNAME IN TU
CONCATLP DS    0H                       DO I = 1 TO NUMDS;
         L     R11,0(R3)                  ADDRESS DSTBL ELEMENT
         MVC   0(8,R5),DDNAME1            MOVE DDNAME TO TEXT UNIT
         LA    R5,10(,R5)                 NEXT DDNAME IN TU
         LA    R3,4(,R3)                  NEXT DS PTR
         BCT   R2,CONCATLP             END /* LOOP */
         LA    R1,SVC99RB              ADDRESS REQUEST BLOCK
         SVC   99                      DO THE DYNAMIC CONCATENATION
         LTR   R15,R15                 IF IT FAILED, THEN
         BNZ   CONCATX                   WE'RE DONE
         LA    R2,CTUDDNAM+6           ADDRESS DDNAME FOR CONCAT
CONCAT05 DS    0H
         XC    CALLPL(CALLPLL),CALLPL  ELSE CLEAR PARM LIST
         CALL  ISPLINK,(=CL8'LMINIT',=CL8'DATAID',,,,,,,,(R2)),VL,     +
               MF=(E,CALLPL)
         ST    R15,EDBRRC              SAVE RC (TEMPORARY)
         LTR   R15,R15                 IF RETURN CODE ^= 0, THEN
         BZ    CONCAT10
         LA    R1,MSG34                  SET MESSAGE NUMBER
         DO    PUTMSG                    SET A MESSAGE
         L     R15,EDBRRC                RESTORE RC
         B     CONCATX                   AND LEAVE
CONCAT10 DS    0H                      ELSE
         MVI   SPBFUNC,SPBFOPEN          SPAM FUNCTION CODE IS OPEN
         MVI   SPBOPT1,SPBODFLT          ACCESS METHOD IS BPAM
         MVC   SPBDDNAM,0(R2)            MOVE IN DDNAME
         MVI   SPBOPT2,SPBOIN            OPEN THIS FOR INPUT ONLY
         CALL  SPAM,(SPB),VL,MF=(E,SPAMPL)
         MVC   INPSFB,SPBSFB             SAVE THIS FILE BLOCK POINTER
CONCATX  DS    0H
         DS@EXIT RET=R15
         SPACE
REQBLKM  DC    AL1(20),AL1(3),AL2(0),AL2(0),XL2'0',XL2'0',A(0),F'0'
         DC    F'0'
REQBLKML EQU   *-REQBLKM
         SPACE
CTUDDNMM DC    AL2(1),AL2(0),AL2(8),CL8' ',AL2(8),CL8' ',AL2(8),CL8' '
         DC    AL2(8),CL8' '
CTUDDNML EQU   *-CTUDDNMM
         SPACE
         DROP  BASE
         TITLE 'DECONCAT SUBROUTINE'
**********************************************************************
*             D E C O N C A T     S U B R O U T I N E                *
*                                                                    *
*    THIS SUBROUTINE DOES A DYNAMIC DECONCATENATION AND AN LMFREE    *
*  IF THIS LMINIT WAS DONE                                           *
*                                                                    *
**********************************************************************
         SPACE
         USING DECONCAT,BASE
         SPACE
DECONCAT DS    0H
         CLI   DATAID,C' '            IF LMINIT NOT DONE, THEN
         BER   R14                      WE'RE DONE NOW
         DS@ENTR ,                    ELSE READY TO CLOSE
         MVI   SPBFUNC,SPBFCLOS         SET FUNCTION CODE
         L     R1,INPSFB                GET INPUT SFB
         ST    R1,SPBSFB                SAVE IN PARM BLOCK
         CALL  SPAM,(SPB),VL,MF=(E,SPAMPL) DO THE CLOSE
         LA    R2,CTUDDNAM+6            ADDRESS DDNAME OF CONCAT
         CALL  ISPLINK,(=CL8'LMFREE',(R2)),VL,MF=(E,CALLPL) LMFREE
         MVC   DATAID,BLANKS            BLANK DATAID
         CLC   NUMDS,=H'1'              IF MORE THEN ONE DS, THEN
         BNH   DECONCTX
         MVI   RBVERB,4                   SET SVC 99 VERB
         MVC   CTUDDNAM+2,=H'1'           SET # IN TU TO 1
         LA    R1,SVC99RB                 ADDRESS PARM LIST
         SVC   99                         DO THE DECONCATENATION
DECONCTX DS    0H
         DS@EXIT ,
         SPACE
         DROP  BASE
         TITLE 'INITIALIZE ISPF TABLE SUBROUTINE'
**********************************************************************
*              I N I T T B L      S U B R O U T I N E                *
*                                                                    *
*    THIS SUBROUTINE IS INVOKED TO DO A TBCREATE.  THE DEFVARS       *
*  MAY BE INVOKED IF TABLE VARIABLES HAVE NOT YET DEFINED.           *
*                                                                    *
**********************************************************************
         SPACE
         USING INITTBL,BASE
         SPACE
INITTBL  DS@ENTR ,
         TM    VARDFFLG,TBVARDF       IF VARIABLES NOT DEFINED, THEN
         BO    INITTB07
         L     R1,=A(VTBL4)             ADDRESS VARIABLE TABLE
         LA    R2,VTBL4#                GET NUMBER IN TABLE
         TM    FLAGBYT3,LOADLIB         IF LOAD LIBRARIES, THEN
         BZ    INITTB05
         L     R1,=A(VTBL5)               ADDRESS VARIABLE TABLE
         LA    R2,VTBL5#                  GET NUMBER IN TABLE
INITTB05 DS    0H
         STM   R1,R2,VARTBLA            SAVE IN PARM BLOCK
         DO    DEFVARS                  GO VDEFINE THEM
INITTB07 DS    0H
         DO    GTTBLNM                GO GET A TABLE NAME
         L     R1,DS@LVL              GET LEVEL
         LA    R1,1(,R1)              INCREMENT IT
         ST    R1,DS@LVL              SAVE IT BACK
         L     R2,CURTBLNM
         XC    CALLPL(CALLPLL),CALLPL CLEAR CALL PARM LIST
         LA    R3,TBLVARS
         TM    FLAGBYT3,LOADLIB       IF LOAD LIBRARIES, THEN
         BZ    *+8
         LA    R3,TBLVARSL              USE OTHER TABLE VARIABLES
         CALL  ISPLINK,(=CL8'TBCREATE',(R2),,(R3),=CL8'NOWRITE'),      +
               VL,MF=(E,CALLPL)
         OI    FLAGBYTE,TBINIT        INDICATE THAT WE HAVE BEEN HERE
INITBRET DS@EXIT ,
         SPACE 2
TBLVARS  DC   C'(TBSEL,TBMEM,TBSTAT,TBVERMOD,TBCRTED,TBLMDT,TBLMTM,TBSI+
               ZE,TBUSERID,TBLIB#,TBISIZE,TBMOD,TBTTR,TBTTRX,TBLMDTJ)'
         SPACE 2
TBLVARSL DC   C'(TBSEL,TBMEM,TBSTAT,TBTTR,TBSIZEK,TBALIAS,TBATTR,TBSSI,+
               TBLIB#,TBMODE TBEPA,TBEPAX,TBTTRX)'
         SPACE
         DROP  BASE
         TITLE 'GTTBLNM SUBROUTINE'
**********************************************************************
*             G T T B L N M       S U B R O U T I N E                *
*                                                                    *
*    THIS SUBROUTINE CREATES A NEW TABLE NAME, AND PLACES IT AT THE  *
* TOP OF THE STACK.                                                  *
*                                                                    *
**********************************************************************
         SPACE
         USING GTTBLNM,BASE
         SPACE
GTTBLNM  DS@ENTR ,
         L     R1,NUMTBLNM            GET NUMBER OF TABLE NAME
         C     R1,=AL4(MAXTBLNM)      IF AT MAX, THEN
         BNH   *+4+2
         DC    H'0'                     DIE 0C1
         L     R2,CURTBLNM              ELSE ADDRESS CURRENT NAME
         LA    R2,TABLEL(,R2)             GET NEW SLOT FOR NAME
         LTR   R1,R1                      IF FIRST TABLE, THEN
         BNZ   GTTBLN05
         LA    R2,TBLNAMES                  USE FIRST SLOT
GTTBLN05 DS    0H
         LA    R1,1(,R1)                INCREMENT TABLE COUNT
         ST    R1,NUMTBLNM              SAVE IT
         ST    R2,CURTBLNM              SAVE TABLE NAME ADDRESS
         MVC   TBLNAME,=CL8'DS@S'       BUILD TABLE NAME
         TIME  DEC                      GET CURRENT TIME
         ST    R0,TBLNAME+4             MAKE IT PART OF TBL NAME
         DS@EXIT ,
         SPACE
         DROP  BASE
         TITLE 'DETERMINE LENGTH OF MEMBER NAME PASSED SUBROUTINE'
**********************************************************************
*               M E M L N G       S U B R O U T I N E                *
*                                                                    *
*    THIS SUBROUTINE DETERMINES IF A GENERIC MEMBER NAME WAS PASSED, *
*  AND IF SO, THE LENGTH OF THE STRING (LESS ENDING ASTERISK) FOR    *
*  A LATER CLC.  IF MEMBER NAME IS BLANK, OR IS A SINGLE ASTERISK,   *
*  THEN ALLMEM FLAG IS SET IN FLAGBYTE.  IF MEMBER NAME IS NONBLANK, *
*  THEN WE'RE LOOKING FOR A SPECIFIC ENTRY, AND THE LENGTH IS SET    *
*  TO 7 (THE LENGTH RETURNED IS ALWAYS ONE LESS THAN THE ACTUAL      *
*  LENGTH--THIS IS FOR THE EX INSTRUCTION).                          *
*    INPUT: MEMBER - MEMBER NAME GOTTEN FROM ISPF                    *
*    OUTPUT:  LNGMEM SET TO LENGTH - 1, OR ALLMEM FLAG SET           *
*                                                                    *
**********************************************************************
         SPACE
         USING MEMLNG,BASE
         SPACE
MEMLNG   DS@ENTR ,
         NI    FLAGBYTE,255-(ALLMEM+GENERIC) TURN THESE OFF
         NI    FLAGBYT3,255-SINGMEM
         NI    FLAGBYT4,255-GDGMEMBR
         CLC   MEMBER,BLANKS          Q.WAS MEMBER NAME PASSED
         BNE   MEMCONT1               Y.THEN CONTINUE
         OI    FLAGBYTE,ALLMEM        ELSE ALL MEMBERS WANTED, SO SET
         B     MEMRET                   FLAG AND RETURN
MEMCONT1 DS    0H
         LA    R6,MEMBER              ADDRESS MEMBER NAME PASSED
         LA    R7,L'MEMBER-1(R6)      GET END OF THIS STRING
MEMLLP   DS    0H
         CLI   0(R7),C'*'             LOOP UNTIL ASTERISK OR NONBLANK
         BE    MSETLNG                   FOUND
         CLI   0(R7),C' '
         BE    MNXTBYTE
         LA    R7,8                   IF HERE, NON GENERIC NAME PASSED,
         OI    FLAGBYT3,SINGMEM         SAY SINGLE MEMBER NAME (KEY)
         B     MEMCONT2                 SO LENGTH IS 7, AND RETURN
MNXTBYTE DS    0H
         BCTR  R7,0                   IF HERE, LOOK AT NEXT BYTE
         B     MEMLLP                 AND LOOP
         SPACE
MSETLNG  DS    0H
         OI    FLAGBYTE,GENERIC       ASSUME GENERIC MEMBER NAME
         SR    R7,R6                  CALCULATE LENGTH
         LTR   R7,R7                  IF ZERO (SINGLE *), THEN
         BP    MEMCONT2
         OI    FLAGBYTE,ALLMEM          INDICATE ALL MEMBERS
         NI    FLAGBYTE,255-GENERIC       NOT GENERIC
         B     MEMRET                   AND LEAVE
MEMCONT2 DS    0H
         BCTR  R7,0                   GIVE PROPER LENGTH FOR EX INSTR.
         STH   R7,LNGMEM              STORE THIS LENGTH AWAY
         CLI   MEMBER,C'0'            IF 1ST CHARACTER ZERO,
         BE    MEMGDG                     MUST BE INVALID
         CLI   MEMBER,C'+'
         BE    MEMGDG
         CLI   MEMBER,C'-'
         BNE   MEMRET
MEMGDG   DS    0H
         OI    FLAGBYT4,GDGMEMBR      IF HERE, SAY GDG
MEMRET   DS    0H
         DS@EXIT ,
         SPACE
         DROP  BASE
         TITLE 'DETERMINE LENGTH OF USERID PASSED SUBROUTINE'
**********************************************************************
*               U I D L N G       S U B R O U T I N E                *
*                                                                    *
*    THIS SUBROUTINE DETERMINES IF A GENERIC USERID WAS PASSED, AND  *
*  IF SO, THE LENGTH OF THE STRING (LESS ENDING ASTERISK) FOR        *
*  A LATER CLC.  THE USERID IS ALWAYS GIVEN--THE USER OPTION IS      *
*  SET TO 'Y' IF USERIDS ARE TO BE CONSIDERED FOR SELECTION CRI      *
*  TERIA.  THE THE USERID IS A SINGLE ASTERISK, THEN USEROP IS SET   *
*  BACK TO 'N'.  IF THE USERID DOES NOT END IN AN ASTERISK, THEN     *
*  WE ARE LOOKING FOR A SPECIFIC USERID, AND LNGUID IS SET TO 7.     *
*    INPUT: USERID - USERID GOTTEN FROM ISPF                         *
*    OUTPUT:  LNGUID SET TO LENGTH - 1, OR ALLUID FLAG SET           *
*                                                                    *
**********************************************************************
         SPACE
         USING UIDLNG,BASE
         SPACE
UIDLNG   DS@ENTR ,
         CLI   USEROP,C'N'            IF NO USERID TO CONSIDER, THEN
         BE    UIDLNGRT                 WE ARE DONE
         LA    R6,USERID              ADDRESS USERID PASSED
         LA    R7,L'USERID-1(R6)      GET END OF THIS STRING
UIDLLP   DS    0H
         CLI   0(R7),C'*'             LOOP UNTIL ASTERISK OR NONBLANK
         BE    UIDLNGST                  FOUND
         CLI   0(R7),C' '
         BE    UNXTBYTE
         MVC   LNGUID,=H'7'           IF HERE, NON-GENERIC USER PASSED,
         B     UIDLNGRT                 SO LENGTH IS 7, AND RETURN
UNXTBYTE DS    0H
         BCTR  R7,0                   IF HERE, LOOK AT NEXT BYTE
         B     UIDLLP                 AND LOOP
         SPACE
UIDLNGST DS    0H
         SR    R7,R6                  IF HERE, LENGTH TO BE CALCULATED
         LTR   R7,R7                  IS LENGTH ZERO (SINGLE * THERE)
         BP    UIDCONT2               N.THEN SKIP
         MVI   USEROP,C'N'            ELSE INDICATE NONE TO CONSIDER
         B     UIDLNGRT               AND RETURN
UIDCONT2 DS    0H
         BCTR  R7,0                   GIVE PROPER LENGTH FOR EX INSTR.
         STH   R7,LNGUID              STORE THIS LENGTH AWAY
UIDLNGRT DS@EXIT ,
         SPACE
         DROP  BASE
         TITLE 'DEFINE ISPF DIALOG VARIABLES SUBROUTINE'
**********************************************************************
*              D E F V A R S       S U B R O U T I N E               *
*                                                                    *
*    THIS SUBROUTINE CYCLES THROUGHT THE NECESSARY TABLES IN ORDER   *
*  TO EFFICIENTLY ISSUE VDEFINE CALLS WITH A COPY OPTION.  INPUT TO  *
*  THIS ROUTINE IS VARTBLA, WHICH CONTAINS AN ADDRESS TO THE VARI-   *
*  ABLE TABLE ELEMENT TO BEGIN WITH, AND THE NUMBER OF ELEMENTS IN   *
*  THE TABLE TO VDEFINE.                                             *
*                                                                    *
**********************************************************************
         SPACE
         USING DEFVARS,BASE
         SPACE
DEFVARS  DS@ENTR ,
         LM    R8,R9,VARTBLA
         USING VARSTBL,R8
         LA    R2,=CL8'COPY'          SAY COPY
DVLOOP   DS    0H
         LA    R5,VARBASE ADDRESS VARIABLE BASE
         AH    R5,VVOFF               CALCULATE OUR VARIABLE ADDRESS
         LA    R6,VNAME               ADDRESS VARIABLE NAME
         LA    R3,LNGBASE             ADDRESS LENGTH BASE
         SLR   R4,R4                  CLEAR FOR IC
         IC    R4,VLNG                GET LENGTH OF VARIABLE
         LH    R1,VLOFF               GET LENGTH OFFSET
         LTR   R1,R1                  IF LENGTH OFFSET = 0, THEN
         BNZ   DV010                    WE DON'T NEED A LENGTH
         ST    R4,LNGBASE               SO USE LNGBASE FOR LENGTH
         B     DV020
DV010    DS    0H                     ELSE
         AR    R3,R1                    CALCULATE OFFSET
         ST    R4,0(R3)                 SAVE LENGTH
DV020    DS    0H
         LA    R7,=CL8'CHAR'            ASSUME CHARACTER
         TM    VFLAG,CHAR               IF NOT CHARACTER, THEN
         BO    DV030
         LA    R7,=CL8'FIXED'             TRY FIXED
         TM    VFLAG,FIXED                IF NOT FIXED, THEN
         BO    DV030
         LA    R7,=CL8'BIT'                 TRY BIT
         TM    VFLAG,BIT                    IF NOT BIT, THEN
         BO    DV030
         LA    R7,=CL8'HEX'                   TRY HEX
         TM    VFLAG,HEX                      IF NOT HEX, THEN
         BO    DV030
         DC    H'0'                             DIE 0C1
DV030    DS    0H
         TM    VFLAG,NOCOPY           IF COPY, THEN
         BO    DV040
         CALL  ISPLINK,(=CL8'VDEFINE',(R6),(R5),(R7),(R3),(R2)),VL,    +
               MF=(E,CALLPL)            ISSUE THE VDEFINE WITH COPY
         B     DV050
DV040    DS    0H
         CALL  ISPLINK,(=CL8'VDEFINE',(R6),(R5),(R7),(R3)),VL,         +
               MF=(E,CALLPL)            ISSUE THE VDEFINE (NOCOPY)
DV050    DS    0H
         LA    R8,VARSTBLL(,R8)       NEXT TABLE ENTRY
         BCT   R9,DVLOOP              AND LOOP
DVEXIT   DS    0H
         DS@EXIT ,
         SPACE
         DROP  BASE
         TITLE 'GET DIALOG VARIABLE LENGTHS SUBROUTINE'
**********************************************************************
*              G E T L N G         S U B R O U T I N E               *
*                                                                    *
*    THIS SUBROUTINE DETERMINES THE LENGTHS OF VARIOUS DIALOG VARI-  *
*  ABLES.  INPUT TO THIS ROUTINE IS VARTBLA, WHICH CONTAINS AN AD-   *
*  DRESS TO THE VARIABLE TABLE ELEMENT TO BEGIN WITH, AND THE NUM-   *
*  BER OF TABLE ELEMENTS TO DETERMINE THE LENGTH FOR.                *
*                                                                    *
**********************************************************************
         SPACE
         USING GETLNG,BASE
         SPACE
GETLNG   DS@ENTR ,
         LM    R8,R9,VARTBLA          GET INPUT PARMS
         L     R10,TRTBL@             ADDRESS TRANSLATE
         XC    0(256,R10),0(R10)      CLEAR TRANSLATE TABLE
         MVI   C' '(R10),C' '         SET UP TRANSLATE TABLE
GLLOOP   DS    0H
         LH    R1,VLOFF               GET LENGTH OFFSET
         LTR   R1,R1                  IF THERE IS A LENGTH TO GET,
         BZ    GL050
         LA    R3,VARBASE               ADDRESS VARIABLE BASE
         AH    R3,VVOFF                 CALCULATE VARIABLE ADDRESS
         LA    R4,LNGBASE               ADDRESS LENGTH BASE
         AR    R4,R1                    CALCULATE LENGTH ADDRESS
         SLR   R5,R5                    CLEAR FOR IC
         IC    R5,VLNG                  GET LENGTH OF VARIABLE
         TM    VFLAG,EMBED              IF NO EMBEDDED BLANKS, THEN
         BO    GL030
         BCTR  R5,0                       GET EXECUTE LENGTH
         EX    R5,GLTRT                   FIND A BLANK
         BNZ   GL020                      IF NOT FOUND, THEN
         LA    R5,1(,R5)                    WE HAVE LENGTH IN R5
         ST    R5,0(R4)                     SO SAVE IT
         B     GL050
GL020    DS    0H ELSE
         SR    R1,R3                        CALCULATE LENGTH
         ST    R1,0(R4)                     SAVE IT
         B     GL050
GL030    DS    0H                       ELSE /* MAY HAVE EMBEDDED */
         AR    R5,R3                      GET TO END
         BCTR  R5,0                           OF FIELD
GL040    DS    0H                         SEARCH BACK FOR NON-BLANK
         CR    R5,R3                      IF BEGINNING, THEN
         BE    GL045                        WE'RE DONE
         CLI   0(R5),C' '                 IF NOT A BLANK, THEN
         BNE   GL045                        WE'RE DONE
         BCT   R5,GL040                   ELSE LOOP
GL045    DS    0H
         SR    R5,R3                      CALCULATE LENGTH
         LA    R5,1(,R5)
         ST    R5,0(R4)                   SAVE LENGTH
GL050    DS    0H
         LA    R8,VARSTBLL(,R8)        NEXT TABLE ELEMENT
         BCT   R9,GLLOOP               AND LOOP
GETLNGX  DS    0H
         DS@EXIT ,
         SPACE
GLTRT    TRT   0(0,R3),0(R10)          EX SKELETON
         SPACE
         DROP  BASE,R8
         TITLE 'ASSIGN SAVE AREA FOR SUBROUTINE'
**********************************************************************
*              G E T S V A         S U B R O U T I N E               *
*                                                                    *
*    THIS SUBROUTINE ASSIGNS THE NEXT SAVE AREA IN THE STACK FOR THE *
*  CALLING SUBROUTINE.  THE ADDRESS OF THE 64-BYTE SAVEAREA IS RE-   *
*  TURNED IN REGISTER 1.                                             *
*    THIS ROUTINE IS COUPLED CLOSELY WITH THE DS@ENTR MACRO, AND     *
*  SHOULD ONLY BE USED IN THIS ENVIRONMENT.                          *
*                                                                    *
**********************************************************************
         SPACE
         USING GETSVA,R15
         SPACE
GETSVA   DS    0H
         L     R1,SAVADDR             GET CURRENT ADDRESS
         LTR   R1,R1                  IF THIS IS FIRST TIME
         BNZ   GETSVA1
         LA    R1,SAVSTCK               SET ADDRESS OF SAVE AREAS
         ST    R1,SAVADDR
         B     GETSVA2
GETSVA1  DS    0H                     ELSE
         LA    R1,SAVALNG(,R1)          CALCULATE NEXT SAVE AREA
         ST    R1,SAVADDR               AND SAVE IT
GETSVA2  DS    0H
         L     R0,NUMSVA              GET NUMBER OF SAVE AREAS
         AH    R0,=H'1'               INCREMENT IT
         ST    R0,NUMSVA              SAVE AWAY
         CH    R0,=AL2(SAVMAX)        IF WE HAVE EXCEEDED MAXIMUM
         BNH   *+4+2                      NESTING LEVEL
         DC    H'0'                     DIE 0C1
         BR    R14                    ELSE RETURN TO CALLER
         SPACE
         LTORG
         SPACE
         DROP  R15
         TITLE 'RETURN SAVE AREA ADDRESS, REMOVE FROM STACK'
**********************************************************************
*              F R E E S V A       S U B R O U T I N E               *
*                                                                    *
*    THIS SUBROUTINE RETURNS THE ADDRESS OF THE CURRENT SAVEAREA,    *
*  AND REMOVES IT FROM THE STACK.                                    *
*    THIS ROUTINE IS COUPLED CLOSELY WITH THE DS@ENTR MACRO, AND     *
*  SHOULD ONLY BE USED IN THIS ENVIRONMENT.                          *
*                                                                    *
**********************************************************************
         SPACE
         USING FREESVA,R15
         SPACE
FREESVA  DS    0H
         L     R1,NUMSVA              GET NUMBER ON STACK
         LTR   R1,R1                  IF ZERO, THEN
         BNZ   *+4+2
         DC    H'0'                     DIE 0C1
         BCTR  R1,0                   ELSE DECREMENT IT
         ST    R1,NUMSVA                SAVE FOR NEXT TIME
         L     R0,SAVADDR               GET CURRENT SAVE AREA ADDRESS
         LR    R1,R0                    COPY IT
         SH    R0,=AL2(SAVALNG)         CALCULATE PREVIOUS SAVEAREA
         ST    R0,SAVADDR               SAVE FOR NEXT TIME
         BR    R14                      RETURN TO CALLER
         SPACE
         LTORG
         SPACE
         DROP  R15
         TITLE 'DS@SCPDS - SET ISPF MESSAGE SUBROUTINE'
**********************************************************************
*              P U T M S G         S U B R O U T I N E               *
*                                                                    *
*    THIS SETS UP THE MESSAGE PARAMETER BLOCK AND CALLS THE MESSAGE  *
*  PROGRAM TO SET AN ISPF MESSAGE.  INPUT TO THIS ROUTINE IS R1,     *
*  WHICH CONTAINS THE ID OF THE MESSAGE.                             *
*                                                                    *
**********************************************************************
         SPACE
         USING PUTMSG,BASE
         SPACE
PUTMSG   DS@ENTR ,
         C     R1,=AL4(MAXMSG)        IF MESSAGE GREATER THAN MAX,
         BNH   *+6
         DC    H'0'                     DIE 0C1
         ST    R1,MSGID               SAVE MESSAGE IN PARM BLOCK
         LA    R2,1                   ASSUME MEMBER LIST MODE
         CLI   MODE,C'M'              IF NOT MEMBER LIST MODE,
         BE    PUTMSG01
         LA    R2,2                     ASSUME BROWSE MODE
         CLI   MODE,C'B'                IF NOT BROWSE MODE, THEN
         BE    PUTMSG01
         LA    R2,3                       MUST BE EDIT MODE
PUTMSG01 DS    0H
         ST    R2,MSGTB               SET TABLE ID
         LA    R2,DS@MSGPB            ADDRESS MESSAGE PARM BLOCK
         CALL  DS@SCMSG,((R2)),VL,MF=(E,CALLPL)
         LA    R15,4                  RETURN A NON-ZERO RC
         DS@EXIT RET=R15
         SPACE
         DROP  BASE
         TITLE 'DS@SCPDS - ISSUE A TBTOP'
**********************************************************************
*              T B T O P           S U B R O U T I N E               *
*                                                                    *
*    THIS SUBROUTINE MERELY ISSUES A TBTOP COMMAND FOR OUT TABLE.    *
*                                                                    *
**********************************************************************
         SPACE
         USING TBTOP,BASE
         SPACE
TBTOP    DS@ENTR ,
         L     R2,CURTBLNM
         CALL  ISPLINK,(=CL8'TBTOP',(R2)),VL,MF=(E,CALLPL)
         DS@EXIT RET=R15
         SPACE
         DROP  BASE
         TITLE 'DS@SCPDS - SCANTIME ROUTINE'
**********************************************************************
*           S C A N T I M E        S U B R O U T I N E               *
*                                                                    *
*    THIS SUBROUTINE SETS UP THE TIMER VALUES FOR SHOWING THE        *
*  STATISTICS WHEN DOING A SCAN.                                     *
*                                                                    *
**********************************************************************
         SPACE
         USING SCANTIME,BASE
         SPACE
SCANTIME DS@ENTR ,
         LA    R2,=AL4(60*60*100)       MAX VALUE IS ONE HOUR
         STIMER TASK,BINTVL=(R2)        SET MAX FOR TIMER
         TTIMER ,                       GET WHAT IS LEFT
         ST    R0,STTIME                SAVE IT
         TIME  BIN                      GET CURRENT TOD
         LR    R1,R0                    COPY TO R1
         SLR   R0,R0                    CLEAR R0 FOR DIVIDE
         D     R0,=F'100'               CONVERT TIME TO SECONDS
         ST    R1,TOD                   SAVE FOR LATER
         L     R2,TIMEVAL               SAVE TIMEVAL
         MVC   TIMEVAL,=F'5'            SET FIRST DELAY TO 5
         DO    TIMESET                  GO SET THE TIME
         ST    R2,TIMEVAL               RESET TIMEVAL
         DS@EXIT ,
         SPACE
         DROP  BASE
         TITLE 'BLANK AN AREA'
**********************************************************************
*              B L A N K I T       S U B R O U T I N E               *
*                                                                    *
*    THIS SUBROUTINE SIMPLY BLANKS A SPECIFIED AREA.  INPUT TO THE   *
* ROUTINE IS R1, WHICH CONTAINS THE ADDRESS OF THE AREA TO BLANK,    *
* R2, WHICH CONTAINS THE LENGTH OF THE AREA (MAY BE MORE THAN 256    *
* BYTES OF COURSE).  THE FIELD "BLANKS" IN THE DSA IS A FIELD OF     *
* 256 BYTES OF C' ' AND MUST BE INITIALIZED TO THIS BEFORE CALLING   *
* THIS ROUTINE.                                                      *
*                                                                    *
**********************************************************************
         SPACE
         USING BLANKIT,BASE
         SPACE
BLANKIT  DS@ENTR ,
         LA    R3,255                 PUT CONSTANT IN REGISTER
BLNKITLP DS    0H
         CH    R2,=H'256'             IF > THAN 256, THEN
         BNH   BLNKLPX
         EX    R3,BLNKMVC               GO AHEAD AND BLANK 256
         LA    R1,1(R3,R1)              AHEAD 256 BYTES
         SR    R2,R3                    LESS 256 IN LENGTH
         BCTR  R2,0
         B     BLNKITLP                 AND LOOP
BLNKLPX  DS    0H
         BCTR  R2,0                   GET LENGTH FOR EX
         EX    R1,BLNKMVC             BLANK IT
BLANKITX DS@EXIT ,
         SPACE
BLNKMVC  MVC   0(0,R1),BLANKS         MVC SKELTON FOR EX INSTRUCTION
         SPACE
         DROP  BASE
         TITLE 'CONVERT TO BINARY SUBROUTINE'
**********************************************************************
*            C O N V B I N            R O U T I N E S                *
*                                                                    *
*    THIS SUBROUTINE TAKES AN EBCDIC NUMBER RIGHT OR LEFT JUSTIFIED  *
*    IN A FIELD WITH BLANKS, AND CONVERTS IT TO ITS BINARY EQUIVA-   *
*    LENT.  IT ASSUMES A VALID NUMBER IS IN THIS FIELD SOMEWHERE.    *
*    THE INPUT REGISTERS ARE USED AND NOT RESTORED.                  *
*    INPUT: R1 - ADDRESSES START OF FIELD TO CONVERT                 *
*           R0 - LENGTH OF FIELD TO CONVERT                          *
*           R14 - RETURN REGISTER                                    *
*    OUTPUT: R1 - THE BINARY EQUIVALENT OF THE NUMBER                *
*                                                                    *
**********************************************************************
         SPACE
         USING CONVBIN,BASE
         SPACE
CONVBIN  DS@ENTR ,                    START OF ROUTINE
         LR    R5,R1                  COPY START OF FIELD
         AR    R5,R0                  SUBTRACT LENGTH
         BCTR  R5,0                   R5 NOW HAS END OF FIELD
CNVLOOP1 DS    0H
         CLI   0(R1),C' '             LOOP REPLACING BLANKS WITH C'0'
         BNE   CNVLOOP2                 UNTIL FIRST NUMBER FOUND
         MVI   0(R1),C'0'
         LA    R1,1(,R1)              NEXT BYTE
         CR    R5,R1                  IF AT END OF FIELD, THAN IT WAS
         BH    CNVLOOP1                 BLANKS TO BEGIN WITH, SO JUST
         SLR   R1,R1                    ZERO OUT R4 AND RETURN
         B     CNVBDONE
CNVLOOP2 DS    0H
         CLI   0(R5),C' '             LOOP FROM BACK UNTIL FIRST NON-
         BNE   CNVBDOIT                 BLANK CHARACTER FOUND
         BCTR  R5,0
         B     CNVLOOP2
CNVBDOIT DS    0H
         SR    R5,R1                  SUBTRACT TO GET LENGTH OF FIELD
         EX    R5,PACKIT              NOW PACK IT
         CVB   R1,CNVWORK             NOW CONVERT IT TO BINARY
CNVBDONE DS@EXIT RET=R1
         SPACE
PACKIT   PACK  CNVWORK(8),0(0,R1)     EX PACK INSTRUCTION
         SPACE
         DROP  BASE
         TITLE 'CONVERSION SUBROUTINES'
**********************************************************************
*            C O N V E R S I O N      R O U T I N E S                *
*                                                                    *
*   CONVMOD - CONVERTS THE VER/MOD FIELD FROM FORMAT X'VVMM' (WHERE  *
*     VV IS BINARY VERSION NUMBER AND MM IS BINARY MOD NUMBER) TO    *
*     FORMAT C'VV.MM', PRINTABLE. (VV AND MM CONVERTED TO DECIMAL)   *
*     INPUT - FIELD VERMOD                                           *
*             R14 - RETURN ADDRESS                                   *
*     OUTPUT - FIELD TBVERMOD                                        *
*                                                                    *
*   CONVTIME - CONVERTS THE TIME FIELD  FROM FORMAT X'HHMM' TO       *
*     FORMAT C'HH:MM', PRINTABLE.                                    *
*     INPUT - FIELD TIME                                             *
*             R14 - RETURN ADDRESS                                   *
*     OUTPUT - FIELD TBLMTM                                          *
*                                                                    *
*   CONVDATE - CALLS THE CONVDATE PROGRAM TO CONVERT A DATE FROM     *
*     JULIAN TO GREGORIAN, THEN FORMATS IT FOR DISPLAY.  CALLER      *
*     SHOULD MOVE JULIAN DATE INTO JULDATE OF PARAMETER BLOCK.       *
*     INPUT - JULDATE SET UP WITH THE JULIAN DATE                    *
*             R9 - ADDRESS OF RECEIVING FIELD                        *
*             R14 - RETURN ADDRESS                                   *
*     OUTPUT - FIELD ADDRESSED BY R9                                 *
*                                                                    *
**********************************************************************
         SPACE
         USING CONVMOD,BASE
         SPACE
CONVMOD  DS@ENTR ,
         SLR   R6,R6                  CLEAR WORK REGISTER
         IC    R6,VERMOD              GET VERSION NUMBER
         CVD   R6,CNVWORK             CONVERT IT TO DECIMAL
         UNPK  TBVERMOD(2),CNVWORK+6(2) NOW PACK FOR PRINTABLE
         IC    R6,VERMOD+1            GET MOD NUMBER
         CVD   R6,CNVWORK             CONVERT IT TO DECIMAL
         UNPK  TBVERMOD+3(2),CNVWORK+6(2) NOW PACK FOR PRINTABLE
         OC    TBVERMOD,=X'00F00000F0'  ENSURE ALL IS PRINTABLE
         MVI   TBVERMOD+2,C'.'        MOVE PERIOD BETWEEN THE TWO
         DS@EXIT ,                    AND RETURN TO CALLER
         SPACE
         DROP  BASE
         SPACE 3
         USING CONVTIME,BASE
         SPACE
CONVTIME DS@ENTR ,
         MVC   TBLMED(6),EDPATTM      MOVE PATTERN TO OUTPUT AREA
         ED    TBLMED(6),TIME         PERFORM THE CONVERSION
         MVI   TBLMTM+2,C':'          ENSURE : FOR HOUR OF 00
         MVC   TBLMTMB,TIME           MOVE BINARY VALUE FOR TIME
         DS@EXIT ,                    AND RETURN TO CALLER
         SPACE
EDPATTM  DC    X'F020207A2020'        EDIT MASK FOR TIME
         SPACE
         DROP  BASE
         SPACE 3
         USING CONVSIZE,BASE
         SPACE
CONVSIZE DS@ENTR ,
         LH    R6,SIZE                GET THE SIZE
         LTR   R6,R6                  IF = 0, THEN
         BNZ   CNVSIZ01
         MVC   0(5,R1),=C'    0'        SET FIELD TO 0
         B     CONVSIZX
CNVSIZ01 DS    0H
         CVD   R6,CNVWORK             CONVERT BINARY TO PACK DECIMAL
         MVC   SIZEWORK(9),EDPATSZ    MOVE EDIT PATTER TO WORK AREA
         ED    SIZEWORK(8),CNVWORK+4  PERFORM THE CONVERSION
         MVC   0(5,R1),SIZEWORK+3     MOVE RESULT TO OUTPUT
CONVSIZX DS@EXIT ,                    AND RETURN TO CALLER
         SPACE
EDPATSZ  DC    X'402020202020202021'  EDIT MASK FOR SIZE
         SPACE
         DROP  BASE
         TITLE 'CONVERSION SUBROUTINES'
**********************************************************************
*               C O N V D A T          R O U T I N E                 *
**********************************************************************
         SPACE
         USING CONVDATE,BASE
         SPACE
CONVDATE DS@ENTR ,
         LA    R2,CNVDATPB            ADDRESS PARAMETER BLOCK
         CALL  DS@CNVDT,((R2)),VL,MF=(E,CALLPL) CALL ROUTINE FOR THIS
         MVC   0(8,R9),GREGDATE       MOVE IN MM FROM RETURNED DATE
         DS@EXIT ,
         SPACE
         DROP  BASE
         TITLE 'STATIC DEFINITIONS'
**********************************************************************
*         D I A L O G     V A R I A B L E     T A B L E              *
**********************************************************************
         SPACE
VTBL1    DC    AL2(DSN1-VARBASE),AL2(DSN1L-LNGBASE)
         DC    AL1(L'DSN1),AL1(CHAR),CL8'DS@DSN1'
         DC    AL2(DSN2-VARBASE),AL2(DSN2L-LNGBASE)
         DC    AL1(L'DSN2),AL1(CHAR),CL8'DS@DSN2'
         DC    AL2(DSN3-VARBASE),AL2(DSN3L-LNGBASE)
         DC    AL1(L'DSN3),AL1(CHAR),CL8'DS@DSN3'
         DC    AL2(DSN4-VARBASE),AL2(DSN4L-LNGBASE)
         DC    AL1(L'DSN4),AL1(CHAR),CL8'DS@DSN4'
         DC    AL2(MEMBER-VARBASE),AL2(MEMBERL-LNGBASE)
         DC    AL1(L'MEMBER),AL1(CHAR),CL8'DS@MEM'
         DC    AL2(VOL1-VARBASE),AL2(VOL1L-LNGBASE)
         DC    AL1(L'VOL1),AL1(CHAR),CL8'DS@VOL'
         DC    AL2(USERID-VARBASE),AL2(USERIDL-LNGBASE)
         DC    AL1(L'USERID),AL1(CHAR),CL8'DS@USER'
         DC    AL2(ZPREFIX-VARBASE),AL2(ZPREFIXL-LNGBASE)
         DC    AL1(L'ZPREFIX),AL1(CHAR),CL8'ZPREFIX'
SCNVARS  DC    AL2(SCANSTR-VARBASE),AL2(SCANSTRL-LNGBASE)
         DC    AL1(L'SCANSTR),AL1(CHAR+EMBED),CL8'DS@SCSTR'
         DC    AL2(STP-VARBASE),AL2(STPL-LNGBASE)
         DC    AL1(L'STP),AL1(CHAR),CL8'DS@STP'
         DC    AL2(SCOL1-VARBASE),AL2(SCOL1L-LNGBASE)
         DC    AL1(L'SCOL1),AL1(CHAR),CL8'DS@SCOL1'
         DC    AL2(SCOL2-VARBASE),AL2(SCOL2L-LNGBASE)
         DC    AL1(L'SCOL2),AL1(CHAR),CL8'DS@SCOL2'
         DC    AL2(SCOP-VARBASE),AL2(0)
         DC    AL1(L'SCOP),AL1(CHAR),CL8'DS@SCOP'
         DC    AL2(CASE-VARBASE),AL2(0)
         DC    AL1(L'CASE),AL1(CHAR),CL8'DS@CASE'
         DC    AL2(WSP-VARBASE),AL2(0)
         DC    AL1(L'WSP),AL1(CHAR),CL8'DS@WSP'
         DC    AL2(DS@LVL-VARBASE),AL2(0)
         DC    AL1(L'DS@LVL),AL1(FIXED),CL8'DS@LVL'
         DC    AL2(MPR-VARBASE),AL2(0)
         DC    AL1(L'MPR),AL1(FIXED+NOCOPY),CL8'MPR'
         DC    AL2(DATAID-VARBASE),AL2(0)
         DC    AL1(L'DATAID),AL1(CHAR+NOCOPY),CL8'DATAID'
SCNVARS# EQU   (*-SCNVARS)/VARSTBLL
         DC    AL2(USEROP-VARBASE),AL2(0)
         DC    AL1(L'USEROP),AL1(CHAR),CL8'DS@UOP'
         DC    AL2(TRACE-VARBASE),AL2(0)
         DC    AL1(L'TRACE),AL1(CHAR),CL8'TRACE'
         DC    AL2(DELAY-VARBASE),AL2(DELAYL-LNGBASE)
         DC    AL1(L'DELAY),AL1(CHAR),CL8'DELAY'
         DC    AL2(MODE-VARBASE),AL2(0)
         DC    AL1(L'MODE),AL1(CHAR),CL8'DS@MODE'
         DC    AL2(MIX-VARBASE),AL2(0)
         DC    AL1(L'MIX),AL1(CHAR),CL8'DS@MIX'
         DC    AL2(FNAM-VARBASE),AL2(0)
         DC    AL1(L'FNAM),AL1(CHAR),CL8'DS@FNAM'
         DC    AL2(MAC-VARBASE),AL2(0)
         DC    AL1(L'MAC),AL1(CHAR),CL8'DS@IMAC'
         DC    AL2(PROF-VARBASE),AL2(0)
         DC    AL1(L'PROF),AL1(CHAR),CL8'DS@PROF'
         DC    AL2(ERRFIELD-VARBASE),AL2(0)
         DC    AL1(L'ERRFIELD),AL1(CHAR),CL8'DS@ERRFD'
         DC    AL2(ZDSN-VARBASE),AL2(0)
         DC    AL1(L'ZDSN),AL1(CHAR+NOCOPY),CL8'ZDSN'
         DC    AL2(ZMEMB-VARBASE),AL2(0)
         DC    AL1(L'ZMEMB),AL1(CHAR+NOCOPY),CL8'ZMEMB'
VTBL1#   EQU   (*-VTBL1)/VARSTBLL
         SPACE
VTBL2    DC    AL2(PRTDSN-VARBASE),AL2(0)
         DC    AL1(L'PRTDSN),AL1(CHAR+NOCOPY),CL8'PRTDSN'
         DC    AL2(CP-VARBASE),AL2(0)
         DC    AL1(L'CP),AL1(FIXED+NOCOPY),CL8'CP'
         DC    AL2(DEST-VARBASE),AL2(0)
         DC    AL1(L'DEST),AL1(CHAR),CL8'DEST'
         DC    AL2(HOLD-VARBASE),AL2(0)
         DC    AL1(L'HOLD),AL1(CHAR),CL8'HOLD'
         DC    AL2(HEAD-VARBASE),AL2(0)
         DC    AL1(L'HEAD),AL1(CHAR),CL8'HEAD'
         DC    AL2(SNUM-VARBASE),AL2(0)
         DC    AL1(L'SNUM),AL1(CHAR),CL8'SNUM'
         DC    AL2(FORM-VARBASE),AL2(0)
         DC    AL1(L'FORM),AL1(CHAR),CL8'FORM'
         DC    AL2(UCS-VARBASE),AL2(0)
         DC    AL1(L'UCS),AL1(CHAR),CL8'UCS'
VTBL2#   EQU   (*-VTBL2)/VARSTBLL
         SPACE
VTBL3    DC    AL2(PROJ2-VARBASE),AL2(PROJ2L-LNGBASE)
         DC    AL1(L'PROJ2),AL1(CHAR),CL8'PROJ2'
         DC    AL2(LIBR2-VARBASE),AL2(LIBR2L-LNGBASE)
         DC    AL1(L'LIBR2),AL1(CHAR),CL8'LIBR2'
         DC    AL2(TYPE2-VARBASE),AL2(TYPE2L-LNGBASE)
         DC    AL1(L'TYPE2),AL1(CHAR),CL8'TYPE2'
         DC    AL2(DSN02-VARBASE),AL2(DSN02L-LNGBASE)
         DC    AL1(L'DSN02),AL1(CHAR),CL8'DSN02'
         DC    AL2(VOL2-VARBASE),AL2(0)
         DC    AL1(L'VOL2),AL1(CHAR),CL8'VOL2'
         DC    AL2(REP-VARBASE),AL2(0)
         DC    AL1(L'REP),AL1(CHAR),CL8'REP'
         DC    AL2(SD-VARBASE),AL2(0)
         DC    AL1(L'SD),AL1(CHAR),CL8'SD'
VTBL3#   EQU   (*-VTBL3)/VARSTBLL     INDICATES END OF TABLE
         SPACE
VTBL4    DC    AL2(TBSEL-VARBASE),AL2(0)
         DC    AL1(L'TBSEL),AL1(CHAR+NOCOPY),CL8'TBSEL'
         DC    AL2(TBMEM-VARBASE),AL2(0)
         DC    AL1(L'TBMEM),AL1(CHAR+NOCOPY),CL8'TBMEM'
         DC    AL2(TBSTAT-VARBASE),AL2(0)
         DC    AL1(L'TBSTAT),AL1(CHAR+NOCOPY),CL8'TBSTAT'
         DC    AL2(TBLIB#-VARBASE),AL2(0)
         DC    AL1(L'TBLIB#),AL1(CHAR+NOCOPY),CL8'TBLIB#'
         DC    AL2(TBTTR-VARBASE),AL2(0)
         DC    AL1(L'TBTTR),AL1(CHAR+NOCOPY),CL8'TBTTR'
         DC    AL2(TBTTRX-VARBASE),AL2(0)
         DC    AL1(L'TBTTRX),AL1(HEX+NOCOPY),CL8'TBTTRX'
         DC    AL2(TBVERMOD-VARBASE),AL2(0)
         DC    AL1(L'TBVERMOD),AL1(CHAR+NOCOPY),CL8'TBVERMOD'
         DC    AL2(TBCRTED-VARBASE),AL2(0)
         DC    AL1(L'TBCRTED),AL1(CHAR+NOCOPY),CL8'TBCRTED'
         DC    AL2(TBLMDT-VARBASE),AL2(0)
         DC    AL1(L'TBLMDT),AL1(CHAR+NOCOPY),CL8'TBLMDT'
         DC    AL2(TBLMDTJ-VARBASE),AL2(0)
         DC    AL1(L'TBLMDTJ+L'TBLMTMB),AL1(CHAR+NOCOPY),CL8'TBLMDTJ'
         DC    AL2(TBLMTM-VARBASE),AL2(0)
         DC    AL1(L'TBLMTM),AL1(CHAR+NOCOPY),CL8'TBLMTM'
         DC    AL2(TBSIZE-VARBASE),AL2(0)
         DC    AL1(L'TBSIZE),AL1(CHAR+NOCOPY),CL8'TBSIZE'
         DC    AL2(TBISIZE-VARBASE),AL2(0)
         DC    AL1(L'TBISIZE),AL1(CHAR+NOCOPY),CL8'TBISIZE'
         DC    AL2(TBMOD-VARBASE),AL2(0)
         DC    AL1(L'TBMOD),AL1(CHAR+NOCOPY),CL8'TBMOD'
         DC    AL2(TBUSERID-VARBASE),AL2(0)
         DC    AL1(L'TBUSERID),AL1(CHAR+NOCOPY),CL8'TBUSERID'
VTBL4#   EQU   (*-VTBL4)/VARSTBLL
         SPACE
VTBL5    DC    AL2(TBSEL-VARBASE),AL2(0)
         DC    AL1(L'TBSEL),AL1(CHAR+NOCOPY),CL8'TBSEL'
         DC    AL2(TBMEM-VARBASE),AL2(0)
         DC    AL1(L'TBMEM),AL1(CHAR+NOCOPY),CL8'TBMEM'
         DC    AL2(TBSTAT-VARBASE),AL2(0)
         DC    AL1(L'TBSTAT),AL1(CHAR+NOCOPY),CL8'TBSTAT'
         DC    AL2(TBLIB#-VARBASE),AL2(0)
         DC    AL1(L'TBLIB#),AL1(CHAR+NOCOPY),CL8'TBLIB#'
         DC    AL2(TBTTR-VARBASE),AL2(0)
         DC    AL1(L'TBTTR),AL1(CHAR+NOCOPY),CL8'TBTTR'
         DC    AL2(TBTTRX-VARBASE),AL2(0)
         DC    AL1(L'TBTTRX),AL1(HEX+NOCOPY),CL8'TBTTRX'
         DC    AL2(TBSIZEK-VARBASE),AL2(0)
         DC    AL1(L'TBSIZEK),AL1(CHAR+NOCOPY),CL8'TBSIZEK'
         DC    AL2(TBALIAS-VARBASE),AL2(0)
         DC    AL1(L'TBALIAS),AL1(CHAR+NOCOPY),CL8'TBALIAS'
         DC    AL2(TBEPAX-VARBASE),AL2(0)
         DC    AL1(L'TBEPAX),AL1(HEX+NOCOPY),CL8'TBEPAX'
         DC    AL2(TBMODE-VARBASE),AL2(0)
         DC    AL1(L'TBMODE),AL1(CHAR+NOCOPY),CL8'TBMODE'
         DC    AL2(TBEPA-VARBASE),AL2(0)
         DC    AL1(L'TBEPA),AL1(CHAR+NOCOPY),CL8'TBEPA'
         DC    AL2(TBATTR-VARBASE),AL2(0)
         DC    AL1(L'TBATTR),AL1(CHAR+NOCOPY),CL8'TBATTR'
         DC    AL2(TBSSI-VARBASE),AL2(0)
         DC    AL1(L'TBSSI),AL1(CHAR+NOCOPY),CL8'TBSSI'
VTBL5#   EQU   (*-VTBL5)/VARSTBLL
         SPACE
VTBL6    DC    AL2(CRP-VARBASE),AL2(0)
         DC    AL1(L'CRP),AL1(FIXED+NOCOPY),CL8'CRP'
         DC    AL2(ZTDTOP-VARBASE),AL2(0)
         DC    AL1(L'ZTDTOP),AL1(FIXED+NOCOPY),CL8'ZTDTOP'
         DC    AL2(CMDLINE-VARBASE),AL2(0)
         DC    AL1(L'CMDLINE),AL1(CHAR+NOCOPY),CL8'CMDLINE'
         DC    AL2(ZTDMARK-VARBASE),AL2(0)
         DC    AL1(L'ZTDMARK),AL1(CHAR+NOCOPY),CL8'ZTDMARK'
         DC    AL2(FINDPARM-VARBASE),AL2(0)
         DC    AL1(L'FINDPARM),AL1(CHAR+NOCOPY),CL8'FINDPARM'
         DC    AL2(PARM1-VARBASE),AL2(0)
         DC    AL1(L'PARM1),AL1(CHAR+NOCOPY),CL8'PARM1'
         DC    AL2(SCRHORZ-VARBASE),AL2(0)
         DC    AL1(L'SCRHORZ),AL1(CHAR+NOCOPY),CL8'RFIND'
         DC    AL2(DS@MODE-VARBASE),AL2(0)
         DC    AL1(L'DS@MODE),AL1(CHAR+NOCOPY),CL8'DS@MODE'
VTBL6#   EQU   (*-VTBL6)/VARSTBLL
         SPACE
VTBL7    DC    AL2(LASTMEM-VARBASE),AL2(0)
         DC    AL1(L'LASTMEM),AL1(CHAR+NOCOPY),CL8'LASTMEM'
         DC    AL2(CPUTM-VARBASE),AL2(0)
         DC    AL1(L'CPUTM),AL1(CHAR+NOCOPY),CL8'CPUTM'
         DC    AL2(ELAPTM-VARBASE),AL2(0)
         DC    AL1(L'ELAPTM),AL1(CHAR+NOCOPY),CL8'ELAPTM'
         DC    AL2(MSC-VARBASE),AL2(0)
         DC    AL1(L'MSC),AL1(FIXED+NOCOPY),CL8'MSC'
         DC    AL2(MSE-VARBASE),AL2(0)
         DC    AL1(L'MSE),AL1(FIXED+NOCOPY),CL8'MSE'
VTBL7#   EQU   (*-VTBL7)/VARSTBLL
         SPACE
VTBL8    DC    AL2(INFDSNAM-VARBASE),AL2(0)
         DC    AL1(L'INFDSNAM),AL1(CHAR+NOCOPY),CL8'INFDSNAM'
         DC    AL2(INFDEVTY-VARBASE),AL2(0)
         DC    AL1(L'INFDEVTY),AL1(CHAR+NOCOPY),CL8'INFDEVTY'
         DC    AL2(INFVOLSR-VARBASE),AL2(0)
         DC    AL1(L'INFVOLSR),AL1(CHAR+NOCOPY),CL8'INFVOLSR'
         DC    AL2(INFDSORG-VARBASE),AL2(0)
         DC    AL1(L'INFDSORG),AL1(CHAR+NOCOPY),CL8'INFDSORG'
         DC    AL2(INFRECFM-VARBASE),AL2(0)
         DC    AL1(L'INFRECFM),AL1(CHAR+NOCOPY),CL8'INFRECFM'
         DC    AL2(INFATYP-VARBASE),AL2(0)
         DC    AL1(L'INFATYP),AL1(CHAR+NOCOPY),CL8'INFATYP'
         DC    AL2(INFCRTDT-VARBASE),AL2(0)
         DC    AL1(L'INFCRTDT),AL1(CHAR+NOCOPY),CL8'INFCRTDT'
         DC    AL2(INFEXPDT-VARBASE),AL2(0)
         DC    AL1(L'INFEXPDT),AL1(CHAR+NOCOPY),CL8'INFEXPDT'
         DC    AL2(INFLRECL-VARBASE),AL2(0)
         DC    AL1(L'INFLRECL),AL1(FIXED+NOCOPY),CL8'INFLRECL'
         DC    AL2(INFBLKSZ-VARBASE),AL2(0)
         DC    AL1(L'INFBLKSZ),AL1(FIXED+NOCOPY),CL8'INFBLKSZ'
         DC    AL2(INFPRIM-VARBASE),AL2(0)
         DC    AL1(L'INFPRIM),AL1(FIXED+NOCOPY),CL8'INFPRIM'
         DC    AL2(INFSEC-VARBASE),AL2(0)
         DC    AL1(L'INFSEC),AL1(FIXED+NOCOPY),CL8'INFSEC'
         DC    AL2(INFALLOC-VARBASE),AL2(0)
         DC    AL1(L'INFALLOC),AL1(FIXED+NOCOPY),CL8'INFALLOC'
         DC    AL2(INFALLOE-VARBASE),AL2(0)
         DC    AL1(L'INFALLOE),AL1(FIXED+NOCOPY),CL8'INFALLOE'
         DC    AL2(INFUSEDA-VARBASE),AL2(0)
         DC    AL1(L'INFUSEDA),AL1(FIXED+NOCOPY),CL8'INFUSEDA'
         DC    AL2(INFUSEDE-VARBASE),AL2(0)
         DC    AL1(L'INFUSEDE),AL1(FIXED+NOCOPY),CL8'INFUSEDE'
         DC    AL2(INFMAXDB-VARBASE),AL2(0)
         DC    AL1(L'INFMAXDB),AL1(FIXED+NOCOPY),CL8'INFMAXDB'
         DC    AL2(INFUSEDB-VARBASE),AL2(0)
         DC    AL1(L'INFUSEDB),AL1(FIXED+NOCOPY),CL8'INFUSEDB'
         DC    AL2(INFMEM#-VARBASE),AL2(0)
         DC    AL1(L'INFMEM#),AL1(FIXED+NOCOPY),CL8'INFMEM#'
VTBL8#   EQU   (*-VTBL8)/VARSTBLL
         SPACE
VTBL9    DC    AL2(DIRMEM-VARBASE),AL2(0)
         DC    AL1(L'DIRMEM),AL1(CHAR+NOCOPY),CL8'DIRMEM'
         DC    AL2(DIRLIB-VARBASE),AL2(0)
         DC    AL1(L'DIRLIB),AL1(CHAR+NOCOPY),CL8'DIRLIB'
         DC    AL2(DIRLNG-VARBASE),AL2(0)
         DC    AL1(L'DIRLNG),AL1(CHAR+NOCOPY),CL8'DIRLNG'
         DC    AL2(DIRINFO-VARBASE),AL2(0)
         DC    AL1(L'DIRINFO),AL1(CHAR+NOCOPY),CL8'DIRINFO'
VTBL9#   EQU   (*-VTBL9)/VARSTBLL
         SPACE
         EJECT
**********************************************************************
*              C O M M A N D        T A B L E S                      *
*                                                                    *
*                                                                    *
*   NOTE: KEEP THESE TABLE ALPHABETIZED BY COMMAND!!!!  THE COMMAND  *
* TABLES ARE MAPPED BY THE CMDTBL DSECT.                             *
*                                                                    *
**********************************************************************
         SPACE
CMDTBLM  DS    0F                  COMMAND TABLE FOR MEMBER LIST
         DC    CL8'        ',AL4(NOOPMEM),AL2(0),AL2(0)
         DC    CL8'?       ',AL4(LEVEL),AL2(0),AL2(CMDLONLY)
         DC    CL8'ADD     ',AL4(ADDMEM),AL2(1)
         DC    AL2(NEWMEM+CMDLONLY+MEMNREQ)
         DC    CL8'B       ',AL4(BROWMEM),AL2(1),AL2(GENMEM+MEMNREQ)
         DC    CL8'C       ',AL4(CPYMEM),AL2(1),AL2(GENMEM+MEMNREQ)
         DC    CL8'CAN     ',AL4(CANCEL),AL2(0),AL2(CMDLONLY)
         DC    CL8'CLEAR   ',AL4(CLRTBL),AL2(0),AL2(CMDLONLY)
         DC    CL8'CLOSE   ',AL4(CLOSCPY),AL2(0),AL2(CMDLONLY)
         DC    CL8'COPY    ',AL4(CPYMEM),AL2(2)
         DC    AL2(CMDLONLY+GENMEM+MEMNREQ)
         DC    CL8'DEL     ',AL4(DELMEM),AL2(1),AL2(GENMEM+MEMNREQ)
         DC    CL8'DIR     ',AL4(DIRDUMP),AL2(1)
         DC    AL2(GENMEM+MEMNREQ+OGENPRC)
         DC    CL8'E       ',AL4(EDITMEM),AL2(1)
         DC    AL2(NEWMEM+GENMEM+MEMNREQ)
         DC    CL8'F       ',AL4(FINDID),AL2(1),AL2(CMDLONLY)
         DC    CL8'FIND    ',AL4(FINDID),AL2(1),AL2(CMDLONLY)
         DC    CL8'FREE    ',AL4(FRESYSOU),AL2(0),AL2(CMDLONLY)
         DC    CL8'INFO    ',AL4(DSINFO),AL2(1),AL2(CMDLONLY)
         DC    CL8'IOF     ',AL4(IOF),AL2(0),AL2(CMDLONLY)
         DC    CL8'L       ',AL4(LOCMEM),AL2(1),AL2(NEWMEM+MEMNREQ)
         DC    CL8'LE      ',AL4(LEFT),AL2(1),AL2(CMDLONLY)
         DC    CL8'LEFT    ',AL4(LEFT),AL2(1),AL2(CMDLONLY)
         DC    CL8'M       ',AL4(MOVMEM),AL2(2),AL2(GENMEM+MEMNREQ)
         DC    CL8'MODE    ',AL4(MODECMD),AL2(1),AL2(CMDLONLY)
         DC    CL8'MOVE    ',AL4(MOVMEM),AL2(2)
         DC    AL2(CMDLONLY+GENMEM+MEMNREQ)
         DC    CL8'P       ',AL4(PRMEM),AL2(1),AL2(GENMEM+MEMNREQ)
         DC    CL8'PR      ',AL4(PRMEM),AL2(1),AL2(GENMEM+MEMNREQ)
         DC    CL8'R       ',AL4(RENMEM),AL2(2),AL2(MEMNREQ)
         DC    CL8'RE      ',AL4(RENMEM),AL2(2),AL2(MEMNREQ)
         DC    CL8'REB     ',AL4(REBUILD),AL2(1),AL2(CMDLONLY)
         DC    CL8'REBUILD ',AL4(REBUILD),AL2(1),AL2(CMDLONLY)
         DC    CL8'REN     ',AL4(RENMEM),AL2(2),AL2(MEMNREQ)
         DC    CL8'RF      ',AL4(RFINDID),AL2(0),AL2(CMDLONLY)
         DC    CL8'RFIND   ',AL4(RFINDID),AL2(0),AL2(CMDLONLY)
         DC    CL8'RI      ',AL4(RIGHT),AL2(1),AL2(CMDLONLY)
         DC    CL8'RIGHT   ',AL4(RIGHT),AL2(1),AL2(CMDLONLY)
         DC    CL8'S       ',AL4(BROWMEM),AL2(1),AL2(GENMEM+MEMNREQ)
         DC    CL8'SCAN    ',AL4(SCANCMD),AL2(0),AL2(CMDLONLY)
         DC    CL8'SORT    ',AL4(SORT),AL2(4),AL2(CMDLONLY)
         DC    CL8'ST      ',AL4(STACK),AL2(1),AL2(CMDLONLY)
         DC    CL8'SUB     ',AL4(SUBMEM),AL2(1),AL2(GENMEM+MEMNREQ)
         DC    CL8'SUBMIT  ',AL4(SUBMEM),AL2(1),AL2(GENMEM+MEMNREQ)
         DC    CL8'SW      ',AL4(SWITCH),AL2(1),AL2(CMDLONLY)
         DC    CL8'TOP     ',AL4(TOPTBL),AL2(0),AL2(CMDLONLY)
         DC    CL8'X       ',AL4(EDITMEM),AL2(1)
         DC    AL2(NEWMEM+GENMEM+MEMNREQ)
         DC    CL8'Z       ',AL4(ZAPTBL),AL2(1),AL2(GENMEM+MEMNREQ)
         DC    CL8'ZAP     ',AL4(ZAPTBL),AL2(1),AL2(GENMEM+MEMNREQ)
CMDTBLSZ EQU   ((*-CMDTBLM)/12)
         SPACE 2
CMDTBLE  DS    0F                  COMMAND TABLE (EDIT MODE)
         DC    CL8'        ',AL4(NOOPMEM),AL2(0),AL2(0)
         DC    CL8'?       ',AL4(LEVEL),AL2(0),AL2(CMDLONLY)
         DC    CL8'ADD     ',AL4(ADDMEM),AL2(1)
         DC    AL2(NEWMEM+CMDLONLY+MEMNREQ)
         DC    CL8'CAN     ',AL4(CANCEL),AL2(0),AL2(CMDLONLY)
         DC    CL8'E       ',AL4(EDITMEM),AL2(1)
         DC    AL2(NEWMEM+GENMEM+MEMNREQ)
         DC    CL8'F       ',AL4(FINDID),AL2(1),AL2(CMDLONLY)
         DC    CL8'FIND    ',AL4(FINDID),AL2(1),AL2(CMDLONLY)
         DC    CL8'INFO    ',AL4(DSINFO),AL2(1),AL2(CMDLONLY)
         DC    CL8'IOF     ',AL4(IOF),AL2(0),AL2(CMDLONLY)
         DC    CL8'L       ',AL4(LOCMEM),AL2(1),AL2(MEMNREQ+NEWMEM)
         DC    CL8'LEFT    ',AL4(NOOPMEM),AL2(1),AL2(CMDLONLY)
         DC    CL8'MODE    ',AL4(MODECMD),AL2(1),AL2(CMDLONLY)
         DC    CL8'REB     ',AL4(REBUILD),AL2(1),AL2(CMDLONLY)
         DC    CL8'REBUILD ',AL4(REBUILD),AL2(1),AL2(CMDLONLY)
         DC    CL8'RF      ',AL4(RFINDID),AL2(0),AL2(CMDLONLY)
         DC    CL8'RFIND   ',AL4(RFINDID),AL2(0),AL2(CMDLONLY)
         DC    CL8'RIGHT   ',AL4(NOOPMEM),AL2(1),AL2(CMDLONLY)
         DC    CL8'S       ',AL4(EDITMEM),AL2(1)
         DC    AL2(NEWMEM+GENMEM+MEMNREQ)
         DC    CL8'SCAN    ',AL4(SCANCMD),AL2(0),AL2(CMDLONLY)
         DC    CL8'SORT    ',AL4(SORT),AL2(4),AL2(CMDLONLY)
         DC    CL8'ST      ',AL4(STACK),AL2(1),AL2(CMDLONLY)
         DC    CL8'SW      ',AL4(SWITCH),AL2(1),AL2(CMDLONLY)
         DC    CL8'TOP     ',AL4(TOPTBL),AL2(0),AL2(CMDLONLY)
         DC    CL8'X       ',AL4(EDITMEM),AL2(1)
         DC    AL2(NEWMEM+GENMEM+MEMNREQ)
         DC    CL8'Z       ',AL4(ZAPTBL),AL2(1),AL2(GENMEM+MEMNREQ)
         DC    CL8'ZAP     ',AL4(ZAPTBL),AL2(1),AL2(GENMEM+MEMNREQ)
CMDTBSZE EQU   ((*-CMDTBLE)/12)
         SPACE 2
CMDTBLB  DS    0F                  COMMAND TABLE (BROWSE MODE)
         DC    CL8'        ',AL4(NOOPMEM),AL2(0),AL2(0)
         DC    CL8'?       ',AL4(LEVEL),AL2(0),AL2(CMDLONLY)
         DC    CL8'ADD     ',AL4(ADDMEM),AL2(1)
         DC    AL2(NEWMEM+CMDLONLY+MEMNREQ)
         DC    CL8'CAN     ',AL4(CANCEL),AL2(0),AL2(CMDLONLY)
         DC    CL8'B       ',AL4(BROWMEM),AL2(1),AL2(GENMEM+MEMNREQ)
         DC    CL8'F       ',AL4(FINDID),AL2(1),AL2(CMDLONLY)
         DC    CL8'FIND    ',AL4(FINDID),AL2(1),AL2(CMDLONLY)
         DC    CL8'INFO    ',AL4(DSINFO),AL2(1),AL2(CMDLONLY)
         DC    CL8'IOF     ',AL4(IOF),AL2(0),AL2(CMDLONLY)
         DC    CL8'L       ',AL4(LOCMEM),AL2(1),AL2(MEMNREQ+NEWMEM)
         DC    CL8'LEFT    ',AL4(NOOPMEM),AL2(1),AL2(CMDLONLY)
         DC    CL8'MODE    ',AL4(MODECMD),AL2(1),AL2(CMDLONLY)
         DC    CL8'REB     ',AL4(REBUILD),AL2(1),AL2(CMDLONLY)
         DC    CL8'REBUILD ',AL4(REBUILD),AL2(1),AL2(CMDLONLY)
         DC    CL8'RF      ',AL4(RFINDID),AL2(0),AL2(CMDLONLY)
         DC    CL8'RFIND   ',AL4(RFINDID),AL2(0),AL2(CMDLONLY)
         DC    CL8'RIGHT   ',AL4(NOOPMEM),AL2(1),AL2(CMDLONLY)
         DC    CL8'S       ',AL4(BROWMEM),AL2(1),AL2(GENMEM+MEMNREQ)
         DC    CL8'SCAN    ',AL4(SCANCMD),AL2(0),AL2(CMDLONLY)
         DC    CL8'SORT    ',AL4(SORT),AL2(4),AL2(CMDLONLY)
         DC    CL8'ST      ',AL4(STACK),AL2(1),AL2(CMDLONLY)
         DC    CL8'SW      ',AL4(SWITCH),AL2(1),AL2(CMDLONLY)
         DC    CL8'TOP     ',AL4(TOPTBL),AL2(0),AL2(CMDLONLY)
         DC    CL8'Z       ',AL4(ZAPTBL),AL2(1),AL2(GENMEM+MEMNREQ)
         DC    CL8'ZAP     ',AL4(ZAPTBL),AL2(1),AL2(GENMEM+MEMNREQ)
CMDTBSZB EQU   ((*-CMDTBLB)/12)
         SPACE 2
**********************************************************************
*               P A N E L     N A M E     T A B L E S                *
**********************************************************************
         SPACE
PNLNMTBL DC    CL8'DS@SCPDT',CL8'DS@SCPDV'  SINGLE DSN, ^ LOAD, L/R
         DC    CL8'DS@SCPDU',CL8'DS@SCPDW'  MULT DSN, ^ LOAD,   L/R
         DC    CL8'DS@SCPL1',CL8'DS@SCPL3'  SING DSN, LOADLIB,  L/R
         DC    CL8'DS@SCPL2',CL8'DS@SCPL4'  MULT DSN, LOADLIB,  L/R
         SPACE
PNLNMTBE DC    CL8'DS@EDBRT',CL8'DS@EDBRT'  SINGLE DSN, ^ LOAD, L/R
         DC    CL8'DS@EDBRU',CL8'DS@EDBRU'  MULT DSN, ^ LOAD,   L/R
         DC    CL8'DS@EDBR1',CL8'DS@EDBR1'  SING DSN, LOADLIB,  L/R
         DC    CL8'DS@EDBR2',CL8'DS@EDBR2'  MULT DSN, LOADLIB,  L/R
         SPACE
**********************************************************************
*        U P P E R    C A S E    T R A N S L A T E   T B L           *
**********************************************************************
         SPACE
TBLUPPER DS    0F
         DC    256AL1(*-TBLUPPER)
         ORG   TBLUPPER+X'81'
TBLGRPA  DC    9AL1(C'A'+*-TBLGRPA)
         ORG   TBLUPPER+X'91'
TBLGRPJ  DC    9AL1(C'J'+*-TBLGRPJ)
         ORG   TBLUPPER+X'A2'
TBLGRPS  DC    8AL1(C'S'+*-TBLGRPS)
         ORG   TBLUPPER+256
         SPACE 3
**********************************************************************
*                 H E X     T R A N S L A T E    T B L               *
**********************************************************************
         SPACE
TRTABLE  EQU   *-X'F0'
         DC    C'0123456789ABCDEF'
         TITLE 'DELIMITER TRANSLATE TABLE'
**********************************************************************
*          D E L I M I T E R     T R A N S L A T E   T B L           *
**********************************************************************
*          BE SURE CAPS ARE OFF IF YOU NEED TO CHANGE THIS!!!!       *
**********************************************************************
         SPACE
DELTBL   DC    256X'00'              DELIMITERS
         ORG   DELTBL+C'_'
         DC    C'_'                    UNDERSCORE
         ORG   DELTBL+C'a'
         DC    C'abcdefghi'            LOWER A - I
         ORG   DELTBL+C'j'
         DC    C'jklmnopqr'            LOWER J - R
         ORG   DELTBL+C's'
         DC    C'stuvwxyz'             LOWER S - Z
         ORG   DELTBL+C'A'
         DC    C'ABCDEFGHI'            UPPER A - I
         ORG   DELTBL+C'J'
         DC    C'JKLMNOPQR'            UPPER J - R
         ORG   DELTBL+C'S'
         DC    C'STUVWXYZ'             UPPER S - Z
         ORG   DELTBL+C'0'
         DC    C'0123456789'           NUMERIC
         ORG
         TITLE 'ERROR MESSAGE NUMBER EQUATES'
**********************************************************************
*              E R R O R    M E S S A G E    N U M B E R S           *
**********************************************************************
         SPACE
MSG1     EQU   1
MSG2     EQU   2
MSG3     EQU   3
MSG4     EQU   4
MSG5     EQU   5
MSG6     EQU   6
MSG7     EQU   7
MSG8     EQU   8
MSG9     EQU   9
MSG10    EQU   10
MSG11    EQU   11
MSG12    EQU   12
MSG13    EQU   13
MSG14    EQU   14
MSG15    EQU   15
MSG16    EQU   16
MSG17    EQU   17
MSG18    EQU   18
MSG19    EQU   19
MSG20    EQU   20
MSG21    EQU   21
MSG22    EQU   22
MSG23    EQU   23
MSG24    EQU   24
MSG25    EQU   25
MSG26    EQU   26
MSG27    EQU   27
MSG28    EQU   28
MSG29    EQU   29
MSG30    EQU   30
MSG31    EQU   31
MSG32    EQU   32
MSG33    EQU   33
MSG34    EQU   34
MSG35    EQU   35
MSG36    EQU   36
MSG37    EQU   37
MSG38    EQU   38
MSG39    EQU   39
MSG40    EQU   40
MSG41    EQU   41
MSG42    EQU   42
MSG43    EQU   43
MSG44    EQU   44
MSG45    EQU   45
MSG46    EQU   46
MSG47    EQU   47
MAXMSG   EQU   MSG47
         END   DS@SCPDS
