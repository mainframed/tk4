DS@FLSTC TITLE 'DS@FLSTC - FULISTC MODULE'
***********************************************************************
*  PROGRAM-ID: DS@FLSTC                                               *
*  FUNCTION:                                                          *
*      THIS PROGRAM IS CALLED BY THE FSLISTC  CLIST TO BUILD THE      *
*      ISPF TABLE FOR DISPLAY BY THE CLIST.  THE OUTPUT IS SIMILAR    *
*      TO WHAT WOULD BE OBTAINED USING THE LISTSPC TSO COMMAND,       *
*      EXCEPT THAT THE OUTPUT IS IN A TABLE FORM FOR THE USER TO      *
*      SCROLL THROUGH, AND THE USER MAY BROWSE, EDIT, RENAME AND      *
*      DELETE DATA SETS, AND COMPRESS AND OBTAIN A MEMBER LIST FOR    *
*      PDS'S.                                                         *
*                                                                     *
*  REGISTER USAGE:                                                    *
*      R0 - R10 GENERAL WORK REGISTERS                                *
*      R11 - BASE REGISTER                                            *
*      R13-R15 - STANDARD LINKAGE                                     *
*                                                                     *
*  RETURN CODES:                                                      *
*       0 - ALWAYS RETURNED--AN ISPF MESSAGE IS SET IF ANYTHING       *
*           UNUSUAL OCCURS.                                           *
*                                                                     *
*  RESTRICTIONS:                                                      *
*     THIS DIALOG APPLICATION REQUIRES VERSION 2 OR LATER OF ISPF.    *
*                                                                     *
* AUTHOR:   PHIL HEROLD, SYSTEMS DEVELOPER                            *
*           SAS INSTITUTE                                             *
*           CARY, NC                                                  *
*                                                                     *
* NOTE:  SAS INSTITUTE IS NOT RESPONSIBLE FOR THE SUPPORT OF THIS     *
*        PROGRAM--PLEASE DO NOT CALL SAS INSTITUTE TECHNICAL SUPPORT. *
*        HOWEVER, THE AUTHOR WILL BE GLAD TO PROVIDE ANY ASSISTANCE   *
*        NEEDED.                                                      *
*                                                                     *
*                                                                     *
* ACKNOWLEDGEMENT:  THIS PROGRAM WAS ORIGINALLY DEVELOPED AT FIRST    *
*                   COMPUTER SERVICES, CHARLOTTE, NORTH CAROLINA, AND *
*                   WAS MODIFIED FOR USE IN THE ENVIRONMENT IN WHICH  *
*                   IT NOW RUNS.  THE AUTHOR WOULD LIKE TO ESPECIALLY *
*                   THANK DAVE LASALLE FOR HIS SUPPORT AND ENCOURAGE- *
*                   MENT.                                             *
*                                                                     *
*                                                                     *
***********************************************************************
         COPY  DS@MACS
         TITLE 'MISCELLANEOUS EQUATES'
***********************************************************************
*                    O T H E R    E Q U A T E S                       *
***********************************************************************
*
DEFDELAY EQU   20                      DEFAULT TIME DELAY
MINDELAY EQU   5                       MINIMUM DELAY IS 5 SECONDS
*
FLAGON   EQU   C'1'
FLAGOFF  EQU   C'0'
         TITLE 'DS@FLSTC - DSECTS'
**********************************************************************
*                                                                    *
*   THE FOLLOWING DSECT IS USED BY THE LOCINDEX PROGRAM; IT MAPS THE *
* WORKAREA WHOSE ADDRESS WE PROVIDE.  IF THIS PROGRAM FAILS TO PRO-  *
* DUCE THE DESIRED RESULTS, CHECK LOCINDEX TO SEE IF THE DSECTS      *
* CORRESPOND.                                                        *
*                                                                    *
**********************************************************************
         SPACE
WORKSECT DSECT               WORK AREA PASSED AS PARM
GETADDR  DS    A             ADDRESS OF GETMAINED VSAM WORK AREA
TRTAB    DS    CL256                                        *HMD 12/79*
         DS    0D            ALIGNMENT                      *HMD 12/79*
VOLCNT   DS    H
DEVT     DS    XL4
SER      DS    CL6
SEQ      DS    H
         DS    CL251
OINDEX   DS    CL44          PREVIOUS VALUE OF FIRST PARM
REST     DS    CL44          LOW QUALIFIER COMPARE STRING
NEXT     DS    A             ADDRESS OF NEXT DSN IN INCORE TABLE
LAST     DS    A             ADDRESS OF BYTE AFTER END OF DSNLIST
LKEY     DS    H             LENGTH OF GENERIC KEY
SAVE12   DS    2F            SAVE AREA OVER TRT INSTR       *HMD 12/79*
NOREST   DS    0B            FLAG IF 'REST' IS EMPTY
LREST    DS    H             LENGTH OF REST
USERIDF  EQU   X'80'         USERID FLAG                    *HMD 12/79*
ASTERF   EQU   X'40'         LAST LEVEL ONLY INDICATOR      *HMD 12/79*
         TITLE 'DS@FLSTC - DSA DEFINITION'
**********************************************************************
*                         D S A                                      *
**********************************************************************
         SPACE
FLSTCDSA DSECT
SAVEAREA DC    18F'0'
         SPACE
GETSVA@  DC    A(0)                   ADDRESS OF GET SAVEAREA ROUTINE
FREESVA@ DC    A(0)                   ADDRESS OF FREE SAVEAREA ROUTINE
         SPACE
DS@14TO1 DC    4F'0'                  TEMP SAVE AREA FOR REGISTERS
DS@14T1L EQU   *-DS@14TO1             LENGTH OF ABOVE
         SPACE
HWK1     DC    H'0'                   HALF WORD WORK AREA
VOLTKCYL DC    H'19'                  # TRKS/CYL FOR 3350
WKD      DC    D'0'                   DOUBLE WORK WORK AREA
CLOCK    DC    D'0'                   CURRENT TIME
CCLOCK   DC    D'0'                   NEXT TIME FOR STATS
STCNT    DC    H'0'                   STAT SHOW COUNTER
HALF0    DC    H'0'                   CONSTANT
ZEROES   DC    D'0'                   TWO WORDS OF BINARY ZEROES
TIMEVAL  DC    F'0'                   TIME VALUE FOR DELAY (SECS)
GPREFL   DC    F'0'                   LENGTH FOR 1ST PART (GENERIC)
CNVWORK  DC    D'0'                   WORK AREA FOR CONVERT ROUTINE
CNVWORK2 DC    CL16' '                WORK AREA FOR CONVERT ROUTINE
XTNTS    DS    16XL10
LASTTRK  DC    H'0'
WXTNT    DS    CL5
         SPACE 2
ZPREFIX  DC    CL8' '                 USERID OF USER FOR SEARCH
ZDATE    DC    CL8' '                 CURRENT DATE
ZJDATE   DC    CL6' '                 CURRENT DATE (JULIAN)
PREFIX   DC    CL44' '                CATALOG PREFIX
DFORM    DC    C' '                   DISPLAY OPTION
CONFIRM  DC    C' '                   CONFIRM OPTION
DELAY    DC    CL4' '                 STIMER DELAY
TRACE    DC    CL5' '                 EQUAL "TRACE" IF DEBUG
INITBLNG EQU   *-ZPREFIX              LENGTH TO BLANK
         SPACE
DSNSAVE  DC    CL52' '
DSNSHSV  DC    CL44' '
*                                *** TABLE VARIABLES FOLLOW
TBSEL    DC    C' '                   SELECT OPTION
TBDSNAME DC    CL44' '                DATA SET NAME
TBDSNSH  DC    CL44' '                DATA SET NAME MINUS PREFIX
TBMEM    DC    CL8' '                 MEMBER NAME (INPUT)
TBCRTED  DC    CL8' '                 DATE OF DATA SET CREATION
TBEXPDT  DC    CL8' '                 EXPIRATION DATE FOR DATASET
TBLSTRF  DC    CL8' '                 DATE OF LAST REFERENCE
TBDSORG  DC    CL2' '                 DATA SET ORGANIZATION
TBRECFM  DC    CL3' '                 DATA SET RECORD FORMAT
TBLRECL  DC    CL5' '                 DATA SET LOGICAL RECORD LENGTH
TBBLKSZ  DC    CL5' '                 DATA SET BLOCK SIZE
TBALC    DC    CL4' '                 # OF TRKS ALLOCATED
TBPCUSED DC    CL4' '                 % OF USED TRKS
TBEXTNTS DC    CL2' '                 # OF EXTENTS USED
TBVOLSER DC    CL6' '                 VOLSER OF DATA SET
TBDELBLK EQU   *-TBCRTED              LENGTH TO BLANK AFTER DELETE
TBDEVT   DC    XL4'0'                 DEVICE TYPE FOR DS
TBEND    EQU   *
*                                ***  END OF TABLE VARIABLES
DSF      DC    F'0'                   STATISTICS VARIABLE
DSP      DC    F'0'                        "        "
         SPACE
CRP      DC    F'0'                   CURRENT ROW POINTER
ZTDTOP   DC    F'0'                   TOP ROW ON DISPLAY
SCRHORZ  DC    CL8' '                 HORIZONTAL SCROLL (DYNAMIC)
ZCMD     DC    CL79' '                ZCMD FROM DISPLAY
SAVZCMD  DC    CL79' '                PLACE TO SAVE ZCMD
ZCMDMRK  DC    X'FF'              *** MUST FOLLOW ZCMD (INITIALIZED)
ZTDMARK  DC    CL79' '                ZTDMARK VAR
DSN1     DC    CL44' '                DSN1 (MEMBER LIST)
DSN2     DC    CL44' '                DSN2 (MEMBER LIST)
DSN3     DC    CL44' '                DSN3 (MEMBER LIST)
DSN4     DC    CL44' '                DSN4 (MEMBER LIST)
VOL1     DC    CL6' '                 VOL1 (MEMBER LIST)
MODE     DC    C' '                   MODE (MEMBER LIST)
USERID   DC    CL8' '                 USERID (MEMBER LIST)
USEROP   DC    C' '                   USEROP (MEMBER LIST)
MEMBER   DC    CL8' '                 MEMBER (MEMBER LIST)
SCOP     DC    C' '                   SCAN OPTION (SCANPDS)
RLSE     DC    C' '                   RELEASE OPTION (COMPRESS)
PRTOPT   DC    C' '                   IEBCOPY MESSAGES OPT (COMPRESS)
INITV2L  EQU   *-DSN1                 LENGTH TO BLANK OUT
         SPACE
         DS    0F
ZPREFIXL DC    F'0'
ZDATEL   DC    F'0'
ZJDATEL  DC    F'0'
PREFIXL  DC    F'0'
DFORML   DC    F'0'
CONFIRML DC    F'0'
DELAYL   DC    F'0'
TRACEL   DC    F'0'
         SPACE
TBSELL   DC    F'0'
TBDSNL   DC    F'0'
TBDSNSHL DC    F'0'
TBMEML   DC    F'0'
TBCRTDL  DC    F'0'
TBEXPDL  DC    F'0'
TBLSTRFL DC    F'0'
TBDSORGL DC    F'0'
TBRECFML DC    F'0'
TBLRECLL DC    F'0'
TBBLKSZL DC    F'0'
TBALCL   DC    F'0'
TBPCUSDL DC    F'0'
TBXTNTSL DC    F'0'
TBVLSERL DC    F'0'
TBDEVTL  DC    F'0'
*
DSFL     DC    F'0'
DSPL     DC    F'0'
         SPACE
CRPL     DC    F'0'
ZTDTOPL  DC    F'0'
SCRHORZL DC    F'0'
ZCMDL    DC    F'0'
ZTDMARKL DC    F'0'
DSN1L    DC    F'0'
DSN2L    DC    F'0'
DSN3L    DC    F'0'
DSN4L    DC    F'0'
VOL1L    DC    F'0'
MODEL    DC    F'0'
USERIDL  DC    F'0'
USEROPL  DC    F'0'
MEMBERL  DC    F'0'
SCOPL    DC    F'0'
RLSEL    DC    F'0'
PRTOPTL  DC    F'0'
         SPACE
CSR      DC    F'0'
SKIPNUM  DC    F'0'
RCSAVE   DC    F'0'
         SPACE
BLANKS   DC    CL256' '
BLNKLNG  EQU   *-(BLANKS+1)
         SPACE
TBLNAME  DC    CL8' '
         ORG   TBLNAME+4
TBLNMTM  DS    CL4' '                 TIME AS PART OF TABLE NAME
         SPACE
TBPANEL  DC    CL8' '
STPANLNM DC    CL8' '
TDATE    DC    CL8' '
TDATEJC  DC    XL1'0'
TDATEJ   DC    PL3'0'
AUTOSEL  DC    CL3' '
ERRFIELD DC    CL70' '
ERFIELDL EQU   *-ERRFIELD
         SPACE
         DS    0F
TBSRTBFL DC    F'0'
TBSRTBUF DC    CL60' '
         ORG   TBSRTBUF
TBSORT   DC    CL8'TBSORT '
NAMETBL  DC    CL8' '
         DC    C' FIELDS('
SORTFLD1 DC    CL8' '
         DC    C',C,'
SORTOP1  DC    C'A'
         DC    C','
SORTFLD2 DC    CL8' '
         DC    C',C,'
SORTOP2  DC    C'A'
         DC    C')'
         ORG
         SPACE
FLAGBYTE DC    X'00'                  FLAG BYTE NUMBER 1 (PRIMARY)
TBINIT   EQU   B'10000000'              TABLE HAS BEEN CREATED
NOSHOW   EQU   B'01000000'              DON'T SHOW STATS SCREEN
MANY     EQU   B'00100000'              "MANY" FROM TBDISPL
CMDZ     EQU   B'00010000'              PROCESSING ZCMD
SKIPPUT  EQU   B'00001000'              DON'T DO TBPUT
GENERIC  EQU   B'00000100'              GENERIC PREFIX
         SPACE
RBLDFLAG DC    X'00'                  SET TO 1 IF SWITCH COMMAND
         SPACE
SCRLLFLG DC    X'00'                  0 IF "LEFT", 1 IF "RIGHT"
         SPACE
STAXFLAG DC    X'00'
         SPACE
STAXUADR DC    A(STAXFLAG)
         SPACE
EDFLD    DS    XL6
EDMASK1  DC    XL6'402020202021'
         SPACE
VTOCCHHR DC    XL5'0'                 TRACK ADDR WORK AREA
         DS    0F                     PARM BLOCK FOR LOCINDEX
SEEKCAM  CAMLST SEEK,0,0,0
SRCHCAM  CAMLST SEARCH,0,0,0
DELCAM   CAMLST SCRATCH,0,,0
CATCAM   CAMLST CAT,0,,0
UNCATCAM CAMLST UNCAT,0
RENCAM   CAMLST RENAME,0,0,0
STAXPL   STAX  0,DEFER=NO,USADDR=0,MF=L
CALLPL   CALL  ,(,,,,,,,,,,,),MF=L
CALLPLL  EQU   *-CALLPL
RACHKPL  RACHECK ,MF=L                RACHECK PARAMETER LIST
         SPACE
VOLLIST  DS    0H
VOLNUM   DC    H'1'
VOLDEVT  DC    XL4'0'
VOLVOLS  DC    CL6' '
VOLSTCD  DC    H'0'
         SPACE
         DS    0F                     PARM BLOCK FOR LOCINDEX
VARTBLA  DC    A(0),A(0),A(0)           PARMLIST FOR VARIABLE ROUTINES
         SPACE
SAVDFORM DC    C' '                   SAVE DISPLAY FORMAT
         DS    0H
SAVPREF  DC    CL44' '                CATALOG PREFIX SAVE AREA (STACK)
SAVPREFL DC    F'0'                   CAT. PREFIX LENGTH SAVE AREA
         SPACE
TOKPTR   DC    F'0'
TOKEN    DC    CL52' '
         SPACE
         DS    0F
PARM     DC    A(0)                     PREFIX ADDRESS
         DC    A(0)                     DSN ADDRESS
         DC    A(0)                     VOL SER ADDRESS
         DC    A(0)                     ADDRESS OF WORKAREA
         DC    A(0)                     ADDRESS OF TRACKS PER CYLINDER
         DC    CL10' '
         SPACE
BUF1     DS    0D
         DS    265C
         SPACE
         DS    0F
         DS@CNDPB DSECT=NO            CONVERT DATA ROUTINE PARM BLOCK
         DS    0F
         DS@CPRPB DSECT=NO            COMPRESS ROUTINE PARM BLOCK
         DS    0F
         DS@MSGPB DSECT=NO            MESSAGE PARAMETER BLOCK
         DS    0F
MSGDSA   DC    100F'0'                DSA FOR THE MESSAGE SYSTEM
         SPACE
NUMSVA   DC    F'0'                   NUMBER OF SAVE AREAS
SAVADDR  DC    A(0)                   LAST SAVE AREA
SAVMAX   EQU   16                     LEVEL OF SUBROUTINE NESTING
SAVALNG  EQU   64                     LENGTH OF A SAVE AREA
         SPACE
SAVSTCK  DS    0F                     SAVE AREA STACK
         ORG   *+(SAVMAX*SAVALNG)
         SPACE
LOCINDXW DS    0D
         ORG   *+4096                 4K WORK AREA FOR LOCINDEX
LNGDSA   EQU   *-FLSTCDSA
         TITLE 'DS@FLSTC - MAINLINE CODE'
**********************************************************************
*                      D S @ F L S T C                               *
**********************************************************************
         SPACE
DS@FLSTC CSECT
         PRINT GEN
         USING *,R15
         DS@START ,
*        PRINT NOGEN
         LR    BASE,R15               LOAD BASE REGISTER
         DROP  R15                    DROP TEMPORARY BASE
         USING DS@FLSTC,BASE
         LH    R1,=AL2(LNGDSA)        GET DSA LENGTH
         LR    R5,R1                  COPY FOR LATER
         GETMAIN RC,LV=(R1)           GO GET SOME STORAGE
         LR    R4,R1                  COPY ADDRESS RETURNED
         SLR   R3,R3                  CLEAR THIS REGISTER
         MVCL  R4,R2                  THIS SHOULD ZERO IT OUT
         ST    R13,4(0,R1)            SET BACKWARD CHAIN
         ST    R1,8(0,R13)            SET FORWARD CHAIN
         LR    R13,R1                 GET DSA BASE
         USING FLSTCDSA,R13
         MVC   SAVEAREA(4),=C'DS@F'   MOVE IN SAVE AREA IDENTIFIER
         L     R1,=A(GETSVA)          ADDRESS THIS ROUTINE
         ST    R1,GETSVA@             SAVE IN DSA
         L     R1,=A(FREESVA)         ADDRESS THIS ROUTINE
         ST    R1,FREESVA@            SAVE IN DSA
*
         DO    SETATTN                SET ATTENTION EXIT
         DO    INIT                   GO DO ALL INITIALIZATION
RBLDLOOP DS    0H                     LOOP IF HERE IF SWITCH COMMAND
         DO    PROCESS                GO PROCESS THE INPUT
         L     R1,DSF                 GET NUMBER IN THE TABLE
         LTR   R1,R1                  IF NONE ARE IN THE TABLE
         BZ    RETURN                   WE ARE DONE
TBLSHOW  DS    0H
         CALL  ISPLINK,(=CL8'CONTROL',=CL8'DISPLAY',=CL8'REFRESH'),VL, +
               MF=(E,CALLPL)
         DO    PROCTBL                GO SHOW THE TABLE BUILT
RETURN   DS    0H
         STAX  ,                      TURN ATTENTION OFF
         TM    FLAGBYTE,TBINIT        IF TABLE WAS CREATED,
         BZ    RETNTB
         LA    R2,TBLNAME               GET RID OF IT
         CALL  ISPLINK,(=CL8'TBEND',(R2)),VL,MF=(E,CALLPL) KILL IT
         NI    FLAGBYTE,255-TBINIT
RETNTB   DS    0H
         CLI   RBLDFLAG,FLAGON        IF SWITCH COMMAND, THEN
         BE    RBLDLOOP                 LET'S GO AGAIN
         LR    R2,R13                 COPY R13
         LH    R1,=AL2(LNGDSA)        GET DSA LENGTH
         L     R3,4(0,R13)            COPY PREVIOUS REGISTER 13
         FREEMAIN RC,LV=(R1),A=(R2)   DO THE FREEMAIN
         LR    R13,R3                 RESTORE REG 13 CONTENTS
         SLR   R15,R15                SET RETURN CODE
         RETURN (14,12),T,RC=(15)     DONE
         SPACE
         LTORG
         SPACE
         DROP  BASE
         TITLE 'INITIALIZATION SUBROUTINE'
**********************************************************************
*                 I N I T         S U B R O U T I N E                *
*                                                                    *
*    THIS SUBROUTINE DOES ALL OF THE INITIALIZATION REQUIRED.  IT    *
*  CALLS THE GETVARS SUBROUTINE TO VCOPY THE DIALOG VARIABLES THAT   *
*  THIS PROGRAM NEEDS, AND THEN DETERMINES THE LENGTH OF THE INDEX   *
*  PREFIX IF GIVEN.                                                  *
*    INPUT: R14 - RETURN ADDRESS                                     *
*                                                                    *
**********************************************************************
         SPACE
         USING INIT,BASE
         SPACE
INIT     DS@ENTR ,
         LR    R1,R13                 COPY DSA ADDRESS
         AH    R1,=AL2(MSGDSA-FLSTCDSA) ADD OFFSET FOR THIS
         ST    R1,MSGDSA@             SAVE IN MESSAGE PARM BLOCK
         LA    R1,1                   GET CONSTANT
         ST    R1,MSGTB               SET TABLE ID
         MVI   BLANKS,C' '            SET THIS FIELD TO BLANKS
         MVC   BLANKS+1(BLNKLNG),BLANKS PROPOGATE THE BLANKS
         MVC   ZPREFIX(INITBLNG),BLANKS INIT THESE FIELDS
         MVC   SEEKCAM(SEEKCAML),SEEKCAMM MOVE IN MASK
         MVC   SRCHCAM(SRCHCAML),SRCHCAMM MOVE IN MASK
         MVC   DELCAM(DELCAML),DELCAMM  MOVE IN MASK
         MVC   CATCAM(CATCAMML),CATCAMM MOVE IN MASK
         MVC   UNCATCAM(UNCATCML),UNCATCMM  MOVE IN MASK
         MVC   RENCAM(RENCAMML),RENCAMM  MOVE IN MASK
         MVC   STPANLNM,=CL8'DS@FMST1' INIT STATUS PANEL NAME
         MVC   EDMASK1,=X'402020202021' SET MASK MASK
         LA    R1,VTOCCHHR            ADDRESS THIS FIELD
         LA    R2,TBVOLSER            ADDRESS THIS FIELD
         LA    R3,BUF1                ADDRESS THIS FIELD
         STM   R1,R3,SEEKCAM+4        BUILD SEEK CAMLST
         LA    R1,TBDSNAME            ADDRESS THIS FIELD
         LA    R2,TBVOLSER            ADDRESS THIS FIELD
         LA    R3,BUF1                ADDRESS THIS FIELD
         STM   R1,R3,SRCHCAM+4        BUILD SEEK CAMLST
         GET   GETVTBL1,ZPREFIXL,ZPREFIX COPY INPUT VARIABLES
         MVC   TDATE,ZDATE            MOVE IN ZDATE
         L     R3,DELAYL              GET LENGTH FOR SUBROUTINE
         LTR   R3,R3                  IF DELAY NOT GIVEN, THEN
         BNZ   INITSK1                  USE DEFAULT
         LA    R4,DEFDELAY
         B     INITSK2
INITSK1  DS    0H
         LA    R2,DELAY               SET UP FOR CONVERT TO BINARY
         DO    CONVBIN                CONVERT IT
         LTR   R1,R1                  IF DELAY PASSED WAS ZERO,
         BZ    INITRET                  THEN NO DELAY (NO STATS)
         LA    R2,MINDELAY            GET MININUM DELAY VALUE
         CR    R1,R2                  IF LESS THAN MINIMUM, THEN
         BNL   *+6                      SET TO MINIMUM
         LR    R1,R2
INITSK2  DS    0H
         ST    R1,TIMEVAL             AND SAVE IT
INITRET  DS@EXIT ,
         SPACE
SEEKCAMM CAMLST SEEK,0,0,0
SEEKCAML EQU   *-SEEKCAMM             LENGTH OF ABOVE
         SPACE
SRCHCAMM CAMLST SEARCH,0,0,0
SRCHCAML EQU   *-SRCHCAMM             LENGTH OF ABOVE
         SPACE
DELCAMM  CAMLST SCRATCH,0,,0
DELCAML  EQU   *-DELCAMM              LENGTH OF ABOVE
         SPACE
UNCATCMM CAMLST UNCAT,0
UNCATCML EQU   *-UNCATCMM             LENGTH OF ABOVE
         SPACE
CATCAMM  CAMLST CAT,0,,0
CATCAMML EQU   *-CATCAMM              LENGTH OF ABOVE
         SPACE
RENCAMM  CAMLST RENAME,0,0,0
RENCAMML EQU   *-RENCAMM              LENGTH OF ABOVE
         DROP  BASE
         TITLE 'PROCESS CATALOG ROUTINE'
**********************************************************************
*              P R O C E S S        R O U T I N E                    *
*                                                                    *
*     THIS SUBROUTINE DOES THE ACTUAL PROCESSING, BY READING THE     *
*   SYSTEM CATALOG, AND FOR EACH DATA SET, MOVES THE INFORMATION     *
*   INTO THE ISPF TABLE FOR LATER DISPLAY.                           *
*                                                                    *
**********************************************************************
         SPACE
         USING PROCESS,BASE
         SPACE
PROCESS  DS@ENTR ,
         MVI   RBLDFLAG,FLAGOFF       RESET FLAG FOR "SWITCH"
         LA    R1,PREFIX           ADDRESS PREFIX
         ST    R1,PARM             SAVE ADDR IN PARM LIST
         LA    R1,TBDSNAME         ADDRESS TBDSNAME
         ST    R1,PARM+4           SAVE ADDR IN PARM LIST
         LA    R1,TBVOLSER         ADDRESS TBVOLSER
         ST    R1,PARM+8           SAVE ADDR IN PARM LIST
         LA    R1,LOCINDXW         POINT TO LOCINDEX WORK AREA
         ST    R1,PARM+12          SAVE ADDR IN PARM LIST
         LA    R1,VOLTKCYL         SET UP FIELD IN PARMLIST
         ST    R1,PARM+16
         MVI   PARM+12,X'80'       INDICATE END OF PARM LIST
         MVI   WXTNT+4,X'04'
         DO    SRCHCAT             GO SEARCH THE CATALOG
         LTR   R15,R15             IF RETURN CODE IS NOT ZERO,
         BZ    PROCCONT              REFRESH DISPLAY, AND DONE
         CALL  ISPLINK,(=CL8'CONTROL',=CL8'DISPLAY',=CL8'REFRESH'),VL, +
               MF=(E,CALLPL)
         B     PROCRET
PROCCONT DS    0H
         CLI   DFORM,C'L'          IF LONG SPECIFIED, THEN
         BNE   PROCRET
         DO    COMPTBL               FILL IN THE TABLE
PROCRET  DS@EXIT ,
         SPACE
         DROP  BASE
         TITLE 'DS@FLSTC - SEARCH THE CATALOG'
**********************************************************************
*                S R C H C A T    S U B R O U T I N E                *
*                                                                    *
*   THIS SUBROUT. SEARCHES THE CATALOG FOR THE GIVEN CATALOG PREFIX. *
* THE LOCINDEX ROUTINE IS USED TO RETURN THE DATA SET NAME FOR THE   *
* PREFIX.  FOR EACH, WE ADD THE DATA SET NAME TO THE ISPF TABLE.     *
* IF ANY ERRORS ARE ENCOUNTERED, A RETURN CODE IS SET, AND WE GET    *
* OUT OF HERE.                                                       *
*                                                                    *
**********************************************************************
         SPACE
         USING SRCHCAT,BASE
         SPACE
SRCHCAT  DS@ENTR ,
         MVC   GPREFL,PREFIXL      SET GENERIC = PREFIX LENGTH
         DO    TIMESET             GO SET TIME FOR STATS
SCLOOP   DS    0H
         CLI   STAXFLAG,FLAGON     IF ATTENTION YET, THEN
         BE    ENDATTN               GET OUT OF HERE
SCLP01   DS    0H
         CLC   TIMEVAL,=F'0'       IF DELAY SPECIFIED,
         BE    SCLP02
         STCK  CLOCK                 SAVE CURRENT CLOCK
         CLC   CLOCK,CCLOCK          IF TIME TO SHOW STATS
         BNH   SCLP02
         DO    STSHOW                  GO SHOW THEM
SCLP02   DS    0H
         MVC   TBSEL(TBEND-TBSEL),BLANKS    CLEAR FOR NEXT ENTRY
         LA    R1,PARM             POINT TO PARM LIST
         L     R15,=V(LOCINDEX)    GET EXTERNAL ENTRY POINT
         BALR  R14,R15             GO TO IT
         B     *+4(R15)            BRANCH , DEP ON RETURN CODE
         B     OK                  0-GET INFOR FOR DSN & CONT
         B     NOUSER              4-SET RC & RETURN TO CALLER
         B     NOTDISK             8-SET "NOTDISK" & CONTINUE
         B     MULTIVOL            12-SET "MULTI" & CONTINUE
         B     ENDDSN              16-FINISHED-RETURN TO CALLER
         B     RDERR               20-SET RC & RETURN TO CALLER
         B     SVC26ER             24-SUPER LOCATE ERROR--SET RC
OK       DS    0H
         LA    R8,LOCINDXW
         USING WORKSECT,R8
         CLI   LREST,0             IF GENERIC PREFIX, THEN
         BNE   OK05
         TM    FLAGBYTE,GENERIC      IF NOT GENERIC SAID YET, THEN
         BO    OK01
         OI    FLAGBYTE,GENERIC        SAY GENERIC
         LH    R1,LKEY                 GET LENGTH OF KEY
         BCTR  R1,0                    LESS ONE
         ST    R1,GPREFL               SAVE AS GENERIC PREFIX LENGTH
OK01     DS    0H
         L     R15,=A(TBLBLNK)       ADDRESS BLANK TRT TABLE
         TRT   TBDSNAME,0(R15)       FIND FIRST BLANK (ALWAYS FOUND)
         SH    R1,LREST              BACK UP
         BCTR  R1,0                    LESS ONE
         CLI   0(R1),C'.'            IF C'.' NOT THERE, THEN
         BNE   SCLOOP                  CAN'T BE THIS ONE
         B     SCADDDSN
OK05     DS    0H                  ELSE
         LA    R5,TBDSNAME           ADDRESS DSNAME FIELD
         A     R5,PREFIXL            ADD LENGTH OF PREFIX
         CLI   0(R5),C' '            IF ' ' DOESN'T FOLLOW  OR
         BE    SCADDDSN
         CLI   0(R5),C'.'                 '.' DOESN'T FOLLOW, OR
         BNE   SCLOOP                  CAN'T BE THIS ONE
SCADDDSN DS    0H
         MVC   TBDEVT,DEVT         MOVE IN DEVICE TYPE
         DROP  R8
         DO    GETDSNSH            GET SHORT VERSION OF TBDSNAME
         DO    ADDTBL              GO ADD ENTRY TO TABLE
         L     R1,DSF              GET NUM OF DATA SETS FOUND
         LA    R1,1(,R1)           INCREMENT IT
         ST    R1,DSF              AND SAVE
         B     SCLOOP              AND LET'S GO AGAIN
         SPACE 2
NOUSER   DS    0H
         LA    R1,MSG2             SET MESSAGE NUMBER
         B     SCCATRET            LET'S GET OUT OF HERE
         SPACE 2
NOTDISK  DS    0H
         MVC   TBLSTRF,=CL8'NOT DISK' SET MESSAGE
         B     OK
         SPACE 2
MULTIVOL DS    0H
         MVC   TBVOLSER,=CL6'MULTI' INDICATE MULTIPLE VOLUMES
         B     OK
ENDATTN  DS    0H
         LA    R1,MSG33            SET MESSAGE NUMBER
         MVI   STAXFLAG,FLAGOFF    RESET THIS FLAG
         B     SCCATRET            AND GET OUT OF HERE
         SPACE 2
RDERR    DS    0H
         LA    R1,MSG3             SET MESSAGE NUMBER
         B     SCCATRET            AND GET OUT OF HERE
         SPACE 3
SVC26ER  DS    0H
         LA    R1,MSG6             SET MESSAGE NUMBER
         B     SCCATRET            AND GET OUT OF HERE
         SPACE 2
ENDDSN   DS    0H
         SLR   R15,R15             CLEAR RETURN CODE
         TM    FLAGBYTE,TBINIT     IF ^ TABLE WAS BUILT,
         BO    SCCATX
         LA    R1,MSG1               SET MESSAGE NUMBER
SCCATRET DS    0H
         DO    PUTMSG              GO SET AN ISPF MESSAGE
         LA    R15,4               SET A RETURN CODE
SCCATX   DS    0H
         DS@EXIT RET=R15
         TITLE 'DS@FLSTC - COMPLETE THE TABLE ROUTINE'
**********************************************************************
*                C O M P T B L    S U B R O U T I N E                *
*                                                                    *
*    THIS SUBROUTINE COMPLETES THE TABLE INFORMATION FOR THE TABLE   *
*  THAT HAS ALREADY BEEN CONSTRUCTED.  THE ONLY INFORMATION FOR      *
*  EACH ENTRY AT THIS POINT IS THE DATA SET NAME, AND VOLUME.  WE    *
*  "OBTAIN" THE FORMAT 1 DSCB AND THE FORMAT 3 DSCB (IF ONE EXISTS)  *
*  FOR THE DATASET IN EACH ENTRY OF THE TABLE, AND BUILD ALL OF THE  *
*  INFORMATION FOR THAT ENTRY.  THIS INCLUDES THE DSORG, THE # OF    *
*  ALLOCATED TRACKS, THE % OF USED TRACKS,   THE # OF EXTENTS, THE   *
*  DATE CREATED, AND THE DATE LAST REFERENCED, THE BLOCKSIZE, AND    *
*  LRECL FOR THE DATASET.                                            *
*                                                                    *
**********************************************************************
         SPACE
         USING COMPTBL,BASE
         SPACE
COMPTBL  DS@ENTR ,
         LA    R2,TBLNAME
         CALL  ISPLINK,(=CL8'TBTOP',(R2)),VL,MF=(E,CALLPL)
         MVC   STPANLNM,=CL8'DS@FMST2' RESET STATUS PANEL NAME
         OI    FLAGBYTE,NOSHOW    DON'T SHOW STATS SCREEN
         DO    STSHOW             GO UPDATE STATS VARIABLES
         NI    FLAGBYTE,255-NOSHOW RESET THIS FLAG
         DO    TIMESET            GO SET INTERVAL TIMER
CTLOOP   DS    0H
         CLI   STAXFLAG,FLAGON    IF ATTENTION KEY HIT, THEN
         BNE   CTCONT1
         LA    R1,MSG33             SET MESSAGE NUMBER
         DO    PUTMSG               GO SET AN ISPF MESSAGE
         MVI   STAXFLAG,FLAGOFF     RESET ATTENTION FLAG
         B     CTRETRN              AND DONE
CTCONT1  DS    0H
         LA    R2,TBLNAME
         CALL  ISPLINK,(=CL8'TBSKIP',(R2)),VL,MF=(E,CALLPL)
         LTR   R15,R15            IF END OF TABLE, THEN
         BNZ   CTRETRN              WE ARE DONE
         CLC   TIMEVAL,=F'0'      IF DELAY SPECIFIED, THEN
         BE    CTLP01
         STCK  CLOCK                SAVE CURRENT TIME
         CLC   CLOCK,CCLOCK         IF TIME TO SHOW STATS, THEN
         BNH   CTLP01
         DO    STSHOW                 GO SHOW THE STATS
CTLP01   DS    0H
         L     R1,DSP             GET NUMBER OF DATA SET PROCESSED
         LA    R1,1(,R1)          INCREMENT IT
         ST    R1,DSP             AND SAVE BACK
         CLC   TBLSTRF,=CL8'NOT DISK' IF "NOT DISK", THEN
         BE    CTPUTIT              GO FOR NEXT ONE
         MVC   DSNSAVE(44),TBDSNAME   SAVE DATASET NAME
         MVI   TBDSNAME,X'04'     MOVE FOR F4 DSCB
         MVC   TBDSNAME+1(43),TBDSNAME PROPOGATE IT
         OBTAIN SRCHCAM
         MVC   VOLTKCYL(2),BUF1+20 GET NUM OF TRKS/CYL
         MVC   TBDSNAME,DSNSAVE    RESTORE DATA SET NAME
         OBTAIN SRCHCAM
         LTR   R15,R15            IF OBTAIN FAILED, THEN
         BZ    CTOBTOK
         MVC   TBLSTRF,=CL8'NOTFOUND' SAY SO
         B     CTPUTIT              GO UPDATE TABLE
CTOBTOK  DS    0H
         DO    GETDSORG           GO GET DATA SET ORGANIZATION
         DO    GETRECFM           GO GET RECORD FORMAT
         LA    R5,BUF1+9          ADDRESS BEGINNING OF DATE CREATED
         LA    R6,TBCRTED         ADDRESS TABLE VARIABLE TO PUT RESULT
         DO    CONVDATE           GO CONVERT DATE CREATED FOR TABLE
         LA    R5,BUF1+12         ADDRESS BEGINNING OF EXP. CREATED
         LA    R6,TBEXPDT         ADDRESS TABLE VARIABLE TO PUT RESULT
         DO    CONVDATE           GO CONVERT DATE CREATED FOR TABLE
         CLC   TBEXPDT,BLANKS     IF NO EXPIRATION DATE, THEN
         BNE   *+10
         MVC   TBEXPDT,=CL8'**NONE**' SAY SO
         LA    R5,BUF1+31         ADDRESS BEGINNING OF DATE LAST REFER.
         LA    R6,TBLSTRF         ADDRESS TABLE VARIABLE TO PUT RESULT
         DO    CONVDATE           GO CONVERT DATE CREATED FOR TABLE
         CLC   TBLSTRF,BLANKS     IF NEVER REFERENCED, THEN
         BNE   *+10
         MVC   TBLSTRF,=CL8'**NONE**' SAY SO
         LH    R4,BUF1+44         GET DATA SET LRECL
         LTR   R4,R4              IF LRECL = 0, THEN
         BNZ   LRECLNZ
         MVC   TBLRECL,=C'    0'    SET VALUE IN TBL VAR
         B     SAVBLKSZ
LRECLNZ  DS    0H
         CVD   R4,WKD             CONVERT LRECL IN R4 TO DECIMAL
         MVC   EDFLD,EDMASK1      MOVE EDMASK TO EDFLD
         ED    EDFLD(6),WKD+5     MAKE IT DISPLAYABLE
         MVC   TBLRECL,EDFLD+1    MOVE TO TABLE VARIABLE
SAVBLKSZ DS    0H
         LH    R4,BUF1+42         GET DATA SET BLKSIZE
         CVD   R4,WKD             CONVERT BLKSIZE IN R4 TO DECIMAL
         MVC   EDFLD,EDMASK1      MOVE EDMASK TO EDFLD
         ED    EDFLD(6),WKD+5     MAKE IT DISPLAYABLE
         MVC   TBBLKSZ,EDFLD+1    MOVE TO TABLE VARIABLE
         CLC   TBVOLSER,=CL6'MULTI' IF NOT MULTI VOLUME, THEN
         BO    NOSPINFO
         DO    CALCSPC              CALCULATE SPACE INFO
         B     CTPUTIT
NOSPINFO DS    0H                 ELSE
         MVC   TBVOLSER,=CL6'MULTI' INDICATE MULTIPLE VOLUMES
CTPUTIT  DS    0H
         DO    PUTTBL              UPDATE THE TABLE
         B     CTLOOP               GO FOR THE NEXT ONE
CTRETRN  DS    0H
         DS@EXIT ,
         SPACE
         DROP  BASE
         TITLE 'DS@FLSTC - CALCULATE SPACE'
**********************************************************************
*                                                                    *
*    THIS SUBROUTINE CALCULATES THE SPACE ALLOCATION INFORMATION FOR *
*  THE DATASET GIVEN.  UPON ENTRY, AN OBTAIN HAS ALREADY BEEN DONE   *
*  TO GET US THE F4 DSCB, AND THE INFORMATION RETURNED IS IN BUF1.   *
*  WE CALCULATE THE NUMBER OF EXTENTS, TRACKS ALLOCATED, AND PERCENT *
*  TRACKS SPACE USED, AND UPDATE THE CORRESPONDING VARIABLES.        *
*                                                                    *
**********************************************************************
         SPACE
         USING CALCSPC,BASE
         SPACE
CALCSPC  DS@ENTR ,
         LA    R9,XTNTS            POINT TO EXTENTS SAVE AREA
         LH    R6,BUF1+54          GET LAST RELATIVE TRK USED
         CLI   BUF1+56,X'00'       IS TRK UNUSED?
         BE    *+8                  YES
         LA    R6,1(R6)             NO, ANOTHER TRACK
         STH   R6,LASTTRK          SAVE LAST REL. TRK
         SR    R2,R2                ZERO REG 2
         IC    R2,BUF1+15           PICK UP NUMBER OF EXTENTS
         LA    R3,1                 SET EXTENT COUNTER
         SR    R4,R4                CLEAR R4 TO TRK ACCUMULATION
         LTR   R2,R2               NO XTNTS? - GDG PATTERN. DSCB
         BZ    VVALID               YES, BYPASS ACCUMULATE
         LA    R5,BUF1+61           POINT TO FIRST EXTENT
VXTLOOP  DS    0H
         MVC   0(10,R9),0(R5)      MOVE EXTENT TO SAVE AREA
         LA    R9,10(R9)           BUMP TO NEXT SAVE AREA
         MVC   HWK1(2),6(R5)        MOVE HI-CYL TO HWD
         LH    R0,HWK1              LOAD
         MVC   HWK1(2),8(R5)        MOVE HI-TRK TO HWD
         LH    R1,HWK1              LOAD
         MVC   HWK1(2),2(R5)        MOVE LOW-CYL TO HWD
         SH    R0,HWK1              SUBTRACT
         MVC   HWK1(2),4(R5)        MOVE LOW-TRK TO HWD
         SH    R1,HWK1              SUBTRACT
         MH    R0,VOLTKCYL          CONVERT CYL TO TRK
         AR    R1,R0                GET TOTAL MINUS1
         LA    R4,1(R1,R4)          GET TOTAL AND ACCUMULATE
         CR    R3,R2                DONE LAST EXTENT?
         BE    VVALID               GO TO VVALID IF SO
         LA    R3,1(R3)             BUMP TO EXTENT COUNTER
         CH    R3,=H'4'             FOURTH EXTENT?
         BE    VXT4                   BRANCH IF SO
         CH    R3,=H'8'             EIGHTH EXTENT?
         BE    VXT8
         LA    R5,10(R5)            ELSE BUMP EXTENT POINTER
         B     VXTLOOP              AND GO TO NEXT EXTENT
VXT4     DS    0H
         MVC   VTOCCHHR(5),BUF1+91  POINT NEXT DSCB(F2 OR F3)
VXT4OBT  DS    0H
         OBTAIN SEEKCAM
         CLI   BUF1+44,C'3'         IF IT F3 DSCB
         BE    VXT4F3               BRANCH IF SO
         MVC   VTOCCHHR(5),BUF1+135  ELSE ITS F2-POINT TO F3
         B     VXT4OBT
VXT4F3   DS    0H
         LA    R5,BUF1+4            POINT TO FIRST EXTENT IN F3
         B     VXTLOOP              CONTINUE LOOP FOR SIZE
VXT8     DS    0H
         LA    R5,BUF1+45           SKIP OVER F3 ID IN F3 DSCB
         B     VXTLOOP            CONTINUE LOOP FOR SIZE
VVALID   DS    0H
* CONVERT SPACE ALLOC AND PUT INTO TABLE
         LTR   R4,R4              IF NO SPACE USED, THEN
         BNZ   CVD01
         MVC   TBALC,=C'   0'       SET FIELDS TO C'0'
         MVC   TBPCUSED,=C'  0'
         MVC   TBEXTNTS,=C' 0'
         B     CVDEXIT              AND GET OUT OF HERE
CVD01    DS    0H                 ELSE
         LH    R6,LASTTRK         GET LAST RELATIVE TRACK
         LR    R7,R4
         SR    R7,R6              R7 CONTAINS UNUSED SPACE
         CVD   R4,WKD             CONVERT TRKS IN R4
         MVC   EDFLD,EDMASK1      MOVE EDIT MASK IN
         ED    EDFLD(6),WKD+5     MAKE IT DISPLAYABLE
         MVC   TBALC,EDFLD+2      MOVE TO TBL VARIABLE
         LR    R5,R4              COPY TRACKS ^USED
         SR    R5,R7              CALCULATE TRACKS USED
         LR    R7,R5              COPY TRACKS ALLOCATED
         MH    R7,=H'1000'
         SLR   R6,R6              CLEAR FOR DIVIDE
         DR    R6,R4              CALCULATE PERCENT USED
         LTR   R7,R7              IF R7 = 0, THEN
         BNZ   CVD02
         MVC   TBPCUSED,=C'  0'     PLACE VALUE IN FIELD
         B     CVDX
CVD02    DS    0H
         CVD   R7,WKD             CONVERT %USED IN R7
         MVC   EDFLD,EDMASK1      MOVE EDIT MASK IN
         ED    EDFLD(6),WKD+5     MAKE IT DISPLAYABLE
         MVC   TBPCUSED,EDFLD+2   MOVE TO TBL VARIABLE
CVDX     DS    0H
         CVD   R2,WKD             CONVERT EXTENTS IN R2
         MVC   EDFLD,EDMASK1      MOVE EDIT MASK IN
         MVI   EDFLD+3,X'21'      PUT SIGNIFICANCE DIGIT IN 3RD BYTE
         ED    EDFLD(4),WKD+6     MAKE IT DISPLAYABLE
         MVC   TBEXTNTS,EDFLD+2   MOVE TO TBL VARIABLE
CVDEXIT  DS    0H
         DS@EXIT ,
         SPACE
         DROP BASE
         TITLE 'ATTENTION HANDLING ROUTINES'
**********************************************************************
*                                                                    *
*    THIS SUBROUTINE SETS UP THE ATTENTION (STAX), AND ALSO CONTAINS *
*  THE ATTENTION EXIT FOR PROCESSING IF AN ATTENTION OCCURS.         *
*                                                                    *
**********************************************************************
         SPACE
         USING SETATTN,BASE
         SPACE
SETATTN  DS@ENTR ,
         MVC   STAXPL(STAXML),STAXM   MOVE MASK TO DSA
         LA    R1,STAXFLAG            ADDRESS ATTENTION FLAG
         ST    R1,STAXUADR            SAVE IT
         LA    R2,STAXUADR
         STAX  ATTNEXIT,DEFER=NO,USADDR=(R2),MF=(E,STAXPL) ISSUE STAX
         DS@EXIT ,
         SPACE
STAXM    STAX  0,DEFER=NO,USADDR=0,MF=L MASK FOR STAX MACRO
STAXML   EQU   *-STAXM                LENGTH OF ABOVE
         SPACE
         DROP  BASE
         SPACE 2
ATTNEXIT DS    0H
         L     R1,8(R1)               ADDRESS USER PARAMETER LIST
         L     R1,0(R1)               ADDRESS OF USER PARM
         MVI   0(R1),FLAGON           SAY ATTENTION WAS HIT
         BR    R14                    AND RETURN TO SYSTEM
         TITLE 'ISSUE ISPF TABLE ADD AND CREATE SUBROUTINES'
**********************************************************************
*              A D D T B L        S U B R O U T I N E                *
*                                                                    *
*    THIS SUBROUTINE ADDS AN ENTRY TO THE TABLE.  IF THE TABLE HAS   *
*  NOT YET BEEN CREATED, IT ALSO ISSUES THE TBCREATE TO CREATE       *
*  THE DIALOG TABLE.                                                 *
*    INPUT: R14 - RETURN ADDRESS                                     *
*                                                                    *
**********************************************************************
         SPACE
         USING ADDTBL,BASE
         SPACE
ADDTBL   DS@ENTR ,
         TM    FLAGBYTE,TBINIT        Q.HAS TABLE BEEN CREATED?
         BO    ADDIT                  Y.THEN NO NEED TO CREATE NOW
         DO    INITTBL                ELSE GO CREATE THE TABLE
ADDIT    DS    0H
         LA    R2,TBLNAME
         CALL  ISPLINK,(=CL8'TBADD',(R2)),VL,MF=(E,CALLPL)
         DS@EXIT ,
         SPACE
         DROP  BASE
         SPACE 3
**********************************************************************
*              I N I T T B L      S U B R O U T I N E                *
*                                                                    *
*    THIS SUBROUTINE IS INVOKED ONLY ONCE TO SET UP THE ISPF TABLE   *
*  TO BE DISPLAYED BY THE INVOKING CLIST.  WE USE THE DEFVARS        *
*  SUBROUTINE TO DEFINE THE TABLE VARIABLES, AND WE CALL THE         *
*  TBCREATE DIALOG SERVICE TO CREATE THE TABLE.  NOTE THAT THIS      *
*  ROUTINE MAY NOT BE CALLED AT ALL.                                 *
*    INPUT: R14 - RETURN ADDRESS                                     *
*                                                                    *
**********************************************************************
         SPACE
         USING INITTBL,BASE
         SPACE
INITTBL  DS@ENTR ,
         DEFINE DEFVTBL1,TBSELL,TBSEL DEFINE OUR TABLE VARIABLES
         MVC   TBLNAME,=CL8'DS@F'     CREATE TABLE NAME
         CLI   TRACE,C'T'             IF TRACE NOT SPECIFIED, THEN
         BE    INITTBL1                 MAKE TIME PART OF TABLE NAME
         TIME  DEC
         ST    R0,TBLNMTM
INITTBL1 DS    0H
         LA    R2,TBLNAME
         XC    CALLPL(CALLPLL),CALLPL
         CALL  ISPLINK,(=CL8'TBCREATE',(R2),,TBLVARS,=CL8'NOWRITE'),VL,+
               MF=(E,CALLPL)
         OI    FLAGBYTE,TBINIT        INDICATE THAT WE HAVE BEEN HERE
         DS@EXIT ,
         SPACE
TBLVARS  DC   C'(TBSEL,TBDSNAME,TBCRTED,TBDSORG,TBALC,TBPCUSED,TBEXTNTS+
               ,TBVOLSER,TBRECFM,TBLRECL,TBBLKSZ,TBLSTRF,TBDSNSH,TBDEVT+
               ,TBEXPDT)'
         SPACE
         DROP  BASE
         TITLE 'SHOW THE STATISTICS FOR THE BUILD'
**********************************************************************
*              S T S H O W          R O U T I N E                    *
*                                                                    *
*     THIS SUBROUTINE SHOWS THE SCREEN GIVING THE STATISTICS ABOUT   *
*   THE SEARCH SO FAR.  THE SCREEN SERVES TWO PURPOSES--THE FIRST IS *
*   TO GIVE THE USER SOME INFORMATION, AND THE SECOND, AND MOST      *
*   IMPORTANT PURPOSE IS TO LET THE USER KNOW THAT WE ARE STILL      *
*   CRANKING AWAY.  WE SHOULD ONLY GET TO THIS ROUTINE AFTER THE     *
*   TIMER INTERVAL HAS EXPIRED.  THE DISPLAY IS LOCKED BEFORE THE    *
*   SCREEN IS SHOWN.                                                 *
*      REGISTER 5 THROUGH 9 ARE USED AS WORK REGISTERS.              *
**********************************************************************
         SPACE
         USING STSHOW,BASE
         SPACE
STSHOW   DS    0H
         DS@ENTR ,
STSHOW1  DS    0H
         TM    FLAGBYTE,NOSHOW        IF WE ARE TO SHOW THE SCREEN
         BO    STSHWRET
         LH    R3,STCNT                 GET STATUS COUNT
         LA    R3,1(,R3)                INCREMENT IT
         STH   R3,STCNT                 SAVE BACK
         CH    R3,=H'5'                 REFRESH SCREEN EVERY
         BL    STSHOW2                     FIFTH TIME
         CALL  ISPLINK,(=CL8'CONTROL',=CL8'DISPLAY',=CL8'REFRESH'),VL, +
               MF=(E,CALLPL)
         XC    STCNT,STCNT              RESET COUNTER
STSHOW2  DS    0H
         CALL  ISPLINK,(=CL8'CONTROL',=CL8'DISPLAY',=CL8'LOCK'),VL,    +
               MF=(E,CALLPL)
         LA    R2,STPANLNM
         CALL  ISPLINK,(=CL8'DISPLAY',(R2)),VL,MF=(E,CALLPL)
         DO    TIMESET                GO SET THE TIMER AGAIN
STSHWRET DS@EXIT ,
         SPACE
         DROP  BASE
         TITLE 'RECORD FORMAT CONVERSION ROUTINE'
**********************************************************************
*               G E T R E C F M        R O U T I N E                 *
*                                                                    *
*    THIS SUBROUTINE SIMPLY CONVERTS THE RECORD FORMAT IN THE DSCB   *
*    USING A TABLE LOOKUP INTO THE PRINTABLE 3-BYTE VERSION OF THE   *
*    RECORD FORMAT.                                                  *
*       INPUT: RECORD FORMAT IN BUF1+40                              *
*       OUTPUT: PRINTABLE RECFM IN TABLE VARIABLE TBRECFM            *
*                                                                    *
**********************************************************************
         SPACE
         USING GETRECFM,BASE
         SPACE
GETRECFM DS@ENTR ,
         LA   R1,RECFMTBL          ADDRESS BEGINNING OF TABLE
GETRFMLP DS   0H
         CLI  0(R1),FLAGON         DO UNTIL END OF THE TABLE
         BE   GETRFMRT
         CLC  0(1,R1),BUF1+40      IS THIS THE ONE?
         BE   GOTRECFM             Y.THEN SKIP
         LA   R1,4(R1)             ELSE NEXT RECFM TABLE ENTRY
         B    GETRFMLP             AND LOOP
GOTRECFM DS   0H
         MVC  TBRECFM,1(R1)        IF HERE, FOUND IT, SO MOVE TO TABLE
GETRFMRT DS@EXIT ,
         SPACE
RECFMTBL DC    X'40',C'V  '
         DC    X'44',C'VA '
         DC    X'48',C'VS '
         DC    X'50',C'VB '
         DC    X'54',C'VBA'
         DC    X'58',C'VBS'
         DC    X'80',C'F  '
         DC    X'84',C'FA '
         DC    X'88',C'FS '
         DC    X'90',C'FB '
         DC    X'94',C'FBA'
         DC    X'98',C'FBS'
         DC    X'C0',C'U  '
         DC    AL1(FLAGON)
         SPACE
         DROP  BASE
         TITLE 'DS ORGANIZATION CONVERSION ROUTINE'
**********************************************************************
*               G E T D S O R G        R O U T I N E                 *
*                                                                    *
*    THIS SUBROUTINE SIMPLY CONVERTS THE DS ORGANIZATION IN THE DSCB *
*    USING A TABLE LOOKUP INTO THE PRINTABLE 2-BYTE VERSION OF THE   *
*    DS ORG FOR PRINTING.                                            *
*       INPUT: DSORG IN BUF1+38                                      *
*       OUTPUT: PRINTABLE DSORG IN TABLE VARIABLE TBDSORG            *
*                                                                    *
**********************************************************************
         SPACE
         USING GETDSORG,BASE
GETDSORG DS@ENTR ,
         LA    R5,DSORGTBL          ADDRESS BEGINNING OF TABLE
GETDSOLP DS    0H
         CLI   0(R5),FLAGON         DO UNTIL END OF THE TABLE
         BE    GETDSORT
         CLC   0(1,R5),BUF1+38      IS THIS THE ONE?
         BE    GOTDSORG             Y.THEN SKIP
         LA    R5,3(R5)             ELSE NEXT DSORG TABLE ENTRY
         B     GETDSOLP             AND LOOP
GOTDSORG DS    0H
         MVC   TBDSORG,1(R5)      IF HERE, FOUND IT, SO MOVE TO TABLE
GETDSORT DS@EXIT ,
         SPACE
DSORGTBL DC    X'80',C'IS'
         DC    X'40',C'PS'
         DC    X'20',C'DA'
         DC    X'02',C'PO'
         DC    X'01',C'U '
         DC    AL1(FLAGON)
         SPACE
         DROP  BASE
         TITLE 'OBTAIN SHORT VERSION OF DATA SET NAME'
**********************************************************************
*               G E T D S N S H        R O U T I N E                 *
*                                                                    *
*    THIS SUBROUTINE SIMPLY BUILDS THE SHORT VERSION OF TBDSNAME,    *
*    PUTS IT IN THE TABLE VARIABLE TBDSNSH.  THE SHORT VERSION IS    *
*    SIMPLY THE LONG NAME MINUS THE GIVEN PREFIX.                    *
*       INPUT: TBDSNAME - FULL DATA SET NAME                         *
*       OUTPUT: TBDSNSH - DISPLAYABLE SHORT FORM OF TBDSNAME         *
*                                                                    *
**********************************************************************
         SPACE
         USING GETDSNSH,BASE
         SPACE
GETDSNSH DS@ENTR ,
         L     R5,GPREFL                 GET LENGTH OF PREFIX
         LA    R6,TBDSNAME               ADDRESS START OF TBDSNAME
         AR    R5,R6                     ADD TO GET BEG. OF SHORT FORM
         LA    R5,1(R5)                  +1 TO GET PASSED PERIOD
         LA    R7,44                     LOAD VALUE OF ENTIRE LENGTH
         S     R7,GPREFL                 SUBTRACT TO GET MOVE LENGTH
         SH    R7,=H'2'                  SUBTRACT TO GET EX LENGTH
         EX    R7,MOVEDSN                AND DO THE MOVE
GTDSNSHX DS    0H
         DS@EXIT ,
         SPACE
MOVEDSN  MVC   TBDSNSH(0),0(R5)        MVC FOR EXECUTE INSTRUCTION
         SPACE
         DROP  BASE
         TITLE 'PROCESS TABLE DISPLAY ROUTINE'
**********************************************************************
*              P R O C T B L        R O U T I N E                    *
*                                                                    *
*     THIS SUBROUTINE DISPLAYS THE TABLE BUILT ABOVE, AND PROCESSES  *
*   THE USER SELECTIONS FROM THE DISPLAY.  'END' FROM THE TBDISPL    *
*   (RC = 8) IS HOW WE EXIT THIS SUBROUTINE, AND THE PROGRAM ITSELF. *
*                                                                    *
**********************************************************************
         SPACE
         USING PROCTBL,BASE
         SPACE
PROCTBL  DS@ENTR ,
         MVI   ZCMDMRK,X'FF'          MARK END OF THIS FIELD
         MVI   SCRLLFLG,FLAGON        SCROLL IS TO THE LEFT
         MVC   RLSE(2),BLANKS         SET RLSE, PRTOPT TO BLANKS
         MVC   DSN1(INITV2L),BLANKS   SET ALL OF THESE TO BLANKS
         DEFINE DEFVTBL2,CRPL,CRP     DEFINE VARIABLES FOR TBDISPL
         LA    R1,TBDSNAME            SET UP DELETE CAMLST
         ST    R1,DELCAM+4
         ST    R1,UNCATCAM+4             AND UNCAT CAMLST
         ST    R1,CATCAM+4               AND CAT CAMLST
         LA    R1,VOLLIST
         ST    R1,CATCAM+12
         ST    R1,DELCAM+12
         ST    R1,RENCAM+12              AND RENAME CAMLST
         LA    R1,TBDSNAME            SET UP RENAME CAMLST
         ST    R1,RENCAM+4
         LA    R1,DSNSAVE
         ST    R1,RENCAM+8
         MVC   AUTOSEL,=CL3'NO'       INITIALIZE AUTOSEL FIELD
         MVC   ZTDMARK,ZTDMARKM       SET ZTDMARK VALUE
         LA    R2,ZTDMARKL            GET LENGTH
         LA    R3,ZTDMARK             ADDRESS VAR
         CALL  ISPLINK,(=CL8'VREPLACE',=C'(ZTDMARK)',(R2),(R3)),VL,    +
               VL,MF=(E,CALLPL)
         LA    R2,TBLNAME
         CALL  ISPLINK,(=CL8'TBTOP',(R2)),VL,MF=(E,CALLPL) ISSUE TBTOP
         CLI   TRACE,C'T'             IF TRACE NOT SPECIFIED, THEN
         BE    DSPLYTBL                 RETURN ERRORS TO US PLEASE
         CALL  ISPLINK,(=CL8'CONTROL',=CL8'ERRORS',=CL8'RETURN'),VL,   +
               MF=(E,CALLPL)
DSPLYTBL DS    0H
         CLI   RBLDFLAG,FLAGON        IF SWITCH COMMAND, THEN
         BE    TBLDONE                  GET OUT OF HERE
         XC    CALLPL(CALLPLL),CALLPL CLEAR THE PARM LIST
         MVC   SCRHORZ,=CL8'PASSTHRU' SET ACTION FOR COMMAND TABLE
         LA    R2,TBLNAME             ADDRESS TABLE NAME
         LA    R5,=CL8'DS@FLSTT'      ADDRESS PANEL NAME (LEFT)
         CLI   SCRLLFLG,FLAGON        IF SCROLLED TO RIGHT, THEN
         BE    *+8
         LA    R5,=CL8'DS@FLSTU'        ADDRESS PANEL NAME (RIGHT)
         LA    R3,CSR
         LA    R4,AUTOSEL               AND AUTOSEL
         CALL  ISPLINK,(=CL8'TBDISPL',(R2),(R5),,,(R3),,(R4),          +
               =CL8'CRP'),VL,MF=(E,CALLPL)
         ST    R15,RCSAVE             SAVE RETURN CODE FOR LATER
         MVC   SCRHORZ,BLANKS         SET ACTION FOR COMMAND TABLE
         MVC   SKIPNUM,ZTDTOP         COPY THIS FOR LATER
         MVC   SAVZCMD,ZCMD           SAVE ZCMD
         MVC   ZCMD,BLANKS            RESET ZCMD
         MVC   CSR,CRP                AND ALSO THIS
         NI    FLAGBYTE,255-(MANY+CMDZ+SKIPPUT) RESET THESE FLAGS
         CLC   RCSAVE,=F'0'           IF RC FROM TBDISPL = 0
         BE    BIGLOOP                  SKIP
         CLC   RCSAVE,=F'4'           IF RC FROM TBDISPL ^= 4
         BNE   TBLDONE                  THEN DONE
         OI    FLAGBYTE,MANY          INDICATE MANY TO PROCESS
BIGLOOP  DS    0H
         MVI   STAXFLAG,FLAGOFF       BE SURE THIS FLAG IS OFF
BGSKIP0  DS    0H
         L     R15,=A(TBLUPPER)       ADDRESS TRANSLATE TABLE
         TR    TBSEL,0(R15)           TRANSLATE TBSEL TO UPPER CASE
BGSKIP1  DS    0H
         CLI   TBSEL,C'L'             IF ^ LOCATE COMMAND, AND
         BE    BGSKIP5                  ^ NOOP COMMAND (BLANK), THEN
         CLI   TBSEL,C' '
         BE    BGSKIP5
         CLC   TBLSTRF,=C'NOT DISK'     IF DATASET NOT DISK, THEN
         BNE   BGSKIP2
         LA    R1,MSG18                   SET THE MESSAGE
         B     BGSKIP4                    GO SET IT AND QUIT
BGSKIP2  DS    0H
         CLC   TBLSTRF,=C'NOTFOUND'     IF DATASET NOT FOUND, THEN
         BNE   BGSKIP3
         LA    R1,MSG24                   SET THE MESSAGE
         B     BGSKIP4                    GO SET IT AND QUIT
BGSKIP3  DS    0H
         CLC   TBVOLSER,=C'DELETE'      IF DATASET DELETED, THEN
         BNE   BGSKIP5
         LA    R1,MSG13                   SET THE MESSAGE
BGSKIP4  DS    0H
         DO    PUTMSG                     GO GIVE IT TO ISPF
         NI    FLAGBYTE,255-MANY          TURN OFF MANY
         B     UPDTBL1                    AND SKIP
BGSKIP5  DS    0H
         MVC   TOKEN,BLANKS           BLANK OUT TOKEN
         MVC   TOKEN(1),TBSEL         MOVE SELECT CODE TO TOKEN
         NI    FLAGBYTE,255-CMDZ      INDICATE SELECT CODE, ^ ZCMD
         DO    GETCMD                 SEE IF COMMAND IS VALID
         LTR   R15,R15                IF R15 ^= 0 THEN
         BZ    BGBDCMD
         BALR  R14,R15                  GO PROCESS COMMAND
         LTR   R15,R15                  IF RETURN FROM COMMAND BAD,
         BNZ   SHOWTBL                    RESHOW
         B     UPDTBL                   ELSE CONTINUE
BGBDCMD  DS    0H
         MVC   AUTOSEL,=CL3'YES'      SET AUTOSEL TO YES
         NI    FLAGBYTE,255-MANY      TURN OFF MANY
         LA    R1,MSG9                SET THE MESSAGE
         DO    PUTMSG                 GO GIVE IT TO ISPF
         B     UPDTBL1                UPDATE TABLE AND DISPLAY IT
UPDTBL   DS    0H
         MVC   TBSEL,BLANKS           BLANK TABLE SELECTION
         MVC   AUTOSEL,=CL3'NO'       SET AUTOSEL TO NO
UPDTBL1  DS    0H
         DO    PUTTBL                 UPDATE THE TABLE
         TM    FLAGBYTE,MANY          Q.MORE TO PROCESS?
         BO    MORE                   Y.THEN SKIP
         DO    PROCZCMD               GO SEE IF ZCMD GIVEN
SHOWTBL  DS    0H
         LA    R2,TBLNAME             REPOSITION TABLE FOR DISPLAY
         CALL  ISPLINK,(=CL8'TBTOP',(R2)),VL,MF=(E,CALLPL)
         LA    R3,SKIPNUM
         CALL  ISPLINK,(=CL8'TBSKIP',(R2),(R3)),VL,MF=(E,CALLPL)
         B     DSPLYTBL               AND LOOP
*                                     MORE ENTRIES TO PROCESS
MORE     DS    0H
         CLI   STAXFLAG,FLAGON        IF ATTENTION KEY HIT, THEN
         BE    SHOWTBL                  GET OUT OF LOOP
         XC    CALLPL(CALLPLL),CALLPL CLEAR PARM LIST FOR CALL
         LA    R2,TBLNAME
         CALL  ISPLINK,(=CL8'TBDISPL',(R2),,,,,,,=CL8'CRP'),VL,        +
               MF=(E,CALLPL)
         MVC   CSR,CRP                  SAVE CRP VALUE
         LTR   R15,R15                IF STILL MORE THAN ONE TO PROC
         BNZ   BIGLOOP                  THEN CONTINUE
         NI    FLAGBYTE,255-MANY      ELSE INDICATE ONLY ONE LEFT
         B     BIGLOOP                  AND GO PROCESS IT
         SPACE
TBLDONE  DS    0H
         MVC   ZTDMARK,BLANKS         RESET ZTDMARK
         LA    R2,ZTDMARKL
         LA    R3,ZTDMARK
         CALL  ISPLINK,(=CL8'VREPLACE',=C'(ZTDMARK)',(R2),(R3)),VL,    +
               MF=(E,CALLPL)
         DS@EXIT ,
         SPACE
ZTDMARKM DC    C'***************************** END OF CATALOG LIST ****+
               *************************'
         DROP  BASE
         TITLE 'DS@FLSTC - EDIT/BROWSE COMMAND PROCESSORS'
**********************************************************************
*          E D I T      C O M M A N D     P R O C E S S O R          *
*                                                                    *
*     THIS ROUTINE PROCESSES THE EDIT COMMAND TO EDIT THE DATASET    *
*   LISTED IN THE TABLE.                                             *
*                                                                    *
**********************************************************************
         SPACE
         USING EDIT,R15
         SPACE
EDIT     DS    0H
         MVI   MODE,C'E'              BE SURE THIS IS EDIT
         L     R15,=A(SCPDS)
         BR    R15                    GO CALL DS@SCPDS
         LTORG
         DROP  R15
         SPACE 3
**********************************************************************
*        B R O W S E    C O M M A N D     P R O C E S S O R          *
*                                                                    *
*     THIS ROUTINE PROCESSES THE BROWSE COMMAND TO BROWSE THE DATA-  *
*   SET LISTED IN THE TABLE.                                         *
*                                                                    *
**********************************************************************
         SPACE
         USING BROWSE,R15
         SPACE
BROWSE   DS    0H
         MVI   MODE,C'B'              INDICATE THIS IS BROWSE
         L     R15,=A(SCPDS)
         BR    R15                    GO CALL DS@SCPDS
         LTORG
         DROP  R15
         SPACE 3
**********************************************************************
*        M E M L I S T  C O M M A N D     P R O C E S S O R          *
*                                                                    *
*     THIS ROUTINE PROCESSES THE MEMBER LIST COMMAND TO DISPLAY A    *
*   GENERAL PDS MEMBER LIST.                                         *
*                                                                    *
**********************************************************************
         SPACE
         USING MEMLIST,R15
         SPACE
MEMLIST  DS    0H
         MVI   MODE,C'M'              BE SURE THIS IS EDIT
         L     R15,=A(SCPDS)
         BR    R15                    GO CALL DS@SCPDS
         LTORG
         DROP  R15
         TITLE 'DS@FLSTC - INVOKE DS@SCPDS'
**********************************************************************
*                   I N V O K E     D S @ S C P D S                  *
*                                                                    *
*     THIS ROUTINE INVOKES THE PROGRAM DS@SCPDS TO DO THE RESPECTIVE *
*  BROWSE, EDIT OR PDS MEMBER LIST.                                  *
*                                                                    *
**********************************************************************
         SPACE
         USING SCPDS,BASE
         SPACE
SCPDS    DS@ENTR ,
         TM    FLAGBYTE,CMDZ          IF COMING FROM ZCMD,
         BZ    SCPDS20
         DO    GETTOKEN                 GO GET A OPERAND (DSNAME)
         LTR   R1,R1                    IF NOT GIVEN, THEN
         BNZ   SCPDS10
         LA    R1,MSG14                   SET THE MESSAGE
         DO    PUTMSG                     GIVE IT TO ISPF
         LA    R15,4                      SET RETURN CODE
         B     SCPDSX                     AND WE'RE DONE
SCPDS10  DS    0H                       ELSE
         MVC   TBDSNSH,TOKEN              MOVE IN OPERAND
         DO    FNDSNAME                   GO SEE IF DSNAME IN TABLE
         LTR   R15,R15                    IF NOT IN TABLE
         BZ    SCPDS20
         LA    R1,MSG15                     SET THE MESSAGE
         DO    PUTMSG                       GIVE IT TO ISPF
         LA    R15,4                        SET RETURN CODE
         B     SCPDSX                       AND WE'RE DONE
SCPDS20  DS    0H                         ELSE
         MVC   DSN1,TBDSNAME                MOVE IN DSNAME
         MVC   VOL1,TBVOLSER                MOVE IN VOLUME
         MVC   DSN2,BLANKS                  RESET
         MVC   DSN3,BLANKS                    ALL
         MVC   DSN4,BLANKS                      OF THESE
         MVC   MEMBER,TBMEM                 SET MEMBER NAME FROM PANEL
         MVC   USERID,BLANKS
         MVI   USEROP,C'N'
         MVI   SCOP,C'N'
         LA    R2,VPUTVARS
         CALL  ISPLINK,(=CL8'VPUT',(R2),=CL8'SHARED'),VL,MF=(E,CALLPL)
         CALL  ISPLINK,(=CL8'CONTROL',=CL8'DISPLAY',=CL8'SAVE'),VL,    +
               MF=(E,CALLPL)
         CALL  ISPLINK,(=CL8'SELECT',=F'13',=CL13'PGM(DS@SCPDS)'),VL,  +
               MF=(E,CALLPL)
         ST    R15,RCSAVE                   SAVE RETURN CODE
         CALL  ISPLINK,(=CL8'CONTROL',=CL8'DISPLAY',=CL8'RESTORE'),    +
               VL,MF=(E,CALLPL)
         DO    SETATTN                RESET ATTENTION EXIT
         MVC   DSN1,BLANKS                  RESET THIS GUY
         CALL  ISPLINK,(=CL8'VPUT',=CL8'(DS@DSN1)',=CL8'SHARED'),VL,   +
               MF=(E,CALLPL)
         MVC   TBMEM,BLANKS           RESET MEMBER NAME
         CLI   DFORM,C'S'             IF NOT 'SHORT' FORM, THEN
         BE    SCPDSX
         MVC   TBLSTRF,TDATE            MOVE NEW DATE LAST REF INFO
         LTR   R15,R15                  IF RETURN CODE ZERO,
         BNZ   SCPDSX
         DO    GETNSPC                    GO GET NEW ALLOC. SPACE INFO
SCPDSX   DS    0H
         SLR   R15,R15                CLEAR RETURN CODE
         DS@EXIT RET=R15
         SPACE
VPUTVARS DC    C'(DS@DSN1 DS@DSN2 DS@DSN3 DS@DSN4 DS@MEM DS@UOP DS@USER+
                 DS@VOL DS@MODE DS@SCOP)'
         SPACE
         DROP  BASE
         TITLE 'DS@FLSTC - RENAME'
**********************************************************************
*         R E N A M E    C O M M A N D    P R O C E S S O R          *
*                                                                    *
*     THIS ROUTINE PROCESSES THE RENAME COMMAND.  WE FIRST DISPLAY   *
*  THE PANEL FOR THE USER TO ENTER THE NEW NAME.  IF ENTER IS HIT,   *
*  THEN WE BUILD THE NEW DATASET NAME AND ISSUE THE RENAME.          *
*                                                                    *
**********************************************************************
         SPACE
         USING RENAME,BASE
         SPACE
RENAME   DS@ENTR ,
         TM    FLAGBYTE,GENERIC      IF GENERIC PREFIX, THEN
         BZ    RENAME00                 RENAME NOT ALLOWED
         LA    R1,MSG35                 SET MESSAGE NUMBER
         DO    PUTMSG                   GIVE IT TO ISPF
         LA    R15,4                    SET RETURN CODE
         B     RENAMEX                  AND WE'RE DONE
RENAME00 DS    0H
         TM    FLAGBYTE,CMDZ          IF COMING FROM ZCMD,
         BZ    RENAME20
         DO    GETTOKEN                 GO GET A OPERAND (DSNAME)
         LTR   R1,R1                    IF NOT GIVEN, THEN
         BNZ   RENAME10
         LA    R1,MSG14                   SET THE MESSAGE
         DO    PUTMSG                     GIVE IT TO ISPF
         LA    R15,4                      SET RETURN CODE
         B     RENAMEX                    AND WE'RE DONE
RENAME10 DS    0H                       ELSE
         MVC   TBDSNSH,TOKEN              MOVE IN OPERAND
         DO    FNDSNAME                   GO SEE IF DSNAME IN TABLE
         LTR   R15,R15                    IF NOT IN TABLE
         BZ    RENAME20
         LA    R1,MSG15                     SET THE MESSAGE
         DO    PUTMSG                       GIVE IT TO ISPF
         LA    R15,4                        SET RETURN CODE
         B     RENAMEX                      AND WE'RE DONE
RENAME20 DS    0H                         ELSE SHOW CONFIRM PANEL
         CLC   TBVOLSER,=C'MULTI '          IF MULTI VOLUME DS, THEN
         BNE   RENAME30
         LA    R1,MSG25                       SET THE MESSAGE
         DO    PUTMSG                         GIVE IT TO ISPF
         LA    R15,4                          SET RETURN CODE
         B     RENAMEX                        AND WE'RE DONE
RENAME30 DS    0H                         ELSE SHOW CONFIRM PANEL
         MVC   DSNSHSV(44),TBDSNSH          SAVE DATASET NAME
         CALL  ISPLINK,(=CL8'CONTROL',=CL8'DISPLAY',=CL8'SAVE'),VL,    +
               MF=(E,CALLPL)
         CALL  ISPLINK,(=CL8'DISPLAY',=CL8'DS@FLSTR'),VL,MF=(E,CALLPL)
         ST    R15,RCSAVE                   SAVE RETURN CODE
         CALL  ISPLINK,(=CL8'CONTROL',=CL8'DISPLAY',=CL8'RESTORE'),VL, +
               MF=(E,CALLPL)
         L     R15,RCSAVE                   RESTORE RC FROM DISPLAY
         LTR   R15,R15                      IF RC ^= 0,
         BZ    RENAMIT
         SLR   R15,R15                        CLEAR RC
         B     RENAMEX                        AND DONE
RENAMIT  DS     0H                          ELSE (RC = 0)
         CATALOG UNCATCAM                     UNCATALOG THE DS
         MVC   DSNSAVE,BLANKS                 BLANK THIS AREA
         MVC   DSNSAVE,PREFIX                 BUILD NEW DATASET NAME
         LA    R1,DSNSAVE
         A     R1,PREFIXL
         MVI   0(R1),C'.'
         LA    R1,1(,R1)
         LA    R2,TBDSNSH
         LR    R3,R2
RENAMELP DS    0H
         CLI   0(R2),C' '
         BE    RENAMLPX
         LA    R2,1(R2)
         B     RENAMELP
RENAMLPX DS    0H
         SR    R2,R3
         BCTR  R2,0
         EX    R2,MVNEWNM
         MVC   VOLDEVT,TBDEVT                 SET DEVICE TYPE
         MVC   VOLNUM,=H'1'                   SET NUMBER OF VOLUMES
         MVC   VOLVOLS,TBVOLSER               MOVE VOLSER TO VOLLIST
         XC    VOLSTCD,VOLSTCD                RESET THIS FIELD
         RENAME RENCAM                        ISSUE THE RENAME
         SLR   R2,R2                          CLEAR FOR IC
         IC    R2,VOLSTCD+1                   GET STATUS CODE
         LTR   R2,R2                          IF STATUS CODE ^ 0,
         BZ    RENAME50
         LA    R1,MSG26                         ASSUME IN USE
         CH    R2,=H'7'                         IF NOT IN USE, THEN
         BE    RENAME40
         LA    R1,MSG29                           TRY RACF FAILURE
         CH    R2,=H'8'                           IF NOT RACF, THEN
         BE    RENAME40
         LA    R1,MSG12                             TRY ALREADY EXISTS
         CH    R2,=H'3'                             IF NOT THIS, THEN
         BE    RENAME40
         LA    R1,MSG30                               GENERIC MESSAGE
RENAME40 DS    0H
         DO    PUTMSG                           GO SET THE MESSAGE
         CATALOG CATCAM                         RECATALOG THE DS
         MVC   TBDSNSH,DSNSHSV                  RESTORE OLD NAME
         LA    R15,4                            SET RETURN CODE
         B     RENAMEX                          AND GET OUT OF HERE
RENAME50 DS    0H                             ELSE
         LA    R1,MSG7                          SET INFO MESSAGE NUMBER
         DO    PUTMSG                           GO SET THE MESSAGE
         MVC   TBDSNAME,DSNSAVE                 SAVE NEW NAME
         CATALOG CATCAM                         CATALOG THE NEW DS
         SLR   R15,R15                          CLEAR FOR RETURN
RENAMEX  DS    0H
         DS@EXIT RET=R15
         SPACE
MVNEWNM  MVC   0(0,R1),TBDSNSH
         SPACE
         DROP   BASE
         TITLE 'DS@FLSTC - DELETE'
**********************************************************************
*         D E L E T E    C O M M A N D    P R O C E S S O R          *
*                                                                    *
*     THIS ROUTINE PROCESSES THE DELETE COMMAND.  WE FIRST DISPLAY   *
*  THE PANEL FOR THE USER TO CONFIRM THE DELETE.  IF ENTER IS HIT,   *
*  THEN WE ISSUE THE SCRATCH TO DELETE THE DATASET.                  *
*                                                                    *
**********************************************************************
         SPACE
         USING DELETE,BASE
         SPACE
DELETE   DS@ENTR ,
         TM    FLAGBYTE,CMDZ          IF COMING FROM ZCMD,
         BZ    DELETE20
         DO    GETTOKEN                 GO GET A OPERAND (DSNAME)
         LTR   R1,R1                    IF NOT GIVEN, THEN
         BNZ   DELETE10
         LA    R1,MSG14                   SET THE MESSAGE
         DO    PUTMSG                     GIVE IT TO ISPF
         LA    R15,4                      SET RETURN CODE
         B     DELETEX                    AND WE'RE DONE
DELETE10 DS    0H                       ELSE
         MVC   TBDSNSH,TOKEN              MOVE IN OPERAND
         DO    FNDSNAME                   GO SEE IF DSNAME IN TABLE
         LTR   R15,R15                    IF NOT IN TABLE
         BZ    DELETE20
         LA    R1,MSG15                     SET THE MESSAGE
         DO    PUTMSG                       GIVE IT TO ISPF
         LA    R15,4                        SET RETURN CODE
         B     DELETEX                      AND WE'RE DONE
DELETE20 DS    0H                         ELSE SHOW CONFIRM PANEL
         CLC   TBVOLSER,=C'MULTI '          IF MULTI VOLUME DS, THEN
         BNE   DELETE30
         LA    R1,MSG25                       SET THE MESSAGE
         DO    PUTMSG                         GIVE IT TO ISPF
         LA    R15,4                          SET RETURN CODE
         B     DELETEX                        AND WE'RE DONE
DELETE30 DS    0H                         ELSE
         CLI   CONFIRM,C'N'                IF CONFIRM OFF, THEN
         BE    DELETIT                       DON'T SHOW CONFIRM PANEL
         CALL  ISPLINK,(=CL8'CONTROL',=CL8'DISPLAY',=CL8'SAVE'),VL,    +
               MF=(E,CALLPL)
         CALL  ISPLINK,(=CL8'DISPLAY',=CL8'DS@FLSTD'),VL,MF=(E,CALLPL)
         ST    R15,RCSAVE                   SAVE RC FROM DISPLAY
         CALL  ISPLINK,(=CL8'CONTROL',=CL8'DISPLAY',=CL8'RESTORE'),VL, +
               MF=(E,CALLPL)
         L     R15,RCSAVE                   RESTORE RC FROM DISPLAY
         LTR   R15,R15                      IF RC ^= 0,
         BZ    DELETIT
         SLR   R15,R15                        CLEAR RC
         B     DELETEX                        AND LEAVE
DELETIT  DS    0H                           ELSE (RC = 0)
         MVC   VOLDEVT,TBDEVT                 SET DEVICE TYPE
         MVC   VOLNUM,=H'1'                   SET NUMBER OF VOLUMES
         MVC   VOLVOLS,TBVOLSER               MOVE VOLSER TO VOLLIST
         XC    VOLSTCD,VOLSTCD                RESET THIS FIELD
         SCRATCH DELCAM                       ISSUE THE SCRATCH
         SLR   R2,R2                          CLEAR FOR IC
         IC    R2,VOLSTCD+1                   GET STATUS CODE
         LTR   R2,R2                          IF STATUS CODE ^ 0,
         BZ    DELETE50
         LA    R1,MSG26                         ASSUME IN USE
         CH    R2,=H'7'                         IF NOT IN USE, THEN
         BE    DELETE40
         LA    R1,MSG27                           TRY RACF FAILURE
         CH    R2,=H'8'                           IF NOT RACF, THEN
         BE    DELETE40
         LA    R1,MSG28                             GENERIC MESSAGE
DELETE40 DS    0H
         DO    PUTMSG                           GO SET THE MESSAGE
         LA    R15,4                            SET RETURN CODE
         B     DELETEX                          AND GET OUT OF HERE
DELETE50 DS    0H
         MVC   TBCRTED(TBDELBLK),BLANKS  ELSE BLANK TABLE ENTRY
         MVC   TBVOLSER,=C'DELETE'          SAY "DELETE"
         CATALOG UNCATCAM                   UNCATALOG THE DS
         LA    R1,MSG4                      SET INFO MESSAGE
         DO    PUTMSG
         SLR   R15,R15
DELETEX  DS@EXIT RET=R15
         SPACE
         DROP   BASE
         TITLE 'DS@FLSTC - COMPRESS'
**********************************************************************
*      C O M P R E S S   C O M M A N D    P R O C E S S O R          *
*                                                                    *
*     THIS ROUTINE PROCESSES THE COMPRESS COMMAND, BY SIMPLY         *
*  BUILDING THE PARM BLOCK FOR THE COMPRESS PROGRAM, AND CALLING     *
*  IT.                                                               *
*                                                                    *
**********************************************************************
         SPACE
         USING COMPRESS,BASE
         SPACE
COMPRESS DS@ENTR ,
         TM    FLAGBYTE,CMDZ          IF COMING FROM ZCMD,
         BZ    COMPRS20
         DO    GETTOKEN                 GO GET A OPERAND (DSNAME)
         LTR   R1,R1                    IF NOT GIVEN, THEN
         BNZ   COMPRS10
         LA    R1,MSG14                   SET THE MESSAGE
         DO    PUTMSG                     GIVE IT TO ISPF
         LA    R15,4                      SET RETURN CODE
         B     COMPRSX                    AND WE'RE DONE
COMPRS10 DS    0H                       ELSE
         MVC   TBDSNSH,TOKEN              MOVE IN OPERAND
         DO    FNDSNAME                   GO SEE IF DSNAME IN TABLE
         LTR   R15,R15                    IF NOT IN TABLE
         BZ    COMPRS20
         LA    R1,MSG15                     SET THE MESSAGE
         DO    PUTMSG                       GIVE IT TO ISPF
         LA    R15,4                        SET RETURN CODE
         B     COMPRSX                      AND WE'RE DONE
COMPRS20 DS    0H                         ELSE SEE IF AUTHORIZED
*        CLC   TBDSORG,=CL4'PO'         IF DSORG IS NOT PO OR
*        BE    COMPRS25                     PS, THEN
*        CLC   TBDSORG,=CL4'PS'
*        BE    COMPRS25
*        LA    R1,MSG11                   SET MESSAGE NUMBER
*        DO    PUTMSG                     GO SET THE MESSAGE
*        LA    R15,4                      SET RETURN CODE
*        B     COMPRSX                    AND GET OUT OF HERE
*COMPRS25 DS    0H                       ELSE SEE IF AUTHORIZED
         LA    R2,TBDSNAME
         LA    R3,TBVOLSER
         MVC   RACHKPL(RACHKML),RACHKM MOVE IN PARM LIST MASK
         RACHECK ENTITY=((R2)),VOLSER=(R3),ATTR=UPDATE,DSTYPE=N,       +
               CLASS=RACFDS,MF=(E,RACHKPL)
         LTR   R15,R15                      IF RACF CHECK FAILS, THEN
         BZ    COMPRS30
         LA    R1,MSG31                       SET MESSAGE NUMBER
         DO    PUTMSG                         GO SET THE MESSAGE
         LA    R15,4                          SET RETURN CODE
         B     COMPRSX                        AND GET OUT OF HERE
COMPRS30 DS    0H                         SHOW CONFIRM PANEL
         CALL  ISPLINK,(=CL8'CONTROL',=CL8'DISPLAY',=CL8'SAVE'),VL,    +
               MF=(E,CALLPL)
         CALL  ISPLINK,(=CL8'DISPLAY',=CL8'DS@FLSTC'),VL,MF=(E,CALLPL)
         ST    R15,RCSAVE                 SAVE RC FROM DISPLAY
         CALL  ISPLINK,(=CL8'CONTROL',=CL8'DISPLAY',=CL8'RESTORE'),VL, +
               MF=(E,CALLPL)
         L     R15,RCSAVE                 RESTORE RC FROM DISPLAY
         LTR   R15,R15                    IF RC ^= 0,
         BZ    COMPRSIT
         SLR   R15,R15                      CLEAR RC
         B     COMPRSX                      AND DONE
COMPRSIT DS    0H                         ELSE (RC = 0)
         CLC   TBDSORG,=CL4'PS'             IF DSORG IS PS, AND
         BNE   COMPRS27
         CLI   RLSE,C'Y'                        RELEASE NOT SPECIFIED,
         BNE   COMPRSX                        NOTHING TO DO
COMPRS27 DS    0H                           ELSE
         MVC   CPRDSNAM,TBDSNAME            MOVE DSNAME TO PARM BLOCK
         MVC   CPRRLSE,RLSE                 MOVE IN RELEASE OPTION
         MVC   CPRMSGS,PRTOPT               MOVE IN MSGS OPTION
         CALL  DS@CMPRS,(DS@CPRPB),VL,MF=(E,CALLPL) CALL THE PROGRAM
         LTR   R15,R15                      IF RC = 0, THEN
         BNZ   COMPRSER
         CLI   DFORM,C'S'                     IF ^ 'SHORT' FORM, THEN
         BE    COMPSHRT
         DO    GETNSPC                          GET ALLOC. SPACE INFO
         MVC   TBLSTRF,TDATE                    SET DATE LAST REF INFO
COMPSHRT DS    0H                           ELSE
         LA    R1,MSG5                        SAY "COMPRESSED"
         CLC   TBDSORG,=CL4'PS'               IF DSORG WAS PS,
         BNE   *+4+4
         LA    R1,MSG32                         SAY "RELEASED"
         DO    PUTMSG                         GO SET THE MESSAGE
         SLR   R15,R15                        CLEAR RC
         B     COMPRSX                        AND WE'RE DONE
COMPRSER DS    0H                           ELSE
         SLR   R2,R2                          READY TO SET ERR MESSAGE
         IC    R2,0(R15)                      GET LENGTH OF MESSAGE
         BCTR  R2,0                           GET EX LENGTH
         EX    R2,MVERRMSG                    MOVE TO ERROR MESSAGE
         LA    R2,=AL4(ERFIELDL)
         LA    R3,ERRFIELD
         CALL  ISPLINK,(=CL8'VREPLACE',=C'(ERRFIELD)',(R2),(R3)),VL,   +
               MF=(E,CALLPL)
         LA    R1,MSG20                       SET MESSAGE NUMBER
         DO    PUTMSG                         GO SET THE MESSAGE
         LA    R15,4                          SET RETURN CODE
COMPRSX  DS    0H
         DS@EXIT RET=R15
         SPACE
MVERRMSG MVC   ERRFIELD(0),1(R15)
         SPACE
RACHKM   RACHECK ENTITY=0,VOLSER=0,ATTR=UPDATE,DSTYPE=N,MF=L
RACHKML  EQU   *-RACHKM               LENGTH OF ABOVE
         SPACE
RACFDS   DC    AL1(8),CL8'DATASET'
         SPACE
         DROP  BASE
         TITLE 'SORT - PROCESS SORT COMMAND'
**********************************************************************
*                 S O R T           R O U T I N E                    *
*                                                                    *
*     THIS ROUTINE PROCESSES THE SORT COMMAND ENTERED FROM THE       *
*   COMMAND LINE (ZCMD).  ONLY THE FIRST TWO SORT OPERANDS THAT ARE  *
*   SORT FIELDS ARE PROCESSED, THE REST ARE IGNORED.                 *
**********************************************************************
         SPACE
         USING SORT,BASE
         SPACE
SORT     DS@ENTR ,
         MVC   TBSRTBUF(TBSRBUFL),TBSRTBFM SET MASK
         MVC   NAMETBL,TBLNAME        SET TABLE NAME FOR SORT
         MVI   SORTOP1,C'A'           SET DEFAULT SORT OPTIONS
         MVC   SORTFLD2+8(4),=C',C,A'
         DO    GETTOKEN               GO GET 1ST OPERAND
         LTR   R1,R1
         BNZ   SORTSK1
         MVC   SORTFLD1,=CL8'TBDSNSH'   DEFAULT IS SORT BY MEMBER
         MVC   SORTOP1+1(13),BLANKS
         B     SORTIT
SORTSK1  DS    0H
         DO    GETSRTOP               ELSE GO GET SORT OPTION 1
         LTR   R1,R1                  IF RETURN IS BAD, THEN
         BNZ   SORTSK1A
         LA    R1,MSG21                 SET MESSAGE NUMBER
         DO    PUTMSG                   SET ISPF MESSAGE
         B     SORTX                    AND GET OUT OF HERE
SORTSK1A DS    0H
         MVC   SORTFLD1,0(R1)         MOVE IN SORT OPTION
         DO    GETTOKEN               GO GET NEXT ONE
         LTR   R1,R1
         BNZ   SORTSK2
         MVC   SORTOP1+1(13),BLANKS THEN WE ARE FINISHED
         B     SORTIT
SORTSK2  DS    0H
         DO    GETSRTOP               GO SEE IF SORT FIELD
         LTR   R1,R1                  IF NOT SORT FIELD, THEN
         BNZ   SORTSK4
         CLC   TOKEN(2),=C'A '        IF ASCENDING OPTION, THEN
         BE    SORTSK3                  WE ALREADY HAVE IT
         CLC   TOKEN(2),=C'D '        IF ^ DESCENDING OPTION, THEN
         BNE   SORTSK5                  THIS IS AN ERROR
         MVI   SORTOP1,C'D'           ELSE SAY WE HAVE DESCENDING
         B     SORTSK3                AND TRY NEXT ONE
SORTSK5  DS    0H
         LA    R1,MSG21                 SET MESSAGE NUMBER
         DO    PUTMSG                 ERROR MESSAGE FOR ISPF
         B     SORTX                  AND GET OUT OF HERE
SORTSK4  DS    0H
         MVC   SORTFLD2,0(R1)         MOVE IN SORT OPTION
         DO    GETTOKEN               GO GET NEXT TOKEN
         LTR   R1,R1                  IF NOTHING, THEN
         BZ    SORTIT                   WE ARE FINISHED
         CLC   TOKEN(2),=C'A '        IF ASCENDING OPTION, THEN
         BE    SORTIT                   WE ALREADY HAVE IT
         CLC   TOKEN(2),=C'D '        IF ^ DESCENDING OPTION, THEN
         BNE   SORTIT                   IGNORE THIS ONE
         MVI   SORTOP2,C'D'           ELSE SAY WE HAVE DESCENDING
         B     SORTIT                   AND WE ARE DONE
SORTSK3  DS    0H
         DO    GETTOKEN               GO GET NEXT TOKEN
         LTR   R1,R1                  IF TOKEN, THEN
         BNZ   SORTSK7                  SKIP
         MVC   SORTFLD2+8(4),BLANKS   ELSE BLANK OUT SORTOP 2 STUFF
         B     SORTIT                 AND NOW WE'RE READY
SORTSK7  DS    0H
         DO    GETSRTOP               GO SEE IF SORT FIELD
         LTR   R1,R1                  IF NOT SORT FIELD, THEN
         BNZ   SORTSK4
         LA    R1,MSG21                 SET MESSAGE NUMBER
         DO    PUTMSG                   GIVE IT TO ISPF
         B     SORTX                    AND GET OUT OF HERE
SORTIT   DS    0H
         LA    R1,TBSRBUFL            GET BUFFER LENGTH
         ST    R1,TBSRTBFL            SAVE IN DSA
         LA    R2,TBSRTBFL            ADDRESS BUFFER LENGTH
         LA    R3,TBSRTBUF
         CALL  ISPEXEC,((R2),(R3)),VL,MF=(E,CALLPL) TBSORT IT
         XC    SKIPNUM,SKIPNUM        CLEAR SKIPNUM
SORTX    DS    0H
         DS@EXIT ,
         SPACE
         DROP  BASE
         TITLE 'GETSRTOP - GET SORT FIELD/OPERAND'
**********************************************************************
*              G E T S R T O P      R O U T I N E                    *
*                                                                    *
*     THIS ROUTINE DETERMINES IF TOKEN IS A VALID SORT FIELD.  IF IT *
*   IS, THEN REGISTER 1 IS SET TO POINT TO THE CORRESPONDING TABLE   *
*   VARIABLE NAME TO BE USED AS A SORT FIELD.  IF TOKEN IS NOT A     *
*   VALID SORT FIELD, THEN R1 IS RETURNED AS ZERO.                   *
*                                                                    *
**********************************************************************
         SPACE
         USING GETSRTOP,BASE
         SPACE
GETSRTOP DS@ENTR ,
         LA    R0,SRFLDTB#            GET NUMBER OF TABLE ELEMENTS
         LA    R6,SRTFLDTB            ADDRESS START OF TABLE
         SLR   R1,R1                  ASSUME WE WON'T FIND IT
GETSRTLP DS    0H
         CLC   TOKEN(8),0(R6)         IF IN TABLE, THEN
         BE    GETSRTIT                 GET OUT OF LOOP
         BL    GETSRTEX               IF OUT OF ORDER, THEN DONE
         LA    R6,16(,R6)             ELSE NEXT TABLE ELEMENT
         BCT   R0,GETSRTLP            AND LOOP
         B     GETSRTEX               IF HERE, DIDN'T FIND IT
GETSRTIT DS    0H
         LA    R1,8(,R6)              IF HERE, FOUND, SO PRIME R1
GETSRTEX DS@EXIT RET=R1
         SPACE
SRTFLDTB DS    0H                     THIS TABLE MUST BE SORTED
         DC    CL8'%USED   ',CL8'TBPCUSED'    BASED ON THE 1ST CL8
         DC    CL8'BLKSIZE ',CL8'TBBLKSZ '
         DC    CL8'CREATED ',CL8'TBCRTED '
         DC    CL8'DEVICE  ',CL8'TBDEVT  '
         DC    CL8'DSNAME  ',CL8'TBDSNSH '
         DC    CL8'EXPIRES ',CL8'TBEXPDT '
         DC    CL8'LASTREF ',CL8'TBLSTRF '
         DC    CL8'LRECL   ',CL8'TBLRECL '
         DC    CL8'ORG     ',CL8'TBDSORG '
         DC    CL8'RECFM   ',CL8'TBRECFM '
         DC    CL8'TRKS    ',CL8'TBALC   '
         DC    CL8'VOLUME  ',CL8'TBVOLSER'
         DC    CL8'XT      ',CL8'TBEXTNTS'
SRFLDTB# EQU   (*-SRTFLDTB)/16
         SPACE
         DROP  BASE
         SPACE
TBSRTBFM DC    CL60' '
         ORG   TBSRTBFM
         DC    CL8'TBSORT '
         DC    CL8'        '
         DC    C' FIELDS('
         DC    CL8' '
         DC    C',C,'
         DC    C'A'
         DC    C','
         DC    CL8' '
         DC    C',C,'
         DC    C'A'
         DC    C')'
         ORG
TBSRBUFL EQU   *-TBSRTBFM
         TITLE 'DS@FLSTC - LOCATE COMMAND PROCESSOR'
**********************************************************************
*         L O C A T E    C O M M A N D    P R O C E S S O R          *
*                                                                    *
*     THIS ROUTINE PROCESSES THE LOCATE COMMAND.  IF THE COMMAND HAS *
*   COME FROM ZCMD RATHER THAN THE SELECT CODE, IT CALLS GETTOKEN    *
*   TO GET THE DATASET NAME. IF NOT GIVEN, AN ERROR MESSAGE IS SET.  *
*   IF GIVEN, AN ISPF TBSARG IS DONE, THEN A TBSCAN TO ACTUALLY      *
*   LOCATE THIS TABLE ELEMENT.  IF IT IS NOT FOUND, AN ERROR MESSAGE *
*   IS SET.  IF FOUND, THEN A TBQUERY IS DONE TO GET THE CRP, AND    *
*   SKIPNUM IS RESET TO THE CRP, SO THAT WHEN THE TABLE IS REDIS-    *
*   PLAYED, THIS ROW WILL BE THE FIRST ROW.                          *
**********************************************************************
         SPACE
         USING LOCATE,BASE
         SPACE
LOCATE   DS@ENTR ,
         TM    FLAGBYTE,CMDZ          IF NOT ZCMD, THEN WE CAN
         BZ    LOCATIT                   SKIP THIS
         DO    GETTOKEN               GO GET DDNAME NAME
         LR    R6,R1                    COPY LENGTH RETURNED
         LTR   R1,R1                    THEN THIS IS AN ERROR
         BNZ   OKLOCMEM
         LA    R1,MSG14                 SET THE MESSAGE
         DO    PUTMSG                   LET ISPF SET IT
         LA    R15,4                    SET RETURN CODE
         B     LOCATEX                  AND GET OUT OF HERE
OKLOCMEM DS    0H
         BCTR  R6,0                   DECREMENT FOR EX INSTRUCTION
         MVC   TBDSNSH,BLANKS         BLANK OUT SHORT DSNAME
         EX    R6,MVCDSNSH            MOVE SHORT DSNAME TO TBVAR
         CH    R6,=H'43'              IF TOKLNG < 43 THEN
         BL    TOKLNGB7
         MVI   TBDSNSH+43,C'*'        ELSE PUT * AT END
         B     LOCATIT
TOKLNGB7 DS    0H
         LA    R7,TBDSNSH+1             CALCULATE ADDR TO PUT *
         AR    R7,R6
         MVI   0(R7),C'*'             MOVE IN * AT PROPER PLACE
LOCATIT  DS    0H
         DO    FNDSNAME               GO FIND IT IN THE TABLE
         LTR   R15,R15                IF FOUND, THEN
         BZ    LOCATED                  GET CRP
         LA    R1,MSG15                 SET THE MESSAGE
         DO    PUTMSG                   LET ISPF SET IT
         B     LOCATEX
LOCATED  DS    0H
         XC    CALLPL(CALLPLL),CALLPL CLEAR CALL PARM LIST
         CALL  ISPLINK,(=CL8'TBQUERY',(R2),,,,,,=CL8'CRP'),VL,         +
               MF=(E,CALLPL)
         MVC   SKIPNUM,CRP              STORE IN SKIPNUM FOR LATER
LOCATEX  DS@EXIT RET=R15
         SPACE
MVCDSNSH MVC   TBDSNSH(0),TOKEN       EX SKELETON
         SPACE
         DROP  BASE
         TITLE 'STACK - PROCESS STACK COMMAND'
**********************************************************************
*           S T A C K    C O M M A N D    P R O C E S S O R          *
*                                                                    *
*     THIS COMMAND PROCESSES THE STACK COMMAND, WHICH SETS UP A      *
*   RECURSIVE INVOCATION OF THIS PROGRAM IN ORDER TO STACK CATALOG   *
*   LISTS.                                                           *
*                                                                    *
**********************************************************************
         SPACE
         USING STACK,BASE
         SPACE
STACK    DS    0H
         DS@ENTR ,
         DO    GETTOKEN               GO SEE IF NEW PREFIX ENTERED
         LTR   R1,R1                  IF NOTHING ENTERED, THEN
         BNZ   STACK10
         LA    R1,MSG34                 SET ERROR MESSAGE
         DO    PUTMSG                   GO PUT THE MESSAGE
         B     STACKX                   AND WE'RE DONE
STACK10  DS    0H
         MVC   SAVPREF,PREFIX         SAVE CURRENT CATALOG PREFIX
         MVC   SAVPREFL,PREFIXL       SAVE CURRENT CATALOG PREFIX LNG
         MVC   PREFIX,TOKEN           MOVE IN VALUE RETURNED
         ST    R1,PREFIXL             SAVE LENGTH
         MVI   SAVDFORM,C' '          SET TO BLANK
         DO    GETTOKEN               GO SEE SHORT OR LONG OPERAND
         LTR   R1,R1                  IF OPERAND, THEN
         BZ    STACK20
         MVC   SAVDFORM,DFORM           SAVE CURRENT DFORM
         MVC   DFORM,TOKEN              ASSUME IT'S VALID
         CALL  ISPLINK,(=CL8'VREPLACE',=CL8'(DFORM)',=F'1',DFORM),VL,  +
               MF=(E,CALLPL)            REPLACE IN FUNCTION POOL
STACK20  DS    0H
         CALL  ISPLINK,(=CL8'VREPLACE',=CL8'(PREFIX)',PREFIXL,PREFIX), +
               VL,MF=(E,CALLPL)
         CALL  ISPLINK,(=CL8'VPUT',=C'(PREFIX DFORM)',=CL8'SHARED'),   +
               VL,MF=(E,CALLPL)
         CALL  ISPLINK,(=CL8'SELECT',=F'13',=C'PGM(DS@FLSTC)'),VL,     +
               MF=(E,CALLPL)
         MVC   PREFIX,SAVPREF         RESTORE CURRENT CATALOG PREFIX
         MVC   PREFIXL,SAVPREFL       RESTORE CURRENT CAT. PREFIX LNG
         CALL  ISPLINK,(=CL8'VREPLACE',=CL8'(PREFIX)',PREFIXL,PREFIX), +
               VL,MF=(E,CALLPL)
         CLI   SAVDFORM,C' '          IF NEW DFORM SPECIFIED, THEN
         BE    STACK30
         MVC   DFORM,SAVDFORM           RESTORE OLD VALUE
         CALL  ISPLINK,(=CL8'VREPLACE',=CL8'(DFORM)',=F'1',DFORM),VL,  +
               MF=(E,CALLPL)            REPLACE IN FUNCTION POOL
STACK30  DS    0H
         CALL  ISPLINK,(=CL8'VPUT',=CL8'(PREFIX DFORM)',=CL8'SHARED'), +
               VL,MF=(E,CALLPL)
STACKX   DS    0H
         DS@EXIT RET=R15
         SPACE
         DROP  BASE
         TITLE 'SWITCH - PROCESS SWITCH COMMAND'
**********************************************************************
*         S W I T C H    C O M M A N D    P R O C E S S O R          *
*                                                                    *
*     THIS COMMAND PROCESSES THE SWITCH COMMAND, WHICH IS USED TO    *
*   END THE CURRENT CATALOG LIST AND TO DISPLAY A NEW ONE WITH THE   *
*   GIVEN PREFIX.                                                    *
*                                                                    *
**********************************************************************
         SPACE
         USING SWITCH,BASE
         SPACE
SWITCH   DS    0H
         DS@ENTR ,
         DO    GETTOKEN               GO SEE IF NEW PREFIX ENTERED
         LTR   R1,R1                  IF NOTHING ENTERED, THEN
         BNZ   SWITCH10
         LA    R1,MSG34                 SET ERROR MESSAGE
         DO    PUTMSG                   GO PUT THE MESSAGE
         B     SWITCHX                  AND WE'RE DONE
SWITCH10 DS    0H
         MVC   PREFIX,TOKEN           MOVE IN VALUE RETURNED
         ST    R1,PREFIXL             SAVE LENGTH
         CALL  ISPLINK,(=CL8'VREPLACE',=CL8'(PREFIX)',PREFIXL,PREFIX), +
               VL,MF=(E,CALLPL)
         DO    GETTOKEN               GO SEE SHORT OR LONG OPERAND
         LTR   R1,R1                  IF OPERAND, THEN
         BZ    SWITCH20
         MVC   DFORM,TOKEN              ASSUME IT'S VALID
SWITCH20 DS    0H
         XC    TIMEVAL,TIMEVAL        ENSURE NO STATISTICS PANEL
         MVI   RBLDFLAG,FLAGON        SAY REBUILD
         MVI   FLAGBYTE,0             RESET ANY FLAGS
         XC    DSF,DSF                CLEAR THESE FIELDS
         XC    DSP,DSP
         L     R5,=F'4096'            READY TO ZERO 4K WORK AREA
         LA    R4,LOCINDXW            ADDRESS WORK AREA
         LR    R1,R4                     FOR MVCL
         SLR   R3,R3                  CLEAR THIS REGISTER
         MVCL  R4,R2                  THIS SHOULD ZERO IT OUT
SWITCHX  DS    0H
         DS@EXIT RET=R15
         SPACE
         DROP  BASE
**********************************************************************
*                 Z A P T B L       R O U T I N E                    *
*                                                                    *
*     THIS ROUTINE PROCESSES THE ZAP COMMAND, WHICH SIMPLY DELETES   *
*   THE GIVEN LINE FROM THE TABLE (THE DATASET IS NOT DELETED).      *
*                                                                    *
**********************************************************************
         SPACE
         USING ZAP,BASE
         SPACE
ZAP      DS@ENTR ,
         TM    FLAGBYTE,CMDZ          IF NOT ZCMD, THEN WE CAN
         BZ    ZAPIT                     SKIP THIS
         DO    GETTOKEN               ELSE GO GET MEMBER IF GIVEN
         LTR   R15,R15                IF MEMBER NOT GIVEN, THEN
         BNZ   OKZAP
         LA    R1,MSG14                 SET THE MESSAGE
         DO    PUTMSG                   GO SET THE ERROR
         LA    R15,4                    SET RC
         B     ZAPTBLX                  AND GET OUT OF HERE
OKZAP    DS    0H
         MVC   TBDSNSH,TOKEN
         LA    R2,TBLNAME
         CALL  ISPLINK,(=CL8'TBSCAN',(R2),=C'(TBDSNSH)'),VL,           +
               MF=(E,CALLPL)
         LTR   R15,R15                IF MEMBER NOT FOUND, THEN
         BZ    ZAPIT
         LA    R1,MSG15                 SET MESSAGE NUMBER
         DO    PUTMSG                   GO SET THE MESSAGE
         LA    R15,4                    SET RC
         B     ZAPTBLX                  AND GET OUT OF HERE
ZAPIT    DS    0H
         LA    R2,TBLNAME             ISSUE THE DELETE
         CALL  ISPLINK,(=CL8'TBDELETE',(R2)),VL,MF=(E,CALLPL)
         OI    FLAGBYTE,SKIPPUT       BE SURE TO SKIP TBPUT
ZAPTBLX  DS@EXIT RET=R15
         SPACE
         DROP  BASE
         TITLE 'NOOPMEM - PROCESS NO-OP COMMAND'
**********************************************************************
*                N O O P M E M      R O U T I N E                    *
*                                                                    *
*     THIS ROUTINE PROCESSES THE NO-OP COMMAND.  THE NO-OP COMMAND   *
*   IS A SELECT CODE OF ALL BLANKS.  THIS HAPPENS WHEN AN INVALID    *
*   SELECT CODE IS ENTERED.  THE TABLE IS REDISPLAYED, AND THE USER  *
*   IS MADE TO CORRECT THE ERROR BEFORE PROCEEDING.  HE MAY SIMPLY   *
*   JUST BLANK OUT HIS SELECTION, AND IN THIS CASE THE ROW IS STILL  *
*   SELECT BY TBDISPL, SO WE MUST PROCESS THE BLANK SELECT CODE.     *
**********************************************************************
         SPACE
NOOP     DS    0H
         LA    R15,0                  NOTHING TO DO HERE EXCEPT
         BR    R14                       SET RETURN CODE AND GO BACK
         TITLE 'RIGHT - PROCESS RIGHT COMMAND'
**********************************************************************
*                  R I G H T        R O U T I N E                    *
*                                                                    *
*     THIS ROUTINE PROCESSES THE RIGHT COMMAND, WHICH IS ONLY GOTTEN *
*   FROM ZCMD (EITHER TYPED IN ON THE COMMAND LINE, OR FROM A PFKEY).*
*   THE ONLY THING TO DO, IS SET A FLAG, AND GET OUT.                *
**********************************************************************
         SPACE
RIGHT    DS    0H
         MVI   SCRLLFLG,FLAGOFF       SAY "RIGHT" COMMAND
         LA    R15,0                  SET RETURN CODE
         BR    R14                    DONE
         TITLE 'LEFT - PROCESS RIGHT COMMAND'
**********************************************************************
*                   L E F T         R O U T I N E                    *
*                                                                    *
*     THIS ROUTINE PROCESSES THE  LEFT COMMAND, WHICH IS ONLY GOTTEN *
*   FROM ZCMD (EITHER TYPED IN ON THE COMMAND LINE, OR FROM A PFKEY).*
*   THE ONLY THING TO DO, IS SET A FLAG, AND GET OUT.                *
**********************************************************************
         SPACE
LEFT     DS    0H
         MVI   SCRLLFLG,FLAGON        SAY "LEFT" COMMAND
         LA    R15,0                  SET RETURN CODE
         BR    R14                    DONE
         TITLE 'DS@FLSTC - CLEAR COMMAND PROCESSOR'
**********************************************************************
*               C L E A R           R O U T I N E                    *
*                                                                    *
*     THIS ROUTINE PROCESSES THE CLEAR COMMAND, WHICH SERVES TO      *
*   DELETE TABLE ENTRIES FOR DATSETS THAT HAVE BEEN DELETED. THEN    *
*   PROCESS IS VERY SIMPLE.  WE DO A TBTOP, AND THEN STEP THROUGH    *
*   THE TABLE CHECKING TO SEE IF IT WAS DELETED. THEN IF SO, WE      *
*   ISSUE  A  TBDELETE.    THIS IS DONE UNTIL THE END OF THE TABLE   *
*   IS REACHED, THEN THE TABLE IS PUT AT THE TOP.                    *
*     NOTE:  THIS PROCESS COULD EASILY CAUSE THE TABLE TO NOT HAVE   *
*   ANY ENTRIES, AND WHEN IT IS TBDISPLAYED NEXT TIME, A DIALOG      *
*   ERROR WILL BE THE RESULT.  BUT SINCE WE HAVE ISSUED "CONTROL     *
*   ERRORS RETURN", WE WILL GET CONTROL WITH A BAD RETURN CODE, AND  *
*   THIS PROGRAM WILL EXIT AS IF "END" HAD BEEN ENTERED.             *
**********************************************************************
         SPACE
         USING CLEAR,BASE
         SPACE
CLEAR    DS@ENTR ,
         LA    R2,TBLNAME
         CALL  ISPLINK,(=CL8'TBTOP',(R2)),VL,MF=(E,CALLPL)
         LA    R1,1
         L     R8,SKIPNUM             COPY CURRENT VALUE FOR SKIPNUM
         ST    R1,SKIPNUM             SET NUMBER FOR TBSKIP
CLRLOOP  DS    0H
         LA    R2,TBLNAME
         LA    R3,SKIPNUM
         CALL  ISPLINK,(=CL8'TBSKIP',(R2),(R3)),VL,MF=(E,CALLPL)
         LTR   R15,R15                IF END OF TABLE, THEN
         BNZ   CLRTBLX                  WE ARE DONE
         CLC   TBVOLSER,=CL6'DELETE'  IF THIS ONE WAS DELETED, THEN
         BNE   CLRLOOP
         CALL  ISPLINK,(=CL8'TBDELETE',(R2)),VL,MF=(E,CALLPL)
         B     CLRLOOP                  LOOP
CLRTBLX  DS    0H
         ST    R8,SKIPNUM             RESTORE CURREN VALUE FOR SKIPNUM
         DS@EXIT ,
         SPACE
         DROP  BASE
         TITLE 'DS@FLSTC - CONFIRM COMMAND PROCESSOR'
**********************************************************************
*               C O N F I R M       R O U T I N E                    *
*                                                                    *
*     THIS ROUTINE PROCESSES THE CONFIRM COMMAND, WHICH IS USED TO   *
*   CONTROL WHETHER OR NOT THE DELETE DATASET CONFIRM PANEL IS TO    *
*   BE DISPLAYED.  THE CONFIRM COMMAND LOOKS FOR AN OPERAND OF       *
*   "ON" OR "OFF".  IF "CONFIRM" OR "CONFIRM ON" IS SPECIFIED, THEN  *
*   THE DATASET DELETE PANEL IS DISPLAYED.  IF "CONFIRM OFF" IS      *
*   SPECIFIED, THEN THE PANEL IS NOT DISPLAYED.                      *
*     "CONFIRM ON" IS ALWAYS ASSUMED WHEN THE TABLE IS BUILT.  THE   *
*   USER MUST DO "CONFIRM OFF" TO CAUSE THE CONFIRMATION PANEL DIS-  *
*   PLAY TO BE SKIPPED.                                              *
**********************************************************************
         SPACE
         USING CONF,BASE
         SPACE
CONF     DS@ENTR ,
         SLR   R15,R15                CLEAR RETURN CODE
         MVI   CONFIRM,C'Y'           ASSUME "ON"
         DO    GETTOKEN               GET AN OPERAND
         LTR   R1,R1                    DONE
         BZ    CONFX
         CLC   =C'ON ',TOKEN            IF "ON" SPECIFIED, THEN
         BE    CONFX                      DONE
         CLC   =C'OFF ',TOKEN           ELSE IF "OFF" SPECIFIED, THEN
         BNE   CONFX
         MVI   CONFIRM,C'N'               SET FLAG
CONFX    DS    0H
         DS@EXIT RET=R15
         SPACE
         DROP  BASE
         TITLE 'DS@FLSTC - PROCESS "TOP" ZCMD'
**********************************************************************
*               T O P T B L         R O U T I N E                    *
*                                                                    *
*     THIS ROUTINE PROCESSES THE TOP COMMAND, BY SIMPLY RESETTING    *
*  SKIPNUM TO 1.                                                     *
*                                                                    *
**********************************************************************
         SPACE
         USING TOP,R15
         SPACE
TOP      DS    0H
         MVC   SKIPNUM,=F'1'
         SLR   R15,R15
         BR    R14
         SPACE
         LTORG
         DROP  R15
         TITLE 'DS@FLSTC - LOOK AT ZCMD'
**********************************************************************
*              P R O C Z C M D      R O U T I N E                    *
*                                                                    *
*     THIS ROUTINE DETERMINES IF ZCMD IS NONBLANK, AND IF SO, CALLS  *
*   GETTOKEN TO GET THE ACTUAL COMMAND.  GETCMD THEN VALIDATES THIS  *
*   COMMAND, AND IF IT IS VALID, WE  CALL THE CORRECT  PROCESSING    *
*   ROUTINE.  OTHERWISE, AN ERROR MESSAGE IS SET INDICATING THAT AN  *
*   INVALID COMMAND WAS GIVEN.                                       *
*     REGISTER USAGE: R5 - R9 AS WORK REGISTERS                      *
**********************************************************************
         SPACE
         USING PROCZCMD,BASE
         SPACE
PROCZCMD DS    0H
         TM    FLAGBYTE,CMDZ          IF WE ALREADY HAVE ZCMD
         BOR   R14                        OR
         CLC   SAVZCMD,BLANKS            ZCMD IS BLANK, THEN
         BER   R14                      NOTHING TO DO
         DS@ENTR ,
         LA    R6,SAVZCMD             ADDRESS ZCMD
         ST    R6,TOKPTR              SET UP FOR SUBROUTINE
         DO    GETTOKEN               ELSE GO GET COMMAND IN ZCMD
         DO    GETCMD                   GO VALIDATE COMMAND
         LTR   R15,R15                  IF COMMAND IS VALID THEN
         BNZ   OKZCMD                     SKIP
         LA    R1,MSG22                   SET THE MESSAGE
         DO    PUTMSG                     AND SET IT
         B     PZRETRN                    AND LEAVE
OKZCMD   DS    0H
         OI    FLAGBYTE,CMDZ            INDICATE COMMAND IS ZCMD
         BALR  R14,R15                  GO PROCESS IT
         DO    PUTTBL                   UPDATE THE TABLE
PZRETRN  DS    0H
         DS@EXIT ,
         SPACE
         DROP  BASE
         TITLE 'BUILD DATA SET NAME SUBROUTINE'
**********************************************************************
*               B L D D S N       S U B R O U T I N E                *
*                                                                    *
*    THIS SUBROUTINE BUILDS THE AREA FOR THE DATA SET NAME FOR       *
*  THE ISPF EDIT AND BROWSE COMMANDS.                                *
*                                                                    *
**********************************************************************
         SPACE
         USING BLDDSN,BASE
         SPACE
BLDDSN   DS@ENTR ,
         MVC   DSNSAVE,BLANKS         BLANK OUT THIS FIELD
         MVI   DSNSAVE,C''''          MOVE IN QUOTE
         MVC   DSNSAVE+1(44),TBDSNAME MOVE DATA SET NAME IN FOR US
         LA    R2,DSNSAVE+45          ADDRESS END OF NAME
BLDDSNLP DS    0H
         CLI   0(R2),C' '             BACK SCAN FOR FIND 1ST NONBLANK
         BNE   BLDDSNLX
         BCTR  R2,0
         B     BLDDSNLP
BLDDSNLX DS    0H
         MVC   1(1,R2),=C''''         MOVE IN ENDING QUOTE
         DS@EXIT ,
         SPACE
         DROP  BASE
         TITLE 'DS@FLSTC - FIND DSNAME IN TABLE'
**********************************************************************
*              F N D S N A M E      R O U T I N E                    *
*                                                                    *
*     THIS ROUTINE DETERMINES IF THE DSNAME NAMED BY TBDSNSH  IS     *
*   IN THE ISPF TABLE.  IT IS CALLED BY THE COMMAND PROCESSING       *
*   ROUTINES WHEN PROCESSING A COMMAND FROM THE COMMAND LINE (ZCMD). *
*   IF THE DSNAME IS NOT FOUND, R15 IS RETURNED WITH A VALUE OF 4.   *
*   OTHERWISE R15 IS RETURNED AS ZERO.                               *
**********************************************************************
         SPACE
         USING FNDSNAME,BASE
         SPACE
FNDSNAME DS    0H
         DS@ENTR ,
FNDSNLP  DS    0H
         MVC   DSNSAVE(44),TBDSNSH        SAVE INPUT
         LA    R2,TBLNAME
         CALL  ISPLINK,(=CL8'TBTOP',(R2)),VL,MF=(E,CALLPL)
         MVC   TBDSNAME,DSNSAVE       RESET DSNAME
         CALL  ISPLINK,(=CL8'TBSCAN',(R2),=CL8'TBDSNSH'),VL,           +
               MF=(E,CALLPL)
FNDSN01  DS    0H
         DS@EXIT RET=R15
         SPACE
         DROP  BASE
         TITLE 'GETCMD - GET COMMAND FROM COMMAND TABLE'
**********************************************************************
*                G E T C M D        R O U T I N E                    *
*                                                                    *
*     THIS ROUTINE  DETERMINES IF THE COMMAND IN THE FIELD TOKEN     *
*   EXISTS IN CMDTBL.  IF IT DOES, R15 IS RETURNED WITH THE ADDRESS  *
*   OF THE PROPER PROCESSING ROUTINE.  IF THE COMMAND IS NOT FOUND   *
*   IN CMDTBL, THEN R15 IS SET TO ZERO.                              *
*     REGISTER USAGE: R6 AS A WORK REGISTER                          *
**********************************************************************
         SPACE
         USING GETCMD,BASE
         SPACE
GETCMD   DS@ENTR ,
         L     R6,=A(CMDTBL)          ADDRESS COMMAND TABLE
         LA    R7,CMDTBLSZ            GET NUMBER OF TABLE ELEMENTS
         SLR   R15,R15                ASSUME WE WON'T FIND IT
GCDLOOP  DS    0H
         CLC   0(8,R6),TOKEN          IF COMMAND FOUND IN TABLE THEN
         BE    GOTCMD                   OK, SO SKIP
         LA    R6,12(R6)              ELSE NEXT TABLE ELEMENT
         BCT   R7,GCDLOOP               AND LOOP
         B     GCMDRET                IF HERE, IT WAS NOT FOUND
GOTCMD   DS    0H
         L     R15,8(R6)              GET ADDRESS OF ROUTINE
GCMDRET  DS@EXIT RET=R15              RETURN TO CALLER
         SPACE
         DROP  BASE
         TITLE 'GETTOKEN - GET TOKEN FROM ZCMD'
**********************************************************************
*             G E T T O K E N       R O U T I N E                    *
*                                                                    *
*     THIS ROUTINE FUNCTIONS AS A SIMPLE PARSERBY PUTTING IN THE    *
*   FIELD TOKEN THE NEXT WORD FROM THE FIELD ZCMD.  THE ONLY VALID   *
*   DELIMITER BETWEEN WORDS OF THE COMMAND IS CURRENTLY A BLANK.     *
*   THE ROUTINE SAVES A POINTER TO THE PLACE IN ZCMD IN WHICH TO     *
*   BEGIN LOOKING FOR THE NEXT TOKEN.  SO TO BEGIN WITH THE FIRST    *
*   TOKEN IN ZCMD, THIS SHOULD POINT TO THE ADDRESS OF ZCMD.         *
*     INPUT: ZCMD - FIELD IN WHICH TO RETRIEVE TOKEN                 *
*            TOKPTR - PLACE IN WHICH TO BEGIN SEARCH                 *
*     OUTPUT: TOKEN - VALUE GOTTEN                                   *
*             R1    - LENGTH OF TOKEN GOTTEN                         *
**********************************************************************
         SPACE
         USING GETTOKEN,BASE
         SPACE
GETTOKEN DS    0H
         DS@ENTR ,
         MVC   TOKEN,BLANKS           CLEAR TOKEN FIELD
         SLR   R7,R7                  CLEAR LENGTH
         L     R6,TOKPTR              ADDRESS START OF SEARCH
GBLNKLP  DS    0H
         CLI   0(R6),X'FF'            IF END OF ZCMD, THEN
         BE    GTOKRET                  WE ARE DONE, SO LEAVE
         CLI   0(R6),C' '             IF BLANK NOT FOUND THEN
         BNE   GBLNKLPX                 GET OUT OF LOOP
         LA    R6,1(,R6)              ELSE NEXT CHARACTER
         B     GBLNKLP                  AND LOOP
GBLNKLPX DS    0H
         LA    R7,1(,R6)              FIRST BYTE AFTER NONBLANK
GCHARLP  DS    0H
         CLI   0(R7),X'FF'            IF END OF ZCMD, THEN
         BE    GTOKRET                  WE ARE DONE, SO LEAVE
         CLI   0(R7),C' '             IF BLANK FOUND, THEN
         BE    GCHARLPX                 GET OUT OF LOOP
         LA    R7,1(,R7)              ELSE NEXT CHARACTER
         B     GCHARLP                  AND LOOP
GCHARLPX DS    0H
         LA    R8,1(,R7)              COPY CURRENT PLACE+1
         ST    R8,TOKPTR              SAVE POINTER FOR LATER
         SR    R7,R6                  SUBTRACT TO GET LNG OF TOKEN
         BCTR  R7,0                   DECREMENT FOR EXECUTE
         EX    R7,MVCTOK              AND MOVE INTO TOKEN FIELD
         LA    R7,1(,R7)              PUT 1 BACK
GTOKRET  DS    0H
         LR    R1,R7                  SET RETURN REGISTER
         DS@EXIT RET=R1
         SPACE
MVCTOK   MVC   TOKEN(0),0(R6)
         SPACE
         DROP  BASE
         TITLE 'DS@FLSTC - CALCULATE NEW SPACE ALLOCATION INFO'
**********************************************************************
*             G E T N S P C         R O U T I N E                    *
*                                                                    *
*     THIS ROUTINE RECALCULATES THE SPACE ALLOCATION INFORMATION AND *
*   UPDATES THE CORRESPONDING DIALOG VARIABLES.  IT IS CALLED AFTER  *
*   ANY COMMAND WHICH COULD CHANGE THIS INFORMATION (EDIT, MEMBER    *
*   LIST, AND COMPRESS).                                             *
**********************************************************************
         SPACE
         USING GETNSPC,BASE
         SPACE
GETNSPC  DS    0H
         CLC   TBVOLSER,=CL6'MULTI'   IF MULTI VOLUME, THEN
         BER   R14                      NOTHING TO DO
         DS@ENTR ,
         MVC   DSNSAVE(44),TBDSNAME   SAVE DATA SET NAME
         MVI   TBDSNAME,X'04'         SET FOR F4 DSCB
         MVC   TBDSNAME+1(43),TBDSNAME PROPOGATE IT
         OBTAIN SRCHCAM               OBTAIN DSCB
         MVC   VOLTKCYL(2),BUF1+20    SAVE TRKS/CYL
         MVC   TBDSNAME,DSNSAVE       RESTORE DS NAME
         OBTAIN SRCHCAM               OBTAIN DSCB
         DO    CALCSPC                ROUTINE WILL CALCULATE INFO
         DS@EXIT ,
         TITLE 'DS@FLSTC - TBPUT ROUTINE'
**********************************************************************
*              P U T T B L         S U B R O U T I N E               *
*                                                                    *
*    THIS SUBROUTINE ISSUES THE TBPUT ISPF DIALOG SERVICE UNLESS THE *
*  FLAG SAYING SKIP THE PUT IS ON.  THE FLAG IS ALWAYS RESET BY THIS *
*  ROUTINE.                                                          *
*                                                                    *
**********************************************************************
         SPACE
         USING PUTTBL,BASE
         SPACE
PUTTBL   DS@ENTR ,
         TM    FLAGBYTE,SKIPPUT         IF ^ SKIP THE PUT, THEN
         BO    PUTTBLX
         LA    R2,TBLNAME                 UPDATE THE TABLE
         CALL  ISPLINK,(=CL8'TBPUT',(R2)),VL,MF=(E,CALLPL)
PUTTBLX  DS    0H
         NI    FLAGBYTE,255-SKIPPUT     RESET THIS FLAG
         DS@EXIT RET=R15
         SPACE
         DROP  BASE
         TITLE 'DS@SCPDS - SET ISPF MESSAGE SUBROUTINE'
**********************************************************************
*              P U T M S G         S U B R O U T I N E               *
*                                                                    *
*    THIS SETS UP THE MESSAGE PARAMETER BLOCK AND CALLS THE MESSAGE  *
*  PROGRAM TO SET AN ISPF MESSAGE.  INPUT TO THIS ROUTINE IS R1,     *
*  WHICH CONTAINS THE ID OF THE MESSAGE.                             *
*                                                                    *
**********************************************************************
         SPACE
         USING PUTMSG,BASE
         SPACE
PUTMSG   DS@ENTR ,
         C     R1,=AL4(MAXMSG)        IF GREATER THAN MAX MSG, THEN
         BNH   *+6
         DC    H'0'                     DIE 0C1
         ST    R1,MSGID               SAVE MESSAGE IN PARM BLOCK
         LA    R2,DS@MSGPB            ADDRESS MESSAGE PARM BLOCK
         CALL  DS@FCMSG,((R2)),VL,MF=(E,CALLPL)
         DS@EXIT ,
         SPACE
         DROP  BASE
         TITLE 'TIME ROUTINE'
**********************************************************************
*                                                                    *
*    THIS ROUTINE SAVES THE CURRENT CLOCK VALUE AND CALCULATES THE   *
*  THE TIME FOR THE NEXT TIME TO SHOW THE STATISTICS BY ADDING THE   *
*  FIELD TIMEVAL.                                                    *
*                                                                    *
**********************************************************************
         SPACE
         USING TIMESET,BASE
         SPACE
TIMESET  DS    0H
         L     R1,TIMEVAL             GET TIMER VALUE GIVEN
         LTR   R1,R1                  IF ZERO, THEN
         BZR   R14                      SKIP ALL OF THIS
         STCK  CCLOCK                 SAVE CURRENT CLOCK
         L     R0,CCLOCK              GET FIRST WORD OF CLOCK VALUE
         AR    R0,R1                  ADD TIMER VALUE
         ST    R0,CCLOCK              AND SAVE AWAY
         BR    R14
         TITLE 'CONVERT TO BINARY SUBROUTINE'
**********************************************************************
*            C O N V B I N            R O U T I N E S                *
*                                                                    *
*    THIS SUBROUTINE TAKES AN EBCDIC NUMBER RIGHT OR LEFT JUSTIFIED  *
*    IN A FIELD WITH BLANKS, AND CONVERTS IT TO ITS BINARY EQUIVA-   *
*    LENT.  IT ASSUMES A VALID NUMBER IS IN THIS FIELD SOMEWHERE.    *
*    THE INPUT REGISTERS ARE USED AND NOT RESTORED.                  *
*    INPUT: R2 - ADDRESSES START OF FIELD TO CONVERT                 *
*           R3 - LENGTH OF FIELD TO CONVERT                          *
*           R14 - RETURN REGISTER                                    *
*    OUTPUT: R1 - THE BINARY EQUIVALENT OF THE NUMBER                *
*                                                                    *
**********************************************************************
         SPACE
         USING CONVBIN,BASE
         SPACE
CONVBIN  DS@ENTR ,                    START OF ROUTINE
         LR    R5,R2                  COPY START OF FIELD
         AR    R5,R3                  SUBTRACT LENGTH
         BCTR  R5,0                   R5 NOW HAS END OF FIELD
CNVLOOP1 DS    0H
         CLI   0(R2),C' '             LOOP REPLACING BLANKS WITH C'0'
         BNE   CNVLOOP2                 UNTIL FIRST NUMBER FOUND
         MVI   0(R2),C'0'
         LA    R2,1(R2)               NEXT BYTE
         CR    R5,R2                  IF AT END OF FIELD, THAN IT WAS
         BH    CNVLOOP1                 BLANKS TO BEGIN WITH, SO JUST
         SLR   R1,R1                    ZERO OUT R4 AND RETURN
         B     CNVBDONE
CNVLOOP2 DS    0H
         CLI   0(R5),C' '             LOOP FROM BACK UNTIL FIRST NON-
         BNE   CNVBDOIT                 BLANK CHARACTER FOUND
         BCTR  R5,0
         B     CNVLOOP2
CNVBDOIT DS    0H
         SR    R5,R2                  SUBTRACT TO GET LENGTH OF FIELD
         EX    R5,PACKIT              NOW PACK IT
         CVB   R1,CNVWORK             NOW CONVERT IT TO BINARY
CNVBDONE DS@EXIT RET=R1
         SPACE
PACKIT   PACK  CNVWORK(8),0(0,R2)     EX PACK INSTRUCTION
         SPACE
         DROP  BASE
         TITLE 'CONVERT DATE SUBROUTINE'
**********************************************************************
*               C O N V D A T E        R O U T I N E                 *
*                                                                    *
*    THIS SUBROUTINE CONVERTS THE DATE ADDRESSED BY REGISTER 5. IT IS*
*    IN THE FORM X'YYDDDD', WHERE YY IS THE YEAR IN HEX, AND DDDD IS *
*    THE JULIAN DAY IN HEX.  THIS SUBROUTINE CONVERTS THIS INTO A    *
*    FORM ACCEPTABLE TO THE CONVDATE EXTERNAL SUBROUTINE, THAT IS    *
*    P'YYDDD'.  CONVDATE CONVERTS THIS TO C'MMDDYY', AND THEN IT'S   *
*    JUST A MATTER OF MOVING THESE FIELDS TO OUR TABLE VARIABLE,     *
*    ADDRESSED BY REGISTER 6, INCLUDING THE DATE SLASHES.  IF THERE  *
*    IS NO DATE (X'000000'), THEN NOTHING IS DONE HERE.              *
*       INPUT: R5 - DATE TO BE CONVERTED IN FORM X'YYDDDD'           *
*              R6 - ADDRESS OF FIELD TO PUT CONVERTED DATE           *
*       OUTPUT: CONVERTED DATE IN FIELD ADDRESSED BY REGISTER 6      *
*                                                                    *
**********************************************************************
         SPACE
         USING CONVDATE,BASE
         SPACE 2
CONVDATE DS    0H
         CLC   0(3,R5),ZEROES         IF DATE IS ZERO, THEN
         BER   R14                      NOTHING TO DO
         DS@ENTR ,
         SLR   R2,R2                  CLEAR WORK REGISTER
         IC    R2,0(R5)               GET YY
         CVD   R2,WKD                 CONVERT IT TO PACKED DECIMAL
         L     R2,WKD+4               GET IT BACK
         SRL   R2,4                   REMOVE PACKED SIGN
         STC   R2,JULDATE             PUT YY IN PARAMETER LIST
         LH    R2,1(R5)               GET DDD
         CVD   R2,WKD                 CONVERT IT TO PACKED DECIMAL
         MVC   CONVTYPE,=C'JG'        CONVERT JULIAN TO GREGORIAN
         MVC   JULDATE+1(2),WKD+6     PUT DDD IN PARAMETER LIST
         LA    R2,CNVDATPB            ADDRESS PARAMETER BLOCK
         CALL  DS@CNVDT,((R2)),VL,MF=(E,CALLPL) CALL PROGRAM
         MVC   0(8,R6),GREGDATE       MOVE IN DATE FROM ROUTINE
         DS@EXIT ,                    AND RETURN TO CALLER
         SPACE
         DROP  BASE
         TITLE 'GET ISPF DIALOG VARIABLES SUBROUTINE'
**********************************************************************
*              G E T V A R S       S U B R O U T I N E               *
*                                                                    *
*    THIS SUBROUTINE CYCLES THROUGHT THE NECESSARY TABLES IN ORDER   *
*  TO EFFICIENTLY ISSUE VCOPY CALLS.                                 *
*  INPUT TO THIS ROUTINE IS VARTBLA, WHICH CONTAINS THREE ADDRESSES. *
*  THE FIRST ADDRESS POINTS TO A TABLE THAT CONTAINS VARIOUS INFOR-  *
*  MATION ABOUT THE VARIABLES TO VCOPY; THE SECOND ADDRESS POINTS    *
*  TO A LENGTH TABLE WHERE THE VARIABLE LENGTHS VCOPIED WILL BE      *
*  PLACED (IN CONSECUTIVE FULLWORDS); THE THIRD ADDRESS POINTS TO    *
*  THE FIRST VARIABLE ADDRESS IN THE DSA.                            *
*                                                                    *
**********************************************************************
         SPACE
         USING GETVARS,BASE
         SPACE
GETVARS  DS@ENTR ,
         LM    R2,R4,VARTBLA          LOAD ADDRESSES FROM PARM LIST
GVLOOP   DS    0H
         SLR   R5,R5                  CLEAR REGISTER 2
         IC    R5,0(R2)               GET LENGTH FOR VARIABLE
         LTR   R5,R5                  IF ZERO, THEN
         BZ    GVEXIT                   WE ARE DONE
         ST    R5,0(R3)               SAVE VARIABLE LENGTH IN TABLE
         LH    R5,2(R2)               GET OFFSET FOR VARIABLE
         AR    R5,R4                  ADD TO FIRST VARIABLE
         LA    R6,4(R2)               ADDRESS VARIABLE NAME
         CALL  ISPLINK,(=CL8'VCOPY',(R6),(R3),(R5),=CL8'MOVE'),VL,     +
               MF=(E,CALLPL)          ISSUE THE VCOPY
         LA    R2,VTBLLNG(,R2)        NEXT ELEMENT IN THE TABLE
         LA    R3,4(,R3)              NEXT ONE IN LENGTH TABLE
         B     GVLOOP                 AND LOOP
GVEXIT   DS@EXIT ,
         SPACE
         DROP  BASE
         TITLE 'DEFINE ISPF DIALOG VARIABLES SUBROUTINE'
**********************************************************************
*              D E F V A R S       S U B R O U T I N E               *
*                                                                    *
*    THIS SUBROUTINE CYCLES THROUGHT THE NECESSARY TABLES IN ORDER   *
*  TO EFFICIENTLY ISSUE VDEFINE CALLS.                               *
*  INPUT TO THIS ROUTINE IS VARTBLA, WHICH CONTAINS THREE ADDRESSES. *
*  THE FIRST ADDRESS POINTS TO A TABLE THAT CONTAINS VARIOUS INFOR-  *
*  MATION ABOUT THE VARIABLES TO VDEFINE; THE 2ND  ADDRESS POINTS    *
*  TO A LENGTH TABLE WHERE THE VARIABLE LENGTHS VDEFINED WILL BE     *
*  PLACED (IN CONSECUTIVE FULLWORDS); THE THIRD ADDRESS POINTS TO    *
*  THE FIRST VARIABLE ADDRESS IN THE DSA.                            *
*                                                                    *
**********************************************************************
         SPACE
         USING DEFVARS,BASE
         SPACE
DEFVARS  DS@ENTR ,
         LM    R2,R4,VARTBLA          LOAD ADDRESSES FROM PARM LIST
DVLOOP   DS    0H
         SLR   R5,R5                  CLEAR REGISTER 2
         IC    R5,0(R2)               GET LENGTH FOR VARIABLE
         LTR   R5,R5                  IF ZERO, THEN
         BZ    DVEXIT                   WE ARE DONE
         ST    R5,0(R3)               SAVE VARIABLE LENGTH IN TABLE
         LH    R5,2(R2)               GET OFFSET FOR VARIABLE
         AR    R5,R4                  ADD TO FIRST VARIABLE
         LA    R6,4(R2)               ADDRESS VARIABLE NAME
         LA    R7,=C'CHAR'            ADDRESS THIS FORMAT
         CLI   1(R2),CHAR             IF NOT CHAR FORMAT, THEN
         BE    DVVDEF
         LA    R7,=C'FIXED'             TRY FIXED FORMAT
         CLI   1(R2),FIXED              IF NOT FIXED FORMAT, THEN
         BE    DVVDEF
         LA    R7,=C'BIT'                 TRY BIT FORMAT
         CLI   1(R2),BIT                  IF NOT BIT FORMAT, THEN
         BE    DVVDEF
         LA    R7,=C'HEX'                   TRY HEX FORMAT
         CLI   1(R2),HEX                    IF NOT HEX FORMAT, THEN
         BE    DVVDEF
         DC    H'0'                           DIE 0C1
DVVDEF   DS    0H
         CALL  ISPLINK,(=CL8'VDEFINE',(R6),(R5),(R7),(R3)),VL,         +
               MF=(E,CALLPL)          ISSUE THE VCOPY
         LA    R2,VTBLLNG(,R2)        NEXT ELEMENT IN THE TABLE
         LA    R3,4(,R3)              NEXT ONE IN LENGTH TABLE
         B     DVLOOP                 AND LOOP
DVEXIT   DS@EXIT ,
         SPACE
         DROP  BASE
         TITLE 'ASSIGN SAVE AREA FOR SUBROUTINE'
**********************************************************************
*              G E T S V A         S U B R O U T I N E               *
*                                                                    *
*    THIS SUBROUTINE ASSIGNS THE NEXT SAVE AREA IN THE STACK FOR THE *
*  CALLING SUBROUTINE.  THE ADDRESS OF THE 64-BYTE SAVEAREA IS RE-   *
*  TURNED IN REGISTER 1.                                             *
*    THIS ROUTINE IS COUPLED CLOSELY WITH THE DS@ENTR MACRO, AND     *
*  SHOULD ONLY BE USED IN THIS ENVIRONMENT.                          *
*                                                                    *
**********************************************************************
         SPACE
         USING GETSVA,R15
         SPACE
GETSVA   DS    0H
         L     R1,SAVADDR             GET CURRENT ADDRESS
         LTR   R1,R1                  IF THIS IS FIRST TIME
         BNZ   GETSVA1
         LA    R1,SAVSTCK               SET ADDRESS OF SAVE AREAS
         ST    R1,SAVADDR
         B     GETSVA2
GETSVA1  DS    0H                     ELSE
         LA    R1,SAVALNG(,R1)          CALCULATE NEXT SAVE AREA
         ST    R1,SAVADDR               AND SAVE IT
GETSVA2  DS    0H
         L     R0,NUMSVA              GET NUMBER OF SAVE AREAS
         AH    R0,=H'1'               INCREMENT IT
         ST    R0,NUMSVA              SAVE AWAY
         CH    R0,=AL2(SAVMAX)        IF WE HAVE EXCEEDED MAXIMUM
         BNH   *+4+2                      NESTING LEVEL
         DC    H'0'                     DIE 0C1
         BR    R14                    ELSE RETURN TO CALLER
         SPACE
         LTORG
         SPACE
         DROP  R15
         TITLE 'RETURN SAVE AREA ADDRESS, REMOVE FROM STACK'
**********************************************************************
*              F R E E S V A       S U B R O U T I N E               *
*                                                                    *
*    THIS SUBROUTINE RETURNS THE ADDRESS OF THE CURRENT SAVEAREA,    *
*  AND REMOVES IT FROM THE STACK.                                    *
*    THIS ROUTINE IS COUPLED CLOSELY WITH THE DS@ENTR MACRO, AND     *
*  SHOULD ONLY BE USED IN THIS ENVIRONMENT.                          *
*                                                                    *
**********************************************************************
         SPACE
         USING FREESVA,R15
         SPACE
FREESVA  DS    0H
         L     R1,NUMSVA              GET NUMBER ON STACK
         LTR   R1,R1                  IF ZERO, THEN
         BNZ   *+4+2
         DC    H'0'                     DIE 0C1
         BCTR  R1,0                   ELSE DECREMENT IT
         ST    R1,NUMSVA                SAVE FOR NEXT TIME
         L     R0,SAVADDR               GET CURRENT SAVE AREA ADDRESS
         LR    R1,R0                    COPY IT
         SH    R0,=AL2(SAVALNG)         CALCULATE PREVIOUS SAVEAREA
         ST    R0,SAVADDR               SAVE FOR NEXT TIME
         BR    R14                      RETURN TO CALLER
         SPACE
         LTORG
         SPACE
         DROP  R15
         TITLE 'DS@FLSTC - STATIC CSECT'
**********************************************************************
*               S T A T I C      D E F I N I T I O N S               *
**********************************************************************
         SPACE 2
**********************************************************************
*         D I A L O G     V A R I A B L E     T A B L E              *
**********************************************************************
         SPACE
GETVTBL1 DC    AL1(L'ZPREFIX),AL1(CHAR),AL2(ZPREFIX-ZPREFIX)
         DC    CL10'(ZPREFIX)'
VTBLLNG  EQU   *-GETVTBL1
         DC    AL1(L'ZDATE),AL1(CHAR),AL2(ZDATE-ZPREFIX)
         DC    CL10'(ZDATE)'
         DC    AL1(L'ZJDATE),AL1(CHAR),AL2(ZJDATE-ZPREFIX)
         DC    CL10'(ZJDATE)'
         DC    AL1(L'PREFIX),AL1(CHAR),AL2(PREFIX-ZPREFIX)
         DC    CL10'(PREFIX)'
         DC    AL1(L'DFORM),AL1(CHAR),AL2(DFORM-ZPREFIX)
         DC    CL10'(DFORM)'
         DC    AL1(L'CONFIRM),AL1(CHAR),AL2(CONFIRM-ZPREFIX)
         DC    CL10'(CONFIRM)'
         DC    AL1(L'DELAY),AL1(CHAR),AL2(DELAY-ZPREFIX)
         DC    CL10'(DELAY)'
         DC    AL1(L'TRACE),AL1(CHAR),AL2(TRACE-ZPREFIX)
         DC    CL10'(TRACE)'
         DC    AL2(0)                 INDICATES END OF TABLE
         SPACE
DEFVTBL1 DC    AL1(L'TBSEL),AL1(CHAR),AL2(TBSEL-TBSEL)
         DC    CL10'(TBSEL)'
         DC    AL1(L'TBDSNAME),AL1(CHAR),AL2(TBDSNAME-TBSEL)
         DC    CL10'(TBDSNAME)'
         DC    AL1(L'TBDSNSH),AL1(CHAR),AL2(TBDSNSH-TBSEL)
         DC    CL10'(TBDSNSH)'
         DC    AL1(L'TBMEM),AL1(CHAR),AL2(TBMEM-TBSEL)
         DC    CL10'(TBMEM)'
         DC    AL1(L'TBCRTED),AL1(CHAR),AL2(TBCRTED-TBSEL)
         DC    CL10'(TBCRTED)'
         DC    AL1(L'TBEXPDT),AL1(CHAR),AL2(TBEXPDT-TBSEL)
         DC    CL10'(TBEXPDT)'
         DC    AL1(L'TBLSTRF),AL1(CHAR),AL2(TBLSTRF-TBSEL)
         DC    CL10'(TBLSTRF)'
         DC    AL1(L'TBDSORG),AL1(CHAR),AL2(TBDSORG-TBSEL)
         DC    CL10'(TBDSORG)'
         DC    AL1(L'TBRECFM),AL1(CHAR),AL2(TBRECFM-TBSEL)
         DC    CL10'(TBRECFM)'
         DC    AL1(L'TBLRECL),AL1(CHAR),AL2(TBLRECL-TBSEL)
         DC    CL10'(TBLRECL)'
         DC    AL1(L'TBBLKSZ),AL1(CHAR),AL2(TBBLKSZ-TBSEL)
         DC    CL10'(TBBLKSZ)'
         DC    AL1(L'TBALC),AL1(CHAR),AL2(TBALC-TBSEL)
         DC    CL10'(TBALC)'
         DC    AL1(L'TBPCUSED),AL1(CHAR),AL2(TBPCUSED-TBSEL)
         DC    CL10'(TBPCUSED)'
         DC    AL1(L'TBEXTNTS),AL1(CHAR),AL2(TBEXTNTS-TBSEL)
         DC    CL10'(TBEXTNTS)'
         DC    AL1(L'TBVOLSER),AL1(CHAR),AL2(TBVOLSER-TBSEL)
         DC    CL10'(TBVOLSER)'
         DC    AL1(L'TBDEVT),AL1(HEX),AL2(TBDEVT-TBSEL)
         DC    CL10'(TBDEVT)'
         DC    AL1(L'DSF),AL1(FIXED),AL2(DSF-TBSEL)
         DC    CL10'(DSF)'
         DC    AL1(L'DSP),AL1(FIXED),AL2(DSP-TBSEL)
         DC    CL10'(DSP)'
         DC    AL2(0)                 INDICATES END OF TABLE
         SPACE
DEFVTBL2 DC    AL1(L'CRP),AL1(FIXED),AL2(CRP-CRP)
         DC    CL10'(CRP)'
         DC    AL1(L'ZTDTOP),AL1(FIXED),AL2(ZTDTOP-CRP)
         DC    CL10'(ZTDTOP)'
         DC    AL1(L'SCRHORZ),AL1(CHAR),AL2(SCRHORZ-CRP)
         DC    CL10'(RFIND)'
         DC    AL1(L'ZCMD),AL1(CHAR),AL2(ZCMD-CRP)
         DC    CL10'(ZCMD)'
         DC    AL1(L'ZTDMARK),AL1(CHAR),AL2(ZTDMARK-CRP)
         DC    CL10'(ZTDMARK)'
         DC    AL1(L'DSN1),AL1(CHAR),AL2(DSN1-CRP)
         DC    CL10'(DS@DSN1)'
         DC    AL1(L'DSN2),AL1(CHAR),AL2(DSN2-CRP)
         DC    CL10'(DS@DSN2)'
         DC    AL1(L'DSN3),AL1(CHAR),AL2(DSN3-CRP)
         DC    CL10'(DS@DSN3)'
         DC    AL1(L'DSN4),AL1(CHAR),AL2(DSN4-CRP)
         DC    CL10'(DS@DSN4)'
         DC    AL1(L'VOL1),AL1(CHAR),AL2(VOL1-CRP)
         DC    CL10'(DS@VOL)'
         DC    AL1(L'MODE),AL1(CHAR),AL2(MODE-CRP)
         DC    CL10'(DS@MODE)'
         DC    AL1(L'USERID),AL1(CHAR),AL2(USERID-CRP)
         DC    CL10'(DS@USER)'
         DC    AL1(L'USEROP),AL1(CHAR),AL2(USEROP-CRP)
         DC    CL10'(DS@UOP)'
         DC    AL1(L'MEMBER),AL1(CHAR),AL2(MEMBER-CRP)
         DC    CL10'(DS@MEM)'
         DC    AL1(L'SCOP),AL1(CHAR),AL2(SCOP-CRP)
         DC    CL10'(DS@SCOP)'
         DC    AL1(L'RLSE),AL1(CHAR),AL2(RLSE-CRP)
         DC    CL10'(RLSE)'
         DC    AL1(L'PRTOPT),AL1(CHAR),AL2(PRTOPT-CRP)
         DC    CL10'(PRTOPT)'
         DC    AL2(0)                 INDICATES END OF TABLE
         SPACE
CHAR     EQU   0
FIXED    EQU   4
BIT      EQU   8
HEX      EQU   12
         TITLE 'DS@FLSTC - COMMAND TABLE'
**********************************************************************
*              C O M M A N D        T A B L E                        *
**********************************************************************
         SPACE
CMDTBL   DS    0F
         DC    C'S       ',AL4(BROWSE)
         DC    C'E       ',AL4(EDIT)
         DC    C'M       ',AL4(MEMLIST)
         DC    C'R       ',AL4(RENAME)
         DC    C'D       ',AL4(DELETE)
         DC    C'C       ',AL4(COMPRESS)
         DC    C'B       ',AL4(BROWSE)
         DC    C'L       ',AL4(LOCATE)
         DC    C'Z       ',AL4(ZAP)
         DC    C'        ',AL4(NOOP)
         DC    C'RI      ',AL4(RIGHT)
         DC    C'RIGHT   ',AL4(RIGHT)
         DC    C'LE      ',AL4(LEFT)
         DC    C'LEFT    ',AL4(LEFT)
         DC    C'SORT    ',AL4(SORT)
         DC    C'CLEAR   ',AL4(CLEAR)
         DC    C'CONFIRM ',AL4(CONF)
         DC    C'ST      ',AL4(STACK)
         DC    C'SW      ',AL4(SWITCH)
         DC    C'TOP     ',AL4(TOP)
CMDTBLSZ EQU   ((*-CMDTBL)/12)
         TITLE 'TRANSLATE TABLES'
**********************************************************************
*                T R A N S L A T E    T A B L E S                    *
**********************************************************************
         SPACE
TBLUPPER DS    0F
         DC    256AL1(*-TBLUPPER)
         ORG   TBLUPPER+X'81'
TBLGRPA  DC    9AL1(C'A'+*-TBLGRPA)
         ORG   TBLUPPER+X'91'
TBLGRPJ  DC    9AL1(C'J'+*-TBLGRPJ)
         ORG   TBLUPPER+X'A2'
TBLGRPS  DC    8AL1(C'S'+*-TBLGRPS)
         ORG   TBLUPPER+256
         SPACE 2
TBLBLNK  DC    256X'00'
         ORG   TBLBLNK+C' '
         DC    X'01'
         ORG
         TITLE 'ERROR MESSAGE NUMBER EQUATES'
**********************************************************************
*              E R R O R    M E S S A G E    N U M B E R S           *
**********************************************************************
         SPACE
MSG1     EQU   1
MSG2     EQU   2
MSG3     EQU   3
MSG4     EQU   4
MSG5     EQU   5
MSG6     EQU   6
MSG7     EQU   7
MSG8     EQU   8
MSG9     EQU   9
MSG10    EQU   10
MSG11    EQU   11
MSG12    EQU   12
MSG13    EQU   13
MSG14    EQU   14
MSG15    EQU   15
MSG16    EQU   16
MSG17    EQU   17
MSG18    EQU   18
MSG19    EQU   19
MSG20    EQU   20
MSG21    EQU   21
MSG22    EQU   22
MSG23    EQU   23
MSG24    EQU   24
MSG25    EQU   25
MSG26    EQU   26
MSG27    EQU   27
MSG28    EQU   28
MSG29    EQU   29
MSG30    EQU   30
MSG31    EQU   31
MSG32    EQU   32
MSG33    EQU   33
MSG34    EQU   34
MSG35    EQU   35
MAXMSG   EQU   MSG35
         END
