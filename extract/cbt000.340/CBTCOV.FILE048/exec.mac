./ ADD NAME=RISPFPRT 0128-91095-93098-0700-00041-00006-00000-$A1238
        /* rexx */
        /* corrected to not update zcmd if not under bookmanager zpplid

        Address ISPEXEC "VGET (ZPRDSN ZPRMEM ZPROPT ZPRLPRT ZPRVOLSE)"
        Address ISPEXEC "VGET (ZPRDSORG ZPRRECFM ZPRPMD ZPRSYSO zapplid)

        zcmd = ""
        Address ISPEXEC "VPUT (ZCMD)"

        if zprpmd = "LOCAL" then do
           if zprlprt <> '' then dest = "DEST("zprlprt")"

           if zpropt = "K" then nodel = "NODEL"

           if zprmem <> '' then dsn = zprdsn"("zprmem")"
                           else dsn = zprdsn

           "%RPRINT  '"dsn"'  VOL("zprvolse")" nodel  dest "NOX"

           if zpropt = "D" then do
              x = msg("off")
              if sysdsn("'"dsn"'") = "OK" then "DELETE" "'"dsn"'"
              x = msg("on")
              end

           Address ISPEXEC "Control NONDISPL END"

           /* test code for return processing for
              BookManager Read/MVS                 */
           if wordpos(zapplid,"EOXR EOYR") > 0 then do
              zcmd   = "P"
              Address ISPEXEC "VPUT (ZCMD)"
              end
           Exit 0
        end
           else Exit 4
           /*  Leave with a return code of 4         *
            *  which causes ISPF print services to   *
            *  generate the necessary JCL and to     *
            *  submit the JCL when the users exits   *
            *  the dialog.                           */
./ ADD NAME=RPRINT   0110-92002-93085-0655-00198-00170-00000-$A1238
        /* ---------------------  rexx procedure  ----------------------
         * Name:      RPRINT
         *
         * Function:  Interface to Rockwell Print ISPF Dialogs
         *
         *
         * Syntax:    %RPRINT dsname DEST(dest) CC(x)
         *                    NODEL VOL(volume) NOX NOED
         *
         * Error:     If data set not found then ISPF messages issued.
         *
         * Options:    NODEL - do not allow delete from menu
         *             NOX   - do not display Xerox options
         *             NED   - do not allow Edit
         *
         * Notes:     1.  Volume is ONLY support for the Rockwell
         *                PRINTOFF ISPF Dialog and not the others.....
         *
         * Author:    Lionel B. Dyck
         *            Rockwell International
         *            P.O. Box 2515
         *            Seal Beach, California 90740
         *            (310) 797-1125
         *            IBMMAIL:  USROKNTN
         *
         * History:
         *            10/29/92  Add noed option
         *
         *            04/10/92  Support for AFP LIST38xx dialog. .
         *
         *            01/02/92  Correction to support Xerox again.
         *
         *            06/17/91  Added NOX option to not display the
         *                      Xerox dialogs because they do not work
         *                      when used under an ISRFPA.
         *
         *            04/09/91  Converted from CLIST to REXX
         *
         * -------------------------------------------------------------

        arg options

        parse value options with rpdsn .  1 "DEST(" dest ")" 1 ,
                    "CC(" cc ")" 1 "VOL(" volume ")"

        del = "on"
        hold_dsn = rpdsn

        if wordpos("NODEL",options) > 0 then del = 'off'
        if wordpos("NOX",options) > 0 then nox = "off"
                                      else nox = "on"
        if wordpos("NOED",options) > 0 then noed = "off"
                                       else noed = "on"

        if sysdsn(rpdsn) <> "OK" then do
           zedsmsg = "Error"
           zedlmsg = sysdsn(rpdsn)
           signal exit
           end

        if pos(".LIST3820",rpdsn) > 0 then afp_ds = "on"
        if pos(".LIST38PP",rpdsn) > 0 then afp_ds = "on"

        if afp_ds = "on" then do
           Address ISPEXEC "DISPLAY PANEL(RPRINT38)"
           if rc > 0 then signal exit
           "PR DS("rpdsn") DEST("dest") COPIES("rp38cpy") NOTITLE OUTDES
           signal exit
           end

        do forever
        rpdsn = hold_dsn
        dsn   = hold_dsn
        if cc = 'X' then cc = ''

        Address ISPEXEC "DISPLAY PANEL(RPRINT)"
        if rc > 0 then signal exit

        opts = ''
        rpdsn_nq = rpdsn
        if left(rpdsn,1) = "'" then rpdsn = "''"rpdsn"''"

         select
           when rpopt = 1 then do
             if dest <> '' then do
               opts = "RPODEST("dest")"
             end
             if cc <> '' then do
               opts = opts "RPOCC("cc")"
             end
             if volume <> '' then do
               opts = opts "RPOVOL("volume")"
             end
               opts = "DSN("rpdsn")" opts
             /*  Invoke the Printoff dialog  */
             "%ROCPUCPO" opts
           end
           when rpopt = 2 then do
             if dest <> '' then do
               opts = "RPVPNODE("dest")"
             end
             if cc <> '' then do
               opts = opts "RPVPCC("cc")"
             end
             opts = "DSN("rpdsn")" opts
             /* Invoke the VPS Print ISPF Dialog */
             "%ROCPUCVP" opts
           end
           when rpopt = 3 then do
             if dest <> '' then do
               opts = "PRTDEST("dest")"
             end
             else do
                  Address ISPEXEC "VGET (PRTDEST) PROFILE"
                          if dest <> '' then do
                             opts = "PRTDEST("dest")"
                          end
                  end
             if cc <> '' then do
               opts = opts "PRTCC("cc")"
             end
             opts = "DSN("rpdsn")" opts
             /* Invoke the Rockwell AFP ISPF Print Dialog */
             "%ROCPUC06" opts
           end
           when rpopt = 4 then do
             if dest <> '' then do
               x27dest = dest
               Address ISPEXEC "VPUT (X27DEST) PROFILE"
             end
             if cc <> '' then do
               Address ISPEXEC "VPUT (CC) PROFILE"
             end
             dsn = rpdsn_nq
             Address ISPEXEC "VPUT (DSN) PROFILE"
             Address ISPEXEC "CONTROL ERRORS RETURN"
             Address ISPEXEC "SELECT PGM(ISRFPR) PARM((ROCPUP27))  NEWPO
             Address ISPEXEC "CONTROL ERRORS CANCEL"
             dsn = ''
             cc  = ''
             Address ISPEXEC "VPUT   (DSN CC) PROFILE"
             Address ISPEXEC "VERASE (DSN CC) PROFILE"
           end
           when rpopt = 5 then do
             if dest <> '' then do
               x97dest = dest
               Address ISPEXEC "VPUT (X97DEST) PROFILE"
             end
             if cc <> '' then do
               Address ISPEXEC "VPUT (CC) PROFILE"
             end
             dsn = rpdsn_nq
             Address ISPEXEC "VPUT (DSN) PROFILE"
             Address ISPEXEC "CONTROL ERRORS RETURN"
             Address ISPEXEC "SELECT PGM(ISRFPR) PARM((ROCPUP97))  NEWPO
             Address ISPEXEC "CONTROL ERRORS CANCEL"
             dsn = ''
             cc  = ''
             Address ISPEXEC "VPUT   (DSN CC) PROFILE"
             Address ISPEXEC "VERASE (DSN CC) PROFILE"
           end
           when rpopt = "B" then do
             Address ISPEXEC "CONTROL ERRORS RETURN"
             Address ISPEXEC "BROWSE DATASET("rpdsn_nq")"
             Address ISPEXEC "CONTROL ERRORS CANCEL"
           end
           when rpopt = "D" then do
             if del = "on" then do
                 "DELETE" rpdsn_nq
                 zedsmsg = "Deleted"
                 zedlmsg = "Data set" rpdsn_nq "Deleted"
                 signal exit
               end
               else do
                 zedsmsg = "Invalid"
                 zedlmsg = "Delete not allowed for this data set:" rpdsn
                Address ISPEXEC "SETMSG MSG(ISRZ000)"
               end
           end
           when rpopt = "E" then do
             if noed = "on" then do
             Address ISPEXEC "CONTROL ERRORS RETURN"
             Address ISPEXEC "EDIT DATASET("rpdsn_nq")"
             Address ISPEXEC "CONTROL ERRORS CANCEL"
             end
             else do
                 zedsmsg = "Invalid"
                 zedlmsg = "Edit is not allowed for this data set:" rpds
                Address ISPEXEC "SETMSG MSG(ISRZ000)"
               end
           end
           otherwise nop;
         end  /* end select */

        end

        Exit:
         Address ISPEXEC "SETMSG MSG(ISRZ000)"
./ ADD NAME=SOFTPBB  0121-93077-93160-1319-00355-00295-00000-$A1238
        /* ---------------------  rexx procedure  ----------------------
         * Name:      SOFTPBB
         *
         * Function:  Called by SOFTPUBA to BUILD the ISPF tables used
         *            by the Softcopy dialog.
         *
         * Syntax:    %SOFTPBB build_table prod_table debug
         *
         * Author:    Lionel B. Dyck
         *            Rockwell International
         *            P.O. Box 2515
         *            Seal Beach, California 90740
         *            (310) 797-1125
         *            IBMMail:  USROKNTN
         *            Internet: lbdyck@osreq48.rockwell.com
         *            IBMLINK:  ROK2027
         *
         * History:
         *            03/18/93 - build softpall table of all items
         *            02/10/93 - support for multiple access records
         *
         * -------------------------------------------------------------

        parse arg build_table prod_table debug access_table.

        if debug = "on" then trace i

        null     = ""
        ddn      = "SFT"random()
        table_id = 1000
        level    = 1
        hold_access.  = null
        hold_access.0 = 0

        table = strip(build_table,,"'")
        if "OK" <> sysdsn("'"table"(BUILD)'") then do
           smsg = null
           lmsg = "The requested build data set is not valid as",
                  "the BUILD member does not exist in data set: ",
                  build_table
           call Exit_Build
           end

        Address ISPEXEC,
          "LMINIT DATAID(dataid) DATASET("build_table") ENQ(SHRW)"

        Call Clean_Build_Dataset

        prod  = strip(prod_table,,"'")
        if sysdsn("'"prod"(GG)'") = "OK" then do
           "Alloc f("ddn") SHR Reuse DS('"prod"(GG)')"
           "Execio * Diskr" ddn "(Finis Stem g."
           gg = g.1 + 1
           if gg = 100 then gg = 0
           end
           else gg = 1

        "Alloc f("ddn") SHR Reuse DS('"table"(GG)')"
        g.1 = gg
        "Execio * Diskw" ddn "(Finis Stem g."
        "Free  f("ddn")"
        drop g.

        gg = gg + 100

        "Alloc f("ddn") SHR DS('"table"(BUILD)')"
        "Execio * Diskr" ddn "(Finis Stem build."
        "Free f("ddn")"

        "Alloc f("ddn") SHR Reuse DS('"table"(MASTER)')"
        "Execio * Diskw" ddn "(Finis Stem build."
        "Free f("ddn")"

        Address ISPEXEC

        "Lmmstats Dataid("dataid") Member(MASTER)"

        "Libdef SOFTPB Dataset ID("build_table")"

        "TBCREATE SOFTCOPY NAMES(type desc data access)",
                          "Library(SOFTPB) Write"

        "TBCREATE SOFTPALL NAMES(type desc data access)",
                          "Library(SOFTPB) Write"

        parse value null with tables item
        table  = "SOFTCOPY"
        cat    = table

        Do i = 1 to build.0
           if left(build.i,1) = "*" then iterate
           row = translate(build.i)
           call Please_Wait
           Select
             When left(row,1) = "C" then call New_Category
             When left(row,1) = "S" then call Do_Shelf
             When left(row,1) = "B" then call Do_Book
             When left(row,1) = "A" then call Do_Access
             When left(row,1) = "E" then call End_Category
             otherwise say "Error in row:" build.i
             end
        end

        If level > 0 then do
           /* close out all open tables */
           count = words(tables)
           do i = 1 to count
              table = word(tables,i)
              call Sort_Close_Table
              end
           end

        /* signal skip_all */
           type = "C"
           data = "SOFTPALL"
           desc = "Default Bookshelves"
           "TBADD" table
        skip_all:

        table = "SOFTCOPY"
         call Sort_Close_Table

        table = "SOFTPALL"
         call Sort_Close_Table

        "Lmmstats Dataid("dataid") Member(GG)"
        "Libdef SOFTPB"
        "LMFREE DATAID("dataid")"

        Exit_Build:
           Address ISPEXEC "VPUT (SMSG LMSG)"
           Address ISPEXEC "Setmsg Msg(SOFTP000)"
           exit 0

        New_Category:
          level = level + 1
          table_id = table_id + 1
          prev_table = table
          tables = tables table
          table = "SFT"right(gg,2)right(table_id,3)
          type   = "C"
          data   = table
          desc   = strip(substr(build.i,3,78))
          cat    = table
          access = null
          "TBADD" prev_table
          "TBCREATE" table "NAMES(type desc data access)",
                           "Library(SOFTPB) Write"
          return

        End_Category:
          level  = level - 1
          cnt    = words(tables) - 1
          tables = subword(tables,1,cnt)
          call Sort_Close_Table
          table      = prev_table
          if cnt = 0 then prev_table = table
             else prev_table = word(tables,cnt)
          if access_table.table = "on" then do
             call end_access
             access_table.table = null
             end
          return

        End_Access:
          if hold_access.0 = 1 then do
             hold_access.0 = 0
             hold_access.1 = null
             accdata       = null
             end
          if hold_access.0 > 1 then do
             acclev  = hold_access.0 - 1
             accdata = hold_access.acclev
             hold_access.0 = acclev
             acclev  = acclev + 1
             hold_access.acclev = null
             end
          return

        Sort_Close_Table:
              "TBSort"  table "Fields(DESC,C,A)"
              "TBCLOSE" table "Library(SOFTPB)"
              "Lmmstats Dataid("dataid") Member("table")"
          return

        Do_Shelf:
          type   = "S"
          data   = word(build.i,2)
          access = null
          desc = subword(build.i,3)
          if desc = "" then do
             if sysdsn("'"data"'") <> "OK" then return
             Address TSO
               "Alloc f("ddn") Shr Reuse Ds('"data"')"
               "Execio * Diskr" ddn "(Finis Stem d."
               "Free  f("ddn")"
             Address ISPEXEC
             do c = 1 to d.0
                title = translate(d.c)
                if left(title,9) <> "BKSTITLE=" then iterate
                desc = strip(substr(d.c,10,70))
                leave
                end
             drop d.
             end
          item   = desc
          "TBADD" table
          call add_all
          return

        Do_Book:
          type   = "B"
          data   = word(build.i,2)
          access = null
          desc = subword(build.i,3)
          if desc = "" then do
             say "Error in row:" build.i
             say "Description required."
             return
             end
          item   = desc
          "TBADD" table
          call add_all
          return

        Add_All:
           if hold_access.0 > 0 then do
              acclev = hold_access.0
              access = hold_access.acclev
              hdata = data /* $$ */
              end
          "TBADD  SOFTPALL"
           access = null
           return

        Do_Access:
          do forever
             naccess = substr(build.i,3,77)
             access  = translate(strip(access naccess))
             ix = i + 1
                row = translate(build.ix)
                if left(row,1) <> "A" then leave
                i = ix
          end
          call set_access

          if type = "C" then do
             "TBPUT" prev_table
             access_table.prev_table = "on"
             end
             else do
                  "TBPUT" table
                  if length(accdata) > 0 then do
                     access = accdata
                     "TBPUT SOFTPALL"
                     call end_access
                     access = null
                     end
                  end
          return

        Set_Access:
          acclev  = hold_access.0
          if acclev = 0 then accdata = access
                        else accdata = access hold_access.acclev
          acclev  = acclev + 1
          call clean_access
          hold_access.acclev = accdata
          hold_access.0 = acclev
        return

        Clean_access: procedure expose accdata
        count = words(accdata)
        parse value "" with c. all
        c.0 = 0
        do i = 1 to count
           current = word(accdata,i)
           hit = ""
           do j = 1 to c.0
              if c.j = current then hit = "y"
              end
           if hit  = "" then do
              cc   = c.0 + 1
              c.cc = current
              c.0  = cc
              all  = all current
           end
        end
        accdata = strip(all)
        return

        Clean_Build_Dataset:
        /* ----------------------------------------------- *
         * Clean_Build_Dataset                             *
         *                                                 *
         * Removes all members from the BUILD Table Dataset*
         * except the member BUILD, MASTER and OMASTER.    *
         * Members REPORT and NEWSHELF are also retained.  *
         *                                                 *
         * Remove all OMAST after 5.                       *
         * ----------------------------------------------- */
        x = outtrap("lm.","*")

           "LISTD "build_table" MEMBERS"

        x = outtrap("off")

        Address ISPEXEC

         "LMOPEN DATAID("dataid") OPTION(OUTPUT)"

        do i = 1 to lm.0
           if lm.i = "--MEMBERS--" then signal domem
           end

        domem:  do j = lm.0 to i+1 by -1
                parse value lm.j with mem extra
                do_del = null
                if mem = "MASTER" then call new_mast
                if wordpos(mem,"SOFTCOPY SOFTPALL",1) > 0 then do_del =
                if left(mem,5) = "OMAST" then call new_mast
                if left(mem,3) = "SFT"   then do_del = "y"
                call del_mem
                end

        "LMCLOSE DATAID("dataid")"

        Address TSO
        return

        Please_Wait:
         Address ISPEXEC "Control Display Lock"
         Address ISPEXEC "Display Panel(SOFTPBWT)"
        return

        del_mem:
        if do_del <> null then
           "LMMDEL DATAID("dataid") MEMBER("mem")"
        return

        new_mast:
          if mem = "MASTER" then do
             "LMMREN DATAID("dataid") Member(MASTER) NEWNAME(OMAST001)"
             return
             end
          num = right(mem,3)
          if num > 4 then do
             do_del = "y"
             end
          else do
               num = num + 1001
               new_mem = "OMAST"right(num,3)
               "LMMREN DATAID("dataid") Member("mem") NEWNAME("new_mem")
             end
        return
./ ADD NAME=SOFTPBC  0134-93026-93209-0653-00248-00147-00000-$A1238
        /* ---------------------  rexx procedure  ----------------------
         * Name:      SOFTPBC
         *
         * Function:  Called by SOFTPBA to:
         *
         *            1. clean up old members in the production
         *               softcopy table data set
         *
         *            2. Copy the newly built tables from the build
         *               table data set into production.
         *
         * Syntax:    %SOFTPBC build_table prod_table debug
         *
         * Author:    Lionel B. Dyck
         *            Rockwell International
         *            P.O. Box 2515
         *            Seal Beach, California 90740
         *            (310) 797-1125
         *            IBMMail:  USROKNTN
         *            Internet: lbdyck@osreq48.rockwell.com
         *            IBMLINK:  ROK2027
         *
         * History:
         *            05/18/93 - correct delete statement in batch job.
         *
         * -------------------------------------------------------------

        parse arg build_table prod_table debug

        if debug = "on" then trace i

        null     = ""
        ddn      = "RIS"random()

        build = strip(build_table,,"'")
        prod  = strip(prod_table,,"'")

        Address ISPEXEC,
          "LMINIT DATAID(buildid) DATASET("build_table") ENQ(SHRW)"
        Address ISPEXEC,
          "LMINIT DATAID(prodid) DATASET("prod_table") ENQ(SHRW)"

        Call Clean_Prod_Dataset

        Call Copy_Build_to_Prod

        Call Transmit_Table

        Address ISPEXEC
          "LMFREE DATAID("prodid")"
          "LMFREE DATAID("buildid")"

        smsg = null
        lmsg = "Copy from BUILD into PRODUCTION is now complete."
        "VPUT (SMSG LMSG)"
        "SETMSG MSG(SOFTP000)"
        Exit 0

        Transmit_Table:
        /* ----------------------------------------------- *
         * Issue MVS/BDT to transmit the table to other    *
         * centers                                         *
         *                                                 *
         * Also submit a batch tmp job to clean out old    *
         * members in the table data set.                  *
         * ----------------------------------------------- */
        "%SOFTPDFT"
        Address ISPEXEC "Vget Centers"
        members = tran_mem.1
        do i = 2 to tran_mem.0
           members = members","tran_mem.i
           end
        x = outtrap("trap.","*")
        do c = 1 to words(centers)
           center = word(centers,c)
           call bdt_deljob
           Address ISPEXEC
           "Control Display Lock"
           "Display Panel(SOFTPBWB)"
           Address TSO
              "BDT Q FROM LOC("home") DS("build_table") SHR ",
                  "PARM(R=Y S M=("members")) DAP(PDS) ",
                  "TO LOC("word(centers,c)") SHR DAP(PDS) ",
                  "DS("prod_table") PARM(MSG=S)"
           end
        x = outtrap("off")
        return

        Copy_Build_to_Prod:
        /* ----------------------------------------------- *
         *                                                 *
         * Copy Build into Prod                            *
         *                                                 *
         * ----------------------------------------------- */

        "Alloc f("ddn") SHR Reuse DS('"build"(GG)') Reuse"
        "Execio * Diskr" ddn "(Finis Stem g."
        "Free  f("ddn")"
        gg = g.1

        tran_mem.  = ""
        tran_mem.0 = 0

        "Showtso Center"
        home  = center

        drop lm.
        x = outtrap("lm.","*")

           "LISTD "build_table" MEMBERS"

        x = outtrap("off")

        Address ISPEXEC

        do i = 1 to lm.0
           if lm.i = "--MEMBERS--" then signal ckmem
           end

        ckmem:  do j = lm.0 to i+1 by -1
                parse value lm.j with mem extra
                do_copy = null
                if left(mem,4) = "MAST" then do_copy = "on"
                if mem         = "GG" then do_copy = "on"
                if left(mem,3) = "SFT" then do
                   w_gg = substr(mem,4,2)
                   if w_gg = gg then do_copy = "on"
                   end
                call copy_mem
                end

        /* now copy the def table */
        mem = "SOFTPALL"
        do_copy = "on"
        call copy_mem

        /* now copy the key table */
        mem = "SOFTCOPY"
        do_copy = "on"
        call copy_mem

        "LMCLOSE DATAID("prodid")"

        Address TSO
        return

        Copy_Mem:
        if do_copy = null then return

         "Control Display Lock"
         "Display Panel(SOFTPBWC)"

        tc          = tran_mem.0 + 1
        tran_mem.tc = mem
        tran_mem.0  = tc

        "LMCopy Fromid("buildid") todataid("prodid")",
           "Replace Frommem("mem") Tomem("mem")"
        return

        Clean_Prod_Dataset:
        /* ----------------------------------------------- *
         * Clean_Prod_Dataset                              *
         *                                                 *
         * Remove old SFT members                          *
         * ----------------------------------------------- */

        if sysdsn("'"prod"(GG)'") <> "OK" then gg = 00
           else do
               "Alloc f("ddn") SHR Reuse DS('"prod"(GG)')"
               "Execio * Diskr" ddn "(Finis Stem g."
               "Free  f("ddn")"
               gg = g.1
               end

        x = outtrap("lm.","*")

           "LISTD "prod_table" MEMBERS"

        x = outtrap("off")

        Address ISPEXEC

        "LMOPEN DATAID("prodid") OPTION(OUTPUT)"

        del_member.  = null
        del_member.0 = 0

        do i = 1 to lm.0
           if lm.i = "--MEMBERS--" then signal domem
           end

        domem:  do j = lm.0 to i+1 by -1
                parse value lm.j with mem extra
                do_del = null
                if left(mem,5) = "OMAST" then do_del = "on"
                if left(mem,3) = "SFT" then do
                   w_gg = substr(mem,4,2)
                   if (w_gg + 1) > gg  then do_del = null
                      else do_del = "on"
                   end
                if do_del <> null then
                   call del_mem
                end

        "LMCLOSE DATAID("prodid")"

        Address TSO
        return

        del_mem:
        if do_del = null then return
           "LMMDEL DATAID("prodid") MEMBER("mem")"
           cnt            = del_member.0 + 1
           del_member.cnt = mem
           del_member.0   = cnt
        return

        BDT_Deljob:
        /* ----------------------------------------------- *
         *                                                 *
         * build and submit batch job to clean out         *
         * softcopy table data set.                        *
         *                                                 *
         * ----------------------------------------------- */
        if del_job <> "on" then do
           Address ISPEXEC "VGET (Ztempf Zacctnum)"
           jcl.  = null
           jcl.0 = 6
           jcl.1 = "//"left(sysvar(sysuid),8)" JOB '"left(zacctnum,52)"'
           id=sysvar(sysuid)
           jcl.2 = "// PRTY=3,MSGLEVEL=(1,1),TIME=5,MSGCLASS=T,NOTIFY="i
           jcl.3 = "//*ROUTE XEQ" center
           jcl.4 = "//STEP EXEC PGM=IKJEFT01,DYNAMNBR=50"
           jcl.5 = "//SYSTSPRT  DD SYSOUT=*"
           jcl.6 = "//SYSTSIN   DD *"
           do mc = 1 to del_member.0
              cc = jcl.0 + 1
              jcl.cc = " DELETE '"prod"("del_member.mc")'"
              jcl.0 = cc
              end
           end
           jcl.3 = "//*ROUTE XEQ" center
           "Alloc f("ddn") Shr Reuse Dsn('"ztempf"')"
           "Execio * diskw" ddn "(Finis stem jcl."
           "Free  f("ddn")"
           "Submit '"ztempf"'"
        return
./ ADD NAME=SOFTPBFX 0102-93195-93195-1253-00074-00073-00000-$A1238
        /* ---------------------  rexx procedure  ----------------------
         * Name:      SOFTPBFX
         *
         * Function:  Called by the update shelf routine when it is
         *            necessary to update a new BKSHELF with the
         *            correct dsnames and then rename the BKSHELF to
         *            remove the 2nd qualifier of UPLOAD.
         *
         * Syntax:    %SOFTPBFX dsname
         *
         * Author:    Lionel B. Dyck
         *            Rockwell International
         *            P.O. Box 2515
         *            Seal Beach, California 90740
         *            (310) 797-1125
         *            IBMMail:  USROKNTN
         *            Internet: lbdyck@osreq48.rockwell.com
         *            IBMLINK:  ROK2027
         *
         * History:
         *            07/14/93 - created from SOFTPBRP
         * -------------------------------------------------------------

        arg dsn

        ddn        = "BK"random()

        "%SOFTPDFT"
        Address ISPEXEC "VGET (INDEX)"

        dsname = strip(dsn)
        if left(dsname,1) = "'" then
           parse value dsname with "'" dsname "'"
        "Alloc f("ddn") Shr Reuse Ds('"dsname"')"
        "Execio * Diskr" ddn "(Finis Stem Book."
        "Free  f("ddn")"
        say 'Processing dsname:' dsname

        book_out.  = ""
        book_out.0 = 0
        do j = 1 to book.0
          if left(book.j,9) = "BKSTITLE=" then
             parse value book.j with "BKSTITLE=" title
          if left(book.j,7) = "BKNAME=" then do
             bc         = book_out.0 + 1
             book_out.0 = bc
             parse value book.j with "BKNAME=" name .
             book_out.bc = "BKMDSN=ABOOK."name".BOOK"
             end
          if left(book.j,9) = "BKSINDEX=" then do
             parse value book.j with "BKSINDEX=" name .
             if name = null then
                parse value dsname with index".UPLOAD." name ".BKSHELF"
             bc         = book_out.0 + 1
             book_out.0 = bc
             book_out.bc = "BKSIMDSN=ABOOK."name".BKINDEX"
             end
          bc         = book_out.0 + 1
          book_out.0 = bc
          book_out.bc = book.j
          end
        say "Updateing" dsname "for correct book names."
        "Alloc f("ddn") Shr Reuse Ds('"dsname"')"
        "Execio * Diskw" ddn "(Finis Stem Book_Out."
        "Free  f("ddn")"
        old_dsn = dsname
        parse value dsname with index".UPLOAD." bksname ".BKSHELF" .
        dsname = index"."bksname".BKSHELF"
        if sysdsn("'"dsname"'") = "OK" then do
           say "Doing delete for old" dsname
           "DELETE '"dsname"'"
           end
        say "Doing rename of" old_dsn "to" dsname
        "Rename '"old_dsn"' '"dsname"'"
./ ADD NAME=SOFTPBKL 0104-93070-93085-0655-00077-00081-00000-$A1238
        /* ---------------------  rexx procedure  ----------------------
         * Name:      name
         *
         * Function:  Create list of all books on a set of .BKSHELF
         *            the list of shelves if found in member NEWSHELF
         *            of the build softcopy table data set.
         *
         * Syntax:    %softpbkl
         *
         *
         * Author:    Lionel B. Dyck
         *            Rockwell International
         *            P.O. Box 2515
         *            Seal Beach, California 90740
         *            (310) 797-1125
         *            IBMMail:  USROKNTN
         *            Internet: lbdyck@osreq48.rockwell.com
         *            IBMLINK:  ROK2027
         *
         * History:   mm/dd/yy
         *            comments
         *
         * -------------------------------------------------------------

        "%Softpdft"
        Address ISPEXEC "Vget build"

        parse value build with "'" dsn "'"
        newshelf = "'"dsn"(NEWSHELF)'"
        newbooks = "'"dsn"(NEWBOOKS)'"

        dd = "bkl"random()

        "Alloc f("dd") shr reuse dsn("newshelf")"
        "Execio * diskr" dd "(Finis stem bkl."
        "Free  f("dd")"

        books.  = ""
        books.0 = 0

        do bkl = 1 to bkl.0
           parse value bkl.bkl with dsn .
           drop bks.
           "Alloc f("dd") shr reuse dsn('"dsn"')"
           "Execio * diskr" dd "(finis stem bks."
           "Free  f("dd")"
           call get_books
           end

        "Alloc f("dd") shr reuse dsn("newbooks")"
        "Execio * diskw" dd "(finis stem books."
        "Free  f("dd")"
        exit 0

        Get_Books:
        parse value "" with bknum bkname bkdate
        do bks = 1 to bks.0
           Select
             When left(bks.bks,2) = "SH" then
                  bknum = substr(bks.bks,3,9)
             When left(bks.bks,2) = "ST" then
                  parse value bks.bks with "ST" bkname
             When left(bks.bks,10) = "BKDATETIME" then
                  parse value bks.bks with "BKDATETIME=" bkdate .
             Otherwise nop;
             end

           if bknum  = "" then iterate
           if bkname = "" then iterate
           if bkdate = "" then iterate

           x = books.0 + 1
           books.0 = x
           books.x = bknum substr(bkname,1,60) bkdate
           parse value "" with bknum bkname bkdate
           end
        Return
./ ADD NAME=SOFTPBRP 0119-93022-93209-0654-00168-00101-00000-$A1238
        /* ---------------------  rexx procedure  ----------------------
         * Name:      SOFTPBRP
         *
         * Function:  Create in the build table data set member REPORT
         *            which lists each dsname and the book shelf title
         *            for every bkshelf.
         *
         *            Also update every newly uploaded BKSHELF with the
         *            correct dsnames and then rename the BKSHELF to
         *            remove the 2nd qualifier of UPLOAD.
         *
         * Syntax:    %SOFTPBRP
         *
         * Author:    Lionel B. Dyck
         *            Rockwell International
         *            P.O. Box 2515
         *            Seal Beach, California 90740
         *            (310) 797-1125
         *            IBMMail:  USROKNTN
         *            Internet: lbdyck@osreq48.rockwell.com
         *            IBMLINK:  ROK2027
         *
         * History:
         *            05/14/93 - updated to use mvs/bdt to send new
         *                       shelfs, index and books to other
         *                       centers
         * -------------------------------------------------------------

        "%SOFTPDFT"
        Address ISPEXEC "VGET (BUILD INDEX Centers)"

        build_table = strip(build,,"'")
        report.     = ""
        report.0   = 0
        ddn        = "BK"random()

        x = outtrap("listc.","*")
        "LISTC LEVEL("index")"
        x = outtrap("OFF")

        do i = 1 to listc.0
           if substr(listc.i,2,1) = " " then iterate
           parse value listc.i with "NONVSAM -------" dsname
             if pos(".BKSHELF",dsname) > 0 then call do_bkshelf
           end

        "Alloc f("ddn") ds('"build_table"(REPORT)') Shr Reuse"
        "Execio * Diskr" ddn "(Finis Stem old."
        "Execio * Diskw" ddn "(Finis Stem report."
        "Free  f("ddn")"

        do i = 1 to old.0
           name = word(old.i,1)
           oldname.name = "on"
           end
        new.  = ""
        new.0 = 0
        do i = 1 to report.0
           name = word(report.i,1)
           if oldname.name = "on" then iterate
           cnt     = new.0 + 1
           new.0   = cnt
           new.cnt = report.i
           end

        if new.0 > 0 then do
           say "New Book Shelves found.  Creating" build_table"(NEWSHELF
           "Alloc f("ddn") ds('"build_table"(NEWSHELF)') Shr Reuse"
           "Execio * Diskw" ddn "(Finis Stem new."
           "Free  f("ddn")"
        end
        else say "No new Book Shelves found.",
             build_table"(NEWSHELF) not updated."

        Exit 0

        do_bkshelf:
        dsname = strip(dsname)
        "Alloc f("ddn") Shr Reuse Ds('"dsname"')"
        "Execio * Diskr" ddn "(Finis Stem Book."
        "Free  f("ddn")"
        say 'Processing dsname:' dsname
        if pos(".UPLOAD.",dsname) > 0 then call Fix_Upload
                                      else call Get_Title
        cnt        = report.0 + 1
        report.0   = cnt
        report.cnt = dsname title
        say 'Reporting:' report.cnt
        drop book.
        return

        Get_Title:
        do j = 1 to book.0
          if left(book.j,9) = "BKSTITLE=" then do
             parse value book.j with "BKSTITLE=" title
             return
             end
        end
        return

        Fix_Upload:
        book_out.  = ""
        book_out.0 = 0
        do j = 1 to book.0
          if left(book.j,9) = "BKSTITLE=" then
             parse value book.j with "BKSTITLE=" title
          if left(book.j,7) = "BKNAME=" then do
             bc         = book_out.0 + 1
             book_out.0 = bc
             parse value book.j with "BKNAME=" name .
             book_out.bc = "BKMDSN=ABOOK."name".BOOK"
             end
          if left(book.j,9) = "BKSINDEX=" then do
             parse value book.j with "BKSINDEX=" name .
             if name = null then
                parse value dsname with index".UPLOAD." name ".BKSHELF"
             bc         = book_out.0 + 1
             book_out.0 = bc
             book_out.bc = "BKSIMDSN=ABOOK."name".BKINDEX"
             end
          bc         = book_out.0 + 1
          book_out.0 = bc
          book_out.bc = book.j
          end
        say "Updateing" dsname "for correct book names."
        "Alloc f("ddn") Shr Reuse Ds('"dsname"')"
        "Execio * Diskw" ddn "(Finis Stem Book_Out."
        "Free  f("ddn")"
        old_dsn = dsname
        parse value dsname with index".UPLOAD." bksname ".BKSHELF" .
        dsname = index"."bksname".BKSHELF"
        if sysdsn("'"dsname"'") = "OK" then do
           say "Doing delete for old" dsname
           "DELETE '"dsname"'"
           end
        say "Doing rename of" old_dsn "to" dsname
        "Rename '"old_dsn"' '"dsname"'"
        call do_bdt "'"dsname"'"
        return

        /* -------------------------------------------------------------
         * Do_BDT routine is used to issue the MVS/BDT command....
         * -------------------------------------------------------------
        Do_BDT: procedure expose centers
        arg filedsn
        call listdsi filedsn 'directory'

        center=showrexx("CENTER")

        if sysdsorg = "PS" then dap = "SEQ"
                           else dap = "PDS"
           alloc = "CYLINDER TRACK BLOCK"
           units = wordpos(sysunits,alloc)
           units = word(alloc,units)
           if units = "BLOCK" then units = "TRACK RLSE"
           disp_opt = "New Recfm("sysrecfm") Lrecl("syslrecl")" ,
                      "Blksize("sysblksize") Space("sysused","sysseconds
                      "Unit(SYSTS)"
           if dap = "PDS" then disp_opt = disp_opt "Dir("sysadirblk")"

        say "Transmitting file:" filedsn "to centers:" centers

        do i = 1 to words(centers)
            "BDT Q From Loc("center") DS("filedsn") Shr Dap("dap")" ,
                  "To   Loc("word(centers,i)") DS("filedsn") Dap("dap")"
                  disp_opt
           end
        return
./ ADD NAME=SOFTPDFT 0123-93022-93085-0655-00019-00005-00000-$A1238
        /* rexx */

        signal do_prod

        build   = "'$a1238.SOFTCOPY.TABLE'"
        Prod    = "'$a1238.SOFTPUB.TABLE'"
        Index   = "$a1238"
        Centers = " "
        Address ISPEXEC,
          "VPUT (BUILD PROD INDEX CENTERS) SHARED"
        exit 0

        do_prod:
        build   = "'ABOOK.SOFTCOPY.TABLE'"
        Prod    = "'ABOOK.SOFTPUB.TABLE'"
        Index   = "ABOOK"
        Centers = "WCC2 SWCC SWC2"
        Address ISPEXEC,
          "VPUT (BUILD PROD INDEX CENTERS) SHARED"
./ ADD NAME=SOFTPES  0109-93054-93195-1259-00073-00061-00000-$A1238
        /* ---------------------  rexx procedure  ----------------------
         * Name:      SOFTPES
         *
         * Function:  Called by SOFTPUBA to Edit a Book Shelf and then
         *            transmit the updated shelf to other centers
         *
         * Syntax:    %SOFTPES
         *
         * Author:    Lionel B. Dyck
         *            Rockwell International
         *            P.O. Box 2515
         *            Seal Beach, California 90740
         *            (310) 797-1125
         *            IBMMail:  USROKNTN
         *            Internet: lbdyck@osreq48.rockwell.com
         *            IBMLINK:  ROK2027
         *
         * History:
         *            07/14/93 - update to update single upload shelf
         *            02/23/93 - created.
         *
         * -------------------------------------------------------------

        Do Forever

        Address ISPEXEC

        "Display Panel(Softpes)"
          if rc > 0 then exit

        if sysdsn(shelfdsn) <> "OK" then do
           smsg = "Error"
           lmsg = sysdsn(shelfdsn)
           call do_msg
           end
        else do
             if left(shelfdsn,13) = "'ABOOK.UPLOAD" then do
                Address TSO "%Softpbfx" shelfdsn
                parse value shelfdsn with "'ABOOK.UPLOAD." dsn_ok
                shelfdsn = "'ABOOK."dsn_ok
                new = 1
                end
             "Edit Dataset("shelfdsn")"
             if rc = 0 then new = 1
             if new = 1 then call do_bdt
             end

        end  /* end of do forever */

        /* -------------------------------------------------------------
         * Do_BDT routine is used to issue the MVS/BDT command....
         * -------------------------------------------------------------
        Do_BDT:
        Address TSO "%Softpdft"
        "Vget Centers"
        Address TSO
        "Showtso Center"
        do i = 1 to words(centers)
           "BDT Q From Loc("center") DS("shelfdsn") Shr Dap(SEQ)",
                 "To   Loc("word(centers,i)") DS("shelfdsn") Shr Dap(Seq
           end
        smsg = ""
        lmsg = "Shelf updated and transmitted to:" centers
        Address ISPEXEC
        call do_msg
        return

        /* -------------------------------------------------------------
         * Do_msg routine is used to issue the ISPF Message....
         * -------------------------------------------------------------
        Do_Msg:
           "Setmsg Msg(SOFTP000)"
        return
./ ADD NAME=SOFTPLST 0103-93081-93085-0655-00032-00032-00000-$A1238
        /* ---------------------  rexx procedure  ----------------------
         * Name:      Softplst
         *
         * Function:  Generate a list of items in a Softcopy Table
         *
         *
         * Syntax:    %softplst library table
         *
         * Author:    Lionel B. Dyck
         *            Rockwell International
         *            P.O. Box 2515
         *            Seal Beach, California 90740
         *            (310) 797-1125
         *            IBMMail:  USROKNTN
         *            Internet: lbdyck@osreq48.rockwell.com
         *            IBMLINK:  ROK2027
         *
         * History:   mm/dd/yy
         *            comments
         *
         * -------------------------------------------------------------
         arg library table user

        Address ISPEXEC
        "Vput (table user)"
        "Libdef ISPTLIB Dataset Id("library")"
        "FTOpen Temp"
        "FTIncl Softplst"
        "FTClose"
        "Libdef ISPTLIB"
        "Vget ztempf"
        "Browse Dataset('"ztempf"')"
./ ADD NAME=SOFTPTRN 0103-93074-93085-0655-00244-00230-00000-$A1238
        /* ---------------------  rexx procedure  ----------------------
         * Name:      SOFTPTRN
         *
         * Function:  Called by SOFTPUBA to allow the administrator to
         *            selectively transmit using MVS/BDT book, bkshelf,
         *            bkindex and notep files.
         *
         * Syntax:    %SOFTPTRN
         *
         * Author:    Lionel B. Dyck
         *            Rockwell International
         *            P.O. Box 2515
         *            Seal Beach, California 90740
         *            (310) 797-1125
         *            IBMMail:  USROKNTN
         *            Internet: lbdyck@osreq48.rockwell.com
         *            IBMLINK:  ROK2027
         *
         * History:
         *            03/15/93 - created.
         *
         * -------------------------------------------------------------

        x = outtrap("bdt.","*")
        "%Softpdft"
        Address ISPEXEC "Vget (Index Centers Build)"
        "Showtso Center"
        "Listc Level("index")"
        x = outtrap("off")

        null = ""

        ddn = "BDT"random()
        parse value build with "'" build_dsn "'"

        bdtdsn.   = null
        bdtdsn.0  = 0

        do file = 1 to  bdt.0
           if left(bdt.file,7) <> "NONVSAM" then iterate
           parse value bdt.file with . "-------" filedsn
           filedsn = strip(filedsn)
           parse value filedsn with a '.' b '.' c .
           if wordpos(c,"NOTEP BOOK BKSHELF BKINDEX") = 0 then iterate
           c  = bdtdsn.0 + 1
           bdtdsn.c = filedsn
           bdtdsn.0 = c
           end

        Address ISPEXEC

        do i = 1 to bdtdsn.0
           call do_add
           end

        "TBSort DSNTBL Fields(bdtdsn)"
        table_name = "DSNTBL"

        parse value '1 0 0 0' with crp rowcrp last_find

        User_Display:
        do forever

        usrrfind = "PASSTHRU"
        "VPUT USRRFIND"

        zcmd = null
        if src = 4 then "TBDispl" table_name
           else do
                "TBTOP" table_name
                "TBSKIP" table_name "NUMBER("crp")"
                if rowcrp = 0 then
                   "TBDISPL" table_name "PANEL(SOFTPTRN)"
                   else
                   "TBDISPL" table_name "PANEL(SOFTPTRN)",
                           "CSRROW("rowcrp") AUTOSEL(NO)"
                end
        src = rc
          if src > 4 then do
             "TBEnd" table_name
             Exit 0
             end

        crp = ztdtop
        rowcrp = null

        if row <> null then
           if row > 0 then do
             "TBTop" table_name
             "TBSkip" table_name "NUMBER("row")"
             end

        Usrrfind = null
        "VPUT USRRFIND"

        zcmd_ok = null

        Select
          When words(Zcmd) > 1 then do
               parse value zcmd with o1 o2
               if abbrev("FIND",o1,1) = 1 then call Find_It
               if zcmd_ok <> "ok" then do
                  smsg = "Error"
                  lmsg = "Invalid command:" zcmd
                  call do_msg
                  end
               end
          When zcmd = "RFIND" then do
               zcmd = "RFIND" o2
               call Find_It
               end
          When length(zcmd) = 0 then
             if row <> 0 then
                          if zsel <> null then do
                             if zsel = "N" then call do_bdt bdtdsn "NEW"
                             if zsel = "S" then call do_bdt bdtdsn "SHR"
                             end
          otherwise nop
        end

        signal User_Display
        end

        /* -------------------------------------------------------------
         * Find_it routine to search the table 'desc'  entries for the
         * specified character string.  The search is done using
         * REXX instead of using the ISPF TBSCAN which is very limited.
         * -------------------------------------------------------------
        Find_It:
           zcmd_ok = "ok"
           parse value zcmd with o1 argument
           upper argument
           argument = strip(argument)
           zsel = null
           crp = ztdtop
           find_loop = null
           search = null
           rowid = crp
           if o1 = "RFIND" then do
              last_find = last_find + 1
              "TBTOP" table_name
              "TBSKIP" table_name "Position(ROWID) Number("Last_find")"
              end
              else do
                   "TBSKIP" table_name "Position(ROWID)"
                   end
           if rc = 8 then do
                          s_smsg = "Found - Table Wrapped"
                          "TBTOP" table_name
                          "TBSKIP" table_name "Position(ROWID)"
                          end
                     else s_smsg = "Found"

           /* perform search */

           do forever
              search = translate(bdtdsn)
              if pos(argument,search) > 0 then do
                 crp = rowid + 0
                 rowcrp = crp
                 last_find = crp
                     smsg = s_smsg  /* "Found" */
                     lmsg = argument "found during search in row:" crp
                     call do_msg
                 return
                 end
              "TBSKIP" table_name "POSITION(Rowid)"
              if rc = 8 then do
                    "TBTOP" table_name
                     s_smsg = "Found - Table Wrapped"
                 if find_loop = "on" then do
                     smsg = "Not Found"
                     lmsg = argument "Not found during search"
                     rowid = crp
                     call do_msg
                     return
                     end
                     else find_loop = "on"
                 end
              zsel = null
              end
        return


        Exit 0

        /* -------------------------------------------------------------
         * Do_add routine is used to issue the MVS/BDT command....
         * -------------------------------------------------------------
        Do_Add:
        bdtdsn = bdtdsn.i
           if table <> "open" then do
              "TBCreate DSNTBL Names(bdtdsn stat) Nowrite"
              "TBAdd DSNTBL Mult("bdtdsn.0")"
              table = "open"
              end
              else "TBAdd DSNTBL"
        return
        /* -------------------------------------------------------------
         * Do_bdt routine is used to issue the MVS/BDT command....
         * -------------------------------------------------------------
        Do_BDT:
        arg dsname  disp

        filedsn = "'"dsname"'"

        Address TSO

        call listdsi filedsn 'directory'

        if sysdsorg = "PS" then dap = "SEQ"
                           else dap = "PDS"
        if disp = "NEW" then do
           alloc = "CYLINDER TRACK BLOCK"
           units = wordpos(sysunits,alloc)
           units = word(alloc,units)
           if units = "BLOCK" then units = "TRACK RLSE"
           disp_opt = "New Recfm("sysrecfm") Lrecl("syslrecl")" ,
                      "Blksize("sysblksize") Space("sysused","sysseconds
                      "Unit(SYSTS)"
           if dap = "PDS" then disp_opt = disp_opt "Dir("sysadirblk")"
           end
           else disp_opt = "SHR"


        say "Transmitting file:" filedsn "to centers:" centers

        do i = 1 to words(centers)
            "BDT Q From Loc("center") DS("filedsn") Shr Dap("dap")" ,
                  "To   Loc("word(centers,i)") DS("filedsn") Dap("dap")"
                  disp_opt
           end

        Address ISPEXEC
        stat = "Sent as" disp
        "TBPUT DSNTBL"
        return

        /* -------------------------------------------------------------
         * Do_msg routine is used to issue the ISPF Message....
         * -------------------------------------------------------------
        Do_Msg:
           "Setmsg Msg(SOFTP000)"
        return
./ ADD NAME=SOFTPUB  0199-93021-93209-0655-00620-00037-00000-$A1238
        /* ---------------------  rexx procedure  ----------------------
         * Name:      SOFTPUB
         *
         * Function:  Book Category Display dialog.
         *
         *            Then recursively called for each category.
         *
         * Syntax:    %SOFTPUB
         *         or
         *            %SOFTPUB title >< table_dsn table_name
         *                    % uaccess
         *         or
         *            %SOFTPUB option
         *
         * Options:
         *            PRivate     Display users private shelf
         *            OWn         alias of Private
         *            DEfault     Display the private shelf
         *            USER        Display only non-access restricted
         *                        categories/shelves/books.
         *            Find xxx    Find the specified string and then
         *                        if only 1 hit open that row, otherwise
         *                        display selection
         *            DFind xxx   Find the specified string and then
         *                        if only 1 hit open that row, otherwise
         *                        display selection using the DEFAULT
         *                        category
         *
         * Dependencies: none
         *
         * Author:    Lionel B. Dyck
         *            Rockwell International
         *            P.O. Box 2515
         *            Seal Beach, California 90740
         *            (310) 797-1125
         *            IBMMail:  USROKNTN
         *            Internet: lbdyck@osreq48.rockwell.com
         *            IBMLINK:  ROK2027
         *
         * History:
         *            07/27/93 - Add FIND and DFIND options
         *            07/08/93 - Add Shelf: accounting record
         *            07/07/93 - Add 'accouting' to find who is using
         *                       private shelves.
         *            05/12/93 - Clean up Find/RFind
         *            04/26/93 - Don't Call ISPOPF if already ON
         *            04/19/93 - Clean up Find/RFind
         *            04/02/93 - Fix check_access for default
         *            03/23/93 - Add option of DEFAULT to open Default
         *                       catagory
         *            03/19/93 - Support Cancel function key (as END)
         *            03/12/93 - Support abbrev private/own  ...
         *                       Fix private shelf support
         *            03/09/93 - Change to log at each center...
         *            03/03/93 - Change showrexx to use showtso
         *            02/24/93 - Add support for local blkshelf (default
         *            02/18/93 - Set Sortbook and Sortshlf options
         *            02/17/93 - test for table dsn exist...
         *            02/11/93 - Set ExitBook and ExitShlf options
         *            02/10/93 - fix access checking
         *            02/10/93 - add USER option to cause all restricted
         *                       shelves to be removed.
         *            02/09/93 - added center to account
         *            02/05/93 - added pfk setting (pf11/12/23/24)
         *            02/02/93 - added usage recording
         *            01/21/93 - created by Lionel Dyck
         *
         * -------------------------------------------------------------

        parse arg options

        Address ISPEXEC "VGET ZAPPLID"
          if zapplid <> "EOXR" then do
             Address ISPEXEC "Select",
                "CMD(%"sysvar('sysicmd') options ") Newappl(EOXR)"
             Exit 0
             end

        parse value "" with null uaccess table_dsn table_name opt privat
                      title find_string dfind_string exit_opt

        if length(options) > 0 then
           Select
             when pos("><",options) > 0 then
                  parse value options with title "><" table_dsn table_na
             when pos("><",options) = 0 then
                  title = options
             otherwise nop;
             end

        if pos("%",opt) > 0 then do
           parse value opt with . "%" uaccess
           If abbrev("FIND",translate(word(uaccess,1)),2) = 1 then do
              parse value uaccess with title "%" uaccess
              exit_opt = "fast"
              end
           end

        If abbrev("DFIND",translate(word(title,1)),2) = 1 then do
                    dfind_string = "Find" translate(subword(title,2))
                    private = "default"
                    exit_opt = "fast"
                    end

        If abbrev("FIND",translate(word(title,1)),1) = 1 then do
                    find_string = translate(subword(title,2))
                    exit_opt = "fast"
                    end

        if words(title) = 1 then do
           titleu = translate(title)
           Select
               When titleu = "USER" then uaccess = "xxx"
               When abbrev("OWN",titleu,2) = 1 then private = "on"
               When abbrev("PRIVATE",titleu,2) = 1 then private = "on"
               When abbrev("DEFAULT",titleu,2) = 1 then private = "defau
               otherwise nop;
               End
        End

        if length(uaccess) = 0 then do
           "Showtso fds# dept"
           uaccess = fds#"/"dept
           end
        uaccess = strip(uaccess)

        "%SOFTPDFT"

        Address ISPEXEC

        "VGET (PROD BUILD)"
        if length(table_dsn) = 0 then do
           table_dsn  = prod
           table_name = "SOFTCOPY"
           end

        if sysdsn(table_dsn) <> "OK" then do
           smsg = null
           lmsg = "This application is not supported on this system."
           call do_msg
           exit 0
           end

        /* --------------------------------------- *
         * set function key values for our app     *
         * --------------------------------------- */
         zpf10 = "Nop"
         zpf11 = "Retrieve"
         zpf12 = "Cancel"
         zpf22 = zpf10
         zpf23 = zpf11
         zpf24 = zpf12
         "Vput (zpf10 zpf11 zpf12 zpf22 zpf23 zpf24)"

        if table_name = "SOFTCOPY" then do
                 call set_bmread_exitopts
                 call set_bmread_sortopts
                 call do_account 'in'
                 panel = "SOFTPBTP"
                 title = null
                 "Vget ZPFSHOW"
                 save_pfshow = zpfshow
                 if zpfshow <> "ON" then
                   "SELECT PGM(ISPOPF) PARM(PFK,ON) NOFUNC SUSPEND"
                 end
           else do
                panel = "SOFTPBTS"
                title = center(title,75)
                end

        "Control Errors Return"
        "Libdef SOFTPUB Dataset ID("table_dsn")"

        "TBOpen" table_name "Library(SOFTPUB) Nowrite Share"

        if table_name = "SOFTCOPY" then call check_default
        if private <> "default" then
           if private_count = 0 then private = null
        call check_access

        "TBQuery" table_name "ROWNUM(Tabrows)"
        Select
        when tabrows = 1 then do
           "TBTOP" table_name
           "TBSKIP" table_name "NUMBER(1)"
           call read_it
           signal out_a_here
           end
        when tabrows = 0 then do
           smsg = Find_string "not found"
           lmsg = find_string "was not found in the search"
           call do_msg
           signal out_a_here
           end
        otherwise if tabrows > 1 then exit_opt = null
        end

        parse value '1 1 0 0' with crp rowcrp last_find prev_crp

        User_Display:
        do forever

        usrrfind = "PASSTHRU"
        "VPUT USRRFIND"

        Select
          when private = "default" then do
                  "TBTOP" table_name
                  "TBSKIP" table_name "NUMBER("default_row")"
                  call read_it
                 private = null
                 end
          when private = "on" then do
             if private_count > 1 then leave
                 "Control Display Save"
                  "TBTOP" table_name
                  "TBSKIP" table_name "NUMBER(1)"
                 "Select CMD(%Bookmgr Shelf('"data"') )"
                 private = null
                 "Control Display Restore"
             end
           otherwise nop;
        end

        zcmd = null

        if src = 4 then "TBDispl" table_name
           else do
                "TBTOP" table_name
                "TBSKIP" table_name "NUMBER("crp")"
                if rowcrp = 0 then
                   "TBDISPL" table_name "PANEL("panel")"
                   else
                   "TBDISPL" table_name "PANEL("panel")",
                           "CSRROW("rowcrp") AUTOSEL(NO)"
                end
        src = rc
          if src > 4 then signal out_a_here

        skip_disp:
          crp = ztdtop
          rowcrp = null

        if row <> null then
           if row > 0 then do
             "TBTop" table_name
             "TBSkip" table_name "NUMBER("row")"
             end

        Usrrfind = null
        "VPUT USRRFIND"

        zcmd_ok = null

        Select
          when wordpos(zcmd,'CANCEL Cancel') > 0 then signal out_a_here
          When words(Zcmd) > 1 then do
               parse value zcmd with o1 o2
               if abbrev("FIND",o1,1) = 1 then call Find_It
               if zcmd_ok <> "ok" then do
                  smsg = "Error"
                  lmsg = "Invalid command:" zcmd
                  call do_msg
                  end
               end
          When zcmd = "RFIND" then do
               zcmd = "RFIND" o2
               call Find_It
               end
          When length(zcmd) = 0 then
             if row <> 0 then
                          if zsel <> null then call Read_it
          otherwise nop
        end

        signal User_Display
        end

        /* -------------------------------------------------------------
         * Find_it routine to search the table 'desc'  entries for the
         * specified character string.  The search is done using
         * REXX instead of using the ISPF TBSCAN which is very limited.
         * -------------------------------------------------------------
        Find_It:
           zcmd_ok = "ok"
           parse value zcmd with o1 argument
           search_argument = argument
           upper argument
           argument = strip(argument)
           zsel = null
           crp = ztdtop
           start_crp = crp
           rowid = crp
           find_loop = null
           search = null
          "TBTOP" table_name
           if o1 = "RFIND" then do
              if prev_crp <> start_crp then last_find = start_crp
              last_find = last_find + 1
              "TBSKIP" table_name "Position(ROWID) Number("Last_find")"
              end
              else do
                   "TBSKIP" table_name "Position(ROWID) Number("start_cr
                   end
           if rc = 8 then do
                          s_smsg = search_argument "Found - Table Wrappe
                          "TBTOP" table_name
                          "TBSKIP" table_name "Position(ROWID)"
                          end
                     else s_smsg = search_argument "Found"

           /* perform search */

           do forever
              search = translate(desc)
              if pos(argument,search) > 0 then do
                 crp = rowid + 0
                 rowcrp = crp
                 last_find = crp
                 smsg = s_smsg  /* "Found" */
                 lmsg = search_argument "found during search in row:" cr
                 call do_msgn
                 prev_crp = start_crp
                 return
                 end
              "TBSKIP" table_name "POSITION(Rowid)"
              if rc = 8 then do
                    "TBTOP" table_name
                     s_smsg = search_argument "Found - Table Wrapped"
                 if find_loop = "on" then do
                     smsg = search_argument "Not Found"
                     lmsg = search_argument "Not found during search"
                     rowid = crp
                     call do_msg
                     prev_crp = start_crp
                     return
                     end
                     else find_loop = "on"
                 end
              zsel = null
              end
        return

        /* -------------------------------------------------------------
         * Do_msg routines is used to issue the ISPF Message....
         * -------------------------------------------------------------
        Do_Msg:
           "Setmsg Msg(SOFTP000)"
        return

        Do_MsgN:
           "Setmsg Msg(SOFTP001)"
        return

        /* -------------------------------------------------------------
         * Read_it routine to:
         *
         * 1.  Display another category selection using %softpub
         * or
         * 2.  Invoke BookManager/Read MVS for the book shelf
         *
         * -------------------------------------------------------------
        Read_it:
        if zsel = "V" then do
              "Display Panel(SOFTPUBD)"
              return
              end

        "Control Display Save"
        Select
          When type = "C" then do
             if length(uaccess) > 0 then xaccess = "%" uaccess
                                    else xaccess = null
             if dfind_string <> null then xaccess = "%" dfind_string  xa
             "Select CMD(%SOFTPUB" desc "><" table_dsn data xaccess")"
             if dfind_string <> null then rc = 4
             xrc = rc
             end
          When type = "B" then do
               "Select CMD(%Bookmgr Book('"data"') )"
               xrc = rc
               end
          When type = "S" then do
               "Select CMD(%Bookmgr Shelf('"data"') )"
               xrc = rc
               end
          otherwise xrc = 0
        end
        "Control Display Restore"
        if xrc > 0 then do
           exit_opt = "fast"
           signal out_a_here
           end
        return

        /* -------------------------------------------------------------
         * Check_Access routine:
         *
         * If the row is access restricted then check to see if the
         * current user can view it.  If not then remove it from the
         * table.
         *
         * -------------------------------------------------------------
        Check_Access:
        row_cnt = 0
        "TBTop" table_name
        do forever
           "TBSkip" table_name
           if rc > 0 then return
           row_cnt = row_cnt + 1
           kill = null
           hit  = null
           if data = "SOFTPALL" then default_row = row_cnt
           if find_string <> null then
              if pos(find_string,translate(desc)) = 0 then do
                 kill = "on"
                 access = 'xx'
                 end
           if length(access) = 0 then iterate
           if kill = null then
              do ca = 1 to words(access)
                 ca_word = word(access,ca)
                 if pos("*",ca_word) > 0 then
                    acl = length(ca_word) - 1
                    else acl = length(ca_word)
                 ca_word = left(ca_word,acl)
                 if pos(ca_word,uaccess) > 0 then hit = "on"
                    else kill = "on"
              end
           if hit = "on" then kill = null
           if kill = "on" then
                 "TBDelete" table_name
           end
        return

        /* -------------------------------------------------------------
         * Do_Account routine:
         *
         * This routine will do the necessary logging for the user to
         * allow us to do some 'simple' accounting of the usage of this
         * product.  This routine is only called when first entered and
         * when we exit.
         *
         * Input is a parameter of 'in' or 'out' to indicate the start
         * or stop of the usage of the application.
         *
         * Output is written to a temporary data set and then sent via
         * the ALLOC command to userid of ABOOK where it will be picked
         * up via the TSO RECEIVE command.
         *
         * The output information is:
         *
         *     Userid      sysvar(sysuid)
         *     Date        date('u')
         *     Time        time()
         *     Account     zacctnum (ispf variable)
         *     Local Shelves L(nn) * optional - only if local shelves
         *
         * -------------------------------------------------------------
        Do_Account:
        arg opt
        parse value null with rec2 local_shelves orec
        if opt = "IN" then do
           Address TSO "Showtso Center"
           stamp = substr(date("U"),1,2)substr(date("U"),4,2)
           stamp = stamp""substr(date("U"),7,2)
           stamp = center stamp"-"left(time("N"),2)substr(time("N"),4,2)
           rec = "Start:"
           end
           else do
                rec = "Stop :"
                if use_local > 0 then do
                   local_shelves = "L("use_local")"
                   rec2 = "Shelf:"
                   end
                end
        "Vget (ZACCTNUM)"
        vio_unit = "SYSVIO"
        rec = rec left(sysvar(sysuid),8) stamp date("U"),
             time() left(zacctnum,32) local_shelves
        if rec2 <> null then
           rec2 = rec2 left(sysvar(sysuid),8) stamp date("U"),
                  time() local_shelves

        /*  create profs-like header */
          userid = sysvar(sysuid)
          toid   = "ABOOK"
          tonode = strip(center)
          header = " MSG:FROM:" left(userid,8)"--"left(center,8) "TO:",
                     left(toid,8)"--"left(tonode,18)date('u') time()
          new_header = overlay(x2c('FE'),header,1)
          header = new_header

        /*  create profs-like trailer */
         trailer = left(" ",6)left(sendsubj,65)
         new_trailer = overlay(x2c('FFFF00000011'),trailer,1)
         trailer = overlay(x2c('000000000000000000'),new_trailer,72)
         subject = "No Subject"
         new_trailer = overlay(subject,trailer,7,65)
         trailer = new_trailer

        orec.1 = header
        orec.2 = rec
        if rec2 <> null then do
           orec.3 = rec2
           orec.4 = trailer
           end
           else orec.3 = trailer
        ddn = "AC"random()
        Address TSO
        "Alloc f("ddn") Space(1) Tr Recfm(f) Blksize(80) Sysout(B)",
          "Dest("tonode"."toid")"
        "Execio * Diskw" ddn "(Finis Stem orec."
        "Free  f("ddn")"
        Address ISPEXEC
        return

        set_bmread_exitopts:
        /* -------------------------------------------------------------
         * Set_BMRead_ExitOpts routine:
         *
         * If Exitbook is null then set it to
         *    - do not confirm on book exit
         *    - do not set bookmark on exit
         *    (setting is numeric 6 for both)
         * If Exitshlf is null then set it to
         *    - do not confirm on exit
         *    (setting is numeric 2)
         * -------------------------------------------------------------
        "Vget (Exitbook Exitshlf) Profile"
        if length(exitbook""exitshlf) > 1 then return
        if exitbook = null then exitbook = 6
        if exitshlf = null then exitshlf = 2
        "Vput (Exitbook Exitshlf) Profile"
        return


        Check_Default:
        /* -------------------------------------------------------------
         * check_default routine
         *
         * look for user defined book shelf list userid.*.bklshelf
         * and then if there add entry for default category (2+ shelves)
         * or default shelf.
         * -------------------------------------------------------------
         x = outtrap("traplc.","*")
         Address TSO,
            "LISTC ENT('"sysvar(syspref)".*.BKLSHELF')"
         x = outtrap("off")
         local.  = ""
         local.0 = 0
         use_local = 0
         private_count = local.0
         do trap = 1 to traplc.0
            if left(traplc.trap,7) <> "NONVSAM" then iterate
            parse value traplc.trap with . "-------" filedsn
            filedsn = strip(filedsn)
            x       = local.0 + 1
            local.x = filedsn
            local.0 = x
            end
         if local.0 = 0 then return
         private_count = local.0
         do bx = 1 to local.0
            filedsn = local.bx
            call read_shelf
            end
         return

        Read_Shelf:
        /* -------------------------------------------------------------
         * Read_Shelf routine
         *
         * read the users book shelf and extract the title......
         * -------------------------------------------------------------
        Address TSO
        "Alloc f("ddn") Shr Reuse DS('"filedsn"')"
        "Execio * diskr" ddn "(Finis stem t."
        "Free  f("ddn")"
        Address ISPEXEC
        do b = 1 to t.0
           parse value t.b with a1 a2 bookdsn title
           title = strip(title)
            type = "S"
            desc = "*" title "*"
            data = bookdsn
            "TBADD Softcopy Order"
            use_local = use_local + 1
           end
        return

        set_bmread_sortopts:
        /* -------------------------------------------------------------
         * Set_BMRead_SortOpts routine:
         *
         * If Exitbook is null then set it to
         *    - do not confirm on book exit
         *    - do not set bookmark on exit
         *    (setting is numeric 6 for both)
         * If Exitshlf is null then set it to
         *    - do not confirm on exit
         *    (setting is numeric 2)
         * -------------------------------------------------------------
        "Vget (Sortbook Sortshlf) Profile"
        if length(sortbook""sortshlf) > 1 then return
        if sortbook = null then sortbook = 2
        if sortshlf = null then sortshlf = 2
        "Vput (Sortbook Sortshlf) Profile"
        return

        Out_A_Here:
             "TBEnd" table_name
             "Libdef SOFTPUB"
             if table_name = "SOFTCOPY" then do
                call do_account 'out'
                 if save_pfshow <> "ON" then
                   "SELECT PGM(ISPOPF) PARM(PFK,OFF) NOFUNC SUSPEND"
                end
             if exit_opt = "fast" then exit 4
             Exit 0
./ ADD NAME=SOFTPUBA 0165-93014-93209-0656-00207-00070-00000-$A1238
        /* ---------------------  rexx procedure  ----------------------
         * Name:      SOFTPUBA
         *
         * Function:  Administration front-end for Rockwell ISPF
         *            BookManager/Read for MVS for Application.
         *
         * Syntax:    %SOFTPUBA option(s)
         *
         *            Valid options:
         *
         *            BUILD  -  builds the selection tables and saves
         *                      the updated tables in a work data set
         *                      which must then be copied into the
         *                      production data set using PDF 3.3
         *
         *                      Calls SOFTPBB rexx procedure
         *
         *            DEBUG   - Invoke Rexx tracing for debugging
         *
         *            TEST    - Invoke using DISPLAY and using the
         *                      newly built tables in the BUILD
         *                      library
         *            ACCESS  - Used with TEST to specify a test
         *                      department/group
         *
         *            Default(s);  none -
         *
         *
         * Author:    Lionel B. Dyck
         *            Rockwell International
         *            P.O. Box 2515
         *            Seal Beach, California 90740
         *            (310) 797-1125
         *            IBMMail:  USROKNTN
         *            Internet: lbdyck@osreq48.rockwell.com
         *            IBMLINK:  ROK2027
         *
         * History:   mm/dd/yy
         *            comments
         *
         * -------------------------------------------------------------
        arg options

        if wordpos("DEBUG",options) > 0 then do
           trace i
           debug = "on"
           end
           else debug = ""

        Address ISPEXEC "VGET ZAPPLID"
          if zapplid <> "EOXR" then do
             Address ISPEXEC "Select CMD(",
                sysvar('sysicmd') options ") Newappl(EOXR)"
             Exit 0
             end

        null        = ""
        test_access = null
        this_user   = sysvar(sysuid)
        admin_users = "$A1238 Lionel Dyck",
                      "$A1019 Doug Adams",
                      "YA0408 Susie Strand",
                      "YA0370 Felicia Woodson"

        call test_admin

        Display_Selection:
        re_do = ""
        if length(options) = 0 then do
           parse value "" with zcmd test
           Address ISPEXEC "Display Panel(SOFTPUBA)"
           if rc > 4 then exit 0
           do_pan = "on"
           select
             when zcmd = "1" then options = "BUILD"
             when zcmd = "2"  then do
                Address TSO,
                  "%SOFTPUBX"
                  re_do = "on"
                  end
             when zcmd = "3"  then  do
                  options = "TEST"
                  if length(panacc) <> null then
                     options = options "ACCESS" panacc
                  end
             when zcmd = "4"  then options = "COPY"
             when zcmd = "5"  then do
                  Address ISPEXEC,
                   "Select CMD(%SOFTPES)"
                  re_do = "on"
                  end
             when zcmd = "6"  then options = "COLLECT"
             when zcmd = "7"  then do
                  Address TSO,
                     "%SOFTPDFT"
                  Address ISPEXEC,
                     "VGET (BUILD PROD)"
                  Address ISPEXEC,
                     "Edit Dataset("build")"
                  re_do = "on"
                  end
             when zcmd = "8"  then do
                Address TSO,
                  "%BKINDEX"
                  re_do = "on"
                  end
             when zcmd = "9"  then do
                Address TSO,
                  "%SOFTPUSD"
                  re_do = "on"
                  end
             when zcmd = "10"  then do
                Address TSO,
                  "%SOFTPTRN"
                  re_do = "on"
                  end
             otherwise re_do = "on"
             end
           end

        if re_do = "on" then signal Display_Selection

        Address ISPEXEC

        /* -------------------------------------------------------------
         * Establish working defaults for use during this application:
         *
         * admin_users     = list of valid userids that may perform
         *                   the BUILD function.
         * this_user       = userid of the currently active user.
         * build_table     = data set into which the BUILD selection
         *                   tables will be stored.
         * prod_table      = data set for the production DISPLAY
         *                   selection tables.
         * -------------------------------------------------------------

        Address TSO "%SOFTPDFT"
        "VGET (BUILD PROD)"

        build_table = build
        prod_table  = prod

        if wordpos("COLLECT",options) > 0 then do
           "Select CMD(%SOFTPBRP)"
             "Select CMD(%SOFTPBKL)"
              Signal Exit_RISoft
        end

        if wordpos("BUILD",options) > 0 then do
           /* perform validation of authorized build users */
           "Select CMD(",
              "%SOFTPBB" build_table prod_table debug ")"
              Signal Exit_RISoft
        end

        if wordpos("COPY",options) > 0 then do
           /* perform validation of authorized build users */
           "Select CMD(",
              "%SOFTPBC" build_table prod_table debug ")"
              Signal Exit_RISoft
        end

        if wordpos("TEST",options) > 0 then do
           test = "on"
           prod_table = build_table
           end

        if wordpos("ACCESS",options) > 0 then do
           parse value options with . "ACCESS" test_access .
           test_access = "%" test_access
           if test <> "on" then do
                   smsg = null
                   lmsg = "Error:  ACCESS specified but you have not",
                          "requested the TEST option. Try again."
                   Signal Exit_RISoft
                   end
           end

        "Select Cmd(%SOFTPUB PRIME ><" prod_table "SOFTCOPY" debug test_
                   ") Newpool"

        Exit_Risoft:
           if do_pan = "on" then do
              options = ""
              signal display_selection
              end
          address ISPEXEC,
              "VPUT (SMSG LMSG)"
          address ISPEXEC,
              "Setmsg Msg(SOFTP000)"
           Exit 0

        Test_Admin:
        /* ----------------------------------------------- *
         * Test_Admin                                      *
         *                                                 *
         * Verify that the requestor is authorized for the *
         * administration function(s) of BUILD, COPY,      *
         * ACCESS, and TEST.                               *
         * ----------------------------------------------- */
           if wordpos(this_user,admin_users) = 0 then do
              smsg = null
              lmsg = "Error:  Invalid option selected for this applicati
                     "causing a security violation."
              Signal Exit_RISoft
              end
        return
./ ADD NAME=SOFTPUBX 0112-93026-93209-0642-00042-00009-00000-$A1238
        /* rexx */
        /* this is the softcopy build review application */
        arg table

        if table = "" then table = "SOFTCOPY"

        "%SOFTPDFT"

        Address ISPEXEC
          "Vget (Build)"
          "Libdef softpub dataset id("build")"
          "TBOpen" table "Library(softpub)"
          src = rc
          if rc > 0 then do
             Select
               When src = 8  then lmsg = "Table does not exist"
               When src = 12 then lmsg = "Table in use, ENQ failed"
               When src = 16 then lmsg = "Input library not allocated"
               otherwise lmsg = "Severe table open error"
               end
            smsg = ""
            "SETMSG MSG(Softp000)"
            exit 4
            end

        Do forever
        "TBDispl" table "Panel(softpubx)"
         if rc > 4 then do
            "TBEnd" table
            "Libdef softpub"
            exit 0
            end
        if row <> null then
           if row > 0 then do
             "TBTop" table
             "TBSkip" table "NUMBER("row")"
             end
        if zsel <> "" then
           if type = "C" then do
           Address ISPEXEC "Select Cmd(%SOFTPUBX" data ")"
           end
        end
./ ADD NAME=SOFTPUSD 0121-93182-93209-0652-00398-00165-00000-$A1238
        /* ---------------------  rexx procedure  ----------------------
         * Name:      SOFTPUSD
         *
         * Function:  Create Several Reports of Softcopy Files:
         *
         *            1.  Report 1 - all books
         *                Contents.......
         *                Book DSName
         *                Book order number
         *                Date/time stamp (if any)
         *                Title
         *                Shelf
         *
         *            2.  Report 2 - all used books
         *                Contents.......
         *                Book DSName
         *                Book order number
         *                Date/time stamp (if any)
         *                Title
         *                Shelf
         *
         *            2a. Report 2a- all used books with DCF Tags
         *                Contents.......
         *                Book DSName
         *                Book order number
         *                Date/time stamp (if any)
         *                Title
         *                Shelf
         *
         *            3.  Report 3 - all not reference books/shelves
         *                Contents.......
         *                Book DSName
         *                Book order number
         *                Date/time stamp (if any)
         *                Title
         *                Shelf
         *
         *            4.  Report 4 - all not reference books/shelves
         *                Contents.......
         *
         *            The report is created in a temporary
         *            data set and includes Script tags and the
         *            user is prompted for a target location for
         *            the file after browsing it.
         *
         *            These files are also placed into flat files
         *            without tags thus:
         *
         *                Book DSName  (44)
         *                Book order number (8)
         *                Date/time stamp (17)
         *                Shelf (8)
         *                Title (variable)
         *
         * Syntax:    %softpusd
         *
         * Author:    Lionel B. Dyck
         *            Rockwell International
         *            P.O. Box 2515
         *            Seal Beach, California 90740
         *            (310) 797-1125
         *            IBMMail:  USROKNTN
         *            Internet: lbdyck@osreq48.rockwell.com
         *            IBMLINK:  ROK2027
         *
         * History:
         *            07/02/93 - rewrite for multiple reports
         *            04/26/93 - created
         *
         * -------------------------------------------------------------

        "%SOFTPDFT"
        Address ISPEXEC "VGET (INDEX build)"

        d    = date(u)
        date = substr(d,7,2)substr(d,1,2)substr(d,4,2)
        adsn = "Softcopy.ALL.D"date
        udsn = "Softcopy.USED.D"date
        kdsn = "Softcopy.KILL.D"date

        parse value "" with null script. report. bookidx. bookname.,
                       info. kill. used. flag notep. kille. shelf. shelv
        parse value "0 0 0 0 0 0 0" with script.0 report.0 bookidx.0,
                       kill.0 notep.0 kille.0 shelf.0

        ddn        = "BK"random()

        x = outtrap("listc.","*")
        "LISTC LEVEL('"index".*.BKSHELF')"
        "LISTC LEVEL('"index".*.BOOK')"
        "LISTC LEVEL('"index".*.NOTEP')"
        x = outtrap("OFF")

        report.0 = 2
        report.1 = "List of All Softcopy Publications"
        report.2 = " "

        say "Processing result of LISTC"

        listc_phase = 0

        do i = 1 to listc.0
           if substr(listc.i,2,1) = " " then iterate
           parse value listc.i with "NONVSAM -------" dsname .
             if right(dsname,8) = ".BKSHELF" then call do_bkshelf
             if right(dsname,5) = ".BOOK" then do
                bookname.dsname = "*here*" bookname.dsname
                end
             if right(dsname,6) = ".NOTEP" then call do_notep
           end

        say "Processing complete for LISTC"

        listc_phase = 1

         x = msg("off")
        "Delete "adsn".report"
        "Delete "udsn".script"
        "Delete "udsn".report"
        "Delete "kdsn".report"
        "Delete "kdsn".exec"
         x = msg("on")

        "Alloc f("ddn") New Reuse ds("adsn".report)",
           "Recfm(V B) Lrecl(255) Blksize(0)",
           "tracks Space(30,30) release"
        "Execio * diskw" ddn "(Finis Stem report."

        call Do_Build

        used.0 = 3
        used.1 = "List of All Referenced Softcopy Publications"
        used.3 = " "

        kill.0 = 2
        kill.1 = "List of Unreferenced Softcopy Publications"
        kill.2 = " "

        kille.0 = 2
        kille.1 = "/* rexx procedure to delete Softcopy Publications */"
        kille.2 = " "

        say "Calling Find_Used"
        call Find_Used

        used.2 = "used files:" used.0-3  "out of a total file count of:"
                 total_files "with" kill.0-2 "unreferenced files.",
                 "Cross check is:" used.0 + kill.0 - 5 "vs" total_files

        "Alloc f("ddn") New Reuse ds("udsn".script)",
           "Recfm(V B) Lrecl(255) Blksize(0)",
           "tracks Space(30,30) release"
        "Execio * diskw" ddn "(Finis Stem script."

        "Alloc f("ddn") New Reuse ds("udsn".report)",
           "Recfm(V B) Lrecl(255) Blksize(0)",
           "tracks Space(30,30) release"
        "Execio * diskw" ddn "(Finis Stem used."

        "Alloc f("ddn") New Reuse ds("kdsn".report)",
           "Recfm(V B) Lrecl(255) Blksize(0)",
           "tracks Space(30,30) release"
        "Execio * diskw" ddn "(Finis Stem kill."

        Call Create_Kill_Exec
        "Alloc f("ddn") New Reuse ds("kdsn".exec)",
           "Recfm(V B) Lrecl(255) Blksize(0)",
           "tracks Space(30,30) release"
        "Execio * diskw" ddn "(Finis Stem kille."

        "Free f("ddn")"

        if sysvar(sysenv) <> "FORE" then exit 0
        Address ISPEXEC "Browse Dataset("adsn".report)"
        Address ISPEXEC "Browse Dataset("udsn".script)"
        Address ISPEXEC "Browse Dataset("udsn".report)"
        Address ISPEXEC "Browse Dataset("kdsn".report)"
        Address ISPEXEC "Browse Dataset("kdsn".exec)"

        Exit 0

        do_bkshelf:
        dsname = strip(dsname)
        if listc_phase = 0 then do
           book_dsn = dsname
           bookname.dsname = "*here* SHELF"
           call set_book
           end
        if listc_phase = 1 then do
           bookname.dsname = bookname.dsname "Build"
           end
        "Alloc f("ddn") Shr Reuse Ds('"dsname"')"
        "Execio * Diskr" ddn "(Finis Stem Book."
        "Free  f("ddn")"
        parse value dsname with front ".BKSHELF"
        front = translate(front," ",".")
        shelf = translate(word(front,2))
        call Get_Info
        return

        Get_Info:
        do j = 1 to book.0
          select
          when left(book.j,2) = "SH" then do
               if book_num <> "" then call save_it
               parse value "" with book_num Book_title book_dsn,
                                   book_name book_datetime
               book_num = substr(book.j,3)
               end
          when left(book.j,2) = "ST" then do
               book_title     = strip(substr(book.j,3))
               end
          when left(book.j,7) = "BKNAME=" then do
               parse value book.j with "BKNAME=" book_name
               end
          when left(book.j,7) = "BKMDSN=" then do
               parse value book.j with "BKMDSN=" book_dsn
               book_dsn = strip(translate(book_dsn))
               end
          when left(book.j,11) = "BKDATETIME=" then do
               parse value book.j with "BKDATETIME=" book_datetime
               end
          when left(book.j,9) = "BKSTITLE=" then do
               parse value book.j with "BKSTITLE=" book_title
               book_dsn      = dsname
               book_dsn      = strip(translate(book_dsn))
               book_num      = "*shelf*"
               book_name     = "Shelf"
               book_datetime = "Shelf"
               call save_it
                    parse value "" with book_num Book_title book_dsn,
                                   book_name book_datetime
               end
          when left(book.j,9) = "BKSIMDSN=" then do
               parse value book.j with "BKSIMDSN=" book_dsn
               book_dsn = strip(translate(book_dsn))
               book_num = "*index*"
               book_title = "Index"
               book_name  = "Index"
               if listc_phase = 1 then do
                  book_datetime = "used"
                  bookname.book_dsn = bookname.book_dsn "Build"
                  end
               else do
                  bookname.book_dsn = "*here* Index"
                  book_datetime = "index"
                  call set_book
                  end
               if length(book_dsn) > 0 then
               call save_it
                    parse value "" with book_num Book_title book_dsn ,
                                   book_name book_datetime
               end
          otherwise nop;
        end
        end
        return

        Do_Notep:
           n = notep.0 + 1
           notep.0 = n
           notep.n = dsname
        return

        Save_It:
        if flag <> 1 then call set_book
        if flag <> 1 then call set_info
        call set_bookname
        data = left(book_dsn,44) left(book_num,9) left(book_datetime,17)
               left(shelf,8) book_title
        c = report.0 + 1
        report.c = data
        report.0 = c
        return

        Set_Book:
        bc         = bookidx.0 + 1
        bookidx.bc = book_dsn
        bookidx.0 = bc
        return

        Set_Bookname:
        if flag = 1 then shelf = "Build"
        bookname.book_dsn = bookname.book_dsn shelf
        return

        Set_Info:
        Info.book_dsn = book_num "%" book_datetime "%" book_title
        return

        Do_Build:
        flag = 1
        parse value build with "'" build "'"
        "Alloc f("ddn") Shr Reuse Ds('"build"(BUILD)')"
        "Execio * Diskr" ddn "(Finis Stem build."
        "Free f("ddn")"

        do b = 1 to build.0
           parse value "" with book_num Book_title book_dsn,
                               book_name book_datetime
           type = translate(left(build.b,1))
           Select
           When type = "B" then do
                parse value build.b with "B" book_dsn book_title
                book_dsn = strip(translate(book_dsn))
                call set_info
                call set_book
                call set_bookname
                end
           When type = "S" then do
                Parse value build.b with t dsname .
                call do_bkshelf
                end
           otherwise nop
           end
        end
        Return

        Find_Used:
        total_files = 0
        do i = 1 to bookidx.0
           book_dsn = bookidx.i
           if bookname.book_dsn = "gone" then iterate
           shelf = bookname.book_dsn
           bookname.book_dsn = "gone" /* remove after 1st use */
           parse value info.book_dsn with book_num "%" book_datetime "%"
                        book_title
           hpos = wordpos("*here*",shelf)
           if hpos = 0 then iterate
           total_files = total_files + 1
           c_shelf = delword(shelf,hpos,1)
           bpos = wordpos("Build",c_shelf)
           if bpos > 0 then
              c_chelf = delword(c_shelf,bpos,1)
              else c_cshelf = c_shelf
           data = left(book_dsn,44) left(book_num,9) left(book_datetime,
                  "("c_shelf")" book_title
           if hpos = 0 then iterate
           if bpos = 0 then do
              c = kill.0 + 1
              kill.c = data
              kill.0 = c
              end
              else do
                   c = used.0 + 1
                   used.c = data
                   used.0 = c
                   call set_script
                   end
        end

        do i = 1 to notep.0
           notedsn = notep.i
           parse value notedsn with prefix ".NOTEP"
           testdsn = prefix".BOOK"
           data = left(testdsn,44) left("*Notep*",9) left("Notep",17),
                  left("Notep",8) "Public Note"
           if wordpos("Build",bookname.testdsn) = 0 then do
              c = kill.0 + 1
              kill.c = data
              kill.0 = c
              end
              else do
                   c = used.0 + 1
                   used.c = data
                   used.0 = c
                   end
        end
        return

        Set_Script:
        count        = script.0 + 1
        script.count = ":row."
        count = count + 1
        script.count = ":c."book_num
        count = count + 1
        script.count = ":c."book_name
        count = count + 1
        script.count = ":c."book_dsn
        count = count + 1
        script.count = ":c."book_title
        count = count + 1
        script.count = ":c."book_datetime
        count = count + 1
        script.count = ":c."shelf
        script.0     = count
        return

        Create_Kill_Exec:
        do i = 3 to kill.0
           parse value kill.i with dsname .
           parse value Info.dsname with ig1 "%" ig2 "%" title
           c = kille.0 + 1
           kille.0  = c
           killdata = "'Delete" dsname"'"
           kille.c  = left(killdata,40) "/*" title "*/"
           end
        return
./ ADD NAME=SOFTPUSG 0103-93033-93085-0655-00069-00069-00000-$A1238
        /* ---------------------  rexx procedure  ----------------------
         * Name:      SOFTPUSG
         *
         * Function:  Generate usage accounting for the Softcopy
         *            application.  This is accomplished by reading
         *            the ABOOK.LOG.MISC file that is generated by
         *            the following steps:
         *
         *            1.  SOFTPUB uses TSO Transmit to send a 1-line
         *                message to node WCC1 and userid ABOOK that
         *                contains Start/Stop Userid Date Time and
         *                Accounting information.
         *
         *            2.  The SAFEMAIL application that is run
         *                nightly does a TSO RECEIVE command for the
         *                ABOOK userid and places the output into
         *                ABOOK.LOG.MISC.
         *
         *
         * Syntax:    %SOFTPUSG
         *
         * Author:    Lionel B. Dyck
         *            Rockwell International
         *            P.O. Box 2515
         *            Seal Beach, California 90740
         *            (310) 797-1125
         *            IBMMail:  USROKNTN
         *            Internet: lbdyck@osreq48.rockwell.com
         *            IBMLINK:  ROK2027
         *
         * History:
         *            02/02/93 - created by Lionel Dyck
         *
         * -------------------------------------------------------------

        ddn = "USG"random()

        "Alloc f("ddn") DS('ABOOK.LOG.MISC') Shr Reuse"
        "Execio * Diskr" ddn "(Finis Stem usage."
        "Free  f("ddn")"

        report.  = ""
        report.0 = 0

        do i = 1 to usage.0
           if left(usage.i,6) = "Start:" then call record_it
           if left(usage.i,6) = "Stop :" then call record_it
           end

        date = substr(date("U"),4,2)substr(date("U"),7,2)left(date("U"),
        time = left(time("N"),2)substr(time("N"),4,2)

        soft_dsn = "SOFTCOPY.D"date".T"time".REPORT"
        "Alloc f("ddn") Ds("soft_dsn") New",
          "Recfm(F B) Lrecl(80) Blksize(0)",
          "Space(30,30) Tr"
        "Execio * Diskw" ddn "(Finis Stem report."
        "Free f("ddn")"

        Address ISPEXEC
          "Select CMD(%RPRINT "soft_dsn")"

        Exit 0

        Record_it:
              cnt        = report.0 + 1
              report.0   = cnt
              report.cnt = usage.i
              return
