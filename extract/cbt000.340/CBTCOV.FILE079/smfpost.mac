//SMFPOST   JOB   MSGLEVEL=1,REGION=150K                               C
//                    *                                                C
//        THIS IS A SAMPLE PL1 DATA REDUCTION PROGRAM. IT PRODUCES A   C
//         REPORT BASED ON DATA IN STANDARD SMF RECORD FORMATS.        C
//                    *                                                C
//        NOTE: TWO DATA DEFINITION(DD) CARDS ARE REQUIRED FOR THIS    C
//             SAMPLE PROGRAM EXECUTION.                               C
//                   SYSPRINT      -  LOGICAL RECORD 132               C
//                   DATAIN        - FULL DESCRIPTION OF INPUT DATA SET
//SMFPST  EXEC   PL1LFCL,PARM.PL1L='SIZE=100000,L,E,A,X,FS'
//PL1L.SYSIN DD *
 SMFPOST: PROCEDURE OPTIONS(MAIN);
         DECLARE 1 COMMON,
 /* THESE VARIABLES ARE COMMON TO RECORD TYPES 0,12 */
         2 CONT BIT(8),
         2 RECORD_TYPE BIT(8),
         2 TIME_STAMP BINARY FIXED(31,0) UNAL,
         2 DATE_STAMP DECIMAL FIXED(7),
         2 CPU_ID,
           3 SYS_ID CHARACTER(2),
           3 MODEL CHARACTER(2),
         2 SPACE CHARACTER(32752),
 /* THESE VARIABLES ARE COMMON TO RECORD TYPE 0 */
         JWAIT_TIME BINARY FIXED(31,0) UNAL DEFINED SPACE,
         SMFBUF_SIZE BINARY FIXED(31,0) UNAL DEFINED SPACE POSITION(5),
         CORE_SIZE BINARY FIXED(31,0) UNAL DEFINED SPACE POSITION(9),
         OPTIONS(K) BIT(1) DEFINED SPACE POSITION(13),
         OPTION CHARACTER(3),
         OPT(3) CHAR(1) DEFINED OPTION POS(1),
 /* THIS VARIABLE IS COMMON TO RECORD TYPES 1,12 */
         SYSWAIT_TIME BIN FIXED(31,0) UNAL DEFINED SPACE,
 /* THESE VARIABLES ARE COMMON TO RECORD TYPES 4,5,6,10 */
         JOB_NAME CHARACTER(8) DEFINED SPACE,
         RDR_START_TIME BIN FIXED(31,0) UNAL DEFINED SPACE POS(9),
         RDR_START_DATE DECIMAL FIXED(7) DEFINED SPACE POSITION(13),
         USER_ID CHAR(8) DEFINED SPACE POS(17),
 /* THESE VARIABLES ARE COMMON TO RECORD TYPES 4,5,6 */
         JS_NUMBER BIT(8) DEFINED SPACE POSITION(25),
         OUTPUT_CLASS CHARACTER(1) DEFINED SPACE POSITION(25),
         START_TIME BIN FIXED(31,0) UNAL DEFINED SPACE POSITION(26),
         START_DATE DECIMAL FIXED(7) DEFINED SPACE POSITION(30),
 /* THESE VARIABLES ARE COMMON TO RECORD TYPES 4,5 */
         SYSIN_COUNT BIN FIXED(31,0) UNAL DEFINED SPACE POSITION(34),
         TERM_STATUS(L) BIT(4) DEFINED SPACE POSITION(38),
         PRIORITY BIT(8) DEFINED SPACE POSITION(40),
         DEVC(1) CHARACTER(4),
         DEVCA(4) CHARACTER(1) DEFINED DEVC POSITION(1),
 /* THESE VARIABLES ARE COMMON TO RECORD TYPE 4 */
         PROGRAM_NAME CHARACTER(8) DEFINED SPACE POSITION(41),
         STEP_NAME CHARACTER(8) DEFINED SPACE POSITION(49),
         REGION_REQUEST BIT(16) DEFINED SPACE POSITION(57),
         LCS_CORE_REQ BIT(16) DEFINED SPACE POS(59),
         CORE_USED BIT(16) DEFINED SPACE POSITION(61),
         CORE_BORROWED BIT(16) DEFINED SPACE POS(63),
         LCS_USED BIT(16) DEFINED SPACE POS(65),
         LCS_BORROWED BIT(16) DEFINED SPACE POS(67),
         STEP_RESERVED CHAR(20) DEFINED SPACE POS(69),
         LENGTH1 BIT(16) DEFINED SPACE POSITION(89),
         UNIT1(M) BIT(4) DEFINED SPACE POSITION(91),
         DEVCD(1) CHARACTER(8),
         DEVCE(8) CHARACTER(1) DEFINED DEVCD POSITION(1),
 /* THESE VARIABLES ARE COMMON TO RECORD TYPE 5 */
         RDR_STOP_TIME BIN FIXED(31,0) UNAL DEFINED SPACE POS(41),
         RDR_STOP_DATE DECIMAL FIXED(7) DEFINED SPACE POSITION(45),
         USER_CANC(K) BIT(1) DEFINED SPACE POSITION(49),
         SYSOUT_CLASSES(J) BIT(1) DEFINED SPACE POSITION(50),
         CHK_PT_RESTART BIT(8) DEFINED SPACE POSITION(55),
         RDR_DEV_CLASS_TYPE(L) BIT(4) DEFINED SPACE POSITION(56),
         JOB_INPUT_CLASS CHAR(1) DEFINED SPACE POSITION(58),
         JOB_RESERVED CHAR(20) DEFINED SPACE POS(59),
         SIZE BIT(8) DEFINED SPACE POSITION(79),
         PROGR_NAME CHARACTER(20) DEFINED SPACE POSITION(80),
         JPP_CPU_RUN_TIME BIT(24) DEFINED SPACE POSITION(100),
         NUM_ACCT_FIELDS BIT(8) DEFINED SPACE POSITION(103),
         FIELDS(152) CHARACTER(1) DEFINED SPACE POSITION(104),
         AFIELD CHARACTER(152) DEFINED SPACE POSITION(104),
         ACCTING(1) CHAR(120) INITIAL(' '),
         ACCTFLD(120) CHAR(1) DEFINED ACCTING POS(1),
         DEVCB(1) CHARACTER(4),
         DEVCC(4) CHARACTER(1) DEFINED DEVCB POSITION(1),
         CANCEL(6) CHARACTER(2) INITIAL('TL','JV','JI','SI','ST','JE'),
         IND CHARACTER(6),
 /* THESE VARIABLES ARE COMMON TO RECORD TYPE 6 */
         SYSOUT_COUNT BIN FIXED(31,0) UNAL DEFINED SPACE POS(34),
         ERR_IND(8) BIT(1) DEFINED SPACE POSITION(38),
         DATA_SET_COUNT BIT(8) DEFINED SPACE POSITION(39),
         FORM_NUMBER CHARACTER(4) DEFINED SPACE POSITION(40),
         ERROR CHARACTER(6),
         ERR(6) CHARACTER(1) DEFINED ERROR POSITION(1),
 /* THESE VARIABLES ARE COMMON TO RECORD TYPE 7 */
         RECORD_COUNT BIT(16) DEFINED SPACE,
         REC_OMIT_TIME BIN FIXED(31,0) UNAL DEFINED SPACE POS(3),
         REC_OMIT_DATE DEC FIXED(7) DEFINED SPACE POS(7),
 /* THESE VARIABLES ARE COMMON TO RECORD TYPES 8,9,10,11 */
         LENGTH BIT(16) DEFINED SPACE,
         UNIT(M) BIT(4) DEFINED SPACE POSITION(3),
         /* THESE VARIABLES ARE COMMON TO RECORD TYPE 13 */
         PART_REC CHAR(10),
         PART BIT(8) DEFINED PART_REC,
         SIZE_H0 BIT(16) DEFINED PART_REC POS(2),
         SIZE_H1 BIT(16) DEFINED PART_REC POS(4),
         CLASS_REC BIT(8) DEFINED PART_REC POS(6),
         JOBCLASS(4) CHAR(1) DEFINED PART_REC POS(7),
         OUTCLASS CHAR(7),
         OUTEST(7) CHAR(1) DEFINED OUTCLASS,
         PLACE(Z) CHAR(10) DEFINED SPACE POS(3),
 /* WORK VARIABLES AND CONSTANTS */
         WORK1 BINARY FIXED(31,15),
         WORK3 DECIMAL FIXED(15,3),
         WORK5 BINARY FIXED(31,15),
         WORK7 BINARY FIXED(31,15),
         WORK9 DECIMAL FIXED(15,2),
         C360 DECIMAL FIXED(6,0),
         WORKA BINARY FIXED(31,15),
         A BINARY FIXED(15,0),
         B BINARY FIXED(15,0),
         C BINARY FIXED(15,0),
         D BINARY FIXED(15,0),
         E BINARY FIXED(15,0),
         G DECIMAL FIXED(15,0),
         J STATIC INITIAL(40),
         K STATIC INITIAL(8),
         L STATIC INITIAL(4),
         M STATIC INITIAL(1600),
         POS BINARY FIXED(15,0),
         S STATIC INITIAL(1),
         Y STATIC INITIAL(1),
         Z STATIC INITIAL(52),
         HEADING CHAR(25) INITIAL(' '),
         TYPE CHARACTER(2),
         DTE CHARACTER(6),
         PAGE_NO DECIMAL FIXED INITIAL(1),
         DATAIN FILE INPUT RECORD,
         SMF(13) LABEL;
         DTE = DATE;
 /* SET UP NORMAL TERMINATION */
         ON ENDFILE(DATAIN) GO TO FINISH;
 /* ON END OF PAGE, SKIP TO A NEW PAGE, PRINT DATE, NEW PAGE NUMBER, AND
    PAGE HEADINGS */
         ON ENDPAGE(SYSPRINT) BEGIN;
              PAGE_NO = PAGE_NO + 1;
         PUT EDIT ('DATE',DTE,'PAGE',PAGE_NO,'RECTME RT  JOBLOGNUMBER  S
 C STRTME RDRSTP SYSIN SYOUT P/PTIME PROGNAME REG COR JC JSP CODE RC/T F
 ORM DC IODEVICE EXCP SWTIME')
                  (PAGE,COL(93),A(4),F(7),COL(109),A(4),F(7),SKIP(2),
                  COL(1),A);
              END;
 /* PRINT REPORT TITLE */
 PUT EDIT ('SSSSSSS    MM     MM    FFFFFFFF',
          'SSSSSSSS    MMM   MMM    FFFFFFFF',
          'SS          MMMM MMMM    FF',
          'SS          MM MMM MM    FF',
          'SSSSSSS     MM  M  MM    FFFFFFF',
           'SSSSSSS    MM     MM    FFFFFFF',
                'SS    MM     MM    FF',
                'SS    MM     MM    FF',
          'SSSSSSSS    MM     MM    FF',
          'SSSSSSS     MM     MM    FF')
          (PAGE,LINE(18),X(50),A,SKIP,X(49),A,SKIP,X(49),A,SKIP,X(49),
          A,SKIP,X(49),A,SKIP,X(50),A,SKIP,X(55),A,SKIP,X(55),A,SKIP,
          X(49),A,SKIP,X(49),A);
                                                              PUT EDIT (
 'RRRRRRR     EEEEEEEE    PPPPPPP      OOOOOO     RRRRRRR     TTTTTTTT',
 'RRRRRRRR    EEEEEEEE    PPPPPPPP    OOOOOOOO    RRRRRRRR    TTTTTTTT',
 'RR    RR    EE          PP    PP    OO    OO    RR    RR       TT',
 'RR    RR    EE          PP    PP    OO    OO    RR    RR       TT',
 'RRRRRRR     EEEEEE      PPPPPPPP    OO    OO    RRRRRRR        TT',
 'RRRR        EEEEEE      PPPPPPP     OO    OO    RRRR           TT',
 'RR RR       EE          PP          OO    OO    RR RR          TT',
 'RR  RR      EE          PP          OO    OO    RR  RR         TT',
 'RR   RR     EEEEEEEE    PP          OOOOOOOO    RR   RR        TT',
 'RR    RR    EEEEEEEE    PP           OOOOOO     RR    RR       TT')
          (SKIP(5),X(32),A,SKIP,X(32),A,SKIP,X(32),A,SKIP,X(32),A,SKIP,
          X(32),A,SKIP,X(32),A,SKIP,X(32),A,SKIP,X(32),A,SKIP,X(32),A,
          SKIP,X(32),A);
 /* AFTER PRINTING REPORT TITLE, SKIP TO NEW PAGE, AND PRINT TABLE
    WHICH DESCRIBES THE INFORMATION CONTAINED UNDER PAGE HEADINGS */
         PUT EDIT ('RECTME       - RECORD TIME STAMP      - HH.TTT IS TH
 E HOUR(HH) AND 1000THS/HOUR(TTT) WHEN THE RECORD WAS ORIGINATED',
                   'RT           - RECORD TYPE            - XX IS THE RE
 CORD TYPE(XX)',
                   'JOBLOGNUMBER - JOB LOG NUMBER         - CCCCCCCCHH.T
 TT IS THE JOB NAME(CCCCCCCC) AS SPECIFIED ON THE JOB CARD AND THE HOUR(
 HH)','AND 1000THS/HOUR(TTT) JOB CARD WAS PROCESSED',
                   'SC           - STEP NUMBER            - XX IS THE ST
 EP NUMBER(XX) WITHIN THIS JOB (STEP TERMINATION RECORD)',
                                '- TOTAL JOB STEPS        - XX IS THE TO
 TAL NUMBER OF STEPS WITHIN THIS JOB (JOB TERMINATION RECORD)',
                                '- OUTPUT WRITER CLASS    - CC IS THE OU
 TPUT WRITER CLASS FOR THIS WRITER (OUTPUT WRITER RECORD)',
                   'STRTME       - STEP INITIATION        - HH.TTT IS TH
 E HOUR(HH) AND 1000THS/HOUR(TTT) STEP INITIATED (STEP TERM. RECORD)',
                                '- JOB INITIATION         - HH.TTT IS TH
 E HOUR(HH) AND 1000THS/HOUR(TTT) JOB INITIATED (JOB TERM. RECORD)',
                                '- OUTPUT WRITER START    - HH.TTT IS TH
 E HOUR(HH) AND 1000THS/HOUR(TTT) WRITER STARTED (WRITER RECORD)')
                   (PAGE,LINE(10),COL(1),A,COL(1),A,COL(1),A,COL(41),A,
                   COL(1),A,COL(14),A,COL(14),A,COL(1),A,COL(14),A,
                   COL(14),A);
         PUT EDIT ('RDRSTP       - READER STOP TIME       - HH.TTT IS TH
 E HOUR(HH) AND 1000THS/HOUR(TTT) READER STOPPED READING FOR THIS JOB',
                   'SYSIN        - SYSIN COUNT            - XXXXX IS THE
 NUMBER(XXXXX) OF LOGICAL RECORDS IN THE DD DATA OR DD * DATA SETS','STE
 P TERMINATION RECORD - NUMBER OF RECORDS THIS STEP','JOB TERMINATION RE
 CORD - TOTAL NUMBER OF RECORDS THIS JOB',
                   'SYOUT        - SYSOUT COUNT           - XXXXX IS THE
 NUMBER OF LOGICAL RECORDS FOR A WRITER PER FORM NUMBER PER CLASS',
                   'P/PTIME      - PROB PROG CPU TIME     - SSSS.HH IS T
 HE NUMBER OF SECONDS(SSSS) AND 100THS/SECONDS(HH) OF PROB PROG EXECUTIO
 N','STEP TERMINATION RECORD - STEP PROB PROG EXECUTION(CPU) TIME','JOB
 TERMINATION RECORD - SUM OF STEP CPU TIMES FOR THIS JOB',
                   'PROGNAME     - PROGRAM NAME           - CCCCCCCC IS
 THE NAME(CCCCCCCC) OF THE PROGRAM EXECUTED BY THIS STEP')
                  (COL(1),A,COL(1),A,COL(41),A,COL(41),A,COL(1),A,
                  COL(1),A,COL(41),A,COL(41),A,COL(1),A);
         PUT EDIT ('REG          - REQUESTED REGION SIZE  - XXX IS THE R
 EGION SIZE(XXX) IN K BLOCKS REQUESTED BY A STEP. TAKEN FROM JOB OR','EX
 EC STATEMENT OR FROM THE READER PROCEDURE DEFAULT',
                   'COR          - ACTUAL MAIN CORE USED  - XXX IS THE A
 CTUAL REGION CORE(XXX) IN K BLOCKS USED BY THIS STEP',
                   'JC           - JOB INPUT CLASS        - X IS THE JOB
  INPUT CLASS(X) FROM THE JOB STATEMENT',
                   'JSP          - JOB SELECTION PRIORITY - XX IS THE PR
 IORITY(XX) WITH WHICH A JOB WAS SELECTED FOR INIT.(JOB TERM REC.)',
                   '             - STEP DISPATCH PRIORITY - XXX IS THE A
 CTUAL PRIORITY(XXX) WITH WHICH A STEP WAS DISPATCHED(STEP TERM REC)',
                   'CODE         - COMPLETION CODE        - XXXX IS THE
 COMPLETION CODE(XXXX) WITH WHICH A JOB/STEP TERMINATED',
                   'RC/T         - READER CLASS/TYPE      - CCTT IS THE
 DEVICE CLASS(CC) AND UNIT TYPE(TT) OF THE SYSTEM READER FOR THIS JOB',
                   'FORM         - FORM NUMBER            - CCCC IS THE
 FORM NUMBER(CCCC) REQUESTED FOR THIS OUTPUT CLASS',
                   'DC           - DATA SET COUNT         - XX IS THE NU
 MBER(XX) OF DATA SETS PER OUTPUT CLASS PER FORM PROCESSED BY THE WRITER
 ','FOR THIS JOB',
                   'IODEVICE     - I/O DEVICE             - CCTT CUA IS
 THE DEVICE CLASS(CC), UNIT TYPE(TT), AND CHANNEL/UNIT ADDRESS( CUA)',
                   'EXCP         - EXCP COUNT             - XXXX IS THE
 NUMBER(XXXX) OF EXCP COUNTS PER DATA SET PER DEVICE',
                   'SWTIME       - SYSTEM WAIT TIME       - MMM.HH IS TH
 E NUMBER OF MINUTES(MMM) AND 100THS/MINUTES(HH) OF CUMULATIVE SYSTEM','
 WAIT TIME SINCE THE LAST SYSTEM WAIT RECORD')
                  (COL(1),A,COL(41),A,COL(1),A,COL(1),A,COL(1),A,
                   COL(1),A,COL(1),A,COL(1),A,COL(1),A,COL(1),A,
                   COL(41),A,COL(1),A,COL(1),A,COL(1),A,
                   COL(41),A);
               PUT EDIT ('MEANING OF HEADINGS APPEARING ON RECORD TYPE 0
  (IPL RECORD)',
                         'SYSTEM        SYSTEM IDENTIFICATION',
                         'MODEL         CPU MODEL NUMBER',
                         'SMFBUF        ONE-HALF SMF BUFFER SIZE(BYTES)'
 ,                       'MAIN CORE(K)  MAIN STORAGE SIZE (1K BLOCKS)',
                         'JWT           JOB WAIT TIME (MINUTES)',
                         'SMFOPT        SMF OPTIONS SELECTED',
                                       'J - SYSTEM/JOB DATA COLLECTION',
                                       'S - SYSTEM/STEP DATA COLLECTION'
 ,                                     'E - SMF EXITS REQUESTED',
                         'DATE          DATE OF IPL (YYDDD)')
                        (SKIP(3),COL(14),A,COL(41),A,COL(41),A,COL(41),
                         A,COL(41),A,COL(41),A,COL(41),A,COL(55),A,
                         COL(55),A,COL(55),A,COL(41),A);
         PUT EDIT ('MEANING OF HEADINGS APPEARING ON RECORD TYPE 13',
                   'PART    PARTITION NUMBER',
                   'H0      PARTITION SIZE IN MAIN STORAGE(1K BLOCKS)',
                   'H1      PARTITION SIZE HIERARCHY 1(1K BLOCKS)',
                   'CLASS   JOB CLASS')
                   (PAGE,LINE(10),COL(14),A,COL(41),A,COL(41),A,COL(41)
                   ,A,COL(41),A);
 /* PRINT HEADINGS FOR FIRST PAGE */
         PUT EDIT ('DATE',DTE,'PAGE',PAGE_NO,'RECTME RT  JOBLOGNUMBER  S
 C STRTME RDRSTP SYSIN SYOUT P/PTIME PROGNAME REG COR JC JSP CODE RC/T F
 ORM DC IODEVICE EXCP SWTIME')
                  (PAGE,COL(93),A(4),F(7),COL(109),A(4),F(7),SKIP(2),
                  COL(1),A);
         C360 = 360000;
 /* READ A RECORD FROM THE INPUT FILE, DATAIN */
  BRING: READ FILE(DATAIN) INTO (COMMON);
 /* CHECK THE RECORD TYPE. IF GREATER THAN 13 THEN GO READ ANOTHER
    RECORD. (THIS PROCESSOR ROUTINE, SMFPOST, WILL ONLY PROCESS
    RECORD TYPES 0 - 13). IF THE RECORD TYPE IS NOT GREATER THAN
    13 AND IS NOT 0 THEN GO TO APPROPRIATE RECORD HANDLING ROUTINE.
    OTHERWISE, PROCESS RECORD TYPE 0 (IPL INITIALIZATION RECORD).  */
         IF RECORD_TYPE > 13 THEN GO TO BRING;
         IF RECORD_TYPE ^= 0 THEN GO TO SMF(RECORD_TYPE);
         WORK3 = TIME_STAMP;
         WORK1 = WORK3/C360;
         K = 8;
         M = 1;
         N = 1;
         OPTION = ' ';
 /* PROCESS THE SMF OPTIONS INDICATED IN SMFDEFLT
    IF THE VALUE OF THE VARIABLE M IS NOT GREATER THAN 8 AND THE BIT,
    AS INDEXED BY M IN OPTIONS IS ON (1) THEN EXTRACT THE CORRE-
    SPONDING LETTER VALUE FROM THE CHARACTER STRING (JSE    W) AND
    PLACE IT IN THE PRINT FIELD. IF M IS NOT GREATER THAN 8, BUT THE
    BIT AS INDEXED IN OPTIONS BY M IS OFF (0) THEN INCREASE M BY 1
    AND GO BACK TO CHECK THE NEXT BIT AS BEFORE. THIS LOOP IS CONT-
    INUED UNTIL M IS GREATER THAN 8 WHICH SHOWS THAT ALL BIT POSITIONS
    HAVE BEEN TESTED */
 SMFOPT: IF M^>3 THEN IF OPTIONS(M) = '1'B
                 THEN DO;
                 OPT(N) = SUBSTR('JSE',M,1);
                 M = M + 1;
                 N = N + 1;
                 GO TO SMFOPT;
                 END;
                 ELSE DO;
                 M = M + 1;
                 GO TO SMFOPT;
                 END;
            ELSE;
 /* PRINT IPL INITIALIZATION VALUES, THEN GO READ NEXT RECORD */
         PUT EDIT (WORK1,'0','SYSTEM=',SYS_ID,'MODEL=',MODEL,'JWT=',
                  JWAIT_TIME,'SMFBUF=',SMFBUF_SIZE,'MAIN CORE(K)=',
                  CORE_SIZE,'SMFOPT=',OPTION,'DATE=',DATE_STAMP)
                  (COL(1),F(6,3),COL(9),A,COL(11),A(7),COL(18),A(2),
                  COL(21),A(6),COL(27),A(2),COL(30),A(4),COL(34),F(3),
                  COL(38),A(7),COL(45),F(5),COL(51),A(13),COL(64),F(4),
                  COL(69),A(7),COL(76),A,COL(81),A,COL(86),F(5));
         GO TO BRING;
 /* SET SYSTEM WAIT TIME RECORD TYPE, BRANCH TO PROCESS SYS WAIT TIME */
 SMF(1): TYPE = ' 1';
         GO TO SYSWATE;
 /* SET END-OF-DAY RECORD TYPE */
 SMF(12): TYPE = '12';
 /* CONVERT RECORD TIME STAMP TO HOUR AND 1000THS/HOUR, SYSTEM WAIT
    TIME FROM 100THS/SECONDS TO MINUTES AND 100THS/MINUTES, PRINT OUT
    RECORD VALUES, THEN GO READ NEXT RECORD */
 SYSWATE: WORK3 = TIME_STAMP;
          WORK1 = WORK3/C360;
          WORK9 = SYSWAIT_TIME;
          WORK9 = WORK9/6000;
         PUT EDIT (WORK1,TYPE,WORK9)
                  (COL(1),F(6,3),COL(8),A,COL(119),F(6,2));
         GO TO BRING;
 /* SET DUMP HEADER RECORD TYPE, THEN BRANCH TO PROCESS TIME STAMP */
 SMF(2): TYPE = ' 2';
         GO TO DUMPREC;
 /* SET DUMP TRAILER RECORD TYPE */
 SMF(3): TYPE = ' 3';
 /* CONVERT DUMP START (TYPE 2) OR STOP (TYPE 3) TIME FROM 100THS/SECS
    TO HOUR AND 1000THS/HOUR, PRINT RECORD VALUES, THEN BRANCH TO READ
    NEXT RECORD */
 DUMPREC: WORK3 = TIME_STAMP;
          WORK1 = WORK3/C360;
         PUT EDIT (WORK1,TYPE) (COL(1),F(6,3),COL(8),A);
         GO TO BRING;
 /* CONVERT JOB, STEP, OR OUTPUT WRITER RECORD TIME STAMPS, READER
    START TIME, AND JOB OR STEP INITIATION OR OUTPUT WRITER START TIMES
    FROM 100THS/SECONDS TO HOUR AND 1000THS/HOURS */
 SMF(4): WORK3 = TIME_STAMP;
         WORK1 = WORK3/C360;
         WORK3 = RDR_START_TIME;
         WORK5 = WORK3/C360;
         WORK3 = START_TIME;
         WORK7 = WORK3/C360;
 /* CHECK FOR JOB OR OUTPUT WRITER RECORD */
         IF RECORD_TYPE = 5 THEN GO TO JOBTYPE;
         IF RECORD_TYPE = 6 THEN GO TO WTRTYPE;
 /* CONVERT STEP P/P CPU TIME FROM 100THS/SECS TO SECONDS AND 100THS  */
         I = UNSPEC(LENGTH1);
         I = I + 90;
         WORK9 = UNSPEC(SUBSTR(SPACE,I,3));
         WORK9 = WORK9/100;
         A = JS_NUMBER;
         C = REGION_REQUEST;
         D = CORE_USED;
         E = PRIORITY;
 /* CONVERT STEP COMPLETION CODE TO PRINTABLE FORM */
         DO I = 1 TO 4;
         L = TERM_STATUS(I) + 1;
         DEVCA(I) = SUBSTR('0123456789ABCDEF',L,1);
         END;
 /* PRINT OUT STEP TERMINATION RECORD VALUES */
         PUT EDIT (WORK1,'4',JOB_NAME,WORK5,A,WORK7,'------',
                  SYSIN_COUNT,'-----',WORK9,PROGRAM_NAME,C,D,'--',E,
                  DEVC(1),'---- ---- --')
                  (COL(1),F(6,3),COL(9),A,COL(11),A(8),COL(19),F(6,3),
                  COL(26),F(2),COL(29),F(6,3),COL(36),A(6),COL(43),
                  F(5),COL(49),A(5),COL(55),F(7,2),COL(63),A(8),
                  COL(72),F(3),COL(76),F(3),COL(80),A(2),COL(83),F(3),
                  COL(87),A(4),COL(92),A(12));
 /* CHECK FOR DEVICES USED BY THIS STEP. IF NONE, PRINT OUT *NONE*, THEN
    BRANCH TO PROCESS ACCOUNTING INFORMATION */
         IF LENGTH1 = 2 THEN DO;
         PUT EDIT ('*NONE*') (COL(106),A(6));
         I = UNSPEC(LENGTH1) + 93;
         GO TO ACCT;
               END;
                        ELSE;
 /* IF DEVICES WERE USED BY THIS STEP, INITIALIZE LOOP VALUES FOR LOOP
    TO PROCESS DEVICES USED AND ASSOCIATED EXCP COUNTS. THE LOOP CON-
    VERTS THE DEVICE CLASS,TYPE, AND CHANNEL UNIT ADDRESS TO PRINTABLE
    FORMS, EXTRACTS EXCP ASSOCIATED WITH THIS DEVICE, PRINTS OUT DEVICE
    AND EXCP COUNTS, INCREMENTS LOOP VALUES, DETERMINES IF ALL THE DE-
    VICES HAVE BEEN PROCESSED AND IF NOT, CONTINUE UNTIL ALL DEVICES
    HAVE PROCESSED; OTHERWISE, BRANCH TO PROCESS ACCTING INFO */
         J = 1;
         K = 8;
         N = 1;
         A = 95;
         B = 0;
         M = (LENGTH1 - 2)*2;
  AGAIN: DO I = J TO K;
         L = UNIT1(I) + 1;
         B = B + 1;
         DEVCE(B) = SUBSTR('0123456789ABCDEF',L,1);
         END;
         G = UNSPEC(SUBSTR(SPACE,A,4));
         DEVCE(5) = ' ';
         PUT EDIT (DEVCD(1),G) (COL(105),A(8),COL(114),F(4));
         J = J + 16;
         K = K + 16;
         A = A + 8;
         N = N + 1;
         B = 0;
         IF J<M THEN GO TO AGAIN;
         ELSE; I = UNSPEC(LENGTH1) + 93; GO TO ACCT;
 /* BRANCH TO CONVERT JOB RECORD TIME STAMP, READER START TIME, AND
    JOB INITIATION START TIME FROM 100THS/SECONDS TO HOUR AND
    1000THS/HOURS */
 SMF(5): GO TO SMF(4);
 /* CONVERT READER STOP TIME FROM 100THS/SECONDS TO HOUR AND
    1000THS/HOUR , AND TOTAL JOB CPU TIME FROM 100THS/SECONS TO SECONDS
    AND 100THS/SECONDS */
 JOBTYPE: WORK3 = RDR_STOP_TIME;
         WORKA = WORK3/C360;
         WORK9 = JPP_CPU_RUN_TIME;
         WORK9 = WORK9/100;
         B = PRIORITY;
         D = JS_NUMBER;
 /* CONVERT READER CLASS/TYPE TO PRINTABLE FORM */
         DO I = 1 TO 4;
         L = RDR_DEV_CLASS_TYPE(I) + 1;
         DEVCC(I) = SUBSTR('0123456789ABCDEF',L,1);
         END;
 /* CONVERT JOB COMPLETION CODE TO PRINTABLE FORM */
         DO I = 1 TO 4;
         L = TERM_STATUS(I) + 1;
         DEVCA(I) = SUBSTR('0123456789ABCDEF',L,1);
         END;
 /* PRINT OUT JOB TERMINATION RECORD VALUES */
         PUT EDIT (WORK1,'5',JOB_NAME,WORK5,D,WORK7,WORKA,SYSIN_COUNT,
                  '-----',WORK9,'-------- --- ---',
               JOB_INPUT_CLASS,B,DEVC(1),
                  DEVCB(1),'---- -- ---- --- ----')
                  (COL(1),F(6,3),COL(9),A,COL(11),A(8),COL(19),F(6,3),
                  COL(26),F(2),COL(29),F(6,3),COL(36),F(6,3),COL(43),
                  F(5),COL(49),A(5),COL(55),F(7,2),COL(63),A(16),
         COL(81),A(1),COL(84),F(2),COL(87),A(4),COL(92),A(4),
                  COL(97),A(21));
         I = 103;
 /* THE NEXT SECTION OF CODE DETERMINES IF THERE IS ACCTING INFO TO PRO-
    CESS. IF NOT, BRANCH TO READ NEXT RECORD. IF THERE IS ACCOUNTING
    INFO, EACH FIELD OF ACCTING INFO IS MOVED TO A PRINT FIELD, AND WHEN
    ALL ACCTING INFO HAS BEEN MOVED TO THE PRINT FIELD, IT IS PRINTED
    OUT. BRANCH TO READ NEXT RECORD */
   ACCT: J = UNSPEC(SUBSTR(SPACE,I,1));
         IF J = 0 THEN GO TO BRING;
                  ELSE;
         I = I + 1;
         K = UNSPEC(SUBSTR(SPACE,I,1));
         M = 0; A = 1;
   LOOP: DO L = A TO K;
         I = I + 1;
         ACCTFLD(L) = SUBSTR(SPACE,I,1);
         END;
         M = M + 1;
         IF J = M THEN DO; PUT EDIT (ACCTING(1)) (COL(11),A);
         ACCTING(1) = ' ';
                           GO TO BRING; END;
         I = I + 1;
         K = UNSPEC(SUBSTR(SPACE,I,1));
         IF K = 0 THEN ACCTFLD(A) = ',';
                  ELSE; A = L + 1; K = K + L; GO TO LOOP;
 /* BRANCH TO CONVERT OUTPUT WRITER RECORD TIME STAMP, READER START
    TIME, AND OUTPUT WRITER START TIME FROM 100THS/SECONDS TO HOUR AND
    1000THS/HOUR */
 SMF(6): GO TO SMF(4);
 WTRTYPE: J = DATA_SET_COUNT;
 /* PRINT OUT OUTPUT WRITER RECORD VALUES, THEN BRANCH TO READ NEXT
    RECORD */
         PUT EDIT (WORK1,'6',JOB_NAME,WORK5,OUTPUT_CLASS,WORK7,
                  '------ -----',SYSOUT_COUNT,'------- -------- ---',
                  '--- -- --- ---- ----',FORM_NUMBER,J,'---- --- ----')
                  (COL(1),F(6,3),COL(9),A,COL(11),A(8),COL(19),F(6,3),
                  COL(27),A,COL(29),F(6,3),COL(36),A,COL(49),F(5),
                  COL(55),A,COL(76),A,COL(97),A,COL(102),F(2),
                  COL(105),A);
         GO TO BRING;
 /* CONVERT DATA LOST RECORD TIME STAMP AND RECORD OMISSION START TIME
    FROM 100THS/SECONDS TO HOUR AND 1000THS/HOUR */
 SMF(7): WORK3 = TIME_STAMP;
         WORK1 = WORK3/C360;
         WORK3 = REC_OMIT_TIME;
         WORK5 = WORK3/C360;
         A = RECORD_COUNT;
 /* PRINT OUT DATA LOST RECORD VALUES */
         PUT EDIT (WORK1,'7',A,'RECORD(S) LOST BEGINNING AT',WORK5)
                  (COL(1),F(6,3),COL(9),A,COL(18),F(5),COL(24),A,
                  COL(52),F(6,3));
         GO TO BRING;
 /* SET UP INITIAL I/O CONFIGURATION RECORD HEADING AND TYPE, THEN
    BRANCH TO PROCESS I/O DEVICE(S) */
 SMF(8): HEADING = 'INITIAL I/O CONFIGURATION'; TYPE = ' 8';
         GO TO DEVICE;
 /* SET UP VARY ONLINE RECORD HEADING AND TYPE, THEN BRANCH TO PROCESS
    DEVICE VARIED ONLINE */
 SMF(9): HEADING = 'VARY ONLINE'; TYPE = ' 9';
         GO TO DEVICE;
 /* CONVERT ALLOCATION RECOVERY RECORD TIME STAMP AND READER START TIME
    FROM 100THS/SECONDS TO HOUR AND 1000THS/HOUR, SET RECORD TYPE, PRINT
    OUT ALLOCATION RECOVERY RECORD VALUES, THEN BRANCH TO PROCESS
    DEVICE */
 SMF(10): WORK3 = TIME_STAMP;
          WORK1 = WORK3/C360;
          WORK3 = RDR_START_TIME;
          WORK5 = WORK3/C360;
          TYPE = '10';
          PUT EDIT (WORK1,TYPE,JOB_NAME,WORK5,'ALLOCATION RECOVERY')
                   (COL(1),F(6,3),COL(8),A,COL(11),A(8),COL(19),F(6,3),
                   COL(50),A);
          J = 49; K = 56; N = 1; B = 0; M = 56; GO TO AGAIN2;
 /* SET UP VARY OFFLINE RECORD HEADING AND TYPE */
 SMF(11): HEADING = 'VARY OFFLINE'; TYPE = '11';
 /* CONVERT RECORD TIME STAMP FROM 100THS/SECONDS TO HOUR AND
    1000THS/HOUR, THEN PRINT OUT VALUES */
 DEVICE: WORK3 = TIME_STAMP;
         WORK1 = WORK3/C360;
         PUT EDIT (WORK1,TYPE,HEADING)
                  (COL(1),F(6,3),COL(8),A,COL(50),A);
 /* THE NEXT SECTION OF CODING PROCESSES THE DEVICES INFORMATION IN
    RECORD TYPES 8,9,10, AND 11. AFTER INITIALIZATION OF LOOP CONTROL
    VARIABLES J,K, AND N, M, WHICH IS EQUAL TO THE NUMBER OF HALF BYTES
    OF DEVICES INFO, IS DETERMINED BY SUBTRACTING 2 (THE SIZE OF THE
    LENGTH FIELD) FROM THE VALUE IN THE LENGTH FIELD AND MULTIPLYING
    THIS RESULT BY 2 TO GIVE THE NUMBER OF HALF BYTES. EACH HALF BYTE
    IS THEN USED AS AN INDEX TO EXTRACT THE CORRESPONDING CHARACTER
    VALUE FROM THE CHARACTER STRING, 012.....DEF. EACH 8 HALF BYTES RE-
    PRESENT 1 DEVICE. THEREFORE, WHEN 8 HALF BYTES HAVE BEEN PROCESSED,
    THE CORRESPONDING DEVICE IS PRINTED OUT. THIS LOOP CONTINUES UNTIL
    ALL DEVICES HAVE BEEN PROCESSED, AT WHICH TIME A BRANCH IS TAKEN TO
    GET THE NEXT RECORD */
 AGAIN1: J = 1;
         K = 8;
         N = 1;
         B = 0;
         M = (LENGTH - 2)*2;
 AGAIN2: DO I = J TO K;
         L = UNIT(I) + 1;
         B = B + 1;
         DEVCE(B) = SUBSTR('0123456789ABCDEF',L,1);
        END;
         DEVCE(5) = ' ';
         PUT EDIT (DEVCD(1)) (COL(105),A(8));
         J = J + 8;
         K = K + 8;
         N = N + 1;
         B = 0;
         IF J<M THEN GO TO AGAIN2;
                ELSE HEADING = ' '; GO TO BRING;
 SMF(13):
         /* SET UP DEFINE RECORD HEADING AND TYPE */
            HEADING='DEFINE';  TYPE='13';
         /* CONVERT RECORD TIME STAMP FROM 100THS/SECONDS TO HOUR AND
            1000THS/HOUR, THEN PRINT OUT VALUES */
         WORK3=TIME_STAMP;
         WORK1=WORK3/C360;
         PUT EDIT (WORK1,TYPE,HEADING,'PART','H0','H1','CLASS')
                   (COL(1),F(6,3),COL(8),A,COL(50),A,COL(90),A(4),
                  COL(98),A(2),COL(105),A(2),COL(112),A(5));
         J=1;
         I=1;
         M=LENGTH-2;
 LOOPA:
         PART_REC=PLACE(I);
         K=PART;
         A=SIZE_H0;
         B=SIZE_H1;
         L=CLASS_REC;
         IF CLASS_REC^='00000001'B
           THEN GO TO MORE;
         IF JOBCLASS(2)='W' THEN
           DO;
           OUTCLASS='  WTR  ';
           GO TO OUTER;
           END;
         IF JOBCLASS(2)='R' THEN
           DO;
           OUTCLASS='  RDR  ';
           GO TO OUTER;
           END;
         OUTEST(4)=JOBCLASS(4);
           GO TO OUTER;
         /*THE FOLLOWING LOOP WILL CAUSE COMMAS TO BE INSERTED*/
         /*BETWEEN JOB CLASSES IN THE OUTPUT LISTING          */
 MORE:
         POS=1;
         G=5-L;
         DO S=1 TO L;
           IF S=1 THEN GO TO SKIP;
         OUTEST(POS)=',';
           POS=POS+1;
         SKIP:
         OUTEST(POS)=JOBCLASS(G);
           POS=POS+1;
         G=G+1;
         END;
 OUTER:
         PUT EDIT  (K,A,B,
                    OUTCLASS)
                  (COL(90),F(4),COL(97),F(4),COL(104),F(4),
                  COL(111),A(7));
         OUTCLASS=' ';
         I=I+1;
         J=J+10;
         IF J<M THEN GO TO LOOPA;
         GO TO BRING;
 /* PRINT OUT REPORT TRAILER */
 FINISH: PUT EDIT ('EEEEEEEEEE     NN       NN    DDDDDDDDDD',
                   'EEEEEEEEEE     NNN      NN     DDDDDDDDDD',
                   'EE             NNNN     NN     DD      DD',
                   'EE             NN NN    NN     DD      DD',
                   'EEEEEEEE       NN  NN   NN     DD      DD',
                   'EEEEEEEE       NN   NN  NN     DD      DD',
                   'EE             NN    NN NN     DD      DD',
                   'EE             NN     NNNN     DD      DD',
                   'EEEEEEEEEE     NN      NNN     DDDDDDDDDD',
                   'EEEEEEEEEE     NN       NN    DDDDDDDDDD')
                  (PAGE,LINE(25),X(45),A,SKIP,X(45),A,SKIP,X(45),A,
                  SKIP,X(45),A,SKIP,X(45),A,SKIP,X(45),A,SKIP,X(45),
                  A,SKIP,X(45),A,SKIP,X(45),A,SKIP,X(45),A);
         END;
/*
