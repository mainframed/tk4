 UTLSMRY:    PROC  OPTIONS(MAIN);
    %SKIP(1);
 /* XB01D030 IS THE SECOND IN A SERIES OF SMF PROCESSING AND BILLING  */
 /* PROGRAMS FOR THE COUNTY OF L.A. IT HAS TWO PRIMARY FUNCTIONS.     */
 /* THE FIRST IS TO SELECT THE SMF RECORD TYPES NECESSARY FOR THE     */
 /* LACS BILLING SYSTEM AND PASS THEM ON TO THE NEXT PROGRAM IN THE   */
 /* CHAIN (DDNAME = SMFOUT). PART OF THIS FUNCTION IS TO COMPRESS THE */
 /* TYPES 14 & 15 RECORDS, SAVING ONLY THAT DATA WHICH IS NECESSARY   */
 /* FOR OUR BILLING. THE SECOND FUNCTION IS TO PRODUCE A UTILIZATION  */
 /* SUMMARY REPORT FOR MANAGEMENT AND FOR OVERVIEW VISIBILITY BY THE  */
 /* PERFORMANCE AND TUNING SYSTEM PROGRAMMER.                         */
 /*                                                                   */
 /* THE INPUT TO XB01D030 IN OUR ENVIRONMENT ARE FOUR DAILY SMF TAPES */
 /* (DUMPED FROM MANX OR MANY). THESE TAPES EACH REFLECT THE DAYS SMF */
 /* DATA FROM APPROX. 0000-2400 ON ONE OF FOUR SYSTEMS. APPROPRIATELY */
 /* THIS PROGRAM WILL PRODUCE A UTILIZATION REPORT FOR EACH OF ONE TO */
 /* FOUR SYSTEMS BY CONCATINATING THE SMF TAPE(S) IN DD: SMFIN.       */
 /*                                                                   */
 /* IN THE EVENT THAT THE INPUT FOR A SYSTEM CONTAINS DATA FOR MORE   */
 /* THAN ONE DAY OR A PART THEREOF (I.E. DATA FROM 2330 OF ONE DAY TO */
 /* 2330 OF THE NEXT), THE PROGRAM WILL REPORT ONLY ON THE DAY THAT   */
 /* REPRESENTS THE HIGHEST NUMBER OF SMF RECORDS.                     */
 /*                                                                   */
 /* THE OUTPUT FROM XB01D030 (DD: SMFOUT) IS ONE TAPE THAT CONTAINS   */
 /* THE SELECTED SMF RECORDS FROM ALL SYSTEM(S) FOR LATER PROCESSING  */
 /* BY OUR BILLING SYSTEM. THIS INCLUDES THE COMPRESSED TYPES 14 & 15 */
 /* RECORDS BUT DOES NOT INCLUDE TYPE 7X RECORDS.                     */
 /*                                                                   */
 /* PARAMETER CONTROL AND RECORD TYPE SELECTION - SMF RECORD TYPE     */
 /* SELECTION IS BASED ON OUR BILLING REQUIREMENTS AND THOSE OF THE   */
 /* DAILY SUMMARY REPORT SECTION. THE SUMMARY REPORT REQUIRES SMF     */
 /* RECORD TYPES 0,4,5,10,21,26,34,35,40,70,71,72 AND 73. THE SUMMARY */
 /* REPORT HAS DEFAULT VALUES FOR THE DAY SHIFT, SWING SHIFT, GRAVE   */
 /* SHIFT, AM PEAK AND PM PEAK PERIODS. ANY OR ALL OF THESE VALUES    */
 /* MAY BE CHANGED IN THE 'RPTPARM' DD INPUT STREAM (OR SYSIN POINTED */
 /* TO BY RPTPARM AS IS DONE IN OUR PROC). CARE MUST BE USED IN       */
 /* SELECTING VALUES FOR THE SHIFT PERIODS AS THERE ARE SOME ASSUMP-  */
 /* TIONS AND RULES THAT APPLY HERE. SEE 'RPTPARM' CODE FOR THESE     */
 /* RULES, INPUT KEYWORDS AND FORMAT.                                 */
     %PAGE;
 /* MISCELLANEOUS REQUIREMENTS, CONSIDERATIONS AND IDIOSYNCRASIES---- */
 /* >> IN ORDER TO DISTINGUISH THE TYPE 26 AND 40 RECORDS BETWEEN     */
 /* BATCH AND TSO JOBS, I INCLUDED CODE IN OUR SMF EXIT: IEFUJV TO    */
 /* FLAG TSO RELATED RECORDS WITH 'TS' IN THE LAST TWO BYTES OF THE   */
 /* USERID FIELD: OFFSET 30(1E) +6. THIS FEATURE IS ALSO USED BY SOME */
 /* OF OUR BILLING PROGRAMS.                                          */
 /* >> SORT IS USED WITH E15 AND E35 EXITS TO ASSURE THAT ALL DATA TO */
 /* THE REPORT GENERATOR IS IN DATE/TIME ASCENDING SEQUENCE. DATA     */
 /* FROM THE TYPE00 (IPL) RECORDS ARE SAVED UNTIL REPORT TIME TO      */
 /* CALCULATE THE TOTAL TSO OUTAGE TIME SINCE THE LAST TSO TIME IS    */
 /* NOT KNOWN UNTIL THEN.                                             */
 /* >> PROGRAM WILL ALLOW 16 PERFORMANCE GROUP NUMBERS AND THE HIGH-  */
 /* EST PGN NUMBER MUST BE <= 16. THE SAME APPLIES TO THE DOMAINS:    */
 /* #DOMAINS & DOMAIN# <= 16.                                         */
 /* >> THIS VERSION (IMPLYING LATER VERSIONS??) IS DEPENDENT ON RMF   */
 /* VERSION 2.X PROGRAM NUMBER 5740-XY4 FOR TYPE 7X FORMATS. TIME     */
 /* PERMITTING, A FUTURE VERSION WILL BE WRITTEN TO BE RMF INDEPENDENT*/
 /* POSSIBLY THIS FUTURE VERSION WILL ALSO ACCOMODATE ANY VARIABLE    */
 /* NUMBER OF SYSTEMS AND NOT BE RESTRICTED TO FOUR.                  */
 /* >> IN OUR ENVIRONMENT, THE DAILY SUMMARY REPORT FITS NICELY ON    */
 /* TWO PAGES. HOWEVER, IF AN INSTALLATION HAS MANY PERF GROUPS,      */
 /* DOMAINS, OR CHANNELS (ALL <= 16), A THIRD PAGE MAY BE NECESSARY.  */
 /* OUR INSTALLATION HAS ABOUT 10 PERFORMANCE GROUPS, 5 DOMAINS AND   */
 /* 5 BLOCK MPX CHANNELS. THIS FITS ON TWO PAGES WITH ROOM TO SPARE.  */
 /* NOTE: NO THIRD PAGE EJECTING OR HEADING IS PROVIDED.              */
 /*                                                                   */
 /* A HISTORY DATASET CONSISTING OF ALL THE PERTINENT COUNTERS AND    */
 /* PROGRAM VARIABLES IS WRITTEN TO FACILITATE SUBSEQUENT WEEKLY OR   */
 /* MONTHLY REPORTING. DDNAME = HISTORY. THE DCB IS SPECIFIED IN THE  */
 /* PROGRAM: DCB=(RECFM=F,BLKSIZE=13816)  (IF DISK, MAKE SURE DEVICE  */
 /* WILL ACCOMODATE THIS BLOCK SIZE. IE. 3350 BUT NOT 3330 ETC.)      */
 /*                                                                   */
 /*                                                                   */
 /*        THIS PROGRAM WAS WRITTEN IN 1977 BY                        */
 /*                                                                   */
 /*        BOB WIDNEY                                                 */
 /*        COUNTY OF LOS ANGELES                                      */
 /*        DATA PROCESSING DEPARTMENT                                 */
 /*        IBM TECHNOLOGY DIVISION                                    */
 /*        9150 IMPERIAL HWY.                                         */
 /*        DOWNEY, CALIF.      90242                                  */
    %PAGE;
 /* THE FOLLOWING IS A SAMPLE OF THE JCL TO RUN UTLSMRY (XB01D030)    */
 /*                                                                   */
 /* //G030   EXEC PGM=XB01D030,REGION=640K
    //STEPLIB  DD DSN=SYS1.PLILIB,DISP=SHR    ** PL1 OPTIMIZER **
    //         DD DSN=SYS1.SORTLIB,DISP=SHR
    //         DD DSN=LINKLIB.FOR.XB01D030.IF.NOT.IN.LNKLSTXX,DISP=SHR
    //SORTLIB  DD DSN=SYS1.SORTLIB,DISP=SHR
    //SMFIN    DD DSN=SYSXB.XB01A01.RAWSMF(+0),DISP=OLD
    //         DD DSN=SYSXB.XB01B01.RAWSMF(+0),DISP=OLD
    //         DD DSN=SYSXB.XB01C01.RAWSMF(+0),DISP=OLD
    //         DD DSN=SYSXB.XB01D01.RAWSMF(+0),DISP=OLD
    //SMFOUT   DD DUMMY,DCB=(RECFM=VBS,LRECL=4096,BLKSIZE=10000)
    //HISTORY  DD DUMMY  (DO NOT SPECIFY DCB ATTR: ARE IN PGM DCB)
    //RPTPARM  DD *       DUMMY IS ALSO OK IF DEFAULTS TO BE TAKEN
    /*    DEFAULTS TAKEN
    //SYSPRINT DD SYSOUT=A
    //SYSOUT   DD SYSOUT=A
    //SORTWK01 DD UNIT=SYSDA,SPACE=(CYL,(12),,CONTIG)
    //SORTWK02 DD UNIT=SYSDA,SPACE=(CYL,(12),,CONTIG)
    //SORTWK03 DD UNIT=SYSDA,SPACE=(CYL,(12),,CONTIG)
    //SORTWK04 DD UNIT=SYSDA,SPACE=(CYL,(12),,CONTIG)
    //SORTWK05 DD UNIT=SYSDA,SPACE=(CYL,(12),,CONTIG)
    //SORTWK06 DD UNIT=SYSDA,SPACE=(CYL,(12),,CONTIG)
    //SYSUDUMP DD SYSOUT=T,HOLD=YES
    //PLIDUMP  DD SYSOUT=C   DUMMY OUTPUT CLASS                     */
    %PAGE;
   DCL  SMFIN    FILE RECORD ENV(VBS),
        SMFOUT   FILE RECORD ENV(VBS)  OUTPUT,
        HISTORY  FILE RECORD ENV(F BLKSIZE(13816)) OUTPUT;
    %SKIP(1);
   DCL  SMFREC          CHAR(10000) VAR,
        SMF1415_REC     CHAR(6412)  VAR;
    %SKIP(1);
   DCL  FIRSTSW(4)       BIT(1) ALIGNED   STATIC INIT((04)('0'B)),
        FIRSTTSO(4)      BIT(1) ALIGNED   STATIC INIT((04)('0'B)),
        FIRST#72         BIT(1) ALIGNED   STATIC INIT('0'B),
        SMF_TYPE(0:130)  BIT(1) ALIGNED   STATIC INIT((131)('0'B)),
        SMF_COUNT(4,0:130) BIN FIXED(31)  STATIC INIT((524)(0));
    %SKIP(1);
   DCL  P1       POINTER,  /*  PTR TO ALL SMF RECORDS ON INPUT        */
        PDEV     POINTER,  /*  PTR TO DEVICE SECTS OF TYPES 4, 34, 40 */
        PREL     POINTER,  /*  PTR TO RELOCATE SECTS OF TYPES 4 & 34  */
        P1OL     BIN FIXED(31,0) DEF P1,    /* OVERLAYS               */
        PDEVOL   BIN FIXED(31,0) DEF PDEV,  /*      FOR POINTER       */
        PRELOL   BIN FIXED(31,0) DEF PREL,  /*           ARITHMETIC   */
        RETURN_ADDR   LABEL;
    %SKIP(1);
   DCL /*   COMMON DATA IN 1ST 14 BYTES OF ALL SMF RECORDS        */
      1 COMMON BASED(P1),
         3 VLEN          CHAR(2),
         3 RESERVED      BIT(8) ALIGNED,
         3 REC_TYPE      BIT(8) ALIGNED,
         3 SMFTIME       BIN FIXED(31,0),
         3 SMFDATE       DEC FIXED(7),
         3 SYSID         CHAR(4),
         3 JOBNAME       CHAR(8),
         3 JOBTIME       BIN FIXED(31,0),
         3 JOBDATE       DEC FIXED(7),
         3 DATA          CHAR(5000);
    %SKIP(1);
   DCL  DEV_CL          BIT(8) ALIGNED    STATIC  INIT('00000000'),
        TAPE_DEV        BIT(8) ALIGNED    STATIC  INIT('10000000'),
        DISK_DEV        BIT(8) ALIGNED    STATIC  INIT('00100000');
    %PAGE;
   DCL  SYSTOTAL(4)     BIN FIXED(31,0)   STATIC  INIT((4)(0)),
        GRTOTAL         BIN FIXED(31,0)   STATIC  INIT(0),
        IDMNSU(16)      BIN FIXED(31,0)   STATIC  INIT((16)(0)),
        #72IST1         BIN FIXED(31,0)   STATIC  INIT(0),
        REC#            BIN FIXED(31,0)   STATIC  INIT(0),
        BILLCNT         BIN FIXED(31,0)   STATIC  INIT(0),
        ERRCNT          BIN FIXED(15,0)   STATIC  INIT(0),
        STIME           BIN FIXED(31,0)   STATIC  INIT(0),
        OUT_TIME        BIN FIXED(31,0)   STATIC  INIT(0),
        BGNTIME         BIN FIXED(31,0)   STATIC  INIT(0),
        START_TIME      BIN FIXED(31,0)   STATIC  INIT(0),
        STOP_TIME       BIN FIXED(31,0)   STATIC  INIT(0),
        START_TSO       BIN FIXED(31,0)   STATIC  INIT(0),
        STOP_TSO        BIN FIXED(31,0)   STATIC  INIT(0),
        AMP1            BIN FIXED(31,0)   STATIC  INIT(0),
        AMP2            BIN FIXED(31,0)   STATIC  INIT(0),
        PMP1            BIN FIXED(31,0)   STATIC  INIT(0),
        PMP2            BIN FIXED(31,0)   STATIC  INIT(0),
        DSH1            BIN FIXED(31,0)   STATIC  INIT(0),
        DSH2            BIN FIXED(31,0)   STATIC  INIT(0),
        SWSH1           BIN FIXED(31,0)   STATIC  INIT(0),
        SWSH2           BIN FIXED(31,0)   STATIC  INIT(0),
        AMPEAK_START    BIN FIXED(31,0)   STATIC,
        AMPEAK_STOP     BIN FIXED(31,0)   STATIC,
        PMPEAK_START    BIN FIXED(31,0)   STATIC,
        PMPEAK_STOP     BIN FIXED(31,0)   STATIC,
        DAYSHFT_START   BIN FIXED(31,0)   STATIC,
        DAYSHFT_STOP    BIN FIXED(31,0)   STATIC,
        SWNGSHFT_START  BIN FIXED(31,0)   STATIC,
        SWNGSHFT_STOP   BIN FIXED(31,0)   STATIC,
        GRVESHFT_START  BIN FIXED(31,0)   STATIC,
        GRVESHFT_STOP   BIN FIXED(31,0)   STATIC;
    %SKIP(1);
   DCL  (I,I#DEVS,ICH#,ICPU,IDEV,IDMN,IM,INTV,
         IPEAK,IPERIOD,IPGN,IPHCH,IPL#,
         ISHIFT,ISYS#,ITYPE,IX,IXPROC,LUCBS) STATIC;
    %SKIP(2);
   DCL  MSG01           CHAR(080) INIT('XB01D030-1 SYNTAX ERROR DETECTED
  IN ONE OR MORE SYSIN CONTROL KEYWORDS'),
        MSG02           CHAR(070) INIT('XB01D030-2 SORT INPUT PROCESSING
  COMPLETED. SELECTED RECORD COUNT ='),
        MSG03           CHAR(090) INIT('XB01D030-3 TWENTY ERRORS ENCOUNT
 ERED IN PROGRAM. DAILY REPORT DATA COLLECTING TERMINATED'),
        MSG04           CHAR(100) INIT('XB01D030-4 TOO MANY UNRECOVERABL
 E ERRORS ENCOUNTERED. PROCESSING TERMINATED. DEBUG AND RERUN PGM.'),
        MSG04D          CHAR(072) INIT('XB01D030-4 UNRECOVERABLE ERRORS
 ENCOUNTERED. PROCESSING TERMINATED');
    %PAGE;
   DCL  WORKBIN1        BIN FIXED(31,0)   STATIC,
        WORKBIN2        BIN FIXED(31,0)   STATIC,
        WORKBIN3        BIN FIXED(31,0)   STATIC,
        WORKBIN4        BIN FIXED(31,0)   STATIC,
        WORKFP          DEC FLOAT(16)     STATIC,
        WORKFP1         DEC FLOAT(16)     STATIC,
        WORKFP2         DEC FLOAT(16)     STATIC,
        WORKFP3         DEC FLOAT(16)     STATIC,
        WORKFP4         DEC FLOAT(16)     STATIC,
        BET_JOB(4)      DEC FLOAT(16)     STATIC,
        TIM_SESS(4)     DEC FLOAT(16)     STATIC,
        QTIME(4)        DEC FLOAT(16)     STATIC,
        JTURNS(4)       DEC FLOAT(16)     STATIC,
        SU_XACT(4)      DEC FLOAT(6)      STATIC,
        XACT_SESS(4)    DEC FLOAT(6)      STATIC,
        PAGES_SEC(4)    DEC FLOAT(6)      STATIC,
        PF_SEC(4)       DEC FLOAT(6)      STATIC,
        SU_SEC(4)       DEC FLOAT(6)      STATIC,
        SWO_TIME(4)     DEC FLOAT(6)      STATIC,
        SWAPSM(4)       DEC FLOAT(6)      STATIC,
        CPUBUSY(4)      DEC FLOAT(6)      STATIC,
        TSUSEC(4)       DEC FLOAT(6)      STATIC,
        CSUSEC(4)       DEC FLOAT(6)      STATIC,
        ISUSEC(4)       DEC FLOAT(6)      STATIC,
        MSUSEC(4)       DEC FLOAT(6)      STATIC,
        INTVL(4)        DEC FLOAT(6)      STATIC,
        AMP_INT         DEC FLOAT(6)      STATIC,
        PMP_INT         DEC FLOAT(6)      STATIC,
        DAY_INT         DEC FLOAT(6)      STATIC,
        SWNG_INT        DEC FLOAT(6)      STATIC,
        GRV_INT         DEC FLOAT(6)      STATIC,
   /*  PRVXX = PRORATE VALUE = % EXPRESSED AS A DECIMAL             */
        PRVPK           DEC FLOAT(16)     STATIC,
        PRVDS           DEC FLOAT(16)     STATIC;
    %SKIP(1);
   DCL  NDATE1(4)       BIN FIXED(31,0)   STATIC  INIT((4)(0)),
        NDATE2(4)       BIN FIXED(31,0)   STATIC  INIT((4)(0)),
        DATE1(4)        DEC FIXED(7)      STATIC  INIT((4)(0)),
        DATE2(4)        DEC FIXED(7)      STATIC  INIT((4)(0)),
        LAST_DATE(4)    DEC FIXED(7)      STATIC  INIT((4)(0));
   %PAGE;
 /*   GET AMPEAK/PMPEAK/DAYSHFT/SWNGSHFT/GRVESHFT PARM VALUES        */
    OPEN FILE(SYSPRINT) STREAM OUTPUT PRINT LINESIZE(132) PAGESIZE(60);
      ON ENDFILE(RPTPARM);
      ON CONVERSION
      BEGIN;
        DCL ONSOURCE BUILTIN;
        PUT SKIP(2) EDIT(MSG01) (SKIP(2),A);
        PUT SKIP(2) DATA(DAYSHFT,SWNGSHFT,GRVESHFT,AMPEAK,PMPEAK);
        PUT SKIP(1) EDIT('STRING IN ERROR=  ',ONSOURCE)(A);
        PUT SKIP(2) EDIT('********** PROCESSING TERMINATED')(A);
        GOTO FINISH;
      END;
   GET FILE(RPTPARM) DATA(AMPEAK,PMPEAK,DAYSHFT,SWNGSHFT,GRVESHFT);
   GET STRING(AMPEAK)   EDIT(AMPEAK_START,AMPEAK_STOP)    (R(FMT_TIME));
   GET STRING(PMPEAK)   EDIT(PMPEAK_START,PMPEAK_STOP)    (R(FMT_TIME));
   GET STRING(DAYSHFT)  EDIT(DAYSHFT_START,DAYSHFT_STOP)  (R(FMT_TIME));
   GET STRING(SWNGSHFT) EDIT(SWNGSHFT_START,SWNGSHFT_STOP)(R(FMT_TIME));
   GET STRING(GRVESHFT) EDIT(GRVESHFT_START,GRVESHFT_STOP)(R(FMT_TIME));
 FMT_TIME:    FORMAT(F(4),X(1));
    %SKIP(1);
      ON CONVERSION SYSTEM;   /* RETURN TO DEFAULT SYSTEM HANDLING */
    %SKIP(1);
 /*  PROGRAM ASSUMES AND FORCES FOLLOWING CRITERIA:                   */
 /*    GRAVE SHIFT STARTS >>AT<< MIDNIGHT (0000) OR >>BEFORE<<        */
 /*    MIDNIGHT (BETWEEN 1600 AND 2359) AND ENDS >>AFTER<<  MIDNIGHT!!*/
    %SKIP(1);
      IF GRVESHFT_START =  2400               ×
         SWNGSHFT_STOP  >  2400               ×
         GRVESHFT_STOP  >  2400               ×
         DAYSHFT_START  >  DAYSHFT_STOP       ×
         SWNGSHFT_START >  SWNGSHFT_STOP      ×
       ((GRVESHFT_START <  GRVESHFT_STOP) & (GRVESHFT_START ^= 0))  ×
       ((GRVESHFT_START ^= SWNGSHFT_STOP)     &
                 ((GRVESHFT_START ^= 0) × (SWNGSHFT_STOP ^= 2400))) ×
         DAYSHFT_START  ^= GRVESHFT_STOP      ×
         SWNGSHFT_START ^= DAYSHFT_STOP       THEN
         DO;
           PUT EDIT('XB01D030-B ERROR IN SYSIN CONTROL KEYWORDS',
      '     ONE OF THE FOLLOWING RULES WAS BROKEN:',
      '1. ALL TIME MUST BE ACCOUNTED FOR IN A SHIFT',
      '2. NO OVERLAPPING OF SHIFT TIMES',
      '3. VALUES FOR END OF ANY SHIFT AND BEGIN OF NEXT SHIFT MUST BE ',
      '   THE SAME. ONLY EXCEPTION: SWINGSHIFT ENDS AT 2400 AND ',
      '   GRAVE SHIFT BEGINS AT 0000',
      '4. GRAVE SHIFT MUST START BETWEEN 1600 AND 2359 (OR 0000)',
      '   AND END *AFTER* MIDNIGHT',
      '5. NO SHIFT TERMINATING TIME VALUE > 2400',
      '6. DAY AND SWING SHIFT STOP TIMES MUST BE > START TIMES')
              (SKIP(2),A,10 (SKIP(1),A));
           PUT SKIP(2) DATA(DAYSHFT,SWNGSHFT,GRVESHFT);
           PUT SKIP(2) EDIT('********** PROCESSING TERMINATED')(A);
           GOTO FINISH;
         END;
    %PAGE;
  /*  CONVERT START/STOP VALUES TO 1/100 SECONDS                     */
   AMP1 = (((AMPEAK_START / 100) * 60) +(MOD(AMPEAK_START,100))) * 6000;
   AMP2 = (((AMPEAK_STOP  / 100) * 60) +(MOD(AMPEAK_STOP,100)))  * 6000;
   PMP1 = (((PMPEAK_START / 100) * 60) +(MOD(PMPEAK_START,100))) * 6000;
   PMP2 = (((PMPEAK_STOP  / 100) * 60) +(MOD(PMPEAK_STOP,100)))  * 6000;
   DSH1 = (((DAYSHFT_START/ 100) * 60) +(MOD(DAYSHFT_START,100)))* 6000;
   DSH2 = (((DAYSHFT_STOP / 100) * 60) +(MOD(DAYSHFT_STOP,100))) * 6000;
   SWSH1= (((SWNGSHFT_START/100) * 60) +(MOD(SWNGSHFT_START,100)))*6000;
   SWSH2= (((SWNGSHFT_STOP /100) * 60) +(MOD(SWNGSHFT_STOP,100))) *6000;
   %SKIP(1);
   AMP_INT  = (AMP2 - AMP1) / 100;    /* AMPEAK INTERVAL IN SECONDS   */
   PMP_INT  = (PMP2 - PMP1)   / 100;  /* PMPEAK INTERVAL IN SECONDS   */
   DAY_INT  = (DSH2 - DSH1)   / 100;  /* DAY SH INTERVAL IN SECONDS   */
   SWNG_INT = (SWSH2 - SWSH1) / 100;  /* SWNG SH INTERVAL IN SECONDS  */
   GRV_INT  = 86400 - (DAY_INT + SWNG_INT); /* GRV SH INT IN SECONDS  */
    %SKIP(4);
   /*  TURN ON TYPE OF SMF RECORDS TO BE COLLECTED                */
    %SKIP(1);
   SMF_TYPE(00), SMF_TYPE(02), SMF_TYPE(03), SMF_TYPE(04), SMF_TYPE(05),
   SMF_TYPE(06), SMF_TYPE(07), SMF_TYPE(10), SMF_TYPE(14), SMF_TYPE(15),
   SMF_TYPE(20), SMF_TYPE(21), SMF_TYPE(26), SMF_TYPE(34), SMF_TYPE(35),
   SMF_TYPE(40), SMF_TYPE(64), SMF_TYPE(130) = '1'B;
    %SKIP(1);
   SMF_TYPE(70), SMF_TYPE(71), SMF_TYPE(72), SMF_TYPE(73)  = '1'B;
          %PAGE;
   /*  INVOKE SORT SPECIFYING USE OF E15 AND E35 EXITS    */
   %SKIP(1);
   DCL  /*   LENGTH IN SORT STMT ALLOWS FOR 4 BYTE RDW: 7+4=11       */
        /*   SORT IS BY SMFXXDTE & SMFXXTME ASCENDING.               */
      SORTSTMT    CHAR(80)  STATIC
                  INIT(' SORT FIELDS=(11,4,PD,A,7,4,BI,A) '),
      RECSTMT     CHAR(80)  STATIC
                  INIT(' RECORD TYPE=V,LENGTH=(5000,,5000,30,300) '),
      RTNCODE     BIN FIXED(31,0)  STATIC;
          %SKIP(1);
   P1 = ADDR(SMFREC);
   OPEN FILE(SMFIN) INPUT;
   CALL PLISRTD(SORTSTMT,RECSTMT,80000,RTNCODE,E15X,E35X);
   IF RTNCODE = 0 THEN
      PUT SKIP(2)  LIST('SORT COMPLETE');     ELSE
   IF RTNCODE = 16 THEN
      PUT SKIP(2)  LIST('SORT FAILED');       ELSE
      PUT SKIP(2)  EDIT('INVALID SORT RTN CODE:',RTNCODE)(A,X(2),F(4));
     %SKIP(4);
   PUT EDIT('***** COUNTS OF SMF RECORDS PROCESSED: ***** ',' ',
            'SYSTEM ID:',
           (SYS#(ISYS#) DO ISYS# = 1 TO 4 WHILE(SYS#(ISYS#) ^= '    ')))
           (PAGE,A,2 (SKIP(1),A),COL(26),4 (X(4),A));
   PUT EDIT('TOTAL',' ')(X(3),A,SKIP(1),COL(120),A);
   DO ITYPE = 0 TO 130;
     REC# = 0;
     IF SMF_TYPE(ITYPE) THEN
     DO;
       DO I = 1 TO 4 WHILE(SYS#(I) ^= '    ');
         REC# = REC# + SMF_COUNT(I,ITYPE);
       END;
       PUT EDIT('RECORD COUNT FOR TYPE ',ITYPE,
                   (SMF_COUNT(I,ITYPE) DO I = 1 TO 4
                   WHILE(SYS#(I) ^= '    ')),REC#)
           (SKIP(1),A,F(3),5 F(8));
       END;
     END;
     DO I = 1 TO 4;
       GRTOTAL = GRTOTAL + SYSTOTAL(I);
     END;
     PUT EDIT('SYSTEM TOTALS',(SYSTOTAL(I) DO I = 1 TO 4
                               WHILE(SYS#(I) ^= '    ')),GRTOTAL)
             (SKIP(2),A,COL(26),5 F(8));
     PUT EDIT('BILLING RECORD COUNT (NON 7X) ',BILLCNT)(SKIP(2),A,F(8));
    %PAGE;
 REPORTS:
     DO ISYS# = 1 TO 4  WHILE(SYS#(ISYS#) ^= '    ');
       START_TIME = (FIRST_TIME(ISYS#) / 360000 * 100)
                   + MOD(ROUND(FIRST_TIME(ISYS#) / 6000,0),60);
       STOP_TIME  = (LAST_TIME(ISYS#)  / 360000 * 100)
                   + MOD(ROUND(LAST_TIME(ISYS#)  / 6000,0),60);
       START_TSO  = (FIRST_TSO(ISYS#)  / 360000 * 100)
                   + MOD(ROUND(FIRST_TSO(ISYS#)  / 6000,0),60);
       STOP_TSO   = (LAST_TSO(ISYS#)   / 360000 * 100)
                   + MOD(ROUND(LAST_TSO(ISYS#)   / 6000,0),60);
       PUT STRING(TSOHOURS) EDIT(START_TSO,'-',STOP_TSO)(P'9999',A);
       RETURN_ADDR = TSO_REPORT;
    %SKIP(2);
 REPORT_HEAD:
       PUT EDIT(
       'DAILY SYSTEM SUMMARY',GREGDTE(PROCESS_DATE(ISYS#)),
       'SYSTEM ID:  ',SYS#(ISYS#),
       'FROM: ',START_TIME,'TO: ',STOP_TIME)
       (PAGE,A,COL(40),A,
        SKIP(2),2 A,COL(52),A,P'9999',COL(66),A,P'9999');
       GOTO RETURN_ADDR;
    %PAGE;
 /* THE FOLLOWING DESCRIBES HOW EACH ITEM IS CALCULATED.             */
 /*  ALL APPLICABLE INTERVALS HAVE BEEN ADJUSTED FOR OUTAGE TIME.    */
 /*  SIG = SUMMATION,  RI = REPORT INTERVAL,   PR = PRORATED FOR RI  */

 /* TSO REPORT *******************************************************/

 /*  OUTAGE ---------------  SIG LAST SMF RECORD TO IPL RECORD FOR RI*/
 /*  SESSIONS COMPLETED ---  SIG SMF TYPE 35 RECORDS FOR RI          */
 /*  TRANSACTIONS COMPLETED  SIG TLGNTSN (TYPE35)                    */
 /*  SESSION TIME ---------  SIG SESSION TIME FOR ALL SESSIONS IN RI:*/
 /*                (TLGRCDTS - TLGONTME)  (PR) (SMF35)               */
 /*  TIME/SESSION ---------  AVERAGE SESSION TIME FOR RI:            */
 /*                (SESSION TIME / #SESSIONS) (PR) (SMF35)           */
 /*  TCB CPU TIME ---------  SIG TCB CPU TIME FOR ALL SESSIONS IN RI:*/
 /*                (TLGCPUTM) (PR) (SMF35)                           */
 /*  SRB CPU TIME ---------  SIG SRB CPU TIME FOR ALL SESSIONS IN RI:*/
 /*                (TLGSRBT)  (PR) (SMF35)                           */
 /*  DISK EXCPS -----------  SIG DISK EXCPS FOR RI (PR) (SMF34 & 40) */
 /*  TERMINAL I/O ---------  SIG TGETS & TPUTS FOR ALL SESS IN RI:   */
 /*                (TLGINCT + TLGOUTCT) (PR) (SMF34)                 */
 /*  SERVICE UNITS --------  SIG JOB SERVICE FOR ALL SESSIONS IN RI: */
 /*                (TLGTJS) (PR) (SMF35)                             */
 /*  SU/TRANSACTION -------  SIG JOB SERVICE / SIG TRANSACTIONS IN RI*/
 /*                (TLGTJS / TLGNTSN) (PR) (SMF35)                   */
 /*  SU/SECOND ------------  SIG JOB SERVICE / RI FOR RI:            */
 /*                (TLGTJS / RI IN SECS) (PR) (SMF35)                */
 /*  PAGES/SECOND ---------  SIG VIO & NON-VIO PAGES IN & OUT FOR ALL*/
 /*                          SESSIONS IN RI / RI:                    */
 /*                ((PGIN+PGOT+SIN+SOUT+VPI+VPO)/RI) (PR) (SMF34)    */
 /*  SWAPOUT TIME/TRANS ---  SUM OF DIFFERENCE BETWEEN TRANSACTION   */
 /*                          ACTIVE TIME AND TRANSACTION RESIDENT    */
 /*                          TIME / SUM OF TRANSACTIONS FOR ALL SESS */
 /*                ((TIVACT - TIVTRANT) / TLGNTSN)  RI (PR) (SMF35)  */
    %PAGE;
 /* BATCH REPORT *****************************************************/

 /*  OUTAGE ---------------  SIG LAST SMF RECORD TO IPL RECORD FOR RI*/
 /*  JOBS COMPLETED -------  SIG SMF TYPE 5 RECORDS FOR RI           */
 /*  STEPS COMPLETED         SIG SMF TYPE 4 RECORDS FOR RI           */
 /*  ELAPSED TIME/JOB -----  SIG ELAPSED EXECUTION TIMES / NUMBER OF */
 /*                          JOBS FOR ALL JOBS IN RI
 /*                (SMF5TME - SMF5JIT) / JOBS COMPLETED (SMF05)      */
 /*  TCB CPU TIME ---------  SIG TCB CPU TIME FOR ALL JOBS IN RI:    */
 /*                (SMF5JCPU) (SMF05)                                */
 /*  SRB CPU TIME ---------  SIG SRB CPU TIME FOR ALL JOBS IN RI:    */
 /*                (SMF5SRBT) (SMF05)                                */
 /*  DISK EXCPS -----------  SIG DISK EXCPS FOR RI (SMF04 & 40)      */
 /*  TAPE EXCPS -----------  SIG TAPE EXCPS FOR RI (SMF04)           */
 /*  SERVICE UNITS --------  SIG JOB SERVICE FOR ALL JOBS IN RI:     */
 /*                (SMF5TJS) (SMF05)                                 */
 /*  SU/STEP --------------  SIG JOB SERVICE / SIG STEPS IN RI:      */
 /*                (SMF5TJS / STEPS COMPLETED) (SMF05)               */
 /*  SU/SECOND ------------  SIG JOB SERVICE / RI FOR RI:            */
 /*                (SMF5TJS / RI IN SECS) (SMF05)                    */
 /*  PAGES/SECOND ---------  SIG VIO & NON-VIO PAGES IN & OUT FOR ALL*/
 /*                          JOBS IN RI / RI:                        */
 /*                ((PGIN+PGOT+PSI+PSO+VPI+VPO)/RI) (SMF04)          */
 /*  SWAP SEQ/MIN ---------  SUM OF ADDRESS SPACE SWAP SEQUENCES FROM*/
 /*                          ALL STEPS COMPLETED IN THE RI / RI(MINS)*/
 /*                (SMF4NSW) (SMF04)                                 */
 /*  QUEUE TIME/JOB -------  SUM OF THE DIFFERENCE BETWEEN XEQ PROC  */
 /*                          START TIME/DATE & READER START TIME/DATE*/
 /*                          FOR ALL JOBS INPUT DURING RI / NUMBER   */
 /*                          OF SUCH JOBS FOR RI:                    */
 /*                ((SMF26XST:XSD - SMF26RST:RSD) / JOBS (SMF26)     */
 /*  TURNAROUND / JOB -----  SUM OF THE DIFFERENCE BETWEEN PURGE     */
 /*                          TIME/DATE & READER TIME/DATE FOR ALL    */
 /*                          JOBS INPUT DURING THE RI / NUMBER OF    */
 /*                          SUCH JOBS FOR RI:                       */
 /*                ((SMF26OPT:OPD - SMF26RST:RSD) / JOBS (SMF26)     */
 /*  TAPE MOUNTS ----------  SUM OF ALL TAPES DISMOUNTED FOR RI:     */
 /*                  NUMBER OF SMF21 RECORDS.                        */
 /*  DISK ALLOCATION RECOV-  SUM OF SUCCESSFUL DISK ALLOCATION       */
 /*                          RECOVERIES DURING RI: (SMF10)           */
  %PAGE;
 /* SYSTEM REPORT ****************************************************/

 /*  IPLS -----------------  SUM OF IPL RECORDS (SMF00)              */
 /*  OUTAGE ---------------  SAME AS THAT OF TSO AND BATCH REPORTS   */
 /*  CPU BUSY (%) ---------  ONE MINUS SIG CPU WAIT TIME /           */
 /*                          SIG TYPE70 RECORDING INTERVALS X 100.   */
 /*                (1.0 - (SMF70WAT / SMF70INT) * 100) (PR) (SMF70)  */
 /*  TOTAL SU/SEC ---------  SUM OF ALL SERVICE UNITS FOR ALL        */
 /*                          PERFORMANCE GROUPS AND PERIODS IN RI/RI */
 /*                (SMF72SER) (PR) (SMF72)                           */
 /*  CPU SU/SEC -----------  SUM OF ALL CPU SERVICE UNITS FOR ALL    */
 /*                          PERFORMANCE GROUPS AND PERIODS IN RI/RI */
 /*                (SMF72SER) (PR) (SMF72)                           */
 /*  I/O SU/SEC -----------  SUM OF ALL I/O SERVICE UNITS FOR ALL    */
 /*                          PERFORMANCE GROUPS AND PERIODS IN RI/RI */
 /*                (SMF72SER) (PR) (SMF72)                           */
 /*  MSO SU/SEC -----------  SUM OF ALL MSO SERVICE UNITS FOR ALL    */
 /*                          PERFORMANCE GROUPS AND PERIODS IN RI/RI */
 /*                (SMF72SER) (PR) (SMF72)                           */
 /*  PAGES/SEC ------------  SIG VIO AND NON-VIO PAGES IN AND OUT    */
 /*                          IN RI / RI                              */
 /*                (PIN+POT+SIN+SOT+VIN+VOT) (PR) (SMF71)            */
 /*  PAGE FLT/SEC ---------  SIG NON-VIO PAGES IN AND RECLAIMS INCL. */
 /*                          COMMON IN RI / RI.                      */
 /*                (SMF71PIN + SMF71PRC + SMF71SNR) (PR) (SMF71)     */
 /*  SWAPS/MIN ------------  SUM OF ADDRESS SPACE SWAP SEQUENCES IN  */
 /*                          RI / RI IN MINUTES.                     */
 /*                (SMF71SSQ) (PR) (SMF71)                           */
 /*  UNIL SWAPS -----------  SUM OF ADDRESS SPACE UNILATERAL         */
 /*                          SWAP-OUTS IN RI                         */
 /*                 (SMF71ULS) (PR) (SMF71)                          */
 /*  EXCH SWAPS -----------  SUM OF ADDRESS SPACE EXCHANGE SWAPS     */
 /*                          IN RI.                                  */
 /*                 (SMF71EXS)                                       */
 /*                                                                  */
 /* PHYSICAL CHANNEL UTILIZATION --------------                      */
 /*          SIG CHANNEL BUSY TIMES / NUMBER OF SAMPLES FOR EACH     */
 /*          NON-BYTE MPX CHANNEL IN THE SYSTEM FOR RI.              */
 /*                 (SMF73BSY / SMF73SAM * 100) (PR) (SMF73)         */
 /*                                                                  */
 /* SERVICE CHARACTERISTICS BY PERFORMANCE GROUP --------------      */
 /*          SERVICE TOTAL AND RATE FOR EACH IPS DEFINED PERFORMANCE */
 /*          GROUP IN THE RI.  (MAX = 16)                            */
 /*                 (SMF72SER) (PR) (SMF72)                          */
 /*                                                                  */
 /* SERVICE CHARACTERISTICS BY DOMAIN -------------------------      */
 /*          SERVICE TOTAL AND RATE FOR EACH >>USED<< DOMAIN IN      */
 /*          THE RI.  (MAX = 16)                                     */
 /*                 (SMF72SER) (PR) (SMF72)                          */
    %PAGE;
 TSO_REPORT:
       IF TSOHOURS = '0000-0000'  THEN
       DO;
         PUT EDIT('********** NO TSO ACTIVITY RECORDED **********')
                 (SKIP(2),A);
         GOTO BATCH_REPORT;
       END;
    /* CALC TOUTAGE(ISYS#,4) VALUES FROM SAVED DATA FROM TYPE 00 RECS */
       DO IPL# = 1 TO IPLS(ISYS#,4) WHILE(IPLS(ISYS#,4) <= 8);
        /* IF SMFTIME <= LAST_TSO THEN TOUTAGE(ISYS#,4) + OUT_TIME    */
         IF TYPE0_DATA(ISYS#,IPL#,1) <= LAST_TSO(ISYS#) THEN
         TOUTAGE(ISYS#,4) = TOUTAGE(ISYS#,4) + TYPE0_DATA(ISYS#,IPL#,2);
       END;
       INTVL(1) = AMP_INT - (TOUTAGE(ISYS#,1) / 100); /*ADJ INTERVALS*/
       INTVL(2) = PMP_INT - (TOUTAGE(ISYS#,2) / 100); /*TO ACCNT FOR */
       INTVL(3) = DAY_INT - (TOUTAGE(ISYS#,3) / 100); /*TOUTAGE TIME */
       INTVL(4) = (LAST_TSO(ISYS#) - FIRST_TSO(ISYS#)
                - TOUTAGE(ISYS#,4)) / 100;    /* ADJ TSO TIME IN SECS */
       DO INTV = 1 TO 4;
         TIM_SESS(INTV),XACT_SESS(INTV),SU_XACT(INTV),SWO_TIME(INTV) =0;
         IF TSESS(ISYS#,INTV) ^= 0  THEN
         DO;
           TIM_SESS(INTV)  = TSESTIM(ISYS#,INTV) / TSESS(ISYS#,INTV);
           XACT_SESS(INTV) = TXACT(ISYS#,INTV)   / TSESS(ISYS#,INTV);
         END;
         IF TXACT(ISYS#,INTV) ^= 0  THEN
         DO;
           SU_XACT(INTV)  = TSU(ISYS#,INTV) / TXACT(ISYS#,INTV);
           SWO_TIME(INTV) =
             (TXACT_ACTTIME(ISYS#,INTV) - TXACT_RESTIME(ISYS#,INTV))
             * 0.001024 / TXACT(ISYS#,INTV);
         END;
         PAGES_SEC(INTV) = TPAGES(ISYS#,INTV) / INTVL(INTV);
         SU_SEC(INTV)    = TSU(ISYS#,INTV)    / INTVL(INTV);
       END;
    %PAGE;
   PUT EDIT('TOTAL',
   '***** TSO PROCESSING *****',
     'AM PEAK','PM PEAK','DAY SHIFT','TSO HOURS',
   '__________________________',
   '(',AMPEAK,')','(',PMPEAK,')','(',DAYSHFT,')','(',TSOHOURS,')',
   'OUTAGE  (HH:MM) ',(HHMM(TOUTAGE(ISYS#,I)) DO I = 1 TO 4),
   'SESSIONS COMPLETED',(TSESS(ISYS#,I) DO I = 1 TO 4),
   'TRANSACTIONS COMPLETED',(TXACT(ISYS#,I) DO I = 1 TO 4),
   'SESSION TIME (HH:MM)',(HHMM(TSESTIM(ISYS#,I)) DO I = 1 TO 4),
   'TIME/SESSION (HH:MM)',(HHMM(TIM_SESS(I)) DO I = 1 TO 4))
    (SKIP(3),COL(69),A,
     SKIP(1),A,COL(29),A,COL(42),A,COL(54),A,COL(67),A,
     SKIP(0),A,
     SKIP(1),COL(27),3 A,COL(40),3 A,COL(53),3 A,COL(66),3 A,
     SKIP(2),A,COL(30),A,   COL(43),A,   COL(56),A,   COL(69),A,
     SKIP(1),A,COL(30),F(6),COL(43),F(6),COL(56),F(6),COL(69),F(6),
     SKIP(1),A,COL(30),F(6),COL(43),F(6),COL(56),F(6),COL(69),F(6),
     SKIP(1),A,COL(30),A,   COL(43),A,   COL(56),A,   COL(69),A,
     SKIP(1),A,COL(30),A,   COL(43),A,   COL(56),A,   COL(69),A);
    %SKIP(1);
   PUT EDIT(
   'TCB CPU  (HH:MM) ',(HHMM(TCPUTCB(ISYS#,I)) DO I = 1 TO 4),
   'SRB CPU  (HH:MM) ',(HHMM(TCPUSRB(ISYS#,I)) DO I = 1 TO 4),
   'DISK EXCPS',(TDISK_EXCPS(ISYS#,I) DO I = 1 TO 4),
   'TERMINAL I/O',(TTERMIO(ISYS#,I) DO I = 1 TO 4),
   'SERVICE UNITS (SU)',(TSU(ISYS#,I) DO I = 1 TO 4),
   'SU/TRANSACTION',(SU_XACT(I) DO I = 1 TO 4),
   'SU/SECOND',(SU_SEC(I) DO I = 1 TO 4),
   'TRANSACTIONS/SESSION',(XACT_SESS(I) DO I = 1 TO 4),
   'PAGES/SECOND',(PAGES_SEC(I) DO I = 1 TO 4),
   'SWAPOUT TIME/TRANS (SECS)',(SWO_TIME(I) DO I = 1 TO 4))
    (SKIP(1),A,COL(30),A,   COL(43),A,   COL(56),A,   COL(69),A,
     SKIP(1),A,COL(30),A,   COL(43),A,   COL(56),A,   COL(69),A,
     SKIP(1),A,COL(28),F(8),COL(41),F(8),COL(54),F(8),COL(67),F(8),
     SKIP(1),A,COL(30),F(6),COL(43),F(6),COL(56),F(6),COL(69),F(6),
     SKIP(1),A,COL(28),F(8),COL(41),F(8),COL(54),F(8),COL(67),F(8),
     SKIP(1),A,COL(30),F(6),COL(43),F(6),COL(56),F(6),COL(69),F(6),
     SKIP(1),A,COL(30),F(6),COL(43),F(6),COL(56),F(6),COL(69),F(6),
     SKIP(1),A,COL(30),F(6),COL(43),F(6),COL(56),F(6),COL(69),F(6),
    SKIP,A,COL(30),F(6,2),COL(43),F(6,2),COL(56),F(6,2),COL(69),F(6,2),
    SKIP,A,COL(30),F(6,2),COL(43),F(6,2),COL(56),F(6,2),COL(69),F(6,2));
  %PAGE;
 BATCH_REPORT:
       INTVL(1)  = DAY_INT  - (BOUTAGE(ISYS#,1) / 100);
       INTVL(2)  = SWNG_INT - (BOUTAGE(ISYS#,2) / 100);
       INTVL(3)  = GRV_INT  - (BOUTAGE(ISYS#,3) / 100);
       INTVL(4)  = (LAST_TIME(ISYS#) - FIRST_TIME(ISYS#)
                  - BOUTAGE(ISYS#,4)) / 100;
       DO INTV = 1 TO 4;
         SU_XACT(INTV), BET_JOB(INTV), QTIME(INTV), JTURNS(INTV) = 0;
         IF BSTEPS(ISYS#,INTV) ^= 0  THEN
          SU_XACT(INTV) = BSUJOB(ISYS#,INTV) / BSTEPS(ISYS#,INTV);
         IF BJOBS(ISYS#,INTV)  ^= 0  THEN
         DO;
           BET_JOB(INTV) = BET(ISYS#,INTV)    / BJOBS(ISYS#,INTV);
           QTIME(INTV)   = BQTIME(ISYS#,INTV) / BJOBS(ISYS#,INTV);
           JTURNS(INTV)  = BTURNA(ISYS#,INTV) / BJOBS(ISYS#,INTV);
         END;
         SWAPSM(INTV)    = BSWAPS(ISYS#,INTV) / (INTVL(INTV) / 60);
         PAGES_SEC(INTV) = BPAGES(ISYS#,INTV) / INTVL(INTV);
         SU_SEC(INTV)    = BSUJOB(ISYS#,INTV) / INTVL(INTV);
       END;
    %PAGE;
   PUT EDIT(
   '**** BATCH PROCESSING ****','DAY','SWING','GRAVE','TOTAL',
   '__________________________',
   '(',DAYSHFT,')','(',SWNGSHFT,')','(',GRVESHFT,')',
   'OUTAGE  (HH:MM) ',(HHMM(BOUTAGE(ISYS#,I)) DO I = 1 TO 4),
   'JOBS COMPLETED',(BJOBS(ISYS#,I) DO I = 1 TO 4),
   'STEPS COMPLETED',(BSTEPS(ISYS#,I) DO I = 1 TO 4),
   'ELAPSED TIME/JOB  (HH:MM)',(HHMM(BET_JOB(I)) DO I = 1 TO 4),
   'TCB CPU  (HH:MM) ',(HHMM(BCPUTCB(ISYS#,I)) DO I = 1 TO 4),
   'SRB CPU  (HH:MM) ',(HHMM(BCPUSRB(ISYS#,I)) DO I = 1 TO 4))
    (SKIP(7),A,COL(33),A,COL(44),A,COL(57),A,COL(70),A,
     SKIP(0),A,
     SKIP(1),COL(27),3 A,COL(40),3 A,COL(53),3 A,
     SKIP(2),A,COL(30),A,   COL(43),A,   COL(56),A,   COL(69),A,
     SKIP(1),A,COL(30),F(6),COL(43),F(6),COL(56),F(6),COL(69),F(6),
     SKIP(1),A,COL(30),F(6),COL(43),F(6),COL(56),F(6),COL(69),F(6),
     SKIP(1),A,COL(30),A,   COL(43),A,   COL(56),A,   COL(69),A,
     SKIP(1),A,COL(30),A,   COL(43),A,   COL(56),A,   COL(69),A,
     SKIP(1),A,COL(30),A,   COL(43),A,   COL(56),A,   COL(69),A);
    %SKIP(1);
   PUT EDIT(
   'DISK EXCPS',(BDISK_EXCPS(ISYS#,I) DO I = 1 TO 4),
   'TAPE EXCPS',(BTAPE_EXCPS(ISYS#,I) DO I = 1 TO 4),
   'SERVICE UNITS (SU)',(BSUJOB(ISYS#,I) DO I = 1 TO 4),
   'SU/STEP',(SU_XACT(I) DO I = 1 TO 4),
   'SU/SECOND',(SU_SEC(I) DO I = 1 TO 4),
   'PAGES/SECOND',(PAGES_SEC(I) DO I = 1 TO 4),
   'SWAP SEQ/MIN',(SWAPSM(I) DO I = 1 TO 4),
   'QUEUE TIME/JOB  (HH:MM)',(HHMM(QTIME(I)) DO I = 1 TO 4),
   'TURNAROUND/JOB  (HH:MM)',(HHMM(JTURNS(I)) DO I = 1 TO 4),
   'TAPE MOUNTS',(BTMOUNT(ISYS#,I) DO I = 1 TO 4),
   'DISK ALLOC RECOVERY',(BBDISKAR(ISYS#,I) DO I = 1 TO 4))
    (SKIP(1),A,COL(28),F(8),COL(41),F(8),COL(54),F(8),COL(67),F(8),
     SKIP(1),A,COL(28),F(8),COL(41),F(8),COL(54),F(8),COL(67),F(8),
     SKIP(1),A,COL(28),F(8),COL(41),F(8),COL(54),F(8),COL(67),F(8),
     SKIP(1),A,COL(30),F(6),COL(43),F(6),COL(56),F(6),COL(69),F(6),
     SKIP(1),A,COL(30),F(6),COL(43),F(6),COL(56),F(6),COL(69),F(6),
    SKIP,A,COL(30),F(6,2),COL(43),F(6,2),COL(56),F(6,2),COL(69),F(6,2),
    SKIP,A,COL(30),F(6,2),COL(43),F(6,2),COL(56),F(6,2),COL(69),F(6,2),
     SKIP(1),A,COL(30),A,   COL(43),A,   COL(56),A,   COL(69),A,
     SKIP(1),A,COL(30),A,   COL(43),A,   COL(56),A,   COL(69),A,
     SKIP(2),A,COL(30),F(6),COL(43),F(6),COL(56),F(6),COL(69),F(6),
     SKIP(1),A,COL(30),F(6),COL(43),F(6),COL(56),F(6),COL(69),F(6));
    %SKIP(4);
     RETURN_ADDR = SYSTEM_REPORT;
     GOTO REPORT_HEAD;   /* GO START A NEW PAGE & PRINT HEADING    */
    %PAGE;
 SYSTEM_REPORT:
     DO INTV = 1 TO 4;
       TSUSEC(INTV), CSUSEC(INTV), ISUSEC(INTV), MSUSEC(INTV),
       CPUBUSY(INTV), PAGES_SEC(INTV), PF_SEC(INTV), SWAPSM(INTV) = 0;
       IF #70INT(ISYS#,INTV) ^= 0 THEN
         CPUBUSY(INTV) = (1.0000 - ((#70WAT(ISYS#,INTV) * 1.048576)
                           / (#70INT(ISYS#,INTV) / 1000))) * 100;
       IF #72INT(ISYS#,INTV) ^= 0 THEN
       DO;
         WORKFP = #72INT(ISYS#,INTV) / 1000;
         TSUSEC(INTV) = #72TOTSU(ISYS#,INTV) / WORKFP;
         CSUSEC(INTV) = #72CPUSU(ISYS#,INTV) / WORKFP;
         ISUSEC(INTV) = #72IOSU(ISYS#,INTV)  / WORKFP;
         MSUSEC(INTV) = #72MSOSU(ISYS#,INTV) / WORKFP;
       END;
       IF #71INT(ISYS#,INTV) ^= 0 THEN
       DO;
         WORKFP = #71INT(ISYS#,INTV) / 1000;
         PAGES_SEC(INTV)  = #71PAGES(ISYS#,INTV) / WORKFP;
         PF_SEC(INTV)     = #71PFR(ISYS#,INTV)   / WORKFP;
         SWAPSM(INTV)     = #71SWAPS(ISYS#,INTV) / (WORKFP / 60);
       END;
     END;
    %PAGE;
   PUT EDIT(
   '***** SYSTEM FACTORS *****',
     'AM PEAK','PM PEAK','DAY SHIFT','TOTAL',
   '__________________________',
   '(',AMPEAK,')','(',PMPEAK,')','(',DAYSHFT,')',
   'IPLS',(IPLS(ISYS#,I) DO I = 1 TO 4),
   'OUTAGE  (HH:MM) ',(HHMM(TOUTAGE(ISYS#,I)) DO I = 1 TO 3),
                       HHMM(BOUTAGE(ISYS#,4)),
   'CPU BUSY  (%)',(CPUBUSY(I) DO I = 1 TO 4),
   'TOTAL SU/SEC',(TSUSEC(I) DO I = 1 TO 4),
   'CPU SU/SEC',(CSUSEC(I) DO I = 1 TO 4),
   'I/O SU/SEC',(ISUSEC(I) DO I = 1 TO 4),
   'MSO SU/SEC',(MSUSEC(I) DO I = 1 TO 4),
   'PAGES/SEC',(PAGES_SEC(I) DO I = 1 TO 4),
   'PAGE FLT/SEC',(PF_SEC(I) DO I = 1 TO 4),
   'SWAPS/MIN',(SWAPSM(I) DO I = 1 TO 4),
   'UNIL SWAPS',(#71ULS(ISYS#,I) DO I = 1 TO 4),
   'EXCH SWAPS',(#71EXS(ISYS#,I) DO I = 1 TO 4))
    (SKIP(3),A,COL(29),A,COL(42),A,COL(54),A,COL(70),A,
     SKIP(0),A,
     SKIP(1),COL(27),3 A,COL(40),3 A,COL(53),3 A,
     SKIP(1),A,COL(30),F(6),COL(43),F(6),COL(56),F(6),COL(69),F(6),
     SKIP(1),A,COL(30),A,   COL(43),A,   COL(56),A,   COL(69),A,
 SKIP(2),A,COL(30),F(6,2),COL(43),F(6,2),COL(56),F(6,2),COL(69),F(6,2),
  9 (SKIP(1),A,COL(30),F(6),COL(43),F(6),COL(56),F(6),COL(69),F(6)));
   %SKIP(2);
   PUT EDIT('PHYSICAL CHANNEL UTILIZATION  (% BUSY)')(SKIP(2),A);
   DO ICH# = 0 TO 15;
     IF CHFLG(ISYS#,ICH#) THEN
     DO;
       WORKFP1, WORKFP2, WORKFP3, WORKFP4 = 0;
       IF #73SAMP(ISYS#,ICH#,1) ^= 0 THEN
         WORKFP1= (#73BUSY(ISYS#,ICH#,1) / #73SAMP(ISYS#,ICH#,1) * 100);
       IF #73SAMP(ISYS#,ICH#,2) ^= 0 THEN
         WORKFP2= (#73BUSY(ISYS#,ICH#,2) / #73SAMP(ISYS#,ICH#,2) * 100);
       IF #73SAMP(ISYS#,ICH#,3) ^= 0 THEN
         WORKFP3= (#73BUSY(ISYS#,ICH#,3) / #73SAMP(ISYS#,ICH#,3) * 100);
       IF #73SAMP(ISYS#,ICH#,4) ^= 0 THEN
         WORKFP4= (#73BUSY(ISYS#,ICH#,4) / #73SAMP(ISYS#,ICH#,4) * 100);
       PUT EDIT('CHANNEL',ICH#,WORKFP1,WORKFP2,WORKFP3,WORKFP4)
        (SKIP(1),COL(2),A,F(4),
         COL(30),F(6,2),COL(43),F(6,2),COL(56),F(6,2),COL(69),F(6,2));
     END;
   END;
    %PAGE;
    PUT EDIT(
    'SERVICE CHARACTERISTICS BY <<PERFORMANCE GROUP>>   (SU & SU/SEC)',
    '________________________________________________________________',
    'PGN#','AM PEAK','PM PEAK','DAY SHIFT','TOTAL',' ')
    (SKIP(3),A,SKIP(0),A,
     SKIP(2),A,COL(25),A,COL(39),A,COL(52),A,COL(68),A,SKIP(1),A);
    DO IPGN = 1 TO 16;
      IF PGNSW(ISYS#,IPGN) THEN
      DO;   /* WE HAVE A USED PERFORMANCE GROUP NUMBER  */
        DO INTV = 1 TO 4;
          SU_SEC(INTV) = 0;
          IF #72INT(ISYS#,INTV) ^= 0 THEN
          SU_SEC(INTV) =
            #72PGNSU(ISYS#,IPGN,INTV) / (#72INT(ISYS#,INTV) / 1000);
        END;
        PUT EDIT(IPGN,'×',
                (#72PGNSU(ISYS#,IPGN,I),SU_SEC(I),'×' DO I = 1 TO 4))
                (SKIP(1),F(3),COL(21),A,4 (F(8),X(2),F(3),A));
      END;
    END;
    %SKIP(2);
    PUT EDIT(
    'SERVICE CHARACTERISTICS BY <<DOMAIN>>   (SU & SU/SEC)',
    '_____________________________________________________',
    'DMN#','AM PEAK','PM PEAK','DAY SHIFT','TOTAL',' ')
    (SKIP(3),A,SKIP(0),A,
     SKIP(2),A,COL(25),A,COL(39),A,COL(52),A,COL(68),A,SKIP(1),A);
    DO IDMN = 1 TO 16;
      IF #72DMNSU(ISYS#,IDMN,4) ^= 0 THEN
      DO;   /* WE HAVE A GOOD AND USED DOMAIN NUMBER */
        DO INTV = 1 TO 4;
          IF #72INT(ISYS#,INTV) ^= 0 THEN
          SU_SEC(INTV) =
            #72DMNSU(ISYS#,IDMN,INTV) / (#72INT(ISYS#,INTV) / 1000);
        END;
        PUT EDIT(IDMN,'×',
                (#72DMNSU(ISYS#,IDMN,I),SU_SEC(I),'×' DO I = 1 TO 4))
                (SKIP(1),F(3),COL(21),A,4 (F(8),X(2),F(3),A));
      END;
    END;
  END;
     %SKIP(2);
   GOTO WRAPUP;
    %PAGE;
  /*  CONVERT A PACKED JULIAN DATE TO AN EDCDIC STRING OF FORM:       */
  /*  WWWWWW---  DD MMM------ YYYY    EX:  FRIDAY  31 DECEMBER 1999   */
  /*  ZELLERS CONGRUENCE FORMULA IS USED TO DETERMINE THE DAY OF THE  */
  /*  WEEK: INDEX-INTO-WEEKDAY-NAME-TABLE (0-6) =                     */
  /*    MOD((MM-2) * 2.6 - 0.2 + DD + YY + (CC/4) - (CC * 2)),7)      */
  /*  NOTE: INTEGER ARITHMETIC IS USED IN ALL CALCULATIONS THUS       */
  /*        DROPPING ANY FRACTIONS/REMAINDERS                         */
    %SKIP(1);
 GREGDTE:  PROC(JULIAN) RETURNS(CHAR(30) VAR);
    DCL JULIAN      DEC FIXED(7,0),
        RSTRING     CHAR(30) VAR    STATIC,
        DAY         DEC FIXED(3,0)  STATIC,
        MONTH       CHAR(9)  VAR    STATIC,
        YEAR        DEC FIXED(4,0)  STATIC,
        (MM, DD, CC, YY) FIXED BIN(15,0) STATIC,
        LMONTH(12)  DEC FIXED(2,0)  STATIC   INIT
          (31,28,31,30,31,30,31,31,30,31,30,31),
        WEEK_DAY(0:6)  CHAR(12)  STATIC  INIT ('   SUNDAY','   MONDAY',
           '  TUESDAY','WEDNESDAY',' THURSDAY','   FRIDAY',' SATURDAY'),
        CMONTH(12)  CHAR(9)  VAR    STATIC   INIT
          ('JANUARY','FEBRUARY','MARCH','APRIL','MAY','JUNE','JULY',
           'AUGUST','SEPTEMBER','OCTOBER','NOVEMBER','DECEMBER');
    RSTRING = '                              ';
    YEAR = JULIAN / 1000;
    YY = YEAR;
    IF (MOD(YEAR,4) = 0 & YEAR ^= 00) THEN LMONTH(2) = 29;/* LEAP YR*/
    DAY = MOD(JULIAN,(YEAR * 1000));
    DO IM = 1 TO 12;  /* FIND CORRECT MONTH OF THE YEAR     */
      DAY = DAY - LMONTH(IM);
      IF DAY <= 0 THEN
      DO;
        DAY = DAY + LMONTH(IM);  /* BACK UP ONE MONTH       */
        MONTH = CMONTH(IM);      /* EBCDIC MONTH            */
        YEAR = YEAR + 1900;      /* 20TH CENTURY            */
        GOTO CALC_WEEK_DAY;
      END;
    END;
    %PAGE;
 CALC_WEEK_DAY:
   /*   ZELLERS CONGRUENCE USED TO DETERMINE DAY OF WEEK            */
    DD = DAY;
    CC = 19;
    MM = IM - 2;
    IF MM <= 0 THEN
    DO;
      MM = MM + 12;          /* MONTHS + 12   */
      YY = YY - 1;           /* YEAR - 1      */
      IF YY < 0 THEN
      DO;
        YY = 99;
        CC = CC - 1;         /* CENTURY - 1   */
      END;
    END;
    WORKBIN1 = (((MM * 26) - 2) / 10);
    WORKBIN2 = (YY / 4);
    WORKBIN3 = (CC / 4);
    WORKBIN4 = (CC * 2);
    IX = MOD((WORKBIN1 + DD + YY + WORKBIN2 + WORKBIN3 - WORKBIN4),7);
    PUT STRING(RSTRING) EDIT(WEEK_DAY(IX),DAY,MONTH,YEAR)
                            (A,P'Z9',X(1),A,X(1),P'9999');
    RETURN(RSTRING);
    END GREGDTE;
    %SKIP(4);
  /*  CONVERT A FLOAT DEC(16) FIELD CONTAINING 1/100 SECONDS TO       */
  /*  A 6 BYTE CHARACTER STRING OF FORM:  ' HH:MM'                    */
    %SKIP(1);
 HHMM:    PROC(SECS100) RETURNS(CHAR(6));
    DCL  SECS100    DEC FLOAT(16),
         RSTRING    CHAR(6)          STATIC,
         HOURS      BIN FIXED(15,0)  STATIC,
         MINS       BIN FIXED(15,0)  STATIC;
    HOURS = SECS100 / 360000;
    MINS  = MOD(SECS100,360000) / 6000;
    PUT STRING(RSTRING) EDIT(HOURS,':',MINS)(P'Z99',A,P'99');
    RETURN(RSTRING);
    END HHMM;
      %PAGE;
  /* BUCKETS FOR DATA FROM VARIOUS SMF RECORDS.  FORM= ARRAY(A,B)    */
  /* WHERE A = SYSTEM ID (1-4) AND                                   */
  /*       B = BATCH BUCKETS FOR  DAY(1), SWING(2), GRAVE(3) TOTAL(4)*/
  /*         = TSO BUCKETS FOR AMPEAK(1); PMPEAK(2); DAY(3); TOTAL(4)*/
      %SKIP(1);
   DCL  1  COUNTERS  STATIC  ALIGNED,

    /*    MISCELLANEOUS TIMES AND PERIOD VALUES     */
           3 FIRST_TIME(4)        BIN FIXED(31)  INIT((4)(0)),
           3 LAST_TIME(4)         BIN FIXED(31)  INIT((4)(0)),
           3 FIRST_TSO(4)         BIN FIXED(31)  INIT((4)(0)),
           3 LAST_TSO(4)          BIN FIXED(31)  INIT((4)(0)),
           3 PROCESS_DATE(4)      DEC FIXED(7)   INIT((4)(0)),
           3 SYS#(4)              CHAR(4)  INIT((4)('    ')),
           3 AMPEAK               CHAR(9)  INIT('0900-1100'),
           3 PMPEAK               CHAR(9)  INIT('1400-1600'),
           3 DAYSHFT              CHAR(9)  INIT('0800-1600'),
           3 SWNGSHFT             CHAR(9)  INIT('1600-2400'),
           3 GRVESHFT             CHAR(9)  INIT('0000-0800'),
           3 TSOHOURS             CHAR(9)  INIT('0000-0000'),

   /*    TYPE  0 BUCKETS    */
           3 IPLS(4,4)            BIN FIXED(15)  INIT((16)(0)),
           3 TOUTAGE(4,4)         DEC FLOAT(16)  INIT((16)(0)),
           3 BOUTAGE(4,4)         DEC FLOAT(16)  INIT((16)(0)),
           3 TYPE0_DATA(4,8,2)    DEC FLOAT(16)  INIT((64)(0)),
             /*  8 = IPL#    2 = SMFTIME & OUT_TIME SAVE AREAS    */

   /*  TYPE  4 & 40 BUCKETS */
           3 BSTEPS(4,4)          BIN FIXED(31)  INIT((16)(0)),
           3 BDISK_EXCPS(4,4)     DEC FLOAT(16)  INIT((16)(0)),
           3 BTAPE_EXCPS(4,4)     DEC FLOAT(16)  INIT((16)(0)),
           3 BPAGES(4,4)          DEC FLOAT(16)  INIT((16)(0)),
           3 BSWAPS(4,4)          DEC FLOAT(16)  INIT((16)(0)),

   /*    TYPE  5 BUCKETS    */
           3 BJOBS(4,4)           BIN FIXED(31)  INIT((16)(0)),
           3 BCPUTCB(4,4)         DEC FLOAT(16)  INIT((16)(0)),
           3 BCPUSRB(4,4)         DEC FLOAT(16)  INIT((16)(0)),
           3 BSUJOB(4,4)          DEC FLOAT(16)  INIT((16)(0)),
           3 BET(4,4)             DEC FLOAT(16)  INIT((16)(0)),

   /*    TYPE 10 BUCKETS    */
           3 BBDISKAR(4,4)        BIN FIXED(31)  INIT((16)(0)),

   /*    TYPE 21 BUCKETS    */
           3 BTMOUNT(4,4)         BIN FIXED(31)  INIT((16)(0)),

   /*    TYPE 26 BUCKETS    */
           3 B#26(4,4)            DEC FLOAT(16)  INIT((16)(0)),
           3 BQTIME(4,4)          DEC FLOAT(16)  INIT((16)(0)),
           3 BTURNA(4,4)          DEC FLOAT(16)  INIT((16)(0)),



   /*  TYPE 34 & 40 BUCKETS */
           3 TXACT_RESTIME(4,4)   DEC FLOAT(16)  INIT((16)(0)),
           3 TXACT_ACTTIME(4,4)   DEC FLOAT(16)  INIT((16)(0)),
           3 TDISK_EXCPS(4,4)     DEC FLOAT(16)  INIT((16)(0)),
           3 TPAGES(4,4)          DEC FLOAT(16)  INIT((16)(0)),

   /*    TYPE 35 BUCKETS    */
           3 TSESS(4,4)           BIN FIXED(31)  INIT((16)(0)),
           3 TXACT(4,4)           BIN FIXED(31)  INIT((16)(0)),
           3 TSESTIM(4,4)         DEC FLOAT(16)  INIT((16)(0)),
           3 TCPUTCB(4,4)         DEC FLOAT(16)  INIT((16)(0)),
           3 TCPUSRB(4,4)         DEC FLOAT(16)  INIT((16)(0)),
           3 TTERMIO(4,4)         DEC FLOAT(16)  INIT((16)(0)),
           3 TSU(4,4)             DEC FLOAT(16)  INIT((16)(0)),

   /*    TYPE 70 BUCKETS    */
           3 #70INT(4,4)          DEC FLOAT(16)  INIT((16)(0)),
           3 #70WAT(4,4)          DEC FLOAT(16)  INIT((16)(0)),

   /*    TYPE 71 BUCKETS    */
           3 #71SWAPS(4,4)        DEC FLOAT(06)  INIT((16)(0)),
           3 #71ULS(4,4)          DEC FLOAT(06)  INIT((16)(0)),
           3 #71EXS(4,4)          DEC FLOAT(06)  INIT((16)(0)),
           3 #71INT(4,4)          DEC FLOAT(16)  INIT((16)(0)),
           3 #71SAM(4,4)          DEC FLOAT(16)  INIT((16)(0)),
           3 #71PAGES(4,4)        DEC FLOAT(16)  INIT((16)(0)),
           3 #71PFR(4,4)          DEC FLOAT(16)  INIT((16)(0)),

   /*    TYPE 72 BUCKETS    */
           3 PGNSW(4,16)          BIT(1) ALIGNED  INIT((64)('0'B)),
           3 #72INT(4,4)          DEC FLOAT(16)  INIT((16)(0)),
           3 #72TOTSU(4,4)        DEC FLOAT(16)  INIT((16)(0)),
           3 #72CPUSU(4,4)        DEC FLOAT(16)  INIT((16)(0)),
           3 #72IOSU(4,4)         DEC FLOAT(16)  INIT((16)(0)),
           3 #72MSOSU(4,4)        DEC FLOAT(16)  INIT((16)(0)),
           3 #72DMNSU(4,16,4)     DEC FLOAT(16)  INIT((256)(0)),
           3 #72PGNSU(4,16,4)     DEC FLOAT(16)  INIT((256)(0)),

   /*    TYPE 73 BUCKETS    */
           3 CHFLG(4,0:15)        BIT(1) ALIGNED  INIT((64)('0'B)),
           3 #73SAMP(4,0:15,4)    DEC FLOAT(16)  INIT((256)(0)),
           3 #73BUSY(4,0:15,4)    DEC FLOAT(16)  INIT((256)(0));
      %PAGE;
 E15X:  PROC RETURNS(CHAR(5000) VAR);
   ON ENDFILE (SMFIN)
      BEGIN;
         CLOSE FILE(SMFIN);
         PUT EDIT('DAYSHFT= ',DAYSHFT,'SWNGSHFT= ',SWNGSHFT,
                  'GRVESHFT= ',GRVESHFT,
                  'AMPEAK= ',AMPEAK,'PMPEAK= ',PMPEAK,
 '**********************************************************************
 ******************************')
                 (PAGE,5 (A,A,X(5)),SKIP(1),A);
  /* SET PROCESSING DATE FOR EACH FOUND SYSTEM ID                     */
         DO ISYS# = 1 TO 4 WHILE(SYS#(ISYS#) ^= '    ');
           IF NDATE1(ISYS#) >= NDATE2(ISYS#)      THEN
              PROCESS_DATE(ISYS#) = DATE1(ISYS#); ELSE
              PROCESS_DATE(ISYS#) = DATE2(ISYS#);
           PUT EDIT('REPORT DATE FOR SYSTEM:  ',SYS#(ISYS#),
                     GREGDTE(PROCESS_DATE(ISYS#)))
                   (SKIP(1),2 A,COL(50),A);
         END;
         PUT EDIT(MSG02,REC#) (SKIP(2),A,F(8));
         CALL PLIRETC(8);    /* SIGNAL END OF SORT INPUT */
         GOTO ENDE15;
      END;
    %SKIP(1);
 READ_SMF:
    READ FILE (SMFIN) INTO(SMFREC);
    ITYPE = REC_TYPE;
    IF SMF_TYPE(ITYPE) THEN   /*  IS SMF_TYPE SELECTED?   */
       DO;
         DO ISYS# = 1 TO 4; /*DETERMINE WHICH SYSTEM SMF RECORD IS FOR*/
           IF SYSID = SYS#(ISYS#) THEN GOTO DATE_CHECK;
         END;
         DO ISYS# = 1 TO 4;  /* ESTABLISH A NEW SLOT FOR VALID SYSID */
           IF SYS#(ISYS#) = '    ' THEN
           DO;
             SYS#(ISYS#) = SYSID;
             GOTO DATE_CHECK;
           END;
         END;
         DISPLAY ('XB01D030-3 TOO MANY SYSTEM IDS FOUND. MAXIMUM = 4');
         DISPLAY ('XB01D030-3 INPUT PROCESSING TERMINATED');
         SIGNAL ENDFILE(SMFIN);
       END;
    GOTO READ_SMF;
    %PAGE;
 DATE_CHECK:
 /*     CODE TO DETERMINE HIGHEST COUNT DATE FOR PROCESSING         */
    IF ITYPE >= 70 THEN GOTO RTN15;        /* NOT IF TYPE 7X        */
    IF SMFDATE = DATE1(ISYS#)             THEN
      NDATE1(ISYS#) = NDATE1(ISYS#) +1;   ELSE
    IF NDATE1(ISYS#) >= NDATE2(ISYS#)     THEN
      DO;  /* WE HAVE A NEW HIGHEST COUNT DATE */
         NDATE2(ISYS#) = NDATE1(ISYS#);
         NDATE1(ISYS#) = 1;
         DATE2(ISYS#)  = DATE1(ISYS#);
         DATE1(ISYS#)  = SMFDATE;
      END;                                ELSE
      DO;  /*  LAST DATE COUNT ^> HIGHEST DATE COUNT  */
         DATE1(ISYS#) = SMFDATE;
         NDATE1(ISYS#) = 1;
      END;
    %SKIP(1);
     IF ITYPE = 14 × ITYPE = 15 THEN
     DO; /*  CONSOLIDATE TYPES 14 &15 RECORDS:  FIRST 48 BYTES   */
     /*  ×× FIRST 52 BYTES OF JFCB SECTION ×× 24 BYTE    */
     /*     UCB SECTION(S).              */
    %SKIP(1);
     /*   THE FIRST SUBSTR EXPRESSION SPECIFIES A LENGTH TO SET  */
     /* THE VARYING STRING TO THE PROPER FINAL LENGTH FOR    */
     /* ULTIMATE ASSIGNMENT TO SMFREC. THE ACTUAL LENGTH DESIRED */
     /* IS THE FIRST 48 BYTES OF THE SMF 14/15 RECORD. THE REST  */
     /* WILL BE OVERLAID BY THE SUBSEQUENT SUBSTR EXPRESSIONS.   */

       DCL  SMFEFNUC    BIT(8) ALIGNED DEF(SMFREC) POS(44);
       LUCBS = SMFEFNUC * 24;  /* TOTAL LENGTH OF UCB SECTION(S) */
       SMF1415_REC = SUBSTR(SMFREC,1,100+LUCBS);
       SUBSTR(SMF1415_REC,49,52) = SUBSTR(SMFREC,65,52);
       SUBSTR(SMF1415_REC,101,LUCBS) = SUBSTR(SMFREC,265,LUCBS);
       SMFREC = SMF1415_REC;
     END;
 RTN15:
     REC# = REC# +1;
     CALL PLIRETC(12);   /* INPUT TO SORT CONTINUES  */
 ENDE15:
      RETURN(SMFREC);     /* GO BACK TO SORT W/ CC12 OR CC8  */
      END E15X;
      %PAGE;
 E35X:    PROC(SMFREC);
   DCL  SMFREC    CHAR(*)  CONN,
        1 COMMON BASED(P1),
           3 RESERVED      BIT(8)  ALIGNED,
           3 REC_TYPE      BIT(8)  ALIGNED,
           3 SMFTIME       BIN FIXED(31,0),
           3 SMFDATE       DEC FIXED(7),
           3 SYSID         CHAR(4),
           3 JOBNAME       CHAR(8),
           3 JOBTIME       BIN FIXED(31,0),
           3 JOBDATE       DEC FIXED(7),
           3 DATA          CHAR(5000);
    %SKIP(1);
  /*  ESTABLISH ERROR RECOVERY PROCEDURES...ALLOW TWENTY ERRORS TO  */
  /*  BE BYPASSED IN E35X EXIT (NORMAL RETURN TO SORT). AT TWENTY   */
  /*  ERRORS, DISABLE DAILY REPORT FUNCTION AND JUST CONTINUE WITH  */
  /*  THE BILLING SYSTEM DATA PASSING FUNCTION.                     */
    %SKIP(1);
     ON ERROR GOTO ERROR_E35X;
     ON TRANSMIT(SMFOUT) SYSTEM;
     GOTO E35XGO;
    %SKIP(1);
 ERROR_E35X:
     ERRCNT = ERRCNT + 1;
     IF ERRCNT = 20 THEN PUT EDIT(MSG03) (SKIP(2),A);
     IF ERRCNT > 20 THEN
     DO;      /*    TOO MANY UNRECOVERABLE ERRORS....CHUCK IT       */
       DISPLAY(MSG04D);
       PUT EDIT(MSG04) (SKIP(2),A);
       RTNCODE = 16;            /*  TERMINATE SORT PROCESSING       */
     END;
     GOTO E35_RETURN;
   %PAGE;
 E35XGO:
   RTNCODE = 4;              /* NORMAL RETURN FROM E35 EXIT     */
   P1 = ADDR(SMFREC);        /* POINT TO SMF RECORD             */
   ITYPE = REC_TYPE;
   DO ISYS# = 1 TO 4;  /* DETERMINE WHICH SYSTEM SMF RECORD IS FOR   */
     IF SYSID = SYS#(ISYS#) THEN GOTO TYPE_CHECK;
   END;
 TYPE_CHECK:
   IF (ITYPE < 70 × ITYPE = 130) THEN
   DO;                 /* WRITE BILLING FILE  */
     WRITE FILE(SMFOUT) FROM(SMFREC);
     BILLCNT = BILLCNT +1;
   END;
   SYSTOTAL(ISYS#) = SYSTOTAL(ISYS#) + 1;
   SMF_COUNT(ISYS#,ITYPE) = SMF_COUNT(ISYS#,ITYPE) + 1;
   IF ERRCNT >= 20 THEN GOTO E35_RETURN;
   IF ITYPE =14 × ITYPE =15 × SMFDATE ^= PROCESS_DATE(ISYS#) THEN
     GOTO E35_RETURN;
   IF ^ FIRSTSW(ISYS#)  THEN       /* FIRST RECORD FOR THIS SYSTEM?  */
   DO;                             /* YES, SAVE TIME                 */
     FIRSTSW(ISYS#) = '1'B;
     FIRST_TIME(ISYS#) = SMFTIME;
   END;
   IF ITYPE = 00 THEN GOTO TYPE00_PROCESS;      /*    IPL RECORD     */
   LAST_DATE(ISYS#) = SMFDATE;
   LAST_TIME(ISYS#) = SMFTIME;
   IF ITYPE >= 70  THEN GOTO SELECT_PROCESS;
 /*    DETERMINE WHAT WORK SHIFT PERIOD SMF RECORD REPRESENTS        */
   IF ITYPE = 26 THEN SMFTIME = JOBTIME; /* FORCE DETERMINATION OF   */
      /* ISHIFT TO TIME JOB WAS READ...SEE EXPLANATION OF QUEUE TIME */
      /* AND TURNAROUND TIME FOR BATCH REPORTS.                      */
   STIME=(SMFTIME/360000*100)+MOD(ROUND(SMFTIME/6000,0),60);
   IF STIME >= DAYSHFT_START  &
      STIME <  DAYSHFT_STOP   THEN ISHIFT = 1;  /* DAY SHIFT   */ ELSE
   IF STIME >= SWNGSHFT_START &
      STIME <  SWNGSHFT_STOP  THEN ISHIFT = 2;  /* SWING SHIFT */ ELSE
                                   ISHIFT = 3;  /* GRAVE SHIFT */
    %SKIP(1);
 SELECT_PROCESS:
   IF ITYPE = 40 THEN GOTO TYPE40_PROCESS;      /*   DYNAM UNALLOC   */
   IF ITYPE = 72 THEN GOTO TYPE72_PROCESS;      /*   WORKLOAD        */
   IF ITYPE = 70 THEN GOTO TYPE70_PROCESS;      /*   CPU             */
   IF ITYPE = 71 THEN GOTO TYPE71_PROCESS;      /*   PAGING          */
   IF ITYPE = 73 THEN GOTO TYPE73_PROCESS;      /*   CHANNEL         */
   IF ITYPE = 04 THEN GOTO TYPE04_PROCESS;      /*   STEP TERMINATE  */
   IF ITYPE = 26 THEN GOTO TYPE26_PROCESS;      /*   JES2 JOB PURGE  */
   IF ITYPE = 21 THEN GOTO TYPE21_PROCESS;      /*   ERR STATS VOL   */
   IF ITYPE = 05 THEN GOTO TYPE05_PROCESS;      /*   JOB TERMINATE   */
   IF ITYPE = 34 THEN GOTO TYPE34_PROCESS;      /*   TSO STEP TERM.  */
   IF ITYPE = 35 THEN GOTO TYPE35_PROCESS;      /*   TSO SESS TERM.  */
   IF ITYPE = 10 THEN GOTO TYPE10_PROCESS;      /*   ALLOC RECOVERY  */
   GOTO E35_RETURN;  /* RETURN TO SORT */
    %PAGE;
 PRORATE_PEAK:
   PRVPK = 1.00;
   IF (BGNTIME >= AMP1 & SMFTIME <= AMP2)                    THEN
       IPEAK = 1;                                            ELSE
   IF (BGNTIME >= PMP1 & SMFTIME <= PMP2)                    THEN
       IPEAK = 2;                                            ELSE
   IF (BGNTIME >= AMP2  & SMFTIME <= PMP1) /* BETWN PEAKS */ THEN
       IPEAK = 0;                                            ELSE
   IF (BGNTIME <  AMP1 & SMFTIME >  AMP1 & SMFTIME <= AMP2)  THEN
      DO;
        IPEAK = 1;
        WORKFP1,        WORKFP3 = SMFTIME;
        WORKFP2 = AMP1; WORKFP4 = BGNTIME;
        GOTO CALC_PRVPK;
      END;                                                   ELSE
   IF (BGNTIME <  PMP1 & SMFTIME >  PMP1 & SMFTIME <= PMP2)  THEN
      DO;
        IPEAK = 2;
        WORKFP1,        WORKFP3 = SMFTIME;
        WORKFP2 = PMP1; WORKFP4 = BGNTIME;
        GOTO CALC_PRVPK;
      END;                                                   ELSE
   IF (BGNTIME >= AMP1 & BGNTIME <  AMP2 & SMFTIME >  AMP2)  THEN
      DO;
        IPEAK = 1;
        WORKFP1 = AMP2;    WORKFP3 = SMFTIME;
        WORKFP2,           WORKFP4 = BGNTIME;
        GOTO CALC_PRVPK;
      END;                                                   ELSE
   IF (BGNTIME >= PMP1 & BGNTIME <  PMP2 & SMFTIME >  PMP2)  THEN
      DO;
        IPEAK = 2;
        WORKFP1 = PMP2;    WORKFP3 = SMFTIME;
        WORKFP2,           WORKFP4 = BGNTIME;
        GOTO CALC_PRVPK;
      END;                                                   ELSE
   IF (BGNTIME <  AMP1 & SMFTIME >  AMP2)                    THEN
      DO;
        IPEAK = 1;
        WORKFP1 = AMP2;    WORKFP2 = AMP1;
        WORKFP3 = SMFTIME; WORKFP4 = BGNTIME;
        GOTO CALC_PRVPK;
      END;                                                   ELSE
   IF (BGNTIME <  PMP1 & SMFTIME >  PMP2)                    THEN
      DO;
        IPEAK = 2;
        WORKFP1 = PMP2;    WORKFP2 = PMP1;
        WORKFP3 = SMFTIME; WORKFP4 = BGNTIME;
        GOTO CALC_PRVPK;
      END;                                                   ELSE
      IPEAK = 0;  /*  PEAK PERIOD(S) NOT AFFECTED      */
   GOTO RETURN_ADDR;
    %PAGE;
 PRORATE_DAYSHFT:
   IF (BGNTIME >= DSH1 & SMFTIME <= DSH2) THEN PRVDS = 1.00; ELSE
   IF (BGNTIME <  DSH1 & SMFTIME >  DSH1 & SMFTIME <= DSH2)  THEN
       DO;
         WORKFP1 = SMFTIME; WORKFP2 = DSH1;
         WORKFP3 = SMFTIME; WORKFP4 = BGNTIME;
         GOTO CALC_PRVDS;
       END;                                                  ELSE
   IF (BGNTIME >= DSH1 & BGNTIME <  DSH2 & SMFTIME >  DSH2)  THEN
       DO;
         WORKFP1 = DSH2;    WORKFP3 = SMFTIME;
         WORKFP2,           WORKFP4 = BGNTIME;
         GOTO CALC_PRVDS;
       END;                                                  ELSE
   IF (BGNTIME <  DSH1 & SMFTIME >  DSH2)                    THEN
       DO;
         WORKFP1 = DSH2;    WORKFP2 = DSH1;
         WORKFP3 = SMFTIME; WORKFP4 = BGNTIME;
         GOTO CALC_PRVDS;
       END;                                                  ELSE
   PRVDS = 0.00;
   GOTO RETURN_ADDR;
    %SKIP(5);
 CALC_PRVPK:
   PRVPK = ((WORKFP1 - WORKFP2) / (WORKFP3 - WORKFP4));
   GOTO RETURN_ADDR;
    %SKIP(4);
 CALC_PRVDS:
   PRVDS = ((WORKFP1 - WORKFP2) / (WORKFP3 - WORKFP4));
   GOTO RETURN_ADDR;
      %PAGE;
 TYPE00_PROCESS:  /*  SMF TYPE  0  */
     OUT_TIME = SMFTIME - LAST_TIME(ISYS#);
     BGNTIME  = LAST_TIME(ISYS#);
     RETURN_ADDR = RTN00A;
     GOTO PRORATE_PEAK;  /*  GET PEAK PERIOD PRORATE VALUE           */
 RTN00A:
     RETURN_ADDR =RTN00B;
     GOTO PRORATE_DAYSHFT;  /*    GET DAYSHIFT PRORATE VALUE         */
 RTN00B:
     IF IPEAK ^= 0 THEN
     DO;
       IPLS(ISYS#,IPEAK) = IPLS(ISYS#,IPEAK) + 1;
       TOUTAGE(ISYS#,IPEAK) = TOUTAGE(ISYS#,IPEAK) + (OUT_TIME * PRVPK);
     END;
     IF (SMFTIME >= DSH1 & SMFTIME <= DSH2) THEN  /* DAY SHIFT IPL   */
       IPLS(ISYS#,3) = IPLS(ISYS#,3) + 1;
     IPLS(ISYS#,4) = IPLS(ISYS#,4) + 1;
     TOUTAGE(ISYS#,3) = TOUTAGE(ISYS#,3) + (OUT_TIME * PRVDS);
     IF (SMFTIME >= FIRST_TSO(ISYS#) & IPLS(ISYS#,4) ^> 8)   THEN
     DO;  /* SAVE SMFTIME & OUT_TIME FOR USE AFTER ALL RECORDS ARE IN*/
       TYPE0_DATA(ISYS#,IPLS(ISYS#,4),1) = SMFTIME;
       TYPE0_DATA(ISYS#,IPLS(ISYS#,4),2) = OUT_TIME;
     END;
     BOUTAGE(ISYS#,4) = BOUTAGE(ISYS#,4) + OUT_TIME;
     IF PRVDS = 1.0                          /* DAY SHIFT ONLY*/  THEN
        BOUTAGE(ISYS#,1) = BOUTAGE(ISYS#,1) + OUT_TIME;           ELSE
     IF BGNTIME >= SWSH1 & SMFTIME <= SWSH2  /* SW SHIFT ONLY */  THEN
        BOUTAGE(ISYS#,2) = BOUTAGE(ISYS#,2) + OUT_TIME;           ELSE
     IF BGNTIME <  DSH2  & SMFTIME >  SWSH1  /* DAY-SWING SH  */  THEN
     DO;
       BOUTAGE(ISYS#,1) = BOUTAGE(ISYS#,1) + (OUT_TIME * PRVDS);
       BOUTAGE(ISYS#,2) = BOUTAGE(ISYS#,2) + (OUT_TIME * (1.0 - PRVDS));
     END;                                                         ELSE
     IF PRVDS ^= 0.0                         /*  DAY  - GRAVE */  THEN
     DO;
       BOUTAGE(ISYS#,1) = BOUTAGE(ISYS#,1) + (OUT_TIME * PRVDS);
       BOUTAGE(ISYS#,3) = BOUTAGE(ISYS#,3) + (OUT_TIME * (1.0 - PRVDS));
     END;                                                         ELSE
     IF (BGNTIME >  SWSH1 & BGNTIME <  SWSH2 * SMFTIME > SWSH2)   THEN
     DO;  /* SWING - GRAVE..USE PRVDS FOR EXPEDIENT PURPOSE OF CALC  */
       WORKFP1 = SWSH2;
       WORKFP2 = BGNTIME;
       WORKFP3 = SMFTIME;
       WORKFP4 = BGNTIME;
       RETURN_ADDR = RTN00C;
       GOTO CALC_PRVDS;
 RTN00C:
       BOUTAGE(ISYS#,2) = BOUTAGE(ISYS#,2) + (OUT_TIME * PRVDS);
       BOUTAGE(ISYS#,3) = BOUTAGE(ISYS#,3) + (OUT_TIME * (1.0 - PRVDS));
     END;                                                         ELSE
     BOUTAGE(ISYS#,3) = BOUTAGE(ISYS#,3) + OUT_TIME; /* GRAVE ONLY */
    %PAGE;
 /*  FOR MONITORING IPL ACTIVITY   */
      PUT EDIT(
   '***** FOLLOWING DATA AFTER IPL RECORD ***************************',
   'SYSID:  ',SYS#(ISYS#),'IPEAK:',IPEAK,'PRVPK:',PRVPK,'PRVDS:',PRVDS,
   'SMFTIME (HH:MM):',  HHMM(SMFTIME),
   'LAST_TIME (HH:MM):',HHMM(LAST_TIME(ISYS#)),
   'OUT_TIME (HH:MM):', HHMM(OUT_TIME),
   '*****************************************************************')
      (SKIP(2),A,
       SKIP(1),2 A,3 (X(8),A,F(8,6)),
       SKIP(1),3 (2 A,X(6)),
       SKIP(1),A);
    %SKIP(1);
     GOTO E35_RETURN;
    %PAGE;
 TYPE04_PROCESS:  /*  SMF TYPE  4  */
     BSTEPS(ISYS#,ISHIFT) = BSTEPS(ISYS#,ISHIFT) + 1;
     BSTEPS(ISYS#,4)      = BSTEPS(ISYS#,4)      + 1;
     PDEV = ADDR(SMF4DEV);  /* ADDRESS DEVICE SECT OF TYPE 4 RECORDS */
     I#DEVS = (SMF4LENN-2) / 8;
     RETURN_ADDR = RTN4A;
     GOTO GETJOB_EXCPS;
 RTN4A:
     PRELOL = P1OL + SMF4RLCT; /*POINT TO RELOC SECT VIA PTR OVERLAYS*/
     BSWAPS(ISYS#,ISHIFT) = BSWAPS(ISYS#,ISHIFT) + RELOC.NSW;
     BSWAPS(ISYS#,4) = BSWAPS(ISYS#,4) + RELOC.NSW;
     WORKFP = PGIN + PGOT + PSI + PSO + VPI + VPO;  /*  IN RELOC  */
     BPAGES(ISYS#,ISHIFT) = BPAGES(ISYS#,ISHIFT) + WORKFP;
     BPAGES(ISYS#,4) = BPAGES(ISYS#,4) + WORKFP;
     %SKIP(1);
     GOTO E35_RETURN;
     %SKIP(1);
 /*********************************************************************/
     %SKIP(2);
 TYPE05_PROCESS:  /*  SMF TYPE  5  */
     BJOBS(ISYS#,ISHIFT)   = BJOBS(ISYS#,ISHIFT)   + 1;
     BJOBS(ISYS#,4)        = BJOBS(ISYS#,4)        + 1;
     WORKFP                = SMF5JCPU;
     BCPUTCB(ISYS#,ISHIFT) = BCPUTCB(ISYS#,ISHIFT) + WORKFP;
     BCPUTCB(ISYS#,4)      = BCPUTCB(ISYS#,4)      + WORKFP;
     WORKFP                = SMF5SRBT;
     BCPUSRB(ISYS#,ISHIFT) = BCPUSRB(ISYS#,ISHIFT) + WORKFP;
     BCPUSRB(ISYS#,4)      = BCPUSRB(ISYS#,4)      + WORKFP;
     WORKFP                = SMF5TJS;
     BSUJOB(ISYS#,ISHIFT)  = BSUJOB(ISYS#,ISHIFT)  + WORKFP;
     BSUJOB(ISYS#,4)       = BSUJOB(ISYS#,4)       + WORKFP;
     WORKFP                = (SMF5TME - SMF5JIT);
     IF WORKFP < 0 THEN    /* CHECK IF JOB STARTED THE DAY BEFORE IT */
     DO;                   /* ENDED. IF SO, ADJUST. IF NOT = ERROR   */
       IF SMF5DTE > SMF5JID
          THEN  WORKFP = WORKFP + 8640000; /* ADD ONE DAY TO ADJUST  */
          ELSE  GOTO E35_RETURN;           /* = ERROR...IGNORE       */
     END;
     BET(ISYS#,ISHIFT)     = BET(ISYS#,ISHIFT)     + WORKFP;
     BET(ISYS#,4)          = BET(ISYS#,4)          + WORKFP;
    %SKIP(1);
     GOTO E35_RETURN;
    %PAGE;
 TYPE10_PROCESS:  /*  SMF TYPE 10  */
     I#DEVS = (SMF10LN - 2) / 4;
     BBDISKAR(ISYS#,ISHIFT) = BBDISKAR(ISYS#,ISHIFT) + I#DEVS;
     BBDISKAR(ISYS#,4)      = BBDISKAR(ISYS#,4)      + I#DEVS;
    %SKIP(1);
     GOTO E35_RETURN;
     %SKIP(1);
 /*********************************************************************/
     %SKIP(2);
 TYPE21_PROCESS:  /*  SMF TYPE 21  */
     BTMOUNT(ISYS#,ISHIFT) = BTMOUNT(ISYS#,ISHIFT) + 1;
     BTMOUNT(ISYS#,4)      = BTMOUNT(ISYS#,4)      + 1;
    %SKIP(1);
     GOTO E35_RETURN;
     %SKIP(1);
 /*********************************************************************/
     %SKIP(2);
 TYPE26_PROCESS:  /*  SMF TYPE 26  */
     IF (SMF26_TFLG = 'TS' × SMF26XST = 0) THEN GOTO E35_RETURN;
         /*   NOT A BATCH JOB OR JOB PURGED BEFORE XEQ PROCESSOR    */
     DO IXPROC = 1 TO 4;  /* SET SYSID TO XEQ PROCESSOR FOR TALLYS  */
       IF SMF26XID = SYS#(IXPROC) THEN GOTO TYPE26_GO;
     END;
     IXPROC = ISYS#;   /* IF FALL THRU--SET TO PURGE SYSID  */
 TYPE26_GO:
     B#26(IXPROC,ISHIFT) = B#26(IXPROC,ISHIFT) + 1;
     WORKFP = SMF26XST - SMF26RST;
     IF WORKFP < 0 THEN
     DO;
       IF SMF26RSD > SMF26XSD
          THEN WORKFP = WORKFP + 8640000; /* ADD ONE DAY TO ADJUST  */
          ELSE GOTO TURNA_PROC;           /* = ERROR...IGNORE       */
     END;
     BQTIME(IXPROC,ISHIFT) = BQTIME(IXPROC,ISHIFT) + WORKFP;
     BQTIME(IXPROC,4)      = BQTIME(IXPROC,4)      + WORKFP;
 TURNA_PROC:
     IF SMF26OPT = 0 THEN GOTO E35_RETURN; /* JOB PURGED B4 OUT PROC*/
     WORKFP = SMF26OPT - SMF26RST;
     IF WORKFP < 0 THEN
     DO;
       IF SMF26OPD > SMF26RSD
          THEN WORKFP = WORKFP + 8640000; /* ADD ONE DAY TO ADJUST  */
          ELSE GOTO E35_RETURN;           /* = ERROR....IGNORE      */
     END;
     BTURNA(IXPROC,ISHIFT) = BTURNA(IXPROC,ISHIFT) + WORKFP;
     BTURNA(IXPROC,4)      = BTURNA(IXPROC,4)      + WORKFP;
    %SKIP(1);
     GOTO E35_RETURN;
      %PAGE;
 TYPE34_PROCESS:  /*  SMF TYPE 34  */
     IF ^ FIRSTTSO(ISYS#) THEN   /*  FIRST TSO SESSION FOR SYSID?   */
     DO;                         /*  YES, SAVE TIME                 */
       FIRSTTSO(ISYS#) = '1'B;
       IF JOBDATE = SMFDATE THEN FIRST_TSO(ISYS#) = JOBTIME;
                            ELSE FIRST_TSO(ISYS#) = 0000; /* MIDNIGHT*/
     END;
     LAST_TSO(ISYS#) = SMFTIME;
     BGNTIME = JOBTIME;
     RETURN_ADDR = RTN34A;
     GOTO PRORATE_PEAK;
 RTN34A:
     RETURN_ADDR = RTN34B;
     GOTO PRORATE_DAYSHFT;
 RTN34B:
     PDEV = ADDR(TIVDEV);  /* ADDRESS DEVICE SECT OF TYPE 34 RECORDS */
     I#DEVS = (TIVVAR-2) / 8;
     RETURN_ADDR = RTN34C;
     GOTO GETTSO_EXCPS;
 RTN34C:
     PRELOL = P1OL + TIVRLCT;  /*POINT TO RELOC SECT VIA PTR OVERLAYS*/
     WORKFP =  PGIN + PGOT + PSI + PSO + VPI + VPO;
     IF IPEAK ^= 0 THEN
     DO;
       TXACT_RESTIME(ISYS#,IPEAK) = TXACT_RESTIME(ISYS#,IPEAK)
                                  + (TRAN * PRVPK);
       TXACT_ACTTIME(ISYS#,IPEAK) = TXACT_ACTTIME(ISYS#,IPEAK)
                                  + (ACT * PRVPK);
       TPAGES(ISYS#,IPEAK) = TPAGES(ISYS#,IPEAK) + (WORKFP * PRVPK);
     END;
     IF ISHIFT = 1 THEN
     DO;
       TXACT_RESTIME(ISYS#,3) = TXACT_RESTIME(ISYS#,3) + (TRAN * PRVDS);
       TXACT_ACTTIME(ISYS#,3) = TXACT_ACTTIME(ISYS#,3) + (ACT * PRVDS);
       TPAGES(ISYS#,3) = TPAGES(ISYS#,3) + (WORKFP * PRVDS);
     END;
     TXACT_RESTIME(ISYS#,4) = TXACT_RESTIME(ISYS#,4) + TRAN;
     TXACT_ACTTIME(ISYS#,4) = TXACT_ACTTIME(ISYS#,4) + ACT;
     TPAGES(ISYS#,4) = TPAGES(ISYS#,4) + WORKFP;
     %SKIP(1);
     GOTO E35_RETURN;
     %PAGE;
 TYPE35_PROCESS:  /*  SMF TYPE 35  */
     BGNTIME = JOBTIME;
     RETURN_ADDR = RTN35A;
     GOTO PRORATE_PEAK;
 RTN35A:
     RETURN_ADDR = RTN35B;
     GOTO PRORATE_DAYSHFT;
 RTN35B:
     IF IPEAK ^= 0 THEN
       DO;
         TSESS(ISYS#,IPEAK)   = TSESS(ISYS#,IPEAK) + 1;
         TXACT(ISYS#,IPEAK)   = TXACT(ISYS#,IPEAK)
                              + (TLGNTSN * PRVPK);
         TSESTIM(ISYS#,IPEAK) = TSESTIM(ISYS#,IPEAK)
                              + ((TLGRCDTS - TLGONTME) * PRVPK);
         TCPUTCB(ISYS#,IPEAK) = TCPUTCB(ISYS#,IPEAK)
                              + (TLGCPUTM * PRVPK);
         TCPUSRB(ISYS#,IPEAK) = TCPUSRB(ISYS#,IPEAK)
                              + (TLGSRBT  * PRVPK);
         TTERMIO(ISYS#,IPEAK) = TTERMIO(ISYS#,IPEAK)
                              + ((TLGINCT + TLGOUTCT) * PRVPK);
         TSU(ISYS#,IPEAK)     = TSU(ISYS#,IPEAK)
                              + (TLGTJS * PRVPK);
       END;
     IF ISHIFT = 1 THEN
       DO;    /*  DAY SHIFT  */
         TSESS(ISYS#,3)   = TSESS(ISYS#,3)   + 1;
         TXACT(ISYS#,3)   = TXACT(ISYS#,3)   + (TLGNTSN * PRVDS);
         TSESTIM(ISYS#,3) = TSESTIM(ISYS#,3)
                          + ((TLGRCDTS - TLGONTME) * PRVDS);
         TCPUTCB(ISYS#,3) = TCPUTCB(ISYS#,3) + (TLGCPUTM * PRVDS);
         TCPUSRB(ISYS#,3) = TCPUSRB(ISYS#,3) + (TLGSRBT * PRVDS);
         TTERMIO(ISYS#,3) = TTERMIO(ISYS#,3)
                          + ((TLGINCT + TLGOUTCT) * PRVDS);
         TSU(ISYS#,3)     = TSU(ISYS#,3)     + (TLGTJS * PRVDS);
       END;
     TSESS(ISYS#,4)   = TSESS(ISYS#,4)   + 1;
     TXACT(ISYS#,4)   = TXACT(ISYS#,4)   + TLGNTSN;
     TSESTIM(ISYS#,4) = TSESTIM(ISYS#,4) + (TLGRCDTS - TLGONTME);
     TCPUTCB(ISYS#,4) = TCPUTCB(ISYS#,4) + TLGCPUTM;
     TCPUSRB(ISYS#,4) = TCPUSRB(ISYS#,4) + TLGSRBT;
     TTERMIO(ISYS#,4) = TTERMIO(ISYS#,4) + (TLGINCT + TLGOUTCT);
     TSU(ISYS#,4)     = TSU(ISYS#,4)     + TLGTJS;
    %SKIP(1);
     GOTO E35_RETURN;
    %PAGE;
 TYPE40_PROCESS:  /*  SMF TYPE 40  */
     PDEV = ADDR(TDDDEV);  /* ADDRESS DEVICE SECT OF TYPE 40 RECORDS */
     I#DEVS = (TDDVAR-2) / 8;
     IF TDDUTSFL = 'TS' THEN
       DO;                       /*  TSO SESSION                     */
         BGNTIME = JOBTIME;
         RETURN_ADDR = RTN40A;
         GOTO PRORATE_PEAK;
 RTN40A: RETURN_ADDR = RTN40B;
         GOTO PRORATE_DAYSHFT;
 RTN40B: RETURN_ADDR = E35_RETURN;
         GOTO GETTSO_EXCPS;
       END;             ELSE
       DO;                       /*  BATCH JOB                       */
         RETURN_ADDR = E35_RETURN;
         GOTO GETJOB_EXCPS;
       END;
    %SKIP(2);
 GETTSO_EXCPS:
     DO IDEV = 1 TO I#DEVS; /*   GET EXCP COUNTS FOR DISK            */
       DEV_CL = DEVICES.DEVC(IDEV);
       IF DEV_CL = DISK_DEV THEN
       DO;
         IF IPEAK ^= 0 THEN TDISK_EXCPS(ISYS#,IPEAK) =
           TDISK_EXCPS(ISYS#,IPEAK) + (DEVICES.EXCP(IDEV) * PRVPK);
         IF ISHIFT = 1 THEN TDISK_EXCPS(ISYS#,3) =
           TDISK_EXCPS(ISYS#,3) + (DEVICES.EXCP(IDEV) * PRVDS);
         TDISK_EXCPS(ISYS#,4) = TDISK_EXCPS(ISYS#,4)
                              + DEVICES.EXCP(IDEV);
       END;
     END;
     GOTO RETURN_ADDR;
    %SKIP(1);
 GETJOB_EXCPS:
     DO IDEV = 1 TO I#DEVS; /*   GET EXCP COUNTS FOR DISK & TAPE     */
       DEV_CL = DEVICES.DEVC(IDEV);
       IF DEV_CL = DISK_DEV THEN
       DO;
         BDISK_EXCPS(ISYS#,ISHIFT) = BDISK_EXCPS(ISYS#,ISHIFT) +
          DEVICES.EXCP(IDEV);
         BDISK_EXCPS(ISYS#,4) = BDISK_EXCPS(ISYS#,4) +
          DEVICES.EXCP(IDEV);
       END;                 ELSE
       IF DEV_CL = TAPE_DEV THEN
       DO;
         BTAPE_EXCPS(ISYS#,ISHIFT) = BTAPE_EXCPS(ISYS#,ISHIFT) +
          DEVICES.EXCP(IDEV);
         BTAPE_EXCPS(ISYS#,4) = BTAPE_EXCPS(ISYS#,4) +
          DEVICES.EXCP(IDEV);
       END;
     END;
     GOTO RETURN_ADDR;
     %PAGE;
 TYPE70_PROCESS:  /*  SMF TYPE 70  */
     WORKBIN1 = SMF70IST;
     WORKBIN2 = SMF70INT / 10;
     RETURN_ADDR = RTN70A;
     GOTO CALC_TIMES;
 RTN70A:
     RETURN_ADDR = RTN70B;
     GOTO PRORATE_PEAK;
 RTN70B:
     RETURN_ADDR = RTN70C;
     GOTO PRORATE_DAYSHFT;
 RTN70C:
     WORKBIN2 = SMF70INT;                     /*  CONVERT TO BINARY  */
     WORKBIN1= ((WORKBIN2 / 100000) * 60000)      /* MM IN MSECS     */
             + (MOD(WORKBIN2,100000));            /* + SSTTT IN MS   */
     WORKFP  = WORKBIN1;                      /* CONVERT TO FLOAT PT.*/
 /* IF AP OR MP THEN DOUBLE INT TO AVERAGE CPU BUSY/WAIT TIMES       */
     IF SMF70CPU = 2 THEN WORKFP = WORKFP * 2;
     IF IPEAK ^= 0 THEN #70INT(ISYS#,IPEAK) = #70INT(ISYS#,IPEAK)
                                            + (WORKFP * PRVPK);
     IF PRVDS ^= 0 THEN #70INT(ISYS#,3)     = #70INT(ISYS#,3)
                                            + (WORKFP * PRVDS);
     #70INT(ISYS#,4) = #70INT(ISYS#,4) + WORKFP; /*  IN MILLISECONDS */
     DO ICPU = 1 TO  SMF70CPU;
       WATBITS = SMF70WT2(ICPU);
       IF WATBIT32 THEN SMF70WT1 = SMF70WT1 + 1; /* ROUND UP IF SET  */
       IF IPEAK ^= 0 THEN #70WAT(ISYS#,IPEAK) = #70WAT(ISYS#,IPEAK)
                                           + (SMF70WT1(ICPU) * PRVPK);
       IF PRVDS ^= 0 THEN #70WAT(ISYS#,3)     = #70WAT(ISYS#,3)
                                           + (SMF70WT1(ICPU) * PRVDS);
       #70WAT(ISYS#,4) = #70WAT(ISYS#,4) + SMF70WT1(ICPU);
 /*  #70WAT UNITS ARE 1.048576 SECONDS & WILL BE ADJUSTED LATER   */
     END;
    %SKIP(1);
     GOTO E35_RETURN;
    %SKIP(3);
 CALC_TIMES: /* WORKBIN1 = IST (0HHMMSS), WORKBIN2 = INT (MMSSTT.0)*/
     BGNTIME = ((WORKBIN1 / 10000) * 3600);  /*   = 0HH  SECONDS   */
     WORKBIN3 = MOD(WORKBIN1,10000);         /*     MMSS           */
     BGNTIME = BGNTIME + (WORKBIN3 / 100 * 60); /* +MM IN SECONDS  */
     BGNTIME = BGNTIME + MOD(WORKBIN3,100);  /*    +SS    SECONDS  */
     BGNTIME = BGNTIME * 100;                /*   0HHMMSSTT.0      */
    %SKIP(1);
  /*  SMFTIME RESET TO REFLECT TRUE MEASUREMENT INTERVAL FOR       */
  /*  CALCULATING PEAK PRORATE VALUES. (ELIMINATES DELAY FROM END  */
  /*  OF INTERVAL TO SMF BUFFER LOAD TIME)                         */
     WORKBIN1= ((WORKBIN2 / 10000) * 6000);  /*   = MM  1/100 SECS */
     SMFTIME = BGNTIME + WORKBIN1
                       + MOD(WORKBIN2,10000); /*  0HHMMSSTT  1/100 */
     GOTO RETURN_ADDR;
    %PAGE;
 TYPE71_PROCESS:  /*  SMF TYPE 71  */
     WORKBIN1 = SMF71IST;
     WORKBIN2 = SMF71INT / 10;
     RETURN_ADDR = RTN71A;
     GOTO CALC_TIMES;
 RTN71A:
     RETURN_ADDR = RTN71B;
     GOTO PRORATE_PEAK;
 RTN71B:
     RETURN_ADDR = RTN71C;
     GOTO PRORATE_DAYSHFT;
 RTN71C:
     WORKBIN2 = SMF71INT;                     /*  CONVERT TO BINARY  */
     WORKBIN1= ((WORKBIN2 / 100000) * 60000)      /* MM IN MSECS     */
             + (MOD(WORKBIN2,100000));            /* + SSTTT IN MS   */
     WORKFP  = WORKBIN1;                      /* CONVERT TO FLOAT PT.*/
     WORKFP1 = SMF71PIN+SMF71POT+SMF71SIN+SMF71SOT+SMF71VIN+SMF71VOT;
     WORKFP2 = SMF71PIN + SMF71PRC + SMF71SNR;
     IF IPEAK ^= 0 THEN
     DO;
       #71INT(ISYS#,IPEAK)   = #71INT(ISYS#,IPEAK)  +(WORKFP   * PRVPK);
       #71SAM(ISYS#,IPEAK)   = #71SAM(ISYS#,IPEAK)  +(SMF71SAM * PRVPK);
       #71PAGES(ISYS#,IPEAK) = #71PAGES(ISYS#,IPEAK)+(WORKFP1  * PRVPK);
       #71PFR(ISYS#,IPEAK)   = #71PFR(ISYS#,IPEAK)  +(WORKFP2  * PRVPK);
       #71SWAPS(ISYS#,IPEAK) = #71SWAPS(ISYS#,IPEAK)+(SMF71SSQ * PRVPK);
       #71ULS(ISYS#,IPEAK)   = #71ULS(ISYS#,IPEAK)  +(SMF71ULS * PRVPK);
       #71EXS(ISYS#,IPEAK)   = #71EXS(ISYS#,IPEAK)  +(SMF71EXS * PRVPK);
     END;
     IF PRVDS ^= 0 THEN
     DO;
       #71INT(ISYS#,3)   = #71INT(ISYS#,3)   + (WORKFP   * PRVDS);
       #71SAM(ISYS#,3)   = #71SAM(ISYS#,3)   + (SMF71SAM * PRVDS);
       #71PAGES(ISYS#,3) = #71PAGES(ISYS#,3) + (WORKFP1  * PRVDS);
       #71PFR(ISYS#,3)   = #71PFR(ISYS#,3)   + (WORKFP2  * PRVDS);
       #71SWAPS(ISYS#,3) = #71SWAPS(ISYS#,3) + (SMF71SSQ * PRVDS);
       #71ULS(ISYS#,3)   = #71ULS(ISYS#,3)   + (SMF71ULS * PRVDS);
       #71EXS(ISYS#,3)   = #71EXS(ISYS#,3)   + (SMF71EXS * PRVDS);
     END;
     #71INT(ISYS#,4)   = #71INT(ISYS#,4)   + WORKFP;
     #71SAM(ISYS#,4)   = #71SAM(ISYS#,4)   + SMF71SAM;
     #71PAGES(ISYS#,4) = #71PAGES(ISYS#,4) + WORKFP1;
     #71PFR(ISYS#,4)   = #71PFR(ISYS#,4)   + WORKFP2;
     #71SWAPS(ISYS#,4) = #71SWAPS(ISYS#,4) + SMF71SSQ;
     #71ULS(ISYS#,4)   = #71ULS(ISYS#,4)   + SMF71ULS;
     #71EXS(ISYS#,4)   = #71EXS(ISYS#,4)   + SMF71EXS;
    %SKIP(1);
     GOTO E35_RETURN;
    %PAGE;
 TYPE72_PROCESS:  /*  SMF TYPE 72  */
     WORKBIN1 = SMF72IST;
     IF WORKBIN1 = #72IST1 THEN FIRST#72 = '0'B;    ELSE
     DO;  /* FLAG AS FIRST #72 REC FOR INTERVAL  */
       FIRST#72 = '1'B;
       #72IST1 = WORKBIN1;
     END;
     WORKBIN2 = SMF72INT / 10;
     RETURN_ADDR = RTN72A;
     GOTO CALC_TIMES;
 RTN72A:
     RETURN_ADDR = RTN72B;
     GOTO PRORATE_PEAK;
 RTN72B:
     RETURN_ADDR = RTN72C;
     GOTO PRORATE_DAYSHFT;
 RTN72C:
     WORKBIN2 = SMF72INT;                     /*  CONVERT TO BINARY  */
     WORKBIN1= ((WORKBIN2 / 100000) * 60000)      /* MM IN MSECS     */
             + (MOD(WORKBIN2,100000));            /* + SSTTT IN MS   */
     WORKFP  = WORKBIN1; /* CONVERT SMF72INT TO FLOAT PT.:  MMSSTTT  */
     IF SMF72SUB > 16          THEN
     DO;
       PUT EDIT('***** TOO HIGH A PERFORMANCE GROUP NUMBER FOUND.',
                '      MAXIMUM = 16.  PROCESSING TERMINATED.')
               (SKIP(2),A,A);
       RTNCODE = 16;
       GOTO E35_RETURN;
     END;
     PGNSW(ISYS#,SMF72SUB) = '1'B;        /* WE HAVE A VALID PGNO  */
     DO IDMN = 1 TO 16;                   /* CLEAR DMN COUNTERS    */
       IDMNSU(IDMN) = 0;
     END;
     WORKFP1, WORKFP2, WORKFP3, WORKFP4 = 0;   /*CLEAR SU COUNTERS */
     DO IPERIOD = 1 TO SMF72PGP;
       IF SMF72CDN(IPERIOD) > 16 THEN
       DO;
         PUT EDIT('***** TOO HIGH A DOMAIN NUMBER FOUND.',
                  '      MAXIMUM = 16.  PROCESSING TERMINATED.')
                 (SKIP(2),A,A);
         RTNCODE = 16;
         GOTO E35_RETURN;
       END;
       IDMNSU(SMF72CDN(IPERIOD)) = IDMNSU(SMF72CDN(IPERIOD))
                                 + SMF72SER(IPERIOD);
       WORKFP1 = WORKFP1 + SMF72CTS(IPERIOD);  /*    CPU  SU       */
       WORKFP2 = WORKFP2 + SMF72ITS(IPERIOD);  /*    I/O  SU       */
       WORKFP3 = WORKFP3 + SMF72MTS(IPERIOD);  /*    MSO  SU       */
       WORKFP4 = WORKFP4 + SMF72SER(IPERIOD);  /*    TOTAL SU      */
     END;
    %PAGE;
     IF IPEAK ^= 0 THEN
     DO;
       IF FIRST#72 THEN    /* ADD INT VALUE ONLY ONCE PER INTERVAL   */
       #72INT(ISYS#,IPEAK)   = #72INT(ISYS#,IPEAK)  +(WORKFP   * PRVPK);
       #72TOTSU(ISYS#,IPEAK) = #72TOTSU(ISYS#,IPEAK)+(WORKFP4  * PRVPK);
       #72CPUSU(ISYS#,IPEAK) = #72CPUSU(ISYS#,IPEAK)+(WORKFP1  * PRVPK);
       #72IOSU(ISYS#,IPEAK)  = #72IOSU(ISYS#,IPEAK) +(WORKFP2  * PRVPK);
       #72MSOSU(ISYS#,IPEAK) = #72MSOSU(ISYS#,IPEAK)+(WORKFP3  * PRVPK);
       #72PGNSU(ISYS#,SMF72SUB,IPEAK) = #72PGNSU(ISYS#,SMF72SUB,IPEAK)
                                      + (WORKFP4 * PRVPK);
     END;
     IF PRVDS ^= 0 THEN
     DO;
       IF FIRST#72 THEN    /* ADD INT VALUE ONLY ONCE PER INTERVAL   */
       #72INT(ISYS#,3)   = #72INT(ISYS#,3)   + (WORKFP  * PRVDS);
       #72TOTSU(ISYS#,3) = #72TOTSU(ISYS#,3) + (WORKFP4 * PRVDS);
       #72CPUSU(ISYS#,3) = #72CPUSU(ISYS#,3) + (WORKFP1 * PRVDS);
       #72IOSU(ISYS#,3)  = #72IOSU(ISYS#,3)  + (WORKFP2 * PRVDS);
       #72MSOSU(ISYS#,3) = #72MSOSU(ISYS#,3) + (WORKFP3 * PRVDS);
       #72PGNSU(ISYS#,SMF72SUB,3) = #72PGNSU(ISYS#,SMF72SUB,3)
                                  + (WORKFP4 * PRVDS);
     END;
     IF FIRST#72 THEN      /* ADD INT VALUE ONLY ONCE PER INTERVAL   */
     #72INT(ISYS#,4)   = #72INT(ISYS#,4)   + WORKFP;
     #72TOTSU(ISYS#,4) = #72TOTSU(ISYS#,4) + WORKFP4;
     #72CPUSU(ISYS#,4) = #72CPUSU(ISYS#,4) + WORKFP1;
     #72IOSU(ISYS#,4)  = #72IOSU(ISYS#,4)  + WORKFP2;
     #72MSOSU(ISYS#,4) = #72MSOSU(ISYS#,4) + WORKFP3;
     #72PGNSU(ISYS#,SMF72SUB,4) = #72PGNSU(ISYS#,SMF72SUB,4) + WORKFP4;
     DO IDMN = 1 TO 16;  /*   ADD SU COUNT TO APPROPRIATE DMN NOS.   */
       IF IDMNSU(IDMN) ^= 0  THEN
         DO;
           IF IPEAK ^= 0     THEN
             #72DMNSU(ISYS#,IDMN,IPEAK) = #72DMNSU(ISYS#,IDMN,IPEAK)
                                        + (IDMNSU(IDMN) * PRVPK);
           #72DMNSU(ISYS#,IDMN,3) = #72DMNSU(ISYS#,IDMN,3)
                                  + (IDMNSU(IDMN) * PRVDS);
           #72DMNSU(ISYS#,IDMN,4) = #72DMNSU(ISYS#,IDMN,4)
                                  + IDMNSU(IDMN);
         END;
     END;
      %SKIP(1);
   GOTO E35_RETURN;
    %PAGE;
 TYPE73_PROCESS:  /*  SMF TYPE 73  */
     WORKBIN1 = SMF73IST;
     WORKBIN2 = SMF73INT / 10;
     RETURN_ADDR = RTN73A;
     GOTO CALC_TIMES;
 RTN73A:
     RETURN_ADDR = RTN73B;
     GOTO PRORATE_PEAK;
 RTN73B:
     RETURN_ADDR = RTN73C;
     GOTO PRORATE_DAYSHFT;
 RTN73C:
     WORKFP1 = SMF73SAM * PRVPK;
     WORKFP2 = SMF73SAM * PRVDS;
     DO IPHCH = 1 TO SMF73CHA;
       IF (^ BYMPX(IPHCH) & ^ INVCHID(IPHCH) & ^ INVDATA(IPHCH)) THEN
       DO;
         ICH# = SMF73HID(IPHCH);
         CHFLG(ISYS#,ICH#) = '1'B;
         IF IPEAK ^= 0 THEN
         DO;
           #73SAMP(ISYS#,ICH#,IPEAK) = #73SAMP(ISYS#,ICH#,IPEAK)
                                     + WORKFP1;
           #73BUSY(ISYS#,ICH#,IPEAK) = #73BUSY(ISYS#,ICH#,IPEAK)
                                     + (SMF73BSY(IPHCH) * PRVPK);
         END;
         #73SAMP(ISYS#,ICH#,3) = #73SAMP(ISYS#,ICH#,3) + WORKFP2;
         #73BUSY(ISYS#,ICH#,3) = #73BUSY(ISYS#,ICH#,3)
                               + (SMF73BSY(IPHCH) * PRVDS);
         #73SAMP(ISYS#,ICH#,4) = #73SAMP(ISYS#,ICH#,4) + SMF73SAM;
         #73BUSY(ISYS#,ICH#,4) = #73BUSY(ISYS#,ICH#,4)+SMF73BSY(IPHCH);
       END;
     END;
      %SKIP(1);
   GOTO E35_RETURN;
      %SKIP(4);
 E35_RETURN:    /* RETURN POINT FROM SMF PROCESSING ROUTINES  */
   CALL PLIRETC(RTNCODE);    /*  REQUEST NEXT RECORD FROM SORT  */
                             /** OR TERMINATE SORT FOR TESTING **/
   END E35X;
      %SKIP(3);
 WRAPUP:
   OPEN FILE(HISTORY) OUTPUT;
   WRITE FILE(HISTORY) FROM(COUNTERS);
   CLOSE FILE(SMFOUT), FILE(HISTORY);
   GOTO FINISH;
     %PAGE;
 DCL   1 TYPE4     UNAL  BASED(P1),
         3 SMF4FLG      BIT(8)  ALIGNED,
         3 SMF4RTY      BIT(8)  ALIGNED,
         3 SMF4TME      BIN FIXED(31,0),
         3 SMF4DTE      DEC FIXED(7,0),
         3 SMF4SID      CHAR(4),
         3 SMF4JBN      CHAR(8),
         3 SMF4RST      BIN FIXED(31,0),
         3 SMF4RSD      DEC FIXED(7,0),
         3 SMF4UIF      CHAR(8),
         3 SMF4STN      BIT(8)  ALIGNED,
         3 SMF4SIT      BIN FIXED(31,0),
         3 SMF4STID     DEC FIXED(7,0),
         3 SMF4NCI      BIN FIXED(31,0),
         3 SMF4SCC      BIT(16) ALIGNED,
         3 SMF4PRTY     BIT(8)  ALIGNED,
         3 SMF4PGMN     CHAR(8),
         3 SMF4STMN     CHAR(8),
         3 SMF4RSHO     BIN FIXED(15,0),
         3 SMF4SYST     BIN FIXED(15,0),
         3 SMF4HOST     BIN FIXED(15,0),
         3 SMF4RV1      BIT(48) ALIGNED,
         3 SMF4SPK      BIT(8)  ALIGNED,
         3 SMF4STI      BIT(8)  ALIGNED,
         3 SMF4RV2      BIT(16) ALIGNED,
         3 SMF4AST      BIN FIXED(31,0),
         3 SMF4PPST     BIN FIXED(31,0),
         3 SMF4RV3      BIT(8)  ALIGNED,
         3 SMF4SRBT     BIT(24) ALIGNED,
         3 SMF4RIN      BIT(16) ALIGNED,
         3 SMF4RLCT     BIN FIXED(15,0),
         3 SMF4LENN     BIN FIXED(15,0),
         3 SMF4DEV      CHAR(LDEV04 REFER(SMF4LENN)),
         3 SMF4LNTH     BIT(8)  ALIGNED,
         3 SMF4ACCT     CHAR(LACT04 REFER(SMF4LNTH));
      %PAGE;
 /*   THE FOLLOWING AGGREGATE DEFINES THE DEVICE ENTRY SECTION(S) OF */
 /*   SMF RECORD TYPES 4, 34, & 40.                                  */

 DCL   1 DEVICES(1635)  BASED(PDEV),
         3 DEVC     BIT(8)  ALIGNED,
         3 UTYP     BIT(8)  ALIGNED,
         3 UAD      BIT(8)  ALIGNED,
         3 UAD1     BIT(8)  ALIGNED,
         3 EXCP     BIN FIXED(31,0);
         %SKIP(2);
 /*   THE FOLLOWING AGGREGATE DEFINES THE RELOCATE SECTION OF SMF    */
 /*   RECORD TYPES 4 & 34.                                           */
    %SKIP(1);
 DCL   1 RELOC  UNAL  BASED(PREL),
         3 PGIN     BIN FIXED(31,0),
         3 PGOT     BIN FIXED(31,0),
         3 NSW      BIN FIXED(31,0),
         3 PSI      BIN FIXED(31,0),
         3 PSO      BIN FIXED(31,0),
         3 VPI      BIN FIXED(31,0),
         3 VPO      BIN FIXED(31,0),
         3 SST      BIN FIXED(31,0),
         3 ACT      BIN FIXED(31,0),
         3 PGNO     BIN FIXED(15,0),
         3 TRAN     BIN FIXED(31,0),
         3 RECL     BIN FIXED(31,0),
         3 RCLM     BIN FIXED(31,0),
         3 CPGN     BIN FIXED(31,0),
         3 CRCL     BIN FIXED(31,0),
         3 PGST     BIN FIXED(31,0),
         3 PSEC     BIT(64);
      %PAGE;
 DCL   1 TYPE5     UNAL  BASED(P1),
         3 SMF5FLG      BIT(8)  ALIGNED,
         3 SMF5RTY      BIT(8)  ALIGNED,
         3 SMF5TME      BIN FIXED(31,0),
         3 SMF5DTE      DEC FIXED(7,0),
         3 SMF5SID      CHAR(4),
         3 SMF5JBN      CHAR(8),
         3 SMF5RST      BIN FIXED(31,0),
         3 SMF5RSD      DEC FIXED(7,0),
         3 SMF5UIF      CHAR(8),
         3 SMF5NST      BIT(8)  ALIGNED,
         3 SMF5JIT      BIN FIXED(31,0),
         3 SMF5JID      BIN FIXED(31,0),
         3 SMF5NCI      BIN FIXED(31,0),
         3 SMF5JCC      BIT(16) ALIGNED,
         3 SMF5JPTY     BIT(8)  ALIGNED,
         3 SMF5RSTT     BIN FIXED(31,0),
         3 SMF5RSTD     DEC FIXED(7,0),
         3 SMF5JBT1     BIT(8)  ALIGNED,
         3 SMF5SMC1     BIT(8)  ALIGNED,
         3 SMF5TRAN     BIN FIXED(31,0),
         3 SMF5CKRE     BIT(8)  ALIGNED,
         3 SMF5RDCL     BIT(8)  ALIGNED,
         3 SMF5RUTY     BIT(8)  ALIGNED,
         3 SMF5JICL     BIT(8)  ALIGNED,
         3 SMF5SPK      BIT(8)  ALIGNED,
         3 SMF5SRBT     BIT(24) ALIGNED,
         3 SMF5TJS      BIN FIXED(31,0),
         3 SMF5TTAT     BIN FIXED(31,0),
         3 SMF5RV2      BIT(32) ALIGNED,
         3 SMF5PGNO     BIN FIXED(15,0),
         3 SMF5RV3      BIT(16) ALIGNED,
         3 SMF5TLEN     BIT(8)  ALIGNED,
         3 SMF5PRGN     CHAR(20),
         3 SMF5JCPU     BIT(24) ALIGNED,
         3 SMF5ACTF     BIT(8)  ALIGNED,
         3 SMF5JSAF     CHAR(80);
      %PAGE;
 DCL   1 TYPE10    UNAL  BASED(P1),
         3 SMF10FLG     BIT(8)  ALIGNED,
         3 SMF10RTY     BIT(8)  ALIGNED,
         3 SMF10TME     BIN FIXED(31,0),
         3 SMF10DTE     DEC FIXED(7,0),
         3 SMF10SID     CHAR(4),
         3 SMF10JBN     CHAR(8),
         3 SMF10RST     BIN FIXED(31,0),
         3 SMF10RSD     DEC FIXED(7,0),
         3 SMF10UIF     CHAR(8),
         3 SMF10LN      BIT(16)  ALIGNED,
         3 SMF10DEV(1)  CHAR(4);
      %PAGE;
 DCL   1 TYPE26    UNAL  BASED(P1),
         3 SMF26FLG     BIT(8)  ALIGNED,
         3 SMF26RTY     BIT(8)  ALIGNED,
         3 SMF26TME     BIN FIXED(31,0),
         3 SMF26DTE     DEC FIXED(7,0),
         3 SMF26SID     CHAR(4),
         3 SMF26JBN     CHAR(8),
         3 SMF26RST     BIN FIXED(31,0),
         3 SMF26RSD     DEC FIXED(7,0),
         3 SMF26UIF,
           5 SMF26UI6   CHAR(6),
           5 SMF26_TFLG CHAR(2),
         3 SMF26RSV     BIT(32) ALIGNED,
         3 SMF26SBS     BIT(16) ALIGNED,
         3 SMF26IND     BIT(16) ALIGNED,
         3 SMF26LN1     BIN FIXED(15,0),
         3 SMF26RV1     BIT(16) ALIGNED,
         3 SMF26IN2     BIT(8)  ALIGNED,
         3 SMF26INF     BIT(8)  ALIGNED,
         3 SMF26JNM     CHAR(4),
         3 SMF26JID     CHAR(8),
         3 SMF26NAM     CHAR(20),
         3 SMF26MSG     CHAR(1),
         3 SMF26CLS     CHAR(1),
         3 SMF26XPI     BIT(8)  ALIGNED,
         3 SMF26XPS     BIT(8)  ALIGNED,
         3 SMF26OPI     BIT(8)  ALIGNED,
         3 SMF26OPS     BIT(8)  ALIGNED,
         3 SMF26LOC     BIT(16) ALIGNED,
         3 SMF26DEV     CHAR(8),
         3 SMF26ACT     CHAR(4),
         3 SMF26ROM     CHAR(4),
         3 SMF26XTM     BIN FIXED(31,0),
         3 SMF26ELN     BIN FIXED(31,0),
         3 SMF26EPU     BIN FIXED(31,0),
         3 SMF26FRM     CHAR(4),
         3 SMF26CYP     BIN FIXED(15,0),
         3 SMF26LIN     BIN FIXED(15,0),
         3 SMF26PRR     BIT(16) ALIGNED,
         3 SMF26PUR     BIT(16) ALIGNED,
         3 SMF26PDD     CHAR(8),
         3 SMF26LN2     BIN FIXED(15,0),
         3 SMF26RV2     BIT(16) ALIGNED,
         3 SMF26RPT     BIN FIXED(31,0),
         3 SMF26RPD     DEC FIXED(7,0),
         3 SMF26CST     BIN FIXED(31,0),
         3 SMF26CSD     DEC FIXED(7,0),
         3 SMF26CPT     BIN FIXED(31,0),
         3 SMF26CPD     DEC FIXED(7,0),
         3 SMF26XST     BIN FIXED(31,0),
         3 SMF26XSD     DEC FIXED(7,0),
         3 SMF26XPT     BIN FIXED(31,0),
         3 SMF26XPD     DEC FIXED(7,0),
         3 SMF26OST     BIN FIXED(31,0),
         3 SMF26OSD     DEC FIXED(7,0),
         3 SMF26OPT     BIN FIXED(31,0),
         3 SMF26OPD     DEC FIXED(7,0),
         3 SMF26LN3     BIN FIXED(15,0),
         3 SMF26RV4     BIT(16) ALIGNED,
         3 SMF26ICD     BIN FIXED(31,0),
         3 SMF26XLN     BIN FIXED(31,0),
         3 SMF26XPU     BIN FIXED(31,0),
         3 SMF26RID     CHAR(4),
         3 SMF26CID     CHAR(4),
         3 SMF26XID     CHAR(4),
         3 SMF26OID     CHAR(4);
     %PAGE;
 DCL   1 TYPE34    UNAL  BASED(P1),
         3 TIVRFLG     BIT(8)  ALIGNED,
         3 TIVRCDTY    BIT(8)  ALIGNED,
         3 TIVRCDTS    BIN FIXED(31,0),
         3 TIVRCDTE    DEC FIXED(7,0),
         3 TIVCPUID    CHAR(4),
         3 TIVUIF      CHAR(8),
         3 TIVONTME    BIN FIXED(31,0),
         3 TIVONDTE    DEC FIXED(7,0),
         3 TIVUDATA    CHAR(8),
         3 TIVINVSQ    BIT(8)  ALIGNED,
         3 TIVSIT      BIN FIXED(31,0),
         3 TIVOUTCT    BIN FIXED(31,0),
         3 TIVINCT     BIN FIXED(31,0),
         3 TIVSTAT     BIT(16) ALIGNED,
         3 TIVPRI      BIT(8)  ALIGNED,
         3 TIVPRGNM    CHAR(8),
         3 TIVINVNM    CHAR(8),
         3 TIVEFRGN    BIN FIXED(15,0),
         3 TIVSYST     BIN FIXED(15,0),
         3 TIVMCRE     BIN FIXED(15,0),
         3 TIVRVC      BIT(48) ALIGNED,
         3 TIVSPK      BIT(8)  ALIGNED,
         3 TIVSTI      BIT(8)  ALIGNED,
         3 TIVRV1      BIT(16) ALIGNED,
         3 TIVAST      BIN FIXED(31,0),
         3 TIVPPST     BIN FIXED(31,0),
         3 TIVRV2      BIT(8)  ALIGNED,
         3 TIVSRBT     BIT(24) ALIGNED,
         3 TIVRIN      BIT(16) ALIGNED,
         3 TIVRLCT     BIN FIXED(15,0),
         3 TIVVAR      BIN FIXED(15,0),
         3 TIVDEV      CHAR(LDEV34 REFER(TIVVAR)),
         3 TIVVARA     BIT(8)  ALIGNED,
         3 TIVACCT     CHAR(LACTFLD REFER(TIVVARA));
     %PAGE;
 DCL   1 TYPE35    UNAL  BASED(P1),
         3 TLGRFLG     BIT(8)  ALIGNED,
         3 TLGRCDTY    BIT(8)  ALIGNED,
         3 TLGRCDTS    BIN FIXED(31,0),
         3 TLGRCDTE    DEC FIXED(7,0),
         3 TLGCPUID    CHAR(4),
         3 TLGUIF      CHAR(8),
         3 TLGONTME    BIN FIXED(31,0),
         3 TLGONDTE    DEC FIXED(7,0),
         3 TLGUDATA    CHAR(8),
         3 TLGSTPCT    BIT(8)  ALIGNED,
         3 TLGCRTME    BIN FIXED(31,0),
         3 TLGOUTCT    BIN FIXED(31,0),
         3 TLGINCT     BIN FIXED(31,0),
         3 TLGSTAT     BIT(16) ALIGNED,
         3 TLGPRI      BIT(8)  ALIGNED,
         3 TLGNQTME    BIN FIXED(31,0),
         3 TLGNQDTE    DEC FIXED(7,0),
         3 TLGTRMI     BIT(8)  ALIGNED,
         3 TLGOUTCL    BIT(8)  ALIGNED,
         3 TLGTRANT    BIN FIXED(31,0),
         3 TLGRVC      BIT(32) ALIGNED,
         3 TLGSPK      BIT(8)  ALIGNED,
         3 TLGSRBT     BIT(24) ALIGNED,
         3 TLGTJS      BIN FIXED(31,0),
         3 TLGTTAT     BIN FIXED(31,0),
         3 TLGNTSN     BIN FIXED(31,0),
         3 TLGPGNO     BIN FIXED(15,0),
         3 TLGRV2      BIT(16) ALIGNED,
         3 TLGVAR      BIT(8)  ALIGNED,
         3 TLGRVB      CHAR(20),
         3 TLGCPUTM    BIT(24) ALIGNED,
         3 TLGNBRAC    BIT(8)  ALIGNED,
         3 TLGACFLD    CHAR(IL REFER(TLGNBRAC));
     %PAGE;
 DCL   1 TYPE40    UNAL  BASED(P1),
         3 TDDRFLG     BIT(8)  ALIGNED,
         3 TDDRCDTY    BIT(8)  ALIGNED,
         3 TDDRCDTS    BIN FIXED(31,0),
         3 TDDRCDTE    DEC FIXED(7,0),
         3 TDDCPUID    CHAR(4),
         3 TDDUIF      CHAR(8),
         3 TDDONTME    BIN FIXED(31,0),
         3 TDDONDTE    DEC FIXED(7,0),
         3 TDDUDATA,
           5 TDDU6     CHAR(6),
           5 TDDUTSFL  CHAR(2),     /*  TSO USER FLAG = 'TS' IF TSO */
         3 TDDINVSQ    BIT(8)  ALIGNED,
         3 TDDFLG      BIT(8)  ALIGNED,
         3 TDDRIN      BIT(16) ALIGNED,
         3 TDDRVA      BIT(144) ALIGNED,
         3 TDDVAR      BIN FIXED(15,0),
         3 TDDDEV      CHAR(LDEV40 REFER(TDDVAR));
    %PAGE;
 DCL   1 TYPE70    UNAL  BASED(P1),
         3 SMF70FLG     BIT(8)  ALIGNED,
         3 SMF70RTY     BIT(8)  ALIGNED,
         3 SMF70TME     BIN FIXED(31,0),
         3 SMF70DTE     DEC FIXED(7,0),
         3 SMF70SID     CHAR(4),
         3 SMF70SIZ     BIN FIXED(15,0),
         3 SMF70IST     DEC FIXED(7,0),
         3 SMF70DAT     DEC FIXED(7,0),
         3 SMF70INT     DEC FIXED(7,0),
         3 SMF70MOD     BIT(16) ALIGNED,
         3 SMF70SUB     BIT(16) ALIGNED,
         3 SMF70SAM     BIN FIXED(31,0),
         3 SMF70MFV     CHAR(2),
         3 SMF70RV1     BIT(16) ALIGNED,
         3 SMF70RLS     CHAR(4),
         3 SMF70CYC     DEC FIXED(7,0),
         3 SMF70SCC     BIN FIXED(15,0),
         3 SMF70CPU     BIN FIXED(15,0),
         3 SMF70SCD     BIN FIXED(15,0),
         3 SMF70SAS     BIT(16) ALIGNED,
         3 SMF70SUS     BIT(112) ALIGNED,
         3 SMF70RV2     BIT(16) ALIGNED,
         3 SMF70_CPUDATA(2),
           5 SMF70WAT,
             7 SMF70WT1 BIN FIXED(31,0),
             7 SMF70WT2 BIT(32) ALIGNED,
           5 SMF70CID   BIN FIXED(15,0),
           5 SMF70RV3   BIT(8)  ALIGNED,
           5 SMF70CNF   BIT(8)  ALIGNED,
           5 SMF70RV4   BIT(8)  ALIGNED,
           5 SMF70SER   BIT(24) ALIGNED;
    %SKIP(1);
 DCL   WATBITS          BIT(32) ALIGNED,
       WATBIT32         BIT(1)  DEF(WATBITS);
    %PAGE;
 DCL   1 TYPE71    UNAL  BASED(P1),
         3 SMF71FLG     BIT(8)  ALIGNED,
         3 SMF71RTY     BIT(8)  ALIGNED,
         3 SMF71TME     BIN FIXED(31,0),
         3 SMF71DTE     DEC FIXED(7,0),
         3 SMF71SID     CHAR(4),
         3 SMF71SIZ     BIN FIXED(15,0),
         3 SMF71IST     DEC FIXED(7,0),
         3 SMF71DAT     DEC FIXED(7,0),
         3 SMF71INT     DEC FIXED(7,0),
         3 SMF71RV0     BIT(16) ALIGNED,
         3 SMF71SUB     BIT(16) ALIGNED,
         3 SMF71SAM     BIN FIXED(31,0),
         3 SMF71MFV     CHAR(2),
         3 SMF71RV1     BIT(16) ALIGNED,
         3 SMF71RLS     CHAR(4),
         3 SMF71CYC     DEC FIXED(7,0),
         3 SMF71SPC     BIN FIXED(15,0),
         3 SMF71SPD     BIN FIXED(15,0),
         3 SMF71PIN     BIN FIXED(31,0),
         3 SMF71POT     BIN FIXED(31,0),
         3 SMF71PRC     BIN FIXED(31,0),
         3 SMF71SSQ     BIN FIXED(31,0),
         3 SMF71SIN     BIN FIXED(31,0),
         3 SMF71SOT     BIN FIXED(31,0),
         3 SMF71VIN     BIN FIXED(31,0),
         3 SMF71VOT     BIN FIXED(31,0),
         3 SMF71VRC     BIN FIXED(31,0),
         3 SMF71SNI     BIN FIXED(31,0),
         3 SMF71SNO     BIN FIXED(31,0),
         3 SMF71SNR     BIN FIXED(31,0),
         3 SMF71RV2     BIN FIXED(31,0),
         3 SMF71RV3     BIN FIXED(31,0),
         3 SMF71RV4     BIN FIXED(31,0),
         3 SMF71AFC     BIN FIXED(31,0),
         3 SMF71TFC     BIN FIXED(31,0),
         3 SMF71TSC     BIN FIXED(31,0),
         3 SMF71DSC     BIN FIXED(31,0),
         3 SMF71VSC     BIN FIXED(31,0),
         3 SMF71NSC     BIN FIXED(31,0),
         3 SMF71FIN     BIN FIXED(31,0),
         3 SMF71MNF     BIN FIXED(31,0),
         3 SMF71MXF     BIN FIXED(31,0),
         3 SMF71AVF     BIN FIXED(31,0),
         3 SMF71MNP     BIN FIXED(31,0),
         3 SMF71MXP     BIN FIXED(31,0),
         3 SMF71AVP     BIN FIXED(31,0),
         3 SMF71MNS     BIN FIXED(31,0),
         3 SMF71MXS     BIN FIXED(31,0),
         3 SMF71AVS     BIN FIXED(31,0),
         3 SMF71MNT     BIN FIXED(31,0),
         3 SMF71MXT     BIN FIXED(31,0),
         3 SMF71AVT     BIN FIXED(31,0),
         3 SMF71MNQ     BIN FIXED(31,0),
         3 SMF71MXQ     BIN FIXED(31,0),
         3 SMF71AVQ     BIN FIXED(31,0),
         3 SMF71MNC     BIN FIXED(31,0),
         3 SMF71MXC     BIN FIXED(31,0),
         3 SMF71AVC     BIN FIXED(31,0),
         3 SMF71MNR     BIN FIXED(31,0),
         3 SMF71MXR     BIN FIXED(31,0),
         3 SMF71AVR     BIN FIXED(31,0),
         3 SMF71MNX     BIN FIXED(31,0),
         3 SMF71MXX     BIN FIXED(31,0),
         3 SMF71AVX     BIN FIXED(31,0),
         3 SMF71MNU     BIN FIXED(31,0),
         3 SMF71MXU     BIN FIXED(31,0),
         3 SMF71AVU     BIN FIXED(31,0),
         3 SMF71MNV     BIN FIXED(31,0),
         3 SMF71MXV     BIN FIXED(31,0),
         3 SMF71AVV     BIN FIXED(31,0),
         3 SMF71MNM     BIN FIXED(31,0),
         3 SMF71MXM     BIN FIXED(31,0),
         3 SMF71AVM     BIN FIXED(31,0),
         3 SMF71MNB     BIN FIXED(31,0),
         3 SMF71MXB     BIN FIXED(31,0),
         3 SMF71AVB     BIN FIXED(31,0),
         3 SMF71MNA     BIN FIXED(31,0),
         3 SMF71MXA     BIN FIXED(31,0),
         3 SMF71AVA     BIN FIXED(31,0),
         3 SMF71TIS     BIN FIXED(31,0),
         3 SMF71LWS     BIN FIXED(31,0),
         3 SMF71DWS     BIN FIXED(31,0),
         3 SMF71ULS     BIN FIXED(31,0),
         3 SMF71NRS     BIN FIXED(31,0),
         3 SMF71ASS     BIN FIXED(31,0),
         3 SMF71RSS     BIN FIXED(31,0),
         3 SMF71EXS     BIN FIXED(31,0),
         3 SMF71EES     BIN FIXED(31,0),
         3 SMF71TOS     BIN FIXED(31,0),
         3 SMF71RV8     BIN FIXED(31,0);
     %PAGE;
 DCL   1 TYPE72    UNAL  BASED(P1),
         3 SMF72FLG     BIT(8)  ALIGNED,
         3 SMF72RTY     BIT(8)  ALIGNED,
         3 SMF72TME     BIN FIXED(31,0),
         3 SMF72DTE     DEC FIXED(7,0),
         3 SMF72SID     CHAR(4),
         3 SMF72SIZ     BIN FIXED(15,0),
         3 SMF72IST     DEC FIXED(7,0),
         3 SMF72DAT     DEC FIXED(7,0),
         3 SMF72INT     DEC FIXED(7,0),
         3 SMF72RV0     BIT(16) ALIGNED,
         3 SMF72SUB     BIN FIXED(15,0),
         3 SMF72SAM     BIT(32) ALIGNED,
         3 SMF72MFV     CHAR(2),
         3 SMF72RV1     BIT(16) ALIGNED,
         3 SMF72RLS     CHAR(4),
         3 SMF72CYC     DEC FIXED(7,0),
         3 SMF72SWC     BIN FIXED(15,0),
         3 SMF72PGP     BIN FIXED(15,0),
         3 SMF72SPD     BIN FIXED(15,0),
         3 SMF72HPG     BIN FIXED(15,0),
         3 SMF72IPS     CHAR(8),
         3 SMF72IRF     CHAR(3),
         3 SMF72CRF     CHAR(3),
         3 SMF72ERF     CHAR(6),
         3 SMF72ISD     CHAR(4),
         3 SMF72CSD     CHAR(4),
         3 SMF72MSD     CHAR(4),
         3 SMF72PGD(8),
           5 SMF72TTX   BIN FIXED(31,0),
           5 SMF72ACT   BIN FIXED(31,0),
           5 SMF72SER   BIN FIXED(31,0),
           5 SMF72TTM   BIN FIXED(31,0),
           5 SMF72LEV   BIN FIXED(31,0),
           5 SMF72MTS   BIN FIXED(31,0),
           5 SMF72ITS   BIN FIXED(31,0),
           5 SMF72CTS   BIN FIXED(31,0),
           5 SMF72TAT   BIN FIXED(31,0),
           5 SMF72SPP   BIN FIXED(31,0),
           5 SMF72CDN   BIN FIXED(15,0),
           5 SMF72PON   BIT(8) ALIGNED,
           5 SMF72RV2   BIT(8) ALIGNED;
     %SKIP(4);
     %PAGE;
 DCL   1 TYPE73    UNAL  BASED(P1),
         3 SMF73FLG     BIT(8)  ALIGNED,
         3 SMF73RTY     BIT(8)  ALIGNED,
         3 SMF73TME     BIN FIXED(31,0),
         3 SMF73DTE     DEC FIXED(7,0),
         3 SMF73SID     CHAR(4),
         3 SMF73SIZ     BIN FIXED(15,0),
         3 SMF73IST     DEC FIXED(7,0),
         3 SMF73DAT     DEC FIXED(7,0),
         3 SMF73INT     DEC FIXED(7,0),
         3 SMF73RV0     BIT(16) ALIGNED,
         3 SMF73SUB     BIN FIXED(15,0),
         3 SMF73SAM     BIN FIXED(31,0),
         3 SMF73MFV     CHAR(2),
         3 SMF73RV1     BIT(16) ALIGNED,
         3 SMF73RLS     CHAR(4),
         3 SMF73CYC     DEC FIXED(7,0),
         3 SMF73SHC     BIN FIXED(15,0),
         3 SMF73CHA     BIN FIXED(15,0),
         3 SMF73SHD     BIN FIXED(15,0),
         3 SMF73LCA     BIN FIXED(15,0),
         3 SMF73SLD     BIN FIXED(15,0),
         3 SMF73RV2     BIN FIXED(15,0),
         3 SMF73CB0     BIN FIXED(31,0),
         3 SMF73CB1     BIN FIXED(31,0),
         3 SMF73WB0     BIN FIXED(31,0),
         3 SMF73WB1     BIN FIXED(31,0),
         3 SMF73PCD(I#PHDS REFER(SMF73CHA)),
           5 SMF73CID   BIN FIXED(15,0),
           5 SMF73HID   BIT(8) ALIGNED,
           5 SMF73FG2,
             7 RSV1     BIT(2),
             7 BLMPX    BIT(1),
             7 BYMPX    BIT(1),
             7 RSV2     BIT(1),
             7 INVCHID  BIT(1),
             7 INVDATA  BIT(1),
             7 CHISON   BIT(1),
           5 SMF73CNT   BIN FIXED(31,0),
           5 SMF73BSY   BIN FIXED(31,0),
           5 SMF73OLP   BIN FIXED(31,0);
     %SKIP(4);
 FINISH:
   END UTLSMRY;
