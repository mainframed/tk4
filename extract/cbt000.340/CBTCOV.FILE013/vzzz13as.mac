         TITLE 'PRINTDS  LEVEL 3.0   6/08/79  M.J.SPRINZEN'
*
PRINTDS  CSECT
*
*  "PRINTDS" - A TSO COMMAND PROCEDURE                  WRITTEN 7/77
*
*)F FUNCTION -
*  THE PRINTDS COMMAND DYNAMICALLY PRINTS OR PUNCHES: A SEQUENTIAL
*  DATASET, SPECIFIED MEMBERS OF A PARTITIONED DATASET, OR ALL
*  MEMBERS OF A PARTITIONED DATASET.
*)X SYNTAX  -
*          PRINTDS   'DSNAME'  HEADING/NOHEADING  HOLD
*                    CLASS('SYSOUT CLASS')  COPIES('NUMBER')
*                    DEST('LOCATION')  FUNC('FUNCTION')
*                    PAGE/NOPAGE  INDEX/NOINDEX  NOMESSAGES
*                    LINESIZE('NUMBER')  LINECOUNT('NUMBER')
*                    FCB('FCB')   CHARS('CHARACTER SET')
*                    SELECT('LIST OF MEMBERS') RANGE('START':'END')
*                    START('RECORD')  COUNT('RECORDS')
*  REQUIRED - 'DSNAME'
*  DEFAULTS - HEADING, CLASS(1), COPIES(1), DEST(LOCAL),
*             LINESIZE(131), LINECOUNT(60), AND, NOPAGE
*             AND INDEX ARE DEFAULTS WHEN PRINTING A PDS.
*  ALIAS    - NONE
*  NOTE     - IF THE FULLY QUALIFIED DATA SET NAME IS SPECIFIED,IT MUST
*             BE ENCLOSED IN SINGLE QUOTES. IF THE DATA SET NAME IS NOT
*             ENTERED WITHIN QUOTES, THE USERID IS ALWAYS APPENDED TO
*             THE LEFT OF THE NAME.
*           - TO PRINT A PARTICULIAR MEMBER OF A PARTITIONED DATASET,
*             SPECIFY 'DSNAME(MEMBERNAME)' AS THE FIRST OPERAND.
*           - THE OPERAND 'CLASS' MAY ALSO BE SPECIFIED AS 'SYSOUT'.
*           - THE OPERAND 'DEST'  MAY ALSO BE SPECIFIED AS 'ROUTE'.
*           - THE OPERAND 'NOMESSAGES' MAY ALSO BE SPEC AS 'NOMSG'.
*)O OPERANDS -
*))'DSNAME'  - DSNAME IS THE NAME OF THE DATASET TO BE PRINTED.
*))HEADING   - SPECIFIES THAT A HEADING IS TO APPEAR ON THE TOP OF EACH
*              OUTPUT PAGE.
*))NOHEADING - SPECIFIES THAT A HEADING IS NOT TO APPEAR ON THE TOP OF
*              EACH OUTPUT PAGE. THIS IS NECESSARY WHEN PUNCHING CARDS
*              OR PRINTING DATASETS THAT CONTAIN CARRIAGE CONTROL (ASA)
*              CHARACTERS. WHEN PRINTING A PDS, A HEADING WILL ALWAYS
*              BE PRINTED.
*))HOLD   - OUTPUT IS TO BE PLACED IN HOLD STATUS.
*))CLASS('CLASS')   - THE OUTPUT CLASS (SYSOUT CLASS) TO BE USED.
*))COPIES('NUMBER') - NUMBER OF COPIES OF SYSOUT DATASET TO BE PRODUCED
*                     MAXIMUM NUMBER OF COPIES IS 255.
*))DEST('LOCATION') - REMOTE LOCATION TO WHICH SYSOUT DATASET IS TO BE
*                     ROUTED.
*))FUNC('FUNCTION') - IF THE SYSOUT DATASET IS TO BE PUNCHED CARDS,
*                     "FUNC(I)" WILL SPECIFY INTERPRETING.
*))PAGE  - SPECIFIES THAT EACH MEMBER OF A PDS WILL BEGIN ON A NEW PAGE
*))NOPAGE - SPECIFIES THAT EACH MEMBER OF A PDS WILL NOT BEGIN ON A NEW
*           PAGE.
*))INDEX   - A PAGE INDEX IS TO BE PRODUCED FOR A PDS.
*))NOINDEX - NO PAGE INDEX IS TO BE PRODUCED.
*))NOMESSAGES - FOR A PDS LISTING, NO MESSAGE IS TO APPEAR ON THE TSO
*               TERMINAL AFTER PROCESSING EACH MEMBER.
*))LINESIZE - SPECIFIES THE OUTPUT LINESIZE WHERE  121<= LINESIZE <=205
*             HAS NO EFFECT IF "NOHEADING" SPECIFIED. LINESIZE MUST BE
*             1 GREATER THAN RECORD SIZE TO ALLOW FOR ASA CHARACTER.
*))LINECOUNT - SPECIFIES THE NUMBER OF LINES PRINTED PER PAGE.
*              HAS NO EFFECT IF "NOHEADING" SPECIFIED.
*))FCB   - ALLOWS FOR SPECIFICATION OF AN FCB FOR 3800 PRINTER ONLY.
*))CHARS - ALLOWS FOR SPECIFICATION OF A CHARACTER SET FOR A 3800 PRNTR
*          ONLY.
*))SELECT - FOR A PDS LISTING, ALLOWS FOR SELECTING SPECIFIED MEMBERS.
*))RANGE  - USED TO SPECIFY A RANGE OF MEMBERS TO BE PRINTED FROM A PDS
*           THE RANGE MAY BE GENERIC (I.E.  RANGE(A:C) - WILL CAUSE ALL
*           MEMBERS THAT BEGIN WITH A,B, OR C TO BE PRINTED).
*))START - SPECIFIES THE RECORD FOR WHICH PRINTING IS TO START. WILL
*          APPLY TO ALL MEMBERS OF A PDS.
*))COUNT - SPECIFIES THE NUMBER OF RECORDS TO BE PRINTED. MAY BE USED
*          WITH THE START OPTION (I.E. START(100) COUNT(10) - WILL PRNT
*          10 RECORDS STARTING WITH RECORD 100). WILL APPLY TO ALL
*          MEMBERS OF A PDS.
*
*
*  METHOD: IKJPARSE IS USED TO GET THE INPUT LINE FROM COMMAND BUFFER.
*          IF EITHER FCB OR CHARS IS SPECIFIED, ROUTINE PRINTDSY IS
*          CALLED TO DO VALIDITY CHECKING (I.E. CHECK 'SYS1.IMAGELIB').
*          THE SYSOUT DATASET IS THEN DYNAMICALLY ALLOCATED WITH THE
*          SYSTEM ALLOCATED DDNAME PASSED BACK TO PROGRAM. THE SYSOUT
*          DATASET IS SPECIFIED TO BE FREED ON CLOSE. THE "DYNALLOC"
*          MACRO IS USED RATHER THAN THE "DAIR" SERVICE ROUTINES SO
*          THAT MULTIPLE COPIES AND/OR INTERPRETING OF CARDS CAN BE
*          SPECIFIED. THE INPUT DATASET IS THEN DYNAMICALLY ALLOCTED
*          USING THE "DYNALLOC" MACRO AND THE SYSTEM ALLOCTED DDNAME
*          IS PASSED BACK TO THE PROGRAM. IF "NOHEADING" WAS NOT
*          SPECIFIED, "PRINTDSX" IS CALLED TO DO PROCESSING.
*          IF NOT (I.E. A DIRECT COPY), THE DCB'S FOR BOTH THE INPUT
*          AND OUTPUT (SYSOUT) DATASETS ARE THEN MODIFIED TO USE THE
*          RETURNED DDNAMES. THE INPUT DATASET IS OPENED AND ITS
*          RECFM, LRECL, AND BLKSIZE ARE COPIED TO THE OUTPUT DCB.
*          THE OUTPUT DCB IS OPENED. QSAM IS USED WITH CHAIN SCHEDULING
*          TO COPY THE INPUT TO THE OUTPUT. A "SYNAD" EXIT IS SUPPLIED
*          AND USES SYNADAF WITH ADDITIONAL COMMENTS ADDED.
*
*
*  NOTES:
*   (1) THIS IS A CP AND EXPECTS REG. 1 TO POINT TO A CPPL.
*   (2) USING REGS 4,5,9 FOR PARSE, 4,5,6,8 FOR DYNALLOC,
*       REG 4 FOR DCBD, REGS 11,12 FOR PROGRAM, REG 13 FOR DSECT1,
*       REGS 2,3,7,10    FOR WORKING.
*   (3) RETURN CODE OF 12 IF ERROR (PARSE,DYNALLOC,OPEN,SYNAD,CLOSE).
*   (4) THE SYNAD ERROR RETURNS TO THE TMP SO NO ABEND WILL OCCUR.
*   (5) THE INPUT DATASET IS NOT FREED SO C.B.'S CAN BE REUSED. NOTE:
*       SINCE IT IS NOT ALLOCATED WITH PERMANENT ATTR THIS IS O.K.
         EJECT
*        SET DEFAULT SYSOUT CLASS
         SPACE 1
         GBLC  &CLASS
&CLASS   SETC  'A'                                    AXC CBT
         SPACE 2
SP1      EQU   7              SUBPOOL FOR GETMAINS
         SPACE 1
         SAVE  (14,12),,*     SAVE REGS
         LR    12,15          ESTABLISH ADDRESSABILITY
         LA    11,2048(12)
         LA    11,2048(11)    POINT TO NEXT 4K
         USING PRINTDS,12,11
* SAVE PARM PTR IN R3
         LR    9,1
         SPACE 1
* GETMAIN FOR REENT
         GETMAIN R,LV=DLENGTH,SP=SP1
         ST    13,4(1)        SAVE R13 INTO NEW SAVEAREA
         ST    1,8(0,13)      STORE NEW SAVEAREA ADDR INTO OLD
         LR    13,1           R1 POINTS TO NEW SAVE (BEG DSECT1)
         USING DSECT1,13      ADDRES. FOR DSECT1 (CONTAINS SAVEAREA)
         EJECT
*
*  INITIALIZE GETMAINED AREA
*
         SPACE 1
* ZILCH CORE (FIRST 256 BYTES- THUS, ANYTHING THAT MUST BE 0 GOES HERE)
*   START AFTER SAVEAREA SO AS NOT TO OVERLAY
         XR    3,3
         STC   3,72(13)       AFTER 72 BYTE SAVEAREA
         MVC   73(256,13),72(13)
         XC    CARRIAGE,CARRIAGE
         SPACE 1
* MOVE IN DCBS
         MVC   DSNIN(DSNINL),DSNIN2
         MVC   DSNOUT(DSNOUTL),DSNOUT2
         SPACE 1
* MOVE IN OPEN & CLOSE MACROS AND INIT.
         MVC   OPENIN(4),OPENIN2
         MVC   OPENOUT(4),OPENOUT2
         MVC   CLOSEB(8),CLOSEB2
         LA    3,DSNIN
         STCM  3,B'0111',OPENIN+1
         STCM  3,B'0111',CLOSEB+1
         LA    3,DSNOUT
         STCM  3,B'0111',OPENOUT+1
         STCM  3,B'0111',CLOSEB+5
         SPACE 1
* MOVE IN SUBMSG,PUTMSG,TABADDR,WORKP,WORKZ,LINESIZE,LINECNT
         MVC   SUBMSG(78),SUBMSG2
         MVC   PUTMSG(4),PUTMSG2
         MVC   TABADDR,=V(PARMTAB)
         MVC   LINECNT,=H'60'   DEFAULT
         MVC   LINESIZE,=H'133' DEFAULT
         SPACE 1
* INIT IOPL AND PUTLINE STUFF
         MVC   PUTLIST(PUTLISTL),PUTLIST2
         LA    3,PUTMSG
         ST    3,PUTLIST+4
         LA    3,PUTLIST
         ST    3,IOPL+12     IOPL NEEDS ADDR OF LIST FORM
         LA    3,ECBPUT
         ST    3,IOPL+8      IOPL ALSO NEEDS ECB ADDRESS
         SPACE 1
* MOVE 68 BLANKS INTO DSN & DDNAMES
         IC    3,=C' '
         STC   3,DDNAME1
         MVC   DDNAME1+1(67),DDNAME1
         SPACE 1
* SAVE ORIGINAL PARM REG
         ST    9,CPPLADDR    STORE ADDR OF CPPL FOR LATER USE
         EJECT
*
*    PARSE ROUTINE SETUP
*
*    ALLOCATE SPACE FOR PPL AND MOVE IN FIELDS FROM CPPL + ELSEWHERE
*
*        FOR FOLLOWING SECTION OF CODE USING REGS 4,5 + 6 FOR DSECTS
*        FROM MACROS IKJCPPL, IKJPPL AND IKJPARM WHICH IS PDL RETRND
*        FROM PARSE AND CONTAINS THE SPECIFIED PDE'S.
*
         L     4,CPPLADDR
         USING CPPL,4        ADDRESSABILITY FOR CPPL DSECT
*
         LA    5,PPLAREA
         USING PPL,5
*    NOW CREATE PARSE PARAMETER LIST (PPL)  AND IOPL FOR PUTLINES
         L     7,CPPLCBUF   FROM CPPL
         ST    7,PPLCBUF           TO PPL
         L     7,CPPLUPT    FROM CPPL
         ST    7,PPLUPT            TO PPL
         ST    7,IOPL              TO IOPL FOR PUTLINE
         L     7,CPPLECT    FROM CPPL
         ST    7,PPLECT            TO PPL
         ST    7,IOPL+4            TO IOPL FOR PUTLINE
         LA    7,0          PUT 0 IN THIS FIELD
         ST    7,PPLUWA                      IN PPL
         LA    7,ECBPPL     PUT ADDR OF ECB
         ST    7,PPLECB                      IN PPL
         L     7,TABADDR    FROM PARSE MACROS - PDL
         ST    7,PPLPCL
         LA    7,ANSADDR    ADDR OF ANSWER AREA FOR PARSE
         ST    7,PPLANS
         DROP  4,5
*
         LR    1,5           PUT ADDR OF PPL IN R1 AND THEN
         LINK  EP=IKJPARS    CALL PARSE ROUTINE
         LTR   15,15
         BNZ   ERRPARSE
*
         L     9,ANSADDR     GET LOC. OF PDL RETURNRD BY PARSE
         USING IKJPARMD,9    USE THE IKJPARMD DSECT FOR ADDRES.
*
* IKJPARMD DSECT LOOKS AS FOLLOWS:
* IKJPARMD DSECT
*          DS   2A HEADER INFO. - USED BY RELEASE MACRO
* DSNPDE   DS   6A CONTAINS LENGTH OF(4-5) + PTR(8-11) TO DSNAME
* COPKEYW  DS   AL2
* LINKEYW  DS   AL2
* LCCKEYW  DS   AL2
* FCBKEYW  DS   AL2
* CHAKEYW  DS   AL2
* DESKEYW  DS   AL2
* CLAKEYW  DS   AL2
* FUNKEYW  DS   AL2
* NOPKEYW  DS   AL2
* NOHKEYW  DS   AL2
* NOIKEYW  DS   AL2
* NOMKEYW  DS   AL2
* HEXKEYW  DS   AL2
* HOLKEYW  DS   AL2
* RANKEYW  DS   AL2
* SELKEYW  DS   AL2
* COUKEYW  DS   AL2
* STAKEYW  DS   AL2
* COPNUM   DS   2A IF COPIES ENTERED THEN 1ST 4 BYTES ARE PTR.
* LINNUM   DS   2A IF LINESIZE ENTRD THEN 1ST 4 BYTES ARE PTR.
* LCCNUM   DS   2A IF LINECOUNT ETRD THEN 1ST 4 BYTES ARE PTR.
* FCBNUM   DS   2A IF FCB    ENTERED THEN 1ST 4 BYTES ARE PTR.
* CHANUM   DS   2A IF CHARS  ENTERED THEN 1ST 4 BYTES ARE PTR.
* DESNUM   DS   2A IF DEST   ENTERED THEN 1ST 4 BYTES ARE PTR.
* CLANUM   DS   2A IF CLASS  ENTERED THEN 1ST 4 BYTES ARE PTR.
* FUNNUM   DS   2A IF FUNC   ENTERED THEN 1ST 4 BYTES ARE PTR.
* RANNUM   DS   4A IF RANGE  ENTERED THEN 2 ENTRIES ("RANGE" OPTION)
* SELNUM   DS   3A IF SELECT ENTERED THEN LINKED LIST("LIST" OPTION)
* COUNUM   DS   2A IF COUNT  ENTERED THEN 1ST 4 BYTES ARE PTR.
* STANUM   DS   2A IF START  ENTERED THEN 1ST 4 BYTES ARE PTR.
*          DS   0D
* IKJ@0056 EQU  *-IKJPARMD = B0  FOR THIS SET OF PARSE MACROS
*
         MVC   DSNLNGTH(2),DSNPDE+4  MOVE LENGTH OF DSN INTO DSNLNGTH
         L     3,DSNPDE       LOAD FIRST 4 BYTES OF PDE (PTR TO DSN)
         LH    7,DSNLNGTH     LOAD LENGTH INTO R7 FOR MVC
         BCTR  7,0            FOR MVC
         EX    7,MVCEX1       MOVE DSNAME INTO DSNAME FIELD
         B     CONT1
MVCEX1   MVC   DSNAME(0),0(3)   MVC FOR EX INSTRUCTION
CONT1    EQU   *
         TM    DSNPDE+14,X'80'  SEE IF MEMBER NAME WAS SUPPLIED(FLAG)
         BZ    CONT2          NO IT WAS NOT
         MVC   MEMLNGTH(2),DSNPDE+12 MOVE LENGTH OF MEM INTO MEMLNGTH
         L     3,DSNPDE+8     LOAD 3RD 4 BYTES OF PDE (PTR TO MEM)
         LH    7,MEMLNGTH     LOAD LENGTH INTO R7 FOR MVC
         BCTR  7,0            DEC LENGTH BY 1 FOR MVC
         EX    7,MVCMEMB      MOVE DSNAME INTO DSNAME FIELD
         B     CONT2
MVCMEMB  MVC   MEMBER(0),0(3)   MVC FOR EX INSTRUCTION
CONT2    EQU   *
*
*  SEE IF "NOHEADING" WAS SPECIFIED, IF NOT TURN ON FLAGS BIT 1.
*
         TM    NOHKEYW+1,X'01' SEE IF "NOHEADING" ENTERED
         BO    NONOH           YES
         OI    FLAGS,X'40'     TURN ON IF HEADING ON SEQ. OUTPUT
NONOH    EQU   *
*
*  SEE IF "PAGE" WAS SPECIFIED, IF NOT, DO NOT TURN ON FLAGS BIT 0.
*
         TM    NOPKEYW+1,X'02' SEE IF "PAGE" ENTERED
         BZ    NONOP           NO
         OI    FLAGS,X'80'     TURN ON IF NEW PAGE FOR EACH MEMBER
NONOP    EQU   *
*
*  SEE IF "NOINDEX" WAS SPECIFIED, IF NOT TURN ON FLAGS BIT 7.
*
         TM    NOIKEYW+1,X'01' SEE IF "NOINDEX" ENTERED
         BO    NONOI           YES
         OI    FLAGS,X'02'     TURN ON IF INDEX REQUESTED
NONOI    EQU   *
*
* SEE IF "LINESIZE" WAS SPECIFIED
*
         TM    LINNUM+6,X'80' CK. FLAG TO SEE IF PRESENT(FLG=0 IF NO)
         BZ    NOLIN          NO IT WAS NOT - USE SYSTEM DEFAULT
         L     7,LINNUM       LOAD PTR TO LINSZE FIELD
         LH    3,LINNUM+4     LOAD LENGTH OF LINSZE ENTERED(1,2,OR 3)
         BCTR  3,0            DEC LENGTH BY 1 FOR MVC
         MVC   WORKZ(7),=ZL3'0' CLEAR
         LA    2,WORKZ        FOR MVC
         LA    2,2(2)         ADD 2 TO ADDR (PT TO LAST BYTE)
         SR    2,3            SUB 0,1, OR 2 DEPENDING ON # OF BYTES
         EX    3,MVCLIN       EXEC MVC
         B     CONT2A
MVCLIN   MVC   0(0,2),0(7)    MOVE N CHARS (MAX 3 NUMERICS)
CONT2A   PACK  WORKP(8),WORKZ(3) PACK THE 3 BYTES
         CVB   3,WORKP        GET BINARY EQUIV
         STH   3,LINESIZE     STORE FOR USE LATER.
NOLIN    EQU   *
*
* SEE IF "LINECOUNT" WAS SPECIFIED
*
         TM    LCCNUM+6,X'80' CK. FLAG TO SEE IF PRESENT(FLG=0 IF NO)
         BZ    NOLCC          NO IT WAS NOT - USE SYSTEM DEFAULT
         L     7,LCCNUM       LOAD PTR TO LINCNT FIELD
         LH    3,LCCNUM+4     LOAD LENGTH OF LINCNT ENTERED(1,2,OR 3)
         BCTR  3,0            DEC LENGTH BY 1 FOR MVC
         MVC   WORKZ(7),=ZL3'0' CLEAR
         LA    2,WORKZ        FOR MVC
         LA    2,2(2)         ADD 2 TO ADDR (PT TO LAST BYTE)
         SR    2,3            SUB 0,1, OR 2 DEPENDING ON # OF BYTES
         EX    3,MVCLCC       EXEC MVC
         B     CONT2B
MVCLCC   MVC   0(0,2),0(7)    MOVE N CHARS (MAX 3 NUMERICS)
CONT2B   PACK  WORKP(8),WORKZ(3) PACK THE 3 BYTES
         CVB   3,WORKP        GET BINARY EQUIV
         STH   3,LINECNT      STORE FOR USE LATER.
NOLCC    EQU   *
*
* SEE IF "COUNT" WAS SPECIFIED
*
         TM    COUNUM+6,X'80' CK. FLAG TO SEE IF PRESENT(FLG=0 IF NO)
         BZ    NOCOU          NO IT WAS NOT - IGNORE
         OI    FLAGS2,X'40'   TURN ON COUNT BIT
         L     7,COUNUM       LOAD PTR TO COUNT  FIELD
         LH    3,COUNUM+4     LOAD LENGTH OF COUNT  ENTERED(1-7)
         BCTR  3,0            DEC LENGTH BY 1 FOR MVC
         MVC   WORKZ2(7),=ZL7'0' CLEAR
         LA    2,WORKZ2       FOR MVC
         LA    2,6(2)         ADD 6 TO ADDR (PT TO LAST BYTE)
         SR    2,3            SUB 0,1,2.... DEPENDING ON # OF BYTES
         EX    3,MVCCOU       EXEC MVC
         B     CONT2C
MVCCOU   MVC   0(0,2),0(7)    MOVE N CHARS (MAX 7 NUMERICS)
CONT2C   PACK  WORKP(8),WORKZ2(7) PACK THE 7 BYTES
         CVB   3,WORKP        GET BINARY EQUIV
         ST    3,COUNT        STORE FOR USE LATER.
NOCOU    EQU   *
*
* SEE IF "START" WAS SPECIFIED
*
         TM    STANUM+6,X'80' CK. FLAG TO SEE IF PRESENT(FLG=0 IF NO)
         BZ    NOSTA          NO IT WAS NOT
         OI    FLAGS2,X'20'   TURN ON START BIT
         L     7,STANUM       LOAD PTR TO START  FIELD
         LH    3,STANUM+4     LOAD LENGTH OF START  ENTERED(1-7)
         BCTR  3,0            DEC LENGTH BY 1 FOR MVC
         MVC   WORKZ2(7),=ZL7'0' CLEAR
         LA    2,WORKZ2       FOR MVC
         LA    2,6(2)         ADD 6 TO ADDR (PT TO LAST BYTE)
         SR    2,3            SUB 0,1,2.... DEPENDING ON # OF BYTES
         EX    3,MVCSTA       EXEC MVC
         B     CONT2D
MVCSTA   MVC   0(0,2),0(7)    MOVE N CHARS (MAX 7 NUMERICS)
CONT2D   PACK  WORKP(8),WORKZ2(7) PACK THE 7 BYTES
         CVB   3,WORKP        GET BINARY EQUIV
         ST    3,START        STORE FOR USE LATER.
NOSTA    EQU   *
*
* SEE IF "RANGE" WAS SPECIFIED - RANGE OPTION ON IKJIDENT
*
         TM    RANNUM+6,X'80' CK. FLAG TO SEE IF PRESENT(FLG=0 IF NO)
         BZ    NORAN          NO IT WAS NOT
         OI    FLAGS2,X'10'   TURN ON RANGE BIT
         MVC   RANGES(8),=8XL1'00'  CLEAR FIELD
         MVC   RANGES+8(8),=8XL1'FF'  "    "
         L     7,RANNUM       LOAD PTR TO 1ST ENTRY
         LH    3,RANNUM+4     LOAD LENGTH OF ENTRY (1-8)
         BCTR  3,0            DEC LENGTH BY 1 FOR MVC
         EX    3,MVCRAN1
         ICM   7,B'1111',RANNUM+8 LOAD PTR TO 2ND ENTRY
         BZ    CONT2E         NO SECOND ENTRY
         LH    3,RANNUM+12    LOAD LENGTH OF ENTRY (1-8)
         BCTR  3,0            DEC LENGTH BY 1 FOR MVC
         EX    3,MVCRAN2
         B     CONT2E
MVCRAN1  MVC   RANGES(0),0(7)   MOVE N CHARS (MAX 8)
MVCRAN2  MVC   RANGES+8(0),0(7) MOVE N CHARS (MAX 8)
CONT2E   EQU   *
NORAN    EQU   *
*
*  SEE IF "HEX" WAS SPECIFIED, IF YES TURN ON FLAGS2 BIT 5.
*
         TM    HEXKEYW+1,X'01' SEE IF "HEX" ENTERED
         BZ    NOHEX           NO
         OI    FLAGS2,X'04'    TURN ON BIT
NOHEX    EQU   *
*
* SEE IF "SELECT" WAS SPECIFIED - LIST OPTION ON IKJIDENT
*
         TM    SELNUM+6,X'80' CK. FLAG TO SEE IF PRESENT(FLG=0 IF NO)
         BZ    NOSEL          NO IT WAS NOT
         OI    FLAGS2,X'08'   TURN ON SELECT BIT
         LA    3,0            INITIALIZE COUNTER
         LA    7,SELNUM
*        LOOP TO SEE HOW MANY ENTRIES FOR GETMAIN
LOOPSEL1 LA    3,1(3)         INCR COUNTER
         L     7,8(7)         GET A(NEXT BLOCK)
         C     7,=XL4'FF000000' LAST BLOCK ?
         BNE   LOOPSEL1       NOPE
         SPACE 1
*        DO GETMAIN
         LR    10,3
         ST    3,MEMCOUNT     SAVE FOR USE BY PRINTDSX
         LA    10,2(10)       INCR. BY 2 FOR HIGHFF & LASTENTB
         MH    10,=H'12'      FOR GETMAIN
         GETMAIN R,LV=(10),SP=SP1
         ST    1,MEMPTR       SAVE ADDRESS
         SPACE 1
*        LOOP THRU ENTRIES AGAIN PLACING IN GETMAINED AREA
         LA    7,SELNUM       GET A(FIRST BLOCK)
LOOPSEL2 LH    8,4(7)         GET LENGTH
         BCTR  8,0            DECR BY 1 FOR MVC
         MVC   0(8,1),=CL8' ' INIT AREA
         L     10,0(7)        GET ADDRESS OF ENTRY
         EX    8,MVCSEL       MOVE IN NAME
         L     7,8(7)         POINT TO NEXT BLOCK
         LA    1,12(1)        INCR POINTER INTO MEMLIST
         BCT   3,LOOPSEL2
         SPACE 1
*        COMPLETE BLOCK
         MVC   0(8,1),HIGHFF     PUT IN HIGH FF'S
         MVC   12(8,1),LASTENTB  INDICATE END OF BLOCK
         B     NOSEL
MVCSEL   MVC   0(0,1),0(10)    MOVE IN ENTRY
NOSEL    EQU   *
*
*  SEE IF "NOMSG" WAS SPECIFIED, IF YES TURN ON FLAGS BIT 8.
*
         TM    NOMKEYW+1,X'01' SEE IF "NOMSG" ENTERED
         BZ    NONOM           YES
         OI    FLAGS,X'01'     TURN ON IF NOMSG REQUESTED
         MVI   NOMSG+1,X'F0'   TURN ON IF NOMSG REQUESTED
NONOM    EQU   *
         EJECT
*
*   NOW DYNAMICALLY ALLOCATE THE SYSOUT DATASET
*
*        FOR FOLLOWING SECTION OF CODE USING REGS 4,5,6+8 FOR DSECTS
*        FROM MACROS IEFZB4D0 + IEFZB4D2 (AN RB AND A PARM LIST).
*                 LENGTH = 4+20+(NX4) + N1,N2,N3,...
         LA    8,136     = 4+20+36 +  7+13+10+10+7+4+7+4+14
         GETMAIN R,LV=(8),SP=SP1
         LR    8,1
         USING S99RBP,8       ADDRESSABILITY FOR 'RBPTR' DSECT
         LA    4,S99RBPTR+4   4 BYTES BEYOND 'RBPTR'
         USING S99RB,4        ADDRESSABILITY FOR 'RB' DSECT
         ST    4,S99RBPTR     MAKE 'RBPTR' POINT TO 'RB'
         OI    S99RBPTR,S99RBPND  TURN ON HIGH ORDER BIT IN 'RBPTR'
         XC    S99RB(RBLEN),S99RB ZERO OUT 'RB' ENTIRELY
         MVI   S99RBLN,RBLEN   PUT IN LENGTH OF 'RB' IN ITS LENGTH FLD
         MVI   S99VERB,S99VRBAL  SET VERB CODE FIELD TO ALLOC FUNCTION
         LA    5,S99RB+RBLEN   POINT 20 BYTES BEYOND START OF 'RB'
         USING S99TUPL,5       ESTAB. ADDRESSABILITY FOR TEXT UNIT PTRS
         ST    5,S99TXTPP      INIT. THE TEXT PTRS. ADDRESS IN 'RB'
*
         LA    6,S99TUPL+36    POINT JUST PAST 9 TEXT UNIT PTR'S
         USING S99TUNIT,6      SET ADDRESSABILITY FOR 1ST TEXT UNIT
         ST    6,S99TUPTR      POINT 1ST TEXT UNIT PTR TO 1ST TEXT UNIT
*
* SEE IF COPIES WAS SPECIFIED
*
         TM    COPNUM+6,X'80' CK. FLAG TO SEE IF PRESENT(FLG=0 IF NO)
         BZ    NOCOP          NO IT WAS NOT - USE SYSTEM DEFAULT
         L     7,COPNUM       LOAD PTR TO COPIES FIELD
         LH    3,COPNUM+4     LOAD LENGTH OF COPIES ENTERED(1,2,OR 3)
         BCTR  3,0            DEC LENGTH BY 1 FOR MVC
         MVC   WORKZ(7),=ZL3'0' CLEAR
         LA    2,WORKZ       FOR MVC
         LA    2,2(2)         ADD 2 TO ADDR (PT TO LAST BYTE)
         SR    2,3            SUB 0,1, OR 2 DEPENDING ON # OF BYTES
         EX    3,MVCCOP        EXEC MVC
         B     CONT3
MVCCOP   MVC   0(0,2),0(7)  MOVE N CHARS (MAX 3 NUMERICS)
CONT3    PACK  WORKP(8),WORKZ(3) PACK THE 3 BYTES
         CVB   3,WORKP    GET BINARY EQUIV. -THIS IS PARM FIELD
*
         LA    7,DALCOPYS      GET KEY FOR NO COPIES
         STH   7,S99TUKEY      PUT KEY IN TEXT UNIT KEY FIELD
         LA    7,1             # OF PARMS
         STH   7,S99TUNUM      PUT # OF PARMS
         LA    7,1             LENGTH OF PARM
         STH   7,S99TULNG      PUT LENGTH OF PARM
         STC   3,S99TUPAR      FROM CVB ABOVE- STORE 1 CHAR
*
         LA    6,S99TUNIT+7    POINT JUST PAST 1ST TEXT UNIT
         LA    5,S99TUPL+4     POINT TO 2ND TUP IN LIST
         ST    6,S99TUPTR      POINT 2ND TUP TO 2ND TEXT UNIT
NOCOP    EQU   *
*
* SEE IF DEST WAS SUPPLIED
*
         TM    DESNUM+6,X'80' CK. FLAG TO SEE IF PRESENT(FLG=0 IF NO)
         BZ    NODEST         NO IT WAS NOT - FORGET IT
         LA    7,DALSUSER      GET KEY FOR DEST
         STH   7,S99TUKEY      PUT KEY IN TEXT UNIT KEY FIELD
         LA    7,1             # OF PARMS
         STH   7,S99TUNUM      PUT # OF PARMS
         LH    3,DESNUM+4     LOAD LENGTH OF ENTERED(1-7)
         STH   3,S99TULNG      PUT LENGTH
         L     7,DESNUM       LOAD PTR TO DEST FIELD
         BCTR  3,0            DEC LENGTH BY 1 FOR MVC
         EX    3,MVCDES1        EXEC MVC INSTRUCTION
         EX    3,MVCDES2
         B     CONT4
MVCDES1  MVC   S99TUPAR(0),0(7) MOVE N CHARACTERS (MAX 7 CHAR)
MVCDES2  MVC   ROUTELOC(0),0(7) MOVE
CONT4    EQU   *
*
         LA    6,S99TUNIT+13   POINT JUST PAST 2ND TEXT UNIT
         LA    5,S99TUPL+4     POINT TO 3RD TUP IN LIST
         ST    6,S99TUPTR      POINT 3RD TUP TO 3RD TEXT UNIT
         B     CONT4A
NODEST   MVC   ROUTELOC(5),=CL5'LOCAL'  IF DEST NOT SUPPLIED
CONT4A   EQU   *
*
* SEE IF FCB  WAS SUPPLIED
*
         TM    FCBNUM+6,X'80' CK. FLAG TO SEE IF PRESENT(FLG=0 IF NO)
         BZ    NOFCB          NO IT WAS NOT - FORGET IT
         OI    FLAGS2,X'01'   INDICATE CHARS/FCB SPEC
         LA    7,DALFCBIM      GET KEY FOR FCB
         STH   7,S99TUKEY      PUT KEY IN TEXT UNIT KEY FIELD
         LA    7,1             # OF PARMS
         STH   7,S99TUNUM      PUT # OF PARMS
         LH    3,FCBNUM+4     LOAD LENGTH OF ENTERED(1-4)
         STH   3,S99TULNG      PUT LENGTH
         L     7,FCBNUM       LOAD PTR TO DEST FIELD
         BCTR  3,0            DEC LENGTH BY 1 FOR MVC
         EX    3,MVCFCB         EXEC MVC INSTRUCTION
         MVC   CALLFLD(8),=CL8' ' ALSO FILL IN CALLFLD FOR CHECK
         EX    3,MVCFCB2         ROUTINE - PRINTDSY
         B     CONT4B
MVCFCB   MVC   S99TUPAR(0),0(7) MOVE N CHARACTERS (MAX 4 CHAR)
MVCFCB2  MVC   CALLFLD(0),0(7)    "  "    "
CONT4B   EQU   *
         LA    6,S99TUNIT+10   POINT JUST PAST 3RD TEXT UNIT
         LA    5,S99TUPL+4     POINT TO 4TH TUP IN LIST
         ST    6,S99TUPTR      POINT 4TH TUP TO 4TH TEXT UNIT
NOFCB    EQU   *
*
* SEE IF CHARS WAS SUPPLIED
*
         TM    CHANUM+6,X'80' CK. FLAG TO SEE IF PRESENT(FLG=0 IF NO)
         BZ    NOCHA          NO IT WAS NOT - FORGET IT
         OI    FLAGS2,X'01'   INDICATE CHARS/FCB SPEC
         LA    7,DALUCS        GET KEY FOR CHARS (ACTUALLY UCS)
         STH   7,S99TUKEY      PUT KEY IN TEXT UNIT KEY FIELD
         LA    7,1             # OF PARMS
         STH   7,S99TUNUM      PUT # OF PARMS
         LH    3,CHANUM+4     LOAD LENGTH OF ENTERED(1-4)
         STH   3,S99TULNG      PUT LENGTH
         L     7,CHANUM       LOAD PTR TO DEST FIELD
         BCTR  3,0            DEC LENGTH BY 1 FOR MVC
         EX    3,MVCCHA         EXEC MVC INSTRUCTION
         MVC   CALLFLD(8),=CL8' ' ALSO FILL IN CALLFLD FOR CHECK
         EX    3,MVCCHA2         ROUTINE - PRINTDSY
         B     CONT4C
MVCCHA   MVC   S99TUPAR(0),0(7) MOVE N CHARACTERS (MAX 4 CHAR)
MVCCHA2  MVC   CALLFLD(0),0(7)    "  "      "
CONT4C   EQU   *
*
         LA    6,S99TUNIT+10   POINT JUST PAST 4TH TEXT UNIT
         LA    5,S99TUPL+4     POINT TO 5TH TUP IN LIST
         ST    6,S99TUPTR      POINT 5TH TUP TO 5TH TEXT UNIT
NOCHA    EQU   *
*
* SEE IF FUNC WAS SUPPLIED
*
         TM    FUNNUM+6,X'80' CK. FLAG TO SEE IF PRESENT(FLG=0 IF NO)
         BZ    NOFUNC
         L     7,FUNNUM      LOAD PTR TO FUNC FIELD
         CLI   0(7),C'I'     SEE IF IT IS AN "I"
         BNE   NOFUNC        IF NOT, FORGET IT
*
         LA    7,DALFUNC       GET KEY FOR FUNC
         STH   7,S99TUKEY      PUT KEY IN TEXT UNIT KEY FIELD
         LA    7,1             # OF PARMS
         STH   7,S99TUNUM      PUT # OF PARMS
         STH   7,S99TULNG      PUT LENGTH = 1
         MVI   S99TUPAR,X'80' PARM FOR INTERPRET
*
         LA    6,S99TUNIT+7    POINT JUST PAST 5TH TEXT UNIT
         LA    5,S99TUPL+4     POINT TO 6TH TUP IN LIST
         ST    6,S99TUPTR      POINT 6TH TUP TO 6TH TEXT UNIT
NOFUNC   EQU   *
*
*  SEE IF HOLD WAS SPECIFIED
*
         TM    HOLKEYW+1,X'01' SEE IF HOLD SPECIFIED
         BZ    NOHOLD          NO
         LA    7,DALSHOLD      GET KEY FOR HOLD OPTION
         STH   7,S99TUKEY      PUT KEY IN TEXT UNIT KEY FIELD
         LA    7,0             # OF PARMS
         STH   7,S99TUNUM      PUT # OF PARMS
*
         LA    6,S99TUNIT+4    POINT JUST PAST 6TH TEXT UNIT
         LA    5,S99TUPL+4     POINT TO 7TH TUP IN LIST
         ST    6,S99TUPTR      POINT 7TH TUP TO 7TH TEXT UNIT
NOHOLD   EQU   *
         TM    ASAKEYW+1,X'01'
         BZ    NOASA
         OI    CARRIAGE,X'04'
         B     CARRNI
NOASA    TM    MCODKEYW+1,X'01'
         BZ    NOMCOD
         OI    CARRIAGE,X'02'
CARRNI   NI    FLAGS,X'BF'
NOMCOD   EQU   *
         TM    FORMKEYW+1,X'01'
         BZ    NOFORM
         LA    7,DALSFMNO
         STH   7,S99TUKEY
         LA    7,1
         STH   7,S99TUNUM
         LH    3,FORMNUM+4
         STH   3,S99TULNG
         L     7,FORMNUM
         BCTR  3,0
         EX    3,MVCFORM
         B     BASOVER
MVCFORM  MVC   S99TUPAR(0),0(7)
BASOVER  EQU   *
         LA    6,S99TUNIT+10
         LA    5,S99TUPL+4
         ST    6,S99TUPTR
NOFORM   EQU   *
         EJECT
*     1- CALL PRINTDSY VALIDITY CHECKING ROUTINE IF FCB OR CHRARS SPEC
*     2- RELEASE PARSE STORAGE
         SPACE 2
*        CHECK FOR VALID CHA OR FCB BY CALLING PRINTDSY
*        NOTE: PRINTDSY MAY CHANGE PDE FOR CLASS
         TM    FLAGS2,X'01'    FCB OR CHARS SPEC ?
         BZ    CONT5A          NO
         CALL  PRINTDSY,(IOPL,FCBNUM,CHANUM,CLANUM,DESNUM),            X
               MF=(E,CPARMS)
         LTR   15,15
         BNZ   END
CONT5A   EQU   *
         SPACE 2
*
*  SEE IF CLASS WAS SPECIFIED (THIS CODE MUST FOLLOW CALL TO PRINTDSY
*        SINCE IT MAY CHANGE CLASS).
         LA    7,DALSYSOU      GET KEY FOR SYSOUT
         STH   7,S99TUKEY      PUT KEY IN TEXT UNIT KEY FIELD
         LA    7,1             # OF PARMS
         STH   7,S99TUNUM      PUT # OF PARMS
         LA    7,1             LENGTH OF PARM
         STH   7,S99TULNG      PUT LENGTH OF PARM
         TM    CLANUM+6,X'80'  SEE IF CLASS SPECIFIED
         BZ    CLASSA          NO IT WAS NOT - USE "1"   AXC CBT
         L     7,CLANUM        LOAD PTR TO CLASS FIELD
         MVC   S99TUPAR(1),0(7) MOVE SYSOUT CLASS INTO PARM FIELD
         B     CONT5
CLASSA   MVI   S99TUPAR,C'&CLASS' DEFAULT SYSOUT CLASS IN PARM FLD
*
CONT5    LA    6,S99TUNIT+7    POINT JUST PAST 7TH TEXT UNIT
         LA    5,S99TUPL+4     POINT TO 8TH TUP IN LIST
         ST    6,S99TUPTR      POINT 8TH TUP TO 8TH TEXT UNIT
         SPACE 2
*        RELEASE PARSE STORAGE
         IKJRLSA ANSADDR
*
         DROP  9          NO LONGER NEED PARSE ANSWER AREA.
         EJECT
*
*   NOW COMPLETE DYNAMIC ALLOCATION OF SYSOUT DATASET
*
         LA    7,DALCLOSE      GET KEY FOR FREE=CLOSE OPTION
         STH   7,S99TUKEY      PUT KEY IN TEXT UNIT KEY FIELD
         LA    7,0             # OF PARMS
         STH   7,S99TUNUM      PUT KEY
*
         LA    6,S99TUNIT+4    POINT JUST PAST 8TH TEXT UNIT
         LA    5,S99TUPL+4     POINT TO 9TH TUP IN LIST
         ST    6,S99TUPTR      POINT 9TH TUP TO 9TH TEXT UNIT
*
         OI    S99TUPTR,S99TUPLN TURN ON HIGH ORDER BIT FOR LAST PTR
*
         LA    7,DALRTDDN      GET KEY FOR RETURN DDNAME
         STH   7,S99TUKEY      PUT KEY IN TEXT UNIT KEY FIELD
         LA    7,1             # OF PARMS
         STH   7,S99TUNUM      PUT KEY
         LA    7,8             LENGTH OF PARM - FIX TO 8 BYTES
         STH   7,S99TULNG
*
         LA    7,S99TULNG
         ST    7,LNGADDR1      STORE ADDR OF LENGTH FOR DCB MOD.
*
         LA    7,S99TUPAR      LOAD ADDR. OF PARM FIELD
         ST    7,DDNADDR1       TO USE LATER - DDNAME FIELD.
*
         LR    1,8       PUT RB PTR ADR IN R1 FOR DYNALLOC
         DYNALLOC        INVOKE DYNALLOC ROUTINE
         LTR   15,15     CHK DYNALLOC RETURN CODE
         BNZ   ERRDYN1
*
         DROP  4,5,6,8   NO LONGER NEED FOR THIS DYNALLOC
         EJECT
*
*       NOW DYNAMICALLY ALLOCATE THE INPUT DATASET
*
         LA    8,137       4+20+20 + 50+7+14+14+8
         GETMAIN R,LV=(8),SP=SP1
         LR    8,1
         USING S99RBP,8       ADDRESSABILITY FOR 'RBPTR' DSECT
         LA    4,S99RBPTR+4   4 BYTES BEYOND 'RBPTR'
         USING S99RB,4        ADDRESSABILITY FOR 'RB' DSECT
         ST    4,S99RBPTR     MAKE 'RBPTR' POINT TO 'RB'
         OI    S99RBPTR,S99RBPND  TURN ON HIGH ORDER BIT IN 'RBPTR'
         XC    S99RB(RBLEN),S99RB ZERO OUT 'RB' ENTIRELY
         MVI   S99RBLN,RBLEN   PUT IN LENGTH OF 'RB' IN ITS LENGTH FLD
         MVI   S99VERB,S99VRBAL  SET VERB CODE FIELD TO ALLOC FUNCTION
         LA    5,S99RB+RBLEN   POINT 20 BYTES BEYOND START OF 'RB'
         USING S99TUPL,5       ESTAB. ADDRESSABILITY FOR TEXT UNIT PTRS
         ST    5,S99TXTPP      INIT. THE TEXT PTRS. ADDRESS IN 'RB'
*
         LA    6,S99TUPL+20    POINT JUST PAST 5 TEXT UNIT PTR'S
         USING S99TUNIT,6      SET ADDRESSABILITY FOR 1ST TEXT UNIT
         ST    6,S99TUPTR      POINT 1ST TEXT UNIT PTR TO 1ST TEXT UNIT
*
         LA    7,DALDSNAM      GET KEY FOR DSNAME
         STH   7,S99TUKEY      PUT KEY IN TEXT UNIT KEY FIELD
         LA    7,1             # OF PARMS
         STH   7,S99TUNUM      PUT # OF PARMS
         LH    7,DSNLNGTH      LOAD LENGTH OF DSNAME FOR MVC
         STH   7,S99TULNG      PUT LENGTH OF PARM
         BCTR  7,0             DEC LENGTH BY 1 FOR MVC
         EX    7,MVCDSN        MOVE DSNAME INTO PARM FIELD
         B     CONT7
MVCDSN   MVC   S99TUPAR(0),DSNAME    MVC FOR EX INSTRUCTION
CONT7    EQU   *
*
         LA    6,S99TUNIT+50   POINT JUST PAST 1ST TEXT UNIT(ASSUME 50)
         LA    5,S99TUPL+4     POINT TO 2ND TUP IN LIST
         ST    6,S99TUPTR      POINT 2ND TUP TO 2ND TEXT UNIT
*
         LA    7,DALSTATS      GET KEY FOR DATASET STATUS
         STH   7,S99TUKEY      PUT KEY IN TEXT UNIT KEY FIELD
         LA    7,1             # OF PARMS
         STH   7,S99TUNUM      PUT # OF PARMS
         STH   7,S99TULNG      SET PARM LENGTH ALSO TO 1
         MVI   S99TUPAR,X'08'  INDICATE SHARE OPTION
*
         LA    6,S99TUNIT+7    POINT JUST PAST 2ND TEXT UNIT
         LA    5,S99TUPL+4     POINT TO 3RD TUP IN LIST
         ST    6,S99TUPTR      POINT 3RD TUP TO 3RD TEXT UNIT
*
         LH    3,MEMLNGTH      TEST TO SEE IF MEMBER NAME WAS SUPPLIED
         CH    3,=H'0'             IF NOT DO NOT SET UP THIS TEXT UNIT
         BE    NOMEM
         OI    FLAGS,X'10'     INDICATE THAT A MEMBER WAS SPECIFIED
         LA    7,DALMEMBR      GET KEY FOR MEMBER
         STH   7,S99TUKEY      PUT KEY IN TEXT UNIT KEY FIELD
         LA    7,1             # OF PARMS
         STH   7,S99TUNUM      PUT # OF PARMS
         STH   3,S99TULNG      PUT LENGTH OF PARM
         BCTR  3,0             SUBTRACT 1 FOR MVC
         EX    3,MVCMEM        MOVE MEMBER NAME INTO PARM FIELD
         B     CONT8
MVCMEM   MVC   S99TUPAR(0),MEMBER
*
CONT8    LA    6,S99TUNIT+14   POINT JUST PAST 3RD TEXT UNIT
         LA    5,S99TUPL+4     POINT TO 4TH TUP IN LIST
         ST    6,S99TUPTR      POINT 4TH TUP TO 4TH TEXT UNIT
*
NOMEM    EQU   *
*
         LA    7,DALRTDDN      GET KEY FOR RETURN DDNAME
         STH   7,S99TUKEY      PUT KEY IN TEXT UNIT KEY FIELD
         LA    7,1             # OF PARMS
         STH   7,S99TUNUM      PUT KEY
         LA    7,8             LENGTH OF PARM - FIX TO 8 BYTES
         STH   7,S99TULNG
*
         LA    7,S99TULNG      LOAD ADDR. OF LENGTH OF PARM
         ST    7,LNGADDR2       TO USE LATER - FOR MVC FOR DDN
*
         LA    7,S99TUPAR      LOAD ADDR. OF PARM FIELD
         ST    7,DDNADDR2       TO USE LATER - DDNAME FIELD.
*
         LA    6,S99TUNIT+14   POINT JUST PAST 4TH TEXT UNIT
         LA    5,S99TUPL+4     POINT TO 5TH TUP IN LIST
         ST    6,S99TUPTR      POINT 5TH TUP TO 5TH TEXT UNIT
*
         OI    S99TUPTR,S99TUPLN TURN ON HIGH ORDER BIT FOR LAST PTR
*
         LA    7,DALRTORG      GET KEY FOR DSORG (FOR RETURN)
         STH   7,S99TUKEY      PUT KEY IN TEXT UNIT KEY FIELD
         LA    7,1             # OF PARMS
         STH   7,S99TUNUM      PUT # OF PARMS
         LA    7,2             LOAD LENGTH
         STH   7,S99TULNG      PUT LENGTH OF PARM
         LA    7,S99TUPAR      LOAD ADDR. OF PARM FIELD
         ST    7,DSORGADR      STORE ADDR FOR USE LATER
*
         LR    1,8       PUT RB PTR ADR IN R1 FOR DYNALLOC
         DYNALLOC        INVOKE DYNALLOC ROUTINE
         LTR   15,15     CHK DYNALLOC RETURN CODE
         BNZ   ERRDYN2
*
         DROP  4,5,6,8   NO LONGER NEED REGS FOR THIS DYNALLOC
         EJECT
*
*        MOVE DDNAME RETRND BY DYNALLOC INTO DDNAME FOR SYSOUT
*
         L     2,LNGADDR1 LOAD ADDRESS OF LENGTH OF DDN FOR MVC
         LH    7,0(2)     LOAD LENGTH
         BCTR  7,0        SUBTRACT 1 FOR EX MVC
         L     3,DDNADDR1 LOAD ADDRESS OF DDNAME FIELD
         EX    7,MVCDD1
         B     CONT6
MVCDD1   MVC   DDNAME1(0),0(3) MOVE DDNAME INTO DDNAME FIELD IN DCB
CONT6    EQU   *
*
*        MOVE DDNAME RETRND BY DYNALLOC INTO DDNAME FOR INPUT
*
         L     2,LNGADDR2 LOAD ADDRESS OF LENGTH OF DDN FOR MVC
         LH    7,0(2)     LOAD LENGTH
         BCTR  7,0        SUBTRACT 1 FOR EX MVC
         L     3,DDNADDR2 LOAD ADDRESS OF DDNAME FIELD
         EX    7,MVCDD2
         B     CONT9
MVCDD2   MVC   DDNAME2(0),0(3) MOVE DDNAME INTO DDNAME FIELD IN DCB
CONT9    EQU   *
         EJECT
*
*     CALL PRINTDSX
*
* IS DATASET A PDS??   IF SO, CALL PDS PRINT ROUTINE - "PRINTDSX"
* IS A HEADING REQ. FOR A SEQDS? "   "     "      "         "
* IS A MEMBER OF A PDS SPEC.?    THEN CHK. FOR HEADING REQ.
         SPACE 2
         L     7,DSORGADR     LOAD ADDR OF DSORG
         LH    7,0(7)         LOAD DSORG PARM
         CH    7,=X'4100'     IS DSORG=PSU
         BE    SEQDS          YES
         CH    7,=X'4000'     IS DSORG=PS
         BE    SEQDS          YES
         CH    7,=X'0200'     IS DSORG=PO
         BE    PDSDS          YES
         CH    7,=X'0300'     IS DSORG=POU
         BE    PDSDS          YES
*        IF FELL THRU ABOVE TESTS, CANNOT PRINT THIS TYPE DATASET
         B     ERRDSORG
         SPACE 2
PDSDS    TM    FLAGS,X'10'    WAS A MEMBER OF A PDS SPECIFIED?
         BO    SEQDS          YES, ASSUME SEQDS  (PDS BIT NOT TRNED ON)
         OI    FLAGS,X'20'    TURN ON PDS INDICATOR BIT.
         B     CONT10         FULL PDS LISTING REQUESTED
         SPACE 2
SEQDS    TM    FLAGS,X'40'    HEADING REQUESTED?
         BZ    NOCALL         NO
CONT10   EQU   *
         SPACE 2
         CALL  PRINTDSX,(DDNAME1,DDNAME2,IOPL,DSNAME,FLAGS,ROUTELOC,   X
               MEMBER,LINESIZE,LINECNT,START,COUNT,MEMPTR,RANGES,      X
               MEMCOUNT,CARRIAGE),                                     X
               MF=(E,CPARMS)
         SPACE 2
         B     END
         SPACE 2
NOCALL   EQU   *
         EJECT
*    ALL ALLOCATIONS COMPLETED SUCCESSFULLY.
*        NOW MOVE DDNAMES INTO DCBS AND
*        OPEN FILES AND MOVE DATA TO SYSOUT.
         SPACE 1
         USING IHADCB,4
         LA    4,DSNIN
         MVC   DCBDDNAM(8),DDNAME2     MOVE  DDNAME
         SPACE 2
         OPEN  ,MF=(E,OPENIN)
         LTR   15,15      CHK RETURN CODE
         BNZ   ERROPEN1
         OI    FLAGS3,X'80'   INDICATE INPUT DCB OPEN IN CASE OF ERROR
         SPACE 2
*        WAS DCB ABEND EXIT TAKEN? IF SO - TERMINATE.
         TM    FLAGS2,X'80'
         BZ    NOABEND        NO, CONTINUE
         LA    15,12          PUT IN RC
         B     END
NOABEND  EQU   *
         SPACE 2
         MVC   TTTRECFM(1),DCBRECFM    MOVE RECFMTO TEMP STORAGE
         XI    TTTRECFM,DCBRECBR       TURN OFF "B" BIT IF ON
         MVC   TTTLRECL(2),DCBLRECL    MOVE LRECL TO TEMP STORAGE
         TM    DCBRECFM,DCBRECU CHK FOR "U" FORMAT (X'24' OFFSET)
         BO    ERRFORM           NO GOOD IF "U"
         TM    DCBRECFM,DCBRECF "F" FORMAT
         BO    FIXED             YES
         TM    DCBRECFM,DCBRECV "V" FORMAT
         BNO   ERRFORM        IF NOT - THEN ERROR
         TM    DCBRECFM,DCBRECSB SPANNED RECORDS ?
         BNO   VARIABLE       IF NOT - O.K.
         B     ERRFORM
         SPACE 2
* FOLLOWING CODE (1) SETS BLKSIZE=LRECL FOR F/FB
*             OR (2) SETS BLKSIZE=LRECL+4 FOR V/VB
* MUST CHECK FOR LRECL=0
FIXED    LH    7,DCBLRECL  LOAD LRECL INTO R7
         LTR   7,7         SEE IF ZERO.
         BNZ   FCONT1
         MVC   TTTBLKSI(2),DCBBLKSI IF LRECL IS 0 USE BLKSIZE
         B     OUTDCB
FCONT1   MVC   TTTBLKSI(2),DCBLRECL USE LRECL FOR BLKSIZE
         B     OUTDCB
VARIABLE LH    7,DCBLRECL  LOAD LRECL INTO R7
         LTR   7,7         SEE IF ZERO.
         BNZ   VCONT1
         MVC   TTTBLKSI(2),DCBBLKSI IF LRECL IS 0 USE BLKSIZE
         B     OUTDCB
VCONT1   LA    7,4(7)      INCR LRECL BY 4 FOR BLKSIZE
         STH   7,TTTBLKSI  STORE BLKSIZE IN TEMP STORAGE
         SPACE 2
*   MOVE DDNAME,RECFM,LRECL + BLKSIZE INTO DSOUT DCB
OUTDCB   LA    4,DSNOUT   STILL USING 4 BUT NOW POINT TO DCBOUT
         MVC   DCBDDNAM(8),DDNAME1     MOVE  DDNAME
         MVC   DCBRECFM(1),TTTRECFM    MOVE RECFM,LRECL,BLKSIZE
         MVC   DCBLRECL(2),TTTLRECL    TO OUTPUT DCB FROM TEMP
         MVC   DCBBLKSI(2),TTTBLKSI    STORAGE
         OC    DCBRECFM(1),CARRIAGE
         DROP  4     NO LONGER NEED IHADCB
         SPACE 2
*   NOW OPEN DSNOUT WITH LRECL,RECFM,+BLKSIZE FROM DSNIN
         OPEN  ,MF=(E,OPENOUT)
         LTR   15,15      CHK RETURN CODE
         BNZ   ERROPEN2
         OI    FLAGS3,X'40'   INDICATE OUTPUT DCB OPEN IN CASE OF ERROR
         EJECT
*        PROCESS INPUT DATASET
         SPACE 1
         SR    3,3            WILL USE TO COUNT RECORDS
         SPACE 1
*        LOOP THRU DATASET
GETLOOP  GET   DSNIN          GET RECORDS IN LOCATE MODE
         LR    0,1            FOR PUT
         SPACE 1
*        CHECK IF START OPTION SPEC.
         TM    FLAGS2,X'20'  SPEC ?
         BZ    CONT11        NO
         C     3,START
         BL    GETLOOP       DO NOT START YET
         XI    FLAGS2,X'20'  TURN OFF START OPTION FOR NEXT TIME THRU
         SR    3,3           RESET R3 IN CASE COUNT OPTION SPEC
CONT11   EQU   *
         SPACE 1
*        CHECK IF COUNT OPTION SPEC.
         TM    FLAGS2,X'40'
         BZ    CONT12        NOT SPEC
         C     3,COUNT       IF ALL PRINTED,
         BE    EODAD         SIMULATE EODAD
CONT12   EQU   *
         SPACE 1
*        PUT RECORD
         PUT   DSNOUT,(0)
         LA    3,1(3)         INCR COUNT OF RECORDS
         B     GETLOOP
         EJECT
*        EODAD ROUTINE
         SPACE 1
EODAD    CLOSE ,MF=(E,CLOSEB)
         LTR   15,15      CHK RETURN CODE
         BNZ   ERRCLOSE
         SPACE 1
NOMSG    NOP   BASFSR
         CVD   3,WORKP     COUNT OF RECORDS
         LA    1,SUBMSG+7  IN CASE EDMK DOESNT LOAD R1 (LT.10)
         EDMK  SUBMSG(8),WORKP+4 LOW 4 DIGITS WILL SUFFICE
*        FOR FOLLOWING MVC USE FIRST SIGNIFICANT DIGIT FROM EDMK
         MVC   PUTTEXT(70),0(1)  MOVE MESSAGE FOR PUTLINE
         PUTLINE MF=(E,IOPL)
         SPACE 2
BASFSR   SR    15,15          SET RC
*        ENTRY POINT FOR ERROR
END      EQU   *
* NOTE: NEXT INSTRUCTION DESTROYS ADDRESABILITY TO DSECT1
         L     13,SAVEAREA+4  POINT TO OLD SAVEAREA
         LR    8,15           SAVE RC (FREEMAIN CHANGES)
         FREEMAIN R,SP=SP1    FREE ALL
         LR    15,8
         RETURN (14,12),RC=(15)
*
         EJECT
*        DCB ERROR EXIT (NO ABEND IF MEMBER OF PDS SPEC. WRONG)
         SPACE 1
DCBERRX  LR    7,13           USE 7 FOR USING FOR DSECT1 (NOTE: R13
         USING DSECT1,7           IS STILL VALID IN EXIT) ..
         DROP  13             TEMPORARILY DROP R13
         LA    13,DCBSV       MUST PROVIDE OWN SAVE AREA FOR PUTLINE
         ST    14,DCBSV14     SAVE 14 FOR RETURN TO CONTROL PGM
         CLC   0(3,1),=X'013018' CC=013 + RC=018 (MEMBER NOT THERE)?
         BNE   OTHERABD       NO
         SPACE 1
         MVI   3(1),X'04'      INDICATE NO ABEND
         MVC   PUTTEXT,ERRMSGA MEMBER OF A PDS NOT THERE
         B     TPUTX
         SPACE 2
OTHERABD MVC   PUTTEXT,ERRMSG3 PUT OPEN ERROR MSG + CONT WITH ABEND.
         SPACE 2
TPUTX    PUTLINE MF=(E,IOPL)
         SPACE 2
         OI    FLAGS2,X'80'   INDICATE ABEND EXIT WAS TAKEN
         L     14,DCBSV14
         BR    14
         SPACE 2
         DROP  7              USE R13 AGAIN
         USING DSECT1,13           FOR DSECT1
         EJECT
*        ERROR MESSAGES
         SPACE 1
ERRPARSE MVC   PUTTEXT,ERRMSG0
         B     TPUTIT
ERROPEN1 MVC   PUTTEXT,ERRMSG1
         B     TPUTIT
ERROPEN2 MVC   PUTTEXT,ERRMSG2
         B     TPUTIT
ERRCLOSE MVC   PUTTEXT,ERRMSG3
         B     TPUTIT
ERRDYN1  MVC   PUTTEXT,ERRMSG4
         B     TPUTIT
ERRDYN2  MVC   PUTTEXT,ERRMSG5
         USING S99RB,4 WAS DROPPED BUT IS STILL VALID ADDRESS.
*BELOW WILL GIVE EXACT RETURN CODE FROM DYNALLOC
         LH    7,S99ERROR LOAD R7 WITH ANY POSS. ERROR CODE
         CH    7,=X'1708' LOCATE ERROR
         BNE   NOLOCERR
         MVC   PUTTEXT,ERRMSG6
NOLOCERR CH    7,=X'0210' DATASET ALLOCTED ELSEWHERE
         BNE   NOTALLOC
         MVC   PUTTEXT,ERRMSG7
NOTALLOC CH    7,=X'0218' SPECIFIED VOLUME NOT MOUNTED
         BNE   TPUTIT
         MVC   PUTTEXT,ERRMSG8
         B     TPUTIT
ERRFORM  MVC   PUTTEXT,ERRMSG9  RECFM OF INPUT IS "VS" OR "U"
         B     TPUTIT
ERRDSORG MVC   PUTTEXT,ERRMSG10 DSORG IS NOT PS/PSU/PO/POU
         B     TPUTIT
         SPACE 2
TPUTIT   PUTLINE MF=(E,IOPL)
         SPACE 2
*        CLOSE ANY OPEN DCBS WITH FREE OPTION
         TM    FLAGS3,X'80'   INPUT DCB OPEN ?
         BZ    NO1            NO
         MVC   CLOSERR(4),CLOSERR2
         LA    6,DSNIN
         BAL   7,CLOSEX
NO1      TM    FLAGS3,X'40'  OUTPUT DCB OPEN ?
         BZ    NO2            NO
         MVC   CLOSERR(4),CLOSERR2
         LA    6,DSNOUT
         BAL   7,CLOSEX
NO2      B     CONTERR
         SPACE 1
CLOSEX   CLOSE ((6),FREE),MF=(E,CLOSERR)
         BR    7              RETURN TO INLINE CODE
         SPACE 2
CONTERR  LA    15,12          SET RC
         B     END
         EJECT
*
*   SYNAD ROUTINE FOR INPUT DATASET
         SPACE 1
SYNAD    SYNADAF ACSMETH=QSAM
         MVC   PUTMSG(124),SYNMSG  MOVE HDR+MSG TO PUTMSG
         MVC   PUTTEXT+38(70),50(1)
         SPACE 2
         PUTLINE MF=(E,IOPL)
         SPACE 2
         SYNADRLS
         SPACE 2
         CLOSE ,MF=(E,CLOSEB)
         SPACE 2
*        RETURN TO TMP TO AVOID ABEND.
         L     13,SAVEAREA+4
         RETURN (14,12),RC=12
         SPACE 3
SYNMSG   DC    H'120' LENGTH OF OUTPUT LINE FOR PUTLINE
         DC    H'0'  RESERVED
SYNTEXT  DC    CL120'I/O ERROR OCCURED WITH INPUT DATASET, ' 38
*                    12345678901234567890123456789012345678901234567890
*
         EJECT
*        STORAGE AREAS
ERRMSGA  DC    CL70'ERROR - MEMBER SPECIFIED NOT IN PDS'
ERRMSG0  DC    CL70'ERROR IN SPECIFICATION OF COMMAND "PRINTDS"'
ERRMSG1  DC    CL70' OPEN ERROR - INPUT DATASET'
ERRMSG2  DC    CL70' OPEN ERROR - SYSOUT DATASET'
ERRMSG3  DC    CL70' CLOSE ERROR'
ERRMSG4  DC    CL70'ERROR WITH DYNAMIC ALLOCATION OF SYSOUT DATASET'
ERRMSG5  DC    CL70'ERROR WITH DYNAMIC ALLOCATION OF INPUT DATASET'
ERRMSG6  DC    CL70'INPUT DATASET NOT IN CATALOG - REQUEST CANCELLED'
ERRMSG7  DC    CL70'DATASET ALLOCATED ELSEWHERE - REQUEST CANCELLED'
ERRMSG8  DC    CL70'VOLUME NOT MOUNTED - REQUEST CANCELLED'
ERRMSG9  DC    CL70'ERROR - ONLY F/FB/FBA/V/VB/VBA RECFM ALLOWED'
ERRMSG10 DC    CL70'ERROR - ONLY PS/PSU/PO/POU DSORG ALLOWED'
HIGHFF   DC    8XL1'FF'
LASTENTB DC    7XL1'FF',XL1'FE'
         SPACE 2
         LTORG
         EJECT
* DEFINE CONSTANTS THAT MUST BE INIT.
         SPACE 1
SUBMSG2  DC    XL8'4020202020202120'
         DC    CL70' LINES ROUTED' 70 SINCE BLNKS IGNORD
PUTMSG2  DC    H'74' LENGTH OF OUTPUT LINE FOR PUTLINE
         DC    H'0'  RESERVED
         SPACE 3
* LIST FORM OF OPEN & CLOSE MACROS
         SPACE 1
OPENIN2  OPEN  (,INPUT),MF=L
         SPACE 1
OPENOUT2 OPEN  (,OUTPUT),MF=L
         SPACE 1
CLOSEB2  CLOSE (,,,),MF=L     FOR NORMAL CLOSE OF INPUT & OUTPUT DCBS
         SPACE 1
CLOSERR2 CLOSE (,),MF=L       FOR CLOSE OF INPUT OR OUTPUT DCB IF ERROR
         SPACE 3
*   PUTLINE PARAMETER LIST
         SPACE 1
PUTLIST2 PUTLINE OUTPUT=(,TERM,SINGLE,DATA),                           X
               TERMPUT=(EDIT,WAIT,NOHOLD,BREAKIN),MF=L
PUTLISTL EQU   *-PUTLIST2
         EJECT
         PRINT NOGEN
*   OUTPUT DCB - QSAM
*
DSNOUT2  DCB   MACRF=(PM),DSORG=PS,BUFNO=1
DSNOUTL  EQU   *-DSNOUT2
         SPACE 3
*    INPUT DCB - QSAM
*
         DS    0F
EXLST    DC    X'91',AL3(DCBERRX) INDICATE LAST ENTRY
         SPACE 1
DSNIN2   DCB   MACRF=(GL),EODAD=EODAD,DSORG=PS,SYNAD=SYNAD,            X
               EROPT=ABE,OPTCD=C,BUFNO=5,EXLST=EXLST
DSNINL   EQU   *-DSNIN2
* NOTE: WITH OPTCD=C THE SYSTEM CHANGES EROPT=SKP TO EROPT=ACC.
*
         EJECT
DSECT1   DSECT
         SPACE 1
*   DSECT FOR REENTERABILITY
         SPACE 2
SAVEAREA DS    18F
         SPACE 2
* FLAGS + FLAGS2 + FLAGS3 MUST BE IN FOLLOWING ORDER.
         SPACE 1
FLAGS    DS    X '00' BIT 0 = ON IF NEW PAGE FOR EACH MEMBER.
*                         1 = ON IF HEADING REQUESTED FOR SEQDS.
*  THIS BYTE IS PASSED    2 = ON IF DATASET IS A PDS
*  TO "PRINTDSX"          3 = ON IF A MEMBER OF A PDS IS TO BE PRINTED.
*                         4 = ON IF DATASET IS "F" RECFM(PRINTDSX)
*                         5 = SWITCH FOR BUFFER (PRINTDSX CSECT)
*                         6 = ON IF PDS INDEX IS TO BE PRODUCED
*                         7 = ON IF NOMSG OPTION FOR PDS
FLAGS2   DS    X '00' BIT 0 = ON IF DCB ABEND EXIT TAKEN
*                         1 = ON IF COUNT OPTION SPECIFIED
*  THIS BYTE IS PASSED    2 = ON IF START OPTION SPECIFIED
*  TO "PRINTDSX"          3 = ON IF RANGE OPTION SPECIFIED
*                         4 = ON IF SELECT OPTION SPECIFIED
*                         5 = ON IF HEX OPTION SPECIFIED
*                         6 = START OPTION SWITCH (PRINTDSX ONLY)
*                         7 = FCB OR CHARS SPECIFIED
FLAGS3   DS    X '00' BIT 0 = INPUT DCB OPEN          ( PRINTDSX USES +
*                         1 = OUTPUT DCB OPEN            DIFFERENTLY )
*  THIS BYTE IS PASSED    2 = (USED BY PRINTDSX ONLY)
*  TO "PRINTDSX"          3 = RESERVED
*                         4 =    "
*                         5 =    "
*                         6 =    "
*                         7 =    "
         SPACE 2
ECBPPL   DS    F '0'
ECBPUT   DS    F '0'
MEMCOUNT DS    F '0'     IF SELECT OPTION SPECIFIED.
MEMLNGTH DS    H '0'     SET DEFAULT TO USE IF NOT SUPPLIED
LINESIZE DS    H '132'=DEFAULT
LINECNT  DS    H '60' =DEFAULT
IOPL     DS    A          UPT=      FOR
         DS    A          ECT=       PUTLINE
         DS    A (ECBPUT)  ECB=
         DS    A (PUTLIST) PARM=
* FOLLOWING 68 CHARS MUST BE IN THIS ORDER SINCE MVC USED TO INIT.Q
DDNAME1  DS    CL8 ' '
DDNAME2  DS    CL8 ' '
DSNAME   DS    CL44 ' '
MEMBER   DS    CL8 ' '
CALLFLD  DS    CL8
SUBMSG   DS    XL8
         DS    CL70
ROUTELOC EQU   SUBMSG+22
PUTMSG   DS    H     LENGTH OF OUTPUT LINE FOR PUTLINE
         DS    H
PUTTEXT  DS    CL70,CL50  ALLOW 50 EXTRA BYTES IF SYNAD USES THIS AREA
TABADDR  DS    V
         DS    0D   ALIGN
WORKP    DS    PL8
WORKZ    DS    ZL3
WORKZ2   DS    ZL7
CARRIAGE DS    X
COUNT    DS    F        FOR "COUNT" OPTION
START    DS    F        FOR "START" OPTION
RANGES   DS    2CL8     FOR "RANGE" OPTION
MEMPTR   DS    A        FOR "SELECT" OPTION
ANSADDR  DS    A        PARSE WILL RETURN ADDR OF PDL HERE
CPPLADDR DS    A        ADDR OF CPPL AS GIVEN TO CP IN R1
TTTRECFM DS    X    TEMP
TTTLRECL DS    H     STORAGE
TTTBLKSI DS    H       FOR LRECL,BLKSIZE+RECFM WHEN MVC BETWEEN DCBS
DSORGADR DS    A
DDNADDR1 DS    A
DDNADDR2 DS    A
LNGADDR1 DS    A
LNGADDR2 DS    A
DSNLNGTH DS    H
DCBSV    DS    18F     SPECIAL SAVEAREA FOR DCB EXIT
DCBSV14  DS    F                        AND FOR R14
         DS    0D
PPLAREA  DS    CL28    AREA FOR PPL
CPARMS   DS    15F            FOR CALL PARM LIST
DSNIN    DS    0F,(DSNINL)CL1  FOR INPUT DCB
DSNOUT   DS    0F,(DSNOUTL)CL1 FOR OUTPUT DCB
PUTLIST  DS    0F,(PUTLISTL)CL1 FOR PUTLIST - LIST FORM
OPENIN   DS    F              FOR LIST FOR OPEN MACRO
OPENOUT  DS    F               "   "    "   "    "
CLOSEB   DS    2F              "   "    "  CLOSE "
CLOSERR  DS    F               "   "    "  CLOSE "
         SPACE 2
DLENGTH  EQU   *-DSECT1
         EJECT
PRINTDS  CSECT
*  SETUP DSECT - "IKJPARMD"  AND CSECT -"PARMTAB" FOR PDE'S
         SPACE 2
PARMTAB  IKJPARM
         SPACE 2
DSNPDE   IKJPOSIT DSNAME,PROMPT='DATA SET NAME',USID
         SPACE 2
COPKEYW  IKJKEYWD
         SPACE 1
         IKJNAME 'COPIES',SUBFLD=COPSUB
         SPACE 2
LINKEYW  IKJKEYWD
         SPACE 1
         IKJNAME 'LINESIZE',SUBFLD=LINSUB
         SPACE 2
LCCKEYW  IKJKEYWD
         SPACE 1
         IKJNAME 'LINECOUNT',SUBFLD=LCCSUB
         SPACE 2
FCBKEYW  IKJKEYWD
         SPACE 1
         IKJNAME 'FCB',SUBFLD=FCBSUB
         SPACE 2
CHAKEYW  IKJKEYWD
         SPACE 1
         IKJNAME 'CHARS',SUBFLD=CHASUB
FORMKEYW IKJKEYWD
         IKJNAME 'FORMS',SUBFLD=FORMSUB
         SPACE 2
DESKEYW  IKJKEYWD
         SPACE 1
         IKJNAME 'DEST',SUBFLD=DESSUB,ALIAS='ROUTE'
         SPACE 2
CLAKEYW  IKJKEYWD
         SPACE 1
         IKJNAME 'CLASS',SUBFLD=CLASUB,ALIAS='SYSOUT'
         SPACE 2
FUNKEYW  IKJKEYWD
         SPACE 1
         IKJNAME 'FUNC',SUBFLD=FUNSUB
         SPACE 2
NOPKEYW  IKJKEYWD
         SPACE 1
         IKJNAME 'NOPAGE'
         SPACE 1
         IKJNAME 'PAGE'
         SPACE 2
NOHKEYW  IKJKEYWD
         SPACE 1
         IKJNAME 'NOHEADING'
         SPACE 1
         IKJNAME 'HEADING'
         SPACE 2
NOIKEYW  IKJKEYWD
         SPACE 1
         IKJNAME 'NOINDEX'
         SPACE 1
         IKJNAME 'INDEX'
         SPACE 2
NOMKEYW  IKJKEYWD
         SPACE 1
         IKJNAME 'NOMESSAGES',ALIAS='NOMSG'
         SPACE 2
HEXKEYW  IKJKEYWD
         SPACE 1
         IKJNAME 'HEX'
         SPACE 2
HOLKEYW  IKJKEYWD
         SPACE 1
         IKJNAME 'HOLD'
         SPACE 2
RANKEYW  IKJKEYWD
         SPACE 1
         IKJNAME 'RANGE',SUBFLD=RANSUB
         SPACE 2
SELKEYW  IKJKEYWD
         SPACE 1
         IKJNAME 'SELECT',SUBFLD=SELSUB
         SPACE 2
COUKEYW  IKJKEYWD
         SPACE 1
         IKJNAME 'COUNT',SUBFLD=COUSUB
         SPACE 2
STAKEYW  IKJKEYWD
         SPACE 1
         IKJNAME 'START',SUBFLD=STASUB
ASAKEYW  IKJKEYWD
         IKJNAME 'ASA'
MCODKEYW IKJKEYWD
         IKJNAME 'MCODE'
         EJECT
COPSUB   IKJSUBF
         SPACE 1
COPNUM   IKJIDENT 'NUMBER',FIRST=NUMERIC,OTHER=NUMERIC,                X
               PROMPT='COPIES',MAXLNTH=3
         SPACE 2
LINSUB   IKJSUBF
         SPACE 1
LINNUM   IKJIDENT 'NUMBER',FIRST=NUMERIC,OTHER=NUMERIC,                X
               PROMPT='LINESIZE',MAXLNTH=3
         SPACE 2
LCCSUB   IKJSUBF
         SPACE 1
LCCNUM   IKJIDENT 'NUMBER',FIRST=NUMERIC,OTHER=NUMERIC,                X
               PROMPT='LINECOUNT',MAXLNTH=5
         SPACE 2
FCBSUB   IKJSUBF
         SPACE 1
FCBNUM   IKJIDENT 'CHARACTER',FIRST=ALPHANUM,OTHER=ALPHANUM,           X
               PROMPT='FCB',MAXLNTH=4
         SPACE 2
CHASUB   IKJSUBF
         SPACE 1
CHANUM   IKJIDENT 'CHARACTER',FIRST=ALPHANUM,OTHER=ALPHANUM,           X
               PROMPT='CHARS',MAXLNTH=4
FORMSUB  IKJSUBF
FORMNUM  IKJIDENT 'FORMS',FIRST=ALPHANUM,OTHER=ALPHANUM,               *
               PROMPT='FORMS',MAXLNTH=4
         SPACE 2
DESSUB   IKJSUBF
         SPACE 1
DESNUM   IKJIDENT 'CHARACTER',FIRST=ALPHANUM,OTHER=ALPHANUM,           X
               PROMPT='DEST',MAXLNTH=7
         SPACE 2
CLASUB   IKJSUBF
         SPACE 1
CLANUM   IKJIDENT 'CHARACTER',FIRST=NONATNUM,                          X
               PROMPT='CLASS',MAXLNTH=1
         SPACE 2
FUNSUB   IKJSUBF
         SPACE 1
FUNNUM   IKJIDENT 'CHARACTER',FIRST=ALPHA,                             X
               PROMPT='FUNC',MAXLNTH=1
         SPACE 2
RANSUB   IKJSUBF
         SPACE 1
*        RANGE OPTION SPECIFIED ON IKJIDENT
RANNUM   IKJIDENT 'CHARACTER',FIRST=ALPHA,OTHER=ALPHANUM,RANGE,        X
               PROMPT='RANGE',MAXLNTH=8
         SPACE 2
SELSUB   IKJSUBF
         SPACE 1
*        LIST OPTION SPECIFIED ON IKJIDENT
SELNUM   IKJIDENT 'CHARACTER',FIRST=ALPHA,OTHER=ALPHANUM,LIST,         X
               PROMPT='MEMBER',MAXLNTH=8
         SPACE 2
COUSUB   IKJSUBF
         SPACE 1
COUNUM   IKJIDENT 'NUMBER',FIRST=NUMERIC,OTHER=NUMERIC,                X
               PROMPT='COUNT',MAXLNTH=7
         SPACE 2
STASUB   IKJSUBF
         SPACE 1
STANUM   IKJIDENT 'NUMBER',FIRST=NUMERIC,OTHER=NUMERIC,                X
               PROMPT='START',MAXLNTH=7
         SPACE 2
         IKJENDP
*
         EJECT
         PRINT NOGEN
         DCBD DEVD=DA,DSORG=PS
         PRINT GEN
         SPACE 3
         IKJCPPL
         SPACE 3
         IKJPPL
         EJECT
         IEFZB4D0
RBLEN    EQU   (S99RBEND-S99RB)
         EJECT
         IEFZB4D2
         END   PRINTDS
