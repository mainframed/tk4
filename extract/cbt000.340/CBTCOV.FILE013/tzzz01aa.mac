 During Systems Generation to add device types the normal I/O
 gen process copies most I/O related modules to the new system, even
 though they may already be there from a previous I/O or full gen.
 If the gen has no new device types, this is redundant and will lose
 a fair percentage of local mods.  The 'MINIGEN' is a technique
 which causes ONLY the assembled  modules generated by SYSGEN to be
 re-assembled and re-linked.  It requires approximately 10% of the
 time required for an I/O gen.  It does not lose local mods (except
 for UCB zaps, which this process replaces).  It is useful for
 building multiple MVS systems from one base.  It is useful in
 converting to new DASD.

 The MINIGEN technique can provide a productivity gain in large
 installations where a lot of IOGEN activity exists and/or multiple
 CPUs, MVS systems, user modifications, and environments are being
 supported by a single systems programming staff.

 MINIGEN should be considered for these reasons also:

   - IOGEN re-copies a large number of device support modules
     thus using additional system resources.
   - IOGEN will lose a significant number of local mods(exits,
     tables, etc) and unACCEPTed PTFs/APARs.
   - IOGEN may  abend and have to be manually restarted if a PDS
     fills up.
   - The many jobsteps created by IOGEN can be tedious to check.
   - A full set of DLIBs is required for an iogen.

 The following considerations will prevent the use of the MINIGEN
 technique:
   - New device types can not be added.
   - New console device types can not be added.
   - Only the CHANNEL, IODEVICE, UNIT NAME, and
     CONSOLE macros can be changed during MINIGEN.
 If either of these requirements exist, a complete iogen must be done.

 The MINIGEN process is designed to reassemble and relink only
 those modules whose source code is generated by sysgen.  No DLIB
 modules are recopied/relinked.  This improves performance and
 prevents the loss of most local mods and all uACCEPTed
 maintenance.  It has been experienced that the local mods which do
 get lost by MINIGEN are the ones (like UCB zaps) that should have
 been put in with a MINIGEN in the first place.  Since a great
 deal less is copied/linked, the probability of a PDS filling up
 is much lower, and if it does, the RETRY capability of SMP4 will
 compress it and try again.  Since MINIGEN consists of only about
 10 steps, it is much simpler to check.  The only DLIB
 datasets used are 'SYS1.AGENLIB' and 'SYS1.AMODGEN'; therefore,
 MINIGEN can be done using only the system residence volume if a
 copy of those two datasets is maintained on that volume.

 The MINIGEN job stream example listed here is for MVS 3.8 with SMP 4.
 Minigens on 3.7 with SMP 3 and on VS1 with SMP4 can be done.

 The following describes the various steps in a MINIGEN:

   - The first step (STAGE1) runs a normal IOGEN stage 1
     and places the output in dataset 'SYS1.STAGE2'.
   - The next step (IEHPGM) is to circumvent a problem.  It is not
     clear whether SYSGEN or NIP causes the problem.  The APAR was
     closed with a change to the SYSGEN manual (refer to the
     console macro in SYSGEN manual).  The problem is as follows:
     Assume you have 2 consoles 301 and 302.  SYS1.LPALIB
     will contain load module DCM301 with an alias of DCM302.
     Suppose you now change your consoles to be 300 and 301 and run
     an IOGEN or MINIGEN.  You will now have DCM300 with an alias
     of DCM301 which in turn has an alias of DCM302.  This double
     aliasing will cause NIP to go into a 3 instruction loop in
     IEAVNP05.  The circumvention is to delete all DCMxxx modules
     from LPALIB prior to doing a gen.  Step IEHPGM does this.
     The generation of the SCRATCH card could be automated.
   - Step GENER creates a dummy macro applied by the MINIGEN
     function.
   - Step SMP performs the actual minigen.  The UCLIN is to
     remove any traces of the previous minigen. The module list
     shown here is installation dependent on SYSGEN options chosen
     and is given as an example.  It should refer to all modules
     for which there is an EXEC ASMS card in the stage 2 deck.
     The generation of the ++FUNCTION could be automated with a
     program that reads the stage 2 deck and generates another
     module name each time it hits an EXEC ASMS card.

 //SMP4MVS  JOB ...
 //STAGE1 EXEC PGM=IEV90,PARM='DECK,NOLOAD,LINECOUNT(55)',
 //             REGION=1024K
 //*******************************************************************
 //**** RUN THE STAGE 2 ASSEMBLY                                   ***
 //*******************************************************************
 //SYSLIB    DD DSN=SYS1.SMPMTS,DISP=SHR,
 //             UNIT=3330-1,VOL=SER=SYSRES,
 //             DCB=BLKSIZE=12960
 //          DD DSN=SYS1.AGENLIB,DISP=SHR,
 //             UNIT=3330-1,VOL=SER=SYSRES
 //          DD DSN=SYS1.AMODGEN,DISP=SHR,
 //             UNIT=3330-1,VOL=SER=SYSRES
 //SYSPUNCH  DD DSNAME=SYS1.STAGE2,DISP=(OLD,PASS),
 //             UNIT=SYSDA,VOL=SER=SYSRES,
 //             DCB=(RECFM=FB,LRECL=80,BLKSIZE=12960)
 //SYSPRINT  DD SYSOUT=*
 //SYSUT1    DD UNIT=SYSDA,SPACE=(CYL,(20,2))
 //SYSUT2    DD UNIT=SYSDA,SPACE=(CYL,(20,2))
 //SYSUT3    DD UNIT=SYSDA,SPACE=(CYL,(20,2))
 //SYSIN     DD *
 STAGE 1 DECK GOES HERE
 /*
 //*
 //IEHPGM  EXEC PGM=IEHPROGM,COND=(0,NE)
 //*******************************************************************
 //**** SCRATCH ALL DCM MODULES FROM LPALIB                         **
 //*******************************************************************
 //SYSPRINT  DD SYSOUT=*
 //SYSRES    DD DSNAME=SYS1.LPALIB,DISP=OLD,
 //             UNIT=3330-1,VOL=SER=SYSRES
 //SYSIN     DD *
  SCRATCH DSNAME=SYS1.LPALIB,VOL=3330-1=SYSRES,MEMBER=DCM301
  SCRATCH DSNAME=SYS1.LPALIB,VOL=3330-1=SYSRES,MEMBER=DCM302
 //*
 //GENER   EXEC PGM=IEBGENER
 //*******************************************************************
 //**** USE IEBGENER TO BUILD THE PHONEY MACRO INSTALLED BY MINIGEN***
 //*******************************************************************
 //SYSPRINT  DD SYSOUT=*
 //SYSIN     DD DUMMY
 //SYSUT2    DD DSNAME=&DUMMY(MINIMAC0),DISP=(NEW,PASS),
 //             UNIT=SYSDA,SPACE=(TRK,(1,1,1)),
 //             DCB=(RECFM=FB,LRECL=80,BLKSIZE=3120)
 //SYSUT1    DD *
          MACRO
          MINIMAC0
          NOP
          MEND
 /*
 //*
 //SMP EXEC IPOSMP4R,RES=SYSRES,COND=(0,NE)
 //*******************************************************************
 //**** USE SMP TO INSTALL THE MINIGEN                             ***
 //*******************************************************************
 //SYSIN DD *
 UCLIN CDS DIS(WRITE).
   DEL MAC(IEECDCM).
   DEL MAC(IEECRDCM).
   DEL SYSMOD(MINIGEN).
   ENDUCL.
 RESETRC.
 UCLIN PTS.
   DEL SYSMOD(MINIGEN).
   ENDUCL.
 RESETRC.
 JCLIN DIS(WRITE).
 RECEIVE SELECT(MINIGEN).
 APPLY SELECT(MINIGEN) CHECK DIS(WRITE) BYPASS(ID).
 APPLY SELECT(MINIGEN) DIS(WRITE) BYPASS(ID).
 /*
 //SMPPTFIN  DD *
 ++ FUNCTION(MINIGEN).
 ++ VER(Z038).
 ++ VER(Z037).
 ++ MAC (MINIMAC0) DISTLIB(AMODGEN) TXLIB(DUMMYMAC)
     ASSEM(DCM300,
           DCM301,
           IEAASU00,
           IEASVC00,
           IEAVBK00,
           IECZDTAB,
           IEECVH1,
           IEECVSUB,
           IEECVUCM,
           IEFAQTOP,
           IFBCTA00,
           IEFBDA,
           IFGDEBCK,
           IEEMB850,
           IEFJESNM,
           MSTRJCL,
           IEFSDPPT,
           IEFDEVPT,
           IEFEDTTB,
           IEFSG0PT,
           IEFYRCDS,
           IEFWMAS1,
           IEFWMSKA,
           IKJEBEIN,
           IKJEBEPD,
           IKJEFLPO),
 //SMPJCLIN  DD DSNAME=SYS1.STAGE2,DISP=(SHR,KEEP),
 //             UNIT=3330-1,VOL=SER=SYSRES
 //DUMMYMAC  DD DSNAME=&DUMMY,DISP=(OLD,DELETE)
