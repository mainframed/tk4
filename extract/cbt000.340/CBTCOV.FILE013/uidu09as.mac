         TITLE 'BUILD GENERATION DATA GROUP FOR OS CATALOG   -MVS'
MVSBLDG  CSECT
*********************************************************************
*                                                                   *
*   THIS MODULE CREATES GENERATION DATA GROUPS FOR OS CATALOGS      *
*   UNDER MVS. IT ALSO MODIFIES AND DELETES EXISTING GDG INDICES.   *
*                                                                   *
*********************************************************************
         SPACE
         SAVE  (14,12)        SAVE REGISTERS
         BALR  R3,0           ESTABLISH BASE REGISTERS
         USING *,3,4,5
NA0      LM    R4,R5,KBAS
         B     NA1
KBAS     DC    A(NA0+4096,NA0+2*4096)
NA1      LA    R12,SAVE       LOAD ADDR OF OWN SAVE AREA
         ST    R12,8(R13)     AND STORE IT INTO CALLER'S S.A.
         ST    R13,4(R12)     STORE ADDR OF CALLER'S S.A. INTO OWN S.A.
         LR    R13,R12        LOAD ADDR OF OWN SAVE AREA TO REG 13
         XC    INDADDR,INDADDR   CLEAR POINTER TO INDEX AREA
         LA    R8,INDADDR     ADDR OF INDEX AREA PTR TO CURRENT PTR
         ST    R8,LINDADDR
         XC    RC,RC          CLEAR RETURN CODE
         XC    ICE,ICE        CLEAR INDEX CONTROL ENTRY FIELD
         XC    SWITCH,SWITCH  CLEAR INDICATOR BYTE
         XC    VICEADDR,VICEADDR  CLEAR VICE SAVE AREA POINTER
         XC    ICEADDR,ICEADDR  CLEAR ICE SAVE AREA POINTER
         ST    R1,REG1        SAVE PARM REG
         OPEN  (CTLG,UPDAT)
*
*     GET PARAMETERS
*
         L     R7,REG1        LOAD START ADDR
         LA    R9,PARMTAB     LOAD ADDR OF PARAMETER TABLE
NA2      EQU   *
         LH    R1,0(R9)       LOAD PARAMETER LENGTH
         LTR   R1,R1          ZERO TEST
         BZ    NA3            ZERO MEANS END OF PARMTABLE
         L     R8,0(R7)       ADDR OF PARAM ADDR
         L     R8,0(R8)       ADDR OF PARAMETER
         BCTR  R1,0           DECREASE LENGTH FOR EX
         EX    R1,MOVE1       STORE PARAMETER INTO PARM TABLE
         LA    R9,3(R9,R1)    INCREASE PARM TAB REG
         LA    R7,4(R7)       INCREASE PARM LIST REG
         B     NA2
NA3      EQU   *
*
*   GET DATE AND TIME
*
         TIME  ERRET=FEHLTME
         ST    R1,DATE
         ST    R0,TIME
*
*   PARAMETER VALIDATION TESTS
*
*   1. GDG NAME
*
         TRT   GDGNAME(36),TBL LOOK FOR BLANK DELIMITER
         BZ    FEHLNAM
         BAL   R10,LOGFORM  FORMATTING THE LOG DS
*
*   2. NUMBER OF ENTRIES
*
         OI    ENTRIES+3,X'F0'  INSERT VALID SIGN
         PACK  ENTRIES,ENTRIES  PACK NUMBER OF ENTRIES
         CP    ENTRIES,=P'0'  TEST FOR ZERO
         BZ    NA41           ZERO INDICATES 'DELETE INDEX'
         CP    ENTRIES,=P'255'  ERROR IF NUMBER OF ENTRIES
         BH    FEHLENT           GREATER THAN 256
*
*   3. INDEX OVERFLOW ACTION
*
         LA    R7,TACT        LOAD ADDR OF ACTION TABLE
NA4      EQU   *
         CLC   ACT,0(R7)      LOOK UP ACTION TABLE
         BE    NA5
         CLI   0(R7),X'FF'    IF END OF TABLE BRANCH TO ERR ROUT
         BE    FEHLACT
         LA    R7,7(R7)       INCREASE TAB REG
         B     NA4
NA41     EQU   *
         OI    SWITCH,X'04'   TURN ON DLTX BIT
         B     NA51
NA5      EQU   *
         MVC   FLAG,6(R7)     GDG FLAGS
         EJECT
**************************************
*                                    *
*   S E A R C H   R O U T I N E      *
*                                    *
**************************************
         SPACE
NA51     EQU   *
*
*   SET UP SEARCH ROUTINE
*
         LA    R8,GDGNAME     INIT CURRENT NAME ADDR
         ST    R8,NAMEADDR
         XC    NTTR,NTTR      SET TTR TO 000001 (VOL IND)
         MVI   NREC,X'01'
         BAL   R10,GETNAME    GET HIGH LEVEL INDEXNAME
*
*   ENQ SYSCTLG
*
*     GET UCB ADDR
*
         LA    R7,CTLG        DCB ADDR
         USING IHADCB,7
         L     R7,DCBDEBAD    DEB ADDR
         L     R7,32(R7)      UCB ADDR
         LA    R7,0(R7)       CLEAR HIGH ORDER BITS
         ST    R7,UCBADDR
         MVC   MINVICE+8(4),UCBADDR  ADD UCB ADDR TO MINOR NAMES
         MVC   MINVX+8(4),UCBADDR
         MVC   MINHLI(8),GINAME
         MVC   MINHLI+8(4),UCBADDR
         EXTRACT ASIDF,'S',FIELDS=(ASID)  GET ASID
         XR    R0,R0
         ICM   R0,X'C',ASIDF+2  INSERT ASID
         AH    R0,=H'41'       SYSEVENT ID
         ST    R0,DOPPLW       SAVE SYSEVENT INPUT
         SVC   95             SET ADDR SPACE TO NONSWAP
         ST    R1,DOPPLW+4     SAVE SYSEVENT RETURN CODE
         CLI   DOPPLW+7,X'00'  TEST RETURN CODE
         BE    NA51NSW        OK
         ABEND 0001,DUMP      NOT SUCCESSFUL
NA51NSW   EQU   *
         ENQ   MF=(E,ENQHL)   ENQ HIGH LEVEL NAME
         ENQ   MF=(E,ENQHLS)    SCOPE = SYSTEMS
         ENQ   MF=(E,ENQVX)   ENQ VOLUME INDEX
         ENQ   MF=(E,ENQVXS)    SCOPE = SYSTEMS
         ENQ   MF=(E,ENQVI)   ENQ VOLUME INDEX CONTROL ENTRY
         ENQ   MF=(E,ENQVIS)    SCOPE = SYSTEMS
         ENQ   MF=(E,ENQDSN)
         OI    SWITCH,X'01'   TURN ON ENQ SWITCH
         CLC   GINAME(7),=C'ENQTEST'
         BNE   NA52
         MVC   ETTR(3),NTTR      PASS TTR TO READ ROUT
         BAL   R10,UPLOCATE      LINK TO READ ROUTINE
         MVC   PROTBER+3(3),=C'ENQ'
         MVC   ECOMM(22),=CL22' SYSCTLG NOW ENQUEUED'
         LA    R8,ETTR
         BAL   R10,UPLOG         LINK TO LOG ROUT
         MVC   LOGBLKAD-1(4),=F'1'
         CLOSE (CTLG,,LOG)
NA51WTOR EQU   *
         XC    WTOECB,WTOECB
         XC    REPLY,REPLY
         WTO   'KATALOG-UPDATE AN DER ANDEREN ANLAGE.',        *********
               ROUTCDE=(1)
         WTOR  'ERST ANTWORTEN, WENN UPDATE BEENDET IST.',    **********
               REPLY,4,WTOECB,ROUTCDE=(1)
         WAIT  1,ECB=WTOECB
         CLC   REPLY,=C'FREE'
         BNE   NA51WTOR
         OPEN  (CTLG,UPDAT,LOG,UPDAT)
NA52     EQU   *
         TM    SWITCH,X'04'   TEST DLTX BIT.
         BO    DLTX           IF ON BRANCH TO DLTX ROUTINE
         B     NA61
NA6      EQU   *
         BAL   R10,GETNAME    GET INDEX NAME
*
*   READ CATALOG BLOCK
*
NA61     EQU   *
         MVC   ETTR(3),NTTR   PASS TTR TO READ ROUT
         BAL   R10,UPLOCATE   LINK TO READ ROUTINE
         MVC   KEY,EKEY       GET KEY
         MVC   CBER(256),EBER  MOVE BLOCK TO WORK AREA
         LA    R2,CBER+2      LOAD ADDR OF WORK AREA
         XC    ENTRY,ENTRY  CLEAR ENTRY INDICATOR
NA7      EQU   *
         BAL   R10,UPUNBLK    LINK TO UNBLOCK ROUTINE
*
*   TEST ENTRY TYPE
*
         CLC   0(8,R2),KD1    IS THIS ENTRY A CONTROL ENTRY?
         BE    NA8            YES
         CLI   11(R2),X'00'   LINK ENTRY ?
         BNE   NB1
         CLC   0(8,R2),=8X'FF'
         BNE   NB1            NO
*
*   THIS IS AN INDEX LINK ENTRY. IF LINK FIELD IS NOT ZERO
*   THERE IS ANOTHER BLOCK FOR THIS INDEX. PLACE LINK ADDR
*   IN TTR FIELD AND CONTINUE.
*
         CLC   8(3,R2),=3X'00'
         BE    NB2            END OF INDEX.BRANCH TO INSERT ROUT
         MVC   NTTR(3),8(R2)  PLACE LINK ADDR IN TTR
         B     NA61           AND BRANCH TO LOCATE
NA8      EQU   *
         CLI   11(R2),X'05'   TEST HALFWORD COUNT
         BE    NA9            VOLUME INDEX CONTROL ENTRY
         CLI   11(R2),X'03'
         BNE   FEHLIRR
*
*   THIS IS AN INDEX CONTROL ENTRY. SAVE THIS ENTRY AND ITS TTR
*
         MVC   ICE,0(R2)      SAVE INDEX CONTROL ENTRY
         B     NA7            GET NEXT ENTRY
*
*   THIS IS THE VOLUME INDEX CONTROL ENTRY
*
NA9      EQU   *
         MVC   VICE,0(R2)     SAVE VOLUME INDEX CONTROL ENTRY
         XR    R8,R8          PICK UP TRACK CAPACITY
         IC    R8,14(R2)
         STH   R8,TRKCAP      TRACK CAPACITY
         B     NA7            GET NEXT ENTRY
*
*   COMPARE NEW INDEX NAME WITH CURRENT ENTRY NAME
*
NB1      EQU   *
         CLC   0(8,R2),GINAME
         BL    NA7            LOW. GET NEXT ENTRY
         BH    NB2            HIGH. BRANCH TO INSERT ROUT
         L     R8,NAMEADDR    LOAD INDEX NAME PTR
         CLI   11(R2),X'00'   ERROR IF NO (G)IPE
         BE    NB1B
         CLI   11(R2),X'02'
         BNE   FEHLNAM
         CLI   0(R8),C' '     IF LOW LEVEL NAME BRANCH TO MOD ROUT
         BE    NB11
         B     FEHLNAM
NB1A     EQU   *
         LA    R8,1(R8)       BYPASS PERIOD
         ST    R8,NAMEADDR
         MVC   NTTR(3),8(R2)  LINK ADDR TO TTR
         B     NA6            SEARCH NEXT INDEX LEVEL
NB1B     EQU   *
         CLI   0(R8),C' '     ERROR IF LOW LEVEL NAME AND NO GIPE
         BE    FEHLNAM
         B     NB1A
         EJECT
**************************************************
*                                                *
*   M O D I F I C A T I O N   R O U T I N E      *
*                                                *
**************************************************
         SPACE
NB11     EQU   *
         ST    R2,INSADDR     SAVE MOD ADDR
*
*   LOG OLD INDEX BLOCK
*
         MVC   PROTBER+3(3),=C'OLD'
         MVC   COMM(22),=CL22' VOR MODIFIKATION'
         LA    R8,NTTR
         BAL   R10,UPLOG      LINK TO LOG ROUTINE
*
*   MODIFY GENERATION INDEX POINTER ENTRY
*
         ZAP   DOPPLW,ENTRIES  CONVERT MAX NUMBER OF ENTRIES
         CVB   R9,DOPPLW
         L     R2,INSADDR     LOAD MOD ADDR
         STC   R9,13(R2)      STORE MAX NUMBER OF ENTRIES
         MVC   12(1,R2),FLAG  GDG FLAGS
*
*   MOVE MODIFIED BLOCK TO OUTPUT QUEUE
*
         CLC   13(1,R2),15(R2)  COMP MAX NUMBER WITH CURRENT NUMBER
         BNL   NB12           IF NOT LOW NO GDG'S WILL BE DELETED
         MVC   15(1,R2),13(R2)  SET CURRENT NUMBER TO MAX
         MVC   GIPEFLD,0(R2)  SAVE GIPE
         BAL   R10,GDGDEL     LINK TO DELETE GENERATION ROUT
NB12     EQU   *
         MVC   OTTR(3),NTTR   TTR
         MVI   OTTR+3,X'FF'   SET CHANGE BYTE TO ONES
         MVC   OKEY,KEY       KEY
         MVC   OBER(256),CBER  INDEX BLOCK
         MVC   OCOMM(22),=CL22' NACH MODIFIKATION'
         MVC   OPTR,INDADDR  LINK W A QUEUE TO OUTPUT QUEUE
         B     ND71           WRITE OUTPUT QUEUE
         EJECT
****************************************
*                                      *
*   I N S E R T   R O U T I N E        *
*                                      *
****************************************
         SPACE
NB2      EQU   *
         ST    R2,INSADDR     SAVE INSERT ADDR
*
*   LOG FIRST FREE BLOCK
*
         MVC   ETTR(3),VICE+16  TTR OF FIRST FREE BLOCK
         BAL   R10,UPLOCATE   READ FREE BLOCK
         MVC   PROTBER+3(3),=C'OLD'
         MVC   ECOMM(22),=CL22' FREIER BLOCK'
         LA    R8,ETTR
         BAL   R10,UPLOG      LINK TO LOG ROUTINE
NB3      EQU   *
*
*   BUILD NEW INDEX POINTER ENTRY
*
         MVC   GITTR,VICE+16  ADDR OF FIRST UNUSED BLOCK IN SYSCTLG
         MVI   GICNT,X'00'
         L     R8,NAMEADDR    LOW LEVEL NAME
         CLI   0(R8),C' '     IF NO CREATE AN INDEX POINTER ENTRY
         BNE   NB4            IF YES A GEN INDEX PTR ENTRY
         MVI   GICNT,X'02'    HALFWORD COUNT
         MVC   GIFLAGS,FLAG   GDG FLAG BYTE
         ZAP   DOPPLW,ENTRIES  CONVERT MAX NUMBER OF ENTRIES
         CVB   R9,DOPPLW
         STC   R9,GIMAX
         XC    GICURR,GICURR  ZERO CURRENT NUMBER OF ENTRIES
NB4      EQU   *
*
*   BUILD NEW INDEX BLOCK
*
         BAL   R10,GETOQEL    GET NEW OUTPUT QUEUE ELEMENT
         MVC   BLOCK1AD,LINDADDR  SAVE CURRENT BLOCK ADDR
         USING INDTTR,7
         MVC   INDKEY,=8X'FF' INIT INDEX AREA
         XC    INDBLOCK(256),INDBLOCK
         MVC   INDBLOCK(2),=H'32'  NUMBER OF BYTES USED
         MVC   INDBLOCK+2(8),KD1   INDEX CONTROL ENTRY IDENTIFIER
         MVC   INDBLOCK+10(3),VICE+16  TTR OF LAST BLOCK IN THIS INDEX
         MVI   INDBLOCK+13,X'03'  HALFWORD COUNT
         MVC   INDBLOCK+14(3),VICE+16  TTR OF FIRST BLOCK IN THIS INDEX
         MVI   INDBLOCK+17,X'00'  ALIAS COUNT = 00
         MVC   INDBLOCK+18(2),=2X'00'  UNUSED
         MVC   INDBLOCK+20(8),=8X'FF'  INDEX LINK ENTRY (TERMINATOR)
         MVC   INDTTR(3),VICE+16  DESTINATION
         MVI   INDCHNG,X'FF'  SET CHANGE BYTE TO ONES
         MVC   INDCOMM(22),=CL22' NEUER INDEX LEVEL'
         CLC   INDADDR,LINDADDR  FIRST LEVEL IPE TO BE INSERTED?
         BNE   NC2            IF NO BRANCH TO NEW BLOCK MODIFICATION
*
*   EXPAND OLD INDEX BLOCK
*
         XC    OBER(256),OBER  CLEAR STATIC OUTPUT AREAS
         XC    OBER2(256),OBER2
         XC    OTTR2(4),OTTR2
         MVC   OTTR(3),NTTR   TTR OF BLOCK TO BE WRITTEN
         MVI   OTTR+3,X'FF'   SET CHANGE BYTE TO ONES
         MVC   OKEY,KEY       KEY OF BLOCK TO BE WRITTEN
         LA    R8,CBER        ADDR OF OLD INDEX BLOCK
NB41     EQU   *
         LA    R9,OBER+2      ADDR OF OUTPUT AREA
         L     R1,INSADDR     INSERT ADDR
         SR    R1,R8          LENGTH OF FIRST SEGMENT
         STH   R1,OBER        STORE IT INTO OUTPUT AREA
         SH    R1,=H'2'       DECREASE LENGTH BY LENGTH OF LENGTH FIELD
         BM    FEHLIRR
         LA    R8,2(R8)
         CH    R1,=H'254'
         BH    FEHLIRR
         BCTR  R1,0           DECREASE LENGTH FOR EX
         LTR   R1,R1          ZERO LENGTH MEANS  THE NEW ENTRY
         BM    NB6            MUST BE INSERTED AT THE BEGINNING
*                             OF THE BLOCK
         EX    R1,MOVE3       FIRST SEGMENT TO OUTPUT AREA
         LA    R9,1(R9,R1)    UPDATE OUTPUT POINTER
NB6      EQU   *
         LA    R8,1(R8,R1)    UPDATE OLD INDEX POINTER
         CLC   GINAME,=8X'00' NEW ENTRY ALREADY INSERTED
         BE    NB61
         XR    R1,R1          CALCULATE LENGTH OF ENTRY TO BE INSERTED
         IC    R1,GICNT
         SLA   R1,1(0)
         LA    R1,12(R1)
         LH    R7,OBER        ENOUGH PLACE TO INSERT NEW ENTRY ?
         LA    R7,12(R7,R1)
         CH    R7,=H'256'
         BH    NB5            NO. BLOCK MUST BE SPLITTED
         BCTR  R1,0           DECREASE ENTRY LENGTH FOR EX
         EX    R1,MOVE4       INSERT NEW ENTRY
         XC    GINAME,GINAME  INDICATE THAT NEW ENTRY IS INSERTED
         SH    R7,=H'12'      CURRENT NUMBER OF USED BYTES
         STH   R7,OBER        STORE IT INTO LENGTH FIELD
         LA    R9,1(R9,R1)    UPDATE OUTPUT POINTER
NB61     EQU   *
         LA    R1,CBER        CALCULATE REMAINING LENGTH
         AH    R1,0(R1)
         S     R1,INSADDR     REMAINING LENGTH
         LH    R7,OBER        ENOUGH PLACE TO STORE 2ND SEGMENT
         LA    R7,0(R7,R1)
         CH    R7,=H'256'
         BH    NB7            NO. TERMINATE THIS BLOCK
         BCTR  R1,0           DECREASE LENGTH FOR EX
         EX    R1,MOVE3       MOVE 2ND SEGMENT TO OUTPUT AREA
         STH   R7,OBER        TOTAL NUMBER OF USED BYTES
         TM    SWITCH,X'02'   TEST OVERFLOW BIT
         BZ    NC1            BRANCH TO TEST NEXT LEVEL
         LA    R9,1(R9,R1)    UPDATE OUPUT POINTER
         LA    R2,CBER-12     LOOK FOR TERMINAL LINK ENTRY
         AH    R2,CBER
         CLC   8(3,R2),=3X'00'
         BE    NC1            TERMINAL LINK ENTRY
         MVC   ETTR(3),8(R2)  PICK UP TTR OF CONT BLOCK
         BAL   R10,UPLOCATE   READ CONTINUATION BLOCK
         MVC   COMM(22),=CL22' VOR EINFUEGEN (G)IPE'
         LA    R8,NTTR
         BAL   R10,UPLOG      LINK TO LOG ROUTINE
         MVC   NTTR(3),ETTR
         MVC   KEY,EKEY
         MVC   CBER(256),EBER
         SH    R9,=H'12'      DELETE LINK ENTRY
         LH    R7,OBER
         SH    R7,=H'12'
         STH   R7,OBER
         LA    R8,CBER+2      NEW INSERT ADDR
         B     NB7
*
*   TERMINATE INDEX BLOCK
*
NB7      EQU   *
         ST    R8,INSADDR
         XR    R1,R1          CALCULATE LENGTH OF NEXT ENTRY
         IC    R1,11(R8)
         SLA   R1,1(0)
         LA    R1,12(R1)
         LH    R7,OBER        ENOUGH PLACE LEFT FOR THIS ENTRY ?
         LA    R7,44(R7,R1)
         CH    R7,=H'256'
         BH    NB5            NO. BRANCH TO SPLIT BLOCK
         BCTR  R1,0           DECREASE LENGTH FOR EX
         EX    R1,MOVE3       MOVE ENTRY TO OUTPUT AREA
         SH    R7,=H'44'
         STH   R7,OBER        CURRENT NUMBER OF USED BYTES
         CLC   0(8,R8),=8X'FF'  INDEX BLOCK TERMINATED ?
         BE    NC1            YES
         LA    R8,1(R8,R1)    UPDATE INDEX BLOCK POINTER
         LA    R9,1(R9,R1)    UPDATE OUTPUT PTR
         B     NB7
*
*   INDEX BLOCK FULL. BUILD OVERFLOW BLOCK
*
NB5      EQU   *
         OI    SWITCH,X'02'   OVERFLOW BIT
         LH    R1,OBER        INCREASE NUMBER OF USED BYTES
         LA    R1,12(R1)
         STH   R1,OBER
         LA    R2,CBER-12     LOOK FOR TERMINAL LINK ENTRY
         AH    R2,CBER
         CLC   0(8,R2),=8X'FF'
         BNE   FEHLIRR
         CLC   8(3,R2),=3X'00'
         BE    NB51           TERMINAL LINK ENTRY
         MVC   0(8,R9),=8X'FF'  BUILD LINK ENTRY
         MVC   8(3,R9),8(R2)  TTR OF NEXT BLOCK
         MVI   11(R9),X'00'   HALFWORD COUNT
         BAL   R10,GETOQEL    GET NEW OUTPUT QUEUE ELEMENT
         USING INDTTR,7
         CLC   OTTR(3),X'000001'  FIRST BLOCK VOL IND ?
         BNE   NB5A           NO
         ST    R7,VICEADDR
         B     NB5B
NB5A     CLC   ICE+12(3),OTTR  FIRST BLOCK OF INDEX
         BNE   NB5B
         ST    R7,ICEADDR
NB5B     EQU   *
         MVC   INDTTR(4),OTTR  MOVE TO OUTPUT QUEUE
         MVC   INDKEY,OKEY
         MVC   INDBLOCK(256),OBER
         MVC   INDCOMM(22),=CL22' NACH EINFUEGEN (G)IPE'
         MVC   OTTR(3),8(R2)  TTR OF CONTINUATION BLOCK
         MVI   OTTR+3,X'FF'   SET CHANGE BYTE TO ONES
         MVC   OKEY,=8X'FF'
         XC    OBER(256),OBER  CLEAR OUTPUT AREA
         L     R8,INSADDR     PICK UP ACTUAL BLOCK ADDR
         SH    R8,=H'2'
         LA    R9,OBER+2
         B     NB41
NB51     EQU   *
         BAL   R10,UPFREE     LOOK FOR NEXT FREE BLOCK
         MVC   0(8,R9),=8X'FF'  BUILD LINK ENTRY
         MVC   8(3,R9),VICE+16  LINK ADDR
         MVI   11(R9),X'00'   HALFWORD COUNT 00
         MVC   OTTR2(4),OTTR  MOVE TO ALTERNATE OUTPUT AREA
         MVC   OKEY2,OKEY
         MVC   OBER2(256),OBER
         MVC   OTTR(3),VICE+16  TTR OF OVERFLOW BLOCK
         MVI   OTTR+3,X'FF'   SET CHANGE BYTE TO ONES
         MVC   OKEY,=8X'FF'   KEY
         XC    OBER(256),OBER  CLEAR PRIMARY OUTPUT AREA
         L     R8,INSADDR     PICK UP ACTUAL BLOCK ADDR
         SH    R8,=H'2'
         LA    R9,OBER+2      LOAD ADDR OF OUTPUT AREA
         B     NB41
*
*   TEST FOR NEXT INDEX LEVEL
*
NC1      EQU   *
         NI    SWITCH,X'FD'   CLEAR OVERFLOW BIT
         L     R8,NAMEADDR
         CLI   0(R8),C' '
         BE    ND1            END OF QUALIFIED NAME
         LA    R8,1(R8)       BYPASS PERIOD
         ST    R8,NAMEADDR    SAVE CURRENT NAME ADDR
         BAL   R10,GETNAME    GET NEXT INDEX LEVEL NAME
         BAL   R10,UPFREE     LOOK FOR NEXT FREE BLOCK
         L     R8,BLOCK1AD    ADDR OF CURRENT LEVEL INDEX BLOCK
         LA    R8,16(R8)
         ST    R8,INSADDR     AND SAVE IT
         B     NB3            BUILD NEW INDEX POINTER ENTRY
*
*   INSERT INDEX POINTER ENTRY IN NEW INDEX BLOCK
*
NC2      EQU   *
         L     R9,INSADDR     ADDR OF CURRENT LEVEL INDEX BLOCK
         XR    R1,R1          CALCULATE LENGTH OF ENTRY TO BE INSERTED
         IC    R1,GICNT
         SLA   R1,1(0)
         LA    R1,12(R1)
         LH    R7,0(R9)       UPDATE NUMBER OF USED BYTES
         LA    R7,0(R7,R1)
         STH   R7,0(R9)
         LA    R9,20(R9)      UPDATE INDEX POINTER
         BCTR  R1,0           DECREASE LENGTH FOR EX
         EX    R1,MOVE4       INSERT NEW ENTRY
         LA    R9,1(R9,R1)    UPDATE INDEX POINTER
         MVC   0(8,R9),=8X'FF'  LINK ENTRY
         B     NC1            BRANCH TO TEST FOR NEXT LEVEL
         EJECT
***********************************
*                                 *
*   W R I T E   R O U T I N E     *
*                                 *
***********************************
         SPACE
ND1      EQU   *
         BAL   R10,UPFREE     LOOK FOR NEXT FREE BLOCK
         CLC   OTTR2(3),=3X'00'  ALTERNATE OUTPUT AREA IN USE?
         BE    ND2           IF EMPTY THE LAST BLOCK TTR IN ICE OR VICE
*                             IS NOT CHANGED.
*
*   LOOK FOR TERMINAL LINK ENTRY
*
         LA    R2,OBER+2      SET UP UNBLOCK ROUT
         XC    ENTRY,ENTRY
ND3      EQU   *
         BAL   R10,UPUNBLK    LINK TO UNBLOCK ROUT
         CLC   0(8,R2),=8X'FF'
         BNE   ND3
         CLC   8(3,R2),=3X'00'  TEST LINK ADDR
         BNE   ND2            NO TERMINAL LINK ENTRY
         CLC   ICE,=18X'00'   INDEX LEVEL LOWER THAN VOL INDEX
         BE    ND4            IF NO UPDATE VICE
         MVC   ICE+8(3),OTTR  UPDATE ICE
         CLC   ICE+12(3),OTTR2  IS FIRST BLOCK OF INDEX ALREADY
*                               QUEUED FOR UPDATE ?
*
         BE    ND31            YES
         CLC   ICE+12(3),OTTR
         BE    ND32            YES
         L     R7,ICEADDR
         USING INDTTR,7
         LTR   R7,R7
         BZ    ND33
         CLC   ICE+12(3),INDTTR
         BNE   ND33
         MVC   INDBLOCK+2(18),ICE  NEW ICE TO OUTPUT AREA
         B     ND2
ND31     EQU   *
         MVC   OBER2+2(18),ICE  NEW ICE TO OUTPUT AREA
         B     ND2
ND32     EQU   *
         MVC   OBER+2(18),ICE
         B     ND2
ND33     EQU   *
*
*   NO. READ FIRST BLOCK OF INDEX TO UPDATE ICE
*
         MVC   ETTR(3),ICE+12  TTR OF FIRST BLOCK
         BAL   R10,UPLOCATE   LINK TO READ ROUTINE
         MVC   PROTBER+3(3),=C'OLD'  SET UP LOG ROUTINE
         MVC   ECOMM(22),=CL22' ICE -ALT-'
         LA    R8,ETTR        ADDR OF BLOCK TO BE LOGGED
         BAL   R10,UPLOG      LINK TO LOG ROUTINE
         BAL   R10,GETOQEL    GET OUTPUT QUEUE ELEMENT
         USING INDTTR,7
         MVC   INDTTR(12),ETTR  MOVE BLOCK TO OUTPUT QUEUE
         MVI   INDCHNG,X'FF'  SET CHANGE BYTE TO ONES
         MVC   INDBLOCK(256),EBER
         MVC   INDBLOCK+2(18),ICE NEW INDEX CONTROL ENTRY
         MVC   INDCOMM(22),=CL22' ICE -NEU-'
         B     ND2
*
*   UPDATE VICE AND TEST IF FIRST  BLOCK OF VOLUME INDEX
*   IS ALREADY QUEUED FOR OUTPUT. IF NO READ FIRST BLOCK
*   OF VOLUME INDEX TO UPDATE VICE
*
ND4      EQU   *
         MVC   VICE+8(3),OTTR  UPDATE VOLUME INDEX CONTROL ENTRY
ND2      EQU   *
         CLC   OTTR2(3),=X'000001'
         BE    ND21
         CLC   OTTR(3),=X'000001'
         BE    ND22
         L     R7,VICEADDR
         USING INDTTR,7
         LTR   R7,R7
         BZ    ND23
         CLC   INDTTR(3),=X'000001'
         BNE   ND23
         MVC   INDBLOCK+2(22),VICE  NEW VICE TO OUTPUT AREA
         B     ND5
ND21     EQU   *
         MVC   OBER2+2(22),VICE  NEW VICE TO OUTPUT AREA
         B     ND5
ND22     EQU   *
         MVC   OBER+2(22),VICE
         B     ND5
ND23     EQU   *
*
*   READ FIRST BLOCK OF VOL IND TO UPDATE VICE
*
         MVC   ETTR(3),=X'000001'  ADDR OF FIRST BLOCK IN VOLUME INDEX
         BAL   R10,UPLOCATE   LINK TO READ ROUTINE
         MVC   PROTBER+3(3),=C'OLD'  SET UP LOG ROUTINE
         MVC   ECOMM(22),=CL22' VICE -ALT-'
         LA    R8,ETTR        ADDR OF BLOCK TO BE LOGGED
         BAL   R10,UPLOG      LINK TO LOG ROUTINE
         BAL   R10,GETOQEL    GET OUTPUT QUEUE ELEMENT
         USING INDTTR,7
         MVC   INDTTR(12),ETTR  MOVE BLOCK TO OUTPUT QUEUE
         MVI   INDCHNG,X'FF'  SET CHANGE BYTE TO ONES
         MVC   INDBLOCK(256),EBER
         MVC   INDBLOCK+2(22),VICE  NEW VOLUME INDEX CONTROL ENTRY
         MVC   INDCOMM(22),=CL22' VICE -NEU-'
*
*   SET UP OUTPUT QUEUE
*
ND5      EQU   *
         MVC   OPTR2,INDADDR
         LA    R7,OPTR2
         ST    R7,OPTR
*
*   INSERT COMMENTS IN OUTPUT AREAS
*
         CLC   OTTR2(3),=3X'00'  ALTERNATE OUTPUT AREA IN USE ?
         BE    ND6            NO
         MVC   OCOMM2(22),=CL22' NACH EINFUEGEN (G)IPE'
         MVC   OCOMM(22),=CL22' UEBERLAUF-BLOCK'
         B     ND7
ND6      EQU   *
         MVC   OCOMM(22),=CL22' NACH EINFUEGEN (G)IPE'
*
*   LOG OLD INDEX BLOCK
*
ND7      MVC   PROTBER+3(3),=C'OLD'
         MVC   COMM(22),=CL22' VOR EINFUEGEN (G)IPE'
         LA    R8,NTTR
         BAL   R10,UPLOG      LINK TO LOG ROUTINE
*
*   WRITE OUTPUT QUEUE
*
ND71     LA    R7,OPTR        START ADDR OF OUTPUT QUEUE
NE1      EQU   *
         CLI   7(R7),X'00'    TEST FOR DUMMY ELEMENT
         BE    NE2
         CLC   4(3,R7),=X'000001'  CALCULATE RELATIVE BLOCK ADDR
         BNE   NE3
         MVC   BLOCKADR,=3X'00'
         B     NE4
NE3      EQU   *
         LH    R8,4(R7)       RELATIVE TRACK
         MH    R8,TRKCAP      TIMES TRACK CAPACITY
         XC    BLOCKNR,BLOCKNR
         MVC   BLOCKNR+1(1),6(R7)  PICK UP RECORD NUMBER
         AH    R8,BLOCKNR     ADD RECORD NUMBER
         BCTR  R8,0           DECREASED BY 1
         ST    R8,BLOCKADR-1  STORE RELATIVE BLOCK ADDR
NE4      EQU   *
*
*   KEY TEST ROUTINE. IF KEY NOT EQUAL TO HEX FF THIS
*   ROUTINE WILL MOVE THE LAST ENTRY NAME OF THIS BLOCK
*   TO THE KEY FIELD
*
         CLC   8(8,R7),=8X'FF'    IF KEY EQUAL TO HEX FF
         BE    NE4M           BYPASS TEST ROUTINE
         LA    R8,16(R7)      AREA ADDR
         LH    R2,0(R8)       LOOK FOR ILE
         CH    R2,=H'256'
         BH    NE4M
         LA    R2,0(R8,R2)
         SH    R2,=H'12'
         CLC   0(8,R2),=8X'FF'
         BNE   NE4M
         LA    R2,2(R8)       ADDR OF FIRST ENTRY
         XC    ENTRY,ENTRY    CLEAR ENTRY INDICATOR
NE4B     EQU   *
         BAL   R10,UPUNBLK    LINK TO UNBLOCK ROUT
         CLC   0(8,R2),=8X'FF' LINK ENTRY ?
         BE    NE4D           YES
         MVC   GINAME,0(R2)   SAVE CURRENT ENTRY NAME
         B     NE4B
NE4D     EQU   *
         MVC   8(8,R7),GINAME     MODIFY KEY
NE4M     EQU   *
         MVC   KEY,8(R7)      KEY
         LA    R8,16(R7)      AREA ADDRESS
         NOP   NE41           BYPASS WRITE
         WRITE WDECB,DI,CTLG,(8),'S',KEY,BLOCKADR   WRITE BLOCK
         CHECK WDECB
         CLC   WDECB+2(2),=2X'00'  TEST EXCEPTION BYTES
         BNE   FEHLWR         WRITE EXCEPTION
NE41     EQU   *
         MVC   PROTBER+3(3),=C'NEW'  SET UP LOG ROUTINE
         LA    R8,4(R7)
         BAL   R10,UPLOG      LINK TO LOG ROUTINE
NE2      EQU   *
         CLC   0(4,R7),=4X'00'  TEST FOR END OF QUEUE
         BE    NE5 END
         L     R7,0(R7)       ADDR OF NEXT OUTPUT QUEUE ELEMENT
         B     NE1
         EJECT
****************************************
*                                      *
*   B L D G   T E R M I N A T I O N    *
*                                      *
****************************************
         SPACE
NE5      EQU   *
         TM    SWITCH,X'01'   TEST ENQ BIT
         BZ    NE6
         DEQ   MF=(E,DEQHL)  DEQ HIGH LEVEL INDEX
         DEQ   MF=(E,DEQHLS)    SCOPE = SYSTEMS
         DEQ   MF=(E,DEQVX)  DEQ VOLUME INDEX
         DEQ   MF=(E,DEQVXS)    SCOPE = SYSTEMS
         DEQ   MF=(E,DEQVI)  DEQ VICE
         DEQ   MF=(E,DEQVIS)    SCOPE = SYSTEMS
         DEQ   MF=(E,DEQDSN)
         XR    R0,R0
         ICM   R0,X'C',ASIDF+2  INSERT ASID
         AH    R0,=H'42'      SYSEVENT ID
         ST    R0,DOPPLW         SAVE SYSEVENT INPUT
         SVC   95        SET ADDR SPC TO SWAPPABLE
         ST    R1,DOPPLW+4       SAVE SYSEVENT RETURN CODE
         CLI   DOPPLW+7,X'00'    TEST RETURN CODE
         BE    NE5SW      OK
         ABEND 0002,DUMP
NE5SW    EQU   *
         NI    SWITCH,X'FE'   TURN OFF ENQ BIT
NE6      EQU   *
         XC    NTTR(3),NTTR   LOG END OF BLDG
         XC    KEY,KEY
         XC    CBER(256),CBER
         MVC   COMM(22),=CL22' BLDG ENDE.RC='
         UNPK  COMM+14(9),RC(5)  RETURN CODE
         TR    COMM+14(8),TTRANS-240
         L     R7,REG1        POINT TO CALLER'S RET FIELD
         L     R7,12(R7)
         L     R7,0(R7)
         MVC   0(8,R7),COMM+14  PASS RETURN CODE TO CALLER
         MVC   PROTBER+3(3),=C'END'
         LA    R8,NTTR
         BAL   R10,UPLOG      LINK TO LOG ROUTINE
         CLOSE (CTLG)    CLOSE SYSCTLG AND LOG DATA SET
         MVC   LOGEOD,LOGBLKAD-1
         XC    LOGBLKAD-1(4),LOGBLKAD-1
         READ  LOGRDECB,DI,MF=E
         CHECK LOGRDECB
         BAL   R14,LOGIOR
         MVC   PROTBER+10(4),LOGEOD
         WRITE LOGDDECB,DI,MF=E
         CHECK LOGDDECB
         BAL   R14,LOGIOW
         CLOSE LOG
*
*   FREE ALLOCATE SPACE
*
         L     R7,INDADDR     ADDR OF FIRST AREA
         B     NF11
NF1      EQU   *
         L     R7,0(R1)       SAVE LINK ADDR
         FREEMAIN R,LV=300,A=(1)
NF11     EQU   *
         LTR   R7,R7          TEST LINK ADDR
         BZ    NF2            IF ZERO FREEMAIN IS FINISHED
         LR    R1,R7
         B     NF1
NF2      EQU   *
         L     R15,RC         LOAD RETURN CODE
         L     R13,SAVE+4     LOAD SAVE AREA ADDR OF CALLER
         RETURN (14,12),RC=(15)   RETURN TO CALLER
         EJECT
*********************************************************
*                                                       *
*  D E L E T E   I N D E X   R O U T I N E  (DLTX)      *
*                                                       *
*********************************************************
         SPACE
DLTX     EQU   *
         XC    BLOCK1AD,BLOCK1AD  CLEAR ADDR OF CURRENT W A ELEMENT
         B     NH1
NH0      EQU   *
         BAL   R10,GETNAME    GET INDEX NAME
*
*   READ CATALOG BLOCK
*
NH1      EQU   *
         MVC   ETTR(3),NTTR   PASS TTR TO READ ROUTINE
         BAL   R10,UPLOCATE   LINK TO READ ROUTINE
         LA    R2,EBER+2      SET UP UNBLOCK ROUTINE
         XC    ENTRY,ENTRY
NH2      EQU   *
         BAL   R10,UPUNBLK    LINK TO UNBLOCK ROUT
*
*   TEST ENTRY TYPE
*
         CLC   0(8,R2),KD1    CONTROL ENTRY ?
         BE    NH3            YES
         CLI   11(R2),X'00'   LINK ENTRY ?
         BNE   NH4
         CLC   0(8,R2),=8X'FF'
         BNE   NH4            NO
*
*  LINK ENTRY. IF LINK ADDR ZERO BRANCH TO ERROR.
*  IF NONZERO SAVE BLOCK AND READ NEXT ONE
*
         CLC   8(3,R2),=3X'00'
         BE    FEHLNAM        GDG NOT FOUND
         L     R7,BLOCK1AD    LOAD ADDR OF CURRENT W A ELEMENT
         LTR   R7,R7       IF ZERO GET NEW WORK AREA QUEUE ELEMENT
         BNZ   NH5
         L     R7,LINDADDR    BLOCK ALREADY STORED ?
         LA    R7,4(R7)
         USING INDTTR,7
         CLC   INDTTR(3),ETTR
         BE    NH51           YES. READ NEXT BLOCK
         BAL   R10,GETOQEL    GET NEW WORK AREA QUEUE ELEMENT
         ST    R7,BLOCK1AD    SAVE ADDR OF NEW ELEMENT
NH5      EQU   *
         USING INDTTR,7
         MVC   INDTTR(3),ETTR  MOVE CTLG BLOCK TO WORK AREA QUEUE
         MVI   INDCHNG,X'00'  CLEAR CHANGE BYTE
         MVC   INDKEY,EKEY
         MVC   INDBLOCK(256),EBER
         XC    INDOFFS,INDOFFS  CLEAR (G)IPE OFFSET
NH51     EQU   *
         MVC   NTTR(3),8(R2)  PLACE LINK ADDR IN TTR
         B     NH1            AND BRANCH TO READ
*
*  THIS IS A CONTROL ENTRY. MOVE THIS BLOCK TO WORK AREA QUEUE.
*  IF IT IS THE VICE PICK UP RECORD NUMBER FROM LAST BLOCK ADDR
*  AND STORE IT INTO TRACK CAPACITY FIELD
*
NH3      EQU   *
         BAL   R10,GETOQEL    GET QUEUE ELEMENT
         USING INDTTR,7
         MVC   INDTTR(3),ETTR  MOVE CTLG BLOCK TO WORK AREA QUEUE
         MVI   INDCHNG,X'00'  CLEAR CHANGE BYTE
         MVC   INDKEY,EKEY
         MVC   INDBLOCK(256),EBER
         XC    INDOFFS,INDOFFS  CLEAR (G)IPE OFFSET
         CLI   11(R2),X'05'   TEST HALFWORD COUNT
         BE    NH6            VOLUME INDEX CONTROL ENTRY (VICE)
         CLI   11(R2),X'03'
         BNE   FEHLIRR        NEITHER VICE NOR ICE
         B     NH2            INDEX CONTROL ENTRY. GET NEXT ENTRY
NH6      EQU   *  THIS IS A VOLUME INDEX CONTROL ENTRY
         ST    R7,VICEADDR    SAVE ADDR OF FIRST BLOCK
         MVC   INDCOMM,=CL22' VICE -ALT-'
         XR    R8,R8          PICK UP TRACK CAPACITY
         IC    R8,14(R2)
         STH   R8,TRKCAP      TRACK CAPACITY
         MVC   VICE,EBER+2    SAVE VICE
         B     NH2            GET NEXT ENTRY
*
*  COMPARE INDEX NAME WITH NAME OF CURRENT ENTRY.
*
NH4      EQU   *
         CLC   0(8,R2),GINAME
         BL    NH2            LOW. GET NEXT ENTRY
         BH    FEHLNAM        GDG NAME NOT FOUND
*
*  (GENERATION) INDEX POINTER ENTRY FOUND. MOVE THIS BLOCK
*  TO WORK AREA QUEUE AND PLACE (G)IPE OFFSET IN INDOFFS
*
         L     R7,LINDADDR    BLOCK ALREADY STORED ?
         LA    R7,4(R7)
         USING INDTTR,7
         CLC   INDTTR(3),ETTR
         BE    NH9            IF YES BYPASS MOVE SEQUENCE
         BAL   R10,GETOQEL    GET NEW WORK AREA QUEUE ELEMENT
         XC    BLOCK1AD,BLOCK1AD  CLEAR CURRENT ELEMENT POINTER
         USING INDTTR,7
         MVC   INDTTR(3),ETTR  TTR
         MVI   INDCHNG,X'00'  CLEAR CHANGE BYTE
         MVC   INDKEY,EKEY    KEY
         MVC   INDBLOCK(256),EBER
NH9      EQU   *
         LA    R8,EBER        CALCULATE (G)IPE OFFSET
         LNR   R8,R8
         AR    R8,R2
         STH   R8,INDOFFS     (G)IPE OFFSET
         L     R8,NAMEADDR    LOAD INDEX NAME POINTER
         CLI   11(R2),X'00'   ERROR IF ENTRY IS NO (G)IPE
         BE    NH7            INDEX POINTER ENTRY
         CLI   11(R2),X'02'   TEST FOR GIPE
         BNE   FEHLNAM        CONFLICTING INDEX STRUCTURE
         CLI   0(R8),C' '     GIPE MUST BE LOWEST LEVEL
         BNE   FEHLNAM
         MVC   GIPEFLD,0(R2)  SAVE GIPE
         MVI   GIMAX,X'00'    SET MAX NUMBER OF GEN TO ZERO
         ST    R2,INSADDR     SAVE ADDR OF GIPE
         B     NH8
NH7      EQU   *              IPE
         CLI   0(R8),C' '     ERROR IF LOW LEVEL AND NO GIPE
         BE    FEHLNAM
         LA    R8,1(R8)       BYPASS PERIOD
         ST    R8,NAMEADDR
         MVC   NTTR(3),8(R2)  LINK ADDR TO TTR
         B     NH0            SEARCH NEXT INDEX LEVEL
*
*  E N T R Y   D E L E T I O N
*
NH8      EQU   *
         MVC   BLOCK1AD,LINDADDR  SAVE ADDR OF LOW LEVEL INDEX
         BAL   R10,GDGDEL     LINK TO GENERATION DELETE ROUT
         MVC   GLINDADR,LINDADDR  SAVE ADDR OF LAST QUEUE ELEMENT
         L     R7,BLOCK1AD    ADDR OF LOW LEVEL INDEX BLOCK
         ST    R7,LINDADDR
         LA    R7,4(R7)
         USING INDTTR,7
NI1      EQU   *
         CLC   INDOFFS,=H'0'  TEST (G)IPE OFFSET
         BNE   NI2
         CLC   INDADDR,LINDADDR  END OF QUEUE ?
         BE    NI3            YES
         L     R7,INDBACK     POINT TO PREVIOUS QUEUE ELEMENT
         ST    R7,LINDADDR
         LA    R7,4(R7)
         B     NI1
*
*  BLOCK WITH (G)IPE TO BE DELETED FOUND
*
NI2      EQU   *
         MVC   INDCOMM,=CL22' VOR DELETE (G)IPE'
         LA    R8,INDTTR
         BAL   R10,UPLOG      LINK TO LOG ROUTINE
         XC    OBER(256),OBER  CLEAR WORK AREA
         LA    R8,INDBLOCK    RESET INPUT POINTER
         LA    R9,OBER        RESET OUTPUT POINTER
         LH    R1,INDOFFS     OFFSET IS LENGTH OF FIRST SEGMENT
         BCTR  R1,0           DECREASE LENGTH FOR EX
         EX    R1,MOVE3       MOVE FIRST SEGMENT
         LA    R8,1(R8,R1)    INCREASE INPUT PTR
         LA    R9,1(R9,R1)    INCREASE OUTPUT PTR
         XR    R2,R2          PICK UP HALFWORD COUNT
         IC    R2,11(R8)      AND CALCULATE LENGTH
         SLL   R2,1(0)        OF ENTRY TO BE DELETED
         LA    R2,12(R2)
         AR    R8,R2          BYPASS ENTRY TO BE DELETED
         LH    R1,INDBLOCK    PICK UP OLD TOTAL LENGTH
         SH    R1,INDOFFS     AND DECREASE IT BY LENGTH OF 1ST SEGM
         SR    R1,R2          DECR IT BY LENGTH OF ENTRY TO BE DEL
         BCTR  R1,0           DECREASE IT FOR EX
         EX    R1,MOVE3       MOVE 2ND SEGMENT
         LH    R1,OBER        DECREASE TOTAL LENGTH
         SR    R1,R2          BY LENGTH OF DELETED ENTRY
         STH   R1,OBER
         CLC   OBER+2(8),KD1  FIRST BLOCK OF INDEX ?
         BE    NI6            YES
         SH    R1,=H'14'      BLOCK EMPTY ?
         BM    FEHLIRR
         BNZ   NI5            NO
         CLC   OBER+2(8),=8X'FF'
         BNE   FEHLIRR
         L     R7,INDBACK     LOOK FOR FIRST BLOCK IN INDEX
         LA    R7,4(R7)
         MVC   NTTR(3),INDTTR SAVE TTR OF PREVIOUS BLOCK
         MVC   PROTBER+3(3),=C'OLD'
         MVC   INDCOMM,=CL22' VOR AUSTAUSCH ILE'
         LA    R8,INDTTR
         BAL   R10,UPLOG      LINK TO LOG ROUTINE
         LA    R8,INDBLOCK    POINT TO ILE
         AH    R8,INDBLOCK
         SH    R8,=H'12'
         CLC   0(8,R8),=8X'FF'  THIS ENTRY MUST BE THE ILE
         BNE   FEHLIRR        IF NO BRANCH TO ERROR ROUT
         MVC   0(12,R8),OBER+2  ILE FROM EMPTY BLOCK TO PREVIOUS
         MVC   INDCOMM,=CL22' NACH AUSTAUSCH ILE'
         MVI   INDCHNG,X'FF'  SET CHANGE BYTE TO ONES
         CLC   OBER+10(3),=3X'00'  LAST BLOCK IN INDEX ?
         BNE   NI91       NO
         CLC   INDBLOCK+2(8),KD1  IS THIS BLOCK THE FIRST ONE IN INDEX
         BE    NI8            YES
         L     R7,INDBACK     POINT TO PREVIOUS ELEMENT
         LA    R7,4(R7)
         CLC   INDBLOCK+2(8),KD1
         BNE   FEHLIRR        NO ICE FOUND
NI8      EQU   *
         CLI   INDBLOCK+13,X'05'  VOLUME INDEX ?
         BNE   NI9
         CLC   INDTTR(3),=X'000001'
         BNE   FEHLIRR
         MVC   VICE+8(3),NTTR UPDATE VICE
         L     R8,VICEADDR
         MVI   7(R8),X'FF'    SET CHANGE BYTE TO ONES
         B     NI91
NI9      EQU   *
         MVC   PROTBER+3(3),=C'OLD'
         MVC   INDCOMM,=CL22' ICE -ALT-'
         LA    R8,INDTTR
         BAL   R10,UPLOG      LINK TO LOG ROUTINE
         MVC   INDBLOCK+10(3),NTTR  UPDATE ICE
         MVI   INDCHNG,X'FF'  SET CHANGE BYTE TO ONES
         MVC   INDCOMM,=CL22' ICE -NEU-'
NI91     EQU   *
         L     R7,LINDADDR    POINT TO CURRENT QUEUE ELEMENT
         LA    R7,4(R7)
         TM    INDBLOCK,X'80'  TEST FOR LINK ADDR
         BZ    NI7             NO LINK ADDR
         L     R7,INDBLOCK     LOAD ADDR OF BLOCK TO BE FREED
         LA    R7,4(R7)
         B     NI7
*
NI6      EQU   *    FIRST BLOCK OF INDEX
*
         CLC   INDTTR(3),=X'000001'  VOLUME INDEX ?
         BE    NJ1            YES
         SH    R1,=H'32'      BLOCK EMPTY ?
         BM    FEHLIRR
         BNZ   NI5            NO
         LA    R2,OBER+20     POINT TO LINK ENTRY
         B     NJ2
NJ1      EQU   *  FIRST BLOCK OF VOLUME INDEX
         SH    R1,=H'36'      BLOCK EMPTY ?
         BM    FEHLIRR
         BNZ   NI5            NO
         LA    R2,OBER+24     POINT TO LINK ENTRY
NJ2      EQU   *
         ST    R2,INSADDR     SAVE ADDR OF ILE
         CLC   0(8,R2),=8X'FF'  LAST BLOCK IN INDEX ?
         BNE   FEHLIRR
         CLC   8(3,R2),=3X'00'
         BNE   NJ3            NO
         CLC   INDTTR(3),=X'000001'  EMPTY VOLUME INDEX ISN'T DELETED
         BE    NI5
         OI    SWITCH,X'08'   IPE IN NEXT HIGHER LEVEL MUST BE DELETED
         B     NI7
*
* FIRST BLOCK OF MULTI BLOCK INDEX IS EMPTY. SHIFT FIRST
* ENTRY OF NEXT BLOCK TO EMPTY ONE
*
NJ3      EQU   *
         ST    R7,BLOCK1AD    SAVE ACTUAL ELEMENT ADDR
         BAL   R10,GETOQEL2   GET NEW WORKAREA QUEUE ELEMENT
         L     R8,BLOCK1AD
         MVC   INDTTR(4),0(R8)  TTR AND KEY OF ACTUAL BLOCK
         MVC   INDKEY,4(R8)   TO NEW ELEMENT
         XC    INDOFFS,INDOFFS
         XC    0(4,R8),0(R8)  REMOVE UNUSED ELEMENT FROM QUEUE
         MVC   ETTR(3),8(R2)  TTR OF NEXT BLOCK
         BAL   R10,UPLOCATE   LINK TO READ ROUTINE
         XC    INDBLOCK(256),INDBLOCK
         MVI   INDCHNG,X'FF'  SET CHANGE BYTE TO ONES
         MVC   INDCOMM,=CL22' NACH DELETE UND SHIFT'
         LA    R8,OBER
         LA    R9,INDBLOCK
         XR    R1,R1          PICK UP HALFWORD COUNT OF CONTROL ENTRY
         IC    R1,13(R8)
         SLL   R1,1(0)
         LA    R1,13(R1)
         EX    R1,MOVE3       CONTROL ENTRY TO NEW ELEMENT
         LA    R8,EBER+2      SET INPUT POINTER
         LA    R9,INDBLOCK+1(R1)  UPDATE OUTPUT POINTER
         XR    R1,R1          PICK UP HALFWORD COUNT OF NEXT ENTRY
         IC    R1,EBER+13     AND CALCULATE ENTRY LENGTH
         CLI   EBER+13,X'03'
         BE    FEHLIRR
         SLL   R1,1(0)
         LA    R1,12(R1)
         BCTR  R1,0           DECREASE LENGTH FOR EX
         EX    R1,MOVE3       MOVE NEXT ENTRY TO CURRENT BLOCK
         LA    R9,1(R9,R1)    UPDATE OUTPUT POINTER
         L     R8,INSADDR        ADDR OF ILE IN EMPTY BLOCK
         MVC   0(12,R9),0(R8)    ILE
         LH    R8,INDBLOCK    UPDATE LENGTH
         LA    R8,1(R8,R1)
         STH   R8,INDBLOCK
         CLC   INDTTR(3),=X'000001'  FIRST BLOCK OF VOL INDEX
         BNE   NJ4            NO
         ST    R7,VICEADDR    YES. SAVE ELEMENT ADDR OF VOL IND
NJ4      EQU   *
         BAL   R10,GETOQEL2   GET NEW WORK AREA QUEUE ELEMENT
         USING INDTTR,7
         MVC   INDTTR(3),ETTR MOVE BLOCK TO WORK AREA QUEUE
         MVI   INDCHNG,X'00'  CLEAR CHANGE BYTE
         MVC   INDKEY,EKEY
         MVC   INDBLOCK(256),EBER
         MVC   INDOFFS,=H'2'
         L     R8,BLOCK1AD    ADDR OF REMOVED BLOCK
         MVC   12(4,R8),GLINDADR  ADDR OF LAST ELEMNT TO REM BLK
         OI    12(R8),X'80'   SET INDICATOR
         B     NI1            DELETE SHIFTED ENTRY
*
*   F R E E   C A T A L O G   B L O C K
*
NI7      EQU   *
         MVI   INDCHNG,X'FF'  SET CHANGE BYTE TO ONES
         XC    INDKEY,INDKEY
         XC    INDBLOCK(256),INDBLOCK  CLEAR BLOCK
         MVC   INDCOMM,=CL22' BLOCK FREIGEGEBEN'
         XC    INDOFFS,INDOFFS
         CLC   INDTTR(3),VICE+16  UPDATE FREE BLOCK PTR IN VICE
         BNL   NJ5
         MVC   VICE+16(3),INDTTR
         L     R8,VICEADDR
         MVI   7(R8),X'FF'    SET CHANGE BYTE TO ONES
NJ5      EQU   *
         TM    SWITCH,X'08'   ANY IPE IN HIGHER LEVEL TO BE DELETED ?
         BZ    NI3            NO
         NI    SWITCH,X'F7'   CLEAR HIGH LEVEL IPE BIT
         L     R7,LINDADDR    PICK UP CURRENT W A QUEUE ELEMENT
         LA    R7,4(R7)
         L     R7,INDBACK     POINT TO PREVIOUS W A QUEUE ELELMENT
         ST    R7,LINDADDR
         LA    R7,4(R7)
         B     NI1            BRANCH TO ENTRY DELETION
*
*  ADD CHANGED BLOCK TO WORK AREA QUEUE
*
NI5      EQU   *
         MVI   INDCHNG,X'FF'  SET CHANGE BYTE TO ONES
         MVC   INDBLOCK(256),OBER  CHANGED BLOCK
         MVC   INDCOMM,=CL22' NACH DELETE (G)IPE'
         XC    INDOFFS,INDOFFS  CLEAR IPE OFFSET
*
*  TEST IF VICE HAS BEEN CHANGED
*
NI3      EQU   *
         L     R7,VICEADDR    LOAD ADDR OF VOL INDEX
         USING INDTTR,7
         CLC   VICE,INDBLOCK+2
         BE    NI31           NOT CHANGED
         MVC   PROTBER+3(3),=C'OLD'  SET UP LOG ROUTINE
         LA    R8,INDTTR
         BAL   R10,UPLOG      LINK TO LOG ROUTINE
         MVC   INDCOMM,=CL22' VICE -NEU-'
         MVC   INDBLOCK+2(22),VICE  UPDATE VICE
         MVI   INDCHNG,X'FF'  SET CHANGE BYTE TO ONES
NI31     EQU   *
         NI    SWITCH,X'F3'   CLEAR DLTX BITS
*
*  SET UP OUTPUT QUEUE
*
         L     R7,INDADDR     LOAD START ADDR OF WORK AREA QUEUE
         B     NE1            AND BRANCH TO WRITE ROUTINE
****************************************************
         EJECT
***************************************************************
*                                                             *
*   D E L E T E   G E N E R A T I O N   R O U T I N E         *
*                                                             *
*   THIS ROUTINE UNCATALOGS ALL GENERATIONS THAT INCREASE     *
*   THE MAX NUMBER OF GENERATIONS SPECIFIED IN THE GENERATION *
*   INDEX POINTER ENTRY (GIPE). IF THIS NUMBER IS ZERO THE    *
*   COMPLETE GENERATION INDEX WILL BE DELETED.                *
*                                                             *
***************************************************************
         SPACE
GDGDEL   EQU   *
         ST    R10,REG10GDG   SAVE RETURN REG
         MVC   ETTR(3),GITTR  PASS TTR OF GEN INDEX TO READ ROUT
         XR    R8,R8          PICK UP MAX NUMBER OF GENERATIONS
         IC    R8,GIMAX
         STH   R8,GDGCNT      AND SAVE IT
         LTR   R8,R8          IF MAX NUMBER IS ZERO
         BNZ   NK5            THE COMPLETE INDEX WILL BE DELETED
         OI    SWITCH,X'08'   ZERO. INDICATE COMPLETE DELETION
NK5      EQU   *
         BAL   R10,UPLOCATE   LINK TO READ ROUTINE
         BAL   R10,GETOQEL    GET WORK AREA QUEUE ELEMENT
         USING INDTTR,7       AND MOVE BLOCK TO IT
         MVC   INDTTR(3),ETTR TTR
         MVI   INDCHNG,X'00'  CLEAR CHANGE BYTE
         MVC   INDKEY,EKEY    KEY
         MVC   INDBLOCK(256),EBER  GENERATION INDEX BLOCK
         XC    INDOFFS,INDOFFS
         TM    SWITCH,X'08'   IF DELETE BIT IS ON SET DELETE OFFSET
         BZ    NK3
         MVC   INDOFFS,=H'2'
NK3      EQU   *
         LA    R2,INDBLOCK+2  SET UP UNBLOCK ROUTINE
         XC    ENTRY,ENTRY
NK1      EQU   *
         BAL   R10,UPUNBLK    LINK TO UNBLOCK ROUTINE
         CLC   0(8,R2),KD1    CONTROL ENTRY
         BNE   NK2
         CLI   11(R2),X'03'   YES
         BNE   FEHLIRR        ERROR IF NO CORRECT ICE
         ST    R7,ICEADDR     SAVE ADDR OF ICE
         B     NK1       NEXT ENTRY
NK2      EQU   *
*
*  TEST ENTRY TYPE. ONLY DSPE, VCBPE AND ILE ARE ALLOWED.
*
         CLI   11(R2),X'00'   INDEX LINK ENTRY ?
         BE    NK4            YES
         CLI   0(R2),C'G'     TEST FOR CORRECT GENERATION NAME
         BNE   FEHLIRR
         CLI   5(R2),C'V'
         BNE   FEHLIRR
         CLI   11(R2),X'01'   VCBPE ?
         BE    NK9            YES
         CLI   11(R2),X'07'   DSPE ?
         BL    FEHLIRR        IF NO BRANCH TO ERROR ROUT
NK9      EQU   *
         TM    SWITCH,X'08'   DELETE BIT ON ?
         BZ    NK6            NO
*
*  DELETE BIT ON. THIS GENERATION IS TO BE DELETED
*
         CLC   INDOFFS,=H'0'  DELETE OFFSET ALREADY SET
         BNE   NK7            YES
         LA    R8,INDBLOCK    CALCULATE DELETE OFFSET
         LNR   R8,R8
         AR    R8,R2
         STH   R8,INDOFFS
NK7      EQU   *
         CLI   11(R2),X'07'   DATASET POINTER ENTRY ?
         BNL   NK1            YES. GET NEXT ENTRY
*
*  THE GENERATION TO BE DELETED CONSISTS OF A VOLUME CONTROL
*  BLOCK POINTER ENTRY (VCBPE) AND ONE OR MORE VOLUME CONTROL
*  BLOCKS (VCB).
*  THE VCB'S WILL BE DELETED AND THE BLOCKS ARE FREED.
*
         ST    R2,INSADDR     SAVE ADDR OF ACTUAL ENTRY
         ST    R7,BLOCK2AD    SAVE ACTUAL BLOCK ADDR
         MVC   ETTR(3),8(R2)  TTR OF FIRST VCB
NL1      EQU   *
         BAL   R10,UPLOCATE   LINK TO READ ROUTINE
         BAL   R10,GETOQEL    GET WORKAREA QUEUE ELEMENT
         USING INDTTR,7
         MVC   INDTTR(3),ETTR FREE VCB
         MVI   INDCHNG,X'FF'  SET CHANGE BYTE TO ONES
         XC    INDKEY,INDKEY  CLEAR KEY
         XC    INDBLOCK(256),INDBLOCK  CLEAR CATALOG BLOCK
         MVC   INDCOMM,=CL22' VCB NACH FREIGABE'
         XC    INDOFFS,INDOFFS
         CLC   VICE+16(3),ETTR  UPDATE VICE IF REQUIRED
         BNH   NL3            NO UPDATE REQUIRED
         MVC   VICE+16(3),ETTR  CHANGE TTR OF FIRST FREE BLOCK
NL3      EQU   *
         MVC   PROTBER+3(3),=C'OLD'  SET UP LOG ROUTINE
         LA    R8,ETTR
         MVC   ECOMM,=CL22' VCB VOR FREIGABE'
         BAL   R10,UPLOG      LINK TO LOG ROUTINE
         CLC   EBER+252(3),=3X'00'  LAST VCB ?
         BE    NL2            YES
         MVC   ETTR(3),EBER+252  TTR OF NEXT VCB
         B     NL1
NL2      EQU   *
         L     R2,INSADDR     RELOAD ENTRY POINTER
         L     R7,BLOCK2AD    RELOAD BLOCK POINTER
         B     NK1            GET NEXT ENTRY OF GEN INDEX
NK6      EQU   *
         LH    R8,GDGCNT      UPDATE GDG COUNT
         SH    R8,=H'1'
         STH   R8,GDGCNT
         BNZ   NK1            IF NOT ZERO BRANCH TO GET NEXT ENTRY
         OI    SWITCH,X'08'   ZERO.TURN ON DELETE BIT
         B     NK1            GET NEXT ENTRY
*
*   END OF BLOCK
*
NK4      EQU   *
         MVC   ETTR(3),8(R2)    TTR OF NEXT GDG BLK
         CLC   0(8,R2),=8X'FF'  TEST FOR CORRECT ILE
         BNE   FEHLIRR        ILE INVALID
         TM    SWITCH,X'08'   TEST DELETE BIT
         BZ    NL4            ZERO. BLOCK REMAINS UNCHANGED.
*
*  MODIFY INDEX BLOCK
*
         XC    OBER(256),OBER  CLEAR WORKAREA
         XC    OKEY,OKEY
         CLC   INDOFFS,=H'2'  OFFSET=2 MEANS THE COMPLETE BLOCK
         BNH   NL5            IS TO BE DELETED
         LA    R8,INDBLOCK    SET INPUT POINTER
         LA    R9,OBER        SET OUTPUT POINTER
         LH    R1,INDOFFS     OFFSET IS LENGTH OF FIRST SEGMENT
         BCTR  R1,0           DECREASE IT FOR EX
         EX    R1,MOVE3       MOVE FIRST AND ONLY SEGMENT
         LA    R8,1(R8,R1)    INCREASE INPUT POINTER
         LA    R9,1(R9,R1)    INCREASE OUTPUT POINTER
         LA    R1,13(R1)      CALCULATE NEW LENGTH FIELD
         STH   R1,OBER
         MVC   0(12,R9),0(R2) TERMINATE BLOCK
         MVC   8(3,R9),=3X'00'
         MVC   OKEY,INDKEY
*
*  UPDATE LAST BLOCK TTR IN ICE IF REQUIRED
*
         C     R7,ICEADDR     ONE BLOCK INDEX ?
         BE    NL5            IF YES NO UPDATE REQUIRED
         L     R8,ICEADDR     ADDR OF FIRST BLOCK OF INDEX
         CLC   22(3,R8),INDTTR  LAST BLOCK TTR CHANGED ?
         BE    NL5            IF NO NO UPDATE IS REQUIRED
         TM    3(R8),X'FF'    TEST CHANGE BYTE
         BO    NK41           IF ONES NO LOG OF OLD STATUS
         MVC   PROTBER+3(3),=C'OLD'  SET UP LOG ROUTINE
         MVC   268(22,R8),=CL22' ICE -ALT-'
         LA    R8,0(R8)
         BAL   R10,UPLOG      LINK TO LOG ROUTINE
NK41     EQU   *
         L     R8,ICEADDR     ADDR OF FIRST BLOCK OF INDEX
         MVI   3(R8),X'FF'    SET CHANGE BYTE TO ONES
         MVC   22(3,R8),INDTTR  TTR OF LAST BLOCK IN INDEX
         MVC   268(22,R8),=CL22' ICE -NEU-'
NL5      EQU   *
         MVC   PROTBER+3(3),=C'OLD'  SET UP LOG ROUTINE
         MVC   INDCOMM,=CL22' GDG BLOCK VOR UNCATLG'
         LA    R8,INDTTR
         BAL   R10,UPLOG      LINK TO LOG ROUTINE
         MVC   ETTR(3),8(R2)  TTR OF NEXT GDG BLOCK
         MVC   INDKEY,OKEY    MOVE CHANGED BLOCK TO W A QUEUE
         MVI   INDCHNG,X'FF'  SET CHANGE BYTE TO ONES
         MVC   INDBLOCK(256),OBER  CHANGED BLOCK
         MVC   INDCOMM,=CL22' GDG-BLK NACH UNCATLG'
         XC    INDOFFS,INDOFFS  CLEAR OFFSET
         CLC   INDBLOCK(2),=H'0'  IS THIS BLOCK EMPTY ?
         BNE   NL4            NO. FREE BLOCK TTR REMAINS UNCHANGED
         CLC   VICE+16(3),INDTTR  UPDATE FREE BLOCK TTR IN VICE
         BNH   NL4            NO UPDATE REQUIRED
         MVC   VICE+16(3),INDTTR  TTR OF FIRST FREE BLOCK IN CATALOG
NL4      EQU   *
         CLC   ETTR(3),=3X'00'  LAST BLOCK IN INDEX ?
         BE    NL6            YES. BRANCH TO EXIT SEQUENCE
         B     NK5            READ NEXT GDG BLOCK
*
*   EXIT SEQUENCE
*
NL6      EQU   *
         L     R7,VICEADDR    ADDR OF FIRST CATALOG BLOCK
         LTR   R7,R7          IF ZERO VICE BLOCK NOT IN STORAGE
         BNZ   NL7            NONZERO
         LA    R7,NTTR        ADDR OF INPUT WORK AREA
         CLC   NTTR(3),=X'000001'  VICE IN INPUT WORK AREA ?
         BE    NL7            YES
         MVC   ETTR(3),=X'000001'  SET UP READ ROUTINE
         BAL   R10,UPLOCATE   TO READ FIRST BLOCK OF CATALOG
         BAL   R10,GETOQEL    GET WORK AREA QUEUE ELEMENT
         USING INDTTR,7
         MVC   INDTTR(3),ETTR  TTR
         MVC   INDKEY,EKEY    KEY
         MVI   INDCHNG,X'00'  CLEAR CHANGE BYTE
         MVC   INDBLOCK(256),EBER
         MVC   INDCOMM,=CL22' VICE -ALT-'
         XC    INDOFFS,INDOFFS  CLEAR OFFSET FIELD
         ST    R7,VICEADDR    SAVE ADDR OF FIRST BLOCK IN CATALOG
         CLC   VICE,INDBLOCK+2  HAS VICE BEEN CHANGED ?
         BE    NL8            NO
         B     NL9
NL7      EQU   *
         CLC   VICE,INDBLOCK+2  HAS VICE BEEN CHANGED ?
         BE    NL8            NO
NL9      EQU   *
         MVC   PROTBER+3(3),=C'OLD'  SET UP LOG ROUT
         LA    R8,INDTTR
         BAL   R10,UPLOG      LINK TO LOG ROUTINE
         MVC   INDCOMM,=CL22' VICE -NEU-'
         MVC   INDBLOCK+2(22),VICE  UPDATE VICE
         MVI   INDCHNG,X'FF'  SET CHANGE BYTE TO ONES
NL8      EQU   *
         NI    SWITCH,X'F7'   CLEAR DELETE SWITCH
         L     R10,REG10GDG  LOAD RETURN REG
         BR    R10            RETURN
         EJECT
***********************************
*                                 *
*   CATALOG UNBLOCK ROUTINE       *
*                                 *
***********************************
         SPACE
UPUNBLK  TM    ENTRY,X'FF'    ENTRY POINTER AT START POSITION ?
         BZ    UNBL1          IF YES BYPASS PTR UPDATE
         XR    R8,R8
         IC    R8,11(R2)      PICK UP HALFWORD COUNT
         SLA   R8,1(0)        HALFWORD COUNT TIMES 2
         LA    R8,12(R8)      ADD LENGTH OF FIX PART = ENTRY LENGTH
         AR    R2,R8          INCREASE INDEX POINTER BY ENTRY LENGTH
UNBL1    EQU   *
         MVI   ENTRY,X'FF'
         BR    R10            RETURN
         EJECT
****************************************
*                                      *
*   G E T   I N D E X   N A M E        *
*                                      *
****************************************
         SPACE
GETNAME  EQU   *
         MVC   GINAME,=8C' '  BLANK INDEX NAME
         L     R8,NAMEADDR    ADDR OF INDEX NAME
         TRT   0(9,R8),TPUBL  TEST FOR PERIOD/BLANK DELIM
         BZ    FEHLNAM        INDEX NAME LONGER THAN 8 BYTES
         SR    R1,R8          LENGTH OF INDEX NAME
         BZ    FEHLNAM        ZERO LENGTH NOT ALLOWED
         BCTR  R1,0           DECREASE LENGTH FOR EX
         EX    R1,MOVE2       STORE INDEX NAME INTO ENTRY AREA
         LA    R8,1(R1,R8)    UPDATE INDEX NAME POINTER
         ST    R8,NAMEADDR    AND SAVE IT
         TRT   GINAME(1),TALPHA  TEST FIRST CHAR
         BNZ   FEHLNAM        ERROR IF NON ALPHA
         TRT   GINAME+1(7),TALNUM  TEST REMAINING CHAR'S
         BZ    NF3            ERROR IF NON ALPHANUM
         EX    R2,COMP
         BNE   FEHLNAM
NF3      EQU   *
         BR    R10            RETURN
         EJECT
*******************************************************************
*                                                                 *
*   G E T   N E W   O U T P U T   Q U E U E   E L E M E N T       *
*                                                                 *
*******************************************************************
         SPACE
GETOQEL  EQU   *
         L     R7,LINDADDR    ADDR OF CURRENT ELEMENT
         GETMAIN R,LV=300     GET NEW ELEMENT
         ST    R1,0(R7)       STORE ADDR OF NEW ELEMENT
*                             INTO LINK FIELD OF PREVIOUS ELEMENT
*
         ST    R7,296(R1)     BACKWARD POINTER
         ST    R1,LINDADDR    SAVE ADDR OF NEW ELEMENT
         XC    0(4,R1),0(R1)  CLEAR LINK FIELD
         LA    R7,4(R1)       SET BASE REG FOR NEW ELEMENT
         BR    R10            RETURN
GETOQEL2 EQU   *
         ST    R10,REG10GQ   SAVE RETURN REG
         MVC   BLOCK2AD,LINDADDR  SAVE ADDR OF CURRENT ELEMENT
         MVC   LINDADDR,GLINDADR  ADDR OF LAST QUEUE ELEMENT
         BAL   R10,GETOQEL        GET NEW QUEUE ELEMENT
         MVC   GLINDADR,LINDADDR  SAVE ADDR OF LAST QUEUE ELEMENT
         MVC   LINDADDR,BLOCK2AD  ADDR OF CURRENT QUEUE ELEMENT
         L     R10,REG10GQ        RELOAD RETURN REG
         BR    R10                RETURN
GLINDADR DS    F                  ADDR OF LAST QUEUE ELEMENT
REG10GQ  DS    F                  RETURN REG SAVE AREA
         EJECT
***********************************
*                                 *
*   R E A D   R O U T I N E       *
*                                 *
***********************************
         SPACE
UPLOCATE EQU   *
         CLC   ETTR(3),=X'000001'  CALCULATE RELATIVE BLOCK ADDR
         BNE   NG1
         MVC   BLOCKADR,=3X'00'
         B     NG2
NG1      EQU   *
         LH    R8,ETTR        RELATIVE TRACK
         MH    R8,TRKCAP      TIMES TRACK CAPACITY
         XC    BLOCKNR,BLOCKNR
         MVC   BLOCKNR+1(1),EREC  PICK UP RECORD NUMBER
         AH    R8,BLOCKNR     PLUS RECORD NUMBER
         BCTR  R8,0           DECREASE IT BY 1
         ST    R8,BLOCKADR-1
NG2      EQU   *
         READ  RDECB,DI,CTLG,EBER,'S',EKEY,BLOCKADR   READ CTLG BLOCK
         CHECK RDECB
         CLC   RDECB+2(2),=2X'00'  TEST EXCEPTION BYTES
         BNE   FEHLRD         READ EXCEPTION
         BR    R10            RETURN
         EJECT
************************************************************
*                                                          *
*   F R E E   B L O C K   S E A R C H   R O U T I N E      *
*                                                          *
*   THIS ROUTINE FETCHES THE TTR OF NEXT FREE BLOCK FROM   *
*   THE VOLUME INDEX CONTROL ENTRY. THIS TTR IS INCREASED  *
*   BY 1 AND THE ROUTINE LOOKS FOR THE NEXT UNUSED BLOCK   *
*   AND RETURNS ITS TTR TO VOLUME INDEX CONTROL ENTRY.     *
*                                                          *
************************************************************
         SPACE
UPFREE   EQU   *
         ST    R10,REG10FR    SAVE RETURN REG
         MVC   ETTR(3),VICE+16  PICK UP TTR OF FIRST FREE BLOCK
NG3      EQU   *
         XR    R8,R8
         IC    R8,EREC        INSERT RECORD NUMBER
         LA    R8,1(R8)       INCREASE IT BY 1
         STC   R8,EREC        AND STORE IT INTO TTR
         CH    R8,TRKCAP      TRACK CAPACITY EXEEDED ?
         BNH   NG4            NO
         LH    R8,ETTR        YES. INCREASE TRACK ADDR
         LA    R8,1(R8)
         STH   R8,ETTR
         MVI   EREC,X'01'     AND SET RECORD NUMBER TO 01
NG4      EQU   *
         CLC   ETTR(3),VICE+12  TTR OUT OF EXTENT ?
         BH    FEHLEXT        IF YES BRANCH TO ERR ROUT
         BAL   R10,UPLOCATE   LINK TO READ ROUTINE
         CLC   EBER(10),=10X'00'  UNUSED BLOCK ?
         BNE   NG3            IF NO CONTINUE SEARCH
         MVC   VICE+16(3),ETTR  PLACE ADDR OF FREE BLOCK IN VICE
*
*   LOG FREE BLOCK
*
         MVC   PROTBER+3(3),=C'OLD'
         MVC   ECOMM(22),=CL22' FREIER BLOCK'
         LA    R8,ETTR
         BAL   R10,UPLOG      LINK TO LOG ROUTINE
         L     R10,REG10FR    RELOAD RETURN ADDR
         BR    R10            RETURN
         EJECT
***********************************
*                                 *
*   L O G   R O U T I N E         *
*                                 *
***********************************
         SPACE
UPLOG    EQU   *
         CLI   RC,X'01'                TEST RETURN CODE
         BE    0(R10)                  NO LOGGING IF NOT ZERO
         CLC   LOGEOD,LOGBLKAD-1  LOG DS FULL ?
         BNL   UPLOGB             NO
         MVI   RC,X'01'           YES. SET INDICATOR
         BR    R10                NO LOGGING
UPLOGB   EQU   *
         MVC   PROTBER(3),0(R8)  TTR
         MVC   PROTBER+6(8),4(R8)  KEY
         MVC   PROTBER+14(256),12(R8)  CATALOG BLOCK
         MVC   PROTBER+270(8),DATE     DATE TIME
         MVC   PROTBER+278(22),268(R8) TEXT
         WRITE LOGDDECB,DI,MF=E
         CHECK LOGDDECB
         BAL   R14,LOGIOW
         L     R1,LOGBLKAD-1  INCREASE REL BLOCK ADDR
         LA    R1,1(R1)
         ST    R1,LOGBLKAD-1
         BR    R10            RETURN
LOGFORM  EQU   *
*
*  FORMATTING THE LOG DATA SET
*
         CLC   GDGNAME(8),=C'*LOGFORM'
         BNE   NA12
         OPEN  (LOGC,OUTPUT)
         XC    PROTBER(256),PROTBER
         XC    PROTBER+256(44),PROTBER+256
         XC    LOGBLKAD-1(4),LOGBLKAD-1  CLEAR REL BLOCK ADDR
NA11     EQU   *
         WRITE LOGCDECB,SF,LOGC,PROTBER,'S'  WRITE DUMMY BLOCK
         ST    R15,RC    SAVE WRITE RETURN CODE
         CHECK LOGCDECB
         CLC   RC,=F'8'  PRIMARY SPACE FULL ?
         BE    NA111     YES
         L     R1,LOGBLKAD-1  INCREASE BLOCK COUNT
         LA    R1,1(R1)
         ST    R1,LOGBLKAD-1
         B     NA11
NA111    EQU   *
         CLOSE LOGC
         OPEN  (LOG,UPDAT)
         MVC   LOGEOD,LOGBLKAD-1
         XC    LOGBLKAD-1(4),LOGBLKAD-1
         READ  LOGRDECB,DI,MF=E
         CHECK LOGRDECB
         BAL   R14,LOGIOR
         MVC   PROTBER(6),=C'///FMT'
         MVC   PROTBER+6(4),LOGEOD
         MVC   PROTBER+10(4),=F'1'
         WRITE LOGDDECB,DI,MF=E
         CHECK LOGDDECB
         BAL   R14,LOGIOW
         XC    RC,RC
         MVC   LOGBLKAD-1(4),=F'1'
         B     NE5
NA12     EQU   *
         OPEN  (LOG,UPDAT)
         XC    LOGBLKAD-1(4),LOGBLKAD-1
         READ  LOGRDECB,DI,MF=E
         CHECK LOGRDECB
         BAL   R14,LOGIOR
         CLC   PROTBER(6),=C'///FMT'
         BE    NA122
         MVI   RC,X'01'
         BR    R10
NA122    EQU   *
         MVC   LOGBLKAD-1(4),PROTBER+10
         MVC   LOGEOD,PROTBER+6
         BR    R10
         EJECT
***********************************
*                                 *
*   E R R O R   R O U T I N E     *
*                                 *
***********************************
         SPACE
FEHLNAM  BAL   R7,FEHL1       ILLEGAL GDG NAME
FEHLENT  BAL   R7,FEHL1       ILLEGAL NUMBER OF ENTRIES
FEHLACT  BAL   R7,FEHL1       ILLEGAL GDG OPTION
FEHLTME  BAL   R7,FEHL1       TIME ERROR
FEHLEXT  BAL   R7,FEHL1       NO MORE FREE BLOCKS IN CATALOG
FEHLI    BAL   R7,FEHL1       UNCORRECTABLE INPUT ERROR
FEHLO    BAL   R7,FEHL1       UNCORRECTABLE OUTPUT ERROR
FEHLIRR  BAL   R7,FEHL1       MYSTERIOUS ERROR
FEHL1    EQU   *
         LA    R7,0(R7)       CLEAR HIGH ORDER BITS
         LA    R8,FEHLNAM     CALCULATE RETURN CODE
         SR    R7,R8
         A     R7,RC
         ST    R7,RC
         B     NE5            BRANCH TO TERMINATION ROUTINE
         EJECT
***********************************
*                                 *
*   S Y N A D   R O U T I N E     *
*                                 *
***********************************
         SPACE
FEHLIO   BR    R14
*
*   WRITE ERROR
*
FEHLWR   EQU   *
         MVC   RC+1(2),WDECB+2  STORE EXCEPTION CODE BITS
         B     FEHLO
*
*   READ ERROR
*
FEHLRD   EQU   *
         MVC   RC+1(2),RDECB+2  STORE EXCEPTION CODE BITS
         B     FEHLI
*
*   I/O ERROR ON LOG DATA SET
*
LOGIO    BR    R14
LOGIOR   EQU   *
         CLC   LOGRDECB+2(2),=2X'00'
         BE    0(R14)
         MVI   RC,X'02'
         CLC   RC+1(2),=2X'00'
         BNE   0(R14)
         MVC   RC+1(2),LOGRDECB+2
         BR    R14
LOGIOW   EQU   *
         CLC   LOGDDECB+2(2),=2X'00'
         BE    0(R14)
         MVI   RC,X'02'
         CLC   RC+1(2),=2X'00'
         BNE   0(R14)
         MVC   RC+1(2),LOGDDECB+2
         BR    R14
         EJECT
***********************************
*                                 *
*   D E F I N I T I O N S         *
*                                 *
***********************************
SAVE     DS    18F            SAVE AREA
WTOECB   DS    F
NAMEADDR DS    F              ADDR OF CURRENT INDEX LEVEL NAME
INSADDR DS     F              INSERT ADDR
INDADDR  DS    F              ADDR OF FIRST OUTPUT QUEUE ELEMENT
LINDADDR DS    F              ADDR OF CURRENT OUTPUT QUEUE ELEMENT
REG10FR  DS    F              SAVE AREA FOR RETURN REG
REG10GDG DS    F              SAVE AREA RETURN REG (GDGDEL)
REG1     DS    F              SAVE AREA FOR PARM REG
DOPPLW   DS    D              DOUBLE WORD FOR CVB,CVD
ICEADDR  DS    F              QUEUE ELEMENT ADDR OF CURRENT ICE
VICEADDR DS    F              QUEUE ELEMENT ADDR OF VICE
RC       DS    F  RETURN CODE
BLOCK1AD DS    F              SAVE AREA FOR ACTUAL ELEMENT ADDR
BLOCK2AD DS    F  ADDR OF CURRENT GDG BLOCK (GDGDEL)
ASIDF    DS    F  ASID
         DS    0F
         DS    C
BLOCKADR DS    CL3            RELATIVE BLOCK ADDR
         DS    0F        )    LOG REL BLOCK ADDR
         DS    C         )    LOG REL BLOCK ADDR
LOGBLKAD DS    CL3       )    LOG REL BLOCK ADDR
LOGEOD   DS    F              LOG REL BLOCK ADDR OF LAST BLOCK
TRKCAP   DS    H              TRACK CAPACITY
BLOCKNR  DS    H              RECORD NUMBER
GDGCNT   DS    H              GENERATION COUNT
KD1      DC    F'0'           CONTROL ENTRY IDENTIFIER
         DC    F'1'           BELONGS TO PREVIOUS STATEMENT
UCBADDR  DS    F              UCB ADDRESS FOR ENQ PARM LIST
*
*   PARAMETER TABLE
*
PARMTAB  EQU   *
         DC    H'44'
GDGNAME  DS    CL44           GDG NAME
         DC    H'4'
ENTRIES  DS    CL4            MAX NUMBER OF ENTRIES
         DC    H'6'
ACT      DS    CL6            GDG OPTIONS
         DC    H'0'           INDICATES END OF PARM TABLE
DATE     DS    F              DATE
TIME     DS    F              TIME
*
*   STATIC INPUT/OUTPUT AND WORK AREAS FOR SYSCTLG
*
*   1. OLD INDEX BLOCK WORK AREA
*
NTTR     DS    H              RELATIVE TRACK
NREC     DS    C              RECORD NUMBER
         DS    C
KEY      DS    CL8            KEY
CBER     DS    256C           INDEX BLOCK
COMM     DS    CL24           COMMENTS
*
*   2. INPUT AREA FOR SYSCTLG
*
ETTR     DS    H              RELATIVE TRACK
EREC     DS    C              RECORD NUMBER
         DS    C
EKEY     DS    CL8            KEY
EBER     DS    256C           INDEX BLOCK
ECOMM    DS    CL24           COMMENT
*
*   3. OUTPUT AREA FOR SYSCTLG
*
OPTR     DS    F              ADDR OF ALTERNATE OUTPUT AREA
OTTR     DS    H              RELATIVE TRACK
OREC     DS    C              RECORD NUMBER
         DS    C
OKEY     DS    CL8            KEY
OBER     DS    256C           INDEX BLOCK
OCOMM    DS    CL24           COMMENTS
*
*   4. ALTERNATE OUTPUT AREA FOR SYSCTLG
*
OPTR2    DS    F              ADDR OF DYNAMIC OUTPUT QUEUE
OTTR2    DS    H              RELATIVE TRACK
OREC2    DS    C              RECORD NUMBER
         DS    C
OKEY2    DS    CL8            KEY
OBER2    DS    256C
OCOMM2   DS    CL24           COMMENTS
*
*   IPE / GIPE WORKAREA
*
         DS    0F             FULLWORD ALIGNMENT
GIPEFLD  DS    0CL16
GINAME   DS    CL8            INDEX LEVEL NAME TO BE INSERTED
GITTR    DS    CL3            TTR OF NEW INDEX LEVEL
GICNT    DS    C              HALFWORD COUNT OF NEW ENTRY
GIFLAGS  DS    C              GDG FLAGS (GIPE ONLY)
GIMAX    DS    C              MAX NUMBER OF ENTRIES (GIPE ONLY)
GICURR   DS    CL2            CURRENT NUMBER OF ENTRIES (GIPE ONLY)
*
ENTRY    DS    C              ENTRY INDICATOR
MAJOR    DC    CL8'SYSCTLG'    ENQ MAJOR NAME
MINVICE  DC    XL12'00'        ENQ MINOR NAMES
MINVX    DC    CL12'SYSCTLG'
MINHLI   DS    CL12
MAJDSN   DC    CL8'SYSDSN'
MINDSN   DC    C'SYSCTLG'
VICE     DS    CL22           VOLUME INDEX CONTROL ENTY
ICE      DS    CL18           INDEX CONTROL ENTRY
REPLY    DS    CL4
SWITCH   DS    C              INDICATOR BYTE
*
*      .... ...1    ENQ BIT
*      .... ..1.    OVERFLOW BIT
*      .... .1..    DELETE INDEX BIT (DLTX)
*      .... 1...    IPE IN NEXT HIGHER LEVEL MUST BE DELETED
*
*
*  ENQ / DEQ PARAMETER LISTS
*
ENQHL    ENQ   (MAJOR,MINHLI,,,SYSTEM),MF=L
ENQHLS   ENQ   (MAJOR,MINHLI,,,SYSTEMS),MF=L
ENQVX    ENQ   (MAJOR,MINVX,,,SYSTEM),MF=L
ENQVXS   ENQ   (MAJOR,MINVX,,,SYSTEMS),MF=L
ENQVI    ENQ   (MAJOR,MINVICE,,,SYSTEM),MF=L
ENQVIS   ENQ   (MAJOR,MINVICE,,,SYSTEMS),MF=L
ENQDSN   ENQ   (MAJDSN,MINDSN,,,SYSTEM),UCB=UCBADDR,MF=L
DEQHL    DEQ   (MAJOR,MINHLI,12,SYSTEM),MF=L
DEQHLS   DEQ   (MAJOR,MINHLI,12,SYSTEMS),MF=L
DEQVX    DEQ   (MAJOR,MINVX,12,SYSTEM),MF=L
DEQVXS   DEQ   (MAJOR,MINVX,12,SYSTEMS),MF=L
DEQVI    DEQ   (MAJOR,MINVICE,12,SYSTEM),MF=L
DEQVIS   DEQ   (MAJOR,MINVICE,12,SYSTEMS),MF=L
DEQDSN   DEQ   (MAJDSN,MINDSN,7,SYSTEM),UCB=UCBADDR,MF=L
*
READL    READ  LOGRDECB,DI,LOG,PROTBER,'S',0,LOGBLKAD,MF=L
WRITL    WRITE LOGDDECB,DI,LOG,PROTBER,'S',0,LOGBLKAD,MF=L
MOVE1    MVC   2(0,R9),0(R8)
MOVE2    MVC   GINAME(0),0(R8)
MOVE3    MVC   0(0,R9),0(R8)
MOVE4    MVC   0(0,R9),GIPEFLD
COMP     CLI   KBL,X'00'
KBL      DC    C' '
PROTBER  DS    300C           LOG AREA
FLAG     DS    C              GDG FLAGS
*
*   T A B L E S
*
*   1. GDG OPTION TABLE
*
TACT     EQU   *
         DC    CL6' '
         DC    X'00'
         DC    CL6'SCR'
         DC    X'02'
         DC    CL6'EMP'
         DC    X'01'
         DC    CL6'SCREMP'
         DC    X'03'
         DC    CL6'EMPSCR'
         DC    X'03'
         DC    X'FF'          END OF OPTION TABLE
*
*   2. TEST TABLE PERIOD/BLANK DELIM
*
TPUBL    EQU   *
         DC    64X'00'
         DC    X'40'
         DC    10X'00'
         DC    X'4B'
         DC    180X'00'
*
*   3. TEST TABLE BLANK DELIM
*
TBL      EQU   *
         DC    64X'00'
         DC    X'40'
         DC    191X'00'
*
*   4. TEST TABLE ALPHA
*
TALPHA   EQU   *
         DC    193X'FF'
         DC    9X'00'
         DC    7X'FF'
         DC    9X'00'
         DC    8X'FF'
         DC    8X'00'
         DC    22X'FF'
*
*   5. TEST TABLE ALPHA NUMERICAL
*
TALNUM   EQU   *
         DC    64X'FF'
         DC    X'40'
         DC    128X'FF'
         DC    9X'00'
         DC    7X'FF'
         DC    9X'00'
         DC    8X'FF'
         DC    8X'00'
         DC    6X'FF'
         DC    10X'00'
         DC    6X'FF'
*
*   6. TRANSLATION TABLE FOR HEX CONVERSION
*
TTRANS   DC    X'F0F1F2F3F4F5F6F7F8F9C1C2C3C4C5C6'
*
*   D A T A   C O N T R O L   B L O C K S
*
CTLG     DCB   DDNAME=CTLG,DSORG=DA,MACRF=(RIC,WIC),OPTCD=R,           *
               RECFM=F,BLKSIZE=256,KEYLEN=8,SYNAD=FEHLIO
LOG      DCB   BLKSIZE=300,DDNAME=LOG,DSORG=DA,MACRF=(RIC,WIC),   ******
               OPTCD=RF,KEYLEN=0,RECFM=F,SYNAD=LOGIO
LOGC     DCB   BLKSIZE=300,DDNAME=LOG,DSORG=PS,MACRF=WL,RECFM=F
*
*  P A T C H     A R E A
*
         DS    0F
PATCH    DS    256C
*
*   REGISTER DEFINITIONS
*
R0       EQU   0              PARM REG
R1       EQU   1              PARM REG
R2       EQU   2              INDEX REG, UNBLOCK ROUTINE
R3       EQU   3              BASE REGISTER
R4       EQU   4              BASE REGISTER
R5       EQU   5
R6       EQU   6
R7       EQU   7              TABLE INDEX REG
R8       EQU   8              WORK REGISTER
R9       EQU   9              WORK REGISTER
R10      EQU   10             SUBROUTINES LINK REG
R11      EQU   11
R12      EQU   12
R13      EQU   13             SAVE AREA REG
R14      EQU   14             RETURN REG
R15      EQU   15             ENTRY POINT AND RETURN CODEREG
         LTORG
*
*   OUTPUT QUEUE ELEMENT
*
INDBER   DSECT
INDPTR   DS    F              ADDR OF NEXT OUTPUT QUEUE ELEMENT OR 0
INDTTR   DS    H              RELATIVE TRACK
INDREC   DS    C              RECORD NUMBER
INDCHNG  DS    C              CHANGE BYTE
INDKEY   DS    CL8            KEY
INDBLOCK DS    256C           INDEX BLOCK
INDCOMM  DS    CL22           COMMENTS
INDOFFS  DS    H              (G)IPE OFFSET
INDBACK  DS    F              ADDR OF PREVIOUS OUTPUT QUEUE ELEMENT
         DCBD  DSORG=DA,DEVD=DA
         END   MVSBLDG
*/* AN FOLGENDEN TAGEN WURDE DAS PROGRAMM GETESTET */
*/* AENDERUNG        5. JAN 1976   LEVEL G  */
*/* AENDERUNG        5. JAN 1976   LEVEL G  */
*/* NEUERSTELLUNG   20. JAN 1976   LEVEL G  */
*/* NEUERSTELLUNG   26. JAN 1976   LEVEL G  */
*/* NEUERSTELLUNG   27. JAN 1976   LEVEL G  */
*/* NEUERSTELLUNG   30. JAN 1976   LEVEL G  */
*/* NEUERSTELLUNG    3. FEB 1976   LEVEL G  */
*/* NEUERSTELLUNG    4. FEB 1976   LEVEL G  */
*/* NEUERSTELLUNG    5. FEB 1976   LEVEL G  */
*/* NEUERSTELLUNG    9. FEB 1976   LEVEL G  */
*/* NEUERSTELLUNG   10. FEB 1976   LEVEL G  */
*/* NEUERSTELLUNG   12. FEB 1976   LEVEL G  */
*/* NEUERSTELLUNG   12. FEB 1976   LEVEL G  */
*/* NEUERSTELLUNG   12. FEB 1976   LEVEL G  */
*/* NEUERSTELLUNG    1. MAR 1976   LEVEL G  */
