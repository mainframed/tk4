 S0STSRC:      /*  AUFNAHME VON MITGLIEDERN IN QUELLEN-BIBLIOTHEKEN  */

 /*********************************************************************

 AUTHOR. HUEHN.
 INSTALLATION. COLONIA, KOELN, EDV-PLANUNG.
 SCHREIBDATUM. 7.8.74.
 BEMERKUNGEN.
     DAS PROGRAMM S0STSRC DIENT ZUM AUFNEHMEN BZW. ZUM VERAENDERN VON
     MITGLIEDERN IN QUELLEN-BILIOTHEKEN.
     IN DER PARAMETER-KETTE (EXEC-ANWEISUNG: PARM='<PARAMETER>') WERDEN
     DEM PROGRAMM S0STSRC STEUERUNGSPARAMETER UEBERGEBEN.DIE PARAMETER-
     KETTE HAT FOLGENDEN AUFBAU:
         <SPR>,<NUM>,<MBR>,<ID>,<IDSW>,<LIST>

         BEDEUTUNG DER PARAMETER:

         NAME × DEFAULT × WERTE × BEDAEUTUNG
         -----+---------+-------+--------------------------------------
         SPR  × ASM     ×       × SPRACHANGABE FUER QUELLEN-BIBLIOTHEK
              ×         × ASM   ×   ASSEMBLER
              ×         × COB   ×   COBOL
              ×         × PLI   ×   PL/1
              ×         × DBD   ×   DBD (IMS)
              ×         × PSB   ×   PSB (IMS)
              ×         × FMT   ×   FORMATE (IMS)
              ×         ×       ×
         NUM  × YES     ×       × NUMERIERUNGSANGABE BEI NEUAUFNAHME
              ×         ×       × DES KOMPLETTEN MITGLIEDES, DIE ANGABE
              ×         ×       × WIRD IGNORIERT WENN IN DER EINGABE-
              ×         ×       × DATEI FUER DAS MIGLIED EINE IEBUPDTE
              ×         ×       × -'NUMBER-ANWEISUNG' VORLIEGT;
              ×         × YES   ×   JA; ANFANGSWERT 10, INKREMENT 10;
              ×         ×     BEI COBOL AUF SPALTE 1-6, SONST
              ×         ×       ×     AUF SPALTE 73-80;
              ×         × NO    ×   NEIN;
              ×         ×       ×
         MBR  × -       ×       × MITGLIEDSNAME; ANGABE WIRD IGNORIERT
              ×         ×       × WENN DER NAME-PARAMETRE IN DER IEB-
              ×         ×       × UPDTE FUNKTIONS-ANWEISUNG (ADD,REPL,
              ×         ×       × CHANGE,REPRO) IM EINGABESTROM VORHAN-
              ×         ×       × DEN IST;
              ×         ×       ×
1
         ID   × <MBR>   ×       × KENNLOCHUNG FUER COBOL-MITGLIEDER AUF
              ×         × SPALTE 73-80; GILT NUR FUER SPR=COB;
              ×         ×       ×
         IDSW × YES     ×       × SCHALTER ZUR ERZEUGUNG DER KENNLOCH-
              ×         ×       × UNG (SIEHE ID),
              ×         × YES   JA, KENNLOCHUNG EINTRAGEN;
              ×         × NO    ×   NEIN; WIRD IMMER ANGENOMMEN WENN
              ×         ×       ×   SPR>=COB!;
              ×         ×       ×

     DIE QUELLENKARTEN WERDEN UEBER DIE DATEI 'SYSIN' EINGELESEN. IST
     DIE EINGABEDATEI LEER ODER IM STEP NICHT DIFINIERT, SO WIRD DAS
     PROGRAMM S0STSRC OHNE WEITERE AKTIONEN BEENDET. DIE DATEI 'SYSIN'
     WIRD IN DIE TEMPORAERE ARBEITSDATEI 'IEBIN' DUPLIZIERT, WOBEI
     IEBUPTE-KONTROLLANWEISUNGEN ERZEUGT BZW. ERGAENZT WERDEN. WERDEN
     IN EINEM EINGABESTROM MEHRERE MITGLIEDER ANGESPROCHEN, SO MUSS AB
     DEM ZWEITEN MITGLIED EINE FUNTIONS-ANWEISUNG MIT DEM NAME-PARA-
     METER VORHANDEN SEIN. JEDE FUNKTIONS-ANWEISUNG WIRD UM DEN SSI-
     PARAMETER, DER DATUM (JJMMTT) UND UHRZEIT (HH) ANGIBT, ERGAENZT.

     DIE QUELLENBIBLIOTHEK WIRD VOR DER VERAENDERUNG DURCH 'RESERVE'
     (PROGRAMM S0STRES) VOR PARALELLEN VERAENDERUNGEN GESCHUETZT.
     DIE BIBLIOTHEKS-VERAENDERUNG WIRD VON DEM DIENSTPROGRAMM IEBUPDTE,
     DAS DYNAMISCH MIT 'LINK' (PROGRAMM P0SM26A) AUFGERUFEN WIRD, DURCH
     -GEFUEHRT. DAS PROGRAMM IEBUPDTE LIEST ALS EINGABEDATEI DIE DATEI
     'IEBIN'. SIND IM EINGABESTROM NUR 'ADD-FUNKTIONSANWEISUNGEN' ENT-
     HALTEN, SO WIRD IEBUPDTE MIT 'PARM=NEW', DIES IMPLIZIERT 'ADD' UND
     'REPL', AUFGERUFEN. SONST WIRD 'PARM=MOD' ANGENOMMEN.
     DER BIBLIOTHEKSSCHUTZ WIRD NACH DER VERAENDERUNG MIT 'DEQ'
     (PROGRAMM S0STRES) WIEDER AUFGEHOBEN

     DIE MITGLIEDER FUER DIE IMSVS.FMTSOURC (SPR=FMT) ERFORDERN EINE
     GESONDERTE VERARBEITUNG.
         IM EINGABESTROM KOENNEN QUELLENKARTEN FUER MITGLIEDER
         ENTHALTEN SEIN. DIE MITGLIEDER WERDEN DURCH DIE FMT-MAKROS
         'FMT', 'MSG', 'FMTEND' UND 'MSGEND' GETRENNT. DER MITGLIEDS-
         NAME WIRD ALS MARKENNAMEN BEI DEN 'MSG-' BZW. 'FMT-' ANWEI-
         SUNGEN ANGEGEBEN. ZUR BESTIMMUNG DER MITGLIEDSNAMEN MUESSEN
         ALLE VORLIEGENDEN ANWEISUNGEN IN DER ARBEITSDATEI 'SYSUT3'
         ZWISCHENGESPEICHERT WERDEN ZUSAETZLICH WIRD DIE DATEI 'FMT'
         ERSTELLT, IN DER COPY-' AUFRUFE FUER DIE ANSCHLIESSENDE
         FORMAT-GENERIERUNG ENTHALTEN SIND.

 *********************************************************************/
1PROCEDURE (PARM) OPTIONS (MAIN);

     DECLARE PARM        CHARACTER (100) VARYING;
     DECLARE SYSIN       FILE RECORD INPUT;
     DECLARE IEBIN       FILE RECORD OUTPUT;
     DECLARE SYSUT3      FILE RECORD;
     DECLARE FMT         FILE RECORD OUTPUT;
     DECLARE SATZ        CHARACTER (80);
     DECLARE KARTE       CHARACTER (80);
     DECLARE SPR         CHARACTER (3);
     DECLARE NUM         BIT (1);
     DECLARE MBR         CHARACTER (8) VARYING;
     DECLARE ID          CHARACTER (8);
     DECLARE IDSW        BIT (1);
     DECLARE LIST        BIT (1);
     DECLARE TNUM        BIT (1);
     DECLARE ID_DATE     BIT (1) INIT ('0'B);
     DECLARE NR          PICTURE '(8)9' INIT (0);
     DECLARE SSI         CHARACTER (8);
     DECLARE MBR_NR      FIXED BINARY INIT (0);
     DECLARE SATZ_NR     FIXED BINARY INIT (0);
     DECLARE IEB_PARM    CHARACTER (3) VARYING INIT ('NEW');
     DECLARE FEHLERKODE  FIXED BINARY (31) INIT (0);
     DECLARE TIME        BUILTIN;
     DECLARE DATE        BUILTIN;
     DECLARE P0SM26      ENTRY EXTERNAL;
     DECLARE S0STRES     ENTRY EXTERNAL;
     DECLARE BSYSUT3     BIT (1) INIT ('0'B);
     DECLARE PGM_NAME    CHARACTER (8);
     DECLARE ADD_PARM    CHARACTER (70) VARYING;
     DECLARE
         01  IEB_DD,
             02  LAENGE  FIXED BINARY (15) INIT (40),
             02  FILLER (8) FIXED BINARY (31) INIT ((8) 0),
             02  K_IEBIN CHARACTER (8) INIT ('IEBIN');
     DECLARE I           FIXED BINARY;
     DECLARE J           FIXED BINARY;
     DECLARE K           FIXED BINARY;
     DECLARE L           FIXED BINARY;
1
     ON UNDEFINEDFILE (SYSIN) GO TO ABSCHLUSS;
     ON ENDFILE (SYSIN) GO TO EINGABE_ENDE;


     CALL INITIALISIEREN;
 SCHLEIFE:
     READ FILE (SYSIN) INTO (SATZ);

     SATZ_NR = SATZ_NR + 1;
     MBR_NR = MBR_NR + 1;
     NR = NR + 10;

     IF SUBSTR (SATZ, 1, 3) = './' THEN
         CALL IEBUPDTE_SATZ;
     ELSE IF SPR ^= 'FMT' & MBR_NR = 1 THEN DO;  /* ADD-KARTE FEHLT ! */
         KARTE = SATZ;
         SATZ = './ ADD';
         CALL IEBUPDTE_SATZ;
         WRITE FILE (IEBIN) FROM (SATZ);
         SATZ = KARTE;
     END;
     IF IDSW THEN
         SUBSTR (SATZ, 73, 8) = ID;
     IF NUM THEN
               IF SPR = 'COB' & SUBSTR(SATZ,1,3) ^= './' THEN
             SUBSTR (SATZ, 1, 6) = SUBSTR (NR, 3);
         ELSE
             SUBSTR (SATZ, 73) = NR;

     IF SPR = 'FMT' THEN
         CALL FORMAT_SATZ;

     IF BSYSUT3 THEN
         WRITE FILE (SYSUT3) FROM (SATZ);
     ELSE
         WRITE FILE (IEBIN) FROM (SATZ);
     GO TO SCHLEIFE;

 EINGABE_ENDE:
     CLOSE FILE (SYSIN), FILE (IEBIN);
     IF SPR = 'FMT' THEN DO;
         KARTE = '         END';
         WRITE FILE (FMT) FROM (KARTE);
         CLOSE FILE (FMT);
         IF BSYSUT3 THEN
             CLOSE FILE (SYSUT3);
     END;
     IF SATZ_NR = 0 THEN  /* DANN WAR EINGABEDATEI LEER !! */
         GO TO ABSCHLUSS;
1    PGM_NAME = 'S0STRES';
     CALL S0STRES ('SYSUT2  ', 'RES', FEHLERKODE);
     IF FEHLERKODE > 0 THEN
         GO TO FEHLER_ABSCHLUSS;
     PGM_NAME = 'IEBUPDTE';
     CALL P0SM26 (PGM_NAME, IEB_PARM, IEB_DD, FEHLERKODE);
     IF FEHLERKODE > 0 THEN
         GO TO FEHLER_ABSCHLUSS;
     PGM_NAME = 'S0STRES';
     CALL S0STRES ('SYSUT2  ', 'DEQ', FEHLERKODE);
     IF FEHLERKODE > 0 THEN
         GO TO FEHLER_ABSCHLUSS;

 ABSCHLUSS:
     RETURN;

 FEHLER_ABSCHLUSS:
     PUT EDIT ('STSRC01F FEHLERKODE', FEHLERKODE, 'VON PROGRAMM',
         PGM_NAME, 'STSRC02I PROGRAMM S0STSRC ABGEBROCHEN')
         (SKIP, A, F (3), 2 (X (1), A), SKIP, A);
     CALL PLIRETC (FEHLERKODE);
     RETURN;
1INITIALISIEREN:
 PROCEDURE;

     I = 1;
     SPR = GET_PARM;
     NUM = GET_PARM_BIT ('1'B);
     MBR = GET_PARM;
     ID = GET_PARM;
     IF SPR = 'COB' THEN
         IDSW = '1'B;
     ELSE
         IDSW = '0'B;
     IDSW = GET_PARM_BIT (IDSW);
     IF ID = ' ' THEN
         ID = MBR;
     ELSE IF ID = 'DATE' × ID = 'DATUM' THEN DO;
         ID = PL1DATE;
         ID_DATE = '1'B;
     END;
     IF SPR ^= 'COB' & NUM THEN
         IDSW = '0'B;
     LIST = GET_PARM_BIT ('1'B);

     OPEN FILE (SYSIN), FILE (IEBIN);
     IF SPR = 'FMT' THEN DO;
         BSYSUT3 = '1'B;
         OPEN FILE (SYSUT3) OUTPUT, FILE (FMT);
     END;
     SSI = DATE ×× TIME;
     TNUM = NUM;

 END INITIALISIEREN;
1IEBUPDTE_SATZ:
 PROCEDURE;

     I = VERIFY (SUBSTR (SATZ, 4), ' ');
     IF I = 0 THEN
         RETURN;
     IF SUBSTR (SATZ, I + 3, 7) = 'NUMBER' ×
         SUBSTR (SATZ, I + 3, 7) = 'DELETE' THEN DO;
         NUM = '0'B;
         RETURN;
     END;
     ADD_PARM = '';
     IF SUBSTR (SATZ, I + 3, 4) = 'ADD' THEN
         ADD_PARM = 'ADD ';
     ELSE IF SUBSTR (SATZ, I + 3, 7) = 'CHANGE' THEN
         ADD_PARM = 'CHANGE ';
     ELSE IF SUBSTR (SATZ, I + 3, 5) = 'REPL' THEN
         ADD_PARM = 'REPL ';
     ELSE IF SUBSTR (SATZ, I + 3, 6) = 'REPRO' THEN
         ADD_PARM = 'REPRO ';
     IF ADD_PARM = '' THEN
         RETURN;
     J = LENGTH (ADD_PARM);
     IF J > 4 THEN
         IEB_PARM = 'MOD';
     IF ADD_PARM = 'ADD' × ADD_PARM = 'REPL' THEN
         NUM = TNUM;
     ELSE
         NUM = '0'B;
     ADD_PARM = ADD_PARM ×× 'SSI=' ×× SSI;
     K = INDEX (SATZ, 'NAME=');
     IF K = 0 THEN
         ADD_PARM = ADD_PARM ×× ',NAME=' ×× MBR;
     ELSE DO;
         L = INDEX (SUBSTR (SATZ, K + 5, 8), ',');
         IF L = 0 THEN
             L = INDEX (SUBSTR (SATZ, K + 5, 8), ' ');
         IF L = 0 THEN
             L = 9;
         MBR = SUBSTR (SATZ, K + 5, L - 1);
         IF IDSW THEN
             IF ^ ID_DATE THEN ID = MBR;
     END;
     IF SPR = 'COB' & INDEX (SATZ, 'SEQFLD=') = 0 THEN
         ADD_PARM = ADD_PARM ×× ',SEQFLD=016';
     IF LIST & INDEX (SATZ, 'LIST=ALL') = 0 THEN
         ADD_PARM = ADD_PARM ×× ',LIST=ALL';

     K = VERIFY (SUBSTR (SATZ, I + 3 + J), ' ');
     IF K ^= 0 THEN
         ADD_PARM = ADD_PARM ×× ',' ×× SUBSTR (SATZ, I + 2 + J + K);
     SATZ = './ ' ×× ADD_PARM;

 END IEBUPDTE_SATZ;
1FORMAT_SATZ:
 PROCEDURE;

     IF SUBSTR (SATZ, 1, 1) = '*' THEN
         RETURN;
     IF SUBSTR (SATZ, 1, 1) = ' ' THEN DO;
         I = VERIFY (SATZ, ' ');
         IF I = 0 THEN
             GO TO SCHLEIFE;
         IF SUBSTR (SATZ, I, 5) = 'COPY' THEN DO;
             KARTE = '         PRINT NOGEN';
             WRITE FILE (FMT) FROM (KARTE);
             WRITE FILE (FMT) FROM (SATZ);
             GO TO SCHLEIFE;
         END;
         IF ^ BSYSUT3 THEN
             IF SUBSTR (SATZ, I, 7) = 'MSGEND' ×
                 SUBSTR (SATZ, I, 7) = 'FMTEND' THEN DO;
                 WRITE FILE (IEBIN) FROM (SATZ);
                 OPEN FILE (SYSUT3) OUTPUT;
                 BSYSUT3 = '1'B;
                 GO TO SCHLEIFE;
             END;
     END;
     ELSE IF SUBSTR (SATZ, 1, 1) < 'A' THEN
         RETURN;
     I = INDEX (SATZ, ' ');
     IF I = 0 THEN
         RETURN;
     J = VERIFY (SUBSTR (SATZ, I), ' ');
     IF J = 0 THEN
         RETURN;
     J = I + J - 1;
     IF SUBSTR (SATZ, J, 4) ^= 'FMT' &
         SUBSTR (SATZ, J, 4) ^= 'MSG' THEN
         RETURN;
     MBR = SUBSTR (SATZ, 1, I - 1);
     WRITE FILE (SYSUT3) FROM (SATZ);
     CLOSE FILE (SYSUT3);
     BSYSUT3 = '0'B;
     SATZ = './ ADD';
     CALL IEBUPDTE_SATZ;
     WRITE FILE (IEBIN) FROM (SATZ);
     KARTE = '         PRINT NOGEN';
     WRITE FILE (FMT) FROM (KARTE);
     KARTE = '         COPY  ' ×× MBR;
     WRITE FILE (FMT) FROM (KARTE);

1    ON ENDFILE (SYSUT3) GO TO FERTIG;
     OPEN FILE (SYSUT3) INPUT;
     NR = 10;
 LESEN:
     READ FILE (SYSUT3) INTO (SATZ);
     NR = NR + 10;
     IF NUM THEN
         SUBSTR (SATZ, 73) = NR;
     WRITE FILE (IEBIN) FROM (SATZ);
     GO TO LESEN;
 FERTIG:
     CLOSE FILE (SYSUT3);
     GO TO SCHLEIFE;

 END FORMAT_SATZ;
1
 /*            PARAMETER BESTIMMEN                                   /*

 GET_PARM: /* BESTIMME NAECHSTEN POSITIONSPARAMETER */
 PROCEDURE RETURNS (CHARACTER (100) VARYING);
     DECLARE (J, K) FIXED BINARY STATIC INIT (1);

     IF I > LENGTH (PARM) THEN
         RETURN ('');
     J = INDEX (SUBSTR (PARM, I), ',');
     IF J = 0 THEN
         J = LENGTH (PARM) - I + 2;
     K = I;
     I = I + J;
     RETURN (SUBSTR (PARM, K, J - 1));

 END GET_PARM;


 GET_PARM_BIT:  /* BESTIMME NAECHSTEN BITSCHALTER-PARAMETER */
 PROCEDURE (DEFAULT) RETURNS (BIT (1));
     DECLARE DEFAULT BIT (1);
     DECLARE Z CHARACTER (1) VARYING STATIC;

     Z = GET_PARM;
     IF Z = '' THEN
         RETURN (DEFAULT);
     IF Z = 'Y' × Z = 'J' THEN
         RETURN ('1'B);
     ELSE
         RETURN ('0'B);

 END GET_PARM_BIT;
1
 PL1DATE: /* DATUM UND UHRZEIT BESTIMMEN  */

 PROCEDURE RETURNS (CHARACTER (8));

     DECLARE (DATE, TIME) BUILTIN;
     DECLARE KETTE CHARACTER (8) STATIC;
     KETTE = DATE;
     KETTE = SUBSTR (KETTE, 5, 2) ×× '.' ×× SUBSTR (KETTE, 3, 2) ××
         '.' ×× KETTE;
     RETURN (KETTE);

 PL1ZEIT:
 ENTRY RETURNS (CHARACTER (8));

     KETTE = TIME;
     SUBSTR (KETTE,3,5) = '.' ×× SUBSTR (KETTE, 3, 2) ×× '.' ××
         SUBSTR (KETTE, 5, 2);
     RETURN (KETTE);
 END PL1DATE;

 END S0STSRC;
