         MACRO
&NAME    PRIME &REG=12,&SAVE=,&ID=,&LV=0
.* PRIME WILL SAVE REGISTERS, CREATE A NEW SAVE AREA, CHAIN THE NEW
.* SAVE AREA TO THE CALLERS SAVE AREA, ESTABLISH ADDRESSABILITY,
.* OPTIONALLY OBTAIN ADDITIONAL STORAGE AND IN GENERAL PERFORM THE
.* NECESSARY ENTRY LINKAGE.
.* IF THE USER DOES NOT SPECIFY WHAT REGISTER HE REQUIRES FOR A BASE,
.* TWELVE IS USED.  NOTE..IF REG= IS SPECIFIED TO BE 0, 1, 13, 14, OR
.* 15  A WARNING MESSAGE IS ISSUED.
.* IF THE USER SPECIFIES A SAVE AREA VIA THE SAVE= OPERAND THEN PRIME
.* WILL CHAIN THE USERS SAVE AREA TO THE CALLERS SAVE AREA. IF THE
.* USER DOES NOT SPECIFY SAVE,THEN PRIME WILL OBTAIN A NEW SAVE AREA
.* VIA THE GETMAIN SVC.  AN ADDITIONAL AMOUNT OF STORAGE MAY BE
.* OBTAINED AT THIS TIME BY SPECIFIEING THE LV=, OPERAND.  IF LV IS NOT
.* SPECIFIED IN REGISTER NOTATION, 4023 IS THE MAXIMUM VALUE.
.* IF THE USER SPECIFIES SAVE=NONE, PRIME WILL NOT OBTAIN A NEW AREA.
.* REG 13 WILL POINT TO THE NEW 18 WORD SAVE AREA FOLLOWED BY THE EXTRA
.* STORAGE AREA.
         LCLA  &A,&B
         LCLC  &E,&F,&G,&H
         MNOTE *,'&REG WILL BE USED AS A BASE REGISTER'
         AIF   ('&NAME' EQ '').NONAME
&NAME    DS    0H
.NONAME  ANOP
         AIF   ('&ID' EQ '').CONT4
         AIF   ('&ID' EQ '*').SPEC
&A       SETA  ((K'&ID+2)/2)*2+4
         BAL   15,&A.(0,15)             GET PGM MASK AND BRANCH AROUND
         USING *,&REG
&A       SETA  K'&ID
         DC    AL1(&A)
.CONTB   AIF   (&A GT 32).SPLIT
.CONTAA  AIF   (&A GT 8).BRAK
&E       SETC  '&ID'(&B+1,&A)
         DC    CL&A'&E'
         AGO   .CONT1
.BRAK    ANOP
&E       SETC  '&ID'(&B+1,8)
         DC    CL8'&E'
&B       SETA  &B+8
&A       SETA  &A-8
         AGO   .CONTAA
.SPLIT   ANOP
&E       SETC  '&ID'(&B+1,8)
&F       SETC  '&ID'(&B+9,8)
&G       SETC  '&ID'(&B+17,8)
&H       SETC  '&ID'(&B+25,8)
         DC    CL32'&E.&F.&G.&H'
&B       SETA  &B+32
&A       SETA  &A-32
         AGO   .CONTB
.SPEC    AIF   ('&NAME' EQ '').CSECTN
&E       SETC  '&NAME'
&A       SETA  1
.CONTQ   AIF   ('&E'(1,&A) EQ '&E').LVE
&A       SETA  &A+1
         AGO   .CONTQ
.LVE     ANOP
&B       SETA  ((&A+2)/2)*2+4
         BAL   15,&B.(0,15)             GET PGM MASK AND BRANCH AROUND
         USING *,&REG
         DC    AL1(&A)
         DC    CL&A'&E'
         AGO   .CONT1
.CSECTN  AIF   ('&SYSECT' EQ '').E4
&E       SETC  '&SYSECT'
&A       SETA  1
         AGO   .CONTQ
.E4      IHBERMAC 78,360
.CONT4   ANOP
         BALR  15,0                     R15 NOW CONTAINS PGM MASK
         USING *,&REG
.CONT1   ANOP
         AIF   ('&REG' EQ '0' OR '&REG' EQ '1' OR '&REG' EQ '13').ERR1
         AIF   ('&REG' EQ '14' OR '&REG' EQ '15').ERR1
.CONT3   ANOP
         DS    0H
         STM   14,12,12(13)             SAVE REGS IN CALLERS AREA
         LR    &REG,15                  SET TRUE BASE EQUAL EP
         AIF ('&SAVE' EQ 'NONE').A
         AIF   ('&SAVE' EQ '').C
         AIF   ('&SAVE'(1,1) EQ '(').F
         LA    1,&SAVE                  SET R1 EQ USERS SAVE ADDRESS
         AGO   .D
.F       ANOP
         AIF   ('&SAVE' EQ '(1)').D
         LR    1,&SAVE(1)               PICK UP USERS SAVE AREA
         AGO   .D
.C       ANOP
         AIF   ('&LV'(1,1) EQ '(').E
.*         AIF   ('&LV' GT '4023').ERR2
         LA    0,(&LV.+72+15)/16        PARAMETER FOR GETMAIN
         SLL   0,4                      PARAMETER FOR GETMAIN /*8039*/
         AGO   .CONT2
.E       ANOP
         AIF   ('&LV' EQ '(0)').CONT2
         LA    0,72(&LV(1).,0)          PARAMETER FOR GETMAIN
.CONT2   ANOP
         BAL   1,*+4                    INDICATE GETMAIN
         SVC   10                       ISSUE SVC 10
         ST    0,0(0,1)                 SAVE LENGTH IN 1ST WORD
.D       ANOP
         XC    4(68,1),4(1)             CLEAR AREA
         ST    1,8(0,13)                CHAIN FORWARD
         ST    13,4(0,1)                CHAIN BACKWARD
         LM    0,1,20(13)               RESET R0 AND R1
         L     13,8(0,13)               SET SAVE AREA REGISTER
.A       ANOP
         MEXIT
.ERR1    MNOTE 'ILLEGAL BASE REGISTER SPECIFIED'
         AGO   .CONT3
.ERR2    MNOTE 'LV GT 4023, LV REQUEST NOT HONORED'
         LA    0,72(0,0)                PARAMETER FOR GETMAIN
         AGO   .CONT2
         MEND
         MACRO
&NAME    TERME &OP=,&SAVE=,&LV=0
.* TERME WILL RESTORE REGISTERS, UNCHAIN SAVE AREAS, RELEASE DYNAMIC
.* STORAGE OBTAINED BY THE PRIME MACRO, RESET THE PGM MASK AND IN
.* GENERAL PERFORM THE NECESSARY EXIT LINKAGE.
.* TERME WILL FREE THE USERS SAVE AREA PLUS THE NUMBER OF BYTES
.* SPECIFIED BY THE LV OPERAND UNLESS THE USER IMPLIES THAT THE SAVE
.* AREA WAS NOT OBTAINED VIA A GETMAIN.  THE USER IMPLIES THIS BY
.* SPECIFYING SAVE= SOME VALUE OR SYMBOL.
.* IF THE USER SPECIFIED SAVE=NONE IN THE PRIME MACRO, HE SHOULD DO
.*  THE SAME FOR TERME.
.* THE USER MAY CHOOSE TO FOLLOW THE TERME MACRO WITH THE XCTL MACRO
.* RATHER THAN BRANCH ON 14.  THE USER ACCOMPLISHES THIS BY CODING
.* OP=XCTL.
         AIF   ('&NAME' EQ '').F
&NAME    DS    0H
.F       ANOP
         AIF ('&SAVE' EQ 'NONE').C
         L     13,4(0,13)              GET PTR TO USERS AREA
         STM   0,1,20(13)               TEMPORARY SAVE OF R0 AND R1
         AIF   ('&SAVE' NE '').C
         AIF   ('&LV'(1,1) EQ '(').E
         AIF   ('&LV' EQ '0').CONT
         AIF   ('&LV' GT '4023').ERR
         LA    0,&LV.+72(0,0)           PARAMETER FOR FREEMAIN
         AGO   .CONT
.E       ANOP
         AIF   ('&LV' EQ '(0)').CONT
         LA    0,72(&LV(1).,0)          PARAMETER FOR FREEMAIN
.CONT    ANOP
         L     1,8(0,13)                GET SAVE AREA ADDRESS
         LA    1,0(0,1)                 INDICATE FREEMAIN
         AIF   ('&LV' NE '0').CONTC
         L     0,0(0,1)                 LENGTH IS IN 1ST WORD OF AREA
.CONTC   ANOP
         SVC   10                       ISSUE SVC 10
.C       ANOP
         L     14,16(0,13)              RESET
         SPM   14                       PGM MASK
         L     14,12(0,13)              RESTORE
         LM    0,12,20(13)              REGISTERS
         XC    8(4,13),8(13)            DEQUEUE SAVE AREA
         AIF   ('&OP' EQ 'XCTL').D
         BR    14                       RETURN TO CALLER
         MEXIT
.D       ANOP
         BALR  15,0                     ESTABLISH ADDRESSABILITY
         USING *,15
         MEXIT
.ERR     MNOTE 'LV GT 4023, LV REQUEST NOT HONORED'
         LA    0,72(0,0)                PARAMETER FOR FREEMAIN
         AGO   .CONT
         MEND
         MACRO
         REGS
R0       EQU   0
R1       EQU   1
R2       EQU   2
R3       EQU   3
R4       EQU   4
R5       EQU   5
R6       EQU   6
R7       EQU   7
R8       EQU   8
R9       EQU   9
RA       EQU   10
RB       EQU   11
RC       EQU   12
RD       EQU   13
RE       EQU   14
RF       EQU   15
R10      EQU   10
R11      EQU   11
R12      EQU   12
R13      EQU   13
R14      EQU   14
R15      EQU   15
         MEND
         MACRO
&SYM     SYSGET &EODAD=EODAD,&DDNAME=SYSIN,&LRECL=80,&RECFM=,          X
               &BLKSIZE=80
         AIF   (K'&SYM EQ 0).NOSYM
         AIF   (K'&SYM GT 5).ERRSYM
         AIF   (K'&DDNAME GT 8).DDNERR
         AIF   (K'&EODAD GT 8).ERREOD
       MNOTE *,'DCB = DDNAME=&DDNAME,DSORG=PS,MACRF=GL,EODAD=&EODAD'
       MNOTE *,'          DD CARD CHANGES WILL WORK FOR '
       MNOTE *,'      LRECL=&LRECL,BLKSIZE=&BLKSIZE,RECFM=&RECFM'
***********************************************************************
*        THIS MACRO COURTESY OF D.R.CHANEY, MILWAUKEE, FE-246         *
***********************************************************************
         DS    0H
&SYM     ST    14,&SYM.14 .            SAVE RETURN REG
         TM    &SYM.DCB+48,X'10' .     IS DCB OPEN
         BC    1,&SYM.1 .              YES - BYPASS OPEN CODE
         OPEN  (&SYM.DCB,(INPUT))
         TM    &SYM.DCB+48,X'10' .     DID DCB OPEN
         BC    1,&SYM.1 .              YES
         WTO   '&SYM.DCB IS NOT OPEN - CHECK DD CARD',ROUTCDE=11
         B     &SYM.EOD
&SYM.1   GET   &SYM.DCB
         L     14,&SYM.14 .            RESTORE RETURN REG
         BR    14 .                    RETURN
&SYM.XIT CLC   &SYM.DCB+62(2),=H'0' .  IS BLOCK SIZE THERE
         BNE   &SYM.3 .                IF SO SKIP
         MVC   &SYM.DCB+62(2),=H'&BLKSIZE' .MOVE IN SIZE
&SYM.3   CLC   &SYM.DCB+82(2),=H'0' .  IS LRECL HERE
         BNE   &SYM.4 .                IF SO SKIP
         MVC   &SYM.DCB+82(2),=H'&LRECL' .   MOVE IN LRECL
&SYM.4   CLI   &SYM.DCB+36,X'00' .     IS RECFM THERE
         BNE   &SYM.5 .                BRANCH IF THERE
         MVI   &SYM.DCB+36,X'90' .     MOVE IN DEFAULT RECFM FB
&SYM.5   BR    14 .                    RETURN TO OPEN
&SYM.EOD CLOSE &SYM.DCB
         FREEPOOL &SYM.DCB
         B     &EODAD .                GO TO USERS EODAD RTN
&SYM.14  DS    1F .                    RETURN REG SAVE AREA
&SYM.LST DC    X'85' .                 DCB OPEN EXIT
         DC    AL3(&SYM.XIT) .         POINTER TO XIT RTN
&SYM.DCB DCB   DDNAME=&DDNAME,DSORG=PS,MACRF=(GL),EODAD=&SYM.EOD,      ,
               EXLST=&SYM.LST,RECFM=&RECFM
         AGO   .END
.ERRSYM MNOTE 8,'8,*** LABEL ON SYSGET MACRO MUST BE LESS THAN SIX'
         AGO   .END
.NOSYM  MNOTE 8,'8,*** SYSGET MACRO MUST HAVE A LABEL'
         AGO   .END
.DDNERR MNOTE 8,'8,*** DDNAME LARGER THAN EIGHT CHARACTERS'
         AGO   .END
.ERREOD MNOTE 8,'8,*** MAXIMUM LABEL SIZE IS EIGHT CHARACTERS'
.END     MEND
         MACRO
&SYM     SYSPUT &DDNAME=SYSPUNCH,&LRECL=80,&RECFM=,&BLKSIZE=80
         AIF   (K'&SYM GT 5).ERRSYM
         AIF   (K'&SYM EQ 0).NOSYM
         AIF   (K'&DDNAME GT 8).DDNERR
       MNOTE *,'DCB = DDNAME=&DDNAME,DSORG=PS,MACRF=PM'
       MNOTE *,'             DD CARD CHANGES WILL WORK FOR'
       MNOTE *,'      LRECL=&LRECL,BLKSIZE=&BLKSIZE,RECFM=&RECFM'
***********************************************************************
*        THIS MACRO COURTESY OF D.R.CHANEY, MILWAUKEE, FE-246         *
***********************************************************************
&SYM     DS    0H
         STM   14,1,&SYM.14 .          SAVE REGS
         TM    &SYM.DCB+48,X'10' .     IS DCB OPEN
         BC    1,&SYM.1 .              YES - BYPASS OPEN CODE
         OPEN  (&SYM.DCB,(OUTPUT))
         TM    &SYM.DCB+48,X'10' .     DID DCB OPEN
         BC    1,&SYM.1 .              YES
         B     &SYM.1S
&SYM.1   L     0,&SYM.14+12 .          SET DATA REG
         PUT   &SYM.DCB,(0)
&SYM.1S  DS    0H
         LM    14,1,&SYM.14 .          RESTORE REGS
         BR    14 .                    RETURN
&SYM.XIT CLC   &SYM.DCB+62(2),=H'0' .  IS BLKSIZE THERE
         BNE   &SYM.3 .                IF SO SKIP
         MVC   &SYM.DCB+62(2),=H'&BLKSIZE' MOVE IN BLKSIZE
&SYM.3   CLC   &SYM.DCB+82(2),=H'0' .  IS LRECL THERE
         BNE   &SYM.4 .                IF SO SKIP
         MVC   &SYM.DCB+82(2),=H'&LRECL' MOVE IN LRECL
&SYM.4   CLI   &SYM.DCB+36,X'00' .     IS RECFM THERE
         BNE   &SYM.5 .                BRANCH IF THERE
         MVI   &SYM.DCB+36,X'90' .     MOVE IN DEFAULT RECFM FB
&SYM.5   BR    14 .                    RETURN TO OPEN
&SYM.14  DS    4F .                    REG SAVE AREA
&SYM.LST DC    X'85' .                 OPEN EXIT LIST
         DC    AL3(&SYM.XIT) .         ENTRY FOR OPEN EXIT
&SYM.DCB DCB   DDNAME=&DDNAME,DSORG=PS,MACRF=(PM),EXLST=&SYM.LST,      X
               RECFM=&RECFM
         AGO   .END
.ERRSYM MNOTE 8,'8,*** LABEL ON SYSPUT MACRO MUST BE LESS THAN SIX'
         AGO   .END
.NOSYM  MNOTE 8,'8,*** SYSPUT MACRO MUST HAVE A LABEL'
         AGO   .END
.DDNERR MNOTE 8,'8,*** DDNAME LARGER THAN EIGHT CHARACTERS'
.END     MEND
         MACRO
&SYM     SYSPRINT &HEADER1=,&HEADER2=,&LINES=56,&DDNAME=SYSPRINT,      X
               &RECFM=FBA,&LRECL=133,&BLKSIZE=0
         AIF   (K'&SYM EQ 0).NOSYM
         AIF   (K'&SYM GT 5).ERRSYM
         AIF   (K'&DDNAME GT 8).DDNERR
         AIF   ('&LRECL' GT '133').ERRLEN
         MNOTE *,'DCB = DDNAME=&DDNAME,LRECL=&LRECL,LINES=&LINES'
         AIF   ('&HEADER1' EQ '').HD1
         MNOTE *,'    &HEADER1 IS FIRST HEADER LINE'
         AIF   ('&HEADER2' EQ '').HD2
         MNOTE *,'    &HEADER2 IS SECOND HEADER LINE'
.HD2     MNOTE *,'    THE FIRST BYTE OF ANY BUFFER SPECIFIED WILL'
         MNOTE *,'    BE USED BY THIS ROUTINE FOR ASA CHARACTERS'
         MNOTE *,'    AND UNPREDICTABLE RESULTS MAY OCCUR IF USED.'
***********************************************************************
*        THIS MACRO COURTESY OF D.R.CHANEY, MILWAUKEE, FE-246         *
***********************************************************************
         DS    0H
&SYM     NOP   DRC&SYSNDX.C .          NOP BRANCH SET AFTER OPEN
         NOP   DRC&SYSNDX.D .          NOP BRANCH SET AFTER OPEN
         STM   14,2,DRC&SYSNDX.B .     SAVE USERS REGS
         LA    1,DRC&SYSNDX.A .        LOAD ADDRESS OF OPEN LIST
         SVC   19 .                    ISSUE OPEN SVC
         TM    &SYM.DCB+48,X'10' .     DID DCB OPEN
         BC    1,&SYM.1 .              YES
         LM    14,2,DRC&SYSNDX.B .     RESTORE REGISTERS
         BR    14
&SYM.1   DS    0H
         OI    &SYM.+5,C'0' .          SET NOP TO BRANCH
         OI    &SYM.+1,C'0' .          SET FIRST NOP TO BRANCH
         AIF   ('&HEADER1' EQ '').HD4
DRC&SYSNDX.F MVI &HEADER1,C'1' .       SET CARRIAGE CONTROL
         PUT   &SYM.DCB,&HEADER1
         AIF   ('&HEADER2' EQ '').HD5
         MVI   &HEADER2,C'-' .         SET TRIPLE SPACE AFTER SKIP
         PUT   &SYM.DCB,&HEADER2
         AGO   .HD5
.HD4     L     15,DRC&SYSNDX.B+12 .    GET POINTER TO RECORD
DRC&SYSNDX.E MVI 0(15),C'1' .            SKIP TO ONE FIRST TIME
         LA    2,&LINES.+1 .           GET LINE COUNT
         AGO   .HD55
.HD5     L     15,DRC&SYSNDX.B+12 .    PICK UP DATA POINTER
         MVI   0(15),C'0' .            SET DOUBLE SPACE AFTER SK97
         LA    2,&LINES.+1 .           PICK UP LINE COUNT
.HD55    ANOP
DRC&SYSNDX.G BCT 2,DRC&SYSNDX.H .      BR TO PRINT FOR NUMBER OF LINES
         AIF   ('&HEADER1' NE '').HD6
         B     DRC&SYSNDX.E .          START NEW PAGE
         AGO   .P4
.HD6     B     DRC&SYSNDX.F .          GO TO DO SKIP AND PRINT HDR
.P4      ANOP
DRC&SYSNDX.H PUT &SYM.DCB,(15)
         ST    2,DRC&SYSNDX.J .        SAVE THE LINE COUNT
         LM    14,2,DRC&SYSNDX.B .     RESTORE USERS REGS
         MVI   0(1),C' ' .             PLACE BLANK INTO CARRIAGE CONTR
         MVC   1(&LRECL.-1,1),0(1) .   CLEAR THE BUFFER
         BR    14 .                    RETURN
DRC&SYSNDX.D STM 14,2,DRC&SYSNDX.B .   SAVE REGS ALWAYS
         AIF   ('&HEADER1' EQ '').P6
         B     DRC&SYSNDX.F .          GO TO HEADER ROUTINE
         AGO   .P5
.P6     ANOP
         L     15,DRC&SYSNDX.B+12 .    PICK UP POINTER TO DATA
         B     DRC&SYSNDX.E .          GO TO HEADER RTN
.P5      ANOP
DRC&SYSNDX.C STM 14,2,DRC&SYSNDX.B .   SAVE REGS ALWAYS
         L     2,DRC&SYSNDX.J .        RESTORE THE LINE COUNTER
         L     15,DRC&SYSNDX.B+12 .    PICK UP POINTER TO DATA
         MVI   0(15),C' ' .            MOVE X'40' TO ASA
         B     DRC&SYSNDX.G .          GO TEST FOR LINE COUNT
DRC&SYSNDX.M CLC &SYM.DCB+62(2),=H'0' . IS BLOCK SIZE THERE
         BNE   DRC&SYSNDX.L .          IF SO SKIP
         MVC   &SYM.DCB+62(2),=H'&LRECL'  .     MOVE IN DEFAULT SIZE
DRC&SYSNDX.L BR 14 .               RETURN TO OPEN
DRC&SYSNDX.B DS 5F .                   PRINT RTNS SAVE AREA
DRC&SYSNDX.J DS 1F .                   SAVE FOR LINE COUNTER
DRC&SYSNDX.K DC X'85' .                EXIT LIST FOR OPEN
         DC    AL3(DRC&SYSNDX.M) .     POINTER TO THE EXIT ROUTINE
DRC&SYSNDX.A DC AL1(143) .             OPTION BYTE FOR OPEN
         DC    AL3(&SYM.DCB) .         DCB ADCON FOR OPEN
&SYM.DCB DCB   DDNAME=&DDNAME,LRECL=&LRECL,RECFM=&RECFM,DSORG=PS,      X
               MACRF=(PM),EXLST=DRC&SYSNDX.K,BLKSIZE=&BLKSIZE
         MEXIT
.HD1     AIF   ('&HEADER2' EQ '').HD2
         MNOTE 8,'8,*** HEADER2 INVALID WITHOUT HEADER1 SPECIFIED'
         MEXIT
.ERRLEN MNOTE 8,'8,*** LRECL TOO LARGE FOR SYSPRINT'
         MEXIT
.NOSYM  MNOTE 8,'8,*** SYSPRINT MACRO MUST HAVE A LABEL'
         MEXIT
.ERRSYM MNOTE 8,'8,*** LABEL ON SYSPRINT MACRO MUST BE LESS THAN SIX'
         MEXIT
.DDNERR MNOTE 8,'8 *** MAXIMUM DDNAME SIZE IS EIGHT CHARACTERS'
         MEXIT
.BUFERR  MNOTE 8,'8,*** NO BUFFER SUPPLIED, EXECUTION IMPOSSIBLE'
.END     MEND
TSGTFMAP TITLE 'TSGTFMAP-SHOW DISK USAGE FROM GTF DATA - 5/20/78'
***********************************************************************
* DESC: READ GTF DATA AND SUMMARIZE DASD SIO/IO RECORDS.
*        BY DEVICE: CALCULATE NUMBER SIO CC = 0-3,
*              TOTAL CYLINDERS SEEKED,
*              AVERAGE CYLINDERS SEEKED,
*              AVERAGE IO TIME,
*              MAX. IO TIME OVER RUN,
*              BUILD TWO ARRAYS FOR DRIVE/JOB STATS.
*              OPTIONALLY PRODUCE A HISTOGRAM OF SEEKS
*
*        DRIVE ARRAY:
*        SLOT SIZE(IN CYLINDERS) = ((LINESIZE-OFFSET)/
*              (#DIGITS DISPLAYED PER SLOT))
*        EXAMPLE: ((133-11)/3)=40 SETS OF NUMBERS CAN FIT
*              ON A LINE.
*        THIS ARRAY IS USED AS FOLLOWS:
*         DT(N,M)=DT(N,M)+1 WHERE:
*          N=FROM SLOT #,
*          M=TO   SLOT #.
*         IF HISTOGRAM OPTION IS USED, ARRAY IS NOW A VECTOR.
*          DT(N)=DT(N)+1 WHERE N IS CYL #.
*
*        JOB ARRAY:
*        JOB TABLE IS AN N BY N MATRIX,
*           WHERE N IS NUMBER OF JOBS IN INCORE TABLE.
*        THIS ARRAY IS USED AS FOLLOWS:
*         JT(N,M)=JT(N,M)+1 WHERE:
*          N=JOB# THAT WAS HELD UP.
*          M=JOB# THAT HELD JOB N UP.
*         HELD UP MEANS JOB N HAD TO SEEK MORE THAN 'SEEKINTF' CYLS.
*
*        JCL:  //MAP EXEC PGM=TSGTFMAP,REGION=(100K+6K*#DASD),
*              // PARM=XXXX WHERE XXXX=HIST OR MATR, DEFAULT=HIST
*              //* MATR=MATRIX OPTION, HIST=HISTOGRAM OPTION.
*              //SYSPRINT DD SYSOUT=C
*              //SYSUT1   DD DSN=GTFDATA,DISP=SHR
*        SUMMARY OF CHANGES FOR 5/20/78:
*              CYLINDER SEEK HISTOGRAM
*              CSW BREAKDOWN FOR SIO CC=1
*              DYNAMIC INITIALIZATION OF MAXIMUM # DASD SUPPORTED
*              SOME INITIAL CODE FOR AN I/O CONCURRENCE (NOT WORKING)
*        QUESTIONS:
*              CLARK HUNTER  PHONE: 313-497-0524/0533.
*              CHRYSLER SERVICE AND PARTS SUPPLY DIVISION
*              26311 LAWRENCE AVENUE
*              CENTERLINE, MICHIGAN  48015
*               CIMS: 423-10-17
***********************************************************************
         LCLB  &NOXYTEX       IF CALCOMP/XYTEX IN SYSTEM
&NOXYTEX SETB  1                   CALCOMP ATL IN SYSTEM
*        I AM USING THEIR PROPRIETARY DATE/TIME SUBROUTINE
TSGTFMAP CSECT                      GTF DISK USAGE MAPPER
         PRINT NOGEN                SAVE PAPER/TREES
         REGS                       SYMBOLIC REGS
         PRIME ID=*,LV=DSASIZE      SET UP SAVE AREAS/CHAIN/BASING
         USING DSA,R13              SAVE AREA / WORKING STORE
         USING DVTAB,R11            DEVICE TABLE POINTER
         USING GTFREC,R10           GTF RECORD POINTER
         ST    R1,PARMSAVE         SAVE PARM LIST PTR
         LA    R9,GETREC           SET STATIC AREA
         LA    R9,(STATIC-GETREC)(R9) "
         USING STATIC,R9           TELL ASM
         B     SETUP                GO TO SETUP
GETREC   DS    0H                   GET NEXT GTF RECORD
         BAL   R14,GET             GET GTF RECORD
         LR    R10,R1              COPY ADDR PTR
         CLC   GTLEN,=H'65'        MIN LENGTH HANDLED
         BL    BYPASS              TOO SHORT
         CLI   GTID,X'FF'          TRACE RECORD ID
         BNE   BYPASS              NO-SKIP
         CLI   GTFMT,0             FORMAT IDENTIFIER
         BNE   BYPASS              NO-BYPASS
         CLC   GTEVNT,=X'5100'     SIO REC
         BE    SIOREC              YES
         CLC   GTEVNT,=X'5200'     I/O W/ VALID UCB
         BE    IOREC               YES
         CLC   GTEVNT,=X'2100'     PCI I/O
         BE    IORECPCI            YES
         CLC   GTEVNT,=X'5201'     I/O W/O VALID UCB
         BE    IORECBAD            YES-BAD
         B     BYPASS              ALL ELSE FAILS TOO
IORECPCI DS    0H                  PCI
         AP    TOTPCI,=P'1'        BUMP
         B     GETREC              LOOP
IORECBAD DS    0H                  I/O W/O VALID UCB
         AP    TOTBAD,=P'1'        BUMP
         B     GETREC              LOOP
BYPASS   DS    0H                  BYPASSED RECORD(MANY REASONS)
         AP    TOTBYPAS,=P'1'      BUMP CTR
         B     GETREC              LOOP
         TITLE '              I / O  R E C O R D '
IOREC    DS    0H
         AP    TOTIO,=P'1'          BUMP TOT
         LH    R11,GTIDEV           GET DEV ADDR
         BAL   R14,UTGET            LOCATE DEVICE TABLE PTR
         B     GETREC               +0 RETURN = NOT FOUND
         OC    DVLTIME,DVLTIME      IS THERE A PREV SIO REC.
         BZ    IODEFR               NO - SEE IF ANY IO WAS DEFERED
         ICM   R0,15,GTTIME         GET IO TIME
         ICM   R1,15,GTTIME+4       GET IO TIME
         LM    R2,R3,DVLTIME       GET SIO TIME
         XC    DVLTIME,DVLTIME      SHOW NO SIO TIME
         XC    DVL0TIME,DVL0TIME    SHOW NO SIO TIME
         BAL   R14,UTTIMDIF        CALC TIME DIF IN MILLISEC*10
         C     R1,DVMAXIO           CHECK AGAINST MAX SO FAR
         BL    *+8                  NO - SKIP
         ST    R1,DVMAXIO           YES-SAVE NEW MAX
         LR    R0,R1               SAVE VALUE
         AL    R1,DVAVGIO           ADD IO TIME TO TOTAL
         ST    R1,DVAVGIO           STORE
         LH    R15,DVLJOBI         GET LAST JOB INDEX
         AL    R0,DVJTIOTM(R15)    ADD TO LAST JOBS TIME
         ST    R0,DVJTIOTM(R15)    UPDATE
*        CALC DEFERED I/O TIMES
IODEFR   DS    0H                  CALC HOW LONG LAST SIO.NE.ZERO
         BAL   R14,UTDEFR          CALC DEFER TIME
         B     GETREC              NEXT RECORD
         TITLE '               S I O  R E C O R D'
SIOREC   DS    0H                   PROCESS SIO RECORD
         MVC   STOPTM,GTTIME       SAVE TIME(LAST GTF RECORD@EOD)
         AP    TOTSIO,=P'1'         BUMP TOT
         XR    R11,R11
         ICM   R11,3,GTSDEV         GET ADDR
         BAL   R14,UTGET            GET DEVICE TABLE PTR
         B     GETREC               +0=NOT FOUND
         BAL   R14,UTDEFR          CALC DEFER TIME IF ANY
         BAL   R14,UTFNDJOB        LOCATE INDEX IN JOB TABLE
         IC    R1,GTSIOCC           GET SIO CC
         N     R1,=X'00000030'      MASK
         SRL   R1,2                 SHIFT R 2 TO GET SIOCC*4
         LA    R15,TOTSIO0(R1)     GET PACKED CTR
         AP    0(L'TOTSIO0,R15),=P'1' BUMP
         L     R15,DVSIO0(R1)       BUMP SIO CTR
         AH    R15,=H'1'            "
         ST    R15,DVSIO0(R1)       "
         CH    R1,=AL2(1*4)        SIO CC=1?
         BNE   SIO1END             NO
         LA    R0,(DVSIO1XE-DVSIO1XS)/(DVSIO1XL) # ENTRIES
         LA    R14,DVSIO1XS        START OF STATUS CODES
SIO1LOC  DS    0H                  FIND MATCH OR ADD NEW CODE
         CLC   GTSSTAT,DVSIO1XS-DVSIO1XS(R14)
         BE    SIO1UPD             YES-BUMP COUNTERS
         CLC   DVSIO1XS-DVSIO1XS(L'DVSIO1XS,R14),=H'0' ZERO
         BZ    SIO1UPD             END-OF-TABLE - ADD NEW ENTRY
         LA    R14,DVSIO1XL(R14)   TRY NEXT
         BCT   R0,SIO1LOC          LOOP
         B     SIO1END             NOMATCH AND TABLE FULL - * SKIP *
SIO1UPD  DS    0H                  ADD OR BUMP ENTRY
         MVC   DVSIO1XS-DVSIO1XS(L'DVSIO1XS,R14),GTSSTAT ADD/OVLY DATA
         ICM   R15,15,DVSIO1XC-DVSIO1XS(R14) BUMP COUNTER
         AH    R15,=H'1'
         STCM  R15,15,DVSIO1XC-DVSIO1XS(R14) BUMP COUNTER
SIO1END  DS    0H
         LR    R14,R1              GET SIO CC
         MH    R14,=AL2(JT#)       * ROW SIZE = SIO ROW XX (INDEX)
         AH    R14,DVCJOBI         ADD CURRENT JOB INDEX 0,4,8...
*                                   =SIO(SIOCC,JOB)
         L     R15,DVJTSIO0(R14)   BUMP SIO CC BY 1
         AH    R15,=H'1'           "
         ST    R15,DVJTSIO0(R14)
         LTR   R1,R1                SIO CC = 0
         BNZ   SIO1REC              NO - NEXT PHASE
         MVC   DVL0TIME,GTTIME     REMEMBER LAST SIO0 FOR CONCURRENCE
         ICM   R1,3,GTSSEEK+3       GET SEEK CYL
         CLI   PRTOPT,C'H'         HISTOGRAM OPTION?
         BNE   SIOMATRX            NO-CALC ADDR IN SEEK MATRIX
**       HISTOGRAM - JUST GO DOWN TO CYL ENTRY IN VECTOR
         SLL   R1,2                CYL# * 4 = OFFSET IN VECTOR
         L     R0,DVXREF(R1)       GET CURRENT SEEK COUNT
         AH    R0,=H'1'            BUMP
         ST    R0,DVXREF(R1)       UPDATE
         B     SIOSKPX             GO AROUND MATRIX CODE
SIOMATRX DS    0H
         LH    R15,DVDELTA          GET SLOT SIZE IN CYL
         BAL   R14,DIVIDE           CALC SLOT #
         SLL   R1,2                SLOT# * 4
         L     R15,DVLROW          LAST ROW ADDR IN SEEK ARRAY
         AR    R15,R1              + OFFSET = ENTRY
         L     R0,0(R15)           DT(FROM,TO)=DT(FROM,TO)+1
         AH    R0,=H'1'            "
         ST    R0,0(R15)           "
         MH    R1,DVSLOTS          CALC NEW FROM ROW ADDR
         LA    R1,DVXREF(R1)       "
         ST    R1,DVLROW           SAVE FOR NEXT SIO
SIOSKPX  DS    0H
         XR    R0,R0
         ICM   R0,3,DVLSEEK+3      LAST SEEK CYL
         SH    R0,GTSSEEK+3        CALC DIFFERENCE
         LPR   R0,R0               POSITIVE
         LR    R3,R0               SAVE FOR JOB ARRAY
         A     R0,DVTOTCYL         BUMP TOT CYL SEEKED
         ST    R0,DVTOTCYL         "
         LR    R0,R3               REFRESH
         LH    R1,DVCJOBI          GET CURR INDEX
         A     R0,DVJTSEEK(R1)     BUMP JOB'S CYL SEEKED
         ST    R0,DVJTSEEK(R1)     "
*        UPDATE JT TABLE
         CH    R3,SEEKINTF         CYL SEEKED ENOUGH ?
         BL    SIONOINT            NO - JOB NOT HELD UP
         LH    R1,DVLJOBI          GET LAST JOB #(CAUSED PROB)
         LH    R14,DVCJOBI         GET CURRENT JOB INDEX
         MH    R14,=AL2(JT#)       *L'=OFFSET TO ARRAY ROW
         LA    R14,DVJTXREF(R14)    + BASE ADDR = ROW ADDR
         L     R2,0(R14,R1)        JT(N,M)=JT(N,M)+1
         AH    R2,=H'1'            "
         ST    R2,0(R14,R1)        "
SIONOINT DS    0H                  UPDATE FILEDS
*        UPDATE HOLD INFO
         MVC   DVLJOBI,DVCJOBI     LAST JOB INDEX
         MVC   DVLSEEK,GTSSEEK     LAST SEEK
         MVC   DVLJOB,GTJOB        LAST JOB
         MVC   DVLTIME,GTTIME      LAST TIME
         B     GETREC              LOOP
*        SIO 1 AND 2 RECORDS
SIO1REC  DS    0H                  SEE IF IO HAD TO BE DEFERED
         MVC   DVLJOBI,DVCJOBI     UPDATE LAST JOB INDEX
         CH    R1,=H'3'            SIO=3 NOT OPERATIONAL
         BE    SIORET              YES-RETURN
         MVC   DVDEFRTM,GTTIME     SAVE TIME
*        I/O INTERRUPT WILL BE STOP OF DEFERED TIME
*        - OR SIO CC=0 WILL BE STOP OF DEFERED TIME
SIORET   DS    0H                  END OF SIO PROCESSING
         B     GETREC
         TITLE '             S E T U P'
SETUP    DS    0H
*        CALC NUMB OF ONLINE DASDS IN SYSTEM
         L     R4,16               CVT
         L     R4,CVTILK2(R4)      LOOKUP2
         LA    R0,1                ONE SPOT FOR DUMMY ENTRY
         XR    R6,R6
SETMXDA  DS    0H
         LA    R4,2(R4)            NEXT UCB(1ST UCB NOT DASD)
         ICM   R6,3,0(R4)          GET UCB ADDR
         BZ    SETMXDA             HOLE-LOOP
         CLC   =X'FFFF',0(R4)      END OF TABLE-SET MAX DASD
         BE    SETMXEND
         CLI   UCBDVCLS(R6),X'20'  DASD
         BNE   SETMXDA             NO-SKIP
         TM    UCBSTAT(R6),X'80'   ONLINE
         BNO   SETMXDA             NO-SKIP
*        NOW SEE IF THIS IS PRIMARY PATH
         L     R2,16
         L     R2,CVTILK2(R2)      CVT LOOKUP
         XR    R3,R3
SETMXDUP DS    0H
         LA    R2,2(R2)            NEXT UCB PTR
         ICM   R3,3,0(R2)          GET UCB ADDR
         BZ    SETMXDUP
         CLC   =X'FFFF',0(R2)      END
         BE    SETMXINC            YES-STRANGE??
         CR    R3,R6               SAME UCB
         BNE   SETMXDUP            NO-TRY AGAIN
         CR    R2,R4               SAME UCB PTR
         BNE   SETMXDA             NO-MUST HAVE HIT 1ST PATH ALREADY
SETMXINC DS    0H
         AH    R0,=H'1'            BUMP NUMB OF ONLINE DASDS
         B     SETMXDA             NEXT
SETMXEND DS    0H
         STH   R0,DVMAX            SET SYSTEM MAX DASD
         ZAP   PACKS(4),=P'0'      ZERO FIRST PACKED COUNTER
         MVC   PACKS+4(PACKE-PACKS-4),PACKS  ZERO REST (64 MAX)
         MVI   HDR1,C' '           BLANK HDR
         MVC   HDR1+1(L'HDR1-1),HDR1  "
         MVI   HDR1,C'1'           SKIP CHAN 1 ASA
         AIF (&NOXYTEX).NOX1
         MVI   DTVFLAG,GETDATE     CALCOMP DATE UTILITY
         CALL  XYUTDTTM,(DTV)      "
         MVC   HDRDATE,REPTFORM    DATE
         MVC   HDRTIME,DTVCHR      TIME
.NOX1    ANOP
         MVC   HDRTITLE,LOGO       MOVE HEADER
         LA    R1,HDR1             GET HDR
         BAL   R14,PUT             1ST WRITE CAUSES OPEN
         MVC   LINESIZE,PUTDCB+X'52' COPY LRECL
*        SET REPORT FORMAT
         MVI   PRTOPT,C'H'         DEFAULT (H=HISTOGRAM,M=MATRIX)
         L     R1,PARMSAVE         GET O/S PARM
         L     R1,0(R1)            GET JCL PARM
         CLC   =H'4',0(R1)         MIN LENGTH
         BH    SETPREND            NO-USE DEFAULT
         MVI   PRTOPT,C'M'         SET MATRIX OPTION
         CLC   =C'MATR',2(R1)      MATRIX
         BE    SETPREND            YES-LEAVE 'M' IN
         MVI   PRTOPT,C'H'         HISTOGRAM
         CLC   =C'HIST',2(R1)
*        BE    SETPREND            YES-LEAVE 'H' (ENABLE-MORE OPTIONS)
SETPREND DS    0H
         LH    R0,LINESIZE         GET LINE SIZE
         AH    R0,=H'10'           + 10
         GETMAIN R,LV=(0)          GET PRINT LINE
         ST    R1,@PL              SAVE ADDR
         LH    R1,STMAXDSP         DIGITS IN DEVICE ARRAY DISPLAY
         XR    R0,R0               CLEAR
SETOVFLO DS    0H                  CALC LARGEST DISPLAY NUMBER (999)
         MH    R0,=H'10'           SHIFT LEFT 1 DECIMAL
         AH    R0,=H'9'            ADD 9
         BCT   R1,SETOVFLO         LOOP TO GET STMAXDSP 9(S)
         ST    R0,EODOVFLO         SAVE 999
*        SETUP MOVE INSTR FOR SEEK COUNT
         MVC   EXMVC,MVC           MOVE MODEL
         MVC   EXMVC2,MVC2         MOVE MODEL OF *** MOVE
         MVC   EXMVC3,MVC          MOVE MODEL FORM EDIT AREA
         LH    R6,EXMVC+4          GET END OF EDIT AREA
         N     R6,=X'0000FFFF'     CLEAR TO S TYPE CON
         SH    R6,STMAXDSP         BACK UP BY DISPLAY DIGITS
         STCM  R6,3,EXMVC+4        SAVE S-TYPE ADDR OF EDIT AREA
         AH    R6,STMAXDSP         GET BACK TO ORIG. S-TYPE
         SH    R6,STJOBDSP         BACK UP FOR JOB DISPLAY DIGITS
         STCM  R6,3,EXMVC3+4       SAVE S-TYPE
         LH    R0,STMAXDSP         GET # DISPLAY DIGITS
         BCTR  R0,0                -1
         STC   R0,EXMVC+1          PUT IN MVC INSTR
         STC   R0,EXMVC2+1
         LH    R0,STJOBDSP         GET JOB ARRAY DISPLAY DIGITS
         BCTR  R0,0                -1
         STC   R0,EXMVC3+1         SET MVC L'
         LH    R0,DVMAX            MAX DEVICES
         MH    R0,DVMAX            SQUARE FOR TABLE
         SLL   R0,2                4 BYTE ENTRIES
         GETMAIN                   R,LV=(0) GET CONCURRENCE TABLE
         ST    R1,DVCONTAB         SAVE ADDR
         BAL   R14,CLRIT           ZERO IT OUT
*        CALC. # OF SLOTS FOR A DRIVE
         LH    R1,LINESIZE         GET LINE SIZE
         SH    R1,LINEOFST         -MARGIN INFO
         LH    R15,STMAXDSP        GET # DISPLAY DIGITS
         BAL   R14,DIVIDE          CALC # SLOTS ON A LINE
         STH   R1,DVSLOTS          SAVE IT
         MH    R1,DVSLOTS          SQUARE FOR DEVICE ARRAY
         CLI   PRTOPT,C'H'         HISTOGRAM
         BNE   SETSIZE             NO
         LH    R1,MAXCYL           YES-4BYTE ENTRIES PER CYL
SETSIZE  DS    0H
         SLL   R1,2                *4BYTES/COUNTER
         LA    R1,DVFIXSIZ(R1)     +FIX PREFIX SIZE
         ST    R1,DVSIZE           =SIZE OF A DEVICE ENTRY(6K)
*        GET DEVICE VECTOR TABLE
         LH    R0,DVMAX            GET MAX DEVICES
         MH    R0,=AL2(DVVSIZ)     *SIZE OF VECTOR TABLE ENTRY(6)
         ST    R0,DVVSIZE          SAVE SIZE
         GETMAIN R,LV=(0)          GET TABLE
         ST    R1,DVVROOT          SAVE ADD
         BAL   R14,CLRIT           CLEAR CORE
*        SEARCH FOR DASD UCBS TO FILL VECTOR TABLE
         L     R1,DVVROOT          GET START OF VECTOR TABLE
         A     R1,DVVSIZE          +SIZE=END+1
         SH    R1,=AL2(DVVSIZ)     BACKUP TO LAST
         MVI   0(R1),X'FF'         MARK LAST
*        SEARCH UCB LOOKUP TABLE FOR DASDS
         L     R4,16               CVT
         L     R4,CVTILK2(R4)      LOOKUP2
         L     R5,DVVROOT          MY LOOKUP TABLE
         USING DVVTAB,R5           TELL ASM
         XR    R6,R6               CLEAR
SETDASD  DS    0H                  LOOK FOR DASD
         LA    R4,2(R4)           NEXT UCB PTR(ASSUME 1ST UCB NOT DASD)
         ICM   R6,3,0(R4)          UCB ADDR
         BZ    SETDASD             HOLE - LOOP
         CLC   0(2,R4),=X'FFFF'    END
         BE    SETDASDE            YES-NEXT SECTION
         CLI   UCBDVCLS(R6),X'20'  DASD
         BNE   SETDASD             NO-LOOP
         L     R2,16               YES-SEE IF ANOTHER CHAN PATH
         L     R2,CVTILK2(R2)      LOOKUP TABLE
         XR    R3,R3               CLEAR
SETDASD1 DS    0H                  SEE IF ANOTHER PATH
         LA    R2,2(R2)            UCB PTR
         ICM   R3,3,0(R2)          UCB ADDR
         BZ    SETDASD1            HOLE-LOOP
         CLC   0(2,R2),=X'FFFF'    END - NO 2ND PATH
         BE    SETDASD
         CR    R3,R6               SAME UCB?
         BNE   SETDASD1            NO-LOOP
         CR    R2,R4               SAME PTR?
         BNE   SETDASD             NO-ANOTHER PATH
         TM    UCBCHAN+1(R6),X'07' SEE IF 1ST DRIVE IN STRING
         BNZ   SETNSTR             NO
         L     R0,STSIZ#           GET CURRENT NUMB OF STRINGS
         AH    R0,=H'1'            BUMP
         ST    R0,STSIZ#
SETNSTR  DS    0H                  END-OF-STRING CALC
         TM    UCBSTAT(R6),X'80'   DASD ONLINE?
         BNO   SETDASD             NO-SKIP IT
         LA    R14,STCYLS          GET MY DEVICE CHAR TABLE
SETDEVCK DS    0H                  LOC DEVICE ATTR
         CLC   0(1,R14),UCBUNTYP(R6)  MATCH ON UCB TYPE
         BE    SETDEVOK            YES - GOOD DEV
         LA    R14,STCYLS1-STCYLS(R14)  BUMP
         CLI   0(R14),X'FF'        END OF TABLE
         BE    SETDASD             YES-SKIP HIM
         B     SETDEVCK            LOOP
SETDEVOK DS    0H                  GOOD DASD
         CLI   0(R5),X'FF'         ROOM FOR THIS ONE
         BE    ABEND1XX            NO-PROGRAM BUG
         STCM  R6,3,DVVUCB         SAVE UCB ADDR
         LA    R5,DVVSIZ(R5)       BUMP PTR
         B     SETDASD
ABEND1XX ABEND 1,DUMP              NO-BLOW
SETDASDE DS    0H                  NOW BUILD DEVICE TABLES
         S     R5,DVVROOT          BACK UP TO LAST BUILT
         LR    R1,R5               PUT IN WORK
         LA    R15,DVVSIZ          SIZE OF VECTOR ENTRY
         BAL   R14,DIVIDE          GET # GOOD DASDS IN SYS
         LR    R0,R1               PUT IN WORK
         MH    R0,DVSIZE+2         *DEVICE ENTRY SIZE(6K)
         GETMAIN R,LV=(0)          GET DEVICE TABLE
         LR    R11,R1              SET PTR TO FIRST
         BAL   R14,CLRIT           CLEAR CORE
         L     R5,DVVROOT          GET VECTOR PTR
SETDT    DS    0H                  BUILD DEVICE ENTRIES
         ICM   R6,3,DVVUCB         GET UCB ADDR
         BZ    SETTM               END-OF-TABLE
         ST    R11,DVVPTR          STORE PTR TO DEVICE ENTRY
         MVC   DVUCB,UCBNAME(R6)   MOVE DISPLAY ADDR
         MVC   DVVOLI,UCBVOLI(R6)  MOVE VOLSER
         STCM  R6,3,DVUCBPTR       STORE UCB ADDR IN DEV TABLE
         LR    R1,R11              WORK
*        CALC # OF CYLS IN A SLOT
         LA    R14,STCYLS          DEVICE CHAR TABLE
SETCYLLP DS    0H                  LOOK FOR DEVICE
         CLC   0(1,R14),UCBUNTYP(R6)  MATCH
         BE    SETCYL              YES-LOAD
         LA    R14,STCYLS1-STCYLS(R14) BUMP
         CLI   0(R14),X'FF'        END - ?
         BNE   SETCYLLP            NO - LOOP
SETCYL   DS    0H                  SET UP DEVICE CHAR
         MVC   DVTYPE,(STCYLNAM-STCYLS)(R14)  NAME (3330)
         MVC   DVTRK,(STCYLTRK-STCYLS)(R14)  TRACKS PER CYL
         LH    R15,DVSLOTS         GET # OF SLOTS
         LH    R1,(STCYLMAX-STCYLS)(R14)   GET # CYLS ON PACK
         CH    R1,MAXCYL           CHECK AGAINST DEVICE LIMIT
         BNH   SETCYLOK            OK
         ABEND 2,DUMP              INCREASE 'MAXCYL'
SETCYLOK DS    0H
         BAL   R14,DIVIDE          STRAIGHT DIVIDE
         AH    R1,=H'1'            ROUND UP TO HANDLE PARTIAL
         STH   R1,DVDELTA           ROW
         LA    R15,DVXREF          GET START OF DEVICE ARRAY
         ST    R15,DVLROW          SAVE AS LAST ROW SEEKED
         LA    R5,DVVSIZ(R5)       NEXT DEVICE VECTOR PTR
         A     R11,DVSIZE          NEXT DEVICE ENTRY
         B     SETDT               DO NEXT DEVICE
         DROP  R5                  TELL ASM
MVC2     MVC   0(*-*,R5),=CL10'**********'  OVERFLOW MODEL INSTR
MVC      MVC   0(*-*,R5),WE+L'WE   MODEL FOR MOVE IN REPORT
*        GET START TIME OF GTF RUN
SETTM    DS    0H                  GET TIEM
         BAL   R14,GET             READ A RECORD
         LR    R10,R1              COPY TO DSECT REG
         CLI   GTID,0              CONTROL RECORD
         BNE   SETBAD              WRONG
         CLI   GTFMT,X'01'         FORMAT ID
         BNE   SETBAD              WRONG
         MVC   STRTTM,GTCRTOD      SAVE TIME
         B     SETST               GO TO NEXT PHASE
SETBAD   DS    0H
         WTO   'TSGTFMAP-1ST RECORD NOT CONTROL RECORD',ROUTCDE=(11)
         ABEND 1,DUMP
*        GETMAIN CORE FOR STRING TABLE
*        THIS TABLE SHOULD BE GETMAINED/FREEMAINED AT EOJ
*         SINCE IT IS ONLY USED THERE.
SETST    DS    0H                  GETMAIN STRING TABLE
         L     R0,STSIZ#           GET # OF STRINGS
         MH    R0,=AL2(STSIZE)
         GETMAIN R,LV=(0)
         ST    R1,STROOT           SAVE ADDR
         BAL   R14,CLRIT           CLEAR CORE
SETRET   DS    0H                  RETURN FROM SETUP
         B     GETREC
 TITLE 'E N D  O F  D A T A  -  C A L C  D E P E N D A N T  D A T A'
GETEOD2  DS    0H                  END-OF-FILE ON INPUT
         LM    R0,R1,STOPTM        GET TIME OF LAST GTF REC
         LM    R2,R3,STRTTM        GET STOP TIME
         BAL   R14,UTTIMDIF        CALC DIF IN MILLISEC*10
         LH    R15,=H'10'          NORMALIZE *10 OUT
         BAL   R14,DIVIDER         CALC GTF RUN TIME IN MILLI-SEC
         ST    R1,TOTTM            SAVE ELAPSED TIME
*        CALC SUMMARY DATA BY STRING
         L     R1,DVVROOT          GET DEVICE VECTOR TABLE
         ST    R1,EODCURDV         SET 1ST DEVICE
EODSTNX1 DS    0H                  NEXT DEVICE
         L     R1,EODCURDV         GET DEVICE VECT ENTRY
         L     R11,DVVPTR-DVVTAB(R1) GET DEVICE TABLE ENTRY
         OC    DVVPTR-DVVTAB+1(3,R1),DVVPTR-DVVTAB+1(R1) END OF DEVS
         BZ    EODSTEN1            YES-STRING-CALC-COMPLETE
         LA    R1,DVVSIZ(R1)       BUMP TO NEXT VECTOR
         ST    R1,EODCURDV         SAVE FOR NEXT TIME
         MVC   EODSTUCB,DVUCB      GET EBCDIC ADDR
         MVI   EODSTUCB+2,C'0'     ASSUME ZERO STRING
         XR    R6,R6               CLEAR WORKER
         ICM   R6,3,DVUCBPTR       GET UCB ADDR
         TM    UCBCHAN+1(R6),X'08' HI OR LO STRING
         BZ    *+8                 ZERO STRING-OK
         MVI   EODSTUCB+2,C'8'     MAKE XX8 STRING
         L     R2,STSIZ#           GET NUMB OF STRINGS
         L     R3,STROOT           GET FIRST STRING
         USING STTAB,R3            TELL ASM
EODSTNX2 DS    0H                  CALC STRING STATS
         OC    STUCB,STUCB         END OF STRING TABLE
         BZ    EODSTADD            YES-ADD NEW STRING
         CLC   STUCB,EODSTUCB      FOUND RIGHT STRING
         BE    EODSTHIT            YES
         LA    R3,STSIZE(R3)       BUMP TO NEXT STRING TABLE
         BCT   R2,EODSTNX2         TRY NEXT STRING TABLE ENTRY
         ABEND 1,DUMP              RAN OF OF CALCULATED STRING ENTRIES?
EODSTADD DS    0H                  ADD A NEW STRING
         MVC   STUCB,EODSTUCB      MOVE EBCDIC NAME
EODSTHIT DS    0H                  UPDATE A STRING ENTRY
         OC    DVSIO0,DVSIO0       ANY DEVICE ACTIVITY
         BZ    EODSTNX1            NO
         L     R0,DVSIO0           BUMP
         A     R0,STSIO0
         ST    R0,STSIO0           UPDATE
         L     R0,DVSIO1           BUMP
         A     R0,STSIO1
         ST    R0,STSIO1           UPDATE
         L     R0,DVSIO2           BUMP
         A     R0,STSIO2
         ST    R0,STSIO2           UPDATE
         L     R0,DVSIO3           BUMP
         A     R0,STSIO3
         ST    R0,STSIO3           UPDATE
         L     R0,STNUMB           GET CURR NUMB OF DEV ON STRING
         AH    R0,=H'1'            BUMP
         ST    R0,STNUMB           UPDATE
         L     R0,DVAVGIO          BUMP
         A     R0,STAVGIO
         ST    R0,STAVGIO          UPDATE
         L     R0,DVTOTCYL         BUMP
         A     R0,STTOTCYL
         ST    R0,STTOTCYL         UPDATE
         L     R0,DVDEFRIO         BUMP
         A     R0,STDEFRIO
         ST    R0,STDEFRIO         UPDATE
         CLC   DVDEFRMX,STDEFRMX   LOCATE HIGHEST DEFER TIME
         BL    *+10                LOWER THAN CURR. MAX.
         MVC   STDEFRMX,DVDEFRMX   STORE NEW LIMIT
         B     EODSTNX1
 TITLE 'E N D  O F  D A T A  -  P R I N T  S T R I N G  S T A T S  '
EODSTEN1 DS    0H                  PRINT GRAND TOTALS
*        PRINT JOB TOTALS
         BAL   R14,CLRPL           CLEAR PRINT LINE
         L     R1,@PL              GET PRINT LINE
         MVI   0(R1),C'0'          DOUBLE SPACE
         MVC   1(10,R1),=C'JOB TOTALS'
         BAL   R14,PUT             PRINT IT
         LA    R2,(PRTCNTE-PRTCNTS)/(PRTCNT1-PRTCNTS)
         LA    R3,PRTCNTS          #OF CTRS/STRT OF TABLE
         BAL   R14,UTEODP          PRINT PACKED DATA
         LA    R2,(PRTBCNTE-PRTBCNTS)/(PRTBCNT1-PRTBCNTS) NUMB OF ENTS
         LA    R3,PRTBCNTS         START OF FORMAT TABLE
         ST    R13,UTEODBAS        SAVE BASE INFO FOR FORMATTER
         BAL   R14,UTEODB          PRINT TABLE
*                                  CALC STRING DATA AND PRINT
         L     R3,STROOT           GET 1ST STRING
EODSTNX3 DS    0H                  NEXT STRING
         L     R0,STSIZ#           NUMB OF STRINGS
         MH    R0,=AL2(STSIZE)     * SIZE = OFFSET TO END+1
         A     R0,STROOT            + BASE = END+1
         CR    R0,R3               OFF END
         BNH   EODSTEND            YES
         OC    STSIO0,STSIO0       ANY SIOS
         BZ    EODSTBM1            NO-SKIP
         L     R1,STAVGIO          GET TOTAL IO TIME * 10MS
         L     R15,STSIO0          GET # GOOD SIOS
         MH    R15,=H'10'          ADJUST FOR *10 FACTOR
         BAL   R14,DIVIDER         GET AVG IO TIME ON STRING MILLISEC
         ST    R1,STAVGIO          SAVE AVERAGE
         L     R1,STTOTCYL         GET TOTAL CYLS SEEKED
         L     R15,STSIO0          GOOD SIO
         BAL   R14,DIVIDER         GET AVG CYL SEEKED
         ST    R1,STTOTCYL         AVG CYL SEEKED
         L     R1,STDEFRIO         GET DEFERED TIME *10MS
         L     R15,STSIO1          GET # OF DEFERED SIOS
         MH    R15,=H'10'          ADJUST FOR *10
         BAL   R14,DIVIDER
         ST    R1,STDEFRIO         SAVE AVG DEFERED TIME
*        NORMALIZE STRING MAX DEFER TIME
         L     R1,STDEFRMX         GET MAX STRING DEFER *10
         LH    R15,=H'10'          SETUP DIVISOR
         BAL   R14,DIVIDER         DIVIDE AND ROUND
         ST    R1,STDEFRMX         STORE MAX DEFER IN MILLI-SEC
*        PRINT STRING DATA
         BAL   R14,CLRPL           CLR PRINT LINE
         L     R1,@PL              GET PRINT LINE
         MVI   0(R1),C'0'          DBL SPACE
         MVC   1(3,R1),STUCB       MOVE NAME OF STRING
         MVC   5(6,R1),=C'STRING'  STRING IN TITLE
         BAL   R14,PUT
         ST    R3,UTEODBAS         SAVE BASE ADDR FOR FORMATTER
         LA    R2,(EOD2CNTE-EOD2CNTS)/(EOD2CNT1-EOD2CNTS) NUMB OF FLDS
         LA    R3,EOD2CNTS         GET FORMAT DATA
         BAL   R14,UTEODB          PRINT STRING DATA
         L     R3,UTEODBAS         RESTORE R3
EODSTBM1 DS    0H                  NEXT STRING ENTRY
         LA    R3,STSIZE(R3)
         B     EODSTNX3
         DROP  R3                  FINI W/ STRING
EODSTEND DS    0H                  FINI W/ STRING
 TITLE 'E N D  O F  D A T A  -  P R I N T  E A C H  D E V I C E    '
         L     R1,DVVROOT          FIRST VECTOR ENTRY
         ST    R1,EODCURDV         SAVE
EODLOOP  DS    0H             NOW PRINT DATA FOR EACH DASD
         BAL   R14,CLRPL           CLEAR PRT LINE TO BLANKS
         L     R1,EODCURDV         PICK UP CURRENT DEVICE PTR
         OC    1(3,R1),1(R1)  END OF VECTOR TABLE           AXC
         BZ    EODJOB              YES-FINI
         L     R11,DVVPTR-DVVTAB(R1) GET DEVICE TABLE
         LA    R1,DVVSIZ(R1)       BUMP TO NEXT DEVICE PTR
         ST    R1,EODCURDV         SAVE FOR NEXT TIME
         OC    DVSIO0,DVSIO0  NO-SIOS - SKIP
         BZ    EODLOOP             TRY NEXT DEVICE
*        CALC AVG CYL SEEKED
         L     R1,DVTOTCYL         GET TOTAL CYL SEEKED
         L     R15,DVSIO0          GET GOOD SIOS
         BAL   R14,DIVIDER         TOT CYL / SIO 0
         ST    R1,DVAVGCYL         STORE AVG. CYL SEEKED
*        CALC AVG IO TIME IN MILLI-SEC
         L     R1,DVAVGIO          GET SUM OF IO TIME(TIMES 10)
         L     R15,DVSIO0          GET GOOD SIOS
         MH    R15,=H'10'          (TIMES 10) TO OFFSET IO TIME
         BAL   R14,DIVIDER         GET AVG. I/O TIME (IN MILLISEC)
         ST    R1,DVAVGIO          SAVE
         L     R1,DVMAXIO          GET LONGEST IO TIME
         LH    R15,=H'10'          GET 10 TO NORMALIZE
         BAL   R14,DIVIDER         GET LONGEST IO TIME IN MILLISEC
         ST    R1,DVMAXIO          SAVE IT
*        CALC AVG DEFERED TIME IN MS
         L     R1,DVDEFRIO         GET DEFERED IO TIME
         L     R15,DVSIO1          GET # OF DEFRS
         MH    R15,=H'10'          ADJUST FOR *10 FACTOR
         BAL   R14,DIVIDER         GET AVG DEFR TIME
         ST    R1,DVDEFRIO
*        CALC MAX DEFERED TIME IN MS
         L     R1,DVDEFRMX         GET DEFERED IO TIME
         LH    R15,=H'10'          ADJUST FOR *10 FACTOR
         BAL   R14,DIVIDER         GET AVG DEFR TIME
         ST    R1,DVDEFRMX
*        SET UP TO NORMALIZE COUNTS IN XREF ARRAY
         LH    R2,DVSLOTS          GET # OF SLOTS TO MAP PACK
         MH    R2,DVSLOTS          SQUARE IT FOR # OF ARRAY ENTRIES
         CLI   PRTOPT,C'H'         HISTOGRAM
         BNE   EODNHIST            NO
         LH    R2,MAXCYL           YES-1 ENTRY/CYL
EODNHIST DS    0H
         XR    R3,R3               CLEAR
         LA    R4,DVXREF           GET START OF ARRAY
EODMAX   DS    0H                  LOOK FOR HIGHEST ENTRY
         C     R3,0(R4)            COMPARE AGAINST CURRENT
         BH    *+8                 NOT A NEW HIGH
         L     R3,0(R4)            NEW-HIGH - PICK UP
         LA    R4,4(R4)            BUMP TO NEXT ENTRY
         BCT   R2,EODMAX           LOOP
         ST    R3,DVMAXHIT         SAVE HIGHEST HIT PT.
         CLI   PRTOPT,C'H'         HISTOGRAM PRINT
         BE    EODMAXOK            YES-DONT HORMALIZE
         C     R3,EODOVFLO         WOULD MAX OVERFLOW A PRT ENTRY
         BL    EODMAXOK            NO-NO NEED TO NORMALIZE
         LH    R2,DVSLOTS          GET SLOTS AGAIN
         MH    R2,DVSLOTS          SQUARE TO GET ARRAY SIZE
         LA    R4,DVXREF           START OF ARRAY
         LR    R14,R3              SAVE MAX HIT POINT SIZE
         SRL   R14,1               1/2
EODNORM  DS    0H                  NORMALIZE WHOLE ARRAY TO PRT SIZE
         XR    R0,R0               CLEAR
         L     R1,0(R4)            GET ENTRIES NUMBER
         M     R0,EODOVFLO         X 999 - PRT ELEMENT SIZE
         ALR   R1,R14              ADD FOR HALF ADJUST
         BC    8+4,*+8             DID OVERFLOW OCCUR
         AH    R0,=H'1'            YES-BUMP 1ST REG
         DR    R0,R3               GET NORMALIZED SIZE
         ST    R1,0(R4)            STORE NORMALIZED ENTRY
         LA    R4,4(R4)            BUMP TO NEXT ARRAY ELEMENT
         BCT   R2,EODNORM          LOOP
EODMAXOK DS    0H
*        CALC JOB AVGS
         LA    R2,JT#              GET # OF JOBS
EODJTAVG DS    0H
         LA    R3,JT#              GET # OF JOBS
         SR    R3,R2               GET INDEX FROM 0,1,2...
         SLL   R3,2                4 BYTES PER COUNTER
*        AVG DEFER TIME BY JOB
         L     R1,DVJTDFRT(R3)     GET THIS JOB
         L     R15,DVJTSIO1(R3)    GET # OF DEFERS
         MH    R15,=H'10'          ADJUST FOR *10
         BAL   R14,DIVIDER         DIVIDE/ROUND
         ST    R1,DVJTDFRT(R3)     STORE
*        AVG I/O TIME FOR A JOB
         L     R1,DVJTIOTM(R3)     GET THIS JOB
         L     R15,DVJTSIO0(R3)    GET # OF IOS
         MH    R15,=H'10'          ADJUST FOR *10
         BAL   R14,DIVIDER         DIVIDE/ROUND
         ST    R1,DVJTIOTM(R3)     STORE
*        AVG SEEK FOR A JOB
         L     R1,DVJTSEEK(R3)     GET CYLS SEEKED
         L     R15,DVJTSIO0(R3)    GET IOS
         BAL   R14,DIVIDER         DIVIDE
         ST    R1,DVJTSEEK(R3)     STORE AVG CYL
         BCT   R2,EODJTAVG         RE-DO AVGS FOR NEXT JOB
*        SETUP HDR
         LA    R1,HDR1             GET HEADER
         MVC   HDRUCB,DVUCB        SET UCB ADDR IN HDR
         MVC   HDRTYPE,DVTYPE      SET TYPE (3330)
         MVC   HDRVOLI,DVVOLI      SET VOLID
         BAL   R14,PUT             SKIP TO CH 1
         LA    R0,(DVSIO1XE-DVSIO1XS)/(DVSIO1XL) # ENTRIES
         LA    R14,DVSIO1XS        START
         LA    R15,EODSIO1S        MODIFY HEADERS WITH PRINTABLE HEX
EODXCONV DS    0H
         UNPK  5(5,R15),DVSIO1XS-DVSIO1XS(L'DVSIO1XS+1,R14) 0-F=F0-FF
         MVI   9(R15),C' '         BLANK LAST BYTE
         TR    5(4,R15),TRTAB-240  XLATE TO PRINTABLE
         LA    R14,DVSIO1XL(R14)   NEXT ENTRY
         LA    R15,(EODCNT1-EODCNTS)(R15) NEXT HEADER
         BCT   R0,EODXCONV
         LA    R2,(EODCNTE-EODCNTS)/(EODCNT1-EODCNTS)  GET # TOTS
         LA    R3,EODCNTS          GET START OF DEV. TOTS
         BAL   R14,CLRPL           BLANK PRINT LINE
         L     R1,@PL              GET PRINT LINE
         MVI   0(R1),C'0'          DBL SPACE
         ST    R11,UTEODBAS        STORE BASING FOR TABLE
         BAL   R14,UTEODB          FORMAT DATA
         BAL   R14,CLRPL           CLEAR PRINT LINE
         L     R1,@PL              GET PRINT LINE
         CLI   PRTOPT,C'H'         HISTOGRAM
         BE    EODPRTHS            YES-GOTO SUBROUTINE
         MVC   0(L'HDR2,R1),HDR2   GET 2ND HEADER
         BAL   R14,PUT             PRINT IT
         BAL   R14,CLRPL           CLEAR PRINT
         L     R1,@PL              GET PRINT LINE
         MVC   1(9,R1),=C'    TRACK' SET UP ARRAY LINES
         LH    R2,DVSLOTS          GET # OF PRINT SLOTS
         LR    R5,R1               GET ADDR OF PRINT LINE
         AH    R5,LINEOFST         BUMP TO START OF ARRAY DATA
EODHDR2  DS    0H                  DISPLAY SLOT # IN HDR
         LR    R0,R2               GET COUNT DOWN CTR
         SH    R0,DVSLOTS          SUBTRACT MAX. (0,-1,-2,..MAX)
         CVD   R0,WD               MAKE PACKED
         MVC   WE,MASK             SET MASK
         ED    WE,WD+2             EDIT IT IN (NO SIGN DISPLAYED)
         EX    0,EXMVC             MOVE IT IN PRINT LINE
         AH    R5,STMAXDSP         NEXT SLOT ADDR IN PRT LINE
         BCT   R2,EODHDR2          LOOP
         BAL   R14,PUT             PRINT ARRAY HEADER
         BAL   R14,CLRPL           CLEAR PRINT LINE
         L     R1,@PL              GET PRT LINE ADDR
         BAL   R14,PUT             PRINT A BLANK LINE
         LA    R4,DVXREF           GET START OF ARRAY
         LH    R3,DVSLOTS          GET # OF SLOTS
EODNXT   DS    0H                  PRINT A ROW OF DEV ARRAY
         LR    R0,R3               GET CURRENT DOWN CTR
         SH    R0,DVSLOTS          - MAX = NEG SLOT #
         CVD   R0,WD               PACKED
         L     R1,@PL              GET PRINT LINE
         MVC   0(4,R1),=X'40212020' SET EDIT MASK
         ED    0(4,R1),WD+6        SET SLOT # (NO SIGN SHOWN)
         MH    R0,DVDELTA          GET # OF CYLS IN A SLOT
         MH    R0,DVTRK            * # OF TRK IN A CYL
         CVD   R0,WD               MAKE PACKED
         MVC   4(6,R1),=X'402021202020' SET EDIT MASK
         ED    4(6,R1),WD+5        EDIT STARTING TRACK # IN
         LR    R5,R1               GET START OF PRINT LINE
         AH    R5,LINEOFST         ADD OFFSET TO START OF ARRAY DATA
         LH    R2,DVSLOTS          GET # OF SLOTS ON PRT LINE
EODROW   DS    0H                  RUN THRU ALL COL. IN A ROW
         L     R0,0(R4)            GET COUNTER
         LTR   R0,R0               IS COUNT ZERO
         BZ    EODZERO             YES-SPECIAL CASE
         CVD   R0,WD               NO-MAKE PACKED
         MVC   WE,MASK             SET EDIT MASK
         ED    WE,WD+2             EDIT IT IN
EODMVC   DS    0H                  MOVE COUNT FROM WORK AREA
         EX    0,EXMVC             MOVE SPECIFIED DIGITS IN
EODBUMP  DS    0H                  NEXT COL. IN A ROW
         LA    R4,4(R4)            BUMP TO NEXT CTR
         AH    R5,STMAXDSP         BUMP SLOT ADDR IN PRT LINE
         BCT   R2,EODROW           NEXT COLUMN IN ROW
         L     R1,@PL              GET PRT LINE
         BAL   R14,PUT             PRINT WHOLE ROW
         BCT   R3,EODNXT           LOOP FOR NEXT ROW
         B     EODJPRNT            PRINT JOB INTERFERENCE RPT
**       PRINT SEEK ADDRESSES IN HISTOGRAM FORMAT
EODPRTHS DS    0H
         LH    R3,MAXCYL           SET UP LOOP FOR EACH CYLINDER
         LA    R4,DVXREF           CYL ZERO CTR
         BAL   R14,CLRPL           CLEAR PRINTLINE
         L     R1,@PL
         MVC   0(7,R1),=C'0TRACK #' MINOR HEADING
         BAL   R14,PUT
EODRNXH  DS    0H
         CLC   =F'0',0(R4)         NULL CTR?
         BE    EODRNXCY            YES-NEXT CYLINDER
         L     R1,@PL
         LR    R0,R3               GET COUNT DOWN CTR
         SH    R0,MAXCYL           TURN IT INTO COUNT UP
         MH    R0,DVTRK            CALC STARTING TRACK #
         CVD   R0,WD               PRINT IT
         MVC   4(6,R1),=X'40202120202020' EDIT MASK
         ED    4(6,R1),WD+5
         L     R1,0(R4)            GET CYL COUNT
         LH    R0,LINESIZE         CALC # OF AVALIABLE PRINT POS.
         SH    R0,LINEOFST         # = LINESIZE-STARTING OFFSET
         STH   R0,WD
         MH    R1,WD               R1=(SEEK COUNT)*(MAX PRINT POS.)
         L     R15,DVMAXHIT        HIGHEST SEEK COUNT FOR THIS PACK
         BAL   R14,DIVIDER
*        R1=# OF ASTERISKS FOR NORMALIZED COUNTER
**       NOW MOVE ASTERISKS INTO PRINT LINE
         XR    R15,R15             FROM LEN=0
         ICM   R15,8,=C'*'         FILL CHAR=C'*'
         XR    R14,R14             FROM ADDR=0
         L     R0,@PL              TO ADDR
         AH    R0,LINEOFST         "
         MVCL  R0,R14              INSERT ASTERISKS
         L     R1,@PL
         BAL   R14,PUT
         BAL   R14,CLRPL           BLANK PRINT LINE
EODRNXCY DS    0H
         LA    R4,4(R4)            NEXT CYL CTR
         BCT   R3,EODRNXH          LOOP THRU ALL CYLINDERS
EODJPRNT DS    0H
*        PRINT JOB TOTALS FOR A DEVICE
         LA    R6,JTPRT2#          GET NUMBER OF JOB LINES
         LA    R4,DVJTXREF         GET START OF ARRAY
         BAL   R14,CLRPL           CLEAR PRINT LINE
         L     R1,@PL              GET PRT LINE ADDR
         BAL   R14,PUT             PRINT IT
EODJNXT  DS    0H                  PRT JOB + NAMES WHO HELD HIM UP
         BAL   R14,CLRPL           CLEAR PRINT LINE
         L     R1,@PL              GET PRT LINE ADDR
         LA    R14,JTPRT2#         GET # OF JOB LINES
         SR    R14,R6              GET INDEX TO CURRENT JOB
         MH    R14,=AL2(JOB1-JOBS) GET OFFSET TO ROW LIT.
         LA    R14,JOBS(R14)       + BASE ADDR = START OF LIT.
         MVC   5(L'JOBSNAM,R1),(JOBSNAM-JOBS)(R14) MOVE LIT
         LA    R5,14(R1)           GET START OF ARRAY IN PRT LINE
         LA    R2,JT#              GET # OF JOBS MONITORED
EODJROW  DS    0H                  PRINT A ROW
         L     R0,0(R4)            GET INTERFERENCE COUNT
         CVD   R0,WD               MAKE PACKED
         MVC   WE,MASK             SET EDIT MASK
         ED    WE,WD+2             EDIT IT
         EX    0,EXMVC3            MOVE DATA INTO PRT LINE
         LA    R4,4(R4)            NEXT CTR
         AH    R5,STJOBDSP         NEXT SLOT IN PRT LINE
         BCT   R2,EODJROW          GET NEXT COLUMN
         BAL   R14,PUT             PRINT A ROW
         BCT   R6,EODJNXT          NEXT JOB
         B     EODLOOP             NEXT DASD DEVICE
EODZERO  DS    0H                  SPECIAL CASE OF DASD SIO ZERO
         CR    R2,R3               IS ZERO ON DIAGONAL
         BE    EODPLUS             YES - MARK DIAGONAL W/ +
         MVC   WE,=C'           .' ELSE MARK NULLS W/ PERIODS
*        IDEA IS TO MAKE COLUMNS HAVE PERIODS DOWN THEM
*         AND DIAGONAL TO HAVE PLUSES.
         B     EODMVC              MOVE DATA IN PRT LINE
EODPLUS  DS    0H                  SET DATA TO PLUS
         MVC   WE,=C'           +' SET WORK AREA TO PLUS
         B     EODMVC              MOVE DATA IN PRT LINE
EODJOB   DS    0H                  EOJ
*         DC    H'0'          TEST ENABLE TO LOOK AT CORE
         LA    R15,0               SET RC
*        SOMEDAY IM GOING TO CLOSE FILES AND FREE GOTTEN CORE
         TERME ,                   RETURN TO O/S
         TITLE 'C O M M O N   U T I L I T I E S '
********* LOCATE DEVICE ENTRY FROM CHAN. ADDR
UTGET    DS    0H                  ENTRY
         ST    R14,UTGETSAV        SAVE RETURN
         LR    R14,R11             COPY ADDR
         SRDL  R14,8               PUT CU/DEV ADDR IN R15
         SRL   R15,28              PUT CU/DEV IN LOW END
         L     R1,16               CVT
         L     R1,CVTILK1(R1)      LOOKUP 1
         XR    R3,R3               CLEAR
         IC    R3,0(R14,R1)        GET CHANNEL INDEX
         ALR   R15,R3              ADD CU/DEV
         ALR   R15,R15             TIMES 2
         LR    R3,R11              GET A FRESH COPY OF ADDR
         N     R3,=F'15'           MASK OFF CHAN/CU
         AH    R3,0(R15,R1)        ADD DEVICE INDEX
         ALR   R3,R3               DOUBLE
         L     R1,16               CVT
         L     R1,CVTILK2(R1)      LOOKUP 2
         LH    R14,0(R1,R3)        GET UCB ADDR
         N     R14,=X'0000FFFF'    MASK OFF IF OVER 32K
         LR    R11,R14             COPY TO OUTPUT REG
         L     R14,DVVROOT         GET START OF VECTOR TABLE
         L     R1,UTGETSAV         GET RETURN ADDR
         LTR   R11,R11             UCB HOLE ENTRY?
         BZR   R1                  YES-RET +0 - UCB NOT FOUND
UTGLOOP  DS    0H                  FIND SAME UCB PTR
         USING DVVTAB,R14          TELL ASM
         CLI   0(R14),X'FF'        END OF VECTOR TABLE
         BER   R1                  YES-RETURN?????
         CLM   R11,3,DVVUCB        FIND SAME UCB PTR
         BE    UTGFND              FOUND
         LA    R14,DVVSIZ(R14)     BUMP TO NEXT VECTOR ENTRY
         B     UTGLOOP             TRY AGAIN
UTGFND   DS    0H                  FOUND IT
         L     R11,DVVPTR          GET PTR TO DEVICE TABLE
         B     4(R1)               RETURN +4 = GOOD DEV
******** CALC DEFERED TIME
UTDEFR   DS    0H                  CALC DEFER TIME
         ST    R14,UTDEFRSV        SAVE RETURN
         OC    DVDEFRTM,DVDEFRTM   WAS THERE A BUSY BEFORE
         BZ    UTDEFRET            NO-NEXT PHASE
         LM    R2,R3,DVDEFRTM      GET TIME OF SIO-BUSY
         ICM   R0,15,GTTIME        GET I/O INTERRUPT TIME
         ICM   R1,15,GTTIME+4      GET I/O INTERRUPT TIME
         BAL   R14,UTTIMDIF        GO CALC DIF IN MILLISEC*10
         C     R1,DVDEFRMX         COMPARE TO MAX SO FAR
         BL    *+8                 LO-SKIP UPDATE
         ST    R1,DVDEFRMX         STORE NEW LIMIT
         LR    R0,R1               SAVE DEFER
         AL    R1,DVDEFRIO         ADD TO DEFER TIME SO FAR
         ST    R1,DVDEFRIO         STORE
         LH    R15,DVLJOBI         GET INDEX TO LAST SIO JOB
         AL    R0,DVJTDFRT(R15)    ADD TO TOTAL DEFER TIME
         ST    R0,DVJTDFRT(R15)    STORE
         XC    DVDEFRTM,DVDEFRTM   RESET LAST BUSY TIME
UTDEFRET DS    0H                  RETURN
         L     R14,UTDEFRSV        GET RETURN
         BR    R14                 RETURN
******** CLEAR PRINT LINE TO BLANKS
CLRPL    DS    0H                  CLEAR PRINT LINE
         L     R0,@PL              ADDR OF PRT LINE
         LH    R1,LINESIZE         GET LINE SIZE
         L     R15,=X'40000000'    SET FILL CHAR TO BLANK
         MVCL  R0,R14              MOVE BLANKS IN
         BR    R14                 RETURN
******** FIND JOB INDEX FOR A GTF RECORD
UTFNDJOB DS    0H                  FIND A JOB INDEX
         LA    R3,JOBS             GET JOB NAME TABLE
         LA    R2,JT#              GET # OF ENTRIES
         XR    R15,R15             CLEAR
UTFNDJB  DS    0H                  LOCATE JOB WHO CAUSED PROBLEM
         IC    R15,JOBS#CHR-JOBS(R3)  GET L'-1 OF JOBNAME
         EX    R15,UTFNDCLC        FOUND JOBNAME?
         BE    UTFNDSIO            YES
         LA    R3,(JOB1-JOBS)(R3)  NO - BUMP TO NEXT
         BCT   R2,UTFNDJB          LOOP
         SH    R3,=AL2(JOB1-JOBS)  NOT FOUND - BACK UP 1 ENTRY
         LA    R2,1                ADJUST LOOP REG
UTFNDSIO DS    0H                  NOW UPDATE ARRAY ENTRY
         LA    R0,JT#              MAX JOBNAMES
         SR    R0,R2                -LOOP REG = JOB #
         SLL   R0,2                EACH COUNTER IS 4 BYTES
         STH   R0,DVCJOBI          STORE AS CURRENT JOB INDEX
         BR    R14                 RETURN
UTFNDCLC CLC   JOBSNAM-JOBS(0,R3),GTJOB
*        DISPLAY BINARY TOTALS FROM TABLE
UTEODB   DS    0H                  PRINT DEVICE TOTS
         ST    R14,UTEODSAV        SAVE RETURN
UTEODB2  DS    0H
         L     R1,@PL              GET ADDR OF PRINT LINE
         LH    R14,L'EODCNTS(R3)   GET OFFSET TO TOT CTR.
         A     R14,UTEODBAS        GET ADDR OF CTR
         L     R14,0(R14)          GET CTR
         CVD   R14,WD              MAKE PACKED
         MVC   1(L'MASK2,R1),MASK2 MOVE EDIT MASK
         ED    1(L'MASK2,R1),WD+4  EDIT TOT IN
         MVI   1+L'MASK2(R1),C'='  SET =
         MVC   1+L'MASK2+1(L'EODCNTS,R1),0(R3) MOVE TOT NAME IN
         BAL   R14,PUT             PRINT DEV TOTAL
         BAL   R14,CLRPL           CLEAR AND SET SINGLE SPACE
         LA    R3,L'EODCNTS+2(R3)  BUMP TO NEXT TOT DESC. SET
         BCT   R2,UTEODB2          LOOP
         L     R14,UTEODSAV        RESTORE SAVE
         BR    R14                 RETURN
******** CLEAR A SECTION OF CORE
CLRIT    DS    0H                  CLEAR
         XR    R0,R1               SWAP REGS 1 AND 0
         XR    R1,R0               "
         XR    R0,R1               "
         XR    R15,R15             CLEAR R15
         MVCL  R0,R14              PAD WHOLE THING W/ ZEROS
         BR    R14                 RETURN
******** DISPLAY PACKED TOTALS FROM TABLE
UTEODP   DS    0H                  DISPLAY TOTALS
         ST    R14,UTEODSAV        SAVE RETURN
UTEODP2  DS    0H
         L     R1,@PL              GET OUTPUT PLINE ADDR
         LH    R14,L'PRTCNTS(R3)   GET OFFSET FROM STRT OF CTRS
         LA    R14,PACKS(R14)      GET ADDR OF CTRS
         MVC   1(L'MASK2,R1),MASK2 MOVE EDIT MASK
         ED    1(L'MASK2,R1),0(R14) EDIT CTR IN
         MVI   1+L'MASK2(R1),C'='  FORMAT CTR COUNTS
         MVC   1+L'MASK2+1(L'PRTCNTS,R1),0(R3) MOVE CTR NAME IN
         BAL   R14,PUT             PUT OUT COUNTER
         BAL   R14,CLRPL           CLEAR AND SINGLE SPACE
         LA    R3,L'PRTCNTS+2(R3)  BUMP TO NEXT LITERAL/OFFSET SET
         BCT   R2,UTEODP2          DO NEXT TOTAL COUNT
         L     R14,UTEODSAV        RESTORE R14
         BR    R14                 RETURN
******** DIVIDE AND ROUND
DIVIDER  DS    0H                  DIVIDE R1 BY R15
         LR    R0,R15              PUT IN R0 FOR HALF ADJUST
         SRL   R0,1                1/2
         AR    R1,R0               ADD TO DIVISOR
******** DIVIDE WITHOUT ROUND
DIVIDE   DS    0H                  DIVIDE W/OUT HALF ADJUST
         XR    R0,R0               CLEAR
         LTR   R15,R15             CK DIVIDE BY ZERO
         BZR   R14                 LEAVE DATA ALONE
         DR    R0,R15              DIVIDE R1 BY R15 REMANDER=R0
         BR    R14                 RETURN
******** CALC TIME DIFFERENCE FROM 2 TOD FIELDS
*        R0,R1 = HIGHER TIME IN TOD FORMAT
*        R2,R3 = LOWER TIME IN TOD FORMAT
UTTIMDIF DS    0H                  TIME DIFFERENCE
         ST    R14,UTTIMSAV        SAVE RETURN ADDR
         SLR   R1,R3                CALC DIFFERENCE
         BC    2+1,*+8              "
         SH    R0,=H'1'             "
         SR    R0,R2                "
         SRDL  R0,12                CONVERT TO MICRO SECS
         L     R15,=F'100'          CONVERT TO MILLISEC*10
         BAL   R14,DIVIDER         DIVIDE AND ROUND
         L     R14,UTTIMSAV        GET RETURN
         BR    R14                 RETURN
         TITLE '                   S T A T I C  S T O R A G E'
STATIC   DS     0H
GET      SYSGET DDNAME=SYSUT1,RECFM=VB,EODAD=GETEOD2,BLKSIZE=4092,     X
               LRECL=4088
PUT      SYSPUT DDNAME=SYSPRINT,RECFM=FBA,BLKSIZE=3990,LRECL=133
*        TABLE FOR COUNTER NAMES AND OFFSETS TO COUNTERS
*        MAKES EASY TO ADD MORE LATER
         DS    0H
EODCNTS  DS    0CL16
         DC    CL16'TOTAL SIO 0',AL2(DVSIO0-DVTAB)
EODCNT1  EQU   *
         DC    CL16'TOTAL SIO 1',AL2(DVSIO1-DVTAB)
*  **  ** BREAKDOWN OF SIO CC=1 BY 1ST 6 CSW STATUS CODES
EODSIO1S DS    0CL16               TYPES OF SIO CC=1
         DC    CL16' CSW-XXXX  ',AL2(DVSIO1XS-DVTAB+2+0*DVSIO1XL)
         DC    CL16' CSW-XXXX  ',AL2(DVSIO1XS-DVTAB+2+1*DVSIO1XL)
         DC    CL16' CSW-XXXX  ',AL2(DVSIO1XS-DVTAB+2+2*DVSIO1XL)
         DC    CL16' CSW-XXXX  ',AL2(DVSIO1XS-DVTAB+2+3*DVSIO1XL)
         DC    CL16' CSW-XXXX  ',AL2(DVSIO1XS-DVTAB+2+4*DVSIO1XL)
         DC    CL16' CSW-XXXX  ',AL2(DVSIO1XS-DVTAB+2+5*DVSIO1XL)
*  **  ** END OF BREAKDOWN
         DC    CL16'TOTAL SIO 2',AL2(DVSIO2-DVTAB)
         DC    CL16'TOTAL SIO 3',AL2(DVSIO3-DVTAB)
         DC    CL16'CYLINDERS SEEKED',AL2(DVTOTCYL-DVTAB)
         DC    CL16'         AVERAGE',AL2(DVAVGCYL-DVTAB)
         DC    CL16'AVERAGE IO MSEC',AL2(DVAVGIO-DVTAB)
         DC    CL16'MAX     IO MSEC',AL2(DVMAXIO-DVTAB)
         DC    CL16'HIGHEST HIT PT.',AL2(DVMAXHIT-DVTAB)
         DC    CL16'AVG DEFER MSEC.',AL2(DVDEFRIO-DVTAB)
         DC    CL16'MAX DEFER MSEC.',AL2(DVDEFRMX-DVTAB)
EODCNTE  EQU   *              END OF TABLE
******
EOD2CNTS DS    0CL16               STRING DATA FIELDS
         DC    CL16'TOTAL SIO 0',AL2(STSIO0-STTAB)
EOD2CNT1 EQU   *
         DC    CL16'TOTAL SIO 1',AL2(STSIO1-STTAB)
         DC    CL16'TOTAL SIO 2',AL2(STSIO2-STTAB)
         DC    CL16'TOTAL SIO 3',AL2(STSIO3-STTAB)
         DC    CL16'AVG IO TIME',AL2(STAVGIO-STTAB)
         DC    CL16'AVG CYL SEEKED',AL2(STTOTCYL-STTAB)
         DC    CL16'AVG DEFR TIME ',AL2(STDEFRIO-STTAB)
         DC    CL16'MAX DEFR TIME ',AL2(STDEFRMX-STTAB)
         DC    CL16'ACTIVE DEVICES',AL2(STNUMB-STTAB)
EOD2CNTE EQU   *
*
*        ANOTHER TABLE TO DISPLAY EOJ TOTS BY DEVICE
         DS    0H
PRTCNTS  DS    0CL16
         DC    CL16'TOTAL REC IN',AL2(TOTRECIN-PACKS)
PRTCNT1  EQU   *
         DC    CL16'TOTAL SIO',AL2(TOTSIO-PACKS)
         DC    CL16'TOTAL SIO 0',AL2(TOTSIO0-PACKS)
         DC    CL16'TOTAL SIO 1',AL2(TOTSIO1-PACKS)
         DC    CL16'TOTAL SIO 2',AL2(TOTSIO2-PACKS)
         DC    CL16'TOTAL SIO 3',AL2(TOTSIO3-PACKS)
         DC    CL16'TOTAL IO ',AL2(TOTIO-PACKS)
         DC    CL16'TOTAL PCI',AL2(TOTPCI-PACKS)
         DC    CL16'TOTAL BAD',AL2(TOTBAD-PACKS)
         DC    CL16'TOTAL BYPASSED',AL2(TOTBYPAS-PACKS)
PRTCNTE  EQU   *
*
*        BINARY FIELDS FOR WHOLE JOB
PRTBCNTS DS    0CL16
         DC    CL16'TOTAL RUN TIME',AL2(TOTTM-DSA)
PRTBCNT1 EQU   *
PRTBCNTE EQU   *                   END OF FILEDS
*
*
*        TABLE OF JOBS TO MONITOR CONTENTION AMONG THEM
JOBS     DS    0H
JOBS#CHR DS    0AL1
         DC    AL1(7)         L' -1 OF NAME
JOBSNAM  DS    0CL8
         DC    CL8'POPORDER'       JOBNAME
JOB1     EQU   *
         DC    AL1(5),CL8'PVSIMS'
         DC    AL1(7),CL8'PTSTMAST'
         DC    AL1(2),CL8'PGM'
         DC    AL1(2),CL8'N/A'
         DC    AL1(4),CL8'OTHER'
JOBE     EQU   *
JT#      EQU   (JOBE-JOBS)/(JOB1-JOBS)  CALC # OF JOBS IN TABLE
         DC    AL1(0),CL8'SIO 0'   EXTENDED TABLE ROW LABELS
         DC    AL1(0),CL8'SIO 1'
         DC    AL1(0),CL8'SIO 2'
         DC    AL1(0),CL8'SIO 3'
         DC    AL1(0),CL8'DEFR TIM'
         DC    AL1(0),CL8'IO TIME '
JOBE2    EQU   *
JTPRT2#  EQU   (JOBE2-JOBS)/(JOB1-JOBS) # OF ENTRIES IN EXTENDED TAB
*
*        DEVICE CHARACTERISTICS TABLE
STCYLS   DS    0H                  TABLE OF DEVICE TYPE TO MAX. CYLS
         DC    X'0900'             DEVICE TYPE
STCYLMAX EQU   *
         DC    H'404'              MAX CYLS
STCYLNAM EQU   *
         DC    CL8'3330'           EBCDIC NAME
STCYLTRK EQU   *
         DC    H'19'               TRACKS PER CYLINDER
STCYLS1  DS    0H                  FOR SIZE OF ENTRY CALC
         DC    X'0D00',H'808',CL8'3330-1',H'19'
         DC    X'0B00',H'555',CL8'3350  ',H'30'
         DC    H'-1',H'9999',CL8'UNKNOWN',H'19'
****************** S T A T I C  C O N S T A N T S ********************
STMAXDSP DC    H'3'                MAX DIGITS IN DEV ARRAY REPT
STJOBDSP DC    H'8'                DIGITS IN JOB REPORT
MAXCYL   DC    H'808'              MAX # CYL ON ANY PACK
LINEOFST DC    H'11'               OFFSET IN PRINTLINE FOR DATA
SEEKINTF DC    H'20'               # OF CYLS MOVED FOR SIG. CONTENTION
MASK     DC    X'402020202020202020202120' EDIT MASK
MASK2    DC    X'40206B2020206B202120' EDIT MASK
TRTAB    DC    C'0123456789ABCDEF' XLATE MASK
LOGO     DC    C'M O P A R  M A P P E R'  CENTER OF HEADER
HDR2     DC    C'0   FROM  /   TO SLOT NUMBER'  HDR FOR DEV ARRAY DISP
         LTORG
         AIF   (&NOXYTEX).NOX2     SKIP IF NO XYTEX
         XYUTADTV
.NOX2    ANOP
*        EQUATES
*        U C B
UCBDVCLS EQU   18,1
UCBCHAN  EQU   4,2
UCBNAME  EQU   13,3
UCBSTAT  EQU   3,1
UCBUNTYP EQU   19,1
UCBVOLI  EQU   28,6
*        C V T
CVTILK1  EQU   X'24'
CVTILK2  EQU   X'28'
         TITLE 'D Y N A M I C  S T O R A G E'
DSA      DSECT
         DS    9D                  O/S SAVE AREA
DSAPARMS DS    F                   RES
PACKS    EQU   *                   START OF PACKED COUNTERS
TOTRECIN DS    PL4                 TOTAL RECS IN
TOTSIO   DS    PL4                 TOTAL SIO RECS
TOTSIO0  DS    PL4
TOTSIO1  DS    PL4
TOTSIO2  DS    PL4
TOTSIO3  DS    PL4
TOTIO    DS    PL4                 TOTAL IO RECS
TOTPCI   DS    PL4                 TOTAL PCI RECS
TOTBAD   DS    PL4                 TOTAL BAD RECS
TOTBYPAS DS    PL4                 TOTAL BYPASSES RECS
PACKE    EQU   *                   END OF PACKED COUNTERS
UTTIMSAV DS    F                   TIME UTILITY SAVE
STRTTM   DS    XL8                 START OF GTF RUN
STOPTM   DS    XL8                 STOP OF GTF RUN
TOTTM    EQU   STOPTM              TOTAL TIME OF GTF RUN
UTEODSAV DS    F                   PRINT FORMAT UTILITY SAVE
PARMSAVE DS    F                   R1 FROM CALLER
STROOT   DS    F                   ADDR OF STRING TABLE
STSIZ#   DS    F                   NUMBER OF STRINGS IN SYS
EODSTUCB DS    CL3                 WORK AREA-HOLDS STRING
LINESIZE DS    H                   REPORT LINE SIZE
DVMAX    DS    H                   NUMB. DASDS + 1
UTEODBAS DS    F                   BASE ADDR FOR FORMAT UTILITY
DVVROOT  DS    F                   PTR TO DEV VECTOR TABLE
DVVSIZE  DS    F                   SIZE OF DVV TABLE
DVCONTAB DS    F                   PTR TO I/O CONCURRENCE TABLE
DVSLOTS  DS    H                   # SLOTS FOR A PACK
DVSIZE   DS    F                   SIZE OF A DEVICE TABLE ENTRY
UTDEFRSV DS    F                   DEFR UTILITY SAVE AREA
EODCURDV DS    F                   PLACE HOLDER DURING EOD
UTGETSAV DS    F                   UTILITY ROUTINE SAVE AREA
WD       DS    D                   DOUBLE WORD WORK AREA
@PL      DS    F                   PTR TO PRINT LINE
WF       DS    F                   WORK AREA
WE       DS    CL12                MAX SIZE DISPLAY AREA FOR NUMERICS
         DS    0H                  ALIGN
EXMVC    DS    XL6                 EXECUTED MVC INSTRUCTION
EXMVC2   DS    XL6                 EXECUTED MVC INSTRUCTION
EXMVC3   DS    XL6                 EXECUTED MVC INSTRUCTION
EODOVFLO DS    F                   MAX SIZE FIELD THAT CAN BE PRINTED
HDR1     DS    CL133               HEADER AREA
HDRDATE  EQU   HDR1+L'HDR1-22,22   HEADER DATE
PRTOPT   DS    C                   REPORT OPTION SWITCH
HDRTIME  EQU   HDR1+L'HDR1-22-1-8,8      TIME
HDRTITLE EQU   HDR1+(L'HDR1/2)-(L'LOGO/2),L'LOGO  CENTER OF HDR
HDRUCB   EQU   HDR1+1,3            EBCDIC UCB ADDR
HDRTYPE  EQU   HDR1+5,8            EBCDIC DEV TYPE
HDRVOLI  EQU   HDR1+14,6           VOLSER
HDRCLR   EQU   HDR1+1,19           BLANK AREA
DSASIZE  EQU   *-DSA-72            SIZE OF DSA
         TITLE 'D E V I C E  T A B L E'
DVTAB    DSECT                     DEVICE TABLE
DVUCB    DS    CL3                 EBCDIC UCB ADDR
DVUCBPTR DS    H                   UCB PTR(ADDR)
DVFLAG1  DS    X                   FLAG
DVTYPE   DS    CL8                 EBCDIC TYPE
DVVOLI   DS    CL6                 VOLSER
DVSIO0   DS    F                   SIO ZERO COUNT
DVSIO1   DS    F                   " 1
DVSIO2   DS    F                   " 2
DVSIO3   DS    F                   " 3
*        FOR SIO CC=1 TABLE FOR 1ST 6 STATUS CODES/COUNTS
DVSIO1XS DS    XL2                 SIO1 STATUS
DVSIO1XC DS    XL4                 SIO1 CTR
DVSIO1XL EQU   *-DVSIO1XS          1 ENTRY SIZE
         DS    (5*DVSIO1XL)X       REST OF TABLE
DVSIO1XE EQU   *
DVDELTA  DS    H                   CYLINDERS PER PRINT SLOT
DVTRK    DS    H                   TRACKS PER CYLINDER
DVLJOBI  DS    H                   LAST USER OF DEV(JOB TAB INDEX)
DVCJOBI  DS    H                   CURR USER OF DEV(JOB TAB INDEX)
         DS    0D                  ALIGN
DVL0TIME DS    XL8                 TIME OF LAST SIO0(CALC CONCURRENCE)
DVLTIME  DS    XL8                 TIME OF LAST SIO0(CALC I/O TIME)
DVLJOB   DS    CL8                 LAST JOB NAME
DVDEFRTM DS    XL8                 TIME OF LAST SIO .NE. 0
DVDEFRIO DS    F                   CUM/AVG DEFR IO TIME
DVDEFRMX DS    F                   MAX DEFR IO TIME
DVLROW   DS    F                   ROW OF ARRAY WHERE HEAD LEFT
DVTOTCYL DS    F                   TOTAL CYLINDERS SEEKED
DVAVGIO  DS    F                   AVG. I/O TIME
DVMAXIO  DS    F                   MAX. I/O TIME
DVMAXHIT DS    F                   MAX. DEV ARRAY ENTRY
DVAVGCYL DS    F                   AVG. CYL. SEEKED
DVLSEEK  DS    XL8                 MBBCCHHR OF LAST SEEK
DVCURJOB DS    H                   INDEX TO CURRENT JOB USER
DVTOTTIM DS    2F                  RESV.
********* JOB INFO BY DEVICE
DVJTXREF DS    (JT#*JT#)F         JOB INTERFERENCE ARRAY
DVJTSIO0 DS    (JT#)F              SIO CCODE
DVJTSIO1 DS    (JT#)F              SIO CCODE
DVJTSIO2 DS    (JT#)F              SIO CCODE
DVJTSIO3 DS    (JT#)F              SIO CCODE
DVJTDFRT DS    (JT#)F              TOT/AVG DEFER TIME
DVJTIOTM DS    (JT#)F              TOT/AVG I/O TIME
DVJTSEEK DS    (JT#)F              TOT/AVG CYL SEEKED
         DS    0F                  ALIGN
DVFIXSIZ EQU   *-DVTAB             SIZE OF FIXED DEV. TABLE AREA
DVXREF   EQU   *                   START OF SEEK ARRAY
         TITLE 'S T R I N G  T A B L E '
STTAB    DSECT STRING TABLE
STUCB    DS    CL3                 EBCDIC NAME
STSIO0   DS    F                   SIO 0
STSIO1   DS    F                   SIO 1
STSIO2   DS    F                   SIO 2
STSIO3   DS    F                   SIO 3
STAVGIO  DS    F                   AVG IO TIME
STTOTCYL DS    F                   AVG CYL SEEK
STDEFRIO DS    F                   AVG DEFR TIME
STDEFRMX DS    F                   MAX DEFR TIME
STNUMB   DS    F                   NUMBER OF DEVICES ON STRING
STSIZE   EQU   *-STTAB             SIZE OF TABLE
******
******   TITLE 'D E V I C E  V E C T O R  T A B L E '
******
DVVTAB   DSECT                     DEVICE VECTOR TABLE
DVVPTR   DS    F                   PTR TO DEVICE TABLES
DVVUCB   DS    H                   PTR TO UCB
DVVSIZ   EQU   *-DVVTAB            SIZE OF ENTRY
         TITLE 'G T F  R E C O R D S'
GTFREC   DSECT                     GTF RECORDS
GTLEN    DS    H                   LENGTH
         DS    H                   RESV
GTID     DS    X                   RECORD ID
GTFMT    DS    X                   FORMAT ID
GTTIME   DS    XL8                 TIME STAMP IF TIME=YES
GTEVNT   DS    XL2                 EVENT IDENTIFIER
GTASCB   DS    XL4                 PTR TO ACSB
GTCPUID  DS    XL2                 CPU ID
GTJOB    DS    XL8                 JOBNAME
GTSCCWR  DS    XL4                 REAL ADDR OF CCW
GTSCCWV  DS    XL4                 VIRT ADDR OF CCW
GTSPURGE DS    XL4                 CTRL BLK USED BY PURGE
GTSIOCC  DS    XL1                 SIO CONDITION CODE
GTSDEV   DS    XL2                 DEV ADDR
GTSCAW   DS    XL4                 CAW
GTSSTAT  DS    XL2                 STATUS
GTSSEEK  DS    XL8                 SEEK ADDR
GTSFLAG  DS    XL6                 FLAGS
*        I/O RECORD                ***************
         ORG   GTSCCWR             RE-ALIGN
GTIOPSW  DS    XL8                 I/O OLD PSW
GTIRQTCB DS    XL4                 RQE TCB
GTICSW   DS    XL8                 CSW
GTICCWR  DS    XL4                 REAL ADDR OF CCW
GTICCWV  DS    XL4                 VIRT "
GTISENSE DS    XL2                 SENSE
GTIDEV   DS    XL2                 DEVICE ADDR
GTIPURGE DS    XL4                 PURGE CTRL BLOCK
GTIFLAG  DS    XL9                 FLAGS
*
*        TIME STAMP CONTROL RECORD
         ORG   GTTIME
GTCRTZON DS    XL4                 TIME ZONE
GTCRTOD  DS    XL8                 TOD CLOCK
GTCROP1  DS    X                   OPTION 1
GTCROP2  DS    X                   OPTION 2
GTCRSVC  EQU   X'80'               SVC OPTION
GTCROP3  DS    X                   OPTION 3
GTCROP4  DS    X                   OPTION 4
GTCROPT  EQU   X'01'               TIME=YES OPTION
         END
