DVTLIST  TITLE 'DEVICE MASK TABLE UNIT LIST UTILITY'
         MACRO
         REGISTER
         LCLA  &N
.REGS    ANOP
XR&N     EQU   &N
&N       SETA  &N+1
         AIF   ( &N LT 16 ).REGS
         MEND
         EJECT
DEVT     CSECT
         SPACE 2
**********
**********
*
*   THIS UTILITY FORMATS A LIST OF DEVICE ADDRESSES ASSOCIATED WITH A
*   PARTICULAR GENERIC OR ESOTERIC NAME. NAMES MAY BE SPECIFIED ON
*   THE F X COMMAND. IF MORE THAN ONE NAME IS INCLUDED, NAMES SHOULD BE
*   SEPARATED BY COMMAS. IF NO NAME IS SPECIFIED, ALL POSSIBLE NAMES
*   ARE LISTED.
*
**********
**********
         SPACE 2
         XSAVE XR12,,DEVT,WORKL
         USING WORK,XR13
         USING PARMAREA,XR8
         LR    XR8,XR1         SAVE PARM REG
         XC    XCNT,XCNT       COUNT OF MESSAGES SO FAR
         MVI   SWITCHES,X'00'  CLEAR SWITCHES
         LA    XR1,TEXT+5      POINT TO FIRST PARM
         CLI   0(XR1),C' '     ANY PARMS?
         BE    GETCVT          NO, PROCESS ALL NAMES
         OI    SWITCHES,DEVNAME PARM SWITCH ON
         ST    XR1,PARMPTRS   SAVE PARM REGS
*
*   LENGTH OF DEVICE MASK TABLE ENTRY ROUTINE
*
*   FIND # OF UCBS
*
GETCVT   L     XR1,CVTPTR      PTR TO CVT
         L     XR1,CVTILK2(XR1) PTR TO UCB LOOK-UP TABLE
         LR    XR4,XR1
         ST    XR1,UCBLKUP     SAVE IT
ENDUCBTB CLC   =XL2'FFFF',0(XR4)   END OF LOOKUP TABLE?
         BE    FOUNDEND     BRANCH IF YES
         LA    XR4,2(XR4)      UCB PTR UP BY TWO
         B     ENDUCBTB        CONTINUE SEARCH
*
*   CALCULATE LENGTH OF BIT PATTERN WHICH VARIES WITH # OF UNITS IN
*   SYSTEM.  ALL DEVICES HAVE A UNIT BUT NOT ALL UNITS HAVE A DEVICE
*
FOUNDEND DS    0H
         XR    XR5,XR5         CLEAR WORK REG
         SR    XR4,XR1         GET LENGTH OF UCB TABLE BY SUBTRACTING
*                              START AND END ADDRESSES
         SRL   XR4,1           DIVIDE BY TWO FOR # OF UCB ENTRIES IN LU
*                              TBL; REPRESENTS # OF BITS IN BIT PATTERN
*                              OF MASK TBL ENTRY
         SRDL  XR4,5           DIVIDE BY 32 TO FIND # OF FULLWORDS IN
*                              ENTRY BIT PATTERN
         LTR   XR5,XR5         IS REMAINDER ZERO?
         BZ    *+8             YES, BIT PATTERN ALREADY ON FW BOUNDARY
         LA    XR4,1(XR4)      ADD ONE TO FULLWORD COUNT
         SLL   XR4,2           MULTIPLY BY 4 BYTES/FW TO GET BIT PATTRN
*                              LENGTH IN BYTES
         LR    XR9,XR4         SAVE BIT PATTERN LENGTH IN BYTES
*   ON EXIT, XR9 HAS LENGTH OF BIT PATTERN IN BYTES
         LOAD  EP=DEVNAMET     LOAD DEVICE NAME TBL
         ST    XR0,DNMTPTR     ESTABLISH BASE TO DEVNAMET
         LOAD  EP=DEVMASKT     LOAD DEVICE MASK TABLE
         ST    XR0,DMSKTPTR    ESTABLISH BASE TO DEVMASKT
         MVI   PRINTWRK,C' '
         MVC   PRINTWRK+1(70),PRINTWRK
*
*   GET FIRST NAME IF PARMS WERE PASSED, ELSE PROCESS ALL NAMES
*
         TM    SWITCHES,DEVNAME PARMS PASSED?
         BZ    NOPARMS         NO
         L     XR3,PARMPTRS RELOAD PARM PTRS
PARMFIND TM    SWITCHES,ENDPARMS ALL PARMS BEEN PROCESSED?
         BO    EXIT            YES, RETURN TO OS
FNDCOMMA TRT   0(9,XR3),TRTBK IS A COMMA PRESENT? OR A SPACE
         BNZ   GOTBOK          GOT A BLANK OR A COMMA
         LA    XR1,8           MAXIMUM LENGTH
         OI    SWITCHES,ENDPARMS END OF PARMS SW ON
         B     LASTPNAM        GOT LAST PARM NAME
GOTBOK   LA    XR2,1(XR1)      UPDATE PARM PTR TO NEXT PARM
         CLI   0(XR1),C' '     END OF PARMS
         BNE   NOTEND            NO
         OI    SWITCHES,ENDPARMS END OF PARMS SW ON
NOTEND   SR    XR1,XR3         GET LENGTH
         ST    XR2,PARMPTRS    SAVE POINTER TO NEXT PARM
LASTPNAM BCTR  XR1,0            ...MINUS ONE FOR MVC
         MVI   PARMNAME,C' '   CLEAR PARM
         MVC   PARMNAME+1(7),PARMNAME   NAME AREA ( 8 BYTES )
         EX    XR1,*+4         PUT IT IN MVC
         MVC   PARMNAME(0),0(XR3) SAVE PARM NAME
NOPARMS  LM    XR5,XR6,DNMTPTR GET PTRS TO TABLES
         LA    XR3,NAMELEN     GET LENGTH OF NAME ENTRY
         XR    XR2,XR2         CLEAR WORK REG
         M     XR2,0(XR5)      LENGTH OF ENTRY * # ENTRIES = LENGTH
*                              OF TBL (XR3)
         LA    XR5,4(XR5)      POINT PAST HDR (NAME)
         LA    XR6,4(XR6)      POINT PAST HDR (MASK)
         LA    XR7,0(XR3,XR5)  PTR TO END OF NAME TABLE
         SPACE 2
         USING DNTSECT,XR5     ESTABLISH BASE FOR
         USING DMTSECT,XR6          BOTH TABLE ENTRIES
         SPACE 2
         TM    SWITCHES,DEVNAME PARMS PASSED?
         BZ    DOALL           NO, DO ALL ENTRIES
         LA    XR2,NAMELEN
         LR    XR3,XR7         PTR TO END OF NAME TBL (FOR PARMS)
NTRYFIND CLC   PARMNAME,DNTNAME DO WE PROCESS THIS ENTRY?
         BE    FNDMASKN        YES, FIND CORRESPONDING MASK TBL ENTRY
         BXLE  XR5,XR2,NTRYFIND NO, INCR PTR BY LEN OF NAME ENTRY
*                              AND CONTINUE SEARCH
         B     EROR2RTN        ERROR OCCURS IF PARM NAME PASSED CAN NOT
*                              BE FOUND IN TBL
FNDMASKN CLC   DNTDEVTY,DMTDEVTY FIND MASK TBL ENTRY
         BE    DOALL           EXIT
         LA    XR6,MASKBASE(XR9,XR6) ADD LENGTH OF ENTRY TO ADJUST PTR
         B     FNDMASKN        LOOP TO SEARCH
*
*   ON ENTRY - XR5 POINTS TO NAME ENTRY & XR6 POINTS TO MASK ENTRY
*              XR7 POINTS TO END OF NAME TABLE
*
DOALL    BAL   RETURNR,CHECXCNT  DO NOT FILL THE CONSOLE BUFFERS
         B     EXIT              FINISH IF  OPERATOR SAYS SO
         XMSG  MESS1,DNTNAME,MCSFLAG=REG4,MF=(E,XMSGL)
         NI    SWITCHES,255-INITFN INITIALIZE PRINT BUFFER
         BAL   RETURNR,PRINTUCB       FOR EACH NEW NAME
         LA    XR10,1          SET INCREMENT OF ONE FOR LOOP THRU BIT
*                              PATTERN
         LA    XR11,MASKBASE(XR9,XR6) SET ENDING ADDR FOR THIS MASK
*                              ENTRY
         BCTR  XR11,0           ... MINUS ONE
         LA    XR4,DMTBITS     POINT AT BIT PATTERN IN ENTRY
SELECTIT CLI   0(XR4),0        IS SELECTED BYTE OF BIT PATTERN ZERO?
         BE    INCROFF         YES, LOOP
         SPACE 4
*   SUBROUTINE FOR BIT WITHIN BYTE ANALYSIS
         SPACE 1
*   REGS USED - XR2 - BIT POSITION COUNTER FROM 0 TO 7
*               XR3 - MASK IN LOW ORDER BYTE. STARTS WITH X'80' &
*                     ENDS WITH X'01'
*
*   ENTRY * INITIAL - ANLYZBIT, REENTRY - BITDISP1
*
*   INPUT - PTR TO BYTE TO BE ANALYZED
*
*   OUTPUT - XR2 HAS BIT POSITION
*            XR3 HAS MASK LAST USED (TESTED)
         SPACE 1
ANLYZBIT XR    XR2,XR2         INITIAL BIT POSITION TO +0
         LA    XR3,X'80'       MASK TO START FOR FIRST BIT
GETBIT   EX    XR3,TESTBIT     IS BIT ON?
         BO    BITDISPL        GOT BIT DISPLACEMENT
BITDISP1 LA    XR2,1(XR2)      INCREMENT BIT DISPL BY +1
         SRL   XR3,1           SHIFT MASK BY ONE BIT POSITION
         LTR   XR3,XR3         IS MASK ZERO?
         BZ    INCROFF         GO TO INCREMENT OFFSET IN DEVICE ENTRY
*                              BIT PATTERN
         B     GETBIT          CHK ALL BITS WITHIN BYTE
         SPACE 1
TESTBIT  TM    0(XR4),*-*      CHK BITS WITH APPROPRIATE MASK PATTERN
*   XR4 IN ABOVE INSTRUCTION IS A PTR AT BYTE TO BE EXAMINED IN
*          DEVICE ENTRY
         SPACE 4
*
*   (OFFSET OF BYTE   *   8   +   BIT NUMBER) * 2 = OFFSET INTO UCB
*   INTO BIT PATTERN             FROM 0 TO 7             TABLE
*         X                          Y                   Z
*
*   (8X + Y)2 = Z = 16X + 2Y   (FROM BIT ISOLATION LEFT TO RIGHT)
*
BITDISPL LR    XR14,XR2        SAVE BIT POSITION LAST FOUND (Y)
         SLL   XR14,1          Y * 2
         LR    XR15,XR4        SAVE BYTE PTR WITHIN BIT PATTERN
         LA    XR1,DMTBITS     GET START OF BIT PATTERN IN ENTRY
         SR    XR15,XR1        OFFSET OF BYTE INTO BIT PATTERN (X)
         SLL   XR15,4          X * 16
         AR    XR14,XR15       16X + 2Y = Z (OFFSET INTO UCB TABLE)
         L     XR15,UCBLKUP    GET PTR TO UCB LOOK-UP TBL
         LA    XR15,0(XR14,XR15) POINT AT SELECTED UCB FROM BIT PATTERN
*                                IN ENTRY
         ICM   XR15,3,0(XR15)    PICK UP UCB ADDR
         LA    XR1,UCBNAME(XR15) POINT AT DEVICE ADDR AS PARM TO UCB
*                                LIST PRINTER
         XR    XR0,XR0         DO NOT FLUSH BUFFERS
         BAL   RETURNR,PRINTUCB GO FORMAT DEVICE ADDRESSES
         B     BITDISP1        REENTER BIT ANALYSIS ROUTINE
INCROFF  BXLE  XR4,XR10,SELECTIT LOOP IN BIT PATTERN ROUTINE
         BAL   XR0,*+4         ON GOES HI BIT FOR FLUSH OF BUFFER
         BAL   RETURNR,PRINTUCB FLUSH BUFFER
         SPACE 1
         TM    SWITCHES,DEVNAME PARMS PASSED?
         BZ    ALLNAMES        NO, DOING ENTIRE TABLE
PARMEXIT L     XR3,PARMPTRS    RELOAD PARM PTRS
         B     PARMFIND        CONTINUE PARM LIST SCAN
         SPACE 1
ALLNAMES EQU   *
         LA    XR5,NAMELEN(XR5) POINT TO NEXT NAME TBL ENTRY
         CR    XR5,XR7         AT END OF TBL?
         BE    EXIT            YES, RETURN TO OS
         LA    XR6,1(XR11)     PUT ENDING ADDR OF LAST MASK TBL ENTRY
*                              INTO REG FOR START OF NEW ENTRY
         B     DOALL           CONTINUE TABLE LIST
         SPACE 2
EXIT     DELETE EP=DEVNAMET    DELETE TABLES
         DELETE EP=DEVMASKT       USED FOR PGM
         XRETURN 0,R          RETURN
         EJECT
PRINTUCB EQU   *      ROUTINE TO MOVE UCB DEVICE ADDR TO PRINT LINE
         STM   XR2,XR4,OLDREGS SAVE REGS USED AS WORK REGS
         TM    SWITCHES,INITFN IS IT INIT FUNCTION?
         BO    FUNCDETR        NO, CHK OTHERS
INITREGS LA    XR2,PRINTWRK    PTR TO START OF PRINT BUFFER
         XR    XR3,XR3         CLEAR COUNTER
         LA    XR4,14          # OF 5 BYTE ENTRIES IN PRINT BUFFER
         STM   XR2,XR4,PRINTREG SAVE ABOVE REGS
         OI    SWITCHES,INITFN INITIALIZATION COMPLETE
         B     PRINTXIT        EXIT TO CALLER
         SPACE 2
FUNCDETR LTR   XR0,XR0       WHAT FUNCTION?
         BM    PRINT            FLUSH BUFFER
*
*   ADD DEVICE ADDR TO BUFFER
*
         LM    XR2,XR4,PRINTREG GET WORK REGS FOR PRINTER
         MVC   0(3,XR2),0(XR1) MOVE IN DEVICE ADDR
         LA    XR2,5(XR2)      INCREMENT FOR 5 BYTE ENTRY
         LA    XR3,1(XR3)      ADD ONE TO COUNTER
         CR    XR3,XR4         MAX REACHED?
         BE    PRINTBUF        YES, FLUSH BUFFER & RESET REGS
         STM   XR2,XR4,PRINTREG NO, SAVE AS IS
         B     PRINTXIT           AND EXIT TO CALLER
         SPACE 1
PRINTBUF ST    RETURNR,RET14   SAVE RETURN REG
         BAL   RETURNR,PRINT   FLUSH BUFFER
         L     RETURNR,RET14   RESTORE RETURN REG
         B     INITREGS           AND REINITIALIZE REGS
         SPACE 1
PRINT    EQU   *        PRINT OUTPUT ROUTINE
         ST    RETURNR,PRINTR14  SAVE CALLER'S RETURN REG
         BAL   RETURNR,CHECXCNT  DO NOT FILL THE CONSOLE BUFFERS
         B     EXIT              FINISH IF  OPERATOR SAYS SO
         XMSG  MESS2,PRINTWRK,MCSFLAG=REG4,MF=(E,XMSGL)
         MVI   PRINTWRK,C' '
         MVC   PRINTWRK+1(70),PRINTWRK
         L     RETURNR,PRINTR14  RESTORE CALLER'S RETURN REG
         BR    RETURNR         EXIT TO CALLER
         SPACE 1
*   FORMS CONTROL CHARACTER TABLE
PRINTXIT EQU   *
         LM    XR2,XR4,OLDREGS RESTORE OLD WORK REGS
         BR    RETURNR           AND EXIT TO CALLER
         SPACE 3
EROR2RTN EQU   *       PARM NAME PASSED CAN NOT BE FOUND
         XMSG  MESS3,PARMNAME,MCSFLAG=REG4,MF=(E,XMSGL)
         B     PARMEXIT      SET EXIT FOR PRINT
         SPACE
CHECXCNT STM   XR14,XR13,CXSV SAVE REGS
         CLC   REG4,=CL4'TSO'
         BE    NOXWTOR        NO QUESTION IF TSO
         L     XR0,XCNT      GET NUMBER OF  XMSGS SO FAR
         AH    XR0,=H'1'     PLUS 1
         ST    XR0,XCNT      AND SAVE
         SRDA  XR0,32        SET UP FOR DIVIDE
         D     XR0,XMAX      SEE IF ENOUGH HAVE BEEN ISSUED
         LTR   XR0,XR0       IF ZERO, NUMBER IS REACHED
         BNZ   NOXWTOR       DO NOT ASK
         XMSG  MESS4,REPLY=ANS,MCSFLAG=REG4,MF=(E,XMSGL)
         CLI   ANS,C'N'      CONTINUE/Q
         BE    CHECEX0       NO
NOXWTOR  LM    XR14,XR13,CXSV
         B     4(RETURNR)
CHECEX0  LM    XR14,XR13,CXSV
         BR    RETURNR
         TITLE 'CONSTANTS AND WORKAREAS'
XMAX     DC    A(12)
MESS1    DC    C'XDEVT01 UNIT NAME - <1C>'
MESS2    DC    C'XDEVT02 <1C>'
MESS3    DC    C'XDEVT03 DEVTYPE <1C> NOT RECOGNISED'
MESS4    DC    C'XDEVT04 REPLY TO CONTINUE - Y (YES) OR N (NO)'
TRTBK    DC    XL256'00'
         ORG   TRTBK+C' '
         DC    C' '
         ORG   TRTBK+C','
         DC    C','
         ORG
         LTORG
         XPARM
WORK     DSECT
SAVEAREA DS    18F
PRINTR14 DS    F               SAVE CALLER'S RETURN REG
RET14    DS    F      SAVE FOR RETURN REG (CALLER)
OLDREGS  DS    3F     SAVE REGS AT ENTRY TO PRINT ROUTINE
PRINTREG DS    3F     SAVE FOR PRINT ROUTINE REGS
CXSV     DS    16F    SAVE AREA FOR CHECK XMSG COUNT
XCNT     DC    A(0)
ANS      DS    C
         SPACE 2
XMSGL    XMSG  ,,MF=L
         SPACE 1
CVTPTR   EQU   X'10'        ADDR OF CVT
CVTILK2  EQU   X'28'        ADDR OF UCB HALFWORD ADDR LIST SECTION
*                           IN UCB LOOK-UP TABLE (IECILK2)
SWITCHES DS    X            ONE BYTE SWITCH
DEVNAME  EQU   X'80'        DEVICE NAME SPECIFIED IN PARM LIST
ENDPARMS EQU   X'40'        END OF PARM LIST INDICATOR
INITFN   EQU   X'20'        INITIALIZE PRINT BUFFER SW
         SPACE 1
PRINTLIN DS    0CL133
PRINTWRK DS    CL70
         ORG
         SPACE 1
DNMTPTR  DS    F            SAVE AREA FOR PTR TO DEVNAMET
DMSKTPTR DS    F            SAVE AREA FOR PTR TO DEVMASKT
PARMNAME DS    CL8          PARM NAME HOLD AREA
UCBNAME  EQU   X'0D'        EBCDIC UNIT NAME UIN UCB (3 BYTES)
UCBLKUP  DS    F            PTR TO UCB LOOK-UP TABLE
PARMPTRS DS    2F           SAVE PARM REGS
         REGISTER
RETURNR  EQU   XR14
         SPACE 3
WORKL    EQU   *-WORK
DMTSECT  DSECT              DEVICE MASK TABLE ENTRY DSECT
DMTRESRV DS    X            RESERVED
DMTSTAT  DS    X            ENTRY STATUS
DMT#DEVS DS    XL2          # OF POSSIBLE DEVICES
DMTDEVTY DS    XL4          DEVICE TYPE
DMTBITS  DS    X            BIT PATTERN OF POSSIBLE DEVICES (VARIABLE
*                           LENGTH)
MASKBASE EQU   DMTBITS-DMTSECT  LENGTH OF MASK ENTRY BASE
         SPACE 2
DNTSECT  DSECT              DEVICE NAME TABLE ENTRY DSECT
DNTNAME  DS    CL8          DEVICE NAME
DNTDEVTY DS    XL4          DEVICE TYPE
NAMELEN  EQU   *-DNTSECT    LENGTH OF NAME ENTRY
         SPACE 2
         END
