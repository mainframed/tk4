./ ADD  NAME=BASFGEN
         MACRO
         BASFGEN &SYS=OS
         AIF   ('&SYS' EQ 'DOS').COP
         AIF   ('&SYS' EQ 'OS').COP
         MNOTE 12,'SYSTEM NOT SUPPORTED, SPECIFY DOS OR OS'
         MEXIT
.COP     ANOP
         BGENMAC SYS=&SYS
PARMLEN  EQU   PARMEND-MAINPARM
         TITLE '   BASFGEN  CONTROL ROUTINE'
BASFGEN  CSECT
         AIF   ('&SYS' EQ 'OS').OSXS
         SPACE 5
*
*   EXPLANATION FOR DOS USERS :
*     DD - CARD: DATA DEFINITION CARD TO BE PUT BEHIND THE
*        PROGRAM PARAMETERS
*     SYS000 AQUIVALENT TO SYSUT1  ( BASFGEN INPUT )
*     SYS001 AQUIVALENT TO SYSUT2  ( BASFGEN OUTPUT )
*     SYS002 AQUIVALENT TO SYSUT3  ( BASFGEN SEPERATED FILES )
*     SYS003 AQUIVALENT TO SYSUT4  ( BASFGEN SEPERATED FILES )
*     SYS004 AQUIVALENT TO SYSUT5  ( BASFGEN SEPERATED FILES )
*     SYS005 AQUIVALENT TO SYSUT6  ( BASFGEN SEPERATED FILES )
*     SYSRDR AQUIVALENT TO SYSIN   ( BASFGEN CONTROL CARDS )
*     SYSLST AQUIVALENT TO SYPRINT ( BASFGEN PROTOKOLL )
*     SYS005 HIGHEST SEPERATING NUMBER ALLOWED IN DOS
*
         SPACE 5
*        EXTXS BAS,SVA,BASFGEN,TYP=M
         EXTXS BAS,SVA,BASFGEN,TYP=M
         LA    R0,PARMLEN+72 GET STORAGE FOR DSECT
*        EXTGM R,LV=(0),MOD=GM  GETMAIN
         EXTGM R,LV=(0),MOD=GM  GETMAIN
         LR    R13,R1        GET ADDRESS OF NEW SAVE AREA
         MVC   0(72,R13),SVA     MOVE SAVE AREA OF EXTXS TO NEW
         AGO   .USING
.OSXS    ANOP
*        XSAVE BAS,,BASFGEN,PARMLEN+72
         XSAVE BAS,,BASFGEN,PARMLEN+72
         USING IHADCB,WK1
.USING   ANOP
         LA    PRM,72(R13)   MAINPARMFIELD BEGINS BEHIND THE SAVEAREA
         USING MAINPARM,PRM
         AIF   ('&SYS' EQ 'OS').LNKPARM
         XC    MAINPARM(256),MAINPARM   SET GETMAINED AREA TO X'00'
         XC    MAINPARM+256(PARMLEN-256),MAINPARM+256
         MVC   VGM,GM           MOVE RELOCATED ADDR TO VECTOR
         LA    WK1,DTFTAB     GET ADDR OF DTF TABLE
         ST    WK1,CURDTF     SAVE IT AS 1ST CURRENT ENTRY ADDR
         ST    WK1,ASEPDCBS  SAVE TABLE POINTER ADDR IN VECTOR
         LA    WK1,DTF       PICK UP SYSPRINT DTF ADDR
         ST    WK1,ALISTE    SAVE IT IN VECTOR
         LA    WK1,IOLST     PICK UP IOAREA ADDR
         ST    WK1,ALIST     SAVE IT
*        OPENR EXECDD,DTF    OPEN DD CARD DTF AND SYSPRINT DTF
         OPENR EXECDD,DTF    OPEN DD CARD DTF AND SYSPRINT DTF
*   IN DOS IT IS NOT USEFUL TO RETURN WITHOUT A DUMP, IF ONE OF THE
*   DTF'S COULD NOT BE OPENED. THEREFORE A CORRECT OPEN IS ASSUMED
         OI    SWOPEN,PRTOPEN+INOPEN ASSUME OPEN O.K.
         L     WK2,ALIST     GET DTF ADDR FOR SYSPRINT
         USING AZEILE,WK2
         BAL   LNK,CLEARLIN  BLANK OUT OUTPUT LINE
         MVI   ASA,C'1'      NEXT PAGE
         MVC   ACARDOUT(L'DDMSG),DDMSG MOVE MESSAGE
         BAL   LNK,PUTDD
         BAL   LNK,CLEARLIN
         MVI   ASA,C'-'      TWO LINES BLANK
         BAL   LNK,PUTDD
         DROP  WK2
         LA    R1,EXECDD     PROVIDE SELF- RELOCATIBILITY
         ST    R1,AKARTE     SAVE SYSIN DTF ADDR
*        GET   (1)            READ EXEC PARAMETERS- MUST BE 1ST OF FILE
         GET   (1)            READ EXEC PARAMETERS- MUST BE 1ST OF FILE
         LA    WK1,80         LENGTH FOR SEARCH
         LA    PNT,EXECIN     SET POINT REG ON INPUT AREA
         ST    PNT,ACARD     SAVE IT FOR GENINPUT
LOOP     EQU   *
         CLI   0(PNT),C' '    SEARCH START OF OPERAND
         BNE   EXECST         START FOUND
         LA    PNT,1(PNT)     LOOK NEXT POSITION
         BCT   WK1,LOOP
         B     PARMERR        WHOLE CARD BLANK
EXECST   EQU   *
         CLC   0(3,PNT),=C'SYS' EXEC CARD MISSING ?
         BE    CARDREAD       INTERPRET DD CARDS
         L     WK2,ALIST
         USING AZEILE,WK2
         BAL   LNK,CLEARLIN
         MVI   ASA,C'-'      SKIP 2
         MVC   ACARDOUT(L'EXECIN),EXECIN MOVE CARD TO LINE
         MVC   AFLAG(L'PARA),PARA MOVE 'PARAMETER'
         MVI   ACARDOUT-1,C'*' SHOW BEGIN OF CARD
         BAL   LNK,PUTDD
         DROP  WK2
         LR    WK2,PNT       PICK UP START ADDR
EPRMS    EQU   *
         CLI   0(WK2),C' '   IS END ?
         BE    SVLENGTH
         LA    WK2,1(,WK2)   SEE NEXT CHAR
         BCT   WK1,EPRMS     LOOK FOR END OF CARD
SVLENGTH EQU   *
         LR    R0,WK2        PARM END ADDR (1ST BLANK BEHIND PARMS)
         SR    R0,PNT        -START ADDR=LENGTH FOR GETMAIN
         LR    WK1,R0        SAVE LENGTH FOR LATER MOVE
*        EXTGM R,LV=(0),MOD=VGM
         EXTGM R,LV=(0),MOD=VGM
         ST    R1,APARM      SAVE ADDR OF PARMS IN VECTOR
         USING EXECPRMS,R1
         STH   WK1,PARMLL     STORE PA-M LENGTH
         BCTR  WK1,0          - 1 (EX)
         EX    WK1,MVEXEC     MOVE EXEC PARAMETER INTO GENVEC
         B     SEPS          SKIP MVC TO BE DONE BY EX
MVEXEC   MVC   PRMS(0),0(PNT) MOVE EXEC PARAMETER INTO VECTOR
         DROP  R1
         SPACE 2
* WORK SEPERATION CARDS (OR DD CARDS FOR NO DEFAULT IN & OUTPUT)
SEPS     EQU   *
         LA    R1,EXECDD      GET DD DTF
*        GET   (1)           READ FIRST DD CARD
         GET   (1)           READ FIRST DD CARD
CARDREAD EQU   *             NOW SYS... CARDS FOLLOWING
         LR    WK1,WK2       SAVE WK2
         L     WK2,ALIST
         USING AZEILE,WK2
         BAL   LNK,CLEARLIN
         MVI   ASA,C'-'      2 LINES
         MVC   ACARDOUT(L'EXECIN),EXECIN MOVE DD CARD TO SYSPRINT
         MVC   AFLAG(L'DDC),DDC MOVE 'DD- CARD'
         MVI   ACARDOUT-1,C'*' SHOW START OF CARD
         BAL   LNK,PUTDD
         DROP  WK2
         LR    WK2,WK1       GET OWN VALUE AGAIB
         L     WK1,CURDTF     LOAD CURRENT DTF ADDR
         CLI   4(WK1),0      1ST UNUSED ENTRY (ID STILL X'00')  ???
         BE    LOADPNT        NO CHAINING
         LA    WK2,ENTRYLL(WK1) SET ON NXT ENTRY
         ST    WK2,0(WK1)     STORE IT INTO CURRENT
         ST    WK2,CURDTF     SAVE IT AS NEW CURRENT
LOADPNT  EQU   *
         LA    PNT,EXECIN     SET PNT ON INPUT AREA
         LA    WK1,80         LENGTH FOR SEARCH
FINDANF  EQU   *
         CLI   0(PNT),C' '    BLANK ?
         BNE   SYSANF         NO : START FOUND
         LA    PNT,1(PNT)     PNT + 1
         BCT   WK1,FINDANF    LOOK AGAIN
         B     PARMERR        MAX 80
SYSANF   EQU   *
         CLC   0(5,PNT),=C'SYS00' MUST START WITH SYS00
         BNE   PARMERR
         CLI   5(PNT),C'5'    SYS005 HIGHEST ALLOWED
         BH    PARMERR
         CLC   OLDID,5(PNT)  ASCENDING DD CARD NUMBERS
         BNL   ORDERR .     ARE BGENDTF REQUIREMENT
         MVC   OLDID,5(PNT)  SAVE THIS ID FOR NEXT COMPARISON
         L     WK2,CURDTF
         USING DTFTAB,WK2
         MVC   ID,5(PNT)      SAVE ID IN TAB
         LA    PNT,7(PNT)     POINT TO 1ST KEYWORD OR BLANK
         LA    WK1,66         80-7 (SYSXXX) -7(SHORTEST OP) =66
FINDKEYW CLI   0(PNT),C' '
         BNE   KEYANF
         LA    PNT,1(PNT)     +1
         BCT   WK1,FINDKEYW
         B     PARMERR
KEYANF   EQU   *              START OF KEYWORDS
         CLC   RECFORM,0(PNT) RECFM= ?
         BE    RECFSPEC       RECFORM SPECIFIED
         CLC   BLKSIZE,0(PNT) BLKSIZE= ?
         BE    BLKSPEC
         CLC   RECLEN,0(PNT) LRECL = ?
         BE    RECLSPEC
         CLC   UNIT,0(PNT)    UNIT= ?
         BE    UNITSPEC
         CLC   LABEL,0(PNT)   LABEL =  ?
         BE    LABSPEC
         CLC   ASAY,0(PNT)   WAS ASA=   ?
         BE    ASASPEC
         CLC   SYS,0(PNT)    WAS SYS =   ?
         BE    SYSPEC
         B     PARMERR       NOTHING BUT THOSE KEYWORDS ALLOWED
         SPACE 2
RECFSPEC EQU   *              RECORD FORMAT
         LA    PNT,L'RECFORM(PNT) SET ON OPERAND
         CLI   0(PNT),C'F'    FIX ?
         BE    FIX
         CLI   0(PNT),C'V'    VARIABLE ?
         BNE   PARMERR
         MVI   RECFM,C'V'     SET RECORD FORMAT IN PHASE NAME TO BE
         B     RECUP               LOADED TO V
FIX      MVI   RECFM,C'F'     SET RECFM TO FIX
RECUP    EQU   *
         LA    PNT,1(PNT)     + 1
         CLI   0(PNT),C'B'    WAS FB OR VB CODED ? TREAT AS F OR V
         BNE   TSTDEL         TEST DELIMITER FOLLOWING OPERAND
         LA    PNT,1(PNT)     SET OVER B
         OI    DTFFLAG,BLOCKED BLOCKED RECORDS, INDICATE TO DTF
         B     TSTDEL
         SPACE 2
SYSPEC   EQU   *
         LA    PNT,L'SYS(PNT) SET OVER SYS=
         CLC   0(L'YES,PNT),YES SYS=YES ?
         BNE   ISSYSNO       IF NOT: LOOK IF SYS=NO
         LA    PNT,L'YES(PNT) SET OVER "YES"
*        NOTHING TO DO, SYS=YES IS DEFAULT VALUE
         B     TSTDEL
ISSYSNO  EQU   *
         CLC   0(L'NO,PNT),NO SYS=NO   ?
         BNE   PARMERR       NOTHING BUT YES OR NO ALLOWED
         OI    DTFFLAG,NOSYS SET SYS=NO BIT
         LA    PNT,L'NO(PNT) SET OVER "NO"
         B     TSTDEL
         SPACE 2
ASASPEC  EQU   *             ASA=     WAS
         LA    PNT,L'ASAY(PNT) SET OVER ASA=
         CLC   0(L'YES,PNT),YES ASA=YES ?
         BNE   ISASANO
         OI    DTFFLAG,ASAPR SET ASA WANTED BIT
         LA    PNT,L'YES(PNT) SET OVER : YES
         B     TSTDEL
ISASANO  CLC   0(L'NO,PNT),NO ASA=NO ?
         BNE   PARMERR       EITHER YES OR NO ALLOWED
*        NOTS TO DO:   ASA=NO IS DEFAULT
         LA    PNT,L'NO(PNT) SET OVER: NO
         B     TSTDEL
         SPACE 2
BLKSPEC  EQU   *              BLKSIZE
         LA    PNT,L'BLKSIZE(PNT) SET ON OPERAND
         BAL   LNK,GETSIZE    RECKON CODED SIZE
         STH   WK1,BLKL       SAVE FOUND BLOCKSIZE
         B     TSTDEL
RECLSPEC EQU   *              RECORD LENGTH
         LA    PNT,L'RECLEN(PNT)
         BAL   LNK,GETSIZE
         STH   WK1,RECL       SAVE FOUND RECORD LENGTH
         B     TSTDEL
LABSPEC  EQU   *   LABEL =   WAS SPECIFIED
         LA    PNT,L'LABEL(PNT)   SET ON PARM
         CLC   0(2,PNT),=C'SL'  STANDARD LABEL CHECKING ?
         BNE   TSTNL            NO
         OI    DTFFLAG,DTFSL    SHOW LABEL TEST WANTED
         B     ADD2          SET UP POINTER
TSTNL    EQU   *             LOOK IF NL WANTED
         CLC   0(2,PNT),=C'NL'  WAS NL CODED ?
         BNE   PARMERR       NOTHING BUT NL OR SL ALLOWED
         NI    DTFFLAG,255-DTFSL  MAKE SURE IT IS 0
ADD2     LA    PNT,2(PNT)    SET ON NEXT KEYWORD
         B     TSTDEL        TEST NEXT DELIMITER
         SPACE 1
GETSIZE  EQU   *
         LR    WK1,PNT       GET START OF SIZE
SZEND    EQU   *             IS SIZE END ?
         CLI   0(WK1),C'0'   ANY OTHER THAN NUMBER ?
         BL    BLKEND        IF LOW: END FOUND
         LA    WK1,1(,WK1)   SEE NEXT
         B     SZEND
BLKEND   EQU   *
         SR    WK1,PNT        LENGTH OF SIZE PARM IN WK1
         LTR   WK1,WK1       NO NUMBERS AT ALL ?
         BZ    PARMERR       IF YES: ERROR
         BCTR  WK1,0          -1 (EX)
         EX    WK1,PACK       PACK SIZE
         AR    PNT,WK1        SET PNT ON ,
         LA    PNT,1(,PNT)   + 1 (EX)
         CVB   WK1,DBL
         BR    LNK
PACK     PACK  DBL,0(0,PNT)   PACK BLOCK OR RECORD SIZE
DBL      DC    D'0'           DOUBLE WORD
         SPACE 2
UNITSPEC EQU   *
         LA    PNT,L'UNIT(PNT) UNIT TYPE
         CLC   MTAPE,0(PNT)  UNIT=TAPE ?
         BNE   ISPRT
         MVI   DEVTYPE,C'T'   BUILD MODULE NAME
         LA    PNT,L'MTAPE(PNT)  SET OVER "TAPE"
         B     TSTDEL        TEST DELIMITER
ISPRT    CLC   PRINTER,0(PNT) UNIT=PRINTER ?
         BNE   ISRDR
         MVI   DEVTYPE,C'P'   SHOW PRINTER WANTED
         LA    PNT,L'PRINTER(PNT)  SET OVER "PRINTER"
         B     TSTDEL        TEST DELIMITER
ISRDR    CLC   READER,0(PNT) UNIT=READER ?
         BNE   ISPCH
         MVI   DEVTYPE,C'C'   SHOW CARD,WITH INPUT:RDR,WITH OUTPUT:PCH
         LA    PNT,L'READER(PNT)  SET OVER "READER"
         B     TSTDEL        TEST DELIMITER
ISPCH    CLC   PUNCH,0(PNT)  UNIT=PUNCH ?
         BNE   ISSEQD
         MVI   DEVTYPE,C'C'   SHOW CARD
         LA    PNT,L'PUNCH(PNT)  SET OVER "PUNCH"
         CLI   ID,C'0'        PUNCH CANNOT BE ASSOCIATED WITH SYS000
         BE    PARMERR        WHICH MEANS INPUT
         B     TSTDEL        TEST DELIMITER
ISSEQD   CLC   SEQDISK,0(PNT)     SEQUENTIAL DISK FILE WANTED ?
         BNE   PARMERR        NOTHING ELSE POSSIBLE
         MVI   DEVTYPE,C'S'   SHOW SEQDISK
         LA    PNT,L'SEQDISK(PNT)  SET OVER "SEQDISK"
         CLI   0(PNT),C'1'   2311 INDICATED ?
         BNE   IS2314        NO, TEST 2314
         OI    DTFFLAG,D2311 YES,SET ON INDICATOR
         B     ADD1
IS2314   CLI   0(PNT),C'2'   2314 INDICATED ?
         BNE   IS3330        NO, TEST 3330
         OI    DTFFLAG,D2314 YES SET 2314 INDICATOR
         B     ADD1
IS3330   CLI   0(PNT),C'3'   3330 ?
         BNE   PARMERR       NOTS BUT 2311 - 2314 - 3330 ALLOWED
         OI    DTFFLAG,D3330 SET 3330 SWITCH BIT
ADD1     EQU   *
         LA    PNT,1(PNT)    SET OVER DEVICE INDICATOR SIGN
*        B     TSTDEL        TEST DELIMITER
         SPACE 3
TSTDEL   EQU   *              TEST DELIMITER BETWEEN KEYWORDS
         CLI   0(PNT),C','    IS IT A COMMA ?
         BNE   SEEND          IF NOT, IT MAY ONLY BE A BLANK AT END
         LA    PNT,1(PNT)     SET ON NEXT KEYWORD
         B     KEYANF         INTERPRET NEXT KEYWORD
SEEND    EQU   *
         CLI   ID,C'0'        SYS000 ? (INPUT ?)
         BNE   OUT            IF NOT: OUTPUT
         MVI   INOUT,C'I'     YES, SHOW INPUT
         B     SEEDEF        LOOK FOR DEFAULT VALUES
OUT      MVI   INOUT,C'O'     SHOW OUTPUT  ( ^ SYS000 )
         SPACE 2
*   FILL IN DEFAULT VALUES
SEEDEF   CLI   RECFM,0       WAS RECFM =   ?
         BNE   FMSET         YES IF NOT 0
         MVI   RECFM,C'F'    FIX IS DEFAULT
FMSET    EQU   *
         CLC   RECL(2),=X'0000' WAS LRECL =   ?
         BE    WASBLK        IF = LRECL OMITTED
         CLC   BLKL(2),=X'0000' WAS BLKSIZE =  ?
         BNE   LOGCHECK
         MVC   BLKL(2),RECL  MOVE LRECL TO BLOCKSIZE
         B     WASFIX        TEST RECFM
WASBLK   EQU   *
         CLC   BLKL(2),=X'0000'
         BE    SETRECL       NEITHER LRECL NOR BLKSIZE SPECIFIED
         MVC   RECL(2),BLKL  LRECL = BLKSIZE
         B     LOGCHECK
SETRECL  EQU   *             LRECL AND BLOCKSIZE OMITTED
         LA    WK1,80        DEFAULT VALUE IS 80
         STH   WK1,RECL      SAVE IT IN LRECL FIELD
WASFIX   EQU   *
         CLI   RECFM,C'F'    FIX RECORDS ?
         BE    BLKREADY      YES: BLOCKSIZE = RECORD LENGTH
         LA    WK1,4(,WK1)   NO. VARIABLE: ADD 4
BLKREADY STH   WK1,BLKL      SAVE BLKSIZE
         DROP  WK2
*   DEFAULT VALUES OK
         SPACE 1
LOGCHECK EQU   * SPECIFICATIONS LOGICALLY RIGHT ???
         CLI   INOUT,C'I'    WAS INPUT ?
         BE    CHKPI         CHECK PRINTER INPUT
         CLI   DEVTYPE,C'P'  OUTPUT, IS PRINTER ?
         BE    ISEND         ALL OK
         TM    DTFFLAG,ASAPR WAS ASA=YES ?
         BO    PARMERR       IF YES: NO PRINTER, BUT ASA= YES: RUBBISH
         B     CHKCD         CHECK CARD
CHKPI    CLI   DEVTYPE,C'P'  WAS INPUT + PRINTER ?
         BE    PARMERR       IF YES: RUBBISH
CHKCD    CLI   DEVTYPE,C'C'  CARD INPUT OR OUTPUT ?
         BNE   ISEND         O.K.
         CLI   RECFM,C'V'    YES, TEST IF RECFM WAS V
         BE    PARMERR       IF YES: CARD + RECFM=V: RUBBISH
         SPACE 2
ISEND    EQU   *
         CLI   0(PNT),C' '    BLANK ?
         BE    SEPS           GET NEW  DD CARD
         B     PARMERR        ONLY COMMA ALLOWED OR BLANK AT END
         SPACE 3
SEPEND   EQU   *              END OF DD CARDS
         USING AZEILE,WK2
         L     WK2,ALIST     BASE FOR OUTPUT LINE
         L     WK1,ASEPDCBS  LOAD DTF POINTER
         LTR   WK1,WK1       ZERO ? (NO DTF SPECIFIED)
         BZ    ORDERR        NOT ALLOWED
         L     WK1,0(WK1)    GET POINTER
         LTR   WK1,WK1       ZERO ? (ONLY ONE DD)
         BZ    ORDERR        NOT ALLOWED
*   AT LEAST SYS000 AND SYS001 MUST BE SPECIFIED
*        LOAD  BGENCVEX
         LOAD  BGENCVEX
         LA    R14,AFETCH1   GET RETURN ADDRESS FROM FETCH ROUTINE
*        FETCH BGENPARM
         FETCH BGENPARM
AFETCH1  EQU   *
         AGO   .ISERR
.LNKPARM ANOP
         XC    MAINPARM(PARMLEN),MAINPARM
         L     R1,0(R1)
         ST    R1,APARM      SAVE THE EXEC PARAMETERS
         LR    R1,PRM
*        LINK  EP=GENPARM
         LINK  EP=GENPARM
.ISERR   ANOP
         TM    SW2,ERR
         BO    PARMERR
         AIF   ('&SYS' EQ 'OS').LINKOP
         LA    R14,AFETCH2   GET RETURN ADDRESS FROM FETCH ROUTINE
*        FETCH BGENOPEN
         FETCH BGENOPEN
AFETCH2  EQU   *
         AGO   .OVOPEN
.LINKOP  ANOP
*        LINK  EP=GENOPEN
         LINK  EP=GENOPEN
         USING AZEILE,WK2
         L     WK2,ALIST     BASE FOR OUTPUTLINE
.OVOPEN  ANOP
         TM    SWOPEN,ALLOPEN
         BNO   OPENERR
         AIF   ('&SYS' EQ 'OS').LINKCOR
         LA    R14,AFETCH3   GET RETURN ADDRESS FROM FETCH ROUTINE
*        FETCH BGENCORE
         FETCH BGENCORE
AFETCH3  EQU   *
         AGO   .OVCORE
.LINKCOR ANOP
*        LINK  EP=GENCORE
         LINK  EP=GENCORE
.OVCORE  ANOP
         TM    SW2,COREFULL
         BO    COREERR
         L     R0,VGENHEAD    GET ADDRESS OF HEADER PRINT ROUTINE
         ST    R0,AHEADPRT   STORE IT TO PARM LIST
         L     R0,VLFDNR
         ST    R0,ALFDNR     SAVE ADDRESS OF ROUTINE
         L     R0,VLFDNRD
         ST    R0,ALFDNRD    SAVE ADDRESS OF ROUTINE
         L     R0,VCONVXE
         ST    R0,ACONVXE     SAVE ADDRESS
         AIF   ('&SYS' EQ 'OS').LINKINP
*        LOAD  BGENERR       LOAD READ ERROR ROUTINE
         LOAD  BGENERR
RDSYSIN  EQU   *
         LA    R14,AFETCH4   GET RETURN ADDRESS FROM FETCH ROUTINE
*        FETCH BGENIPUT
         FETCH BGENIPUT
AFETCH4  EQU   *
         AGO   .OVINP
.LINKINP ANOP
*DSYSIN  LINK  EP=GENINPUT
RDSYSIN  LINK  EP=GENINPUT
         TM    SW2,IMSORG
         BO    IMSEND
.OVINP   ANOP
         B     *+4(R15)      VARIABLE BRANCH
         B     INPERR        IF RETURN IS FROM INPUT-ROUTINE
         B     NORMEND       IF RETURN IS FROM OUTPUT ROUTINE
CLEARLIN EQU   *
         MVI   ASA,BLANK
         MVC   AFLAG(ALINELEN),ASA     CLEAR THE OUTPUT LINE
         BR    LNK           AND RETURN
         AIF   ('&SYS' EQ 'OS').OSCLOSE
CLOSE    EQU   *
         LA    WK1,0(,WK1)   SET HIGH ORDER BYTE TO ZERO
*        CLOSER (WK1)        CLOSE DTF POINTED TO BY WK1
         CLOSER (WK1)        CLOSE DTF POINTED TO BY WK1
         BR    LNK           GO BACK
         AGO   .NORMEND
.OSCLOSE ANOP
CLOSE    EQU   *
         OI    ACARD,ENDINDIC SET END INDICATOR FOR REL 21 MACRO IS TOO
*                            STUPID TO COUNT THE DCBS TO BE CLOSED
*        CLOSE ((WK1)),MF=(E,ACARD)    CLOSE THE DCB POINTED TO BY WK1
         CLOSE ((WK1)),MF=(E,ACARD)    CLOSE THE DCB POINTED TO BY WK1
         TM    DCBMACR,QUEUED         IS THIS A QSAM-DCB ?
         BO    FREEPOOL      IF YES, FREE THE BUFFER POOL
         TM    DCBMACR+1,QUEUED       IS THIS A QSAM OUTPUT DCB ?
         BCR   8,LNK         IF NOT, RETURN
FREEPOOL EQU   *
*REEPOOL FREEPOOL (WK1)      ISSUE FREEPOOL MACRO
         TM    DCBBUFCB+3,1 .IS BUFFER ADDRESS VALID ?
         BCR   1,LNK .       NO, THAN DON'T TRY TO FREE POOL
*                            MACRO IS TOO STUPID
         FREEPOOL (WK1)      ISSUE FREEPOOL MACRO
         BR    LNK           AND RETURN
.NORMEND ANOP
NORMEND  EQU   *
         TM    SWINPUT,EODADIN   WAS END OF DATA ON SYSIN ?
         BO    TOTALEND      YES, TERMINATE PROCESSING
         TM    SWFUNC,WRNGEOD     WAS END OF DATA UNEXPECTED ?
         BZ    RDSYSIN       IF NOT , LOOK FOR MORE WORK
         BAL   LNK,CLEARLIN     CLEAR THE OUTPUT LINE
         MVC   AFLAG(L'EODMSG),EODMSG  MOVE MESSAGE TO OUTPUT LINE
         L     R1,ALISTE
         PUT   (1),(WK2)     PUT THE MESSAGE
TOTALEND EQU   *
         L     WK1,AINPUT    GET SYSUT1 DCB-ADDRESS
         BAL   LNK,CLOSE
IMSEND   EQU   *
         L     WK1,AKARTE    GET SYSIN DDCB ADDRESS
         BAL   LNK,CLOSE
         L     WK1,AOUTPUT   GET SYSUT2 DCB ADDRESS
         BAL   LNK,CLOSE
         TM    SWTAB,PRINTREF IS REFERNCE PRINT REQUIRED ?
         BZ    NOTABREF .    NO, TERMINATE
         SR    LIMIT,LIMIT . INDICATE FINAL PRINT TO 'GENTABLE'
         AIF   ('&SYS' EQ 'OS').TABPRT
         LA    R14,AFETCHT . GET RETURN ADDRESS
*        FETCH BGENTAB
         FETCH BGENTAB
AFETCHT  EQU   *
         AGO   .ATABEND
.TABPRT  ANOP
*        LINK  EP=GENTABLE . LINK TO GENTABLE FOR PRINT
         LINK  EP=GENTABLE . LINK TO GENTABLE FOR PRINT
.ATABEND ANOP
NOTABREF EQU   *
         L     WK1,ALISTE    GET SYSPRINT DCB-ADDRESS
         BAL   LNK,CLOSE
         LA    PNT,8(PRM)    POINT TO PARMLIST TO BE NOW CONSRTUCTED
         LR    MSG,PNT       AND SAVE THAT POINTER
         L     R1,INRECANF   TABLE FOR SYSUT1
         BAL   LNK,TSTAST    LOOK IF AST WAS REQUESTED FOR DDNAME
         L     R1,INRECEND   TABLE FOR SYSUT2
         BAL   LNK,TSTAST    LOOK IF AST WAS REQUESTED FOR DDNAME
         L     LIMIT,ASEPDCBS GET ADDRESS OF FURTHER DCBS
SEPDCBCL EQU   *
         LTR   LIMIT,LIMIT   ARE THERE FURTHER ONES
         BZ    ENDSEP
         L     R1,12(LIMIT)  GET TABLE ADDRRESS IF AST WAS REQ.
         BAL   LNK,TSTAST    LOOK IF AST WAS REQUESTED FOR DDNAME
         L     WK1,4(LIMIT)  GET THE DCB-ADDRESS
         BAL    LNK,CLOSE
         L     LIMIT,0(LIMIT) POINT TO NEXT SEP-DCB SECTION
         B     SEPDCBCL
TSTAST   EQU   *
         LTR   R1,R1         IS A TABLE
         BCR   8,LNK         IF NOT, RETURN
         ST    R1,0(PNT)     STORE ITS ADDRESS TO PARMLIST
         LA    PNT,4(PNT)    AND INCREASE PARM POINTER
         BR    LNK           AND RETURN
ENDSEP   EQU   *
         CR    PNT,MSG       WAS ATLEST ONE TABLE ?
         BE    RET0          NO, NO AST WILL TAKE PLACE
         SH    PNT,=H'4'     REDUCE POINTER REG TO LAST ENTRY
         CR    MSG,PNT       WAS ONLY ONE TABLE ?
         BE    SORTEND       IF YES, DON'T SORT
SORTANF  LR    WK1,MSG       GET START OF TABLE ADDRESSES
VERGL    CLC   0(1,WK1),4(WK1) IS NEXT TABLE ID HIGH OR EQUAL ?
         BH    EXCHANGE      NO, EXCHANGE THE TWO ENTRIES
         LA    WK1,4(WK1)    POINT TO NEXT ENTRY
         CR    WK1,PNT       IS IT THE LAST ONE ?
         BL    VERGL         NO, LOOK FURTHER ON
SORTEND  EQU   *
         L     R0,AACCU .    GET ADDRESS OF ACCUS
         LTR   R0,R0 .        ARE ACCUS ?
         BZ    NOACCUS .      DON'T USE ACCUS IF NOT PRESENT
         LA    PNT,4(PNT) .  INCREASE PARM POINTER
         ST    R0,0(PNT) .   STORA ACCU ADDRESS AS LAST PARM
NOACCUS  EQU   *
         LA    R0,ANZUPS     WILL BE RETURN CODE FROM COBAST
         ST    R0,0(PRM)     STORE ITS ADDRESS AS FIRST PARAMETER
         LA    R0,ADATE       REPORT TIME WILL BE CURRENT DATE
         ST    R0,4(PRM)     STORE IT AS SECOND PARAMETER
CLEARHI  EQU   *
         MVI   0(MSG),0      CLEAR HIGH ORDER BYTES IN ALL PARM FLDS
         CR    MSG,PNT       IS LAST REACHED ?
         BNL   CALLAST       IF YES, GO TO CALL AST-ROUTINE
         LA    MSG,4(MSG)    POINT TO NEXT PARM
         B     CLEARHI       AND DO ALSO
EXCHANGE EQU   *
         LM    R0,R1,0(WK1)  GET THE COMPARED ENTRIES
         ST    R1,0(WK1)     AND RESTORE THEM
         ST    R0,4(WK1)     IN REVERSED ORDER
         B     SORTANF       THEN START THE SORT AGAIN
CALLAST  EQU   *
         OI    0(PNT),ENDINDIC  INDICATE LAST PARM
         AIF   ('&SYS' EQ 'OS').OSAST
*        LOAD  COBAST        LOAD ABSTIMM- ROUTINE
         LOAD  COBAST
         LR    R15,R1        GET ENTRY
         LR    R1,PRM        POINT TO PARMS FOR COBS
         BALR R14,R15
         LH    R15,ANZUPS    LOAD RETURN CODE FROM COBAST
         LTR   R15,R15       IS O.K. ?
         BZ    RET           YES: IF ZERO
         LR    R0,R15        GET RETURN CODE FROM COBAST INTO REG 0
*        DUMP
         DUMP
         AGO   .TERM
.OSAST   ANOP
         LR    R1,PRM        POINT TO CONSTRUCTED PARMLIST
         LINK  EP=COBAST     AND LINK TO AST-ROUTINE
         LH    R15,ANZUPS    GET RETURN-CODE FROM COBAST
         B     RET           AND TERMINATE  WITH THIS CODE
.TERM    ANOP
         AIF   ('&SYS' EQ 'OS').OSXR
RET0     EQU   *
*ET      EOJ
RET      EOJ
ORDERR   EQU   *             DD- CARDS HAVE NOT BEEN SPECIFIED IN ASC O
         L     WK2,ALIST
         USING AZEILE,WK2
         BAL   LNK,CLEARLIN
         MVC   ACARDOUT(L'ORDMSG),ORDMSG MOVE MSG 'NOT ASCENDING ORDER'
         BAL   LNK,PUTDD
         B     INPERR
PARMERR  EQU   *
         L     WK2,ALIST
         BAL   LNK,CLEARLIN  CLEAR THE OUTPUT LINE
         MVC   AFLAG(L'PRMERR),PRMERR  ERRORS IN PARM CARD FOUND
         L     R1,ALISTE     LOAD DTF ADDR
*        PUT   (1),(WK2)
         PUT   (1),(WK2)
*        CANCEL
CNC      CANCEL
         AGO   .RET16
.OSXR    ANOP
RET0     EQU   *
         SR    R15,R15       RETURN WITH CODE ZERO
*ET      XRETURN (R15),R     TERMINATE PROGRAM
RET      XRETURN (R15),R     TERMINATE PROGRAM
PARMERR  EQU   *
*        WTO   'ERROR IN PARAMETERS FOR BASFGEN',ROUTCDE=11
         WTO   'ERROR IN PARAMETERS FOR BASFGEN',ROUTCDE=11
         LA    R15,16        SET CODE 16
         B     RET           AND TERMINATE
.RET16   ANOP
OPENERR  EQU   *
         TM    SWOPEN,PRTOPEN WAS SYSPRINT OPENED ?
         BZ    RET12         RETURN WITH CODE 12
         BAL   LNK,CLEARLIN  CLEAR THE OUTPUT LINE WITH BLANKS
*        OPEN SVC WILL PROVIDE A MESSAGE FOR MISSING DD-CARD   ( OS )
         TM    SWOPEN,INOPEN WAS A 'SYSIN' - DD-CARD ?
         BO    TESTINP .     LOOK IF SYSUT1 WAS MISSING
         LA    MSG,SYSIN
         BAL   LNK,WRTOPNER  WRITE THE OPEN ERROR ONTO SYSPRINT
TESTINP  EQU   *
         TM    SWOPEN,INPOPEN WAS A SYSUT1 DD-CARD ?
         BO    TESTUT2 .     LOOK FOR SYSUT2 OPENED
         LA    MSG,SYSUT1
         BAL   LNK,WRTOPNER  WRITE THE OPEN ERROR ONTO SYSPRINT
TESTUT2  EQU   *
         TM    SWOPEN,UT2OPEN WAS 'SYSUT2' DD-CARD ?
         BO    RET12         YES, RETURN WITH CODE 12
         LA    MSG,SYSUT2
         BAL   LNK,WRTOPNER  WRITE THE OPEN ERROR ONTO SYSPRINT
RET12    EQU   *
         LA    R15,12        SET RETURN CODE TO 12
         B     RET           AND TERMINATE THE PROGRAM
INPERR   EQU   *
         BAL   LNK,CLEARLIN  CLEAR THE OUTPUT LINE
         MVC   ACARDOUT(L'INERRMSG),INERRMSG  MOVE A MESSAGE
         BAL   LNK,WRTINPER  PUT THE MESSAGE
RET8     EQU   *
         LA    R15,8         SET CONDITION CODE 8
         AIF   ('&SYS' EQ 'OS').TRM8
         B     CNC           CANCEL PROG DUE TO ERRORS
         AGO   .OPERR
.TRM8    ANOP
         B     RET           AND TERMINATE PROGRAM
.OPERR   ANOP
WRTOPNER EQU   *
         MVC   ACARDOUT(6),0(MSG)      MOVE THE DD-NAME TO OUTPUT LINE
         MVC   ACARDOUT+9(L'OPENMSG),OPENMSG     MOVE AN EXPLAINATION
PUTDD    EQU   *             (DOS REQUIRED LABEL)
WRTINPER EQU   *
WRTCORER EQU   *
         L     R1,ALISTE     GET SYSPRINT DCB
*        PUT   (1),(WK2)     PUT THE LINE
         PUT   (1),(WK2)     PUT THE LINE
         BR    LNK           AND RETURN TO CALLING ROUTINE
COREERR  EQU   *
         BAL   LNK,CLEARLIN  CLEAR THE OUTPUT LINE WITH BLANKS
         MVC   ACARDOUT(L'COREMSG),COREMSG
         BAL   LNK,WRTCORER  GO TO WRITE THE MESSAGE
         B     RET12
EODMSG   DC    C'UNEXPECTED EODAD FROM SYSIN, PROCESSING TERMINATED'
OPENMSG  DC    C'DD-CARD MISSING OR MISSPELLED'
COREMSG  DC    C'NO CORE AVAILABLE, INCREASE REGION-SIZE'
SEPMSG   DC    C'OUTPUT RECORDS TO'
INERRMSG DC    C'EXECUTION CANCELLED, DUE TO INDICATED ERRORS'
         AIF   ('&SYS' EQ 'OS').NOPRMER
OLDID    DC    XL1'EF' IDS FOLLOWING: F0,F1,F2,F3,F4,F5
PARA     DC    C'PARAMETER'
DDC      DC    C'DD- CARD'
ORDMSG   DC    C'DD- CARD(S) MISSING OR NOT IN ASCENDING ORDER'
DDMSG    DC    C'BASFGEN - PARAMETER AND DD- CARD LISTING'
PRMERR   DC    C'ERROR IN PARAMETERS FOR BASFGEN MODIFICATION PROGRAM'
SYSIN    DC    CL6'SYSRDR'
SYSUT1   DC    CL6'SYS000'
SYSUT2   DC    CL6'SYS001'
RECFORM  DC    C'RECFM='      *
BLKSIZE  DC    C'BLKSIZE='     *  ALLOWED
RECLEN   DC    C'LRECL='       *  KEYWORDS
UNIT     DC    C'UNIT='       *
LABEL    DC    C'LABEL='
ASAY     DC    C'ASA='
SYS      DC    C'SYS='
MTAPE    DC    C'TAPE'       KEYWORD:   TAPE
PRINTER  DC    C'PRINTER'    KEYWORD:   PRINTER
READER   DC    C'READER'     KEYWORD:   READER
PUNCH    DC    C'PUNCH'      KEYWORD:   PUNCH
SEQDISK  DC    C'SEQDISK'    KEYWORD:   SEQDISK
YES      DC    C'YES'        FOR USE: ASA=
NO       DC    C'NO'         FOR USE: ASA=
GM       DC    V(GETMAIN)
VGENHEAD DC    V(BGENHEAD)
*XECDD   DTFCD IOAREA1=EXECIN,DEVADDR=SYSRDR,DEVICE=2540,
*              EOFADDR=SEPEND
EXECDD   DTFCD IOAREA1=EXECIN,DEVADDR=SYSRDR,DEVICE=2540,              *
               EOFADDR=SEPEND
LEXECDD  EQU   *-EXECDD
IJCFZIZ0 CDMOD
DTF      DTFPR DEVADDR=SYSLST,IOAREA1=IOLST,BLKSIZE=133,               *
               CTLCHR=ASA
IJDFAZZZ PRMOD CTLCHR=ASA
EXECIN   DS    CL80           INPUT AREA FOR FILE DESCRIPTIONS
CURDTF   DC    F'0'           CURRENT DTF ENTRY ADDRESS
         AGO   .VCONS
.NOPRMER ANOP
SYSIN    DC    CL6'SYSIN'
SYSUT1   DC    CL6'SYSUT1'
SYSUT2   DC    CL6'SYSUT2'
VGENHEAD DC    V(GENHEAD)
.VCONS   ANOP
VLFDNR   DC    V(LFDNR)
VLFDNRD  DC    V(LFDNRDEF)
VCONVXE  DC    V(CONVXE)
         LTORG
         AIF   ('&SYS' EQ 'OS').MACEND
IOLST    DS    CL133         IOAREA FOR SYSPRINT
EXECPRMS DSECT
         SPACE 2
* PARAMETERS FROM EXEC CARD (OS) ARE READ FROM FIRST INPUT CARD IN DOS.
* THEY ARE LATER PASSED TO "GENPARM"
         SPACE 1
PARMLL   DS    H   LENGTH FOR FOLLOWING PARAMETERS
PRMS     DS    CL80   FIELD FOR PARAMETERS
LPARMS   EQU   *-EXECPRMS
.MACEND  ANOP
         MEND







./ ADD  NAME=BGENDTF
         MACRO
         BGENDTF &SYS=
         AIF   (T'&SYS NE 'O').TSTDOS
         MNOTE 0,'DEFAULT VALUE FOR PARAMETER SYS IN THIS MACRO IS DOS'
.TSTDOS  ANOP
         AIF   ('&SYS' EQ 'DOS').COP
         AIF   ('&SYS' EQ 'OS').MNOTE
         MNOTE 12,'SYSTEM NOT SUPPORTED, SPECIFY DOS '
         MEXIT
.MNOTE   ANOP
         MNOTE 8,'THIS MODULE IS NOT REQUIRED WITH OS. ONLY VALID WITH *
               DOS'
         MEXIT
.COP     ANOP
         BGENMAC SYS=DOS
         TITLE 'BASFGEN: MODULE ONLY FOR DOS USERS'
BGENDTF  CSECT
         SPACE 3
*   THIS PROGRAM IS ONLY NEEDED IN DOS. IT GETS A DTF ENTRY BY
*   REGISTER LIMIT. IT TAKES BLOCKSIZE AND LRECL FROM THE DTF ENTRY
*   AND PROVIDES THE DIFFERENT DTF TABLES WITH THIS INFORMATION.
*   IT ALLOCATES IOAREAS AND STORES THEIR ADDRESSES INTO THE SPECIFIC
*   DTF...
*
*   AUTHOR: R. RUESSEL
         SPACE 5
DTF      EQU   PNT           CURRENT DTF IN TAB
BLK      EQU   SW            BLOCKSIZE SPECIFIED BY USER
REC      EQU   MSG           RECORD LENGTH SPECIFIED BY USER
IOA      EQU   FUNC          ADDRESS OF IOAREA AFTER GETMAIN
TCP      EQU   LEN           BASE REGISTER FOR RECKONING TRK CAPACITY
         SPACE 2
*        EXTXS BAS,SVA,BGENDTF,TYP=F
         EXTXS BAS,SVA,BGENDTF,TYP=F
         USING MAINPARM,PRM  POINTS TO VECTOR
         USING DTFTAB,LIMIT  POINTS TO ONE ENTRY
         L     DTF,DTFAD     GET ADDR OF DTF TO BE ALTERED
         LH    BLK,BLKL      GET BLOCKSIZE
         LH    REC,RECL      GET LOGICAL RECORD LENGTH
         SPACE 2
*   FOR UNIT RECORD :   IOAREA = OUTREC
         CLI   ID,C'2'       SEP DTF ?
         BL    GETM          IF NOT: DO GETMAIN
         CLI   DEVTYPE,C'P'  IS TAPE OR DISK ?
         BH    GETM          FOR TAPE + DISK A WORKAREA IS NEEDED
         L     IOA,OUTREC    FOR PRINTER + CARD GET SYSUT2 BUFFER ADDR
*              AS IOAREA
         B     TSTCD
*   GETMAIN:
*   1 IOAREA PER DTF, LENGTH: BLKL (FROM DTF-ENTRY)
*   1 WORK AREA FOR OUTPUT, LENGTH: RECL OF SYSUT2
*
GETM     EQU   *
         LR    WK1,BLK       GET BLOCKLENGTH FOR GETMAIN
         CLC   INOUT(2),=C'OS' DISK OUTPUT ?
         BNE   NOT8          SKIP ADDING 8
         LA    WK1,8(,WK1)   IOAREA LENGTH = BLKSIZE + 8
NOT8     EQU   *
         CLI   RECFM,C'V'    IS VARIABLE ?
         BNE   LENOK         SKIP ADDING 4, IF NOT
         LA    WK1,4(WK1)    ADD 4 FOR DESCRIPTOR STUFF
LENOK    EQU   *
*        EXTGM R,LV=(WK1),MOD=VGM           GET SPACE FOR ONE IOAREA
         EXTGM R,LV=(WK1),MOD=VGM
         LR    IOA,R1        SAVE ADDRESS OF IOAREA
         CLI   ID,C'0'       IS SYSUT1 ?
         BE    NOTUT2        SKIP SYSUT2 CHECKING
NOTUT1   EQU   *
         CLI   ID,C'1'       IS SYSUT2 ?
         BNE   NOTUT2        SKIP SAVING ADDR OF SYSUT2 BUFFER
         CLI   DEVTYPE,C'S'  IS CARD OR PRINTER OUTPUT ?
         BL    SVOUTRC       IF YES: NO SPECIAL WORK AREA
         LR    R0,REC        GET LENGTH FOR WORK AREA
*        EXTGM R,LV=(0),MOD=VGM GET MAIN STORAGE
         EXTGM R,LV=(0),MOD=VGM GET MAIN STORAGE
SVOUTRC  EQU   *             SAVE POINTER OF OUTPUT WORK AREA
         ST    R1,OUTREC     SAVE ITS ADDR
         AR    R1,REC        ADD ITS LENGTH
         ST    R1,OUTRECLM   SAVE UPPER LIMIT ADDR
NOTUT2   EQU   *
         CLI   DEVTYPE,C'T'  IS TAPE ?
         BNE   TSTSQ         TEST IF DSK ?
         MVN   7(1,DTF),ID   MOVE RIGHT HALF OF ID TO LOG UNIT NUMBER
         MVC   22(5,DTF),=C'SYS00' PROVIDE FILE NAME
         MVC   27(1,DTF),ID  GET IT UNIQUE
         IC    R0,56(DTF)    SAVE COMMAND CODE
         ST    IOA,56(DTF)   BUILD CHANGED CCW
         STC   R0,56(DTF)    STORE COMMAND CODE BACK
         STH   BLK,62(DTF)   BLOCKLENGTH INTO CCW
         ST    IOA,64(DTF)   STORE IOAREA ADDR INTO DTF
         TM    DTFFLAG,BLOCKED WAS FILE BLOCKED ?
         BZ    *+8           IF NOT: SKIP INDICATION
         OI    21(DTF),X'40' SET BLOCKED BIT
         TM    DTFFLAG,DTFSL WAS STANDARD LABEL ?
         BO    LABELOK       IF YES: SKIP (SL IS DEFAULT)
         MVI   20(DTF),X'11' CHANGE DTF TYPE TO "NO LABEL"
         NI    31(DTF),255-X'04' TURN OFF SL INDICATOR
         NI    32(DTF),255-X'80' TURN OFF SL INDICATOR
         OI    32(DTF),X'02' FORCE TAPEMARK=NO
LABELOK  EQU   *
         CLI   INOUT,C'I'    IS INPUT ?
         BNE   OT            IF NOT: GO  TO OUTPUT + TAPE
         CLI   RECFM,C'F'    RECFM = FIX ?
         BNE   ITV           IF NOT: GO TO VARIABLE TAPE
         SPACE 2
* I-T-F
         L     WK1,ERROPT    GET ERROPT ADDR
         ST    WK1,92(DTF)   INTO DTF
         ST    WK1,88(DTF)   PROVIDE ERROPT ADDR AS WLR- ROUTINE
BOTHIO   EQU   *
         ST    REC,72(DTF)   FORWARD DEBLOCKER 2
         STH   BLK,80(DTF)   BLOCKLENGTH
         LR    WK1,BLK
         BCTR  WK1,0         BLOCKLENGTH - 1
         STH   WK1,82(DTF)   FORWARD
         LR    WK1,REC
         BCTR  WK1,0         RECSIZE - 1
         STH   WK1,84(DTF)   FOLLOWING: DC H'0'
         B     DTFOK         ALL FOR TAPE
         SPACE 2
* I-T-V  +  O-T-V
ITV      L     WK1,ERROPT    GET ERROR ROUTINE ADDR
         ST    WK1,100(DTF)  SAVE IT AS WLR- ADDR
TV       EQU   *             VARIABLE TAPE
         ST    BLK,68(DTF)   DEBLOCKER 2
         ST    IOA,72(DTF)   1 IOAREA DEBLOCKER 3
         LA    WK1,4(IOA)    IOAREA + 4
         ST    WK1,84(DTF)   1 IOAREA DEBLOCKER 1
         STH   BLK,92(DTF)   Y(BLOCKSIZE)
         LR    WK1,BLK       BLOCKSIZE
         BCTR  WK1,0         - 1
         STH   WK1,94(DTF)   Y(BLOCKSIZE-1)
         LR    WK1,REC
         BCTR  WK1,0         RECSIZE-1
         STH   WK1,96(DTF)
         L     WK1,ERROPT
         ST    WK1,104(DTF)  ERROPT ADDR INTO DTF
         CLI   INOUT,C'I'    WAS INPUT ?
         BE    DTFOK
* O-T-V ONLY
         LR    WK1,BLK       BRANCHED FROM V
         SH    WK1,=H'4'     BLOCKSIZE-4
         STH   WK1,92(DTF)   OVERWRITE INPUT ENTRY
         B     DTFOK
         SPACE 2
OT       EQU   *
         CLI   RECFM,C'F'    FIX ?
         BNE   TV            O-T-V NEARLY THE SAME
         SPACE 1
* O-T-F
         ST    IOA,68(DTF)   1 IOAREA, OUTPUT DEBLOCKER 1
         LR    WK1,IOA       IOAREA
         AR    WK1,BLK       + BLOCKSIZE
         BCTR  WK1,0         - 1
         ST    WK1,76(DTF)   OUTPUT, 1 IOAREA DEBLOCKER 3
         B     BOTHIO        DO REST
         SPACE 2
TSTSQ    EQU   *
          CLI   DEVTYPE,C'S' IS DISK ?
         BNE   TSTCD
         MVN   7(1,DTF),ID   MOVE RIGHT HALF OF ID TO LOG UNIT NUMBER
         MVC   22(5,DTF),=C'SYS00' PROVIDE FILE NAME
         MVC   27(1,DTF),ID  GET IT UNIQUE
         TM    DTFFLAG,BLOCKED WAS FILE BLOCKED ?
         BZ    *+8           IF NOT: SKIP INDICATION
         OI    21(DTF),X'40' SET BLOCKED BIT
         CLI   RECFM,C'V'    IF NOT FIX: FF IS ASSUMED AS CAPACITY
         BE   NORECSOK
         TM    DTFFLAG,D2314 IS 2314 ?
         BZ    TST3330
         LA    TCP,CAP2314   GET BASE FOR 2314
         B     RECKCAP
TST3330  TM    DTFFLAG,D3330 IS 3330 ?
         BO    IS3330
         LA    TCP,CAP2311   SET BASE REG
         MVI   29(DTF),0     INDICATE 2311
         B     RECKCAP       RECKON CAPACITY
IS3330   LA    TCP,CAP3330
         MVI   29(DTF),4     INDICATE 3330
RECKCAP  EQU   *
         USING NUMBERS,TCP
         SR    WK1,WK1       WK1=0
         LR    WK2,BLK       GET BLOCKSIZE
         MH    WK2,CON1      BLOCKSIZE*CON1
         D     WK1,CON2      BLOCKSIZE*CON1/CON2
         AH    WK2,CON3      BLOCKSIZE*CON1/CON2+CON3
         ST    WK2,SAVEW
         LH   WK2,CON4       MAX PER TRACK
         SR    WK1,WK1
         D     WK1,SAVEW     MAX CAPACITY/1 BLOCK+GAP
         TM    29(DTF),4      IS 3330 ?
         BO    NOADD         DON'T ADD EVEN IF REST IS > BLKSIZE
         CR    WK1,BLK       IS REST OF DIVISION  > BLKSIZE ?
         BNH   NOADD         NO, TRACK CAPACITY IS ALREADY CORRECT
         LA    WK2,1(WK2)    ADD ONE FOR LAST RECORD ON TRACK
NOADD    EQU   *
         CLI   INOUT,C'I'    IF INPUT, DON'T REDUCE
         BE    SVRECNO       SKIP SUBTRACTING 1
         BCTR  WK2,0         OUTPUT: REC/TRK-1 (MAYBE EOF)
SVRECNO  STC   WK2,72(DTF)   STORE NUMBER OF RECORDS PER TRACK
NORECSOK EQU   *
         SPACE 1
         ST    IOA,44(DTF)   SAVE IOAREA ADDR IN DTFSD
         SPACE 1
*        ERROPT ADDRESS
         L     WK1,ERROPT    GET ERROR ADDR
         IC    R0,100(DTF)   SAVE LOGICAL INDICATORS
         ST    WK1,100(DTF)  STORE ERROR ROUTINE ADDR
         STC   R0,100(DTF)   GIVE INDICATORS BACK
         SPACE 1
*        BLOCKLENGTH IN CCW
         LR    WK1,BLK       BLKSIZE
         CLI   INOUT,C'I'    IS INPUT ?
         BE    CCWOK         SKIP ADDING 8
         LA    WK1,8(,WK1)   + 8
CCWOK    EQU   *
         STH   WK1,134(DTF)  STORE BLOCKLENGTH INTO CCW AS DATA LENGTH
         SPACE 1
*        IOAREA ADDR IN CCW
         IC    R0,128(DTF)   SAVE COMMAND CODE
         ST    IOA,128(DTF)  CHANGE CCW
         STC   R0,128(DTF)   STORE BACK COMMAND CODE
         SPACE 1
*        SIZE OF BLOCK - 1
         LR    WK1,BLK       LOAD BLOCKLENGTH
         BCTR  WK1,0         - 1
         STH   WK1,74(DTF)   SAVE SIZE OF BLOCK - 1
         SPACE 1
*        DEBLOCKER LIMIT
         CLI   INOUT,C'I'    IS INPUT ?
         BE    SIZEOK
         LA    WK1,8(,WK1)   + 8
SIZEOK   EQU   *
         AR    WK1,IOA       + IOAREA START ADDR
         ST    WK1,96(DTF)   SAVE DEBLOCKER LIMIT
         SPACE 1
*        DEBLOCKER INITIAL POINTER
         LR    WK1,IOA       IOAREA ADDR
         CLI   INOUT,C'O'    IS OUTPUT ?
         BNE   ISV           DON'T ADD
         LA    WK1,8(,WK1)   + 8
ISV      CLI   RECFM,C'V'    IS VARIABLE ?
         BNE   DEBOK         DON' T ADD 4
         LA    WK1,4(,WK1)   + 4
*        IOAREA + 0(ISF), 4(ISV), 8(OSF), 12(OSV)
DEBOK    ST    WK1,88(DTF)   STORE DEBLOCKER INITIAL POINTER
         SPACE 1
*        DEBLOCKER RECORD SIZE
         LR     WK1,REC      RECORD LENGTH
         CLI   INOUT,C'I'    INPUT ?
         BE    RCOK          SKIP OUTPUT STUFF
*        DATA LENGTH IF OUTPUT
         STH   BLK,66(DTF)   SAVE ADTA LENGTH
*        TRACK CAPACITY IF OUTPUT
         TM    DTFFLAG,D2314 2314 WANTED ?
         BO    RCOK          ALL OK, 2314: DEFAULT
         TM    DTFFLAG,D2311 IS 2311 ?
         BO    STC2311
         MVC   82(2,DTF),TRCAP3 MOVE CAPACITY OF 3330
         B     RCOK
STC2311  MVC   82(2,DTF),TRCAP1 MOVE CAPACITY OF 2311
RCOK     ST    WK1,92(DTF)   SAVE DEBLOCKER RECORD SIZE
         B     DTFOK
         SPACE 2
TSTCD    EQU   *
         CLI   DEVTYPE,C'C'  CARD ?
         BNE   TSTPR
         CLI   INOUT,C'O'    PUNCH ?
         BE    PUNCH
         IC    R0,32(DTF)    GET CCW COMMAND CODE
         ST    IOA,32(DTF)   PROVIDE IOAREA DRRESS
         STC   R0,32(DTF)    GIVE BACK COMMAND CODE
         B     DTFOK
PUNCH    EQU   *
         ST    IOA,24(DTF)   ADDR OF DATA IN IOAREA 1
         IC    R0,40(DTF)    GET CC
         ST    IOA,40(DTF)   STORE IOAREA ADDR
         STC   R0,40(DTF)    GIVE CC BACK
         B     SEESYS        OUTPUT, SEE IF A PROGRAMMER UNIT IS WANTED
         SPACE 2
TSTPR    EQU   *
         LR    WK1,IOA       PICKUP IOAREA ADDR INRO WK1
         TM    DTFFLAG,ASAPR WAS ASA=YES ?
         BZ    IOAROK        IF NOT: SKIP ADDING 1 FOR ASA- CODE
         LA    WK1,1(WK1)    BLOCKSIZE + 1  (ASA)
IOAROK   EQU   *
         ST    WK1,24(DTF)   ADDR OF DATA IN IOAREA1
         IC    R0,40(DTF)    SAVE COMMAND CODE
         ST    WK1,40(DTF)   IOA + 1
         STC   R0,40(DTF)    STORE CC
         LR    WK1,BLK       BLOCKLENGTH
         TM    DTFFLAG,ASAPR IF NOT ASA: DON'T REDUCE
         BZ    BLKLOK        BLOCKLENGTH OK
         BCTR  WK1,0         -1
BLKLOK   EQU   *
         STH   WK1,46(DTF)   BLOCKSIZE IN CCW-1  (ASA)
         SPACE 1
SEESYS   EQU   *
         TM    DTFFLAG,NOSYS WAS SYS=NO ?
         BZ    DTFOK         IF NOT: DON'T CHANGE CCB
         MVI   6(DTF),1      SHOW PROGRAMMER UNIT
         MVN   7(1,DTF),ID   INDICATE WHICH ONE
         SPACE 5
DTFOK    EQU  *              DTF HAS BEEN SUPPLIED WITH INFORMATION
*        EXTXR
         EXTXR
         LTORG
         SPACE 5
SAVEW    DS    F
ERROPT   DC    V(BGENERR)
TRCAP1   DC    H'3625'       TRACK CAPACITY OF A 2311
TRCAP3   DC    H'13030'      TRACK CAPACITY OF A 3330
         CNOP  2,4
CAP2311  DC    H'537' .      DATES FROM MACRO: DTFSD
         DC    F'512' .      2311 :
         DC    H'61' .       X=BLOCKSIZE*537/512+61  (1 BLOCK + GAP)
         DC    H'3625' .     Y=3625/X  (CAPACITY/(BLOCK+GAP))
         CNOP  2,4
CAP2314  DC    H'534'
         DC    F'512'
         DC    H'101'
         DC    H'7294'
         CNOP  2,4
CAP3330  DC    H'1' .
         DC    F'1' .        3330 :
         DC    H'135' .      X=BLOCKSIZE*1/1+135
         DC    H'13165' .    Y=13165/X
NUMBER   DSECT
         CNOP  2,4
NUMBERS  EQU   *
CON1     DS    H FORMULA :
CON2     DS    F X=BLOCKSIZE*CON1/CON2+CON3
CON3     DS    H Y=CON4/X
CON4     DS    H
         MEND
./ ADD  NAME=BGENMAC
         MACRO
         BGENMAC  &SYS=OS,&DCB=YES
         AIF   ('&SYS' EQ 'OS').COP
         AIF   ('&SYS' EQ 'DOS').COP
         MNOTE 12,'SYSTEM &SYS NOT SUPPORTED, SPECIFY DOS OR OS'
         MEXIT
.COP     ANOP
         TITLE '   DEFINITIONS, COMMON TO ALL BASFGEN ROUTINES'
*
*              EQUIVALENCES FOR REGISTERS AND IMMEDIATE OPERATORS
*
         SPACE 3
*
*        REGISTER USE
*
R0       EQU   0
R1       EQU   1
LIMIT    EQU   2             UPPER LIMIT FOR SCAN
*        REGISTER 2 IS USED AS IOREG (DOS) IN GENGET AS SPECIFIED
*        IN THE INPUT TAPE AND DISK DTFS
PNT      EQU   3             POINTER ON INPUT-CARD
LEN      EQU   4             EXECUTION-REGISTER
FUNC     EQU   5             POINTER IN FUNCTION TABLE
SW       EQU   6             POINTS TO COMMUNICATION SWITCHES
MSG      EQU   7             POINTER TO MESSAGES
WK1      EQU   8             WORK REG
WK2      EQU   9             WORK REG
PRM      EQU   10            BASE FOR COMMUNICATION VECTOR
LNK      EQU   11            LINK REGISTER
BAS      EQU   12            BASE REGISTER FOR ALL BASFGEN ROUTINES
R13      EQU   13            SAVEAREA POINTER
R14      EQU   14
R15      EQU   15
         SPACE 3
*
*        BIT   SWITCHES CONTAINED IN SWFUNC
*
WRNGEOD  EQU   128
NOTFOUND EQU   64
CNTFOUND EQU   32
NOFUNC   EQU   16
FUNCEND  EQU   8
FULL     EQU   4
ERR      EQU   2
WARNING  EQU   1
         SPACE 3
*
*              BIT SWITCHES IN BYTE 'SW2'
*
ISORG    EQU   128
IMSORG   EQU   64
COREFULL EQU   32
PSORG    EQU   16            INDICATES BSAM
SCANIS   EQU   8      SW2
SPECENT  EQU   4             INDICATES A SPECIAL ENTRY WITH NO UPDATING
         SPACE 3
*
*              BIT SWITCHES CONTAINED IN SWINPUT
*
EODADIN  EQU   4
FULLIND  EQU   8
ENDREQ   EQU   16
EOFSYS1  EQU   32
FMTFULL  EQU   64
ACTFULL  EQU   128
         SPACE 3
*
*        BIT SWITCHES CONTAINED IN SWITCH BYTE 'SWTAB'
*
TABNOTAB EQU   128
TABFULL  EQU   64
TABEODAD EQU   32
TABNOTOK EQU   128+64+32
TABINTPT EQU   16            TABLE INTERPRETATION IS REQUESTED
COMPAC   EQU   8             COMPARISON OF LITERAL-ACCUS IS REQUESTED
COMPAC2  EQU   4             COMPARISON OF LITERAL-ACCUS IS REQUESTED
PRINTNOT EQU   2             TABLE IS NOT TO BE PRINTED AFTER SORT
PRINTREF EQU   1             TABLE IS TO BE PRINTED AT END OF RUN
*                            WITH A REFERENCE MARK
         SPACE 3
*
*              BIT SWITCHES CONTAINED IN SWITCH BYTE 'SWOPEN'
*
PRTOPEN  EQU   128
INOPEN   EQU   64
UT2OPEN  EQU   32
INPOPEN  EQU   16
ALLOPEN  EQU   128+64+32+16
FLTS     EQU   8 .           BLOCKS IN ERROR ARE NOT TO BE SKIPPED
DCK      EQU   4 .           BLOCKS IN ERROR ARE TO BE SKIPPED
SECDIGAC EQU 2 .             SECOND DIGIT IS ACCU-#, CHECK IT
*
         SPACE 3
*
*              BIT SWITCHES CONTAINED IN SWITCH BYTE 'SWIPRT1'
*
*
NOFORMAT EQU   128
STARWAS  EQU   64
FMTEND   EQU   32
KONSTCMP EQU   16            INDICATES ACCU COMPARE WITH CONSTANT
NUMPACK  EQU   8             NUMERIC TEST FOR PACKED DECIMAL
NUMLIT   EQU   4             NUMERIC TEST UNPACKED DECIMAL
*  ERR   EQU   2             ALSO USED HERE
*
*              SWITCHES CONTAINED IN SWITCH-BYTE 'SWIPRT2'
*
HEX      EQU   64
NOMOVE   EQU   32
NOSPLIT  EQU   16
ODERWAS  EQU   8             INDICATES THE PRECENCE OF 'ODER' OR 'OR'
ONLYDIG  EQU   4
PDKONST  EQU   2
SAVING   EQU   1
         SPACE 3
*
*              SWITCHES CONTAINED IN SWITCH-BYTE 'SW3'
*
SUBTRACT EQU   1             INDICATES WHETHER A SUBTRACTION IS REQUIR.
MASKWAS  EQU   2             INDICATES A 'MOVEM' WAS PRECEDING AN EDIT
ISPUT    EQU   4
DONTPUT  EQU   8
LINCNTIS EQU   16
DOISACT  EQU   32            'DO' IS ACTIVE
         SPACE 3
*
*              BIT-SWITCHES CONTAINED IN SWITCH-BYTE 'SW4'
*
LASTWAS  EQU   1             INDICATES THE A 'LAST' FORMAT WAS
FIRSTWAS EQU   2             INDICATES THE A 'FIRST' FORMAT WAS
COUNTWAS EQU   4             INDICATES THE A 'COUNT' FORMAT WAS
FIRSTLIN EQU   8             INDICATES THE A 'FIRST' ENTRY IS IN USE
LASTIS   EQU   16            INDICATES THE A 'LAST' ENTRY IS IN USE
LASTREC  EQU   32
IRECFMV  EQU   64            INPUT RECFM = V
ORECFMV  EQU   128           OUTPUT RECFM= V
         SPACE 3
*              FUNCTION IDENTIFIERS
*
WTM      EQU   C'W'
FAULT    EQU   C'F'
DCKS     EQU   C'D' .        DATA-CHECKS ARE EXPECTED, BLOCKS IN
*                            ERROR ARE TO BE DUMPED,
*                            BUT NOT TO BE GIVEN TO FORMAT-DRIVER
UNLOAD   EQU   C'U'
REWIND   EQU   C'R'
BACKSP   EQU   C'B'
SKIP     EQU   C'S'
COPY     EQU   C'C'
TABLE    EQU   C'T'
ENDFUNC  EQU   C'E'
         SPACE 3
*
*              BYTE EQUIVALENCES
*
TAPE     EQU   X'81'         DCBDEVT, IF UNIT=TAPE WAS SPECIFIED
BLANK    EQU   C' '
POINTER  EQU   X'4F'
DOLLAR   EQU   C'$'
STERN    EQU   C'*'
KOMMA    EQU   C','
LKLAM    EQU   C'('          LEFT PARATHESES
NULL     EQU   C'0'
EINS     EQU   C'1'
NEUN     EQU   C'9'
         SPACE 3
*
*              IMMEDIATE OPERATORS USED FOR DECISION MAKING
*
ODERENDE EQU   X'20'         INDICATES THE END OF A CHAIN OF OR'S
ORENTRY  EQU   X'40'
EQUAL    EQU   X'70'         BRANCH MASK IF 'EQUAL' IS REQUIRED
HIGH     EQU   X'D0'         BRANCH MASK IF 'HIGH'  IS REQUIRED
LOW      EQU   X'B0'         BRANCH MASK IF 'LOW'   IS REQUIRED
UNEQUAL  EQU   X'80'         BRANCH MASK IF 'UNEQUAL' IS REQUIRED
HIGHEQ   EQU   X'40'         BRANCH MASK IF 'GREATER THAN' IS REQUIRED
LOWEQ    EQU   X'20'         BRANCH MASK IF 'LESS THAN' IS REQUIRED
*
ENDINDIC EQU   128
TABENTLN EQU   10*8
CARDLEN  EQU   72
QUEUED   EQU   X'40'         DCB-INDICATION-BIT FOR QSAM ACCESS
ASTCARD  EQU   C'A'          INDICATOR FOR A AST-CARD
         TITLE ' DUMMY SECTIONS, USED BY BASFGEN ROUTINES'
         AIF   ('&SYS' EQ 'DOS').DEFLINE
         AIF   ('&DCB' EQ 'NO').DEFLINE
         DCBD  DSORG=(PS,IS),DEVD=(PR,TA,DA,PC,RD)
.DEFLINE ANOP
         SPACE 3
*
*              PRINTLINE DESCRIPTION
*
AZEILE   DSECT               DESIGN OF THE OUTPUT-LINE
ASA      DS    CL1
AFLAG    DS    CL12          FLAGS
         DS    CL2
ACARDOUT DS    CL80          CARD IMAGE ON OUTPUT-LINE
         DS    CL2
AERRMSG  DS    0CL20          MESSAGES
AADVERB  DS    CL7           ADVERB OF MESSAGE
         DS    CL1
ASUBJECT DS    CL9           SUBJECT OF MESSAGE
         DS    CL3
         DS    CL1
AMSGSUB  DS    CL6           SUBJECTIVE OF SHORTENED MESSAGE
         DS    CL1
AACTION  DS    CL8           ACTION TAKEN WITH SUBJECTIVE
ALINELEN EQU   *-AFLAG       LENGTH OF THE LINE FOR BLANKING
*
         SPACE 3
*
*              DESCRIPTION OF A FUNCTION ENTRY
*
FUNCTION DSECT
FCOUNT   DS    PL8
FIDENT   DS    CL1
FCLEN    EQU   *-FUNCTION
         SPACE 3
FMTDSECT DSECT               FORMAT-FIELD DESCRIPTION
FMTINCR  DS    H             INCREMENT  (LENGTH OF THIS FIELD (+1))
FMTCODE  DS    H             FORMAT-CODE
FMTCNT   DS    H             FORMAT-COUNT (REPETITION-FAKTOR OR LENGTH)
FMTLITLN DS    H             LENGTH OF THE FOLLOWING LITERAL
FMTLIT   EQU   *             LITERAL FOLLOWS
         ORG   FMTLITLN
FMTKONST DS    PL8           DECIMAL CONSTANT (FOR ADD, COUNT, ETC.)
         ORG   FMTLITLN
FMTAKU#  DS    H             AKU-NUMBER SECOND AKU
         SPACE 3
*
*              DESCRIPTION OF THE COMMUNICATION VECTOR
*
MAINPARM DSECT
AGETROUT DS    0A            ADDRESS OF THE GET ROUTINE
APARM    DS    A             A(PARMS ON EXEC CARD)
AKARTE   DS    A             A(PARAMETER-DCB)
ALISTE   DS    A             A(PROTOKOLL-DCB)
PCBAD    DS    0F            ADDRESS OF THE PCB WHEN 'IMS' WAS
AINPUT   DS    A             A(EINGABE-DCB)
AOUTPUT  DS    A             A(AUSGABE-DCB)
AINBUF   DS    A             A(INPUT DATA-AREA)
INBUFLEN DS    A              LENGTH OF THE INPUT AREA
ASEPDCBS DS    A             A(LISTE WEITERER AUSGABE DCB'S)
AFUNC    DS    A             A(FUNKTIONS-TABELLE)
AFORMAT  DS    A             A(FORMAT-ENTRY-TABELLE)
AACTIONS DS    A             A(ACTIONS)
ATABENTR DS    A             A(TABELLEN-ENTRIES)
OUTREC   DS    A             OUTPUT RECORD START ADDRESS
ALIST    DS    A             A(AUSGABEBEREICH)
ACARD    DS    A             A(EINGABEBEREICH)
LFUNC    DS    A             A(OBERGRENZE DER FUNKTIONS-TABELLE)
LFORMAT  DS    A             A(OBERGRENZE DER FORMATTABELLE)
LACTIONS DS    A             A(OBERGRENZE DER AKTIONSTABELLE)
INRECANF DS    F             BEGINN DES EINGABE RECORDS
INRECEND DS    F             ENDE DES EINGABE RECORDS
SYSINCDS DS    F             COUNT FOR CARDS FROM SYSIN
INPRECS  DS    F             COUNT FOR INPUT RECORDS FROM SYSUT1
OUTCNT   DS    F             COUNT FOR OUTPUT RECORDS TO SYSUT2
AACCU    DS    F             ADDRESS OF THE ACCUMULATORS
SAVFLDS  DS    F             BEGIN OF SAVE-BER CHAIN
ASCAN    DS    F             ADDRESS OF THE SCAN ROUTINE-CSECT
LASTLINE DS    F             ADDRESS OF FORMAT ASSOCIATED TO 'LAST'
NEWPAGE  DS    F             ADDRESS OF THE FORMAT ASSOCIATED TO 'COUNT
LINECOMP DS    F             WORD WITH MAXIMUM LINE COUNT IF 'COUNT'
LINECNT  DS    F             WORD FOR LINE COUNT PER PAGE
ERRCNT   DS    F             COUNT FOR I/O-ERRORS FROM SYSUT1
ERRCOMP  DS    F             SPECIFIED MAXIMIM COUNT FOR THESE I/O ERR
AGENDUMP DS    F             ADDRESS OF DUMP MODUL FOR RECS OR BLOCKS
INPBLKS  DS    F             NUMBER OF INPUT BLOCKS FROM SYSUT1
IMSEODAD DS    F             EODAD ADDRESS WHEN 'IMS' WAS
PRTCNT   DS    F             RECORD COUNT FOR SYSPRINT DATA-SET
PAGECNT  DS    F             PAGE COUNT FOR SYSPRINT
PCBADR   DS    F             ADDRESS OF PCB-NAME IF SPECIFIED
AHEADPRT DS    F             ADDRESS OF HEADER PRINT ROUTINE
MAXLINES DS    F
NORMEOB  DS    F             CONTAINS ADDRESS OF EOB-ROUTINE
ALFDNR   DS    F             ADDRESS OF 'LFDNR' - SUBROUTINE
ALFDNRD  DS    F             ADDRESS OF 'LFDNRDEF' - SUBROUTINE
ACONVXE  DS    F             ADDRESS OF 'CONVXE' - SUBROUTINE
ASTRTKEY DS    F             ADDRESS OF KEY TO START WITH (IMS OR IS)
ADRUPS   DS    F             ADRESS OF UP-START-VECTOR ( DO '
OUTRECLM DS    F             UPPER LIMIT OF OUTPUT RECORD
ASTCHN   DS    F .            START OF AST CHAIN FOR SEP DCBS
HEADSAV  DS    F .             RETURN ADDRESS FROM GENHEAD
ATIME    DS    CL8
ADATE    DS    CL10
ANZUPS   DS    H             MAXIMUM NUMBER OF UP'S (DOLLAR-FORMATS)
ACCUNUM  DS    H             NUMBER OF ACCUMULATORS NORMALLY 10
INLRECL  DS    H             INPUT LRECL
FNCPOWER DC    H'0'
FMTPOWER DC    H'0'
ENTPOWER DC    H'0'
*
*              SWITCH BYTES
*
SWFUNC   DS    CL1
SWINPUT  DS    CL1
SW2      DS    CL1
SW3      DS    CL1
SWOPEN   DS    CL1
SWTAB    DS    CL1
SWIPRT1  DS    CL1                     SWITCHES FOR THE
SWIPRT2  DS    CL1                     INTERPRETATION ROUTINE
SW4      DS    CL1
         DS    0D             ALIGN TO DOUBLE WORD
DMACCU   DS    PL16 .         ACCU FOR DIVISION AND MULTIPLICATION
         AIF   ('&SYS' EQ 'OS').PEND
         SPACE 2
*   REST ONLY NEEDED IN  DOS
*
VGM      DS    F             RELOCATED ADDR OF GETMAIN ROUTINE
VFM      EQU   VGM           OS LIKE FREEMAIN FUNCTION
         SPACE 3
INPDEV   DS    CL1           FIELD FOR SAVING DEVICE TYPE OF INPUT
DTFSL    EQU   X'80'   1 IN DTFFLAG IF SL, 0 IF NL (LABEL CHECKING)
D2311    EQU   X'40'         SET IN DTFFLAG IF DEVICE IS 2311
D2314    EQU   X'20'         SET IN DTFFLAG IF DEVICE IS 2314
D3330    EQU   X'10'         SET IN DTFFLAG IF DEVICE IS 3330
ASAPR    EQU   X'08' SET IN DTFFLAG IF PRINTER AND ASA=YES
BLOCKED  EQU   X'04' SET IN DTFFLAG IF FB OR VB SPECIFIED
NOSYS    EQU   X'02'         SET IN DTFFLAG IF SYS=NO SPECIFIED
         DS    0F
DTFTAB   DS    0F            DESCRIBE ONE ENTRY
NXT      DS    F              POINTER TO NEXT ENTRY
ID       DS    0CL1           DTF ID  I.E. 3 FOR SYS003 OR 5 FOR SYS005
DTFAD    DS    F              ADDRESS OF THIS DTF
PUTCOUNT DS    F              NO OF PUTS ARE COUNTED IN HERE
AASTCODE DS    F             A(AST-CODE)
BLKL     DS    H              WANTED BLOCKLENGTH
RECL     DS    H              WANTED RECORD LENGTH
DTFTYPE  DS    0F             DESCRIBE DTF TO BE LOADED
INOUT    DS    CL1            I=INPUT, O=OUTPUT
DEVTYPE  DS    CL1            T=TAPE, S=SEQDISK, C=CARD, P=PRINTER
RECFM    DS    CL1            F=FIX, V=VARIABLE, SAME AS FB OR VB
DTFFLAG  DS    CL1     FLAG BITS
ENTRYEND EQU   *
ENTRYNO  EQU   7
ENTRYLL  EQU   ENTRYEND-DTFTAB  LENGTH OF ONE ENTRY
DCBID    EQU   ID            EQUATE WITH OS ENTRY NAMES
DCBADR   EQU   DTFAD         A(DTF)
LINKFLD  EQU   NXT           POINTER TO NEXT ENTRY
SEPENTRY EQU   DTFTAB        FOR USING
         ORG   DTFTAB+ENTRYNO*ENTRYLL   SET BEHIND WHOLE TABLE
.PEND    ANOP
PARMEND  DS    0D
         MEND
./ ADD  NAME=DCONVEX
         MACRO
         DCONVEX &SYS=
         AIF   ('&SYS' EQ 'DOS').OK
         MNOTE *,'THIS CSECT IS ONLY REQUIRED FOR SYS=DOS'
         MEXIT
.OK      ANOP
CONVEX   CSECT
         XSAVE 12,SVA,CONVEX
         LR    4,0
         LA    11,256
         CR    4,11
         BNL   LENGFAIL
         LR    10,0
         LA    9,0(1,10)
         LR    2,1
TEST     TM    0(2),C'0'
         BO    TESTON
         TM    0(2),X'C0'
         BNO   WRONG
         CLI   0(2),X'C6'
         BH    WRONG
TESTON   LA    2,1(2)
         CR    2,9
         BL    TEST
         BCTR  10,0
         EX    10,TR
         LA    10,1(10)
         SR    11,11
         LA    7,14
         LA    6,7
         IC    11,=X'EE'
         LR    8,9
         LR    5,6
         BCTR  5,0
COMP     CR    10,7
         BL    LAST
         SR    9,7
EXPACK   EX    11,PACK
         SR    8,6
MOVE     EX    5,MOVEINST
         SR    10,7
         BP    COMP
         LA    15,0
         LA    11,0(1,4)
         SR    11,8
         BCTR  11,0
         EX    11,LASTMOVE
         B     XRET
LASTMOVE MVC   0(0,1),0(8)
TR       TR    0(0,1),TRANSTAB
MOVEINST MVC   0(0,8),7(9)
PACK     PACK  0(0,9),0(0,9)
LAST     STC   10,ZWI
         STC   10,ZWI+1
         PACK  ZWI,ZWI
         IC    11,ZWI+1
         SR    9,10
         LA    6,1(10)
         SRL   6,1
         BCTR  6,0
         LR    5,6
         LA    6,1(6)
         EX    11,PACK
         SR    8,6
         AR    9,10
         SR    9,7
         LA    9,7(9)
         SR    9,6
         B     MOVE
LENGFAIL LNR   15,1
         B     XRET
WRONG    LR    15,2
XRET     XRETURN (15)
TRANSTAB DC    0F'0'
         DC    192X'0'
         DC    X'00CACBCCCDCECF000000000000000000'
         DC    32X'0'
         DC    C'0123456789'
         DC    XL6'0'
ZWI      DS    CL3
         MEND
./ ADD  NAME=DGETMAIN
         MACRO
         DGETMAIN &SYS
         AIF   ('&SYS' EQ 'DOS').OK
         MNOTE *,'****  ASSEMBLY OF THIS MODUL ONLY FOR DOS'
         MEND
.OK      ANOP
GETMAIN  CSECT
         ENTRY FREEMAIN
FREEMAIN EQU *
         SPACE 10
* REGISTER USE:
         SPACE 2
A        EQU   2         ADDRESS OF AREA TO BE FREED
B        EQU   5         BEGINNING OF AREA TO BE USED BY GETSTORE
E        EQU   3         END OF AREA THAT MAY BE USED BY FREESTORE
O        EQU   5         FQE BEFORE MINIMUM (B NO LONGER NECESSARY)
C        EQU   4         CURRENT FQE
M        EQU   6
N        EQU   7         NEXT FQE
P        EQU   8         PREVIOUS FQE
W1       EQU   9         WORKING REGISTER 1
W2       EQU   11        WORKING REGISTER 2
R0       EQU   0         CONTAINS LENGTH OF AREA TO GET OR TO BE FREED
*   REG 12 USED AS LINK REGISTER   (BAL  12,...)
         EJECT
         B     12(15)        SKIP CONSTANTS
         DC    X'07'         ID- LENGTH
         DC    CL7'GETM0'    ID, AFTER 1ST USE CHANGED TO 'GETM1'
         USING *-12,15
         STM   2,12,INNERSA  REGS 2-12 SAVED, 13-15 UNCHANGED
         B     INNERSA+44    SKIP SAVE AREA
INNERSA  DC    11F'0'        INNER SAVE AREA FOR CALLER'S REGS
         SPACE 2
         LR    A,1            GET ADDRESS OF AREA TO BE FREED.
*        FIND COMMUNICATION REGION OF THIS PARTITION
         COMRG
         LM    E,B,32(1)      LOAD INFORMATION FROM COMM. REG.
         LA    B,0(B)        SET HIGH ORDER BYTE TO ZERO
         LTR   B,B           SPI ? IF YES, B WAS ZERO
         BNZ   *+6           IF NOT, SKIP GETTING B
         LR    B,C           GET B FROM WORD BEFORE
         LA    E,1(E)
         LA    B,7(B)         GET ADDRESS OF AREA
         N     B,NEG8
         TM    9(15),X'01'    WAS THERE A GETMAIN  BEFORE ?
         BO    FORMSET        IF YES, DON'T BUILD FBQE AND 1ST FQE.
EIGHT    LA    W1,8(B)        BUILD FBQE.
         ST    W1,0(B)
         LR    W1,E
         SR    W1,B           FIND LENGTH.
         ST    W1,4(B)        STORE LENGTH INTO FBQE.
         SH    W1,EIGHT+2     SUBTRACT  8.
         ST    W1,12(B)       STORE LENGTH INTO 1ST FQE.
         XC    8(4,B),8(B)    ONLY ONE FQE UNTIL NOW.
         OI    9(15),X'01'   SET X'F0' TO X'F1'
         SPACE 2
FORMSET  EQU   *
         LR    W1,R0         GET REG 0 (DESIRED LENGTH)
         LA    W1,7(W1)
         N     W1,NEG8
         BZ    AB80A
         LR    R0,W1
         SR    P,P            SET PREVIOUS TO ZERO
         LR    C,B
         L     N,0(C)         LOAD POINTER TO NEXT FQE
         BAL   12,SETNEW0
         LR    W1,C
         A     W1,4(C)
         CR    W1,E
         BNE   AB60A
         LTR   A,A            IS IT GETMAIN OR FREEMAIN ?
         BP    FM
         SPACE 1
         SR    O,O
         LR    M,C
         B     CHECK
         SPACE 2
TESTLEN  EQU   *
         C     R0,4(C)        COMPARE LENGTH.
         BH    CHECK
         CLC   4(4,C),4(M)    FIND SMALLEST AREA THAT'S BIG ENOUGH.
         BNL   CHECK
         LR    M,C            FOUND.
         LR    O,P
         SPACE 1
CHECK    EQU   *
         LTR   N,N            LAST FQE ?
         BZ    LSTFND         YES
         BAL   12,SETNEW      CHANGE POINTERS.
         B     TESTLEN
         SPACE 2
LSTFND   EQU   *
         LTR   O,O            O STILL ZERO ?
         BZ    AB80A          NO AREA BIG ENOUGH.
         C     R0,4(M)        LENGTH EQ TO RO
         BE    DLTFQE         FQE IS DELETED
         LNR   R0,R0
         A     R0,4(M)        GET DIFFERENCE
         ST    R0,4(M)        SAVE IT AS LENGTH
         AR    R0,M
         LR    1,R0
         B     RET
DLTFQE   EQU   *
         MVC   0(4,O),0(M)
         LR    1,M
         B     RET
         SPACE 2
SETNEW   EQU   *              SET NEW POINTERS
         LR    P,C            CURRENT BECOMES PREVIOUS
SETNEWF  LR    C,N            NEXT BECOMES CURRENT
         L     N,0(0,C)       NEW NEXT IS FOUND BY LOADING ADDRESS
         TM    4(C),X'FF'
         BNZ   AB60A
         LR    W1,C
         A     W1,4(C)
         LTR   N,N
         BZ    JUMP1
         CR    W1,N
         BNL   AB60A
         B     SETNEW0
JUMP1    CR    W1,E
         BH    AB60A
SETNEW0  EQU   *
         TM    3(C),X'07'
         BNZ   AB60A
         CR    N,E
         BNL   AB60A
         BR    12 GET BACK
         EJECT
FM       EQU   *
         LA    W1,7
         NR    W1,A
         BNZ   AB60A          IF NOT: 60A.
         LR    O,C
         SR    M,M
         SPACE 2
FINDC    CR    A,C
         BNH   TESTN
         LR    O,C
         LR    M,N
TESTN    LTR   N,N            TEST NEXT.
         BZ    FOUND          IF ZERO LAST FQE FOUND.
         BAL   12,SETNEWF     CHANGE POINTERS.
         B     FINDC
         SPACE 2
FOUND    EQU   *
         LR    C,O
         LR    N,M
         LR    P,E
         S     P,4(C)
         L     W1,4(C)        LOAD CURRENT LENGTH
         CR    P,C
         BNE   *+12
         LA    W2,8(C)
         B     *+8
         LA    W2,0(W1,C)
         CR    W2,A
         BH    ABA0A
         BL    BUILDFQE
         SPACE 1
         LTR   N,N
         BZ    BFQEEQ         ALREADY AT END
         SPACE 1
         AR    W2,R0
         C     W2,0(C)        INSIDE VALID AREA ?
         BH    ABA0A          NO
         BL    BFQEEQ         YES, LOW
         LR    W1,R0          LOAD LENGTH
         A     W1,4(N)        ADD NEXT    FQE LENGTH
         CR    P,C
         BNE   JUMP3
         ST    W1,4(A)
         MVC   0(4,A),0(N)
         B     STA
JUMP3    A     W1,4(C)        ADD CURRENT FQE LENGTH
         ST    W1,4(C)        SAVE NEW LENGTH
         MVC   0(4,C),0(N)    CHANGE POINTER
         B     RET
         SPACE 2
BFQEEQ   EQU   *
         BAL   12,TESTR0
         CR    P,C
         BE    STR0NA
         AR    W1,R0          ADD LENGTH
         ST    W1,4(C)        SAVE IT
         B     RET
         SPACE 2
BUILDFQE EQU   *
         LTR   N,N
         BZ    LAST
         SPACE 1
         LR    W1,A
         AR    W1,R0          GET ORIGIN + LENGTH
         C     W1,0(C)        EQ TO NEXT FQE ADDR ?
         BH    ABA0A          GT ==> ERROR
         BL    STR0NA
         LR    W1,R0
         A     W1,4(N)
         ST    W1,4(A)
         L     W1,0(N)
         LTR   W1,W1
         BNZ   STNA
         SR    N,N
         B     STNA
         SPACE 2
LAST     BAL   12,TESTR0
STR0NA   ST    R0,4(A)
STNA     ST    N,0(A)
STA      ST    A,0(C)         SET NEW CURRENT FQE
         B     RET
         SPACE 2
TESTR0   LTR   N,N
         BCR   7,12 BNZ
         SR    E,R0
         CR    E,A
         BL    ABA0A
         BR    12
         SPACE 2
AB60A    LA    0,1546                 TO  60A
         B     DUMP
AB80A    LA    0,2058                 TO  80A
         SLL   A,1
         LTR   A,A
         BZ    RET
         B     DUMP
RET      EQU   *
         LM    2,12,INNERSA  GIVE HIM HIS REGS AGAIN
         BR    14            RETURN
ABA0A    LA    0,2570                 TO  A0A
DUMP     DUMP
NEG8     DC    F'-8'
         SPACE 10
         MEND
./ ADD  NAME=DOSJCL
//Z227HF   JOB (6600,128,1),
//   FRANZ,MSGLEVEL=1,PRTY=11,
// COND=(4,LE),MSGCLASS=A,
//   REGION=500K,CLASS=B,TIME=3
//GENDOS PROC CL=A,
//   SRC='OX.A6600.I128SRC',
//   MAC='SYS1.OCRLIB'
//GENDOS EXEC  PGM=IEUASM,
//   PARM='DECK,NOLOAD',
//   REGION=500K
//SYSLIB DD DSN=&SRC,DISP=SHR
//  DD  DSN=&MAC,DISP=SHR
//SYSUT1 DD UNIT=DISK,SPACE=(CYL,(10,2))
//SYSUT2 DD UNIT=DISK,SPACE=(CYL,(10,2))
//SYSUT3 DD UNIT=DISK,SPACE=(CYL,(10,2))
//SYSGO  DD UNIT=DISK,SPACE=(CYL,(01,2))
//SYSPRINT DD SYSOUT=&CL,
//   DCB=(RECFM=FBM,BLKSIZE=3146),SPACE=(CYL,(15,5))
//SYSPUNCH DD SYSOUT=B,DCB=BLKSIZE=3040
//       PEND
//COPY EXEC PGM=IEBCOPY,REGION=500K
//SYSUDUMP DD SYSOUT=A
//SYSPRINT DD SYSOUT=A
//SYSUT3 DD DSN=A,UNIT=DISK,SPACE=(TRK,90)
//SYSUT4 DD DSN=AZ,UNIT=DISK,SPACE=(TRK,90)
//SRC DD DSN=OX.I128SRC,DISP=SHR
//BIN DD DSN=OX.I128BIN,DISP=SHR
//MOD DD DSN=OX.I128MOD,DISP=SHR
//NSRC DD DSN=OX.A6600.I128SRC,DISP=SHR
//NBIN DD DSN=OX.A6600.I128BIN,DISP=SHR
//NMOD DD DSN=OX.A6600.I128MOD,DISP=SHR
//MAC DD DSN=LU.MACLIB,DISP=SHR
//SYSIN DD *
         COPY  I=MAC,O=NSRC
         SELECT  MEMBER=((SYSDATE,,R))
     COPY  I=NSRC,O=NSRC
   COPY I=NBIN,O=NBIN
   COPY I=NMOD,O=NMOD
//S1 EXEC GENDOS
//GENDOS.SYSIN DD *
         BASFGEN SYS=DOS
         END
//S2  EXEC GENDOS
//GENDOS.SYSIN DD *
         GENAST SYS=DOS
         END
//S3  EXEC GENDOS
//GENDOS.SYSIN DD *
         GENCORE SYS=DOS
         END
//S4  EXEC GENDOS
//GENDOS.SYSIN DD *
GENDCBS  CSECT
          GENDCBS SYS=DOS
         END
//S5  EXEC GENDOS
//GENDOS.SYSIN DD *
         GENDUMP SYS=DOS
         END
//S6  EXEC GENDOS
//GENDOS.SYSIN DD *
         GENFUNC SYS=DOS
         END
//S7  EXEC GENDOS
//GENDOS.SYSIN DD *
         GENGET SYS=DOS
         END
//S8  EXEC GENDOS
//GENDOS.SYSIN DD *
         GENHEAD SYS=DOS
         END
//S9  EXEC GENDOS
//GENDOS.SYSLIB DD DSN=IMS.MACLIB,DISP=SHR
//  DD  DSN=OX.A6600.I128SRC,DISP=SHR
//   DD   DSN=SYS1.MACLIB,DISP=SHR
//GENDOS.SYSIN DD *
         GENIMS
         END
//S10 EXEC GENDOS
//GENDOS.SYSIN DD *
         GENINPUT SYS=DOS
         END
//S11 EXEC GENDOS
//GENDOS.SYSIN DD *
         GENIPRT SYS=DOS
         GENOUT SYS=DOS
         END
//S12 EXEC GENDOS
//GENDOS.SYSIN DD *
         GENOPEN SYS=DOS
         END
//S13 EXEC GENDOS
//GENDOS.SYSIN DD *
         GENPARM SYS=DOS
         END
//S14 EXEC GENDOS
//GENDOS.SYSIN DD *
         GENREAD SYS=DOS
         END
//S15 EXEC GENDOS
//GENDOS.SYSIN DD *
         GENSCAN SYS=DOS
         END
//S16 EXEC GENDOS
//GENDOS.SYSIN DD *
         GENSTAT SYS=DOS
         END
//S17 EXEC GENDOS
//GENDOS.SYSIN DD *
         GENSYNBS SYS=DOS
         END
//S18 EXEC GENDOS
//GENDOS.SYSIN DD *
         GENSYNIS SYS=DOS
         END
//S19 EXEC GENDOS
         GENSYNQS SYS=DOS
         END
//S20 EXEC GENDOS
//GENDOS.SYSIN DD *
         GENTABLE SYS=DOS
         END
//S21 EXEC GENDOS
//GENDOS.SYSIN DD *
         GENT99P SYS=DOS
         END
//S22 EXEC GENDOS
//GENDOS.SYSIN DD *
         GENTNUM SYS=DOS
         END
//S23    EXEC  GENDOS
//GENDOS.SYSIN DD *
GENSAVE  CSECT
         GENSAVE SYS=DOS
         END
//
//
./ ADD  NAME=EXTFM
         MACRO
&NAME    EXTFM &R,&LV=,&A=,&MOD=
         LCLC  &ADDR,&AMOD
         LCLC  &L
         LCLC  &REG,&NA
&NA      SETC  '&NAME'
&L       SETC  '&LV'
         AIF   ('&R' EQ 'R').RFOUND
         MNOTE 8,'NO R- MODE SPECIFIED, JOB WILL BE CANCELED.'
&NAME    CANCEL
         MEXIT
.RFOUND  ANOP
         AIF   (T'&LV NE 'O').LVFOUND
         MNOTE 8,'NO LV- MODE SPECIFIED, JOB WILL BE CANCELED.'
&NAME    CANCEL
         MEXIT
.LVFOUND ANOP
         AIF   (T'&A NE 'O').AFOUND
         MNOTE 8,'NO A- MODE SPECIFIED, JOB WILL BE CANCELED.'
&NAME    CANCEL
         MEXIT
.AFOUND  ANOP
         AIF   ('&LV'(1,1) EQ '(').REG
&NA      LA    0,&LV
&NA      SETC  ''
         AGO   .READY
.REG     ANOP
&REG     SETC  '&L'(2,K'&LV-2)
         AIF   ('&REG' EQ '0').READY
&NA      LR    0,&REG
&NA      SETC  ''
.READY   ANOP
         AIF   ('&A'(1,1) EQ '(').REGA
&NA      LA    1,&A
&NA      SETC  ''
         AGO   .SVC
.REGA    ANOP
         AIF   ('&A' EQ '(1)').NOW
&ADDR    SETC  '&A'(2,K'&A-2)
&NA      LR    1,&ADDR
&NA      SETC  ''
.NOW     ANOP
&NA      LA    1,0(1)        INDICATE FREEMAIN
.SVC     ANOP
         AIF   (T'&MOD NE 'O').GETNM
         L     15,=V(FREEMAIN)
         AGO   .BALR
.GETNM   ANOP
         AIF   ('&MOD'(1,1) EQ '(').MODREG
         L     15,&MOD
         AGO   .BALR
.MODREG  ANOP
         AIF   ('&MOD' EQ '(15)').BALR
&AMOD    SETC  '&MOD'(2,K'&MOD-2)
         LR    15,&AMOD
.BALR    ANOP
         BALR  14,15
         MEND
./ ADD  NAME=EXTGM
         MACRO
&NAME    EXTGM &R,&LV=,&MOD=
         LCLC  &REG,&NA
         LCLC  &L,&AMOD
&NA      SETC  '&NAME'
&L       SETC  '&LV'
         AIF   ('&R' EQ 'R').RFOUND
         AIF   ('&R' EQ 'C').RFOUND
         MNOTE 8,'NO R OR C- MODE FOUND, JOB WILL BE CANCELED.'
&NAME    CANCEL
         MEXIT
.RFOUND  ANOP
         AIF   (T'&LV NE 'O').LVFOUND
         MNOTE 8,'NO LV- MODE SPECIFIED, JOB WILL BE CANCELED.'
&NAME    CANCEL
         MEXIT
.LVFOUND ANOP
         AIF   ('&LV'(1,1) EQ '(').REG
&NA      LA    0,&LV
&NA      SETC  ''
         AGO   .READY
.REG     ANOP
&REG     SETC  '&L'(2,K'&LV-2)
         AIF   ('&REG' EQ '0').READY
&NA      LR    0,&REG
&NA      SETC  ''
.READY   ANOP
         AIF   ('&R' EQ 'R').RFORM
         CNOP  0,4
&NA      BAL   1,*+8
         DC    X'80'         INDICATE GETMAIN
         DC    AL3(0)
         L     1,0(1)
         AGO   .SVC
.RFORM   ANOP
&NA      BAL   1,*+4         INDICATE GETMAIN
.SVC     ANOP
         AIF   (T'&MOD NE 'O').GETNM
         L     15,=V(GETMAIN)
         AGO   .BALR
.GETNM   ANOP
         AIF   ('&MOD'(1,1) EQ '(').MODREG
         L     15,&MOD
         AGO   .BALR
.MODREG  ANOP
         AIF   ('&MOD' EQ '(15)').BALR
&AMOD    SETC  '&MOD'(2,K'&MOD-2)
         LR    15,&AMOD
.BALR    ANOP
         BALR  14,15
         MEND
./ ADD  NAME=EXTXR
         MACRO
&SYM     EXTXR   &RC,&MODE,&MOD=
.*
.*                 EXTENDED RETURN MACRO
.*                 RESTORES REGISTERS
.*                 MAY PROVIDE RETURNCODE
.*
.* XRETURN - BASF VERSION, NOT COMPLETELY COMPATIBLE WITH OTHER
.* INSTALLATIONS
         LCLA  &C
         LCLB  &NC,&CF
         LCLC  &R,&NM
         AIF   (T'&MODE EQ 'O' OR '&MODE' EQ 'R').CONT
         MNOTE 8,'UNKNOWN OPERAND'
         MEXIT
.CONT    ANOP
&NM      SETC  '&SYM'
         AIF   (T'&RC NE 'O').CODE
&NC      SETB  (1)
         AGO   .NOCODE
.CODE    ANOP
&R       SETC  '15'
         AIF   ('&RC'(1,1) EQ '(').REG
         AIF   (T'&RC EQ 'N').FIX
&NM      L     15,&RC                  LOAD CODE
&NM      SETC  ''
         AGO   .NOCODE
.FIX     ANOP
&CF      SETB  (1)
         AGO   .NOCODE
.REG     ANOP
&R       SETC  '&RC'(2,K'&RC-2)
.NOCODE  ANOP
&NM      L     13,4(0,13)              GET HIGH SA ADDR
         AIF   (&NC OR &CF).NOSTORE
         ST    &R,16(0,13)             STORE CODE
.NOSTORE AIF   (T'&MODE EQ 'O').NORENT
         L     1,8(0,13)               GET LOW SA ADDR
         LH    0,2(1)                  GET LENGTH
         EXTFM R,LV=(0),A=(1),MOD=&MOD
.NORENT  LM    14,12,12(13)            RESTORE REGS
         AIF   (NOT &CF).EXIT
         LA    15,&RC                  LOAD CODE
&C       SETA  &RC
         AIF   (&C/4*4 EQ &C).EXIT
         MNOTE 0,'UNUSUAL CODE'
.EXIT    MVI   12(13),X'FF'            FORTRAN REQUIREMENT
         SPM   14                      RESTORE PGM MASK AND CC
         BR    14
         MEND
./ ADD  NAME=EXTXS
         MACRO
&SYM     EXTXS &BASE,&AREA,&ID,&LEN,&TYP=S,&MOD=
.*
.*                 EXTENDED SAVE MACRO
.*                 ASSUMES ENTRYPOINT ADDRESS IN REGISTER 15
.*                 SAVES REGISTERS 14 THROUGH 12
.*                 LOADS BASE REGISTER AND CHAINES SAVEAREAS
.*                 MAY PRODUCE REENTRANT CODE
.*
.*
.*
.*   THIS IS A CHANGED COPY OF BASF- XSAVE VERSION, WITHOUT GETMAIN SVC
.*   BUT GETMAIN SUBROUTINE
.*
.*   TYP=M : BALR 15,0 FOR MAIN PROGRAMS
.*   TYP=S : ASSUMES ENTRY POINT IN REG 15 (FOR SUBROUTINES)
.*   TYP=X : (X ANY OTHER BUT S, M OR BLANK)
.*           BALR 15,0  STM 14,12,12(13) TO BE USED FOR FETCHED PROGS
.*   DEFAULT : TYP=S
.*
         LCLA  &OFFSET,&BASEOFF,&SIX,&OVID
         LCLA  &NREG,&REGIX
         LCLC  &PREV,&REG,&NM
&OFFSET  SETA  0
&SIX     SETA  0
&NM      SETC  '&SYM'
&REG     SETC  '15'
         AIF   ('&AREA' NE '' AND '&LEN' NE '').INKONS
.START   ANOP
         AIF   ('&TYP' EQ 'S').SUB
&NM      BALR  15,0
         BCTR  15,0
         BCTR  15,0
&NM      SETC  ''
&SIX     SETA  6
&OFFSET  SETA  6
.SUB     ANOP
         AIF   (T'&ID EQ 'O').NOID
&OVID    SETA  12+&SIX
&NM      B     &OVID.(15)
&NM      SETC  ''
         DC    X'07'
         DC    CL7'&ID'
&OFFSET  SETA  12+&SIX
.NOID    ANOP
         AIF   ('&TYP' EQ 'M').OVSTM
&NM      STM   14,12,12(13)            SAVE REGS
&NM      SETC  ''
&OFFSET  SETA  &OFFSET+4
.OVSTM   ANOP
         AIF   (T'&BASE EQ 'O').NOBASE
         AIF   ('&BASE'(1,1) NE '(').LOAD
&REGIX   SETA  1
&NREG    SETA  N'&BASE
&REG     SETC  '&BASE(&REGIX)'
         LR    &REG,15
&OFFSET  SETA  &OFFSET+2
.LOOP    ANOP
         USING *-&OFFSET+&BASEOFF,&REG
&REGIX   SETA  &REGIX+1
         AIF   ('&REGIX' GT '&NREG').SETUSE
&PREV    SETC  '&REG'
&REG     SETC  '&BASE(&REGIX)'
         LA    &REG,X'FFF'
         LA    &REG,1(&REG,&PREV)
&OFFSET  SETA  &OFFSET+8
&BASEOFF SETA  &BASEOFF+4096
         AGO   .LOOP
.LOAD    LR    &BASE,15                LOAD BASE REG
&OFFSET  SETA  &OFFSET+2
&REG     SETC  '&BASE'
.NOBASE  ANOP
         USING *-&OFFSET,&REG
.SETUSE  ANOP
         AIF   (T'&AREA NE 'O').NORENT
         AIF   (T'&LEN NE 'O').NOTZERO
         LA    0,72                    GET LENGTH
         AGO   .COMP
.NOTZERO ANOP
         LA    0,&LEN                  GET LENGTH
.COMP    ANOP
         EXTGM R,LV=(0),MOD=&MOD
         XC    0(3*4,1),0(1)           ZERO CHAIN ADDRESSES
         AIF   (T'&LEN NE 'O').GET
         LA    0,72                    GET LENGTH
         AGO   .NOSTH
.GET     ANOP
         LA    0,&LEN                  GET LENGTH
.NOSTH   ANOP
         STH   0,2(1)                  STORE LENGTH
         AIF   ('&TYP' NE 'M').COM
.NORENT  ANOP
         AIF   ('&TYP' NE 'M').CHAIN
         AIF   (T'&AREA NE 'O').OVLR
         LR    13,1
         AGO   .TESTDEF
.OVLR    LA    13,&AREA
         AGO   .TESTDEF
.CHAIN   LA    1,&AREA
.COM     ST    1,8(0,13)               SA DOWN CHAIN
         ST    13,4(0,1)               SA UP CHAIN
         LR    13,1                    LOAD SA REG
         L     1,4(0,13)               GET HIGH SA
         AIF   (T'&AREA NE 'O').LM01
         LM    14,1,12(1)              RELOAD DESTROYED REGS
         AGO   .TESTDEF
.LM01    ANOP
         LM    0,1,20(1)               RESTORE REGS 0 AND 1
.TESTDEF ANOP
         AIF   (T'&AREA NE 'O').TEST
         MEXIT
.TEST    AIF   (T'&AREA EQ 'U').DEFINE
         MEXIT
.DEFINE  B     &AREA+72                BRANCH AROUND SAVEAREA
&AREA    DC    18F'0'                  SAVEAREA
         MEXIT
.INKONS  ANOP
         MNOTE 4,'SAVE AREA ID AND LENGTH MUTUALLY EXCLUSIVE, LENGTH IG*
               NORED'
         AGO   .START
         MEND
./ ADD  NAME=GENAST
         MACRO
         GENAST &SYS=OS
         AIF   ('&SYS' EQ 'OS' OR '&SYS' EQ 'DOS').GOON
         MNOTE 12,'SYSTEM NOT SUPPORTED, SPECIFY OS OR DOS'
         MEXIT
.GOON    ANOP
         BGENMAC SYS=&SYS,DCB=NO
         TITLE 'BASFGEN  AST-PREPERATION ROUTINE'
GENAST   CSECT
*              THIS ROUTINE PREPARES COUNTS AND CODE NECESSARY
*              TO ALLOW CALL OF 'LUASTBL' AT END OF RUN.
*
*              AUTHOR: H. FRANZ
*
*              IT IS ENTERED VIA LINK FROM 'GENFUNC'
*              IF AN 'A' IS IN FIRST COLUMN OF FUNCTION-CARD
*
*              IMAGE OF 'AST-CARD':
*                   COLUMN   1     A
*                   COLUMN   2- 9  DDNAME OF FILE TO BE PROCESSED
*                   COLUMN  11-19 ,21-29, 31-39 ETC.
*                                  AST-FIELD 1, 2 ETC.
*                   AST-FIELD DESCRIPTION:
*                   COLUMN   1     FIELD-DESCRIPTOR
*                            S  MEANS   RECORDS ARE TO BE COUNTED
*                            D  MEANS   FIELD IS UNPACKED DECIMAL
*                            P  MEANS   FIELD IS PACKED DECIMAL
*                            B  MEANS   FIELD IS BINARY
*                   COLUMN   2-5   START POSITION OF FIELD
*                   COLUMN   6-9   END POSITION OF FIELD
*
         EJECT
         USING MAINPARM,PRM
         AIF   ('&SYS' EQ 'OS').OSXS
*        EXTXS BAS,,GENAST,TYP=S,MOD=VGM
         EXTXS BAS,,GENAST,TYP=S,MOD=VGM
         AGO   .XSEND
.OSXS    ANOP
         XSAVE BAS,SVA,GENAST
.XSEND   ANOP
         LA    WK1,1(PNT)
         BAL   LNK,LOOKDDNM
         AIF   ('&SYS' EQ 'DOS').SRFUNC
         LA    WK1,ASTDD
         BAL   LNK,LOOKDDNM
         LA    WK1,ASTDD2
         BAL   LNK,LOOKDDNM
.SRFUNC  ANOP
         SR    FUNC,FUNC     CLAER DISPLACEMENT REG
         LA    WK1,10(PNT)   POINT TO FIRST AST-FIELD
         LA    SW,CODESTRT   POINT TO CODE-AREA
         BAL   LNK,GETASTP   TRY TO RESOLVE THE INPUT FIELDS
         CLC   SYSUT1,1(PNT) IS DDNAME = SYSUT1
         BE    UT1AST
         CLC   SYSUT2,1(PNT) IS DDNAME = SYSUT2
         BE    UT2AST
         AIF   ('&SYS' EQ 'OS').F1
         LA    WK1,DTFTAB    PICK UP TAB START ADDR
         USING DTFTAB,WK1
LOOKID   EQU   *             COMPARE ID FROM ASTCARD WITH TABLE ID
         CLC   6(1,PNT),ID   IS ID EQ ?
         BE    STASTCD       IF YES: STORE AST CODE
         L     WK1,NXT       GET POINTER TO NEXT ENTRY
         LTR   WK1,WK1       LAST ?
         BZ    RETURN        YES IF 0, ID NOT FOUND
         B     LOOKID        NOT AT END LOOK AGAIN
STASTCD  ST    SW,AASTCODE   STORE THE CODE INTO TABLE
         AGO   .XRET
.F1      ANOP
         PACK  DW,6(2,PNT)   PACK WN-PART OF SEP-DDNAME
         CVB   R1,DW         CONVERT ID
         STC   R1,DW         SAVE ID IN WORK-FIELD
         LA    LIMIT,ASTCHN      START OF CHAIN
SERLOOP  EQU   *
         L     R1,0(LIMIT)   GET LINKFIELD ( A(NEXT SEP-AST-ROUTINE))
         LTR   R1,R1         IS IT ZERO ?
         BNZ   ISIDEQ        LOOK IF ID IS EQUAL
         LA    R0,8
         GETMAIN R,LV=(0)    GET 8 BYTES OF CORE
         XC    0(8,R1),0(R1) ZERO GETMAINED AREA
         ST    R1,0(LIMIT)   ADD THEM TO CHAIN
         LR    LIMIT,R1      GET NEW CHAIN MEMBER
         ST    SW,4(LIMIT)   STORE ENTRY OF CODE
         MVC   4(1,LIMIT),DW AND ID
.XRET    ANOP
RETURN   XRETURN 0
LOOKDDNM EQU   *
         AIF   ('&SYS' EQ 'OS').TIOT
         CLC   1(5,PNT),SYSUT1   IS SYS00 ?
         BNE   RETURN        IF NOT: RETURN AT ONCE
         DROP  WK1
         LA    WK1,DTFTAB    PICK UP TABLE START ADDR
         USING DTFTAB,WK1
LOOKAG   EQU   *             COMPARE ID
         CLC   6(1,PNT),ID   ID EQ ?
         BCR   8,LNK         IF EQ: LEAVE
         L     WK1,NXT       GET NEXT ENTRY
         LTR   WK1,WK1       END ?
         BZ    RETURN        YES IF 0, NOT FOUND
         B     LOOKAG
         AGO   .ISID
.TIOT    ANOP
         TIOTSCAN 0(WK1)
         LTR   R15,R15
         BCR   7,LNK
         B     RETURN
ISIDEQ   CLC   DW(1),4(R1)   IS ID OF ENTRY EQUAL TO CARD'S ID
         BE    RETURN        IGNOR SECOND AST-CARD
         LR    LIMIT,R1      POINT TO NEXT ELEMENT
         B     SERLOOP       SEARCH ON, IF NOT EQUAL
.ISID    ANOP
UT1AST   EQU   *
         ST    SW,INRECANF   SAVE CODE ADDRESS FOR SYSUT1
         B     RETURN
UT2AST   EQU   *
         ST    SW,INRECEND   SAVE CODE ADDRESS FOR SYSUT2
         B     RETURN
GETASTP  EQU   *
         LA    WK2,7         NUMBER OF FIELDS
         USING DASTCODE,SW
NEXTFLD  CLC   BLANKS,0(WK1) IS FIELD ALL BLANK ?
         BE    EOPARMS       YES, ASSUME END
         CLI   0(WK1),C'S'   OR ONLY RECORD COUNTING
         BE    RECROUT
         PACK  DW,1(4,WK1)   PACK START POSITION
         CVB   R0,DW         INTO REG 0
         PACK  DW,5(4,WK1)   PACK END POSITION
         CVB   R1,DW         INTO REG 1
         SR    R1,R0         LENGTH OF FIELD
         BM    NEXTPRM       ERROR, ICNORE THAT FIELD
         BCTR  R0,0          DISPLACEMENT
         SR    R15,R15
         CLI   0(WK1),C'D'   IS IT UNPACKED
         BE    UNPKROUT
         CLI   0(WK1),C'P'   OR PACKED
         BE    PACKROUT
         CLI   0(WK1),C'B'   OR BINARY
         BE    BINROUT
NEXTPRM  EQU   *
         LA    WK1,10(WK1)   POINT TO NEXT FIELD
         LA    FUNC,8(FUNC)  POINT TO NEXT ACCU
         BCT   WK2,NEXTFLD
EOPARMS  EQU   *
         MVC   0(2,SW),=X'07FE'   SET A RETURN
         LA    SW,2(SW)      POINT TO END OF CODE
         LA    R1,ASTCODE    POINT TO BEGIN OF CODE
         SR    SW,R1         CALCULATE LENGTH
         LR    R0,SW
         BCTR  SW,0          REDUCE IT BY ONE FOR EXECUTE
         AIF   ('&SYS' EQ 'OS').OSGM
*        EXTGM R,LV=(0),MOD=VGM
         EXTGM R,LV=(0),MOD=VGM
         AGO   .EX
.OSGM    ANOP
         GETMAIN R,LV=(0)    GET CORE FOR CODE
.EX      ANOP
         EX    SW,MOVECODE   MOVE THE CODE
         LR    SW,R1         SET REG TO IT
         BR    LNK           AND RETURN
MOVECODE MVC   0(0,R1),ASTCODE
UNPKROUT EQU   *
         MVC   DASTCODE(UNPKLEN),PREUNPK
UNPKPACK AH    R0,FLDDISPL   ADD REGISTER
         STH   R0,FLDDISPL   STORE IT TO CODE
         IC    R15,FIELDLEN  GET LENGTH  ( < 16)
         AR    R15,R1        ADD NEW
         STC   R15,FIELDLEN  STORE BACK
         STC   FUNC,ACCUDISP CURRENT ACCU
         LA    SW,UNPKLEN(SW)
         B     NEXTPRM
PACKROUT EQU   *
         MVC   DASTCODE(PACKLEN),PREPACK
         B     UNPKPACK
*
BINROUT  EQU   *
         MVC   DASTCODE(BINLEN),PREBIN
         AH    R0,FLDDISPL
         STH   R0,FLDDISPL
         SH    R1,=H'3'      CALCULATE
         LPR   R1,R1         SHIFTLENGTH
         SLL   R1,3
         STC   R1,SHIFTNUM   UPDATE SHIFT-INSTRUCTION
         STC   FUNC,BINACCU  CURRENT ACCU
         LA    SW,BINLEN(SW) UPDATE POINTER REG
         B     NEXTPRM
*
RECROUT  EQU   *
         MVC   DASTCODE(RECLEN),PREREC
         STC   FUNC,RECACCU+1 CURRENT ACCU
         LA    SW,RECLEN(SW) UPDATE POINTER REG
         B     NEXTPRM
ASTCODE  DS    0D
         DC    7PL8'+0'      SEVEN COUNTERS
         DC    PL8'+0'       WORK COUNTER
         DC    PL2'+1'       CONSTANT 1 FOR RECORD COUNTING
CODESTRT EQU   *
*              ENTRY TO ASTCODE MUST BE
*                   BAL R14,8*8+2(R15)
*
         DC    (12*7+1)XL2'07FE'
*
*              INITIALIZE CODE WITH RETURNS
*
         SPACE 3
PREUNPK  DC    X'F270F0382000'    PACK THE FIELD TO WORK COUNTER
         DC    X'FA77F000F038'    ADD IT TO ASSOCIATED COUNTER
UNPKLEN  EQU   *-PREUNPK
PREPACK  DC    X'F870F0382000'    ZAP THE FIELD TO WORK COUNTER
         DC    X'FA77F000F038'    ADD IT TO ASSOCIATED COUNTER
PACKLEN  EQU   *-PREPACK
PREBIN   DC    X'D203F0382000'    MOVE FIELD TO WORK COUNTER
         DC    X'5830F038'        LOAD IT INTO REG
         DC    X'8A300000'        SHIFT TO CORRECT POSITION
         DC    X'4E30F038'        CONVERT IT TO WORK COUNTER
         DC    X'FA77F000F038'    ADD IT TO ASSOCIATED COUNTER
BINLEN   EQU   *-PREBIN
PREREC   DC    X'FA71F000F040'    ADD 1 TO ASSOCIATED COUNTER
RECLEN   EQU   *-PREREC
         SPACE 3
*                  C O N S T A N T S
*
         AIF   ('&SYS' EQ 'OS').SYSUT
SYSUT1   DC    CL8'SYS000'
SYSUT2   DC    CL8'SYS001'
         AGO   .DW
.SYSUT   ANOP
SYSUT1   DC    CL8'SYSUT1'
SYSUT2   DC    CL8'SYSUT2'
ASTDD    DC    CL8'ASTPARM'
ASTDD2   DC    CL8'ASTBLATT'
.DW      ANOP
DW       DC    D'0'          WORK-FIELD
BLANKS   DC    CL10' '       COMPARE-FIELD
         LTORG
DASTCODE DSECT
         DS    CL1
FIELDLEN DS    CL1
RECACCU  DS    CL2
FLDDISPL DS    CL2
         DS    CL3
ACCUDISP DS    CL1
         DS    CL3
SHIFTNUM DS    CL1
         DS    CL7
BINACCU  DS    CL1
         DS    CL2
         MEND
./ ADD  NAME=GENCORE
         MACRO
         GENCORE &SYS=OS
         AIF   ('&SYS' EQ 'DOS').COP
         AIF   ('&SYS' EQ 'OS').COP
         MNOTE 12,'SYSTEM NOT SUPPORTED, SPECIFY DOS OR OS'
         MEXIT
.COP     ANOP
         BGENMAC SYS=&SYS,DCB=NO
         TITLE ' CORE ALLOCATION ROUTINE FOR WORK BLOCKS'
GENCORE  CSECT
*              PROGRAMM ZUR SPEICHERZUORDUNG FUER 'LUGENER'
*
*
*              AUTOR: H. FRANZ
*
         USING MAINPARM,PRM
         AIF   ('&SYS' EQ 'OS').OSXS
*        EXTXS BAS,,GENCORE,PARMSIZE,TYP=F,MOD=VGM
         EXTXS BAS,,GENCORE,PARMSIZE,TYP=F,MOD=VGM
         AGO   .ENDXS
.OSXS    ANOP
*        XSAVE BAS,,GENCORE,PARMSIZE
         XSAVE BAS,,GENCORE,PARMSIZE
         LR    PRM,R1
.ENDXS   ANOP
         USING SAVEAREA,R13
         XC    MIN(DSEND-MIN),MIN      CLEAR DUMMYSECTION
         AIF   ('&SYS' EQ 'DOS').DEFAULT
.MVGETM  ANOP
         MVC   VGETMAIN(LISTLENG),LGETMAIN
.DEFAULT ANOP
DEFAULT  LH    R0,FNCPOWER             GET POWER NUMBER RECEIVED
         LA    LIMIT,FUNCDEF           GET STANDARD ASSUMPTION
         BAL   LNK,GETCORE             LINK TO ALLOCATION ROUTINE
         L     R0,ADR                  ADDRESS OF ALLOCATED CORE
         ST    R0,AFUNC                SAVE IT
         A     R0,LENG                 ADD LENGTH
         ST    R0,LFUNC                UPPER LIMIT
         LH    R0,FMTPOWER             NOW SAME FOR FORMAT TABLE
         LA    LIMIT,FMTDEF
         BAL   LNK,GETCORE
         L     R0,ADR
         ST    R0,AFORMAT
         A     R0,LENG
         SH    R0,=H'80'               SAVETY BYTES
         ST    R0,LFORMAT
         LH    R0,ENTPOWER             NOW SAME FOR ENTRY-TABLE
         LA    LIMIT,ENTRDEF
         BAL   LNK,GETCORE
         L     R0,ADR
         ST    R0,AACTIONS
         A     R0,LENG
         SH    R0,=H'4'
         ST    R0,LACTIONS
         AIF   ('&SYS' EQ 'OS').OSXR
*ETURN   EXTXR 0,R,MOD=VFM
RETURN   EXTXR 0,R,MOD=VFM
         AGO   .GETCOR
.OSXR    ANOP
*ETURN   XRETURN 0,R
RETURN   XRETURN 0,R
.GETCOR  ANOP
GETCORE  LTR   R0,R0                   IF NOT SPECIFIED
         BP    POWERWAS                SET POWER
         LA    R0,1                    TO ONE
POWERWAS EQU   *
         STH   LIMIT,ADR               FIELD FOR MULTIPLICATION
         MH    R0,ADR                  DESIRED LENGTH
         AIF   ('&SYS' EQ 'OS').OSGETM
         ST    R0,LENG       PROVIDE LENG IF AVAILABLE
*        EXTGM C,LV=(0),MOD=VGM
         EXTGM C,LV=(0),MOD=VGM
         ST    R1,ADR        PROVIDE ADDR OF AREA
         CH    R0,CC80A      ENOUGH STORAGE AVAILABLE ?
         BCR   7,LNK         IF NOT EQ: NO 80A
         AGO   .BRC8
.OSGETM  ANOP
         LR    R1,R0
         STM   R0,R1,MIN               MINIMUM = MAXIMUM
*        GETMAIN ,LA=MIN,A=ADR,MF=(E,VGETMAIN)
         GETMAIN ,LA=MIN,A=ADR,MF=(E,VGETMAIN)
         LTR   R15,R15                 WAS CORE AVAILABLE
         BCR   8,LNK                   YES, RETURN
.BRC8    ANOP
         TM    SWOPEN,PRTOPEN
         BZ    NOTPUT
         L     WK2,ALIST               OTHERWISE
         USING AZEILE,WK2
         BAL   LNK,CLEARLIN            CLEAR THE OUTPUTLINE
         MVI   ASA,EINS
         MVC   AFLAG,ERRMSGAL          AND PUT
         MVC   ACARDOUT(L'NOCORE),NOCORE
         L     R1,ALISTE               AN ERROR MESSAGE
*        PUT   (R1),(WK2)
         PUT   (R1),(WK2)
NOTPUT   EQU   *
         OI    SW2,COREFULL            AND INDICATE THE ERROR
         B     RETURN
CLEARLIN MVI   ASA,BLANK
         MVC   AFLAG(ALINELEN),ASA
         BR    LNK
         AIF   ('&SYS' EQ 'OS').OSDEF
CC80A    DC    H'2058'       80A IN REG 0 RETURN IF NOT ENOUGH CORE
LISTLENG EQU   0             NOT NEEDED IN DOS (OS: GETMAIN LIST FORM )
         AGO   .OVOSDEF
.OSDEF   ANOP
*GETMAIN GETMAIN VC,MF=L
LGETMAIN GETMAIN VC,MF=L
LISTEND  DS    0D
LISTLENG EQU   LISTEND-LGETMAIN
.OVOSDEF ANOP
NOCORE   DC    C'INSUFFICIENT CORE FOR SPECIFIED POWER, ALLOCATE MORE'
ERRMSGAL DC    CL12'*** ERROR **'
FUNCDEF  EQU   32*FCLEN
FMTDEF   EQU   2048
ENTRDEF  EQU   32*4
         LTORG
DUMMY    DSECT
SAVEAREA DC    18F'0'
MIN      DC    F'0'
MAX      DC    F'0'
ADR      DC    F'0'
LENG     DC    F'0'
DSEND    DS    0D
VGETMAIN EQU   DSEND
PARMSIZE EQU   DSEND-SAVEAREA+LISTLENG
.MEND    ANOP
         MEND
./ ADD  NAME=GENDCBS
         MACRO
         GENDCBS &SYS=OS
         AIF   ('&SYS' EQ 'OS').CONT
         AIF   ('&SYS' EQ 'DOS').DOSSTOP
         MNOTE 12,'&SYS -SYSTEM NOT SUPPORTED, SPECIFY OS OR DOS'
         MEXIT
.DOSSTOP ANOP
         MNOTE *,'THIS CSECT IS NOT NEEDED FOR DOS VERSION OF BASFGEN'
         MEXIT
.CONT    ANOP
SYSPRINT DCB   DDNAME=SYSPRINT,                                        *
               MACRF=PM,                                               *
               DSORG=PS,                                               *
               LRECL=133,                                              *
               RECFM=FBA,BUFNO=1,                                      *
               EROPT=SKP
PRINTLEN EQU   *-SYSPRINT
SYSIN    DCB   DDNAME=SYSIN,                                           *
               MACRF=GM,                                               *
               DSORG=PS,                                               *
               RECFM=FB,                                               *
               LRECL=80,                                               *
               EROPT=ABE
*
INLEN    EQU   *-SYSIN
*
UT1BSAM  DCB   DDNAME=SYSUT1,                                          *
               MACRF=RC,                                               *
               DSORG=PS
BSAMLEN  EQU   *-UT1BSAM
UT1SEQ   DCB   DDNAME=SYSUT1,                                          *
               MACRF=GL,                                               *
               DSORG=PS
SAVPRMWD DC    F'0'          ADDRESS OF PARM-AREA                ***
*                            REQUIRED AT SWITCH OF CONCATENATED  ***
*                            DATA SETS
SEQLEN   EQU   *-UT1SEQ
*
UT2      DCB   DDNAME=SYSUT2,                                          *
               DSORG=PS,                                               *
               MACRF=PM
UT2LEN   EQU   *-UT2
*
UT1ISAM  DCB   DDNAME=SYSUT1,                                          *
               DSORG=IS,                                               *
               MACRF=(GL,SK)
ISAMLEN  EQU   *-UT1ISAM
MAXRANGE DC    H'4200'   DEFAULT VALUE FOR DATA-BASE-SEGMENTS
         MEND
./ ADD  NAME=GENDUMP
         MACRO
         GENDUMP &SYS=OS
         AIF   ('&SYS' EQ 'DOS').COP
         AIF   ('&SYS' EQ 'OS').COP
         MNOTE 12,'SYSTEM NOT SUPPORTED, SPECIFY DOS OR OS'
         MEXIT
.COP     ANOP
         BGENMAC SYS=&SYS
         TITLE ' LUGENER APPENDAGE TO DUMP A BUFFER AREA'
*
*        PARAMETERS :
*
*              REG 0 : A(BEGIN OF THE AREA TO BE DUMPED)
*              REG 1 : A(END OF THE AREA TO BE DUMPED)
*
*        AUTHOR :   H. FRANZ           1. 6. 73
*
GENDUMP  CSECT
         AIF   ('&SYS' EQ 'OS').OSXS
*        EXTXS BAS,SAVEAREA,GENDUMP
         EXTXS BAS,SAVEAREA,GENDUMP
         AGO   .USPRM
.OSXS    ANOP
*        XSAVE BAS,,GENDUMP,PARMLEN
         XSAVE BAS,,GENDUMP,PARMLEN
         USING DSECT,R13
.USPRM   ANOP
         USING MAINPARM,PRM
         L     WK2,ALIST     GET THE OUTPUT LINE FOR SYSPRINT
         USING AZEILE,WK2
         SR    R1,R0         COMPUTE LENGTH OF THE AREA
         LR    LEN,R1        SET THE LENGTH REGISTER
         LR    PNT,R0        AND THE POINTER REGISTER TO ORIGIN
         L     R1,PRTCNT     GET ACTUAL LINE COUNT
         LA    R1,4(R1)      ADD FOUR
         ST    R1,PRTCNT     RESTORE LINE COUNT
         C    R1,MAXLINES    COMPARE WITH SPECIFIED MAXIMUM
         BL    PRINTOK
         L     R15,AHEADPRT  GET ADDRESS OF HEADER PRINT ROUTINE
         BALR  R14,R15       AND LINK TO IT
PRINTOK  EQU   *
         BAL   LNK,CLEARLIN  CLEAR THE OUTPUT LINE
         MVI   ASA,NULL      WRITE WITH SPACING
         MVC   AERRMSG,HEAD  MOVE A HEADER TO LINE
         CVD   LEN,DW        CONVERT THE BYTE COUNT
         ED    AERRMSG+L'HEAD(8),DW+4  AND EDIT IT INTO PRINT-LINE
         L     R1,ALISTE     GET SYSPRINT DCB
         PUT   (1),(WK2)     AND PUT THE HEADLINE
         L     R1,ALISTE     GET  THE DCB
         AIF   ('&SYS' EQ 'OS').OSPUT
         MVC   ASA(L'HEADLINE),HEADLINE
         PUT   (1),(WK2)
         AGO   .CLEAR
.OSPUT   ANOP
         PUT   (1),HEADLINE  PUT A PATTERN FOR BETTER READABILITY
.CLEAR   ANOP
         BAL   LNK,CLEARLIN  CLEAR THE LINE AGAIN
NEXTLINE EQU   *
         LA    WK1,40        NUMBER OF BYTES DUMPED ON A LINE
         CR    LEN,WK1       COMPARE WITH REMAINING LENGTH
         BNL   DIMIN         STILL MORE THAN 40 BYTES
         LR    WK1,LEN       IF LESS, TAKE REMAINDER
DIMIN    EQU  *
         BCTR  WK1,0         REDUCE FOR EXECUTE
         LTR   WK1,WK1       TEST IF SOMETHING LEFT
         BM    RETURN        NO, RETURN
         L     R1,PRTCNT     GET ACTUAL LINE COUNT
         LA    R1,1(R1)      ADD ONE
         ST    R1,PRTCNT     RESTORE LINE COUNT
         C    R1,MAXLINES    COMPARE WITH SPECIFIED MAXIMUM
         BL    OKPRINT
         L     R15,AHEADPRT  GET ADDRESS OF HEADER PRINT ROUTINE
         BALR  R14,R15       AND LINK TO IT
OKPRINT  EQU   *
         EX    WK1,MOVE1     MOVE NEXT BYTES TO OUTPUT LINE
         EX    WK1,MOVE2     MOVE NEXT BYTES TO OUTPUT LINE
         EX    WK1,TR2       TRANSLATE THE RIGHT PORTION OF CHARACTERS
         LA    R0,1(WK1)     LENGTH OF THE STRING MOVED TO LINE
         LA    R1,AZEILE+1   BEGIN OF THE STRING
         L     R15,ACONVXE    GET ADDRESS OF SUBROUTINE
         BALR  R14,R15       AND LINK TO IT
*        THE CHARACTER STRING IS EXPANDED TO DOUBLE LENGTH
*        AND CONVERTED TO 'EBCDIC'-CODE
         MVI   AZEILE+89,STERN MAKE AN EXTRA STAR
         LA    MSG,AZEILE+91(WK1)      BEFOR AND BEHIND
         MVI   0(MSG),STERN  THE TRANSLATED CHARACTERS
         L     R1,ALISTE     GET DCB-ADDRESS
         PUT   (1),(WK2)     AND PUT LINE
         BAL   LNK,CLEARLIN  CLEAR THE OUTPUT LINE
         LA    PNT,1(WK1,PNT) SET POINTER REGISTER UP OVER DUMPED AREA
         SH    LEN,=H'40'    DIMINUISH LENGTH
         BP    NEXTLINE      IF THERE IS A REMAINDER, GO ON
         AIF   ('&SYS' EQ 'OS').OSXR
*ETURN   EXTXR
RETURN   EXTXR
         AGO   .LTORG
.OSXR    ANOP
*ETURN   XRETURN ,R          IF NOT, RETURN TO CALLER
RETURN   XRETURN ,R          IF NOT, RETURN TO CALLER
.LTORG   ANOP
         LTORG
CLEARLIN DS    0H
         MVI   ASA,BLANK     CLEAR THE
         MVC   AFLAG(ALINELEN),ASA     OUTPUT LINE
         BR    LNK           WITH BLANKS
MOVE1    MVC   AZEILE+1(0),0(PNT)      MOVE PART TO BE EXPANDED
MOVE2    MVC   AZEILE+90(0),0(PNT)     MOVE PART TO BE TRANSLATED
TR2      TR    AZEILE+90(0),TAB        TRANSLATE CHARACTERS TO PRINT
HEAD     DC    C'SATZLAENGE :'
MASK     DC    X'4020202020202120'     MASK FOR BYTE COUNT
HEADLINE DS    0CL133
         DC    C'0'          ASA CHARACTER
         DC    C' . . . . 5'
         DC    C' . . . .10'
         DC    C' . . . .15'
         DC    C' . . . .20'
         DC    C' . . . .25'
         DC    C' . . . .30'
         DC    C' . . . .35'
         DC    C' . . . .40'
         DC    CL9' '
         DC    C'....*...10'
         DC    C'....*...20'
         DC    C'....*...30'
         DC    C'....*...40'
         DC    CL4' '
         DS    0D
TAB      DC    256C'.'       SUBSTITUTION FOR UNPRINTABLE CHARACTERS
         ORG    TAB+C' '
         DC    C' '
         ORG   TAB+C'A'
         DC    C'ABCDEFGHI'
         ORG   TAB+C'J'
         DC    C'JKLMNOPQR'
         ORG    TAB+C'S'
         DC    C'STUVWXYZ'
         ORG   TAB+C'0'
         DC    C'0123456789'
         ORG
         AIF   ('&SYS' EQ 'DOS').SAV
DSECT    DSECT
SAVEAREA DS    18F
.SAV     ANOP
DW       DS    D             FOR DECIMAL CONVERSION
DSEND    DS    0D            END INDICATOR
         AIF   ('&SYS' EQ 'DOS').VGM
PARMLEN  EQU   DSEND-DSECT   LENGTH OF THE DSECT (FOR GETMAIN)
.VGM     ANOP
         MEND
./ ADD  NAME=GENFUNC
         MACRO
         GENFUNC &SYS=OS
         AIF   ('&SYS' EQ 'DOS').COP
         AIF   ('&SYS' EQ 'OS').COP
         MNOTE 12,'SYSTEM NOT SUPPORTED, SPECIFY DOS OR OS'
         MEXIT
.COP     ANOP
         BGENMAC SYS=&SYS
         TITLE '   FUNCTION INTERPRETATION ROUTINE'
*
*              LIEST UND
*              INTERPRETIERT FUNCTIONSKARTEN FUER LUGENER
*
*
*              AUTHOR: H. FRANZ
*
GENFUNC  CSECT
         USING MAINPARM,PRM
         AIF   ('&SYS' EQ 'OS').OSXS
*        EXTXS BAS,,GENFUNC,PARMLEN,TYP=F,MOD=VGM
         EXTXS BAS,,GENFUNC,PARMLEN,TYP=F,MOD=VGM
         AGO   .ENDXS
.OSXS    ANOP
*        XSAVE BAS,,GENFUNC,PARMLEN
         XSAVE BAS,,GENFUNC,PARMLEN
         LR    PRM,1         GET PARAMETERS
.ENDXS   ANOP
         USING SAVEAREA,R13
         XC    SAVEAREA+72(PARMLEN-72),SAVEAREA+72
         L     WK2,ALIST
         USING AZEILE,WK2
         L     FUNC,AFUNC
         USING FUNCTION,FUNC
         L     R1,AKARTE
         AIF   ('&SYS' EQ 'OS').IHAD
         LA    R15,EODHERE   LOAD ADDR OF EODAD ADDR
         ST    R15,28(R1)    STORE IT INTO DTFCD EODAD ADDR
         AGO   .FCOUNT
.IHAD    ANOP
         USING IHADCB,R1
         IC    R14,DCBBFTEK
         L     SW,DCBEODAD
         LA    R15,EODHERE
         ST    R15,DCBEODAD
         STC   R14,DCBBFTEK
.FCOUNT  ANOP
         ZAP   FCOUNT,MAXNUM
         MVI   FIDENT,COPY
SETEND   EQU   *                       SET END FUNCTION
         LA    FUNC,FCLEN(FUNC)        AS SECOND FUNCTION
         ZAP   FCOUNT,MAXNUM
         MVI   FIDENT,ENDFUNC          FOR THE CASE OF NO FUNCTIONS
         L     FUNC,AFUNC              RESET THE POINTER
         TM    SWINPUT,EODADIN
         BNZ   EODHERE
         L     PNT,ACARD
         LA    LIMIT,72(PNT)
         B     BEGIN
GETCARD  EQU   *
         NI    SWFUNC,ERR+WARNING      CLEAR SWITCH, BUT NOT ERROR IND
         OC    SWINPUT,SWFUNC          COLLECT ERRORS AND WARNINGS
         MVI   SWFUNC,0                NOW CLEAR THE SWITCH TOTALLY
         L     R1,AKARTE
         L     PNT,ACARD     GET ACTUAL INPUTCARD
*        GET   (R1),(PNT)
         GET   (R1),(PNT)
         LA    LIMIT,72(PNT) POINT TO CARD END
         L     R1,SYSINCDS   GET NUMBER OF SYSIN CARDS
         LA    R1,1(R1)      ADD ONE
         ST    R1,SYSINCDS   AND STORE COUNT BACK
AGAIN    EQU   *
         CLI   0(PNT),STERN  WAS FORMAT BEGIN
         BE    STERNFND      YES
         CLI   0(PNT),DOLLAR WAS A SUB-FORMAT
         BE    STERNFND
         CLI   0(PNT),BLANK  WAS A BLANK
         BNE   PUTCARD       IF NOT, CARD MUST BE A FUNCTION CARD
         LA    PNT,1(PNT)    UPDATE POINTER REG
         CR    LIMIT,PNT     IS CARDEND ?
         BNL   AGAIN         NO, TEST AGAIN
PUTCARD  EQU   *
         L     PNT,ACARD     SET PONTER REG BACK TO CARD BEGIN
         BAL   LNK,CLEARLIN
         L     R1,ALISTE
         MVC   ACARDOUT,0(PNT)
         BAL   LNK,PUTMSG
BEGIN    EQU   *
         CLC   COMMENT,0(PNT) IS THIS A COMMENT CARD ?
         BE    GETCARD       YES, DON'T PROCESS
         CLI   0(PNT),ASTCARD IS IT A 'AST-CARD'
         BE    GENAST        GO TO AST-ROUTINE
         ZAP   DW,MAXNUM     SET DEFAULT COUNT OF MAXIMUM
         BAL   LNK,TSTNOTBL  LOOK FOR A COUNT
TEST     EQU   *
         TM    SWFUNC,CNTFOUND
         BO    TSTFUNC
         TM    SWFUNC,NOTFOUND
         BZ    TSTFUNC
NOTFND   LA    MSG,NOFUNCT   NOTHING FOUND ON CARD
         OI    SWFUNC,WARNING
IGNORE   EQU  *
         MVC   AMSGSUB(L'CD),CD    MOVE MESSAGE TO OUTPUTLINE
         MVC   AACTION(L'IGNOR),IGNOR
          BAL   LNK,INVALID  AND PUT ERROR MESSAGE
         B     GETCARD       THEN RETURN WITHOUT UPDATING
TSTFUNC  EQU   *
         BAL   LNK,FNDFUNC   LOOK FOR FUNCTION
         TM    SWFUNC,NOTFOUND
         BO    NOTFND        NOTHING FOUND
         BAL   LNK,GETFUNC   TEST FUNCTION
         TM    SWFUNC,NOFUNC GO TO UPDATE
         BZ    UPDATE        IF VALID FUNCTION
         OI    SWFUNC,ERR    INDICATE ERROR CONDITION
         LA    MSG,INVFUNC
         BAL   LNK,INVALID   PUT THE ERROR MESSAGE
         B     UPDATE        RETURN WITH UPDATING
*        THIS  WILL CAUSE THE EXECUTING PROGRAM TO STOP AT THIS POINT
UPDATE   EQU   *             UPDATE POINTER
         ZAP   FCOUNT,DW     AND MOVE IT TO FUNCTION-COUNT
         LA    FUNC,FCLEN(FUNC)
         C     FUNC,LFUNC
         BNL   FUNCFULL
         ZAP   FCOUNT,MAXNUM
         MVI   FIDENT,ENDFUNC
         B     GETCARD       THEN RETURN WITHOUT UPDATING
INVALID  EQU   *             THIS ROUTINE WILL WRITE AN ERROR MESSAGE
         ST    PNT,PNTSAV    SAVE ACTUAL POINTER FOR CONTINUATION
         S     PNT,ACARD     DISPLACEMENT ON CARD
         A     PNT,FIX       ADD FIX PART OF OUTPUT-LINE
         A     PNT,ALIST     AND LINE ADDRESS
         MVI   0(PNT),POINTER  SET INDICATOR
         MVC   AERRMSG,0(MSG)
         TM    SWFUNC,WARNING
         BZ    PUTERR
         MVC   AFLAG,WRNMSG
         B     PUTMSG
PUTERR   EQU   *
         MVC   AFLAG,ERRMSG  MOVE MESSAGES TO OUTPUTLINE
PUTMSG   L     1,ALISTE      PUT THE LINE
         LA    0,AZEILE
*        PUT   (1),(0)
         PUT   (1),(0)
         L     R15,PRTCNT
         LA    R15,1(R15)    ADD ONE TO PRINT COUNT
         C     R15,PRTCNT    AND STORE BACK
         C     R15,MAXLINES  IS PAGE CHANDE NECESSARY
         BNH   CLEARLIN      NO
         L     R15,AHEADPRT  GET ADDRESS OF PAGE-ROUTINE
         BALR  R14,R15       LINK TO IT
CLEARLIN EQU   *
         MVI   ASA,BLANK
         MVC   AFLAG(ALINELEN),ASA     CLEAR THE LINE
         BR    LNK           RETURN    TO CALLING ROUTINE
STERNFND EQU   *
         OI    SWFUNC,FUNCEND
         B     RETURN
FNDFUNC  EQU   *             FIND THE FUNCTION REQUESTED
         CLI   0(PNT),BLANK
         BCR   7,LNK         LOOK FOR NEXT NONBLANK CHARACTER
         LA    PNT,1(PNT)
         CR    PNT,LIMIT
         BL    FNDFUNC
         OI    SWFUNC,NOTFOUND
         BR    LNK
GETFUNC  EQU   *             WHICH FUNCTION
         CLI   0(PNT),STERN
         BE    STERNFND
         CLI   0(PNT),DOLLAR IS A SUBFORMAT
         BE    STERNFND      YES, FUNCTION CARD END
TCOPY    CLI   0(PNT),COPY
         BNE   TSKIP
         MVI   FIDENT,COPY
         CLC   NCOPY,0(PNT)
         BCR   8,LNK         RETURN IF EQUAL
         MVC   AMSGSUB(L'NCOPY),NCOPY
         B     WRNGFUNC
TSKIP    EQU   *
         CLI   0(PNT),SKIP
         BNE   TBACKSP
         MVI   FIDENT,SKIP
         CLC   NSKIP,0(PNT)
         BCR   8,LNK         RETURN IF EQUAL
         MVC   AMSGSUB(L'NSKIP),NSKIP
         B     WRNGFUNC
TBACKSP  EQU   *
         CLI   0(PNT),BACKSP
         BNE   TREWIND
         MVI   FIDENT,BACKSP
         CLC   NBACKSP,0(PNT)
         BCR   8,LNK         RETURN IF EQUAL
         MVC   AMSGSUB(L'NBACKSP),NBACKSP
         B     WRNGFUNC
TREWIND  EQU   *
         CLI   0(PNT),REWIND
         BNE   TUNLOAD
         MVI   FIDENT,REWIND
         CLC   NREWIND,0(PNT)
         BCR   8,LNK         RETURN IF EQUAL
         MVC   AMSGSUB(L'NREWIND),NREWIND
         B     WRNGFUNC
TUNLOAD  EQU   *
         CLI   0(PNT),UNLOAD
         BNE   TWTM
         MVI   FIDENT,UNLOAD
          CLC  NUNLOAD,0(PNT)
         BCR   8,LNK         RETURN IF EQUAL
         MVC   AMSGSUB(L'NUNLOAD),NUNLOAD
          B     WRNGFUNC
TWTM      EQU   *
         CLI   0(PNT),WTM
         BNE   TFAULT
         MVI   FIDENT,WTM
         CLC   NWTM,0(PNT)
         BCR   8,LNK         RETURN IF EQUAL
         MVC   AMSGSUB(L'NWTM),NWTM
          B     WRNGFUNC
TFAULT   EQU   *
         CLI   0(PNT),FAULT
         BNE   TTABLE
         MVI   FIDENT,FAULT
         OI    SWOPEN,FLTS . SET INDICATOR THAT FAULTY BLOCKS ARE NOT
*                            TO BE BYPASSED
         CLC   NFAULT,0(PNT)
         BCR   8,LNK
         MVC   AMSGSUB(L'NFAULT),NFAULT
          B     WRNGFUNC
TTABLE   EQU   *
         CLC   NTABLE,0(PNT)
         BNE   TDCKS .       MAY BE DATA-CHECKS
         L     R1,ATABENTR             GET ADDRESS OF TABLE ENTRY VECT
         LTR   R1,R1                   TEST, IF ALREADY PRESENT
         BNZ   LINKTO                  IS ALREADY ESTABLISHED
         LA    R0,TABENTLN
         AIF   ('&SYS' EQ 'OS').GETM1
*        EXTGM R,LV=(0),MOD=VGM
         EXTGM R,LV=(0),MOD=VGM
         AGO   .STAD
.GETM1   ANOP
*        GETMAIN R,LV=(R0)
         GETMAIN R,LV=(R0)
.STAD    ANOP
         ST    R1,ATABENTR
         XC    0(TABENTLN,R1),0(R1)     CLEAR THE ENTRIES
LINKTO   EQU   *
         LA    LIMIT,1 .     SET INDICATOR REG NOT ZERO
         AIF   ('&SYS' EQ 'OS').LINKTAB
         LA    R14,AFETCH8   GET RETURN ADDRESS FROM FETCH ROUTINE
*        FETCH BGENTAB
         FETCH BGENTAB
AFETCH8  EQU   *
         AGO   .TMSW
.LINKTAB ANOP
         LR    R1,PRM
*        LINK  EP=GENTABLE   LINK TO TABLE CONSTRUCTION ROUTINE
         LINK  EP=GENTABLE   LINK TO TABLE CREATE ROUTINE
.TMSW    ANOP
         TM    SWTAB,TABNOTOK
         BZ    GETCARD       ALL OK, READ NEXT CARD
TABERROR EQU   *
         L     PNT,ACARD
         LA    PNT,CARDLEN(PNT)  POINT TO END OF CARD
         OI    SWFUNC,ERR    INDICATE ERROR
         TM    SWTAB,TABNOTAB  WAS TABLE DEFINITION IMPOSSIBLE ?
         BZ    TABTON        NO, SOME TABLE WAS
         LA    MSG,TABMSG    POINT TO MESSAGE
         B     IGNORE
TABTON   EQU   *
         TM    SWTAB,TABEODAD WAS EODAD DURING TABLE PROCESSING ?
         BZ    TABISFUL      NO, TABLE MUST BE FULL
         LA    MSG,TABDEFMS  POINT TO MESSAGE
         BAL   LNK,INVALID
         B     EODHERE       GO TO EODAD ROUTINE
TABISFUL EQU   *
         LA    MSG,TABFULMS  POINT TO MESSAGE
         BAL   LNK,INVALID
         B     RETURN        TERMINATE FUNCTION PROCESSING
TDCKS    EQU   *
         CLI   0(PNT),DCKS . MAY KEY-WORD BE DCKS ?
         BNE   TERROR .      NO, INDICATE ERROR
         MVI   FIDENT,DCKS . MOVE CODE TO FUNCTION
         OI    SWOPEN,DCK .  SET FLAG TO INDICATE THAT FAULTY BLOCKS
*                            ARE TO BE SKIPPED
         CLC   NDCKS,0(PNT) .IS KEYWORD CORRECTLY SPECIFIED ?
         BCR   8,LNK .       YES, GO ON
         MVC   AMSGSUB(L'NDCKS),NDCKS  MOVE ASSUMPTION
         B     WRNGFUNC .    PUT AN ERROR MESSAGE BUT GO ON
TERROR   OI    SWFUNC,NOFUNC
         BR    LNK
WRNGFUNC EQU   *
         OI    SWFUNC,WARNING
         LA    MSG,INVFUNC
         MVC   AACTION(L'ASSUM),ASSUM
         BAL   LNK,INVALID
         B     UPDATE
FUNCFULL EQU   *
         OI    SWFUNC,FULL   TABLE IS FULL
         B     RETURN        INDICATE THIS CONDITION AND DON'T UPDATE
TSTNOTBL EQU   *             SEARCH FOR NEXT NONBLANK CHARACTER
         CLI   0(PNT),BLANK
         BNE   IFNUM
         LA    PNT,1(PNT)
         CR    PNT,LIMIT
         BL    TSTNOTBL
         OI    SWFUNC,NOTFOUND
         BR    LNK
RETURN   EQU   *
         AIF   ('&SYS' EQ 'DOS').OVDEL
         L     R15,AGENAST   GET ADDRESS OF AST-ROUTINE
         LTR   R15,R15       TEST IF IT WAS LOADED
         BZ    NODELETE
         DELETE EPLOC=ASTNAME DELETE THE MODUL
NODELETE EQU   *
.OVDEL   ANOP
         L     R1,AKARTE
         AIF   ('&SYS' EQ 'OS').OSXR
         ST    SW,28(R1)     RESTORE DTF EODAD ADDR
*        EXTXR 0,R,MOD=VFM
         EXTXR 0,R,MOD=VFM
         AGO   .IFNUM
.OSXR    ANOP
         ST    SW,DCBEODAD
*        XRETURN 0,R
         XRETURN 0,R
.IFNUM   ANOP
IFNUM    EQU   *
         LR    WK1,PNT       FIRST DIGIT
IFNUM@   CLI   0(PNT),NULL
         BL    IFSTERN       MAY BE AN ASTERISK
         CLI   0(PNT),NEUN
         BH    INVNUM        NON-NUMERIC CHARACTER
         LA    PNT,1(PNT)
         B     IFNUM@
IFSTERN  CR    WK1,PNT
         BNE   GETNUM
         CLI   0(WK1),STERN
         BE    STERNFND      FUNCTION END
         CLI   0(WK1),DOLLAR IS A SUBFORMAT
         BE    STERNFND      YES, FUNCTION CARD END
GETNUM   LR    LEN,PNT
         SR    LEN,WK1
         BCR   13,LNK        IF NOT PLUS, RETURN
         CH    LEN,PACKLIM
         BNL   BIGNUM        NUMBER IS TOO BIG
         BCTR  LEN,0
         EX    LEN,PACK      PACK THE COUNT
         OI    SWFUNC,CNTFOUND
         BR    LNK
INVNUM   EQU   *
         ST    LNK,LNKSAV    SAVE LINK REGISTER
         LA    MSG,INVDIGIT
         OI    SWFUNC,WARNING
         MVI   0(PNT),NULL   SUBSTITUTE  IT BY ZERO
         MVC   AMSGSUB(L'ZERO),ZERO
         MVC   AACTION(L'ASSUM),ASSUM  WRITE COMMENT
         BAL   LNK,INVALID
         L     LNK,LNKSAV    GET RETURN ADDRESS
         BR    LNK           AND GO BACK
BIGNUM   EQU   *
         ST    LNK,LNKSAV    SAVE RETURN ADDRESS
         LA    MSG,TOOBIG    MESSAGE ADDRESS
         OI    SWFUNC,ERR
         MVC   AMSGSUB(L'COUNT),COUNT
         MVC   AACTION(L'IGNOR),IGNOR
         BAL   LNK,INVALID   PUT THE MESSAGE
         L     LNK,LNKSAV
         BR    LNK           RETURN TO CALLING ROUTINE
EODHERE  OI    SWFUNC,WRNGEOD
         B     RETURN
GENAST   EQU   *
         L     R15,AGENAST   GET ADDRESS OF ROUTINE
         LTR   R15,R15       IF IT IS LOADED
         BNZ   LINKAST       BRANCH TO IT
         AIF   ('&SYS' EQ 'OS').OSLO
*        LOAD  BGENAST
         LOAD  BGENAST
         ST    R1,AGENAST    SAVE ENTRY ADDR
         LR    R15,R1        GET IT INTO R 15
         AGO   .LNKAS
.OSLO    ANOP
         LOAD  EPLOC=ASTNAME IF NOT YET PRESENT, LOAD IT
         ST    R0,AGENAST    AND SAVE THE ADDRESS
         LR    R15,R0        GET IT INTO REG
.LNKAS   ANOP
LINKAST  EQU   *
         BALR  R14,R15       LINK TO ROUTINE
         B     GETCARD       AND READ NEXT CARD
PACK     PACK  DW,0(0,WK1)   PACK INSTRUCTION
*
*              INTERNAL CONSTANTS
*
FIX      DC    A(ACARDOUT-AZEILE)
PACKLIM  DC    H'16'
MAXNUM   DC    PL8'+999999999999999'
NOFUNCT  DC    CL20'NO FUNCTION FOUND'
INVFUNC  DC    CL20'UNKNOWN FUNCTION'
INVDIGIT DC    CL20'NON-NUMERIC BYTE'
TOOBIG   DC    CL20'NUMBER IS TOO BIG'
NCOPY    DC    CL4'COPY'
NSKIP    DC    CL4'SKIP'
NBACKSP  DC    CL6'BACKSP'
NREWIND  DC    CL6'REWIND'
NTABLE   DC    C'TABDEF'
NUNLOAD  DC    CL6'UNLOAD'
NWTM     DC    CL3'WTM'
NFAULT   DC    CL5'FAULT'
NDCKS    DC    C'DCKS' .     KEYWORD FOR DATA-CHECKS
ERRMSG   DC    CL12'*** ERROR **'
WRNMSG   DC    CL12'*** WARNING '
CD       DC    C'CARD'
IGNOR    DC    C'IGNORED'
COUNT    DC    C'COUNT'
ASSUM    DC    C'ASSUMED'
ZERO     DC    C'ZERO'
TABMSG   DC    CL20'TABDEF INSUFFICIENT'
TABDEFMS DC    CL20'TABEND MISSING OR INV'
TABFULMS DC    CL20'TABLE FULL, CHECK N'
ASTNAME  DC    CL8'GENAST'   NAME OF AST-PREPERATION ROUTINE
COMMENT  DC    CL2'##'       INDICATOR FOR A COMMENT CARD
         LTORG
*
*              INTERNAL POINTERS AND WORKFIELDS
*              CONTAINED IN THE INTERNAL DUMMY SECTION
*
DUMMY    DSECT
SAVEAREA DS    18F
DW       DC    D'0'          CONVERT WORK FIELD
PNTSAV   DC    F'0'          SAVE-WORD FOR CARD-POINTER
LNKSAV   DC    F'0'          SAVE-WORD FOR LINKREGISTER
AGENAST  DS    F             ADDRESS OF AST-ROUTINE IF LOADED
*
DSEND    DS    0D
PARMLEN  EQU   DSEND-SAVEAREA
         MEND
./ ADD  NAME=GENGET
         MACRO
         GENGET &SYS=OS
         AIF   ('&SYS' EQ 'DOS').COP
         AIF   ('&SYS' EQ 'OS').COP
         MNOTE 12,'SYSTEM NOT SUPPORTED, SPECIFY DOS OR OS'
         MEXIT
.COP     ANOP
         BGENMAC SYS=&SYS
         TITLE ' THIS IS THE LUGENER GET ROUTINE FOR SEQUENTIEL DATA'
*
*              DIESES PROGRAM STELLT DEN NAECHSTEN RECORD ZUR
*              VERFUEGUNG   (  PER 'GET-LOCATE' )
*              ES WIRD IMMER DANN BENUTZT, WENN PER PARAMETER NICHTS
*              ANDERES ANGEGEBEN WURDE.
*
*              AUTHOR: H. FRANZ
*
GENGET   CSECT
         USING MAINPARM,PRM
         USING SVA,R13
         AIF   ('&SYS' EQ 'DOS').NOIHA
         USING IHADCB,WK1
.NOIHA   ANOP
         STM   R14,BAS,12(R13)   SAVE REGISTERS
         LR    BAS,R15       LOAD BASEREG
         USING *-6,BAS
         TM    0(R13),ENDINDIC IS INITIALIZATION ALREADY DONE
         BO    INITOK        YES, BRANCH AROUND INITIALIZATION
         OI    0(R13),ENDINDIC    INDICATE THAT INITIALIZATION IS DONE
         LR    PRM,R1        GET MAINPARM AREA
         LA    R0,PARMLEN
         AIF   ('&SYS' EQ 'OS').OSGM
*        EXTGM R,LV=(0),MOD=VGM
         EXTGM R,LV=(0),MOD=VGM
         AGO   .GMEND
.OSGM    ANOP
*        GETMAIN R,LV=(0)    GET STORAGE FOR SAVEAREA
         GETMAIN R,LV=(0)    GET STORAGE FOR SAVEAREA
.GMEND   ANOP
         XC    0(PARMLEN,R1),0(R1)      CLEAR WORKAREA
         ST    R1,72(R13)    SAVE THIS ADDRESS FOR FURTHER USE
         LA    R0,PARMLEN    GET LENGTH OF THIS AREA
         STH   R0,2(R1)      SAVE THE LENGTH FOR FREEMAIN
         ST    R1,8(R13)     CHAIN THE SAVEAREAS
         ST    R13,4(R1)     CHAIN THE SAVEAREAS
         LR    R13,R1        SET SAVEAREA POINTER TO NEW SVA
         AIF   ('&SYS' EQ 'DOS').NOBLKC
         L     WK1,AINPUT    GET INPUT DCB'S ADDRESS
         TM    SW2,ISORG     IS IT AN ISAM DCB ?
         BZ    NOISAM        NO
         L     R1,ASTRTKEY   WAS A START KEY SPECIFIED ?
         LTR   PNT,R1
         BNP   NOISAM        NO, IGNOR SETL
         SETL  (WK1),KH,1(PNT)  START PROCESSING WITH THIS KEY
NOISAM   EQU   *
         SR    R0,R0         CLEAR THE INPUT BLOCK COUNT
         ST    R0,INPBLKS
         TM    SW2,ISORG     IS ISAM
         BO    DONTEXCH      DO NOT EXCHANGE EOB-ROUTINE ADDRESS
         NC    NORMEOB,NORMEOB
         BNZ   DONTEXCH
         MVC   NORMEOB,DCBEOB
         LA    R0,BLKCNTRT   GET ADDRESS OF OWN EOB-ROUTINE
         ST    R0,DCBEOB     SET IT TO DCB
         ST    PRM,DCBEOB+4  SAVE PARMREG BEHIND DCB             ***
DONTEXCH EQU   *
.NOBLKC  ANOP
         L     R1,4(R13)     GET OLD SAVEAREA'S ADDRESS
         LM    R0,R1,20(R1)  TO RESTORE REGS 0 AND 1
         B     INITOK+4
INITOK   L     R13,72(R13)   GET SAVEAREA FOR THIS PROGRAM
         AIF   ('&SYS' EQ 'DOS').NOPRM
         LR    PRM,R1        LOAD BASE OF PARM-AREA
.NOPRM   ANOP
         L     WK1,AINPUT    ADDRESS OF INPUT - DCB
*        GET   (WK1)         GET THE NEXT RECORD   (LOCATE MODE)
         GET   (WK1)         GET THE NEXT RECORD   (LOCATE MODE)
         AIF   ('&SYS' EQ 'OS').ST1
         LA    WK2,DTFTAB    GET ADDR OF BUILT ENTRY FOR SYS000
         USING DTFTAB,WK2    MUST BE FIRST ENTRY
         CLI   DEVTYPE,C'C'  IS CARD INPUT ?
         BE    CDINP
SAVEANF  EQU   *
         ST    2,INRECANF    REG 2 WAS IOREG IN INPUT DTFS
         CLI   RECFM,C'V'    WAS VARIABLE LENGTH ?
         BE    VAR           IF YES: GET LENGTH FROM RECORD
         MVC   HW,RECL       MOVE FIX RECORD LENGTH FROM DTF ENTRY
         B     GETEND        SKIP MOVING FOR VAR RECS
VAR      MVC   HW,0(2)       MOVE LENGTH CONTAINED IN RECORD
GETEND   AH    2,HW          RECKON END OF RECORD ADDR
         ST    2,INRECEND    SAVE IT AS END ADDR
         DROP  WK2
.ST1     ANOP
         LA    R0,1          ADD ONE
         A     R0,INPRECS    TO
         ST    R0,INPRECS    RECORD COUNT
         AIF   ('&SYS' EQ 'DOS').RET
         ST    R1,INRECANF   SAVE ITS ADDRESS TO RECORD POINTER WORD
         TM    DCBRECFM,X'80'    RECFM = F OR U ?
         BO    FIXORUND      YES, LENGTH IS PROVIDED IN DCBLRECL-FIELD
         MVC   HW,0(R1)      MOVE THE RECORD LENGTH TO A HALFWORD
         AH    R1,HW         AND ADD IT TO RECORD BEGIN ADDRESS
RET      ST    R1,INRECEND   STORE RECORD END ADDRESS
         AIF   ('&SYS' EQ 'OS').XR
.RET     ANOP
*        EXTXR
RETURN   EXTXR
CDINP    EQU   *
         L     2,32(,WK1)    GET BUFFER ADDR FROM DTFCD
         LA    2,0(,2)       SET HIGH ORDER BYTE TO ZERO
         B     SAVEANF
         SPACE 2
         AGO   .XREND
.XR      ANOP
         XRETURN
FIXORUND EQU   *             IF RECFM IS FIX OR UNDEFINED, THE RECORD-
         AH    R1,DCBLRECL   IS PROVIDED IN THE DCBLRECL FIELD
         B     RET
BLKCNTRT EQU   *
         DROP  PRM,WK1
         USING MAINPARM,5    REG 5 IS RELOADED AT ENTRY TO EOB R ***
         USING IHADCB,2      REG 2 POINTS TO DCB IN QSAM MODULES ***
*                            AND AT EXIT FROM SVC 55 (EOV)       ***
*                            WHICH IS TAKEN AT CONCATENATION     ***
         L     5,DCBEOB+4    GET COMMUNICATION VECTOR            ***
         LA    R15,1
         A     R15,INPBLKS
         ST    R15,INPBLKS   STORE COUNT BACK
         L     R15,NORMEOB    GET ADDRESS OF QSAM EOB-ROUTINE
*                            OR QISAM READ ROUTINE
         BR    R15           AND BRANCH TO IT
.XREND   ANOP
WORKAREA DSECT
SVA      DS    18F           SAVEAREA
HW       DS    H           HALFWORD TO ALIGN RECORD-LENGTH IF VARIABLE
DUMEND   DS    0D
PARMLEN  EQU    *-WORKAREA
         MEND
./ ADD  NAME=GENHEAD
         MACRO
         GENHEAD &SYS=OS
         AIF   ('&SYS' EQ 'DOS').COP
         AIF   ('&SYS' EQ 'OS').COP
         MNOTE 12,'SYSTEM NOT SUPPORTED, SPECIFY DOS OR OS'
         MEXIT
.COP     ANOP
         BGENMAC SYS=&SYS,DCB=NO
         TITLE 'BASFGEN HEADER PRINT ROUTINE'
         AIF   ('&SYS' EQ 'OS').GHEAD
BGENHEAD CSECT
         AGO   .USI
.GHEAD   ANOP
GENHEAD  CSECT
.USI     ANOP
         USING AZEILE,WK2
         USING MAINPARM,PRM
         USING *,R15
         ST    R14,HEADSAV   SAVE RETURN ADDRESS
         MVI   ASA,BLANK     CLEAR
         MVC   AFLAG(ALINELEN),ASA     THE OUTPUT LINE
         MVI   ASA,EINS      FORCE NEW PAGE
         MVC   ACARDOUT(IDLEN),PGMID   MOVE PROGRAM IDENTIFICATION
         MVC   AADVERB-10(L'ATIME),ATIME MOVE TIME TO HEADER
         MVC   ASUBJECT-2(L'ADATE),ADATE MOVE DATE TO HEADER
         MVC   AMSGSUB(L'PAGE),PAGE    MOVE 'PAGE'
         L     R1,PAGECNT    GET PAGE COUNT
         LA    R1,1(R1)      ADD ONE
         ST    R1,PAGECNT    STORE IT BACK
         CVD   R1,DMACCU     CONVERT IT
         OI    DMACCU+7,X'0F' FORCE SIGN TO 'F'
         UNPK  AACTION(4),DMACCU+4(4)  UNPK THE COUNT TO LINE
         LA    R1,4           INIT COUNT
         ST    R1,PRTCNT     AND LINE COUNT
         L     R1,ALISTE     GET THE DCB ADDRESS
         PUT   (1),(WK2)
         MVI   ASA,BLANK
         MVC   AFLAG(ALINELEN),ASA     CLEAR LINE
         MVI   ASA,C'-'      SPACE 3 LINES
         L     R1,ALISTE     GET DCB-ADDRESS
         PUT   (1),(WK2)     PUT THE LINE (SPACE)
         MVI   ASA,BLANK
         L     R14,HEADSAV   GET RETURN ADDRESS
         BR    R14           AND RETURN
PGMID    DC    C'BASFGEN - DATA MODIFICATION PROGRAM, '
         DC    C'VERSION 3.0'
         DC    C' 75.060'
IDLEN    EQU   *-PGMID
PAGE     DC    C'PAGE'
         MEND
./ ADD  NAME=GENIMS
         MACRO
         GENIMS &SYS=OS
         AIF   ('&SYS' EQ 'OS').COP
         AIF   ('&SYS' EQ 'DOS').MNOTE
         MNOTE 12,'&SYS  -SYSTEM IS NOT SUPPORTED, SPECIFY OS OR DOS'
         MEXIT
.MNOTE   ANOP
         MNOTE *,'THIS CSECT IS ONLY REQUIRED FOR OS'
         MEXIT
.COP     ANOP
         BGENMAC SYS=&SYS,DCB=NO
         TITLE 'DSECT''S USED WITH DLI'
DBSEGM   DSECT
*              ***   DESCRIPTION OF A DATA-BASE-SEGMENT AFTER READ ***
HEADER   DS    0CL62
SEGNAME  DS    CL8
COKEYLEN DS    H
DATALEN  DS    H
COKEY    DS    CL50
DATA     EQU   *             ORIGINAL DATA IS FOLLWING HEREAFTER
         IDLI  PSTBASE=0,DPCBASE=0,JCBBASE=0,SDBBASE=0,DMBBASE=0
         IDLI  FDBBASE=0
         ISCD  SCDBASE=0
         TITLE 'BASFGEN DATENBANK-LESE-ROUTINE'
GENIMS   CSECT
DMBR     EQU   SW
JCBR     EQU   WK1
SDBR     EQU   FUNC
PCB      EQU   MSG
*
*              DIESES PROGRAMM LIEST DATENBANK-SEGMENTE SEQUENTIELL
*              MIT HILFE VON 'DLI'-CALLS   FUNCTION= GET NEXT
*
*
*              AUTHOR :   H. FRANZ
*
         STM   R14,BAS,12(R13)         SAVE REGISTERS
         LR    BAS,R15       LOAD BASE REG
         USING *-6,BAS
         USING SDB,SDBR
         USING DBPCB,PCB
         USING DMBPSDB,DMBR
         USING JCB,JCBR
         USING AZEILE,WK2
         USING DUMMY,R13
         USING MAINPARM,PRM
         USING DBSEGM,PNT
         TM    0(R13),ENDINDIC         IS INITIALIZATION ALREADY DONE ?
         BO    INITOK                  YES, BRANCH AROUND
         OI    0(R13),ENDINDIC         INDICATE INIT COMPLETED
         LR    PRM,R1                  GET PARM ADDRESS
         LA    R0,PARMLEN              LENGTH OF WORK FIELDS
         GETMAIN R,LV=(0)              GET CORE
         XC    0(PARMLEN,R1),0(R1)     CLEAR WORKFIELDS
         ST    R1,72(R13)              SAVE WORKFIELDS ADDRESS IN HISVA
         LA    R0,PARMLEN              GET LENGTH OF THE WORKFIELDS
         STH   R0,2(R1)                SAVE IT FOR FREEMAIN
         ST    R1,8(R13)               SVA UP CHAIN
         ST    R13,4(R1)               SVA DOWN CHAIN
         LR    R13,R1                  POINT TO NEW SVA
         LA    R0,GETNEXT              POINT TO FUNCTION NAME
         ST    R0,PARMLIST             STORE IT AS FIRST PARM FOR DLI
         L     PCB,PCBAD               GET THE PCB-ADDRESS
         LA    PNT,SCDAD     POINT TO DATA AREA
         CALL  ASMTDLI,(GSCD,(PCB),(PNT)),VL     GET THE ADDRESS OF
*                  SYSTEM CONTENTS DIRECTORY
         L     DMBR,4(PNT) .       GET PST ADDR
         ST    DMBR,PSTSAV .       SAVE THE ADDRESS
         L     PNT,AINBUF              GET INPUT BUFFER'S ADDRESS
         ST    PCB,PARMLIST+4          STORE IT AS SECOND PARM FOR DLI
         LA    R0,DATA-HEADER(PNT)     POINT TO SEGMENT DATA START
         ST    R0,PARMLIST+8           STORE IT AS THIRD PARM FOR DLI
         OI    PARMLIST+8,ENDINDIC     AND INDICATE LAST
         L     LIMIT,ASTRTKEY GET KEY OF FIRST SEGMENT TO BE READ
         LTR   LIMIT,LIMIT   IS ONE ?
         BZ    NOSTART       NO, BEGIN WITH 'GN'
         L     JCBR,DBPCBJCB GET JCB-ADDRESS
         TM    JCBORGN,JCBORGHD        IS DATA BASE HDAM ?
         BNO   *+8           NO, KEYS ARE ASCENDING ORDERED
         MVI   STKEY-1,BLANK KEY MUST BE ASKED FOR EQUAL
         L     SDBR,JCBSDB1  GET FIRST SDB (MUST BE ROOT)
         MVC   SEGNAMB,SDBSYM MOVE SEGMENT NAME TO SSA
         L     DMBR,SDBPSDB  POINT TO PSD
         L     DMBR,DMBFDBA  POINT TO FIELD DESCRIPTOR BLOCK
         DROP  DMBR
         LA    DMBR,0(DMBR)  CLEAR HIGH ORDER BYTE
         LTR   DMBR,DMBR     TEST IF ZERO
         BZ    NOTNAME       IF ZERO, CANNOT BE A VALID FIELD NAME
         USING FDB,DMBR
         TM    FDBDCENF,FDBKEY IS IT A SEGMENTS SEQUENCE FIELD ?
         BZ    NOTNAME       IF ZERO, CANNOT BE A VALID FIELD NAME
         MVC   FELDNAME,FDBSYMBL MOVE FIELD NAME TO SSA
         DROP  DMBR
         SR    R1,R1
         IC    R1,0(LIMIT)   GET LENGTH OF KEY ( - 1 )
         EX   R1,MOVEKEYE    MOVE THE KEY TO SSA
         LA    R1,STKEY+1(R1) POINT TO END OF KEY
         MVI   0(R1),C')'    CLOSE PARENTHESES (SET END OF SSA )
         CALL  ASMTDLI,(GU,(PCB),(R0),SSA),VL
         CLC   DBPCBSTC,DLIOK WAS 'GU' SUCCESSFUL
         BE    SEGOK         YES, GO TO INTERPRETE THE SEGMANT
         MVC   DLIMSG+L'DLIMSG-2(2),GU MOVE FUNCTION TO MESSEGA
         L     WK2,ALIST
         B     MSGMOVE
NOSTART  EQU   *
         L     R1,4(R13)               GET OLD SVA
         LM    R0,R1,20(R1)            RELOAD REGS 0 AND 1
         B     INITOK+4                BRANCH AROUND (R13 ALREADY OK)
INITOK   L     R13,72(R13)             GET SVA OF THIS MODUL
         LR    PRM,R1
         L     WK2,ALIST               POINT TO OUTPUT LINE
         L     PCB,PCBAD     GET THE PCB-ADDRESS
         L     PNT,AINBUF              GET INPUT BUFFER
         L     DMBR,PSTSAV .              GET PST ADDRESS
         L     R15,=V(ASMTDLI)         GET DLI-INTERFACE MODUL
         LA    R1,PARMLIST             POINT TO PARMS
         BALR  R14,R15                 LINK TO DLI INTERFACE
         CLC   DBPCBSTC,DLIOK          WAS THE SEGMENT READ OK ?
         BE    SEGOK                   IF YES, SEGMENT IS OK
         CLC   DBPCBSTC,CHNG1          WAS CHANGE IN HIERARICAL ORDER ?
         BE    SEGOK                   IF YES, SEGMENT IS OK
         CLC   DBPCBSTC,CHNG2          WAS CHANGE IN HIERARICAL ORDER ?
         BE    SEGOK                   IF YES, SEGMENT IS OK
         CLC   DBPCBSTC,ENDDB          WAS END OF DATA-BASE REACHED ?
         BE    DLIEODAD
MSGMOVE  EQU   *
         MVC   ACARDOUT(2),DBPCBSTC    MOVE STATUS CODE TO PRINTLINE
         MVC   ACARDOUT+4(L'DLIMSG),DLIMSG  AND A MESSAGE EXPLAINING
ERRORRET EQU   *
         MVC   AFLAG,DLIERR
         MVI   ASA,NULL
         L     R1,ALISTE               GET PRINT DCB
         PUT   (1),(WK2)               PUT THE MESSAGE
         BAL   LNK,CLRLINE
         SR    R0,R0         CLEAR
         ST    R0,INRECANF   THE FIELDS WHICH INDICATE
         ST    R0,INRECEND   THAT AST CALL IS REQUIRED
         L     R13,4(R13)    SAVE-AREA GENOUT
         L     R13,4(R13)    SAVE-AREA BASFGEN
         LM    R14,BAS,12(R13)  RELOAD REGS
         SR    R15,R15       SET ERROR CODE
         BR    R14           RETURN TO TERMINATE
DLIEODAD EQU   *
         L     R14,IMSEODAD            GET EODAD ADDRESS
         BR    R14                     AND RETURN
SEGOK    EQU   *
         L     R15,INPBLKS
         LA    R15,1(R15)
         ST    R15,INPBLKS
         ST    R15,INPRECS
         USING PST,DMBR
         L     DMBR,PSTSAV .          GET PST ADDRESS
         L     R0,PSTSEGL .           GET DATA LENGTH
         STH   R0,DATALEN              BRING IT TO BUFFER
         L     R0,DBPCBMKL             LENGTH OF CONCATENATED KEY
         STH   R0,COKEYLEN             BRING IT TO BUFFER
         BCTR  R0,0                    REDUCE IT BY ONE
         LR    LEN,R0                  LENGTH OF COKEY READY TO EX
         MVI   COKEY,BLANK             BLANK OUT THE KEY-FIELD
         MVC   COKEY+1(L'COKEY-1),COKEY
         EX    LEN,MOVEKEY             MOVE IN THE NEW KEY
         MVC   SEGNAME,DBPCBSFD        MOVE IN THE SEGMENT NAME
         ST    PNT,INRECANF            SET POINTER TO INPUT RECORD
         LH    LEN,DATALEN             GET THE LENGTH OFF THE DATA SEGM
         LA    LEN,DATA-DBSEGM(LEN,PNT)  POINT TO END OF RECORD
         ST    LEN,INRECEND            AND SET THE POINTER
         L     R13,4(R13)              GET HIGH SVA
         LM    R14,BAS,12(R13)         RELOAD REGS
         BR    R14                     AND RETURN
NOTNAME  EQU   *
         MVC   ACARDOUT(L'SSAMSG),SSAMSG
         B     ERRORRET
MOVEKEY  MVC   COKEY(0),DBPCBKFD       MOVE THE KEY
MOVEKEYE MVC   STKEY(0),1(LIMIT)
CLRLINE  EQU   *
         MVI   ASA,BLANK
         MVC   AFLAG(ALINELEN),ASA
         BR    LNK
*
*              ***   C O N S T A N T S   ***
*
STATCODE DS    0F
DLIOK    DC    CL2' '
CHNG1    DC    CL2'GA'
CHNG2    DC    CL2'GK'
ENDDB    DC    CL2'GB'
GETNEXT  DC    CL4'GN'
GU       DC    CL4'GU'
GSCD     DC    CL4'GSCD'     GET SYSTEM CONTENTS DIRECTORY
NOSDB    DC    C'NO SDB FOUND WITH NAME : '
DLIERR   DC    CL12'*** ERROR **'
DLIMSG   DC    C'UNEXPECTED STATUS-CODE WITH DLI-FUNC = GN'
SSAMSG   DC    C'UNABLE TO CREATE SSA'
SSA      EQU   *
SEGNAMB  DC    CL8' '
         DC    C'('
FELDNAME DC    CL8' '
         DC    C'=>'
STKEY    DC    CL50' '
         LTORG
DUMMY    DSECT
SVA      DS    18F
PARMLIST DS    0F
         DS    3F
SCDAD    DS    2F
PSTSAV   DS    F .           POINTER TO PST IF SAVED HERE
DUMEND   DS    0D
PARMLEN  EQU   DUMEND-DUMMY
         MEND
./ ADD  NAME=GENINPUT
         MACRO
         GENINPUT &SYS=OS
         AIF   ('&SYS' EQ 'DOS').COP
         AIF   ('&SYS' EQ 'OS').COP
         MNOTE 12,'SYSTEM NOT SUPPORTED, SPECIFY DOS OR OS'
         MEXIT
.COP     ANOP
         BGENMAC SYS=&SYS
         TITLE 'BASFGEN INPUT ROUTINE'
GENINPUT CSECT
*
*              DIESES PROGRAMM LIEST UND INTERPRETIERT DIE
*              EINGABE FUER 'LUGENER'.
*
*              AUTHOR: H. FRANZ
*
         USING MAINPARM,PRM
         AIF   ('&SYS' EQ 'OS').OSXS
*        EXTXS BAS,,GENIPUT,PARMLEN+72,TYP=F,MOD=VGM
         EXTXS BAS,,GENIPUT,PARMLEN+72,TYP=F,MOD=VGM
         AGO   .OVXS
.OSXS    ANOP
*        XSAVE BAS,,GENINPUT,PARMLEN+72
         XSAVE BAS,,GENINPUT,PARMLEN+72
         LR    PRM,1
.OVXS    ANOP
         USING SAVEAREA,R13
         XC    SAVEAREA+72(PARMLEN),SAVEAREA+72
         MVI   SWIPRT1,0               CLEAR INTERPRETATION SWITCHES
         MVI   SWIPRT2,0
         MVI   SWFUNC,0                CLEAR SWITCH FOR FUNCTIONS
         MVI   SW3,0         CLEAR SWITCH
         SR    R0,R0         CLEAR REG
         ST    R0,NEWPAGE    AND FIELD FOR 'COUNT-FORMAT'
         NI    SW4,IRECFMV+ORECFMV     CLEAR ALL OTHER CONDITIONS
         NI    SWINPUT,EODADIN         CLEAR SWITCH FOR SYSIN-INPUT
         BNZ   WRONGEOD
         L     WK2,ALIST
         USING AZEILE,WK2
         L     R15,MAXLINES  FORCE NEW PAGE
         ST    R15,PRTCNT
         L     R1,AKARTE
         AIF   ('&SYS' EQ 'OS').IHAD
         LA    R0,LASTCARD   GET EODAD ADDR IN THIS PROGRAM
         ST    R0,28(R1)     EODAD ADDRESS IN DTFCD
         AGO   .DAT
.IHAD    ANOP
         USING IHADCB,R1
         IC    WK1,DCBBFTEK            SET THE
         LA    R0,LASTCARD             NEW
         ST    R0,DCBEODAD             EODAD-ADDRESS
         STC   WK1,DCBBFTEK            AND RESTORE BUFFER BYTE
.DAT     ANOP
         LA    R0,ATIME      POINT TO TIME FIELD
         LA    R1,ADATE      POINT TO DATE FIELD
         STM   R0,R1,PRMLUDAT STORE ADDRESSES TO PARM LIST
         OI    PRMLUDAT+4,ENDINDIC INDICATE END OF PARMLIST
         LA    R1,PRMLUDAT   POINT TO PARM-LIST
         AIF   ('&SYS' EQ 'OS').OSDATE
         L     R15,TDATE     LOAD TDATE ENTRY POINT
         AGO   .BALR
.OSDATE  ANOP
         L     R15,=V(TDATE)
.BALR    ANOP
         BALR  R14,R15       LINK TO DATE CONVERSION RO UTINE
         BAL   LNK,CLEARLIN  CLEAR THE OUTPUT-LINE
GETCARD  L     R1,AKARTE
         L     PNT,ACARD
*        GET   (1),(PNT)               GET A CARD FROM SYSIN
         GET   (1),(PNT)               GET A CARD FROM SYSIN
         BAL   LNK,CLEARL    CLEAR THE LINE
         LA    R0,1          COUNT THE
         A     R0,SYSINCDS   SYSIN CARDS
         ST    R0,SYSINCDS   IN COMMON COUNT FIELD
         CLC   COMMENT,0(PNT) IS THIS A COMMENT CARD
         BE    PUTCARD       IF YES, DON'T INTERPRETE IT
         LA    R0,1          AND IN A
         A     R0,CARDCNT    SPECIAL FIELD
         ST    R0,CARDCNT    ONLY USED IN THIS ROUTINE
         TM    SWFUNC,FUNCEND IF FUNCTIONS ARE COMPLETE
         BO    NOWACTN2      GO TO INTERPRETATION ROUTINE
TSTAGAIN EQU   *
         CLI   0(PNT),STERN  WAS A STAR
         BE    NOPUT         YES, CANNOT BE A FUNCTION
         CLI   0(PNT),DOLLAR WAS A SUB-FORMAT ?
         BE    NOPUT         YES, CANNOT BE A FUNCTION
         CLI   0(PNT),BLANK
         BNE   PUTCARD       A FUNCTION WAS FOUND
         LA    PNT,1(PNT)    POINT TO NEXT BYTE
         CR    LIMIT,PNT     IS END OF CARD REACHED
         BNL   TSTAGAIN      TEST ONCE MORE
PUTCARD  EQU   *
         L     PNT,ACARD     SET THE POINTER BACK
         MVC   ACARDOUT,0(PNT)         AND PUT IT ON THE MESSAGE
         L     R1,ALISTE               DATASET
*        PUT   (R1),(WK2)
         PUT   (R1),(WK2)
         BAL   LNK,CLEARL              CLEAR THE OUTPUT LINE
         CLC   COMMENT,0(PNT)  IS IT A COMMENT CARD ?
         BE    COMMCARD       IGNOR PROSSESSING
NOPUT    EQU   *
         AIF   ('&SYS' EQ 'OS').LINK
         LA    R14,AFETCH6   GET RETURN ADDRESS FROM FETCH ROUTINE
*        FETCH BGENFUNC
         FETCH BGENFUNC
AFETCH6  EQU   *
         AGO   .TSTFNC
.LINK    ANOP
         LR    R1,PRM
*        LINK EP=GENFUNC
         LINK EP=GENFUNC
.TSTFNC  ANOP
         TM    SWFUNC,WRNGEOD
         BO    RETURN
         TM    SWINPUT,ERR
         BO    RETURN
         TM    SWFUNC,FULL             IS THE TABLE FULL
         BO    TABLEFUL
         LA    R0,PLENGTH
         ST    R0,PLENGA
*
*              NOW LOAD THE SUBROUTINES NEEDED
*
         AIF   ('&SYS' EQ 'OS').OSLOAD
*        LOAD  BGENBLEX
         LOAD  BGENBLEX
         ST    R1,ABLANKEX   SAVE ADDR OF BLANKEX
*        LOAD  BGENIPRT
         LOAD  BGENIPRT
         ST    R1,AGENIPRT   SAVE ADDR OF INTERPRET ROUTINE
         AGO   .ELOAD
.OSLOAD  ANOP
*        LOAD  EP=BLANKEX              BLANK DELETION AND FIRST TESTS
         LOAD  EP=BLANKEX              BLANK DELETION AND FIRST TESTS
         ST   R0,ABLANKEX
*        LOAD  EP=GENIPRT             &--AT &NTE---ETAT&N
         LOAD  EP=GENIPRT              FORMAT INTERPRETATION
         ST   R0,AGENIPRT
.ELOAD   ANOP
*
NOWACTN  EQU   *                       NO, END OF FUNCTIONS REACHED
         L     R0,ACARD
         ST    R0,PINPUT               INITIALIZE PARAMETERS FOR
         ST    R0,POUTPUT              FORMAT INTERPRETATION
*
NOWACTN2 EQU   *
         LA    R0,CARDLEN
         ST    R0,PLENGTH              LINK TO BLANK-DELETION ROUTINE
         LA    R1,PRMBLKEX
         L     R15,ABLANKEX
         BALR  R14,R15
         B     *+4(R15)
         B     BLANKOK                 VARIABLE BRANCH
         B     LENGFAIL                LIST
         B     DILIMMIS
WRONGEOD EQU   *
         OI    SWFUNC,WRNGEOD
         B     RETURN
COMMCARD EQU   *
         BAL   LNK,CLEARLIN   CLEAR THE OUTPUT LINE AND COUNT
         B     GETCARD        GO TO READ NEXT CARD
TABLEFUL EQU   *                       FUNCTION TABLE IS FULL
         TM    SWINPUT,FULLIND         IS THE ERROR MESSAGE
         BO    GETCARD                 ALREADY WRITTEN
         BAL   LNK,CLEARLIN            IF YES, DON'T WRITE AGAIN
         MVC   AFLAG,ERRMSGIN          MOVE THE MESSAGE TO OUTPUT-LINE
         MVC   ACARDOUT(L'FULLMSG),FULLMSG
         L     R1,ALISTE
*        PUT   (R1),(WK2)              AND PUT THE LINE
         PUT   (R1),(WK2)              AND PUT THE LINE
         OI    SWINPUT,FULLIND         INDICATE WRITTEN MESSAGE
         B     GETCARD
LENGFAIL EQU   *                       LENGTH ERROR IN BLANKEX
         AIF   ('&SYS' EQ 'OS').OSABEND
         LA    0,X'100'      LOAD USER ABEND INTO REG 0
*        DUMP
         DUMP
         AGO   .DILS
.OSABEND ANOP
*        ABEND 100,DUMP                SHOULD NOT OCCUR
         ABEND 100,DUMP                SHOULD NOT OCCUR
.DILS    ANOP
DILIMMIS EQU   *                       ODD NUMBER OF APOSTROPHES
         BAL   LNK,CLEARLIN
         MVC   AFLAG,ERRMSGIN          MOVE THE MESSAGE
         MVC   ACARDOUT(L'ODDMSG),ODDMSG
         L     R1,ALISTE
*        PUT   (R1),(WK2)              AND PUT IT
         PUT   (R1),(WK2)              AND PUT IT
         BAL   LNK,CLEARLIN
         OI    SWINPUT,ERR             INDICATE ERROR CONDITION
         B     GETCARD
BLANKOK  EQU   *                       BLANKEX RETURN WITHOUT ERRORS
         LR    R1,PRM
         L     R0,PLENGTH    GET LENGTH FO DATA ON CARD
         L     R15,AGENIPRT
         BALR  R14,R15                 LINK TO INTERPRETATION ROUTINE
         TM    SWIPRT1,FMTEND
         BZ    GETCARD
END1RUN  EQU   *
         AIF   ('&SYS' EQ 'DOS').OVDEL
*        DELETE EP=BLANKEX             DELETE
         DELETE EP=BLANKEX             DELETE
*        DELETE EP=GENIPRT             SUB-ROUTINES
         DELETE EP=GENIPRT             SUB-ROUTINES
.OVDEL   ANOP
         TM    SWIPRT1,ERR   WAS AN ERROR DURING INTERPRETATION ?
         BO    RET44         YES, RETURN TO MAIN PROGRAM
         L     R1,AIPRTSVA   GET START ADDRESS OF WORKAREA 'GENIPRT'
         LH    R0,2(R1)      AND ITS LENGTH
         AIF   ('&SYS' EQ 'OS').OSFM1
*        EXTFM R,LV=(0),A=(1),MOD=VFM
         EXTFM R,LV=(0),A=(1),MOD=VFM
         AGO   .EFM1
.OSFM1   ANOP
*        FREEMAIN R,LV=(0),A=(1)  AND FREE THAT AREA
         FREEMAIN R,LV=(0),A=(1)  AND FREE THAT AREA
         LR    R1,R13        GET ADDRESS OF OWN SAVEAREA
         LH    R0,2(R1)      AND ITS LENGTH
         L     R13,4(R13)    SAVE THE ADDRESS OF MAINROUTINE'S SAVEAREA
*        FREEMAIN R,LV=(0),A=(1)  AND FREE THAT AREA
         FREEMAIN R,LV=(0),A=(1)  AND FREE THAT AREA
         TM    SW2,IMSORG    IS DLI REQUIRED ?
         BO    IMSEXIT       YES, EXIT TO DLI CONTROL PROGRAM
         LR    R1,PRM        GET POINTER TO PARMAREA
         L     R14,12(R13)   LOAD CORRECT RETURN ADDRESS
         AGO   .XCTL
.EFM1    ANOP
*        LOAD  BGENSTAT
         LOAD  BGENSTAT
         LA    R14,AFETCH7   GET RETURN ADDRESS FROM FETCH ROUTINE
*        FETCH BGENOUT
         FETCH BGENOUT
AFETCH7  EQU   *
         B     RET           KEEP CODE FROM BGENOUT AND RETURN
         AGO   .LSTCD
.XCTL    ANOP
*        XCTL (2,12),EP=GENOUT TRANSFER CONTROL TO OUT PUT ROUTINE
         XCTL (2,12),EP=GENOUT TRANSFER CONTROL TO OUT PUT ROUTINE
IMSEXIT  EQU   *
*        LOAD  EP=GENSAVE .  LOAD A REUSABLE MODUL TO SAVE PARM POINTER
         LOAD  EP=GENSAVE .  LOAD A REUSABLE MODUL TO SAVE PARM POINTER
         LR    R15,R0 .      GET THE ADDRESS
         USING GENSAVE,R15
         ST    PRM,PARMADR . STORE ADDRESS OF COMMUNICATION VECTOR
*                            FOR IMS WILL DESTROY ALL REGS
*                            AND REQUIRES FIRST SAVEAREA FOR OWN USE
         LR    R14,R13 .     GET ADDRESS OF MAIN SAVEAREA
PREVSVA  EQU   * .           SEARCH FIRST SAVE AREA
         LR    R1,R14 .      SET REG 1 TO IT
         L     R14,4(R1) .   GO BACK IN CHAIN
         LTR   R14,R14 .     IS A PREVIOUS ONE ?
         BNZ   PREVSVA .     YES, GO FURTHER BACK
FIRSTSVA EQU   * .           REG 1 POINTS TO FIRST SVA (TCBSVA-POINTER)
         XC    12(60,R1),12(R13) EXCHANGE THE SAVE AREAS
         XC    12(60,R13),12(R1) EXCHANGE THE SAVE AREAS
         XC    12(60,R1),12(R13) EXCHANGE THE SAVE AREAS
         XC    8(4,R1),8(R1) CLEAR CHAIN
         ST    R13,4(R1) .   EXCHANGE CHAIN ADDRESS
         ST    R1,8(R13) .   EXCHANGE CHAIN ADDRESS
         LR    R13,R1 .      SET R13 SAVE AREA POINTER
         L     R14,12(R13)   GET CORRECT RETURN ADDRESS
         LA    R1,AINPUT     POINT TO PARMS AS IF FROM EXEC CARD
         ST    R1,24(R13)     SET REG 1 TO PARMS FOR DLI
*        XCTL  (2,12),EP=DFSRRC00      TRANSFER CONTROL TO DLI
         XCTL  (2,12),EP=DFSRRC00      TRANSFER CONTROL TO DLI
.LSTCD   ANOP
*
LASTCARD OI    SWINPUT,EODADIN         INDICATE END OF SYSIN INPUT
         L     R0,CARDCNT    GET THE CARD COUNT
         LTR   R0,R0         HAVE CARDS BEEN READ ?
         BZ    RET4          NORMAL END
         B     END1RUN       DELETE SUBPROGRAMS AND DO THE WORK
RET4     EQU   *
         SR    R0,R0         CLEAR REG AND PRTCNT
         ST    R0,PRTCNT     TO PREVENT NEW PAGE FOR END MESSAGE
         BAL   LNK,CLEARLIN  CLEAR THE OUTPUT LINE
         BAL   LNK,ENDLINE
         LA    R15,4         SET CODE FOR NORMAL RETURN
         AIF   ('&SYS' EQ 'OS').OSXR
*ET      EXTXR (R15),R,MOD=VFM
RET      EXTXR (R15),R,MOD=VFM
         AGO   .RET
.OSXR    ANOP
*ET      XRETURN (R15),R     AND RETURN TO MAINROUTINE
RET      XRETURN (R15),R     AND RETURN TO MAINROUTINE
.RET     ANOP
RETURN   EQU   *
         BAL   LNK,CLEARLIN
         BAL   LNK,ENDLINE
RET44    EQU   *
         SR    R15,R15       SET CODE TO 0
         B     RET
CLEARLIN EQU   *
         L     R15,PRTCNT    GET LINE COUNT
         LA    R15,1(R15)    ADD ONE
         ST    R15,PRTCNT    STORE IT BACK
         C     R15,MAXLINES  IS MAXIMUM REACHED ?
         BL    CLEARL        NO, GO TO CLEAR THE LINE
         L     R15,AHEADPRT  GET HEADER PRINT ROUTINE'S ADDRESS
         BALR  R14,R15       AND LINK TO IT
CLEARL   EQU   *
         MVI   ASA,BLANK
         MVC   AFLAG(ALINELEN),ASA
         BR    LNK
ENDLINE  EQU   *
         MVC   AFLAG(L'ENDMSG),ENDMSG  PUT AN END MESSAGE
         L     R0,SYSINCDS   GET NUMBER OF CARDS
         CVD   R0,DW         CONVERT COUNT TO DECIMAL
         OI    DW+7,15       FORCE SIGN TO 'F'
         UNPK  AFLAG+L'ENDMSG(8),DW    UNPACK THE COUNT TO OUTPUTLINE
         L     R1,ALISTE     PROTOKOLL-DCB
*        PUT   (1),(WK2)     PUT THE LINE
         PUT   (1),(WK2)     PUT THE LINE
         BR    LNK
FULLMSG  DC    C'FUNCTION-TABLE IS FULL, INCREASE POWER'
ENDMSG   DC    C'EODAD FROM SYSIN, NUMBER OF INPUT CARDS = '       '
ODDMSG   DC    C'ODD NUMBER OF APOSTROPHES ON CARD ABOVE, INTERPRETATIO*
               N IMPOSSIBLE'
ERRMSGIN DC    CL12'*** ERROR **'
COMMENT  DC    CL2'##'
         AIF   ('&SYS' EQ 'OS').OSDEF
TDATE    DC    V(BGENDATE)   OS LIKE TDATE FUNCTION
.OSDEF   ANOP
         LTORG
DUMMY    DSECT
SAVEAREA DS    18F
AIPRTSVA DS    F             ADDRESS OF SAVE AREA FOR 'GENIPRT'
ABLANKEX DC    F'0'
AGENIPRT DC    F'0'
PLENGTH  DC    F'0'
DW       DS    0D            DOUBLEWORD USED TO CONVERSION AT THE END
PRMBLKEX EQU   *
PRMLUDAT EQU   PRMBLKEX
PINPUT   DC    F'0'
POUTPUT  DC    F'0'
PLENGA   DS    F
CARDCNT  DS    F             COUNT THE INPUT CARDS READ IN THIS ROUTINE
DSEND    DS    0D
PARMLEN  EQU   DSEND-SAVEAREA-72
GENSAVE  DSECT
         GENSAVE
         MEND
./ ADD  NAME=GENIPRT
         MACRO
         GENIPRT &SYS=OS
         GBLB  &IPRT
         LCLB  &S,&SD
&S       SETB  ('&SYS' EQ 'OS')
&SD      SETB  ('&SYS' EQ 'DOS')
         AIF   (&S OR &SD).COP
         MNOTE 12,'SYSTEM NOT SUPPORTED, SPECIFY DOS OR OS'
         MEXIT
.COP     ANOP
&IPRT    SETB  1
         BGENMAC SYS=&SYS
         TITLE '  INTERPRETATION DER EINGABE-FORMAT-KARTEN'
GENIPRT  CSECT
*
*              AUTHOR: H. FRANZ
*
*              FORMAT-KARTEN
*              INTERPRETATIONS-PROGRAMM FUER 'BASFGEN'
*
         B     12(0,R15)
         DC    X'07'
         DC    CL7'GENIPRT'  PROGRAM NAME
         STM   R14,BAS,12(R13)  SAVE REGISTERS
         LR    BAS,R15       LO AD BASE REG
         USING *-18,BAS
         TM    0(R13),X'80'  IS WORK AREA INITIALIZED ?
         BO    INITOK        YES
         LR    PRM,R1        GET BASE OF PARMLIST
         USING MAINPARM,PRM
         OI    0(R13),X'80'  NO, INDICATE THAT NOW IT IS
         LA    R0,PARMLEN    GET LENGTH OF WORKAREA
         AIF   (&S).OSGM1
*        EXTGM R,LV=(0),MOD=VGM
         EXTGM R,LV=(0),MOD=VGM
         AGO   .OVGM1
.OSGM1   ANOP
*        GETMAIN R,LV=(0)    GET CORE FOR WORK AREA
         GETMAIN R,LV=(0)    GET CORE FOR WORK AREA
.OVGM1   ANOP
         XC    0(3*4,R1),0(R1)
         ST    R1,72(R13)    SAVE THE ADDRESS OF THIS AREA IN CALLING
         LA    R0,PARMLEN                        PROGRAMS SAVEAREA
         STH   R0,2(R1)      SAVE ITS LENGTH AT START-ADDRESS
         ST    R13,4(R1)     CHAIN THE SAVEAREAS
         ST    R1,8(R13)     CHAIN THE SAVEAREAS
         LR    R13,R1        SET SAVEAREA REG TO NEW SAVEAREA
         USING SAVEAREA,R13
         L     FUNC,AFORMAT  BEGIN OF FORMAT-TABLE
         ST    FUNC,AFORMAT@ STORE IT TO ACTUAL POINTER
         L     SW,AACTIONS   BASE FOR FORMAT-ENTRIES
         XC    0(8,SW),0(SW)    CLEAR FIRST TWO ENTRIES
         LA    SW,4(SW)      AND SPARE THE FIRST ONE
         ST    SW,AACTIONS   FOR EVER (MIGHT CAUSE ERRORS, IF COMPARE
*                            IS IN A SUB-FORMAT)
         ST    SW,ACTION@    STORE IT TO ACTUAL POINTER
         LA    R0,INDEX .    *
         ST    R0,PARM3+8 .  **
         ST    R0,PARM4+8 .  * *
         ST    R0,PARM5+8 .  *  *
         LA    R0,LFP3 .     *   *     INITIALIZE PARM-LISTS
         ST    R0,PARM3 .    *    *
         LA    R0,LFP4 .     *     *   FOR LFDNR
         ST    R0,PARM4 .    *    *
         LA    R0,LFP5 .     *   *     ONE LIST PER TABLE
         ST    R0,PARM5 .    *  *
         MVC   LFP4,P4 .     * *
         MVC   LFP3,P3 .     **
         MVC   LFP5,P5 .     *
         LA    R1,DW         INITIALIZE TABLES FOR SEARCH-PROCESSING
         L     R15,ALFDNRD         GET ADDRESS OF DEFINITION ROUTINE
         L     R0,ATAB3      GET TABLE ADDRESS
         ST    R0,DW         STORE IT TO PARMLIST FOR LFDNRDEF
         LA    R0,LFP3       GET TABLE DEPENDENT PARMAREA
         ST    R0,DW+4       STORE IT TO TABLE DEPENDENT PARMAREA
         L     R0,ATAB4      GET TABLE ADDRESS
         BALR  14,15         LINK TO 'LFDNRDEF' - SUBROUTINE
         ST    R0,DW         STORE IT TO PARMLIST FOR LFDNRDEF
         LA    R0,LFP4       GET TABLE DEPENDENT PARMAREA
         ST    R0,DW+4       STORE IT TO TABLE DEPENDENT PARMAREA
         BALR  14,15         LINK TO 'LFDNRDEF' - SUBROUTINE
         L     R0,ATAB5      GET TABLE ADDRESS
         ST    R0,DW         STORE IT TO PARMLIST FOR LFDNRDEF
         LA    R0,LFP5       GET TABLE DEPENDENT PARMAREA
         ST    R0,DW+4       STORE IT TO TABLE DEPENDENT PARMAREA
         BALR  14,15         LINK TO 'LFDNRDEF' - SUBROUTINE
         L     R1,4(R13)     GET OLD SAVEAREA
         LM    R0,R1,20(R1)  TO RELOAD R0 AND R1
         B     INITOK+4
INITOK   L     R13,72(R13)   GET THE NEW SAVEAREA WORK FIELDS
         AIF   (&SD).PRMOK
         LR    PRM,R1        BASE FOR COMMUNICATION-VEKTOR
.PRMOK   ANOP
         XC    IPRTTAB(256),IPRTTAB     CLEAR TRANSLATE-TABLE
         L     WK2,ALIST     BASE FOR OUTPUTLINE
         USING AZEILE,WK2
         L     FUNC,AFORMAT@ BASE FOR FORMAT-TABLE
         USING FMTDSECT,FUNC
         L     SW,ACTION@    GET ACTUAL POINTER FOR ACTIONS
         SR    2,2           CLEAR REG FOR 'TRT' - PROCESSING
         L     PNT,ACARD     GET POINTER TO CARD
         LR    LEN,R0
         LA    WK1,CARDLEN   CARD-LENGTH TO BE INTERPRETED
         SR    WK1,R0        SUBTRACT LENGTH OF FORMAT-SPECIFICATIONS
         BZ    NOCLEAR       IF CARD WAS FULL, PREVENT CLEARING
         AR    PNT,R0        SET POINTER OVER SPECIFICATIONS
         BCTR  WK1,0         REDUCE LENGTH
         MVI   0(PNT),BLANK  BEGIN TO CLEAR REST OF THE CARD
         BCTR  WK1,0         REDUCE ONCE MORE
         LTR   WK1,WK1       SOMETHING LEFT ?
         BNP   NOCLEAR       NO, ALL DONE
         EX    WK1,MVCBLANK  BLANK REST OF THE CARD
NOCLEAR  EQU   *
         L     PNT,ACARD     SET CARD POINTER BACK TO CARD BEGIN
         BAL   LNK,CLEARLI#   CLEAR THE OUTPUTLINE
         MVC   ACARDOUT,0(PNT) MOVE THE COMPRESSED CARD IMAGE TO LINE
         MVC   AFLAG(L'COMPRES),COMPRES  INDICATE CHANGED FORMAT
         CLI   0(PNT),STERN  IS A NEW FORMAT ?
         BE    SPACE         SPACE ONE LINE
         CLI   0(PNT),DOLLAR IS A NEW SUB-FORMAT ?
         BNE   PUTSO         NO, DON'T SPACE
SPACE    EQU   *
         MVI   ASA,NULL      2 LINES CARRIAGE
         L     R15,PRTCNT    GET THE LINE COUNT
         LA    R15,1(R15)     ADD ONE
         ST    R15,PRTCNT    STORE IT BACK
PUTSO    EQU   *
         BAL   LNK,PUTLINE   PUT  R THE OUTPUT LINE
         LTR   LEN,LEN
         BP    BEGIN         IF THERE ARE ANY, INTERPRET THEM
         OI    SWIPRT1,NOFORMAT
         AIF   (&S).OSRET1
*        EXTXR
RET      EXTXR
         AGO   .ERET1
.OSRET1  ANOP
*ET      XRETURN
RET      XRETURN
.ERET1   ANOP
OR       DC    C'OR'
P3       DC    AL2((T3END-T3ANF)/10,10,1,3)  *
P4       DC    AL2((T4END-T4ANF)/10,10,1,4)  *    PARMS FOR LFDNR
P5       DC    AL2((T5END-T5ANF)/10,10,1,5)  *
COMPRES  DC    C'COMPRESSED'
         DS    0H            GET CORRECT BOUNDARY
IFOR     EQU   *
         CLC   DO,0(PNT)     WAS 'DO' ?
         BE    DOFND         YES
         CLC   OR,0(PNT)     WAS 'OR' ?
         BNE   INVEQUAL      NO, INVALID
         MVC   INDEX,=AL2((ODER-TAB4T)/10+1) SIMULATE PRESENCE OF ODER
         L     LNK,ATAB4     GET TABLE ADDRESS
         B     KEYFND
TAB3     LA    R1,PARM3      GET PARM-ADDRESS
         L     LNK,ATAB3     GET TABLE ADDRESS
         ST    PNT,PARM3+4
LFDNRCAL EQU   *
         L     R15,ALFDNR    AND LINK
         BALR  14,15         TO SEARCH-PROGRAM
         B     KEYFND
TAB4     LA    R1,PARM4      GET PARM-ADDRESS
         L     LNK,ATAB4     GET TABLE ADDRESS
         ST    PNT,PARM4+4
         B     LFDNRCAL      GO TO SEARCH-ROUTINE
TAB5     LA    R1,PARM5      GET PARM-ADDRESS
         L     LNK,ATAB5     GET TABLE ADDRESS
         ST    PNT,PARM5+4
         B     LFDNRCAL      GO TO SEARCH-ROUTINE
KEYFND   EQU   *
         LH    WK1,INDEX     GET INDEX
         LTR   WK1,WK1       WAS ELEMENT IN TABLE ?
         BZ    INVEQUAL      NO, INDICATE THAT CONDITION
         BCTR  WK1,0         TABLE-POSITION MINUS 1
         MH    WK1,P3+2            * 12
         AR    WK1,LNK       ADD BASE OF TABLE
         MVC   FMTCODE,08(WK1) EXECUTION-ADDRESS
         MVC   DMACCU+1(3),5(WK1)      ALIGN ADDRESS OF FURTHE RINTERPR
         L     LNK,DMACCU    GET THE ADDRESS TO REG
         BR    LNK           GO ON
KOMMAWAS EQU   *
EQUALWAS EQU   *
         LA    R0,1(R1)
         ST    R0,PNTSAV
         SR    R0,PNT
         SR    LEN,R0        REMAINING LENGTH
         SR    R1,PNT        LENGTH OF KEYWORD
         BZ    STARMAYB      STAR MAY BE POSSIBLE HERE
         CH    R1,=H'5'      WAS KEYWORD LONGER THAN 5 CHARACTERS ?
         BH    INVEQUAL      YES, MUST BE WRONG
         SLL   R1,2          * 4
         B     *(R1)         FOR VARIABLE BRANCH
         B     INVEQUAL      KEYWORD WITH LENGTH = 1 NOT VALID
         B     IFOR          WAS 'OR' ?
         B     TAB3          KEY-LENGTH WAS 3
         B     TAB4          KEY-LENGTH WAS 4
         B     TAB5          KEY-LENGTH WAS 5
STARMAYB EQU   *             KEYWORD-LENGTH 0 WAS DETECTED
         LR    R1,PNT        FOR CORRECT UPDATE AT STERNWAS
         BCTR  LEN,0         REDUCE LENGTH REG BY ONE            ***
         CLI   0(PNT),STERN  WAS A STAR
         BE    STERNWAS
INVEQUAL EQU   *
         MVC   ASUBJECT(7),=C'KEYWORD'
         LR    R1,PNT        TO GET POINTER CORRECT PLACED
INVINV   EQU   *
         MVC   AADVERB,=C'INVALID'
         B     INVPUT
INVALID3 EQU   *
         MVC   ASUBJECT,=C'CHARACTER'
         MVC   AADVERB,=C'INVALID'
         B     INVPUT
INVALID1 EQU   *
         MVC   AADVERB,=C'INVALID'
         B     INVDLM
INVALID2 EQU   *
         LA    R1,0(LEN,PNT) SET POINTER TO END OF TRSTED STRING
         MVC   AADVERB,=C'MISSING'
INVDLM   EQU   *
         MVC   ASUBJECT,=C'DELIMITER'
INVALID  EQU   *
         LA    R0,1(R1)       SET OVER CHARACTER FOUND
         ST    R0,PNTSAV      SAVE POINTER FOR NEXT TRT
         SR    R0,PNT
         SR    LEN,R0         REMAINING LENGTH
INVPUT   EQU   *
         S     R1,ACARD      R1 = RELATIVE ERROR POSITION ON CARD
         LA    R1,ACARDOUT-AZEILE(R1)  ADD FIX PART OF THE OUTPUTLINE
         A     R1,ALIST       ADD OUTPUT LINE ADDRESS
         MVI   0(R1),POINTER  SET INDICATOR
PUTMSG   EQU   *
         NI    SWTAB,255-TABINTPT-COMPAC-COMPAC2 CLEAR THE SWITCHES
         NI    SW2,255-SCANIS CLEAR THE SWITCH SCAN MIGHT BE PROCESSED
         OI    SWIPRT1,ERR    SET ERROR SWITCH
         MVC   AFLAG,ERRMSG  SET AN OBVIOUS ERROR INDICATION
         BAL   LNK,PUTLINE   PUT THE MESSAGE AND CLEAR LINE
         B     TRYNEXT        AND TRY TO GO FURTHER ON
STERNWAS EQU   *
         NI    SWIPRT1,255-STARWAS
         MVC   0(STOPLEN,FUNC),FMTSTOP STOP FORMAT-PROCESSING HERE
         LA    FUNC,STOPLEN(FUNC)      INCREASE POINTER BY LENGTH OF FL
         ST    FUNC,AFORMAT@ UPDATE FORMATPOINTER
         TM    SW2,SPECENT   IS THIS A SPECIAL ENTRY ?
         BZ    LETSW         LET THE SWITCH REG AS I0 &S
         SH    SW,=H'4'      REDUCE FOR OVERWRITING SPECIAL ENTRY
LETSW    EQU   *
         ST    FUNC,0(SW)    SET FORMAT-ENTRY
         LA    SW,4(SW)      POINT TO NEXT ENTRY-LOCATION
         C     SW,LACTIONS   IS UPPER LIMIT OF THE TABLE REACHED ?
         BNL   ACTOVFL       GO TO OVERFLOW ROUTINE
         NI    SW2,255-SPECENT CLEAR THE SPECIAL SWITCH
         ST    SW,ACTION@    SAVE THE ACTUAL POINTER
         OI    0(SW),ENDINDIC
         CLI   1(R1),STERN   TWO STARS ?
         BE    ENDFORMT      YES, TERMINATE INTERPRETATION
         LA    R0,1(R1)      SET OVER CHARACTER FOUND
         ST    R0,PNTSAV     SAVE POSITION FOR CONTINUATION
         LR    PNT,R0        UPDATE POINTER REG                  ***
         LTR   LEN,LEN       IS SOMETHING TO BE TESTED LEFT ?    ***
         BP    TRYNEXT
         B     RET
BEGIN    EQU   *             HERE STARTS THE SEARCH FOR NEW KEYWORD
         CLI   0(PNT),KOMMA  IS NEXT BYTE A KOMMA ?
         BNE   BEGINOK       IF NOT, START THE SEARCH
         LA    PNT,1(PNT)    IF YES, SET THE POINTER OVER IT
         ST    PNT,PNTSAV    AND UPDATE THE ACTUAL POINTER
         BCTR  LEN,0         REDUCE LENGTH
         B     TRYNEXT       AND TEST IF CONTINUATION IS NECESSARY
BEGINOK  EQU   *             START THE SEARCH
         MVI   CONCODE,0     RESET CONDITION CODE
         MVI   CONCOD2,0     CLEAR LENGTH SWITCH
         XC    IPRTTAB,IPRTTAB CLEAR THE TABLE
         MVI   IDOLLAR,4
         MVI   IEQUAL,8
         MVI   ISTERN,12
         MVI   IKOMMA,16
         MVI   ILKLAM,20
         MVI   IRKLAM,20
         MVI   IAPOST,20
         SR    2,2           CLEAR TRT REG
         EX    LEN,TRT
         BZ    INVALID2
         B     *(2)
         B     DOLLARWS
         B     EQUALWAS
         OI    SWIPRT1,STARWAS         INDICATE THAT END OF FORMAT WAS
         B     KOMMAWAS
         B     INVALID1
PACK     PACK  DW,0(0,PNT)
TOOLONG  EQU   *
         LR    R1,PNT         SET POINTER TO LITERAL
         MVC   AADVERB(16),=C'LITERAL TOO LONG'
         B     INVPUT .       BRANCH TO PUT MESSAGE ROUTINE
NOOPER   EQU   *
         MVC   AACTION,OPERAND    MESSAGE
OPERRMSG EQU   *
         MVC   AMSGSUB(L'NO),NO   MOVE
         LR    R1,PNT        POINT TO MISSING OPERAND
         B     INVALID
DO       DC    C'DO'
NO       DC    C'NO'
OPERAND  DC    CL8'OPERAND'
DIGIT22  EQU   *
         LR    R0,R1         SET PNTSAV TO END OF DIGITS
         B     DIGIT2        AND GO TO SECOND DIGIT ENTRY
DIGIT    EQU   *             IF THIS ROUTINE IS ENTERED,
*                            REG 'PNT' POINTS TO BEGIN OF A STRING
*                            REG 1 POINTS TO END OF A STRING
*                            EXPECTED TO CONTAIN A DECIMAL COUNT
*                            AND EVENTUALLY A 'X' TO INDICATE THAT
*                           THE FOLLOWING LITERAL IS TO BE TREATED HEXA
         LA    R0,1(R1)      UPDATE ACTUAL POINTER FOR NEXT SEARCH
DIGIT2   EQU   *        ENTRY IS HERE, IF 2 DIGITS ARE EXPECTED
         ST    R0,PNTSAV     SAVE ACTUAL POINTER
         LR    LIMIT,R1      SAVE THE END POINTER
         SR    R1,PNT
         BNP   NOOPER        NO OPERATOR WAS FOUND TO BE CONVERTED
         SR    R0,PNT
         SR    LEN,R0        REMAINING LENGTH
         BCTR  LIMIT,0       REDUCE POINTER
         CLI   0(LIMIT),C'X'     IS FOLLOWING LITERAL HEXA ?
         BNE   NOHEXLIT      NO
         OI    SWIPRT2,HEX   INDICATE THIS REQUEST
         BCTR  R1,0          REDUCE LENGTH OF STRING
         LTR   R1,R1         WAS ONLY THE 'X'
         BNP   ONLY1         REPETE THE LITERAL ONCE
NOHEXLIT EQU   *
         SR    LIMIT,LIMIT   CLEAR TRT-REG AGAIN
         BCTR  R1,0          REDUCE LENGTH FOR EXECUTE
         MVI   IPRTTAB,BLANK PREPARE TABLE FOR DIGIT TEST
         MVC   IPRTTAB+1(255),IPRTTAB  CLEAR TABLE WITH BLANKS
         XC    IZIFF,IZIFF   MAKE DIGITS VALID
         EX    R1,TRT        AND TEST THE CHARACTER-STRING
         BNZ   INVALID3      INVALID CHARACTER WAS DETECTED
         XC    IPRTTAB,IPRTTAB CLEAR THE TABLE WITH HEXA-00
         EX    R1,PACK       PACK THE COUNT INTO A DOUBLEWORD
         CVB   R1,DW         AND CONVERT IT TO BINARY
*                  REG 1 CONTAINS NOW THE REQUIRED COUNT
*                  PNTSAV THE NEXT ADDRESS TO BE TESTED
*                  AND HEX-SWITCH IS SET, IF A 'X' WAS FOUND BEFORE LIT
         BR    LNK           RETURN
ONLY1    EQU   *             ONLY A 'X' WAS PRECEDING THE LITERAL
         LA    R1,1          SET THE REPETITION-COUNT TO ONE IF NONE IS
         SR    LIMIT,LIMIT   CLEAR TRT-REG AGAIN
         BR    LNK           AND RETURN
NNNXLIT  EQU   *             THIS ROUTINE IS ENTERED,
*                            WHEN A STRING OF THE FORMAT
*                            NNNX'LITERAL' IS EXPECTED TO FOLLOW
*                            NNN AND X ARE OPTIONAL
         XC    IPRTTAB,IPRTTAB CLEAR THE TABLE
         ST    LNK,LNKSAV    SAVE THE LINKREGISTER
         MVI   IAPOST,8      ONLY APOSTROPHE IS VALID AND REQIRED
         MVI   IKOMMA,4      4 INDICATES AN INVALID
         MVI   ISTERN,4      DELIMITER
         MVI   ILKLAM,4
         MVI   IRKLAM,4
         MVI   IEQUAL,4
         L     PNT,PNTSAV    GET ACTUAL POINTER
         EX    LEN,TRT       LOOK FOR THE APOSTROPHE
         BZ    INVALID2      THERE MUST BE ONE
         B     *(2)          VARIABLE BRANCH
         B     INVALID1      OTHER DELIMITERS THAN APOSTROPHE
         BAL   LNK,LITERAL   GET THE LITERAL
         L     LNK,LNKSAV    GET THE LINKREGISTER BACK
         BR    LNK           AND RETURN
MOVELIT  MVC   0(0,WK1),0(PNT)
SETORENT EQU   *             SET UP AN 'OR' - ENTRY
         LR    LIMIT,SW      GET ACTUAL ACTION POINTER
         SH    LIMIT,=H'4'   SET BACK TO PRECEDING
         TM    0(LIMIT),ODERENDE       WAS ODER ENDE
         BZ    NOORENTR      THERE WAS NO ORENTRY
         L     R15,0(LIMIT)  POINT TO FORMAT
         SH    R15,INCRSAV
         SH    R15,=H'2'     CHECK IF AN 'OR' WAS BEFOR THIS FORMAT
         L     R14,ATAB3     GET BASE OF INTERPRETATION TABLES
         USING TAB3T,R14
         CLC   0(2,R15),ORFMT WAS 'OR' ?
         DROP  R14
         BNE   NOORENTR
         LR    SW,LIMIT      OVERWRITE ODERENDE
NOORENTR EQU   *
         SR    LIMIT,LIMIT
         ST    FUNC,0(SW)    SET A NEW ACTION-ENTRY
         OI    0(SW),ORENTRY INDICATE THIS IS AN 'OR' - ENTRY
         LA    SW,4(SW)      UPDATE ACTION-POINTER
         ST    SW,ACTION@   AND SAVE THAT POINTER
         BR    LNK           AND RETURN
ENDFORMT EQU   *
         SH    SW,=H'4'      SET BACK TO LAST ENTRY
         OI    0(SW),ENDINDIC INDICATE THAT THIS WAS THE LAST ACTIVE
         OI    SWIPRT1,FMTEND
         B     RET           AND RETURN
TRYNEXT  EQU   *
         LTR   LEN,LEN       TEST REMAINING LENGTH
         BNP   RET           IF LENGTH IS EXHAUSTED, RETURN
         L     PNT,PNTSAV    GET NEW ACTUAL POINTER
         NI    SWIPRT2,255-SAVING-HEX-NOMOVE-NOSPLIT-ONLYDIG-PDKONST
         B     BEGIN
PUTLINE  EQU   *
         L     R1,ALISTE     GET DCB-ADDRESS
*        PUT   (1),(WK2)     AND PUT THE LINE
         PUT   (1),(WK2)     AND PUT THE LINE
CLEARLIN EQU   *
         L     R15,PRTCNT    GET LINE-COUNT
         LA    R15,1(R15)    ADD ONE
         ST    R15,PRTCNT    AND STORE IT BACK
         C     R15,MAXLINES  IS MAXIMUM REACHED ?
         BL    CLEARLI#      NO,PAGE IS NOT FULL
         L     R15,AHEADPRT  GET ADDRESS OF HEADER PRINT ROUTINE
         BALR  R14,R15       AND LINK TO IT IF PAGE IS FULL
CLEARLI# EQU   *
         MVI   ASA,BLANK     BLANK THE OUTPUT LINE
         MVC   AFLAG(ALINELEN),ASA BLANK  THE  OUTPUTLINE
         BR    LNK
COUNT@   EQU   *
         OI    SW4,COUNTWAS  INDICATE THAT COUNT PROCESSING IS REQUIRED
         OI    SW3,LINCNTIS  INDICATE THAT UPDATE OF SW-REG NOT NECESSA
         OI    SW2,SPECENT   INDICATE THIS IS A SPECIAL ENTRY WITH NO
*                                                             UPDATING
IGNI@    EQU   *
IGNO@    EQU   *
RSTI@    EQU   *
RSTO@    EQU   *
PNTI@    EQU   *
PNTO@    EQU   *
MOVEX@   EQU   *
FMT@     EQU   *
         OI    SWIPRT2,NOMOVE INDICATE THIS IS NO MOVE INSTUCTION
EDIT@    EQU   *
MOVEN@   EQU   *
MOVEZ@   EQU   *
MOVE@    EQU   *             ROUTINE IF KEYWORD MOVE WAS FOUND
         MVI   IAPOST,4      4 IS THE  INDICATOR  FOR
         MVI   ILKLAM,4        CODES THAT MUST NOT
         MVI   IRKLAM,4        APPEAR AT THIS POINT
         MVI   IEQUAL,4
         MVI   ISTERN,8      STERN MAY BE POSSIBLE
         MVI   IKOMMA,12     KOMMA IS THE NORMAL CASE
         L     PNT,PNTSAV    GET ACTUAL POINTER
         EX    LEN,TRT
         BZ    INVALID2
         B     *(2)
         B     INVALID1
         OI    SWIPRT1,STARWAS
         BAL   LNK,DIGIT     INTERPRETE THE DIGITS
MOVEUPD  EQU   *             THIS ROUTINE DOES THE UPDATING AFTER
*                            KEYWORD=NNNN WAS FOUND
         TM    SW3,LINCNTIS  WAS A COUNT FORMAT DETECTED ?
         BO    SETLINE       YES, SET A LINE ENTRY
         TM    SWIPRT2,NOMOVE  IS THIS A MOVE INSTRUCTION
         BO    POINTWAS      NO, IT WAS A POINT => NO BCTR
         CH    R1,=H'256'    WILL A SINGLE MVC BE ENOUGH
         BNH   LENGTHOK      YES
         MVC   FMTCODE,AMVCLONG  IF NOT, PROVIDE THE ADDRESS OF LONG MV
LENGTHOK EQU   *
         BCTR  R1,0          REDUCE LENGTH FOR EXECUTE
         B     CNTOK         COUNT IS OK
POINTWAS EQU   *
         CLI   0(WK1),C'P'   WAS KEYWORD 'PNTI' OR 'PNTO' ?
         BNE   CNTOK         NO, COUNT IS OK
         LTR   R1,R1         WAS ZERO SPECIFIED ?
         BNP   CNTOK         YES, DON'T REDUCE
         BCTR  R1,0          REDUCE BY 1 FOR CORRECT DISPLACEMENT
CNTOK    EQU   *
         NI    SWIPRT2,255-NOMOVE      RESET SWITCH BIT
         STH   R1,FMTCNT     STORE THE COUNT TO FORMAT-ELEMENT
         LA    R0,FMTCNT+L'FMTCNT-FMTDSECT  LENGTH OF THIS FORMAT-ENTRY
COMUPDAT EQU   *             COMMON UPDATE ROUTINE FOR FORMAT POINTER
         STH    R0,FMTINCR   STORE LENGTH TO FORMAT ENTRY
         AR    FUNC,R0       INCREASE FORMAT-POINTER
         C     FUNC,LFORMAT  IS FORMAT-TABLE FULL ?
         BNL   FMTOVFL       GO TO OVERFLOW ROUTINE
         ST    FUNC,AFORMAT@ UPDATE ACTUAL POINTER
         TM    SWIPRT2,ODERWAS WAS KEYWORD = OR ?
         BZ    TESTSTAR      NO
         BAL   LNK,SETORENT  SET UP AN 'OR' - ENTRY
         NI    SWIPRT2,255-ODERWAS CLEAR THE OR-SWITCH
TESTSTAR EQU   *
         MVC   0(STOPLEN,FUNC),FMTSTOP MOVE POFILAKTISCH
         STH   R0,INCRSAV
         TM    SWIPRT1,STARWAS
         BZ    TRYNEXT
         L     R1,PNTSAV
         BCTR  R1,0
         B     STERNWAS
MOVEM@   EQU   *
         OI    SWIPRT2,HEX   INDICATE HEXALITERAL => CALL CONVEX
MOVEL@   EQU   *             IF KEYWORD 'MOVEL' WAS FOUND
         BAL   LNK,NNNXLIT   LINK TO ROUTINE ANALYZING THIS FORMAT
         B     TRYNEXT       THEN TRY TO FIND NEXT KEYWORD
CNT0@    EQU   *
RSTC@    EQU   *
DATE@    EQU   *
NEXT@    EQU   *
DATM@    EQU   *
DMP@     EQU   *
SAME@    EQU   *
TIME@    EQU   *
MOVER@   EQU   *
NEXTC@   EQU   *
PRINT@   EQU   *
UPDAT4   EQU   *             UPDATE ROUTINE FOR ALL 4-BYTE ENTRIES
         LA    R0,4          SET LENGTH REGISTER
         B     COMUPDAT      AND GO TO COMMON UPDATE ROUTINE
LITERAL  EQU   *             THIS ROUTINE BRINGS LITERALS TO FORMATTABL
         LA    R0,1          INITIALIZE THE BCT (REPETITION) COUNT
         ST    R0,BCTCOUNT   FOR LITERALS
         C    R1,PNTSAV      IF EQUAL => NO REPETITION COUNT WAS
         LA    R0,1(R1)      SET POINTER OVER APOSTROPHE
         ST    R0,PNTSAV     AND SAVE THAT ACTUAL POINTER
         BNH   NOREPET       RESPONSE IS TO COMPARE
         ST    LNK,LNKSAV2   SAVE LINKREGISTER
         BAL   LNK,DIGIT     CONVERT THE COUNT INTO REG 1
         ST    R1,BCTCOUNT   AND SAVE THE COUNT
         LA    LEN,1(LEN)    ADD ONE, BECAUSE APOSTROPHE WAS ALREADY
         L     LNK,LNKSAV2
NOREPET  EQU   *             IF NO REPETITION COUNT WAS => IT IS 1
         L     PNT,PNTSAV    BYTE BEHIND THE APOSTROPHE
         BCTR  LEN,0         REDUCE LENGTH BY 1 (APOSTROPHE)
         XC    IPRTTAB,IPRTTAB CLEAR THE TRT TABLE
         MVI   IAPOST,4      ONLY APOSTROPHE IS VALID AND SIGNIFICANT
         EX    LEN,TRT       TRANSLATE AND TEST
         BZ    INVALID2      THERE MUST BE AN APOSTROPHE
         LA    R0,1(R1)      SET POINTER OVER THE APOSTROPHE
         ST    R0,PNTSAV     AND SAVE THIS ACTUAL POINTER
         SR    R1,PNT        LITERAL LENGTH
         BZ    NOOPER        THER WASN'T ANYTHING BETWEEN APOSTROPHES
         SR    R0,PNT
         SR    LEN,R0        COMPUTE REMAINING LENGTH
         TM    SWIPRT2,HEX   IS HEX-CONVERSION REQIRED ?
         BO    HEXCONV       YES, GO TO CONVERSION ROUTINE
GETLIT   EQU   *             ROUTINE TO GET A LITERAL TO FORMAT-TABLE
*              REG1  CONTAINS THE LENGTH OF THE LITERAL
*              PNT    IS THE POINTER TO THE LITERAL ON INPUT CARD
         ST    LEN,LENSAV    SAVE THE REMAINING LENGTH
         LA    LIMIT,256     MAXIMUM ACCEPTABLE LENGTH FOR LITERALS
         SR    LIMIT,R1      REDUCED BY SIMPLE LENGTH
         L     R0,BCTCOUNT   GET THE REPETION FAKTOR
         BCTR  R1,0          REDUCE LENGTH FOR EXECUTE
GETLIT2  EQU   *            THIS ROUTINE IS REPETED IF LITERAL IS SPLIT
         SR    LEN,LEN       CLEAR REG
         LA    WK1,FMTLIT    SET A POINTER TO LITERAL IN FORMAT
EXLITMOV EQU   *   THIS ROUTINE IS REPETED DUE TO THE REPETITION COUNT
         CR    LEN,LIMIT     WILL NEXT REPETION FIT INTO FORMAT
         BNL   ENOUGH        NO, SPLIT THE LITERAL
         EX    R1,MOVELIT    EXECUTE THE MOVE
         LA    LEN,1(R1,LEN) ACCUMMULATE THE LENGTH
         LA    WK1,1(R1,WK1) AND UPDATE POINTER IN FORMAT
         BCT   R0,EXLITMOV   AND DO IT AGAIN
         OI    SWIPRT2,ENDINDIC   INDICATE THAT LITERAL IS COMPLETE
ENOUGH   EQU   *   NOW UPDATE THE FORMAT ENTRY-POINTER
         TM    SWIPRT2,NOSPLIT  MAY LITERAL BE SPLIT ?
         BZ    LITISOK       YES, SPLIT IF NECESSARY
         NI    SWIPRT2,255-NOSPLIT     CLEAR SWITCH
         TM    SWIPRT2,ENDINDIC  MUST BE ON, OTHERWISE LITERAL WILL
         BZ    TOOLONG                 EXCEED 256 BYTES IN LENGTH
LITISOK  EQU   *
         BCTR  LEN,0        MAKE COUNT READY FOR EXECUTE
         STH   LEN,FMTLITLN  LENGTH OF LITERAL
         MVC   FMTLITLN(1),CONCODE    MOVE THE REQUIRED CONDITIONCODE
         TM    FMTLITLN+L'FMTLITLN-1,1 IS LENGTH AN ODD NUMBER
         BO    *+8           IF YES , LENGHT IS OKAY
         LA    LEN,1(LEN)    ADD ONE TO FORCE ENTRY LENGTH EVEN
         TM    SW2,SCANIS    IS SCAN IN INTERPRETATION ?
         BZ    NOSCAN        NO, DON'T CARE ABOUT
         NI    SW2,255-SCANIS CLEAR SWITCH
         LA    LEN,2(LEN)    ADD 2 FOR SCAN ENTRY IS LONGER
         SH    FUNC,=H'2'    AND REDUCE FORMAT POINTER
NOSCAN   EQU   *
         TM    SWIPRT2,SAVING  WAS A SAVE INSTRUCTION ?
         BZ    NOSAVE        NO, FUNC IS CORRECT
         LA    LEN,4(LEN)    ADD 4 TO FORMATLENGTH  (ACCU-ADDRESS)
         SH    FUNC,=H'4'    SET BACK FORMAT POINTER
NOSAVE   EQU   *
         LA    LEN,FMTLIT-FMTDSECT+1(LEN) COMPUT TOTAL ENTRY LENGTH
         STH   LEN,INCRSAV
         STH   LEN,FMTINCR   AND STORE IT TO INCREMENT
         LR    R14,FUNC      SAVE TEMPORARY THIS ENTRY ADDRESS
         AR    FUNC,LEN      UPDATE FORMAT-POINTER
         L     LEN,LENSAV    RESET LENGTH REGISTER
         C     FUNC,LFORMAT
         BNL   FMTOVFL
         ST    FUNC,AFORMAT@ SAVE ACTUAL FORMAT POINTER
         MVC  FMTCODE,FMTCODE-FMTDSECT(R14) MOVE OLD CODE TO NEW FORMAT
*              MAY BE NECESSARY, IF LITERAL IS SPLIT
         TM    SWIPRT2,ENDINDIC        IS THE LITERAL GENERATED ?
         BZ    GETLIT2       NO, GO ONCE MORE
         NI    SWIPRT2,255-ENDINDIC    RESET SWITCH
         BR    LNK           AND RETURN
SETLINE  EQU   *
         NI    SW3,255-LINCNTIS CLEAR THE SWITCH
         ST    FUNC,NEWPAGE  SAVE THE ENTRY OF FOLLOWING FORMATS
         ST    R1,LINECOMP   PUT THE REQUIRTED LINE COUNT TO COMPARE FL
         ST    R1,LINECNT    AND TO COUNT FIELD, TO GET OVERFLOW AT FIR
         B     TESTSTAR      DONT UPDATE FORMAT ENTRY TABLE
HEXCONV  EQU   *
         NI    SWIPRT2,255-HEX  CLEAR SWITCH BIT
         LR    R0,R1         LOAD LENGTH PARM REG
         LR    R1,PNT        SET POINTER TO LITERAL STRING
         L     R15,VCONVEX    ENTRY POINT OF CONVERSION SUBROUTINE
         BALR  R14,R15       LINK TO CONVERSION PROGRAM
         LPR   R15,R15       WAS ANY ERROR CONDITION ?
         BNZ   INVALID4      YES, PUT A MESSAGE
         LR    R1,R0         GET BACK THE LENGTH
         LA    R1,1(R1)      ADD ONE  IF LENGTH WAS ODD
         SRL   R1,1          AND DIVIDE BY 2
         B     GETLIT        NOW PLACE THE LITERAL TO FORMAT
INVALID4 EQU   *
         LR    R1,R15        GET THE ADDRESS OF INCORRECT BYTE
         AR    PNT,R0        ADD LENGTH OF STRING
         LA    PNT,1(PNT)    AND ONE FOR APOSTROPHE
         SR    LEN,R0        REDUCE LENGTH
         BCTR  LEN,0
         ST    PNT,PNTSAV    SAVE ACTUAL POINTER
         B     INVALID3
DIGLIT   EQU   *             THIS ROUTINE IS ENTERED, WHEN A FORMAT
*                            OF THE FORM  (NNN,NN'LITERAL') IS EXPECTED
         L     PNT,PNTSAV    GET ACTUAL POINTER
         LR    R1,PNT
         CLI   0(PNT),C'('   IS A LEFT PARENTHESES
         BNE   INVALID1      NO, INDICATE ERROR
         BCTR  LEN,0         REDUCE LENGTH
         LA    PNT,1(PNT)    INCREASE POINTER
         ST    PNT,PNTSAV    UPDATE ACTUAL POINTER
SECNDDIG EQU   *
         XC    IPRTTAB,IPRTTAB CLEAR THE TRANSLATE TABLE
         MVI   IKOMMA,4      ONLY KOMMA IS VALID
         EX    LEN,TRT       TEST THE STRING
         BZ    INVALID2
         BAL   LNK,DIGIT     CONVERT THE COUNT
         TM    SWIPRT2,ONLYDIG IS ONLY THE DIGIT REQUIRED ?
         BCR   1,R15         YES, RETURN
         LTR   R1,R1         WAS ZERO SPECIFIED ?
         BZ    ZEROWAS       YES, PREVENT REDUCING
         BCTR  R1,0          REDUCE TO GET CORRECT DISPLACEMENT
ZEROWAS  STH   R1,FMTCNT     STORE THE COUNT TO FORMAT
         L     PNT,PNTSAV    SET POINTER OVER KOMMA
         OI    SWIPRT2,NOSPLIT INDICATE SPLITTING NOT ALLOWED
         BAL   LNK,NNNXLIT   GET THE LITERAL IF THERE IS ONE
         NI    SWIPRT2,255-NOSPLIT   REST SWITCH
         BAL   R15,ORENDTST  WAS A 'OR'-ENTRY  ACTIVE ?
         SR    LIMIT,LIMIT   CLEAR TRT-REG
         L     PNT,PNTSAV    GET THE UPDATED POINTER
         LR    R1,PNT        REQUIRED IF NO  ')'  WAS FOUND
         CLI   0(PNT),C')'   IS A RIGHT PARANTHESES ?
         BNE   INVALID1      IF NOT, INDICATE ERROR
         LA    PNT,1(PNT)    SET POINTER OVER ')'
         ST    PNT,PNTSAV    AND SAVE THE ACTUAL POINTER
         BCTR  LEN,0         REDUCE LENGTH
         TM    SWIPRT2,SAVING  WAS A SAVING INSTRUCTION ?
         BO    SETL@@        YES
         B     TRYNEXT
ADD@     EQU   *
         L     R1,AACCU      ACCUS START ADDRESS
         LTR   R1,R1         ARE ALREADY ACCUS ?
         BCR   7,LNK         YES, RETURN
         LH    R0,ACCUNUM    GET NUMBER OF ACCUS SPECIFIED
         SLL   R0,3          * 8 FOR ONE ACCU HAS 8 BYTES
         AIF   (&S).OSGM2
*        EXTGM R,LV=(0),MOD=VGM
         EXTGM R,LV=(0),MOD=VGM
         AGO   .OVGM2
.OSGM2   ANOP
*        GETMAIN R,LV=(0)    GET CORE FOR ACCUS
         GETMAIN R,LV=(0)    GET CORE FOR ACCUS
.OVGM2   ANOP
         ST    R1,AACCU      SAVE THEIR ADDRESS
         LH    R0,ACCUNUM    NUMBER OF ACCUS
ZAP0     ZAP   0(8,R1),=P'0' CLEAR ALL ACCUS TO ZERO
         LA    R1,8(R1)      SET POINTER TO NEXT ACCU
         BCT   R0,ZAP0       AND CLEAR THE NEXT
         BR    LNK           IF ALL ARE ZERO, RETURN
SUB@     EQU   *
AND@     EQU   *
UND@     EQU   *
         B     TESTSTAR      DON'T UPDATE IGNOR IT TOTALLY
END@     EQU   *
         B     UPDAT4        UPDATE A 4 BYTE ENTRY
         DROP  WK2
SEP@     EQU   *
         L     PNT,PNTSAV    GET ACTUAL POINTER
         LA    R1,2(PNT)     PREPARE END POINTER FOR DIGIT VERIFICATION
         BAL   LNK,DIGIT22   LINK TO SECOND DIGIT CONVERT ROUTINE
         STC   R1,DW+7       SAVE THE DCB-ID
         LA    LIMIT,ASEPDCBS POINT TO CHAIN BEGIN FOR SEPERATION DCB'S
         USING SEPENTRY,LIMIT
NEXTSEP  EQU   *
         L     R1,LINKFLD    GET NEXT ENTRY ADDRESS
         LTR   R1,R1         TEST IF ONE IS PRESENT
         BNZ   ISIDEQ        IF YES, TEST IF SAME IDENTIFICATION
         AIF   (&S).BNZ
         MVN   NOFZONE(1),DCBID STORE NUMERIC PART OF ID FOR COMPARISON
         CLC   NOFZONE(1),DW+7 IS DTF ID EQ ?
         BNE   SEPERR        ID NOT FOUND IN CHAIN
         B     SEPUPD        ID FOUND IN LAST ENTRY
NOFZONE  DC    H'0'          RECEIVING FIELD OF NUMERIC PART OF ID
         AGO   .SEPUP
.BNZ     ANOP
         LA    R0,16         ENTRY-LENGTH
*        GETMAIN R,LV=(0)    GET CORE FOR AN ENTRY
         GETMAIN R,LV=(0)    GET CORE FOR AN ENTRY
         ST    R1,LINKFLD    CHAIN IT TO PREVIOUS ENTRY
         XC    0(16,R1),0(R1) AND CLEAR THE NEW ENTRY
         LR    LIMIT,R1      SET BASE TO NEW ENTRY
*        LOAD EPLOC=MODELDCB GET THE PREDEFINED DCB'S
         LOAD EPLOC=MODELDCB GET THE PREDEFINED DCB'S
         LR    WK2,R0        SET BASE REGISTER
         USING GENDCBS,WK2
         LA    R0,UT2LEN     LENGTH OF THE DCB
*        GETMAIN R,LV=(0)    GET CORE FOR THE DCB
         GETMAIN R,LV=(0)    GET CORE FOR THE DCB
         LR    WK1,R1        SET BASE REGISTER TO DCB
         USING IHADCB,WK1
         MVC   0(UT2LEN,WK1),UT2       MOVE THE PREDEFINED DCB TO PLACE
*        DELETE EPLOC=MODELDCB DELETE THE CSECT
         DELETE EPLOC=MODELDCB DELETE THE CSECT
         MVC   DCBDDNAM+5(2),0(PNT)    MOVE THE CHARACTER ID TO DDNAME
*        TIOTSCAN DCBDDNAM
         TIOTSCAN DCBDDNAM
         LTR   R15,R15       TEST IF TIOT ENTRY WAS FOUND
         BZ    SEPERR        NO, WRITE A MESSAGE
         OI    DW,ENDINDIC   PREPARE A REENTRANT OPEN
*        OPEN  ((WK1),(OUTPUT)),MF=(E,DW)   OPEN T8E DCB
         OPEN  ((WK1),(OUTPUT)),MF=(E,DW)   OPEN THE DCB
         ST    WK1,DCBADR    SAVE THE DCB'S ADDRESS
         MVC   DCBID,DW+7    AND THE IDENTIFICATION
.SEPUP   ANOP
SEPUPD   EQU   *
         L     WK2,ALIST     GET BACK THE OUTPUT LINE
         ST    LIMIT,DW      STORE THE ENTRY ADDRESS
         MVC   FMTCNT(4),DW  AND BRING IT TO FORMAT TABLE
         SR    LIMIT,LIMIT   CLEAR TRT-REGISTER
         LA    R0,FMTCNT+4-FMTDSECT    SET THE UPDATE REGISTER
         B     COMUPDAT      AND BRANCH TO COMMON UPDATE ROUTINE
ISIDEQ   EQU   *             TEST IF DCB-ID WAS ALREADY PRESENT
         LR    LIMIT,R1      GET THE ENTRY ADDRESS
         AIF   (&S).CIDDW
         MVN   NOFZONE(1),DCBID MOVE ID WITHOUT F
         CLC   NOFZONE(1),DW+7 DO THEY MATCH ?
         AGO   .DECISIO
.CIDDW   ANOP
         CLC   DCBID,DW+7    COMPARE ENTRY ID WITH ID FOUND
.DECISIO ANOP
         BE    SEPUPD        IF EQUAL, UPDATE THE FORMAT ENTRY
         B     NEXTSEP       IF NOT, SEARCH ON
         AIF   (&SD).NOTWK2
         DROP  WK2
.NOTWK2  ANOP
         USING AZEILE,WK2
SEPERR   EQU   *
         L     WK2,ALIST     GET BACK THE OUTPIT LINE
         MVC   AADVERB,=C'MISSING'
         MVC   ASUBJECT(8),=C'DDNAME :'
         AIF   (&S).DDNM
         MVC   AMSGSUB-1(7),=C'SYS00  ' MOVE DDNAME TO MSG
         MVC   AMSGSUB+4(1),DCBID MOVE INVALID ID
         AGO   .PUTM
.DDNM    ANOP
         MVC   AMSGSUB-1(7),DCBDDNAM   MOVE THE INVALID DDNAME
.PUTM    ANOP
         DROP  LIMIT
         B     PUTMSG        PUT A MESSAGE AND INDICATE ERROR
EDAC@    EQU   *
         MVI   CONCOD2,15    MAXIMUM ALLOWED LENGTH
         B     ADDCOM
LAST@    EQU   *
         OI    SW2,SPECENT   INDICATE THIS IS A SPECIAL ENTRY WITH NO
*                                                             UPDATING
         OI    SW4,LASTWAS   INDICATE THERE WAS AN ENTRY 'LAST'
         ST    FUNC,LASTLINE SAVE ENTRY OF THIS FORMAT
         B     TESTSTAR      DONT UPDATE FORMAT ENTRY POINTER
ODER@    EQU   *
         OI    SWIPRT2,ODERWAS
         B     UPDAT4        AND GO TO UPDATE ROUTINE
PUTL@    EQU   *
SAVE@    EQU   *
         OI    SWIPRT2,SAVING INDICATE SAVE OR COMP SAVE
         B     ADDCOM        GET THE COUNTS
SAVETEST EQU   *             IF SAVING BIT WAS SET, CONTROL RETURNS HER
         NI    SWIPRT2,255-SAVING
         LH    R1,FMTCNT     GET THE ID NUMBER
         SRL   R1,3          SHIFT IT BACK  WAS CALCULATED AS ACCU
         STH   R1,FMTCNT     AND SET IT CORRECTLY BACK
         TM    SWIPRT1,NUMLIT IS NUMERIC TEST REQ?
         BO    LOADNUMT .    YES, GO TO FETCH TABLE
         TM    SWIPRT1,NUMPACK IS PACKED TEST REQ. ?
         BO    LOADN99T .    YES, GO TO FETCH TABLE
SAVELOOP EQU   *
         MVC   FMTCNT(1),CONCODE       IF COMPARISON WAS, ZERO ELSE
SAVELOP2 EQU   *
         LA    LIMIT,SAVFLDS GET THE ORIGIN OF THE SAVBER-CHAIN
         USING SAVDSECT,LIMIT
NEXTSAV  EQU   *
         L     R1,LNKFLD     TEST IF ANOTHER ENTRY EXISTS
         LTR   R1,R1
         BNZ   ISSAVID       YES, IT EXISTS, => LOOK IF ID IS MATCHING
         LA    R0,8          LENGTH OF A SAVE-ENTRY
         AIF   (&S).OSGM3
*        EXTGM R,LV=(0),MOD=VGM
         EXTGM R,LV=(0),MOD=VGM
         AGO   .OVGM3
.OSGM3   ANOP
*        GETMAIN R,LV=(0)    GET CORE FOR AN ENTRY
         GETMAIN R,LV=(0)    GET CORE FOR AN ENTRY
.OVGM3   ANOP
         ST    R1,LNKFLD     CHAIN NEW ENTRY
XC       XC    0(8,R1),0(R1) CLEAR THE NEW ENTRY
         LR    LIMIT,R1      POINT TO NEW ENTRY
         LH    R0,FMTAKU#    LENGTH OF THIS SAVBER
         LR    WK1,R0        SAVE THAT LENGTH
         AH    R0,=H'1'      TO GET CORRECT LENGTH
         AIF   (&S).OSGM4
*        EXTGM R,LV=(0),MOD=VGM
         EXTGM R,LV=(0),MOD=VGM
         AGO   .OVGM4
.OSGM4   ANOP
*        GETMAIN R,LV=(0)    GET CORE FOR THE SAVBER
         GETMAIN R,LV=(0)    GET CORE FOR THE SAVBER
.OVGM4   ANOP
         ST    R1,SAVADR     SAVE ITS ADDRESS TO SAVE-ENTRY
         EX    WK1,XC        CLEAR THAT SAVBER
         MVC   SAVID,FMTCNT+1 PUT THE ID TO ENTRY
SAVUPD   EQU   *
         ST    LIMIT,DW      SAVE THE ENTRY ADDRESS
         TM    SWTAB,COMPAC2 IS ACCU-COMPARE FOR 2. ACCU ACTIVE ?
         BO    ACC2UPDT      YES
         MVC   FMTAKU#+2(4),DW AND BRING IT TO FORMAT ENTRY
         TM    SWTAB,COMPAC  IS ACCU-COMPARE ACTIVE ?
         BO    ACCMP2P       YES
         LA    R0,FMTAKU#+2+4-FMTDSECT SET UPDATE REGISTER
IFSVUPD  EQU   *
         SR    LIMIT,LIMIT   CLEAR TRT REG
         TM    SWIPRT2,SAVING WAS KEYWORD = 'SETL' ?
         BO    SETLWAS       SETL-ENTRY IS LONGER
         TM    CONCODE,X'F0'  WAS COMP-INSTUCTION ?
         BZ    COMUPDAT      NO, GO TO UPDATE ROUTINE
CONDUPDT EQU   *
         LR    R1,FUNC       SAVE POINTER TO FORMAT ENTRY
         AR    FUNC,R0       SET POINTER TO END OF FORMAT-ENTRY
         BAL   R15,ORENDTST  WAS A 'OR'-ENTRY  ACTIVE ?
         LR    FUNC,R1       RESET POINTER FOR CORRECT UPDATE
         SR    LIMIT,LIMIT   CLEAR TRT REG
         B     COMUPDAT      GO TO COMMON UPDATE ROUTINE
SETLWAS  EQU   *
         NI    SWIPRT2,255-SAVING      CLEAR THE SWITCH
         LH    R0,FMTINCR    GET LENGTH OF THE ENTRY (IS ALREDY IN FLD)
         B     COMUPDAT
ISSAVID  EQU   *
         LR    LIMIT,R1      POINT TO NEXT ENTRY
         CLC   SAVID,FMTCNT+1 IS THE ID ALREADY PRESENT
         BE    SAVUPD        YES, SAVE-ENTRY IS INSTALLED, => UPDATE
         B     NEXTSAV       IF NOT, TEST ON
         DROP  LIMIT
SCANERR  EQU   *
         MVC   AADVERB,=C'INVALID'
         MVC   ASUBJECT(10),=C'BOUNDARIES'
         MVC   AMSGSUB-1(8),=C'FOR SCAN'
         B     PUTMSG        PUT A MESSAGE AND INDICATE ERROR
SCAN@    EQU   *
         L     R0,ASCAN      GET SCAN ROUTINE ADDRESS IF ALREDY IN CORE
         LTR   R0,R0         IS ROUTINE ALREDY LOADED ?
         BNZ   SCANISLD      YES, DON'T LOAD AGAIN
         AIF   (&S).OSSCAN
         LOAD  BGENSCAN
         AGO   .STO
.OSSCAN  ANOP
*        LOAD  EP=GENSCAN    LOAD SCAN ROUTINE
         LOAD  EP=GENSCAN
.STO     ANOP
         ST    R0,ASCAN      SAVE ADDRESS OF SCAN ROUTINE
SCANISLD EQU   *
         OI    SW2,SCANIS    INDICATE SCAN OPERATION IN PROCESS
GET2DIGS EQU   *
         OI    SWIPRT2,ONLYDIG INDICATE ONLY DIGIT IS REQUIRED
         BAL   R15,DIGLIT    GET THE DIGIT CONVERTED
         LTR   R1,R1         WAS ZERO SPECIFIED ?
         BNP   ZEROWAS4      IF ZERO, DON'T REDUCE
         BCTR  R1,0          REDUCE FOR CORRECT DISPLACEMENT
ZEROWAS4 EQU   *
         STH   R1,FMTCNT     SAVE THE COUNT TO FORMAT ENTRY
         L     PNT,PNTSAV    GET THE ACTUAL POINTER
         BAL   R15,SECNDDIG  GET THE SECOND DIGIT
         NI    SWIPRT2,255-ONLYDIG     CLEAR THE SWITCH
         TM    SWTAB,COMPAC  IS ACCU-COMPARE ACTIVE
         BO    GETACUL       YES, THIS IS THE LENGTH PARAMETER
         CH    R1,FMTCNT     IS SECONG DIGIT GREATER THAN FIRST
         BNH   SCANERR       IF NOT => ERROR
         LA    FUNC,2(FUNC)  ADD 2  TO FORMAT POINTER TO USE DSECT
         B     ZEROWAS       AND GO TO COMMON LITERAL RECIEVE ROUTINE
WLOG@    EQU   *
         L     WK1,AOUTPUT   GET SYSUT2 DCB
         AIF   (&S).DCBL
         LA    R1,DTFTAB
         USING DTFTAB,R1
COMP     CLI   ID,C'1'       LOOK FOR SYSUT2 (SYS001) LRECL
         BE    IDFND         EXISTENCE WAS EARLIER PROVED
         LA    R1,ENTRYLL(R1)  SET ON NEXT ENTRY
         B     COMP
IDFND    EQU   *
         LH    R1,RECL       GET SYSUT2 RECORD LENGTH
         DROP  R1
         L     WK1,ALISTE    GET MESSAGE DTF
         LH    R0,=H'133'    SYSPRINT RECORD LENGTH
         AGO   .COMP01
.DCBL    ANOP
         LH    R1,DCBLRECL   GET LRECL OF SYSUT2
         L     WK1,ALISTE    GET MESSAGE DCB
         LH    R0,DCBLRECL   AND ITS LRECL
.COMP01  ANOP
         CR    R0,R1         COMPARE LRECLS
         BH    WILLFIT       TAKE LRECL FROM SYSUT2 (IT IS LOWER)
         BCTR  R0,0          REDUCE SYSPRINT LRECL FOR ASA-CODE
         LR    R1,R0         TAKE THE SHORTER ONE
WILLFIT  EQU   *
         BCTR  R1,0          AND REDUCE IT BY 1 FOR EXECUTE
         STH   R1,FMTCNT     STORE IT TO LENGTH FIELD
         LA    R0,FMTCNT+L'FMTCNT-FMTDSECT
         TM    SWIPRT2,SAVING  WAS SETL ?
         BZ    COMUPDAT      NO, GO TO COMMON UPDATE ROUTINE
         NI    SWIPRT2,255-SAVING-NOSPLIT  CLEAR THE SWITCHES
         B     TESTSTAR      UPDATE IS DONE, TRY NEXT
SETL@    EQU   *
         OI    SWIPRT2,ONLYDIG+SAVING+NOSPLIT
         BAL   R15,DIGLIT    GET THE FIRST DIGIT
         NI    SWIPRT2,255-ONLYDIG
         LTR   R1,R1
         BZ    ZEROWAS5      IF ZERO LET IT
         BCTR  R1,0          REDUCE IT BY ONE
ZEROWAS5 EQU   *
         STH   R1,FMTCNT     STORE ACCU-ID (=ACCU-NUMBER - 1)
         LA    FUNC,4(FUNC)  SPARE FOR ACCU-ADDRESS
         B     ZEROWAS       GO TO COMMON LITERAL-ROUTINE
ACKTE@   EQU   *
         MVI   CONCODE,EQUAL MOVE THE REQUIRED CONDITION MASK
         B     ACKTCOMP      GO TO COMMON ROUTINE
ACKTL@   EQU   *
         MVI   CONCODE,LOW   MOVE THE REQUIRED CONDITION MASK
         B     ACKTCOMP      GO TO COMMON ROUTINE
ACKTH@   EQU   *
         MVI   CONCODE,HIGH  MOVE THE REQUIRED CONDITION MASK
         B     ACKTCOMP      GO TO COMMON ROUTINE
ACKTU@   EQU   *
         MVI   CONCODE,UNEQUAL MOVE THE REQUIRED CONDITION MASK
ACKTCOMP EQU   *
         OI    SWIPRT1,KONSTCMP INDICATE THISCONDITION
ADDKT@   EQU   *
SUBKT@   EQU   *
         BAL   LNK,ADD@      LOOK IF ALREADY ACCUS ARE
         OI    SWIPRT2,PDKONST  INDICATE KONSTANT IS EXPECTED
         BAL   R14,ADDCOM    GO TO COMMON ROUTINE FOR ADDS
         NI    SWIPRT2,255-PDKONST CLEAR THE SWITCH
         L     PNT,PNTSAV    GET ACTUAL POINTER
         LR    R1,PNT
         CLI   0(PNT),X'7D'  IS AN APOSTROPHE ?
         BNE   INVALID1      SOMETHING WRONG
         LA    PNT,1(PNT)    SET POINTER OVER
         BCTR  LEN,0         REDUCE LENGTH
         XC   IPRTTAB,IPRTTAB          CLEAR THE TRT-TABLE
         MVI   IAPOST,4      MAKE APOSTROPHE VALID
         EX    LEN,TRT       TEST FOR APOSTROPHE
         BZ    INVALID2      IF NONE FOUND THERE IS SOMETHING WRONG
         BAL   LNK,DIGIT     TEST AND GET THE COUNT
         ZAP   FMTKONST,DW   BRING THE COUNT TO FORMAT (PACKED FORMAT
         LA    R0,FMTKONST+L'FMTKONST-FMTDSECT GET LENGTH OF THIS ENTRY
         L     PNT,PNTSAV    GET ACTUAL POINTER
         LR    R1,PNT
         CLI   0(PNT),C')'   IS FIELD CORRECT SPECIFIED ?
         BNE   INVALID1      NO, GIVE A MESSAGE AND ERROR INDICATION
         LA    PNT,1(PNT)    UPDATE POINTER
         BCTR  LEN,0         REDUCE LENGTH
         ST    PNT,PNTSAV    STORE POINTER
         TM    SWIPRT1,KONSTCMP IS COMPARE ACCU TO KONSTANT ?
         BO    UPDATCAC      GO TO SPECIAL UPDATE ROUTINE
         B     COMUPDAT      AND GO TO COMMON UPDATE ROUTINE
DIV@     EQU   *
MULT@    EQU   *
ADDAC@   EQU   *
SUBAC@   EQU   *
         OI    SWOPEN,SECDIGAC
         MVI   CONCOD2,255   MAXIMUM POSSIBLE LENGTH
         B     ADDCOMA       GO TO ROUTINE COMMON TO ALL ADDS
BINAC@   EQU   *
ADDBI@   EQU   *
SUBBI@   EQU   *
         MVI   CONCOD2,3     MAXIMUM POSSIBLE LENGTH
         B     ADDCOMA       GO TO ROUTINE COMMON TO ALL ADDS
ADDCH@   EQU   *
SUBCH@   EQU   *
UNPAC@   EQU   *
         MVI   CONCOD2,15    MAXIMUM POSSIBLE LENGTH
         B     ADDCOMA       GO TO ROUTINE COMMON TO ALL ADDS
PCKAC@   EQU   *
ADDPD@   EQU   *
SUBPD@   EQU   *
         MVI   CONCOD2,7     MAXIMUM POSSIBLE LENGTH
ADDCOMA  EQU   *
         BAL   LNK,ADD@      LOOK FOR ACCUS IF ALREADY PRESENT
ADDCOM   EQU   *
         OI    SWIPRT2,ONLYDIG    ONLY THE DIGIT IS REQUIRED
         BAL   R15,DIGLIT
         NI    SWIPRT2,255-ONLYDIG     CLEAR THE SWITCH
         LTR   R1,R1         WAS A COUNT OF ZERO ?
         BZ    ZEROWAS2      YES, DON'T REDUCE
         TM    SWIPRT2,SAVING IS SAVE SWITCH SET ?
         BO    DONTCOMP .    YES, NO CHECK IS TO BE MADE
         TM    SWTAB,TABINTPT OR IS TABLE INTERPRETATION ?
         BO    DONTCOMP .    YES, NO CHECK IS TO BE MADE
         CH    R1,ACCUNUM    IS THIS ACCU DEFINED ?              ***
         BH    ACCUERR       NO, INFORM THE USER                 ***
DONTCOMP EQU   *
         BCTR  R1,0          REDUCE COUNT BY ONE
ZEROWAS2 EQU   *
         SLL   R1,3        * 8 TO GET CORRECT ACCU DISPLACE MENT
*              THIS FIRST DIGIT IS A ACCU NUMBER
         STH   R1,FMTCNT     STORE ACCU-DISPLACE MENT TO FORMAT ENTRY
         TM    SWIPRT2,PDKONST         IS A DECIMAL KONST EXPECTED
         BCR   1,R14         YES, RETURN TO KONST ROUTINE
GETACCU2 EQU   *
         L     PNT,PNTSAV    GET ACTUAL POINTER
         MVI   IKOMMA,0      REMOVE THE KOMMA TEST
         MVI   IRKLAM,4      AND SET THE TEST FOR RIGHT PARANTHESES
         EX    LEN,TRT       TEST FOR RIGTH PARANTHESES
         BZ    INVALID2      IF NONE FOUND => ERROR
         BAL   LNK,DIGIT     GET THE COUNT
         LTR   R1,R1         WAS ZERO SPECIFIED ?
         BZ    ZEROWAS3      YES, DON'T REDUCE
         TM    SWOPEN,SECDIGAC IS SECOND DIGIT AN ACCU NUMBER ?
         BZ    DONTCMP2 .    DON'T COMPARE WITH MAX NUM
         NI    SWOPEN,255-SECDIGAC CLEAR THE SWITCH
         CH    R1,ACCUNUM .       IS THIS NUMBER ALLOWED ?
         BH    ACCUERR .          NO, INDICATE ERROR
DONTCMP2 EQU   *
         BCTR  R1,0          REDUCE THE COUNT BY ONE
ZEROWAS3 EQU   *
         STH   R1,FMTAKU#    STORE THE COUNT TO FORMAT ENTRY
         TM    SWTAB,TABINTPT IS TABLE INTERPRETATION ?
         BO    TABDEF        YES, GO TO DEFINE THE TABLE
         TM    SWTAB,COMPAC  IS ACCU-COMPARE ?
         BO    ACCMPPRP      YES, GO TO PREPARE ACCUS
         TM    SWIPRT2,SAVING  WAS ACTION SAVE OR COMP ?
         BO    SAVETEST      YES, GO TO SPECIAL UPDATE ROUTINE
         NC    FMTAKU#+1(1),CONCOD2    FORCE LENGTH TO FIT OUTPUT
         LA    R0,FMTAKU#+L'FMTAKU#-FMTDSECT   GET LENGTH OF THIS ENTRY
UPDATCAC EQU   *
         NI    SWIPRT1,255-KONSTCMP    CLEAR THE SWITCH
         MVC   FMTAKU#(1),CONCODE      IF ACCU COMPARE, ZERO ELSE
         B     CONDUPDT
COMPE@   EQU   *
         MVI   CONCODE,EQUAL MOVE THE REQUIRED CONDITION CODE
         B     SAVE@         SAME AS SAVE
COMPH@   EQU   *
         MVI   CONCODE,HIGH  MOVE THE REQUIRED CONDITION CODE
         B     SAVE@         SAM
COMPL@   EQU   *
         MVI   CONCODE,LOW   MOVE THE REQUIRED CONDITION CODE
         B     SAVE@
COMPU@   EQU   *
         MVI   CONCODE,UNEQUAL MOVE THE REQUIRED CONDITION CODE
         B     SAVE@
IFEQ@    EQU   *
FINDE@   EQU   *
         MVI   CONCODE,EQUAL MOVE THE CONDITION CODE
         B     DIGLIT        AND TRY TO GET THE LITERAL RESOLVED
IFGE@    EQU   *
         MVI   CONCODE,HIGHEQ MOVE REQUIRED CONDITION-CODE
         B     DIGLIT
IFGT@    EQU   *
FINDH@   EQU   *
         MVI   CONCODE,HIGH  MOVE THE CONDITION CODE
         B     DIGLIT        AND TRY TO GET THE LITERAL RESOLVED
IFLE@    EQU   *
         MVI   CONCODE,LOWEQ MOVE REQUIRED CONDITION-CODE
         B     DIGLIT
IFLT@    EQU   *
FINDL@   EQU   *
         MVI   CONCODE,LOW   MOVE THE CONDITION CODE
         B     DIGLIT        AND TRY TO GET THE LITERAL RESOLVED
FINDU@   EQU   *
IFNE@    EQU   *
         MVI   CONCODE,UNEQUAL
         B     DIGLIT        AND TRY TO GET THE LITERAL RESOLVED
FIRST@   EQU   *
         B     UPDAT4        UPDATE A 4-BYTE ENTRY
IFACE@   EQU   *
         OI    SWOPEN,SECDIGAC
         MVI   CONCOD2,255
         MVI   CONCODE,EQUAL   MOVE THE REQUIRED CONDITION-CODE
         B     ADDCOMA       GO TO COMMON ADD (ACCU) ROUTINE
IFACH@   EQU   *
         OI    SWOPEN,SECDIGAC
         MVI   CONCOD2,255
         MVI   CONCODE,HIGH    MOVE THE REQUIRED CONDITION-CODE
         B     ADDCOMA       GO TO COMMON ADD (ACCU) ROUTINE
IFACL@   EQU   *
         OI    SWOPEN,SECDIGAC
         MVI   CONCOD2,255
         MVI   CONCODE,LOW     MOVE THE REQUIRED CONDITION-CODE
         B     ADDCOMA       GO TO COMMON ADD (ACCU) ROUTINE
IFACU@   EQU   *
         OI    SWOPEN,SECDIGAC
         MVI   CONCOD2,255
         MVI   CONCODE,UNEQUAL MOVE THE REQUIRED CONDITION-CODE
         B     ADDCOMA       GO TO COMMON ADD (ACCU) ROUTINE
SETL@@   EQU   *
         LR    FUNC,R14      RESET ALREADY UPDATED REGISTER
         LH    R1,10(FUNC)   GET THE LITERAL LENGTH
         STH   R1,FMTAKU#    STORE IT TO PLACE EXPECTED BY SAVE-ROUTINE
         B     SAVELOOP      AND LOOK IF ACCU ALREADY PRESENT
MVTAB@   EQU   *
         OI    SWIPRT2,ONLYDIG    INDICATE THAT ONLY DIGIT IS REQUIRED
         BAL   R15,DIGLIT    GO TO GET THE DIGIT
         NI    SWIPRT2,255-ONLYDIG  CLEAR THE SWITCH
         BCTR  R1,0
         STH   R1,FMTCNT     STORE REDUCED DISPLACEMENT TO FORMAT
         MVI   CONCOD2,255   MAXIMUM LENGTH
         B     GETACCU2
*
ACTOVFL  EQU   *
         TM    SWINPUT,ACTFULL  IS ACTION TABLE ALREADY FULL
         BO    TRYNEXT
         OI    SWINPUT,ACTFULL INDICATE THIS CONDITION
         MVC   ACARDOUT(L'ACTMSG),ACTMSG MOVE THE MESSAGE
         B     OVERFLOW
FMTOVFL  EQU   *
         L     FUNC,AFORMAT   SET FORMAT POINTER BACK
         ST    FUNC,AFORMAT@  TO START OF TABLE
         TM    SWINPUT,FMTFULL  IS FORMAT TABLE ALREADY FULL
         BO    TRYNEXT
         OI    SWINPUT,FMTFULL INDICATE THIS CONDITION
         MVC   ACARDOUT(L'FMTMSG),FMTMSG MOVE THE MESSAGE
OVERFLOW MVC   AADVERB(8),=C'INCREASE'
         MVC   ASUBJECT+1(5),=C'POWER'
         B     PUTMSG        PUT THE ERROR MESSAGE AND PREVENT UPDATE
ORENDTST EQU   *
         TM    CONCODE,X'F0' WAS THIS A COMPARISON INSTRUCTION ?
         BCR   8,R15         IF NOT, RETURN
         LR    LIMIT,SW      WAS CURRENT ENTRY AN 'OR' - ENTRY ?
         SH    LIMIT,=H'4'
         TM    0(LIMIT),ORENTRY
         BCR   8,R15         IF ZERO, RETURN
         ST    FUNC,0(SW)    PRODUCE AN 'OREND' - ENTRY
         OI    0(SW),ODERENDE  INDICATE END OF OR'S
         LA    SW,4(SW)      SET POINTER UP
         ST    SW,ACTION@    AND SAVE IT
*              THIS ENTRY MUST BE OVERRIDDEN, IF ANOTHER 'OR' FOLLOWS
         BR    R15           RETURN
TABEQ@   EQU   *
TABNE@   EQU   *
         OI    SWTAB,TABINTPT INDICATE TABLE INTERPRETATION
         B     ADDCOM        GO TO GET THE PARAMETERS
TABDEF   EQU   *
         NI    SWTAB,255-TABINTPT      CLEAR THE SWITCH
         LH    R1,FMTCNT     ACCU-ID - 1) * 8
         A     R1,ATABENTR   ADD BASE OF VECTOR
         ST    R1,DW         SAVE THE POINTER
         L     R15,0(R1)     POINTER TO TABLE
         LTR   R15,R15       IS TABLE WITH THIS ID ?
         BZ    TABERR        NO, MUST BE ERROR
TABUPDAT EQU   *
         MVC   FMTLIT(4),DW  BRING ENTRY TO FORMAT
         LA    R0,12
         B     COMUPDAT      GO TO COMMON UPDATE ROUTINE
LOADNUMT EQU   *
         AIF   (&S).TNUM
*        LOAD  BGENTNUM      LOAD ASSOCIATED TABLE
         LOAD  BGENTNUM
         AGO   .TNUME
.TNUM    ANOP
*        LOAD  EP=GENTNUM    LOAD ASSOCIATED TABLE
         LOAD  EP=GENTNUM
.TNUME   ANOP
         B     NUMEND
LOADN99T EQU   *
         AIF   (&S).T99P
*        LOAD  BGENT99P      LOAD ASSOCIATED TABLE
         LOAD  BGENT99P
         AGO   .T99PE
.T99P    ANOP
*        LOAD  EP=GENT99P    LOAD ASSOCIATED TABLE
         LOAD  EP=GENT99P
.T99PE   ANOP
NUMEND   EQU   *
         ST    R0,DW .       STORE ADDRESS  FOR ALIGNMENT
         NI    SWIPRT1,255-NUMLIT-NUMPACK CLEAR NUMERICTEST SWITCHES
         B     TABUPDAT .    DO SAME UPDATE AS IF TABLE SPECIFIED
NOT99@   EQU   *
         OI    SWIPRT1,NUMLIT INDICATE NUMERIC TEST REQUIRED
         B     SAVE@ .       AND DO SAME AS SAVE
NOT9P@   EQU   *
         OI    SWIPRT1,NUMPACK INDICATE PACKED TEST REQUIRED
         B     SAVE@ .       AND DO SAME AS SAVE
IFSVE@   EQU   *
         MVI   CONCODE,EQUAL SET CONDITION-CODE
         B     ACCUCOMP
IFSVH@   EQU   *
         MVI   CONCODE,HIGH  SET CONDITION CODE
         B     ACCUCOMP
IFSVL@   EQU   *
         MVI   CONCODE,LOW   SET CONDITION CODE
         B     ACCUCOMP
IFSVU@   EQU   *
         MVI   CONCODE,UNEQUAL SET CONDITION CODE
ACCUCOMP EQU   *
         MVI   CONCOD2,255
         OI    SWTAB,COMPAC
         B     GET2DIGS      GET TWO DIGITS
GETACUL  EQU   *
         STH   R1,INDEX      SAVE THE LENGTH CODE
         B     GETACCU2
ACCMPPRP EQU   *
         LH    R0,INDEX      GET LENGTH OF COMPARE
         LH    R1,FMTAKU#    GET 2. ACCU ID
         STH   R1,INDEX      SAVE THIS ID
         BCTR  R0,0          REDUCE LENGTH FOR EXECUTE
         LTR   R0,R0         TEST IF MINUS
         BNM   *+6 IF PLUS OR ZERO LET IT
         SR    R0,R0         SET IT TO ZREO (ONE) IF IT WAS ZEREO
         STH   R0,FMTAKU#    SET LENGTH OF COMPARE (AND ACCU TO DEFINE
         B     SAVELOOP
ACCMP2P  EQU   *
         OI    SWTAB,COMPAC2 SET UP FLAG FOR SECOND ACCU
         MVC   FMTCNT+1(1),INDEX+1  2. ACCU'S ID
         B     SAVELOP2
ACC2UPDT EQU   *
         NI    SWTAB,255-COMPAC-COMPAC2 CLEAR THE SWITCH
         MVC   FMTAKU#+6(4),DW BRING 2. ACCU ADDRESS TO FORMAT
         LA    R0,16         LENGTH OF FORMAT EMTRY
         B     IFSVUPD
TRT      TRT   0(0,PNT),IPRTTAB        TRT   FOR EXECUTE
MVCBLANK MVC   1(0,PNT),0(PNT) BLANK REST OF THE CARD
DOLLARWS EQU   *
         BCTR  LEN,0
         LA    R0,1(R1)      UPDATE POINTER
         ST    R0,PNTSAV
         L     R1,ADRUPS     ADDRESS OF UP-VECTOR
         LTR   R1,R1         IS IT ALREADY
         BNZ   UPVECTIS       YES
         LH    R0,ANZUPS     IF NOT ESTABLISH IT
         SLL   R0,2          MAX NO. OF UP'S * 4
         LR    LIMIT,R0      SAVE LENGTH
         AIF   (&S).OSGM6
*        EXTGM R,LV=(0),MOD=VGM
         EXTGM R,LV=(0),MOD=VGM
         AGO   .OVGM6
.OSGM6   ANOP
*        GETMAIN R,LV=(0)    GET CORE
         GETMAIN R,LV=(0)    GET CORE
.OVGM6   ANOP
         ST    R1,ADRUPS     STORE ADDRESS
         BCTR  LIMIT,0
         EX    LIMIT,XC      CLEAR THE VECTOR
         SR    LIMIT,LIMIT   AND TRT-REG
UPVECTIS EQU   *
         MVC   0(STOPLEN,FUNC),FMTSTOP SET END OF FORMAT
         LA    FUNC,STOPLEN(FUNC)      AND UPDATE FORMAT POINTER
         L     PNT,PNTSAV    GET POINTER REG CORRECT
         LA    R1,2(PNT)     SET TO END OF DIGIT
         BAL   LNK,DIGIT22   LINK TO SECOND DIGIT CONVERT ROUTINE
         CH    R1,ANZUPS .   IS THIS NUMBER ALLOWED ?
         BH    DOERROR .     NO, INDICATE ERROR
         LTR   R1,R1 .       TEST IF ZERO
         BNP   DOERROR .     ZERO OR NEGATIVE NOT ALLOWED
         L     R15,ADRUPS    POINT TO VECTOR
         BCTR  R1,0
         SLL   R1,2          ID * 4
         ST    FUNC,0(R1,R15) SET ADDRESS OF FORMAT TO ENTRY
         ST    FUNC,AFORMAT@  SAVE FORMAT POINTER
         B     TRYNEXT
DOFND    EQU   *
         LA    PNT,3(PNT)    SET OVER KEYWORD
         LA    R1,2(PNT)     POINT TO END OF ID
         BAL   LNK,DIGIT22   LINK TO SECOND DIGIT CONVERT ROUTINE
         CH    R1,ANZUPS     IS NUMBER VALID ?
         BH    DOERROR       NO
         LA    R0,ODO@-GENOUT DISPLACEMENT IN GENMOD
         STH   R0,FMTCODE    SET THE CODE TO FORMAT
         BCTR  R1,0
         SLL   R1,2          ID * 4
         L     R15,ADRUPS    GET ADDRESS OF VECTOR TABLE
         L     R14,0(R1,R15) IS SUCH AN UP
         LTR   R14,R14
         BZ    DOERROR
         ST    R14,DW
         MVC   FMTCNT(4),DW    BRING ENRTY TO FORMAT
         L     PNT,PNTSAV    POINT TO CHARACTER BEHIND DIGIT
         CLI   0(PNT),LKLAM  IS IT A LEFT PARANTHESES ?
         BE    REPETIS       YES, ASSUME REPETITION COUNT IN BRACKETS
         LA    R1,1          IF NOT, 'DO' SHOULD BE DONE ONCE
DOUPDAT  EQU   *
         STH   R1,FMTLIT+2   STORE THE REPETITION COUNT
         LA    R0,12         LENGTH OF THIS FORMAT ENTRY
         B     COMUPDAT      GO TO COMMON UPDATE ROUTINE
REPETIS  EQU   *
         LA    PNT,1(PNT)    SET POINTER OVER LEFT PARANTHESES
         BCTR  LEN,0
         XC    IPRTTAB,IPRTTAB CLEAR THE TRANSLATE TABLE
         MVI   IRKLAM,4      ONLY RIGHT PARANTHES IS REQUIRED
         EX    LEN,TRT       SEARCH FOR IT
         EX    LEN,TRT
         BZ    INVALID2      NONE FOUND ==> MUST BE ERROR
         BAL   LNK,DIGIT     CONVERT THE COUNT IN PARANTHESES
         B     DOUPDAT
         B     COMUPDAT
DOERROR  EQU   *
         MVC   AACTION,=CL8'SUCH UP'   MOVE EXPLAINING MESSAGE
         B     OPERRMSG      PUT THE MESSAGE
TABERR   EQU   *
         MVC   AACTION,=CL8'SUCH TAB'  MOVE MESSAGE
         B     OPERRMSG
ACCUERR  EQU   *                                                 ***
         MVC   AACTION-1(9),=CL9'SUCH ACCU'  MOVE EXPLANATION    ***
         B     OPERRMSG                PUT THE MESSAGE           ***
ATAB3    DC    A(TAB3T)      ADDRESS OF KEYS WITH 3 BYTES LENGTH
ATAB4    DC    A(TAB4T)      ADDRESS OF KEYS WITH 4 BYTES LENGTH
ATAB5    DC    A(TAB5T)      ADDRESS OF KEYS WITH 5 BYTES LENGTH
VCONVEX  DC    V(CONVEX)     ADDR OF CONVERSION EBCDIC TO HEX
         LTORG
FMTSTOP  DC    H'4'
         DC    AL2(OSTOP@-GENOUT)
STOPLEN  EQU   *-FMTSTOP
AMVCLONG DC    AL2(OMVCLONG-GENOUT)    ADDRESS OF MOVE ROUTINE FOR LONG
ERRMSG   DC    C'*** ERROR **'
ACTMSG   DC    C'TOO MANY FORMAT-ENTRIES'
FMTMSG   DC    C'FORMAT-TABLE OVERFLOW'
MODELDCB DC    CL8'GENDCBS'  CSECT NAME OF MODELDCB'S
         TITLE 'BASFGEN KEY-WORD AND ADDRESS TABLE'
*        GENSORT COUNT,CNT0,RSTC,
         GENSORT COUNT,CNT0,RSTC,                                      *
               NEXT,SAME,PRINT,WLOG,                                   *
               SCAN,                                                   *
               SAVE,SETL,PUTL,                                         *
               SEP,END,                                                *
               AND,UND,ODER,                                           *
               TABEQ,TABNE,                                            *
               DIV,MULT,                                               *
               ACKTE,ACKTL,ACKTH,ACKTU,                                *
               UNPAC,PCKAC,                                            *
               BINAC,NOT99,NOT9P,                                      *
               FMT,                                                    *
               FIRST,LAST,                                             *
               SUBPD,SUBKT,SUBCH,SUBBI,SUBAC,                          *
               ADDKT,ADDPD,ADDCH,ADDBI,ADDAC,                          *
               MOVE,MOVER,MOVEL,MOVEM,MOVEN,MOVEZ,MOVEX,               *
               NEXTC,MVTAB,                                            *
               IGNI,IGNO,PNTI,PNTO,RSTI,RSTO,                          *
               EDAC,EDIT,                                              *
               COMPE,COMPL,COMPH,COMPU,                                *
               IFEQ,IFNE,IFLE,IFLT,IFGE,IFGT,                          *
               IFACE,IFACH,IFACL,IFACU,                                *
               IFSVE,IFSVH,IFSVL,IFSVU,                                *
               DATM,DMP,                                               *
               TIME,DATE
ORFMT    EQU   ODER+8
         DROP  R13,BAS,PRM,FUNC,WK2
         TITLE ' BASFGEN DATEN-MODIFIKATIONS-ROUTINE    '
*              DIESES PROGRAMM MODIFIZIERT EINGABE-RECORDS
*              NACH DEN ANGABEN DER FORMAT-STATEMENTS
*
*              AUTHOR: H. FRANZ
*
IPRTWORK DSECT
SAVEAREA DS    18F
DW       DS    D
PNTSAV   DS    F
LFP3     DS    CL28          PARAMETERS FOR TABLE 3
LFP4     DS    CL28          PARAMETERS FOR TABLE 4
LFP5     DS    CL28          PARAMETERS FOR TABLE 5
         DS    0D
IPRTTAB  DS    0CL256        INTERPRETATION TABLE FOR 'TRT'
         DC    256X'0'
         ORG   IPRTTAB+C'='  DIE MOEGLICHEN TRENNZEICHEN
IEQUAL   EQU   *
         ORG   IPRTTAB+C','  WERDEN PER 'MVI' IN DIE
IKOMMA   EQU   *
         ORG   IPRTTAB+C'$'
IDOLLAR  EQU   *
         ORG   IPRTTAB+C'*'  TABELLE GEBRACHT
ISTERN   EQU   *
         ORG   IPRTTAB+C'('  UND PER 'TRT' IHR VORHANDENSEIN
ILKLAM   EQU   *
         ORG   IPRTTAB+C')'  GETESTET.
IRKLAM   EQU   *
         ORG   IPRTTAB+X'7D'
IAPOST   EQU   *
         ORG   IPRTTAB+C'0'  DIGIT FIELDS
IZIFF    DS    CL10
         ORG
SAVEODAD DS    F             SAVE EODAD ADDRESS
PARM3    DS    3F            LFDNR-PARAMETER FUER TAB3
PARM4    DS    3F            LFDNR-PARAMETER FUER TAB4
PARM5    DS    3F            LFDNR-PARAMETER FUER TAB5
AFORMAT@ DS    F             ACTUALFORMATPOINTER
ACTION@  DS    F             ACTUAL POINTER TO ACTIONS
LNKSAV   DS    F             1. SAVE WORD FOR LINKREGISTER
LNKSAV2  DS    F             2. SAVE WORD FOR LINKREGISTER
LENSAV   DS    F             SAVEWORD FOR LENGTH REGISTER
BCTCOUNT DS    F             REPETIION COUNT FOR LITERALS
INDEX    DS    H             TABLE-POSITION OF KEYWORD IF FOUND
INCRSAV  DS    H
CONCOD2  DS    CL1           SWITCH BYTE FOR MAXIMUM LENGTH ATTRIBUTES
CONCODE  DS    CL1           CONDITION CODE FOR COMPARISONS
DUMEND   DS    0D
PARMLEN  EQU   DUMEND-IPRTWORK
         AIF   (&SD).NODCBS
         SPACE 3
SEPENTRY DSECT
LINKFLD  DS    F             POINTER TO NEXT ENTRY
DCBID    DS    0CL1          BINARY ID FOR DCB-NUMBER
DCBADR   DS    F             POINTER TO THE DCB
PUTCOUNT DS    F             NUMBER OF PUTS AGAINST THIS DCB
AASTCODE DS    F             A (AST-CODE AND TABLE)
.NODCBS  ANOP
         SPACE 3
SAVDSECT DSECT
LNKFLD   DS    F             POINTER TO NEXT SAVE-ENTRY
SAVID    DS    0CL1          IDENTIFICATION BYTE
SAVADR   DS    F             ADDRESS OF THE SAVBER
         SPACE 3
         MEND
./ ADD  NAME=GENJCL
//Z227HF   JOB (6600,128,1),
//   FRANZ,MSGLEVEL=1,PRTY=11,
// COND=(4,LE),MSGCLASS=A,
//   REGION=500K,CLASS=B,TIME=3
//GENDOS PROC CL=A,
//   SRC='OX.A6600.I128SRC',
//   MAC='SYS1.OCRLIB'
//GENDOS EXEC  PGM=IEUASM,
//   PARM='DECK,NOLOAD',
//   REGION=500K
//SYSLIB DD DSN=&SRC,DISP=SHR
//  DD  DSN=&MAC,DISP=SHR
//SYSUT1 DD UNIT=DISK,SPACE=(CYL,(10,2))
//SYSUT2 DD UNIT=DISK,SPACE=(CYL,(10,2))
//SYSUT3 DD UNIT=DISK,SPACE=(CYL,(10,2))
//SYSGO  DD UNIT=DISK,SPACE=(CYL,(01,2))
//SYSPRINT DD SYSOUT=&CL,
//   DCB=(RECFM=FBM,BLKSIZE=3146),SPACE=(CYL,(15,5))
//SYSPUNCH DD SYSOUT=B,DCB=BLKSIZE=3040
//       PEND
//GENMOD PROC  CL=A,
//   BIN='OX.A6600.I128BIN',
//   LMOD='OX.A6600.I128MOD'
//GENMOD EXEC PGM=IEWL,PARM='RENT,XREF,LIST,REFR',REGION=500K
//SYSLMOD DD DSN=&LMOD,DISP=SHR
//SYSLIB DD DSN=&BIN,DISP=SHR
//SYSUT1 DD DSN=&&UT1,UNIT=DISK,SPACE=(CYL,(1,1))
//SYSPRINT DD SYSOUT=&CL,DCB=BLKSIZE=605
//SYSLIN DD DDNAME=SYSIN
//       PEND
//GENBIN PROC  MBR=1,CL=A,
//   BIN='OX.A6600.I128BIN',
//   SRC='OX.A6600.I128SRC'
//GENBIN EXEC  PGM=IEUASM,PARM=(DECK,NOLOAD),REGION=500K
//SYSLIB DD DSN=&SRC,DISP=SHR
//       DD DSN=SYS1.MACLIB,DISP=SHR
//SYSUT1 DD UNIT=DISK,SPACE=(CYL,(3,2)),DSN=&&UT1
//SYSUT2 DD UNIT=DISK,SPACE=(CYL,(3,2)),DSN=&&UT2
//SYSUT3 DD UNIT=DISK,SPACE=(CYL,(3,2)),DSN=&&UT3
//SYSGO  DD DSN=&LOADSET,UNIT=DISK,SPACE=(CYL,(1)),DCB=BLKSIZE=80
//SYSPRINT DD SYSOUT=&CL,DCB=(RECFM=FBSM,BLKSIZE=3146),
//   SPACE=(CYL,(15,5))
//SYSPUNCH DD DSN=&BIN(&MBR),DISP=SHR
//       PEND
//COPY EXEC PGM=IEBCOPY,REGION=500K
//SYSUDUMP DD SYSOUT=A
//SYSPRINT DD SYSOUT=A
//SYSUT3 DD DSN=A,UNIT=DISK,SPACE=(TRK,90)
//SYSUT4 DD DSN=AZ,UNIT=DISK,SPACE=(TRK,90)
//NSRC DD DSN=OX.A6600.I128SRC,DISP=SHR
//NBIN DD DSN=OX.A6600.I128BIN,DISP=SHR
//NMOD DD DSN=OX.A6600.I128MOD,DISP=SHR
//MAC DD DSN=LU.MACLIB,DISP=SHR
//SYSIN DD *
         COPY  I=MAC,O=NSRC
         SELECT  MEMBER=((SYSDATE,,R))
     COPY  I=NSRC,O=NSRC
   COPY I=NBIN,O=NBIN
   COPY I=NMOD,O=NMOD
//S1  EXEC GENBIN,
//   MBR=BASFGEN
//GENBIN.SYSIN DD *
         BASFGEN
         END
//S2  EXEC GENBIN,
//   MBR=GENAST
//GENBIN.SYSIN DD *
         GENAST
         END
//S3  EXEC GENBIN,
//   MBR=GENCORE
//GENBIN.SYSIN DD *
         GENCORE
         END
//S4  EXEC GENBIN,
//   MBR=GENDCBS
//GENBIN.SYSIN DD *
GENDCBS  CSECT
         GENDCBS
         END
//S5  EXEC GENBIN,
//   MBR=GENDUMP
//GENBIN.SYSIN DD *
         GENDUMP
         END
//S6  EXEC GENBIN,
//   MBR=GENFUNC
//GENBIN.SYSIN DD *
         GENFUNC
         END
//S7  EXEC GENBIN,
//   MBR=GENGET
//GENBIN.SYSIN DD *
         GENGET
         END
//S8  EXEC GENBIN,
//   MBR=GENHEAD
//GENBIN.SYSIN DD *
         GENHEAD
         END
//S9  EXEC GENBIN,
//   MBR=GENIMS
//GENBIN.SYSLIB DD DSN=IMS.MACLIB,DISP=SHR
//  DD  DSN=OX.A6600.I128SRC,DISP=SHR
//   DD   DSN=SYS1.MACLIB,DISP=SHR
//GENBIN.SYSIN DD *
         GENIMS
         END
//S10 EXEC GENBIN,
//   MBR=GENINPUT
//GENBIN.SYSIN DD *
         GENINPUT
         END
//S11 EXEC GENBIN,
//   MBR=GENMOD
//GENBIN.SYSIN DD *
         GENIPRT
         GENOUT
         END
//S12 EXEC GENBIN,
//   MBR=GENOPEN
//GENBIN.SYSIN DD *
         GENOPEN
         END
//S13 EXEC GENBIN,
//   MBR=GENPARM
//GENBIN.SYSIN DD *
         GENPARM
         END
//S14 EXEC GENBIN,
//   MBR=GENREAD
//GENBIN.SYSIN DD *
         GENREAD
         END
//S15 EXEC GENBIN,
//   MBR=GENSCAN
//GENBIN.SYSIN DD *
         GENSCAN
         END
//S16 EXEC GENBIN,
//   MBR=GENSTAT
//GENBIN.SYSIN DD *
         GENSTAT
         END
//S17 EXEC GENBIN,
//   MBR=GENSYNBS
//GENBIN.SYSIN DD *
         GENSYNBS
         END
//S18 EXEC GENBIN,
//   MBR=GENSYNIS
//GENBIN.SYSIN DD *
         GENSYNIS
         END
//S19 EXEC GENBIN,
//   MBR=GENSYNQS
         GENSYNQS
         END
//S20 EXEC GENBIN,
//   MBR=GENTABLE
//GENBIN.SYSIN DD *
         GENTABLE
         END
//S21 EXEC GENBIN,
//   MBR=GENT99P
//GENBIN.SYSIN DD *
         GENT99P
         END
//S22 EXEC GENBIN,
//   MBR=GENTNUM
//GENBIN.SYSIN DD *
         GENTNUM
         END
//S23    EXEC  GENBIN,
//   MBR=GENSAVE
//GENBIN.SYSIN DD *
GENSAVE  CSECT
         GENSAVE
         END
//RENT EXEC GENMOD
//GENMOD.SYSIN DD *
     INCLUDE SYSLIB(BASFGEN)
     NAME  BASFGEN(R)
     INCLUDE SYSLIB(BLANKEX)
     NAME  BLANKEX(R)
     INCLUDE SYSLIB(GENCORE)
     NAME  GENCORE(R)
     INCLUDE SYSLIB(GENDUMP)
     NAME  GENDUMP(R)
     INCLUDE SYSLIB(GENFUNC)
     NAME  GENFUNC(R)
     INCLUDE SYSLIB(GENGET)
     NAME  GENGET(R)
     INCLUDE SYSLIB(GENINPUT)
     NAME  GENINPUT(R)
     REPLACE  GENMOD,GENOUT,GENSTAT,DLITCBL
     INCLUDE SYSLIB(GENMOD)
     NAME  GENIPRT(R)
     REPLACE  GENIPRT,CONVEX
     INCLUDE SYSLIB(GENMOD)
     ALIAS  GENMOD
     ENTRY  GENOUT
     NAME  GENOUT(R)
     INCLUDE SYSLIB(GENOPEN)
     NAME  GENOPEN(R)
     INCLUDE SYSLIB(GENPARM)
     NAME  GENPARM(R)
     INCLUDE SYSLIB(GENREAD)
     NAME  GENREAD(R)
     INCLUDE SYSLIB(GENSCAN)
     NAME  GENSCAN(R)
     INCLUDE SYSLIB(GENTNUM)
   NAME GENTNUM(R)
     INCLUDE SYSLIB(GENT99P)
   NAME GENT99P(R)
//REUS EXEC GENMOD,
//   PARM='LIST,XREF,REUS'
//GENMOD.SYSIN DD *
  INCLUDE SYSLIB(GENAST)
   NAME GENAST(R)
    INCLUDE SYSLIB(GENSAVE)
     NAME  GENSAVE(R)
//NORENT EXEC GENMOD,
//   PARM.GENMOD='XREF,LIST'
//GENMOD.SYSIN DD *
     INCLUDE SYSLIB(GENSYNBS)
     NAME  GENSYNBS(R)
     INCLUDE SYSLIB(GENSYNIS)
     NAME  GENSYNIS(R)
     INCLUDE SYSLIB(GENSYNQS)
     NAME  GENSYNQS(R)
     INCLUDE SYSLIB(GENTABLE)
     NAME  GENTABLE(R)
//IMSLINK EXEC GENMOD,
//   PARM.GENMOD='XREF,LIST'
//GENMOD.SYSIN DD *
    INCLUDE SYSLIB(GENIMS)
    NAME    GENIMS(R)
//LINKOL EXEC GENMOD,
//   PARM.GENMOD='XREF,LIST,OL'
//GENMOD.SYSIN DD *
     INCLUDE SYSLIB(GENDCBS)
     NAME  GENDCBS(R)
    INCLUDE SYSLIB(GENT99P)
    NAME    GENT99P(R)
    INCLUDE SYSLIB(GENTNUM)
    NAME    GENTNUM(R)
//
./ ADD  NAME=GENOPEN
         MACRO
         GENOPEN &SYS=OS
         AIF   ('&SYS' EQ 'DOS').COP
         AIF   ('&SYS' EQ 'OS').COP
         MNOTE 12,'SYSTEM NOT SUPPORTED, SPECIFY DOS OR OS'
         MEXIT
.COP     ANOP
         BGENMAC SYS=&SYS
         TITLE ' OPEN-ROUTINE FUER DIE STANDARD BASFGEN DATEIEN'
GENOPEN  CSECT
*
*              DIE UNBEDINGT VORHANDEN SEIN MUESSEN
*
*              AUTHOR:  H. FRANZ
*              DIESE ROUTINE EROEFFNET DIE DATEIEN FUER BASFGEN,
*
         AIF   ('&SYS' EQ 'OS').OSXS
*        EXTXS BAS,SAVEAREA,GENOPEN,TYP=F
         EXTXS BAS,SAVEAREA,GENOPEN,TYP=F
         AGO   .ENDSAVE
.OSXS    ANOP
*        XSAVE BAS,,GENOPEN,PARMLEN
         XSAVE BAS,,GENOPEN,PARMLEN
         LR    PRM,R1
         USING SAVEAREA,R13
.ENDSAVE ANOP
         USING MAINPARM,PRM
         AIF   ('&SYS' EQ 'OS').DMPOS
         SPACE 2
*   LOAD BASFGEN MODULE:  BGENDUMP
*        LOAD BGENDUMP
         LOAD BGENDUMP
         ST    R1,AGENDUMP   SAVE DUMP MOD ADDR
         AGO   .EDMPOS
.DMPOS   ANOP
         XC    SAVEAREA+72(PARMLEN-72),SAVEAREA+72 CLEAR REST OF DSECT
*        LOAD  EP=GENDUMP    GET THE RECORD DUMP MODUL
         LOAD  EP=GENDUMP    GET THE RECORD DUMP MODUL
         ST    R0,AGENDUMP   STORE IT TO ADDRESS POINTER
         SR    MSG,MSG       CLEAR REG TO CONTAIN SYNAD-ADDRESS LATER
         AGO   .DCBSOS
.EDMPOS  ANOP
         SPACE 2
         LA    WK1,ASEPDCBS  GET FIRST POINTER OF CHAIN
         ST    WK1,OLDDTF    SAVE IT FOR UNCHAIN
         L     LIMIT,ASEPDCBS LOAD ADDR OF DTF CHAIN
         USING DTFTAB,LIMIT
NXTDTF   EQU   *             GET NEXT DTF ENTRY
         CLI   ID,C'1'       IS SYSUT2 ?
         BNE   FIXED
         CLI   RECFM,C'V'    IS RECFM=V ?
         BNE   FIXED
         OI    SW4,ORECFMV   INDICATE V TO PUTROUTINE
FIXED    EQU   *
         MVI   LOADNAME+7,C' ' KILL A IF ASA BEFORE
         MVC   LOADNAME+4(3),INOUT GET NAME OF MOD READY
         TM    DTFFLAG,ASAPR WAS ASA=YES ?
         BZ    NOWLOAD
         MVI   LOADNAME+7,C'A' SET A TO END OF NAME
NOWLOAD  EQU   *
         SPACE 2
         SR    WK2,WK2       ZERO WORK REG
         LA    PNT,AMODTAB   PICK UP ADDR OF 1ST ENTRY
         USING MODTAB,PNT
FNDM     EQU   *             FIND MOD
         L     WK1,MODNXT    GET POINTER TO NEXT ENTRY
         LTR   WK1,WK1       IS THERE ANY FURTHER ONE ?
         BZ    SETNMOD       BUILD NEW ENTRY
         LR    PNT,WK1       SET BASE REG ON ENTRY START ADDR
         CLC   MODNAM,LOADNAME+4 NAME ALREADY IN TABLE ?
         BNE   FNDM          LOOK AGAIN
         CLC   MODASA,LOADNAME+7 OPFA AGAIN ?
         BNE   FNDM          EQ IF BOTH BLANK OR BOTH A
*        EQUAL NAME FOUND IN THIS ENTRY  ==> SEP DTF
         IC    WK2,MODCNT    GET COUNTER UNTIL NOW
         LA    WK2,1(,WK2)   USAGE COUNT +1
         STC   WK2,MODCNT    SAVE NEW COUNT
         CLI   MODCNT,3
         BL    LMODAD        IF NOT: LOAD MOD ADDR
         LA    R0,X'200'     LOAD INDICATOR REGISTER
*        DUMP
         DUMP
LMODAD   EQU   *
         L     R1,MODDTF     ENTRY ADDR
         SLL    WK2,2        MULTIPLY BY 4
         L     R1,0(WK2,R1)  GET ADDR OF DTF
         B     SAVEDTF       SKIP GETMAIN AND LOADING THE MODULE
SETNMOD  EQU   *             BUILD A NEW ENTRY
         LA    R0,MODTLL     GET LENGTH FOR NEW ENTRY
*        EXTGM R,LV=(0)
         EXTGM R,LV=(0),MOD=VGM
         ST    R1,MODNXT     STORE POINTER INTO OLD ENTRY
         LR    PNT,R1        GET NEW START ADDR
         XC    0(MODTLL,R1),0(R1) ZERO NEW
         MVC   MODNAM,LOADNAME+4 FILL TABLE WITH NAME
         MVC   MODASA,LOADNAME+7 MOVE "A" OR BLANK
         LA    R1,LOADNAME
*        LOAD  (1)
         LOAD  (1)
         ST    R1,MODDTF     STORE MODULE ADDR INTO ENTRY
         L     R1,0(R1)      LOAD DTF ADDRESS
SAVEDTF  EQU   *
         IC    WK1,ID        SAVE ID FROM BEING DESTROYED
         ST    R1,DTFAD      SAVE DTF ADDRESS IN TABLE
         STC    WK1,DTFAD    STORE ID BACK
         LR    WK1,R1        SAVE R1 TO BE DESTROYED BY FETCH
         LA    R14,AFETCH5   GET RETURN ADDRESS FROM FETCH ROUTINE
*        FETCH BGENDTF SUPPLY DTF WITH BLOCKSIZE, RECORD LENGTH,
*                      IOAREA DRRESS, ERROPT ADDRESS
         FETCH BGENDTF
AFETCH5  EQU   *
         LR    R1,WK1        GET DTF ADDR AGAIN
         CLI   ID,C'0'       WAS SYS000 = INPUT ?
         BNE   NOINP
         MVC   INPDEV,DEVTYPE SAVE DEVICE TYPE OF INPUT
         ST    R1,AINPUT     SAVE INPUT DTF ADDR
         B     OUTCHAIN      SCRATCH IT FROM CHAIN
NOINP    EQU   *             NOT INPUT
         CLI   ID,C'1'       SYS001 = SYSUT2 = OUTPUT 1    ?
         BNE   DEVOK         IF NOT EQ: SEP DTF
         ST    R1,AOUTPUT    SAVE OUTPUT DTF ADDR
OUTCHAIN EQU   *
         L     WK1,NXT       FIND POINTER TO NEXT
         L     WK2,OLDDTF    LOAD ADDR OF 1 BEFORE
         ST    WK1,0(WK2)    STORE "NEXT" TO "ONE BEFORE"
         OI    INDIC,OUTCH   ENTRY TAKEN OUT OF CHAIN
DEVOK    EQU   *
         BAL   LNK,OPENROUT  OPEN DTF
         L     WK2,NXT       ADDRESS OF NEXT
         LTR   WK2,WK2       LAST ALREADY PROCESSED ?
         BZ    DTFEND        YES, IF 0
         TM    INDIC,OUTCH   WAS THIS A NO-SEP DCB ?
         BO    SETLIMIT      IF YES: SKIP STORING ACTUAL AS OLD
         ST    LIMIT,OLDDTF  SAVE OLD ADDR FOR UNCHAIN
SETLIMIT EQU   *
         LA    LIMIT,ENTRYLL(LIMIT) SET ON NEXT ENTRY
         NI    INDIC,255-OUTCH NEXT TIME ZERO
         B     NXTDTF
DTFEND   EQU   *
*   IN DOS IT IS NOT USEFUL TO RETURN WITHOUT A DUMP, IF ONE OF
*   THE DTF'S COULD NOT BE OPENED. A CORRECT OPEN IS THEREFORE ASSUMED.
         OI    SWOPEN,INPOPEN+UT2OPEN ASSUME OPEN O.K.
*        LOAD  BGENGET
         LOAD  BGENGET
         ST    R1,AGETROUT
         SPACE 2
*ETURN   EXTXR 0
RETURN   EXTXR 0
         SPACE 2
OPENROUT EQU  *
*        OPENR (1)
         OPENR (1)
         BR    LNK
         SPACE 2
         LTORG
         AGO   .NOWOS1
.DCBSOS  ANOP
*        LOAD  EP=GENDCBS
         LOAD  EP=GENDCBS
         LR    LIMIT,R0
*
*              SET THE DEFAULT VALUES FOR DCB-SUBPARAMETERS OF SYSUT2
*
         MVI   OPNRECFM,RECFMFB SET DEFAULT VALUE
         LH    R0,DEFLRECL . GET THE DEFAULT LRECL FOR SYSUT2
         STH   R0,OPNLRECL . SET IT TO TEMP FIELD
         LH    R0,DEFBLKSI . GET THE DEFAULT BLOCKSIZE
         STH   R0,OPNBLKSI . SET IT TO TEMP FIELD
         USING GENDCBS,LIMIT
         USING IHADCB,WK2
*
*              OPEN ONE DCB AFTER THE OTHER
*
         MVI   DCBLIST,X'80'           INDICATE LAST DCB TO BE OPENED
         LA    PNT,SYSPRINT            MODEL-DCB  FOR SYSPRINT
         LA    LEN,PRINTLEN            DCB-LEN
         LA    WK1,PRINTEXL            EXIT-LIST ADDRESS
         LA    SW,OUTPUT               SWITCH FOR CORRECT OPEN ROUTINE
         BAL   LNK,OPENROUT            LINK TO OPEN ROUTINE
         TM    DCBOFLGS,ISOPEN         WAS OPEN SUCCESSFULL
         BZ    OPENIN                  NO, TRY NEXT
         BAL   LNK,GETREC              GET SPACE FOR AN OUTPUT LINE
         ST    R1,ALIST                SAVE THE ADDRESS
         OI    SWOPEN,PRTOPEN          SET SWITCH FOR OK
         ST    WK2,ALISTE              AND SAVE DCB-ADDRESS
OPENIN   LA    PNT,SYSIN
         LA    LEN,INLEN               SAME FOR SYSIN DCB
         LA    WK1,INEXLST
         LA    SW,INPUT
         BAL   LNK,OPENROUT
         TM    DCBOFLGS,ISOPEN
         BZ    OPENINP
         BAL   LNK,GETREC              GET SPACE FOR THE INPUT CARD
         ST    R1,ACARD                SAVE THE ADDRESS
         OI    SWOPEN,INOPEN
         ST    WK2,AKARTE
*
OPENINP  EQU   *
         LH    LEN,MAXRANGE            MAXIMUM INPUT SIZE FROM DATABASE
         TM    SW2,IMSORG              IS INPUT FROM DATABASE
         BO    DATABASE      PREPARE DATA-BASE PROCESSING
         TM    SW2,ISORG               IS INPUT ISAM
         BO    ISAM                    YES, TAKE ISAM DCB
         TM    SW2,PSORG     IS BSAM INPUT REQUIRED ?
         BO    BSAM          YES,GO TO BSAM ROUTINE
         LA    PNT,UT1SEQ
         LA    LEN,SEQLEN
*        LOAD  EP=GENGET     LOAD THE GET ROUTINE
         LOAD  EP=GENGET     LOAD THE GET ROUTINE
         ST    R0,AGETROUT   AND SAVE THE ADDRESS
*        LOAD  EP=GENSYNQS   GET SYNAD-ROUTINE FOR QSAM
         LOAD  EP=GENSYNQS   GET SYNAD-ROUTINE FOR QSAM
         LR    MSG,R0        LOAD SYSNAD REGISTER
OPNINPUT EQU   *
         LA    WK1,INEXLST
         LA    SW,INPUT
         BAL   LNK,OPENROUT
         TM    DCBOFLGS,ISOPEN         TEST IF OPEN WAS SUCCESSFUL
         BZ    OPENUT2                 IF NOT, TRY SYSUT2
         TM    DCBRECFM,RECFMU IS RECORD-FORMAT UNDEFINED ?
         BO    FIXED         YES, TREAT IT AS FIXED
         TM    DCBRECFM,RECFMV IS RECORD-FORMAT VARIABLE ?
         BZ    FIXED         NO, MUST BE FIX
         OI    SW4,IRECFMV   INDICATE THIS CONDITION TO READ ROUTINE
FIXED    EQU   *
         OI    SWOPEN,INPOPEN          SET SWITCH
         ST    WK2,AINPUT              AND SAVE DCB-ADDRESS
         LH    LEN,DCBBLKSI            GET BUFFER LENGTH FOR BSAM
         TM    SW2,IMSORG    IS INPUT FROM DATABASE
         BO    OPENUT2       YES, DON'T TRY TO SET SYNAD-ADDRESS
         IC    R15,DCBIOBL   SAVE IOB-LENGTH
         ST    MSG,DCBSYNAD  SET THE ADDRESS OF SYNAD-ROUTINE INTO DCB
         STC   R15,DCBIOBL   AND RESET LENGTH OF IOB
         TM    SW2,PSORG               WAS BSAM INPUT
         BZ    NORECREQ      NO ALLOCATION IS REQUIRED
*                            YES, ALLOCATE A BUFFER
         LH    R0,DCBLRECL    GET LRECL
         STH   R0,INLRECL    SAVE IT FOR USE DURING READ
GETBUF   EQU   *
*        GETMAIN R,LV=(LEN)
         GETMAIN R,LV=(LEN)
         ST    R1,AINBUF               SAVE BUFFER ADDRESS
         ST    LEN,INBUFLEN            AND ITS LENGTH
NORECREQ EQU   *
OPENUT2  LA    PNT,UT2                 AND NOW FOR OUTPUT-DCB
         LA    LEN,UT2LEN
         LA    WK1,UT2EXLST
         TM    SW2,IMSORG+ISORG IS INPUT ISAM OR DATASET IMS ?
         BNZ   NOEXCHNG      YES, DON'T EXCHANGE EXLISTS
         LA    WK1,UT2EX2    IF SEQUENTIELL, TAKE SPECIAL EXIT
NOEXCHNG EQU   *
         LA    SW,OUTPUT
         BAL   LNK,OPENROUT
         TM    OPNSW,RECVERR+RECUERR WAS AN ERROR AT SYSUT2 OPEN ?
         BNZ   UT2ERR .      YES, ANALYZE THE ERROR
         TM    DCBOFLGS,ISOPEN
         BZ    RETURN        REURN
         TM    DCBRECFM,RECFMU IS RECORD-FORMAT UNDEFINED ?
         BO    FIXED2        YES, TREAT IT AS FIXED
         TM    DCBRECFM,RECFMV IS RECORD-FORMAT VARIABLE ?
         BZ    FIXED2        NO, MUST BE FIX
         OI    SW4,ORECFMV   INDICATE THIS CONDITION TO PUT ROUTINE
FIXED2   EQU   *
         BAL   LNK,GETREC              GET SPACE FOR AN OUTPUT RECORD
         ST    R1,OUTREC
         AH    R1,DCBLRECL   ADD THE LRECL
         ST    R1,OUTRECLM   SAVE OUTPUT-RECORD UPPERLIMIT
         OI    SWOPEN,UT2OPEN
         ST    WK2,AOUTPUT             SAVE OUTPUT-DCB-ADDRESS
RETURN   EQU   *
*        DELETE EP=GENDCBS             MODEL-DCBS ARE NOT LONGER USED
         DELETE EP=GENDCBS             MODEL-DCBS ARE NOT LONGER USED
*        XRETURN 0,R
         XRETURN 0,R
DATABASE EQU   *
*        LOAD  EP=GENIMS     GET THE IMS ACCESS-MODUL
         LOAD  EP=GENIMS     GET THE IMS ACCESS-MODUL
         ST    R0,AGETROUT   AND SAVE ITS ADDRESS INTO PARMAREA
         OI    SWOPEN,INPOPEN SET SWITCH FOR INPUT OPEN
*                            AND HOPE THAT IMS WILL DO IT LATER
         B     GETBUF        NOW ALLOCATE THE BUFFER
ISAM     EQU   *
         LA    PNT,UT1ISAM
         LA    LEN,ISAMLEN
*        LOAD  EP=GENGET     FETCH THE GET ROUTINE
         LOAD  EP=GENGET     FETCH THE GET ROUTINE
         ST    R0,AGETROUT   AND POINT TO ENTRY POINT
*        LOAD  EP=GENSYNIS   GET SYNAD-ROUTINE FOR QISAM
         LOAD  EP=GENSYNIS   GET SYNAD-ROUTINE FOR QISAM
         LR    MSG,R0        AND LOAD SYNAD REGISTER
         B     OPNINPUT
BSAM     EQU   *
         LA    PNT,UT1BSAM   POINT TO THE REQUIRED DCB
         LA    LEN,BSAMLEN    LENGTH OF THE MODEL-DCB
*        LOAD  EP=GENREAD    LOAD THE READ ROUTINE
         LOAD  EP=GENREAD    LOAD THE READ ROUTINE
         ST    R0,AGETROUT   AND SAVE ITS ADDRESS
*        LOAD  EP=GENSYNBS   GET SYNAD ROUTINE FOR BSAM
         LOAD  EP=GENSYNBS   GET SYNAD ROUTINE FOR BSAM
         LR    MSG,R0        AND LOAD SYNAD REGISTER
         B     OPNINPUT      GO TO COMMON OPEN ROUTINE
         DS    0F
PRINTEXL DC    X'85'
         DC    VL3(LUDCBEX)
INEXLST  DC    X'85'
         DC    AL3(INPEXIT)
UT2EXLST DC    X'85'
         DC    VL3(LUDCBEX)
UT2EX2   DC    X'85'
         DC    AL3(GENOUTEX)
INPEXIT  EQU   *
         TM    DCBRECFM,X'48'  IS RECORD FORMAT VS ?
         BCR   14,R14        IF NOT, RETURN IMMEDIATELY
         OI    DCBBFTEK,BFTEKA IS YES, SET DCB BUFFER TECHNIQUE TO 'A'
         BR    R14           AND RETURN TO OPEN-SVC
GENOUTEX EQU   *
         CLI   DCBRECFM,X'0' WAS RECFM
         BNE   LOOKLREC      LET IT IF IT WAS SPECIFIED
         MVI   DCBRECFM,X'90' SET RECFM TO FB
         NC    DCBLRECL,DCBLRECL
         BNZ   LOOKBLKS      IF SPECIFIED, LET IT
         NC    DCBBLKSI,DCBBLKSI
         BNZ   TESTDIV .     TEST IF BLKSIZE IS CORRECT
ALLOFUT1 EQU   * .           TAKE ALL SUBPARAMETERS FROM SYSUT1 DCB
         L     SW,AINPUT     GET ADDRESS OF SYSUT1 DCB
         MVC   DCBRECFM,DCBRECFM-IHADCB(SW)      MOVE IT FROM SYSUT1
         MVC   DCBLRECL,DCBLRECL-IHADCB(SW)   MOVE IT FROM SYSUT1
         MVC   DCBBLKSI,DCBBLKSI-IHADCB(SW)  MOVE IT FROM SYSUT1
         BR    R14           AND RETURN TO OPEN SVC
LOOKLREC EQU   *
         NC    DCBLRECL,DCBLRECL IS THE LRECL SPECIFIED ?
         BNZ   LOOKBLKS .    YES, LOOK FOR BLOCKSIZE
         MVC   DCBLRECL,OPNLRECL TAKE THE DEFAULT VALUE
LOOKBLKS EQU   *
         NC    DCBBLKSI,DCBBLKSI IS THE BLOCKSIZE SPECIFIED ?
         BNZ   TESTDIV .     YES, CHECK IF CORRECT
         MVC   DCBBLKSI,OPNBLKSI IF NOT, TAKE THE DEFAULT VALUE
TESTDIV  EQU   * .           CHECK IF BLOCKSIZE IS ACCEPTABLE
         TM    DCBRECFM,RECFMU . IS SYSUT2 RECFM = 1 ?
         BO    RECFMERR .    IF YES, THIS IS NOT ALLOWED
         TM    DCBRECFM,RECFMV IS IT V ?
         BO    RECFMISV .    YES, LET THE BLOCKSIZE DIVISION
         SR    R0,R0 .       CLEAR WORK REG
         LH    R1,DCBBLKSI . GET THE BLOCKSIZE
         LH    R15,DCBLRECL .AND THE LRECL
         LTR   R15,R15 .     IS LRECL SPECIFIED ?
         BP    OKFORDIV .    OK DIVISION ALLOWED
         STH   R1,DCBLRECL . IF NOT SPECIFIED, TAKE BLKSIZE
         BR    R14 .         AND RETURN TO OPEN SVC
OKFORDIV EQU   *
         DR    R0,R15 .      DIVIDE BLOCKSIZE BY LRECL
         LTR   R0,R0 .       IS REMAINDER EQUAL ZERO ?
         BCR   8,R14 .       YES, RETURN TO OPEN SVC
         LTR   R1,R1 .       IS BLOCKING FACTOR POSITIVE ?
         BNP   ONETOONE      BLKSIZE WAS LESS THAN LRECL (DEFAULT LRECL
         MH    R1,DCBLRECL . SET BLOCKSIZE TO THAT MULTIPLE OF LRECL
         STH   R1,DCBBLKSI . WHICH IS THE HIGHEST LESS THAN THE DEFAULT
*                            OR SPECIFIED BLOCKSIZE
         BR    R14 .         RETUEN TO OPEN SVC
ONETOONE EQU   *
         MVC   DCBLRECL,DCBBLKSI       SET LRECL EQUAL BLKSIZE
         BR    R14
RECFMERR EQU   * .           RECFM = U IS NOT ALLOWED
         OI    OPNSW,RECUERR OPEN SVC WILL COMPLETE NORMALLY
         BR    R14 .         RETURN TO SVC, BUT INDICATE ERROR
RECFMISV EQU   * .           FOR RECFM=V OTHER CHECKS MUST BE MADE
         LH    R1,DCBBLKSI . GET THE BLOCKSIZE
         LH    R15,DCBLRECL .AND THE RECORD LENGTH
         LA    R15,4(R15) .  ADD LENGTH OF BLOCK DESCRIPTOR WORD
         CR    R1,R15 .      COMPARE THIS LENGTH WITH BLOCKSIZE
         BCR   10,R14 .      IF BLKSI IS HIGH OR EQUAL OPEN SVC CAN
         TM    DCBRECFM,8 .  IS SPANNED SPECIFIED ?             HANDLE
         BCR   1,R14 .       IF SPANNED, OPEN SVC CAN HANDLE
         OI    OPNSW,RECVERR INDICATE ERROR CONDITION
         OI    DCBRECFM,8 .  SET SPAN-BIT TO PASS THRU OPEN SVC
         BR    R14 .         AND RETURN TO OPEN SVC
OPENROUT EQU   *
*        GETMAIN R,LV=(LEN)            GET CORE FOR DCB
         GETMAIN R,LV=(LEN)            GET CORE FOR DCB
         LR    WK2,R1                  SET POINTER TO IT
         BCTR  LEN,0
         EX    LEN,MOVEDCB             MOVE MODEL-DCB INTO IT
         IC    R14,DCBRECFM            SAVE RECFM
         ST    WK1,DCBEXLST            SET UP EXIT-ADDRESS
         STC   R14,DCBRECFM            RESTORE RECFM
         BR    SW                      NOW DO OPEN
*                                      AND RETURN
MOVEDCB  MVC   0(0,WK2),0(PNT)
*UTPUT   OPEN  ((WK2),(OUTPUT)),MF=(E,DCBLIST)
OUTPUT   OPEN  ((WK2),(OUTPUT)),MF=(E,DCBLIST)
         BR    LNK
*NPUT    OPEN  ((WK2),(INPUT)),MF=(E,DCBLIST)
INPUT    OPEN  ((WK2),(INPUT)),MF=(E,DCBLIST)
         BR    LNK
GETREC   EQU   *
         LH    R0,DCBLRECL             GET RECORD LENGTH
*        GETMAIN R,LV=(0)              ALLOCATE SPACE FOR A RECORD
         GETMAIN R,LV=(0)              ALLOCATE SPACE FOR A RECORD
         BR    LNK                     RETURN
UT2ERR   EQU   * .           SYSUT2 IS OPEN, BUT IS NOT SUITABLE FOR
         L     R1,ALISTE .   GET DCB-ADDRESS      FOR LATER PROCESSING
         L     WK2,ALIST .   GET ADDRESS OF OUTPUTLINE
         USING AZEILE,WK2
         TM    DCBOFLGS-IHADCB(R1),ISOPEN
         BZ    RETURN .      IF SYSPRINT NOT OPEN ==> DO NOT TRY TO PUT
         BAL   LNK,CLRLINE . CLEAR THE OUTPUT LINE
         MVC   AFLAG,ERRMSG .MOVE AN ERROR INDICATOR
         TM    OPNSW,RECUERR IS THE ERROR RECFM=U ?
         BZ    TESTRECV .    MUST BE ONE OF BOTH
         MVC   ACARDOUT+2(L'RECU),RECU
         BAL   LNK,PUTLINE . PUT THE MESSAGE
TESTRECV EQU   *
         TM    OPNSW,RECVERR IS RECFM=V NOT SPANNED AND LRECL+4>BLKSI
         BZ    RETURN .      IF NOT => MUST HAVE BEEN RECFM=U
         MVC   ACARDOUT+2(L'RECV),RECV
         BAL   LNK,PUTLINE . PUT THE MESSAGE
         B     RETURN
*
CLRLINE  EQU   * .           CLEAR THE OUTPUT LINE WITH BLANKS
         MVI   ASA,BLANK .   MOVE FIST CHARACTER
         MVC   AFLAG(ALINELEN),ASA AND THROUGH ALL THE LINE
         BR    LNK .         RETURN TO CALLER
PUTLINE  EQU   * .           PUT THE LINE
         PUT   (1),(WK2) .   PUT THE LINE
         BR    LNK .         AND RETURN TO  CALLER
ISOPEN   EQU   X'10'
RECFMU   EQU   X'C0'         DCB-RECORD-FORMAT IF 'U' WAS SPECIFIED
RECFMV   EQU   X'40'         DCB-RECORD-FORMAT IF 'V' WAS SPECIFIED
RECVERR  EQU   1 .           SET IF RECFM=V NOT SPANNED AND LRECL+4>BLK
RECUERR  EQU   2 .           SET IF RECFM FOR SYSUT2 IS U
RECU     DC    C'SYSUT2-RECFM=U INVALID'
RECV     DC    C'SYSUT2-RECFM=V NOT SPANNED AND LRECL + 4 > BLOCKSIZE'
ERRMSG   DC    C'*** ERROR **'
RECFMFB  EQU   X'90' .       RECORD FORMAT IS FB
DEFLRECL DC    H'133' .      DEFAULT LRECL FOR SYSUT2
DEFBLKSI DC    H'3156' .     DEFAULT BLOCKSIZE FOR SYSUT2
BFTEKA   EQU   X'60'         BFTEK=A FOR RECFM=VBS OR VS
         CNOP  0,8           EXPAND MODUL ONDOUBLE-WORD BOUNDARY
         AIF   ('&SYS' EQ 'OS').OVDOS
.NOWOS1  ANOP
OLDDTF   DS    F             POINTER TO LAST ACTIVE DTF IN CHAIN
SAVEW    DS    F             WORD FOR SAVING INFORMATION TEMORARILY
AMODTAB  DC    F'0'          ADDRESS OF MODULE TABLE
INDIC    DC    X'00'         BIT INDICATOR
OUTCH    EQU   X'80'         SET IF ENTRY WAS TAKEN OUT OF CHAIN
LOADNAME DC    CL8'BGEN'     NAME OF MODULE TO BE LOADED
         SPACE 3
MODTAB   DSECT
MODNXT   DS    F             POINTER TO NEXT ENTRY
MODCNT   DS    CL1           MODULE USAGE COUNT
MODNAM   DS    CL3           MODULE IDENTIFIER
MODDTF   DS    F             MODULE ADDR CONTAINING 3 DTFS + ONE MODULE
MODASA   DS    CL1           CONTAINS "A" IF OPFA, ELSE BLANK
MODTLL   EQU   *-MODTAB      LENGTH OF ONE ENTRY
         AGO   .ENDDCBS
.OVDOS   ANOP
DUMMY    DSECT
SAVEAREA DS    18F
DCBLIST  DS    F
OPNLRECL DS    H .           LRECL FIELD
OPNBLKSI DS    H .           BLOCKSIZE FIELD
OPNRECFM DS    C .           RECORD FORMAT FIELD
OPNSW    DS    C .           ROUTINE'S INTERNAL SWITCH
DSEND    DS    0D
PARMLEN  EQU   DSEND-DUMMY
         TITLE ' MODELL-DCBS FUER BASFGEN'
GENDCBS  DSECT
         GENDCBS
.ENDDCBS ANOP
         MEND
./ ADD  NAME=GENOUT
         MACRO
         GENOUT &SYS=OS
         GBLB  &IPRT
         LCLB  &S,&SD
&S       SETB  ('&SYS' EQ 'OS')
&SD      SETB  ('&SYS' EQ 'DOS')
         AIF   (&S OR &SD).COP
         MNOTE 12,'SYSTEM NOT SUPPORTED, SPECIFY DOS OR OS'
         MEXIT
.COP     ANOP
         AIF   (&IPRT).OK
         MNOTE 12,'GENIPRT MUST BE ASSEMBLED TOGETHER WITH THIS CSECT'
         MEXIT
.OK      ANOP
         AIF   (&S).ENTRY
GENOUT   CSECT
         USING MAINPARM,PRM
*        EXTXS BAS,,BGENOUT,PARMLENG,TYP=F,MOD=VGM
         EXTXS BAS,,BGENOUT,PARMLENG,TYP=F,MOD=VGM
         AGO   .NORMENT
.ENTRY   ANOP
GENMOD   CSECT
         ENTRY DLITCBL,GENOUT
*LITCBL  XSAVE BAS,,DLITCBL,PARMLENG
DLITCBL  XSAVE BAS,,DLITCBL,PARMLENG
         LR    SW,R1 .       PSB-ADDRESS
*        LOAD  EP=GENSAVE .  GET THE COMMUNICATION VECTOR
         LOAD  EP=GENSAVE .  GET THE COMMUNICATION VECTOR
         LR    R15,SW .      SAVE THE PSB-ADDRESS
         LR    WK1,R0 .      GET BASE OF SAVE MODULE
         USING GENSAVE,WK1
         L     PRM,PARMADR . GET ADDRESS OF COMM. VECTOR
         USING MAINPARM,PRM
         L     PNT,PCBADR .  GET ADDRESS OF PCB-NAME IF SPECIFIED
         LTR   PNT,PNT .     TEST IF SPECIFIED
         BNZ   SERPCB .      WAS SPEC. ==> FIND ADDRESS
PCBDEFLT EQU   *
         L     PNT,4(SW) .   TAKE SECOND PCB FROM PSB AS DEFAULT
         B     PCBFND
SERPCB   EQU   *
         L     R14,0(R15) .  NEXT PCB IN PSB
         CLC   0(8,R14),0(PNT) PCB-NAME EQUAL TO SPECIFIED ?
         BE    PCBEQ .       YES
         LTR   R14,R14 .     WAS THIS THE LAST IN PSB ?
         BM    PCBDEFLT ,    YES, THAN TAKE DEFAULT MAY CAUSE ABEND
         LA    R15,4(R15) .  POINT TO NEXT PCB-ADDRESS
         B     SERPCB .      AND TRY TO FIND THE SPECIFIED ONE
PCBEQ    EQU   *
         LR    PNT,R14 .     R14 POINTS TO SPECIFIED PCB
PCBFND   EQU   *
         LR    R1,PRM .      SAVE COMMUNICATION VECTOR ADDRESS
         LA    BAS,GENOUT-GENMOD(BAS)
         B     NORMENTR-GENOUT(BAS)    BRANCH TO NORMAL ENTRY POINT
*ENOUT   XSAVE BAS,,GENOUT,PARMLENG
GENOUT   XSAVE BAS,,GENOUT,PARMLENG
NORMENTR EQU   *
.NORMENT ANOP
         USING WORKSAVE,R13
         XC    WORKSAVE+12(PARMLENG-12),WORKSAVE+12 CLEAR WORKAREA
         USING FMTDSECT,WK1
         AIF   ('&SYS' EQ 'DOS').NOPRM
         LR    PRM,R1        PARMAREA BASE
         USING MAINPARM,PRM
.NOPRM    ANOP
         L     FUNC,AFUNC    POINTER TO FUNCTION TABLE
         USING FUNCTION,FUNC
         L     WK2,ALIST     GET OUTPUT-LINE ADDRESS
         USING AZEILE,WK2
         LM    R0,R1,INRECANF SET ADDRESSES OF AST-CODE
         STM   R0,R1,UT1AST  TO DSECT
         AIF   (&SD).LAEOD
         L     R1,ASTCHN .   GET START OF  ASTCODE CHAIN FOR SEP DCBS
SEPLPOUT EQU   *
         LTR   R1,R1         ARE FURTHER ENTRIES IN THIS CHAIN
         BZ    ENDSPAST      NO
         LA    R14,ASEPDCBS  GET START OF SEP-DCB-CHAIN
         USING SEPENTRY,R14
SEPLPIN  EQU   *
         L     R15,LINKFLD   GET NEXT ENTRY IN CHAIN
         LTR   R15,R15       TEST IF THERE IS ONE MORE
         BZ    ENDSPAST      IF NOT TERMINATE PROCESSING
         LR    R14,R15       POINT TO NEXT ENTRY
         CLC   DCBID,4(R1)   ARE ID-S IN BOTH CHAINS IDENTICAL
         BNE   SEPLPIN       IF NOT, GO ON IN DCB-CHAIN
         L     R0,4(R1)      GET ADDRESS OF ASTCODE IF ID-S ARE EQUAL
         ST    R0,12(R14)    SET ADDRESS TO DCB-ENTRY
         L     R1,0(R1)      AND POINT TO NEXT ENTRY
         B     SEPLPOUT
ENDSPAST EQU   *
         DROP  R14
.LAEOD   ANOP
         LA    R15,EODAD
         AIF   (&SD).INPDTF
         TM    SW2,IMSORG    IS INPUT FROM DATABASE
         BZ    SETEODAD      SET MORMAL EODAD ADDRESS
         LA    PNT,0(PNT)    CLEAR HIGH OREDER BYTE
         ST    PNT,PCBAD     SAVE ADDRESS OF PCB
         ST    R15,IMSEODAD  SET UP EODAD ADDRESS FOR DLI INTERFACE
         B     FIRSTCLR
SETEODAD EQU   *
.INPDTF  ANOP
         L     R1,AINPUT     INPUT - DCB
         AIF   (&S).IHA
         CLI   INPDEV,C'S'   WAS SYS000 = DISK ?
         BNE   TSTTP         IF NOT: TEST /F TAPE
         IC    R0,64(R1)     SAVE RECORD NUMBER IN DTF
         ST    R15,64(R1)    STORE EODAD ADDR
         STC   R0,64(R1)     GIVE RECORD NUMBER BACK
         B     FIRSTCLR
TSTTP    EQU   *
         CLI   INPDEV,C'T'   WAS SYS000 = TAPE ?
         BNE   CDINP         IF NOT: ONLY CARD INP POSSIBLE
         IC    R0,36(R1)     SAVE SWITCH BYTE
         ST    R15,36(R1)    STORE EODAD ADDRESS
         STC   R0,36(R1)     GIVE SWITCH BYTE BACK
         B     FIRSTCLR
CDINP    EQU   *             INPUT FROM READER
         ST     R15,28(R1)   STORE EODAD ADDRESS
         AGO   .FIRSTCL
.IHA     ANOP
         USING IHADCB,R1
         ST    R15,DCBEODAD  SET AN EODAD-ADDRESS
         MVI   DCBLIST,ENDINDIC SET END SWITCH TO ADDRESS LIST
.FIRSTCL ANOP
FIRSTCLR EQU   *
ONEXTC@  EQU   *
         BAL   LNK,CLEAROUT  CLEAR THE OUTPUT RECORD
         NI    SW3,255-DOISACT-DONTPUT
NEXTFUNC EQU   *             HERE THE FUNCTION CODES ARE TESTED
         CLI   FIDENT,COPY   TO BRANCH TO CORRECT ROUTINE
         BE    OCOPY
         CLI   FIDENT,SKIP
         BE    OSKIP
         CLI   FIDENT,ENDFUNC
         BE    OENDE
         CLI   FIDENT,BACKSP
         BE    BACKSPAC
         CLI   FIDENT,FAULT
         BE    PREPFLTS .    PREPARE FAULT PROCESSING
         CLI   FIDENT,DCKS . ARE DATA-CHECKS EXPECTED ?
         BE    PREPDCKS .    PREPARE COUNT FIELD
         CLI   FIDENT,C'N'
         BE    ONOP
         CLI   FIDENT,UNLOAD
         BE    OUNLOAD
         CLI   FIDENT,REWIND
         BE    OREWIND
         CLI   FIDENT,WTM
         BNE   ONOP          UNKNOWN FUNCTION => CHANGE IT TO NOP
OWTM     EQU   *             A TAPE MARK ON OUTPUT IS REQUIRED
         SR    R0,R0         CLEAR REG                           ***
         ST    R0,OUTCNT     AND RECORD COUNT FOR SYSUT2         ***
         L     R1,AOUTPUT    PICK UP DCB ADDRESS
*FEOV    FEOV  (1)           FORCE END OF VOLUME CONDITION
OFEOV    FEOV  (1)           FORCE END OF VOLUME CONDITION
NEWFUNC  LA    FUNC,FCLEN(FUNC)  SET FUNCTION POINTER TO NEXT FUNCTION
         B     NEXTFUNC
OREWIND  EQU   *             INPUT TAPE SHOULD BE REWOUND
         L     WK1,AINPUT    PICK UP DCB-ADDRESS
         AIF   (&S).OSCL
*        CLOSER (WK1)
         CLOSER (WK1)
*        OPENR (WK1)
         OPENR (WK1)
         AGO   .NEWF
.OSCL    ANOP
*        CLOSE ((WK1),REREAD),MF=(E,DCBLIST)   CLOSE DCB TEMPORARY
         CLOSE ((WK1),REREAD),MF=(E,DCBLIST)   CLOSE DCB TEMPORARY
*        OPEN  ((WK1),(INPUT)),MF=(E,DCBLIST)  OPEN IT AGAIN
         OPEN  ((WK1),(INPUT)),MF=(E,DCBLIST)  OPEN IT AGAIN
.NEWF    ANOP
         SR    R0,R0         CLEAR REG                           ***
         ST    R0,INPBLKS    AND INPUT BLOCK-COUNT               ***
         ST    R0,INPRECS    AND INPUT RECORD-COUNT              ***
         B     NEWFUNC
OUNLOAD  EQU   *             INPUT TAPE SHOULD BE UNLOADED
         L     R1,AINPUT     PICK UP DCB-ADDRESS
         SR    R0,R0         CLEAR REG                           ***
         ST    R0,INPBLKS    AND INPUT BLOCK-COUNT               ***
         ST    R0,INPRECS    AND INPUT RECORD-COUNT              ***
         B     OFEOV         BRANCH TO FEOV ROUTINE
ONOP     EQU   *
         L     R15,VGENSTAT     GET ADDRESS OF STATISTIC REPORT ROUT
         BALR  R14,R15       LINK TO IT
         MVI   FIDENT,C'N'   NOP THIS FUNCTION
         B     NEWFUNC       AND TRY NEXT
PREPFLTS EQU   *
         OI    SWOPEN,FLTS . INDICATE THAT FAULT WAS IN FUNCTION-CARDS
         B     PREPERR .     GO TO COMMON ROUTINE
PREPDCKS EQU   *
         OI    SWOPEN,DCK .  INDICATE THAT DCKS WAS IN FUNCTION-CARDS
PREPERR  EQU   *             PREPARE ERROR COUNT IN SYNAD ROUTINE
         ZAP   PDW,FCOUNT+3(5) MOVE THE SPECIFIED COUNT          ***
         CVB   R0,PDW        AND CONVERT IT
         ST    R0,ERRCOMP    STORE IT TO COMPARE FIELD
         B     NEWFUNC
BACKSPAC EQU   *
         AIF   (&SD).NOBSAM
         TM    SW2,PSORG     IS BSAM SPECIFIED ?
         BZ    ONOP          NO, BACKSPACING NOT POSSIBLE
.NOBSAM  ANOP
         L     R1,AINPUT     GET DCB-ADDRESS
         AIF   (&S).OSTAPE
         CLI   INPDEV,C'T'   WAS INPUT DEVICE A TAPE ?
         AGO   .BONOP
.OSTAPE  ANOP
         CLI   DCBDEVT,TAPE  IS INPUT DEVICE A TAPE ?
.BONOP   ANOP
         BNE   ONOP          NO TAPE => NO BACKSPACING POSSIBLE
         ZAP   PDW,FCOUNT+3(5) MOVE REQUIRED COUNT TO DOUBLEWORD ***
         CVB   R0,PDW        LOAD REGISTER  WITH BLOCK-COUNT
         AIF   (&S).PDWBSR
         LR    WK1,R0        GET NO OF RECS TO BE BACKSPACED
BSRLOOP  EQU   *
*        CNTRL (1),BSR
         CNTRL (1),BSR
         BCT   WK1,BSRLOOP
         B     ONOP
         AGO   .SKIP
.PDWBSR  ANOP
         MVC   PDW(4),=X'002707FB'     SET CODE AND RETURN INSTRUCTION
         B     CNTRL         GO TO CONTROL-ROUTINE
.SKIP    ANOP
OSKIP    EQU   *
         AIF   (&SD).LDTF
         TM    SW2,PSORG     WAS BSAM SPECIFIED ?
         BZ    SKIPREC       SKIP IS TO BE DONE BY RECORDS
.LDTF    ANOP
         L     R1,AINPUT     GET DCB-ADDRESS
         AIF   (&S).TAPT
         CLI   INPDEV,C'T'   WAS INPUT A TAPE ?
         AGO   .BSKREC
.TAPT    ANOP
         CLI   DCBDEVT,TAPE  IS INPUT FROM TAPE ?
.BSKREC  ANOP
         BNE   SKIPREC       SIMULATE SKIP ON DISK DEVICES
         ZAP   PDW,FCOUNT+3(5) MOVE REQUIRED COUNT TO DOUBLEWORD ***
         CVB   R0,PDW        LOAD COUNT REGISTER
         AIF   (&S).SKP
         LR    WK1,R0        GET NO OF RECS TO BE SKIPPED
SKIPLOOP EQU   *
*        CNTRL (1),FSR
         CNTRL (1),FSR
         BCT   WK1,SKIPLOOP
         B     ONOP
         AGO   .SKIPREC
.SKP     ANOP
         MVC   PDW(4),=X'003707FB'     SET CODE AND RETURN INSTRUCTION
CNTRL    EQU   *
         L     R15,DCBCNTRL  GET CNTRL-ROUTINE ADDRESS
         LA    LNK,CNTRLRET  LOAD RETURN ADDRESS
         LA    R14,PDW       POINTER TO CODE AND RETUEN INSTRUCTION
         BR    R15           LINK TO CNTRL-ROUTINE
CNTRLRET B     ONOP          NOP THE FUNCTION
.SKIPREC ANOP
SKIPREC  EQU   *
         SP    FCOUNT,=P'1'  REDUCE COUNT BY 1
         BM    ONOP          COUNT EXHAUSTED
         LR    R1,PRM        LOAD PARM REG
         L     R15,AGETROUT  GET ADDRESS OF THE GET-(READ)-ROUTINE
         BALR  R14,R15       LINK TO INPUT-ROUTINE
         B     SKIPREC       AND LOOK IF IT WAS ENOUGH
EODAD    EQU   *
         L     R13,4(R13)    GET OWN SAVEAREA
         LM     R14,BAS,12(R13)        GET OWN REGISTERS
         OI    SWINPUT,EOFSYS1 INDICATE END OF SYSUT1 TO GENSTAT ***
OENDE    EQU   *
         TM    SW4,LASTWAS   WAS A LAST FORMAT REQUIRED ?
         BZ    XRET          NO, RETURN IMMEDIATELY
         OI    SW4,LASTIS    INDICATE LAST-PROCESSING IS NOW ACTIVE
         L     WK1,LASTLINE  GET FORMAT ADDRESS OF THIS LAST-ENTRY
         NI    SW4,255-LASTWAS CLEAR THE SWITCH => LAST IS DONE
         NI    SW3,255-DOISACT CANCEL EVENTUALLY ACTIVE 'DO'
         L     MSG,OUTREC    SET OUTPUT RECORD POINTER BACK
         L     PNT,INRECANF  SET INPUT RECORD POINTER BACK
         B     NEXTOP        PROCESS REQUIRED FORMAT
XRET     EQU   *
         L     R15,VGENSTAT  GET ADDRESS OF STATISTIC ROUTINE
         BALR  R14,R15       AND LINK TO IT                      ***
         LA    R15,4         SET NORMAL CODE
RETURN   EQU   *
         LM    R0,R1,UT1AST  GET ADDRESSES OF AST-TABLES
         STM   R0,R1,INRECANF AND PLACE THEM TO COMMON VECTOR
         AIF   (&S).XR1
*        EXTXR (R15),R,MOD=VFM FREE THE SAVE AREA
         EXTXR (R15),R,MOD=VFM FREE THE SAVE AREA
         AGO   .OCOP
.XR1     ANOP
*        XRETURN (R15),R
         XRETURN (R15),R
.OCOP    ANOP
OCOPY    EQU   *
         SP    FCOUNT,=P'1'  REDUCE COPY-COUNT BY ONE
         BM    ONOP          NOP THIS FUNCTION IF ALL IS DONE
         LR    R1,PRM        SET PARAMETER REGISTER
         L     R15,AGETROUT  ADDRESS OF GETROUTINE
         BALR  R14,R15       LINK TO IT
*              NOW INRECANF POINTS TO A NEW RECORD
         TM    SW2,PSORG     IS BSAM INPUT ?
         BZ    GETREC        NO, PROCESS THE RECORD
         TM    SW4,LASTREC   IF BSAM, LOOK IF LAST RECORD IN BLOCK
         BO    GETREC        IF LAST, PROCESS IT
         AP    FCOUNT,=P'1'  IF NOT LAST, REST COPY-COUNT BEFOR PROCESS
GETREC   EQU   *
         L     LEN,INRECEND  END OF RECORD
         L     PNT,INRECANF  BEGIN OF RECORD
         L     R15,UT1AST    GET ADDRESS OF ASTCODE
         LTR   R15,R15       TEST IF THERE IS ONE
         BZ    NOUT1AST      IF NOT, BRANCH AROUND LINK
         LR    LIMIT,PNT     SET POINTER REG TO RECORD
         BAL   R14,8*8+2(R15) LINK TO ASTCODE
NOUT1AST EQU   *
         SR    LEN,PNT       LENGTH OF THIS RECORD
         TM    SW3,DONTPUT   SHOULT PUT BE PREVENTED ?
         BO    DONTCLER      YES, DO NOT CLEAR THE OUTPUT RECORD
         BAL   LNK,CLEAROUT   CLEAR THE OUTPUT RECORD
DACAPO   EQU  *
         L     MSG,OUTREC    POINTER TO OUTPUT RECORD
DONTCLER NI    SW3,255-DONTPUT CLEAR THE SWITCH BIT
         L     SW,AACTIONS   POINT TO ACTION TABLE
NEXTFMT  EQU   *
         TM    0(SW),ENDINDIC NO MORE ACTIONS ?
         BO    OUNDEF        IF END, => THIS IS AN UNDEFINED RECORD
         L     WK1,0(SW)     FIRST FORMAT
NEXTOP   LH    R1,FMTCODE    GET FORMATCODE
         BAL   LNK,0(R1,BAS) AND LINK TO REQUIRED ROUTINE
         AH    WK1,FMTINCR   SET TO NEXT FORMAT-ENTRY
         B     NEXTOP        AND GO TO ASSOCIATED ROUTINE
NICHT1   EQU   *
         TM    SW3,DOISACT   IS RETURN FROM 'DO'
         BZ    NOTDO         THIS IS NOT A RETURN FROM SUB-FORMAT
         L     WK1,DOSAVE    GET ADDRESS OF 'DO' FORMAT ENTRY BACK
         SR    R0,R0         CLEAR REG
         STH   R0,FMTLIT     AND REPETION-COUNT
         B     ODORET        GO TO 'DO'-RETURN ROUTINE
NOTDO    EQU   *
         LH    R1,FMTINCR    GET LENGTH OF CURRENT FORMAT ENTRY
         AR    R1,WK1        POINT TO NEXT FORMAT ENTRY
         CLC   2(2,R1),=AL2(OODER@-GENOUT)  IS NEXT FUNCTION 'ODER' ?
         BE    NICHT         YES, NORMAL PROCESSING
INCRSW   EQU   *
         LA    SW,4(SW)      IF NOT,
         TM    0(SW),ODERENDE+ORENTRY  SKIP ALL ODER-FIELDS
         BZ    NEXTFMT       TO FIND NEXT FORMAT (STAR)
         B     INCRSW
NICHT    EQU   *             THIS IS ENTERED IF THE CONDITION WAS
*                            NOT MATCHING
         LA    SW,4(SW) .    GET NEXT ACTION ENTRY
         TM    0(SW),ODERENDE LAST 'OR'-CONDITION REACHED?
         BO    NICHT         YES, NO COMPARISON DID MATCH
         B     NEXTFMT       NOW DO NEXT ACTION
ODO@     EQU   *
         MVC   UPRADR,FMTCNT ALIGN ADDRESS OF SUBFORMAT-ENTRY
         LH    R0,FMTLIT+2   GET THE REPETION COUNT
         STH   R0,FMTLIT     STORE IT TO COUNTER AREA
ODOREPET EQU   *
         LH    R0,FMTLIT     GET REPETION COUNT
         BCTR  R0,0          REDUCE IT BY ONE
         STH   R0,FMTLIT     AND       RESTORE IT
         ST    WK1,DOSAVE    SAVE THAT POINTER
         L     WK1,UPRADR    POINT TO SUBFORMAT ENRTY
         OI    SW3,DOISACT   INDICATE THAT UPRO IS ACTIVE
         B     NEXTOP
ODORET   EQU   *
         NI    SW3,255-DOISACT  CLEAR UPRO CONDITION
         TM    SW4,FIRSTLIN  IS RETURN FROM 'COUNT' - FORMAT ?
         BZ    ODORET2       NO
         LA    R0,ODORET2    IF YES, SET RETURN ADDRESS
         ST    R0,LNKSAVE    TO SAVE WORD FOR IT
         B     OVEND         TERMINATE COUNT PROCESSING
ODORET2  EQU   *
         L     WK1,DOSAVE    GET ORIGINAL FORMAT POINTER BACK
         LH    R0,FMTLIT     GET THE REPETION COUNT
         LTR   R0,R0         TEST IT
         BP    ODOREPET      IF NOT ZERO, GO TO REPEAT SUB-FORMAT
         AH    WK1,FMTINCR   POINT TO NEXT FORMAT ENTRY
         B     NEXTOP        AND GO ON IN NORMAL MANNER
TABSEARC EQU   *
         MVC   TABSAV,FMTAKU#+2 TABLE ENTRY ADDRESS
         L     R1,TABSAV     SET REG TO IT
         LH    LEN,FMTAKU#
         A     LEN,INRECANF  POINT TO INPUT RECORD POSITION TO BE TEST
         ST    LEN,PDW+4     STORE IT TO PARM LIST
         LA    R0,EDITLEN    INDEX FIELD FOR LFDNR
         ST    R0,PDW+8      STOREIT TO PARM LIST
         OI    PDW+8,ENDINDIC END OF PARMS
         L     R1,4(R1)      A(PARAMETERS) FOR LFDNRDEF
         LA    R1,0(R1)      CLEAR HIGH ORDER BYTE
         ST    R1,PDW        1. PARAMETER
         LA    R1,PDW        POINT TO PARM LIST
         L     R15,ALFDNR    GET ENTRY ADDRESS OF SEARCH ROUTINE
         BALR  R14,R15       LINK TO IT
         LH     LIMIT,EDITLEN  GET INDEX OF TABLE ELEMENT
         LTR   LIMIT,LIMIT   WAS IT FOUND
         BCR   8,LNK .       RETURN IF NOT
         L     R14,TABSAV    GET TABLE ENTRY ADDRESS
         L     R15,4(R14)    LFDNRDEF-PARMS
         LH    R1,2(R15)     LENGTH OF ONE TABLE ELEMENT
         MH    R1,EDITLEN    ELEMENT NUMBER JUST FOUND
         SH    R1,2(R15)     - ONE ELEMENT
         BM    CLEARTAB
         A     R1,0(R14)     + TABLE ADDRESS
         ST    R1,ATABELEM . SAVE ADR. OF THIS TABLE ELEMENT
         MVI   0(R1),STERN . SET REFERENCE MARK IN TABLE
         LH    LIMIT,EDITLEN GET INDEX OF ELEMENT BACK
         LTR   LIMIT,LIMIT . AND THE ORIGINAL CONDITION CODE
         BCR   7,LNK .       IF NOT ZERO , RETURN
CLEARTAB EQU   *
         XC    ATABELEM,ATABELEM CLEAR THE POINTER
         BR    LNK .         AND RETURN WITH COND-CODE ZERO
         BR    LNK           RETURN
OTABEQ@  EQU   *
         ST    LNK,LNKSAVE   SAVE THE LINKREGISTER
         BAL   LNK,TABSEARC  SEARCH THE TABLE
         L     LNK,LNKSAVE   GET THE LINK REG BACK
         BCR   7,LNK         GO ON IN THIS FORMAT, IF ELEMENT FOUND
         B     NICHT1
OTABNE@  EQU   *
         ST    LNK,LNKSAVE   SAVE THE LINKREGISTER
         BAL   LNK,TABSEARC  SEARCH THE TABLE
         L     LNK,LNKSAVE   GET THE LINK REG BACK
         BCR   8,LNK         GO ON IN THIS FORMAT, IF ELEMENT NOT FOUND
         B     NICHT1
OIFSVE@  EQU   *
OIFSVH@  EQU   *
OIFSVL@  EQU   *
OIFSVU@  EQU   *
         MVC   PDW,FMTAKU#+2 GET THE ADDRESSES OF THE SAVE-ENTRY'S
         LM    R14,R15,PDW   GET THEM TO REGS
         LH    LEN,FMTAKU#   LENGTH OF COMPARE
         IC    R1,FMTCNT     CONDITION CODE
         L     R14,4(R14)    ADDRESS OF DATA 1. ACCU
         L     R15,4(R15)    ADDRESS OF DATA 2. ACCU
         EX    LEN,COMPACC   COMPARE THE ACCUS
         EX    R1,BRANCH     BRANCH IF REQUIRED CONDITION WAS NOT FOUND
         BR    LNK           GO ON IN FORMAT IF CONDITION MATCH WAS
COMPACC  CLC   0(0,R14),0(R15)
OAND@    EQU   *
ODMP@    EQU   *
OSUB@    EQU   *
OUND@    EQU   *
OLAST@   EQU   *
OCOUNT@  EQU   *
         DC    H'-1'         CANNOT OCCUR
OEND@    EQU   *
         OI    SWINPUT,ENDREQ INDICATE THAT END OF PROCESSING IS WISHED
         B     OENDE         AND RETURN
OSEP@    EQU   *
         MVC   PDW(4),FMTCNT GET THE DCB-ENTRY-ADDRESS
         L     LIMIT,PDW     INTO BASE REGISTER
         USING SEPENTRY,LIMIT
         L     R1,DCBADR     GET THE DCB-ADDRESS
         L     R0,OUTREC     AND THE OUTPUT AREA
         AIF   (&S).RECF
         CLI   RECFM,C'F'    RECFM FIX ?
         BE    SEPPUT        YES, PUT IMMEDIATELY
         AGO   .L15
.RECF    ANOP
         TM    DCBRECFM,X'80' IS RECFM FIX ?
         BO    SEPPUT        YES, PUT IMMEDIATELY
.L15     ANOP
         L     R15,OUTRECPT  ASSUME VARIABLE
         SR    R15,R0        LENGTH OF RECORD TILL NOW
         CH    R15,=H'4'     IS RECORD LENGTH PLAUSIBLE ?
         BCR   13,LNK        NO, RETURN WITHOUT PUTTING
         LR    R14,R0
         SLL   R15,16        SHIFT LENGTH TO HIGH ORDER BYTES
         ST    R15,0(R14)    STORE LENGTH AND FILLER TO RECORD
SEPPUT   EQU   *
*        PUT   (1),(0)
         PUT   (1),(0)       AND PUT IT
         L     R1,PUTCOUNT   ADD
         LA    R1,1(R1)      ONE TO
         ST    R1,PUTCOUNT   COUNT ASSOCIATED TO DCB
         L     R15,AASTCODE
         LTR   R15,R15       IF THER EIS ONE
         BZ    NOSEPAST      IF THERE IS NONE, PREVENT LINK
         L     LIMIT,OUTREC  SET POINTER REG TO RECORD
         BAL   R14,8*8+2(R15) LINK TO ASTCODE
NOSEPAST EQU   *
         BR    LNK
         DROP  LIMIT
OEDAC@   EQU   *
         LH    LEN,FMTAKU#   NUMBER OF BYTES TO BE EDITED
         LA    LEN,2(LEN)    + 2
         SRL   LEN,1              / 2 = ANZAHL BYTES
         L     R1,AACCU      GET ACCU START ADDRESS
         AH    R1,FMTCNT     ADD ACCU DISPLACEMENT
         LA    R1,8(R1)      END OF THIS ACCU
         SR    R1,LEN        R1 POINTS NOW TO EDIT START-POSITION
         SR    R0,R0         INPUT POINTER MUST NOT BE INCREASED
         TM    SW3,MASKWAS   WAS A PRECEDING MOVE-MASK
         BO    MASKWASH      YES, TAKE THIS MASK
MASKWASN EQU   *             NO MASK HAS BEEN PROVIDED
         AR    LEN,LEN       LEN * 2
         BCTR  LEN,0         REDUCE LENGTH BY ONE                ***
         BCTR  MSG,0         SET POINTER BACK                    ***
         MVC   EDSAV,0(MSG)  SAVE THE BYTE                       ***
         BAL   R14,TESTLEN   LOOK IF MOVE WILL BE OK
         EX    LEN,MVCMASK   MOVE THE MASK TO OUTPUT RECORD
         STH   LEN,EDITLEN   AND SAVE THIS LENGTH
MASKWASH EQU   *
         LH    LEN,EDITLEN   GET LENGTH OF THE MASK
         BAL   R14,TESTLEN   LOOK IF MOVE WILL BE OK
         EX    LEN,EDITINST  DO THE EDIT INSTRUCTION
         TM   SW3,MASKWAS    WAS A MASK PROVIDED ?               ***
         BO    YESITWAS      YES                                 ***
         MVC   0(1,MSG),EDSAV SET BYTE BACK                      ***
YESITWAS EQU   *                                                 ***
         NI    SW3,255-MASKWAS
         LA    MSG,1(LEN,MSG) UPDATE THE OUTPUT RECORD POINTER
         BR    LNK           THEN RETURN
MVCMASK  MVC   0(0,MSG),MASK VARIABLE MVC FOR MASK
EDITINST ED    0(0,MSG),0(R1) EDIT THE DIGITS TO OUTPUT
MASK     DC    C'0'
         DC    31X'21'
OEDIT@   EQU   *
         LH    LEN,FMTCNT    BYTES - 1 TO BE EDITED
         LA    R0,1(LEN)     NUMBER OF BYTES TO BE EDITED  PRECICELY
         LR    R1,PNT        GET EDIT POINTER
         AR    PNT,R0        AND THE INPUT RECORD POINTER
         TM    SW3,MASKWAS   WAS A PRECEDING 'MOVE-MASK' INSTRUCTION
         BO    MASKWASH      YES, TAKE IT
         LA    LEN,1(LEN)    INCREASE REG TO GET CORRECT LENGTH
         B     MASKWASN      NO, MAKE ONE
OIGNI@   EQU   *
         AH    PNT,FMTCNT    ADD REQUIRED NUMBER
         BR    LNK           AND RETURN TO NEXT
OIGNO@   EQU   *
         AH    MSG,FMTCNT    ADD REQUIRED COUNT TO OUTPUT REG
         BR    LNK           AND RETURN TO NEXT
OMOVE@   EQU   *
         LH    LEN,FMTCNT    NUMBER OF BYTES TO BE MOVED
         BAL   R14,TESTLEN   LOOK IF MOVE WILL BE OK
         EX    LEN,MVC
OMOVEUPD EQU   *
         LA    MSG,1(LEN,MSG) UPDATE OUTPUT-RECORD POINTER
         LA    PNT,1(LEN,PNT) UPDATE INPUT RECORD POINTER
         BR    LNK           AND GO ON
MVC      MVC   0(0,MSG),0(PNT)
ONEXT@   EQU   *
         NI    SW3,255-DOISACT
         OI    SW3,DONTPUT   INDICATE THAT OUTPUT RECORD IS NOT TO BE
         B     NEXTFUNC      AND GO ON                              PUT
OODER@   EQU   *
         LA    SW,4(SW)      GET NEXT ENTRY
         TM    0(SW),ORENTRY IS THIS A 'OR' - ENTRY ?
         BO    OODER@        DON'T ANY FURTHER COMPARE
         B     NEXTFMT       BUT DO NEXT ACTION
OPNTI@   EQU   *
         L     PNT,INRECANF    SET POINTER BACK TO START ADDRESS
         AH    PNT,FMTCNT    AND ADD REQUIRED COUNT
         BR    LNK           AND RETURN TO NEXT
OPNTO@   EQU   *
         L     MSG,OUTREC      SET POINTER BACK TO START ADDRESS
         AH    MSG,FMTCNT    AND ADD REQUIRED COUNT
         BR    LNK           AND RETURN TO NEXT
ORSTI@   EQU   *
         SH    PNT,FMTCNT    AND SUBTRACT REQUIRED COUNT
         BR    LNK           AND RETURN TO NEXT
ORSTO@   EQU   *
         SH    MSG,FMTCNT    AND SUBTRACT REQUIRED COUNT
         C     MSG,OUTREC .  IS POINTER BEFOR THE OUTPUT RECORD ?
         BCR   10,LNK  .     IF EQUAL OR HIGH THAN OK
         LH    LEN,OCOUNT@ . SET LENGTH TO -1 => WILL RESULT IN 0
         B     DONTMOVE .    PUT A MESSAGE AND TERMINATE
GETACCUL EQU   *
         MVC   PDW(4),FMTAKU#+2   GET TEH SAVE-ENTRY ADDRESS
         L     LIMIT,PDW     LOAD BASE REGISTER WITH IT
         USING SAVDSECT,LIMIT
         L     R1,SAVADR     GET ADDRESS OF THE SAVBER
         LH    LEN,FMTAKU#   LENGTH OF THIS SAVBER
         BR    R15           RETURN TO DO EXECUTE THE MOVE
         DROP  LIMIT
OSAVE@   EQU   *
         BAL   R15,GETACCUL  GET THE SPECIFIED LITERAL ACCU ADDRESS
         EX    LEN,MOVESAV   MOVE THE DATA TO SAVBER
         BR    LNK           AND RETURN
OSETL@   EQU   *
         BAL   R15,GETACCUL  GET THE SPECIFIED LITERAL ACCU ADDRESS
         EX    LEN,SETLIT    SET THE LITERAL TO ACCU
         BR    LNK
OPUTL@   EQU   *
         BAL   R15,GETACCUL  GET THE SPECIFIED LITERAL ACCU ADDRESS
         BAL   R14,TESTLEN   LOOK IF MOVE WILL BE OK
         EX    LEN,PUTLIT    MOVE THE LITERAL ACCU TO OUTPUT RECORD
         LA    MSG,1(LEN,MSG)  UPDATE POINTER
         BR    LNK
CLCSAV   CLC   0(0,PNT),0(R1)  COMPARE INPUT RECORD FIELD WITH SAVBER
SETLIT   MVC   0(0,R1),FMTAKU#+6
PUTLIT   MVC   0(0,MSG),0(R1)
MOVESAV  MVC   0(0,R1),0(PNT)
MVCWLOG  MVC   1(0,WK2),0(LNK) MOVE SYSUT2 REC TO SYSPRINT REC
OSCAN@   EQU   *
         L     R15,ASCAN     GET ADDRESS OF SCAN ROUTINE
         BALR  R14,R15       AND LINK TO IT
         LTR   LIMIT,LIMIT   TEST INDICATION REGISTER
         BCR   2,LNK         IF PLUS, => SCAN WAS SUCCESSFUL
         B     NICHT1        IF NOT, LITERAL WAS NOT FOUND => NEXT FMT
OSTOP@   EQU   *
         TM    SW3,DOISACT   IS THIS A UPRO END ?
         BO    ODORET        YES, RETURN TO NORMAL FORMAT PROCESSING
         TM    SW4,FIRSTWAS+LASTIS  IS FIRST OR LAST FORMAT PROCESSED ?
         BZ    NOTFIRST
         TM    SW4,LASTIS    WAS IT LAST
         BO    XRET          YES, TERMINATE
         NI    SW4,255-FIRSTWAS        CLEAR THE SWITCH AND
         B     DACAPO        DO PROCESSING OF FIRST RECORD
NOTFIRST EQU   *
         TM    SW4,FIRSTLIN  IS 'COUNT'-PROCESSING ACTIVE ?
         BO    OVEND         YES, GO TO PAGE OVERFLOW END ROUTINE
         BAL   LNK,OPUT      PUT THE OUTPUT-RECORD
         TM    SW4,LASTIS    IS 'LAST'-PROCESSING ACTIVE ?
         BO    OENDE         YES, GO TO END IMMEDIATELY
         BAL   LNK,CLEAROUT  CLEAR OUTPUT RECORD
         B     NEXTFUNC      DO NEXT FUNCTION
OWLOG@   EQU   *
         ST    LNK,LNKSAVE   SAVE THE LINK REG
         LH    LEN,FMTCNT    GET THE LENGTH TO BE MOVED
         L     R1,ALISTE     GET OUTPUT DCB FOR MESSAGES
         L     LNK,OUTREC    GET TYHE OUTPUT RECORD FOR SYSUT2
         EX    LEN,MVCWLOG   MOVE IT TO MESSAGE LINE
         MVI   ASA,BLANK     SPACE ONE LINE
*        PUT   (1),(WK2)     PUT THE LINE
         PUT   (1),(WK2)     PUT THE LINE
         BAL   LNK,CLRLINE   CLEAR THE LINE
         L     LNK,LNKSAVE   GET BACK THE LINKREGISTER
         BR    LNK           AND RETURN
OSUBAC@  EQU   *
         OI    SW3,SUBTRACT  INDICATE THIS IS A SUBTRACTION
OADDAC@  EQU   *
         BAL   R14,GETACCUS
         TM    SW3,SUBTRACT  IS SUBTRACTION REQUIRED ?
         BO    AKKUNEG       YES, GO TO SUBTRACTION
         AP    0(8,R1),0(8,LIMIT)      ADD CONTENT OF SECOND ACCU TO 1.
         BR    LNK           AND RETURN
AKKUNEG  EQU   *
         SP    0(8,R1),0(8,LIMIT)      SUBTRACT CONTENT OF 2. ACCU FROM
         NI    SW3,255-SUBTRACT        CLEAR THE SWITCH
         BR    LNK           AND RETURN
OSUBBI@  EQU   *
         OI    SW3,SUBTRACT  INDICATE THIS IS A SUBTRACTION
OADDBI@  EQU   *
         LH    LIMIT,FMTAKU# LENGTH OF THE FIELD TO BE ADDED
         MVC   ADDBIWD,0(PNT)  MOVE THE SUMMAND TO WORKFIELD
         L     R15,ADDBIWD   LOAD WORK REG WITH SUMMAND
         LNR   LIMIT,LIMIT   COMPLEMENT TO LENGTH
         AH    LIMIT,=H'3'   AND ADD MAXIMUM LENGTH
         SLL   LIMIT,3       * 8   (ONE BYTE HAS 8 BITS )
         SRA   R15,0(LIMIT)  NOW ARITHMETIC VALUE OF WORK REG IS OK
         L     R1,AACCU      ACCUS START ADDRESS
         LH    LIMIT,FMTCNT  ACCU DISPLACEMENT
         CVB   R0,0(R1,LIMIT) GET ACCU CONTENTS
         TM    SW3,SUBTRACT  IS SUBTRACTION REQUIRED ?
         BZ    BINNEG
         LCR   R15,R15       COMPLEMENT WORK REG
         NI    SW3,255-SUBTRACT        CLEAR THE SWITCH
BINNEG   EQU   *
         AR    R0,R15        ADD THE SUMMAND
         CVD   R0,0(R1,LIMIT)   AND UPDATE THE ACCU
         BR    LNK           AND RETURN
OSUBCH@  EQU   *
         OI    SW3,SUBTRACT  INDICATE THIS IS A SUBTRACTION
OADDCH@  EQU   *
         L     R1,AACCU      ACCUS START ADDRESS
         AH    R1,FMTCNT     ACCU ADDRESS
         LH    LIMIT,FMTAKU# LENGTH OF FILD
         EX    LIMIT,PACKCH  PACH THE FIELD TO A WORK DOUBLE WORD
OCOMADD  EQU   *             COMMON ROUTINE FOR ADD
         TM    SW3,SUBTRACT  IS A SUBTRACTION REQUIRED ?
         BO    CHNEG
         AP    0(8,R1),PDW   ADD THE FIELD TO ACCU
         BR    LNK           AND RETURN
PACKCH   PACK  PDW,0(0,PNT)  PACK THE ADDRESSED FIELD
CHNEG    EQU   *
         SP    0(8,R1),PDW   SUBTRACT THE ADDRESSED FIELD
         NI    SW3,255-SUBTRACT        CLEAR THE SWITCH
         BR    LNK           AND RETURN
OSUBPD@  EQU   *
         OI    SW3,SUBTRACT  INDICATE THIS IS A SUBTRACTION
OADDPD@  EQU   *
         L     R1,AACCU      ACCUS START ADDRESS
         AH    R1,FMTCNT     ADDRESS THE ACCU
         LH    LIMIT,FMTAKU# LENGTH OF THE REQUIRED FIELD
         EX    LIMIT,ZAPPD   ZAP THE PACKED FIELD TO WORK-DOUBLE-WORD
         B     OCOMADD       AND GO TO COMMON ADD ROUTINE
ZAPPD    ZAP   PDW,0(0,PNT)  ZAP THE REQUIRED FIELD
OSUBKT@  EQU   *
         OI    SW3,SUBTRACT  INDICATE THIS IS A SUBTRACTION
OADDKT@  EQU   *
         L     R1,AACCU      GET START ADDRESS OF ACCUS
         AH    R1,FMTCNT     GET ACCU ADDRESS
         TM    SW3,SUBTRACT  IS SUBTRACTION REQUIRED ?
         BO    KONSTNEG
         AP    0(8,R1),FMTKONST        ADDTHE CONSTANT
         BR    LNK           AND RETURN
KONSTNEG EQU   *
         SP    0(8,R1),FMTKONST        SUBTRACT THE CONSTANT
         NI    SW3,255-SUBTRACT        CLEAR THE SWITCH
         BR    LNK           AND RETURN
OCOMPU@  EQU   *
OCOMPE@  EQU   *
OCOMPH@  EQU   *
OCOMPL@  EQU   *
         BAL   R15,GETACCUL  GET THE SPECIFIED LITERAL ACCU ADDRESS
         IC    R15,FMTCNT    CONDITION CODE
         EX    LEN,CLCSAV    EXECUTE COMPARE INSTRUCTION
         EX    R15,BRANCH    AND  BRANCH ON REQUIRED CONDITION
         BR    LNK           IF BRANCH WAS NOT TAKEN, GO ON
OIFEQ@   EQU   *
OIFGE@   EQU   *
OIFGT@   EQU   *
OIFLE@   EQU   *
OIFLT@   EQU   *
OIFNE@   EQU   *
OFINDE@  EQU   *
OFINDH@  EQU   *
OFINDL@  EQU   *
OFINDU@  EQU   *
         L     R1,INRECANF   GET START ADDRESS OF INPUT RECORD
         AH    R1,FMTCNT     ADD DISPLACEMENT TOADDRESS REQUIRED FLD
         IC    R15,FMTLITLN+1 GET LITERAL LENGTH READY FOR EXECUTE
         IC    R14,FMTLITLN  GET CONDITION-CODE FOR BRANCH
         EX    R15,CLCLIT    EXECUTE THE COMPARISON
         EX    R14,BRANCH    AND THE ASSOCIATED BRANCH
         BR    LNK           IF COMPARE FAILS GO ON
CLCLIT   CLC   0(0,R1),FMTLIT   COMPARE INPUT-REC-FIELD WITH LITERAL
BRANCH   NOP   NICHT1        IF CONDITION WAS MATCHING
OFIRST@  EQU   *
         LA    SW,4(SW)      ADD 4 TO POINTER
         ST    SW,AACTIONS   AND UPDATE POINTER TO GET NEVER THIS ENTRY
         OI    SW4,FIRSTWAS  INDICATE THAT CONDITION
         BR    LNK           RETURN                             AGAIN
OIFACE@  EQU   *
OIFACH@  EQU   *
OIFACL@  EQU   *
OIFACU@  EQU   *
         L     R1,AACCU      ADDRESS OF ACCUMULATOR FIELDS
         SR    LIMIT,LIMIT   CLEAR REG
         IC    LIMIT,FMTAKU#+1 GET 2. ACCU NUMBER ( -1)
         SLL   LIMIT,3       * 8 TO GET ACCU DISPLACEMENT
         AR    LIMIT,R1      A(2. ACCU)
         AH    R1,FMTCNT     A(1. ACCU)
         IC    R14,FMTAKU#   GET CONDITION CODE
         CP    0(8,R1),0(8,LIMIT)      COMPARE THE ACCUS
         EX    R14,BRANCH    BRANCH ON NOT REQUIRED CONDITION
         BR    LNK           BRANCH ON CONDITION REQUIRED
OMOVEL@  EQU   *
         LH    LEN,FMTLITLN  GET LENGTH TO BE MOVED
         BAL   R14,TESTLEN   LOOK IF MOVE WILL BE OK
         EX    LEN,MVCLIT
         LA    MSG,1(LEN,MSG) UPDATE OUTPUT POINTER
         BR    LNK           AND RETURN
MVCLIT   MVC   0(0,MSG),FMTLIT         MOVE THE LITERAL FROM FORMATENTR
OMOVEM@  EQU   *
         OI    SW3,MASKWAS   INDICATE THAT A MASK WAS HERE
         LH    LEN,FMTLITLN  GET LENGTH TO BE MOVED
         BAL   R14,TESTLEN   LOOK IF MOVE WILL BE OK
         STH   LEN,EDITLEN   SAVE THE LENGTH OF THE MASK FOR EDIT
         EX    LEN,MVCLIT    MOVE THE LITERAL
         BR    LNK           AND RETURN
OMOVEN@  EQU   *
         LH    LEN,FMTCNT    GET THE LENGTH TO BE MOVED
         BAL   R14,TESTLEN   LOOK IF MOVE WILL BE OK
         EX    LEN,MVN       EXECUTETHE MOVE
         B     OMOVEUPD      AND GO TO COMMON RETURN ROUTINE
MVN      MVN   0(0,MSG),0(PNT)         MVN INSTRUCTION FOR EXECUTE
OMOVER@  EQU   *
         L     LEN,INRECEND  GET END OF THE INPUT RECORD
         SR    LEN,PNT       SUBTRACT ACTUAL POINTER  = REMAINING LENG
         BCR   13,LNK        IF NOT PLUS RETURN
         BCTR  LEN,0         REDUCE BY ONE
         B     OMVCLNG       GO TO MOVE ROUTIME
OMOVEZ@  EQU   *
         LH    LEN,FMTCNT    GET THE LENGTH TO BE MOVED
         BAL   R14,TESTLEN   LOOK IF MOVE WILL BE OK
         EX    LEN,MVZ       EXECUTETHE MOVE
         B     OMOVEUPD      AND GO TO COMMON RETURN ROUTINE
MVZ      MVZ   0(0,MSG),0(PNT)         MVZ INSTRUCTION FOR EXECUTE
INCOUNT  EQU   * .           IF PRINT IS SPECIFIED IN COUNT STATEMENT
*                            REGS MUST BE STORED TO SOME OTHER PLACE
         ST    WK1,FMTSAVE3 .SAVE REG
         ST    LNK,LNKSAVE3 .SAVE REG
         BAL   LNK,OPUT .    PUT THE OUTPUT-RECORD
         BAL   LNK,CLEAROUT .CLEAR THE OUTPUT LINE
         L     LNK,LNKSAVE3 .GET REG BACK
         L     WK1,FMTSAVE3 .GET REG BACK
         BR    LNK .         AND RETURN
OPRINT@  EQU   *
         TM    SW4,FIRSTLIN .IS THIS PRINT IN COUNT FORMAT ?
         BO    INCOUNT .     YES, DON'T DESTROY RETURN REGS
         ST    WK1,FMTSAVE2  SAVE FORMAT POINTER
         ST    LNK,LNKSAVE2
         BAL   LNK,OPUT      PUT THE OUTPUT RECORD
         BAL   LNK,CLEAROUT  CLEAR THE OUTPUT RECORD
         L     LNK,LNKSAVE2
         L     WK1,FMTSAVE2  GET FORMATPOINTER BACK
         BR    LNK           AND GO ON
OMVTAB@  EQU   *
         L     R1,ATABELEM . GET THE ADDRESS OF LAST TABLE ELEMENT
         LTR   R1,R1 .       TEST IF THERE WAS ONE FOUND
         BCR   8,LNK .       IF NOT, RETURN WITH DOING ANYTHING
         LA    R1,1(R1) .    SET OVER REFERENCE MARK
         AH    R1,FMTCNT     R1 POINTS NOW TO REQUIRED FIELD
         LH    LEN,FMTCNT+2  GET LENGTH READY FOR EXECUTE
         BAL   R14,TESTLEN . TEST IF MOVE WILL FIT
         EX    LEN,PUTLIT    MOVE THE LITERAL  FROM TABLE TO LINE
         LA    MSG,1(LEN,MSG) INCREASE OUTPUT POINTER REG
         BR    LNK           AND GO ON
OUNDEF   EQU   *
         BAL   LNK,CLRLINEB    CLEAR THE OUTPUT LINE             ***
         MVC   ACARDOUT+2(L'UNDEFMSG),UNDEFMSG                   ***
PRINTERR EQU   *
         MVC   AFLAG,ERRFLAG FLAG THE LINE                       ***
         BAL   LNK,ERRPUT    PUT THE ERROR MESSAGE
         L     R15,AGENDUMP
         L     R0,INRECANF   START ADDRESS OF AREA TO BE DUMPED
         L     R1,INRECEND     END ADDRESS OF AREA TO BE DUMPED
         BALR  R14,R15       LINK TO DUMP ROUTINE
         B     ERRRET        TERMINATE RUN                       ***
CLEAROUT EQU   *
         L     MSG,OUTREC    ADDRESS OF OUTPUT-RECORD
         ST    MSG,OUTRECPT  SET MAXIMUM OUTPUT POINTER  BACK
         L     R1,AOUTPUT    OUTPUT DCB ADDRESS
         AIF   (&S).OSRECL
         LH    LIMIT,RECL-MAINPARM+ENTRYLL*1(PRM) GET RECORD LENGTH
*              OF SYS001 (OUTPUT) - MUST BE IN SECOND DTF- ENTRY
         AGO   .SUBLIM
.OSRECL  ANOP
         LH     LIMIT,DCBLRECL RECORD-LENGTH
.SUBLIM  ANOP
         BCTR  LIMIT,0
         MVI   0(MSG),BLANK  BLANK FIRST BYTE OF OUTPUT RECORD
*        MOVE  1(MSG),(LIMIT),(MSG),CPU=360  AND THE REST OF THE RECORD
         MOVE  1(MSG),(LIMIT),(MSG),CPU=360  AND THE REST OF THE RECORD
         L     PNT,INRECANF  SET INPUT RECORD POINTER BACK
         TM    SW4,COUNTWAS  IS LINE COUNT SPECIFIED ?
         BCR   8,LNK         NO, GO BACK
         TM    SW4,FIRSTWAS  IS FISRT FORMAT ACTIV ?
         BCR   1,LNK         IF YES, RETURN WITHOUT COUNTING
         L     R1,LINECNT    GET ACTUAL COUNT
         C     R1,LINECOMP   COMPARE WITH REQUIRED COUNT
         BCR   4,LNK         IF LOW, GO BACK
COUNTFMT EQU   *
         SR    R1,R1         SET COUNT TO 0
         ST    R1,LINECNT    AND LINE COUNT
         ST    WK1,FMTSAVE   SAVE ACTUAL FORMAT POINTER
         ST    LNK,LNKSAVE   AND BRANCH REGISTER
         L     WK1,NEWPAGE   GET 'FIRST' ENTRY ADDRESS
         OI    SW4,FIRSTLIN  INDICATE ACTIVE 'COUNT'-PROCESSING
         B     NEXTOP        DO THE COUNT FORMAT
OPCKAC@  EQU   *
         LA    R15,PACKOUT   GET ASSOCIATED INSTRUCTION
PCKUPK   EQU   *
         L     R1,AACCU      GET ADDRESS OF ACCUS
         AH    R1,FMTCNT     ADD DISPLACEMENT OF SPECIFIED ACCU
         LH    LEN,FMTAKU#   GET SPECIFIED LENGTH
         BAL   R14,TESTLEN   LOOK IF LENGTH FITS IN OUTPUT BUFFER
         SLL   LEN,4         SHIFT LENGTH FOR EXECUTE
         EX    LEN,0(R15)    DO THE REQUIRED INSTRUCTION
         SRL   LEN,4         SET LENGTH REGISTER BACK FOR UPDATE
         LA    MSG,1(LEN,MSG) UPDATE OUTPUT RECORD POINTER
         BR    LNK           AND RETURN
OUNPAC@  EQU   *
         LA    R15,UNPKOUT   GET ASSOCIATED INSTRUCTION
         B     PCKUPK        GO TO COMMON ROUTINE
PACKOUT  ZAP   0(0,MSG),0(8,R1) ZAP ACCU TO OUTPUT RECORD
UNPKOUT  UNPK  0(0,MSG),0(8,R1) UNPK ACCU TO OUTPUT RECORD
OACKTE@  EQU   *
OACKTL@  EQU   *
OACKTH@  EQU   *
OACKTU@  EQU   *
         L     R1,AACCU      BASE OF ACCUS
         AH    R1,FMTCNT     ADD DISPLACEMENT OF SPECIFIED ACCU
         IC    R14,FMTKONST  GET THE ASSOCIATED CONDITION MASK
         CP    0(8,R1),FMTKONST+1(7)   COMPARE IT WITH CONSTANT
         EX    R14,BRANCH    DO THE BRANCH TO NEXT FORMAT,
*                            IF REQUIRED CONDITION WAS NOT
         BR    LNK           GO ON IN THIS FORMAT, IF CONDION WAS
OVEND    EQU   *
         NI    SW4,255-FIRSTLIN   CLEAR SWITCH
         BAL   LNK,OPUT      PUT THIS LINE
         NI    SW4,255-COUNTWAS CLEAR SWITCH TEMPORARY
         BAL   LNK,CLEAROUT  CLEAR THE LINE
         OI    SW4,COUNTWAS  RESET SWITCH
         L     LNK,LNKSAVE   GET BRANCH REGISTER BACK
         L     WK1,FMTSAVE   AND FORMAT POINTER
         BR    LNK           RETURN TO INTERRUPTED PROCESSING
OPUT     EQU   *
         TM    SW4,ORECFMV   IS OUTPUT RECFM VARIABLE ?
         BZ    FIX           NO, ASSUME FIX
         L     R1,OUTREC     GET OUTPUT RECORD ADDRESS
         L     MSG,OUTRECPT  GET MAXIMUM OUTPUT POINTER
         SR    MSG,R1        COMPUTE CURRENT RECORD LENGTH
         CH    MSG,=H'4'     IS RECORD LENGTH PLAUSIBLE ?
         BCR   13,LNK        NO, RETURN WITHOUT PUTTING
         STH   MSG,0(R1)     AND STORE IT TO RECORD DESCRIPTOR WORD
FIX      EQU   *
         L     R1,AOUTPUT    GET OUTPUT DCB
         L     R0,OUTREC     AND THE RECORD TO BE PUT
*        PUT   (1),(0)       AND PUT THE RECORD
         PUT   (1),(0)       AND PUT THE RECORD
         L     R15,UT2AST    GET ADDRESSOF ASTCODE
         LTR   R15,R15       IF THER EIS ONE
         BZ    NOUT2AST      IF THERE IS NONE, PREVENT LINK
         L     LIMIT,OUTREC  SET POINTER REG TO RECORD
         BAL   R14,8*8+2(R15) LINK TO ASTCODE
NOUT2AST EQU   *
         L     R1,OUTCNT     GET ACTUAL RECORD COUNT             ***
         LA    R1,1(R1)      ADD 1
         ST    R1,OUTCNT     AND UPDATE THE RECORD COUNT         ***
         TM    SW4,COUNTWAS  IS LINE COUNTING NECESSARY ?
         BCR   8,LNK         NO, GO BACK
         L     R1,LINECNT    GET THE ACTUAL LINE-COUNT
         LA    R1,1(R1)      ADD 1
         ST    R1,LINECNT    AND UPDATETHE COUNT
         BR    LNK
OBINAC@  EQU   * .           BINARY OUTPUT OF ACCU CONTENT
         L     R1,AACCU .    GET BASE OF ACCUS
         AH    R1,FMTCNT .   ADD DISPLACEMENT OF SPECIFIED ACCU
         LH    LEN,FMTAKU# . SPECIFIED LENGTH (READY FOR EXECUTE )
         BAL   R14,TESTLEN . TEST IF MOVE LENGTH WILL FIT
         CVB   R0,0(R1) .    R0 = ACCU CONTENT
         LNR   LIMIT,LEN .   COMPLEMENT OF THE LENGTH FOR EX
         AH    LIMIT,=H'3' . ADD MAXIMUM POSSIBLE LENGTH
         SLL   LIMIT,3 .     * 8 (BITS TO BE SHIFTED)
         SLA   R0,0(LIMIT) . ALIGN THE VALUE
         ST    R0,ADDBIWD .  BRING IT TO STORAGE
         EX    LEN,BINACMVC .MOVE IT TO OUTREC IN SPECIFIED LENGTH
         LA    MSG,1(LEN,MSG) UPDATE OUTREC POINTER
         BR    LNK .         AND RETURN TO DRIVER
BINACMVC MVC   0(0,MSG),ADDBIWD MOVE INSTRUCTION
NUMBRAN  EQU   *
         BCR   4,LNK .       IF COMPLETE
         B     *+4(LIMIT)
         B     NICHT1
         B     NICHT1
         BR    LNK
NUMTRT   TRT   0(0,R1),0(R14)
NUM9BRAN EQU   * .           TEST FOR PACKED DECIMAL MUST BE COMPLETE
*                            WITH CODE 4 IN REG 2 (LIMIT)
         BCR   12,LNK .      IF ZERO OR INCOMPLETE ==> NOT PACKED
         B     *(LIMIT) .    MUST BE 4 OR 8 IN REG LIMIT
         B     NICHT1 .      GO TO BRANCH EXIT
         BR    LNK .         RETURN IF CODE 8
ONOT9P@  EQU   *
         LA    R0,NUM9BRAN . SET R0 TO TRT-EXIT
         B     NUMCOMM .     GO TO COMMON TEST ROUTINE
ONOT99@  EQU   *
         LA    R0,NUMBRAN .  SET R0 TO TRT-EXIT
NUMCOMM  EQU   *
         L     R1,INRECANF . GET POINTER TO INPUT REC
         AH    R1,FMTCNT .   R1 POINTS NOW TO SPECIFIED FIELD
         LH    R15,FMTLITLN .FIELD LENGTH (READY FOR EXECUTE)
         SR    LIMIT,LIMIT . CLEAR TRT REG
         MVC   PDW,FMTLIT .  GET TRT-TABLE ADDRESS ALIGNED
         L     R14,PDW .     AND INTO REG
         EX    R15,NUMTRT .  DO THE TRT INSTRUCTION
         LR    R15,R0 .      GET BRANCH ADDRESS
         BR    R15 .         AND GO TO ASSOCIATED BRANCH EXIT
CLRLINE  EQU   *
         L     R15,PRTCNT    GET LINE COUNT
         LA    R15,1(R15)    ADD ONE
         ST    R15,PRTCNT    STORE IT BACK
         C     R15,MAXLINES  IS PAGE FULL
         BL    CLRLINEB      NO
         L     R15,AHEADPRT  GET HEADER PRINT ROUTINE'S ADDRESS
         BALR  R14,R15       AND BRANCH TO IT
CLRLINEB EQU   *
         MVI   ASA,BLANK     CLEAR THE OUT PUT LINE
         MVC   AFLAG(ALINELEN),ASA     WITH BLANKS
         BR    LNK           AND RETURN
GETACCUS EQU   *
         L     R1,AACCU      ACCUS START ADDRESS
         LH    LIMIT,FMTAKU# GET  ID OF SECOND ACCU
         SLL   LIMIT,3       * 8  TO GET DISPLACEMENT
         AR    LIMIT,R1      A( 2. ACCU)
         AH    R1,FMTCNT     A( 1. ACCU)
         BR    R14           RETURN
OSAME@   EQU   *
         L     PNT,INRECANF  SET INPUT POINTER BACK TO START
         B     DACAPO        AND BEGIN WITH FIRST FORMAT
OTIME@   EQU   *
         LA    LEN,L'ATIME-1  SET LENGTH OF THE MOVE
         BAL   R14,TESTLEN   LOOK IF MOVE WILL BE OK
         MVC   0(L'ATIME,MSG),ATIME    MOVE TIME TO OUTPUT RECORD REC
         LA    MSG,L'ATIME(MSG)         SET POINTER REG OVER
         BR    LNK           AND RETURN
ODATM@   EQU   *
         LA    LEN,4 .       LENGTH WILL BE 5
         BAL   R14,TESTLEN . TEST IF LENGTH WILL FIT
         AIF    (&S).OSDATM
         MVC   0(2,MSG),ADATE+8 MOVE YEAR
         MVC   2(2,MSG),ADATE+3 MOVE MONTH
         MVC   4(1,MSG),ADATE   MOVEDECADE
         AGO   .COMDATM
.OSDATM  ANOP
*        TIME  DEC .         ISSUE TIME SVC
         TIME  DEC .         ISSUE TIME SVC
         ST    R1,PDW .      STORE DATE
         UNPK  0(5,MSG),PDW+1(3) UNPACK DATE TO OUTPUT REC
.COMDATM ANOP
         LA    MSG,5(MSG) .  SET POINTER OVER
         BR    LNK .         AND GO ON
ODATE@   EQU   *
         LA    LEN,L'ADATE-1  SET LENGTH OF THE MOVE
         BAL   R14,TESTLEN   LOOK IF MOVE WILL BE OK
         MVC   0(L'ADATE,MSG),ADATE    MOVE DATE TO LINE
         LA    MSG,L'ADATE(MSG)         SET POINTER OVER
         BR    LNK           AND RETURN
OCNT0@   EQU   *
ORSTC@   EQU   *
         TM    SW4,FIRSTLIN .IS COUNT PROCESSING ACTIVE ?
         BO    COUNTERR .    THIS CNT0 WOULD CAUSE AN ENDLESS LOOP
         L     R1,NEWPAGE .  WAS A COUNT FORMAT SPECIFIED ?
         LTR   R1,R1 .       TEST
         BNZ   COUNTFMT .    ASSUME ADDRESS IS CORRECT
COUNTERR EQU   *
         BAL   LNK,CLRLINEB .CLEAR THE OUTPUT LINE WITHOUT COUNTING
         MVC   ACARDOUT+2(L'CNTERR),CNTERR MOVE MESSAGE
         B     PRINTERR .    PRINT AND EXIT
ODIV@    EQU   *
         BAL   R14,GETACCUS  GET THE ACCUS TO OPERATE WITH
         ZAP   DMACCU,0(8,R1)  BRING FIRST ACCU TO WORK FIELD
         DP    DMACCU,0(8,LIMIT)   DIVIDE BY SECOND ACCU
         ZAP   0(8,R1),DMACCU(8)       REPLACE 1. ACCU BY QUOTIENT
         BR    LNK           AND RETURN
OMULT@   EQU   *
         BAL   R14,GETACCUS  GET THE ACCUS TO OPERATE WITH
         ZAP   DMACCU,0(8,R1)  BRING FIRST ACCU TO WORK FIELD
         MP    DMACCU,0(8,LIMIT)   MULTIPLY BY SECOND ACCU
         ZAP   0(8,R1),DMACCU+8(8)     REPLACE ACCU 1 WITH PRODUCT
         BR    LNK
OMOVEX@  EQU   *
         LH    LEN,FMTCNT    NUMBER OF BYTES
         LR    R0,LEN        LOAD PARM REG
         AR    LEN,LEN       LENGTH AFTER 'CONVXE'
         BAL   R14,TESTLEN   LOOK IF MOVE WILL BE OK
         EX    LEN,MVC       MOVE +1 BYTE
         LR    R1,MSG        POINTER TO STRING
         L     R15,ACONVXE   ADDRESS OF CONVERSION ROUTINE
         BALR  R14,R15       LINK TO IT
         AR    MSG,LEN       ADD EXPANDED STRING LENGTH
         AR    PNT,R0        ADD ORIGINAL STRING LENGTH
         BR    LNK           AND RETURN
OMVCLONG EQU   *             THIS ROUTINE MOVES CHARACTER STRINGS,
*                            THAT ARE LONGER THAN 256 BYTES
         LH    LEN,FMTCNT    GET LENGTH TO BE MOVED (-1)
OMVCLNG  EQU   *
         BAL   R14,TESTLEN   LOOK IF LENGTH WILL FIT
*        MOVE  (MSG),1(LEN),(PNT)      INIT MOVE PARMS
         MOVE  (MSG),1(LEN),(PNT)      INIT MOVE PARMS
         B     OMOVEUPD      GO TO COMMON UPDATE ROUTINE
TESTLEN  EQU   *
         LA    LIMIT,1(LEN,MSG) POINT TO END BYTE OF THE MOVE
         C     LIMIT,OUTRECLM IS IT HIGHER THAN OUTPUT RECORD SIZE ?
         BH    DONTMOVE      YES, PREVENT THE MOVE
         C     LIMIT,OUTRECPT IS A NEW MAXIMUM ?
         BCR   13,R14        NO, LET THE OLD ONE
         ST    LIMIT,OUTRECPT SAVE THE OUTPUT RECORD MAXIMUM
         BR    R14           RETURN TO DO THE MOVE
DONTMOVE EQU   *
         BAL   LNK,CLRLINE   CLEAR THE OUTPUT LINE
         MVC   ACARDOUT(L'MOVEERR),MOVEERR
         MVC   AFLAG,ERRFLAG
         MVC   ACARDOUT+L'MOVEERR+4(L'POINT),POINT
         MVC   ACARDOUT+L'MOVEERR+L'POINT+14(L'MVCLEN),MVCLEN
         S     MSG,OUTREC    RELATIVE OUTPUT POSITION
         BM    OVEROUT .     IF NEGATIVE => DON'T REDUCE
         LA    MSG,1(MSG)    DISPLACEMENT TO POSITION
OVEROUT  EQU   *
         CVD   MSG,PDW       CONVERT IT
         MVC   ACARDOUT+L'MOVEERR+L'POINT+4(7),EDMSK
         ED    ACARDOUT+L'MOVEERR+L'POINT+4(7),PDW+5
         LA    LEN,1(LEN)    EXACT MOVE LENGTH
         CVD   LEN,PDW       CONVERT IT
         MVC   ACARDOUT+L'MOVEERR+L'POINT+L'MVCLEN+18(7),EDMSK
         ED    ACARDOUT+L'MOVEERR+L'POINT+L'MVCLEN+18(7),PDW+5
         BAL   LNK,ERRPUT    PUT THE ERROR MESSAGE
         BAL   LNK,CLRLINE   CLEAR THE LINE
         MVC   ACARDOUT(L'INRECORD),INRECORD
         BAL   LNK,ERRPUT    PUT THE ERROR MESSAGE
         L     R0,INRECANF   GET ADDRESS OF INPUT RECORD
         L     R1,INRECEND   AND ITS END
         L     R15,AGENDUMP  GET ADDRESS OF DUMP ROUTINE
         BALR  R14,R15       AND LINK TO IT
         BAL   LNK,CLRLINE   CLEAR THE LINE
         MVC   ACARDOUT(L'OTRECORD),OTRECORD
         BAL   LNK,ERRPUT    PUT THE ERROR MESSAGE
         L     R0,OUTREC     GET ADDRESS OF OUTPUT RECORD
         L     R1,OUTRECLM   AND ITS END
         L     R15,AGENDUMP  GET ADDRESS OF DUMP ROUTINE
         BALR  R14,R15       AND LINK TO IT
ERRRET   EQU   *
         L     R15,VGENSTAT  GET ADDRESS OF STATISTIC ROUTINE
         BALR  R14,R15       AND LIN  TO IT                      ***
         SR    R15,R15       SET ERROR CODE
         B     RETURN        AND TERMINATE
OFMT@    EQU   *
         LH    SW,FMTCNT     GET RELATIVE NUMBER OF FORMAT-ENTRY
         SLL   SW,2          * 4 (ENTRY-LENGTH
         A     SW,AACTIONS   ADD BASE OF FORMAT-ENTRIES
         B     NEXTFMT       DO THIS FORMAT
ERRPUT   EQU   *
         MVI   ASA,NULL      SPACE TWO LINES                     ***
         L     R1,ALISTE     GET PROTOKOLL DCB ADDRESS           ***
         PUT   (1),(WK2)     PUT THE LINE                        ***
         L     R1,PRTCNT     GET CURRENT PRINT COUNT             ***
         LA    R1,1(R1)       ADD ONE                            ***
         ST    R1,PRTCNT      RESTORE THE LINE COUNT             ***
         BR    LNK           RETURN TO CALLER
VGENSTAT DC    V(GENSTAT)
         LTORG
INRECORD DC    C'INPUT RECORD :'
EDMSK    DC    X'40202020212060' .     MASK FOR POINTER AND LENGTH
OTRECORD DC    C'OUTPUT RECORD :'
UNDEFMSG DC    C'MISSING FORMAT SPECIFICATION FOR THIS RECORD'   ***
MVCLEN   DC    C'MOVE-LENGTH :'
POINT    DC    C'POINTER :'
ERRFLAG  DC    C'*** ERROR **'
MOVEERR  DC    C'MOVE WOULD EXCEED OUTPUT RECORD'
CNTERR   DC    C'COUNT FORMAT MISSING OR RSTC(CNT0) IN IT'
         DC    20CL4'ZAPS'
         SPACE 3
         SPACE 3
WORKSAVE DSECT
OSVA     DS    18F          SAVEAREA
IROUTSV  DS    F             SAVEAREA-ADDRESS OF THE INPUT ROUTINE
OUTRECPT DS    F             ACTUAL POINTER IN OUTPUT RECORD
DOSAVE   DS    F             SAVE FIELD FOR FORMAT POINTER IF 'DO' WAS
ADDBIWD  DS    0F
EDSAV    DS    0CL1          SAVE THE FIRST BYTE AT EDIT  NO MASK***
PDW      DS    D             WORK FIELD FOR CALCULATIONS
DCBLIST  DS    F             DCB-ADDRESS LIST FOR REENTRANT OPEN-CLOSE
LNKSAVE  DS    F             SAVE WORD FOR BRANCH REGISTER
LNKSAVE2 DS    F
FMTSAVE  DS    F             SAVE WORD FOR FORMAT POINTER
UT1AST   DS    F             ADDRESS OF ASTCODE IF SYSUT1 SHOULD 'AST'
UT2AST   DS    F             ADDRESS OF ASTCODE IF SYSUT2 SHOULD 'AST'
UPRADR   DS    F             SPACE FOR ADDRESS OF SUBFORMAT-ENTRY
TABSAV   DS    F             POINTER TO CURRENT TABLE ENTRY ADDRESS
ATABELEM DS    F .           ADDRESS OF TABLE ELEMENT FROM FIND TO MOVE
LNKSAVE3 DS    F .           SAVE WORD FOR LNK REG AT PRINT IN COUNT FM
FMTSAVE3 DS    F .           SAVE WORD FOR WK1 REG AT PRINT IN COUNT FM
FMTSAVE2 DS    F             SECOND FORMAT POINTER SAVE AREA (PRINT)
EDITLEN  DS    H             SAVE FIELD FOR LENGTH OF EDIT INSTRUCTION
         DS   0D
DUMMEND  DS    0D
PARMLENG EQU   *-WORKSAVE               LENGTH OF THIS AREA
         AIF   (&SD).MEND
GENDCBS  DSECT
         GENDCBS
         SPACE 3
GENSAVE  DSECT
         GENSAVE
.MEND    ANOP
         MEND
./ ADD  NAME=GENPARM
         MACRO
         GENPARM &SYS=OS
         AIF   ('&SYS' EQ 'DOS').COP
         AIF   ('&SYS' EQ 'OS').COP
         MNOTE 12,'SYSTEM NOT SUPPORTED, SPECIFY DOS OR OS'
         MEXIT
.COP     ANOP
         BGENMAC SYS=&SYS,DCB=NO
         TITLE ' PROGRAMM ZUR UEBERNAHME DER EXEC - PARAMETER'
*
*              PROGRAMM ZUR UEBERNAHME DER PARAMETER AUS DER EXEC-KARTE
*
*
*              AUTHOR:  H. FRANZ
*
GENPARM  CSECT
         USING MAINPARM,PRM
         AIF   ('&SYS' EQ 'OS').OSXS
*        EXTXS BAS,,GENPARM,PARMLEN,TYP=F,MOD=VGM
         EXTXS BAS,,GENPARM,PARMLEN,TYP=F,MOD=VGM
         AGO   .USING
.OSXS    ANOP
*        XSAVE BAS,,GENPARM,PARMLEN
         XSAVE BAS,,GENPARM,PARMLEN
         LR    PRM,R1                  GET  PARMAREA
.USING   ANOP
         USING SAVEAREA,R13
         LA    R0,10         GET DEFAULT COUNT
         STH   R0,ACCUNUM    FOR NUMBER OF ACCUS
         STH   R0,ANZUPS     FOR NUMBER OF SUB FORMATS
         LA    R0,1          DEFAULT ERROR COUNT
         ST    R0,ERRCOMP    FOR NUMBER OF I/O - ERRORS ALLOWED
         LA    R0,50
         ST    R0,MAXLINES
         L     WK1,APARM               GET  PARMADDR
         LH    LIMIT,0(WK1)            PARM LENGTH
         LTR   LIMIT,LIMIT             TEST IF NO PARMS
         BZ    DEFAULT                 TAKE DEFAULT VALUES
         LA    PNT,2(WK1)
PARMANAL EQU   *
         CLC   ACCUS,0(PNT)  WAS ACCUS?
         BE    ACCUFND       YES
         AIF   ('&SYS' EQ 'DOS').POW
         CLC   PSB,0(PNT)    WAS KEYWORD 'PSB' ?
         BE    PSBFND
         CLC   IS,0(PNT)               KEYWORDS
         BE    ISFND
         CLC   IMS,0(PNT)
         BE    IMSFND
         CLC   PCB,0(PNT)    WAS KEYWORD 'PCB' ?
         BE    PCBFND        YES
         CLC   BUF,0(PNT)     WAS A BUFFER SIZE SPECIFIED ?
         BE    BUFFND         YES, BRING IT TO DLI-PARMS
.POW     ANOP
         CLC   PS,0(PNT)     IS BSAM REQUIRED ?
         BE    PSFND                   FOR
         CLC   POWER,0(PNT)
         BE    POWERFND
         CLC   START,0(PNT)  WAS KEYWORD 'START'
         BE    STARTFND      YES, GO TO INTERPRETE
         CLC   LINES,0(PNT)  WAS KEYWORD 'LINES' ?
         BE    LINESFND      YES, GO TO INTERPRETE
         CLC   UPS,0(PNT)    WAS KEYWORD 'UPS' ?
         BE    UPSFND        YES, GO TO INTERPRETE
PTESTON  CLI   0(PNT),KOMMA            POWER MAY BE SPECIFIED
         BNE   PARMERR
         LA    PNT,1(PNT)              SET POINTER OVER KOMMA
         BCT   LIMIT,PARMANAL          AND SEARCH ON
         B     DEFAULT
PARMERR  OI    SW2,ERR                 INDICATE AN ERROR CONDITION
         B     DEFAULT
PSFND    LA    PNT,L'PS(PNT)           SET POINTER OVER PARM
         OI    SW2,PSORG     INDICATE BSAM REQUIRED
         SH    LIMIT,PSFND+2           SUBTRACT LENGTH
         BNP   DEFAULT                 IF LAST PARM GO ON
         B     PTESTON
         AIF   ('&SYS' EQ 'DOS').POWFND
ISFND    EQU   *                       DSORG=IS
         OI    SW2,ISORG               INDICATE IS
         LA    PNT,L'IS(PNT) SET POINTER OVER PARM FOUND
         SH    LIMIT,*-2     REDUCE LENGTH COUNT
         BNP   DEFAULT       IF NO PARMS LEFT
         B     PTESTON       IF FURTHER PARMS
IMSFND   EQU   *                       DATA-BASE
         OI    SW2,IMSORG              INDICATE DATA-BASE
         LA    PNT,L'IMS(PNT)          SET OVER PARM
         SH    LIMIT,*-2               SUBTRACT LENGTH
         BNP   DEFAULT
         B     PTESTON
.POWFND  ANOP
POWERFND LA    R14,FNCPOWER
         LA    PNT,L'POWER(PNT)
         SH    LIMIT,*-2
         LA    R0,(ENTPOWER+L'ENTPOWER-FNCPOWER)/L'ENTPOWER
POWERLOP CLI   0(PNT),NEUN
         BH    PARMERR
         CLI   0(PNT),NULL
         BL    PTESTON
         IC    R1,0(PNT)
         SLL   R1,28
         SRL   R1,28
         STH   R1,0(R14)
         LA    PNT,1(PNT)              INCREASE POINTER
         LA    R14,L'ENTPOWER(R14)
         BCT   LIMIT,BCTPOWER
         B     DEFAULT
BCTPOWER BCT   R0,POWERLOP
         B     PTESTON
ACCUFND  EQU   *
         LA    PNT,L'ACCUS(PNT)   SET POINTER OVER
         SH    LIMIT,*-2     DECREASE LENGTH OF PARMS
         LR    R1,PNT        SET POINTER REG
         BAL   LNK,DIGIT     GO TO GET A DIGIT CONVERTED
         STH   R1,ACCUNUM    SAVE IT
LOOKLEFT EQU   *             LOOK IF SOMETHING IS LEFT
         LR    PNT,R0        GET UPDATED POINTER REG
LOOKLEF2 EQU   *
         LTR   LIMIT,LIMIT   SOMETHING LEFT ?
         BNP   DEFAULT       NO, RETURN
         B     PTESTON
         AIF   ('&SYS' EQ 'DOS').DIG
PSBFND   EQU   *
         LA    PNT,L'PSB(PNT) SET POINTER OVER KEYWORD
         SH    LIMIT,*-2     REDUCE LENGTH REGISTER
         LR    MSG,PNT       SAVE BEGIN OF THE NAME
         SR    R0,R0         CLEAR COUNT REG
PSBLOOP  EQU   *
         CLI   0(PNT),KOMMA
         BE    PSBMOVE
         LA    PNT,1(PNT)    INCREASE POINTER
         AH    R0,=H'1'      COUNT CHARACTERS OF PSB-NAME
         BCT   LIMIT,PSBLOOP  REDUCE LENGTH AND TRY AGAIN
PSBMOVE  EQU   *
         TM    SW2,IMSORG    WAS 'IMS' ALREADY SPECIFIED ?
         BZ    PARMERR
         CH    R0,=H'8'      NAME LONGER THAN 8 CHARACTERS
         BH    PARMERR       MUST BE ERROR
         LTR   R1,R0         TEST LENGTH IF ZERO
         BNP   PARMERR       NO NAME SPECIFIED => ERROR
         BCTR  R1,0          REDUCE FOR EXECUTE
         LA    R0,L'DLIPRM1+L'DLIPRM2+5(R1)
         LR    WK1,R1        SAVE PSB-NAME LENGTH
*        GETMAIN R,LV=(0)    GET CORE FOR DLI-PARAMETERS
         GETMAIN R,LV=(0)    GET CORE FOR DLI-PARAMETERS
         SR    R0,R0
         ST    R0,0(R1)      CLEAR FIRST WORD
         LA    R1,2(R1)      POINT TO HALFWORD BOUNDARY
         ST    R1,AINPUT     SAVE ADDRESS OF PARMS INTO DCB-ADDRESS
         MVC   2(L'DLIPRM1,R1),DLIPRM1 MOVE FIRST FIX PART OF PARMS
         LA    WK2,L'DLIPRM1
         LA    R1,L'DLIPRM1+2(R1)
         EX    WK1,MOVEPSB   MOVE THE PSB-NAME TO PARM-FIELD
         LA    WK2,1(WK1,WK2) COMPUTE LENGTH OF PARM FIELD
         LA    R1,1(WK1,R1)  SET UP POINTER
         MVC   0(L'DLIPRM2,R1),DLIPRM2
         LA    WK2,L'DLIPRM2(WK2) COMPUTE LENGTH OF PARMFIELD
         L     R1,AINPUT     GET ADDRESS OF THE PARMAREA BACK
         STH    WK2,0(R1)    SET PARM-LENGTH-FIELD
         OI    AINPUT,ENDINDIC SET PARMPOINTER AS IF EXEC PGM
         LTR   LIMIT,LIMIT
         BNP   DEFAULT
         B     PTESTON       LOOK FOR FURTHER PARMS
MOVEPSB  MVC   0(0,R1),0(MSG)
PCBFND   EQU   *
         LA    PNT,L'PCB(PNT) SET POINTER OVER KEYWORD
         SH    LIMIT,*-2     REDUCE LENGTH REG
         LR    MSG,PNT       SAVE BEGIN OF NAME
         SR    R0,R0         CLEAR COUNTER REG
PCBLOOP  EQU   *
         CLI   0(PNT),KOMMA  LOOK FOR KOMMA
         BE    PCBMOVE       IF FOUND, NAME IS COMPLETE
         LA    PNT,1(PNT)    INCREASE POINTER REG
         AH    R0,=H'1'      AND NAME LENGTH
         BCT   LIMIT,PCBLOOP     REDUCE LENGTH AND TRY AGAIN
PCBMOVE  EQU   *
         TM    SW2,IMSORG    WAS 'IMS' SPECIFIED ?
         BZ    PARMERR       IF NOT, PCB DOESN'T MAKE SENSE
         CH    R0,=H'8'      NAME LONGER THAN 8 CHARS
         BH    PARMERR       YES, ERROR
         LTR   WK1,R0
         BNP   TSTLIMIT      IF NO PCBNAME SPECIFIED, TAKE SECOND AS
*                            DEFAULT ONE
         BCTR  WK1,0
         LA    R0,8          LENGTH OF NAME
*        GETMAIN R,LV=(0)    GET CORE FOR PCB-NAME
         GETMAIN R,LV=(0)    GET CORE FOR PCB-NAME
         ST    R1,PCBADR     SAVE THE ADDRESS
         MVI   0(R1),BLANK   BLANK THE NAME FIELD
         MVC   1(7,R1),0(R1)
         EX    WK1,MOVEPSB   MOVE WITH SAME INSTR. AS PSB
TSTLIMIT EQU   *
         LTR   LIMIT,LIMIT   LOOK IF SOMETHING IS LEFT IN PARM FIELD
         BNP   DEFAULT       NOTHING LEFT
         B     PTESTON
.DIG     ANOP
DIGIT    EQU   *
         CLI   0(R1),NEUN    IS A DIGIT ?
         BH    PARMERR       ERROR
         CLI   0(R1),NULL
         BL    GETDIG        ASSUME KOMMA
         LA    R1,1(R1)      INCREASE POINTER
         BCT   LIMIT,DIGIT
         B     DIGEND
GETDIG   EQU   *
         CLI   0(R1),KOMMA   VERIFY THE KOMMA
         BNE   PARMERR       INDICATE THE ERROR
DIGEND   EQU   *
         LR    R0,R1         SAVE POINTER
         SR    R1,PNT        LENGTH OF DIGIT
         BNP   PTESTON
         BCTR  R1,0
         EX    R1,PACK       PACK THE ACCUCOUNT
         CVB   R1,DW         CONVERT IT
         BR    LNK           RETURN TO CALLING ROUTINE
         AIF   ('&SYS' EQ 'DOS').RNDBUF
BUFFND   EQU   *
         LA    PNT,L'BUF(PNT) SET POINTER OVER KEYWORD
         SH    LIMIT,*-2      REDUCE LENGTH-REG BY LENGTH OF KEYWORD
         LR    R1,PNT         SET PARM REG FOR DIGIT INTERPRETATION
         BAL   LNK,DIGIT      GO TO GET THE DIGIT
         OI    DW+7,X'0F'     FORCE SIGN TO BE PRINTABLE
         UNPK  DW(4),DW+4(4)  UNPACK THE COUNT
         MVC   DLIPRM2+1(3),DW+1
         B     LOOKLEFT       GO TO FURTHER INTERPRETATION
.RNDBUF  ANOP
PACK     PACK  DW,0(0,PNT)
UPSFND   EQU   *
         LA    PNT,L'UPS(PNT) SET POINTER OVER KEYWORD
         SH    LIMIT,*-2     REDUCE LENGTH
         LR    R1,PNT        POINT TO EXPECTED DIGIT
         BAL   LNK,DIGIT     GET THE DIGIT
         STH   R1,ANZUPS     OVERWRITE DEFAULT VALUE
         B     LOOKLEFT
LINESFND EQU   *
         LA    PNT,L'LINES(PNT) SET POINTER OVER KEYWORD
         SH    LIMIT,*-2     REDUCE LENGTH
         LR    R1,PNT        POINT TO EXPECTED DIGIT
         BAL   LNK,DIGIT     GET THE DIGIT
         ST    R1,MAXLINES   OVERWRITE DEFAULT VALUE
         B     LOOKLEFT
STARTFND EQU   *
         LA    PNT,L'START(PNT) SET POINTER OVER KEYWORD
         SH    LIMIT,*-2     REDUCE LENGTH
         LR    FUNC,PNT      SAVE BEGIN OF THE KEY
KEYLOOP  EQU   *
         CLI   0(PNT),KOMMA  IS END OF KEY REACHED ?
         BE    KEYMOVE       YES, MOVE THE KEY TO ITS PLACE
         LA    PNT,1(PNT)    IF NOT TEST NEXT BYTE
         BCT   LIMIT,KEYLOOP REDUCE LENGTH AND TRY AGAIN
KEYMOVE  EQU   *
         LR    R0,PNT        GET END OF KEY
         SR    R0,FUNC       MINUS STAR TOF KEY
         BNP   LOOKLEF2      IGNOR PARM AND LOOK FOR FURTHER ONES
         LR    LEN,R0        SAVE LENGTH
         AH    R0,=H'1'      ADD ONE FOR LENGTH BYTE
         AIF   ('&SYS' EQ 'OS').OSGM
*        EXTGM R,LV=(0),MOD=VGM
         EXTGM R,LV=(0),MOD=VGM
         AGO   .SVKEYAD
.OSGM    ANOP
*        GETMAIN R,LV=(0)    GET CORE FOR THE K5Y
         GETMAIN R,LV=(0)    GET CORE FOR THE KEY
.SVKEYAD ANOP
         ST    R1,ASTRTKEY   AND SAVE THE ADDRESS IN VECTOR TABLE
         BCTR  LEN,0         REDUCE BY ONE FOR EXECUTE
         EX    LEN,MOVEKEY   MOVE THE KEY TO ITS PLACE
         STC   LEN,0(R1)     STORE ITS LENGTH (-1)
         B     LOOKLEF2      AND GO ON INTERPRETING
MOVEKEY  MVC   1(0,R1),0(FUNC)
         AIF   ('&SYS' EQ 'OS').OSRET
*EFAULT  EXTXR 0,R,MOD=VFM
DEFAULT  EXTXR 0,R,MOD=VFM
         AGO   .KEYW
.OSRET   ANOP
*EFAULT  XRETURN 0,R         RETURN TO CALLIN7 PRo7R1M
DEFAULT  XRETURN 0,R         RETURN TO CALLING PROGRAM
IS       DC    C'IS'
IMS      DC    C'IMS'
PSB      DC    C'PSB='
PCB      DC    C'PCB='
BUF      DC    C'BUF='        BUFFER SIZE SHOULD BE CHANGED
DLIPRM1  DC    C'DLI,GENMOD,'          FIRST PART OF DLI-PARMS
*              PSB-NAME MUST BE INSERTED BETWEEN THIS TWO PARM-PARTS
DLIPRM2  DC    C',020,01'
.KEYW    ANOP
PS       DC    C'PS'
POWER    DC    C'POWER='
ACCUS    DC    C'ACCUS='
START    DC    C'START='     KEYWORD FOR START-KEY
LINES    DC    C'LINES='     KEYWORD FOR MAXIMUM LINES ON SYSPRINT
UPS      DC    C'UPS='       KEYWORD FOR MAXIMUM DOLLAR-FORMATS
         LTORG
DUMMY    DSECT
SAVEAREA  DS   18F
DW       DS    D
DSEND    DS    0D
PARMLEN  EQU   DSEND-SAVEAREA
.MEND    ANOP
         MEND
./ ADD  NAME=GENREAD
         MACRO
         GENREAD &SYS=OS
         AIF   ('&SYS' EQ 'OS').COP
         AIF   ('&SYS' EQ 'DOS').MNOTE
         MNOTE 12,'&SYS  -SYSTEM IS NOT SUPPORTED, SPECIFY OS OR DOS'
         MEXIT
.MNOTE   ANOP
         MNOTE *,'THIS CSECT IS ONLY REQUIRED FOR OS'
         MEXIT
.COP     ANOP
         BGENMAC SYS=&SYS
         TITLE 'EINGABE ROUTINE FUER BSAM DATEIEN'
*
*        DIESES PROGRAMM WIRD GELADEN, WENN IN DER EXEC-KARTE
*        PARM='PS,.....'  SPEZIFIZIERT WURDE
*
*              AUTHOR:  H. FRANZ
*
GENREAD  CSECT
         STM   R14,BAS,12(R13) SAVE REGISTERS
         LR    BAS,R15       LOAD BASE REG
         USING *-6,BAS
         TM    0(R13),ENDINDIC IS DSECT ALREADY INITIALIZED ?
         BO    INITOK        YES, TAKE EXISTING ONE
         OI    0(R13),ENDINDIC INDICATE THAT INITIALIZATION IS DONE
         LR    PRM,R1        GET PARM POINTER
         USING MAINPARM,PRM
         OI    SW4,LASTREC   FORCE A 'READ' AT FIRST ENTRY
         LA    R0,PARMLEN    LENGTH OF DSECT
         GETMAIN R,LV=(0)    GET CORE FOR DSECT
         XC    0(PARMLEN,R1),0(R1)     CLEAR THE DSECT
         ST    R1,72(R13)    SAVE ADDRESS OF DSECT
         LA    R0,PARMLEN    GET LENGTH OF THE DSECT
         STH   R0,2(R1)      SAVE IT AT BEGIN OF DSECT FOR FREEMAIN
         ST    R1,8(R13)     CHAIN DSECT IN SAVEAREA CHAIN
         ST    R13,4(R1)     AND CHAIN BACKWARD
         LR    R13,R1        SET NEW SAVEAREA POINTER
         USING DUMMY,R13
         MVC   DECBL(DECBLEN),DECB     MOVE THE DECB TO DSECT
         L     R1,4(R13)     GET OLD SAVEAREA
         LM    R0,R1,20(R1)  RELOAD REG0 AND REG1
         B     INITOK+4
INITOK   EQU   *
         L     R13,72(R13)   GET DSECT ADDRESS
         LR    PRM,R1        GET PARMPOINTER
         L     WK2,ALIST     GET OUTPUT LINE
         USING FUNCTION,FUNC
         L     WK1,AINPUT    GET DCB-ADDRESS
         USING IHADCB,WK1
         TM    SW4,LASTREC   IS A READ NECESSARY
         BZ    GET           NO, GET ONLY NEXT RECORD
READ     EQU   *
         L     PNT,AINBUF    GET ADDRESS OF THE BUFFER
         READ  DECBL,SF,(WK1),(PNT),MF=E   READ NEXT BLOCK
         NI    SW4,255-LASTREC         CLEAR THE SWITCH FOR BLOCKEND
         CHECK DECBL         CHECK COMPLETION OF READ
         TM    SW4,IRECFMV   IS INPUT VARIABLE
         BZ    NOVAR
         LH    R1,0(PNT)     GET THE BLOCK-COUNT
         SH    R1,=H'4'      REDUCE IT BY ITS OWN LENGTH
         STH   R1,MAXREC     IS MAXIMUM RECORD LENGTH
         LA    PNT,4(PNT)    SKIP THE BLOCKCOUNT
NOVAR    EQU   *
         ST    PNT,ACTPOINT  SET ACTUAL POINTER IN BLOCK TO BEGIN
         L     R1,INPBLKS    COUNT THE
         LA    R1,1(R1)      INPUT
         ST    R1,INPBLKS    BLOCKS
         TM    SWINPUT,ERR   WAS CONTROL IN SYNAD-ROUTINE ?
         BZ    BLOCKOK       NO, BLOCK IS OK
         NI    SWINPUT,255-ERR  CLEAR THE SWITCH
         TM    SWOPEN,DCK .  ARE FAULTY BLOCKS REQUIRED ?
         BO    READ .        NO,READ NEXT OR TRY TO DO SO
BLOCKOK  EQU   *
         L     LEN,DCBIOBA   A(IOB)
         LH    LEN,22(LEN)   RESIDUAL COUNT
         LH    R0,DCBBLKSI   BLOCKSIZE
         SR    R0,LEN        ACTUAL LENGTH OF BLOCK
         A     R0,AINBUF     ADD START ADDRESS OF THE BLOCK
         ST    R0,BLOCKEND   NOW THE BLOCKEND IS COMPUTED
GET      EQU   *
         CLI   FIDENT,C'S'   IS A 'SKIP' REQUIRED
         BE    LAST
         L     R1,INPRECS    COUNT THE
         LA    R1,1(R1)      INPUT
         ST    R1,INPRECS    RECORDS
         L     PNT,ACTPOINT  GET THE ACTUAL POINTER IN BLOCK
         ST    PNT,INRECANF  THIS IS START OF A NEW RECORD
         TM    SW4,IRECFMV   IS INPUT VARIABLE
         BO    VARIABEL
         AH    PNT,INLRECL   ADD LRECL IF FIXED OR U
RETURN   EQU   *
         ST    PNT,INRECEND  THIS IS THE END OF THE RECORD
         ST    PNT,ACTPOINT  AND UPDATE ACTUAL POINTER
         C     PNT,BLOCKEND  IS END OF THE BLOCH REACHED
         BL    RET           NO, RETURN
LAST     OI    SW4,LASTREC   INDICATE THAT THIS IS THE LAST RECORD
RET      XRETURN 0
VARIABEL EQU   *
         MVC   HW,0(PNT)     MOVE THE RECORD LENGTH TO BOUNDARY
         LH    R1,HW         GET THE LENGTH
         CH    R1,MAXREC     IS RECORD LENGTH POSSIBLE ?
         BH    DUMP          NO, DUMP THE BLOCK
         LTR   R1,R1         TEST IF VALID
         BNP   DUMP          NOT VALID, => GO TO DUMP THE BLOCK
         AR    PNT,R1        UPDATE RECORD POINTER AND RETURN
         LH    R0,MAXREC     GET MAXIMUM POSSIBLE RECORD LENGTH
         SR    R0,R1         REDUCE IT BY LENGTH OF ACTUAL RECORD
         STH   R0,MAXREC     AND RESET THE LENGTH INDICATOR
         B     RETURN
         USING AZEILE,WK2
DUMP     EQU   *
         MVC   ACARDOUT(L'INVBLK),INVBLK   MOVE A MESSAGE
         MVC   AMSGSUB,=C'BLOCK#'
         L     R0,INPBLKS    GET ACTUAL BLOCKCOUNT
         CVD   R0,DW         CONVERT THE COUNT
         OI    DW+7,X'0F'    FORCE SIGN TO 'F'
         UNPK  AACTION,DW    MOVE THEW COUNT TO OUTPUT LINE
         MVI   ASA,EINS      NEW PAGE
         L     R1,ALISTE     GET DCB ADDRESS
         PUT   (1),(WK2)     PUT THE LINE
         L     R15,AGENDUMP  GET ADDRESS OF DUMP ROUITNE
         L     R0,AINBUF     BEGIN IS BUFFER ADDRESS
         L     R1,BLOCKEND   END IS END OF BLOCK
         BALR  R14,R15       LINK TO DUMP ROUTINE
         B     READ          AND READ NEXT BLOCK
INVBLK   DC    C'INVALID RDW IN THIS BLOCK'
         READ  DECB,SF,,,'S',MF=L      READ LIST FORM
DECBLEN  EQU   *-DECB
         LTORG
DUMMY    DSECT
SVA      DS    18F           SAVEAREA FOR READ ROUTINE
ACTPOINT DS    F             ACTUAL RECORD POINTER IN INPUT BLOCK
BLOCKEND DS    F             END OF THE INPUT BLOCK
HW       DS    H             HALFWORD, REQUIRED TO ALIGN RECORD LENGTH
MAXREC   DS    H             MAXIMUM POSSIBLE RECORD LENGTH
DECBL    DS    6F
DW       DS    D
DUMEND   DS    0D
PARMLEN  EQU   DUMEND-DUMMY  LENGTH OF THE DSECT FOR GETMAIN
         MEND
./ ADD  NAME=GENSAVE
         MACRO
&NM      GENSAVE &SYS=OS
         AIF   ('&SYS' EQ 'OS').COP
         AIF   ('&SYS' EQ 'DOS').DOSEND
         MNOTE 12,'SYSTEM &SYS NOT SUPPORTED, SPECIFY DOS OR OS'
         MEXIT
.DOSEND  ANOP
         MNOTE 0,'MODULE NOT NEEDED FOR DOS VERSION OF BASFGEN'
         MEXIT
.COP     ANOP
         SYSDATE
         DC    C'GENSAVE'
         DS    0D
PARMADR  DC    F'0' .        ADDRESS OF COMMUNICATION VECTOR
         MEND
./ ADD  NAME=GENSCAN
         MACRO
         GENSCAN &SYS=OS
         AIF   ('&SYS' EQ 'DOS').COP
         AIF   ('&SYS' EQ 'OS').COP
         MNOTE 12,'SYSTEM NOT SUPPORTED, SPECIFY DOS OR OS'
         MEXIT
.COP     ANOP
         BGENMAC SYS=&SYS,DCB=NO
         TITLE 'LUGENER SCAN ROUTINE'
GENSCAN  CSECT
         USING MAINPARM,PRM
         USING FMTDSECT,WK1
         STM   R14,BAS,12(R13)    SAVE REGS
         LR    BAS,R15       LOAD BASE REG
         USING *-6,BAS
         L     PNT,INRECANF  GET INPUT RECORD'S ADDRESS
         AH    PNT,FMTCNT    START POSITION OF SCAN-AREA
         LR    R0,PNT        SAVE THAT ADDRESS
         LH    LIMIT,FMTLITLN RELATIVE END -ADDRESS OF SCAN-AREA
         L     R1,INRECEND   GET RECORD END ADDRESS
         S     R1,INRECANF   COMPUTE RECORD LENGTH
         BCTR  R1,0
         CR    LIMIT,R1      IS END POSITION IN RECORD ?
         BL    ISINREC       YES, IT IS
         LR    LIMIT,R1      NO, SET UPPER LIMIT TO RECORD END ADDRESS
ISINREC  EQU  *
         SH    LIMIT,FMTCNT  LENGTH OF SCAN AREA
         LH    R1,FMTLIT     LENGTH OF LITERAL (-1) TO BE TESTED
         SR    LIMIT,R1      NUMBER OF COMPARES NECESSARY
         BNP   NOTFND        IF NOT PLUS, => LITERAL CANNOT BE FOUND
COMP     EQU   *
         EX    R1,CLC        EXECUTE THE CLC INSTRUCTION
         BE    FOUND         IF EQUAL, LITERAL WAS FOUND
         LA    PNT,1(PNT)    INCREASE POINTER
         BCT   LIMIT,COMP    AND SEARCH ON
NOTFND   EQU   *
         B     RET           AND RETURN WITH REG 'LIMIT' SET TO ZERO
CLC      CLC   0(0,PNT),FMTLIT+2       COMPARE THE LITERAL WITH ACTUAL
*                                      INPUT RECORD POSITION
FOUND    LR    LEN,PNT       COMPUTE LENGTH TO BE MOVED
         SR    LEN,R0        NOW LENGTH IS IN REG 'LEN'
*        MOVE  (MSG),(LEN),(R0)        MOVE SCANNED FIELD TO OUTPUT
         MOVE  (MSG),(LEN),(R0)        MOVE SCANNED FIELD TO OUTPUT
         AR    MSG,LEN       UPDATE OUTPUT RECORD POINTER
         ST    MSG,20+4*MSG(R13) SAVE UPDATED RECORD POINTER
         ST    PNT,20+4*PNT(R13) SAVE UPDATED RECORD POINTER
         LR    LIMIT,PNT     POINT TO START POSITION OF LITERAL FOUND
RET      ST    LIMIT,28(R13) SET RETURN CODE TO REG-POSITION 'LIMIT'
         LM    R14,BAS,12(R13) RESTORE REGS
         BR    R14           AND RETURN WITH REG 'LIMIT' SET TO LITERAL
         MEND
./ ADD  NAME=GENSORT
         MACRO
&NAME    GENSORT  &LIST
         LCLC  &N3(50),&N4(50),&N5(50),&ZWSP,&INSERT
         LCLA  &I,&I3,&I4,&I5,&K3,&K4,&K5,&L3,&L4,&L5,&M3,&M4,&M5,&LAE
         ACTR  10000
         AIF   (N'&LIST EQ 0).ERROR4
.UEBERN  ANOP
         AIF   (&I GE N'&SYSLIST).ANZFL3
&I       SETA  &I+1
         AIF   (K'&SYSLIST(&I) EQ 3).FELDWL3
         AIF   (K'&SYSLIST(&I) EQ 4).FELDWL4
         AIF   (K'&SYSLIST(&I) EQ 5).FELDWL5
         AGO   .ERROR2
.FELDWL3 ANOP
&LAE     SETA  3
         AIF   (&I3 GE 50).ERROR3
&I3      SETA  &I3+1
&N3(&I3) SETC  '&SYSLIST(&I)'
         AGO   .UEBERN
.FELDWL4 ANOP
&LAE     SETA  4
         AIF   (&I4 GE 50).ERROR3
&I4      SETA  &I4+1
&N4(&I4) SETC  '&SYSLIST(&I)'
         AGO   .UEBERN
.FELDWL5 ANOP
&LAE     SETA  5
         AIF   (&I5 GE 50).ERROR3
&I5      SETA  &I5+1
&N5(&I5) SETC  '&SYSLIST(&I)'
         AGO   .UEBERN
.ANZFL3  ANOP
         AIF   (&I3 LE 1).ANZFL4
.SORTFL3 ANOP
         AIF   (&K3 GE &I3-1).ANZFL4
&K3      SETA  &K3+1
&L3      SETA  &K3
.VERGLF3 ANOP
         AIF   (&L3 GE &I3).SORTFL3
&L3      SETA  &L3+1
.ABFRF3  ANOP
         AIF   ('&N3(&K3)' GT '&N3(&L3)').ORDNEN3
         AGO   .VERGLF3
.ORDNEN3 ANOP
&ZWSP    SETC  '&N3(&K3)'
&N3(&K3) SETC  '&N3(&L3)'
&N3(&L3) SETC  '&ZWSP'
&L3      SETA  &K3+1
         AGO   .ABFRF3
.ANZFL4  ANOP
         AIF   (&I4 LE 1).ANZFL5
.SORTFL4 ANOP
         AIF   (&K4 GE &I4-1).ANZFL5
&K4      SETA  &K4+1
&L4      SETA  &K4
.VERGLF4 ANOP
         AIF   (&L4 GE &I4).SORTFL4
&L4      SETA  &L4+1
.ABFRF4  ANOP
         AIF   ('&N4(&K4)' GT '&N4(&L4)').ORDNEN4
         AGO   .VERGLF4
.ORDNEN4 ANOP
&ZWSP    SETC  '&N4(&K4)'
&N4(&K4) SETC  '&N4(&L4)'
&N4(&L4) SETC  '&ZWSP'
&L4      SETA  &K4+1
         AGO   .ABFRF4
.ANZFL5  ANOP
         AIF   (&I5 LE 1).TAB1
.SORTFL5 ANOP
         AIF   (&K5 GE &I5-1).TAB1
&K5      SETA  &K5+1
&L5      SETA  &K5
.VERGLF5 ANOP
         AIF   (&L5 GE &I5).SORTFL5
&L5      SETA  &L5+1
.ABFRF5  ANOP
         AIF   ('&N5(&K5)' GT '&N5(&L5)').ORDNEN5
         AGO   .VERGLF5
.ORDNEN5 ANOP
&ZWSP    SETC  '&N5(&K5)'
&N5(&K5) SETC  '&N5(&L5)'
&N5(&L5) SETC  '&ZWSP'
&L5      SETA  &K5+1
         AGO   .ABFRF5
.TAB1    ANOP
         AIF   (&I3 EQ 0).TAB2
&L3      SETA  &I3*12
         SPACE
TAB3T    DS    0F
T3ANF    EQU   *
.ERH3    ANOP
&M3      SETA  &M3+1
         AIF   (&M3 GT &I3).TAB2
&INSERT  SETC  '&N3(&M3)'
&INSERT  DC    CL5'&INSERT'
         DC    AL3(&INSERT.@)
         DC    AL2(O&INSERT.@-GENOUT)
         AGO   .ERH3
.TAB2    ANOP
*
T3END    EQU   *
*
         AIF   (&I4 EQ 0).TAB3
&L4      SETA  &I4*12
         SPACE
TAB4T    DS    0F
T4ANF    EQU   *
.ERH4    ANOP
&M4      SETA  &M4+1
         AIF   (&M4 GT &I4).TAB3
&INSERT  SETC  '&N4(&M4)'
&INSERT  DC    CL5'&INSERT'
         DC    AL3(&INSERT.@)
         DC    AL2(O&INSERT.@-GENOUT)
         AGO   .ERH4
.TAB3    ANOP
*
T4END    EQU   *
*
         AIF   (&I5 EQ 0).EXIT
&L5      SETA  &I5*12
         SPACE
TAB5T    DS    0F
T5ANF    EQU   *
.ERH5    ANOP
&M5      SETA  &M5+1
         AIF   (&M5 GT &I5).T5E
&INSERT  SETC  '&N5(&M5)'
&INSERT  DC    CL5'&INSERT'
         DC    AL3(&INSERT.@)
         DC    AL2(O&INSERT.@-GENOUT)
         AGO   .ERH5
.ERROR2  ANOP
         SPACE
         MNOTE '*** LENGTH OF PARAMETER &I (&SYSLIST(&I)) INVALID ***'
         SPACE
         MEXIT
.ERROR3  ANOP
         SPACE
         MNOTE '*** MORE THAN FIFTY PARAMETERS OF LENGTH &LAE ***'
         SPACE
         MEXIT
.ERROR4  ANOP
         SPACE
         MNOTE '*** PARAMETERS MISSING ***'
         SPACE
.T5E     ANOP
*
T5END    EQU   *
*
.EXIT    MEXIT
         MEND
./ ADD  NAME=GENSTAT
         MACRO
         GENSTAT &SYS=OS
         AIF   ('&SYS' EQ 'OS' OR '&SYS' EQ 'DOS').GOON
         MNOTE 12,'SYSTEM NOT SUPPORTED, SPECIFY OS OR DOS'
         MEXIT
.GOON    ANOP
         BGENMAC SYS=&SYS
         TITLE 'BASFGEN   PROTOKOLL ROUTINE'
GENSTAT  CSECT
         USING AZEILE,WK2
         USING MAINPARM,PRM
         USING FUNCTION,FUNC
         AIF   ('&SYS' EQ 'OS').OSXR
*        EXTXS BAS,,GENSTAT,MOD=VGM,TYP=S
         EXTXS BAS,,GENSTAT,MOD=VGM,TYP=S
         AGO   .OVXR
.OSXR    ANOP
         XSAVE BAS,,GENSTAT
.OVXR    ANOP
         BAL   LNK,CLRLINE   CLER THE MESSAGE LINE
         BAL   LNK,PRTFUNC   PRINT LEAST FUNCTION
         BAL   LNK,PRT1      PUT COUNT FOR SYSUT1
         BAL   LNK,PRT2      PUT COUNT FOR SYSUT2
         BAL   WK1,PRTSEPS   PUT COUNT FOR SEP-DCBS
         AIF   ('&SYS' EQ 'OS').OSGM
*        EXTXR ,R,MOD=VGM
         EXTXR ,R,MOD=VGM
         AGO   .OVOS
.OSGM    ANOP
         XRETURN ,R          RETURN
.OVOS    ANOP
PRTFUNC  EQU   *
         LA    LEN,(SFUNCEND-FUNCS)/L'SCOPY  NO. OF FUNCTIONS
         MVC   ACARDOUT(L'FUNCNM),FUNCNM  MOVE A MESSAGE
         MVI   ASA,NULL
         LA    R1,1          ADD ONE
         A     R1,PRTCNT     TO LINE COUNT
         ST    R1,PRTCNT     FOR SYSPRINT DCB
         LA    PNT,ACARDOUT+L'FUNCNM+2
         LA    MSG,FUNCS     POINT TO FUNCTION NAMES
         TM    SWINPUT,EOFSYS1  WAS EODAD FROM SYSUT1 ?
         BZ    FUNCCOMP      NO, LOOK FOR FUNCTION
         MVC   20(L'ENDMSG,PNT),ENDMSG   MOVE A MESSAGE TO LINE
FUNCCOMP EQU   *
         CLC   FIDENT,0(MSG) IS FUNCTION EQUAL
         BE    MOVEFUNC      YES, MOVE ITS NAME TO MESSAGE
         LA    MSG,L'SCOPY(MSG)        IF NOT, ASK NEXT
         BCT   LEN,FUNCCOMP  AS OFTEN AS FUNCTIONS ARE
         LA    MSG,=CL6'UNDEF.'  TELL THAT ITS UNKNOWN
MOVEFUNC EQU   *
         MVC   0(L'SCOPY,PNT),0(MSG)   MOVE THE FUNCTION NAME
PUTLIST  EQU   *
         L     R1,ALISTE     POINT TO DCB
         PUT   (1),(WK2)      AND PUT THE LINE
         L     R1,PRTCNT     GET PRINT COUNT
         LA    R1,1(R1)      ADD ONE
         ST    R1,PRTCNT     AND STORE THE COUNT BACK
         C     R1,MAXLINES   IS PAGE FULL ?
         BL    NONEWPG       NO, PRINT ON
         L     R15,AHEADPRT  GET ADDRESS OF HEADER PRINT ROUTINE
         BALR  R14,R15       AND LINK TO IT
NONEWPG EQU   *
CLRLINE  EQU   *
         MVI   ASA,BLANK     MOVE BLANKS TO
         MVC   AFLAG(ALINELEN),ASA     THE OUTPUT LINE
         BR    LNK
PRT1     EQU   *
         AIF   ('&SYS' EQ 'OS').OSUT1
         MVC   ACARDOUT(8),=C'SYS000  '
         AGO   .BLK
.OSUT1   ANOP
         MVC   ACARDOUT(8),=CL8'SYSUT1'   DCB ID
         MVC   ACARDOUT+34(L'BLK#),BLK#
         LA    PNT,ACARDOUT+36+L'BLK#
         L     R0,INPBLKS     GET NO. OF INPUT BLOCKS
         CVD   R0,DMACCU     CONVERT IT
         OI    DMACCU+7,15   MAKE PRINTABLE
         UNPK  0(8,PNT),DMACCU(8)
.BLK     ANOP
         L     R0,INPRECS    GET NO. OF INPUT RECORDS
PUTRECS  EQU   *
         CVD   R0,DMACCU     CONVERT COUNT
         MVC   ACARDOUT+10(L'REC#),REC#
         OI    DMACCU+7,15   MAKE PRINTABLE
         UNPK  ACARDOUT+23(8),DMACCU(8)
         B     PUTLIST
PRT2     EQU   *
         AIF   ('&SYS' EQ 'OS').OSUT2
         MVC   ACARDOUT(8),=C'SYS001  '
         AGO   .OUTC
.OSUT2   ANOP
         MVC   ACARDOUT(8),=CL8'SYSUT2'
.OUTC    ANOP
         L     R0,OUTCNT     GET RECORD COUNT FOR SYSUT2
         B     PUTRECS       AND GO TO PUT THE COUNT
PRTSEPS  EQU   *
         LA    LIMIT,ASEPDCBS
         USING SEPENTRY,LIMIT
TESTSEP  EQU   *
         L     R1,LINKFLD    GET ADDRESS OF NEXT SEPERATION-ENTRY
         LTR   LIMIT,R1      LOAD AND TEST BESA OF ENTRY
         BCR   8,WK1         IF THERE IS NONE MORE RETURN
         AIF   ('&SYS' EQ 'OS').SR
         MVC   ACARDOUT(8),=C'SYS001  '
         MVC   ACARDOUT+5(1),DCBID
         AGO   .LPUT
.SR      ANOP
         SR    R0,R0
         IC    R0,DCBID      GET NUMERIC ID OF DCB
         CVD   R0,DMACCU+8
         OI    DMACCU+15,15  MAKE PRINTABLE
         MVC   ACARDOUT(8),=CL8'SYSUT2'
         UNPK  ACARDOUT+5(2),DMACCU+14(2) CONSTRUCT DDNAME
.LPUT    ANOP
         L     R0,PUTCOUNT   GET NUMBER OF PUTS FOR THIS DCB
         BAL   LNK,PUTRECS
         B     TESTSEP       LOOK FOR MORE DCBS
FUNCS    EQU   *
SCOPY    DC    CL6'COPY'
SSKIP    DC    CL6'SKIP'
SBACKSP  DC    CL6'BACKSP'
SREWIND  DC    CL6'REWIND'
SUNLOAD  DC    CL6'UNLOAD'
SWTM     DC    CL6'WTM'
SFAULT   DC    CL6'FAULT'
SENDE    DC    CL6'ENDE'
SFUNCEND EQU   *
ENDMSG   DC    C'EOF ENCOUNTERED FROM SYSUT1'
FUNCNM   DC    C'FUNCTION JUST COMPLETED :'
BLK#     DC    C'BLOCK-NO. :'
REC#     DC    C'RECORD-NO. :'
         LTORG
         AIF   ('&SYS' EQ 'DOS').MEND
SEPENTRY DSECT
LINKFLD  DS    F             POINTER TO NEXT ENRTY
DCBID    DS    0C            BINARY ID FOR DCB-NUMBER
DCBADR   DS    F             POINTER TO THE DCB
PUTCOUNT DS    F             NUMBER OF PUTS AGAINST THIS DCB
.MEND    ANOP
         MEND
./ ADD  NAME=GENSYNBS
         MACRO
         GENSYNBS &SYS=OS
         AIF   ('&SYS' EQ 'DOS').COP
         AIF   ('&SYS' EQ 'OS').COP
         MNOTE 12,'SYSTEM NOT SUPPORTED, SPECIFY DOS OR OS'
         MEXIT
.COP     ANOP
         BGENMAC SYS=&SYS
         AIF   ('&SYS' EQ 'OS').BSAM
         TITLE 'LUGENER ERROPT ROUTINE FOR DOS, (MTMOD - SDMOD)'
         AGO   .COM
.BSAM    ANOP
         TITLE 'LUGENER SYNAD-ROUTINE FOR BSAM'
.COM     ANOP
*
*
*              AUTHOR: H. FRANZ
*
*
         AIF   ('&SYS' EQ 'OS').USIN
BGENERR  CSECT
         BALR  15,0          GET BASE
         BCTR  15,0          SET IT ON START
         BCTR  15,0
         USING *-6,15
         AGO   .NOWON
.USIN    ANOP
GENSYNBS CSECT
         USING *,R15
.NOWON   ANOP
         STM   R0,R15,REGS   SAVE ALL REGISTERS
         LR    BAS,R15       LOAD BASE REG
         DROP  R15
         AIF   ('&SYS' EQ 'OS').GESYN
         USING BGENERR,BAS
         AGO   .OVGESY
.GESYN   ANOP
         USING GENSYNBS,BAS
.OVGESY  ANOP
         USING AZEILE,WK2
         USING MAINPARM,PRM
         LA    R13,NEWSAVE   GET A NEW SAVEAREA
         L     WK2,ALIST     POINT TO MESSAGE LINE
         AIF   ('&SYS' EQ 'OS').USING
         SPACE 1
BLK      EQU   SW            POINTS TO ERROR BLOCK
DTF      EQU   FUNC          DTF POINTER
         SPACE 1
         L     DTF,0(R1)     R1 --> A(DTF), A(BLOCK)
         L     BLK,4(R1)
         USING CCBORG,DTF
         TM    CCBTRNS0,CCBIOERR NON DATA TRANSFER ?
         BZ    ACCEPT        DUMP READ BLOCK
         TM    CCBTRNS1,CCBDCKMT READ DATA CHECK
         BO    SKIPBLK       SKIP THIS BLOCK
         ST    DTF,POINTDTF  HELP TO FIND CCB IN DUMP
         AGO   .MSG
.USING   ANOP
         USING IHADCB,R1
         OI    SWINPUT,ERR   INDICATE TO READ ROUTINE,THAT ERROR WAS
         TM    REG1,X'90'    READ ERROR, BLOCK IS IN CORE
         BO    ACCEPT        YES, DUMP THE BLOCK
         TM    REG1,X'80'    READ ERROR , BLOCK IS NOT IN CORE
         BO    SKIPBLK       DON'T DUMP, DUMP WOULD GET PREVIOUS BLOCK
         TM    REG1,X'20'    CNTRL ERROR
         BO    CNTRLERR
.MSG     ANOP
         MVC   AFLAG,ERROR   INDICATE AN ERROR CONDITION ON THE PRINTLN
         MVC   ACARDOUT(L'UNMSG),UNMSG WRITE A MESSAGE
         BAL   LNK,PUTMSG    PUT THE LINE
         L     WK1,ALISTE    GET THE DCB-ADDRESS
         AIF   ('&SYS' EQ 'OS').OSCL
*        CLOSER (WK1)        CLOSE SYSPRINT TO FORCE MESSAGE
         CLOSER (WK1)        CLOSE SYSPRINT TO FORCE MESSAGE
         DC    H'0'          FORCE DUMP (OPERATION EXCEPTION)
         DS    0F            ORG WORD BOUNDARY
         DC    C' DTF ADDRESS'
POINTDTF DC    F'0'          CONTAINS A(DTF) IF DUMP
         AGO   .TEXT
.OSCL    ANOP
         CLOSE ((WK1)),MF=(E,NEWSAVE)  CLOSE THE DCB TO FORCE LINE OUT
         DC    H'0'          AND TAKE A DUMP
.TEXT    ANOP
ERROR    DC    CL12'*** ERROR **'
UNMSG    DC    C'UNDEFINED I/O-ERROR ON SYSUT1, DUMP (0C1) FOLLOWS'
ACCERR   DC    C'I/O-ERROR ON SYSUT1, BLOCK-NR.:'
NOTINERR DC    C'UNABLE TO READ BLOCK-NR.:'
END      DC    C'ERROR-COUNT EXCEEDED, EXECUTION TERMINATED'
         AIF   ('&SYS' EQ 'OS').RGS
WLRMSG   DC    C'INCORRECT LENGTH ERROR THIS RECORD, SKIPPED'
.RGS     ANOP
REGS     DC    16F'0'        SAVEAREA FOR ALL REGISTERS
         AIF   ('&SYS' EQ 'DOS').SAVE
CNTERR   DC    C'CNTRL-ERROR, RERUN THE JOB'
REG1     EQU   REGS+4        ERROR INDICATORS ARE IN BYTE 0 OF REG 1
.SAVE    ANOP
NEWSAVE  DC    18F'0'        SAVE AREA REQUIRED FOR PUT
DW       DS    D             WORK-DOUBLEWORD FOR CVD
PUTMSG   EQU   *
         L     R1,ALISTE
         PUT   (1),(WK2)     PUT THE LINE
         MVI   ASA,BLANK     BLANK THE OUTPUT LINE
         MVC   AFLAG(ALINELEN),ASA
         BR    LNK
ADD1     EQU   *
         L     R1,ERRCNT     GET THE ERROR COUNT TILL NOW
         LA    R1,1(R1)      ADD ONE
         ST    R1,ERRCNT     AND RESTORE IT
         L     R1,INPBLKS    GET NUMBER OF BLOCKS TILL NOW
         CVD   R1,DW         CONVERT IT
         OI    DW+7,X'0F'    FORCE SIGN TO 'F'
         MVC   AFLAG,ERROR   SET THE FLAG
         BR    LNK           AND RETURN
ACCEPT   EQU   *
         BAL   LNK,ADD1
         MVC   ACARDOUT(L'ACCERR),ACCERR
         UNPK  ACARDOUT+L'ACCERR+1(8),DW
         BAL   LNK,PUTMSG
         AIF   ('&SYS' EQ 'OS').DMP
         TM    CCBCHNST,CCBILN INCORRECT LENGTH INDICATED ?
         BZ    DMP           IF NOT: DON'T WRITE THE MESSAGE
         MVC   ACARDOUT(L'WLRMSG),WLRMSG MOVE MESSAGE
         BAL   LNK,PUTMSG
DMP      EQU   *
.DMP     ANOP
         L     R15,AGENDUMP  ADDRESS OF THE DUMP ROUTINE
         AIF   ('&SYS' EQ 'OS').AINBUF
         LR    R0,BLK        GET BLOCK ADDRESS
         AGO   .LR
.AINBUF  ANOP
         L     R0,AINBUF     GET BUFFER ADDRESS
.LR      ANOP
         LR    R1,R0         TOO
         A     R1,INBUFLEN   END OF INPUT BUFFER
         BALR  R14,R15       LINK TO DUMP ROUTINE
         AIF   ('&SYS' EQ 'OS').BRET
         TM    CCBCHNST,CCBILN INCORRECT LENGTH INDICATED ?
         BZ    RET           IF NOT: DON'T SKIP THIS BLOCK
SKP      EQU   *
*        ERET  SKIP
         ERET  SKIP
         AGO   .SKPBLK
.BRET    ANOP
         B     RET
.SKPBLK  ANOP
SKIPBLK  EQU   *
         BAL   LNK,ADD1
         MVC   ACARDOUT(L'NOTINERR),NOTINERR
         UNPK  ACARDOUT+L'NOTINERR+1(8),DW
         BAL   LNK,PUTMSG
         AIF   ('&SYS' EQ 'OS').CNTRL
         B     SKP           SKIP THIS RECORD
         AGO   .RET
.CNTRL   ANOP
         B     RET
CNTRLERR EQU   *
         BAL   LNK,ADD1
         MVC   ACARDOUT(L'CNTERR),CNTERR
         BAL   LNK,PUTMSG    PUT THE LINE
         XC    ERRCOMP,ERRCOMP FORCE END, ERRCNT IS NOW GREATER
.RET     ANOP
RET      EQU   *
         CLC   ERRCNT,ERRCOMP IS ERROR COUNT REACHED
         BNL   STOP          YES, TERMINATE
         LM    R0,R15,REGS   RESTORE REGISTERS
         AIF   ('&SYS' EQ 'OS').BR14
*        ERET  RETRY
         ERET  RETRY
         AGO   .STOP
.BR14    ANOP
         BR    R14           AND RETURN TO CHECK ROUTINE
.STOP    ANOP
STOP     EQU   *
         MVC   ACARDOUT(L'END),END
         MVI   ASA,C'-'
         BAL   LNK,PUTMSG
         OI    SWINPUT,ENDREQ INDICATE THAT END IS REQUIRED
         LM    R0,R15,REGS   R13 POINTS TO SVA OF GENREAD
         L     R13,4(R13)    R13 POINTS TO SVA OF GENOUT
         AIF   ('&SYS' EQ 'OS').LM
         L     R13,4(R13)    R13 POINTS TO SVA OF BGENIPUT
.LM      ANOP
         L     R13,4(R13)    R13 POINTS TO SVA OF LUGENER
         LM    R14,BAS,12(R13)
         SR    R15,R15       INDICATE ERROR
         BR    R14           TERMINATE BY GOING TO LUGENER
         LTORG
         AIF   ('&SYS' EQ 'OS').MEND
DTFDESCR DSECT
         CCBDEF
.MEND    ANOP
         MEND
./ ADD  NAME=GENSYNIS
         MACRO
         GENSYNIS &SYS=OS
         AIF   ('&SYS' EQ 'OS').COP
         AIF   ('&SYS' EQ 'DOS').MNOTE
         MNOTE 12,'&SYS  -SYSTEM IS NOT SUPPORTED, SPECIFY OS OR DOS'
         MEXIT
.MNOTE   ANOP
         MNOTE *,'THIS CSECT IS ONLY REQUIRED FOR OS'
         MEXIT
.COP     ANOP
         TITLE 'SYNAD-ROUTINE FOR QISAM INPUT FILES'
GENSYNIS CSECT
         BR    14            ACCEPT ANY ERROR
         CNOP  0,8
         MEND
./ ADD  NAME=GENSYNQS
         MACRO
         GENSYNQS &SYS=OS
         AIF   ('&SYS' EQ 'OS').COP
         AIF   ('&SYS' EQ 'DOS').MNOTE
         MNOTE 12,'&SYS  -SYSTEM IS NOT SUPPORTED, SPECIFY OS OR DOS'
         MEXIT
.MNOTE   ANOP
         MNOTE *,'THIS CSECT IS ONLY REQUIRED FOR OS'
         MEXIT
.COP     ANOP
         BGENMAC SYS=&SYS
         TITLE 'BASFGEN - SYNAD ROUTINE FOR QSAM INPUT'
GENSYNQS CSECT
         USING *,15
         STM   R0,R15,REGS
         LR    BAS,R15
         DROP  R15
         USING GENSYNQS,BAS
         USING AZEILE,WK2
         USING MAINPARM,PRM
         USING IHADCB,R1
         LA    R13,NEWSAVE
         L     WK2,ALIST
         OI    SWINPUT,ERR
         SYNADAF ACSMETH=QSAM
         LA    FUNC,8(R1)
         MVI   ASA,C'0'
         MVC   AFLAG,ERROR
         MVC   ACARDOUT(78),42(FUNC)
         BAL   LNK,PUTMS
         L     LEN,AINPUT
         L     LEN,68(LEN)
         L     LEN,0(LEN)
         LA    LEN,8(LEN)
         MVI   ASA,C' '
         MVC   AFLAG,ERROR
         MVC   ACARDOUT(L'IOBMSG),IOBMSG
         MVC   ACARDOUT+L'IOBMSG(16),0(LEN)
         LA    R0,16
         LA    R1,ACARDOUT+L'IOBMSG
         L     R15,ACONVXE
         BALR  R14,R15
         BAL   LNK,PUTMS
         TM    REG1,X'90'
         BO    BLKACC
BLKSKIP  EQU   *
         BAL   LNK,ADD
         MVI   ASA,C' '
         MVC   ACARDOUT(L'NOTINERR),NOTINERR
         UNPK  ACARDOUT+L'NOTINERR+1(8),DW
         BAL   LNK,PUTMS
SKIPBLK  EQU   *
         L     R1,AINPUT
         NI    DCBEROPT,X'7F'
         OI    DCBEROPT,X'40'
         B     RET
ERROR    DC    CL12'*** ERROR **'
ACCERR   DC    C'I/O-ERROR ON SYSUT1 BLOCK-NR. :'
NOTINERR DC    C'UNAIBLE TO READ BLOCK-NR.: '
END      DC    C'ERROR-COUNT EXCEEDED,EXECUTION TERMINATED'
IOBMSG   DC    C'IOB = '
REGS     DC    16F'0'
REG1     EQU   REGS+4
NEWSAVE  DC    18F'0'
DW       DS    D
PUTMS    EQU   *
         L     R1,ALISTE
         PUT   (1),(WK2)
         MVI   ASA,BLANK
         MVC   AFLAG(ALINELEN),ASA
         BR    LNK
ADD      EQU   *
         L     R1,ERRCNT
         LA    R1,1(R1)
         ST    R1,ERRCNT
         L     R1,INPBLKS
         CVD   R1,DW
         OI    DW+7,X'0F'
         MVC   AFLAG,ERROR
         BR    LNK
BLKACC   EQU   *
         BAL   LNK,ADD
         MVI   ASA,C' '
         MVC   ACARDOUT(L'ACCERR),ACCERR
         UNPK  ACARDOUT+L'ACCERR+1(8),DW
         BAL   LNK,PUTMS
         TM    SWOPEN,DCK .  ARE FAULTY BLOCKS REQUIRED ?
         BO    SKIPBLK .     NO, TRY TO READ NEXT BLOCK
         L     R1,AINPUT
         NI    DCBEROPT,X'BF'
         OI    DCBEROPT,X'80'
         L     R15,AGENDUMP
         L     R0,0(FUNC)
         LR    R1,R0
         LA    R0,0(R1)
         LH    LIMIT,4(FUNC)
         LA    R1,0(R1,LIMIT)
         BALR  R14,R15
         SYNADRLS
RET      EQU   *
         L     R1,PRTCNT
         LA    R1,4(R1)
         ST    R1,PRTCNT
         CLC   ERRCNT,ERRCOMP
         BNL   ENDE
         LM    R0,R15,REGS
         BR    R14
ENDE     EQU   *
         MVC   ACARDOUT(L'END),END
         MVI   ASA,C'-'
         BAL   LNK,PUTMS
         L     R1,PRTCNT
         LA    R1,1(R1)
         ST    R1,PRTCNT
         OI    SWINPUT,ENDREQ
         LM    R0,R15,REGS
         L     R13,4(R13)
         L     R13,4(R13)
         LM    R14,BAS,12(13)
         SR    15,15
         BR    R14
         LTORG
         MEND
./ ADD  NAME=GENTABLE
         MACRO
&NM      GENTABLE &SYS=OS
         LCLA  &EOD
         LCLB  &OS,&DOS
&OS      SETB  ('&SYS' EQ 'OS')
&DOS     SETB  ('&SYS' EQ 'DOS')
&EOD     SETA  32
         AIF   (&OS).COP
&EOD     SETA  28
         AIF   (&DOS).COP
         MNOTE 12,'&SYS   - SYSTEM NOT SUPPORTED, SPECIFY OS OR DOS'
         MEXIT
.COP     ANOP
         BGENMAC SYS=&SYS
         TITLE 'BASFGEN    TABLE CREATION'
GENTABLE CSECT
*
*              DIESES PROGRAMM ERZEUGT UND INITIALISIERT
*              EINE TABELLE FUER 'BASFGEN'
*
         AIF   (&OS).LINK
*              ES WIRD UEBER 'FETCH' AUS 'GENFUNC' AUFGERUFEN
         AGO   .LINKE
.LINK    ANOP
*              ES WIRD UEBER 'LINK' AUS 'GENFUNC' AUFGERUFEN
.LINKE   ANOP
*              WENN DIESES PROGRAMM EINE 'TABDEF'-KARTE
*              ERKANNT HAT
*
*              AUTHOR:   H. FRANZ
*
*              EINGABE:
*
*      N TABDEF,L=NNN,N=NNN(,K=NNN)
*             ELEMENTE     (AB SPALTE 15)
*                 .
*                 .
*                 .
*        TABEND            (IN SPALTE 10)
*
         AIF   (&OS).XSAVE
         EXTXS BAS,SVA,GENTABL,TYP=F
         AGO   .XSAVEE
.XSAVE   ANOP
         XSAVE BAS,SVA,GENTABLE        SAVE REGS
.XSAVEE  ANOP
         USING MAINPARM,PRM
         USING AZEILE,WK2
         L     WK2,ALIST     POINT TO OUTPUT LINE
         LTR   LIMIT,LIMIT . IF ENTERED FROM BASFGEN AT END OF RUN
         BZ    ONLYPRT       REG2 CONTAINS ZERO
         L     PNT,ACARD     POINT TO INPUT CARD
         LA    WK1,C'L'      FIRST KEY TO FIND
         BAL   LNK,CHARSER   SEARCH FOR CHARACTER IN REG WK1
         ST    R0,ELEMLEN    SAVE RESULT   ELEMENT LENGTH
         LA    WK1,C'N'      SECOND KEY TO FIND
         BAL   LNK,CHARSER   SEARCH FOR CHARACTER IN REG WK1
         ST    R0,ELEMANZ    SAVE RESULT   NUMBER OF ELEMENTS (MAX)
         LA    WK1,C'K'      THIRD KEY TO FIND  MAY BE OMITTED
         BAL   LNK,CHARSER   SEARCH FOR CHARACTER IN REG WK1
         ST    R0,KEYLEN     SAVE RESULT   LENGTH OF THE KEY
         LA    WK1,C'P' .    SEARCH FOR BEGIN OF A PRINT STATEMENT
         BAL   LNK,CHARSER   SEARCH FOR THE BLANK
LOOKIFRF EQU   *
         CLC   0(L'PRINTRE,R1),PRINTRE IS PRINTREF SPECIFIED ?
         BNE   LOOKIFNT      MAY BE PRINTNOT
         OI    PRINTSW,PRINTREF        SET SWITCH LOCAL
         OI    SWTAB,PRINTREF          SET SWITCH GLOBAL
         CLI   9(R1),BLANK . IS MORE THAN THIS KEYWORD SPECIFIED ?
         BE    GETCORE .     NO, CONSTRUCT THE TABLE
         LA    R1,8(R1) .    SET OVER KEYWORD
         BAL   LNK,CHARLOOP .SEARCH ON FOR NEXT PRINT STATEMENT
LOOKIFNT EQU   *
         CLC   0(L'PRINTNO,R1),PRINTNO IS PRINTNOT SPECIFIED ?
         BNE   WARN .        'P' FOUND, BUT NOT PRINT ==> MISSPELLED
         OI    PRINTSW,PRINTNOT        PRINT OF TABLE IS NOT REQUIRED
GETCORE  EQU   *
         L     R1,ELEMLEN    GET THE LENGTH OF ONE ELEMENT
         LA    R1,1(R1)      ADD ONE
         ST    R1,ACTLEN     AND SAVE THIS LENGTH (+ REFERENCE MARK)
         L     R0,ELEMANZ    GET MAX NUMBER OF ELEMENTS
         MH    R0,ACTLEN+2
         ST    R0,MAXCORE    THIS IS REQUIRED TABLE SIZE
         AIF   (&OS).VGETM
         ST    R0,LENCORE    SAVE REQUIRED LENGTH
         EXTGM C,LV=(0),MOD=VGM  GET THE CORE FOR TABLE
         LA    R15,X'080A'   WAS ENOUGH ?
         CR    R0,R15        IF EQUAL  ===> NO
         BE    INSUFFIC
         ST    R1,ADRCORE    SAVE POINTER TO ALLOCATED CORE
         AGO   .VGETME
.VGETM   ANOP
         GETMAIN VC,LA=MINCORE,A=ADRCORE  TRY TO GET THE CORE
         LTR   R15,R15       SUCCESSFUL ?
         BNZ   SORRY         NO, INDICATE TO USER
.VGETME  ANOP
         L     R0,LENCORE    GET SIZE OF ACTUALLY ALLOCATED CORE
         C     R0,MAXCORE    IF LESS THAN REQUIRED
         BL    INSUFFIC      THAT'S NOT ENOUGH
         A     R0,ADRCORE    COMPUT END OF TABLE
         ST    R0,ENDCORE    SAVE THIS ADDRESS
GETTABID EQU   *
         PACK  DMACCU(8),0(8,PNT)      PACK THE TABLE ID
         OI    DMACCU+7,15   FORCE POSITIVE AND BLANK TO BE VALID
         CVB   R1,DMACCU
         CH    R1,=H'10'     IS ID GREATER THAN NUMBER OF TABLES
         BH    TOOHIGH       INDICATE AN ERROR
         BCTR  R1,0          REDUCE BY ONE
         LTR   R1,R1         TEST ID
         BNM   IDOK          IF ZERO OR POSITIV, IT'S OK
         SR    R1,R1         SET IT TO ZERO   ==>  TABLE ID IS '1'
IDOK     EQU   *
         SLL   R1,3          * 8   (LENGTH OF A TABLE ENTRY
         A     R1,ATABENTR   COMPUTE ADDRESS OF THIS ENTRY
         ST    R1,THISENTR   SAVE THAT POINTER
         L     R0,ADRCORE    POINT TO TABLE START
         ST    R0,0(R1)      PUT ADDRESS TO TABLE ENTRY
         L     R1,AKARTE     POINT TO DCB FOR CARDS
         L     R15,&EOD.(R1)  GET EODAD ADDRESS
         ST    R15,EODADSAV  SAVE THAT ADDRESS
         LA    R0,EODHERE    GET NEW EODAD ADDRESS
         ST    R0,&EOD.(R1)  SET NEW EODAD ADDRESS
         MVC   &EOD.(1,R1),EODADSAV RESET DCB-RECFM (FOR OS ONLY)
*
GETELEM  EQU   *
         SR    LIMIT,LIMIT   CLEAR COUNT REG
         L     LEN,ELEMLEN   GET LENGTH OF AN ELEMENT
         BCTR  LEN,0         REDUCE IT BY ONE FOR EXECUTE
         L     SW,ADRCORE    SET POINTER TO TABLE START
GET      EQU   *
         L     R1,AKARTE     POINT TO DCB
         L     PNT,ACARD     POINT TO I/O AREA
         GET   (1),(PNT)     GET THE CARDS
         LA    R0,1
         A     R0,SYSINCDS   ADD ONE TO CARD-COUNT
         ST    R0,SYSINCDS   AND STORE NEW COUNT
         CLC   9(6,PNT),=C'TABEND' IS END OF TABLE REACHED ?
         BE    THATSALL      YES, DON'T ANY FURTHER GETS
         LA    LIMIT,1(LIMIT)  COUNT THE CARDS = TABLE ELEMENTS
         LA    MSG,2(LEN,SW) SET OVER ELEMENT NOW TO BE MOVED
         C     MSG,ENDCORE   WILL THIS ELEMENT FIT ?
         BH    TABFULLR      NO, TABLE IS FULL
         EX    LEN,MVCTAB    MOVE THE ELEMENT TO TABLE
         MVI   0(SW),BLANK   SET REFERENCE MARK TO BLANK
         LR    SW,MSG        POINT TO NEXT ELEMENT PLACE
         B     GET           READ NEXT CARD
MVCTAB   MVC   1(0,SW),14(PNT)
CHARSER  EQU   *
         LA    R1,15(PNT)    SET POINTER OVER TABDEF
         LA    LIMIT,CARDLEN(PNT) UPPER LIMIT FOR SCAN
CHARLOOP EQU   *
         EX    WK1,CLI       COMPARE BYTE FROM CARD WITH CHAR IN WK1
         BE    CHARFND       IF EQUAL, IT IS FOUND
         LA    R1,1(R1)      TRY WITH NEXT CHARACTER
         CR    R1,LIMIT      IS UPPER LIMIT REACHED
         BNH   CHARLOOP      IF NOT, TRY AGAIN
         B     IGNORE
CLI      CLI   0(R1),0       PROTOTYPE CLI INSTRUCTION
CHARFND  EQU   *
         CLI   0(R1),C'P'    WAS SEARCH FOR PRINT-KEYWORD ?
         BCR   8,LNK         YES, GO BACK
         LA    R1,2(R1)      SET OVER CHARACTER AND EQUAL SIGN
         LR    SW,R1         SAVE START OF DIGITS
TESTDIG  EQU   *
         CLI   0(R1),C'0'    TEST IF NUMERIC
         BL    NUMEND        IF NOT, ASSUME END OF DIGIT
         CLI   0(R1),C'9'
         BH    NUMEND
         LA    R1,1(R1)      IF NUMERIC, TEST NEXT BYTE
         B     TESTDIG
NUMEND   EQU   *
         SR    R1,SW         COMPUT LENGTH
         BNP   IGNORE
         BCTR  R1,0          REDUCE BY ONE FOR EXECUTE
         EX    R1,PACK       EXECUTE THE PACK INSTRUCTION
         CVB   R0,DMACCU     GET THE DIGIT
         BR    LNK           AND RETURN
PACK     PACK  DMACCU(8),0(0,SW)
*
IGNORE   EQU   *
         EX    WK1,CLIK      WAS A 'K' IN WK1
         BNE   TESTP .       MAY BE PRINT SEARCH
         L     R0,ELEMLEN
         BR    LNK .         GO TO STORE LENGTH
CLIK     CLI   K,0
CLIP     CLI   P,0 .         TEST FOR P IN REG WK1
TESTP    EQU   *
         EX    WK1,CLIP .    TEST IF 'P' IS IN REG WK1
         BE    GETCORE .     PRINT KEYWORD OR 'K=' ARE NOT NECESSARY
*                  OTHER KEYS SEARCHED FOR ARE NECESSARY
SORRY    EQU   *
         L     R1,THISENTR   GET ADDRESS OF THIS TAB E ENTRY
         LTR   R1,R1 .       TEST IF ALREADY INITIATED
         BZ    *+10 .        IF NOT, PREVENT CLEAR OF ENTRY
         XC    0(8,R1),0(R1)  CLEAR TAB ENTRY
         OI    SWTAB,TABNOTAB  INDICATE THAT NO TABLE IS PROVIDED
         B     XRET
INSUFFIC EQU   *
         BAL   LNK,CLEARLIN  CLEAR THE OUTPUT LINE
         MVC   ACARDOUT+20(L'INSUMSG),INSUMSG
ERRRET   EQU   *
         MVC   AFLAG,ERROR . MOVE A FLAG TO OUTPUT-LINE
         BAL   LNK,PUTLINE
         B     SORRY
TOOHIGH  EQU   *
         BAL   LNK,CLEARLIN
         MVC   ACARDOUT+20(L'HIGHMSG),HIGHMSG
         B     ERRRET
*
EODHERE  EQU   *
         OI    SWTAB,TABEODAD INDICATE UNEXPECTED EODAD
RESETEOD EQU   *
RESETEOF EQU   *
         L     R15,EODADSAV  GET THE SAVED EOD ADDRESS
         L     R1,AKARTE     POINT TO DCB
         ST    R15,&EOD.(R1)  RESET OLD EODAD ADDRESS
*
         AIF   (&OS).RET
XRET     EXTXR   ,           RETURN TO CALLER (GENFUNC
         AGO   .RETE
.RET     ANOP
XRET     XRETURN
.RETE    ANOP
TABFULLR EQU   *
         OI    SWTAB,TABFULL INDICATE THAT TABLE IS FULL
         L     R1,THISENTR   GET THIS TABLE ENTRY
         XC    0(8,R1),0(R1)  CLEAR THE ENTRY
         B     RESETEOD
PUTLINE  EQU   *
         L     R1,ALISTE     GET DCB ADDRESS
         PUT   (1),(WK2)     PUT THE LINE
         L     R1,PRTCNT     GET CURRENT LINE COUNT
         LA    R1,1(R1)      ADD ONE
         ST    R1,PRTCNT     RESTORE LINE COUNT
         C     R1,MAXLINES   IS MAXIMUM REACHED ?
         BL    PAGEOK        NO, CLEAR THE LINE
         L     R15,AHEADPRT  GET ADDRESS OF HEADER PRINT ROUTINE
         BALR  R14,R15       AND LINK TO THIS ROUTINE
PAGEOK   EQU   *
CLEARLIN EQU   *
         MVI   ASA,BLANK     BLANK OUT LINE
         MVC   AZEILE+1(ALINELEN),AZEILE
         BR    LNK
THATSALL EQU   *
         MVC   ACARDOUT,0(PNT)         MOVE TABEND CARD
         BAL   LNK,PUTLINE    AND PUT IT
         LA    R0,LFDPRMLN   LENGTH OF LFDNRDEF PARMS
         AIF   (&OS).OSGM5
*        EXTGM R,LV=(0),MOD=VGM
         EXTGM R,LV=(0),MOD=VGM
         AGO   .OVGM5
.OSGM5   ANOP
*        GETMAIN R,LV=(0)
         GETMAIN R,LV=(0)
.OVGM5   ANOP
         USING LFDPRMS,MSG
         LR    MSG,R1        SET BASE REG
         XC    LFDPRMS(LFDPRMLN),LFDPRMS CLEAR THIS AREA
         LA    R0,2          START OF KEY
         STH   R0,LFDARGAN   POS 1 IS ARGUMENT START
         BCTR   R0,0         REDUCE BY ONE
         A     R0,KEYLEN   . ADD KEYLENTH
         STH   R0,LFDARGEN   ARGUMENT END
         L     R0,ACTLEN .   GET ACTUAL ELEMENT LENGTH
         STH   R0,LFDLEN     STORE IT TO PARMS
         S    SW,ADRCORE     LENGTH OF TABLE (USED)
         ST    SW,LFDTABLN   SAVE LENGTH
         STH   LIMIT,LFDANZ  NUMBER OF ACTIVE ELEMENTS
         TM    PRINTSW,PRINTREF      IS REFERENCE PRINT SWITCH ON
         BZ    NOREFPRT ,    NO
         OI    PRTSW,PRINTREF SET SWITCH INTO TABLE DEPENDENT AREA
NOREFPRT EQU   *
         DROP  MSG
         L     R15,THISENTR  POINT TO ACTUAL ENTRY
         ST    MSG,4(R15)    INITIALISE PARMLIST FOR LDEF
         OI    4(R15),ENDINDIC  INDICATE END OF LIST
SORTTAB  EQU   *
         A     SW,ADRCORE    SET TO END OF USED TABLE
         L     MSG,ADRCORE
SORTANF  LR    R1,MSG        SET POINTER REG
NEXTELEM EQU   *
         LA    R1,2(LEN,R1)  POINT TO NEXT ELEMENT
         CR    R1,SW         IS END OF TABLE REACHED ?
         BNL   NEXTPHAS      YES, NEXT SORT PHASE IS REACHED
         EX    LEN,COMPARE   COMPARE TWO TABLE ELEMENTS
         BL    NEXTELEM      LOWER ELEMENT IS LOW
*                         ==> SEQUENCE IS AS DESIRED
         EX    LEN,XC1       *
         EX    LEN,XC2       **    EXCHANGE THE TWO ELEMENTS
         EX    LEN,XC1       *
         B     NEXTELEM
COMPARE  CLC   1(0,MSG),1(R1)
XC1      XC    1(0,MSG),1(R1)
XC2      XC    1(0,R1),1(MSG)
NEXTPHAS EQU   *
*              THIS ROUTINE IS ENTERED, WHENEVER LOWEST ELEMENT
*              IS AT LOWEST PLACE
         LA    MSG,2(LEN,MSG) POINT TO NEXT TABLE ELEMENT AND REPEAT
         CR    MSG,SW        IF MSG REACHES UPPER TABLE LIMIT
         BL    SORTANF       SORT CAN BE STOPPED
         LA    LEN,1(LEN)  . INCREASE LENGTH BY REF MARK
SORTEND  EQU    *
         TM    PRINTSW,PRINTNOT IS PRINT OUT REQUIRED ?
         BO    DONTPUTT .    NO, SKIP THE PUT INSTRUCTION
         L     R15,AHEADPRT  GET ADDRESS OF HEADER PRINT ROUTINE
         BALR  R14,R15       LINK TO IT
         TM    PRINTSW,ENDPRINT IS THIS A REFERENCE PRINT ?
         BZ    NOREF .       NO, LET THIS LINE UNPRINTED
         MVC   ACARDOUT+5(L'REF),REF   MOVE MESSAGE
         MVC   ACARDOUT+5+L'REF+2(4),MASK MOVE EDIT MASK
         ED    ACARDOUT+5+L'REF+2(4),TABID+6 EDIT TABLE ID
         MVI   ASA,C'-' .    SPACE THREE LINES
         BAL   LNK,PUTLINE . PUT THIS LINE
         OI    PRTCNT+3,3 .  FORCE LINE COUNT FROM 4 TO 7
NOREF    EQU   *
         MVC   ACARDOUT(L'UB),UB  PRINT HEAD LINE
         LA    MSG,ACARDOUT+L'UB+3
         MVC   0(L'ACTEL,MSG),ACTEL
         LA    MSG,L'ACTEL+1(MSG)
         BAL   LNK,UNPKR
         LA    MSG,L'MASK+2(MSG)
         MVC   0(L'ELLEN,MSG),ELLEN
         LA    MSG,L'ELLEN+1(MSG)
         L     LIMIT,ELEMLEN
         BAL   LNK,UNPKR
         LA    MSG,L'MASK+2(MSG)
         MVC   0(L'KYLEN,MSG),KYLEN
         LA    MSG,L'KYLEN+1(MSG)
         L     LIMIT,KEYLEN
         BAL   LNK,UNPKR
         MVI   ASA,C'-'      SPACE TWO LINES
         BAL LNK,PUTLINE
         MVI   ASA,C'0'
         L     R15,PRTCNT    GET LINECOUNT
         LA    R15,3(R15)    ADD THREE
         ST    R15,PRTCNT    AND RESTORE PRINT COUNT
PRINTTAB EQU   *
         L     LEN,ELEMLEN   GET ELEMENT LENGTH
         L     PNT,ADRCORE   GET START OF TABLE
         SR    LIMIT,LIMIT   CLEAR COUNT REG
         LA    MSG,ACARDOUT-L'MASK-2  POINT INTO OUTPUT LINE
PRTLOOP  EQU   *
         LA    LIMIT,1(LIMIT)   ADD ONE TO COUNT REG
         BAL   LNK,UNPKR     UNPACK THE COUNT TO LINE
         EX    LEN,PRTMOVE   MOVE ELEMENT TO PRINTLINE
         BAL   LNK,PUTLINE   AND PUT IT
         LA    PNT,1(LEN,PNT) SET OVER ELEMENT JUST WRITTEN
         CR    PNT,SW        END OF TAB E REACHED ?
         BL    PRTLOOP       NO, PRINT ON
         TM    PRINTSW,ENDPRINT IS THIS A FINAL PRINT
         BO    NEXTTAB .     IF YES, TRY NEXT TABLE
DONTPUTT EQU   *
         L     R1,THISENTR   POINT TO PARMLIST FOR LFDNRDEF
         L     R15,ALFDNRD   GET ADDRESS OF 'LFDNRDEF' ROUTINE
         BALR  R14,R15       AND LINK TO IT
         B     RESETEOF
UNPKR    EQU   *
         CVD   LIMIT,DMACCU  CONVERT THE COUNT TO DECIMAL
         MVC   0(L'MASK,MSG),MASK
         ED    0(L'MASK,MSG),DMACCU+5
         BR    LNK
PRTMOVE  MVC   ACARDOUT(0),0(PNT)
ONLYPRT  EQU   *
         L     R15,ATABENTR  GET BASE OF TABLE VECTOR
         LA    WK1,10 .      MAXIMUM NUMBER OF TABLES
LOOKNEXT EQU   *
         ST    R15,THISENTR  STORE ACTUAL VECTOR POINTER
         LM    R0,R1,0(R15)  GET A TABLE ENTRY INTO REGS
         LTR   R0,R0 .       IS THIS TABLE INITIALIZED ?
         BZ    NEXTTAB .     NO, TRY NEXT ONE
         ST    R0,ADRCORE  . INITIALIZE PRINT PARMS
         USING LFDPRMS,R1 .  ADDRESS LFDNR PARM FIELD
         TM    PRTSW,PRINTREF IS REFERENCE PRINT REQUIRED ?
         BZ    NEXTTAB .     NO, LET THIS TABLE
         LNR   SW,WK1 .      COMPLEMENT OF TABLE ID
         AH    SW,=H'11' .   NOW TABLE ID IS CORRECT
         CVD   SW,TABID .    SAVE ID OF THIS TABLE
         LR    SW,R0 .       SW MUST POINT TO END OF TABLE AT PRINT
         A     SW,LFDTABLN   SET TO END OF ACTIVE TABLE
         LH    LIMIT,LFDARGEN
         BCTR  LIMIT,0 .     REDUCE  IT BY REF MARK LENGTH
         ST    LIMIT,KEYLEN  SET KEYLENGTH
         LH    LEN,LFDLEN    GET TOTAL LENGTH
         BCTR  LEN,0   .      FOR REF MARK
         ST    LEN,ELEMLEN   INIT MOVE LENGTH
         LH    LIMIT,LFDANZ  NUMBER OF ELEMENTS
         OI    PRINTSW,ENDPRINT  INDICATE REF PRINT AT END OF RUN
         B     SORTEND .     DO THE PRINT OUT
NEXTTAB  EQU   *
         L     R15,THISENTR  GET CURRENT TABLE ENTRY
         LA    R15,8(R15)    POINT TO NEXT ENTRY
         BCT   WK1,LOOKNEXT
         B     XRET          RETURN AFTER TEN RETRIES
WARN     EQU   *
         BAL   LNK,CLEARLIN .CLEAR THE OUTPUT LINE
         MVC   ACARDOUT+20(PRTL),WARNPRT
         MVC   AFLAG,WARNIN  MOVE A FLAG TO OUTPUT LINE
         BAL   LNK,PUTLINE . PUT THE OUTPUT LINE
         B     GETCORE .     BUT CONTINUE PROCESSING
*
MASK     DC    X'402020202020'
K        DC    C'K'          KONSTANT FOR COMPARE
P        DC    C'P'
INSUMSG  DC    C'INSUFFICIENT CORE FOR TABLE, INCREASE REGION'
REF      DC    C'REFERENCE PRINT FOR TABLE'
HIGHMSG  DC    C'TABLE-ID. IS TOO HIGH (MAX = 10)'
UB       DC    C'SORTED TABLE'
KYLEN    DC    C',LENGTH OF KEY :'
ELLEN    DC    C',LENGTH OF 1 ELEMENT :'
ACTEL    DC    C',ACTIVE ELEMENTS :'
WARNPRT  EQU   *
PRINTNO  DC    C'PRINTNOT'
         DC    C' OR '
PRINTRE  DC    C'PRINTREF'
         DC    C' MISSPELLED'
PRTL     EQU   *-WARNPRT
ERROR    DC    CL12'*** ERROR **'
WARNIN   DC    CL12'*** WARNING'
PRINTSW  DC    X'0' .        LOCAL PRINT SWITCH
ENDPRINT EQU   128
TABID    DC    D'0' .        DW FOR TABLE ID DURING REFERENCE PRINT
ACTLEN   DC    F'0'          LENGTH OF ELEMENT +1 (REF MARK)
KEYLEN   DC    F'0'
ELEMANZ  DC    F'0'
ELEMLEN  DC    F'0'
MINCORE  DC    F'8'
MAXCORE  DC    F'0'
ADRCORE  DC    F'0'
LENCORE  DC    F'0'
ENDCORE  DC    F'0'
THISENTR DC    F'0'
EODADSAV DC    F'0'
         LTORG
         SPACE 3
LFDPRMS  DSECT
LFDANZ   DS    H             NUMBER OF TABLE ELEMENTS
LFDLEN   DS    H             LENGTH OF ONE ELEMENT
LFDARGAN DS    H             START OF ARGUEMENT WITHIN ELEMENT
LFDARGEN DS    H              END  OF ARGUEMENT WITHIN ELEMENT
LFDFILL  DS    9H            REQUESTED BY LFDNR
LFDTABLN DS    F             TOTAL LENGTH OF TABLE
PRTSW    DS    CL1  .        PRINT SWITCH INDIVIDUAL PER TABLE
LFDEND   DS    0D
LFDPRMLN EQU   LFDEND-LFDPRMS
         MEND
./ ADD  NAME=GENTNUM
         MACRO
&NM      GENTNUM   &SYS=OS
         AIF   ('&SYS' EQ 'DOS').COP
         AIF   ('&SYS' EQ 'OS').COP
         MNOTE 12,'SYSTEM &SYS NOT SUPPORTED, SPECIFY DOS OR OS'
         MEXIT
.COP     ANOP
GENTNUM  CSECT
*
*              THIS CSECT IS A TABLE FOR THE NUMERIC TEST
*
*              THE TEST IS FOR UNPACKED DECIMAL DIGITS
*              THE 'TRT' MUST BE COMPLETE WITH CODE 04 IN REG2, OR
*                                                CONDITION CODE = 0
*              THEN YOU CAN BE SURE THAT THE DATA IS CORRECTLY UNPACKED
*
*              AUTHOR :   H. FRANZ
*
*                 0 1 2 3 4 5 6 7 8 9 A B C D E F
DATA00   DC    X'08080808080808080808080808080808'         00-0F
DATA10   DC    X'08080808080808080808080808080808'         10-1F
DATA20   DC    X'08080808080808080808080808080808'         20-2F
DATA30   DC    X'08080808080808080808080808080808'         30-3F
DATA40   DC    X'08080808080808080808080808080808'         40-4F
DATA50   DC    X'08080808080808080808080808080808'         50-5F
DATA60   DC    X'08080808080808080808080808080808'         60-6F
DATA70   DC    X'08080808080808080808080808080808'         70-7F
DATA80   DC    X'08080808080808080808080808080808'         80-8F
DATA90   DC    X'08080808080808080808080808080808'         90-9F
DATAA0   DC    X'08080808080808080808080808080808'         A0-AF
DATAB0   DC    X'08080808080808080808080808080808'         B0-BF
DATAC0   DC    X'04040404040404040404080808080808'         C0-CF
DATAD0   DC    X'04040404040404040404080808080808'         D0-DF
DATAE0   DC    X'08080808080808080808080808080808'         E0-EF
DATAF0   DC    X'00000000000000000000080808080808'         F0-FF
*                 0 1 2 3 4 5 6 7 8 9 A B C D E F
*
         MEND
./ ADD  NAME=GENT99P
         MACRO
&NM      GENT99P   &SYS=OS
         AIF   ('&SYS' EQ 'DOS').COP
         AIF   ('&SYS' EQ 'OS').COP
         MNOTE 12,'SYSTEM &SYS NOT SUPPORTED, SPECIFY DOS OR OS'
         MEXIT
.COP     ANOP
GENT99P  CSECT
*              THIS CSECT IS A TABLE FOR THE NUMERIC TEST
*
*              THE TEST IS FOR PACKED DECIMAL DIGITS
*              THE 'TRT' MUST BE COMPLETE WITH CODE 04 IN REG 2
*              THEN YOU CAN BE SURE THAT THE DATA IS CORRECTLY PACKED
*
*              AUTHOR :  H. FRANZ
*                 0 1 2 3 4 5 6 7 8 9 A B C D E F
DATA00   DC    X'00000000000000000000080804040804'         00-0F
DATA10   DC    X'00000000000000000000080804040804'         10-1F
DATA20   DC    X'00000000000000000000080804040804'         20-2F
DATA30   DC    X'00000000000000000000080804040804'         30-3F
DATA40   DC    X'00000000000000000000080804040804'         40-4F
DATA50   DC    X'00000000000000000000080804040804'         50-5F
DATA60   DC    X'00000000000000000000080804040804'         60-6F
DATA70   DC    X'00000000000000000000080804040804'         70-7F
DATA80   DC    X'00000000000000000000080804040804'         80-8F
DATA90   DC    X'00000000000000000000080804040804'         90-9F
DATAA0   DC    X'08080808080808080808080808080808'         A0-AF
DATAB0   DC    X'08080808080808080808080808080808'         B0-BF
DATAC0   DC    X'08080808080808080808080808080808'         C0-CF
DATAD0   DC    X'08080808080808080808080808080808'         D0-DF
DATAE0   DC    X'08080808080808080808080808080808'         E0-EF
DATAF0   DC    X'08080808080808080808080808080808'         F0-FF
*                 0 1 2 3 4 5 6 7 8 9 A B C D E F
*
         MEND
./ ADD  NAME=IMSJOB
//Z227HF   JOB (6600,128,1),
//   FRANZ,MSGLEVEL=1,PRTY=11,
//   COND=(4,LE),
//   REGION=500K,CLASS=B,TIME=3
//GENDOS PROC CL=A,
//   SRC='OX.A6600.I128SRC',
//   MAC='SYS1.OCRLIB'
//GENDOS EXEC  PGM=IEUASM,
//   PARM='DECK,NOLOAD',
//   REGION=500K
//SYSLIB DD DSN=&SRC,DISP=SHR
//  DD  DSN=&MAC,DISP=SHR
//SYSUT1 DD UNIT=DISK,SPACE=(CYL,(10,2))
//SYSUT2 DD UNIT=DISK,SPACE=(CYL,(10,2))
//SYSUT3 DD UNIT=DISK,SPACE=(CYL,(10,2))
//SYSGO  DD UNIT=DISK,SPACE=(CYL,(01,2))
//SYSPRINT DD SYSOUT=&CL,
//   DCB=(RECFM=FBM,BLKSIZE=3146),SPACE=(CYL,(15,5))
//SYSPUNCH DD SYSOUT=B,DCB=BLKSIZE=3040
//       PEND
//GENMOD PROC  CL=A,
//   BIN='OX.A6600.I128BIN',
//   LMOD='OX.A6600.I128MOD'
//GENMOD EXEC PGM=IEWL,PARM='RENT,XREF,LIST,REFR',REGION=500K
//SYSLMOD DD DSN=&LMOD,DISP=SHR
//SYSLIB DD DSN=&BIN,DISP=SHR
//SYSUT1 DD DSN=&&UT1,UNIT=DISK,SPACE=(CYL,(1,1))
//SYSPRINT DD SYSOUT=&CL,DCB=BLKSIZE=605
//SYSLIN DD DDNAME=SYSIN
//       PEND
//GENBIN PROC  MBR=1,CL=A,
//   BIN='OX.A6600.I128BIN',
//   SRC='OX.A6600.I128SRC'
//GENBIN EXEC  PGM=IEUASM,PARM=(DECK,NOLOAD),REGION=500K
//SYSLIB DD DSN=&SRC,DISP=SHR
//       DD DSN=SYS1.MACLIB,DISP=SHR
//SYSUT1 DD UNIT=DISK,SPACE=(CYL,(3,2)),DSN=&&UT1
//SYSUT2 DD UNIT=DISK,SPACE=(CYL,(3,2)),DSN=&&UT2
//SYSUT3 DD UNIT=DISK,SPACE=(CYL,(3,2)),DSN=&&UT3
//SYSGO  DD DSN=&LOADSET,UNIT=DISK,SPACE=(CYL,(1)),DCB=BLKSIZE=80
//SYSPRINT DD SYSOUT=&CL,DCB=(RECFM=FBSM,BLKSIZE=3146),
//   SPACE=(CYL,(15,5))
//SYSPUNCH DD DSN=&BIN(&MBR),DISP=SHR
//       PEND
//S9  EXEC GENBIN,
//   MBR=GENIMS
//GENBIN.SYSLIB DD DSN=IMS.MACLIB,DISP=SHR
//  DD  DSN=OX.A6600.I128SRC,DISP=SHR
//   DD   DSN=SYS1.MACLIB,DISP=SHR
//GENBIN.SYSIN DD *
         GENIMS
         END
//NORENT EXEC GENMOD,
//   PARM.GENMOD='XREF,LIST'
//GENMOD.SYSIN DD *
     INCLUDE SYSLIB(GENIMS)
     NAME  GENIMS(R)
//
./ ADD  NAME=LUSORT
SORT     TITLE 'SORTIERUNG SPEICHER-INTERN  (NACH WDSORT)'
*
*        CALL  'LUSORT'   USING TABELLE, PARAMETER
*
*
*
LUSORT   CSECT
B        EQU   2
RANF     EQU   3
REND     EQU   4
WSR      EQU   5
K        EQU   8
RLNG     EQU   9
AK       EQU   10
CNT      EQU   11
         XSAVE (12),,LUSORT
         LM    2,3,0(1)      R.2 = BLOCK-ANFANG  = B
         LH    RLNG,2(3)     RLNG = FELD-LAENGE
         CH    RLNG,=H'256'
         BH    ZULANG
         LA    4,2     R4=2
         LH    8,0(3)  R8=NO OF FIELDS TO BE SORTED
         CR    4,8     R8=0 OR 1 ?
         BH    WTP     YES IF HIGH
         LR    REND,RLNG
         MH    REND,0(3)     PARMM (1)= ANZAHL DER SAETZE
         AR    REND,B        REND = B + FLD-LNG * FLD-ANZ
         SR    REND,RLNG     REND = ADR. OF LAST RECORD
         ST    REND,A        A(0) = REND
         SR    K,K           K = 0
         LR    CNT,RLNG
         BCTR  CNT,0
NXTKEY   LH    4,4(3)        R.4  = PARAM (3)
         BCTR  4,0           R.4  = DISPLACEMENT OF SORT KEY
         LH    7,6(3)        R.7  = PARAM (4)
         LA    5,X'81'
         LTR   7,7           ASCENDING GIBT  BZ/BO
         BNM   *+8
         LA    5,X'18'       DESCENDING GIBT BO/BZ
         LA    6,X'80'
STBIT    STC   6,DISPL+1(K)
         STC   5,DISPL(K)
         STH   4,DISPL+2(K)
         LA    K,4(,K)       K = K + 1
         SRA   6,1
         BNZ   STBIT
         LA    4,1(4)
         CH    4,8(3)        PARAM (5) =  FELD-ENDE
         BE    FLDENDE
         CH    K,=H'2048'
         BL    STBIT-4
         WTO   'FEHLER IM UNTERPROGRAMM LUSORT. SORTIERBEGRIFFE SIND ZU*
                LANG',ROUTCDE=11
         ABEND 888
ZULANG   EQU   *
         WTO   'FEHLER IM UNTERPROGRAMM LUSORT. FELDLAENGE IST ZU GROSS*
               ',ROUTCDE=11
         ABEND 999
*
FLDENDE  CLC   10(2,3),=H'0'
         BE    LASTKEY
         LA    3,6(3)
         B     NXTKEY
*                  VARIABLE BRANCH-INSTR.
IFZERO   BZ    FINDONE
IFONE    BO    FINDZERO
*                  INITIALIZE NEXT SEARCH PHASE
LASTKEY  ST    K,KEND
         SR    K,K
NEXTBIT  C     K,KEND             AK = POINTER IN DISPL-TABLE
         BNL   LASTBIT
         LA    AK,DISPL(K)        IF END OF A-TABLE
         LR    RANF,B
         L     REND,A(K)          REND = A(K)
         SR    RANF,RLNG          RANF = B - 1
         MVZ   IFZERO+1(1),0(AK)  SET CONDITION MASK
         MVO   IFONE+1(1),0(1,AK)
*                  MODIFY TM-INSTRUCTIONS
         MVC   TEST0+1(3),1(AK)   SET DISPLACEMENT
         MVC   TEST1+1(3),1(AK)     AND MASK-BITS
         OI    TEST0+2,REND*16    SET BASE-REGISTER
         OI    TEST1+2,RANF*16
         B     FINDZERO+2
LASTBIT  L     B,A(K)        B = A(K) + 1
         AR    B,RLNG
         L     WSR,A-4(K)
         ST    WSR,A(K)      A(K) = A(K-1)
         CR    B,WSR         B = A(K)
         BL    LASTBIT
         BE    KSUBTR
         LR    B,WSR         B = A(K)
KSUBTR   SH    K,=H'4'       K = K - 1
         B     IFDONE
*                  0-BIT  SUCHEN   ABWAERTS
FINDZERO SR    REND,RLNG     EIN FELD ZURUECK
         CR    REND,RANF
         BNH   GRUPEND
         EX    0,TEST0
         EX    0,IFONE
*                  1-BIT SUCHEN   AUFWAERTS
FINDONE  AR    RANF,RLNG     EIN FELD VORAN
         CR    RANF,REND
         BNL   GRUPEND
         EX    0,TEST1
         EX    0,IFZERO
*                  FELDER VERTAUSCHEN
XCHANGE  EX    CNT,MOVE1
         EX    CNT,MOVE2
         EX    CNT,MOVE3
         B     FINDZERO
*
TEST0    TM    0(REND),X'00'
TEST1    TM    0(RANF),X'00'
MOVE1    MVC   ZWISP(0),0(REND)
MOVE2    MVC   0(0,REND),0(RANF)
MOVE3    MVC   0(0,RANF),ZWISP
*                  RANF = END OF 1ST SUBGROUP
GRUPEND  ST    RANF,A+4(K)   A(K+1) =  D
         CR    RANF,B
         BL    LOWB          IF  D  =  B
         BE    EQUB
HIGHB    LA    K,4(,K)       K = K + 1
         B     NEXTBIT
*                  NUR 1-BITS GEFUNDEN
LOWB     L     RANF,A(K)
         B     GRUPEND
*                  GENAU EIN 0-BIT GEFUNDEN
EQUB     AR    B,RLNG        B = B + 1
         L     WSR,A(K)
         ST    WSR,A+4(K)    A(K+1) = A(K)
         CR    WSR,B
         BH    HIGHB
         LTR   K,K
IFDONE   BZ    DONE
         L     WSR,A-4(K)
         ST    WSR,A(K)
         CR    B,WSR         IF B = A(K)
         BE    KSUBTR
         AR    B,RLNG        B = B + 1
         CR    B,WSR
         BL    NEXTBIT
         B     KSUBTR
*
WTP      WTO   'LUSORT: ANZAHL DER TABELLENELEMENTE KLEINER ALS 2, AUFR*
               UF IGNORIERT.',ROUTCDE=11
DONE     XRETURN ,R
         LTORG
KEND     DS   F
ZWISP    DS    CL256
DISPL    DS    512F
A        DS    512F
         END
./ ADD  NAME=MBRJCL
//Z227HF   JOB (6600,128,1),
//   FRANZ,MSGLEVEL=1,PRTY=11,MSGCLASS=A,
//   CLASS=B,NOTIFY=Z227TSO,
//   COND=(4,LE)
//GENDOS PROC CL=A,
//   SRC='OX.A6600.I128SRC',
//   MAC='SYS1.OCRLIB'
//GENDOS EXEC  PGM=IEUASM,
//   PARM='DECK,NOLOAD',
//   REGION=500K
//SYSLIB DD DSN=&SRC,DISP=SHR
//  DD  DSN=&MAC,DISP=SHR
//SYSUT1 DD UNIT=DISK,SPACE=(CYL,(10,2))
//SYSUT2 DD UNIT=DISK,SPACE=(CYL,(10,2))
//SYSUT3 DD UNIT=DISK,SPACE=(CYL,(10,2))
//SYSGO  DD UNIT=DISK,SPACE=(CYL,(01,2))
//SYSPRINT DD SYSOUT=&CL,
//   DCB=(RECFM=FBM,BLKSIZE=3146),SPACE=(CYL,(15,5))
//SYSPUNCH DD SYSOUT=B,DCB=BLKSIZE=3040
//       PEND
//GENMOD PROC  CL=A,
//   BIN='OX.A6600.I128BIN',
//   LMOD='OX.A6600.I128MOD'
//GENMOD EXEC PGM=IEWL,PARM='RENT,XREF,LIST,REFR',REGION=500K
//SYSLMOD DD DSN=&LMOD,DISP=SHR
//SYSLIB DD DSN=&BIN,DISP=SHR
//SYSUT1 DD DSN=&&UT1,UNIT=DISK,SPACE=(CYL,(1,1))
//SYSPRINT DD SYSOUT=&CL,DCB=BLKSIZE=605
//SYSLIN DD DDNAME=SYSIN
//       PEND
//GENBIN PROC  MBR=1,CL=A,
//   BIN='OX.A6600.I128BIN',
//   SRC='OX.A6600.I128SRC'
//GENBIN EXEC  PGM=IEUASM,PARM=(DECK,NOLOAD),REGION=500K
//SYSLIB DD DSN=&SRC,DISP=SHR
//       DD DSN=SYS1.MACLIB,DISP=SHR
//SYSUT1 DD UNIT=DISK,SPACE=(CYL,(3,2)),DSN=&&UT1
//SYSUT2 DD UNIT=DISK,SPACE=(CYL,(3,2)),DSN=&&UT2
//SYSUT3 DD UNIT=DISK,SPACE=(CYL,(3,2)),DSN=&&UT3
//SYSGO  DD DSN=&LOADSET,UNIT=DISK,SPACE=(CYL,(1)),DCB=BLKSIZE=80
//SYSPRINT DD SYSOUT=&CL,DCB=(RECFM=FBSM,BLKSIZE=3146),
//   SPACE=(CYL,(15,5))
//SYSPUNCH DD DSN=&BIN(&MBR),DISP=SHR
//       PEND
//COPY EXEC PGM=IEBCOPY,REGION=500K
//SYSUDUMP DD SYSOUT=A
//SYSPRINT DD SYSOUT=A
//SYSUT3 DD DSN=A,UNIT=DISK,SPACE=(TRK,90)
//SYSUT4 DD DSN=AZ,UNIT=DISK,SPACE=(TRK,90)
//NSRC DD DSN=OX.A6600.I128SRC,DISP=SHR
//NBIN DD DSN=OX.A6600.I128BIN,DISP=SHR
//NMOD DD DSN=OX.A6600.I128MOD,DISP=SHR
//MAC DD DSN=LU.MACLIB,DISP=SHR
//SYSIN DD *
         COPY  I=MAC,O=NSRC
         SELECT  MEMBER=((SYSDATE,,R))
     COPY  I=NSRC,O=NSRC
   COPY I=NBIN,O=NBIN
   COPY I=NMOD,O=NMOD
//S12 EXEC GENBIN,
//   MBR=GENSYNQS
//GENBIN.SYSIN DD *
         GENSYNQS
         END
//NORENT EXEC GENMOD,PARM.GENMOD='LIST,XREF'
//GENMOD.SYSIN DD *
     INCLUDE SYSLIB(GENSYNQS)
     NAME  GENSYNQS(R)
//
//
./ ADD  NAME=MOVE
         MACRO
&NAME    MOVE  &T,&L,&F,&CPU=360
         GBLB  &FIRST
         GBLC  &GOTO1
         GBLC  &CSECT
         LCLC  &GOTO2
         LCLC  &GOTO3
         AIF   ('&CPU' EQ '370').CODE
         AIF   ('&CPU' EQ '360').C360
         MNOTE 12,'CPU=&CPU  INVALID, SPECIFY 360 OR 370'
.C360    AIF   (&FIRST).W11
&CSECT   SETC  '&SYSECT'
.W11     AIF   ('&T'(1,1) EQ '(').W1
&NAME    LA    1,&T .        LOAD ADDRESS OF RECEIVING FIELD
         AGO   .W2
.W1      ANOP
&NAME    LR    1,&T(1) .     LOAD ADDRESS OF RECEIVING FIELD
.W2      AIF   ('&L'(1,1) EQ '(').W3
         AIF   (T'&L NE 'N').W7
.W9      LA    15,&L .        GET LENGTH
         AGO   .W4
.W7      AIF   (T'&L EQ 'F').W8
         AIF   (T'&L NE 'H').W9
         LH    15,&L .       LENGTH IS IN HALFWORD
         AGO   .W4
.W8      L     15,&L .       LENGTH IS IN FULLWORD
         AGO   .W4
.W3      LR    15,&L(1) .    LENGTH IS IN REGISTER
.W4      AIF   ('&F'(1,1) EQ '(').W5
         LA    2,&F .        LOAD ADDRESS OF SENDING FIELD
         AGO   .W6
.W5      LR    2,&F(1) .     LOAD ADDRESS OF SENDING FIELD
.W6      AIF   ('&CSECT' EQ '&SYSECT').W12
&FIRST   SETB  0
&CSECT   SETC  '&SYSECT'
.W12     AIF   (&FIRST).W10
&FIRST   SETB  1
&GOTO1   SETC  'IBC&SYSNDX'
&GOTO2   SETC  'IAC&SYSNDX'
&GOTO3   SETC  'ICC&SYSNDX'
         LA    14,&GOTO2+2 .  LOAD ADDRESS OF NEXT INSTRUCTION
         LA    0,256 .          LOAD MAX. MVC-LENGTH
&GOTO1   CR    15,0 .           COMPARE WITH ACTUAL LENGTH
         BC    4,&GOTO3 .       IF LESS, BRANCH TO LTR
         MVC   0(256,1),0(2) . MOVE 256 BYTES
         SR    15,0 .           REDUCE ACTUAL LENGTH
         AR    1,0 .            RESET FIELD POINTERS
         AR    2,0
         BC    15,&GOTO1 .      GO TO COMPARE
         MVC   0(0,1),0(2) .   EXEC-MVC
&GOTO3   LTR   15,15 .          IS REMAINDER ZERO ?
         BC    8,&GOTO2 .       IF TRUE GO TO MEND
         BCTR  15,0 .           REDUCE FOR EXECUTE
         EX    15,&GOTO3-6 .    MOVE REMAINING BYTES
&GOTO2   BR    14 .           RETURN
         MEXIT
.W10     BAL   14,&GOTO1-4 .  BRANCH TO LOOP
         MEXIT
.CODE    AIF   ('&T'(1,1) EQ '(').C1
&NAME    LA    0,&T .        LOAD ADDRESS OF RECEIVING FIELD
         AGO   .C2
.C1      ANOP
&NAME    LR    0,&T(1) .     LOAD ADDRESS OF RECEIVING FIELD
.C2      AIF   ('&L'(1,1) EQ '(').C3
         AIF   (T'&L NE 'N').C7
.C9      LA    1,&L .        GET LENGTH
         AGO   .C4
.C7      AIF   (T'&L EQ 'F').C8
         AIF   (T'&L NE 'H').C9
         LH    1,&L .        LENGTH IS IN HALFWORD
         AGO   .C4
.C8      L     1,&L .        LENGTH IS IN FULLWORD
         AGO   .C4
.C3      LR    1,&L(1) .     LENGTH IS IN REGISTER
.C4      LR    15,1 .        LENGTH IS IN REGISTER
         AIF   ('&F'(1,1) EQ '(').C5
         LA    14,&F .       LOAD ADDRESS OF SENDING FIELD
         AGO   .C6
.C5      LR    14,&F(1) .    LOAD ADDRESS OF SENDING FIELD
.C6      MVCL  0,14 .        MOVE LONG
         MEND
./ ADD  NAME=SYSDATE
         MACRO
&NM      SYSDATE
&NM      DC    C'05/24/76'   MM/DD/YY             24.05.1976     76.145
         MEND
./ ADD  NAME=TIOTSCAN
         MACRO
&NM      TIOTSCAN  &DDNM,&JOBNM,&PROCNM,&STEPNM,&TIOT=
.*  TIOTSCAN INFORMES ABOUT EXISTENCE OF DDNAME IN THE TIOT.
.*  WHEN ASKD,THIS MACRO CAN EXTRACT JOBNAME,PROCNAME,STEPNAME
.*  FROM TIOT AND STORE THEM IN THE OUTSIDE OF MACRO DEFINIED FIELDS
.*  THE TIOT ADDRESS MAY BE SPECIFIED IN A FULLWORD,
.*  WHEN MACRO EXTRACT USED BEFORE.
.*  &DDNAME-THE ADDRESS OF IT MAY BE SPECIFIED IN THE FORM:
.*          FULLWORD OR (REGISTER)
.*  &JOBNAME-THE ADDRESS OF THE ASSIGNED FIELD MUST BE SPECIFIED IN
.*           THE FORM:FULLWORD OR (REGISTER) OR DISPLACEMENT(REGISTER)
.*  THE SAME FOR &PROCNAME AND &STEPNAME.
         LCLA  &L
         LCLB  &DN,&JN,&PN,&SN,&COUNT,&CN,&TI
         LCLC  &GNAME,&GNAME1,&GNAME2,&REG,&FELD,&SYM,&NHM
&GNAME   SETC  'IHB'.'&SYSNDX'
&GNAME1  SETC  '&GNAME'.'A'
&GNAME2  SETC  '&GNAME'.'E'
         AIF   (T'&NM EQ 'O').PEDR
&NHM     SETC  '&NM'
&NHM     EQU   *
.PEDR    AIF   (T'&DDNM EQ 'O').ERROR
&DN      SETB  (1)
         SR    0,0           CLEAN  REG
         AIF   ('&DDNM'(1,1) NE '(').LOAD
         LR    1,&DDNM       LOAD A(DDNAME)
         AGO   .ERROR
.LOAD    LA    1,&DDNM       LOAD  A(DDNAME)
         AGO   .ERROR
.LAOP    AIF   (T'&TIOT EQ 'O').NFND
&TI      SETB  (1)
         L     14,&TIOT      LOAD A(TIOT)
         AIF   (NOT &DN).LOOK
.NFND    ANOP
         AIF   (&TI).LAST
         L     14,16         A(CVT)
         L     14,0(14)      A(CVTTCB)
         L     14,4(14)      A(CURRTCB)
         L     14,12(14)     A(TIOT)
         AIF   (NOT &DN).LOOK
.LAST    LA    15,24(14)     FIRST  TIOT  ENTRY
&GNAME1  CLC   4(8,15),0(1)  DDNAME  EQUAL?
         BE    &GNAME        YES,RETURN
         IC    0,0(15)       GET ENTRY LENGHT
         LTR   0,0           LAST  ONE
         BZ    &GNAME2       YES,RETURN WITH CODE 0
         AR    15,0          NO,DO NEXT ONE
         B     &GNAME1
&GNAME2  SR    15,15         CLEAR REG
&GNAME   EQU   *
.ERROR   ANOP
         AIF   (&CN).LOOK
&CN      SETB  (1)
         AIF   (T'&JOBNM NE 'O').PAL1
.XP      AIF   (T'&PROCNM NE 'O').PAL2
.XS      AIF   (T'&STEPNM NE 'O').PAL3
         AIF   (&DN OR &JN OR &PN).LAOP
         MNOTE 12,'ALL NAMES OMITTED'
         MEXIT
.PAL1    ANOP
&JN      SETB  (1)
&COUNT   SETB  (1)
         AGO   .XP
.PAL2    ANOP
&PN      SETB  (1)
&COUNT   SETB  (1)
         AGO   .XS
.PAL3    ANOP
&SN      SETB  (1)
&COUNT   SETB  (1)
         AGO   .LAOP
.LOOK    AIF   (NOT &JN).PROC
         AIF   (T'&JOBNM EQ 'U').POX
         AIF   ('&JOBNM'(1,1) EQ '(').POLX
&SYM     SETC  '&JOBNM'
         AIF   (T'&JOBNM EQ 'N').ERR
         MVC   &JOBNM,0(14)  MOVE  JOBNAME
         AGO   .PROC
.POLX    ANOP
&REG     SETC  '&JOBNM(1)'
         MVC   0(8,&REG),0(14)      MOVE  JOBNAME
         AGO   .PROC
.POX     ANOP
&L       SETA  K'&JOBNM
.KLAM    AIF   ('&JOBNM'(&L,1) EQ '(').FND
&L       SETA  &L-1
         AGO   .KLAM
.FND     ANOP
&FELD    SETC  '&JOBNM'(1,&L).'8,'
&FELD    SETC  '&FELD'.'&JOBNM'(&L+1,K'&JOBNM-&L)
         MVC   &FELD,0(14)   MOVE  JOBNAME
.PROC    AIF   (NOT &PN).STEP
         AIF   (T'&PROCNM EQ 'U').POY
         AIF   ('&PROCNM'(1,1) EQ '(').POLY
&SYM     SETC  '&PROCNM'
         AIF   (T'&PROCNM EQ 'N').ERR
         MVC   &PROCNM,8(14)      MOVE PROCNAME
         AGO   .STEP
.POLY    ANOP
&REG     SETC  '&PROCNM(1)'
         MVC   0(8,&REG),8(14)        MOVE  PROCNAME
         AGO   .STEP
.POY     ANOP
&L       SETA  K'&PROCNM
.KLM     AIF   ('&PROCNM'(&L,1) EQ '(').FOND
&L       SETA  &L-1
         AGO   .KLM
.FOND    ANOP
&FELD    SETC  '&PROCNM'(1,&L).'8,'
&FELD    SETC  '&FELD'.'&PROCNM'(&L+1,K'&PROCNM-&L)
         MVC   &FELD,8(14)           MOVE PROCNAME
.STEP    AIF   (NOT &SN).ENDO
         AIF   (T'&STEPNM EQ 'U').POZ
         AIF   ('&STEPNM'(1,1) EQ '(').POLZ
&SYM     SETC  '&STEPNM'
         AIF   (T'&STEPNM EQ 'N').ERR
         MVC   &STEPNM,16(14)  MOVE  STEPNAME
         AGO   .ENDO
.POLZ    ANOP
&REG     SETC  '&STEPNM(1)'
         MVC   0(8,&REG),16(14)       MOVE  STEPNAME
         AGO   .ENDO
.POZ     ANOP
&L       SETA  K'&STEPNM
.KLAME   AIF   ('&STEPNM'(&L,1) EQ '(').FOUND
&L       SETA  &L-1
         AGO   .KLAME
.FOUND   ANOP
&FELD    SETC  '&STEPNM'(1,&L).'8,'
&FELD    SETC  '&FELD'.'&STEPNM'(&L+1,K'&STEPNM-&L)
         MVC   &FELD,16(14)            MOVE  STEPNAME
         AGO   .ENDO
.ERR     ANOP
         MNOTE 8,'INCORRECT  SYMBOL &SYM'
.ENDO    MEND
./ ADD  NAME=XRETURN
         MACRO
&SYM     XRETURN &RC,&MODE,&SP=0
.*
.*                 EXTENDED RETURN MACRO
.*                 RESTORES REGISTERS
.*                 MAY PROVIDE RETURNCODE
.*
         LCLA  &C
         LCLB  &NC,&CF
         LCLC  &R,&NM
         AIF   (T'&MODE EQ 'O' OR '&MODE' EQ 'R').CONT
         MNOTE 8,'UNKNOWN OPERAND'
         MEXIT
.CONT    ANOP
         AIF   (T'&SP EQ 'N').SPFIX
         MNOTE 8,'SUBPOOL NUMBER NOT A SELF-DEFINING TERM'
         MEXIT
.SPFIX   ANOP
         AIF   ('&SP' NE '0' AND '&MODE' NE 'R').SPERR
.NOERR   ANOP
&NM      SETC  '&SYM'
         AIF   (T'&RC NE 'O').CODE
&NC      SETB  (1)
         AGO   .NOCODE
.CODE    ANOP
&R       SETC  '15'
         AIF   ('&RC'(1,1) EQ '(').REG
         AIF   (T'&RC EQ 'N').FIX
&NM      L     15,&RC                  LOAD CODE
&NM      SETC  ''
         AGO   .NOCODE
.FIX     ANOP
&CF      SETB  (1)
         AGO   .NOCODE
.REG     ANOP
&R       SETC  '&RC'(2,K'&RC-2)
.NOCODE  ANOP
&NM      L     13,4(0,13)              GET HIGH SA ADDR
         AIF   (&NC OR &CF).NOSTORE
         ST    &R,16(0,13)             STORE CODE
.NOSTORE AIF   (T'&MODE EQ 'O').NORENT
         L     1,8(0,13)               GET LOW SA ADDR
         LH    0,2(1)                  GET LENGTH
         AIF   ('&SP' EQ '0').FM
         LA    2,&SP         WANTED SUBPOOL NUMBER
         SLL   2,24          INSERT SUBPOOL NUMBER INTO R2 HIGH BYTE
         OR    0,2           R0: SP-NO, LENGTH TO BE FREED
.FM      ANOP
         FREEMAIN  R,LV=(0),A=(1)
.NORENT  LM    14,12,12(13)            RESTORE REGS
         AIF   (NOT &CF).EXIT
         LA    15,&RC                  LOAD CODE
&C       SETA  &RC
         AIF   (&C/4*4 EQ &C).EXIT
         MNOTE 0,'UNUSUAL CODE'
.EXIT    MVI   12(13),X'FF'            FORTRAN REQUIREMENT
         SPM   14                      RESTORE PGM MASK AND CC
         BR    14
         MEXIT
.SPERR   ANOP
         MNOTE 4,'SUBPOOL SPECIFICATION INVALID WITHOUT FREEMAIN FUNCTI*
               ON, IGNORED'
         AGO   .NOERR
         MEND
./ ADD  NAME=XSAVE
         MACRO
&SYM     XSAVE &BASE,&AREA,&ID,&LEN,&SP=0
.*
.*                 EXTENDED SAVE MACRO
.*                 ASSUMES ENTRYPOINT ADDRESS IN REGISTER 15
.*                 SAVES REGISTERS 14 THROUGH 12
.*                 LOADS BASE REGISTER AND CHAINES SAVEAREAS
.*                 MAY PRODUCE REENTRANT CODE
.*
         LCLA  &OFFSET,&BASEOFF,&LLID,&DISPL,&I
         LCLA  &NREG,&REGIX,&LCH
         LCLC  &NM,&REG,&BL
         LCLC  &PREV,&IT
&OFFSET  SETA  4
&NM      SETC  '&SYM'
&REG     SETC  '15'
&BL      SETC  ''
&IT      SETC  '&ID'
         AIF   (T'&SP EQ 'N').SPFIX
         MNOTE 8,'SUBPOOL NUMBER NOT A SELF-DEFINING TERM'
         MEXIT
.SPFIX   ANOP
         AIF   ('&SP' NE '0' AND T'&AREA NE 'O').SPERR
.NOERR   ANOP
         AIF   (T'&ID EQ 'O').NOID
         AIF   ('&ID' NE '*').SETLL
&I       SETA  8
         AIF   ('&NM' EQ '').SECT
&IT      SETC  '&NM'.'          '
         AGO   .FINDL
.SECT    ANOP
&IT      SETC  '&SYSECT'.'          '
.FINDL   ANOP
         AIF   ('&IT'(&I,1) NE ' ').IDEND
&I       SETA  &I-1
         AIF   (&I NE 0).FINDL
&I       SETA  5
&IT      SETC  'XSAVE'
         AGO   .XID
.IDEND   ANOP
&IT      SETC  '&IT'(1,&I)
.XID     ANOP
&LLID    SETA  &I
         AGO   .ODDEV
.SETLL   ANOP
&LLID    SETA  K'&ID
.ODDEV   ANOP
         AIF   (&LLID NE &LLID/2*2).OVBL
&BL      SETC  ' '
&LLID    SETA  &LLID+1   BLANK
.OVBL    ANOP
&LLID    SETA  &LLID+8   DATE
&DISPL   SETA  4+1+&LLID   B,X,(DATE,ID)
&NM      B     &DISPL.(0,15)
         DC    AL1(&LLID)
         AIF   ('&ID' NE '*' AND '&ID' NE '').IDDEF
         DC    C'&IT&BL'     PGM-ID.
         AGO   .SDATE
.IDDEF   ANOP
         DC    C'&ID&BL'     PGM-ID.
.SDATE   ANOP
         SYSDATE
&OFFSET  SETA  4+4+1+&LLID   B,STM,X,(DATE,ID)
&NM      SETC  ''
.NOID    ANOP
&NM      STM   14,12,12(13)            SAVE REGS
         AIF   (T'&BASE EQ 'O').NOBASE
         AIF   ('&BASE'(1,1) NE '(').LOAD
&REGIX   SETA  1
&NREG    SETA  N'&BASE
&REG     SETC  '&BASE(&REGIX)'
         LR    &REG,15
&OFFSET  SETA  &OFFSET+2
.LOOP    ANOP
         USING *-&OFFSET+&BASEOFF,&REG
&REGIX   SETA  &REGIX+1
         AIF   ('&REGIX' GT '&NREG').SETUSE
&PREV    SETC  '&REG'
&REG     SETC  '&BASE(&REGIX)'
         LA    &REG,X'FFF'
         LA    &REG,1(&REG,&PREV)
&OFFSET  SETA  &OFFSET+8
&BASEOFF SETA  &BASEOFF+4096
         AGO   .LOOP
.LOAD    LR    &BASE,15                LOAD BASE REG
&OFFSET  SETA  &OFFSET+2
&REG     SETC  '&BASE'
.NOBASE  ANOP
         USING *-&OFFSET,&REG
.SETUSE  ANOP
         AIF   (T'&AREA NE 'O').NORENT
         AIF   ('&SP' EQ '0').SEELEN
         BAL   1,*+8         SKIP DEFINITION
         DC    AL1(&SP)      SPECIFIED SUBPOOL NUMBER
         AIF   (T'&LEN NE 'O').SPEC
         DC    AL3(72)       LENGTH FOR 1 SAVE AREA
         AGO   .LOAD0
.SPEC    DC    AL3(&LEN)     SPECIFIED LENGTH INCLUDING SAVE AREA
.LOAD0   L     0,0(,1)       GET R0 READY FOR GETMAIN
         AGO   .COMP
.SEELEN  ANOP
         AIF   (T'&LEN NE 'O').NOTZERO
         LA    0,72                    GET LENGTH
         AGO   .COMP
.NOTZERO ANOP
         LA    0,&LEN                  GET LENGTH
.COMP    ANOP
         GETMAIN   R,LV=(0)
         XC    0(3*4,1),0(1)           ZERO CHAIN ADDRESSES
         AIF   (T'&LEN NE 'O').GET
         LA    0,72                    GET LENGTH
         AGO   .NOSTH
.GET     ANOP
         LA    0,&LEN                  GET LENGTH
.NOSTH   ANOP
         STH   0,2(1)                  STORE LENGTH
         AGO   .COM
.NORENT  LA    1,&AREA                 GET SA ADDR
.COM     ST    1,8(0,13)               SA DOWN CHAIN
         ST    13,4(0,1)               SA UP CHAIN
         LR    13,1                    LOAD SA REG
         L     1,4(0,13)               GET HIGH SA
         LM    0,1,20(1)               RESTORE REGS 0 AND 1
         AIF   (T'&AREA NE 'O').DBL
         MEXIT
.DBL     AIF   (T'&LEN EQ 'O').TEST
         MNOTE 4,'SAVE AREA ID AND LENGTH MUTUALLY EXCLUSIVE, LENGTH IG*
               NORED'
.TEST    AIF   (T'&AREA EQ 'U').DEFINE
         MEXIT
.SPERR   ANOP
         MNOTE 4,'SUBPOOL SPECIFICATION INVALID WITHOUT GETMAIN FUNCTIO*
               N, IGNORED'
         AGO   .NOERR
.DEFINE  B     &AREA+72                BRANCH AROUND SAVEAREA
&AREA    DC    18F'0'                  SAVEAREA
         MEND
