         MACRO
         ACCESS  &PHASE
.***************************************************************
.*
.*
.*              ACCESS MACRO
.*
.*
.*FUNCTION
.*   WILL  ASSEMBLE NECESSARY ACCESS ROUTINES FOR EACH PHASE.
.*   PHASE 1 & 2 GET 'E' AND 'L' SERIES BUT NOT LOCNXT ROUTINE.
.*   PHASE 3 GETS 'L' SERIES AND LOCNXT NOT 'E' SERIES.
.*
.*CALLING SEQUENCE
.*       ACCESS  PHASE= A ONE DIGIT NUMBER EITHER 1, 2 OR 3
.*
.*
.****************************************************************
*    TAMER-ACCESS PACKAGE
*    TABLE DICTIONARY AREA IN THIS PACKAGE IS 16K
*
*
*    NOTE THAT WHEN A USER STARTS TO BUILD THE DICTIONARY HE MUST FIRST
*    CALL 'INTACC' TO INITIALIZE 'ACCESS'.  THIS INITIALIZATION IS NOT
*    NECESSARY IF THE DICTIONARY IS ALL OR PARTIALLY BUILTA.
*
*
*    ORDER OF CORE FOR ACCESS
*    LOCATIONS COMMON TO ACCESS AND TAMER
*    LOCATIONS FOR ROUTINES COMMON TO 'ENT' AND 'L' SERIES
*    LOCATIONS FOR 'L' SERIES
*    LOCATIONS FOR 'ENT' SERIES
*    ROUTINES COMMON TO 'ENT' AND 'L' SERIES
*    'L' SERIES
*    'ENT' SERIES
*
*
         EJECT
*
*
*  IMMEDIATE VALUES
*
*   MASKS  DM PREFIX
DMPFT1   EQU   128       TESTS 1ST BIT OF DICT PREFIX  1000 0000
DMPFT2   EQU   64        TESTS 2ND BIT OF DICT PREFIX  0100 0000
DMBYT    EQU   255            TESTS WHOLE BYTE
DMATRB   EQU   240            TESTS FIRST 4 BITS
*
*    MASKS TO TEST ROUTINE ENTERED UPON
DMEPTR   EQU   16             ENTPTR TEST, TESTS 5TH BIT FROM RIGHT
DMGPTR   EQU   8              GETPTR TEST, TESTS 4TH BIT FROM RIGHT
DMATRP   EQU   4         LATRPT, NOTE ALSO FOR LATGRP
DMACP    EQU   8        TESTS FOR LATACP,LATGRP
DMACPP   EQU   12       TESTS FOR LATACP (ALSO WORKS FOR LATRPT)
DMDELM   EQU   16        LDELNM
DMPFXT   EQU   192           TESTS DICT PFX, 1ST 2 BITS  1100 0000
DMGRUP   EQU   4             GROUP TEST, 3RD BIT FROM RIGHT
*
*      EQUATES GIVING DISPLACEMENTS OF NEEDED PARAMS FROM A(COS),WHICH
*      IS THE START-ADDRESS OF COMPILER COMMON.
*
*
LDICOT EQU   TIB20-COS
L8DCOT EQU   TIB20-COS
*
*
*
*
*      FOLLOWING ARE REGISTER EQUATES FOR TAMER
*
*
*
BDUMP6   EQU   *              START OF DEBUG DUMP AREA
       DS    0F
*    ACCESS- TAMER CONSTANTS AND WORK AREA
*    THESE VALUES ARE UNDER REGISTER 12
*
*      FOLLOWING IS THE TAMER CONSTANT AREA.  TIBS AND TAMMS ASSEMBLED
*      HERE ARE ACCESSIBLE TO ACCESS, AND TO THE PHASE PROGRAMMER.
*
       USING *,R12             BASE REGISTER FOR ACCESS CONSTANTS.
PBEG12   EQU   *             MUST FOLLOW 'USING' FOR REG12
FRSTAM DS      80F
LASTAM DS    D
DUMMY1 DS    F
*
****** PARAMETER LIST FOR STORAGE OF PARAM'S. GOT FROM COMPILER COMMON.
*
*
DPARST DS    F                     STORAGE FOR A(COS)PASSED TO PHASE.
DPARLS DS    19F                   STORAGE FOR PARAMS MOVE TO ACCESS
DMDMDM DS    20F                   FROM COMMON.
LPRIME EQU   DPARLS                A(PRIME)
LINSRT EQU   DPARLS+4              A(INSERT)
DTAMM1 EQU   DPARLS+24             A(LASTAM)
DMVDAD DC    F'0'                  A(MOVDIC), PASSED IN COMMON,STORED
*                                 HERE BY INTACC.
LDUMP6 EQU   *                     END OF DEBUG DUMP AREA
PTMSTR DS    F
FDCNT  DC    X'00000090'
PBCODE DC    X'C0DEC0DE'
ADSTOR DS    CL1
*
*
*      THE FOLLOWING ARE TAMER ADCONS FOR THE VARIOUS ROUTINE NAMES.
*
*
*
*
*
*      FOLLOWING ARE THE ADCONS FOR THE LAST TAMM IN THE TAMM AREA
*      (PRESENTLY USED AS THE TAMM FOR MAIN FREE AREA), AND THE ADDRESS
*      OF THE LAST BYTE OF FREE AREA AVAILABLE FOR TAMER-ACCESS TABLES.
*
ALAST  DC    A(LASTAM)
         DS    0F
*
*  TEMPORARY CELLS  FOR BASIC ASSEMBLER USAGE ONLY
*
DLDHSH   DC    A(DHASH)       DE110
DLDINC   DC    A(DINCOR)
DLGCOD   DC    A(DGRPCD)      DE110
DLHSCD   DC    A(DHSHCD)
LDLDIC   DC    A(DLDIC)
       EJECT
       DS    0F
*
*
         EJECT
*    ACCESS CONSTANT AND WORK AREAS  REFER. BY REG13
*
*    HOUSEKEEPING FOR THE DICTIONARY
*    LASTAM IS THE TAMM FOR THE CURRENT FREE AREA
*
*
*    HOUSEKEEPING FOR THE DICOT TABLE, NEEDED BY TAMER
*    THE DICOT TABLE IS THE TABLE USED TO HOLD INFORMATION ON THE
*    DICTIONARY SEGMENTS.  IT CONTAINS AN ENTRY FOR EACH SECTION AND
*    ITS ORDER CORRESPONDS TO THE ORDER OF THE SECTIONS.
*      EACH ENTRY IS 12 BYTES LONG---
*            BYTE  0   = CODE TESTED FOR STATUS OF SECTION.
*            BYTES 1-3 = ADDRESS OF A DICT. SECTION IN CORE.
*            BYTES 4-11= ADDRESS, ON DISK, OF A SPILLED SECTION.
*
*      THE CORE ADDRESS OF A SPILLED SECTION IS OBSOLETE UNTIL THE
*      SECTION IS READ BACK IN FOR UPDATING.  THEN BOTH ADDRESSES, DISK
*      AND CORE, ARE TRUE.  AFTER SPILL, UNTIL UPDATE, THE TRUE
*      ADDRESS IS THAT IN BYTES 4-11 OF THE DICOT ENTRY FOR THE SECT.
*
*
*    TIB20 RESERVED FOR THE DICOT TABLE IN PHASES 1,2,3
*
*    PARAMETER LOCATION NEEDED FOR CALL TO PRIME
*
       DS    0F
DLDIC  DC    X'0C'                 ENTRY SIZE IS 12 BYTES.
       DC    X'0000AC'
       DC    H'240'       PRIME SIZE OS
       DC    H'120'                GROW REQUEST AMOUNT.
       SPACE 5
*      STORE UNDER DATA FOR DINCOR.
       DS    0F
DUPDCD DC    X'FF000000'
DCENLG DC    F'12'                 LENGTH OF DICOT TABLE ENTRY.
DINSTR DC    5F'0'
DINSTB DC    2F'0'
         EJECT
*    LOCATIONS FOR BOTH 'ENT' AND 'L' SERIES
*      SHOULD NOT BE OVERLAID
*
*
*
*   REGISTER SAVE AREA
*
*      'ENT','L' SERIES, 'ENTDEL','LOCNXT' USE SAME AREA SINCE ONLY
*      ONE OF THESE ROUTINES IS CALLED AT A TIME
*      'DHASH', 'DINCOR' HAVE THEIR OWN AREA SEPARATE SINCE THEY ARE
*      CALLED BY THE OTHER ROUTINES
*
*    'DHASH' STORAGE AREA
         DS    0F
DSTORE   DS    CL4
DSTOR1   DS    CL4
D33S14   DC    2F'0'    SAVE AREA FOR R14,R15,UPON DEMORE CALL TO DICSP
*
DRSAVE   DS    CL56      SAVE AREA FOR 'ENT' SERIES, REG. 2-15
DL4      EQU   DRSAVE    SAVE AREA FOR 'L' SERIES
*
*
*    SAVE AREAS FOR REG 14,15  ARE UNDER REG12
*
*    FOR 'DL' SERIES
D1SV14   DS    F
DL15     DS    CL4
         DS    2F                 ADDITIONAL STORAGE, USED IN INTACC
*
*    FOR 'LOCNXT'
D2SV14   EQU   D1SV14
D2SV15   EQU   DL15
*
*    FOR 'DE' SERIES
D3SV14   EQU   D1SV14
DS15     EQU   D2SV15
*
*    FOR 'ENTDEL'
D4SV14   EQU   D1SV14
D4SV15   EQU   D2SV15
*
*    FOR 'INTACC'
D5SV14   EQU   D1SV14
D5SV15   EQU   D2SV15
*
*
*    CONSTANTS, MASKS, WORK AREAS
*      COMMON TO BOTH PARTS OF ACCESS
*
*   CONSTANTS
         DS    0F
DHDIV    DC    F'521'        DIVIDE CONSTANT FOR DHASH
DMDSPL   DC    X'000001FF'    MASKS OUT ALL BUT DISPLAC
DMSECT   DC    X'003FFE00'   MASKS OUT ALL BUT SECT. NO.
D512     DC    F'512'
DSUBVL   DC    X'00000200'   USED IN DINCOR TO DECREM. SECT. NO.
*
*    WORK CELL
         DS    0F
DWORK    DS    CL1       DUMMY FOR REG REFER
DWORK1   DS    CL3
DELSAV   DC    F'0'            FOR DELIM PTR IN CASE SPILLED SECTION
*
         DS    0F
*    DHWORD BYTE =0  USED BY DE210
DHWORD   DC    X'00'         DUMMY FOR XR PICK-UP, MUST BE ZERO (LTR)
DHSHCD DS    CL3              DUP. HASH CODE
*    DGRPCD MUST START ON A FULL WORD BOUNDARY AND MUST FOLLOW DHSHCD.
*    WHEN DUP. HASH AND GROUP CODES APPEAR TOGETHER, THEY ARE MOVED INT
*    THE DICT. AS ONE UNIT  (SEE DMVCOD).
DGRPCD   DC    X'400000'     GROUP CODE, 01 IN 1ST 2 BITS
         EJECT
*   HOUSEKEEPING FOR ACESS ROUTINES  LATRNM,LATRPT,LDELNM,LATACP,LATGRP
*
*    LOCATIONS FOR 'L' SERIES
*      SHOULD NOT BE OVERLAID
         DS    0F
DSWTCH   DC    A(DL500)       FOR LATACP SWITCH OFF
*
*  MASKS   DM PREFIX
         DS    0F
*    DMSKCD BYTE0 USED TO SET DLMPTR BYTE0 NON-ZERO
DMSKCD DC    X'003FFFFF'           MASK OUT CODE BITS
DMSKDL DC    X'FF000000'           BYTE 0 MUST BE NON-ZERO
DMBYT1   DC    X'00FFFFFF'    MASKS OUT 1ST BYTE (AND)
*
*    NAME COMPARISON INSTRUCTION
DCOMPR CLC   0(0,R2),0(R9)       R2=A(DICT NAME), R9=A(INPUT NAME)
*
*    LAST VALID ENTRY POINTER (NEEDED FOR LATACP)
*    BITS 0-7 MUST EQUAL ZERO
         DS    0F
DSTART DC    F'0'                 MUST BE SET TO 0.NOT USED ACROSS PH5.
*
*    'DLMPTR'  SET IN ALL VALID CALLS TO ACCESS BY 'L' ROUTINES,
*    TESTED BY LATACP.  VALUE = GROUP DELIMITER POINTER FOR GROUP ITEMS
*    FOUND BY LATACP, LDELMN, ITS BYTE0 NONZERO FOR ELEM. ITEMS FOUND
*    BY LATACP, SET ZERO BY ALL OTHER ROUTINES.
*
*    'DLTEMP'  USED IN 'L' SERIES TO SAVE A(ATTRIB) OF FIRST MATCH
*    FOUND  CHANGE THIS IF 'DLMPTR' USED IN DL300 LOOP
DLMPTR DC    F'0'                  SET TO 0 BY DEFINITION.  2/16/66.
DLTEMP   EQU   DLMPTR
         EJECT
*   HOUSEKEEPING FOR ENTNAM,ENTPTR,GETPTR
*      OVERLAID IN PHASE 3
*
*
*    MASKS FOR 'ENT' SERIES
         DS    0F
DMPFX2   DC    X'00800000'    INSERTS PREFIX=2 IN 2ND BYTE
DMPFX3   DC    X'00C00000'    INSERTS PREFIX=3 IN 2ND BYTE
DMDLM    DC  X'C00000'       MASK TO CLEAR DELIM PART OF GROUP CODE
*
*   MOVE INSTRUCTIONS         R2=DICT ADDRESS
         DS    0F
DMVCOD MVC   0(0,R2),0(R8)  R8= 0GRPCD,DHSHCD
DMOVE  MVC   0(0,R2),0(R9)  R9= A(NAME,ATTRIB)
         EJECT
DTSAVE  DC  F'0'
         EJECT
       SPACE 5
******                                                           ******
******                                                           ******
*                                                                     *
*                           ** INTACC **                              *
*                                                                     *
*      INTACC---ACCESS INITIALIZATION ROUTINE.                        *
*                                                                     *
*      CALLS----INTACC IS CALLED AS PART OF INITIALIZATION BY         *
*               EACH PHASE USING ACCESS.                              *
*                                                                     *
*      FUNCTION-INTACC PRIMES THE DICOT TABLE AND MOVES ADDRESS       *
*               OF TAMER ROUTINES CALLED BY ACCESS FROM COMMON TO
*               ITS OWN ADDRESS STORAGE AREA.
*
*****
       DS    0F
       USING *,R15
INTACC EQU   *
       ST    R12,DINS12
       L     R12,DATADD                STORE R12.
       STM   R14,R1,D5SV14             STORE REST UNDER BASE 12
****** THE LOADING OF THE FOLLOWING PARAMETERS MUST BE DONE
****** BEFORE ANY ACCESS ROUTINE OTHER THAN INTACC IS CALLED.
       L     R1,DPARST                 LOAD A(COS).
       MVC   LPRIME(8),APRIME
*                                      PARAMETER LIST
       MVC   DTAMM1(4),ALSTAM
       MVC   DMVDAD(4),AMOVDC
       TM    ACCESW,1
       BC    ONES,INTCEX               NO. DICOT TABE PRIMED. EXIT
       MVI   ACCESW,1
*   ON FIRST CALL TO INTACC, THE HASH TABLE IS ZEROED OUT, AND THE
*   DICOT TABLE IS PRIMED. HASH TABLE=(521) (3)=(1563) BYTES LONG.
       L     R1,ACCESW                 A(HASA TABLE)
       LA    R14,6                     LOAD LOOP COUNT.
PHTBZR XC    0(255,R1),0(R1)           CLEAR 255 BYTES.
       LA    R1,255(R1)                INCREMENT.
       BCT   R14,PHTBZR
       XC    0(33,R1),0(R1)            CLEAR TABLE.
*   AFTER ZERO-OUT OF HASH TABLE, PRIME DICOT TABLE.
       L     R1,LDLDIC                 LOAD A(DICOT TABLE PARM).
       L     R15,LPRIME                A(PRIME).
       BALR  R14,R15                   CALL PRIME
*   EXIT AFTER INITIALIZATION FINISHED.
INTCEX LM    R14,R1,D5SV14
       L     R12,DINS12
       BCR   15,R14                    RETURN.
****** THIS AREA IS FOR STORAGE OF R12 UNDER R15,
****** AND DATA BASE ADDRESS.
DATADD DC    A(PBEG12)                 DATA BASE ADDRESS
DINS12 DC    F'0'                      STORAGE FOR CALLER'S REG 12.
         EJECT
*                                                                     *
*                           **  DINCOR  **                            *
*                                                                     *
*      DINCOR--- GIVEN A DICTIONARY POINTER, DINCOR CHECKS TO SEE     *
*                IF THE SECTION FOR THAT POINTER IS IN CORE.          *
*                IF IT IS- DINCOR RETURNS WITH THE ENTRY ADDRESS.     *
*                IF NOT--- DINCOR CALLS THE ROUTINE WHICH READS       *
*                          IN THE SPILLED SECTION,THE RETURNS WITH    *
*                          THE ENTRY ADDRESS.                         *
*      INPUT---- R2 = DICTIONARY POINTER                              *
*      OUTPUT--- R2 = ENTRY ADDRESS .                                 *
*                R0 = SEGMENT ADDRESS,USED IN LOCNXT.                 *
*                                                                     *
******                                                           ******
       SPACE 5
       DS    0F
       USING *,R15
DINCOR EQU   *
       STM   R3,R7,DINSTR          STORE REGISTERS.
       STM   R14,R15,DINSTB        STORE DINCOR BASE ADDRESS,RETURN AD.
       LR    R5,R2                 LOAD DICT.POINTER
       N     R5,DMSECT             MASK OUT SECT. NUMBER.
       S     R5,DSUBVL             SUB X'200' FOR DICOT SECT.NUMBER--
*                                  GIVING 1 SECTION LOWER THAN SECTION
*                                  VALUE IN POINTER.
       SRL   R5,9                  SHIFT DOWN TO OBTAIN SECTION NUMBER.
*                                  0 FOR SECTION 1,
*                                  1 FOR SECTION 2,
*                                  2 FOR SECTION 3, ETC.
       M     R4,DCENLG             MULTIPLY BY LGTH OF DICOT ENTRY.
*                                  RESULT,IN R5, IS DISPLACEMENT.
       L     R7,DPARST             LOAD  A(COS).
       LA    R7,LDICOT(R7)         OBTAIN A(TIB20)= A(DICOT TIB).
       L     R7,0(R7)              LOAD A(DICOT TAMM).
       L     R7,0(R7)              LOAD A(DICOT TABLE).
       LA    R3,0(R5,R7)           LOAD A(ENTRY FOR POINTER).
       SPACE 2
*      TEST HERE FOR SECTION IN CORE, OR SPILLED SECTION.
       TM    0(R3),128             HAS SECTION BEEN SPILLED?
       BC    ZERO,DINSCA              NO. LOAD ADDRESS OF SECTION.
       TM    0(R3),96                 YES.HAS IT BEEN READ IN,UPDATED?
       BC    ONES,DINSCA                 YES.THEN CORE ADDRESS IS VALID
       SPACE 2
*      THIS CODE CALLS TAMER'S MOVDIC ROUTINE, WHICH READS IN SPILLED
*      SECTION,AND ADJUSTS THE DICOT ENTRY FOR IT ACCORDINGLY.
*      MOVDIC RETURNS THE SECTION ADDRESS IN R0.
       SPACE 2
DGTSPL L     R15,DMVDAD                  NO. LOAD A(MOVDIC).
       O     R15,DUPDCD                      SET HIGH BYTE OF 15 =X'FF'
       BALR  R14,R15               CALL MOVDIC.
*      WHEN DINCOR CALLS MOVDIC, IT PASSES A(DICOT ENTRY)FOR SECTION
*      IN R3. MOVDIC PLACES IN-CORE ADDR. OF SECT. IN DICOT TABLE.
       LM    R14,R15,DINSTB        RESTORE A(DINCOR),RETURN ADDRESS.
DINSCA L     R0,0(R3)                 NO. LOAD ADDRESS OF SECTION.
       N     R0,DMBYT1             MASK OUT TOP BYTE IN ADDRESS REG.
       N     R2,DMDSPL             MASK OUT ALL BUT DISPLACEMENT.
       AR    R2,R0                 OBTAIN ADDRESS OF ENTRY.
       SPACE 2
DINCEX LM    R3,R7,DINSTR          RELOAD REGISTERS USED.
       BCR   15,R14                RETURN TO CALL
       EJECT
         EJECT
*   ROUTINE 'DHASH'
*       USED BY BOTH 'ENT','L' SERIES
*
*     HASHES BCD NAME, LOCATES CORRES. HASH TABLE ENTRY
*    INPUT  R9=A(BCD NAME)       'ENT'  R9  'L' R9
*           R11= BCD NAME CNT            R11     R11
*    OUTPUT R8= 0,DICT PNTR             R8      R8
*           R10= A(HASH TABLE ENTRY)     R10     R10
*           R8/R9  EVEN/ODD  DIVIDEND
*           R10/R11  EVEN/ODD  INCREM./COMPAR.
*
*    HASHING FUNCTION
*      SEGMENT NAME (INCL. CNT) INTO 4 BYTE LENGTHS, ADD LENGTHS
*      TOGETHER LOGICALLY, DIVIDE SUM BY SIZE OF HASH TABLE, MULT
*      REMAIN. BY 3 TO OBTAIN DISPL. ADD IT TO A(HASH TABLE) AND
*      PICK UP CORRES. ENTRY
*      ENTRY=0 OR DICT. PNTR OF LAST BCD NAME WHICH HASHED TO THIS LOC
*
*     NOTE THAT INPUT NAME IS PADDED OUT WITH ZEROES SO 4 BYTES CAN BE
*     ADDED AT A TIME
*
*
         DS    0F
       USING *,R15
DHASH    EQU   *
       ST    R9,DSTORE
       LA    R10,4(R0,R0)    R10=INCREMENT=4
       SR    R8,R8       R8= CNTR =0,4,...
       SR    R0,R0         R0=SUM, INITIALLY ZERO
DHLOOP AL    R0,0(R9,R8)    NOTE, NO OVERFLOW INTERRUPT
       BXLE  R8,R10,DHLOOP      R8= R10+1 =COMPARAND
       LR    R9,R0
       SR    R8,R8       R9= R8+1
       D     R8,DHDIV     R8/R9 =DIVIDEND,  SIGN IS +
       LA    R10,0(R8,R8)     R8= REMAINDER, MULT BY 3
       AR    R10,R8
*     DISPLAC COMPUTED, OBTAIN ENTRY
*
*      TEMPORARY HASH TABLE PLACEMENT OF HASH TABLE,'PHASHT', AT END
*      OF TAMER CODING IN PHASE 0.
*
       L     R8,DPARST           LOAD ADDRESS OF COS.
       L     R8,ACCESW-COS(R8)         A(PHASHT)
       LA    R10,0(R10,R8)       INCREMENT TO DISPLACEMENT IN HASH
*                                 TABLE FOR CURRENT DICTIONARY ENTRY.
       MVC   DHSHCD(3),0(R10)
       L     R8,DHWORD    1ST BYTE MUST = 0
       L     R9,DSTORE
       BCR   UNCOND,R14
*
*
         EJECT
*   ACCESS ROUTINES   LATRNM,LATRPT,LDELNM,LATACP,LATGRP
*     'L' (LOCATE) SERIES    'DL' PREFIX
*    NOTE  SHOULD NEVER USE LATACP FOLLOWING AN INVALID CALL TO ACCESS.
*    LATACP TESTS 'DLMPTR', SET IN LAST VALID CALL TO ACCESS.
*    'DLMPTR' = GROUP DELIMITER POINTER IF LAST CALL WAS TO LATACP,
*    LDELMN AND ENTRY WAS VALID AND GROUP ITEM.  'DLMPTR' BYTE0 NONZERO
*    IF LAST CALL WAS BY LATACP AND ELEM. ITEM WAS FOUND.  'DLMPTR'
*    SET ZERO BY ALL OTHER ROUTINES.
*
*
         DS    0F
DLBEG    EQU   *
LATRNM   EQU   *
LATRPT   EQU   *
LDELNM   EQU   *
LATACP   EQU   *
LATGRP   EQU   *
*
       USING *,R15
       ST    R12,D1SV12    REG12 IS USED TO REFER. CONSTANTSETC
       L     R12,D1RG12
       STM   R14,R15,D1SV14     REG13 IS NOT USED SO NOT SAVED
       TM    0(R1),DMACP
         BC    ZERO,DL200
*
*    LATACP, LATGRP ENTRY   COMPUTE LIMITS FOR ENTRY TO BE LOCATED
*    DSTART WILL = LOWER LIMIT OF ENTRIES TO SCAN, IE. = HEADER GROUP
*    POINTER.  R5 WILL = UPPER LIMIT OF ENTRIES TO SCAN, IE.= DELIMITER
*    PONTER.  IN LATGRP, PICK UP DELIMITER POINTER FROM GROUP HEADER
*    DICT. ENTRY.  IN LATACP, TEST 'DLMPTR'  (SEE COMMENTS).
DL100  STM   R4,R11,DL4
       SR    R6,R6          SET LATACP SWITCH ON
       TM    0(R1),DMATRP
         BC    NOTZER,DL150
*
*    LATACP ENTRY, CHECK 'DLMPTR'
*    'DLMPTR' = GROUP DELIMITER POINTER IF LAST CALL TO ACCESS WAS BY
*    LDELMN OR LATACP AND ENTRY WAS VALID AND GROUP ITEM.
*
DL110  L     R2,DSTART     DSTART= LAST VALID ENTRY POINTER
       L     R5,DLMPTR
       LTR   R5,R5
         BC    ZERO,DL160
         TM    DLMPTR,DMBYT  IF BYTE0 IS NONZERO, LAST ITEM WAS ELEM.
         BC    ZERO,DL160
*
*    LAST CALL WAS FOR ELEM. ITEM, INPUT ITEM ELEM. ITEM  ERROR EXIT
DL130  LA    R14,12(R0)
         BC    UNCOND,DXEXIT
*
*    LATGRP ENTRY,  LATACP ENTRY WHEN LAST CALL WAS NOT BY LATACP,
*    LDELMN.  REFERENCE GROUP HEADER DICT. ENTRY TO OBTAIN DELIMITER
*    POINTER
*    NOTE THAT 'DSTART' BYTE0 MUST =0  OK SINCE LATGRP INPUT CODE =0.
DL150  L     R2,4(R1)      LATGRP
       ST    R2,DSTART
*
*   NOW OBTAIN DELIM.,IF ANY, FOR GROUP ITEM    SET R5=DELIM
DL160  L     R15,DLDINC    R2= INPUT
       BALR  R14,R15
       L     R15,DL15       OUTPUT   R2=DICT ADDRESS
       TM    0(R2),DMPFT1
         BC    ZERO,DL170
       LA    R2,3(R2)       UPDATE PAST HASH CODE
DL170  TM    0(R2),DMPFT2
         BC    ZERO,DL130    BRANCH IF NO GROUP CODE
       MVC   DWORK1(3),0(R2)
       L     R5,DWORK       SET R5=GROUP DELIM POINTER
       N     R5,DMSKCD      MASK OUT CODE BITS
         BC    UNCOND,DL210
*
*   INITIAL.   LATRNM,LATRPT,LDELNM     TEST IF LATRPT
DL200  TM    0(R1),DMATRP   SUFFIC TEST   CANNOT BE LATGRP
         BC    ONES,DL700
       STM   R4,R11,DL4
       L     R6,DSWTCH      SET LATACP SWITCH OFF
*
*   PROCESSING FOR ALL ROUTINES EXCEPT LATRPT
*    HASH THE INPUT NAME, INVESTIGATE DICT. ENTRIES THAT HASH TO SAME
*    VALUE.  INITIALLY AGREE CODE =0.  WHEN 1ST MATCH IS FOUND, SET
*    AGREE CODE = ITS POINTER.
DL210  SR    R3,R3     SET AGREE CODE=0
       L     R9,0(R1)      SET R9= A(INPUT BCD NAME)
       SR    R11,R11
       IC    R11,0(R9)  SET R11=INPUT NAME CNT
       L     R15,DLDHSH
       BALR  R14,R15
       L     R15,DL15
       LTR   R8,R8     DHASH OUTPUT  R8= 0,DICT POINTER
         BC    NOTZER,DL300
       LA    R14,4(R0,R0)     NO POINTER PRESENT  ERROR EXIT
         BC    UNCOND,DXEXIT
*
*    LOOP  CHECK THRO ALL DUP. HASH NAMES UNTIL NO MORE FOUND OR 2
*          MATCHES FOUND
*          R8= CURRENT TEST POINTER       LOOP DL300-DL550
*          INITIAL VALUE OF CURRENT POINTER = C(HASH TABLE ENTRY).
*
*   LATACP ENTRY   TEST IF CURRENT POINTER POINTS TO ENTRY BETWEEN
*      GROUP HEADER AND DELIMITER
*      IF NOT, CHECK NEXT DUP HASH POINTER IF ANY
*    TEST IF LATACP, LATGRP ENTRY  (R6=0)
*    IF YES, TEST IF CURRENT POINTER LESS THAN GROUP HEADER POINTER
DL300  LTR   R6,R6
         BC    NOTZER,DL310
       C     R8,DSTART
         BC    LO,DL560      CURRENT POINTER LESS, DISCONTINUE SEARCH
DL310  LR    R2,R8
       L     R15,DLDINC
       BALR  R14,R15        LOCATE ENTRY
       L     R15,DL15       OUTPUT   R2=DICT ADDRESS
       SR    R7,R7          R7= DUP HASH INDICATOR
       TM    0(R2),DMPFT1
         BC    ZERO,DL400
       MVC   DWORK1(3),0(R2)     SET R7=DUP HASH POINTER
       L     R7,DWORK
       N     R7,DMSKCD      MASK OUT CODE BITS
       LA    R2,3(R2,R0)
*
*    AGAIN, TEST IF LATACP, LATGRP ENTRY  (R6=0)
*      NOTE  1ST TEST (DL300) WAS TO AVOID POSSIBLE UNNECESSARY
*      RETRIEVAL OF A SEGMENT
*      IF YES, CHECK FOR MATCH ONLY IF CURRENT POINTER LESS THAN
*      DELIMITER POINTER
DL400  LTR   R6,R6
       BCR   NOTZER,R6      IF NOT, R6=DL500
*
       CR    R8,R5          R5=DELIMITER
         BC    NOTLO,DL550
*
*   DOES DICT. NAME AGREE WITH INPUT NAME
*    NOTE  DL500 IS THE TRANSFER POINT IN LATACP SWITCH
DL500  SR    R10,R10          R10 INDICATOR FOR LDELNM
       TM    0(R2),DMPFT2
         BC    ZERO,DL510
       LR    R10,R2          SET R10=A(GROUP CODE)
       LA    R2,3(R2)
*    NOTE  R11= CORRECT VALUE, 1 LESS THAN NO. OF BYTES TO BE COMPARED
DL510  EX    R11,DCOMPR     COMPARE NAMES, R11=INPUT NAME CNT
         BC    NOTEQ,DL550
       LTR   R3,R3          TEST AGREE CODE
         BC    ZERO,DL520
*
*   NAMES AGREE, NOT FIRST MATCH, ERROR EXIT
       LA    R14,8(R0)
         BC    UNCOND,DXEXIT
*
*
*   NAMES AGREE, FIRST MATCH
*    SET R3= ITS DICT POINTER
*    SET R4 =A(GROUP CODE OF 1ST MATCH)
DL520  LR    R3,R8
       LR    R4,R10
         MVC   DELSAV(3),0(R10)
*
*    DOES THIS ENTRY POINT TO ANOTHER DUP HASH VALUE
DL550  LTR   R7,R7
         BC    ZERO,DL560
       LR    R8,R7          YES, SET CURRENT PNTR= DUP HASH POINTER
         BC    UNCOND,DL300
*
*    NO MORE DUP HASH, CHECK IF MATCH WAS EVER FOUND
DL560  LTR   R3,R3
         BC    NOTZER,DLEXIT
       LA    R14,4(R0)      NO, ERROR EXIT
         BC    UNCOND,DXEXIT
*
*    VALID ENTRY EXIT    OUTPUT IN REG 2,3,15   REG4 RESTORED
*    TEST IF LDELMN, LATACP ENTRY
*    IF YES, TEST IF ENTRY IS GROUP ITEM
*    R4 = A(GROUP CODE, IF ANY, OF MATCH)
DL600    EQU   *
DLEXIT LR    R2,R3
       L     R15,DLDINC
       BALR  R14,R15
       L     R15,DL15
       TM    0(R2),DMPFXT
       BC    ZERO,DL602
       LA    R2,3(R2)
       BC    MIXED,DL602
       LA    R2,3(R2)
DL602  EQU   *
       LA    R2,1(R2,R11)
       TM    0(R1),DMDELM
         BC    ZERO,DL610
       LTR   R4,R4         LDELMN ENTRY
         BC    NOTZER,DL620
*
*   LDELNM  INPUT NAME ELEM ITEM, ERROR EXIT  REG2,3 SET UP, REG4 UNCHG
       LA    R14,12(R0)
         BC    UNCOND,DXEXIT  RESTORE REG4
*
*    NOT LDELMN, TEST IF LATACP
DL610  TM    0(R1),DMACPP  NOTE  CANNOT BE LATRPT SO TEST IS OK
         BC    NOTMXD,DL640
*    LATACP,  IF NOT GROUP ITEM, SET 'DLMPTR' BYTE0 NONZERO
       LTR   R4,R4
         BC    NOTZER,DL620
       L     R4,DMSKDL             (DMSKDL) BYTE 0 = FF
         BC    UNCOND,DL650
*
*    LATACP, LDELMN ENTRY AND A GROUP ITEM
*    SET 'DLMPTR', REG1 = GROUP DELIMITER POINTER  (BYTE0=0)
DL620    MVC   DWORK1(3),DELSAV
       L     R1,DWORK
       N     R1,DMSKCD     MASK OUT CODE
       ST    R1,DLMPTR
         BC    UNCOND,DL660
*
DL640  LR    R4,R4         NOT LATACP, LDELMN
DL650  ST    R4,DLMPTR     SET UP 'DLMPTR'
*    BYTE0=0  AS REQUIRED FOR DSTART
DL660  ST    R3,DSTART     SET DSTART=VALID ENTRY DICT. POINTER
       LM    R4,R11,DL4
       L     R14,D1SV14    MUST PRECECE LOAD OF REG12
       L     R12,D1SV12    REG15 VALUE OKAY
       SR    R15,R15       NOW SET REG15 =RETURN VALUE
       BCR   UNCOND,R14
*
*    ERROR EXIT  SET UP REG15
DXEXIT ST    R14,D1SVEM    SAVE ERROR CODE, CANNOT SET REG15 YET
       LM    R4,R11,DL4
       L     R14,D1SV14    MUST PRECEDE LOAD OF REG12
       L     R12,D1SV12    REG15 VALUE OKAY
       L     R15,D1SVEM    LOAD REG15 WITH ERROR CODE VALUE
       BCR   UNCOND,R14
*
*    LATRPT ENTRY, SET REG2=A(ATTRIB)
*    USES R2, R11
DL700  ST    R11,DL4
       L     R2,0(R1)
       N     R2,DMBYT1
       ST    R2,DSTART      SET DSTART= ENTRY POINTER
       L     R15,DLDINC
       BALR  R14,R15
       L     R15,DL15       LOCATE ENTRY, OUTPUT  R2= DICT ADDRESS
       TM    0(R2),DMPFXT
         BC    ZERO,DL720
       LA    R2,3(R2)
         BC    MIXED,DL720
       LA    R2,3(R2)
DL720  SR    R11,R11
       ST    R11,DLMPTR     SET DLMPTR =0
       IC    R11,0(R2)       SET R11= NAME CNT
       LA    R2,1(R2,R11)
*   DUMP OF REGISTERS ONLY  CODE =2
       L     R11,DL4
       L     R14,D1SV14    MUST PRECEDE LOAD OF REG12
       L     R12,D1SV12    REG15 VALUE OKAY
       BCR   UNCOND,R14
*
*
D1RG12   DC    A(PBEG12)
*    D1SVEM  UNDER REG15  USED TO HOLD ERROR CODES  REG15 IS BOTH
*    BASE REG. AND ERROR CODE REG.  CANNOT LOAD IT UNTIL EXIT
D1SVEM   DS    F
D1SV12   DS    F
         EJECT
         AIF   ('&PHASE' EQ '3').PH3
*  ACCESS ROUTINES   ENTNAM,ENTPTR,GETPTR    R2 PREFIX
*
*
         DS    0F
       USING *,R15
DEBEG    EQU   *
ENTNAM   EQU   DEBEG
ENTPTR   EQU   DEBEG
GETPTR   EQU   DEBEG
*    REG. 0,1  WILL NOT BE SAVED
*    MODIFY LATER  REG. 2,12 DO NOT HAVE TO BE SAVED
*
       ST    R12,D3SV12
       L     R12,D3RG12
       STM   R14,R15,D3SV14
       STM   R2,R11,DRSAVE
       SR    R11,R11
       SR    R7,R7
       TM    0(R1),DMEPTR
         BC    ONES,DE500     BRANCH IF ENTPTR ENTRY
*
*  SET UP GROUP CODE, HASH CODE
DE100  L     R9,0(R1)       R9=A(BCD NAME)  SET UP FOR DHASH
       IC    R11,0(R9)     R11=NAME CNT
       L     R15,DLDHSH    *HASH NAME
       BALR  R14,R15
       L     R15,DS15      OUTPUT  R8= (0, DUP. POINTER)
       LR    R3,R8
       SR    R4,R4
       TM    0(R1),DMGRUP
         BC    ZERO,DE110
       L     R8,DLGCOD     *GROUP ITEM
       LA    R4,3(R0,R0)     SET CNT=3
DE110  LTR   R3,R3         TEST IF DUP HASH POINTER
         BC    ZERO,DE200
       L     R8,DLHSCD     *LOAD ADDR OF HASH CODE
       LA    R7,3(R0,R0)     SET CNT=3
       O     R3,DMPFX2      INSERT PREFIX 2
       LTR   R4,R4
         BC    ZERO,DE120
       O     R3,DMPFX3      GROUP CODE, INSERT PREFIX 3
DE120  ST    R3,DHWORD
*
*  COMPUTE TOTAL ENTRY SIZE, TEST IF SUFFIC. SPACE IN CURRENT SECTION
DE200  AR    R4,R7          R4= CODE CNT
       IC    R7,4(R1)       SET R7= ATTRIB CNT
       LA    R6,1(R11,R7)
       AR    R6,R4         R6= ENTRY SIZE
       L     R2,DPARST              LOAD A(COS)
       L     R2,DICADR-COS(R2)
*****
       ST    R4,DSTOR1       2/18/66
       L     R4,DPARST
       L     R3,ACCESW-COS(R4)         HOLD DISP
       LA    R3,0(R3)                INTO HASH TABLE
       SR    R10,R3                    IN REG. 10
*****
*****
       LR    R3,R2
       AR    R3,R6
       SR    R5,R5          R5=0 THROUGHOUT PROGRAM
       C     R3,DLSVAL-COS(R4)
         BC    LO,DE205
       BC    HI,DEMORG             RESTORE R4 BEFORE GO TO DEMORE
*DEL
DEMORG L     R4,DSTOR1       2/18/66
       BC    15,DEMORE             GO TO DEMORE.
*     WHEN ENTRY DOES NOT FILL SEGMENT, STORE ZERO IN 1ST BYTE AFTER
*     ENTRY.   IF THIS TURNS OUT TO BE LAST ENTRY IN SEGMENT, BYTE=O
*     IN NEXT BYTE INDICATES THIS TO LOCNXT.
DE205  STC   R5,0(R3)
DE210  L     R4,DPARST
       ST    R3,DICADR-COS(R4)
       L     R3,ACCESW-COS(R4)         GET ADDRESS OF ENTRY
       LA    R3,0(R3)                IN THE HASH TABLE
       AR    R10,R3                    INTO REG. 10
*   UPDATED DICADR AT RETURN FROM DEMORE
*  STORE HASH TABLE POINTER,CODE,IF ANY,IN DICT.
       MVC   0(3,R10),DCPTR-COS(R4)
       L     R4,DSTOR1       2/18/66
*     SET PREFIX =0.  INDICATOR FOR ENTPTR IN CASE NO CODE IN ENTRY
*     AND BCD NAME CAN BE STORED IMMEDIATELY.
       STC   R5,0(R2)
       LTR   R4,R4
         BC    ZERO,DE250
       BCTR  R4,R0           CODE, SUBT 1
       EX    R4,DMVCOD      STORE CODE IN DICT
       LA    R2,1(R4,R2)    UPDATE DICT REF
DE250  TM    0(R1),DMGPTR
         BC    ONES,DE400     BRANCH IF GETPTR ENTRY
*
*  STORE ENTRY IN DICTIONARY
DE300  EX    R11,DMOVE     STORE NAME
       LA    R2,1(R2,R11)  UPDATE DICT REFERENCE
       BCTR  R7,R0           SUBT 1
       L     R9,4(R1)       R9=A(ATTRIB)
       EX    R7,DMOVE       STORE ATTRIB
*
*  ENTNAM, GETPTR   UPDATE DICPTR
DE400  L     R1,DPARST      LOAD  A(COS)
       L     R1,DICPTR                 OUTPUT FOR GETPTR
*****
*****
       LR    R4,R1
       LR    R11,R1
       N     R4,DMDSPL      R4=DISPLAC.
       AR    R4,R6
       N     R4,DMDSPL     MASK OUT POSSIBLE OFLO FOR 512 DISPL  1/66
       N     R11,DMSECT    R11=SECT NO
       ALR   R4,R11
       L     R2,DPARST             LOAD A(COS)
       ST    R4,DICPTR-COS(R2)
*    REG 1 IS NOT SAVED, OUTPUT FOR GETPTR
DEXIT  LM    R2,R11,DRSAVE
*
       L     R14,D3SV14    MUST PRECEDE LOAD OF REG12
       L     R12,D3SV12
       BCR   UNCOND,R14
*
*
*  ENTPTR ENTRY
DE500  L     R2,8(R1)      LOAD INPUT DICT POINTER
       L     R15,DLDINC     MAKE SURE ENTRY IS IN CORE
       BALR  R14,R15        SETS R2= DICT. ADDR.
       L     R15,DS15      *
*  TEST IF CODE FOR ENTRY IN DICT.
       TM    0(R2),DMPFXT   TEST ENTRY PREFIX
         BC    ZERO,DE520     ZERO IF NO CODE
         BC    MIXED,DE510
       LA    R2,3(R2)      DOUBLE CODE, ADD 3 TO DICT REFER.
DE510  LA    R2,3(R2)      SINGLE CODE
DE520  IC    R7,4(R1)       ATTRIB. CNT
       L     R9,0(R1)       A(BCD NAME)
       IC    R11,0(R9)     NAME CNT
*  STORE ENTRY IN DICT.
       EX    R11,DMOVE     STORE NAME
       LA    R2,1(R2,R11)   UPDATE DICT REF
       BCTR  R7,R0
       L     R9,4(R1)       A(ATTRIB)
       EX    R7,DMOVE       STORE ATTRIB
*    REG 1 IS NOT RESTORED
       LM    R2,R11,DRSAVE
       L     R14,D3SV14    MUST PRECEDE LOAD OF REG12
       L     R12,D3SV12
       BR    R14
*
*
D3RG12   DC    A(PBEG12)
D3SV12   DS    F
*
         EJECT
       SPACE 5
******                                                           ******
*                                                                     *
*                           ** DEMORE **                              *
*                                                                     *
*                                                                     *
*      DEMORE--- AN INTERNAL ACCESS SUBROUTINE TO OBTAIN 512          *
*                BYTES OF CORE FOR A DICTIONARY SECTION.              *
*                DEMORE CALLS DICSPC IN TAMER TO OBTAIN A             *
*                NEW SECTION.                                         *
*                                                                     *
*      ENTRY REGISTERS--- R6 = ENTRY SIZE.                            *
*      EXIT  REGISTERS--- R2 = ADDRESS OF NEW SECTION.                *
*                         R3 = UPDATED DICADR,                        *
*                            = A(NEW SECTION) + ENTRY SIZE.           *
*                                                                     *
*      DEMORE--- UPDATES DICPTR,DLSVAL,AND DICOT TABLE.               *
*            --- ENTERS A(NEW SECTION) IN DICOT TABLE.                *
*                                                                     *
******                                                           ******
       SPACE 5
       DS    0F
DEMORE EQU   *
       ST    R1,DSTORE
       ST    R4,DSTOR1             STORE REGISTERS USED.
       SPACE 2
*      DEMORE CALLS DICSPC IN TAMER TO OBTAIN A NEW DICTIONARY SECTION.
       STM   R14,R15,D33S14        STORE 14,15.
       LA    R14,DEMRTA
       L     R15,DTAMM1            LOAD A(DICSPC),STORED BY INTACC.
       BALR  R14,R15               CALL DICSPC.
DEMRTA LM    R14,R15,D33S14
       SPACE 2
***                                                                 ***
*                                                                     *
*      REG1 =START ADDRESS OF NEW DICTIONARY SECTION.                 *
*      REG2 =HIGH ADDRESS =(START+512) OF NEW DICTIONARY SECTION.     *
*                                                                     *
***                                                                 ***
       SPACE 2
       L     R4,DPARST             LOAD A(COS).
       ST    R2,DLSVAL-COS(R4)         TOP ADDRESS OF SECTION
       ST    R1,DICADR-COS(R4)
       SPACE 2
       L     R1,DPARST             LOAD A(COS).
       LA    R1,LDICOT(R1)         LOAD A(DICOT TIB)= A(TIB20).
       L     R15,LINSRT            LOAD A(INSERT)
       BALR  R14,R15               CALL INSERT.
       L     R15,DS15              RESTORE BASE.
*                                  INSERT OUTPUT--REG2 = A(INSERT ENT).
*                                                 REG3 = TABLE DISPL.
       L     R4,DPARST
       L     R4,DICADR-COS(R4)
       ST    R4,0(R2)              STORE SECTION ADDRESS IN DICOT TABLE
       NI    0(R2),0               CLEAR TOP BYTE OF DICOT ENTRY.
       OI    0(R2),64              SET ON IN-CORE BIT.
       LR    R2,R4                 LOAD SECT. ADD. INTO R2.
       SPACE 2
****** ACCESS TEMPORARY STORAGE OF NEW SECTION NUMBER IN DICPTR.
****** SEE DE200. STORE NEWLY ASSIGNED SEC.NO. BEFORE RETURN TO DE210.
       SPACE 2
       ST    R4,DTSAVE
       L     R4,DPARST             LOAD A(COS).
       L     R3,DICPTR-COS(R4)
*
*      NOTE- FIRST SECTION NUMBER ASSIGNED IS 1.
*            DINCOR SUBTRACTS 1 TO OBTAIN CORRECT DICOT TABLE DISPL.
*
       N     R3,DMSECT             MASK OUT ALL BUT SECT.NUMBER.
       LA    R3,512(R3)            INCREMENT SECTION NUMBER.
       ST    R3,DICPTR-COS(R4)
******
****** END OF DICPTR STORAGE CODING. NEW SECTION DISPLACEMENT IS ZERO.
       SPACE 2
       L     R4,DTSAVE             RESTORE R4.
       LA    R3,0(R2,R6)           LOAD UPDATED DICT.ADDR. INTO R3.
*                                  R2 = ADDRESS OF NEW SECTION.
*                                  R6 =  ENTRY SIZE,FROM DE200 SEQUENCE
       L     R4,DSTOR1
       L     R1,DSTORE
       BC    15,DE210              RETURN TO DE210 WITH NEW DICADR.
       SPACE 2
**     NOTE- DEMORE IS NOT CALLED BY A BALR 14,15  SEQUENCE.
**           IT IS CALLED BY A DIRECT BRANCH FROM DEMORG+4.
**           ITS BASE REGISTER IS THUS THE BASE OF THE CALLING
**           ROUTINE. ITS DATA BASE REGISTER IS THAT OF CALLING ROUTINE
**           DEMORE USES ONLY REGISTERS 2 AND 4 INTERNALLY.
**           IT SAVES AND RESTORES THESE.
       EJECT
         EJECT
*    ACCESS ROUTINE 'ENTDEL'
*       SEPARATE ENTRY POINT
*       STORES DELIMITER IN DICT ENTRY FOR INPUT GROUP NAME
*       INPUT   REG1=A(INPUT DATA)
*
         DS    0F
ENTDEL   EQU   *
       USING *,R15
       ST    R12,D4SV12
       L     R12,D4RG12    REG12 IS USED TO REFER. CONSTANTS ETC
       STM   R14,R15,D4SV14
       ST    R2,DWORK
       L     R2,0(R1)
       L     R15,DLDINC
       BALR  R14,R15
       L     R15,D4SV15
       TM    0(R2),DMPFT1
         BC    ZERO,DENT1
       LA    R2,3(R2)       UPDATE PAST HASH CODE
*     DEBUG CODING  MAKE SURE GROUP CODE IS PRESENT
DENT1    EQU   *
       NC    0(3,R2),DMDLM ZERO OUT DELIM PART OF GRP CODE.  11/23
*        THIS CLEARS DELIM PART IN CASE OF PREVIOUS DUMMY DELIM NTRY.
       OC    0(3,R2),5(R1)  INSERT DELIMITER INTO ENTRY
       L     R2,DWORK
       L     R14,D4SV14     PRECEDES LOAD OF REG13
       L     R12,D4SV12
       BCR   UNCOND,R14
*
D4RG12   DC    A(PBEG12)
D4SV12   DS    F
*
       EJECT
       SPACE 5
         AGO   .EXIT
.PH3     ANOP
*     SUBROUTINE  'LOCNXT'
*       GIVEN A DICT POINTER, RETURNS DICT POINTER OF NEXT ENTRY
*       INPUT  REG1= INPUT DICT POINTER
*       OUTPUT  REG1= DICT POINTER OF NEXT ENTRY
*               REG2= STARTING ADDR OF ITS ATTRIB
*               REG3= STARTING ADDR OF ITS NAME CNT
*               R0=A(SEGMENT START)  OUTPUT FROM DINCOR
*    IF THE BYTE FOLLOWING THE CURRENT ENTRY =0, THEN THE NEXT ENTRY
*    IS IN THE NEXT SEGMENT  (SEE DE200)
*
*
         DS    0F
       USING LOCNXT,R15
LOCNXT   EQU   *
       ST    R12,D2SV12
       L     R12,D2RG12
       STM   R14,R15,D2SV14
       ST    R4,DL4
*     LOCATE ENTRY IN DICT
       LR    R2,R1
       L     R15,DLDINC
       BALR  R14,R15
       L     R15,D2SV15
       ST    R2,DWORK      SAVE A(ENTRY START)
***
***    CAREFUL  DO NOT USE R0 AS A WORK REGISTER UNTIL AFTER DT210
***
       A     R0,D512     SET R0 TO SEGMENT START + 512
*     COMPUTE LOC OF END OF ENTRY
       TM    0(R2),DMPFXT
         BC    ZERO,DT100     UPDATE PAST ANY CODE
       LA    R2,3(R2)
         BC    MIXED,DT100
       LA    R2,3(R2)
DT100  SR    R4,R4
       IC    R4,0(R2)     SET R4=NAME CNT
       LA    R2,1(R4,R2)   SET R2=A(ATTRIB)
*
*     ATTRIB CNT IN 1ST 4 BITS OF 1ST BYTE UNLESS REPORT OR CONDITION
*    NAME ATTRIBUTES
*    THEN 1ST 4 BITS=0 AND BYTE NO. 6= CNT OF VARIABLE PART OF
*    ATTRIBUTES AND DOES NOT INCLUDE ITSELF
*    (IE TOTAL NO OF ATTRIB. BYTES = N+7)
       IC    R4,0(R2)
       TM    0(R2),DMATRB
         BC    NOTZER,DT200
         TM    0(R2),CNDNM             IS IT CONDITION NAME
         BO    ENTCND                  YES
         LA    R2,1(R2)                ADD 1 FOR REPORT
ENTCND   LA    R2,6(R2)
       IC    R4,0(R2)
       LA    R2,1(R2,R4) ADD 1, CNT DOES NOT INCL ITSELF
         BC    UNCOND,DT210
DT200    CLI   0(R2),X'9A'
         BE    DT250                   YES
         CLI   0(R2),X'98'             RANDOM PROCESSING
         BNE   DT260                   NO
DT250    SR    R4,R4                   YES GET COUNT
         IC    R4,8(R2)
       A     R4,FDCNT                  ADD FIXED COUNT
DT260    SRL   R4,4
       LA    R2,0(R2,R4)      CNT DOES NOT INCL ITSELF
*
*     NOW REG2= A(1ST BYTE AFTER ENTRY)
DT210  CR    R2,R0         R0= END OF SEGMENT + 1
         BC    EQ,DT300      BRANCH IF NO SPACE LEFT IN CURRENT SECTION
       TM    0(R2),DMBYT   NEXT BYTE=O MEANS NO ENTRY FOLLOWS
         BC    NOTZER,DT400
*
*     NEXT ENTRY IN NEXT SEGMENT, COMPUTE DICT POINTER
DT300  N     R1,DMSECT     MASK OUT ALL BUT SECT NO
       LA    R1,512(R1)   INCR. SECT. NO.
       LR    R2,R1
       L     R15,DLDINC     COMPUTE CORRES. DICT ADDR= R2
       BALR  R14,R15
       L     R15,D2SV15
         BC    UNCOND,DT500
*
*     NEXT ENTRY IN SAME SEGMENT, COMPUTE DICT POINTER
DT400  LR    R3,R2        COMPUTE R3= INPUT ENTRY SIZE
       S     R3,DWORK      DWORK=A(ENTRY START)
       AR    R1,R3
*
*     COMPUTE A(BCD NAME), A(ATTRIB) OF NEXT ENTRY
DT500  TM    0(R2),DMPFXT
         BC    ZERO,DT550
       LA    R2,3(R2)
         BC    MIXED,DT550
       LA    R2,3(R2)
DT550  LR    R3,R2        SET R3= A(NAME)
       IC    R4,0(R2)
       LA    R2,1(R2,R4)      SET R2=A(ATTRIB)
*
       L     R4,DL4
*    REG13 IS NEVER USED, NO NEED TO SAVE IT
       L     R14,D2SV14    PRECEDE LOAD OF REG12
       L     R12,D2SV12
       BCR   UNCOND,R14
*
D2RG12   DC    A(PBEG12)
D2SV12   DS    F
CNDNM    EQU   X'08'
*
       EJECT
.EXIT    ANOP
         MEND
