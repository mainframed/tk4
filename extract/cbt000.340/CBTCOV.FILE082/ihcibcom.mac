         MACRO
         IHCIBCOM
         GBLA  &ERR
         AIF   (&ERR EQ 0).IBCNO
         TITLE     'IHCECOMH' - OPERATING SYSTEM 360   FORTRAN H
IHCECOMH START 0
         AGO   .IBC001
.IBCNO   ANOP
         TITLE     'IHCFCOMH' - OPERATING SYSTEM 360   FORTRAN H
IHCFCOMH START 0
.IBC001  ANOP
*C406500                                                         MAINT
*D791000                                                         MAINT
*D854350                                                         A29323
*A854330-854360                                                  A29323
*A617020-617060                                                  A34162
*A835750,835930,854030-854060                                    A37107
*C854150                                                         A37107
*A198700                                                         A45027
*C288500                                                         A45029
*A288200-288800,828200                                           A45029
*D533500                                                         A49560
*A533200-533600,534570-534920                                    A49560
*C867700                                                         A52394
*A832800,837700,867440-867460,867550,870560                       61497
*C868000                                                          61497
*A835530-835550,835946-835952                                     60647
*C835520-835540                                                   60647
*D852000-852500                                                   59714
         ENTRY     IBCOM#
         ENTRY     FDIOCS#
         EXTRN     ADCON#
         EXTRN     FIOCS#
         EXTRN ARITH#                                              HWRE
         EXTRN ADJSWTCH                                            HWRE
         EXTRN IHCUOPT                                             BNDR
         ENTRY INTSWTCH                                            HWRE
* THESE EXTERNAL REFERENCES ARE A TEMPORARY EXPEDIENT TO MAINTAIN
* COMPATIBILITY WITH FORTRAN E'S DUMP/PDUMP SUBROUTINE.
         EXTRN     FCVEOUTP
         EXTRN     FCVLOUTP
         EXTRN     FCVIOUTP
         EXTRN     FCVCOUTP
         EXTRN     FCVAOUTP
         EXTRN     FCVZOUTP
*
*  STATUS  --  CHANGE LEVEL 9  --  1 AUGUST 1974  --  RELEASE 21.8
*
* FUNCTION/OPERATION--IHCFCOMH, A MEMBER OF THE FORTRAN SYSTEM LIBRARY,
*    PERFORMS OBJECT-TIME IMPLEMENTATION OF THE FOLLOWING FORTRAN
*    I/O SOURCE STATEMENTS.
*       1. READ AND WRITE (BOTH FORMATTED AND NON-FORMATTED)
*       2. BACKSPACE, REWIND, AND ENDFILE (DEVICE MANIPULATION)
*       3. STOP AND PAUSE (WRITE TO OPERATOR)
*    IN ADDITION, IHCFCOMH PROCESSES OBJECT-TIME ERRORS DETECTED
*    BY THE VARIOUS FORTRAN LIBRARY SUBPROGRAMS, PROCESSES
*    ARITHMETIC-TYPE PROGRAM INTERRUPTS, AND TERMINATES LOAD MODULE
*    EXECUTION.
*
* ENTRY POINTS--
*
*    1. IBCOM# IS THE INITIAL LOCATION IN A TRANSFER VECTOR.
*       LINKAGE TO ROUTINES WITHIN IHCFCOMH IS ACCOMPLISHED BY
*                       L   15,=V(IBCOM#)
*                       BAL 14,D(15)
*       WHERE 'D' VARIES ACCORDING TO THE ROUTINE DESIRED.
*
*       ROUTINE   'D'   FUNCTION
*       .......   ...   ..............................................
*       FRDWF      0    OPENING SECTION, FORMATTED READ
*       FWRWF      4    OPENING SECTION, FORMATTED WRITE
*       FIOLF      8    I/O LIST SECTION, FORMATTED LIST VARIABLE
*       FIOAF     12    I/O LIST SECTION, FORMATTED LIST ARRAY
*       FENDF     16    CLOSING SECTION, FORMATTED READ OR WRITE
*       FRDNF     20    OPENING SECTION, NON-FORMATTED READ
*       FWRNF     24    OPENING SECTION, NON-FORMATTED WRITE
*       FIOLN     28    I/O LIST SECTION, NON-FORMATTED LIST VARIABLE
*       FIOAN     32    I/O LIST SECTION, NON-FORMATTED LIST ARRAY
*       FENDN     36    CLOSING SECTION, NON-FORMATTED READ OR WRITE
*       FBKSP     40    IMPLEMENTS THE BACKSPACE SOURCE STATEMENT
*       FRWND     44    IMPLEMENTS THE REWIND SOURCE STATEMENT
*       FEOFM     48    IMPLEMENTS THE ENDFILE SOURCE STATEMENT
*       FSTOP     52    WRITE TO OPERATOR, TERMINATE JOB
*       FPAUS     56    WRITE TO OPERATOR, RESUME EXECUTION
*       IBFERR    60    EXECUTION ERROR MONITOR
*       IBFINT    64    INTERRUPT PROCESSOR
*       IBEXIT    68    JOB TERMINATOR
*       EXCEPT   106    I/O EXCEPTION
*       FERROR   110    I/O ERROR
*
*       THE COMPLETE CALLING SEQUENCE FOR EACH OF THE ABOVE
*       ROUTINES IS GIVEN IN THE BODY OF THE LISTING.
*
*    2. FDIOCS# IS A 4-BYTE LOCATION INITIALIZED TO THE ADDRESS
*       OF IHCDIOSH, WHEN DIRECT ACCESS I/O STATEMENTS ARE
*       USED IN A FORTRAN PROGRAM.
*
* INPUT--INPUT CONSISTS OF PARAMETERS PASSED IN THE CALLING SEQUENCES
*    GENERATED BY THE FORTRAN COMPILER, AND DATA READ FROM USER-
*    DEFINED INPUT SOURCES.
*
* OUTPUT--OUTPUT CONSISTS OF DATA RECORDS AND ERROR MESSAGES.
*
* EXTERNAL ROUTINES--
*    1. IHCFCVTH, THE INPUT/OUTPUT DATA CONVERSION PACKAGE.
*    2. IHCFIOSH, THE SEQUENTIAL I/O INTERFACE WITH DATA MANAGEMENT.
*    3. IHCDIOSH, THE RANDOM ACCESS I/O INTERFACE WITH DATA MANAGEMENT
*    4. IHCFINTH, THE PROGRAM INTERRUPTION EXIT ROUTINE
*
* EXITS--
*    NORMAL--RETURN IS TO THE CALLING ROUTINE VIA REGISTER 14,
*    UNLESS THE SOURCE STATEMENT BEING IMPLEMENTED IS A STOP,
*    IN WHICH CASE RETURN IS TO THE SUPERVISOR.
*    ERROR--IN CASE OF AN OBJECT-TIME ERROR, A MESSAGE IS WRITTEN
*    ON THE MESSAGE OUTPUT UNIT, EXECUTION IS TERMINATED, AND RETURN
*    IS TO THE SUPERVISOR WITH A CODE OF 16 DECIMAL.
*
* TABLES/WORK AREAS--
*    'TABLE' - A BRANCH TABLE CORRESPONDING TO FORMAT CODES
*              GENERATED BY THE FORTRAN COMPILER.
*    'BRTAB' - A BRANCH TABLE CORRESPONDING TO THE CHARACTERS
*              ENCOUNTERED IN THE OBJECT-TIME FORMAT SCAN.
*    'TRTSTB' - A 256 BYTE TRANSLATE-AND-TEST TABLE USED IN
*               THE OBJECT-TIME FORMAT SCAN.
*    'SAVE' - REGISTER STORAGE AREA
*
* ATTRIBUTES--THIS MODULE IS NOT REENTRANT, BUT IS SERIALLY REUSABLE.
*
* NOTES--
*    1. ALL CALLING SEQUENCES TO IHCFCOMH ARE NON-STANDARD.
*    2. IHCFCOMH USES ITS OWN INTERNAL REGISTER SAVE AREAS,
*       RATHER THAN STORING REGISTERS IN THE CALLING PROGRAM.
*    3. ROUTINES FSTOP AND FPAUS USE A HAND-CODED WTO/WTOR MACRO.
*    4. ROUTINE FPAUS ISSUES A SYSTEM WAIT FOLLOWING EXECUTION
*       OF THE WTOR.
*    5. ROUTINE IBFINT ISSUES A SYSTEM SPIE TO INITIALIZE THE
*       PROCESSING OF ARITHMETIC-TYPE PROGRAM INTERRUPTS.
*    6. ROUTINE IBEXIT ISSUES A SYSTEM SPIE TO CANCEL THE FORTRAN SPIE
*       AND RESTORE THE PREVIOUS SPIE IF ANY.
         EJECT
* REGISTER DEFINITIONS
S        EQU       13                  SAVE AREA POINTER
R        EQU       14                  RETURN REGISTER
L        EQU       15                  LINKAGE REGISTER
GRX      EQU       2                   FIRST ARGUMENT
GRY      EQU       3                   SECOND ARGUMENT
SPILL    EQU       4                   UTILITY REGISTER
BASE     EQU       5                   BASE REGISTER
CALLER   EQU       6                   CALLING REGISTER
BYTER    EQU       7                   ONE BYTE ONLY
BUFLIM   EQU       8                   END OF RECORD
BUFPTR   EQU       9                   LOCATION IN RECORD
FMTPTR   EQU       10                  LOCATION IN FORMAT
ADDER    EQU       11                  ARRAY INCREMENT
LOOP     EQU       12                  LOOP CONTROL
PARLEV   EQU       13                  PARENTHESIS LEVEL
PARCNT   EQU       3                   PARENTHESIS COUNTER
DIGINT   EQU       4                   DIGIT COLLECTOR
RECCNT   EQU       5                   RECORD COUNTER
BUFLOC   EQU       10                  START OF RECORD
RECNUM   EQU       4                   BACKSPACE COUNTER
R256     EQU   4                         USED TO COMPUTE CORRECT    174
B        EQU   6                         SIZE OF MOVE OPERATION     174
BTM      EQU   11                      BYTES LEFT IN ARRAY          174
BTG      EQU   12                      BYTES LEFT IN BUFFER         174
         SPACE     3
* BRANCHING CONDITIONS
ALWAYS   EQU       15                  UNCONDITIONAL
HIGH     EQU       2                   HIGH
LOW      EQU       4                   LOW
EQUAL    EQU       8                   EQUAL
NOTEQ    EQU       7                   NOT EQUAL
NOTZER   EQU   7                       NOT ZERO                   22019
HIEQ     EQU       10                  HIGH OR EQUAL
LOEQ     EQU       12                  LOW OR EQUAL
PLUS     EQU       2                   PLUS
ZMINUS   EQU       12                  ZERO OR MINUS
ALL      EQU       1                   ALL BITS ON
ANY      EQU       4                   ANY BITS ON
NONE     EQU       8                   NO BITS ON
ANYALL   EQU       5                   ANY OR ALL BITS ON
         SPACE     3
* MISCELLANEOUS CODES
FMTINP   EQU       X'F0'               FORMATTED INPUT
FMTOUT   EQU       X'FF'               FORMATTED OUTPUT
NONINP   EQU       X'00'               NON-FORMATTED INPUT
NONOUT   EQU       X'0F'               NON-FORMATTED OUTPUT
INIT     EQU       X'00'               INITIALIZATION OPERATION
READ     EQU       X'01'               READ OPERATION
RITE     EQU       X'02'               WRITE OPERATION
CTRL     EQU       X'03'               CONTROL OPERATION
TERM     EQU       X'04'               TERMINATION OPERATION
NULL     EQU       X'00'               NULL QUALIFIER
BKSP     EQU       X'00'               BACKSPACE QUALIFIER
RWND     EQU       X'01'               REWIND QUALIFIER
EOFM     EQU       X'02'               WRITE EOF QUALIFIER
FORMAT   EQU       X'F0'               FORMAT QUALIFIER
OUTPUT   EQU       X'0F'               OUTPUT QUALIFIER
ON       EQU       X'FF'               ON CONDITION
OFF      EQU       X'00'               OFF CONDITION
HALF     EQU       X'0F'               HALF-ON CONDITION
LNK      EQU   14
BITS     EQU   3
CCHAR    EQU   X'80'
VDSRN    EQU   X'01'                   BIT IN CALLING SEQ.INDICATING
*                                      VARIABLE DSRN
         EJECT
*
* IBCOM TRANSFER VECTOR
*
IBCOM#   EQU       *
         USING     *,L
         BC        ALWAYS,FRDWF        MAIN ENTRY, FORMATTED READ
         BC        ALWAYS,FWRWF        MAIN ENTRY, FORMATTED WRITE
         BC        ALWAYS,FIOLF        SECONDARY ENTRY, I/O LIST ITEM
         BC        ALWAYS,FIOAF        SECONDARY ENTRY, I/O LIST ARRAY
         BC        ALWAYS,FENDF        FINAL ENTRY, END OF I/O LIST
         BC        ALWAYS,FRDNF        MAIN ENTRY, NON-FORMATTED READ
         BC        ALWAYS,FWRNF        MAIN ENTRY, NON-FORMATTED WRITE
         BC        ALWAYS,FIOLN        SECONDARY ENTRY, I/O LIST ITEM
         BC        ALWAYS,FIOAN        SECONDARY ENTRY, I/O LIST ARRAY
         BC        ALWAYS,FENDN        FINAL ENTRY, END OF I/O LIST
         BC        ALWAYS,FBKSP        BACKSPACE TAPE
         BC        ALWAYS,FRWND        REWIND TAPE
         BC        ALWAYS,FEOFM        WRITE TAPE MARK
         BC        ALWAYS,FSTOP        STOP SUBROUTINE
         BC        ALWAYS,FPAUS        PAUSE SUBROUTINE
DSRN     DS    1F'0'                   AREA FOR FIOCS&DIOCS TO STORE
*                                      DATA SET REFERENCE NUMBER
         BC        ALWAYS,IBFINT       INTERRUPTION PROCESSOR
         BC        ALWAYS,IBEXIT       JOB TERMINATION
*
OVFIND   DC        X'00'               OVERFLOW/UNDERFLOW INDICATOR
DVCIND   DC        X'00'               DIVIDE-CHECK INDICATOR
*
         L         1,VFIOCS            I/O INTERFACE
         L         1,VFCVZO            HEXADECIMAL OUTPUT CONVERSION
         L         1,VFCVIO            INTEGER OUTPUT CONVERSION
         L         1,VFCVEO            REAL OUTPUT CONVERSION
         L         1,VFCVDO            DOUBLE OUTPUT CONVERSION
*
         L         1,VFCVLO            LOGICAL OUTPUT CONVERSION
         L         1,VFCVCO            COMPLEX OUTPUT CONVERSION
         L         1,VFCVAO            ALPHAMERIC OUTPUT CONVERSION
*
         DC    XL2'0000'               PADDING TO KEEP OFFSETS SAME
         AIF   (&ERR EQ 0).IB71
AD904    DC    A(ERR904)               ADDRESS OF RTN TO OUTPUT 904 MSG
         AGO   .IB70
.IB71    DC    A(IBEXIT)               ADDRESS OF IBEXIT
.IB70    ANOP
         DC    XL2'0000'               PADDING
*
         MVI       INTSW,ON            IGNORE INTERRUPTS
         MVI       INTSW,OFF           PROCESS INTERRUPTS
OVSWITCH DC    X'00'
*
         DS    0F
SAVE     DC    XL1'FF'                 MAIN REGISTER STORAGE AREA
         DC    AL3(0)                  WITH FIRST BYTE SET TO X'FF'
         DC    15F'0'                  THIS IS SET OFF(I.E.TO  A REPRE-
*                                      SENTATION OTHER THAN FF WHEN
*                                      IBCOM IS ENTERED(OR NAMELIST OR
*                                      ET AL) AND THEY STORE INTO SAVE.
*                                      IBCOM ET AL RESTORE THIS FF WHEN
*                                      THEY TERMINATE EXECUTION FOR A
*                                      COMPLETED FORTRAN STATEMENT.
*                                      THIS IS DONE SO THAT AN ATTEMPT
*                                      TO DO I/O DURING AN I/O FIXUP
*                                      ROUTINE CAN BE CAUGHT AS AN ERR.
*
FDIOCS#  DC    V(SEQDASD)              STORAGE FOR DIOCS# ENTRY LOC.
* NOTE - OFFSET OF X'C0' FOR MAINEP MUST BE MAINTAINED FOR IHCTRCH 4594
MAINEP   DS    F                    MAIN ROUTINE ENTRY POINT       4594
*                                                                  4594
ERRSAV   DC    A(EOFNIOR)              SAVE AREA FOR USE BY IBCOM,FIOCS
*                                      DIOCS ET AL AND THE MATH
*                                      ROUTINES. THE FIRST WORD OF THE
*                                      SAVE AREA HAS THE ADDRESS OF THE
*                                      IBCOM SUBROUTINE USED BY
*                                      NAMELIST TO GET THE END OF FILE
*                                      AND/OR THE I/O ERROR EXIT(S) FOR
*                                      LATER USE BY THE ERROR MONITOR
         DS    17F
ENDFILE  DS    1F'0'                   AREA IN WHICH ERROR MONITOR EX-
IOERROR  DS    1F'0'                   PECTS END OF FILE AND I/O ERROR
*                                      EXITS TO BE PLACED RESPECTIVELY
*                                      WHEN THESE ARE SPECIFIED AND THE
*                                      INDICATED ERROR OCCURS.
         AIF   (&ERR EQ 0).IB200
BUFPTRS  DC    2F'0'                   ADDRESS IN WHICH THE ERROR MON.
*                                      EXPECTS TO FIND THE BUFFER POINT
*                                      ER AND THE LENGTH OF THE BUFFER
*                                      WHEN IT IS NECESSARY TO PRINT
*                                      BUFFER CONTENTS ALONG WITH THE
*                                      ERROR MESSAGE.
.IB200   ANOP
         EJECT
* CALLING SEQUENCE
*
*        L         L,=V(IBCOM#)
*        CNOP      0,4
*        BAL       R,0(L)              FRDWF
*             OR
*        BAL       R,4(L)              FWRWF
*        DC        XL0.4'PI',XL0.4'UI',AL3(UNIT)
*        DC        AL1'FI',AL3(FORMAT)
*        DC        AL4(EOFADD)         OPTIONAL
*        DC        AL4(ERRADD)         OPTIONAL
*                  WHERE PI = X'0' IF NEITHER EOF NOR ERR,
*                             X'1' IF EOF ONLY,
*                             X'2' IF ERR ONLY,
*                             X'3' IF BOTH EOF AND ERR.
*                  UI = X'0' IF UNIT IS AN INTEGER CONSTANT,
*                       X'1' IF UNIT IS A VARIABLE NAME,
*                       X'4' IF UNIT IS A STANDARD SYSTEMS UNIT.
*                  FI = X'00' IF FORMAT IS A STATEMENT LABEL,
*                       X'01' IF FORMAT IS AN ARRAY NAME.
*
*        L         L,=V(IBCOM#)
*        BAL       R,8(L)              FIOLF
*        DC        XL1'L',XL0.4'T',XL0.4'X',XL0.4'B',XL1.4'D'
*                  WHERE LENGTH(L) = SIZE(IN BYTES) OF THE ITEM,
*                  TYPE(T) = LOGICAL/INTEGER/REAL/COMPLEX/LITERAL,
*                  AND X, B, D ARE THE INDEX, BASE, DISPLACEMENT
*                  WHICH SPECIFY THE ADDRESS OF THE ITEM.
*
*        L         L,=V(IBCOM#)
*        BAL       R,12(L)             FIOAF
*        DC        XL1'SPAN',AL3(ADDRESS)
*        DC        XL1'L',XL0.4'T',XL2.4'ELEMENTS'
*                  WHERE SPAN REFERS TO STRUCTURED ARRAYS,
*                  ADDRESS = BEGINNING LOCATION OF THE ARRAY,
*                  LENGTH(L) = SIZE(IN BYTES) OF EACH ITEM,
*                  TYPE(T) = LOGICAL/INTEGER/REAL/COMPLEX/LITERAL,
*                  ELEMENTS = NUMBER OF ITEMS IN THE ARRAY.
*
*        L         L,=V(IBCOM#)
*        BAL       R,16(L)             FENDF
*
         SPACE     3
* ERROR CONDITIONS
*        INVALID CHARACTER IN FORMAT STATEMENT.
*        ATTEMPT TO READ OR WRITE PAST END OF RECORD.
*        FOR OTHERS, SEE FIOCS ROUTINE.
         EJECT
*
FRDWF    MVI       IOSWF,FMTINP        SET FOR FORMATTED INPUT
         BC        ALWAYS,RWCOMF
*
FWRWF    MVI       IOSWF,FMTOUT        SET FOR FORMATTED OUTPUT
         SPACE     3
*
RWCOMF   EQU   *
         AIF   (&ERR EQ 0).IB60
         CLI   SAVE,ON                 THIS CODE CHECKS FOR ATTEMPT TO
         BNE   ERR904                  DO I/O DURING A FIXUP ROUTINE
*                                      FOR AN I/O TYPE ERROR
.IB60    ANOP
         STM   14,13,SAVE              SAVE REGISTERS
         LA    GRY,8                   ALLOW FOR UNIT AND FORMAT
         LA    13,IOCALL1              SET UP RETURN REGISTER
EOFNIOR  EQU   *
         AIF   (&ERR EQ 0).IB9
         ST    14,DSRNPTR              SAVE ADDRESS OF PARAMETERS
         MVI   SKPLIST,OFF             SET OFF SKIP I/O REQUEST SWITCH
.IB9     SR    1,1
         SR    GRX,GRX
         STM   1,GRX,ENDFILE           CLEAR OUT EXIT ADDRESSES
         L     1,VFIOCS                GET ADDRESS OF FIOCS
         LR        GRX,R               PICKUP PARAMETER POINTER
         MVC       UNITWD(8),0(R)      MOVE PARAMETERS
         TM    UNITWD,X'80'            DIRECT ACCESS?
         BZ    EOFIO1                  NO, BRANCH
         L     1,FDIOCS#               YES GET ADDRESS OF DIOCS INSTEAD
         LA    GRY,4(0,GRY)            ALLOW FOR RECORD NUMBER
EOFIO1   EQU   *
         TM    UNITWD,X'10'            END OF FILE EXIT SPECIFIED
         BZ    EOFIO2                  NO, BRANCH
         L     BASE,0(GRY,GRX)         GET END OF FILE EXIT ADDRESS(IND
         ST    BASE,ENDFILE            IRECT ADDRESS) AND SAVE IT FOR
         LA    GRY,4(0,GRY)            ERROR MONITOR. UPDATE GRY
EOFIO2   TM    UNITWD,X'20'            WAS AN I/O ERROR EXIT GIVEN
         BZ    EOFIO3                  NO, BRANCH
         L     BASE,0(GRY,GRX)         YES, GET EXIT ADDRESS GIVEN(IT
         ST    BASE,IOERROR            IS THE ADDRESS OF THE ADDRESS
         LA    GRY,4(0,GRY)            ACTUALLY, AS ABOVE).AND SAVE IT
EOFIO3   LA    LNK,0(GRX,GRY)          COMPUTE RETURN ADDRESS AND
         ST    LNK,SAVE                STORE IT INTO THE SAVE AREA
SEQWF    ST        1,DFIOCS            SET INTERFACE SELECTED
         BR    13                      RETURN
IOCALL1  LA    LNK,NRET                SET UP RETURN REGISTER
IOCALL   EQU   *
         BALR      0,1                 INITIALIZE FILE
         DC        AL1(INIT)
IOSWF    DC        AL1(0)
         B     SETSW                   IF SOME KIND OF ERROR BRANCH
         ST        GRX,BUFADD          SAVE START OF RECORD
         LA        BUFLIM,0(GRY,GRX)   COMPUTE END OF RECORD
         LR        BUFPTR,GRX          INITIALIZE RECORD POINTER
         BR    LNK                     RETURN
NRET     EQU   *
         SR        BYTER,BYTER         INITIALIZE BYTE REGISTER
         ST        BYTER,FMTSWS        CLEAR SWITCHES
         ST        BYTER,COUNTS           AND CLEAR COUNTS.
         ST    BYTER,BUFPTRHI          CLEAR HOLD FOR RCD PTR HIGH.6002
SETFMT   L         FMTPTR,FORMWD       SET POINTER TO START OF FORMAT
         TM        FORMWD,ON
         BC        ANYALL,FSCAN        BRANCH IF FORMAT IS VARIABLE
         BC        ALWAYS,SCAN
*
*
*
         AIF   (&ERR EQ 1).IB7
SETSW    BAL   14,68(0,L)              TERMINATE JOB VIA IBEXIT(THIS
         DC    AL2(16)                 CODE SHOULD NEVER BE ENTERED
         AGO   .IB8
.IB7     ANOP
SETSW    MVI   EFMTSW,ON               THIS LITTLE SUBROUTINE IS ENTRED
         LA    GRX,EXITF               AFTER AN ERROR OCCURS IN FIOCS
         LA    CALLER,0(CALLER)                                   45027
         CR    GRX,CALLER              OR DIOCS AND SETS ALL SWITCHES
         BCR   8,CALLER                OFF SO THAT WHEN ATTEMPT IS MADE
         MVI   SKPLIST,ON              TO RETURN TO THE USER VIA 'LIST'
         MVI   ARRSW,OFF               THE ATTEMPT WILL GO THRU. IF
         MVI   CTYPSW,OFF              ERROR OCCURS ON END CALL TO
         B     LIST                    IBCOM RETURN IS DIRECT TO EXITF
ERR904   L     BASE,VIBCOM2            SET UP BASE FOR CSECT TWO
         B     OFF904(0,BASE)          GO TO PUT OUT MESSAGE 904
.IB8     ANOP
         EJECT
*
SCAN     SR        BASE,BASE
         IC        BASE,0(0,FMTPTR)    SCAN OUT OPERATOR
         SLA       BASE,1
         CH        BASE,LIMIT
         BC        HIEQ,FMTERR         ERROR, NOT IN TABLE.
         BC        ALWAYS,TABLE(BASE)  BRANCH TO CORRESPONDING ROUTINE
*
TABLE    DS        0H
         BC        ALWAYS,VARFMT       00
         BC        ALWAYS,BEGINF       02
         BC        ALWAYS,GRPCNT       04
         BC        ALWAYS,FLDCNT       06
         BC        ALWAYS,PSCALE       08
         BC        ALWAYS,FCNVRT       0A
         BC        ALWAYS,ECNVRT       0C
         BC        ALWAYS,DCNVRT       0E
         BC        ALWAYS,ICNVRT       10
         BC        ALWAYS,COLUMN       12
         BC        ALWAYS,ACNVRT       14
         BC        ALWAYS,LCNVRT       16
         BC        ALWAYS,XCNVRT       18
         BC        ALWAYS,HCNVRT       1A
         BC        ALWAYS,GRPEND       1C
         BC        ALWAYS,SLASHR       1E
         BC        ALWAYS,GCNVRT       20
         BC        ALWAYS,ENDFMT       22
         BC        ALWAYS,ZCNVRT       24
LIMIT    DC        AL2(*-TABLE)
*
FMTERR   EQU   *
         AIF   (&ERR EQ 1).IB5
         LA    1,211                   GIVE MESSAGE 211
COMERRHN ST    1,ERRORNO               STORE ERROR NUMBER IN PARAMETER
         LA    1,ADERRNO               LIST AND PUT ADDRESS OF LIST IN
         L     13,SAVE+60              REG. 1.LINK SAVE AREAS TOGETHER
         MVC   12(16,13),SAVE          AND MOVE USER'S REGISTERS INTO
         ST    13,ERRSAV+4             HIS SAVE AREA
         LA    13,ERRSAV
         L     15,VIHCERRM             GOT TO THE 'ERROR MONITOR'
         BR    15
         AGO   .IB6
.IB5     ANOP
         L     3,PARMR211              GIVE MESSAGE 211
         MVC   MSG211M-PRAMS211(8,3),COMPILED-PRAMS211(3)  MOVE COMPILD
         MVI   FMTCHR-PRAMS211(3),X'40' INTO MESAGE .BLANK OUT CHAR.
         ST    FMTPTR,12(0,3)          STORE ADDR OF BAD CHAR. IN PARM.
         MVI   12(3),X'80'             LIST. RESET LAST PARM INDICATOR
         BAL   LNK,PRCMNTFC            GO TO OUTPUT MESSAGE
         B     STAND211                IF STANDARD FIXUP
         B     SCAN                    IF USER FIXED DATA
STAND211 EQU   *
         CH    PARLEV,TWO              IF NOT WITHIN SECOND LEVEL OF
         BL    ENDFMT                  PARENTHESES DONT MOVE POINTERS
         MVC   CURRENT(10),SECLEV      OTHERWISE THIS IS NECESSARY
         B     ENDFMT                  TO RESTART FROM PREVIOUS 1ST
*                                      LEVEL PARENTHESES
.IB6     ANOP
*
         EJECT
*
BEGINF   LA        FMTPTR,1(0,FMTPTR)  BUMP FORMAT POINTER
         SR        PARLEV,PARLEV       PARENTHESIS LEVEL = 0
SCAN1    ST        FMTPTR,LSTGRP       SAVE POINTER FOR REPEATS
         ST        PARLEV,NEWPAR       SAVE PARENTHESIS COUNT
         BC        ALWAYS,SCAN         CONTINUE FORMAT SCAN
*
GRPCNT   IC        BYTER,1(0,FMTPTR)
         LA        PARLEV,1(0,PARLEV)  BUMP PARENTHESIS LEVEL
         CH        PARLEV,TWO
         BC        LOW,SCAN3
         MVC       SAVPTR(4),LSTGRP    PARENTHESIS LEVEL GT ONE,
         MVC       SAVCNT(2),COUNTS       SAVE POSITION AND COUNTS.
         MVC       OLDPAR(4),NEWPAR
SCAN3    STC       BYTER,GCOUNT        SAVE GROUP COUNT
         STC       BYTER,GCSAVE
         LA        FMTPTR,2(0,FMTPTR)  BUMP FORMAT POINTER
         BC        ALWAYS,SCAN1
*
FLDCNT   MVC       FCOUNT(1),1(FMTPTR) SAVE FIELD COUNT
SCAN2    LA        FMTPTR,2(0,FMTPTR)  BUMP FORMAT POINTER
         BC        ALWAYS,SCAN         CONTINUE FORMAT SCAN
*
PSCALE   MVC       SCALEF(1),1(FMTPTR) SAVE SCALE FACTOR
         BC        ALWAYS,SCAN2
*
COLUMN   IC        BYTER,1(0,FMTPTR)   GET COLUMN POSITION
         BCTR      BYTER,0
         L         SPILL,BUFADD        ADD START OF RECORD
         AR        SPILL,BYTER            AND COLUMN POSITION.
         SR    SPILL,BUFLIM            COMPARE TO RECORD END
         BC    LOW,COL2                  IF MINUS(<0) OK
         BAL   BASE,ERROR              IF BIG OR EQUAL ERROR
         AR    SPILL,BUFPTR            ON RETURN SET UP TO CONTINUE
         B     COL3
COL2     AR    SPILL,BUFLIM            RESTORE REGISTER
COL3     EQU   *
         C     BUFPTR,BUFPTRHI         IS CURRENT RECORD POINTER   6002
         BC    LOEQ,COL4               HIGHER THAN PREVIOUS HIGH?  6002
         ST    BUFPTR,BUFPTRHI         IF SO, SAVE CURRENT PTR.    6002
COL4     LR    BUFPTR,SPILL            GET NEW RECORD POINTER.     6002
         BC        ALWAYS,SCAN2
*
XCNVRT   IC        BYTER,1(0,FMTPTR)   PICKUP N
         LA        FMTPTR,2(0,FMTPTR)  BUMP FORMAT POINTER
         TM        IOSWF,OUTPUT
         BC        ALL,XBLANK          BRANCH IF OUTPUT
         AR        BUFPTR,BYTER        BUMP RECORD POINTER BY N
         CR        BUFPTR,BUFLIM       COMPARE TO END OF RECORD
         BC        HIGH,ERROR          ERROR, SKIP PAST RECORD.
         BC        ALWAYS,SCAN         CONTINUE FORMAT SCAN
XBLANK   CR        BUFPTR,BUFLIM       COMPARE TO END OF RECORD
         BL    XBLANK1                 LOW, OK
         BAL   BASE,ERROR              HIGH ERROR
XBLANK1  EQU   *
         MVI       0(BUFPTR),C' '      MOVE IN BLANKS, ONE AT A TIME.
         LA        BUFPTR,1(0,BUFPTR)  BUMP RECORD POINTER
         BCT       BYTER,XBLANK
         BC        ALWAYS,SCAN         CONTINUE FORMAT SCAN
*
HCNVRT   IC        BYTER,1(0,FMTPTR)   PICKUP N
         LA        FMTPTR,2(0,FMTPTR)  BUMP FORMAT POINTER
HCNVRT1  EQU   *
         LR        SPILL,BUFLIM
         SR        SPILL,BUFPTR        SUBTRACT POINTER FROM RECORD END
         CR        BYTER,SPILL         ARE ENOUGH BYTES LEFT
         AIF   (&ERR EQ 0).IB40
         BNH   HCNVRT2                 YES, BRANCH
         TM    IOSWF,OUTPUT            NO, IS THIS OUTPUT
         BZ    ERROR                   NO, GO GIVE ERROR
         LTR   SPILL,SPILL             YES, ANY BYTES LEFT IN BUFFER?
         BZ    CALERR                  NO, BRANCH TO GIVE ERROR
         SR    BYTER,SPILL             YES, CALCULATE HOW MANY BYTES
         BCTR  SPILL,0                 NOT MOVED THIS TIME, THEN MOVE
         EX    SPILL,MOVE2             AS MUCH AS WE CAN INTO CURRENT
         LA    BUFPTR,1(SPILL,BUFPTR)  BUFFER. UPDATE BUFFER AND FORMAT
         LA    FMTPTR,1(SPILL,FMTPTR)  POINTERS.
CALERR   EQU   *
         BAL   BASE,ERROR              GIVE ERROR MESSAGE
         B     HCNVRT1                 GO CHECK IF ENOUGH ROOM IN BUFFE
HCNVRT2  EQU   *
         AGO   .IB41
.IB40    BC    HIGH,ERROR              NO, ERROR
.IB41    ANOP
         BCTR      BYTER,0             YES, PREPARE FOR EXECUTE.
         TM        IOSWF,OUTPUT
         BC        ALL,HCVOUT          BRANCH IF OUTPUT
         EX        BYTER,MOVE1         MOVE CHARACTERS INTO FORMAT
         BC        ALWAYS,HCVRET
HCVOUT   EX        BYTER,MOVE2         MOVE CHARACTERS FROM FORMAT
HCVRET   LA        BUFPTR,1(BYTER,BUFPTR) BUMP RECORD POINTER
         LA        FMTPTR,1(BYTER,FMTPTR) BUMP FORMAT POINTER
         BC        ALWAYS,SCAN         CONTINUE FORMAT SCAN
*
GRPEND   LA        FMTPTR,1(0,FMTPTR)  BUMP FORMAT POINTER
         TM        GCOUNT,X'FE'        IS THERE A GROUP COUNT
         BC        ANYALL,SCAN4        YES
         BCTR      PARLEV,0            NO, REDUCE PARENTHESIS LEVEL.
         CH        PARLEV,ONE
         BC        LOW,SCAN
         MVC       LSTGRP(4),SAVPTR    END OF SECOND PARENTHESIS LEVEL,
         MVC       COUNTS(2),SAVCNT       RESTORE POSITION AND COUNTS.
         MVC       NEWPAR(4),OLDPAR
         BC        ALWAYS,SCAN
SCAN4    L         FMTPTR,LSTGRP       RESET FORMAT POINTER
         L         PARLEV,NEWPAR       RESTORE PARENTHESIS COUNT
         IC        BYTER,GCOUNT
         BCTR      BYTER,0             REDUCE GROUP COUNT
         STC       BYTER,GCOUNT
         BC        ALWAYS,SCAN         CONTINUE FORMAT SCAN
*
SLASHR   EQU       *
         ST        CALLER,REG6         SAVE REGISTER CALLER       45029
         BAL       CALLER,RECORD       INPUT OR OUTPUT ONE RECORD 45029
         L         CALLER,REG6         RESTORE REGISTER CALLER    45029
         LA        FMTPTR,1(0,FMTPTR)  BUMP FORMAT POINTER
         BC        ALWAYS,SCAN         CONTINUE FORMAT SCAN
*
ENDFMT   MVI       EFMTSW,ON           SET END-FORMAT SWITCH ON,
         BC        ALWAYS,LIST            AND EXIT TO I/O LIST.
LSTRET   EQU   *
         AIF   (&ERR EQ 0).IB10
         TM    SKPLIST,ON              ARE WE TO IGNORE REST OF I/O
         BO    LIST                    REQUEST? YES, RETURN TO USER
.IB10    BAL   CALLER,RECORD           ELSE, INPUT OR OUPUT 1 RECORD
         MVC       GCOUNT(1),GCSAVE    RESET LAST GROUP COUNT
         L         FMTPTR,LSTGRP       RESET FORMAT POINTER
         L         PARLEV,NEWPAR       RESTORE PARENTHESIS COUNT
         BC        ALWAYS,SCAN         CONTINUE FORMAT SCAN
*
RECORD   STM       GRX,GRY,STASH       SAVE ARGUMENT REGISTERS
         TM        IOSWF,OUTPUT
         BC        ALL,RECOUT          BRANCH IF OUTPUT
         MVI       IOTYPF,READ         SET INDICATOR FOR READ
         BC        ALWAYS,RECCOM
RECOUT   MVI       IOTYPF,RITE         SET INDICATOR FOR WRITE
         LR        GRX,BUFPTR
         C     GRX,BUFPTRHI            IS CURRENT RECORD POINTER   6002
         BC    HIEQ,RECOUT1            LOWER THAN PREVIOUS HIGH?   6002
         L     GRX,BUFPTRHI            IF SO, USE PREVIOUS HIGH.   6002
RECOUT1  XC    BUFPTRHI(4),BUFPTRHI    CLEAR BUFPTRHI.             6002
RECSIZ   S         GRX,BUFADD          COMPUTE RECORD LENGTH
RECCOM   L         1,DFIOCS
         BALR      0,1                 READ OR WRITE ONE RECORD
IOTYPF   DC        AL1(0)
         DC        AL1(NULL)
         B     SETSW                   IF ERROR OCCURRED BRANCH
         ST        GRX,BUFADD          SAVE START OF RECORD
         LA        BUFLIM,0(GRY,GRX)   COMPUTE END OF RECORD
         LR        BUFPTR,GRX          INITIALIZE RECORD POINTER
         LM        GRX,GRY,STASH       RESTORE ARGUMENT REGISTERS,
         BCR       ALWAYS,CALLER          AND RETURN TO CALLER.
*
         EJECT
*
GCNVRT   MVI       GFMTSW,ON           SET G-FORMAT SWITCH ON
         MVC   PARMHOLD(1),2(FMTPTR)   SAVE DEC POSITIONS          2717
         MVC   PARMHOLD+1(1),SCALEF    SAVE SCALE FACTOR           2717
         BC    ALWAYS,PARAM5                                       2717
PARMHOLD DC    AL2(0)                                              2717
*
FCNVRT   SR    BASE,BASE               SET FOR F-CONVERSION        4594
         BC        ALWAYS,PARAM4
*
ECNVRT   LA        BASE,1              SET FOR E-CONVERSION
PARAM4   MVC   PARAMS+3(1),SCALEF      SET CURRENT SCALE FACTOR    2717
PARAM5   MVC   PARAMS+1(2),1(FMTPTR)   SET FORMAT WIDTH,DECIMALS   2717
         LA        FMTPTR,3(0,FMTPTR)  BUMP FORMAT POINTER
         BC        ALWAYS,COMMON
*
DCNVRT   EQU       ECNVRT
*
ICNVRT   LA        BASE,5              SET FOR I-CONVERSION
         BC        ALWAYS,PARAM2
*
ACNVRT   LA        BASE,10             SET FOR A-CONVERSION
         BC        ALWAYS,PARAM2
*
LCNVRT   LA        BASE,3              SET FOR L-CONVERSION
         BC        ALWAYS,PARAM2
*
ZCNVRT   LA        BASE,11             SET FOR Z-CONVERSION
PARAM2   MVC       PARAMS+1(1),1(FMTPTR)  SET FORMAT WIDTH
         MVC       PARAMS+2(2),NOPB2      AND A TWO-BYTE NOP.
         LA        FMTPTR,2(0,FMTPTR)  BUMP FORMAT POINTER
*
COMMON   SLA       BASE,3              ADJUST TO DOUBLE-WORD BOUNDARY
         TM        IOSWF,OUTPUT
         BC        NONE,EFMTCK         BRANCH IF INPUT
         LA        BASE,4(0,BASE)      ADJUST TO 2ND HALF OF DOUBLEWORD
EFMTCK   TM        EFMTSW,ON
         BC        NONE,LIST           BRANCH IF NOT END OF FORMAT
         MVI       EFMTSW,OFF          SET END-FORMAT SWITCH OFF,
         BAL       CALLER,FMTCAL          AND SKIP LIST EXIT.
*
LIST     TM        CTYPSW,ON
         BC        ALL,FMTCAL          BRANCH IF COMPLEX ITEM
         TM        ARRSW,ON
         BC        ALL,BUMPER          BRANCH IF ARRAY
         STM       4,13,KEEP           SAVE OWN REGISTERS
         LM    14,13,SAVE              RESTORE ALL REGISTER FOR USER
         BCR       ALWAYS,R            EXIT TO I/O LIST
*
         EJECT
*
FIOLF    MVC   STASH(4),0(R)           STASH LIST PARAMETERS
         LA    R,4(0,R)                COMPUTE RETURN ADDRESS
         STM   14,13,SAVE              SAVE MAIN REGISTERS
         MVC       PARAMS(1),STASH     SET LENGTH AND TYPE
         MVZ       MTYPE(1),STASH+1       OF I/O LIST ITEM.
         NI        STASH,X'00'
         NI        STASH+1,X'0F'
         OC        STASH(4),LAGRX      CREATE LA TO GRX
         EX        0,STASH             PICKUP ITEM ADDRESS IN GRX
         LM        4,13,KEEP           RESTORE OWN REGISTERS
         BAL       CALLER,FMTCAL       CONVERT CURRENT LIST ITEM
         BC        ALWAYS,LIST         RETURN TO I/O LIST
*
FIOAF    MVC   STASH(8),0(R)           STASH LIST PARAMETERS
         LA    R,8(0,R)                COMPUTE RETURN ADDRESS
         STM   14,13,SAVE              SAVE MAIN REGISTERS
         LM    4,13,KEEP               RESTORE OWN REGISTERS
         MVC       PARAMS(1),STASH+4   SET LENGTH AND TYPE
         MVZ       MTYPE(1),STASH+5       OF ARRAY ITEMS.
         NI        STASH+4,X'00'
         NI        STASH+5,X'0F'
         L         LOOP,STASH+4        GET NUMBER OF ITEMS IN ARRAY
         L         GRX,STASH           PICKUP ADDRESS OF ARRAY
         MVI       ARRSW,ON            SET ARRAY SWITCH ON
         SR        ADDER,ADDER
         IC        ADDER,PARAMS        USE ITEM LENGTH AS INCREMENT
         TM        STASH,ON
         BC        NONE,ARRHAF
         IC        ADDER,STASH         USE STRUCTURE SPAN INSTEAD
ARRHAF   TM        MTYPE,X'80'
         BC        NONE,RECALL         BRANCH IF NOT COMPLEX
         IC        BYTER,PARAMS
         SRA       BYTER,1
         STC       BYTER,PARAMS        SET LENGTH = LENGTH / 2
         SR        ADDER,BYTER
RECALL   BAL       CALLER,FMTCAL       CONVERT CURRENT LIST ITEM
BUMPER   AR        GRX,ADDER           STEP THROUGH ARRAY,
         BCT       LOOP,RECALL            UNTIL IT IS EXHAUSTED.
         MVI       ARRSW,OFF           SET ARRAY SWITCH OFF
         BC        ALWAYS,LIST         RETURN TO I/O LIST
*
         EJECT
*
FMTCAL   TM        EFMTSW,ON
         BC        ALL,LSTRET          BRANCH IF END OF FORMAT
         TM        MTYPE,X'80'
         BC        ALL,TSTHAF          BRANCH IF COMPLEX
GCHECK   TM        GFMTSW,ON
         BC        NONE,RECCHK         BRANCH IF NOT G-FORMAT
         MVC   PARAMS+2(2),PARMHOLD    ASSUMING REAL/DOUBLE/CMPLX, 2717C
                                       PLACE WIDTH & DEC POSITIONS 2717
         LA        BASE,X'60'
         CLI       MTYPE,X'60'
         BC        HIEQ,SKPNOP         BRANCH IF REAL/DOUBLE/COMPLEX
         MVC       PARAMS+2(2),NOPB2
         IC        BASE,MTYPE
SKPNOP   SRA       BASE,1              ADJUST TO DOUBLE-WORD BOUNDARY
         TM        IOSWF,OUTPUT
         BC        NONE,RECCHK         BRANCH IF INPUT
         LA        BASE,4(0,BASE)      ADJUST TO 2ND HALF OF DOUBLEWORD
RECCHK   IC        BYTER,PARAMS+1
         LTR       BYTER,BYTER
         BC        ZMINUS,TSTCNT       WIDTH = 0
CHKREC   EQU   *
         LA        SPILL,0(BYTER,BUFPTR)  RECORD POINTER PLUS WIDTH
         CR        SPILL,BUFLIM        COMPARE TO END OF RECORD
         AIF   (&ERR EQ 0).IB31
         BNH   RECOK                   LOW  OK
         LR    SPILL,GRX               HIGH ERROR,  SAVE REGISTER 2
         STM   BASE,BYTER,BASESAVE     SAVE REGS
         BAL   BASE,ERROR              GIVE ERROR MESSAGE
         LM    BASE,BYTER,BASESAVE     RESTORE REGS
         LR    GRX,SPILL
         B     CHKREC                  CHECK BUFFER SIZE
RECOK    EQU   *
         AGO   .IB30
.IB31    ANOP
         BC        HIGH,ERROR          ERROR, AT END OF RECORD.
.IB30    ANOP
         LR        GRY,BUFPTR          PICKUP BUFFER LOCATION
         L         1,VADCON
         L         1,0(BASE,1)
         BALR      0,1                 BRANCH TO CONVERSION ROUTINE
PARAMS   DC        AL4(0)
         LA        BUFPTR,0(BYTER,BUFPTR) UPDATE RECORD POINTER
TSTCNT   TM        FCOUNT,X'FE'        IS THERE A FIELD COUNT
         BC        NONE,SCANON         NO
         IC        BYTER,FCOUNT
         BCTR      BYTER,0             YES, REDUCE FIELD COUNT.
         STC       BYTER,FCOUNT
         TM        CTYPSW,ON
         BC        ALL,HAFCNT          BRANCH IF COMPLEX ITEM
         BCR       ALWAYS,CALLER       OTHERWISE, RETURN TO CALLER.
SCANON   MVI       GFMTSW,OFF          SET G-FORMAT SWITCH OFF
         BC        ALWAYS,SCAN         CONTINUE FORMAT SCAN
*
TSTHAF   TM        CTYPSW,ON
         BC        ALL,HAFCNT          BRANCH IF SECOND HALF
         MVI       CTYPSW,ON           SET FIRST-HALF SWITCH ON
         TM        ARRSW,ON
         BC        ALL,GCHECK          BRANCH IF ARRAY
         IC        BYTER,PARAMS
         SRA       BYTER,1
         STC       BYTER,PARAMS        SET LENGTH = LENGTH / 2
         BC        ALWAYS,GCHECK
HAFCNT   MVI       CTYPSW,OFF          SET FIRST-HALF SWITCH OFF
         IC        BYTER,PARAMS
         AR        GRX,BYTER           INCREMENT ITEM ADDRESS
         BC        ALWAYS,GCHECK
*
         SPACE     3
*
FENDF    STM       14,13,SAVE          SAVE MAIN REGISTERS
         LM        4,13,KEEP           RESTORE OWN REGISTERS
         TM        IOSWF,OUTPUT
         BC        NONE,EXITF          BRANCH IF INPUT
         AIF   (&ERR EQ 0).IB32
         TM    SKPLIST,ON              IS THE REMAINDER OF THE I/O REQ-
         BO    EXITF                   UEST TO BE IGNORED? YES RETURN
.IB32    ANOP
*   THIS INSTRUCTION MUST BE DIRECTLY FOLLOWED BY THE LABEL 'EXITF'
         BAL       CALLER,RECORD       OUTPUT ONE RECORD
EXITF    EQU   *
         SR    GRX,GRX                 ZERO OUT END OF FILE AND I/O
         SR    GRY,GRY                 ERROR EXIT ADDRESS FROM IBCOM
         STM   GRX,GRY,ENDFILE         COMMUNICATION AREA
         LM    0,13,SAVE+8             RESTORE MAIN REGISTERS
         MVI   SAVE,ON                 RESTORE I/O ENDED SWITCH
         BCR       ALWAYS,R            RETURN TO MAIN PROGRAM
*
ERROR    TM        IOSWF,OUTPUT
         BC        NONE,ERRORX         BRANCH IF INPUT
         BAL       CALLER,RECORD       OUTPUT ONE RECORD
ERRORX   EQU   *
         AIF   (&ERR EQ 0).IB22
         L     3,PARAM212              GIVE MESSAGE 212
         ST    GRX,STASH               SAVE REG 2
         BAL   LNK,COMINTFC            OUTPUT ERROR MESSAGE
         B     STAND212                IF STANDARD FIXUP
         B     SETSW                   IF USER FIXUP(I.E. IGNORE REST)
STAND212 TM    IOSWF,OUTPUT            IS THIS AN OUTPUT OPERATION?
         BZ    SETSW                   NO , IGNORE REST OF I/O REQ.
         L     1,VFIOCS                YES, REINITIALIZE FIOCS
         L     GRX,DSRNPTR             RESET PARM. LIST ADDRESS FOR
         BAL   LNK,IOCALL              FIOCS. GO TO FIOCS
         L     LNK,USEROPT     FROM OPTION TABLE ENTRY FOR 212    MAINT
         TM    48+BITS(LNK),CCHAR      FIND OUT IF USER WANTED A
         BZ    *+8                     CONTROL CHAR. SUPPLIED. NO ,BR.
         LA    BUFPTR,1(0,BUFPTR)      YES, SUPPLY BLANK AS CONTROL CHR
         L     GRX,STASH
         BR    BASE                    RETURN
         AGO   .IB23
.IB22    LA    1,212                   GIVE ERROR MESSAGE 212
         B     COMERRHN
.IB23    ANOP
*
         AIF   (&ERR EQ 0).IB11
PRCMNTFC EQU   *
         STM   11,15,KEEP+4            SAVE REGISTERS
         LR    12,15                   SET BASE INTO REG 12
         DROP  L
         USING IBCOM#,12
         LR    11,3                    SAVE ADDRESS OF PARM LIST
         MVI   12(3),X'80'
         TM    UNITWD,X'80'            DIRECT ACCESS REQUST?
         BO    NOMAIN                  YES, NOT NECESSARY TO SAVE BUFFR
         TM    IOSWF,OUTPUT            OUTPUT REQUEST?
         BZ    NOMAIN                  NO, ALSO NOT NECESSARY TO SAVE
         LR    1,BUFPTR                BUFFER. OTHERWISE SEE IF ANY-
         S     1,BUFADD                THING MOVED INTO BUFFER YET
         LTR   1,1                     IF NOTHING IN BUFFER THEN NO
         BZ    NOMAIN                  SAVE IS NECESSARY
         ST    GRX,STASH               ELSE, GET CORE TO SAVE PORTION
         LR    2,1                     OF THE BUFFER THAT HAS BEEN
* GETMAIN R,LV=1                       FILLED. THIS SAVE IS NECESSARY
         GETMAIN R,LV=(1)              FILLED. THIS SAVE IS NECESSARY
         ST    1,GOTAD                 IN CASE USER WAS DOING OUTPUT
         L     13,BUFADD               TO THE OBJECT ERROR UNIT AND WE
         BCTR  2,0                     KNOW THAT THE ERROR MONITOR WILL
         EX    2,MOVEFMT               ALSO DO I/O TO THAT UNIT .
         STH   2,KEEP                  (NOTE; USER CANNOT DO INPUT FROM
         B     GETSVR                  THE OBJECT ERROR UNIT)
         DROP  12
         USING IBCOM#,L
COMINTFC STM   11,15,KEEP+4            SAVE REGS
         LR    12,15                   CHANGE BASE REGISTERS
         DROP  L
         USING IBCOM#,12
         LR    11,3                    SAVE PARM LIST ADDRESS
         L     3,0(0,3)                GET ADDRESS OF LAST FOUR BYTES
         L     14,0(0,3)               OF MESSAGE AND CONVERT THE
         LA    3,0(3,14)               DATA SET REFERENCE NUMBER INTO
         LA    2,DSRN                  THIS AREA(I.E.MAKE IT PRINTABLE)
         EX    0,82(0,12)
         BALR  0,1
         DC    X'0404'
GETSVR   EQU   *
NOMAIN   EQU   *
         LR    1,11                    PUT PARM LIST ADDRESS IN REG. 1
*        THIS CODE DOES NOT SET UP THE HIGH (I.E. NEXT) SAVE AREA
*        POINTER IN THE USER'S SAVE AREA BECAUSE THIS IS NOT NECESSARY
*        CURRENTLY IN TRACEBACK
         L     13,SAVE+60              LINK UP USER'S SAVE AREA TO
         MVC   12(16,13),SAVE          THE SAVE AREA THAT WE ARE GOING
         ST    13,ERRSAV+4             TO USE IN THE CALL TO THE ERROR
         LA    13,ERRSAV               MONITOR. MOVE HIS REGS TO HIS
*                                      SAVE AREA FOR TRACEBACK PURPOSES
*   THIS ROUTINE DOES NOT ZERO THE RETURN CODE BECAUSE THE ERROR
*   WILL DO SO BEFORE GOING TO THE USER'S EXIT
         L     15,VIHCERRM             LINK TO THE ERROR MONITOR
         BALR  14,15
         L     13,GOTAD                WAS THE CONTENTS OF THE BUFFER
         LTR   13,13                   SAVED? NO, BRANCH
         BZ    NOMV
         L     1,VFIOCS                YES, REINITIALIZE FIOCS AND
         L     GRX,DSRNPTR             THEN MOVE THE CONTENTS
         LR    15,12                   OF THE BUFFER INTO THE NEW
         BAL   LNK,IOCALL              BUFFER PASSED BACK BY FIOCS
         L     1,BUFADD                THEN FREE THE AREA USED TO
         LH    2,KEEP                  SAVE THE CONTENTS OF THE OLD
         EX    2,MOVEFMT               BUFFER
         LA    2,1(0,2)
         LA    BUFPTR,0(2,BUFPTR)
* FREEMAIN R,LV=(2),A=(13)
         FREEMAIN R,LV=(2),A=(13)
         SR    GRX,GRX
         ST    GRX,GOTAD               ZERO OUT SAVED BUFFER AREA
         L     GRX,STASH
NOMV     EQU   *
         L     GRY,4(0,11)             GET ADDRES OF RETURN CODE FIELD
         LM    11,15,KEEP+4            RESTORE  REGISTERS
         DROP  12
         USING IBCOM#,L
         L     GRY,0(0,GRY)            GET REURN CODE
         LTR   GRY,GRY                 TEST IT
         BCR   8,LNK                   IF ZERO RETURN AT OFFSET 0
         B     4(0,LNK)                ELSE RETURN AT OFFSET 4
MOVEFMT  MVC   0(1,1),0(13)
.IB11    ANOP
         EJECT
*
FSCAN    STM       1,6,SAVES1          SAVE MAIN REGISTERS
         SR        PARCNT,PARCNT       INITIALIZE PARENTHESIS COUNT
         SR        DIGINT,DIGINT          AND DIGIT COLLECTORS.
         ST        DIGINT,FMTNUM
         LA        CALLER,CTYPE+3      INSURE RETURN FROM SCAN
         ST        CALLER,LSTGRP
         MVI       FBYTE+1,X'00'
         MVC       CTYPE(4),FBYTE+1
         LR        1,FMTPTR            POINT TO VARIABLE FORMAT
         SR        2,2
CNTFMT   L     CALLER,VIBCOM2          GET ADDRESS OF CSECT TWO
         TRT   0(256,1),OFFTRT(CALLER) TRANSLATE VARIABLE FORMAT
         BC    NOTZER,BRTAB(2)         GO TO CHAR ROUT IF NOT 256 22019
         LA    1,256(0,1)              BLANKS, ELSE UPDATE FMT    22019
*
BRTAB    DS        0H
         BC    ALWAYS,CNTFMT           ADD & CONTINUE TRT OF FMT. 22019
         BC        ALWAYS,TDIGIT       0-9
         BC        ALWAYS,TLFPAR       (
         BC        ALWAYS,TCHARA       A
         BC        ALWAYS,TCHARL       L
         BC        ALWAYS,TCHARZ       Z
         BC        ALWAYS,TCHARI       I
         BC        ALWAYS,TMINUS       -
         BC        ALWAYS,TCHARP       P
         BC        ALWAYS,TCHARF       F
         BC        ALWAYS,TCHARE       E
         BC        ALWAYS,TCHARD       D
         BC        ALWAYS,TCHARG       G
         BC        ALWAYS,TCHART       T
         BC        ALWAYS,TCHARX       X
         BC        ALWAYS,TCHARH       H
         BC        ALWAYS,TQUOTE       '
         BC        ALWAYS,TPOINT       .
         BC        ALWAYS,TCOMMA       ,
         BC        ALWAYS,TSLASH       /
         BC        ALWAYS,TRTPAR       )
         AIF   (&ERR EQ 1).IB14
         BC        ALWAYS,FMTERR       ILLEGAL CHARACTER
         AGO   .IB15
.IB14    BC    ALWAYS,FMTERR1
FMTERR1  LA    CALLER,CNTFMT           SET UP RETURN POINTFOR LATER USE
         STM   1,6,SAVES2              SAVE REGISTERS
         L     3,PARMR211              GIVE ERROR MESSAGE 211
         MVC   MSG211M-PRAMS211(8,3),VARIABLE-PRAMS211(3)  MOVE VARIABL
         MVC   FMTCHR-PRAMS211(1,3),0(1)   INTO MESS. MOVE BAD CHAR TO
         ST    1,12(0,3)               MESS. STORE ADDR. OF BAD CHAR.
         MVI   12(3),X'80'             IN PARM LIST. RESET LAST PARM
         BAL   LNK,PRCMNTFC            BIT . OUTPUT THE MESSAGE
         B     STND211                 IF STANDARD FIXUP
         B     RESTR                   IF USER FIXUP(CALLER HAS BEEN
*                                      PREVIOSLY SET UP TO GO TO
*                                      'CNTFMT'
STND211  EQU   *
         LM    1,6,SAVES2              RESTORE REGS
         CH    PARCNT,TWO              IF NOT WITHIN SECOND LEVELOF
         BNH   ENDOFMT                 PARENTHESES BRANCH
         MVC   CURRENT+4(6),SECLEV+4   ELSE RESET TO THE FIRST LEVEL
         MVC   TGROUP(4),SECLEV
         B     ENDOFMT                 GO TO TREAT AS END OF FORMAT )
.IB15    ANOP
*
TDIGIT   MVN       FMTDIG+3(1),0(1)
         SLA       DIGINT,3            N * 10
         A         DIGINT,FMTNUM
         A         DIGINT,FMTNUM
         A         DIGINT,FMTDIG       ADD NEW DIGIT TO N
         ST        DIGINT,FMTNUM
BUMPR1   LA        1,1(0,1)            POINT TO NEXT FORMAT CHARACTER
         BC        ALWAYS,CNTFMT
*
TLFPAR   LA        PARCNT,1(0,PARCNT)  INCREMENT PARENTHESIS COUNT
         CH        PARCNT,TWO
         BC        LOEQ,LOWLEV
         MVC       SAVPTR(4),TGROUP    PARENTHESIS LEVEL GT ONE,
         MVC       SAVCNT(2),COUNTS       SAVE POSITION AND COUNTS.
         MVC       OLDPAR(4),NEWPAR
LOWLEV   ST        1,TGROUP            SAVE POINTER FOR REPEATS
         STC       DIGINT,GCOUNT       SAVE GROUP COUNT
         STC       DIGINT,GCSAVE
         ST        PARCNT,NEWPAR       SAVE PARENTHESIS COUNT
         BC        ALWAYS,DINIT
*
TSLASH   BAL       CALLER,FIELDR       PROCESS CURRENT FIELD
         MVI       CTYPE,X'1E'
         BAL       CALLER,STASHR       PROCESS RECORD END
         BC        ALWAYS,DINIT
*
TRTPAR   BAL       CALLER,FIELDR       PROCESS CURRENT FIELD
         BCT       PARCNT,NOTEND       DECREMENT PARENTHESIS COUNT
ENDOFMT  EQU   *
         MVI       CTYPE,X'22'
         BAL       CALLER,STASHR       PROCESS FORMAT END
REPFMT   L         1,TGROUP            POINT TO LAST GROUP
         L         PARCNT,NEWPAR       RESTORE PARENTHESIS COUNT
         BC        ALWAYS,DINIT
NOTEND   TM        GCOUNT,X'FE'
         BC        ANYALL,CNTDWN       BRANCH IF GROUP COUNT
         CH        PARCNT,ONE
         BC        LOEQ,DINIT
         MVC       TGROUP(4),SAVPTR    END OF SECOND PARENTHESIS LEVEL,
         MVC       COUNTS(2),SAVCNT       RESTORE POSITION AND COUNTS.
         MVC       NEWPAR(4),OLDPAR
         BC        ALWAYS,DINIT
CNTDWN   IC        DIGINT,GCOUNT
         BCTR      DIGINT,0
         STC       DIGINT,GCOUNT       REDUCE GROUP COUNT
         BC        ALWAYS,REPFMT
*
FIELDR   TM        CTYPE,ON
         BCR       NONE,CALLER         IGNORE NULL FIELD
         TM        TDECSW,ON           TEST FOR DECIMAL
         BC        NONE,TWIDTH
         STC       DIGINT,CTYPE+2      SWITCH ON, SET D.
         MVI       TDECSW,OFF
         BC        ALWAYS,TESTER
TWIDTH   STC       DIGINT,CTYPE+1      SWITCH OFF, SET W.
TESTER   TM        CTYPE+1,X'FF'
         BCR       NONE,CALLER         IGNORE IF WIDTH = 0
STASHR   STM       1,6,SAVES2          SAVE OWN REGISTERS
         LM        1,6,SAVES1          RESTORE MAIN REGISTERS
         LA        FMTPTR,CTYPE        POINT TO FIELD PROPER
         TM        FBYTE+1,X'FE'
         BC        NONE,SCAN
         LA        FMTPTR,FBYTE        POINT TO FIELD COUNT
         BC        ALWAYS,SCAN
*
FBYTE    DC        X'0600'             FIELD COUNT
CTYPE    DC        AL4(0)              CONVERSION AND RETURN
*
VARFMT   MVI       FBYTE+1,X'00'       CLEAR FIELD
         MVC       CTYPE(4),FBYTE+1
         STM       1,6,SAVES1          SAVE MAIN REGISTERS
RESTR    EQU   *
         LM        1,6,SAVES2          RESTORE OWN REGISTERS
         BCR       ALWAYS,CALLER       RETURN FROM FIELDR
*
TMINUS   MVI       CTYPE+1,X'80'       MINUS SIGN
         BC        ALWAYS,BUMPR1
*
TCHARP   MVI       CTYPE,X'08'         SCALE FACTOR
         OC        CTYPE+1(1),FMTNUM+3
         BAL       CALLER,STASHR       PROCESS P-FIELD
         BC        ALWAYS,DINIT
*
TCHARX   LTR       DIGINT,DIGINT
         BC        PLUS,SETXCT         BRANCH IF N NON-ZERO
         LA        DIGINT,1            FORCE COUNT OF 1
SETXCT   MVI       CTYPE,X'18'         SKIP OR BLANK
         STC       DIGINT,CTYPE+1
         BAL       CALLER,STASHR
         BC        ALWAYS,DINIT
*
TCOMMA   BAL       CALLER,FIELDR       PROCESS CURRENT FIELD
         BC        ALWAYS,DINIT
*
TPOINT   TM        TDECSW,ON           DECIMAL PT.ALREADY FOUND?  49560
         BO        TPTERR              IF SO GIVE ERROR           49560
         STC       DIGINT,CTYPE+1      SAVE DECIMAL POINT         49560
         MVI       TDECSW,ON
         BC        ALWAYS,DINIT
TPTERR   MVI       TDECSW,OFF          SET DEC. PT. SWITCH OFF    49560
         AIF   (&ERR EQ 0).IB16
         B         FMTERR1             GIVE ERROR 211             49560
         AGO   .IB16B
.IB16    B         FMTERR              GIVE ERROR 211             49560
.IB16B   ANOP
*
TCHART   MVI       CTYPE,X'12'         COLUMN SET
*
TFLDCT   STC       DIGINT,FBYTE+1      STASH FIELD COUNT
DINIT    SR        DIGINT,DIGINT       INITIALIZE FOR NEW NUMBER
         ST        DIGINT,FMTNUM
         BC        ALWAYS,BUMPR1
*
TCHARI   MVI       CTYPE,X'10'         I-CONVERSION
         BC        ALWAYS,TFLDCT
TCHARA   MVI       CTYPE,X'14'         A-CONVERSION
         BC        ALWAYS,TFLDCT
TCHARL   MVI       CTYPE,X'16'         L-CONVERSION
         BC        ALWAYS,TFLDCT
TCHARZ   MVI       CTYPE,X'24'         Z-CONVERSION
         BC        ALWAYS,TFLDCT
*
TCHARF   MVI       CTYPE,X'0A'         F-CONVERSION
         BC        ALWAYS,TFLDCT
TCHARE   MVI       CTYPE,X'0C'         E-CONVERSION
         BC        ALWAYS,TFLDCT
TCHARD   MVI       CTYPE,X'0E'         D-CONVERSION
         BC        ALWAYS,TFLDCT
TCHARG   MVI       CTYPE,X'20'         G-CONVERSION
         BC        ALWAYS,TFLDCT
*
TCHARH   BAL       CALLER,LITDAT       INPUT OR OUTPUT DATA
         SR        DIGINT,DIGINT
         ST        DIGINT,FMTNUM
         BC        ALWAYS,CNTFMT
*
TQUOTE   MVI       QSTOP,OFF           TURN OFF STOP SWITCH
         MVC       QUOTE(1),0(1)
BEGQ     ST        1,QSAVE             SAVE FORMAT POINTER
         SR        DIGINT,DIGINT       INITIALIZE COUNT
QSEEK    CLC       1(1,1),QUOTE
         BC        EQUAL,QMATCH        BRANCH IF QUOTE
QBUMP    LA        DIGINT,1(0,DIGINT)  INCREMENT COUNT
         LA        1,1(0,1)               AND FORMAT POINTER.
         BC        ALWAYS,QSEEK
QMATCH   CLC       2(1,1),QUOTE
         BC        NOTEQ,ENDQ          BRANCH IF NOT QUOTE PAIR
         LA        DIGINT,1(0,DIGINT)  INCREMENT COUNT
         LA        1,1(0,1)               AND FORMAT POINTER.
         TM        IOSWF,OUTPUT
         BC        NONE,QBUMP          BRANCH IF INPUT
         BC        ALWAYS,ENDQ+4
ENDQ     MVI       QSTOP,ON            TURN ON STOP SWITCH
         L         1,QSAVE
         BAL       CALLER,LITDAT       INPUT OR OUTPUT DATA
         TM        QSTOP,ON
         BC        ALL,DINIT           BRANCH IF MOVE COMPLETE
         BC        ALWAYS,BEGQ         PROCESS NEXT PART OF LITERAL
*
LITDAT   LTR       DIGINT,DIGINT       N = 0
         LA        1,1(0,1)
         BCR       ZMINUS,CALLER
         LR        FMTPTR,1            SET FORMAT POINTER
         BCTR      DIGINT,0            PREPARE FOR EXECUTE
         TM        IOSWF,OUTPUT
         BC        ALL,LITOUT          BRANCH IF OUTPUT
         EX        DIGINT,MOVE1        MOVE CHARACTERS INTO FORMAT
         BC        ALWAYS,LITRET
LITOUT   EX        DIGINT,MOVE2        MOVE CHARACTERS FROM FORMAT
LITRET   LA        BUFPTR,1(DIGINT,BUFPTR)  BUMP RECORD POINTER
         LA        1,1(DIGINT,FMTPTR)  REPOSITION IN VARIABLE FORMAT
         BCR       ALWAYS,CALLER
*
         EJECT
* CALLING SEQUENCE
*
*        L         L,=V(IBCOM#)
*        CNOP      0,4
*        BAL       R,20(L)             FRDNF
*             OR
*        BAL       R,24(L)             FWRNF
*        DC        XL0.4'PI',XL0.4'UI',AL3(UNIT)
*        DC        AL4(EOFADD)         OPTIONAL
*        DC        AL4(ERRADD)         OPTIONAL
*                  WHERE PI = X'0' IF NEITHER EOF NOR ERR,
*                             X'1' IF EOF ONLY,
*                             X'2' IF ERR ONLY,
*                             X'3' IF BOTH EOF AND ERR.
*                  UI = X'0' IF UNIT IS AN INTEGER CONSTANT,
*                       X'1' IF UNIT IS A VARIABLE NAME,
*                       X'4' IF UNIT IS A STANDARD SYSTEMS UNIT.
*
*        L         L,=V(IBCOM#)
*        BAL       R,28(L)             FIOLN
*        DC        XL1'LENGTH',XL0.4'0',XL0.4'X',XL0.4'B',XL1.4'D'
*                  WHERE LENGTH = SIZE (IN BYTES) OF THE ITEM,
*                  AND X, B, D ARE THE INDEX, BASE, DISPLACEMENT
*                  WHICH SPECIFY THE ADDRESS OF THE ITEM.
*
*        L         L,=V(IBCOM#)
*        BAL       R,32(L)             FIOAN
*        DC        XL1'SPAN',AL3(ADDRESS)
*        DC        XL1'LENGTH',AL3(ELEMENTS)
*                  WHERE SPAN REFERS TO STRUCTURED ARRAYS,
*                  ADDRESS = BEGINNING LOCATION OF THE ARRAY,
*                  LENGTH(L) = SIZE(IN BYTES) OF EACH ITEM,
*                  ELEMENTS = NUMBER OF ITEMS IN THE ARRAY.
*
*        L         L,=V(IBCOM#)
*        BAL       R,36(L)             FENDN
*
         SPACE     3
* ERROR CONDITIONS
*        INPUT LIST LONGER THAN LOGICAL RECORD.
*        ATTEMPT TO OUTPUT MORE THAN 255 RECORDS IN A LOGICAL RECORD.
*        FOR OTHERS, SEE FIOCS ROUTINE.
         EJECT
*
FRDNF    MVI       IOSWN,NONINP        SET FOR NON-FORMATTED INPUT
         BC        ALWAYS,RWCOMN
*
FWRNF    MVI       IOSWN,NONOUT        SET FOR NON-FORMATTED OUTPUT
         SPACE     3
*
RWCOMN   EQU   *
         AIF   (&ERR EQ 0).IB61
         CLI   SAVE,ON                 ATTEMPT TO DO I/O DURING A FIXUP
         BNE   ERR904                  FOR AN I/O ERROR? YES, BRANCH
.IB61    ANOP
         STM   14,13,SAVE
         LA    GRY,4                   ALLOW FOR UNIT NUMBER
         BAL   13,EOFNIOR              GO TO SET UP ADDRESSES
         BALR      0,1                 INITIALIZE FILE
         DC        AL1(INIT)
IOSWN    DC        AL1(0)
         AIF   (&ERR EQ 0).IB17
         MVI   SKPLIST,ON              INDICATE REST OF I/O REQ. TO BE
         AGO   .IB18                   SKIPPED
.IB17    NOP   0
.IB18    ANOP
         LA    BUFLOC,0(GRX,0)         SAVE START OF RECORD         174
         LA        BUFLIM,0(GRY,GRX)   COMPUTE END OF RECORD
         LR    BUFPTR,BUFLOC           INITIALIZE RECORD POINTER    174
SETBYT   SR    BTM,BTM                 INITIALIZE BYTE REGISTER     174
         SR    BYTER,BYTER             SET INDEX FOR MOVE3 - READ   174
         TM    IOSWN,OUTPUT            IS THIS A WRITE ?            174
         BC    NONE,SETREC             NO LEAVE AS MOVE3 - READ     174
         LA    BYTER,6(0,0)            SET INDEX FOR MOVE4 WRITE    174
SETREC   SR        RECCNT,RECCNT       INITIALIZE RECORD COUNT
         STM   4,12,KEEP               SAVE OWN REGISTERS           174
         LM    14,13,SAVE              RESTORE REGISTERS
         BCR       ALWAYS,R            EXIT TO I/O LIST
*
         EJECT
*
FIOLN    STM       14,13,SAVE          SAVE MAIN REGISTERS
         MVC       STASH(4),0(R)       STASH LIST PARAMETERS
         MVC       FQUALS(1),STASH     SET LENGTH OF I/O LIST ITEM
         NI        STASH,X'00'
         NI        STASH+1,X'0F'
         OC        STASH(4),LAGRX      CREATE LA TO GRX
         EX        0,STASH             PICKUP ITEM ADDRESS IN GRX
         LM    4,12,KEEP               RESTORE OWN REGISTERS        174
         MVI   GOWHR,OFF               SET RTN TO FIOLN FR NEWREC   174
         IC    BTM,FQUALS              ITEM LENGTH                  174
         LR    BTG,BUFLIM                END OF BUF - LOC IN BUF    174
         SR    BTG,BUFPTR                = BYTES LEFT IN BUF        174
         CR    BTG,BTM                 BYTES IN BUF < ITEM SIZE ?   174
         BL    CHECK                   YES - CHECK FOR SPLIT READ   174
MOVCOM   BCTR  BTM,0                   ADJUST FOR MVC COUNT         174
MOVOUT   EX    BTM,MOVE3(BYTER)        MAKE THE MOVE                174
         LA    BUFPTR,1(BTM,BUFPTR)    UPDATE BUFFER POINTER        174
RTNL     STM   4,12,KEEP               SAVE OWN REGISTERS           174
         LM    0,12,SAVE+8             RESTORE MAIN REGISTERS       174
         BC        ALWAYS,4(0,R)       RETURN TO I/O LIST
*
FIOAN    STM   14,13,SAVE              SAVE REGISTERS               174
         LM    4,12,KEEP               RESTORE OWN REGISTERS        174
         MVC   STASH(8),0(R)           STASH LIST PARAMETERS        174
         L     GRX,STASH               ADDRESS OF ARRAY             174
         L     BTM,STASH+4            SIZE, TYPE & # OF ARRAY ITEMS 174
         N     BTM,MASK                # OF ITEMS ONLY              174
         MVC   ITEM+1(1),4(R)          SIZE OF ITEM                 174
         MH    BTM,ITEM                SIZE OF ARRAY                174
         LH    GRY,ITEM                SIZE OF ITEM                 174
         LA    R256,256(0)             LARGEST MVC SIZE  256        174
         LNR   CALLER,GRY              SET CONSTANT FOR FULL ITEM   174
         ST    CALLER,FULLIT           SAVE CONSTANT                174
LOOPER   LR    BTG,BUFLIM              END OF BUF - LOC IN BUF      174
         SR    BTG,BUFPTR               = BYTES LEFT IN BUFFER      174
         CR    BTG,GRY                 BYTES IN BUF < ITEM SIZE     174
         BNL   DARRAY                  NO  BYPASS SPLIT REC TEST    174
         MVI   GOWHR,ON                SET RTN TO LOOPER FR NEWREC  174
CHECK    LTR   BYTER,BYTER             IS THIS A WRITE ?            174
         BNZ   NEWREC                  YES - GET NEW BUFFER         174
         TM    UNITWD,X'80'            DIRECT ACCESS ?              174
         BC    ALL,NEWREC              YES - NO SPLIT READ          174
         LTR   BTG,BTG                 IS BUFFER FINISHED ?         174
         BZ    NEWREC                  YES - GET NEW BUFFER         174
RDSPLT   BCTR  BTG,0                   ADJUST FOR MVC COUNT         174
         EX    BTG,MOVE3               READ                         174
         LA    GRX,1(BTG,GRX)          UPDATE ARRAY ADDRESS         174
         SR    BTM,BTG                 UPDATE BYTES TO MOVE         174
         BCT   BTM,NEWREC              GET NEW BUFFER               174
         TM    GOWHR,ON                ENTERED FR FIOLN OR FIOAN ?34162
         BC    NONE,RTNL               FIOLN CASE                 34162
         BC    ALWAYS,RTNA             FIOAN CASE                 34162
DARRAY   LR    B,BTG                   MOVE SIZE = BYTES IN BUF     174
         CR    BTM,BTG                 RECORD > REMAINING BUFFER    174
         BH    ARRAY                   YES  USE BYTES IN BUF SIZE   174
         LR    B,BTM                   NO  USE RECORD SIZE          174
ARRAY    CR    B,R256                  BYTES TO MOVE > 256          174
         BNH   LNTHOK                  NO  BYTES TO MOVE = MVC      174
         LR    B,R256                  YES  256 = MVC               174
LNTHOK   LTR   BYTER,BYTER             IS THIS A READ ?             174
         BNZ   DORITE                  NO  SET FOR WRITE            174
         TM    UNITWD,X'80'            DIRECT ACCESS RECORD ?       174
         BC    LOEQ,SPLTYS             NO  DO SEQ READ              174
DORITE   N     B,FULLIT                ADJUST FOR FULL ITEM         174
SPLTYS   BCTR  B,0                     ADJUST FOR MVC COUNT         174
         EX    B,MOVE3(BYTER)          MAKE THE MOVE                174
         LA    BUFPTR,1(B,BUFPTR)      UPDATE BUFFER POINTER        174
         LA    GRX,1(B,GRX)            UPDATE ARRAY POINTER         174
         SR    BTM,B                   UPDATE # OF BYTES TO MOVE    174
         BCT   BTM,LOOPER              MORE TO MOVE ? YES  LOOP     174
RTNA     STM   4,12,KEEP               NO   SAVE OWN REGISTERS      174
         LM    0,12,SAVE+8             RESTORE MAIN REGISTERS       174
         BC    ALWAYS,8(0,R)           RETURN TO I/O LIST           174
*
         EJECT
*
NEWREC   EQU   *
         STM   GRX,GRY,STASH           SAVE REGS
         AIF   (&ERR EQ 0).IB19
         TM    SKPLIST,ON              IS I/O REQUEST TO BE IGNORED
         BC    NONE,IOOK               NO - CONTINUE                174
RTNE     TM    GOWHR,ON                RETURN TO LIST OR ARRAY ?    174
         BC    NONE,RTNL               LIST - FIOLN                 174
         BC    ALWAYS,RTNA             ARRAY - FIOAN                174
.IB19    ANOP
IOOK     LTR   BYTER,BYTER                                          174
         BNZ   OUTREC                  GO TO WRITE RECORD           174
         MVI       IOTYPN,READ         SET INDICATOR FOR READ
         TM        UNITWD,X'80'        IF DIRECT ACCESS,
         BC        ALL,COMREC             SKIP GREEN WORD CHECK.
         SH    BUFLOC,FOUR             POINT TO THE SCW            SIR1
         TM    2(BUFLOC),X'01'         TEST SCC TO SEE IF SOMETHINGSIR1
         BO    COMREC                  FOLLOWS, YES OK , NO ERROR  SIR1
*                                                                  SIR1
INPERR   EQU   *
         AIF   (&ERR EQ 0).IB20
         L     3,PARAM213              GIVE MESSAGE 213
         BAL   LNK,COMINTFC            OUTPUT MESSAGE
         NOP   0                       STANDARD FIXUP AND
         L     LNK,SAVE                USER FIXUP THE SAME, IGNORE I/O
INPRET   EQU   *                       REQUEST.
         LR    BUFPTR,BUFLIM           SET BUFPTR=BUFLIM SO THAT NO
         MVI   SKPLIST,ON              I/O GETS DONE. SET SKIP I/O SW.
         LM    GRX,GRY,STASH           RESTORE REGS
         B     RTNE                    GO TO RETURN CHECK           174
         AGO   .IB21
.IB20    LA    1,213
         B     COMERRHN                GIVE MESSAGE 213
.IB21    ANOP
OUTREC   MVI       IOTYPN,RITE         SET INDICATOR FOR WRITE
         SR        BUFPTR,BUFLOC       COMPUTE NUMBER OF BYTES OUTPUT,
         LR        GRX,BUFPTR             AND PLACE IT IN GRX.
         TM        UNITWD,X'80'        IF DIRECT ACCESS,
         BC        ALL,COMREC             DON'T ADJUST LENGTH.
         SH    BUFLOC,FOUR             POINT TO THE SCW            SIR1
         OI    2(BUFLOC),X'01'         INDICATE SOMETHING FOLLOWS  SIR1
         LTR   RECCNT,RECCNT           DOES ANYTHING PRECEDE       SIR1
         BZ    INCRM                   NO, BRANCH                  SIR1
         OI    2(BUFLOC),X'02'         INDICATE SOMETHING PRECEDES SIR1
INCRM    LA    RECCNT,1(0,RECCNT)                                  SIR1
COMREC   L         1,DFIOCS
         BALR      0,1                 READ OR WRITE ONE RECORD
IOTYPN   DC        AL1(0)
         DC        AL1(NULL)
         AIF   (&ERR EQ 0).IB3
         B     INPRET                  GO IGNORE I/O REQUEST
         AGO   .IB26
.IB3     NOP   0
.IB26    ANOP
         LA    BUFLOC,0(GRX,0)         SAVE START OF RECORD         174
         LA        BUFLIM,0(GRY,GRX)   COMPUTE END OF RECORD
         LR    BUFPTR,BUFLOC           INITIALIZE RECORD POINTER    174
SKPGRN   LM        GRX,GRY,STASH       RESTORE ARGUMENT REGISTERS,
         TM    GOWHR,ON                CALLED FR FIOLN OR FIOAN ?   174
         BC    NONE,MOVCOM             RTN TO MOVCOM (FIOLN CASE)   174
         BC    ALWAYS,LOOPER           RTN TO LOOPER (FIOAN CASE)   174
*
         EJECT
*
FENDN    STM       14,13,SAVE          SAVE MAIN REGISTERS
         LM    4,12,KEEP               RESTORE OWN REGISTERS        174
         AIF   (&ERR EQ 0).IB33
         TM    SKPLIST,ON              I/O REQUEST TO BE IGNORED
         BO    EXITN                   YES, RETURN
.IB33    ANOP
         TM        IOSWN,OUTPUT
         BC        ALL,ENDOUT          BRANCH IF OUTPUT
ENDTST   TM        UNITWD,X'80'
         BC        ALL,EXITN           BRANCH IF DIRECT ACCESS
TESTEND  SH    BUFLOC,FOUR             POINT TO SCW                SIR1
         TM    2(BUFLOC),X'01'         DOES ANY FOLLOW(TEST SCC)   SIR1
         BZ    EXITN                   NO, ALL DONE(BRANCH)YES,READSIR1
         L         1,VFIOCS
         BALR      0,1                 NO, KEEP READING UNTIL IT HAS.
         DC        AL1(READ)
         DC        AL1(NULL)
         B     EXITN                   IF ERROR OCCURRED, RETURN
         LR        BUFLOC,GRX          GET START OF RECORD,
         B     TESTEND                    AND REPEAT TEST          SIR1
ENDOUT   SR        BUFPTR,BUFLOC       COMPUTE NUMBER OF BYTES OUTPUT,
         LR        GRX,BUFPTR             AND PLACE IT IN GRX.
         TM        UNITWD,X'80'        IF DIRECT ACCESS,
         BC        ALL,PUTOUT             DON'T ADJUST LENGTH.
         SH    BUFLOC,FOUR             POINT TO THE SCW            SIR1
         LTR   RECCNT,RECCNT           ANY SEGMENTS PRECEDING THIS SIR1
         BZ    PUTOUT                  NO BRANCH                   SIR1
         OI    2(BUFLOC),X'02'         YES INDICATE THIS IN THE SCCSIR1
PUTOUT   L         1,DFIOCS
         BALR      0,1                 WRITE LAST RECORD
         DC        AL1(RITE)
         DC        AL1(NULL)
         NOP   0
EXITN    EQU   *
         SR    GRX,GRX                 ZERO OUT END OF FILE AND I/O
         SR    GRY,GRY                 ERROR EXIT ADDRESSES
         STM   GRX,GRY,ENDFILE
         LM    0,12,SAVE+8             RESTORE MAIN REGISTERS       174
         MVI   SAVE,ON                 RESET I/O ENDED SWITCH
         BCR       ALWAYS,R            RETURN TO MAIN PROGRAM
         EJECT
* CALLING SEQUENCE
*        L         L,=V(IBCOM#)
*        CNOP      0,4
*        BAL       R,40(L)             FBKSP
*        DC        XL1'FLAG',AL3(UNIT)
*                  WHERE FLAG = 0 IF UNIT IS AN INTEGER CONSTANT,
*                  ANY OTHER BIT PATTERN IF UNIT IS A VARIABLE.
         SPACE     3
* ERROR CONDITIONS
*        SEE FIOCS ROUTINE
         SPACE     3
*
FBKSP    EQU   *
         AIF   (&ERR EQ 0).IB62
         CLI   SAVE,ON                 ATTEMPT TO DO I/O DURING A FIXUP
         BNE   ERR904                  FOR AN I/O ERROR? YES BRANCH
.IB62    STM   14,13,SAVE              SAVE REGISTERS
BSP      EQU   *                                                   SIR1
         LR        GRX,R               PICKUP PARAMETER POINTER
         L         1,VFIOCS
         BALR      0,1                 BACKSPACE RECORD
         DC        AL1(CTRL)
         DC        AL1(BKSP)
         NOP   0
EXITB    LM        0,4,SAVE+8          RESTORE MAIN REGISTERS
         MVI   SAVE,ON                 RESET I/O ENDED SWITCH
         BC        ALWAYS,4(0,R)       RETURN TO MAIN PROGRAM
*
         EJECT
* CALLING SEQUENCE
*        L         L,=V(IBCOM#)
*        CNOP      0,4
*        BAL       R,44(L)             FRWND
*             OR
*        BAL       R,48(L)             FEOFM
*        DC        XL1'FLAG',AL3(UNIT)
*                  WHERE FLAG = 0 IF UNIT IS AN INTEGER CONSTANT,
*                  ANY OTHER BIT PATTERN IF UNIT IS A VARIABLE.
         SPACE     3
* ERROR CONDITIONS
*        SEE FIOCS ROUTINE
         SPACE     3
*
         USING IBCOM#,L                                             174
FRWND    EQU   *
         AIF   (&ERR EQ 0).IB63
         CLI   SAVE,ON                 ATTEMPT TO DO I/O DURING A FIXUP
         BNE   ERR904                  FOR AN I/O ERROR? YES BRANCH
.IB63    STM   14,13,SAVE              SAVE REGISTERS               174
         L     BASE,VIBCOM2            GET ADDRESS OF CSECT TWO     174
         B     OFFRWND(0,BASE)         GO TO REWIND                 174
FEOFM    EQU   *
         AIF   (&ERR EQ 0).IB75                                     174
         CLI   SAVE,ON                 ATTEMPT TO DO I/O DURING A FIXUP
         BNE   ERR904                  FOR AN I/O ERROR? YES BRANCH
.IB75    STM   14,13,SAVE              SAVE REGISTERS               174
         L     BASE,VIBCOM2            GET ADDRESS OF CSECT TWO     174
         B     OFFEOFM(0,BASE)         GO TO WRITE TAPE MARK        174
         DROP  L                                                    174
*
         EJECT
* CALLING SEQUENCE
*        L         L,=V(IBCOM#)
*        BAL       R,52(L)             FSTOP
*             OR
*        BAL       R,56(L)             FPAUS
*        DC        AL1(LENGTH)
*        DC        C'TEXT'
*                  WHERE LENGTH IS THE NUMBER OF SUBSEQUENT TEXT BYTES,
*                  AND TEXT IS A NUMBER OR MESSAGE IN ALPHAMERIC FORM.
         SPACE     3
* ERROR CONDITIONS
*        NONE
         SPACE     3
*
* WRITE TO OPERATOR
*
         USING IBCOM#,L                                             174
FSTOP    EQU   *
         AIF   (&ERR EQ 0).IB64
         CLI   SAVE,ON            ATTEMPT TO DO I/O DURING FIXUP
         BNE   ERR904             FOR AN I/O ERROR? YES, BRANCH
.IB64    STM   14,6,SAVE               SAVE REGISTERS               174
         L     BASE,VIBCOM2            GET ADDRESS OF CSECT TWO     174
         B     OFFSTOP(0,BASE)         GO TO STOP                   174
FPAUS    EQU   *
         AIF   (&ERR EQ 0).IB76
         CLI   SAVE,ON            ATTEMPT TO DO I/O DURING FIXUP
         BNE   ERR904             FOR AN I/O ERROR? YES, BRANCH
.IB76    STM   14,6,SAVE               SAVE REGISTERS               174
         L     BASE,VIBCOM2            GET ADDRESS OF CSECT TWO     174
         B     OFFPAUS(0,BASE)         GO TO PAUSE                  174
         DROP  L                                                    174
         SPACE 8                                                    174
* CALLING SEQUENCE
*        L         L,=V(IBCOM#)
*        BAL       R,64(L)             IBFINT
         SPACE     3
* ERROR CONDITIONS
*        NONE
         SPACE     3
*
* INITIALIZATION AT BEGINNING OF PROBLEM PROGRAM
*
         USING IBCOM#,L
IBFINT   ST    13,REG13      STORE FOR IHCTRCH                     HWRE
         STM   14,5,SAVE                                           HWRE
         L     BASE,VIBCOM2            GET ADDRESS OF CSECT TWO
         B     OFFINT(0,BASE)          BRANCH TO INITIALIZE FORTRAN
         DROP  L
         EJECT
* CALLING SEQUENCE
*        L         L,=V(IBCOM#)
*        BAL       R,68(L)             IBEXIT
*        DC        AL2(CODE)
         SPACE     3
* ERROR CONDITIONS
*        NONE
         SPACE     3
*
* JOB TERMINATION
*
         USING IBCOM#,L
IBEXIT   L     BASE,VIBCOM2            GET ADDRESS OF CSECT TWO
         B     OFFEXIT(0,BASE)         GO TO TERMINATE FORTRAN EXECUTIO
         DROP  L
*
         EJECT
*
* DATA AND STORAGE AREAS
*
         AIF   (&ERR EQ 1).IB24
ADERRNO  DC    A(0)
         DC    A(0)
         DC    XL1'80'
         DC    AL3(ERRORNO)
ERRORNO  DC    F'0'
         AGO   .IB25
.IB24    ANOP
VIHCERRE DC    V(IHCERRE)
PARMR211 DC    A(PRAMS211)
PARAM212 DC    A(PRAMS212)
PARAM213 DC    A(PRAMS213)
PARAM231 DC    A(PRAMS231)
BASESAVE DS    3F
DSRNPTR  DS    F
GOTAD    DC    F'0'
.IB25    ANOP
OUTPTR  DC  XL4'04000000'                                         24793
VIBCOM2  DC    V(IHCCOMH2)
VIHCERRM DC    V(IHCERRM)
CURRENT  DS    0F
LSTGRP   DS    1F                      LAST LEFT PARENTHESIS
NEWPAR   DS    1F
COUNTS   DS    0F
GCOUNT   DC    AL1(0)                  CURRENT GROUP COUNT
GCSAVE   DC    AL1(0)                  LAST GROUP COUNT
FCOUNT   DC    AL1(0)                  FIELD COUNT
SCALEF   DC    AL1(0)                  CURRENT SCALE FACTOR
SECLEV   DS    0F
SAVPTR   DS    1F                 FIRST LEVEL POSITION
OLDPAR   DS    1F
SAVCNT   DC    AL2(0)                  FIRST LEVEL COUNTS
CTYPSW   DC    AL1(0)                  COMPLEX FIRST-HALF SWITCH
         AIF   (&ERR EQ 0).IB4
SKPLIST  DC    AL1(0)
.IB4     ANOP
         DS    0F
VFIOCS   DC        AL4(FIOCS#)
DFIOCS   DS        1F                  CURRENT I/O INTERFACE
VADCON   DC        AL4(ADCON#)
VARITH   DC    A(ARITH#)                                           HWRE
VFCVEO   DC        A(FCVEOUTP)
VFCVLO   DC        A(FCVLOUTP)
VFCVIO   DC        A(FCVIOUTP)
VFCVCO   DC        A(FCVCOUTP)
VFCVAO   DC        A(FCVAOUTP)
VFCVZO   DC        A(FCVZOUTP)
USEROPT  DC    A(IHCUOPT)                                          HWRE
VADJSW   DC    A(ADJSWTCH)                                         HWRE
VFCVDO   EQU       VFCVEO
*
PICAHOLD DS    F                                                   HWRE
KEEP     DS        10F                 OWN REGISTER STORAGE
UNITWD   DS        1F                  UNIT AND FORMAT PARAMETERS
FORMWD   DS        1F                     ARE MOVED HERE.
STASH    DS        2F                  LIST PARAMETERS
BUFADD   DS        1F                  START OF RECORD
FMTDIG   DC        AL4(0)              DIGIT STORAGE
FMTNUM   DC        AL4(0)              INTEGER STORAGE
SAVES1   DS        6F                  MAIN SCAN REGISTERS
SAVES2   DS        6F                  OWN SCAN REGISTERS
TGROUP   DC        AL4(0)              VARIABLE FORMAT GROUP
QSAVE    DS        1F                  START OF LITERAL
MOVE1    MVC       0(1,FMTPTR),0(BUFPTR)  RECORD TO FORMAT
MOVE2    MVC       0(1,BUFPTR),0(FMTPTR)  FORMAT TO RECORD
MOVE3    MVC       0(1,GRX),0(BUFPTR)  RECORD TO INPUT ITEM
MOVE4    MVC       0(1,BUFPTR),0(GRX)  OUTPUT ITEM TO RECORD
LAGRX    LA        GRX,0(0,0)          INSTRUCTION MASK
NOPB2    BCR       0,0                 TWO-BYTE NOP
ONE      DC        AL2(1)
TWO      DC        AL2(2)
FOUR     DC        AL2(4)
FMTSWS   DS        0F
EFMTSW   DC        AL1(0)              END-FORMAT INDICATOR
ARRSW    DC        AL1(0)              ARRAY INDICATOR
         DC    AL1(0)                  NECESSARY - DO NOT DELETE.  6002
GFMTSW   DC        AL1(0)              G-FORMAT SWITCH
BUFPTRHI DC    A(0)                    IF T-CODE USED, HIGHEST     6002C
                                       PREVIOUS RECORD PTR SETTING.6002
MTYPE    DC        AL1(0)              MODE - TYPE
TDECSW   DC        AL1(0)              VARIABLE FORMAT DECIMAL
QSTOP    DC        AL1(0)              LITERAL STOP SWITCH
QUOTE    DC        AL1(0)              FIRST QUOTE SCANNED
FQUALS   DC        AL1(0)              FILE QUALIFIER STORAGE
GOWHR    DC    AL1(0)                  RTN SW FROM NEWREC           174
ITEM     DC    AL2(0)                  HOLDS LENGTH OF ARRAY ITEM   174
MASK     DC    X'000FFFFF'             CLEARS 1ST 12 BITS OF REG    174
FULLIT   DS    1F                      CONSTANT FOR EVEN ITEM WRITE 174
*
REG6     DS        1F                                             45029
REG13    DS        1F
RETCOD   DS        0D
         DC        XL8'0'              CODE STORAGE
PAUSE    DC        AL4(0)              WTOR ECB
ANSWER   DC        AL1(0)
EXITSW   DC        AL1(0)              SET ON BY STOP, OFF BY PAUSE
INTSW    DC        AL1(0)
INTSWTCH EQU   INTSW
MSTOP    DC        C'2I STOP  '
MPAWS    DC        C'1A PAUSE '
STAEBLK  DC    F'0'                                               II295
STAESW   DC    X'00'                                              II295
MAIN2SW  DC  XL1'00'   SWITCH TO INDIC MULT ENT               61497 1/7
*
         TITLE     'IHCCOMH2'
IHCCOMH2 CSECT
IBCOM2   EQU   *
         ENTRY SEQDASD
         USING *,BASE
EXITRTN1     EQU *                                            60647 1/6
             USING  EXITRTN1,15      ESTABLISH ADDRESSABILITY
             CL    0,TWELVE IS THERE BAD RETURN CODE -        60647 1/6
*                           SPACE FOR SAVE AREA IN SUPV NOT AVAIL
             BNE   GOODRETC   NO  CONTINUE                    60647 2/6
             LA   13,IB2SAV  SET FOR SAVE AREA WITHIN IBCOM   60647 3/6
GOODRETC     STM  14,12,12(13)    SAVE STAE'S REGS            60647 4/6
         L     8,VIBCOM            GET ADDR OF CSECT 1            II295
         USING IBCOM#,8                                           II295
         ST    13,SAVEREGS+4       STORE BACKWARD PTR             II295
         LR    12,13                                              II295
         LA    13,SAVEREGS                                        II295
       ST    13,8(0,12)                                           II295
         LR    7,1                 SAVE REGISTER 1                II295
         LR    6,0                SAVE RET CODE FOR STAE          II295
         LA    3,STAEBLK          ADDR OF REG SAVE WORD           II295
         ST    3,BLKPTR           STORE IT FOR STAE               II295
         MVC   REG13A(4),REG13    GET MAIN SAVEAREA PTR FOR STAE  37107
* LOAD EP=IHCSTAE                                                 II295
         LOAD  EP=IHCSTAE                                         II295
         MVI   STAESW,X'FF'       TURN ON STAE PROCESSING SWITCH  II295
         LR    15,0                ADDR OF LOAD PT OF STAE ROUTINE
         CNOP  2,4                                                II295
         BALR  3,15               GO TO STAE                      II295
VIBCOM   DC    V(IBCOM#)                                          II295
VERRMON  DC    V(IHCERRM)                                         II295
BLKPTR   DS    F'0'                                               II295
REG13A   DS    F                  REG 13 FOR IHCSTAE              37107
SAVEREGS DS    18F                                                II295
IB2SAV     DC   18F'0'     TEMP SAVE IF NO CORE               60647 5/6
TWELVE  DC  X'0000000C'       TWELVE                          60647 6/6
         DROP  15                                                 II295
         DROP  8                                                  II295
         EJECT
IBEXIT2  EQU   *
         USING IBCOM#,CALLER
         LR    CALLER,L                SET UP ADDRESSABILITY
      MVI   MAIN2SW,0    RESET FOR RE-USEABILITY             61497 2/7
         LH    SPILL,0(0,R)            GET RETURN CODE TO BE PASSED TO
*                                      THE OPERATING SYSTEM
TRYAGN   EQU   *
         AIF   (&ERR EQ 0).IBC1
         LA    13,ERRSAV               SET UP SAVE AREA ADDRESS
         L     15,VIHCERRE             CALL THE ERROR MONITOR TO GIVE A
         BALR  14,15                   ERROR SUMMARY.
.IBC1    ANOP
         L         1,VFIOCS
         BALR      0,1                 CLOSE ALL FILES
         DC        AL1(TERM)
         DC        AL1(NULL)
         B     TRYAGN
         LA        0,SEQDASD           PICKUP ERROR ADDRESS
         L         1,FDIOCS#
         CR        0,1                 WAS DIOCS EVER CALLED
         BC        EQUAL,DOSPIE        NO, SKIP SECOND CLOSE.
         BALR      0,1                 YES, CLOSE DA DATA SETS.
         DC        AL1(TERM)
         DC        AL1(NULL)
         B     TRYAGN                  IF ERROR GO TO CLOSE FIOCS AGAIN
DOSPIE   EQU   *                                                   BNDR
         L     1,VADJSW      OBTAIN ADDRESS OF ADJUST SWITCH       HWRE
         CLI   0(1),X'00'    WAS ADJUST LOADED                     HWRE
         BE    RSTORE                                              HWRE
         MVI   0(1),X'00'    RESET ADJUST SWITCH TO OFF            HWRE
* DELETE EP=IHCADJST
         DELETE EP=IHCADJST                                        BNDR
RSTORE   L     1,PICAHOLD    OBTAIN ADDRESS OF PREVIOUS PICA       HWRE
*  FOLLOWING 2 INSTRUCTIONS DELETED, APAR 59714
*    LTR  1,1
*   BZ  REGLOAD
*
* SPIE MF=(E,(1))
         SPIE  MF=(E,(1))                                          HWRE
         B     STAECALL                                           II295
* SPIE
REGLOAD  SPIE
* STAE 0                                                          37107
STAECALL STAE 0                                                   37107
         CLI   STAESW,X'FF'        DID WE COME FROM STAE ROUTINE?
         BNE   RELOAD                                             37107
         L     1,STAEBLK           RESTORE STAE CONTROL BLOCK PTR
         LM    2,4,32(1)                                          II295
         LM    6,15,48(1)                                         II295
*        ABEND 240,DUMP                                           29323
         ABEND 240,DUMP                                           29323
RELOAD   L     S,REG13       SAVE AREA PTR PASSED BY MAIN          BNDR
         L         R,12(0,S)           GET RETURN ADDRESS
         AIF   (&ERR EQ 0).IB0021
         L     2,VIHCERRM
         MVI   19(2),0            TURN SUMMARY SWITCH IN IHCERRM TO YES
.IB0021  ANOP
         LR        L,SPILL             PICKUP RETURN CODE
         LM        0,12,20(S)          RESTORE REGISTERS
         BCR       ALWAYS,R            RETURN TO SUPERVISOR
         DROP  CALLER
*
OFFEXIT  EQU   IBEXIT2-IBCOM2
         EJECT
CONTIBFN EQU   *
         USING IBCOM#,GRX
         LR    GRX,L                   SET UP ADDRESSABILITY
         L     SPILL,16(S)             GET ADDR OF MAIN RTN ENTRYPT4594
         ST    SPILL,MAINEP            STORE FOR TRACEBACK         4594
         L     SPILL,USEROPT           TEST IF BOUNDARY ADJUSTMENT BNDR
         L     GRY,VARITH              GET ADDR. OF INTERRUPT HANDLER
         TM    4(SPILL),X'40'          BOUNDARY ALIGNMENT TO OCCUR
         BZ    IBFINT1                 BRANCH IF NO BOUND. ADJ.    BNDR
* SPIE (3),(6,9,11,12,13,15)
         SPIE  (3),(6,9,11,12,13,15)
         B     IBFINT2                                             BNDR
* SPIE (3),(9,11,12,13,15)
IBFINT1  SPIE  (3),(9,11,12,13,15)
IBFINT2  ST    1,PICAHOLD              SAVE PREVIOUS PICA
         L     1,VFIOCS                                           24793
         LR    SPILL,GRX                                          24793
         LA    GRX,OUTPTR          PARAMS TO OPEN OBJ ERR UNIT    24793
         BALR  0,1                                                24793
               DC  XL2'00FF'                                      24793
          NOP  0                                                  24793
         LR    GRX,SPILL                                          24793
      CLI   MAIN2SW,0   IS THIS FIRST TIME THRU IBCOM INIT   61497 3/7
      MVI   MAIN2SW,X'FF'  INDICATE PASSED THRU THIS CODE    61497 4/7
         MVI   SAVE,ON                 RESET I/O ENDED SWITCH
      BNE  LOOPOUT YES-RETURN TO PROG-POSSIBILITY OF LOOP    61497 5/7
*        STAE      EXITRTN1,ASYNCH=YES                            52394
         STAE      EXITRTN1,ASYNCH=YES                            52394
LOOPOUT    LM  14,5,SAVE     RESTORE  REGISTERS              61497 6/7
         BR    R                       RETURN
         DROP  GRX
OFFINT   EQU   CONTIBFN-IBCOM2
         EJECT
FRWND2   MVI   CTLSW,RWND              SET FOR REWIND               174
         BC    ALWAYS,CTLCOM           GO TO DO REWIND              174
*
FEOFM2   MVI   CTLSW,EOFM              SET FOR WRITE TAPE MARK      174
         SPACE 3
*
CTLCOM   EQU   *
         USING IBCOM#,CALLER                                        174
         LR    CALLER,L                SET UP ADDRESSIBILITY        174
         LR        GRX,R               PICKUP PARAMETER POINTER
         L         1,VFIOCS
         BALR      0,1                 PERFORM INDICATED CONTROL
         DC        AL1(CTRL)
CTLSW    DC        AL1(0)
         NOP   0
         MVI   SAVE,ON                 RESTORE I/O ENDED SWITCH
         LM    0,6,SAVE+8              RESTORE MAIN REGISTERS       174
         BC    ALWAYS,4(0,R)           RETURN TO MAIN PROGRAM
*
         DROP  CALLER                                               174
OFFRWND  EQU   FRWND2-IBCOM2                                        174
OFFEOFM  EQU   FEOFM2-IBCOM2                                        174
         EJECT
         DS    0H
         USING IBCOM#,CALLER                                        174
FSTOP2   LR    CALLER,L                SET UP ADDRESSIBILITY        174
      MVI  MAIN2SW,0  RESET FOR RE-USEABILITY                61497 7/7
         MVI   EXITSW,ON               SET FOR MONITOR EXIT         174
         BC    ALWAYS,WTOCOM           GO TO WRITE STOP             174
*
FPAUS2   LR    CALLER,L                SET UP ADDRESSIBILITY        174
         MVI   EXITSW,OFF              SET VS. MONITOR EXIT         174
         NI    PAUSE,X'BF'             TURN OFF COMPLETED FLAG     8460
*                            (BIT 1) IN ECB NAMED PAUSE            8460
         SPACE 3
*
WTOCOM   BCR   5,0                MOD 91 PIPE LINE DRAIN INSTRUCTION
         TM        EXITSW,ON
         BC        ALL,STOPPR          BRANCH IF STOP
         MVC       WTOMES+5(9),MPAWS
         LA        1,OREPLY
         BC        ALWAYS,GETCNT
STOPPR   MVC       WTOMES+5(9),MSTOP
       LA    1,MESLEN-1                                           18035
GETCNT   SR        SPILL,SPILL
         IC        SPILL,0(0,R)        GET NUMBER OF BYTES IN MESSAGE
         LR        GRY,SPILL
         CH        SPILL,MESMAX
         BC        LOEQ,WTOMOV         BRANCH IF WITHIN LIMITS
         LH        GRY,MESMAX          SET TO MAXIMUM LENGTH
WTOMOV   BCTR      GRY,0
         EX        GRY,MOVEO           MOVE MESSAGE INTO CALL
       CLI   EXITSW,X'00'                                         18035
       BE    CONT                                                18035
       PACK  RETCOD+5(3),WTOMES+14(5)                             18035
       CVB   SPILL,RETCOD          CONVERT STOP CODE TO BINARY    18035
       STH   SPILL,XITCOD                                         18035
       LTR   SPILL,SPILL           TEST FOR STOP 0                18035
       BZ    RESUME                DON'T ISSUE WTO IF STOP 0      18035
CONT   LA    GRX,19(0,GRY)                                        18035
       STH   GRX,MESLEN-1                                         18035
       A     GRX,MESADR                                           18035
       TM    EXITSW,ON                                            18035
       BC    ALL,STOPCD            BRANCH FOR STOP CODE           18035
       MVC   0(2,GRX),DESCD2                                      18035
       MVI   2(GRX),X'80'          PAUSE CODE INSERTED            18035
       BC    ALWAYS,PADDER                                        18035
STOPCD MVC   0(2,GRX),DESCD1                                      18035
       MVI   2(GRX),X'40'          STOP ROUTING CODE              18035
PADDER MVI   3(GRX),X'00'          STOP CODE INSERTED             18035
       B     WTOSVC                                               18035
       CNOP  0,4                                                  18035
OREPLY DC    AL1(1)                LENGTH OF REPLY                18035
       DC    AL3(ANSWER)           REQUESTOR'S REPLY BUFFER ADDR. 18035
       DC    AL4(PAUSE)            REQUESTOR'S REPLY ECB POINTER  18035
       DC    AL1(0)                ZERO                           18035
MESLEN DC    AL1(0)                MESSAGE LENGTH FIELD           18035
       DC    X'80'                 MCSFLAGS-ROUTING CODES EXIT    18035
       DC    AL1(0)                                               18035
WTOMES DC    C'IHC00'                                             18035
       DC    67C' '                                               18035
       DS    CL4                                                  18035
MESMAX DC    H'58'                                                18035
DESCD1 DC    X'02'                 STOP DESCRIPTOR CODE           18035
       DC    X'00'                                                18035
DESCD2 DC    X'40'                 PAUSE DESCRIPTOR CODE          18035
       DC    X'00'                                                18035
WTOSVC DS    0H                                                   18035
       SVC   35                                                   18035
       MVI   SAVE,ON               RESET I/O ENDED SWITCH         18035
         TM        EXITSW,ON
         BC        NONE,PAUSER         BRANCH IF PAUSE
RESUME LM    14,6,SAVE                                            18035
         BAL   R,68(0,L)               TERMINATE JOB
XITCOD   DC    AL2(0)
MESADR DC    A(MESLEN-1)                                          18035
*
PAUSER   L     R,SAVE                                              HWRE
         LA    R,1(SPILL,R)            COMPUTE RETURN ADDRESS
         ST    R,SAVE                                              HWRE
         MVI   SAVE,ON                 RESET I/O ENDED SWITCH
*        WAIT  1,ECB=PAUSE
         WAIT  1,ECB=PAUSE
         LM    14,6,SAVE                                           HWRE
         BCR   ALWAYS,R                RETURN TO MAIN PROGRAM
MOVEO    MVC   WTOMES+14(1),1(R)       OPERATOR MESSAGE TO CALL
*
         DROP  CALLER                                               174
OFFSTOP  EQU   FSTOP2-IBCOM2                                        174
OFFPAUS  EQU   FPAUS2-IBCOM2                                        174
         EJECT
         AIF   (&ERR EQ 0).IB55
         SPACE 3
         USING IBCOM#,L
E904     LA    GRX,OUTPTR              POINT TO OBJECT ERROR UNIT
         SR    0,0                     ZERO OUT ERR= EXIT ADDRESS
         ST    0,IOERROR
         L     1,VFIOCS                INITIALIZE FIOCS
         BALR  0,1
         DC    XL2'00FF'
         B     TRM904                  IF ERROR OCCURRED FORGET IT
         MVC   1(E904LN,GRX),MS904     MOVE MESSAGE TO BUFFER
         MVI   0(GRX),C'0'             MOVE IN CONTROL CHAR.
         LA    GRX,E904LN+1            LENGTH OF MSG FOR FIOCS#   19720
         L     1,VFIOCS                WRITE MESSAGE
         BALR  0,1
         DC    XL2'0200'
         NOP   0
TRM904   EQU   *
         MVI   SAVE,ON
         BAL   R,68(0,L)               TERMINATE JOB VIA IBEXIT
         DC    AL2(16)
         DROP  L
OFF904   EQU   E904-IBCOM2
         EJECT
.IB55    ANOP
         SPACE 3
SEQDASD  DS    0H
         USING IBCOM#,15
         USING *,1
         AIF   (&ERR EQ 0).IB34
         TM    0(GRX),VDSRN            IS IT A POINTER TO THE DSRN
         L     GRX,0(0,GRX)            GET DSRN OR ADDRESS OF DSRN
         BZ    *+8                     IF NOT ADDRESS BRANCH
         L     GRX,0(0,GRX)            GET DSRN
         STH   GRX,DSRN+2
         L     3,PARAM231              GIVE MESSAGE 231
         LR    BUFPTR,0                SAVE RETURN ADDRESS TO IBCOM
         BAL   LNK,COMINTFC            OUTPUT THE MESSAGE
         NOP   0                       STANDARD FIXUP AND
RET231   SR    GRY,GRY                 USER FIXUP SAME(I.E. IGNORE
         B     2(0,BUFPTR)             REMAINDER OF I/O REQUEST)
         AGO   .IB35
.IB34    LA    1,231
         B     COMERRHN
.IB35    ANOP
         DROP  1
         DROP  15
*
* TRANSLATE AND TEST TABLE FOR VARIABLE FORMATS
*
TRTSTB   DS        0F
         DC    16X'54'                                            22019
         DC    16X'54'                                            22019
         DC    16X'54'                                            22019
         DC    16X'54'                                            22019
         DC    X'00'                   BLANK                      22019
         DC    8X'54'                                             22019
         DC    X'44'                   PERIOD                     22019
         DC    X'54'                                              22019
         DC    X'44'                   PERIOD                     22019
         DC    X'50'                   RIGHT PAREN (BCD)          22019
         DC    X'08'                   LEFT PAREN (EBCDIC)        22019
         DC    15X'54'                                            22019
         DC    X'50'                   RIGHT PAREN (EBCDIC)       22019
         DC    2X'54'                                             22019
         DC    X'1C'                   MINUS                      22019
         DC    X'4C'                   SLASH                      22019
         DC    7X'54'                                             22019
         DC    X'48'                   COMMA                      22019
         DC    X'54'                                              22019
         DC    X'48'                   COMMA                      22019
         DC    X'08'                   LEFT PAREN (BCD)           22019
         DC    15X'54'                                            22019
         DC    X'40'                   QUOTE (BCD)                22019
         DC    X'40'                   QUOTE (EBCDIC)             22019
         DC    16X'54'                                            22019
         DC    16X'54'                                            22019
         DC    16X'54'                                            22019
         DC    16X'54'                                            22019
         DC    3X'54'                                             22019
         DC    X'0C'                   CHAR A                     22019
         DC    2X'54'                                             22019
         DC    X'2C'                   CHAR D                     22019
         DC    X'28'                   CHAR E                     22019
         DC    X'24'                   CHAR F                     22019
         DC    X'30'                   CHAR G                     22019
         DC    X'3C'                   CHAR H                     22019
         DC    X'18'                   CHAR I                     22019
         DC    9X'54'                                             22019
         DC    X'10'                   CHAR L                     22019
         DC    3X'54'                                             22019
         DC    X'20'                   CHAR P                     22019
         DC    11X'54'                                            22019
         DC    X'34'                   CHAR T                     22019
         DC    3X'54'                                             22019
         DC    X'38'                   CHAR X                     22019
         DC    X'54'                                              22019
         DC    X'14'                   CHAR Z                     22019
         DC    6X'54'                                             22019
         DC    10X'04'                 DIGITS 0 - 9               22019
         DC    6X'54'                                             22019
*
OFFTRT   EQU   TRTSTB-IBCOM2
         EJECT
         AIF   (&ERR EQ 0).IB29
PRAMS211 EQU   *
         DC    A(MSG211)               ADDRESS OF THE MESSAGE
         DC    A(RTCD)                 ADDRESS OF THE RETURN CODE FIELD
         DC    A(E211)                 ADDRESS OF THE ERROR NUMBER
         DC    A(0)                    ADDRESS OF BAD CHARACTER
PRAMS212 EQU   *
         DC    A(MSG212)
         DC    A(RTCD)
         DC    A(E212)
         DC    XL1'80'
         DC    AL3(DSRN)               ADDRESS OF THE UNIT ON WHICH
*                                      ERROR OCCURRED
PRAMS213 EQU   *
         DC    A(MSG213)
         DC    A(RTCD)
         DC    A(E213)
         DC    XL1'80'
         DC    AL3(DSRN)
PRAMS231 EQU   *
         DC    A(MSG231)
         DC    A(RTCD)
         DC    A(E231)
         DC    XL1'80'
         DC    AL3(DSRN)
E211     DC    F'211'
E212     DC    F'212'
E213     DC    F'213'
E231     DC    F'231'
RTCD     DC    F'0'
         EJECT
*     MESSAGES
COMPILED DC    C'COMPILED'
VARIABLE DC    C'VARIABLE'
MSG211   DC    A(MSG211E-MSG211B)
MSG211B  DC    C'IHC211I IBCOM - ILLEGAL '
MSG211M  DC    C'        '
         DC    C' FORMAT CHARACTER SPECIFIED '
FMTCHR   DC    C' '
MSG211E  EQU   *
MSG212   DC    A(MSG212E-MSG212B)
MSG212B  DC    C'IHC212I IBCOM - FORMATTED I/O, END OF RECORD ON UNIT  X
                  '
MSG212E  EQU   *
MSG213   DC    A(MSG213E-MSG213B)
MSG213B  DC    C'IHC213I IBCOM - UNFORMATTED READ, END OF RECORD ON UNIX
               T     '
MSG213E  EQU   *
MSG231   DC    A(MSG231E-MSG231B)
MSG231B  DC    C'IHC231I IBCOM - DIRECT ACCESS STATEMENT USED WITHOUT DX
               EFINE FILE ON UNIT     '
MSG231E  EQU   *
MS904    DC    C'IHC904I ATTEMPT TO DO I/O DURING FIXUP ROUTINE FOR AN X
               I/O TYPE ERROR'
E904LN   EQU   *-MS904
.IB29    ANOP
         MEND
