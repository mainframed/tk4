    AECATLG - AN OS/360 CATALOG MAINTENANCE UTILITY PROGRAM
    -------------------------------------------------------

CATALOG STRUCTURE
-----------------

  THE STRUCTURE OF OS/360 CATALOGS IS ESSENTIALLY ONE OF A RECURSIVE
SET OF INDEXES, WHOSE ENTRIES CONTAIN POINTERS TO LOWER LEVEL INDEXES
& FINALLY TO DATASET LOCATIONS BY VOLUME TYPE & LABEL. INDEX ENTRIES
ARE IDENTIFIED BY 8-BYTE NAMES, ARE 12 TO 74 BYTES LONG EACH, & WITHIN
EACH INDEX ARE ARRANGED IN ALPHABETICAL ORDER. EACH INDEX OF ENTRIES IS
DIVIDED INTO AS MANY 256-BYTE BLOCKS AS NECESSARY TO CONTAIN THE WHOLE
INDEX. THESE BLOCKS MAY OR NOT BE CONTIGUOUS IN THE DATASET WHICH IS
THE CATALOG.


CATALOG MANAGEMENT
------------------

  CATALOG OPERATIONS TYPICALLY CONSIST OF SEARCHES DOWN SEVERAL INDEXES,
& THESE SEARCHES ARE MORE EFFICIENT IF LOGICALLY CONSECUTIVE INDEX
BLOCKS ARE ALSO PHYSICALLY CONSECUTIVE. IN FACT AS MANY EXCP'S ARE
REQUIRED ON EACH INDEX AS THERE ARE DISCONTIGUOUS BLOCKS DOWN TO THE
POINT OF THE ALPHABET WHERE THE DESIRED ENTRY LIES. IF ALL BLOCKS IN
EACH INDEX ARE CONTIGUOUS, ONLY ONE EXCP PER INDEX IS REQUIRED & ANY
DECISION MAKING NECESSARY TO FIND THE BLOCK CONTAINING THE WANTED ENTRY
IS DONE BY CONDITIONAL CCW COMMANDS (SEARCH KEY HIGH OR EQUAL).

  OS/360 CATALOG MANANGEMENT ROUTINES NEVER ATTEMPT TO PLACE LOGICALLY
ADJACENT BLOCKS PHYSICALLY ADJACENT, ALTHOUGH THEY SOMETIMES
ACCIDENTALLY DO. IN FACT, IF A CATALOG WITH NO PHYSICAL BREAKS IN ITS
INDEXES IS COPIED WITH IEHMOVE, ALMOST NO CONSECUTIVE BLOCKS OF THE SAME
INDEX ARE LEFT ADJACENT.


THE AECATLG UTILITY
-------------------

  IT IS THEREFORE DESIRABLE TO HAVE A UTILITY TO 'STRAIGHTEN' A CATALOG
AS A REDUCTION IN SYSTEM OVERHEAD WILL BE ACHIEVED DURING EVERY CATALOG
REFERENCE THEREAFTER. AECATLG IS SUCH A UTILITY. IT COPIES AN ENTIRE
DATASET WITH AN OS CATALOG STRUCTURE, INDEX BY INDEX, USING A RECURSIVE
ROUTINE WHICH ADJUSTS ALL THE TTR POINTERS & LEAVES THE BLOCKS OF EACH
INDEX CONTIGUOUS. NULL BLOCKS (RESULTING FROM THE DELETION OF ALL NAMES
UNDER A GIVEN INDEX) MAY BE OPTIONALLY DELETED & REPORTED. THESE
CAPABILITIES ARE NOT PROVIDED AT ALL BY OS CATALOG MANAGEMENT.

  THE PROGRAM CAN BE USED IN THIS FORM TO MAKE A DUPLICATE OR BACKUP
CATALOG, BUT OF COURSE THIS DOES NOT ALLOW THE SYSTEM CATALOG OR A
SUBCATALOG TO BE STRAIGHTENED WITHOUT QUIESCING A RUNNING SYSTEM. IF THE
SYSTEM IS QUIESCED & THE CATALOG COPIED TO A BACKUP LOCATION & BACK
AGAIN, THE OCCURRENCE OF A SYSTEM CRASH DURING THE COPY BACK WILL LEAVE
THE SYSTEM WITHOUT A CATALOG, PROBABLY REQUIRING THE CALLING OF EXPERTS
TO RECOVER.


ONLINE OPERATION
----------------

  A SCHEME HAS THEREFORE BEEN BUILT INTO AECATLG TO STRAIGHTEN A SYSTEM
CATALOG EFFECTIVELY IN-PLACE, IN AN UTTERLY FAIL-SAFE MANNER, & WHILE
THE SYSTEM IS RUNNING. THIS INVOLVES COPYING THE CATALOG TO ANOTHER
DATASET ON THE SAME VOLUME, RENAMING BOTH DATASETS, & COPYING BACK
AGAIN. IN DETAIL THE PROCEDURE IS:-

    1.   ENQ THE CATALOG FOR EXCLUSIVE USE. THIS WILL STOP ALL CATALOG
         MANAGEMENT ROUTINES FROM ACCESSING THE CATALOG.

    2.   CHECK THAT A DATASET SYSCTLG.BACKUP EXISTS ON THE SAME VOLUME
         AS SYSCTLG.

    3.   COPY THE CATALOG, WITH BLOCK RESTRUCTURING, TO THE DATASET
         SYSCTLG.BACKUP WHICH MUST BE PREALLOCATED ON THE SAME VOLUME.

    4.   USING DIRECT VTOC I/O, CHANGE THE NAME OF THIS DATASET TO
         SYSCTLG (LEAVING TWO VALID SYSCTLG DATASETS ON THE SAME
         VOLUME).

    5.   CHANGE THE NAME OF THE ORIGINAL SYSCTLG TO SYSCTLG.BACKUP.

    6.   IF THE DSCB ADDRESS OF THE NEW SYSCTLG IS HIGHER THAN THAT OF
         SYSCTLG.BACKUP, GO BACK TO STEP3. (IT IS ASSUMED THAT OF THE
         DATASETS SYSCTLG & SYSCTLG.BACKUP, THE ONE INTENDED TO BE THE
         WORKING CATALOG WILL HAVE THE LOWER DSCB ADDRESS.)

    7.   DEQ THE CATALOG.

  THUS TO PREPARE FOR AECATLG USE, ONE MERELY ALLOCATES A DATASET ON
THE SAME VOLUME AS EACH CATALOG OR SUB-CATALOG WITH ENOUGH SPACE TO
CONTAIN A DUPLICATE CATALOG. NORMAL USE OF AECATLG WILL COPY TO & FROM
THIS EXTRA CATALOG, & LEAVE IT AS A BACKUP. IF A SYSTEM CRASH OCCURS AT
ANY TIME DURING AECATLG RUNNING, A VALID CATALOG ALWAYS EXISTS, & A
SUBSEQUENT RUN OF AECATLG WILL TIDY UP & RESTORE THE CORRECT CATALOG TO
NORMAL OPERATION BY COPYING THE CATALOG ONCE OR TWICE AS APPROPRIATE.


PERFORMANCE
-----------

  A SUMMARY OF THE STRUCTURE OF THE CATALOG BEFORE & AFTER STRAIGHTENING
IS PRINTED AFTER EACH COPY. THE REAL-TIME PERFORMANCE OF THE PROGRAM IS
DEPENDENT ON THE CATALOG SIZE, & THE REGION GIVEN TO THE PROGRAM. THE
MINIMUM REGION SIZE NECESSARY IS ABOUT 20K. THE MAXIMUM PERFORMANCE IS
ACHIEVED WHEN THERE IS ENOUGH STORAGE TO HOLD ALL ALLOCATED BLOCKS OF
THE CATALOG.

  AN EXAMPLE OF THE PROGRAM'S PERFORMANCE TO STRAIGHTEN A CATALOG IN
PLACE IS:-

          CATALOG SIZE    314 BLOCKS
          REGION USED     60K
          CPU TIME        1.1 SECONDS
          REAL TIME       4 SECONDS

  THUS IF THE PROGRAM IS USED ONLINE, CATALOG OPERATIONS ARE BANNED FOR
AROUND 4 SECONDS.


HOW TO USE THE PROGRAM
----------------------

  NO CONTROL STATEMENT INPUT IS NECESSARY TO RUN AECATLG; THE USER'S
REQUIREMENTS ARE SPECIFIED ENTIRELY BY JCL AS FOLLOWS:-

        //A        EXEC PGM=AECATLG(,PARM=K)
        //STEPLIB    DD PROGRAM LIBRARY IF NECESSARY
        //SYSPRINT   DD PRINT OUTPUT DATASET
        //SYSUT1     DD DISK DATASET (CATALOG INPUT)
        //SYSUT2     DD DISK DATASET (OPTIONAL CATALOG OUTPUT)

  THERE ARE TWO MODES OF RUNNING AECATLG - DISTINGUISHED BY THE PRESENCE
OR ABSENCE OF THE SYSUT2 DD STATEMENT. IF SYSUT2 IS PRESENT, THE
'COPY-ONLY' MODE IS USED; THE DISK DATASET SPECIFIED BY SYSUT1, WHICH
MUST HAVE THE STRUCTURE OF AN O/S CATALOG, IS COPIED TO THE DISK DATASET
SPECIFIED BY SYSUT2, WITH INDEX STRAIGHTENING. THE SYSUT2 DATASET WILL
BE GIVEN THE SPECIAL INDICATOR 0000FF(HEX) IN THE DS1LSTAR FIELD OF ITS
DSCB TO INDICATE TO CATALOG MANAGEMENT ROUTINES THAT IS A VALID CATALOG.
(CATALOG MANAGEMENT ROUTINES ALSO REQUIRE IT TO HAVE THE DSNAME
'SYSCTLG'.)

  IF THE SYSUT2 DDNAME IS NOT PRESENT, THE 'STRAIGHTEN-IN-PLACE' MODE
IS USED; THE SUFFIX '.BACKUP' IS APPENDED TO THE DSNAME GIVEN ON THE
SYSUT1 DD STATEMENT, & THE DSNAME SO FORMED IS EXPECTED TO BE PRESENT
ON THE SAME VOLUME. THE STRAIGHTEN-IN-PLACE PROCEDURE DESCRIBED ABOVE
IS THEN FOLLOWED. IF THE OPTIONAL PARM=K IS SPECIFIED, NULL ENTRIES IN
THE CATALOG ARE KEPT.

  AECATLG HAS NO INTERNAL KNOWLEDGE OF THE SPECIAL DSNAME 'SYSCTLG'
IT USES ONLY THE DSNAMES GIVEN IN THE SYSUT1 & SYSUT2 DD STATEMENTS.
THUS TO WORK ON THE SYSTEM CATALOG, DSN=SYSCTLG MUST BE SPECIFIED ON THE
SYSUT1 STATEMENT. THE PROGRAM DOES, HOWEVER, USE THE SPECIAL NAME
'SYSCTLG' TO ENQ EXCLUSIVELY ON THE CATALOG ON THE INPUT VOLUME,
WHATEVER DSNAME IS GIVEN. THIS ENQ HAS THE MAJOR NAME SYSCTLG & A MINOR
NAME OF 12 BYTES CONSISTING OF THE 8-BYTE MAJOR NAME WITH 4 BYTES
CONTAINING THE UCB ADDRESS APPENDED TO IT.

  THE WAY IN WHICH AECATLG IS USED AT AAEC IS AS FOLLOWS. EACH VOLUME
CONTAINING A SYSCTLG DATASET ALSO CONATAINS A DATASET NAMED
SYSCTLG.BACKUP WITH A HIGHER DSCB ADDRESS IN THE VTOC. PERIODICALLY,
AECATLG IS RUN ON EACH OF THESE VOLUMES IN THE STRAIGHTEN-IN-PLACE MODE.
THIS HAS THE DUAL FUNCTION OF PROVIDING A BACKUP COPY OF THE CATALOG IN
THE DATASET SYSCTLG.BACKUP & OF REPAIRING ANY INDEX BLOCK LINKS WHICH
MAY HAVE BECOME NON-CONTIGUOUS SINCE THE LAST RUN. IF THE MAIN CATALOG
IS EVER LOST, IT MAY BE QUICKLY RESTORED FROM THE BACKUP COPY USING
AECATLG IN ITS COPY ONLY MODE. IF A SYSTEM CRASH OCCURS DURING THE
AECATLG RUN, HASP AUTOMATICALLY RESTARTS THE AECATLG JOB AFTER THE
SYSTEM IS RESTORED. THIS RUN OF AECATLG WILL COPY THE CATALOG EITHER
ONCE OR TWICE AS NECESSARY TO RESTORE THE ORIGINAL CATALOG DEPENDING ON
HOW FAR THE INITIAL RUN GOT BEFORE THE SYSTEM CRASH.

  THE PROGRAM HAS BEEN TESTED UNDER A VARIETY OF CONDITIONS & IS
REGULARLY USED ONLINE UNDER THE OS RELEASE 21.7 SYSTEM AT AAEC. IT HAS
ALSO BEEN RUN SUCCESSFULLY UNDER VS1 & VS2 RELEASE 1 AT OTHER
INSTALLATIONS. (UNDER VS IT MUST BE LINKAGE-EDITED WITH THE
AUTHORISATION CODE 1 BECAUSE IT WRITES TO THE VTOC & ENQUEUES THE
CATALOG.) TO AAEC'S KNOWLEDGE, IT IS QUITE SAFE TO USE ON ANY SYSTEM
CATALOG. HOWEVER, NO RESPONSIBILITY CAN BE TAKEN BY AAEC FOR ANY DAMAGE
IT MAY DO TO ANY PART OF A USER'S COMPUTER SYSTEM. AAEC WOULD WELCOME
ANY COMMENTS OR REPORTS OF PROBLEMS REGARDING THE OPERATION OF THIS
PROGRAM.

//GWCAT     JOB ('********/S41AM002',W3),G.W.COX,CLASS=0,TIME=(,15),
//  COND=(0,NE)
/*ROUTE PRINT VIEW
/*JOBPARM L=10
//*
//A EXEC ASMFC
//SYSGO  DD  DISP=(MOD,PASS),DSN=&&OBJSET
//SYSIN DD  DISP=SHR,DSN=GWC.AECATLG.ASM(AECATLG)
//B EXEC ASMFC
//SYSGO  DD  DISP=(MOD,PASS),DSN=&&OBJSET
//SYSIN DD DISP=SHR,DSN=GWC.AECATLG.ASM(CPYCTL)
//A EXEC ASMFCL,PARM.LKED='LIST,MAP'
//SYSGO  DD  DISP=(MOD,PASS),DSN=&&OBJSET
//SYSIN DD  DISP=SHR,DSN=GWC.AECATLG.ASM(DSPEMON)
//LKED.SYSLMOD DD  DISP=SHR,DSN=GWC.LINKLIB
 ENTRY AECATLG
 SETCODE AC(1)
 NAME AECATLGN(R)
//*
//*
// END OF JCL
//*
//*
// START OF DUMMY DSPEMON
*        DUMMY EXIT ROUTINE 'DSPEMON'
DSPEMON  CSECT
         SR    15,15
         BR    14
         END
// END OF DUMMY DSPEMON
//*
//*
// START OF AECATLG
         TITLE 'AECATLG - MAIN PROGRAM'
* * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *
*                                                                     *
*        AECATLG COPIES AN O/S CATALOG IN SUCH A WAY THAT ALL INDEXES *
*        HAVE PHYSICALLY CONTIGUOUS BLOCKS SO THAT THE NUMBER OF I/O  *
*        OPERATIONS FOR A CATALOG LOOKUP IS MINIMISED.                *
*                                                                     *
*        IT CAN EITHER MAKE A BACKUP COPY OF A CATALOG, OR UPDATE     *
*        A CATALOG IN PLACE IN A WAY WHICH IS TRANSPARENT TO SYSTEM   *
*        CRASHES. IN EITHER CASE, THE INPUT CATALOG IS RESERVED TO    *
*        MAINTAIN SYSTEM AND CATALOG INTEGRITY.                       *
*                                                                     *
*                                                                     *
*        IT COPIES FROM SYSUT1 TO SYSUT2 IF BOTH DATASETS ARE PRESENT *
*        IF SYSUT1 ONLY IS PRESENT, IT COPIES FROM THE GIVEN DSNAME   *
*                                                                     *
*        (USUALLY 'SYSCTLG') TO 'DSNAME.BACKUP' WHICH SHOULD EXIST    *
*        ON THE SAME VOLUME.                                          *
*        IF 'DSNAME.BACKUP' DOES NOT EXIST, IT CHECKS FOR TWO 'DSNAME'*
*        DATASETS IN THE VTOC. IF THESE ARE FOUND, IT CHANGES THE     *
*        NAME OF THE SECOND ONE TO 'DSNAME.BACKUP' BEFORE PROCEEDING. *
*        AFTER COPYING TO 'DSNAME.BACKUP', IT SWAPS NAMES IN SUCH A   *
*        WAY THAT THE WORST STATE A SYSTEM CRASH COULD LEAVE BEHIND   *
*        IS A VTOC CONTAINING TWO 'DSNAME' ENTRIES.                   *
*        IF THE NEW 'DSNAME' HAS A HIGHER VTOC CCHHR THAN THE OLD,    *
*        THE COPY AND NAME-CHANGE PROCESSES ARE REPEATED              *
*                                                                     *
*        PARM= <SINGLE LETTERS, ANY ORDER>                            *
*              K : KEEP NULL ENTRIES                                  *
*              I : PRINT I/O SUMMARY                                  *
*              F : FORCE ZERO COND CODE WHEN UNREF BLKS PRESENT       *
*                                                                     *
*                                                                     *
*        NULL INDEXES ARE NORMALLY DELETED, HOWEVER, IF PARM=K        *
*        THEN NULL INDEXES ARE KEPT                                   *
*                                                                     *
* * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *
         EJECT
AECATLG  CSECT
         BC    15,12(,R15)
         DC    AL1(7),CL7'AECATLG'
         STM   R14,R12,12(R13)
         LR    R12,R15
         USING AECATLG,R12
         SR    R15,R15
         ST    R15,16(,R13)            INIT COND CODE
         LR    R11,R13
         LA    R13,SAVE                NEW SAVE AREA
         ST    R11,4(,R13)             LINK
         ST    R13,8(,R11)             SAVE AREAS
         SPACE
R0       EQU   0
R1       EQU   1
R2       EQU   2
R3       EQU   3
R4       EQU   4
R5       EQU   5
R6       EQU   6
R7       EQU   7
R8       EQU   8
R9       EQU   9
R10      EQU   10
R11      EQU   11
R12      EQU   12
R13      EQU   13
R14      EQU   14
R15      EQU   15
         EJECT
         L     R1,0(,R1)               PARM FIELD POINTER
         LH    R0,0(,R1)               LENGTH
         LTR   R0,R0                   TEST
         BC    12,NOPARM               BR IF NO PARM FIELD
PARM     CLI   2(R1),C'K'              TEST PARM=K (KEEP NULL INDEXES)
         BC    7,*+8                   BR IF NOT
         O     R13,=X'80000000'        SET IND TO SUPPRESS NULL DELETN
         CLI   2(R1),C'I'              TEST PARM=I (PRINT I/O SUMMARY)
         BC    7,*+8                   BR IF NOT
         O     R13,=X'40000000'        SET IND TO PRINT SUMMARY
         CLI   2(R1),C'F'              TEST PARM=F (FORCE 0 COND CODE)
         BC    7,*+8                   BR IF NOT (IN CASE #0 BLKS)
         O     R13,=X'20000000'        SET IND TO FORCE CODE
         LA    R1,1(,R1)               NEXT CHAR OF PARM FIELD
         BCT   R0,PARM
NOPARM   DS    0H
         SPACE
*        OPEN PRINT DATA SET
         OPEN  MF=(E,OPENS)            OPEN
         LA    R7,PRERCS               ERROR RETN ADDR
         TM    SYSPRINT+48,16          TEST OK
         BCR   8,R7                    RETURN IF NOT OPEN
         LA    R7,PRER                 ERROR RETURN ADDR
         SPACE
*        CHECK TIOT FOR SYSUT1 AND SYSUT2
         L     R6,16                   CVT
         L     R6,0(,R6)               TCBWORDS
         L     R6,4(,R6)               TCB
         L     R6,12(,R6)              TIOT
         LA    R6,24(,R6)              1ST ENTRY
AC1      CLI   0(R6),0                 SEE IF LAST
         BC    8,AC6                   BR IF SO
         CLC   =CL8'SYSUT1',4(R6)      TEST IF SYSUT1
         BC    7,AC2                   BR NOT
         OI    DDNFLG,DDNFS1           SET FLAG
         BC    15,AC3                  GO CHECK DEVICE IS DA
AC2      CLC   =CL8'SYSUT2',4(R6)
         BC    7,AC5
         OI    DDNFLG,DDNFS2
AC3      LH    R2,18(,R6)              UCB ADDR
         LTR   R2,R2                   TEST DUMMY
         BC    8,AC4                   ERROR IF SO
         CLI   18(R2),X'20'            CHECK DA
         BC    8,AC5                   BR IF OK
AC4      MVC   PRLINE+1(36),=C' ERROR - SYSUTX IS NOT DIRECT-ACCESS'
         MVC   PRLINE+10(6),4(R6)      GET APPROPRIATE DDNAME
         BR    R7                      PRINT ERROR AND EXIT
AC5      SR    R5,R5
         IC    R5,0(,R6)
         AR    R6,R5                   NEXT TIOT ENTRY
         BC    15,AC1                  LOOP
         SPACE
AC6      TM    DDNFLG,DDNFS1           TEST AT LEAST SYSUT1 OK
         BC    1,AC7                   BR IF SYSUT1 PRESENT
         MVC   PRLINE+1(31),=C' ERROR - SYSUT1 DD CARD MISSING'
         BR    R7                      PRINT ERROR AND EXIT
AC7      DS    0H
         SPACE
*        PREPARE TO OPEN VTOC(S)
         TM    DDNFLG,DDNFS2           TEST IF SYSUT2
         BC    1,AC8                   BR IF SO
         OI    OPENV,X'80'             SET ONLY ONE VTOC
AC8      DS    0H
         RDJFCB MF=(E,OPENV)           GET 1 OR 2 JFCB'S
         MVC   DSNI,JFCBI              SAVE DSNAME
         MVC   DSNO,JFCBO
         MVI   JFCBI,4                 SET VTOC
         MVC   JFCBI+1(43),JFCBI       DSN
         MVC   JFCBO(44),JFCBI
         OI    JFCBO+52,8              SET NO
         OI    JFCBI+52,8              WRITE-BACK
         OPEN  MF=(E,OPENV),TYPE=J     OPEN VTOC(S)
         LA    R7,PRERCV               SET ERROR EXIT
         SPACE
*        GET DEVTYPE, BLKS PER TRK AND CHECK DSNAME PRESENT
*        FOR INPUT AND OUTPUT
         DEVTYPE DCBI+40,DEVTI,DEVTAB  GET DEVTYPE, INPUT
         LA    R1,DCBVI
         BAL   R2,GETBPT               BLKS PER TRK, INPUT
         ST    R0,BLKPTRKI
         SPACE
         LA    R1,DCBVI
         LA    R3,DSNI
         BAL   R2,FNDF1                GET CCHHR OF DSCB
         SPACE
         TM    DDNFLG,DDNFS2           TEST SYSUT2 PRESENCE
         BC    8,AC10                  BR IF NOT
         DEVTYPE DCBO+40,DEVTO,DEVTAB
         LA    R1,DCBVO
         BAL   R2,GETBPT
         ST    R0,BLKPTRKO
         SPACE
         LA    R1,DCBVO
         LA    R3,DSNO
         BAL   R2,FNDF1
         BC    15,AC14
         SPACE
AC10     DS    0H                      CHECK .BACKUP ON SYSUT1 VOL
         CLC   =CL7' ',DSNI+37         CHECK NAME SHORT ENOUGH
         BC    8,AC11
         MVC   PRLINE+1(32),=C' ERROR - SYSUT1 DSNAME TOO LONG:'
         MVC   PRLINE+34(44),DSNI
         BR    R7                      PRINT ERROR AND EXIT
         SPACE
AC11     LA    R1,DSNO+43
         MVC   DSNO,DSNI
AC12     BCTR  R1,0
         CLI   0(R1),C' '              LOOK FOR LAST NON-BLANK
         BC    8,AC12                  IN DSNAME
         MVC   1(7,R1),=C'.BACKUP'     APPEND .BACKUP
         LA    R1,DCBVI
         LA    R3,DSNO                 FIND THE .BACKUP DSCB ON SYSUT1
         LA    R2,AC13                 SET OK RETURN ADDR
         BAL   R4,FNDF1R               RETURN HERE IF NOT OK
         CLI   ECB,X'42'               NO FIND?
         BC    7,FFE2                  I/O ERROR IF NOT NO-FIND
         SPACE
*        HERE LOOK FOR DUPLICATE NAME ON VOL ASSUMING SYSTEM CRASH
*        DURING A PREVIOUS AECATLG RUN
         LA    R1,DCBVI                SYSUT1 DCB
         LA    R3,DSNI                 DSN ADDR
         MVC   IOBM+3(5),CHRI          START AT 1ST DSN DSCB
         LA    R4,FNDNODUP             ERROR RETURN
         BAL   R2,FNDF12               GET 2ND DSCB FOR DSN
         MVC   CHRO,CHRI               SET ITS CCHHR
         MVC   CHRI(5),IOBM+3          RESTORE CCHHR OF 1ST
         MVC   IOBM+3(5),CHRO          SET 2ND CCHHR FOR I/O
         LA    R0,CCWWTF1              CCW FOR WRITE 'X.BACKUP'
         ST    R0,IOB+16               SET TO IOB
         LA    R0,DSNO                 SET TO WRITE
         ST    R0,CCWWTF1K             .BACKUP
         MVI   CCWWTF1K,WKD
         BAL   R8,EXCP
*        PRINT NAME CHANGE MESSAGE
         LA    R6,DCBI
         LA    R7,DCBO
         L     R1,DCBVI+44             GET A DEB FOR THE VOL
         BAL   R5,PRNCC                PRINT NAME CHANGE
         MVI   PRLINE,C'0'             SET NEXT TO DOUBLE SPACE
AC13     DS    0H
         EJECT
         MVC   DEVTO(20),DEVTI         INVENT OUTPUT DEVTYPE
         MVC   JFCBO,JFCBI             SET OUTPUT JFCB
         MVC   BLKPTRKO,BLKPTRKI       SET SAME BLKS/TRK
         MVI   DCBO+45,C'1'            BOTH INPUT AND OUTPUT ARE SYSUT1
AC14     DS    0H
         MVC   JFCBI(44),DSNI          SET DSNAMES
         MVC   JFCBO(44),DSNO          TO JFCBS
         SPACE
         OPEN  TYPE=J,MF=(E,OPENC)     OPEN CATALOGS
         SPACE
*        ENQ THE CATALOG IF IT IS A SYSTEM CATALOG
         CLC   DSNI,=CL44'SYSCTLG'     SEE IF SYSCTLG
         BC    7,NOENQ                 NO ENQ IF NOT
         L     R1,DCBI+44              DEB
         L     R1,32(,R1)              UCB
         LA    R1,0(,R1)               CLEAR BYTE
         ST    R1,RNAME+8              STORE AS PART OF RNAME
         ENQ   MF=(E,ENQL)             ENQ THE CATALOG
NOENQ    DS    0H
         SPACE 2
*        NOW COPY THE CATALOG
         LA    R0,DCBI
         LA    R1,DCBO
         STM   R0,R1,CPYARG1           SET UP ARG LIST
         SPACE
AC20     DS    0H
         LA    R7,PRERDQ               ERROR RETN ADDR
         LM    R10,R11,CPYARG1         INPUT, OUTPUT, CURRENT
*        FROM HEREON, ADDRESS QTTIES RELATING TO INPUT OR OUTPUT
*        UNDER R10 AND R11, AS THEY MAY BE SWAPPED
         USING DCBI,R10
         USING DCBO,R11
         SPACE
         MVC   PRLINE(18),=C'1COPY CATALOG FROM'
         LR    R9,R10                  INPUT
         BAL   R8,PRVD                 PRINT VOL AND DSN
         MVC   PRLINE+16(2),=C'TO'
         LR    R9,R11                  OUTPUT
         BAL   R8,PRVD                 PRINT VOL AND DSN
         BAL   R8,PRNT                 BLANK LINE
         SPACE
         LA    R1,CPYARG               ARG ADDRS
         L     R15,=V(CPYCTL)          SUBROU
         BALR  R14,R15                 LINK
         LTR   R15,R15                 TEST
         BCR   7,R7                    EXIT IF ERROR
         SPACE
*        NOW ZAP THE DSCB OF OUTPUT CATALOG TO INDICATE IT IS A
*        CATALOG - ALSO DO NAME CHANGE IF NO SYSUT2 EXISTS
         SPACE
         MVC   IOBM+3(5),CHRO          SET UP DSCB ADDR
         LA    R0,CCWRDF1              CHAN PGM
         LA    R1,DCBVO                DCB ADDR
         CLI   DCBVO+40,C'S'           SEE IF OPEN
         BC    7,*+8                   IF NOT OPEN, MUST BE
         LA    R1,DCBVI
         STM   R0,R1,IOB+16
         LA    R0,DSNO
         ST    R0,CCWRDF1S
         MVI   CCWRDF1S,SKEQ
         BAL   R8,EXCP
         MVC   F1DATA+98-44(3),=X'0000FF' SET DS1LSTAR TO SPECIAL VALUE
         LA    R0,DSNO                 DSNAME FOR WKD
         TM    DDNFLG,DDNFS2           TEST IF SYSUT2
         BC    1,AC22                  BR IF SO - NO NAME CHANGE REQD
         LA    R0,DSNI
AC22     ST    R0,CCWWTF1K
         MVI   CCWWTF1K,WKD
         LA    R0,CCWWTF1              SET CPGM ADDR
         ST    R0,IOB+16               IN IOB
         BAL   R8,EXCP
         SPACE 2
*        IF NO SYSUT2, CHANGE NAME OF INPUT DS TOO
         TM    DDNFLG,DDNFS2
         BC    1,AC23                  BR IF SYSUT2 PRESENT
         LR    R6,R11                  NAME CHANGED FROM
         LR    R7,R10                  NAME CHANGED TO
         BAL   R5,PRNC                 PRINT NAME CHANGE MESSAGE
         MVC   IOBM+3(5),CHRI          DSCB CCHHR
         LA    R0,CCWRDF1
         ST    R0,IOB+16
         LA    R0,DSNI
         ST    R0,CCWRDF1S
         MVI   CCWRDF1S,SKEQ
         BAL   R8,EXCP                 READ THE INPUT CTLG DSCB
         LA    R0,DSNO                 SET UP FOR
         ST    R0,CCWWTF1K             NAME CHANGE
         MVI   CCWWTF1K,WKD            SET WRITE CMD BACK IN
         LA    R0,CCWWTF1              SET NEW
         ST    R0,IOB+16               CPGM ADDR
         BAL   R8,EXCP                 CHANGE NAME
         LR    R6,R10
         LR    R7,R11                  NAME CHANGED TO
         BAL   R5,PRNC                 PRINT NAME CHANGE MESSAGE
         XC    DSNI,DSNO               CHANGE NAMES IN CORE SO THAT
         XC    DSNO,DSNI               NEXT PASS IF ANY
         XC    DSNI,DSNO               WILL WORK
         LR    R9,R11
         STM   R9,R10,CPYARG1          SWAP ARGLIST WORDS
         MVI   PRLINE,C'1'             SET NEW PAGE
         CLC   CHRI,CHRO               IF INPUT HAD LOWER CCHHR OF DSCB
         BC    4,AC20                  COPY CATLG BACK AGAIN
AC23     DS    0H                      COME HERE FOR SYSUT1-->SYSUT2
         SR    R7,R7                   INDICATE NO ERROR AND EXIT
PRERDQ   CLC   RNAME+8(3),RNAME+9      TEST IF ENQ WAS SET UP
         BC    8,PRERCC                NO DEQ IF NO ENQ
         DEQ   MF=(E,ENQL)
PRERCC   DS    0H
         NI    DCBI+X'2B',X'F3'        INDICATE NO 4 OR 5 WORD
         NI    DCBO+X'2B',X'F3'        DEVICE INTERFACE PRESENT SO THAT
*        ABSENCE OF APARS P72296 OR P73789 WILL NOT ALLOW CLOSE TO
*        WRECK THE DSILSTAR FIELD OF THE DSCB
         CLOSE MF=(E,OPENC)
PRERCV   CLOSE MF=(E,OPENV)            CLOSE VTOCS
         LTR   R7,R7                   TEST IF ERROR TO PRINT
         BC    8,PRERCS                SKIP PRINTING IF NOT
PRER     BAL   R8,PRNT                 PRINT ERRORS IF ANY
PRERCS   CLOSE MF=(E,OPENS)            CLOSE SYSPRINT
         LTR   R15,R7
         BC    8,RETNO
RETN16   LA    R15,16
RETNO    L     R13,4(,R13)
         L     R14,12(,R13)
         LM    R0,R12,20(R13)
         MVI   12(R13),X'FF'
         BR    R14
         DROP  R10,R11
         EJECT
*        SUBROUTINE FINDS DSCB ON VOL
         SPACE
FNDF1    LA    R4,FNDFER               SET ERROR RETURN
FNDF1R   DS    0H                      ENTRY WITH RETURN SET
         XC    IOBM,IOBM
         L     R15,44(,R1)             DEB
         MVC   IOBM+1(6),36(R15)       VTOC START BBCCHH
FNDF12   DS    0H                      ENTRY WITH RETURN AND MBB CCHHR
         LA    R0,CCWFNDF1
         STM   R0,R1,IOB+16            SET CCW AND DCB ADDR
         ST    R3,CCWFND2              BUILD CHAN PGM
         MVI   CCWFND2,SKEQ
         LA    R0,44(,R3)              CHR0 OR CHRI
         ST    R0,CCWFND1
         MVI   CCWFND1,RC+MT
         BAL   R8,EXCPR                DO I/O (R4 IS SET FOR BAD RETN)
         BR    R2                      RETURN
         SPACE
FNDNODUP LA    R3,DSNO                 SET TO .BACKUP FOR MESSAGE
FNDFER   DS    0H                      ERROR FINDING DSCB
         CLI   ECB,X'42'               DID WE RUN OUT OF VTOC
         BC    7,FFE2                  BR IF NOT
         MVC   PRLINE+1(18),=C' ERROR - DATASET "'
         MVC   PRLINE+19(44),0(R3)     DSN TO MESSAGE
         LA    R1,PRLINE+19+44
FFE1     BCTR  R1,0                    SEARCH LAST
         CLI   0(R1),C' '              NON BLANK
         BC    8,FFE1
         MVC   1(15,R1),=C'" NOT ON VOLUME'
         L     R2,IOB+20               DCB
         L     R2,44(,R2)              DEB
         L     R2,32(,R2)              UCB
         MVC   18(6,R1),28(R2)         VOLSER TO MESSAGE
         MVI   17(R1),C'"'
         MVI   24(R1),C'"'
         BR    R7                      PRINT ERROR, EXIT
         SPACE
FFE2     MVC   PRLINE+1(27),=C' ERROR - I/O ERROR IN VTOC:'
         LA    R1,IOB
         SYNADAF ACSMETH=EXCP
         MVC   PRLINE+29(80),50(R1)    MESSAGE TO LINE
         SYNADRLS
         BR    R7                      PRINT ERROR, EXIT
         SPACE 4
*        SUBROUTINE TO GET BLKS PER TRK IN CATALOG
*        BY READING F4 DSCB
*        ON ENTRY, A(VTOCDCB) IN R1, RETURN IN R2
*        RESULT RETURNED IN R0
         SPACE
GETBPT   LA    R0,CCWBPT
         STM   R0,R1,IOB+16            SET UP IOB
         L     R1,44(,R1)              DEB
         MVC   IOBM+1(6),36(R1)        BBCCHH
         MVI   IOBM+7,1                R=1 FOR F4
         BAL   R8,EXCP                 READ F4
         SR    R0,R0
         IC    R0,F4DSCB+75-44         GET BLK/TRK FROM DSCB
         BR    R2                      RETURN
         SPACE 4
*        SUBROUTINE TO DO EXCP ON VTOC
*        EXITS WITH SYNAD IF ERROR
         SPACE
EXCP     LA    R4,FFE2                 SET ERROR HANDLER
EXCPR    DS    0H                      ENTRY HERE IF WANT TO HANDLE
         EXCP  IOB                     OWN ERROR
         WAIT  ECB=ECB
         CLI   ECB,X'7F'               CHECK OK
         BCR   8,R8                    RETURN IF SO
         BR    R4                      HANDLE ERROR
         EJECT
*        PRINT VOLSER AND DSN IN FORMAT
*                 VOLUME=      , DSNAME=
PRVD     MVC   PRLINE+19(45),=C'VOLUME=XXXXXX, DSCB CCHHR=XXXXXXXXXX, D*
               SNAME='
         USING DCBI,R9
         MVC   PRLINE+64(44),DSNI      DSN
         L     R1,DCBI+44              DEB
         L     R1,32(,R1)              UCB
         MVC   PRLINE+26(6),28(R1)     VOLSER
         LM    R0,R1,CHRI
         SRDL  R0,24
         LA    R2,PRLINE+45
         BAL   R14,CNVHEX
         DROP  R9
         SPACE
PRNT     PUT   SYSPRINT,PRLINE
         MVI   PRLINE,C' '             BLANK OUT LINE
         MVC   PRLINE+1(120),PRLINE
         BR    R8                      RETURN
         SPACE 2
         USING DCBI,R6                 FROM
         USING DCBO,R7                 TO
PRNC     L     R1,DCBI+44              DEB
PRNCC    DS    0H
         MVC   PRLINE(38),=C'0VOLUME=XXXXXX, DSCB CCHHR=XXXXXXXXXX,'
         L     R1,32(,R1)              UCB
         MVC   PRLINE+8(6),28(R1)      VOLSER
         LM    R0,R1,IOBM              DSCB MBBCCHHR
         LA    R2,PRLINE+27            SPOT FOR ANSWER
         BAL   R14,CNVHEX              CONVERT TO HEX
         BAL   R8,PRNT                 PRINT IT
         MVC   PRLINE+1(19),=C'NAME CHANGED FROM "'
         MVC   PRLINE+20(44),DSNI
         MVC   PRLINE+64(6),=C'" TO "'
         MVC   PRLINE+70(44),DSNO
         MVI   PRLINE+114,C'"'
         BAL   R8,PRNT
         BR    R5
         DROP  R6,R7
         SPACE 2
CNVHEX   LA    R15,10                  DIGIT COUNTER
         BCTR  R2,0
CNV1     STC   R1,0(R15,R2)
         SRDL  R0,4
         BCT   R15,CNV1
         NC    1(10,R2),=10X'F'
         TR    1(10,R2),=C'0123456789ABCDEF'
         BR    R14
         EJECT
CCWFNDF1 CCW   SIDEQ,IOBM+3,CC,5
         CCW   TIC,*-8,0,0
CCWFND1  CCW   RC+MT,*-*,CC,8
CCWFND2  CCW   SKEQ,*-*,CC,44
         CCW   TIC,CCWFND1,0,0
         CCW   RD,F1DATA,0,96
         SPACE
CCWRDF1  CCW   SIDEQ,IOBM+3,CC,5
         CCW   TIC,*-8,0,0
CCWRDF1S CCW   SKEQ,*-*,CC,44
         CCW   NOP,0,0,0
         CCW   RD,F1DATA,0,96
         SPACE
CCWWTF1  CCW   SIDEQ,IOBM+3,CC,5
         CCW   TIC,*-8,0,0
CCWWTF1K CCW   WKD,*-*,CD,44
         CCW   0,F1DATA,0,96
         SPACE
CCWBPT   CCW   SIDEQ,IOBM+3,CC,5
         CCW   TIC,CCWBPT,0,0
         CCW   SKEQ,VTOCDSN,CC,44
         CCW   TIC,*-8,0,0
         CCW   RD,F4DSCB,0,96
VTOCDSN  DC    44X'4'
F4DSCB   DC    XL96'0'
SIDEQ    EQU   X'31'
TIC      EQU   8
RC       EQU   X'12'
MT       EQU   X'80'
SKEQ     EQU   X'29'
WKD      EQU   X'0D'
RD       EQU   6
NOP      EQU   3
         SPACE
CC       EQU   X'40'                   CHAIN COMMAND
CD       EQU   X'80'                   CHAIN DATA
         EJECT
SAVE     DC    18A(0)                  SAVE AREA
OPENS    OPEN  (SYSPRINT,OUTPUT),MF=L
OPENV    OPEN  (DCBVI,UPDAT,DCBVO,UPDAT),MF=L
OPENC    OPEN  (DCBI,OUTPUT,DCBO,OUTPUT),MF=L
ENQL     ENQ   (QNAME,RNAME,E,12,SYSTEM),MF=L
QNAME    DC    CL12'SYSCTLG'
RNAME    EQU   QNAME                   RNAME= 'SYSCTLG XXXX' XXXX=UCB
EXLVI    DC    0A(0),X'87',AL3(JFCBI)
EXLVO    DC    0A(0),X'87',AL3(JFCBO)
         SPACE
IOB      DC    X'42000000',A(ECB)
         DC    A(0,0)                  CSW
         DC    A(0,0)                  CCW,DCB
         DC    A(0,0)                  RESTART
IOBM     DC    XL8'0'                  MBBCCHHR
ECB      DC    A(0)
         PRINT NOGEN
SYSPRINT DCB   DDNAME=SYSPRINT,DSORG=PS,RECFM=FBA,LRECL=121,MACRF=PM,  X
               EXLST=EXLS
EXLS     DC    0A(0),X'85',AL3(*+3)
         USING *,R15                   IF BLKSI ZERO, THIS MAKES
         SR    R2,R2                   IT 10*LRECL, OTHERWISE THE NEXT
         LH    R3,62(,R1)              MULTIPLE OF LRECL BELOW ITSELF
         LTR   R3,R3
         BC    7,DCBEX1
         LA    R3,10
         MH    R3,82(,R1)
         STH   R3,62(,R1)
         BR    R14
DCBEX1   LH    R4,82(,R1)
         DR    R2,R4
         MR    R2,R4
         STH   R3,62(,R1)
         LTR   R3,R3
         BCR   7,R14
         STH   R4,62(,R1)
         BCR   15,R14
         DROP  R15
PRLINE   DC    CL121'0'
DDNFLG   DC    AL1(0)                  DDNAME PRESENCE FLAGS
DDNFS1   EQU   X'80'                   SYSUT1
DDNFS2   EQU   X'40'                   SYSUT2 PRESENT
F1DATA   DC    0A(0),XL96'0'
CPYARG   DC    A(SYSPRINT)
CPYARG1  DC    A(0)
CPYARG2  DC    A(0)
         LTORG
         EJECT
DCBO     DCB   MACRF=E,DDNAME=SYSUT2,EXLST=EXLVO
DEVTO    DC    5A(0)
BLKPTRKO DC    A(0)
DSNO     DC    CL44' '
CHRO     DC    XL8'0'
JFCBO    DC    XL176'0'
DCBVO    DCB   MACRF=E,DDNAME=SYSUT2,EXLST=EXLVO
 SPACE 3
DCBI     DCB   MACRF=E,DDNAME=SYSUT1,EXLST=EXLVI
DEVTI    DC    5A(0)
BLKPTRKI DC    A(0)
DSNI     DC    CL44' '
CHRI     DC    XL8'0'
JFCBI    DC    XL176'0'
DCBVI    DCB   MACRF=E,DDNAME=SYSUT1,EXLST=EXLVI
         END   AECATLG
// END OF AECATLG
//*
//*
// START OF CPYCTL
         SPACE 2
         MACRO
&L       PUT   &A,&B
.*       MACRO TO PUT SYSPRINT,XXX WITH ONLY A(SYSPRINT) ADDRESSABLE
&L       L     R1,ASYSPRNT .           DCB ADDR
         AIF   ('&B' EQ '').A
         LA    R0,&B
.A       L     R15,48(,R1) .           PUT ROUTINE ADDR
         BALR  R14,R15 .               LINK TO IT
         MEND
         EJECT
         MACRO
&L       LT    &R,&S
&L       L     &R,&S
         LTR   &R,&R
         MEND
         MACRO
&N       INCR  &I
&N       LA    R0,1
         AL    R0,&I
         ST    R0,&I
         MEND
         MACRO
&NAME    STACK &DEPTH
         LCLA  &LVL
&NAME    EQU   *
.MORE    ANOP
&LVL     SETA  &LVL+1
         DC    A(&LVL),(LVWKLENG/4-1)A(0)
         AIF   (&LVL NE &DEPTH).MORE
         MEND
*        DEFINITION OF DSECT DESCRIBING THE CORE AREA ASSOCIATED WITH
*        A CORE-RESIDENT CATALOG BLOCK
*        EACH SUCH AREA MAY BE IN ONE OF 6 STATES
*        1)    IT CONTAINS NO CATALOG BLOCK - IT IS ON A FREE CHAIN
*        2)    IT CONTAINS A BLOCK FROM THE INPUT CATALOG WHICH MAY
*              BE PURGED - I.E. IT HAS BEEN READ, IS NOT CURRENTLY
*              NEEDED IN CORE, BUT MAY BE NEEDED AGAIN LATER - IT IS
*              ON A PURGABLE CHAIN - CBRPC
*        3)    IT CONTAINS AN INPUT CATALOG BLOCK WHICH MUST NOT BE
*              PURGED - IT IS NOT ON A CHAIN
*        4)    IT CONTAINS AN OUTPUT BLOCK WHICH IS BEING FILLED - IT
*              IS NOT ON A CHAIN
*        5)    IT CONTAINS AN OUTPUT BLOCK WHICH IS BEING WRITTEN - IT
*              IS CHAINED THRU THE CHAN PROGM TIC
*        6)    AN OUTPUT BLOCK QUEUED FOR WRITING IN CCHHR ORDER -CBWQC
*        THE 1ST 3 ITEMS MAY BE REFERRED TO ABSOLUTELY, THE REMAINDER
*        WILL BE REFERRED TO ONLY BY THEIR DSECT LABELS
CAB      DSECT                         CATALOG CONTROL BLOCK
CABTTR0  DC    A(0)                    TTR0 OF THIS BLOCK
CABKEY   DC    XL8'0'                  KEY OF THIS BLOCK
CABDATA  DC    XL256'0'                DATA AREA OF CATALOG
CABNEXT  DC    A(0)                    NEXT BLOCK ON CHAIN
CABPREV  DC    A(0)                    PREVIOUS BLOCK ON CHAIN
CABM     DC    0XL8'0',X'0'            MBBCCHHR, M
CABSEEKA DC    XL2'0'                  BB
CABCOUNT DC    XL5'0'                  CCHHR
CABCCW   DS    0D                      CCW AREA TO READ OR WRITE
*        READ CHAN PGM
CABRCMT  CCW   RC+MT,CABCOUNT,CC+SLI,5 READ COUNT OF BLOCK
CABRKD   CCW   RKD,CABKEY,CC-CC,8+256  READ THE BLOCK, PERHAPS CHAIN
CABRTIC  CCW   TIC,*-*,0,0             TIC TO NEXT READ
         SPACE
*        WRITE CHAN PGM
         ORG   CABCCW
CABWSID  CCW   SIDEQ,CABCOUNT,CC,5     SEARCH RECORD
CABWTIC1 CCW   TIC,CABWSID,0,0         LOOP TILL FOUND
CABWKD   CCW   WKD,CABKEY,CC-CC,8+256  WRITE KEY/DATA
CABWTIC2 CCW   TIC,*-*,0,0             TIC TO NEXT WRITE
         ORG
CABLEN   EQU   *-CAB
CNEXT    EQU   CABNEXT-CAB
CPREV    EQU   CABPREV-CAB
         TITLE 'AECATLG'
* * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *
*                                                                     *
*        SUBROUTINE OF AECATLG WHICH COPIES AND RESTRUCTURES          *
*        ('STRAIGHTENS') AN O/S CATALOG SO THAT ALL INDEX LEVELS      *
*        CONSIST OF CONTIGUOUS BLOCKS                                 *
*                                                                     *
*        PARAMETER LIST ON ENTRY:                                     *
*        A(OPEN SYSPRINT DCB)                                         *
*        A(OPEN CATALOG DCB,DEVTYPE,BLKS/TRK) INPUT CATALOG           *
*        A(OPEN CATALOG DCB,DEVTYPE,BLKS/TRK) OUTPUT CATALOG          *
*                                                                     *
DTD      EQU   X'34'                   DISPL DCB TO DEVTYPE           *
BPTD     EQU   X'34'+20                DISPL DCB TO BLKS/TRK          *
*                                                                     *
*        RETURN CODE NON-ZERO IF ANY PROBLEMS                         *
*                                                                     *
* * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *
CPYCTL   CSECT
R15      EQU   15
R14      EQU   14
R13      EQU   13                      SAVE AREA, CONSTS, WORK
R12      EQU   12                      BASE REG
SP       EQU   11                      STACK POINTER
*              REGS 10 THRU 6 SAVED ON STACK
LNK      EQU   10                      LINK REG
XRINREC  EQU   9                       POINTER TO INPUT RECORD
XROUTREC EQU   8                       POINTER TO OUTPUT RECORD
XRINBUF  EQU   7                       INPUT TTR0 BLOCK POINTER
XROUTBUF EQU   6                       OUTPUT TTR3 BLOCK POINTER
WK5      EQU   5                       SEMI VOLATILE - NOT SAVED ON STA
WK4      EQU   4                       SEMI VOLATILE - NOT SAVED ON ST
WK3      EQU   3                       VOLATILE - NOT SAVED ON SUBR C
WK2      EQU   2
R1       EQU   1
R0       EQU   0
R9       EQU   9
R10      EQU   10
         SPACE 3
NE       EQU   7                       NOT EQUAL - COND CODE BIT MASK
E        EQU   8                       EQUAL     - COND CODE BIT MASK
         EJECT
         SAVE  (14,12),,*
         LR    R12,R15
         USING CPYCTL,R12              BASE REG
         ST    R13,SAVEAREA+4          BACK CHAIN
         LR    WK2,R13
         LA    R13,SAVEAREA
         USING SAVEAREA,R13            OS SAVE AREA AND CONSTS
         ST    R13,8(,WK2)             FWD CHAIN
         SR    WK2,WK2
         ST    WK2,SAVEAREA+16         CLEAR RC FOR FUTURE USE
         SPACE 3
*        ENTRY SEQUENCE
         LM    R1,R3,0(R1)             ARGUMENTS
         ST    R1,ASYSPRNT             ADDR OF SYSPRINT DCB
         ST    R2,IOBIDCB              INPUT DCB
         ST    R3,IOBODCB              OUTPUT DCB
         L     R0,BPTD(,R2)            BLKS/TRK INPUT
         L     R1,BPTD(,R3)            BLKS/TRK OUTPUT
         STM   R0,R1,BLKPTRKI          SAVE BOTH
         SPACE 2
*INITIALISE IO SECTION
         BAL   R14,INITIO
CPC1     BAL   R14,INITIO1
         SPACE 3
*        INITIALISE VARIABLE STORAGE
         BAL   R14,INITST
         SPACE 3
*FIND THE SPACE TO BE LEFT IN THE HIGHEST LEVEL INDEX FOR EXPANSION
         BAL   R14,INDSPACE
         SPACE 3
*PREPARE TO CALL THE TREE SEARCH POUTINE
         LA    SP,STACK                SET UP STACK POINTER
         USING LVWKAREA,SP
         LA    R0,256                  SET REG0 FOR TTR0='0010'
         SPACE 3
         BAL   LNK,TREESRCH            GO FIX IT
         SPACE 3
*CLEAN UP THE IO
         BAL   R14,FINIO
         SPACE 3
* PRINT CATALOG STATISTICS
         SPACE
         BAL   LNK,PRINTST
         SPACE 2
         BAL    LNK,DMPUNREF               DUMP UNREFERENCED BLOCKS
         SPACE 2
* FREEMAIN THE STORAGE
         SPACE
         BAL   R14,FREEMAIN
         SPACE 2
*EXIT
         L     R13,SAVEAREA+4
         RETURN (14,12),T,RC=0
         TITLE 'AECATLG - TREESRCH - RECURSIVE CATALOG TREE HANDLING ROX
               UTINE'
*TREESRCH IS CALLED WITH THE TTR0 OF THE NEXT LOWER LEVEL INDEX BLOCK
*              IN REG 0.IT WRITES OUT THIS LOWER LEVEL INDEX LEVEL
*              AND RETURNS WITH R15=0. IF LOWER LEVEL IS NULL, IT
*              RETURNS WITH R15=4 AND NOTHING IS WRITTEN OUT
*
*              TREESRCH READS THE INDEX LEVEL IT HAS BEEN POINTED TO
*              AND IF THAT LEVEL POINTS TO LOWER LEVELS STILL, IT
*              CALLS ITSELF (RECURSIVE) TO RESOLVE THAT NEW TTR0
*
*              THIS ROUTINE CALLS TH IO ROUTINES TO ACTUALLY WRITE THE
*              NEW CATALOG.
*
         SPACE 3
TREESRCH EQU   *
         SPACE 3
*PUSH OLD REGS ON THE STACK AND INITIALISE
         STM   XROUTBUF,LNK,LVWKREGS
         ST    R0,INPUTTTR             SAVE TTR0 FOR LATER
         INCR  O#INDEXS                COUNT NO OF OLD INDEXES
         SPACE 3
*GET AN OUTPUT BLOCK AND CLEAR IT
         BAL   R14,GETBUFO             XROUTBUF SET UP AS POINTER
         USING CAB,XROUTBUF
         XC    CABDATA,CABDATA
         LA    XROUTREC,CABDATA+2      SET UP OUTPUT RECORD POINTER
         MVC   CABTTR0,GLBLTTR0        SET UP TTR0 OF FIRST BLOCK
         SPACE 3
*DOUBLE OLD BLOCK LINK COUNTS, AS THE OLD CATALOG IS READ TWICE
*              THE COUNT IS HALVED AGAIN ON EXIT
         L     R0,OCTGLNK
         SLL   R0,1
         ST    R0,OCTGLNK
         L     R0,OBRKLNK
         SLL   R0,1
         ST    R0,OBRKLNK
         EJECT
*NOW DETERMINE SIZE OF THIS INDEX LEVEL IN BLOCKS
         BAL   R14,PURGST              FIRST MAKE THE NEXT BLOCKS PURGB
         L     R0,INPUTTTR             GET TTR0 OF INPUT BLOCK
         BAL   R14,GETBUFI             SETS UP XRINBUF
         LA    XRINREC,CABDATA-CAB+2(,XRINBUF) SET UP RECORD POINTER
         USING REC,XRINREC
TRYLOOP  BAL   LNK,TRYREC              PUT IT IN OUTPUT BUFFER
         BAL   LNK,GETREC
         LTR   R15,R15
         BZ    TRYLOOP                 BR IF NOT END
         MVC   INENDTTR,CABTTR0        SAVE SIZE OF INDEX LEVEL
         BAL   R1,NEXTTTR0             GET TTR0 FOR NEXT BLOCK
         MVC   CABTTR0,GLBLTTR0        RESET OUTPUT BUFFER FIRST TTR0
         MVC   OLDGLBL,GLBLTTR0        SAVE INDEX LEVEL START
         ST    R0,GLBLTTR0             UPDATE GLOBAL TTR FOR NEXT LVL
         LA    XROUTREC,CABDATA+2      REST RECORD POINTER
         XC    CABDATA,CABDATA         CLEAR OUTPUT BUFFER
         BAL   R14,FREEBUFI            FREE INPUT BUFFER
         BAL   R14,PURGEND             STOP PURGABILITY OF BLOCKS
         LA    R1,1                    SET UP INDEX BLOCK COUNTERS
         ST    R1,N#BLKWK              SET FOR ONE BLK EACH NEW & OLD
         ST    R1,O#BLKWK                   AS A START
         EJECT
*AT THIS STAGE WE HAVE DETERMINED THE LENGTH OF THE CURRENT INDEX
*              LEVEL AND HAVE UPDATED THE GLOBAL POINTER FOR THE
*              FIRST BLOCK OF THE NEXT INDEX LEVEL
         SPACE 3
         L     R0,INPUTTTR             GET BEGINNING TTR FOR THIS LEVEL
         BAL   R14,GETBUFI             GET FIRST BUFFER OF LEVEL AGAUN
         LA    XRINREC,CABDATA+2-CAB(,XRINBUF)     SET UP REC POINTER
         CLI   ETYPE,X'05'             IS IT VICE
         BNE   TYPE03
         SPACE 3
*ETYPE=05 VICE - FIX UP DISPLACEMENTS 8, 12, AND 16
         MVC   12(3,XRINREC),VCLSTBLK  END OF CATALOG
         MVC   ETTR,INENDTTR           GET TTR OF LAST BLOCK OF INDEX
         MVC   16(3,XRINREC),GLBLTTR0  GET ADDRESS OF NEXT SPARE BLOCK
         LR    WK4,XROUTBUF             SAVE INBUF POINTER TEMPORARILY
         LA    XROUTBUF,GLBLTTR0        POINT AT NEXT SPARE TTR0
         BAL   R1,NEXTTTR0             INCREMENT TO LEAVE SPACE
         ST    R0,GLBLTTR0
         LR    XROUTBUF,WK4             RESTORE BUFFER POINTER
         B     MOVEREC                 MOVE TO OUTPUT BUFFER
         SPACE 3
*ETYPE=03 ICE  - FIX UP POINTER TO INDEX END
TYPE03   EQU   *
         MVC   ETTR,INENDTTR           GET TTR OF LAST BLOCK OF INDEX
         MVI   15(XRINREC),X'00' **************CLEAR ALIAS COUNT*******
         MVC   12(3,XRINREC),CABTTR0-CAB(XROUTBUF) GET 1ST BLK OF INDEX
         SPACE 3
MOVEREC  BAL   LNK,PUTREC              PUT IT OUT
GETNEXT  BAL   LNK,GETREC              GET ANOTHER (NOT FIRST) RECORD
         LTR   R15,R15
         BZ    RECPRES                 BR IF NOT END OF INDEX
         SPACE 3
*CHECK IF THIS LEVEL IS NULL
         CLC   CABTTR0,OLDGLBL         SEE IF THIS IS 1ST BLK OF LEVEL
         BNE   FINALILE                NO, CAN'T BE NULL - PUT IT OUT
         LA    R1,CABDATA+2+EDATA-REC+2*X'03' POINT TO JUST AFTER ICE
         CR    R1,XROUTREC             IS IT SAME AS CURRENT REC POINTR
         BNE   FINALILE                NO, NOT NULL
 SPACE 2
*        HERE WE TEST FOR PARM=K OPTION WHICH KEEPS NULL ENTRIES
         TM    4(R13),X'80'            TEST OLD R13 TOP BIT
         BC    1,FINALILE              IF ON, KEEP THE NULL INDEX
         SPACE 3
*HANDLE NULL INDEX LEVEL
         MVC   GLBLTTR0,OLDGLBL        RECOVER SPACE ALLOCATED TO THIS X
                                       LEVEL
         BAL   R14,FREEBUF             FREE UNUSED OUTPUT BUFFER
         BAL   R14,FREEBUFI            FREE UP INPUT BUFFER
         SPACE 3
*        PRINT THE NAME OF THE NULL INDEX BEING DELETED
         LA    R10,STACK
         DROP  SP
         USING LVWKAREA,R10
         MVC   NULLMDSN,NULLMDSN-1     PREPARE TO BUILD NAME
         LA    R6,NULLMDSN             SPOT FOR NAME
NULLM1   LA    R10,LVWKLENG(,R10)      GET NEXT SAVE AREA
         CR    R10,SP                  SEE IF IT IS UP TO CURRENT
         BC    2,NULLM3                DEPTH - BR IF PAST, FINISHED
         L     XRINREC,LVWKREGS+12     OLD ENTRY POINTER
         MVC   0(8,R6),0(XRINREC)      MOVE IN INDEX NAME
         LA    R6,7(,R6)               PREPARE TO STRIP BLANKS
NULLM2   CLI   0(R6),C' '
         BC    7,*+8                   BR WHEN NON-BLANK
         BCT   R6,NULLM2               LOOP TO FIND NON-BL
         MVI   1(R6),C'.'
         LA    R6,2(,R6)               SPOT FOR NEXT INDEX NAME
         B     NULLM1                  GET NEXT INDEX NAME
NULLM3   PUT   SYSPRINT,NULLMESS       OUTPUT MESSAGE
         DROP  R10
         USING LVWKAREA,SP             REESTABLISH SP ADRSBLTY
         SPACE 2
         LA    R15,4                   SET RETURN CODE FOR NULL
         B     TREERET                 RETURN
         SPACE 3
FINALILE EQU   *
         MVC   CABKEY,=X'FFFFFFFFFFFFFFFF' SET UP HIGH KEY
         MVC   0(8,XROUTREC),CABKEY    SET UP FINAL ILE
         MVC   8(4,XROUTREC),=F'0'     SET LINK TO ZERO
*SET UP BLOCK LENGTH COUNT
         SR    XROUTREC,XROUTBUF       GET LENGTH
         LA    XROUTREC,12-CABDATA+CAB(,XROUTREC) ADJUST FOR END AND ST
         STH   XROUTREC,CABDATA        STORE LENGTH IN OUTPUT BLOCK
         BAL   R14,FREEBUFO            WRITE OUT FINAL BUFFER
         BAL   R14,FREEBUFI            FREE UP INPUT BUFFER
         INCR  N#INDEXS                COUNT NEW INDEX IF NON NULL
         SR    R15,R15                 CLEAR RETURN CODE
         L     R0,N#BLKWK              GET NO. BLKS THIS INDEX
         C     R0,NMAXBLKS
         BNH   *+8                     NOT LARGER THAN ANY BEFORE
         ST    R0,NMAXBLKS
         AL    R0,N#BLOCKS             ADD NO. OF BLKS SO FAR
         ST    R0,N#BLOCKS
         SPACE 3
*NOW RETURN TO CALLER
TREERET  EQU   *
         L     R0,O#BLKWK              GET NO. BLOCKS THIS INDEX
         C     R0,OMAXBLKS             IS IT LARGER THAN BEFORE
         BNH   *+8                     NO, DON'T INCREMENT IT
         ST    R0,OMAXBLKS
         AL    R0,O#BLOCKS             ADD TO INDEX LEVEL TOTAL
         ST    R0,O#BLOCKS
*              HALVE LINK COUNTS AS OLD CATALOG READ TWICE
         L     R0,OBRKLNK
         SRL   R0,1
         ST    R0,OBRKLNK
         L     R0,OCTGLNK
         SRL   R0,1
         ST    R0,OCTGLNK
         LM    XROUTBUF,LNK,LVWKREGS   GET OLD REGS
         BR    LNK                     RETURN
         SPACE 3
*CHECK FOR TYPE OF RECORD
RECPRES  EQU   *
         CLI   ETYPE,X'04'             IS IT AN ALIAS ENTRY
*        BH    MOVEREC                 PUT IT OUT IF CVPE OR DSPE
*********  MOD TO WATCH DSPE ENTRIES GO PAST AND DO VARIOUS
*        THINGS WITH THEM  --  THE MOD COMMENTED OUT THE
*        PREVIOUS BH INSTRUCTION
         BH    MOVEREC                 DELETE THIS TO ACTIVATE MOD
         BNH   PASTMOD
         CLI   ETYPE,X'07'             IS IT A DSPE?
         BNE   MOVEREC                 CONTINUE IF NOT
*     HERE WE HAVE A DSPE FOR SURE ..
         L     R15,=V(DSPEMON)
         LTR   R15,R15
         BC    8,MOD55
         LA    R0,STACK
         BALR  R14,R15
MOD55    DS    0H
         CLI   EDATA+2+2,X'20'         IS IT DISK DEVTYPE
         BNE   MOVEREC
         LA    LNK,TBL                 GET DISK HISTOG TABLE
         LA    R1,TBLEND
****************** MOD TO CHANGE TAPE ENTRIES ***********
*        CLC   =X'34208001',EDATA+2  13/6/79 --> CLI EDATA+4,X'80'
*        BC    7,TMOD1                       BY SUPERZAP
*        MVC   EDATA+2(4),=X'32108003'
TMOD1    DS    0H
MOD1     CLC   0(10,LNK),EDATA+2       SEE IF DEV/VOL ALREADY IN TABLE
         BC    8,MOD2                  BR IF SO
         LA    LNK,16(,LNK)            NEXT TABLE ENTRY
         CR    LNK,R1                  IF TABLE TOO SMALL
         BC    10,MOVEREC              FORGET RECORDING
         OC    0(4,LNK),0(LNK)         SEE IF EMPTY ENTRY
         BC    7,MOD1                  KEEP LOOKING IF NOT
         MVC   0(10,LNK),EDATA+2        SET UP THIS DEVTYPE
MOD2     LA    R0,1
         AL    R0,12(,LNK)              UPDATE COUNT
         ST    R0,12(,LNK)
         B     MOVEREC
PASTMOD  DS    0H
         BE    GETNEXT ***************IGNORE IF ALIAS ENTRY************
         CLI   ETYPE,X'03'             IS IT OLD CVOL POINTER
         BE    MOVEREC                 YES, PUT IT OUT
         SPACE 3
*ETYPE=00, 01, 02   IPE,GIPE, VCBPE - ALL POINT TO OTHER BLOCK(S)
         LH    R0,ETTR                 GET TT
         SLA   R0,8
         IC    R0,ETTR+2               GET R
         SLA   R0,8                    NOW HAVE NEXT OLD TTR0
         MVC   ETTR,GLBLTTR0           GET NEW TTR FROM GLOBAL TTR
         CLI   ETYPE,X'01'             IS IT VCBPE
         BE    VCBPE                   YES, GO FIX UP VCBS
         LA    SP,LVWKLENG(,SP)        POINT TO NEXT STACK ENTRY
         BAL   LNK,TREESRCH            CALL OURSELVES FOR NEXT LOWER
*                                       INDEX LEVEL TO UPDATE GLBLTTR0
         LA    R1,LVWKLENG             GET WORK AREA LENGTH
         SR    SP,R1                   RESET STACK BACK A LEVEL
         LTR   R15,R15                 CHECK FOR NULL LOWER LEVEL
         BZ    MOVEREC                 NON NULL, GO PUT IT OUT
         B     GETNEXT                 IGNORE ENTRY IF NULL
         SPACE 3
*ETYPE=01 VCBPE
VCBPE    EQU   *
         LR    WK5,XROUTBUF            SAVE PRESENT BUFFER POINTERS
         LR    WK4,XRINBUF
NEXTVCB  BAL   R14,GETBUFI             GET A VCB
         L     LNK,252+CABDATA-CAB(XRINBUF) GET NEXT BLOCK POINTER
         BAL   R14,GETBUFO
         MVC   CABKEY,CABKEY-CAB(XRINBUF)      SET UP KEY
         MVC   CABDATA,CABDATA-CAB(XRINBUF) SHIFT DATA TO OUTPUT
         MVC   CABTTR0,GLBLTTR0        SET UP NEW TTR
         BAL   R1,NEXTTTR0             INCREMENT TTR0
         ST    R0,GLBLTTR0
         LTR   LNK,LNK                 SEE IF END ONE
         BC    8,*+8                   BR IF END
         ST    R0,CABDATA+252          PUT IN TTR0 FOR LINK
         BAL   R14,FREEBUFI            FREE INPUT
         BAL   R14,FREEBUFO            PUT OUT NEW VCB
         LTR   R0,LNK                  ANY MORE VCBS
         BNZ   NEXTVCB                 BR IF YES
         LR    XROUTBUF,WK5            RESTORE BUFFER POINTERS
         LR    XRINBUF,WK4
         B     MOVEREC                 GO BACK TO INDEX SEARCH
         TITLE 'AECATLG - INTERNAL CATALOG SEARCH SUBROUTINES'
*ROUTINE TO CALCULATE THE SPACE TO BE LEFT IN THE INDEX LEVELS
*              FOR EXPANSION
*              READS VALUE FROM PARM FIELD
*
*              DEFAULT IS NO SPACE LEFT
         SPACE 3
INDSPACE EQU   *
         LA    WK2,256-12              SPACE FOR ILE ONLY
         STH   WK2,BLOCKEND
         BR    R14
         EJECT
*CALCULATE NEXT TTR0 FOR OUTPUT
*              ON ENTRY XROUTBUF POINTES TO CURRENT TTR0
*              NEW TTR0 IS RETURNED IN R0
*              R1 IS LINK REG
NEXTTTR0 EQU   *
         SR    R0,R0
         IC    R0,CABTTR0+2            GET 'R0'
         AH    R0,=H'1'                BUMP IT
         C     R0,BLKPTRKO             IS IT MORE THAN MAX
         BH    NEXTTRK
         L     R0,CABTTR0
         AL    R0,=F'256'              INCREMENT R IN TTR0
         BR    R1
NEXTTRK  LH    R0,CABTTR0              GET 'TT'
         AH    R0,=H'1'                BUMP 'TT'
         SLA   R0,16
         O     R0,=F'256'              SET ' R' = 1
         BR    R1                      RETURN
         EJECT
* ROUTINE THAT GETS THE NEXT LOGICAL RECORD FROM THE INPUT BUFFER
*              ROUTINE IS ENTERED WITH XRINREC POINTING TO CURRENT
*              ENTRY.
*              XRINREC IS UPDATED TO POINT AT NEXT LOGICAL RECORD.
*              IF BLOCK BOUNDARY IS REACHED, NEXT BLOCK IS READ AND
*              THE OLD ONE IS FREED. THE ILE IS NOT PRESENTED TO THE
*              CALLER, ONLY THE NEXT LOGICAL RECORD.
*
*              IF THE END OF THE INDEX LEVEL IS REACHED, REG 15 IS
*              LOADED WITH RC=4. THE INPUT BUFFER IS NOT FREED.
         SPACE 3
GETREC   EQU   *
         SR    WK5,WK5
         IC    WK5,ETYPE               GET ENTRY TYPE
         LA    WK5,EDATA-REC(WK5,WK5)  CONVERT TO LENGTH
         AR    XRINREC,WK5             UPDATE RECORD POINTER
GETREC1  DS    0H
         SR    WK5,WK5       DO CHECK TO ENSURE RECD IS WITHIN BLOCK
         IC    WK5,ETYPE               GET ENTRY TYPE
         LA    WK5,EDATA-REC(WK5,WK5)  CONVERT TO LENGTH
         AR    WK5,XRINREC             ADDR OF REC END
         LA    R0,CABDATA+256
         CL    WK5,R0        CHECK END OF REC WITHIN BLK
         BC    2,BLKERR      GIVE DIAGNOSTIC AND UP IF NOT
         SR    R15,R15                 CLEAR RETURN CODE
         CLI   ETYPE,X'00'             CHECK RECORD TYPE
         BCR   NE,LNK                  RETURN IF NOT ILE OR IPE
         CLC   ENAME,=X'FFFFFFFFFFFFFFFF' CHECK IF ILE
         BCR   NE,LNK                  RETURN IF NOT ILE
         SPACE
*WE ARE NOW AT THE END OF A BLOCK - CHECK IF INDEX END
         LA    R15,4                   SET UP RETURN CODE FOR END
         CLC   ETTR,=F'0'              IS IT END
         BCR   E,LNK                   RETURN - END OF INDEX
         SPACE 3
*GET NEXT BLOCK AND SET UP RECORD POINTER
         LH    R0,ETTR                 GET NEXT TT
         SLA   R0,8
         IC    R0,ETTR+2               GET 'R'
         SLA   R0,8                    NOW HAVE NEW TTR
         LR    WK5,R0                  SAVE
*              CHECK IF LINK IS CONTIGUOUS
         CLC   CABKEY-CAB(8,XRINBUF),=X'FFFFFFFFFFFFFFFF' END OF ST
         BNE   INCR1                   BR IF CONTIG LINK
         INCR  OBRKLNK                 BUMP BROKEN LINK COUNT
         B     INCR2
INCR1    INCR  OCTGLNK
INCR2    EQU   *
         BAL   R14,FREEBUFI            FREE OLD BUFFER
         LR    R0,WK5                  GET NEWTTR0
         BAL   R14,GETBUFI
         INCR  O#BLKWK                 COUNT OLD BLOCKS
         LA    XRINREC,CABDATA+2-CAB(XRINBUF) SET UP RECORD POINTER
         B     GETREC1                 CHECK NOT NULL AND RETURN
         EJECT
*ROUTINE THAT MOVES RECORDS FROM INPUT TO OUTPUT BUFFERS
*        IF AN OUTPUT BUFFER BOUNDARY IS CROSSED , THE ROUTINE
*              PUTS THAT BUFFER OUT AND INITIALISES A FRESH ONE
         SPACE 3
TRYREC   EQU   *
         MVI   TRYSW,X'FF'             SET SW INDICATING NO OUTPUT
PUTREC   EQU   *
         SR    WK5,WK5
         IC    WK5,ETYPE               GET ENTRY TYPE
         LA    WK5,EDATA-REC-1(WK5,WK5) CALCULATE ENTRY LENGTH - 1
         LR    R1,WK5
         AR    R1,XROUTREC
         LA    R0,CABDATA              GET BUFFER START
         SR    R1,R0
         CH    R1,BLOCKEND             CHECK UF ROOM FOR ENTRY
         BNL   NOROOM
         SPACE
MOVEDATA EX    WK5,MOVEINST
*        MVC   0(*-*,XROUTREC),REC
         MVC   CABKEY,ENAME            SET UP KEY IN CASE LAST ENTRY
         LA    XROUTREC,1(WK5,XROUTREC) UPDATE OUTPUT POINTER
         MVI   TRYSW,0                 CLEAR TRY SW
         BR    LNK                     RETURN
         SPACE 3
NOROOM   EQU   *
         BAL   R1,NEXTTTR0
         CLI   TRYSW,X'FF'             IS IT CHECKING SIZE
         BNE   NEXTBUF                 BR IF MOVEING RECORDS
*              RESET POINTERS TO REUSE CURRENT BUFFER
         ST    R0,CABTTR0              SET NEW TTR0 IN OLD BUFFER
         LA    XROUTREC,CABDATA+2
         B     MOVEDATA
         SPACE 3
NEXTBUF  EQU   *
         MVC   0(8,XROUTREC),=X'FFFFFFFFFFFFFFFF' SET UP ILE
         LR    WK4,R0                  SAVE NEW TTR0
         STH   R0,10(XROUTREC)         STORE 'R0'
         SRL   R0,16                   GET TT
         STH   R0,8(XROUTREC)          STORE 'TT'
*SET UP BLOCK LENGTH COUNT
         SR    XROUTREC,XROUTBUF       GET LENGTH
         LA    XROUTREC,12-CABDATA+CAB(,XROUTREC) ADJUST FOR END AND ST
         STH   XROUTREC,CABDATA        STORE LENGTH IN OUTPUT BLOCK
         INCR  NCTGLNK                 COUNT CONTIGUOUS OUTPUT LINK
         BAL   R14,FREEBUFO            WRITE OUT BLOCK
         INCR  N#BLKWK                 COUNT NEW BLOCKS
         SPACE
         BAL   R14,GETBUFO             GET A NEW BUFFER
         ST    WK4,CABTTR0             SET UP NEW TTR0
         LA    XROUTREC,CABDATA+2      SET UP OUTPUT RECORD POINTER
         XC    CABDATA,CABDATA         CLEAR OUTPUT BUFFER
         B     MOVEDATA
         TITLE 'AECATLG - DSECTS'
REC      DSECT
ENAME    DC    CL8' '
ETTR     DC    XL3'00'
ETYPE    DC    XL1'00'
EDATA    DS    0C
         SPACE 3
LVWKAREA DSECT
INDEXNO  DC    F'0'
LVWKREGS DS    5F                      REGS 6 THRU 10 SAVE
OLDGLBL  DC    F'0'                    INDEX LEVEL START TTR0
*              SEE 'STATS' DSECT FOR DESCRIPTION OF THESE FIELDS
*              DATA FOR LEVEL OF OLD CATALOG
O#INDEXS DC    F'0'
O#BLOCKS DC    F'0'
O#BLKWK  DC    F'0'
OMAXBLKS DC    F'0'
OCTGLNK  DC    F'0'
OBRKLNK  DC    F'0'
*              DATA FOR LEVEL OF NEW CATALOG
N#INDEXS DC    F'0'
N#BLOCKS DC    F'0'
N#BLKWK  DC    F'0'
NMAXBLKS DC    F'0'
NCTGLNK  DC    F'0'
NBRKLNK  DC    F'0'
LVWKEND  EQU   *
         SPACE 3
         SPACE
*              MAP THE STATISTICS BLOCK FOR BOTH NEW AND OLD INDEXES
         SPACE
STATS    DSECT                         FOR EACH INDEX LEVEL
#INDEXS  DC    F'0'                    NO. OF SEPARATE INDEXES
#BLOCKS  DC    F'0'                    NO. OF BLOCKS
#BLKWK   DC    F'0'                    BLOCKS IN CURRENT  INDEX CHAIN
MAXBLKS  DC    F'0'                    MAX BLKS IN ANY INDEX CHAIN
CTGLNK   DC    F'0'                    NO. OF CONTIG LINKS
BRKLNK   DC    F'0'                    NO. OF BROKEN LINKS
CPYCTL   CSECT
         TITLE 'AECATLG - PRINT CATALOG STATICS'
*        THIS ROUTINE PRINTS ORGANISATION STSTISTICS FOR BOTH NEW AND
*              AND OLD CATALOGS.
*
*              USES DATA ACCUMULATED IN THE STACK, AND RETURNS
*              VIA REG LNK
         SPACE 3
PRINTST  EQU   *
         TM    4(R13),X'40'            TEST PARM=I TO PRINT I/O SUMARY
         BC    8,PRINTST1              BYPASS SECTION IF NOT PARM=I
         SPACE
         PUT   SYSPRINT,=CL121'0       AECATLG I/O PERFORMANCE SUMMARY'
         LA    R3,7                    NO OF STATISTICS
         LA    R4,IOPSM                1ST MESSAGE
         LA    R5,SLOGR                1ST STATISTIC
         L     R0,SLOGR
         S     R0,SREXCP
         ST    R0,SBINC                SET UP BLOCKS-IN-CORE STATISTIC
IOPS1    MVC   LINE(8),=C'0NO. OF '    PREFIX
         MVC   LINE+8(L'IOPSM),0(R4)   MESSAGE
         L     R0,0(,R5)               VALUE
         LA    R1,LINE+8+L'IOPSM+1     PLACE TO PRINT IT
         BAL   R2,FIELD                CVD ETC
         LA    R5,4(,R5)               NEXT VALUE
         LA    R4,L'IOPSM(,R4)         NEXT MESSAGE
         PUT   SYSPRINT,LINE           OUTPUT MESSAGE
         BCT   R3,IOPS1                LOOP
PRINTST1 DS    0H
         SPACE
         LA    SP,STACK                SET SP TO BEGINNING OF STACK
         PUT   SYSPRINT,HDNG1
         LA    WK5,O#INDEXS            SET UP STATISTICS POINTER
         USING STATS,WK5
         BAL   WK4,PRNTCAT             PRINT OLD CATALOG
         LA    SP,STACK
         PUT   SYSPRINT,HDNG2
         LA    WK5,N#INDEXS
         BAL   WK4,PRNTCAT             PRINT NEW CATALOG INFO
         BR    LNK                     REMOVE THIS TO ACTIVATE MOD
********  MOD TO PRINT DEVTYPE SUMMARY
         BR    LNK                     REMOVE THIS TO ACTIVATE MOD
         MVI   PRLINE,C'0'
         BAL   R14,PRNT
         LA   WK4,TBL+16
MODLOOP  L     R0,0(,WK4)
         LTR   R0,R0
         BCR   8,LNK
         MVI   PRLINE,C'0'
         LA    R1,PRLINE+10
         BAL   R14,CNVH4
         MVC   PRLINE+21(6),4(WK4)     VOLSER
         L     R0,12(,WK4)
         LA    R1,PRLINE+28
         BAL  R2,FIELD
         BAL   R14,PRNT
         LA   WK4,16(,WK4)
         B     MODLOOP
      SPACE
CNVH4     LA    R15,8                CONVERT REG0 TO 8 HEX DIGS
         BCTR  R1,0
CNVH41   STC   R0,0(R15,R1)
         SRL   R0,4
         BCT   R15,CNVH41
         NC    1(8,R1),=16X'F'
         TR    1(8,R1),=C'0123456789ABCDEF'
         LA    R1,9(,R1)
         BR    R14
**********************        END OF MOD
         SPACE 3
*PRINT A CATALOG STATS (NEW OR OLD)
*              RETURNS VIA WK4
*              WK5 POINTS TO NEW OR OLD STATS IN STACK
*              SP POINTS TO STACK (AND SO INDEX NO.)
PRNTCAT  EQU   *
         PUT   SYSPRINT,UNDERLNE
         PUT   SYSPRINT,COL1           PRINT HEADINGS
         PUT   SYSPRINT,COL2
         MVC   LINE,LINE-1             CLEAR PRINT LINE
         MVI   LINE,C'0'               SET DOUBLE FIRST SPACE
PRNTCAT1 EQU   *
         LT    R0,#INDEXS              CHECK IF THIS LEVEL NULL
         BCR   E,WK4                   RETURN IF NULL
         BAL R6,DETAIL                 PRINT DETAIL LINE
         CLI   INDEXNO+3,22            CHECK IF BOTTOM OF CATALOG
         BCR   E,WK4                   RETURN IF YES
         MVC   LINE,LINE-1
         LA    SP,LVWKLENG(,SP)        BUMP SP
         LA    WK5,LVWKLENG(,WK5)      BUMP STATS POINTER
         B     PRNTCAT1                GO PRINT NEXT LINE
         SPACE 3
*GENERATE A LINE AND PRINT IT
*              RETURNS VIA R6
*              SP AND STATS POINTER ALREADY SET UP
DETAIL   EQU   *
         L     R0,INDEXNO              INDEX LEVEL NUMBER
         CVD   R0,DEC
         MVC   LINE+2(L'MASK1),MASK1
         ED    LINE+2(L'MASK1),DEC+6
         SPACE
         L     R0,#INDEXS
         LA    R1,LINE+9
         BAL   R2,FIELD
         SPACE
         L     R0,#BLOCKS
         LA    R1,LINE+18
         BAL   R2,FIELD
         SPACE
         L     R0,MAXBLKS
         LA    R1,LINE+29
         BAL   R2,FIELD
         SPACE
         L     R0,CTGLNK
         LA    R1,LINE+39
         BAL   R2,FIELD
         SPACE
         L     R0,BRKLNK
         LA    R1,LINE+47
         BAL   R2,FIELD
         SPACE
         L     R0,BRKLNK
         AL    R0,CTGLNK
         LA    R1,LINE+54
         BAL   R2,FIELD
         SPACE
         L     R0,#BLOCKS
         LA    R3,LINE+62
         BAL   R2,FIELD2
         SPACE
         L     R0,BRKLNK
         LA    R3,LINE+71
         BAL   R2,FIELD2
         SPACE
         PUT   SYSPRINT,LINE
         BR    R6
         SPACE 3
*SET UP A FIELD
*              R0 CONTAINS VALUE
*              R1     PRINT LINE ADDR
*              R2       RETURN ADDR
FIELD    EQU   *
         CVD   R0,DEC
         MVC   0(L'MASK2,R1),=C'*******'
         CLC   DEC(5),=X'0000000000'   CHECK IF NO. TOO LARGE FOR FIELD
         BCR   NE,R2                   RETURN IF PRINT POSN OVERFLOW
         MVC   0(L'MASK2,R1),MASK2
         ED    0(L'MASK2,R1),DEC+5
         BR    R2
         SPACE
*        VALUE IN R0, R2 RETURN, PRINT LOCN IN R3
FIELD2   EQU   *
         SRDA  R0,32                   SHIFT TO ODD REG
         M     R0,=F'100'              ADJ FOR TWO DEC POINTS
         D     R0,#INDEXS
         CVD   R1,DEC
         MVC   0(L'MASK3,R3),=C'*******'
         CLC   DEC(5),=X'0000000000'
         BCR   NE,R2
         MVC   0(L'MASK3,R3),MASK3
         ED    0(L'MASK3,R3),DEC+5
         BR    R2
HDNG1    DC    CL121'0                            OLD CATALOG INFORMATIX
               ON'
HDNG2    DC    CL121'0                            NEW CATALOG INFORMATIX
               ON'
UNDERLNE DC    CL121'+                            _____________________X
               __'
COL1     DC    CL121'0'
         ORG   COL1+1
         DC    C'INDEX'
         ORG   COL1+9
         DC    C'NO. OF'
         ORG   COL1+19
         DC    C'NO. OF'
         ORG   COL1+28
         DC    C'MAX BLKS'
         ORG   COL1+39
         DC    C'-----BLOCK--LINKS-----'
         ORG   COL1+63
         DC    C'BLOCKS'
         ORG   COL1+72
         DC    C'BREAKS'
         ORG   COL1+121
COL2     DC    CL121' '
         ORG   COL2+1
         DC    C'LEVEL'
         ORG   COL2+9
         DC    C'INDEXES'
         ORG   COL2+19
         DC    C'BLOCKS'
         ORG   COL2+28
         DC    C'/INDEX'
         ORG   COL2+39
         DC    C'CONTIG  BROKEN  TOTAL'
         ORG   COL2+63
         DC    C'/INDEX'
         ORG   COL2+72
         DC    C'/INDEX'
         ORG   COL2+121
         DC    C' '                     FOR BLANKING LINE
LINE     DC    CL121' '
MASK1    DC    X'40202120'
MASK2    DC    X'402020202120'
MASK3    DC    X'402020214B2020'
DEC      DC    D'0'
IOPSM    DC    CL19'LOGICAL READS      '
         DC    CL19'PHYSICAL READS     '
         DC    CL19'TIMES BLOCK IN CORE'
         DC    CL19'BLOCKS PURGED      '
         DC    CL19'LOGICAL WRITES     '
         DC    CL19'PHYSICAL WRITES    '
         DC    CL19'WRITER WAITS       '
         DROP  WK5
         EJECT
DMPUNREF DS     0H
*        SECTION TO DUMP ANY BLOCKS WHICH HAVE NOT BEEN REFERENCED
*
*        A 4-BYTE WIDE TABLE IS IN SP(0)
*        CBVECT  ==> START TABLE
*        CBVEND  ==> END OF TABLE
*        EACH ENTRY REPRESENTS THE STATUS OF THE CORRESPONDING
*        RELATIVE BLOCK OF THE CATALOG
*        VALUE = 0  BLOCK NOT YET READ
*        VALUE = 1  BLOCK HAS BEEN READ AND USED
*        VALUE = 2  BLOCK IS A ZERO BLOCK
*        VALUE > 3  ADDR OF CAB IN CORE
         SPACE 2
*        NOW GO THROUGH TABLE AND FOR EACH ENTRY:
*        IF ZERO, GETBUFI
*        IF > 3 THEN DUMP IT
*        REGISTERS: 14-7 USED BY GETBUFI
*        REGISTERS: 10,12,13 USED BY CALLER
*        REGISTERS: 8,9,11 WORK
         SPACE  2
         L      R11,CBVECT                 TABLE START ADDR
         L      R9,CBVEND                  TABLE END ADDR
         BCTR   R9,0                       FOR BXLE
         LA     R8,4                       ENTRY LENGTH
DUR1     L      R0,0(,R11)                 NEXT ENTRY
         LTR    R0,R0
         BC     7,DUR2
         LR     R1,R11                     TABLE ENTRY ADDR
         BAL    R15,CNVP2T                 GET TTR0
         BAL    R15,READBLKS               READ THIS BLK
DUR2     TM     3(R11),3                   TEST IF ZERO OR USED
         BC     7,DUR4                     BRANCH IF SO - OK
*        NOW WE MUST DUMP THIS BLOCK
         TM     DURSW,255                  TEST HEADING PRINTED
         BC     7,DUR3                     BRANCH IF SO
         OI     DURSW,1
         MVC    PRLINE(L'DURHD),DURHD      PRINT HEADING
         BAL    R14,PRNT                   BLANK LINE
DUR3     DS     0H
         L      XRINBUF,0(,R11)
         BAL    R14,DUMPREC
         BAL    R14,FREEBUFI               FREE THE BLOCK
DUR4     BXLE   R11,R8,DUR1                LOOP THROUGH VECTOR
         TM     DURSW,X'FF'                DID WE DUMP ANY?
         BCR    8,LNK                      RETURN IF NOT
*        HERE WE TEST FOR PARM=F OPTION WHICH FORCES ZERO COND CODE
         TM    4(R13),X'20'
         BCR   1,LNK                       RETURN FOR ZERO CODE
         MVC   PRLINE,=CL121'0 RERUN WITH PARM=F TO GET COND CODE ZERO'
         B     ERRET                       SET COND CODE IF NOT PARM=F
DURSW    DC     AL1(0)                     HEADING SWITCH
DURHD    DC     C'1 DUMP OF UNREFERENCED, NON-ZERO-KEY BLOCKS'
DMRSAVE  DC     A(0)
PRTTBL   DC     256C'.'
         ORG    C' '+PRTTBL
         DC     C' '
         ORG    C'='+PRTTBL
         DC     C'='
         ORG    C'@'+PRTTBL
         DC     C'@'
         ORG    C'#'+PRTTBL
         DC     C'#'
         ORG    C'$'+PRTTBL
         DC     C'$'
         ORG    C'A'+PRTTBL
         DC     C'ABCDEFGHI'
         ORG    C'J'+PRTTBL
         DC     C'JKLMNOPQR'
         ORG    C'S'+PRTTBL
         DC     C'STUVWXYZ'
         ORG    C'0'+PRTTBL
         DC     C'0123456789'
         ORG
PRTTBL1  DC    C'ECA86420'
         EJECT
DUMPREC  DS     0H              ROUTINE DUMPS ONE REC TP PRINTER
         ST     R14,DMRSAVE
         USING  CAB,XRINBUF
         MVC    PRLINE(7),=C'0 TTR='
         LA     R1,PRLINE+6
         L      R0,CABTTR0
         BAL    R14,CNVH3
         MVC    0(9,R1),=C',  CCHHR='
         LA     R1,8(,R1)
         LM     R14,R15,CABM               MBBCCHHR
         LA     R2,10
DMP4     STC    R15,0(R2,R1)
         SRDL   R14,4
         BCT    R2,DMP4
         NC     1(10,R1),=16X'F'
         TR     1(10,R1),=C'0123456789ABCDEF'
         MVC    11(7,R1),=C',  KEY='
         LA     R1,19(,R1)
         L      R0,CABKEY
         BAL    R14,CNVH4
         LA     R1,1(,R1)
         L      R0,CABKEY+4
         BAL    R14,CNVH4
         MVI    1(R1),C'='
         MVC    3(8,R1),CABKEY
         BAL    R14,PRNT                   BLK HEADING
         MVI    PRLINE,C'0'                DOUBLE SPACE
         LA     R2,CABDATA
         LA     R4,8                       # OF LINES
DMP5     MVC    PRLINE+89(32),0(R2)
         MVI    PRLINE+88,C'*'
         MVI    PRLINE+89+32,C'*'
         TR     PRLINE+89(32),PRTTBL
         IC    R0,PRTTBL1-1(R4)         1ST DIGIT OF ADDRESS
         STC    R0,PRLINE+2
         MVI    PRLINE+3,C'8'
         LA     R1,PRLINE+5
         BAL    R14,CNVH4S                 FORMAT WORD AT 0(,R2)
         BAL    R14,CNVH4S                 TO 1(R1)
         BAL    R14,CNVH4S
         BAL    R14,CNVH4S
         LA     R1,1(,R1)
         BAL    R14,CNVH4S
         BAL    R14,CNVH4S
         BAL    R14,CNVH4S
         BAL    R14,CNVH4S
         BAL    R14,PRNT
         BCT    R4,DMP5                    LOOP OVER 8 LINES
         DROP   XRINBUF
         BAL    R14,PRNT                   EXTRA BLANK LINE
         L      R14,DMRSAVE
         BR     R14
         SPACE  2
CNVH4S   L      R0,0(,R2)
         LA     R15,8
CNVH4S1  STC    R0,0(R15,R1)
         SRL    R0,4
         BCT    R15,CNVH4S1
         NC     1(8,R1),=16X'F'
         TR     1(8,R1),=C'0123456789ABCDEF'
         LA     R1,9(,R1)
         LA     R2,4(,R2)
         BR     R14
         TITLE 'AECATLG - CONSTS,WORKAREAS AND DSECTS'
TBL      DC    80D'0'  SPACE FOR 40 DISK VOLSERS
TBLEND   DC    2D'0'
SAVEAREA DC    18F'0'                  OS SAVE AREA
LVWKLENG EQU   (LVWKEND-LVWKAREA+3)/4*4 ENSURE MULTIPLE OF FULL WDS
GLBLTTR0 DC    F'256'                  GLOBAL NEXT TTR FOR OUTPUT
INENDTTR DC    F'0'                    LAST BLOCK IN CURRENT INDEX
INPUTTTR DC    F'0'                    INPUT TTR WHEN TREESRCH CALLED
MOVEINST MVC   0(*-*,XROUTREC),REC
BLOCKEND DC    H'0'                    MAXIMUM SIZE OF BLOCK TO ALLOW
*                                      REQUIRED END ROOM
TRYSW    DC    CL1' '                  SET TO -1 IF TESTING INDEX SIZE
NULLMESS DC    C'0NULL ENTRY DELETED: '
NULLMDSN DC    CL44' '
         DC    (NULLMESS+121-NULLMDSN-44)C' '  REST OF LINE
         LTORG
VCLSTBLK DC    F'0'
         DROP  XROUTBUF
         TITLE 'AECATLG --  I/O ROUTINES'
R2       EQU   2
R3       EQU   3
R4       EQU   4
R5       EQU   5
R6       EQU   6
R7       EQU   7
R8       EQU   8
R11      EQU   11
         SPACE 2
INITST   XC    SLOGR(SWWAIT-SLOGR+4),SLOGR
         SR    R0,R0
         ST    R0,GLBLTTR0
         MVI   GLBLTTR0+2,1            SET 1ST TTR TO 0 0 1
         ST    R0,INENDTTR
         ST    R0,INPUTTTR
         STH   R0,BLOCKEND
         LA    R1,22
         LA    R2,STACK
INITST1  XC    4(LVWKLENG-4,R2),4(R2)
         LA    R2,LVWKLENG(,R2)
         BCT   R1,INITST1
         BR    R14
         SPACE 2
INITIO   DS    0H                      THIS SECTION INITIALISES I/O
         SPACE 3
         SPACE
*        GET BUFFER SIZE REQUIRED
*        MINIMUM IS 45 BUFFER BLOCKS + SPACE FOR BLOCK DESCRIPTOR
*        VECTOR
*        MAX REQD IS TOTAL SIZE OF INPUT CATALOG PLUS 23 BLOCKS +
*        SPACE FOR BLOCK DESCRIPTOR VECTOR
         SPACE 2
*        FIND NO OF TRKS IN INPUT CATALOG
         L     R1,IOBIDCB              DCB
         L     R1,44(,R1)              DEB
         LA    R0,0                    FOR IC
         IC    R0,16(,R1)              DEBNMEXT - NO OF EXTENTS
         LA    R2,32(,R1)              1ST EXTENT DESCRIPTOR
         SR    R1,R1                   ZERO TO ACCUMULATE
GM1      AH    R1,14(,R2)              ADD TRKS THIS EXTENT
         LA    R2,16(,R2)              POINT TO NEXT
         BCT   R0,GM1                  LOOP THRU EXTENTS
*        R1 CONTAINS TOTAL TRKS IN INPUT CATALOG
         MH    R1,BLKPTRKI+2           TOTAL BLOCKS IN INPUT
         LR    R2,R1                   SAVE IN R2
         SLL   R2,2                    *4 = BYTES REQD FOR TABLE
         LR    R3,R2                   SAVE IN R3
         LA    R2,7(,R2)               ROUND UP TO NEXT DBLWD
         N     R2,=X'FFFFFFF8'
         LA    R1,23(,R1)              NO BLOCKS + 23
         LA    R0,CABLEN               * BLOCK  LENGTH
         MR    R0,R0
         ALR   R1,R2                   PLUS TABLE SIZE
         ST    R1,GMMAX                IS MAX SPACE REQD
         AL    R2,=A(45*CABLEN)        TABLE + 45 BLOCKS
         CR    R2,R1                   ENSURE NO
         BC    4,*+6                   LARGER THAN
         LR    R2,R1                   MAX
         ST    R2,GMMIN                IS MIN SPACE REQD
         LA    R0,2048                 GET 25 FOR DUMP
         GETMAIN R,LV=(0)
         LR    R2,R1
         GETMAIN MF=(E,GETML)
         LA    R0,2048
         FREEMAIN R,LV=(0),A=(R2)      FREE WORK AREA
         BR    R14
         EJECT
         SPACE
*        NOW ZERO EACH ENTRY IN THE BLOCK DESCRIPTOR TABLE
*        TO INDICATE THAT EACH BLOCK IS NOT IN CORE
INITIO1  DS    0H                      ENTRY FOR PARTIAL INITIALISE
         LA    R0,CBRPC
         ST    R0,CBRPCN
         ST    R0,CBRPCP
         LA    R0,CBFRC
         ST    R0,CBFRCN
         ST    R0,CBRPCP
         LA    R0,CBWQC
         ST    R0,CBWQCN
         ST    R0,CBWQCP
         LA    R0,4                    INCREMENT
         LR    R1,R3                   SIZE OF VECTOR TABLE
         BCTR  R1,0                    -1 FOR BXLE
         L     R2,GMAREA               ADDR OFTABLE
         ST    R2,CBVECT               SAVE
         SR    R15,R15                 ZERO
         ALR   R1,R2                   END OF TABLE - 1
GM2      ST    R15,0(,R2)              ZERO TABLE ENTRY
         BXLE  R2,R0,GM2               LOOP
         ST    R2,CBVEND               SAVE TABLE END
         LA    R2,7(,R2)               ROUND UP TO NEXT DBLWD
         N     R2,=X'FFFFFFF8'
         SPACE 2
*        FORMAT THE OUTPUT CATALOG
         LR    R3,R2                   CCW AREA FOR FORMAT
         L     R4,BLKPTRKO             BLKS PER TRK O/P CATLG
         LR    R5,R4
         SLL   R5,3                    * 8
         ALR   R5,R3                   ADDRESS OF COUNTS
         AL    R5,=AL1(WCKD,0,0,0)     + CCW OP CODE
         L     R6,=AL1(CC+SLI,0,0,8)
         B     GM5                     ENTER LOOP
GM4      LA    R3,8(,R3)               NEXT CCW
GM5      STM   R5,R6,0(R3)             STORE CCW
        AL    R5,=A(8)
         BCT   R4,GM4                  LOOP FOR ALL BLKS ON TRK
         MVI   4(R3),SLI               REMOVE CC FROM LAST
         ST    R2,CCWOTIC              SET TIC TO 1ST CCW
         MVI   CCWOTIC,TIC             RESTORE OP CODE
         LA    R0,CCWO                 SET IOB --> FORMATTING
         ST    R0,IOBOCCW              CCW CHAIN PREFIX
         SPACE
*        FORMAT CHAN PGM IS NOW SET UP, EXECUTE IT FOR EACH TRK
         SPACE
*        FIRST CALCULATE HOW MANY TRACKS IN O/P CATALOG
         LA    R0,0
         L     R1,IOBODCB              DCB
         L     R1,44(,R1)              DEB
         SR    R4,R4
         IC    R4,16(,R1)              DEBNMEXT
GM6      AH    R0,32+14(,R1)           TRKS THIS EXTENT
         LA    R1,16(,R1)              NEXT EXTENT
         BCT   R4,GM6                  LOOP THRU EXTENTS
         ST    R0,TRKO                 SAVE TRKS IN O/P
         SPACE
         LA    R5,8(,R3)               1ST COUNT AREA
         SR    R0,R0
         ST    R2,12(,R13)             SAVE
*        LOOP FOR EACH TRACK STARTS HERE
GM7      LA    R3,IOBOM                ADDR FOR MBBCCHHR
         L     R4,IOBODCB              DCB
         L     R4,44(,R4)              DEB
         ST    R0,TTO
         SLL   R0,16                   TTR0
         BAL   R15,CNVT2M              SET UP MBBCCHHR FOR TTR0 FROM R0
         DC    2Y(0)                   NO ERROR POSSIBLE
         L     R0,BLKPTRKO             BLOCKS PER TRK IN O/P
         LR    R1,R5                   ADDR 1ST COUNT
         LM    R6,R7,IOBOM             MBBCCHHR
         SLDL  R6,24                   CCHH TO R6
         L     R7,=X'00080100'         RKDD OF COUNT FIELD
GM8      AL    R7,=X'01000000'         INCREMENT R
         STM   R6,R7,0(R1)             SAVE NEXT COUNT FIELD
         LA    R1,8(,R1)               POINT TO NEXT
         BCT   R0,GM8
         EXCP  IOBO                    START THE I/O
         WAIT  ECB=ECBO                WAIT FOR IT
         LA    R1,IOBO
         BAL   R3,CLI7F                CHECK I/O COMPLETION
         LA    R0,1                    TO INCREMENT CURRENT TRK NO
         AL    R0,TTO                  INCREMENT
         C     R0,TRKO                 COMPARE WITH LIMIT
         BC    4,GM7                   LOOP IF STILL WITHIN EXTENTS
         BCTR  R0,0                    TT OF LAST
         SLL   R0,8
         IC    R0,BLKPTRKO+3           R OF LAST
         SLL   R0,8
         ST    R0,VCLSTBLK             SAVE FOR INSERTION IN VICE
         L     R2,12(,R13)             RESTORE
         SPACE 3
*        HANG ALL BLOCKS ON THE FREE QUEUE
         SPACE
         LA    R0,CABLEN               BXLE INCREMENT
         L     R1,GMLEN                TO CALC END
         SR    R1,R0                   TO ENSURE BXLE FINISHES OK
*        R2 IS AT END OF TABLE = 1ST BLOCK
         LA    R3,CBFRC                PSEUDO 1ST BLOCK IN FREE CHAIN
         AL    R1,GMAREA               ADDR OF LAST ENTRY
GM3      ST    R2,CNEXT(,R3)           POINT FROM PREVIOUS
         XC    0(256,R2),0(R2)         ZERO THE BLOCK
         XC    256(CABLEN-256,R2),256(R2)
         ST    R3,CPREV(,R2)           POINT TO PREVIOUS
         LR    R3,R2                   SAVE THIS AS PREVIOUS
         BXLE  R2,R0,GM3               GET NEXT
         LA    R2,CBFRC                PSEUDO 1ST BLOCK
         ST    R2,CNEXT(,R3)           MAKE FINAL
         ST    R3,CPREV(,R2)           LINK UP
         SPACE 2
*        SET UP ECB'S FOR I/O
         MVI   ECBI,X'7F'              SET FINISHED
         MVI   ECBO,X'7F'              SET FINISHED
         XC    IOBOCCW,IOBOCCW         SET NO O/P IN PROGRESS
         SPACE
         BR    R14
         EJECT
*        CONVERT ROUTINES
         SPACE
*        CNVT2P CONVERT TTR0 (R0) TO ADDR OF VECTOR ENTRY (R1)
CNVT2P   ST    R0,12(,R13)             SAVE
         CLC   14(1,R13),BLKPTRKI+3    TEST IF R OK
         BC    2,TTRBAD                BR IF NOT
         SRDL  R0,16                   TT TO R0, R TO R1
         MH    R0,BLKPTRKI+2           TT * BLKS/TRK
         SRL   R1,24                   R
         BCTR  R1,0                    R-1
         ALR   R1,R0                   BLOCK NO (0=1ST)
         SLL   R1,2                    *4 TO ADDRESS TABLE
         AL    R1,CBVECT               + VECTOR TABLE ADDR
         L     R0,12(,R13)             RESTORE
         CL    R1,CBVEND               TEST IF OUTSIDE TABLE
         BCR   12,R15                  RETURN IF NOT
         SPACE
* WE HAVE BEEN REQUESTED TO GET A BLOCK WITH A TTR OUTSIDE THE CATALOG
*        USUALLY XRINBUF WILL POINT TO THE BLOCK CONTG THE BAD POINTER
TTRBAD   DS    0H
         MVC   PRLINE(EM11L),EM1       MESSAGE SKELETON
         LA    R1,PRLINE+EM12L         SPOT FOR TTR
         BAL   R14,CNVH3
         BAL   R14,PRNT
         BAL   R8,TTRPI                PRINT INDEXES
         B     OPTER                   FINISH UP
         SPACE
EM1      DC    C'0BAD TTR ('
EM12L    EQU   *-EM1
         DC    C'TTTTRR) IN INPUT CATALOG THROUGH INDEXES (IN TTR):'
EM11L    EQU   *-EM1
         SPACE 2
*        CNVP2T CONVERTS ADDR OF VECTOR ENTRY (R1) TO TTR0(R0)
CNVP2T   ST    R1,12(,R13)             SAVE
         SL    R1,CBVECT               DISPL
         SRL   R1,2                    BLOCK NO
         SR    R0,R0                   FOR DIVIDE
         D     R0,BLKPTRKI             R-1, TT
         SLL   R1,8                    TT0
         ALR   R1,R0                   TTR-1
         LA    R0,1(,R1)               TTR
         SLL   R0,8                    TTR0
         L     R1,12(,R13)             RESTORE
         BR    R15                     RETURN
         EJECT
CNVT2M   DS    0H                      TTR0 TO MBBCCHHR CONVERT ROUTINE
*
*        ON ENTRY, R0 CONT TTR0, R3 --> MBBCCHHR, R4 --> DEB
*                  DEVTYPE INFO IS AT DCB+DTD,RETN IN R15
         SPACE
         STM   R15,R4,CNVSAVE          SAVE REGS
         SRL   R0,8                    R IN RIGHT BYTE
         STC   R0,7(,R3)               STORE R
         SRL   R0,8                    TT
         SR    R15,R15
         IC    R15,16(,R4)             DEBNMEXT - NO OF EXTENTS
         LR    R1,R15                  SAVE
         LR    R2,R4                   SAVE DEB ADDR
CNVT1    SH    R0,32+14(,R2)           LESS TRKS THIS EXTENT
         BC    4,CNVT2                 BR IF IN THIS EXTENT
         LA    R2,16(,R2)              NEXT EXTENT
         BCT   R1,CNVT1                LOOP THRU EXTENTS
         LM    R15,R4,CNVSAVE          ERROR RETURN
         BR    R15
CNVT2    SR    R15,R1                  GET M FOR THIS EXTENT
         STC   R15,0(,R3)              M
         MVC   1(6,R3),36(R2)          GET BBCCHH
         AH    R0,32+14(,R2)           TRK DISPL IN THIS EXTENT
         BC    8,CNVTEX
         AH    R0,32+8(,R2)            + START TRK THIS EXTENT
         LR    R1,R0                   FOR DIVIDE
         SR    R0,R0
         L     R4,24(,R4)              DCB ADDR
         LH    R4,DTD+10(,R4)          TRKS/CYL FROM DEVTYPE
         DR    R0,R4                   TRKS, CYL
         STC   R0,6(,R3)               SET HH
         AH    R1,32+6(,R2)            + CYL START THIS EXTENT
         STC   R1,4(,R3)               SET XC
         SRL   R1,8
         STC   R1,3(,R3)               SET CX
CNVTEX   LM    R15,R4,CNVSAVE          RESTORE
         B     4(,R15)                 NORMAL RETURN
CNVSAVE  DC    6A(0)
         EJECT
CNVM2T   DS    0H                      MBBCCHHR TO TTR0 CONVERT ROUTINE
*
*        ON ENTRY, R3 --> MBBCCHHR, R4 --> DEB
*                  DEVTYPE INFO AT DCB+DTD
*        RETURN IS MADE TO R15 WITH TTR0 IN R0
         SPACE
         STM   R15,R4,CNVSAVE          SAVE REGS
         SR    R0,R0
         SR    R15,R15
         IC    R15,0(,R3)              M
         LR    R2,R4                   DEB
         CLC   0(1,R3),16(R4)          SEE IF M OK
         BC    4,*+6                   BR IF SO
         DC    Y(0)
         LA    R15,1(,R15)             M+1 FOR BCT
         B     CNVM2
CNVM1    AH    R0,32+14(,R2)           ADD TRKS IN PREVIOUS EXTENTS
         LA    R2,16(,R2)              POINT TO NEXT EXTENT
CNVM2    BCT   R15,CNVM1               LOOP THRU M-1 EXTENTS
         CLC   1(6,R3),32+4(R2)        TEST IN THIS EXTENT
         BC    10,*+6
         DC    Y(0)
         CLC   3(4,R3),32+10(R2)
         BC    12,*+6
         DC    Y(0)
         IC    R15,6(,R3)              HEAD NO
         ALR   R0,R15
         SH    R0,32+8(,R2)            - HEAD NO AT START OF EXTENT
         IC    R15,3(,R3)              HIGH BYTE OF CC
         SLL   R15,8
         IC    R15,4(,R3)              LOW BYTE
         L     R4,24(,R4)              DCB
         SH    R15,32+6(,R2)           CYLS THIS EXTENT
         MH    R15,DTD+10(,R4)         * TRKS/CYL
         ALR   R0,R15                  TOTAL TRKS
         SLL   R0,8
         IC    R0,7(,R3)               GET R
         SLL   R0,8
         L     R15,CNVSAVE             RESTORE
         LM    R1,R4,CNVSAVE+8         REGS
         BR    R15
         SPACE
         EJECT
*        ROUTINE SETS SO FUTURE GETBUFI MAKES PURGABLE
PURGST   LA    R0,CBRPC                BOTTOM OF PURGABLE CHAIN
         ST    R0,CABGP                SET GET POINTER
         BR    R14                     RETURN
         SPACE
*        ROUTINE SETS SO FUTURE GETBUFI MAKES FIXED
PURGEND  LA    R0,0                    NO-CHAIN INDICATOR
         ST    R0,CABGP                SET POINTER
         BR    R14                     RETURN
         EJECT
FREEBUF  DS    0H                      THE BUFFER AT XROUTBUF WAS GOT
*                                      FOR OUTPUT AND IS NO LONGER
*                                      NEEDED. THIS FREES IT.
         SPACE
         L     R1,CBFRCN               FIRST FREE
         ST    R1,CNEXT(,XROUTBUF)     POINT TO IT FROM THIS
         ST    XROUTBUF,CPREV(,R1)     POINT BACK TO THIS
         LA    R0,CBFRC                FREE CHAIN START
         ST    R0,CPREV(,XROUTBUF)     POINT BACK TO FREE START
         ST    XROUTBUF,CBFRCN         POINT TO THIS AS FIRST FREE ONE
         BR    R14                     RETURN
         SPACE
         SPACE 2
         USING CAB,XRINBUF
*        SUBROUTINE TAKES GIVEN BUFFER IN XRINBUF
*        IF IT IS FIXED, IT FREES IT
*        I F IT IS PURGABLE IT LEAVES IT SO
FREEBUFI LT    R0,CABNEXT              SEE IF FIXED
         BCR   7,R14                   RETURN IF NOT
         L     R0,CABTTR0              GET TTR0
         BAL   R15,CNVT2P              GET POINTER ENTRY ADDR
         C     XRINBUF,0(,R1)          CHECK INTEGRITY
         BC    8,*+6
         DC    Y(0)
         LA    R0,1
         ST    R0,0(,R1)               SET COMPLETE
         LA    R1,CBFRC                FREE CHAIN DUMMY
         L     R2,CBFRCN               FIRST FREE
         ST    R1,CABPREV              BACK PTR
         ST    R2,CABNEXT              FORW PTR
         ST    XRINBUF,CNEXT(,R1)      NEW FIRST
         ST    XRINBUF,CPREV(,R2)
         BR    R14                     RETURN
         DROP  XRINBUF
         EJECT
* * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *
*
*        GETBUF SUBROUTINE
*        CALLED BY  BAL  R15,  TO GET A BUFFER ADDRESS IN R2
*               BY BALR R15,  GETS A BUFFER ADDRESS IF EASY
*                             OTHERWISE R2 CONT 0
*
* * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *
         SPACE 2
GETBUF   L     R2,CBFRCN               GET NEXT FREE
         LA    R0,CBFRC
         CR    R2,R0
         BC    8,GB1                   BR IF NONE
         L     R1,CNEXT(,R2)           NEXT AFTER THIS ONE
         ST    R1,CBFRCN               STORE AS NEW 1ST ON FREE CHAIN
         ST    R0,CPREV(,R1)           LINK UP TO NEW FIRST ONE
         LA    R0,0                    ZERO
         ST    R0,CNEXT(,R2)           ZERO INDICATES NOT ON ANY CHAIN
         BR    R15                     RETURN
         SPACE
GB1      DS    0H
         SR    R2,R2                   ZERO
         LTR   R15,R15                 SEE IF USER INSISTS ON GETTING
         BCR   2,R15                   A BLOCK - RETURN IF NOT
         STM   R14,R15,20(R13)         SAVE
         SPACE
*        HERE A DECISION HAS TO BE MADE AS TO WHERE THE NEXT BLOCK WILL
*        COME FROM.
*        FIRST TRY TO PURGE A BLOCK ON PURGABLE QUEUE,
*        IF THERE ARE NO PURGABLE BLOCKS, WE WAIT FOR WRITE TASK TO
*        FINISH, THEN THERE SHOULD BE SOME MORE FREE BLOCKS
         L     R2,CBRPCN               GET NEXT ON PURGE Q
         C     R2,CBRPCP               SEE IF ANY
         BC    8,GB2                   BR IF NONE
         USING CAB,R2
         L     R0,CABTTR0              GET TTR
         BAL   R15,CNVT2P              CONVERT TO PNTR
         C     R2,0(,R1)               * CHECK IF INTEGRITY OF BLOCKS
         BC    8,*+6                   IS PRESERVED
         DC    Y(0)                    *
         LA    R0,0
         ST    R0,0(,R1)               SET TO INDICATE THIS BLOCK
*                                      NOT IN CORE ANY MORE
         INCR  SPURGED                 COUNT NO OF PURGED BLOCKS
         L     R1,CABPREV              GET PREVIOUS
         L     R3,CABNEXT              GET NEXT
         ST    R3,CNEXT(,R1)           REMOVE THIS
         ST    R1,CPREV(,R3)           ONE FROM CHAIN
         LA    R0,0
         ST    R0,CABNEXT              SET NOT-ON-ANY-CHAIN
         C     R2,CABGP                SEE IF THIS IS WHERE PURGE LIMIT
         BC    7,*+8                   IS SET - BR IF NOT
         ST    R3,CABGP                SET NEW PURGE LIMIT
         LM    R14,R15,20(R13)         RESTORE
         BR    R15                     RETURN
         DROP  R2
         SPACE 2
*        HERE WE MUST WAIT FOR WRITER TO FINISH AND RETURN
*        FREE BLOCKS, THEN GET A FREE ONE
GB2      DS    0H
         BAL   R14,WAITO               WAIT TO FINISH
         BAL   R14,EXCPO               WRITE SOME OUT
         LA    R2,CBFRC                *
         C     R2,CBFRCP               *
         BC    7,*+6                   *
         DC    Y(0)                    *
         LM    R14,R15,20(R13)
         B     GETBUF                  TRY AGAIN
         SPACE 3
*        THIS ROUTINE GETS A BUFFER WHICH CALLER CAN USE FOR OUTPUT
*        IT RETURNS THE ADDRESS IN XROUTBUF
         SPACE
GETBUFO  BAL   R15,GETBUF              GET A BUFFER ADDR IN R2
         LR    XROUTBUF,R2             SET IN CALLERS REGISTER
         BR    R14                     RETURN
         EJECT
*        GETBUFI ROUTINE READS A GIVEN CATALOG BLOCK AND PASSES
*        ITS ADDRESS BACK TO USER
*        THE BLOCK REQD HAS TTR0 IN R0 ON ENTRY, THE ADDR OF THE
*        BLOCK IS PASSED BACK IN XRINBUF
GETBUFI  DS    0H
         BAL   R15,CNVT2P              GET VECTOR POINTER ADDRESS
         TM    3(R1),3                 SEE IF FINISHED WITH
         BC    7,TTRFIN                BLOCK IS DOUBLY USED IF SO
         L     XRINBUF,0(,R1)          GET ADDR OF CAT BLOCK
         LTR   XRINBUF,XRINBUF         TEST
         BC    8,GBI1                  BR IF NOT IN CORE - MUST DO I/O
         ST    R0,28(,R13)               SAVE
         INCR  SLOGR
         L     R0,28(,R13)             RESTORE
*        HERE WE MUST TAKE THE BLOCK OFF THE PURGABLE CHAIN
         L     R3,CNEXT(,XRINBUF)
         LTR   R3,R3                   TEST IF ON A CHAIN
         BC    8,TTRFIN                ERROR IF NOT
         L     R2,CPREV(,XRINBUF)
         ST    R3,CNEXT(,R2)
         ST    R2,CPREV(,R3)
         SR    R3,R3
         ST    R3,CNEXT(,XRINBUF)      SET NOT-ON-ANY-CHAIN
*        HERE WE MUST HANG THE BLOCK ON PURGABLE CHAIN AT APPROPRIATE
*        SPOT IF USER WILL LET US
         L     R3,CABGP                GET SPOT TO HANG
         LTR   R3,R3                   TEST IF OK
         BCR   8,R14                   MERELY RETURN TO USER IF NOT
         ST    R3,CNEXT(,XRINBUF)      POINT TO INDICATED BLOCK
         L     R4,CPREV(,R3)           GET PLACE TO BREAK IN
         ST    R4,CPREV(,XRINBUF)
         ST    XRINBUF,CNEXT(,R4)
         ST    XRINBUF,CPREV(,R3)
         ST    XRINBUF,CABGP           RESET PURGE POINTER
         BR    R14
         SPACE
         SPACE 2
*        HERE THE BLOCK IS NOT IN CORE, SO READ IT IN, TOGETHER
*        WITH ADJACENT FOLLOWING BLOCKS WHICH MIGHT BE REQUIRED LATER
         SPACE
GBI1     DS    0H
         BAL   R15,READBLKS            DO SOME READING, STARTING WITH
*                                      TTR0 IN R0
         B     GETBUFI                 THE BLOCK SHOULD BE IN CORE NOW
         EJECT
READBLKS DS    0H
         STM   R14,R8,SAVGI
         LA    R3,IOBIM                ADDR FOR CONVERT
         L     R4,IOBIDCB
         L     R4,44(,R4)              DEB
         BAL   R15,CNVT2M              SET UP MBBCCHHR
         DC    2Y(0)                   NO POSSIBILITY OF ERROR
         IC    R15,IOBIM+7             GET R
         BCTR  R15,0                   -1
         STC   R15,IOBIM+7             SAVE FOR SEARCH
         BAL   R15,GETBUF              GET A BUFFER FOR IT
         USING CAB,R2
         LA    R3,CCWI                 TO OI CC AND SET TIC
         SPACE
*        START OF LOOP TO SET UP A READ CHAN PGM
         L     R8,BLKPTRKI             SET MAX CPGM CHAIN LENGTH TO BE
         AR    R8,R8                   2 TRKS.  WE DON'T WANT TO GIVE
*                                      MVS A PAIN BY MAKING A BIG ONE
GBI2     DS    0H
         LM    R4,R7,CCWRPATT          GET PATTERN FOR CPGM
         LA    R15,CABCOUNT            RELOACTE
         ALR   R4,R15
         LA    R15,CABKEY              RELOCATE
         ALR   R6,R15
         STM   R4,R7,CABCCW            SET READ CCW UP
         MVC   CABM(3),IOBIM           SET MBB IN CAB
         XC    CABCOUNT,CABCOUNT       CLEAR COUNT AREA
         LA    R4,CABCCW               JOIN TO PREVIOUS
         ST    R4,16(,R3)              SET FOR TIC
         MVI   16(R3),TIC              SET TIC OP-CODE
         OI    12(R3),CC               SET COMMAND CHAIN
         LA    R3,CABCCW               ADDR FOR JOINING TO
         L     R1,SAVGI+12             RESTIRE R1
         LA    R1,4(,R1)               NEXT BLOCK
         C     R1,CBVEND               SEE IF LAST
         BC    8,GBI3                  BR IF SO
         ST    R1,SAVGI+12
         L     R4,0(,R1)               SEE IF READ NEEDED FOR NEXT
         LTR   R4,R4
         BC    7,GBI3                  BR IF NOT
         BCT   R8,*+8                  FINISH IF MADE 2 TRKS ALREADY
         B     GBI3
         LA    R15,GETBUF              TRY TO GET A BUFFER
         BALR  R15,R15                 BUT NOT TO WORRY IF CANT EASILY
         LTR   R2,R2                   TEST IF GOT ONE
         BC    7,GBI2                  BR IF SO - MAKE ANOTHER CHAN PGM
         SPACE
*        HERE WE HAVE STOPPED MAKING READ CHAN PGMS TO HANG ON TO
*        THE IOB FOR ONE REASON OR ANOTHER.
*        SO NOW EXCP, AND THEN LOOK AT WHAT WE GOT
GBI3     EXCP  IOBI                    EXCP TO READ BLOCKS
         INCR  SREXCP                  COUNT READ EXCPS
         WAIT  ECB=ECBI                WAIT FOR READ TO FINISH
         LA    R1,IOBI
         CLI   ECBI,X'42'              SEE IF EOX
         BC    8,*+8                   OK IF SO
         BAL   R3,CLI7F                CHECK I/O COMPLETION
         SPACE
*        HAVE A LOOK AT EACH BLOCK READ, AND SET IT ON CORRECT CHAIN
         L     R2,CCWITIC              1ST CHAN PGM
GBI4     LA    R2,0(,R2)               REMOVE TOP BYTE
         SL    R2,=A(CABCCW-CAB)       BACK TO CAB ADDRESS
         USING CAB,R2
         CLC   CABCOUNT,=XL8'0'        SEE IF RECORD WAS READ
         BC    8,GBI45                 (WILL NOT BE AFTER EOX)
         L     R4,IOBIDCB
         L     R4,44(,R4)              DEB
         LA    R3,CABM                 MBBCCHHR ADDRESS
         BAL   R15,CNVM2T              CONVERT TO TTR0
         ST    R0,CABTTR0              STORE IN CAB
         BAL   R15,CNVT2P              CONVERT ALSO TO POINTER ADDRESS
         L     R3,0(,R1)               SEE WHAT IS THERE ALREADY
         LTR   R3,R3                   TEST
         BC    8,*+6                   BR IF NOT THERE
         DC    Y(0)                    SOMETHING MUST BE WRONG
         LA    R3,CBRPC                TOP OF PURGABLE CHAIN
         ST    R2,0(,R1)               STORE ADDRESS OF CAB IN POINTER
         CLC   CABKEY,=XL8'0'          SEE IF ZERO BLOCK
         BC    7,GBI5                  BR IF NOT
         LA    R0,2                    ZERO IND
         ST    R0,0(,R1)               SAVE TO PREVENT FURTHER READ
GBI45    DS    0H
         LA    R3,CBFRC                FREE CHAIN START
GBI5     DS    0H                      R3 IS CHAIN ADDR TO PUT BLOCK
         L     R4,CNEXT(,R3)
         ST    R4,CABNEXT
         ST    R2,CNEXT(,R3)
         ST    R2,CPREV(,R4)
         ST    R3,CABPREV
         TM    CABRKD+4,CC             SEE IF CHAINED
         L     R2,CABRTIC              GET ADDR OF NEXT
         DROP  R2
         BC    1,GBI4                  LOOP IF ANOTHER
         LM    R14,R8,SAVGI
         BR    R15
SAVGI    DC    11A(0)
         EJECT
*        HERE WE HAVE DETECTED THE CONDITION THAT A BLOCK IS REQUESTED
*        FOR INPUT, BUT IT HAS ALREADY BEEN MARKED AS FINISHED WITH.
*        THUS EITHER IT IS A ZERO BLOCK OR HAS A DOUBLE REFERENCE TO IT
*        IF IT IS ZERO, WE JUST PRINT THE INDEX ROUTE TO IT AND EXIT.
*        IF IT IS A DOUBLE REFERENCE, WE TRY AND PRINT BOTH PATHS TO IT
*        THE SECOND PATH CAN BE FOUND FROM THE CURRENT STACK.
*        THE FIRST PATH IS FOUND BY STARTING THE WHOLE COPY AGAIN
*        WITH A TRAP SET FOR THE RELEVANT BLOCK.
*        THE PATH IS THEN AVAILABLE FROM THE STACK.
         SPACE
TTRFIN   DS    0H
         TM    TTRFLG,1                TEST IF 2ND ENTRY(FOR 1ST PATH)
         BC    1,TTRF3                 BR IF SO
         TM    3(R1),2                 TEST IF ZERO BLOCK
*        KEEP COND CODE TO BAL
         ST    R1,TTRFV                ADDR OF BLOCK PTR IN VECTOR
         MVC   PRLINE(L'EM2),EM2
         LA    R1,PRLINE+L'EM2
         BAL   R14,CNVH3               PUT TTR IN MESSAGE
         SPM   R14                     RESTORE CC FROM TM 3(1),2
         BC    14,TTRF4                BR IF NOT, MUST BE DOUBLE
         SPACE
*        HANDLE POINTER TO ZERO BLOCK HERE
         MVC   PRLINE+L'EM2+7(L'EM5),EM5
         MVC   PRLINE+L'EM2+7+L'EM5+1(L'EM4),EM4
TTRFIN1  BAL   R14,PRNT
         BAL   R8,TTRPI
         WAIT  ECB=ECBI
         WAIT  ECB=ECBO
         B     OPTER                   ERROR RETURN
         SPACE 2
TTRF4    DS    0H                      HANDLE DOUBLE REFERENCE
         OI    TTRFLG,1                SET NEXT AS 2ND
         MVC   PRLINE+L'EM2+7(L'EM3+L'EM4),EM3
         BAL   R14,PRNT
         BAL   R8,TTRPI                PRINT INDEX LEVELS CURRENT
*        NOW START THE WHOLE COPY AGAIN
         WAIT  ECB=ECBI                ENSURE PREVIOUS I/O
         WAIT  ECB=ECBO                IS STOPPED FIRST
         BAL   R14,INITST              INITIALISE VARIABLES
         L     R3,CBVEND
         S     R3,CBVECT               VECTOR LENGTH
         BAL   R14,INITIO1             INITIALISE I/O
         L     R1,TTRFV                GET ADDR FOR DOUBLY REF BLOCK
         MVI   3(R1),3                 SET TRAP
         LA    SP,STACK
         LA    R0,256                  FOR TTR0 = 0010
         BAL   LNK,TREESRCH            START COPY OFF AGAIN
         DC    Y(0)                    DO NOT EXPECT TO COME BACK IF
*                                      TRAP WE SET IS SPRUNG
TTRF3    NI    TTRFLG,X'FE'            CLEAR 2ND TIME INDICATOR
         BAL   R8,TTRPI                PRINT INDEX LEVELS
         B     OPTER                   FINISH UP
         SPACE
TTRPI    DS    0H                      ROUTINE PRINTS CURRENT INDEXES
*                                      UP TO THE CURRENT BLOCK
         MVI   PRLINE,C'0'             DOUBLE SPACE
         LA    R6,PRLINE+1
         LA    R10,STACK
         DROP  SP
         USING LVWKAREA,R10
TTRF1    LA    R10,LVWKLENG(,R10)      NEXT SAVE AREA
         CR    R10,SP                  DEEP ENOUGH YET?
         BC    2,TTRF2                 FINISH IF SO
         C     R6,=A(PRLINE+100)
         BC    12,TTRF15
         BAL   R14,PRNT                PRINT LINE IF LONG
         LA    R6,PRLINE+10            INDENT SECOND LINE
TTRF15   DS    0H
         L     XRINREC,LVWKREGS+4*(XRINREC-XROUTBUF) ENTRY PTR
         MVC   0(8,R6),0(XRINREC)      NAME TO LINE
         LA    R6,7(,R6)               TO STRIP BLANKS
         CLI   0(R6),C' '
         BC    7,*+8                   BR NON-BLANK
         BCT   R6,*-8                  LOOP BACK
         MVI   1(R6),C'('
         L     XRINBUF,LVWKREGS+4*(XRINBUF-XROUTBUF) BLOCK PTR
         USING CAB,XRINBUF
         L     R0,CABTTR0
         DROP  XRINBUF
         LA    R1,2(,R6)               SPOT FOR TTR
         BAL   R14,CNVH3
         MVC   8(2,R6),=C').'
         LA    R6,10(R6)
         B     TTRF1                   LOOP DOWN STACK
TTRF2    BCTR  R6,0                    TO REMOVE LAST '.'
         MVI   0(R6),C' '
         BAL   R14,PRNT
         BR    R8
         SPACE
*        HANDLE RECORD LENGTH ERROR WITHIN BLOCK
BLKERR   MVC   PRLINE(L'EM6),EM6
         BAL   R14,DUMPREC
         MVC   PRLINE(L'EM7),EM7
         MVC   PRLINE+L'EM7+1(L'EM4),EM4
         B     TTRFIN1       PRINT INDEX LEVELS
         SPACE
TTRFV    DC    A(0)
TTRFLG   DC    AL1(0)
         SPACE
EM2      DC    C'0INPUT CATALOG BLOCK TTR='
EM3      DC    C'IS DOUBLY '
EM4      DC    C'REFERENCED THROUGH INDEXES(IN TTR):'
EM5      DC    C'IS UNUSED, BUT IS'
EM6      DC    C'0STRUCTURE ERROR IN BLOCK:'
EM7      DC    C'0BLOCK'
         EJECT
*        SUBROUTINE TO PUT A BUFFER ON THE Q FOR OUTPUT
*        IT IS PUT ON IN CCHHR ORDER AND THE WRITE CHAN PROGRAM IS
*        BUILT FOR IT AT THIS TIME, EXCEPT FOR THE CC BIT AND THE
*        TIC TO THE NEXT BLOCK
         SPACE
FREEBUFO DS    0H
         INCR  SLOGW
         ST    R4,12(,R13)             SAVE REG
         USING CAB,XROUTBUF            MAKE BLOCK ADDRESSABLE
         LA    R3,CABM                 ADDR FOR MBBCCHHR
         L     R4,IOBODCB
         L     R4,44(,R4)              DEB
         L     R0,CABTTR0              TTR0 OF THIS BLOCK
         BAL   R15,CNVT2M              GET MBBCCHHR
         BC    15,OPTS                 O/P CATALOG TO SMALL ERROR
         SPACE
*        BUILD CHANNEL PROGRAM EXCEPT FINAL TIC
         SPACE
         LM    R1,R2,CCWWPAT1          1ST PART OF CPGM
         ALR   R1,XROUTBUF             RELOCATE
         STM   R1,R2,CABCCW            STORE
         LM    R15,R2,CCWWPAT2         2ND HALF CHANNEL PGM
         ALR   R15,XROUTBUF            RELOCATE
         ALR   R1,XROUTBUF             RELOCATE
         STM   R15,R2,CABWTIC1         STORE
         SPACE
*        QUEUE THE BLOCK IN CCHHR ORDER
         LA    R3,CBWQC                CHAIN BOTTOM
FBO1     L     R3,CNEXT(,R3)           GET NEXT
         CLC   CABCOUNT-CAB(5,R3),ZERO
         BC    8,FBO2                  BR IF END OF CHAIN
         CLC   CABCOUNT,CABCOUNT-CAB(R3) TEST CCHHR AGAINST THIS ONE
         BC    2,FBO1                  LOOP TILL LESS
*        INSERT IN ON CHAIN HERE
FBO2     DS    0H
         L     R2,CPREV(,R3)           PREVIOUS
         ST    R2,CABPREV
         ST    R3,CABNEXT
         ST    XROUTBUF,CNEXT(,R2)
         ST    XROUTBUF,CPREV(,R3)
         SPACE
         L     R4,12(,R13)             RESTORE
         B     EXCPO                   START WRITING SOME OUT IF POSSIB
         DROP  XROUTBUF
OPTS     L     R1,IOBODCB              EXTEND O/P CATALOG
         EOV   (1)
         MVC   PRLINE(24),=C'0OUTPUT CATALOG EXTENDED'
         BAL   R14,PRNT
         L     R3,CBVEND
         S     R3,CBVECT               SET SIZE OF VECTOR TABLE
         B     CPC1                    AND START AGAIN
         SPACE 2
*        WRITE CCW PATTERN
         SPACE
CCWWPAT1 DC    0D'0'
         CCW   SIDEQ,CABCOUNT-CAB,CC,5 SEARCH RECORD
CCWWPAT2 CCW   TIC,CABWSID-CAB,0,0     LOOP TILL RECORD FOUND
         CCW   WKD,CABKEY-CAB,CC-CC,8+256 UPDATE RECORD
         EJECT
EXCPO    DS    0H
*        SUBROUTINE TO EXCP THE BLOCKS QUEUED FOR OUTPUT
*        THE WAITING-FOR-OUTPUT CHAIN IS EXAMINED, AND ALL BLOCKS
*        ON THE SAME TRACK ARE CHAN PROGM CHAINED TOGETHER IN
*        R ORDER
         TM    ECBO,X'40'              SEE IF WRITER FREE YET
         BCR   8,R14                   RETURN IF NOT
EXCPOF   DS    0H                      FINIO ENTERS HERE
         ST    R14,12(,R13)            SAVE RETURN
         BAL   R14,WAITO               FREE BUFFER CHAINS
         L     R14,12(,R13)
         XC    IOBOCCW,IOBOCCW         ZERO
         SPACE
         USING CAB,R2
         L     R2,CBWQCN               1ST IN Q
         C     R2,CABNEXT              SEE IF ANY
         BCR   8,R14                   RETURN IF NOT
         LA    R0,CABCCW               SET ADDR
         ST    R0,IOBOCCW              IN IOB
         MVC   IOBOM(8),CABM           SET MBBCCHHR IN IOB
         SPACE
*        REMOVE THIS BLOK FROM WAITING QUEUE
         SPACE
EXO1     L     R3,CABNEXT
         L     R1,CABPREV
         ST    R3,CNEXT(,R1)
         ST    R1,CPREV(,R3)
         SPACE
         CLC   CABCOUNT(4),CABCOUNT-CAB(R3) SEE IF ANY ON SAME TRK
         BC    8,EXO4                  BR IF SO
         EXCP  IOBO                    START THE I/O
         INCR  SWEXCP                  COUNT THE EXCP'S
         BR    R14                     RETURN
*        COND CODE MUST BE NON-ZERO ON RETURN
         SPACE
*        HANG THIS ONE ON CHAN PROGM
         SPACE
         USING CAB,R3
EXO4     LA    R0,CABCCW               GET ADDRESS OF THIS
         DROP  R3
         ST    R0,CABWTIC2             POINT FROM OLD ONE
         MVI   CABWTIC2,TIC            SET TIC OP-CODE
         OI    CABWKD+4,CC             SET COMMAND CHAIN BIT
         LR    R2,R3                   GET ADDR OF NEW ONE
         B     EXO1                    REMOVE FROM Q
         SPACE
         DROP  R2
         EJECT
WAITO    DS    0H
*        SUBROUTINE WAITS FOR WRITER AND THEN RETURNS BLOCKS TO FREE Q
         SPACE
         LT    R2,IOBOCCW              GET CHAN PGM
         BCR   8,R14                   RETURN IF NONE
         TM    ECBO,X'40'
         BC    1,WW0
         WAIT  ECB=ECBO                WAIT FOR I/O TO FINISH
         INCR  SWWAIT
WW0      DS    0H
         LA    R1,IOBO
         BAL   R3,CLI7F                CHECK I/O COMPLETION
         L     R2,IOBOCCW              RESTORE R2
WW1      DS    0H
         S     R2,=A(CABCCW-CAB)       BACK TO CAB ADDRESS
         LA    R2,0(,R2)               REMOVE TOP BYTE
         USING CAB,R2                  ADDRESS CAB
         LA    R1,CBFRC                HEAD OF FREE CHAIN
         L     R3,CNEXT(,R1)           1ST CAB ON FREE Q
         ST    R1,CABPREV
         ST    R3,CABNEXT
         ST    R2,CNEXT(,R1)
         ST    R2,CPREV(,R3)
         TM    CABWKD+4,CC             SEE IF ANOTHER
         L     R2,CABWTIC2             ADDR OF NEXT
         BC    1,WW1                   FREE IT TOO
         SR    R2,R2
         ST    R2,IOBOCCW              INDICATE BLOCKS FREED
         BR    R14
         DROP  R2
         EJECT
FINIO    DS    0H
*        SUBROUTINE TO WIND UP ALL I/O AND CLOSE DATA SETS
         LR    R7,R14                  SAVE RETURN
FIO1     DS    0H
         BAL   R14,EXCPOF              OUTPUT FROM THE WAITING Q
         BC    7,FIO1                  LOOP TILL NONE LEFT ON Q
         SPACE
FIO2     DS    0H
         WAIT  ECB=ECBO                ENSURE THAT
         WAIT  ECB=ECBI                ALL I/O IS FINISHED
         BR    R7
         SPACE
FREEMAIN FREEMAIN MF=(E,GETML)
         SPACE
         BR    R14                     RETURN
         SPACE 2
CLI7F    L     R2,4(,R1)               ECB ADDR
         CLI   0(R2),X'7F'             SEE IF COMPLETE OK
         BCR   8,R3                    BR RETURN TO USER IF SO
         MVC   PRLINE(31),=C'0  I/O ERROR IN XXXXXX CATALOG:'
         MVC   PRLINE+16(6),40(R1)     GET 'INPUT ' OR 'OUTPUT'
         BALR  R15,0                   SET ADDRESSABILITY
         USING *,R15
         SYNADAF ACSMETH=EXCP
         MVC   PRLINE+32(78),50(R1)    GET MESSAGE
         SYNADRLS
         DROP  R15
ERRET    DS    0H
         BAL   R14,PRNT
         SPACE
*        NOW EXIT FROM CPYCTL W/OUT RETURNING TO CLI7F CALLER
         BAL   R7,FIO2                 WAIT FOR I/O, FREEMAIN
         L     R13,4(,R13)
         LM    R14,R12,12(R13)
         MVI   12(R13),255
         LA    R15,16
         BR    R14
         SPACE 2
PRNT     ST    R14,PRNTS
         PUT   SYSPRINT,PRLINE
         MVC   PRLINE,PRLINE-1
         L     R14,PRNTS
         BR    R14
PRNTS    DC    A(0)
         SPACE
OPTER    DS    0H
         MVC   PRLINE(21),=C'0OPERATION TERMINATED'
         B     ERRET
         SPACE
CNVH3    SRL   R0,8                    TTR TO RIGHT OF REG
         LA    R15,6                   COUNTER FOR HEX DIGITS
         BCTR  R1,0
CN1      STC   R0,0(R15,R1)            STORE DIGIT
         SRL   R0,4                    GET NEXT DIGIT
         BCT   R15,CN1                 LOOP
         NC    1(6,R1),=16X'F'          REMOVE JUNK
         TR    1(6,R1),=C'0123456789ABCDEF' TR TO HEX
         LA    R1,7(,R1)
         BR    R14                     RETURN
         EJECT
*        VARIABLES, IOB'S ETC
ASYSPRNT DC    A(0)                    ADDR OF OPENED SYSPRINT DCB
PURGED   DC    A(0)
BLKPTRKI DC    A(0)                    BLOCKS PER TRACK, INPUT CATLG
BLKPTRKO DC    A(0)                    BLOCKS PER TRACK, OUTPUT CATLG
         SPACE 2
*        IOB FOR INPUT CATALOG
IOBI     DC    0A(0),X'42000000',A(ECBI)
IOBICSW  DC    A(0,0)
IOBICCW  DC    A(CCWI)
IOBIDCB  DC    A(0,0,0)
IOBIM    DC    A(0,0)                  MBBCCHHR
         DC    CL6'INPUT'
         SPACE
*        IOB FOR OUTPUT CATALOG
IOBO     DC    0A(0),X'42000000',A(ECBO)
IOBOCSW  DC    A(0,0)
IOBOCCW  DC    A(CCWO)
IOBODCB  DC    A(0,0,0)
IOBOM    DC    A(0,0)                  MBBCCHHR
         DC    CL6'OUTPUT'
         SPACE
ECBI     DC    A(0)
ECBO     DC    A(0)
         SPACE
CCWO     CCW   SIDEQ,IOBOM+3,CC,5
         CCW   TIC,*-8,0,0
CCWOTIC  CCW   TIC,*-*,0,0
TTO      DC    A(0)
TRKO     DC    A(0)
GETML    GETMAIN VU,LA=GMMIN,A=GMAREA,MF=L
GMAREA   DC    A(0)                    AREA GOT BY GETMAIN
GMLEN    DC    A(0)                    LENGTH GOT BY GETMAIN
GMMIN    DC    A(0)                    MIN AREA TO BE GOT
GMMAX    DC    A(0)                    MAX AREA TO BE GOT
         SPACE
CCWI     CCW   SIDEQ,IOBIM+3,CC,5      SEARCH, INPUT CATALG
         CCW   TIC,*-8,0,0
CCWITIC  CCW   TIC,*-*,0,0
         SPACE 2
         DC    C' '                    FOR BLANKING PRLINE
PRLINE   DC    CL121' '                PRINT LINE FOR SYSPRINT MESSAGES
         EJECT
*        WORK AREA STRUCTURE
         DC    0A(0)
CBRPC    EQU   *-CABNEXT+CAB           FAKE STARTS READ AND PURGABLE
CBRPCN   DC    A(CBRPC)                NEXT
CBRPCP   DC    A(CBRPC)                PREVIOUS
CBFRC    EQU   *-CABNEXT+CAB           FAKE STARTS FREE CHAIN
CBFRCN   DC    A(CBFRC)                NEXT
CBFRCP   DC    A(CBFRC)                PREVIOUS
CBWQC    EQU   *-CNEXT                 FAKE STARTS QUEUED FOR WRITE
CBWQCN   DC    A(CBWQC)                NEXT
CBWQCP   DC    A(CBWQC)                PREVIOUS
         DC    XL8'FFFFFFFFFFFFFFFF'   DUMMY MBBCCHHR
ZERO     DC    XL8'0'
CABGP    DC    A(0)                    GET-POINTER. GETBUFI HANGS NEW
*                                      BUFFERS ON HERE
CBVECT   DC    A(0)                    START OF LOOKUP TABLE
CBVEND   DC    A(0)                    END ON LOOKUP TABLE
CCWRPATT CCW   RC+MT,*-*,CC+SLI,5
         CCW   RKD,*-*,CC-CC,8+256
         SPACE
*        PERFORMANCE RECORDERS
SLOGR    DC    A(0)
SREXCP   DC    A(0)
SBINC    DC    A(0)
SPURGED  DC    A(0)
SLOGW    DC    A(0)
SWEXCP   DC    A(0)
SWWAIT   DC    A(0)
         LTORG
         DC    0A(0)                   ALIGN STACK
STACK    STACK 22                      22 LEVEL STACK
         EJECT
*        CCW OP-CODES AND FLAG BYTE SYMBOLICS
         SPACE
CC       EQU   X'40'                   CHAIN COMMAND
CD       EQU   X'80'                   CHAIN DATA
SKIP     EQU   X'10'                   SUPPRESS DATA TRANSFER
PCI      EQU   X'08'                   PCI INTERRUPT
SLI      EQU   X'20'                   SUPPRESS LENGTH IND
         SPACE
MT       EQU   X'80'                   MULTIPLE TRACK
SIDEQ    EQU   X'31'                   SEARCH COUNT EUQAL
SKEQ     EQU   X'29'                   SEARCH KEY EQUAL
RD       EQU   X'06'                   READ DATA
WCKD     EQU   X'1D'                   WRITE COUNT, KEY, DATA
WKD      EQU   X'0D'                   WRITE KEY, DATA
RKD      EQU   X'0E'                   READ KEY, DATA
RC       EQU   X'12'                   READ COUNT
TIC      EQU   X'08'                   TRANSFER IN CHANNEL
         END
// END OF CPYCTL
//*
//*
// START OF SAMPLXIT
         TITLE ' AECATLG - DSPEMON EXIT ROUTINE - OUTPUTS DSNAMES'
DSPEMON  CSECT
         STM   R14,R12,12(R13)
         LR    R12,R15
         USING DSPEMON,R12
         LA    R15,DSPESAVE
         ST    R15,8(,R13)
         ST    R13,4(,R15)
         LR    R13,R15
         SPACE
         DS    0H                      ROUTINE PRINTS CURRENT INDEXES
*                                      UP TO THE CURRENT BLOCK
         LA    R6,DSNAME
         LR    R10,R0                  STACK
         LR    R3,XRINREC
         USING LVWKAREA,R10
TTRF1    LA    R10,LVWKLENG(,R10)      NEXT SAVE AREA
         CR    R10,SP                  DEEP ENOUGH YET?
         BC    2,TTRF2                 FINISH IF SO
         L     XRINREC,LVWKREGS+4*(XRINREC-XROUTBUF) ENTRY PTR
         MVC   0(8,R6),0(XRINREC)      NAME TO LINE
         LA    R6,7(,R6)               TO STRIP BLANKS
         CLI   0(R6),C' '
         BC    7,*+8                   BR NON-BLANK
         BCT   R6,*-8                  LOOP BACK
         MVI   1(R6),C'.'
         LA    R6,2(R6)
         B     TTRF1                   LOOP DOWN STACK
TTRF2    MVC   0(8,R6),0(R3)           LAST LEVEL NAME TO LINE
         MVC   VOL,18(R3)
         BAL   R14,PRNT
         SPACE
*        FINISH OFF NOW
         L     R13,4(,R13)
         LM    R14,R12,12(R13)
         BR    R14
         EJECT
PRNT     BC    0,PRNT1
         BCR   0,R14
         OPEN  (DS,OUTPUT)
         TM    DS+48,16
         BC    1,PRNT2
         CLOSE DS
         OI    PRNT+7,X'F0'
         B     PRNT
PRNT2    OI    PRNT+1,X'F0'
PRNT1    LR    R2,R14        RETURN ADDR
         PUT   DS,VOL
         MVC   DSNAME,=CL44' '
         BR    R2
         SPACE
VOL      DC    CL6' ',C' ' >   ORDER IMPORTANT
DSNAME   DC    CL44' '     >
DSPESAVE DC    18A(0)
         PRINT NOGEN
         SPACE
DS       DCB   DDNAME=DSNAMES,MACRF=(PM),DSORG=PS,BLKSIZE=5100, XXXXXXXX
               LRECL=51,RECFM=FB
         LTORG
         TITLE 'AECATLG - DSECTS'
LVWKAREA DSECT
INDEXNO  DC    F'0'
LVWKREGS DS    5F                      REGS 6 THRU 10 SAVE
OLDGLBL  DC    F'0'                    INDEX LEVEL START TTR0
*              SEE 'STATS' DSECT FOR DESCRIPTION OF THESE FIELDS
*              DATA FOR LEVEL OF OLD CATALOG
O#INDEXS DC    F'0'
O#BLOCKS DC    F'0'
O#BLKWK  DC    F'0'
OMAXBLKS DC    F'0'
OCTGLNK  DC    F'0'
OBRKLNK  DC    F'0'
*              DATA FOR LEVEL OF NEW CATALOG
N#INDEXS DC    F'0'
N#BLOCKS DC    F'0'
N#BLKWK  DC    F'0'
NMAXBLKS DC    F'0'
NCTGLNK  DC    F'0'
NBRKLNK  DC    F'0'
LVWKEND  EQU   *
LVWKLENG EQU   *-LVWKAREA
         SPACE 3
R15      EQU   15
R14      EQU   14
R13      EQU   13                      SAVE AREA, CONSTS, WORK
R12      EQU   12                      BASE REG
SP       EQU   11                      STACK POINTER
*              REGS 10 THRU 6 SAVED ON STACK
LNK      EQU   10                      LINK REG
XRINREC  EQU   9                       POINTER TO INPUT RECORD
XROUTREC EQU   8                       POINTER TO OUTPUT RECORD
XRINBUF  EQU   7                       INPUT TTR0 BLOCK POINTER
XROUTBUF EQU   6                       OUTPUT TTR3 BLOCK POINTER
WK5      EQU   5                       SEMI VOLATILE - NOT SAVED ON STA
WK4      EQU   4                       SEMI VOLATILE - NOT SAVED ON ST
WK3      EQU   3                       VOLATILE - NOT SAVED ON SUBR C
WK2      EQU   2
R1       EQU   1
R0       EQU   0
R9       EQU   9
R10      EQU   10
         SPACE 3
REC      DSECT
ENAME    DC    CL8' '
ETTR     DC    XL3'00'
ETYPE    DC    XL1'00'
EDATA    DS    0C
R2       EQU   2
R3       EQU   3
R4       EQU   4
R5       EQU   5
R6       EQU   6
R7       EQU   7
R8       EQU   8
R11      EQU   11
         END
