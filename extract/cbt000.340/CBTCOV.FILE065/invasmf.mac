 INVASMF: PROC OPTIONS(MAIN); /* INVOKE FORGROUND ASM XF  MH */
  /* ************************************************************** */
  /*                                                                */
  /*                                                                */
  /*    A TSO FOREGROUND ASSEMBLER XF PROMPTER UNDER ISPF.          */
  /*                                                                */
  /*    (WRITTEN IN A HIGH LEVEL LANGUAGE FOLKS: (WELL MOSTLY)      */
  /*                                                                */
  /*    THE ASSEMBLER SUBROUTINES ARE ALL INCLUDED WITH THIS CODE.  */
  /*                                                                */
  /*    THEY ARE 1) A DYNAMIC ALLOCATION INTERFACE - VERY EASY TO   */
  /*                                                 USE SEE CODE   */
  /*             2) CATALOG MANAGEMENT FOR DATASET LOCATE.          */
  /*             3) TSO COMMAND HANDLER SO WE CAN ISSUE TSO COMMANDS*/
  /*                SUCH AS FREE AND PRINTOFF WITHOUT HAVING TO     */
  /*                GO THROUGH ALL THAT TSO COMMAND PROCESSOR       */
  /*                INITIALISATION GARBAGE : PPL CPPL ECT ETC ETC.  */
  /*                                                                */
  /*             4) PDS MEMBER FINDER : RETURNS INFORMATION AS      */
  /*                TO WHETHER A MEMBER IS IN A PDS OR NOT.         */
  /*                                                                */
  /*  WISH LIST : THE USER DATASETS DO NOT HAVE TO BE CATALOGUED.   */
  /*              I CAN ADD VOLUME INFORMATION LATER. MAYBE         */
  /*              RELEASE 2 OF THIS (IF I EVER GET ROUND TO IT)     */
  /*              WILL ADD THIS FUNCTION.                           */
  /*                                                                */
  /*                                                                */
  /*  COMMENTS SUGGESTIONS IMPROVEMENTS AND ERROR INFORMATION       */
  /*  GREATLY APPRECIATED. ADDRESS BELOW.                           */
  /*                                                                */
  /*                                                                */
  /*   THIS PROGRAM IS ALMOST A CLONE OF INVPLI WHICH               */
  /*   INTERACTIVELY PERFORMS PLI PROCESSING. THE SAME              */
  /*   METHODOLOGY IS USED AND THE SAMF ASSEMBLER LANGUAGE          */
  /*   SUBPROGRAMS ARE CALLED.                                      */
  /*                                                                */
  /*                                                                */
  /*                                                                */
  /*    MIKE HAWTHORNE  TTI CITICORP                                */
  /*                    3100 OCEAN PK BLVD                          */
  /*                    SANTA MONICA CA 90405                       */
  /*                                                                */
  /*    (213) 450-9111 X2353                                        */
  /*                                                                */
  /*                                                                */
  /*                                                                */
  /* THIS PROGRAM DISPLAYS A PANEL TO OBTAIN USER SOURCE AND LOAD   */
  /* LIBRARIES AND THE USER-ID. DATASETS REQUIRED BY THE ASMH       */
  /* ASSEMBLER ARE DYNAMICALLY ALLOCATED WITH THE DYNAM INTERFACE   */
  /* (EXISTING DATASETS ARE DELETED USING THE CATMAN CATALOG        */
  /* INTERFACE) AND THE ASSEMBLER XF PROGRAM IS INVOKED DYNAMICALLY */
  /*                                                                */
  /* IF THE RETURN CODE IS 4 OR LESS THE LINK EDITOR IS INVOKED     */
  /* LOADING THE MODULE TO THE LOAD LIBRARY SELECTED OTHERWISE      */
  /* AN ERROR DATASET IS DYNAMICALLY ALLOCATED AND THE LIST         */
  /* DATASET READ AND THE ERRORS COPIED TO THE ERROR DATASET.       */
  /* ISPF BROWSE OF THE ERROR DATASET IS THEN INVOKED.              */
  /*                                                                */
  /* NOTE : IF NO LOAD TARGET LIBRARY IS SPECIFIED THEN THE         */
  /*        LINK STEP IS NOT DONE.                                  */
  /*                                                                */
  /*                                                                */
  /* IF THE USER HAS SELECTED THE PRINT OPTION THE LIST DATASET     */
  /* IS PRINTED BY ISSUING THE PRINTOFF TSO COMMAND.                */
  /*                                                                */
  /* NOTE : USING PANELS AND ISPF SERVICES IS MUCH EASIER THAN      */
  /*        WRITING A TSO COMMAND PROCESSOR TO DO THIS JOB.         */
  /*        NOBODY HAS TSO THESE DAYS WITHOUT ALSO HAVING ISPF.     */
  /*        PARSING COMMANDS IS MUCH SIMPLER IN PL/I AND MOST       */
  /*        OF THE CODE CAN BE WRITTEN IN A HIGH LEVEL LANGUAGE.    */
  /*                                                                */
  /*                                                                */
  /* ************************************************************** */
  /*                                                                */
  /* DEFINE EXTERNAL REFERENCES : DYNAMIC ALLOCATION INTERFACE      */
  /*                            : CATALOG MANAGEMENT                */
  /*                            : PDS MEMBER FINDER                 */
  /*                            : TSO COMMAND PROCESSOR.            */
  /*                            : ISPF SERVICES                     */
  /*                            : IFOX00 ASSEMBLER XF (THE STD ONE) */
  /*                            : LINKAGE EDITOR                    */
  /*                                                                */
  /*  (NOTE TO ALL ASSEMBLER BIGOTS OUT THERE: YES YOU CAN CALL     */
  /*   ASM AND LINK EDIT FROM A HIGH LEVEL LANGUAGE SO LONG AS      */
  /*   YOU PASS THE RIGHT PARAMETERS AND GET THE ENTRY POINTS       */
  /*   CORRECT).                                                    */
  /*                                                                */
  /* ************************************************************** */
 DCL ISPLINK          ENTRY EXTERNAL OPTIONS(ASM,INTER,RETCODE);
 DCL (CATMAN, DYNAM)  ENTRY EXTERNAL OPTIONS(ASM,INTER,RETCODE);
 DCL INVTSO           ENTRY EXTERNAL OPTIONS(ASM,INTER,RETCODE);
 DCL INVFIND          ENTRY EXTERNAL OPTIONS(ASM,INTER,RETCODE);
 DCL IFOX00           ENTRY EXTERNAL OPTIONS(ASM,INTER,RETCODE);
 DCL HEWL             ENTRY EXTERNAL OPTIONS(ASM,INTER,RETCODE);
  /*                                                                */
  /* ************************************************************** */
  /*                                                                */
  /* DEFINE PLI BUILTIN FUNCTIONS/SERVICES.                         */
  /*                                                                */
  /* ************************************************************** */
 DCL (PLIRETV, LENGTH, SUBSTR, INDEX, ADDRESS, ADDR) BUILTIN;
  /* ************************************************************** */
  /*                                                                */
  /* DEFINE NON ISPF VARIABLES .                                    */
  /*                                                                */
  /* ************************************************************** */
 DCL CONS             CHAR(80) INIT(' '),
     BLANK            CHAR(8) INIT(' '),
     Q                PTR,
     I                FIXED BIN(15) INIT(0),
     J                FIXED BIN(15) INIT(0),
     K                FIXED BIN(15) INIT(0),
     MEMBER           CHAR(8) INIT(' '),
     MEML             FIXED BIN(15) INIT(0),
     LEN_USERID       FIXED BIN(15) INIT(0),
     LEN_ERR          FIXED BIN(15) INIT(0),
     SAVERC           FIXED BIN(15) INIT(0),
     L_SOURCE         FIXED BIN(15) INIT(0),
     L_COPY1          FIXED BIN(15) INIT(0),
     L_COPY2          FIXED BIN(15) INIT(0),
     L_COPY3          FIXED BIN(15) INIT(0),
     L_LOAD           FIXED BIN(15) INIT(0),
     L_LOAD1          FIXED BIN(15) INIT(0),
     L_LNAME          FIXED BIN(15) INIT(0),
     L_LDT            FIXED BIN(15) INIT(0),
     WORK             FIXED BIN(31) INIT(0),
     TESTDSN          CHAR(54) INIT(' '),
     BROWSE_DSN       CHAR(44) INIT(' '),
     MSGFILE          FILE STREAM OUTPUT ENV(FB),
     FLAG             CHAR(1) INIT(' '),
     ERR_FLAG         CHAR(1) INIT('N'),
     MSGID            CHAR(8) INIT(' '),
     QUOTE            CHAR(1) INIT(''''), /* THIS IS A SINGLE QUOTE !*/
     LINK             CHAR(1) INIT(' '),
  /* ************************************************************** */
  /*                                                                */
  /* SET UP OPTIONS LIST AND ALTERNATE DDNAMES FOR BOTH THE         */
  /* ASSEMBLER XF PROGRAM AND THE LINKAGE EDITOR.                   */
  /*                                                                */
  /* ************************************************************** */
  1 FORASM            UNALIGNED,
    3  OPTLEN         FIXED BIN(15),
    3  OPTDATA        CHAR(100),
  1 ASMDDN            ALIGNED,
    3  DDNLEN         FIXED BIN(15) INIT(96),
    3  P1P2P3         CHAR(24) INIT(' '),
    3  P4             CHAR(8) INIT('ASMMAC'),
    3  P5             CHAR(8) INIT('ASMIN'),
    3  P6             CHAR(8) INIT('ASMPRNT'),
    3  P7             CHAR(8) INIT('ASMPNCH'),
    3  P8             CHAR(8) INIT('ASMUT1'),
    3  P9             CHAR(8) INIT('ASMUT2'),
    3  P10            CHAR(8) INIT('ASMUT3'),
    3  P11            CHAR(8) INIT('ASMGO'),
    3  P12            CHAR(8) INIT('ASMTERM'),
  1 FORLNK            UNALIGNED,
    3  LNKLEN         FIXED BIN(15),
    3  LNKDATA        CHAR(100),
  1 LNKDDN            ALIGNED,
    3  DDNLEN1        FIXED BIN(15) INIT(64),
    3  L1             CHAR(8) INIT('LNKLIN'),  /* SYSLIN           */
    3  L2             CHAR(8) INIT(' '),       /* OUTPUT LMOD NAME */
    3  L3             CHAR(8) INIT('LNKMOD'),  /* SYSLMOD          */
    3  L4             CHAR(8) INIT('LNKLIB'),  /* SYSLIB           */
    3  L5             CHAR(8) INIT(' '),       /* NOTHING          */
    3  L6             CHAR(8) INIT('LNKPRNT'), /* SYSPRINT         */
    3  L7             CHAR(8) INIT('  '),      /* NOTHING          */
    3  L8             CHAR(8) INIT('LNKUT1'),  /* SYSUT1           */
  /* ************************************************************** */
  /*                                                                */
  /* SET UP PARAMETER LIST FOR CATALOG MANAGEMENT INTERFACE         */
  /*                                                                */
  /* ************************************************************** */
  PARMS1              CHAR(169) BASED(Q),
  1  WORK1            UNALIGNED,
    3 FUNC            CHAR(1) INIT('P'),
    3 DSNAME          CHAR(44) INIT(' '),
    3 VOLCOUNT        FIXED BIN(31) INIT(0),
    3 VOLLIST(20)     CHAR(6),
  /* ************************************************************** */
  /*                                                                */
  /* SET UP PARAMETER LIST FOR MEMBER FINDER MODULE                 */
  /*                                                                */
  /* ************************************************************** */
  1 FORMEM            UNALIGNED,
    3  MPARML         FIXED BIN(15) INIT(8),
    3  LIBNAME        CHAR(9) INIT(' '),
  /* ************************************************************** */
  /*                                                                */
  /* SET UP PARAMETER LIST FOR TSO COMMAND PROCESSING.              */
  /*                                                                */
  /* ************************************************************** */
  TSOLEN              FIXED BIN(31) INIT(0),
  TSOCMD              CHAR(255) INIT(' '),
  /* ************************************************************** */
  /*                                                                */
  /* DEFINE ISPF VARIABLES WE ARE GOING TO USE IN THE PROGRAM.      */
  /*                                                                */
  /* ************************************************************** */
     PRTOPT           CHAR(3) INIT(' '),
     OPT              CHAR(98) INIT(' '),
     LDT              CHAR(98) INIT(' '),
     SOURCE           CHAR(54)  INIT(' '),
     LOAD             CHAR(44) INIT(' '),
     COPY1            CHAR(44) INIT(' '),
     COPY2            CHAR(44) INIT(' '),
     COPY3            CHAR(44) INIT(' '),
     LOAD1            CHAR(44) INIT(' '),
     LNAME            CHAR(8) INIT(' '),
     ZUSER            CHAR(7)  INIT('ZUSER'),
     USERID           CHAR(8)  INIT(' '),
     LLDT             FIXED BIN(31) INIT(LENGTH(LDT));
 DCL LLNAME           FIXED BIN(31) INIT(LENGTH(LNAME));
 DCL LSOURCE          FIXED BIN(31) INIT(LENGTH(SOURCE)),
     LLOAD            FIXED BIN(31) INIT(LENGTH(LOAD)),
     LCOPY1           FIXED BIN(31) INIT(LENGTH(COPY1)),
     LCOPY2           FIXED BIN(31) INIT(LENGTH(COPY2)),
     LCOPY3           FIXED BIN(31) INIT(LENGTH(COPY3)),
     LLOAD1           FIXED BIN(31) INIT(LENGTH(LOAD1)),
     LZUSER           FIXED BIN(31) INIT(LENGTH(ZUSER)),
     LOPT             FIXED BIN(31) INIT(LENGTH(OPT)),
     LPRTOPT          FIXED BIN(31) INIT(LENGTH(PRTOPT));
  /* ************************************************************** */
  /*                                                                */
  /* SET UP THE INITIAL PROGRAM ENVIRONMENT :                       */
  /*                                                                */
  /*        A) SET UP ADDRESSABILITY OF BASED VARIABLES             */
  /*        B) INITIALIZE THE DYNAMIC ALLOCATION INTERFACE          */
  /*                                                                */
  /* ************************************************************** */
 Q = ADDR(WORK1);
 FETCH DYNAM;
 FETCH CATMAN;
 FETCH INVTSO;
 CALL DYNAM(WORK, 'INIT ');
 CALL DYNAM(WORK,'ALLOC ','DD=MSGFILE;','TE;');
 OPEN FILE(MSGFILE) LINESIZE(80);
  /* ************************************************************** */
  /*                                                                */
  /* SET UP THE ISPF ENVIRONMENT:                                   */
  /*                                                                */
  /*        A) DEFINE OUR PROGRAMS VARIABLES TO ISPF SO WE          */
  /*           CAN GET DATA FROM A PANEL.                           */
  /*        B) GET THE TSO USER-ID FROM ISPF. THIS IS THE SYSTEM    */
  /*           VARIABLE ZUSER FROM ISPF OBTAINED VIA VCOPY FUNCTION */
  /*        C) SHOW THE USER THE PANEL                              */
  /*        D) GET DATA BACK FROM THE PANEL                         */
  /*                                                                */
  /*       (IF PLIRETV = 8 THEN PFK3 OR END KEY HAS BEEN PRESSED)   */
  /*        IF THIS HAS HAPPENED WE EXIT WITHOUT MORE ADO.          */
  /*                                                                */
  /* ************************************************************** */
 CALL ISPLINK('VDEFINE', '(PRTOPT)', PRTOPT, 'CHAR', LPRTOPT);
 CALL ISPLINK('VDEFINE', '(LNAME)', LNAME, 'CHAR', LLNAME);
 CALL ISPLINK('VDEFINE', '(OPT)', OPT, 'CHAR', LOPT);
 CALL ISPLINK('VDEFINE', '(LDT)', LDT, 'CHAR', LLDT);
 CALL ISPLINK('VDEFINE', '(SOURCE)', SOURCE, 'CHAR', LSOURCE);
 CALL ISPLINK('VDEFINE', '(COPY1)', COPY1, 'CHAR', LCOPY1);
 CALL ISPLINK('VDEFINE', '(COPY2)', COPY2, 'CHAR', LCOPY2);
 CALL ISPLINK('VDEFINE', '(COPY3)', COPY3, 'CHAR', LCOPY3);
 CALL ISPLINK('VDEFINE', '(LOAD1)', LOAD1, 'CHAR', LLOAD1);
 CALL ISPLINK('VDEFINE', '(LOAD)', LOAD, 'CHAR', LLOAD);
 CALL ISPLINK('VCOPY', ZUSER, LZUSER, USERID, 'MOVE');
 CALL ISPLINK('DISPLAY', 'ASMXF   ', 'INV012  ');
 LEN_USERID = INDEX(USERID,' ');
 IF LEN_USERID ^= 0
 THEN LEN_USERID = LEN_USERID - 1;
 REDOO: IF PLIRETV = 8 /* COME BACK HERE ON ANY ERROR     */
 THEN GO TO EXIT1;        /* EXIT WITHOUT DOING ANY PROCESSING*/
 TSOLEN = 1;
  /* ************************************************************** */
  /*                                                                */
  /*   PARSE THE DATA FROM THE USER.                                */
  /*                                                                */
  /*        A) GET SOURCE DATASET AND CHECK FOR VALIDITY.           */
  /*           IF THE DATASET IS UNQUOTED APPEND THE TSO USER-ID.   */
  /*           IF MISSING QUOTE THEN ISSUE ERROR MESSAGE AND EXIT.  */
  /*           IF UNCATALOGUED THEN ISSUE A MESSAGE.                */
  /*        B) IF NO MACRO LIBRARIES THEN ISSUE ERROR MESSAGE       */
  /*           OTHERWISE CHECK FOR VALIDITY OF DATASETS AND IF      */
  /*           NECESSARY CONCATENATE THEM.                          */
  /*        C) IF NO LOAD LIBRARY SPECIFIED THEN SET A FLAG WHICH   */
  /*           INDICATES LINK STEP NOT TO BE DONE                   */
  /*        D) CHECK FOR ADDITIONAL LOAD LIBRARIES (MAX 1) TO       */
  /*           USE IN THE AUTOLINK SEARCH FOR LINK EDIT INCLUDES.   */
  /*        E) IF ALL THE ABOVE TESTS PASS SET UP OPTIONS FOR       */
  /*           PASSING TO THE COMPILER. THE NEXT SECTION WILL       */
  /*           ALLOCATE DATASETS NEEDED FOR COMPILE.                */
  /*                                                                */
  /*                                                                */
  /* ************************************************************** */
  DSNAME = ' ';
 IF SUBSTR(SOURCE,1,1) = ' '          /* MISSING SOURCE DATASET     */
 THEN DO;
         CALL ISPLINK('DISPLAY', BLANK, 'INV001  ', 'SOURCE ');
         GO TO REDOO;
      END;
 TESTDSN = SOURCE;
 CALL PARSE;
 IF ERR_FLAG = 'Y'
 THEN DO;
         ERR_FLAG = 'N';
         CALL ISPLINK('DISPLAY', BLANK,  MSGID, 'SOURCE ');
         GO TO REDOO;
      END;
 SOURCE = DSNAME;                    /* GET CORRECT DSN FOR ALLOCATE*/
 IF SUBSTR(COPY1,1,1) ^= ' '
 THEN DO;
          TESTDSN = COPY1;
          CALL PARSE;
          IF ERR_FLAG = 'Y'    /* PARSE ERROR            */
          THEN DO;
                  ERR_FLAG = 'N';
                  CALL ISPLINK('DISPLAY', BLANK,
                               MSGID, 'COPY1  ');
                  GO TO REDOO;
               END;
          COPY1 = DSNAME;
          L_COPY1 = INDEX(COPY1,' ') - 1;
       END;
  IF SUBSTR(COPY2,1,1) = ' '
  THEN DO;
          IF SUBSTR(COPY1,1,1) = ' '
          THEN DO;
                  IF SUBSTR(COPY3,1,1) = ' '
                  THEN DO;
                         CALL ISPLINK('DISPLAY', BLANK,
                         'INV005  ' ,'COPY1   ');
                         GO TO REDOO;
                       END;
                END;
       END;
  ELSE DO;
          TESTDSN = COPY2;
          CALL PARSE;
          IF ERR_FLAG = 'Y'
          THEN DO;
                  ERR_FLAG = 'N';
                  CALL ISPLINK('DISPLAY', BLANK,
                               MSGID, 'COPY2   ');
                  GO TO REDOO;
               END;
          COPY2 = DSNAME;
          L_COPY2 = INDEX(COPY2,' ') - 1;
       END;
  IF SUBSTR(COPY3,1,1) ^= ' '
  THEN DO;
          TESTDSN = COPY3;
          CALL PARSE;
          IF ERR_FLAG = 'Y'
          THEN DO;
                  ERR_FLAG = 'N';
                  CALL ISPLINK('DISPLAY', BLANK,
                  MSGID, 'COPY3   ');
                  GO TO REDOO;
               END;
          COPY3 = DSNAME;
          L_COPY3 = INDEX(COPY3,' ') - 1;
       END;
  IF SUBSTR(LOAD,1,1) = ' '
  THEN LINK = 'N';
  ELSE DO;
          LINK = 'Y';
          TESTDSN = LOAD;
          CALL PARSE;
          IF ERR_FLAG = 'Y'    /* PARSE ERROR            */
          THEN DO;
                  ERR_FLAG = 'N';
                  CALL ISPLINK('DISPLAY', BLANK,
                               'INV002  ', 'LOAD   ');
                  GO TO REDOO;
               END;
          LOAD = DSNAME;
          L_LOAD = INDEX(LOAD,' ') - 1;
          IF SUBSTR(LNAME,1,1) = ' '  /* NO NAME FOR LOAD MODULE*/
          THEN DO;
                  CALL ISPLINK('DISPLAY', BLANK,
                                       'INV003  ', 'LNAME  ');
                  GO TO REDOO;
               END;
          ELSE L2 = LNAME;
       END;
 IF SUBSTR(LOAD1,1,1) ^= ' '
 THEN DO;
         IF LINK = 'Y'
         THEN DO;
                 TESTDSN = LOAD1;
                 CALL PARSE;
                 IF ERR_FLAG = 'Y'    /* PARSE ERROR            */
                  THEN DO;
                          ERR_FLAG = 'N';
                          CALL ISPLINK('DISPLAY', BLANK,
                                       MSGID, 'LOAD1  ');
                          GO TO REDOO;
                       END;
                 LOAD1 = DSNAME;
                 L_LOAD1 = INDEX(LOAD1,' ') - 1;
              END;
      END;
 CONS= 'ASSEMBLER XF PROMPTER  V1.0  MIKE HAWTHORNE AUG 1985';
 CALL WRITEIT;
 OPTLEN = INDEX(OPT,' ');
 OPTLEN = OPTLEN - 1;
 OPTDATA = SUBSTR(OPT,1,OPTLEN);
  /* ************************************************************** */
  /*                                                                */
  /*   WE USE THE TERM ASSEMBLER OPTION TO WRITE THE DIAGNOSTICS    */
  /*   OUT TO THE ERRMSG DATASET.                                   */
  /*   DELETE DATASETS USERID.ASM.LIST USERID.ASM.ERRMSG AND        */
  /*   USERID.ASM.OBJ.                                              */
  /*   ALLOCATE DATASETS NEEDED BY THE ASSEMBLER PROGRAM PRODUCT    */
  /*   AND CALL IT .                                                */
  /*   AT END OF COMPILATION DELETE THE SYSUT DATASETS AND          */
  /*   ISSUE A MESSAGE INDICATING THE RETURN CODE.                  */
  /*                                                                */
  /* ************************************************************** */
 FUNC = 'P';                    /* SET FOR PURGE OF DATASETS */
 DSNAME=SUBSTR(USERID,1,LEN_USERID) ×× '.ASM.LIST';
 CALL CATMAN(PARMS1);           /* IGNORE RET CODE IF NOT 0  */
 FUNC = 'P';                    /* SET FOR PURGE OF DATASETS */
 DSNAME=SUBSTR(USERID,1,LEN_USERID) ×× '.ASM.OBJ';
 CALL CATMAN(PARMS1);           /* IGNORE RET CODE IF NOT 0  */
 FUNC = 'P';                    /* SET FOR PURGE OF DATASETS */
 DSNAME=SUBSTR(USERID,1,LEN_USERID) ×× '.ASM.ERRMSG';
 CALL CATMAN(PARMS1);           /* IGNORE RET CODE IF NOT 0  */
 FUNC = 'P';                    /* SET FOR PURGE OF DATASETS */
 DSNAME=SUBSTR(USERID,1,LEN_USERID) ×× '.ASM.UT1';
 CALL CATMAN(PARMS1);           /* IGNORE RET CODE IF NOT 0  */
 FUNC = 'P';                    /* SET FOR PURGE OF DATASETS */
 DSNAME=SUBSTR(USERID,1,LEN_USERID) ×× '.ASM.UT2';
 CALL CATMAN(PARMS1);           /* IGNORE RET CODE IF NOT 0  */
 FUNC = 'P';                    /* SET FOR PURGE OF DATASETS */
 DSNAME=SUBSTR(USERID,1,LEN_USERID) ×× '.ASM.UT3';
 CALL CATMAN(PARMS1);           /* IGNORE RET CODE IF NOT 0  */
  /* ************************************************************** */
  /*                                                                */
  /*   ALLOCATE DATASETS NEEDED BY THE ASSEMBLER                    */
  /*   AND CALL IT .                                                */
  /*   AT END OF COMPILATION DELETE THE SYSUT DATASETS AND          */
  /*   ISSUE A MESSAGE INDICATING THE RETURN CODE.                  */
  /*                                                                */
  /* ************************************************************** */
 IF LIBNAME ^= ' '             /*  ARE WE USING A PDS     */
 THEN DO;                      /* YES WE ARE              */
         K = INDEX(SOURCE,'(');  /* PARSE HAS REMOVED ANY QUOTES   */
         K = K - 1;      /* OR ALREADY INSERTED USER ID       */
         I = INDEX(LIBNAME,' ');
         I = I - 1;
         CALL DYNAM(WORK, 'ALLOC ', 'DSN='
                   ×× SUBSTR(SOURCE,1,K) ×× ' SHR;',
                   'ME=' ×× SUBSTR(LIBNAME,1,I) ×× ';',
                   'DD=ASMIN;');
      END;
 ELSE DO;
         K = INDEX(SOURCE,' ');
         K = K - 1;
          CALL DYNAM(WORK, 'ALLOC ', 'DSN='
                    ×× SUBSTR(SOURCE,1,K) ×× ' SHR;',
                    'DD=ASMIN;');
      END;
 K = INDEX (SOURCE,' ');
 CALL DYNAM(WORK, 'ALLOC ',
 'DSN=' ×× SUBSTR(USERID,1,LEN_USERID) ×× '.ASM.OBJ NEW CATLG;',
          'LRECL=80;','BLKSIZE=800;','FB;',
          'UNIT=SYSDA;','DD=ASMPNCH;',
          'TRK PRIMARY=15 SECONDARY=5;');
 CALL DYNAM(WORK, 'ALLOC ',
 'DSN=' ×× SUBSTR(USERID,1,LEN_USERID) ×× '.ASM.UT1 NEW CATLG;',
          'BLKSIZE=1024;',
          'UNIT=SYSDA;','DD=ASMUT1;',
          'TRK PRIMARY=15 SECONDARY=5;');
 CALL DYNAM(WORK, 'ALLOC ',
 'DSN=' ×× SUBSTR(USERID,1,LEN_USERID) ×× '.ASM.UT2 NEW CATLG;',
          'BLKSIZE=1024;',
          'UNIT=SYSDA;','DD=ASMUT2;',
          'TRK PRIMARY=15 SECONDARY=5;');
 CALL DYNAM(WORK, 'ALLOC ',
 'DSN=' ×× SUBSTR(USERID,1,LEN_USERID) ×× '.ASM.UT3 NEW CATLG;',
          'BLKSIZE=1024;',
          'UNIT=SYSDA;','DD=ASMUT3;',
          'TRK PRIMARY=15 SECONDARY=5;');
 CALL DYNAM(WORK, 'ALLOC ',
 'DSN=' ×× SUBSTR(USERID,1,LEN_USERID) ×× '.ASM.LIST NEW CATLG;',
          'LRECL=125;','BLKSIZE=629;','VBA;',
          'UNIT=SYSDA;', 'DD=ASMPRNT;',
          'TRK PRIMARY=15 SECONDARY=5;');
  /* ************************************************************** */
  /*                                                                */
  /*   SCAN FOR USER MACLIBS                                        */
  /*   UP TO 3 MAY BE SPECIFIED AND ANY CAN BE BLANK.               */
  /*   PARSE HAS ALREADY TOLD US THERE MUST BE AT LEAST ONE         */
  /*   MACRO LIBRARY SPECIFIED.                                     */
  /*                                                                */
  /*   ALLOWABLE VARIATIONS ARE :  (7 CASES)                        */
  /*                                                                */
  /*     1:MACLIB1 2:MACLIB1 3:MACLIB1 4:MACLIB1                    */
  /*       -------   MACLIB2   -------   MACLIB2                    */
  /*       -------   -------   MACLIB3   MACLIB3                    */
  /*                                                                */
  /*       =====================================                    */
  /*                                                                */
  /*     5:-------  6:------ 7:------                               */
  /*       -------   MACLIB2   MACLIB2                              */
  /*       MACLIB3   MACLIB3   ------                               */
  /*                                                                */
  /*                                                                */
  /*  THIS GETS VERY COMPLEX IF I ADD ANOTHER MACLIB.               */
  /*  3 SHOULD BE ENOUGH.                                           */
  /*                                                                */
  /*  YOU COULD ALWAYS CONCATENATE SAY SYS1.MACLIB AND SYS1.AMODGEN */
  /*  AT THE END OF USER MACLIBS SO YOU COULD HAVE 3 USER           */
  /*  SPECIFIED MACLIBS AND 2 STANDARD ONES GIVING 5 OF WHICH       */
  /*  ONLY 3 NEED TO BE SCANNED FOR.                                */
  /*                                                                */
  /*            (MIKE HAWTHORNE)                                    */
  /*                                                                */
  /* ************************************************************** */
 IF SUBSTR(COPY1,1,1) = ' '  /* NO MACLIB1                          */
  /*      ============== CASES 5 6 OR 7 ==============              */
 THEN DO;
  /*      =================== CASE 5 =================              */
         IF SUBSTR(COPY2,1,1) = ' '     /* MACLIB3 ONLY             */
         THEN DO;
         CALL DYNAM(WORK, 'ALLOC  ', 'DSN=' ×× SUBSTR(COPY3,1,L_COPY3)
                ×× ' SHR;','BLKSIZE=16000;','DD=ASMMAC;');
              END;
         ELSE DO;
  /*      =================== CASE 6 =================              */
                 IF SUBSTR(COPY3,1,1) ^= ' '  /*MACLIB3 AND MACLIB2 */
                 THEN DO;
         CALL DYNAM(WORK, 'ALLOC  ', 'DSN=' ×× SUBSTR(COPY2,1,L_COPY2)
                ×× ' SHR;','BLKSIZE=16000;','DD=ASMMAC;');
                 CALL DYNAM(WORK, 'ALLOC ', 'DSN='
                       ×× SUBSTR(COPY3,1,L_COPY3)
                       ×× ' SHR;','DD=DDNAME2;');
                 CALL DYNAM(WORK, 'CONCAT',
                           'DD=ASMMAC,DDNAME2;');
                      END;
                      ELSE DO;    /* MACLIB 2 ONLY */
  /*      =================== CASE 7 =================              */
         CALL DYNAM(WORK, 'ALLOC  ', 'DSN=' ×× SUBSTR(COPY2,1,L_COPY2)
                ×× ' SHR;','BLKSIZE=16000;','DD=ASMMAC;');
                           END;
              END;
         GO TO ASMIT;           /* NOW ASSEMBLE IT         */
      END;
  /*      ============ CASES 1 2 3 OR 4 ==============              */
 CALL DYNAM(WORK, 'ALLOC ', 'DSN=' ×× SUBSTR(COPY1,1,L_COPY1)
                ×× ' SHR;','BLKSIZE=16000;','DD=ASMMAC;');
 IF SUBSTR(COPY2,1,1) ^= ' '   /* MACLIB1 AND MACLIB2 */
  /*      ================ CASES 2 OR 4 ==============              */
 THEN DO;
         CALL DYNAM(WORK, 'ALLOC ', 'DSN='
                    ×× SUBSTR(COPY2,1,L_COPY2)
                    ×× ' SHR;','DD=DDNAME1;');
                 IF SUBSTR(COPY3,1,1) = ' '
  /*      =================== CASE 2 =================              */
                 THEN DO;
                 CALL DYNAM(WORK, 'CONCAT', 'DD=ASMMAC,DDNAME1;');
                      END;
                 ELSE DO;    /* MACLIB1 MACLIB2 MACLIB3             */
  /*      =================== CASE 4 =================              */
                 CALL DYNAM(WORK, 'ALLOC ', 'DSN='
                       ×× SUBSTR(COPY3,1,L_COPY3)
                       ×× ' SHR;','DD=DDNAME2;');
                 CALL DYNAM(WORK, 'CONCAT',
                           'DD=ASMMAC,DDNAME1,DDNAME2;');
                      END;
      END;
 ELSE DO;
  /*      ================ CASES 1 OR 3 ==============              */
         IF SUBSTR(COPY3,1,1) ^= ' '  /*MACLIB1 AND MACLIB3 */
         THEN DO;
  /*      =================== CASE 3 =================              */
                 CALL DYNAM(WORK, 'ALLOC ', 'DSN='
                       ×× SUBSTR(COPY3,1,L_COPY3)
                       ×× ' SHR;','DD=DDNAME2;');
                 CALL DYNAM(WORK, 'CONCAT',
                           'DD=ASMMAC,DDNAME2;');
              END;
  /*      =================== CASE 1 =================              */
      END;
 ASMIT: CALL DYNAM(WORK, 'ALLOC ',
          'DSN=' ×× SUBSTR(USERID,1,LEN_USERID)
          ×× '.ASM.ERRMSG NEW CATLG;',
          'LRECL=121;','BLKSIZE=1210;','FBA;',
          'UNIT=SYSDA;','DD=ASMTERM;',
          'TRK PRIMARY=2 SECONDARY=1;');
  FETCH IFOX00;
 CONS = 'ASSEMBLING FROM : ' ×× SUBSTR(SOURCE,1,INDEX(SOURCE,' '));
 CALL WRITEIT;
  CALL IFOX00(FORASM, ASMDDN);
  SAVERC = PLIRETV;
  RELEASE IFOX00;
  CONS= 'ASSEMBLER XF HAS FINISHED RC = ' ×× SAVERC;
  CALL WRITEIT;
  /* ************************************************************** */
  /*                                                                */
  /*   DE-ALLOCATE DDNAMES USED IN ASSEMBLY PROCESSING              */
  /*                                                                */
  /* ************************************************************** */
 CALL DYNAM(WORK, 'UNALLOC ', 'DD=ASMIN;');
 CALL DYNAM(WORK, 'UNALLOC ', 'DD=ASMPNCH;');
 CALL DYNAM(WORK, 'UNALLOC ', 'DD=ASMPRNT;');
 CALL DYNAM(WORK, 'UNALLOC ', 'DD=ASMTERM;');
 CALL DYNAM(WORK, 'UNALLOC ', 'DD=ASMUT1;');
 CALL DYNAM(WORK, 'UNALLOC ', 'DD=ASMUT2;');
 CALL DYNAM(WORK, 'UNALLOC ', 'DD=ASMUT3;');
 CALL DYNAM(WORK, 'UNCONCAT ','DD=ASMMAC;');
 CALL DYNAM(WORK, 'UNALLOC ', 'DD=ASMMAC;');
 CALL DYNAM(WORK, 'UNALLOC ', 'DD=DDNAME1;');
 CALL DYNAM(WORK, 'UNALLOC ', 'DD=DDNAME2;');
 FUNC = 'P';                    /* SET FOR PURGE OF DATASETS */
 DSNAME=SUBSTR(USERID,1,LEN_USERID) ×× '.ASM.UT1';
 CALL CATMAN(PARMS1);           /* IGNORE RET CODE IF NOT 0  */
 FUNC = 'P';                    /* SET FOR PURGE OF DATASETS */
 DSNAME=SUBSTR(USERID,1,LEN_USERID) ×× '.ASM.UT2';
 CALL CATMAN(PARMS1);           /* IGNORE RET CODE IF NOT 0  */
 FUNC = 'P';                    /* SET FOR PURGE OF DATASETS */
 DSNAME=SUBSTR(USERID,1,LEN_USERID) ×× '.ASM.UT3';
 CALL CATMAN(PARMS1);           /* IGNORE RET CODE IF NOT 0  */
  /* ************************************************************** */
  /*                                                                */
  /*   IF RETURN CODE >4                                            */
  /*   ENTER ISPF WITH BROWSE FACILITY TO BROWSE THE DATASET        */
  /*   JUST CREATED. WHEN THE USER HAS FINISHED WITH BROWSE THEN    */
  /*   EXIT BACK TO TSO.                                            */
  /*                                                                */
  /*   NOTE : WHILE YOU ARE IN BROWSE YOU HAVE FULL ACCESS TO       */
  /*          SPLIT SCREENS AND OTHER TSO/ISPF SERVICES SO YOU      */
  /*          CAN EDIT, ISSUE TSO COMMANDS ETC. ETC.                */
  /*                                                                */
  /* ************************************************************** */
  IF SAVERC > 4
  THEN DO;
         CONS = 'ABOUT TO BROWSE DIAGNOSTICS YOU MAY USE SPLIT'
            ×× ' SCREENS ETC WHILE IN BROWSE';
         CALL WRITEIT;
         CONS = 'PRESS ENTER TO CONTINUE : TO EXIT BROWSE PRESS PF3'
              ×× ' TO RESUME PROCESSING';
         CALL WRITEIT;
         BROWSE_DSN = 'ASM.ERRMSG';
         CALL ISPLINK ('BROWSE', BROWSE_DSN);
         LINK = 'N';
      END;
  /* ************************************************************** */
  /*                                                                */
  /*   IF LINK FLAG INDICATES WE ARE NOT INTERESTED LINK EDIT THEN  */
  /*   WE EXIT OTHERWISE WE SET OURSELVES UP FOR THE LINK STEP.     */
  /*                                                                */
  /* ************************************************************** */
   IF LINK = 'N'
   THEN DO;
           CONS = 'LINK EDIT STEP BYPASSED : EITHER YOU HAD '
                  ×× 'COMPILATION ERRORS IN YOUR PROGRAM';
           CALL WRITEIT;
           CONS = 'OR YOU DID NOT ASK FOR IT (TARGET LOAD LIBRARY '
                  ×× 'NOT ENTERED)';
           CALL WRITEIT;
           GO TO EXIT;
        END;
   CONS = 'LINK EDIT PROCESSING STARTING';
   LNKLEN = INDEX(LDT,' ');
   LNKLEN = LNKLEN - 1;
   LNKDATA = SUBSTR(LDT,1,LNKLEN);
  /* ************************************************************** */
  /*                                                                */
  /*   DELETE DATASET USERID.LNK.LINKLIST AND USERID.LNK.UT1        */
  /*   ALLOCATE DATASETS NEEDED BY THE LINKAGE EDITOR               */
  /*   AND CALL IT .                                                */
  /*                                                                */
  /*  NOTE : WE HAVE TO CONCATENATE ALL THE REQUIRED LIBRARIES      */
  /*         FOR SYSLIB (USING DDNAME LNKLIB) SO THAT AUTO LINK     */
  /*         WILL SEARCH THE RIGHT LIBRARIES.                       */
  /*                                                                */
  /*   AT END OF LINK EDIT  DELETE THE SYSUT1 DATASET AND           */
  /*   ISSUE A MESSAGE INDICATING THE RETURN CODE.                  */
  /*                                                                */
  /* ************************************************************** */
 FUNC = 'P';                    /* SET FOR PURGE OF DATASETS */
 DSNAME=SUBSTR(USERID,1,LEN_USERID) ×× '.LNK.LINKLIST';
 CALL CATMAN(PARMS1);           /* IGNORE RET CODE IF NOT 0  */
 FUNC = 'P';                    /* SET FOR PURGE OF DATASETS */
 DSNAME=SUBSTR(USERID,1,LEN_USERID) ×× '.LNK.UT1';
 CALL CATMAN(PARMS1);           /* IGNORE RET CODE IF NOT 0  */
 CALL DYNAM(WORK, 'ALLOC ',
 'DSN=' ×× SUBSTR(USERID,1,LEN_USERID) ×× '.LNK.UT1 NEW CATLG;',
          'BLKSIZE=1024;',
          'UNIT=SYSDA;','DD=LNKUT1;',
          'TRK PRIMARY=15 SECONDARY=5;');
 CALL DYNAM(WORK, 'ALLOC ',
 'DSN=' ×× SUBSTR(USERID,1,LEN_USERID) ×× '.LNK.LINKLIST NEW CATLG;',
          'LRECL=121;','BLKSIZE=1210;','FBA;',
          'UNIT=SYSDA;','DD=LNKPRNT;',
          'TRK PRIMARY=2 SECONDARY=5;');
 CALL DYNAM(WORK, 'ALLOC ',
 'DSN=' ×× SUBSTR(USERID,1,LEN_USERID) ×× '.ASM.OBJ SHR;',
         'DD=LNKLIN;');
 CALL DYNAM(WORK, 'ALLOC ', 'DSN=' ×× SUBSTR(LOAD,1,L_LOAD)
         ×× ' SHR;','DD=LNKMOD;');
 CALL DYNAM(WORK, 'ALLOC ', 'DSN=SYS1.PPLINK  SHR;',
        'DD=LNKLIB;');
 CALL DYNAM(WORK, 'ALLOC ', 'DSN=SYS1.LINKLIB SHR;',
        'DD=DD1;');
 CALL DYNAM(WORK, 'ALLOC ', 'DSN=' ×× SUBSTR(LOAD,1,L_LOAD)
         ×× ' SHR;','DD=DD2;');
 IF SUBSTR(LOAD1,1,1) ^= ' '
 THEN DO;
         CALL DYNAM(WORK, 'ALLOC ', 'DSN=' ×× SUBSTR(LOAD1,1,L_LOAD1)
         ×× ' SHR;','DD=DD3;');
          CALL DYNAM(WORK, 'CONCAT',
          'DD=LNKLIB,DD1,DD2,DD3;');
      END;
 ELSE DO;
          CALL DYNAM(WORK, 'CONCAT',
          'DD=LNKLIB,DD1,DD2;');
      END;
  FETCH HEWL;          /* YOU BETTER HAVE A BIG ENOUGH TSO REGION */
  CONS = 'LINK EDIT PROCESS STARTING';
  CALL WRITEIT;
  CALL HEWL (FORLNK, LNKDDN);
  SAVERC = PLIRETV;
  RELEASE HEWL;       /* DELETE IT  ITS A BIG STORAGE USER */
  CONS= 'LINK EDIT PROCESSING HAS FINISHED RC = ' ×× SAVERC;
  CALL WRITEIT;
  /* ************************************************************** */
  /*                                                                */
  /*   DE-ALLOCATE DDNAMES USED IN LINK EDIT PROCESSING             */
  /*                                                                */
  /* ************************************************************** */
 CALL DYNAM(WORK, 'UNALLOC ', 'DD=DDNAME1;');
 CALL DYNAM(WORK, 'UNALLOC ', 'DD=LNKUT1;');
 CALL DYNAM(WORK, 'UNALLOC ', 'DD=LNKLIN;');
 CALL DYNAM(WORK, 'UNALLOC ', 'DD=LNKMOD;');
 CALL DYNAM(WORK, 'UNCONCAT ','DD=LNKLIB;');
 CALL DYNAM(WORK, 'UNALLOC ', 'DD=LNKLIB;');
 CALL DYNAM(WORK, 'UNALLOC ', 'DD=DD1;');
 CALL DYNAM(WORK, 'UNALLOC ', 'DD=DD2;');
 CALL DYNAM(WORK, 'UNALLOC ', 'DD=DD3;');
  IF SAVERC ^= 0
  THEN DO;
          BROWSE_DSN = 'LNK.LINKLIST';
          CALL ISPLINK ('BROWSE', BROWSE_DSN);
       END;
  CALL DYNAM(WORK, 'UNALLOC ', 'DD=LNKPRNT;');
  GO TO EXIT;  /* REDUNDANT STATEMENT BUT MAKES CODE EASIER TO READ */
  /* ************************************************************** */
  /*                                                                */
  /*  THIS SUBROUTINE DOES THE FOLLOWING :                          */
  /*                                                                */
  /*                  A) TOO MANY QUOTES ON DATASET NAME.           */
  /*                  B) IF WE HAVE ( OR ) IN THE DATASET           */
  /*                     IS IT VALID. I.E '(' MUST COME BEFORE ')'. */
  /*                  C) IS THE MEMBER NAME 8 CHARS OR LESS.        */
  /*                  D) CHECKS FOR QUOTED DATASET. IF QUOTED       */
  /*                     CHECKS FOR MATCHING END OF QUOTE.          */
  /*                  E) IF NOT QUOTED APPENDS THE USERS TSO ID     */
  /*                     IN FRONT OF THE DSN.                       */
  /*                  F) CHECKS WHETHER THE DATASET CATALOGUED.     */
  /*                  G) IS THE MEMBER IN THE PDS IF ITS A PDS.     */
  /*                                                                */
  /*                                                                */
  /* ERRORS WILL CAUSE A RE-DISPLAY OF THE PANEL WITH A MESSAGE.    */
  /* PF2 WILL PRESENT THE ALTERNATE LONG MESSAGE.                   */
  /*                                                                */
  /*                                                                */
  /* ************************************************************** */
 PARSE: PROC;
 MEML = 0;
 MEMBER=' ';
 DSNAME = ' ';
 K = INDEX (TESTDSN,QUOTE ×× QUOTE); /* CHECK FOR DOUBLE QUOTES */
 IF K ^= 0
 THEN DO;
         ERR_FLAG = 'Y';
         MSGID = 'INV009  '; /* TOO MANY QUOTES          */
         GO TO ENDPARS;
      END;
 IF SUBSTR(TESTDSN,1,1) = QUOTE   /* EXTRACT QUOTES IF ANY   */
  THEN DO;                        /* IF THERE APPEND USER ID */
          K = INDEX (TESTDSN,' ');     /* GET LENGTH OF SOURCE DSN  */
          K = K - 1;                   /* GET THE REAL LENGTH       */
          IF SUBSTR(TESTDSN,K,1) ^= QUOTE
          THEN DO;
                  ERR_FLAG = 'Y';
                  MSGID = 'INV004  ';
                  GO TO ENDPARS;
               END;
          ELSE DO;
                  DSNAME=SUBSTR(TESTDSN,2,K-2); /* EXTRACT QUOTES */
               END;
       END;
  ELSE DO;
          K = INDEX (TESTDSN,QUOTE);   /* CHECK FOR A SINGLE QUOTE */
          IF K = 0                             /* NOT FOUND   OKAY */
          THEN DO;
                  K = INDEX (TESTDSN,' ');
                  K = K - 1;
                  DSNAME=SUBSTR(USERID,1,LEN_USERID) ×× '.'
                  ×× SUBSTR(TESTDSN,1,K);
                END;
          ELSE DO;
                  ERR_FLAG = 'Y';
                  MSGID = 'INV004  ';
                  GO TO ENDPARS;
               END;
       END;
 K = INDEX (DSNAME,'(');  /* NOTE WE HAVE NOW EXTRACTED QUOTE */
 IF K = 0                 /* AND IF NECESSARY APPENDED TSO USER ID */
 THEN DO;
         K = INDEX (DSNAME,')');
         IF K ^=0
         THEN DO;
                 ERR_FLAG = 'Y';
                 MSGID = 'INV004  '; /* SET INVALID DATASET NAME */
                 GO TO ENDPARS;
             END;
      END;        /* THAT TAKES CARE OF UNBALANCED PARENTHESES */
 ELSE DO;         /* WE HAVE ALREADY FOUND A  '(' SO VALIDATE DS */
         I = INDEX (DSNAME,')');
         IF I = 0
         THEN DO;
                 ERR_FLAG = 'Y';    /* UNBALANCED PARENTHESES */
                 MSGID = 'INV004  ';
                 GO TO ENDPARS;
             END;
         IF SUBSTR(DSNAME,I+1,1) = QUOTE  /* QUOTED DSN FOLKS   */
         THEN DO;
                 IF SUBSTR(DSNAME,I+2,1) ^= ' ' /* GARBAGE DSN  */
                 THEN DO;
                         ERR_FLAG = 'Y';
                         MSGID = 'INV004  ';
                         GO TO ENDPARS;
                      END;
              END;
         IF SUBSTR(DSNAME,I+1,1) ^= ' ' /* GARBAGE DSN  */
         THEN DO;
                 ERR_FLAG = 'Y';
                 MSGID = 'INV004  ';
                 GO TO ENDPARS;
              END;
         ELSE DO;
                 IF I < K          /* PARENTHESES ASS ABOUT TIT  */
                 THEN DO;          /* GOT ) BEFORE (  TURKEY !   */
                         ERR_FLAG = 'Y';
                         MSGID = 'INV004  ';
                         GO TO ENDPARS;
                      END;
                 MEML = I - K;
                 IF MEML > 9      /* INVALID MEMBER NAME          */
                 THEN DO;
                         ERR_FLAG = 'Y';
                         MSGID = 'INV007  ';
                         GO TO ENDPARS;
                      END;
                 ELSE DO;
                         MEMBER = SUBSTR(DSNAME,K+1,I-1);
                      END;
             END;
       END;
  IF ERR_FLAG = 'N'          /* ON ERROR SKIP REST OF PROCESSING    */
  THEN DO;
          FUNC = 'I';        /* CHECK IF CATALOGED                  */
          CALL CATMAN(PARMS1);
          IF PLIRETV ^=0
          THEN DO;
                  MSGID = 'INV002  ';
                  ERR_FLAG = 'Y';
                  GO TO ENDPARS;
               END;
       END;
  ENDPARS: IF ERR_FLAG = 'N'
  THEN DO;
          IF MEML > 0       /* WE'VE GOT A PDS HERE                */
          THEN DO;          /* NOW CHECK FOR MEMBER OF A PDS       */
                  CALL CHEKMEM;
               END;
       END;
 END PARSE;
 CHEKMEM: PROC;
  /* ************************************************************** */
  /*                                                                */
  /* WE WILL CHECK FOR MEMBER OF A PDS. CATALOG MANAGEMENT WILL     */
  /* TELL US IF THE WHOLE PDS IS OUT THERE BUT WILL NOT TELL US     */
  /* IF AN ACTUAL MEMBER IS IN THE PDS.                             */
  /* WE CAN GET THAT FROM DYNAMIC ALLOCATION ROUTINES AND OUR       */
  /* PDS MEMBER FINDER WHICH NEEDS A DDNAME OF WXYZ.                */
  /*                                                                */
  /* ************************************************************** */
  IF ERR_FLAG = 'N'
  THEN DO;
         K = INDEX(DSNAME,'(');
         K = K - 1;
         CALL DYNAM(WORK, 'ALLOC ', 'DSN='
         ×× SUBSTR(DSNAME,1,K)  ×× ' SHR;', 'DD=WXYZ;');
         IF PLIRETV ^= 0
         THEN DO;
                 CONS= 'DYNALLOC FAILED DSN='
                 ×× SUBSTR(DSNAME,1,K) ×× 'RC='
                 ×× PLIRETV;
                 CALL WRITEIT;
                 GO TO EXIT;
              END;
         LIBNAME = ' ';
         MPARML = 8;
         LIBNAME = SUBSTR(MEMBER,1,MEML-1);
         FETCH INVFIND;
         CALL INVFIND(FORMEM);
         SAVERC = PLIRETV;
         RELEASE INVFIND;
         CALL DYNAM(WORK, 'UNALLOC ', 'DSN='
                    ×× SUBSTR(DSNAME,1,K) ×× ' KEEP;', 'DD=WXYZ;');
         IF SAVERC ^= 0
         THEN DO;
                 ERR_FLAG = 'Y';
                 MSGID = 'INV008';
              END;
       END;
  END CHEKMEM;
- /* ************************************************************** */
  /*                                                                */
  /*  THIS SUBROUTINE ISSUES THE APPROPRIATE ERROR MESSAGES         */
  /*  AND EXITS THE PROGRAM                                         */
  /*                                                                */
  /* ************************************************************** */
 WRITEIT: PROC;
          PUT FILE(MSGFILE) EDIT (CONS)(A(80));
 END WRITEIT;
- /* ************************************************************** */
  /*                                                                */
  /*            CLEAN UP AND TERMINATION SECTION.                   */
  /*                                                                */
  /* THE ASSEMBLER KNOWS ITS UNDER TSO SO WE WILL ALSO HAVE         */
  /* TO FREE DDNAME=TERMFILE AND OUR OWN TERMINAL DATASET.          */
  /*                                                                */
  /* IF THE USER HAS INDICATED HE WANTS A PRINT THEN ISSUE THE      */
  /* PRINTOFF COMMAND.                                              */
  /*                                                                */
  /*                                                                */
  /* ************************************************************** */
  EXIT: IF PRTOPT = 'YES'
        THEN DO;
                TSOCMD = 'PRINTOFF ASM.LIST';
                TSOLEN = INDEX(TSOCMD,' ');
                CALL INVTSO(TSOLEN, TSOCMD);
                IF LINK = 'Y'
                THEN DO;
                        TSOCMD = 'PRINTOFF LNK.LINKLIST';
                        TSOLEN = INDEX(TSOCMD,' ');
                        CALL INVTSO(TSOLEN, TSOCMD);
                     END;
             END;
 CONS = 'ASSEMBLER XF PROMPTER HAS FINISHED';
 CALL WRITEIT;
 EXIT1: RELEASE CATMAN;
 CLOSE FILE(MSGFILE);
 CALL DYNAM(WORK,'UNALLOC ','DD=MSGFILE;');
 RELEASE DYNAM;
 RELEASE INVTSO;
 CALL ISPLINK('VDELETE', '(SOURCE)');
 CALL ISPLINK('VDELETE', '(LNAME)');
 CALL ISPLINK('VDELETE', '(COPY1)');
 CALL ISPLINK('VDELETE', '(COPY2)');
 CALL ISPLINK('VDELETE', '(COPY3)');
 CALL ISPLINK('VDELETE', '(LOAD1)');
 CALL ISPLINK('VDELETE', '(LOAD)');
 CALL ISPLINK('VDELETE', '(OPT)');
 CALL ISPLINK('VDELETE', '(LDT)');
 CALL ISPLINK('VDELETE', '(PRTOPT)');
 END INVASMF;
