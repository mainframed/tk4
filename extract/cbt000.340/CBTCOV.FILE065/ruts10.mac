*********************************************************************
*****               TSIWM.SOURCE.DATA(RUTS10)                   *****
*****               FLOYD L. PEDRIANA                           *****
*****               WALTER MARZOUK                      5-06-81 *****
********************************************************************;
 MACRO DAYDELT
   DATEJ=DATEJUL(CHEKDATE);
   DAY =WEEKDAY(DATEJ);       *1=SUN TO 7=SAT;
   IF DAY=1 OR DAY=7 THEN DELETE;          *WEEKENDS DELETED;
   IF CHEKDATE = 82001 OR     CHEKDATE = 82046 OR
      CHEKDATE = 82151 OR     CHEKDATE = 82186 OR
      CHEKDATE = 82249 OR     CHEKDATE = 82284 OR
      CHEKDATE = 82315 OR     CHEKDATE = 82329 OR
      CHEKDATE = 82330 OR     CHEKDATE = 82358 OR
      CHEKDATE = 82365        THEN DELETE ;
                        * LOS ANGELES COUNTY HOLIDAYS DELETED;
   %
DATA TEMP4A  (KEEP = JOBID       MISCUNIT MISCEXCP
                TAPEUNIT TAPEXCP DISKUNIT DISKEXCP URECUNIT URECEXCP)
     TEMP5A  (KEEP = JOBID CPUID JOBNAME STARTIME STARTDTE CLASS STEPS
                     SU  ACCOUNT INITTIME INITDATE ET_MIN  JOBTYPE
                     MJSYSCOD  CPU NOFTXNS)
     TEMP6A  (KEEP = JOBID JOBNAME STARTIME LINES  PRNTSETS PAGES)
     TEMP14A (KEEP = JOBID JOBNAME STARTIME DDNAME DEVICE BLKSIZE)
     TEMP26A (KEEP = JOBID JOBNAME STARTIME STARTDTE  JOB_MIN)
     TEMP70A (KEEP = DATE  SHIFT HOUR CPUID
                     CPU_BUSY  AVEBATCH AVESTART AVETSO)
     TEMP71A (KEEP = DATE SHIFT HOUR CPUID DMNDPGRT PAGFAULT SWAPRATE)
     TEMP73A (KEEP = DATE SHIFT HOUR CPUID ANYCHNBS WAITFCHN
                        SIO0-SIO15
                     CHANBS0-CHANBS15)
     TEMP72A (KEEP = DATE SHIFT HOUR CPUID  PG_NO  NOTXNTMT
                     SERVICE ELPSTIME  MAINSERV IOSERV
                     CPUSERV TXNRSTIM NOFSWAP DOMAINNO);
      ARRAY SIO (K)         SIO0-SIO15;
      ARRAY CHANBS (K)   CHANBS0-CHANBS15;
      OPTIONS MACROGEN;
INFILE  INDD  MISSOVER;
      INPUT   @2   ID        PIB1.
                   TERMTIME  PIB4.
                   TERMDATE   PD4.
                   SYSID       $4.
              @12  CPUID       $1.  @;
     TERMYR = INT(TERMDATE/1000);
  IF ID=4 OR ID=5 OR ID=6 OR ID=14 OR ID=15 OR ID=26 OR ID=34 OR ID=35
     THEN GO TO TYPESMF;
 IF ID =70 OR ID =71 OR ID =73     OR ID=72
     THEN GO TO TYPERMF; ELSE DELETE;
TYPESMF:
      INPUT   @15  JOBID  $CHAR16.
              @15  JOBNAME     $8.
              @23  STARTIME  PIB4.
              @28  STARTDTE   PD3.  @;
  SAVETIME =(TERMTIME +((TERMDATE - STARTDTE)*8640000)+STARTIME)/2;
  CHEKDATE = STARTDTE + INT(SAVETIME/8640000);
  DAYDELT
    STARTYR = INT(STARTDTE/1000);
    IF MOD(STARTYR,4) = 0 THEN DAYFIX = (STARTYR*1000) + 366;
                          ELSE DAYFIX = (STARTYR*1000) + 365;
  IF ID = 14 THEN GO TO TYPE14;    *DATA SETS  OPENED FOR INPUT;
  IF ID = 15 THEN GO TO TYPE14;    *DATA SETS  OPENED FOR OUTPUT;
  IF ID =  4 THEN GO TO TYPE4 ;    *STEP PROCS. BATCH BACKGROUND;
  IF ID = 34 THEN GO TO TYPE4 ;    *STEP PROCS. TSO   FOREGROUND;
  IF ID =  6 THEN GO TO TYPE6 ;    *SYSOUT PROCESSING;
  IF ID =  5 THEN GO TO TYPE35;    *JOB PROCS. BATCH  BACKGROUND;
  IF ID = 35 THEN GO TO TYPE35;    *JOB PROCS. TSO    FOREGROUND;
  IF ID = 26 THEN GO TO TYPE26;    *AT JOB PURGE AFTER PRINT;
TYPE4:
      INPUT  @55   PGMNAME     $8.
             @84   CC_S      PIB1.
             @101  RELOCATE  PIB2.
             @103  DEVLNGTH  PIB2. @;
      DISKEXCP = 0;   TAPEXCP = 0;   URECEXCP = 0;   MISCEXCP = 0;
      DISKUNIT = 0;  TAPEUNIT = 0;   URECUNIT = 0;   MISCUNIT = 0;
      AOFF = DEVLNGTH + 1;
      DEVLNGTH = DEVLNGTH - 2;
NEXT:
      IF DEVLNGTH = 0 THEN GO TO STEPCPU;
      EXCPS = 0;
      INPUT  DEVCLASS    PIB1.
             FILL        PIB1.
             ADDRESS     PIB2.
             EXCPS       PIB4.   @;
      DEVLNGTH = DEVLNGTH - 8;
      IF EXCPS    =   0 THEN GO TO NEXT;
      IF DEVCLASS =  32 THEN DO;
                                DISKUNIT + 1;
                                DISKEXCP = DISKEXCP + EXCPS;  END; ELSE
      IF DEVCLASS = 128 THEN DO;
                                TAPEUNIT + 1;
                                TAPEXCP = TAPEXCP + EXCPS;    END; ELSE
      IF DEVCLASS =   8 THEN DO;
                                URECUNIT + 1;
                                URECEXCP = URECEXCP + EXCPS;  END; ELSE
                             DO;
                                MISCUNIT + 1;
                                MISCEXCP = MISCEXCP + EXCPS;  END;
      GO TO NEXT;
STEPCPU:
      INPUT  @103+AOFF     CPU       PIB3.
             @RELOCATE     PAGEINS   PIB4.
             @RELOCATE+28  SERVUNIT  PIB4.
             @RELOCATE+38  RESIDENT  PIB4.
             @RELOCATE+62  PAGE_SEC  PIB8.  @;
      IF CPU=. THEN DELETE;
      OUTPUT TEMP4A;        RETURN;
TYPE35:
      INPUT  @39   STEPS     PIB1.
             @52   CC_J      PIB2.
             @65   RESIDENT  PIB4.
             @77   SU        PIB4.
             @114  CPU       PIB3.
             @118  ACCTFLD   PIB1.
             @119  ACCOUNT $CHAR9.
             @129  JOBTYPE $CHAR1.
             @130  MJSYSCOD $CHAR2. @;
*100=PROD, 300=TEST, 400=ITD, 800=TSO;
      IF CPU=. OR CPU = 0 THEN DELETE;
 IF ID = 35 THEN  DO;
                 INITTIME = STARTIME;
                 INITDATE = STARTDTE;
     INPUT  @85  NOFTXNS     PIB4. @;
                 END;
 IF ID = 35 THEN GO TO PROC5_35;      ELSE
      INPUT  @40   INITTIME  PIB4.
                   INITDATE   PD4.
             @72   CLASS       $1.   @;
PROC5_35:
      IF TERMYR > INT(INITDATE/1000) THEN
                      TERMDATE = DAYFIX + (MOD(TERMDATE,1000) );
 ET_MIN=(TERMTIME + ((TERMDATE - INITDATE) * 8640000) - INITTIME)/6000;
      CPU      = CPU / 100;
      SU       = SU  /1000;
      OUTPUT TEMP5A;         RETURN;
TYPE6:
      INPUT  @48   LINES     PIB4.
             @53   PRNTSETS  PIB1.
             @85   PAGES     PIB4.  @;
      OUTPUT TEMP6A;         RETURN;
TYPE14:
      INPUT  @53   DDNAME      $8.
             @167  BLKSIZE   PIB2.
             @275  DEVICE    PIB1.
             @281  EXCPS     PIB4.  @;
      OUTPUT  TEMP14A;        RETURN;
TYPE26:
     IF TERMYR > STARTYR THEN
                      TERMDATE = DAYFIX + (MOD(TERMDATE,1000) );
JOB_MIN=(TERMTIME + ((TERMDATE - STARTDTE) * 8640000) - STARTIME)/6000;
     OUTPUT TEMP26A;       RETURN;

TYPERMF:
  CHEKDATE=TERMDATE;
  DAYDELT
      POINTER = 15;
      INPUT @ POINTER
                     COM_SIZE  PIB2.
                     TIME       PD4.
                     DATE       PD4.
                     DURATION   PD4.3  @;
 X = 60*FLOOR(DURATION/100)+MOD(DURATION,100); *CONVERT TO SECONDS;
 HOUR = FLOOR(TERMTIME/360000) ;
 POINTER = POINTER + COM_SIZE;
 SHIFT = '1';
 IF HOUR >16 THEN SHIFT ='2';
 IF HOUR <8  THEN SHIFT ='3';
  IF ID = 72 THEN GO TO TYPESRM;   *WORKLOAD ACTIVITY INFO;
      INPUT        +4 NOFSAMPL PIB4.   @;
  IF NOFSAMPL = 0 THEN NOFSAMPL =. ;
  IF ID = 70 THEN GO TO TYPE70;    *CPU BUSY INFORMATION;
  IF ID = 71 THEN GO TO TYPE71;    *PAGING SWAP INFO;
  IF ID = 73 THEN GO TO TYPE73;    *ON-LINE CHANNEL INFO;
TYPE70:
      INPUT @ POINTER
                     CON_SIZE  PIB2.
                     CPU_NO    PIB2.
                     CPU_SIZE  PIB2.   @;
     POINTER = POINTER + CON_SIZE;
     INPUT @ POINTER
                     CPU_WT     PIB8.
                     CPU_ID     PIB2.
                     +1 VALID   PIB1.
                     +1 SERIAL_0 PIB3.  @;
      CPU_WT = CPU_WT/4096;      *CONVERT TO MICROSECONDS;
      CPU_WT = CPU_WT/1000000;   *CONVERT TO SECONDS;
      CPU0_BUS =100 * (1 - CPU_WT/X);
      CPU1_BUS =.;
      IF CPU_NO = 1 THEN GO TO _70_1;
      POINTER = POINTER + CPU_SIZE;
      INPUT @ POINTER
                     CPU_WT     PIB8.
                     CPU_ID     PIB2.
                     +1 VALID  PIB1.
                     +1 SERIAL_1 PIB3.  @;
      CPU_WT = CPU_WT / 4096;
      CPU_WT = CPU_WT / 1000000;
      CPU1_BUS = 100*(1 - CPU_WT/X);
  _70_1:
      IF CPU1_BUS =. THEN CPU1_BUS = CPU0_BUS;
      CPU_BUSY = (CPU0_BUS + CPU1_BUS)/2;
       POINTER = POINTER + CPU_SIZE;
       INPUT @ POINTER
                      +244 BATCHUSR  PIB4.
                      +52  STARTUSR  PIB4.
                      +52  TSOTUSR   PIB4. @;
  AVEBATCH = BATCHUSR/NOFSAMPL;
  AVESTART = STARTUSR/NOFSAMPL;
  AVETSO   =TSOTUSR / NOFSAMPL;
 OUTPUT TEMP70A;     RETURN;
 TYPE71:
   INPUT @ POINTER
                  PAG_SIZE   PIB2.
                  DATASIZE   PIB2.  @;
   POINTER = POINTER + PAG_SIZE;
   INPUT @ POINTER
                  NVNSPGIN   PIB4.
                  NVNSPGOT   PIB4.
                  NVPGRC     PIB4.
                  NSPSWAP    PIB4.  @;
   DMNDPGRT = (NVNSPGIN + NVNSPGOT)/X;
   PAGFAULT = (NVNSPGIN + NVPGRC)/X;
   SWAPRATE = NSPSWAP/X;
   OUTPUT  TEMP71A;  RETURN;
 TYPE73:
     INPUT @ POINTER
                    CON_SIZE      PIB2.
                    NOFCHANL      PIB2.
                    PHCHSIZE      PIB2.
                    NOFLGCHN      PIB2.
                    LGCHSIZE      PIB2.
                 +2 CHANBUS0      PIB4.
                    CHANBUS1      PIB4.
                    CHANWAT0      PIB4.
                    CHANWAT1      PIB4.   @;
    IF SYSID='1658' OR SYSID='2058' THEN DO;
       ANYCHNBS = 100*(CHANBUS1/NOFSAMPL);
       WAITFCHN = 100*(CHANWAT1/NOFSAMPL);
       END;                  ELSE
    IF SYSID='1733' OR SYSID='1833' THEN DO;
       ANYCHNBS = 100*(CHANBUS0/NOFSAMPL);
       WAITFCHN = 100*(CHANWAT0/NOFSAMPL);
       END;
     POINTER = POINTER + CON_SIZE;
      K=1;
 TYPE73_1:
      INPUT @ POINTER
                    +2 CHANID     PIB1.
                       CHNIDCTR     $1.
                       SIO_SIO    PIB4.
                       CHN_BUSY   PIB4.   @;
      SIO      = SIO_SIO/X;
      CHANBS   =100*(CHN_BUSY/NOFSAMPL);
   IF CHNIDCTR = '...1....'B   THEN DO; CHANID=.;
                                        SIO=.;
                                        CHANBS=.;    END;
   POINTER = POINTER + PHCHSIZE;
   K+1;
   IF K ^> NOFCHANL THEN GO TO TYPE73_1;
  OUTPUT TEMP73A;   RETURN;
TYPESRM:
   INPUT @ 31    PG_NO      PIB2.  @;
   INPUT @ POINTER
                 CON_SIZE   PIB2.
                 PEROD_NO   PIB2.
                 PRD_SIZE   PIB2.  @;
   POINTER = POINTER + CON_SIZE;
   P=1;
   Y=0;        *TO COMPARE DOMAIN;
   L=0;        *SWITCH FOR FIRST PERIOD IN THE RECORD;
   NOTXNTMT=0;
   ACTIME=0  ;
   SERVICE=0 ;
   ELPSTIME=0;
   WORKLVL=0 ;
   MAINSERV=0 ;
   IOSERV=0  ;
   CPUSERV=0 ;
   TXNRSTIM=0;
   NOFSWAP=0 ;
   *THE LOGIC BEHIND 72 SECTION IS THAT WE ACCUMULATE THE VARIABLES*
   *  IF IT IS UNDER THE SAME DOMAIN WHILE WE OUTPUT A RECORD IF IT*
   *  IS UNDER A DIFFERENT DOMAIN, WHEN PROCESSING DIFFERENT PERIODS;
 TYPE72_1:
     INPUT @ POINTER
                    SMF72TTX   PIB4.
                    SMF72ACT   PIB4.
                    SMF72SER   PIB4.
                    SMF72TTM   PIB4.
                    SMF72LEV   PIB4.
                    SMF72MTS   PIB4.
                    SMF72ITS   PIB4.
                    SMF72CTS   PIB4.
                    SMF72TAT   PIB4.
                    SMF72SPP   PIB4.
                    SMF72CDN   PIB2.  @;
   IF SMF72CDN ^=Y  AND L>0  AND PG_NO ^=16   THEN DO;
                     OUTPUT TEMP72A;
                     NOTXNTMT=0;
                     ACTIVE  =0;
                     SERVICE =0;
                     ELPSTIME=0;
                     WORKLVL =0;
                     MAINSERV=0;
                     IOSERV  =0;
                     CPUSERV =0;
                     TXNRSTIM=0;
                     NOFSWAP =0;
                     END;
   IF SMF72ACT >0 THEN DO;
      SMF72ACT=SMF72ACT*1024/1000000;
      SMF72TTM=SMF72TTM*1024/1000000;
      SMF72TAT=SMF72TAT*1024/1000000;
      SMF72LEV=SMF72LEV/256;
      END;
   NOTXNTMT =NOTXNTMT + SMF72TTX;
   ACTIME   =ACTIME   + SMF72ACT;
   SERVICE  =SERVICE  + SMF72SER;
   ELPSTIME =ELPSTIME + SMF72TTM;
   WORKLVL  =WORKLVL  + SMF72LEV;
   MAINSERV =MAINSERV + SMF72MTS;
   IOSERV   =IOSERV   + SMF72ITS;
   CPUSERV  =CPUSERV  + SMF72CTS;
   TXNRSTIM =TXNRSTIM + SMF72TAT;
   NOFSWAP  =NOFSWAP  + SMF72SPP;
   DOMAINNO =SMF72CDN           ;
   Y =DOMAINNO;
   L+1;
   P+1;
   POINTER = POINTER + PRD_SIZE;
   IF P ^> PEROD_NO   THEN GO TO TYPE72_1;
      OUTPUT TEMP72A;    RETURN;

PROC SORT DATA = TEMP4A;      BY JOBID;
PROC MEANS NOPRINT SUM;               BY JOBID;
     VAR   TAPEUNIT TAPEXCP  DISKUNIT DISKEXCP
           URECUNIT URECEXCP MISCUNIT MISCEXCP ;
     OUTPUT OUT = TEMP4B
     SUM = TAPEUNIT TAPEXCP  DISKUNIT DISKEXCP
           URECUNIT URECEXCP MISCUNIT MISCEXCP ;
PROC SORT DATA = TEMP6A;      BY JOBID;
PROC MEANS NOPRINT SUM;               BY JOBID;
     VAR   LINES PRNTSETS PAGES;
     OUTPUT OUT = TEMP6B
     SUM = LINES PRNTSETS PAGES;
PROC SORT DATA = TEMP14A;     BY JOBID DEVICE DDNAME;
DATA TEMP14B;
SET  TEMP14A;                 BY JOBID DEVICE DDNAME;
     IF DEVICE = 128 THEN TAPEBLKS = BLKSIZE; ELSE
     IF DEVICE =  32 THEN DISKBLKS = BLKSIZE;
   * IF DEVICE =   8 THEN URECBLKS = BLKSIZE;
     IF LAST.DDNAME  THEN OUTPUT TEMP14B;
                     ELSE DELETE;
     DROP DEVICE ;
PROC MEANS NOPRINT N MEAN;            BY JOBID ;
            VAR    TAPEBLKS DISKBLKS ;
     OUTPUT OUT  = TEMP14C
            N    = TAPESETS DISKSETS
            MEAN = TAPEBLK_ DISKBLK_  ;
PROC SORT DATA = TEMP5A;              BY JOBID;
PROC SORT DATA = TEMP26A;             BY JOBID;
DATA    TEMP456
        (KEEP = CPUID    JOBNAME  ACCOUNT  STARTIME STARTDTE
                CLASS    STEPS    INITDATE INITTIME ET_MIN   CPU
                LINES    PRNTSETS PAGES JOBTYPE MJSYSCOD JOB_MIN SU
                TAPEUNIT TAPEXCP  TAPESETS TAPEBLKS   NOFTXNS
                DISKUNIT DISKEXCP DISKSETS DISKBLKS
                MISCUNIT MISCEXCP SHIFT RUNHR FILLERS);
  LENGTH  JOBNAME                             $ 8
          ACCOUNT                             $ 9
          CPUID                               $ 1
          JOBTYPE                             $ 1
          MJSYSCOD                            $ 2
          SHIFT  CLASS                        $ 1
          RUNHR  TAPESETS TAPEUNIT STEPS PRNTSETS MISCUNIT  2
            DISKSETS  DISKUNIT     NOFTXNS
            TAPEBLKS DISKBLKS                   3
          STARTIME STARTDTE INITTIME INITDATE SU
          TAPEXCP MISCEXCP LINES PAGES DISKEXCP 4
                                     DEFAULT =  4;
      FORMAT  ET_MIN JOB_MIN CPU   6.1
              STARTDTE  YYMMDD6.;
      MERGE  TEMP4B TEMP6B TEMP14C TEMP5A TEMP26A; BY JOBID;
      IF CPU=. THEN DELETE;
      TAPEBLKS = INT(TAPEBLK_+.5);   DISKBLKS = INT(DISKBLK_+.5);
      CPU = (.01*INT((CPU+.005)*100) );
      SU  = (.1*INT((SU +.05)*10) );
      RUNHR = INT((INITTIME/360000) + (ET_MIN/120) + .5) ;
      RUNHR = MOD(RUNHR,24);
      SHIFT = '1';
      IF RUNHR > 16 THEN SHIFT = '2';  ELSE
      IF RUNHR <  8 THEN SHIFT = '3';
      STARTDTE=DATEJUL(STARTDTE);
      FILLERS='XXXXXXXX';
      PROC DELETE DATA=SMFDD._ALL_;
      PROC SORT DATA=TEMP456
                 OUT=SMFDD.SMFDATA;
           BY STARTDTE SHIFT RUNHR CPUID ACCOUNT JOBNAME;

      PROC CONTENTS DATA=SMFDD._ALL_ MAP POSITION;
      TITLE1  REPORT #1  DESCRIPTIVE CONTENTS OF THE SMF DATA BASE;
  *   PROC MEANS MEAN N MAX MIN NMISS DATA=SMFDD.SMFDATA;
  *   TITLE1  REPORT #2  DESCRIPTIVE STATISTICS OF THE SMF DATA BASE;
  *   PROC PRINT DATA=SMFDD.SMFDATA (OBS=104);
  *   TITLE1  REPORT #3  SMF DATA BASE FILE DUMP;

 PROC SORT DATA= TEMP70A; BY  DATE SHIFT HOUR CPUID;
 PROC MEANS NOPRINT DATA =TEMP70A; BY  DATE SHIFT HOUR CPUID;
 VAR   CPU_BUSY AVEBATCH AVESTART AVETSO;
 OUTPUT OUT=TEMP70B
 MEAN =  CPU_BUSY AVEBATCH AVESTART AVETSO;
PROC SORT DATA=TEMP71A; BY  DATE SHIFT HOUR CPUID;
PROC MEANS NOPRINT DATA=TEMP71A; BY  DATE SHIFT HOUR CPUID;
 OUTPUT OUT=TEMP71B
 MEAN = DMNDPGRT PAGFAULT SWAPRATE;
 DATA TEMP73B;
 SET TEMP73A;
      DROP SIO0    SIO6
           CHANBS0 CHANBS6;
PROC SORT DATA=TEMP73B; BY  DATE SHIFT HOUR CPUID;
PROC MEANS NOPRINT DATA=TEMP73B; BY  DATE SHIFT HOUR CPUID;
 VAR ANYCHNBS WAITFCHN
                        SIO1-SIO5         SIO7-SIO15
                        CHANBS1-CHANBS5   CHANBS7-CHANBS15;
   OUTPUT OUT=TEMP73C
    MEAN = ANYCHNBS WAITFCHN
                             SIO1-SIO5    SIO7-SIO15
                            CHANBS1-CHANBS5  CHANBS7-CHANBS15;
PROC DELETE DATA=RMFDD._ALL_;
DATA RMFDD.RMFDATA
       (KEEP = CPUID DATE SHIFT HOUR
               CPU_BUSY AVEBATCH AVESTART AVETSO
               DMNDPGRT PAGFAULT SWAPRATE
               ANYCHNBS WAITFCHN
               SIO1-SIO5         SIO7-SIO15
               CHANBS1-CHANBS5   CHANBS7-CHANBS15  FILLER);
      LENGTH   DATE
               CPU_BUSY AVEBATCH AVESTART AVETSO
               DMNDPGRT PAGFAULT SWAPRATE
               SIO1-SIO5         SIO7-SIO15
               CHANBS1-CHANBS5   CHANBS7-CHANBS15
               ANYCHNBS  WAITFCHN                    4
               HOUR                                  2
              DEFAULT =4;
      FORMAT  CHANBS1-CHANBS5    CHANBS7-CHANBS15
              SIO1-SIO5          SIO7-SIO15         5.2
              DATE  YYMMDD6.;
   MERGE TEMP70B TEMP71B TEMP73C ;BY  DATE SHIFT HOUR CPUID;
   DATE=DATEJUL(DATE);
   FILLER='XXXXXXXXXX';
 PROC CONTENTS DATA=RMFDD._ALL_  MAP POSITION;
 TITLE1  REPORT #4 DESCRIPTIVE CONTENTS OF RMF DATA BASE;
* PROC MEANS MEAN N MAX MIN NMISS DATA=RMFDD.RMFDATA;
* TITLE1  REPORT #5 DESCRIPTIVE STATISTICS OF RMF DATA BASE;
* PROC PRINT DATA=RMFDD.RMFDATA (OBS=96);
* TITLE1  REPORT #6 RMF DATA BASE FILE DUMP;

 PROC SORT DATA=TEMP72A; BY DATE SHIFT HOUR CPUID PG_NO DOMAINNO;
 PROC MEANS NOPRINT DATA=TEMP72A;
          BY DATE SHIFT HOUR CPUID PG_NO DOMAINNO;
    VAR NOTXNTMT  SERVICE ELPSTIME NOFSWAP
        MAINSERV IOSERV CPUSERV TXNRSTIM;
        OUTPUT OUT=TEMP72B
        SUM  = NOTXNTMT   SERVICE ELPSTIME NOFSWAP
               MAINSERV IOSERV CPUSERV TXNRSTIM;
 PROC DELETE DATA=SRMDD._ALL_;
 DATA SRMDD.SRMDATA;
 SET  TEMP72B;
 DATE=DATEJUL(DATE);
 FILLERM='XXXXXXXXXX';
 LENGTH  HOUR  PG_NO  DOMAINNO                        2
         DATE  NOTXNTMT   SERVICE  ELPSTIME
         MAINSERV  IOSERV  CPUSERV  TXNRSTIM  NOFSWAP 4;
 FORMAT DATE YYMMDD6.;
 PROC CONTENTS DATA=SRMDD._ALL_  MAP POSITION;
 TITLE1  REPORT #7 DESCRIPTIVE CONTENTS OF SRM DATA BASE;
* PROC MEANS MEAN N MAX MIN NMISS DATA=SRMDD.SRMDATA;
* TITLE1  REPORT #8 DESCRIPTIVE STATISTICS OF SRM DATA BASE;
* PROC PRINT DATA=SRMDD.SRMDATA (OBS=112);
* TITLE1  REPORT #9 SRM DATA BASE FILE DUMP;
