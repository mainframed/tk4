**********************************************************************
* THIS ROUTINE WILL GIVE THE VALUES OF VARIABLES IN READABLE          *
* FORM IF AN ABEND CONDITION OCCURS. IT IS NOT NECESSARY TO           *
* HAVE A SYSUDUMP OR SYSABEND CARD TO GET THIS OUTPUT                 *
*                             HOWEVER                                 *
* A //DEBUGOUT DD CARD IS REQUIRED FOR THIS OUTPUT SUCH AS            *
* DEBUGOUT DD SYSOUT=*.  IF THIS CARD MISSING OR DD DUMMY NO          *
* DEBUGGING OUTPUT WILL APPEAR                                        *
*                                                                     *
*        THE VARIABLES ARE PRINTED IN THE ORDER OF THE CALL           *
*        STATEMENTS ARE EXECUTED                                      *
*                                                                     *
*                                                                     *
*                                                                     *
*                                                                     *
* THE CALLING SEQUENCE TO THIS PROGRAM IS AS FOLLOWS                  *
*                                                                     *
* CALL TERMON(OPT,NAMESW,EBDVARIABLE,VARIABLE,                        *
*              D1,D2,D3,D4,D5,D6,D7,,,,,,,,,,,,,,,,,,,,,,)            *
*                                                                     *
*                                                                     *
*                                                                     *
*        OPT IS A FLAG THAT TELLS THE PROGRAM THAT THE NAME           *
*        THAT FOLLOWS IS THE OPTIONAL LENGTH FOR THE VARIABLE         *
*                                                                     *
*                                                                     *
*        IT IS A -     (MINUS) IF THE VARIABLE IS NOT THE             *
*        STANDARD FORTRAN LENGTH                                      *
*                                                                     *
*        ************VARIABLE LENGTHS ******************              *
*  VARIABLE TYPE               STANDARD               OPTIONAL        *
*    INTEGER                       4                      2           *
*    REAL                          4                      8           *
*                                                                     *
*                                                                     *
*                                                                     *
*        IF THE VARIABLE IS THE STANDARD LENGTH THIS PARAMATER        *
*        SHOULD NOT APPEAR                                            *
*                                                                     *
*                                                                     *
*                                                                     *
*        NAMESW         IS A FLAG TO TELL THE PROGRAM THAT            *
*        THE NAME IS NOT THE FORTRAN STANDARD NAME FOR THIS           *
*        TYPE OF VARIABLE. (A THRU H  AND O THUR Z FOR REAL AND       *
*        I THRU N FOR INTEGER)                                        *
*                                                                     *
*                                                                     *
*        THIS ARGUMENT IF PRESENT SHOULD BE SET TO                    *
*                                                                     *
*        * FOR AN INTEGER WITH A REAL NAME                            *
*        / FOR AN REAL WITH A INTEGER NAME                            *
*                                                                     *
*                                                                     *
*        IF THE VARIABLE IS THE FORTRAN STANDARD TYPE THIS            *
*        THIS PARAMATER SHOULD NOT APPEAR                             *
*                                                                     *
*                                                                     *
*                                                                     *
*                                                                     *
*        EBDVARIABLE IS THE EBDIC NAME OF THE VARIABLE IN QUOTES      *
*        THIS PARAMATER IS REQUIRED .   IT IS THE FIRST               *
*        PARAMATER IF THE 2 PREVIOUS PARAMATERS ARE                   *
*        NOT REQUIRED AS WILL BE THE CASE FOR                         *
*        MOST VARIABLES                                               *
*                                                                     *
*        D1    IS THE FIRST DIMENSION OF THE VARIABLE                 *
*        D2    IS THE SECOND DIMENSION OF THE VARIABLE                *
*        D3    IS THE THIRD DIMENSION OF THE VARIABLE                 *
*        D4    IS THE FORTH DIMESNION OF THE VARIABLE                 *
*        D5    IS THE FIFTH DIMENSION OF THE VARIABLE                 *
*        D6    IS THE SIXTH DIMENSION OF THE VARIABLE                 *
*        D7    IS THE SEVENTH DIMENSION OF THE VARIABLE               *
*                                                                     *
* ONLY THOSE DIMENSIONS OF A VARIABLE THAT APPLY WILL APPEAR.         *
*                     FOR EXAMPLE                                     *
* IF A VARIABLE HAS ONLY 2 DIMENSIONS THEN ONLY D1 AND D2             *
* WOULD BE PRESENT IN THE CALL.                                       *
*                                                                     *
* IF A VARIABLE HAS NO DIMENSION THEN NONE OF THE DIMENSION           *
* ARGUMENTS IN THE CALL WOULD APPEAR                                  *
*                                                                     *
*  THE APPROPRIATE ARGUMENTS FOR OTHER VARIABLES MAY                  *
*  APPEAR AFTER EACH OTHER IN THE CALL                                *
*                                                                     *
*                                                                     *
* AS MANY CALL STATEMENTS AS NEEDED MAY APPEAR IN THE PROGRAM.        *
*                                                                     *
* THE CALL STATEMENTS ARE NORMALLY THE FIRST STATEMENTS IN THE        *
* PROGRAM.  THIS IS NOT A REQUIREMENT. ALL THAT IS NECESSARY          *
* IS THAT THE CALL STATEMENTS BE  EXECUTED BEFORE A FORTRAN           *
* ABEND CONDITION                                                     *
*   THE MINIMUM NUMBER OF ARGUMENTS NEEDED FOR A VARIABLE             *
*   IS 2.                                                             *
*                                                                     *
*   FOR AN UNDIMENSIONED VARIABLE THAT IS THE STANDARD LENGTH AND     *
*   TYPE ONLY THE EBDIC NAME AND THE VARIABLE NEED BE IN THE          *
*   ARGUMENTS OF THE CALL TO TERMON                                   *
*                                                                     *
*                                                                     *
*                                                                     *
*                                                                     *
*        EXAMPLE 1                                                    *
*                                                                     *
*        CALL TERMON('A',A,2,4)                                       *
*                                                                     *
*        THE VALUES OF THE REAL VARIABLE A WILL BE DISPLAYED          *
*        ON DEBUGOUT IF AN ABEND CONDITION OCCURS.                    *
*        A IS A 2 BY 4 ARRAY (DIMENSION A(2,4))                       *
*                                                                     *
*        EXAMPLE 2                                                    *
*                                                                     *
*        CALL TERMON('ABCDEF',ABCDEF,4,5,6,3,4,7,9,'JJ',JJ,5,5,3)     *
*                                                                     *
*        THE VALUES OF THE REAL VARIABLE ABCDEF WILL BE DISPLAYED     *
*        ON DEBUGOUT IF AN ABEND CONDITION OCCURS.  ABCDEF IS A 7     *
*        DIMENSION ARRAY ( DIMENSION(4,5,6,3,4,7,9))                  *
*        AND THE VALUES OF THE INTEGER VARIABLE JJ WILL BE            *
*        DISPLAYED IF AN ABEND CONDITION OCCURS.  JJ IS A 3           *
*        DIMENSION VARIABLE   (DIMENSION JJ(5,5,3))                   *
*                                                                     *
*                                                                     *
*                                                                     *
*        EXAMPLE 3                                                    *
*        CALL TERMON('*','ABX',ABX,'/'.'IQ',IQ,3)                     *
*                                                                     *
*        IN THIS EXAMPLE THE VALUES OF INTEGER  ABX ( A TYPE          *
*        STATEMENT MADE IT INTEGER) WILL BE DISPLAYED. ABX IS NOT     *
*        DIMENSIONED.                                                 *
*        AND THE VALUES OF THE REAL VARIABLES IQ ( A TYPE             *
*        STATEMNT MADE IT REAL) WILL BE DISPLAYED. IQ HAS             *
*        DIMENSION FOR A SINGLE SUBSCRIPT. (DIMENSION IQ(3))          *
*                                                                     *
*        EXAMPLE 4                                                    *
*                                                                     *
*        CALL TERMON('-','XX',XX,9,8,'-','*','KA',KA,5,6,7)           *
*                                                                     *
*        IN THIS EXAMPLE THE VALUES OF REAL VARIABLES XX              *
*        (A TYPE STATEMENT MADE IT OPTIONAL LENGTH OF 8)              *
*        ARE DISPLAYED ON DEBUGOUT IF AN ABEND CONDITION OCCURED      *
*        AND THE VALUES OF REAL VARIABLE KA ( A TYPE STETEMENT        *
*        MADE IT REAL AND OPTIONAL LENGTH OF 8)                       *
*        WILL BE DISPLAYED ON DEBUGOUT IF AN ABEND CONDITION          *
*        OCCURS.                                                      *
*        KA WAS DIMENSIONED AS FOLLOWS                                *
*        DIMENSION KA(5,6,6)                                          *
*                                                                     *
*        EXAMPLE 5                                                    *
*                                                                     *
*        CALL TERMON('AWW',AWW)                                       *
*                                                                     *
*        IN THIS EXAMPLE THE VALUE OF VARIABLE AWW WILL BE            *
*        DISPLAYED ON DEBUGOUT IF AN ABEND CONDITION OCCURRED         *
*        VARIABLE AWW IS NOT DIMENSIONED                              *
*                                                                     *
*        EXAMPLE 6                                                    *
*                                                                     *
*        CALL TERMON('ZZZZZZ01',ZZZZZZ,2000)                          *
*                                                                     *
*        IN THIS EXAMPLE VAIRABLE ZZZZZZ WHICH HAS A DEMINSION OF     *
*        2000 WILL BE DISPLAYED ON DEBUGOUT IF AN ABEND  OCCURS       *
*                                                                     *
*        NOTE THAT THE EBDIC NAME IS ZZZZZZ01 NOT ZZZZZZ              *
*                                                                     *
*        THIS WAS USED BECAUSE THE ZZZZZZ WAS IN THE FIRST            *
*        SUBROUTINE AND A VARIABLE OF THE SAME NAME NAME WAS IN       *
*        THE MAIN PROGRAM.   01 WAS CHOSEN BY THE PROGRAMMER          *
*        SO THE PROGRAMMER CAN TELL WHICH VARIABLE IS BEING           *
*        DISPLAYED ON DEBUGOUT IF BOTH VARIABLES ARE SELECTED         *
*        TO BE PRINTED ON DEBUGOUT IF AN ABEND CONDITION OCCURS       *
*        THE 01 WAS CHOSEN BY THE PROGRAMMER. IT COULD HAVE BEEN      *
*        0A OR ANYTHING ELSE  SO LONG AS THE NUMBER OF CHARACTERS     *
*        BETWEEN THE QUOTE MARKS IS 8 OR LESS.                        *
*                                                                     *
*        AS VARIABLES NAMES CAN NOT EXCEED 6 CHARACTERS 2 CHARACTERS  *
*        ARE ALWAYS AVAILABLE FOR THE PROGRAMMERS USE. IF THE VARIABLE*
*        NAME WAS LESS THAN 6 CHARACTERS THE THE PROGRAMMER HAS MORE  *
*        CHARACTERS TO USE WITH THE VARIABLE NAME IF IT WILL HELP     *
*        IDENTIFY THE VARIABLE.                                       *
*                                                                     *
*********PLEASE NOTE  *************************************************
**                                                                   **
**       THE VARIABLE NAME THAT FOLLOWS THE NAME IN QUOTES MUST BE   **
**       THE EXACT VARIABLE NAME THAT IS USED IN THE PROGRAM         **
**                                                                   **
***********************************************************************
         EJECT
         PRINT OFF     DON'T PRINT MACRO DEFINATIONS
         MACRO
&NAME    STARTIT
&NAME    START
R0       EQU   0             SET UP REGISTER EQUATES
R1       EQU   1
R2       EQU   2
R3       EQU   3
R4       EQU   4
R5       EQU   5
R6       EQU   6
R7       EQU   7
R8       EQU   8
R9       EQU   9
R10      EQU   10
R11      EQU   11
R12      EQU   12
R13      EQU   13
R14      EQU   14
R15      EQU   15
         EJECT
         USING *,R12         USE REGISTER 12 AS THE BASE REGISTER
         STM   R14,R12,12(R13)  PERFORM STANDARD SAVE IN CALLERS SAVEAR
         LR    R12,R15       SET BASE NOW
         LR    R15,R13       SAVE CALLERS SAVE AREA ADDRESS TEMPORARY
         CNOP  0,4           GET ON A FULL WORD BOUNDRY
         BAL   R13,PAST&SYSNDX GO PAST SAVE AREA
         DC    18F'0'        THIS IS THE SAVE AREA FOR THIS PROGRAM
         DC    C'SAVEAREA'   SO WE CAN FIND IT IN A DUMP
PARM&SYSNDX DC    F'0'       ADDRESS OF THE ADDRESSES OF THE PARMS
         DC    C'PARMADDR'   SO WE CAN FIND IT IN A DUMP
         CNOP  0,4           GET ON WORLD BOUNDRY EVEN IF NOT NEEDED
PAST&SYSNDX  LA   R13,0(R13) CLEAR HY BYTE
         ST    R13,8(R15)    SAVE NEW SAVE AREA ADDR IN OLD SAVE AREA
         LA    R15,0(R15)    CLEAR HY BYTE
         ST    R15,4(R13)    STORE     OLD ASVE ADDR IN NEW SAVE ADDR
         ST    R1,PARM&SYSNDX SAVE THE FIRST PARM ADDRESS
         EJECT
* SET MOST REGESTERS TO ZERO  TO MAKE DEBUGGING LESS OF A PROBLEM
         SR    R0,R0
         SR    R2,R2
         SR    R3,R3
         SR    R4,R4
         SR    R5,R5
         SR    R6,R6
         SR    R7,R7
         SR    R8,R8
         SR    R9,R9
         SR    R10,R10
         SR    R11,R11
         SR    R14,R14
         SR    R15,R15
         MEND
         EJECT
         MACRO
&NAME    ENDIT
&NAME    L     R13,4(R13)    GET CALLERS SAVE AREA ADDRESS
         LM    R14,R12,12(R13)  RESTORE RGEISTERS AS THEY WERE IN CALL
         SR    R15,R15       SET REG 15 TO ZERO TO SAY GOOD
         MVI   12(R13),X'FF' SET DONE FLAG
         BR    R14           GO BACK TO CALLER
         MEND
         EJECT
         MACRO
&NAME    GET50N2
&NAME    ST    R1,SAV1&SYSNDX
         GETMAIN    R,LV=56
         LR    R2,R1         GET THE ADDRESS OF THE AREA GOT IN REG 2
         MVI   0(R2),0       CLEAR BYTE 1
         MVC   1(49,R2),0(R2) ZERO OUT THE OTHER 49 BYTES
         L     R1,LASTGETM
         LTR   R1,R1
         BZ    DDD&SYSNDX
         ST    R2,52(R1)     SAVE THIS ADDRESS IN LAST GETMAIN
DDD&SYSNDX L   R1,SAV1&SYSNDX
         ST    R2,LASTGETM
         MVC   X'32'(2,R2),=C'NX'  DO THIS FOR DEBUGGING
         MVC   X'34'(4,R2),=F'0'   CLEAR NEXT ADDRESS
         B     PST1&SYSNDX
SAV1&SYSNDX    DC  F'0'
PST1&SYSNDX EQU *
         MEND
         EJECT
         MACRO
&NAME UPDATEPR
&NAME    L     R1,CURPARM    GET ADDRESS OF CURRENT PARM
         LA    R1,4(R1)      GO TO NEXT PARM
         ST    R1,CURPARM    SAVE THE CURRENT PARM ADDRESS
         L     R3,0(R1)      GET THE ADDRESS OT REG 3
* R1 HAS THE ADDRESS OF THE LIST OF PARM ADDRESS
         MEND
         EJECT
         PRINT ON,NOGEN
TERMON   STARTIT            START OF THE PROGRAM HERE
         EJECT
REALSTAR LR    R11,R1        SAVE R1
         OPEN  (OUTPUT,OUTPUT) OPEN FOR OUTPUT DDNAME DEGUBOUT
         TM    OUTPUT+X'30',X'10'  DO WE HAVE A DD CARD
         BZ    END           GO AND DO NOTHING IF NO DD CARD
         SPACE 1
         LTR   R1,R11        DO WE HAVE A PARM
         BZ    ERROR1        BRANCH IF NOT TELL PROGRAMMER OF ERROR
         SPACE 1
         L     R3,0(R1)      GET ADDRESS OF EBDIC NAME OF VARIABLE
         ST    R1,CURPARM    SAVE IT FOR LATTER USE
         SPACE 3
NEXTCASE L     R1,PARMSET
         LA    R1,1(R1)      COUNT PARMS IN THIS CALL
         ST    R1,PARMSET
         SPACE 4
******************************************************
******    REG 3 HAS THE POINTER TO THE CURRENT PARM **
******************************************************
GETMORE  GET50N2             GET ME SOME CORE FOR THIS PARM GROUP
         CLC   FIRSTGET(4),=F'0' IS THIS THE FIRST GETMAIN
         BNE   QX            GO IF NO
         ST    R2,FIRSTGET   SAVE ADDRESS OF THE AREA GOT
QX       LR    R11,R2        LOAD THE BASE WITH THE ADDRESS WE GOT
         USING TABLE,R11     TELL THE ASSEMBLER
         CLI   0(R3),C'-'    CHECK FIRST PARM FOR OPTIONAL LENGTH
         BNE   NOTMIN        BRANCH IF NOT OPTIONAL LENGTH
         SPACE 1
         MVI   OPTIONAL,X'FF' SET FLAG FOR OPTIONAL LENGTH
         UPDATEPR
NOTMIN   CLI   0(R3),C'*'    IS IT * FOR INTEGER WITH REAL NAME
         BNE   TRYSL         NOT * FOR INT FOR REALTRY / FORREAL AS INT
         SPACE 1
         MVI   TYPE,C'*'     SET INTG  FLAG
         UPDATEPR
         B     NOTCHANG      DONT TEST ANY MORE
         SPACE 3
TRYSL    CLI   0(R3),C'/'    IS IT SLASH FOR REAL AS INTG NAME
         BNE   NOTCHANG      BRANCH IF NOT AS THERE IS NO CHANGE OF TYP
         SPACE 1
         MVI   TYPE,C'/'     SET REAL AS INTEGER NAME FLAG
         UPDATEPR
***** NOW CHECK FOR ERRORS IN THE NAME OF THE VARIABLE ************
NOTCHANG CLI   0(R3),C'A'    CHECK SMALLEST VARIABLE NAME
         BL    ERROR1        FIRST CHARACTER OF NAME IS BAD
         SPACE 1
         CLI   0(R3),C'Z'    IS IT BIGGER THAN Z PROBLEM PROBLEM
         BH    ERROR1        BRANCH IF IT IS
         SPACE 1
****** IT MUST BE GOOD SO MOVE IT IN *****************************
         MVC   NAME(8),0(R3) MOVE IN THE VARIABLE NAME HERE
         SPACE 4
         CLI   TYPE,0        HAVE WE CHANGED THE TYPE
         BNE   CONT1         BRANCH  IF WE ALREADY KNOW THE TYPE
         SPACE 1
         CLI   0(R3),C'I'    I TO N ARE INTEGERS
         BL    REAL1         MUST BE A REAL NAME
         SPACE 1
         CLI   0(R3),C'O'    O AND ABOVE ARE REAL
         BL    INTG          IF WE BRANCH IT IS INTEGER
         SPACE 1
REAL1    MVI   TYPE,C'/'     SET REAL FLAG
         B     CONT1         GO GO BYPASS
         SPACE 3
INTG     MVI   TYPE,C'*'     SET INTEGER FLAG  IN TYPE
CONT1    UPDATEPR
         LTR   R3,R3
         BNM   NNOTLAST
         SPACE 1
         MVI   LASTPARM,X'FF' SET LAST PARM FLAG
         XC    DIM1(36),DIM1 THIS SHOULD CLEAR THE AREA DIM1
         ST    R3,ADDRESS    SAVE THE VARIABLE ADDEESS
         B     CALLEND       THIS VARIABLE HAS NOT DIMENSIONS
         SPACE 3
NNOTLAST ST    R3,ADDRESS    SAVE ADDRESS OF VARIABLE
         SPACE 4
********** NOW FIND DIMENSIONS ***************************************
         UPDATEPR
         LTR   R3,R3         LAST PARM
         BNM   NOTLAST3      GO IF NO
         SPACE 1
         MVI   LASTPARM,X'FF' SET LAST PARM FLAG
***********************************************
*    IF LAST PARM HERE IT MUST BE DIMENSION   *
***********************************************
NOTLAST3 EQU   *
         CLI   0(R3),C'-'    IS IT MINUS FOR OPT LENGTH
         BE    NEXTCASE      GO FOR ANOTHER SET OF ARGS
         SPACE 1
         CLI   0(R3),C'*'    IS IT * FOR NAME SWITCH
         BE    NEXTCASE      GO IF YES
         SPACE 1
         CLI   0(R3),C'/'    IS IT / FOR NAME SWITCH
         BE    NEXTCASE      GO IF YES
         SPACE 1
         CLI   0(R3),C'A'    IS IT A LETTER
         BNL   NEXTCASE      GO IF IT IS A NAME
         SPACE 1
         LA    R7,0          COUNT DIMENSIONS
         LA    R6,0          COUNT WORDS TO PRINT
****************************************************************
*   THERE CAN BE 7 PARMS HERE FOR DIMENSIONS                   *
****************************************************************
         LA    R8,8          CHECK NUMBER OF DIMENSION 7 MAX
         LA    R9,DIM1       GET THE ADDRESS IN REGISTER 9
COMP9    CLI   0(R3),0       IS HIGH BYTE 0
         BE    GOODMIN       BRANCH IF A GOOD NUMBER FOR DIMENSION
         SPACE 1
         B     NEXTCASE
         SPACE  5
GOODMIN  BCTR  R8,0          REDUCE BY 1
         LTR   R8,R8         IS IT ZERO
         BZ    ERROR1        TO MANY DIMENSIONS TELL PROGRAMMER
         SPACE 1
         MVC   0(4,R9),0(R3) MOVE IN NUMBER OF DIMENSION
         LA    R7,1(R7)      COUNT DIMENSIONS
         ST    R7,DIMNUM     STORE COUNTED DIMENSIONS
         A     R6,0(R3)      COUNT TOTAL DIMINSIONS VALUES
         ST    R6,TOTDIM     SAVE IT IN DSECT
         CLI   LASTPARM,X'FF' IS THIS THE LAST
         BE    CALLEND       GO IF YES
         SPACE 1
         LA    R9,4(R9)      GO TO NEXT DIMENSION
         UPDATEPR
         LTR   R3,R3         LAST PARM
         BNM   PASTSET       GO IF NO
         SPACE 1
         MVI   LASTPARM,X'FF' SET FLAG
PASTSET  B     COMP9         GET NEXT DIMENSION
         SPACE 4
CALLEND  MVI   LASTPARM,0    RESET FLAG FOR NEXT CALL
         CLI   STAEOK,X'FF'  HAVE WE BEEN HERE BEFORE
         BE    END           GO IF YES
         SPACE 1
         L     R1,16         GET CVT ADDRESS IN REG 1
         L     R1,0(R1)      GET DOUBLE WORD ADDRESS
         L     R1,4(R1)      GET MY TCB ADDRESS
         ST    R1,TCBADDR    SAVE  TCB ADDRESS
         L     R1,160(R1)    GET STAE CONTROL BLOCK ADDRESS
         LA    R1,0(R1)      CLEAR HI ORDER BYTE
         L     R1,4(R1)      GET USERS STAE EXIT ADDRESS
         LA    R1,0(R1)      CLEAR HI ORDER BYTE
         ST    R1,GOTOSTAE   SAVE IT FOR LATER USE
         SPACE 4
**************************************************************
*       KILL PREVIOUS STAE THEN ISSUE MY STAE                *
**************************************************************
         STAE 0              CANCEL CURRENT STAE
**********************************************************************
*  THIS SPIE FEATURE WILL BE USED IN LATER RELEASES OF THE PROGRAM   *
*        SPIE  SPIEXIT,(9,12,13,15)
**********************************************************************
         SPACE 5
         STAE  EXITADDR,PURGE=QUIESCE       ISSUE STAE FOR ME
         MVI   STAEOK,X'FF'
         B     END           GO TO EXIT TO CALLER
         SPACE 3
****************************************************************
ERROR1   PUT   OUTPUT,BADPARM SAY BAD PARM THEN EXIT
END      ENDIT GO TO CALLER
         EJECT
*******************************************************************
* ENTER HERE ON ABEND IN FORTRAN  OR ANYTHING ELSE FOR THAT MATTER*
* VARIABLES TO BE DISPLAYED ARE IN A GETMAINED AREA.              *
* THESE AREAS ARE CHAINED TOGETHER. THE FIRST IS AT               *
* LOCATION FIRSTGET                                               *
* AN * IS FOR A INTIGER    A / IF FOR A REAL NUMBER               *
*******************************************************************
EXITADDR DS    0F
         USING *,R15         SET UP BASE REGISTER    TEMPORARYLY
         STM   R14,R12,12(R13) SAVE IN CALLERS SAVE AREA
         STM   R0,R15,REG0TO15 SAVE IN MY AREA FOR USE
         ST    R13,SAVEAREA+4 SAVE OLD SAVE AREA ADDRESS IN NEW
         LA    R14,SAVEAREA   GET  MY SAVE AREA ADDRESS
         ST    R14,8(R13)     SAVE IT IN CALLERS SAVE AREA FOR CHAINING
         LR    R13,R14        SET THE BASE (R13) HERE
         B     PASTSAVE       GO AROUND SAVE AREA
         SPACE 3
         DROP  15
         USING SAVEAREA,13,12 USE 2 BASE REGISTERS
SAVEAREA DC    20F'0'         THE REAL SAVE AREA
REG0TO15 DC    16F'0'         MY USE AREA
PASTSAVE LA    R12,4095(R13)  SECOND BASE REGISTER
         LA    R12,1(R12)     MAKE IT 4096 MORE THAN R13
         EJECT
*********************************************************************
*   *************************************************************   *
*        **************************************************         *
*               **************************************              *
*                       *************************                   *
*                            **************                         *
*                                 **                                *
*   CHANGE THE NEXT INSTRUCTION TO A NOP TO GET MORE INFORMATION    *
*   ABOUT THE ABEND THAT HAS OCCURED                                *
            SPACE  3
******   B     SKIPALL       BYPASS THIS NEXT SECTION OF CODE
            SPACE  3
*   THIS BYPASSED CODE HAS NOT BEEN CHECKED OUT ON A 303X MACHINE   *
*   SO WE CAN NOT RELEASE IT FOR GENERAL USE.                       *
*   HOWEVER THE USER OF THIS PROGRAM CAN CHANGE THE BRANCH TO NOP   *
*   AND TRY TRY THIS NEW FEATURE OF THE PROGRAM IF DESIRED.         *
*                                                                   *
*  ON     ENTRY TO THIS ROUTINE R1 POINTS TO STAE WORK AREA (SDWA)  *
*  SWDA+ X'18'  IS REGISTER 0   THUR REGISTER 15                    *
*                                 **                                *
*                               ********                            *
*                            **************                         *
*                       *************************                   *
*               **************************************              *
*        **************************************************         *
*   *************************************************************   *
*********************************************************************
         EJECT
         MVC   LOWER(8),140  IF WE ARE IN EC MODE SAVE THIS
         L     R2,TCBADDR    GET TCB ADDRESS
         L     R2,44(R2)     GET LAST CDE ADDRESS
LOOKMORE LR    R3,R2
         L     R2,0(R2)      GET NEXT CDE ADDRESS BACKWARDS
         LTR   R2,R2         IS IT FIRST CDE -THE REAL PROGRAM
         BNZ   LOOKMORE      GO IF NOT
         SPACE 1
         L     R3,20(R3)     GET EXTENT LIST ADDRESS AT +20
         LA    R3,0(R3)      CLEAR HI BYTE
         L     R4,12(R3)     GET LOAD POINTAT +12 OF EXTENT
         LA    R4,0(R4)      CLEAR HI
         ST    R4,LOADAT     SAVE IT
         L     R1,REG0TO15+4 GET REGISTER 1
         SR    R2,R2         CLEAR REG 2
         IC    R2,12(R1)     GET LENGTH OF LAST INSTRUCTION
         SRL   R2,6          LOOSE JUNK
         SLL   R2,1          TIMES 2 FOR BYTES
         L     R5,12(R1)     GET ABEND ADDRESS
         LA    R5,0(R5)      CLEAR HI
*        SR    R5,R2         GO BACK TO BAD INSTRUCTION
         ST    R5,ABENDLOC   SAVE ABEND ADDRESS
         SR    R5,R4         GET RELATIVE ADRESS
         ST    R5,RELABEND   SAVE IT
         L     R6,4(R1)      GET COMPLETION CODE
         SLL   R6,8
         SRL   R6,20         PUT CODE IN RIGHT MOST BYTE OF WORD
         ST    R6,COMPCODE   SAVE IT
         L     R1,ABENDLOC   SAVE THE ABENDING INSTURCTION
         MVC   BADINST(6),0(R1) MOVE FAILING INSTRUCION TO MY AREA
****************  MOVE IN AND PRINT LINE ONE OF MESSAGES  ***********
         MVC   PRINTLIN(L'MSAGE1),MSAGE1   MOVE IN INST THAT FAILED
         UNPK  PRINTLIN+L'MSAGE1+3(7),RELABEND+1(4)
         TR    PRINTLIN+L'MSAGE1+3(7),TRANS
         MVI   PRINTLIN+L'MSAGE1+9,C' ' BLANK OUT JUNK CHARACTER
         MVC   PRINTLIN+70(L'ABSOLUTE),ABSOLUTE
         UNPK  PRINTLIN+90(7),ABENDLOC+1(4)
         TR    PRINTLIN+90(7),TRANS
         MVI   PRINTLIN+96,C' ' BLANK OUT JUNK CHARACTER
         PUT   OUTPUT,PRINTCC PRINT IT
         MVI   PRINTCC,C' '   BLANK OUT PRINTLINE
         MVC   PRINTCC+1(120),PRINTCC
         PUT   OUTPUT,PRINTCC    PRINT IT
**************   FIND WHICH INSTRUCTION FAILED  *******************
**************   THEN PRINT LINE 2 OF MESSAGE   *******************
         MVC   PRINTLIN(L'MSAGE2),MSAGE2
         MVC   PRINTLIN+70(L'MSAGE3),MSAGE3
         MVC   PRINTLIN+90(L'MSAGE6),MSAGE6
         LA    R4,INSTEND-INSTABLE  GET TABLE LENGTH
         SRL   R4,2          DIVIDE BY 4 TO GET NUMBER OF INSTS
         LA    R2,INSTABLE   START THE SEARCH OF TABLE
COMPAGAN CLC   BADINST(1),0(R2)   IS THIS THE INSTRUCTION
         BE    GOTIT         GO IF YES
         SPACE 1
         LA    R2,4(R2)      GO TO NEXT INSTRUCTIONM
         BCT   R4,COMPAGAN   REPEAT UNTILL ALL INST COMPARED
         SPACE 1
         B     SKIPALL       THIS INSTRUCTION IS IN OUR TABLE
         SPACE 3
GOTIT    CLI   0(R2),X'92'   IS IT SI INSTRUCTION
         BL    NOTSI
         SPACE 1
         CLI   0(R2),X'97'
         BH    NOTSI
         SPACE 1
         MVI   SIFLAG,X'FF'  SET FLAG
NOTSI    L     R7,0(R2)      GET MESSAGE ADDRESS
         LA    R7,0(R7)      CLEAR HI ORDER BYTE
         TM    0(R7),X'C0'   ROM/TO/WITH?
         BZ    MOVEFROM
         SPACE 1
         TM    0(R7),X'80'
         BO    MOVEINTO
         SPACE 1
         MVC   PRINTLIN+84(4),WITH
         B     PASTALL       IT IS NOW SET TO CORRECT WORD
         SPACE 3
MOVEFROM MVC   PRINTLIN+84(4),FROM
         B     PASTALL
         SPACE 1
MOVEINTO MVC   PRINTLIN+84(4),INTO
PASTALL  NI    0(R7),X'3F'   LOOSE FLAG BITS FROM COUNT
         SR    R8,R8
         IC    R8,0(R7)      GET COUNT
         BCTR  R8,0          REDUCE BY ONE FOR MOVE
         STC   R8,MVMSG+1    PUT IT IN THE MOVE
MVMSG    MVC   PRINTLIN+50,1(R7) MOVE IN NAME OF OPERATION
* IF IT IS A RX INSTRUCTION DO THE FOLLOWING
* BUT SKIP IT IF IT IS AN SI INSTRUCTION
         CLI   SIFLAG,X'FF'  IS IT A  SI INSTRUCTION
         BE    INDEXZ        GO IF YES
         SPACE 1
         SR    R3,R3
         IC    R3,BADINST+1  GET THE FROM/TO REGISTER
         SRL   R3,4          LOOSE OTHER PART
         CVD   R3,WORK1      MAKE IT DECIMAL FOR PRINTING
         UNPK  TEMP1(4),WORK1+6(3)
         CLI   TEMP1,C'0'    WE WONT PRINT LEADING ZEROS
         BNE   ISNUMQ
         SPACE 1
         MVI   TEMP1,C' '    MAKE IT BLANK
ISNUMQ   MVC   SOMEBUF(2),TEMP1 MOVE IT TO PRINT AREA
         MVC   PRINTLIN+81(2),SOMEBUF
         SR    R5,R5
         IC    R3,BADINST+1  NOW GET THE INDEX
         N     R3,=X'0000000F'  LOOSE BAD PART
         LTR   R3,R3         WAS THERE AN INDEX
         BZ    INDEXZ        GO IF NOT
         SPACE 1
         SLL   R3,2          INDEX REGISTER NUMBER TIMES 4
         L     R6,REG0TO15+4 LETS GET THE VALUE OF THE INDEX
         LA    R6,X'18'(R6)  GO TO REGISTER ZERO LOCATION
         AR    R6,R3         R6 NOW HAS ADDRESS OF REGISTER CONTENTS
         A     R5,0(R6)      WE ARE COMPUTING THE ADDRESS OF TO/FROM
*  START  AT INDEXZ FOR SI INSTRUCTIONS
INDEXZ   SR    R3,R3
         IC    R3,BADINST+2  NOW GET THE BASE
         SRL   R3,4          LOOSE THE ADDRESS PART
         LTR   R3,R3         IS THERE A BASE
         BZ    BZX           GO IF NO
         SPACE 1
         SLL   R3,2
         L     R6,REG0TO15+4 GET SWDA WORK AREA ADDRESS
         LA    R6,X'18'(R6)  GO TO REGISTER ZERO LOCATION
         AR    R6,R3         PREPARE TO GET THE REGISTER CONTENTS
         A     R5,0(R6)      KEEP COMPUTING  FROM/TO ADDRESS
BZX      ST    R5,BADBADL    SAVE IT FOR DEBUGGING
         MVC   TEMP1(2),BADINST+2
         NI    TEMP1,X'0F'   LOOSE NON ADDRESS PART
         AH    R5,TEMP1      ADD IN ADDRESS
         ST    R5,BADLOC     SAVE IT
         UNPK  PRINTLIN+100(7),BADLOC+1(4)
         TR    PRINTLIN+100(7),TRANS
         MVI   PRINTLIN+106,C' '   LOOSE JUNK BYTE
         UNPK  PRINTLIN+6(3),COMPCODE+3(2) PUT IN THE ABEND CODE
         TR    PRINTLIN+6(3),TRANS
         MVI   PRINTLIN+8,C' '    BLANK OUT JUNK BYTE
         PUT   OUTPUT,PRINTCC
         MVI   PRINTCC,C' '   BLANK OUT PRINTLINE
         MVC   PRINTCC+1(120),PRINTCC
         PUT   OUTPUT,PRINTCC
SKIPALL  EQU   *
         MVI   PRINTLIN,C' '
         MVC   PRINTLIN+1(119),PRINTLIN
         MVC   PRINTLIN(L'STMSG),STMSG
         PUT   OUTPUT,PRINTCC
         MVI   PRINTLIN,C' '
         MVC   PRINTLIN+1(119),PRINTLIN
         L     R11,FIRSTGET  SO WE CAN USE IT AS A BASE
         USING TABLE,R11     TELL ASSEMBLER R11 IS A BASE NOW
         EJECT
**********************************************************************
* NOW PRINT OUT SUBSCRIPTS                                           *
**********************************************************************
*        R9    HAS POINTER TO CURRENT POSITION IN THE PRINT LINE     *
*        R8    HAS NUMBER OF DIMENSIONS 1-2-3-4-5-6-7                *
*        R7    POINTS TO THE CURRENT NUMBER TO CONVERT TO A SUBSCRIPT*
**********************************************************************
         SPACE 4
LOOPIT   LA    R15,NAME      GET VARIABLE NAME
         BAL   R14,HOWMANY   GO SEE NUMBER OF BYTES IN NAME
         SPACE 1
         STC   R1,MV1+1      STORE IN MOVE BELOW
MV1      MVC   PRINTLIN(0),NAME  NAME IS ALWAYS LEFT JUSTIFIED
         LA    R1,1(R1)      GET REAL BYTE COUNT
         LA    R2,PRINTLIN
         AR    R1,R2         FIND FIST BLANK
         LR    R9,R1         R9 NOW HAS LOC OF FIRST BLANK IN LINE
         CLC   DIM1(4),=F'0' DID WE HAVE DIMENSIONS
         BE    NOTDIMM       GO IF NO
         SPACE 1
         MVI   0(R9),C'('    MOVE IN LEFT PAREN
         LA    R9,1(R9)      GET CURRENT FIRST BLANK
         ST    R9,STARTCLR   SAVE ADDRESS FOR PRINT CLEAR ROUTINE
         SPACE 3
*****************************************************************
* RESET CURRENT SUBSCRIPT POINTER TO FIRST SUBSCRIPT            *
* AND RESET THE NUMBER OF DIMENSIONS                            *
*****************************************************************
RESET    LA    R7,WORKDIM1
         L     R8,DIMNUM      GET NUMBER OF DIMENSIONS
         SPACE 2
GETSUB   L     R15,0(R7)     GET THE SUBSCRIPT
         BAL   R14,MAKEINTG  GO CONVERT IT FOR PRINTING
         SPACE 2
         STC   R1,MVC8+1     STORE IT IN MOVE BELOW
MVC8     MVC   0(0,R9),0(R15) MOVE IT TO PRINT LINE
         LA    R1,1(R1)      GET REAL BYTE COUNT
         AR    R9,R1         UP POINTER TO END OF LINE
         MVI   0(R9),C','    MOVE IN A COMMA
         LA    R9,1(R9)      GET TO FIRST BLANK IN PRINTLINE
         LA    R7,4(R7)      GO TO NEXT SUBSCRIPT ADDRESS
         BCT   R8,GETSUB     GO GET REST OF SUBSCRIPTS IF ANY
         SPACE 2
*****************************************************************
* WE MUST HAVE ALL OF THE SUBSCRIPTS OF THE NUMBER              *
* NOW BACK UP THE LINE POINTER AND WIPE OUT THE LAST COMMA      *
*  AND INSERT )=                                                *
*****************************************************************
         BCTR  R9,0          REDUCE BY ONE
NOTDIMM  MVC   0(2,R9),=C')='
         CLC   DIM1(4),=F'0' DO WE HAVE DIMENSIONS
         BNE   AVOID         GO IF YES
         SPACE 1
         MVI    0(R9),C' '   BLANK LEFT PARM
AVOID    LA    R9,2(R9)
*************************************************
* NOW DECIDE IF THE NUMBER IS REAL OF INTEGER   *
* THEN CONVERT IT AND PRINT IT                  *
*************************************************
         CLI   TYPE,C'*'     IS IT INTEGER
         BE    CONVINTG      GO MAKE AN INTEGER EBDIC
         SPACE 1
         CLI   TYPE,C'/'     IS IT REAL
         BE    CONVREAL      GO CONVERT A REAL
         SPACE 1
         ABEND 123,DUMP      IF WE GOT HERE WE ARE IN TROUBLE TROUBLE
         SPACE 4
CONVREAL CLI   OPTIONAL,X'FF' OPTIONAL LENGTH
         BNE   USE4X         GO USE DEFAULT
         SPACE 1
         LA    R1,8          USE 8 BYTES PER WORD
STO2     ST    R1,LENGTH
         B     IIS
         SPACE 3
USE4X    LA    R1,4          USE DEFAULT OF 4 BYTES
         B     STO2
         SPACE 3
IIS      L     R1,ADDRESS    GET ADDTESS OF VARIABLE
         LE    R0,0(R1)      GET FLOATING NUMBER
         LTER  R0,R0         IS IT NEGATIVE
         BP    NOTNG         GO IF NOT
         SPACE 1
         MVI   REALNEG,X'FF' SET FLAG
NOTNG    STE   R0,NUMBER
         CALL  MAKFLT,(NUMBER,EBDNUM,EXP)
* UPON RETURN R15 HAS ADDRESS OF EBDIC NUMBER
         CLI   REALNEG,X'FF'
         BNE   NOT1          GO IF NOT NEGATIVE
         SPACE 1
         MVI   REALNEG,0     RESET FLAG
         MVI   0(R9),C'-'    MOVE IN NEG SIGN
         LA    R9,1(R9)      MOVE REST OVER 1
NOT1     MVI   0(R9),C'.'    MOVE IN PEROID
         MVC   1(6,R9),EBDNUM
         LA    R9,8(R9)      GET PAST
         MVI   0(R9),C'E'    FLOATING POINT NEED AN E
         LA    R9,1(R9)
         L     R15,EXP       GET EXPONT
         LTR   R15,R15       TEST IT
         BP    POS1          GO IF POSITIVE
         SPACE 1
         MVI   0(R9),C'-'    NOT POSITIVE MUST BE NEGATIVE OR TROUBLE
         LA    R9,1(R9)
POS1     CVD   R15,TEMP1      MAKE HEX DECIMAL
         UNPK  WORK1(3),TEMP1+6(2)
         OI    WORK1+2,X'F0'  MAKE IT PRINTABLE
         MVC   0(2,R9),WORK1+1
         B     PUT
         SPACE 3
CONVINTG CLI   OPTIONAL,X'FF'
         BNE   USE4           GO IF DEFAULT LENGTH
         SPACE 1
         LA    R1,2           USE INTEGER OPTIONAL LENGTH
STO1     ST    R1,LENGTH      SAVE LENGTH
         B     ISET
         SPACE 3
USE4     LA    R1,4          GET DEFAULT LENGTH
         B     STO1
         SPACE 3
ISET     L     R14,ADDRESS   GET ADDRESS OF VARIABLE
         LH    R15,0(R14)    GET THE VALUE OF THE INTEGER
         C     R1,=F'4'      IS IT 4 BYTES LONG
         BNE   OKUSEIT       GO IF NOT
         SPACE 1
         L     R15,0(R14)
OKUSEIT  BAL   R14,MAKEINTG  GO MAKE IT EBDIC
         SPACE 1
         STC   R1,MVX+1      SAVE BYTE COUNT IN MOVE INSTRUCTION
MVX      MVC   0(0,R9),0(R15) MOVE IT TO PRINTLINE
         SPACE 9
PUT      L     R15,LINEONPG  GET LINES PER PAGE
***********************************************************************
*                                                                     *
*   COUNT LINES PER PAGE HERE                                         *
*                                                                     *
***********************************************************************
         S     R15,=F'1'     REDUCE BY ONE PAGECOUNT
         ST    R15,LINEONPG  SAVE NEW COUNTER
         BNZ   SAMEPAGE      GO IF PAGE NOT FULL
         SPACE 1
         MVI   PRINTCC,C'1'  SET TO EJECT
         MVC   LINEONPG(4),=F'50'  RESET LINE PER PAGE COUNT
SAMEPAGE PUT   OUTPUT,PRINTCC PRINT THE LINE
         MVI   PRINTCC,C' '  RESET TO SINGLE SPACE
         CLC   DIM1(4),=F'0' ANY DIMENSIONS
         BZ    ALLDONE       GO IF NONE
         SPACE 4
***********************************************************************
* FIRST CALUCLATE THE CORRECT NUMBER OF BYTES TO UP IT                *
* NOW UP THE ADDRESS OF THE NEXT VARIABLE TO PRINT                    *
***********************************************************************
         L     R1,ADDRESS
         A     R1,LENGTH     GET PROPER LENGTH
         ST    R1,ADDRESS    STORE ADDRESS OF NEXT BARIABLE
********* NOW CHECK THE FIRST DIMENSION TO SEE IF IF CAN BE UPED
         CLC   WORKDIM1(4),DIM1
         BE    TRYREST       DIMENSION 1 IS AT THE LIMIT IF BRANCH
         SPACE 1
         L     R2,WORKDIM1   UP DIMENSION 1
         A     R2,=F'1'      UP IT BY ONE
         ST    R2,WORKDIM1   STORE UPDATED COUNT
SETRE    LA    R1,PRINTLIN+120
         S     R1,STARTCLR
         BCTR  R1,0          REDUCE BY ONE
         STC   R1,MVCLEAR+1  PUT IT IN MOVE   BELOW
         L     R2,STARTCLR   GET ADDRESS TO START CLEAR
         MVI   0(R2),C' '    CLEAR FIRST BYTE
MVCLEAR  MVC   1(0,R2),0(R2) CLEAR REST OF LINE
         L     R9,STARTCLR
         B     RESET         GO DO REST OF FIRST DIMENSIONS
         SPACE 4
* **********************************************************
* THE FIRST DIMENSION IS AT IT LIMIT SO SOME DIMENSION     *
* MUST BE UPED TRY SECOND THEN THIRD THEN 4TH ETC          *
* **********************************************************
TRYREST  L     R8,DIMNUM     GET NUMBER OF DIMENSIONS
         BCTR  R8,0          REDUCE BY ONE WE TOOK CARE OF DIM1 BEFORE
         LTR   R8,R8         IS IT ZERO NOW
         BZ    JUSTONE       GO IF ONLY ONE DIMESNION
         SPACE 1
         LA    R3,DIM2       GET ADDRESS OF REST OF DIMESNIONS
************ START WITH DIMENSION 2 **************************
         LA    R2,WORKDIM2   GET WORKING DIMENSIONS2 TO START
COMPDIM  CLC   0(4,R2),0(R3) IS WORKDIMENSIONS AS BIG AS
**********REAL DIMENSION THAT IS IT REACHED ITS LIMIT YET ******
**********IF NOT WE CAN UP THE CURRENT DIMENSION ****************
         BL    CANUPIT       BRANCH IF LESS
         SPACE 1
         LA    R3,4(R3)      GET ADDRESS OF DIMENSION LIMIT
         LA    R2,4(R2)      GET ADDRESS OF WORKDIMENSION IN CASE
******* THERE IS ANOTHER DIMENSION WE CAN UP *********************
         BCT   R8,COMPDIM    GO COMPARE ANOTHER DIMESSION IF NOT PAST L
*********WE JUST RUN OUT OF DIMESNIONS TO UP SO WE ARE DONE
         B     ALLDONE
         SPACE 4
******** WHEN WE GET HERE R2 HAS THE DIMENSION THAT CAN BE UPED *****
CANUPIT  L     R1,0(R2)
         A     R1,=F'1'      +1
         ST    R1,0(R2)      STORE IT BACK IN WORKDIM
         LR    R15,R2        PREPARE TO RESET ALL PREVIOUS DIMENSIONS
****** GO RESET ALL PREVIOUS SUBSCRIPTS TO ONE *********************
         BAL   R14,SETSUB21
         SPACE 4
         B     SETRE         NOT GO GET SOME MORE NUMBERS
         SPACE 9
JUSTONE  EQU   *
ALLDONE  L     R1,NEXTABLE   GET NEXT VARIABLE TO PRINT
         LTR   R1,R1         IS THIS THE LAST VARIABLE
         BZ    EXITEXIT      GO IF YES
         SPACE 1
         LR    R11,R1        SET BASE FOR DSECT
         LA    R15,WORKDIM7+4
****** GO RESET ALL PREVIOUS SUBSCRIPTS TO ONE *********************
         BAL   R14,SETSUB21
         SPACE 1
         MVI   PRINTLIN,C' ' BLANK OUT THE LINE
         MVC   PRINTLIN+1(119),PRINTLIN
         L     R15,LINEONPG  GET LINE PER PAGE
         S     R15,=F'1'     REDUCE BY ONE
         ST    R15,LINEONPG  SAVE LINECOUNT
         BNZ   NOEJ          IS IT ZERO
         SPACE 1
         MVI   PRINTCC,C'1'  SET FOR EJECT TO TOP OF PAGE
         MVC   LINEONPG(4),=F'50'
NOEJ     PUT   OUTPUT,PRINTCC
         MVI   PRINTCC,C' '  SET TO BLANK
NOPR2    B     LOOPIT
         EJECT
******************************************************************
* R15 HAS NUMBER TO BE CONVERTED TO PRINTABLE INTIGER            *
* UPON RETURN R15 HAS ADDRESS OF CONVERTED NUMBER                *
* LEFT JUSTIFIED                                                 *
* R1 HAS THE BYTE COUNT-1                                        *
*******************************************************************
MAKEINTG DS    0H
         CVD   R15,WORK1     MAKE IT DECIMAL
         TM    WORK1+7,X'03' IS IT NEGATIVE
         BZ    ISPOS         FO IF IT IS POSITIVE
         SPACE 1
         MVI   INTGNEG,X'FF' SET TO NEGATIVE NUMBER
ISPOS    UNPK  WORK2(16),WORK1(8) PUT IN FXFXFX ETC
         OI    WORK2+15,X'F0'
         LTR   R15,R15       IS NUMBER ZERO
         BNZ   NONZ          GO IF NOT
         SPACE 1
         LA    R1,3          SET TO 4 BYTES OF ZERO
         LA    R15,WORK2     GET START OF NUMBER
         BR    R14
         SPACE  3
NONZ     LA    R15,WORK2
CLI1     CLI   0(R15),C'0'   IS IT LEADING ZERO
         BNE   FIRSTNON      GO WHEN NON LEADING ZERO FOUND
         SPACE 1
         LA    R15,1(R15)    GO TO NEXT CHARACTER TO FIND NONZERO
         B     CLI1          GO COMPARE SOME MORE
         SPACE  3
FIRSTNON LA    R1,0          START WITH 0 FOR A BYTE COUNT
CLI2     CLI   0(R15),C' '   ARE WE PAST THE GOOD INFO
         BE    THATALL       GO IF YESS
         SPACE 1
         LA    R1,1(R1)      COUNT GOOD BYTES
         LA    R15,1(R15)    GO TO NEXT BYTE
         B     CLI2          GO COMPARE SOME MORE
         SPACE  2
THATALL  SR    R15,R1        GET R15 TO FIRST GOOD NUMBER
         CLI   INTGNEG,0
         BE    POSINTG       GO IF IT IS NOT NEGATIVE
         SPACE 1
         BCTR  R15,0         REDUCE 15 BY ONE FOR - SIGN
         MVI   0(R15),C'-'   MOVE IN MINUS SIGN
         LA    R1,1(R1)      UP COUNT OF BYTES IN NUMBER
POSINTG  BCTR  R1,0          REDUCE FOR MOVE
         MVI   INTGNEG,0     RESET SWITCH TO ZERO
         BR    R14           GO TO CALLER
         EJECT
*****************************************************************
*   R15 HAS ADDRESS OF INFORMATION                              *
*   R1 WILL RETURN WITH THE NUMBER OF GOOD BYTES(B4 BLANK)      *
*****************************************************************
HOWMANY  LA    R1,0
CLI3     CLI   0(R15),C' '   IS IT BLANK
         BE    XIT
         SPACE 1
         CLI   0(R15),C'A'   IS IT EVEN A LETTER
         BL    XIT           GO IF NOT
         SPACE 1
         CLI   0(R15),C'J'
         BNL   CONX1         GO CHECK MORE
         SPACE 1
         CLI   0(R15),C'I'
         BH    XIT           IT IS GR THAN I AND LESS THAN J *BADBAD
         SPACE 1
CONX1    CLI   0(R15),C'S'
         BNL   CONX2
         SPACE 1
         CLI   0(R15),C'R'
         BH    XIT            LESS THAN S AND GR  THAN R
         SPACE 1
CONX2    CLI   0(R15),C'0'
         BNL   CONX3
         SPACE 1
         CLI   0(R15),C'Z'
         BH    XIT
         SPACE 1
CONX3    CLI   0(R15),C'9'
         BH    XIT           GREATER THAN 9
         SPACE 1
         LA    R1,1(R1)      COUNT GOOD NUMBERS
         C     R1,=F'8'      IS IT AT THE LIMIT
         BE    XIT
         SPACE 1
         LA    R15,1(R15)    GO TO NEXT BYTE
         B     CLI3
         SPACE 1
XIT      BCTR  R1,0          REDUCE 1 FOR MOVE
         BR    R14           GO TO CALLER
         EJECT
****************************************************************
* THIS ROUTINE SETS ALL PREVIOUS SUBSCRIPTS TO ONE             *
* R15   HAS ADDRESS OF CURRENT SUBSCRIPT IN WORKDIM            *
****************************************************************
SETSUB21 DS    0H
         LA    R1,WORKDIM
MAKONE   MVC   0(4,R1),=F'1' SET IT TO ONE
         LA    R1,4(R1)      GO TO NEXT DIMENSION
         CR    R1,R15        ARE WE THERE YET
         BNE   MAKONE
         SPACE 1
         BR    R14           RETURN TO CALLER
         EJECT
EXITEXIT L     R15,GOTOSTAE  GET WHERE WE ARE GOING  ADDRESS
         L     R13,4(R13)    GET OLD SAVE AREA
         L     R14,12(R13)   GET WHERE WE CAME FROM AND WILL RETURN
         LM    R0,R12,20(R13) GET THE REGESTERS
         BR    R15           GO TO REAL STAE
         EJECT
         LTORG
         EJECT
OUTPUT   DCB   DDNAME=DEBUGOUT,DSORG=PS,MACRF=PM,LRECL=120
         EJECT
*********************************************************************
LINEONPG DC    F'50'
STARTCLR DC    F'0'
LENGTH   DC    F'0'
INTGNEG  DC    X'00'
REALNEG  DC    X'00'
STAEOK   DC    X'00'
         DC    C'GOST'
GOTOSTAE DC    F'0'
LASTGETM DS    0F
         DC    AL4(0)
FIRSTGET DC    F'0'
CURPARM  DC    F'0'
LASTPARM DC    X'00'
OPNFLG   DC    X'00'
PARMSET  DC    F'0'
WORK1    DC    D'0'
WORK2    DC    32C' '
NUMDIM   DC    F'0'
WORKDIM  DC    7F'1'
WORKDIM1 EQU   WORKDIM
WORKDIM2 EQU   WORKDIM1+4
WORKDIM3 EQU   WORKDIM2+4
WORKDIM4 EQU   WORKDIM3+4
WORKDIM5 EQU   WORKDIM4+4
WORKDIM6 EQU   WORKDIM5+4
WORKDIM7 EQU   WORKDIM6+4
PRINTCC  DC    C' '
PRINTLIN DC    121C' '
         DC    C'ENDPRINTLINE'
BADPARM  DC    CL120' BAD PARM ON CALL'
STMSG    DC    C'THESE VARIABLES HAD THE DISPLAYED VALUE AT THE TIME OFX
                ABEND'
NUMBER   DC    D'0'
EBDNUM   DC    D'0'
EXP      DC    D'0'
TEMP1    DC    D'0'
PATCH    DC    20F'0'
TCBADDR  DC    F'0'
BADBADL  DC    F'0'
LOADAT   DC    F'0'
RELABEND DC    F'0'
ABENDLOC DC    F'0'
COMPCODE DC    F'0'
BADLOC   DC    F'0'
SOB1     DC    F'0'
SOB2     DC    F'0'
LOWER    DC    2F'0'
BADINST  DC    2F'0'
TABLEE   DC    C'0123456789ABCDEF'
TRANS    EQU   TABLEE-240
MSAGE1   DC    C'THE INSTRUCTION THAT FAILED WAS AT RELATIVE ADDRESS'
MSAGE2   DC    C'THIS        ABEND WAS CAUSED BY AN ATTEMPT TO'
MSAGE3   DC    C'REGISTER'
INTO     DC    C'INTO'
FROM     DC    C'FROM'
WITH     DC    C'FROM'
MSAGE6   DC    C'LOCATION'
ABSOLUTE DC    C'ABSOLUTE LOCATION'
SOMEBUF  DC    CL2' '
SIFLAG   DC    X'00'
A        DC    X'06',C'ADD TO'
AH       EQU   A
N        DC    X'06',C'AND TO'
C        DC    X'47',C'COMPARE'
CVB      DC    X'11',C'CONVERT TO BINARY'
CVD      DC    X'92',C'CONVERT TO DECIMAL'
D        DC    X'06',C'DIVIDE'
X        DC    X'0C',C'EXCLUSIVE OR'
IC       DC    X'15',C'INSERT CHARACTER'
L        DC    X'04',C'LOAD'
LH       EQU   L
M        DC    X'08',C'MULTIPLY'
MH       EQU   M
O        DC    X'0F',C'OR TO'
ST       DC    X'85',C'STORE'
NI       DC    X'83',C'AND'
CLI      DC    X'48',C'COMPARE'
STC      EQU   ST
STH      EQU   ST
S        DC    X'0C',C'SUBTRACT FROM'
SH       EQU   S
AD       EQU   A
AE       EQU   AD
AW       EQU   A
AU       EQU   A
CD       DC    X'47',C'COMPARE'
CE       EQU   CD
DD       EQU   D
DE       EQU   D
LD       EQU   L
LE       EQU   L
ME       EQU   M
STD      EQU   ST
STE      EQU   ST
SD       EQU   S
SE       EQU   S
SW       EQU   S
SU       EQU   S
XI       DC    X'4C',C'EXCULSIVE OR'
MVI      DC    X'84',C'MOVE'
OI       EQU   O
LM       EQU   L
STM      EQU   ST
INSTABLE EQU   *
         DC    X'40',AL3(STH)
         DC    X'42',AL3(STC)
         DC    X'43',AL3(IC)
         DC    X'48',AL3(LH)
         DC    X'4A',AL3(AH)
         DC    X'4B',AL3(SH)
         DC    X'4C',AL3(MH)
         DC    X'4E',AL3(CVD)
         DC    X'4F',AL3(CVB)
         DC    X'50',AL3(ST)
         DC    X'53',AL3(M)
         DC    X'54',AL3(N)
         DC    X'56',AL3(O)
         DC    X'57',AL3(X)
         DC    X'58',AL3(L)
         DC    X'59',AL3(C)
         DC    X'5A',AL3(A)
         DC    X'5B',AL3(S)
         DC    X'5D',AL3(D)
         DC    X'60',AL3(STD)
         DC    X'68',AL3(LD)
         DC    X'69',AL3(CD)
         DC    X'6A',AL3(AD)
         DC    X'6B',AL3(SD)
         DC    X'6D',AL3(DD)
         DC    X'6E',AL3(AW)
         DC    X'6F',AL3(SW)
         DC    X'70',AL3(STE)
         DC    X'78',AL3(LE)
         DC    X'79',AL3(CE)
         DC    X'7A',AL3(AE)
         DC    X'7B',AL3(SE)
         DC    X'7C',AL3(ME)
         DC    X'7D',AL3(DE)
         DC    X'7E',AL3(AU)
         DC    X'7F',AL3(SU)
         DC    X'92',AL3(MVI)
         DC    X'94',AL3(NI)
         DC    X'95',AL3(CLI)
         DC    X'96',AL3(OI)
         DC    X'97',AL3(XI)
INSTEND  EQU   *
         EJECT
****************************************************************
*   THIS SECTION IS FOR LATER RELEASES IT HAS NO USE NOW       *
         ENTRY  TERMALL
TERMALL  DS     0F
         USING   *,15
         MVI     ALLFLAG,X'FF'
         B     R14
ALLFLAG  DC    X'00'
****************************************************************
         EJECT
TABLE    DSECT
NAME     DC    CL8' '
ADDRESS  DC    F'0'
DIM1     DC    F'0'
DIM2     DC    F'0'
DIM3     DC    F'0'
DIM4     DC    F'0'
DIM5     DC    F'0'
DIM6     DC    F'0'
DIM7     DC    F'0'
DIMNUM   DC    F'0'
TOTDIM   DC    F'0'
OPTIONAL DC    X'00'
TYPE     DC    X'00'
         DC    C'NX'
NEXTABLE DC    F'0'
         END
