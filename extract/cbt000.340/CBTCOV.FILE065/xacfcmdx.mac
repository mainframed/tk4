ACF2     TITLE 'ROUTINE USED AS AN ACF2 COMMAND PROCESSOR'
         MACRO ,
&NAME    OPTABENT &ROUTINE,&OFFSET,&FLAG
         DC    AL1(L'N&SYSNDX)
         DC    AL4(&ROUTINE)
N&SYSNDX DC    C'&NAME'
         AIF   ('&ROUTINE' NE 'EXITSET').NOTEXIT
         DC    AL2(&OFFSET-ACCVT)
         DC    AL2(&FLAG-ACFDR)
         MEXIT
.NOTEXIT AIF   ('&OFFSET' NE '').ACC
         DC    AL2(0)
         AGO   .FLAG
.ACC     AIF   ('&OFFSET'(1,3) NE 'ACC').FDR
         DC    AL2(&OFFSET-ACCVT)
         AGO   .FLAG
.FDR     AIF   ('&OFFSET'(1,3) NE 'FDR').UCVT
         DC    AL2(&OFFSET-ACFDR)
         AGO   .FLAG
.UCVT    AIF   ('&OFFSET'(1,4) NE 'UCVT').ABS
         DC    AL2(&OFFSET-UCVT)
         AGO   .FLAG
.ABS     ANOP
         DC    AL2(&OFFSET)
.FLAG    ANOP
         AIF   ('&FLAG' NE '').FFDR
         DC    AL2(0)
         MEXIT
.FFDR    AIF   ('&FLAG'(1,3) NE 'FDR').FABS
         DC    AL2(&FLAG-ACFDR)
         MEXIT
.FABS    ANOP
         DC    AL2(&FLAG)
         MEND
XACFCMDX CSECT
         XACFUCVT ,               ACF2 USER CVT MAPPING MACRO
         ACFREGS LINK=R7
         ACCVT ,                  ACF2 CVT
         ACFASVT ,                MAP ACF2 ASVT
         ACFDR ,                  ACF2 FIELD DEFINITION RECORD
         ACUCB ,                  MAP ACF USER CONTROL BLOCK
         PUSH  PRINT
         PRINT OFF
         CVT   DSECT=YES,PREFIX=NO
         IHAASCB ,                ADDRESS SPACE CONTROL BLOCK
         IHAASVT ,                ADDRESS SPACE VECTOR TABLE
         IHAPSA ,                 PREFIXED SAVE AREA
         IEEXSA ,
         POP   PRINT
SHOWAREA DSECT
         DS    18F
TABLE    DC    XL256'00'
WTOLINE  DC    AL2(83)
WTOFLAGS DC    XL2'0100'
LINE     DC    CL124' '
SHOWPDSN DS    CL44
         DS    0F
MSGID    DS    XL3                MSGID
CONSOLE  DS    XL1                CONSOLE ID
PARMLIST DS    0A
PARMCOM  DC    A(COMMAND)
PARMBUF  DC    A(BUFFER)
PARMBUFL DC    A(BUFFLEN)
PARMLINL DC    A(LINELEN)
PARMLINN DC    A(CDSPLIN#)
COMMAND  DC    AL2(L'WORDS)
         DC    AL2(9)
WORDS    DC    CL256'SHOW STATE '
BUFFLEN  DC    A(L'BUFFER)
LINELEN  DC    F'70'
CDSPAREA DS    A                  ADDRESS OF ARE BUFFER
CDSPGRPA DS    A                  ADDRESS OF START OF GROUPS
CDSPGRPN DS    A                  ADDRESS OF NUMBER OF GROUPS
CDSPHDRA DS    A                  ADDRESS OF HEADER LIST OF FLD
CDSPBUFA DS    A                  ADDRESS OF OUTPUT BUFFER
CDSPBUFS DS    A                  ADDRESS OF LENGTH OF BUFFER
CDSPLINS DS    A                  ADDRESS OF LINE LENGTH
CDSPLINN DS    A                  ADDRESS OF NUMBER OF LINES
CDSPLIN# DS    A                  NUMBER OF LINES
         ACALT DSECT=NO           LOGONID DATABASE ALT PARMLIST
ACALTLEN EQU   *-ACALT
         ACRULE DSECT=NO          RULE DATABASE ALT PARMLIST
         ACGRSRC DSECT=NO         RESOURCE DATABASE ALT PARMLIST
ACFDCMPL CALL  ,(,,,),MF=L        PARMLIST
WORKAREA DS    0CL(*-SHOWAREA)
BUFFAREA DSECT
         DS    0D
BUFFER   DS    CL8192
XACFCMDX CSECT
         SAVE  (14,12),T,*        SAVE REGISTERS
         LR    R12,R15            SET UP BASE REGISTER
         LA    R11,4095(,R12)     SET NEXT BASE REGISTER
         LA    R11,1(,R11)        SET NEXT BASE REGISTER
         USING XACFCMDX,R12,R11   SET ADDRESSABILITY
         L     R0,SHOWLEN         GET LENGTH OF AREA
         GETMAIN RU,LV=(R0)       GET STORAGE FOR PARMLIST
         ST    R1,8(,R13)         CHAIN LOWER SAVE AREA
         ST    R13,4(,R1)         CHAIN HIGHER SAVE AREA
         LR    R13,R1             SAVE ADDRESS OF AREA
         A     R13,SHOWOFF        ADD OFFSET TO SHOWAREA
         USING SHOWAREA,R13       SET ADDRESSABILITY
         LR    R8,R2              SAVE XSA ADDRESS
         USING XSA,R8             SET ADDRESSABILITY
         ACFINCVT R10,NONE=ERROR  GET ACF2 CVT ADDRESS
         USING ACCVT,R10          SET ACF2 CVT ADDRESSABILITY
         L     R9,ACCFDR          LOAD ADDRESS OF ACF2 FDR
         USING ACFDR,R9           SET ACF2 FDR ADDRESSABILITY
         USING PSA,R0             SET PSA ADDRESSABILITY
         MVI   WORDS,C' '         BLANK FIRST CHARACTER
         MVC   WORDS+1(L'WORDS-1),WORDS BLANK REST OF DATA
         XC    MSGID,MSGID        CLEAR MSGID
         MVC   CONSOLE,XAU        SAVE CONSOLE ID
         XR    R7,R7              CLEAR R7
         ICM   R7,B'0111',XAL+1   GET ADDRESS OF OPERAND
         BZ    RETURN             IF NO CIB PROGRAM NOT STC
         L     R1,XAR             GET ADDRESS OF CIB
         LA    R14,2(,R1)         GET ADDRESS OF DATA
         LR    R0,R7              SAVE OPERAND ADDRESS
         SR    R0,R14             GET DIFERENTIAL LENGTH
         LH    R1,0(,R1)          GET TOTAL LENGTH OF DATA
         SR    R1,R0              GET PARM LENGTH
         BM    RETURN             IF NO PARM GO TO ACTIVE
         LA    R0,4               GET OFFSET
         STH   R0,COMMAND+2       STORE OFFSET
         AR    R0,R1              ADD DATA LENGTH
         BCTR  R1,0               DECREMENT R1
         STH   R0,COMMAND         STORE LENGTH
         EX    R1,OCCOMMND        MOVE COMMAND
SETPARMS EQU   *
         LA    R0,COMMAND         LOAD ADDRESS OF COMMAND BFR
         LR    R1,R13             LOAD ADDRESS OF BUFFER
         S     R1,SHOWOFF         SUBTRACT OFFSET TO SHOWAREA
         A     R1,BUFFOFF         ADD OFFSET TO BUFFER
         LA    R2,BUFFLEN         LOAD ADDRESS OF BUFFER LENGTH
         LA    R3,LINELEN         LOAD ADDRESS OF LINE LENGTH
         LA    R4,CDSPLIN#        LOAD ADDRESS NUMBER OF LINES
         STM   R0,R4,PARMCOM      STORE PARMAMETER ADDRESSES
         L     R1,BUFFSIZE        GET LENGTH OF STORAGE AREA
         ST    R1,BUFFLEN         STORE LENGTH OF BUFFER
         LA    R1,70              GET LINE LENGTH
         ST    R1,LINELEN         STORE LINE LENGTH
NEXTTEST EQU   *
         LA    R3,COMMAND         GET ADDRESS OF PARMS
         SLR   R4,R4              CLEAR R4
         SLR   R1,R1              CLEAR R1
         ICM   R4,B'0011',0(R3)   GET LENGTH OF PARMS
         ICM   R1,B'0011',2(R3)   GET OFFSET TO CURRENT OPERAND
         LA    R3,0(R1,R3)        GET ADDRESS OF CURRENT OPRND
         SR    R4,R1              GET LENGTH OF REMAINDER
         BZ    RETURN             MUST BE POSITIVE LENGTH
         BNP   ERROR              MUST BE POSITIVE LENGTH
         CLI   0(R3),C' '         Q. ' ' FOUND
         BE    NEXTBYTE           A. YES, IGNORE IT
         CLI   0(R3),C')'         Q. ')' FOUND
         BE    NEXTBYTE           A. YES, IGNORE IT
         CLI   0(R3),C','         Q. ',' FOUND
         BNE   OPRNDTST           A. NO, GO TO OPERAND TEST
NEXTBYTE EQU   *
         LA    R3,1(,R3)          INCREMENT ADDRESS
         LA    R1,COMMAND         GET ADDRESS OF BUFFER
         SR    R3,R1              SUBTRACT FROM BUFFER ADDRESS
         STH   R3,2(,R1)          STORE NEW OFFSET
         BP    NEXTTEST           GO TO NEXT TEST
         B     RETURN             GO TO RETURN
OPRNDTST EQU   *
         LR    R14,R4             SAVE LENGTH
         BCTR  R14,0              DECREMENT BY 1
         SLR   R2,R2              CLEAR R2
         LA    R1,0(R4,R3)        GET ADDRESS OF DEFAULT END
         XC    TABLE,TABLE        CLEAR TABLE
         MVI   TABLE+C' ',X'04'   SET TABLE ENTRIES
         MVI   TABLE+C',',X'04'   SET TABLE ENTRIES
         MVI   TABLE+C')',X'04'   SET TABLE ENTRIES
         EX    R14,DLMCHK         FIND DELIMETER
         LA    R0,COMMAND         GET ADDRESS OF BUFFER
         SR    R1,R0              GET NEW OPERAND OFFSET
         STH   R1,COMMAND+2       STORE NEW OFFSET
         AR    R1,R0              RESTORE ADDRESS
         SR    R1,R3              GET LENGTH OF OPERAND
         LR    R4,R1              SAVE LENGTH
         LR    R15,R1             SAVE LENGTH
         BCTR  R15,0              DECREMENT BY 1
         SLR   R2,R2              CLEAR R2
         LA    R1,0(R4,R3)        GET ADDRESS OF DEFAULT END
         XC    TABLE,TABLE        CLEAR TABLE
         MVI   TABLE+C'=',X'04'   SET TABLE ENTRIES
         MVI   TABLE+C'(',X'04'   SET TABLE ENTRIES
         EX    R15,DLMCHK         FIND EQUAL SIGN
         B     OPSET(R2)          TAKE APPROPRIATE ACTION
OPSET    B     NOEQUAL            NO EQUAL SIGN
         LR    R15,R1             SAVE ADDRESS
         SR    R15,R3             GET LENGTH OF PARM
         LR    R2,R4              SAVE LENGTH OF OPERAND
         SR    R2,R15             GET LENGTH PAST EQUAL SIGN
         BCTR  R15,0              DECREMENT LENGTH
NOEQUAL  EQU   *
         XR    R3,R1              SWAP PLACES
         XR    R1,R3              "    "
         XR    R3,R1              "    "
         L     R5,=A(OPTABLE-10)  GET ADDRESS OF OPTABLE-10
         SLR   R6,R6              CLEAR R6
NOTIT    EQU   *
         LA    R5,10(R6,R5)       GET ADDRESS OF NEXT ENTRY
         C     R5,=A(ENDTABLE)    CHECK FOR END-OF-TABLE
         BH    ERROR
         IC    R6,0(,R5)          GET ENTRY LENGTH
         BCTR  R6,0               DECREMENT R6
         CR    R15,R6             CHECK LENGTH
         BH    NOTIT              IF OPERAND TO LARGE
         BL    MULTCHK            CHECK FOR MULTIPLE ENTRIES
         SLR   R14,R14            CLEAR R14
         L     R14,1(,R5)         GET ADDRESS OF ROUTINE
         EX    R15,ENTRYCHK       CHECK ENTRY
         BZR   R14                IF EQUAL GO TO IT
         BL    ERROR              ELSE GO TO NOT IT
         B     NOTIT              ELSE GO TO NOT IT
DLMCHK   TRT   0(0,R3),TABLE      CHECK FOR DELIMETER
ENTRYCHK CLC   0(0,R1),5(R5)      CHECK ENTRY
MULTCHK  EQU   *
         SLR   R14,R14            CLEAR R14
         L     R14,1(,R5)         GET ADDRESS OF ROUTINE
         EX    R15,ENTRYCHK       CHECK ENTRY
         BL    ERROR              ELSE GO TO NOT IT
         BH    NOTIT              ELSE GO TO NOT IT
         LA    R7,10(R6,R5)       GET ADDRESS OF NEXT ENTRY
         CLM   R15,B'0001',0(R7)  CHECK LENGTH
         BNLR  R14                IF NOT LOW NOT IT
         EX    R15,AMBIGUUS       CHECK ENTRY
         BZ    NOTIT              IF EQUAL THEN NOT IT
         BR    R14                ELSE IT IS
AMBIGUUS CLC   0(0,R1),5(R7)      CHECK FOR AMBIGUOUS OPERAND
RESETUCT EQU   *
         MODESET MODE=SUP,        SET SUP STATE KEY ZERO               X
               KEY=ZERO
         LH    R1,6(R6,R5)        GET OFFSET OF BYTE
         L     R14,ACCCUSR1       GET ADDRESS OF ACF2 USER CVT
         USING UCVT,R14
         LA    R1,UCVT            GET BYTE ADDRESS
         DROP  R14
         B     UCTRESET
RESETCVT EQU   *
         MODESET MODE=SUP,        SET SUP STATE KEY ZERO               X
               KEY=ZERO
         LH    R1,6(R6,R5)        GET OFFSET OF BYTE
         LA    R1,ACCVT(R1)       GET BYTE ADDRESS
UCTRESET EQU   *
         LA    R15,255            INITIALIZE BIT MASK
         SH    R15,8(R6,R5)       SET BIT MASK
         EX    R15,BITSOFF        EXECUTE NI
         MODESET MODE=PROB,       SET PROB STATE KEY NZERO             X
               KEY=NZERO
         B     NEXTTEST           CONTINUE CHECKING
BITSOFF  NI    0(R1),X'00'        TURN OFF BITS
SETCVT   EQU   *
         CLI   0(R3),C'='         Q. PARM='JOBCK=???'
         BE    YESORNO            CONTINUE CHECKING
SETBITON EQU   *
         MODESET MODE=SUP,        SET SUP STATE KEY ZERO               X
               KEY=ZERO
         LH    R1,6(R6,R5)        GET OFFSET OF BYTE
         LA    R1,ACCVT(R1)       GET BYTE ADDRESS
         LH    R15,8(R6,R5)       SET BIT MASK
         EX    R15,BITSON         EXECUTE NI
         MODESET MODE=PROB,       SET PROB STATE KEY NZERO             X
               KEY=NZERO
         B     NEXTTEST           CONTINUE CHECKING
BITSON   OI    0(R1),X'00'        TURN OFF BITS
YESORNO  EQU *
         CLC   =C'=YES',0(R3)     Q. VALUE = 'YES'
         BE    SETBITON           A. YES, SET BIT
         CLC   =C'=NO',0(R3)      Q. VALUE = 'NO'
         BE    RESETCVT           A. YES, RESET BIT
         B     ERROR              ELSE, GO TO ERROR
SETBYTE  EQU   *
         LH    R1,8(R6,R5)        GET ACF2 FDR BYTE OFFSET
         LH    R5,6(R6,R5)        GET ACF2 CVT BYTE OFFSET
         IC    R6,ACFDR(R1)       GET DEFAULT DATA
         CLI   0(R3),C'='         Q. ANSWER SUPPLIED
         BNE   STDEFBYT           A. NO, STORE FDR DATA
         CLI   1(R3),C'X'         Q. IS VALUE HEX ?
         BNE   DECIMAL            A. NO, DECIMAL THEN
         LA    R3,2(,R3)          INCREMENT PARM ADDRESS
         SH    R2,=H'2'           SUBTRACT FROM LENGTH
         BNP   ERROR              GO TO ERROR
         CH    R2,=H'2'           Q. TWO CHARACTERS SPECIFIED ?
         BNE   ERROR              A. NO, ERROR
         BAL   LINK,ADDRESS       GET ADDRESS
STDEFBYT EQU   *
         MODESET MODE=SUP,        SET SUP STATE KEY ZERO               X
               KEY=ZERO
         STC   R6,ACCVT(R5)       STORE BYTE
         MODESET MODE=PROB,       SET PROB STATE KEY NZERO             X
               KEY=NZERO
         B     NEXTTEST           CONTINUE CHECKING
DECIMAL  EQU   *
         CLC   =C'=NO',0(R3)      Q. WAITIME=NO SPECIFIED?
         BNE   CHECKDEC           A. NO, CHECK FOR NUMERIC
         LA    R6,0               CLEAR BYTE
         MODESET MODE=SUP,        SET SUP STATE KEY ZERO               X
               KEY=ZERO
         STC   R6,ACCVT(R5)       STORE BYTE
         MODESET MODE=PROB,       SET PROB STATE KEY NZERO             X
               KEY=NZERO
         B     NEXTTEST           CONTINUE CHECKING
CHECKDEC EQU   *
         XR    R6,R6              CLEAR R6
         LA    R3,1(,R3)          INCREMENT PARM ADDRESS
         SH    R2,=H'1'           ADJUST LENGTH FOR '='
         BNP   ERROR              IF LENGTH 0 THEN ERROR
         CH    R2,=H'3'           Q. LENGTH OF ANSWER > 3
         BH    ERROR              A. YES, ERROR
         LA    R0,X'F'            LOAD MASK
DECMLOOP EQU   *
         CLI   0(R3),C','         Q. END OF NUMBER
         BE    STORBYTE           A. YES, STORE BYTE
         CLI   0(R3),C' '         Q. END OF NUMBER
         BE    STORBYTE           A. YES, STORE BYTE
         MH    R6,=H'10'          MULTIPLY BY 10
         CLI   0(R3),C'9'         Q. CHAR HIGHER THAN '9'
         BH    ERROR              A. YES, GO TO ERROR
         CLI   0(R3),C'0'         Q. CHAR LESS THAN '0'
         BL    ERROR              A. YES, GO TO ERROR
         IC    R1,0(,R3)          GET CHARACTER
         NR    R1,R0              CLEAR HIGH ORDER BITS
         AR    R6,R1              PLACE BITS IN R6
         LA    R3,1(,R3)          INCREMENT PARM ADDRESS
         SH    R2,=H'1'           SUBTRACT FROM LENGTH
         BM    ERROR              GO TO ERROR
         BZ    STORBYTE           STORE MIN
         B     DECMLOOP           GO TO DECIMAL LOOP
STORBYTE EQU    *
         MODESET MODE=SUP,        SET SUP STATE KEY ZERO               X
               KEY=ZERO
         STC   R6,ACCVT(R5)       STORE BYTE
         MODESET MODE=PROB,       SET PROB STATE KEY NZERO             X
               KEY=NZERO
         B     NEXTTEST           CONTINUE CHECKING
EXITSET  EQU   *
         LH    R1,8(R6,R5)        GET ACF2 FDR EXIT NAME OFFSET
         LA    R0,ACFDR(R1)       ADDRESS OF EXIT NAME IN FDR
         LH    R5,6(R6,R5)        GET ACF2 CVT EXIT ADDRESS
         LA    LINK,EXITSTOR      LOAD RETURN ADDRESS
         CLI   0(R3),C'('         Q. PARM='EXIT('
         BE    MODLOAD            A. YES, LOAD
         CLI   0(R3),C'='         Q. PARM='EXIT='
         BNE   EXITLOAD           A. NO, LOAD
         LA    R3,1(,R3)          INCREMENT PARM ADDRESS
         SH    R2,=H'1'           SUBTRACT FROM LENGTH
         BNP   ERROR              GO TO ERROR
         BAL   LINK,ADDRESS       GET ADDRESS
EXITSTOR EQU   *
         MODESET MODE=SUP,        SET SUP STATE KEY ZERO               X
               KEY=ZERO
         ST    R6,ACCVT(R5)       STORE BYTE
         MODESET MODE=PROB,       SET PROB STATE KEY NZERO             X
               KEY=NZERO
         B     NEXTTEST           CONTINUE CHECKING
MODLOAD  EQU   *
         LA    R6,SHOWPDSN        GET SDDRESS OF WORK AREA
         LR    R0,R6              SAVE ADDRESS
         MVC   SHOWPDSN(8),=CL8' ' BLANK NAME
         LA    R1,9               GET MAX COUNT
MODLOOP  EQU   *
         LA    R3,1(,R3)          INCREMENT PARM ADDRESS
         CLI   0(R3),C','         Q. ADDR=,
         BE    EXITLOAD           A. YES, RETURN
         CLI   0(R3),C')'         Q. ADDR=,
         BE    EXITLOAD           A. YES, RETURN
         CLI   0(R3),C' '         Q. ADDR=
         BE    EXITLOAD           A. YES, RETURN
         MVC   0(1,R6),0(R3)      MOVE IN CHARACTER
         LA    R6,1(,R6)          INCREMENT ADDRESS
         BCT   R1,MODLOOP         DECREMENT AND LOOP
         B     ERROR
EXITLOAD EQU   *
         LR    R6,R0              SAVE ADDRESS OF EPLOC
         L     R1,FLCCVT          GET ADDRESS OF CVT POINTER
         USING CVT,R1             SET CVT ADDRESSABILITY
         L     R1,CVTSVDCB        GET SVC/LPA DCB
         LOAD  EPLOC=(0),         LOAD MODULE                          X
               DCB=(1),                                                X
               ERRET=ERROR
         XR    R6,R0              SWITCH ADDRESSES
         XR    R0,R6                 SWITCH ADDRESSES
         XR    R6,R0                    SWITCH ADDRESSES
         LA    R6,0(,R6)          CLEAR HIGH ORDER
         DELETE EPLOC=(0)         DELETE MODULE
         BR    LINK               RETURN
ADDRESS  DS    0H
         XR    R6,R6              CLEAR R6
ADDRLOOP EQU   *
         CLI   0(R3),C','         Q. ADDR=,
         BER   LINK               A. YES, RETURN
         CLI   0(R3),C' '         Q. ADDR=
         BER   LINK               A. YES, RETURN
         SLL   R6,4               SHIFT LEFT 4
         LA    R0,X'F'            LOAD MASK
         CLI   0(R3),C'A'         Q. CHAR LESS THAN 'A'
         BL    ERROR              A. YES, GO TO ERROR
         CLI   0(R3),C'9'         Q. CHAR HIGHER THAN '9'
         BH    ERROR              A. YES, GO TO ERROR
         CLI   0(R3),C'0'         Q. CHAR NOT LESS THAN '0'
         BNL   NUMERIC            A. YES, GO TO NUMERIC
         CLI   0(R3),C'F'         Q. CHAR HIGHER THAN 'F'
         BH    ERROR              A. YES, GO TO ERROR
ALPHA    EQU   *
         IC    R1,0(,R3)          GET CHARACTER
         NR    R1,R0              CLEAR HIGH ORDER BITS
         LA    R1,9(,R1)          INCREMENT BY 9
         OR    R6,R1              PLACE BITS IN R6
         B     NEXTCHAR
NUMERIC  EQU   *
         IC    R1,0(,R3)          GET CHARACTER
         NR    R1,R0              CLEAR HIGH ORDER BITS
         OR    R6,R1              PLACE BITS IN R6
NEXTCHAR EQU   *
         LA    R3,1(,R3)          INCREMENT PARM ADDRESS
         SH    R2,=H'1'           SUBTRACT FROM LENGTH
         BM    ERROR              GO TO ERROR
         BZR   LINK               RETURN
         B     ADDRLOOP           GO TO ADDRLOOP
SECURE   EQU   *
         CLI   0(R3),C'('         Q. PARM='SHOW='
         BNE   ERROR              GO TO ERROR
         LA    R3,1(,R3)          INCREMENT PARM ADDRESS
         SH    R2,=H'1'           SUBTRACT FROM LENGTH
         CH    R2,=H'5'           CHECK LENGTH
         BL    ERROR              GO TO ERROR
         BAL   LINK,REMOTECK      GO CHECK FOR VALID REMOTE
         MVC   5(3,R1),=C'SEC'    SET TO RMXXXSEC
         MVI   ACGSFCN,ACGSUPT    INDICATE UPDATE OPTION
         BAL   LINK,REMOTEUP      UPDATE REMOTE LOGICAL SOURCE
         BAL   LINK,REMOTEDI      DISPLAY REMOTE LOGICAL SOURCE
         B     NEXTTEST           CONTINUE CHECKING
OPEN     EQU   *
         CLI   0(R3),C'('         Q. PARM='SHOW='
         BNE   ERROR              GO TO ERROR
         LA    R3,1(,R3)          INCREMENT PARM ADDRESS
         SH    R2,=H'1'           SUBTRACT FROM LENGTH
         CH    R2,=H'5'           CHECK LENGTH
         BL    ERROR              GO TO ERROR
         BAL   LINK,REMOTECK      GO CHECK FOR VALID REMOTE
         MVC   5(3,R1),=C'RD1'    SET TO RMXXXRD1
         MVI   ACGSFCN,ACGSUPT    INDICATE UPDATE OPTION
         BAL   LINK,REMOTEUP      UPDATE REMOTE LOGICAL SOURCE
         BAL   LINK,REMOTEDI      DISPLAY REMOTE LOGICAL SOURCE
         B     NEXTTEST           CONTINUE CHECKING
SHOWTEST EQU   *
         CLI   0(R3),C'('         Q. PARM='SHOW('
         BNE   NEXTTEST           A. NO, CONTINUE CHECKING
         LA    R3,1(,R3)          INCREMENT PARM ADDRESS
         SH    R2,=H'1'           SUBTRACT FROM LENGTH
         CH    R2,=H'5'           CHECK LENGTH
         BL    ERROR              GO TO ERROR
         BAL   LINK,REMOTECK      GO CHECK FOR VALID REMOTE
         BAL   LINK,REMOTEDI      DISPLAY REMOTE LOGICAL SOURCE
         B     NEXTTEST           CONTINUE CHECKING
REMOTECK EQU   *
         XC    ACGRSRC(ACGRSLEN),ACGRSRC CLEAR PARM LIST
         MVI   ACGFCN,X'04'       SET REQUEST TYPE
         MVI   ACGSFCN,ACGSRTN    SET OPTION TYPE
         LA    R1,WTOLINE         GET ADDRESS OF MESSAGE AREA
         ST    R1,ACGMSG          STORE MESAGE AREA ADDRESS
         MVC   ACGRTYPE,=C'ESRC'  MOVE IN CLASS AND TYPE
         LR    R14,R13            GET SHOWAREA ADDRESS
         S     R14,SHOWOFF        SUBTRACT SHOW AREA OFFSET
         A     R14,BUFFOFF        ADD BUFFER OFFSET
         ST    R14,ACGREDTA       STORE BUFFER ADDRESS
         MVC   ACGREDTL,BUFFSIZE  STORE LENGTH OF BUFFER
         LA    R1,SHOWPDSN        LOAD ADDRESS OF PSEUDO DSN
         ST    R1,ACGRPDSN        STORE ADDRESS OF PSEUDO DSN
         MVC   ACGRNAME(5),0(R3)  MOVE IN REMOTE NAME
         MVC   ACGRNAME+5(35),=CL35'RD1' COMPLETE DEVICE NAME
REMOTEUP EQU   *
         ACFSVC ACGFCN,TYPE=A,    ISSUE ACF2 SVC TO READ               X
               CVT=HAVE
         LTR   R15,R15            CHECK RETURN CODE
         BNZ   ERRORMSG           IF BAD GO TO ERROR
         L     R1,ACGREDTA        GET ADDRESS OF DATA
         LA    R1,2(,R1)          GET ADDRESS OF FIRST ENTRY
         CLI   0(R1),8            Q. LENGTH = 8
         BNE   ERROR              A. NO, ERROR
         LA    R1,1(,R1)          GET ADDRESS OF LOGICAL SOURCE
         BR    LINK               RETURN
REMOTEDI EQU   *
         LA    R15,12             GET INITIAL LENGTH
         MVC   LINE(8),0(R1)      MOVE IN MESSAGE
         STH   R15,WTOLINE        STORE LENGTH
         MVC   WTOFLAGS,=XL2'0184' SET WTO FLAGS
         MODESET MODE=SUP         SET SUP STATE
         XR    R0,R0              CLEAR R0
         IC    R0,CONSOLE         GET CONSOLE ID
         WTO   MF=(E,WTOLINE)     WTO
         MODESET MODE=PROB        SET PROBLEM STATE
         BR    LINK               RETURN
STATUS   DS    0H
         ST    R14,12(,R13)       SAVE R14
         LA    R1,LINE            GET ADDRESS OF LINE
         LA    R15,4              GET INITIAL LENGTH
         L     R14,ACCCUSR1       GET ADDRESS OF UCVT
         USING UCVT,R14
         TM    UCVTFLG1,@TESTTSO  CHECK FOR TSO BITS
         DROP  R14
         BNZ   TESTTSO            SKIP MOVE
         MVC   0(15,R1),=CL15'NO TSO CONTROL' MOVE IN INIT MSG
         LA    R1,15(,R1)         GET ADDRESS OF NEXT ENTRY
         LA    R15,15(,R15)       ADD ENTRY LENGTH
         B     WTOPREP
TESTTSO  EQU   *
         MVC   0(8,R1),=CL8'TESTTSO' MOVE IN NEXT MESSAGE ENTRY
         LA    R1,8(,R1)          GET ADDRESS OF NEXT ENTRY
         LA    R15,8(,R15)        ADD ENTRY LENGTH
WTOPREP  EQU   *
         STH   R15,WTOLINE        STORE LENGTH
         MVC   WTOFLAGS,=XL2'0184' SET WTO FLAGS
         MODESET MODE=SUP         SET SUP STATE
         XR    R0,R0              CLEAR R0
         IC    R0,CONSOLE         GET CONSOLE ID
         WTO   MF=(E,WTOLINE)     WTO
         MODESET MODE=PROB        SET PROBLEM STATE
         L     R14,12(,R13)       GET RETURN ADDRESS
         BR    R14                RETURN
JESLID   EQU   *
         LA    R6,ASVJID-ACFASVT+4 GET OFFSET TO JES NUMBER
         LA    R7,3               SET MACHINE LENGTH OF DATA CHK
         B     USERLIST
JOBLID   EQU   *
         LA    R3,1(,R3)          INCREMENT ADDRESS
         MVC   ACALID,=CL8' '     BLANK LID FIELD
         BCTR  R2,0               DECREMENT FOR '='
         BCTR  R2,0               DECREMENT FOR MACHINE LENGTH
         EX    R2,MOVELID         MOVE LID
         L     R1,FLCCVT          GET ADDRESS OF CVT
         USING CVT,R1             SET CVT ADDRESSABILITY
         L     R1,CVTASVT         GET ASVT ADDRESS
         USING ASVT,R1            SET ASVT ADDRESABILITY
         L     R0,ASVTMAXU        GET MAXIMUM NO. OF ASID'S
ASCBLOOP EQU   *
         ICM   R5,B'1111',ASVTENTY GET ASCB ADDRESS
         BM    NEXTASCB           IF NOT ASSIGNED GO TO NEXT
         USING ASCB,R5            SET ASCB ADDRESSABILITY
         L     R6,ASCBJBNI        GET ADDRESS OF JOBNAME
         CLC   ACALID,0(R6)       Q. CORRECT JOB NAME
         BE    ASFOUND            A. YES, GO GET LID
         L     R6,ASCBJBNS        GET ADDRESS OF STC NAME
         CLC   ACALID,0(R6)       Q. CORRECT JOBNAME
         BE    ASFOUND            A. YES, GO GET LID
NEXTASCB EQU   *
         LA    R1,4(,R1)          GET NEXT ASVT ENTRY ADDRESS
         BCT   R0,ASCBLOOP        DECREMENT ASID COUNT AND LOOP
         B     NOMATCH            WRITE MESSAGE IF NOT FOUND
ASFOUND  EQU   *
         LH    R6,ASCBASID        GET ASID
         SLL   R6,ASVINDEX        GET OFFSET IN ACF2 SVT
         L     R5,ACCASVT         GET ADDRESS OF ACF2 ASVT
         USING ACFASVT,R5         SET ACF2 ASVT ADDRESSABILITY
         LA    R5,0(R6,R5)        GET OFFSET TO PROPER DATA
         XR    R6,R6              CLEAR R6
         B     LIDFOUND           GO LIST LID
LID      EQU   *
         LA    R6,ASVLID-ACFASVT  GET OFFSET TO LID
         LA    R7,7               SET MACHINE LENGTH OF DATA CHK
         B     USERLIST
SRCLID   EQU   *
         LA    R6,ASVSRC-ACFASVT  GET OFFSET TO SOURCE
         LA    R7,7               SET MACHINE LENGTH OF DATA CHK
         B     USERLIST
USERLIST EQU   *
         XC    ACALT(ACALTLEN),ACALT CLEAR PARM LIST
         LA    R3,1(,R3)          INCREMENT ADDRESS
         MVC   ACALID,=CL8' '     BLANK LID FIELD
         BCTR  R2,0               DECREMENT FOR '='
         BCTR  R2,0               DECREMENT FOR MACHINE LENGTH
         EX    R2,MOVELID         MOVE LID
         L     R1,FLCCVT          GET ADDRESS OF CVT
         USING CVT,R1             SET CVT ADDRESSABILITY
         L     R1,CVTASVT         GET ASVT ADDRESS
         USING ASVT,R1            SET ASVT ADDRESABILITY
         L     R1,ASVTMAXU        GET MAXIMUM NO. OF ASID'S
         L     R5,ACCASVT         GET ADDRESS OF ACF2 ASVT
         USING ACFASVT,R5         SET ACF2 ASVT ADDRESSABILITY
         LA    R5,0(R6,R5)        GET OFFSET TO PROPER DATA
NEXTASID EQU   *
         EX    R7,CHECK           Q. PROPER ADDRESS SPACE FOUND?
         BE    LIDFOUND           A. YES, LIST
         LA    R5,ASVENLEN(,R5)   CHECK NEXT
         BCT   R1,NEXTASID        DECREMENT COUNT AND LOOP
         C     R6,=A(ASVLID-ACFASVT) Q. IS THIS INFO REQUEST
         BE    INFOLIST           A. YES, LIST INFO
NOMATCH  EQU   *
         MVC   WTOLINE(LMSG1),ERRMSG1 MOVE ERROR MESSAGE WTO
         B     ERRORMSG           WRITE ERROR MESSAGE
LIDFOUND EQU   *
         SR    R5,R6              GET ADDRESS OF ENTRY
         MVC   ACALID,ASVLID      MOVE IN LID
         MVC   WTOLINE(L'LMSG2),INFOMSG2 MOVE INFO INTO MESSAGE
         L     R1,PARMBUF         GET ADDRESS OF NEXT MESSAGE
         ST    R1,WTOLINE         STORE POINTER
         MVC   WTOLINE-INFOMSG2+USERID(8),ACALID MOVE LID
         MVC   WTOLINE-INFOMSG2+SOURCE(8),ASVSRC MOVE SOURCE
         MVC   WTOLINE-INFOMSG2+JESID(8),ASVJID MOVE JID
INFOLIST EQU   *
         MVI   ACAFCN,X'02'       INDICATE REQUEST TYPE
         MVI   ACASFCN,ACASFRT    INDICATE DISPLAY IN ACALT
         MVI   ACACNTL,ACACLRET   LIMIT RETURNED FIELDS
         L     R1,=X'FFFFFFFF'    GET SUPERCALL INDICATOR
         ST    R1,ACAUCB          STORE ACF2 UCB ADDRESS
         LA    R1,WTOLINE         LOAD ADDRESS OF MESSAGE BUFFER
         ST    R1,ACAMSG          STORE ERROR MESSAGE ADDRESS
         XC    ACAAREB,ACAAREB    CLEAR ADDRESS OF ARE BUFFER
         XC    ACAAREL,ACAAREL    CLEAR ARE BUFFER LENGTH
         LA    R0,ACAARLST        LOAD ADDRESS OF LIST OF FIELDS
         LA    R1,L'ACAARLST      LOAD NUMBER OF ITEMS IN LIST
         LR    R2,R13             GET WORK AREA ADDRESS
         A     R2,BUFFOFF         ADD BUFFER OFFSET
         L     R3,=A(L'BUFFER/2)  LOAD LENGTH OF ARE RETURN BFR
         AR    R2,R3              ADD HALF
         STM   R0,R3,ACAFLDB      STORE IN PARM LIST
         ACFSVC ACALT,TYPE=A,     ISSUE ALTER SVC                      X
               NONE=ERROR,CVT=HAVE
         LTR   R15,R15            Q. ZERO RETURN CODE
         BNZ   ERRORMSG           A. NO, PUT ERROR MESSAGE
         LR    R0,R13             GET WORK AREA ADDRESS
         A     R0,BUFFOFF         ADD BUFFER OFFSET
         AR    R0,R3              ADD HALF
         L     R1,FDRGRP          LOAD ADDRESS OF GROUP LIST
         LA    R2,FDRGRPC         LOAD ADDRESS OF GROUP COUNT
         L     R3,FDRHDR          LOAD ADDRESS OF HEADER LIST
         STM   R0,R3,CDSPAREA     STORE IN PARM LIST
         L     R0,PARMBUF         LOAD ADDRESS OF OUTPUT BUFFER
         LA    R1,=A(L'BUFFER/2)  LOAD LENGTH OF ARE RETURN BFR
         LA    R2,70              LOAD LINE LENGTH
         ST    R2,LINELEN         STORE LINE LENGTH
         LA    R2,LINELEN         LOAD ADDRESS OF LINE LENGTH
         LA    R3,CDSPLIN#        LOAD ADDRESS OF NUMBER OF LNS
         STM   R0,R3,CDSPBUFA     STORE IN PARM LIST
         LINK  EP=ACFCDSP,        LINK TO DISPLAY ROUTINE              X
               MF=(E,CDSPAREA)
         B     WTOLIST            WRITE OUTPUT
RULE     EQU   *
         XC    ACRULE(ACRLEN),ACRULE CLEAR PARM LIST
         MVI   ACRFCN,X'03'       INDICATE REQUEST TYPE
         MVI   ACRSFCN,ACRSRET    INDICATE RETURN RULE RECORD
         MVI   ACRFLGS,ACRFGNXT   INDICATE GET NEXT PROCESS
         MVC   ACRUCB,=X'FFFFFFFF' SET SUPERCALL INDICATOR
         LA    R1,WTOLINE         LOAD ADDRESS OF MESSAGE BUFFER
         ST    R1,ACRMSG          STORE ERROR MESSAGE ADDRESS
         LA    R3,1(,R3)          INCREMENT ADDRESS
         MVI   ACRPFX,C'*'        MOVE IN INITIAL ASTERISK
         MVC   ACRPFX+1(L'ACRPFX-1),ACRPFX FILL WITH ASTERISKS
         BCTR  R2,0               DECREMENT FOR '='
         BCTR  R2,0               DECREMENT FOR MACHINE LENGTH
         EX    R2,MOVEKEY         MOVE KEY
         LR    R0,R13             GET WORK AREA ADDRESS
         A     R0,BUFFOFF         ADD BUFFER OFFSET
         L     R1,=A(L'BUFFER/2)  LOAD LENGTH OF ARE RETURN BFR
         AR    R0,R1              ADD HALF
         STM   R0,R1,ACRRULAD     STORE IN PARM LIST
         ACFSVC ACRULE,TYPE=A,    ISSUE ALTER SVC                      X
               NONE=ERROR,CVT=HAVE
         LTR   R15,R15            Q. ZERO RETURN CODE
         BNZ   ERRORMSG           A. NO, PUT ERROR MESSAGE
         L     R0,ACRRULAD        GET ADDRESS OF RULE
         LR    R1,R13             GET WORK AREA ADDRESS
         A     R1,BUFFOFF         ADD BUFFER OFFSET
         L     R2,=A(L'BUFFER/2)  LOAD LENGTH OF OUTPUT BUFFER
         LA    R3,=F'0'           LOAD ADDRESS OF SEQUENCE INCREMENT
         O     R3,=X'80000000'    SET LAST PARM INDICATOR
         STM   R0,R3,ACFDCMPL     STORE PARM IN LIST
         LINK  EP=ACFDCMPL,       LINK TO DECOMPILE ROUTINE            X
               MF=(E,ACFDCMPL)
         LTR   R15,R15            Q. GOOD RETURN CODE
         BNZ   ERROR              A. NO, ISSUE MESSAGE
         B     WTOLIST            WRITE OUTPUT
RESOURCE EQU   *
         XC    ACGRSRC(ACGRSLEN),ACGRSRC CLEAR PARM LIST
         MVI   ACGFCN,X'04'       INDICATE REQUEST TYPE
         MVI   ACGSFCN,ACGSRET    INDICATE RETURN RESOURCE RECORD
         MVI   ACGFLGS,ACGFGNXT   INDICATE GET NEXT PROCESS
         MVC   ACGUCB,=X'FFFFFFFF' SET SUPERCALL INDICATOR
         LA    R1,WTOLINE         LOAD ADDRESS OF MESSAGE BUFFER
         ST    R1,ACGMSG          STORE ERROR MESSAGE ADDRESS
         LA    R3,1(,R3)          INCREMENT ADDRESS
         MVI   ACGRTYPE,C'R'      SET RESOURCE TYPE
         MVI   ACGRTYPE+1,C'*'    MOVE IN INITIAL ASTERISK
         MVC   ACGRTYPE+2(L'ACGRTYPE+L'ACGRNAME-2),ACGRTYPE+1 '*' FILL
         BCTR  R2,0               DECREMENT FOR '='
         BCTR  R2,0               DECREMENT FOR MACHINE LENGTH
         EX    R2,MOVETYPK        MOVE KEY
         LR    R0,R13             GET WORK AREA ADDRESS
         A     R0,BUFFOFF         ADD BUFFER OFFSET
         L     R1,=A(L'BUFFER/2)  LOAD LENGTH OF ARE RETURN BFR
         AR    R0,R1              ADD HALF
         STM   R0,R1,ACGRULAD     STORE IN PARM LIST
         ACFSVC ACGRSRC,TYPE=A,   ISSUE ALTER SVC                      X
               NONE=ERROR,CVT=HAVE
         LTR   R15,R15            Q. ZERO RETURN CODE
         BNZ   ERRORMSG           A. NO, PUT ERROR MESSAGE
         L     R0,ACGRULAD        GET ADDRESS OF RULE
         LR    R1,R13             GET WORK AREA ADDRESS
         A     R1,BUFFOFF         ADD BUFFER OFFSET
         L     R2,=A(L'BUFFER/2)  LOAD LENGTH OF OUTPUT BUFFER
         LA    R3,=F'0'           LOAD ADDRESS OF SEQUENCE INCREMENT
         O     R3,=X'80000000'    SET LAST PARM INDICATOR
         STM   R0,R3,ACFDCMPL     STORE PARM IN LIST
         LINK  EP=ACFDCMPL,       LINK TO DECOMPILE ROUTINE            X
               MF=(E,ACFDCMPL)
         LTR   R15,R15            Q. GOOD RETURN CODE
         BNZ   ERROR              A. NO, ISSUE MESSAGE
         B     WTOLIST            WRITE OUTPUT
SHOW     EQU   *
         LH    R1,COMMAND+2       GET OFFSET
         SR    R1,R15             REGRESS OFFSET
         BCTR  R1,0               DECREMENT BY 1
         STH   R1,COMMAND+2       GET OFFSET
         LA    R1,PARMLIST        GET PARMLIST ADDRESS
         CALL  ACF63SHW           CALL SHOW ROUTINE
WTOLIST  EQU   *
         L     R1,PARMBUF         LOAD ADDRESS OF NEXT MESSAGE
         C     R1,WTOLINE         Q. INSERTED MESSAGE?
         BNE   NOINS              A. NO, SKIP
         LA    R1,WTOLINE         GET FIRST LINE
NOINS    EQU   *
         L     R2,0(R1)           LOAD ADDRESS OF NEXT MESSAGE
         XC    MSGID,MSGID        CLEAR MSGID
LOOP     EQU   *
         LR    R3,R1              SAVE ADDRESS OF MESSAGE
         LA    R0,8(,R3)          GET ADDRESS OF MSG
         LH    R1,4(,R3)          GET LENGTH OF WTO
         SH    R1,=H'4'           ADJUST LENGTH
         CALL  XACFJUST           LEFT JUSTIFY MESSAGE
         LR    R1,R3              RESTORE MESSAGE ADDRESS
         L     R3,0(R2)           LOAD ADDRESS OF NEXT MESSAGE
         LH    R4,4(R1)           GET LENGTH OF MESSAGE
         LR    R5,R1              SET STORE ADDRESS
         LA    R1,4(R1)           LOAD ADDRESS OF NEXT MESSAGE
         MVC   2(2,R1),=X'01C4'   MOVE IN FLAGS
         BCTR  R4,0               DECREMENT R4
         EX    R4,MOVELINE        MOVE MESSAGE
         LA    R1,1(R4,R5)        GET ADDRESS OF END-OF-MESSAGE
         MVC   0(4,R1),=X'20000001' MOVE IN ROUTE CODE
         LTR   R2,R2              GET NEXT ADDRESS
         BZ    WTOEND             IF NON-ZERO GET WTO
         LTR   R3,R3              Q. NEXT LINE NULL LINE ?
         BNZ   WTO                A. YES, DON'T SET END
         CLC   4(2,R2),=H'4'      Q. IS FOLLOWING LINE NULL ?
         BNE   WTO                A. NO, DON'T SET END
WTOEND   EQU   *
         OI    0(R1),X'30'        MOVE IN END FLAG
WTO      EQU   *
         CH    R4,=H'3'           IF NULL LENGTH THEN SKIP
         BE    NOMSG              GO TO NO MESSAGE
         MODESET MODE=SUP         SET SUP STATE
         L     R0,MSGID           GET CONSOLE ID AND MSGID
         WTO   MF=(E,(R5))        ISSUE WTO
         LTR   R15,R15            CHECK RETURN CODE
         BNZ   ERROR              IF NON-ZERO NEXTTEST
         STCM  R1,B'0111',MSGID   SAVE MSGID
         MODESET MODE=PROB        SET PROBLEM STATE
NOMSG    EQU   *
         LTR   R1,R2              GET NEXT ADDRESS
         BZ    NEXTTEST           IF ZERO NEXTTEST
         LR    R2,R3              SAVE NEXT
         B     LOOP               GO PUT NEXT
ERROR    EQU   *
         MVC   WTOLINE(LMSG),ERRMSG MOVE ERROR MESSAGE INTO WTO
ERRORMSG EQU   *
         MVC   WTOFLAGS,=XL2'0184' SET WTO FLAGS
         MODESET MODE=SUP         SET SUP STATE
         XR    R0,R0              CLEAR R0
         IC    R0,CONSOLE         GET CONSOLE ID
         WTO   MF=(E,WTOLINE)     ISSUE WTO
         MODESET MODE=PROB        SET PROBLEM STATE
RETURN   EQU   *
         TM    ACCCUSR1,@UCVT     Q. INITIALIZATION NEEDED
         BZ    CHKSTAT            A. NO, SKIP
         MODESET MODE=SUP,        SET SUP STATE KEY ZERO               X
               KEY=ZERO
         CALL  XACFBUCT           CALL ACF2 USER CVT BUILDER
         MODESET MODE=PROB,       SET PROBLEM STATE KEY NON-ZERO       X
               KEY=NZERO
CHKSTAT  EQU   *
         BAL   R14,STATUS         CALL STATUS
         L     R0,SHOWLEN         GET LENGTH OF AREA
         S     R13,SHOWOFF        SUBTRACT OFFSET TO SHOWAREA
         LR    R1,R13             SAVE  WORKAREA ADDRESS
         L     R13,4(,R13)        GET PREVIOUS SAVE AREA
         FREEMAIN RU,LV=(R0),A=(R1) FREE STORAGE
         RETURN (14,12),T,RC=0    RETURN
OPLIST   DC    CL8'BAY'
         DC    CL8'ENTITY'
         DC    CL8'NAME'
         DC    CL8'ORG'
         DC    CL8'PHONE'
ACAARLST EQU   OPLIST,((*-OPLIST)/8),C'C'
CHECK    CLC   ACALID(0),0(R5)    Q. PROPER ADDRESS SPACE FOUND?
MOVELID  MVC   ACALID(0),0(R3)    MOVE IN LOGONID
MOVEKEY  MVC   ACRPFX(0),0(R3)    MOVE IN RULE KEY
MOVETYPK MVC   ACGRTYPE+1(0),0(R3) MOVE IN RESOURCE TYPE/KEY
MOVELINE MVC   0(0,R5),0(R1)      MOVE DATA
OCCOMMND OC    WORDS(0),0(R7)     MOVE DATA
ZERO     DC    F'0'
SHOWOFF  DC    Q(SHOWAREA)
BUFFOFF  DC    Q(BUFFAREA)
BUFFSIZE DC    A(L'BUFFER)
ERRMSG   DC    AL2(L'MESSAGE+4)
         DC    XL2'0100'
MESSAGE  DC    C'INVALID OPERAND'
LMSG     EQU   *-ERRMSG
ERRMSG1  DC    AL2(L'MESSAGE1+4)
         DC    XL2'0100'
MESSAGE1 DC    C'MATCH NOT FOUND ON SYSTEM'
LMSG1    EQU   *-ERRMSG1
INFOMSG2 DS    A
         DC    AL2(L'LMSG2-4)
         DC    XL2'0100'
FILL1    DC    CL22' '
HEAD1    DC    C'LID('
USERID   DC    CL8' '
HEAD2    DC    C') SOURCE('
SOURCE   DC    CL8' '
HEAD3    DC    C') JESID('
JESID    DC    CL8' '
HEAD4    DC    C')'
LMSG2    DS    0CL(*-INFOMSG2)
         LTORG ,
SHOWLEN  CXD   ,
OPTABLE  CSECT  ,
$KK      OPTABENT SHOW
@BLPPGM  OPTABENT RESETUCT,UCVTFLG1,@BLPPGM
@LOGPGM  OPTABENT RESETUCT,UCVTFLG1,@LOGPGM
@MAINT   OPTABENT RESETUCT,UCVTFLG1,@MAINT
@PPGM    OPTABENT RESETUCT,UCVTFLG1,@PPGM
@TSOLIM  OPTABENT RESETUCT,UCVTFLG1,@TSOLIM
@UNRSRC  OPTABENT RESETUCT,UCVTFLG1,@UNRSRC
ACFFDR   OPTABENT EXITSET,ACCFDR,ACFDR
ACTIVE   OPTABENT SHOW
ASCMOD   OPTABENT SETCVT,ACCXFLG,ACCXCRT
BLP      OPTABENT SETCVT,ACCC2FLG,ACCC2BLP
CENTRAL  OPTABENT SETCVT,ACCCFLG,ACCCCEN
CHANGE   OPTABENT RESETCVT,ACCC2FLG,ACCC2DCH
CMDREC   OPTABENT SETCVT,ACCCFLG,ACCCCREC
DDSNS    OPTABENT SHOW
DECOMP   OPTABENT SETBYTE,ACCDCMPP,FDRDECMP
DFTLID   OPTABENT SETCVT,ACCMFLG,ACCMDFID
DSNGEN   OPTABENT EXITSET,ACCTVOL,FDRDSGEN
DSNPOST  OPTABENT EXITSET,ACCPEXIT,FDRPSVLD
EXPPXIT  OPTABENT EXITSET,ACCEPXIT,FDREPXIT
FIELDS   OPTABENT SHOW
INFOPRE  OPTABENT EXITSET,INFSXIT1,FDRPRINF
INFOPST  OPTABENT EXITSET,INFSXIT2,FDRPOINF
JES      OPTABENT JESLID
JOBCK    OPTABENT SETCVT,ACCC2FLG,ACCC2JOB
JOBNAME  OPTABENT JOBLID
LGNIXIT  OPTABENT EXITSET,ACCLVXIT,FDRLIXIT
LGNPXIT  OPTABENT EXITSET,ACCLPXIT,FDRLPXIT
LOGONCK  OPTABENT SETCVT,ACCC2FLG,ACCC2TSO
MAXTRY   OPTABENT SETBYTE,ACCPSWC,FDRPSWC
MAXVIO   OPTABENT SETBYTE,ACCSVIOS+1,FDRSVIOS+1
MINPSWD  OPTABENT SETBYTE,ACCMPSW,FDRMPSW
MIXED    OPTABENT RESETCVT,ACCXFLG,ACCXONCP+ACCXNNCP
NCP      OPTABENT SETCVT,ACCXFLG,ACCXONCP
NEWPXIT  OPTABENT EXITSET,ACCNPXIT,FDRNPXIT
NOASCMOD OPTABENT RESETCVT,ACCXFLG,ACCXCRT
NOBLP    OPTABENT RESETCVT,ACCC2FLG,ACCC2BLP
NOCENTRAL OPTABENT RESETCVT,ACCCFLG,ACCCCEN
NOCHANGE OPTABENT SETCVT,ACCC2FLG,ACCC2DCH
NOCMDREC OPTABENT RESETCVT,ACCCFLG,ACCCCREC
NODFTLID OPTABENT RESETCVT,ACCMFLG,ACCMDFID
NOJOBCK  OPTABENT RESETCVT,ACCC2FLG,ACCC2JOB
NOLOGONCK OPTABENT RESETCVT,ACCC2FLG,ACCC2TSO
NONCP    OPTABENT SETCVT,ACCXFLG,ACCXNNCP
NONE     OPTABENT SETCVT,ACCXFLG,ACCXNMSG
NOPSWDALT OPTABENT SETCVT,ACCC2FLG,ACCC2NPW
NOPSWDFRC OPTABENT RESETCVT,ACCYFLG,ACCYPFRC
NOPSWDJES OPTABENT RESETCVT,ACCC2FLG,ACCC2JES
NOROLL   OPTABENT RESETCVT,ACCXFLG,ACCXNMSG+ACCXRMSG
NOSTC    OPTABENT RESETCVT,ACCC2FLG,ACCC2STC
NOSTMPSMF OPTABENT RESETCVT,ACCCFLG,ACCCSTMP
NOTAPEDSN OPTABENT RESETCVT,ACCCFLG,ACCCTDS
NOTESTTSO OPTABENT RESETUCT,UCVTFLG2,@TESTTSO
NOT2741  OPTABENT SETCVT,ACCXFLG,ACCXOTWX
NOUADS   OPTABENT SETCVT,ACCCFLG,ACCCNUAD
NOUCVT   OPTABENT RESETCVT,ACCCUSR1,@UCVT
NOXBM    OPTABENT SETCVT,ACCMFLG,ACCMNXBM
NOXOUT17 OPTABENT RESETCVT,ACCXFLG,ACCXPM17
OPEN     OPTABENT OPEN
PASSLMT  OPTABENT SETBYTE,ACCPLMT+1,FDRPSWD+1
PGMS     OPTABENT SHOW
PROGRAMS OPTABENT SHOW
PSWDALT  OPTABENT RESETCVT,ACCC2FLG,ACCC2NPW
PSWDFRC  OPTABENT SETCVT,ACCYFLG,ACCYPFRC
PSWDJES  OPTABENT SETCVT,ACCC2FLG,ACCC2JES
RESIDENT OPTABENT SHOW
RESOURCE OPTABENT RESOURCE
ROLL     OPTABENT SETCVT,ACCXFLG,ACCXRMSG
RSCXIT1  OPTABENT EXITSET,ACCRXIT1,FDRRXIT1
RSCXIT2  OPTABENT EXITSET,ACCRXIT2,FDRRXIT2
RULE     OPTABENT RULE
RULEPRE  OPTABENT EXITSET,ACCSXIT1,FDRPRACC
RULEPST  OPTABENT EXITSET,ACCSXIT2,FDRPOACC
SECURE   OPTABENT SECURE
SOURCE   OPTABENT SRCLID
SRCXIT   OPTABENT EXITSET,ACCSRXIT,FDRSRXIT
STATE    OPTABENT SHOW
STATUS   OPTABENT SHOWTEST
STC      OPTABENT SETCVT,ACCC2FLG,ACCC2STC
STCXIT   OPTABENT EXITSET,ACCSVXIT,FDRSVXIT
STMPSMF  OPTABENT SETCVT,ACCCFLG,ACCCSTMP
SVCIXIT  OPTABENT EXITSET,ACCAUXIT,FDRAUXIT
SYSTEMS  OPTABENT SHOW
TAPEDSN  OPTABENT SETCVT,ACCCFLG,ACCCTDS
TESTTSO  OPTABENT SETCVT,UCVTFLG2,@TESTTSO
TSO      OPTABENT SHOW
T2741    OPTABENT RESETCVT,ACCXFLG,ACCXOTWX
UADS     OPTABENT RESETCVT,ACCCFLG,ACCCNUAD
UCVT     OPTABENT SETCVT,ACCCUSR1,@UCVT
USER     OPTABENT LID
VIOEXIT  OPTABENT EXITSET,ACCVEXIT,FDRSCVIO
VLDEXIT  OPTABENT EXITSET,ACCIEXIT,FDRPVALD
WAITIME  OPTABENT SETBYTE,ACCTLWTM,FDRWAITM
WRNDAYS  OPTABENT SETBYTE,ACCPWDAY,FDRPWARN
WTP      OPTABENT SETCVT,ACCXFLG,ACCXNMSG+ACCXRMSG
XBM      OPTABENT RESETCVT,ACCMFLG,ACCMNXBM
XOUT17   OPTABENT SETCVT,ACCXFLG,ACCXPM17
ZEROFLDS OPTABENT SHOW
ENDTABLE EQU   *
         END   XACFCMDX
