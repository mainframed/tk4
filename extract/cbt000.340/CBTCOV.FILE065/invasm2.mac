 INVASM2: PROC OPTIONS(MAIN,TASK); /*   FORGROUND ASM XF  MH */
  /* ************************************************************** */
  /*                                                                */
  /*                                                                */
  /* A VERY NICE FLEXIBLE AND EASY TO USE ASSEMBLER XF PROMPTER     */
  /* FOR RUNNING UNDER TSO : EVER HAD TO WAIT A WHILE FOR A SMALL   */
  /* ASSEMBLY. IT SEEMS THE LARGER THE MACHINES GET THE LONGER YOU  */
  /* HAVE TO WAIT FOR TURN ROUND! THIS FIXES THIS PROBLEM.          */
  /*                                                                */
  /* A LITTLE BIT OF MULTITASKING IS DONE TOO SO YOU CAN DO OTHER   */
  /* THINGS WHILE THE ASSEMBLY IS RUNNING!!! (ENSURE YOU HAVE A     */
  /* LARGE ENOUGH TSO LOGON REGION SIZE).                           */
  /*                                                                */
  /* WHEN YOU INSTALL THIS PROGRAM ON YOUR MACHINE ENSURE THAT      */
  /* THE LINK EDIT IS DONE WITH THE PLI MULTITASKING LIBRARY        */
  /* AS THE FIRST LIBRARY IN THE SYSLIB CONCATENATION. THE NAME     */
  /* OF THIS LIBRARY IS USUALLY SYS1.PLITASK OR PLI.PLITASK.        */
  /*                                                                */
  /*                                                                */
  /*    WRITTEN IN A HIGH LEVEL LANGUAGE EXECPT FOR A SMALL NUMBER  */
  /*    OF ASSEMBLER SUBROUTINES.                                   */
  /*    IF YOU DON'T LIKE PL/I YOU CAN CONVERT THIS FAIRLY          */
  /*    EASILY TO A CLIST (BUT TAKES A LOT LONGER TO RUN !!)        */
  /*    OR RE-WRITE THE WHOLE THING IN ASSEMBLER BUT THAT IS MESSY. */
  /*    IF YOU ARE MAD ENOUGH  YOU CAN EVEN I SUPPOSE CLUDGE AROUND */
  /*    WITH IT TO CONVERT IT TO COBOL (UGH!!!!! AND YOU WOULD      */
  /*    HAVE TO REMOVE THE MULTI-TASKING FACILITY).                 */
  /*                                                                */
  /*    THE ASSEMBLER SUBROUTINES ARE ALL INCLUDED WITH THIS CODE.  */
  /*                                                                */
  /*    THEY ARE 1) A DYNAMIC ALLOCATION INTERFACE - VERY EASY TO   */
  /*                                                 USE SEE CODE   */
  /*             2) CATALOG MANAGEMENT FOR DATASET LOCATE.          */
  /*                                                                */
  /*             3) TSO COMMAND HANDLER ALLOWING TSO COMMANDS TO BE */
  /*                DIRECTLY ISSUED IN A PROBLEM PROGRAM. USED HERE */
  /*                TO ISSUE PRINTOFF COMMAND FOR FOREGROUND        */
  /*                PRINT IF REQUESTED.                             */
  /*                                                                */
  /*             4) PDS MEMBER FINDER : RETURNS INFORMATION AS      */
  /*                TO WHETHER A MEMBER IS IN A PDS OR NOT.         */
  /*                                                                */
  /*  TO RUN YOU MUST BE ABLE TO ACCESS THE PL/I RUN TIME LIBRARY   */
  /*  AND THE LIBRARY CONTAINING THE LINK EDITOR AND ASSEMBLER H    */
  /*  PROGRAM PRODUCTS. IF YOU DO NOT HAVE VERSION 2 OF ISPF        */
  /*  YOU MUST CONCATENATE THESE LIBRARIES TO ISPLLIB IN YOUR TSO   */
  /*  LOGON PROC. ISPF LOOKS IN THIS LIBRARY BEFORE STEPLIB !!!!!!  */
  /*  OR ELSE YOU MUST HAVE THEM UNDER A LOGON STEPLIB DD           */
  /*  STATEMENT.                                                    */
  /*  VERSION 2 ALLOWS USER DEFINED LIBRARIES TO BE SEARCHED        */
  /*  BEFORE ANY STEPLIB, LINKLIST LIBRARY BY USING THE             */
  /*  THE LIBDEF SERVICE FACILITY. EXECUTE A CLIST DEFINING THE     */
  /*  LINK LIBRARY (LINK LIBRARIES) AS FOLLOWS :                    */
  /*                                                                */
  /* ISPEXEC LIBDEF ISPLUSR DATASET ID('SYS1.COMPLIB',LOADLIB)      */
  /*                                                                */
  /* I HAVE DELIBERATELY NOT USED THE ISPF FORMAT                   */
  /* CALL ISPEXEC(BUFLEN,BUFFER) BECAUSE THIS WILL THEN RESTRICT    */
  /* THIS PROGRAM TO ONLY WORK WITH VERSION 2 OF ISPF EVEN THOUGH   */
  /* IT MAKES THE CODING MUCH MORE SIMPLE.                          */
  /*  YOU CAN VERY EASILY MODIFY THIS IF YOU WANT TO RUN ONLY ON    */
  /*  V2 OF ISPF. SIMPLY INSERT THE LENGTH OF YOUR COMMAND IN       */
  /*  BUFLEN AND THE TEXT IN BUFFER.                                */
  /*                                                                */
  /*  NOTE : FOR SUCCESSFUL USE THE TERM OPTION ON THE ASSEMBLY     */
  /*         MUST NOT BE CHANGED.                                   */
  /*                                                                */
  /*  THE FIRST TIME YOU USE THIS PROGRAM ALL VARIABLES WILL BE     */
  /*  BLANK EXCEPT FOR THE ASSEMBLER AND LINK OPTIONS. AFTER EACH   */
  /*  USE EVERYTHING IS STORED IN YOUR PROFILE SO YOU DON'T HAVE    */
  /*  TO RE-ENTER EVERYTHING.                                       */
  /*                                                                */
  /*  INITIAL OPTIONS DECK,NOOBJ,TERM FOR IEUASM                */
  /*   MAP,XREF,LIST FOR LINK EDIT.                              */
  /*                                                                */
  /*  NOTE THAT NO CONTROL STATEMENTS ARE USED IN THE LINK EDIT     */
  /*  OTHER THAN WHAT CAN BE CODED AS PARM VALUES E.G AC(1),RENT    */
  /*  NCAL ETC. IF YOU HAVE A COMPLEX LINK EDIT WITH                */
  /*  INCLUDE STATEMENTS THEN SUBMIT A BATCH JOB !!!!               */
  /*                                                                */
  /*  COMMENTS SUGGESTIONS IMPROVEMENTS AND ERROR INFORMATION       */
  /*  GREATLY APPRECIATED. ADDRESS BELOW.                           */
  /*                                                                */
  /*                                                                */
  /*   THIS PROGRAM IS ALMOST A CLONE OF INVPLI WHICH               */
  /*   INTERACTIVELY PERFORMS PLI PROCESSING. THE SAME              */
  /*   METHODOLOGY IS USED AND THE SAME ASSEMBLER LANGUAGE          */
  /*   SUBPROGRAMS ARE CALLED.                                      */
  /*                                                                */
  /*                                                                */
  /*   THIS PROGRAM CAN BE FREELY COPIED AND DISTRIBUTED SO LONG    */
  /*   AS IT IS NOT USED FOR COMMERCIAL PROFIT. YOU MAY ONLY USE    */
  /*   IT HOWEVER IF YOU ARE LICENSED FOR :                         */
  /*                         A) MVS/370 OR MVS/XA                   */
  /*                         B) TSO (FREE) OR TSO/E (ANY LEVEL)     */
  /*                         C) ISPF/PDF VERSION 1 OR 2             */
  /*                         D) PL/I OPTIMIZER + LIBRARIES          */
  /*                                                                */
  /*    MIKE HAWTHORNE  TTI CITICORP                                */
  /*                    3100 OCEAN PK BLVD                          */
  /*                    SANTA MONICA CA 90405                       */
  /*                                                                */
  /*    (213) 450-9111 X2353                                        */
  /*                                                                */
  /*                                                                */
  /*                                                                */
  /* THIS PROGRAM DISPLAYS A PANEL TO OBTAIN USER SOURCE AND LOAD   */
  /* LIBRARIES AND THE USER-ID. DATASETS REQUIRED BY THE ASMH       */
  /* ASSEMBLER ARE DYNAMICALLY ALLOCATED WITH THE DYNAM INTERFACE   */
  /* (EXISTING DATASETS ARE DELETED USING THE DSINFO CATALOG        */
  /* INTERFACE) AND THE ASSEMBLER H PRODUCT IS INVOKED DYNAMICALLY  */
  /*                                                                */
  /* THE USER CAN SELECT UP TO 3 USER MACLIBS,AND AN EXTRA LOAD     */
  /* LIBRARY FOR THE LINK EDITOR TO CONCATENATE TO THE SYSTEM       */
  /* LIBRARIES FOR AUTO-LINK.                                       */
  /*                                                                */
  /* IF THE RETURN CODE IS 4 OR LESS THE LINK EDITOR IS INVOKED     */
  /* LOADING THE MODULE TO THE LOAD LIBRARY SELECTED OTHERWISE      */
  /* AN ERROR DATASET IS DYNAMICALLY ALLOCATED AND THE LIST         */
  /* DATASET READ AND THE ERRORS COPIED TO THE ERROR DATASET.       */
  /* ISPF BROWSE OF THE ERROR DATASET IS THEN INVOKED.              */
  /*                                                                */
  /* NOTE : IF NO LOAD TARGET LIBRARY IS SPECIFIED THEN THE         */
  /*        LINK STEP IS NOT DONE.                                  */
  /*                                                                */
  /*                                                                */
  /* IF THE USER HAS SELECTED THE PRINT OPTION THE LIST DATASET     */
  /* IS PRINTED BY ISSUING THE PRINTOFF TSO COMMAND.                */
  /* IF THE USER REQUESTS IT THE OUTPUT OF THE ASSEMBLY IS NOT      */
  /* DELETED AT END OF PROCESSING.                                  */
  /* THE OUTPUT IS DIRECTED TO A DATASET USERID.ASM.LIST            */
  /*                                                                */
  /*                                                                */
  /* NOTE : USING PANELS AND ISPF SERVICES IS MUCH EASIER THAN      */
  /*        WRITING A TSO COMMAND PROCESSOR TO DO THIS JOB.         */
  /*        NOBODY HAS TSO THESE DAYS WITHOUT ALSO HAVING ISPF.     */
  /*        PARSING COMMANDS IS MUCH SIMPLER IN PL/I AND MOST       */
  /*        OF THE CODE CAN BE WRITTEN IN A HIGH LEVEL LANGUAGE.    */
  /*                                                                */
  /*  THIS VERSION ASSUMES YOU ARE USING V2 OF ISPF AND HENCE       */
  /*  CAN HOLD SOURCE IN COMPRESSED I.E PACKED FORMAT.              */
  /*  A CALL TO ISRLEMX WILL EXPAND THE MEMBER AND WRITE IT TO A    */
  /*  TEMPORARY DATASET. IF THE SOURCE IS NOT PACKED THEN THE       */
  /*  SOURCE IS NOT EXPANDED BUT STILL WRITTEN TO A TEMPORARY       */
  /*  DATASET.                                                      */
  /*                                                                */
  /*  NOTE YOUR SOURCE MUST BE A MEMBER OF A PDS !!!!!!!            */
  /*       IF IT'S A SEQUENTIAL DATASET THEN THE CALL TO ISRLEMX    */
  /*       WILL NOT BE DONE                                         */
  /*       (IN ANY CASE IT'S MUCH MORE EFFICIENT TO USE PDS'S)      */
  /*                                                                */
  /* ************************************************************** */
  /*                                                                */
  /* DEFINE EXTERNAL REFERENCES : DYNAMIC ALLOCATION INTERFACE      */
  /*                            : CATALOG MANAGEMENT                */
  /*                            : PDS MEMBER FINDER                 */
  /*                            : TSO COMMAND PROCESSOR.            */
  /*                            : ISPF SERVICES                     */
  /*                            : IEUASM ASSEMBLER XF ITSELF        */
  /*                            : LINKAGE EDITOR                    */
  /*                            : ISPF EXPANDER MODULE              */
  /*                                                                */
  /*  (NOTE TO ALL ASSEMBLER BIGOTS OUT THERE: YES YOU CAN CALL     */
  /*   ASM AND LINK EDIT FROM A HIGH LEVEL LANGUAGE SO LONG AS      */
  /*   YOU PASS THE RIGHT PARAMETERS AND GET THE ENTRY POINTS       */
  /*   CORRECT).                                                    */
  /*                                                                */
  /* ************************************************************** */
1
 DCL ISPLINK          ENTRY EXTERNAL OPTIONS(ASM,INTER,RETCODE);
 DCL (DSINFO, DYNAM)  ENTRY EXTERNAL OPTIONS(ASM,INTER,RETCODE);
 DCL INVTSO           ENTRY EXTERNAL OPTIONS(ASM,INTER,RETCODE);
 DCL INVFIND          ENTRY EXTERNAL OPTIONS(ASM,INTER,RETCODE);
 DCL IEUASM           ENTRY EXTERNAL OPTIONS(ASM,INTER,RETCODE);
 DCL ISRLEMX          ENTRY EXTERNAL OPTIONS(ASM,INTER,RETCODE);
 DCL HEWL             ENTRY EXTERNAL OPTIONS(ASM,INTER,RETCODE);
-
  /* ************************************************************** */
  /*                                                                */
  /* DEFINE PLI BUILTIN FUNCTIONS/SERVICES.                         */
  /*                                                                */
  /* ************************************************************** */
 DCL (PLIRETV, LENGTH, SUBSTR, INDEX, ADDR, COMPLETION) BUILTIN;
-
  /* ************************************************************** */
  /*                                                                */
  /*               DEFINE VARIABLES FOR INTER TASK COMMUNICATION.   */
  /*                                                                */
  /* ************************************************************** */
 DCL ECBASM                   EVENT ;
 DCL TASKASM                  TASK  ;
 DCL ECBISPF                  EVENT ;
 DCL TASKISPF                 TASK  ;
 DCL ECBLINK                  EVENT ;
 DCL TASKLINK                 TASK  ;
 DCL ASMBIT BIT(1) INIT('0'B);   /* COMPLETION OF ASSEMBLY  TASK    */
 DCL LINKBIT BIT(1) INIT('0'B);  /* COMPLETION OF LINK EDIT TASK    */
 DCL TASKSDONE BIT(1) INIT('0'B); /* COMPLETION OF ALL TASKS        */
-
  /* ************************************************************** */
  /*                                                                */
  /* DEFINE NON ISPF VARIABLES .                                    */
  /*                                                                */
  /* ************************************************************** */
 DCL CONS             CHAR(80) INIT(' '),
     BLANK            CHAR(8) INIT(' '),
     CURSOR           CHAR(8) INIT(' '),
     PANEL            CHAR(8) INIT(' '),
     Q                PTR,
     Y                PTR,
     Z                PTR,
     I                FIXED BIN(15) INIT(0),
     J                FIXED BIN(15) INIT(0),
     K                FIXED BIN(15) INIT(0),
     LPARM            FIXED BIN(15) INIT(0),
     MEMBER           CHAR(8) INIT(' '),
     MEML             FIXED BIN(15) INIT(0),
     LEN_USERID       FIXED BIN(15) INIT(0),
     LEN_ERR          FIXED BIN(15) INIT(0),
     ASM_RC           FIXED BIN(15) INIT(0),
     LINK_RC          FIXED BIN(15) INIT(0),
     SAVERC           FIXED BIN(15) INIT(0),
     L_SOURCE         FIXED BIN(15) INIT(0),
     L_COPY1          FIXED BIN(15) INIT(0),
     L_COPY2          FIXED BIN(15) INIT(0),
     L_COPY3          FIXED BIN(15) INIT(0),
     L_LOAD           FIXED BIN(15) INIT(0),
     L_LOAD1          FIXED BIN(15) INIT(0),
     L_LNAME          FIXED BIN(15) INIT(0),
     L_LDT            FIXED BIN(15) INIT(0),
     LINE1            FIXED BIN(31) INIT(1),
     WORK             FIXED BIN(31) INIT(0),
     TESTDSN          CHAR(44) INIT(' '),
     NAMELIST         CHAR(70) INIT(' '),
     BROWSE_DSN       CHAR(44) INIT(' '),
     MSGFILE          FILE STREAM OUTPUT ENV(FB),
     FLAG             CHAR(1) INIT(' '),
     PDSTEST          CHAR(1) INIT('N'),
     ERR_FLAG         CHAR(1) INIT('N'),
     ABEND_FLAG       BIT(1)  INIT('0'B),
     MSGID            CHAR(8) INIT(' '),
     QUOTE            CHAR(1) INIT(''''), /* THIS IS A SINGLE QUOTE !*/
     LINK             CHAR(1) INIT(' ');
-
  /* ************************************************************** */
  /*                                                                */
  /* SET UP OPTIONS LIST AND ALTERNATE DDNAMES FOR BOTH THE         */
  /* ASSEMBLER XF AND THE LINKAGE EDITOR.                           */
  /*                                                                */
  /* BY USING ASMPNCH FOR THE OUTPUT OF THE ASSEMBLER AND THE       */
  /* SYSLIN DDNAME FOR THE ASSEMBLER WE CAN USE TEMPORARY           */
  /* DATASETS MAKING DYNAMIC ALLOCATION EASIER.                     */
  /*                                                                */
  /* ************************************************************** */
 DCL
  1 FORASM            UNALIGNED,
    3  OPTLEN         FIXED BIN(15),
    3  OPTDATA        CHAR(100),
  1 FOREXP            UNALIGNED,
    3  EXPLEN         FIXED BIN,
    3  EXPDATA        CHAR(100),
  1 ASMDDN            ALIGNED,
    3  DDNLEN         FIXED BIN(15) INIT(96),
    3  P1             CHAR(8) INIT('ASMLIN'),
    3  P2P3           CHAR(16) INIT(' '),
    3  P4             CHAR(8) INIT('ASMMAC'),
    3  P5             CHAR(8) INIT('ISRLEXPD'), /* ISPF OUTPUT DSN */
    3  P6             CHAR(8) INIT('ASMPRNT'),
    3  P7             CHAR(8) INIT('ASMPNCH'),
    3  P8             CHAR(8) INIT('ASMUT1'),
    3  P9             CHAR(8) INIT('ASMUT2'),
    3  P10            CHAR(8) INIT('ASMUT3'),
    3  P11            CHAR(8) INIT('ASMGO'),
    3  P12            CHAR(8) INIT('ASMTERM'),
  1 FORLNK            UNALIGNED,
    3  LNKLEN         FIXED BIN(15),
    3  LNKDATA        CHAR(100),
  1 LNKDDN            ALIGNED,
    3  DDNLEN1        FIXED BIN(15) INIT(64),
    3  L1             CHAR(8) INIT('ASMPNCH'), /* SYSLIN           */
    3  L2             CHAR(8) INIT(' '),       /* OUTPUT LMOD NAME */
    3  L3             CHAR(8) INIT('LNKMOD'),  /* SYSLMOD          */
    3  L4             CHAR(8) INIT('LNKLIB'),  /* SYSLIB           */
    3  L5             CHAR(8) INIT(' '),       /* NOTHING          */
    3  L6             CHAR(8) INIT('LNKPRNT'), /* SYSPRINT         */
    3  L7             CHAR(8) INIT('  '),      /* NOTHING          */
    3  L8             CHAR(8) INIT('LNKUT1');  /* SYSUT1           */
-
 DCL
  /* ************************************************************** */
  /*                                                                */
  /* SET UP PARAMETER LIST FOR CATALOG MANAGEMENT INTERFACE         */
  /*                                                                */
  /*  C  : CATALOGS A DATASET                                       */
  /*  D  : SCRATCHES A DATASET GIVEN THE VOLUME ID .                */
  /*  I  : RETURNS VOLUME LIST FOR A CATALOGUED DATASET             */
  /*  L  : VERIFY A DATASET IS ON A GIVEN VOLUME AND RETURN DSORG   */
  /*  P  : DELETES AND UNCATALOGS A CATALOGUED DATASET              */
  /*  R  : RENAMES A DATSET. (DOES NOT UNCATALOG IT )               */
  /*  S  : SCRATCHES A CATALOGUED DATASET (UNCATALOG NOT DONE)      */
  /*  U  : UNCATALOGS A DATASET WITHOUT SCRATCHING IT               */
  /*                                                                */
  /*  L ,C, D REQUIRE THE VOLUME ID TO BE ENTERED AS THE FIRST      */
  /*  MEMBER OF VOLLIST ARRAY.                                      */
  /*  ALL FUNCTIONS REQUIRE A 44 BYTE DSN TO BE ENTERED.            */
  /*                                                                */
  /*  FUNCTION L ALSO RETURNS THE DSORG IF THE DATASET IS FOUND     */
  /*  ON THE VOLUME : PO PS IS DA VS                                */
  /*                                                                */
  /*  A VARIETY OF RETURN CODES ARE RETURNED TOO NUMEROUS TO        */
  /*  ELABORATE HERE.                                               */
  /*                                                                */
  /*  IF YOU GET AN RC=0 THEN THE REQUESTED FUNCTION HAS BEEN DONE. */
  /*                                                                */
  /*  ANY OTHER RETURN CODE THEN YOU HAVE AN ERROR.                 */
  /*                                                                */
  /*  IF YOU HAVE XA YOU MUST LOOK IN                               */
  /*  MVS/XA SYSTEM DATA ADMINISTRATION GC26-4010-1 OR HIGHER       */
  /*  MVS/XA CATALOG ADMINISTRATION GUIDE GC26-4041-1 OR HIGHER.    */
  /*  THE CATALOG AND VTOC ACCESS MACROS HAVE BEEN SPLIT INTO       */
  /*  THESE 2 VOLUMES. IF YOU HAVE MVS YOU MAY ONLY NEED 1 VOLUME   */
  /*  DATA MANAGEMENT FOR SYSTEM PROGRAMMERS BUT WITH THE ADVENT    */
  /*  OF DFP FOR MVS THEY MAY ALSO HAVE RE-ORGANIZED THE LIBRARY.   */
  /*  YOU ARE ON YOUR OWN ON THAT ONE.                              */
  /*                                                                */
  /*  (NOT ALL THESE FUNCTIONS ARE USED HERE BUT YOU MIGHT LIKE     */
  /*   TO HAVE THE DOCUMENTATION HERE FOR REFERENCE)                */
  /*                                                                */
  /*                                                                */
  /* ************************************************************** */
  PARMS1               CHAR(215) BASED(Q),
  1 WORK1              UNALIGNED,
  3  FUNC              CHAR(1) INIT('P'),
  3  DSNAME            CHAR(44) INIT(' '),
  3  VOLCOUNT          FIXED BIN(31) INIT('0'),
  3  VOLLIST(20)       CHAR(6),
  3  DSORG             CHAR(2) INIT(' '),
  3  NEWNAME           CHAR(44) INIT(' ');
-
 DCL
  /* ************************************************************** */
  /*                                                                */
  /* SET UP PARAMETER LIST FOR MEMBER FINDER MODULE                 */
  /*                                                                */
  /* ************************************************************** */
  1 FORMEM            UNALIGNED,
    3  MPARML         FIXED BIN(15) INIT(8),
    3  LIBNAME        CHAR(9) INIT(' '),
  /* ************************************************************** */
  /*                                                                */
  /* SET UP PARAMETER LIST FOR TSO COMMAND PROCESSING.              */
  /*                                                                */
  /* ************************************************************** */
  TSOLEN              FIXED BIN(15) INIT(0),
  TSOCMD              CHAR(255) INIT(' '),
-
  /* ************************************************************** */
  /*                                                                */
  /* DEFINE ISPF VARIABLES WE ARE GOING TO USE IN THE PROGRAM.      */
  /*                                                                */
  /* ************************************************************** */
     PRTOPT           CHAR(3) INIT(' '),
     OPT              CHAR(98) INIT(' '),
     SYS              CHAR(1)  INIT(' '),
     LIS              CHAR(1)  INIT(' '),
     DEL              CHAR(1)  INIT(' '),
     RCA              CHAR(4)  INIT(' '),
     RCAA             PIC '9999' BASED(Y),
     RCL              CHAR(4)  INIT(' '),
     RCLA             PIC '9999' BASED(Z),
     LDT              CHAR(98) INIT(' '),
     SOURCE           CHAR(44)  INIT(' '),
     LOAD             CHAR(44) INIT(' '),
     COPY1            CHAR(44) INIT(' '),
     COPY2            CHAR(44) INIT(' '),
     COPY3            CHAR(44) INIT(' '),
     LOAD1            CHAR(44) INIT(' '),
     LNAME            CHAR(8) INIT(' '),
     MEM              CHAR(8) INIT(' '),
     SOURCE_A         CHAR(44)  INIT(' '),
     LOAD_A           CHAR(44) INIT(' '),
     COPY1_A          CHAR(44) INIT(' '),
     COPY2_A          CHAR(44) INIT(' '),
     COPY3_A          CHAR(44) INIT(' '),
     LOAD1_A          CHAR(44) INIT(' '),
     LNAME_A          CHAR(8) INIT(' '),
     ZUSER            CHAR(7)  INIT('ZUSER'),
     USERID           CHAR(8)  INIT(' '),
     LLDT             FIXED BIN(31) INIT(LENGTH(LDT));
 DCL LLNAME           FIXED BIN(31) INIT(LENGTH(LNAME));
 DCL LSOURCE          FIXED BIN(31) INIT(LENGTH(SOURCE)),
     LLOAD            FIXED BIN(31) INIT(LENGTH(LOAD)),
     LMEM             FIXED BIN(31) INIT(LENGTH(MEM)),
     LRCA             FIXED BIN(31) INIT(LENGTH(RCA)),
     LRCL             FIXED BIN(31) INIT(LENGTH(RCL)),
     LCOPY1           FIXED BIN(31) INIT(LENGTH(COPY1)),
     LCOPY2           FIXED BIN(31) INIT(LENGTH(COPY2)),
     LCOPY3           FIXED BIN(31) INIT(LENGTH(COPY3)),
     LLOAD1           FIXED BIN(31) INIT(LENGTH(LOAD1)),
     LZUSER           FIXED BIN(31) INIT(LENGTH(ZUSER)),
     LOPT             FIXED BIN(31) INIT(LENGTH(OPT)),
     LSYS             FIXED BIN(31) INIT(LENGTH(SYS)),
     LLIS             FIXED BIN(31) INIT(LENGTH(LIS)),
     LPRTOPT          FIXED BIN(31) INIT(LENGTH(PRTOPT));
1
  /* ************************************************************** */
  /*                                                                */
  /* SET UP THE INITIAL PROGRAM ENVIRONMENT :                       */
  /*                                                                */
  /*        A) SET UP ADDRESSABILITY OF BASED VARIABLES             */
  /*        B) INITIALIZE THE DYNAMIC ALLOCATION INTERFACE          */
  /*        C) SET UP CODE TO TRAP ABEND                            */
  /*                                                                */
  /* ************************************************************** */
 Q = ADDR(WORK1);
 Y = ADDR(RCA);
 Z = ADDR(RCL);
 FETCH DYNAM;
 FETCH DSINFO;
 FETCH INVTSO;
 FETCH ISPLINK;
 CALL DYNAM(WORK, 'INIT ');
 CALL DYNAM(WORK,'ALLOC ','DD=MSGFILE;','TE;');
1
  /* ************************************************************** */
  /*                                                                */
  /*        ON AN ABEND THIS ROUTINE IS ENTERED. IT DISPLAYS A      */
  /*        MESSAGE SAYING AN ABEND HAS OCCURRED, DEALLOCATES       */
  /*        ANY ALLOCATED DATASETS AND DELETES THE ASSEMBLY AND     */
  /*        LINK LIST DATASETS.                                     */
  /*                                                                */
  /*                                                                */
  /* ************************************************************** */
  ON ERROR
  BEGIN;
        CALL GETOUT;
  END;
 OPEN FILE(MSGFILE) LINESIZE(80);
-
  /* ************************************************************** */
  /*                                                                */
  /* SET UP THE ISPF ENVIRONMENT:                                   */
  /*                                                                */
  /*        A) DEFINE OUR PROGRAMS VARIABLES TO ISPF SO WE          */
  /*           CAN GET DATA FROM A PANEL.                           */
  /*        B) GET THE TSO USER-ID FROM ISPF. THIS IS THE SYSTEM    */
  /*           VARIABLE ZUSER FROM ISPF OBTAINED VIA VCOPY FUNCTION */
  /*        C) GET THE LAST USED OPTIONS FROM THE USERS PROFILE     */
  /*           (SOURCE DATASET MACLIBS LOADLIB NAMES ETC)           */
  /*        D) SHOW THE USER THE PANEL                              */
  /*        E) GET DATA BACK FROM THE PANEL                         */
  /*                                                                */
  /*       (IF PLIRETV = 8 THEN PFK3 OR END KEY HAS BEEN PRESSED)   */
  /*        IF THIS HAS HAPPENED WE EXIT WITHOUT MORE ADO.          */
  /*                                                                */
  /* ************************************************************** */

 CALL ISPLINK('VDEFINE', '(PRTOPT)', PRTOPT, 'CHAR', LPRTOPT);
 CALL ISPLINK('VDEFINE', '(LNAME)', LNAME, 'CHAR', LLNAME);
 CALL ISPLINK('VDEFINE', '(OPT)', OPT, 'CHAR', LOPT);
 CALL ISPLINK('VDEFINE', '(SYS)', SYS, 'CHAR', LSYS);
 CALL ISPLINK('VDEFINE', '(LIS)', LIS, 'CHAR', LLIS);
 CALL ISPLINK('VDEFINE', '(LDT)', LDT, 'CHAR', LLDT);
 CALL ISPLINK('VDEFINE', '(MEM)', MEM, 'CHAR', LMEM);
 CALL ISPLINK('VDEFINE', '(RCA)', RCA, 'CHAR', LRCA);
 CALL ISPLINK('VDEFINE', '(RCL)', RCL, 'CHAR', LRCL);
 CALL ISPLINK('VDEFINE', '(SOURCE)', SOURCE, 'CHAR', LSOURCE);
 CALL ISPLINK('VDEFINE', '(COPY1)', COPY1, 'CHAR', LCOPY1);
 CALL ISPLINK('VDEFINE', '(COPY2)', COPY2, 'CHAR', LCOPY2);
 CALL ISPLINK('VDEFINE', '(COPY3)', COPY3, 'CHAR', LCOPY3);
 CALL ISPLINK('VDEFINE', '(LOAD1)', LOAD1, 'CHAR', LLOAD1);
 CALL ISPLINK('VDEFINE', '(LOAD)', LOAD, 'CHAR', LLOAD);
 CALL ISPLINK('VCOPY', ZUSER, LZUSER, USERID, 'MOVE');
 LEN_USERID = INDEX(USERID,' ');
 IF LEN_USERID ^= 0
 THEN LEN_USERID = LEN_USERID - 1;
 NAMELIST = '(PRTOPT OPT SYS LDT SOURCE COPY1 LOAD1 LIS ' ××
             'LOAD MEM LNAME COPY2 COPY3)';
 CALL ISPLINK('VGET ' ,NAMELIST, 'PROFILE');
 IF LDT = ' '
 THEN LDT = 'MAP,XREF,LIST';
 IF OPT = ' '
 THEN OPT = 'DECK,NOOBJ,TERM';
  /* ************************************************************** */
  /*                                                                */
  /*  DISPLAY THE FOREGROUND ASSEMBLY PANEL.                        */
  /*  IF PFK3/15 PRESSED THEN NO FURTHER PROCESSING IS NEEDED.      */
  /*                                                                */
  /* ************************************************************** */
 CALL ISPLINK('DISPLAY', 'ASMH    ', 'INV011  ');
 IF PLIRETV = 8
 THEN TASKSDONE = '1'B;
 ELSE TASKSDONE = '0'B;
1
  /* ************************************************************** */
  /*                                                                */
  /*  MAIN LOGIC IS AS FOLLOWS:                                     */
  /*                                                                */
  /*  A) IF PFK3/PFK15 PRESSED THEN EXIT OTHERWISE DELETE OLD ASM   */
  /*     AND LINK EDIT LIST DATASETS. IF THEY DO NOT EXIST THE      */
  /*     RETURN CODE IS IGNORED.
  /*  B) PARSE THE DATA FROM THE USER. IF ERROR SHOW THE USER THE   */
  /*     ERROR AND WAIT FOR INPUT. PARSE AGAIN UNTIL NO ERROR OR    */
  /*     PFK3/PFK15 PRESSED. IF PFK3/PFK15 PRESSED THEN EXIT.       */
  /*  C) CALL ASSEMBLY SUBTASK.                                     */
  /*  D) CALL ISPF SUBTASK.                                         */
  /*  E) WAIT FOR ASSEMBLY SUBTASK TO COMPLETE.                     */
  /*  F) CALL LINK EDIT SUBTASK                                     */
  /*  G) WAIT FOR LINK EDIT SUBTASK TO COMPLETE.                    */
  /*  H) WAIT FOR ISPF SUBTASK TO COMPLETE                          */
  /*  I) DEALLOCATE DATASETS FROM ASSEMBLY PHASE                    */
  /*  J) DEALLOCATE DATASETS FROM LINK PHASE                        */
  /*  K) PERFORM END OF ASSEMBLY/LINK PROCESSING (PRINTOFFS ETC).   */
  /*  L) SHOW USER ASSEMBLY COMPLETION PANEL                        */
  /*  M) AWAIT INPUT FROM USER                                      */
  /*  N) DO THE WHOLE THING AGAIN UNTIL PFK3/PFK15 PRESSED.         */
  /*  O) AT END OF ENTIRE JOB SAVE VARIABLES IN USERS PROFILE       */
  /*     AND EXIT.                                                  */
  /*                                                                */
  /* ************************************************************** */
 DO WHILE(TASKSDONE = '0'B);
    DEL = 'Y';
    CALL DELETE_LIST;
    IF LIS = 'Y'                /* KEEP LIST DATASET               */
    THEN DEL = 'N';             /* YES   SO DO NOT DELETE          */
    CALL PARSE_IT;
    DO WHILE(ERR_FLAG = 'Y');
       CALL ISPLINK('DISPLAY', PANEL,  MSGID, CURSOR);
       ERR_FLAG = 'N';
       IF PLIRETV = 8
       THEN TASKSDONE = '1'B;
       IF TASKSDONE = '1'B
       THEN LEAVE;
       CALL PARSE_IT;
    END;
    IF TASKSDONE = '1'B
    THEN LEAVE;
  /* ************************************************************** */
  /*                                                                */
  /*  THE MAIN PROCESS PATH ATTACHES 3 SUBTASKS TWO OF WHICH        */
  /*  RUN ASYNCHRONOUSLY AT THE SAME TIME. THE ASSEMBLY SUBTASK     */
  /*  IS DISPATCHED AND THEN THE ISPF SUBTASK. THE LINK EDIT        */
  /*  SUBTASK IS DISPATCHED AFTER THE ASSEMBLY SUBTASK HAS          */
  /*  FINISHED.                                                     */
  /*  THE ISPF SUBTASK IS PREVENTED FROM TERMINATING (ABENDS        */
  /*  EXCEPTED) UNTIL BOTH THE ASSEMBLY AND LINK SUBTASKS           */
  /*  HAVE FINISHED. HOWEVER THE ISPF SUBTASK CAN RUN FOR AS        */
  /*  LONG AS THE USER WISHES BEFORE CONTROL IS RETURNED TO THE     */
  /*  MAIN TASK. AT THIS POINT THE MAIN PROCESS PATH WILL RETURN    */
  /*  HERE TO CONTINUE EXECUTION.                                   */
  /*                                                                */
  /*  SET UP THE ASSEMBLY AND LINK EDIT SECTIONS AS SUBTASKS.       */
  /*  A PANEL IS THEN DISPLAYED WITH THE KEYBOARD LOCKED. AFTER     */
  /*  2 SECONDS A NEW MENU PANEL IS SHOWN WHICH ENABLES YOU DO TO   */
  /*  OTHER ISPF FUNCTIONS INCLUDING SPLIT SCREEN.                  */
  /*  IF PFK3/15 IS PRESSED THE ECB OF THE ASSEMBLY TASK IS CHECKED.*/
  /*  IF THE TASK IS POSTED AS COMPLETE THEN THE LINK EDIT ECB IS   */
  /*  CHECKED. IF THE LINK EDIT IS ALSO COMPLETE THEN THE FINAL     */
  /*  STATUS PANEL IS DISPLAYED.                                    */
  /*  IF EITHER THE ASSEMBLY OR LINK EDIT SUBTASK HAS NOT FINISHED  */
  /*  THEN A PANEL IS DISPLAYED INDICATING ASSEMBLY FINISHED RC=    */
  /*  THE ASSEMBLY RETURN CODE WITH A MESSAGE LINK EDIT STILL       */
  /*  RUNNING OR ASSEMBLY NOT FINISHED. AFTER APPROX 2 SECS THE     */
  /*  KEYBOARD IS UNLOCKED FOR THE CALLER TO CONTINUE CONCURRENT    */
  /*  PROCESSING. THIS SUBTASK IS NOT ALLOWED TO END UNTIL THE      */
  /*  OTHER 2 HAVE ENDED. NOTE ALSO THIS SUBTASK CAN CARRY ON FOR   */
  /*  AS LONG AS IT LIKES AFTER THE OTHER 2 HAVE FINISHED SO THE    */
  /*  USER DOES NOT HAVE TO LEAVE HIS ISPF SESSION AS SOON AS       */
  /*  THE FOREGROUND ASSEMBLY AND LINK HAS FINISHED.                */
  /*                                                                */
  /*  IF RC > 4 FROM ASSEMBLY SUB TASK THEN ISPF BROWSE IS ENTERED  */
  /*  TO BROWSE THE DIAGNOSTICS.                                    */
  /*                                                                */
  /* ************************************************************** */
  /*                                                                */
  /*        (CLEVER  EH!!!    TRY DOING THIS IN COBOL ALL YOU       */
  /*                          BIGOTS OUT THERE !!!!!).              */
  /*                                                                */
  /* ************************************************************** */
    MSGID = 'INV040  ' ;
    PANEL = 'ASMHS';              /* ASSEMBLY STARTING PANEL         */
    CALL ISPF_DISP;
    DELAY(2000);              /* ALLOW USER 2 SECS TO READ PANEL     */
    CALL DOASM EVENT(ECBASM) TASK(TASKASM);
    CALL DOISPF EVENT(ECBISPF) TASK(TASKISPF);
    WAIT(ECBASM);               /* DO NOT START LINK BEFORE ASM ENDS*/
    IF LINK = 'Y'
    THEN DO;
            CALL DOLINK EVENT(ECBLINK) TASK(TASKLINK);
            WAIT(ECBLINK);
         END;
    ELSE RCL = '*NE*';
    WAIT(ECBISPF);                /* WAIT FOR CONCURRENT ISPF        */
    IF ABEND_FLAG = '1'B          /* ABEND   HARD CHEESE OLD PAL    */
    THEN LEAVE;
1
  /* ************************************************************** */
  /*                                                                */
  /*  THIS SECTION HANDLES PRINTING THE ASSEMBLY/LINK LISTINGS      */
  /*  DELETING THE DATASETS AND SETTING UP THE VARIABLES FOR        */
  /*  ANOTHER INVOCATION OF THE ASSEMBLER IF THE USER WISHES IT.    */
  /*                                                                */
  /*  IF PRINT WAS REQUESTED THEN A TSO PRINTOFF COMMAND IS ISSUED  */
  /*  FOR THE ASSEMBLY AND LINK PRINTOUTS.                          */
  /*  THE ASM.LIST AND LNK.LINKLIST DATASETS ARE THEN DELETED       */
  /*  UNLESS THE USER REQUESTED THEM TO BE KEPT.                    */
  /*                                                                */
  /* ************************************************************** */
    IF PRTOPT = 'YES'
    THEN DO;
            TSOCMD = 'PRINTOFF ASM.LIST CLASS(' ×× SYS ××
                              ')  ';
            TSOLEN = INDEX(TSOCMD,')') + 1;
            CALL INVTSO(TSOLEN, TSOCMD);
            IF LINK = 'Y'
            THEN DO;
                    TSOCMD = 'PRINTOFF LNK.LINKLIST CLASS(' ××
                    SYS ×× ') ';
                    TSOLEN = INDEX(TSOCMD,')') + 1;
                    CALL INVTSO(TSOLEN, TSOCMD);
                 END;
         END;
  /* ************************************************************** */
  /*                                                                */
  /* NOTE : IF YOU ASKED FOR THE LIST DATASET TO BE KEPT AND THEN   */
  /*        INITIATE ANOTHER ASSEMBLY THEN THE OLD LIST DATASET     */
  /*        IS PURGED AND A NEW ONE CREATED!  YOU HAVE BEEN WARNED. */
  /*                                                                */
  /* ************************************************************** */
    IF LIS = 'Y'
    THEN DEL = 'N';
    ELSE DEL = 'Y';
    CALL DELETE_LIST;
  /* ************************************************************** */
  /*                                                                */
  /*  RESTORE ORIGINAL DATASET NAMES FOR SOURCE MACRO AND LOAD      */
  /*  LIBRARIES.                                                    */
  /*  WE HAVE TO DO THIS BECAUSE THE PARSING ROUTINE HAS ALREADY    */
  /*  ADDED USER ID OR REMOVED QUOTES FROM THE                      */
  /*  ORIGINAL VARIABLES.                                           */
  /*                                                                */
  /* ************************************************************** */
    SOURCE = SOURCE_A;
    LOAD = LOAD_A;
    COPY1 = COPY1_A;
    COPY2 = COPY2_A;
    COPY3 = COPY3_A;
    LOAD1 = LOAD1_A;
    LOAD1_A = ' ';
    LOAD_A = ' ';
    COPY1_A = ' ';
    COPY2_A = ' ';
    COPY3_A = ' ';
    CALL ISPLINK('DISPLAY', 'PLIH1   ');
    IF PLIRETV = 8
    THEN TASKSDONE = '1'B;
    IF PLIRETV = 0
    THEN CALL ISPLINK('DISPLAY', 'ASMH    ', 'INV011  ');
    IF PLIRETV = 8
    THEN TASKSDONE = '1'B;
 END;
1
  /* ************************************************************** */
  /*                                                                */
  /*  THIS SECTION IS ENTERED WHEN THE USER HAS FINALLY REQUESTED   */
  /*  TO END BY PRESSING PFK3/PFK15 FROM ANY PANEL.                 */
  /*                                                                */
  /*  SAVE VARIABLES IN USERS PROFILE SO HE CAN USE THEM AGAIN NEXT */
  /*  TIME THIS PROCEDURE IS ENTERED.                               */
  /*                                                                */
  /* ************************************************************** */
 CLOSE FILE(MSGFILE);
 CALL DYNAM(WORK,'UNALLOC ','DD=MSGFILE;');
 RELEASE DYNAM;
 RELEASE INVTSO;
 CALL ISPLINK('VPUT ' ,NAMELIST, 'PROFILE');
 CALL ISPLINK('VDELETE', '(RCA)');
 CALL ISPLINK('VDELETE', '(RCL)');
 RELEASE ISPLINK;
1
 ASM_ALLOCATE: PROC;
  /* ************************************************************** */
  /*                                                                */
  /*  THIS SECTION ALLOCATES THE DATASETS NEEDED BY ASSEMBLY.       */
  /*                                                                */
  /* ************************************************************** */
  /*   IF WE ARE USING A PDS THEN EXPAND POSSIBLE COMPRESSED        */
  /*   SOURCE. REMOVE THIS SECTION IF YOU ARE NOT USING ISPF V2     */
  /*                                                                */
  /* ************************************************************** */
 IF DSORG = 'PO'               /*  ARE WE USING A PDS     */
 THEN DO;                      /* YES WE ARE              */
         K = INDEX(SOURCE,' ');  /* PARSE HAS REMOVED ANY QUOTES   */
         K = K - 1;      /* OR ALREADY INSERTED USER ID       */
         I = INDEX(LIBNAME,' ');
         I = I - 1;
          CALL DYNAM(WORK, 'ALLOC ',
                     'NEW KEEP;',
                     'LRECL=80;',
                     'BLKSIZE=3120;',
                     'FB;',
                     'UNIT=SYSDA;',
                     'DD=ISRLEXPD;',
                     'TRK PRIMARY=15 SECONDARY=5;');
  /* ************************************************************** */
  /*                                                                */
  /*   ALLOCATE THE INPUT SOURCE PDS CONTAINING COMPRESSED OR       */
  /*   ORDINARY SOURCE MEMBER(S)                                    */
  /*                                                                */
  /* ************************************************************** */
          CALL DYNAM(WORK, 'ALLOC ', 'DSN='
                    ×× SUBSTR(SOURCE,1,K) ×× ' SHR;',
                    'DD=ISRLCODE;');
  /* ************************************************************** */
  /*                                                                */
  /*   LOAD THE IBM PROGRAM, EXECUTE IT AND FREE THE INPUT DATASET. */
  /*   AFTER THIS WE CAN EXECUTE THE ASSEMBLY                       */
  /*                                                                */
  /*   DO NOT CHANGE THE PARM INFO FOR THE IBM PROGRAM OTHERWISE    */
  /*   IT WON'T WORK.  THE BOOK IS WRONG !!!!!!!!!                  */
  /*                                                                */
  /* ************************************************************** */
          FETCH ISRLEMX;
          CALL DYNAM(WORK,'ALLOC ','DD=ISRLMSG;','TE;');
          LPARM = LENGTH('ASM,' ××
          SUBSTR(LIBNAME,1,I) ×× ',F,N,E,4, ,00,ENG,4,7,1,/');
          EXPLEN = LPARM;                   /* CONVERT TO BINARY   */
          EXPDATA = 'ASM,' ×× SUBSTR(LIBNAME,1,I) ××
          ',F,N,E,4, ,00,ENG,4,7,1,/';
          CALL ISRLEMX(FOREXP);
          RELEASE ISRLEMX;
          CALL DYNAM(WORK, 'UNALLOC ', 'DD=ISRLCODE;');
          CALL DYNAM(WORK, 'UNALLOC ', 'DD=ISRLMSG;');
      END;
  /* ************************************************************** */
  /*                                                                */
  /* IF THE INPUT SOURCE IS NOT A PDS THEN DO NOT CALL THE IBM      */
  /* PROGRAM TO EXPAND THE SOURCE. IF THE SOURCE IS A SEQUENTIAL    */
  /* DATASET AND IN COMPRESSED FORMAT YOU MUST DO YOUR OWN EXPANSION*/
  /* FIRST E.G EXECUTE A CLIST WHICH CALLS THIS PROGRAM AFTER YOU   */
  /* HAVE EXPANDED THE SOURCE.                                      */
  /*                                                                */
  /* ************************************************************** */
 ELSE DO;
         K = INDEX(SOURCE,' ');
         K = K - 1;
          CALL DYNAM(WORK, 'ALLOC ', 'DSN='
                    ×× SUBSTR(SOURCE,1,K) ×× ' SHR;',
                    'DD=ISRLEXPD;');
      END;
  /* ************************************************************** */
  /*                                                                */
  /*   ALLOCATE THE DATASETS NEEDED BY THE ASSEMBLER AND THEN GO    */
  /*   AND SCAN FOR USER MACLIBS.                                   */
  /*                                                                */
  /* ************************************************************** */
 K = INDEX (SOURCE,' ');
 CALL DYNAM(WORK, 'ALLOC ',
          'NEW KEEP;',
          'LRECL=80;',
          'BLKSIZE=800;',
          'FB;',
          'UNIT=SYSDA;',
          'DD=ASMPNCH;',
          'TRK PRIMARY=15 SECONDARY=5;');
 CALL DYNAM(WORK, 'ALLOC ',
          'NEW KEEP;',
          'BLKSIZE=1024;',
          'UNIT=SYSDA;',
          'DD=ASMUT1;',
          'TRK PRIMARY=15 SECONDARY=5;');
 CALL DYNAM(WORK, 'ALLOC ',
          'NEW KEEP;',
          'BLKSIZE=1024;',
          'UNIT=SYSDA;',
          'DD=ASMUT2;',
          'TRK PRIMARY=15 SECONDARY=5;');
 CALL DYNAM(WORK, 'ALLOC ',
          'NEW KEEP;',
          'BLKSIZE=1024;',
          'UNIT=SYSDA;',
          'DD=ASMUT3;',
          'TRK PRIMARY=15 SECONDARY=5;');
 CALL DYNAM(WORK, 'ALLOC ',
 'DSN=' ×× SUBSTR(USERID,1,LEN_USERID) ×× '.ASM.LIST NEW CATLG;',
          'LRECL=125;',
          'BLKSIZE=629;',
          'VBA;',
          'UNIT=SYSDA;',
          'DD=ASMPRNT;',
          'TRK PRIMARY=30 SECONDARY=15;');
  /* ************************************************************** */
  /*                                                                */
  /*   SCAN FOR USER MACLIBS                                        */
  /*   UP TO 3 MAY BE SPECIFIED AND ANY CAN BE BLANK.               */
  /*   PARSE HAS ALREADY TOLD US THERE MUST BE AT LEAST ONE         */
  /*   MACRO LIBRARY SPECIFIED.                                     */
  /*                                                                */
  /*   ALLOWABLE VARIATIONS ARE :  (7 CASES)                        */
  /*                                                                */
  /*     1:MACLIB1 2:MACLIB1 3:MACLIB1 4:MACLIB1                    */
  /*       -------   MACLIB2   -------   MACLIB2                    */
  /*       -------   -------   MACLIB3   MACLIB3                    */
  /*                                                                */
  /*       =====================================                    */
  /*                                                                */
  /*     5:-------  6:------ 7:------                               */
  /*       -------   MACLIB2   MACLIB2                              */
  /*       MACLIB3   MACLIB3   ------                               */
  /*                                                                */
  /*                                                                */
  /*  THIS GETS VERY COMPLEX IF I ADD ANOTHER MACLIB.               */
  /*  3 SHOULD BE ENOUGH.                                           */
  /*                                                                */
  /*  YOU COULD ALWAYS CONCATENATE SAY SYS1.MACLIB AND SYS1.AMODGEN */
  /*  AT THE END OF USER MACLIBS SO YOU COULD HAVE 3 USER           */
  /*  SPECIFIED MACLIBS AND 2 STANDARD ONES GIVING 5 OF WHICH       */
  /*  ONLY 3 NEED TO BE SCANNED FOR.                                */
  /*                                                                */
  /*  I THINK 3 SHOULD CERTAINLY BE ENOUGH FOR ON-LINE ASSEMBLIES.  */
  /*  I DO NOT SUGGEST YOU DO SAY AN MVS STAGE1 SYSGEN ONLINE       */
  /*  ALTHOUGH IF YOU HAVE A 3090 OUT THERE YOU PROBABLY COULD      */
  /*  GET AWAY WITH IT. NOTE THAT WHILE IT'S RUNNING YOU STILL      */
  /*  HAVE ISPF FACILITIES AVAILABLE AS THIS PROCESS IS             */
  /*  MULTI-TASKED.                                                 */
  /*                                                                */
  /*                                                                */
  /*            (MIKE HAWTHORNE)                                    */
  /*                                                                */
  /*                                                                */
  /* ************************************************************** */
 IF SUBSTR(COPY1,1,1) = ' '  /* NO MACLIB1                          */
  /*      ============== CASES 5 6 OR 7 ==============              */
 THEN DO;
  /*      =================== CASE 5 =================              */
         IF SUBSTR(COPY2,1,1) = ' '     /* MACLIB3 ONLY             */
         THEN DO;
         CALL DYNAM(WORK, 'ALLOC  ', 'DSN=' ×× SUBSTR(COPY3,1,L_COPY3)
                ×× ' SHR;','BLKSIZE=16000;','DD=ASMMAC;');
              END;
         ELSE DO;
  /*      =================== CASE 6 =================              */
                 IF SUBSTR(COPY3,1,1) ^= ' '  /*MACLIB3 AND MACLIB2 */
                 THEN DO;
         CALL DYNAM(WORK, 'ALLOC  ', 'DSN=' ×× SUBSTR(COPY2,1,L_COPY2)
                ×× ' SHR;','BLKSIZE=16000;','DD=ASMMAC;');
                 CALL DYNAM(WORK, 'ALLOC ', 'DSN='
                       ×× SUBSTR(COPY3,1,L_COPY3)
                       ×× ' SHR;','DD=DDNAME2;');
                 CALL DYNAM(WORK, 'CONCAT',
                           'DD=ASMMAC,DDNAME2;');
                      END;
                      ELSE DO;    /* MACLIB 2 ONLY */
  /*      =================== CASE 7 =================              */
         CALL DYNAM(WORK, 'ALLOC  ', 'DSN=' ×× SUBSTR(COPY2,1,L_COPY2)
                ×× ' SHR;','BLKSIZE=16000;','DD=ASMMAC;');
                           END;
              END;
         GO TO ASMIT;           /* NOW ASSEMBLE IT         */
      END;
  /*      ============ CASES 1 2 3 OR 4 ==============              */
 CALL DYNAM(WORK, 'ALLOC ', 'DSN=' ×× SUBSTR(COPY1,1,L_COPY1)
                ×× ' SHR;','BLKSIZE=16000;','DD=ASMMAC;');
 IF SUBSTR(COPY2,1,1) ^= ' '   /* MACLIB1 AND MACLIB2 */
  /*      ================ CASES 2 OR 4 ==============              */
 THEN DO;
         CALL DYNAM(WORK, 'ALLOC ', 'DSN='
                    ×× SUBSTR(COPY2,1,L_COPY2)
                    ×× ' SHR;','DD=DDNAME1;');
                 IF SUBSTR(COPY3,1,1) = ' '
  /*      =================== CASE 2 =================              */
                 THEN DO;
                 CALL DYNAM(WORK, 'CONCAT', 'DD=ASMMAC,DDNAME1;');
                      END;
                 ELSE DO;    /* MACLIB1 MACLIB2 MACLIB3             */
  /*      =================== CASE 4 =================              */
                 CALL DYNAM(WORK, 'ALLOC ', 'DSN='
                       ×× SUBSTR(COPY3,1,L_COPY3)
                       ×× ' SHR;','DD=DDNAME2;');
                 CALL DYNAM(WORK, 'CONCAT',
                           'DD=ASMMAC,DDNAME1,DDNAME2;');
                      END;
      END;
 ELSE DO;
  /*      ================ CASES 1 OR 3 ==============              */
         IF SUBSTR(COPY3,1,1) ^= ' '  /*MACLIB1 AND MACLIB3 */
         THEN DO;
  /*      =================== CASE 3 =================              */
                 CALL DYNAM(WORK, 'ALLOC ', 'DSN='
                       ×× SUBSTR(COPY3,1,L_COPY3)
                       ×× ' SHR;','DD=DDNAME2;');
                 CALL DYNAM(WORK, 'CONCAT',
                           'DD=ASMMAC,DDNAME2;');
              END;
  /*      =================== CASE 1 =================              */
      END;
 ASMIT: CALL DYNAM(WORK, 'ALLOC ',
          'DSN=' ×× SUBSTR(USERID,1,LEN_USERID)
          ×× '.ASM.ERRMSG NEW CATLG;',
          'LRECL=121;',
          'BLKSIZE=1210;',
          'FBA;',
          'UNIT=SYSDA;',
          'DD=ASMTERM;',
          'TRK PRIMARY=10 SECONDARY=5;');
 END ASM_ALLOCATE;
1
  DOASM: PROC;
  /* ************************************************************** */
  /*                                                                */
  /*   THIS SECTION IS THE ASSEMBLY SUBTASK.                        */
  /*                                                                */
  /*   IT WORKS AS FOLLOWS:                                         */
  /*                                                                */
  /*   A)  IF WE ARE USING A PDS ALLOCATE A TEMPORARY DATASET AND   */
  /*       USE THE EXPANDER PROGRAM TO COPY THE COMPRESSED MEMBER   */
  /*       TO THIS TEMPORARY DATASET, OTHERWISE ALLOCATE THE        */
  /*       SEQUENTIAL DATASET TO THE SAME DDNAME FOR INPUT TO THE   */
  /*       ASSEMBLER.                                               */
  /*                                                                */
  /*    B) DYNAMICALLY ALLOCATE DATASETS NEEDED BY THE ASSEMBLER    */
  /*       NOTE SOMEONE OUT THERE MUST HAVE A MORE ELEGANT          */
  /*       MACLIB SEARCH ALGORITHM  PLEEEEEESE PLEEEZE!!!           */
  /*                                                                */
  /*    C) CALL THE ASSEMBLER (IEUASM) 31-BIT MODE ALLOWED IN XA.   */
  /*                                                                */
  /*    D) CHECK RETURN CODE. IF RC > 4 SET LINK EDIT FLAG OFF      */
  /*                                                                */
  /*    E) RETURN TO CALLER                                         */
  /*                                                                */
  /* ************************************************************** */
 OPTLEN = INDEX(OPT,' ');
 OPTLEN = OPTLEN - 1;
 OPTDATA = SUBSTR(OPT,1,OPTLEN);
 CALL ASM_ALLOCATE;
  MSGID = 'INV040 ';  /* IEUASM ASSEMBLY PROCESS STARTING */
  FETCH IEUASM;
  CALL IEUASM(FORASM, ASMDDN) ;
  ASM_RC = PLIRETV;
  RCAA = ASM_RC;
  IF ASM_RC > 4
  THEN LINK = 'N';
  RELEASE IEUASM;
  CALL ASM_DEALLOCATE;
  END DOASM;
1
  /* ************************************************************** */
  /*                                                                */
  /*     ALLOCATE DATASETS NEEDED BY LINK EDIT.                     */
  /*                                                                */
  /*                                                                */
  /* ************************************************************** */
   LINK_ALLOCATE: PROC;
 CALL DYNAM(WORK, 'ALLOC ',
                  'NEW KEEP;',
                  'BLKSIZE=1024;',
                  'UNIT=SYSDA;','DD=LNKUT1;',
                  'TRK PRIMARY=15 SECONDARY=5;');
 CALL DYNAM(WORK, 'ALLOC ',
 'DSN=' ×× SUBSTR(USERID,1,LEN_USERID) ×× '.LNK.LINKLIST NEW CATLG;',
          'LRECL=121;',
          'BLKSIZE=1210;',
          'FBA;',
          'UNIT=SYSDA;',
          'DD=LNKPRNT;',
          'TRK PRIMARY=2 SECONDARY=5;');
 CALL DYNAM(WORK, 'ALLOC ', 'DSN=' ×× SUBSTR(LOAD,1,L_LOAD)
         ×× ' SHR;','DD=LNKMOD;');
    /* CALL WRITEIT */
 CALL DYNAM(WORK, 'ALLOC ', 'DSN=SYS1.PPLINK SHR;',
          'DD=LNKLIB;');
 CALL DYNAM(WORK, 'ALLOC ', 'DSN=SYS1.LINKLIB SHR;',
        'DD=DD1;');
 CALL DYNAM(WORK, 'ALLOC ', 'DSN=' ×× SUBSTR(LOAD,1,L_LOAD)
         ×× ' SHR;','DD=DD2;');
 IF SUBSTR(LOAD1,1,1) ^= ' '
 THEN DO;
         CALL DYNAM(WORK, 'ALLOC ', 'DSN=' ×× SUBSTR(LOAD1,1,L_LOAD1)
         ×× ' SHR;','DD=DD3;');
          CALL DYNAM(WORK, 'CONCAT',
          'DD=LNKLIB,DD2,DD3,DD1;');
      END;
 ELSE DO;
          CALL DYNAM(WORK, 'CONCAT',
          'DD=LNKLIB,DD2,DD1;');
      END;
 END LINK_ALLOCATE;
1
   DOLINK: PROC;
  /* ************************************************************** */
  /*                                                                */
  /*  THIS IS THE LINK EDIT SUBTASK.                                */
  /*                                                                */
  /*   IF RETURN CODE >4  OR LINK EDIT NOT REQUESTED THEN           */
  /*   THIS SUBTASK IS NOT ATTACHED.                                */
  /*   OTHERWISE DATASETS REQUIRED FOR LINK EDIT ARE DYNAMICALLY    */
  /*   ALLOCATED AND THE LINK EDITOR CALLED.                        */
  /*   AT THE END OF THE LINK IF RETURN-CODE > 0 THEN ISPF BROWSE   */
  /*   IS ENTERED TO VIEW THE LINK LISTING.                         */
  /*                                                                */
  /* ************************************************************** */
   LNKLEN = INDEX(LDT,' ');
   LNKLEN = LNKLEN - 1;
   LNKDATA = SUBSTR(LDT,1,LNKLEN);
  /* ************************************************************** */
  /*                                                                */
  /*   ALLOCATE DATASETS NEEDED BY THE LINKAGE EDITOR               */
  /*   AND CALL IT .                                                */
  /*                                                                */
  /*  NOTE : WE HAVE TO CONCATENATE ALL THE REQUIRED LIBRARIES      */
  /*         FOR SYSLIB (USING DDNAME LNKLIB) SO THAT AUTO LINK     */
  /*         WILL SEARCH THE RIGHT LIBRARIES.                       */
  /*                                                                */
  /*   AT END OF LINK EDIT  UNALLOCATE THE SYSUT1 DATASET AND       */
  /*   ISSUE A MESSAGE INDICATING THE RETURN CODE.                  */
  /*                                                                */
  /* ************************************************************** */
  CALL LINK_ALLOCATE;
  FETCH HEWL;          /* YOU BETTER HAVE A BIG ENOUGH TSO REGION */
  CALL HEWL (FORLNK, LNKDDN);
  LINK_RC = PLIRETV;
  RCLA = LINK_RC;
  RELEASE HEWL;       /* DELETE IT  ITS A BIG STORAGE USER */
  CALL LINK_DEALLOCATE;
  END DOLINK;
1
  DOISPF: PROC;
  /* ************************************************************** */
  /*                                                                */
  /*     THIS IS THE ISPF SUBTASK.                                  */
  /*                                                                */
  /*  USER WILL NOW BE IN ISPF UNDER THE MENU SHOWN. A RETURN TO    */
  /*  THIS TASK WILL OCCUR WHEN THE USER PRESSES THE END KEY        */
  /*  HOWEVER THE SUB TASKS ATTACHED WILL STILL BE RUNNING.         */
  /*  IF THE END KEY IS PRESSED BEFORE THE ASSEMBLY HAS FINISHED    */
  /*  HAS BEEN DONE THEN A STATUS PANEL WILL BE DISPLAYED WITH      */
  /*  THE MESSAGE ASSEMBLY STILL EXECUTING AND THE PRIMARY MENU     */
  /*  WILL THEN RE-APPEAR AFTER A DELAY OF 2 SECONDS.               */
  /*  IF THE LINK EDIT IS RUNNING THEN THE STATUS OF THE ASSEMBLY   */
  /*  WILL BE SHOWN.                                                */
  /*  IN THIS WAY A USER CAN GET A CONTINUAL UPDATE ON THE STATUS   */
  /*  OF THE JOB.                                                   */
  /*                                                                */
  /*  AT END OF ASM SUB-TASK IF THE RC FROM THE ASSEMBLY WAS > 4    */
  /*  ISPF BROWSE IS ENTERED TO BROWSE THE DIAGNOSTICS.             */
  /*                                                                */
  /*  IF YOU USE OPTION 6 OF ISPF AND YOUR COMMAND PROCESSOR        */
  /*  OR PROGRAM BLOWS UP (ABENDS) THE ASSMBLY AND LINK EDIT        */
  /*  TASKS SHOULD STILL BE UNAFFECTED.                             */
  /*                                                                */
  /*  PLEASE NOTE THAT GETMAINS MAY CAUSE THE WHOLE CABOODLE TO     */
  /*  ABEND S80A OR 878. THE MORAL IS DO NOT ATTEMPT TO EDIT        */
  /*  VERY LARGE DATASETS OR EXECUTE COMMANDS WHICH REQUIRE LARGE   */
  /*  AMOUNTS OF STORAGE AND/OR CPU WHILE CONCURRENTLY RUNNING      */
  /*  FOREGROUND ASSEMBLIES.                                        */
  /*                                                                */
  /* ************************************************************** */
  DCL  BUFLEN     FIXED BIN(31) INIT(0);
  DCL  BUFFER     CHAR(120)     INIT(' ');
  BUFLEN = 15;
  BUFFER = 'PANEL(PLIHS1  )';
  CALL ISPLINK('SELECT', BUFLEN, BUFFER);
   ASMBIT = COMPLETION(ECBASM);
   DO WHILE(ASMBIT = '0'B);
      PANEL = 'PLIHS2 ';
      MSGID = 'INV046 ';       /* TELL HIM ASM STILL RUNNING */
      CALL ISPF_DISP;
      DELAY(2000);             /* WAIT 2 SECS AND THEN BACK TO ISPF*/
      CALL ISPLINK('SELECT', BUFLEN, BUFFER);
      ASMBIT = COMPLETION(ECBASM);  /* CHECK TASK STATUS AGAIN */
   END;
  IF LINK = 'Y'
  THEN DO;
          LINKBIT = COMPLETION(ECBLINK);
          DO WHILE(LINKBIT = '0'B);
              PANEL = 'PLIHS3 ';
              MSGID = 'INV041 ';
              CALL ISPF_DISP;
              DELAY(2000);   /* WAIT 2 SECS AND THEN BACK TO CALLER */
              CALL ISPLINK('SELECT', BUFLEN, BUFFER);
              LINKBIT = COMPLETION(ECBLINK);
          END;
       END;
  /* ************************************************************** */
  /*                                                                */
  /*   IF RETURN CODE FROM ASM SUBTASK >4                           */
  /*   ENTER ISPF WITH BROWSE FACILITY TO BROWSE THE DATASET        */
  /*                                                                */
  /*   NOTE : WHILE YOU ARE IN BROWSE YOU HAVE FULL ACCESS TO       */
  /*          SPLIT SCREENS AND OTHER TSO/ISPF SERVICES SO YOU      */
  /*          CAN EDIT, ISSUE TSO COMMANDS ETC. ETC.                */
  /*                                                                */
  /* ************************************************************** */
  IF ASM_RC > 4
  THEN DO;
          RCL = '*NE*';
          BROWSE_DSN = 'ASM.ERRMSG';
          CALL ISPLINK ('BROWSE', BROWSE_DSN);
          CALL DYNAM(WORK, 'UNALLOC ', 'DD=ASMTERM;');
       END;
  IF LINK = 'Y'
  THEN DO;
          IF LINK_RC > 4
          THEN DO;
                  BROWSE_DSN = 'LNK.LINKLIST';
                  CALL ISPLINK ('BROWSE', BROWSE_DSN);
               END;
       END;
  END DOISPF;
1
  /* ************************************************************** */
  /*                                                                */
  /*   DE-ALLOCATE DDNAMES USED IN ASSEMBLY PROCESSING              */
  /*                                                                */
  /* ************************************************************** */
 ASM_DEALLOCATE: PROC;
  CALL DYNAM(WORK, 'UNALLOC ', 'DD=ISRLEXPD;');
  CALL DYNAM(WORK, 'UNALLOC ', 'DD=ASMPRNT;');
  CALL DYNAM(WORK, 'UNALLOC ', 'DD=ASMUT1;');
  CALL DYNAM(WORK, 'UNALLOC ', 'DD=ASMUT2;');
  CALL DYNAM(WORK, 'UNALLOC ', 'DD=ASMUT3;');
  CALL DYNAM(WORK, 'UNCONCAT ','DD=ASMMAC;');
  CALL DYNAM(WORK, 'UNALLOC ', 'DD=ASMMAC;');
  CALL DYNAM(WORK, 'UNALLOC ', 'DD=DDNAME1;');
  CALL DYNAM(WORK, 'UNALLOC ', 'DD=DDNAME2;');
  IF LINK = 'N'
  THEN CALL DYNAM(WORK, 'UNALLOC ', 'DD=ASMPNCH;');
  IF ASM_RC < 5
  THEN CALL DYNAM(WORK, 'UNALLOC ', 'DD=ASMTERM;');
 END ASM_DEALLOCATE;
1
 LINK_DEALLOCATE: PROC;
  /* ************************************************************** */
  /*                                                                */
  /*   DE-ALLOCATE DDNAMES USED IN LINK EDIT PROCESSING             */
  /*                                                                */
  /* ************************************************************** */
 CALL DYNAM(WORK, 'UNALLOC ', 'DD=LNKUT1;');
 CALL DYNAM(WORK, 'UNALLOC ', 'DD=LNKMOD;');
 CALL DYNAM(WORK, 'UNCONCAT ','DD=LNKLIB;');
 CALL DYNAM(WORK, 'UNALLOC ', 'DD=LNKLIB;');
 CALL DYNAM(WORK, 'UNALLOC ', 'DD=DD1;');
 CALL DYNAM(WORK, 'UNALLOC ', 'DD=DD2;');
 CALL DYNAM(WORK, 'UNALLOC ', 'DD=DD3;');
 CALL DYNAM(WORK, 'UNALLOC ', 'DD=ASMPNCH;');
 IF LINK_RC < 5
 THEN CALL DYNAM(WORK, 'UNALLOC ', 'DD=LNKPRNT;');
 END LINK_DEALLOCATE;
1
  /* ************************************************************** */
  /*                                                                */
  /*   DELETE ASSEMBLY AND LINK EDIT LIST DATASETS.                 */
  /*   ALSO GET RID OF ERROR MESSAGE DATASET.                       */
  /*                                                                */
  /* ************************************************************** */
  DELETE_LIST: PROC;
  IF DEL = 'Y'
  THEN DO;
          FUNC = 'P';
          DSNAME = SUBSTR(USERID,1,LEN_USERID) ×× '.ASM.LIST';
          CALL DSINFO(PARMS1);
          FUNC = 'P';
          DSNAME = SUBSTR(USERID,1,LEN_USERID) ×× '.LNK.LINKLIST';
          CALL DSINFO(PARMS1);
       END;
  FUNC = 'P';
  DSNAME=SUBSTR(USERID,1,LEN_USERID) ×× '.ASM.ERRMSG';
  CALL DSINFO(PARMS1);
  END DELETE_LIST;
1
 PARSE_IT: PROC;
  /* ************************************************************** */
  /*                                                                */
  /*   PARSE THE DATA FROM THE USER.                                */
  /*                                                                */
  /*        A) GET SOURCE DATASET AND CHECK FOR VALIDITY.           */
  /*           IF THE DATASET IS UNQUOTED APPEND THE TSO USER-ID.   */
  /*           NOTE THE PANEL HAS VERIFIED THE CORRECT DSN SYSNTAX  */
  /*           IF UNCATALOGUED THEN ISSUE A MESSAGE.                */
  /*        B) IF NO MACRO LIBRARIES THEN ISSUE ERROR MESSAGE       */
  /*           OTHERWISE CHECK FOR VALIDITY OF DATASETS AND IF      */
  /*           NECESSARY CONCATENATE THEM.                          */
  /*        C) IF NO LOAD LIBRARY SPECIFIED THEN SET A FLAG WHICH   */
  /*           INDICATES LINK STEP NOT TO BE DONE                   */
  /*        D) CHECK FOR ADDITIONAL LOAD LIBRARIES (MAX 1) TO       */
  /*           USE IN THE AUTOLINK SEARCH FOR LINK EDIT INCLUDES.   */
  /*        E) IF ALL THE ABOVE TESTS PASS SET UP OPTIONS FOR       */
  /*           PASSING TO THE COMPILER. THE NEXT SECTION WILL       */
  /*           ALLOCATE DATASETS NEEDED FOR COMPILE.                */
  /*                                                                */
  /*                                                                */
  /* ************************************************************** */
  DSNAME = ' ';
 TESTDSN = SOURCE;
 ERR_FLAG = 'N';
 IF MEM = ' '
 THEN PDSTEST = 'N';
 ELSE DO;
         PDSTEST = 'Y';
         LIBNAME = SUBSTR(MEM,1,8);
         MEML = 8;
      END;
 CALL PARSE;
 IF PDSTEST = 'N'
 THEN DO;
         DSORG = 'XX';
         CALL CHEKPDS;         /* DSN MUST BE SEQUENTIAL */
         IF DSORG ^= 'PS'
         THEN DO;
                 MSGID = 'INV036 ';  /*ITSNOTSEQN  */
                 ERR_FLAG = 'Y';
              END;
      END;
 PDSTEST = 'N';
 IF ERR_FLAG = 'Y'
 THEN CURSOR = 'SOURCE ';
 DO WHILE(ERR_FLAG = 'N');
    SOURCE_A = SOURCE;
    SOURCE = DSNAME;             /* GET CORRECT DSN FOR ALLOCATE*/
    IF SUBSTR(COPY1,1,1) ^= ' '
    THEN DO;
            TESTDSN = COPY1;
            CALL PARSE;
            IF ERR_FLAG = 'Y'    /* PARSE ERROR            */
            THEN CURSOR = 'COPY1 ';
            ELSE DO;
                    COPY1_A = COPY1;
                    COPY1 = DSNAME;
                    L_COPY1 = INDEX(COPY1,' ') - 1;
                 END;
         END;
     IF ERR_FLAG = 'Y'
     THEN LEAVE;
     IF SUBSTR(COPY1,1,1) = ' '
     THEN COPY1_A = ' ';
     IF SUBSTR(COPY2,1,1) = ' '
     THEN DO;
          COPY2_A = ' ';
             IF SUBSTR(COPY1,1,1) = ' '
             THEN DO;
                     COPY1_A = ' ';
                     IF SUBSTR(COPY3,1,1) = ' '
                     THEN DO;
                            CURSOR = 'COPY1 ';
                            MSGID = 'INV005 ';
                            ERR_FLAG = 'Y';
                          END;
                   END;
          END;
     IF ERR_FLAG = 'Y'
     THEN LEAVE;
     ELSE DO;
             TESTDSN = COPY2;
             CALL PARSE;
             IF ERR_FLAG = 'Y'
             THEN CURSOR = 'COPY2 ';
             ELSE DO;
                     COPY2_A = COPY2;
                     COPY2 = DSNAME;
                     L_COPY2 = INDEX(COPY2,' ') - 1;
                  END;
          END;
     IF ERR_FLAG = 'Y'
     THEN LEAVE;
     IF SUBSTR(COPY3,1,1) ^= ' '
     THEN DO;
             TESTDSN = COPY3;
             CALL PARSE;
             IF ERR_FLAG = 'Y'
             THEN CURSOR = 'COPY3 ';
             ELSE DO;
                     COPY3_A = COPY3;
                     COPY3 = DSNAME;
                     L_COPY3 = INDEX(COPY3,' ') - 1;
                  END;
          END;
     IF SUBSTR(LOAD,1,1) = ' '
     THEN DO;
             LOAD_A = ' ';
             LINK = 'N';
          END;
     ELSE DO;
             LINK = 'Y';
             TESTDSN = LOAD;
             CALL PARSE;
             IF ERR_FLAG = 'Y'    /* PARSE ERROR            */
             THEN DO;
                     CURSOR = 'LOAD ';
                     MSGID = 'INV002 ';
                  END;
             ELSE DO;
                     LOAD_A = LOAD;
                     LOAD = DSNAME;
                  END;
          END;
     IF ERR_FLAG = 'Y'
     THEN LEAVE;
     L_LOAD = INDEX(LOAD,' ') - 1;
     IF LINK = 'Y'               /* HAVE WE REQUESTED A LINK  */
     THEN DO;
             IF SUBSTR(LNAME,1,1) = ' '  /* NO NAME FOR LOAD MODULE*/
             THEN DO;
                     MSGID = 'INV003 ';
                     CURSOR = 'LNAME ';
                     ERR_FLAG = 'Y';
                  END;
             ELSE DO;
                     L2 = LNAME;
                     LNAME_A = LNAME;
                  END;
          END;
    IF ERR_FLAG = 'Y'
    THEN LEAVE;
    IF SUBSTR(LOAD1,1,1) ^= ' '
    THEN DO;
            IF LINK = 'Y'
            THEN DO;
                    TESTDSN = LOAD1;
                    CALL PARSE;
                    IF ERR_FLAG = 'Y'    /* PARSE ERROR            */
                    THEN CURSOR = 'LOAD1 ';
                    ELSE DO;
                            LOAD1_A = LOAD1;
                            LOAD1 = DSNAME;
                            L_LOAD1 = INDEX(LOAD1,' ') - 1;
                         END;
                 END;
         END;
    IF ERR_FLAG = 'Y'
    THEN LEAVE;
    IF SUBSTR(LOAD1,1,1) = ' '
    THEN LOAD1_A = ' ';
    LEAVE;                   /* LEAVE PROCEDURE IN ANY CASE        */
 END;
 END PARSE_IT;                /* AT LAST                           */
 PARSE: PROC;
  /* ************************************************************** */
  /*                                                                */
  /*  THIS SUBROUTINE DOES THE FOLLOWING :                          */
  /*                                                                */
  /*      A) IF DSN NOT QUOTED THEN APPEND USERS TSO ID IN FRONT OF */
  /*         THE DATASET NAME OTERWISE EXTRACT QUOTES.              */
  /*      B) IF MEMBER FROM PANEL NOT BLANK THEN THE DATASET MUST   */
  /*         NOT BE OF THE FORMAT DSN(MEMBER)                       */
  /*      B) IF MEMBER IS BLANK THEN CHECK FOR DSN(MEMBER)          */
  /*      C) IF DSN(MEMBER) THEN MEMBER MUST BE 8 CHARS OR LESS     */
  /*      E) CHECKS IF DATASET CATALOGUED.                          */
  /*      F) IF NOT PDS SET SEQUENTIAL INDICATOR.                   */
  /*      G) IF PDS CHECKS MEMBER IS ACTUALLY IN THE PDS            */
  /*                                                                */
  /*                                                                */
  /* BY USING THE VER OPTION ON THE PANEL THE DATASET FORMAT IS     */
  /* CORRECT SO WE DO NOT NEED TO RE-CHECK THIS I.E TOO MANY        */
  /* QUOTES OR ) BEFORE (.                                          */
  /*                                                                */
  /*                                                                */
  /* ERRORS WILL CAUSE A RE-DISPLAY OF THE PANEL WITH A MESSAGE.    */
  /* PF2 WILL PRESENT THE ALTERNATE LONG MESSAGE.                   */
  /*                                                                */
  /*                                                                */
  /* ************************************************************** */
 MEML = 0;
 MEMBER=' ';
 DSNAME = ' ';
 IF SUBSTR(TESTDSN,1,1) = QUOTE   /* EXTRACT QUOTES IF ANY   */
  THEN DO;                        /* IF THERE APPEND USER ID */
          K = INDEX (TESTDSN,' ');     /* GET LENGTH OF SOURCE DSN  */
          K = K - 1;                   /* GET THE REAL LENGTH       */
          DSNAME=SUBSTR(TESTDSN,2,K-2); /* EXTRACT QUOTES */
       END;
  ELSE DO;
          K = INDEX (TESTDSN,' ');  /* NOTE WE COULD HAVE DSN(MEM */
          K = K - 1;
              DSNAME=SUBSTR(USERID,1,LEN_USERID) ×× '.'
              ×× SUBSTR(TESTDSN,1,K);
          END;
 K = INDEX (DSNAME,'(');  /* NOTE WE HAVE NOW EXTRACTED QUOTE */
 IF K > 0                 /* AND IF NECESSARY APPENDED TSO USER ID */
 THEN DO;         /* WE HAVE ALREADY FOUND A  '(' SO VALIDATE DS */
         I = INDEX (DSNAME,')');
         MEML = I - K;
         IF MEML > 9      /* INVALID MEMBER NAME          */
         THEN DO;
                 ERR_FLAG = 'Y';
                 MSGID = 'INV007  ';
              END;
         IF MEM ^= ' '
         THEN DO;
                 ERR_FLAG = 'Y';
                 MSGID = 'INV001  ';
                 GO TO ENDPARS;
              END;
         MEMBER = SUBSTR(DSNAME,K+1,I-1);
         LIBNAME = SUBSTR(MEMBER,1,MEML-1);
         PDSTEST = 'Y';
         DSNAME = SUBSTR(DSNAME,1,K-1);     /* REMOVE (MEMBER) */
      END;
  IF ERR_FLAG = 'N'          /* ON ERROR SKIP REST OF PROCESSING    */
  THEN DO;
  /* ************************************************************** */
  /*                                                                */
  /*  REL 2.1.2 XA GIVES RC = 08 IF DATASET NAME ON LOCATE          */
  /*  IN FORMAT DSNAME(MEMNAME). REL 2.1.1 IGNORED MEMNAME AND      */
  /*  GAVE RC=0 IF DSNAME IN CATALOG.                               */
  /*                                                                */
  /* ************************************************************** */
          FUNC = 'I';        /* CHECK IF CATALOGED                  */
          CALL DSINFO(PARMS1);
          IF PLIRETV ^=0
          THEN DO;
                  MSGID = 'INV002  ';
                  ERR_FLAG = 'Y';
                  GO TO ENDPARS;
               END;
       END;
  ENDPARS: IF ERR_FLAG = 'N'
  THEN DO;
          IF PDSTEST = 'Y'
          THEN DO;
                  DSORG = 'XX';
                  CALL CHEKPDS;
                  IF DSORG ^= 'PO'
                  THEN DO;
                          MSGID = 'INV038 ';  /*ITSNOTAPDS  */
                          ERR_FLAG = 'Y';
                       END;
                  ELSE CALL CHEKMEM;
               END;
       END;
 END PARSE;
1
 CHEKPDS: PROC;
  /* ************************************************************** */
  /*                                                                */
  /* THIS SECTION RETURNS THE DSORG OF A DATASET.                   */
  /*                                                                */
  /* ************************************************************** */
  FUNC = 'I';               /* GET THE VOLUME INFO FROM CATALOG     */
  CALL DSINFO(PARMS1);
  IF PLIRETV = 0
  THEN DO;
          FUNC = 'L';        /* ACCESS THE VTOC                     */
          CALL DSINFO(PARMS1);
       END;
 END CHEKPDS;
 ISPF_DISP:  PROC;
  CALL ISPLINK('CONTROL', 'DISPLAY', 'LOCK ');
  CALL ISPLINK('DISPLAY', PANEL, MSGID ,'SOURCE  ');
  END ISPF_DISP;
1
 CHEKMEM: PROC;
  /* ************************************************************** */
  /*                                                                */
  /* WE WILL CHECK FOR MEMBER OF A PDS. CATALOG MANAGEMENT WILL     */
  /* TELL US IF THE WHOLE PDS IS OUT THERE BUT WILL NOT TELL US     */
  /* IF AN ACTUAL MEMBER IS IN THE PDS.                             */
  /* WE CAN GET THAT FROM DYNAMIC ALLOCATION ROUTINES AND OUR       */
  /* PDS MEMBER FINDER WHICH NEEDS A DDNAME OF WXYZ.                */
  /*                                                                */
  /* ************************************************************** */
  IF ERR_FLAG = 'N'
  THEN DO;
         K = INDEX(DSNAME,' ');
         K = K - 1;
         CALL DYNAM(WORK, 'ALLOC ', 'DSN='
         ×× SUBSTR(DSNAME,1,K)  ×× ' SHR;', 'DD=WXYZ;');
         IF MEM ^= ' '    /* WE COULD HAVE DSN(MEMBER) */
         THEN LIBNAME = MEM;
         MPARML = 8;
         FETCH INVFIND;
         CALL INVFIND(FORMEM);
         SAVERC = PLIRETV;
         RELEASE INVFIND;
         CALL DYNAM(WORK, 'UNALLOC ', 'DSN='
                    ×× SUBSTR(DSNAME,1,K) ×× ' KEEP;', 'DD=WXYZ;');
         IF SAVERC ^= 0
         THEN DO;
                 ERR_FLAG = 'Y';
                 MSGID = 'INV008';
              END;
       END;
  END CHEKMEM;
- /* ************************************************************** */
  /*                                                                */
  /*  THIS SUBROUTINE ISSUES THE APPROPRIATE ERROR MESSAGES         */
  /*                                                                */
  /* ************************************************************** */
 WRITEIT: PROC;
          PUT FILE(MSGFILE) EDIT (CONS)(A(80));
 END WRITEIT;
 GETOUT: PROC;
        TASKSDONE = '1'B;
        CONS = 'SYSTEM ABEND HAS OCCURRED   PROGRAM TERMINATING';
        CALL WRITEIT;
        ABEND_FLAG = '1'B;
        CALL ASM_DEALLOCATE;
        CALL LINK_DEALLOCATE;
        DEL = 'Y';
        CALL DELETE_LIST;
        STOP;
 END GETOUT;
 END INVASM2;
