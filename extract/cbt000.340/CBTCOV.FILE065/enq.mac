*          DATA SET MVSENQ     AT LEVEL 001 AS OF 07/21/75
         MACRO
&NAME    TSDERASE &N
&NAME    CALL CLR3270          USE SCREEN ERASE SUBROUTINE  *HMD 06/79*
         MEND
ENQ      TITLE 'ENQ - DISPLAY QUEUE STRUCTURE'
         MACRO
&NAME    TABLE &T,&G
         LCLA  &L
&L       SETA  K'&T-1
&NAME    DC    AL1(&L),AL3(&G),C'&T'
         MEND
         EJECT
***********************************************************************
*                                                                     *
*        ENQ USES THREE TABLES TO MAINTAIN STATUS INFORMATION         *
*        ABOUT THE ENQUEUE STRUCTURE.  THIS DATA IS COLLECTED DURING  *
*        THE DISABLED SCAN OF THE ENQUEUE CHAIN AND IS ACCESSED       *
*        DURING THE FORMAT/DISPLAY SECTION OF THE PROGRAM TO PROVIDE  *
*        THE ENQUEUE STRUCTURE INFORMATION                            *
*                                                                     *
*                                                                     *
*        THE TABLES THAT ARE USED ARE:                                *
*        QTABLE - INTERNAL FORMAT COPY OF THE ENQUEUE STRUCTURE       *
*        NTABLE - JOB AND STEP NAMES OF ENQUEUEING TASKS              *
*        XTABLE - MAINTAINS A CROSS REFERENCE BETWEEN QTABLE & NTABLE *
*                                                                     *
*                                                                     *
*        QTABLE IS STRUCTURED IN THE FOLLOWING MANER                  *
*                                                                     *
*        *********************************                            *
*        ×                               × MAJOR QCB NAME, X'FF' IF   *
*        ×   M A J O R    N A M E        × THE LAST ENTRY IN QTABLE   *
*        ×                               ×                            *
*        *********************************                            *
*        × F × L × P ×                   × FLG - X'80' = CONFLICT     *
*        × L × E × K ×                   ×     - X'FF' = LAST MINOR   *
*        × G × N × F ×    M × N O R      ×               QCB FOR THIS *
*        *************                   ×               MAJOR        *
*        ×                               × LEN - EX LEN OF MINOR NAME *
*        -                 N A M E       - PKF - COPY OF QCBPKF       *
*        ×                               ×                            *
*        *********************************                            *
*        × F × F × O  S  × F × F × O  S  × FL1 - COPY OF QELSMC X'01' *
*        × L × L × F  E  × L × L × F  E  ×       INDICATES TSO TASK   *
*        × 1 × 2 × F  T  × 1 × 2 × F  T  × FL2 - COPY OF QELTYP X'01' *
*        *********************************       INDICATES WAITING    *
*                                          OFFSET - IS THE OFFSET IN  *
*                                                   XTABLE FOR THE    *
*                                                   JOB/STEP NAMES    *
*                                                                     *
*        WITHIN QTABLE EACH LEVEL OF ENTRIES STARTS ON A DOUBLE       *
*        WORD BOUNDRY, E.G. THE ENTRY FOR A MINOR QUEUE NAME WILL     *
*        BE ROUNDED TO A DOUBLE WORD BOUNDRY BEFORE AND QEL'S ARE     *
*        INSERTED INTO THE TABLE.                                     *
*                                                                     *
*        ENTRY TYPES ARE TERMINATED AS FOLLOWS -                      *
*          MAJOR'S BY 8 BYTES OF X'FF' FOR A NAME                     *
*          MINORS'S BY A FLG FIELD OF X'FF'                           *
*          QEL'S BY A FL1 FIELD OF X'FF'                              *
*                                                                     *
***********************************************************************
         EJECT
***********************************************************************
*                                                                     *
*        XTABLE - CROSS REFERENCE OF QTABLE AND NTABLE                *
*                                                                     *
*                                                                     *
*        *********************************                            *
*        × TCB/TJID      × RES   × OFF   × TCB/TJID - FROM QEL        *
*        ×  BIT 0=1 IF   ×       ×  SET  × OFFSET - INTO NTABLE FOR   *
*        ×   TJID        ×       ×       ×          TASK IN QUESTION  *
*        *********************************                            *
*                                                                     *
*        THERE EXISTS ONE ENTRY IN XTABLE FOR EACH UNIQUE TCB ADDRESS *
*        OR TJID THAT IS DETECTED IN A QEL.  XTABLE IS MAINTAINED     *
*        IN REVERSE COLLATING SEQUENCE AND IS ACCESSED VIA A BINARY   *
*        LOOKUP TECHNIQUE.  WHEN A TCB/TJID IS ENCOUNTERED THAT DOES  *
*        NOT EXIST A NEW ENTRY IS MADE IN NTABLE AND THEN XTABLE IS   *
*        RESEQUENCED TO REFLECT THE NEW ENTRY.                        *
*                                                                     *
***********************************************************************
         EJECT
***********************************************************************
*                                                                     *
*        NTABLE - MAINTAIN JOB AND STEP NAMES ASSOCIATED WITH ENQ     *
*                                                                     *
*                                                                     *
*        ___________________________________                          *
*        ×                ×                ×  JOB NAME AND STEP       *
*        ×  JOB           ×  STEP          ×  NAME FROM TIOT OR       *
*        ×    NAME        ×    NAME        ×  TSO USERID AND JUNK     *
*        ×________________×________________×                          *
*                                                                     *
*        A NEW ENTRY IS PLACED IN NTABLE EACH TIME XTABLE IS SEARCHED *
*        AND NO MATCH IS FOUND.  FOR AN IN CORE TASK NTABLE CONTAINS  *
*        THE JOB AND STEP NAME FROM THE TIOT POINTED TO BY THE TCB    *
*        IN THE QEL.  FOR AN OUT OF CORE TASK (TSO) NTABLE CONTAINS   *
*        THE TSO USERID FROM THE TJB POINTED TO BY THE TJID IN        *
*        THE QEL.                                                     *
*                                                                     *
***********************************************************************
         EJECT
ENQ      TSBEGIN WORK=TSDUSIZE
ERASE1   TSDERASE                       DO AN ERASE
         LA    R0,1                     GET A CONSTANT
         ST    R0,OLD                   SET # OF SEGMENTS
         MVC   TSDGMAIN(LGMAIN),GMAIN   INIT THE GETMAIN LIST
         MVC   TSDSPIE(LSPIE),SPIE      INIT THE SPIE LIST
         BAL   RLINK,NEWQCORE           GET THE QTABLE
         BAL   RLINK,NEWNCORE           GET THE NTABLE & XTABLE
         LA    R1,TSDSPIE               GET THE LFORM ADDR
         SPIE  QUEUEBAD,MF=(E,(1))      ALLOW NO PROT EXCEPT.
         OI    FLAG1,$CNFL              1ST TIME TRY CONFLICTS
         EJECT
***********************************************************************
*                                                                     *
*        AT THIS POINT THE PROGRAM DISABLES FOR THE SCAN              *
*        OF THE QCB STRUCTURE, AND USES THE DATA OBTAINED TO BUILD    *
*        THE Q, N, AND X TABLES                                       *
*                                                                     *
***********************************************************************
         SPACE 3
SCAN     DS    0H
         BAL   RLINK,CLEARCOR           CLEAN THE TABLES
         XC    CURXREF,CURXREF          AND THE COUNT
         XC    CURNAME,CURNAME          AND THE OFFSET
         L     R5,XTABLE                -> XREF TABLE
         L     R6,QTABLE                -> QUEUE TABLE
         LR    R9,R6                    MAKE A COPY
         A     R9,QLEN                  -> END
*        SETPSW DISABLE                 TAKE AWAY THE MACHINE
         L     R1,16                    ->CVT
         LA    R2,640(,R1)              POINT TO QCB LIST ORIG
         USING QCBJ,R2
         USING QCBM,R3
         USING QEL,R4
         SPACE 2
         SPACE 2
MAJLOOP  DS    0H                        LOOP FOR MAJOR QCB'S
         L     R2,QCBJNEXT              GET NEXT MAJOR
         LTR   R2,R2                    END OF CHAIN ?
         BZ    ENDMAJ                   YES, GO FORMAT
         BAL   RLINK,ROUND              GET BOUNDRY IN W.A.
         MVC   0(8,R6),QCBJNAME         SAVE MAJOR NAME
         LA    R6,8(,R6)                -> TO NEXT SPOT
         L     R3,QCBJMIN               SETUP FOR MINORS
         B     MINLOOP1                 FURST TIME
         SPACE 1
MINLOOP  DS    0H                        LOOP FOR MINOR QCB'S
         SPACE 1
         L     R3,QCBMNEXT              GET NEXT MINOR QCB
MINLOOP1 LTR   R3,R3                    END OF CHAIN
         BZ    ENDMIN                   YES, GO DO NEXT MAJ
         BAL   RLINK,ROUND              GET BOUNDRY
         MVC   1(2,R6),QCBMLEN          GET LEN & FLAGS
         SR    R1,R1                    CLEAR FOR EX
         IC    R1,QCBMLEN               GET LEN FOR EX
         BCTR  R1,0                     GET EX LEN
         EX    R1,NAMEMVC               MOVE THE MINOR NAME
         LR    R7,R6                    SAVE PLACE IN TABLE
         LA    R6,4(R1,R6)              GET TO END OF DATA
         BAL   RLINK,ROUND              GET A BOUNDRY
         L     R4,QCBMQEL               SETUP FOR QEL SCAN
         SR    R8,R8                    ALSO SETUP
         B     QELLOOP1                 FIRST TIME
         SPACE 1
QELLOOP  DS    0H                        LOOP FOR ALL QEL'S
         SPACE 1
         L     R4,QELNEXT               GET NEXT QEL
QELLOOP1 LA    R4,0(,R4)                DELETE SMC DATA IF ANY
         LTR   R4,R4                    END OF QEL CHAIN
         BZ    ENDQEL                   YES, GO GET NEXT MIN
         MVC   1(1,R6),QELQFLGS         SAVE QEL FLAGS
         MVI   0(R6),0                  ZERO OTHER FLAGS
         TM    QELQFLGS,QELRESV         RESERVE?
         BZ    QELNORES
         L     R11,QELUCB
         ST    R11,4(,R6)               MOVE IN UCB ADDR
QELNORES DS    0H
         TM    QELQFLGS,X'80'           SHARED ENQ?
         BO    QELSHR                   YES, GO SHARE IT
         LTR   R8,R8                    ANY BODY HAVE THIS ONE
         BZ    QELGOT                   NO, MARK IT AS MINE
         LPR   R8,R8                    IN CASE OF SHARED REQUEST
         LA    R8,1(,R8)                MAKE IT PLUS
QELWAIT  DS    0H
         OI    0(R6),$WAIT              MARK QEL AS WAITING
         OI    0(R7),$MQCBCNF           MARK MINOR AS CONFLICT
         B     QELTSTTS                 GO SEE IF TSO
         SPACE 1
QELGOT   DS    0H
         LA    R8,1                     MARK RESOURCE IN USE
         B     QELTSTTS                 GO SEE IF TSO TASK
         SPACE 1
QELSHR   DS    0H
         LTR   R8,R8                    IS IT IN USE
         BP    QELWAIT                  YES, I MUST WAIT THEN
         BCTR  R8,0                     MARK AS SHARED
         SPACE 1
QELTSTTS DS    0H
         OI    1(R6),$TSO               MARK AS A TSO TASK
         LH    R0,QELASID               LOAD ASID
         SLL   R0,16                    SHIFT OFF BITS
         SPACE 1
         BAL   RLINK,GETOFF             GO GET AN OFFSET
         STH   R0,2(,R6)                PUT OFFSET IN LIST
         LA    R6,8(,R6)                POINT TO NEXT SLOT
         CR    R6,R9                    OUT OF CORE YET
         BNL   NOCORE                   YES, GO GIVE UP
         B     QELLOOP                  GO GET NEXT QEL
         SPACE 2
ENDQEL   DS    0H
         MVC   0(2,R6),ENDLIST          MARK THE END
         LA    R6,8(,R6)                POINT TO NEXT SLOT
         B     MINLOOP                  GO GET NEXT MINOR
         SPACE 2
ENDMIN   DS    0H
         BAL   RLINK,ROUND              GET A BOUNDRY
         MVC   0(2,R6),ENDLIST          MARK THE END
         LA    R6,2(,R6)                TO FORCE A NEW BOUNDRY
         B     MAJLOOP                  GO GET NEXT MAJOR
         SPACE 2
ENDMAJ   DS    0H
*        SETPSW ENABLE                  GIVE THE MACHINE BACK
         BAL   RLINK,ROUND              GET A BOUNDRY
         MVC   0(8,R6),ENDLIST          MARK THE END
         B     FORMAT                   GO FORMAT THE STRUCTURE
         SPACE 2
NAMEMVC  MVC   3(0,R6),QCBMNAME         << EXECUTED >>
         SPACE 3
         DROP  R2,R3,R4
         EJECT
***********************************************************************
*                                                                     *
*        THIS CODE MAINTAINS THE TWO TABLES USED BY ENQ               *
*                                                                     *
***********************************************************************
         SPACE 2
ROUND    DS    0H
         LA    R6,7(,R6)                FORCE TO HIGHER DBLWORD
         SRL   R6,3                     SHIFT OFF SLOP
         SLL   R6,3                     AND RESTORE
         CR    R6,R9                    OUT OF CORE YET ?
         BNL   NOCORE                   YES, GO DIE
         BR    RLINK
         SPACE 5
GETOFF   DS    0H
         ST    R8,DWORK                 SAVE A TEMP REG
         LH    R1,CURXREF               GET CURRENT HIGH
         LA    R1,1(,R1)                MAKE THE NUMBER EVEN
         SR    R15,R15                  INIT ENTRY POINTER
         SPACE 1
GETLOW   DS    0H
         LR    R14,R15                  SET LOW LIMIT
         SPACE 1
GETHIGH  DS    0H
         LA    R15,0(R14,R1)            GET NEW ENTRY POINTER
         SRL   R15,1                    -> MIDDLE
         CR    R15,R14                  ENTRY = LOW
         BE    GETADD                   YES, IT'S NEW THEN
         LR    R8,R15                   COPY ENTRY ->
         BCTR  R8,0                     DOWN BY ONE
         SLL   R8,3                     TIMES 8
         LA    R8,0(R8,R5)              GET REAL ADDR
         CL    R0,0(,R8)                IS THIS THE ONE ?
         BL    GETLOW                   NO, GO HIGHER
         LR    R1,R15                   SET NEW HIGH POINT
         BH    GETHIGH                  NO, TRY LOWER
         LR    R15,R8                   SETUP FOR LOAD
GETRET   DS    0H                        HAVE MATCH ON TCB/TJID
         LH    R0,6(,R15)               GET OFFSET INTO NTABLE
         L     R8,DWORK                 RESTORE WORK REG
         BR    RLINK                    RETURN TO QCB SCAN
         SPACE 3
GETADD   DS    0H
         LA    R14,8                    GET A CONSTANT
         LH    R1,CURXREF               GET CURRENT # IN XTABLE
         LA    R1,1(,R1)                PLUS THE ONE TO BE ADDED
         STH   R1,CURXREF               BACK TO CORE
         CH    R1,MAXXREF               AM I OVER TABLE SIZE ?
         BH    NOXCORE                  YES, GO FIX US UP
         LR    R15,R5                   GET START OF XTABLE
         SLL   R1,3                     GET OFFSET TO END OF XTABLE
         AR    R15,R1                   GET A REAL ADDR
         SPACE 1
GETCHECK DS    0H
         CL    R0,0(,R15)               DOES IT GO HERE ?
         BH    GETSHIFT                 NO, GO MOVE TABLE ENTRIES
         BE    PGMERR                   IF HERE IT'S A DISASTER
         SPACE 1
GETFORCE DS    0H
         AR    R15,R14                  ADD 8 TO -> TO GOOD ONE
         ST    R0,0(,R15)               SAVE THE TCB/TJID ENTRY
         LH    R14,CURNAME              GET CURRENT OFFSET INTO NTABLE
         LR    R1,R0                    COPY THE BLOCK POINTER
         STH   R14,6(,R15)              PUT OFFSET IN XTABLE
         LA    R0,16(,R14)              -> NEXT SLOT FOR LATTER
         STH   R0,CURNAME               AND UPDATE CORE
         A     R14,NTABLE               GET REAL ADDR
         SLL   R1,1                     SHIFT OFF INDICATOR
         SRL   R1,17                    MAKE IT A ASID
         LTR   R1,R1                    CHECK FOR NULL ASID
         BNP   GOTBADN
         LR    R0,R1                    SAVE IT
         L     R1,16                    FIND CVT
         L     R1,X'22C'(,R1)           FIND ASVT
         LA    R1,X'20C'(,R1)           POINT TO START OF VECS
         SLL   R0,2                     MULT BY FOUR
         AR    R1,R0                    POINT TO ASCB ENTRY
         L     R1,0(,R1)                POINT TO ASCB
         ICM   R0,B'1111',172(R1)       CHECK FOR JOBNAME
         BNZ   GOTID
         ICM   R0,B'1111',176(R1)       ELSE S/M/L NAME
         BZ    GOTBADN
GOTID    LR    R1,R0
         MVC   0(8,R14),0(R1)           COPY THE USERID
         B     GETRET                   RETURN TO CALLER
GOTBADN  MVC   0(8,R14),=CL8'*UNKNOWN'
         B     GETRET
         SPACE 3
GETSHIFT DS    0H
         MVC   8(8,R15),0(R15)          SHIFT UP IN TABLE
         SR    R15,R14                  GO DOWN IN TABLE
         CR    R15,R5                   CHECK THE START OF TABLE
         BL    GETFORCE                 FORCE TO FIRST ENTRY
         B     GETCHECK                 GO TRY AGAIN
         SPACE 3
PGMERR   DS    0H
*        SETPSW ENABLE
         EX    0,*                      A NICE PRECISE 0C3
         EJECT
NOCORE   DS    0H                        HERE FOR NO CORE IN QTABLE
*        SETPSW ENABLE                  LET THE MACHINE GO
         BAL   RLINK,GETQCORE           GET MORE CORE FOR QTABLE
         B     SCAN                     THEN RETRY IT
         SPACE 5
NOXCORE  DS    0H                        NO CORE IN NTABLE/XTABLE
*        SETPSW ENABLE                  GIVE THE MACHINE BACK
         BAL   RLINK,GETNCORE           GET CORE FOR N/X TABLES
         B     SCAN                     AND TRY AGAIN
         EJECT
***********************************************************************
*                                                                     *
*        FORMAT THE TABELED ENQUEUE STRUCTURE                         *
*              THIS ROUTINE CONSTRUCTS THE LINE TO BE SENT TO THE     *
*              TERMINAL, AND PERFORMS THE REQUIRED SELECTION (AS      *
*              DETERMINED BY THE COMMAND SCAN SECTION) OF OUTSTANDING *
*              ENQUEUE REQUESTS                                       *
*                                                                     *
***********************************************************************
         SPACE 3
FORMAT   DS    0H
         L     R10,NTABLE               -> JOB NAME/USERID TABLE
         L     R6,QTABLE                -> ENQUEUE STRUCTURE TABLE
         SPACE 1
FMAJLOOP DS    0H                        MAJOR NAME LOOP
         MVI   LINE,C' '                START THE CLEAR
         MVC   LINE+1(L'LINE-1),LINE  FINISH IT
         BAL   RLINK,FROUND             GET THE NEXT MAJOR NAME
         CLC   0(8,R6),ENDLIST          END OF THE TABLE
         BE    COMGET                   YES, GO GET A COMMAND
         MVC   LJNAME,0(R6)             MOVE MAJOR NAME TO LINE
         LA    R6,8(,R6)                -> PAST THIS ENTRY
         SPACE 1
FMINLOOP DS    0H                        MINOR NAME LOOP
         BAL   RLINK,FROUND             GET UP TO NEXT ENTRY
         CLC   0(2,R6),ENDLIST          END OF MINOR NAME ?
         BE    FMINEND                  YES, GO TERMINATE MINOR
         LR    R3,R6                    SAVE THE LOCATION
         MVI   LMNAME,C' '              START CLEAR OF NAME IN LINE
         MVC   LMNAME+1(L'LMNAME-1),LMNAME   FINISH THE CLEAR
         SR    R1,R1                    CLEAR FOR INSERT
         IC    R1,1(,R6)                GET THE LEN OF MINOR NAME
         CH    R1,LMNMAX                OVER MY MAX LEN ?
         BNH   FMINMOVE                 NO, DON'T FORCE IT
         LH    R1,LMNMAX                SET TO MY MAX
FMINMOVE DS    0H
         BCTR  R1,0                     -1 FOR EXECUTED MVC
         EX    R1,FMINMVC               MOVE MINOR NAME TO LINE
         LR    R11,R1                   SAVE ORIGINAL LENGTH
         TRT   3(0,R6),TRTMN            CHECK FOR UNPRINT
         EX    R11,*-6
         BZ    FMINDONE                 NONE, PRINT AS CHAR
         SPACE 1
         LA    R5,3(,R6)                STARTING ADDR OF QCB NAME
         LA    R4,1                     BXLE INCREMENT
         LR    R7,R1                    STARTING ADDRESS
         SR    R7,R5                    GET GOOD CHAR LEN
         LA    R7,LMNAME(R7)            OUTPUT AREA ADDRESS
         LA    R5,0(R11,R5)             END OF STRING
         MVC   0(3,R7),=C' X'''
         LA    R7,3(,R7)
         SPACE 1
HEXLOOP  UNPK  DWORK(3),0(2,R1)
         MVC   0(2,R7),DWORK
         TR    0(2,R7),HEXTAB
         LA    R7,2(,R7)
         BXLE  R1,R4,HEXLOOP
         SPACE 1
         MVI   0(R7),C''''
FMINDONE LR    R1,R11                   REST ORIGINAL LENGTH
         LA    R6,4(R1,R6)              POINT PAST MINOR NAME
         BAL   RLINK,FROUND             POINT TO FIRST QEL
         SR    R5,R5                    SO I CAN REMEMBER
         SPACE 1
FQELLOOP DS    0H                        FORMAT QEL'S LOOP
         CLC   0(2,R6),ENDLIST          END OF ALL QEL'S FOR MINOR
         BE    FQELEND                  YES, THEN QUIT
         LH    R8,2(,R6)                GET THE OFFSET
         AR    R8,R10                   GET REAL ADDR
         TM    FLAG1,$GLOBAL            AM I TO DO EVERYTHING ?
         BO    DOLINE                   YES, THEN GET AT IT
         TM    FLAG1,$CNFL              CONFLICT CHECKING ?
         BNO   FQELCKF                  NO, THEN GO CHECK FINDS
         TM    0(R3),$MQCBCNF           ANY CONFLICTS ?
         BNO   FQELNEXT                 NO, THEN SKIP TO NEXT QEL
         B     DOLINE                   GO DISPLAY CONFLICTS
         SPACE 1
FQELCKF  DS    0H                        TEST FOR FINDS
         TM    FLAG1,$FIND              IS IT A FIND REQUEST ?
         BO    FQELFIND                 YES, KEEP GOING
         EX    0,*                      PGM ERROR, CAN'T BE HERE
         SPACE 1
FQELFIND DS    0H
         TM    FLAG2,$FMAJ              FIND ON MAJOR NAME ?
         BNO   FQELFMIN                 NO, GO TEST FOR MINOR
         LH    R1,FMAJLEN               GET THE COMPARE LEN
         EX    R1,FMAJCLC               SEE IF THIS MAJOR NAME
         BNE   FQELNEXT                 NO, THE SKIP TO NEXT QEL
FQELFMIN DS    0H
         TM    FLAG2,$FMIN              CHECK FOR MINOR NAME ?
         BNO   FQELFJOB                 NO, GO CHECK FOR JOB NAME
         LH    R1,FMINLEN               GET THE COMPARE LEN
         EX    R1,FMINCLC               SEE IF THIS MINOR NAME
         BNE   FQELNEXT                 NO, GO GET NEXT QEL
FQELFJOB DS    0H
         TM    FLAG2,$FJOB              FIND ON JOB NAME ?
         BNO   DOLINE                   NO, THEN GO DISPLAY LINE
         LH    R14,FJOBLEN              GET LEN TO COMPARE
         EX    R14,FJOBCLC              IS THIS THE ONE ?
         BNE   FQELNEXT                 NO, THEN GET NEXT QEL
         SPACE 2
DOLINE   DS    0H
         MVC   LJOB,0(R8)               MOVE JOB NAME TO LINE
         MVI   LSCOPE,#SYS              ASSUME SYSTEM WIDE ENQ
         TM    2(R3),X'20'              IS MINOR QCB SYSTEM WIDE
         BZ    FQELSYS                  YES, SKIP NEXT MOVE
         MVI   LSCOPE,#STEP             MARK AS STEP WIDE ONLY
FQELSYS  DS    0H
         MVI   LTYPE,#SHR               ASSUME A SHARED ENQ
         TM    1(R6),X'80'              IS THIS QEL SHARED ?
         BO    FQELSHR                  YES, THEN SKIP THE MOVE
         MVI   LTYPE,#EXC               MARK AS NON-SHARED REQUEST
FQELSHR  DS    0H
         MVI   LHAS,#GOT                ASSUME HE HAS RESOURCE
         TM    0(R6),$WAIT              IS HE WAITING ?
         BNO   FQELGOT                  NO, SKIP TO NEXT TEST
         MVI   LHAS,#WAIT               MARK AS WAITING
FQELGOT  DS    0H
         MVI   LSYS,C' '                ASSUME NOT RESERVE
         TM    1(R6),X'10'              IS THIS A RESERVE ?
         BNO   FQELRES                  NO, SKIP TO THE NEXT ONE
         MVI   LSYS,#RES                MARK AS A RESERVE
         L     R11,4(,R6)              MOVE IN UCB VOL SER
         MVC   LUCB(6),28(R11)         MOVE IN UCB VOL SER
         MVC   LUCB+7(3),13(R11)       MOVE IN DEVICE ADDR
         MVI   LUCB+6,C'-'
FQELRES  DS    0H
         LA    R9,LINE                  -> TO OUTPUT LINE
         TPUT  (R9),L'LINE              SEND IT TO TERMINAL
         SPACE 3
FQELNEXT DS    0H
         LA    R6,8(,R6)                -> NEXT QEL ENTRY
         B     FQELLOOP                 GO TRY TO DO IT
         SPACE 3
FQELEND  DS    0H
         LA    R6,8(,R6)                TO STAY CONSISTENT
         B     FMINLOOP                 GO TRY NEXT MINOR NAME
         SPACE 3
FMINEND  DS    0H
         LA    R6,8(,R6)                TO STAY CONSISTENT
         B     FMAJLOOP                 GO DO THE MAJORS
         SPACE 5
FMAJCLC  CLC   FMAJ(0),LJNAME           << EXECUTED >>
FMINCLC  CLC   FMIN(0),LMNAME           << EXECUTED >>
FJOBCLC  CLC   FJOB(0),0(R8)            << EXECUTED >>
FMINMVC  MVC   LMNAME(0),3(R6)          << EXECUTED >>
         SPACE 3
FROUND   DS    0H
         LA    R6,7(,R6)                FORCE TO HIGH DOUBLE WORD
         SRL   R6,3                     SHIFT OFF THE SLOP
         SLL   R6,3                     BACK TO A REAL NUMBER
         BR    RLINK
         EJECT
***********************************************************************
*                                                                     *
*        ASK THE USER FOR A COMMAND.  WHEN YOU GET ONE SEARCH THE     *
*        COMMAND TABLE FOR A MATCH, IF NO MATCH ASK HIM AGAIN,        *
*        IF YOU GET A HIT GO PROCESS THE COMMAND                      *
*                                                                     *
***********************************************************************
         SPACE 3
COMGET   DS    0H
         LA    R1,MSGMODE               GET MY MODE MSG
         ST    R1,OLD+4                 AND PUT IT IN THE OLD
         L     R15,TSDAPTGT             GET EPA OF IKJPTGT
         LA    R1,IOPL                  GET THE IO PARM LIST
*        TELL USER WE WANT INPUT AND WAIT FOR HIM TO TALK
         PUTGET PARM=PGPB,OUTPUT=(OLD,,MODE),ENTRY=(15),               +
               TERMGET=(EDIT),MF=(E,(1))
         CH    R15,=H'4'                A BAD ERROR ?
         BH    EXIT                     YES, THE GIVE UP
ERASE2   TSDERASE
         L     R1,PGPBIBUF              GET COMMAND BUFFER
         ST    R1,CSPLCBUF              INTO THE LIST
         LA    R1,CSPL                  -> LIST
         L     R15,TSDASCAN             GET EPA OF IKJSCAN
         BALR  R14,R15                  GO SCAN THE COMMAND
*        INVOKE IKJSCAN TO FORMAT THE COMMAND BUFFER
         LTR   R15,R15                  CHECK RETURN FROM IKJSCAN
         BNZ   SCANERR                  AND ERROR IS A BAD ONE
         CLI   CSOAFLG,X'10'            IS BUFFER EMPTY ?
         BE    AGAIN                    YES, THE GO FREE UP & CONTINUE
         TM    CSOAFLG,X'28'            IS THERE A VALID COM THERE
         BNZ   COMINVL                  NO, THEN TELL USER
         L     R1,CSOACNM               GET THE COMMAND ADDR
         LH    R0,CSOALNM               GET THE LEN OF THE NAME
         BCTR  R0,0                     REDUCE IT FOR TEST
         LA    R15,COMTAB               -> TABLE OF VALID COMMANDS
         SR    R14,R14                  CLEAR A WORK REG
COMLOOP  DS    0H
         IC    R14,0(,R15)              GET EX LEN OF COMMAND
         CR    R14,R0                   ARE THEY THE SAME
         BNE   COMNEXT                  NO, GO TRY THE NEXT ONE
         EX    R14,COMCLC               CHECK THE TEXT
         BE    COMHAVE                  = IS A HIT ON THE COMMAND
COMNEXT  DS    0H
         LA    R15,5(R14,R15)           POINT TO NEXT COMMAND
         CLI   0(R15),XFF               END OF TABLE ?
         BE    COMINVL                  YES, THEN INVALID COMMAND
         B     COMLOOP                  GO TRY NEXT ONE
         SPACE 2
COMHAVE  DS    0H
         MVC   DWORK(4),0(R15)          GET ADDR OF COMMAND
         L     R15,DWORK                SO I CAN USE IT
         BR    R15                      GO PROCESS THE COMMAND
         SPACE 3
COMCLC   CLC   4(0,R15),0(R1) << EXECUTED >>
         SPACE 3
COMINVL  DS    0H                        INVALID COMMAND ENTERED
         LA    R1,MSGCOM                GET INVVALID MSG
         ST    R1,OLD+4                 PUT IT IN THE OLD
         LA    R1,IOPL                  GET THE LIST ADDR
         PUTLINE PARM=PTPB,OUTPUT=OLD,MF=(E,(1)) TELL THE USER
         LTR   R15,R15                  DID IT WORK ?
         BNZ   EXIT                     NO, THEN QUIT
         B     COMGET                   GO TRY AGAIN
         SPACE 3
SCANERR  DS    0H
         EX    0,*                      DIE A LOT
         EJECT
CONFL    DS    0H                        CONFLICT COMMAND
         XC    FLAGS,FLAGS              CLEAN UP
         OI    FLAG1,$CNFL              SET CONFLICT SCAN
         B     AGAIN                    AND CONTINUE
         SPACE 3
GLOBAL   DS    0H                        GLOBAL COMMAND
         XC    FLAGS,FLAGS              CLEAN UP
         OI    FLAG1,$GLOBAL            SET FOR GLOBAL SCAN
         B     AGAIN                    AND GO DO IT
         SPACE 3
FIND     DS    0H                        FIND COMMAND
         XC    FLAGS,FLAGS              CLEAN UP
         OI    FLAG1,$FIND              INDICATE FIND OPERATION
         TSPARSE CBUF=PGPBIBUF,PCL==V(PCL),ENTRY=TSDAPARS
         LTR   R15,R15                  DID THE PARSE GO ?
         BNZ   EXIT                     NO, THEN QUIT
         L     R1,TSDPANS               GET THE ANSWER PLACE
         USING IKJPARMD,R1              MAKE IT ADDRESSABLE
         LH    R14,PARMAJ+4             GET LEN OF MAJOR GIVEN
         LTR   R14,R14                  ANY NAME ?
         BZ    FINDMIN                  NO, GO GET MINOR
         L     R15,PARMAJ               GET ADDR OF TEXT
         BCTR  R14,0                    CHECK FOR LEN OF 1
         LTR   R14,R14                  IS THE LEN ONE
         BZ    FINDJ@                   YES, GO CHECK FOR '*'
FINDJ#   DS    0H
         LA    R2,FMAJ                  GET RECEIVING FIELD
         EX    R14,FINDMVC              MOVE THE NAME
         STH   R14,FMAJLEN              SAVE THE LEN
         OI    FLAG2,$FMAJ              INDICATE FIND ON MAJOR NAME
         B     FINDMIN                  GO CHECK MINOR
         SPACE 1
FINDJ@   DS    0H
         CLI   0(R15),C'*'              ACCEPT ANY MAJOR NAME ?
         BNE   FINDJ#                   NO, MUST BE REAL NAME
         SPACE 2
FINDMIN  DS    0H
         LH    R14,PARMIN+4             GET THE LEN OF MINOR NAME
         LTR   R14,R14                  IS IT OMITTED ?
         BZ    FINDJOB                  YES, GO CHECK JOB NAME
         L     R15,PARMIN               GET TEXT ADDR
         BCTR  R14,0                    DOWN BY ONE
         LTR   R14,R14                  IS LEN ONE
         BZ    FINDM@                   YES, GO CHECK SPECIAL CASE
FINDM#   DS    0H
         LA    R2,FMIN                  GET RECEIVVING FIELD
         EX    R14,FINDMVC              MOVE THE TEXT
         STH   R14,FMINLEN              SAVE THE LEN
         OI    FLAG2,$FMIN              SET FIND ON MINOR NAME
         B     FINDJOB                  GO CHECK JOB NAME
         SPACE 1
FINDM@   DS    0H
         CLI   0(R15),C'*'              ALLOW ANY MINOR NAME ?
         BNE   FINDM#                   NO, GO MOVE NAME
         SPACE 2
FINDJOB  DS    0H
         LH    R14,PARJOB+4             GET LEN OF JOB NAME
         LTR   R14,R14                  WAS ONE GIVEN
         BZ    FINDEND                  NO, GO TO END OF PARSE
         L     R15,PARJOB               GET TEXT ADDR
         BCTR  R14,0                    DOWN BY ONE
         LTR   R14,R14                  IS THE LEN ONE
         BZ    FINDN@                   YES, GO CHECK SPECIAL CASE
FINDN#   DS    0H
         LA    R2,FJOB                  GET TARGET FIELD
         EX    R14,FINDMVC              MOVE THE JOB NAME
         STH   R14,FJOBLEN              SAVE FOR LATTER
         OI    FLAG2,$FJOB              MARK AS FIND JOB NAME
         B     FINDEND                  AND GO FINISH PARSE
         SPACE 1
FINDN@   DS    0H
         CLI   0(R15),C'*'              ACCEPT ANY JOB NAME ?
         BNE   FINDN#                   NO, GO MOVE NAME
         SPACE 2
FINDEND  DS    0H
         IKJRLSA (1)                    FREE THE PDL
         SPACE 3
AGAIN    DS    0H
         L     R1,PGPBIBUF              GET COMMAND BUFFER
         LH    R0,0(,R1)                GET LEN OF BUFFER
         O     R0,=AL1(1,0,0,0)         MAKE IF SUB POOL 1
         FREEMAIN R,LV=(0),A=(1)        GIVE BACK BUFFER
         B     SCAN                     AND GO TRY IT AGAIN
         SPACE 2
FINDMVC  MVC   0(0,R2),0(R15)           << EXECUTED >>
         EJECT
GETQCORE DS    0H
         L     R1,QTABLE                GET CURRENT ADDR
         L     R0,QLEN                  GET CURRENT LENGTH
         O     R0,=AL1(2,0,0,0)         MAKE SUBPOOL 2      *HMD 04/82*
         FREEMAIN R,LV=(0),A=(1)        GIVE IT BACK
         SPACE 1
NEWQCORE DS    0H
         L     R3,QLEN                  GET CURRENT LEN
         A     R3,QINCR                 ADD THE INCREMENT   *HMD 04/82*
         BC    5,QUITCORE               NOT OVERFLOW/MINUS  *HMD 04/82*
         ST    R3,QLEN                  UPDATE THE REAL ONE
         LA    R4,QTABLE                POINT TO AREA
         XC    QTABLE,QTABLE            ZERO JUST IN CASE
         LA    R1,TSDGMAIN              GET LIST
         GETMAIN EC,LV=(R3),SP=2,A=(R4),MF=(E,(1))          *HMD 04/82*
         LTR   R15,R15                  DIDI I GET IT ?
         BNZ   QUITCORE                 NO, THEN GIVE IT UP
         BR    RLINK                    GO BACK
         SPACE 5
GETNCORE DS    0H
         L     R1,NTABLE                GET CURRENT ADDR
         L     R0,NLEN                  GET CURRENT LEN
         O     R0,=AL1(2,0,0,0)         MAKE SUBPOOL 2      *HMD 04/82*
         FREEMAIN R,LV=(0),A=(1)        GIVE IT BACK
NEWNCORE DS    0H
         L     R3,NLEN                  GET CURRENT LEN
         A     R3,NINCR                 UP BY THE INCREMENT *HMD 04/82*
         BC    5,QUITCORE               NOT OVERFLOW/MINUS  *HMD 04/82*
         ST    R3,NLEN                  UPDATE THE REAL ONE
         LA    R4,NTABLE                GET AREA
         XC    NTABLE,NTABLE            IN CASE OF FAILURE
         LA    R1,TSDGMAIN              GET THE LIST
         GETMAIN EC,LV=(R3),SP=2,A=(R4),MF=(E,(1))          *HMD 04/82*
         LTR   R15,R15                  DID I GET IT
         BNZ   QUITCORE                 NO, THEN GO FAIL
         SR    R2,R2                    CLEAR FOR DIVIDE
         LA    R15,24                   NUMBER OF BYTES PER ENTRY
         DR    R2,R15                   GET # OF ENTRIES
         STH   R3,MAXXREF               SAVE THE # OF ENTRIES
         LA    R15,16                   SIZE OF NTABLE ENTRY
         MR    R2,R15                   GET END OF NTABLE
         A     R3,NTABLE                GET REAL START OF XTABLE
         ST    R3,XTABLE                SAVE THE ADDR
         BR    RLINK                    RETURN TO CALLER
         SPACE 5
CLEARCOR DS    0H
         L     R14,QLEN                 GET LEN OF QTABLE
         L     R15,QTABLE               GET START OF QTABLE
         B     CLEARE1                  JUMP INTO IT
CLEARLP1 DS    0H
         XC    0(256,R15),0(R15)        CLEAR SOME CORE
         LA    R15,256(R15)             -> TO NEXT CHUNK
CLEARE1  DS    0H
         SH    R14,*-2                  BE CAREFUL
         BP    CLEARLP1                 BR IF MORE TO CLEAR
         AH    R14,=H'255'              BRING IT BACK
         EX    R14,CLEARXC              FINISH THE CLEAR
         L     R14,NLEN                 GET LEN OF NTABLE
         L     R15,NTABLE               GET ADDR OF NTABLE
         B     CLEARE2                  JUMP INTO IT
CLEARLP2 DS    0H
         XC    0(256,R15),0(R15)        CLEAR A BUNCH OF CORE
         LA    R15,256(R15)             -> NEXT CHUNK
CLEARE2  DS    0H
         SH    R14,*-2                  BE CAREFUL
         BP    CLEARLP2                 GO CLEAR SOME MORE
         AH    R14,=H'255'              ADJUST FOR LAST CLEAR
         EX    R14,CLEARXC              CLEAR FINAL CORE
         BR    RLINK                    RETURN
         SPACE 1
CLEARXC  XC    0(0,R15),0(R15)          << EXECUTED >>
         SPACE 4
         USING QUEUEBAD,R15             FROM SPIE
QUEUEBAD DS    0H
         LA    R0,BADQUEUE              GET ERROR ADDR
         ST    R0,8(,R1)                PUT IN RESTORE PSW
         BR    R14                      BACK TO SPIE
         DROP  R15
         SPACE 2
BADQUEUE DS    0H
*        SETPSW ENABLE
         LA    R1,MSGQUE                GET BAD QUEUE MSG
         ST    R1,OLD+4                 & PUT IT IN THE OLD
PUTLINE  DS    0H
         LA    R1,IOPL                  GET THE LIST ADDR
         PUTLINE PARM=PTPB,OUTPUT=OLD,MF=(E,(1))  WRITE THE LINE
         B     COMGET                   THEN TRY AGAIN
         SPACE 3
QUITCORE DS    0H
         LA    R1,MSGCORE               GET OUT OF CORE MSG
         ST    R1,OLD+4                 PUT IT IN THE OLD
         B     PUTLINE                  THEN GO DO IT
         EJECT
EXIT     DS    0H
         L     R1,QTABLE      GET QTABLE ADDR
         LTR   R1,R1          IS THERE ONE ?
         BZ    NOQFREE        NO, THEN SKIP FREE
         L     R0,QLEN        GET CURRENT LENGTH
         O     R0,=AL1(2,0,0,0)         MAKE SUBPOOL 2      *HMD 04/82*
         FREEMAIN R,LV=(0),A=(1)        GIVE BACK THE CORE
NOQFREE  DS    0H
         L     R1,NTABLE                GET NTABLE ADDR
         LTR   R1,R1                    IS THERE ONE ?
         BZ    NONFREE                  NO, THEN DON'T FREE IT
         L     R0,NLEN                  GET CURRENT LEN
         O     R0,=AL1(2,0,0,0)         MAKE SUBPOOL 2      *HMD 04/82*
         FREEMAIN R,LV=(0),A=(1)        GIVE BACK CORE
NONFREE  DS    0H
         TSFINISH RC=0                  GO HOME
         TSDSECT NODAPL,NOADAIR,NOSAV2,PGPB,PTPB,ASCAN,NODAPB,NODAECB
         TSDSECT AIOPG,APARS,CSPL,GEN=YES
         EJECT
GMAIN    GETMAIN EC,A=0,LV=0,MF=L
LGMAIN   EQU   *-GMAIN
SPIE     SPIE  0,(4,5),MF=L
LSPIE    EQU   *-SPIE
TSOSTEP  DC    CL8'TSOLOGON'
ENDLIST  DC    8X'FF'
LMNMAX   DC    Y(L'LMNAME)
QINCR    DC    A(1024*260)        GET ENOUGH CORE           *HMD 04/82*
NINCR    DC    A(1000*48)         GET ENOUGH CORE           *HMD 04/82*
         SPACE 3
MSGCORE  DC    AL2(LMSGCORE,0),C' INSUFFICIENT CORE TO PROCESS'
LMSGCORE EQU   *-MSGCORE
MSGQUE   DC    AL2(LMSGQUE,0),C' ERROR IN QUEUE STRUCTURE'
         DC    C' OR SOMETHING MOVED, TRY AGAIN'
LMSGQUE  EQU   *-MSGQUE
MSGCOM   DC    AL2(LMSGCOM,0),C' INVALID COMMAND'
LMSGCOM  EQU   *-MSGCOM
MSGMODE  DC    AL2(LMSGMODE,0),C' ENQ'
LMSGMODE EQU   *-MSGMODE
         SPACE 3
COMTAB   TABLE FIND,FIND
         TABLE F,FIND
         TABLE CONFLICT,CONFL
         TABLE C,CONFL
         TABLE GLOBAL,GLOBAL
         TABLE G,GLOBAL
         TABLE END,EXIT
         TABLE E,EXIT
         DC    X'FF'
         SPACE 2
$WAIT    EQU   X'01'
$TSO     EQU   X'01'
$MQCBCNF EQU   X'80'
XFF      EQU   X'FF'
         SPACE 2
         LTORG
         SPACE 2
HEXTAB   EQU   *-C'0'
         DC    C'0123456789ABCDEF'
         SPACE 1
TRTMN    DC    256X'FF'                 TABLE FOR XLATE AND TEST
         ORG   TRTMN+C' '
         DC    X'00'
         ORG   TRTMN+C'.'
         DC    6X'00'
         ORG   TRTMN+C'$'
         DC    7X'00'
         ORG   TRTMN+C','
         DC    5X'00'
         ORG   TRTMN+C':'
         DC    5X'00'
         ORG   TRTMN+C'A'
         DC    9X'00'
         ORG   TRTMN+C'J'
         DC    9X'00'
         ORG   TRTMN+C'S'
         DC    8X'00'
         ORG   TRTMN+C'0'
         DC    10X'00'
         ORG
         EJECT
PCL      IKJPARM
         SPACE 1
PARMAJ   IKJIDENT 'MAJOR NAME',ASTERISK,MAXLNTH=8,FIRST=ANY,           *
               OTHER=ANY,DEFAULT='*'
         SPACE 2
PARMIN   IKJIDENT 'MINOR NAME',ASTERISK,MAXLNTH=47,FIRST=ANY,          *
               OTHER=ANY,DEFAULT='*'
         SPACE 2
PARJOB   IKJIDENT 'JOB NAME',ASTERISK,MAXLNTH=8,FIRST=ANY,             *
               OTHER=ANY,DEFAULT='*'
         SPACE 2
         IKJENDP
         SPACE
         EJECT
QCBJ     DSECT
QCBJNEXT DS    A                        -> NEXT MAJOR QCB
QCBJLAST DS    A                        -> TO PREVIOUS MAJOR QCB
QCBJMIN  DS    A                        -> TO FIRST MINOR QCB ON MAJOR
QCBJLMIN DS    A                        -> TO LAST  MINOR QCB ON MAJOR
QCBJNAME DS    CL8                      MAJOR QUEUE NAME
         SPACE 3
QCBM     DSECT ,                        MAP THE MINOR QCB
QCBMNEXT DS    A                        -> TO NEXT MINOR QCB
QCBMLAST DS    A                        -> TO PREVIOUS MINOR QCB
QCBMQEL  DS    A                        -> FIRST QEL ON MINOR QCB
QCBMLQEL DS    A                        -> LAST  QEL ON MINOR QCB
QCBMLEN  DS    C                        LEN OF MINOR QUEUE NAME
QCBMPKF  DS    C                        SCOPE OF ENQ
MINSYS   EQU   B'10000000'              SCOPE OF SYSTEM
MINSYSS  EQU   B'01000000'              SCOPE OF SYSTEMS
MINSTEP  EQU   B'00100000'              SCOPE OF STEP
MINNOENQ EQU   B'00010000'              NO ENQS ALLOWED (FRR)
QCBMASID DS    CL2                      ASID (STEP ONLY)
QCBMNAME DS    CL255                    MINOR QUEUE NAME
         SPACE 3
QEL      DSECT ,                        MAP THE QEL
QELNEXT  DS    A                        -> TO NEXT QEL ON CHAIN
QELLAST  DS    A                        -> TO PREVIOUS QEL
QELTCB   DS    A                        A(TCB) OF ENQING TASK
QELQFLGS DS    X
QELSHARE EQU   B'10000000'              ENQ SHARE
QELMC    EQU   B'01000000'              THIS IS AN MC QEL
QELLIST  EQU   B'00100000'              THIS IS A LIST QEL
QELRESV  EQU   B'00010000'              THIS IS A RESERVE
QELLFLGS DS    X
QELASID  DS    XL2                      ASID OF REQUESTOR
QELSVRB  DS    A
QELLCNT  DS    H
QELWCNT  DS    H
QELUCB   DS    A                        UCB ADDR FOR RESERVES
         EJECT
TSDSECT  DSECT ,              PICK UP IN THE DSECT
DWORK    DS    D
QTABLE   DS    A
QLEN     DS    F
NTABLE   DS    A
NLEN     DS    F
XTABLE   DS    A
OLD      DC    A(0,0)
FLAGS    DS    0F
FLAG1    DS    X
$CNFL    EQU   X'80'
$GLOBAL  EQU   X'40'
$FIND    EQU   X'20'
         SPACE 1
FLAG2    DS    X
$FMAJ    EQU   X'80'
$FMIN    EQU   X'40'
$FJOB    EQU   X'20'
         SPACE 1
FLAG3    DS    X
FLAG4    DS    X
         SPACE 1
FMAJLEN  DS    H
FMINLEN  DS    H
FJOBLEN  DS    H
MAXXREF  DS    H
CURXREF  DS    H
CURNAME  DS    H
         SPACE 1
TSDGMAIN GETMAIN EC,A=0,LV=0,MF=L
TSDSPIE  SPIE  0,(5),MF=L
FMAJ     DS    CL8
FJOB     DS    CL8
FMIN     DS    CL47
         SPACE 2
LINE     DS    0CL80                    MAP THE LINE SENT TO TERMINAL
LSCOPE   DS    C                        SCOPE OF ENQ - 'Y' OR 'J'
LTYPE    DS    C                        TYPE OF ENQ - 'E' OR 'S'
LHAS     DS    C                        ENQ STATUS - 'G' OR 'W'
LSYS     DS    C                        RESERVE - 'R' OR ' '
         DS    C
LTSO     DS    C                        TSO USER = '*'
LJOB     DS    CL8                      JOB NAME
         DS    C
LUCB     DS    CL10                     UCB  NAME
         DS    C
LJNAME   DS    CL8                      MAJOR QUEUE NAME
         DS    C
LMNAME   DS    CL49                     MINOR QUEUE NAME
         SPACE 1
#SYS     EQU   C'Y'
#STEP    EQU   C'J'
#SHR     EQU   C'S'
#EXC     EQU   C'E'
#GOT     EQU   C'G'
#WAIT    EQU   C'W'
#RES     EQU   C'R'
RLINK    EQU   R11
TSDUEND  DS    0H
TSDUSIZE EQU   TSDUEND-TSDUSER
         END
