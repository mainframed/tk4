 INVPLIF: PROC OPTIONS(MAIN); /* INVOKE FORGROUND PLIF    MH */
  /* ************************************************************** */
  /*                                                                */
  /*                                                                */
  /*    A TSO FOREGROUND PLI/F PROMPTER UNDER ISPF.                 */
  /*                                                                */
  /*    (USE THE OPTIMISING COMPILER UNDER NORMAL CIRCUMSTANCES.    */
  /*     USE THIS IF YOU HAVE SOME OLD PROGRAMS YOU DON'T           */
  /*     WANT TO REDO OR IF YOU WANT TO CHECK CERTAIN FEATURES      */
  /*     OUT. WE ORIGINALLY HAD A PROBLEM CALLING PLISRTA UNDER     */
  /*     XA WITH DFSORT BUT GOOD OLD PLI/F STILL WORKED FINE.       */
  /*     MVS/XA REL 2.1.2 WITH DFSORT REL 7.0 !!!!).                */
  /*                                                                */
  /*    (WRITTEN IN A HIGH LEVEL LANGUAGE FOLKS: (WELL MOSTLY)      */
  /*                                                                */
  /*    THE ASSEMBLER SUBROUTINES ARE ALL INCLUDED WITH THIS CODE.  */
  /*                                                                */
  /*    THEY ARE 1) A DYNAMIC ALLOCATION INTERFACE - VERY EASY TO   */
  /*                                                 USE SEE CODE   */
  /*             2) CATALOG MANAGEMENT FOR DATASET LOCATE.          */
  /*             3) TSO COMMAND HANDLER SO WE CAN ISSUE TSO COMMANDS*/
  /*                SUCH AS FREE AND PRINTOFF WITHOUT HAVING TO     */
  /*                GO THROUGH ALL THAT TSO COMMAND PROCESSOR       */
  /*                INITIALISATION GARBAGE : PPL CPPL ECT ETC ETC.  */
  /*             4) PDS MEMBER FINDER.                              */
  /*                                                                */
  /*  WISH LIST : THE USER DATASETS DO NOT HAVE TO BE CATALOGUED.   */
  /*              I CAN ADD VOLUME INFORMATION LATER. MAYBE         */
  /*              RELEASE 2 OF THIS (IF I EVER GET ROUND TO IT)     */
  /*              WILL ADD THIS FUNCTION.                           */
  /*                                                                */
  /*                                                                */
  /*  COMMENTS SUGGESTIONS IMPROVEMENTS AND ERROR INFORMATION       */
  /*  GREATLY APPRECIATED. ADDRESS BELOW.                           */
  /*                                                                */
  /*                                                                */
  /*  (INCIDENTLY IF YOU ARE USING THAT HORRIBLE DISEASE KNOWN      */
  /*   AS COBOL YOU CAN MODIFY THIS PROGRAM TO CALL WHATEVER        */
  /*   THE LOAD MODULE OF THAT PIECE OF JUNK IS KNOWN AS. ALSO      */
  /*   CHANGE THE COMPILER OPTIONS ON THE PANEL AND ALLOCATE        */
  /*   THE RELEVANT DATASETS FOR COBOL. THE SAME IS TRUE FOR ANY    */
  /*   OTHER LANGUAGE YOU WANT TO USE OR ANY FOREGROUND PROGRAM     */
  /*   / UTILITY YOU WANT TO TRY. ISPF IS MUCH EASIER THAN          */
  /*   FIDDLING AROUND WITH TSO COMMAND PROCESSORS AND YOU'VE       */
  /*   GOT ALL THE CODE HERE FOR FREE!!!!!!!).                      */
  /*                                                                */
  /*                                                                */
  /*   I HAVE USED ALTERNATE DDNAMES FOR COMPILE AND LINK STEPS     */
  /*   AS PEOPLE OFTEN HAVE THE STANDARD ONES (SYSIN,SYSLIB,        */
  /*   SYSPRINT ETC.) EITHER ALLOCATED IN THEIR LOGON PROC          */
  /*   TO THE TERMINAL (TS) OR HAVE ALREADY ALLOCATED THEM IN       */
  /*   OTHER COMMANDS. THIS MAKES ALLOCATION AND DEALLOCATION       */
  /*   MUCH EASIER !!                                               */
  /*                                                                */
  /*    MIKE HAWTHORNE  TTI CITICORP                                */
  /*                    3100 OCEAN PK BLVD                          */
  /*                    SANTA MONICA CA 90405                       */
  /*                                                                */
  /*    (213) 450-9111 X2353                                        */
  /*                                                                */
  /*                                                                */
  /*                                                                */
  /* THIS PROGRAM DISPLAYS A PANEL TO OBTAIN USER SOURCE AND LOAD   */
  /* LIBRARIES AND THE USER-ID. DATASETS REQUIRED BY THE PLI/F      */
  /* COMPILER ARE DYNAMICALLY ALLOCATED WITH THE DYNAM INTERFACE    */
  /* (EXISTING DATASETS ARE DELETED USING THE CATMAN CATALOG        */
  /* INTERFACE) AND THE PLI/F COMPILER IS INVOKED DYNAMICALLY       */
  /*                                                                */
  /* IF THE RETURN CODE IS 4 OR LESS THE LINK EDITOR IS INVOKED     */
  /* LOADING THE MODULE TO THE LOAD LIBRARY SELECTED OTHERWISE      */
  /* AN ERROR DATASET IS DYNAMICALLY ALLOCATED AND THE LIST         */
  /* DATASET READ AND THE ERRORS COPIED TO THE ERROR DATASET.       */
  /* ISPF BROWSE OF THE ERROR DATASET IS THEN INVOKED.              */
  /*                                                                */
  /* NOTE : IF NO LOAD TARGET LIBRARY IS SPECIFIED THEN THE         */
  /*        LINK STEP IS NOT DONE.                                  */
  /*                                                                */
  /*                                                                */
  /* IF THE USER HAS SELECTED THE PRINT OPTION THE LIST DATASET     */
  /* IS PRINTED BY ISSUING THE PRINTOFF TSO COMMAND.                */
  /*                                                                */
  /* NOTE : USING PANELS AND ISPF SERVICES IS MUCH EASIER THAN      */
  /*        WRITING A TSO COMMAND PROCESSOR TO DO THIS JOB.         */
  /*        NOBODY HAS TSO THESE DAYS WITHOUT ALSO HAVING ISPF.     */
  /*        PARSING COMMANDS IS MUCH SIMPLER IN PL/I AND MOST       */
  /*        OF THE CODE CAN BE WRITTEN IN A HIGH LEVEL LANGUAGE.    */
  /*                                                                */
  /*   DYNAMIC ALLOCATION WORKS SO I DO NOT TEST THE RETURN CODE    */
  /*   EACH TIME. IT KEEPS THE PROGRAM SMALLER (REMEMBER WE         */
  /*   ARE RUNNING IN A TSO ADDRESS SPACE).                         */
  /*   IF YOU HAVE PROBLEMS YOU CAN CHECK PLIRETV VALUE EACH        */
  /*   TIME YOU ALLOCATE A DATASET.                                 */
  /*                                                                */
  /*   NORMAL ERRORS ARE : RC=04  YOU ARE TRYING TO ALLOCATE A      */
  /*                              A DDNAME THATS ALREADY ALLOCATED. */
  /*                              FREE THE DDNAME AND TRY AGAIN.    */
  /*                       RC=12  INVALID PARAMETER PASSED TO       */
  /*                              THE DYNAMIC ALLOCATION INTERFACE. */
  /*                              LOOK FOR MISSING ; OR             */
  /*                              MIS-SPELT DATASET NAMES.          */
  /*                                                                */
  /* IF YOU HAVE TOP SECRET, RACF, ACF2 OR ANY OTHER SECURITY       */
  /* PACKAGE ENSURE THAT YOU HAVE THE CORRECT LEVEL OF ACCESS TO    */
  /* ANY DATASET YOU DYNAMICALLY ALLOCATE.                          */
  /* THE SOURCE IS MEMBER DYNAM IN MVSUG.SOURCE                     */
  /* AND INSTRUCTIONS ON HOW TO USE IT IS IN MEMBER DYNAM           */
  /* IN MVSUG.DOCUMENT.                                             */
  /*                                                                */
  /* ************************************************************** */
  /*                                                                */
  /* DEFINE EXTERNAL REFERENCES : DYNAMIC ALLOCATION INTERFACE      */
  /*                            : CATALOG MANAGEMENT                */
  /*                            : ISPF SERVICES                     */
  /*                            : TSO COMMAND PROCESSOR.            */
  /*                            : PDS MEMBER FINDER.                */
  /*                            : PLI COMPILER ITSELF.              */
  /*                            : LINKAGE EDITOR ITSELF.            */
  /*                                                                */
  /*  (NOTE TO ALL ASSEMBLER BIGOTS OUT THERE: YES YOU CAN CALL     */
  /*   PLI AND LINK EDIT FROM A HIGH LEVEL LANGUAGE SO LONG AS      */
  /*   YOU PASS THE RIGHT PARAMETERS AND GET THE ENTRY POINTS       */
  /*   CORRECT).                                                    */
  /*                                                                */
  /* ************************************************************** */
 DCL ISPLINK          ENTRY EXTERNAL OPTIONS(ASM,INTER,RETCODE);
 DCL (CATMAN, DYNAM)  ENTRY EXTERNAL OPTIONS(ASM,INTER,RETCODE);
 DCL INVTSO           ENTRY EXTERNAL OPTIONS(ASM,INTER,RETCODE);
 DCL INVFIND          ENTRY EXTERNAL OPTIONS(ASM,INTER,RETCODE);
 DCL IEMAA            ENTRY EXTERNAL OPTIONS(ASM,INTER,RETCODE);
 DCL HEWL             ENTRY EXTERNAL OPTIONS(ASM,INTER,RETCODE);
  /*                                                                */
  /* ************************************************************** */
  /*                                                                */
  /* DEFINE PLI BUILTIN FUNCTIONS/SERVICES.                         */
  /*                                                                */
  /* ************************************************************** */
 DCL (PLIRETV, LENGTH, SUBSTR, INDEX, ADDRESS, ADDR) BUILTIN;
  /* ************************************************************** */
  /*                                                                */
  /* DEFINE NON ISPF VARIABLES .                                    */
  /*                                                                */
  /* ************************************************************** */
 DCL CONS             CHAR(80) INIT(' '),
     Q                PTR,
     I                FIXED BIN(15) INIT(0),
     J                FIXED BIN(15) INIT(0),
     K                FIXED BIN(15) INIT(0),
     MEMBER           CHAR(8) INIT(' '),
     MEML             FIXED BIN(15) INIT(0),
     ERR_FLAG         CHAR(1) INIT('N'),
     MSGID            CHAR(8) INIT(' '),
     BLANK            CHAR(8) INIT(' '),
     LEN_USERID       FIXED BIN(15) INIT(0),
     LEN_ERR          FIXED BIN(15) INIT(0),
     SAVERC           FIXED BIN(15) INIT(0),
     L_SOURCE         FIXED BIN(15) INIT(0),
     L_COPY1          FIXED BIN(15) INIT(0),
     L_COPY2          FIXED BIN(15) INIT(0),
     L_LOAD           FIXED BIN(15) INIT(0),
     L_LOAD1          FIXED BIN(15) INIT(0),
     L_LNAME          FIXED BIN(15) INIT(0),
     L_LDT            FIXED BIN(15) INIT(0),
     WORK             FIXED BIN(31) INIT(0),
     TESTDSN          CHAR(44) INIT(' '),
     BROWSE_DSN       CHAR(44) INIT(' '),
     DIAG             FILE RECORD OUTPUT SEQUENTIAL ENV(VB),
     MSGFILE          FILE STREAM OUTPUT ENV(FB),
     PLIPRNT          FILE RECORD INPUT SEQUENTIAL ENV(VB),
     PLILINE          CHAR(125) VARYING,
     DIAGLINE         CHAR(125) VARYING,
     FLAG             CHAR(1) INIT(' '),
     FILE_IND         CHAR(1) INIT('N'),
     QUOTE            CHAR(1) INIT(''''), /* THIS IS A SINGLE QUOTE !*/
     LINK             CHAR(1) INIT(' '),
  /* ************************************************************** */
  /*                                                                */
  /* SET UP OPTIONS LIST AND ALTERNATE DDNAMES FOR BOTH THE         */
  /* PL/1 COMPILER AND THE LINKAGE EDITOR.                          */
  /*                                                                */
  /* ************************************************************** */
  1 FORPLI            UNALIGNED,
    3  OPTLEN         FIXED BIN(15),
    3  OPTDATA        CHAR(100),
  1 PLIDDN            ALIGNED,
    3  DDNLEN         FIXED BIN(15) INIT(80),
    3  P1             CHAR(8) INIT('PLILIN'),
    3  P2P3           CHAR(16) INIT(' '),
    3  P4             CHAR(8) INIT('PLIMAC'),
    3  P5             CHAR(8) INIT('PLIIN'),
    3  P6             CHAR(8) INIT('PLIPRNT'),
    3  P7             CHAR(8) INIT('PLIPUNCH'),
    3  P8             CHAR(8) INIT('PLIUT1'),
    3  P9             CHAR(8) INIT(' '),
    3  P10            CHAR(8) INIT('PLIUT3'),
  1 FORLNK            UNALIGNED,
    3  LNKLEN         FIXED BIN(15),
    3  LNKDATA        CHAR(100),
  1 LNKDDN            ALIGNED,
    3  DDNLEN1        FIXED BIN(15) INIT(64),
    3  L1             CHAR(8) INIT('LNKLIN'),  /* SYSLIN           */
    3  L2             CHAR(8) INIT(' '),       /* OUTPUT LMOD NAME */
    3  L3             CHAR(8) INIT('LNKMOD'),  /* SYSLMOD          */
    3  L4             CHAR(8) INIT('LNKLIB'),  /* SYSLIB           */
    3  L5             CHAR(8) INIT(' '),       /* NOTHING          */
    3  L6             CHAR(8) INIT('LNKPRNT'), /* SYSPRINT         */
    3  L7             CHAR(8) INIT('  '),      /* NOTHING          */
    3  L8             CHAR(8) INIT('LNKUT1'),  /* SYSUT1           */
  /* ************************************************************** */
  /*                                                                */
  /* SET UP PARAMETER LIST FOR CATALOG MANAGEMENT INTERFACE         */
  /*                                                                */
  /* ************************************************************** */
  PARMS1              CHAR(169) BASED(Q),
  1  WORK1            UNALIGNED,
    3 FUNC            CHAR(1) INIT('P'),
    3 DSNAME          CHAR(44) INIT(' '),
    3 VOLCOUNT        FIXED BIN(31) INIT(0),
    3 VOLLIST(20)     CHAR(6),
  /* ************************************************************** */
  /*                                                                */
  /* SET UP PARAMETER LIST FOR MEMBER FINDER MODULE                 */
  /*                                                                */
  /* ************************************************************** */
  1 FORMEM            UNALIGNED,
    3  MPARML         FIXED BIN(15) INIT(8),
    3  LIBNAME        CHAR(9) INIT(' '),
  /* ************************************************************** */
  /*                                                                */
  /* SET UP PARAMETER LIST FOR TSO COMMAND PROCESSING.              */
  /*                                                                */
  /* ************************************************************** */
  TSOLEN              FIXED BIN(31) INIT(0),
  TSOCMD              CHAR(255) INIT(' '),
  /* ************************************************************** */
  /*                                                                */
  /* DEFINE ISPF VARIABLES WE ARE GOING TO USE IN THE PROGRAM.      */
  /*                                                                */
  /* ************************************************************** */
     PRTOPT           CHAR(3) INIT(' '),
     OPT              CHAR(98) INIT(' '),
     LDT              CHAR(98) INIT(' '),
     SOURCE           CHAR(44)  INIT(' '),
     LOAD             CHAR(44) INIT(' '),
     COPY1            CHAR(44) INIT(' '),
     COPY2            CHAR(44) INIT(' '),
     LOAD1            CHAR(44) INIT(' '),
     LNAME            CHAR(8) INIT(' '),
     ZUSER            CHAR(7)  INIT('ZUSER'),
     USERID           CHAR(8)  INIT(' '),
     LLDT             FIXED BIN(31) INIT(LENGTH(LDT));
 DCL LLNAME           FIXED BIN(31) INIT(LENGTH(LNAME));
 DCL LSOURCE          FIXED BIN(31) INIT(LENGTH(SOURCE)),
     LLOAD            FIXED BIN(31) INIT(LENGTH(LOAD)),
     LCOPY1           FIXED BIN(31) INIT(LENGTH(COPY1)),
     LCOPY2           FIXED BIN(31) INIT(LENGTH(COPY2)),
     LLOAD1           FIXED BIN(31) INIT(LENGTH(LOAD1)),
     LZUSER           FIXED BIN(31) INIT(LENGTH(ZUSER)),
     LOPT             FIXED BIN(31) INIT(LENGTH(OPT)),
     LPRTOPT          FIXED BIN(31) INIT(LENGTH(PRTOPT));
  /* ************************************************************** */
  /*                                                                */
  /* SET UP THE INITIAL PROGRAM ENVIRONMENT :                       */
  /*                                                                */
  /*        A) SET UP ADDRESSABILITY OF BASED VARIABLES             */
  /*        B) INITIALIZE THE DYNAMIC ALLOCATION INTERFACE          */
  /*        C) ALLOCATE TERMINAL FILE AND ISSUE A MESSAGE           */
  /*                                                                */
  /* ************************************************************** */
 Q = ADDR(WORK1);
 FETCH DYNAM;
 FETCH CATMAN;
 FETCH INVTSO;
 CALL DYNAM(WORK, 'INIT ');
 CALL DYNAM(WORK,'ALLOC ','DD=MSGFILE;','TE;');
 OPEN FILE(MSGFILE) LINESIZE(80);
  /* ************************************************************** */
  /*                                                                */
  /* SET UP THE ISPF ENVIRONMENT:                                   */
  /*                                                                */
  /*        A) DEFINE OUR PROGRAMS VARIABLES TO ISPF SO WE          */
  /*           CAN GET DATA FROM A PANEL.                           */
  /*        B) GET THE TSO USER-ID FROM ISPF. THIS IS THE SYSTEM    */
  /*           VARIABLE ZUSER FROM ISPF OBTAINED VIA VCOPY FUNCTION */
  /*        C) SHOW THE USER THE PANEL                              */
  /*        D) GET DATA BACK FROM THE PANEL                         */
  /* WE SAVE THE PANEL SO  ON PARSE ERROR WE CAN ISSUE A MESSAGE    */
  /* AND RE-DISPLAY THE PANEL. THE USER CAN THEN CORRECT HIS        */
  /* ERROR(S)                                                       */
  /*                                                                */
  /*       (IF PLIRETV = 8 THEN PFK3 OR END KEY HAS BEEN PRESSED)   */
  /*        IF THIS HAS HAPPENED WE EXIT WITHOUT MORE ADO.          */
  /*                                                                */
  /* ************************************************************** */
 CALL ISPLINK('VDEFINE', '(PRTOPT)', PRTOPT, 'CHAR', LPRTOPT);
 CALL ISPLINK('VDEFINE', '(LNAME)', LNAME, 'CHAR', LLNAME);
 CALL ISPLINK('VDEFINE', '(OPT)', OPT, 'CHAR', LOPT);
 CALL ISPLINK('VDEFINE', '(LDT)', LDT, 'CHAR', LLDT);
 CALL ISPLINK('VDEFINE', '(SOURCE)', SOURCE, 'CHAR', LSOURCE);
 CALL ISPLINK('VDEFINE', '(COPY1)', COPY1, 'CHAR', LCOPY1);
 CALL ISPLINK('VDEFINE', '(COPY2)', COPY2, 'CHAR', LCOPY2);
 CALL ISPLINK('VDEFINE', '(LOAD1)', LOAD1, 'CHAR', LLOAD1);
 CALL ISPLINK('VDEFINE', '(LOAD)', LOAD, 'CHAR', LLOAD);
 CALL ISPLINK('VCOPY', ZUSER, LZUSER, USERID, 'MOVE');
 CALL ISPLINK('DISPLAY', 'PLIF    ', 'INV020  ');
 LEN_USERID = INDEX(USERID,' ');
 IF LEN_USERID ^= 0
 THEN LEN_USERID = LEN_USERID - 1;
 REDOO: IF PLIRETV = 8    /* COME BACK TO HERE ON ANY ERROR*/
 THEN GO TO EXIT1;        /* EXIT WITHOUT DOING ANY PROCESSING*/
 TSOLEN = 1;
  /* ************************************************************** */
  /*                                                                */
  /*   PARSE THE DATA FROM THE USER.                                */
  /*                                                                */
  /*        A) GET SOURCE DATASET AND CHECK FOR VALIDITY.           */
  /*           IF THE DATASET IS UNQUOTED APPEND THE TSO USER-ID.   */
  /*           IF MISSING QUOTE THEN ISSUE ERROR MESSAGE .          */
  /*           IF UNCATALOGUED THEN ISSUE A MESSAGE.                */
  /*        B) IF NO MACRO LIBRARIES THEN ISSUE ERROR MESSAGE       */
  /*           OTHERWISE CHECK FOR VALIDITY OF DATASETS AND IF      */
  /*           NECESSARY CONCATENATE THEM.                          */
  /*        C) IF NO LOAD LIBRARY SPECIFIED THEN SET A FLAG WHICH   */
  /*           INDICATES LINK STEP NOT TO BE DONE                   */
  /*        D) CHECK FOR ADDITIONAL LOAD LIBRARIES (MAX 1) TO       */
  /*           USE IN THE AUTOLINK SEARCH FOR LINK EDIT INCLUDES.   */
  /*        E) IF ALL THE ABOVE TESTS PASS SET UP OPTIONS FOR       */
  /*           PASSING TO THE COMPILER. THE NEXT SECTION WILL       */
  /*           ALLOCATE DATASETS NEEDED FOR COMPILE                 */
  /*           OTHERWISE RE-DISPLAY PANEL AND RE-DO.                */
  /*                                                                */
  /*       SEE ISPF DIALOG MANAGEMENT SERVICES                      */
  /*       (SC34-2088) FOR MESSAGE FORMATS AND USING ISPF SERVICES  */
  /*       FROM A PROBLEM PROGRAM.                                  */
  /*                                                                */
  /*      HINT : TO RE-DISPLAY A PANEL AFTER AN ERROR               */
  /*             CALL ISPLINK OMITTING THE PANEL NAME BUT INCLUDE   */
  /*             A MESSAGE NUMBER AND THE FIELD WHERE YOU WANT      */
  /*             THE CURSOR TO GO.                                  */
  /*             TO OMIT A PARAMETER IN THIS WAY TO ISPLINK         */
  /*             I USE A PANEL NAME OF ALL BLANKS. THIS ACHIEVES    */
  /*             THE SAME OBJECT AS OMITTING A PARAMETER WHICH      */
  /*             IS NOT THE LAST ONE IN THE LIST.                   */
  /*                                                                */
  /* ************************************************************** */
  DSNAME = ' ';
 IF SUBSTR(SOURCE,1,1) = ' '          /* MISSING SOURCE DATASET     */
 THEN DO;
         CALL ISPLINK('DISPLAY', BLANK, 'INV001  ', 'SOURCE ');
         GO TO REDOO;
      END;
 TESTDSN = SOURCE;
 CALL PARSE;
 IF ERR_FLAG = 'Y'    /* PARSE SETS MESSAGE ID  */
 THEN DO;
         ERR_FLAG = 'N';
         CALL ISPLINK('DISPLAY', BLANK,  MSGID, 'SOURCE ');
         GO TO REDOO;
      END;
 SOURCE = DSNAME;                    /* GET CORRECT DSN FOR ALLOCATE*/
  IF SUBSTR(COPY1,1,1) ^= ' '
  THEN DO;
          TESTDSN = COPY1;
          CALL PARSE;
          IF ERR_FLAG = 'Y'    /* PARSE ERROR            */
          THEN DO;
                  ERR_FLAG = 'N';
                  CALL ISPLINK('DISPLAY', BLANK,
                               MSGID, 'COPY1  ');
                  GO TO REDOO;
               END;
          COPY1 = DSNAME;
          L_COPY1 = INDEX(COPY1,' ') - 1;
       END;
  IF SUBSTR(COPY2,1,1) = ' '
  THEN DO;
          IF SUBSTR(COPY1,1,1) = ' '  /* NO MACRO LIBRARIES SPECIFIED*/
          THEN DO;
                  CALL ISPLINK('DISPLAY', BLANK,
                               'INV005  ', 'COPY1  ');
                  GO TO REDOO;
                END;
       END;
  ELSE DO;
          TESTDSN = COPY2;
          CALL PARSE;
          IF ERR_FLAG = 'Y'    /* PARSE ERROR            */
          THEN DO;
                  ERR_FLAG = 'N';
                  CALL ISPLINK('DISPLAY', BLANK,
                               MSGID, 'COPY2  ');
                  GO TO REDOO;
               END;
          COPY2 = DSNAME;
          L_COPY2 = INDEX(COPY2,' ') - 1;
       END;
  IF SUBSTR(LOAD,1,1) = ' '
  THEN LINK = 'N';
  ELSE DO;
          LINK = 'Y';
          TESTDSN = LOAD;
          CALL PARSE;
          IF ERR_FLAG = 'Y'    /* PARSE ERROR            */
          THEN DO;
                  ERR_FLAG = 'N';
                  CALL ISPLINK('DISPLAY', BLANK,
                               'INV002  ', 'LOAD   ');
                  GO TO REDOO;
               END;
          LOAD = DSNAME;
          L_LOAD = INDEX(LOAD,' ') - 1;
          IF SUBSTR(LNAME,1,1) = ' '  /* NO NAME FOR LOAD MODULE*/
          THEN DO;
                  CALL ISPLINK('DISPLAY', BLANK,
                                       'INV003  ', 'LNAME  ');
                  GO TO REDOO;
               END;
          ELSE L2 = LNAME;
       END;
 IF SUBSTR(LOAD1,1,1) ^= ' '
 THEN DO;
         IF LINK = 'Y'
         THEN DO;
                 TESTDSN = LOAD1;
                 CALL PARSE;
                 IF ERR_FLAG = 'Y'    /* PARSE ERROR            */
                  THEN DO;
                          ERR_FLAG = 'N';
                          CALL ISPLINK('DISPLAY', BLANK,
                                       MSGID, 'LOAD1  ');
                          GO TO REDOO;
                       END;
                 LOAD1 = DSNAME;
                 L_LOAD1 = INDEX(LOAD1,' ') - 1;
              END;
      END;
 CONS= 'PLI/F PROMPTER       V1.0  MIKE HAWTHORNE AUG 1985';
 CALL WRITEIT;
 OPTLEN = INDEX(OPT,' ');
 OPTLEN = OPTLEN - 1;
 OPTDATA = SUBSTR(OPT,1,OPTLEN);
  /* ************************************************************** */
  /*                                                                */
  /*   DELETE DATASETS USERID.PLIF.LIST USERID.PLIF.ERRMSG AND      */
  /*   USERID.PLIF.OBJ.                                             */
  /*                                                                */
  /* ************************************************************** */
 FUNC = 'P';                    /* SET FOR PURGE OF DATASETS */
 DSNAME=SUBSTR(USERID,1,LEN_USERID) ×× '.PLIF.LIST';
 CALL CATMAN(PARMS1);           /* IGNORE RET CODE IF NOT 0  */
 FUNC = 'P';                    /* SET FOR PURGE OF DATASETS */
 DSNAME=SUBSTR(USERID,1,LEN_USERID) ×× '.PLIF.OBJ';
 CALL CATMAN(PARMS1);           /* IGNORE RET CODE IF NOT 0  */
 FUNC = 'P';                    /* SET FOR PURGE OF DATASETS */
 DSNAME=SUBSTR(USERID,1,LEN_USERID) ×× '.PLIF.ERRMSG';
 CALL CATMAN(PARMS1);           /* IGNORE RET CODE IF NOT 0  */
 FUNC = 'P';                    /* SET FOR PURGE OF DATASETS */
 DSNAME=SUBSTR(USERID,1,LEN_USERID) ×× '.PLIF.UT1';
 CALL CATMAN(PARMS1);           /* IGNORE RET CODE IF NOT 0  */
 FUNC = 'P';                    /* SET FOR PURGE OF DATASETS */
 DSNAME=SUBSTR(USERID,1,LEN_USERID) ×× '.PLIF.UT3';
 CALL CATMAN(PARMS1);           /* IGNORE RET CODE IF NOT 0  */
  /* ************************************************************** */
  /*                                                                */
  /*   ALLOCATE DATASETS NEEDED BY THE PLI COMPILER                 */
  /*   AND CALL IT .                                                */
  /*   AT END OF COMPILATION DELETE THE SYSUT1 DATASET AND          */
  /*   ISSUE A MESSAGE INDICATING THE RETURN CODE.                  */
  /*                                                                */
  /* ************************************************************** */
 IF LIBNAME ^= ' '             /*  ARE WE USING A PDS     */
 THEN DO;                      /* YES WE ARE              */
         K = INDEX(SOURCE,'(');  /* PARSE HAS REMOVED ANY QUOTES   */
         K = K - 1;      /* OR ALREADY INSERTED USER ID       */
         I = INDEX(LIBNAME,' ');
         I = I - 1;
         CALL DYNAM(WORK, 'ALLOC ', 'DSN='
                   ×× SUBSTR(SOURCE,1,K) ×× ' SHR;',
                   'ME=' ×× SUBSTR(LIBNAME,1,I) ×× ';',
                   'DD=PLIIN;');
      END;
 ELSE DO;
         K = INDEX(SOURCE,' ');
         K = K - 1;
          CALL DYNAM(WORK, 'ALLOC ', 'DSN='
                    ×× SUBSTR(SOURCE,1,K) ×× ' SHR;',
                    'DD=PLIIN;');
      END;
 K = INDEX (SOURCE,' ');
 CALL DYNAM(WORK, 'ALLOC ',
 'DSN=' ×× SUBSTR(USERID,1,LEN_USERID) ×× '.PLIF.OBJ NEW CATLG;',
          'LRECL=80;','BLKSIZE=800;','FB;',
          'UNIT=SYSDA;','DD=PLILIN;',
          'TRK PRIMARY=15 SECONDARY=5;');
 CALL DYNAM(WORK, 'ALLOC ',
 'DSN=' ×× SUBSTR(USERID,1,LEN_USERID) ×× '.PLIF.UT1 NEW CATLG;',
          'BLKSIZE=1024;',
          'UNIT=SYSDA;','DD=PLIUT1;',
          'TRK PRIMARY=15 SECONDARY=5;');
 CALL DYNAM(WORK, 'ALLOC ',
 'DSN=' ×× SUBSTR(USERID,1,LEN_USERID) ×× '.PLIF.UT3 NEW CATLG;',
          'LRECL=80;','BLKSIZE=800;','FB;',
          'UNIT=SYSDA;','DD=PLIUT3;',
          'TRK PRIMARY=15 SECONDARY=5;');
 CALL DYNAM(WORK, 'ALLOC ',
 'DSN=' ×× SUBSTR(USERID,1,LEN_USERID) ×× '.PLIF.LIST NEW CATLG;',
          'LRECL=125;','BLKSIZE=629;','VBA;',
          'UNIT=SYSDA;','DD=PLIPRNT;',
          'TRK PRIMARY=15 SECONDARY=5;');
 IF SUBSTR(COPY1,1,1) = ' '
 THEN DO;
         CALL DYNAM(WORK, 'ALLOC  ', 'DSN=' ×× SUBSTR(COPY2,1,L_COPY2)
                ×× ' SHR;','DD=PLIMAC;');
      END;
 ELSE DO;
         CALL DYNAM(WORK, 'ALLOC ', 'DSN=' ×× SUBSTR(COPY1,1,L_COPY1)
                ×× ' SHR;','DD=PLIMAC;');
         IF SUBSTR(COPY2,1,1) ^= ' '
         THEN DO;
                 CALL DYNAM(WORK, 'ALLOC ', 'DSN='
                       ×× SUBSTR(COPY2,1,L_COPY2)
                       ×× ' SHR;','DD=DDNAME1;');
                 CALL DYNAM(WORK, 'CONCAT', 'DD=PLIMAC,DDNAME1;');
              END;
      END;
 CONS = 'NOW COMPILING FROM : ' ×× SUBSTR(SOURCE,1,INDEX(SOURCE,' '));
 CALL WRITEIT;
  FETCH IEMAA;
  CALL IEMAA(FORPLI, PLIDDN);
  SAVERC = PLIRETV;
  RELEASE IEMAA;
  IF SAVERC > 4
  THEN LINK = 'N';
  CONS= 'PLI/F  COMPILE FINISHED RC = ' ×× SAVERC;
  CALL WRITEIT;
  /* ************************************************************** */
  /*                                                                */
  /*   DE-ALLOCATE DDNAMES USED IN COMPILE PROCESSING               */
  /*   (WE NEED THE LIST DATASET IF RC >0 FOR BUILDING THE          */
  /*    DIAGNOSTIC DATASET. THIS IS THEREFORE DEALLOCATED LATER).   */
  /*                                                                */
  /* ************************************************************** */
 CALL DYNAM(WORK, 'UNALLOC ', 'DD=PLIIN;');
 CALL DYNAM(WORK, 'UNALLOC ', 'DD=PLILIN;');
 CALL DYNAM(WORK, 'UNALLOC ', 'DD=PLIUT1;');
 CALL DYNAM(WORK, 'UNALLOC ', 'DD=PLIUT3;');
 CALL DYNAM(WORK, 'UNCONCAT ','DD=PLIMAC;');
 CALL DYNAM(WORK, 'UNALLOC ', 'DD=PLIMAC;');
 FUNC = 'P';                    /* SET FOR PURGE OF DATASETS */
 DSNAME=SUBSTR(USERID,1,LEN_USERID) ×× '.PLIF.UT1';
 CALL CATMAN(PARMS1);           /* IGNORE RET CODE IF NOT 0  */
 FUNC = 'P';                    /* SET FOR PURGE OF DATASETS */
 DSNAME=SUBSTR(USERID,1,LEN_USERID) ×× '.PLIF.UT3';
 CALL CATMAN(PARMS1);           /* IGNORE RET CODE IF NOT 0  */
  /* ************************************************************** */
  /*                                                                */
  /*   IF RETURN CODE >0 ALLOCATE A MESSAGE DATASET AND READ THE    */
  /*   LIST DATASET UNTIL WE FIND THE COMPILER DIAGNOSTICS.         */
  /*   WRITE THESE TO THE MESSAGE DATASET.                          */
  /*   ENTER ISPF WITH BROWSE FACILITY TO BROWSE THE DATASET        */
  /*   JUST CREATED. WHEN THE USER HAS FINISHED WITH BROWSE THEN    */
  /*   EXIT BACK TO TSO WITH MESSAGE PLI PROMPTER PROCESSING        */
  /*   FINISHED.                                                    */
  /*                                                                */
  /*   NOTE : WHILE YOU ARE IN BROWSE YOU HAVE FULL ACCESS TO       */
  /*          SPLIT SCREENS AND OTHER TSO/ISPF SERVICES SO YOU      */
  /*          CAN EDIT, ISSUE TSO COMMANDS ETC. ETC.                */
  /*                                                                */
  /* ************************************************************** */
  IF SAVERC > 0
  THEN DO;
           CALL DYNAM(WORK, 'ALLOC ',
                     'DSN=' ×× SUBSTR(USERID,1,LEN_USERID)
                      ×× '.PLIF.ERRMSG NEW CATLG;',
                      'LRECL=125;','BLKSIZE=629;','VBA;',
                       'UNIT=SYSDA;','DD=DIAG;',
          'TRK PRIMARY=2 SECONDARY=1;');
         CONS= 'BUILDING DIAGNOSTIC DATASET '
               ×× SUBSTR(USERID,1,LEN_USERID)
               ×× '.PLIF.ERRMSG FOR ISPF BROWSE';
         CALL WRITEIT;
         OPEN FILE(PLIPRNT),   FILE(DIAG);
         ON ENDFILE(PLIPRNT) FILE_IND = 'Y';
         READ FILE(PLIPRNT) INTO(PLILINE);
         DO WHILE(FILE_IND = 'N');
            IF FILE_IND = 'Y'
            THEN LEAVE;
            IF SUBSTR(PLILINE,1,26) =
             '-    COMPILER DIAGNOSTICS.'
            THEN FLAG = 'Y';
            IF FLAG = 'Y'
            THEN DO;
                    DIAGLINE = PLILINE;
                    WRITE FILE(DIAG) FROM(DIAGLINE);
                 END;
            READ FILE(PLIPRNT) INTO(PLILINE);
         END;
         CLOSE FILE(PLIPRNT), FILE(DIAG);
         CALL DYNAM(WORK, 'UNALLOC ', 'DD=DIAG;');
         CONS = 'ABOUT TO BROWSE DIAGNOSTICS YOU MAY USE SPLIT'
            ×× ' SCREENS ETC WHILE IN BROWSE';
         CALL WRITEIT;
         CONS = 'PRESS ENTER TO CONTINUE : TO EXIT BROWSE PRESS PF3'
              ×× ' TO RESUME PROCESSING';
         CALL WRITEIT;
         BROWSE_DSN = 'PLIF.ERRMSG';
         CALL ISPLINK ('BROWSE', BROWSE_DSN);
      END;
  /* ************************************************************** */
  /*                                                                */
  /*   IF LINK FLAG INDICATES WE ARE NOT INTERESTED LINK EDIT THEN  */
  /*   WE EXIT OTHERWISE WE SET OURSELVES UP FOR THE LINK STEP.     */
  /*                                                                */
  /* ************************************************************** */
   CALL DYNAM(WORK, 'UNALLOC ', 'DD=PLIPRNT;');
   IF LINK = 'N'
   THEN DO;
           CONS = 'LINK EDIT STEP BYPASSED : EITHER YOU HAD '
                  ×× 'COMPILATION ERRORS IN YOUR PROGRAM';
           CALL WRITEIT;
           CONS = 'OR YOU DID NOT ASK FOR IT (TARGET LOAD LIBRARY '
                  ×× 'NOT ENTERED)';
           CALL WRITEIT;
           GO TO EXIT;
        END;
   CONS = 'LINK EDIT PROCESSING STARTING';
   CALL WRITEIT;
   LNKLEN = INDEX(LDT,' ');
   LNKLEN = LNKLEN - 1;
   LNKDATA = SUBSTR(LDT,1,LNKLEN);
  /* ************************************************************** */
  /*                                                                */
  /*   DELETE DATASET USERID.LNK.LINKLIST AND USERID.LNK.UT1        */
  /*   ALLOCATE DATASETS NEEDED BY THE LINKAGE EDITOR               */
  /*   AND CALL IT .                                                */
  /*                                                                */
  /*  NOTE : WE HAVE TO CONCATENATE ALL THE REQUIRED LIBRARIES      */
  /*         FOR SYSLIB (USING DDNAME LNKLIB) SO THAT AUTO LINK     */
  /*         WILL SEARCH THE RIGHT LIBRARIES.                       */
  /*                                                                */
  /*   AT END OF LINK EDIT  DELETE THE SYSUT1 DATASET AND           */
  /*   ISSUE A MESSAGE INDICATING THE RETURN CODE.                  */
  /*                                                                */
  /* ************************************************************** */
 FUNC = 'P';                    /* SET FOR PURGE OF DATASETS */
 DSNAME=SUBSTR(USERID,1,LEN_USERID) ×× '.LNK.LINKLIST';
 CALL CATMAN(PARMS1);           /* IGNORE RET CODE IF NOT 0  */
 FUNC = 'P';                    /* SET FOR PURGE OF DATASETS */
 DSNAME=SUBSTR(USERID,1,LEN_USERID) ×× '.LNK.UT1';
 CALL CATMAN(PARMS1);           /* IGNORE RET CODE IF NOT 0  */
 CALL DYNAM(WORK, 'ALLOC ',
 'DSN=' ×× SUBSTR(USERID,1,LEN_USERID) ×× '.LNK.UT1 NEW CATLG;',
          'BLKSIZE=1024;',
          'UNIT=SYSDA;','DD=LNKUT1;',
          'TRK PRIMARY=15 SECONDARY=5;');
 CALL DYNAM(WORK, 'ALLOC ',
 'DSN=' ×× SUBSTR(USERID,1,LEN_USERID) ×× '.LNK.LINKLIST NEW CATLG;',
          'LRECL=121;','BLKSIZE=1210;','FBA;',
          'UNIT=SYSDA;','DD=LNKPRNT;',
          'TRK PRIMARY=2 SECONDARY=5;');
 CALL DYNAM(WORK, 'ALLOC ',
 'DSN=' ×× SUBSTR(USERID,1,LEN_USERID) ×× '.PLIF.OBJ SHR;',
         'DD=LNKLIN;');
 CALL DYNAM(WORK, 'ALLOC ', 'DSN=' ×× SUBSTR(LOAD,1,L_LOAD)
         ×× ' SHR;','DD=LNKMOD;');
 CALL DYNAM(WORK, 'ALLOC ', 'DSN=SMDC.COMPLIB SHR;',
        'DD=LNKLIB;');
 CALL DYNAM(WORK, 'ALLOC ', 'DSN=SYS1.PPLINK SHR;',
        'DD=DD1;');
 CALL DYNAM(WORK, 'ALLOC ', 'DSN=' ×× SUBSTR(LOAD,1,L_LOAD)
         ×× ' SHR;','DD=DD2;');
 IF SUBSTR(LOAD1,1,1) ^= ' '
 THEN DO;
         CALL DYNAM(WORK, 'ALLOC ', 'DSN=' ×× SUBSTR(LOAD1,1,L_LOAD1)
         ×× ' SHR;','DD=DD3;');
          CALL DYNAM(WORK, 'CONCAT',
          'DD=LNKLIB,DD1,DD2,DD3;');
      END;
 ELSE DO;
          CALL DYNAM(WORK, 'CONCAT',
          'DD=LNKLIB,DD1,DD2;');
      END;
  FETCH HEWL;          /* YOU BETTER HAVE A BIG ENOUGH TSO REGION */
  CALL HEWL (FORLNK, LNKDDN);
  SAVERC = PLIRETV;
  RELEASE HEWL;       /* DELETE IT  ITS A BIG STORAGE USER */
  CONS= 'LINK EDIT PROCESSING HAS FINISHED RC = ' ×× SAVERC;
  CALL WRITEIT;
  /* ************************************************************** */
  /*                                                                */
  /*   DE-ALLOCATE DDNAMES USED IN LINK EDIT PROCESSING             */
  /*                                                                */
  /* ************************************************************** */
 CALL DYNAM(WORK, 'UNALLOC ', 'DD=DDNAME1;');
 CALL DYNAM(WORK, 'UNALLOC ', 'DD=LNKUT1;');
 CALL DYNAM(WORK, 'UNALLOC ', 'DD=LNKLIN;');
 CALL DYNAM(WORK, 'UNALLOC ', 'DD=LNKMOD;');
 CALL DYNAM(WORK, 'UNCONCAT ','DD=LNKLIB;');
 CALL DYNAM(WORK, 'UNALLOC ', 'DD=LNKLIB;');
 CALL DYNAM(WORK, 'UNALLOC ', 'DD=DD1;');
 CALL DYNAM(WORK, 'UNALLOC ', 'DD=DD2;');
 CALL DYNAM(WORK, 'UNALLOC ', 'DD=DD3;');
  IF SAVERC ^= 0
  THEN DO;
          BROWSE_DSN = 'LNK.LINKLIST';
          CALL ISPLINK ('BROWSE', BROWSE_DSN);
       END;
 CALL DYNAM(WORK, 'UNALLOC ', 'DD=LNKPRNT;');
  GO TO EXIT;  /* REDUNDANT STATEMENT BUT MAKES CODE EASIER TO READ */
  /* ************************************************************** */
  /*                                                                */
  /*  THIS SUBROUTINE DOES THE FOLLOWING :                          */
  /*                                                                */
  /*                  A) TOO MANY QUOTES ON DATASET NAME.           */
  /*                  B) IF WE HAVE ( OR ) IN THE DATASET           */
  /*                     IS IT VALID. I.E '(' MUST COME BEFORE ')'. */
  /*                  C) IS THE MEMBER NAME 8 CHARS OR LESS.        */
  /*                  D) CHECKS FOR QUOTED DATASET. IF QUOTED       */
  /*                     CHECKS FOR MATCHING END OF QUOTE.          */
  /*                  E) IF NOT QUOTED APPENDS THE USERS TSO ID     */
  /*                     IN FRONT OF THE DSN.                       */
  /*                  F) CHECKS WHETHER THE DATASET CATALOGUED.     */
  /*                  G) IS THE MEMBER IN THE PDS IF ITS A PDS.     */
  /*                                                                */
  /*                                                                */
  /* ERRORS WILL CAUSE A RE-DISPLAY OF THE PANEL WITH A MESSAGE.    */
  /* PF2 WILL PRESENT THE ALTERNATE LONG MESSAGE.                   */
  /*                                                                */
  /*                                                                */
  /* ************************************************************** */
 PARSE: PROC;
 MEML = 0;
 MEMBER=' ';
 DSNAME = ' ';
 K = INDEX (TESTDSN,QUOTE ×× QUOTE); /* CHECK FOR DOUBLE QUOTES */
 IF K ^= 0
 THEN DO;
         ERR_FLAG = 'Y';
         MSGID = 'INV009  '; /* TOO MANY QUOTES          */
         GO TO ENDPARS;
      END;
 IF SUBSTR(TESTDSN,1,1) = QUOTE   /* EXTRACT QUOTES IF ANY   */
  THEN DO;                        /* IF THERE APPEND USER ID */
          K = INDEX (TESTDSN,' ');     /* GET LENGTH OF SOURCE DSN  */
          K = K - 1;                   /* GET THE REAL LENGTH       */
          IF SUBSTR(TESTDSN,K,1) ^= QUOTE
          THEN DO;
                  ERR_FLAG = 'Y';
                  MSGID = 'INV004  ';
                  GO TO ENDPARS;
               END;
          ELSE DO;
                  DSNAME=SUBSTR(TESTDSN,2,K-2); /* EXTRACT QUOTES */
               END;
       END;
  ELSE DO;
          K = INDEX (TESTDSN,QUOTE);   /* CHECK FOR A SINGLE QUOTE */
          IF K = 0                             /* NOT FOUND   OKAY */
          THEN DO;
                  K = INDEX (TESTDSN,' ');
                  K = K - 1;
                  DSNAME=SUBSTR(USERID,1,LEN_USERID) ×× '.'
                  ×× SUBSTR(TESTDSN,1,K);
                END;
          ELSE DO;
                  ERR_FLAG = 'Y';
                  MSGID = 'INV004  ';
                  GO TO ENDPARS;
               END;
       END;
 K = INDEX (DSNAME,'(');  /* NOTE WE HAVE NOW EXTRACTED QUOTE */
 IF K = 0                 /* AND IF NECESSARY APPENDED TSO USER ID */
 THEN DO;
         K = INDEX (DSNAME,')');
         IF K ^=0
         THEN DO;
                 ERR_FLAG = 'Y';
                 MSGID = 'INV004  '; /* SET INVALID DATASET NAME */
                 GO TO ENDPARS;
             END;
      END;        /* THAT TAKES CARE OF UNBALANCED PARENTHESES */
 ELSE DO;         /* WE HAVE ALREADY FOUND A  '(' SO VALIDATE DS */
         I = INDEX (DSNAME,')');
         IF I = 0
         THEN DO;
                 ERR_FLAG = 'Y';    /* UNBALANCED PARENTHESES */
                 MSGID = 'INV004  ';
                 GO TO ENDPARS;
             END;
         IF SUBSTR(DSNAME,I+1,1) = QUOTE  /* QUOTED DSN FOLKS   */
         THEN DO;
                 IF SUBSTR(DSNAME,I+2,1) ^= ' ' /* GARBAGE DSN  */
                 THEN DO;
                         ERR_FLAG = 'Y';
                         MSGID = 'INV004  ';
                         GO TO ENDPARS;
                      END;
              END;
         IF SUBSTR(DSNAME,I+1,1) ^= ' ' /* GARBAGE DSN  */
         THEN DO;
                 ERR_FLAG = 'Y';
                 MSGID = 'INV004  ';
                 GO TO ENDPARS;
              END;
         ELSE DO;
                 IF I < K          /* PARENTHESES ASS ABOUT TIT  */
                 THEN DO;          /* GOT ) BEFORE (  TURKEY !   */
                         ERR_FLAG = 'Y';
                         MSGID = 'INV004  ';
                         GO TO ENDPARS;
                      END;
                 MEML = I - K;
                 IF MEML > 9      /* INVALID MEMBER NAME          */
                 THEN DO;
                         ERR_FLAG = 'Y';
                         MSGID = 'INV007  ';
                         GO TO ENDPARS;
                      END;
                 ELSE DO;
                         MEMBER = SUBSTR(DSNAME,K+1,I-1);
                      END;
             END;
       END;
  IF ERR_FLAG = 'N'          /* ON ERROR SKIP REST OF PROCESSING    */
  THEN DO;
          FUNC = 'I';        /* CHECK IF CATALOGED                  */
          CALL CATMAN(PARMS1);
          IF PLIRETV ^=0
          THEN DO;
                  MSGID = 'INV002  ';
                  ERR_FLAG = 'Y';
                  GO TO ENDPARS;
               END;
       END;
  ENDPARS: IF ERR_FLAG = 'N'
  THEN DO;
          IF MEML > 0       /* WE'VE GOT A PDS HERE                */
          THEN DO;          /* NOW CHECK FOR MEMBER OF A PDS       */
                  CALL CHEKMEM;
               END;
       END;
 END PARSE;
- /* ************************************************************** */
  /*                                                                */
  /*  THIS SUBROUTINE ISSUES ANY NON ISPF TERMINAL MESSAGES         */
  /*                                                                */
  /*  (NOTE MSGFILE IS AN ORDINARY PL/I STREAM DIRECTED I/O         */
  /*   DATASET : THE DYNAMIC ALLOCATION INTERFACE ALLOCATES IT      */
  /*   AS A TERMINAL FILE SO YOU DO NOT NEED SUBROUTINES            */
  /*   FOR TPUT/TGET)                                               */
  /*                                                                */
  /* ************************************************************** */
 WRITEIT: PROC;
          PUT FILE(MSGFILE) EDIT (CONS)(A(80));
 END WRITEIT;
 CHEKMEM: PROC;
  /* ************************************************************** */
  /*                                                                */
  /* WE WILL CHECK FOR MEMBER OF A PDS. CATALOG MANAGEMENT WILL     */
  /* TELL US IF THE WHOLE PDS IS OUT THERE BUT WILL NOT TELL US     */
  /* IF AN ACTUAL MEMBER IS IN THE PDS.                             */
  /* WE CAN GET THAT FROM DYNAMIC ALLOCATION ROUTINES AND OUR       */
  /* PDS MEMBER FINDER WHICH NEEDS A DDNAME OF WXYZ.                */
  /*                                                                */
  /* ************************************************************** */
  IF ERR_FLAG = 'N'
  THEN DO;
         K = INDEX(DSNAME,'(');
         K = K - 1;
         CALL DYNAM(WORK, 'ALLOC ', 'DSN='
         ×× SUBSTR(DSNAME,1,K)  ×× ' SHR;', 'DD=WXYZ;');
         IF PLIRETV ^= 0
         THEN DO;
                 CONS= 'DYNALLOC FAILED DSN='
                 ×× SUBSTR(DSNAME,1,K) ×× 'RC='
                 ×× PLIRETV;
                 CALL WRITEIT;
                 GO TO EXIT;
              END;
         LIBNAME = ' ';
         MPARML = 8;
         LIBNAME = SUBSTR(MEMBER,1,MEML-1);
         FETCH INVFIND;
         CALL INVFIND(FORMEM);
         SAVERC = PLIRETV;
         RELEASE INVFIND;
         CALL DYNAM(WORK, 'UNALLOC ', 'DSN='
                    ×× SUBSTR(DSNAME,1,K) ×× ' KEEP;', 'DD=WXYZ;');
         IF SAVERC ^= 0
         THEN DO;
                 ERR_FLAG = 'Y';
                 MSGID = 'INV008';
              END;
       END;
  END CHEKMEM;
- /* ************************************************************** */
  /*                                                                */
  /*            CLEAN UP AND TERMINATION SECTION.                   */
  /*                                                                */
  /* THE PLI COMPILER KNOWS ITS UNDER TSO SO WE WILL ALSO HAVE      */
  /* TO FREE DDNAME=TERMFILE AND OUR OWN TERMINAL DATASET.          */
  /*                                                                */
  /* IF THE USER HAS INDICATED HE WANTS A PRINT THEN ISSUE THE      */
  /* PRINTOFF COMMAND.                                              */
  /*                                                                */
  /*                                                                */
  /* ************************************************************** */
  EXIT: IF PRTOPT = 'YES'
        THEN DO;
                TSOCMD = 'PRINTOFF PLIF.LIST';
                TSOLEN = INDEX(TSOCMD,' ');
                CALL INVTSO(TSOLEN, TSOCMD);
                IF LINK = 'Y'
                THEN DO;
                        TSOCMD = 'PRINTOFF LNK.LINKLIST';
                        TSOLEN = INDEX(TSOCMD,' ');
                        CALL INVTSO(TSOLEN, TSOCMD);
                     END;
             END;
 CONS = 'PLI/F PROMPTER HAS FINISHED';
 CALL WRITEIT;
 EXIT1: RELEASE CATMAN;
 CLOSE FILE(MSGFILE);
 CALL DYNAM(WORK,'UNALLOC ','DD=MSGFILE;');
 RELEASE DYNAM;
 RELEASE INVTSO;
 CALL ISPLINK('VDELETE', '(SOURCE)');
 CALL ISPLINK('VDELETE', '(LNAME)');
 CALL ISPLINK('VDELETE', '(COPY1)');
 CALL ISPLINK('VDELETE', '(COPY2)');
 CALL ISPLINK('VDELETE', '(LOAD1)');
 CALL ISPLINK('VDELETE', '(LOAD)');
 CALL ISPLINK('VDELETE', '(OPT)');
 CALL ISPLINK('VDELETE', '(LDT)');
 CALL ISPLINK('VDELETE', '(PRTOPT)');
 END INVPLIF;
