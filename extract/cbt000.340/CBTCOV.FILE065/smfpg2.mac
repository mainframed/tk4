 SMFPG2:  PROC (PARAM) OPTIONS(MAIN); /* AUTO SMF   SMFPG2 MH       */
  /* ************************************************************** */
  /*                                                                */
  /*                                                                */
  /*                                                                */
  /*       MIKE AUTO SMF RECORD COLLECTION PROJECT : SMFPG2         */
  /*       ------------------------------------------------         */
  /*                                                                */
  /*                                                                */
  /*                                                                */
  /* ************************************************************** */
  /*                                                                */
  /*                                                                */
  /* THIS PROGRAM IS EXECUTED AUTOMATICALLY AT 04.00 EVERY NIGHT    */
  /* ON SYSTEM B. IT IS THE THIRD STEP IN OUR SMFNITE PROCEDURE.    */
  /* NEARLY ALL DATASETS ARE HANDLED BY DYNAMIC ALLOCATION SO       */
  /* YOU ONLY NEED A SYSPRINT DD NAME. THE INPUT DATASET IS HANDLED */
  /* BY A PARM CARD. TAPES ARE ALSO DYNAMICALLY ALLOCATED.          */
  /*                                                                */
  /* FOR SAMPLE JCL SEE THE MEMBER SMFNITE IN MVSUG.CNTL            */
  /*                                                                */
  /* THE SMFNITE PROCEDURE ITSELF SORTS THE DATASETS CREATED        */
  /* DURING THE DAY WHEN IEFU29 STARTS A JOB TO DUMP THE SMF DATA   */
  /* TO HOLDING DATASETS AND CREATES ANOTHER BACKUP DATASET         */
  /* FROM WHICH ANY DUPLICATE RECORDS ARE EXTRACTED (SMFPG1).       */
  /* THIS PROGRAM IS EXECUTED. A NUMBER OF SAS REPORTS ARE THEN RUN */
  /* IN FOLLOWING STEPS. ONCE YOU HAVE CAPTURED THE DATA YOU        */
  /* MUST DECIDE YOURSELF HOW YOU WANT TO HANDLE IT.                */
  /*                                                                */
  /*  THIS PROGRAM PERFORMS THE FOLLOWING FUNCTIONS:                */
  /*                                                                */
  /*    1) AS WE DONT HAVE ENOUGH TAPE DRIVES AND THE               */
  /*       OPERATORS SOMETIMES GET CONFUSED WITH MOUNT OR CANCEL    */
  /*       MESSAGES/REQUESTS FOR NON EXISTANT DEVICES               */
  /*       THEY ISSUE AN MVS OPERATOR CANCEL. THIS JOB THEN GETS    */
  /*       CANCELLED AT VARIOUS POINTS IN ITS EXECUTION AS IT       */
  /*       REQUESTS TAPE DRIVES SO THIS STEP READS A RESTART        */
  /*       DATASET. PROCESSING RESUMES FROM THE LAST COMPLETED      */
  /*       PROCEDURE.                                               */
  /*                                                                */
  /*       (MORAL : IT'S RELATIVELY EASY TO CODE SOMETHING          */
  /*        BUT MAKING IT OPERATOR OR USER PROOF IS MUCH HARDER     */
  /*        AND THAT IS WHERE THE TIME SHOULD BE SPENT              */
  /*        WHEN DESIGNING NEW SYSTEMS!!!)                          */
  /*                                                                */
  /*       THE STEPS IN PROCESSING ARE AS FOLLOWS                   */
  /*                                                                */
  /*         A) COPY DATA FROM SMFDATA.NITE.BACKUP TO A DAILY       */
  /*            DATASET.                                            */
  /*         B) COPY DATA FROM THE DAILY DATASET TO A WEEKLY        */
  /*            DATASET (TAPE).                                     */
  /*         C) COPY DATA FROM THE DAILY DATASET TO A MONTHLY       */
  /*            DATASET (TAPE).                                     */
  /*         D) SCRATCH AND REALLOCATE THE HOLDING DATASETS FOR     */
  /*            THE FOLLOWING DAYS USE BY THE JOB IEFU29 STARTS.    */
  /*         E) RE-INITIALIZE THE RE-START DATASET.                 */
  /*                                                                */
  /*       SMFDATA.NITE.BACKUP IS ALLOCATED AND CREATED BY THE      */
  /*       PREVIOUS STEP. THIS DATASET IS THE ONLY INPUT REQUIRED   */
  /*       FOR THIS JOB.                                            */
  /*                                                                */
  /*       THE RE-START DATASET CONSISTS OF AN 80-BYTE RECORD       */
  /*       WHERE THE IST 4 POSITIONS ARE Y IF THE PROCEDURE HAS     */
  /*       BEEN DONE OR AN N IF THE PROCEDURE HAS NOT BEEN DONE.    */
  /*       THIS DATASET IS DYNAMICALLY ALLOCATED IF IT DOES NOT     */
  /*       EXIST AND IS CALLED SMFDATA.RESTART.DATA                 */
  /*                                                                */
  /*       POSITION 1 : SMFDATA.MMMDDYY.DAILY HAS BEEN CREATED      */
  /*       POSITION 2 : DAILY DATA HAS BEEN COPIED TO WEEKLY TAPE.  */
  /*       POSITION 3 : DAILY DATA HAS BEEN COPIED TO MONTHLY TAPE. */
  /*       POSITION 4 : HOLDING DATASETS HAVE BEEN SCRATCHED AND    */
  /*                    RE-ALLOCATED.                               */
  /*                                                                */
  /*       EACH POSITION IS INDEPENDENT SO YOU CAN SET THEM         */
  /*       VIA ISPF/EDIT IF YOU WANT TO RUN THE JOB AGAIN TO        */
  /*       COPY THE DATA TO SAY ANOTHER WEEKLY TAPE BUT NOT         */
  /*       A MONTHLY AND YOU DO NOT WANT THE TEMPORARY HOLDING      */
  /*       DATASETS TO BE SCRATCHED AND RE-ALLOCATED                */
  /*                                                                */
  /*       YOU WOULD THEN SET THE RECORD TO YNYY                    */
  /*                                                                */
  /*       IF THERE IS NO RE-START DATASET (IT WILL BE ALLOCATED    */
  /*       DYNAMICALLY) OR IF THE JOB HAS ALREADY RUN TO COMPLETION */
  /*       THE RECORD CONTAINS NNNN.                                */
  /*                                                                */
  /*       (UNCATALOG THE WEEKLY TAPE IST OR YOU WILL JUST GET      */
  /*        DUPLICATE DATA AT THE END OF IT. YOU CAN THEN           */
  /*        UNCATALOG THIS ONE AND RE-CATALOG THE OLD ONE           */
  /*        IF YOU WANT TO).                                        */
  /*                                                                */
  /*       THE HOLDING DATASETS ARE SMFDATA.TEMP.CPUB AND           */
  /*                                SMFDATA.TEMP.CPUC.              */
  /*                                                                */
  /*       THEY SHOULD BE ALLOCATED WITH ENOUGH SPACE (SECONDARY    */
  /*       ALSO) TO HOLD 24 HRS SMF DATA. IF YOU HAVE MORE          */
  /*       MACHINES YOU CAN ADD DATASETS.                           */
  /*                                                                */
  /*       IF YOU WANT TO CHANGE DATASET NAMES OR SPACE ALLOCATIONS */
  /*       JUST ALTER THE CODE IN THE CALLS TO DYNAM.               */
  /*       IF YOU WANT TO ADD DATASETS JUST INSERT THE RELEVANT     */
  /*       CODE.                                                    */
  /*                                                                */
  /*       DYNAMIC ALLOCATION IS MUCH BETTER THAN MESSING ABOUT     */
  /*       WITH A LOAD OF JCL AND HOW CAN YOU CREATE MEANINGFUL     */
  /*       DAILY DATASETS WITH A NAME OF SMFDATA.MMMDDYY.DAILY      */
  /*       E.G SMFDATA.AUG1185.DAILY IF YOU HAVE STATIC JCL IN A    */
  /*       LIBRARY.                                                 */
  /*                                                                */
  /*       IF THE JOB IS MANUALLY CANCELLED IN THE MIDDLE OF A      */
  /*       STEP THEN YOU WILL HAVE DUPLICATE DATA. SINCE THE        */
  /*       PROBLEMS ONY SEEM TO ARRIVE AT TAPE ALLOCATION TIME      */
  /*       THIS SHOULD NOT BE A PROBLEM.                            */
  /*                                                                */
  /*       PROGRAM SMFKOPY CAN BE RUN TO REMOVE DUPLICATE DATA      */
  /*       IN AN SMF BACKUP DATASET PROVIDED IT HAS BEEN SORTED.    */
  /*                                                                */
  /*                                                                */
  /*                                                                */
  /*    2) CREATES A DATASET SMFDATA.MMMDDYY WHERE MMMDDYY IS THE   */
  /*       DATE OF THE PREVIOUS DAY (NOTE WE ARE AT 00.30 OF A NEW  */
  /*       DAY.
  /*                                                                */
  /*    3) COPIES THE OUTPUT FROM THE MERGED DATASETS TO THIS NEW   */
  /*       DATASET. (THE SORTSTEP IS STEP 1 OF THIS JOB)            */
  /*       THE INPUT DATASET IS THE BACKUP DATASET COPIED FROM THE  */
  /*       SORTED DATASET. IN THE EVENT OF AN ABEND E.G X37 YOU     */
  /*       CAN THEN RE-RUN THE JOB.                                 */
  /*                                                                */
  /*    4) SCRATCHES THE 8TH OLDEST SMFDATA.MMMDDYY.DAILY DATASET.  */
  /*                                                                */
  /*    5) IF THE DAY OF THE WEEK FROM 1) IS A SUNDAY WE CREATE     */
  /*       A NEW TAPE DATASET SMFDATA.MMMDDYY.WEEKLY AND COPY THE   */
  /*       THE SMFDATA.MMMDDYY.DAILY DATASET TO IT                  */
  /*       OTHERWISE WE GET VOLUME SERIAL OF THE PREVIOUS WEEKS     */
  /*       TAPE AND COPY THE SMFDATA.MMMDDYY.DAILY DATASET TO IT    */
  /*       WITH A DISP OF MOD.                                      */
  /*       WE THEN CHECK FOR A DATE OF 01. IF WE FIND ONE WE        */
  /*       ALLOCATE A NEW MONTHLY DATASET SMFDATA.MMMDDYY.MONTHLY   */
  /*       AND COPY THE SMFDATA.MMMDDYY.DAILY DATASET TO IT.        */
  /*       OTHERWISE WE USE THE CURRENT MONTHS TAPE WITH A DISP OF  */
  /*       MOD.                                                     */
  /*                                                                */
  /*    8) THE SMF TEMPORARY DATASETS SMFDATA.TEMP.CPUB AND         */
  /*       SMFDATA.TEMP.CPUC ARE SCRATCHED UNCATALOGUED AND         */
  /*       RE ALLOCATED USING CALLS TO CATMAN.                      */
  /*                                                                */
  /*       DATA SET ALLOCATION IS HANDLED BY A DYNAMIC ALLOCATION   */
  /*       INTERFACE.(PROGRAM NAME DYNAM : SEE MEMBER DYNAM IN      */
  /*       DATASET MVSUG.DOCUMENT ON HOW TO USE IT.                 */
  /*                                                                */
  /*       CATALOG MANAGEMENT AND DASDM IS HANDLED BY CALLS TO      */
  /*       A CATALOG INTERFACE ROUTINE CATMAN.                      */
  /*                                                                */
  /*               FUNCTION I RETURNS UP TO 20 VOLUMES FOR A DSN.   */
  /*               FUNCTION U UNCATALOGS A DATASET.                 */
  /*               FUNCTION S SCRATCHES A DATASET.                  */
  /*               FUNCTION P SCRATCHES AND UNCATALOGS A DATASET.   */
  /*                                                                */
  /*    6) A LIST IS PRODUCED SHOWING ALL DATASET ALLOCATIONS       */
  /*       AND UN-ALLOCATIONS IN THE VERY UNLIKELY EVENT OF         */
  /*       AN UN-DETECTED ERROR OCCURRING.                          */
  /*                                                                */
  /*    7) IF WE HAVE A NUL INPUT FILE OR IF DYNAMIC ALLOCATION AND */
  /*       DE-ALLOCATION FAILS THEN A MESSAGE IS SENT TO THE        */
  /*       OPERATOR WHO MUST REPLY TO CONTINUE.. THE PROGRAM WILL   */
  /*       THEN TERMINATE WITH AN RC=16. THE RELEVANT SUPPORT       */
  /*       PERSON CAN THEN CORRECT THE ERROR AND YOU CAN RE-RUN.    */
  /*                                                                */
  /*                                                                */
  /*                                                                */
  /*        NOTE ON RE-RUNNING.                                     */
  /*        ===================                                     */
  /*                                                                */
  /*                                                                */
  /*      THIS WHOLE PROCEDURE WAS DESIGNED TO BE AS AUTOMATIC      */
  /*      AS POSSIBLE AND THEREFORE TO BE RUN ONLY ONCE EVERY       */
  /*      DAY (ERRORS AND ABENDS EXCEPTED).                         */
  /*      IF THE JOB RUNS SUCCESSFULLY AND YOU WISH TO RE-RUN       */
  /*      THE WHOLE PROCEDURE AGAIN LATER                           */
  /*      YOU MUST ENSURE THE FOLLOWING IS DONE:                    */
  /*                                                                */
  /*                                                                */
  /*      A) RE-NAME THE EXISTING SMFDATA.MMMDDYY.DAILY DATASET     */
  /*         TO ANYTHING YOU LIKE.                                  */
  /*      B) RUN THE JOB                                            */
  /*      C) RUN ANY PROGRAM YOU LIKE TO COPY THE OLD DAILY         */
  /*         DATASET INTO THE NEW ONE WITH A DISP OF MOD            */
  /*      D) DELETE THE OLD DATASET.                                */
  /*                                                                */
  /*       THE ONLY POTENTIAL PROBLEM WITH THIS JOB IS THAT AN      */
  /*       SMF DATASET COULD BECOME FILLED BEFORE THIS JOB HAS      */
  /*       FINISHED EXECUTING. HOWEVER IT IS UNLIKELY THAT AN       */
  /*       SMF DATASET SHOULD BECOME FILLED IN 20 MINS.             */
  /*       NOTE THAT AN AUTOMATIC I SMF COMMAND IS ISSUED ON        */
  /*       BOTH SYSTEMS EVERY NIGHT AT 00.00                        */
  /*                                                                */
  /*                                                                */
  /*  SEE PROGRAM COMMENTS IN SMGPG1 FOR USE ON THE DYNAMIC         */
  /*  ALLOCATION INTERFACE.                                         */
  /*                                                                */
  /*   SUGGESTIONS IMPROVEMENTS AND COMMENTS WILL BE GRATEFULLY     */
  /*   RECEIVED.                                                    */
  /*                                                                */
  /*           MIKE HAWTHORNE   TTI CITICORP                        */
  /*                            3100 OCEAN PK BLVD                  */
  /*          (213) 450-9111    SANTA MONICA CA 90405               */
  /*                 X2353                                          */
  /*                                                                */
  /*                                                                */
  /*   WISH LIST : A) X37 ABEND INTERCEPT AND RETRY ROUTINE.        */
  /*                  I'M SURE SOMEONE OUT THERE HAS ONE FOR PL/I   */
  /*                                                                */
  /*                                                                */
  /*                                                                */
  /* ************************************************************** */
  DCL PARAM                 CHAR(100) VARYING;
  DCL DYNAM                 ENTRY OPTIONS (ASSEMBLER,RETCODE);
  DCL DOODATE               ENTRY OPTIONS (ASSEMBLER,RETCODE);
  DCL CATMAN                ENTRY OPTIONS (ASSEMBLER,RETCODE);
  DCL SMFIN         FILE RECORD SEQUENTIAL BUFFERED ENV(VBS);
  DCL SMFOUT        FILE RECORD SEQUENTIAL ENV(VBS);
  DCL SMFWEEK       FILE RECORD SEQUENTIAL ENV(VBS);
  DCL SMFMON        FILE RECORD SEQUENTIAL ENV(VBS);
  DCL RESTART       FILE STREAM ENV(FB);
  DCL RECIN                 CHAR(32000) VARYING;
  DCL RECOUT                CHAR(32000) VARYING;
  DCL WORK                  FIXED BIN(31) INIT(0);
  DCL FILE_IND              CHAR(1) INIT('N');
  DCL ERR_IND               CHAR(1) INIT('N');
  DCL RESTART_IND           CHAR(1) INIT('N');
  DCL K                     PIC '99' INIT('0');
  DCL TXT                   CHAR(60) INIT(' ');
  DCL MONTHDSN              CHAR(44) INIT(' ');
  DCL RECAREA               CHAR(80);
  DCL D                     PTR;
  DCL Q                     PTR;
  DCL R                     PTR;
  DCL Y                     PTR;
  DCL Z                     PTR;
  DCL 1 RESTART_REC  BASED(Y),
       3   DUMP_DAY         CHAR(1),
       3   DUMP_WEEK        CHAR(1),
       3   DUMP_MONTH       CHAR(1),
       3   DUMP_DEL         CHAR(1),
       3   DUMP_SPARE       CHAR(76);
  /* ************************************************************** */
  /*                                                                */
  /*  THIS WORK AREA IS USED TO INSERT A DATASET NAME AND A         */
  /*  DISPOSITION TO BE PASSED TO THE DYNAMIC ALLOCATION INTERFACE. */
  /*                                                                */
  /* ************************************************************** */
  DCL 1 DYNPARM,
        3  PREF             CHAR(4) INIT('DSN='),
        3  DSN              CHAR(44) INIT(' ');
  /* ************************************************************** */
  /*                                                                */
  /*  THIS AREA IS THE PARM PASSED FROM THE JCL CARD.               */
  /*  NOTE PL/I REQUIRES PARM='/PARMDATA     ' THE / IS             */
  /*  MANDATORY. IF OMITTED PL/I ASSUMES THE PARM VALUE IS/ARE      */
  /*  PL/I RUN TIME OPTIONS. YOU ONLY GET THE ACTUAL LENGTH OF YOUR */
  /*  PARM WITHOUT THE / AND ALSO THE DATA WITHOUT THE /.           */
  /*                                                                */
  /* ************************************************************** */
  DCL 1    PARMINFO         BASED(Q),
        3    PARML          FIXED BIN(15),    /* LENGTH OF PARM */
        3    PARMT          CHAR(100);        /* ACTUAL PARM    */
  /* ************************************************************** */
  /*                                                                */
  /*  WORK AREA HERE IS USED BY DOODATE ASSEMBLER LANGAUGE PROGRAM  */
  /*  TO RETURN DATES TIMES AND DAY OF THE WEEK. I USED IT HERE     */
  /*  AS I ALREADY HAVE THE ROUTINES WRITTEN AND I DON'T WANT TO    */
  /*  WRITE THEM AGAIN.                                             */
  /*                                                                */
  /*  BINARY ZERO IN THE IST FIELD MEANS SYSTEM RETURNS CURRENT     */
  /*  DATE AND TIME TOGETHER WITH TIME IN BINARY AND DATE IN        */
  /*  JULIAN PACKED FORMAT 00YYDDDF SO WE CAN DO OUR SUBTRACTIONS.  */
  /*                                                                */
  /*                                                                */
  /* ************************************************************** */
  DCL 1 DATEPARM            UNALIGNED,
        3 U_TIME            FIXED BIN(31) INIT('0'),
        3 U_DATE            FIXED (7),
        3 RET_TIME          CHAR(8),
        3 RET_DATE          CHAR(7),
        3 RET_DAY           CHAR(3),
        3 MC_TIME           CHAR(8) INIT(' '),
        3 MC_DATE           CHAR(7) INIT(' '),
        3 MC_DAY            CHAR(3) INIT(' ');
 DCL  1 DATE_FIELD          BASED(R),
        3 MMM               CHAR(3),
        3 DD                PIC '99',
        3 YY                PIC '99';
 DCL  1 PDAY  UNALIGNED     BASED(D),
        3 DYY               CHAR(2),
        3 DDD               FIXED(3);
 Q = ADDR(PARAM);
 R = ADDR(RET_DATE);
 D = ADDR(U_DATE);
  /* ************************************************************** */
  /*                                                                */
  /*  THIS WORK AREA IS USED BY THE CATALOG RETRIEVAL ASSEMBLY      */
  /*  LANGUAGE PROGRAM. THIS ROUTINE RETURNS DATASET INFORMATION    */
  /*  AND SCRATCHES / UNCATALOGS DATASETS.                          */
  /*                                                                */
  /* ************************************************************** */
  DCL PARMA                 CHAR(169) BASED(Z);
  Y = ADDR(RECAREA);
  Z = ADDR(DSPARMS);
  DCL 1 DSPARMS,
        3 FNC               CHAR(1),
        3 DSNAME            CHAR(44) INIT(' '),
        3 VOLCOUNT          FIXED BIN(31) INIT('0'),
        3 VOLLIST(20)       CHAR(6);
  DCL CONS                  CHAR(120) INIT(' ');
  DCL VOLID                 CHAR(11);
  DCL (ADDR, SUBSTR, LENGTH, PLIRETV, PLIRETC, STRING) BUILTIN;
  /* ************************************************************** */
  /*                                                                */
  /*  DYNAMICALLY LOAD DYNAMIC ALLOCATION DATE FORMATTER AND        */
  /*  CATALOG RETRIEVAL ROUTINES.                                   */
  /*                                                                */
  /* ************************************************************** */
  FETCH DYNAM;
  FETCH DOODATE;
  FETCH CATMAN;
  /* ************************************************************** */
  /*                                                                */
  /*  INITIALIZE WORK AREA REQUIRED BY THE DYNAMIC ALLOCATION       */
  /*  INTERFACE.                                                    */
  /*  ALLOCATE OUR PRIMARY INPUT DATASET.                           */
  /*  IF ITS NO GOOD THEN LETS EXIT WITHOUT FURTHER PROCESSING.     */
  /*                                                                */
  /* ************************************************************** */
  CALL DYNAM(WORK, 'INIT ');
  DSNAME=SUBSTR(PARMT,1,PARML);
  DSN = SUBSTR(DSNAME,1,PARML) ×× ' SHR;';
          CALL DYNAM(WORK, 'ALLOC ', DYNPARM,
                            'VBS;',
                            'LRECL=32000 BLKSIZE=4096;',
                             'DD=SMFIN;');
   IF PLIRETV ^= 0
   THEN DO;
           CONS = 'JOB BLEW UP : NON EXISTANT INPUT DATA SET'
           ×× ' ENTER ANY CHAR TO CONTINUE';
           ERR_IND = 'Y';
           DISPLAY (CONS) REPLY(TXT);
           GO TO ENDPRG2;
        END;
   ELSE DO;
            CONS = 'INPUT DATASET ' ×× SUBSTR(DSN,1,PARML)
                   ×× ' SUCCESSFULLY ALLOCATED';
            PUT SKIP EDIT (CONS)(A);
        END;
  /* ************************************************************** */
  /*                                                                */
  /*  CHECK CATALOG FOR EXISTING DATASET. IF NOT THERE THEN ALLOCATE*/
  /*  A NEW ONE OTHERWISE ALLOCATE EXISTING DATASET WITH DISP=SHR.  */
  /*                                                                */
  /* ************************************************************** */
  DSNAME = 'SMFDATA.RESTART.DATA';
  FNC = 'I';
  CALL CATMAN(PARMA);
  IF PLIRETV ^=0
  THEN DO;
  DSN = 'SMFDATA.RESTART.DATA NEW CATLG;';
  CALL DYNAM(WORK, 'ALLOC ', DYNPARM,
                             'DD=RESTART;',
                             'TRK PRIM=1 SEC=1;',
                             'FB;',
                             'VOL=SYS003;',
                             'LRECL=80 BLKSIZE=80;');
  CONS = 'DATASET ' ×× SUBSTR(DSN,1,21) ×× ' SUCCESSFULLY ALLOCATED';
  PUT SKIP EDIT (CONS)(A);
            DUMP_DAY = 'N';
            DUMP_WEEK = 'N';
            DUMP_MONTH = 'N';
            DUMP_DEL = 'N';
            DUMP_SPARE = ' ';
            PUT FILE(RESTART) EDIT(RECAREA)(A(80));
            CLOSE FILE(RESTART);
       END;
  ELSE DO;
          DSN = 'SMFDATA.RESTART.DATA SHR;';
          CALL DYNAM(WORK, 'ALLOC ', DYNPARM,
                             'DD=RESTART;');
          CONS= 'EXISTING RESTART DATASET BEING USED';
          PUT SKIP EDIT (CONS)(A);
          OPEN FILE(RESTART) INPUT;
          GET FILE(RESTART) EDIT(RECAREA)(A(80));
          CLOSE FILE(RESTART);
       END;
  /* ************************************************************** */
  /*                                                                */
  /*  GET CURRENT SYSTEM DATE AND TIME FOR DATASET DYNAMIC          */
  /*  ALLOCATION                                                    */
  /*  WE WILL THEN DYNAMICALLY ALLOCATE OUR DATASET WITH THE        */
  /*  NAME SMFDATA.MMMDDYY.DAILY AND COPY THE MERGED SORTED FILE    */
  /*  TO THIS DATASET.                                              */
  /*  THE MMMDDYY WE WANT IS ONE LESS THAN THE CURRENT DATE         */
  /*                                                                */
  /* ************************************************************** */
  U_TIME = 0;
  CALL DOODATE(DATEPARM);
  IF SUBSTR(MC_DATE,1,5) = 'JAN01'
  THEN DO;
          RET_DATE = MC_DATE;
          YY = YY - 1;
          SUBSTR(MC_DATE,1,5) ='DEC31';
       END;
  ELSE DO;
          U_DATE = U_DATE - 1;      /* GET YESTERDAY DATE   */
          CALL DOODATE(DATEPARM);   /* NOW GOT IT           */
       END;
  MONTHDSN = 'SMFDATA.' ×× MMM ×× '01' ×× YY ×× '.MONTHLY';
  /* ************************************************************** */
  /*                                                                */
  /*  CHECK CATALOG FOR EXISTING DATASET. IF NOT THERE THEN ALLOCATE*/
  /*  A NEW ONE OTHERWISE ALLOCATE EXISTING DATASET WITH DISP=MOD.  */
  /*  NOTE: IF YOU RE-RUN THIS JOB YOU COULD GET DUPLICATE DATA     */
  /*  ON THE WEEKLY/MONTHLY TAPES. HOWEVER A RE-RUN IS USUALLY      */
  /*  REQUESTED SINCE THE OPERATORS CANCEL AT TAPE ALLOCATION       */
  /*  AND THE RESTART DATASET WILL INDICATE WHERE TO START FROM.    */
  /*                                                                */
  /*                                                                */
  /* ************************************************************** */
  DSNAME = 'SMFDATA.' ×× RET_DATE ×× '.DAILY';
  FNC = 'I';
  CALL CATMAN(PARMA);
  IF PLIRETV ^=0
  THEN DO;
  DSN = 'SMFDATA.' ×× RET_DATE ×× '.DAILY NEW CATLG;';
  CALL DYNAM(WORK, 'ALLOC ', DYNPARM,
                             'DD=SMFOUT;',
                             'CYL PRIM=40 SEC=10 RLSE;',
                             'VOL=SYSSMF;',
                             'LRECL=32000 BLKSIZE=4096;');
  CONS = 'DATASET ' ×× SUBSTR(DSN,1,21) ×× ' SUCCESSFULLY ALLOCATED';
  PUT SKIP EDIT (CONS)(A);
      END;
  ELSE DO;
          VOLID = 'VOL=' ×× VOLLIST(VOLCOUNT) ×× ';';
          DSN = 'SMFDATA.' ×× RET_DATE ×× '.DAILY MOD KEEP;';
          CALL DYNAM(WORK, 'ALLOC ', DYNPARM,
                             'DD=SMFOUT;',
                             'VBS;',
                             'LRECL=32000 BLKSIZE=4096;',
                             VOLID,
                            'UNIT=3380;');
         CONS = 'EXISTING DATASET ' ×× SUBSTR(DSN,1,22)
                ×× ' USED ON VOL ' ×× VOLLIST(VOLCOUNT);
         PUT SKIP EDIT (CONS)(A);
       END;
   IF DUMP_DAY = 'Y'
   THEN DO;
           CONS = 'DAILY DATASET ALREADY COPIED : STEP SKIPPED';
           PUT SKIP EDIT (CONS)(A);
           RESTART_IND = 'Y';      /* SET RESTART INDICATOR */
           GO TO WEEK;
        END;
  /* ************************************************************** */
  /*                                                                */
  /*  COPY OUR SORT OUTPUT TO THE NEWLY ALLOCATED DATSET.           */
  /*  NOTE WE RLSE UNUSED SPACE AS THIS DATASET IS NOW ONLY         */
  /*  GOING TO BE READ.                                             */
  /*                                                                */
  /* ************************************************************** */
  ON ENDFILE (SMFIN)        FILE_IND = 'Y';
  ON UNDEFINEDFILE(SMFIN)   ERR_IND = 'Y';
  OPEN FILE(SMFIN) INPUT, FILE(SMFOUT) OUTPUT;
  IF ERR_IND = 'Y'
  THEN GO TO WEEK;      /* CONTINUE PROCESSING*/
  READ FILE(SMFIN) INTO(RECIN);
  DO WHILE (FILE_IND = 'N');
     IF FILE_IND = 'Y'
     THEN LEAVE;
     RECOUT = RECIN;
     WRITE FILE(SMFOUT) FROM(RECOUT);
     READ FILE(SMFIN) INTO(RECIN);
  END;
  CLOSE FILE(SMFIN), FILE(SMFOUT);
  DUMP_DAY = 'Y';
  OPEN FILE(RESTART) OUTPUT;
  PUT FILE(RESTART) EDIT(RECAREA)(A(80)); /* UPDATE RESTART FILE*/
  CLOSE FILE(RESTART);
  /* ************************************************************** */
  /*                                                                */
  /* IF THE INPUT (SORTED SMF DATASET FROM PREVIOUS STEP) IS NO     */
  /* GOOD ISSUE A MESSAGE AND EXIT. THE UNDEFINED FILE CONDITION    */
  /* WILL HAVE SET THE ERROR INDICATOR TO A 'Y'                     */
  /*                                                                */
  /* FREE THE DAILY DATASET AND NOW ALLOCATE IT AGAIN WITH A DISP   */
  /* OF SHR. WE USE THIS AS INPUT FOR THE REST OF THE PROGRAM.      */
  /*                                                                */
  /*  WE NOW SCRATCH THE 7TH OLDEST PREVIOUS ONE. IF THE DATASET    */
  /*  DOES NOT EXIST THERE IS NO PROBLEM.                           */
  /*  (WE ACTUALLY HAVE 7 HELD ON DISK)                             */
  /*                                                                */
  /*  WE REDUCE THE DATE BY 8 AND CALL THE DATE FORMATTER ROUTINE   */
  /*  SO WE CAN GET THE DATASET NAME SMFDATA.MMMDDYY.DAILY AND      */
  /*  REQUEST CATALOG MANAGEMENT TO SCRATCH AND UNCATALOG IT.       */
  /* ************************************************************** */
  WEEK: IF ERR_IND = 'Y'
  THEN DO;
          CONS = 'JOB BLEW UP : SMF INPUT DATASET CORRUPTED'
          ×× ' ENTER ANY CHAR TO CONTINUE';
           ERR_IND = 'Y';
          DISPLAY (CONS) REPLY(TXT);
          GO TO ENDPRG2;
       END;
   VOLID = 'VOL=' ×× VOLLIST(VOLCOUNT) ×× ';';
  DSN = 'SMFDATA.' ×× RET_DATE ×× '.DAILY KEEP;';
  CALL DYNAM(WORK, 'UNALLOC ', DYNPARM,
                   'DD=SMFOUT;');
  IF PLIRETV = 0
  THEN DO;
          CONS = 'UNALLOCTION FOR DAILY DATASET SUCCESSFUL';
          PUT SKIP EDIT (CONS)(A);
       END;
  ELSE DO;
          CONS = 'JOB BLEW UP : UNALLOCATION RC = ' ×× PLIRETV
          ×× ' ENTER ANY CHAR TO CONTINUE';
          DISPLAY (CONS) REPLY(TXT);
           ERR_IND = 'Y';
          GO TO ENDPRG2;
       END;
  DSN = 'SMFDATA.' ×× RET_DATE ×× '.DAILY SHR KEEP;';
          CALL DYNAM(WORK, 'ALLOC ', DYNPARM,
                             'DD=SMFOUT;',
                             'VBS;',
                             'LRECL=32000 BLKSIZE=4096;');
  IF PLIRETV ^=0
  THEN DO;
          CONS = 'JOB BLEW UP : REALLOCATION RC = ' ×× PLIRETV
          ×× ' ENTER ANY CHAR TO CONTINUE';
          DISPLAY (CONS) REPLY(TXT);
           ERR_IND = 'Y';
          GO TO ENDPRG2;
       END;
  CONS = 'EXISTING DATASET ' ×× SUBSTR(DSN,1,22)
          ×× ' REALLOCATED ';
  PUT SKIP EDIT (CONS)(A);
  IF DUMP_WEEK = 'Y'
  THEN DO;
           CONS = 'WEEKLY DATASET ALREADY COPIED : STEP SKIPPED';
           PUT SKIP EDIT (CONS)(A);
           RESTART_IND = 'Y';      /* SET RESTART INDICATOR */
           GO TO MONTH;
       END;
  IF MMM = 'JAN'
  THEN DO;
          IF DD < 8
          THEN DO;
                  K = 8 - DD;  /* IF JAN08 THEN PREV YEAR ALL GONE  */
                  YY = YY - 1;
                  MMM = 'DEC';
                  DD = 31 - K; /* FIDDLED BACK THE DATE             */
              END;
       END;
  ELSE DO;
          U_DATE = U_DATE - 8;
          CALL DOODATE(DATEPARM);
       END;
  FNC = 'P';              /* GOING TO PURGE DATASET  */
  DSNAME = 'SMFDATA.' ×× RET_DATE ××'.DAILY';
  CALL CATMAN(DSPARMS);
  IF PLIRETV ^= 0
  THEN DO;
          CONS = 'PURGE FAILED FOR DATASET '
                  ×× SUBSTR(DSNAME,1,21) ×× ' RC=' ×× PLIRETV;
          PUT SKIP EDIT(CONS)(A);
          CONS = 'DATASET DID NOT EXIST SO RC=8 IS ACCEPTABLE'
                 ×× '--RECOVERY OK  JOB CONTINUING';
       END;
  ELSE DO;
          CONS = 'PURGE SUCCESSFUL FOR DATASET '
                  ×× SUBSTR(DSNAME,1,21);
       END;
  PUT SKIP EDIT(CONS)(A);
  /* ************************************************************** */
  /*                                                                */
  /*  FROM THE DAY OF THE WEEK WE NOW FIND OUT THE DATE THAT        */
  /*  SUNDAY WAS ON. WE THEN CHECK TO SEE IF THIS DATASET IS IN     */
  /*  THE CATALOG. IF IT IS WE ALLOCATE THE LATEST VOLUME WITH      */
  /*  DISP OF MOD, OTHERWISE WE ALLOCATE A NEW DATASET.             */
  /*  WE THEN COPY OUR NEWLY CREATED DAILY DATASET TO THIS ONE.     */
  /*                                                                */
  /*  WE WANT THE MACHINE DATE NOW TO GET SUNDAYS DATE.             */
  /*                                                                */
  /*  GLITCH  CORRECT FOR LEAP YEAR : HAVE UNTIL 88 TO FIX.         */
  /*                                                                */
  /* ************************************************************** */
   U_TIME = 0;               /* INDICATE MACHINE DATE WANTED */
  CALL DOODATE(DATEPARM);
  SELECT (MC_DAY);
      WHEN ('MON') DO;
                      U_DATE = U_DATE - 1;
                      IF DDD = 0
                      THEN DO;
                              YY = YY - 1;
                              U_DATE = YY * 1000 + 365;
                           END;
                   END;
      WHEN ('TUE') DO;
                      U_DATE = U_DATE - 2;
                      IF DDD = 0
                      THEN DO;
                              YY = YY - 1;
                              U_DATE = YY * 1000 + 365;
                           END;
                   END;
      WHEN ('WED') DO;
                      U_DATE = U_DATE - 3;
                      IF DDD = 0
                      THEN DO;
                              YY = YY - 1;
                              U_DATE = YY * 1000 + 365;
                           END;
                   END;
      WHEN ('THU') DO;
                      U_DATE = U_DATE - 4;
                      IF DDD = 0
                      THEN DO;
                              YY = YY - 1;
                              U_DATE = YY * 1000 + 365;
                           END;
                   END;
      WHEN ('FRI') DO;
                      U_DATE = U_DATE - 5;
                      IF DDD = 0
                      THEN DO;
                              YY = YY - 1;
                              U_DATE = YY * 1000 + 365;
                           END;
                   END;
      WHEN ('SAT') DO;
                      U_DATE = U_DATE - 6;
                      IF DDD = 0
                      THEN DO;
                              YY = YY - 1;
                              U_DATE = YY * 1000 + 365;
                           END;
                   END;
      OTHERWISE    DO;  /* WANT LAST SUNDAYS NOT TODAYS DATE */
                      U_DATE = U_DATE - 7;
                      IF DDD = 0
                      THEN DO;
                              YY = YY - 1;
                              U_DATE = YY * 1000 + 365;
                           END;
                   END;
  END;
  CALL DOODATE(DATEPARM);   /* NOW GOT IT           */
  /* ************************************************************** */
  /*                                                                */
  /*  WE CALL OUR CATALOG ROUTINE TO SEE IF WE HAVE THE DATASET     */
  /*  ALREADY CATALOGUED. IF IT IS WE DYNAMICALLY ALLOCATE THE      */
  /*  LAST VOLUME OTHERWISE WE ALLOCATE A NEW ONE                   */
  /*                                                                */
  /* ************************************************************** */
  DSNAME = 'SMFDATA.' ×× RET_DATE ×× '.WEEKLY';
  FNC = 'I';
  CALL CATMAN(PARMA);
  IF PLIRETV ^=0
  THEN DO;
          DSN = 'SMFDATA.' ×× RET_DATE ×× '.WEEKLY NEW CATLG;';
          CALL DYNAM(WORK, 'ALLOC ', DYNPARM,
                             'DD=SMFWEEK;',
                             'UNIT=TAPE;',
                             'VBS;',
                             'LRECL=32000 BLKSIZE=4096;');
         CONS = 'NEW DATASET ' ×× SUBSTR(DSN,1,22)
                ×× ' ALLOCATED';
       END;
  ELSE DO;
          VOLID = 'VOL=' ×× VOLLIST(VOLCOUNT) ×× ';';
          DSN = 'SMFDATA.' ×× RET_DATE ×× '.WEEKLY MOD CATLG;';
          CALL DYNAM(WORK, 'ALLOC ', DYNPARM,
                             'DD=SMFWEEK;',
                             'VBS;',
                             'LRECL=32000 BLKSIZE=4096;');
         CONS = 'EXISTING DATASET ' ×× SUBSTR(DSN,1,22)
                ×× ' USED ON VOL ' ×× VOLLIST(VOLCOUNT);
       END;
  PUT SKIP EDIT (CONS)(A);
  FILE_IND = 'N';
  ON ENDFILE (SMFOUT)      FILE_IND = 'Y';
  ON UNDEFINEDFILE(SMFOUT)  ERR_IND = 'Y';
  OPEN FILE(SMFOUT) INPUT, FILE(SMFWEEK) OUTPUT;
  IF ERR_IND = 'Y'
  THEN GO TO MONTH;     /* CONTINUE PROCESSING*/
  READ FILE(SMFOUT) INTO(RECIN);  /* USE SAME I/O BUFFERS */
  DO WHILE (FILE_IND = 'N');
     IF FILE_IND = 'Y'
     THEN LEAVE;
     RECOUT = RECIN;
     WRITE FILE(SMFWEEK) FROM(RECOUT);
     READ FILE(SMFOUT) INTO(RECIN);
  END;
  CLOSE FILE(SMFOUT), FILE(SMFWEEK);
  DUMP_WEEK = 'Y';
  OPEN FILE(RESTART) OUTPUT;
  PUT FILE(RESTART) EDIT(RECAREA)(A(80)); /* UPDATE RESTART FILE*/
  CLOSE FILE(RESTART);
  /* ************************************************************** */
  /*                                                                */
  /* IF THE INPUT (DAILY DATASET JUST CREATED IS NO GOOD            */
  /* GOOD ISSUE A MESSAGE AND EXIT. THE UNDEFINED FILE CONDITION    */
  /* WILL HAVE SET THE ERROR INDICATOR TO A 'Y'                     */
  /*  WE CALL OUR CATALOG ROUTINE TO SEE IF WE HAVE THE DATASET     */
  /*  ALREADY CATALOGUED. IF IT IS WE DYNAMICALLY ALLOCATE THE      */
  /*  LAST VOLUME OTHERWISE WE ALLOCATE A NEW ONE                   */
  /*                                                                */
  /*  THIS IS THE MONTHLY DATASET.                                  */
  /*                                                                */
  /*  THE FORMAT IS SMFDATA.MMM01YY.MONTHLY                         */
  /*  WE ALREADY OBTAINED THE MONTH DSN WHEN WE ALLOCATED OUR       */
  /*  DAILY DATASET.                                                */
  /*                                                                */
  /* ************************************************************** */
  MONTH: IF ERR_IND = 'Y'
  THEN DO;
          CONS = 'JOB BLEW UP : WEEKLY DATASET NOT UPDATED '
          ×× '- BAD INPUT  :  ENTER ANY CHAR TO CONTINUE';
          DISPLAY (CONS) REPLY(TXT);
          GO TO ENDPRG2;
       END;
  DSNAME = MONTHDSN;
  IF DUMP_MONTH = 'Y'
  THEN DO;
           CONS = 'MONTHLY DATASET ALREADY COPIED : STEP SKIPPED';
           PUT SKIP EDIT (CONS)(A);
           RESTART_IND = 'Y';      /* SET RESTART INDICATOR */
           GO TO DELTEMP;
       END;
  FNC = 'I';
  CALL CATMAN(PARMA);
  IF PLIRETV ^=0
  THEN DO;
          DSN = SUBSTR(MONTHDSN,1,23) ×× ' NEW CATLG;';
          CALL DYNAM(WORK, 'ALLOC ', DYNPARM,
                             'DD=SMFMON;',
                             'UNIT=TAPE;',
                             'VBS;',
                             'LRECL=32000 BLKSIZE=4096;');
         CONS = 'NEW DATASET ' ×× SUBSTR(DSN,1,23)
                ×× ' ALLOCATED';
       END;
  ELSE DO;
          VOLID = 'VOL=' ×× VOLLIST(VOLCOUNT) ×× ';';
          DSN = SUBSTR(MONTHDSN,1,23) ×× ' MOD CATLG;';
          CALL DYNAM(WORK, 'ALLOC ', DYNPARM,
                             'DD=SMFMON;',
                             'VBS;',
                             'LRECL=32000 BLKSIZE=4096;');
         CONS = 'EXISTING DATASET ' ×× SUBSTR(DSN,1,23)
                ×× ' USED ON VOL ' ×× VOLLIST(VOLCOUNT);
       END;
  PUT SKIP EDIT (CONS)(A);
  FILE_IND = 'N';
  ON ENDFILE (SMFOUT)      FILE_IND = 'Y';
  ON UNDEFINEDFILE(SMFOUT)  ERR_IND = 'Y';
  OPEN FILE(SMFOUT) INPUT, FILE(SMFMON) OUTPUT;
  IF ERR_IND = 'Y'
  THEN GO TO EMONTH;    /* CONTINUE PROCESSING*/
  READ FILE(SMFOUT) INTO(RECIN);  /* USE SAME I/O BUFFERS */
  DO WHILE (FILE_IND = 'N');
     IF FILE_IND = 'Y'
     THEN LEAVE;
     RECOUT = RECIN;
     WRITE FILE(SMFMON) FROM(RECOUT);
     READ FILE(SMFOUT) INTO(RECIN);
  END;
  CLOSE FILE(SMFOUT), FILE(SMFMON);
  DUMP_MONTH = 'Y';
  OPEN FILE(RESTART) OUTPUT;
  PUT FILE(RESTART) EDIT(RECAREA)(A(80)); /* UPDATE RESTART FILE*/
  CLOSE FILE(RESTART);
  EMONTH: IF ERR_IND = 'Y'
  THEN DO;
          CONS = 'JOB BLEW UP : MONTHLY DATASET NOT UPDATED '
          ×× '- BAD INPUT  :  ENTER ANY CHAR TO CONTINUE';
          DISPLAY (CONS) REPLY(TXT);
          GO TO ENDPRG2;
       END;
  /* ************************************************************** */
  /*                                                                */
  /*  DELETE AND RE-ALLOCATE SMFDATA.TEMP.CPUB AND                  */
  /*  SMFDATA.TEMP.CPUC FOR RE-USE.                                 */
  /*                                                                */
  /* ************************************************************** */
  DELTEMP: FNC = 'P';
  IF DUMP_DEL = 'Y'
  THEN DO;
           CONS = 'TEMP DATASETS HAVE ALREADY BEEN SCRATCHED AND '
                  ×× 'REALLOCATED';
           PUT SKIP EDIT (CONS)(A);
           RESTART_IND = 'Y';      /* SET RESTART INDICATOR */
           GO TO ENDPRG;;
       END;
  DSNAME = 'SMFDATA.TEMP.CPUB';
  CALL CATMAN(PARMA);
  DSNAME = 'SMFDATA.TEMP.CPUC';
  FNC = 'P';
  CALL CATMAN(PARMA);
  CONS = 'DATASET SMFDATA.TEMP.CPUB DELETED';
  PUT SKIP EDIT (CONS)(A);
  CONS = 'DATASET SMFDATA.TEMP.CPUC DELETED';
  PUT SKIP EDIT (CONS)(A);
  DSN = 'SMFDATA.TEMP.CPUB NEW CATLG;';
          CALL DYNAM(WORK, 'ALLOC ', DYNPARM,
                             'CYL PRIM=40 SEC=10;',
                             'VOL=SYSPG5;',
                             'VBS;',
                             'LRECL=32000 BLKSIZE=4096;');
  DSN = 'SMFDATA.TEMP.CPUC NEW CATLG;';
          CALL DYNAM(WORK, 'ALLOC ', DYNPARM,
                             'CYL PRIM=40 SEC=10;',
                             'VOL=SYSPG5;',
                             'VBS;',
                             'LRECL=32000 BLKSIZE=4096;');
  CONS = 'DATASET SMFDATA.TEMP.CPUB ALLOCATED';
  PUT SKIP EDIT (CONS)(A);
  CONS = 'DATASET SMFDATA.TEMP.CPUC ALLOCATED';
  PUT SKIP EDIT (CONS)(A);
  DUMP_DEL   = 'Y';
  OPEN FILE(RESTART) OUTPUT;
  PUT FILE(RESTART) EDIT(RECAREA)(A(80)); /* UPDATE RESTART FILE*/
  CLOSE FILE(RESTART);
  ENDPRG: DUMP_DAY = 'N';
  DUMP_WEEK = 'N';
  DUMP_MONTH = 'N';
  DUMP_DEL = 'N';
  OPEN FILE(RESTART) OUTPUT;
  PUT FILE(RESTART) EDIT(RECAREA)(A(80));
  CLOSE FILE(RESTART);
  ENDPRG2: IF RESTART_IND = 'Y'
  THEN DO;
          CALL PLIRETC(4);
       END;
  ELSE DO;
          CALL PLIRETC(0);
       END;

  IF ERR_IND = 'Y'
  THEN DO;
          CALL PLIRETC(16);
       END;
  END SMFPG2;
