         MACRO
&NAME    #XXC  &OP,&T,&F,&L,&SVID=,&PFIX=,&MF=INLINE
.*
.*
.*
.* LAST CHANGE DATE - OCTOBER 18, 1983
.*                  - MAILING ADDRESS CHANGE
.*
.* LAST CHANGE DATE - MARCH 8, 1982
.*                  - THE LENGTH VERIFICATION TEST ("#TEST SIZE=...")
.*                    HAS BEEN REMOVED. IT IS NOT REALLY NEEDED.
.*
.* LAST CHANGE DATE - DECEMBER 1, 1981
.*                  - "PFIX=(...,NOSAVE)" SUPPORT HAS BEEN ADDED. THIS
.*                    PROVIDES A MEANS OF BYPASSING THE ISSUENCE OF THE
.*                    #REGS MACRO. (SOMETIMES, THE #REGS MACRO THAT I
.*                    WOULD GET IS NOT THE ONE I WANT).
.*
.* LAST CHANGE DATE - JUNE 1, 1981
.*                  - BUG FIXED. NOW, IF MF=SUBROUTINE AND
.*                    OP=TRT, THEN R1 IS NOT RESTORED WHEN
.*                    THE SUBROUTINE COMPLETES.
.*
.* LAST CHANGE DATE - APRIL 21, 1981
.*                  - MACRO NAME CHANGED FROM $XXC TO #XXC.
.*
.* LAST CHANGE DATE - APRIL 20, 1981
.*                  - "#REGS GEN=NO" SUPPORT ADDED.
.*
.* LAST CHANGE DATE - DECEMBER 12, 1977
.*                  - SYNTAX BUG FIXED. A CONTINUATION CHARACTER WAS
.*                    NOT PLACE IN COLUMN 72.
.*
.* LAST CHANGE DATE - JANUARY 17, 1977
.*                  - FORM OF &MF= OPERAND REDESIGNED.
.*                  - DEFAULT MEANINGS OF &T AND &F AND (FOR
.*                    MF=SUBROUTINE) &L REMOVED.
.*                  - REGISTER FORM OF &SVID= SUPPORTED.
.*                  - COMMENTARY REWRITTEN.
.*                  - MAILING ADDRESS CHANGED.
.*
.* LAST CHANGE DATE - SEPTEMBER 27, 1976
.*                  - FIXED BUG: MISSING SEQUENCE SYMBOL - .TLR
.*                  - CHANGED LENGTH SIZE TEST TO BE GENERATED WHENEVER
.*                    &L(2) WAS GIVEN WITH THE NON-ROUTINE/SUBROUTINE
.*                    FORM OF THE MACRO CALL.
.*                  - IF THE CALL IS A KNOWN LENGTH FORM AND IF THE
.*                    LENGTH'S DERIVATIVE EXPRESSION IS GIVEN (&L(2))
.*                    THEN IT IS USED TO DERIVE THE LENGTH FIELD OF THE
.*                    LAST SS INSTRUCTION GENERATED.
.*
.* LAST CHANGE DATE - JUNE 6, 1975
.*
.* THIS MACRO WAS WRITTEN BY DAVID B. COLE. ANY QUESTIONS CONCERNING
.* IT MAY BE ADDRESSED TO:
.*       RR#2 BOX 712
.*       AFTON, VA. 22920
.*
.*
.*    THIS MACRO GENERATES ROUTINES TO PERFORM NON-DECIMAL
.* STORAGE-TO-STORAGE FUNCTIONS ON OPERANDS OF ARBITRARY LENGTH.
.* SUPPORTED "SS-FUNCTIONS" ARE:
.*       CLC      MVZ      TR
.*       MVC      NC       TRT
.*       MVN      OC       XC
.*
.*    THIS MACRO HAS TWO DIFFERENT MODES OF EXPANSION:
.*     - IF THE OPERAND LENGTHS ARE KNOWN AT ASSEMBLY TIME, THEN THE
.*       EXPANSION CAN CONSIST OF A SUFFICIENT NUMBER OF
.*       SS-INSTRUCTIONS TO ACCOMODATE THE GIVEN LENGTH. FOR EACH
.*       SUCCESSIVE SS-INSTRUCTION GENERATED, THE SINK OPERAND POINTER
.*       IS INCREMENTED BY 256. THE SOURCE OPERAND POINTER IS ALSO
.*       INCREMENTED BY 256 UNLESS THE OPERATOR IS EITHER "TR" OR
.*       "TRT". ADDITIONALLY FOR "CLC" AND "TRT", CONDITIONAL BRANCH
.*       INSTRUCTIONS ARE INSERTED IN THE EXPANSION SO THAT UPON THE
.*       FIRST OCCURANCE OF A NOT-EQUAL CONDITION THE REMAINING
.*       SS-INSTRUCTIONS ARE BYPASSED.
.*     - IF THE OPERAND LENGTHS CANNOT BE KNOWN UNTIL EXECUTION TIME,
.*       THEN THE EXPANSION IS A GENERALIZED SUBROUTINE CAPABLE OF
.*       PROCESSING ANY LENGTH.
.*
.* &NAME
.*       THIS OPERAND IS OPTIONAL. IF GIVEN, THEN, OF COURSE, IT LABELS
.*       THE GENERATED CODE.
.*
.* &MF=
.*       THIS OPERAND IS OPTIONAL. IF OMITTED, THEN MF=INLINE IS
.*       ASSUMED. &MF= CONTROLS THE OVERALL FORM OF THE MACRO
.*       EXPANSION. &MF= MAY BE GIVEN IN THE FOLLOWING FORMS:
.*       -OMITTED-
.*       MF=
.*       MF=INLINE
.*             THE SINK OPERAND LENGTH IS KNOWN AT ASSEMBLY TIME. THE
.*             MACRO EXPANDS INTO A SUFFICIENT REPETITION OF
.*             SS-INSTRUCTIONS TO PERFORM THE FUNCTION.
.*       MF=(SUBROUTINE, --- )
.*             THE SINK OPERAND LENGTH CANNOT BE KNOWN UNTIL ASSEMBLY
.*             TIME. THE MACRO EXPANDS INTO A GENERALIZED SUBROUTINE
.*             CAPABLE OF PERFORMING THE REQUIRED SS-FUNCTION ON
.*             OPERANDS OF ARBITRARY LENGTH.
.*       MF=SUBROUTINE
.*       MF=(SUBROUTINE,(14))
.*             WHEN THE SS-FUNCTION SUBROUTINE COMPLETES, A RETURN IS
.*             MADE TO THE ADDRESS POINTED TO BY REGISTER-14.
.*       MF=(SUBROUTINE,(-X-))
.*             -X- MUST BE AN ABSOLUTE EXPRESSION REPRESENTING THE NAME
.*             OF A REGISTER CONTAINING A RETURN ADDRESS.
.*       MF=(SUBROUTINE,-X-)
.*             -X- MUST BE AN ABSOLUTE OR RELOCATABLE EXPRESSION
.*             REPRESENTING A FIXED RETURN ADDRESS.
.*       MF=(SUBROUTINE,*)
.*             WHEN THE SS-FUNCTION SUBROUTINE COMPLETES, IT FALLS
.*             THROUGH TO CODE FOLLOWING THE MACRO EXPANSION.
.*
.* &OP
.*       THIS OPERAND IS REQUIRED. IT IDENTIFIES THE SS-FUNCTION TO BE
.*       PERFORMED. IF SHOULD BE EITHER:
.*          CLC      MVZ      TR
.*          MVC      NC       TRT
.*          MVN      OC       XC
.*       IF IT IS ANYTHING ELSE, THEN A SEVERITY-4 DIAGNOSTIC IS ISSUED
.*       BEFORE THE EXPANSION IS ATTEMPTED.
.*
.* &T
.*       THIS OPERAND IS REQUIRED. IT IDENTIFIES THE LOCATION OF THE
.*       SINK OPERAND. IT MAY BE EITHER AN ADDRESS, A REGISTER, OR A
.*       BASE/DISPLACEMENT COMBINATION AS FOLLOWS:
.*       -X- (ADDRESS FORM): -X- MAY BE EITHER AN ABSOLUTE OR
.*           RELOCATABLE EXPRESSION IDENTIFYING THE LOCATION OF THE
.*           SINK OPERAND.
.*       (-X-) (REGISTER FORM): -X- MUST BE AN ABSOLUTE EXPRESSION
.*             REPRESENTING THE NAME OF A REGISTER CONTAINING THE
.*             ADDRESS OF THE SINK OPERAND.
.*       (-X-,-Y-) (BASE/DISPLACEMENT FORM): -X- MUST BE AN ABSOLUTE
.*                 EXPRESSION REPRESENTING A DISPLACEMENT. -Y- MUST BE
.*                 AN ABSOLUTE EXPRESSION REPRESENTING A BASE (REGISTER
.*                 NAME). TOGETHER THE BASE AND DISPLACEMENT GIVE THE
.*                 ADDRESS OF THE SINK OPERAND.
.*
.* &F
.*       THIS OPERAND IS REQUIRED. IT IDENTIFIES THE LOCATION OF THE
.*       SOURCE OPERAND. IT MAY BE EITHER AN ADDRESS, A REGISTER, OR A
.*       BASE/DISPLACEMENT COMBINATION AS FOLLOWS:
.*       -X- (ADDRESS FORM): -X- MAY BE EITHER AN ABSOLUTE OR
.*           RELOCATABLE EXPRESSION IDENTIFYING THE LOCATION OF THE
.*           SOURCE OPERAND.
.*       (-X-) (REGISTER FORM): -X- MUST BE AN ABSOLUTE EXPRESSION
.*             REPRESENTING THE NAME OF A REGISTER CONTAINING THE
.*             ADDRESS OF THE SOURCE OPERAND.
.*       (-X-,-Y-) (BASE/DISPLACEMENT FORM): -X- MUST BE AN ABSOLUTE
.*                 EXPRESSION REPRESENTING A DISPLACEMENT. -Y- MUST BE
.*                 AN ABSOLUTE EXPRESSION REPRESENTING A BASE (REGISTER
.*                 NAME). TOGETHER THE BASE AND DISPLACEMENT GIVE THE
.*                 ADDRESS OF THE SOURCE OPERAND.
.*
.* &L
.*       THIS OPERAND RELATES TO THE LENGTH OF THE SINK (AND,
.*       THEREFORE, THE SOURCE) OPERAND. ITS PRECISE MEANING, HOWEVER,
.*       DIFFERS DEPENDING UPON THE VALUE OF THE &MF= OPERAND.
.*
.* &L    (MF ==> INLINE)
.*       HERE, &L IS AN OPTIONAL OPERAND REPRESENTING THE ACTUAL LENGTH
.*       OF THE SINK OPERAND. IT MAY BE GIVEN IN THE FOLLOWING FORMS:
.*       -OMITTED-: THE MACRO ATTEMPTS TO USE THE IMPLIED LENGTH OF THE
.*                  SINK OPERAND. IF THE IMPLIED LENGTH CAN BE KNOWN AT
.*                  MACRO PASS TIME, THEN IT IS USED TO CONTROL THE
.*                  NUMBER OF SS-INSTRUCTIONS GENERATED; OTHERWISE,
.*                  ONLY ONE SS-INSTRUCTION IS GENERATED.
.*       -X-: -X- MUST BE A SELF-DEFINING TERM (I.E. RESOLVABLE AT
.*            MACRO PASS TIME) REPRESENTING THE LENGTH OF THE SINK
.*            OPERAND. IT IS USED TO CONTROL THE NUMBER OF
.*            SS-INSTRUCTIONS GENERATED.
.*       (-X-,-Y-): -X- MUST BE AS ABOVE. -Y- MUST BE A ABSOLUTE
.*                  EXPRESSION (I.E. RESOLVABLE BY FINAL-PASS TIME)
.*                  ALSO REPRESENTING THE LENGTH OF THE SINK OPERAND.
.*                  IN OTHER WORDS, -X- AND -Y- MUST REPRESENT THE SAME
.*                  VALUE. THE DISTINCTION IS THAT -Y- CAN BE
.*                  RESPONSIVE TO SUCH THINGS AS LENGTH ATTRIBUTES AND
.*                  EQUATE VALUES WHEREAS -X- CANNOT. -Y- IS NOT USED
.*                  TO CONTROL THE MACRO EXPANSION. INSTEAD, IT IS USED
.*                  AS A VALIDITY CHECK ON -X-. WHEN -Y- IS GIVEN, A
.*                  STATEMENT OF THE FORM:
.*                        DC    0Y(X'7FFF'-(X-Y),X'7FFF'-(Y-X))
.*                  IS GENERATED. THIS STATEMENT DOES NOT CREATE ANY
.*                  OBJECT CODE, BUT IF -X- AND -Y- HAVE UNEQUAL
.*                  VALUES, THEN IT DOES GENERATE AN ASSEMBLY ERROR.
.*
.* &L    (&MF ==> SUBROUTINE)
.*       HERE, &L IS A REQUIRED OPERAND. IT REPRESENTS THE LOCATION OF
.*       THE LENGTH OF THE SINK OPERAND. IT MAY BE GIVEN IN THE
.*       FOLLOWING FORMS:
.*       -X- (ADDRESS FORM): -X- MUST BE EITHER AN ABSOLUTE OR
.*           RELOCATABLE EXPRESSION REPRESENTING THE ADDRESS OF A
.*           FULLWORD CONTAINING THE LENGTH OF THE SINK OPERAND.
.*       (-X-) (REGISTER FORM): -X- MUST BE AN ABSOLUTE EXPRESSION
.*             REPRESENTING THE NAME OF A REGISTER CONTAINING THE
.*             LENGTH OF THE SINK OPERAND.
.*
.* &SVID=
.*       THIS OPERAND IS OPTIONAL. IT IDENTIFIES THE LOCATION OF A
.*       4-WORD REGISTER SAVE AREA FOR USE BY THE SUBROUTINE FORM OF
.*       THE MACRO EXPANSION. (FOR THE INLINE FORM OF THE EXPANSION,
.*       THE &SVID= OPERAND IS IGNORED.) &SVID= MAY BE GIVEN IN THE
.*       FOLLOWING FORMS:
.*       -OMITTED-: A 4-WORD SAVE AREA IS INCLUDED IN THE EXPANSION
.*       SVID=-X- (ADDRESS FORM): -X- MUST BE EITHER AN ABSOLUTE OR
.*             RELOCATABLE EXPRESSION REPRESENTING THE ADDRESS OF A
.*             4-WORD SAVE AREA.
.*       SVID=(-X-) (REGISTER FORM): -X- MUST BE AN ABSOLUTE EXPRESSION
.*             REPRESENTING THE NAME OF A REGISTER CONTAINING THE
.*             ADDRESS OF A 4-WORD REGISTER SAVE AREA. WARNING, THE
.*             REGISTER CANNOT BE EITHER 14, 15, 0, OR 1.
.*
.* &PFIX=
.*       THE #XXC MACRO ATTEMPTS TO USE REGISTER EQUATES IN ITS
.*       EXPANSION WHEN REFERING TO REGISTERS. THIS IS SO THAT THE USE
.*       OF THE REGISTERS IS INDICATED IN THE ASSEMBLER'S CROSS
.*       REFERENCE LISTING. THE PFIX= OPERAND CAN BE USED TO CONTROL
.*       THE SET OF EQUATES USED. FOR EXAMPLE, IF "PFIX=GPR" IS GIVEN,
.*       THEN "GPR1" IS USED WHENEVER THE EXPANSION REFERS FO REGISTER
.*       1.
.*          IF THE PFIX= OPERAND IS OMITTED, THEN THE SET OF REGISTER
.*       EQUATES DEFINED BY THE NEXT PRIOR #REGS MACRO IS USED. IF
.*       THERE ARE NO PRIOR #REGS MACROS, THEN SELF-DEFINING NUMERICS
.*       ARE USED.
.*
.* &PFIX=(...,NOSAVE)
.*       THIS PREVENTS THIS MACRO FROM INVOKING THE #REGS MACRO.
.*
.*
.*
.*
.* INNER MACROS USED - #REGS #TEST
.*
         GBLA  &#TESERR
         GBLC  &#TESRET(20)
         LCLA  &TDI,&TRI,&TR
         LCLA  &FDI,&FRI,&FR
         LCLA  &A,&D1,&RE
         LCLB  &LOADR1
         LCLC  &TZ,&TC,&TLP,&TRP
         LCLC  &FZ,&FC,&FLP,&FRP
         LCLC  &#,&C,&CD1,&CD2,&N,&@,&SAVEA
&#       SETC  '&SYSNDX'
&N       SETC  '&NAME'
         AIF   ('&OP' EQ 'CLC' OR '&OP' EQ 'MVC' OR '&OP' EQ 'MVN' OR '*
               &OP' EQ 'MVZ' OR '&OP' EQ 'NC' OR '&OP' EQ 'OC' OR '&OP'*
                EQ 'TR' OR '&OP' EQ 'TRT' OR '&OP' EQ 'XC').OPCOK
         MNOTE 4,'WARNING - THE OPCODE IS "&OP".'
         MNOTE 4,'THIS EXPANSION WILL PROBABLY NOT BE USEFULL.'
.OPCOK   ANOP
&TDI     SETA  1
&TRI     SETA  2
         AIF   (N'&T GT 1).TREG
         AIF   ('&T' EQ '&T(1)').TDCODED
&TDI     SETA  2
&TRI     SETA  1
&TZ      SETC  '0'
.TREG    ANOP
&TC      SETC  ','
&TLP     SETC  '('
&TRP     SETC  ')'
.TDCODED ANOP
&FDI     SETA  1
&FRI     SETA  2
         AIF   (N'&F GT 1).FREG
         AIF   ('&F' EQ '&F(1)').FDCODED
&FDI     SETA  2
&FRI     SETA  1
&FZ      SETC  '0'
.FREG    ANOP
&FC      SETC  ','
&FLP     SETC  '('
&FRP     SETC  ')'
.FDCODED ANOP
         AIF   ('&MF(1)' EQ 'INLINE' OR '&MF(1)' EQ '').XXC
         AIF   ('&MF(1)' EQ 'SUBROUTINE').SUB
         MNOTE 8,'MF(1)=&MF(1) IS INVALID.'
         AGO   .MEND
.SUB     ANOP
.*
&@       SETC  '&PFIX(1)'
         AIF   ('&PFIX(2). '(1,1) EQ 'N').DONPFIX
         AIF   (K'&PFIX(1) NE 0).GOTPFIX
         #TEST PFIX=
&@       SETC  '&#TESRET(1)'
         AGO   .DONPFIX
.GOTPFIX #REGS &PFIX(1),GEN=NO
.DONPFIX ANOP
.*
&SAVEA   SETC  'X&#.SVA'
         AIF   ('&SVID(1)' EQ '').GOTSAVA
&SAVEA   SETC  '&SVID'
         AIF   ('&SVID(1)' EQ '&SVID').GOTSAVA
&SAVEA   SETC  '0(&SVID(1))'
.GOTSAVA AIF   ('&F(&FRI)' EQ '').GOTFR
         #TEST REGS=&F(&FRI)
         AIF   (&#TESERR NE 0).GOTFR
&FR      SETA  &#TESRET(1)
.GOTFR   ANOP
&N       STM   &@.14,&@.1,&SAVEA   SAVE WORK REGISTERS
         AIF   ('&TZ' EQ '').TLA
         #TEST REGS=&T(&TRI)
         AIF   (&#TESERR NE 0).TLR
&TR      SETA  &#TESRET(1)
         AIF   (&TR EQ 15).TDONE
.TLR     LR    &@.15,&T(&TRI)      LOAD SINK REGISTER
         AGO   .TDONE
.TLA     LA    &@.15,&T(&TDI)&TLP&TC&T(&TRI)&TRP LOAD SINK REGISTER
.TDONE   ANOP
&LOADR1  SETB  (('&OP' NE 'TR' AND '&OP' NE 'TRT') OR (&FR EQ 14 OR &FR*
                EQ 15))
         AIF   (NOT &LOADR1).FDONE
         AIF   ('&FZ' EQ '').FLA
         AIF   (&FR EQ 15).FLR15
         AIF   (&FR EQ 1).FDONE
.FLR     LR    &@.1,&F(&FRI)       LOAD SOURCE REGISTER
         AGO   .FDONE
.FLR15   AIF   (&TR EQ 15).FLR
         L     &@.1,&SAVEA+4       LOAD SOURCE REGISTER
         AGO   .FDONE
.FLA     AIF   (&FR EQ 15).FL15
&FR      SETA  0
.FLAA    LA    &@.1,&F(&FDI)&FLP&FC&F(&FRI)&FRP LOAD SOURCE REGISTER
         AGO   .FDONE
.FL15    AIF   (&TR EQ 15).FLAA
         L     &@.1,&SAVEA+4       LOAD -
         LA    &@.1,&F(&FDI)(,&@.1) SOURCE REGISTER
.FDONE   AIF   ('&L' EQ '&L(1)').LL
         #TEST REGS=&L(1)
         AIF   (&#TESERR NE 0).LLTR
&A       SETA  4
&D1      SETA  &TR
         AIF   (&#TESRET(1) EQ 15).LLSVA
         AIF   (&#TESRET(1) NE 1).LLTR
&A       SETA  12
&D1      SETA  &FR
.LLSVA   AIF   (&#TESRET(1) EQ &D1).LLTR
         L     &@.0,&SAVEA+&A      LOAD LENGTH REGISTER
         AGO   .LLTR0
.LLTR    LTR   &@.0,&L(1)          LOAD LENGTH REGISTER; > 0?
         AGO   .LDONE
.LL      L     &@.0,&L             LOAD LENGTH REGISTER
.LLTR0   LTR   &@.0,&@.0           LENGTH > 0?
.LDONE   BNP   X&#.RET             NO, EXIT
         LA    &@.14,256           YES, GET MAX SINGLE EXECUTE LENGTH
X&#.LP   CR    &@.14,&@.0          LENGTH NEARLY EXHAUSTED YET?
         BNH   X&#.EX              NO, GO EXECUTE MAX LENGTH
         LR    &@.14,&@.0          YES, GET LAST EXECUTE LENGTH
X&#.EX   BCTR  &@.14,0             CONVERT LENGTH TO MACHINE LENGTH
         EX    &@.14,X&#.XXC       EXECUTE THE FUNCTION
         AIF   ('&OP' NE 'TRT' AND '&OP' NE 'CLC').TSTSKIP
         BNE   X&#.RET             INEQUALITY; GO RETURN TO CALLER
.TSTSKIP LA    &@.14,1(,&@.14)     RESTORE ORIGINAL LENGTH
         AR    &@.15,&@.14         ADVANCE SINK REGISTER
         AIF   ('&OP' EQ 'TRT' OR '&OP' EQ 'TR').NOINCR
         AR    &@.1,&@.14          ADVANCE SOURCE REGISTER
.NOINCR  SR    &@.0,&@.14          DECRIMENT THE LENGTH; DONE YET?
         BP    X&#.LP              NO, KEEP LOOPING
         AIF   ('&OP' NE 'TRT' OR NOT &LOADR1).NOTTRTX
         L     &@.1,&SAVEA+12      YES, TRT MISSED; INSURE R1 RESTORED
.NOTTRTX ANOP
&RE      SETA  1
         AIF   ('&OP' NE 'TRT').GOTRE
&RE      SETA  0
.GOTRE   ANOP
X&#.RET  LM    &@.14,&@&RE,&SAVEA  RESTORE REGISTERS
         AIF   ('&MF(2)' EQ '').BR14
         AIF   ('&MF(2)' EQ '*').BEND
         AIF   ('&MF(2)'(1,1) EQ '(').BREG
         B     &MF(2)              EXIT
         AGO   .DATA
.BR14    BR    &@.14               RETURN
         AGO   .DATA
.BEND    B     X&#.END             EXIT
         AGO   .DATA
.BREG    #TEST DCODE=&MF(2)
         BR    &#TESRET(2)         RETURN
.DATA    AIF   ('&SVID(1)' NE '').NOSAVEA
X&#.SVA  DS    4A                  REGISTER SAVE AREA
.NOSAVEA AIF   (NOT &LOADR1).TRTRTO
X&#.XXC  &OP   0(*-*,&@.15),0(&@.1) (EXECUTED)
         AGO   .ENDTST
.TRTRTO  ANOP
X&#.XXC  &OP   0(*-*,&@.15),&FZ&F(&FDI)&FLP&F(&FRI)&FRP (EXECUTED)
.ENDTST  AIF   ('&MF(2)' NE '*').MEND
X&#.END  DS    0H
         AGO   .MEND
.XXC     ANOP
&C       SETC  T'&L(1)
         AIF   ('&C' NE 'O').GOTLEN
&C       SETC  T'&T(&TDI)
         AIF   ('&C' EQ 'M' OR '&C' EQ 'N' OR '&C' EQ 'O' OR '&C' EQ 'T*
               ' OR '&C' EQ 'U' OR '&C' EQ 'W' OR '&C' EQ '$').NOLNGTH
&A       SETA  L'&T(&TDI)
         AIF   (&A GT 256).LONGMVC
.NOLNGTH ANOP
&N       &OP   &TZ&T(&TDI)&TLP&TC&T(&TRI)&TRP,&FZ&F(&FDI)&FLP&F(&FRI)&F*
               RP
         AGO   .MEND
.GOTLEN  AIF   ('&C' NE 'N').SHORTMV
&A       SETA  &L(1)
         AIF   (&A GT 256).LONGMVC
.SHORTMV ANOP
&A       SETA  1
         AIF   (K'&L(2) EQ 0).SHORT2
&A       SETA  2
.SHORT2  ANOP
&N       &OP   &TZ&T(&TDI)(&L(&A)&TC&T(&TRI)),&FZ&F(&FDI)&FLP&F(&FRI)&F*
               RP
         AGO   .MEND
.LONGMVC ANOP
&N       &OP   &TZ&T(&TDI)&CD1.(256&TC&T(&TRI)),&FZ&F(&FDI)&CD2&FLP&F(&*
               FRI)&FRP
&N       SETC  ''
         AIF   ('&OP' NE 'TRT' AND '&OP' NE 'CLC').NOTEST
         BNE   X&#.END
.NOTEST  ANOP
&A       SETA  &A-256
&D1      SETA  &D1+256
&CD1     SETC  '+'.'&D1'
         AIF   ('&OP' EQ 'TR' OR '&OP' EQ 'TRT').TROP
&CD2     SETC  '&CD1'
.TROP    AIF   (&A GT 256).LONGMVC
         AIF   (K'&L(2) EQ 0).LAST2
         &OP   &TZ&T(&TDI)&CD1.(&L(2)-&D1&TC&T(&TRI)),&FZ&F(&FDI)&CD2&F*
               LP&F(&FRI)&FRP
         AGO   .LAST1
.LAST2   &OP   &TZ&T(&TDI)&CD1.(&A&TC&T(&TRI)),&FZ&F(&FDI)&CD2&FLP&F(&F*
               RI)&FRP
.LAST1   AIF   ('&OP' NE 'CLC' AND '&OP' NE 'TRT').MEND
X&#.END  DS    0H
.MEND    MEND
