         &STLIMIT = 16000000
         TRACE('TRACEMOV','V',,'MOVTRC')
         &INPUT = 1
         &TRACE = 50
         KHVTRC = 50
         &TRIM = 1
         &DUMP = 2
-TITL                        CHECKERS PROGRAM BY S.P. SHAPLAND
-SPACE 4
*                  THIS IS A CHECKERS PROGRAM WRITTEN BY S.P. SHAPLAND
*        FOR INFE375 FALL '74.
*                  HEAVY RELIANCE HAS BEEN PLACED UPON THE CHECKERS
*        PROGRAM WRITTEN BY A.L. SAMUEL IN THE 1950'S, AS DESCRIBED
*        IN THE ARTICLE, 'SOME STUDIES IN MACHINE LEARNING USING
*        A GAME OF CHECKERS", BY A.L. SAMUEL.  THIS ARTICLE APPEARED
*        IN THE IBM JOURNAL OF RESEARCH AND DEVELOPMENT, 1959, AND
*        WAS REPRINTED IN:
*                  COMPUTERS AND THOUGHT
*                  E.A. FEIGENBAUM & J. FELDMAN
*                  MC GRAW HILL BOOK CO.,NEW YORK,NEW YORK, 1963
*
*                  THE PRIMARY MATERIAL TAKEN FROM THIS SOURCE
*        HAS BEEN THE TECHNIQUE FOR NUMBERING THE BOARD, AND
*        SOME HUERISTIC EVALUATION PARAMETERS.
*
*                  THE PROGRAM HAS THE FOLLOWING PRIMARY ROUTINES:
*        GENMOV    FOR GENERATING MOVES
*        JMPGEN    FOR GENERATING JUMPS OR SEQUENCES OF JUMPS
*        MAKMOV    FOR MAKING MOVES
*        RSTRMOV   FOR RESTORING MOVES
*        HUEREVAL  FOR EVALUATING TIP NODES OF THE MOVE-TREE
*        MINMAX    FOR MAKING THE FINAL SELECTION AT THE FIRST LEVEL
*        DATAMOV   FOR OBTAINING AND MAKING THE USER'S MOVES
*        INITDATA  FOR INITIALIZING THE BOARD AND ASSOCIATED
*                  PARAMETERS
*        RESET     FOR RESETING PARAMETERS BETWEEN MOVES AND
*                  GARBAGE COLLECTION
*
*                  THE FOLLOWING ROUTINES ARE OF A UTILITY NATURE:
*        DISPLAY   FOR DISPLAYING THE CURRENT BOARD STATE
*        RECAPENT  FOR ENTERING A MOVE INTO THE RECAP LISTING
*        RECAPPNT  FOR PRINTING THE RECAP LISTING
*        CNVTSTD   FOR CONVERTING SAMUEL'S NOTATION TO STANDARD NOTATION
*        CNVTSAM   FOR CONVERTING STANDARD NOTATION TO SAMUEL'S NOTATION
*        TABGEN    FOR GENERATING THE NOTATION CONVERSION TABLES
*
*                  THE FOLLOWING I/O ASSOCIATIONS HAVE BEEN MADE
*        INMOV     FI(MOVIN) FOR INPUTING USER'S MOVES
*        INDAT     FI(DATIN) FOR INPUTING INITIAL BOARD STATES
*        OUTPUT    FI(TERM1) FOR SEPERATING COMPILER AND GAME OUTPUT
*        OUTNSK    FI(TERM1) FOR 'NO SKIP' OUTPUT
*        OUTRC     FI(TRCOUT) FOR OUTPUT OF PROGRAMMER DEFINED TRACE
*
*                  THE FOLLOWING DEFINED DATA-TYPES ARE USED:
*        MOVLST    FOR THE GAME TREE
*        JMPLST    FOR JUMP TREES. CONNECTED TO THE GAME TREE THRU
*                  MOVLST
*        RCPLST    FOR THE RECAP LISTING
-STITL             PROGRAMER DEFINED DATA TYPES
         TENSP = DUPL(' ',10)
         DATA('JMPLST(JNAME,LINK,FMPOS,TOPOS,OPNCPT,OPNAPT)')
-SPACE
*        THIS DATA TYPE FORMS A LINKED LIST OF THE JUMPS
*   THAT MAY BE MADE FOR THIS MOVE.
*   JNAME => THE NAME OF THE ELEMENT
*   LINK => THE NAME OF THE HIGHER ELEMENT OF THE LIST
*   FMPOS => THE POSITION ON THE BOARD FROM WHICH THE JUMP
*        IS TO BE MADE.
*   TOPOS => THE POSITION TO WHICH THE JUMP IS TO BE MADE.
*   OPNCPT => THE POSITION OF THE OPPONENT JUMPED.
*     OPNAPT => THE INDEX OF THE CAPTURED MAN.
-SPACE 3
         DATA('MOVLST(MNAME,UPT,LPT,RPT,DPT,FMLOC,TOLOC,HVAL,LVL,JPT,'
+   'FBD,APNT)')
-SPACE
*        THIS DATA TYPE IS FOR THE LINKED LIST OF POSSIBLE
*   MOVES.
*   MNAME => THE NAME OF THE ELEMENT.
*   UPT => THE NAME OF THE PARENT MOVE'S ELEMENT.
*   LPT => THE NAME OF THE SIBLING TO THE LEFT IN THE CURRENT LEVEL.
*   RPT => THE NAME OF THE SIBLING TO THE RIGHT IN THE LIST.
*   DPT => THE NAME IF THE FIRST CHILD OF THIS MOVE.
*   FMLOC => THE BOARD POSITION FROM WHICH THE MOVE IS MADE.
*   TOLOC => THE POSITION TO WHICH THE PIECE IS TO BE MOVED.
*   HVAL => THE HEURISTIC VALUE OF THIS MOVE.
*   LVL => THE LEVEL OF THE TREE TO WHICH THIS MOVE BELONGS.
*   JPT => THE NAME OF THE LAST ELEMENT IN THE JUMPLIST RELEVANT
*        TO THIS MOVE.
*   FBD => THE BOARD CONDITION AFTER THIS MOVE HAS BEEN MADE.
*   APNT => THE NAME OF THE VALUE WHICH CONTAINS THE PIECE MOVED.
-SPACE 2
         DATA('RCPLST(RCPLNK,MVCNTR,BFM,BTO,WFM,WTO)')
*
*        THIS LINKED LIST WILL BE USED TO MAINTAIN A
*        RECAP LISTING OF THE MOVES OF THE GAME.
*        THIS LIST IS LINKED FORWARD FROM THE BEGINNING OF THE GAME.
*        NEW ELEMENTS MAY BE ADDED USING <RECAPENT>.  THE LIST MAY BE
*        PRINTED USING <RECAPPNT>.  THE LIST WILL BE PRINTED
*        AT THE END OF EACH GAME.
*        FIELDS ARE:
*                  RCPLNK => A PNTR TO THE PREVIOUS PAIR OF MOVES.
*                  MVCNTR => THE NUMBER OF THE MOVE PAIR IN THE GAME.
*                  BFM & BTO => THE POSITIONS OF BLACK'S MOVE.
*                  WFM & WTO => THE POSITIONS OF WHITE'S MOVE.
-SPACE 3
         INPUT('INMOV','MOVIN',72)
*        THIS INPUT FUNCTION WILL BE USED TO OBTAIN
*        THE PLAYER'S MOVES FROM THE INPUT FILE <DATIN>.
-SPACE 2
         INPUT('INDAT','MOVIN',72)
*        THIS INPUT FUNCTION WILL BE USED TO OBTAIN INITIAL
*        CONDITIONS FOR THE GAME FROM THE INPUT FILE <DATIN>.
-SPACE 2
         OUTPUT('OUTPUT','TERM1',' ')
*     THIS OUTPUT ASSOCIATION IS USED TO SEPERATE PGM OUTPUT
*   FROM COMPILER OUTPUT.
-SPACE 3
-STITL THE FUNCTION <MAKMOV>
DMAKMOV DEFINE('MAKMOV(PNT,PLR,OPN,LKGSW,PRNTCNTL)FML,TOL,PJL,'
+             'CPT,PRTCPT,KCPT')     :(DRSTMOV)
-SPACE
*        THIS FUNCTION MAKES THE MOVE SPECIFIED.
*   ARGUMENTS ARE:
*   PNT => THE  ELEMENT WITHIN MOVLST WHICH IS
*        IS TO BE MADE.
*   PLR => THE NAME OF THE PLAYER MAKING THE MOVE.
*   OPN => THE NAME IF HIS OPPONENT.
*    LKGSW => NAME OF KING SWITCH TO BE SET = 1, IF MAN IS CROWNED.
*    PRNTCNTL => PRINT CONTROL, OUTPUT AND RECAP ENTRY MADE IF NON-NULL.
-SPACE
*   LOCAL VARIABLES ARE:
*   FML => THE LOCATION FROM WHICH THE PIECE IS TO BE MOVED.
*   TOL => THE LOCATION TO WHICH THE PIECE IS MOVED.
*   PJL => THE  JUMP-LIST WHICH APPLIES.
*   CPT => THE POSITION OF CAPTURED MAN.
*    KCPT => 'POS' INDEX OF CAPTURED MAN. WILL BE STORED IN OPNAPT(PJL)
*    PRTCPT => STRING OF LOCATIONS OF CAPTURED MEN.
-SPACE 3
MAKMOV   FML = FMLOC(PNT)
         TOL = TOLOC(PNT)
*    MOVE THE PLAYER6S MAN FROM FMLOC(PNT) TO TOLOC(PNT)
         $(BOARD TOL) = $(BOARD FML)
         $(BOARD FML) = ' '
         $(PLR 'POS' APNT(PNT)) = TOL
         PJL = JPT(PNT)
         DIFFER($(PLR 'KNG' APNT(PNT)))  :S(RMVCPT)
CHKKNG   (' ' TOL) $(OPN 'HOM')   :F(RMVCPT)
*    CROWN THE PLAYER'S MAN IF IT HAS REACHED KING'S ROW.
         $(PLR 'KNG' APNT(PNT)) = 1
         $(BOARD TOL) = $(BOARD TOL) 'K'
         $LKGSW = 1
RMVCPT   DIFFER(PJL)  :F(PRNTMOV)
*    REMOVE ANY CAPTURED PIECES
         CPT = OPNCPT(PJL)
         K =
RMVINC   K = LT(K,12) K + 1    :F(CPTNFND)
         $(OPN 'POS' K) = EQ($(OPN 'POS' K),CPT)     :F(RMVINC)
         OPNAPT(PJL) = K
         $(BOARD CPT) = ' '
         PRTCPT = CNVTSTD(CPT) ' ' PRTCPT
         PJL = LINK(PJL)   :(RMVCPT)
PRNTMOV  IDENT(PRNTCNTL)     :S(RETURN)
*    MAKE RECAP ENTRY AND PRINT MOVE IF PRNTCNTL IS NON-NULL.
         RECAPENT(PLR,FML,TOL)
         OUTPUT = TENSP '>>>> ' PLR "'S MOVE IS FROM:"
+    CNVTSTD(FML) ' TO: ' CNVTSTD(TOL) '    PNTR: ' MNAME(PNT)
         OUTPUT = DIFFER(CPT) DUPL(' ',15) 'CAPTURES MADE: '
+    PRTCPT
         OUTPUT = DIFFER($LKGSW) DUPL(' ',15) 'MAN HAS BEEN CROWNED.'
         :(RETURN)
CPTNFND  OUTPUT = TENSP '***  CAPTURED MAN AT ' CPT ' CANNOT BE FOUND.'
+        :(FRETURN)
-STITL   THE FUNCTION <RSTRMOV>
DRSTMOV  DEFINE('RSTRMOV(PNT,PLR,OPN,LKGSW,PRNTCNTL)FML,TOL,PJL,'
+             'CPT,KCPT,PRTRPL')     :(DGENMV)
*             THIS FUNCTION IS USED TO RESTORE A MOVE, ONCE
*        IT HAS BEEN MADE.  ARGUMENTS AND LOCAL VARIABLES ARE
*        THE SAME AS FOR <MAKMOV>.
RSTRMOV  FML = FMLOC(PNT)
         TOL = TOLOC(PNT)
*    MOVE PLAYER'S MAN FROM TOLOC(PNT) TO FMLOC(PNT)
         $(BOARD FML) = $(BOARD TOL)
         $(BOARD TOL) = ' '
         $(PLR 'POS' APNT(PNT)) = FML
         PJL = JPT(PNT)
         DIFFER($LKGSW)     :F(RSTMOV1)
*    RESET CROWNING OF MAN IF LKGSW IS NON-NULL
         $(PLR 'KNG' APNT(PNT)) =
         $(BOARD FML) 'K' =
         $LKGSW =
RSTMOV1  DIFFER(PJL)     :F(RSTMOV2)
*    REPLACE ANY CAPTURED MEN
         CPT = OPNCPT(PJL)
         KCPT = OPNAPT(PJL)
         $(BOARD CPT) = $(OPN 'MAN')
         $(BOARD CPT) = DIFFER($(OPN 'KNG' KCPT)) $(BOARD CPT) 'K'
         $(OPN 'POS' KCPT) = CPT
         PRTRPL = CNVTSTD(CPT) ' ' PRTRPL
         PJL = LINK(PJL)     :(RSTMOV1)
RSTMOV2  IDENT(PRNTCNTL)     :S(RETURN)
*    PRINT RESTORATION OF MOVE.
         OUTPUT = TENSP '<<<<< ' PLR "'S MOVE FROM:"
+           CNVTSTD(FML) ' TO: ' CNVTSTD(TOL) ' HAS BEEN REMOVED.'
         OUTPUT = DIFFER(CPT) DUPL(' ',16) 'CAPTURES RESTORED: '
+             PRTRPL
         OUTPUT = DIFFER($LKGSW) DUPL(' ',16) 'MAN IS NO LONGER A KING.'
         :(RETURN)
-STITL THE FUNCTION <GENMOV>
DGENMV  DEFINE('GENMOV(PLR,OPN,LVL,PARPT,GNLY)I,J,KPT,JSW,BSTMOV,'
+   'CUTSW,ABCUT,KNMV,KMSQN,KNGSW,BOTTOM,PRNTCNTL') :(DJMPGEN)
-SPACE
*        THIS FUNCTION MAY BE USED RECURSIVELY TO GENERATE THE
*   LEGAL MOVES THAT MAY BE MADE AT THE CURRENT STATE OF GAME.
*   ARGUMENTS ARE:
*   PLR => THE CURRENT PLAYER.
*   OPN => THE PLAYER'S OPPONENT.
*   LVL => THE CURRENT LEVEL WITHIN THE GAME TREE.
*   PARPNT => THE POINTER TO THE MOVE WHICH IS THE LOGICAL PARENT
*        OF THIS MOVE.
*   GNLY =>  IF NOT NULL, THEN MOVES WILL BE GENERATED ONLY, AND NO
*            EVALUATION OR RECURSION WILL OCCUR.
*   LOCAL VARIABLES ARE:
*   I => A COUNTER USED TO SELECT THE PIECE TO BE ATTEMPT TO MOVE.
*   J => A COUNTER USED FOR SELECTION THE DIRECTION OF THE MOVE.
*   KPT => THE GENERATED MOVE TO BE EXPANDED NEXT.
*   JSW => A SWITCH INDICATING THE PRESENCE OF LEGAL JUMPS.
*   KNMV => A TEMP STG FOR THE NUMBER OF MOVES.
*   KMSQN => A TEMP STG FOR THE CURRENT MOVE POINTER.
*    BSTMOV => POINTER TO THE BEST MOVE AVALIBLE FROM MINMAX
*    CUTSW => SWITCH INDICATING THAT THE CURRENT LEVEL HAS BEEN
*        CUT OFF BY ALPHA-BETA PROCEEDURE.
*    ABCUT => THE DIRECTION(.GT. OR .LT.) OF THE ALPHA-BETA CUT-OFF
*    KNGSW => KING SWITCH TO INDICATE IF THE LAST MOVE CROWNED A MAN
*    BOTTOM => SWITCH TO INDICATE THAT THE BOTTOM OF THE DESIRED TREE
*        HAS BEEN REACHED.  TIP NODES WILL BE EVALUATED WITH HUEREVAL.
*    PRNTCNTL => PRINT CONTROL FOR MAKMOV AND RSTRMOV.
*
*    GLOBAL VARIABLES AFFECTED:
*    MSQN => POINTER TO THE CURRENT MOVE
*    NMV => THE NUMBER OF VALID MOVES IN THIS GENERATION
*    LVLIMT => THE DEEPEST LEVEL OF THE TREE WHICH MAY BE SEARCHED,
*        UNLESS THE LAST MOVE WAS A JUMP
*    CALLVL =>  THE TOTAL NUMBER OF VALID MOVES WHICH HAVE BEEN FOUND
*    BOTLVL => STORES THE LEVEL OF THE DEEPEST LEVEL OF THE TREE
*    SLPNT => POINTER TO THE PREVIOUS MOVE IN THIS GENERATION FOUND.
*    FSTBOT => THE NUMBER OF TIMES THAT THE TREE HAS BEEN TO THE BOTTOM.
*
*        THE ROUTINE GENERATES ALL VALID MOVES IN THE CURRENT
*    GENERATION, AND THEN PROCEEDS FROM R TO L THRU THE GENERATION,
*    EXPANDING EACH NODE RECURSIVELY.  AFTER EACH NODE HAS BEEN
*    EXPANDED, ALPHA-BETA CUT-OFF IS CHECKED.  IF CUT IS DESIRED,
*    CONTROL IS RETURNED TO THE PREVIOUS GENERATION.
-SPACE 3
GENMOV   LVL = LVL + 1
         NCALL = NCALL + 1
         LVLIMT = GE(LVLIMT,CALLVL)  MAXLVL - CALLVL
         LVLIMT = LT(LVLIMT,MINLVL) MINLVL
         BOTLVL = GT(LVL,BOTLVL) LVL
         NMV =
         ABCUT = 'LT'
         ABCUT = IDENT(FRIEND,PLR) 'GT'
NLOUT    SLPNT =
*    GENERATE ALL VALID MOVES FOR THIS GENERATION
INCI     I = LT(I,12) I + 1     :F(RECUR)
         PIECE = $(PLR 'POS' I)
         DIFFER(PIECE)   :F(INCI)
         NDIR = 2 + $(PLR 'KNG' I) * 2
         J =
INCJ    J = LT(J,NDIR) J + 1   :F(INCI)
         TMV = PIECE + $(PLR 'DIR' J)
         DIFFER($(BOARD TMV)) :F(INCJ)
         $(BOARD TMV) $(PLR 'CHR')    :S(INCJ)
         $(BOARD TMV) $(OPN 'CHR')     :S(JMP)
         DIFFER(JSW)   :S(INCJ)
*    IF NO JUMPS HAVE BEEN FOUND, LINK THE MOVE TO THE TREE
         NMV = NMV + 1
         MSQN = 'MOV' LVL '.' NCALL '.' NMV
*OUTMOV  OUTPUT = '     MOVE MAY BE MADE FM: ' PIECE ' TO: '
*+     TMV  '  ×  '  MSQN
         MSQN = MOVLST(MSQN,PARPT,SLPNT,,,PIECE,TMV,HVAL(PARPT),
+     LVL,,,I)
         DIFFER(SLPNT)   :F(SARPT)
         RPT(SLPNT) = MSQN
SARPT    SLPNT =  MSQN
         DIFFER(PARPT)     :F(INCJ)
         DPT(PARPT) = MSQN     :(INCJ)
JMP      JMPNT =
         JSW = JMPGEN(PLR,OPN,PIECE,TMV,PARPT)     :(INCJ)
*
*        THIS COMPLETES GENERATION AT THIS LEVEL.
*
RECUR    DIFFER(NMV)   :F(GENLOS)
*    IF NO MOVES CAN BE MADE, INDICATES WIN FOR OPN
         DIFFER(GNLY)     :S(RETURN)
*    IF GENERATION ONLY(GNLY NON-NULL) RETURN
         CALLVL = CALLVL + NMV
         DIFFER(JSW)     :S(RECUR1)
*    IF JUMP WAS TO BE MADE, DO NOT TERMINATE AT THIS DEPTH
         BOTTOM = GE(LVL,LVLIMT) 1
RECUR1   BSTMOV = EQ((NMV * LVL),1) MSQN     :S(PLRMKMOV)
*    IF ONLY ONE MOVE IS AVALIBLE AT THE FIRST LEVEL,  MAKE IT
*        WITH OUT GENERATING OR SEARCHING THE TREE.
         KPT = MSQN
*    STORE THOSE GLOBAL VARIABLES WHICH ARE NEEDED LOCALLY
         KNMV = NMV
         KMSQN = MSQN
         FSTBOT = FSTBOT + BOTTOM
RECUR2   DIFFER(KPT)   :F(CHKLVL)
         HVAL(KPT) = HVAL(PARPT)
         MAKMOV(KPT,PLR,OPN,'KNGSW')
*    MAKE THE SPECIFIED MOVE
         HVAL(KPT) = DIFFER(BOTTOM) HUEREVAL(KPT,OPN)     :S(RECUR3)
*        THE OPPONENT IS TO MOVE NEXT
*    EVALUATE IF AT THE BOTTOM
         GENMOV(OPN,PLR,LVL,KPT)   :S(RECUR3)
*    GENERATE THE NEXT LEVEL(RECUREIVELY).  IF THIS FAILS,
*        INDICATE A WIN FOR PLAYER.
         HVAL(KPT) = 99999999
         HVAL(KPT) = IDENT(PLR,'WHT') -99999999
         HVAL(KPT) = DIFFER(FRIEND,'BLK') -HVAL(KPT)
RECUR3   RSTRMOV(KPT,PLR,OPN,'KNGSW')
*    RESTORE THE BOARD TO THE STATE PRIOR TO THE LAST MOVE
         DPT(KPT) =
         EQ(LVL,1)     :S(RECUR4)
         DIFFER(CUTSW)     :S(RECUR4)
*    CHECK FOR ALPH-BETA CUT-OFF
         HVAL(PARPT) = IDENT(HVAL(PARPT)) HVAL(KPT)     :S(RECUR4)
         HVAL(PARPT) = APPLY(ABCUT,HVAL(KPT),HVAL(PARPT)) HVAL(KPT)
+             :S(RECUR4)
CUT      GT(FSTBOT,1)     :F(RECUR4)
         HVAL(PARPT) = HVAL(KPT)
         GT(KHVTRC,0)     :F(CHKLVL)
         OUTRC = TENSP
         OUTRC = TENSP '     +++++     CUT(' ABCUT ')     +++++'
         OUTRC = TENSP
             :(CHKLVL)
RECUR4   TRACEMOV = KPT
         KPT = LPT(KPT)     :(RECUR2)
*    CHECK THE REST OF THE GENERATION
CHKLVL   NMV = KNMV
         MSQN = KMSQN
         EQ(LVL,1)     :  F(RETURN)
         MINMAX(PLR,PARPT,'BSTMOV')
*    SELECT THE BEST MOVE TO MAKE W/MINMAX IF AT THE TOP OF THE TREE
*        THEN MAKE THE MOVE AND RETURN
PLRMKMOV OUTRC = TENSP TENSP 'BOTTOM => ' BOTLVL
         PRNTCNTL = 1
         MAKMOV(BSTMOV,PLR,OPN,'KNGSW',PRNTCNTL) :F(FRETURN) S(RETURN)
GENLOS   EQ(LVL,1)     :F(FRETURN)
         DIFFER(GNLY)     :S(FRETURN)
         OUTPUT = TENSP 'I HAVE NO LEGAL MOVES!'
         OUTPUT = TENSP OPN ' WINS !!!!!'     :(FRETURN)
-STITL THE JUMP CHECKING/GENERATION FUNCTION <JMPGEN>
DJMPGEN  DEFINE('JMPGEN(PLR,OPN,PIECE,TMV,PARPNT,JMPNT)JMV,'
+              'LJMV,KMV,CCH,KPC,PCH,LJMP,JSW2,JSW3')     :(DMNMX)
*
*             THIS FUNCTION IS USED TO GENERATE JUMP MOVES.  IT MAY
*        BE USED RECURSIVELY TO GENERATE A CHAIN OF JUMPS.
*        A JUMP IS ADDED TO THE MOVE-LIST ONLY IF;
*   1)  THE JUMP HAS BEEN SUCCESSFUL. AND
*   2)  ALL FURTHER JUMPS FROM THIS POINT FAIL.
*             ARGUMENTS ARE:
*        PLR =>  THE PLAYER MAKING THE MOVE.
*        OPN =>  PLAYER'S OPPONENT.
*        PIECE =>  THE LOCATION OF THE MAN TO BE MOVED.
*        TMV =>  THE LOCATION OF THE MAN TO BE CAPTURED.
*        PARPNT =>  LINK TO THE PARENT OF THIS MOVE.
*        JMPNT =>  LINK TO PREVIOUS JUMPS IN A CHAIN.
*                  SHOULD BE NULL FOR INITIAL CALL FROM GENMOV.
*                 IT WILL BECOME THE CURRENT JMPLST.
*
*             LOCAL VARIABLES ARE:
*        JMV =>  THE LOCATION JUMPED TO.
*        LJMV => LOOP COUNTER FOR NEXT MOVE.
*        KMV =>  TEMP STG FOR THE LOCATION OF THE CAPTURED MAN.
*        CCH =>  TEMP STG FOR THE CAPTURED MAN.
*        KPC =>  TEMP STG FOR THE MOVED MAN'S LOCATION.
*        PCH =>  TEMP STG FOR THE MOVED MAN.
*        LJMP =>  LINK TO THE PREVIOUS JUMP IN A CHAIN.
*        JSW2 =>  SUCCEED SWITCH.  NULL ONLY IF NO FURTHER JUMPS
*                  IN THE CHAIN.
*        JSW3 => TRANSFER FOR SUCCEED SWITCH.
*
*             GLOBAL VARIABLES USED:
*        NJMP =>  USED TO DEVELOPE UNIQUE JUMP POINTERS.
*        JSW =>  JUMP SWITCH.  NMV IS RESET IF NULL, IE. ON THE
*                FIRST JUMP FOUND AT A CURRENT LEVEL.
*        NDIR =>  NO. OF POSSIBLE DIRECTIONS THAT THE MAN MAY MOVE.
*        NMV =>  USED TO DEVELOP UNIQUE MOVE POINTERS.
*        SLPNT =>  POINTER TO PRECEEDING MOVE AT CURRENT LEVEL.
*        MSQN =>  MOVE POINTER.
*        NCALL =>  THE NO. OF GENMOV CALLS.
*        LVL =>  THE LEVEL AT WHICH JMPGEN WAS CALLED BY GENMOV.
*        FMJL =>  THE INITIAL LOCATION OF MAN AT THE BEGINNING OF
*                 OF A CHAIN.  IT WILL BE ASSIGNED ONLY ON THE FIRST
*                CALL FROM GENMOV.
-SPACE 3
JMPGEN   JMV = 2 * TMV - PIECE
*   OBTAIN THE NEXT POSITION IN THE SAME DIRECTION AND
*   SEE IF THE JUMP IS VALID.
         DIFFER($(BOARD JMV))    :F(FRETURN)
         $(BOARD JMV) ' '        :F(FRETURN)
*   THE JUMP IS VALID.  LINK TO JMPLST.
         NJMP = NJMP + 1
         LJMP = JMPNT
         JMPNT = 'JMP' LVL '.' NCALL '.' NJMP
         JMPNT = JMPLST(JMPNT,LJMP,PIECE,JMV,TMV)
*   SET UP TO CHECK FOR FURTHER JUMPS IN A CHAIN.
         FMJL = IDENT(LJMP) PIECE
         KPC = PIECE
         PCH = $(BOARD KPC)
         KMV = TMV
         CCH = $(BOARD KMV)
         $(BOARD KMV) = ' '
*   CHECK FOR RESET OF NMV
         DIFFER(JSW)     :S(JMPGEN1)
         NMV =
         SLPNT =
         MSQN =
         DIFFER(PARPNT)     :F(JMPGEN1)
         DPT(PARPNT) =
JMPGEN1  JMPGEN = 1
*   THE JUMP HAS SUCCEEDED THIS FAR.
         JNME = '< TOP >'
         JNME = DIFFER(LJMP) JNAME(LJMP)
*OUTJMP   OUTPUT = TENSP 'JUMP MAY BE MADE FROM: ' PIECE ' TO: '
*+      JMV ' TAKING: ' TMV ' × J=> ' JNAME(JMPNT) ' L=> ' JNME
*
*   CHECK FOR FURTHER JUMPS IN A CHAIN.
JMPGEN2  LJMV = LT(LJMV,NDIR) LJMV + 1     :F(JMPGEN3)
         TMV = JMV + $(PLR 'DIR' LJMV)
         EQ(TMV,KMV)     :S(JMPGEN2)
         DIFFER($(BOARD TMV))     :F(JMPGEN2)
         $(BOARD TMV) $(OPN 'CHR')     :F(JMPGEN2)
         JSW3 =  JMPGEN(PLR,OPN,JMV,TMV,PARPNT,JMPNT)
         JSW2 = IDENT(JSW2) JSW3  :(JMPGEN2)
*
JMPGEN3  DIFFER(JSW2)     :S(JMPGEN5)
*   LINKAGE OF THE CHAIN TO MOVE-LIST WILL OCCUR ONLY IF
*   THERE ARE NO FURTHER POSSIBILITIES IN THE CHAIN.
         JSW = 1
         NMV = NMV + 1
         MSQN = 'MOV' LVL  '.' NCALL '.' NMV
*OUTJMV   OUTPUT = TENSP '### MOVE MAY BE MADE FROM: ' FMJL
*+                 ' TO: ' JMV ' × M=> ' MSQN
         MSQN = MOVLST(MSQN,PARPT,SLPNT,,,FMJL,JMV,HVAL(PARPT),LVL,
+             JMPNT,,I)
         DIFFER(SLPNT) :F(JMPGEN4)
         RPT(SLPNT) = MSQN
JMPGEN4  SLPNT = MSQN
         DIFFER(PARPNT) :F(JMPGEN5)
         DPT(PARPNT) = MSQN
*
*   THE TEMPARARY MOVE MUST BE RESTORED PRIOR TO RETURNING.
JMPGEN5  $(BOARD KPC) = PCH
         $(BOARD KMV) = CCH     :(RETURN)
-STITL     THE MINMAX ROUTINE
DMNMX    DEFINE('MINMAX(PLR,PNTR,BPT)VAL,MPT,CHS,TVAL,BSTPT') :(DHREVAL)
-SPACE
*        THIS FUNCTION IS USED TO BACK THE APPROPRIATE HVAL TO THE
*        PARENT MOVE.
*        ARGUMENTS ARE:
*        PLR => THE PLAYER WHO IS MAKING THE CHOICE OF MOVE AND TO
*             RECIEVE THE VALUE.
*        PNTR => POINTER TO THE MOVE TO RECIEVE THE VALUE.
*        BPT => NAME OF THE VARIABLE WHICH IS TO BE SET TO
*        THE BEST MOVE.
*
*        LOCAL VARIABLES ARE:
*        VAL => A TEMPORRY STG FOR THE MIN/MAX HVAL FOUND.
*        MPT => POINTER TO THE MOVE BEING CONSIDERED.
*        CHS => WHICH FUNCTION ('GT' -> MAX / 'LT' -> MIN) IS
*             TO BE USED IN THE SELECTION PROCESS.
*        TVAL => THE VALUE OF THE MOVE BEING CONSIDERED.
*
*        THE GLOBAL VARIABLE 'FRIEND' IS USED TO DETERMINE WHAT CHS
*        SHOULD BE.  THIS WILL HAVE THE COLOR ('BLK' OR 'WHT') THAT
*        THE COMPUTER IS PLAYING WITH.
-SPACE 2
MINMAX   DIFFER(DPT(PNTR))     :F(FRETURN)
*        SET UP FOR THE LOOP TO LOOK AT THE DECENDENT GENERATION
         BSTPT = DPT(PNTR)
MNMX     DIFFER(BSTPT)     :F(FRETURN)
         VAL = HVAL(BSTPT)
         BSTPT = IDENT(VAL) LPT(BSTPT)   :S(MNMX)
         MPT = LPT(BSTPT)
*        SELECT THE PROPER CHOICE TYPE
         CHS = 'LT'
         CHS = IDENT(FRIEND,PLR) 'GT'
MNMX1    DIFFER(MPT)     :F(MNMX3)
*        LOOP THRU THE GENERATION
         TVAL = HVAL(MPT)
         IDENT(TVAL)    :S(MNMX2)
         VAL = APPLY(CHS,TVAL,VAL) TVAL     :F(MNMX2)
         BSTPT = MPT
MNMX2    MPT = LPT(MPT)     :(MNMX1)
MNMX3    MINMAX = VAL
*         OUTPUT = TENSP TENSP 'THE BEST MOVE FOR ' PLR ' IS: '
*+        MNAME(BSTPT) ' HVAL= ' VAL
*        SET BPT TO THE BEST MOVE
         $BPT = BSTPT
         :(RETURN)
-STITL THE <HUEREVAL> FUNCTION
DHREVAL  DEFINE('HUEREVAL(HMPNT,PLR)LP1,BCNT,BKCNT,WCNT,WKCNT,LP2,'
+             'ACNMT,LDYK,DYCHR,BDYKE,WDYKE,'
+             'LCENT,CENTSQ,BCENT,BKCENT,WCENT,WKCENT,'
+             'LDD1,DDF,DDM,LDD2,LDD3,LDD4,LDD5,'
+             'MOVE,LMOV1,LMOV2,MVCNT,OREO,BACK,GUARD,'
+             'LMOB1,TPLR,TOPN,PCL,NMDIR,LMOB2,TPCH,BLKMOB,WHTMOB,'
+             'PROX,BLOC,DIFF,LPRX1,LPRX2,LTR1,BDSTR,'
+        'BLKTHRET,WHTTHRET')
-SPACE 2
*                  THIS FUNCTION EVALUATES THE CURRENT BOARD POSITION.
*        ALL CALCULATIONS ARE PERFORMED CONSIDERING THAT BLACK IS THE
*        FRIENDLY PLAYER.  MOST OF THE PARAMETERS ARE ADAPTED FROM
*        SAMUEL'S PROGRAM.
*
*        THE ARGUMENT (HMPNT) IS THE POINTER TO THE MOVE
*             BEING EVALUATED.
*        PLR IS THE PLAYER WHO HAS THE NEXT MOVE.
*
*                  THE FOLLOWING LOCAL VARIABLES ARE USED AS LOOP
*        COUNTERS:
*                  LP1,LP2,LDD1,LDD2,LDD3,LDD4,LDD5,LMOV1,
*                  LMOV2,LMOB1,LMOB2,LTR1,LPRX1,LPRX2
*
*                  BDSTR IS USED FOR TRACE OUTPUT
*                  DYCHR IS USED IN THE DYKE CALCULATIONS
*                  CENTSQ IS USED IN THE CENTER CONTROL CALCULATIONS
*                  BLOC & DIFF ARE USED IN THE PROXIMITY CALCULATIONS.
*
*                  PARAMETERS IF THE EVALUATION FUNCTION ARE:
*
*        BCNT      TOTAL NUMBER OF BLACK PIECES ON THE BOARD
*        BKCNT     NUMBER OF BLACK KINGS ON THE BOARD
*        WCNT      TOTAL NUMBER OF WHITE PIECES ON THE BOARD
*        WKCNT     NUMBER OF WHITE KINGS ON THE BOARD
*        ACNMT     ADVANCEMENT, CREDITED WITH +1 FOR EACH BLACK
*                  MAN IN HIS FIFTH OR SIXTH ROW, AND -1 FOR
*                  EACH WHITE MAN IN SQUARES 1)-17.
*        BDYKE     BLACK'S DYKE PARAMETER, CREDITED WITH +1 FOR
*                  EACH GROUP OF THREE BLACK MEN NEXT TO ONE
*                  ANOTHER ON THE SAME DIAGONAL
*        WDYKE     WHITE'S DYKE PARAMETER, CREDITED THE SAME AS BDYKE
*        BCENT     CREDITED WITH +1 FOR EACH BLACK MAN(NON-KING)
*                  IN THE CENTER OF THE BOARD
*                  (SQUARES 11,12,15,16,20,21,24,& 25)
*        BKCENT    CREDITED WITH +1 FOR EACH BLACK KING IN THE CENTER
*        WCENT     CREDITED WITH +1 FOR EACH WHITE MAN(NON-KING) IN THE
*                  CENTER OF THE BOARD
*        WKCENT    CREDITED WITH +1 FOR EACH WHITE KING IN THE CENTER
*        DDF       CREDITED WITH +1 FOR EACH BLACK MAN ON THE DOUBLE
*                  DIAGONAL FILES, AND WITH -1 FOR EACH WHITE MAN ON THE
*                  DOUBLE DIAGONAL FILES.
*        DDM       CREDITED WITH (+/-)3 FOR EACH (BLACK/WHITE) MAN ON
*                  THE DOUBLE DIAGONAL FILES, (+/-) 2 FOR EACH ON
*                  THE FILES ONE REMOVED FROM THE DDF, AND WITH
*                  (+/-) 1 FOR EACH ON THE FILES TWO REMOVED FROM THE
*                  DOUBLE DIAGONAL FILES
*        MOVE      CALCULATED IF THE TOTAL PIECE COUNT
*                  (2 * (BCNT + WCNT) + BKCNT + WKCNT) < 24
*                  CREDITED WITH +1 IF THERE IS AN ODD NUMBER
*                  OF PIECES IN BLACK'S MOVE SYSTEM FILES(1,2,3,& 4)
*                  CREDITED WITH -1 IF BLACK DOES NOT HAVE THE MOVE
*        BLKMOB    THE TOTAL NUMBER OF MOVES AVALIBLE TO
*                  BLACK, DISREGARDING THE FACT THE ONLY JUMPS MAY
*                  MAY BE MADE
*        BLKTHRET  THE NUMBER OF JUMPS AVALIBLE IN BLKMOB
*        WHTMOB    THE TOTAL NUMBER OF MOVES AVALIBLE TO WHITE
*        WHTTHRET  THE NUMBER OF JUMPS AVALIBLE IN WHTMOB
*        OREO      CREDITED WITH +1 FOR BLACK OCCUPPYING
*                  SQUARES 2,3,& 7, AND WITH -1 FOR WHITE OCCUPYING
*                  SQUARES 26,30,& 31.
*        BACK      CREDITED WITH +1 FOR BLACK OCCUPYING SQUARES 1 & 3,
*                  AND -1 FOR WHITE OCCUPYING SQUARES 30 & 32
*        GUARD     BACK + OREO
*        PROX      AN FUNCTION OF THE DISTANCE SEPERATING
*                  THE OPPOSING PIECES.  IT WILL BE CALCULATED ONLY WHEN
*                  ONLY WHEN THE MOVE PARAMETER IS TO BE CALCULATED.
*
*                  EACH OF THE PARAMETERS WILL BE MULTIPLIED BY AN
*        APPROPRIATE COEFFICIENT TO OBTAIN THE HUERISTIC VALUE
*        IF THE FRIENDLY PLAYER IS NOT 'BLK', THEN THE SIGN
*        OF THE FINAL VALUE WILL BE REVERSED.
-SPACE 3
*        DEFINE THE HUERISTIC PARAMETER COEFFICIENT VALUES
         KADVT = 600
         KKADVT = 300
         KACMT = 200
         KDYKE = -200
         KCENT = 250
         KKCENT = 400
         KDDF = 100
         KDDM = 65
         KMOVE = 1000
         KOREO = 90





         KBACK = 85
         KGUARD = 105
         KMOB = 700
         KPROX = -2
         KTHRET = 300
*
*     DEFINE CONSTANT ADDITIVE VALUES
*
         KSIGN = DIFFER(FRIEND,'BLK') '-'
         CADVT = CONVERT((KSIGN '2'),'INTEGER')
         CACMT = CONVERT((KSIGN '1'),'INTEGER')
         CCENT = CONVERT((KSIGN '2'),'INTEGER')
         CMOB = CONVERT((KSIGN '-2'),'INTEGER')
         CPROX = CONVERT((KSIGN '1'),'INTEGER')
*
*     DEFINE THE ARRAY WHICH SPECIFIES THE CENTER OF THE BOARD
*
         CENTER = ARRAY(8)
         CENTER<1> = 11
         CENTER<2> = 12
         CENTER<3> = 15
         CENTER<4> = 16
         CENTER<5> = 20
         CENTER<6> = 21
         CENTER<7> = 24
         CENTER<8> = 25
*
              :(DINITDAT)
-STITL   THE <HUEREVAL> FUNCTION
HUEREVAL           LP1 = LT(LP1,12) LP1 + 1     :F(HEVL1)
*
*     COMPUTE THE PIECE ADVANTAGE
*
         BCNT = DIFFER($('BLKPOS' LP1)) BCNT + 1
         BKCNT = DIFFER($('BLKKNG' LP1)) BKCNT + 1
         WCNT = DIFFER($('WHTPOS' LP1)) WCNT + 1
         WKCNT = DIFFER($('WHTKNG' LP1)) WKCNT + 1    :(HUEREVAL)
HEVL1    HUEREVAL = IDENT(BCNT) -9999999    :S(HEVL38)
         HUEREVAL = IDENT(WCNT) 9999999      :S(HEVL38)
         LP2 = 19
*
*     COMPUTE THE ADVANCEMENT PARAMETER
*
HEVL2     LP2 = LT(LP2,26) LP2 + 1     :F(HEVL4)
         $(BOARD LP2) BLKCHR     :F(HEVL3)
         ACNMT = ACNMT + 1
HEVL3    $(BOARD (LP2 - 9)) WHTCHR      :F(HEVL2)
         ACNMT = ACNMT - 1     :(HEVL2)
HEVL4    LDYK = 4
*
*     COMPUTE THE DYKE PARAMETER
*
HEVL5     LDYK = LT(LDYK,31) LDYK + 1     :F(HEVL7)
         DYCHR = $(BOARD LDYK)
         DIFFER(DYCHR)     :F(HEVL5)
         IDENT(DYCHR,' ')     :S(HEVL5)
         DYCHR 'K' =
         IDENT(DYCHR,$(BOARD (LDYK + 4)))     :F(HEVL6)
         IDENT(DYCHR,$(BOARD (LDYK - 4)))     :F(HEVL6)
         $(DYCHR 'DYKE') = $(DYCHR 'DYKE') + 1
HEVL6    IDENT(DYCHR,$(BOARD (LDYK + 5)))     :F(HEVL5)
         IDENT(DYCHR,$(BOARD (LDYK - 5)))     :F(HEVL5)
         $(DYCHR 'DYKE') = $(DYCHR 'DYKE') + 1     :(HEVL5)
HEVL7    LCENT = LT(LCENT,8) LCENT + 1     :F(HEVL8)
*
*     COMPUTE THE CENTER CONTROL PARAMETERS (BCENT,BKCENT,WCENT,WKCENT)
*
         CENTSQ = $(BOARD CENTER<LCENT>)
         CENTSQ ' '     :S(HEVL7)
         $(CENTSQ 'CENT') = $(CENTSQ 'CENT') + 1   :(HEVL7)
*
*     COMPUTE THE DOUBLE DIAGIONAL PARAMETER(DDF)
*
HEVL8    LDD1 = LT(LDD1,31) LDD1 + 1     :F(HEVL12)
HEVL9    $(BOARD LDD1) BLKCHR    :F(HEVL10)
         DDF = DDF + 1   :(HEVL11)
HEVL10    $(BOARD LDD1) WHTCHR     :F(HEVL11)
         DDF = DDF - 1
HEVL11   LDD1 = NE(REMDR(LDD1,5),0) LDD1 + 4 :S(HEVL9) F(HEVL8)
HEVL12   LDD2 = -3
*
*     COMPUTE THE DIAGIANAL MOMENT PARAMETER(DDM)
*
         DDM = DDF * 3
HEVL13   LDD2 = LT(LDD2,22) LDD2 + 5     :F(HEVL17)
         LDD3 = LDD2 + 12
         $(BOARD LDD2) BLKCHR     :F(HEVL14)
         DDM = DDM + 2   :(HEVL15)
HEVL14 $(BOARD LDD2) WHTCHR     :F(HEVL15)
         DDM = DDM - 2
HEVL15 $(BOARD LDD3) BLKCHR     :F(HEVL16)
         DDM = DDM + 2   :(HEVL13)
HEVL16   $(BOARD LDD3) WHTCHR     :F(HEVL13)
         DDM = DDM - 2     :(HEVL13)
HEVL17   LDD4 = -2
HEVL18   LDD4 = LT(LDD4,13) LDD4 + 5     :F(HEVL22)
         LDD5 = LDD4 + 20
         $(BOARD LDD4) BLKCHR     :F(HEVL19)
         DDM = DDM + 1     :(HEVL20)
HEVL19   $(BOARD LDD4) WHTCHR     :F(HEVL20)
         DDM = DDM - 1
HEVL20   $(BOARD LDD5) BLKCHR     :F(HEVL21)
         DDM = DDM + 1     :(HEVL18)
HEVL21   $(BOARD LDD5) WHTCHR     :F(HEVL18)
         DDM = DDM - 1     :(HEVL18)
HEVL22   MOVE = (BCNT + WCNT) * 2 + BKCNT + WKCNT
         MOVE = GT(MOVE,24) 0     :S(HEVL26)
         MOVE = NE(BCNT,WCNT)     :S(PROX1)
*
*     COMPUTE THE MOVE PARAMETER
*
         LMOV1 = -9
HEVL23   LMOV1 = LT(LMOV1,27) LMOV1 + 9     :F(HEVL25)
         LMOV2 =
HEVL24   LMOV2 = LT(LMOV2,4) LMOV2 + 1     :F(HEVL23)
         MVCNT = DIFFER($(BOARD (LMOV1 + LMOV2)),' ') MVCNT + 1
                   :(HEVL24)
HEVL25   MOVE = REMDR(MVCNT,2)
         MOVE = EQ(MOVE,0) -1
*    IF WHT HAS THE NEXT MOVE, THE MOVE PARM MUST CHANGE SIGN
         MOVE = DIFFER(PLR,'BLK') -MOVE
*
*    COMPUTE THE PROXIMITY PARAMETER
*
PROX1    LPRX1 = LT(LPRX1,12) LPRX1 + 1     :F(PROX3)
         BLOC = DIFFER($('BLKPOS' LPRX1))  $('BLKPOS' LPRX1)  :F(PROX1)
         LPRX2 =
PROX2    LPRX2 = LT(LPRX2,12) LPRX2 + 1   :F(PROX1)
         DIFF = DIFFER($('WHTPOS' LPRX2)) $('WHTPOS' LPRX2) -
+                  BLOC     :F(PROX2)
         DIFF = LT(DIFF,0) -DIFF
         PROX = PROX + DIFF     :(PROX2)
PROX3    PROX = PROX / (BCNT * WCNT)
*
HEVL26   EQ((BKCNT + WKCNT),0)     :F(HEVL31)
*
*     COMPUTE THE PARAMETERS OREO,BACK, & GUARD
*
         $(BOARD '3') 'B'     :F(HEVL28)
         $(BOARD '2') 'B'     :F(HEVL27)
         $(BOARD '7') 'B'     :F(HEVL27)
         OREO = 1
HEVL27   $(BOARD '1') 'B'     :F(HEVL28)
         BACK = 1
HEVL28   $(BOARD '30') 'W'     :F(HEVL30)
         $(BOARD '26') 'W'     :F(HEVL29)
         $(BOARD '31') 'W'     :F(HEVL29)
         OREO = OREO - 1
HEVL29   $(BOARD '32') 'W'     :F(HEVL30)
         BACK = BACK - 1
HEVL30   GUARD = BACK + OREO
*
*     COMPUTE THE MOBILITY & THRET FUNCTIONS
*
HEVL31   LMOB1 = LT(LMOB1,12) LMOB1 + 1     :F(HEVL37)
         TPLR = 'BLK'
         TOPN = 'WHT'
HEVL32   PCL = $(TPLR 'POS' LMOB1)
         DIFFER(PCL)     :F(HEVL35)
         NMDIR = 2 + $(TPLR 'KNG' LMOB1) * 2
         LMOB2 =
HEVL33   LMOB2 = LT(LMOB2,NMDIR) LMOB2 + 1     :F(HEVL35)
         TPCH = $(BOARD (PCL + $(TPLR 'DIR' LMOB2)))
         DIFFER(TPCH)     :F(HEVL33)
         TPCH $(TPLR 'CHR')     :S(HEVL33)
         TPCH $(TOPN 'CHR')     :F(HEVL34)
         $(BOARD (PCL + 2 * $(TPLR 'DIR' LMOB2))) ' '   :F(HEVL33)
         $(TPLR 'THRET') = $(TPLR 'THRET') + 1
HEVL34   $(TPLR 'MOB') = $(TPLR 'MOB') + 1     :(HEVL33)
HEVL35   TPLR = IDENT(TPLR,'BLK') 'WHT'   :F(HEVL31)
         TOPN = 'BLK'     :(HEVL32)
*
*     COMPUTE THE TOTAL HUERISTIC VALUE
*
HEVL37   HUEREVAL = KADVT * (BCNT - WCNT + CADVT)
+             + KKADVT * (BKCNT - WKCNT + CADVT)
+             + KACMT * (ACNMT + CACMT) + KDYKE * (BDYKE - WDYKE)
+             + KCENT * (BCENT - WCENT + CCENT)
+             + KKCENT * (BKCENT - WKCENT + CCENT)
+             + KDDF * DDF + KDDM * DDM + KMOVE * MOVE
+             + KOREO * OREO + KBACK * BACK + KGUARD * GUARD
+             + KMOB * (BLKMOB - WHTMOB + CMOB)
+             + KPROX * (PROX + CPROX)
+            + KTHRET * (BLKTHRET - WHTTHRET)
*
*     ALTER THE SIGN IF NECCESSARY (+ FOR FRIEND'S ADVTG).
*
HEVL38   HUEREVAL = DIFFER('BLK',FRIEND) -HUEREVAL
*
*     CHECK IF TRACE OUTPUT IS DESIRED
*
         KHVTRC = GT(KHVTRC,0) KHVTRC - 1     :F(RETURN)
HEVL39   LTR1 = LT(LTR1,35) LTR1 + 1   :F(HEVL40)
         BDSTR = BDSTR $(BOARD LTR1)     :(HEVL39)
HEVL40   BDSTR ' ' = '.'     :S(HEVL40)
HEVL41   OUTRC = TENSP 'MOVE(' MNAME(HMPNT) ')  : HVAL = ' HUEREVAL
         OUTRC = TENSP TENSP 'BOARD =>' BDSTR
         OUTRC = TENSP TENSP 'BCNT: ' BCNT ' BKCNT: ' BKCNT
+                  ' WCNT: ' WCNT ' WKCNT: ' WKCNT ' ACNMT: ' ACNMT
         OUTRC = TENSP TENSP 'BCENT: ' BCENT ' BKCENT: ' BKCENT
+                  ' WCENT: ' WCENT ' WKCENT: ' WKCENT ' MOVE: ' MOVE
         OUTRC = TENSP TENSP 'BDYKE: ' BDYKE ' WDYKE: ' WDYKE ' DDF: '
+                  DDF ' DDM: '  DDM ' PROX: ' PROX
         OUTRC = TENSP TENSP 'BLKMOB: ' BLKMOB ' WHTMOB: ' WHTMOB
+                  ' BLKTHRET: ' BLKTHRET ' WHTTHRET:' WHTTHRET
         OUTRC = TENSP TENSP ' OREO: ' OREO ' BACK: ' BACK
+                  ' GUARD: ' GUARD
                   :(RETURN)
-STITL BOARD INITIALIZATION ROUTINE
DINITDAT PATIN = BREAK(':- ') $ MAN SPAN(':- ') BREAK(' .,;') $ LOC
+   SPAN(' .,;') BREAK(' .;') $ KNG
*        MAN & LOC WILL BE ASSIGNED IMMEDIATELY.
*   KNG WILL BE ASSIGNED ONLY UPON COMPLETE MATCH
-SPACE 2
         DEFINE('INITDATA()CNTR,CARD,MAN,LOC,KNG,PKNG,BLKCNT,WHTCNT')
              :(DDATMOV)
-SPACE
*        THIS ROUTINE MAY BE USED TO OBTAIN A PARTIAL
*   GAME BOARD CONFIGURATION.
-SPACE
*        ARGUMENTS DEFINE WHICH PLAYER('BLK' OR 'WHT') HAS
*   THE NEXT MOVE.
-SPACE
*        LOCAL VARIABLES ARE:
*   CNTR => A GENERAL COUNTER USED THRUOUT THE ROUTINE.
*   CARD => TEMP. STORAGE FOR THE INPUT RECORDS.
*   MAN  => THE PLAYER BEING PLACED ON THE BOARD.
*   LOC  => THE BOARD POSITION WHERE THE MAN IS TO BE PLACED.
*   KNG  => A SWITCH FOR WHEN THE MAN IS A KING.
*   PATIN => A PATTERN FOR BREAKING THE LOCAL VARIABLES
*        OUT OF THE INPUT RECORD.
-SPACE
INITDATA &TRIM = 1
         BOARD = 'BOARD'
         OUTPUT = TENSP 'WHAT BOARD STATE DO YOU DESIRE '
+             '(RETURN FOR BEGIN)?'
         CARD = INDAT                                 :F(BGNGAME)
         EQ(SIZE(CARD),0)     :S(BGNGAME)
         CARD = CARD '.'
         CARD (POS(0) 'D/')     :S(BNKBD)
*   IF NO INPUT, THEN BEGIN GAME STATE IS ASSUMED.
         CARD  (BREAK(' -') $ PLAYER SPAN(' -') BREAK(' .;') $ OPPONENT)
*   ASSIGN WHO IS FIRST TO MOVE.
         OUTPUT = TENSP PLAYER ' WILL MOVE FIRST.'
*        BLANK OUT ALL LEGAL BOARD POSITIONS
-SPACE
BNKBD    CNTR = LT(CNTR,35) CNTR + 1     :F(XOUT1)
         $(BOARD CNTR) = ' '          :(BNKBD)
XOUT1    BOARD9  =
         BOARD18 =
         BOARD27 =
         PLCTAB = TABLE()
         PLCTAB<'9'>  = 'X'
         PLCTAB<9>  =   'X'
         PLCTAB<'18'> = 'X'
         PLCTAB<18>  =  'X'
         PLCTAB<'27'> = 'X'
         PLCTAB<27>  =  'X'
-SPACE
INPLOP   OUTPUT = '?'
         KNG =
         MAN =
         LOC =
         PKNG =
         CARD = INDAT                                 :F(INITEND)
         EQ(SIZE(CARD),0)                    :S(INITEND)
         CARD = CARD ' .'
*
         CARD (POS(0) 'C/') =      :S(INITCHG)
*
         CARD (POS(0) 'L/') =     :S(INITLST)
*
         CARD 'DISP'     :S(INITDISP)
*
         CARD (POS(0) 'E/')     :S(INITEND)
*
         CARD (POS(0) 'B/')     :S(BGNGAME)
*
         CARD PATIN
         LOC = CNVTSAM(LOC)
         DIFFER(KSTD)     :S(GETCNT)
         GT(LOC,35)     :S(OFBDERR)
         LT(LOC,1)      :S(OFBDERR)
         DIFFER(PLCTAB<LOC>,'X')     :F(OFBDERR)
GETCNT   IDENT(PLCTAB<LOC>,LOC)     :S(USDERR)
         PLCTAB<LOC> = LOC
         CNTR = $(MAN 'CNT')
         $(MAN 'CNT') = LT($(MAN 'CNT'),12) $(MAN 'CNT') + 1 :F(CNTERR)
         $(MAN 'POS' $(MAN 'CNT')) = CONVERT(LOC,'INTEGER')
         $(BOARD LOC) = DIFFER(LOC) $(MAN 'MAN')
         $(MAN 'KNG' $(MAN 'CNT')) = DIFFER(KNG) 1           :F(PENTRY)
         $(BOARD LOC) = DIFFER(LOC) $(BOARD LOC) 'K'
         PKNG = 'KNG'
PENTRY   OUTPUT = DIFFER(LOC) TENSP MAN PKNG ' IS AT ' CNVTSTD(LOC) '.'
         :(INPLOP)
-SPACE
*   ERROR IF $(MAN 'CNT') > 12.
CNTERR   OUTPUT = TENSP 'SUFFICIENT ' MAN ' POSITIONS HAVE BEEN '
+   'SPECIFIED.  THIS RECORD WILL BE IGNORED.'        :(INPLOP)
-SPACE
*        INITIALIZE TO BEGIN GAME STATE.
BGNGAME  OUTPUT = TENSP 'BEGIN GAME STATE HAS BEEN ASSUMED.'
         CNTR =
         PLAYER = 'BLK'
         OPPONENT = 'WHT'
INBLK    CNTR = LT(CNTR,13) CNTR + 1                  :F(INBNK)
         $(BOARD CNTR) = 'B'                        :(INBLK)
INBNK    CNTR = LT(CNTR,22) CNTR + 1                  :F(INWHT)
         $(BOARD CNTR) = ' '                        :(INBNK)
INWHT    CNTR = LT(CNTR,35) CNTR + 1                  :F(XOUT2)
         $(BOARD CNTR) = 'W'                        :(INWHT)
XOUT2    BOARD9  =
         BOARD18 =
         BOARD27 =
         CNTR =
FPOSA    CNTR = LT(CNTR,8) CNTR + 1                   :F(FPOSB)
         $('BLKPOS' CNTR) = CNTR
         $('WHTPOS' CNTR) = 36 - CNTR                 :(FPOSA)
FPOSB    CNTR = LT(CNTR,12) CNTR + 1                  :F(INITEND)
         $('BLKPOS' CNTR) = CNTR + 1
         $('WHTPOS' CNTR) = 35 - CNTR                 :(FPOSB)
*
INITEND  OUTPUT = TENSP 'INITIALIZATION OF BOARD IS COMPLETE.' :(RETURN)
*
OFBDERR  OUTPUT = TENSP "UNDER SAMUEL'S NOTATION, POSITIONS 9,18, & 27 "
+                 'ARE INVALID.'
*
RNTMSG   OUTPUT = TENSP 'RE-ENTER YOUR INPUT.'   :(INPLOP)
*
USDERR   OUTPUT = TENSP 'THAT POSITION ' CNVTSTD(LOC) ' IS ALREADY '
+                  'IN USE.'     :(RNTMSG)
INITDISP DISPLAY()     :(INPLOP)
*
INITCHG  CARD PATDMV
         $FMLM = DIFFER(TOLM) CONVERT(TOLM,'INTEGER')   :S(INITCHG2)
         TOLM '"' = ' '
         $FMLM = TOLM
INITCHG2 OUTPUT = TENSP 'THE VALUE OF ' FMLM ' HAS BEEN SET = '
+             $FMLM     :(INPLOP)
*
INITLST  CARD PATDMV
         OUTPUT = TENSP FMLM ' = ' $FMLM     :(INPLOP)
-STITL     MOV INPUT ROUTINE
DDATMOV  DEFINE('DATAMOV(PLR,OPN)CARD,TOLM,FMLM,GNLY,MVPT,ERCNT,DKGSW,'
+                  'MVPT,AVBMOVS')
-SPACE
*        THIS FUNCTION MAY BE USED TO OBTAIN SPECIFIED MOVES.
*   FROM EITHER A PLAYER OR A DATASET.
*        ARGUMENTS ARE THE PLAYER SELECTION('BLK' OR 'WHT').
*        LOCAL VARIABLES ARE:
*   CARD => THE INPUT RECORD. MAY BE USED IN ERROR MSGS.
*   TOLM => WHERE THE PIECE IS TO BE MOVED FROM.
*   FMLM =>WHERE THE PIECE IS TO BE MOVED FROM.
*   GNLY => SWITCH FOR USE WITH GENMOV.
*   MVPT => POINTER TO THE MOVE TO BE MADE.
*    ERCNT => THE ERROR COUNTER. IF >3, THEN THE PLAYER LOSES HIS TURN.
*    DKGSW => THE KING SWITCH AS DESCRIBED IN MAKMOV.
*    AVBMOVS => STRING OF VALID MOVES USED BY ASST.
-SPACE 2
         FORFEIT = 'F'
*    THIS IS USED TO FILL A VACANCY IN RECAPLST DUE TO LOST TURN.
*
    PATDMV =  BREAK(' >') $ FMLM SPAN(' >')
+   BREAK(' .>') $ TOLM   :(DDSPLY)
-SPACE
*        THIS PATTERN WILL BE USED TO BREAK OUT THE MOVE LOCATIONS.
-SPACE
DATAMOV  GNLY = 1
*   OBTAIN A LIST OF VALID MOVES FOR THE PLAYER
         GENMOV(PLR,OPN,,TREETOP,GNLY)     :F(LOSGM)
         EQ(NMV,0)        :S(LOSGM)
*    IF NO MOVES ARE POSSIBLE, THEN THE PLAYER LOSES THE GAME.
*
*
DATAMOV1 OUTPUT = 'YOUR MOVE IS?'
         CARD = INMOV                                  :F(INPERR)
         FMLM = CARD
         TOLM =
*        OBTÔAIN AN INPUT LINE
         EQ(SIZE(CARD),0)   :S(REENTR)
         CARD = CARD ' .'
DMVPATCK CARD PATDMV
*        CHECK HERE FOR A DISPLAY REQUEST.
         CARD 'DISP'        :S(MOVDSPLY)
*   CHECK FOR REQUEST FOR ASSISTANCE.
         CARD 'ASST'     :S(DMVASST)
*   CHECK FOR TRACE REQUEST.
         FMLM 'TRACE'     :S(DMVTRC)
*   CHECK FOR DUMP REQUEST.
         FMLM 'DUMP'     :S(DMVDUMP)
*   CHECK FOR REQUEST FOR RECAP OF GAME.
         CARD 'RECAP'     :S(DMVRCP)
*
         CARD (POS(0) 'C/') =     :S(DMVCHNG)
*
         CARD (POS(0) 'L/') =     :S(DMVLST)
*
         CARD 'DRAW'     :S(DMVDRAW)
*    USED TO END THE GAME IF A DRAW HAS DEVELOPED.
*
         FMLM = CNVTSAM(FMLM)
         TOLM = CNVTSAM(TOLM)
         TOLM = CONVERT(TOLM,'INTEGER')
         FMLM = CONVERT(FMLM,'INTEGER')
         MVPT = MSQN
DATAMOV2 EQ(FMLM,FMLOC(MVPT))     :F(DATAMOV3)
         EQ(TOLM,TOLOC(MVPT))     :F(DATAMOV3)
*     IF THE MOVE IS ON THE LIST, MAKE IT.
         MAKMOV(MVPT,PLR,OPN,'DKGSW',GNLY)     :S(RETURN) F(MKRERR)
DATAMOV3 DIFFER(LPT(MVPT))     :F(INVERR)
         MVPT = LPT(MVPT)     :(DATAMOV2)
*
*        ERROR SECTION
*
MKRERR   OUTPUT = TENSP 'THE MOVE-MAKER HAS FAILED.' :(REENTR)
*
INPERR   OUTPUT = TENSP 'I ASSUME THAT YOU RESIGN!!!'
         OUTPUT = TENSP OPN ' WINS.'   :(FRETURN)
*
INVERR   OUTPUT = TENSP 'THAT MOVE (' CNVTSTD(FMLM) '->' CNVTSTD(TOLM)
+                ') IS INVALID.???'
         ERCNT = LT(ERCNT,2) ERCNT + 1   :F(LOSTRN)
REENTR   OUTPUT = TENSP 'RE-ENTER YOUR MOVE!!!'  :(DATAMOV1)
*
LOSTRN   RECAPENT(PLR,FORFEIT,FORFEIT)
         OUTPUT = TENSP 'YOU HAVE MADE 3 ILLEGAL MOVES.'
         OUTPUT = TENSP 'YOU HAVE LOST YOUR TURN!!!' :(RETURN)
*
LOSGM    OUTPUT = TENSP 'YOU HAVE NO LEGAL MOVES!!'
         OUTPUT = TENSP OPN ' WINS!!!!!'   :(FRETURN)
*
*        SPECIAL FEATURES SECTION
*
MOVDSPLY DISPLAY()     :(DATAMOV1)
*
DMVTRC   &TRACE = CONVERT(TOLM,'INTEGER')     :(DATAMOV1)
*
DMVDUMP  DUMP(CONVERT(TOLM,'INTEGER'))     :(DATAMOV1)
*
DMVASST   MVPT = MSQN
         DIFFER(AVBMOVS)     :S(DMVAST2)
DMVAST1  AVBMOVS = DIFFER(MVPT) AVBMOVS ' (' CNVTSTD(FMLOC(MVPT))
+                  '->' CNVTSTD(TOLOC(MVPT)) ')'     :F(DMVAST2)
         MVPT = LPT(MVPT)     :(DMVAST1)
DMVAST2  OUTPUT = TENSP 'MOVES AVALIBLE TO YOU ARE:'
+                  AVBMOVS     :(DATAMOV1)
*
DMVRCP   RECAPPNT()     :(DATAMOV1)
DMVCHNG  CARD PATDMV
         $FMLM = DIFFER(TOLM) CONVERT(TOLM,'INTEGER')   :S(DMVCHNG2)
         TOLM '"' = ' '
DMVCHNG1 $FMLM = TOLM
DMVCHNG2 OUTPUT = TENSP 'THE VALUE OF ' FMLM ' HAS BEEN SET = '
+                  $FMLM      :(DATAMOV1)
*
DMVLST   CARD PATDMV
         OUTPUT = TENSP FMLM ' = ' $FMLM     :(DATAMOV1)
*
DMVDRAW  OUTPUT = TENSP 'THE GAME HAS BECOME A DRAW.'     :(FRETURN)
-STITL     DISPLAY ROUTINE
DDSPLY   OUTPUT('OUTNSK','TERM1','+')
*        OUTPUT ASSOCIATION FOR PRINTING W/ NO LINE FEED.
-SPACE 2
         BOTTOM = TENSP DUPL(' __',8)
*        LINE FOR THE BOTTOM OF EACH ROW ON THE BOARD.
-SPACE 2
         DEFINE('DISPLAY()IDSPLY,JDSPLY,NUMLN1,NUMLN2,'
+             'POSLN1,POSLN2,POSBD1,POSBD2')   :(DRCPE)
*        THIS FUNCTION IS USED TO DISPLAY THE CURRENT BOARD STATE.
*        THERE ARE NO ARGUMENTS.  TWO ROWS OF THE BOARD ARE BUILT
*        AND THEN PRINTED.  LOCAL VARIABLES ARE:
*             NUMLN1 & NUMLN2 =>  PRINT LINES FOR LOCATION NUMBERS.
*             POSLN1 & POSLN2 =>  PRINT LINES FOR LOCATION VALUES.
*             POSBD1 & POSBD2 =>  THE LOCATIONS BEING ADDED.
*             IDSPLY & JDSPLY  =>  LOOP COUNTERS.
-SPACE 2
DISPLAY  IDSPLY = 44
         OUTPUT = TENSP 'THE CURRENT BOARD STATE IS:'
         OUTPUT = BOTTOM
DSPLY1   IDSPLY = GT(IDSPLY,9)  IDSPLY - 9   :F(RETURN)
         NUMLN1 = TENSP '×  '
         NUMLN2 = TENSP '×'
         POSLN1 = TENSP '×  '
         POSLN2 = TENSP '×'
         JDSPLY = -1
DSPLY2   JDSPLY = LT(JDSPLY,3)  JDSPLY + 1     :F(DSPLY3)
*        CONSTRUCT THE FIRST ROW.
         POSBD1 = IDSPLY - JDSPLY
         POSLN1 = POSLN1 '×' $(BOARD POSBD1)
+             DUPL(' ',(2 - SIZE($(BOARD POSBD1)))) '×  '
         POSBD1 = CNVTSTD(POSBD1)
         NUMLN1 = NUMLN1 '×' DUPL(' ',(2 - SIZE(POSBD1))) POSBD1 '×  '
*        CONSTRUCT THE SECOND ROW.
         POSBD2 = IDSPLY - JDSPLY - 4
         POSLN2 = POSLN2  $(BOARD POSBD2)
+             DUPL(' ',(2 - SIZE($(BOARD POSBD2)))) '×  ×'
         POSBD2 = CNVTSTD(POSBD2)
         NUMLN2 = NUMLN2  DUPL(' ',(2 - SIZE(POSBD2))) POSBD2 '×  ×'
              :(DSPLY2)
*        PRINT THE TWO ROWS.
DSPLY3   OUTPUT = NUMLN1
         OUTPUT = POSLN1
         OUTNSK = BOTTOM
         OUTPUT = NUMLN2
         OUTPUT = POSLN2
         OUTNSK = BOTTOM     :(DSPLY1)
-STITL     THE RECAP ENTRY FUNCTION
DRCPE    DEFINE('RECAPENT(PLR,FMLR,TOLR)LNK')   :(DRCPP)
*
*        THIS FUNCTION IS USED TO ADD ELEMENTS TO <RCPLST>.
*        ARGUMENTS ARE:
*                  PLR => THE PLAYER MAKING THE MOVE.
*                  FMLR & TOLR => THE POSITIONS(SAMUEL'S NOTATION) THAT
*                            THE MOVE OS MADE FROM & TO.
*        LOCAL VARIABLES ARE:
*                  LNK => A TEMP LINK FOR THE LIST
*        GLOBAL VARIABLES AFFECTED ARE:
*                  MOVCNTR => THE # OF MOVE PAIRS MADE IN THE GAME.
*                            IT WILL BE INCREMENTED IF BLACK IS
*                            MAKING THE MOVE.
*                  RCPHEAD => POINTS TO THE HEAD OF <RCPLST>.
*                  CURRCPE => POINTS TO THE CURRENT RCPLST ENTRY.
*
RECAPENT FMLR = CNVTSTD(FMLR)
         TOLR = CNVTSTD(TOLR)   :($('RCPE' PLR))
*    BLACK'S ENTRY SECTION
RCPEBLK  MOVCNTR = MOVCNTR + 1
         LNK = CURRCPE
         CURRCPE = RCPLST(,MOVCNTR,FMLR,TOLR,,)
         RCPHEAD = EQ(MOVCNTR,1) CURRCPE   :S(RETURN)
         RCPLNK(LNK) = CURRCPE     :(RETURN)
*    WHITE'S ENTRY SECTION
RCPEWHT  DIFFER(CURRCPE)     :F(RCPEWST)
         WFM(CURRCPE) = FMLR
         WTO(CURRCPE) = TOLR     :(RETURN)
*    USED IF WHITE MAKES THE FIRST MOVE (MID-GAME SITUATION).
RCPEWST  MOVCNTR = MOVCNTR + 1
         CURRCPE = RCPLST(,MOVCNTR,,,FMLR,TOLR)
         RCPHEAD = CURRCPE     :(RETURN)
-STITL     THE RECAP PRINTING ROUTINE
DRCPP    MVSPR = ' -> '
*    THIS WILL BE USED TO SEPERATE THE MOVES IN THE LISTING.
*
         DEFINE('RECAPPNT()RCPNTR,MCNT,BFMP,BTOP,WFMP,WTOP')
                   :(DCVSTD)
*
*        THIS FUNCTION IS USED TO PRINT THE RECAP LISTING OF THE GAME.
*         LOCAL VARIABLES ARE:
*         RCPNTR => THE POINTER TO THE ELEMENT OF <RCPLST> BEING PRINTED
*         MCNT => THE MOVE COUNT FOR THIS ELEMENT.
*         BFMP,BTOP,WFMP,WTOP => BUFFERED PRINT VARIABLES
*                   OF THE LOCATIONS OF THE MOVES.
*
RECAPPNT OUTPUT = TENSP 'RECAP OF GAME IS AS FOLLOWS:'
         RCPNTR = DIFFER(RCPHEAD) RCPHEAD    :F(RCPP2)
         OUTPUT = TENSP 'MOVE#    BLACK' TENSP 'WHITE'
RCPP1    DIFFER(RCPNTR)     :F(RETURN)
         MCNT = DUPL(' ',4 - SIZE(MVCNTR(RCPNTR))) MVCNTR(RCPNTR)
         BFMP = DUPL(' ',5 - SIZE(BFM(RCPNTR))) BFM(RCPNTR)
         BTOP = DUPL(' ',3 - SIZE(BTO(RCPNTR))) BTO(RCPNTR)
         WFMP = DUPL(' ',3 - SIZE(WFM(RCPNTR))) WFM(RCPNTR)
         WTOP = DUPL(' ',3 - SIZE(WTO(RCPNTR))) WTO(RCPNTR)
*
         OUTPUT = TENSP MCNT BFMP MVSPR BTOP '  :  ' WFMP MVSPR WTOP
         RCPNTR = RCPLNK(RCPNTR)     :(RCPP1)
*
RCPP2    OUTPUT = TENSP 'NO MOVES HAVE BEEN MADE YET.'   :(RETURN)
-STITL  CONVERSION TABLE AND ROUTINES FOR STD <-> SAM
*        THESE ROUTINES ARE EMPLOYED WHEN AN INDIVIDUAL DESIRES TO
*        TO USE STANDARD CHECKERS NOTATION ( 1 -> 32 ) RATHER THAN
*        SAMUEL'S NOTATION ( 1 -> 36 ) AS DESCRIBED IN HIS PAPER,
*        "SOME STUDIES IN MACHINE LEARNING USING A GAME OF CHECKERS",
*        BY A.L. SAMUEL
*        IBM JOURNAL OF RESEARCH AND DEVELOPMENT, 1959, AS REPRINTED IN
*        COMPUTERS AND THOUGHT, E.A. FEIGENBAUM & J. FELDMAN,
*        MC GRAW HILL BOOK CO.,NEW YORK,NEW YORK, 1963.
*        SAMUEL'S NOTATION IS USED INTERNALLY FOR THE PROGRAM.
-SPACE 2
DCVSTD   DEFINE('CNVTSTD(VAR)')   :(DCVSAM)
*        THIS FUNCTION IS USED TO CONVERT SAMUEL'S NOTATION TO
*        STANDARD CHECKER'S NOTATION IF <KSTD> IS NON-NULL.
*
CNVTSTD  CNVTSTD = VAR
         CNVTSTD = DIFFER(KSTD) SAMTSTD<VAR>     :(RETURN)
*
*
DCVSAM   DEFINE('CNVTSAM(VAR)')  :(DTABGEN)
*        THIS FUNCTION IS USED TO CONVERT STANDARD CHECKER'S NOTATION
*        INTO SAMUEL'S NOTATION , WHICH IS USED INTERNALLY,
*        IF <KSTD> IS NON-NULL.
CNVTSAM  CNVTSAM = VAR
*
         CNVTSAM = DIFFER(KSTD) STDTSAM<VAR>     :(RETURN)
*
*
DTABGEN  DEFINE('TABGEN()KTB,ITB,STD,SAM,CSTD,CSAM')  :(DRESET)
*        THIS ROUTINE GENERATES THE TABLES REQUIRED FOR CONVERSION
*        FROM STD <-> SAMUEL'S NOTATION.
*
TABGEN   STDTSAM = TABLE(75)
         SAMTSTD = TABLE(75)
         STDTSAM<'F'> = 'F'
         SAMTSTD<'F'> = 'F'
TABBLD   KTB = -1
TABBLD1   KTB = LT(KTB,3) KTB + 1  :F(RETURN)
         ITB =
TABBLD2  ITB = LT(ITB,8) ITB + 1   :F(TABBLD1)
         STD = (8 * KTB) + ITB
         SAM = (9 * KTB) + ITB
         CSTD = CONVERT(STD,'STRING')
         CSAM = CONVERT(SAM,'STRING')
         STDTSAM<STD> = SAM
         STDTSAM<CSTD> = CSAM
         SAMTSTD<SAM> = STD
         SAMTSTD<CSAM> = CSTD   :(TABBLD2)
-STITL   THE RESET FUNCTION
DRESET   DEFINE('RESET()')     :(DMVLSTRC)
*
*        THIS FUNCTION IS USED TO RESET THE GLOBAL VARIABLES USED
*        IN TREE CREATION.
*        STORAGE WILL BE COLLECTED AFTER THEY HAVE BEEN RESET.
*        THERE ARE NO ARGUMENTS OR LOCAL VARIABLES.
-SPACE 2
RESET    MSQN =
         SLPNT =
         RLPNT =
         JMPNT =
         TREETOP = MOVLST('TOP',,,,,,,,,,,)
         FSTBOT =
         LVLIMT = MINLVL
         CALLVL =
         BOTLVL =
         COLLECT()
         :(RETURN)
-SPACE 4
DMVLSTRC   OUTPUT('OUTRC','TRCOUT',' ')
*        THIS FUNCTION IS USED TO PRODUCE TRACE OUTPUT FOR
*     THE LINKED LISTS <MOVLST> & <JMPLST>.
*     THE OUTPUT IS PLACED ON FI(TRCOUT).
*
         DEFINE('MOVTRC(NAME,TAG)LSTNO,DPT,UNM,LNM,RNM,DNM,JNM')
         :(INITIAL)
*
MOVTRC   LSTNO = &LASTNO
         DPT = DATATYPE($NAME)
         DIFFER('MOVLST',DPT)     :F(DMTR1)
         OUTRC = '***' LSTNO '***' NAME '=>' $NAME
         :(RETURN)
DMTR1    UNM = UPT($NAME)
         UNM = DIFFER(UNM) MNAME(UNM)
         LNM = LPT($NAME)
         LNM = DIFFER(LNM) MNAME(LNM)
         RNM = RPT($NAME)
         RNM = DIFFER(RNM) MNAME(RNM)
         DNM = DPT($NAME)
         DNM = DIFFER(DNM) MNAME(DNM)
         JNM = JPT($NAME)
         OUTRC = '***' LSTNO '*** ' NAME '= MOVLST(' MNAME($NAME) ') :'
+                  ' UPT=>' UNM ' LPT=>' LNM ' RPT=>' RNM ' DPT=>' DNM
         OUTRC = TENSP 'FM=>' FMLOC($NAME) ' TO=>' TOLOC($NAME)
+                  ' LVL=>' LVL($NAME) ' HVAL=>' HVAL($NAME)
+                  ' APNT=>' APNT($NAME)
DMTR2    DIFFER(JNM)     :F(RETURN)
         OUTRC = TENSP 'JUMP MADE: JNAME(' JNAME(JNM) ') FROM:'
+                  FMPOS(JNM) ' TO:' TOPOS(JNM)
+                  ' CAPTURING:' OPNCPT(JNM) ' APT#' OPNAPT(JNM)
         JNM = LINK(JNM)     :(DMTR2)
-STITL THE INITIALIZATION SECTION

INITIAL  BLKCHR = 'BK' × 'B'
         WHTCHR = 'WK' × 'W'
         BOARD = 'BOARD'
         MINLVL = 3
         MAXLVL = 12
         LVLIMT = MAXLVL
         BLKMAN = 'B'
         WHTMAN = 'W'
*        HOME ROWS USED FOR DEFINING KINGS.
         BLKHOM = (' 1' × ' 2' × ' 3' × ' 4') RPOS(0)
         WHTHOM = ('32' × '33' × '34' × '35') RPOS(0)
*        DIRECTION TABLES <BLKDIR & WHTDIR> ARE USED TO DEFINE THE
*        DIRECTION A MAN MAY MOVE ON THE BOARD.
         BLKDIR1 =  5
         BLKDIR2 =  4
         BLKDIR3 = -4
         BLKDIR4 = -5
         I =
INITDIR  I = LT(I,4) I + 1   :F(SETUP)
         $('WHTDIR' I) = $('BLKDIR' (5 - I))   :S(INITDIR)
*
*     INTRODUCTION
*
SETUP    OUTPUT = TENSP 'WELCOME TO A GAME OF CHECKERS.'
         OUTPUT = TENSP 'DO YOU WISH TO SEE MY INSTRUCTIONS(YES/NO)?'
         INMOV 'YES'     :F(ASKNOT)
*
*        TEXT OUTPUT FOR INSTRUCTIONS OF USE.
*
         OUTPUT = TENSP 'RIGHT NOW I MUST APOLOGIZE '
+                  'FOR MY POOR PLAY.  '
         OUTPUT = TENSP 'I HOPE TO IMPROVE.'
         OUTPUT = TENSP 'PLEASE SPECIFY YOUR MOVES IN '
+                  "THE FOLLOWING FORMAT :  "
         OUTPUT = TENSP TENSP "'FMLOC  TOLOC'  "
         OUTPUT = TENSP 'FMLOC IS THE LOCATION OF THE MAN TO BE '
+                  'MOVED.'
         OUTPUT = TENSP 'TOLOC IS THE FINAL LOCATION THE '
+                  'MAN IS TO BE MOVED TO.'
         OUTPUT = TENSP 'IF YOU ATTEMPT TO MAKE THREE(3) '
+             'INVALID MOVES, '
         OUTPUT = TENSP 'YOU WILL LOSE YOUR TURN.'
         OUTPUT = TENSP 'THE MACHINE CANNOT RECONGIZE DRAWN GAMES.'
         OUTPUT = TENSP 'IN THESE SITUATIONS, YOU MUST TERMINATE'
+                  ' THE GAME BY '
         OUTPUT = TENSP "SPECIFYING YOUR MOVE AS 'DRAW'."
         OUTPUT = TENSP 'YOU MAY ALSO REQUEST SEVERAL AIDS FOR MAKING '
+                  'YOUR MOVE.'
         OUTPUT = TENSP "'DISPLAY' WILL PROVIDE A DISPLAY OF THE "
+                  'CURRENT BOARD STATE.'
         OUTPUT = TENSP "'RECAP' WILL PROVIDE A LIST OF ALL MOVES"
+                  ' THAT HAVE BEEN '
         OUTPUT = TENSP TENSP 'MADE IN THE GAME.'
         OUTPUT = TENSP "'ASST' WILL PROVIDE A LIST OF ALL LEGAL "
+                  'MOVES THAT YOU'
         OUTPUT = TENSP TENSP 'MAY MAKE AT THIS TIME.'
         OUTPUT = TENSP 'DO YOU WISH INSTRUCTIONS FOR MID-'
+                  'GAME SITUATIONS(YES/NO)?'
         INMOV 'YES'     :F(ASKNOT)
         OUTPUT = TENSP 'MID-GAME SITUATIONS MAY BE SPECIFIED WHEN'
+                  ' THE INITIAL '
         OUTPUT = TENSP 'GAME STATE IS REQUESTED.'
         OUTPUT = TENSP 'FOR BEGIN GAME, HIT THE CARRAIGE RETURN'
+                  'AT THIS TIME.'
         OUTPUT = TENSP 'OTHERWISE TYPE IN THE ORDER OF PLAY, USING'
         OUTPUT = TENSP "'BLK' FOR BLACK AND 'WHT' FOR WHITE."
         OUTPUT = TENSP 'FROM THEN ON, COMMANDS WILL BE REQUESTED WITH '
+                  "'?'."
         OUTPUT = TENSP 'COMMANDS ARE:'
         OUTPUT = TENSP "'E/' TO END STATE DEFINITION."
         OUTPUT = TENSP "'B/' SHOULD YOU WANT BEGIN STATE AFTERALL."
         OUTPUT = TENSP "'DISPLAY' REQUESTS A DISPLAY OF THE BOARD."
         OUTPUT = TENSP 'THE LOCATIONS OF THE PIECES ARE SPECIFIED'
+                  ' AS FOLLOWS:'
         OUTPUT = TENSP TENSP "'MAN LOC KING'"
+                  TENSP 'WHERE:'
         OUTPUT = TENSP "'MAN' IS THE PLAYER ('BLK'/'WHT')."
         OUTPUT = TENSP "'LOC' IS THE NUMBER OF THE SQUARE HE IS ON."
         OUTPUT = TENSP "'KING' MAY BE ANY NON-BLANK CHAR. IF "
+                  'THE MAN IS A KING.'
         OUTPUT = TENSP 'ONCE A MAN HAS BEEN PLACED ON THE BOARD,'
+                  ' HE MAY NOT BE REMOVED '
         OUTPUT = TENSP 'W/O RESTARTING THE GAME.'
ASKNOT   RCPHEAD =
         CURRCPE =
         MOVCNTR =
         OUTPUT = TENSP 'WILL YOU USE STANDARD NOTATION(YES/NO)?'
*        SET THE INPUT MODE.
         KSTD = 1
         CARD = INMOV
         CARD 'YES'     :S(PLY1)
         KSTD =
         OUTPUT = TENSP "SAMUEL'S NOTATION WILL BE USED."
PLY1     DUMMY = DIFFER(KSTD) TABGEN()
*        SET-UP THE TRANSLATE TABLES FOR STD-SAM
PLAY     INITDATA()
*        OBTAIN THE INITIAL CONDITIONS FOR THE GAME.
         OUTPUT = TENSP 'DO YOU WISH TO PLAY FIRST(YES/NO/SOLVE)?'
*        SET THE ORDER OF PLAY (CMPTR/HUMAN).
         FRIEND = OPPONENT
         CARD = INMOV
         CARD 'YES'     :S(BEGIN2)
         FRIEND = PLAYER
         CARD 'SOLVE'     :S(PRBSOLVE)
*
*    THIS SECTION THE CMPTR PLAYS FIRST
BEGIN    OUTPUT = TENSP TENSP 'TIME= ' TIME() ' MSEC.'
         OUTPUT = TENSP
         RESET()
         GENMOV(PLAYER,OPPONENT,,TREETOP)  :F(ENDRCP)
         OUTPUT = TENSP TENSP 'TIME= ' TIME() ' MSEC.'
         OUTPUT = TENSP
         RESET()
         DATAMOV(OPPONENT,PLAYER)   :F(ENDRCP) S(BEGIN)
*
*    THIS SECTION THE PLAYER PLAYS FIRST
BEGIN2   OUTPUT = TENSP TENSP 'TIME= ' TIME() ' MSEC.'
         OUTPUT = TENSP
         RESET()
         DATAMOV(PLAYER,OPPONENT)   :F(ENDRCP)
         OUTPUT = TENSP TENSP 'TIME= ' TIME() ' MSEC.'
         OUTPUT = TENSP
         RESET()
         GENMOV(OPPONENT,PLAYER,,TREETOP)  :F(ENDRCP) S(BEGIN2)
*
*    THIS SECTION THE CMPTR SOLVES PROBLEMS BY PLAYING BOTH SIDES
PRBSOLVE RESET()
         OUTPUT = TENSP TENSP 'TIME= ' TIME() ' MSEC.'
         FRIEND = PLAYER
         GENMOV(PLAYER,OPPONENT,,TREETOP)    :F(ENDRCP)
         RESET()
         OUTPUT = TENSP TENSP 'TIME= ' TIME() ' MSEC.'
         FRIEND = OPPONENT
         GENMOV(OPPONENT,PLAYER,,TREETOP)    :S(PRBSOLVE) F(ENDRCP)
*
ENDRCP   OUTPUT = TENSP 'DO YOU WANT TO SEE A RECAP '
+             '& FINAL BOARD STATE(YES/NO)?'
         INMOV 'YES'     :F(NEWGME)
         RECAPPNT()
         DISPLAY()
NEWGME   OUTPUT = TENSP 'DO YOU WANT TO PLAY AGAIN(YES/NO)?'
         INMOV 'YES'     :S(ASKNOT)
END


