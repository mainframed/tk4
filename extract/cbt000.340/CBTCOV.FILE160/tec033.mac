// EXEC FORTGC,PARM.FORT='MAP'
//FORT.SYSIN DD *
      INTEGER KMV/0/,K1MV/'NO'/,YES/'YES'/
      INTEGER A1/'WPLC'/,WPLC/0/,A2/'WSCR'/,WSCR/0/
      INTEGER A3/'BPLC'/,BPLC/0/,A4/'BSCR'/,BSCR/0/
      INTEGER A5/'USED'/,USED/0/,A6/'MOVE'/,MOVE/0/,A7/'MSCR'/,MVSCR/0/
C          THIS INITIAL STATE FOR USED SETS THE FIRST BIT
C          BEYOND THE VALID MOVES TO '1', SO THAT THE
C          FIRST MOVE MADE BY THE PLAYER IS VALID.
      USED=134217728
C        THIS MAIN ROUTINE COORDINATES THE VARIOUS ROUTINES INVOLVED TO
C        PLAY A GAME OF REX.  THE GAME IS A VERSION OF 3-D TIC-TAC-TOE.
C        THERE ARE THREE RADIAL ARMS, EACH HAVING THREE POST, EACH OF
C        ATICH MAY HOLD THREE BEADS ON SEPERATE LEVELS.  PLAYERS ALTER-
C        NATE PLACING BEADS ON THE POSTS, WHITE MOVING FIRST HAVING ONE
C        MORE BEAD THAN BLACK, TRYING TO EITHER SCORE POINTS, OR BLOCK
C        THEIR OPPONENT FROM SCORING POINTS.  EACH ARM IS TREATED AS A
C        SEPERATE TIC-TAC-TOE BOARD, SCORING POINTS FOR EACH VERTICAL,
C        HORIZONTAL, OR DIAGONAL COMBINATION OF BEADS.  IN ADDITION,
C        POINTS MAY BE SCORED BY FORMING A CIRCLE WITH ONE BEAD ON EACH
C        ARM AT THE SAME LEVEL & POST, OR A HELIX, WITH ONE BEAD ON EACH
C        ARM, ON EACH LEVEL,ON THE SAME POST.
C        THE PLAYER WILL BE ASKED IF HE DESIRES DIRECTIONS ON HOW TO
C        PLAY THE GAME.  IF SO, PNTDIR WILL BE CALLED.
C        THE PLAYER WILL THEN BE ASKED IF HE DESIRES TO MOVE FIRST.  IF
C        SO, HE WILL BE ASKED FOR HIS MOVE, USING PLRMV, AND THE GAME WI
C        SO, HE WILL BE ASKED FOR HIS MOVE, USING PLRMV, AND THE GAME
C        WILL PROCEED.  IF NOT, THE COMPUTER WILL MAKE THE FIRST MOVE
C        WILL PROCEED.  IF NOT, THE COMPUTER WILL MAKE THE FIRST MOVE
C        WITH FNDMV AND THE MOVE WILL BE PRINTED WITH PNTCMV.
      CALL ERRSET(215,-1,1,1)
      WRITE(06,1000)
 1000 FORMAT('1     THIS IS A GAME OF REX'/'0 DO YOU WISH TO SEE'
     1,' THE DIRECTIONS? (YES OR NO)')
      READ(05,1005) KDIR
      IF(KDIR .EQ. YES) CALL PNTDIR
      WRITE(06,1006)
 1006 FORMAT('0     DO YOU WISH TO MOVE FIRST? (YES OR NO)')
      READ(05,1005) K1MV
 1005 FORMAT(A4)
      IF(K1MV.EQ.YES) GOTO 20
C        THIS SECTION IS FOR THE COMPUTER MOVING FIRST.
      KMV=0
      WRITE(06,1016)
 1016 FORMAT('0 THE COMPUTER WILL MOVE FIRST.'/
     1'   IT WILL MOVE WITH THE WHITE(0) PIECES'/
     2'   YOU WILL USE THE BLACK(*) PIECES.')
      CALL FNDMV(MOVE,WPLC,USED,WSCR,MVSCR)
      CALL PNTCMV(MOVE)
      WRITE(06,4006) MVSCR
      DO 11 I=1,13
      CALL PLRMV(MOVE,BPLC,BSCR,USED,WPLC,WSCR,MVSCR,KMV)
      WRITE(06,4006) MVSCR
      CALL FNDMV(MOVE,WPLC,USED,WSCR,MVSCR)
      CALL PNTCMV(MOVE)
      WRITE(06,4006) MVSCR
   11 CONTINUE
      GOTO 30
   20 KMV=1
C        THIS SECTION IS FOR THE PLAYER MOVING FIRST.
      WRITE(06,2016)
 2016 FORMAT('0  YOU WILL MOVE FIRST.'/
     1'   YOU WILL USE THE WHITE(0) PIECES'/
     2'  THE COMPUTER WILL USE THE BLACK(*) PIECES')
      CALL PLRMV(MOVE,WPLC,WSCR,USED,BPLC,BSCR,MVSCR,KMV)
      WRITE(06,4006) MVSCR
      DO 21 I=1,13
      CALL FNDMV(MOVE,BPLC,USED,BSCR,MVSCR)
      CALL PNTCMV(MOVE)
      WRITE(06,4006) MVSCR
      CALL PLRMV(MOVE,WPLC,WSCR,USED,BPLC,BSCR,MVSCR,KMV)
      WRITE(06,4006) MVSCR
   21 CONTINUE
   30 WRITE(06,3006)
 3006 FORMAT('0  GAME FINISHED'//)
      CALL DSPLAY(WPLC,WSCR,BPLC,BSCR)
      IF(WSCR-BSCR) 31,32,33
   31 WRITE(06,3016)
 3016 FORMAT(' BLACK WINS. ')
      GOTO 40
   32 WRITE(06,3026)
 3026 FORMAT(' GAME TIED.  ')
      GOTO 40
   33 WRITE(06,3036)
 3036 FORMAT(' WHITE WINS. ')
 4006 FORMAT('   POINTS GAINED BY THIS MOVE=',I4)
   40 STOP
      END
// EXEC ASMGC
//ASM.SYSIN DD *
FNDMV    CSECT
*              THIS ROUTINE IS USED TO OBTAIN A MOVE IN THE GAME
*              OF 'REX'.  IT RETURNS THAT MOVE WHICH WILL YEILD
*              THE HIGHEST POSSIBLE SCORE FOR THAT MOVE.  IF NO MOVE
*              WILL IMPROVE THE SCORE OF THE PLAYER, IT WILL RETURN
*              THE LOWEST LEVEL MOVE.
*              ARGUMENTS ARE:
*              1) THE MOVE TO BE MADE
*              2)  THE PLAYER'S PRESENT STATE
*              3) THE GAMES PRESENT STATE
*              4) THE PLAYER'S PRESENT SCORE
*              5) THE POINTS GAINED BY THIS MOVE
*              UPON RETURN, BOTH THE PLAYER'S AND THE GAMES STATES
*              WILL HAVE BEEN UPDATED TO INCLUDE THE MOVE RETURNED
         REGISTER                 * EQUATES REGISTERS W/R#
         ENTRY POSIT              * THIS SETS UP THE ADDR OF POSIT
         B     12(0,R15)          * BRANCH AROUND NAME
         DC    X'07'              * DEFINE LENGTH OF NAME FIELD
         DC    CL7'FNDMV'
         STM   R14,R12,12(R13)    * PRESERVES HIGHER REGISTERS
         LR    R12,R15
         USING FNDMV,R12
         LR    R15,R13            * RETAIN ADDR OF HIGHER SAVE AREA
         LA    R13,SVAREA         * LOAD ADDR OF LOCAL SAVE AREA
         ST    R13,8(R15)         * STORE ADDR OF LOCAL SAVE AREA
         ST    R15,4(R13)         * STORE ADDR OF HIGHER SAVE AREA
         ST    R1,ARGADR          * STORE ADDR OF ARGUMENT LIST
         LM    R2,R4,4(R1)        * OBTAIN ADDR OF ARGUMENTS
         L     R5,0(R2)           * LOAD PLAYER'S PAST MOVES(STATE)
         L     R6,0(R3)           * LOAD GAME STATE
         L     R7,0(R4)           * LOAD PLAYER'S PRESENT SCORE
         CL    R6,MVONE           * CHECK IF THIS IS THE FIRST MOVE
*                                   MOVE OF THE GAME.
         BE    ST1MV              * IF SO, SKIP ALL MOVE CHECKS
         L     R10,=F'4'          * SET LOOP INCREMENT
         L     R11,=F'104'        * SET LOOP LIMIT
         MVI   PMV,X'00'          * ZERO FIRST BYTE OF PMV
         MVC   PMV+1,PMV          * ZERO OUT PMV
         MVI   PMVSK,X'00'        * ZERO FIRST BYTE OF PMVSK
         MVC   PMVSK+1,PMVSK      * ZERO OUT PMVSK
         SR    R9,R9              * INITALIZE LOOP COUNTER
IFDMV    L     R8,POSIT(R9)       * LOAD A MOVE
         L     R6,0(R3)            * RELOAD GAME STATE INTO R6
         NR    R8,R6              * CHECK IF MOVE HAS BEEN MADE
         BNZ   EFDMV              * BRACH IF IT HAS
         N     R6,POSIT-36(R9)    * CHECK IF POSITION BELOW MOVE HAS
*                                 BEEN FILLED.
         BZ    EFDMV              * BRANCH IF IT HAS NOT
         MVC   TMPPLR,0(R2)       * PLACES PLAYER'S STATE IN DUMMY
         MVC   TMPUSD,0(R3)       * PLACES GAME STATE IN DUMMY
         LA    R8,POSIT(R9)       * LOAD ADDR OF MOVE
         ST    R8,TMPMV           * PLACE ADDR OF MOVE IN DUMMY
         ST    R7,TMPSKR          * PLACE PLAYER'S SCORE IN DUMMY
         LA    R1,=A(TMPMV,TMPPLR,TMPUSD,TMPSKR,TMPMSK)
*                                 LOAD ADDRESS OF ARGUMENT LIST
*                                 FOR SUBROUTINE SCORE
         L     R15,ASCORE         * LOAD ADDR OF ROUTINE SCORE
         BALR  R14,R15            * BRANCH TO ROUTINE SCORE
         ST    R8,PMV(R9)         * STORE ADDR OF MOVE
         L     R8,TMPMSK          * LOAD POINTS GAINED BY THIS MOVE
         ST    R8,PMVSK(R9)       * STORE THE POINTS GAINED BY THIS MO
EFDMV    BXLE  R9,R10,IFDMV       * LOOK FOR ANOTHER MOVE
         L     R1,ARGADR          * RESTORE ADDR OF ARGUMENT LIST
         SR    R9,R9              * CLEAR LOOP COUNTER
         L     R6,DMSK            * LOAD DUMMY SCORE OF 0
IFMAX    CL    R6,PMVSK(R9)       * COMPARE SCORE W/PREVIOUS MAX.
         BNL   EFMAX              * BRANCH IF PAST IS GREATER
         L     R6,PMVSK(R9)       * STORE NEW MAX
         LR    R5,R9              * STORE INDEX OF NEW MAX
EFMAX    BXLE  R9,R10,IFMAX
         CL    R6,DMSK            * BE SURE THAT MAX > 0
         BNE   MVFND              * IF MAX>0, THEN THE MOVE HAS BEEN
*                                 FOUND, IF NOT, THEN FIND FIR
*                                 FOUND,  IF NOT, THEN FIND THE LOWEST
*                                 MOVE AVALIBLE
         SR    R9,R9              * RESET LOOP COUNTER
         SR    R5,R5              * BESURE NO MOVE HAS BEEN FOUND
FLMV     C     R5,PMV(R9)         * FOND THE FIRST MOVE MADE
         BNE   LOWMV              * BRANCH IF MOVE IS FOUND
         BXLE  R9,R10,FLMV        * CONTINUE TO LOOK IF NOT FOUND
LOWMV    LR    R5,R9              * STORE LOWEST MOVE ADDR
MVFND    L     R7,PMV(R5)         * LOAD ADDR OF MOVE
         L     R8,0(R1)           * LOAD ADDR OF MOVE
         ST    R7,0(R8)           * STORE MOVE MADE IN MOVE
         OC    0(4,R2),0(R7)      * PLACE MOVE IN PLAYER'S STATE
         OC    0(4,R3),0(R7)      * PLACE MOVE IN GAME STATE
         L     R7,16(R1)          * LOAD ADDR OF MVSCORE
         L     R8,PMVSK(R5)       * LOAD MVSCORE
         ST    R8,0(R7)           * STORE MOVE SCORE IN MVSCORE
         L     R6,0(R4)           * LOAD PLAYER'S OLD SCORE
         AR    R6,R8              * COMPUTE PLAYERS NEW SCORE
         ST    R6,0(R4)           * STORE PLAYWR'S NEW SCORE
RTN      L     R13,SVAREA+4       * LOAD ADDR OF HIGHER SAVE AREA
         LM    R14,R12,12(R13)    * SESTORE REGISTERS
         BR    R14                * RETURN
ST1MV    LA    R10,POSIT          * LOAD ADDR OF FIRST MOVE
         L     R9,0(R1)           * LOAD ADDR OF MOVE
         ST    R10,0(R9)          * STORE ADDR OF MOVE IN MOVE
         MVC   0(4,R2),0(R10)     * STORE MOVE IN PLAYER'S STATE
         MVC   0(4,R3),0(R10)     * STORE MOVE IN USED OR GAME STATE
         B     RTN                * RETURN TO RETURN SECTION
SVAREA   DC    9D'0'
ARGADR   DS    F                  * STORAGE FOR ADDR OF ARGUMENT LIST
TMPPLR   DC    F'0'               * DUMMY PLAYER'S STATE
TMPUSD   DC    F'0'               * DUMMY PAME STATE
TMPMV    DC    F'0'               * DUMMY MOVE ADDR
TMPSKR   DC    F'0'               * DUMMY PLAYER'S SCORE
TMPMSK   DC    F'0'               * DUMMY MOVE SCORE
DMSK     DC    F'0'               * DUMMY SCORE
PMV      DC    XL108'00'          * MOVE ADDR FOR POSSIBLE MOVES
PMVSK    DC    XL108'00'          * SCORES FOR POSSIBLE MOVES
BOTTOM   DC    10XL4'FFFFFFF'     * FILLED FIELD FOR BOTTOM OF BOARD
POSIT    DS    0F                 * POSSIBLE PLAYING POSITIONS
*                                 EACH FULL WORD CONTAINS ONE POSSIBLE
*                                 POSITION. ONE BIT IN EACH WORD IS
*                                 TURNED ON TO INDICATE THE POSITION
*                                 BEING PLAYED.
L1P1A1   DC    XL4'4000000'
L1P1A2   DC    XL4'2000000'
L1P1A3   DC    XL4'1000000'
L1P2A1   DC    XL4'800000'
L1P2A2   DC    XL4'400000'
L1P2A3   DC    XL4'200000'
L1P3A1   DC    XL4'100000'
L1P3A2   DC    XL4'80000'
L1P3A3   DC    XL4'40000'
L2P1A1   DC    XL4'20000'
L2P1A2   DC    XL4'10000'
L2P1A3   DC    XL4'8000'
L2P2A1   DC    XL4'4000'
L2P2A2   DC    XL4'2000'
L2P2A3   DC    XL4'1000'
L2P3A1   DC    XL4'800'
L2P3A2   DC    XL4'400'
L2P3A3   DC    XL4'200'
L3P1A1   DC    XL4'100'
L3P1A2   DC    XL4'80'
L3P1A3   DC    XL4'40'
L3P2A1   DC    XL4'20'
L3P2A2   DC    XL4'10'
L3P2A3   DC    XL4'8'
L3P3A1   DC    XL4'4'
L3P3A2   DC    XL4'2'
L3P3A3   DC    XL4'1'
MVONE    DC    XL8'8000000'       * MASK FOR THE FIRST MOVE
ASCORE   DC    V(SCORE)
         LTORG
         END   FNDMV
// EXEC ASMGC
//ASM.SYSIN DD *
SCORE    CSECT
*
*              THIS ROUTINE IS USED TO OBTAIN THE PRESENT SCORE OF A
*              PLAYER IN A GAME OF REX.  IT RETURNS THE PLAYERS
*              PRESENT SCORE AND THE NUMBER OF POINTS GAINED ON THIS
*              MOVE.  ARGUMENTS ARE:
*              1)  THE ADDRESS OF THE CURRENT MOVE
*              2)  ALL OF THE PLAYER'S PAST MOVES(PLAYER'S STATE)
*              3)  ALL OF THE GAMES PAST MOVES(GAME STATE).
*              4)  THE PLAYER'S PRESENT SCORE
*              5)  THE NUMBER OF POINTS GAINED BY THIS MOVE
*
         REGISTER                 EQUATE REGISTERS
         B     12(0,R15)          * BRANCH AROUND NAME
         DC    X'07'              * DEFINE LENGTH OF NAME FIELD
         DC    CL7'SCORE'
         STM   R14,R12,12(R13)    * PRESERVE HIGHER REGISTERS
         LR    R12,R15
         USING SCORE,R12
         LR    R15,R13            * RETAIN ADDR OF HIGHER SAVE AREA
         LA    R13,SVAREA         * LOAD ADDR OF LOCAL SAVE AREA
         ST    R13,8(R15)         * STORE ADDR OF LOCAL SVAREA
*                                 IN HIGHER SAVE AREA.
         ST    R15,4(R13)         * STORE ADDR OF HIGHER SVAREA
*                                 IN LOCAL SAVE AREA.
         ST    R1,ARGADR          * STORE ADDR OF ARGUMENT LIST
         OPEN  (PRINTER,OUTPUT)   * OPEN THE SYSOUT FILE
         L     R1,ARGADR          * RESTORE ARGUMENT ADDRESS REGISTER
         LM    R2,R4,0(R1)        * LOAD ADDR OF MOVE,PSTMV,&USED
         L     R5,0(R2)           * LOAD ACTUAL ADDR OF MOVE INTO REG5
         L     R7,0(R5)           * LOAD MOVE INTO R7
         L     R8,0(R4)           * LOAD ALL PAST MOVES (USED)
         NR    R7,R8              * CHECK IF MOVE HASS BEEN MADE
         BNZ   INVL1              * ERROR MGS1
         LR    R6,R5              * LOAD ADDR OF MOVE IN REG#6
         S     R6,=F'36'          * CHANGE ADDR TO LOWER LEVEL
         N     R8,0(R6)           * CHECK IF POSITION ON LOWER LEVEL
*                                   HAS BEEN FILLED.
         BZ    INVL2              * ERROR MSG2
         L     R7,0(R5)           * RELOAD MOVE
         L     R8,0(R4)           * RELOAD USED
         OR    R8,R7              * PLACE MOVE IN USED
         ST    R8,0(R4)           * STORE MOVE IN USED
         L     R8,0(R3)           * LOAD PLAYER'S PAST MOVES(PSTMV)
         OR    R8,R7              * FIND PLAYER'S NEW STATE
         ST    R8,0(R3)           * STORE PLAYER'S NEW STATE
         SR    R9,R9              * INITIALIZE LOOP PARAMETER
         SR    R6,R6              * INITIALIZE SCORE COUNTER
         L     R11,=F'200'        * SET LOOP LIMIT
         L     R10,=F'4'          * SET LOOP INCRAMENT
         LR    R7,R8              * STORE STATE FOR RESETTING
ICHSKR   N     R8,PSCORE(R9)      'AND' STATE WITH MASK
         CL    R8,PSCORE(R9)      * COMPARE RESULT W/ MASK
         LR    R8,R7              * RESET NEW STATE
         BNE   ECHSKR             * IF ^=, CHECK AGAINST THE NEXT COMB
         LA    R6,1(R6)           * INCREMENT SCORE
ECHSKR   BXLE  R9,R10,ICHSKR      * CHECK AGAINST ALL MASKS
*                                 CHECK THE PRESENT STATE AGAINST
*                                 MASK OF ALL POSSIBLE SCORENG
*                                 COMBINATIONS.  THSE MASKS BEGIN AT
*                                 PSCORE
         LM    R2,R3,12(R1)       * LOAD ADDR OF PSCORE & MSCORE
         L     R5,0(R2)           * LOAD PLAYER'S PAST SCORE
         ST    R6,0(R2)           * STORE PLAYER'S NEW SCORE
         SR    R6,R5              * COMPUTE PTS FOR THIS MOVE
         ST    R6,0(R3)           * STORE MSCORE
         B     RTN                * BRANCH TO RETURN RECTION
INVL1    MVC   PRTLN,BLANK        * BLANK OUT PRINT LINE
         MVC   PRTLN(32),MSG1     * LOAD ERROR MSG1
         B     INVLMV             * BRANCH TO MOVE ERROR SECTION
INVL2    MVC   PRTLN,BLANK        * BLANK OUT PRINT LINE
         MVC   PRTLN(64),MSG2     * LOAD ERROR MSG2
INVLMV   PUT   PRINTER,PRTLN      * PRINT ERROR MSG
         SR    R7,R7              * RTN BLANK MOVE IF INVALID
         ST    R7,0(R2)           * STORE BLANK MOVE
RTN      CLOSE (PRINTER)          * CLOSE SYSOUT FILE
         L     R13,SVAREA+4       * LOAD ADDR OF HIGHER SAVE AREA
         LM    R14,R12,12(R13)    * RESTORE REGISTER TO ENTRY STATE
         BR    R14                * RETURN TO CALLING ROUTINE
SVAREA   DC    9D'0'              * DEFINE SAVE AREA
ARGADR   DS    F                  * STORAGE FOR ADDR OF ARGUMENT LIST
PSCORE   DS    0F                 * ALL POSSIBLE SCORING COMBINATIONS
*                                 EACH MASK CONTAINS THREE(3) BITS
*                                 'ON'. EACH COMBINATION IS WORTH
*                                 ONE(1) POINT.
*                                 : VERTICAL SCORES
P1A1AL   DC    XL4'4020100'
P1A2AL   DC    XL4'2010080'
P1A3AL   DC    XL4'1008040'
P2A1AL   DC    XL4'804020'
P2A2AL   DC    XL4'402010'
P2A3AL   DC    XL4'201008'
P3A1AL   DC    XL4'100804'
P3A2AL   DC    XL4'80402'
P3A3AL   DC    XL4'40201'
*                                 : DIAGONAL SCORES
DA1OT    DC    XL4'4004004'
DA2OT    DC    XL4'2002002'
DA3OT    DC    XL4'1001001'
DA1IT    DC    XL4'104100'
DA2IT    DC    XL4'82080'
DA3IT    DC    XL4'41040'
*                                 : CIRCULAR SCORES
L1P1AA   DC    XL4'7000000'
L1P2AA   DC    XL4'E00000'
L1P3AA   DC    XL4'1C0000'
L2P1AA   DC    XL4'38000'
L2P2AA   DC    XL4'7000'
L2P3AA   DC    XL4'E00'
L3P1AA   DC    XL4'1C0'
L3P2AA   DC    XL4'38'
L3P3AA   DC    XL4'7'
*                                 : HORIZONTAL SCORES
L1A1AP   DC    XL4'4900000'
L1A2AP   DC    XL4'2480000'
L1A3AP   DC    XL4'1240000'
L2A1AP   DC    XL4'24800'
L2A2AP   DC    XL4'12400'
L2A3AP   DC    XL4'9200'
L3A1AP   DC    XL4'124'
L3A2AP   DC    XL4'92'
L3A3AP   DC    XL4'49'
*                                 : HELICAL SCORES
SP1A1R   DC    XL4'4010040'
SP1A1L   DC    XL4'4008080'
SP1A2L   DC    XL4'2020040'
SP1A2R   DC    XL4'2008100'
SP1A3R   DC    XL4'1020080'
SP1A3L   DC    XL4'1010100'
SP2A1R   DC    XL4'802008'
SP2A1L   DC    XL4'801010'
SP2A2L   DC    XL4'404008'
SP2A2R   DC    XL4'401020'
SP2A3R   DC    XL4'204010'
SP2A3L   DC    XL4'202020'
SP3A1R   DC    XL4'100401'
SP3A1L   DC    XL4'100202'
SP3A2L   DC    XL4'80801'
SP3A2R   DC    XL4'80204'
SP3A3R   DC    XL4'40802'
SP3A3L   DC    XL4'40404'
MSG1     DC    CL32'0  * MOVE HAS ALREADY BEEN MADE.'
MSG2     DC    CL64'0  * MOVE CANNOT BE MADE UNTIL POSITION BELOW IT HA+
               S BEEN FILLED.'
BLANK    DC    CL70' '            * BLANKING FIELD FOR PRINTLINE
PRTLN    DC    CL70' '            * PRINT LINE
*                                 DEFINE DCB PARM FOR PRINTER
*                                 USE LRECL=70 FOR TSO TERMINAL
PRINTER  DCB   DDNAME=FT06F001,DSORG=PS,RECFM=FA,LRECL=70,             +
               BLKSIZE=70,MACRF=(PM)
         LTORG
         END   SCORE
// EXEC ASMGC
//ASM.SYSIN DD *
FSCORE   CSECT
*        THIS ROUTINE IS USED TO:
*             1)  CHECK THE VALIDITY OF A PLAYER'S MOVE.
*             2)  PLACE THE PLAYER'S MAVE IN THE APPROPRIATE VARIABLES.
*             3)  SCORE THE PLAYER'S MOVE USING <SCORE>.
*        THESE DUMMY ARGUMENTS WILL BE USED FOR <SCORE> TO INSURE THAT
*        THE PLAYER'S MAVE IS VALID BEFORE THE MOVE IS ADDED TO HIS
*        FILLED MOVES AND THE USED FILE.
*        THIS ROUTINE IS USED TO OBTAIN THE ABSOLUTE ADDRESS OF THE
*        BEGINNING OF THE POSSIBLE POSITION MASKS CONTAINED WITHIN
*        <FNDMVS SO THAT PROPER DISPLACEMENT OF THE COMPUTER'S MOVE
*        MAY BE CALCULATED FOR INTERPRETATION BY <PNTCMV>.
         REGISTER
         B     12(R15)
         DC    X'07'              * DEFINE LENGTH OF NAME FIELD
         DC    CL7'FSCORE'
         STM   R14,R12,12(R13)
         LR    R12,R15
         USING FSCORE,R12
         LR    R15,R13
         LA    R13,SVAREA
         ST    R15,SVAREA+4
         ST    R13,8(R15)
         ST    R1,ARGADR
         LM    R2,R6,0(R1)
         L     R11,=V(POSIT)
         A     R11,0(R2)          * OBTAIN TRUE ADDR. OF MOVE
         ST    R11,MOV
         MVC   PST,0(R3)
         MVC   USD,0(R4)
         MVC   SCR,0(R5)
         SR    R7,R7
         LA    R1,=A(MOV,PST,USD,SCR,MSCR)
         L     R15,=V(SCORE)
         BALR  R14,R15
         MVC   0(4,R2),MOV        * REPLACE ARGMTS W/NEW VALUES
         CL    R7,MOV             * CHECK IF MOVE WAS VALID
         BE    RTN                * IF NOT; RETURN W/O CHANGES IN
*                                   OTHER ARGUMENTS
         MVC   0(4,R3),PST
         MVC   0(4,R4),USD
         MVC   0(4,R5),SCR
         MVC   0(4,R6),MSCR
RTN      L     R13,SVAREA+4
         LM    R14,R12,12(R13)
         BR    R14
SVAREA   DC    9D'0'              * DEFINE SAVE AREA
ARGADR   DC    F'0'
MOV      DS    F
USD      DS    F
PST      DS    F
SCR      DS    F
MSCR     DS    F
         LTORG
         END   FSCORE
// EXEC ASMFC
//ASM.SYSIN DD *
DSPLAY   CSECT
*              THIS ROUTINE WILL CAUSE A PRINTOUT OF THE CURRENT
*              GAME STATE AND PLAYER'S CURRENT SCORE.
*              THE CURRENT STATE WILL BE DISPLAYED AS A 3-D FIGURE,
*              WHITE'S MOVES SHOWING AS A '0', AND BLACK'S MOVES AS '*'
*              POSITIONS STILL OPEN FOR MOCES WILL BE SHOWN AS '×'
*              THERE ARE 4 ARGUMENTS:
*              1)  WHITE'S CURRENT STATE
*              2)  WHITE'S CURRENT SCORE
*              3)  BLACK'S CURRENT STATE
*              4)  BLACK'S CURRENT SCORE
*              NO CHANGES WILL BE MODE IN ANY OF THESE ARGUMENTS.
         REGISTER                 * EQUATE REGISTERS FOR R# FORMAT
         B     12(R15)            * BRANCH AROUND NAME FIELD
         DC    X'07'              * DEFINE LENGTH OF NAME FIELD
         DC    CL7'DSPLAY'
         STM   R14,R12,12(R13)    * STORE REG. IN HIGHER SVAREA
         LR    R12,R15            * SET BASE REG.
         USING DSPLAY,R12         * ESTABLISH ADDRESSABILITY
         LR    R11,R13            * RETAIN ADDR. OF HI SVAREA
         LA    R13,SVAREA         * OBTAIN ADDR. OF LOCAL SVAREA
         ST    R13,8(R11)         * LINK LOCAL TO HI SVAREA
         ST    R11,4(R13)         * LINK HI TO LOCAL SVAREA
         ST    R1,ARGADR          * RETAIN AGRUMENT LIST ADRR.
         L     R2,0(R1)           OBTAIN ADDR. OF WHIT'S STATE
         L     R3,8(R1)           * OBTAIN ADDR OF BLACK'S STATE
         IC    R4,WPCHR           * LOAD WHITE'S PRINT CHR.
         IC    R5,BPCHR           * LOAD BLACK'S PRINT CHR.
         L     R10,=F'4'          * SET LOOP INCREMENT
         L     R11,=F'104'        * SET LOOP LIMIT
         SR    R9,R9              * INITIALIZE LOOP COUNTER
BCHKLP   L     R6,0(R2)           * OBTAIN WHITYE'S CURRENT STATE
         L     R8,PLTDSP(R9)      * LOAD PRINTER DISP. OF CURRENT POSIT
CHKWHT   N     R6,POSIT(R9)       * CHECK IF WHITE HAS MADE THIS MOVE
         BZ    CHKBLK             * IF NOT CHECK FOR BLACK
         STC   R4,PRTAR(R8)       * IF SO PLACE WHITE'S PRCHR IN MOVE
         B     ELOOP              * CHECK NEXT POSSIBLE MOVE
CHKBLK   L     R7,0(R3)           * LOAD BLACK'S CURRENT STATE
         N     R7,POSIT(R9)       * CHECK IF BLACK HAS MADE THIS MOVE
         BZ    ELOOP              * IF NOT, GO TO NOXT MOVE
         STC   R5,PRTAR(R8)       * IF SO, STORE BLACK'S PRTCHR IN MOVE
ELOOP    BXLE  R9,R10,BCHKLP      * CHECK ALL POSSIBLE MOVES
         L     R2,4(R1)           * LOAD ADDR. OF WHITE'S SCORE
         L     R3,12(R1)          * LOAD ADDR. OF BLACK'S SCORE
         L     R4,0(R2)           * LOAD WHITE'S SCORE
         L     R5,0(R3)           * LOAD BLACK'S SCORE
         CVD   R4,WPDSCR          * CONVERT WHITE'S SCORE TO PACK-DEC
         MVC   WSKR,SCRMSK        * MOVE SCORING MASK INTO WHIT'S SCORE
         ED    WSKR,WPDSCR+4      * EDIT WHIT'S SCORE INTO PRTAR
         CVD   R5,BPDSCR          * CONVERT BLACK'S SCORE INTO PACK-DEC
         MVC   BSKR,SCRMSK        * MOVE SCORING MASK INTO BLACK'S
*                                   SCORE OF PRTAR.
         ED    BSKR,BPDSCR+4      * EDIT BLACK'S SCORE INTO PRTAR
         OPEN  (PRINTER,OUTPUT)   * OPEN THE PRINT FILE
         L     R8,=F'14'          * SET LOOP LIMIT FOR PRINT LOOP
         LA    R9,PRTAR           * PLACE ADDR OF 1ST LINE IN R9
PLOOP    PUT   PRINTER,0(R9)      * OUTPUT A LINE OF THE STATE
         LA    R9,15(R9)          * INC R9 FOR THE NEXT LINE
         BCT   R8,PLOOP           * PUT ALL LINES OF STATE OUT
         CLOSE (PRINTER)
         L     R13,4(R13)         * RESTORE ADDR. OF HI SVAREA
         LM    R14,R12,12(R13)    * RESOTRE REG TO ENTY STATE
         BR    R14                * RETURN CNTL TO CALLING ROUTINE
SVAREA   DC    9D'0'              * DEFINE SAVE AREA
ARGADR   DS    F                  * SET STORAGE FOR ARGUMENT ADDR.
WPDSCR   DS    D                  * DUMMY TO PACK WHITE'S SCORE INTO
BPDSCR   DS    D                  * DUMMY TO PACK BLACK'S SCORE INTO
WPCHR    DC    C'0'               * WHITE'S PRINT CHR
BPCHR    DC    C'*'               * BLACK'S PRINT CHR
SCRMSK   DC    XL8'4020202020202120'   * EDIT MASK FOR SCORES
PRTAR    DS    0F                 * DEFINE PRINTAREA
PRTLN1   DC    CL15'0CURRENT GAME'
PRTLN2   DC    CL15' STATE:'
PRTLN3   DS    0CL15
         DC    CL7' WHITE:'
WSKR     DC    CL8' '
PRTLN4   DS    0CL15
         DC    CL7' BLACK:'
BSKR     DC    CL8' '
PRTLN5   DC    CL15'0          ×'
PRTLN6   DC    CL15'         × ×'
PRTLN7   DC    CL15'       × × ×'
PRTLN8   DC    CL15'       × ×'
PRTLN9   DC    CL15'       ×'
PRTLN10  DC    CL15'      × ×'
PRTLN11  DC    CL15'    × × × ×'
PRTLN12  DC    CL15'  × × × × × ×'
PRTLN13  DC    CL15'  × ×     × ×'
PRTLN14  DC    CL15'  ×         ×'
*                                 END OF PRINT AREA
PLTDSP   DS    0F                 * BEGIN PLOT DISPLACEMENT FIELDS
*                                   THIS DATA CONTAINS THE DISPLACEMENT
*                                   OF EACH PLAYING POSITION FROM THE
*                                   THE BEGINNING OF PRTAR.  IT IS USED
*                                   TO POSITION THE APPROPRIATE COUNTER
*                                   IN THE DISPLAY.
P111     DC    F'171'
P112     DC    F'173'
P113     DC    F'127'
P121     DC    F'184'
P122     DC    F'190'
P123     DC    F'114'
P131     DC    F'197'
P132     DC    F'207'
P133     DC    F'101'
P211     DC    F'156'
P212     DC    F'158'
P213     DC    F'112'
P221     DC    F'169'
P222     DC    F'175'
P223     DC    F'99'
P231     DC    F'182'
P232     DC    F'192'
P233     DC    F'86'
P311     DC    F'141'
P312     DC    F'143'
P313     DC    F'97'
P321     DC    F'154'
P322     DC    F'160'
P323     DC    F'84'
P331     DC    F'167'
P332     DC    F'177'
P333     DC    F'71'
POSIT    DS    0F
L1P1A1   DC    XL4'4000000'
L1P1A2   DC    XL4'2000000'
L1P1A3   DC    XL4'1000000'
L1P2A1   DC    XL4'800000'
L1P2A2   DC    XL4'400000'
L1P2A3   DC    XL4'200000'
L1P3A1   DC    XL4'100000'
L1P3A2   DC    XL4'80000'
L1P3A3   DC    XL4'40000'
L2P1A1   DC    XL4'20000'
L2P1A2   DC    XL4'10000'
L2P1A3   DC    XL4'8000'
L2P2A1   DC    XL4'4000'
L2P2A2   DC    XL4'2000'
L2P2A3   DC    XL4'1000'
L2P3A1   DC    XL4'800'
L2P3A2   DC    XL4'400'
L2P3A3   DC    XL4'200'
L3P1A1   DC    XL4'100'
L3P1A2   DC    XL4'80'
L3P1A3   DC    XL4'40'
L3P2A1   DC    XL4'20'
L3P2A2   DC    XL4'10'
L3P2A3   DC    XL4'8'
L3P3A1   DC    XL4'4'
L3P3A2   DC    XL4'2'
L3P3A3   DC    XL4'1'
PRINTER  DCB   DDNAME=FT06F001,DSORG=PS,RECFM=FA,LRECL=15,             +
               BLKSIZE=15,MACRF=(PM)
         LTORG
         END   DSPLAY
// EXEC ASMGC
//ASM.SYSIN DD *
APOSIT   CSECT
         USING APOSIT,15
         L     0,=V(POSIT)        * LOAD THE ADDR OF POSIT
         BR    14
         END   APOSIT
// EXEC FORTGCE,PARM.LKED='MAP,XREF,LIST,LET,SIZE=(88K,8K)'
//FORT.SYSIN DD *
      SUBROUTINE PLRMV(MOVE,PLC,PSCR,USED,OPLC,OSCR,MVSCR,KMV)
C        THIS ROUTINE IS USED TO OBTAIN THE PLAYER'S MOVE FROM THE
C        INPUT FILE, CALCULATE THE PROPER DISPLACEMENT , SCORE THE MOVE,
C        AND PLACE THE MOVE AMONG THE FILLED POSITIONS.
C        IF THE PLAYER SHOULD MAKE THREE(3) INVALID MOVES, THE COMPUTER
C        WILL SELECT A MOVE FOR HIM. USING <FNDMV>.  AFTER EACH INVALID
C        MOVE, THE PLAYER WILL RECIEVE A DISPLAY IF THE CURRENT GAME
C        STATE.  IF THE PLAYER SHOULD CARE TO OBSERVE THE CURRENT GAME
C        STATE, HE MAY SET ANY OF THE REQUIRED VARIABLES TO ZERO(0),
C        AND OBTAIN A DISPLAY WITHOUT PENALTY.
C        THIS ROUTINE IS USED TO INTERPRET THE COMPUTERS MAVE INTO
C        LEVEL ,ARM,
C        LEVEL,POST,ARM CODE FOR PRINTING TO INFORM THE PLAYER OF ITS
C        MOVE.
      INTEGER A1/'DISP'/,DISP/0/,A2/'LEVL'/,LEVL/0/,A3/'POST'/,POST/0/,
     1 A4/'ARM'/,ARM/0/,A5/'MOVE'/,MOVE,A6/'PLC'/,PLC,A7/'PSCR'/,PSCR,
     2 A8/'MVSR'/,MVSCR,A9/'OPLC'/,OPLC,A10/'OSCR'/,OSCR,A11/'USED'/,
     3 USED,A12/'CNTR'/,CNTR/0/
      INTEGER A13/'KMV'/,KMV
      CNTR=0
   10 WRITE(06,1006)
      READ(05,*,END=20) LEVL,POST,ARM
      WRITE(06,1026) LEVL,POST,ARM
      IF((LEVL.LE.0).OR.(POST.LE.0).OR.(ARM.LE.0)) GOTO 30
      IF((LEVL.GT.3).OR.(POST.GT.3).OR.(ARM.GT.3)) GOTO 15
      DISP=((LEVL-1)*9+(POST-1)*3+ARM-1)*4
      CALL FSCORE(DISP,PLC,USED,PSCR,MVSCR)
      IF(DISP.EQ.0) GOTO 20
      MOVE=DISP
      RETURN
   15 WRITE(06,1036)
   20 CNTR=CNTR+1
      IF(CNTR.GE.3) GOTO 40
   30 IF(KMV) 31,31,32
   31 CALL DSPLAY(OPLC,OSCR,PLC,PSCR)
      GOTO 10
   32 CALL DSPLAY(PLC,PSCR,OPLC,OSCR)
      GOTO 10
   40 CALL FNDMV(MOVE,PLC,USED,PSCR,MVSCR)
      WRITE(06,1016)
      CALL PNTCMV(MOVE)
      IF(KMV) 41,41,42
   41 CALL DSPLAY(OPLC,OSCR,PLC,PSCR)
      RETURN
   42 CALL DSPLAY(PLC,PSCR,OPLC,OSCR)
      RETURN
 1006 FORMAT('0 YOUR MOVE IS?')
 1016 FORMAT('     YOUR MOVE HAS BEEN MADE FOR YOU!'/'     IT IS:')
 1026 FORMAT('0   LEVEL=',I2,'   POST=',I2,'    ARM=',I2)
 1036 FORMAT('0  * MOVE SPECIFIED IS OUT OF PROPER RANGE.')
      END
      SUBROUTINE PNTCMV(MOVE)
      INTEGER A1/'APOS'/,APOS,A2/'MOVE'/,MOVE,A3/'LEVL'/,LEVL,
     1 A4/'POST'/,POST,A5/'ARM'/,ARM,A6/'DISP'/,DISP,A7/'5DSP'/,KDSP,
     2 A8/'KLVL'/,KLVL,APOSIT
      APOS=APOSIT(MOVE)
      DISP=MOVE-APOS
      KDSP=DISP/4
      LEVL=KDSP/9+1
      KLVL=MOD(KDSP,9)
      POST=KLVL/3+1
      ARM=MOD(KLVL,3)+1
      WRITE(06,1006) LEVL,POST,ARM
      RETURN
 1006 FORMAT('0 THE GENERATED MOVE IS:'/
     1'   LEVEL=',I2,'  POST=',I2,'  ARM=',I2)
      END
      SUBROUTINE PNTDIR
C        THIS ROUTINE IS USED TO PRINT THE DIRECTIONS FOR THE GAME OF
C        REX.  WRITE STATEMENTS ARE USED WITH EXTENDED FORMAT STATMENTS.
      WRITE(06,1006)
 1006 FORMAT('0',5X,'REX IS A VERSION OF 3-D TIC-TAC-TOE.'/
     1' THERE ARE THREE RADIAL ARMS, WITH THREE POSTS EACH.'/
     2' EACH POST HAS ROOM FOR THREE BEADS OR LEVELS.'/
     3' THERE ARE 27 BEADS, 14 WHITE AND 13 BLACK.'/
     4' THE BEADS ARE PLACED BY EACH PLAYER ALTERNATELY TRYING TO '/
     5' OBTAIN POINTS OR BLOCK THEIR OPPONENT FROM OBTAINING POINTS.'/
     6' POINTS ARE GIVEN FOR COMBINATIONS OF 3 BEADS OF THE SAME '/
     7' COLOR.  THERE ARE 51 POSSIBLE COMBINATIONS'/
     8'  WORTH 1 POINT EACH.  THEY MAY BE DIVIDED INTO 5 CLASSES'/
     9'     1) VERTICALS: ALL LEVELS ON THE SAME POST.'/
     A'     2) HORIZONTALS: ALL POSTS ON THE SAME ARM & LEVEL'/
     B'     3) DIAGONALS: COMPLETE WITHIN ANY ARM.'/
     C'     4) RADIALS: THE SAME LEVEL & POST ON ALL ARMS.'/
     D'     5) HELIXS: ONE BEAD ON EACH LEVEL, THE SAME POSTS,'/
     E'                ON DIFFERENT ARMS.')
      WRITE(06,1016)
 1016 FORMAT('0 EXAMPLES OF THESE ARE:'/
     1'0      VERTICAL       HORIZONTAL       DIAGONAL'/
     2'              ×               ×               ×'/
     3'            × ×             × ×             × ×'/
     4'          × × ×           × × ×           × × ×'/
     5'          × ×             × ×             × ×'/
     6'          ×               ×               ×'/
     7'         × ×             × ×             × ×'/
     8'       × × × ×         × × × ×         × × × ×'/
     9'     0 × × × × ×     × × 0 × × ×     0 0 0 × × ×'/
     A'     0 ×     × ×     × 0     × ×     × ×     × ×'/
     B'     0         ×     0         ×     ×         ×')
      WRITE(06,1026)
 1026 FORMAT('0            RADIAL               HELIX'/
     1'                   ×                    ×'/
     2'                 × ×                  × ×'/
     3'               × × ×                0 × ×'/
     4'               × 0                  × ×'/
     5'               ×                    ×'/
     6'              × ×                  × ×'/
     7'            × × × ×              × × 0 ×'/
     8'          × × × × × ×          × × 0 × × ×'/
     9'          × 0     0 ×          × ×     × ×'/
     A'          ×         ×          ×         ×')
      WRITE(06,1036)
 1036 FORMAT('0     MOVES ARE EXPRESSED AS A COMBINATION OF THREE'/
     1'     INTEGERS, RANGING BETWEEN 1 AND 3.'/
     2'     THEY REPRESENT RESPECITVELY, '/
     3'     LEVEL: FROM THE BOTTOM UP.'/
     4'     POST: FROM THE CENTER OUT.'/
     5'     ARM: FROM LOWER LEFT COUNTER-CLOCKWISE,'/
     6'     AN EXAMPLE MIGHT BE: '/
     7'          1,3,1       FOR THE LOWER LEFTMOST POSITION'/
     8'     IF A POSITION OF <0,0,0> IS ENTERED, THEN A'/
     9'     DISPLAY OF THE CURRENT GAME STATE WILL BE'/
     A'     PRODUCED.')
      RETURN
      END
//LKED.SYSLMOD DD DSN=NIN4176.REX.LOAD(REX),DISP=(NEW,CATLG),
// UNIT=TPUSER,SPACE=(TRK,(10,10,1))
