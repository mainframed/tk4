(*$L+,C+,M-,D-*)
PROGRAM PCODE_INTERPRETER(OUTPUT);

(* ASSEMBLER AND INTERPRETER OF PASCAL CODE.  K.JENSEN, N.WIRTH, E.T.H.


NOTE FOR THE IMPLEMENTATION.
===========================
THIS INTERPRETER IS WRITTEN FOR THE CASE WHERE ALL THE FUNDAMENTAL
TYPES TAKE ONE STORAGE UNIT.
IN AN IMPLEMENTATION ALL THE HANDLING OF THE SP POINTER HAS TO TAKE
INTO ACCOUNT THE FACT TAHT THE TYPES MAY HAVE A LENGTH DIFFERENT FROM
ONE. SO IN PUSH AND POP OPERATIONS THE IMPLEMENTOR HAS TO INCREASE
AND DECREASE THE SP NOT BY 1 BUT BY A NUMBER DEPENDING ON THE TYPE
CONCERNED.
WHERE A COMMENT SAYS THAT SOME VARIABLE IS EXPRESSED 'IN UNITS OF
STORAGE' THE VALUE OF THIS VARIABLE MUST NOT BE CORRECTED, BECAUSE
THE COMPILER HAS COMPUTED IT TAKING INTO ACCOUNT THE LENGTHS OF THE
TYPES INVOLVED.
THE SAME HOLDS FOR THE HANDLING OF THE NP POINTER (WHICH MUST NOT BE
CORRECTED)                                                       *)

(* MODIFIED 20.7.76, S. WOOD, STANFORD.
   ===================================
THIS INTERPRETER HAS BEEN MODIFIED TO ACCEPT 'TYPED' P-CODE, AS
GENERATED BY THE S.L.A.C. COMPILER.
IN ADDITION, A DYNAMIC TRACE FEATURE HAS BEEN ADDED.  THE TRACE IS
TURNED ON OR OFF BY THE P-INSTRUCTIONS 'TON' AND 'TOF', RESPECTIVELY.
THE PRESENCE OF A 'TON' INSTRUCTION ANYWHERE IN THE SOURCE P-CODE
ALSO CAUSES A DUMP OF THE OBJECT CODE AFTER LOADING.
*)
(*$E*)
  (*********************************************************************
   *
   *
   *   P_Code Interpreter
   *
   *   This interpreter  interprets  the  P_Code  generated  by  the
   *   Stanford  Pascal  Compiler  when used in "PM"+"CM" mode (i.e.
   *   allocating one storage unit per basic data item).   It  reads
   *   the  P_Code  program to be interpreted from file 'PFILE', and
   *   sends its messages to the file 'OUTPUT'.  The  file  'OUTPUT'
   *   and  other predefined Pascal files may be used by the program
   *   being interpreted.
   *
   *   The   interpreter   can   provide   (optional)    statistical
   *   information about the program it is interpreting.  The P_Code
   *   related  statistics  are  sent  to  'SFL'  and  stack related
   *   information is directed to 'TRFILE'.  The size of the largest
   *   program that can be interpreted is determined by 'MAXPC'  and
   *   the  size  of  the  run  time  stack  is set by 'MAXSTK'.  By
   *   setting  'MAXPC  =  18500'  and  'STKMAX  =  30000'  you  can
   *   interpret the Compiler compiling  a  reasonably  large  (i.e.
   *   5000  lines)  program  and  the  interpreter will need a 600k
   *   region for such a compilation.  Also note that running Pascal
   *   programs in this nterpretive form is very expensive in  terms
   *   of  the  CPU  time  and  is not suggested as a normal mode of
   *   operation.
   *
   *   further updates and new features will be listed below.
   *
   *
   *   -THE  PROBLEM  ASSOCIATED   WITH   'FORWARD   REFERENCE'   TO
   *   PROCEDURES IS FIXED AND SIZE OF 'STORE' AND 'CODE' ARRAYS ARE
   *   INCREASED   SO  THAT  THE  INTERPRETER  MAY  'INTERPRET'  THE
   *   P_COMPILER WHILE COMPILING AVERAGE SIZE PROGRAMS.
   *
   *   -THE  INTERPRETER  CAN  NOW  PROVIDE   DYNAMIC   AND   STATIC
   *   INFORMATION  ABOUT  THE  OCCURANCE  FREQUENCIES OF INDIVIDUAL
   *   P_INSTRUCTIONS AS WELL AS INSTRUCTION PAIRS.
   *
   *       GETSTAT  -->  ENABLES 'COUNTING' PROCEDURES
   *       STAT1    -->  PRINT DETAILED BREAKDOWN FOR EACH
   *                     INSTRUCTION BY THE OPERAND TYPE
   *       STAT2    -->  PRINT FREQUENCY OF ADDRESS/OPERAND
   *                     FOR LOD, STR, INC, DEC, IXA... ETC.
   *       STAT3    -->  PRINT FREQUENCY AND BRANCH DISTANCE
   *                     FOR JUMP INSTRUCTIONS.
   *       STAT4    -->  PRINT INSTRUCTION PAIR STATISTICS
   *       STAT5    -->  PRINT MATRIX OF INSTRUCTION PAIR FREQUENCY.
   *       STAT6    -->  GENERATE PUSH/POP, CALL/RETURN STACK TRACE.
   *       STAT9    -->  PRINT FULL DETAILS OF THE ABOVE TABLES.
   *
   *       STAT4, STAT2 AND STAT3, IF ENABLED WHILE INTERPRETING,
   *       COULD BE QUITE COSTLY WITH THE COST INCREASING IN THAT
   *       ORDER. THE ADDED COST FOR THE STATIC STATISTICS
   *       (COLLECTED DURING THE LOADING PHASE) IS LESS DRAMATIC
   *       THOUGH.
   *
   *
   *   -THE INTERPRETER HAS BEEN MODIFIED AND FIXED  TO  CONFORM  TO
   *   THE NEW P_CODE AS GENERATED BY THE APR_79 VERSION OF THE SLAC
   *   PASCAL  COMPILER,  THE MODIFICATION INVOLVES THE 'DEF', 'XJP'
   *   'NEW', 'SAV' AND 'RST' INSTRUCTIONS.
   *
   *
   *                                Sassan Hazeghi,
   *                                Computation Research Group,
   *                                Stanford Linear Accelerator Center
   *
   *
   *                                updated:  july 76
   *                                          sep. 76
   *                                          oct. 76
   *                                          may  77
   *                                          feb. 79
   *                                          may. 79
   *
   *
   *********************************************************************

(*----------------------------------------------------------------------


CONST  MAXPC       = 20000; (* SIZE OF PROGRAM AREA *)
       MAXCODE     = MAXPC; (* PROGRAM COUNTER RANGE *)
       MAXSTK      = 40000; (* TOTAL SIZE OF STACK+HEAP+CONSTANT POOL*)
"""    MAXSTK      = 30000; (* SIZE OF RUNTIME STACK *)
       OVERI       = 32010; (* SIZE OF INTEGER CONSTANT TABLE = 10 *)
       OVERR       = 32220; (* SIZE OF REAL CONSTANT TABLE = 210 *)
       OVERS       = 32300; (* SIZE OF SET CONSTANT TABLE =  80 *)
       OVERB       = 32400; (* SIZE OF BOUNDARY CONSTANT TABLE = 200 *)
       OVERM       = 35900; (* SIZE OF MULTIPLE CONSTANT TABLE = 2500 *)
       LARGEINT    = 524288;  (* = 2**19 *)
      "MAXINT      = 2147483641 ;"
       MAXADR      = MAXINT     ;
       LTSIZE      = 550  ;   (* SIZE OF THE LINEARIZED 'COUNT' TABLE *)
       STRNGLEN    = 64;      (* MAX STRING LENGHT *)
       INPUTADR    = 6  ;     (* ABSOLUTE ADDRESS *)
       OUTPUTADR   = 7  ;
       PRDADR      = 8  ;
       PRRADR      = 9  ;
       QRDADR      = 10 ;
       QRRADR      = 11 ;
       LSTBUF      = 15 ;
       NILVAL      = MAXSTK;
       BLNK3       = '   ' ;  BLNK8 = '        ' ;
       MAXLBLCNT   = 1200 ; (* COUNT OF LABELS *)
       MAXLABEL    = 650 ;  (* COMPLETE COMPILER PROCESSING *)
       MINLABEL    = 360 ;  (*NEGATIVE INDICIES FOR PROCEDURE LABELS*)
       MAXPROC     = MINLABEL ;
       MINPROC     = 0 ;
       PTRSIZE     = 1 ;     (* HAS TO BE UPDATED FOR DIFFERENT DATA SIZ
       OSPARMLOC   = 16;     (* LOCATION FOR OSPARM VARIABLE *)
       LCAFTMST    = 16;     (* LOCATION AFTER MARK STACK *)
       SAVEAREA    = 16;     (* SAVE AREA FOR THE 370 IMPLEMENTATION*)
       TIMEDATELOC = 20;     (* LOCATION OF TIME/DATE PREDEF. VARS *)
       FUNCRSLT    = 0 ;     (* LOCATION (OFF MP) OF THE FUNC RESULT *)

       (* P-CODE INSTRUCTION MNEMONICS *)

       PABI =  0 ;   PABR =  1 ;   PADI =  2 ;   PADR =  3 ;
       PAND =  4 ;   PCHK =  5 ;   PCHR =  6 ;   PCSP =  7 ;
       PCUP =  8 ;   PDEC =  9 ;   PDEF = 10 ;   PDIF = 11 ;
       PDVI = 12 ;   PDVR = 13 ;   PENT = 14 ;   PEOF = 15 ;
       PEQU = 16 ;   PFJP = 17 ;   PFLO = 18 ;   PFLT = 19 ;
       PGEQ = 20 ;   PGRT = 21 ;   PINC = 22 ;   PIND = 23 ;
       PINN = 24 ;   PINT = 25 ;   PIOR = 26 ;   PIXA = 27 ;
       PLAO = 28 ;   PLCA = 29 ;   PLDA = 30 ;   PLDC = 31 ;
       PLDO = 32 ;   PLEQ = 33 ;   PLES = 34 ;   PLOC = 35 ;
       PLOD = 36 ;   PMOD = 37 ;   PMOV = 38 ;   PMPI = 39 ;
       PMPR = 40 ;   PMST = 41 ;   PNEQ = 42 ;   PNEW = 43 ;
       PNGI = 44 ;   PNGR = 45 ;   PNOT = 46 ;   PODD = 47 ;
       PORD = 48 ;   PPRE = 49 ;   PRET = 50 ;   PRST = 51 ;
       PSAV = 52 ;   PSBI = 53 ;   PSBR = 54 ;   PSGS = 55 ;
       PSQI = 56 ;   PSQR = 57 ;   PSRO = 58 ;   PSTO = 59 ;
       PSTP = 60 ;   PSTR = 61 ;   PUJP = 62 ;   PXJP = 63 ;
       PTON = 64 ;   PTRC = 65 ;   PSUC = 66 ;   PUNI = 67 ;
       PTOF = 68 ;   PBGN = 69 ;   PLCI = 70 ;   PCMP = 71 ;
       PNOP = 72 ;

       SPCNT = 32 ;                (* COUNT OF STANDARD PROCS *)

       UNDEF = '0' ;  INT = '1' ;  REEL = '2' ;  BOOL = '3' ;
       SETT  = '4' ;  ADR = '5' ;  MARK = '6' ;  INDEX= '7' ;
"""    UNDEF = 0 ;  INT = 1 ;  REEL = 2 ;  BOOL = 3 ;
       SETT  = 4 ;  ADR = 5 ;  MARK = 6 ;  INDEX= 7 ;   """

      "ENTERED = 0 ;  DEFINED = 1 ;"
(*----------------------------------------------------------------------

TYPE  BIT4         = 0..MAXLBLCNT ;
      BIT7         = 0..70;
      BIT20        = -524287..524287;
      OPRNG        = 0..PNOP;
      DATATYPE     = CHAR (* I.E. UNDEF..INDEX *) ;
      LBLRNG       = MINPROC..MAXLABEL ;
      LBLCNTRNG    = 0..MAXLBLCNT ;
      ADDRESS      = -1..MAXSTK;
      POSINT       = 0..MAXADR ;
      ALFA         = PACKED ARRAY [1..8] OF CHAR ;
      SHRTALFA     = PACKED ARRAY [1..3] OF CHAR ;
      BETA         = PACKED ARRAY[1..20] OF CHAR; (*ERROR MESSAGE*)
      COUNTER      = 0..MAXINT ;
      COUNTER1     = -1..MAXINT ;

      LABELST      = (ENTERED,DEFINED);  (* LABEL SITUATION *)
      LABELREC     = RECORD
         VAL: -1..MAXADR  ;
         ST: LABELST
         END ;

      TEXT         = FILE OF CHAR ;

      CNTBIN       = RECORD
                       VAL :  INTEGER ;
                       CNT :  COUNTER ;
                       NXT :  @ CNTBIN
                     END ;

(*----------------------------------------------------------------------
VAR
     (* INSTRUCTION REGISTER, OPCODE, T, P AND Q FIELDS *)

     OP, OLDOP     : -1..PNOP;
     T             : DATATYPE;
     P             : ADDRESS;
     Q             : INTEGER;

     (* MP:      ACTIVATION RECORD POINTER,
        SP:      TOP ELEMENT OF EXPRESSION EVALUATION STACK,
        NP:      POINTER TO NEXT AVAILABLE HEAP AREA (GROWS DOWN !)
        EP:      PROGRAM ENTRY POINT,
        CPL:     END OF THE HEAP, BEGINING OF CONSTANT POOL,
        PC:      P_PROGRAM COUNTER,
        CURLVL:  STATIC LEVEL OF CURRENTLY ACTIVE PROCEDURE,         *)

     MP,
     SP,
     NP,
     EP,
     CPL           : ADDRESS;
     PC            : 0..MAXPC;
     CURLVL        : BIT4;

     (* VARIOUS SWITCHES AND COUNTERS *)

     LOADING,
     STRACE,
(*   CTRACE,
     INTERPRETING,
     GETSTAT,
     STAT1,
     STAT4,
     STAT2,
     STAT3,
     STAT5,
     STAT6,
     STAT9,
     TRCE, DMP      : BOOLEAN;

     PUSHCNT,
     POPCNT,
     MAXCALL,
     CSTP,
     TBUFP,
     INSTRCNT      : INTEGER;

     STK_LMT,
     HEAP_LMT      : ADDRESS;

     (* VARIOUS TABLES, BUFFERS AND COUNTER ARRAYS *)

     INSTR         : ARRAY[PABI..PNOP] OF SHRTALFA;(*MNEMONIC INST. CODE
     DISPLAY       : ARRAY [1..10] OF ADDRESS ;

     PINX, QINX,                                       (* INDEX TO SCNT
     PCNT          : ARRAY [PABI..PNOP] OF INTEGER ;   (* P_INST. COUNTS
     ACNT          : ARRAY [PABI..PNOP] OF @ CNTBIN ;  (* CONST. VALUE C
     SCNT          : ARRAY [0..LTSIZE] OF INTEGER ;    (* SPECIAL INST.
     TBUF:           ARRAY[0..79] OF CHAR;            (* PUSH/POP TRACE

     (* P_MACHINE CODE AND DATA SPACES *)

     CODE          : ARRAY[0..MAXCODE] OF   (* THE PROGRAM *)
                     PACKED RECORD  OP1    :INTEGER; ":BIT7;"
                                   "P1     :BIT4;"
                                    Q1     :INTEGER";
                                    T1     :DATATYPE ;
                                    OP2    :BIT7;
                                    P2     :BIT4;
                                    Q2     :INTEGER ;
                                    T2     :DATATYPE  "
                            END;

     STYPE:          ARRAY [ADDRESS] OF DATATYPE;

     STORE         : ARRAY [ADDRESS] OF
                        RECORD   CASE "STYPE :"DATATYPE OF
                                INT        :(VI :INTEGER);
                                REEL       :(VR :REAL);
                                BOOL       :(VB :BOOLEAN);
                                SETT       :(VS :SET OF 0..63);
                                ADR        :(VA :ADDRESS); (*ADDRESS IN
                                MARK       :(VM :INTEGER)
                        END;

     SPTABLE       : ARRAY[0..SPCNT] OF SHRTALFA;   (* STANDARD FNS AND
        PROCTAB       : ARRAY [MINPROC..MAXPROC] OF ALFA ;
     BDCNT         : ARRAY [LBLCNTRNG] OF
                           RECORD  CNT: COUNTER1 ;  VAL : INTEGER  END ;

     CORTBL        : ARRAY[PABI..PNOP,PABI..PNOP] OF INTEGER ;  (* INST.

     STRBUF:         ARRAY[0..STRNGLEN] OF CHAR;  (* BUFFER FOR STRING C
     HEADLN:         ARRAY[1..36] OF CHAR;        (* HEADING OF THE P_PR
     IVECTOR       : ARRAY['A'..'Z'] OF INTEGER ; (* INDEX INTO P_CODE T
     CALLSTK:        ARRAY[0..100] OF INTEGER;    (* NEST OF CALL STACK

     NEEDOPNDS     : SET OF 0..63 ;  (* OPCODES THAT HAVE OPERANDS *)

     NXTUJP,NXTFJP : LBLCNTRNG ;
     TIMER,
     RETCDE,
     GAC, IAC, LAC:  INTEGER;               (* GLOBAL/LOCAL/INT. ACCESS

     (* INTERPRETER I/O FILE DEFINITIONS *)

     PFILE         : TEXT ;                 (* P_CODE INPUT FILE *)

     SFL           : TEXT ;                 (* INTERP. STATISTICS OUTPUT

     TRFILE        : TEXT ;                 (* STACK ACTIVITY TRACE FILE


(*$D-*)
(*----------------------------------------------------------------------

PROCEDURE STK_TRACE ;

   (* TO GENERATE THE TRACE OF STACK ACTIVITY PUSH/POP AS WEEL AS CALL/R
   (* OUTPUTS AN 'A' TO 'TRFILE' FILE TO INDICATE A  PUSH         *)
   (*            'S' "    "      "        "          POP          *)
   (*            'P' "    "      "        "          POP PARM.    *)
   (*            'C' "    "      "        "          CALL         *)
   (*            'R' "    "      "        "          RETURN       *)
   (*                                                             *)

   VAR I, J: INTEGER;

   PROCEDURE DOPUSH(C: CHAR) ;

      BEGIN
      IF STRACE "AND (C IN ['C', 'R'])" THEN
         BEGIN  PUSHCNT := PUSHCNT+1;  TBUF[TBUFP] := C;  TBUFP := TBUFP
         IF TBUFP = 80 THEN  BEGIN  WRITE(TRFILE,TBUF);  TBUFP := 2;  EN
         END;
      END (*DOPUSH*);


   PROCEDURE DOPOP(C: CHAR);

      BEGIN
      IF STRACE "AND (C IN ['C', 'R'])" THEN
         BEGIN  POPCNT := POPCNT+1;  TBUF[TBUFP] := C;  TBUFP := TBUFP+1
         IF TBUFP = 80 THEN  BEGIN  WRITE(TRFILE, TBUF);  TBUFP := 2  EN
         END;
      END (*DOPOP*);



   BEGIN

      CASE OP OF

      PLCA, PLCI, PLDC, PLOD, PLDA :
         DOPUSH('A');

      PABI, PABR, PNGI, PNGR, PNOT:
         BEGIN  DOPOP('S');  DOPUSH('A');  END;

      PEQU, PNEQ, PGRT, PGEQ, PLES, PLEQ,
      PADI, PSBI, PMPI, PDVI, PMOD, PADR,
      PSBR, PMPR, PDVR, PAND, PIOR,
      PDIF, PINT, PUNI, PINN:
         BEGIN  DOPOP('S');  DOPOP('S');  DOPUSH('A')  END;

      PSTR, PIXA, PXJP, PFJP,
      PNEW, PSAV, PRST:
         DOPOP('S');

      PSTO, PMOV :
         BEGIN  DOPOP('S'); DOPOP('S') END ;

      PMST :
         BEGIN  CSTP := CSTP+1 ;  CALLSTK[CSTP] := PUSHCNT-POPCNT ; END

      PCUP :
         BEGIN  J := (PUSHCNT-POPCNT)-CALLSTK[CSTP] ;
         FOR I := 1 TO J DO DOPOP('P') ;  (*POPS PARAMETERS OFF THE STAC
         IF LOADING THEN
            BEGIN
            IF T <> UNDEF THEN DOPUSH('A');  (*FUNCTION CALL LEAVES A RE
            IF MAXCALL < CSTP THEN  MAXCALL := CSTP;
            CSTP := CSTP-1;
            END
         ELSE  (*I.E. INTERPRETING*)  DOPUSH('C');

         END ;

      PCSP :
         BEGIN
         IF Q = 28 (*PSIO*) THEN  STRACE := FALSE
         ELSE IF Q = 29 (*PEIO*) THEN  BEGIN  STRACE := TRUE;  DOPOP('S'
         ELSE IF Q IN [24, 7 (*PEOF, PELN*)] THEN
            BEGIN STRACE := TRUE; DOPUSH('A');  STRACE := FALSE END
         ELSE IF Q IN [14, 15, 16, 17, 18, 19
                      (*PSIN, PCOS, PATN, PEXP, PLOG, PSQT*)] THEN
                      BEGIN  DOPOP('S');  DOPUSH('A');  END
         ELSE IF Q IN [2, 4, 20 (*PRST, PNEW, PSAV*)] THEN  DOPOP('S')
         END ;

      PRET :
         IF INTERPRETING THEN
            BEGIN
            IF MAXCALL < CSTP THEN MAXCALL := CSTP;
            IF T <> UNDEF THEN DOPUSH('A');
            DOPOP('R');  (*FLAG PROC. RETURN*)
            CSTP := CSTP-1;
            END;


      END (*CASE OP OF*);


   END (*STK_TRACE*);

(*----------------------------------------------------------------------


FUNCTION  WRF(VAR F:TEXT; X: REAL; M,N: INTEGER): CHAR;
   (* WRITE REAL NUMBER X IN FIXED-POINT FORMAT;
    M CHARACTERS, N AFTER THE '.' *)
   CONST T31 = 214731364(*7*);  (* (2**32-1) DIV 10 *)
         REALT31 = 214731364.0;
     (*  Z = 27; *)   (* ORD('0') *)
   TYPE POSINT = 0..99;
   VAR C,D,E,R,K2,K3,I: INTEGER;
       SIGN: CHAR;

BEGIN
   IF ABS(X) > T31*10  THEN
   BEGIN FOR I:=1 TO N-1 DO BEGIN F@:='#'; PUT(F) END;
      F@:='U'; PUT(F)
   END ELSE
   BEGIN
      IF X<0 THEN
         BEGIN SIGN := '-'; X := -X
         END ELSE SIGN := ' ';

     IF X < 1.0E-10 THEN X := 0;

      (* X = 0: A SPECIAL CASE *)
      IF X=0 THEN
      BEGIN  REPEAT  F@ := ' '; PUT(F); M := M-1 UNTIL M<=1;
             F@ := '0'; PUT(F)
      END ELSE
      BEGIN (* CHECK SIGN AND DETERMINE SCALE FACTOR *)
         (*E := EXPO(X);*)   E := 0;
         IF X >= 1.0 THEN
            REPEAT  X := X(*/10.0*) * 0.1; E := E + 1   UNTIL X < 1.0

         ELSE  IF X < 0.1 THEN
                  REPEAT  X := X * 10.0; E := E - 1   UNTIL X >= 0.1 ;

         (* 0.1 <= X < 1.0 *)
         R := N+E;

         IF (R >= 1) OR (R <= 9) THEN

            CASE R OF      (* ROUNDING *)
              1: X := X+0.5E-1;
              2: X := X+0.5E-2;
              3: X := X+0.5E-3;
              4: X := X+0.5E-4;
              5: X := X+0.5E-5;
              6: X := X+0.5E-6;
              7: X := X+0.5E-7;
              8: X := X+0.5E-8;
              9: X := X+0.5E-9;
             10: X := X+0.5E-10;
             11: X := X+0.5E-11;
             12: X := X+0.5E-12;
             13: X := X+0.5E-13
            END

         ELSE X := X+0.5E-9;

         IF X >= 1.0 THEN  BEGIN X := X * 0.1; E := E+1 END ;
         IF E>0 THEN BEGIN M := M-N-E-2;  K2 := E;  K3 := 0  END
         ELSE
         BEGIN M := M-N-3;  K2 := 0;
            IF N+E >= 0 THEN K3 := -E ELSE K3 := N;
            N := N-K3
         END;
         IF M <= 0 THEN M := (*1*) 0;
         (* M BLANKS, SIGN, K2 DIGITS, '.', K3 ZEROES, N DIGITS *)
         WHILE M > 0 DO BEGIN    F@ := ' '; PUT(F); M := M-1  END ;
         F@ := SIGN; PUT(F);
         C := TRUNC(X*REALT31+0.5); D := 0;
         IF K2=0 THEN BEGIN F@ := '0'; PUT(F) END ELSE
            REPEAT C := (C - D*T31) * 10;
                   D := C DIV T31;
                  F@ := CHR(D+ ORD('0') ); PUT(F);  K2 := K2-1
            UNTIL K2=0;
         F@ := '.'; PUT(F);
         WHILE K3<>0 DO
            BEGIN F@ := '0'; PUT(F); K3 := K3-1
            END;
         WHILE N<>0 DO
         BEGIN C := (C - D*T31) * 10;
               D := C DIV T31;
               F@ := CHR(D+ ORD('0') ); PUT(F); N := N-1
         END
      END
   END ;
   WRF := ' ';
END (* WRF *);

(*----------------------------------------------------------------------

   PROCEDURE PRINT_HEADLN(VAR F: TEXT);

   BEGIN
   REWRITE(F);
   WRITELN(F, '    < Stanford P_Code Interpreter, Version of May 79. >')
   WRITELN(F);  WRITELN(F);

   IF LOADING THEN
      BEGIN
      WRITELN(F, '    < P_INSTRUCTIONS'' STATIC STATISTICS >') ;
      WRITELN(F);  WRITELN(F);
      WRITELN(F, '    >>>>  LOADING: ', HEADLN);
      WRITELN(F);  WRITELN(F);
      WRITELN(F, '>>>>  ':10,  PC:5, ' INSTRUCTIONS AND  ',
                 MAXSTK-CPL-1:1, ' CONSTANTS LOADED, ',
                 WRF(F, TIMER/1000, 6, 1):01, ' SECONDS IN LOADING.') ;
      END
   ELSE
      BEGIN
      WRITELN(F, '    < P_INSTRUCTIONS'' DYNAMIC STATISTICS >') ;
      WRITELN(F);  WRITELN(F);
      WRITELN(F, '    >>>>  INTERPRETING: ', HEADLN);
      WRITELN(F);  WRITELN(F);
      WRITELN(F,'    --->  I_CNT:  ',INSTRCNT:4,',  SP: ', SP:5,',  NP:
                ',  MP: ',MP:4, ',  PC: ',  PC:5, '  OP =', INSTR[OP]:4,
                '  (', OP:3, '  T: ', T:1, '  P: ', P:4,'  Q: ',Q:5, ')'
      WRITELN(F);  WRITELN(F);
      WRITELN(F, '>>>>  ':10, INSTRCNT:5, ' INSTRUCTIONS INTERPRETED IN
                 WRF(F, TIMER/1000, 8, 1):01, ' SECONDS.' ) ;
      WRITELN(F);  WRITELN(F);
      WRITELN(F, '>>>>  ':10, ' TOTAL STACK USAGE= ',STK_LMT:2,
                 ',  HEAP USAGE= ', CPL-HEAP_LMT:2, '  STORAGE UNITS.');
      END (*IF INTERPRETING*);

   END (*PRINT_HEADLN*);

(*----------------------------------------------------------------------


PROCEDURE CLEARCOUNTS ;      (*TO CLEAR STATIC/DYNAMIC COUNTERS*)
   VAR  I, J : INTEGER ;   PTR : @CNTBIN ;
   BEGIN   OLDOP := PNOP ;

   FOR I := PABI TO PNOP DO
      BEGIN  PCNT[I] := 0 ;  PINX[I] := 0 ;
      PTR := ACNT[I] ;
      REPEAT  PTR@.CNT := 0 ;  PTR := PTR@.NXT ;   UNTIL PTR = NIL ;
      FOR  J := PABI TO PNOP DO  CORTBL[I,J] := 0 ;
      END ;

   PINX[PRET] :=   0 ;  PINX[PLDA] :=  10 ;  PINX[PEQU] :=  20 ;
   PINX[PGEQ] :=  26 ;  PINX[PGRT] :=  32 ;  PINX[PLDC] :=  38 ;
   PINX[PLEQ] :=  44 ;  PINX[PLES] :=  50 ;  PINX[PNEQ] :=  56 ;
  "PINX[PRET] :=  62 ;" PINX[PIND] :=  68 ;  PINX[PLDO] :=  74 ;
   PINX[PSRO] :=  80 ;  PINX[PSTO] :=  86 ;  PINX[PCUP] :=  92 ;
   PINX[PLOD] := 152 ;  PINX[PSTR] := 212 ;  PINX[PCSP] := 272 ;
   PINX[PMST] := 304 ;  PINX[PENT] := 320 ;

   QINX[PLOD] := 380 ;  QINX[PSTR] := 450 ;  QINX[PLDA] := 520 ;
   QINX[PMST] := 530 ;

   FOR I := 0 TO LTSIZE DO SCNT[I] := 0 ;

   FOR I := 0 TO MAXLBLCNT DO BDCNT[I].CNT := 0 ;

   PUSHCNT := 0;  POPCNT := 0;  CSTP := 0;                 (*++++++++*)
   TBUFP := 2;  MAXCALL := 0;  STRACE := TRUE;             (*++++++++*)
(*    CTRACE := TRUE;
   TBUF[0] := '$';  TBUF[1] := ' ';                        (*++++++++*)
   IF INTERPRETING THEN TBUF[0] := '#';                    (*++++++++*)
   END (*CLEARCOUNTS*) ;
(*----------------------------------------------------------------------

PROCEDURE COUNT ;            (*TO ACCUMULATE STSTIC/DYNAMIC INSTR. COUNT
   VAR  J, K, TT : INTEGER ;   PTR, PTR2: @ CNTBIN ;
   BEGIN
   IF STAT6 THEN  STK_TRACE;                                       (*+++
   PCNT[OP] := PCNT[OP]+1 ;

     IF STAT1 THEN

       BEGIN   TT := ORD(T)-ORD(UNDEF);  J := PINX[OP];

       CASE OP OF

          PLDA,PMST:  (* SEGREGATE BY LEVEL *)
             BEGIN
             SCNT[ J  + P] := SCNT[ J  + P] + 1 ;
             K := CURLVL-P;
             SCNT[QINX[OP]+K+ TT] := SCNT[QINX[OP]+K+ TT]+1;

             IF LOADING THEN
                IF OP = PLDA THEN
                   IF P = 1 THEN GAC := GAC+1
                   ELSE IF P = CURLVL THEN LAC := LAC+1
                   ELSE               IAC := IAC+1;

             END;

          PRET,PEQU,PGEQ,PGRT,PLDC,PLEQ,PLES,PNEQ:
          (* SEGREGATE BY TYPE *)
             SCNT[ J  + P] := SCNT[ J  + P] + 1 ;

          PIND,PSTO",PLDO,PSRO":  (* SEGREGATE BY TYPE *)
             BEGIN
                SCNT[ J  + TT] := SCNT[ J  + TT] + 1  ;
             END  (* IND,STO",LDO,SRO" *) ;

          PLOD,PSTR:  (* SEGREGATE BY TYPE AND LEVEL *)
             BEGIN
                SCNT[ J  + P * 6 + TT] := SCNT[ J  + P * 6 + TT] + 1;;
                K := 6*(CURLVL-P);
                SCNT[QINX[OP]+K+ TT] := SCNT[QINX[OP]+K+ TT]+1;

             IF LOADING THEN
                IF P = 1 THEN GAC := GAC+1
                ELSE IF P = CURLVL THEN LAC := LAC+1
                ELSE               IAC := IAC+1;

             END  (* PLOD,PSTR *) ;

          PCUP,PENT:  (* SEGREGATE BY TYPE AND LEVEL *)
             BEGIN
                SCNT[ J  + P * 6 + TT] := SCNT[ J  + P * 6 + TT] + 1;;
             END  (* PCUP,PENT *) ;

          PCSP:  (* SEGREGATE BY PROCEDURE NUMBER *)
             SCNT[ J  + Q] := SCNT[ J  + Q] + 1 ;

          PABI,PABR,PADI,PADR,PAND,PCHK,PCHR,PDEC,PDIF,PDVI,PDVR,
          PEOF,PFJP,PFLO,PFLT,PINC,PINN,PINT,PIOR,PIXA,PLAO,PLCA,
          PLOC,PMOD,PMOV,PMPI,PMPR,PNGI,PNGR,PNOT,PODD,PORD,
          PPRE,PSBI,PSBR,PSGS,PSQI,PSQR,PSTP,PSUC,PTOF,PTON,PTRC,
          PUJP,PUNI,PXJP,PLCI:
             PINX[OP] := PINX[OP] + 1

       END  (* CASE OP *) ;


    """IF OP <= PSTR THEN
          BEGIN

          IF OP IN [PLOD, PSTR, PLDA, PMST] THEN
             BEGIN
             IF OP IN [PMST, PLDA] THEN  K := CURLVL-P  ELSE  K := 6*(CU
             SCNT[QINX[OP]+K+ TT] := SCNT[QINX[OP]+K+ TT]+1;
             END;

          IF LOADING THEN
             IF OP IN [PLOD, PSTR, PLDA] THEN
                IF P = 1 THEN GAC := GAC+1
                ELSE IF P = CURLVL THEN LAC := LAC+1
                ELSE               IAC := IAC+1;

          END (* OP <= PSTR *); """


      END (* IF STAT1 *);

   IF STAT2 THEN  (* COLLECT DATA OCCURANCE COUNTS *)
      IF OP <= 63 THEN
         IF OP IN [PNEW,PINC,PDEC,PIND,PLDA,PLOD,PSTR,PCSP,PMOV,PIXA,PLD
            IF (OP <> PLDC) OR (P = 1) THEN
               BEGIN   PTR := ACNT[OP] ;      (* OCCURANCE COUNT OF CONS

               WHILE (PTR@.VAL < Q)"AND (PTR@.NXT <> NIL)"DO  PTR := PTR

               IF PTR @.VAL <>  Q THEN
                  BEGIN  NEW(PTR2) ;
                  PTR2@ := PTR@ ;
                  PTR@.NXT := PTR2 ;  PTR@.CNT := 0 ;  PTR@.VAL := Q ;
                  END ;
               PTR@.CNT := PTR@.CNT+1 ;
               END (* COUNTING OCCURANCES OF CONSTANT VALUES *) ;

   IF STAT4 THEN  BEGIN  CORTBL[OLDOP,OP] := CORTBL[OLDOP,OP]+1 ;
                  OLDOP := OP ;
                  END ;
   END (*COUNT*) ;
(*----------------------------------------------------------------------


PROCEDURE PRINTCOUNTS ;     (*TO PRINT STATIC/DYNAMIC STATISTICS*)
   VAR   I, J, K, L, M, S,
         COLS:                INTEGER ;
         SL                 : REAL;       (* SCALED TOTAL CNT *)
         PTR                : @ CNTBIN ;
         COLNDX             : ARRAY [0..30] OF INTEGER ;
         OPMAP               : ARRAY [0..5] OF OPRNG;
                                    (*INDEX OF NON ZERO COLS*)
(*----------------------------------------------------------------------

   PROCEDURE PRINT_STK_TRACE;
      BEGIN
      WRITELN(TRFILE, TBUF:TBUFP);  WRITELN(TRFILE);        (*++++++*)

      WRITELN(TRFILE,'    PUSHCNT, POPCNT, MAXCALL: ',
              PUSHCNT:10,POPCNT:10, MAXCALL:5);
      WRITELN(SFL);
      WRITELN(SFL, '    PUSHCNT, POPCNT, MAXCALL: ',
              PUSHCNT:10,POPCNT:10, MAXCALL:5);
      WRITELN(SFL);
      END (*PRINT_STK_TRACE*);

(*----------------------------------------------------------------------

   PROCEDURE SORTJ(LB,UB: LBLCNTRNG) ;  (*TO SORT/PRINT JUMP DISTANCE TA
      VAR  I, N      : LBLCNTRNG ;
           J, K, L1  : INTEGER ;
           TCNT, NEGCNT, BINCNT,
           CUMCNT    : COUNTER ;
           INX       : ARRAY [LBLCNTRNG] OF LBLCNTRNG ;
      BEGIN     (* TO SORT AND PRINT BRANCH DISTANCES *)
      INX[0] := NXTFJP ;   BDCNT[NXTFJP].VAL := MAXADR ;
      TCNT := 0 ;  NEGCNT := 0 ;
      FOR I := LB TO UB DO
         BEGIN
         WITH BDCNT[I] DO
            BEGIN   K := VAL ;
            TCNT := TCNT+CNT ;   IF K < 0 THEN NEGCNT := NEGCNT+CNT ;
            END ;
         J := -1 ;
         REPEAT   J := J+1   UNTIL K < BDCNT[ INX[J] ].VAL ;
         FOR  N := I-LB DOWNTO J DO   INX[N+1] := INX[N]  ;
         INX[J] := I ;
         END ;

      IF TCNT > 0 THEN
         BEGIN
         WRITELN(SFL,'1--> ', INSTR[OP], '   (BRANCH  DISTANCE  COUNTS.)
                     '   TOTAL COUNT: ', TCNT:4, WRF(SFL, TCNT*SL, 8, 2)
         WRITELN(SFL) ;       (* PRINT BACKWARD BRANCH DISTANCES *)
         L1 := -1024 ;   BINCNT := 0 ;  CUMCNT := 0  ;   I := 0 ;

         IF NEGCNT > 0 THEN
            REPEAT
            WITH BDCNT[ INX[I] ] DO
               IF VAL <= L1 THEN  BEGIN  BINCNT := BINCNT+CNT ;  I := I+
               ELSE
                  BEGIN   CUMCNT := CUMCNT+BINCNT ;
                  WRITELN(SFL, L1:16, BINCNT:8, CUMCNT:8, NEGCNT-CUMCNT:
                               WRF(SFL, (NEGCNT-CUMCNT)/TCNT*100, 8, 2):
                  L1 := L1 DIV 2 ;  BINCNT := 0 ;
                  END ;
            UNTIL L1 = 0 ;

         WRITELN(SFL) ;   (* NOW PRINT FORWARD BRANCH DISTANCES *)

         CUMCNT := TCNT-CUMCNT ;  NEGCNT := CUMCNT ;   L1 := 1 ;

         IF NEGCNT > 0 THEN
            BEGIN
            REPEAT
            WITH BDCNT[ INX[I] ] DO
               IF VAL < L1 THEN  BEGIN  BINCNT := BINCNT+CNT ;  I := I+1
               ELSE
                  BEGIN
                  WRITELN(SFL,L1 DIV 2:16, BINCNT:8, CUMCNT:8, NEGCNT-CU
                              WRF(SFL, (NEGCNT-CUMCNT)/TCNT*100, 8, 2):0
                  CUMCNT := CUMCNT-BINCNT ;  L1 := L1*2 ;  BINCNT := 0 ;
                  END ;
            UNTIL CUMCNT = 0 ;

            WRITELN(SFL, L1 DIV 2:16, BINCNT:8, CUMCNT:8, NEGCNT-CUMCNT:
                         WRF(SFL, (NEGCNT-CUMCNT)/TCNT*100, 8, 2):0) ;
            END (* IF NEGCNT > 0 ... *);
         WRITELN(SFL);
         WRITELN(SFL, '     BKWRD JUMPS,  FRWRD JUMPS,  RATIOS: ',
                      TCNT-NEGCNT:6, ' ',NEGCNT:6,
                      WRF(SFL, (TCNT-NEGCNT)/TCNT*100, 10, 2):0,
                      WRF(SFL, (NEGCNT)/TCNT*100, 10, 2):0 );

         WRITELN(SFL) ;

         END (* IF TCNT > 0 ... *);

      IF (OP = PFJP) AND (PCNT[PFJP] > 0) THEN
         IF NOT(INTERPRETING OR LOADING) THEN
            (* SUCCESSFUL/UNSUCCESSFULL BRANCHES *)
            WRITELN(SFL, '     TOTAL ''FJP'' COUNT,  SUCC. BRANCHES,  RA
                         PCNT[PFJP]:6, ' ', TCNT:6,
                         WRF(SFL, TCNT/PCNT[PFJP]*100, 10, 2):0);

      IF STAT9 AND (TCNT > 0) THEN
         BEGIN   WRITELN(SFL);  WRITELN(SFL);
         FOR I := 0 TO UB-LB DO
            WRITELN(SFL,BDCNT[ INX[I] ].VAL:16, BDCNT[ INX[I] ].CNT:8) ;
         END (* IF STAT9 *) ;

      WRITELN(SFL) ;

      END (*SORTJ*) ;
(*----------------------------------------------------------------------

   PROCEDURE SORTP ;       (*TO SORT/PRINT INSTRUCTION PAIR FREQUENCIES*
      CONST ML = 120 ;   ML1 = 121 ;
      VAR  I, J       : PABI..PNOP ;
           K          : INTEGER ;
           N          : 0..ML ;
           M          : 0..MAXADR ;
           R          : REAL ;
           INX        : ARRAY [0..ML1] OF  RECORD  X, Y: PABI..PNOP  END

      BEGIN   CORTBL[PNOP,PNOP] := 0 ;
      INX[0].X := PNOP ;  INX[0].Y := PNOP ;  INX[ML1] := INX[0] ;
      FOR I := PABI TO PNOP-1 DO
         FOR J := PABI TO PNOP-1 DO
            BEGIN   M := CORTBL[I,J] ;
            IF M >= 0 THEN
               BEGIN   K := -1 ;
               REPEAT  K := K+1  UNTIL M >= CORTBL[INX[K].X,INX[K].Y] ;
               IF K < ML THEN
                  BEGIN
                  FOR N := ML-1 DOWNTO K DO  INX[N+1] := INX[N] ;
                  INX[K].X := I ;  INX[K].Y := J ;
                  END  ;
               END (* M > 0 *) ;
            END (* FOR I,.. FOR J... *) ;

      WRITELN(SFL,'1 INSTRUCTION PAIR OCCURANCES (COUNT   %   CUMUL.) ',
                   '  TOTAL # OF PAIRS: ', INSTRCNT:8) ;
      WRITELN(SFL) ;     M := 0 ;

      FOR  N := 0 TO ML DO      (* ASSUMES ALL ENTRIES USEFULL *)
         BEGIN   I := INX[N].X ;   J := INX[N].Y ;  K := CORTBL[I,J] ;
         M := M+K ;    R := K*SL ;
         IF R >= 0.1 THEN
            WRITELN(SFL,N:4,')',INSTR[I]:12,INSTR[J]:6,K:10,
                        WRF(SFL, R, 8, 3):01, WRF(SFL, M*SL,10,2):1) ;
         END (* FOR N ... *) ;

      END (*SORTP*) ;

(*----------------------------------------------------------------------
(*$D-*)
   PROCEDURE SORTO(SORTOPC, DETAILED: BOOLEAN);  (*TO SORT/PRINT OPCODE
      VAR  INX            : ARRAY [PABI..PNOP] OF PABI..PNOP ;
           WR, ENTROPY    : REAL ;
           OP, OP1        : PABI..PNOP ;
           M, TC          : INTEGER ;

      PROCEDURE PRINTO(*PRINT OPCODE DISTRIBUATION TABLE*);

         VAR  J:              INTEGER;

         BEGIN
         FOR OP1 := PABI TO PNOP DO

            BEGIN   IF SORTOPC THEN  OP := INX[OP1]  ELSE  OP := OP1 ;
            TC := PCNT[OP];
            IF TC > 0 THEN
               BEGIN WR := L/TC ;
               ENTROPY := ENTROPY + LN(WR)/WR ;

               IF DETAILED THEN

                  CASE OP OF
                     PABI,PABR,PADI,PADR,PAND,PCHK,PCHR,PDEC,PDIF,PDVI,P
                     PEOF,PFJP,PFLO,PFLT,PINC,PINN,PINT,PIOR,PIXA,PLAO,P
                     PLOC,PMOD,PMOV,PMPI,PMPR,PNGI,PNGR,PNOT,PODD,PORD,
                     PPRE,PSBI,PSBR,PSGS,PSQI,PSQR,PSTP,PSUC,PTOF,PTON,P
                     PUJP,PUNI,PXJP,PLCI,PNEW:
                        BEGIN  K := PINX[OP] ;
                        IF K <> 0 THEN
                           WRITELN(SFL, INSTR[OP]:10, K:20,
                                        WRF(SFL,K*SL,10,2):01) ;
                        END ;

                     PRET,PLDA,PMST:
                        BEGIN  S := 0 ;
                        FOR I := PINX[OP] TO PINX[OP] + 9 DO
                           BEGIN  K := SCNT[I] ;
                           IF K <> 0 THEN
                               BEGIN  S := S+K ;
                               WRITELN(SFL,INSTR[OP]:10,(I-PINX[OP]):5,
                                       K:15,WRF(SFL, K*SL,10,2):01,
                                       WRF(SFL, K*100.0/TC, 10, 2):0 );
                               END ;
                           END ;

                        IF S > 0 THEN
                           BEGIN
                           WRITELN(SFL,INSTR[OP]:10,'*':5,S:15,
                                       WRF(SFL, S*SL, 10, 2):01,
                                       WRF(SFL, S*100.0/S, 10, 2):01);
                           WRITELN(SFL) ;
                           END ;

                        IF OP <> PRET THEN
                           BEGIN  S := 0 ;
                           FOR I := QINX[OP] TO QINX[OP] + 9 DO
                              BEGIN  K := SCNT[I] ;
                              IF K <> 0 THEN
                                  BEGIN  S := S+K ;
                                  WRITELN(SFL, '#':7, INSTR[OP], (I-QINX
                                                K:15,WRF(SFL, K*SL,10,2)
                                                WRF(SFL, K*100.0/TC, 10,
                                  END ;
                               END;

                           WRITELN(SFL, '#':7, INSTR[OP], '*':5,S:15,
                                        WRF(SFL, S*SL, 10, 2):01,
                                        WRF(SFL, S*100.0/S, 10, 2):01 )
                           WRITELN(SFL) ;
                           END ;

                        END ;

                     PIND,PLDC,PLDO,PSRO,PSTO:
                        BEGIN  S := 0 ;
                        FOR I := PINX[OP] TO PINX[OP] + 5 DO
                           BEGIN  K := SCNT[I] ;
                           IF K <> 0 THEN
                              BEGIN  S := S+K ;

                                 WRITE(SFL,INSTR[OP]:10) ;
                                 CASE (I - PINX[OP]) OF
                                    0: IF OP = PLDC THEN WRITE(SFL,'N':5
                                       ELSE WRITE(SFL,'P':5) ;
                                    1: WRITE(SFL,'I':5) ;
                                    2: WRITE(SFL,'R':5) ;
                                    3: WRITE(SFL,'B':5) ;
                                    4: IF OP = PRET THEN WRITE(SFL,'C':5
                                          ELSE WRITE(SFL,'S':5) ;
                                    5: WRITE(SFL,'A':5)
                                 END  (* CASE K-PINX ... *) ;
                                 WRITELN(SFL,K:15, WRF(SFL, K*SL,10,2):0
                              END ;
                           END (* FOR I...*) ;
                        WRITELN(SFL,INSTR[OP]:10,'*':5,S:15,
                                    WRF(SFL, S*SL, 10, 2):01 ) ;
                        WRITELN(SFL) ;
                        END  (* PIND, ... ,PSTO *) ;

                     PCMP (*PEQU,PGEQ,PGRT,PLEQ,PLES,PNEQ*) :
                        BEGIN
                        FOR J := 0 TO 5 DO
                           BEGIN   S := 0;   OP := OPMAP[J];
                           FOR I := PINX[OP] TO PINX[OP] + 5 DO
                              BEGIN  K := SCNT[I] ;
                              IF K <> 0 THEN
                                 BEGIN  S := S+K ;

                                    WRITE(SFL,INSTR[OP]:10) ;
                                    CASE (I - PINX[OP]) OF
                                       0: WRITE(SFL,'A':5);
                                       1: WRITE(SFL,'I':5) ;
                                       2: WRITE(SFL,'R':5) ;
                                       3: WRITE(SFL,'B':5) ;
                                       4: WRITE(SFL,'S':5) ;
                                       5: WRITE(SFL,'M':5)
                                    END  (* CASE K-PINX ... *) ;
                                    WRITELN(SFL,K:15, WRF(SFL, K*SL,10,2
                                 END ;
                              END (* FOR I...*) ;

                           IF S > 0 THEN
                              BEGIN
                              WRITELN(SFL, INSTR[OP]:10, '*':5, S:15,
                                           WRF(SFL, S*SL, 10, 2):01,
                                           WRF(SFL, S*100.0/TC, 10, 2):0
                              WRITELN(SFL) ;
                              END (* IF S > 0 *);
                           END (*FOR J :=0... *);

                        WRITELN(SFL, INSTR[PCMP]:10, '*':5, TC:15,
                                     WRF(SFL, TC*SL, 10, 2):01,
                                     WRF(SFL, TC*100.0/TC, 10, 2):2 );
                        WRITELN(SFL);
                        END  (* PCMP ::= PEQU, ... ,PGRT *) ;

                     PCUP,PLOD,PSTR,PENT:
                        BEGIN  S := 0 ;
                        FOR I := 0 TO 9 DO
                           BEGIN  M := 0;
                           FOR J := 0 TO 5 DO
                              BEGIN  K := SCNT[PINX[OP]+I*6+J] ;
                              IF K <> 0 THEN
                                 BEGIN
                                 S := S+K ;   M := M+K;
                                 WRITE(SFL,INSTR[OP]:10,'    ') ;
                                    CASE J OF
                                    0: WRITE(SFL,'P') ;
                                    1: WRITE(SFL,'I') ;
                                    2: WRITE(SFL,'R') ;
                                    3: WRITE(SFL,'B') ;
                                    4: WRITE(SFL,'S') ;
                                    5: WRITE(SFL,'A')
                                    END  (* CASE J *) ;
                                 WRITELN(SFL,',',I:1,K:13,
                                             WRF(SFL, K*SL,10,2):01 ) ;
                                 END ;
                              END (* FOR J := 0 TO 5 *);

                           IF M > 0 THEN
                              BEGIN
                              WRITELN(SFL, INSTR[OP]:10, '*,':6, I:1, M:
                                            WRF(SFL, M*SL, 10, 2):01,
                                            WRF(SFL, M*100.0/TC, 10, 2):
                              WRITELN(SFL);
                              END;

                           END ;

                           WRITELN(SFL,INSTR[OP]:10,'*,*':7,S:13,
                                       WRF(SFL, S*SL, 10, 2):01,
                                       WRF(SFL, S*100.0/S, 10, 2):01 );
                           WRITELN(SFL) ;

                        IF OP IN [PLOD, PSTR] THEN
                           BEGIN  S := 0 ;
                           FOR I := 0 TO 9 DO
                              BEGIN  M := 0;
                              FOR J := 0 TO 5 DO
                                 BEGIN  K := SCNT[QINX[OP]+I*6+J] ;
                                 IF K <> 0 THEN
                                    BEGIN
                                    S := S+K ;   M := M+K ;
                                    WRITE(SFL, '#':7, INSTR[OP],'    ')
                                       CASE J OF
                                       0: WRITE(SFL,'P') ;
                                       1: WRITE(SFL,'I') ;
                                       2: WRITE(SFL,'R') ;
                                       3: WRITE(SFL,'B') ;
                                       4: WRITE(SFL,'S') ;
                                       5: WRITE(SFL,'A')
                                       END  (* CASE J *) ;
                                    WRITELN(SFL,',',I:1,K:13,
                                                WRF(SFL, K*SL,10,2):01);
                                    END (* IF K > 0 *);

                                 END (* FOR J := 0 TO 5 *);

                              IF M > 0 THEN
                                 BEGIN
                                 WRITELN(SFL, '#':7, INSTR[OP], '*,':6,
                                              M:13,
                                              WRF(SFL, M*SL, 10 ,2):01,
                                              WRF(SFL, M*100.0/TC,10,2):
                                 WRITELN(SFL);
                                 END ;


                              END ;

                           WRITELN(SFL, '#':7, INSTR[OP],'*,*':7, S:13,
                                        WRF(SFL, S*SL, 10, 2):01,
                                        WRF(SFL, S*100.0/S, 10, 2):01 );
                           WRITELN(SFL) ;
                           END ;

                        END  (* PCUP,PLOD,PSTR *) ;

                       PCSP:
                        BEGIN  S := 0 ;
                          FOR J := 0 TO SPCNT-1 DO
                          BEGIN  K := SCNT[PINX[OP]+J] ;    S:= S+K ;
                            IF K <> 0 THEN
                              WRITELN(SFL, INSTR[OP]:10, SPTABLE[J]:7,
                                           K:13, WRF(SFL, K*SL, 10, 2):0
                          END ;
                          WRITELN(SFL,INSTR[OP]:10,'*':5,S:15,
                                      WRF(SFL, S*SL, 10, 2):01) ;
                          WRITELN(SFL) ;
                        END (*PCSP*)
                  END  (* CASE OP *)

               ELSE (* NOT STAT1 *)

                  BEGIN    S := S+TC;  M := M+1;
                  WRITELN(SFL, M:6, ')', INSTR[OP]:5, TC:10,
                               WRF(SFL, TC*SL, 7,2):01, WRF(SFL, S*SL,10
                  END ;

               END (*IF TC > 0*);


            END (* FOR OP := PABI...*) ;
         END (*PRINTO*);


      BEGIN    PCNT[PNOP] := 0 ;   INX[0] := PNOP ;

      FOR OP := PABI TO PNOP-1 DO
         BEGIN   S := PCNT[OP] ;   K := -1 ;
         REPEAT    K := K+1   UNTIL  S >= PCNT[ INX[K] ] ;
         FOR I := OP-PABI DOWNTO K DO  INX[I+1] := INX[I] ;
         INX[K] := OP ;
         END (* FOR OP := PABI.. *) ;

      ENTROPY := 0.0 ;  S := 0 ;  M := 0 ;
      IF DETAILED THEN WRITE(SFL, '1   DETAILED')
      ELSE WRITE(SFL, '1   SUMMARY');

      WRITELN(SFL,' P_INSTRUCTION COUNTS, ABSOLUT AND RELATIVE FIGURES.'
      WRITELN(SFL, '    ( TOTAL OF: ', L:3, ' INSTRUCTIONS )' ) ;
      IF SORTOPC THEN WRITELN(SFL, '    ( SORTED BY COUNTS )')
      ELSE  WRITELN(SFL, '    ( SORTED BY OPCODES )' );
      WRITELN(SFL) ;  WRITELN(SFL) ;

      PRINTO;

      WRITELN(SFL) ;
      WRITELN(SFL, '    TOTAL COUNT = ', L:6 ,
                   ',   ENTROPY =', WRF(SFL, ENTROPY/LN(2.0),8, 3):01 );

      END (* SORTO *) ;      (*$D-*)

(*----------------------------------------------------------------------

BEGIN  (*PRINTCOUNT*)
   WRITELN(SFL);  WRITELN(SFL);
   IF GETSTAT THEN WRITELN(SFL, '    GETSTAT  -->  ENABLE ''COUNTING'' '
                                'PROCEDURES.');
   IF STAT1   THEN WRITELN(SFL, '    STAT1    -->  PRINT DETAILED BREAKD
                                'FOR EACH INSTRUCTION BY THE OPERAND TYP
   IF STAT2   THEN WRITELN(SFL, '    STAT2    -->  PRINT FREQUENCY OF AD
                                'OPERAND FOR LOD, STR, INC, DEC, IXA...
   IF STAT3   THEN WRITELN(SFL, '    STAT3    -->  PRINT FREQUENCY AND B
                                'DISTANCE FOR JUMP INSTRUCTIONS.');
   IF STAT4   THEN WRITELN(SFL, '    STAT4    -->  PRINT INSTRUCTION ',
                                'PAIR STATISTICS.');
   IF STAT5   THEN WRITELN(SFL, '    STAT5    -->  PRINT MATRIX OF ',
                               'INSTRUCTION PAIR FREQUENCIES.');
   IF STAT6   THEN WRITELN(SFL, '    STAT6    -->  GENERATE PUSH/POP, ',
                                'CALL/RETURN STACK TRACE.');
   IF STAT9   THEN WRITELN(SFL, '    STAT9    -->  PRINT FULL DETAILS OF
                                'THE ABOVE TABLES.');
   WRITELN(SFL);  WRITELN(SFL);


   IF STAT6 THEN  PRINT_STK_TRACE;                                (*++++

   (* PATCH UP COUNT TABLES *)
   OPMAP[0] := PEQU;   OPMAP[1] := PNEQ;
   OPMAP[2] := PLEQ;   OPMAP[3] := PLES;
   OPMAP[4] := PGEQ;   OPMAP[5] := PGRT;

   FOR I := 0 TO 5 DO  (*PEQU..PGRT*)
      BEGIN  OP := OPMAP[I];
      M := PCNT[PCMP]+PCNT[OP];   PCNT[OP] := 0;  PCNT[PCMP] := M;

      FOR J := 0 TO PNOP DO
         BEGIN
         M := CORTBL[PCMP,J]+CORTBL[OP,J];  CORTBL[OP,J] := 0;
         CORTBL[PCMP,J] := M;
         M := CORTBL[J,PCMP]+CORTBL[J,OP];  CORTBL[J,OP] := 0;
         CORTBL[J,PCMP] := M;
         END;

      END (*FOR I := 0... *);

   (* SORT AND/OR PRINT TABLES *)

   L := INSTRCNT;   SL := 100/L;  (*SCALE FACTOR*)

   SORTO(TRUE  (*OPCODE SORTED LIST*), FALSE (*SUMMARY TABLE*));

   IF STAT9 THEN  SORTO(FALSE (*ALPHABETIC LISTING*), FALSE ) ;

   IF STAT1 THEN SORTO(TRUE  (*OPCODE SORTED LIST*), TRUE  (*DETAILED TA

   IF STAT2 THEN
      BEGIN   WRITELN(SFL,'1') ;
      FOR OP := PABI TO PSTR DO       (* PSTR = 61 <= 63 *)
         IF PCNT[OP] > 0 THEN
            IF OP IN [PNEW,PINC,PDEC,PIND,PLDA,PLOD,PSTR,PCSP,PMOV,PIXA,
               THEN
               BEGIN  M := PCNT[OP];  WRITELN(SFL) ; WRITELN(SFL) ;
               WRITELN(SFL, '-->':4, INSTR[OP]:4,
                           '   (VALUE      COUNT      CUMUL.C.)',
                            ',   TOTAL COUNT: ',M:7,
                            WRF(SFL, PCNT[OP]*SL, 7, 2):01) ;
               WRITELN(SFL) ;
               PTR := ACNT[OP] ;    S:= 0 ;   J := 0 ;   I := 0 ;   K :=
                  REPEAT
                  WITH PTR@ DO
                      BEGIN
                      IF OP IN [PLOD,PSTR,PLDA,PLDC] THEN
                         IF VAL < K THEN
                            BEGIN  I := I+CNT ;  S := S+CNT ;
                            IF CNT > 0 THEN  J := J+1 ;
                            PTR := NXT ;
                            END
                         ELSE
                            BEGIN
                            WRITELN(SFL, K DIV 2:16, I:8,
                                         WRF(SFL, I*100.0/M, 8, 2):0,
                                         WRF(SFL, S*100.0/M, 10, 2):0 )
                            I := 0 ;  K := K*2 ;
                            END

                      ELSE (* NOT (OP IN [... *)

                         BEGIN
                         IF CNT > 0 THEN
                            BEGIN   J := J+1 ;    S := S+CNT ;
                            IF OP = PCSP THEN  WRITE(SFL, SPTABLE[VAL]:1
                            ELSE  WRITE(SFL, VAL:16);
                            WRITELN(SFL, CNT:8, WRF(SFL, CNT*100.0/M, 8,
                                         WRF(SFL, S*100.0/M, 10, 2):0 )
                            END ;
                         PTR := NXT ;
                         END ;

                      END ;
                   UNTIL (PTR = NIL) OR (S = M) OR (K >= 1073741824)  ;

                IF OP IN [PLOD,PSTR,PLDA,PLDC] THEN
                   WRITELN(SFL, K DIV 2:16, I:8, WRF(SFL, I*100.0/M, 8,
                                WRF(SFL, S*100.0/ PCNT[OP], 10, 2):01);
                WRITELN(SFL);
                WRITELN(SFL, '     COUNT OF DISTINCT VALUES: ', J:3) ;

               END (* FOR OP := PABI TO ...*) ;

      END (* STAT2 *) ;


   IF STAT3 THEN
      BEGIN  (* PRINT BRANCH DISTANCES *)
      IF NXTUJP > 0 THEN  BEGIN  OP := PUJP;  SORTJ(0, NXTUJP-1)  END;
      IF NXTFJP < MAXLBLCNT THEN
         BEGIN  OP := PFJP;  SORTJ(NXTFJP+1, MAXLBLCNT) END;
      END (* STAT3 *) ;


   IF STAT4 THEN SORTP ;   (* SORTED LIST OF THE MOST FREQUENT PAIRS *)

   IF STAT5 THEN

      BEGIN   (* INSTRUCTION PAIR TABLES *)

      FOR COLS := 0 TO 30 DO COLNDX[COLS] := 0 ;

      WRITE(SFL,'1INSTRUCTION_PAIR FREQUENCY TABLE') ;
      WRITELN(SFL,'   (ROW  PERCENTAGES)') ;  WRITELN(SFL) ;
        FOR I := PABI TO PNOP DO
           BEGIN  PINX[I] := 0 ;
           FOR J := PABI TO PNOP DO
              BEGIN  PINX[I] := PINX[I]+CORTBL[I,J] ;
              "CORTBL[I,J] := CORTBL[I,J]*100;"
              END ;
           END ;

        K := PABI ;
        WRITELN(SFL) ;
        WHILE K < PNOP DO (* LOOP FOR FRAMES *)
           BEGIN  COLS := 0 ;
           (* PRINT FRAME HEADER *)
           WRITE(SFL,' ':14) ;
           WHILE (COLS <= 15) AND (K < PNOP) DO
              BEGIN
              IF PINX[K] > 0 THEN
                 BEGIN
                 COLNDX[COLS] := K ;  WRITE(SFL,INSTR[K]:7) ;
                 COLS := COLS+1 ;
                 END ;
              K := K+1 ;
              END ;
           WRITELN(SFL (*TERMINATE HEADER LINE*) ) ;
           (* PRINT BODY OF THE FRAME *)
           IF COLS > 0 THEN
              BEGIN  WRITELN(SFL (*SPACE*) ) ;
              FOR I := PABI TO PNOP DO (* REPEAT FOR EACH LINE *)
                 IF PINX[I] > 0 THEN
                    BEGIN  J := 0 ;
                    WHILE (J < COLS) AND (CORTBL[I,COLNDX[J]] = 0) DO  J
                    IF J < COLS THEN
                       BEGIN  L := PINX[I] ;
                       WRITE(SFL, WRF(SFL, PINX[I]*SL, 8, 2):0,')',INSTR
                       FOR J := 0 TO COLS-1 DO
                          WRITE(SFL, WRF(SFL, CORTBL[I,COLNDX[J]]*SL, 7,
                       WRITELN(SFL (* TERMINATE THIS LINE *) ) ;
                       END ;
                    END ;
              WRITELN(SFL,'1' (* SPACE *) ) ;
              END (* IF COLS...*) ;
           END (* WHILE K < PNOP *) ;

      IF STAT9 THEN
         BEGIN  (*MATRIX OF ABSOLUTE COUNTS *)
         WRITELN(SFL,'1INSTRUCTION_PAIR FREQUENCY TABLE   (ABSOLUTE COUN
         WRITELN(SFL) ;

         FOR I := PABI TO PNOP DO
            BEGIN  PINX[I] := 0 ;
            FOR J := PABI TO PNOP DO
               PINX[I] := PINX[I]+CORTBL[I,J] ;
            END ;
         K := PABI ;
         WRITELN(SFL) ;
         WHILE K < PNOP DO (* LOOP FOR FRAMES *)
            BEGIN  COLS := 0 ;
            (* PRINT FRAME HEADER *)
            WRITE(SFL,' ':16) ;
            WHILE (COLS <= 15) AND (K < PNOP) DO
               BEGIN
               IF PINX[K] > 0 THEN
                  BEGIN
                  COLNDX[COLS] := K ;  WRITE(SFL,INSTR[K]:7) ;
                  COLS := COLS+1 ;
                  END ;
               K := K+1 ;
               END ;
            WRITELN(SFL (*TERMINATE HEADER LINE*) ) ;
            (* PRINT BODY OF THE FRAME *)
            IF COLS > 0 THEN
               BEGIN  WRITELN(SFL (*SPACE*) ) ;
               FOR I := PABI TO PNOP DO (* REPEAT FOR EACH LINE *)
                  IF PINX[I] > 0 THEN
                     BEGIN  J := 0 ;
                     WHILE (J < COLS) AND (CORTBL[I,COLNDX[J]] = 0) DO
                     IF J < COLS THEN
                        BEGIN
                        WRITE(SFL,PINX[I]:9,')',INSTR[I]:5) ;
                        FOR J := 0 TO COLS-1 DO
                           WRITE(SFL,CORTBL[I,COLNDX[J]]:7) ;
                        WRITELN(SFL (* TERMINATE THIS LINE *) ) ;
                        END ;
                     END ;
               WRITELN(SFL,'1' (* SPACE *) ) ;
               END (* IF COLS...*) ;
            END (* WHILE K <= PLCI *) ;

         END (*STAT9*) ;

      END (* STAT5 *) ;

END  (* PRINTCOUNTS *) ;
(*----------------------------------------------------------------------

PROCEDURE LOAD;
   VAR
      " ICP,RCP,SCP,BCP,MCP  : ADDRESS; "(*POINTERS TO NEXT FREE POSITIO
        I  :  INTEGER ;     CH  :  CHAR ;
        NXTPROC, CURPROC  : MINPROC..MAXPROC ;
        LABELVALUE: ADDRESS;
        NAME: SHRTALFA ;  PROCNAME : ALFA ;
        LABELTAB      : ARRAY [LBLRNG] OF LABELREC ;
        PROCSZE :       ARRAY [MINPROC..MAXPROC] OF 0..MAXADR  ;

   PROCEDURE INIT;
      VAR I, J : INTEGER;
   BEGIN INSTR[PABI]:='ABI'; INSTR[PABR]:='ABR';
         INSTR[PADI]:='ADI'; INSTR[PADR]:='ADR';
         INSTR[PAND]:='AND'; INSTR[PCHK]:='CHK';
         INSTR[PCHR]:='CHR'; INSTR[PCSP]:='CSP';
         INSTR[PCUP]:='CUP'; INSTR[PDEC]:='DEC';
         INSTR[PDEF]:='DEF'; INSTR[PDIF]:='DIF';
         INSTR[PDVI]:='DVI'; INSTR[PDVR]:='DVR';
         INSTR[PENT]:='ENT'; INSTR[PEOF]:='EOF';
         INSTR[PEQU]:='EQU'; INSTR[PFJP]:='FJP';
         INSTR[PFLO]:='FLO'; INSTR[PFLT]:='FLT';
         INSTR[PGEQ]:='GEQ'; INSTR[PGRT]:='GRT';
         INSTR[PINC]:='INC'; INSTR[PIND]:='IND';
         INSTR[PINN]:='INN'; INSTR[PINT]:='INT';
         INSTR[PIOR]:='IOR'; INSTR[PIXA]:='IXA';
         INSTR[PLAO]:='LAO'; INSTR[PLCA]:='LCA';
         INSTR[PLDA]:='LDA'; INSTR[PLDC]:='LDC';
         INSTR[PLDO]:='LDO'; INSTR[PLEQ]:='LEQ';
         INSTR[PLES]:='LES'; INSTR[PLOC]:='LOC';
         INSTR[PLOD]:='LOD'; INSTR[PMOD]:='MOD';
         INSTR[PMOV]:='MOV'; INSTR[PMPI]:='MPI';
         INSTR[PMPR]:='MPR'; INSTR[PMST]:='MST';
         INSTR[PNEQ]:='NEQ'; INSTR[PNEW]:='NEW';
         INSTR[PNGI]:='NGI'; INSTR[PNGR]:='NGR';
         INSTR[PNOT]:='NOT'; INSTR[PODD]:='ODD';
         INSTR[PORD]:='ORD'; INSTR[PPRE]:='PRE';
         INSTR[PRET]:='RET'; INSTR[PRST]:='RST';
         INSTR[PSAV]:='SAV'; INSTR[PSBI]:='SBI';
         INSTR[PSBR]:='SBR'; INSTR[PSGS]:='SGS';
         INSTR[PSQI]:='SQI'; INSTR[PSQR]:='SQR';
         INSTR[PSRO]:='SRO'; INSTR[PSTO]:='STO';
         INSTR[PSTP]:='STP'; INSTR[PSTR]:='STR';
         INSTR[PSUC]:='SUC'; INSTR[PTOF]:='TOF';
         INSTR[PTON]:='TON'; INSTR[PTRC]:='TRC';
         INSTR[PUJP]:='UJP'; INSTR[PUNI]:='UNI';
         INSTR[PXJP]:='XJP'; INSTR[PLCI]:='LCI';
         INSTR[PBGN]:='BGN'; INSTR[PCMP]:='CMP';

         SPTABLE[ 0]:='GET'; SPTABLE[ 1]:='PUT';
         SPTABLE[ 2]:='RST'; SPTABLE[ 3]:='RLN';
         SPTABLE[ 4]:='NEW'; SPTABLE[ 5]:='WLN';
         SPTABLE[ 6]:='WRS'; SPTABLE[ 7]:='ELN';
         SPTABLE[ 8]:='WRI'; SPTABLE[ 9]:='WRR';
         SPTABLE[10]:='WRC'; SPTABLE[11]:='RDI';
         SPTABLE[12]:='RDR'; SPTABLE[13]:='RDC';
         SPTABLE[14]:='SIN'; SPTABLE[15]:='COS';
         SPTABLE[16]:='EXP'; SPTABLE[17]:='LOG';
         SPTABLE[18]:='SQT'; SPTABLE[19]:='ATN';
         SPTABLE[20]:='SAV'; SPTABLE[21]:='XIT';
         SPTABLE[22]:='RES'; SPTABLE[23]:='REW';
         SPTABLE[24]:='EOF'; SPTABLE[25]:='CLK';
         SPTABLE[26]:='WRB'; SPTABLE[27]:='RDS';
         SPTABLE[28]:='SIO'; SPTABLE[29]:='EIO';
         SPTABLE[30]:='FDF'; SPTABLE[31]:='RDB';

         FOR CH := 'A' TO 'Z' DO IVECTOR[CH] := 0 ;

         IVECTOR['A'] := PABI ;  IVECTOR['C'] := PCHK ;
         IVECTOR['D'] := PDEC ;  IVECTOR['E'] := PENT ;
         IVECTOR['F'] := PFJP ;  IVECTOR['G'] := PGEQ ;
         IVECTOR['I'] := PINC ;  IVECTOR['L'] := PLAO ;
         IVECTOR['M'] := PMOD ;  IVECTOR['N'] := PNEQ ;
         IVECTOR['O'] := PODD ;  IVECTOR['P'] := PPRE ;
         IVECTOR['R'] := PRET ;  IVECTOR['S'] := PSAV ;
         IVECTOR['T'] := PTON ;  IVECTOR['U'] := PUJP ;
         IVECTOR['X'] := PXJP ;

         NEEDOPNDS := [PCHK,PCSP,PCUP,PDEC,PENT,PEQU,PFJP,PGEQ,PGRT,PINC
                       PIXA,PLAO,PLCA,PLDA,PLDC,PLDO,PLEQ,PLES,PLOC,PLOD
                        + [PMOV,PMST,PNEQ,PNEW,PRET,PSRO,PSTO,PSTR,PUJP,
         PC:= 0;   EP := 0;  CPL := MAXSTK-1;
"""      ICP:= MAXSTK+1; FOR I:= ICP TO OVERI DO STORE[I].STYPE:= INT;
         RCP:= OVERI+1; FOR I:= RCP TO OVERR DO STORE[I].STYPE:= REEL;
         SCP:= OVERR+1; FOR I:= SCP TO OVERS DO STORE[I].STYPE:= SETT;
         BCP:= OVERS+2; FOR I:= OVERS+1 TO OVERB DO STORE[I].STYPE:= IN
         MCP:= OVERB+1; FOR I:= MCP TO OVERM DO STORE[I].STYPE:= INT; "

         STYPE[MAXSTK] := UNDEF;  STYPE[0] := UNDEF;
         NAME := BLNK3 ;

         FOR I := PABI TO PNOP DO
            BEGIN
            NEW(ACNT[I]) ;
            ACNT[I]@.VAL := MAXINT ;  ACNT[I]@.NXT := NIL ;  ACNT[I]@.CN
            END ;

         FOR I:= MINPROC TO MAXPROC DO
             WITH LABELTAB[I] DO BEGIN VAL:=-1; ST:= ENTERED END;

         CURLVL := 0;
      """NUMERICS := ['0','1','2','3','4','5','6','7','8','9'] ; """
         NXTPROC := MINPROC ;   LOADING := TRUE ;  INTERPRETING := FALSE
         NXTFJP := MAXLBLCNT ;  NXTUJP := 0 ;
         TRCE := FALSE  ;  DMP := FALSE  ;
         GETSTAT := FALSE;  STAT9 := FALSE;  STAT1 := FALSE;  STAT4 := F
         STAT2 := FALSE;   STAT3 := FALSE;  STAT5 := FALSE;  STAT6 := FA

         FOR I := 0 TO 9 DO  (*INITIALIZE TIME/DATE*)
             BEGIN
             STORE[TIMEDATELOC+I].VI := ORD(DATE[I+1]) ;
             STYPE[TIMEDATELOC+I] := INT;
             STORE[TIMEDATELOC+10+I].VI := ORD(TIME[I+1]);
             STYPE[TIMEDATELOC+10+I] := INT;
             END;

         IF OSPARM = NIL THEN
            STORE[OSPARMLOC].VI := NILVAL
         ELSE
            WITH OSPARM@ DO
               BEGIN
               FOR I := LENGTH TO 1 DO
                  BEGIN  NP := NP-1;
                  STORE[NP].VI := ORD(STRING[I]);  STYPE[NP] := INT;
                  END;
               NP := NP-1;
               STORE[NP].VI := LENGTH;  STYPE[NP] := INT;
               STORE[OSPARMLOC].VI := NP;
               END (* WITH OSPARM... *);

         STYPE[OSPARMLOC] := ADR;


         IF STAT6 THEN  BEGIN  REWRITE(TRFILE); WRITELN(TRFILE)  END;  (

   END;(*INIT*)
(*----------------------------------------------------------------------

   PROCEDURE ERRORL(STRING: BETA); (*ERROR IN LOADING*)
   BEGIN WRITELN() ;
         WRITELN(OUTPUT,'>>>>  ':10, STRING); EXIT(1001) (*EXIT INTERPRE
   END; (*ERRORL*)
(*----------------------------------------------------------------------

   PROCEDURE BRDIST(DIST: INTEGER) ;   (*TO RECORD BRANCH DISTANCES*)
      VAR I : INTEGER ;
      BEGIN   (* TO RECORD 'BRANCH DISTANCE' OF A BRANCH INSTRUCTION *)
      IF OP = PFJP THEN

         IF NXTFJP = NXTUJP THEN ERRORL(' BRANCH TABLE OVRFL.')
         ELSE
            BEGIN   BDCNT[NXTFJP].VAL := DIST ;   I := MAXLBLCNT+1 ;
            REPEAT  I := I-1  UNTIL BDCNT[I].VAL = DIST ;
            IF I = NXTFJP THEN  NXTFJP := NXTFJP-1 ;
            BDCNT[I].CNT := BDCNT[I].CNT+1  ;  P := I ;
            END

      ELSE IF OP = PUJP THEN

         IF NXTFJP = NXTUJP THEN ERRORL(' BRANCH TABLE OVRFL.')
         ELSE
            BEGIN   BDCNT[NXTUJP].VAL := DIST ;   I := -1 ;
            REPEAT  I := I+1  UNTIL BDCNT[I].VAL = DIST ;
            IF I = NXTUJP THEN  NXTUJP := NXTUJP+1 ;
            BDCNT[I].CNT := BDCNT[I].CNT+1  ;  P := I ;
            END ;

      END (*BRDIST*) ;
(*----------------------------------------------------------------------

   PROCEDURE UPDATE(X: LBLRNG); (*WHEN A LABEL DEFINITION LX IS FOUND*)
      VAR CURR,SUCC: -1..MAXPC; (*RESP. CURRENT ELEMENT AND SUCCESSOR EL
                                      OF A LIST OF FUTURE REFERENCE*)
          ENDLIST: BOOLEAN;
   BEGIN
      IF LABELTAB[X].ST=DEFINED THEN
         BEGIN  WRITELN(OUTPUT,X) ; ERRORL(' DUPLICATED LABEL   ')  END
      ELSE BEGIN
             IF LABELTAB[X].VAL<>-1 THEN (*FORWARD REFERENCE(S)*)
             BEGIN CURR:= LABELTAB[X].VAL; ENDLIST:= FALSE;
                REPEAT
                      WITH CODE[CURR] DO
                        BEGIN
                        IF STAT3 THEN
                           BEGIN
                           OP := OP1 MOD 256 ;  BRDIST(LABELVALUE-CURR)
                           IF OP IN [PUJP,PFJP] THEN
                              OP1 := OP + 65536*P ;   (*'P' IS SET BY 'B
                           END ;
                        SUCC := Q1 ;  Q1:= LABELVALUE ;
                        IF SUCC=-1 THEN ENDLIST:= TRUE
                                   ELSE CURR:= SUCC
                        END;
                UNTIL ENDLIST ;
             END;
             LABELTAB[X].ST:= DEFINED;
             LABELTAB[X].VAL:= LABELVALUE;
          END  ;
   END;(*UPDATE*)
(*----------------------------------------------------------------------

   FUNCTION GET_PROCID: LBLRNG ;       (* TO GET PROCEDURE NAME *)
      VAR  ALFALAB : ALFA ;  INTLAB : LBLRNG ;
      BEGIN  ALFALAB[1] := CH ;
      FOR INTLAB := 2 TO 8 DO READ(PFILE,ALFALAB[INTLAB]) ;
      INTLAB := MINPROC ;  PROCTAB[NXTPROC] := ALFALAB;
      WHILE ALFALAB <> PROCTAB[INTLAB] DO INTLAB := INTLAB+1 ;
      IF INTLAB = NXTPROC THEN NXTPROC := NXTPROC+1 ;
      IF ALFALAB = '$MAINBLK' THEN EP := PC ; (*RECORD ENTRY POINT *)
      IF NXTPROC > MAXPROC THEN
          BEGIN WRITELN(OUTPUT, ALFALAB:10, INTLAB) ;
          ERRORL(' TOO MANY PROCEDURES')
          END ;
      GET_PROCID := INTLAB ;
      END (* GET_PROCID*) ;
(*----------------------------------------------------------------------

   PROCEDURE SORTE ;      (* TO SORT/PRINT PROCEDURE SIZE DISTRIBUTION *
      VAR  I, J, K : 0..MAXPROC ;  L, N: ADDRESS ;
           INX :     ARRAY [0..MAXPROC] OF 0..MAXPROC ;
           LGTH :    ARRAY [0..MAXPROC] OF ADDRESS ;
      BEGIN

      PROCSZE[NXTPROC] := MAXADR ;   INX[0] := NXTPROC ;

      FOR J := MINPROC TO NXTPROC-1 DO
         BEGIN   L := PROCSZE[J]  ;   N := -1  ;

         REPEAT   N := N+1   UNTIL L < PROCSZE[ INX[N] ] ;

         FOR L := J DOWNTO N DO   INX[L+1] := INX[L] ;

         INX[N] := J ;
         END ;

      WRITELN(SFL) ;  WRITELN(SFL) ;
      WRITELN(SFL,'    PROCEDURE SIZE DISTRIBUTION, TOTAL COUNT =',NXTPR
      WRITELN(SFL);  WRITELN(SFL, '    LENGTH,     NAME,     DATA SIZE '
      WRITELN(SFL) ;   WRITELN(SFL) ;

      FOR J := MINPROC TO NXTPROC-1 DO
         WRITELN(SFL, PROCSZE[ INX[J] ]:10, PROCTAB[ INX[J] ]:12,
                       CODE[ LABELTAB[ INX[J] ].VAL ].Q1:10) ;

      END (*SORTE*) ;


(*----------------------------------------------------------------------

   PROCEDURE ASSEMBLE; FORWARD;
(*----------------------------------------------------------------------

   PROCEDURE GENERATE;(*GENERATE SEGMENT OF CODE*)
      VAR X: INTEGER; (* LABEL NUMBER *)
   BEGIN  RESET(PFILE) ;
      REPEAT    (* READ UNTIL LAST INSTRUCTION, 'STP' *)
         READ(PFILE,CH) ;  (* FIRST CHARACTER OF LINE *)
         IF CH = ' ' THEN
         BEGIN   (* NO LABEL FIELD *)
            ASSEMBLE
         END   (* CH = ' ' *)
         ELSE
         BEGIN   (* LABEL *)
            IF (CH = 'L') AND (PFILE@ >= '0') AND (PFILE@ <= '9') THEN
            BEGIN   (* STANDARD LABEL *)
               READ(PFILE,X,CH,CH) ;   (*READ NEXT NON BLANK CHAR*)
               IF CH = 'L' THEN   (* LAB *)
                  LABELVALUE := PC
               ELSE
               BEGIN   (* DEF *)
                  READ(PFILE,CH,CH,LABELVALUE)
               END   (* DEF *) ;
               UPDATE(X+MINLABEL) ;
               READLN(PFILE)
            END   (* STANDARD LABEL *)
            ELSE
            BEGIN   (* PROCEDURE OR FUNCTION *)
(*            PC := PC+1;     (* SAVE SPACE FOR PROC ID PTR *)
               LABELVALUE := PC ;   CURPROC := GET_PROCID ;
               UPDATE(CURPROC) ;
               READ(PFILE,CH) ; (*ADVANCE TO OPCODE FIELD*)
               ASSEMBLE
            END   (* PROCEDURE OR FUNCTION *)
         END   (* LABEL *)  ;
      UNTIL OP = PSTP ;
   END   (* GENERATE *) ;
(*----------------------------------------------------------------------

   PROCEDURE ASSEMBLE; (*TRANSLATE SYMBOLIC CODE INTO MACHINE CODE AND S
      VAR B :BOOLEAN;  R :REAL;  S :SET OF 0..63;
          C1 :CHAR;  I,J,S1,LB,UB :INTEGER;
(*----------------------------------------------------------------------

      PROCEDURE LOOKUP(X: LBLRNG); (* SEARCH IN LABEL TABLE*)
      BEGIN
          CASE LABELTAB[X].ST OF
          ENTERED: BEGIN Q:=LABELTAB[X].VAL;
                   LABELTAB[X].VAL:=PC
                   END;
          DEFINED: BEGIN  Q:= LABELTAB[X].VAL  ;
                   IF STAT3 THEN BRDIST(Q-PC) ;
                   END
          END(*CASE LABEL..*) ;
      END;(*LOOKUP*)
(*----------------------------------------------------------------------


      PROCEDURE GET_OPCDE;
      BEGIN     READ(PFILE,NAME) ;
         OP := IVECTOR[NAME[1]]-1 ;
         INSTR[PNOP] := NAME ;
         REPEAT  OP := OP+1  UNTIL (INSTR[OP] = NAME) ;
         IF OP > PLCI THEN
         BEGIN
            WRITELN(OUTPUT,' ILLEGAL OPCODE     ',NAME) ;
            OP := PTOF  (* NOP *)
         END ;
         IF OP <= 63 THEN
            IF (OP IN NEEDOPNDS) THEN
               REPEAT
                  READ(PFILE,CH) ;
               UNTIL (CH <> ' ') ;
      END; (*GET_OPCDE*)
(*----------------------------------------------------------------------

   BEGIN   (* ASSEMBLE *)
      P := 0;  Q := 0;  OP := 0; T := UNDEF ;
      GET_OPCDE;

      CASE OP OF  (* GET PARAMETERS T,P,Q *)

          PBGN:
             BEGIN  READ(PFILE, B, CH, B, CH, B, CH, HEADLN);  END;

          (*EQU,NEQ,GEQ,GRT,LEQ,LES*)
          PEQU,PGEQ,PGRT,PLEQ,PLES,PNEQ :
                        BEGIN CASE CH OF
                              'A': P := 0;
                         'C', 'I': P := 1;
                              'R': P := 2;
                              'B': P := 3;
                              'S': P := 4;
                              'M' :BEGIN P := 5;
                                     READ(PFILE, CH, Q)
                                   END
                              END
                          END;

          PLOD,PSTR:
             BEGIN
                CASE CH OF
                   'I','C': T := INT ;
                   'R': T := REEL ;
                   'B': T := BOOL ;
                   'S': T := SETT ;
                   'A': T := ADR
                END   (* CASE *) ;
                REPEAT
                   READ(PFILE,CH) ;
                UNTIL CH = ',' ;
                READ(PFILE,CH) ;
                P := 0 ;
                WHILE CH <> ',' DO
                BEGIN
                   P := P * 10 + ORD(CH) - ORD('0') ;
                   READ(PFILE,CH)
                END   (* WHILE *) ;
                READ(PFILE,Q)
             END   (* LOD,STR *) ;

          PSTO:
             CASE CH OF
                'I','C': T := INT ;
                'R': T := REEL ;
                'B': T := BOOL ;
                'S': T := SETT ;
                'A': T := ADR
             END   (* STO *) ;

          (* LDA *)
          PLDA:
             BEGIN
                P := ORD(CH) - ORD('0') ;
                READ(PFILE,CH) ;
                WHILE CH <> ',' DO
                BEGIN
                   P := P * 10 + ORD(CH) - ORD('0') ;
                   READ(PFILE,CH)
                END   (* WHILE *) ;
                READ(PFILE,Q)
             END   (* LDA *) ;

          PCUP:
             BEGIN
                CASE CH OF
                   'P': T := UNDEF ;
                   'I','C': T := INT ;
                   'R': T := REEL ;
                   'B': T := BOOL ;
                   'S': T := SETT ;
                   'A': T := ADR
                END   (* CASE *) ;
                READ(PFILE,CH,P,CH,CH) ;  (*THE FIRST CHAR OF PROCID*)
            """ IF ODD(P) THEN  ERRORL(' FP SAVE AREA REQ   '); """
                P := P DIV 2 ;
                LOOKUP(GET_PROCID) ;
             END   (* CUP *) ;

          PMST :
                  BEGIN
                  REPEAT
                     P := P * 10 + ORD(CH) - ORD('0') ;
                     READ(PFILE,CH) ;
                  UNTIL CH = ' ' ;
                  P := CURLVL-P;
                  END;

          PRET :
             BEGIN   PROCSZE[CURPROC] := PC+1- LABELTAB[CURPROC].VAL ;
                CASE CH OF
                   'P': T := UNDEF ;
                   'I','C': T := INT ;
                   'R': T := REEL ;
                   'B': T := BOOL ;
                   'S': T := SETT ;
                   'A': T := ADR
                END ;

             IF GETSTAT THEN
                IF IAC <> 0 THEN P := 1
                ELSE IF (GAC = 0) AND (LAC > 0) THEN P := 0
                ELSE IF (GAC > 0) AND (LAC = 0) THEN P := 2
                ELSE P := 3
             END ;

          PDEC,PINC,PIND,PLDO,PSRO :
             BEGIN
                CASE CH OF
                   'I','C': T := INT ;
                   'R': T := REEL ;
                   'A': T := ADR ;
                   'B': T := BOOL ;
                   'S': T := SETT
                END   (* CASE *) ;
                REPEAT
                   READ(PFILE,CH) ;
                UNTIL CH = ',' ;
                READ(PFILE,Q)
             END   (* LDO,SRO,IND,MOV,INC,DEC *) ;

          PIXA,PLAO,PLOC,PMOV :
             BEGIN
                Q := ORD(CH) - ORD('0') ;
                READ(PFILE,CH) ;
                WHILE CH <> ' ' DO
                BEGIN
                   Q := Q * 10 + ORD(CH) - ORD('0') ;
                   READ(PFILE,CH)
                END   (* WHILE *)
             END   (* LAO,IXA *) ;

          PFJP,PUJP:
             BEGIN  READ(PFILE,I) ;  LOOKUP(I+MINLABEL) ;  END ;

          PXJP:
            BEGIN  READ(PFILE,I);  LOOKUP(I+2+MINLABEL) ;
            CODE[PC].OP1 := OP ;   CODE[PC].Q1 := Q ;  PC := PC+1 ;
            LOOKUP(I+3+MINLABEL) ;
            CODE[PC].OP1 := 0 ;  CODE[PC].Q1 := Q ; PC := PC+1 ;
            LOOKUP(I+MINLABEL) ;
            CODE[PC].OP1 := 0 ;  CODE[PC].Q1 := Q ; PC := PC+1 ;
            LOOKUP(I+1+MINLABEL) ;
            END (*PXJP*) ;

          PENT:
             BEGIN
                GAC := 0;  IAC := 0;  LAC := 0;

                FOR I := MINLABEL TO MAXLABEL DO
                   BEGIN  LABELTAB[I].VAL := -1;  LABELTAB[I].ST := ENTE
                CASE CH OF
                   'P': T := UNDEF ;
                   'I','C': T := INT ;
                   'R': T := REEL ;
                   'B': T := BOOL ;
                   'S': T := SETT ;
                   'A': T := ADR
                END ;

             (* WHILE CH <> ',' DO READ(PFILE,CH) ;*)  (* GET LEVEL *)
                READ(PFILE, CH(*,*), P, CH, CH(*,L*), I) ;
                CURLVL := P ;         (*LEVEL OF THIS PROC*)
                LOOKUP(I+MINLABEL) ;  (*LABEL FOR DATA AREA*)
(*             WRITELN(OUTPUT, ' PROCID,  PC: ', PROCTAB[CURPROC],  PC:6
(*             CODE[PC-1].Q1 := CURPROC;
             END  (* PENT *) ;

          PCSP :
             BEGIN
                NAME[1] := CH ;
                READ(PFILE,NAME[2],NAME[3]) ;
                WHILE (NAME<>SPTABLE[Q]) AND (Q < SPCNT) DO  Q := Q+1 ;
                IF NAME <> SPTABLE[Q] THEN
                   BEGIN WRITE(NAME:5) ;ERRORL(' UNDEFINED CSP NAME ') E
             END   (* CSP *) ;

          PLDC :          BEGIN CASE CH OF  (*GET Q*)
                           'I' :BEGIN  P := 1;
                                   REPEAT
                                      READ(PFILE,CH) ;
                                   UNTIL CH = ',' ;
                                   READ(PFILE,I) ;
                                   Q := I
                                END;

                           'C' :BEGIN
                                   P := 1 ;
                                   READ(PFILE,CH) ;  READ(PFILE,CH) ;
                                   READ(PFILE,CH) ;
                                   Q := ORD(CH)
                                END   (* C *) ;

                           'R' :BEGIN  OP := PLCI ; P := 2;
                                   REPEAT
                                      READ(PFILE,CH) ;
                                   UNTIL CH = ',' ;
                                   READ(PFILE,R);
                                   STORE[CPL].VR := R;  Q := MAXSTK;
                                   STYPE[CPL]".STYPE" := REEL ;
                                   REPEAT  Q := Q-1
                                   UNTIL (STYPE[Q]".STYPE" = REEL) AND
                                         (STORE[Q].VR=R);
                                   IF Q=CPL THEN  CPL := CPL-1;
                               """ BEGIN  RCP := RCP+1;
                                      IF RCP=OVERR THEN
                                         ERRORL(' REAL TABLE OVERFLOW')
                                   END  """
                                END;

                           'N' :; (*P,Q = 0*)

                           'B' :BEGIN
                                   P := 3 ;
                                   REPEAT
                                      READ(PFILE,CH) ;
                                   UNTIL CH = ',' ;
                                   READ(PFILE,Q)
                                END   (* B *) ;

                           'S' :BEGIN  OP := PLCI ;   P := 4;
                                   S := [ ];
                                   REPEAT
                                      READ(PFILE,CH) ;
                                   UNTIL CH = '(' ;

                                   FOR I := 3 DOWNTO 0 DO
                                      BEGIN  J := I*16 ;
                                      READ(PFILE,S1,CH) ;
                                      WHILE S1 > 0 DO
                                         BEGIN
                                         IF ODD(S1) THEN S := S+[J] ;
                                         S1 := S1 DIV 2 ;  J := J+1 ;
                                         END ;
                                      END (* FOR I :=..*) ;

                                   STYPE[CPL]".STYPE" := SETT;
                                   STORE[CPL].VS := S;
                                   Q := MAXSTK;
                                   REPEAT  Q := Q-1
                                   UNTIL (STYPE[Q]".STYPE" = SETT) AND
                                         (STORE[Q].VS=S);
                                   IF Q=CPL THEN   CPL := CPL-1;
                              """  BEGIN  SCP := SCP+1;
                                      IF SCP=OVERS THEN
                                         ERRORL(' SET TABLE OVERFLOW ')
                                   END   """
                                END
                           END (*CASE*)
                        END;

          PCHK :        BEGIN  READ(PFILE,LB,UB);

                           CASE CH OF
                           'I','C': T := INT ;
                           'S':     T := SETT ;
                           'A':     T := ADR ;
                           'J':     T := INDEX
                           END ;

                        STORE[CPL-1].VI := LB;  STYPE[CPL-1] := INT;
                        STORE[CPL].VI := UB;  STYPE[CPL] := INT;
                        Q := MAXSTK;
                        REPEAT  Q := Q-2
                        UNTIL (STORE[Q].VI = LB) AND (STORE[Q+1].VI = UB
                        IF Q <= CPL THEN CPL := CPL-2;
                        END;

          PLCA :        BEGIN  READ(PFILE,CH);  (*CH = FIRST CHAR IN STR
                           I := 0;

                              REPEAT
                                 REPEAT
                                 STRBUF[I] := CH ;
                                 IF I = STRNGLEN THEN
                                    ERRORL(' STRING TABLE OVRFL.') ;
                                 I := I+1;  READ(PFILE,CH)
                                 UNTIL CH = '''' ;
                              READ(PFILE, CH);
                              UNTIL CH <> '''';

                           FOR I := I-1 DOWNTO 0 DO
                              BEGIN
                              STYPE[CPL]".STYPE" := INT;
                              STORE[CPL].VI := ORD(STRBUF[I]);
                              CPL := CPL-1;
                              END;

                           Q := CPL+1;
                        END;

          PNEW,PRST,PSAV :
             BEGIN  (* CHANGE TO CSP CALL *)    P := 0 ;
                IF OP = PNEW THEN
                   REPEAT  (* GET LENGTH *)
                      Q := Q * 10 + ORD(CH) - ORD('0') ;
                      READ(PFILE,CH) ;
                   UNTIL CH = ' ' ;
              " OP := PCSP ;
                WHILE (NAME <> SPTABLE[Q]) AND (Q < 24) DO Q := Q + 1 ;
                IF NAME <> SPTABLE[Q] THEN
                   BEGIN WRITELN(OUTPUT, NAME:8) ;
                   ERRORL(' UNDEFINED CSP NAME ')
                   END; "
             END   (* SAV,NEW,RST *) ;
          PTON: DMP := TRUE


      END; (*CASE*)

      READLN(PFILE);
      (* STORE INSTRUCTION *)

      IF (OP <> PLOC) THEN
            BEGIN
            WITH CODE[PC] DO
               BEGIN  OP1 := OP+ (65536)*P + 256*ORD(T);  Q1 := Q;
               IF DMP THEN
                 WRITELN(OUTPUT, ',  PC: ',PC:5,' OP =',INSTR[OP]:4,
                                 '  (', OP:3, '  T: ', T:1, '  P: ', P:4
                                 '  Q: ',Q:6, ')' );
               END;

            IF GETSTAT THEN  COUNT ;
            PC := PC+1;  INSTRCNT := INSTRCNT+1 ;
            IF PC > CPL THEN  ERRORL(' CODE AREA OVERFLOW ');
            END ;

   END; (*ASSEMBLE*)
(*----------------------------------------------------------------------

BEGIN (*LOAD*)
   INIT ;      (* INITIALIZE FOR LOADING THE P_PROGRAM *)
   INSTRCNT := 0 ;
   IF GETSTAT THEN  CLEARCOUNTS
   ELSE
      BEGIN
      STAT5 := FALSE ;  STAT3 := FALSE ;  STAT2 := FALSE ;  STAT4 := FAL
      END ;

   GENERATE;   (* GENERATE THE P_PROGRAM SEGMENT *)

   FOR I := MINPROC TO NXTPROC-1 DO
      WITH LABELTAB[I] DO
      IF ST <> DEFINED THEN
         BEGIN  WRITELN(OUTPUT, ' ':4, PROCTAB[I]:14,I:5) ;
         ERRORL(' UNDEFINED PROC.    ');
         END;

   IF DMP THEN
      FOR I := 0 TO PC-1  DO
         WITH CODE [I] DO
         BEGIN
            OP :=OP1 MOD 256;
            P := OP1 DIV 65536;   T := CHR((OP1 DIV 256) MOD 256);   Q :
            WRITELN(OUTPUT, ',  PC: ',  I:5, ' OP =', INSTR[OP]:4, '  ('
                            '  T: ', T:1, '  P: ', P:4,'  Q: ',Q:6, ')'
         END;

   TIMER := CLOCK(1);
   PRINT_HEADLN(OUTPUT);

   IF GETSTAT THEN
      BEGIN   REWRITE(SFL);  PRINT_HEADLN(SFL);  SORTE;  PRINTCOUNTS;  E

   IF PC >= CPL  THEN  ERRORL(' PROGRAM TOO LARGE. ');
   IF EP = 0  THEN  ERRORL(' NO ENTRY POINT.    ');

END; (*LOAD*)

(*----------------------------------------------------------------------


PROCEDURE PMD;
   VAR S :INTEGER; I: INTEGER;

   PROCEDURE PT;
   BEGIN
   IF I >= 5 THEN
      BEGIN  WRITELN(OUTPUT);   WRITE(OUTPUT, ' ':5);  I := 0 END;
   WRITE(S:6);
   IF (STYPE[S] < UNDEF) OR (STYPE[S] > MARK) THEN
       BEGIN
       REPEAT S:=S-1
       UNTIL  (S <= 0) OR ((STYPE[S] >= UNDEF) AND (STYPE[S] <= MARK));
       S := S+1;
       WRITE(OUTPUT, '  <G>', S:5);
       END
   ELSE
      CASE STYPE[S]".STYPE" OF
          UNDEF: BEGIN
                    REPEAT S := S-1 UNTIL (S <= 0) OR (STYPE[S] <> UNDEF
                    S := S+1;
                    WRITE(OUTPUT,'  <U>',S:5)
                 END;
          INT  : WRITE(STORE[S].VI:10);
          REEL : WRITE(STORE[S].VR:10);
          BOOL : IF STORE[S].VB THEN
                    WRITE(OUTPUT,' TRUE ':10)
                 ELSE  WRITE(OUTPUT,' FALSE ':10);
          SETT : WRITE(OUTPUT,' SET ':10) (* WRITE(STORE[S].VS:21 OCT) *
          ADR  : WRITE(OUTPUT,' @  ',STORE[S].VA:6);
          MARK : WRITE(OUTPUT,' .M.',STORE[S].VM:6)
      END; (*CASE*)
      S := S - 1;
      I := I + 1;
   END; (*PT*)

   BEGIN
   WRITELN(OUTPUT);
   WRITELN(OUTPUT, '    ***>  PSW: ');  WRITELN(OUTPUT);
   WRITELN(OUTPUT);
   WRITE(OUTPUT, '    PC: ',PC-1:5,' OP =',INSTR[OP]:4,'  (', OP:3,
                 '  T: ', T:1, '  P: ', P:4,'  Q: ',Q:6, '),  SP =',SP:5
                 '  MP =',MP:5,'  NP =', NP:5,'  INSTRCNT = ',INSTRCNT:6
   WRITELN(OUTPUT); WRITELN(OUTPUT);
   WRITELN(OUTPUT, '    ***>  STACK CONTENTS: ');  WRITELN(OUTPUT);

   S := SP;  I := 6;
   WHILE S > 0 DO PT;
   WRITELN(OUTPUT) ;
   S := CPL;   I := 6;
   IF S >= NP THEN
      BEGIN  WRITELN(OUTPUT);  WRITELN(OUTPUT, '    ***>  HEAP CONTENTS:
      WRITELN(OUTPUT) ;
      END ;
   WHILE S>=NP DO PT;
   WRITELN(OUTPUT);  WRITELN(OUTPUT, '    ***>  END OF DUMP  ***>');
   WRITELN(OUTPUT);
END; (*PMD*)
(*----------------------------------------------------------------------

   PROCEDURE ERRORI0(AD: ADDRESS);

      BEGIN   WRITELN(OUTPUT);  WRITELN(OUTPUT);

      WRITELN(OUTPUT, '    ***>   ADDRESS, TYPE, VALUE: ',
                      AD:6, STYPE[AD]:4, STORE[AD].VI:10) ;
      WRITE(OUTPUT,'    ***>   LOC: ', AD:6, '  VALUE: ') ;
      IF (STYPE[AD] < UNDEF) OR (STYPE[AD] > MARK) THEN
         WRITE(OUTPUT,'.GARBAGE.':10)
      ELSE
        CASE STYPE[AD]".STYPE" OF
          UNDEF: WRITE(OUTPUT,'UNDEF':10);
          INT  : WRITE(STORE[AD].VI:10);
          REEL : WRITE(STORE[AD].VR:10);
          BOOL : IF STORE[AD].VB THEN
                    WRITE(OUTPUT,' TRUE ':10)
                 ELSE  WRITE(OUTPUT,' FALSE ':10);
          SETT : WRITE(OUTPUT,' SET ':10) (* WRITE(STORE[AD].VS:21 OCT)
          ADR  : WRITE(OUTPUT,' @  ',STORE[AD].VA:6);
          MARK : WRITE(OUTPUT,' .M.',STORE[AD].VM:6)
        END; (*CASE*)

      WRITELN(OUTPUT);  WRITELN(OUTPUT);
      END (*ERRORI0*);
(*----------------------------------------------------------------------

PROCEDURE ERRORI(STRING: BETA);
BEGIN  WRITELN(OUTPUT);  WRITELN(OUTPUT,'    ***>  ', STRING);
      PMD; "EXIT(1002)"
      RETCDE := 1002;  INTERPRETING := FALSE;
END;(*ERRORI*)
(*----------------------------------------------------------------------

FUNCTION BASE(LD :BIT4):INTEGER ;
   VAR AD :ADDRESS;
BEGIN  AD := MP;
   WHILE LD>0 DO
   BEGIN  AD := STORE[AD+1].VM;  LD := LD-1
   END;
   BASE := AD
END; (*BASE*)
(*----------------------------------------------------------------------

PROCEDURE PUSH ;
BEGIN
   SP := SP + 1 ;
   IF SP >= NP THEN
      ERRORI(' STORE OVERFLOW     ')
END   (* PUSH *) ;
(*----------------------------------------------------------------------


   PROCEDURE CALLSP;
      VAR LINE: BOOLEAN; ADPTR,ADELNT,AD: ADDRESS;
          I: INTEGER;
(*----------------------------------------------------------------------

      PROCEDURE READI(VAR F: TEXT);
         VAR AD: ADDRESS;
      BEGIN AD:= STORE[SP].VA;
         READ(F,STORE[AD].VI) ;
         STORE[STORE[SP-1].VA].VI := ORD(F@)  ;    (* UPDATE FILE BUF *)
         STYPE[AD]".STYPE" := INT ;
         SP := SP - 1
      END;(*READI*)
(*----------------------------------------------------------------------

      PROCEDURE READB(VAR F: TEXT);
         VAR AD: ADDRESS;
      BEGIN AD:= STORE[SP].VA;
         READ(F,STORE[AD].VB) ;
         STORE[STORE[SP-1].VA].VI := ORD(F@)  ;    (* UPDATE FILE BUF *)
         STYPE[AD]".STYPE" := BOOL;
         SP := SP - 1
      END;(*READB*)
(*----------------------------------------------------------------------

      PROCEDURE READR(VAR F: TEXT);
         VAR AD: ADDRESS;
      BEGIN AD:= STORE[SP].VA;
         READ(F,STORE[AD].VR) ;
         STORE[STORE[SP-1].VA].VI := ORD(F@)  ;     (* UPDATE FILE BUFFE
         STYPE[AD]".STYPE" := REEL ;
         SP := SP - 1
      END;(*READR*)
(*----------------------------------------------------------------------

      PROCEDURE READC(VAR F: TEXT);
         VAR C: CHAR; AD: ADDRESS;
      BEGIN
         READ(F,C) ;
         STORE[STORE[SP-1].VA].VI := ORD(F@)  ;    (* UPDATE FILE BUFFER
         AD := STORE[SP].VA ;
         STORE[AD].VI := ORD(C) ;
         STYPE[AD]".STYPE" := INT ;
         SP := SP - 1
      END;(*READC*)
(*----------------------------------------------------------------------

      PROCEDURE READSTR(VAR F: TEXT) ;
         VAR  C : CHAR ;  I :INTEGER ;  AD : ADDRESS ;
         BEGIN   AD := STORE[SP-1].VA ;
         FOR I := 0 TO STORE[SP].VI-1 DO
            BEGIN  READ(F,C) ;
            STORE[AD+I].VI := ORD(C) ;
            STYPE[AD+I]".STYPE" := INT ;
            END ;
         SP := SP-2 ;
         STORE[ STORE[SP].VA ].VI := ORD(F@) ;   (* UPDATE FILE BUFFER *
         END (* READSTR *) ;
(*----------------------------------------------------------------------

      PROCEDURE WRITESTR(VAR F: TEXT);
         VAR I,J,K: INTEGER;
             AD: ADDRESS;
      BEGIN AD:= STORE[SP-2].VA;
            K:= STORE[SP].VI; J:= STORE[SP-1].VI;
           (* J AND K ARE NUMBERS OF CHARACTERS *)
      (*  K <-- STRING LEN,   J <-- FIELD WIDTH  *)
      IF J > K THEN FOR I := 1 TO J-K DO WRITE(F,' ')
      ELSE  K := J ;
      FOR I := 0 TO K-1 DO WRITE(F,CHR(STORE[AD+I].VI)) ;
      (* IN THE INDEX OF STORE I HAS TO BE MULTIPLIED BY CHARSIZE *)
      SP := SP - 3
      END;(*WRITESTR*)
(*----------------------------------------------------------------------


      PROCEDURE GETFILE(VAR F: TEXT);
         VAR AD: ADDRESS;
      BEGIN AD:=STORE[SP].VA;
         GET(F) ;
         STORE[AD].VI := ORD(F@) ;
      "  SP := SP - 1  "
      END;(*GETFILE*)
(*----------------------------------------------------------------------

      PROCEDURE PUTFILE(VAR F: TEXT);
         VAR AD: ADDRESS;
      BEGIN AD:= STORE[SP].VA;
         F@ := CHR(STORE[AD].VI) ;
         PUT(F)  ;
      "  SP := SP - 1  "
      END;(*PUTFILE*)
(*----------------------------------------------------------------------

   BEGIN (*CALLSP*)
         CASE Q OF
              0 (*GET*) : CASE STORE[SP].VA OF
                               INPUTADR: GETFILE(INPUT);
                               OUTPUTADR: ERRORI(' GET ON OUTPUT FILE ')
                               PRDADR: GETFILE(PRD);
                               PRRADR: ERRORI(' GET ON PRR FILE    ')
                          END;
              1 (*PUT*) : CASE STORE[SP].VA OF
                               INPUTADR: ERRORI(' PUT ON INPUT FILE  ');
                               OUTPUTADR: PUTFILE(OUTPUT);
                               PRDADR: ERRORI(' PUT ON PRD FILE    ');
                               PRRADR: PUTFILE(PRR)
                          END;
              2 (*RST*) : BEGIN NP:= STORE[SP].VI; SP:=SP-1  END ;
              3 (*RLN*) : BEGIN
                             CASE STORE[SP].VA OF
                                INPUTADR: BEGIN READLN(INPUT);
                                          STORE[INPUTADR].VI := ORD(INPU
                                 OUTPUTADR: ERRORI(' READLN ON OUTPUT
                                 PRDADR: BEGIN READLN(PRD);
                                         STORE[PRDADR].VI := ORD(PRD@) E
                                 PRRADR: ERRORI(' READLN ON PRR FILE ');
                                 QRDADR: BEGIN READLN(QRD);
                                         STORE[QRDADR].VI := ORD(QRD@) E
                             END;
                          "  SP := SP-1  "
                          END;
               4 (*NEW*): BEGIN AD := NP - P ;
                          (*TOP OF STACK GIVES THE ADDRESS TO BE STORED
                                IF AD<= SP THEN
                                   ERRORI(' STORE OVERFLOW     ') ;
                                FOR I:=NP-1 DOWNTO AD DO
                                   STYPE[I]".STYPE":= UNDEF;
                                NP:= AD; AD:= STORE[SP].VA;
                                STORE[AD].VA:= NP;
                                STYPE[AD]".STYPE":=ADR;
                                SP := SP - 1
                          END;

               5 (*WLN*): BEGIN
                              CASE STORE[SP].VA OF
                                 INPUTADR: ERRORI(' WRITELN ON INPUT   '
                                 OUTPUTADR: WRITELN(OUTPUT);
                                 PRDADR: ERRORI(' WRITELN ON PRD FILE');
                                 PRRADR: WRITELN(PRR) ;
                                 QRRADR: WRITELN(QRR) ;
                              END;
                           "  SP:= SP-1  "
                           END;
               6 (*WRS*): CASE STORE[SP-3].VA OF
                               INPUTADR: ERRORI(' WRITE ON INPUT FILE');
                               OUTPUTADR: WRITESTR(OUTPUT);
                               PRDADR: ERRORI(' WRITE ON PRD FILE  ');
                               PRRADR: WRITESTR(PRR) ;
                               QRRADR: WRITESTR(QRR)
                          END;
               7 (*ELN*) : BEGIN
                               CASE STORE[SP].VA OF
                                  INPUTADR: LINE:= EOLN(INPUT);
                                  OUTPUTADR: ERRORI(' EOLN ON OUTPUT FIL
                                  PRDADR: LINE:=EOLN(PRD);
                                  PRRADR: ERRORI(' EOLN ON PRR FILE   ')
                               END;
                               STORE[SP].VB:= LINE;
                               STYPE[SP]".STYPE":= BOOL ;
                               SP := SP+1 ;
                           END;
               8 (*WRI*) : BEGIN
                               CASE STORE[SP-2].VA OF
                                  INPUTADR: ERRORI(' WRITE ON INPUT FILE
                                  OUTPUTADR: WRITE(OUTPUT,STORE[SP-1].VI
                                             STORE[SP].VI);
                                  PRDADR: ERRORI(' WRITE ON PRD FILE  ')
                                  PRRADR: WRITE(PRR,STORE[SP-1].VI:
                                                STORE[SP].VI);
                                  QRDADR: ERRORI(' WRITE ON QRD FILE  ')
                                  QRRADR: WRITE(QRR,STORE[SP-1].VI:
                                                STORE[SP].VI);
                               END;
                              SP:=SP-2
                           END;
               9 (*WRR*) : BEGIN
                               CASE STORE[SP-3].VA OF
                                  INPUTADR: ERRORI(' WRITE ON INPUT FILE
                                  OUTPUTADR: WRITE(OUTPUT,STORE[SP-2].VR
                                                   STORE[SP-1].VI:STORE[
                                  PRDADR: ERRORI(' WRITE ON PRD FILE  ')
                                  PRRADR: WRITE(PRR,STORE[SP-2].VR:
                                                STORE[SP-1].VI:STORE[SP]
                                  QRDADR: ERRORI(' WRITE ON QRD FILE  ')
                                  QRRADR: WRITE(QRR,STORE[SP-2].VR:
                                                STORE[SP-1].VI:STORE[SP]
                               END;
                               SP:=SP-3
                          END;
               10 (*WRC*):BEGIN
                              CASE STORE[SP-2].VA OF
                                 INPUTADR: ERRORI(' WRITE ON INPUT FILE'
                                 OUTPUTADR: WRITE(OUTPUT,CHR(STORE[SP-1]
                                                  STORE[SP].VI);
                                 PRDADR: ERRORI(' WRITE ON PRD FILE  ');
                                 PRRADR: WRITE(PRR,CHR(STORE[SP-1].VI):
                                               STORE[SP].VI) ;
                                 QRRADR: WRITE(QRR,CHR(STORE[SP-1].VI):
                                               STORE[SP].VI)
                              END;
                              SP:=SP-2
                          END;
               26(*WRB*) : BEGIN
                              "IF STORE[SP-1].VB THEN  STORE[SP-1].VI :=
                               ELSE  STORE[SP-1].VI := 0 ;"

                               CASE STORE[SP-2].VA OF
                                  INPUTADR: ERRORI(' WRITE ON INPUT FILE
                                  OUTPUTADR: WRITE(OUTPUT,STORE[SP-1].VB
                                             STORE[SP].VI);
                                  PRDADR: ERRORI(' WRITE ON PRD FILE  ')
                                  PRRADR: WRITE(PRR,STORE[SP-1].VB:
                                                STORE[SP].VI) ;
                                  QRDADR: ERRORI(' WRITE ON QRD FILE  ')
                                  QRRADR: WRITE(QRR,STORE[SP-1].VB:
                                                STORE[SP].VI) ;
                               END;
                              SP:=SP-2
                           END;
               11(*RDI*) : CASE STORE[SP-1].VA OF
                               INPUTADR: READI(INPUT);
                               OUTPUTADR: ERRORI(' READ ON OUTPUT FILE')
                               PRDADR: READI(PRD);
                               QRDADR: READI(QRD);
                               PRRADR, QRRADR: ERRORI(' READ ON WRONG FI
                           END;
               12(*RDR*) : CASE STORE[SP-1].VA OF
                               INPUTADR: READR(INPUT);
                               OUTPUTADR: ERRORI(' READ ON OUTPUT FILE')
                               PRDADR: READR(PRD);
                               QRDADR: READR(QRD);
                               PRRADR, QRRADR: ERRORI(' READ ON WRONG FI
                           END;
               31(*RDB*) : CASE STORE[SP-1].VA OF
                               INPUTADR: READB(INPUT);
                               OUTPUTADR: ERRORI(' READ ON OUTPUT FILE')
                               PRDADR: READB(PRD);
                               QRDADR: READB(QRD);
                               PRRADR, QRRADR: ERRORI(' READ ON WRONG FI
                           END;
               13(*RDC*):  CASE STORE[SP-1].VA OF
                               INPUTADR: READC(INPUT);
                               OUTPUTADR: ERRORI(' READ ON OUTPUT FILE')
                               PRDADR: READC(PRD);
                               QRRADR,
                               PRRADR: ERRORI(' READ ON PRR FILE   ') ;
                               QRDADR: READC(QRD);
                           END;
               27(*RDS*):  CASE STORE[SP-2].VA OF
                               INPUTADR: READSTR(INPUT);
                               OUTPUTADR: ERRORI(' READ ON OUTPUT FILE')
                               PRDADR: READSTR(PRD);
                               QRRADR,
                               PRRADR: ERRORI(' READ ON PRR FILE   ') ;
                               QRDADR: READSTR(QRD);
                           END;

               29(*EIO*): SP := SP-1;    (*POP THE FILE ADRE*)

               30(*FDF*): BEGIN ERRORI(' EXTERNAL FILE DEF. ')  END;

               14(*SIN*): BEGIN
                          (* AD := STORE[SP].VA ;
                             STYPE[SP]".STYPE" := REEL ; *)
                             STORE[SP].VR := SIN(STORE[SP].VR)
                          END   (* SIN *) ;
               15(*COS*): BEGIN
                          (* AD := STORE[SP].VA ;
                             STYPE[SP]".STYPE" := REEL ;  *)
                             STORE[SP].VR := COS(STORE[SP].VR)
                          END   (* COS *) ;
               16(*EXP*): BEGIN
                          (* AD := STORE[SP].VA ;
                             STYPE[SP]".STYPE" := REEL ; *)
                             STORE[SP].VR := EXP(STORE[SP].VR)
                          END   (* EXP *) ;
               17(*LOG*): BEGIN
                          (* AD := STORE[SP].VA ;
                             STYPE[SP]".STYPE" := REEL ; *)
                             STORE[SP].VR := LN(STORE[SP].VR)
                          END   (* LOG *) ;
               18(*SQT*): BEGIN
                          (* AD := STORE[SP].VA ;
                             STYPE[SP]".STYPE" := REEL ; *)
                             STORE[SP].VR := SQRT(STORE[SP].VR)
                          END   (* SQT *) ;
               19(*ATN*): BEGIN
                          (* AD := STORE[SP].VA ;
                             STYPE[SP]".STYPE" := REEL ;*)
                             STORE[SP].VR := ARCTAN(STORE[SP].VR)
                          END   (* ATN *) ;
               20(*SAV*): BEGIN AD:=STORE[SP].VA;
                             STYPE[AD]".STYPE":=ADR;
                             STORE[AD].VA:= NP;
                             SP:= SP-1
                          END;
               21(*XIT*): BEGIN  INTERPRETING := FALSE;
                          RETCDE := STORE[SP].VI;
                          END ;
               22 (* RES *):
                  BEGIN
                     CASE STORE[SP].VA OF
                        INPUTADR: RESET(INPUT) ;
                        OUTPUTADR: ERRORI(' RESET ON OUTPUT    ') ;
                        PRDADR: RESET(PRD) ;
                        QRRADR,PRRADR: ERRORI(' RESET ON PRR FILE  ') ;
                        QRDADR: RESET(QRD) ;
                     END   (* CASE STORE[SP].VA *) ;
                  "  SP := SP - 1  "
                  END   (* RES *) ;
               23 (* REW *):
                  BEGIN
                     CASE STORE[SP].VA OF
                        INPUTADR: ERRORI(' REWRITE ON INPUT   ') ;
                        OUTPUTADR: REWRITE(OUTPUT) ;
                        QRDADR,PRDADR: ERRORI(' REWRITE ON PRD FILE') ;
                        PRRADR: REWRITE(PRR) ;
                        QRRADR: REWRITE(QRR)
                     END   (* CASE STORE[SP].VA *) ;
                  "  SP := SP - 1   "
                  END   (* REW *) ;
               24 (* EOF *):
                  BEGIN
                     CASE STORE[SP].VA OF
                        INPUTADR: STORE[SP].VB := EOF(INPUT) ;
                        OUTPUTADR: ERRORI(' EOF ON OUTPUT      ') ;
                        PRDADR: STORE[SP].VB := EOF(PRD) ;
                        QRRADR,PRRADR: ERRORI(' EOF ON PRR FILE    ') ;
                        QRDADR: STORE[SP].VB := EOF(QRD) ;
                     END   (* CASE STORE[SP].VA *) ;
                     STYPE[SP]".STYPE" := BOOL ;  SP := SP+1 ;
                  END   (* EOF *) ;

               25 (* CLK *) :  STORE[SP].VI := CLOCK(STORE[SP].VI) ;

         END;(*CASE Q*)
   END;(*CALLSP*)
(*----------------------------------------------------------------------

PROCEDURE EX0;
   VAR AD,AD1 :ADDRESS;
       I,I1,I2,J  :INTEGER;  B :BOOLEAN;

   PROCEDURE COMPARE;
   BEGIN  I1 := STORE[SP].VA;  I2 := STORE[SP+1].VA;
      I := 0;  B := TRUE;
      WHILE B AND (I<>Q) DO
         IF STORE[I1+I].VI=STORE[I2+I].VI THEN I := I+1
         ELSE B := FALSE
   END; (*COMPARE*)

BEGIN   (* EXO *)
   (* IN THIS PROCEDURE Q MUST NOT BE CORRECTED *)
   CASE OP OF

                PABI:STORE[SP].VI := ABS(STORE[SP].VI);

                PABR:STORE[SP].VR := ABS(STORE[SP].VR);

                PADI:BEGIN  SP := SP-1;
                      STORE[SP].VI := STORE[SP].VI + STORE[SP+1].VI
                   END;

                PADR:BEGIN  SP := SP-1;
                      STORE[SP].VR := STORE[SP].VR + STORE[SP+1].VR
                   END;

                PAND:BEGIN  SP := SP-1;
                      STORE[SP].VB := STORE[SP].VB AND STORE[SP+1].VB
                   END;

                PCHK:IF(STORE[SP].VI < STORE[Q].VI)
                        OR (STORE[SP].VI > STORE[Q+1].VI) THEN
                           ERRORI(' VALUE OUT OF RANGE ');

                PCHR: (* NOTHING TO DO *) ;

                PCSP: CALLSP ;

                PCUP:BEGIN  (*P=NO. OF PARAMETERS, Q=ENTRY POINT*)
(*                   IF CTRACE  THEN
(*                      BEGIN
(*                      WRITELN(OUTPUT,'     I_CNT: ',INSTRCNT:6,
(*                                     ', SP: ',SP:5,',  NP: ', NP:5,
(*                                     ',  MP: ', MP:5 , ',  PC: ',  PC:
(*                                     ' OP =', INSTR[OP]:4, '  (', OP:3
(*                                     '  T: ', T:1, '  P: ', P:4,
(*                                     '  Q: ',Q:6, ') --> ',
(*                                     PROCTAB[CODE[Q-1].Q1] );
(*                      END  (* IF CTRCE *) ;
                      MP := SP-(P + (SAVEAREA-1));
                      STYPE[MP+3]".STYPE" := MARK;
                      STORE[MP+3].VM := PC;
                      PC := Q
                   END;

                PDEC:STORE[SP].VI := STORE[SP].VI - Q;

                PDIF:BEGIN  SP := SP-1;
                      STORE[SP].VS := STORE[SP].VS - STORE[SP+1].VS
                   END;

                PDVI:BEGIN  SP := SP-1;
                      STORE[SP].VI := STORE[SP].VI DIV STORE[SP+1].VI
                   END;

                PDVR:BEGIN  SP := SP-1;
                      STORE[SP].VR := STORE[SP].VR/STORE[SP+1].VR
                   END;

                PENT:BEGIN  J := MP+Q;  (*Q=LENGTH OF DATA SEG*)
                      IF J>NP THEN ERRORI(' STORE OVERFLOW     ');
                      STORE[MP+1].VM := DISPLAY[P] ;  DISPLAY[P] := MP ;
                  """ (*RESET TO UNDEFINED--MAY DECIDE TO REMOVE THIS TE
                      IF SP<INPUTADR THEN SP := PRDADR;
                      FOR I := SP+1 TO J DO STORE[I].STYPE := UNDEF; ""
                      STORE[MP+4].VM := CURLVL ;  SP := J;  CURLVL := P
                      IF STK_LMT < SP THEN STK_LMT := SP;
                   END;

                PEQU:BEGIN  SP := SP-1;
                      CASE P OF
                      0,1: STORE[SP].VB := STORE[SP].VI=STORE[SP+1].VI;
                        2: STORE[SP].VB := STORE[SP].VR=STORE[SP+1].VR;
                        3: STORE[SP].VB := STORE[SP].VB=STORE[SP+1].VB;
                        4: STORE[SP].VB := STORE[SP].VS=STORE[SP+1].VS;
                        5: BEGIN  COMPARE;
                              STORE[SP].VB := B;
                           END
                      END; (*CASE P*)
                      STYPE[SP]".STYPE" := BOOL
                   END;

                PFJP:BEGIN
                   IF NOT STORE[SP].VB THEN
                      BEGIN   PC := Q;
                      IF STAT3 THEN BDCNT[P].CNT := BDCNT[P].CNT+1
                      END ;
                   SP := SP-1
                   END;

                PFLO:BEGIN  STORE[SP-1].VR := STORE[SP-1].VI;
                      STYPE[SP-1]".STYPE" := REEL
                   END;

                PFLT:BEGIN  STORE[SP].VR := STORE[SP].VI;
                      STYPE[SP]".STYPE" := REEL
                   END;

                PGEQ:BEGIN  SP := SP-1;
                      CASE P OF
                      0,1: STORE[SP].VB := STORE[SP].VI>=STORE[SP+1].VI;
                        2: STORE[SP].VB := STORE[SP].VR>=STORE[SP+1].VR;
                        3: STORE[SP].VB := STORE[SP].VB>=STORE[SP+1].VB;
                        4: STORE[SP].VB := STORE[SP].VS>=STORE[SP+1].VS;
                        5: BEGIN COMPARE;
                              STORE[SP].VB := (STORE[I1+I].VI>=STORE[I2+
                                 OR B
                           END
                      END; (*CASE P*)
                      STYPE[SP]".STYPE" := BOOL
                   END;

                PGRT:BEGIN  SP := SP-1;
                      CASE P OF
                      0,1: STORE[SP].VB := STORE[SP].VI>STORE[SP+1].VI;
                        2: STORE[SP].VB := STORE[SP].VR>STORE[SP+1].VR;
                        3: STORE[SP].VB := STORE[SP].VB>STORE[SP+1].VB;
                        4: ERRORI(' SET INCLUSION      ');
                        5: BEGIN  COMPARE;
                              STORE[SP].VB := (STORE[I1+I].VI>STORE[I2+I
                                  NOT B
                           END
                      END; (*CASE P*)
                      STYPE[SP]".STYPE" := BOOL
                   END;

                PINC:BEGIN STORE[SP].VI := STORE[SP].VI + Q;
                     END ;

                PIND:BEGIN  AD := STORE[SP].VI + Q; (* Q IS # OF STORAGE
                      IF STYPE[AD]".STYPE"=UNDEF THEN
                         ERRORI(' VALUE UNDEFINED    ') ;
                      STORE[SP] := STORE[AD] ;    STYPE[SP] := STYPE[AD]
                   END;

                PINN:BEGIN  SP := SP-1;
                      STORE[SP].VB := STORE[SP].VI IN STORE[SP+1].VS;
                      STYPE[SP]".STYPE" := BOOL
                   END;

                PINT:BEGIN  SP := SP-1;
                      STORE[SP].VS := STORE[SP].VS *  STORE[SP+1].VS
                   END;

                PIOR:BEGIN  SP := SP-1;
                      STORE[SP].VB := STORE[SP].VB OR STORE[SP+1].VB
                   END;

                PIXA:BEGIN
                     IF STYPE[SP]".STYPE" = BOOL THEN
                        BEGIN
                        IF STORE[SP].VB THEN STORE[SP].VI := 1
                        ELSE  STORE[SP].VI := 0 ;
                        STYPE[SP]".STYPE" := INT ;
                        END ;
                     IF STYPE[SP]".STYPE" <> INT THEN
                        ERRORI(' NON INTEGER IXA ARG') ;
                     SP := SP-1; (* Q IS A NUMBER OF STORAGE UNITS *)
                      STORE[SP].VA := Q*STORE[SP+1].VI + STORE[SP].VA
                   END;

                PLAO:BEGIN  PUSH;
                      STORE[SP].VA := Q;
                      STYPE[SP]".STYPE" := ADR
                   END;

                PLCA:BEGIN  PUSH;
                      STORE[SP].VA := Q;
                      STYPE[SP]".STYPE" := ADR
                   END;

                PLDA:BEGIN  PUSH;
                      STORE[SP].VA := DISPLAY[P] + Q;
                      STYPE[SP]".STYPE" := ADR
                   END;

                PLDC:BEGIN  PUSH;
                      IF P=1 THEN
                         BEGIN  STORE[SP].VI := Q;
                         STYPE[SP]".STYPE" := INT
                         END ELSE
                      IF P=3 THEN
                         BEGIN  STORE[SP].VB := Q=1;
                         STYPE[SP]".STYPE" := BOOL
                         END
                      ELSE (*LOAD NIL*)
                         BEGIN  STORE[SP].VA := NILVAL;
                         STYPE[SP]".STYPE" := ADR
                         END
                   END;

                PLDO:BEGIN
                      IF STYPE[Q]".STYPE"=UNDEF THEN
                        ERRORI(' VALUE UNDEFINED    ') ;
                      IF STYPE[Q]".STYPE" <> T THEN
                         BEGIN  ERRORI0(AD);
                         ERRORI(' INCOMPATIBLE TYPE  ') ;
                         END;
                      PUSH;
                      STORE[SP] := STORE[Q];  STYPE[SP] := STYPE[Q];
                   END;

                PLEQ:BEGIN  SP := SP-1;
                      CASE P OF
                      0,1: STORE[SP].VB := STORE[SP].VI<=STORE[SP+1].VI;
                        2: STORE[SP].VB := STORE[SP].VR<=STORE[SP+1].VR;
                        3: STORE[SP].VB := STORE[SP].VB<=STORE[SP+1].VB;
                        4: STORE[SP].VB := STORE[SP].VS<=STORE[SP+1].VS;
                        5: BEGIN  COMPARE;
                              STORE[SP].VB := (STORE[I1+I].VI<=STORE[I2+
                                 OR B
                           END
                      END; (*CASE P*)
                      STYPE[SP]".STYPE" := BOOL
                   END;

                PLES:BEGIN  SP := SP-1;
                      CASE P OF
                      0,1: STORE[SP].VB := STORE[SP].VI<STORE[SP+1].VI;
                        2: STORE[SP].VB := STORE[SP].VR<STORE[SP+1].VR;
                        3: STORE[SP].VB := STORE[SP].VB<STORE[SP+1].VB;
                        5: BEGIN  COMPARE;
                              STORE[SP].VB := (STORE[I1+I].VI<STORE[I2+I
                                 NOT B
                           END
                      END; (*CASE P*)
                      STYPE[SP]".STYPE" := BOOL
                   END;


               PLOD:BEGIN  AD := DISPLAY[P] + Q;
                      IF STYPE[AD]".STYPE"=UNDEF THEN
                         ERRORI(' VALUE UNDEFINED    ') ;
                      IF STYPE[AD]".STYPE" <> T THEN
                         BEGIN  ERRORI0(AD);
                         ERRORI(' INCOMPATIBLE TYPE  ') ;
                         END;
                      PUSH;
                      STORE[SP] := STORE[AD];  STYPE[SP] := STYPE[AD];
                   END

   END  (* CASE *)
END   (* EX0 *) ;
(*----------------------------------------------------------------------

PROCEDURE EX1;
   VAR AD,AD1 :ADDRESS;
       I,I1,I2,J  :INTEGER;  B :BOOLEAN;

   PROCEDURE COMPARE;
   BEGIN  I1 := STORE[SP].VA;  I2 := STORE[SP+1].VA;
      I := 0;  B := TRUE;
      WHILE B AND (I<>Q) DO
         IF STORE[I1+I].VI=STORE[I2+I].VI THEN I := I+1
         ELSE B := FALSE
   END; (*COMPARE*)

BEGIN   (* EX1 *)
   (* IN THIS PROCEDURE Q MUST NOT BE CORRECTED *)
   CASE OP OF

                PMOD:BEGIN  SP := SP-1;
                      STORE[SP].VI := STORE[SP].VI MOD STORE[SP+1].VI
                   END;

                PMOV: BEGIN I1 := STORE[SP-1].VA; I2 := STORE[SP].VA;
                         SP := SP - 2 ;
                       FOR I := 0 TO Q-1 DO
                          BEGIN
                          STORE[I1+I] := STORE[I2+I]; STYPE[I1+I] := STY
                          END;
                      (* Q IS A NUMBER OF STORAGE UNITS *)
                    END;

                PMPI:BEGIN  SP := SP-1;
                      STORE[SP].VI := STORE[SP].VI * STORE[SP+1].VI
                   END;

                PMPR:BEGIN  SP := SP-1;
                      STORE[SP].VR := STORE[SP].VR * STORE[SP+1].VR
                   END;

                PMST:BEGIN (*P=LEVEL OF CALLED PROCEDURE , SET DL
                             SL WILL BE SET AT 'ENT', INCREMENT SP*)
                      STYPE[SP+1]".STYPE" := UNDEF;
                      (* THEN LENTH OF THIS ELEMENT IS
                        MAX(INTSIZE,REALSIZE,BOOLSIZE,CHARSIZE,PTRSIZE *
                      STYPE[SP+2]".STYPE" := MARK;
                      (* THE LENGTH OF THIS ELEMENT IS PTRSIZE *)
                      STYPE[SP+3]".STYPE" := MARK;
                      STORE[SP+3].VM := MP;
                      (* IDEM *)
                      "STYPE[SP+4].STYPE := UNDEF;"
                      (* IDEM *)
                      SP := SP+SAVEAREA ;
                   END;

                PNEQ:BEGIN  SP := SP-1;
                      CASE P OF
                      0,1: STORE[SP].VB := STORE[SP].VI<>STORE[SP+1].VI;
                        2: STORE[SP].VB := STORE[SP].VR<>STORE[SP+1].VR;
                        3: STORE[SP].VB := STORE[SP].VB<>STORE[SP+1].VB;
                        4: STORE[SP].VB := STORE[SP].VS<>STORE[SP+1].VS;
                        5: BEGIN  COMPARE;
                              STORE[SP].VB := NOT B;
                           END
                      END; (*CASE P*)
                      STYPE[SP]".STYPE" := BOOL
                   END;

                PNGI:STORE[SP].VI := -STORE[SP].VI;

                PNGR:STORE[SP].VR := -STORE[SP].VR;

                PNOT:STORE[SP].VB := NOT STORE[SP].VB;

                PODD:BEGIN  STORE[SP].VB := ODD(STORE[SP].VI);
                      STYPE[SP]".STYPE" := BOOL
                   END;

                PORD:
                     BEGIN
                        IF STYPE[SP]".STYPE" = BOOL THEN
                           BEGIN
                              IF STORE[SP].VB THEN  STORE[SP].VI := 1
                              ELSE STORE[SP].VI := 0 ;
                              STYPE[SP]".STYPE" := INT ;
                           END ;
                           IF STYPE[SP]".STYPE" <> INT THEN
                              ERRORI(' NON INT ARG FOR ORD') ;
                     END ;

                PNEW:      BEGIN AD := NP - Q ;
                           (*TOP OF STACK GIVES THE ADDRESS TO BE STORED
                                 IF AD<= SP THEN
                                    ERRORI(' STORE OVERFLOW     ') ;
                                 FOR I:=NP-1 DOWNTO AD DO
                                    STYPE[I]".STYPE":= UNDEF;
                                 NP:= AD; AD:= STORE[SP].VA;
                                 STORE[AD].VA:= NP;
                                 STYPE[AD]".STYPE":=ADR;
                                 SP := SP - 1;
                                 IF HEAP_LMT > NP THEN  HEAP_LMT := NP;
                           END(*PNEW*);

                PPRE: BEGIN  STORE[SP].VI := STORE[SP].VI-1; END;

                PRST:      BEGIN NP:= STORE[SP].VI; SP:=SP-1  END ;

                PSAV :     BEGIN AD:=STORE[SP].VA;
                              STYPE[AD]".STYPE":=ADR;
                              STORE[AD].VA:= NP;
                              SP:= SP-1
                           END(*PSAV*);

                PRET :
                     BEGIN
                        IF T = UNDEF THEN  SP := MP-1
                        ELSE
                          BEGIN SP := MP; "STORE[SP] := STORE[MP+FUNCRSL
                        PC:= STORE[MP+3].VM;
                        DISPLAY[CURLVL] := STORE[MP+1].VM ;  (*RESTORE D
                        CURLVL := STORE[MP+4].VM ;
                        MP:= STORE[MP+2].VM ;   (*=DISPLAY[CURLVL]*)
                     END  (*PRET*) ;

                PSBI:BEGIN SP := SP-1;
                      STORE[SP].VI := STORE[SP].VI - STORE[SP+1].VI
                   END;

                PSBR:BEGIN  SP := SP-1;
                      STORE[SP].VR := STORE[SP].VR - STORE[SP+1].VR
                   END ;

                PSGS:BEGIN  STORE[SP].VS := [STORE[SP].VI];
                      STYPE[SP]".STYPE" := SETT
                   END;

                PSQI:STORE[SP].VI := SQR(STORE[SP].VI);

                PSQR:STORE[SP].VR := SQR(STORE[SP].VR);

                PSRO: BEGIN
                      STORE[Q] := STORE[SP];  STYPE[Q] := STYPE[SP];
                      SP := SP-1
                      END;

                PSTO: BEGIN  AD := STORE[SP-1].VA;
                      STORE[AD] := STORE[SP];  STYPE[AD] := STYPE[SP];
                      SP := SP-2
                      END;

                PSTP: BEGIN  INTERPRETING := FALSE;  RETCDE := 0;  END;

                PSUC: BEGIN  STORE[SP].VI := STORE[SP].VI+1;   END;

                PSTR: BEGIN  AD := DISPLAY[P]+Q;
                      STORE[AD] := STORE[SP]; STYPE[AD] := STYPE[SP];
                      SP := SP-1
                      END;

                PTOF: TRCE := FALSE ;

                PTON: TRCE := TRUE ;

                PTRC: BEGIN STORE[SP].VI := TRUNC(STORE[SP].VR);
                      STYPE[SP]".STYPE" := INT ;
                      END;

                PUJP: BEGIN  PC := Q;
                      IF STAT3 THEN   BDCNT[P].CNT := BDCNT[P].CNT+1
                      END ;

                PUNI: BEGIN  SP := SP-1;
                      STORE[SP].VS := STORE[SP].VS +  STORE[SP+1].VS
                      END ;

                PXJP: BEGIN
                      IF STYPE[SP]".STYPE" <> INT THEN
                         ERRORI(' NON INT ARG FOR XJP') ;
                      I1 := CODE[PC].Q1 ; (*ASSUME OFF CASE TABLE RANGE*
                      I := STORE[SP].VI ;
                      IF I <= CODE[PC+2].Q1  THEN   (*CHECK AGAINS UPPER
                         BEGIN  I := I-CODE[PC+1].Q1 ; (*SUBTRACT LOWER
                         IF I >= 0 THEN  I1 := I+Q ; (*ADJUST PC IF IN R
                         END ;
                      PC := I1 ;   SP := SP-1 ;
                      END ;

                PLCI: BEGIN  PUSH; STORE[SP] := STORE[Q]; STYPE[SP] := S
                      END

       END (*CASE OP*)
END   (* EX1 *) ;

(*----------------------------------------------------------------------

BEGIN   (*PCODE_INTERPRETER*)   (*  M A I N  *)
   TIMER := 0;
   LOAD;  (* ASSEMBLES AND STORES CODE *)
   WRITELN(OUTPUT); (*FOR TESTING*)
   SP := LSTBUF;  MP := 0;  NP := CPL+1;
   STORE[1].VM := 0 ;  STORE[2].VM := 0 ;   (* SL AND DL FOR THE MAIN BL
   STORE[3].VM := PC-1 ;                    (* RETURN ADDRESS FOR MAINBL
   FOR P := 2 TO 10 DO DISPLAY[P] := -1 ;
   DISPLAY[1] := 0 ;  CURLVL := 1 ;
   PC := EP;   RETCDE := 0;  INSTRCNT := 0;  STK_LMT := 0;  HEAP_LMT :=
   STYPE[INPUTADR]".STYPE" := INT;
   STORE[INPUTADR].VI := ORD(INPUT@);
   STYPE[PRDADR]".STYPE":= INT;
   STORE[PRDADR].VI:= ORD(PRD@);
   STYPE[OUTPUTADR]".STYPE":= UNDEF;  STYPE[QRRADR]".STYPE" := UNDEF ;
   GETSTAT :=TRUE;
   IF GETSTAT THEN
     BEGIN
     STAT1:= TRUE ; STAT4:= TRUE ;  STAT2:= TRUE ; STAT3:= TRUE ; STAT5:
     END;

   INTERPRETING := TRUE;  LOADING := FALSE ;
   IF GETSTAT THEN  CLEARCOUNTS ;


   (* BEGIN INTERPRETING THE PROGRAM *)

   REPEAT   (* INTERPRET ALL INSTRUCTIONS *)
      WITH CODE[PC ] DO
         BEGIN   Q := Q1 ; OP := OP1 MOD 256;
         P := OP1 DIV (65536);  T := CHR((OP1 DIV 256) MOD 256);
         END;
      IF TRCE (*OR ((INSTRCNT MOD 1000) = 0)*) THEN
      BEGIN
         WRITE(OUTPUT,'     I_CNT: ',INSTRCNT:6,', SP: ',SP:5,',  NP: ',
                      ',  MP: ', MP:5);
         WRITELN(OUTPUT, ',  PC: ',  PC:5, ' OP =', INSTR[OP]:4, '  (',
                         '  T: ', T:1, '  P: ', P:4,'  Q: ',Q:6, ')' );
      END  (* TRCE *) ;

      (* EXECUTION COUNTERS *)

      PC := PC+1;  INSTRCNT := INSTRCNT+1 ;
      IF GETSTAT THEN  COUNT ;

      (*EXECUTE*)

      IF OP <= PLOD THEN EX0 ELSE EX1 ;

   UNTIL NOT INTERPRETING ;


   TIMER := CLOCK(1)-TIMER;
   WRITELN(OUTPUT) ;    WRITELN(OUTPUT) ;
   WRITELN(OUTPUT,'    >>>>  EXITING USER PROGRAM,  RETURN CODE = ',RETC

   PRINT_HEADLN(OUTPUT);

   IF GETSTAT THEN  BEGIN  PRINT_HEADLN(SFL);  PRINTCOUNTS;  END;

   EXIT(RETCDE);

END.
