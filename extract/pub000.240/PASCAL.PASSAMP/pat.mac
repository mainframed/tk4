(*$M-*)
program pat;



    ¯***********************************************ò
    ¯*       PAL     (pat,lalr)                    *ò
    ¯*                                             *ò
    ¯*   PATTERN  ACTION  LANGUAGE                 *ò
    ¯*                                             *ò
    ¯*    AUTHOR  :   G. POONEN                    *ò
    ¯*                                             *ò
    ¯*    modification :  J. Bloch, H. Eskin       *ò
    ¯*    modification :  G. Minshall              *ò
    ¯*                                             *ò
    ¯*     VERSION :                               *ò
    ¯*                                             *ò
    ¯*      DATE    :        December, 1983        *ò
    ¯*                                             *ò
    ¯***********************************************ò

¯ Dependancies - The algorithm for making a character
        upper case DEPENDS on (ord(LowerCaseLetter)-ord(UpperCaseLetter)
        being constant as 'Letter' varies from 'a' to 'z'
        (Both ASCII and EBCDIC have this property).
ò






















    ¯  GLOBAL DECLARATIONS  ò
    ¯***********************ò



    ¯ GLOBAL constANTSò
  const
    XCONTINUE = 9996 ;     ¯ CODE FOR CONTINUE IN TABLE ò
    ELSECODE = 9997  ;
    NOSCANCODE   = 9998 ; ¯ CODE FOR SCANò
    ERRORCODE = 9999 ;    ¯ CODE FOR ERROR IN TABLE ò
    UNKNOWN=-9999 ;       ¯ UNKNOWN QTY ò
    MAXSEGMENT = 200 ;
    MAXTABSIZE =3000;
    MAXADDR    = 4*65536-1;
    MAXNAME    = 15   ;   ¯ MAX LENGTH OF NAMES  (was 15) ò
    MAXERR     =  20  ;   ¯ MAX ERRORS PER LINEò
    MAXERRNmr  =  200 ;   ¯ MAX ERROR NUMBERò
    MAXLINECNT =   132;   ¯  LINE COUNTò
    GTMAXERR   =  199 ;   ¯ EXCEEDED MAX ERRORS PER LINEò
    MAXSYM     =    6 ;   ¯ SIZE OF SPECIAL SYMBOLSò
    STATETABSIZE= 2000 ;  ¯ was 1000 ò
    MAXSTATE = 2000 ;     ¯ was 1000 ò
    MAXRHS = 32 ;
    MAXVISIT = 3200  ;    ¯ MAX NO OF STATES VISITED FOR ò
                          ¯ RESOLVING LA STATES ò ¯ was 1600ò

    MAXVOCSIZE = 2048 ;   ¯ MAX VOCABULARY CODE (was 512) ò
    MAXTERMINALS = 1023 ; ¯ was 255 ò
    NAMETABSIZE = 4001 ;  ¯ KEEP IT PRIME  (was 1023) ò
    MAXRULENO    = 4001 ; ¯ KEEP IT PRIME  (was 1023) ò
    DIGMAX    =    5 ;    ¯ MAXIMUM NUMBER of DIGITS FOR INTEGERò
    THRESHOLD =3 ;        ¯ USED FOR SORTING AND MATCHING LISTSò
    FILENAMELEN = 133 ;   ¯ MAX charACTERS IN FILESPECò
    B14 = 12;             ¯ was 14B in DEC version ò
    WHITESPACE = [ ' ' ]; ¯ What INsymbol skips. ò


    ¯ GLOBAL typeS ò
type
    word  =  packed array [1 .. MAXNAME] of char ;
    symbol =  (Ident ,Res, Intconst,  SemiSy, SlashSy, OrSy, EqSy, ColSy
    ,PeriodSy    ) ;
    setofsymbol = set of symbol ;
    namety = (Term,NonTerm,
              Lab
              ) ;
    codety = -1 .. MAXTERMINALS ;
    listptrty = @ list ;
    list   =  packed  record
                             CDR     : listptrty;
                             CAR     : 1 .. '5FFF'X
                      end ;
    setofnamety = set of namety ;


    ¯  NAME TABLE ENTRIES   ò
    ¯***********************ò

    identptrty = @ identry ;
    prodptrty  = @ prod ;
    identry   =   record
                         Nic     : identptrty;
                         FirstAlt: prodptrty;

                         Defin   : listptrty;
                         UsedIn  : listptrty;
                         InternalName,
                         ExternalName    : word   ;
                         Kind    : namety ;
                         SpId    : symbol ;
                         Code    : codety
                  end ;
    prod = record
                  Next   : prodptrty;
                  XDef   : identptrty;
                  Action : identptrty;
                  NxtAlt : prodptrty;
                  Production : 1 .. MAXRULENO
           end ;


    ¯  STATE ENTRIES ò
    ¯****************ò
    statekind     = (Reads,Inadequate,Lookahead,Reduction,Subgoal,LAStri
    stateptrty    = @ statety ;
    tranlistptr   = @ tranlist ;
    statelistptr  = @ statelist ;
    tranptrty     = @ tranty ;
    statety = record
                 FirstTran : tranptrty  ;
                 Back      : tranptrty ;
                 Nic       : stateptrty ;
                 State     : 0 .. MAXSTATE ;
                 Kind      : statekind
              end ;

    statelist = record
                  CAR : stateptrty ;
                  CDR : statelistptr
                end ;
    tranlist = record
                  CAR : tranptrty ;
                  CDR : tranlistptr
               end ;
    tranty =  packed record
                        Next      : tranptrty ;
                        NextState : stateptrty ;
                        Rule      : prodptrty ;
                        Pos       : 0 .. MAXRHS ;
                        MarkE     : BOOLEAN
                     end ;

    ¯ type specifiers for OPEN procedure ò
    openOptions = ( OpenInput, OpenOutput, OpenUppercase );
    openOption  = set of openOptions;
    filenameType = packed array [1 .. FILENAMELEN] of char  ;
    promptType = packed array[1..121] of char;




    ¯ GLOBAL varIABLES ò
var
    Heap,HeapBot,HeapTop      : @integer ; ¯ MARKS Heap ò
    Visit   : array [ 1.. MAXVISIT ] of tranptrty ;
    CurrentVisit : integer ;

    ¯ Table ENTRIES ò


    Table : array [0 .. MAXTABSIZE] of packed record
                                              Tran : integer ;
                                              Action : integer
                                       end ;
    Index : -1 .. MAXTABSIZE ;
    Segment : array [0 .. MAXSEGMENT] of packed record
                                                Tran : integer ;
                                                Action : integer
                                         end ;
    SegIndex : -1 .. MAXSEGMENT ;
    NewState : array [0 .. MAXSTATE] of integer ;


    SymbolName : packed array [0 .. MAXVOCSIZE] of identptrty;
    NameTab  :  array [0 .. NAMETABSIZE ] of identptrty ;
    RuleTab   :  array [1 .. MAXRULENO ] of   prodptrty;
                 ¯  Contains no. of elements on rhs e.g  ò
                 ¯  X =  A   B   C    will be 3          ò
    PopTab  : array [ 1 .. MAXRULENO ] of integer ;

    NState : array [0 .. MAXSTATE ] of stateptrty ;
    StateTab  : array [0 .. STATETABSIZE ] of stateptrty ;
    Inadeq,Conflict : statelistptr ; ¯ list of Inadequate StateS ò
    CurrentState : 0 .. MAXSTATE ;
    Sy     : symbol  ; ¯ LAST symbolò
    SyLeng : integer ; ¯ LENGTH of symbolò
    SyKey  : integer ; ¯ symbol KEY      ò

    SyVal : integer ;
    MaxK  : integer ; ¯ MAX VAL of Lookahead ò
    InternalId,               ¯ symbol InternalName     ò
    ExternalId    :  word   ; ¯ symbol ExternalName     ò
    Ch    :  char   ; ¯ LAST charACTER  ò
    InSymbolState : ( InSymbolNormalState, InSymbolStringState );
                    ¯ that is: returning a string, or just normal
                        processing ò

    ChCnt : integer ;
    Letters
    ,Digits  :  set of char   ;

   MaxPop     : integer ;
   MaxCode    : integer ;
   MaxProdNo  : 0 .. MAXRULENO ;
      ProdNo  : 0 .. MAXRULENO ;

    L      : integer ; ¯ CONTROL varIABLE ò

                       ¯  OPTION FLAGS  ò
    ListFl                  ¯ L ò
    , Look                  ¯ A ò
    , Grammar               ¯ G ò
    , Debug                 ¯ D ò
    , Optimize              ¯ O ò
    , Trace                 ¯ R - Print trace info during run ò
    , Tables                ¯ T ò
    , PN                    ¯ P ò
    , Terminals             ¯ S ò
    , Frequency             ¯ F ò
    , Lr0                   ¯ C ò
    , IFSM                  ¯ I ò
    , Research              ¯ Z ò
    , Symbolic              ¯ Y - The state tables should be symbolic ò
    , NonTerminals          ¯ N - Put non terminals in .TER ò
    , FSM      :   boolean; ¯ M ò

    ¯  ERROR  list  ò

    FatalError,
    ErrorFlag  : boolean ;
    ErrInx   :   integer   ;   ¯ NO of ERRORS IN THIS LINEò
    ErrList  :  array  [1 .. MAXERR]  of
                    record
                      Pos :  0 .. MAXLINECNT ;
                      Nmr :  0 .. MAXERRNmr
                    end ;
    ¯  FILES  ò
    Filename  :  filenameType;
      TTYOut                                 ¯  Console output ò
    , CrefPas                                ¯  Cref       ò
    , TerPas                                 ¯  Terminals  ò
    , NewPrgPas                              ¯  Formatted Grammar ò
    , TabPas                                 ¯  Tables ò
    , PNPas    :  text;                      ¯  Production num ò

    ¯  LALR  ò
    LrK
    :  boolean    ;

    ¯  SPECIAL symbolS  ò
    SpList   :  array [1 .. MAXSYM]  of char  ;
    SpSy    :  array [1 .. MAXSYM]  of symbol  ;

LowerCaseLetters : set of char;


¯ The following are for the Arguments part of the implementation
        specific part of the Pascal/VS version (IBM)
ò
    OurArgs : packed array[1..255] of char;
    OurArgsIndex,
    OurArgsLength : integer;
    OurArgsUpperCase : boolean;









¯ The following proceduRes are, hopefully,
    the only PASCAL/VS specific proceduRes.  Thus, to move to a new
    environment, one should only need to change the way they deal
    with your new I/O system.  NOTE that 'filename' is something
    one might have to reformat.
        (greg minshall - 12/10/83)
ò

¯ OPEN - this procedure opens a file, doing ResET or REWRITE as
    necessary
ò

procedure open( var f          : text;
                const filename : filenametype;
                const options  : openOption );
%include CMS
var
    opts : string(50);
    fn   : string(40);
    rc   : integer;
begin
    assert (( OpenInput in options ) or ( OpenOutput in options )) and
           not (( OpenInput in options ) and ( OpenOutput in options ));

    if OpenUppercase in options then
        opts := 'UCASE '    ¯ translate input to UPPER case ò
    else
        opts := '';

    fn := trim(ltrim(compRess(str(filename))));

    if fn = 'TTY:' then begin
        opts := opts ×× 'DDNAME=STDIN';
        cms( 'FILEDEF STDIN CLEAR', rc );
        cms( 'FILEDEF STDIN TermINAL ( LRECL 255 BLOCK 255', rc );
        if OpenInput in options then
            Reset( f, opts )
        else
            rewrite( f, opts );
    end else begin
        opts := opts ×× 'NAME=' ×× fn;
        if OpenInput in options then
            Reset( f, opts )
        else
            rewrite( f, opts );
    end;
end;

¯ CanOpen - this boolean function returns TRUE if the filename
          LookS ok, FALSE otherwise
ò
function CanOpen( const filename : filenametype ) : boolean;
%include CMS
var
    myfile : filenametype;
    index,
    rc     : integer;
begin
    for index := 1 to filenamelen do
        if filename[index] = '.' then
            myfile[index] := ' '
        else
            myfile[index] := filename[index];

    cms( 'SET CMStype HT', rc );

    cms( 'State ' ×× str(myfile), rc );
    CanOpen := rc = 0;

    cms( 'SET CMStype RT', rc );
end;

PROCEDURE BREAK;
BEGIN
    ¯ DEC has a procedure called BREAK, which causes the output
        buffer to be flushed.  Here is my version - it is
        good for nothing!
    ò
end;


¯ The following proceduRes are designed to allow PAT to get arguments
    from the users.  In the Pascal/VS version, we get the options from
    the command line.  In other versions, one might (as in the DEC
    version this started from) write a prompt, and the read from the
    terminal.
ò

procedure InitArgs;
var
    TempArgs : string(255);
    Index : integer;
begin
    TempArgs := parms;          ¯ parms is a function, returns parms
                                  from the command line ò
    OurArgs := TempArgs;        ¯ Pascal/VS converts ò
    OurArgsIndex := 1;
    OurArgsLength := length(TempArgs);
    while (OurArgs[OurArgsIndex] = ' ') and
          (OurArgsIndex <= OurArgsLength) do
            OurArgsIndex := OurArgsIndex+1;
    OurArgsUpperCase := FALSE;
end;


procedure PromptArgs( Prompt : promptType );
begin
    ¯ We don't use this at all ò
end;


procedure OpenArgs( Options : openOption );
begin
    if OpenUppercase in Options then
        OurArgsUpperCase := TRUE
    else
        OurArgsUpperCase := FALSE;
end;


Procedure GetArgCh( var ch : char; var EndLine, EndArgs : boolean );
begin
    if OurArgsIndex > OurArgsLength then begin
        EndArgs := TRUE;
        Ch := ' ';
    end else begin
        EndArgs := FALSE;
        Ch := OurArgs[OurArgsIndex];
        if (Ch in LowerCaseLetters) and OurArgsUpperCase then
            Ch := chr( ord(Ch) + ord('A')-ord('a') );
        OurArgsIndex := OurArgsIndex+1;
        if  Ch = ' ' then begin
            EndLine := TRUE;
            while (OurArgs[OurArgsIndex] = ' ') and
                  (OurArgsIndex <= OurArgsLength) do
                        OurArgsIndex := OurArgsIndex+1;
        end else
            EndLine := FALSE;
    end;
end;


procedure SetReturnCode( I : integer );
¯ In CMS, error code is propagatable back to caller, so let
    them know...
ò
begin
    retcode(i);     ¯ CMS Pascal/VS primitive ò
end;




¯ Thus ends, hopefully, the implementation dependent part
    of PAT.
        greg minshall, 12/83
ò




procedure InitSp;
begin
        SpList  [1] :=  '!'    ;  SpSy [1] := OrSy ;
        SpList  [2] :=  '/'    ;  SpSy [2] := SlashSy ;
        SpList  [3] :=  ';'    ;  SpSy [3] := SemiSy ;
        SpList  [4] :=  '='    ;  SpSy [4] := EqSy ;
        SpList  [5] :=  ':'    ;  SpSy [5] := ColSy ;
        SpList  [6]  := '.' ;    SpSy [6] := PeriodSy
end;


    ¯used to be an initprocedureò
    procedure  InitOptions ;  ¯  DEFAULT OPTIONSò
      begin
        Optimize   :=   FALSE   ;
        Tables     :=   TRUE   ;
        PN         :=   FALSE   ;
        Terminals  :=   TRUE   ;
        Frequency  :=   FALSE   ;
        FSM        :=   FALSE   ;
        Grammar    :=   TRUE   ;
        Look       :=  TRUE   ;
        ListFl     :=  TRUE   ;
        Lr0        :=  TRUE   ;
        IFSM       :=  TRUE   ;
        Research   :=   FALSE ;
        Debug      :=   FALSE ;
        Trace      :=   FALSE ;
        Symbolic   :=   FALSE ;
        NonTerminals := FALSE ;

        MaxK  :=  1     ; ¯  DEFAULT Lookaheadò
      end  ;




    procedure InitGlob ;    ¯ GLOBAL varIABLES  ò
    ¯used to be an initprocedureò
      begin
        FatalError := FALSE;
        ErrorFlag := FALSE ;
        Conflict := NIL ;
        Inadeq := NIL   ;
        ErrInx := 0     ;
        InSymbolState := InSymbolNormalState;
        LowerCaseLetters := [ 'a', 'b', 'c', 'd', 'e', 'f',
            'g', 'h', 'i', 'j', 'k', 'l', 'm', 'n', 'o', 'p',
            'q', 'r', 's', 't', 'u', 'v', 'w', 'x', 'y', 'z' ];
      end ;



    procedure   EndOfLine  ;
        ¯*******************************************************ò
        ¯*                                                     *ò
        ¯*   end of LINE                                       *ò
        ¯*                                                     *ò
        ¯*       THIS procedure WRITES OUT THE                 *ò
        ¯*     CURRENT LINE AND FOLLOWS IT WITH                *ò
        ¯*     ANY ERROR MESSAGES AND POINTERS.                *ò
        ¯*                                                     *ò
        ¯*                                                     *ò
        ¯*      GLOBAL IN: ErrInx  NO. of ERRORS IN THIS LINE  *ò
        ¯*                                                     *ò
        ¯*                 ErrList array CONTAINING            *ò
        ¯*                         ATTRIBUTES of ERROR         *ò
        ¯*                                                     *ò
        ¯*                 list    listING REQUIRED IF         *ò
        ¯*                         TRUE.                       *ò
        ¯*                                                     *ò
        ¯*         OUT :  ErrInx   set TO 0                    *ò
        ¯*                                                     *ò
        ¯*                                                     *ò
        ¯*******************************************************ò
    var
        LastPos
        , FreePos
        , CurrPos
        , CurrNmr
        ,  F                ¯  FORMAT  ò
        ,  K                ¯  LOOP CONTROL  ò
        :  integer  ;

      begin
        readln; writeln;
        if ErrInx > 0 then  ¯OUTPUT ERROR MESSAGESò
          begin
            write('****');
            LastPos := 0; FreePos := 1;
            for K := 1 to ErrInx do
              begin
                with ErrList[K] do
                  begin
                    CurrPos := Pos; CurrNmr := Nmr
                  end;
                if CurrPos = LastPos then write(',')
                else
                  begin
                    while FreePos < CurrPos do
                      begin
                        write(' '); FreePos := FreePos + 1
                      end;
                    write('@');
                    LastPos := CurrPos
                  end;
                if CurrNmr= 0 then F:= 0
                else if CurrNmr < 10 then F :=1
                else if CurrNmr < 100 then F := 2
                else F := 3;
                if F <> 0 then write(CurrNmr:F);
                FreePos:=FreePos+F+1
              end;
            writeln; ErrInx :=0
          end;
        ChCnt := 0
      end  ¯EndOfLineò ;



    procedure   Error  (FErrNr : integer) ;
        ¯******************************************************ò
        ¯*                                                    *ò
        ¯*        Error                                       *ò
        ¯*                                                    *ò
        ¯*     THIS procedure recordS THE Error               *ò
        ¯*  AND PosITION of OCCURRENCE                        *ò
        ¯*                                                    *ò
        ¯*    GLOBAL  IN :  ChCnt   INDICATE PosITION         *ò
        ¯*                          ON LINE                   *ò
        ¯*                                                    *ò
        ¯*                                                    *ò
        ¯*                                                    *ò
        ¯*         OUT :  ErrorFlag                           *ò
        ¯*                ErrList     array of ErrorS         *ò
        ¯*                ErrInx                              *ò
        ¯*                                                    *ò
        ¯*                            I                       *ò
        ¯*                                                    *ò
        ¯******************************************************ò
      begin
        ¯  Error ò
        ErrorFlag :=  TRUE  ;
        if ErrInx >= MAXERR  then
          begin
            ErrList [ MAXERR ].Nmr :=  GTMAXERR  ;
          end
        else
          begin
            ErrInx  :=  ErrInx +1  ;
            ErrList [ErrInx] . Nmr := FErrNr  ;
            ErrList [ErrInx].Pos   :=  ChCnt   ;
          end  ;
      end  ;
    ¯  Error ò




    procedure  NextCh   ;
        ¯*******************************************************ò
        ¯*                                                     *ò
        ¯*  NextCh.                                            *ò
        ¯*                                                     *ò
        ¯*     THIS procedure RETURNS THE Next charACTER       *ò
        ¯* IN Ch                                               *ò
        ¯*                                                     *ò
        ¯*                                                     *ò
        ¯*                                                     *ò
        ¯*   GLOBAL      IN:   ChCnt                           *ò
        ¯*                     ListFl        boolean OPTION    *ò
        ¯*                                                     *ò
        ¯*              OUT:   ChCnt                           *ò
        ¯*                                                     *ò
        ¯*                      Ch         Next charACTER      *ò
        ¯*                                                     *ò
        ¯*******************************************************ò
      begin
        ¯ NextCh ò
        if not ( eoln(Input) or eof(Input) )  then
          begin
            read (Ch)  ;
            if ListFl then write (Ch)  ;
            ChCnt :=  ChCnt +1  ;
          end
        else   Ch := ' '  ;
      end   ;



    procedure  InSymbol  ;
        ¯*******************************************************ò
        ¯*                                                     *ò
        ¯*   InSymbol                                          *ò
        ¯*                                                     *ò
        ¯*       THIS procedure RETURNS THE Next               *ò
        ¯*  symbol FROM THE SOURCE Input                       *ò
        ¯*                                                     *ò
        ¯*  GLOBAL  IN:  Ch     Next charACTER                 *ò
        ¯*              SP list                                *ò
        ¯*              SP Sy                                  *ò
        ¯*                                                     *ò
        ¯*         OUT :  SyLeng    symbol LENGTH              *ò
        ¯*                Sy        symbol type                *ò
        ¯*                InternalId[I]     symbol charACTERS  *ò
        ¯*                SyKey     KEY for IdentifIERS        *ò
        ¯*                                                     *ò
        ¯*                                                     *ò
        ¯*                                                     *ò
        ¯*******************************************************ò

    label
        3;
    var
        I,K : integer ;
        Noteoln,
        Noteof : boolean;
begin ¯ InSymbol ò
    if InSymbolState = InSymbolStringState then begin
        ExternalId[1] := '''';
        ExternalId[2] := Ch;
        SyKey := ord(Ch);
        ExternalId[3] := '''';
        if Ch = '''' then
            ExternalId[4] := ''''
        else
            ExternalId[4] := ' ';
        for i := 5 to MAXNAME do
            ExternalId[i] := ' ';
        Sy := Res;
        InternalId := ExternalId;
                ¯ End of lines and files terminate strings ò
        if eoln(Input) or eof(Input) then
            InSymbolState := InSymbolNormalState;
        Nextch;
        if Ch = '''' then begin
            Nextch;
            if Ch <> '''' then
                InSymbolState := InSymbolNormalState;
        end;
    end else begin
        repeat begin
            repeat begin
                if  eoln(Input)  then EndOfLine ;
                if  not ( Ch in WHITESPACE ) then
                    leave;
                NextCh   ;          ¯ skip whitespace ò
            end until eof(Input);
            if (Ch <> '¯') AND (Ch <> '%') then
                leave;
            if  Ch = '%' then
            begin
                NextCh   ;
                repeat begin
                    if  eoln(Input)  then EndOfLine ;
                    if  Ch = 'Ö' then
                        leave;
                    NextCh
                end until eof(Input);
            end;
            if  Ch = '¯' then
            begin
                NextCh   ;
                repeat begin
                    if  eoln(Input)  then EndOfLine ;
                    if  Ch = 'ò' then
                        leave;
                    NextCh
                end until eof(Input)
            end;
            NextCh
        end until eof(Input);
        SyLeng  := 0 ;
        SyVal :=0 ;
        SyKey   := 0 ;
        if  Ch  in  Letters  then begin
            K  := 0   ;
            repeat
                if  K  <MAXNAME   then begin
                    K := K+1 ;
                    ExternalId[K] := Ch   ;
                    if Ch in LowerCaseLetters then
                        InternalId[K] := chr( ord(ch) + ord('A')-ord('a'
                    else
                        InternalId[K] := Ch;
                    SyKey  := SyKey + ord(InternalId[K]);
                  end   ;

                NextCh
            until  not  (Ch in Letters + Digits) ;
            if K < MAXNAME  then
            for I := K+1 to MAXNAME do begin
                ExternalId[I] := ' ' ;
                InternalId[I] := ' ' ;
            end;
            Sy  := Ident   ;
          end
        else  if  Ch  in  Digits  then begin
            Sy := Intconst ;
            I  :=  0     ;   SyVal :=0;
            repeat
                I := I+1 ;
                if   I < DIGMAX then
                SyVal := SyVal*10  + ord (Ch) - ord ('0') ;
                ExternalId[I] := Ch      ;
                NextCh
            until  not  (Ch in Digits)   ;
            if I < MAXNAME then
            for I:= I+1 to MAXNAME  do  ExternalId[I] := ' ';
            InternalId := ExternalID;
        end
        else if Ch = '''' then begin
            InSymbolState := InSymbolStringState;
            Nextch;
            if Ch = '''' then begin
                Nextch;
                if Ch <> '''' then    ¯ If TRUE, null symbol - ignore ò
                    InSymbolState := InSymbolNormalState;
            end;
            InSymbol;           ¯ recurse to start reading string ò
        end else begin
            for I := 1 to MAXSYM do begin
                if SpList[I]= Ch  then begin
                    Sy := SpSy [I] ;
                    GOto 3 ;
                end ;
            end ;
            3 : ExternalId[1] := Ch;
            NextCh ;
            for I:= 2 to MAXNAME  do ExternalId[I]:= ' ';
            InternalID := ExternalID;
        end ;
        if Trace then begin
            writeln(TTYOut,InternalId,' ',SyVal:3);BREAK
        end;
    end;
end  ;
        ¯  InSymbol  ò



    procedure   InitP ;
        ¯***********************************************************ò
        ¯*                                                         *ò
        ¯*    InitP                                                *ò
        ¯*                                                         *ò
        ¯*        THIS procedure Reads in THE OPTIONS              *ò
        ¯*   AND ALSO inITIALIZES ANY Tables AS                    *ò
        ¯*   REQUIRED                                              *ò
        ¯*                                                         *ò
        ¯***********************************************************ò
    var

        ChNext : char;
        EndLine,
        EndArgs : boolean;
        I : integer ;
        Distance,Dot,J, RBrak,Colon
                : 0..FILENAMELEN;       ¯PLACE MarkERS in FILESPECò
        procedure     InitSets   ;
        var
            L : integer ;
          begin
            Digits := ['0','1','2','3','4','5','6','7','8','9'] ;
            Letters:= ['A','B','C','D','E','F','G','H','I','J','K',
            'L','M','N','O','P','Q','R','S','T','U','V',
            'W','X','Y','Z','_','a','b','c','d','e','f','g','h','i','j',
            'l','m','n','o','p','q','r','s','t','u','v',
            'w','x','y','z' ] ;

            for L := 0 to NAMETABSIZE do
            NameTab[L] :=  NIL ;
            for L:= 1 to MAXRULENO do
              begin
                RuleTab[L] :=  NIL;
                PopTab [L] := 0
              end   ;
            MaxProdNo := 0;
            ProdNo := 0 ;
            MaxPop := 0 ;
            for L := 0 to MAXSTATE do
              begin
                NewState [L] := 0 ;
                NState [ L ] := NIL ;
              end ;
            for L := 0 to MAXTABSIZE do
              begin
                Table [L].Tran := UNKNOWN ;
                Table [L].Action := UNKNOWN;
              end ;
            for L := 0 to STATETABSIZE do
            StateTab [L] := NIL ;
            CurrentVisit := 0 ;
            for L := 1 to MAXVISIT do
            Visit [L] := NIL ;
            MaxCode := 257 ;    ¯ leave room for ord constants ò
            CurrentState := 0
          end  ;
        ¯ InitSets ò



        procedure    Options   ;
            ¯***********************************************************
            ¯*
            ¯*  Options
            ¯*
            ¯*  THIS procedure Reads in THE Options
            ¯*   AND SETS THE OPTION FLAGS APPROPRIATELY
            ¯*
            ¯*      GLOBAL in:  Ch        LAST charACTER
            ¯*
            ¯*
            ¯***********************************************************
var
    ChNext : char;
    EndLine,
    EndArgs : boolean;

          begin
            ¯ Options ò
              PromptArgs('Options: ');
              OpenArgs([ OpenInput, OpenUppercase ]);
        /*    Reset(TTY,'TTY:','/I/U'); ¯ convert tty input to upper cas
              GetArgCh( ChNext, EndLine, EndArgs );
              while not EndArgs do begin
                Ch := ChNext;       ¯ get Identifier ò
                GetArgCh( ChNext, EndLine, EndArgs ); ¯ get +/- ò
                if Ch = 'L' then
                  begin
                    ListFl  :=  ChNext <> '-';
                    writeln(TTYOut,'Listfile: ',listfl)
                  end
                else if Ch = 'O' then
                  begin
                    Optimize  :=  ChNext <> '-';
                    writeln(TTYOut,'Optimize: ',optimize)
                  end
                else if Ch = 'T'  then
                  begin
                    Tables := ChNext<>'-';
                    writeln(TTYOut,'Tables: ',tables)
                  end
                else if Ch ='S'  then
                  begin
                    Terminals := ChNext<>'-';
                    writeln(TTYOut,'Terminals: ',terminals)
                  end
                else if Ch = 'F'   then
                  begin
                    Frequency  :=  ChNext <>'-';
                    writeln(TTYOut,'Frequency: ',frequency)
                  end
                else if  Ch = 'M'   then
                  begin
                    FSM  :=  ChNext<>'-';
                    writeln(TTYOut,'FSM: ',fsm)
                  end
                else  if  Ch  = 'D'   then
                  begin
                    Debug  := ChNext <> '-';
                    writeln(TTYOut,'Debug: ',debug)
                  end
                else  if  Ch  = 'R'   then
                  begin
                    Trace  :=  ChNext <> '-';
                    writeln(TTYOut,'Trace: ',trace)
                  end
                else  if  Ch in Digits  then
                begin
                    MaxK:=  ord(Ch) - ord('0');
                    writeln(TTYOut,'Maximum lookahead: ',maxk)
                end
                else  if  Ch = 'A'   then
                  begin
                    Look := ChNext<>'-';
                    writeln(TTYOut,'Look: ',look)
                  end
                else if Ch='G'  then
                  begin
                    Grammar:=  ChNext <> '-';
                    writeln(TTYOut,'Grammar: ',grammar)
                  end
                else if Ch ='Z' then
                  begin
                    Research:= ChNext<>'-';
                    writeln(TTYOut,'Research: ',Research)
                  end
                else if Ch ='N' then
                  begin
                    NonTerminals:= ChNext<>'-';
                    writeln(TTYOut,'Non-terminals: ',nonterminals)
                  end
                else if Ch ='Y' then
                  begin
                    Symbolic:= ChNext<>'-';
                    writeln(TTYOut,'Symbolic: ',symbolic)
                  end
                else if Ch = 'I' then
                  begin
                    IFSM := ChNext<>'-' ;
                    writeln(TTYOut,'IFSM: ',ifsm)
                  end
                else if Ch = 'C' then
                  begin
                    Lr0 := ChNext <> '-' ;
                    writeln(TTYOut,'Lr0: ',lr0)
                  end
                else  if  Ch = 'P'   then
                  begin
                    PN :=  ChNext <> '-';
                    writeln(TTYOut,'PN: ',pn)
                  end;
              end;
              writeln(TTYOut)
          end ;
        ¯  Options  ò



      begin
        ¯  InitP    ò
        ¯  GET Filename ò

        InitSets;
        writeln(TTYOut, 'PAT/lalr -- December, 1983');
        writeln(TTYOut);
        InitArgs;


        PromptArgs('File: ');
        for I:= 1 to FILENAMELEN do
            Filename[I] := ' ';
        I:= 0;
        Dot:=0;
        RBrak:=0;
        Colon:=0;
        GetArgCh( ch, EndLine, EndArgs );
        while not EndLine and not EndArgs and
              not FatalError and (I < FILENAMELEN) do begin
            if (Ch in (Letters + Digits)) or (Ch = '<') or
                (Ch = '-') or (Ch = '.') or (Ch = '>') or (Ch = ':')
              then
                begin
                I := I + 1;
                Filename [I] := Ch;
                if ( Ch = '.' ) AND ( Dot = 0 ) then
                    Dot := I
                else if Ch = ':' then Colon := I
                else if Ch = '>' then RBrak := I;
                end
            else begin
                writeln (TTYOut,'?Error in filespecs');
                FatalError := TRUE;
            end;
            GetArgCh( ch, EndLine, EndArgs );
        end;

    if not FatalError then begin
        if dot=0 then ¯set default extension to PATò begin
            dot := i+1;
            filename[i+1] := '.';
            filename[i+2] := 'P';
            filename[i+3] := 'A';
            filename[i+4] := 'T';
            i := i+4
        end;

        if CanOpen(filename) then
            open( input, filename, [ OpenInput, OpenUppercase ] )
     /*Reset(input,filename,'/U/O'); ¯trap errors & xlate input to UCò*/
        else begin
            writeln(TTYOut,'?Cannot open input file');
            FatalError := TRUE
        end;
    end;

    if not FatalError then begin
        Ch := ' ';
        if RBrak > Colon        ¯ Get rid of device and directory names
        then Distance := RBrak
        else Distance := Colon;
        if Distance > 0
        then
            for J:=1 to I+Distance do
                Filename[J] := Filename[J+Distance];
        Dot := Dot-Distance;            ¯ Move down the dot ò
        Options;
        Filename [Dot+1]  :=  'L'   ;
        Filename [Dot+2]  :=  'S'   ;
        Filename [Dot+3]  :=  'T'   ;
        open(OUTPUT,Filename,[ OpenOutput ]);
        if Frequency or FSM or Look or tables
        then
          begin
            Filename [Dot+1]  :=  'C'   ;
            Filename [Dot+2]  :=  'R'   ;
            Filename [Dot+3]  :=  'L'   ;
            open (CrefPas, Filename, [ OpenOutput ])
          end   ;
        if Terminals then
          begin
            Filename [Dot+1] := 'T';
            Filename [Dot+2] := 'E' ;
            Filename [Dot+3] := 'R' ;
            open (TerPas,Filename,[OpenOutput])
          end ;
        if Tables then
          begin
            Filename[Dot+1] := 'T';
            Filename[Dot+2] := 'A' ;
            Filename[Dot+3] := 'B';
            open (TabPas,Filename,[OpenOutput])
          end ;
        if PN then
          begin
            Filename [Dot+1] := 'P' ;
            Filename [Dot+2] := 'N' ;
            Filename [Dot+3] := ' ' ;
            open (PNPas,Filename,[OpenOutput])
          end ;
        NextCh;
    end;
end; ¯ InitP ò



    procedure  Skip (SyS : setofsymbol)  ;

        ¯********************************************ò
        ¯*                                          *ò
        ¯*  Skip                                    *ò
        ¯*                                          *ò
        ¯* Skip Input String until RELEVANT symbol  *ò
        ¯*  IS FOUND                                *ò
        ¯********************************************ò
      begin
        while not(Sy in SyS) and not eof(Input) do InSymbol  ;
        Error (0)
      end  ;



    function FindId (IdName :word; Key : integer ; IdKind
        : setofnamety ) : identptrty ;
        ¯*********************************************ò
        ¯*                                           *ò
        ¯*  FindId                                   *ò
        ¯*                                           *ò
        ¯*     THIS procedure RETURNS A              *ò
        ¯*   A POinTER to THE GIVEN NAME AND type    *ò
        ¯*  in then symbol Table                     *ò
        ¯*                                           *ò
        ¯*********************************************ò

    var
        I : integer ;
        Found : boolean  ;
        P,Q  : identptrty;
      begin
        I := Key mod NAMETABSIZE ;
        Q := NameTab[I] ;
        Found := FALSE;
        P := NIL ;
        while (Q <> NIL) AND (not Found ) do
          begin
            if Q@.InternalName = IdName
            then
              begin
                Found := Q@.Kind in IdKind ;
                P := Q;
              end ;
            Q := Q@.Nic
          end ;
        FindId := P
      end ;




    function EnterId (ExtIdName, IntIdName: word; Key: integer;
        IdKind: namety; IdCode: codety; IdSy : symbol)  :  identptrty  ;
        ¯***************************************************ò
        ¯*                                                 *ò
        ¯*  EnterId                                        *ò
        ¯*                                                 *ò
        ¯*THIS procedure ENTERS THE GIVEN NAME             *ò
        ¯*  into THE symbol Table.  if THE NAME IS A       *ò
        ¯*  TerminAL THE TerminAL Code IS ENTERED AS       *ò
        ¯*  AN ATTRIBUTE of THE NEWLY ENTERED symbol.      *ò
        ¯*                                                 *ò
        ¯***************************************************ò
    label
        2;
    var
        I : integer ;
        P,Q : identptrty;
      begin
        ¯ EnterId ò
        I := Key mod NAMETABSIZE ;
        Q := NameTab [I]  ;

        if Trace then
          begin
            writeln(TTYOut,'I= ',I,'Key= ',Key);
            BREAK
          end ;
        while Q <> NIL do
          begin
            if Q@.InternalName = IntIdName then
              begin
                Error (8) ;
                EnterId := Q;
                GOto 2
              end ;
            Q := Q@.Nic
          end ;
        new (P) ;
        with P@ do
          begin
            Nic := NIL  ;
            FirstAlt := NIL  ;
            ExternalName   := ExtIdName  ;
            InternalName   := IntIdName  ;
            SpId := IdSy ;
            Kind  := IdKind  ;
            if IdCode= -1 then IdCode :=MaxCode+1;
            if IdCode > MAXVOCSIZE then
                writeln(TTYOut,'Code is too big for cross indexing')
            else SymbolName[IdCode] := P ;
            Code  := IdCode  ;
            if IdCode > MaxCode then MaxCode := IdCode ;
            UsedIn  := NIL  ;
            Defin  := NIL
          end  ;
        Q := NameTab [I]  ;
        NameTab [I] := P  ;
        P@. Nic  := Q     ;
        EnterId  := P  ;
        2 :
      end  ;
    ¯ EnterId ò


    procedure Terminal  ;
        ¯************************************************************ò
        ¯*                                                          *ò
        ¯*   Terminal                                               *ò
        ¯*                                                          *ò
        ¯* THIS procedure Reads THE Terminal                        *ò
        ¯* DefinITIONS AND ENTERS THEM in THE                       *ò
        ¯* symbol Table                                             *ò
        ¯************************************************************ò
    var

        TP   : identptrty ;
        LKey : integer ;
        InternalName,
        ExternalName : word;
        NotEof : boolean;
begin
        ¯ Terminal ò
        InSymbol ;
    if InternalId <> 'BEGIN' then begin ¯ Terminal part need not be ther
        if InternalId <> 'TERMINAL' then
          begin
            Error (5) ;
            Skip ([SemiSy])
          end ;
        NotEof := not eof(Input);
        InSymbol  ;
        while (InternalId <> 'END') and NotEof do
          begin
            if (Sy <> Ident) AND (Sy <> Res) then
              begin
                Error (6);
                Skip ([Ident,Res])
              end;
            InternalName := InternalId  ;
            ExternalName := ExternalId  ;
            LKey := SyKey ;
            InSymbol;
            if Sy <> EqSy  then
              begin
                Error (7)  ;
                Skip ([Intconst])
              end
            else InSymbol  ;
            TP :=EnterId(ExternalName, InternalName, LKey, Term, SyVal,
            NotEof := not eof(Input);
            InSymbol  ;
            if Sy = SemiSy  then begin
                NotEof := not eof(Input);
                InSymbol;
            end;
          end  ;
        InSymbol ;
        if Sy= SemiSy then
            InSymbol;
    end; ¯ Allow Terminal part to be absent... ò
end ;
    ¯ Terminal ò



    procedure ReadG   ;
        ¯********************************************ò
        ¯*                                          *ò
        ¯*  ReadG                                   *ò
        ¯*                                          *ò
        ¯* THIS procedure Reads in THE Grammar      *ò
        ¯* AND SETS UP THE symbol Table             *ò
        ¯*                                          *ò
        ¯********************************************ò
    label
        1,2;
    var
        T,U¯ CURRENT RHS TranSITION ò
        ,Q:   prodptrty ;¯ LHS Production ò
        V,P:   identptrty ;¯ LHS symbol ò
        R,S:   listptrty ;¯ of Production NO ò
        PopNo:   integer ;
        NotEof : boolean;
      begin
        ¯ ReadG ò
        if Trace then
          begin
            writeln(TTYOut,'ReadG') ;
            Break
          end ;
        if InternalId <> 'BEGIN' then
          begin
            Error(14) ;
            Skip([Ident,Res])
          end
        else InSymbol ;
        NotEof := TRUE;
        while (InternalId <> 'END') and NotEof do
          begin
            if (Sy <> Ident) AND (Sy <> Res) then
              begin
                  repeat
                    Error (9)  ;
                    Skip ([SemiSy])  ;
                    NotEof := not eof(Input);
                    InSymbol
                  until (Sy=Ident) or (Sy=Res) or not NotEof;
                goto 1
              end ;
            P := FindId (InternalId, SyKey, [NonTerm,Term])  ;
            if P <> NIL then
            if P@.Kind=Term then P@.Kind := NonTerm ;
            if P = NIL then
                P := EnterId ( ExternalId, InternalId, SyKey,
                               NonTerm, MaxCode+1, Sy );
            ¯ ENTER RHS ò
            InSymbol   ;
            if Sy <> EqSy then
              begin
                Error (10)  ;
                Skip ([SemiSy])  ;
                InSymbol  ;
                goto 1
              end  ;
            Q := P@.FirstAlt ;
            if Q<> NIL then while Q@.NxtAlt<> NIL do
            Q := Q@.NxtAlt ;
              repeat
                PopNo := 0  ;
                new (U)  ;
                if Q = NIL then P@.FirstAlt := U
                else Q@.NxtAlt   := U  ;
                Q := U  ;
                with Q@ do
                  begin
                    Next := NIL  ;
                    XDef :=  P   ;
                    Action := NIL  ;
                    NxtAlt := NIL
                  end ;
                if  ProdNo < MAXRULENO then ProdNo := ProdNo +1
                else   Error (12)  ;
                new (R)  ;
                S := P@.Defin;
                if S <> NIL  then
                  begin
                    while S@.CDR <> NIL  do  S:= S@.CDR  ;
                    S@.CDR  := R ;
                  end
                else  P@.Defin  := R  ;

                R@.CDR := NIL ;
                R@.CAR  := ProdNo     ;
                RuleTab [ProdNo]  := Q;
                Q@.Production := ProdNo ;
                InSymbol;
                if (Sy = SemiSy) or (Sy = OrSy ) then
                  begin
                    PopTab [ProdNo] := PopNo ;
                    if PopNo > MaxPop then MaxPop := PopNo;
                    if Sy= SemiSy
                    then
                      begin
                        InSymbol  ;
                        goto 1
                      end
                    else
                    goto 2
                  end
                else while (Sy=Ident) or (Sy=Res) do
                  begin
                    PopNo := PopNo+1 ;
                    V :=  FindId (InternalId,SyKey, [NonTerm , Term]) ;
                    if V = NIL then
                        V := EnterId (ExternalId, InternalId, SyKey,
                                      Term, MaxCode+1, Sy) ;
                    new (T)  ;
                    U@.Next  :=T ;
                    U   :=T ;
                    T@.Action  := V  ;
                    T@.XDef     := P  ;
                    T@.NxtAlt := NIL  ;
                    T@.Next    := NIL  ;
                    S := V@.UsedIn  ;
                    new (R)  ;  R@.CDR  := NIL ;
                    if  S <> NIL then
                      begin
                        while  S@.CDR <> NIL do  S := S@.CDR  ;
                        S@.CDR  := R  ;
                      end
                    else    V@.UsedIn  :=  R ;
                    R@.CAR := ProdNo ;
                    InSymbol
                  end  ;
                PopTab[ProdNo] := PopNo ;
                if PopNo > MaxPop then MaxPop := PopNo;
                if Sy = SlashSy  then
                  begin
                    InSymbol ;
                    if Sy <> Ident
                    then
                      begin
                        Error (9)  ;
                        Skip ([SemiSy]);
                        goto 1
                      end  ;
                    V := FindId (InternalId, SyKey, [Lab]) ;
                    if V=NIL then
                        V:= EnterId (ExternalId, InternalId, SyKey, Lab,
                    S := V@.UsedIn ;
                    new(R) ; R@.CDR := NIL;
                    if S <> NIL then
                      begin
                        while S@.CDR <> NIL do S :=S@.CDR;
                        S@.CDR := R
                      end
                    else V@.UsedIn := R;
                    R@.CAR := ProdNo ;
                    Q@.Action := V  ;
                    InSymbol
                  end ;

                2:
              until Sy <> OrSy ;
            if Sy <> SemiSy then
              begin
                Error (13)  ;
                Skip ([SemiSy])  ;
              end ;
            NotEof := not eof(Input);
            InSymbol ;
            1:
          end ;
        MaxProdNo := ProdNo ;
        if (PopTab [1] <> 2) or
            (RuleTab [1]@.Next@.Next@.Action@.InternalName <> 'GOALSY')
         or (RuleTab[1]@.NxtAlt <> NIL)
        then writeln(TTYOut,'First production must have GOAL symbol.');
      end ;
    ¯ ReadG  ò



    procedure  PrintG ;
        ¯*****************************************************ò
        ¯*                                                   *ò
        ¯*  PrintG                                           *ò
        ¯*                                                   *ò
        ¯*THIS procedure PRinTS OUT A forMATTED              *ò
        ¯*  Grammar ONto FILENAM. new                        *ò
        ¯*                                                   *ò
        ¯*                                                   *ò
        ¯*                                                   *ò
        ¯*****************************************************ò
    var
        I,Count  : integer ;



        procedure PrintProd ( LHS : prodptrty
            ;ProdNo  :  integer  ) ;
            ¯***********************************************ò
            ¯*                                             *ò
            ¯* Print Prod                                  *ò
            ¯*                                             *ò
            ¯*   THIS procedure PRINTS OUT A Production    *ò
            ¯*                                             *ò
            ¯*                                             *ò
            ¯***********************************************ò
        var
            RHS    : prodptrty ;



            procedure    PrintRHS  ( LinK  :  prodptrty )  ;
                ¯***********************************************ò
                ¯*                                             *ò
                ¯* PrintRHS                                    *ò
                ¯*                                             *ò
                ¯*    THIS procedure PRINTS OUT THE RIGHT      *ò
                ¯*    HAND SIDE of A Production                *ò
                ¯*                                             *ò
                ¯*                                             *ò
                ¯***********************************************ò

              begin
                ¯ PrintRHSò
                Count  := 0  ;
                if LinK= NIL
                then write(CrefPas,'                   ')
                else
                  repeat
                    if Count = 3  then
                      begin
                        writeln ( CrefPas)  ;
                        Count := 0  ;
                        write ( CrefPas,'                         ');
                      end   ;
                    Count := Count + 1   ;
                    write ( CrefPas, LinK@.Action@.ExternalName,'   ');
                    LinK :=  LinK@.Next
                  until  LinK = NIL  ;
                if LHS@.Action <> NIL
                then
                  begin
                    while Count <2 do
                      begin
                        write(CrefPas,'               ');
                        Count := Count+1 ;
                      end;
                    write ( CrefPas, '/  ', LHS@.Action@.ExternalName);
                  end ;
                if LHS@.NxtAlt = NIL
                then write ( CrefPas, '  ;  ');
              end ;
            ¯  PrintRHS ò



          begin
            ¯ PRINT prod ò
            if ProdNo <  10
            then write (CrefPas, '  ', ProdNo:1)
            else if ProdNo < 100
            then write (CrefPas, ' ', ProdNo : 2)
            else if ProdNo < 1000
            then write (CrefPas, ProdNo : 3)  ;
            if LHS@.XDef@.FirstAlt = LHS then
            write ( CrefPas,'   ', LHS@.XDef@.ExternalName, '=   ')
            else write ( CrefPas, '               ', '   !   ' );
            RHS :=  LHS@.Next ;
            PrintRHS (RHS)  ;
            writeln(CrefPas,' # ',LHS@.Production) ;
          end ;



      begin
        ¯ PRINT Gò
        I := B14 ;
        Ch := ChR (I) ;
        writeln (CrefPas, Ch)  ;
        writeln (CrefPas, '                      Grammar ');
        writeln (CrefPas, '                      ======= ');
        writeln (CrefPas)  ;
        for I := 1 to MAXRULENO do
        if RuleTab [I] <> NIL
        then PrintProd (RuleTab [I], I) ;
        writeln (CrefPas, Ch)
      end  ;
    ¯ PRINT Gò








    procedure  PrintCref ;
        ¯******************************************************ò
        ¯*                                                    *ò
        ¯*PrintCref                                           *ò
        ¯*                                                    *ò
        ¯*   THIS procedure CONTROLS THE PRINTinG of THE      *ò
        ¯*    CROSS REFERENCE listinG                         *ò
        ¯*                                                    *ò
        ¯*                                                    *ò
        ¯******************************************************ò
    type
        symlistptrty = @ symlist ;
        symlist =  record
                          Sym : identptrty;
                          CDR : symlistptrty
                   end ;
    var
        Head  :  symlist  ;
        I  :  integer  ;
        Ch  :  char     ;

procedure PrintTerm (IdKind : setofnamety) ;

        ¯*****************************************ò
        ¯*                                       *ò
        ¯* PrintTerm                             *ò
        ¯*                                       *ò
        ¯*  THIS procedure PRINTS OUT THE        *ò
        ¯* Terminal symbol DefinITIONS           *ò
        ¯*                                       *ò
        ¯*****************************************ò

var

        P : symlistptrty;



begin    ¯ PrintTerm ò


        P := Head.CDR ;

        while P <> NIL do begin
                if P@.Sym@.Kind in IdKind then begin
                    write(TerPas,P@.Sym@.ExternalName,' = ');
                    if P@.Sym@.SpId = Res then
                        writeln(TerPas, '-1 ;')
                    else
                        writeln(TerPas,P@.Sym@.Code,' ;');
                end;
                P := P@.CDR ;

        end ;

end  ¯ PrintTerm ò ;



        procedure   PrintVoc  (IdKind : setofnamety) ;
            ¯**********************************************************ò
            ¯*                                                        *ò
            ¯*    PrintVoc                                            *ò
            ¯*                                                        *ò
            ¯*        THIS procedure PRINTS OUT CROSS REFERENCE       *ò
            ¯*   inforMATION for Terminals , NON-                     *ò
            ¯*   Terminals AND Action labelS                          *ò
            ¯*                                                        *ò
            ¯**********************************************************ò
        var
            P   :    symlistptrty ;
            Count :   integer    ;
            Q :    listptrty ;
          begin
            ¯  PRINT VOC  ò
            if Trace then
              begin
                writeln(TTYOut,'VOC') ;
                Break
              end ;
            P :=   Head.CDR ;
            while  P <> NIL  do
              begin
                if       P@.Sym@.Kind
                in  IdKind
                then
                  begin
                    writeln (CrefPas)  ;
                    writeln(CrefPas);writeln(CrefPas);
                    write(CrefPas, P@.Sym@.ExternalName);
                    if P@.Sym@.SpId <> Res then
                        write(CrefPas, '  ',P@.Sym@.Code)
                    else
                        write(CrefPas,'     Reserved');
                    writeln(CrefPas) ;
                    write(CrefPas, ' Defined ') ;
                    Count := 0   ;
                    Q := P@.Sym@.Defin;
                    while  Q <> NIL  do
                      begin
                        if Count = 4 then
                          begin
                            writeln (CrefPas) ;
                            Count:=0          ;
                            write  (CrefPas,'         ')
                          end ;
                        Count := Count +1   ;
                        write (CrefPas, Q@.CAR, '   ') ;
                        Q := Q@.CDR
                      end     ;
                    writeln (CrefPas);
                    Count  :=0;
                    Q := P@.Sym@.UsedIn ;
                    write (CrefPas, ' Used    ') ;
                    while Q <> NIL  do
                      begin
                        if   Count =4   then
                          begin
                            writeln (CrefPas) ;
                            Count :=0  ;
                            write (CrefPas,'         ')
                          end   ;
                        Count := Count +1 ;
                        write (CrefPas , Q@.CAR, '   ') ;
                        Q := Q@.CDR
                      end   ;
                  end ;
                P:= P@.CDR
              end   ;
          end ;
        ¯  PRINT VOC  ò



        procedure    Sort ;
            ¯************************************************ò
            ¯*                                              *ò
            ¯*    Sort                                      *ò
            ¯*                                              *ò
            ¯*       THIS procedure SortS THE symbol Table  *ò
            ¯*                                              *ò
            ¯************************************************ò
        label
            1,2;
        var
            I,K :  integer      ;
            X   :   identptrty ;
            P,Q,R   :   symlistptrty ;
          begin
            ¯  Sort  ò
            if Trace then
              begin
                writeln(TTYOut,'Sort');
                Break
              end ;
            Head.CDR := NIL ;
            for K :=  0 to  NAMETABSIZE         do
              begin
                X := NameTab [K] ;
                while X <> NIL  do
                  begin
                    new (R)   ;
                    R@.Sym  := X  ;
                    R@.CDR  := NIL;
                       ¯  Enter in chain  ò
                    Q       := Head.CDR   ;
                    if Q=NIL then Head.CDR:= R
                    else
                      begin
                        if R@.Sym@.InternalName<Q@.Sym@.InternalName
                        then
                          begin
                            Head.CDR := R;
                            R@.CDR := Q
                          end
                        else
                          begin
                            P       :=  Q@.CDR    ;
                            while (P <> NIL)
                            do
                              begin
                                if R@.Sym@.InternalName < P@.Sym@.Intern
                                    then goto 1;
                                Q :=P   ;
                                P := P@.CDR
                              end   ;
                            1:  Q@.CDR := R  ;
                            R@.CDR := P
                          end ;
                      end ;
                    X:= X@.Nic
                  end
              end   ;
            ¯  for  ò
            2:
          end   ;
        ¯  Sort  ò
      begin
        ¯  PRINT CREF  ò
        mark(Heap);
        Sort ;
        if Grammar then begin
        I :=  B14   ;
        Ch :=  ChR(I)  ;
        writeln (CrefPas, Ch)   ;
        writeln (CrefPas, '                      Cross Reference ');
        writeln (CrefPas, '                      ================');
        writeln (CrefPas,'      Terminals') ;
        writeln (CrefPas);
        PrintVoc([Term])      ;
        writeln (CrefPas, Ch) ;
        writeln (CrefPas,'     Non Terminals')  ;
        PrintVoc([NonTerm])    ;
        writeln (CrefPas, Ch)  ;
        writeln (CrefPas, '     Label')  ;

        PrintVoc([Lab]) ;
        writeln (CrefPas, Ch)  ;
        end ;
        if Terminals and NonTerminals then
            PrintTerm([ Term, NonTerm ])
        else if Terminals then
            PrintTerm([Term])
        else if NonTerminals then
            PrintTerm([NonTerm]);
        release (Heap)
      end   ;
    ¯  PRINT CREF  ò






    procedure PrintCon (T : tranptrty) ;
        ¯********************************************************ò
        ¯*                                                      *ò
        ¯*    PrintCon                                          *ò
        ¯*                                                      *ò
        ¯*   THIS procedure PRINT A CONFIGURATION in Symbolic   *ò
        ¯* forM                                                 *ò
        ¯*                                                      *ò
        ¯*   in :   T  GIVEN CONFIGURATION                      *ò
        ¯********************************************************ò
    var
        X : integer ;
        J : integer ;
        Red,SameLine : boolean ;
        P : prodptrty ;



      begin
        ¯ PRINT CON  ò
        X := T@.Pos ;
        P := T@.Rule ;
        SameLine := TRUE ;
        Red := FALSE ;
        J := 0 ;
        write(CrefPas,'* ');
        write(CrefPas,P@.XDef@.ExternalName);
        write(CrefPas,' = ');
        while X <> 0 do
          begin
            P := P@.Next ;
            write (CrefPas,P@.Action@.ExternalName,' ') ;
            X := X-1 ;
            J := J+1;
            if J >= 3 then
              begin
                writeln(CrefPas,'   *');
                write(CrefPas,'*                   ');
                J := 0
              end ;
          end ;
        write(CrefPas,'# ');
        P := P@.Next ;
        if P= NIL then Red := TRUE else Red := FALSE ;
        while P <> NIL do
          begin
            write(CrefPas,P@.Action@.ExternalName,' ');
            J := J+1 ;
            if J >= 3 then
              begin
                writeln(CrefPas,' *');
                write(CrefPas,'*                     ');
                SameLine := FALSE ;
                J := 0 ;
              end ;
            P := P@.Next
          end ;
        if Red then
          begin
            while J < 2 do
              begin
                write(CrefPas,'                ');
                J := J+1 ;
              end ;
            P := T@.Rule ;
            if P@.Action <> NIL then
              begin
                write(CrefPas,'/ ');
                write(CrefPas,P@.Action@.ExternalName);
                writeln(CrefPas,'*');
                if T@.NextState <> NIL then
                writeln(CrefPas,'*                                  ',
                '                   ',T@.NextState@.State:10,'       *')
              end
            else if T@.NextState <> NIL
            then writeln(CrefPas,T@.NextState@.State:10,'       *')
            else writeln(CrefPas,'                 *');
          end
        else
          begin
            while J <2 do
              begin
                write(CrefPas,'                ');
                J := J+1
              end ;
            if T@.NextState <> NIL then
              begin
                write(CrefPas,T@.NextState@.State: 10);
                if SameLine then writeln(CrefPas,'       *')
                else writeln(CrefPas,'       *');
              end
            else if SameLine then writeln(CrefPas,'                 *')
            else writeln(CrefPas,'                 *');
          end
      end   ¯   PRINT CON ò   ;



    procedure PrintState(S :stateptrty)  ;
        ¯**************************************************ò
        ¯*                                                *ò
        ¯*  PrintState                                    *ò
        ¯*                                                *ò
        ¯*  THIS PROC PRINTS A State                      *ò
        ¯*   in   :   S State                             *ò
        ¯**************************************************ò
    var
        T : tranptrty ;
        ST : stateptrty ;


      begin
        ¯ PrintState ò

        writeln(CrefPas) ;
        writeln(CrefPas) ;
        writeln(CrefPas,'*******************************************',
                        '*****************************');
        write(CrefPas,'*     State ');
        write(CrefPas,S@.State) ;
          case S@.Kind of
            Reads : write(CrefPas,' read State ');
            Inadequate:write (CrefPas,' Inadequate ');
            Lookahead :write (CrefPas, ' Lookahead  ') ;
            Reduction  : write (CrefPas, ' Reduction  ') ;
            LAString : write (CrefPas,' LAString   ') ;
            Subgoal : write (CrefPas, ' Subgoal    ')
          end ;
        writeln( CrefPas, '                                   *');
        writeln(CrefPas,'*******************************************',
                        '*****************************');
        writeln(CrefPas,'*                                          ',
                        '                            *');
        T := S@.FirstTran ;
        while T <> NIL do
          begin
            PrintCon(T) ;
            T := T@.Next
          end ;
        writeln(CrefPas,'*******************************************',
                        '*****************************');
        writeln(CrefPas) ;
        writeln(CrefPas)
      end  ¯ PrintState ò   ;



    procedure OutFSM ;
        ¯*********************************************ò
        ¯*                                           *ò
        ¯*         OutFSM                            *ò
        ¯*    THIS PROC OUTPUTS FSM Tables           *ò
        ¯*                                           *ò
        ¯*********************************************ò

    label
        1;
    var
        I : integer ;


      begin
        ¯ OutFSM ò
        I := B14 ;
        Ch := ChR(I) ;
        writeln(CrefPas,Ch) ;
        writeln(CrefPas,'                      Characteristic States');
        writeln(CrefPas,'                      =====================');
        writeln(CrefPas);writeln(CrefPas);writeln(CrefPas);
        for I := 0 to MAXSTATE do
          begin
            if NState [ I ] = NIL then goto 1 ;
            PrintState (NState [I])
          end ;
        1:
      end     ¯ OutFSM ò  ;







    procedure PrintTab ;
        ¯************************************************ò
        ¯*                                              *ò
        ¯* PrintTab                                     *ò
        ¯*                                              *ò
        ¯*    THIS procedure PRINTS THE symbol Action   *ò
        ¯*  Tables .                                    *ò
        ¯*                                              *ò
        ¯************************************************ò

    var
        I : integer ;
        T,A : integer ;



      begin
        ¯ PRINT TABò
        I := B14 ;
        Ch := ChR(I);
        writeln(CrefPas,Ch);
      I := 3*Index +3 ; ¯ NUMBER of ENTRIESò
        writeln(CrefPas);
        writeln(CrefPas,'                Parsing Tables');
        writeln(CrefPas,'                ==============');
        writeln(CrefPas);writeln(CrefPas);writeln(CrefPas);
        writeln(CrefPas,'.__________________________________________',
                        '___________________________.');
        writeln(CrefPas,'! Index  Symbol Name                 Action',
                        '  Pop    Semantics         !');
        writeln(CrefPas,'.__________________________________________',
'___________________________.');
        for I := 0 to Index do
          begin
            write(CrefPas,'!',I:5);
            T := Table[I].Tran ;
            A := Table[I].Action ;
            if T=elseCode then write(CrefPas,'    ELSE')
            else if T=XCONTinUE then  write(CrefPas,'    CONT')
            else write (CrefPas,'   ',T:5);
            if (T >=0 ) AND (T <= MAXVOCSIZE)
            then write(CrefPas,'  ',SymbolName[T]@.ExternalName)
            else write(CrefPas,'                 ');
            if A<= 0 then
              begin
                if A <= -NOSCANCODE then write(CrefPas,' ',-A-NOSCANCODE
                else
                write(CrefPas,' ',-A:4,'#');
                if A <= -NOSCANCODE then write(CrefPas,'NO SCAN')
                else write (CrefPas,'       ');
              end
            else if A= ERRORCODE  then write(CrefPas,'   Error
            else write(CrefPas,'   ',A:5,'            ');


            if A < 0 then
              begin
                if A <= - NOSCANCODE then A := A+NOSCANCODE;
                write(CrefPas,PopTab[-A]:4,'     ');
                if RuleTab[-A]@.Action <> NIL then
                    write(CrefPas,RuleTab[-A]@.Action@.ExternalName)
                else write(CrefPas,'               ');
              end
            else write(CrefPas,'                 ');
            writeln(CrefPas,'  !');
            writeln(CrefPas,'.______________________________________',
                            '_______________________________.');
          end ¯ forò ;
      end ¯ PRINT TABò ;



    function NextTran (S :stateptrty; T : tranptrty ):tranptrty ;

        ¯******************************************************ò
        ¯*                                                    *ò
        ¯* NextTran                                           *ò
        ¯*                                                    *ò
        ¯*    THIS function GETS THE Next UNMarkED            *ò
        ¯* TranSITION FROM State S. THE CURRENT TranSITION IS *ò
        ¯* T. IT RETURNS NIL if NO Next TranSITION EXISTS     *ò
        ¯*                                                    *ò
        ¯*  in    : S    CURRENT State                        *ò
        ¯*          T    CURRENT TranSITION                   *ò
        ¯*                                                    *ò
        ¯*  OUT   :                                           *ò
        ¯*                                                    *ò
        ¯*  GLOBAL                                            *ò
        ¯*                                                    *ò
        ¯* ResULT    PTR to Next TranSITION                   *ò
        ¯******************************************************ò


    label
        1;
    var
        CurTran   : tranptrty   ;

      begin
        ¯ NextTran ò
        if Trace then
          begin
            writeln(TTYOut,'NextTran');Break
          end;
        CurTran := T ;
        if CurTran = NIL then
          begin
            CurTran := S@.FirstTran ;
            if CurTran = NIL then
                writeln(TTYOut,'**System error** in NextTran');
            CurTran@.MarkE := TRUE
          end
        else
          begin
            while  CurTran@.MarkE do
              begin
                CurTran := CurTran@.Next ;
                if CurTran = NIL then goto 1
              end ;
            1:    if CurTran = NIL then
              begin
                CurTran := S@.FirstTran ;
                  repeat
                    CurTran@.MarkE := FALSE ;
                    CurTran       := CurTran@.Next
                  until CurTran = NIL
              end
            else CurTran@.MarkE := TRUE
          end ;
        NextTran := CurTran
      end     ¯ NextTran ò   ;









    function ConMatch(C1,C2 : tranptrty) : boolean ;
        ¯***************************************************ò
        ¯*                                                 *ò
        ¯*   ConMatch                                      *ò
        ¯*                                                 *ò
        ¯*     THIS function COMPARes TWO CONFIGURATIONS   *ò
        ¯*  AND RETURNS THE ResULT                         *ò
        ¯*      TWO CONFIGURATIONS MATCh if EVERYTHinG     *ò
        ¯* BEYOND THE Dot MATChES inCL THE Action          *ò
        ¯*   for THE Research VERSION . OTHERWISE USUAL DRF *ò
        ¯*                                                 *ò
        ¯*    in      : C1,C2 CONFIGURATIONS               *ò
        ¯*                                                 *ò
        ¯*                                                 *ò
        ¯*   GLOBAL          in :   RuleTab                *ò
        ¯*                                                 *ò
        ¯*  ResULT     TRUE if MATChES                     *ò
        ¯***************************************************ò


    label
        1;
    var
        I1, I2,I   : integer  ;
        X1,X2  : prodptrty ;



      begin
        ¯ ConMatch    ò
        I1 :=C1@.Pos ;
        I2 := C2@.Pos ;
        X1 := C1@.Rule ;
        X2 := C2@.Rule ;
        if not Research then begin
            if (I1=I2) and (X1=X2) then
                ConMatch := TRUE
            else
                ConMatch := FALSE;
        end else begin
            if (X1@.Action <> X2@.Action) or (I1 <> I2) then
                ConMatch := FALSE
            else begin
                for I := 0 to I1 do
                X1:= X1@.Next ;
                for I := 0 to I2 do
                X2 := X2@.Next ;
                while (X1<>NIL) and (X2 <> NIL) do
                  begin
                    if X1@.Action <> X2@.Action
                    then
                      begin
                        ConMatch := FALSE;
                        goto 1
                      end ;
                    X1:= X1@.Next;
                    X2 := X2@.Next

                  end ;
                if (X1=NIL) and (X2 = NIL)
                then ConMatch := TRUE
                else ConMatch  := FALSE ;
              end ;
          end ;
        1:

      end  ¯ ConMatch  ò   ;



    procedure AddT( S: stateptrty ; T : tranptrty) ;
        ¯*****************************************************ò
        ¯*                                                   *ò
        ¯*  AddT                                             *ò
        ¯*                                                   *ò
        ¯*     THIS procedure ADDS A CONFIGURATION to THE    *ò
        ¯* GIVEN State . IT ALSO MAKES SURE THE doES not EXIST*ò
        ¯*  BEforE ENTERinG IT                               *ò
        ¯*     in       :S   GIVEN State                     *ò
        ¯*               T  GIVEN CONFIGURATION              *ò
        ¯*****************************************************ò


    label
        1;
    var
        Tx,Ty   : tranptrty ;



      begin
        ¯  AddT  ò

        Tx  := S@.FirstTran  ;
        if Tx = NIL then S@.FirstTran := T
        else
          begin
            while Tx <> NIL do
              begin
                if ConMatch(Tx,T) then goto 1  ;
                Ty := Tx ;
                Tx := Tx@.Next
              end ;
            Ty@.Next   := T  ;
          end ;
        1:
      end   ¯ AddT ò   ;






    function Token(PR : prodptrty ;PS : integer) : identptrty ;
        ¯***************************************************ò
        ¯*                                                 *ò
        ¯*  Token                                          *ò
        ¯*                                                 *ò
        ¯* THIS function RETURNS A POinTER to THE NE T     *ò
        ¯* Token GIVEN A Rule NO. and  A Pos NUM           *ò
        ¯*                                                 *ò
        ¯*   in         : PS   PosITION                    *ò
        ¯*                 PR Production                   *ò
        ¯*   OUT                                           *ò
        ¯*                                                 *ò
        ¯   ResULT         PTR to Next Token               *ò
        ¯***************************************************ò

    label
        1;
    var
        X : identptrty    ;
        I :  integer    ;
        Y  : prodptrty  ;



      begin
        ¯ Token   ò
        Token := NIL;
        Y := PR ;
        for I := 0 to PS
        do
          begin
            Y := Y@.Next ;
            if Y = NIL then
            goto 1
          end ;
        Token :=Y@.Action ;
        1:

      end   ¯ Token ò ;



    procedure AddL (S :stateptrty) ;
        ¯***************************************************ò
        ¯*                                                 *ò
        ¯*  AddL                                           *ò
        ¯*                                                 *ò
        ¯*    THIS procedure ADDS A State to THE list of   *ò
        ¯*  of Inadequate StateS                           *ò
        ¯*                                                 *ò
        ¯*    in : S State                                 *ò
        ¯*                                                 *ò
        ¯***************************************************ò

    var
        X,Y  : statelistptr ;



      begin
        ¯ AddL ò
        new(X)  ;
        X@.CAR := S  ;
        X@.CDR := NIL ;
        if Inadeq = NIL then Inadeq := X
        else
          begin
            Y := Inadeq ;
            while Y@.CDR <> NIL do Y := Y@.CDR ;
            Y@.CDR := X
          end
      end   ¯ AddL ò  ;




    procedure   CFSM (var  Lr0 : boolean)   ;
        ¯*********************************************************ò
        ¯*                                                       *ò
        ¯*     CFSM                                              *ò
        ¯*       THIS procedure COMPUTES THE charACTERISTIC      *ò
        ¯*  FinITE State MAChinE. Lr0 IS set to FALSE            *ò
        ¯*  if ANY Inadequate State EXISTS. A list of Inadequate *ò
        ¯*  StateS IS MAinTAinED BY GENS                         *ò
        ¯*                                                       *ò
        ¯*                                                       *ò
        ¯*                                                       *ò
        ¯*********************************************************ò
    var
        S : stateptrty ;
        S1   : stateptrty ;
        Sl1 : statelistptr ;
        AllReduce : boolean ;



        procedure Closure (A :stateptrty;C:tranptrty;
            var Reduce : boolean) ;
            ¯**************************************************ò
            ¯*                                                *ò
            ¯*   Closure                                      *ò
            ¯*                                                *ò
            ¯*     THIS procedure PERforMS THE Closure        *ò
            ¯* function ON THE GIVEN CONFIGURATIONS           *ò
            ¯*                                                *ò
            ¯*    in     : A  THE GIVEN State                 *ò
            ¯*             C   CURRENT CONFIG                 *ò
            ¯*    OUT    : Reduce  set to TRUE if Reduction   *ò
            ¯*                         N State                *ò
            ¯*                                                *ò
            ¯*   GLOBAL                                       *ò
            ¯*                                                *ò
            ¯**************************************************ò


        label
            1;
        var
            CPos : integer   ;
            Con,CRule : prodptrty ;
            X,Tran   : tranptrty  ;
            Nt   : identptrty   ;
            function Config(Pr : prodptrty ; N: integer) : tranptrty ;






                ¯*****************************************************ò
                ¯*                                                   *ò
                ¯*  Config                                           *ò
                ¯*                                                   *ò
                ¯*     THIS function CREAES A ConfigURATION          *ò
                ¯*                                                   *ò
                ¯*    in          :  Pr  Production                  *ò
                ¯*                N    PosITION in prod              *ò
                ¯*                                                   *ò
                ¯*  ResULT         PTR to new Config                 *ò
                ¯*****************************************************ò


            var
                X   : tranptrty    ;

              begin
                ¯  Config   ò
                new(X) ;
                with X@
                do
                  begin
                    Rule := Pr ;
                    Pos := N  ;
                    MarkE  := FALSE ;
                    Next := NIL ;
                    NextState := NIL
                  end ;
                Config  := X


              end ¯ Config ò   ;



          begin
            ¯ Closure   ò
            if Trace then
              begin
                writeln(TTYOut,'Closure');Break
              end ;
            CRule  := C@.Rule ;
            CPos   := C@.Pos;
            Nt    :=  Token(CRule,CPos) ;
            if Nt <> NIL
            then
              begin
                AllReduce := FALSE ;
                if Nt@.Kind = NonTerm
                then
                  begin
                    Tran := A@.FirstTran ;
                      repeat
                        if (Nt =Tran@.Rule@.XDef) and
                        (Tran@.Pos = 0) then goto 1;
                        Tran := Tran@.Next
                      until Tran = NIL ;
                    Con := Nt@.FirstAlt;
                    while Con <> NIL do
                      begin
                        X := Config(Con,0);
                        AddT(A,X) ;
                        Con := Con@.NxtAlt
                      end
                  end
              end
            else Reduce := TRUE ;
            1:
          end ¯ Closure   ò    ;


        function CIS : stateptrty ;
            ¯*****************************************************ò
            ¯*                                                   *ò
            ¯*  CIS                                              *ò
            ¯*                                                   *ò
            ¯* THIS procedure SETS UP THE inITIAL State and      *ò
            ¯* ALSO ChECKS to SEE if THE FIRST Production        *ò
            ¯* WAS APPrOPrIATELY SET. if not IT GIVES AN Error   *ò
            ¯*   IT RETURNS A POinTER to THE FIRST State         *ò
            ¯*                                                   *ò
            ¯*    GLOBAL    in:   RuleTab                        *ò
            ¯*                    PopTab                         *ò
            ¯*                                                   *ò
            ¯*            OUT :   StateTab                       *ò
            ¯*                    NState,CurrentState            *ò
            ¯*                                                   *ò
            ¯*                                                   *ò
            ¯*   ResULT    POinTER to FIRST State                *ò
            ¯*                                                   *ò
            ¯*****************************************************ò
        var
            X  : stateptrty ;
            Y  : tranptrty ;
            I   : integer ;
            B   : boolean ;
          begin
            ¯  CIS ò
            if Trace then
              begin
                writeln(TTYOut,'CIS');
                Break
              end  ;
            I := 0 ;
            new(X) ;
            new(Y) ;
            CurrentState := 0 ;
            StateTab [0] := X ;
            with X@ do
              begin
                FirstTran := Y ;
                Back      := NIL ;
                Nic       := NIL ;
                State     := 0 ;
                Kind       := Reads
              end ;
            NState [ 0] := X;
            with Y@ do
              begin
                Next := NIL ;
                NextState := NIL ;
                Rule      := RuleTab [1] ;
                Pos       := 0 ;
                MarkE      := FALSE
              end ;
            I  := 1 ;
            CIS := X ;
            B := FALSE ;
            AllReduce := TRUE ;
            Y := NIL ;
              repeat begin
                Y := NextTran(X,Y) ;
                if Y = NIL then
                    leave;
                Closure( X,Y,B) ;
                I := I+1 ;
              end until 1 <> 1;
            if B then if I= 1 then X@.Kind := Reduction
            else
              begin
                AddL(X) ;
                X@.Kind := Inadequate ;
              end ;
          end    ¯ CIS ò   ;




        procedure GenS (S : stateptrty ; var Lr0: boolean) ;

            ¯*****************************************************ò
            ¯*                                                   *ò
            ¯*  GenS                                             *ò
            ¯*                                                   *ò
            ¯*  THIS procedure GENERATES THE State MAChinE       *ò
            ¯* RECURSIVELY. IT SETS Lr0 to FALSE if NECESSARY    *ò
            ¯*                                                   *ò
            ¯*   in    :  S  CURRENt State                       *ò
            ¯*                                                   *ò
            ¯*   OUT   :  Lr0  inDICATES if MAChinE IS Lr0       *ò
            ¯*                                                   *ò
            ¯*   GLOBAL                                          *ò
            ¯*****************************************************ò


        var
            Z : prodptrty   ;
            I : integer   ; ¯ ConTROL  varIABLEò
            X : tranptrty    ;
            Y : stateptrty   ;
            B : boolean     ;




            function CHash( S: stateptrty) : integer ;
                ¯**************************************************ò
                ¯*                                                *ò
                ¯*  CHash                                         *ò
                ¯*                                                *ò
                ¯*     THIS procedure produces A Key.IT USES      *ò
                ¯* THash to produce THE Key                       *ò
                ¯*                                                *ò
                ¯*  in   : S State                                *ò
                ¯*                                                *ò
                ¯**************************************************ò
            var
                Key   : integer   ;
                T     : tranptrty ;



                function THash( X: tranptrty) : integer ;
                    ¯**************************************************ò
                    ¯*                                                *ò
                    ¯* THash                                          *ò
                    ¯*                                                *ò
                    ¯*  THIS function RETURNS AN integer REPresENtinG *ò
                    ¯* A ConfigURATION                                *ò
                    ¯*                                                *ò
                    ¯*   in :  X TranSITION                           *ò
                    ¯*                                                *ò
                    ¯*                                                *ò
                    ¯**************************************************ò

                var
                    Y   : prodptrty ;
                    I    : integer ;
                    TKey : integer ;



                    function Number(S: identptrty): integer ;
                      ¯*************************************************
                      ¯*
                      ¯*  Number
                      ¯*
                      ¯*  THIS function RETURNS AN integer BASED ON THE
                      ¯* VALUE of THE IdentifIER
                      ¯*
                      ¯*   in : S IdentifIER
                      ¯*************************************************
                   var
                        Y : word ;
                        I    : integer ;
                        Tally : integer ;
                      begin
                        ¯ Number ò
                        Tally := 0 ;
                        if S <> NIL then
                          begin
                            Y := S@.ExternalName ;
                            for  I := 1 to MAXNAME do
                            Tally := Tally +ord(Y[I])
                          end  ;
                        Number := Tally

                      end    ¯ Number   ò   ;


                  begin
                    ¯ THash ò
                    Y := X@.Rule ;
                    TKey :=  Number(Y@.Action) ;
                    for I := 0 to X@.Pos do Y := Y@.Next ;
                    if Y <> NIL then
                    TKey := TKey+Number(Y@.Action) ;
                    THash := TKey
                  end      ¯ THash ò    ;





              begin
                ¯ CHash ò
                Key := 0 ;
                T := S@.FirstTran ;
                while T <> NIL do
                  begin
                    Key := Key +THash(T) ;
                    T := T@.Next
                  end ;
                CHash := Key
              end ;
            ¯ CHashò






            function Complete ( S : stateptrty; T : tranptrty) :
                stateptrty ;

                ¯****************************************************ò
                ¯*                                                  *ò
                ¯* Complete                                         *ò
                ¯*                                                  *ò
                ¯* THIS function CREATES A new State and CompleteS IT *ò
                ¯* IT RETURNS A POinTER to THE CompleteD State       *ò
                ¯*                                                   *ò
                ¯*   in    :  S   CURRENt State                      *ò
                ¯*            T   TranSITION State                   *ò
                ¯*   OUT   :                                         *ò
                ¯*                                                   *ò
                ¯*   GLOBAL                                          *ò
                ¯*                                                   *ò
                ¯*  ResULT   PTR to CompleteD State                  *ò
                ¯*****************************************************ò

            var
                A : stateptrty ;
                C : tranptrty ;
                Reduce : boolean  ;
                I  : integer    ;



                function Collect (S :stateptrty;T : tranptrty):stateptrt
                    ¯************************************************ò
                    ¯*                                              *ò
                    ¯*  Collect                                     *ò
                    ¯*                                              *ò
                    ¯*  THIS function CREATES A new State  for THE  *ò
                    ¯* GIVEN TranSITION. IT ALSO CollectS ALL       *ò
                    ¯* TranSITIONS WHICh HAVE THE SAME TranSITION   *ò
                    ¯* Token and ADDS IT to THE State               *ò
                    ¯*                                              *ò
                    ¯*  in     : S CURRENt State                    *ò
                    ¯*              T CURRENt TranSITION            *ò
                    ¯*                                              *ò
                    ¯*   OUT                                        *ò
                    ¯*                                              *ò
                    ¯*   GLOBAL                                     *ò
                    ¯*                                              *ò
                    ¯*  ResULT  PTR to new State                    *ò
                    ¯************************************************ò

                var
                    X,Z : tranptrty ;
                    Y : stateptrty ;



                    function TranMatch(T1,T2 : tranptrty) : boolean ;
                       ¯***********************************************ò
                       ¯                                              *ò
                       ¯*  TranMatch                                  *ò
                       ¯*                                             *ò
                       ¯*  THIS function ChECKS to SEE if THE TranSITION
                       ¯*  Token for THE GIVEN TWO ConfigURATIONS     *ò
                       ¯*  IS THE SAME                                *ò
                       ¯*                                             *ò
                       ¯*   in       : T1,T2  ConfigURATIONS          *ò
                       ¯*                                             *ò
                       ¯*    OUT     :                                *ò
                       ¯*                                             *ò
                       ¯*   GLOBAL                                    *ò
                       ¯*                                             *ò
                       ¯*    ResULT IS TRUE if THEY MATCh             *ò
                       ¯***********************************************ò


                    var
                        R : prodptrty ;
                        I  : integer  ;
                        S1,S2 : identptrty ;



                      begin
                        ¯ TranMatch  ò
                        R   := T1@.Rule  ;
                        for I := 0 to T1@.Pos do
                            R := R@.Next  ;
                        if R = NIL then S1 := NIL
                            else S1 := R@.Action ;

                        R := T2@.Rule  ;
                        for I := 0 to T2@.Pos
                            do R := R@.Next ;
                        if R = NIL then  S2 := NIL
                            else  S2 := R@.Action  ;

                        TranMatch := S1=S2  ;

                      end       ¯ TranMatch ò     ;



                    function CreateS (S:stateptrty; T: tranptrty):statep
                      ¯*************************************************
                      ¯*
                      ¯*   CreateS
                      ¯*
                      ¯*    THIS function CreateS A new State with A Sin
                      ¯*  ConfigURATION T . IT doES not ENtER THE State
                      ¯* into  THE  State Table  SinCE THE State Complet
                      ¯ MAY EXIST ALreadY
                      ¯*
                      ¯*    IT RETURNS A POinTER to THE newLY CREATED St
                      ¯*
                      ¯*   in        : S PARENt State
                      ¯*               T  CURRENt ConfigURATION
                      ¯*
                      ¯*   OUT       :
                      ¯*
                      ¯*   GLOBAL
                      ¯*
                      ¯    ResULT    PTR to new State
                      ¯*************************************************



                    var
                        X   : stateptrty ;



                      begin
                        ¯ CreateS   ò
                        new(X)    ;
                        with X@ do
                          begin
                            FirstTran := T;
                            Nic   := NIL ;
                            Back     := NIL ;
                            State := 0    ;
                            Kind      :=Reads
                          end ;


                        CreateS := X
                      end        ¯ CreateS ò   ;



                    function  MoveDot (T : tranptrty) : tranptrty ;
                        ¯***********************************************
                        ¯*
                        ¯*   MoveDot
                        ¯*
                        ¯*       THIS function CreateS A new  ConfigURAT
                        ¯* with THE PosITION of THE Dot MOVED OVER
                        ¯*    IT RETURNS A POinTER to THIS TranSITION
                        ¯* IT doES not WATChOUT for ReductionS. THIS  ID
                        ¯* BY THE Closure function
                        ¯*
                        ¯*     in         : T CURRENt Config
                        ¯*
                        ¯*     OUT         :
                        ¯*
                        ¯*      GLOBAL
                        ¯*
                        ¯*    ResULT     PTR to new ConfigURATION
                        ¯***********************************************


                    var
                        X  : tranptrty ;

                      begin
                        ¯ MoveDot ò
                        new(X)   ;
                        with X@ do
                          begin
                            MarkE := FALSE ;
                            Next := NIL ;
                            NextState := NIL  ;
                            Rule := T@.Rule ;
                            Pos := T@.Pos +1
                          end ;


                        MoveDot  := X
                      end    ¯ MOVE Dot  ò    ;









                  begin
                    ¯ Collect  ò
                    X := MoveDot (T) ;
                    Y := CreateS (S,X)  ;
                    Z := T@.Next ;
                    while Z <> NIL do
                      begin
                        if TranMatch (Z,T)
                        then
                          begin
                            Z@.MarkE := TRUE;
                            X := MoveDot(Z) ;
                            AddT(Y,X)
                          end ;
                        Z := Z@.Next ;
                      end  ;
                    Collect := Y
                  end      ¯ Collect  ò    ;






              begin
                ¯ Complete ò
                if Trace then
                  begin
                    writeln(TTYOut,'Complete');
                    Break
                  end ;
                A := Collect(S,T) ;
                C := NextTran( A,NIL) ;
                AllReduce := TRUE ;
                Reduce := FALSE ;
                I := 0   ;
                while C <> NIL do
                  begin
                    Closure(A,C,Reduce) ;
                    I   := I+1 ;
                    C := NextTran(A,C)
                  end ;
                if Reduce then if I=1 then A@.Kind := Reduction
                else
                  begin
                    A@.Kind := Inadequate ;
                    Lr0  := FALSE
                  end ;
                Complete := A
              end   ¯ Complete ò  ;

            procedure FindS(var S: stateptrty;var Found:boolean) ;
                ¯****************************************************ò
                ¯*                                                  *ò
                ¯*  FindS                                           *ò
                ¯*                                                  *ò
                ¯*    THIS procedure ChECKS to SEE if THE GIVEN     *ò
                ¯* State ALreadY EXISTS. if SO IT UPDATES S to      *ò
                ¯* POinT to THE EXISTinG State. in THIS case Found  *ò
                ¯* IS set to TRUE                                   *ò
                ¯*                                                  *ò
                ¯*     in:                                          *ò
                ¯*                                                  *ò
                ¯*   OUT : S   POinTS to Found State                *ò
                ¯*        Found  TRUE if State IS Found             *ò
                ¯*                                                  *ò
                ¯****************************************************ò

            var
                Key   : integer ;
                X     : stateptrty  ;



                function StateMatch(S1,S2:stateptrty) : boolean ;
                    ¯***************************************************
                    ¯*                                                 *
                    ¯*  StateMatch                                     *
                    ¯*                                                 *
                    ¯*   THIS procedure ChECKS to SEE if THE GIVEN     *
                    ¯* StateS Match                                    *
                    ¯*                                                 *
                    ¯*    in:  S1,S2 THE StateS to BE MatchED          *
                    ¯*                                                 *
                    ¯***************************************************

                var
                    X,X2    : tranptrty ;
                    A,B  : integer   ;
                    Match  : boolean  ;

                  begin
                    ¯ StateMatch ò
                    StateMatch := FALSE ;
                    A := 0  ;
                    X := S1@.FirstTran   ;
                    while X <> NIL do
                      begin
                        A := A+1 ;
                        X := X@.Next ;
                      end ;

                    B := 0 ;
                    X := S2@.FirstTran ;
                    while X <> NIL do
                      begin
                        B := B+1 ;
                        X := X@.Next ;
                      end ;
                    if A =B
                    then
                      begin
                        X := S1@.FirstTran ;
                        Match := TRUE ;
                        while (X <> NIL) and Match do
                          begin
                            Match := FALSE ;
                            X2 := S2@.FirstTran ;
                            while (X2 <> NIL) and not Match do
                              begin
                                if ConMatch(X,X2) then Match := TRUE ;
                                X2 := X2@.Next
                              end ;
                            X := X@.Next
                          end ;
                        StateMatch := Match
                      end
                  end   ¯ StateMatch ò   ;



              begin
                ¯ FindS ò
                if Trace
                then
                  begin
                    writeln(TTYOut,'FindS');Break
                  end;
                Found := FALSE ;
                Key   := CHash(S) ;
                Key := Key mod STATETABSIZE ;
                X     := StateTab [Key ] ;
                while (X <> NIL) and (not Found) do
                  begin
                    if StateMatch(X,S)
                    then
                      begin
                        Found := TRUE ;
                        S     := X
                      end ;
                    X := X@.Nic
                  end
              end    ¯ FindS  ò ;





            procedure Links(From : stateptrty ;
                On   : tranptrty;
                Dest   : stateptrty  ) ;
                ¯*******************************************************
                ¯*
                ¯*  Links
                ¯*
                ¯*    THIS procedure Links THE From and to StateS
                ¯* BOTHWAYS
                ¯*
                ¯*    in :     From  State
                ¯*               Dest  State
                ¯*               On  TranSITIOn
                ¯*
                ¯*******************************************************

            var
                X,Y,Z   : tranptrty ;



              begin
                ¯ Links ò
                On@.NextState := Dest ;
                new(X)    ;
                with X@ do
                  begin
                    Next := NIL ;
                    MarkE := FALSE;
                    Pos  := On@.Pos ;
                    NextState := From ;
                    Rule   := On@.Rule
                  end ;
                Y := Dest@.Back ;
                if Y= NIL then Dest@.Back := X
                else
                  begin
                    while Y <> NIL do
                      begin
                        Z := Y ;
                        Y := Y@.Next
                      end;
                    Z@.Next := X
                  end

              end   ¯ Links ò   ;


            procedure EnterS ( From:stateptrty; On:tranptrty;Dest:statep
                ¯***************************************************ò
                ¯*                                                 *ò
                ¯*  EnterS                                         *ò
                ¯*                                                 *ò
                ¯*   THIS procedure EnterS A new State and then    *ò
                ¯* Links THE From and Dest StateS                  *ò
                ¯*                                                 *ò
                ¯*  I   : From      State                          *ò
                ¯*          Dest      State                        *ò
                ¯*                                                 *ò
                ¯*          On      TranSITIOn                     *ò
                ¯*                                                 *ò
                ¯***************************************************ò

            var
                Key  :  integer ;
                X,Z  : stateptrty  ;



              begin
                ¯ EnterS ò
                if Trace
                then
                  begin
                    writeln(TTYOut,'EnterS'); Break
                  end;
                Key := CHash(Dest)  ;
                Key := Key  mod STATETABSIZE ;
                if CurrentState >= MAXSTATE then
                  begin
                    writeln(TTYOut,'toO MANY StateS');
                    CurrentState := MAXSTATE ;
                  end
                else                 CurrentState := CurrentState+1 ;
                NState [ CurrentState ] := Dest ;
                Dest@.State := CurrentState ;
                if StateTab [Key] = NIL then StateTab[Key] := Dest
                else
                  begin
                    X := StateTab [Key ] ;
                    while X <> NIL do
                      begin
                        Z := X ;
                        X := X@.Nic
                      end ;
                    Z@.Nic := Dest
                  end ;
                Links( From,On,Dest)
              end     ¯EnterS ò   ;


          begin
            ¯ GenS  ò
            if Trace then
              begin
                writeln(TTYOut,'GenS');
                Break
              end ;
            if Debug then if FSM then PrintState(S) ;
            X := NextTran (S,NIL) ;
            while X <> NIL do
              begin
                Z := X@.Rule ;
                for I := 0 to X@.Pos
                do  Z := Z@.Next ;
                if Z <> NIL then
                  begin
                    mark(Heap) ;
                    Y := Complete (S,X) ;
                    FindS(Y,B) ;
                    if B then
                      begin
                        release(Heap) ; ¯ NO new State WAS NEEDED ò
                        Links (S,X,Y)
                      end
                    else
                      begin
                        EnterS(S,X,Y) ;
                        if Y@.Kind =Inadequate then
                          begin
                            AddL(Y) ;
                            if AllReduce then Y@.Kind:= Reduction ;
                          end ;
                        if Y@.Kind <> Reduction then
                        GenS(Y,Lr0)
                      end ;
                  end ;
                X := NextTran(S,X)
              end
          end    ¯ GenS   ò   ;





      begin
        if Trace then
          begin
            writeln(TTYOut, 'CFSM') ;
            Break
          end ;
        Lr0 := TRUE ;
        S   := CIS ; ¯ CREATE inITIAL State ò
        GenS(S,Lr0) ;
        if Debug then if IFSM then
          begin
            Sl1 := Inadeq ;
            while Sl1 <> NIL do
              begin
                S1 := Sl1@.CAR ;
                PrintState(S1);
                Sl1 := Sl1@.CDR ;
              end ;
          end ;
      end   ¯ CFSM ò ;




    procedure LaLr ( K: integer ; LrK : boolean ) ;
        ¯************************************************ò
        ¯*                                              *ò
        ¯*  LaLr                                        *ò
        ¯*                                              *ò
        ¯*   THIS procedure ATTEMPTS to ResOLVE         *ò
        ¯* ALL Inadequate StateS, USinG A               *ò
        ¯* MAXIMUM of K Lookahead. IT SETS              *ò
        ¯* LrK to FALSE if THIS IS not PosSIBLE         *ò
        ¯* for THE GIVEN K                              *ò
        ¯*                                              *ò
        ¯*                                              *ò
        ¯*    GLOBAL       in:                          *ò
        ¯*                                              *ò
        ¯*                                              *ò
        ¯*                                              *ò
        ¯*               OUT :                          *ò
        ¯************************************************ò
    var
        Y : stateptrty ;
        I : integer;
        X,Z : statelistptr ;




        function Disjoint( X,Y :stateptrty) : boolean ;
            ¯*******************************************************ò
            ¯*                                                     *ò
            ¯*  Disjoint                                           *ò
            ¯*                                                     *ò
            ¯*     THIS function ChECKS to SEE if THE Lookahead    *ò
            ¯* String of Y IS SUFFICIENt to ResOLVE State X        *ò
            ¯* if SO IT RETURNS TRUE                               *ò
            ¯*                                                     *ò
            ¯*     in     :   X     Inadequate State               *ò
            ¯*                Y     Lookahead String State         *ò
            ¯*                                                     *ò
            ¯*     ResULT      TRUE if Disjoint else FALSE         *ò
            ¯*******************************************************ò

        var
            Check : boolean ;
            Id,Id2 : identptrty ;
            S  : stateptrty ;
            Q,R,T : tranptrty;



          begin
            ¯ Disjoint ò
            Disjoint := TRUE ;
            Check := TRUE ;
            T := Y@.FirstTran ;
            while ( T <> NIL) and Check do
              begin
                Id := Token(T@.Rule,T@.Pos);
                Q := X@.FirstTran ;
                while (Q <> NIL) and Check do
                  begin
                    Id2 := Token(Q@.Rule,Q@.Pos);
                    if Id2<> NIL then
                      begin
                        if Id2=Id then Check := FALSE;
                      end

                    else
                      begin
                        S := Q@.NextState ;
                        if (S<> NIL) and(S<>Y)
                        then
                          begin
                            R := S@.FirstTran ;
                            while (R<> NIL) and Check do
                              begin
                                if Token(R@.Rule,R@.Pos)=Id then
                                    Check := FALSE;
                                R := R@.Next ;
                              end ;
                          end ;
                      end ;
                    Q := Q@.Next ;
                  end ;
                T := T@.Next ;
              end ;
            Disjoint := Check ;
          end   ¯ Disjoint  ò  ;


        procedure Follow(A : stateptrty;B :tranptrty;C :stateptrty) ;for

        procedure  Resolve( Y : stateptrty ;  var B : boolean) ;

            ¯****************************************************ò
            ¯*                                                   *ò
            ¯*  Resolve                                          *ò
            ¯*                                                   *ò
            ¯*   THIS procedure ResolveS ANY InadeqUACIES        *ò
            ¯* IT IS CALLED for EACh Inadequate State            *ò
            ¯* if UNABLE to Resolve A State IT SETS B to FALSE   *ò
            ¯*                                                   *ò
            ¯*    in    Y   GIVEN State                          *ò
            ¯*                                                   *ò
            ¯*    OUT   B   set to FALSE if UNABLE to Resolve    *ò
            ¯*                                                   *ò
            ¯*****************************************************ò

        var
            Id : identptrty ;
            X,Z : statelistptr ;
            I   : integer ;
            T,U : tranptrty  ;
            Q,S : stateptrty ;



          begin
            ¯ Resolve ò
            if Trace then
              begin
                writeln(TTYOut,'Resolve');Break ;
              end ;
            T := Y@.FirstTran ;
            while T <> NIL do
              begin
                Id := Token( T@.Rule,T@.Pos) ;
                if Id = NIL then
                  begin
                    new(S) ;
                    with S@ do
                      begin
                        FirstTran := NIL ;
                        Back := NIL ;
                        Nic  := NIL ;
                        CurrentState := CurrentState+1 ;
                        if CurrentState > MAXSTATE then
                          begin
                            writeln(TTYOut,' Too many states.') ;
                            CurrentState := MAXSTATE ;
                          end  ;
                        State := CurrentState ;
                        Kind := LAString ;
                      end ;
                    NState [ CurrentState ] := S ;
                    CurrentVisit := 0;
                    Follow (Y,T,S) ;
                    T@.NextState := S ;
                    if CurrentVisit >0 then
                    for I := 1 to CurrentVisit do
                      begin
                        Visit[I]@.MarkE := FALSE ;
                        Visit [I] := NIL ;
                      end ;
                    CurrentVisit := 0;
                    if Debug and IFSM then
                      begin
                        writeln(TTYOut); writeln(TTYOut);
                        writeln(TTYOut,'Inadequate State ') ;
                        writeln(TTYOut);
                        PrintState(Y) ;
                        writeln(TTYOut);
                        writeln(TTYOut,'Lookahead String') ;
                        PrintState(Y) ;
                      end ;
                    if Disjoint (Y,S) then Y@.Kind := Lookahead
                    else
                      begin
                        Y@.Kind := Inadequate ; ¯ Just in case it was se
                                                ¯ otherwise previously
                        B := FALSE ;
                        Z := Conflict ;
                        new(X) ;
                        X@.CAR := S ;
                        X@.CDR := NIL ;
                        if Z=NIL then Conflict := X
                        else
                          begin
                            while Z@.CDR <> NIL do
                            Z := Z@.CDR ;
                            Z@.CDR := X ;
                          end ;
                      end ;
                  end ;
                T := T@.Next ;
              end ;
          end ¯ Resolve   ò ;




        procedure Reverse (A:stateptrty; B :tranptrty;N:integer ;
            S : stateptrty )   ;
            ¯************************************************ò
            ¯*                                               *ò
            ¯* Reverse                                       *ò
            ¯*                                               *ò
            ¯*    THIS procedure EXECUTES THE Reduction and  *ò
            ¯* MAKES THE APPrOPrIATE TranSITIOn              *ò
            ¯*                                               *ò
            ¯*   in    A   BASE State                        *ò
            ¯*         B   Reduction                         *ò
            ¯*         N   Number of BackUPS to GO           *ò
            ¯*         S   LookSHead String State            *ò
            ¯*                                               *ò
            ¯*************************************************ò

        var
            Id : identptrty ;
            A1 : stateptrty ;
            T : tranptrty ;


            function MakeTran( A:stateptrty; B :tranptrty ) : stateptrty
                ¯******************************************************ò
                ¯*                                                    *ò
                ¯* MakeTran                                           *ò
                ¯*                                                    *ò
                ¯*    THIS function MAKES THE APPrOPrIATE TranSITIOn  *ò
                ¯* for THE GIVEN Reduction B and RETURNS THE ResULTANt*ò
                ¯* State                                              *ò
                ¯*                                                    *ò
                ¯*   in     A State                                   *ò
                ¯*          B GIVEN Reduction                         *ò
                ¯*                                                    *ò
                ¯*  ResULT  IS THE DestinATIOn State                  *ò
                ¯*                                                    *ò
                ¯******************************************************ò

            label
                1;
            var
                X : tranptrty ;
                new : stateptrty ;
                Id : identptrty ;



              begin
                ¯ MakeTran ò
                new := NIL ;
                Id := B@.Rule@.XDef ;
                X := A@.FirstTran ;
                while X <> NIL do
                  begin
                    if Token(X@.Rule,X@.Pos)= Id
                    then
                      begin
                        new := X@.NextState ;
                        if new <> NIL then goto 1 ;
                      end ;
                    X := X@.Next ;
                  end ;
                1:
                MakeTran := new ;
              end ¯ MakeTran ò   ;


          begin
            ¯ Reverse  ò
            if Trace then
              begin
                writeln(TTYOut,'Reverse');Break ;
              end ;
            if N=0 then
              begin
                A1 := MakeTran(A,B) ;
                if A1 = NIL then writeln(TTYOut,'**SySTEM Error** in Rev
                else
                  begin
                    T := A1@.FirstTran ;
                    while T <> NIL do
                      begin
¯suspect code:           Id := Token(T@.Rule,T@.Pos);           ò
¯                        if Id@.Kind <> NonTerm then             ò
                        Follow(A1,T,S) ;
                        T := T@.Next ;
                      end ;
                  end
              end
            else
              begin
                T := A@.Back ;
                while T <> NIL do
                  begin
                    A1 := T@.NextState ;
                    Reverse(A1,B,N-1,S) ;
                    T := T@.Next ;
                  end ;
              end ;
          end ¯ Reverse   ò  ;


        procedure Follow ;
            ¯***************************************************ò
            ¯*                                                 *ò
            ¯* Follow                                          *ò
            ¯*                                                 *ò
            ¯* THIS IS A forward procedure                     *ò
            ¯*      THIS procedure inITIALIZES C with THE      *ò
            ¯* Terminals THAT Follow                           *ò
            ¯*                                                 *ò
            ¯*   in   : A   BASE State                         *ò
            ¯*          B    GIVEN TranSITIOn                  *ò
            ¯*          C   Lookahead String State             *ò
            ¯*                                                 *ò
            ¯***************************************************ò

        var
            Id  : identptrty ;
            X   : stateptrty ;
            P  : prodptrty ;
            Pop : integer   ;
            T   : tranptrty ;



            procedure AddLook ( S: stateptrty;Q : tranptrty);
                ¯*******************************************************
                ¯*                                                     *
                ¯*  AddLook                                            *
                ¯*                                                     *
                ¯*      THIS procedure ADDS THE GIVEN TranSITIOn       *
                ¯* to THE EXISTinG Lookahead String AS REPresENtED BY  *
                ¯*   S                                                 *
                ¯*                                                     *
                ¯*   in      S   Lookahead String State                *
                ¯*           Q   new TranSITIOn                        *
                ¯*                                                     *
                ¯*******************************************************

            var
                X : tranptrty ;

              begin
                ¯ AddLook ò
                new(X)   ;
                with X@ do
                  begin
                    Rule := Q@.Rule ;
                    Pos  := Q@.Pos  ;
                    MarkE := FALSE  ;
                    Next  := NIL  ;
                    NextState := NIL ;
                  end ;
                AddT(S,X)  ;
              end ¯ AddLook   ò  ;



          begin
            ¯ Follow ò
            if Trace then
              begin
                writeln(TTYOut,'Follow');
                Break ;
              end ;
            Id := Token(B@.Rule,B@.Pos) ;
            if not B@.MarkE then
              begin
                B@.MarkE := TRUE ;
                CurrentVisit := CurrentVisit+1 ;
                if CurrentVisit > MAXVISIT then
                writeln(TTYOut,'OVERFLOW of Visit StateS')
                else Visit[CurrentVisit] := B ;
                if Id = NIL then
                  begin
                    Pop := 0 ;
                    P := B@.Rule ;
                    P := P@.Next ;
                    while P <> NIL
                    do
                      begin
                        Pop := Pop +1 ;
                        P := P@.Next ;
                      end ;
                    if B@.NextState = NIL then Reverse(A,B,Pop,C)
                    else
                      begin
                        X := B@.NextState ;
                        T := X@.FirstTran ;
                        while T <> NIL do
                          begin
                            AddLook(C,T) ;
                            T := T@.Next ;
                          end ;
                      end ;
                  end
                else
                if Id@.Kind = Term then AddLook(C,B) ;
              end ;
          end ¯ Follow ò   ;


      begin
        ¯  LaLr  ò
        if Trace then
          begin
            writeln(TTYOut, 'LaLr') ;
            Break ;
          end ;
        Z := Inadeq ;
        X := Inadeq ;
        LrK := TRUE ;
        while X <> NIL do
          begin
            Y := X@.CAR ;
            Resolve(Y,LrK) ;
            if Y@.Kind = Lookahead
            then if X= Inadeq then Inadeq := X@.CDR
            else Z@.CDR := X@.CDR
            else Z := X ;
            X := X@.CDR ;
          end ;
        if not LrK then
          begin
            writeln(TTYOut);
            writeln(TTYOut,'The grammar is not laLR(',K:1,')');
            if IFSM then
              begin
                I := B14 ;
                Ch := ChR(I) ;
                writeln(CrefPas,Ch) ;
                writeln(CrefPas,'                      Conflict States')
                writeln(CrefPas,'                      ===============')
                writeln(CrefPas);writeln(CrefPas);writeln(CrefPas);
                X := Inadeq ;
                while X <> NIL do
                  begin
                    PrintState(X@.CAR) ;
                    X := X@.CDR ;
                  end ;
                X := Conflict ;
                while X <> NIL do
                  begin
                    PrintState(X@.CAR) ;
                    X := X@.CDR ;
                  end ;
              end ¯ IFSM< ò  ;
          end ¯ LrKò   ;

      end ;
    ¯  LaLr  ò



    procedure   Optim  ;
        ¯************************************************ò
        ¯*                                              *ò
        ¯*        Optim              ;                  *ò
        ¯*                                              *ò
        ¯*                                              *ò
        ¯*   THIS procedure OptimizeS THE State Tables  *ò
        ¯*  GENERATED ALSO. THE OptimIZATIOn IS         *ò
        ¯*  doNE USinG FinITE State TEChNIQUES in ordER *ò
        ¯*  to Reduce THE Number of StateS.             *ò
        ¯*    THE FollowinG OptimIZATIOnS ARE doNE      *ò
        ¯*    A. REMOVAL of NOn Terminal TranSITIOnS    *ò
        ¯*    B. REMOVAL of ChAin DEVIATIOnS            *ò
        ¯*                                              *ò
        ¯************************************************ò
      begin
        ¯  Optim  ò
        writeln(TTYOut, 'Optim')
      end   ;



    function FindRule(T: tranptrty) : integer ;

        ¯*****************************************************ò
        ¯*                                                   *ò
        ¯* FindRule                                          *ò
        ¯*                                                   *ò
        ¯*     THIS function RETURNS THE Rule Number of THE  *ò
        ¯* GIVEN Production                                  *ò
        ¯*                                                   *ò
        ¯*     in : T  GIVEN TranSITIOn                      *ò
        ¯*                                                   *ò
        ¯*    OUT :                                          *ò
        ¯*    ResULT   Rule NO. of Production                *ò
        ¯*****************************************************ò

    label
        1;
    var
        L :   listptrty ;

      begin
        ¯ FindRule ò
        FindRule := UNKNOWN ;
        L := T@.Rule@.XDef@.Defin ;
        if L= NIL  then writeln(TTYOut,'**SySTEM Error 2**') ;
        while L<> NIL do
          begin
            if RuleTab[L@.CAR]=T@.Rule then
              begin
                FindRule := L@.CAR ;
                goto 1
              end ;
            L := L@.CDR ;
          end ;
        1:
      end ¯ FindRule  ò  ;



    procedure   OutT     ;
        ¯************************************************ò
        ¯*                                              *ò
        ¯*     OutT                                     *ò
        ¯*                                              *ò
        ¯*   THIS procedure GENERATES THE PARSER Tables,*ò
        ¯* Production Number Tables and THE SEMANtICS   *ò
        ¯* Tables                                       *ò
        ¯************************************************ò



        procedure GenTab ;
            ¯***********************************************ò
            ¯*                                             *ò
            ¯* GenTab                                      *ò
            ¯*                                             *ò
            ¯*  THIS procedure GENERATES Tables in THE     *ò
            ¯* REQUIRed forM VIZ MERGinG symbolS and THE   *ò
            ¯* THE Action list WHEREVER PosSIBLE           *ò
            ¯*                                             *ò
            ¯***********************************************ò
        label
            1;
        var
            I,J  : integer ;
            S : stateptrty ;
            Entry : integer ;
            Done : boolean ;




            procedure EnterSeg(T,A : integer) ;

                ¯************************************************ò
                ¯*                                              *ò
                ¯* EnterSeg                                     *ò
                ¯*                                              *ò
                ¯*   THIS procedure EnterS A symbol Action PAIR *ò
                ¯* into THE Table                               *ò
                ¯************************************************ò



              begin
                ¯ EnterSeg ò
                if Index >= MAXTABSIZE then writeln(TTYOut,'Overflow of
                else Index := Index+1 ;
                Table [Index].Tran := T;
                Table [Index].Action := A ;
              end ¯ EnterSeg ò   ;



            procedure MakeSeg (S :stateptrty) ;
                ¯*************************************************ò
                ¯*                                               *ò
                ¯* MakeSeg                                       *ò
                ¯*                                               *ò
                ¯*  THIS procedure COPIES A Segment I.E. A State *ò
                ¯* and forMATS into A symbol Action PAIR         *ò
                ¯*                                               *ò
                ¯*************************************************ò
            label
                1;
            var
                Act : integer ;
                Id : identptrty ;
                First : boolean ;
                K,LastCount,CurrCount : integer ;
                P : integer ;
                Last,T : tranptrty ;






                function Count (S :stateptrty) : integer ;

                    ¯*********************************************ò
                    ¯*                                           *ò
                    ¯* Count                                     *ò
                    ¯*                                           *ò
                    ¯*   THIS function RETURNS THE Number of     *ò
                    ¯* UNIQUE TranSITIOnS of A GIVEN State       *ò
                    ¯*********************************************ò

                var
                    Temp : integer ;
                    Id : identptrty ;
                    Q,T : tranptrty ;
                  begin
                    ¯ Count ò
                    Temp := 0;
                    T := NextTran(S,NIL);
                    while T <> NIL do
                      begin
                        Id := Token(T@.Rule,T@.Pos);
                        Q := T@.Next ;
                        while Q <> NIL do
                          begin
                            if Token(Q@.Rule,Q@.Pos)=Id then Q@.MarkE :=
                            Q := Q@.Next ;
                          end ;
                        Temp := Temp +1 ;
                        T := NextTran(S,T) ;
                      end ;
                    Count := Temp ;
                  end ¯ Count ò ;



                procedure Expand ( P : tranptrty) ;
                    ¯************************************************ò
                    ¯*                                              *ò
                    ¯* Expand                                       *ò
                    ¯*                                              *ò
                    ¯*    THIS procedure EXOandS A Lookahead String *ò
                    ¯* A symbol Action list                         *ò
                    ¯************************************************ò

                var
                    S : stateptrty ;
                    PRule : integer ;
                    T,Q : tranptrty ;
                    Id : identptrty ;
                  begin
                    S := P@.NextState ;
                    T := NextTran (S,NIL) ;
                    PRule := P@.Rule@.Production ;
                    while T <> NIL do
                      begin
                        Id := Token (T@.Rule ,T@.Pos) ;
                        Q := T@.Next ;
                        while Q <> NIL do
                          begin
                            if Token(Q@.Rule,Q@.Pos)=Id then Q@.MarkE :=
                            Q := Q@.Next ;
                          end ;
                        EnterSeg(Id@.Code,-PRule-NOSCANCODE) ;
                        T := NextTran(S,T) ;
                      end ;
                  end ¯ Expand ò  ;



              begin
                ¯ MakeSeg ò
                First := TRUE ;
                Segment[0].Tran := UNKNOWN ;
                Segment[0].Action := UNKNOWN ;
                P := UNKNOWN ;

                SegIndex := -1 ;
                T :=S@.FirstTran ;
                while T <> NIL do
                  begin
                    ¯whileò
                    if T@.NextState <> NIL then
                      begin
                        ¯COPYò
                        Id := Token(T@.Rule,T@.Pos) ;
                        if Id <> NIL then K := Id@.Code else K:=UNKNOWN;
                        if T@.NextState@.Kind=LAString then
                          begin
                            ¯LAStringò
                            if First then
                              begin
                                ¯Firstò
                                First := FALSE;
                                Last := T ;
                                LastCount := Count(Last@.NextState) ;
                                goto 1 ;
                              end ¯Firstò
                            else
                              begin
                                ¯not Firstò
                                CurrCount := Count(T@.NextState);
                                if CurrCount > LastCount+THRESHOLD then
                                  begin
                                    ¯SWAPò
                                    Expand(Last) ;
                                    Last := T ;
                                    LastCount := CurrCount ;
                                  end ¯SWAPò
                                else Expand(T) ;
                                goto 1 ;
                              end ¯not Firstò
                          end ¯ LAStringò
                        else if T@.NextState@.Kind=Reduction then
                        P := -T@.Rule@.Production
                        else
                        P := T@.NextState@.State ;
                        if SegIndex >= MAXSEGMENT then
                            writeln(TTYOut,'Segment Overflow!')
                        else SegIndex := SegIndex+1;
                        Segment[SegIndex].Tran := K ;
                        Segment[SegIndex].Action := P ;
                      end ¯COPY ò ;
                    1: T := T@.Next ;
                  end ¯whileò  ;
                if S@.Kind = Lookahead then
                if First then writeln(TTYOut,'System error in MAKESEG2')
                         else Act := - Last@.Rule@.Production-NOSCANCODE

                if S@.Kind= Reads then Act := ERRORCODE;
                if (S@.Kind=Reads) or (S@.Kind=Lookahead)
                then
                  begin
                    if SegIndex>= MAXSEGMENT then
                        writeln(TTYOut,'*Segment Overflow!')
                    else SegIndex := SegIndex+1 ;
                    Segment[SegIndex].Tran := elseCode;
                    Segment[SegIndex].Action := Act ;
                  end ;
              end ¯MakeSegò  ;






            function SegMatch(Ind:integer) : integer ;
                ¯*****************************************************ò
                ¯*                                                   *ò
                ¯*  SegMatch                                         *ò
                ¯*                                                   *ò
                ¯*     THIS function RETURNS TRUE if THE Segment     *ò
                ¯* MatchES AN Entry in THE Table .if THERE IS NO     *ò
                ¯* Match IT RETURNS UNKNOWN                          *ò
                ¯*****************************************************ò
            label
                1,2;
            var
                I,K : integer ;
                Mate : integer ;



              begin
                ¯ SegMatchò
                SegMatch := UNKNOWN ;
                if Index > (SegIndex-Ind) then
                for Mate := 0 to Index-(SegIndex-Ind) do
                  begin
                    K := Mate ;
                    for I := Ind to SegIndex do
                      begin
                       if Table[K].Tran=XCONTINUE
                           then K := Table[K].Action;
                        if (Segment[I].Tran <> Table[K].Tran)
                        or (Segment[I].Action <> Table[K].Action) then g
                        K := K+1;
                      end ;
                    SegMatch := Mate ; goto 2;
                    1:
                  end ¯ for ò ;
                2:
              end  ¯ SegMatch ò  ;








          begin
            ¯ GenTab ò
            Index := -1 ;
            for I := 0 to CurrentState do
              begin
                S := NState [I ];
                if (S@.Kind <> Reduction) and (S@.Kind <> LAString) then
                  begin
                        NewState[I] := Index+1 ;
                    MakeSeg(S) ;
                    Entry := SegMatch(0);
                    if Entry <> UNKNOWN then NewState[I] := Entry
                    else
                      begin
                        EnterSeg(Segment[0].Tran,Segment[0].Action) ;
                        if SegIndex > 0 then

                        begin
                        for J := 1 to SegIndex-1 do
                          begin
                            Entry := SegMatch(J);
                            if Entry <> UNKNOWN then
                              begin
                                EnterSeg(XCONTINUE,Entry);
                                goto 1 ;
                              end
                            else EnterSeg(Segment[J].Tran,Segment[J].Act
                          end ;
                        EnterSeg(Segment[SegIndex].Tran,
                                 Segment[SegIndex].Action);
                        end ;
                        1:
                      end ;
                  end ;
              end  ¯ for ò ;
            ¯ RENumber new StateS ò
            for I := 0 to CurrentState do
            if NState[I]@.Kind <> LAString then
            NState[I] @.State := NewState[I] ;
            for I := 0 to Index do
            if (Table[I].Action >=0) and (Table[I].Action <=CurrentState
            and (Table[I].Tran <> XCONTINUE) then
            Table[I].Action := NewState[Table[I].Action ];
          end ¯ GenTab ò   ;



        procedure OutTab ;
        ¯***********************************************ò
        ¯*                                             *ò
        ¯* OutTab                                      *ò
        ¯*                                             *ò
        ¯*    THIS procedure GENERATES TabPas          *ò
        ¯* THE Tables                                  *ò
        ¯***********************************************ò

var
    I,K,T,A : integer ;
    DoSymbolic : boolean;
    X : identptrty;
    Id : word;



 begin  ¯ OutTab ò
        I := B14;
        Ch := ChR(I);
        writeln(TabPas,Ch);
        writeln(TabPas,XCONTINUE,' ',elseCode,' ',ERRORCODE,' ',NOSCANCO
        writeln(TabPas);

        writeln(TabPas,ERRORCODE);
        writeln(TabPas,MaxCode);
        writeln(TabPas,MaxPop);
        writeln(TabPas,MaxProdNo);
        writeln(TabPas,Index);
        writeln(TabPas,elseCode);
        writeln(TabPas,-1); ¯PARTITIONò
        writeln(TabPas);
        writeln(TabPas);

                ¯ GENERATE labelSò

        for K := 0 to NAMETABSIZE do
        begin
                X := NameTab[K];
                while X<> NIL do
                begin
                   if X@.Kind in  [Lab]
                        then writeln(TabPas,X@.ExternalName);
                   X := X@.Nic;
                end ;
        end ;
        writeln(TabPas,-1) ; ¯ PARTò
        writeln(TabPas);writeln(TabPas);writeln(TabPas);


                ¯ GENERATE Table arraySò

        for I := 0 to Index do
        begin
            T := Table[I].Tran ;
            A := Table[I].Action;
            write(TabPas, I, ' ');
            if (T >= 0) and (T < MaxVocSize) then begin
                DoSymbolic := Symbolic and Terminals and
                                (SymbolName[T]@.Kind = Term);
                DoSymbolic := DoSymbolic or (
                                Symbolic and NonTerminals and
                                (SymbolName[T]@.Kind = NonTerm));
                DoSymbolic := DoSymbolic or (SymbolName[T]@.Spid = Res);
            end else
                DoSymbolic := FALSE;
            if DoSymbolic then
                write(TabPas, SymbolName[T]@.ExternalName)
            else
                write(TabPas, T);
            writeln(TabPas, ' ', A);
        end ;
        writeln(TabPas,-1);
        writeln(TabPas);

                ¯ GENERATE Pop and SEMANtICSò

        DoSymbolic := Symbolic and NonTerminals;

        for I := 1 to ProdNo do
        begin

            T := PopTab[I] -1;
            A := RuleTab[I]@.XDef@.Code;
            X := RuleTab[I]@.Action;
            if X = NIL then Id := 'NULL           '
                else Id :=X@.ExternalName;
            write(TabPas,I,' ', T, ' ');
            if DoSymbolic then
                write(TabPas, RuleTab[i]@.XDef@.ExternalName)
            else
                write(TabPas, A);
            writeln(TabPas,' ',Id);
        end ;

        writeln(TabPas,-1) ; ¯ PARTò

        writeln(TabPas);
   end ¯OutTabò  ;







      begin
        ¯  OutT  ò
        writeln(TTYOut,' Generating Tables...') ;
        GenTab ;
        if FSM or tables then    ¯ always want tables ò
        PrintTab ;   ¯ even when you don't want the to see the FSM -hde
        OutTab;
      end   ;



    procedure   OutFreq          ;
        ¯************************************************ò
        ¯*                                              *ò
        ¯*    OutFreq                                   *ò
        ¯*                                              *ò
        ¯*     THIS procedure OUTPUTS ALL STATISTICS    *ò
        ¯*  ConCERNinG THE PrOGRAM, to FILNAM.CRL       *ò
        ¯*     THE FollowinG WILL BE inCLUDED           *ò
        ¯*   1. Frequency of Terminals, NOn Terminals.  *ò
        ¯************************************************ò
      begin
        ¯  OutFreq  ò
        writeln(TTYOut,'OutFreq')
      end   ;



  begin
    ¯  main  ò
    InitSp;           ¯ initialize some data ò
    InitOptions ;     ¯initialize options to defaults ò
    InitGlob;         ¯initialize global variables ò
    mark(HeapBot) ;
    open( TTYOut, 'TTY:', [ OpenOutput ] );
    InitP          ;  ¯  Initialize tables as read. ò
    if not FatalError then
        Terminal       ;  ¯  Read terminals ò
    if not FatalError then begin
        ReadG          ;  ¯  Read grammar ò
        writeln(TTYOut,' There are ', maxprodno:2,' rules.');
    end;
    if Grammar or Terminals and not FatalError then
      begin
        if Grammar then  PrintG ;
        PrintCref ;
      end ;
    if ErrorFlag or FatalError then
        writeln(TTYOut,'Error in the productions - NO tables generated.'
    else
    if Lr0 then
      begin
        ¯ Lr0 ò
        CFSM(Lr0) ;
        if (not Lr0) and Look
        then
          begin
            LrK := TRUE ;
            LaLr(MaxK,LrK) ;
          end ;
        if LrK or Lr0 then
          begin
            if Optimize then Optim ;
            if Tables or PN then OutT ;
          end ;
        if FSM then OutFSM ;
      end   ¯ Lr0 ò ;
    if Frequency then  OutFreq ;
    mark(HeapTop) ;
¯   writeln(TTYOut,'Storage used: ',HeapBot-HeapTop : 5) ;         ò
¯ the above line is commented out because pointers aren't integers
    (in PASCALVS), and also, it is not TRUE since other marks and
    releases are done in the Rest of the code
ò
    if FatalError then
        SetReturnCode(2)
    else if ErrorFlag then
        SetReturnCode(1);

  end.

