PROGRAM PROFILE(OUTPUT,QRD);

(*$D-
        M U L T I P U R P O S E   P R O F I L E    G E N E R A T O R
        -----------------------   -------------    -----------------

     AUTHOR:  R. NIGEL HORSPOOL,  MCGILL UNIVERSITY,  MONTREAL.
     DATE:    AUGUST 22, 1979.

PURPOSE: TO PRODUCE AN EXECUTION PROFILE FOR PASCAL PROGRAMS COMPILED
         AND EXECUTED VIA THE STANFORD PASCAL COMPILER.
         THIS PROGRAM IS INTENDED TO BE WHOLLY COMPATIBLE WITH THE
         "PASPROF" PROGRAM SUPPLIED WITH THE STANFORD PASCAL SYSTEM.
         HOWEVER, THIS PROGRAM REQUIRES MUCH LESS MEMORY AND IS MORE
         VERSATILE.  IT CAN GENERATE THREE DIFFERENT FORMATS FOR THE
         PROFILE.  THE FORMAT IS SELECTED ACCORDING TO WHAT INPUT IS
         PROVIDED IN THE "PRD" FILE - SEE BELOW.  FORMAT 1 IS A
         VERY CONDENSED PROFILE, SUITABLE FOR LISTING ON AN INTERACTIVE
         TERMINAL.  FORMAT 2 GIVES A SOURCE LISTING WITH EXECUTION
         FREQUENCIES PRINTED ALONGSIDE EACH LINE.  FORMAT 3 IS SIMILAR
         TO FORMAT 2 BUT IS IDENTICAL (OR NEARLY SO) TO THE FORMAT
         GENERATED BY STANFORD'S PASPROF PROGRAM.

FILES:
         QRR   - THE COUNTERS WRITTEN BY AN EXECUTING PASCAL PROGRAM
                 (WITH THE K+ OPTION IN EFFECT WHEN COMPILED).  THIS
                 CORRESPONDS TO THE DDNAME "GO.QRR" IN A PASCAL JOB.
         QRD   - SYMBOL TABLE DATA WRITTEN DURING A PASCAL COMPILATION.
                 THIS CORRESPONDS TO THE DDNAME "COMPILE.QRR".
         PRD   - THREE POSSIBILITIES ARE ALLOWED  (AND CAUSE OUTPUT
                 FORMATS 1, 2 OR 3 RESPECTIVELY).
                 1.  "PRD" IS AN EMPTY FILE  (I.E., THE DD STATEMENT
                     IN THE O.S. JCL IS CODED AS "DD DUMMY").
                 2.  "PRD" IS A FILE CONTAINING THE IDENTICAL SOURCE
                     CODE AS THE PROGRAM TO BE PROFILED.
                 3.  "PRD" IS A FILE CONTAINING THE COMPILATION OUTPUT
                     CREATED WHEN THE PROGRAM TO BE PROFILED WAS COMPILE
                     (THIS CORRESPONDS TO THE DDNAME "COMPILE.OUTPUT".)

ERROR CODES:
         101, 102, 103:  INDICATE AN INTERNAL INCONSISTENCY IN THE DATA
                 CONTAINED IN THE "QRD" FILE.  THE ERROR SHOULD BE
                 REPORTED TO THE AUTHOR.
         200:    INDICATES THAT THE "QRR" FILE IS EMPTY OR A PREMATURE
                 END OF FILE HAS OCCURRED.

(*$EJECT *)
CONST MAXLINES = 55;
      BUFLEN   = 150;         (*SIZE OF THE INPUT LINE BUFFER*)
TYPE  STMT_TYPE = ( PROC, LAB_STMT, GOTO_STMT, IF_STMT, WHILE_STMT,
                    REPEAT_STMT, FOR_STMT, CASE_STMT, THEN_CLAUSE,
                    ELSE_CLAUSE, CASE_CLAUSE );
      NODE = RECORD
                KIND: STMT_TYPE;
                CTR_NO, FIRSTLN, LASTLN: INTEGER;
                NEST, NEXT: @NODE;
             END;
      NODE_PTR = @NODE;
VAR   NODE_LIST, NEW_NODE, HEAP_MARK: NODE_PTR;
      LAST_CNT, LAST_CTR_NO, LEN, LINECNT,
           PAGENUM, LEVEL, MID_LINE, CURLINE: INTEGER;
      MODE: ( UNKNOWN, BRIEF, SOURCE, LISTING );
      FAKE: RECORD CASE BOOLEAN OF
               FALSE: ( KIND: STMT_TYPE );
               TRUE:  ( INT:  INTEGER   );  END;
      OK: BOOLEAN;
      LAB:  ARRAY(/1..4/) OF CHAR;
      PROC_NAME: ARRAY(/1..12/) OF CHAR;
      L: RECORD CASE BOOLEAN OF
            FALSE: (LINE:     ARRAY(/1..BUFLEN/) OF CHAR);
            TRUE:  (SEQUENCE: ARRAY(/1..9/)   OF CHAR;
                    REMDR:    ARRAY(/1..141/) OF CHAR);  END;

FUNCTION INNER_STMTS( START_LINE, START_CTR: INTEGER ): NODE_PTR;
   LABEL 10;
   VAR   TEMP1, TEMP2: NODE_PTR;
   BEGIN
      TEMP1 := NIL;
      IF NODE_LIST <> NIL THEN
         WHILE ( NODE_LIST@.FIRSTLN >= START_LINE ) AND
               ( NODE_LIST@.CTR_NO  >  START_CTR  ) DO
            BEGIN
               TEMP2 := NODE_LIST;  NODE_LIST := TEMP2@.NEXT;
               TEMP2@.NEXT := TEMP1;  TEMP1 := TEMP2;
               IF NODE_LIST = NIL THEN GOTO 10;
            END;
   10:INNER_STMTS := TEMP1;
   END (* INNER_STMTS *) ;

PROCEDURE BUILD_TREE( NEW_NODE: NODE_PTR );
   VAR TEMP1, TEMP2: NODE_PTR;
   BEGIN
      CASE NEW_NODE@.KIND OF

      WHILE_STMT, REPEAT_STMT, FOR_STMT, PROC:
         NEW_NODE@.NEST := INNER_STMTS( NEW_NODE@.FIRSTLN, NEW_NODE@.CTR

      IF_STMT:
         IF MID_LINE = 0 THEN  (* NO ELSE CLAUSE *)
            BEGIN
               NEW_NODE@.KIND := THEN_CLAUSE;
               NEW_NODE@.NEST := INNER_STMTS( NEW_NODE@.FIRSTLN,
                                              NEW_NODE@.CTR_NO );
            END
         ELSE BEGIN  (* NESTED THEN & ELSE CLAUSES *)
               NEW(TEMP2);
               WITH TEMP2@ DO BEGIN
                  KIND := ELSE_CLAUSE;  CTR_NO := MAXINT;
                  FIRSTLN := MID_LINE;  NEXT   := NIL;
                  LASTLN  := NEW_NODE@.LASTLN;
                  NEST := INNER_STMTS( MID_LINE, NEW_NODE@.CTR_NO );  EN
               NEW(TEMP1);
               WITH TEMP1@ DO BEGIN
                  KIND := THEN_CLAUSE;  CTR_NO := NEW_NODE@.CTR_NO;
                  FIRSTLN := NEW_NODE@.FIRSTLN;  LASTLN := MID_LINE - 1;
                  IF LASTLN < FIRSTLN THEN LASTLN := FIRSTLN;
                  NEST := INNER_STMTS( FIRSTLN, NEW_NODE@.CTR_NO );
                  NEXT := TEMP2;                                       E
               NEW_NODE@.NEST := TEMP1;
         END;

      CASE_STMT:
         IF MID_LINE = 0 THEN BEGIN  (* CASE CLAUSE *)
            NEW_NODE@.KIND := CASE_CLAUSE;
            NEW_NODE@.NEST := INNER_STMTS( NEW_NODE@.FIRSTLN,
                                           NEW_NODE@.CTR_NO );  END
         ELSE BEGIN  (* END OF ENTIRE CASE STMT *)
            TEMP1 := NIL;
            WHILE MID_LINE > 0 DO
               IF NODE_LIST <> NIL THEN
                  BEGIN
                     IF NODE_LIST@.KIND <> CASE_CLAUSE THEN EXIT(101);
                     TEMP2 := NODE_LIST;  NODE_LIST := TEMP2@.NEXT;
                     TEMP2@.NEXT := TEMP1;  TEMP1 := TEMP2;
                     MID_LINE := MID_LINE - 1;
                  END
               ELSE EXIT(102);
            NEW_NODE@.NEST := TEMP1;
            NEW_NODE@.CTR_NO := MAXINT;
         END;

      GOTO_STMT:
         NEW_NODE@.CTR_NO := MAXINT;

      LAB_STMT:
         (* NOTHING *) ;
      END  (* CASE *) ;
      NEW_NODE@.NEXT := NODE_LIST;
      NODE_LIST := NEW_NODE;
   END (* BUILD_TREE *) ;

PROCEDURE FILL_LINE;
   BEGIN
   (**LEN := 0;  REPEAT  LEN := LEN + 1;  READ(PRD, L.LINE(/LEN/) );
                 UNTIL   EOLN(PRD);  READLN(PRD);**)
       READLN(PRD, L.LINE);
       LEN := BUFLEN;
       REPEAT  LEN := LEN-1;  UNTIL (LEN = 1) OR (L.LINE(/LEN/) <> ' ');
   END  (* FILL_LINE *) ;

PROCEDURE READLINE;
   LABEL 10;
   VAR I: INTEGER;  CH: CHAR;  SEEN: BOOLEAN;

   FUNCTION HEADLINE: BOOLEAN;
      VAR  TEST: BOOLEAN;  I: INTEGER;
      BEGIN  TEST := FALSE;
         IF L.LINE(/1/) = '1' THEN  (* PAGE CONTROL CHAR? *)
            TEST := TRUE
         ELSE BEGIN  (* LOOK FOR WORD "LINE" IN HEADING *)
            I := 1;  WHILE L.LINE(/I/) = ' ' DO I := I + 1;
            TEST := (L.LINE(/I/) = 'L');
         END;
         IF TEST THEN BEGIN  (* SOME NASTY SIDE-EFFECTS *)
            IF L.LINE(/1/) <> '1' THEN BEGIN  PAGE;  WRITELN;  END;
            PAGENUM := PAGENUM + 1;
            WRITELN( L.SEQUENCE, 'RUN CNT':9, L.REMDR:LEN-9 );
            FILL_LINE;  READLN(PRD);
            WRITELN( L.SEQUENCE, '--- ---':9, L.REMDR:LEN-9 );
            WRITELN;  MODE := LISTING;  END;
         HEADLINE := TEST;
      END;
      BEGIN  (* READLINE *)
         REPEAT
            FILL_LINE;
            L.LINE(/BUFLEN/) := '#';
            IF LEN = 1 THEN
               IF EOF(PRD) THEN BEGIN MODE := BRIEF;  GOTO 10;  END;
         UNTIL NOT HEADLINE;
         IF MODE = LISTING THEN BEGIN
            CURLINE := 0;  SEEN := FALSE;
            FOR I := 1 TO 9 DO BEGIN
               CH := L.LINE(/I/);
              IF CH >= '0' THEN BEGIN  SEEN := TRUE;
                 CURLINE := CURLINE*10 - ORD('0') + ORD(CH);  END;  END;
            IF NOT SEEN THEN  (* NO LINE # FOUND *)
                CURLINE := MAXINT;  END;
 10: END;

PROCEDURE ADVANCE( STOPLINE, FREQUENCY: INTEGER );
   BEGIN
      WHILE (CURLINE <= STOPLINE) AND (MODE <> BRIEF) DO
         IF MODE = SOURCE THEN BEGIN
            IF LINECNT >= MAXLINES THEN BEGIN
               PAGE;  WRITELN;  PAGENUM := PAGENUM + 1;
               WRITELN( 'LINE #  RUN CNT':18, 'SOURCE STATEMENT':26,
                          'PAGE':24, PAGENUM:4 );
               WRITELN( '---- -  --- ---':18, '------ ---------':26,
                          '---- ---':28 );
               WRITELN;  LINECNT := 0;  END;
            LINECNT := LINECNT + 1;
            WRITE( CURLINE:9 );
            IF FREQUENCY = 0
               THEN WRITE( ' ':8 ) ELSE WRITE( FREQUENCY:8 );
            WRITELN( ' ':4, L.LINE:LEN );
            FILL_LINE;
            IF LEN = 1 THEN
               IF EOF(PRD) THEN MODE := BRIEF;
            CURLINE := CURLINE + 1;  END
          ELSE BEGIN
            WRITE( L.SEQUENCE:9 );
            IF FREQUENCY = 0 THEN
               WRITE( ' ':9 ) ELSE WRITE( FREQUENCY:9 );
            WRITELN( L.REMDR:LEN-9 );  READLINE;
          END;
   END (* ADVANCE *) ;

PROCEDURE PRINT( NODE: NODE_PTR;  CNT: INTEGER );
   CONST TAB = 2;
   BEGIN
      IF MODE = BRIEF THEN BEGIN
         IF LINECNT >= MAXLINES THEN BEGIN
            PAGE;  WRITELN;  LINECNT := 0;  PAGENUM := PAGENUM + 1;
            WRITELN( 'LINE # RANGE  RUN CNT  CONSTRUCT':35,
                      'PAGE':10, PAGENUM:4 );
            WRITELN( '---- - -----  --- ---  ---------':35, '---- ---':1
            WRITELN;  END;
         LINECNT := LINECNT + 1;
         WITH NODE@ DO BEGIN
            WRITE( FIRSTLN:7, '-':3, LASTLN:5, CNT:9,
                       ' ':(LEVEL*TAB) );
            CASE KIND OF
               PROC:         WRITELN( 'PROCEDURE: ', PROC_NAME );
               LAB_STMT:     WRITELN( 'LABELLED STMT' );
               WHILE_STMT:   WRITELN( 'WHILE STMT' );
               REPEAT_STMT:  WRITELN( 'REPEAT STMT' );
               FOR_STMT:     WRITELN( 'FOR STMT' );
               THEN_CLAUSE:  WRITELN( 'THEN CLAUSE' );
               ELSE_CLAUSE:  WRITELN( 'ELSE CLAUSE' );
               CASE_CLAUSE:  WRITELN( 'CASE CLAUSE' );
               IF_STMT, CASE_STMT:  WRITELN;
            END;  END;  END;
   END  (* PRINT *) ;

PROCEDURE WALK( NODE: NODE_PTR; DFLT_CNT: INTEGER );
   VAR  CNT: INTEGER;  ELSE_PTR: NODE_PTR;
   BEGIN
      LEVEL := LEVEL + 1;
      WHILE NODE <> NIL DO
         WITH NODE@ DO BEGIN
            ADVANCE( FIRSTLN-1, DFLT_CNT );
            IF CTR_NO < MAXINT THEN  BEGIN
               IF CTR_NO < LAST_CTR_NO THEN EXIT(103);
               WHILE CTR_NO > LAST_CTR_NO DO
                  BEGIN LAST_CTR_NO := LAST_CTR_NO + 1;
                     WHILE (QRR@=' ') AND NOT EOF(QRR) DO GET(QRR);
                     IF EOF(QRR) THEN BEGIN
                        WRITELN;  WRITELN( '****':9,
                        'ERROR - COUNTERS FILE INCONSISTANT':36 );
                        EXIT(200);  END;
                        READ( QRR, LAST_CNT );  END;
               CNT := LAST_CNT;  END
            ELSE CNT := DFLT_CNT;
            IF KIND = IF_STMT THEN BEGIN
               ELSE_PTR := NEST@.NEXT;
               NEST@.NEXT := NIL;
               WALK( NEST, DFLT_CNT );  WALK( ELSE_PTR, DFLT_CNT - CNT )
               "NEST@.NEXT := ELSE_PTR;"  END
            ELSE BEGIN
               IF (KIND <> CASE_STMT) AND
                  (KIND <> GOTO_STMT) THEN PRINT( NODE, CNT );
               IF NEST <> NIL THEN WALK( NEST, CNT );
               ADVANCE( LASTLN, CNT );
               IF (KIND = GOTO_STMT) OR (KIND = CASE_CLAUSE) THEN
                  DFLT_CNT := 0
               ELSE IF KIND = LAB_STMT THEN
                  DFLT_CNT := CNT;  END;
            NODE := NEXT;
         END (* WITH *) ;
      LEVEL := LEVEL - 1;
   END  (* WALK *) ;

BEGIN  (* PROFILE *)
   RESET(PRD);  RESET(QRR);
   MODE := UNKNOWN;  LINECNT := MAXLINES;  LAST_CTR_NO := -1;
   MARK( HEAP_MARK );  NODE_LIST := NIL;   OK := FALSE;
   PROC_NAME := '            ';            PAGENUM := 0;
   READLINE;
   IF MODE = UNKNOWN THEN BEGIN
      MODE := SOURCE;  CURLINE := 1;  END;

   WHILE NOT EOF(QRD) DO BEGIN
      READ( QRD, LAB );
      IF LAB = '#CTR' THEN BEGIN
         NEW( NEW_NODE );  OK := TRUE;
         WITH NEW_NODE@ DO BEGIN
            READLN( QRD, FAKE.INT, CTR_NO, FIRSTLN, MID_LINE, LASTLN );
            KIND := FAKE.KIND;
            NEST := NIL;  NEXT := NIL;
            BUILD_TREE( NEW_NODE );
            IF KIND = PROC THEN
               IF LASTLN > 0 THEN BEGIN
                  LEVEL := 0;
                  WALK( NEW_NODE, 0 );  RELEASE( HEAP_MARK );
                  PROC_NAME := '            ';
                  NODE_LIST := NIL;  END  END  END
       ELSE IF LAB = '#BGN' THEN BEGIN
          WHILE QRD@ = ' ' DO GET(QRD);
          READLN( QRD, PROC_NAME );  END
       ELSE READLN( QRD );  END;
   IF OK THEN
      ADVANCE( MAXINT, 0 )
   ELSE BEGIN
      WRITELN;  WRITELN( '****':9, 'ERROR - K+ OPTION NOT ENABLED':36 );
END.
