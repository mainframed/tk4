  (*$P-,F-,D-,K-,Q+,I+,M-    *)
 PROGRAM COMPRESS (INPUT,OUTPUT,QRR);
  (* THIS PROGRAM READS IN SOURCE(OR OTHER) TEXT AND COMPRESSES THE
     TEXT BY ELIMINATING DUPLICATE CHARACTERS. THERE ARE TWO SPECIAL
     CHARACTERS WHICH ARE USED TO AID THIS. SPEC1ALCHAR1 AND 2.
     IF THERE IS AN OCCURRENCE OF 3..256 IDENTICAL CHARACTERS
     THEY ARE COMPRESSED INTO THE FOLLOWING S C N, WHERE :
       S = SPECIALCHAR1
       C = THE DUPLICATED CHARACTER
       N = A 1 BYTE COUNT OF THE NUMBER OF DUPLICATED CHARACTERS

       IF SPECIALCHAR1 OR 2 IS ENCOUNTERED, THE FOLLOWING STRING
       IS OUTPUT : S C 1 WHERE :
         S = SPECIALCHAR1
         C = SPECIALCHAR1 OR SPECIALCHAR2
         1 = BYTE COUNT OF 1

       AT END OF LINE A CHECKSUM IS WRITTEN OUT. THE CHECKSUM IS OF
       THE FORM
       S N WHERE :
         S = SPECIALCHAR2
         N = THE LOW ORDER BYTE OF THE CHECKSUM
       THE CHECKSUM WILL BE IN THE RANGE OF 0 .. 255. OVERFLOW SHOULD
       NOT OCCUR IF CHECK SUM INTERVAL IS A REASONABLE VALUE, TRUNCATION
       CHECKSUM TO LESS THAN 255 SHOULD BE NO PROBLEM.

       IN ORDER THAT THE EXPAND PROGRAM CAN CALIBRATE ITSELF THE FIRST
       CHARACTERS SENT ARE SPECIALCHAR1, SPECIALCHAR2, AND TYPECODE,
       IN THAT ORDER. TYPECODE WILL BE USED TO DENOTE SOURCE CODE TYPE
       FOR (FUTURE) KEYWORD COMPACTION.

       THE DATA IN COMPRESSED FORM IS TERMINATED BY A CHECKSUM AND
       AN INTERNAL END OF FILE MARK WHICH IS S S 0 WHERE :
         S = SPECIALCHAR1
         S = SPECIALCHAR1
         0 = INDICATES A BYTE COUNT OF ZERO WHICH CAN ONLY LEGALLY
             OCCUR AT END OF FILE.

       BECAUSE OF THE AWKWARD HANDLING OF SPECIALCHAR1 AND 2
       THEY SHOULD BE RARE TO NONEXISTANT IN THE INPUT DATA SET,
       BUT THEY WILL BE HANDLED CORRECTLY IF PRESENT.

       UPDATE RECORD:

       04/27/79 : COMMENT CORRECTIONS AND SET SPECIALCHARS TO MORE
                  APPROPIATE VALUES. CH


                                             CURT HILL
                                             225 NEBRASKA HALL
                                             UNIVERSITY OF NEBRASKA - LI
                                             LINCOLN, NEBRASKA
                                             68588
                                             (402) 472-3701


       THIS PROGRAM IS COPYRIGHT 1979, CURT HILL

       PERMISSION IS HEREBY GRANTED FOR ANY NONPROFIT USE OF ALL OR
       PARTS OF THIS PROGRAM, PROVIDED THIS NOTICE IS DISPLAYED.
       FURTHERMORE DISTRIBUTION AND IMPROVEMENT IS ENCOURAGED.
       I WOULD LIKE TO HEAR ABOUT AND/OR RECIEVE COPIES OF ANY
       IMPROVEMENTS THAT ARE WORTH MAKING TO THIS PROGRAM. CONTACT
       ME AT ABOVE ADDRESS OR SEE PASCAL NEWS FOR AN ADDRESS UPDATE.

                  FREELY YOU HAVE RECIEVED, FREELY GIVE.
                                   *)


   VAR
     BUFFER : ARRAY (/0..2/) OF CHAR;
     SPECIALCHAR1, SPECIALCHAR2 : CHAR;
     INCOUNT,            (* CHARS INPUT *)
     OUTCOUNT,           (* CHARS OUTPUT *)
     CHECKSUM,
     INLINE : INTEGER;   (* INPUT LINES (ALSO OUTPUT CHECKSUMS) *)
     TYPECODE : CHAR;    (* INDICATES TYPE OF SOURCE CODE *)



   PROCEDURE WRITECHAR(C : CHAR);

     (* THIS PROCEDURE WRITES OUT ONE CHARACTER AND SUMS CHECKSUM AND
        THE COUNT OF CHARACTERS OUTPUT       *)

     BEGIN (* WRITECHAR *)
       WRITE (QRR, C);
       OUTCOUNT := OUTCOUNT + 1;
       CHECKSUM := CHECKSUM + ORD(C);
       END;    (* WRITECHAR *)



   PROCEDURE WRITECHECKSUM;

     (* THIS PROCEDURE WRITES OUT THE CHECKSUM *)

     BEGIN(* WRITECHECKSUM *)
       WRITE (QRR, SPECIALCHAR2, CHR(CHECKSUM MOD 256));
       OUTCOUNT := OUTCOUNT + 2;
       CHECKSUM := 0;
       INLINE := INLINE + 1;
       END;    (* WRITECHECKSUM *)


   FUNCTION GETCHAR (VAR C:CHAR):BOOLEAN;
     (* GET ONE CHAR, HANDLE EOLN PROPERLY AND PASS BACK WHETHER EOLN
        OR NOT SOAS TO TRIGGER CHECKSUM ACTIVITIES.   *)

     BEGIN     (* GETCHAR *)
       IF NOT EOF(INPUT) THEN
          BEGIN
          IF EOLN(INPUT)
             THEN BEGIN
                  READLN(INPUT);
                  GETCHAR := FALSE;
                  END
             ELSE BEGIN
                  READ (INPUT,C);
                  INCOUNT := INCOUNT + 1;
                  GETCHAR := TRUE;
                  END;
            END;   (*IF NOT EOF BEGIN *)
       END;           (* GETCHAR *)


   PROCEDURE FILLBUFFER (INDEX:INTEGER);
     (* FILL UP THE BUFFER FROM INDEX ON, IF GETCHAR FALSE THEN
        WRITECHECKSUM AFTER EMPTYING THE BUFFER    *)

     VAR
       I , J : INTEGER;



     BEGIN   (* FILLBUFFER *)
       I := INDEX;
       WHILE (I <= 2) AND (NOT EOF(INPUT))  DO
         BEGIN
         IF NOT GETCHAR(BUFFER(× I ×))
            THEN BEGIN        (* WRITE BUFFER AND GET NEW ONE *)
                 FOR J := 0 TO I-1  DO
                     WRITECHAR ( BUFFER (/J/) );
                 I := 0;
                 WRITECHECKSUM;
                 END
            ELSE I := I + 1;
         END;
         IF EOF(INPUT)         (* CLEAN THE BUFFER *)
            THEN FOR J := 0 TO I DO
                     WRITECHAR( BUFFER(/0/) )
            ELSE;

     END;             (* FILLBUFFER *)


   PROCEDURE SENDDUPGROUP;
     (* ACCUMULATE DUPLICATE CHARACTERS AND SEND ONE THREE CHARACTER
        DUPLICATION GROUP *)

     VAR
       NEWCHAR : CHAR;
       COUNT : INTEGER;
       DIFFERENT : BOOLEAN;
       ENDLINE : BOOLEAN;
       IND : INTEGER;

     BEGIN                    (* SENDDUPGROUP *)
       ENDLINE := FALSE;
       COUNT := 3;       (* ONLY CALLED WHEN 3 DUPLICATES ALREADY *)
       DIFFERENT := FALSE;
       WHILE ( (NOT EOF (INPUT))   AND
               (COUNT < 255)       AND
               (NOT DIFFERENT) )             DO
          BEGIN
          IF NOT GETCHAR( BUFFER(×0×) )
             THEN BEGIN
                  DIFFERENT := TRUE;
                  ENDLINE := TRUE
                  END
             ELSE BEGIN
                  DIFFERENT := NOT (BUFFER (/0/) = BUFFER (/1/));
                  END;
          COUNT := COUNT + 1;
          END;

       WRITECHAR(SPECIALCHAR1);
       WRITECHAR( BUFFER(/1/) );
       WRITECHAR( CHR(COUNT-1) );
       IF ENDLINE
          THEN BEGIN
               WRITECHECKSUM;
               IND := 0;
               END
          ELSE IND := 1;
       FILLBUFFER(IND)
       END;       (* PROCDUPE *)



   PROCEDURE PROCCHAR;

     (* THIS PROCEDURE WRITES OUT THE FIRST ELEMENT OF BUFFER, SHIFTS
        THE REST AND READS IN THE LAST ELEMENT OF BUFFER.
        IT ALSO DETECTS OCCURRENCES OF SPECIALCHAR1 AND 2 AND WRITES
        THEM OUT CORRECTLY.              *)





     BEGIN
       IF (BUFFER (/0/) = SPECIALCHAR1)   OR
          (BUFFER (/0/) = SPECIALCHAR2)
          THEN BEGIN    (* WRITE SPECIAL CHARACTERS *)
               WRITECHAR (SPECIALCHAR1);
               WRITECHAR ( BUFFER(/0/) );
               WRITECHAR ( CHR(1) );
               END
          ELSE WRITECHAR ( BUFFER(/0/) );

      BUFFER (/0/) := BUFFER (/1/);     (* SHIFT *)
      BUFFER (/1/) := BUFFER (/2/);
      FILLBUFFER(2)

      END;          (* PROCCHAR *)




   BEGIN     (* COMPRESS *)
                                   (* INITIALIZATION *)
     INCOUNT := 0;
     CHECKSUM := 0;
     OUTCOUNT := 0;
     INLINE := 0;
     TYPECODE := ' ';   (* SET TO BLANK UNTIL PROPERLY IMPLEMENTED *)
     SPECIALCHAR1 := CHR(251);  (* UNUSED IN ASCII AND EBCDIC *)
     SPECIALCHAR2 := CHR(252);   (* UNUSED IN ASCII AND EBCDIC *)
     REWRITE (QRR);
     FILLBUFFER (0);
     WRITECHAR (SPECIALCHAR1);    (* THIS ALLOWS THE EXPAND PROGRAM *)
     WRITECHAR (SPECIALCHAR2);    (* TO BE SELF CALIBRATING  *)
     WRITECHAR (TYPECODE);
     WHILE NOT EOF(INPUT)  DO
       IF (BUFFER (/0/) = BUFFER (/1/)) AND
          (BUFFER (/0/) = BUFFER (/2/))
          THEN SENDDUPGROUP
          ELSE PROCCHAR;

     IF OUTCOUNT = 0
        THEN (* BY CHANCE WE JUST SENT OUT A CHECKSUM *)
        ELSE WRITECHECKSUM;
     WRITECHAR (SPECIALCHAR1);
     WRITECHAR (SPECIALCHAR1);
     WRITECHAR ( CHR(0) );  WRITELN(QRR);
     WRITELN (OUTPUT, ' **** COMPRESS ****');
     WRITELN (OUTPUT, ' NUMBER OF CHARACTERS INPUT : ', INCOUNT:10);
     WRITELN (OUTPUT, ' NUMBER OF LINES INPUT :      ', INLINE:10);
     WRITELN (OUTPUT, ' NUMBER OF CHARACTERS OUTPUT : ', OUTCOUNT:9);
     END.

