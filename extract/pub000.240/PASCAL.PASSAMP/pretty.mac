(*====================================================================*)
(*                                                                    *)
(*  PROGRAM TITLE: PASCAL PRETTYPRINTING PROGRAM                      *)
(*                                                                    *)
(*  AUTHORS: JON F. HUERAS AND HENRY F. LEDGARD                       *)
(*           COMPUTER AND INFORMATION SCIENCE DEPARTMENT              *)
(*           UNIVERSITY OF MASSACHUSETTS, AMHERST                     *)
(*           (EARLIER VERSIONS AND CONTRIBUTIONS BY RANDY CHOW        *)
(*            AND JOHN GORMAN.)                                       *)
(*                                                                    *)
(*  PROGRAM SUMMARY:                                                  *)
(*                                                                    *)
(*     THIS PROGRAM TAKES AS INPUT A PASCAL PROGRAM AND               *)
(*     REFORMATS THE PROGRAM ACCORDING TO A STANDARD SET OF           *)
(*     PRETTYPRINTING RULES. THE PRETTYPRINTED PROGRAM IS GIVEN       *)
(*     AS OUTPUT.  THE PRETTYPRINTING RULES ARE GIVEN BELOW.          *)
(*                                                                    *)
(*     AN IMPORTANT FEATURE IS THE PROVISION FOR THE USE OF EXTRA     *)
(*     SPACES AND EXTRA BLANK LINES.  THEY MAY BE FREELY INSERTED BY  *)
(*     THE USER IN ADDITION TO THE SPACES AND BLANK LINES INSERTED    *)
(*     BY THE PRETTYPRINTER.                                          *)
(*                                                                    *)
(*     NO ATTEMPT IS MADE TO DETECT OR CORRECT SYNTACTIC ERRORS IN    *)
(*     THE USER'S PROGRAM.  HOWEVER, SYNTACTIC ERRORS MAY RESULT IN   *)
(*     ERRONEOUS PRETTYPRINTING.                                      *)
(*                                                                    *)
(*                                                                    *)
(*  INPUT FILE: INPUTFL      - A FILE OF CHARACTERS, PRESUMABLY A     *)
(*                             PASCAL PROGRAM OR PROGRAM FRAGMENT.    *)
(*                                                                    *)
(*  OUTPUT FILES: OUTPUTFL   - THE PRETTYPRINTED PROGRAM.             *)
(*                                                                    *)
(*                OUTPUT     - STANDARD PASCAL FILE FOR RUNTIME       *)
(*                             MESSAGES.                              *)
(*                                                                    *)
(*                                                                    *)
(*====================================================================*)


(*====================================================================*)
(*                                                                    *)
(*                   PASCAL PRETTYPRINTING RULES                      *)
(*                                                                    *)
(*                                                                    *)
(*  [ GENERAL PRETTYPRINTING RULES ]                                  *)
(*                                                                    *)
(*   1.   ANY SPACES OR BLANK LINES BEYOND THOSE GENERATED BY THE     *)
(*     PRETTYPRINTER ARE LEFT ALONE.  THE USER IS ENCOURAGED, FOR THE *)
(*     SAKE OF READABILITY, TO MAKE USE OF THIS FACILITY.             *)
(*        IN ADDITION, COMMENTS ARE LEFT WHERE THEY ARE FOUND, UNLESS *)
(*     THEY ARE SHIFTED RIGHT BY PRECEEDING TEXT ON A LINE.           *)
(*                                                                    *)
(*   2.   ALL STATEMENTS AND DECLARATIONS BEGIN ON SEPARATE LINES.    *)
(*                                                                    *)
(*   3.   NO LINE MAY BE GREATER THAN 72 CHARACTERS LONG.  ANY LINE   *)
(*     LONGER THAN THIS IS CONTINUED ON A SEPARATE LINE.              *)
(*                                                                    *)
(*   4.   THE KEYWORDS "BEGIN", "END", "REPEAT", AND "RECORD" ARE     *)
(*     FORCED TO STAND ON LINES BY THEMSELVES (OR POSSIBLY FOLLWED BY *)
(*     SUPPORTING COMMENTS).                                          *)
(*        IN  ADDITION, THE "UNTIL" CLAUSE OF A "REPEAT-UNTIL" STATE- *)
(*     MENT IS FORCED TO START ON A NEW LINE.                         *)
(*                                                                    *)
(*   5.   A BLANK LINE IS FORCED BEFORE THE KEYWORDS "PROGRAM",       *)
(*     "PROCEDURE", "FUNCTION", "LABEL", "CONST", "TYPE", AND "VAR".  *)
(*                                                                    *)
(*   6.   A SPACE IS FORCED BEFORE AND AFTER THE SYMBOLS ":=" AND     *)
(*     "=".  ADDITIONALLY, A SPACE IS FORCED AFTER THE SYMBOL ":".    *)
(*                                                                    *)
(*                                                                    *)
(*  [ INDENTATION RULES ]                                             *)
(*                                                                    *)
(*   1.   THE BODIES OF "LABEL", "CONST", "TYPE", AND "VAR" DECLARA-  *)
(*     TIONS ARE INDENTED FROM THEIR CORRESPONDING DECLARATION HEADER *)
(*     KEYWORDS.                                                      *)
(*                                                                    *)
(*   2.   THE BODIES OF "BEGIN-END", "REPEAT-UNTIL", "FOR", "WHILE",  *)
(*     "WITH", AND "CASE" STATEMENTS, AS WELL AS "RECORD-END" STRUC-  *)
(*     TURES AND "CASE" VARIANTS (TO ONE LEVEL) ARE INDENTED FROM     *)
(*     THEIR HEADER KEYWORDS.                                         *)
(*                                                                    *)
(*   3.   AN "IF-THEN-ELSE" STATEMENT IS INDENTED AS FOLLOWS:         *)
(*                                                                    *)
(*             IF <EXPRESSION>                                        *)
(*                THEN                                                *)
(*                   <STATEMENT>                                      *)
(*                ELSE                                                *)
(*                   <STATEMENT>                                      *)
(*                                                                    *)
(*                                                                    *)
(*====================================================================*)


(*====================================================================*)
(*                                                                    *)
(*                      GENERAL ALGORITHM                             *)
(*                                                                    *)
(*                                                                    *)
(*      THE STRATEGY OF THE PRETTYPRINTER IS TO SCAN SYMBOLS FROM     *)
(*   THE INPUT PROGRAM AND MAP EACH SYMBOL INTO A PRETTYPRINTING      *)
(*   ACTION, INDEPENDENTLY OF THE CONTEXT IN WHICH THE SYMBOL         *)
(*   APPEARS.  THIS IS ACCOMPLISHED BY A TABLE OF PRETTYPRINTING      *)
(*   OPTIONS.                                                         *)
(*                                                                    *)
(*      FOR EACH DISTINGUISHED SYMBOL IN THE TABLE, THERE IS AN       *)
(*   ASSOCIATED SET OF OPTIONS.  IF THE OPTION HAS BEEN SELECTED FOR  *)
(*   THE SYMBOL BEING SCANNED, THEN THE ACTION CORRESPONDING WITH     *)
(*   EACH OPTION IS PERFORMED.                                        *)
(*                                                                    *)
(*      THE BASIC ACTIONS INVOLVED IN PRETTYPRINTING ARE THE INDENT-  *)
(*   ATION AND DE-INDENTATION OF THE MARGIN.  EACH TIME THE MARGIN IS *)
(*   INDENTED, THE PREVIOUS VALUE OF THE MARGIN IS PUSHED ONTO A      *)
(*   STACK, ALONG WITH THE NAME OF THE SYMBOL THAT CAUSED IT TO BE    *)
(*   INDENTED.  EACH TIME THE MARGIN IS DE-INDENTED, THE STACK IS     *)
(*   POPPED OFF TO OBTAIN THE PREVIOUS VALUE OF THE MARGIN.           *)
(*                                                                    *)
(*      THE PRETTYPRINTING OPTIONS ARE PROCESSED IN THE FOLLOWING     *)
(*   ORDER, AND INVOKE THE FOLLOWING ACTIONS:                         *)
(*                                                                    *)
(*                                                                    *)
(*     CRSUPPRESS      - IF A CARRIAGE RETURN HAS BEEN INSERTED       *)
(*                       FOLLOWING THE PREVIOUS SYMBOL, THEN IT IS    *)
(*                       INHIBITED UNTIL THE NEXT SYMBOL IS PRINTED.  *)
(*                                                                    *)
(*     CRBEFORE        - A CARRIAGE RETURN IS INSERTED BEFORE THE     *)
(*                       CURRENT SYMBOL (UNLESS ONE IS ALREADY THERE) *)
(*                                                                    *)
(*     BLANKLINEBEFORE - A BLANK LINE IS INSERTED BEFORE THE CURRENT  *)
(*                       SYMBOL (UNLESS ALREADY THERE).               *)
(*                                                                    *)
(*     DINDENTONKEYS   - IF ANY OF THE SPECIFIED KEYS ARE ON TOP OF   *)
(*                       OF THE STACK, THE STACK IS POPPED, DE-INDEN- *)
(*                       TING THE MARGIN.  THE PROCESS IS REPEATED    *)
(*                       UNTIL THE TOP OF THE STACK IS NOT ONE OF THE *)
(*                       SPECIFIED KEYS.                              *)
(*                                                                    *)
(*     DINDENT         - THE STACK IS UNCONDITIONALLY POPPED AND THE  *)
(*                       MARGIN IS DE-INDENTED.                       *)
(*                                                                    *)
(*     SPACEBEFORE     - A SPACE IS INSERTED BEFORE THE SYMBOL BEING  *)
(*                       SCANNED (UNLESS ALREADY THERE).              *)
(*                                                                    *)
(*     [ THE SYMBOL IS PRINTED AT THIS POINT ]                        *)
(*                                                                    *)
(*     SPACEAFTER      - A SPACE IS INSERTED AFTER THE SYMBOL BEING   *)
(*                       SCANNED (UNLESS ALREADY THERE).              *)
(*                                                                    *)
(*     GOBBLESYMBOLS   - SYMBOLS ARE CONTINUOUSLY SCANNED AND PRINTED *)
(*                       WITHOUT ANY PROCESSING UNTIL ONE OF THE      *)
(*                       SPECIFIED SYMBOLS IS SEEN (BUT NOT GOBBLED). *)
(*                                                                    *)
(*     INDENTBYTAB     - THE MARGIN IS INDENTED BY A STANDARD AMOUNT  *)
(*                       FROM THE PREVIOUS MARGIN.                    *)
(*                                                                    *)
(*     INDENTTOCLP     - THE MARGIN IS INDENTED TO THE CURRENT LINE   *)
(*                       POSITION.                                    *)
(*                                                                    *)
(*     CRAFTER         - A CARRIAGE RETURN IS INSERTED FOLLOWING THE  *)
(*                       SYMBOL SCANNED.                              *)
(*                                                                    *)
(*                                                                    *)
(*                                                                    *)
(*====================================================================*)


PROGRAM PRETTYPRINT """ ( (* FROM *)  INPUTFL  ,
                     (* TO *)    OUTPUTFL  ,
                     (* USING *) OUTPUT ) """ ;


CONST

      MAXSYMBOLSIZE = 200; (* THE MAXIMUM SIZE (IN CHARACTERS) OF A   *)
                           (* SYMBOL SCANNED BY THE LEXICAL SCANNER.  *)

      MAXSTACKSIZE  = 100; (* THE MAXIMUM NUMBER OF SYMBOLS CAUSING   *)
                           (* INDENTATION THAT MAY BE STACKED.        *)

      MAXKEYLENGTH  =  10; (* THE MAXIMUM LENGTH (IN CHARACTERS) OF A *)
                           (* PASCAL RESERVED KEYWORD.                *)
      MAXLINESIZE   =  72; (* THE MAXIMUM SIZE (IN CHARACTERS) OF A   *)
                           (* LINE OUTPUT BY THE PRETTYPRINTER.       *)

      SLOWFAIL1     =  30; (* UP TO THIS COLUMN POSITION, EACH TIME   *)
                           (* "INDENTBYTAB" IS INVOKED, THE MARGIN    *)
                           (* WILL BE INDENTED BY "INDENT1".          *)

      SLOWFAIL2     =  48; (* UP TO THIS COLUMN POSITION, EACH TIME   *)
                           (* "INDENTBYTAB" IS INVOKED, THE MARGIN    *)
                           (* WILL BE INDENTED BY "INDENT2".  BEYOND  *)
                           (* THIS, NO INDENTATION OCCURS.            *)

      INDENT1       =   3;

      INDENT2       =   1;


      SPACE = ' ';


TYPE

     KEYSYMBOL = ( PROGSYM,    FUNCSYM,     PROCSYM,
                   LABELSYM,   CONSTSYM,    TYPESYM,   VARSYM,
                   BEGINSYM,   REPEATSYM,   RECORDSYM,
                   CASESYM,    CASEVARSYM,  OFSYM,
                   FORSYM,     WHILESYM,    WITHSYM,   DOSYM,
                   IFSYM,      THENSYM,     ELSESYM,
                   ENDSYM,     UNTILSYM,
                   BECOMES,    OPENCOMMENT, CLOSECOMMENT,
                   SEMICOLON,  COLON,       EQUALS,
                   OPENPAREN,  CLOSEPAREN,  PERIOD,
                   ENDOFFILE,
                   OTHERSYM );

     OPTION = ( CRSUPPRESS,
                CRBEFORE,
                BLANKLINEBEFORE,
                DINDENTONKEYS,
                DINDENT,
                SPACEBEFORE,
                SPACEAFTER,
                GOBBLESYMBOLS,
                INDENTBYTAB,
                INDENTTOCLP,
                CRAFTER );

     OPTIONSET = SET OF OPTION;

     KEYSYMSET = SET OF KEYSYMBOL;

     TABLEENTRY = RECORD
                     OPTIONSSELECTED  : OPTIONSET;
                     DINDENTSYMBOLS   : KEYSYMSET;
                     GOBBLETERMINATORS: KEYSYMSET
                  END;

     OPTIONTABLE = ARRAY [ KEYSYMBOL ] OF TABLEENTRY;


     KEY = PACKED ARRAY [ 1..MAXKEYLENGTH ] OF CHAR;


     KEYWORDTABLE = ARRAY [ PROGSYM..UNTILSYM ] OF KEY;


     SPECIALCHAR = PACKED ARRAY [ 1..2 ] OF CHAR;

     DBLCHRSET = SET OF BECOMES..OPENCOMMENT;

     DBLCHARTABLE = ARRAY [ BECOMES..OPENCOMMENT ] OF SPECIALCHAR;

     SGLCHARTABLE = ARRAY [ SEMICOLON..PERIOD ] OF CHAR;


     STRING = ARRAY [ 1..MAXSYMBOLSIZE ] OF CHAR;

     SYMBOL = RECORD
                 NAME        : KEYSYMBOL;
                 VALUE       : STRING;
                 LENGTH      : INTEGER;
                 SPACESBEFORE: INTEGER;
                 CRSBEFORE   : INTEGER
              END;

     SYMBOLINFO = @SYMBOL;


     CHARNAME = ( LETTER,    DIGIT,    BLANK,    QUOTE,
                  ENDOFLINE, FILEMARK, OTHERCHAR       );

     CHARINFO = RECORD
                   NAME : CHARNAME;
                   VALUE: CHAR
                END;


     STACKENTRY = RECORD
                     INDENTSYMBOL: KEYSYMBOL;
                     PREVMARGIN  : INTEGER
                  END;

     SYMBOLSTACK = ARRAY [ 1..MAXSTACKSIZE ] OF STACKENTRY;


VAR

    INPUTFL  ,
    OUTPUTFL  : TEXT;

    RECORDSEEN: BOOLEAN;

    CURRCHAR,
    NEXTCHAR: CHARINFO;

    CURRSYM,
    NEXTSYM: SYMBOLINFO;

    CRPENDING: BOOLEAN;

    PPOPTION: OPTIONTABLE;

    KEYWORD: KEYWORDTABLE;

    DBLCHARS: DBLCHRSET;

    DBLCHAR: DBLCHARTABLE;
    SGLCHAR: SGLCHARTABLE;

    STACK: SYMBOLSTACK;
    TOP  : INTEGER;

    CURRLINEPOS,
    CURRMARGIN :  INTEGER;


PROCEDURE GETCHAR( (* FROM *)      VAR INPUTFL   : TEXT;
                   (* UPDATING *)  VAR NEXTCHAR  : CHARINFO;
                   (* RETURNING *) VAR CURRCHAR  : CHARINFO );

   FUNCTION ATOZ(C: CHAR): BOOLEAN;

     BEGIN
     ATOZ := (('A' <= C) AND (C <= 'Z')) OR
             (('a' <= C) AND (C <= 'i')) OR
             (('j' <= C) AND (C <= 'r')) OR
             (('s' <= C) AND (C <= 'z')) ;
     END ;


BEGIN (* GETCHAR *)

   CURRCHAR := NEXTCHAR;

   WITH NEXTCHAR DO
      BEGIN

         IF EOF(INPUTFL)
            THEN
               NAME  := FILEMARK

    ELSE IF EOLN(INPUTFL)
            THEN
               NAME  := ENDOFLINE

    ELSE IF ATOZ(INPUTFL@) """INPUTFL@ IN ['A'..'Z']"""
            THEN
               NAME  := LETTER

    """ELSE  IF NPUTFL@ IN ['0'..'9']"""
    ELSE IF (INPUTFL@ >= '0')AND(INPUTFL@ <= '9')
            THEN
               NAME  := DIGIT

    ELSE IF INPUTFL  @ = ''''
            THEN
               NAME  := QUOTE

    ELSE IF INPUTFL  @ = SPACE
            THEN
               NAME  := BLANK

    ELSE NAME := OTHERCHAR;


         IF NAME IN [ FILEMARK, ENDOFLINE ]
            THEN
               VALUE := SPACE
            ELSE
               VALUE := INPUTFL  @;

         IF NAME <> FILEMARK
            THEN
               GET(INPUTFL  )

      END (* WITH *)

END; (* GETCHAR *)


PROCEDURE STORENEXTCHAR( (* FROM *)        VAR INPUTFL   : TEXT;
                         (* UPDATING *)    VAR LENGTH    : INTEGER;
                                           VAR CURRCHAR,
                                               NEXTCHAR  : CHARINFO;
                         (* PLACING IN *)  VAR VALUE     : STRING   );

BEGIN (* STORENEXTCHAR *)

   GETCHAR( (* FROM *)      INPUTFL  ,
            (* UPDATING *)  NEXTCHAR,
            (* RETURNING *) CURRCHAR  );

   IF LENGTH < MAXSYMBOLSIZE
      THEN
         BEGIN

            LENGTH := LENGTH + 1;

            VALUE [LENGTH] := CURRCHAR.VALUE

         END

END; (* STORENEXTCHAR *)


PROCEDURE SKIPSPACES( (* IN *)        VAR INPUTFL      : TEXT;
                      (* UPDATING *)  VAR CURRCHAR,
                                          NEXTCHAR     : CHARINFO;
                      (* RETURNING *) VAR SPACESBEFORE,
                                          CRSBEFORE    : INTEGER  );

BEGIN (* SKIPSPACES *)

   SPACESBEFORE := 0;
   CRSBEFORE    := 0;

   WHILE NEXTCHAR.NAME IN [ BLANK, ENDOFLINE ] DO
      BEGIN

         GETCHAR( (* FROM *)      INPUTFL  ,
                  (* UPDATING *)  NEXTCHAR,
                  (* RETURNING *) CURRCHAR  );

         CASE CURRCHAR.NAME OF

            BLANK     : SPACESBEFORE := SPACESBEFORE + 1;

            ENDOFLINE : BEGIN
                           CRSBEFORE    := CRSBEFORE + 1;
                           SPACESBEFORE := 0
                        END

         END (* CASE *)

      END (* WHILE *)

END; (* SKIPSPACES *)


PROCEDURE GETCOMMENT( (* FROM *)     VAR INPUTFL   : TEXT;
                      (* UPDATING *) VAR CURRCHAR,
                                         NEXTCHAR  : CHARINFO;
                                     VAR NAME      : KEYSYMBOL;
                                     VAR VALUE     : STRING;
                                     VAR LENGTH    : INTEGER   );

BEGIN (* GETCOMMENT *)

   NAME := OPENCOMMENT;

   WHILE NOT(    ((CURRCHAR.VALUE = '*') AND (NEXTCHAR.VALUE = ')'))
              OR (NEXTCHAR.NAME = ENDOFLINE)
              OR (NEXTCHAR.NAME = FILEMARK)) DO

      STORENEXTCHAR( (* FROM *)     INPUTFL  ,
                     (* UPDATING *) LENGTH,
                                    CURRCHAR,
                                    NEXTCHAR,
                     (* IN *)       VALUE     );


   IF (CURRCHAR.VALUE = '*') AND (NEXTCHAR.VALUE = ')')
      THEN
         BEGIN

            STORENEXTCHAR( (* FROM *)     INPUTFL  ,
                           (* UPDATING *) LENGTH,
                                          CURRCHAR,
                                          NEXTCHAR,
                           (* IN *)       VALUE     );

            NAME := CLOSECOMMENT

         END

END; (* GETCOMMENT *)


FUNCTION IDTYPE( (* OF *)        VALUE  : STRING;
                 (* USING *)     LENGTH : INTEGER )
                 (* RETURNING *)                   : KEYSYMBOL;

VAR
    I: INTEGER;

    KEYVALUE: KEY;

    HIT: BOOLEAN;

    THISKEY: KEYSYMBOL;


BEGIN (* IDTYPE *)

   IDTYPE := OTHERSYM;

   IF LENGTH <= MAXKEYLENGTH
      THEN
         BEGIN

            FOR I := 1 TO LENGTH DO
               KEYVALUE [I] := VALUE [I];

            FOR I := LENGTH+1 TO MAXKEYLENGTH DO
               KEYVALUE [I] := SPACE;

            THISKEY := PROGSYM;
            HIT     := FALSE;

            WHILE NOT(HIT OR (PRED(THISKEY) = UNTILSYM)) DO
               IF KEYVALUE = KEYWORD [THISKEY]
                  THEN
                     HIT := TRUE
                  ELSE
                     THISKEY := SUCC(THISKEY);

            IF HIT
               THEN
                  IDTYPE := THISKEY

         END;

END; (* IDTYPE *)


PROCEDURE GETIDENTIFIER( (* FROM *)      VAR INPUTFL   : TEXT;
                         (* UPDATING *)  VAR CURRCHAR,
                                             NEXTCHAR  : CHARINFO;
                         (* RETURNING *) VAR NAME      : KEYSYMBOL;
                                         VAR VALUE     : STRING;
                                         VAR LENGTH    : INTEGER   );

BEGIN (* GETIDENTIFIER *)

   WHILE NEXTCHAR.NAME IN [ LETTER, DIGIT ] DO

      STORENEXTCHAR( (* FROM *)     INPUTFL  ,
                     (* UPDATING *) LENGTH,
                                    CURRCHAR,
                                    NEXTCHAR,
                     (* IN *)       VALUE     );


   NAME := IDTYPE( (* OF *)    VALUE,
                   (* USING *) LENGTH );

   IF NAME IN [ RECORDSYM, CASESYM, ENDSYM ]
      THEN
         CASE NAME OF

            RECORDSYM : RECORDSEEN := TRUE;

            CASESYM   : IF RECORDSEEN
                           THEN
                              NAME := CASEVARSYM;

            ENDSYM    : RECORDSEEN := FALSE

         END (* CASE *)

END; (* GETIDENTIFIER *)


PROCEDURE GETNUMBER( (* FROM *)      VAR INPUTFL   : TEXT;
                     (* UPDATING *)  VAR CURRCHAR,
                                         NEXTCHAR  : CHARINFO;
                     (* RETURNING *) VAR NAME      : KEYSYMBOL;
                                     VAR VALUE     : STRING;
                                     VAR LENGTH    : INTEGER   );

BEGIN (* GETNUMBER *)

   WHILE NEXTCHAR.NAME = DIGIT DO

      STORENEXTCHAR( (* FROM *)     INPUTFL  ,
                     (* UPDATING *) LENGTH,
                                    CURRCHAR,
                                    NEXTCHAR,
                     (* IN *)       VALUE     );


   NAME := OTHERSYM

END; (* GETNUMBER *)


PROCEDURE GETCHARLITERAL( (* FROM *)      VAR INPUTFL   : TEXT;
                          (* UPDATING *)  VAR CURRCHAR,
                                              NEXTCHAR  : CHARINFO;
                          (* RETURNING *) VAR NAME      : KEYSYMBOL;
                                          VAR VALUE     : STRING;
                                          VAR LENGTH    : INTEGER   );

BEGIN (* GETCHARLITERAL *)

   WHILE NEXTCHAR.NAME = QUOTE DO
      BEGIN

         STORENEXTCHAR( (* FROM *)     INPUTFL  ,
                        (* UPDATING *) LENGTH,
                                       CURRCHAR,
                                       NEXTCHAR,
                        (* IN *)       VALUE     );

         WHILE NOT(NEXTCHAR.NAME IN [ QUOTE, ENDOFLINE, FILEMARK ]) DO

            STORENEXTCHAR( (* FROM *)     INPUTFL  ,
                           (* UPDATING *) LENGTH,
                                          CURRCHAR,
                                          NEXTCHAR,
                           (* IN *)       VALUE     );


         IF NEXTCHAR.NAME = QUOTE
            THEN
               STORENEXTCHAR( (* FROM *)     INPUTFL  ,
                              (* UPDATING *) LENGTH,
                                             CURRCHAR,
                                             NEXTCHAR,
                              (* IN *)       VALUE     )

      END;


   NAME := OTHERSYM

END; (* GETCHARLITERAL *)


FUNCTION CHARTYPE( (* OF *)        CURRCHAR,
                                   NEXTCHAR : CHARINFO )
                   (* RETURNING *)                      : KEYSYMBOL;

VAR
    NEXTTWOCHARS: SPECIALCHAR;

    HIT: BOOLEAN;

    THISCHAR: KEYSYMBOL;


BEGIN (* CHARTYPE *)

   NEXTTWOCHARS[1] := CURRCHAR.VALUE;
   NEXTTWOCHARS[2] := NEXTCHAR.VALUE;

   THISCHAR := BECOMES;
   HIT      := FALSE;

   WHILE NOT(HIT OR (THISCHAR = CLOSECOMMENT)) DO
      IF NEXTTWOCHARS = DBLCHAR [THISCHAR]
         THEN
            HIT := TRUE
         ELSE
            THISCHAR := SUCC(THISCHAR);

   IF NOT HIT
      THEN
         BEGIN

            THISCHAR := SEMICOLON;

            WHILE NOT(HIT OR (PRED(THISCHAR) = PERIOD)) DO
               IF CURRCHAR.VALUE = SGLCHAR [THISCHAR]
                  THEN
                     HIT := TRUE
                  ELSE
                     THISCHAR := SUCC(THISCHAR)

         END;

   IF HIT
      THEN
         CHARTYPE := THISCHAR
      ELSE
         CHARTYPE := OTHERSYM

END; (* CHARTYPE *)


PROCEDURE GETSPECIALCHAR( (* FROM *)      VAR INPUTFL   : TEXT;
                          (* UPDATING *)  VAR CURRCHAR,
                                              NEXTCHAR  : CHARINFO;
                          (* RETURNING *) VAR NAME      : KEYSYMBOL;
                                          VAR VALUE     : STRING;
                                          VAR LENGTH    : INTEGER   );

BEGIN (* GETSPECIALCHAR *)

   STORENEXTCHAR( (* FROM *)     INPUTFL  ,
                  (* UPDATING *) LENGTH,
                                 CURRCHAR,
                                 NEXTCHAR,
                  (* IN *)       VALUE     );

   NAME := CHARTYPE( (* OF *) CURRCHAR,
                              NEXTCHAR );

   IF NAME IN DBLCHARS
      THEN

         STORENEXTCHAR( (* FROM *)     INPUTFL  ,
                        (* UPDATING *) LENGTH,
                                       CURRCHAR,
                                       NEXTCHAR,
                        (* IN *)       VALUE     )

END; (* GETSPECIALCHAR *)


PROCEDURE GETNEXTSYMBOL( (* FROM *)      VAR INPUTFL   : TEXT;
                         (* UPDATING *)  VAR CURRCHAR,
                                             NEXTCHAR  : CHARINFO;
                         (* RETURNING *) VAR NAME      : KEYSYMBOL;
                                         VAR VALUE     : STRING;
                                         VAR LENGTH    : INTEGER   );

BEGIN (* GETNEXTSYMBOL *)

   CASE NEXTCHAR.NAME OF

      LETTER      : GETIDENTIFIER( (* FROM *)      INPUTFL  ,
                                   (* UPDATING *)  CURRCHAR,
                                                   NEXTCHAR,
                                   (* RETURNING *) NAME,
                                                   VALUE,
                                                   LENGTH    );

      DIGIT       : GETNUMBER( (* FROM *)      INPUTFL  ,
                               (* UPDATING *)  CURRCHAR,
                                               NEXTCHAR,
                               (* RETURNING *) NAME,
                                               VALUE,
                                               LENGTH    );

      QUOTE       : GETCHARLITERAL( (* FROM *)      INPUTFL  ,
                                    (* UPDATING *)  CURRCHAR,
                                                    NEXTCHAR,
                                    (* RETURNING *) NAME,
                                                    VALUE,
                                                    LENGTH    );

      OTHERCHAR   : BEGIN

                       GETSPECIALCHAR( (* FROM *)      INPUTFL  ,
                                       (* UPDATING *)  CURRCHAR,
                                                       NEXTCHAR,
                                       (* RETURNING *) NAME,
                                                       VALUE,
                                                       LENGTH    );

                       IF NAME = OPENCOMMENT
                          THEN
                             GETCOMMENT( (* FROM *)     INPUTFL  ,
                                         (* UPDATING *) CURRCHAR,
                                                        NEXTCHAR,
                                                        NAME,
                                                        VALUE,
                                                        LENGTH    )

                    END;

      FILEMARK    : NAME := ENDOFFILE

   END (* CASE *)

END; (* GETNEXTSYMBOL *)


PROCEDURE GETSYMBOL( (* FROM *)      VAR INPUTFL   : TEXT;
                     (* UPDATING *)  VAR NEXTSYM   : SYMBOLINFO;
                     (* RETURNING *) VAR CURRSYM   : SYMBOLINFO );

VAR
    DUMMY: SYMBOLINFO;


BEGIN (* GETSYMBOL *)

   DUMMY   := CURRSYM;
   CURRSYM := NEXTSYM;
   NEXTSYM := DUMMY  ;

   WITH NEXTSYM@ DO
      BEGIN

         SKIPSPACES( (* IN *)        INPUTFL  ,
                     (* UPDATING *)  CURRCHAR,
                                     NEXTCHAR,
                     (* RETURNING *) SPACESBEFORE,
                                     CRSBEFORE     );
         LENGTH := 0;

         IF CURRSYM@.NAME = OPENCOMMENT
            THEN
               GETCOMMENT( (* FROM *)      INPUTFL  ,
                           (* UPDATING *)  CURRCHAR,
                                           NEXTCHAR,
                           (* RETURNING *) NAME,
                                           VALUE,
                                           LENGTH    )
            ELSE
               GETNEXTSYMBOL( (* FROM *)      INPUTFL  ,
                              (* UPDATING *)  CURRCHAR,
                                              NEXTCHAR,
                              (* RETURNING *) NAME,
                                              VALUE,
                                              LENGTH    )

      END (* WITH *)

END; (* GETSYMBOL *)


PROCEDURE INITIALIZE( (* RETURNING *)

                          VAR INPUTFL  ,
                              OUTPUTFL    : TEXT;

                          VAR TOPOFSTACK  : INTEGER;

                          VAR CURRLINEPOS,
                              CURRMARGIN  : INTEGER;

                          VAR KEYWORD     : KEYWORDTABLE;

                          VAR DBLCHARS    : DBLCHRSET;

                          VAR DBLCHAR     : DBLCHARTABLE;

                          VAR SGLCHAR     : SGLCHARTABLE;

                          VAR RECORDSEEN  : BOOLEAN;

                          VAR CURRCHAR,
                              NEXTCHAR    : CHARINFO;

                          VAR CURRSYM,
                              NEXTSYM     : SYMBOLINFO;

                          VAR PPOPTION    : OPTIONTABLE   );


BEGIN (* INITIALIZE *)

   RESET(INPUTFL  );
   REWRITE(OUTPUTFL  );
   WRITELN(OUTPUTFL  , ' <<<< PRETTY_PRINT OUTPUT OF THE PROGRAM >>>>');
   WRITELN(OUTPUTFL  , ' --------------------------------------------');
   WRITELN(OUTPUTFL  );
   WRITE(OUTPUTFL  , ' ');

   TOPOFSTACK  := 0;
   CURRLINEPOS := 0;
   CURRMARGIN  := 0;


   KEYWORD [ PROGSYM    ] := 'PROGRAM   ' ;
   KEYWORD [ FUNCSYM    ] := 'FUNCTION  ' ;
   KEYWORD [ PROCSYM    ] := 'PROCEDURE ' ;
   KEYWORD [ LABELSYM   ] := 'LABEL     ' ;
   KEYWORD [ CONSTSYM   ] := 'CONST     ' ;
   KEYWORD [ TYPESYM    ] := 'TYPE      ' ;
   KEYWORD [ VARSYM     ] := 'VAR       ' ;
   KEYWORD [ BEGINSYM   ] := 'BEGIN     ' ;
   KEYWORD [ REPEATSYM  ] := 'REPEAT    ' ;
   KEYWORD [ RECORDSYM  ] := 'RECORD    ' ;
   KEYWORD [ CASESYM    ] := 'CASE      ' ;
   KEYWORD [ CASEVARSYM ] := 'CASE      ' ;
   KEYWORD [ OFSYM      ] := 'OF        ' ;
   KEYWORD [ FORSYM     ] := 'FOR       ' ;
   KEYWORD [ WHILESYM   ] := 'WHILE     ' ;
   KEYWORD [ WITHSYM    ] := 'WITH      ' ;
   KEYWORD [ DOSYM      ] := 'DO        ' ;
   KEYWORD [ IFSYM      ] := 'IF        ' ;
   KEYWORD [ THENSYM    ] := 'THEN      ' ;
   KEYWORD [ ELSESYM    ] := 'ELSE      ' ;
   KEYWORD [ ENDSYM     ] := 'END       ' ;
   KEYWORD [ UNTILSYM   ] := 'UNTIL     ' ;


   DBLCHARS := [ BECOMES, OPENCOMMENT ];

   DBLCHAR [ BECOMES     ]  := ':=' ;
   DBLCHAR [ OPENCOMMENT ]  := '(*' ;

   SGLCHAR [ SEMICOLON  ]   := ';' ;
   SGLCHAR [ COLON      ]   := ':' ;
   SGLCHAR [ EQUALS     ]   := '=' ;
   SGLCHAR [ OPENPAREN  ]   := '(' ;
   SGLCHAR [ CLOSEPAREN ]   := ')' ;
   SGLCHAR [ PERIOD     ]   := '.' ;

   RECORDSEEN := FALSE;


   GETCHAR( (* FROM *)      INPUTFL  ,
            (* UPDATING *)  NEXTCHAR,
            (* RETURNING *) CURRCHAR  );

   NEW(CURRSYM);
   NEW(NEXTSYM);

   GETSYMBOL( (* FROM *)      INPUTFL  ,
              (* UPDATING *)  NEXTSYM,
              (* RETURNING *) CURRSYM  );


   WITH PPOPTION [ PROGSYM ] DO
      BEGIN
         OPTIONSSELECTED   := [ BLANKLINEBEFORE,
                                SPACEAFTER ];
         DINDENTSYMBOLS    := [];
         GOBBLETERMINATORS := []
      END;

   WITH PPOPTION [ FUNCSYM ] DO
      BEGIN
         OPTIONSSELECTED   := [ BLANKLINEBEFORE,
                                DINDENTONKEYS,
                                SPACEAFTER ];
         DINDENTSYMBOLS    := [ LABELSYM,
                                CONSTSYM,
                                TYPESYM,
                                VARSYM ];
         GOBBLETERMINATORS := []
      END;

   WITH PPOPTION [ PROCSYM ] DO
      BEGIN
         OPTIONSSELECTED   := [ BLANKLINEBEFORE,
                                DINDENTONKEYS,
                                SPACEAFTER ];
         DINDENTSYMBOLS    := [ LABELSYM,
                                CONSTSYM,
                                TYPESYM,
                                VARSYM ];
         GOBBLETERMINATORS := []
      END;

   WITH PPOPTION [ LABELSYM ] DO
      BEGIN
          OPTIONSSELECTED   := [ BLANKLINEBEFORE,
                                SPACEAFTER,
                                INDENTTOCLP ];
         DINDENTSYMBOLS    := [];
         GOBBLETERMINATORS := []
      END;

   WITH PPOPTION [ CONSTSYM ] DO
      BEGIN
          OPTIONSSELECTED   := [ BLANKLINEBEFORE,
                                DINDENTONKEYS,
                                SPACEAFTER,
                                INDENTTOCLP ];
         DINDENTSYMBOLS    := [ LABELSYM ];
         GOBBLETERMINATORS := []
      END;

   WITH PPOPTION [ TYPESYM ] DO
      BEGIN
          OPTIONSSELECTED   := [ BLANKLINEBEFORE,
                                DINDENTONKEYS,
                                SPACEAFTER,
                                INDENTTOCLP ];
         DINDENTSYMBOLS    := [ LABELSYM,
                                CONSTSYM ];
         GOBBLETERMINATORS := []
      END;

   WITH PPOPTION [ VARSYM ] DO
      BEGIN
          OPTIONSSELECTED   := [ BLANKLINEBEFORE,
                                DINDENTONKEYS,
                                SPACEAFTER,
                                INDENTTOCLP ];
         DINDENTSYMBOLS    := [ LABELSYM,
                                CONSTSYM,
                                TYPESYM ];
         GOBBLETERMINATORS := []
      END;

   WITH PPOPTION [ BEGINSYM ] DO
      BEGIN
         OPTIONSSELECTED   := [ DINDENTONKEYS,
                                INDENTBYTAB,
                                CRAFTER ];
         DINDENTSYMBOLS    := [ LABELSYM,
                                CONSTSYM,
                                TYPESYM,
                                VARSYM ];
         GOBBLETERMINATORS := []
      END;

   WITH PPOPTION [ REPEATSYM ] DO
      BEGIN
         OPTIONSSELECTED   := [ INDENTBYTAB,
                                CRAFTER ];
         DINDENTSYMBOLS    := [];
         GOBBLETERMINATORS := []
      END;

   WITH PPOPTION [ RECORDSYM ] DO
      BEGIN
         OPTIONSSELECTED   := [ INDENTBYTAB,
                                CRAFTER ];
         DINDENTSYMBOLS    := [];
         GOBBLETERMINATORS := []
      END;

   WITH PPOPTION [ CASESYM ] DO
      BEGIN
         OPTIONSSELECTED   := [ SPACEAFTER,
                                INDENTBYTAB,
                                GOBBLESYMBOLS,
                                CRAFTER ];
         DINDENTSYMBOLS    := [];
         GOBBLETERMINATORS := [ OFSYM ]
      END;

   WITH PPOPTION [ CASEVARSYM ] DO
      BEGIN
         OPTIONSSELECTED   := [ SPACEAFTER,
                                INDENTBYTAB,
                                GOBBLESYMBOLS,
                                CRAFTER ];
         DINDENTSYMBOLS    := [];
         GOBBLETERMINATORS := [ OFSYM ]
      END;

   WITH PPOPTION [ OFSYM ] DO
      BEGIN
         OPTIONSSELECTED   := [ CRSUPPRESS,
                                SPACEBEFORE ];
         DINDENTSYMBOLS    := [];
         GOBBLETERMINATORS := []
      END;

   WITH PPOPTION [ FORSYM ] DO
      BEGIN
         OPTIONSSELECTED   := [ SPACEAFTER,
                                INDENTBYTAB,
                                GOBBLESYMBOLS,
                                CRAFTER ];
         DINDENTSYMBOLS    := [];
         GOBBLETERMINATORS := [ DOSYM ]
      END;

   WITH PPOPTION [ WHILESYM ] DO
      BEGIN
         OPTIONSSELECTED   := [ SPACEAFTER,
                                INDENTBYTAB,
                                GOBBLESYMBOLS,
                                CRAFTER ];
         DINDENTSYMBOLS    := [];
         GOBBLETERMINATORS := [ DOSYM ]
      END;

   WITH PPOPTION [ WITHSYM ] DO
      BEGIN
         OPTIONSSELECTED   := [ SPACEAFTER,
                                INDENTBYTAB,
                                GOBBLESYMBOLS,
                                CRAFTER ];
         DINDENTSYMBOLS    := [];
         GOBBLETERMINATORS := [ DOSYM ]
      END;

   WITH PPOPTION [ DOSYM ] DO
      BEGIN
         OPTIONSSELECTED   := [ CRSUPPRESS,
                                SPACEBEFORE ];
         DINDENTSYMBOLS    := [];
         GOBBLETERMINATORS := []
      END;

   WITH PPOPTION [ IFSYM ] DO
      BEGIN
         OPTIONSSELECTED   := [ SPACEAFTER,
                                INDENTBYTAB,
                                GOBBLESYMBOLS,
                                CRAFTER ];
         DINDENTSYMBOLS    := [];
         GOBBLETERMINATORS := [ THENSYM ]
      END;

   WITH PPOPTION [ THENSYM ] DO
      BEGIN
         OPTIONSSELECTED   := [ INDENTBYTAB,
                                CRAFTER ];
         DINDENTSYMBOLS    := [];
         GOBBLETERMINATORS := []
      END;

   WITH PPOPTION [ ELSESYM ] DO
      BEGIN
         OPTIONSSELECTED   := [ CRBEFORE,
                                DINDENTONKEYS,
                                DINDENT,
                                INDENTBYTAB,
                                CRAFTER ];
         DINDENTSYMBOLS    := [ IFSYM,
                                ELSESYM ];
         GOBBLETERMINATORS := []
      END;

   WITH PPOPTION [ ENDSYM ] DO
      BEGIN
         OPTIONSSELECTED   := [ CRBEFORE,
                                DINDENTONKEYS,
                                DINDENT,
                                CRAFTER ];
         DINDENTSYMBOLS    := [ IFSYM,
                                THENSYM,
                                ELSESYM,
                                FORSYM,
                                WHILESYM,
                                WITHSYM,
                                CASEVARSYM,
                                COLON,
                                EQUALS ];
         GOBBLETERMINATORS := []
      END;

   WITH PPOPTION [ UNTILSYM ] DO
      BEGIN
         OPTIONSSELECTED   := [ CRBEFORE,
                                DINDENTONKEYS,
                                DINDENT,
                                SPACEAFTER,
                                GOBBLESYMBOLS,
                                CRAFTER ];
         DINDENTSYMBOLS    := [ IFSYM,
                                THENSYM,
                                ELSESYM,
                                FORSYM,
                                WHILESYM,
                                WITHSYM,
                                COLON,
                                EQUALS ];
         GOBBLETERMINATORS := [ ENDSYM,
                                UNTILSYM,
                                ELSESYM,
                                SEMICOLON ];
      END;

   WITH PPOPTION [ BECOMES ] DO
      BEGIN
         OPTIONSSELECTED   := [ SPACEBEFORE,
                                SPACEAFTER,
                                GOBBLESYMBOLS ];
         DINDENTSYMBOLS    := [];
         GOBBLETERMINATORS := [ ENDSYM,
                                UNTILSYM,
                                ELSESYM,
                                SEMICOLON ]
      END;

   WITH PPOPTION [ OPENCOMMENT ] DO
      BEGIN
         OPTIONSSELECTED   := [ CRSUPPRESS ];
         DINDENTSYMBOLS    := [];
         GOBBLETERMINATORS := []
      END;

   WITH PPOPTION [ CLOSECOMMENT ] DO
      BEGIN
         OPTIONSSELECTED   := [ CRSUPPRESS ];
         DINDENTSYMBOLS    := [];
         GOBBLETERMINATORS := []
      END;

   WITH PPOPTION [ SEMICOLON ] DO
      BEGIN
         OPTIONSSELECTED   := [ CRSUPPRESS,
                                DINDENTONKEYS,
                                CRAFTER ];
         DINDENTSYMBOLS    := [ IFSYM,
                                THENSYM,
                                ELSESYM,
                                FORSYM,
                                WHILESYM,
                                WITHSYM,
                                COLON,
                                EQUALS ];
         GOBBLETERMINATORS := []
      END;

   WITH PPOPTION [ COLON ] DO
      BEGIN
         OPTIONSSELECTED   := [ SPACEAFTER,
                                INDENTTOCLP ];
         DINDENTSYMBOLS    := [];
         GOBBLETERMINATORS := []
      END;

   WITH PPOPTION [ EQUALS ] DO
      BEGIN
         OPTIONSSELECTED   := [ SPACEBEFORE,
                                SPACEAFTER,
                                INDENTTOCLP ];
         DINDENTSYMBOLS    := [];
         GOBBLETERMINATORS := []
      END;

   WITH PPOPTION [ OPENPAREN ] DO
      BEGIN
         OPTIONSSELECTED   := [ GOBBLESYMBOLS ];
         DINDENTSYMBOLS    := [];
         GOBBLETERMINATORS := [ CLOSEPAREN ]
      END;

   WITH PPOPTION [ CLOSEPAREN ] DO
      BEGIN
         OPTIONSSELECTED   := [];
         DINDENTSYMBOLS    := [];
         GOBBLETERMINATORS := []
      END;

   WITH PPOPTION [ PERIOD ] DO
      BEGIN
         OPTIONSSELECTED   := [ CRSUPPRESS ];
         DINDENTSYMBOLS    := [];
         GOBBLETERMINATORS := []
      END;

   WITH PPOPTION [ ENDOFFILE ] DO
      BEGIN
         OPTIONSSELECTED   := [];
         DINDENTSYMBOLS    := [];
         GOBBLETERMINATORS := []
      END;

   WITH PPOPTION [ OTHERSYM ] DO
      BEGIN
         OPTIONSSELECTED   := [];
         DINDENTSYMBOLS    := [];
         GOBBLETERMINATORS := []
      END


END; (* INITIALIZE *)


FUNCTION STACKEMPTY (* RETURNING *) : BOOLEAN;

BEGIN (* STACKEMPTY *)

   IF TOP = 0
      THEN
         STACKEMPTY := TRUE
      ELSE
         STACKEMPTY := FALSE

END; (* STACKEMPTY *)


FUNCTION STACKFULL (* RETURNING *) : BOOLEAN;

BEGIN (* STACKFULL *)

   IF TOP = MAXSTACKSIZE
      THEN
         STACKFULL := TRUE
      ELSE
         STACKFULL := FALSE

END; (* STACKFULL *)


PROCEDURE POPSTACK( (* RETURNING *) VAR INDENTSYMBOL : KEYSYMBOL;
                                    VAR PREVMARGIN   : INTEGER   );

BEGIN (* POPSTACK *)

   IF NOT STACKEMPTY
      THEN
         BEGIN

            INDENTSYMBOL := STACK[TOP].INDENTSYMBOL;
            PREVMARGIN   := STACK[TOP].PREVMARGIN;

            TOP := TOP - 1

         END

      ELSE
         BEGIN
            INDENTSYMBOL := OTHERSYM;
            PREVMARGIN   := 0
         END

END; (* POPSTACK *)


PROCEDURE PUSHSTACK( (* USING *) INDENTSYMBOL : KEYSYMBOL;
                                 PREVMARGIN   : INTEGER   );

BEGIN (* PUSHSTACK *)

   TOP := TOP + 1;

   STACK[TOP].INDENTSYMBOL := INDENTSYMBOL;
   STACK[TOP].PREVMARGIN   := PREVMARGIN

END; (* PUSHSTACK *)


PROCEDURE WRITECRS( (* USING *)          NUMBEROFCRS : INTEGER;
                    (* UPDATING *)   VAR CURRLINEPOS : INTEGER;
                    (* WRITING TO *) VAR OUTPUTFL    : TEXT    );

VAR
    I: INTEGER;


BEGIN (* WRITECRS *)

   IF NUMBEROFCRS > 0
      THEN
         BEGIN

            FOR I := 1 TO NUMBEROFCRS DO
               WRITELN(OUTPUTFL  );

            WRITE(OUTPUTFL, ' ');
            CURRLINEPOS := 0

         END

END; (* WRITECRS *)


PROCEDURE INSERTCR( (* UPDATING *)   VAR CURRSYM    : SYMBOLINFO;
                    (* WRITING TO *) VAR OUTPUTFL   : TEXT       );

CONST
      ONCE = 1;


BEGIN (* INSERTCR *)

   IF CURRSYM@.CRSBEFORE = 0
      THEN
         BEGIN

            WRITECRS( ONCE, (* UPDATING *)   CURRLINEPOS,
                            (* WRITING TO *) OUTPUTFL    );

            CURRSYM@.SPACESBEFORE := 0

         END

END; (* INSERTCR *)


PROCEDURE INSERTBLANKLINE( (* UPDATING *)   VAR CURRSYM : SYMBOLINFO;
                           (* WRITING TO *) VAR OUTPUTFL   : TEXT  );

CONST
      ONCE  = 1;
      TWICE = 2;


BEGIN (* INSERTBLANKLINE *)

   IF CURRSYM@.CRSBEFORE = 0
      THEN
         BEGIN

            IF CURRLINEPOS = 0
               THEN
                  WRITECRS( ONCE, (* UPDATING *)   CURRLINEPOS,
                                  (* WRITING TO *) OUTPUTFL    )
               ELSE
                  WRITECRS( TWICE, (* UPDATING *)   CURRLINEPOS,
                                   (* WRITING TO *) OUTPUTFL    );

            CURRSYM@.SPACESBEFORE := 0

         END

      ELSE
         IF CURRSYM@.CRSBEFORE = 1
            THEN
               IF CURRLINEPOS > 0
                  THEN
                     WRITECRS( ONCE, (* UPDATING *)   CURRLINEPOS,
                                     (* WRITING TO *) OUTPUTFL    )

END; (* INSERTBLANKLINE *)


PROCEDURE LSHIFTON( (* USING *) DINDENTSYMBOLS : KEYSYMSET );

VAR
    INDENTSYMBOL: KEYSYMBOL;
    PREVMARGIN  : INTEGER;


BEGIN (* LSHIFTON *)

   IF NOT STACKEMPTY
      THEN
         BEGIN

            REPEAT

               POPSTACK( (* RETURNING *) INDENTSYMBOL,
                                         PREVMARGIN   );

               IF INDENTSYMBOL IN DINDENTSYMBOLS
                  THEN
                     CURRMARGIN := PREVMARGIN

            UNTIL NOT(INDENTSYMBOL IN DINDENTSYMBOLS)
                   OR (STACKEMPTY);

            IF NOT(INDENTSYMBOL IN DINDENTSYMBOLS)
               THEN
                  PUSHSTACK( (* USING *) INDENTSYMBOL,
                                         PREVMARGIN   )

         END

END; (* LSHIFTON *)


PROCEDURE LSHIFT;

VAR
    INDENTSYMBOL: KEYSYMBOL;
    PREVMARGIN  : INTEGER;


BEGIN (* LSHIFT *)

   IF NOT STACKEMPTY
      THEN
         BEGIN
            POPSTACK( (* RETURNING *) INDENTSYMBOL,
                                      PREVMARGIN   );
            CURRMARGIN := PREVMARGIN
         END

END; (* LSHIFT *)


PROCEDURE INSERTSPACE( (* USING *)      VAR SYMBOL     : SYMBOLINFO;
                       (* WRITING TO *) VAR OUTPUTFL   : TEXT       );

BEGIN (* INSERTSPACE *)

   IF CURRLINEPOS < MAXLINESIZE
      THEN
         BEGIN

            WRITE(OUTPUTFL  , SPACE);

            CURRLINEPOS := CURRLINEPOS + 1;

            WITH SYMBOL@ DO
               IF (CRSBEFORE = 0) AND (SPACESBEFORE > 0)
                  THEN
                     SPACESBEFORE := SPACESBEFORE - 1

         END

END; (* INSERTSPACE *)


PROCEDURE MOVELINEPOS( (* TO *)       NEWLINEPOS  : INTEGER;
                       (* FROM *) VAR CURRLINEPOS : INTEGER;
                       (* IN *)   VAR OUTPUTFL    : TEXT    );

VAR
   I: INTEGER;


BEGIN (* MOVELINEPOS *)

   FOR I := CURRLINEPOS+1 TO NEWLINEPOS DO
      WRITE(OUTPUTFL  , SPACE);

   CURRLINEPOS := NEWLINEPOS

END; (* MOVELINEPOS *)


PROCEDURE PRINTSYMBOL( (* IN *)             CURRSYM     : SYMBOLINFO;
                       (* UPDATING *)   VAR CURRLINEPOS : INTEGER;
                       (* WRITING TO *) VAR OUTPUTFL    : TEXT       );

VAR
   I: INTEGER;


BEGIN (* PRINTSYMBOL *)

   WITH CURRSYM@ DO
      BEGIN

         FOR I := 1 TO LENGTH DO
            WRITE(OUTPUTFL  , VALUE[I]);

         CURRLINEPOS := CURRLINEPOS + LENGTH

      END (* WITH *)

END; (* PRINTSYMBOL *)


PROCEDURE PPSYMBOL( (* IN *)             CURRSYM    : SYMBOLINFO;
                    (* WRITING TO *) VAR OUTPUTFL   : TEXT       );

CONST
      ONCE  = 1;

VAR
    NEWLINEPOS: INTEGER;


BEGIN (* PPSYMBOL *)

   WITH CURRSYM@ DO
      BEGIN

         WRITECRS( (* USING *)      CRSBEFORE,
                   (* UPDATING *)   CURRLINEPOS,
                   (* WRITING TO *) OUTPUTFL    );

         IF (CURRLINEPOS + SPACESBEFORE > CURRMARGIN)
            OR (NAME IN [ OPENCOMMENT, CLOSECOMMENT ])
            THEN
               NEWLINEPOS := CURRLINEPOS + SPACESBEFORE
            ELSE
               NEWLINEPOS := CURRMARGIN;

         IF NEWLINEPOS + LENGTH > MAXLINESIZE
            THEN
               BEGIN

                  WRITECRS( ONCE, (* UPDATING *)   CURRLINEPOS,
                                  (* WRITING TO *) OUTPUTFL    );

                  IF CURRMARGIN + LENGTH <= MAXLINESIZE
                     THEN
                        NEWLINEPOS := CURRMARGIN
                     ELSE
                        IF LENGTH < MAXLINESIZE
                           THEN
                              NEWLINEPOS := MAXLINESIZE - LENGTH
                           ELSE
                              NEWLINEPOS := 0

               END;

         MOVELINEPOS( (* TO *)    NEWLINEPOS,
                      (* FROM *)  CURRLINEPOS,
                      (* IN *)    OUTPUTFL    );

         PRINTSYMBOL( (* IN *)         CURRSYM,
                      (* UPDATING *)   CURRLINEPOS,
                      (* WRITING TO *) OUTPUTFL    )

      END (* WITH *)

END; (* PPSYMBOL *)


PROCEDURE RSHIFTTOCLP( (* USING *) CURRSYM : KEYSYMBOL );
   FORWARD;

PROCEDURE GOBBLE( (* SYMBOLS FROM *) VAR INPUTFL     : TEXT;
                  (* UP TO *)            TERMINATORS : KEYSYMSET;
                  (* UPDATING *)     VAR CURRSYM,
                                         NEXTSYM     : SYMBOLINFO;
                  (* WRITING TO *)   VAR OUTPUTFL    : TEXT       );

BEGIN (* GOBBLE *)

   RSHIFTTOCLP( (* USING *) CURRSYM@.NAME );

   WHILE NOT(NEXTSYM@.NAME IN (TERMINATORS + [ENDOFFILE])) DO
      BEGIN

         GETSYMBOL( (* FROM *)      INPUTFL  ,
                    (* UPDATING *)  NEXTSYM,
                    (* RETURNING *) CURRSYM   );

         PPSYMBOL( (* IN *)         CURRSYM,
                   (* WRITING TO *) OUTPUTFL   )

      END; (* WHILE *)

   LSHIFT

END; (* GOBBLE *)


PROCEDURE RSHIFT( (* USING *) CURRSYM : KEYSYMBOL );

BEGIN (* RSHIFT *)

   IF NOT STACKFULL
      THEN
         PUSHSTACK( (* USING *) CURRSYM,
                                CURRMARGIN);

   IF CURRMARGIN < SLOWFAIL1
      THEN
         CURRMARGIN := CURRMARGIN + INDENT1
      ELSE
         IF CURRMARGIN < SLOWFAIL2
            THEN
               CURRMARGIN := CURRMARGIN + INDENT2

END; (* RSHIFT *)


PROCEDURE RSHIFTTOCLP;

BEGIN (* RSHIFTTOCLP *)

   IF NOT STACKFULL
      THEN
         PUSHSTACK( (* USING *) CURRSYM,
                                CURRMARGIN);

   CURRMARGIN := CURRLINEPOS

END; (* RSHIFTTOCLP *)


BEGIN (* PRETTYPRINT *)

   INITIALIZE( INPUTFL  ,  OUTPUTFL  , TOP,         CURRLINEPOS,
               CURRMARGIN, KEYWORD,    DBLCHARS,    DBLCHAR,
               SGLCHAR,    RECORDSEEN, CURRCHAR,    NEXTCHAR,
               CURRSYM,    NEXTSYM,    PPOPTION );

   CRPENDING := FALSE;

   WHILE (NEXTSYM@.NAME <> ENDOFFILE) DO
      BEGIN

         GETSYMBOL( (* FROM *)      INPUTFL  ,
                    (* UPDATING *)  NEXTSYM,
                    (* RETURNING *) CURRSYM   );

         WITH PPOPTION [CURRSYM@.NAME] DO
            BEGIN

               IF (CRPENDING AND NOT(CRSUPPRESS IN OPTIONSSELECTED))
                 OR (CRBEFORE IN OPTIONSSELECTED)
                  THEN
                     BEGIN
                        INSERTCR( (* USING *)      CURRSYM,
                                  (* WRITING TO *) OUTPUTFL   );
                        CRPENDING := FALSE
                     END;

               IF BLANKLINEBEFORE IN OPTIONSSELECTED
                  THEN
                     BEGIN
                        INSERTBLANKLINE( (* USING *)      CURRSYM,
                                         (* WRITING TO *) OUTPUTFL   );
                        CRPENDING := FALSE
                     END;

               IF DINDENTONKEYS IN OPTIONSSELECTED
                  THEN
                     LSHIFTON(DINDENTSYMBOLS);

               IF DINDENT IN OPTIONSSELECTED
                  THEN
                     LSHIFT;

               IF SPACEBEFORE IN OPTIONSSELECTED
                  THEN
                     INSERTSPACE( (* USING *)      CURRSYM,
                                  (* WRITING TO *) OUTPUTFL   );

               PPSYMBOL( (* IN *)         CURRSYM,
                         (* WRITING TO *) OUTPUTFL   );

               IF SPACEAFTER IN OPTIONSSELECTED
                  THEN
                     INSERTSPACE( (* USING *)      NEXTSYM,
                                  (* WRITING TO *) OUTPUTFL   );

               IF INDENTBYTAB IN OPTIONSSELECTED
                  THEN
                     RSHIFT( (* USING *) CURRSYM@.NAME );

               IF INDENTTOCLP IN OPTIONSSELECTED
                  THEN
                     RSHIFTTOCLP( (* USING *) CURRSYM@.NAME );

               IF GOBBLESYMBOLS IN OPTIONSSELECTED
                  THEN
                     GOBBLE( (* SYMBOLS FROM *) INPUTFL  ,
                             (* UP TO *)        GOBBLETERMINATORS,
                             (* UPDATING *)     CURRSYM,
                                                NEXTSYM,
                             (* WRITING TO *)   OUTPUTFL          );

               IF CRAFTER IN OPTIONSSELECTED
                  THEN
                     CRPENDING := TRUE

            END (* WITH *)

      END; (* WHILE *)

   IF CRPENDING
      THEN
         BEGIN  WRITELN(OUTPUTFL  );  WRITE(OUTPUTFL, ' ');  END;

END. (*PRETTYPRINT*)
PROGRAM PASCREF(INPUT,OUTPUT);      (*$D- N.WIRTH  2.7.75*)
(*CROSS REFERENCE GENERATOR FOR PASCAL PROGRAMS*)
(*QUADRATIC QUOTIENT HASH METHOD*)
(*MODIFIED SLIGHTLY BY A. MICKEL 75/12/08 AND D. LALIBERTE
  78/03/15 TO PRODUCE PROCEDURE LIST AND SKIP COMPILER TITLE*)
(*$T-,P-,R-,B4 TESTS OFF, PMD OFF, DYNAMIC STORAGE, BIG BUFFERS.*)
LABEL 99;
CONST P = 1499;     (*SIZE OF HASH TABLE*)
  NK = 33;          (*NO. OF KEYWORDS*)
  KLN = 10;         (*KEYLENGTH*)
  LPPG = 62;        (*NO. OF LINES PER PAGE*)
  LLMAX = 132;      (*LINE LENGTH DEFAULT MAX*)
  LLMIN = 72;       (*LINE LENGTH MINIMUM*)
  MAXN = 10000;     (*MAX NO. OF LINES*)
  DGPN =  6;        (*NO. OF DIGITS PER NUMBER*)
  LITL = 3;         (*NUMBER OF LINES IN COMPILER TITLE*)
  ADDRWIDTH = 6;    (*NUMBER OF DIGITS IN CODE ADDRESS*)
  EMPTY = '          ';
  STARS = ' *****';
TYPE INDEX = 0..P;
  ALFA = PACKED ARRAY [1..KLN] OF CHAR;
  REF = @ITEM;
  WORD = RECORD KEY: ALFA;
           FIRST: REF;
         END ;
  ITEM = PACKED RECORD
           LNO: 0..MAXN;
           NEXT: REF
         END ;
  PROCREF = @PROC;  (*PROCEDURE OR FUNCTION REFERENCE*)
  PROC = PACKED RECORD
           NAME: ALFA;
           LNO: 0..MAXN;
           NEXT: PROCREF
         END ;
VAR I: INDEX;
  K: INTEGER;
  M: INTEGER;       (*NO. OF LINES ON PAGE*)
  N: INTEGER;       (*NO. OF LINES INPUT*)
  LN: INTEGER;      (*CURRENT LINE NUMBER*)
  LLNGOUT: INTEGER; (*LINE LENGTH FOR OUTPUT*)
  LLNGIN: INTEGER;  (*LINE LENGTH FOR INPUT*)
  CCOUNT: INTEGER;  (*CHARACTER COUNT IN LINE*)
  NOPL: INTEGER;    (*NO. OF LINE-NUMBERS PER LINE*)
  ID: RECORD CASE BOOLEAN OF
             FALSE: (A: ALFA);
             TRUE:  (ORD: INTEGER)
      END ;
  T: ARRAY [INDEX] OF WORD;    (*HASH TABLE*)
  KEY: ARRAY [1..NK] OF ALFA;
  PROCORFUNC,
  COMPILERLISTING,
  LINENUMBERS: BOOLEAN;
  FIRSTPROC,
  PROCPTR: PROCREF; (*POINTERS TO CHAIN OF PROCEDURES*)


   FUNCTION LETTER(C: CHAR): BOOLEAN;

     BEGIN
     LETTER := (('A' <= C) AND (C <= 'Z')) OR (('a' <= C) AND (C <= 'z')
     END ;

   FUNCTION DIGIT(C: CHAR): BOOLEAN ;

     BEGIN
     DIGIT := ('0' <= C) AND (C <= '9') ;
     END ;

   FUNCTION SPECIAL(C: CHAR): BOOLEAN;
     BEGIN  SPECIAL := (C = '$') OR (C = '_')  END ;

FUNCTION NOKEY: BOOLEAN;
   VAR I,J,K: INTEGER;
BEGIN I := 1; J := NK;   (*BINARY SEARCH*)
  REPEAT K := (I+J) DIV 2;
    IF KEY[K] <= ID.A THEN I := K+1 ELSE J := K-1
  UNTIL I > J;
  IF J = 0 THEN NOKEY := TRUE ELSE
    NOKEY := KEY[J] <> ID.A
END (*NOKEY*) ;

PROCEDURE COUNTLINE;
BEGIN
  IF M = LPPG THEN
    BEGIN PAGE(OUTPUT); WRITELN(OUTPUT); WRITELN(OUTPUT);
      M := 0
    END;
  M := M + 1
END (*COUNTLINE*) ;

PROCEDURE ADVANCE;
BEGIN
  WRITE(OUTPUT,INPUT@); GET(INPUT);
  CCOUNT := CCOUNT + 1;
  IF CCOUNT = LLNGIN THEN
    WHILE NOT EOLN(INPUT) DO
      BEGIN WRITE(OUTPUT,INPUT@); GET(INPUT);
      END
END (*ADVANCE*);

PROCEDURE SPACE(J: INTEGER);
BEGIN
  REPEAT J := J-1; WRITELN(OUTPUT); COUNTLINE
  UNTIL J = 0
END (*SPACE*) ;

PROCEDURE NEWLINE;
BEGIN CCOUNT := 0;
  IF N < MAXN THEN
  BEGIN COUNTLINE;  N := N + 1;
    IF COMPILERLISTING THEN
      BEGIN IF NOT EOLN THEN
        BEGIN ADVANCE;
"""     IF NOT (INPUT@ IN ['0'..'9']) THEN  (* ERRORS *)  """
        IF NOT DIGIT(INPUT@) THEN  (* ERRORS *)
          WHILE NOT EOLN DO
            ADVANCE
        ELSE BEGIN
          FOR I := 1 TO ADDRWIDTH + 1  DO
            ADVANCE;
          WHILE (INPUT@ = ' ') AND NOT EOLN DO
            ADVANCE
          END
        END
      END
    ELSE WRITE(OUTPUT,' ');
    IF LINENUMBERS THEN
      BEGIN LN := 0;
      WHILE DIGIT(INPUT@) DO
"""   WHILE INPUT@ IN ['0'..'9'] DO   """
        BEGIN LN := 10*LN + ORD(INPUT@) - ORD('0');
          ADVANCE
        END
      END
    ELSE BEGIN
      LN := N;  WRITE(OUTPUT,LN:6, ' ')
      END
    END
  ELSE BEGIN
    WRITELN(STARS, ' TEXT TOO LONG', STARS);
    "GOTO 99"  EXIT(99);
    END
END (*NEWLINE*) ;

PROCEDURE SEARCH;   (*MODULO P HASH SEARCH*)
  VAR H,D: INDEX;
      X: REF; F: BOOLEAN;
      K: INTEGER;
BEGIN  I := ABS(ID.ORD);  H := I MOD P;
  F := FALSE; D := 1;
  NEW(X); X@.LNO := LN;
  REPEAT
    IF T[H].KEY = ID.A THEN
    BEGIN (*FOUND*) F := TRUE;
      X@.NEXT := T[H].FIRST; T[H].FIRST := X;
    END ELSE
    IF T[H].KEY = EMPTY THEN
    BEGIN (*NEW ENTRY*) F := TRUE;
      T[H].KEY := ID.A;
      T[H].FIRST := X; X@.NEXT := NIL
    END ELSE
    BEGIN (*COLLISION*) H := H+D; D := D+2;
      IF H >= P THEN H := H-P;
      IF D = P THEN
        BEGIN WRITELN(OUTPUT); WRITELN(STARS,' TABLE FULL',STARS);""" GO
        EXIT(99);
        END
    END
  UNTIL F
END (*SEARCH*) ;

PROCEDURE SORT(MIN, MAX: INTEGER);

(* QUICKSORT WITH BOUNDED RECURSION DEPTH *)
(* REQUIRES MIN <= MAX *)

   VAR
         LOW,
        HIGH: INDEX;
      MIDKEY: ALFA;
        TEMP: WORD;

   BEGIN
      REPEAT (*PICK SPLIT POINT*)
         MIDKEY := T[(MIN + MAX) DIV 2].KEY;
         LOW := MIN;
         HIGH := MAX;
         REPEAT (*PARTITION*)
            WHILE T[LOW].KEY < MIDKEY DO
               LOW := LOW + 1;
            WHILE T[HIGH].KEY > MIDKEY DO
               HIGH := HIGH - 1;
            IF LOW <= HIGH THEN
               BEGIN
                  TEMP := T[LOW];
                  T[LOW] := T[HIGH];
                  T[HIGH] := TEMP;
                  LOW := LOW + 1;
                  HIGH := HIGH - 1
               END;
         UNTIL LOW > HIGH;

         (*RECURSIVELY SORT SHORTER SUB-SEGMENT*)
         IF HIGH - MIN < MAX - LOW
         THEN
            BEGIN
               IF MIN < HIGH THEN
                  SORT(MIN, HIGH);
               MIN := LOW
            END
         ELSE
            BEGIN
               IF LOW < MAX THEN
                  SORT(LOW, MAX);
               MAX := HIGH
            END
      UNTIL MAX <= MIN
   END (*SORT*);


PROCEDURE NOTEPROC;   (*NOTE INSTANCE OF PROCEDURE OR FUNCTION*)
  VAR P: PROCREF;
BEGIN PROCORFUNC := FALSE;
  NEW(P); PROCPTR@.NEXT := P;
  P@.NAME := ID.A; P@.LNO := LN; P@.NEXT := NIL;
  PROCPTR := P
END (*NOTEPROC*) ;

PROCEDURE PRINTWORD(W: WORD);
  VAR L: INTEGER; X,Y,Z: REF;
BEGIN COUNTLINE; WRITE(OUTPUT,' ', W.KEY);
  X := W.FIRST; Y := X@.NEXT; X@.NEXT := NIL;
  WHILE Y <> NIL DO
    BEGIN Z := Y@.NEXT; Y@.NEXT := X; X := Y; Y := Z
    END ;
  L := 0;
  REPEAT
    IF L = NOPL THEN
      BEGIN L := 0; WRITELN(OUTPUT); COUNTLINE; WRITE(OUTPUT,' ', EMPTY)
      END;
    L := L+1; WRITE(OUTPUT,X@.LNO: DGPN); X := X@.NEXT
  UNTIL X = NIL;
  WRITELN(OUTPUT);
END (*PRINTWORD*) ;

PROCEDURE PRINTTABLE;
  VAR I,M: INDEX;
BEGIN M := 0;    (*COMPRESS TABLE*)
  FOR I := 0 TO P-1 DO
    IF T[I].KEY <> EMPTY THEN
      BEGIN T[M] := T[I]; M := M+1
      END ;
  IF M > 0 THEN SORT(0,M-1);
  NOPL := (LLNGOUT-KLN-1) DIV DGPN;
  SPACE(2); WRITELN(' CROSS REFERENCE OF IDENTIFIERS,',
            ' LABEL DECLARATIONS AND GOTO STATEMENTS:');
  COUNTLINE; SPACE(1);
  FOR I := 0 TO M-1 DO PRINTWORD(T[I])
END (*PRINTTABLE*) ;

PROCEDURE PRINTPROCS;
BEGIN SPACE(2); COUNTLINE;
  WRITELN(' LIST OF PROCEDURES AND FUNCTIONS:');
  COUNTLINE; SPACE(1);
  PROCPTR := FIRSTPROC@.NEXT;
  WHILE PROCPTR <> NIL DO
    BEGIN WITH PROCPTR@ DO WRITELN(NAME:24,LNO:10);
      COUNTLINE; PROCPTR := PROCPTR@.NEXT
    END
END (*PRINTPROCS*) ;

PROCEDURE INITIALIZE;
  TYPE SETTING = PACKED RECORD
                   CASE SWITCH: BOOLEAN OF
                     TRUE: (ONOFF: CHAR);
                     FALSE: (SIZE: 0..999999)
                   END;
  VAR S: SETTING;
  FUNCTION OPTION(NAME: CHAR; VAR S: SETTING): BOOLEAN;
    EXTERNAL;
BEGIN N := 0; M := 0;
  LLNGIN := LLMAX; LLNGOUT := LLMAX;
"""IF OPTION('U',S) THEN
    IF S.SWITCH AND (S.ONOFF = '+')
      THEN LLNGIN := LLMIN;
  IF OPTION('W',S) THEN
    IF S.SWITCH AND (S.ONOFF = '+')
      THEN LLNGOUT := LLMIN;    """
  FOR I := 0 TO P-1 DO T[I].KEY := EMPTY;
  NEW(PROCPTR); FIRSTPROC := PROCPTR; PROCPTR@.NEXT := NIL;
  PROCORFUNC := TRUE;   (*TO GET P R O G R A M NAME IN PROCEDURE INDEX*)
  KEY[ 1] := 'AND       '; KEY[ 2] := 'ARRAY     ';
  KEY[ 3] := 'BEGIN     '; KEY[ 4] := 'CASE      ';
  KEY[ 5] := 'CONST     '; KEY[ 6] := 'DIV       ';
  KEY[ 7] := 'DOWNTO    '; KEY[ 8] := 'DO        ';
  KEY[ 9] := 'ELSE      '; KEY[10] := 'END       ';
  KEY[11] := 'FILE      '; KEY[12] := 'FOR       ';
  KEY[13] := 'FUNCTION  '; KEY[14] := 'IF        ';
  KEY[15] := 'IN        '; KEY[16] := 'MOD       ';
  KEY[17] := 'NIL       '; KEY[18] := 'NOT       ';
  KEY[19] := 'OF        '; KEY[20] := 'OR        ';
  KEY[21] := 'PACKED    '; KEY[22] := 'PROCEDURE ';
  KEY[23] := 'PROGRAM   '; KEY[24] := 'RECORD    ';
  KEY[25] := 'REPEAT    '; KEY[26] := 'SET       ';
  KEY[27] := 'THEN      '; KEY[28] := 'TO        ';
  KEY[29] := 'TYPE      '; KEY[30] := 'UNTIL     ';
  KEY[31] := 'VAR       '; KEY[32] := 'WHILE     ';
  KEY[33] := 'WITH      '
END (*INITIALIZE*) ;

PROCEDURE SCANANDLISTINPUT;
BEGIN
  WHILE NOT EOF(INPUT) DO
  BEGIN NEWLINE;
    WHILE NOT EOLN(INPUT) DO
    CASE INPUT@ OF
     'a','b','c','d','e','f','g','h','i','j','k','l','m',
     'n','o','p','q','r','s','t','u','v','w','x','y','z',
     'A','B','C','D','E','F','G','H','I','J','K','L','M',
     'N','O','P','Q','R','S','T','U','V','W','X','Y','Z':
      BEGIN K := 0; ID.A := EMPTY;
        REPEAT
          IF K < KLN THEN
            BEGIN K := K+1; ID.A[K] := INPUT@
            END;
          ADVANCE
"""     UNTIL NOT(INPUT@ IN ['A'..'Z', '0'..'9']);   """
        UNTIL NOT(LETTER(INPUT@) OR DIGIT(INPUT@) OR SPECIAL(INPUT@));
        IF NOKEY THEN
        BEGIN SEARCH;
          IF PROCORFUNC THEN NOTEPROC
        END ELSE
        IF (ID.A = 'PROCEDURE ') OR (ID.A = 'FUNCTION  ') THEN
          PROCORFUNC := TRUE
      END;
     '0','1','2','3','4','5','6','7','8','9':
        REPEAT ADVANCE;
"""     UNTIL NOT (INPUT@ IN ['B','E','0'..'9']);  """
        UNTIL NOT DIGIT(INPUT@) ;
     '''':
      BEGIN (*STRING*)
        REPEAT ADVANCE;
        UNTIL (INPUT@ = '''') OR EOLN(INPUT);
        IF NOT EOLN(INPUT) THEN
          ADVANCE
      END;
#    '"':
      BEGIN (*COMMENT*)
        REPEAT ADVANCE;
          WHILE EOLN(INPUT) DO
            BEGIN WRITELN(OUTPUT); GET(INPUT); NEWLINE
            END
        UNTIL INPUT@ = '"';
        ADVANCE
      END;
     '(':
      BEGIN ADVANCE;
        IF INPUT@ = '*' THEN
        BEGIN (*COMMENT*) ADVANCE;
          REPEAT
            WHILE INPUT@ <> '*' DO
            BEGIN
              IF EOLN(INPUT) THEN
                BEGIN GET(INPUT); WRITELN(OUTPUT); NEWLINE
                END ELSE
                ADVANCE
            END ;
            ADVANCE
          UNTIL INPUT@ = ')';
          ADVANCE
        END
      END;
     '+','-','*','/',')','$','=',' ',',','.','[',']',
     ':','!','','&','@','?','<','>','','\','^',';','#','_','%','':
      ADVANCE
    END (*CASE*) ;
    WRITELN(OUTPUT); GET(INPUT)
  END ;
END (*SCANANDLISTINPUT*) ;

PROCEDURE SKIPCOMPILERTITLE;
  VAR I: INTEGER;
BEGIN
  COMPILERLISTING := INPUT@ = '1';
  IF COMPILERLISTING THEN
  BEGIN I := 0; GET(INPUT);
    WHILE I < LITL DO
      BEGIN I := I + 1;
        WHILE NOT EOLN(INPUT) DO
          ADVANCE;
        READLN; WRITELN(OUTPUT);
      END;
    COUNTLINE;
    LINENUMBERS := TRUE
  END ELSE
  BEGIN WRITELN(OUTPUT); WRITELN(OUTPUT);
    LINENUMBERS := """INPUT@ IN ['0'..'9']""" DIGIT(INPUT@)
  END
END (*SKIPCOMPILERTITLE*) ;

BEGIN (*CROSSREF*)
"""LINELIMIT(OUTPUT, MAXN);"""  PAGE(OUTPUT); INITIALIZE;
  IF NOT EOF(INPUT) THEN
  BEGIN SKIPCOMPILERTITLE;
    SCANANDLISTINPUT; """LINELIMIT(OUTPUT, MAXN); """
    PRINTTABLE; PRINTPROCS
  END ELSE WRITELN(STARS,' NO PROGRAM FOUND TO CROSS REFERENCE',STARS);
99:END .
