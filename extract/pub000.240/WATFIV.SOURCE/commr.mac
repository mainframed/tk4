         TITLE     'COMMR     COMMUNICATIONS REGION'
CSAVER   DC        0D'0'
         USING     CSAVER,RC
         SPACE
***********************************************************************
*****    OBJECT CODE OUTPUT ROUTINE                               *****
***********************************************************************
* NOTE
* COUT MUST BE ADDRESSED BY REGISTER 10 DIRECTLY AS IT IS BRANCHED
* TO BY BCR AND BALR INSTRUCTIONS
*
* NOTE
* NO MORE THAN 256 BYTES CAN BE MOVED IN A SINGLE CALL
*
* REGISTER USAGE
*
*                  GPR1                =OBJECT CODE ADDRESS
*                  GPR2                =BYTE COUNT-1
*                  GPR3                WORK REGISTER
*                  GPR5                =TOP OF OBJECT CODE
*                  GPR6                =BOTTOM OF SYMBOL TABLE
*                  GPR14               RETURN ADDRESS
***********************************************************************
         SPACE
COUT     LR        R3,R5
         IF        (CMOSWTCH,ON),DONE
         LA        R5,ZR5+1(R2)
         CR        R5,R6
         BH        ERMO0
         EX        R2,COUTMVC
         CSNAP     OUTPUT
         BR        R14
         SPACE
COUTMVC  MVC       ZR3(*-*),ZR1
         EJECT
* THIS ROUTINE OUTPUTS EXACTLY 4 BYTES OF OBJECT CODE
         SPACE
* BY USING IT WE SAVE 2 BYTES PER CALL AT THE COST OF 26 BYTES
         SPACE
* IF NECESSARY THIS ROUTINE MAY BE ELIMINATED AS ITS FUNCTION
* COULD BE PERFORMED BY COUT
         SPACE
COUT4    LR        R3,R5
         IF        (CMOSWTCH,ON),DONE
         LA        R5,ZR5+4
         CR        R5,R6
         BH        ERMO0
         MVC       ZR3(4),ZR1
         CSNAP     OUTPUT4,,4
         BR        R14
         EJECT
COUTSTAR LR        R3,R5
         USING     ZR14+2-1,R14
         IF        (CMOSWTCH,ON),ZR14+2(R2)
         $FREE     R14                                             V1L5
         LA        R5,ZR5+1(R2)
         CR        R5,R6
         BH        ERMO0A
         EX        R2,COUTSMVC
         CSNAP     OUTPUT*,(R14)
         USING     ZR14+2-1,R14
         B         ZR14+2(R2)
         $FREE     R14                                             V1L5
         SPACE
COUTSMVC MVC       ZR3(*-*),ZR14
         SPACE     5
***********************************************************************
***** ROUTINE TO OUTPUT MO-0 ERROR MESSAGE WHEN SYMTAB MEETS OBJCODE
***********************************************************************
         SPACE
ERMO0A   LA        R14,ZR14+1(R2)
ERMO0    $ERROR    (NOEX,MO,0),,SAVE                               V1L5
         THEN      (CMOSWTCH,ON)
         L         R5,XOBJECT
         ST        R5,CBAR11
         BR        R14
         EJECT
***********************************************************************
*****    COMPILER-MODULE ENTRY AND RETURN ROUTINES                *****
***********************************************************************
**      USED TO SET UP BASE REGISTERS AND SAVEAREA POINTERS          **
**          ON ENTRY TO MODULE                                       **
         SPACE
CENT     LR        R15,R13
         L         R13,ZR11
         ST        R13,ZR15+8
         USING     CENTUSE,R11
         L         R13,CENTSAVE
         ST        R15,ZSVBACK
         B         CENTRET
         $FREE     R11                                             V1L5
         SPACE
**       USED IN SOME MODULES WITH MULTIPLE ENTRIES                  **
CMENT    LR        R15,R13
         USING     CENTUSE,RDONE
         L         R13,CENTSAVE
         ST        R13,ZR15+8
         ST        R15,ZSVBACK
         L         RP,CMENTP
         B         CMENTRET
         $FREE     R14                                             V1L5
         SPACE
**       USED TO RESTORE BASE REGISTER,SAVEAREA REGISTER
CRET     L         R13,ZSVBACK
         L         R14,ZSV14
         L         R11,ZSV11
         BR        RDONE               RETURN
         EJECT
***********************************************************************
***  CLLIB - LOOKS UP NAMES IN LIBRARY LIST                         ***
**          INPUT  R8 - POINTS TO 'NAME' IN V-LIST
**          OUTPUT R3 - ADDRESS-CSYMBASE OF ENTRY IN L-LIST FOR 'NAME'
**                 R15 - POINTS TO 'NAME' IN L-LIST
***********************************************************************
         SPACE
         USING     VLIST,R8
         USING     LLIST,R15
CLLIB    L         R15,CLEND
         LH        R0,VNAME+4          MOVE NAME TO LLIST
         STH       R0,LNAME+4
         L         R0,VNAME
         ST        R0,LNAME
         L         R15,CLBEG           START LOOKING IN LLIST
         BAL       R3,*+8
         SH        R15,LLINK           TRY AGAIN
         CL        R0,LNAME            TRY FIRST 4 CHARACTERS
         BNER      R3                  NOPE
         CLC       LNAME+4(2),VNAME+4  TRY LAST 2 CHARACTERS
         BNER      R3                  NOPE,BLAST
         LR        R3,R15
         S         R3,CSYMBASE         SET R3 FOR CALLER
         C         R15,CLEND           WAS IT AT END
         BNER      RDONE               NO,RETURN WITH CC AS 'NE'
CLLIB1   GETSYM    16                  YES. SET UP FOR NEXT TIME
         LR        R0,R15
         SR        R0,R6
         STH       R0,LLINK
         ST        R6,CLEND            UPDATE END POINTER
         CR        R15,R15             SET CC TO 'EQ'
         BR        RDONE               RETURN TO CALLER
         $FREE     R8,R15                                          V1L5
         EJECT
***********************************************************************
***   CLSTN - STATEMENT NUMBER LOOKUP ROUTINE                       ***
**       ENTRY POINT CLSTN LOOKS UP STATEMENT NUMBERS IN S-LIST      **
**       ENTRY POINT CLPSTN LOOKS UP PSEUDO-STATEMENT NUMBERS        **
**                             GENERATED BY DO STATEMENT COMPILER    **
**       INPUT   RS POINTS TO STACK ENTRY CONTAINING NUMBER          **
**       OUTPUT  R3 - ADDRESS-CSYMBASE OF ENTRY IN S-LIST            **
**               R15 POINTS TO ENTRY IN S-LIST                       **
***********************************************************************
         SPACE
         USING     STAK,RS
CLSTN    IF        (SOPND,LE,5*8),CLE59S     LESS THAN 5 DIGITS?
         $ERROR    (WARN,ST,1,SYMRS,INVAL),,SAVE                   V1L5
CLE59S   NI        SOPND,B'00000111'   GET RID OF DIGIT COUNT
CLPSTN   L         R3,SOPND            STATNUM TO R0
         USING     NLIST,R15
         L         R15,CSEND           PUT IT AT END OF NLIST
         ST        R3,NSTAT
         AR        R3,R3               DOUBLE STATEMENT NUMBER
         N         R3,KM2631           USE BITS 26 TO 30
         LH        R0,CSTNOCEL(R3)        AS HASH INDEX
         LTR       R0,R0               IS IT NEW ?
         BNZ       CMAYBOLD            NON-ZERO =>MAY BE OLD
         LR        R0,R15              ZERO MEANS NEW
         S         R0,CSYMBASE         COMPUTE HASH CELL VALUE
         STH       R0,CSTNOCEL(R3)       AND STASH IT
         LR        R3,R0               SET R3 FOR CALLER
CNUSTANO GETSYM    12                  YES,SET UP FOR NEXT TIME
         LR        R0,R15
         SR        R0,R6
         STH       R0,NLINK
         ST        R6,CSEND            UPDATE END POINTER
         LH        R0,XISN             SET ISN FIELD
         ST        R0,NADDR
         LH        R0,CDONO            SET B1 AND DONUMBER
         STH       R0,NB1
         CR        R15,R15             SET CC TO 'EQ'
         BR        R14                 RETURN TO CALLER
CMAYBOLD LR        R3,R0               SET R3 FOR CALLER
         LR        R15,R3              COMPUTE
         N         R15,KM1631             ADDRESS
         A         R15,CSYMBASE            IN SYMTAB
         L         R0,SOPND
         CL        R0,NSTAT            IS THIS IT?
         BE        COLDSTNO            YES
         CSNAP     HASHSTNO,SOPND,4
         CSNAP     *,NSTAT,4
         CSNAP     CELLS,CSTNOCEL,64
CSTNLINK SH        R15,NLINK           LOOK
         CL        R0,NSTAT              DOWN
         BNE       CSTNLINK                THE LIST
         LR        R3,R15              FOUND IT
         S         R3,CSYMBASE         COMPUTE R3 FOR CALLER
COLDSTNO C         R15,CSEND           WAS IT AT END OF LIST?
         BE        CNUSTANO            YES,THEN IT'S NEW
         BR        R14                 NO,RETURN COND CODE SET TO 'NE'
         $FREE     R15,RS                                          V1L5
         EJECT
***********************************************************************
*****    CLSYM - LOOKUP SYMBOLS IN V-LIST                         *****
**          ENTRY POINT CLSYM LOOKS UP SYMBOLS IN STACK              **
**          ENTRY POINT CSPCLNMS LOOKUPS UP SYMBOLS POINTED TO BY R3 **
**       INPUT RS POINTS TO STACK ENTRY ON ENTRY TO CLSYM            **
**             R3 POINTS TO SYMBOL FOR ENTRY TO CSPCLNMS             **
**       OUTPUT R3 ADDRESS-CSYMBASE OF ENTRY IN V-LIST               **
**              R15 POINTS TO ENTRY IN V-LIST                        **
***********************************************************************
         SPACE
CSPCLNMS STM       R1,R2,CSAVE26
         L         R1,ZR3              GET CHARACTERS 1 TO 4 OF NAME
         LH        R0,ZR3+4            GET CHARACTERS 5 AND 6
         B         CHASH               BYPASS LENGTH CHECK
         USING     STAK,RS
CLSYM    STM       R1,R2,CSAVE26       SAVE R1,R2
         L         R1,SOPND            GET CHARACTERS 1 TO 4
         LH        R0,KBL2             IN CASE OF SHORT NAME
         IF        (SCODE,LT,X'02'),CHASH    IS NAME 4 OR LESS
         LH        R0,SOPND+4          NO,GET CHARACTERS 5 AND 6
         CLI       SOPND+6,C' '        IS NAME 6 OR LESS?          V1L4
         BC        ZIFEQ,CHASH         HASH IF NAME <= 6 CHARS     V1L5
         TM        VA0SW,X'80'         ONLY PRINT VA-0 MESSAGE     V1L5
         BO        CHASH               ONCE FOR SUBROUTINE NAMES   V1L5
VA0MSG   $ERROR    (WARN,VA,0,SYMRS),,SAVE  WARN AND TRUNCATE      V1L5
         $FREE     RS                                              V1L5
         USING     VLIST,R15
CHASH    L         R15,CVEND           STASH NAME AT
         ST        R1,VNAME             PRESENT END
         STH       R0,VNAME+4           OF SYMBOL LIST
         LR        R3,R1
         M         R2,CHASHWTS         HASH CHARACTERS 1 TO 4
         SLDL      R2,8
         N         R2,CHASHMSK
         LH        R3,CHASHCEL(R2)     CHECK HASH CELL
         LTR       R3,R3               ZERO MEANS A NEW SYMBOL
         BNZ       CTESTOLD            NON-ZERO MEANS MAYBE OLD
         LR        R3,R15              COMPUTE HASH CELL VALUE
         S         R3,CSYMBASE
         STH       R3,CHASHCEL(R2)     STASH IT
CNEWNAME GETSYM    16                  SPACE FOR
         ST        R6,CVEND            NEW END OF LIST
         LR        R1,R15              LINK NEW END CELL IN
         SR        R1,R6                   TO
         STH       R1,VLINK             SYMBOL LIST
         SR        R1,R1
         STH       R1,VB3              ZERO OUT
         ST        R1,VADDR              THE FIELDS IN THE
         STC       R1,VB2                SYMBOL TABLE
         IC        R1,VNAME            GET 1ST LETTER OF NAME
         IF        (VNAME,NE,C'$'),CNOT$   CHECK FOR G.D. $
         LA        R1,C'Z'+1           IF SO AT END OF TABLES
CNOT$    IC        R0,CIMPL1-C'A'(R1)    GET THE TYPE
         STC       R0,VB1              STASH IT
         OI        VB1,SIMV            ASSUME SIMPLE VARIABLE
         IC        R0,CIMPL2-C'A'(R1)    GET THE LENGTH
         STC       R0,VLEN             STASH IT
         LM        R1,R2,CSAVE26       RESTORE R1,R2
         CR        R15,R15             SET CONDITION CODE TO 'EQ'
         BR        R14                 OVER AND OUT
CTESTOLD LR        R15,R3
         N         R15,KM1631          LAST 16 BITS ONLY
         A         R15,CSYMBASE        COMPUTE ADDRESS IN SYMTAB
         CL        R1,VNAME            IS THIS WHAT WE WANT
         BNE       CLSTSRCH            NOPE,BLAST
         CH        R0,VNAME+4          MIGHT BE
         BE        COLDNAME            GO SET CONDITION CODE TO 'NE'
CLSTSRCH EQU       *
         CSNAP     HASHFAIL,XSNAPSAV+22,6
         CSNAP     *,VNAME,6
         CSNAP     HASHCELS,CHASHCEL,128
CLSTSUB  SH        R15,VLINK           LOOK FOR IT IN LIST
         CL        R1,VNAME            IS THIS IT
         BNE       CLSTSUB             NOPE
         CH        R0,VNAME+4          MAYBE
         BNE       CLSTSUB             NOPE
         LR        R3,R15
         S         R3,CSYMBASE         SET R3 FOR CALLER
COLDNAME C         R15,CVEND           WAS IT AT END OF LIST
         BE        CNEWNAME            IF SO,ITS NEW
         LM        R1,R2,CSAVE26       RESTORE R1,R2
         BR        R14                 RETURN,CONDITION CODE IS 'NE'
         $FREE     R15                                             V1L5
         DC        0F'0'
CHASHWTS DC        X'02060A0E'
CHASHMSK DC        X'0000007E'
CHASHCEL DC        64H'00'
CSTNOCEL DC        32H'00'
         EJECT
***********************************************************************
* THIS ROUTINE VERIFIES THAT THE SYMBOL TABLE HAS NOT OVERWRITTEN THE
* COMPILER
* IF THIS HAPPENS THE CURRENT JOB IS KICKED OFF WITH ERROR MO-2
***********************************************************************
         SPACE
CGETSYM  C         R6,XOBJECT
         BNLR      RDONE
CERRMO2  $ERROR    (NOEX,MO,2),XSTOP                               V1L5
         SPACE     5
***********************************************************************
**      ROUTINE TO SET UP STACK WHEN KEYWORDS ARE CONCATENATED WITH
**                ALPHABETIC OR NUMERIC CHARACTER STRINGS.
**      E.G.  PRINT1 , CALLNAME , DO1I   ETC
**    INPUTS ARE STACK POINTER (R9) AND R1 AS POINTER TO CHAR AFTER
**       THE KEYWORD TO BE DECONCATENATED. IN ADDITION REGISTERS R15-R4
**       ARE USED AS WORK REGISTERS.
***********************************************************************
         SPACE
         USING     STAK,RS
CSETSTAK SR        R15,R15             CLEAR R15
         IC        R15,SCODE           GET STACK LENGTH CODE
         AR        R15,R15             DOUBLE
         AR        R15,R15             AND AGAIN
         LA        R15,SOPND(R15)      R15 PTS TO CHAR STACK ENTRY
         MVI       SCODE,PHI           MOVE PHI TO STACK CODE
         CR        R1,R15              IS THIS THE NULL STRING
         BER       R14                 YES,PHI IS AT 3(R9),RETURN
         IF        (ZR1,EQ,C' '),DONE     IS THIS A BLANK STRING
CHKALFDG MVC       CSETXIT+1(1),ZR15   SAVE LINK CHARACTER
         MVI       ZR15,C' '         PUT A BLANK THERE
         LR        R4,RS               SAVE STACK POINTER IN R4
         IF        (ZR1,ON,X'F0'),CSETNUM  TEST FOR NUMERIC STRING
CITSALFA LR        R2,R15
         SR        R2,R1               NO OF CHARS TO BE MOVED-1
         EX        R2,CSETMVC
         LA        R3,ZR4+1(R2)        BUMP FOR CHARACTERS MOVED
         MVC       ZR3+4(2),KBL2        PAD WITH 2 BLANKS FOR SAFETY
         LA        R2,ZR2+3            COMPUTE WORDCOUNT FROM CHARCOUNT
         SRL       R2,2
         STC       R2,ZR4+3            STORE CODE FOR NO OF WORDS
CSETXIT  MVI       ZR15,*-*            RESTORE LINK CHARACTER
         CSNAP     SETSTACK,(RS),24
         BR        R14
CSETNUM  LR        R2,R1
CSETNUM1 LA        R2,ZR2+1            SCAN FOR NON-NUMERIC
         IF        (ZR2,ON,X'F0'),CSETNUM1
         LR        R3,R2
         BCTR      R3,0                LENGTH-1 OF NUMSTRING
         SR        R3,R1
         S         R1,KF4
         C         R3,KF5              IS IT TOO LONG
         BL        CN9NO
         $ERROR    (WARN,CN,7,NAMR1,INVAL),,SAVE                   V1L5
         LA        R3,5-1              ASSUME 5
CN9NO    EX        R3,CSETPACK
         CVB       R0,CONDOUB
         IF        (ZR2,NE,C' '),CNUMALFA /*WASNUMSTRING TERM. BY ' '*/
         ST        R0,SOPND            STASH RESULTING CONSTANT
         MVI       SCODE,CCONS+1       MARK CONST IN STACK
         B         CSETXIT             CHECK OUT
CNUMALFA MVI       SOPTR,PHI           PUT PHI B4 ALPHASTRING
         SH        RS,CXSTACK          MOVE BACK TOP OF STACK
         MVC       STAK(8),CXSTACK     SETUP NEW STACK TOP
         ST        R0,SOPND            STASH THE CONSANT
         LR        R1,R2
         B         CITSALFA            GO FOR ALPHASTRING
         DC        0F'0'               ALIGN CXSTACK
CXSTACK  DC        H'8',X'0181',XL4'00'
CSETPACK PACK      CONDOUB+5(3),ZR1+4(*-*)
CSETMVC  MVC       ZR4+4(*-*),ZR1
         $FREE     RS                                              V1L5
         SPACE     5
***********************************************************************
****     ROUTINE TO PUT OUT ISN OBJECT CODE                        ****
***      CALLING SEQUENCE   BAL  R14,CISN
***********************************************************************
         SPACE
CISN     DS        0H                                              V1L5
         AIF       ('&PROFILE' EQ 'USE').CNOP                      V1L5
         B         CISN2               BRANCH AROUND CNOP          V1L5
         NOP       *-*                 FILLER                      V1L5
         AGO       .NOCNOP                                         V1L5
.CNOP    ANOP                                                      V1L5
         IF        (CCNTSW,OFF),CISN2                              V1L5
.NOCNOP  ANOP                                                      V1L5
         ST        R14,XRUPTSV+4       SAVE R14                    V1L5
         BAL       R14,CNOP04          ALIGN OBJ CODE ON FULLWORD  V1L5
         L         R14,XRUPTSV+4       RESTORE R14                 V1L5
CISN2    LA        R3,ZR5+2                                        V1L5
         ST        R3,CBAR11
         THEN      (CISNCDSW,ON)       SET SWITCH FOR ERROR EDITOR
         AIF       ('&PROFILE' EQ 'USE').PROF16                    V1L5
         B         PROF16              GO AROUND PROFILER CHECKING V1L5
         NOP       *-*                 FILLER                      V1L5
         AGO       .PROF17                                         V1L5
.PROF16  ANOP                                                      V1L5
         IF        (CCNTSW,OFF),PROF16                             V1L5
.PROF17  ANOP                                                      V1L5
         CLC       XPRSTART,KF0        IS THIS THE FIRST COUNT?    V1L5
         LA        R2,2(,R5)           GET THE ISN ADDRESS         V1L5
         BNE       CNT1                NO                          V1L5
         ST        R2,XPRSTART         THIS IS THE FIRST COUNT     V1L5
         ST        R2,CALINK           SAVE THE POINTER            V1L5
         SR        R2,R2               R2 = 0                      V1L5
         ST        R2,XTOTCNT1         XTOTCNT1 = 0                V1L5
         ST        R2,XTOTCNT2         XTOTCNT2 = 0                V1L5
         B         CNT2                SKIP AROUND LINKING         V1L5
CNT1     L         R3,CALINK           GET THE LAST ISN ADDRESS    V1L5
         ST        R2,CALINK           SAVE THE LINK               V1L5
         MVC       3(3,R3),CALINK+1    FILL IN THE LINK            V1L5
CNT2     CLI       CLIFSW,X'FF'        IS IT A LOGICAL IF STMT ?   V1L5
         AIF       ('&STR' NE 'USE').NOSTR                         V1L5
         BE        CNT3                YES                         V1L5
         CLI       CWHPERF,X'FF'       IS IT A WHILE-EXEC STMT?    V1L5
         AGO       .NOSTR2                                         V1L5
.NOSTR   ANOP                                                      V1L5
         NOP       *-*                 FILLER                      V1L5
         NOP       *-*                   "                         V1L5
.NOSTR2  ANOP                                                      V1L5
         BNE       CNT4                NO                          V1L5
CNT3     MVI       XCOUNT1,X'C0'       INDICATE IF OR WHILE-EXEC   V1L5
         THEN      (OUTPUT,16,XISNCD),DONE     OUTPUT CODE         V1L5
CNT4     MVI       XCOUNT1,X'00'       INDICATE NOT IF OR WHILE-EX V1L5
         THEN      (OUTPUT,12,XISNCD),DONE     OUTPUT CODE         V1L5
PROF16   DS        0H                                              V1L5
         THEN      (OUTPUT,4,XISNCD),DONE
         SPACE     5
***********************************************************************
*********          CNOP OUTPUT ROUTINES                       *********
***********************************************************************
* CALLING SEQUENCE
*        BAL       R14,CNOP'RTN
         SPACE
CNOP04   LCR       R2,R5
         N         R2,KM3031
CNOPC    S         R2,KF1
         BLR       RDONE
CNOPC1   THEN      (OUTPUT,(R2),*),DONE
         SPACE
         NOPR      0                   THIS IS THE CODE
         NOPR      0                   DO
         NOPR      0                   NOT
         NOPR      0                   REMOVE
         SPACE
CNOP24   LCR       R2,R5
         LA        R2,ZR2+2
         N         R2,KM3031
         B         CNOPC
         SPACE
CNOP08   LCR       R2,R5
         N         R2,KM2931
         B         CNOPC
         SPACE
CNOP28   LCR       R2,R5
         LA        R2,ZR2+2
         N         R2,KM2931
         B         CNOPC
         SPACE
CNOP48   LCR       R2,R5
         LA        R2,ZR2+4
         N         R2,KM2931
         B         CNOPC
         SPACE
         ORG       CNOP48
         SPACE
CNOP68   LCR       R2,R5
         LA        R2,ZR2+6
         N         R2,KM2931
         B         CNOPC
         SPACE
         ORG       CNOP68
         SPACE     5
***********************************************************************
*********          BOUNDARY ALIGNMENT ROUTINES                *********
***********************************************************************
* CALLING SEQUENCE
*        BAL       RDONE,CDS'RTN
* REGISTER USAGE
*                  R5                  =TOP OF OBJECT CODE
*                  RDONE               RETURN ADDRESS
         SPACE
CDS0H    LA        R5,ZR5+1            ALLIGN ON HALFWORD BOUNDARY
         N         R5,KM0030
         BR        RDONE               RETURN
CDS0F    LA        R5,ZR5+3            ALLIGN ON FULLWORD BOUNDARY
         N         R5,KM0029
         BR        RDONE               RETURN
CDS0D    LA        R5,ZR5+7            ALLIGN ON DOUBLEWORD BOUNDARY
         N         R5,KM0028
         BR        R14                 RETURN
         SPACE     5
***********************************************************************
*****    ROUTINE TO OUTPUT A BALR R11,0 TO OBJECT CODE            *****
***********************************************************************
         SPACE
CBALR11  THEN      (OUTPUT,2,*),DONE
         SPACE
         BALR      RP,0                OBJECT CODE
         EJECT
***********************************************************************
*****    CONSTANT LOOKUP ROUTINES                                 *****
*        CALLING SEQUENCE  BAL  R14,COLCONST  TO COLLECT ANY CONSTANT
*                          BAL  R14,COLINTGR  TO COLLECT AN INTEGER
*                          BAL  R14,CONTEST  TO TEST FOR AND COLLECT
*                                      ANY CONSTANT. R3 MUST CONTAIN
*                                      ADDRESS OF ERROR RETURN IN
*                                      CASE NO CONSTANT IS FOUND
*      INPUT:
*        RS  POINTS TO STACK ENTRY WHERE COLLECTION OF CONSTANT IS
*             TO START
*      OUTPUTS:
*        R3   ADDRESS-CSYMBASE OF ENTRY FOR CONSTANT IN K-LIST
*        R15  POINTS TO ENTRY IN K-LIST
*        R0 CONTAINS CODE FOR TYPE OF CONSTANT FOUND
*        R2-R6 ARE SAVED AND RESTORED
*        THE STACK IS ALTERED TO LINK AROUND CONSTANT
*        N.B. DO NOT ASSUME CONSTANTS FALL ON AN INTEGRAL BOUNDARY
*          FOR THEIR LENGTH IN SYMTAB
***********************************************************************
         SPACE
         USING     STAK,RS
COLINTGR MVI       CINTSW+1,BRA        SET INT SW TO 'B'
         B         COL1                    COLLECTING AFTER A INT CONST
CONTEST  MVI       CONERR+1,NOP        SET ERROR SWITCH
COLCONST MVI       COMPSW+1,BRA
         MVI       CINTSW+1,NOP        SET SW TO ALLOW REALS
         IF        (SOPTR,NE,LBRK),COL1
         MVI       COMPSW+1,NOP        SET SW TO TRY FOR COMPLEX CONST
COL1     STM       R1,R6,CSAVE16       SAVE SOME REG'S
         MVI       C1STCON+1,NOP       SET SW FOR 1ST CONST
         LR        R5,RS               R5 MOVES DOWN STACK
         $FREE     RS                                              V1L5
         USING     STAK,R5
COMPP    LR        R6,R5               R6 POINTS TO START OF CONST
         SR        R0,R0               R0 CONTAINS DIGIT COUNT*8
         THEN      (CSIGN,OFF)         INITIALIZE SIGN SWITCH
         SPACE
*        DECIDE WHETHER ITS CONSTANT CONFIGURATION 1,2,3,4,5
*        TYPE 1 IS 'OP'.'N'  'OP' IS AN OPERATOR, 'N' A NUMBER
*        TYPE 2 IS 'OP' + OR - 'N'     EG ( + 3
*        TYPE 3 IS 'S' 'N'     'S' IS + OR -      -3
*        TYPE 4 IS 'OP' 'S' . 'N'            (+.N
*        TYPE 5 IS 'OP' N     'OP' IS NOT + OR -   EG (3
*        TYPES 2,4 WILL PRODUCE SIGNED CONSTANTS
         SPACE
         IF        (SCODE,NE,PHI),CGETCON     TEST FOR 'OP''OP'
         LA        R5,STAK+4           NEXT STACK ENTRY
         IF        (SOPTR,EQ,PLUS),CPOSCON
         IF        (SOPTR,NE,MINUS),CDECENT   CHK FOR '+' OR '-'
         THEN      (CSIGN,ON)          SET SIGN SW FOR NEG CONST
CPOSCON  IF        (SCODE,NE,PHI),CGETCON    TEST FOR TYPE 2 OR 4
         LA        R5,STAK+4           SHOULD BE TYPE 4
         B         CDECENT
CGETCON  IF        (SCODE,OFF,CCONS),CONERR   CHK FOR CONST AFTER '.'
         BAL       R15,COLINT          GET CONSTANT AS AN INTEGER
         AH        R5,SLINK            LOOK AHEAD FOR
CINTSW   B         CINTEGER            B/NOP SWITCH . B IF INTEGER
***   COME HERE TO CHECK FOR AN EXPONENT OR '.' FOLLOWING AN INTEGER
         IF        (SOPTR,EQ,DEC),COLFLT
         BAL       R15,CHKEXP          SEE IF THERE'S AN EXPONENT
         B         CINTEGER            RETURN FOR NO EXPONENT
         LA        R15,CGOTEXP         RETURN FOR EXPONENT PRESENT
         B         CFLOATF0            FLOAT IT.GO FIX UP EXPONENT
COLFLT   BAL       R15,CFLOATF0
*        R5 POITS AT'.'
         IF        (SCODE,ON,CCONS),COLFLT1     CHK FOR FRACTION PART
         STC       R0,CDIGCNT          SAVE DIG COUNT
         IF        (SCODE,EQ,PHI),CNOFRAC  TEST FOR '.''OP'
         BAL       R15,CHKEXP1         GO TEST FOR AN EXPONENT
         B         CNOEXP              NO RETURN
         B         CGOTEXP             YES RETURN
***   ENTRY IF CONSTANT STARTS WITH '.'
CDECENT  IF        (SOPTR,NE,DEC),CDECERR2
         IF        (SCODE,OFF,CCONS),CDECERR1     CHK FOR CONST
         SDR       F0,F0               SET INTEGER PART TO ZERO
COLFLT1  BAL       R15,COLINT          GET FRACTIONAL PART AS INTEGER
         STC       R0,CDIGCNT          SAVE DIGIT COUNT
         LDR       F2,F0
         BAL       R15,CFLOATF0        FLOAT THE FRACTION
         DD        F0,C10LE7-8(R4)     ACCOUNT FOR FRAC DIGITS     V1L4
         ADR       F0,F2               COMBINE INT AND FRACTION
         AH        R5,SLINK
         IF        (SOPTR,NE,PHI),CNOEXP   CHK FOR EXPONENT
CFRACOUT BAL       R15,CHKEXP          GO CHECK FOR EXPONENT
         B         CNOEXP              NO RETURN
***   COME HERE TO ACCOUNT FOR EXPONENT
CGOTEXP  AH        R5,SLINK            R5 --> PAST EXPONENT
         STC       R0,CDIGCNT                                      V1L5
         STC       R4,CEXP1            SAVE EXPONENT
         N         R4,KM2527           EXP=B+L,0.LE.L.LE.15
         SRL       R4,1
CEXPSW   B         CNEGEXP             B/NOP SW SET BY CHKEXP
         BZ        CNOBIGP             TEST FOR B=0
         MD        F0,C10POS-8(R4)     ADJUST FOR POSITIVE EXPON   V1L4
CNOBIGP  NI        CEXP1,X'0F'
         BZ        CEXPDONE            TEST IF L=0
         IC        R4,CEXP1
         SLL       R4,3
         MD        F0,CD10LE7-8(R4)
         B         CEXPDONE
CNEGEXP  BZ        CNOBIGM             TEST FOR B=0
         DD        F0,C10POS-8(R4)
CNOBIGM  NI        CEXP1,X'0F'
         BZ        CEXPDONE            TEST FOR L=0
         IC        R4,CEXP1
         SLL       R4,3
         DD        F0,C10LE7-8(R4)
         B         CEXPDONE
CNOFRAC  AH        R5,SLINK            BUMP PAST '.''OP' CASE
***   COME HERE IF REAL CONSTANT HAS NO EXPONENT
CNOEXP   MVI       CEXPTYPE+1,NOP      ASSUME E-TYPE EXPONENT
         IF        (CDIGCNT,LT,X'40'),CEXPDONE     CHK THAT OUT
         MVI       CEXPTYPE+1,BRA      .GT. 7 DIGITS,MUST BE REAL*8
***   COME HERE TO FINISH PROCESSING REAL CONSTANTS
CEXPDONE IF        (CDIGCNT,LE,X'80'),CPLUS2   CHK FOR .GT. 17 DIGITS
         $ERROR    (WARN,CN,3),,SAVE   ASSUME 16                   V1L5
CPLUS2   IF        (CSIGN,OFF),CPLUS   DO WE ACCOUNT FOR MINUS SIGN
         LNDR      F0,F0               YES
CPLUS    EQU       *
CEXPTYPE B         CPLUS1              B FOR D,NOP FOR E-TYPE EXPONENT
         IF        (CDIGCNT,LE,X'38'),CNOCN6                       V1L2
         $ERROR    (WARN,CN,6),,SAVE   E-TYPE EXPONENT GT 7 DIGITS V1L5
CNOCN6   STD       F0,CDOUB            ROUND TO 6 HEX DIGITS       V1L4
         XC        CDOUB+1(3),CDOUB+1  ZERO HIGH 3 MANTISSA BYTES  V1L2
         AD        F0,CDOUB            ROUND INTO 3RD MANT BYTE    V1L4
         MVI       CTYPE,REAL4         ITS A REAL*4 CONSTANT
         LA        R0,3                GET SET FOR LOOKUP
         B         C1STCON
CPLUS1   MVI       CTYPE,REAL8         ITS REAL*8
         LA        R0,7                GET SET FOR LOOKUP
         B         C1STCON
         SPACE
***   COME HERE TO FINISH PROCESSING AN INTEGER CONSTANT
*        NOW WE ASSUME ITS AN INTEGER CONSTANT
*        INTEGER IS IN R2-R3
*        HIGH ORDER PART R2 SHOULD BE ZERO
CINTEGER LTR       R2,R2               IS N.LT. 2**32-1
         BZ        COK1
         LA        R0,X'81'            SET ERROR INDICATOR
COK1     LTR       R3,R3               IS N.LT. 2**31-1
         BNM       CFWRD
         LA        R0,X'81'            SET ERROR INDICATOR
CFWRD    MVI       CTYPE,INT4          ITS INYEGER*4
         IF        (CSIGN,OFF),CHKER     DO WE ACOUNT FOR MINUS SIGN
         LNR       R3,R3               NEGATIVE TO BOOT
CHKER    CH        R0,=X'0081'         IS IT ILLEGAL
         BL        COK5                NO
         $ERROR    (WARN,CN,1),,SAVE                               V1L5
COK5     LA        R0,3                GET SET FOR LOOKUP
         SPACE
*        COME HERE TO DECIDE IF WE CONTINUE LOOKING FOR A COMPLEX PART
*        RETURN IF 1ST CONST AN INTEGER IN ANY CASE
*        RETURN IF 2ND CONST INTEGER BUT SET TYPE OF CONST FOUND TO BE
*                  REAL
*        ALSO CHECK THAT REAL AND IMAGINARY PARTS AGREE IN LENGTH IF A
*                  COMPLEX CONSTANT HAS BEEN FOUND
*                  TRUNCATE IF MIXED LENGTH
C1STCON  NOP       C2NDCON             NOP FOR 1ST CON ,B FOR 2ND
         ST        R3,CDOUB1           ASSUME INT CONST
         IF        (CTYPE,EQ,INT4),CONEXIT
         STD       F0,CDOUB1           SAVE THE WHOLE GD THING     V1L4
COMPSW   B         CONEXIT             NOP IF TRYING FOR COMP CONST
         IF        (SOPTR,NE,COMMA),CONEXIT    TEST FOR ','
         MVC       CTYPESAV+1(1),CTYPE    SAVE TYPE OF 1ST CONST
         MVI       C1STCON+1,BRA       SET SW FOR 2ND CONSTANT
         MVI       CONERR+1,BRA        SET ERROR SW FOR 2ND CONSTANT
         STC       R0,C1STLNGT         SAVE LENGTH OF 1ST
         B         COMPP               GET 2ND CON ,HOPEFULLY
C1STLNGT EQU       COMPSW+1
C2NDCON  IF        (CTYPE,EQ,INT4),CONEXIT4   2ND CONST CANT BE INTEGER
         IF        (SOPTR,NE,RBRK),CONEXIT4   TEST FOR TRAILING ')'
CTYPESAV IF        (CTYPE,NE,*-*),CEE1 ARE REAL & IMAG PARTS THE SAME
         IF        (CTYPE,NE,REAL4),CDD    IS 1ST REAL*4
CEE      STE       F0,CDOUB1+4         STORE 2ND AS E              V1L4
         MVI       CTYPE,COMP8     ITS COMPLEX*8
         LA        R0,7                GET SET FOR LOOKUP
         B         COMPOUT
CEE1     $ERROR    (WARN,CN,0),,SAVE                               V1L5
CDD      MVI       CTYPE,COMP16        ITS COMPLEX*16
         STD       F0,CDOUB            SAVE IT                     V1L4
         LA        R0,15               GET SET FOR LOOKUP
         $FREE     R5                                              V1L5
         USING     STAK,RS
COMPOUT  MVI       SOPTR,PHI           GET RID OF '(' IN STACK
         $FREE     RS                                              V1L5
         USING     STAK,R5
         MVI       SOPTR,PHI           GET RID OF TRAILING ')' TOO
         IF        (SCODE,NE,PHI),CONEXIT   CHK FOR ')''OP' CASE
         LA        R5,STAK+4           BUMP AROUND IT
         B         CONEXIT
CONEXIT4 MVC       CTYPE(1),CTYPESAV+1     RESTORE TYPE OF 1ST CONSTANT
CONEXIT2 LR        R5,R6               RESET R5 TO END OF 1ST CONSTANT
         IC        R0,C1STLNGT              & ITS LENGTH
CONEXIT  SR        R5,RS               CALCULATE LINK
         $FREE     R5                                              V1L5
         USING     STAK,RS
         STH       R5,SLINK
         $FREE     RS                                              V1L5
         SPACE     2
****   THIS IS THE PART OF THE CONSTANT COLLECTER WHICH CREATES
*            SYMBOL TABLE ENTRIES FOR CONSTANTS
***   HEX CONSTANT COLLECTER IN DATA STATEMENT ENTERS HERE AS WELL
         LM        R4,R6,CSAVE26+8
CONLOOK  SR        R6,R0               LENGTH-1 IN R0
         GETSYM    5                   GET SPACE IN SYMTAB
         STC       R0,CONLNGTH
         LR        R2,R0
         USING     CLIST,R6
         EX        R2,CMOVECON         PUT CONST AT END OF LIST
         STH       R0,CLEN             STASH  ITS LENGTH
CONB     B         C1STLOOK            A SWITCH INITIALLY THIS
**       LQ        R15,CKEND           CHANGED TO THIS
         SR        R15,R6
         STH       R15,CLINK(R15)      STASH LINK TO LAST ENTRY
         $FREE     R6                                              V1L5
         USING     CLIST,R15
         L         R0,CONSTANT         GET 1ST 4 BYTES OF CONSTANT
         L         R15,CKBEG
         BAL       R3,CONLOOK2         LOOK FOR CONSTANT
         SH        R15,CLINK           NEXT ENTRY
CONLOOK2 CH        R2,CLEN             DONT CHK CONSTS OF LESSER LENGTH
         BHR       R3
         CL        R0,CON4             DO 1ST 4 BYTES AGREE
         BNER      R3                  NO
         EX        R2,CONLOOK1         CHECK THE WHOLE SCHMEAR
         BNER      R3                  LOOK FURTHER
***    THIS TEST ENSURES THAT A COMPLEX*8 CONSTANT COMPARES ONLY TO A
*        CONSTANT OF LENGTH 8 IN SYMTAB BECAUSE OF RELOCATERS PRIMARY
*        AND SECONDARY POINTER SCHEME FOR COMPLEX QUANTITIES.
         IF         (CTYPE,NE,COMP8),CNOTCOM8    IS IT COMPLEX*8
         CH        R2,CLEN             CHK LENGTH IN SYMTAB
         BNER      R3                  LOOK FURTHER IF NOT SAME
CNOTCOM8 LR        R3,R15
         S         R3,CSYMBASE
         CR        R15,R6              WAS CONST AT END OF LIST
         BNE       COLDCON
CNEWCON  ST        R6,CKEND            SET NEW END OF LIST
         B         CONDONE
COLDCON  L         R6,CSAVE26+16       RESTORE OLD END OF LIST
CONDONE  SR        R0,R0
         IC        R0,CTYPE            TYPE CODE GOES TO R0 FOR RETURN
         LM        R1,R2,CSAVE16       RESTORE R1,R2
         AIF       ('&SNAPS'EQ'OMIT').CSN1
         ST        R5,CSAVE26
         LH        R5,CLEN
         CSNAP     CONSTANT,CLIST,ZR5+5   SNAP THE C-LIST ENTRY
         LH        R5,ZRS
         CSNAP     COLCON,(RS),ZR5+12       SNAP THE CONVERTED STACK
         L         R5,CSAVE26
.CSN1    ANOP
         BR        R14
C1STLOOK MVC       CONB(4),CONL        RESET THE SWITCH
         ST        R6,CKBEG            ESTABLISH START OF THIS LIST
         LR        R15,R6
         B         CNOTCOM8
CONL     L         R15,CKEND
         $FREE     R15                                             V1L5
         USING     CLIST,R6
CMOVECON MVC       CON4(*-*),CONSTANT    PUT CONST AT END OF LIST
         $FREE     R6                                              V1L5
         USING     CLIST,R15
CONLOOK1 CLC       CON4(*-*),CONSTANT  IS THIS IT
         $FREE     R15                                             V1L5
CDECERR2 EQU       *
CDECERR1 EQU       *
CONERR   B         CONEXIT2            B/NOP SWITCH
         MVI       CONERR+1,BRA        RESET ERROR SWITCH
         LM        R1,R6,CSAVE16       RESTORE THE REGISTERS
         BR        R3                  TAKE ERROR RETURN
         SPACE
         USING     STAK,R5
COLINT   SR        R2,R2
***   COLINT COLLECTS INTEGER CONSTANTS
         IC        R4,SOPND            GET DIGIT COUNT
         N         R4,KM2428           GET THE DIGIT COUNT
         AR        R0,R4               COUNT THE DIGITS
         L         R3,SOPND            GET THE 1ST GROUP OF DIGITS
         N         R3,KM0531
         CLI       SCODE,CCONS+2       ARE THERE MORE THAN 8 DIGITS
         BLR       R15
         BE        CGETC4              YES
         LA        R0,X'81'            INDICATE MORE THAN 16 DIGITS
CGETC4   IC        R4,SOPND+4          GET NEXT DIGIT COUNT
         N         R4,KM2428
         AR        R0,R4               COUNT THEM
         MVC       CHOLD4(4),SOPND+4
         NI        CHOLD4,X'07'
         SRL       R4,1
         M         R2,CPWRS10-4(R4)    FORM C*10**DIG
         LA        R4,64(R4,R4)        SHIFT R4 & BUMP FOR FRAC DIGITS
         AL        R3,CHOLD4           +C1
         BNLCR     R15                 CHECK FOR CARRY TO R2
         LA        R2,ZR2+1
         BR        R15
         SPACE
***  ROUTINE TO FLOAT AN INTEGER STORED IN R2-R3. RESULT IN FR0
CFLOATF0 STM       R2,R3,CDOUB         STORE INTEGER
         MVI       CDOUB,X'4E'         SET AN EXPONENT
         SDR       F0,F0               ZERO F0                     V1L4
         AD        F0,CDOUB            NORMALIZE                   V1L4
         BR        R15                 RETURN
         SPACE
***   ROUTINE TO CHECK FOR A VALID E OR D-TYPE EXPONENT
**      RETURN IS TO 0(R15) FOR NO EXPONENT
**                   4(R15) FOR EXPONENT. LOW BYTE OF R4 HOLDS EXPONENT
CHKEXP   CLI       SOPTR,PHI
         BNER      R15
CHKEXP1  CLI       SCODE,CNAME+1       CHECK FOR POSSIBLE EXPONENT
         BNER      R15                 NOT A CHANCE
         MVI       CEXPTYPE+1,NOP      ASSUME E-TYPE EXPONENT
         IF        (SOPND,EQ,C'E'),CHK1
         CLI       SOPND,C'D'
         BNER      R15                 NEITHER E NOR D
         MVI       CEXPTYPE+1,BRA      SET SW FOR D-TYPE EXPONENT
CHK1     MVI       CEXPSW+1,NOP        ASSUME POSITIVE EXPONENT
         IF        (SOPND+1,EQ,C' '),CHK3     TEST FOR SIGN
         TM        SOPND+1,X'F0'       TEST FOR DIGIT AFTER 'E'
         BNOR      R15                 NOT AN EXPONENT
         IC        R4,SOPND+1          GET THE DIGIT
         N         R4,KM2831
         IF        (SOPND+2,EQ,C' '),4(,R15)
         TM        SOPND+2,X'F0'       TEST FOR 2ND DIGIT
         BNOR      R15                 NO,LOOKS BAD
         MH        R4,CTEN             YES, A 2 DIGIT EXPONENT
         IC        R1,SOPND+2
         N         R1,KM2831
         AR        R4,R1               EXPONENT AS BINARY INT IN R4
         IF        (SOPND+3,EQ,C' '),4(,R15)  CHK FOR 2 DIGIT EXPONENT
         BR        R15                 NO,TAKE NO EXIT FOR RETURN
****   NOW CHECK FOR A '+' OR '-' AFTER 'E'
CHK3     LR        R1,R5               SAVE LINK IN CASE OF ERROR
         AH        R5,SLINK
         IF        (SOPTR,EQ,PLUS),CPOSEXP  VERIFY '+' IN EXPONENT
         IF        (SOPTR,NE,MINUS),COUT2   ERROR IF NOT '-'
         MVI       CEXPSW+1,BRA        SET SW FOR NEG EXPONENT
CPOSEXP  IF        (SCODE,ON,CCONS),CPOSEXP1  TEST FOR CONST NEXT
*        COME HERE IF NO CONST AFTER E+ OR E- OR D+ OR D-
*            OR NO + OR - AFTER E OR D
COUT2    LR        R5,R1               RESTORE R5
         BR        R15                 TAKE THE NO RETURN
CPOSEXP1 IF        (SOPND,LE,X'10'),CHK4   TEST FOR 1 OR 2 DIG EXPON
         $ERROR    (WARN,CN,2,SYMR5,INVAL),,SAVE  EXPON GT 2 DIGITSV1L5
CHK4     L         R4,SOPND            EXPONENT TO R4
         B         ZR15+4              TAKE THE YES RETURN
         $FREE     R5,RS                                           V1L5
         EJECT
CREAD    IF        (CIHGACRD,ON),CREAD10  IS THERE A CARD IN BUFFER
         STM       0,15,XREADS          NO SO SAVE REGS
         MVC       XCARD1+2(5),KBL6    BLANK OUT ISN FIELD
         IF        (CSUBRDS,ON),CSUBRRD   FROM SYSIN OR LIBRARY?
*        READ A CARD FROM THE STANDARD INPUT UNIT
CSPECRD  L         R1,XAFIOCS     INPUT ROUTINE ADDR
         LA        R2,XINPDSRN    ADDR OF DSRN
         BALR      R0,R1          OFF TO READ
         DC        X'00'
         DC        X'F0'
         MVC       XCARD(80),ZR2  SAVE THE CARD IMAGE
         BAL       R9,CPRINT           INITIALIZE FIOCS FOR OUTPUT
CREAD11  LM        0,15,XREADS         GET BACK OUR REGS
CREAD10  LA        R1,XCARD            ADDR OF CARD IMAGE
         LA        R2,80-1             SET LENGHT AS WELL
         CLC       XCARD(L'XCONTROL),XCONTROL    CONTROL CARD?
         AIF       ('&CONTROL'(1,1) EQ '&CONTROL').CRD115          V1L4
         B         CTRLPTCH            IF C$ OPTION THEN GEN PATCH V1L4
         AGO       .CRD116                                         V1L4
.CRD115  ANOP                                                      V1L4
         BE        CREAD20             YES
.CRD116  ANOP                                                      V1L4
COBJECT  EQU       *                                               V1L4
         IF        (XCARD,NE,X'02'),CREAD12      OBJECT DECK CARD?
         THEN      (CIHGACRD,OFF)      YES SO REST CARD SWT
         B         ZR14+12             BACK TO CALLER
CREAD12  IF        (CIHGACRD,ON),CREAD30     ARE WE RE-READING?
         MVC       CFFCHAR(1),XCARD+72   NO SO SAVE COL 73
         OI        XCARD+72,X'FF'      AND SET END-OF-CARD TERMINATOR
CREAD30  THEN      (CIHGACRD,OFF)        RESET CARD SWT
         IF        (XCARD,EQ,C'C'),ZR14+16       COMMENTS CARD?
*        IS IT A THE START OF A NEW STATEMENT OR A CONTINUATION CARD
         IFANY     (XCARD+5,EQ,C' '),(XCARD+5,EQ,C'0'),CISNSTOR
         B         ZR14+4                RETURN TO CALLER
CREAD20  THEN      (CIHGACRD,OFF)        RESET CARD SWT
         BR        R14                   RETURN TO CALLER
CISNSTOR LH        R0,XISN             GET ISN FOR SOURCE LISTING
         A         R0,KF1              IT'S ONE LESS RIGHT NOW
         CVD       R0,CISNCON          CONVERT AND PLACE IN
         MVC       XCARD1+2(5),CISNMASK          PRINT LINE.
         ED        XCARD1+1(6),CISNCON+5
         B         ZR14+8               RETURN TO CALLER
CISNMASK EQU       XEDMASK+4
         AIF       ('&LIBRARY' EQ 'NO').CLN2
CSUBRRD  DC        0H'0'
         CLINK1    JSUBRRD             READ A CARD FROM LIBRARY
         B         CREAD11             RETURN TO PROCESS IT
         AGO       .CLN333
.CLN2    ANOP
CSUBRRD  NOPR      0
         NOPR      0
         NOPR      0
         B         CREAD11
.CLN333  ANOP
*        CALL FIOCS TO INITIALIZE IT FOR OUTPUT
CPRINT   LA        R2,XOUTDSRN
         L         R1,XAFIOCS
         BALR      R0,R1
         DC        X'00'
         DC        X'FF'
         ST        R2,XBUFFER          SAVE ADDRESS OF BUFFER
         BR        R9
COPSTOP  CLC       CBTCHEND,XCARD+L'XCONTROL
COPJOB   CLC       CNEWJOB,XCARD+L'XCONTROL
COPENTRY CLC       CDATA,XCARD+L'XCONTROL
         EJECT
* STORAGE
         SPACE
CANXTMP  DC        D'0'                POINTER FOR TEMPORARIES
CDOUB1   DC        D'0'                WORK
CONSTANT EQU       CDOUB1              THE CONST MAY BE GOT HERE
CDOUB    DC        D'0'                WORK
CISNCON  EQU       CDOUB
CONDOUB  DC        D'0'                TO BE USED BY SETSTACK ONLY
CHOLD4   EQU       CDOUB
CBAR11   DS        F
CPRG     DS        F
CSYMBASE DS        F
CFBEG    DS        F                   =START OF FUNCTION LIST
CFEND    DS        F                   =END OF FUNCTION LIST
CKBEG    DS        F                   =START OF K LIST
CKEND    DS        F                   =END OF K LIST
CSBEG    DS        F                   =START OF S LIST
CSEND    DS        F                   =END OF S LIST
CVBEG    DS        F                   =START OF V LIST
CVEND    DS        F                   =END OF V LIST
CHBEG    DS        F                   =A(START OF H LIST)
CHEND    DS        F                   =A(END OF H LIST)
CLBEG    DS        F                   =A(START OF L LIST)
CLEND    DS        F                   =A(END OF L LIST)
CGVBEG   DS        F                   =A(START OF GV LIST)
CGVEND   DS        F                   =A(END OF GV LIST)
CBADDR   DS        F
CURSTNO  DC        F'0'
CENTRYPD DS        F                   POINTS TO LAST DATA STATEMENT
CSTNOLK  DC        F'0'
CSRT1    DC        F'0'
CSRT2    DC        F'0'
CSRT3    DS        F
CHECKINT DC        F'0'
CREADS   DS        F
CDOBEG   DS        F                   BEGINNING OF DO STATEMENT LIST
CENDARAY DC        F'0'                END OF ARRAY AREA BEFORE ALIGN
CSAVE16  DS        F                   MUST PRECEDE CSAVE26
CSAVE26  DS        5F
CXD      DS        F                   USED BY WATLOAD TO LOAD PR'S ETC
CBUFF    DC        A(*-*)              BEGINNING OF BUFFER
CBUFFE   DC        A(*-*)              BEGINNING OF BUFFER
CPOINT   DC        A(*-*)              BEGINNING OF BUFFER
CDMPLIST DC        A(*-*)              POINTS TO END OF DUMPLIST CHAIN
         SPACE
XLINES   DC        F'58'               MAX NUMBER OF LINES PER PAGE
XLNCOUNT DC        F'0'
XPAGES   DC        F'100'              MAX NUMBER OF PAGES PER JOB
XPGCOUNT DC        F'0'
XTIME    DC        F'0'
CALINK   DC        F'0'                PTR TO LAST XLINK           V1L5
CLIFSW   DC        X'0'                LOGICAL IF SWITCH           V1L5
C$OPTSW  DC        X'0'                $OPTIONS CARD SWITCH        V1L5
XPUNCHSW DC        X'0'
COBJLET  DC     AL1(&OBJLET)           DO WE ACCEPT OBJECT DECKS ?
CLISTSW  DC        X'0'
CLIBLSW  DC        X'0'
CSUBRDS  DC        X'00'
CPAGSKIP DC        C'&PAGSKIP'
CNOCCRDS DC        AL1(&NOCCRDS)       SCAN'S CONT CARD COUNT      V1L4
CINVCHAR DC        C'&INVCHAR'         SCAN'S PRINT PLUG           V1L4
CERRLIST DC        F'0'                END OF ONERROR CHAIN        V1L5
CSAVENOX DC        A(*-*)              USED BY SCAN,FORMAT         V1L5
         SPACE
         AIF       (&NDVSD).D4                                     DVS2
MTIMER1  DC        F'55000'            MAX TIME LIMIT = 15 HRS     DVS1
         AGO       .D5                                             DVS2
.D4      ANOP                                                      DVS2
MTIMER1  DC        F'100000000'
.D5      ANOP                                                      DVS2
MTIMER2  DC        F'0'
MTIMER3  DC        F'0'
MVALUESS DC        F'0',F'&MEMFREE'
MVALUESG DC        2F'0'
MVALUESF DC        2F'0'
         SPACE
CTLNG    DS        H
CSN      DC        H'0'
CDONO    DC        H'0'
CMNPRGSW DC        X'00'               USED BY LANDR
CMOSWTCH DC        X'00'
CSRSWTCH DC        X'00'
CIFGOTSW DC        X'00'
CMODE    DC        X'00'
CDASWCH  DC        X'00'
CADSSW   DC        X'00'
CIMPL1   DS        42X
CIMPL2   DS        42X
CASF1    DS        X
CASF2    DS        X
CJOBCD   DC        X'00'
CDOEND   DC        X'00'
CSPEX    DC        X'0'
CIMPLIT  DC        X'00'               IMPLICIT STAT. OCC. SWITCH
CMODESWT DC        X'0'
CTYPESW  DC        X'00'
CISNCDSW DC        X'00'
CVRFMTSW DC        X'00'
CEXP1    DC        X'00'               WORK
CDIGCNT  DC        X'00'               WORK
CTYPE    DC        X'00'               WORK
CSIGN    DC        X'00'               WORK
CONLNGTH EQU       CSIGN               LENGTH-1 OF CONSTANT HERE
CFFCHAR  DS        X
CIHPALNE DS        X
ALIFSW   DC        X'00'               USED BY ARITH DURING LOGICAL IF
VA0SW    DC        X'00'               TO SUPPRESS VA-0 MSG        V1L5
DEBUGSW  DC        X'00'               MONITOR ENVIRONMENT SWITCH  V1L5
         EJECT
* CONSTANTS
         SPACE
CD10LE7  DC        D'10.'
         DC        D'1.E2'
         DC        D'1.E3'
         DC        D'1.E4'
         DC        D'1.E5'
         DC        D'1.E6'
         DC        D'1.E7'
         DC        D'1.E8'
         DC        D'1.E9'
         DC        D'1.E10'
         DC        D'1.E11'
         DC        D'1.E12'
         DC        D'1.E13'
         DC        D'1.E14'
         DC        D'1.E15'
C10POS   DC        D'1.E16'
         DC        D'1.E32'
         DC        D'1.E48'
         DC        D'1.E64'
         DC        0D'0',X'7F',7X'FF'         1.E80
         DC        0D'0',X'7F',7X'FF'      1.E96
C10LE7   EQU       CD10LE7
CPWRS10  DC        F'10'
         DC        F'100'
         DC        F'1000'
         DC        F'10000'
         DC        F'100000'
         DC        F'1000000'
         DC        F'10000000'
         DC        F'100000000'
CTEN     EQU       CPWRS10+2
CMAXUNIT DC        F'&NOUTILS'         INOUT USES THIS
BLANKCOM DC        0F'0',C'//    '     NAME OF BLANK COMMON BLOCK
BLANKNAM EQU       KBL6                REFERENCED BY LANDR
CNEWJOB  DC        C'&NEWJOB '
CDATA    DC        C'&DATA '
CBTCHEND DC        C'&BTCHEND '
         ORG       CNEWJOB+27
         EJECT
* LITERALS
         SPACE
KF5      DC        F'5'
KF16     DC        F'16'
KM0028   DC        X'FFFFFFF8'
KM0029   DC        X'FFFFFFFC'
KM0030   DC        X'FFFFFFFE'
KM2428   DC        X'000000F8'
         SPACE
***********************************************************************
**   PATCH AREA FOR WATFIV UPDATES OR INSTALLATION PATCHES           **
**                                                                   **
CPATCH   DC        100A(*-*)           COMMR'S PATCH AREA          V1L4
         ORG       CPATCH              GET LOCATION COUNTER        V1L2
         AIF       ('&CONTROL'(1,1) EQ '&CONTROL').NOPATCH         V1L4
CTRLPTCH BE        CREAD20                                         V1L4
         CLI       XCARD,C'&XCTRL2'    CHECK FOR '$'               V1L4
         BNE       COBJECT             CHECK NEXT TYPE             V1L4
         EX        R0,COPCJOB          CHECK FOR C$JOB             V1L4
         BE        CREAD20             SET CONTROL CARD RETRN-CODE V1L4
         EX        R0,COPCENTR         CHECK FOR C$ENTRY           V1L4
         BE        CREAD20             SET CONTROL CARD RETRN-CODE V1L4
         EX        R0,COPCSTOP         CHECK FOR C$STOP            V1L4
         BE        CREAD20             SET CONTROL CARD RETRN-CODE V1L4
         MVC       XHELPS(80),XCARD    SAVE THE CONTROL CARD       V1L5
         MVC       XCARD+1(79),XHELPS  SHIFT OVER ONE BYTE         V1L5
         MVI       XCARD,C'C'          FIX UP CARD FOR USER        V1L4
         B         CREAD20             BRANCH TO CONTROL CARD RTN  V1L4
COPCJOB  CLC       CNEWJOB,XCARD+1     CHECK FOR C$JOB             V1L4
COPCENTR CLC       CDATA,XCARD+1       CHECK FOR C$ENTRY           V1L4
COPCSTOP CLC       CBTCHEND,XCARD+1    CHECK FOR C$STOP            V1L4
.NOPATCH ANOP                                                      V1L4
CREADSWT DC        F'00'               SCAN/STRPROG                ST1
CPARNO   DC        X'00'               PAR. NO. -STRPROG/DODO/SCAN ST1
CWHPERF  DC        X'00'               WHILE-PERF SW.(SCAN/STRPROG)ST1
         ORG       ,                   RESET LOCATION COUNTER      V1L4
***********************************************************************
         LTORG
         SPACE
         $FREE     R1,R2,R3,R4,R5,R6,R7,R8,R9,R11,R13,R14,R15      V1L5
         TITLE     ' '
