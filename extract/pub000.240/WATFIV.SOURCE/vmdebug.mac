NAME   TITLE   'VMDEBUG PACKAGE'
         PRINT     OFF
         COPY      OPTIONS
&DECK    SETC      'VMDEBUG'
*        PRINT     OFF
         COPY      CDEFN
VMLIST   DSECT
VMVB1    DS        X
VMVB2    DS        X
VMNAME   DS        6X
VMDATA2  DS        4X
STARTA   DSECT
         COPY      STARTA
         ERRTABLE
         COPY      EXTRN
         PRINT     ON,GEN
         ENTRY     VMMONITR,VMERROR
VMLINELN EQU       129
VMDEBUGA CSECT
VMERROR  EQU       *
         USING     *,R8
         L         R5,76(,R13)         RESET R5 FROM CURR PROG SEG
         LR        R8,R15              SET BASE REG. FOR VMERROR
         LA        R10,VMMONITR        SET BASE REG. FOR VMMONITR
         CLI       VMSWT1,X'00'        EXEC OR DEBUG?
         BE        VMERROR1            EXEC SO AWAY
         CNOP      0,4
         BAL       R9,VMTERMMG         DEBUG ERROR
         DC        A(VMMSG9)
         B         VMDRIVE
VMERROR1 EQU       *
         STM       R1,R13,VMSAVE       SAVE REGS.
         MVI       XIORECUR,X'00'      TURN OFF I/O RECURSION SW.
         CNOP      0,4
         BAL       R9,VMTERMMG         EXEC ERROR
         DC        A(VMMSG8)
         LA        R15,VMMONITR        TEMP BASE REG.
         SR        R0,R0
         LH        R0,0(R11)           GIVE R0 THE ISN
         B         VMMONL3             PRINT WHERE STOPPED
         DROP      R8
VMMONITR EQU      *
         USING     *,R15
         STM       R1,R13,VMSAVE       SAVE REGS.
         MVI       XVMSWT,X'FF'        SIGNAL VMDEBUG IN CONTROL
         CLI       XVM1STSW,X'FF'      CHECK IF FIRST TIME
         BNE       VMMONL1             NO - SO GO TO MONITOR
         LR        R10,R15             YES - GO TO COMMAND PROCESSOR
         B         VMCOMAND
VMMONL1  LH        R0,0(R11)           GET CURRENT ISN
         CLI       VMATTNSW,X'01'      HAS THERE BEEN AN ATTN INT
         BE        VMMONL3             YES - STOP EXEC'N.
         C         R0,VMSTPLOC         HAVE WE REACHED 'STOP' LOC'N.?
         BE        VMMONL2             YES - GO AWAY
         C         R0,VMSTISN          ARE WE IN TRACE RANGE?
         BL        XPROFILE            NOT YET - GO BACK           V1L5
         C         R0,VMENISN          ARE WE PAST TRACE RANGE?
         BH        XPROFILE            YES - GO BACK               V1L5
         LR        R10,R15
         DROP      15
         USING     VMMONITR,R10
         LA        R5,VMDATA1          IN TRACE RANGE: PRINT 'ISN'
         STH       R0,VMDATA+2         AND BRANCH BACK TO OBJ. CODE
         LA        R2,VMFST2           R2--> FORMAT LIST
         BAL       R9,VMPRINT1         PRINT LINE #
         LM        R1,R13,VMSAVE       RESTORE REGISTERS
         B         XPROFILE            GO BACK                     V1L5
VMMONL2  EQU       *                   'STOP LOC' REACHED
         DROP      R10
         USING     VMMONITR,R15
         SR        R1,R1
         ST        R1,VMSTPLOC         ZERO STOP LOC'N.
         MVI       VMSTPSWT,X'00'      TURN OFF STOP SWITCH
VMMONL3  EQU       *                   STOPPING EXECUTION
         LR        R10,R15
         DROP      R15
         USING     VMMONITR,R10
         LA        R2,VMFST1           R2--> FORMAT LIST
         LA        R5,VMSTOP1          R5--> DUMMY DATA ENTRY
         ST        R0,VMSTPISN         ST CURR ISN IN DUMMY DATA ENTRY
         BAL       R9,VMPRINT1         PRINT A MESSAGE WHERE I STOPPED
         B         VMDRIVE
         EJECT
VMCOMAND EQU       *
*        THIS ROUTINE PROCESSES THE USER'S COMMANDS.
*        THE  COMMANDS ARE:
*        1.TRACE 'RANGE'
*        2. STOP 'ISN'
*        3. RUN
*        4. OFF   TURN OFF TRACE AND STOP'S
*        5. 'VARIABLE NAME'?   DISPLAY VALUE OF VARIABLE
*        6. 'VAR NAME'=VALUE  MODIFY A VALUE(S)
*        7. EXIT   TERMINATE JOB & RETURN TO SYSTEM
*        8. GOTO 'STMT. #'   START EXEC'N. AT SPECIFIED STMT.
*
         STAX      VMATTXIT            SET UP ATT'N EXIT
         MVI       XVM1STSW,X'00'      TURN OFF FIRST TIME SWITCH
         MVI       XVMDSWT,X'F0'       TURN OFF MONITORING
         SR        R1,R1
         ST        R1,VMSTPLOC         ZERO STOP LOC'N.
         ST        R1,VMSTISN          ZERO TRACE RANGE
         ST        R1,VMENISN
VMDRIVE  EQU       *
         MVI       VMATTNSW,X'00'      TURN OFF ATTN SW.
         MVI       VMSWT1,X'FF'        SET TO DEBUG
         L         R5,VMSAVE+16        R5--> START OF DATA AREA
         CNOP      0,4
VMATTRPT BAL       R9,VMTERMMG         OUTPUT 'CMD:'
         DC        A(VMMSG14)
         BAL       R9,VMTERMRD         READ A COMMAND
         CLI       VMATTNSW,X'01'      HAS ATTN BEEN ISSUED?
         BNE       VMOKAY              NO - PROCEED
         MVI       VMATTNSW,X'00'      TURN SWITCH OFF
         CNOP      0,4
         BAL       R9,VMTERMMG         PRINT 'COMMAND IGNORED'
         DC        A(VMMSG15)
         B         VMATTRPT            REPEAT THE READ
VMOKAY   BAL       R9,VMGET2SU         GET 2 SYNTACTIC UNITS
         DC        A(VMBUFFER)
         MVI       VMJSW,X'01'          TURN ON FIRST TIME SWITCH
         B         VMJUMPCD            USE JUMP TABLE TO GET
*                                      CORRECT COMMAND PROCESSOR
         EJECT
         DROP      R10
***   ATTENTION INTERRUPT EXIT   ****
VMATTXIT EQU       *
         USING     *,R15
         MVI       VMATTNSW,X'01'      TURN ON ATT'N SWITCH
         ST        R12,VMATSV12        SAVE R12
         L         R12,=V(XTART)       R12 BASE FOR STARTA
         MVI       XVMDSWT,X'00'       TURN ON MONITORING
         L         R12,VMATSV12        RESTORE R12
         BR        R14                 RET TO SYS. AND CONTINUE
         DROP      R15
         USING     VMMONITR,R10
         EJECT
*
*
*                  OUTPUT A MESSAGE TO THE TERMINAL
*
VMTERMMG EQU       *
         LA        R1,&TERM            GET TERMINAL UNIT NO.
          CNOP     0,4
         BAL       R14,XIOINIT         INITIALIZE TERMINAL OUTPUT
         DC        X'01',AL3(VMEND)
         DC        A(VMERR)
         DC        A(VMFMT2)
         L         R3,0(R9)            R3--> MESSAGE LENGTH
         MVC       VMFMT2+9(1),0(R3)   MSG. LEN. TO FORMAT LIST
         SR        R2,R2
         IC        R2,0(R3)            GIVE R2 THE LENGTH
         LA        R3,1(R3)            R3--> MESSAGE TEXT
         CNOP      0,4
         BAL       R14,XSUBSELT        WRITE MESSAGE TO TERMINAL
VMC1     DC        X'09',AL3(*-*)
         BAL       R14,XENDLIST        TERMINATE I/O LIST
         B         4(,R9)              RETURN
         EJECT
*
*        DISPLAY A VARIABLE ROUTINE
*        R5 POINTS TO THE DATA ITEM IN THE DATA AREA
*        IT CAN BE A SIMPLE VARIABLE,A STAR ROUTINE, OR
*        A POINTER TO THE VALUE (COMMON OR EQIVALENCED)
*        THE OUTPUT IS DONE BY SIMULATING A
*          PRINT100,A
*          WHERE '100 FORMAT' IS APPROPRIATE TO THE TYPE OF 'A'
*
VMPRINT  EQU       *
*        ENTRY IF I USE VMVB1 TO FIND THE FORMAT CODE
         USING     VMLIST,R5
         TM        VMVB1,CHARN         CHARACTER*N?
         BNO       VMAR2               NO - AWAY
*        GENERATE FORMAT FOR CHARACTER*N
         SR        R1,R1
         IC        R1,23(R5)           GET LENGTH IF SUBSCRIPTED
         TM        VMVB1,X'70'         IS IT SUBSCRIPTED?
         BC        5,VMAR3             YES - SO AWAY
         IC        R1,8(R5)            GET LENGTH IF SIMPLE
VMAR3    SR        R2,R2
         LA        R1,1(,R1)           R1=N+1
         STC       R1,VMFCHN+1         A(N+1)
         LA        R3,VMLINELN-1       (LINE LEN-1)/(N+1)
         DR        R2,R1
         LTR       R3,R3               FIELD COUNT ZERO?
         BP        VMAR4               NO - AWAY
         ST        R9,VMSCSAVE         SAVE R9
         CNOP      0,4                 (N+1)>(LINELEN-1)
         BAL       R9,VMTERMMG         LINE TRUNCATED
         DC        A(VMMSG16)
         L         R9,VMSCSAVE         RESTORE R9
         LA        R3,VMLINELN-1       GET FIELD LENGTH
         STC       R3,VMFCHN+1         STORE IN FORMAT LIST
         MVI       VMFCHN,X'01'        FIELD COUNT=1 ==> A(VMLINELN-1)
         B         VMAR2
VMAR4    STC       R3,VMFCHN           FIELD COUNT
VMAR2    IC        R1,VMVB1
         N         R1,KF15             GET VAR. TYPE
         SLL       R1,2                TIMES 4=INDEX INTO FORMAT TABLE
         L         R2,VMFMTADR(R1)     GET FORMAT
         ST        R2,VMFMTCOD         STORE IN FORMAT LIST
         LA        R2,VMFMTPTN         PTR TO FORMAT LIST
*        ENTRY IF R2 HAS ADDRESS OF THE FORMAT LIST
VMPRINT1 ST        R2,VMFORMAT         SAVE IN I/O LIST
         LA        R1,&TERM            UNIT # - TERMINAL
         CNOP      0,4
         BAL       R14,XIOINIT         INITIALIZE TERMINAL OUTPUT
         DC        X'01',AL3(VMEND)
         DC        A(VMERR)
VMFORMAT DC        A(*-*)
         BAL       R8,VMINOUT          PRINT VARIABLE CONTENTS
         BR        R9                  RETURN
         EJECT
         EJECT
*
*                  BAL  R9,VMTERMRD
*
*        READ A RECORD (120 CHARACTERS) FROM THE TERMINAL,
*        AND STORE THEM IN 'VMBUFFER'
*
VMTERMRD EQU       *
         LA        R1,&TERM            UNIT NO. FOR TERMINAL I/O
         CNOP      0,4
         BAL       R14,XIOINIT         INITIALIZE READ
         DC        X'00',AL3(VMEND)
         DC        A(VMERR)
         DC        A(VMFMT1)
         LA        R2,VMLINELN         LENGTH OF INPUT RECORD
         L         R3,=A(VMBUFFER)     PTR TO BUFFER
         CNOP      0,4
         BAL       R14,XSUBSELT        OFF TO READ BUFFER
         DC        X'09',AL3(*-*)
         BAL       R14,XENDLIST        TERMINATE I/O LIST
         L         R1,VMSTRLEN         GET LENGTH OF STRING FROM TERM.
         LA        R1,1(,R1)           ADD 1 TO LEN. TO LEAVE TRAILING
         ST        R1,VMSTRLEN         BLANK FOR FRIOSCAN QUIRK
         IC        R3,VMBUFEND         GET EOB MARK
         STC       R3,VMBUFFER(R1)     AND PUT AT END OF STRING
         BR        R9                  RETURN
         EJECT
*******  TERMINAL I/O ERROR  ***************
VMERR    EQU       *
         CNOP      0,4
         BAL       R9,VMTERMMG         I/O ERROR MESSAGE
         DC        A(VMMSG1)
         B         VMDRIVE
*******  END-OF-FILE ON TERMINAL READ - NOT ENCOUNTERED WITH TGET ***
VMEND    EQU       *
         CNOP      0,4
         BAL       R9,VMTERMMG         INSUFFICIENT DATA MSG.
         DC        A(VMMSG2)
         B         VMDRIVE
         EJECT
*
*        BAL  R8,VMCONVRT
*        CONVERT A NUMBER FROM EBCDIC TO THE PROPER INTERNAL
*        REPRESENTATION.
*        INPUTS:
*          -VALUE(S) IN EBCDIC IN VMBUFFER(NOT NECESSARILY AT START)
*          -R6 POINTS TO THE CONSTANT
*          -R5 POINTS TO THE DATA WHERE CONSTANT,STAR ROUTINE,ETC
*           IS TO BE STORED. IF CONSTANT IS REQUIRED BY VMDEBUG
*           R5 POINTS TO A PATTERN OF A TYPICAL DATA AREA ITEM, NAMELY,
*           VMVB1,C,E,L,NAME(DATA OR STAR ROUTINE OR PTR TO DATA)
*        ROUTINE USES  'XSUBSELT' I.E. ASSUME  OR SET UP AS A
*        SUBSCRIPTED ELEMENT UNLESS IT IS AN ARRAY,THE USE 'XARRAY'
VMCONVRT EQU       *
         ST        R6,VMWONDER
         SR        R3,R3
         IC        R3,VMSUNUM          FIND OUT WHICH SU
         LA        R1,VMSUL2-1
         IC        R1,0(R3,R1)         GET APPROPRIATE LENGTH
         STC       R1,VMLNGTH          FOR XIOINTCC
         CNOP      0,4
         BAL R14,XIOINTCC              INIT CORE-CORE I/O
VMLNGTH  DC        AL1(*-*),AL3(VMWONDER)  BUFF LEN AND PTR
         DC        X'40',AL3(VMEND)
         USING     VMLIST,R5
VMINOUT  IC        R1,VMVB1
         N         R1,KF15             GET VAR. TYPE
         TM        VMVB1,X'70'           IS IT DIMENSIONED?
         BC        5,VMDIM             YES SO AWAY WE GO
         L         R3,8(R5)            PTR TO DATA IF C OR E
         LA        R3,0(R3)            CLEAR HIGH-ORDER BYTE
         ST        R3,VMVB11
         TM        VMVB1,X'08'         CHARACTER?
         BO        VMAR11              YES - AWAY
         TM        VMVB2,X'C0'         C OR E
         BC        5,VMAR1             YES - AWAY
         LA        R3,8(,R5)           PTR TO DATA IF SIMPLE
         ST        R3,VMVB11
         B         VMAR1
VMAR11   SR        R2,R2
         IC        R2,8(R5)            GET N FOR CHAR*N
VMAR1    STC       R1,VMVB11
         CNOP      0,4
         BAL       R14,XSUBSELT        DO <TERM. READ×CC I/O>
VMVB11   DC        A(*-*)
         BAL       R14,XENDLIST        TERMINATE I/O LIST
         BR        R8                  RETURN
VMDIM    TM        VMVB1,CHARN         CHARACTER*N?
         BNO       VMDIM3              NO - AWAY
******   CHARACTER*N   ***********
         LA        R5,8(,R5)           PTR TO STAR ROUTINE
         ST        R5,VMVB14
         STC       R1,VMVB14
         CNOP      0,4
         BAL       R14,XCHARARR        DO CHARACTER ARRAY I/O
VMVB14   DC        A(*-*)
         B         VMDIM2
VMDIM3   LA        R5,8(,R5)           PTR TO STAR ROUTINE
         ST        R5,VMVB12
         STC       R1,VMVB12
         CNOP      0,4
         BAL       R14,XARRAY          DO ARRAY I/O
VMVB12   DC        A(*-*)
VMDIM2   BAL       R14,XENDLIST        TERMINATE I/O LIST
         BR        R8                  RETURN
         EJECT
*        BAL R9,VMSEARCH
*
*        ROUTINE TO SEARCH THE DATA AREA FOR A VARIABLE NAME
*        USE R5 TO POINT TO THE FIRST ELEMENT
*        USE LENGTH TO LINK TO NEXT ITEM
*        LAST LENGTH IS 00000
*        OUTPUT IS R5 POINTING TO THE CORRECT NAME
*        OR A MESSAGE SAYING THE VARIABLE WAS NOT FOUND
*
VMSEARCH EQU       *
         SR        R1,R1
         LA        R5,4(,R5)           SKIP STMT # LIST PTR
VMLOOP1  TM        VMVB2,X'3F'         LOOK AT LENGTH
         BZ        VMNOTIN             NAME  NOT FOUND
         TM        VMVB1,X'80'         TEST IF A VARIABLE
         BZ        VMINC               NO - SKIP COMPARE
         CLC       VMVAR(6),VMNAME     COMPARE VAR. NAME
         BER       R9                  FOUND IT
VMINC    IC        R1,1(,R5)           GET LINK (WORDS)
         N         R1,=X'0000003F'     GET RID OF C AND E
         SLL       R1,2                TIMES 4 = # OF BYTES
         AR        R5,R1               BUMP PTR
         B         VMLOOP1             LOOP UNTIL FOUND OR END
VMNOTIN  EQU       *
         CNOP      0,4
         BAL       R9,VMTERMMG         VAR. NOT FOUND
         DC        A(VMMSG3)
         B         VMDRIVE
         EJECT
*            BAL R9,VMGET2SU
*            DC A(ADDR WHERE SCAN STARTS)
*        GETS 2 SYNTACTIC UNITS AND RETURNS PTRS. VMSU(1×2),
*        LENGTHS VMSUL(1×2), AND TYPE CODES VMSUCOD(1×2)
VMGET2SU EQU       *
         STM       R1,R8,VMSCSAVE
*    INITIALIZE FOR SCAN LOOP
         LA        R3,2                INITIALIZE COUNTER
         LA        R2,VMTABLE          ADDR OF SCAN TABLE
         STC       R2,VMSCINST+3       LOBYTE OF ADDR TO DISPL FIELD
         STC       R2,VMINVCHR+3          "    "   "   "   "     "
         L         R1,0(,R9)           GET ADDR FOR SCAN
         LA        R5,VMBUFEND         ADDR OF END OF BUFFER
         LA        R4,1                INCREMENT FOR BXLE
***    SCAN TO FIRST NON-BLANK
VMNONBLK MVI       VMSCINST+1,X'01'    SET UP MASK FOR TM
         MVI       VM1CHRSW,X'00'      TURN OFF SINGLE CHAR SW
         LA        R6,VMGOTNB          R6 HAS EXIT ADDR FOR SCAN LOOP
         B         VMSCLOOP            OFF TO SCAN LOOP
***    GOT NON-BLANK
VMGOTNB  EQU       *
***   DETERMINE WHAT TYPE OF CHAR. STOPPED THE PREVIOUS SCAN
***   AND BRANCH ACCORDINGLY
VMCHKTYP EQU       *
         CLI       VM1CHRSW,X'01'      IF LAST SU WAS 1 CHAR
         BE        VMNONBLK            THEN SCAN TO NON-BLANK
         SR        R7,R7
         IC        R7,VMSCINST+3       GIVE R7 ADDR OF CURRENT
         LA        R7,0(R7,R2)         CODE IN VMTABLE
         MVC       VMSUCODE(1),0(R7)   STORE SU CODE AWAY
         CLI       0(R7),X'08'
         BE        VMSUEOB             GOT END OF BUFFER MARK
         BH        VMSU1CHR            GOT 1 CHAR. SU   ()=?
         CLI       0(R7),X'02'
         BH        VMLETTER            GOT A LETTER
         BE        VMNUMBER            GOT A NUMBER
         BL        VMNONBLK            GOT A BLANK
***    GOT A LETTER - SCAN TO FIRST NON-LETTER,NON-NUMBER
VMLETTER EQU       *
         MVI       VMSCINST+1,X'06'    SET UP MASK FOR TM
         LA        R6,VMGOTNLN
         ST        R1,VMSUSTRT         SAVE ADDR OF SU START
         LA        R1,1(,R1)
         B         VMSCLOOP
***    GOT NON-(LETTER,NUMBER)
VMGOTNLN EQU       *
***    GET LENGTH OF SU (FOR GROUP OF #'S OR ALPHANUMERIC STRING)
VMLPTR   L         R7,VMSUSTRT
         LR        R6,R1
         SR        R6,R7
         STC       R6,VMLTEMP          STORE LENGTH OF SU TEMP'LY
***    STORE LENGTH ,POINTER AND CODE
VMSTLPTC L         R7,VMSUSTRT         GET POINTER
         LR        R8,R3               GET COUNT
         SLL       R8,2                TIMES 4 FOR OFFSET
         LA        R6,VMSU2-4
         ST        R7,0(R8,R6)         ST PTR IN VMSU(1×2) DEP. ON CTR
         IC        R7,VMLTEMP          GET LENGTH
         LA        R6,VMSUL2-1
         STC       R7,0(R3,R6)         ST LEN IN VMSUL(1×2) DEP. ON CTR
         IC        R7,VMSUCODE         GET CODE
         LA        R6,VMSUCOD2-1
         STC       R7,0(R3,R6)         ST CODE IN VMSUCOD(1×2)
         BCT       R3,VMCHKTYP         IF COUNT NOT ZERO, GET SU2
***   GOT 2 SU'S - CLEANUP & GO HOME
VMSCFIN  ST        R1,VMSCSTRT         SAVE PTR WHERE SCAN LEFT OFF
         LM        R1,R8,VMSCSAVE
         B         4(R9)
***   GOT A NUMBER - SCAN TO FIRST NON-(NUMBER,COMMA,BLANK)
VMNUMBER MVI       VMTABLE+107,X'01'   CHANGE COMMA ENTRY
         MVI       VMSCINST+1,X'03'    SET UP MASK FOR TM
         LA        R6,VMNONNCB
         ST        R1,VMSUSTRT
         LA        R1,1(,R1)
         B         VMSCLOOP
***    GOT NON-(NUMBER,COMMA,BLANK)
VMNONNCB MVI       VMTABLE+107,X'F0'   RESET COMMA ENTRY
         B         VMLPTR
***    GOT SINGLE CHAR. SU      ()=?
VMSU1CHR ST        R1,VMSUSTRT         PTR TO SU
         C         R3,=F'1'            IS IT SU2?
         BE        VMSKIPIT            YES - OK
         CLI       0(R1),C'?'          SU1 - CHECK IF '?'
         BNE       VMCHKEQU
         MVC       VMSUCOD1(1),VMSUCODE
         MVI       VMSUCOD2,X'08'      SET SU2 TO EOB MARK
         B         VMSCFIN             CLEANUP & RETURN
VMCHKEQU CLI       0(R1),C'='          SU1 - CHECK IF '='
         BNE       VMSKIPIT
*   FIRST SU AN '='
         ST        R1,VMSU1
         MVI       VMSUL1,X'01'
         MVC       VMSUCOD1(1),VMSUCODE
         LA        R1,1(,R1)
         ST        R1,VMSU2            SET VMSU2 TO PT. 1 PAST '='
         L         R6,VMSTRLEN         GET STRING LENGTH
         LA        R6,VMBUFFER(R6)     R6<-- ADDR OF INSERTED EOB MARK
         SR        R6,R1
         STC       R6,VMSUL2           GIVE LENGTH TO EOB MARK
         MVI       VMSUCOD2,X'02'      SAY IT'S TYPE #'S
         B         VMSCFIN             CLEANUP & RETURN
VMSKIPIT LA        R1,1(,R1)
         MVI       VMLTEMP,X'01'
         MVI       VM1CHRSW,X'01'      TURN ON 1 CHAR SW
         B         VMSTLPTC
***    GOT END OF BUFFER MARK
VMSUEOB  C         R3,=F'1'            IS IT SU2?
         BH        VMSUEOB1            SU1 - SO MOVE 2 BYTES
         MVI       VMSUCOD2,X'08'      SU2 - MOVE 1 BYTE
         B         VMSCFIN
VMSUEOB1 MVC       VMSUCOD2(2),=X'0808'
         B         VMSCFIN
***   SCAN LOOP - USED FOR THE THREE DIFFERENT SCANS
VMSCLOOP IC        R2,0(R1)            GET CHAR. FROM BUFFER
VMINVCHR TM        0(R2),X'F0'         CHECK FOR INVALID CHAR.
         BO        VMBADCHR            YES - GO AWAY
VMSCINST TM        0(R2),X'00'         PATTERN TM
         BCR       8,R6                BRANCH IF ZEROES
         BXLE      R1,R4,VMSCLOOP
*************THIS POINT SHOULD NEVER BE REACHED*****************
*************ALWAYS GET EOB MARK FIRST         *****************
VMBADCHR MVI       VMTABLE+107,X'F0'   RESET COMMA ENTRY JUST IN CASE
         LM        R1,R8,VMSCSAVE
         CNOP      0,4
         BAL       R9,VMTERMMG
         DC        A(VMMSG10)
         B         VMDRIVE
         EJECT
*           BAL R9,VMJUMPCD   OR   B VMJUMPCD
*        USE BRANCH LIST FOR FIRST PAIR OF SU'S IN A LINE
*         - THEREAFTER, RETURN TO CALLING ROUTINE WITH JUMP CODE
*           IN VMJCODE
VMJUMPCD EQU       *
         STM       R0,R4,VMSCSAVE
         LA        R3,2                INITIALIZE COUNTER
         LA        R4,VMSUCOD2-1
VMAGAIN  SR        R2,R2
         SR        R1,R1
         LA        R0,1
         IC        R1,0(R3,R4)         GET VMSUCOD(1×2) DEP ON CTR
VMLOOK   LA        R2,1(,R2)           COUNT BIT POSITIONS
         BXLE      R0,R0,VMLOOK        DOUBLE R0 & COMP. WITH R1 (CODE)
*                                      - GOES 2,4,8,...,128
         BCTR      R2,R0               DECREMENT R2 BY 1
         BCTR      R2,R0               AGAIN
         STC       R2,0(R3,R4)         ST POSN FOR INDEXING VMJUMP
         BCT       R3,VMAGAIN
         IC        R1,VMSUCOD1
         IC        R2,VMSUCOD2
         M         R0,=F'7'            MULTIPLY R1 BY 7
         AR        R1,R2               R1 NOW HAS OFFSET IN VMJUMP
         IC        R1,VMJUMP(R1)       R1 NOW HAS OFFSET INTO BR. LIST
         CLI       VMJSW,X'00'         CHECK IF FIRST TIME
         BE        VMJCDRET            NO - RETURN TO CALLER
         MVI       VMJSW,X'00'         YES - TURN OFF SW. FOR NEXT TIME
         LH        R1,VMBRTAB(R1)      GET OFFSET TO APPROP. ROUT.
         B         VMBADCMD(R1)        BRANCH TO IT
VMJCDRET STC       R1,VMJCODE          STORE JUMP CODE
         LM        R0,R4,VMSCSAVE      RESTORE REGS.
         BR        R9                  RETURN
VMBRTAB  DC        AL2(VMBADCMD-VMBADCMD)
         DC        AL2(VMBADCMD-VMBADCMD)
         DC        AL2(VMBADCMD-VMBADCMD)
         DC        AL2(VMTSG-VMBADCMD)
         DC        AL2(VMORE-VMBADCMD)
         DC        AL2(VMSUBS-VMBADCMD)
         DC        AL2(VMMODIFY-VMBADCMD)
         DC        AL2(VMDISPLY-VMBADCMD)
         DC        AL2(VMIGNORE-VMBADCMD)
         DC        AL2(VMBADCMD-VMBADCMD)
         DC        AL2(VMBADCMD-VMBADCMD)
***  INVALID COMMAND
         CNOP      0,4
VMBADCMD BAL       R9,VMTERMMG
         DC        A(VMMSG4)
         B         VMDRIVE
***   CHECK IF TRACE, STOP OR GOTO
VMTSG    CLI       VMSUL1,X'05'        CHECK LEN. OF ALPHA-NUM. STRING
         BH        VMBADCMD            TOO LONG - AWAY
         L         R1,VMSU1            PTR TO STRING
         BL        VMSTOPGO            LENGTH<5 - CHECK STOP,GO
         CLC       0(5,R1),=C'TRACE'   LENGTH=5 - CHECK TRACE
         BE        VMTRACE             TRACE - AWAY
         B         VMBADCMD            INVALID COMMAND
VMSTOPGO CLC       0(4,R1),=C'STOP'
         BE        VMSTOP
         CLC       0(4,R1),=C'GOTO'
         BE        VMGOTO
         B         VMBADCMD            INVALID COMMAND
***   CHECK IF OFF, RUN, OR EXIT
VMORE    CLI       VMSUL1,X'04'        CHECK LEN. OF ALPHA-NUM. STRING
         BH        VMBADCMD            TOO LONG - AWAY
         L         R1,VMSU1            PTR TO STRING
         BL        VMOFFRUN            LENGTH<4 - CHECK OFF,RUN
         CLC       0(4,R1),=C'EXIT'    LENGTH=4 - CHECK EXIT
         BE        VMEXIT              EXIT - AWAY
         B         VMBADCMD            INVALID COMMAND
VMOFFRUN CLC       0(3,R1),=C'OFF'
         BE        VMOFF
         CLC       0(3,R1),=C'RUN'
         BE        VMRUN
         B         VMBADCMD            INVALID COMMAND
***   SUBSCRIPTED VARIABLE
VMSUBS   EQU       *
         BAL       R8,VMVARNAM         FIND VAR'S. DATA ENTRY
         TM        VMVB1,X'70'         IS VAR. SUBSCRIPTED?
         BC        5,VMSUBS1           YES - OKAY, AWAY
         CNOP      0,4
         BAL       R9,VMTERMMG         VAR. NOT SUBSCRIPTED
         DC        A(VMMSG5)
         B         VMDRIVE
VMSUBS1  L         R1,VMSCSTRT         GET ADDR WHERE SCAN IS
         ST        R1,VMSCADDR         TO START & STORE IN ADCON
         BAL       R9,VMGET2SU         GET 2 MORE SU'S
VMSCADDR DC        A(*-*)
         CLI       VMSUCOD1,X'02'      CHECK IF #'S
         BNE       VMBADCMD            NO - INVALID COMMAND
         BAL       R9,VMJUMPCD         YES - GET JUMP TABLE CODE
         CLI       VMJCODE,X'04'       CHECK IF #'S)
         BNE       VMNOPREN            NO CLOSING PAREN. - AWAY
         L         R1,VMSU2            GIVE R1 ADDR OF )
VMCLOOP  BCTR      R1,R0               CHECK IF LAST NON-BLANK IN
         CLI       0(R1),X'40'         # STRING WAS A COMMA
         BE        VMCLOOP             - IF BLANK, KEEP LOOKING
         CLI       0(R1),X'6B'         IS NON-BLANK A COMMA?
         BNE       VMFINE              NO - GOOD, GO AWAY
         CNOP      0,4
         BAL       R9,VMTERMMG         INVALID SUBSCRIPT
         DC        A(VMMSG11)
         B         VMDRIVE
VMFINE   MVI       VMSUNUM,X'02'       INDICATE SU1 FOR VMCONVRT
         USING     VMLIST,R5
         L         R6,VMSU1            PTR TO SUBSCRIPTS
         IC        R1,VMVB1
         N         R1,=X'00000070'     GET # OF DIMENSIONS OF 'AA'
         SRL       R1,4
         ST        R1,VMDIMS           SAVE IT IN STAR ROUTINE
         SLL       R1,2                TIMES 4 FOR LENGTH
         STC       R1,VMLEN+3
         MVC       VMVSTARN+2(6),2(R5) SAVE NAME IN CASE OF AN ERROR
         ST        R5,VMSAVE5          SAVE ADDRESS OF 'AA'
         LA        R5,VMVSTAR-8        STAR ROUTINE TO READ SUBSCRIPTS
         BAL       R8,VMCONVRT         OFF TO CONVERT SUBSCRIPTS
         L         R5,VMSAVE5          GET BACK ADDRESS OF 'AA'
         CLI       VMDIMS+3,X'01'      HOW MANY SUBSCRIPTS IN 'AA'?
         BNE       VMMANY              MORE THAN ONE - SO GO AWAY
         TM        VMVB1,CHARN         CHARACTER*N?
         BO        VMMANY              YES - AWAY
         CNOP      0,4
         BAL       R14,8(R5)           ONE - SO GO GET ADDRESS OF AA(I)
         DC        X'0C',AL3(VMTEMP)
         B         VMSKIP              R3 HAS ADDRESS OF AA(I)
VMMANY   MVC       VMARGS+8(24),VMNOPS  PUT NOPR'S IN ARGUMENT LIST
         SR        R1,R1
         IC        R1,VMDIMS+3         GET # OF DIMENSIONS
         SR        R2,R2               ZERO INDEX FOR S.S. ADDR LIST
         LA        R3,VMARGS           PTR TO SUBSCR. ADDR LIST
         TM        VMVB1,CHARN         CHARACTER*N?
         BNO       VMMANY2             NO - AWAY
         LA        R4,KF1              DUMMY SUBSCR. ADDR.
         ST        R4,VMARGS           SAVE AS 1ST S.S. ADDR.
         MVI       VMARGS,X'0C'        DUMMY MODE BYTE
         LA        R2,4(,R2)           BUMP INDEX
VMMANY2  LA        R4,VMTEMP           ADDRESS OF FIRST SUBSCRIPT
         A         R4,=X'0C000000'     INSERT CODE FOR XAN
VMLOOP5  ST        R4,0(R3,R2)         SAVE IN ARGUMENT LIST
         LA        R2,4(,R2)           BUMP INDEX
         A         R4,=F'4'            ADDR OF NEXT SUBSCRIPT
         BCT       R1,VMLOOP5          LOOP FOR # OF DIMENSIONS
         ST        R5,VMSAVE5          SAVE ADDRESS OF 'AA'
         CNOP      0,4
         BAL       R14,8(R5)           TO * ROUT. FOR ADDR OF ELMT.
VMARGS   DC        A(*-*)              SUBSCRIPT ADDRESSES:
         DC        A(*-*)              8 WORDS SINCE THERE
         DC        A(*-*)              CAN BE 7 SUBSCIPTS
         DC        A(*-*)              AND A DUMMY S.S FOR
         DC        A(*-*)              CHARACTER*N ARRAY ELTS.
         DC        A(*-*)
         DC        A(*-*)              RETURNS R3-->AA(I,J,...)
         DC        A(*-*)
VMSKIP   DS        0H                                              V1L5
         L         R5,VMSAVE5          GET BACK ADDR OF 'AA'
         L         R1,VMSCSTRT    GET ADDR WHERE SCAN TO START     V1L5
         ST        R1,VMSCADD          & STORE IN ADCON
         BAL       R9,VMGET2SU         GET 2 MORE SU'S
VMSCADD  DC        A(*-*)
         BAL       R9,VMJUMPCD         GET CODE FROM JUMP TABLE
         CLI       VMJCODE,X'14'       IS IT '?EOB'?
         BE        VMSVDISP            YES - A DISPLAY
         CLI       VMJCODE,X'12'       IS IT '=#'?
         BE        VMSVMOD             YES - A MODIFY
         B         VMBADCMD            INVALID COMMAND
***    DISPLAY AN ELEMENT OF A SUBSCRIPTED VARIABLE
VMSVDISP ST        R3,VMSBOUT+8        PTR TO ARRAY ELEMENT AND
         MVC       VMSBOUT+2(6),VMNAME VAR. NAME TO DUMMY DATA ENTRY
         IC        R1,VMVB1
         N         R1,KF15             GET VAR. TYPE
         STC       R1,VMSBOUT          STORE IN DUMMY DATA ENTRY
         TM        VMVB1,CHARN         CHARACTER*N?
         BNO       VMSVD1              NO - AWAY
         MVC       VMSBOUT+8(1),23(R5)  GET N FOR CHAR*N
VMSVD1   LA        R5,VMSBOUT          R5--> DUMMY DATA ENTRY
         BAL       R9,VMPRINT          DISPLAY ARRAY ELEMENT
         B         VMDRIVE
***  MODIFY AN ELEMENT OF A SUBSCRIPTED VAR.
VMSVMOD  MVC       VMWONDER(4),VMSU2   PTR TO NEW VALUE
         MVC       VMMODLEN(1),VMSUL2  LENGTH OF NEW VALUE
         ST        R3,VMSBOUT+8        SAVE AWAY R3
         CNOP      0,4
         BAL       R14,XIOINTCC        INITIALIZE CORE-CORE I/O
VMMODLEN DC        AL1(*-*),AL3(VMWONDER)     LENGTH AND POINTER
         DC        X'40',AL3(VMEND)
         MVC       VMVB13(1),VMVB1
         L         R3,VMSBOUT+8        GET BACK R3
         TM        VMVB1,CHARN         CHARACTER*N?
         BNO       VMSVM1              NO - AWAY
         SR        R2,R2
         IC        R2,23(R5)           GET N FOR CHAR*N
         CNOP      0,4
VMSVM1   BAL       R14,XSUBSELT        OFF TO CONVERT NEW VALUE
VMVB13   DC        A(*-*)              AND REPLACE OLD VALUE.
         BAL       R14,XENDLIST        TERMINATE I/O LIST
         B         VMDRIVE
***   CLOSING PAREN MISSING
         CNOP      0,4
VMNOPREN BAL       R9,VMTERMMG
         DC        A(VMMSG7)
         B         VMDRIVE
***   MODIFY A VARIABLE    -   SIMPLE OR ARRAY
VMMODIFY BAL       R8,VMVARNAM
         L         R6,VMSCSTRT
         L         R1,VMSTRLEN         GET STRING LENGTH
         LA        R1,VMBUFFER(R1)     R1<-- ADDR OF INSERTED EOB MARK
         SR        R1,R6
         STC       R1,VMSUL1           GIVE LENGTH TO EOB
         MVI       VMSUNUM,X'02'       TELL VMCONVRT, IT'S SU1
         BAL       R8,VMCONVRT         GO OFF TO CONVERT NEW VALUE
         B         VMDRIVE
***   DISPLAY A VARIABLE - SIMPLE OR ARRAY
VMDISPLY BAL       R8,VMVARNAM         FIND VAR. IN DATA AREA
         BAL       R9,VMPRINT          DISPLAY VAR. CONTENTS
***   BLANK LINE - IGNORE IT
VMIGNORE B         VMDRIVE             ALSO THE RETURN OF VMDISPLY
***  MOVE VAR. NAME TO VMVAR & FIND IT'S ENTRY IN THE DATA AREA
VMVARNAM CLI       VMSUL1,X'06'        IS VAR. NAME LONGER THAN 6
         BH        VMBADVAR            YES - INVALID
         L         R6,VMSU1            PTR TO VAR. NAME
         SR        R1,R1
         IC        R1,VMSUL1           LENGTH OF VAR. NAME
         BCTR      R1,R0               SUBTRACT 1 FROM LENGTH
         MVC       VMVAR(6),=C'      ' CLEAR VMVAR
         EX        R1,VMMOVE1          MOVE NAME TO VMVAR
         BAL       R9,VMSEARCH         FIND ENTRY IN DATA AREA
         BR        R8                  RETURN
         CNOP      0,4
VMBADVAR BAL       R9,VMTERMMG         INVALID VAR. NAME
         DC        A(VMMSG6)
         B         VMDRIVE
VMMOVE1  MVC       VMVAR(*-*),0(R6)
***  FIND ADDR OF STATEMENT IN OBJ. CODE LABELLED BY GIVEN STMT.
***      NO., THEN BRANCH TO IT
VMGOTO   EQU       *
         L         R6,VMSU2            PTR. TO STMT #
         MVI       VMSUNUM,X'01'       INDICATE SU2 FOR VMCONVRT
         LA        R5,VMDATA1          R5-->DUMMY DATA ENTRY
         BAL       R8,VMCONVRT         CONVERT STMT. #
         L         R5,VMSAVE+16        GET ADDR OF START OF DATA AREA
         L         R1,0(R5)            R1 GETS ADR OF FIRST ST # ENTRY
VMSNLOOP CLI       0(R1),X'FF'         TEST IF END REACHED
         BE        VMNOTFND            END REACHED - NOT FOUND
         CLC       VMDATA+1(3),1(R1)   HAVE WE FOUND IT
         BE        VMGOTSTN            YES
         LA        R1,8(,R1)           BUMP R1 TO PT. AT NEXT ENTRY
         B         VMSNLOOP            TRY AGAIN
VMGOTSTN EQU       *
         TM        0(R1),X'04'         IS THE STMT EXECUTABLE
         BZ        VMNONEX             NO -PRINT ERROR MSG
         L         R14,4(,R1)          GET ADDR. OF STMT. IN OBJ. CODE
         MVI       VMSWT1,X'00'        SET TO EXEC
         CLI       VMSTPSWT,X'00'      IS THERE A STOP LOC'N?
         BNE       VMGOTO2             YES - SKIP
         CLI       VMTRCSWT,X'00'      IS TRACING ON?
         BNE       VMGOTO2             YES - SKIP
         MVI       XVMDSWT,X'F0'       TURN OFF MONITORING
VMGOTO2  LM        R1,R13,VMSAVE       RESTORE REG'S.
         BR        R14                 START EXEC AT DESIRED PT.
         CNOP      0,4
VMNOTFND BAL       R9,VMTERMMG         STMT. # NOT FOUND
         DC        A(VMMSG12)
         B         VMDRIVE
         CNOP      0,4
VMNONEX  BAL       R9,VMTERMMG         STMT. # NOT EXECUTABLE
         DC        A(VMMSG13)
         B         VMDRIVE
*
*        STOP 'N'   DECODER
*
VMSTOP   EQU       *
         L         R6,VMSU2            PTR TO ISN
         MVI       VMSUNUM,X'01'       SU2
         LA        R5,VMSTOP1          PTR TO DATA ITEM
         BAL       R8,VMCONVRT         CONVERT ISN
         L         R6,VMSTPISN         GET ISN FROM DUMMY DATA ITEM
         ST        R6,VMSTPLOC         STORE STOP LOCATION (ISN)
         MVI       VMSTPSWT,X'01'      TURN ON STOP LOCN. SWITCH
         MVI       XVMDSWT,X'00'       TURN ON MONITORING
         B         VMDRIVE
*
*        RUN DECODER
*
VMRUN    EQU       *
         MVI       VMSWT1,X'00'        SET TO EXEC
         CLI       VMSTPSWT,X'00'      IS THERE A STOP LOC'N?
         BNE       VMRUN2              YES - AWAY
         CLI       VMTRCSWT,X'00'      IS TRACING ON?
         BNE       VMRUN2              YES - AWAY
         MVI       XVMDSWT,X'F0'       TURN OFF MONITORING
         LM        R1,R13,VMSAVE       RESTORE REGISTERS           V1L5
         B         XPROFILE            RETURN                      V1L5
VMRUN2   DS        0H                                              V1L5
         LM        R1,R13,VMSAVE       RESTORE REGISTERS           V1L5
         S         R11,KF2
         BR        R11                 RETURN TO WATFIV CODE
         EJECT
*
*
*        TRACE 'RANGE'   DECODER
*
VMTRACE  EQU       *
         L         R6,VMSU2            PTR TO ISN'S
         MVI       VMSUNUM,X'01'       SU2
         LA        R5,VMISN1           PTR TODATA ITEM
         BAL       R8,VMCONVRT         CONVERT ISN-RANGE
         MVI       VMTRCSWT,X'01'      TURN ON TRACING SWITCH
         MVI       XVMDSWT,X'00'       TURN ON MONITORING
         B         VMDRIVE
         EJECT
*
*        OFF PROCESSOR
*
VMOFF    EQU       *
         SR        R0,R0
         ST        R0,VMSTISN          ZERO TRACE RANGE
         ST        R0,VMENISN
         MVI       VMTRCSWT,X'00'      TURN OFF TRACING SWITCH
         B         VMDRIVE
VMEXIT   EQU       *
         B         XSTOP
         EJECT
VMPATCH  DC        50F'0'
VMBUFFER DC        CL(VMLINELN)' ',X'FF'
         ORG       *-1
VMBUFEND EQU       *
         ORG
*
***ERROR MESSAGES***
*
VMMSG1   DC        AL1(VMMSG2-VMMSG1-1)
         DC        C' I/O ERROR --- RE-ENTER'
VMMSG2   DC        AL1(VMMSG3-VMMSG2-1)
         DC        C' INSUFFICIENT DATA'
VMMSG3   DC        AL1(VMMSG4-VMMSG3-1)
         DC        C' VARIABLE NOT FOUND- PLEASE RE-ENTER'
VMMSG4   DC        AL1(VMMSG5-VMMSG4-1)
         DC        C' INVALID COMMAND'
VMMSG5   DC        AL1(VMMSG6-VMMSG5-1)
         DC        C' VARIABLE NOT SUBSCRIPTED'
VMMSG6   DC        AL1(VMMSG7-VMMSG6-1)
         DC        C' VARIABLE NAME INVALID --- RE-ENTER'
VMMSG7   DC        AL1(VMMSG8-VMMSG7-1)
         DC        C' SEARCHING FOR CLOSING PAREN, RE-ENTER'
VMMSG8   DC        AL1(VMMSG9-VMMSG8-1)
         DC        C' EXECUTION TIME ERROR. ENTER CORRECTION OR EXIT'
VMMSG9   DC        AL1(VMMSG10-VMMSG9-1)
         DC        C' DEBUG ERROR. RE-ENTER'
VMMSG10  DC        AL1(VMMSG11-VMMSG10-1)
         DC        C' INVALID CHAR. - POSSIBLE I/O ERROR - RE-ENTER'
VMMSG11  DC        AL1(VMMSG12-VMMSG11-1)
         DC        C' INVALID SUBSCRIPT'
VMMSG12  DC        AL1(VMMSG13-VMMSG12-1)
         DC        C' STATEMENT NUMBER NOT FOUND --- RE-ENTER'
VMMSG13  DC        AL1(VMMSG14-VMMSG13-1)
         DC        C' ATTEMPT TO BRANCH TO NON-EXECUTABLE STMT.'
VMMSG14  DC        AL1(VMMSG15-VMMSG14-1)
         DC        C'CMD:'
VMMSG15  DC        AL1(VMMSG16-VMMSG15-1)
         DC        C' COMMAND IGNORED'
VMMSG16  DC        AL1(VMMSG17-VMMSG16-1)
         DC        C' CHARACTER VARIABLE TOO LONG FOR LINE--TRUNCATED'
VMMSG17  EQU       *
* FORMAT FOR INPUT FROM THE TERMINAL
*    FORMAT(A(VMLINELN))
         DC        0F'0'
VMFMT1   DC        X'01000004',X'01',AL1(VMLINELN),X'0028'
         DC        X'00080044'         FORMAT(A(VMLINELN))
*        OUTPUT FORMAT FOR MESSAGES
*        FORMAT(1X,A120)
         DC        0F'0'
VMFMT2   DC        X'01000004',X'00010030',X'01',AL1(VMLINELN),X'0028'
         DC        X'000C0044'
*
***FORMAT FOR STOP & TRACE MESSAGES***
*
VMFST1   DC        0F'0',X'01000004',X'00010030',X'000E0034'
         DC        C'STOPPED AT LINE '
         DC        X'01050020',X'00200044'
VMFST2   DC        0F'0',X'01000004',X'00010030',X'00030034'
         DC        C'LINE'
         DC        X'01060020',X'00140044'
*
***FORMAT FOR DATA OUTPUT******
*
         DC        0F'0'
VMFMTPTN DC        X'01000004',X'00010030',X'00000000',X'000C0044'
VMFMTCOD EQU       VMFMTPTN+8
VMFL1    DC        0F'0',X'1404002C'   (20L4)
VMFL4    DC        X'1404002C'         20L4
VMFI4    DC        X'080C0020'         8I12
VMFI2    DC        X'0F060020'         15I6
VMFR4    DC        X'060F0718'         6F15.7
VMFR8    DC        X'04181018'         4F24.16
VMFC8    DC        X'060F0718'         6F15.7
VMFC16   DC        X'04181018'         4D24.16
VMFCH1   DC        X'28020028'         40A2
VMFCHN   DC        X'00000028'         ((VMLINELN-1)/(N+1))A(N+1)
VMFMTADR EQU       VMFL1
*
***STAR ROUTINE FOR READING IN SUBSCRIPTS***
*
VMVSTARN DC        0F'0',X'9200',6C' '
         CNOP      0,4
VMVSTAR  BAL       R15,XATEST          CALL SUBSCRIPTING ROUTINE   VM1
         DC        A(VMTEMP)           ADDRESS OF VECTOR
VMLEN    DC        X'02',AL3(*-*)      LENGTH OF ARRAY
VMDIMS   DC        A(*-*)              # OF SUBSCRIPTS
VMTEMP   DC        7A(*-*)             SUBSCRIPTS ARE STORED HERE
VMNOPS   DC        6X'07000700'
*
*******  DUMMY DATA ITEMS FOR CONVERSION AND I/O ****
*
VMSTOP1  DC        0F'0',X'0200',6X'00',A(*-*)
VMSTPISN EQU       VMSTOP1+8
VMDATA1  DC        0F'0',X'0200',6X'00',A(*-*)
VMDATA   EQU       VMDATA1+8
VMUNIT1  DC        0F'0',X'0200',6X'00',A(*-*)
VMUNIT   EQU       VMUNIT1+8
VMISN1   DC        0F'0',X'9200',6X'00'
         CNOP      0,4
VMISNSTR BAL       R15,XATEST          CALL SUBSCRIPTING ROUTINE   VM1
         DC        A(VMSTISN)
         DC        X'02',AL3(8)
         DC        A(2)
VMSBOUT  DC        0F'0',X'00C0',6X'00',A(*-*)
*****************************************************
VMSTPLOC DC        A(*-*)              STOP LOCATION
VMSTISN  DC        A(*-*)              START OF TRACE RANGE
VMENISN  DC        A(*-*)              END OF TRACE RANGE
VMWONDER DC        A(*-*)
VMVAR    DC        CL7'      '
VMSWT1   DC        X'00'               EXEC/DEBUG MODE SWITCH
         ENTRY     VMATTNSW                                        V1L5
VMATTNSW DC        X'00'               ATTN INTERRUPT SWITCH
VMATSV12 DC        A(*-*)              SAVE R12 FOR ATT'N EXIT
         ENTRY     VMSTRLEN
VMTRCSWT DC        X'00'               TRACING ON?
VMSTPSWT DC        X'00'               STOP LOCN. IN EFFECT?
VMSAVE   DC        13A(*-*)
VMSAVE3  DC        A(*-*)
VMSAVE5  DC        A(*-*)
VMSTRLEN DC        A(*-*)              LENGTH OF STRING FROM TERMINAL
*******************************************************
****   DATA AREA FOR SCAN AND JUMP TABLE ROUTINES   ***
*******************************************************
VMSUSTRT DC        A(*-*)              START OF SU IN BUFFER
VMSU2    DC        A(*-*)              PTRS. TO SU'S IN BUFF
VMSU1    DC        A(*-*)              **DON'T CHANGE ORDER!
VMLTEMP  DC        AL1(*-*)            LENGTH OF SU
VMSUL2   DC        AL1(*-*)            LENGTHS OF SU'S
VMSUL1   DC        AL1(*-*)            **DON'T CHANGE ORDER!
VMSUCODE DC        AL1(*-*)            SU CODE FROM VMTABLE
VMSUCOD2 DC        AL1(*-*)            SU CODES
VMSUCOD1 DC        AL1(*-*)            **DON'T CHANGE ORDER!
VMSCSTRT DC        A(*-*)              START OF SCAN
VMJSW    DC        X'01'               1ST TIME SW - JUMP CODE ROUT.
VMJCODE  DC        AL1(*-*)            JUMP TABLE CODE
VMSUNUM  DC        AL1(*-*)            SU # INDICATOR
VM1CHRSW DC        AL1(*-*)            1 CHAR SWITCH
*
***  JUMP TABLE FOR SU PAIRS  (7 BY 7)
*
VMJUMP   DC        X'00000200040000'   #'S
         DC        X'0600080A000C0E'   ALPHANUMERIC STRING
         DC        X'000010',4X'00'    EOB MARK
         DC        7X'00'              (
         DC        7X'00'              )
         DC        X'12',6X'00'        =
         DC        X'000014',4X'00'    ?
*
***   SCAN TABLE - CLASSES OF CHAR'S. WITH CODES
*
VMTABLE  DC        64X'F0'
         DC        X'01'               BLANK
         DC        12X'F0'
         DC        X'10'               (
         DC        15X'F0'
         DC        X'20'               )
         DC        17X'F0'
         DC        X'80'               ?
         DC        14X'F0'
         DC        X'40'               =
         DC        66X'F0'
         DC        9X'04'              A - I
         DC        7X'F0'
         DC        9X'04'              J - R
         DC        8X'F0'
         DC        8X'04'              S - Z
         DC        6X'F0'
         DC        10X'02'             0 - 9
         DC        5X'F0'
         DC        X'08'               EOB MARK
*
VMSCSAVE DC        8A(*-*)
         LTORG
         END
