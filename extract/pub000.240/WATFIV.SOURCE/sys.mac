         TITLE     'JSYS     OPERATING SYSTEM DEPENDENT ROUTINES'
JSYS     CSECT
         SPACE     1
         $FREE     RP,R13                                          V1L5
         SPACE     1
         AIF       (&DVSD).NOSTAE                                  DVS2
***********************************************************************
*********           ROUTINE TO SET COMPILER STAE EXIT         *********
***********************************************************************
         SPACE     1                                               V1L5
***    THIS ROUTINE IS CALLED ONLY ONCE AT BATCH INITIALIZATION    V1L5
***    AND IS REISSSUED WHEN THE STAE RETRY IS ENTERED             V1L5
         USING     CSAVER,RC                                       V1L5
JMSTAE   CENT      JSAVE               SAVE ALL REGISTERS          V1L5
         STAE      SEXIT,CT            CREATE A STAE CONTROL BLOCK V1L5
         LTR       R15,R15             CHECK IF WE WERE SUCCESSFUL V1L5
         BZ        CRET                BRANCH IF SCB CREATED       V1L5
         L         R14,=A(MSTOP)       ELSE CLOSE UP SHOP          V1L5
         BR        R14                 AND RETURN TO SYSTEM        V1L5
         SPACE     1                                               V1L5
         $FREE     RP,R13                                          V1L5
         SPACE     3                                               V1L5
*******************************************************************V1L5
*********           COMPILER STAE EXIT ROUTINE            *********V1L5
*******************************************************************V1L5
         SPACE     1                                               V1L5
*****    THIS ROUTINE ONLY CHECKS FOR SVC 37 (EOV) ABENDS.        *****
*****    IF THE COMPLETION CODE INVOLVED AN EOV SVC AN ERROR      *****
*****    MESSAGE IS GIVEN AND NO DUMP IS PRODUCED.                *****
         SPACE     1                                               V1L5
SEXIT    EQU       *                   STAE EXIT RTN ENTRY POINT   V1L5
         LR        R9,R15              SAVE ENTRY ADDRESS          V1L5
         USING     SEXIT,9            INFORM ASSEMBLER             V1L5
         L         RX,=A(XTART)       RESET 12 IN CASE CLOBBERED   V1L5
         USING     START,RX            TELL ASSEMBLER              V1L5
         AIF       ('&TRACE' EQ 'OMIT').NOSTATR                    V1L5
         IF        (XISNTRAC,ON,X'40'),THEN,(DO,XTRACON)           V1L5
.NOSTATR ANOP                                                      V1L5
         LR        R5,R1               SAVE ADDR OF WORK AREA      V1L5
         LA        R4,12               RC 12-> GETMAIN UNSUCCESSFULV1L5
         SR        R4,R0               CHECK RETURN CODE IN R0     V1L5
         LTR       R4,R4               0 -> NO WORK AREA OBTAINED  V1L5
         BZ        STAERTN             TERMINATE IF NO WORK AREA   V1L5
         L         R1,4(,R1)           R1 = ABEND COMPLETION CODE  V1L5
         SLL       R1,8                COMP CODE IS SAVED          V1L5
         ST        R1,WKAREA           IN 1ST 3 BYTES OF WORK AREA V1L5
         OI        WKAREA+1,X'0F'      TO FOOL UNPACK INSTR        V1L5
         UNPK      COMPCODE(3),WKAREA(2)  NEED ZONED CHARS         V1L5
         L         R3,ATRANS           ADDRESSABILITY FOR TABLE    V1L5
         USING     ATRANS,R3           INFORM ASSEMBLER            V1L5
         TR        COMPCODE(3),ATRANS  MAKE ABEND CODE PRINTABLE   V1L5
         USING     ZR3,R3              DROP PREVIOUS R3            V1L5
         IF        (STAESW,ON,SABEND),STAERTN CLEANUP FAILED=ABEND V1L5
         LR        R1,R5              R1 -> A(WORK AREA)           V1L5
         LA        R0,SRETRY          R0 -> A(RETRY RTN)           V1L5
         LA        R15,4               R15 = 4 -> GO TO RETRY RTN  V1L5
         BR        R14                                             V1L5
STAERTN  DS        0H                                              V1L5
         SR        R15,R15            INDICATE ABNORMAL TERMINATIONV1L5
         BR        R14                                             V1L5
         SPACE     1                                               V1L5
SRETRY   DS        0H                                              V1L5
         LR        R9,R15              SET UP BASE REGISTER        V1L5
         USING     SRETRY,R9           INFORM ASSEMBLER            V1L5
         USING     START,RX            TELL ASSEMBLER              V1L5
         L         RX,=A(XTART)        R12 -> STARTA               V1L5
         L         R11,XIOSAVE+24      RESTORE PTR TO ISN          V1L5
         L         R13,XIOSAVE+32      RESTORE PTR TO SAVE AREA    V1L5
         FREEMAIN  R,LV=104,A=(1)      FREE WORK AREA              V1L5
         CLC       COMPCODE+1(2),=C'37'  CHECK FOR SVC 37 ABEND    V1L5
         BE        XSTAE              ISSUE ERROR IF YES           V1L5
         LA        R1,COMPCODE        ABEND CODE IN R1             V1L5
         $ERROR    (NOAC,CP,2,,HOL4R1)                             V1L5
         STAE      SEXIT,CT           REISSUE STAE                 V1L5
         OI        STAESW,SABEND       INDICATE STAE ENTERED       V1L5
         L         R14,=A(MSTOP)      END OF BATCH RTN             V1L5
         LA        R15,8              SET RETURN CODE              V1L5
         BR        R14                  RETURN TO CLEANUP RTN      V1L5
XSTAE    DS        0H                                              V1L5
         STAE      SEXIT,CT           REISSUE STAE                 V1L5
         SPIE      XRUPT,((1,7),(9,13),15)                         V1L5
         IF        (STAESW,ON,UNMSG),XSTAE1 ISSUE UN-M ONLY ONCE   V1L5
         OI        STAESW,UNMSG        INDICATE UN-M GIVEN         V1L5
         B         XCODE               ISSUE MSG                   V1L5
XSTAE1   DS        0H                                              V1L5
         NI        STAESW,X'FF'-UNMSG  TURN OFF UN-M FLAG          V1L5
         B         XSTOP               -> END OF JOB ACCOUNTING    V1L5
XCODE    DS        0H                                              V1L5
         LA        R1,COMPCODE         ABEND CODE FOR MSG          V1L5
         $ERROR    (NOAC,UN,M,,HOL4R1) DA SPACE EXCEEDED (EOV SVC) V1L5
         B         XTRACEBK            GIVE A TRACEBACK            V1L5
         DS        0F                                              V1L5
COMPCODE DC        CL4'   )'                                       V1L5
WKAREA   DS        F                                               V1L5
ATRANS   DC        A(TRANSHEX-C'0')                                V1L5
TRANSHEX DC        CL16'0123456789ABCDEF'                          V1L5
STAESW   DC        X'00'              SWITCH TO CHECK STAE LOOPING V1L5
SABEND   EQU       X'80'               INDICATES STAE EXIT ENTERED V1L5
UNMSG    EQU       X'40'               INDICATE UN-M MSG ISSUED    V1L5
         $FREE     R9                                              V1L5
.NOSTAE  ANOP                                                      DVS2
***********************************************************************
*********           ROUTINE TO SET COMPILER SPIE EXIT         *********
***********************************************************************
         SPACE     1
***    THIS ROUTINE IS CALLED ONLY ONCE AT BATCH INITIALIZATION
         USING     CSAVER,RC
JMSPIE   CENT      JSAVE
         AIF  (&NDVSD).JMSPIE1                                     DVS1
*                                                                  DOS2
*        ROUTINE TO SIMULATE O.S. PROGRAM CHECK INTERRUPT LINKAGE  DOS2
*                                                                  DOS2
         L     R1,PIE             GET NEW PROGRAM MASK             DOS2
         SPM   R1                 NO FIXED OFLOW, SIGNIFICANCE     DOS2
         STXIT PC,SPIENTRY,SPISVPSW DOS PC INTERRUPT LINKAGE       DOS2
         B     CRET               RETURN                           DOS2
         $FREE RP,R13                                              DVS1
SPIENTRY EQU   *                                                   DOS2
         BALR  R15,0              ESTABLISH ADRESSIBILITY          DOS2
         USING *,R15                                               DOS2
         L     R15,=A(SPIENTRY)   GET BASE FOR THIS ROUTINE        DOS2
         USING SPIENTRY,R15                                        DOS2
XRUPTSW  EQU       *+1                                             DOS2
         NOP       XRUPTBCK            BR IF RETURN FROM XRUPT     DOS2
BADENTRY EQU       *+1                                             DOS2
         NOP       SPIENT01            BR IF INTERRUPT IN XRUPT    DOS2
         OI        BADENTRY,X'F0'      SET SECOND ENTRY SW         DOS2
         MVC   PIEPSW,SPISVPSW    SAVE INTERRUPT OLD PSW           DOS2
         MVC   PIER14(8),SPISVR14 SAVE REGS 14-15                  DOS2
         MVC   PIER00(12),SPISVR00 SAVE REGS 0-2                   DOS2
         MVC       SPISVR14,=A(XRUPTOUT) LOAD XRUPT EXIT ADDR      DOS2
         MVC   SPISVR15,=A(XRUPT) LOAD WATFIV INTERRUPT ENTRY POINTDOS2
         MVC   SPISVR01,=A(PIE)   LOAD POINTER TO PIE              DOS2
         MVC   SPISVPSW+4(4),=A(XRUPT) PUT NEW ENTRY POINT IN PSW  DOS2
         SVC   17                 GO TO XRUPT (WATFIV) VIA SUPVR   DOS2
*                                                                  DOS2
*        INTERRUPT COMES HERE IF NORMAL RETURN FROM XRUPT          DOS2
*                                                                  DOS2
XRUPTBCK NI        XRUPTSW,X'0F'       RESET XRUPT RETURN SW       DOS2
         MVI   PIE,0              INDICATE THIS ROUTINE NOT IN USE DOS2
         MVC   SPISVR14(8),PIER14 RESTORE REGS 14-15 FROM PIE      DOS2
         MVC   SPISVR00(12),PIER00 RESTORE REGS 0-2 FROM PIE       DOS2
         MVC   SPISVPSW,PIEPSW    RESTORE INTERRUPT PSW FROM PIE   DOS2
         SVC   17                 BACK TO WATFIV VIA SUPVR         DOS2
*                                                                  DOS2
*        INTERRUPT COMES HERE IF IT OCCURRED IN XRUPT              DOS2
*                                                                  DOS2
SPIENT01 MVC       SPISVPSW+4,=A(XABORT) ADDR OF KILL RTN IN PSW   DOS2
         SVC   17                 TO KILL ROUTINE VIA SUPVR        DOS2
         EJECT                                                     DOS2
*                                                                  DOS2
*        XRUPT RETURNS HERE VIA REG 14                             DOS2
*                                                                  DOS2
         USING     *,R14                                           DOS2
XRUPTOUT L         R15,=A(SPIENTRY)    LOAD BASE REG               DOS2
         USING     SPIENTRY,R15                                    DOS2
         $FREE     R14                                             DVS1
         OI        XRUPTSW,X'F0'       SET XRUPT RETURN SW         DOS2
         DC        H'0'                CREATE PROGRAM INTERRUPT    DOS2
*                                                                  DOS2
*        CONTROL COMES HERE IF WATFIV IS TO BE ABORTED             DOS2
*                                                                  DOS2
XABORT   BALR      R15,0               LOAD BASE REG               DOS2
         USING *,R15                                               DOS2
         L     RX,=A(XTART)       GET WATFIV BASE                  DOS2
         L     R13,XSAVER+4       GET POINTER TO WATFIV SAVE AREA  DOS2
         LM    R14,R12,12(R13)    RESTORE REGS                     DOS2
         LA    R15,8              INDICATE FATAL ERROR             DOS2
         BR    R14                GO KILL WATFIV WITH DUMP         DOS2
         $FREE R15                                                 DVS1
         DS    0F                                                  DOS2
PIE      EQU   *                  PROGRAM INTERRUPTION ELEMENT (OS)DOS2
         DC    X'36'              NEW PROG MASK                    DOS2
         DC    AL3(0)             PICA ADDRESS                     DOS2
PIEPSW   DS    CL8                OLD PSW AT INTERRUPT             DOS2
PIER14   DS    1F                 REG 14 AT INTERRUPT              DOS2
PIER15   DS    1F                 REG 15 AT INTERRUPT              DOS2
PIER00   DS    1F                 REG 0 AT INTERRUPT               DOS2
PIER01   DS    1F                 REG 1 AT INTERRUPT               DOS2
PIER02   DS    1F                 REG 2 AT INTERRUPT               DOS2
SPISVPSW DS    1D                 PC INTERRUPT OLD PSW             DOS2
SPISVR00 DS    1F                 REG 0 AT INTERRUPT               DOS2
SPISVR01 DS    1F                 REG 1 AT INTERRUPT               DOS2
SPISVR02 DS    1F                 REG 2 AT INTERRUPT               DOS2
SPISVR03 DS    1F                 REG 3 AT INTERRUPT               DOS2
SPISVR04 DS    1F                 REG 4 AT INTERRUPT               DOS2
SPISVR05 DS    1F                 REG 5 AT INTERRUPT               DOS2
SPISVR06 DS    1F                 REG 6 AT INTERRUPT               DOS2
SPISVR07 DS    1F                 REG 7 AT INTERRUPT               DOS2
SPISVR08 DS    1F                 REG 8 AT INTERRUPT               DOS2
SPISVR09 DS    1F                 REG 9 AT INTERRUPT               DOS2
SPISVR10 DS    1F                 REG 10 AT INTERRUPT              DOS2
SPISVR11 DS    1F                 REG 11 AT INTERRUPT              DOS2
SPISVR12 DS    1F                 REG 12 AT INTERRUPT              DOS2
SPISVR13 DS    1F                 REG 13 AT INTERRUPT              DOS2
SPISVR14 DS    1F                 REG 14 AT INTERRUPT              DOS2
SPISVR15 DS    1F                 REG 15 AT INTERRUPT              DOS2
         AGO   .JMSPIE2                                            DOS2
.JMSPIE1 ANOP                                                      DOS2
         SPIE      XRUPT,((1,7),(9,13),15)
         B         CRET
         SPACE     1
         $FREE     RP,R13                                          V1L5
.JMSPIE2 ANOP                                                      DOS2
         SPACE     3
*******************************************************************
*********           COMPILER PROGRAM INTERRUPT MONITOR    *********
*******************************************************************
         SPACE
*****    THIS ROUTINE DOES NOT CHECK FOR IMPRECISE INTERRUPTS     *****
*****    THE WAY IT SHOULD TO SATISFY MODEL 91 USERS.             *****
*****    WE CANT MAKE EVERYBODY HAPPY.                            *****
         SPACE
         USING     ZPIE,1
         USING     XRUPT,15
XRUPT    L         RX,=A(XTART)       RESET 12 IN CASE CLOBBERED
         AIF       ('&TRACE' EQ 'OMIT').NOSPYTR
         IF        (XISNTRAC,ON,X'40'),THEN,(DO,XTRACON)
.NOSPYTR ANOP
         ST        R2,XRUPTS+8         MIGHT NEED IT LATER         V1L1
         IC        R2,ZPIECODE+1       WHAT CAUSED INTERRUPT ?
         N         R2,KM2831
         IF        (XEXECSW,ON),XRUPT5
         LA        R2,15(,R2)          BUMP AROUND EXECUTION TABLE
XRUPT5   IC        R2,XRUPTAB-1(R2)
         B         XRUPT0(R2)
         SPACE     1
XRUPTAB  DC        AL1(XRUPTCP-XRUPT0)    OPERATION                 1
         DC        AL1(XRUPTCP-XRUPT0)    PRIVILEGED OPERATION      2
         DC        AL1(XRUPTCP-XRUPT0)    EXECUTE                   3
         DC        AL1(XRUPTCP-XRUPT0)    PROTECTION                4
         DC        AL1(XRUPTADR-XRUPT0)   ADDRESSING                5
         DC        AL1(XRUPTSP-XRUPT0)    SPECIFICATION             6
         DC        AL1(XRUPTCP-XRUPT0)    DATA                      7
         DC        AL1(XRUPTFXO-XRUPT0)   FIXED-POINT OVERFLOW      8
         DC        AL1(XRUPTFXD-XRUPT0)   FIXED-POINT DIVIDE        9
         DC        AL1(XRUPTCP-XRUPT0)    DECIMAL OVERFLOW         10
         DC        AL1(XRUPTCP-XRUPT0)    DECIMAL DIVIDE           11
         DC        AL1(XRUPTEXO-XRUPT0)   EXPONENT OVERFLOW        12
         DC        AL1(XRUPTEXU-XRUPT0)   EXPONENT UNDERFLOW       13
         DC        AL1(XRUPTRET-XRUPT0)   SIGNIFICANCE             14
         DC        AL1(XRUPTFLD-XRUPT0)   FLOATING-POINT DIVIDE    15
         DC        AL1(XRUPTCP4-XRUPT0)   OPERATION (COMPILE TIME)  1
         DC        AL1(XRUPTCP4-XRUPT0)   PRIVILEGED OPERATION      2
         DC        AL1(XRUPTCP4-XRUPT0)   EXECUTE                   3
         DC        AL1(XRUPTCP4-XRUPT0)   PROTECTION                4
         DC        AL1(XRUPTCP4-XRUPT0)   ADDRESSING                5
         DC        AL1(XRUPTCP4-XRUPT0)   SPECIFICATION             6
         DC        AL1(XRUPTCP4-XRUPT0)   DATA                      7
         DC        AL1(XRUPTCP4-XRUPT0)   FIXED-POINT OVERFLOW      8
         DC        AL1(XRUPTRET-XRUPT0)   FIXED-POINT DIVIDE        9
         DC        AL1(XRUPTCP4-XRUPT0)   DECIMAL OVERFLOW         10
         DC        AL1(XRUPTCP4-XRUPT0)   DECIMAL DIVIDE           11
         DC        AL1(XRUPTCNO-XRUPT0)   EXPONENT OVERFLOW        12
         DC        AL1(XRUPTCNU-XRUPT0)   EXPONENT UNDERFLOW       13
         DC        AL1(XRUPTRET-XRUPT0)   SIGNIFICANCE             14
         DC        AL1(XRUPTCP4-XRUPT0)   FLOATING-POINT DIVIDE    15
         SPACE     1
XRUPT0   DC        0H'0'
XRUPTCP  DS        0H                                              V1L5
         B         XRUPTCP1                                        V1L5
         SPACE
XRUPTCP4 DS        0H                                              V1L5
         B         XRUPTCP2                                        V1L5
         SPACE
XRUPTFXO L         R2,XFXOFLOW         FIXED OVERFLOW (MASKED OFF IN
         BCT       R2,XRUPT1                          STANDARD WATFOR)
         $ERROR    (NOAC,KO,5),XRUPTFIN,SAVE                       V1L5
XRUPT1   ST        R2,XFXOFLOW
XRUPTRET BR        14
         SPACE
XRUPTFXD L         R2,XFXDVCNT         FIXED DIVIDE
         BCT       R2,XRUPTF1
         $ERROR    (NOAC,KO,1),XRUPTFIN,SAVE                       V1L5
XRUPTF1  ST        R2,XFXDVCNT
         MVI       XDVCHKSW+1,X'01'    TURN ON DIVIDE CHECK SWITCH
         BR        R14
         SPACE
XRUPTEXO L         R2,XEXOFLOW         EXPONENT OVERFLOW
         BCT       R2,XRUPT2
         CLC       ZPIEADDR(3),=AL3(FORMCONV)   CHECK IF WE        V1L5
         BL        XRUPOBJ1                     BOMBED IN          V1L5
         CLC       ZPIEADDR(3),=AL3(FORMCONE)   FORMCONV'S         V1L5
         BH        XRUPOBJ1                     REGION WHILE       V1L5
         L         R13,XIOSAVE+32      CONVERTING CONSTANT         V1L5
XRUPOBJ1 DS        0H                                              V1L5
         $ERROR    (NOAC,KO,3),XRUPTFIN,SAVE                       V1L5
         SPACE
XRUPTEXU L         R2,XEXUFLOW         EXPONENT UNDERFLOW
         BCT       R2,XRUPT3
         CLC       ZPIEADDR(3),=AL3(FORMCONV)   CHECK IF WE        V1L5
         BL        XRUPOBJ2                     BOMBED IN          V1L5
         CLC       ZPIEADDR(3),=AL3(FORMCONE)   FORMCONV'S         V1L5
         BH        XRUPOBJ2                     REGION WHILE       V1L5
         L         R13,XIOSAVE+32      CONVERTING CONSTANT         V1L5
XRUPOBJ2 DS        0H                                              V1L5
         $ERROR    (NOAC,KO,4),XRUPTFIN,SAVE                       V1L5
         SPACE
XRUPTFLD L         R2,XFLDVCNT         FLOATING DIVIDE
         BCT       R2,XRUPTF2
         $ERROR    (NOAC,KO,2),XRUPTFIN,SAVE                       V1L5
XRUPTF2  ST        R2,XFLDVCNT
         MVI       XDVCHKSW+1,X'01'    SET DIVIDE CHECK SWITCH
         BR        R14
         SPACE
XRUPTADR B         XRUPTAD1
         SPACE
XRUPTCNU SDR       F0,F0           EXPONENT UNDERFLOW COMPILE TIME
         B         XERRCN8
XRUPTCNO LD        F0,CPWRS10-8    EXPONENT OVERFLOW COMPILE TIME
XERRCN8  $ERROR    (NOAC,CN,8),,SAVE                               V1L5
         BR        R14
         SPACE
****  THIS IS THE BOUNDARY-ALIGNMENT FIXUP ROUTINE USED TO HANDLE, AT
****     EXECUTION TIME, OPERANDS FORCED TO INVALID MACHINE BOUNDARIES
****     BY COMMON AND/OR EQUIVALENCE. DONT KNOW WHAT WE'LL DO ABOUT
****     MODEL 85'S.
XRUPTSP  STM       R14,R2,XRUPTSV
         MVC       ZCCODE,ZPIEMASK     SET UP TO SAVE CC           V1L2
         NI        ZCCODE,B'00110000'  'AND' OUT ILC & MASK        V1L2
         IF        (ZPIEADDR+2,NZ,X'01'),XRUPTCP  IS ADDRESS ODD ?
         IF        (ZPIEMASK,NZ,X'40'),XRUPTCP  ILC=1 OR 3 => ERROR
         L         R14,ZPIEMASK        LOAD ADDRESS FROM OLD PSW
         S         R14,KF4             R14 -> BAD INSTRUCTION
         IF        (ZR14,NE,X'44'),XRUPTSP1 IS IT AN 'EX' INST?    V1L1
         MVC       XEXEC2+2(2),ZR14+2  GET ADDRESS                 V1L1
         MVN       XEXEC2+1(1),ZR14+1  AND INDEX                   V1L1
         MVZ       XEXEC1+1(1),ZR14+1  REGISTER TO BE OR'D         V1L1
XEXEC1   STC       *-*,XEXEC3+1        VALUE TO BE OR'D            V1L1
         IF        (ZR14+1,MIX,X'F0'),XEXEC2                       V1L1
         MVI       XEXEC3+1,X'00'                                  V1L1
         L         R2,XRUPTS+8         GET BACK REG 2              V1L1
XEXEC2   LA        R14,*-*             POINT TO BAD INST           V1L1
         MVC       XBADINST(4),0(R14)  GET BAD INST                V1L1
XEXEC3   OI        XBADINST+1,*-*      OR IN REGISTER              V1L1
         LA        R14,XBADINST        ADDR OF BAD INST->R14       V1L1
XRUPTSP1 MVC       XLA+2(2),ZR14+2     MOVE D2(I2,B2) TO XLA       V1L1
         MVN       XLA+1(1),ZR14+1
         MVC       XEXEC(1),ZR14       MOVE OPCODE,R1 TO XEXEC
         MVZ       XEXEC+1(1),ZR14+1
         MVI       ZPIERESV,X'00'      GIMMICK PIE TO RETURN       V1L4
         LM        R15,R2,ZPIER15      RESET 15-2 TO PROGRAMME'S VALUES
XLA      LA        R14,*-*             R14 -> BAD DATA
         MVC       XDOUBLE(8),ZR14     MOVE DATA TO DOUBLEWORD BOUNDARY
         TM        KFM1,X'01'          SET CC=3                    V1L3
XEXEC    BC        0,XDOUBLE           EXECUTE INSTRUCTION
         MVC       ZR14(8),XDOUBLE     REPLACE DATA
         L         R14,XRUPTSV+12      R14-> PIE
         STM       R15,R2,ZR14+16      REPLACE 15-2 IN PIE
         BALR      R1,0                GET ILC FOR RETURN          V1L2
         ST        R1,XDOUBLE          IN R1 AND SAVE
         MVZ       ZR14+8(1),XDOUBLE   PUT ILC IN PIE              V1L2
         LM        R14,R2,XRUPTSV      RESET 14-2 FOR SYSTEM
         TM        ZPIEMASK,B'00110000'  DID 'XEXEC' CHANGE CC     V1L2
         BNO       XRUPARD             IF SO LEAVE AS IS ELSE      V1L2
         NI        ZPIEMASK,B'11001111'  'AND' OUT CC              V1L2
         OC        ZPIEMASK,ZCCODE     RESTORE CC                  V1L2
XRUPARD  BR        14                                              V1L2
         SPACE
* ROUTINES TO FIX UP FLOATING POINT REGISTERS AFTER EXPONENT OVERFLOWS
* AND UNDERFLOWS.  THESE ROUTINES DO NOT SET THE CONDITION CODE AND
* DO NOT HANDLE THE CASE WHERE AN EXECUTE INSTRUCTION GETS AN EXPONENT
* OVERFLOW OR UNDERFLOW.
         SPACE
* EXPONENT OVERFLOW
XRUPT2   ST        R2,XEXOFLOW         STASH THE COUNT
         MVI       XOVRFLSW+1,X'01'    SET OVERFLOW INDICATOR
         BAL       R2,XGETREG          WHICH REGISTER HAS OVERFLOW ?
         IC        R2,XRUPTSZ+1        GET REGISTER IN R2
         EX        R2,XRUPTSTE         STORE FLOATING REGISTER
         OC        XRUPTFL(4),XRUPTFM  CREATE MAX.FLOATING NUMBER WITH
         EX        R2,XRUPTLD          CORRECT SIGN AND LOAD REGISTER
         BR        R14                 DONE
         SPACE
* EXPONENT UNDERFLOW ROUTINE
XRUPT3   ST        R2,XEXUFLOW         STASH THE COUNT
         MVI       XOVRFLSW+1,X'03'    SET OVERFLOW INDICATOR
         BAL       R2,XGETREG          SET UP NEXT INSTRUCTION TO LOAD
XRUPTSZ  LD        *-*,XERO            PROPER REGISTER WITH ZERO   V1L4
         BR        R14                 DONE
         SPACE
* ROUTINE TO DETERMINE THE REGISTER WITH THE OVERFLOW OR UNDERFLOW
XGETREG  LR        R0,R2               SAVE RETURN ADDRESS
         L         R2,ZPIEMASK         R2->NEXT INSTRUCTION
         S         R2,KF4 R2->INSTR. CAUSING INTERRUPT IF ILC IS 4
         IF        (ZPIEMASK,O,X'80'),XGETREG1   XGETREG1 IF ILC=4
         LA        R2,2(,R2)       ILC=2,R2->INSTR. CAUSING INTERRUPT
XGETREG1 MVZ       XRUPTSZ+1(1),1(R2)  MOVE REGISTER PART OF INSTR.
         LR        R2,R0
         BR        R2                  DONE
XRUPTCP1 DS        0H                                              V1L5
         $ERROR    (NOAC,KO,7,ISNR0),XRUPTIF,SAVE  EXECUTION ERROR V1L5
XRUPTCP2 DS        0H                                              V1L5
         $ERROR    (NOAC,CP,4),XRUPTIF,SAVE  COMPILE TIME ERROR    V1L5
         SPACE     1
* CONSTANTS USED BY EXPONENT O'FLOW AND U'FLOW ROUTINES
XRUPTFM  DC        X'7FFFFFFF'
XRUPTSTE STE       0,XRUPTFL
XRUPTLD  LD        0,XRUPTFL
         SPACE
****   THIS ROUTINE TRIES TO CHECK IF AN UNINITIALIZED CALL-BY-LOCATION
****     PARAMETER HAS BEEN REFERENCED. THIS COULD HAPPEN IF A ROUTINE
****      WHICH USES CALL-BY-LOCATION PARAMETERS WAS ENTERED THROUGH
****      AN ENTRY POINT WHICH DID NOT CONTAIN THESE PARAMETERS IN ITS
****      PARAMETER LIST, AND SOME OTHER ENTRY POINT WHICH DID CONTAIN
****      THEM HAD NOT BEEN CALLED PREVIOUSLY. BREATH NOW. NOTE THAT AN
****      ARRAY NAME IS AN EXAMPLE OF A CALL-BY-LOCATION PARAMETER.
****      RELOC-1 INITIALIZES ADCONS (AND ARRAY BASES) FOR THESE
****      TYPES OF PARAMETERS TO X'HH800000' WHERE H IS NOT NECESSARILY
****      ZERO. THIS SHOULD CAUSE AN ADDRESSING INTERRUPT IF SUCH AN
****      ADCON IS USED WITHOUT BEING RESET BY ENTERING A ROUTINE
****      WHICH CONTAINS THE VARIABLE AS A PARAMETER (UNLESS YOU'VE GOT
****      SOME JESUS GREAT MACHINE WITH ADDRESSING UP TO X'800000')
****      THE ROUTINE LOOKS FOR X'80' IN THE SECOND BYTE OF REGISTERS
****      R3,R4,R5,R6. THIS IS BECAUSE WATFIV GENERALLY USES THESE
****      REGISTERS FOR INDEXING WITH ARRAYS AND CALL-BY-LOCATION
****      PARAMETERS. ITS KIND OF A CHANCEY TEST AND MAY FAIL SOMETIMES
****      WE THEN ASSUME A COMPILER ERROR HAS OCCURRED. OH WELL, YOU
****      CANT HAVE EVERYTHING.
XRUPTAD1 STM       R3,R6,XRUPTS+12     STORE 3 TO 5
         CLI       XRUPTS+13,X'80'        DID R3 CONTAIN X'HH80HHHH' ?
         BE        XERRSRA
         CLI       XRUPTS+17,X'80'     DID R4 CONTAIN X'HH80HHHH'  V1L1
         BE        XERRSRA
         CLI       XRUPTS+21,X'80'        DID R5 CONTAIN X'HH80HHHH' ?
         BE        XERRSRA
         CLI       XRUPTS+25,X'80'     DID R6 CONTAIN X'HH80HHHH'  V1L1
         BNE       XRUPTCP             THEN ASSUME COMPILER ERROR
         AIF       ('&VM' NE 'USE').VMSYS3                         VM1
XERRSRA  ST        R14,XRUPTSV         SAVE RETURN ADDRESS         VM1
         $ERROR    (NOAC,SR,A)    FALL THRU AFTER PRINTING MSG     V1L5
         L         R14,XRUPTSV         RESTORE RETURN REG          VM1
         AGO       .VMSYS4                                         VM1
.VMSYS3  ANOP                                                      VM1
XERRSRA  $ERROR    (NOAC,SR,A)           FALL THRU AFTER PRTING MSGV1L5
.VMSYS4  ANOP                                                      VM1
         SPACE     1
***    EXIT FROM INTERRUPT MONITOR WHEN WE CONTINUE RUNNING
         AIF       ('&VM' NE 'USE').VMSYS1                         VM1
XRUPTFIN MVC       ZPIEADDR(3),XATRACEB+1  GO TO XTRACEB1 NEXT     VM1
         MVC       ZPIER15(4),XATRACEB SET BASE REG FOR XTRACEB1   VM1
         BR        R14                 RETURN TO SYSTEM            VM1
         AGO       .VMSYS2                                         VM1
.VMSYS1  ANOP                                                      VM1
XRUPTFIN MVI       ZPIERESV,X'0'
         B         XTRACEBK            GO TO TRACEBACK ROUTINE
.VMSYS2  ANOP                                                      VM1
         SPACE     1
****   EXIT WHEN IT LOOKS LIKE GAME OVER. WE MAKE AN ATTEMPT TO CLOSE
****     UP SHOP, I.E., CLOSE FILES,FREE BUFFERS,ETC
XRUPTIF  L         R14,=A(MSTOP)       TRY TO GET TO MSTOP TO SHUT DOWN
         AIF      ('&SNAPS' EQ 'OMIT').XZYX
*******************************************************************
*********          DEBUG VERSION - DUMPS REGISTERS,ETC    *********
*******************************************************************
         ST        1,JPIEADDR
         STM       3,13,XRUPTS+3*4
         LM        3,7,ZPIER14
         STM       3,4,XRUPTS+14*4
         STM       5,7,XRUPTS
         STD       0,XRUPTSF
         STD       2,XRUPTSF+2*4
         STD       4,XRUPTSF+4*4
         STD       6,XRUPTSF+6*4
         MVI       COPT,C'S'
         LA        R13,JRSAVE
         CSNAP     PIE,ZPIE,32
         L         R1,ZPIE+8
         $FREE     1                                               V1L5
         LA        R1,ZR1              CLEAR OUT TOP BYTE
         S         R1,=F'32'
         BL        XRUPTM1     DON'T SNAP IF NEGATIVE
         CSNAP     INSTR,(R1),38
XRUPTM1  DC        0H'0'
         CSNAP     R0-R7,XRUPTS,8*4
         CSNAP     R8-R15,XRUPTS+8*4,8*4
         CSNAP     F0-F6,XRUPTSF,8*4
         IF        (XEXECSW,OFF),XRUPTM2
         CSNAP     ISN,(R11),2
         L         R1,XOBJECT
         L         R2,XENDDATA
         S         R2,XOBJECT
         BCTR      R2,0
         CSNAP     DUMP
XRUPTM2  L         R13,XRUPTS+R13*4
         L         1,JPIEADDR
         USING     ZPIE,1
*******************************************************************
.XZYX    ANOP
         SPACE
         MVI       ZPIERESV,X'0'       GIMMICK PIE TO LET US COME BACK
****   CHECK IF WE HAVE BEEN HERE ALREADY
         IF        (JMRUPTSW,LE,X'04'),JMRUPT19                    V1L4
****   IF WE BOMBED TRYING TO CLEAN UP, EXIT TO SYSTEM DIRECTLY
         L         R13,XSAVER+4
         LM        14,12,12(13)
         LA        R15,8               SET FATAL ERROR CODE
         BR        14
****   INDICATE WE ARE HERE IN CASE WE BLOW CLEANING UP
JMRUPT19 MVI       JMRUPTSW,X'05'                                  V1L4
         BR         R14                      AND OFF TO MSTOP
         SPACE
         $FREE     1,15                                            V1L5
         AIF       ('&SNAPS' EQ 'OMIT').JSNP1
XRUPTSF  DS        4D
JRSAVE   DS        18F
.JSNP1   ANOP
XRUPTFL  DC        0D'0',X'7FFFFFFFFFFFFFFF' USED BY EXPONENT OFLO RTN
XERO     DC        D'0'                USED BY EXPONENT UFLO RTN   V1L4
XRUPTS   DS        16F
JPIEADDR DC        A(*-*)
XBADINST DC        A(*-*)                                          V1L1
ZCCODE   DS        X                   USED BY XRUPTSP RTN         V1L2
         EJECT
         AIF       ('&LIBRARY' EQ 'NO').JLIB
         SPACE     1
***********************************************************************
*        THE NEXT FEW ROUTINES ARE USED TO HANDLE THE WATLIB          *
*        DIRECT-ACCESS LIBRARY FEATURE.                               *
***********************************************************************
         AIF  (&NDVSD).NOIJSYS                                     DVS1
         SPACE 3                                                   DOS2
*******************************************************************DOS2
*        ROUTINE TO OPEN THE SOURCE LIBRARY.                       DOS2
*        OUTPUTS - REGISTER 15 CONTAINS A CODE (0 OR 4)            DOS2
*                  INDICATING (OPEN, NOT OPEN)                     DOS2
*******************************************************************DOS2
         USING CSAVER,RC                                           DOS2
JOPENLIB CENT  JSAVE                                               DOS2
         L     R1,20              GET POINTER TO                   DOS2
         SVC   33                 COMMUNICATIONS REGION            DOS2
****     LH    R2,76(R1)          GET LUB TABLE ADRR               DVS1
         LH        R3,72(,R1)          FICL BASE                   DVS1
         LH        R2,46(,R1)          PIK                         DVS1
         SRL       R2,4                PIK/16                      DVS1
         IC        R2,0(R2,R3)         OUR FICL                    DVS1
         LH        R3,74(,R1)          NICL BASE                   DVS1
         SR        R4,R4               CLEAR R4                    DVS1
         IC        R4,0(,R3)           SYSTEM NICL                 DVS1
         SR        R2,R4               FICL SYSTEM LUB             DVS1
         SLL       R2,1                FICL AS DISPLACEMENT        DVS1
         AH        R2,76(,R1)          ADD LUB BASE                DVS1
         LA        R15,4               INDICATE NO SOURCE LIB      DVS1
         CLI   14(R2),X'FF'       IS PRIVATE SOURCE LIBRARY ASSIGNEDOS2
         BE    JSSLOPN            NO, OPEN SYSTEM SOURCE LIBRARY   DOS2
         OPEN  IJSYSSL            OPEN PRIVATE LIBRARY             DOS2
         TM    IJSYSSL+16,X'20'   WAS LIBRARY ASSIGNED WITH 'IGN'  DOS2
         BO    JSSLOPN            YES, OPEN SYSTEM SOURCE LIBRARY  DOS2
         OI    JPRVSW,X'11'       SET LIBRARY OPEN SW              DOS2
         MVI   JDCCBL+7,X'07'     SET CCB FOR PRIVATE LIBRARY      DOS2
         MVC   JBUCK1(3),IJSYSSL+61 GET DISK ADDR OF PVT LIBRARY   DOS2
         MVC   JBUCK1+1(1),IJSYSSL+60  MOVE IN CYL#                DVS1
         B     JSSLOPN            HIT IT WITH $$BOPNLB             DOS2
JOPNSYS  MVI   JPRVSW,0           RESET PRIVATE LIBRARY OPEN SW    DOS2
         MVI   JPRSSSW,0          RESET PRIVATE LIBRARY OPEN SW    DOS2
         MVI   JDCCBL+7,X'06'     SET CCB FOR SYSTEM SOURCE LIBRARYDOS2
         XC    JBUCK1(3),JBUCK1   CLEAR $$BOPNLB BUCKET            DOS2
JSSLOPN  LA    R2,JBUCK1          GET ADDR OF $$BOPNLB PARAMETERS  DOS2
         LA    R1,=CL8'$$BOPNLB'  GET ADDR OF TRANSIENT NAME       DOS2
         SVC   2                  CALL A LOGICAL TRANSIENT         DOS2
         TM    JPRVSW,X'11'       TEST IF PRIVATE LIBRARY OPEN     DOS2
         BO    JOPENOK            OPENED AND ACTIVE ENTRIES        DOS2
         BM    JOPNSYS            OPENED AND NO ACTIVE ENTRIES     DOS2
         TM    JPRSSSW,X'40'      ANY ACTIVE ENTRIES IN SYSTEM LIB DOS2
         BZ    JRET               TELL CALLER NO DICE              DOS2
JOPENOK  SR    R15,R15            INDICATE ALL IS WELL TO CALLER   DOS2
         B     JRET               RETURN TO CALLER                 DOS2
         $FREE RP,R13                                              DVS1
         SPACE 3                                                   DOS2
*******************************************************************DOS2
*        USED TO FIND A BOOK IN THE SOURCE LIBRARY.                DOS2
*        INPUT - REGISTER 0 POINTS TO A SIX-CHARACTER NAME.        DOS2
*        OUTPUTS - REGISTER 15 CONTAINS A CODE (0,4 OR 8)          DOS2
*                  INDICATING (OK,NOT THERE OR I/O ERROR)          DOS2
*******************************************************************DOS2
         USING CSAVER,RC                                           DOS2
JFIND    CENT  JSAVE                                               DOS2
         LR    R4,R0              GET ADDR OF BOOK NAME            DOS2
         MVC   JBKARG,0(R4)       MOVE BOOK NAME TO COMPARE FIELD  DOS2
         OI    JBKSW,X'70'        SET LIBRARY CONCATENATE SW       DOS2
         MVC   JLADDR(4),JBUCK1   GET PRIVATE LIBRARY ADDRESS      DOS2
         MVI   JDCCBL+7,X'07'     SET CCB FOR PRIVATE LIBRARY      DOS2
         TM    JPRVSW,X'11'       PRIVATE LIBRARY OPENED           DOS2
         BO    JRSTLIB1           OPENED AND ACTIVE ENTRIES        DOS2
         BM    JRTURN             OPENED AND NO ACTIVE ENTRIES     DOS2
JRSTLIB  MVC   JLADDR(4),JBUCK2   GET SYSTEM SOURCE LIBRARY ADDRESSDOS2
         MVI   JDCCBL+7,X'06'     SET CCB FOR SYSTEM LIBRARY       DOS2
         TM    JPRSSSW,X'40'      ANY ACTIVE ENTRIES               DOS2
         BZ    JRTURN             NO                               DOS2
JRSTLIB1 NI    JPRSSSW,X'DF'      CLEAR LIBRARY SWITCHES           DOS2
         OI    JDIRSW,X'01'       RESET DIRECTORY SW               DOS2
JFNDL    MVC   JSRCHFL+1(4),JLADDR GET LIBRARY DISK ADDR           DOS2
         MVC   JSRCHFL(1),JLADDR+1 MOVE IN TOP CYL#                DVS1
         MVI   JSRCHFL+2,X'00'     RESET TOP HEAD#                 DVS1
         EX    0,JRSTBP1          RESET INPUT BUFFER ADDRESS       DOS2
         L     R1,JBUFPTF         GET ADDRESS OF INPUT BUFFER      DOS2
         XC    0(162,R1),0(R1)    CLEAR BUFFER AREA                DOS2
         MVI   161(R1),X'FF'      SET END OF BLOCK INDICATOR       DOS2
         B     JRDBLK             GO READ A DIRECTORY BLOCK        DOS2
JRSTBPT  MVC   JBUFPTF+1(3),JDCCWL+1  POINT BUFFER ADDR TO TWO ZERODOS2
         CLI   1(R1),0            TEST FOR END OF BOOK OR DIRECTORYDOS2
         BE    JRTURN             BR IF END OF BOOK OR DIRECTORY   DOS2
JRSTBP1  MVC   JBUFPTF+1(3),JRCCWDL+1 RESET INPUT BUFFER ADDRESS   DOS2
JRDBLK   LA    R7,JRDBLK2         GET ADDR OF DISK I/O ROUTINE     DOS2
         BALR  R5,R7              LINK TO IT                       DOS2
         B     JLIBERR            BR IF UNRECOVERABLE DISK I/O ERRODOS2
         L     R1,JBUFPTF         LOAD PTR TO DIRECTORY BLOCK      DOS2
         USING JBKPRFX,R1                                          DOS2
         TM    JDIRSW,X'01'       FIRST TIME TO DIRECTORY          DOS2
         BZ    JTSTND             NO                               DOS2
         MVI   JDIRSW,X'00'       SET DIRECTORY FIRST TIME SW      DOS2
         B     JTSTND1                                             DOS2
JTSTND   CLI   0(R1),0            TEST FOR END OF BUFFER           DOS2
         BE    JRSTBPT            BR IF END OF BUFFER              DOS2
JTSTND1  CLI   0(R1),C'*'         TEST FOR END OF DIRECTORY        DOS2
         BE    JRTURN1            BR IF END OF DIRECTORY           DOS2
*    TEST FOR BOOK FOUND IN DIRECTORY                              DOS2
JFNDT    TM    JPRSSSW,X'20'      THIS FIRST TIME THRU             DOS2
         BO    JFNDT2             NO                               DOS2
         LA    R1,80(R1)          UPDATE BUFFER PTR                DOS2
         OI    JPRSSSW,X'20'      SET SW                           DOS2
JFNDT2   CLC   JNAME,JBKPRFX      COMPARE BOOK NAMES               DOS2
         BE    JFNDBK2            BR IF DESIRED BOOK FOUND         DOS2
JFNDT3   LA    R1,16(R1)          BUMP BUFFER POINTER              DOS2
         B     JTSTND             GO LOOK AT NEST DIRECTORY ENTRY  DOS2
*    INITIALIZE FOR GET WHEN BOOK FOUND IN DIRECTORY               DOS2
JFNDBK2  NI    JPRSSSW,X'DF'      CLEAR FIRST TIME SW              DOS2
         MVC   JCYLL(1),JBKCYL    GET CYL                          DOS2
         MVC   JCYLL+2(2),JBKHD   GET HEAD AND RECORD              DOS2
         NI    JCYLL+2,X'3F'      ERASE TOP 2 BITS                 DVS1
         SR    R0,R0              CLEAR R0                         DVS1
         IC    R0,JBKHD           EXTRACT HEAD#                    DVS1
         SRL   R0,6               SHIFT OVER                       DVS1
         STC   R0,JCYL1L          SAVE CYL#                        DVS1
         NI    JBKSW,X'0F'        DO NOT CONCATENATE LIBRARIES     DOS2
         EX    0,JRSTBP1          RESET INPUT BUFFER ADDRESS       DOS2
         NI    JRCCWDL+4,255-JCC  DO NOT CHAIN TO READ COUNT COMMANDOS2
         LA    R7,JRDBLK2         GET ADDR OF DISK I/O ROUTINE     DOS2
         BALR  R5,R7              READ FIRST RECORD OF BOOK        DOS2
          B     JLIBERR           BR IF UNRECOVERABLE I/O ERROR    DOS2
         OI    JRCCWDL+4,JCC      CHAIN TO READ COUNT COMMAND      DOS2
         L     R4,JBUFPTF         LOAD PTR TO BUFFER               DOS2
         LR    R6,R4              LOAD POINTER TO OUTPUT BUFFER    DOS2
         MVO   JCHRS(2),0(1,R4)   GET BLANK-NONBLANK FLAG          DOS2
         SR        R5,R5          CLEAR REG                        DOS2
         IC    R5,JCHRS           GET NUMBER OF NON-BLANKS         DOS2
         EX    R5,JMVNBL          MOVE NON-BLANKS TO FRONT OF BUFFEDOS2
         CLI   0(R6),X'88'        IS THIS RECORD AN ALIAS          DOS2
         BNE   JNOAL              BR IF NO                         DOS2
         MVC   JBKARG,=CL6' '     BLANK BOOKNAME FIELD             DOS2
         LA    R6,JBKARG          POINT TO BOOK NAME FIELD         DOS2
         BCTR  R5,0               SUB 1 FROM NON-BLANK LENGTH      DOS2
         BCTR      R5,0                SUB1 AGAIN                  DOS2
         CH    R5,=H'5'           IS BOOK NAME .GT. 6              DOS2
         BNH   *+8                BR IF NO                         DOS2
         LA    R5,5               MAKE IT SIX                      DOS2
         EX    R5,JMVNBL          MOVE NEW NAME TO FIND POS        DOS2
         B     JRSTLIB1                                            DOS2
JNOAL    EQU   *                                                   DOS2
         LA    R15,0              INDICATE BOOK FOUND TO CALLER    DOS2
         LA    R1,JFRCRD          SET INPUT BUFFER TO FORCE READ   DOS2
         ST    R1,JBUFPTF         SAVE BUFFER POINTER FOR GET      DOS2
         B     JRET               RETURN TO CALLER                 DOS2
JRTURN1  CLC   JLADDR(4),JBUCK2   HAVE WE TRIED THE SYSTEM LIBRARY DOS2
JBKSW    EQU   *+1                                                 DOS2
         BNE   JRSTLIB            BR IF NO                         DOS2
JRTURN   LA    R15,4              INDICATE BOOK NOT FOUND TO CALLERDOS2
         B     JRET               RETURN TO CALLER WITH BAD NEWS   DOS2
JLIBERR  LA    R15,8              INDICATE I/O ERROR TO CALLER     DOS2
         B     JRET               RETURN TO CALLER WITH WORSE NEWS DOS2
JNAME    DS    0XL7                                                DOS2
         DC    C'&LIBPRFX'                                         DOS2
JBKARG   DS    CL6                                                 DOS2
         $FREE R1                                                  DVS1
         SPACE 3                                                   DOS2
*******************************************************************DOS2
*        LIBRARY READ ROUTINE.  INPUT IS FROM EITHER THE SYSTEM SOUDOS2
*        LIBRARY OR A PRIVATE SOURCE LIBRARY.                      DOS2
*******************************************************************DOS2
         USING CSAVER,RC                                           DOS2
         ENTRY JSUBRRD                                             DOS2
JSUBRRD  CENT  JSAVE                                               DOS2
         LA    R6,XCARD           LOAD POINTER TO OUTPUT BUFFER    DOS2
         MVI   0(R6),C' '         MOVE IN A BLANK                  DOS2
         MVC   1(79,R6),0(R6)     BLANK OUT OUTPUT BUFFER          DOS2
JEOBKSW  NOP   JEDSUBRD           SW FOR END OF BOOK               DOS2
         LA    R9,JCDLEN-1(R6)    POINT TO END OF OUTPUT BUFEER    DOS2
         L     R4,JBUFPTF         LOAD POINTER TO INPUT BUFFER     DOS2
JEXPTIN  SR    R8,R8              ZERO REG                         DOS2
         SR    R5,R5                                               DOS2
JEXPLP   CLI   0(R4),0            TEST FOR END OF INPUT BLOCK      DOS2
         BE    JEOBKT             BR IF END OF BLOCJ               DOS2
         MVO   JCHRS(2),0(1,R4)   GET BLANK-NONBLANK FLAG          DOS2
         IC    R5,JCHRS           LOAD NUMBER OF NONBLANKS         DOS2
         NI    0(R4),X'0F'        ZERO NONBLANK COUNT IN FLAG      DOS2
         IC    R8,0(R4)           LOAD NUMBER OF BLANKS            DOS2
         IC    R2,0(R5,R6)        SAVE CHAR AT END OF NON-BLANKS   DOS2
         EX    R5,JMVNBL          MOVE NONBLANKS                   DOS2
         LA    R4,1(R5,R4)        BUMP INPUT BUFFER POINTER        DOS2
         LA    R6,0(R5,R6)        BUMP OUTPUT BUFFER POINTER       DOS2
         STC   R2,0(R6)           RESTORE CHAR AT END OF NON-BLANKSDOS2
         BXLE  R6,R8,JEXPLP       IF CARD NOT COMPLETE, GO AGAIN   DOS2
         ST    R4,JBUFPTF         SAVE INPUT BUFFER POINTER        DOS2
         B     JRET               RETURN TO CALLER WITH CARD IMAGE DOS2
JEOBKT   CLI   1(R4),0            TEST FOR END OF BOOK             DOS2
         BE    JEOBK              BR IF END OF BOOK                DOS2
         LA    R7,JRDBLK2         GET ADDR OF DISK I/O ROUTINE     DOS2
         BALR  R5,R7              LINK TO IT                       DOS2
         B     JERRLIB            BR IF DISK I/O ERROR             DOS2
JRDBLK3  MVC   JBUFPTF+1(3),JRCCWDL+1 RESET POINTER TO BUFFER      DOS2
         L     R4,JBUFPTF         RELOAD POINTER TO BUFFER         DOS2
         B     JEXPTIN                                             DOS2
JEOBK    C     R6,=A(XCARD)       HAS OUTPUT BUFFER GOT A CARD IMAGDOS2
         BE    JEDSUBRD           BR IF NO                         DOS2
         MVI   JEOBKSW+1,X'F0'    SET END-OF-BOOK SW               DOS2
         B     JRET               GO FLUSH OUTPUT BUFFER           DOS2
JEDSUBRD MVI   JEOBKSW+1,X'00'    RESET END-OF-BOOK SW             DOS2
         MVC   0(L'XCONTROL,R6),XCONTROL                           DOS2
         MVC   L'XCONTROL(L'CDATA,R6),CDATA                        DOS2
         B     JRET                                                DOS2
JERRLIB  $ERROR    (NOEX,UN,G),XSTOP                               V1L5
JCHRS    DS    2X                                                  DOS2
JMVNBL   MVC   0(1,R6),1(R4)      'EX'ECUTED MOVE INSTRUCTION      DOS2
JRET     L     R1,4(R13)          GET ADDR OF CALLER'S SAVE AREA   DOS2
         LM    R1,R9,24(R1)       RESTORE CALLER'S REGS 1 - 9      DOS2
         B     CRET               RETURN TO CALLER                 DOS2
         SPACE 3                                                   DOS2
*******************************************************************DOS2
*        CCW'S, CCB'S FILE TABLES AND OTHER ASSORTED NECESSITIES OFDOS2
*        LIFE FOR FOOLING AROUND WITH SOURCE LIBRARIES.            DOS2
*******************************************************************DOS2
*    DISK I/O ROUTINE                                              DOS2
         USING *,R7                                                DOS2
JRDBLK2  EXCP  JDCCBL             READ BLOCK OF BOOK OR DIRECTORY  DOS2
         WAIT  (1)                                                 DOS2
         TM    JDCCBL+2,X'20'     TEST FOR UNRECOVERABLE I/O ERROR DOS2
         BCR   1,R5               BR IF UNRECOVERABLE I/O ERROR    DOS2
         TM    JDCCBL+3,X'20'     TEST FOR END-OF-CYLINDER         DOS2
         BNO   4(R5)              RETURN IF NOT END-OF-CYLINDER    DOS2
         LH    R1,JCYL1L          LOAD CYL NUMBER FOR INCREMENT    DOS2
         MVC   JCYLL+2(2),JFRCRD  RESET TRACK AND RECORD NOS.      DOS2
         LA    R1,1(R1)           INCRMT CYL NO                    DOS2
         STH   R1,JCYL1L          STORE UPDATED CYLINDER NO.       DOS2
         B     4(R5)              RETURN                           DOS2
         $FREE RP,R13,R7                                           DVS1
JCDLEN   EQU   80                                                  DOS2
JCC      EQU   X'40'                                               DOS2
JSLI     EQU   X'20'                                               DOS2
JCCSLI   EQU   JCC+JSLI                                            DOS2
JSEEK    EQU   X'07'                                               DOS2
JSRIE    EQU   X'31'                                               DOS2
JTIC     EQU   X'08'                                               DOS2
JRDDTA   EQU   X'06'                                               DOS2
JMRDCT   EQU   X'92'                                               DOS2
JDCCBL   CCB   SYSRES,JDCCWL,X'9000' CCB TO READ BOOK              DOS2
*        CHANNEL PROGRAMS                                          DOS2
*    READ BLOCK OF BOOK                                            DOS2
JDCCWL   CCW   JSEEK,JSKSCHL,JCCSLI,6 SEEK                         DOS2
JSRCHDL  CCW   JSRIE,JSRCHFL,JCCSLI,5 SEARCH                       DOS2
         CCW   JTIC,JSRCHDL,JCCSLI,1 TRANSFER IN CHANNEL           DOS2
JRCCWDL  CCW   JRDDTA,JDIOA,JCCSLI,160 READ DATA                   DOS2
         CCW   JMRDCT,JSRCHFL,JSLI,5 READ COUNT FLD OF NEXT BLOCK  DOS2
JSKSCHL  DC    XL2'0'             BB                               DOS2
JSRCHFL  DC    0XL5'0'                                             DOS2
JCYL1L   DC    X'0'               C                                DOS2
JCYLL    DC    X'0'               C                                DOS2
         DC    XL2'0'             HH                               DOS2
         DC    X'1'               R                                DOS2
         DC    X'0'               SPARE BYTE                       DOS2
JBUFPTF  DC    A(JRCCWDL+12)                                       DOS2
JLADDR   DC    XL4'1'             START-OF-LIB DASD ADDR           DOS2
JFRCRD   DC    XL2'1'             USED TO FORCE READ               DOS2
JSVREG   DC    6F'0'              REG SAVE AREA                    DOS2
JSVREG1  DC    6F'0'              SAVE FIND STATUS                 DOS2
         LTORG                                                     DOS2
*                                                                  DOS2
*        THE FOLLOWING DC'S ARE PARAMETERS PASSED TO THE B-TRANSIENDOS2
*        ROUTINE $$BOPNLB.                                         DOS2
*                                                                  DOS2
JBUCK1   DC    F'1'               DISK ADDR OF PRIVATE LIBRARY     DOS2
JBUCK2   DC    F'0'               DISK ADDR OF SOURCE LIBRARY      DOS2
JPRVSW   DC    X'0'               PRIVATE LIBRARY SWITCH OPEN      DOS2
JPRSSSW  DC    X'0'               CODE SETTINGS                    DOS2
*                                 BIT 0 - PROCESSING PRIVATE LIBRARDOS2
*                                 BIT 1 - ACTIVE ENTRIES IN SSL    DOS2
*                                 BIT 2 - UPDATE SW FOR FIRST RECORDOS2
JDIRSW   DC    X'0'               FIRST TIME TO DIRECTORY          DOS2
JCMPLSW  DC    X'0'               SERVICING COMPLETE LIBRARY SWITCHDOS2
*                                                                  DOS2
         SPACE     1                                               DOS2
JDTFORG  DC    0D'0'                                               DOS2
JDIOA    DS    XL162                                               DOS2
         ORG   JDTFORG                                             DOS2
*                                                                  DOS2
*        HAND CODED VERSION OF DTFCP FOR SOURCE LIBRARY            DOS2
*                                                                  DOS2
IJSYSSL  DC    H'0'               RESIDUAL COUNT                   DOS2
         DC    X'8400'            COMMUNICATION BYTES              DOS2
         DC    X'0800'            CSW STATUS BYTES                 DOS2
         DC    X'0007'            LOGICAL UNIT                     DOS2
         DC    X'00'                                               DOS2
         DC    AL3(IJJC0016)      CCW ADDRESS                      DOS2
         DC    XL1'0'             STATUS BYTE                      DOS2
         DC    XL3'0'             CSW CCW ADDRESS                  DOS2
         DC    XL1'0'                                              DOS2
         DC    AL3(*-*)           ADDRESS OF LOGIC MODULE          DOS2
         DC    X'32'              DTF TYPE                         DOS2
         DC    X'02'              OPEN INDICATORS                  DOS2
         DC    CL8'IJSYSSL'       FILE NAME                        DOS2
         DC    6X'00'             BCCHHR                           DOS2
         DC    2X'00'             VOL. SEQ. NO. OR WORK AREA       DOS2
         DC    X'08'              OPEN SWITCH                      DOS2
         DC    2X'00'             XTNT SEQ. NO. OR CONSTANT FOR PUNDOS2
         DC    X'20'              CONSTANT                         DOS2
         DC    X'20'              INDICATE DEVICE TO LOGIC         DOS2
         DC    X'F3'              INDICATOR FOR LOGIC              DOS2
         DC    AL1(128)           LOGIC INDICATORS                 DOS2
         DC    AL3(*)             ALT I/O AREA                     DOS2
         DC    X'80000000'        WORK AREA                        DOS2
         DC    XL2'0'             HEAD NO.                         DOS2
         DC    4X'00'             EXTENT UPPER LIMIT               DOS2
IJJW0016 DC    H'0'               BB                               DOS2
         DC    X'0000FF00'        CYLINDER AND HEAD                DOS2
         DC    X'00'              RECORD FOR DISK, CONSTANT FOR PUNDOS2
         DC    AL3(*)             EOF ADDR                         DOS2
         DC    4X'0'              CCHH UPPER LIMIT                 DOS2
         DC    AL1(25+1)          NO. OF REC/TRK + 1               DOS2
         DC    X'01'              FIRST RECORD                     DOS2
         DC    X'0018'            CONSTANT                         DOS2
IJJF0016 DC    4X'00'             CCHH COUNT ID                    DOS2
         DC    X'01'              COUNT FIELD RECORD               DOS2
         DC    X'00'              KEY LENGTH                       DOS2
         NOP   0(0)                                                DOS2
IJJC0016 CCW   X'07',IJJW0016,X'40',6 SEEK TRACK                   DOS2
         CCW   X'31',IJJW0016+2,X'40',5 SEARCH                     DOS2
         CCW   X'08',IJJC0016+8,X'20',1 TRANSFER                   DOS2
         CCW   X'06',*,X'20',81 INPUT                              DOS2
IJJQ0016 EQU   *                                                   DOS2
         ORG       ,                                               DOS2
JENTSRC  DSECT             DSECT FOR SOURCE LIBRARY DIRECTORY EN   DOS2
JBKPRFX  DS    C                  SUBLIBRARY PREFIX                DOS2
JBKNAME  DS    CL8                BOOK NAME                        DOS2
JBKCYL   DS    X                  CYL NO OF BOOK IN LIBRARY        DOS2
JBKHD    DS    X                  HEAD NO OF BOOK IN LIBRARY       DOS2
JBKRCD   DS    X                  RECORD NO OF BOOK IN LIBRARY     DOS2
JBKBLKCT DS    XL2                NO LIBRARY BLOCKS FOR THIS BOOK  DOS2
JBKCHGV  DS    X                  VERSION LEVEL NUMBER             DOS2
JBKCHGM  DS    X                  MOD LEVEL NUMBER                 DOS2
JSYS     CSECT                                                     DOS2
         AGO   .JLIB                                               DOS2
.NOIJSYS ANOP                                                      DOS2
         SPACE     1
***********************************************************************
*        LIBRARY READ ROUTINE.   WATLIB DCB IS USED.                  *
*        DATA READ MUST BE CARD IMAGES AND CAN BE BLOCKED.            *
*        NOTE: CPOINT MUST EQUAL CBUFFE ON ENTRY TO READ A NEW MEMBER *
***********************************************************************
         USING     CSAVER,RC
         ENTRY     JSUBRRD
JSUBRRD  CENT      JSAVE
         L         R1,CPOINT           CURRENT RECORD POINTER
         C         R1,CBUFFE           END OF BUFFER POINTER
         BL        JCMOVE              ARE WE AT END OF BUFFER
         L         R2,CBUFF            YES SO READ ANOTHER BLOCK
         READ      JDECB,SF,WATLIB,(R2)
         CHECK     JDECB
         ST        R2,CPOINT           CURRENT RECORD PTR  RESET
         AH        R2,WATLIB+62        ADD IN BLKSIZE
         L         R3,JDECB+16         IOB ADDRESS
         LH        R3,ZR3+14           RESIDUAL CCW COUNT
         SR        R2,R3               ADDR OF END OF BLOCK
         ST        R2,CBUFFE           AND SAVE IT AWAY
         L         R1,CBUFF            ADDR OF START OF BUFFER
JCMOVE   MVC       XCARD(80),ZR1       SAVE CARD FOR SCAN
         LA        R1,ZR1+80           BUMP CURRENT BUFFER PTR
         ST        R1,CPOINT           AND SAVE IT AWAY
         B         CRET                RETURN TO CALLER
         SPACE     1
*        END OF FILE ROUTINE---GENERATE A $ENTRY CARD IN INPUT AREA
JENDLIB  MVC       XCARD(L'XCONTROL),XCONTROL
         MVC       XCARD+L'XCONTROL(L'CDATA),CDATA
         B         CRET
         SPACE     1
*        I/O ERROR ENCOUNTERED WHILE READING FROM LIBRARY
JERRLIB  $ERROR    (NOEX,UN,G),XSTOP                               V1L5
         $FREE     RP,R13                                          V1L5
         SPACE     3
***********************************************************************
*        USED TO FIND A MEMBER OF THE SOURCE LIBRARY                  *
*        INPUT  -  REGISTER 0 POINTS TO A 6 CHARACTER NAME            *
*        OUTPUTS - REGISTER 15 CONTAINS A CODE (0,4,OR 8)             *
*                  INDICATING (OK,NOT THERE, OR I/O ERROR)            *
*               -  WATLIB DCB SET UP FOR FUTURE READ OF MEMBER        *
***********************************************************************
         USING     CSAVER,RC
JFIND    CENT      JSAVE
         AIF       ('&TRACE' EQ 'OMIT').NFINDTR                    V1L4
         IF        (XISNTRAC,ON,X'40'),THEN,(DO,XTRACON)           V1L4
.NFINDTR ANOP                                                      V1L4
         STM       R2,R7,XIOSAVE       SAVE REGISTERS              V1L4
         AIF       ('&STATS' NE 'YES').STAT4                       UOW
         LR        R3,R0                                           V1L4
.STAT4   ANOP                                                      V1L4
         AIF       (&LIBOPT1).FIND8                                V1L4
         LR        R5,R0               R5=A(LIB OR FCN NAME)       V1L4
         MVC       DMYNAME(8),0(R5)    MOVE NAME INTO DUMMY ENTRY  V1L4
         XC        DMYTTR(4),DMYTTR    ZERO OUT DUMMY TTR IN TABLE V1L4
         MVC       NAME(8),0(R5)       SAVE NAME IN TEMP           V1L4
         LA        R6,TABLE            R6=A(1ST ELEMENT IN TABLE)  V1L4
         L         R2,=F'-12'          R2=INCREMENT FOR BXLE       V1L4
         LA        R3,DMYNAME-12       R3=A(DUMMY ENTRY IN TABLE)-12
LIBLOOP  CLC       NAME(8),0(R6)       IS FCN OR LIB NAME IN TABLE V1L4
         BE        FOUNDIT             YES-> WE FOUND IT           V1L4
         BXH       R6,R2,LIBLOOP       CHECK NEXT ENTRY IN TABLE   V1L4
FOUNDIT  OC        8(4,R6),8(R6)       CHECK IF TTR IS VALID       V1L4
         BZ        BLDL                TTR IS INVALID->ISSUE BLDL  V1L4
         LA        R7,8(R6)            A(TTRK) NOW IN R7           V1L4
         LA        R4,LIBSTAT          RETURN ADDRESS AFTER FIND   V1L4
TTRFIND  FIND      WATLIB,(7),C        GIVEN TTRK GO FIND MEMBER   V1L4
         LTR       R15,R15             WERE WE SUCCESSFUL?         V1L4
         BNZ       BRET                NO->RETURN TO CALLER        V1L4
         BR        R4                  RETURN TO CALLER OR LIBSTAT V1L4
         AIF       ('&LIBSTAK' EQ 'OMIT').FIND1                    V1L4
POPSTACK LA        R3,STAKBOT          R3=A(2ND LAST STACK ENTRY)  V1L4
         SR        R4,R6               CALCULATE LENGTH OF MOVE    V1L4
         LTR       R4,R4               CHECK FOR MOVE OF LENGTH 0  V1L4
         BZ        LIBSTAT             NO MOVE REQUIRED            V1L4
         AH        R4,=H'-13'          LESS 13 FOR DUMMY ENTRY     V1L4
         EX        R4,POPIT            POP THAT STACK              V1L4
         MVC       0(12,R5),NAME       TOP OF STACK GETS NAME,TTR  V1L4
         B         LIBSTAT             STATISTICS ANYONE?          V1L4
.FIND1   ANOP                                                      V1L4
BLDL     EQU       *                                               V1L4
         BLDL      WATLIB,ZLIST        GET TTRK FROM BLDL          V1L4
         LTR       R15,R15             TEST RC IN R15              V1L4
         BNZ       BRET                4 OR 8 -> ERROR             V1L4
         LA        R7,TTR              PUT A(TTRK) IN R7           V1L4
         BAL       R4,TTRFIND          ISSUE FIND FOR MEMBER       V1L4
         AIF       ('&LIBSTAK' EQ 'USE').FIND2                     V1L4
         C         R6,=A(DMYNAME)      CHECK IF AT STACK BOTTOM    V1L4
         BE        LIBSTAT             YES->DON'T SAVE TTR         V1L4
.FIND2   ANOP                                                      V1L4
         AIF       ('&LIBSTAK' EQ 'OMIT').FIND4                    V1L4
         LA        R4,UNPROT           CALCULATE POSITON OF NAME   V1L4
         AIF       ('&LIBCORE' EQ 'OMIT').FIND3                    V1L4
         LR        R5,R4               R5=A(1ST UNPROTECTED ENTRY) V1L4
         CR        R4,R6               IF NAME IS NOT PROTECTED    V1L4
         BNL       POPSTACK            THEN POP UP STACK           V1L4
         AGO       .FIND4                                          V1L4
.FIND3  ANOP                                                       V1L4
         B         POPSTACK            POP UP STACK                V1L4
         AGO       .FIND5                                          V1L4
.FIND4   ANOP                                                      V1L4
         MVC       8(4,R6),TTR         ELSE MOVE IN TTR            V1L4
         B         BRET                AND RETURN                  V1L4
.FIND5   ANOP                                                      V1L4
         AIF       ('&LIBSTAK' EQ 'OMIT').FIND6                    V1L4
POPIT    MVC       0(*-*,R3),12(R3)                                V1L4
         DC        0D'0'                                           V1L4
         STACKGEN                                                  V1L4
.FIND6   ANOP                                                      V1L4
         AIF       ('&LIBCORE' EQ 'OMIT').FIND9                    V1L4
         COREGEN                                                   V1L4
.FIND7   AGO       .FIND9                                          V1L4
.FIND8   ANOP                                                      V1L4
         FIND      WATLIB,(0),D                                    V1L4
         LTR       R15,R15                                         V1L4
         BNZ       CRET                                            V1L4
.FIND9   ANOP                                                      V1L4
LIBSTAT  EQU       *                                               V1L4
         AIF       ('&STATS' NE 'YES').STAT5                       UOW
         MVC       ZLIST+4(8),0(R3)                                V1L4
         MVC       ZLIST+18(2),=H'00'                              V1L4
         IF        (XDEBUGSW,EQ,X'FF'),BRET DEBUG MODE->NO STATS   V1L4
         ENQ       (QNAME,ZNAME,E,13,SYSTEM)                       V1L4
JNOENQ1  EQU       *                                               V1L4
         BLDL      LIBUSAGE,ZLIST                                  V1L4
         LTR       R15,R15             TEST RETURN CODE IN R15     V1L4
         BZ        STOWLIST            0 -> SUCCESS                V1L4
         LA        R15,KF8             SET RETURN CODE TO 8        V1L4
         B         BRET                AND RETURN                  V1L4
STOWLIST EQU       *                                               V1L4
         LH        R1,ZLIST+18                                     V1L4
         LA        R1,1(R1)                                        V1L4
         STH       R1,ZLIST+18                                     V1L4
         NI        ZLIST+17,X'60'                                  V1L4
         OI        ZLIST+17,X'81'                                  V1L4
         MVC       ZLIST+15(3),ZLIST+17                            V1L4
         STOW      LIBUSAGE,ZLIST+4,R                              V1L4
         S         R15,KF8             RETURN CODE-8 TO TEST STOW  V1L4
         BP        SRC8                >0 -> NO SPACE LEFT IN DRY  V1L4
         LA        R2,0                ELSE INDICATE A-OK          V1L4
         B         DEQ                 AND PLAY WITH QCBS          V1L4
SRC8     LA        R2,KF8              NO SPACE LEFT IN DIRECTORY  V1L4
DEQ      EQU       *                   OR I/O ERROR -> RET CODE=8  V1L4
         IF        (XDEBUGSW,EQ,X'FF'),JNOENQ2                     V1L4
         DEQ       (QNAME,ZNAME,13,SYSTEM)                         V1L4
JNOENQ2  EQU       *                                               V1L4
         LR        R15,R2              RESTORE R15                 V1L4
.STAT5   ANOP                                                      V1L4
BRET     LM        R2,R7,XIOSAVE       RESTORE REGISTERS           V1L4
         B         CRET                AND RETURN                  V1L4
         AIF       ('&STATS' NE 'YES').STAT6                       UOW
QNAME    DC        CL8'SYSLIB'                                     V1L4
ZNAME    DC        CL13'SYS2.LIBUSAGE'                             V1L4
.STAT6   ANOP                                                      V1L4
         AIF       ((&LIBOPT1) AND ('&STATS' NE 'YES')).FIND10     V1L5
ZLIST    DC        H'01',H'16'         USED BY BLDL                V1L4
NAME     DC        CL8' '              MEMBER NAME                 V1L4
TTR      DC        4X'00',2X'00',H'00' RELATIVE TRACK ADDRESS      V1L4
.FIND10  ANOP                                                      V1L4
         AIF       ('&STATS' NE 'YES').STAT7                       UOW
LIBUSAGE DCB       DSORG=PO,MACRF=(R,W),BUFNO=0,DDNAME=LIBUSAGE    V1L4
.STAT7   ANOP                                                      V1L4
         SPACE     3
***********************************************************************
*        ROUTINES TO OPEN AND CLOSE WATLIB                            *
***********************************************************************
         USING     CSAVER,RC
JOPENLIB CENT      JSAVE
         OPEN      ,MF=(E,JLIBLIST)                                V1L2
         LH        R2,WATLIB+62
         B         CRET
         SPACE     3
JCLOSLIB CENT      JSAVE
         CLOSE     ,MF=(E,JLIBLIST)                                V1L2
         B         CRET
         AIF       ('&STATS' EQ 'YES').STAT8                       UOW
JLIBLIST OPEN      (WATLIB,(INPUT)),MF=L                           V1L2
.STAT8   ANOP                                                      UOW
         AIF       ('&STATS' NE 'YES').STAT9                       UOW
JLIBLIST OPEN      (WATLIB,(INPUT),LIBUSAGE,(OUTPUT)),MF=L         V1L2
.STAT9   ANOP                                                      UOW
         SPACE     1
         $FREE     RP,R13                                          V1L5
         SPACE     3
***********************************************************************
*        OBTAIN THE ADDRESS OF THE TIOT                               *
***********************************************************************
         USING     CSAVER,RC
JTIOT    CENT      JSAVE
         EXTRACT   JTIOTSAV,'S',FIELDS=(TIOT)
         L         R1,JTIOTSAV
         B         CRET
JTIOTSAV DC        A(*-*)
         $FREE     RP,R13                                          V1L5
         SPACE     3
***********************************************************************
*        DCB FOR WATLIB                                               *
***********************************************************************
WATLIB   DCB       DSORG=PO,MACRF=R,DDNAME=WATLIB,RECFM=FB,            C
               EODAD=JENDLIB,SYNAD=JERRLIB,BUFNO=0,BUFCB=0         V1L2
         EJECT
.JLIB    ANOP
***********************************************************************
*****    ROUTINES USED TO HANDLE TIMING                           *****
***********************************************************************
*         INPUTS
*          -&TIMER IS A PARAMETER SET IN 'OPTIONS AT ASSEMBLY TIME
*           BY THE INSTALATION
*          -REG 0 POINTS TO AN ADCON CONTAINING TNE ADDRESS OF THE
*           THE EXIT ROUTINE(I.E. IF JOB RUNS OVER TIME ALLOTEMENT)
*          -REG 1 POINTS TO A LOCATION CONTAINING THE TIMER INTERVAL
*           (THE VALUE IS STORED IN                 )
*          -NOTE: WATFIV SETS R1 TO F'10000000' FOR COMPILE TIME
*                 AND TO THE VALUE SPECIFIED ON THE JOB CARD OR
*                 THE DEFAULT AT RUN TIME.
***********************************************************************
         USING     CSAVER,RC
JSTIMER  CENT      JSAVE
***********************************************************************
         AIF       ('&OPSYS' NE 'DOS').JDOS11                      DVS1
         LA        R5,JGETTT           GET ADDR OF TIME ROUTINE    DOS2
         BALR      R4,R5               GO GET TIMERS               DOS2
         A         R3,0(R1)            ADD REQUESTED TIME INTERVAL DOS2
         ST        R3,JTIMOUT          SAVE EXPECTED TIME OUT      DOS2
         AGO       .JDOS1                                          DOS2
.JDOS11  ANOP                                                      DVS1
         AIF       ('&OPSYS' NE 'DOSVS').JDOS2                     DVS1
         L         R1,ZR1              (R1) = TIMER INTERVAL       DVS1
         SETIME    (1)                 SET INTERVAL TIMER          DVS1
         L         R2,4(,R13)          PTR TO PREVIOUS SAVE AREA   DVS1
         L         R0,20(,R2)          RESTORE R0 AFTER MULTIPLY   DVS1
         STXIT     IT,(0),JSVAR        SET UP LINKAGE FOR IT EXIT  DVS1
         AGO       .JDOS1                                          DVS1
.JDOS2   ANOP                                                      DVS1
         STIMER    &TIMER,(0),TUINTVL=(1)
.JDOS1   ANOP                                                      DOS2
         B         CRET
         AIF       ('&OPSYS' NE 'DOSVS').JDOS3                     DVS1
JSVAR    DS        18F                 SAVE AREA FOR INT TIMER EXITDVS1
.JDOS3   ANOP                                                      DVS1
         SPACE
         $FREE     RP,R13                                          V1L5
***********************************************************************
*        THE TIMER CANCEL ROUTINE
*        OUTPUTS
*          REG 0 CONTAINS THE TIME REMAINING IN THE TIMER INTERVAL
*          SET BY THE PREVIOUS STIMER
***********************************************************************
JTCANCEL CENT      JSAVE
         AIF       ('&OPSYS' NE 'DOS').JNODOS                      DOS2
         LA        R5,JGETTT           GET ADDR OF TIMERS ROUTINE  DOS2
         BALR      R4,R5               GO TO IT                    DOS2
         L         R0,JTIMOUT          GET EXPECTED TIME OUT       DOS2
         SR        R0,R3               GET DIFFERENCE              DOS2
         AGO       .JDOSXY                                         DOS2
.JNODOS  ANOP                                                      DOS2
         TTIMER    CANCEL
.JDOSXY  B         CRET                RETURN                      DOS2
         $FREE     RP,R13                                          V1L5
         AIF       ('&OPSYS' NE 'DOS').J9                          DVS1
*                                                                  DOS2
*        TIMERS ROUTINE                                            DOS2
*                                                                  DOS2
         USING     *,R5                                            DOS2
JGETTT   LR        R2,R1               SAVE R1                     DVS2
         GETIME    TU                  GET THE TIME                DVS2
         LR        R3,R1               R3 = TIME                   DVS2
         LR        R1,R2               RESTORE R1                  DVS2
         AIF       ('&TIMER' NE 'TASK').NODOPE                     DOS2
         L         R2,XTIMER           GET ADDR OF JAI TIMER       DOS2
         AL        R3,0(R2)            GET CURRENT JAI INTERVAL    DOS2
         L         R2,XPARTIME         GET CPU TIMER ADDR          DOS2
         AL        R3,0(R2)            ADD CPU TIME                DOS2
         AL        R3,4(R2)            ADD OVERHEAD TIME           DOS2
.NODOPE  BR        R4                  RETURN                      DOS2
         $FREE     R5                                              DVS1
         SPACE     5
         AIF       ('&TIMER' NE 'TASK').NOJJT                      DOS2
JJTIME   CENT      JSAVE                                           DOS2
         COMRG                                                     DOS2
         L         R1,136(R1)          GET COM REG EXTENSION       DOS2
         LM        R1,R2,52(R1)        GET ADDR OF JAI TABLES      DOS2
         LA        R1,28(R1)           GET JAI TIMER ADDR          DOS2
         ST        R1,XTIMER           SAVE IT FOR FUTURE REFERENCEDOS2
         LA        R2,28(R2)           GET CPU TIME ADDR           DOS2
         ST        R2,XPARTIME         STASH IT ALSO               DOS2
         B         CRET                RETURN                      DOS2
         $FREE     RP,R13                                          DVS1
.J9      ANOP                                                      DVS1
         AIF       (&NDVSD).J11                                    DVS1
.NOJJT   ANOP                                                      DVS1
         AIF       ('&MEMTYPE' NE 'MAX').J10A                      DVS1
JGET     CENT      JSAVE                                           DOS3
         L         R2,0(R1)            GET ADDR OF STORAGE REQ     DOS3
         LM        R3,R4,0(R2)         GET STORAGE RANGE           DOS3
         LA        R3,7(R3)            MAKE DOUBLEWORD BOUND       DOS3
         N         R3,=F'-8'                                       DOS3
         LA        R4,7(R4)            MAKE DOUBLEWORD BOUND       DOS3
         N         R4,=F'-8'                                       DOS3
         LM        R5,R6,XS@VE3        GET RANGE OF AVAILABLE CORE DOS3
         SR        R6,R5               GET AMOUNT OF AVAILABLE COREDOS3
         LA        R15,4               SET FOR ERROR EXIT          DOS3
         CR        R3,R6               IS AMT LT MIN CORE REQUEST  DOS3
         BH        CRET                ERROR IF YES                DOS3
         CR        R4,R6               IS AMT GT MAXIMUM REQUESR   DOS3
         BNH       *+6                 BR IF NO                    DOS3
         LR        R4,R6               GIVE HIM ALL WE'VE GOT      DOS3
         L         R2,4(R1)            GET ADDR OF ANSWER BOX      DOS3
         ST        R5,0(R2)            STASH ADDD OF NEW CORE      DOS3
         ST        R4,4(R2)            AND AMOUNT OBTAINED         DOS3
         AR        R5,R4               GET START OF REMAINDER      DOS3
         ST        R5,XS@VE3           SAVE FO FUTURE REFERENCE    DOS3
         SR        R15,R15             INDICATE ALL OK             DOS3
         B         CRET                RETURN                      DOS3
JFREE    CENT      JSAVE                                           DOS3
         L         R2,4(R1)            GET ADDR OF PARAMS          DOS3
         L         R2,0(R2)            GET ADDR OF FREED CORE      DOS3
         LA        R2,7(R2)            DOUBLEWORD BOUND            DOS3
         N         R2,=F'-8'                                       DOS3
         ST        R2,XS@VE3           SAVE FOR FUTURE REFERENCE   DOS3
         B         CRET                RETURN                      DOS3
JGETFREE CENT      JSAVE                                           DOS3
         COMRG                         GET COM REG ADDR            DOS3
         LM        R2,R3,32(R1)        GET HI-CORE & HI-PHASE END  DOS3
         LA        R3,7(R3)            DOUBLEWORD BOUND            DOS3
         N         R3,=F'-8'                                       DOS3
         N         R2,=F'-16'                                      DOS3
         ST        R2,XS@VE3+4         STASH END-OF-PARTN          DOS3
         ST        R3,XS@VE3           STASH NEXT AVAIL CORE       DOS3
         B         CRET                RETURN                      DOS3
XS@VE3   DS        2F                                              DOS3
         $FREE     RP,R13                                          DVS1
         AGO       .J10                                            DOS3
.J10A    ANOP                                                      DOS3
XS@VE3   DC        2F'0'                                           DOS3
         AGO       .J10                                            DOS3
.J11     ANOP                                                      DOS3
         AIF       ('&MEMTYPE' NE 'MAX' AND '&LIBRARY' EQ 'NO').J10
***********************************************************************
*            ROUTINES USED FOR CORE MANAGEMENT
***********************************************************************
*            FIRST THE GETMAIN ROUTINE
*       INPUTS:
*           -ADDRESS OF A INFORMATION BLOCK IN REGISTER 1
*              ITEM 1 -  ADDR OF REQUEST RANGE (WORD)
*              ITEM 2 -  ADDR OF OUTPUT RESULTS (WORD)
*              ITEM 3 -  CODES FOR GETMAIN (HALF-WORD)
*        WHERE
*         -REQUEST RANGE IS TWO FULL WORDS CONTAINING THE MIN AND
*          MAX RANGE OF CORE REQUIRED (IF MIN=MAX => FIXED AM'T)
*           -OUTPUT FILLED  IN BY GETMAIN HAS  ITS FIRST WORD
*            CONTAINING THE ADDRESS OF THE CORE OBTAINED AND
*            THE SECOND WORD CONTAING THE LENGTH(BYTES) OBTAINED
*      NOTES:
*          1. THE AREA OBTAINED MUST BE CONTIGUOUS
*          2. GETMAIN USES SUBPOOL 1
*               (IN A 'MONITOR-LIKE' ENVIRONMENT
*                 --'ATTACH,LINK,LOAD'--
*                WATFIV WILL FREE ITS CORE WHEN THE FREEMAIN
*                IS ISSUED
***********************************************************************
JGET     CENT      JSAVE
         GETMAIN   VC,MF=(E,(1)),SP=&SUBPOOL                       V1L4
         B         CRET
         SPACE     3
***********************************************************************
*            THE FREEMAIN ROUTINE
*        INPUTS:
*          -ADDRESS OF INFORMATION BLOCK IN REGISTER 1
*            ITEM 1 ADDRESS OF FREEMAIN INFO
*            ITEM 2 CODE FOR FREEMAIN
*        WHERE
*        -FREEMAIN INFO HAS AS ITS FIRST WORD THE ADDRESS OF THE
*         BLOCK OF CORE TO BE FREED  AND WORD TWO CONTAINS THE
*         LENGTH
***********************************************************************
JFREE    CENT      JSAVE
         FREEMAIN  V,MF=(E,(1)),SP=&SUBPOOL                        V1L4
         B         CRET
         SPACE
         $FREE     RP,R13,RC                                       V1L5
.J10     ANOP
         SPACE     5
JSAVE    DS        18F
         LTORG
         TITLE     ' '
