         TITLE     'STARTB     EXECUTION TIME ROUTINES'
         USING     XIOBASE,R15
XIOBASE  DC       0H'0'
*******************************************************************
*******************************************************************
*********                                                **********
*********               MAIN I/O ROUTINES                **********
*********                                                **********
*******************************************************************
*******************************************************************
         EJECT
         AIF       ('&CHARVAR' EQ 'OMIT').XNCHVR3
*******************************************************************
*********          I/O LIST HANDLING ROUTINES             *********
*********          FOR CHARACTER VARIABLES                *********
*******************************************************************
*                                                                 *
*        THESE 3 ROUTINES ARE USED FOR CHARACTER VARIABLES IN I/O *
*        LISTS,AND CORRESPOND TO XSIMPELT , XSUBSELT AND XARRAY   *
*                                                                 *
*        INPUTS:   R3        FOR XCHARSUB ONLY                    *
*                            ADDRESS OF V(N)                      *
*                                                                 *
*        OUTPUTS:  R2        ELEMENT LENGTH                       *
*                  R3        ADDRESS OF DATA I.E. VARIABLE        *
*                                                                 *
*******************************************************************
         SPACE
*        ENTRY SIMPLE CHARACTER*N VARIABLES
PCHARSIM L         R3,ZR14             POINTER TO WONDERWORD
         SR        R2,R2               ZERO
         IC        R2,ZR3(RO)          ELEMENT LENGTH
         L           R3,ZR3            ADDRESS OF DATA
         B         XSUBSELT
         SPACE
*        ENTRY FOR CHARACTER*N ARRAY ELEMENTS
PCHARSUB L         R2,ZR14             A(.RTN)
         L           R2,ZR2+12         ELEMENT LENGTH
         B         XSUBSELT
         SPACE
*        ENTRY FOR CHARACTER*N ARRAYS
PCHARARR L         R3,ZR14             A(.RTN)
         L         R2,ZR3+12           ELEMENT LENGTH
         ST        R3,XGIMIKSS+4       SAVE TYPE CODE
         B         XARRBAL
*******************************************************************
.XNCHVR3 ANOP
         EJECT
*******************************************************************
*********               I/O INITIALIZER                  **********
*******************************************************************
*                                                                  *
*    THE FIRST BYTE OF THE PARAMTER LIST IS A CODE WHICH TELLS     *
*    WHAT KIND OF I/O.OPERATION IS DESIRED.                        *
*                                                                  *
*        FLAG           MEANING                                    *
*                                                                  *
*        B'00000000'    SEQUENTIAL FORMATTED INPUT                 *
*        B'00000001'    SEQUENTIAL FORMATTED OUTPUT                *
*        B'00000010'    SEQUENTIAL NON-FORMATTED INPUT             *
*        B'00000011'    SEQUENTIAL NON-FORMATTED OUTPUT            *
*        B'00000100'    SEQUENTIAL FREE INPUT                      *
*        B'00000101'    SEQUENTIAL FREE OUTPUT                     *
*        B'00000110'    NAMELIST INPUT                             *
*        B'00000111'    NAMELIST OUTPUT                            *
*        B'00001000'    DIRECT ACCESS FORMATTED INPUT              *
*        B'00001001'    DIRECT ACCESS FORMATTED OUTPUT             *
*        B'00001010'    DIRECT ACCESS NON-FORMATTED INPUT          *
*        B'00001011'    DIRECT ACCESS NON-FORMATTED OUTPUT         *
*        B'00001100'    DIRECT ACCESS FREE INPUT                   *
*        B'00001101'    DIRECT ACCESS FREE OUTPUT                  *
*        B'00101010'    DIRECT ACCESS FIND       (IMPLIES READ)    *
*        B'00010000'    CONTROL : BACKSPACE                        *
*        B'00010001'    CONTROL : REWIND                           *
*        B'00010010'    CONTROL : ENDFILE                          *
*                                                                  *
*        INPUTS:   R1     CONTAINS DSRN                            *
*                                                                  *
*        OUTPUTS:  R1     POINTER TO FORMAT STACK                  *
*                  R2     ADDRESS OF BUFFER                        *
*                  R3     LENGTH OF BUFFER                         *
*                  R14    RETURN ADDRESS IN OBJECT CODE            *
*                                                                  *
********************************************************************
         EJECT
PIOINIT  STM       R5,R14,XIOSAVE
         IF        (XIORECUR,EQ,X'FF'),XIORBOOT I/O RECUR SW ON ?  V1L1
         SR        R2,R2
         ST        R2,XXFORMAT         INITIALIZE FOR FREE I/O
         MVC       XBASADDR(4),XAFMCNB  --BASE ADDR FOR FORMCONV
         MVC       XDSRN+5(7),ZR14+1   END=,ERR= ADDRS
         STH       R1,XDSRN+2          SAVE UNIT #
         IC        R2,ZR14             PICK UP FLAG
         AIF       ('&RDONLY' EQ 'OMIT').READOK                    V1L5
         CH        R1,=H'&READSTR'     UNIT < &READSTR ?           V1L5
         BL        PREADOK             YES                         V1L5
         CH        R1,=H'&READEND'     UNIT > &READEND ?           V1L5
         BH        PREADOK             YES                         V1L5
         AIF       ('&DIRACC' EQ 'OMIT').PREADOK                   V1L5
         TM        ZR14,X'09'          DA FORMATTED OUTPUT ?       V1L5
         BO        PERRUNP             YES                         V1L5
         TM        ZR14,X'0B'          DA NON-FORMATTED OUTPUT ?   V1L5
         BO        PERRUNP             YES                         V1L5
.PREADOK ANOP                                                      V1L5
         TM        ZR14,X'12'          ENDFILE ?                   V1L5
         BO        PERRUNP             YES                         V1L5
PREADOK  DS        0H                                              V1L5
.READOK  ANOP                                                      V1L5
         STC       R2,XFINDSW          SAVE
         N         R2,KF7              LEAVE ONLY TYPE OF I/O
         IF        (ZR14,ON,XXCNTRL),PCONTROL     A CONTROL STAT ?
         IFANY     (ZR14,NON,X'01'),(ZR14,EQ,X'07'),PIOIMISS       V1L1
         MVI       XIORECUR,X'FF'      YES SO SET I/O RECURSIVE SW V1L1
PIOIMISS EQU       *                                               V1L1
         STC       R2,XIOFLAG          SAVE FLAG
         IC        R2,XTAB1(R2)        PICK UP CODE BYTE
         STC       R2,XINITYPE         SAVE FOR FIOCS
         LA        R2,XNOFORM          RETURN INDEX:BIN OR FREE
         IF        (ZR14,MIX,XBINFREE),XINIT4 BINARY OR/FREE I/O ?
         LA        R2,XFORM            RETURN INDEX:BCD OR NAMELIST
         L           R1,ZR14+XNOFORM  GET FORMAT OR NAMELIST ADDR.
         BO        XINIT               NAMELIST
         IF        (ZR14+XNOFORM,OFF,XVARFORM),XINIT VAR. FMT ?
         L         R9,XAFORMTX         YES.PICK UP ROUTINE ADDRESS
         LA        R4,4                FOR INDEXED BRANCH IN FORMAT
         BALR      R1,R9               PROCESS OBJ. FORMAT
         L         R1,XENDDATA         FORMAT LIST ADDR
         EJECT
********************************************************************
*                                                                  *
*        OFF TO INITIALIZE THE UNIT                                *
*        THE DSRN CONTAINS THE ACTUAL UNIT AND A CODE INDICATING   *
*        WHETHER   EOF AND ERR EXITS ARE PRESENT                   *
*        ON RETURN   R2  WILL POINT TO THE BUFFER OBTAINED AND R3  *
*        CONTAINS THE BUFFER LENGTH                                *
*        FOR DIRECT ACCESS I/O CONTROL IS TEMPORARILY RETURNED     *
*        TO THE OBJECT CODE TO CALCULATE THE RECORD POSITION.      *
*        NOTE. IN CASE OF A READ THE RECORD HAS BEEN READ AND PLACED
*        IN THE BUFFER                                             *
*        IN THE CASE OF A WRITE THE RECORD MAY NOT BE WRITTEN      *
*        UNTIL THE NEXT REQUEST FOR OUTPUT BUFFER SPACE,OR UNTIL   *
*        THE END OF AN I/O LIST OCCURS.                            *
*                                                                  *
*                                                                  *
********************************************************************
XINIT    ST        R1,XXFORMAT         SAVE FOR FORMCONV
         AIF       ('&DIRACC' EQ 'OMIT').XNODA2
XINIT4   TM        ZR14,XXDAIO         TEST FOR DIRECT ACCESS
         LA        R14,ZR14(R2)        RETURN ADDRESS
         BCR       ZIFON,RDONE         RETURN TO OBJECT CODE
.XNODA2  AIF       ('&DIRACC'EQ'USE').XDA88
XINIT4   LA        R14,ZR14(R2)        RETURN ADDRESS
.XDA88   ANOP
         MVI       XFDSWT,C'F'
         L         R1,XAFIOCS          ADDRESS OF BUFFER ROUTINE
         AIF       ('&DIRACC' EQ 'OMIT').XNODA3
         B         XINTBALR
         AIF       ('&RDONLY' EQ 'OMIT').NOUNP                     V1L5
PERRUNP  $ERROR    (TRAZ,UN,P)         WRITING ON READ ONLY FILE   V1L5
.NOUNP   ANOP                                                      V1L5
         EJECT                                                     V1L1
*******************************************************************V1L1
*                                                                 *V1L1
*        ENTRY FOR DIRECT ACCESS I/O                              *V1L1
*                                                                 *V1L1
*******************************************************************V1L1
PIOINTDA L         R5,XR14RET          PARM ADDR FOR DIOCS
         AIF       ('&DADEBUG' EQ 'OMIT').NODABG1                  V1L2
         IF        (XDEBUGSW,EQ,X'FF'),XDABOOT DEBUG->NO D.A.      V1L2
.NODABG1 ANOP                                                      V1L2
         LR        R3,R1               RECORD POS'N
         ST        R3,XDARECNO         SAVE RECORD NO.FOR ERROR ROUT
         MVI       XFDSWT,C'D'
         L         R1,XAIBCNT1         ADDRESS OF BUFFER ROUTINE   V1L5
         IF        (XFINDSW,NON,XXFIND),DAINTRD  FIND?             V1L2
         MVI       XDSRN,X'40'         YES                         V1L2
         B         XINTBALR                                        V1L2
DAINTRD  MVI       XDSRN,X'30'         NO                          V1L2
.XNODA3  ANOP
XINTBALR ST        R1,XRADDR           SAVE BUFF. ROUT. ADDR.
         ST        R14,XR14RET         RETURN ADDRESS TO OBJECT CODE
         LA        R2,XDSRN            FOR FIOCS AND DIOCS
         BALR      R0,R1               OFF TO FIOCS OR DIOCS
         DC        AL1(0)
XINITYPE DC        X'00'
*        R2 POINTS TO THE BUFFER JUST READ OR TO THE BUFFER TO BE
*        FILLED FOR OUTPUT.  R3 CONTAINS THE BUFFER LENGTH
XBACK    IF        (XFINDSW,ON,XXFIND),XBCKFIND  IS THIS A FIND STAT ?
         L         R1,XXFORMAT         FOR MILNE
         SR        R4,R4
         IC        R4,XIOFLAG          CODE
XBACKCC  SLA       R4,2                FOR INDEXING
         L         R0,XTAB3(R4)        A(FORMAT CONVERSION)
         ST        R0,XXADDR
         L         R4,XTAB2(R4)        A(FORMAT CONVERSION INIT,ZER)
         C         R1,XAXBOOT          BAD NEWS FORMAT STATEMENT?  V1L2
         BNE       PEXIT1              NO                          V1L2
         B         XBOOT               YES,GAME OVER               V1L2
XBCKFIND LM        R5,R14,XIOSAVE
         BR        R14                 RETURN TO OBJECT CODE
         AIF       ('&PROFILE' EQ 'OMIT').PROF7                    V1L5
*******************************************************************V1L5
*******************************************************************V1L5
***                 WATFIV PROFILER                             ***V1L5
***  THE FOLLOWING ROUTINE IS ENTERED IF A $PROFON CARD WAS     ***V1L5
***  ENCOUNTERED AT COMPILE TIME.  THIS COMPRISES THE           ***V1L5
***  EXECUTION OVERHEAD OF THE PROFILER AND IS USED TO BUMP UP  ***V1L5
***  THE FREQUENCY COUNT EVERY TIME AN EXECUTABLE INSTRUCTION   ***V1L5
***  IS ENCOUNTERED.                                            ***V1L5
*******************************************************************V1L5
*******************************************************************V1L5
PCHKCNT  CLI       2(R11),X'FF'        COUNT THIS ONE ?            V1L5
         BNE       ZR11+2              NO                          V1L5
         L         R1,6(,R11)          GET THE OLD COUNT           V1L5
         A         R1,KF1              ADD ONE TO IT               V1L5
         ST        R1,6(,R11)          STORE IT BACK               V1L5
         CLI       6(R11),X'C0'        IS THE CODE GT C0 ?         V1L5
         BH        ZR11+10             YES                         V1L5
***** THE NEXT 3 INSTRUCTIONS MUST NOT CHANGE THE CONDITION CODE * V1L5
         L         R1,XTOTCNT1         GET THE OLD COUNT     ***** V1L5
         LA        R1,1(,R1)           BUMP IT               ***** V1L5
         ST        R1,XTOTCNT1         STORE IT BACK         ***** V1L5
         BNE       ZR11+10             SKIP FIRST COUNT IF NOT     V1L5
         B         ZR11+14             SKIP SECOND COUNT           V1L5
PIFOBJ   L         R1,10(,R11)         GET OLD COUNT               V1L5
         LA        R1,1(,R1)           BUMP BY 1                   V1L5
         ST        R1,10(,R11)         STORE IT BACK               V1L5
         L         R1,XTOTCNT2         GET THE OLD COUNT           V1L5
         LA        R1,1(,R1)           BUMP IT                     V1L5
         ST        R1,XTOTCNT2         STORE IT BACK               V1L5
         BR        R14                 RETURN TO OBJECT CODE       V1L5
.PROF7   ANOP                                                      V1L5
         EJECT
         AIF       ('&CHARVAR' EQ 'OMIT').XNCHVR4
*******************************************************************
*********               CORE TO CORE I/O                 **********
*******************************************************************
*                                                                 *
*        NOTE:     IN THIS CODING  V1 REFERS TO THE UNIT,I.E. THE *
*        DSRN CHARACTER VARIABLE AND V2 REFERS TO THE FORMAT      *
*        CHARACTER VARIABLE.EITHER MAY APPEAR WITH SUBSCRIPTS. THE*
*        FORMAT MAY,OF COURSE, BE A FORMAT STATEMENT NUMBER.      *
*                                                                 *
*        WHENEVER THE FORMAT IS AN ARRAY ELEMENT CONTROL IS       *
*        TEMPORARILY RETURNED TO THE OBJECT CODE TO CALCULATE     *
*        THE ADDRESS OF THAT ELEMENT.CONTROL RETURNS TO 'XIOCCFRM'*
*                                                                 *
*                                                                 *
*        INPUT     R3     VALID ONLY IF V1(N)=A(V1(N))            *
*                                                                 *
*        OUTPUT    R1     ADDRESS OF FORMAT STACK                 *
*                  R2     ADDRESS OF BUFFER                       *
*                  R3     LENGTH OF BUFFER                        *
*                                                                 *
*                                                                 *
*                                                                 *
*******************************************************************
         SPACE
PIOINTCC STM       R5,R14,XIOSAVE      SAVE FOR RETURN
         IF        (XIORECUR,EQ,X'FF'),XIORBOOT  I/O RECUR SW ON ? V1L1
         IF        (ZR14+4,NON,X'01'),PIOINC1 AN OUTPUT OP ?       V1L1
         MVI       XIORECUR,X'FF'      YES, SO SET SW              V1L1
PIOINC1  MVI       XMORESW,0                                       V1L2
         MVC       XBASADDR(4),XAFMCNB
         L         R0,ZR14             A(.RTN) OF V1 IF DIM'D
         ST        R0,XBYADD
         IC        R4,ZR14+4                SAVE FLAG FOR LATER
         STC       R4,XIOFLAG
         SPACE
**       WHAT KIND OF CHAR VARIABLE IS V1 ?
         SPACE
         IF        (ZR14+4,OFF,XV1SIM),PV1SIM    SIMPLE VARIABLE ?
         IF        (ZR14+4,ON,XV1ELT),PV1ELT     ARRAY ELEMENT ?
*        IT'S AN ARRAY
         LR        R3,R0               A(.RTN)
         BAL       R1,X1STELT          GET A(V1(1)) IN R3
         B         PV1ELT              GO TO COMMON PLACE
*        IT' A SIMPLE VARIABLE
PV1SIM   L         R3,ZR14             A(WONDER WORD)
         L           R3,ZR3            A(V1)
*        IT'S AN  ARRAY ELEMENT        R3=A(V1(N))
PV1ELT   SR        R2,R2               ZERO R2
         IC        R2,ZR14             ELEMENT LENGTH OF V1
         STM       R2,R3,XR2SAVE       SAVE LENGTH AND ADDRESS
         EJECT
*****    GET ADDRESS OF V2 AND LENGTH
         IF        (ZR14+4,ON,XVARFORM),XNOTSTAT  VARIABLE FORMAT?
**       COME HERE FOR STATEMENT # FORMATS
XSTATFRM L         R1,ZR14+4           FORMAT ADDRESS
         LA        R14,ZR14+8          RETURN ADDRESS
         B         XSTOFO                                          V1L2
         SPACE
**       WHAT KIND OF CHARACTER VARIABLE IS V2 ?
         SPACE
XNOTSTAT IF      (ZR14+4,NOFF,XV2SIM),PV2NSIM       SIMPLE VARIABLE
**       COME HERE FOR SIMPLE CHARACTER VARIABLE FORMAT
PV2SIM   L         R3,ZR14+4           PICK UP A(WONDER WORD)
         SR        R2,R2
         IC        R2,ZR3(RO)          PICK UP ELT. LENGTH
         L         R3,ZR3              ADDRESS OF BUFFER
         LA        R3,ZR3              GET RID OF HIGH ORDER JUNK
         B         XCCFORM
PV2NSIM  IF        (ZR14+4,OFF,XV2ELT),PV2ARR    ARRAY ELEMENT ?
         B         ZR14+8              GO CALCULATE A(V2(N))
         SPACE
**       RETURN HERE AFTER CALCULATING A(V2(N)) IN R3
PIOCCFRM L           R1,XR14RET        OBJECT CODE PARMS
         LA        R4,ZR3              SAVE IT
         L         R3,ZR1+4            A(.RTN) OF V2
         BAL       R1,X1STELT          GET A(V2(1)) AND LEN(V2)
         LA        R3,ZR3              ZERO HIGH ORDER CRAP
         AR        R2,R3               A(V2(1))+LEN(V2)
         SR        R2,R4               A(V2(1))+LEN(V2)-A(V2(N))
         LR        R3,R4
         B         XCCFORM4
PV2ARR   L         R3,ZR14+4           A(.RTN) OF V2 FOR FORMAT
         BAL       R1,X1STELT          GET  A(V2(1)) AND LEN(V2)
         EJECT
**       COME HERE WITH R2=LEN(V2) AND R3=A(V2)
**       THEN GO TO FORMAT PROCESSOR
XCCFORM  LA        R14,ZR14+8          RETURN ADDR IN OBJECT CODE
XCCFORM4 L         R9,XAFORMTX         PICK UP ADDCON
         SR        R4,R4               FOR INDEXED BRANCH IN FORMAT
         BALR      R1,R9               PROCESS OBJECT FORMAT
         L         R1,XENDDATA         ADDRESS OF FORMAT STACK
XSTOFO   LM        R3,R4,XR2SAVE       PICK UP LENGTH AND ADDRESS
         LR        R2,R4               R2=BUFF.ADD. , R3=BUFF.LEN.
         STM       R2,R3,XR2SAVE       R2=BUFF.ADD. , R3=BUFF.LEN.
         IF        (XIOFLAG,OFF,X'01'),XSTOFOFO       IS THIS A READ ?
         MVI       ZR2,C' '            WE HAVE TO BLANK BUFFER
         C         R3,KF1
         BE        XSTOFOFO
         S         R3,KF2              LENGTH -2
         BM        XSTOFOFO
         EX        R3,XMORBLNK         PROPAGATE BLANK
         LA        R3,ZR3+2
XSTOFOFO IC        R4,XIOFLAG
         N         R4,KF1              READ=0,WRITE=1 FOR XBACK
         IF        (XIOFLAG,OFF,XV2FREE),*+8 FREE C-C ?            V1L1
         LA        R4,ZR4+4            INDICATE C-C                V1L1
         L         R0,=A(XIOCCMOR)              A(BUFFER ROUTINE)
         ST        R0,XRADDR
         ST           R14,XR14RET      OBJECT CODE RETURN ADDRESS
         B         XBACKCC
         EJECT
*******************************************************************
*********          CORE TO CORE BUFFER ROUTINE            *********
*******************************************************************
*                                                                 *
*                                                                 *
*                  THIS SPACE FOR RENT                            *
*                                                                 *
*                                                                 *
*******************************************************************
XIOCCMOR L         R15,XAXIOB          LOAD OUR BASE REGISTER
         LTR       R3,R3               END OF STATEMENT ?
         LR        R4,R0               RETURN ADDRESS
         BM        XMORET              YES,DON'T DO ANYTHING
         IF        (XIOFLAG,OFF,XV1SIM),XSIMPERR  CAN'T EXTEND SIMVAR
         IF        (XMORESW,EQ,X'FF'),XNOTFIST
         L         R3,XBYADD           ADDRESS OF DOT ROUTINE
         BAL       R1,X1STELT
         AR        R2,R3
         ST        R2,XENDARR          SAVE FOR COMPARE
         MVI       XMORESW,X'FF'       SET SWITCH
XNOTFIST LM        R2,R3,XR2SAVE       RESTORE REGS
         AR        R2,R3               POINT TO NEXT ELEMENT
         C         R2,XENDARR          IS IT  HIGH
         BNL       XSIMPERR            HAVE REACHED END OF ARRAY
         STM       R2,R3,XR2SAVE
         IF        (XIOFLAG,OFF,X'01'),XMORET    IS THIS A READ ?
         MVI       ZR2,C' '            WE MUST BLANK BUFFER
         S         R3,KF1              LENGTH-1                    V1L4
         BM        XMORET              LENGTH < 1 ?
         EX        R3,XMORBLNK         PROPAGATE
         LA        R3,ZR3+2            RESTORE LENGTH
XMORET   L         R15,XAFMCNB         RESTORE FORMCONV'S BASE REGISTER
         B         ZR4+2               RETURN TO FORMCONV
XSIMPERR LA        R14,XAUNK
         B         PERROR11
XMORBLNK MVC       ZR2+1(*-*),ZR2
*******************************************************************
.XNCHVR4 ANOP
XAUNK    DC        AL2(UNK)
         AIF       ('&ISNTRAC' EQ 'OMIT').XISNGO4  ISN TRACE?      V1L2
XISNOUT  LA        R2,XOUTDSRN                                     V1L2
         L         R1,XAFIOCS          THIS FIRST CODING           V1L2
         BALR      R0,R1               IS TO INITIALIZE &PRINT     V1L2
         DC        X'00'                                           V1L2
         DC        X'FF'                                           V1L2
         ST        R2,XBUFFER                                      V1L2
         LH        R3,ZR11             NOW FOR OUTPUT              V1L2
         CVD       R3,XDOUBLE          THIS CODING                 V1L2
         MVC       XISNBUF(5),XEDMASK+4  PRINTS OUT THE            V1L2
         ED        XISNBUF-1(6),XDOUBLE+5  CURRENT ISN             V1L2
         L         R4,72(,R13)         AND                         V1L2
         MVC       XISNAME,2(R4)       CURRENT RTN NAME            V1L2
         SPRIN     XISNTIT,XISNEND-XISNTIT  OUTPUT LINE            V1L2
         B         XISNVM              RETURN                      V1L5
XISNTIT  DC        C' *** ISN = '                                  V1L2
XISNBUF  DS        CL5                                             V1L2
         DC        C'  IN ROUTINE '                                V1L2
XISNAME  DS        CL6                                             V1L2
         DC        C' ***'                                         V1L2
XISNEND  EQU   *                                                   V1L2
.XISNGO4 ANOP                                                      V1L2
         EJECT
         EJECT
         AIF       ('&VM' NE 'USE').XVM91                          VM1
XVMDEBUG L         R15,=V(VMMONITR)                                VM1
         BR        R15                                             VM1
.XVM91   ANOP                                                      VM1
         AIF       ('&DIRACC' EQ 'OMIT').XNODA4
*******************************************************************
*****************     DEFINE FILE INITIALIZER      ****************
*******************************************************************
*                                                                 *
*        CALLING SEQUENCE:                                        *
*                  BAL    R14,XDEFILE                             *
*                  B      ZR14+N*12+4    BRANCH AROUND LIST       *
*                  DC     (N*12)X        PARAMETER LIST           *
*                                                                 *
*******************************************************************
PDEFILE  LA        R0,XDSRN+3          SET R0 FOR DIOCS            V1L2
         STM       5,14,XIOSAVE        SAVE IN CASE OF ERROR MSG
         IF        (XIORECUR,EQ,X'FF'),XIORBOOT  I/O RECUR SW ON ? V1L1
         AIF       ('&DADEBUG' EQ 'OMIT').NODABG2                  V1L2
         IF        (XDEBUGSW,EQ,X'FF'),XDABOOT DEBUG->NO D.A.      V1L2
.NODABG2 ANOP                                                      V1L2
         LR        R2,R14
         S         R2,KF4              POINT TO BAL R14,XDEFILE  INST
         L         R3,XNOPBALR         OVER-WRITE OBJECT CODE TO SET
         ST        R3,ZR2              UP R14 FOR THE BRANCH AROUND
         LA        R1,ZR14+4           POINT TO PARAMETER LIST
         L         R3,XADIOCS          PICK UP ADDRESS
         LR        R15,R3              FOR DIOCS ADDRESSING
         BR        R15                 DEFINE FILE INITIALIZATION
*******************************************************************
.XNODA4  ANOP
         EJECT
*******************************************************************
*********          REWIND  ENDFILE  AND  BACKSPACE       **********
*******************************************************************
*        THESE ROUTINES ARE BASICALLY COPIES OF
*        'FBKSP' , 'FRWND' AND 'FEFM' IN IHCFCOMH
*******************************************************************
PCONTROL EQU       *
         MVC       XDSRN+4(8),XINPDSRN+4  SAVE IN CASE OF I/O ERROR
         STC       R2,PCON1            0,1,ORO2 :SAVE FOR FIOCS
PCNTRL1  LA        R2,XDSRN            UNIT WORD
         L         R1,XAFIOCS
         BALR      R0,R1               OFF TO FIOCS
         DC        X'03'
PCON1    DC        X'00'
         B         ZR14+4              NOTE:**** TEMP FIX  ********V1L1
         EJECT
*******************************************************************
*********               ERROR PROCESSOR                  **********
*******************************************************************
*                                                                 *
*        THIS SECTION GENERATES ERROR MESSAGES FOR INCONSISTENCIES*
*        DETECTED IN THE EXECUTION OF AN I/O STATEMENT            *
*                                                                 *
*        ENTRY FROM WATIO                                         *
*                                                                 *
*******************************************************************
         $FREE     R1                                              V1L5
XAERROR# DC        A(ERROR#)
PERROR11 L         R15,XAERROR#
         USING     ERROR#,R15
         B         PERROR
ERROR#   SR        R3,R3
         MVI       XIORECUR,X'00'      SET I/O RECURSIVE SW OFF    V1L1
         IC        R3,6(R14)          GET ERROR CODE
         B     PERRTAB(R3)
PERRTAB  B         PERROR
         B         PSYNAD
         B         PEODAD
         B         PERROR
         B         PDOLLAR
PSYNAD   MVC       31(6,R14),KBL6
         IF        (XEXECSW,OFF),PSYN1
         L         R1,XIOSAVE+24       RECOVER REGISTER 11
         LH        R1,0(,R1)           GET ISN
         N         R1,KM1631           GET RID OF JUNK
         CVD       R1,XTEMP            CONVERT IT
         MVC       32(5,R14),XEDMASK+4
         ED        31(6,R14),XTEMP+5
PSYN1    L         R1,XAFIOCS           ADDR OF FIOCS
         LA        R2,XOUTDSRN
         ST        R14,PSAVE
         BALR      R0,R1               OFF TO FIOCS TO PRINT LINE
         DC        X'00'
         DC        X'FF'
         MVC       0(108,2),10(14)     MOVE MESSAGE TO BUFFER
         LA        R2,108              LENGTH OF MESSAGE
         L         R1,XAFIOCS
         BALR      R0,R1               OFF TO FIOCS TO PRINT LINE
         DC        X'02'
         DC        X'00'
*        IF COMPILE TIME GO TO TERMINATE THE BATCH
         L         R14,PSAVE
         IF        (XEXECSW,OFF),PERROR9
         LA        R1,8                TO PICK UP I/O ERROR ADDR
         B         PERRET
PDOLLAR  LA        R1,4
         THEN      (CIHGACRD,ON)       SAVE THE CARD
         MVC       XCARD(80),ZR2       PUT CARD IN 'CARD BUFFER'
         B         PERRET
PEODAD   LA        R1,4
         MVI       XCARD+L'XCONTROL+L'XBTCHEND-1,X'40'  BLANK      V1L1
         MVC     XCARD+L'XCONTROL+L'XBTCHEND(80-L'XCONTROL-L'XBTCHEND),X
               XCARD+L'XCONTROL+L'XBTCHEND-1                       V1L1
         IF        (XEXECSW,OFF),PERROR9         COMPILE TIME?
         CLI       XDSRN+3,X'&READ'    FROM READER
         BNE       PERRET                                          V1L1
*        SIMULATE A THE READING OF A $STOP CARD
PERROR9  MVC       XCARD+L'XCONTROL(L'XBTCHEND),XBTCHEND
         MVC       XCARD(L'XCONTROL),XCONTROL
         THEN      (CIHGACRD,ON)
         IF        (XEXECSW,ON),PERRET
         USING     CSAVER,R10
         B         CREAD11             RETURN TO COMPILE READ ROUT
         $FREE     R10                                             V1L5
PERROR   IF        (XEXECSW,OFF),PERROR3
         LM        R5,R13,XIOSAVE
PERROR1  LH        R2,XDSRN+2          GET UNIT #
         LR        R15,R14
         $ERROR    (TRAZ,POINTER,R15,INTR2,UNIT)                   V1L5
XIORBOOT $ERROR    (TRAZ,IO,8)                                     V1L5
         AIF       ('&DADEBUG' EQ 'OMIT').NODABG3                  V1L2
XDABOOT  $ERROR    (TRAZ,UN,Q)         NO DA UNDER BATCH/DEBUG     V1L5
.NODABG3 ANOP                                                      V1L2
PERRET   L         R2,XDSRN(R1)
         LM        R5,R13,XIOSAVE
         BR        R2             RETURN TO OBJ CODE OR TO PERROR1
PERROR3  LR        R15,R14
         $ERROR    (NOAC,POINTER,R15,INTR2,UNIT),XSTOP             V1L5
         EJECT
*******************************************************************
*********          I/O TABLES AND CONSTANTS               *********
*******************************************************************
XIOERR   EQU       PERROR1   IF USER DID NOT SUPPLY EXITS
XIOEND   EQU       PERROR1             WE COME HERE
XVARFORM EQU       X'80'               VARIABLE FORMAT INDICATOR
XV1SIM   EQU       B'00011000'         SIMPLE V1 IN C-C I/O
XV1ELT   EQU       B'00010000'         ARRAY ELT V1 IN C-C I/O
XV2SIM   EQU       B'00000110'         SIMPLE V2 IN C-C I/O
XV2ELT   EQU       B'00000100'         ARRAY ELT V2 IN C-C I/O
XV2FREE  EQU       B'01000000'         C-C FREE I/O                V1L1
XBINFREE EQU       X'06'
XXCNTRL  EQU       X'10'
XXFIND   EQU       X'20'               SEE ALSO DIOCS
XDSRN    DC        0F'0',X'3000',H'0'
         DC        2F'0'
PSAVE    DC        A(*-*)
FI       EQU       X'F0'               FORMATTED INPUT CODE
FO       EQU       X'FF'               FORMATTED OUTPUT CODE
BI       EQU       X'00'               NON-FORMATTED INPUT CODE
BO       EQU       X'0F'               NON-FORMATTED OUTPUT CODE
XTAB1    DC        AL1(FI,FO,BI,BO,FI,FO,FI,FO)
XTAB2    DC        A(INBCDI-4)
         DC        A(OUTBCDI-4)
         DC        A(INBINI-4)
         DC        A(OUTBINI-4)
         DC        A(INFREEI-4)
         DC        A(OUTFREEI-4)
         AIF   ('&NAMLIST' EQ 'OMIT' AND '&DUMPLST' EQ 'OMIT').XNONL1A
         DC        A(NAMELRD)
         DC        A(NAMELWR)
.XNONL1A ANOP
XTAB3    DC        A(INBCD)
         DC        A(OUTBCD)
         DC        A(INBIN)
         DC        A(OUTBIN)
         DC        A(INFREE)
         DC        A(OUTFREE)
         AIF   ('&NAMLIST' EQ 'OMIT' AND '&DUMPLST' EQ 'OMIT').XNONL2
         DC        A(NAMELRD+4)
         DC        A(NAMELWR+4)
.XNONL2  ANOP
XCCDIM   EQU       B'00000010'
XXDAIO   EQU       X'08'               BIT FOR DIRECT ACCESS I/O
XAFORMTX DC        A(FORMATEX)
XNOPBALR EQU       *
         NOPR      0
         BALR      R14,0
XR2SAVE  DS        2F
XENDARR  DS        F
XBYADD   DS        F
XXFORMAT DS        F
         SPACE
* CONSTANTS
         SPACE
XASTACK  EQU       XSTACK
XAFMCNB  DC        A(FMCNBASE)
XADIOCS  DC        V(WATDFILE)
XAIBCNT1 DC        V(WATDIOCS)                                     V1L5
KF9      DC        F'9'
XLENTAB  EQU       KT2
XMORESW  DC        X'00'
XIOFLAG  DC        X'0'
XFINDSW  DC        X'0'
         EJECT
XBTCHEND DC        C'&BTCHEND '
         $FREE     R15                                             V1L5
         EJECT
         AIF       ('&SNAPS' EQ 'OMIT').XSN7
*******************************************************************
*********          SNAPSHOT ROUTINE                       *********
*******************************************************************
         SPACE
         USING     XSNAP5,R105
         SPACE
         ENTRY     XSNAP5
XSNAP5   IF        (COPT,NE,C'S'),ZR104+8 * CHECK FOR SNAPS INHIBITED
         ST        R13,XSNAPSAV+4      SET UP FIRST SNAP SAVE AREA
         LA        R103,XSNAPSAV
         ST        R103,ZSVFRWD        LINK CALLING PROGRAM TO IT
         ST        R103,XSNAPSSV+4
         LA        R13,XSNAPSSV
         ST        R13,XSNAPSAV+8
         LR        R100,R1
         LTR       R101,R2
         BM        PERRZZ0
         IF        (XEXECSW,OFF),XSNAP30
         LA        R2,XOUTDSRN
         L         R1,XAFIOCS
         BALR      R0,R1
         DC        X'00'
         DC        X'FF'
         ST        R2,XBUFFER
XSNAP30  MVC       XSNAPOUT(8),ZR104  MOVE IDENTIFIER
XSNAP8   ST        R100,XSNAPADD       ADDRESS OF AREA TO BE SNAPPED
         UNPK      XSNAPLAD(7),XSNAPADD+1(4) * UNPACK FOR IMPENDING
         TR        XSNAPLAD(6),XSNAPTRT * TRANSLATE(INTO HEX)
         MVC       XSNAPOUT+9(104),XSNAPOUT+8 * BLANK OUT LINE
         C         R101,KF31           LAST LINE CHECK
         BL        XSNAP9              BRANCH IF LAST LINE
         MVC       XSNAPOUT+81(32),ZR100 * MOVE LINE
         TR        XSNAPOUT+81(32),XSNAPTRC * AND TRANSLATE
         B         XSNAP9A
XSNAP9   EX        R101,XSNAPMVC       MOVE PARTIAL LINE
         EX        R101,XSNAPTR        AND TRANSLATE
XSNAP9A  LA        R102,8              NUMBER OF WORDS SNAPPED=8
         LA        R103,XSNAPOUT+9     FIRST WORD GOES HERE
XSNAP10  UNPK      ZR103(9),ZR100(5)   UNPACK FOR IMPENDING
         TR        ZR103(8),XSNAPTRT   TRANSLATE(INTO HEX)
         S         R101,KF4            LESS FOUR
         BM        XSNAP20             ARE WE ON LAST WORD
         MVI       ZR103+8,C' '        ZAP OUT GARBAGE CHARACTER
         LA        R100,ZR100+4        INCREMENT SNAPPED OUT ADDRESS
         LA        R103,ZR103+9
         BCT       R102,XSNAP10
         SPRIN     XSNAPLIN,XSNAPLEN-XSNAPLIN
         B         XSNAP8
XSNAP20  IC        R102,XSNAPEXF(R101)
         EX        0,XSNAPEXT(R102)
         SPRIN     XSNAPLIN,XSNAPLEN-XSNAPLIN
         L         R13,XSNAPSAV+4
         B         ZR104+8             RETURN
PERRZZ0  $ERROR    (NOAC,ZZ,0),ZR104+8                             V1L5
ZZ0      EQU       0
         SPACE
XSNAPSSV DS        18F
XSNAPADD DS        F
XSNAPEXT MVC       ZR103+2(7),KBL7
         MVC       ZR103+4(5),KBL7
         MVC       ZR103+6(3),KBL7
         MVI       ZR103+8,C' '
XSNAPTR  TR        XSNAPOUT+81(*-*),XSNAPTRC
XSNAPMVC MVC       XSNAPOUT+81(*-*),ZR100
XSNAPEXF EQU       *+4
         DC        X'00060C12'
         SPACE
XSNAPLIN DC        C' '
XSNAPOUT DC        CL8'*-*'
         DC        C' '
         DS        CL72
         DS        CL32
         DC        C' '
XSNAPLAD DC        CL6'*-*'
XSNAPLEN EQU       *
         DC        CL1'*-*'            WORK AREA
         SPACE
XSNAPTRC DC        C'................................'
         DC        C'................................'
         DC        C' ...............................'
         DC        C'................................'
         DC        C'................................'
         DC        C'................................'
         DC        C'.ABCDEFGHI.......JKLMNOPQR......'
         DC        C'..STUVWXYZ......0123456789......'
         SPACE
KBL7     DC        CL7' '
XSNAPTRT EQU       *-C'0'
         DC        C'0123456789ABCDEF'
         SPACE
         $FREE     R105                                            V1L5
*******************************************************************
.XSN7    ANOP
         EJECT
***********************************************************************
*****    DATA STATEMENT PROCESSOR   (SECOND PART - SEE XDATA)     *****
***********************************************************************
*****    THIS ROUTINE INITIALIZES EACH ELEMENT IN DATA LISTS BY   *****
*****    MORE OR LESS THE SAME MECHANISMS BY WHICH ELEMENTS IN    *****
*****    INPUT LISTS ARE PROCESSED.                               *****
***********************************************************************
XLITCC   EQU       X'08'               CODE FOR LITERAL CONSTANT
         USING     PDATBASE,R15
PDATBASE DC        0H'0'
***  COME HERE VIA XENDLIST IN I/O CODING
PDATA    B         XNDATLST            GOTO END-OF-LIST ROUTINE
         SPACE
****     RETURN HERE FROM OBJECT CODE VIA XARRAY,XSIMPELT,XSUBSELT
***            BY MEANS OF XXADDR,TO PROCESS EACH ELEMENT IN LIST
         EX        0,XNOTNUFF          SEE IF THERE'S ENUFF CONSTANTS
         SR        R4,R4
         LR        R1,R4               DO THIS FOR XHEX AND XHOLDATA
         LR        R0,R2               SAVE R2 FOR XHEX AND XHOLDATA
         IC        R1,XCONELT+1        PICKUP LENGTH-1 OF CONSTANT
         L         R2,XCONELT+4        PICKUP ADDRESS OF CONSTANT
         IC        R4,ZR14             MODE OF VARIABLE TO R4
         CLI       XCONELT+4,XLITCC    IS THIS A LIERAL OR HEX CONSTANT
         BE        XHOLDATA            SPECAL HANDLING
         BH        XHEXDATA            SIMILARLY FOR HEX CONSTANTS
         CLI       ZR14,INT2        CHECK FOR 2 BYTE INT VAR
         BE        XINT2
         CLI       ZR14,LOG1           CHECK FOR 1 BYTE LOGICAL
         BNE       XCHKTYPE
XLOG1    LR        R4,R1               PRETEND VAR IS LOGICAL*4
XCHKTYPE EQU       *
         EX        R4,XCLI             DO VAR AND CONST AGREE
         BNE       XERRDA6             TOUGH
XSAMELEN EQU       *
         EX        R1,XCLCUNDF         WAS IT INITAILIZED PREVIOUSLY
         BE        XNOTPREV
         C         R1,KF15
         BNH       XERRDA61
         CLI       ZR3,X'&UNDEF'       CHECK FOR 17TH BYTE         V1L4
         BE        XNOTPREV
XERRDA61 $ERROR    (WARN,DA,6,ISNR0),,SAVE  VAR PREVIOUSLY DEFINED V1L5
XNOTPREV EQU       *
         EX        R1,XMOVECON         INITIALIZE
XINITP4  EQU       *
         LH        R2,XCONELT+2        DECREASE REPN FACT FOR THIS CON
         BCT       R2,XREPNM1
         LH        R2,XNOCONS          REPNFACT=0,ANY MOR CONSTANTS
         BCT       R2,XMORECNS
         MVI       XNOTNUFF+1,BRA      NO,SET SWITCH IN CASE MORE VARS
XMORECNS STH       R2,XNOCONS
         L         R1,XSVCONPT
         LA        R1,ZR1+8            SET R1 TO NEXT CONLIST ENTRY
         B         XLSTLP1
XREPNM1  STH       R2,XCONELT+2        SAVE REPN FACT FOR THIS CONSTANT
         B         ZR14+4              BACK TO I/O CODING
         SPACE
XINT2    EQU       *
         LA        R4,2                PRETEND VAR IS INT*4
         LA        R2,ZR2+2            INCREAS FOR HIGHORDER 2 BYTES
         LA        R1,1                LENGTH-1 IN BYTES TO R1
         B         XCHKTYPE
         SPACE
XHEXDATA EQU       *
         IF        (ZR14,NE,CHARN),XHEXNCHR      IS THIS NOT CHAR*N
         LR        R4,R0               LENGTH OF VAR TO R4
         B         XHEXCHAR
XHEXNCHR EQU       *
         IC        R4,XLENTAB(R4)      LENGTH OF VAR TO R4
XHEXCHAR EQU       *
         BCTR      R4,0                LENGTH-1
         LR        R0,R4               SAVE IT
         SR        R4,R1               DIFFERENCE LIN LENGTH
         BZ        XSAMELEN
         BP        XHEXPAD
XHEXTRNC EQU       *                   TRUNCATE HEX CONSTANT
         SR        R2,R4               ADJUST ADDRESS OF CONSTANT
         LR        R1,R0               TAKE LENGTH OF VARIABLE
         B         XSAMELEN
XHEXPAD  EQU       *                   LEFT PAD WITH ZEROS
         MVI       ZR3,X'00'           MOVE IN A ZERO
         S         R4,KF2              SET R4 FOR EX INSTR.
         BL        XHEXPAD1
         EX        R4,XMOVZERO
XHEXPAD1 LA        R3,ZR3+2(R4)        ADJUST ADDRESS OF VARIABLE
         B         XSAMELEN
         SPACE
XHOLDATA EQU       *
         IF        (ZR14,NE,CHARN),XHOLNCHR      IS THIS NOT CHAR*N
         LR        R4,R0               LENGTH OF VAR TO R4
         B         XHOLCHAR
XHOLNCHR EQU       *
         IC        R4,XLENTAB(R4)      LENGTH OF VAR TO R4
XHOLCHAR EQU       *
         BCTR      R4,0                LENGTH - 1 OF VARIABLE
         BCTR      R1,0                LENGTH - 1 OF CONSTANT
         LR        R0,R4               SAVE IT
         SR        R4,R1               DIFFERENCE IN LENGTHS
         BZ        XSAMELEN
         BP        XHOLPAD
XHOLTRNC EQU       *                   TRUNCATE HOL CONSTANT
         $ERROR    (WARN,DA,8,ISNR0,HOL4R2),,SAVE                  V1L5
         LR        R1,R0               TAKE LENGTH OF VARIABLE
         B         XSAMELEN            MOVE IT IN
XHOLPAD  EQU       *                   RIGHT PAD WITH BLANKS
         LR        R0,R3
         LA        R3,ZR3+1(R1)    R3-> 1ST CHARACTER AFTER CONSTANT
         MVI       ZR3,C' '          BLANK AT END OF CONST
         S         R4,KF2
         BL        XHOLPAD1            DIFFERENCE MAY BE ONLY 1
         EX        R4,XMOVZERO
XHOLPAD1 LR         R3,R0
         B         XSAMELEN            GO MOVE IN CONSTANT
XMOVZERO MVC       ZR3+1(*-*),ZR3      PROPAGATE '0' OR ' '
         SPACE
XERRDA6  TM        XRAYPROC,X'80'      ARE WE DOING AN ARRAY?      V1L2
         BZ        XGIVEDA4            ERROR IF NO                 V1L2
         TM        XRAYPROC,X'40'      GIVEN DA-4 ALREADY?         V1L2
         BO        XINITP4             BYPASS IF SO                V1L2
         OI        XRAYPROC,X'40'      DA-4 GIVEN FOR THIS ARRAY   V1L2
XGIVEDA4 $ERROR    (NOAC,DA,4,ISNR0),XINITP4,SAVE                  V1L5
         SPACE
***   ENTRY FOR END-OF-I/O LIST IN DATA STATEMENTS
XNDATLST L         R1,XSVCONPT
         CLI       XNOTNUFF+1,BRA      WAS SW SET FOR MORE CONSTANTS
         BE        X1TO1
         $ERROR    (WARN,DA,5,ISNR0)   EXTRA CONSTANTS             V1L5
         LH        R2,XNOCONS          SKIP OVER THE EXTRA CONSTANTS
         SLL       R2,3
         AR        R1,R2
X1TO1    LH        R2,XNOLISTS         ANYMORE SUBLISTS
         BCT       R2,XMORELST
         L         R11,XENTRYPD        NO,NEXT DATA STATEMENT
         BR        R11
XMORELST STH       R2,XNOLISTS         SETUP FOR NEXT LIST
         B         XLSTLOOP
         SPACE
XERRDA2  $ERROR (NOAC,DA,1,ISNR0),XNDATLST MOR VARS THAN CONSTANTS V1L5
         SPACE
XCLI     CLI       XCONELT+4,X'00'
XCLCUNDF CLC       ZR3(*-*),XUNDEF
XMOVECON MVC       ZR3(*-*),ZR2
         $FREE     R15                                             V1L5
         LTORG
         EJECT
***********************************************************************
**                                                                   **
*********   TRACEBACK PRINTOUT ROUTINE                        *********
**                                                                   **
***********************************************************************
         USING     XTRACEB1,R15
         AIF       ('&VM' EQ 'USE').XVM20                          VM1
XTRACEB1 IF        (XDNTRZSW,ON),XDATATRZ                          VM1
         AGO       .XVM21                                          VM1
.XVM20   ANOP                                                      VM1
XTRACEB1 CLI       XVMSWT,X'FF'   IS VMDEBUG IN CONTROL            VM1
         BNE       XTRACEB2            NO SO AWAY                  VM1
         L         R15,=V(VMERROR)                                 VM1
         BR        R15                                             VM1
XTRACEB2 IF        (XDNTRZSW,ON),XDATATRZ                          VM1
.XVM21   ANOP                                                      VM1
         L         R4,XTRCOUNT         GET MAX # OF TRACEBACKS     V1L2
         L         R1,ZR13+72          R1 -> H'ISN',CL6'NAME'      V1L2
         MVC       XTRC(6),ZR1+2
         AIF       ('&DUMPLST' EQ 'OMIT' AND '&ONERROR' EQ 'OMIT').XNO0
         IF        (XDMPRCUR,EQ,X'80'),XSTOP  BEEN HERE BEFORE ?   V1L2
         MVI       XDMPRCUR,X'80'      SET DUMP RECUR SW           V1L2
.XNO0    ANOP                                                      V1L2
XFORTBK  L         R1,ZR13+72
         MVC       XTNAME(6),ZR1+2
         LH        R3,ZR11
         CVD       R3,XDOUBLE
         MVC       XTISN(5),XEDMASK+4
         ED        XTISN-1(6),XDOUBLE+5
         SPRIN     XTLINE,XTLINEND-XTLINE    PRINT OUT LINE
         AIF       ('&ONERROR' EQ 'OMIT').XNOERR1                  V1L2
         IF        (XERRSW,EQ,X'00'),XNOERRSW ONERROR SW ON ?      V1L2
XNOMATCH L         R10,XERRLIST        LOAD ERROR POINTERON ?      V1L2
         LTR       R10,R10             ZERO ?                      V1L2
         BZ        XNOERRSW            NO MATCH SO DONE            V1L2
         MVC       XERRLIST(4),0(R10)  GET NEXT POINTER            V1L2
         LA        R14,8(R10)          R14 -> OBJECT CODE          V1L2
         IF        (4(R14),NE,X'58'),XNOMATCH GOOD GOTO ADDR ?     V1L2
         L         R10,4(,R10)         R10 -> SAVE AREA            V1L2
         LA        R10,0(R10)          GET RID OF CRAP             V1L2
         LA        R13,0(R13)          GET RID OF CRAP             V1L2
         CR        R10,R13             SAVE AREAS SAME ?           V1L2
         BNE       XNOMATCH            NO                          V1L2
         LM        R5,R10,76(R10)      LOAD UP DATA REGS           V1L2
         BR        R14                 GOTO OBJECT CODE AND PRAY   V1L2
XNOERRSW EQU       *                                               V1L2
.XNOERR1 ANOP                                                      V1L2
         CLC       XTNAME(6),XMNAM     IS IT MAIN PROG ?           V1L2
         AIF       ('&DUMPLST' EQ 'USE').XNODM00                   V1L2
         BE        XSTOP               YES - DONE
.XNODM00 ANOP                                                      V1L2
         AIF       ('&DUMPLST' EQ 'OMIT').XNODM01                  V1L2
         BE        XDMPCHK             GO CHECK FOR DUMPLIST       V1L2
.XNODM01 ANOP                                                      V1L2
         C         R4,XTRCOUNT         FIRST TIME THRU  ?          V1L2
         BE        XOUT                YES BRANCH AROUND
         CLC       XTRC(6),XTNAME      ARE WE BACK TO THE FIRST NAME
         BE        TERR                YES THAN TRACEBACK ERROR
XOUT     CLI       XTNAME,C'$'
         BE        XFIN
         CLI       XTNAME,C'A'
         BL        TERR
         CLI       XTNAME,C'I'
         BNH       XFIN
         CLI       XTNAME,C'J'
         BL        TERR
         CLI       XTNAME,C'R'
         BNH       XFIN
         CLI       XTNAME,C'S'
         BL        TERR
         CLI       XTNAME,C'Z'
         BH        TERR
XFIN     L         R13,ZR13+4          NO - BACK UP ONE LEVEL
         L         R11,ZR13+64
         BCT       R4,XFORTBK
TERR     $ERROR    (NOAC,KO,8),XSTOP                               V1L5
XTLINE   DC        C'0        PROGRAM WAS EXECUTING LINE '         V1L1
XTISN    DC        CL5' '
         DC        C' IN ROUTINE '
XTNAME   DC        CL6' '
         DC        C' WHEN TERMINATION OCCURRED'
XTLINEND EQU       *
         AIF       ('&DUMPLST' EQ 'OMIT').XNODM2                   V1L2
XDMPCHK  IF        (XDUMPSW,EQ,X'00'),XSTOP    DO WE DUMP ?        V1L2
         MVI       XIORECUR,0          ALLOW HIM A DUMP            V1L4
XDMPLOOP L         R10,XDMPLIST        LOAD DUMPLIST POINTER       V1L2
         LTR       R10,R10             ZERO ?                      V1L2
         BZ        XSTOP               YES, THEN DONE              V1L2
         MVC       XDMPLIST(4),0(R10)  GET NEXT POINTER            V1L2
         LA        R14,8(R10)          R14 -> DUMPLIST TABLE       V1L2
         IF        (1(R14),EQ,X'00'),XDMPLOOP  GOOD TABLE ?        V1L2
         L         R10,4(,R10)         R10 -> SAVE AREA            V1L2
         L         R9,XLASTSAV         GET PREVIOUS SAVE AREA      V1L2
         CR        R9,R10              SAME ?                      V1L2
         BE        XSAMESAV            YES                         V1L2
         L         R1,72(,R10)         R1 -> ISN AND NAME          V1L2
         LTR       R1,R1               DID WE EVER CALL THIS ?     V1L2
         BZ        XDMPLOOP            TAKE BRANCH IF NOT          V1L2
         MVC       XDMPNAME(6),2(R1)   GET NAME                    V1L2
         ST        R10,XLASTSAV        SAVE CURRENT SAVE AREA      V1L2
         SPRIN     XDMPHEAD,XDMPEND-XDMPHEAD PRINT HEADER          V1L2
XSAMESAV ST        R14,XDMPCODE        STORE ADDR OF TABLE         V1L2
         ST        R15,XDUMPSV         SAVE R15                    V1L2
         LM        R5,R10,76(R10)      LOAD DATA REGS              V1L2
*  NEXT FIVE LINES SIMULATE A NAMELIST WRITE                       V1L2
         CNOP      0,4                 PAD IF REQUIRED             V1L2
         LA        R1,&PRINT           GET PRINTER UNIT NUMBER     V1L2
         BAL       R14,XIOINIT         OFF TO DO I/O               V1L2
         DC        X'07',AL3(XIOEND)                               V1L2
         DC        A(XIOERR)                                       V1L2
XDMPCODE DC        A(*-*)                                          V1L2
         DROP      R15                                             V1L2
         BALR      R10,0               SET UP BASE REG             V1L2
         USING     *,R10               TELL ASSEMBLER              V1L2
         L         R15,XDUMPSV         RESTORE BASE REG 15         V1L2
         DROP      R10                 DROP R10                    V1L2
         USING     XTRACEB1,R15        SET UP BASE                 V1L2
         B         XDMPLOOP            BACK FOR NEXT DUMPLIST      V1L2
XDUMPSV  DS        1F                  SAVE AREA FOR BASE REG R15  V1L2
XLASTSAV DS        F                   SAVE AREA SAVE AREA         V1L2
XDMPHEAD DC        C'0**** DUMPLIST FOR ROUTINE '                  V1L2
XDMPNAME DS        CL6                                             V1L2
         DC        C' FOLLOWS ****'                                V1L2
XDMPEND  EQU       *                                               V1L2
.XNODM2  ANOP                                                      V1L2
         SPACE
         $FREE     R15                                             V1L5
         EJECT
***********************************************************************
*****    THESE ARE SOME COMPLEX ARITHMETIC ROUTINES WE LEFT OUT OF ****
*****         STARTA WHEN WE RAN OUT OF ROOM THERE. TOUGH JAB      ****
***********************************************************************
         USING     PC16EXPI,R15
PC16EXPI SDR       F6,F6
         LD        F4,XEXPLIT
         MVI       XEXPSW2+1,NOP
         STD       F0,XCMT1
         STD       F2,XCMT2
         LTR       R4,R4
         BNL       XEXP22
         MVI       XEXPSW2+1,BRA
         LPR       R4,R4
         B         XEXP22
XEXP12   LD        F0,XCMT1            PUT NEXT POWER  IN XCMT1,XCMT2
         LD        F2,XCMT2
         MDR       F0,F0
         MDR       F2,F2
         SDR       F0,F2
         LD        F2,XCMT1
         MD        F2,XCMT2
         ADR       F2,F2
         STD       F0,XCMT1
         STD       F2,XCMT2
XEXP22   EX        R4,XEXPTM           IS BOTTOM BIT OF R4 = 1
         BZ        XEXP32              NO
         LDR       F0,F2  MPY PARTIAL RESULT BY CORR. POWER OF INPUT
         MDR       F0,F4
         MDR       F2,F6
         MD        F4,XCMT1
         MD        F6,XCMT1
         SDR       F4,F2
         ADR       F6,F0
XEXP32   SRA       R4,1                SHIFT EXPONENT
         BH        XEXP12              DONE ?
XEXPSW2  BC        *-*,XEXP42          YES - RETURN IF EXPONENT +VE
         LDR       F0,F4
         LDR       F2,F6
         SDR       F6,F6
         BR        R14
XEXP42   LD        F0,XEXPLIT          INVERT RESULT IF EXPONENT -VE
         SDR       F2,F2
****    THIS MUST FALL THRU TO PCDIV116
**       B         XCDIV116            WAS THIS IN OLD DAYS
         $FREE     R15                                             V1L5
         SPACE
PCDIV116 LCDR      F6,F6               COMPLEX*16 DIVIDE
         STD       F4,XCMT1            (F0,F2)/(F4,F6)
         STD       F6,XCMT2            RESULT IN (F0,F2)
         MDR       F4,F4
         MDR       F6,F6
         ADR       F4,F6
         DDR       F0,F4
         DDR       F2,F4
         LD        F4,XCMT1
         LD        F6,XCMT2
         MDR       F4,F2
         MDR       F6,F2
         LDR       F2,F0
         MD        F0,XCMT1
         MD        F2,XCMT2
         SDR       F0,F6
         ADR       F2,F4
         SDR       F6,F6
         BR        R14
         SPACE
PCMULT8  STE       F0,XCMT1            COMPLEX*8 MULTIPLY
         STE       F2,XCMT2            (F0,F2)*(F4,F6)
         MER       F0,F4               RESULT IN (F0,F2)
         MER       F2,F4
         LER       F4,F6
         ME        F4,XCMT1
         ME        F6,XCMT2
         SER       F0,F6
         AER       F2,F4
         SDR       F6,F6
         BR        R14
         SPACE
PCMULT16 STD       F0,XCMT1            COMPLEX*16 MULTIPLY
         STD       F2,XCMT2            (F0,F2)*(F4,F6)
         MDR       F0,F4               RESULT IN (F0,F2)
         MDR       F2,F4
         LDR       F4,F6
         MD        F4,XCMT1
         MD        F6,XCMT2
         SDR       F0,F6
         ADR       F2,F4
         SDR       F6,F6
         BR        R14
         SPACE
PCDIV18  LCER      F6,F6               COMPLEX*8 DIVIDE
         STE       F4,XCMT1            (F0,F2)/(F4,F6)
         STE       F6,XCMT2            RESULT IN (F0,F2)
         MER       F4,F4
         MER       F6,F6
         AER       F4,F6
         DER       F0,F4
         DER       F2,F4
         LE        F4,XCMT1
         LE        F6,XCMT2
         MER       F4,F2
         MER       F6,F2
         LER       F2,F0
         ME        F0,XCMT1
         ME        F2,XCMT2
         SER       F0,F6
         AER       F2,F4
         SDR       F6,F6
         BR        R14
         SPACE
PCDIV28  LCER      F2,F2               COMPLEX*8 DIVIDE
         STE       F0,XCMT1            (F4,F6)/(F0,F2)
         STE       F2,XCMT2            RESULT IN (F0,F2)
         MER       F0,F0
         MER       F2,F2
         AER       F0,F2
         DER       F4,F0
         DER       F6,F0
         LE        F0,XCMT1
         LE        F2,XCMT2
         MER       F0,F4
         MER       F2,F4
         LER       F4,F6
         ME        F4,XCMT1
         ME        F6,XCMT2
         AER       F2,F4
         SER       F0,F6
         SDR       F6,F6
         BR        R14
         SPACE
PCDIV216 LCDR      F2,F2               COMPLEX*16 DIVIDE
         STD       F0,XCMT1            (F4,F6)/(F0,F2)
         STD       F2,XCMT2            RESULT IN (F0,F2)
         MDR       F0,F0
         MDR       F2,F2
         ADR       F0,F2
         DDR       F4,F0
         DDR       F6,F0
         LD        F0,XCMT1
         LD        F2,XCMT2
         MDR       F0,F4
         MDR       F2,F4
         LDR       F4,F6
         MD        F4,XCMT1
         MD        F6,XCMT2
         ADR       F2,F4
         SDR       F0,F6
         SDR       F6,F6
         BR        R14
         SPACE
***********************************************************************
*        THIS ROUTINE SEARCHES AN ARGUMENT LIST A SECOND TIME IF ANY
*        DUMMY PARAMETER WAS AN ARRAY NAME. IT SETS UP THE DOT ROUTINES
*        FOR THE DUMMY ARRAYS IN THE CALL.
*        THIS ROUTINE ALSO CHECKS IF THE LAST DIMENSION IN THE     V1L5
*        ARRAY IS 1 --- IT IS THEN FLAGGED AS A PVD (PSEUDO        V1L5
*        VARIABLE DIMENSION) AND THIS LAST DIMENSION OF 1 IS       V1L5
*        CHANGED SO THE DUMMY ARRAY HAS THE SAME LENGTH AS         V1L5
*        THE CALLING ARRAY                                         V1L5
***********************************************************************
         USING     YENTA,R9
YENTA    MVI       YENTL+1,BRA         TURN OFF ARRAY SWITCH
         LR        R8,R15
         SR        R8,R11
         L         R1,XDOUBLE          R1-> FIRST CALL ARG
         LR        R15,R11             R15 -> FIRST ENTRY ARG
         USING     CALLUSE,R1
         USING     ENTRUSE,R15
         BAL       RDONE,YENTA10
         LA        R15,ENTRUSE+4       GET NEXT ARGUMENT
YENTA15  LA        R1,CALLUSE+4
         IF        (CALLMODE,ON,X'8C'),YENTA15  IGNORE EXTRA WORD FOR
*        AN ARRAY MEMBER IN THE CALLING SEQUENCE
YENTA10  L         R3,ENTRARG
         L         R4,CALLARG
         CLI       ENTRMODE,48         LAST ARGUMENT ?
         BNL       YENTA11             NO
         CLI       ENTRMODE,16
         BL        YENTA11             NO
         LM        R5,R10,ZR13+76      RESET PROGRAMME'S REGISTERS
         B         ENTRARG+4
YENTA11  CLI       ENTRMODE,128+15     IS  ARGUMENT AN ARRAY
         BNHR      RDONE               NO
YENTAR   DS        0H                  LAST DIM FOR ARRAY &        V1L5
         NI        YSW1,X'FF'-YDIML-YPVD  PVD NOT FOUND            V1L5
         IC        R2,ZR3+4            (R4) <- 4N-4 (N = # OF DIM) V1L5
         LA        R8,ZR3+16(R2)       R8-> VARIABLE DIMENSION INFO
         LA        R7,1                INITIALLIZE FOR LENGTH
         LA        R2,ZR2+4
         L         R0,ZR8              CONTROL BYTE IN R0
         LTR       R0,R0
         BNZ       YENTA2
         L         R7,ZR3+8(RO)        GET LENGTH OF ARRAY
         B         YENTAR7
YENTA2   LA        R6,ZR3+8(R2)        ADDRESS OF DIMENSION IN R6
         ALR       R0,R0               IS DIMENSION VARIABLE ?
         LTR       R0,R0               RESET CONDITION CODE
         BNL       YENTA3              NO
         L         R6,ZR8              YES - GET ADDRESS IN DATA AREA
         LA        R8,ZR8+4
         LTR       R6,R6               IS IT CALLED BY NAME ?
         BNL       YENTA3              NO
         L         R6,ZR6(RO)          YES - GET ADDRESS
YENTA3   DS        0H                  BR IF LAST DIM PROCESSED    V1L5
         IF        (YSW1,ON,YDIML),YENTA31   ELSE CHECK FOR PVD    V1L5
         LA        R6,ZR6              ZERO CONTROL BYTE           V1L5
         LTR       R6,R6               A(0) -> PVD                 V1L5
         BNZ       YENTA31             BR IF VALID ADDRESS         V1L5
*        SAVE ADDRESS WHERE VALUE FOR PSEUDO VARIABLE DIMENSION    V1L5
*        (TO BE CALCULATED LATER AT YENTAR6) IS TO BE STORED       V1L5
         LA        R6,ZR3+8(R2)        INDEX INTO DLIST FOR A(DIM) V1L5
         ST        R6,YALDIM           SAVE FOR VALUE OF PVD       V1L5
         LA        R6,1                PSEUDO VAR DIM <- 1         V1L5
         OI        YSW1,YDIML+YPVD  LAST DIM & PVD FOUND           V1L5
         B         YENTA32             OMIT LOADING R6 WITH VAR DIMV1L5
YENTA31  DS        0H                                              V1L5
         L         R6,ZR6              OBTAIN VALUE OF VAR DIM     V1L5
YENTA32  DS        0H                                              V1L5
         ST        R6,ZR3+8(R2)        ST VAR DIM IN DLIST IN STAR V1L5
         OI        YSW1,YDIML          LAST DIM ALREADY PROCESSED  V1L5
         ST        R6,ZR3+8(R2)        STORE IN DOT ROUTINE
         LTR       R6,R6               IS IT NEGATIVE
         BNH       XERRUV1D
YENTA1   MR        R6,R6               MULTIPLY LENGTH BY DIMENSION
         S         R2,KF4              GET NEXT DIMENSION
         BNZ       YENTA2
         IC        R6,ZR3+8(RO)
         SLA       R7,ZR6
         ST        R7,ZR3+8(RO)        STORE LENGTH OF ARRAY
         ST        R7,YLENTRY          SAVE LEN OF ENTRY ARG ARRAY V1L5
         STC       R6,ZR3+8(RO)        REPLACE CHARACTER
YENTAR7  IF         (CALLMODE,GT,128+15),YENTAR1  IS CALL ARG AN ARRAY
         IF        (CALLMODE,NE,CHARN),YENTAR2 OR CHARACTER*N CONSTANT
         L         R0,ZR4(RO)          GET ADDRESS IN R0
         SR        R6,R6
         IC        R6,ZR4(RO)          LENGTH IN R6
         LA        R6,ZR6+3            ROUND TO A FULL-WORD
         N         R6,KFM4
         SLL       R6,2                GET LENGTH IN BYTES         V1L5
         ST        R6,YLCALL           SAVE LEN OF CALL ARG ARRAY  V1L5
         A         R6,ZR4(RO)          ADD ADDRESS
         B         YENTAR8
YENTAR1  L         R0,ZR4+4(RO)        ADDRESS OF CALL ARRAY IN R0
YENTAR3  L         R6,ZR4+8(RO)        GET LENGTH OF MAINLINE ARRAY
         ST        R6,YLCALL           SAVE LEN OF CALL ARG ARRAY  V1L5
         A         R6,ZR4+4(RO)        ADD ADDRESS OF MAINLINE ARRAY
YENTAR8  EQU       *                                               V1L4
         IC        R2,ZR3+4(RO)        SAVE BYTE
         ST        R0,ZR3+4(RO)        FILL IN ADDRESS
         STC       R2,ZR3+4(RO)        RESTORE BYTE
         AR        R7,R0               ADD A(SUBR ARRAY) TO LENGTH
YENTAR6  LA        R7,ZR7    CLEAR TOP BYTE TO GIVE END OF S/R ARG V1L4
         LA        R6,ZR6    CLEAR TOP BYTE TO GIVE ADDR OF END    V1L4
         IF        (YSW1,OFF,YPVD),YTSTDM3 BR IF NO PVD            V1L5
         L         R7,YLCALL           LENGTH OF CALLING ARGUMENT  V1L5
         LA        R7,ZR7              ZERO CONTROL BYTE           V1L5
         SR        R6,R6               ARRAY IS IN R6-R7 PAIR      V1L5
         D         R6,YLENTRY          DIVIDE BY LEN OF ENTRY ARG  V1L5
         L         R6,YALDIM           SAVE CALCULATED VALUE OF    V1L5
         ST        R7,ZR6              PSEUDO VAR DIM IN STAR RTN  V1L5
         MVC       ZR3+9(3),YLCALL+1   SAVE LEN OF CALL ARR IN STARV1L5
         BR        RDONE               CHECK NEXT ARGUMENT         V1L5
YTSTDM3  DS        0H                  CHK IF S/R ARRAY TOO BIG    V1L5
         CR        R7,R6               IS S/R ARRAY TOO BIG?       V1L4
         BNHR      RDONE               OK
XERRDM5  $ERROR    (TRAZ,DM,3,VM6R3)                               V1L5
XERRUV1D C         R6,XUNDEF           WAS VARIABLE UNDEFINED
         BNE       XERRDM5             NO - JUST NEGATIVE
         S         R8,KF4
         L         R5,ZR8
         $ERROR    (TRAZ,UV,0,VM6R5)                               V1L5
YENTAR2  LR        R0,R4               A(ELEMENT) IN R0
         IF        (CALLMODE,NON,CHAR1),YENTAR5
         MVC       YENTAB+9(1),ZR4     MOVE LENGTH TO TABLE
         L         R0,ZR4              IF CHARACTER, GET ADDRESS
YENTAR5  IF        (CALLMODE+4,ON,X'8C'),YENTAR4 WAS CALL ARG AN ARRAY
*                                                MEMBER ?
         IC        R6,ZR3+4(RO)        SAVE BYTE
         ST        R0,ZR3+4(RO)        FILL IN ADDRESS
         STC       R6,ZR3+4(RO)        RESTORE BYTE
         IC        R6,CALLMODE
         N         R6,KF15
         IC        R6,YENTAB(R6)    GET ELEMENT LENGTH FOR CALL ARG.
         ST        R6,YLCALL           SAVE LENGTH OF CALLING ARG  V1L5
         B         YENTAR6
YENTAR4  L         R4,CALLMODE+4       A(DOT RTN FOR CALL ARG) IN R4
         B         YENTAR3
YENTAB   DC        AL1(4,1,4,2,4,8,8,16,1,0)
         SPACE
         $FREE     R1,R3,R9,R15                                    V1L5
         SPACE
* CONSTANTS
         SPACE
KFM4     DC        F'-4'
KF6      DC        F'6'
KM2427   DC        X'000000F0'
YLCALL   DC        F'1'                LENGTH OF CALLING ARG ARRAY V1L5
YLENTRY  DC        F'1'                LENGHT OF ENTRY ARG ARRAY   V1L5
YALDIM   DC        A(*-*)              ADDR OF PSEUDO VAR VALUE    V1L5
         LTORG
YSW1     DC        X'00'                                           V1L5
YDIML    EQU       X'80'               INDICATES LAST DIM PROCESSEDV1L5
YPVD     EQU       X'40'               INDICATES PSEUDO VAR DIM    V1L5
XTRC     DC        C'      '           TEMPORARY STORAGE FOR TRACEBACK
STARTBE  EQU       *-1                 GENERATE ENTRY FOR END OF STARTB
         TITLE     ' '
