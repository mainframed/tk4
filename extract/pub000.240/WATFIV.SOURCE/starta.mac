         TITLE     'STARTA     START AREA'
* TIMER INTERRUPT MONITOR
         SPACE
***********************************************************************
*        TIMER INTERRUPT ROUTINE                                      *
*        SET GATE TO FALL THRU AT START OF NEXT FORTRAN STMT          *
         AIF       (&NDVSD).D1                                     V1L5
XTIMINT  BALR      15,0                SET UP ADDRESSABILITY       DVS1
         USING     XTIMIN1,15                                      DVS1
XTIMIN1  MVI       XISNSW+1,NOP        SET THE SWITCH IN XISNRTN   DVS1
         $EXIT     IT                  EXIT FROM INT TIMER RTN     DVS1
         AGO       .D2                                             V1L5
.D1      ANOP                                                      V1L5
         USING     XTIMINT,15
XTIMINT  MVI       XISNSW+1,NOP        SET THE SWITCH IN XISNRTN
         BR        14
.D2      ANOP                                                      V1L5
         $FREE     15                                              V1L5
***********************************************************************
         SPACE     5
         FUNCREFS
         SPACE     5
* PROGRAM ENTRY ROUTINE
*
* CALLING SEQUENCE
*
*        CNOP      0,4
*        STM       R14,R11,12(R13)
*        BAL       RP,XENT
*        DC        H'0',CL6'NAME'                                  V1L2
*        DC        A(SAVEAREA)                                     V1L2
*        ...                           MODEL ARGUMENT LIST
*        ...                           RETURN ICI
*
* REGISTER USAGE
*
*                  R0                  WORK REGISTER
*                  R1                  PTS TO CALL ARG LIST
*                  R2
*                  R3
*                  R4
*                  R5-R10              BARS COVERING DATA AREA
*                  R11                 PTS TO SUBPROGRAMME ARG LIST
*                  R12                 BAR COVERING START AREA
*                  R13                 PTS TO SUBPROGRAMME SAVE AREA
*                  R14                 LOOP RETURN ADDRESS
*                  R15
         SPACE
         USING     ENTRUSE,R11
         USING     CALLUSE,R1
         SPACE
XENTASF  LR        R15,R13
         L         R13,ENTRSAVE
         THEN      XENT6
         SPACE
XENT     LR        R15,R13             OLD SAVE AREA
         L         R13,ENTRSAVE
         LM        R5,R10,ZR13+76
XENT6    IF        (ZR13+72,ON),XER8SR6
         ST        R11,ZR13+72
         THEN      (ZR13+72,ON)
XENTFN   SR        R2,R2
         ST        R13,ZR15+8
         ST        R15,ZSVBACK
         LR        R15,R11
         $FREE     R11                                             V1L5
         USING     ENTRUSE,R15
         SR        R14,R14             ZERO R14                    V1L5
         ST        R14,XARGCNT         ZERO ARGUMENT COUNT         V1L5
         ST        R1,XDOUBLE          STORE A(FIRST CALL ARG)
XENT8    BAL       R14,XENT10
         LA        R15,ENTRUSE+ENTRNEXT-ENTRARG
XENT11   LA        R1,CALLUSE+CALLNEXT-CALLARG
         IF        (CALLMODE,ON,X'8C'),XENT11 IGNORE 'EXTRA' CALL ARG
XENT10   DS        0H                                              V1L5
         L         R3,XARGCNT          GET THE # OF ARGUMENTS      V1L5
         LA        R3,1(,R3)           INCREMENT IT                V1L5
         ST        R3,XARGCNT          STORE IT                    V1L5
         L         R3,ENTRARG                                      V1L5
         L         R4,CALLARG
         IC        R2,ENTRMODE
         IC        R2,XENTF(R2)
         B         XENTT(R2)
XENTT    DC        0H'0'
         SPACE
* NOTE
* THE OFFSET OF THE LAST ROUTINE ADDRESSED BY THE JUMP TABLE MUST BE
* LESS THAN 256 BYTES FROM XENTT
         SPACE
* NEEDLESS TO SAY A LOT OF WORK HAS GONE INTO FITTING IT INTO 256
* BYTES
* NOTICE THAT THE LAST ROUTINE IS THE LONGEST
         SPACE
XENTCHNA EQU       *
XENTA    IF        (CALLMODE,ON,SIMV),XENTA1   IF CALL ARG. A VARIABLE
         IF        (CALLMODE,NE,CHARN),XCHKSR5  OR HOLLERITH CONSTANT
XENTA1   MVI       YENTL+1,NOP         TURN ON ARRAY SWITCH
         BR        RDONE
XENTL    CLC       ENTRMODE,CALLMODE
         BNE       XENT99
YENTL    B         ENTRARG+4           ***  BRA/NOP SWITCH  ***
         L         R9,XADYENTA
         BR        R9
         SPACE     1
XENTS    IF        (CALLMODE,O,B'10000000'),XER8SR4
         IF        (CALLMODE,Z,B'01000000'),XER8SR4
         L         R0,ZR4
         ST        R0,ZR3
         BR        RDONE
         SPACE
XENTSTAT IF        (CALLMODE,EQ,STAT),DONE
XERRSR4  $ERROR    (NOAC,SR,4,ENTR11),XRETRACE                     V1L5
XER8SR4  EQU       XERRSR4
XENTKO0  B         XBOOT
XENTK    EQU       XENTKO0           GO HERE EVEN FOR ERROR SITUATIONS
XBXBOOT  EQU       XENTKO0             REERENCED BY INOUT AND ERROR
         SPACE
XENTV4   DC        0H'0'
XENTR4   EQU       *                   SIMPLE VARIABLES
XENTL1   EQU       *                   CALLED-BY-VALUE
XENTV2   EQU       *
XENTV8   EQU       *
XENTC8   EQU       *
XENTV16  IC        R2,CALLMODE
         EX        R2,XENTCLI
         BNE       XERRSR4
         N         R2,KF15
         IC        R2,KT1(R2)
         EX        R2,XENTMVC
         BR        RDONE
         SPACE     1
XENTN    ST        R3,XTEMP            SIMPLE VARIABLES
         THEN      (XTEMP,AND,ALL-SIMV)    CALLED-BY-NAME
         CLC       ENTRMODE(1),XTEMP
         BNE       XERRSR4
         ST        R4,ZR3
         BR        RDONE
         SPACE
XENTNCH  ST        R3,XTEMP            CHARACTER VARIABLE
         THEN      (XTEMP,AND,ALL-SIMV)   CALLED-BY-NAME
         CLC       ENTRMODE(1),XTEMP
         BNE       XERRSR4
         CLC       ZR4(1),ZR3
         BNE       XERRSR4
         L         R4,ZR4              PICK UP W.WORD
         ST        R4,ZR3
         BR        RDONE
         SPACE
XENTCH1  DC        0H'0'               CHARACTER VARIABLES
XENTCHN  ST        R4,XTEMP            CALLED-BY-VALUE
         THEN      (XTEMP,OR,SIMV)
         IF        (XTEMP,NO,SIMV+CHAR1),XERRSR4
         IF        (XTEMP,NZ,X'76'),XERRSR4
         CLC       ZR3(1),ZR4
         BNE       XERRSR4
         IC        R2,ZR3(RO)
         BCTR      R2,0
         L         R3,ZR3
         L         R4,ZR4
         EX        R2,XENTMVC
         BR       RDONE
         SPACE     2
XENTCLI  CLI       ENTRMODE,SIMV+*-*
XENTMVC  MVC       ZR3(*-*),ZR4
         SPACE
XENTF    DC        8AL1(XENTN-XENTT)   SIMPLE VARIABLE BY NAME
         DC        2AL1(XENTNCH-XENTT) SIMPLE CHARACTER BY NAME
         DC        6AL1(XENTK-XENTT)
         DC        2AL1(XENTL-XENTT)   LAST ARGUMENT
         DC        14AL1(XENTK-XENTT)
         DC        8AL1(XENTL-XENTT)   LAST ARGUMENT
         DC        8AL1(XENTK-XENTT)
         DC        AL1(XENTSTAT-XENTT) STATEMENT NUMBER
         DC        15AL1(XENTK-XENTT)
         DC        16AL1(XENTK-XENTT)
         DC        AL1(XENTS-XENTT)    SUBPROGRAM ADDRESS
         DC        15AL1(XENTK-XENTT)
         DC        8AL1(XENTS-XENTT)   SUBPROGRAM ADDRESS
         DC        8AL1(XENTK-XENTT)
         DC        16AL1(XENTK-XENTT)
         DC        AL1(XENTV4-XENTT)   LOGICAL*4
         DC        AL1(XENTL1-XENTT)   LOGICAL*1
         DC        AL1(XENTV4-XENTT)   INTEGER*4
         DC        AL1(XENTV2-XENTT)   INTEGER*2
         DC        AL1(XENTV4-XENTT)   REAL*4
         DC        AL1(XENTV8-XENTT)   REAL*8
         DC        AL1(XENTC8-XENTT)   COMPLEX*8
         DC        AL1(XENTV16-XENTT)  COMPLEX*16
         DC        AL1(XENTCH1-XENTT)  CHARACTER*1
         DC        AL1(XENTCHN-XENTT)  CHARACTER*N
         DC        6AL1(XENTK-XENTT)
         DC        4AL1(XENTA-XENTT)   L4,L1,I4,I2
         DC        AL1(XENTA-XENTT)                                V1L1
         DC        4AL1(XENTA-XENTT)   R8,C8,C16,CH1
         DC        AL1(XENTCHNA-XENTT) CHN
         DC        6AL1(XENTK-XENTT)
         DC        9AL1(XENTA-XENTT)   2 DIMENSIONS
         DC        AL1(XENTCHNA-XENTT) CHN
         DC        6AL1(XENTK-XENTT)
         DC        9AL1(XENTA-XENTT)   3 DIMENSIONS
         DC        AL1(XENTCHNA-XENTT) CHN
         DC        6AL1(XENTK-XENTT)
         DC        9AL1(XENTA-XENTT)   4 DIMENSIONS
         DC        AL1(XENTCHNA-XENTT) CHN
         DC        6AL1(XENTK-XENTT)
         DC        9AL1(XENTA-XENTT)   5 DIMENSIONS
         DC        AL1(XENTCHNA-XENTT) CHN
         DC        6AL1(XENTK-XENTT)
         DC        9AL1(XENTA-XENTT)   6 DIMENSIONS
         DC        AL1(XENTCHNA-XENTT) CHN
         DC        6AL1(XENTK-XENTT)
         DC        9AL1(XENTA-XENTT)   7 DIMENSIONS
         DC        AL1(XENTCHNA-XENTT) CHN
         DC        5AL1(XENTK-XENTT)
         DC        AL1(XENTKO0-XENTT)  BOOT
         SPACE
XENT99   IFALL     (CALLMODE,OFF,B'11000000'),(CALLMODE,MIX,B'00110000'X
               ),XER8SR2
         B         XER8SR7
XCHKSR5  IF        (CALLMODE,NZ,B'11000000'),XERRSR4
         IF        (CALLMODE,NM,B'00110000'),XERRSR4
XER8SR7  $ERROR    (NOAC,SR,5,ENTR11),XRETRACE                     V1L5
XER8SR2  $ERROR    (NOAC,SR,2,ENTR11),XRETRACE                     V1L5
XER8SR6  LR        R13,R15
         $ERROR    (NOAC,SR,3,ENTR11),XRETR1                       V1L5
XERRRE7  L         R13,ZR13+8
         $ERROR    (TRAZ,RE,1,INTR2)                               V1L5
         SPACE
         $FREE     R1,R15                                          V1L5
         EJECT
*******************************************************************
*********          PROGRAM RETURN ROUTINE                 *********
*******************************************************************
* CALLING SEQUENCE
*
*        B         XRET
         SPACE
* ASF RETURN ROUTINE
XRETASF  THEN      (ZR13+72,OFF)
         L         R13,ZSVBACK
         L         R14,ZSV14
         L         R11,ZSV11
         BR        RDONE               RETURN;
         SPACE
* SUBPROGRAM RETURN ROUTINE
XRET     THEN      (ZR13+72,OFF)
         SR        R0,R0               ZERO R0                     V1L5
         ST        R0,XARGCNT          ZERO THE ARGUMENT COUNT     V1L5
         L         R15,ZR13+72
         LR        R0,R15              SAVE A(S/R NAME)            V1L4
         USING     ENTRUSE,R15
         L         R13,ZSVBACK
XRET21   L         R1,ZSV1
         USING     CALLUSE,R1
         B         XRET10
XRET20   EX        R2,XRET31
XRET15   LA        R15,ENTRUSE+ENTRNEXT-ENTRARG
XRET16   LA        R1,CALLUSE+CALLNEXT-CALLARG
         IF        (CALLMODE,ON,X'8C'),XRET16
XRET10   DS        0H                                              V1L5
         L         R14,XARGCNT         GET THE ARGUMENT COUNT      V1L5
         LA        R14,1(,R14)         INCREMENT IT                V1L5
         ST        R14,XARGCNT         STORE IT                    V1L5
         IF        (ENTRMODE,SVAR),XRET50                          V1L5
         IF        (ENTRMODE,NZ,B'11000000'),XRET15
         IF        (ENTRMODE,NM,B'00110000'),XRET15
         LM        R5,R11,ZSV5
XRET90   L         R14,ZSV14
         IF       (ENTRMODE,OFF,FUNC),DONE
         L         R1,ENTRARG
         L         R3,0(R1)
         IC        R2,ENTRMODE
         N         R2,KM2831
         SR        R4,R4
         IC        R4,KT1(R2)          GET LENGTH-1 OF FUNCTION VALUE
         EX        R4,XRETCLC          IS IT UNDEFINED
         BNE       XRET91              NO
         $ERROR    (TRAZ,UV,0,VM6R1)                               V1L5
XRET91   IC        R2,XRETF1(R2)
         EX        0,XRETT(R2)
         BR        RDONE               RETURN;
XRETCLC  CLC       ZR3(1),XUNDEF
XRETIH   LH        R3,ZR3(RO)
         B         XRETI
XRETIF   L         R3,ZR3
XRETI    L         R15,ZR13+72
         THEN      (ZR13+72,OFF)
         L         R13,ZSVBACK
         L         R1,ZSV1
         LTR       R2,R3               SAVE I IN R2 FOR XERRE7
         BH        XRET12
         B         XERRRE7
XRETI1   IF        (CALLMODE,LAST),XERRRE7
XRETI3   LA        R1,CALLUSE+CALLNEXT-CALLARG
XRET12   IF        (CALLMODE,NE,STAT),XRETI1
         BCT       R3,XRETI3
         L         R14,CALLARG
         ST        R14,ZSV14            GIMMIK THE RETURN
         B         XRET21
         EJECT
XRET50   IF        (ENTRMODE,NAME),XRET15
         IC        R2,ENTRMODE
         N         R2,KM2831
         IC        R2,KT1(R2)          PICK UP NBYTES-1
         L         R14,ENTRARG
         L         R11,CALLARG
         IFNOT     (ENTRMODE,ON,CHAR),XRET55
         IC        R2,ZR14(RO)
         BCTR      R2,0
         L         R14,ZR14
         L         R11,ZR11
XRET55   IFNOT     (CALLMODE,CONS),XRET20
         EX        R2,XRET30      YES
         BE        XRET15
*  SR-5  ATTEMPT TO REDEFINE A CONSTANT,TEMP.,DO-PAR., ETC. IN S/P
         $ERROR    (NOAC,SR,1,ENTR0),XRETR1                        V1L5
XRET30   CLC       ZR11(*-*),ZR14
XRET31   MVC       ZR11(*-*),ZR14
         SPACE
XRETF1   DC        AL1(XRETL4-XRETT)
         DC        AL1(XRETL1-XRETT)
         DC        AL1(XRETI4-XRETT)
         DC        AL1(XRETI2-XRETT)
         DC        AL1(XRETR4-XRETT)
         DC        AL1(XRETR8-XRETT)
         DC        AL1(XRETC8-XRETT)
         DC        AL1(XRETC16-XRETT)
         SPACE
XRETT    EQU       *
XRETL4   IC        R0,ZR3(RO)
XRETL1   EQU       XRETL4
XRETI4   L         R0,ZR3
XRETI2   LH        R0,ZR3(RO)
XRETR4   LE        F0,ZR3(RO)
XRETR8   LD        F0,ZR3(RO)
XRETC8   B         *+4
         LE        F0,ZR3(RO)
         LE        F2,ZR3+4(RO)
         BR        RDONE
XRETC16  B         *+4
         LD        F0,ZR3(RO)
         LD        F2,ZR3+8(RO)
         BR        RDONE
         SPACE
         $FREE     R1,R15                                          V1L5
         EJECT
XBOOT    $ERROR    (TRAZ,KO,0)                                     V1L5
XERRSS13 LR        R2,R3
         SR        R4,R4
XERRSS14 SR        R3,R3
         IC        R3,ZR14(R4)
         SRA       R3,2
         IC        R3,XSSTAB(R3)       GET LENGTH-1 OF SUBSCRIPT
         L         R1,ZR14(R4)         GET A(SUBSCRIPT)
         EX        R3,XSSCLC           COMPARE WITH XUNDEF
         BNE       XERRSS12
         $ERROR    (TRAZ,UV,3,NSSR15)                              V1L5
XSSCLC   CLC       ZR1(1),XUNDEF
XSSTAB   DC        X'0703010300000000'
XERRSS1  LR        R2,R3
         SR        R4,R4
XERRSS12 $ERROR    (TRAZ,SS,1,NSSR15)                              V1L5
XEND     $ERROR    (TRAZ,EN,1)                                     V1L5
         EJECT
XPRINT   L         R3,XBUFFER
         EX        R2,XMOVEBUF
         LA        R2,ZR2+1            ERROR EDITOR ENTERS HERE
XPRNTERR L         R1,XAFIOCS
         BALR      R0,R1
         DC        X'02'
         DC        X'00'
         ST        R2,XBUFFER
         BR        RDONE               RETURN;
XMOVEBUF MVC       ZR3(*-*),ZR1
*./DELETE  SEQ1=03600000 SEQ2=039300000                            V1L5
         EJECT
*        SUBSCRIPTING ROUTINE FOR SINGLE AND                       V1L5
*        MULTIPLE SUBSCRIPTED VARIABLES                            V1L5
*                                                                  V1L5
*        THIS CODE REPLACES XA1 AND XAN ROUTINES                   V1L5
*        THIS ROUTINE ALSO HANDLES THE CASE WHERE A VARIABLE WAS   V1L5
*        PASSED DOWN AS AN ARGUMENT TO A SUBROUTINE AND ITS        V1L5
*        LAST DIMENSION WAS 1 --- I.E. PVD (PSEUDO-VARIABLE DIM)   V1L5
*                                                                  V1L5
*        THE FOLLOWING IS APPLICABLE ONLY IF A PVD WAS FOUND       V1L5
*        ANY DIMENSION IN THE DUMMY ARGUMENT ARRAY CAN EXCEED      V1L5
*        THAT OF THE CALLING ARGUMENT BUT THAT ELEMENT MUST        V1L5
*        BE WITHIN THE ARRAY LIMITS OF THE CALLING ARRAY           V1L5
*                                                                  V1L5
*        THE $JOB CARD OPTIONS 'SUBCHK' AND 'NOSUBCHK' ARE ALSO    V1L5
*        HANDLED IN THIS ROUTINE BY MODIFYING THE BRANCH INST      V1L5
*        AT LABELS 'XAN1' AND 'XAN2'; NOSUBCHK OPTION WILL PERMIT  V1L5
*        THE PROGRAM TO ACCESS ANYWHERE WITHIN THE ARRAY LIMITS OF V1L5
*        THE CALLING ARGUMENT EVEN IF SUBSCRIPT BOUNDS ARE         V1L5
*        EXCEEDED; ACCESSING OUTSIDE THE ARRAY LIMITS WILL GENERATEV1L5
*        GENERATE AN SS-4 ERROR MESSAGE.                           V1L5
*                                                                  V1L5
XATEST   SR        R4,R4               N = # OF DIMENSIONS         V1L5
         IC        R4,ZR15             GET 4N-4                    V1L5
         SR        R2,R2                                           V1L5
         SR        R3,R3                                           V1L5
         B         XSSJ11A                                         V1L5
XSSJA    M         R2,ZR15+8(R4)       MULTIPLY BY DIMENSION       V1L5
XSSJ11A  IC        R2,ZR14(R4)         GET MODE OF SUBSCRIPT       V1L5
         L         R5,ZR14(R4)         GET A(SUBSCRIPT)            V1L5
         EX        R0,XSSD(R2)         GET SUBSCRIPT IN R2         V1L5
XSSI22   S         R2,KF1              IS SS ZERO OR NEGATIVE?     V1L5
         BL        XERRSS14            YES -> SS1 OR UV3           V1L5
         C         R2,ZR15+8(R4)       IS SS WITHIN DIMENSIONS?    V1L5
         BL        XANA                YES -> GET NEXT SS          V1L5
XAN1     B         XERRSS12            NOP IF NOSUBCHK FOUND       V1L5
XANA     AR        R3,R2               ADD SUBSCRIPT               V1L5
         S         R4,KF4                                          V1L5
         BNL       XSSJA               LOOP FOR NEXT SUB           V1L5
         IC        R2,ZR15+4           GET NO. OF SHIFTS           V1L5
         SLA       R3,0(R2)            SHIFT LEFT                  V1L5
XAN2     B         XANB                NOP IF NOSUBCHK FOUND       V1L5
         LA        R4,1                                            V1L5
         SLA       R4,0(R2)            FIND LENGTH OF AN ELEMENT   V1L5
         L         R5,ZR15+4                                       V1L5
         LA        R5,0(R5)            ZERO HIGH ORDER BYTE        V1L5
         SR        R5,R4               DECREASE TOTAL LENGTH BY ELEV1L5
         CR        R3,R5               IS SS EXPR < THAN ACTUAL?   V1L5
         BNH       XANB                YES -> OKAY TO PROCEED      V1L5
         S         R15,KF4             BACK UP R15                 V1L5
         $ERROR    (TRAZ,SS,4,VM6R15)  ARRAY BOUNDS EXCEEDED       V1L5
XANB     A         R3,ZR15                                         V1L5
         SR        R2,R2                                           V1L5
XSSRETA  IC        R2,ZR15                                         V1L5
         L         R5,ZR13+76                                      V1L5
         B         ZR14+4(R2)                                      V1L5
*./DELETE  SEQ1=03950000,SEQ2=04180000                             V1L5
XSSD     B         XSSD3
XSSR     B         XSSR3
XSSH     LH        R2,ZR5(RO)          GET INTEGER*2 SUBSCRIPT
XSSI     L         R2,ZR5(RO)          GET INTEGER*4 SUBSCRIPT
XSSCH    B         XSSC2
XSSC2    L         R5,ZR5(RO)
XSSC     IC        R2,ZR5(RO)      GET CHAR. OR LOGICAL SUBSCRIPT
         B         XSSI22
XSSR3    SDR       F4,F4
XSSD3    EX        R0,XSSTAB2(R2)      GET REAL OR COMPLEX SUBSCRIPT
XSSFIX   AW        F4,XFLIT3           FIX TO R2
         STD       F4,XCMT1
         NI        XCMT1+4,X'7F'
         L         R2,XCMT1+4                                      V1L5
         TM        XCMT1,X'80'
         BZ        XSSI22
         LCR       R2,R2
         B         XSSI22
XSSTAB2  LD        F4,ZR5(RO)
         LE        F4,ZR5(RO)
         EJECT
*  ROUTINE TO RAISE AN INTEGER TO AN INTEGER POWER
XIEXPI   LR        R2,R1
         SRDA      R2,32
         LA        R1,1
         SR        R0,R0
         MVI       XEXPSW+1,BRA+R14    SET BRA/NOP SWTCH
         LTR       R4,R4
         BH        XEXP2
         BL        XEXP6
         LTR       R3,R3
         BNER       R14
XERREX2  $ERROR    (TRAZ,EX,1)                                     V1L5
XEXP6    MVI       XEXPSW+1,NOP+R14    SET BRA/NOP SWTCH
         LPR       R4,R4
         LTR       R3,R3
         BNZ       XEXP2
XERREX3  $ERROR    (TRAZ,EX,2)                                     V1L5
XEXP1    MR        R2,R3               SQUARE INTEGER
XEXP2    EX        R4,XEXPTM           IS THIS POWER OF 2 IN EXPONENT
         BZ        XEXP3               NO
         MR        R0,R3     MULTIPLY RESULT BY POWER OF INTEGER
XEXP3    SRA       R4,1                SHIFT EXPONENT
         BH        XEXP1               DONE ?
XEXPSW   BCR       *-*,R14             YES - RETURN IF +VE EXPONENT
         LR        R3,R1
         SR        R0,R0               INVERT RESULT
         LA        R1,1
         DR        R0,R3
         BR        R14
XEXPTM   TM        XTEST,X'00'
XTEST    DC        X'01'
         SPACE     3
**  EXPONENTIAL ROUTINE - REAL*8 TO INTEGER POWER
XR8EXPI  LDR       R4,F0
         LD        F0,XEXPLIT
         MVI       XEXPSW1,X'2C'
         LTR       R4,R4
         BH        XEXP21
         BL        XEXP69
         LTER      F4,F4
         BNER      R14
XERREX7  $ERROR    (TRAZ,EX,4)                                     V1L5
XEXP69   MVI       XEXPSW1,X'2D'
         LPR       R4,R4
         LTER       F4,F4
         BNZ       XEXP21
XERREX8  $ERROR    (TRAZ,EX,5)                                     V1L5
XEXP11   MDR       F4,F4               SQUARE REAL NUMBER
XEXP21   EX        R4,XEXPTM           IS THIS POWER OF TWO IN EXPONENT
         BZ        XEXP31              NO
XEXPSW1  MDR       F0,F4     YES - MPY OR DIVIDE RESULT BY POWER OF NO.
XEXP31   SRA       R4,1                SHIFT EXPONENT
         BH        XEXP11              DONE ?
         BR        R14                 YES - RETURN
         SPACE
**  EXPONENTIAL ROUTINE - REAL*8 TO REAL*8 POWER
XR8EXPR8 LTDR      F0,F0
         BH        XR81
         BL        XR83
         LTDR      F2,F2
         BHR       R14
XERREX6  $ERROR    (TRAZ,EX,3)                                     V1L5
XR83     LTDR      F2,F2
         LD        F0,XEXPLIT
         BZR       R14
XERREX9  $ERROR    (TRAZ,EX,6)                                     V1L5
XR81     LTDR      F2,F2
         BNZ       XR82
         LD        F0,XFLTONE
         BR        R14
XR82     STD       F0,XR8BASE
         STD       F2,XR8EXPN
         STM       R14,R1,XR8SAVER     STORE PROGRAMME'S REGISTERS
         L         R15,XR8ADLOG
         LA        R1,XR8LIST
         BALR      R14,R15             TAKE LOG OF REAL NUMBER
         LD        F2,XR8EXPN
         MDR       F0,F2               MULTIPLY BY EXPONENT
         STD       F0,XR8BASE
         LA        R1,XR8LIST
         L         R15,XR8ADEXP
         BALR      R14,R15             GO TO DEXP
         LM        R14,R1,XR8SAVER     RESTORE PROGRAMME'S REGISTERS
         BR        R14                 RETURN
         SPACE
*********   COMPLEX ARITHMETIC ROUTINES
         SPACE
**  COMPLEX EXPONENTIAL
XC16EXPI L         R15,XAPC16E
         BR        R15
XCMULT8  L         R15,XAPC16E
         BB        PCMULT8,PC16EXPI
XCMULT16 L         R15,XAPC16E
         BB        PCMULT16,PC16EXPI
XCDIV18  L         R15,XAPC16E
         BB        PCDIV18,PC16EXPI
XCDIV116 L         R15,XAPC16E
         BB        PCDIV116,PC16EXPI
XCDIV28  L         R15,XAPC16E
         BB        PCDIV28,PC16EXPI
XCDIV216 L         R15,XAPC16E
         BB        PCDIV216,PC16EXPI
         EJECT
*******   FIX- FLOAT ROUTINES
XFIX01   AW        F0,XFLIT3           FIXES F0 TO R1
         STD       F0,XCMT1
         NI        XCMT1+4,X'7F'
         L         R1,XCMT1+4
         TM        XCMT1,X'80'
         BCR       8,R14
         LCR       R1,R1
         BR        R14
XFIX61   LD        F4,XFLIT3           FIXES F6 TO R1
         AWR       F4,F6
         STD       F4,XCMT1
         NI        XCMT1+4,X'7F'
         L         R1,XCMT1+4
         TM        XCMT1,X'80'
         BCR       8,R14
         LCR       R1,R1
         BR        R14
         SPACE
XFLOAT14 LPR       R2,R1               FLOATS F1 TO R4
         N         R1,XFLIT
         STM       R1,R2,XCMT1
         OI        XCMT1,X'4E'
         SDR       F4,F4
         AD        R4,XCMT1
         BR        R14
XFLOAT34 LPR       R4,R3               FLOATS R3 TO F4
         N         R3,XFLIT
         STM       R3,R4,XCMT1
         OI        XCMT1,X'4E'
         SDR       F4,F4
         AD        F4,XCMT1
         BR        R14
         EJECT
XERRUV0  $ERROR    (TRAZ,UV,0,VM6R15)                              V1L5
XERRUV1  S         R14,KF8
         MVC       XUV1LA+2(2),ZR14+2
XUV1LA   LA        R15,*-*(RO)
         $ERROR    (TRAZ,UV,0,VM6R15)                              V1L5
XERRUV2  S         R14,KF4
XUV21    S         R14,KF4
         CLI       ZR14,X'45'
         BNE       XUV21
         MVC       XUV2LA+2(2),ZR14+2
XUV2LA   LA        R15,*-*(RO)
         $ERROR    (TRAZ,UV,0,ARRR15)                              V1L5
XERRUV4  S         R1,KF12
         MVC       XUV5LA+2(2),ZR1+8
XUV5LA   LA        R1,*-*(RO)
         $ERROR    (TRAZ,UV,4,VM6R1)                               V1L5
XERRUV5  $ERROR    (TRAZ,UV,5,VARR15)                              V1L5
XERRUV6  $ERROR    (NOAC,UV,5,ENTR11),XRETRACE                     V1L5
*******  THE CODING FOR XCGTEST2 IS IN ANTICIPATION OF A FIX TO DODO
XCGTEST2 CH        R2,XUNDEF           REFERENCED BY DODO
         BNER      R3
         B         XERRGO4
XCGTEST  BPR       R14                 NO ERROR IF +VE
         C         R2,XUNDEF           COMPARE FOR UNDEFINED VARIABLE
         BNER      R3                  BRANCH TO NEXT FORTRAN STAT
XERRGO4  $ERROR    (TRAZ,GO,4)                                     V1L5
***  XERRGO5 IS HERE IN ANTICIPATION OF A FIX TO DODO
XERRGO5  $ERROR    (TRAZ,GO,4)                                     V1L5
XERRDO7  BPR       R14
         S         R14,KF10
         CLC       ZR14+2(2),KF0       COMPARE FOR COM OR EQUIV
         BNE       *+8
         S         R14,KF4
         MVC       XDO7LA+2(2),ZR14+2
XDO7LA   LA        R15,*-*(RO)
         S         R15,KF10
         $ERROR    (TRAZ,DO,7,NAVR15)                              V1L5
XROUTS1  XROUTS    1         CHECK FOR UNDEFINED S. VAR. LENGTH 1
XROUTS2  XROUTS    2         CHECK FOR UNDEFINED S. VAR. LENGTH 2
XROUTS4  XROUTS    4         CHECK FOR UNDEFINED S. VAR. LENGTH 4
XROUTS8  XROUTS    8         CHECK FOR UNDEFINED S. VAR. LENGTH 8
XROUTS16 XROUTS    16        CHECK FOR UNDEFINED S. VAR. LENGTH 16
XROUTE1  XROUTE    1         CHECK FOR UNDEFINED EQ.VAR. LENGTH 1
XROUTE2  XROUTE    2         CHECK FOR UNDEFINED EQ.VAR. LENGTH 2
XROUTE4  XROUTE    4         CHECK FOR UNDEFINED EQ.VAR. LENGTH 4
XROUTE8  XROUTE    8         CHECK FOR UNDEFINED EQ.VAR. LENGTH 8
XROUTE16 XROUTE    16        CHECK FOR UNDEFINED EQ.VAR. LENGTH 16
XROUTA1  XROUTA    1    CHECK FOR UNDEFINED ARRAY MEMBER LENGTH 1
XROUTA2  XROUTA    2    CHECK FOR UNDEFINED ARRAY MEMBER LENGTH 2
XROUTA4  XROUTA    4    CHECK FOR UNDEFINED ARRAY MEMBER LENGTH 4
XROUTA8  XROUTA    8    CHECK FOR UNDEFINED ARRAY MEMBER LENGTH 8
XROUTA16 XROUTA    16   CHECK FOR UNDEFINED ARRAY MEMBER LENGTH 16
XTRUESP  DC        F'255'
     EJECT
*******************************************************************
*        THE FOLLOWING ROUTINES ARE USED BY THE OBJECT CODE TO    *
*        PERFORM I/O.                                             *
*        EACH FORTRAN I/O STATEMENT CAUSES A TRANSFER TO ONE OF   *
*        'XIOINIT' OR 'XIOINTCC' FOR NORMAL AND CORE TO CORE I/O  *
*        RESPECTIVELY.THIS ROUTINE INITIALIZES THE THE UNIT       *
*        REQUIRED,SETS UP AN ADDRESS FOR LINKAGE BETWEEN THE      *
*        OBJECT CODE AND THE FORMAT PROCESSOR,GOES TO FIOCS OR    *
*        DIOCS TO GET A BUFFER ADDRESS AND LENGTH,AND GOES TO THE *
*        FORMAT CONVERSION INITIALIZER.                           *
*        CONTROL THEN RETURNS TO THE I/O LIST CODING IN THE       *
*        OBJECT CODE.THIS CODE THEN BRANCHES TO ONE OF THE        *
*        FOLLOWING:'XSIMPELT','XSUBSELT','XARRAY','XCHARSIM',     *
*        'XCHARSUB','XCHARARR'.THESE ROUTINES GET THE ADDRESS     *
*        OF THE REQUIRED VARIABLE,AND,IN THE CASE OF A            *
*        CHARACTER VARIABLE,ITS  ELEMENT LENGTH,AND THEN,USING    *
*        THE ADDRESS SET UP BY THE I/O INITIALIZER,BRANCH TO THE  *
*        FORMAT CONVERSION PROCESSOR,WHICH RETURNS CONTROL TO THE *
*        OBJECT CODE.AT THE END OF AN I/O LIST A BRANCH TO        *
*        'XENDLIST' IS MADE TO TIDY UP.                           *
*        NOTE:CHARACTER VARIABLES ARE HANDLED IN A SOMEWHAT       *
*        DIFFERENT MANNER.THIS IS EXPLAINED IN THE APPROPRIATE    *
*        SECTION.                                                 *
*******************************************************************
         EJECT
*******************************************************************
*********               SKELETON ENTRIES                  *********
*******************************************************************
*                                                                 *
*        XIOINIT   ENTRY TO INITIALIZE ALL I/O EXCEPT CORE TO CORE*
*        XDEFILE   ENTRY FOR DEFINE FILE INITIALIZER              *
*        XIOINTCC  ENTRY FOR CORE TO CORE I/O INITIALIZER         *
*        XIOCCFRM  RETURN AFTER CALCULATING A(V2(N))              *
*        XCHARSIM  ENTRY FOR SIMPLE CHARACTER LIST ELEMENT        *
*        XCHARSUB  ENTRY FOR CHARACTER ARRAY ELEMENT LIST ELEMENT *
*        XCHARARR  ENTRY FOR CHARACTER ARRAY LIST ELEMENT         *
*                                                                 *
*******************************************************************
XIOINIT  L         R15,XAXIOB
         BB        PIOINIT
         SPACE
XIOINTDA L         R15,XAXIOB
         BB        PIOINTDA
         SPACE
XDEFILE  L         R15,XAXIOB
         BB        PDEFILE
         SPACE
XIOINTCC L         R15,XAXIOB
         BB        PIOINTCC
         SPACE
XIOCCFRM L         R15,XAXIOB
         BB        PIOCCFRM
         SPACE
XCHARSIM L         R15,XAXIOB
         BB        PCHARSIM
         SPACE
XCHARSUB L         R15,XAXIOB
         BB        PCHARSUB
         SPACE
XCHARARR L         R15,XAXIOB
         BB        PCHARARR
         EJECT
XIFOBJ   L         R15,XAXIOB                                      V1L5
         BB        PIFOBJ                                          V1L5
         SPACE     1                                               V1L5
*******************************************************************
*********          I/O LIST HANDLING ROUTINES             *********
*******************************************************************
*                                                                 *
*        INPUTS:   R3        FOR XSUBSELT ONLY                    *
*                            A(V(N))                              *
*                                                                 *
*        OUTPUTS   R3        ADDRESS OF VARIABLE                  *
*                                                                 *
*******************************************************************
XSIMPELT L         R3,ZR14             GET DATA ADDRESS
*        R3 NOW HAS ADDRESS OF DATA IN IT
XSUBSELT L         R4,XXADDR           FORMAT CONVERSION ADDRESS
PEXIT    STM       5,14,XIOSAVE
PEXIT1   L         R15,XBASADDR
         B         ZR4+4(RO)           OFF TO FORMAT CONVERSION
XENDLIST L         R4,XXADDR           FORMAT CONVERSION ADDRESS
         S         R4,KF4
PEXIT11  MVI       XIORECUR,OFF        SET I/O RECURSIVE SW OFF    V1L2
         B         PEXIT     RETURN TO XENDLIST CODING             V1L2
         SPACE
*****    THE FOLLOWING ROUTINE DUMMIES UP ARRAYS TO LIKE LIKE
*****    ARRAY ELEMENTS,AND PASSES THEM TO 'XSUBSELT' ONE AT A TIME
XARRAY   L         R3,ZR14             A(.RTN) TO R3
         IC        R2,ZR14             PICK UP CODE BYTE
         N         R2,KF15             TYPE AND LENGTH IN R2
         STC       R2,XGIMIKSS+4       SAVE IT
         IC        R2,KT2(R2)          PICK UP LENGTH/ELEMENT
XARRBAL  ST        R2,XELTLENT
         ST        R14,XSAV14          ADDRESS-START OF DOT RTN TO R3
         BAL       R1,X1STELT          GET 1ST ELT ADDR AND LENLEN
         AR        R2,R3
XARRTOT  EQU       *                   FOR FORMCONV                V1L3
         ST        R2,XTOTLNP1         LAST BYTE+1-START           V1L2
         MVI       XRAYPROC,X'80'      SET THE PROCESSING ARRAY SW V1L2
         B         XGIMMIK                                         V1L2
         CNOP      0,4                 ALIGN FOR XGIMIKSS
XGIMMIK  ST        R3,XCRNTELT         SAVE CURRENT ELEMENT ADDR.
         L         R2,XELTLENT         ELEMENT LENGTH-FOR CHAR VARS
XGIMIKSS BAL       R14,XSUBSELT        THIS LOOKS LIKE REGULAR CALL TO
         DC        AL1(*-*),3X'00'     DUMMY OBJECT CODE
         L         R3,XCRNTELT         ADDRESS WHERE WE LEFT OFF
         A         R3,XELTLENT         BUMP ADDRESS
         C         R3,XTOTLNP1         ARE WE DONE
         BL        XGIMMIK             NO
         L         R14,XSAV14          YES                         V1L2
         MVI       XRAYPROC,X'00'    RESET THE PROCESSING ARRAY SW V1L2
         B         ZR14+4              RETURN TO OBJECT CODE       V1L2
*  HERE'S THE ARRAY SWITCH,CHET.X'80' IF PROCESSING AN ARRAY       V1L2
*                               X'40' IF DA-4 MESSAGE ISSUED       V1L2
XRAYPROC DC        X'00',AL3(*-*)      XARRAY PROCESSING AN ARRAY  V1L2
         EJECT
***    GETS ADDRESS OF FIRST ELEMENT OF ARRAY AND ITS LENGTH IN BYTES
***      R3=A(V(1))      R2=LEN(V)
         SPACE
X1STELT  L         R2,ZR3+8            GET LENGTH
         LA        R2,ZR2              ZERO TOP BYTE
         L         R3,ZR3+4            GET ADDRESS
         BR        R1                  RETURN
         EJECT
*******************************************************************
*********               SKELETON ERROR PROCESSOR          *********
*******************************************************************
XFATAL   EQU       X'0F'               SERIOUS ERROR FLAG
XINHIBX  EQU       X'FF'               DONT GO INTO EXECUTION
         SPACE
**  IN-LINE ERROR CODE,SAVE REGISTERS HERE
*****  XERRENT3 MOVED TO FUNCREF PART OF STARTA
         SPACE
*   OUT-OF-LINE CODE,SAVE REGISTERS HERE
XERRENT4 STM       R0,R15,XHELPS
         L         R11,XAXERRP
         BALR      R14,R11
         LM        R0,R15,XHELPS
         BR        R14
         SPACE
*   REGISTERS SAVED,IN-LINE CODE
XERRENT1 LR        R1,R14
         LA        R14,ZR14+2          BUMP FOR 2 BYTE CODE
         TM        ZR1,X'80'           TEST FOR 4 BYTE CODE
         BZ        XERRENT2
         LA        R14,ZR14+2          BUMP FOR 4 BYTE CODE
         SPACE
**  OUT-OF-LINE CODE,REGISTERS SAVED
XERRENT2 L         R11,XAXERRP
         BR        R11
         EJECT
*******************************************************************
*********          SKELETON DATA STAT. EXECUTOR           *********
*******************************************************************
**  INTERPRETS,PRIOR TO EXECUTION,THE LISTS SET UP BY THE DATA
***      STATEMENT COMPILER.
**  THIS PART OF THE ROUTINE DOES INITIALIZATION FOR PDATA WHICH
**       HANDLES INDIVIDUAL ELEMENTS IN THE DATA LISTS AS IN I/O LISTS.
*******************************************************************
         SPACE
XDATA    MVC       XXADDR+1(3),XAPDATB SET XXADDDR
         MVC       XBASADDR+1(3),XAPDATB
         MVC       XENTRYPD+1(3),ZR14+1  SAVE NEXT DATA STATEMENT
         MVC       XNOLISTS+1(1),ZR14+4  SAVE NO OF SUBLISTS
         L         R13,ZR14+4          PICKUP SAVEAREA ADDRESS
         LM        R5,R10,ZSVX5-ZSAVER+ZR13  LOAD DATA REGISTERS
         LA        R1,ZR14+8      R1 POINTS TO CONLIST POINTER     V1L2
         MVI       XRAYPROC,X'00'      ZAP THE PROCESSING ARRAY SW V1L2
         B         XLSTLOOP                                        V1L2
         SPACE
**   PROCESS EACH SUBLIST OF DATA STATEMENT FROM HERE
XLSTLOOP MVI       XNOTNUFF+1,NOP      SET SWITCH TO NOP
         MVC       XNOCONS(2),ZR1      SAVE # OF ENTRIES IN CONLISTV1L5
         LR        R14,R1              SET R14 TO I/O LIST PART
         AH        R1,ZR1+2            R1 POINTS TO CONLIST ELEMENTS
XLSTLP1  ST        R1,XSVCONPT         SAVE IT
         MVC       XCONELT(8),ZR1      SAVE CONLIST ELEMENT
         B         ZR14+4              BACK TO I/O LIST CODING
         SPACE
XNOTNUFF DC        0H'0',AL4(R15*PAGE+XERRDA2-PDATBASE)
         ORG       *-4
         DC        X'4700'
         ORG       *+2
XDATATRZ OI        XERRSWT,XFATAL       FLAG FATATL ERROR
XNXTDATA L         R11,XENTRYPD         GET A(NEXT DATA STMT)
         BR        R11                  GO THERE
         EJECT
XDOUBLE  DC        D'0'                TEMPORARY FOR XRUPT
XR8BASE  DS        D
XR8EXPN  DS        D
XTEMP    DS        D
XCONELT  DS        0D,XL8
         AIF      ('&MEMTYPE' EQ 'MAX').XOBJECT
XOBJECT  DC           A(OBJECT)
XSYMBOL  DC           A(SYMBOL)
XSTACK   DC           A(STACK)
STACKEND DC           A(STACK+SN*4-69*4)
XENDOBJ  DC           A(ENDOBJ)
         AGO       .XENDOBJ
.XOBJECT ANOP
XOBJECT  DC        F'0'                                            V1L4
XSYMBOL  DS        F
XSTACK   DS        F
STACKEND DS        F
XENDOBJ  DC        F'0'                                            V1L4
.XENDOBJ ANOP
XHELPS   DS        16F       FIRST FOUR WORDS USED BY XR8EXPR8
XR8SAVER EQU       XHELPS
XRUPTSV  DS        5F                  USED BY XRUPT
XSAVER   DS        18F
XENTRYP  DS        F
XENTRYPD DS        F
XBEGDATA DS        F
XENDDATA DS        F
XFALSE   DS        F
XTRUE    DS        F
XREADS   DS        0F
XPRINTS  DS        16F
XREADAS  DS        0F
XPRINTAS DS        F
XVMSWT   DC        X'00'                                           VM1
XVM1STSW DC        X'FF'               FIRST TIME TO MONITOR SW    VM1
XEXEC1SW DC        X'00'               MODE SW (INTERACTIVE/DEBUG) VM1
XVMASK   EQU       X'80'               INTERACTIVE MODE SW         VM1
         AIF       ('&OPSYS' NE 'DOS').FORGET                      V1L5
XTIMER   DS        F                   JAI CLOCK ADDR              DOS2
XPARTIME DS        F                   JAI CPU TIME ADDR           DOS2
.FORGET  ANOP                                                      DOS2
XBUFFER  EQU       XPRINTAS
XIOSAVE  DS        10F
XR14RET  EQU       XIOSAVE+36
XTOTLNP1 DC        A(*-*)
XCRNTELT DC        A(*-*)
XRADDR   DC        A(*-*)
XXADDR   DC        A(*-*)
XBASADDR DC        A(*-*)
XSAV14   DC        A(*-*)
XSVCONPT DC        A(*-*)
XELTLENT DC        F'0'
XTRCOUNT DC        A(&TRCOUNT)         TRACEBACK LOOP CONTROL
XMNAM    DC        0F'0',CL6'&MPROGN'  MAIN PROGRAM NAME
         CNOP      2,4
XCARD1   DC        CL10' '
XCARD    DC        CL80' '
XISNCD   DC        0H'0',X'B8',AL.4(RP),AL.4(RX)
XISN     DC        H'0'
XLINK    DC        X'FF',AL3(0)        PTR TO NEXT ISN COUNTED     V1L5
XCOUNT1  DC        F'0'                COUNT OF STATEMENT          V1L5
XCOUNT2  DC        F'0'                COUNT OF OBJECT(IF & WH-EX) V1L5
XPRSTART DC        F'0'                ADDR OF FIRST STMT COUNTED  V1L5
XTOTCNT1 DC        F'0'                TOTAL STATEMENTS EXECUTED   V1L5
XTOTCNT2 DC        F'0'                TOTAL OBJ STMT'S EXECUTED   V1L5
XARGCNT  DC        F'0'                ARGUMENT COUNT              V1L5
CCNTSW   DC        X'0'                STMT COUNT SWITCH           V1L5
XPROFC   EQU       X'01'               COUNT SWITCH                V1L5
XPROFP   EQU       X'02'               PERCENTAGE HISTOGRAM SW     V1L5
XPROFR   EQU       X'04'               RELATIVE HISTOGRAM SWITCH   V1L5
XPROF    EQU       X'07'               ALL OF THE ABOVE SWITCHES   V1L5
XPROFON  EQU       X'80'               PROFILE ON SWITCH           V1L5
         DC        0F'0'               ALIGN XNOERRS               V1L5
XNOERRS  DC        H'0'                THESE 3 CONSTANTS           V1L5
XNOEXTNS DC        H'0'                MUST BE KEPT TOGETHER       V1L5
XNOWARNS DC        H'0'                                            V1L5
XNOCONS  DC        AL2(*-*)
XNOLISTS DC        AL2(*-*)
XERRSWT  DC        X'0'
CIHGACRD DC        X'0'
XEXECSW  DC        X'0'
CUNDEFSW DC        X'0'
XFDSWT   DC        X'0'                FIOCS/DIOCS SWITCH
XDNTRZSW DC        X'0'
CWARNSW  DC        X'00'               WARN-EXTNSN/NOWARN-NOEXTNSN SW
CEXTNSW  DC        X'00'               EXT / NOEXT SWITCH          V1L5
COPT     DC        X'0'
XQUOTCON DC        X'00'
XPUNDSRN DC        AL1(&PUNCH)
XISNTRAC DC        AL1(0)              ISN TRACE SWITCH
XSTOPSW  DC        AL1(&STOPN)         ALLOW OPERATOR MESSAGES ?
XSRBR    DC        X'F0'               SUBSCRIPTING RTN MASK       V1L5
         EJECT
* CONSTANTS
         SPACE
XR8ADEXP DC        A(DEXP)
XDMPLIST DC        A(*-*)              DUMPLIST CHAIN POINTER      V1L2
XAXBOOT  DC        A(XBOOT)                                        V1L2
XAXERRP  DC        A(ERROR)
XINPDSRN DC        0F'0',X'3000',H'&READ'
         DC        A(XIOEND,XIOERR)
XOUTDSRN DC        0F'0',X'3000',H'&PRINT'
         DC        A(XIOEND,XIOERR)
XAMNRST  DC        A(MAINREST)
XR8LIST  DC        AL1(SIMV+REAL8)
         DC        AL3(XR8BASE)
XR8ADLOG DC        B'00100101'
         DC        AL3(DLOG)
         AIF       ('&WHOSIT' NE 'WATFIV').XFIOCS                  V1L4
XAFIOCS  DC        V(WATFIOCS)
.XFIOCS  ANOP                                                      V1L4
         AIF       ('&WHOSIT' EQ 'WATFIV').XTAPE99                 V1L4
XAFIOCS  DC        V(TAPE99)                                       UOW
.XTAPE99 ANOP                                                      V1L4
XAXIOB   DC        A(XIOBASE)
XAPC16E  DC        A(PC16EXPI)
XATRACEB DC        A(XTRACEB1)
XAXERDA2 DC        A(XERRDA2)
XADYENTA DC        A(YENTA)
XFLIT    DC        X'80000000'
XAPDATB  DC        AL3(PDATBASE)
XSSMASK  DC      X'20202020202020202021204B2020'
XEDMASK  EQU       XSSMASK+2
XEDPAT   EQU       XSSMASK+6           USED BY PSTOPN
XCONTROL DC        C'&CONTROL'         CONTROL CHARACTER FOR JOBS
         AIF       ('&CONTROL'(1,1) EQ '&CONTROL').XCTRL
&XCTRL2  SETC      '&CONTROL'(2,2)                                 V1L5
.XCTRL   ANOP
         ORG       XCONTROL+3          MAKE A CONSTANT SPACE       V1L5
JMRUPTSW DC        X'00'               RETURN CODE                 V1L5
         EJECT
* LITERALS
         SPACE
KF0      DC        F'0'
KF1      DC        F'1'
KH1      EQU       KF1+2                                           V1L3
KF2      DC        F'2'
KF3      DC        F'3'
KF7      DC        F'7'
KF8      DC        F'8'
KF10     DC        F'10'
KF12     DC        F'12'
KH12     EQU       KF12+2
KF14     DC        F'14'
KF15     DC        F'15'
KF31     DC        F'31'
KFM1     DC        F'-1'
KM0531   DC        X'07FFFFFF'
KM1631   DC        X'0000FFFF'
KM2527   DC        X'00000070'
KM2631   DC        X'0000003F'
         DC        0F'0'                                           V1L2
*     THE FOLLOWING FOUR SWITCHES MUST BE CONTIGUOUS               V1L2
XIORECUR DC        X'00'               I/O RECURSIVE SWITCH        V1L2
XDUMPSW  DC        X'00'               DUMPLIST SW                 V1L2
XDMPRCUR DC        X'00'               TRACEBACK RECURSIVE SW      V1L2
XERRSW   DC        X'00'               ONERROR SW                  V1L2
XERRLIST DC        F'0'                ONERROR LIST POINTER        V1L2
KM2831   EQU       KF15
KM2931   EQU       KF7
KM3031   EQU       KF3
KH0      EQU       KF0+2
KH2      EQU       KF2+2
KH4      EQU       KF4+2
XDARECNO EQU       XENTRYP
KBL6     DC        CL6'      '
KBL5     EQU       KBL6
KBL2     EQU       KBL6
KT1      DC        AL1(4-1,1-1,4-1,2-1,4-1,8-1,8-1,16-1,1-1)
KT2      DC        AL1(4,1,4,2,4,8,8,16,1)
XFORM    EQU       12
XNOFORM  EQU       8
XONE     EQU       KF1
XZERO    EQU       KF0
X0       EQU       KF0
XDEBUGSW DC        X'00'                                           V1L2
*KEYPUNCH MODE SW: LIBRARY CHAR MODE=INPUT SOURCE DECK MODE->X'0C' V1L5
XMODEKP  DC        X'00'               EBCDIC->X'06'  BCDIC->X'00' V1L5
KOMPSW   DC        X'00'                                           V1L5
XOMRSW   EQU       X'80'                                           V1L5
LINES0   EQU       X'40'                                           V1L5
SPROF1SW EQU       X'20'             INDICATES A $PROFON WAS FOUND V1L5
***********************************************************************
**       PATCH AREA FOR WATFIV UPDATES OR FOR INSTALLATION CHANGES   **
**                                                                   **
XPATCH   DC        25A(*-*)                                        V1L1
         ORG       XPATCH                                          V1L1
         AIF       ('&OPSYS' NE 'DOS').NTDOS                       V1L5
TTESTMR  LR        R2,R1               SAVE R1                     DVS2
         GETIME    TU                  GET THE TIME                DVS2
         LR        R3,R1               R3 = TIME                   DVS2
         LR        R1,R2               RESTORE R1                  DVS2
         AIF       ('&TIMER' NE 'TASK').JAIBYE                     DOS2
         LM        R1,R2,XTIMER        GET TIMER ADDR              DOS2
         AL        R3,0(R1)            ADD CURRENT TIME INTERVAL   DOS2
         LM        R1,R2,0(R2)         GET CPU AND OVERHEAD TIME   DOS2
         AR        R3,R1               ADD CPU TIME                DOS2
         AR        R3,R2               ADD OVERHEAD TIME           DOS2
.JAIBYE  C         R3,JTIMOUT          HAS TIME ELAPSED            DOS2
         BNL       XISNRTN+4           BOOT IF YES                 DOS2
.NTDOS   ANOP                                                      DVS1
         AIF       ('&ISNTRAC' EQ 'OMIT').XISNP1                   V1L5
XISNPATC B         XISNVM                                          V1L5
         L         R15,XAXIOB          SET UP THE INDEX REG        V1L5
         BB        XISNOUT                                         V1L5
         AGO       .XISNP2                                         V1L5
.XISNP1  ANOP                                                      V1L5
XISNPATC NOP       *-*                                             V1L5
         NOP       *-*                                             V1L5
         NOP       *-*                                             V1L5
.XISNP2  AIF       ('&VM' EQ 'OMIT').XVM5                          V1L5
XISNVM   B         XPROFILE                                        V1L5
         L         R15,XAXIOB          SET UP THE INDEX REG        V1L5
         BB        XVMDEBUG                                        V1L5
         AGO       .XVM6                                           V1L5
.XVM5    ANOP                                                      V1L5
XISNVM   NOP       *-*                                             V1L5
         NOP       *-*                                             V1L5
         NOP       *-*                                             V1L5
.XVM6    ANOP                                                      V1L5
XPROFILE B         ZR11+2              BRA/NOP                     V1L5
         AIF       ('&PROFILE' EQ 'OMIT').PROF9                    V1L5
         L         R15,XAXIOB          SET UP THE INDEX REG        V1L5
         BB        PCHKCNT                                         V1L5
         AGO       .PROFB                                          V1L5
.PROF9   ANOP                                                      V1L5
         NOP       *-*                                             V1L5
         NOP       *-*                                             V1L5
.PROFB   ANOP                                                      V1L5
         AIF       ('&STR' NE 'USE').SASTR1                        ST1
XRECPAR  $ERROR    (TRAZ,SP,K)                                     V1L5
.SASTR1  ANOP                                                      ST1
XVMDSWT  EQU       XISNVM+1                                        V1L5
         ORG       ,                                               V1L5
***********************************************************************
         EJECT
         AIF       ('&SNAPS' EQ 'OMIT').XSN2
*******************************************************************
*********          SNAPSHOT ROUTINE                      **********
*******************************************************************
         SPACE
* REGISTER USAGE
         SPACE
R100     EQU       R4                  PTS TO CODE TO BE DUMPED
ZR100    EQU       ZR4
R101     EQU       R5                  NUMBER OF BYTES
R102     EQU       R6                  WORK REGISTER
R103     EQU       R8
ZR103    EQU       ZR8
R104     EQU       R9
ZR104    EQU       ZR9
R105     EQU       R11                 PROGRAM ADDRESSING
ZR105    EQU       ZR11
         SPACE
XSNAP1   BCTR      R2,0
XSNAP    L         R105,XAXSNAP5
         BR        R105
XSNAPSAV DS        18F
XAXSNAP5 DC        A(XSNAP5)
*******************************************************************
.XSN2    ANOP
         EJECT
         AIF       ('&TRACE' EQ 'OMIT').XTN1
*******************************************************************
*****   IMPLEMENTS THE COMPILER DEBUGGING STATEMENTS 'STARTTRACE' AND
*        'ENDTRACE' WHICH ACTIVATE THE TRACE AT EXECUTION TIME
***********************************************************************
XTRACON  TRACEON
TRACEPTR EQU       *-12
         BR        RDONE
XTRACOFF TRACEOFF
         BR        RDONE
*******************************************************************
.XTN1    ANOP
         LTORG
         EJECT
SN       EQU       &NOCCRDS*69+69
         AIF       ('&MEMTYPE' EQ 'MAX').OBJECT
SNN      EQU       SN*4
         AIF       (&NOCCRDS GE 5).SNNN
SNN      EQU       (4*69+69)*4
.SNNN    ANOP
OBJECT   DS        0F
         DS        (&MEMSIZE-(SNN+24))C
SYMBOL   DS        0F
*  DUMMY STACK ENTRY USED BY ARITH TO MAKE RECORD NUMBER RESEMBLE ASF
ADUMENT  DC        0H'0'               MUST BE WITHIN 15 PAGES OF STACK
         DC        X'0000'             LINK IS ZERO
         DC        AL1(TERM)           OPERATOR IS TERM
         DC        X'A8'               CODE IS ARMEMBR
         DC        AL1(SIMV+INT4)      OPND IS INTEGER*4
         DC        X'000000'
         DC        2F'0',H'8',X'0381',F'0'
STACK    DS        0F
         DS       (SNN)C
ENDOBJ   DS        0D
.OBJECT  ANOP
         SPACE
         $FREE     R1,R2,R3,R4,R5,R6,R7,R8,R9,R11,R13,R14,R15      V1L5
         DS        0D                  ALIGN TO DOUBLE WORD BOUNDARY
STARTAE  EQU       *-1                 GENERATE ENTRY FOR END OF STARTA
         SPACE
         TITLE     ' '
