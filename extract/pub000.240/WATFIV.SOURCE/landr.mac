LNDR     TITLE     'LANDR     LINKAGE STATEMENTS AND RELOCATOR'
         COPY      OPTIONS
         PRINT     OFF
         $PUNCH    LANDR                                           DVS2
&DECK    SETC      'LANDR'
         COPY      EXTRN
         COPY      CDEFN               PROGRAM DEFINITIONS
STARTA   DSECT
         COPY      STARTA              START REGION
COMMR    DSECT
         COPY      COMMR               COMMUNICATIONS REGION
         ERRTABLE
         PRINT     ON,&LIST
         TITLE     'LANDR     LINKAGE ROUTINES'
LRCS     CSECT
         PRINT     ON,&LIST
         ENTRY     LASFE               ASF ENTRY
         ENTRY     LASFR               ASF RETURN
         ENTRY     LBLOC               BLOCK DATA STATEMENT
         ENTRY     LCOMP               COMPLEX FUNCTION STATEMENT
         ENTRY     LDOUB               DOUBLE PRECISION FUNCTION
         ENTRY     LEND                END STATEMENT
         ENTRY     LENDPROG            END OF PROGRAM INITIALIZATION
         ENTRY     LENDS               MISSING END STATEMENT
         ENTRY     LENTR               ENTRY STATEMENT
         ENTRY     LFUNC               FUNCTION STATEMENT
         ENTRY     LINTE               INTEGER FUNCTION STATEMENT
         ENTRY     LLOGI               LOGICAL FUNCTION STATEMENT
         ENTRY     LMAIN               MAIN PROGRAM GENERATOR
         ENTRY     LREAL               REAL FUNCTION STATEMENT
         ENTRY     LRETU               RETURN STATEMENT
         ENTRY     LSUBR               SUBROUTINE STATEMENT
         SPACE
         EXTRN     TEQUIV1
         EJECT
         USING     STAK,RS
         SPACE
*******************************************************************
**********                   FUNCTION                    **********
*******************************************************************
LFUNC    CENT      LSAVER              FUNCTION ENTRY POINT
         THEN      (DO,LENDTEST)
         ST        R5,LENTRYP          ENTRY POINT                 V1L5
         THEN      (CSRSWTCH,EQU,FUNC)
         IFANY     (SCODE,EQ,PHI),(SCODE,NOFF,MNAME),LFCOM62
         L         R4,CFBEG                                        V1L5
         USING     RLIST,R4
         THEN      (RB1,EQU,FUNC)
         THEN      (RB2,EQU,USAGE+MENTRY)
         LOOKUP    VARIABLE            LOOKUP FUNCTION NAME
         USING     VLIST,R15          POINTS TO V LIST
         THEN      (VB2,EQU,USAGE)
         AH        RS,SLINK          STEP STACK
         IF        (SOPTR,NE,STAR),LFCOMB
         CLC       SOPND,KSC4
         BE        LFUNC15
LFUNC10  IF        (VB1,SVAR,REAL4),LFUNC20
         CLC       SOPND,KSC2
         BNE       LERRFN4A
         OI        VB1,INT2
         MVI       VLEN,2
LFUNC15  OI        VB2,TYPE
LFUNC17  AH        RS,SLINK
         B         LFCOMB
LFUNC20  CLC       SOPND,KSC8
         BNE       LERRFN4A
         OI        VB1,REAL8
         MVI       VLEN,8
         B         LFUNC15
         SPACE
LERRFN4A $ERROR    (BOOT,FN,4,SYMR9,INVAL),LFUNC17                 V1L5
         SPACE
         $FREE     R4,R15                                          V1L5
         EJECT
*******************************************************************
**********              COMPLEX FUNCTION                 **********
*******************************************************************
LCOMP    CMENT     LSAVER,LFUNC
         THEN      (DO,LENDTEST)
         THEN      (CSRSWTCH,EQU,FUNC+COMP8)
         LA        R7,COMP8           SET R7 FOR COMPLEX*8
         BAL       R8,LFCOMD
         DC        FL.5'1',FL.27'8'
         DC        FL.5'2',FL.27'16'
         EJECT
*******************************************************************
**********         DOUBLE PRECISION FUNCTION             **********
*******************************************************************
LDOUB    CMENT     LSAVER,LFUNC
         THEN      (DO,LENDTEST)
         ST        R5,LENTRYP          ENTRY POINT                 V1L5
         THEN      (CSRSWTCH,EQU,FUNC+REAL8)
         IFANY     (SCODE,EQ,PHI),(SCODE,NOFF,MNAME),LFCOM62
         LR        R1,RS
         LA        R2,8
         LA        R7,REAL8
         B         LFCOMA              GOTO COMMON
         EJECT
*******************************************************************
**********              INTEGER FUNCTION                 **********
*******************************************************************
LINTE    CMENT     LSAVER,LFUNC
         THEN      (DO,LENDTEST)
         THEN      (CSRSWTCH,EQU,FUNC+INT4)
         LA        R7,INT4
         BAL       R8,LFCOMD           GO TO COMMON
KSC4     DC        FL.5'1',FL.27'4'
KSC2     DC        FL.5'1',FL.27'2'
         EJECT
*******************************************************************
**********              LOGICAL FUNCTION                 **********
*******************************************************************
LLOGI    CMENT     LSAVER,LFUNC
         THEN      (DO,LENDTEST)
         THEN      (CSRSWTCH,EQU,FUNC+LOG4)
         SR        R7,R7               SET R7 FOR LOGICAL*4
         BAL       R8,LFCOMD           GO TO
         DC        FL.5'1',FL.27'4'
         DC        FL.5'1',FL.27'1'
         EJECT
*******************************************************************
**********              REAL FUNCTION                    **********
*******************************************************************
LREAL    CMENT     LSAVER,LFUNC
         THEN      (DO,LENDTEST)
         THEN      (CSRSWTCH,EQU,FUNC+REAL4)
         LA        R7,REAL4
         BAL       R8,LFCOMD           GO TO COMMON
         DC        FL.5'1',FL.27'4'
KSC8     DC        FL.5'1',FL.27'8'
         EJECT
*******************************************************************
**********                   SUBROUTINE                  **********
*******************************************************************
LSUBR    CMENT     LSAVER,LFUNC
         THEN      (DO,LENDTEST)
         ST        R5,LENTRYP                                      V1L5
         THEN      (CSRSWTCH,EQU,SUBR)
         IFANY     (SCODE,EQ,PHI),(SCODE,NOFF,MNAME),LSUBR46
         LOOKUP    VARIABLE            LOOKUP NAME
         USING     RLIST,R15
         THEN      (RB1,EQU,SUBR)
         THEN      (RB2,EQU,TYPE+USAGE+MENTRY)
         MVC       RADDR,LENTRYP      MOVE ENTRY POINT ADDRESS
         THEN      (DO,CNOP04)         CALL CNOP04;
         LA        R0,ZR5+8            USING FOR R11 AT EXEC
         ST        R0,CBAR11                                       V1L5
         THEN      (OUTPUT,20,LCSUBR)            OUTPUT OBJECT
         USING     ENTRSEQ,R3
         MVC       ENTRISN,XISN        ENTR.ISN=XISN;
         MVC       ENTRNAME,RNAME      ENTR.NAME=R.NAME;
         $FREE     R3,R15                                          V1L5
         SPACE
LSUBR17  AH        RS,SLINK          STEP STACK
         IF        (SOPTR,NE,LBRK),LSUBR18  IF ARG LIST
         CLINK1    LARGL,LSUBR20       YEP
LSUBR18  IF        (SOPTR,NE,TERM),THEN,(DO,LERRSXAA)
LSUBR20  THEN      (DO,CNOP04)         ALLIGN
         THEN      (OUTPUT,4,LASTARG),CRET       OUTPUT LAST ARG
         EJECT
LSUBR46  LOOKUP    SPCLNAME,NAME=BLANKNAM  CREATE DUMMY ENTRY
         USING     RLIST,R15
         THEN      (RB1,EQU,SUBR),(RB2,EQU,TYPE+USAGE+MENTRY)
         THEN      (DO,LERRSRA),LSUBR17          TELL HIM ABOUT IT
         EJECT
*******************************************************************
**********                   ENTRY                       **********
*******************************************************************
LENTR    CMENT     LSAVER,LFUNC
         IF        (CIFGOTSW,EQ,X'01'),LENTR1
         THEN      (DO,CBALR11)        CALL CBALR11;
         ST        R5,CBAR11           CBAR11,LBAR11=R5;           V1L5
         ST        R5,LBAR11                                       V1L5
         THEN      (OUTPUT,4,LBARND)   OUTPUT BRANCH AROUND
LENTR1   THEN      (DO,CNOP04)         CALL CNOP04;
         ST        R5,LENTRYP          LENTRYP=R5;                 V1L5
         SR        R0,R0
         L         R3,CDOBEG                                       V1L5
         LTR       R3,R3
         BZ        LENTR5
         IC        R0,ZR3+12
         LTR       R0,R0
         BZ        LENTR5
LERREY5  $ERROR    (BOOT,EY,5)                                     V1L5
LENTR5   IF        (SCODE,EQ,PHI),LENTR48
         IF        (SCODE,NOFF,MNAME),LENTR48
         IF        (CSRSWTCH,FUNC),LENTR50     ARE WE IN A FUNCTION
         IF        (CSRSWTCH,NON,MPRG),LENTR10             MAIN PROG
LERREY4  $ERROR    (BOOT,EY,4),LENTR36 YES,THERES NO WAY           V1L5
         EJECT
* ENTRY IN SUBROUTINES
         SPACE
LENTR10  LOOKUP    VARIABLE            LOOK UP ENTRY POINT NAME
         USING     RLIST,R15           POINTER TO SYMBOL TABLE
         LR        R4,R3               HOLD NAME FOR ARGUMENT LIST SCAN
         BOLD      LERREY0             BRANCH IF NAME ALREADY THERE
         THEN      (RB1,EQU,SUBR),(RB2,EQU,TYPE+USAGE+ENTRY)
         MVC       RADDR,LENTRYP       R.ADDR=LENTRYP;
         THEN      (DO,CNOP04)         CALL CNOP04;
         LA        R0,ZR5+8            CBAR11=R5+8;
         ST        R0,CBAR11                                       V1L5
         THEN      (OUTPUT,20,LCSUBR)  OUTPUT OBJECT CODE
         USING     ENTRSEQ,R3
         MVC       ENTRISN,XISN        ENTR.ISN=XISN;
         MVC       ENTRNAME,RNAME      ENTR.NAME=R.NAME;
         $FREE     R3                                              V1L5
LENTR30  AH        RS,SLINK          STEP STACK
         IF        (SOPTR,EQ,LBRK),THEN,(DO,LEARG),LENTR34
         IF        (SOPTR,NE,TERM),THEN,(DO,LERRSX1B)
LENTR34  THEN      (OUTPUT,4,LASTARG)  OUTPUT LAST ARGUMENT
LENTR36  IFANY     (CIFGOTSW,EQ,X'01'),(CMOSWTCH,ON),LENTR40
         L         R3,LBAR11           BRANCH INSTRUCTION ADDRESS  V1L5
         LR        R0,R5               ICI
         SR        R0,R3               LESS REGISTER 11
         O         R0,KP11             PLUS BASE REGISTER
         STH       R0,ZR3+2(RO)
         THEN      (DO,CBALR11)        CALL CBALR11;
         ST        R5,CBAR11           NEW REGISTER 11             V1L5
LENTR40  MVI       CIFGOTSW,X'00'      RESET UNCONDITIONAL TRANSFER SW
         B         CRET
LERREY0  $ERROR    (BOOT,EY,0,NAMR15),LENTR30                      V1L5
LENTR48  THEN      (DO,LERRSRA)
         GETSYM    4
         LR        R4,R6
         S         R4,CSYMBASE
         IF        (CSRSWTCH,RTN),LENTR55
         B         LENTR30
         SPACE
         $FREE     R15                                             V1L5
         EJECT
* ENTRY IN FUNCTIONS
         SPACE
LENTR50  LOOKUP    VARIABLE,,LENTR70   LOOKUP ENTRY POINT NAME
         LR        R4,R3
         STH       R3,LASTARG1+2       PUT INTO LAST ARG
         USING     VLIST,R15          THIS IS FUNCTION VARIABLE
         THEN      (VB2,EQU,USAGE)
LENTR54  GETSYM    16                  GET SOME SPACE
         L         R4,CFEND            R4=CFEND;                   V1L5
         USING     RLIST,R4
         LR        R0,R4               R.LINK=R4-R6;
         SR        R0,R6
         STH       R0,RLINK
         $FREE     R4                                              V1L5
         ST        R6,CFEND            CFEND=R6;                   V1L5
         USING     RLIST,R6
         THEN      (RB1,EQU,FUNC),(RB2,EQU,USAGE+ENTRY)
         MVC       RNAME,VNAME         R.NAME=V.NAME;
         LR        R0,R15              R.PTRF=R15-R6;
         SR        R0,R6
         STH       R0,RPTRF
         MVC       RADDR,LENTRYP       RADDR=LENTRYP;
         $FREE     R6                                              V1L5
         LA        R0,ZR5+8            CBAR11=R5+8;
         ST        R0,CBAR11                                       V1L5
         MVC       LENAME+4(6),VNAME
         LR        R8,RS               R8=RS;
         LA        RS,LENAME           RS->LENAME;
         CLINK1    TEQUIV1             CALL TEQUIV1;
         L         RS,LSAVER+ZSV8-ZSAVER                           V1L5
         L         R15,LSAVER+ZSV15-ZSAVER                         V1L5
         THEN      (DO,CNOP04)         CALL CNOP04;
         THEN      (OUTPUT,20,LCSUBR)  OUTPUT ENTRY CODE
         USING     ENTRSEQ,R3
         MVC       ENTRISN,XISN        ENTR.ISN=XISN;
         MVC       ENTRNAME,VNAME
         $FREE     R3                                              V1L5
LENTR55  AH        RS,SLINK          STEP STACK
         IF        (SOPTR,NE,LBRK),THEN,(DO,LERRSX0B),LENTR56
         CLINK1    LEARG               CALL LEARG;
LENTR56  THEN      (OUTPUT,4,LASTARG1),LENTR36
LENTR70  LR        R4,R3               SAVE FOR ARGUMENT PROCESSING
         STH       R3,LASTARG1+2       PUT INTO LAST ARGUMENT
         IFNOT     (VB1,SVAR),LENTR74
         IF        (VB2,NOFF,B'01111100'),LENTR74
         THEN      (VB2,OR,USAGE),LENTR54
LERREY1  $ERROR    (BOOT,EY,1,NAMR15),LENTR55                      V1L5
LENTR74  EQU       LERREY1             /*PATCH*/
         SPACE
         OFFSET    DROP,R6,R14
         $FREE     R15                                             V1L5
         EJECT
*******************************************************************
* THIS ROUTINE FORMS THE COMMON EXIT ROUTINE FOR THE FOLLOWING
* STATEMENT PROCESSORS
*******************************************************************
*        FUNCTION
*        COMPLEX FUNCTION
*        DOUBLE PRECISION FUNCTION
*        INTEGER FUNCTION
*        LOGICAL FUNCTION
*        REAL FUNCTION
*        SUBROUTINE
*        ENTRY
*******************************************************************
         SPACE
* ENTRY ON ILLEGAL SUBPROGRAMME NAME
         SPACE
LFCOM62  L         R4,CFBEG                                        V1L5
         USING     RLIST,R4
         THEN      (RB1,EQU,FUNC),(RB2,EQU,TYPE+USAGE+MENTRY)
         THEN      (RNAME,EQU,C' ')
         AH        RS,SLINK            NSU
         THEN      (DO,LERRSRA),LFCOM20
         SPACE
         $FREE     R4                                              V1L5
         SPACE
LERRSX4  $ERROR    (BOOT,SX,4,SYMR9,UNEX),LFCOMA                   V1L5
         SPACE
* ENTRY ON ILLEGAL LENGTH CODE
         SPACE
LFCOM72  $ERROR    (BOOT,FN,4,SYMR9,INVAL),LFCOMA                  V1L5
         EJECT
* ENTRY FROM COMPLEX, INTEGER, LOGICAL OR REAL FUNCTION STATEMENT
         SPACE
LFCOMD   ST        R5,LENTRYP          SAVE ENTRY POINT            V1L5
         IFANY     (SCODE,EQ,PHI),(SCODE,NOFF,MNAME),LFCOM62
         LR        R1,RS               MOVE OVER STACK POINTER TO R1
         $FREE     RS                  BUT ONLY TEMPORARILY        V1L5
         USING     STAK,R1
         AH        R1,SLINK            NSU
         IC        R2,ZR8+3            R2=DEFAULT LENGTH(BYTES)
* HERE WE CHECK TO SEE IF AN OPTIONAL LENGTH SPECIFICATION EXISTS
         IF        (SOPTR,NE,STAR),LFCOM
         SPACE
         IF        (SCODE,OFF,MCONS),LERRSX4
         IF        (SCODE,NE,CCONS+1),LFCOM72
         CLC       SOPND,ZR8           IF SAME AS DEFAULT LENGTH
         BE        LFCOMA              YEP
         CLC       SOPND,ZR8+4         IF SAME AS OPTIONAL LENGTH
         BNE       LFCOM72             NOPE, ERROR
         IC        R2,ZR8+7            R2=OPTIONAL LENGTH
         LA        R7,ZR7+1            BUMP R7 FOR OPTIONAL LENGTH
         SPACE
* ENTRY FROM DOUBLE PRECISION FUNCTION STATEMENT
LFCOMA   AH        R1,SLINK            NSU
LFCOM    EX        R7,LFCMVI3          MVI CSRSWTCH,FUNC+*-*
         L         R4,CFBEG                                        V1L5
         USING     RLIST,R4
         EX        R7,LFCMVI2          MVI RB1,FUNC+*-*
         THEN      (RB2,EQU,TYPE+USAGE+MENTRY)
         LOOKUP    VARIABLE            LOOKUP SUBPROG NAME
         USING     VLIST,R15
         LR        RS,R1               RESTORE STACK TO ITS RS
         SPACE
         USING     STAK,RS
         $FREE     R1                                              V1L5
         SPACE
         EX        R7,LFCMVI1          MVI VB1,SIMV+*-*
         THEN      (VB2,EQU,TYPE+USAGE)
         STC       R2,VLEN             V.LEN=R2;
         SPACE
* ENTRY FROM FUNCTION STATEMENT
         SPACE
LFCOMB   MVI       VB3,B'01000000'
         MVC       RNAME,VNAME         R.NAME=V.NAME;
         LR        R0,R15              R.PTRF=R15-R4;
         SR        R0,R4
         STH       R0,RPTRF
         MVC       RADDR,LENTRYP       R.ADDR=LENTRYP;
         STH       R3,LASTARG1+2       MOVE RETURN VALUE POINTER
         MVC       LFNAME+4(6),VNAME   MOVE E.P. NAME TO NEW STACK
         LR        R8,RS               R8=RS;
         LA        RS,LFNAME           RS->LFNAME;
         CLINK1    TEQUIV1             CALL TEQUIV1;
         L         RS,LSAVER+ZSV8-ZSAVER         RESTORE STACK PTR V1L5
         L         R15,LSAVER+ZSV15-ZSAVER       AND PTR TO VLIST  V1L5
         THEN      (DO,CNOP04)         CALL CNOP04;
         LA        R0,ZR5+8            CBAR11=R5+8;
         ST        R0,CBAR11                                       V1L5
         THEN      (OUTPUT,20,*)       OUTPUT ENTRY POINT CODE
         SPACE
LCSUBR   STM       R14,R11,12(R13)     SAVE OLD REGS
         DC        0H'0',X'A0',AL.4(RP),AL.4(0),S(XENT)
         DC        H'0'                ISN
         DC        CL6'*-*'            ENTRY POINT NAME
         DC        XL4'0'              SAVE AREA ADDRESS
         SPACE
         USING     ENTRSEQ,R3
         MVC       ENTRISN,XISN        ENTR.ISN=XISN;
         MVC       ENTRNAME,VNAME      ENTR.NAME=V.NAME;
         $FREE     R3                                              V1L5
         SPACE
* SINCE FUNCTION THEREFORE ARGUMENT LIST MUST FOLLOW
         SPACE
LFCOM20  THEN      (DO,CNOP04)         CALL CNOP04;
         IFNOT     (SOPTR,EQ,PHI),LFCOM22
LERRSX0A $ERROR    (ZERO,SX,0,DELRS,INVAL),LFCOM26                 V1L5
LFCOM22  IF        (SOPTR,NE,LBRK),THEN,(DO,LERRSX1B),LFCOM26
         CLINK1    LARGL               CALL LARGL;
LFCOM26  THEN      (OUTPUT,4,LASTARG1),CRET      OUTPUT LAST ARG
         SPACE
LFCMVI1  MVI       VB1,SIMV+*-*
LFCMVI2  MVI       RB1,FUNC+*-*
LFCMVI3  MVI       CSRSWTCH,FUNC+*-*
         SPACE
         $FREE     R4,R13,R15,RP                                   V1L5
         EJECT
*******************************************************************
**********              ASF ENTRY PROCESSOR              **********
*******************************************************************
LASFE    CENT      LSAVER1             ENTRY POINT
         SR        R7,R7               R7=0
         ST        R7,LABEG            INITIALOZE ASF ARGUMENT LISTV1L5
         MVC       LVBEG,CVBEG         SAVE TOP OF V LIST
         ST        R5,CBADDR           SAVE BRANCH LOCATION        V1L5
         THEN      (OUTPUT,4,LBARND)   OUTPUT BRANCH AROUND
         THEN      (DO,CNOP04)         ALLIGN
         MVC       LBAR11,CBAR11       SAVE REGISTER 11
         LA        R3,ZR5+8
         ST        R3,CBAR11           NEW REGISTER 11             V1L5
         MVN       LASTASF+1(1),SOPND      BYTE 1
         L         R4,SOPND          ASF POINTER                   V1L5
         STH       R4,LVRPTR
         N         R4,KM1631           ZAP OUT GARBAGE
         A         R4,CSYMBASE         FUNCTION NAME POINTER
         OFFSET    USING,RLIST,R4,R15
         ST        R5,RADDR            ENTRY POINT ADDRESS         V1L5
         THEN      (OUTPUT,20,*)                 OUTPUT ENTRY CODE
         SPACE
         STM       R14,R11,12(R13)     SAVE REGISTERS
*        BAL       RP,XENTASF
         DC        0H'0',X'A1',AL.4(RP),AL.4(0),S(XENTASF)
         DC        H'0'                ISN
         DC        CL6'*-*'            ASF ROUTINE NAME
         DC        H'0',Y(*-*)         SAVE AREA POINTER
         SPACE
         USING     ENTRSEQ,R3
         MVC       ENTRISN,XISN        ENTR.ISN=XISN;
         MVC       ENTRNAME,RNAME      ENTR.NAME=R.NAME;
         MVC       ENTRSAVE+2(2),SOPND+2
         OFFSET    DROP,R4,R15
         $FREE     R3                                              V1L5
         LH        R4,LVRPTR
         AH        R7,SLINK          FOR ARITH
         AH        RS,SLINK          NEXT STACK ENTRY
LASFE10  IF        (SCODE,EQ,PHI),THEN,(DO,LERRSX2B),LASFE22
         IF        (SCODE,OFF,MNAME),LASFE12
         $ERROR    (ZERO,FN,5,SYMR9,UNEX),LASFE17                  V1L5
LASFE12  LOOKUP    VARIABLE,,LASFE25   LOOKUP
         USING     VLIST,R15
         THEN      (VB2,EQU,TYPE)
         $FREE     R15                                             V1L5
         S         R6,KF20             CREATE ASF VARIABLE SPACE
         THEN      (DO,CGETSYM)
         USING     VLIST,R6            NON-OFFSET
         MVC      VB1(10),VB1-VLIST+ZR15 * MOVE CB AND NAME
LASFE14  THEN      (VB2,EQU,TYPE+USAGE)
         STH       R4,VRPTR            SAVE FUNCTION NAME POINTER
         SPACE
         THEN      (DO,CHASHVAL)       CALCULATE HASH VALUE
         STC       R2,VHVAL            STORE IN VLIST ENTRY
         LH        R0,CHASHCEL(R2)     LOAD HASH TABLE POINTER
         STH       R0,VHPTR            SAVE FOR LATER RESTORE
         LR        R0,R6               CALCULATE POINTER TO ASF VAR
         S         R0,CSYMBASE         AS POINTER TO SYMTAB
         STH       R0,CHASHCEL(R2)     PUT INTO HASH TABLE
         SPACE
         L         R3,LABEG            ADD ASF ARG TO LISTS        V1L5
         LTR       R3,R3               ASF ARG LIST EMPTY
         BNZ       LASFE16
         ST        R6,LAEND            YES INITIALIZE END          V1L5
LASFE16  ST        R6,LABEG            INITIALIZE BEGINNING        V1L5
         LR        R0,R6               CALCULATE LINK
         S         R0,CVBEG
         STH       R0,VLINK           STORE AWAY
         ST        R6,CVBEG            BACKUP V LIST               V1L5
         LR        R0,R6
         S         R0,CSYMBASE
         STH       R0,LRVARS+2         STORE IN OBJECT CODE
         THEN      (OUTPUT,4,LRVARS)             OUTPUT CODE
LASFE17  AH        R7,SLINK          FOR ARITH
         AH        RS,SLINK          BUMP STACK
         IF        (SOPTR,EQ,COMMA),LASFE10   IF COMMA
         IF        (SOPTR,NE,RBRK),LASFE20  IF RIGHT BRACKET
LASFE18  IF        (SCODE,NE,PHI),THEN,(DO,LERRSX1B)
         AH        R7,SLINK          FOR ARITH
         AH        RS,SLINK          BUMP STACK
         IF        (SOPTR,EQ,EQUAL),LASFE19
         $ERROR    (ZERO,SX,0,DELRS,INVAL)                         V1L5
LASFE185 AH        R7,SLINK
         AH        RS,SLINK
         IF        (SOPTR,NE,EQUAL),LASFE185
LASFE19  THEN      (OUTPUT,4,LASTASF)  OUTPUT LAST ARGUMENT
         LR        R0,R7               ARITH WANTS LINK IN R0
         B         CRET                BACK TO CALLER
         EJECT
LASFE20  THEN      (DO,LERRSXB)        INV CHAR (NOT ) OR ,) FOUND V1L5
LASFE22  AH        R7,SLINK          FOR ARITH
         AH        RS,SLINK          BUMP STACK
         IF        (SOPTR,EQ,COMMA),LASFE10 * IF COMMA
         IF        (SOPTR,EQ,RBRK),LASFE18  IF RIGHT BRACKET
         B         LASFE22             KEEP LOOKING
         SPACE
         $FREE     R6                  NON-OFFSET                  V1L5
         SPACE
         USING     VLIST,R15
LASFE25  TM        VB1,B'01000000'
         BZ        LASFE30
         CLC       LVRPTR,VRPTR
         BNE       LASFE30
         THEN      (DO,LERRFN3),LASFE22
LASFE30  IF        (VB1,VAR),LASFE35
         IFNOT     (VB1,FUNC),THEN,(DO,LERRVA0),LASFE17
LASFE35  THEN      (VB2,OR,TYPE)       TURN ON TYPE ESTABLISHED
         $FREE     R15                                             V1L5
         S         R6,KF20             GET SPACE FOR ASF VARIABLE
         THEN      (DO,CGETSYM)        CALL CGETSYM;
         USING     VLIST,R6            NON-OFFSET
         MVC       VB1(10),VB1-VLIST+ZR15   MOVE CB AND NAME AND VLEN
         IFNOT     (VB1,FUNC),LASFE36
         MVI       VLEN,4              IF A FUNCTION, SET VLEN TO 4
LASFE36  MVZ       VB1,=AL1(SIMV)
         B         LASFE14
         SPACE
         $FREE     R6                  NON-OFFSET                  V1L5
         $FREE     R15,RP                                          V1L5
         EJECT
* THE FOLLOWING CODE CAN BE MOVED TO COMMR AT A CONVENIENT TIME
         USING     VLIST,R6
CHASHVAL L         R3,VNAME                                        V1L5
         M         R2,CHASHWTS
         SLDL      R2,8
         N         R2,CHASHMSK
         BR        RDONE               RETURN;
         $FREE     R6                                              V1L5
         EJECT
*******************************************************************
**********              ASF RETURN PROCESSOR             **********
*******************************************************************
LASFR    CENT      LSAVER1
         THEN      (OUTPUT,4,*)        OUTPUT RETURN
         SPACE
         B         XRETASF             RETURN INSTRUCTION
         SPACE
         L         R3,LABEG            ASF VARIABLE LIST POINTER   V1L5
         LTR       R3,R3               SEE IF ITS EMPTY
         BZ        LASFR10             YEP
         SPACE
         USING     VLIST,R3
         SR        R2,R2
         BAL       R15,LASFR5
         SH        R3,VLINK
LASFR5   IC        R2,VHVAL
         LH        R0,VHPTR
         STH       R0,CHASHCEL(R2)
         C         R3,LAEND
         BNER      R15
         $FREE     R3                                              V1L5
         SPACE
         USING     VLIST,R4            .
         L         R4,LVBEG            .                           V1L5
         BALR      R15,0               FIND THE LAST NAME IN THE VLIST
         LR        R3,R4               .
         SH        R4,VLINK            .
         C         R4,CVEND            .
         BNER      R15                 .
*        NOW R3 -> LAST NAME IN THE VLIST
*        AND R4 -> DUMMY ENTRY AT END OF VLIST
         $FREE     R4                                              V1L5
         USING     VLIST,R3
         LR        R0,R3               LINK THE LAST NAME
         S         R0,LABEG            IN THE VLIST TO THE
         STH       R0,VLINK            FIRST ASF ARGUMENT
*
         L         R3,LAEND            LINK THE LAST ASF ARGUMENT  V1L5
         SR        R4,R3               TO THE DUMMY ENTRY
         LCR       R4,R4
         STH       R4,VLINK            AT THE END OF THE VLIST
         $FREE     R3                                              V1L5
         MVC       CVBEG,LVBEG         CVBEG=LVBEG;
LASFR10  IF        (CMOSWTCH,ON),LASFR20 * IF MO DONT PATCH
         L         R3,CBADDR           ADDRESS OF BRANCH AROUND    V1L5
         LR        R4,R5               BRANCH TO HERE
         S         R4,LBAR11           LESS REGISTER 11
         O         R4,KP11             OR IN BASE REGISTER
         STH       R4,ZR3+2(RO)        INTO BRANCH INSTRUCTION
         THEN      (OUTPUT,2,*)        OUTPUT
         SPACE
         DC        0H'0',X'B6',AL.4(RP),AL.4(0)
         SPACE
LASFR20  ST        R5,CBAR11           THAT WAS A BALR ALSO        V1L5
         B         CRET                RETURN TO CALLER
         SPACE
         $FREE     RP,R13                                          V1L5
         EJECT
*******************************************************************
**********                   BLOCK DATA                  **********
*******************************************************************
LBLOC    CENT      LSAVER              BLOCK DATA STATEMENT PROCESSOR
         THEN      (DO,LENDTEST)
         AH        RS,SLINK            STEP STACK
         IF        (SOPTR,EQ,TERM),LBLOC15 * IF END OF STATEMENT
LERRBD1  $ERROR    (NOAC,BD,1,DELR9,UNEX) * NOPE, COMPLAIN         V1L5
LBLOC15  LOOKUP    SPCLNAME,NAME=BLANKNAM  CREATE DUMMY ENTRY
         USING     RLIST,R15           R LIST POINTER
         THEN      (RB1,EQU,BDAT),(RB2,EQU,TYPE+USAGE+MENTRY)
         THEN      (CSRSWTCH,EQU,BDAT),CRET
         SPACE
         $FREE     R13,R15,RP                                      V1L5
         EJECT
*******************************************************************
**********                   END                         **********
*******************************************************************
LEND     CENT      LSAVER1             NORMAL END STATEMENT ENTRY
         AH        RS,SLINK          STEP STACK
         IF        (SOPTR,EQ,TERM),LEND5
LERREN2  $ERROR    (BOOT,SX,A,DELR9,UNEX)                          V1L5
LEND5    MVC       XCARD1(1),CPAGSKIP
         IF        (CSRSWTCH,EQ,BDAT),LEND12                       V1L2
LEND10   IF        (CIFGOTSW,EQ,X'00'),LEND15
LEND12   THEN      (OUTPUT,2,*),LEND30  OUTPUT END OF S/P          V1L2
         SPACE
         DC        0H'0',X'AA',X'0'
         SPACE
LEND15   $ERROR    (WARN,EN,3)         WARN THE BLOKE              V1L5
         THEN      (DO,CISN),(OUTPUT,6,*)  OUTPUT BRANCH,ETC       V1L2
         SPACE
         B         XEND                BRANCH TO XEND
         DC        0H'0',X'AA',X'0'    END OF PROGRAM INDICATOR
         SPACE
LEND30   DC        0H'0'
         SPACE
         AIF       ('&SNAPS'EQ'OMIT').LDV1
***********************************************************************
*
* DEBUG VERSION ONLY - DUMPS PROGRAM AND SYMBOL TABLE
*
         IF        (CMOSWTCH,ON),LEND35
         OFFSET    LRAL,R1,CPRG
         LR        R2,R5
         S         R2,CPRG
         BNP       LEND35
         BCTR      R2,0
         CSNAP     PROGRAM
LEND35   L         R2,CSYMBASE                                     V1L5
         A         R2,KP11
         SR        R2,R6
         BNP       LEND40
         BCTR      R2,0
         OFFSET    LR,R1,R6
         CSNAP     SYMBOL
LEND40   DC        0H'0'
*******************************************************************
.LDV1    ANOP
         SPACE
         AIF       ('&STR' NE 'USE').RSTR1                         ST1
         L         R15,=V(STENDSEG)                                ST1
         BALR      RDONE,R15                                       ST1
         SPACE     1                                               ST1
.RSTR1   ANOP                                                      ST1
         CLINK1    RPH12               CALL RELOCATOR
         CLINK1    LENDPROG,CRET       CALL END PROGRAM INITIALIZATION
         SPACE
LENDS    CMENT     LSAVER1,LEND        ENTRY FOR MISSING END STATEMENT
LERREN0  $ERROR    (WARN,EN,0),LEND10  COMPLAIN (MILDLY)           V1L5
         SPACE
         $FREE     R13,RP                                          V1L5
         EJECT
* ENTRY STATEMENT ARGUMENT LIST CREATER
         SPACE
LEARG    CENT      LSAVER1
         STH       R4,LVRPTR
         THEN      (DO,CNOP04)         ALLIGN
LEARG8   IF        (SCODE,EQ,PHI),LEARG70
         IF        (SCODE,OFF,MNAME),LEARG14 IF NON NAME
LEARG9   DC        0H'0'
LERRSX2A $ERROR    (BOOT,SX,2,SYMRS,INVAL),LEARG34                 V1L5
LEARG14  LOOKUP    VARIABLE,,LEARG40   LOOKUP NAME
         USING     VLIST,R15          THIS POINTS TO IT TOO
         THEN      (VB2,EQU,PARM)
LEARG15  STH       R4,VRPTR
         STH       R3,LRVARS+2         STORE POINTER IN CODE
         THEN      (OUTPUT,4,LRVARS)   OUTPUT ARGUMENT CODE
LEARG16  AH        RS,SLINK          STEP STACK
         IF        (SOPTR,EQ,COMMA),LEARG8     IF COMMA
         IF        (SOPTR,NE,RBRK),LEARG30     IF NOT RIGHT BRACKET
LEARG18  IF        (SCODE,NE,PHI),THEN,(DO,LERRSXAB),CRET
         AH        RS,SLINK          STEP STACK
         IF        (SOPTR,NE,TERM),THEN,(DO,LERRSXAA)
         B         CRET                RETURN TO CALLER
         SPACE
LEARG30  THEN      (DO,LERRSX1B)
LEARG32  IF        (SOPTR,EQ,TERM),CRET
LEARG34  AH        RS,SLINK            NSU
         IF        (SOPTR,EQ,COMMA),LEARG8     CHECK FOR COMMA
         IF        (SOPTR,EQ,RBRK),LEARG18   OR RIGHT BRACKET
         B         LEARG32             KEEP LOOKING
LEARG40  CLC       LVRPTR,VRPTR        IF REPEATED ARGUMENT NAME
         BE        LEARG60             YEP
         IF        (VB2,OFF,PARM),LEARG48
         IF        (VB2,NON,PARMNAME),LEARG15
LEARG47  THEN      (DO,LERREY2),LEARG16
LEARG48  IF        (VB2,OFF,TYPE),LEARG50
         IF        (VB2,NOFF,B'00011111'),LEARG47
LEARG49  THEN      (VB2,OR,PARM),(DO,LERREY3),LEARG15
*EARG50  IFNOT     (VB1,PROG),LEARG47
LEARG50  TM        VB1,B'10000000'
         BO        LEARG47
         TM        VB1,B'01000000'
         BZ        LEARG47
         IF        (VB2,OFF,B'00000011'),LEARG49
         B         LEARG47
LEARG60  THEN      (DO,LERRFN3),LEARG16
LEARG70  AH        RS,SLINK          STEP STACK
         IF        (SOPTR,NE,SLASH),LEARG90  IF NOT SLASH
         IF        (SCODE,NOFF,MNAME),LEARG9 MUST HAVE NAME HERE
         LOOKUP    VARIABLE,,LEARG80   LOOKUP VARIABLE NAME
         USING     VLIST,R15          POINTS TO SYMBOL TABLE
         THEN      (VB2,EQU,PARMNAME)
LEARG78  STH       R4,VRPTR            STORE FUNCTION POINTER
         STH       R3,LRVARS1+2        STORE POINTER INTO OBJECT CODE
         THEN      (OUTPUT,4,LRVARS1)  OUTPUT OBJECT CODE
LEARG79  AH        RS,SLINK          STEP STACK
         IF        (SOPTR,EQ,SLASH),LEARG16   IF SLASH FOLLOWS
         B         LEARG30             NO,ERROR
LEARG80  CLC       LVRPTR,VRPTR        F REPEATED ARGUMENT NAME
         BE        LEARG96             YES, ERROR
         IF        (VB2,ON,PARMNAME),LEARG78
         IF        (VB2,ON,PARM),THEN,(DO,LERREY2),LEARG79
         IF        (VB2,OFF,USAGE),LEARG87
         IFNOT     (VB1,DVAR),LEARG88
LEARG87  IF        (VB2,NOFF,B'00111111'),LEARG88
         THEN      (VB2,OR,PARMNAME),(DO,LERREY3),LEARG78
LEARG88  THEN      (DO,LERRVA0),LEARG79
LEARG90  IF        (SOPTR,NE,STAR),LEARG9
         IF        (CSRSWTCH,FUNC),THEN,(DO,LERRFN5)
         THEN      (OUTPUT,4,LRSTNS)   OUTPUT STATEMENT NUMBER ARGUMENT
         IF        (SCODE,EQ,PHI),LEARG16    PHI OPERAND
         THEN      (DO,LERRSX0B),LEARG32
LEARG96  THEN      (DO,LERRFN3),LEARG79
         SPACE
LERREY2  $ERROR    (ZERO,EY,2,SYMR9),DONE                          V1L5
LERREY3  $ERROR    (ZERO,EY,3,SYMR9),DONE                          V1L5
         SPACE
         $FREE     R13,R15,RP                                      V1L5
         EJECT
*******************************************************************
* THIS ROUTINE SIMULATES THE PROCESSING DONE BY THE SUBROUTINE
* STATEMENT PROCESSOR WHEN THE SUBPROGRAMME IS A MAIN PROGRAMME.
* IT IS CALLED BY SCAN
*******************************************************************
LMAIN    CENT      LSAVER              SIMULATE A SUBROUTINE FOR
         THEN      (CSRSWTCH,EQU,MPRG)
         LOOKUP    SPCLNAME,NAME=XMNAM  LOOKUP MAIN PROGRAMME NAME
         IF        (CMNPRGSW,ON),LMAIN1     HAVE WE HAD A MAIN PROG?
         THEN      (CMNPRGSW,ON)       NO,SET THE SWITCH
         ST        R5,XENTRYP          STASH MAIN ENTRY POINT      V1L5
         USING     RLIST,R15
LMAIN1   THEN      (RB1,EQU,MPRG),(RB2,EQU,TYPE+USAGE+MENTRY)
         ST        R5,RADDR            ENTRY POINT ADDRESS         V1L5
         THEN      (DO,CNOP04)         ALLIGN
         LA        R0,ZR5+8            R11 AT EXEC TIME
         ST        R0,CBAR11                                       V1L5
         THEN      (OUTPUT,24,*)       OUTPUT ENTRY POINT CODE
         SPACE
         STM       R14,R11,12(R13)
*        BAL       R11,XENT            GO TO ENTRY ROUTINE
         DC        0H'0',X'A0',AL.4(RP),AL.4(0),S(XENT)
         DC        H'0'                ISN
         DC        CL6'&MPROGN'        PROGRAM NAME
         DC        XL4'0'              PTR TO MAIN SAVE AREA
         DC        0H'0',X'AB',B'00010001',H'0'
         SPACE
         USING     ENTRSEQ,R3
         MVC       ENTRISN,XISN        ENTR.ISN=XISN;
         $FREE     R3                                              V1L5
         B         CRET
         SPACE
         $FREE     R13,R15,RP                                      V1L5
         EJECT
*******************************************************************
**********                   RETURN                      **********
*******************************************************************
LRETU    CENT      LSAVER              ENTRY FOR RETURN STAT
         OI        CDOEND,X'01'
         IF        (SCODE,NE,PHI),LRETU30        IF MULT RETURN
         AH        RS,SLINK
         IF        (SOPTR,EQ,TERM),LRETU10
         $ERROR    (BOOT,SX,5,DELR9,UNEX),LRETU999                 V1L5
LRETU10  THEN      (OUTPUT,4,*)        OUTPUT SIMPLE RETURN CODE
         SPACE
         B         XRET                RETURN CODE
         SPACE
LRETU999 THEN      (CIFGOTSW,EQU,X'01'),CRET
         EJECT
* MULTIPLE RETURN STATEMENT(SIMPLE VARIABLE RETURN)
         SPACE
LRETU30  IFNOT     (CSRSWTCH,FUNC),LRETU31
LERRRE2  $ERROR    (BOOT,RE,2),LRETU99    NO MULTRETS IN FUN S/P'S V1L5
LRETU31  IF        (CSRSWTCH,NE,MPRG),LRETU32
LERRRE4  $ERROR    (BOOT,RE,4),LRETU99 OR IN MAIN PROGRAM          V1L5
LRETU32  IF        (SCODE,ON,CCONS),LRETU60
         LOOKUP    VARIABLE            LOOKUP NAME
         USING     VLIST,R15
         IF        (VB1,SVAR,INT4),LRETU40
         IF        (VB1,SVAR,INT2),LRETU37
LERRRE3  $ERROR    (BOOT,RE,3,NAMR15),LRETU99                      V1L5
LRETU37  THEN      (VB2,OR,TYPE+USAGE)
         IF        (VB2,NOFF,B'00000011'),LRETU38
         BAL       R1,LRETU68
         SPACE
         LH        R3,*-*
         B         XRETI
         SPACE
LRETU38  BAL       R1,LRETU68
         SPACE
         L         R3,*-*
         B         XRETIH
         SPACE
LRETU40  THEN      (VB2,OR,TYPE+USAGE)
         IF        (VB2,NOFF,B'00000011'),LRETU42
         BAL       R1,LRETU68
         SPACE
         L         R3,*-*
         B         XRETI
         SPACE
LRETU42  BAL       R1,LRETU68
         SPACE
         L         R3,*-*
         B         XRETIF
         EJECT
* INTEGER RETURN
         SPACE
LRETU60  CLC       SOPND,LRETUK1
         BE        LERRRE1             RETURN 0 = ERROR
         CLC       SOPND,LRETUK2
         BH        LERRRE1
         LH        R0,SOPND+2
         BAL       R1,LRETU69
         SPACE
         LA        R3,*-*
         B         XRETI
         SPACE
LRETU68  LR        R0,R3
LRETU69  THEN      (OUTPUT,8)
         STH       R0,ZR3+2
LRETU99  AH        RS,SLINK
         IF        (SOPTR,EQ,TERM),LRETU999
LERRSXAC $ERROR    (BOOT,SX,A,DELR9,UNEX),LRETU999                 V1L5
LERRRE1  $ERROR    (BOOT,RE,1,SYMR9,INVAL),LRETU99                 V1L5
         SPACE
         $FREE     R13,R15,RP                                      V1L5
         SPACE
LRETUK1  DC        0FL4'0',FL.5'1',FL.27'0'
LRETUK2  DC        0FL4'0',FL.5'3',FL.27'999'
         EJECT
* THIS ROUTINE CREATES THE OBJECT CODE FOR THE ARGUMENT LISTS IN THE
* FOLLOWING STATEMENTS
*******************************************************************
*        COMPLEX FUNCTION
*        DOUBLE PRECISION FUNCTION
*        INTEGER FUNCTION
*        LOGICAL FUNCTION
*        REAL FUNCTION
*        FUNCTION
*        SUBROUTINE
*******************************************************************
LARGL    CENT      LSAVER1             ARG LIST PROCESSOR
         THEN      (DO,CNOP04)         ALLIGN
LARGL2   IF        (SCODE,EQ,PHI),LARGL20   IF PHI
         IF        (SCODE,NOFF,MNAME),THEN,(DO,LERRSX2B),LARGL4
         LOOKUP    VARIABLE,,LARGL14   LOOKUP NAME
         USING     VLIST,R15
         THEN      (VB2,EQU,PARM)
         STH       R3,LRVARS+2         PREPARE FOR OUTPUT
         THEN      (OUTPUT,4,LRVARS)   WHAT ELSE
LARGL4   AH        RS,SLINK          STEP STACK
         IF        (SOPTR,EQ,COMMA),LARGL2   IF MORE ARGS
         IF        (SOPTR,NE,RBRK),LARGL10  OR END OF LIST
LARGL6   IF        (SCODE,NE,PHI),THEN,(DO,LERRSXAB)
         AH        RS,SLINK          STEP STACK
         IF        (SOPTR,EQ,TERM),CRET
         THEN      (DO,LERRSXAA),CRET
         EJECT
LARGL10  THEN      (DO,LERRSX1B)       COMPLAIN
LARGL12  IF        (SOPTR,EQ,TERM),CRET     SEE IF END OF STATEMENT
LARGL125 AH        RS,SLINK          STEP STACK
LARGL13  IF        (SOPTR,EQ,COMMA),LARGL2   SEE IF COMMA
         IF        (SOPTR,EQ,RBRK),LARGL6   OR RIGHT BRACKET
         THEN      LARGL12             KEEP LOOKING
LARGL14  IFNOT     (VB1,VAR),THEN,(DO,LERRFN8),LARGL4
         THEN      (DO,LERRFN3),LARGL4
LARGL20  AH        RS,SLINK          STEP STACK
         IF        (SOPTR,NE,SLASH),LARGL30
         IFANY     (SCODE,EQ,PHI),(SCODE,NOFF,MNAME),                  X
               THEN,(DO,LERRSX2B),LARGL21
         LOOKUP    VARIABLE,,LARGL24   LOOKUP NAME
         USING     VLIST,R15
         THEN      (VB2,EQU,PARMNAME)
         STH       R3,LRVARS1+2        PRIOR TO OUTPUT
         THEN      (OUTPUT,4,LRVARS1)
LARGL21  AH        RS,SLINK          STEP STACK
         IF        (SOPTR,NE,SLASH),THEN,(DO,LERRSX1B),LARGL13
         IF        (SCODE,EQ,PHI),LARGL4
         THEN      (DO,LERRSX0B),LARGL12
LARGL24  IF        (VB1,PROG),THEN,(DO,LERRFN8),LARGL21
         THEN      (DO,LERRFN3),LARGL21
LARGL30  IF        (SOPTR,EQ,STAR),LARGL32  IF MULT RETURN
         THEN      (DO,LERRSX1B),LARGL13
LARGL32  IF        (CSRSWTCH,FUNC),THEN,(DO,LERRFN5),LARGL4
         THEN      (OUTPUT,4,LRSTNS)   OUTPUT MULT RETURN ARG
         IF        (SCODE,EQ,PHI),LARGL4    SHOULD BE PHI
         THEN      (DO,LERRSX0B),LARGL125
         SPACE
LERRFN8  $ERROR    (ZERO,FN,6,NAMR15),DONE                         V1L5
         SPACE
         $FREE     R13,R15,RP                                      V1L5
         EJECT
*******************************************************************
* THIS ROUTINE INITIALIZES POINTERS, TABLES, AND CONSTANTS BEFORE A
* SUBPROGRAMME IS COMPILED. IT IS CALLED BY MAIN BEFORE COMPILATION
* BEGINS AND BY THE END STATEMENT PROCESSOR AFTER IT HAS CALLED THE
* RELOCATOR TO RELOCATE A SUBPROGRAM
*******************************************************************
         SPACE
LENDPROG CENT      LSAVER2             END OF SUBPROGRAMME PROCESSOR
         SR        R3,R3               R3=0
         ST        R3,CKBEG                                        V1L5
         STH       R3,CHECKINT
         ST        R3,CDOBEG           BEGGINNING OF DO LIST       V1L5
         STH       R3,CDONO
         XC        CHASHCEL(96*2),CHASHCEL       ZAP OUT HASH TABLES
         MVC       CTLNG,LTLNG         TEMPORARY LENGTH
         MVC       CANXTMP,LANXTMP
         THEN      (CIFGOTSW,EQ,X'00')
         THEN      (CSRSWTCH,EQU,NORTN)
         THEN      (CIMPLIT,EQU,X'00') NO IMPLICIT STATS YET
         THEN      (CSPEX,EQU,X'00')
         MVC       CONB,CONB1          CONSTANT LOOKUP
         MVC       CIMPL1(84),LIMPL1
         MVI       CASF1,OFF
         MVI       CASF2,OFF
         THEN      (DO,CDS0F)          REALLIGN TO FULLWORD
         ST        R5,CPRG             BEGINNING OF PROGRAMME      V1L5
         ST        R5,CBAR11                                       V1L5
         LR        R3,R6
         S         R3,KP11             BOTTOM OF SYMBOL TABLE
         ST        R3,CSYMBASE                                     V1L5
         ST        R6,ROLDMAX          INITIALLIZE FOR CLEANUP     V1L5
*        IF AN  OBJECT DECK IS LOADED, WATLOAD RELEASES THE SPACE
*        OBTAINED FROM THE SYMBOL TABLE BY THE FOLLOWING GETSYMS
*        I.E. 52 BYTES.
         GETSYM    16,NOCHECK
         ST        R6,CFBEG                                        V1L5
         ST        R6,CFEND                                        V1L5
         GETSYM    16,NOCHECK
         ST        R6,CVBEG                                        V1L5
         ST        R6,CVEND                                        V1L5
         GETSYM    8,NOCHECK
         ST        R6,CHBEG                                        V1L5
         ST        R6,CHEND                                        V1L5
         GETSYM    12
         ST        R6,CSBEG                                        V1L5
         ST        R6,CSEND                                        V1L5
         B         CRET                RETURN TO CALLER
         SPACE
         $FREE     R13,RP                                          V1L5
         SPACE
LANXTMP  DC        A(13*PAGE+100,14*PAGE)
CONB1    B         C1STLOOK
LTLNG    DC        S(100(R13))
LIMPL1   DC        8AL1(REAL4),AL1(INT4),6AL1(0)
         DC        AL1(0),5AL1(INT4),4AL1(REAL4),6AL1(0)
         DC        2AL1(0),8AL1(REAL4),AL1(REAL4)
LIMPL2   DC        8AL1(4),AL1(4),6AL1(0)
         DC        AL1(0),5AL1(4),4AL1(4),6AL1(0)
         DC        2AL1(0),8AL1(4),AL1(4)
         TITLE     'LANDR     RELOCATOR PHASE-ONE'
*******************************************************************
**********              RELOCATOR PHASE ONE              **********
*******************************************************************
* GENERATE DATA AREA
*******************************************************************
* ROUTINES CALLED
*******************************************************************
*                  CDS0D
*                  CDS0F
*                  CDS0H
*                  CENT
*                  COUT
*                  ERCP0
*                  ERMO0
*                  RPADR
*                  RSADRD
*                  RSADRS
*******************************************************************
* REGISTER USAGE
*******************************************************************
*                  R0                  WORK REGISTER
*                  R1                  WORK REGISTER (ADDRESSES)
*                  R2                  WORK REGISTER
*                  R3                  WORK REGISTER
*                  R4                  WORK REGISTER
*                  R8
*                  R9                  CANNOT BE USED
*                  R11                 PROGRAM BAR
*                  R14                 LINK ADDRESSES
*******************************************************************
         ENTRY     RPH12
RPH12    CENT      RSAVER
         EJECT
* CREATE SAVE AREA
         SPACE
         THEN      (DO,CDS0D)          ALIGN ON DOUBLEWORD
         ST        R5,RCURSAVE         THIS IS SAVE AREA ADDRESS   V1L5
         ST        R5,RENTSAVE                                     V1L5
         LR        R3,R5               PUT INTO WORK REGISTER
         L         R4,CANXTMP          FIXED POINT TEMPORARIES     V1L5
         LA        R4,ZR4+7            FILL OUT TO DOUBLEWORD ALSE
         N         R4,KM0028
         S         R4,KP13
         AR        R3,R4               INCRIMENT WORK REGISTER
         S         R4,KP1
         STH       R4,RTMPO            CORRECTION TO FLOAT TEMPORARIES
         STH       R4,RTMPOM           OF MAIN PROCRAMME
         A         R3,CANXTMP+4        OF CURRENT PROGRAMME
         S         R3,KP14             LESS 14 OAGES
         ST        R3,RDATADDR                                     V1L5
         LR        R4,R3
         S         R4,KP5
         ST        R4,RDATBASE         BASE OF DATA                V1L5
         IF        (CMOSWTCH,ON),RSVGEN10
         ST        R3,RSAVEA+76        FOR R5                      V1L5
         L         R0,KP1              R0=4096                     V1L5
         AR        R3,R0               ADD 4096
         ST        R3,RSAVEA+80        FOR R6                      V1L5
         AR        R3,R0
         ST        R3,RSAVEA+84        FOR R7                      V1L5
         AR        R3,R0
         ST        R3,RSAVEA+88        FOR R8                      V1L5
         AR        R3,R0
         ST        R3,RSAVEA+92        FOR R9                      V1L5
         AR        R3,R0
         ST        R3,RSAVEA+96        FOR R10                     V1L5
         THEN      (OUTPUT,100,RSAVEA)           OUTPUT SAVE AREA
         L         R5,RDATADDR         WE ARE HERE NOW IN OBJECT CODE
RSVGEN10 DC        0H'0'
         EJECT
* FIXUP FUNCTION NAMES
         SPACE
         IFNOT     (CSRSWTCH,FUNC),RFFIX99
         L         R3,CFEND            R4=CFEND;                   V1L5
         USING     RLIST,R3
         LR        R0,R3               R.LINK=CFEND-CVBEG;
         S         R0,CVBEG
         STH       R0,RLINK
         $FREE     R3                                              V1L5
         MVC       CVBEG,CFBEG         CVBEG=CFBEG;
RFFIX99  DC        0H'0'
         EJECT
*   INITIALLIZE FOR SYMBOL TABLE CLEANUP
         ST        R6,ROLDR6                                       V1L5
         MVC       ROLDLEND(4),CLEND
         MVC       ROLDGEND(4),CGVEND
         SR        R2,R2
         ST        R2,RNGVLIST                                     V1L5
         EJECT
*        INITIALLIZE VARIABLE DIMENSION LIST
         ST        R2,CVDIMEND                                     V1L5
         ST        R2,CVDIMBEG                                     V1L5
         SPACE
*****************
* VARIABLE LIST *
*****************
         SPACE
R110     OFFSET    EQU,R8,R4
         SPACE
         L         R110,CVBEG                                      V1L5
         OFFSET    USING,VLIST,R110,R8
         AIF       ('&VM' NE 'USE').LVM30                          VM1
         IF        (XEXEC1SW,OFF,XVMASK),RVM1   XDEBUG MODE?       VM1
         ST        R5,VMSAVE55         PTR FOR STMT # LIST         VM1
         OUTPUT    4,KF0                                           VM1
         ST        R5,VMSAVE5          SAVE FOR LATER              VM1
RVM1     DS        0H                                              VM1
.LVM30   ANOP                                                      VM1
         BAL       RLOOP,RVGEN1        SET UP LOOP RETURN
         USING     *,RLOOP
         CSNAP     *,VLIST,16         SNAP OUT LIST
*        SH        R110,VLINK          /*OFFSET*/
         SH        R8,VLINK
RVGEN1   C         R110,CVEND
         AIF       ('&VM' NE 'USE').LVM31                          VM1
         BNE       VMAR1               NOT FINISHED                VM1
         B         RVGEN99             END OF VLIST                VM1
VMSAVE   EQU       *                   ROUT TO SAVE PTR            VM1
         L         R2,VMSAVE5          ADDR OF LAST ENTRY          VM1
         LR        R1,R5               CURRENT OBJ CODE PTR        VM1
         SR        R1,R2               LENGTH OF LAST ITEM         VM1
         SRL       R1,2                LENGTH IN FULLWORDS         VM1
         SR        R3,R3                                           VM1
         IC        R3,1(,R2)           VB2                         VM1
         SLL       R3,6                                            VM1
         AR        R1,R3                                           VM1
         STC       R1,1(,R2)           SAVE IN DATA AREA           VM1
         ST        R5,VMSAVE5          SAVE FOR NEXT ITEM          VM1
         BR        R14                 RETURN                      VM1
VMSAVE5  DC        A(*-*)              SPACE FOR R5                VM1
VMAR1    EQU       *                                               VM1
         AGO       .LVM32                                          VM1
.LVM31   ANOP                                                      VM1
         BE        RVGEN99             FINISHED                    VM1
.LVM32   ANOP                                                      VM1
         CSNAP     VLIST,VLIST,16    SNAP OUT SYMBOL
         EJECT
         IFNOT     (VB1,VAR),RVGEN5
         IFNOT     (VB1,DIM),RVGEN3
         IF        (VB2,ON,PARM),RVGEN2
         SPACE
* DIMENSIONED VARIABLE
         SPACE
RVGARR   EQU       *                                               VM1
         AIF       ('&VM' NE 'USE').LVM33                          VM1
         THEN      (DO,CDS0F)          ALIGN ON A FULL WORD        VM1
         IF        (XEXEC1SW,OFF,XVMASK),RVM2   XDEBUG MODE?       VM1
         THEN      (DO,VMSAVE)         SET UP PTR                  VM1
RVM2     DS        0H                                              VM1
         OUTPUT    8,VB1               OUTPUT VB1,VB2,VNAME        VM1
         AGO       .LVM34                                          VM1
.LVM33   ANOP                                                      VM1
         THEN      (DO,CNOP24),(OUTPUT,6,VNAME)                    VM1
.LVM34   ANOP                                                      VM1
RVGARR11 THEN      (DO,RPADR)          GET P(DOT ROUTINE)
         STH       R3,RVPADD           SAVE FOR LATER SO NAME STILL OK
         IC        R7,VB1
         N         R7,KM2527
         SRL       R7,2                 4*N
         IF        (VB3,OFF,X'80'),RVGARR12
         LA        R1,RVGENT1
*  EC-9  A NAME SUBSCRIPTED IN AN EQUIVALENCE STMT. WAS NOT DIMENSIONED
RERREC9  $ERROR    (NOEX,EC,5,NAMR110),RVGARR13,SAVE               V1L5
RVGARR12 DS        0H                                              V1L5
         LA        R1,RVGENT1+4
RVGARR13 OUTPUT    4         OUTPUT BAL TO SS ROUTINE
         S         R7,KF4              4N-4 IN R7
         STC       R7,RVGARRCN         4N-4 AT RVGARRCN
         LR        R1,R110
         SH        R1,VDIM
         LA        R2,3
         MVC       RVGTEMP4(4),ZR1 MOVE NSHIFTS, LENGTH IN CASE CHARN
         IF        (VB1,NON,CHARN),RVGEN121  IS IT CHARACTER*N
         NI        ZR3+2,X'0F'         ZERO OUT BASE REGISTER IN BAL
         OI        ZR3+1,X'0C'         AND PUT IT IN INDEX POSITION
         MVI       RVGTEMP4,0          SET NSHIFTS TO ZERO
         IC        R2,RVGARRCN         RESET RVGARRCN
         LA        R2,ZR2+4  TO CONTAIN 4N
         STC       R2,RVGARRCN
         IC        R2,VLEN
         ST        R2,ZR1              STORE LENGTH AS EXTRA SUBSCRIPT
         LA        R2,7                SET TO OUTPUT EXTRA 4 BYTES
RVGEN121 OUTPUT    ,RVGARRCN
         LA        R2,ZR7+7            4N+3 IN R2
         LR        R1,R110
         SH        R1,VDIM             R1->DIMENSION LIST
         MVC       RPVDVAR(6),VPAD     SAVE VAR NAME FOR PVD MSG   V1L5
         OUTPUT    ,                   OUTPUT DIMENSION LIST
         MVC       ZR1(4),RVGTEMP4 RESTORE LENGTH IN CASE CHARN
RVGEN11  MVC       VPAD(2),RVPADD      PUT P(DOT ROUTINE) IN SYMTAB
         IF        (VB2,ON,PARM),RVGENV2 IS ARRAY A DUMMY PARAMETER ?
         IF        (VB2,ON,B2EQV),RVGENEQL    EQUIVALENCED ?
         IF        (VB2,NON,B2COM),RVGEN97 DONE UNLESS IN COMMON
         IF        (VB3,NON,VEQPROC),RVGEN122  HAS COMMON LIST BEEN
*                                              PROCESSED ?
RVGEN123 LH        R3,VEC              YES
         LCR       R3,R3
         L         R0,VLINK+EOFF-ELINK(R3) GET OFFSET FROM C.EQ. INFO.
         ST        R0,VOFF             STORE OFFSET IN SYMTAB ENTRY
         SH        R3,VLINK+CMLNK-ELINK(R3)
         LCR       R3,R3               FIX VEC SO IT LINKS TO THE
         STH       R3,VEC              SYMTAB ENTRY OF NEXT VARIABLE
         B         RVGEN97             IN COMMON LIST, THEN DONE
RVGEN122 OI        VB3,VEQPROC         TURN ON BIT TO INDICATE VARIABLE
         B         RVGEN97             HAS BEEN PROCESSED, THEN DONE.
         SPACE
*  EQUIVALENCE LIST PROCESSOR IN RELOCATOR PHASE ONE
RVGENEQL LR        R1,R110
         IF        (VB3,ON,VEQPROC),RVGENEQ6 HAS EQ.LIST BEEN PROCESSED
         OI        VB3,VEQPROC     NO - MARK VARIABLE AS PROCESSED
         SR        R3,R3
         $FREE     R8                                              V1L5
         USING     VLIST,R1
RVGENEQ1 IF        (VB2,ON,B2COM),RVGEN97 IGNORE LIST IF VAR. ALSO IN
*                                         COMMON.
         SH        R1,VEC    GET C. EQ. INFO ELEMENT
         USING     ELIST,R1
         C         R3,EOFF   IS        OFFSET.LT.R3
         BNH       RVGENEQ2
         L         R3,EOFF             YES - OFFSET IN R3
RVGENEQ2 SH        R1,ELINK            GET NEXT VAR. IN EQ. LIST
         USING     VLIST,R1
         CR        R1,R110   END OF LIST ?
         BNE       RVGENEQ1  NO
RVGENEQ3 LH        R7,VEC    YES
         CSNAP     EQUELT,,16
         LCR       R7,R7
         LCR       R0,R3     POSITIVE OFFSET IN R0
         USING     ELIST,R1
         A         R0,EOFF(R7) SUBTRACT SMALLEST OFFSET, SO SMALLEST
*                              WILL BE ZERO WHEN DONE.
         USING     VLIST,R1
RVGENEQ4 BAL       R14,RVGENALI        CHECK ALIGNMENT
RVGENEQ5 OI        VB3,VEQPROC         TURN ON EQUIVALENCE PROC BIT
         USING     ELIST,R1
         ST        R0,EOFF(R7)         STORE NEW OFFSET IN C.EQ.INFO
         CSNAP     EQUOFF,ELINK(R7),8
         SH        R7,ELINK(R7)
         AR        R1,R7               R1->NEXT VAR. IN EQ.LIST
         USING     VLIST,R1
         CR        R1,R110             END OF LIST ?
         BNE       RVGENEQ3
RVGENEQ6 LH        R7,VEC
         USING     ELIST,R1
         LCR       R7,R7
         L         R0,EOFF(R7)         GET EQ. OFFSET FROM C.EQ.INFO
         SH        R7,ELINK(R7)
         USING     VLIST,R1
         ST        R0,VOFF             STORE OFFSET IN SYMTAB ENTRYV1L5
         LCR       R7,R7               FIX VEC TO LINK TO SYMTAB ENTRY
         STH       R7,VEC              OF NEXT VAR. IN EQ. LIST
         B         RVGEN97             DONE
         SPACE
RVGENT1  EQU       *
         BAL       R15,XBOOT
         BAL       R15,XATEST          SINGLE OR MULTIPLE DIM      V1L5
RVPADD   DS        H
         SPACE
* DIMENSIONED VARIABLE(SUBROUTINE PARAMETER)
         SPACE
         OFFSET    USING,VLIST,R110,R8
RVGEN2   LR        R14,R110            ADD TO BEGINNING OF VDIMLIST
         S         R14,CVDIMBEG        ALL DUMMY ARRAYS ARE PROCESSED
         STH       R14,VEC             AFTER ALL OTHER NAMES
         ST        R110,CVDIMBEG                                   V1L5
         C         R110,CVDIMEND
         BNHR      RLOOP
         ST        R110,CVDIMEND                                   V1L5
         BR        RLOOP
*                                                                  V1L5
*  COMES HERE FOR EACH DUMMY ARRAY AFTER STAR ROUTINE HAS BEEN     V1L5
*  GENERATED TO ADD INFORMATION ABOUT VARIABLE DIMENSIONS TO END OFV1L5
*  COMPILER-GENERATED STAR ROUTINE                                 V1L5
*  AT THIS STAGE WE CHECK FOR ALL ARRAYS WHOSE LAST DIMENSION IS 1 V1L5
*  ARRAYS WITH THIS FEATURE WILL BE CLASSIFIED AS PVD (PSEUDO VARIABLE
*  DIMENSION) AND WILL BE DETECTED AT RUN TIME IN STARTB (YENTA)   V1L5
*  PVD HAS THE FOLLOWING CHARACTERISTIC  --- THE CODE BIT FOR VARIABLE
*  DIMENSION IS TURNED ON BUT THE CORRESPONDING ADDRESS OF THE VARIABLE
*  DIMENSION IS ZEROED OUT             R1 -> DIMENSION LIST        V1L5
*                                      (R7) -> 4N-4 (N = # OF DIM) V1L5
*                                                                  V1L5
RVGENV2  LA        R15,RVDIMARE        POINT TO VAR DIM LIST       V1L5
         SR        R2,R2               INITIALIZE CODE BYTE FOR    V1L5
         ST        R2,RVDIMARE         VAR DIM & A(VAR DIM)        V1L5
         STC       R7,RVGARRCN         SAVE 4N-4                   V1L5
         NI        DIM,X'FF'-DIMP      TURN DIM PROCESSED SW OFF   V1L5
RVGENVS  L         R14,4(R7,R1)        ACCESS LAST DIM FROM DLIST  V1L5
         LTR       R14,R14             TOP BYTE =X'80' FOR VAR DIM V1L5
         BNL       RVGENVL             BR IF DIM WAS A CONSTANT    V1L5
*        VARIABLE DIMENSION WAS FOUND; R2 RECORDS WHICH            V1L5
*        DIMENSIONS WERE VARIABLE FOR VAR DIM CODE BYTE            V1L5
         LA        R2,ZR2+1            KEEP TRACK OE VAR DIM       V1L5
         LH        R3,ZR14+4           A(VAR DIM) IN R3            V1L5
         N         R3,KM1631           ZERO TOP 2 BYTES            V1L5
         A         R3,RDATBASE         ADD BASE ADDR               V1L5
RVGENVV  DS        0H                  SAVE CODE BYTE & A(VD) IN   V1L5
         ST        R3,ZR15             RVDIMARE LIST               V1L5
         OI        DIM,DIMP            INDICATE LAST DIM PROCESSED V1L5
         IF        (ZR14+VB2-VLINK,OFF,B2EQV+B2COM),RVGENV5        V1L5
         OI        ZR15,X'80'          VAR DIM IN COMMON OR CALL   V1L5
RVGENV5  DS        0H                  BY NAME S/R PARAMETER       V1L5
         LA        R15,ZR15+4          BUMP PTR DOWN VDLIST        V1L5
RVGENVL  DS        0H                  IF LAST DIMENSION PROCESSED V1L5
         IF        (DIM,ON,DIMP),RVGENVP   THEN BRANCH             V1L5
         C         R14,KF1             LAST DIM =1 -> PSEUDO       V1L5
         BNE       RVGENVP             VARIABLE DIMENSION          V1L5
         LA        R2,ZR2+1            TURN ON CODE BYTE IN VDLIST V1L5
         L         R3,RPVDPTR          R3 -> A(VAR NAME) -4        V1L5
         $ERROR    (LANG,SV,6,NAMR3),,SAVE                         V1L5
         SR        R3,R3               ZERO ADDR OF VAR DIM        V1L5
         ST        R3,ZR15             SAVE ADDR IN RVDIMARE LIST  V1L5
         LA        R15,ZR15+4          BUMP PTR DOWN VLIST         V1L5
         AR        R2,R2               ADJUST VAR DIM CODE BYTE    V1L5
         S         R7,KF4              BUMP PTR UP DLIST           V1L5
         BNL       RVGENVS             CONTINUE PROCESSING         V1L5
         B         RVGENVQ             CALC VAR DIM CONTROL BYTE   V1L5
RVGENVP  DS        0H                                              V1L5
         AR        R2,R2               ADJUST VAR DIM CODE BYTE    V1L5
         OI        DIM,DIMP            SET LAST DIM PROCESSED SW   V1L5
         S         R7,KF4              BUMP PTR UP DLIST           V1L5
         BNL       RVGENVS             FALL THRU IF DLIST FINISHED V1L5
RVGENVQ  DS        0H                                              V1L5
         IC        R7,RVGARRCN         NOW CALCULATE CONTROL BYTE  V1L5
         SRA       R7,2                TO INDICATE WHICH DIMS      V1L5
         SLA       R2,5                WERE VARIABLE               V1L5
         SRA       R2,ZR7              BITS 2-8 INDICATE VAR DIM   V1L5
         IC        R0,RVDIMARE         R0 <- CODE BYTE FOR VAR DIM V1L5
         OR        R0,R2               OR IN VAR DIM FLAGS         V1L5
         STC       R0,RVDIMARE         STASH IT                    V1L5
         S         R15,RADVDIMA        # OF VAR DIM FOUND          V1L5
         LPR       R15,R15             +VE AMOUNT                  V1L5
         OUTPUT    ZR15+2,RVDIMARE     INTO THE OBJ CODE BUCKET    V1L5
         C         R110,CVDIMEND
         BE        RVGENEND
         SH        R110,VEC
         B         RVGARR
RPVDPTR  DC        A(RPVDVAR-4)        USED FOR SV-6 MSG           V1L5
RPVDVAR  DC        CL6'      '         VAR NAME FOR SV6 MSG        V1L5
         EJECT
RVGEN3   IF        (VB2,NOFF,B2COM+B2EQV),RVGEN4
         SPACE
* SIMPLE NON-EQUIVALENCED VARIABLE
         SPACE
         IC        R2,VB1
         N         R2,KM2831 =  MODE
         IC        R2,RVGENF2(R2)
         EX        0,RVGENT2(R2)
         AIF       ('&VM' NE 'USE').LVM35                          VM1
         IF        (XEXEC1SW,OFF,XVMASK),RVM3   XDEBUG MODE?       VM1
         THEN      (DO,VMSAVE)         SET UP PTR                  VM1
RVM3     DS        0H                                              VM1
         THEN      (OUTPUT,8,VB1)      OUTPUT VB1,VB2,VNAME        VM1
         AGO       .LVM36                                          VM1
.LVM35   ANOP                                                      VM1
         THEN      (OUTPUT,6,VNAME)                                VM1
.LVM36   ANOP                                                      VM1
RVGEN302 THEN      (DO,RPADR)
         STH       R3,VPAD
         IF        (VB1,ON,CHAR),RVGEN3J
         IF        (VB1,NON,COMP),RVGEN3C
*                                      COMPLEX*8
         LA        R3,ZR3+4
         IF        (VB1,NON,COMP16),RVGEN3E
*                                      COMPLEX*16
         LA        R3,ZR3+4
RVGEN3E  STH       R3,VSAD   STORE SECONDARY ADDRESS
RVGEN3C  SR        R2,R2
         IC        R2,VLEN
         BCTR      R2,0
         THEN      (OUTPUT,,XUNDEF),LOOP
*                                      CHARACTER*N
RVGEN3J  LR        R3,R5
         LA        R3,ZR3+4
         ST        R3,RVGEN3JT                                     V1L5
         MVC       RVGEN3JT(1),VLEN
         THEN      (OUTPUT,4,RVGEN3JT)
         THEN      (OUTPUT,1,XUNDEF)
         IF        (VB1,NON,CHARN),LOOP
*                                      NOTE THAT R3 POINTS TO THE CODE
*                                      WE JUST OUTPUT
         IC        R2,VLEN
         S         R2,KF2
         THEN      (OUTPUT,,(R3)),LOOP
         SPACE
RVGENF2  EQU       *
         DC        AL1(RVGENT2F-RVGENT2)
         AIF       ('&VM' NE 'USE').LVM37                          VM1
         DC        AL1(RVGENT2F-RVGENT2)                           VM1
         DC        AL1(RVGENT2F-RVGENT2)
         DC        AL1(RVGENT2F-RVGENT2)                           VM1
         AGO       .LVM38                                          VM1
.LVM37   ANOP                                                      VM1
         DC        AL1(RVGENT2B-RVGENT2)                           VM1
         DC        AL1(RVGENT2F-RVGENT2)                           VM1
         DC        AL1(RVGENT2H-RVGENT2)                           VM1
.LVM38   ANOP                                                      VM1
         DC        AL1(RVGENT2F-RVGENT2)
         DC        AL1(RVGENT2D-RVGENT2)
         DC        AL1(RVGENT2F-RVGENT2)
         DC        AL1(RVGENT2D-RVGENT2)
         DC        AL1(RVGENT2F-RVGENT2)
         DC        AL1(RVGENT2F-RVGENT2)
         SPACE
         DC        0H'0'
RVGENT2  EQU       *
RVGENT2B NOP       0
RVGENT2H BAL       R14,CDS0H
         AIF       ('&VM' NE 'USE').LVM39                          VM1
RVGENT2F BAL       R14,CDS0F                                       VM1
RVGENT2D BAL       R14,CDS0D                                       VM1
         AGO       .LVM40                                          VM1
.LVM39   ANOP                                                      VM1
RVGENT2F BAL       R14,CNOP24                                      VM1
RVGENT2D BAL       R14,CNOP28                                      VM1
.LVM40   ANOP                                                      VM1
         SPACE
* SIMPLE VARIABLE(EQUIVALENCED OR S/R PARAMETER BY NAME)
         SPACE
RVGEN4   EQU       *                                               VM1
         AIF       ('&VM' NE 'USE').LVM41                          VM1
         THEN      (DO,CDS0F)          FULL WORD ALIGN             VM1
         IF        (XEXEC1SW,OFF,XVMASK),RVM4   XDEBUG MODE?       VM1
         THEN      (DO,VMSAVE)         SAVE PTR                    VM1
RVM4     DS        0H                                              VM1
         THEN      (OUTPUT,8,VB1)      OUTPUT VB1,VB2,VNAME        VM1
         AGO       .LVM42                                          VM1
.LVM41   ANOP                                                      VM1
         THEN      (DO,CNOP24),(OUTPUT,6,VNAME)                    VM1
.LVM42   ANOP                                                      VM1
RVGEN402 THEN      (DO,RPADR)
         STH       R3,VPAD
         MVC       KB08(1),VLEN        PUT VLEN AT BEGINNING OF WORD
         THEN      (OUTPUT,4,KB08)
         IF        (VB2,ON,PARM),RVGEN4A
         IF        (VB2,ON,B2EQV),RVGENEQL
         IF        (VB3,ON,VEQPROC),RVGEN123
         OI        VB3,VEQPROC
         B         RVGEN97
RVGEN4A  XI        VB2,B2COM+B2EQV     TURN OFF EQ. BIT AND ON COM BIT
         BR        RLOOP
         EJECT
RVGEN5   IFNOT     (VB1,RTN),RVGEN6
         SPACE
* FUNCTION OR SUBROUTINE NAME
         SPACE
         USING     RLIST,R8
         IC        R2,RB2
         N         R2,KM3031
         AR        R2,R2
         LH        R3,RVGEN5T(R2)
         B         RVGEN10(R3)
         SPACE
RVGEN5T  EQU       *
         DC        AL2(0)
         DC        AL2(RVASF-RVGEN10)
         DC        AL2(RVGEN30-RVGEN10)
         DC        AL2(RVGEN40-RVGEN10)
         SPACE
* EXTERNAL NAME
         SPACE
RVGEN10  THEN      (DO,CDS0F),(DO,RPADR)
         STH       R3,RVGEN10T
         IF        (RB2,ON,PARM),RVGEN16
         AIF       ('&VM' NE 'USE').LVM43                          VM1
         IF        (XEXEC1SW,OFF,XVMASK),RVM5   XDEBUG MODE?       VM1
         LA        R3,4(,R3)           BUMP PTR PAST ZEROES        VM1
         STH       R3,RVGEN10T         AND RESAVE                  VM1
         THEN      (DO,VMSAVE),(OUTPUT,4,KF0)                      VM1
RVM5     DS        0H                                              VM1
.LVM43   ANOP                                                      VM1
         THEN      (OUTPUT,4,RAXBOOT)
         LOOKUP    GLBLVAR,,RVGEN12
         USING     LLIST,R15
         MVC       LB1(2),RB1
         MVC       LISN(2),RISN
         MVC       LADDR,RAXBOOT
RVGEN13  ST        R15,RADDR                                       V1L5
         MVC       RPAD,RVGEN10T
         MVC       RPAD+2(2),=X'0058'  SET ADCON TYPE TO STANDARD
         B         RVGEN97
RVGEN12  IFNOT     (LB1,PROG),THEN,(DO,RERRVAC),LOOP
         IF        (LB2,ON,B'00010000'),RVGEN15
         IF        (RB2,ON,B'00010000'),RVGEN13
         CLC       LB1,RB1
         BE        RVGEN13
RVGEN14  THEN      (DO,RERRSR2),RVGEN13
RVGEN15  IF        (RB2,NOFF,B'00010000'),RVGEN13
         MVC       LB1(1),RB1
         NI        LB2,ALL-USAGE2
         B         RVGEN13
         B         RVGEN13
         AIF       ('&VM' NE 'USE').LVM44                          VM1
RVGEN16  IF        (XEXEC1SW,OFF,XVMASK),RVM6   XDEBUG MODE?       VM1
         THEN      (DO,CDS0F),(DO,VMSAVE)                          VM1
         B         RVM7                                            VM1
RVM6     THEN      (DO,CNOP24),(OUTPUT,6,RNAME)                    VM1
RVM7     DS        0H                                              VM1
         THEN      (OUTPUT,2,VB1),(OUTPUT,6,RNAME)                 VM1
         AGO       .LVM45                                          VM1
.LVM44   ANOP                                                      VM1
RVGEN16  THEN      (DO,CNOP24),(OUTPUT,6,RNAME)                    VM1
.LVM45   ANOP                                                      VM1
         THEN      (DO,RPADR)
         STH       R3,RPAD
         THEN      (OUTPUT,4,*),LOOP
         SPACE
         OFFSET    DC,AL4,XTART+XERRUV4-START
         SPACE
         $FREE     R15                                             V1L5
         SPACE
* ASF ENTRY NAME
         SPACE
         AIF       ('&VM' NE 'USE').LVM47                          VM1
RVASF    THEN      (DO,CDS0F)                                      VM1
         IF        (XEXEC1SW,OFF,XVMASK),RVM8   XDEBUG MODE?       VM1
         THEN      (DO,VMSAVE),(OUTPUT,4,KF0)                      VM1
RVM8     DS        0H                                              VM1
         THEN      (DO,RPADR)                                      VM1
         AGO       .LVM999                                         VM1
.LVM47   ANOP                                                      VM1
RVASF    THEN      (DO,CDS0F),(DO,RPADR)
.LVM999  ANOP                                                      VM1
         STH       R3,RPAD             INTO SYMBOL TABLE
         THEN      (OUTPUT,4,RADDR)   OUTPUT BRANCH ADDRESS
         THEN      (DO,CDS0D)          REALLIGN ON DOUBLEWORD
         ST        R5,RADDR                                        V1L5
         LR        R15,R110
         SH        R15,RTLINK
         LR        R3,R5               FOR CALCULATION OF NEW R5
         L         R0,ZR15             LOAD FIXED TEMPORARIES LENGTH
         A         R0,KF7
         N         R0,KM0028
         S         R0,KP13
         AR        R3,R0               OVER FIXED TEMP REGION
         S         R0,KP1
         STH       R0,RTLINK           FOR TEMPORARY OFFSET
         A         R3,ZR15+4           PLUS FLOATING TEMPS
         S         R3,KP14             LESS REGISTER 14 JUNK
         ST        R3,RASFTMP          HOLD DURING OUTPUT          V1L5
         IF        (CMOSWTCH,ON),LOOP
         THEN      (OUTPUT,20*4,RSAVEA)     OUTPUT SAVEAREA        V1L1
         L         R5,RASFTMP          SAVE AREA CREATED9 MOVE TO HERE
         BR        RLOOP
         SPACE
* SECONDARY ENTRY NAME
         SPACE
RVGEN30  IF        (RB2,ON,TYPE),RVGEN31
         LR        R3,R8               R3=R8+R.PTRF
         AH        R3,RPTRF
         USING     VLIST,R3
         MVN       RB1,VB1
         $FREE     R3                                              V1L5
RVGEN31  LOOKUP    GLBLVAR,RVGEN32
         USING     LLIST,R15
         IFNOT     (LB1,RTN),THEN,(DO,RERRVAC),LOOP
         IF        (LB2,ON,B'00000010'),THEN,(DO,RERRSR8),LOOP
         CLC       RB1,LB1
         BE        RVGEN32
         IFNOT     (LB2,ON,B'00010000'),THEN,(DO,RERRSR2)
RVGEN32  MVC       LADDR,RADDR
         MVC       LCB,RCB
         BR        RLOOP
         $FREE     R15                                             V1L5
         SPACE
* PRIMARY ENTRY NAME
         SPACE
RVGEN40  IF        (RNAME,EQ,C' '),RVGEN46      IS THIS A GOOFED NAME
         IF        (RB2,ON,TYPE),RVGEN41
         LR        R3,R8               R3=R8+R.PTRF;
         AH        R3,RPTRF
         USING     VLIST,R3
         MVN       RB1,VB1
         $FREE     R3                                              V1L5
RVGEN41  LOOKUP    GLBLVAR,RVGEN42
         USING     LLIST,R15
         IFNOT     (LB1,RTN),THEN,(DO,RERRVAC),RVGEN97
         IF        (LB2,ON,B'00000010'),THEN,(DO,RERRSR8),RVGEN46
         CLC       RB1,LB1             IF R.B1=L.B1 THEN GO TO RVGEN42;
         BE        RVGEN42
         IFNOT     (LB2,ON,B'00010000'),THEN,(DO,RERRSR2)
RVGEN42  MVC       LCB,RCB             L.CB=R.CB;
         MVC       LADDR,RADDR         L.ADDR=R.ADDR;
RVGEN46  MVC       RADDR,RDATADDR      R.ADDR=RDATADDR;
         B         RVGEN96             GO TO RVGEN96;
         SPACE
RERRSR2  $ERROR    (NOAC,SR,2,NAMR8),DONE                          V1L5
RERRSR8  $ERROR    (WARN,SR,6,NAMR8),DONE                          V1L5
RERRVAC  $ERROR    (NOAC,VA,6,NAMR15),DONE                         V1L5
         SPACE
         $FREE     R8,R15                                          V1L5
         EJECT
*  COMMON BLOCK PROCESSOR IN RELOCATOR PHASE ONE
         USING     VLIST,R8
RVGEN6   IF        (VB1,NE,CBLK),LOOP
         OI        VB2,X'02'   TURN ON BIT IN VB2 SO MLIBR WON'T THINK
*                              COMMON BLOCK IS AN UNDEFINED ROUTINE
         LR        R1,R8
         $FREE     R8                                              V1L5
         USING     VLIST,R1
         SR        R0,R0               SET FIRST OFFSET =0
         ST        R0,RVGEN6MX                                     V1L5
         MVI       RBLCOMSW,ALL-INIT
         CLC       VNAME(4),BLANKCOM
         BNE       RVGEN631
         MVI       RBLCOMSW,ALL        SET BLANK COMMON SWITCH
RVGEN631 CLC       10(2,R1),KH0        ANY ELEMENTS IN COMMON
         BER       RLOOP               NO
         SH        R1,10(,R1)
         B         RVGEN636
RVGEN634 LR        R15,R1
         SH        R15,VEC
         USING     ELIST,R15
RVGEN633 IF        (VB3,NON,VEQPROC),RVGEN650
         LH        R3,VEC
         AH        R3,CMLNK
         STH       R3,VEC
         ST        R0,VOFF
         CSNAP     VOFF,VLINK,16
         B         RVGEN651
RVGEN650 OI        VB3,VEQPROC
         ST        R0,EOFF                                         V1L5
         CSNAP     COMOFF,ELINK,8
RVGEN651 AR        R0,R7               ADD LENGTH TO OFFSET
         LR        R1,R15
         SH        R1,CMLNK            GET NEXT ELEMENT IN COMMON
         CR        R1,R8               END OF LIST ?
         BE        RVGEN6ND
RVGEN636 BAL       R14,RCHBLCOM        CHECK BLANK COMMON INIT.
         CSNAP     COMELT,VLINK,16
RVGEN637 BAL       R14,RVGENALI
         LR        R7,R2
         IFNOT     (VB1,DIM),RVGEN638
         BAL       R14,RVGENLEN
RVGEN638 IF        (VB2,NON,B2EQV),RVGEN634
RVGEN6EQ NI        VB2,ALL-B2EQV       TURN OFF EQ. BIT
         LR        R15,R1
         SH        R15,VEC
         LR        R3,R15
         SH        R3,ELINK
         CR        R3,R1     ANY OTHER ELEMENTS IN EQUIVALENCE LIST
         BE        RVGEN634            NO
         ST        R1,ROLDR1                                       V1L3
         LH        R3,VLINK            MAKE LINK NEG.
         LCR       R3,R3
         STH       R3,VLINK
         AR        R7,R0
         ST        R7,RVGEN6CU         STORE NEXT COMMON OFFSET    V1L5
         LR        R7,R0
         S         R7,EOFF
         ST        R7,RVGEN6MG         STORE OFFSET CORRESPONDING TO
*                                      EQUIVALENCE OFFSET OF ZERO
         LH        R3,ELINK            SWITCH ELINK AND CLINK
         MVC       ELINK(2),CMLNK
         STH       R3,CMLNK
         B         RVGEN6E4
RVGEN6E1 STH       R3,CMLNK
         ST        R1,ROLDR1                                       V1L5
         MVC       RVB3(1),VB3
         IF        (VB3,NON,VEQPROC),RVGEN6E3
         LH        R3,VEC
         STH       R3,ROLDVEC                                      V1L3
         AH        R3,CMLNK
         STH       R3,VEC
         ST        R0,VOFF
         CSNAP     SPOFF,VLINK,16
         B         RVGEN6E2
RVGEN6E3 OI        VB3,VEQPROC
RVGEN6E4 ST        R0,EOFF                                         V1L5
         CSNAP     CEQOFF,ELINK,8
RVGEN6E2 LR        R1,R15
         SH        R1,CMLNK             NEXT ELT. IN EQUIV. LIST
         NI        VB2,ALL-B2EQV       TURN OFF EQ. BIT
         BAL       R14,RCHBLCOM
         IF        (VLINK,ON,X'80'),RVGEN6QN
         IF        (VB2,ON,B2COM),RERREC0
         OI        VB2,B2COM           TURN ON COMMON BIT
         LR        R15,R1
         SH        R15,VEC
         L         R0,RVGEN6MG                                     V1L5
         A         R0,EOFF             CALCULATE COMMON OFFSET
         BNL       RVGEN609
*  EC-3  EXTENDING COMMON DOWNWARDS WITH EQUIVALENCE
RERREC3  $ERROR    (NOAC,EC,3)                                     V1L5
RVGEN609 BAL       R14,RVGENALI
         LR        R7,R2
         IFNOT     (VB1,DIM),RVGEN610
         BAL       R14,RVGENLEN
RVGEN610 AR        R7,R0               ADD LENGTH TO OFFSET
         LH        R3,ELINK
         C         R7,RVGEN6MX
         BNH       RVGEN6E1
         ST        R7,RVGEN6MX                                     V1L5
         B         RVGEN6E1
RERREC0  LR        R3,R1               SET UP R3 TO POINT
         IF       (VB3,NON,VEQPROC),REC01        4 BYTES BEFORE
         LH        R3,VPAD                       THE NAME OF THE
         N         R3,KM1631                     VARIABLE
         A         R3,RDATBASE
         S         R3,KF10
REC01    $ERROR    (NOEX,EC,0,NAMR3),,SAVE                         V1L5
         LH        R3,CMLNK             LINK EQUIV LIST AROUND
         LCR       R3,R3               ELEMENT IN ANOTHER COMMON LIST
         SH        R3,VEC
         SH        R3,ELINK(R3)
         LCR       R3,R3
         STH       R3,CMLNK
         L         R1,ROLDR1           GET PREVIOUS ENTRY          V1L3
         IF        (VLINK,OFF,X'80'),REC02  NOT 1ST ELEMENT        V1L3
         NI        RVB3,ALL-VEQPROC    1ST - SO SET                V1L3
         B         RVGEN6E2                                        V1L3
REC02    LH        R3,ROLDVEC          RECALCULATE LINKS           V1L3
         AH        R3,CMLNK            DELETING BAD MEMBER         V1L3
         STH       R3,VEC                                          V1L3
         B         RVGEN6E2                                        V1L3
RVGEN6QN LH        R3,VLINK            CHANGE LINK TO POSITIVE
         LCR       R3,R3
         STH       R3,VLINK
         LH        R3,CMLNK
         LCR       R3,R3
         SH        R3,VEC              LINK AROUND ELEMENT IN
         SH        R3,ELINK(R3)        COMMON AND EQUIVALENCE
         LCR       R3,R3
         IF        (RVB3,NON,VEQPROC),RVGEN6Q3
         SH        R3,CMLNK
         L         R14,ROLDR1                                      V1L5
         AH        R3,ZR14+VEC-VLINK
         STH        R3,ZR14+VEC-VLINK
RVGEN6Q3 STH       R3,CMLNK
         LR        R15,R1
         SH        R1,VEC
         USING     VLIST,R15
         USING     ELINK,R1
         XI        VB3,VEQPROC
         IF        (VB3,ON,VEQPROC),RVGEN6Q2
         LH        R3,VEC
         AH        R3,CMLNK
         STH       R3,VEC
         L         R3,EOFF                                         V1L5
         ST        R3,VOFF                                         V1L5
RVGEN6Q2 L         R0,RVGEN6CU         GET OFFSET FOR NEXT COMMON
         SH        R1,ELINK
         CR        R1,R8               END OF COMMON LIST ?
         BNE       RVGEN636            NO
         USING     VLIST,R8
RVGEN6ND C         R0,RVGEN6MX
         BNH       RVGEN6N1
         ST        R0,RVGEN6MX                                     V1L5
RVGEN6N1 LOOKUP    GLBLVAR,RVGEN635
         USING     LLIST,R15
         ST        R15,12(R8)                                      V1L5
         IF        (LB1,NE,CBLK),RERRVAB
         CLC       RVGEN6MX+1(3),10(R15)    IS LENGTH SAME
         BE        RVGEN639
*  EC-1  WARNING - COMMON BLOCK HAS DIFFERENT LENGTH THAN IN LAST USE
RERREC1  $ERROR    (WARN,EC,1,NAMR15)                              V1L5
         CLC       RVGEN6MX+1(3),10(R15)    IS LENGTH SAME
         BL        RVGEN639
RVGEN635 DC        0H'0'     NEW ENTRY OR LENGTH INCREASES
         ST        R15,12(R8)                                      V1L5
         MVC       10(3,R15),RVGEN6MX+1  PUT IN NEW LENGTH
         MVC       LB1(2),VB1
RVGEN639 MVI       13(R15),ALL         MAKE ADDRESS NEGATIVE
         B         RVGEN97
RERRVAB  $ERROR    (NOAC,VA,7,NAMR15),,SAVE                        V1L5
         BR        RLOOP
RCHBLCOM NC        VB2(1),RBLCOMSW
         IF        (VB2,OFF,INIT),DONE
*  DA-9  LANGUAGE - INITIALLIZING BLANK COMMON
RERRDA9  $ERROR    (LANG,DA,7),,SAVE                               V1L5
         BR        RDONE
         $FREE     R8                                              V1L5
         USING     VLIST,R1
RVGENALI IC        R2,VB1
         N         R2,KM2831
         IC        R2,KT4(R2)
         NR        R2,R0
         IC        R2,VLEN
         BER       R14
*  EC-2  COMMON OR EQUIVALENCE OFFSET CAUSES BAD ALIGNMENT
RERREC2  $ERROR    (WARN,EC,2),ZR14,SAVE                           V1L5
RVGENALT DC        X'00'
RVGENALS EQU       KT1
KT4      DC        AL1(4-1,1-1,4-1,2-1,4-1,8-1,4-1,8-1,1-1,1-1)
RVGENLEN LH        R7,12(,R1)
         LCR       R7,R7
         L         R7,0(R7,R1)
         LA        R7,0(,R7)
         BR        R14
         SPACE
         USING     VLIST,R8
RVGEN96  L         R3,CGVBEG           START OF GVLIST             V1L5
         LTR       R3,R3               CHECK IF EMPTY
         BNZ       RVGEN97
         ST        R110,CGVBEG          YS INITIALIZE              V1L5
         B         RVGEN98
RVGEN97  L         R3,CGVEND           LOAD UP OLD END             V1L5
         LR        R7,R3
         SR        R7,R110             CALCULATE LINK
         STH       R7,ZR3(RO)          PUT INTO PREDECESSOR
RVGEN98  ST        R110,CGVEND          END OF LIST                V1L5
         L         R7,RNGVLIST                                     V1L5
         LA        R7,ZR7+16
         ST        R7,RNGVLIST                                     V1L5
         BR        RLOOP
         SPACE
         $FREE     R8                                              V1L5
         SPACE
RVGEN99  L         R110,CVDIMBEG       SCAN SUBROUTINE PARAMETERS  V1L5
         LTR       R110,R110           WHICH ARE ARRAYS
         BNZ       RVGARR
RVGENEND DC        0H'0'
         AIF       ('&VM' NE 'USE').LVM48                          VM1
         IF        (XEXEC1SW,OFF,XVMASK),RVM9   XDEBUG MODE?       VM1
         THEN      (DO,VMSAVE)                                     VM1
         OUTPUT    4,KF0                                           VM1
RVM9     DS        0H                                              VM1
.LVM48   ANOP                                                      VM1
         EJECT
*****************
* CONSTANT LIST *
*****************
         L         R4,CKBEG                                        V1L5
         LTR       R4,R4
         BZ        RKGEN99
         USING     CLIST,R4
         BAL       RLOOP,RKGEN1
         USING     *,RLOOP
         C         R4,CKEND
         BE        RKGEN99
         SH        R4,CLINK(RO)
RKGEN1   LH        R2,CLEN(RO)
         LA        R3,ZR2+1            ALIGN FOR CONSTANT
         LCR       R3,R3
         LA        R5,ZR5(R2)
         NR        R5,R3
         THEN      (DO,RPADR)
         STH       R3,RKTEMP
         THEN      (OUTPUT,,CON4(RO))
         LH        R3,RKTEMP           GET P(CONSTANT)
         STH       R3,CPAD(RO)         STORE AT PRIMARY POINTER
         EX        R0,*-*(R2)          IGNORE ASSEMBLER MESSAGE
         ORG       *-2                 GIMMICK TO AVOID
         DC        S(RKGEN2-3)         ASSEMBLY ALIGNMENT ERROR
         STH       R3,CSAD(RO)         STORE SECONDARY POINTER
RKGEN2   BR        RLOOP               DONE
         NOPR      0                   FILLER
         LA        R3,ZR3+4            ADD 4 FOR COMPLEX*8
         NOP       0                   FILLER
         LA        R3,ZR3+8            ADD 8 FOR COMPLEX*16
         SPACE
         $FREE     R4                                              V1L5
         SPACE
RKGEN99  CBALR
         EJECT
*************************
* STATEMENT NUMBER LIST *
*************************
         SPACE
R120     OFFSET    EQU,R8,R4
         SPACE
         L         R120,CSBEG                                      V1L5
         AIF       ('&VM' NE 'USE').LVM49                          VM1
         IF        (XEXEC1SW,OFF,XVMASK),RVM10  XDEBUG MODE?       VM1
         BAL       R14,CDS0F                                       VM1
         L         R1,VMSAVE55                                     VM1
         ST        R5,0(R1)                                        VM1
RVM10    DS        0H                                              VM1
.LVM49   ANOP                                                      VM1
         OFFSET    USING,NLIST,R120,R8
         BAL       RLOOP,RSGEN15
         USING     *,RLOOP
RSGEN10  DC        0H'0'
*        SH        R120,NLINK          /*OFFSET*/
         SH        R8,NLINK
RSGEN15  C         R120,CSEND
         BE        RSGEN99
         CSNAP     NLIST,NLIST,12
         IC        R2,NB1
         N         R2,KM2831
         IC        R2,RSGENF1(R2)
         B         RSGEN10(R2)
         SPACE
RSGENF1  EQU       *
         DC        2AL1(0)
         DC        AL1(RERRST8-RSGEN10)          B'0010'
         DC        AL1(RERRFM7-RSGEN10)    B'0011'                 V1L2
         DC        AL1(0)                                          V1L2
         DC        AL1(RERRST6-RSGEN10)    B'0101'                 V1L2
         DC        3AL1(0)                                         V1L2
         DC        AL1(RSGEN20-RSGEN10)          B'1001'
         DC        AL1(RERRST8-RSGEN10)          B'1010'           V1L2
         DC        AL1(0)                                          V1L2
         DC        AL1(RERRST0-RSGEN10)          B'1100'
         DC        AL1(RSGEN20F-RSGEN10)         B'1101'
         DC        2AL1(0)
         SPACE
* ST-A  MISSING FORMAT STATEMENT
RERRST8  $ERROR    (NOAC,ST,8,USNR8)                               V1L5
         MVC       NADDR,XAXBOOT                                   V1L2
         BR        RLOOP
* ST-0 MISSING STATEMENT NUMBER
RERRST0  DC        0H'0'                                           ST1
         AIF       ('&STR' NE 'USE').RSTR2                         ST1
         TM        NB1,PARA            WAS THIS A PAR'GPH PS. #?   ST1
         BZ        RSKIP1              NO - SKIP                   ST1
         L         R15,=V(STMISPAR)    YES - MISSING PARAGRAPH     ST1
         BALR      R14,R15             DECODE NAME & ISSUE MSG.    ST1
         B         RSGEN20                                         ST1
RSKIP1   DC        0H'0'                                           ST1
.RSTR2   ANOP                                                      ST1
         $ERROR    (NOAC,ST,0,USNR8)                               V1L5
RSGEN20  MVC       NADDR,XAXBOOT                                   V1L2
RSGEN20F THEN      (DO,CDS0F)                                      VM1
         AIF       ('&VM' NE 'USE').LVM50                          VM1
         IF        (XEXEC1SW,OFF,XVMASK),RVM11  XDEBUG MODE?       VM1
         THEN      (OUTPUT,1,NB1),(OUTPUT,3,NSTAT+1)               VM1
RVM11    DS        0H                                              VM1
.LVM50   ANOP                                                      VM1
         THEN      (DO,RPADR)                                      VM1
         STH       R3,NPAD
         THEN      (OUTPUT,4,NADDR),LOOP
*  ST-A  UNREFERENCED STATEMENT FOLLOWS A TRANSFER                 V1L2
RERRST6  DC        0H'0'                                       VM1-ST1
         AIF       ('&STR' NE 'USE').RSTR3                         ST1
         TM        NB1,PARA            WAS THIS A PAR. PSEU. #?    ST1
         BZ        RSKIP2              NO - SKIP                   ST1
         L         R15,=V(STUNREFP)    YES - UNREFERENCED PAR.     ST1
         BALR      R14,R15             DECODE NAME & GIVE WARNING  ST1
         BR        RLOOP                                           ST1
RSKIP2   DC        0H'0'                                           ST1
.RSTR3   ANOP                                                      ST1
         AIF       ('&VM' NE 'USE').LVM51                          VM1
         IF        (NB1,OFF,AFTRAN),RSGEN20F                       VM1
         AGO       .LVM52                                          VM1
.LVM51   ANOP                                                      VM1
         IF        (NB1,OFF,AFTRAN),LOOP                          V1L2
.LVM52   ANOP                                                      VM1
         L         R14,NADDR           GET OBJCODE ADDR            V1L2
         CLC       0(2,R14),XISNCD     TEST FOR 'STOP'             V1L2
         BNE       RESTACL                                         V1L2
         MVC       CSN(2),2(R14)       SAVE ISN                    V1L2
         $ERROR    (WARN,ST,A,CSNR8),LOOP                          V1L5
RESTACL  $ERROR    (WARN,ST,A,STNR8),LOOP    IF 'STOP'             V1L5
*  FM-7  UNREFERENCED FORMAT STATEMENT                             V1L2
RERRFM7  $ERROR    (WARN,FM,7,STNR8),LOOP                          V1L5
         AIF       ('&VM' NE 'USE').LVM53                          VM1
VMSAVE55 DC        A(*-*)                                          VM1
.LVM53   ANOP                                                      VM1
         SPACE
         $FREE     R8                                              V1L5
         SPACE
RSGEN99  DC        0H'0'
         AIF       ('&VM' NE 'USE').LVM54                          VM1
         IF        (XEXEC1SW,OFF,XVMASK),RVM12  XDEBUG MODE?       VM1
         OUTPUT    4,KFM1                                          VM1
RVM12    DS        0H                                              VM1
.LVM54   ANOP                                                      VM1
         EJECT
**************************
* HOLLERITH CONSTANT LIST *
**************************
         L         R4,CHBEG                                        V1L5
         USING     HLIST,R4
         THEN      (DO,CDS0F)
         BAL       RLOOP,RHGEN20
         USING     *,RLOOP
         CSNAP     *,HLIST(RO),8
         SH        R4,HLINK(RO)
RHGEN20  C         R4,CHEND
         BE        RHGEN99
         CSNAP     HLIST,HLIST(RO),8
         IF        (HLEN,ON),LOOP IF DATA, ETC., DON'T OUTPUT W.WORD
         MVC       HADDR(1),HLEN+1
         THEN      (DO,RPADR)
         LR        R0,R3               SAVE POINTER
         OUTPUT    4,HADDR(RO)         OUTPUT WONDERWORD
         STH       R0,HPAD(RO)         STORE POINTER
         BR        RLOOP
         SPACE
         $FREE     R4                                              V1L5
         SPACE
RHGEN99  EQU       *
         EJECT
         L         R3,RDATBASE                                     V1L5
         A         R3,KP11
         CR        R3,R5
         BNL       RPH1E5
         $ERROR    (NOEX,MO,3)                                     V1L5
RPH1E5   DC        0H'0'
***********************************************************************
*
* DEBUG VERSION ONLY - DUMPS DATA AREA AND NEW SYMBOL TABLE
*
         AIF       ('&SNAPS'EQ'OMIT').RSN2
         IF        (CMOSWTCH,ON),RPH1E10
         LR        R2,R5
         S         R2,RENTSAVE
         BNP       RPH1E10
         BCTR      R2,0
         OFFSET    LRAL,R1,RENTSAVE
         CSNAP     DATAAREA
RPH1E10  L         R2,CSYMBASE                                     V1L5
         A         R2,KP11
         SR        R2,R6
         BNP       RPH1E20
         BCTR      R2,0
         OFFSET    LR,R1,R6
         CSNAP     NEWSYMB
RPH1E20  EQU       *
.RSN2    ANOP
*
***********************************************************************
         TITLE     'LANDR     RELOCATOR PHASE-TWO'
* RELOCATE OBJECT CODE
*
* REGISTER USAGE
*
*                  R0                  WORK REGISTER
*                  R1                  WORK REGISTER
*                  R2                  WORK REGISTER
*                  R3                  WORK REGISTER
*                  R4                  WORK REGISTER
*                  R8                  WORK REGISTER
*                  R9                  CANNOT BE USED
*                  R11                 PROGRAM BAR
*                  R14                 LINKAGE REGISTER
*                  R15                 PROGRAM BAR
*******************************************************************
         IF        (CMOSWTCH,ON),RCLEANUP
         OFFSET    LRAL,R1,CPRG
         USING     ZOBJECT,R1
         LR        R8,R1
         SR        R2,R2
         L         R4,KM1631                                       V1L5
         LA        RLOOP,RELLOOP
         USING     RELLOOP,RLOOP
         BAL       R15,RELLOOP5
         USING     *,R15               RELOC12 MUST FOLLOW IMMEDIATELY
RELOC12  NR        R3,R4
         A         R3,RDATBASE
RELOC11  IC        R2,ZOBBYTE
RELOC13  ST        R3,ZOBJECT                                      V1L5
         STC       R2,ZOBJECT
RELLOOP  LA        R1,ZOBJECT+4
RELLOOP5 IC        R2,ZOBOPCD
         IC        R2,ROPTBL(R2)
         B         RELLOOP(R2)
         EJECT
RELRR    LA        R1,ZOBJECT+2
         B         RELLOOP5
REL45    MVZ       REL45TMP,ZOBBYTE
         IF        (REL45TMP,NE,X'B0'),RELRX
         LA        R8,ZOBJECT+4
RELRX    IC        R2,ZOBADDR
         SRL       R2,4
         IC        R2,RELPTF(R2)
         B         RELLOOP(R2)
RELSI    EQU       RELRX
RELSS    LA        R1,ZOBJECT+6
         B         RELLOOP5
RELADDR  LH        R3,ZOBADDR
         NR        R3,R4
         A         R3,CSYMBASE
         LH        R3,ZR3+4(RO)
         STH       R3,ZOBADDR
*        THEN      (ZOBBYTE,OR,RO)     /*OFFSET*/
         BR        RLOOP
RELTEMP  LH        R3,ZOBADDR
         AH        R3,RTMPO
         STH       R3,ZOBADDR
         BR        RLOOP
         EJECT
RELA3    LH        R3,ZOBADDR
         NR        R3,R4
         A         R3,CSYMBASE
         LH        R3,ZR3+4(RO)
         BR        R15                 GO TO RELOC12
RELA5    EQU       RELA3
RELB2    MVC       ZOBJECT(1),ZOBBYTE
         BR        RLOOP
RELB8    LA        R8,ZOBJECT+2
         THEN      (ZOBJECT,EQU,X'05'),LOOP MAKE INTO BALR INSTRUCTION
RELBC    L         R3,=A(XIOERR)
         B         RELOC11
RELBALR  B         REL05
RELBAL   EQU       REL45
RELSHIFT EQU       RELLOOP
RELSTM   EQU       RELLOOP
RELLM    EQU       RELLOOP
RSAVADDR B         RELA0
RASFSAVE B         RELA1
RTEMP    B         RELA2
RVAR     EQU       RELA3
RSTN     B         RELA4
RHOLER   EQU       RELA5
RVARS    B         RELA6
RSTNS    B         RELA7
RVARAM   B         RELA8
RKNST    B         RELA9
RELB1    EQU       RKNST
RSLST    B         RELAB
RFLST    B         RELAC
ROMIT    B         RELAF
RELOC1   EQU       RELB1
RELOC2   EQU       RELB2     INOUT DOESN'T GENERATE B2'S ANYMORE
RELSTN   B         RELB3
RELDSAVE B         RELB4
RELDHOL  B         RELB5
RELAEND  B         RELB6
*ELIEXIT B         RELB7
RELISN1  EQU       RELB8
RELSKP8  B         RELB9
RELNLST  B         RELBA
ROMITBAL B         RELBB
RELIO    EQU       RELBC
RERRCP0  $ERROR    (NOEX,CP,0)         MUST FALL THRU TO RELAA     V1L5
RELERROR EQU       RERRCP0
RELEND   DC        0H'0'
RELAA    DC        0H'0'
         EJECT
         AIF       ('&SNAPS'EQ'OMIT').RSN1
***********************************************************************
*
* DEBUG VERSION ONLY - DUMPS RELOCATED SUBPROGRAM
*
         IF        (CMOSWTCH,ON),RPH2E99
         L         R2,RENTSAVE                                     V1L5
         S         R2,CPRG
         BNP       RPH2E99
         BCTR      R2,0
         OFFSET    LRAL,R1,CPRG
         CSNAP     NEWPROG
*
***********************************************************************
.RSN1    ANOP
         EJECT
*  SYMBOL TABLE CLEANUP PHASE
RCLEANUP BALR      R11,0
         USING     *,R11
         L         R0,ROLDMAX          CALCULATE LIBRARY LIST      V1L5
         S         R0,RNGVLIST         DISPLACEMENT
         S         R0,ROLDR6
         ST        R0,RLDISP                                       V1L5
         L         R6,ROLDMAX                                      V1L5
         S         R6,KF16
         L         R8,ROLDGEND                                     V1L5
         C         R8,CGVEND           ANY NEW ENTRIES IN GVLIST
         BE        RCLEAN50            NO
         LTR       R0,R8               ANY PREVIOUS ENTRIES
         BNZ       RCLEAN2             YES
         L         R8,CGVBEG           NO
         ST        R6,CGVBEG           FIX UP BEGINNING OF LIST
         B         RCLEAN3
RCLEAN2  SR        R0,R6
         USING     GVLIST,R8
         LH        R3,GVLINK
         STH       R0,GVLINK           PATCH UP LINK OF OLD ENTRY
         SR        R8,R3               GET FIRST NEW ENTRY
RCLEAN3  MVC       RGVLINK1+2(14),GVLINK+2
         MVC       RGVLINK(2),GVLINK
         LR        R0,R6
         SR        R0,R8               DISPLACEMENT OF ENTRY IN R0
         IFNOT     (GVB1,VAR),RCLEAN6
         IF        (GVB2,NOFF,B2COM+B2EQV),RCLEAN4
RCLEAN7  C         R8,CGVEND           LAST ENTRY IN GVLIST
         MVC       ZR6(16),RGVLINK1
         BE        RCLEAN8
         SH        R8,RGVLINK          NO - GET NEXT ENTRY
         S         R6,KF16
         B         RCLEAN3
*  ROUTINES TO RELOCATE PARTICULAR KINDS OF GVLIST ENTRIES
RCLEAN4  LH        R3,RVEC
         LTR       R3,R3               DOES IT LINK TO ITSELF?
         BZ        RCLEAN7            YES
         AR        R3,R0               OR COMMONED VARIABLE
         STH       R3,RVEC
         LR        R15,R8
         IF        (GVB2,ON,B2COM),RCLEAN5
         USING     VLIST,R1
RCLEAN41 LR        R1,R15              FIND ENTRY POINTING TO THE
         SH        R15,VEC             PRESENT ONE
         CR        R15,R8
         BNE       RCLEAN41
         LH        R3,VEC              FIX VEC TO POINT TO NEW LOCATION
         SR        R3,R0
         STH       R3,VEC
         B         RCLEAN7
RCLEAN5  LR        R1,R15              FIND ENTRY POINTING TO COMMONED
         SH        R15,VEC             VARIABLE
         IF        (2(R15),VAR),RCLEAN5
         LR        R1,R15              COMMON BLOCK NAME FOUND IN LIST
         SH        R15,10(,R15)
         CR        R15,R8
         BNE       RCLEAN42
         LH        R3,10(,R1)          PATCH P(HEAD) IN CBLOCK NAME
         SR        R3,R0
         STH       R3,10(,R1)
         B         RCLEAN7
RCLEAN42 LR        R1,R15
         SH        R15,VEC
         CR        R15,R8
         BNE       RCLEAN42
         LH        R3,VEC              PATCH VEC OF ENTRY POINTING
         SR        R3,R0               TO THE PRESENT ONE
         STH       R3,VEC
         B         RCLEAN7
RCLEAN6  IFNOT     (GVB1,RTN),RCLEAN61
         IF        (GVB2,ON,X'02'),RCLEAN7
RCLEAN61 L         R3,12(R8)                                       V1L5
         LA        R3,ZR3
         CR        R3,R8
         BNL       RCLEAN65
         A         R3,RLDISP
         ST        R3,RGVADDR                                      V1L5
RCLEAN65 IF        (GVB1,RTN),RCLEAN7
         LH        R3,RPHEAD
         LTR       R3,R3               DOES IT LINK TO ITSELF?
         BZ        RCLEAN7            YES
         AR        R3,R0
         STH       R3,RPHEAD           PATCH P(HEAD) OF CBLOCK NAME
         LR        R15,R6
         SR        R15,R3
         B         RCLEAN41
RCLEAN8  ST        R6,CGVEND                                       V1L5
RCLEAN50 L         R8,ROLDLEND                                     V1L5
         C         R8,CLEND            ANY ENTRIES IN LIBRARY LIST
         BNE       RCLEAN51            YES
         LTR       R3,R8               NO - WERE THERE ANY BEFORE?
         BZ        RCLEAN59            NO - DONE
         L         R15,CLEND          R15->DUMMY ENTRY AT END OF LLIST
         MVC       2(8,R15),RCLNAME    SET UP BITS AND NAME
         BAL       R14,CLLIB1 GET A NEW DUMMY ENTRY FOR END OF LLIST
         B         RCLEAN59
RCLEAN51 S         R6,KF16
         USING     LLIST,R8
         LTR       R0,R8               ANY PREVIOUS ENTRIES
         BNZ       RCLEAN52            YES
         L         R8,CLBEG            GET FIRST ENTRY             V1L5
         ST        R6,CLBEG            FIX UP BEGINNING OF LIST    V1L5
         B         RCLEAN53
RCLEAN52 SR        R0,R6
         LH        R3,LLINK
         N         R3,KM1631
         STH       R0,LLINK            PATCH UP LINK OF OLD ENTRY
         SR        R8,R3               GET NEXT ENTRY
RCLEAN53 MVC       RGVLINK1+2(14),LLINK+2
         MVC       ZR6(16),RGVLINK1
         C         R8,CLEND
         BE        RCLEAN54
         SH        R8,LLINK
         S         R6,KF16
         B         RCLEAN53
RCLEAN54 ST        R6,CLEND                                        V1L5
RCLEAN59 EQU       *
         AIF       ('&WATTYPE' EQ 'DISTR').RCL1
         L         R2,XSYMBOL                                      V1L5
         SR        R2,R6
         BCTR      R2,0
         CSNAP     CLEANSYM,ZR6
         CSNAP     BYTESAVD,RLDISP,4
.RCL1    ANOP
         SPACE
RPH2E99  EQU       *
         USING     RELLOOP,RLOOP
         B         CRET
         SPACE
         $FREE     R8                                              V1L5
         EJECT
         USING     ZOBJECT,R1
REL05    MVZ       REL45TMP,ZOBBYTE    MOVEREGISTER
         CLI       REL45TMP,X'B0'      SEE IF ITS REGISTER 11
         LA        R1,ZOBJECT+2
         BNE       RELLOOP5
         LR        R8,R1
         B         RELLOOP5
RELA0    MVI       ZOBJECT,X'45'
         LA        R8,ZOBJECT+4
         MVC       ZOBJECT+12(4),RENTSAVE
         LA        R1,ZOBJECT+16
         B         RELLOOP5
RELA1    MVI       ZOBJECT,X'45'
         LA        R8,ZOBJECT+4
         LH        R3,ZOBADDR+12
         NR        R3,R4
         A         R3,CSYMBASE
         LH        R0,ZR3+10(RO)
         STH       R0,RTMPO
         OFFSET    L,R0,ZR3+12
         ST        R0,RCURSAVE                                     V1L5
         ST        R0,ZOBJECT+12                                   V1L5
         LA        R1,ZOBJECT+16
         B         RELLOOP5
RELA2    LH        R3,ZOBADDR
         NR        R3,R4
         C         R3,KP14
         BL        RELA2A
         AH        R3,RTMPO
RELA2A   S         R3,KP13
         A         R3,RCURSAVE
         B         RELOC11
RELB3    EQU       *
RELA4    LH        R3,ZOBADDR
         NR        R3,R4
         A         R3,CSYMBASE         =A(SYMBOL TABLE ENTRY-START)
         OFFSET    L,R3,ZR3+8
         B         RELOC11
RELA6    LH        R3,ZOBADDR
         NR        R3,R4
         A         R3,CSYMBASE         =A(SYMBOL TABLE ENTRY-START)
         SR        R0,R0
         IC        R0,ZR3+2(RO)
         LH        R3,ZR3+4(RO)
         NR        R3,R4
         S         R3,KP5
         A         R3,RDATADDR         =A(VARIABLE-START)
         IC        R2,ZOBBYTE          =BYTE
         XR        R2,R0
         B         RELOC13
RELA7    THEN      (ZOBOPCD,EQU,STAT),LOOP
RELA8    NI        ZOBADDR+1,X'FE'
RELA9    CLI       ZOBADDR,X'C0'
         BL        RELA3
         CLI       ZOBADDR,X'D0'
         BNL       RELA2
         LH        R3,ZOBADDR
         N         R3,KM2031
         AR        R3,R12
         B         RELOC11
RELAB    SR        R3,R3
         B         RELOC11
RELAC    LH        R3,ZOBADDR
         NR        R3,R4
         A         R3,CSYMBASE
         IC        R2,ZR3+2(RO)
         LH        R3,ZR3+4(RO)
         NR        R3,R4
         A         R3,RDATBASE
         ST        R3,ZOBOPCD                                      V1L5
         STC       R2,ZOBOPCD
         XI        ZOBOPCD,X'A0' TURN OFF SVAR AND ON FUNCTION BIT
         BR        RLOOP
RELAF    THEN      (ZOBOPCD,EQU,X'47') /*CHANGE TO BC INSTRUCTION*/
         LH        R3,2(R1)            =BRANCH ADDRESS
         N         R3,KM2031
         LA        R1,ZR8(R3)          SKIP OVER OBJECT CODE
         B         RELLOOP5
RELB4    L         R3,RENTSAVE                                     V1L5
         B         RELOC11
RELB5    LH        R3,ZOBADDR
         NR        R3,R4
         A         R3,CSYMBASE
         L         R3,ZR3+4(RO)                                    V1L5
         B         RELOC11
         SPACE
* END OF ASF
         SPACE
RELB6    THEN      (ZOBJECT,EQU,X'05') MAKE INTO BALR
         MVC       RTMPO,RTMPOM
         MVC       RCURSAVE,RENTSAVE
         LA        R1,ZOBJECT+2
         LR        R8,R1
         B         RELLOOP5
*ELB7    MVC       ZOBJECT(1),ZOBJECT+4
*        LA        R1,ZOBJECT+8
*        B         RELLOOP5
RELB9    THEN      (ZOBJECT,EQU,X'00')
         LA        R1,ZOBJECT+8
         B         RELLOOP5
RELBA    LH        R3,ZOBADDR
         NR        R3,R4
         A         R3,CSYMBASE
         L         R3,VADDR-VLIST(0,R3) GET NAMELIST ADDR FROM SYM TBL
         B         RELOC11
         SPACE
RELBB    MVI       ZOBOPCD,X'45'       MAKE INTO BAL
         LH        R3,ZOBADDR
         N         R3,KM2031
         LA        R14,ZOBJECT+4
         LA        R1,ZR8(R3)
         LR        R8,R14
         B         RELLOOP5
         EJECT
* REGISTER RELOCATION TABLE
RELPTF   EQU       *
         DC        4AL1(0)
         DC         7AL1(RELADDR-RELLOOP)
         DC        3AL1(0)
         DC        AL1(RELTEMP-RELLOOP)
         DC        AL1(0)
*
* OPERATION RELOCATION TABLE
*
* RR FORMAT INSTRUCTIONS
*
ROPTBL   EQU       *
         DC        AL1(0)              00,DATA
         DC        4AL1(RELERROR-RELLOOP)
         DC        AL1(RELBALR-RELLOOP)
         DC        2AL1(RELRR-RELLOOP)
         DC        8AL1(RELERROR-RELLOOP)
         DC        21AL1(RELRR-RELLOOP)
         DC        3AL1(RELERROR-RELLOOP)
         DC        13AL1(RELRR-RELLOOP)
         DC        3AL1(RELERROR-RELLOOP)
         DC        8AL1(RELRR-RELLOOP)
*
* RX FORMAT INSTRUCTIONS
*
         DC        5AL1(RELRX-RELLOOP)
         DC        AL1(RELBAL-RELLOOP)
         DC        7AL1(RELRX-RELLOOP)
         DC        AL1(RELERROR-RELLOOP)
         DC        3AL1(RELRX-RELLOOP)
         DC        3AL1(RELERROR-RELLOOP)
         DC        13AL1(RELRX-RELLOOP)
         DC        7AL1(RELERROR-RELLOOP)
         DC        9AL1(RELRX-RELLOOP)
         DC        7AL1(RELERROR-RELLOOP)
         DC        8AL1(RELRX-RELLOOP)
*
* RS,SI FORMAT INSTRUCTIONS
*
         DC        6AL1(RELERROR-RELLOOP)
         DC        2AL1(RELSI-RELLOOP)
         DC        8AL1(RELSHIFT-RELLOOP)
         DC        AL1(RELSTM-RELLOOP)
         DC        7AL1(RELSI-RELLOOP)
         DC        AL1(RELLM-RELLOOP)
         DC        7AL1(RELERROR-RELLOOP)
         DC        AL1(RSAVADDR-RELLOOP)
         DC        AL1(RASFSAVE-RELLOOP)
         DC        AL1(RTEMP-RELLOOP)
         DC        AL1(RVAR-RELLOOP)
         DC        AL1(RSTN-RELLOOP)
         DC        AL1(RHOLER-RELLOOP)
         DC        AL1(RVARS-RELLOOP)
         DC        AL1(RSTNS-RELLOOP)
         DC        AL1(RVARAM-RELLOOP)
         DC        AL1(RKNST-RELLOOP)
         DC        AL1(RELEND-RELLOOP)
         DC        AL1(RSLST-RELLOOP)
         DC        AL1(RFLST-RELLOOP)
         DC        2AL1(RELERROR-RELLOOP)
         DC        AL1(ROMIT-RELLOOP)
         DC        AL1(RELERROR-RELLOOP)
         DC        AL1(RELOC1-RELLOOP)
         DC        AL1(RELOC2-RELLOOP)
         DC        AL1(RELSTN-RELLOOP)
         DC        AL1(RELDSAVE-RELLOOP)
         DC        AL1(RELDHOL-RELLOOP)          B5
         DC        AL1(RELAEND-RELLOOP)          B6,END OF ASF
         DC        AL1(RELERROR-RELLOOP)         B7
*        DC        AL1(RELIEXIT-RELLOOP)
         DC        AL1(RELISN1-RELLOOP)          B8
         DC        AL1(RELSKP8-RELLOOP)          B9
         DC        AL1(RELNLST-RELLOOP)          BA
         DC        AL1(ROMITBAL-RELLOOP)         BB
         DC        AL1(RELIO-RELLOOP)            BC
         DC        3AL1(RELERROR-RELLOOP)
*
* SS FORMAT INSTRUCTIONS
*
         AIF       ('&PROFILE' EQ 'OMIT').RPROF73                  V1L5
         DC        5AL1(0)             STMT COUNT INDICATORS       V1L5
         DC        12AL1(RELERROR-RELLOOP)                         V1L5
         AGO       .RPROF74                                        V1L5
.RPROF73 ANOP                                                      V1L5
         DC        17AL1(RELERROR-RELLOOP)
.RPROF74 ANOP                                                      V1L5
         DC        7AL1(RELSS-RELLOOP)
         DC        4AL1(RELERROR-RELLOOP)
         DC        4AL1(RELSS-RELLOOP)
         DC        17AL1(RELERROR-RELLOOP)
         DC        3AL1(RELSS-RELLOOP)
         DC        4AL1(RELERROR-RELLOOP)
         DC        6AL1(RELSS-RELLOOP)
         DC        AL1(RELERROR-RELLOOP)
         DC        AL1(0)              FF,DATA
         SPACE
         $FREE     R15,RL                                          V1L5
         TITLE     'LANDR     RELOCATOR PHASE-THREE'
* SUBROUTINE LINKAGE AND ASSIGNMENT OF ARRAYS
*
         ENTRY     RPH3
RPH3     CENT      RSAVER
         THEN      (DO,CDS0D)
         ST        R5,XBEGDATA                                     V1L5
         CSNAP     XBEGDATA,XBEGDATA,4
         IF        (CMOSWTCH,ON),RPH3A
         EJECT
* SCAN OF GLOBAL VARIABLE LIST
         SPACE
R130     OFFSET    EQU,R8,R4
         SPACE
         L         R130,CGVBEG                                     V1L5
         OFFSET    USING,GVLIST,R130,R8
         BAL       RLOOP,RGVSC10
         USING     *,RLOOP
         C         R130,CGVEND
         BE        RGVSC99
*        SH        R130,GVLINK         /*OFFSET*/
         SH        R8,GVLINK
RGVSC10  EQU       *
         CSNAP     GVLIST,GVLIST,16
         EJECT
         IFNOT     (GVB1,VAR),RGVSC30
         IF        (GVB2,ON,B'00000010'),LOOP
         IF        (GVB2,ON,B'00000001'),RGVEQL
         LH        R3,GVPAD          SIMPLE ARRAY
         N         R3,KM1631
         A         R3,RDATBASE
         SR        R2,R2
         IC        R2,ZR3+8(RO)        GET NO. OF SHIFTS
         IC        R2,RGVARRT1(R2)
         AR        R5,R2
         LCR       R2,R2
         BCTR      R2,0
         NR        R5,R2
         IC        R2,ZR3+4(RO)
         ST        R5,ZR3+4(RO)
         STC       R2,ZR3+4(RO)
         CSNAP     DIMRTN,ZR3(RO),40
         OFFSET    L,R3,ZR3+8
         LA        R3,ZR3             ERASE TOP BYTE
         AR        R5,R3               ADD LENGTH TO R5
         BR        RLOOP
RGVEQL   LA        R5,ZR5+7            ALIGN R5 ON DOUBLE
         N         R5,KM0028
         ST        R5,RGVEQLMX                                     V1L5
         LR        R1,R8
         $FREE     R8                                              V1L5
         USING     VLIST,R1
RGVEQL1  XI        VB2,B2COM+B2EQV      TURN OFF EQ BIT AND ON COM BIT
         LH        R3,VPAD
         N         R3,KM1631
         A         R3,RDATBASE
         OFFSET    LR,R15,R3
         L         R0,VOFF   GET EQ OFFSET
         LTR       R0,R0               IS IT NEGATIVE ?
         BL        RGVEQL4             YES
         AR        R0,R5               NO - ADD A(1ST-START)
         SR        R2,R2
         IC        R2,ZR15   GET VLEN IF SVAR
         LR        R7,R2     SAVE VLEN IN R7
         AR        R2,R0               END IF S. VAR.
         IFNOT     (VB1,DIM),RGVEQL2
         LA        R15,ZR15+4
         L         R2,ZR15+4           LENGTH                      V1L5
         LA        R2,ZR2
         AR        R2,R0               END OF ARRAY
RGVEQL2  C         R2,RGVEQLMX         YES UPDATE SIZE
         BL        RGVEQL3
         ST        R2,RGVEQLMX                                     V1L5
RGVEQL3  IC        R3,ZR15
         ST        R0,ZR15                                         V1L5
         STC       R3,ZR15
         IF        (VB1,NON,CHAR1),RGVEQL4       IF NOT CHAR, DONE
         IF        (VB1,DIM),RGVEQL4   IF DIM, DONE
         STC       R7,ZR15   IF SIMPLE CHAR. PUT VLEN IN WONDERWORD
RGVEQL4  EQU       *
         CSNAP     RGVEQLDR,ZR15,40
         CSNAP     RGVEQST,,16
         SH        R1,VEC
         CR        R1,R8               END OF EQ. LIST ?
         BNE       RGVEQL1
         L         R5,RGVEQLMX         PUT A(NEXT-START) IN R5     V1L5
         BR        RLOOP
         OFFSET    USING,GVLIST,R130,R8
         EJECT
RGVSC30  IFNOT     (GVB1,RTN),RGVSC50
         SPACE
         USING     RLIST,R8
         SPACE
         IF        (RB2,OFF,B'00000010'),RGVSC40
         SPACE
* SUBPROGRAMME HEADER
         SPACE
         L         R3,RADDR                                        V1L5
         S         R3,KP5
         ST        R3,RDATBASE                                     V1L5
         BR        RLOOP
         SPACE
* EXTERNAL REFERENCES
         SPACE
RGVSC40  LH        R3,RPAD
         N         R3,KM1631
         A         R3,RDATBASE
         MVI       XDOUBLE+4,0
         L         R2,RADDR            GET A(LLIST ENTRY)          V1L5
         MVC       XDOUBLE+5(3),ZR2+13
RGVSC41  MVC       RGVEX(1),RPAD+3     INSERT OPCODE - L,A, OR ST
         IC        R2,RPAD+2           GET LENGTH-1 OF ADCON
         N         R2,KF15
         IC        R2,RADCONT(R2)      GO TO ROUTINE TO HANDLE
         B         RLEN4(R2)           AD CONS OF THAT LENGTH
RLEN4    MVC       XDOUBLE(4),ZR3      MOVE AD CON TO XDOUBLE
         L         R2,XDOUBLE          PUT IN R2
         EX        R0,RGVEX            RELOCATE IN PROPER DIRECTION
         ST        R2,XDOUBLE          STORE RESULT AT XDOUBLE     V1L5
         MVC       ZR3(4),XDOUBLE      RETURN RESULT TO ORIGINAL SPOT
         BR        RLOOP               DONE
RLEN3    MVI       XDOUBLE,0           SET TOP BYTE TO ZERO
         MVC       XDOUBLE+1(3),ZR3    MOVE 3-BYTE AD CON TO XDOUBLE
         L         R2,XDOUBLE          PICK UP AD CON IN R2
         EX        R0,RGVEX            RELOCATE IN PROPER DIRECTION
         ST        R2,XDOUBLE          STORE RESULT AT XDOUBLE     V1L5
         MVC       ZR3(3),XDOUBLE+1    MOVE BACK TO ORIGINAL LOCATION
         BR        RLOOP               DONE
RLEN2    MVC       XDOUBLE(2),ZR3      MOVE 2-BYTE AD CON TO XDOUBLE
         LH        R2,XDOUBLE          PICK UP IN R2
         EX        R0,RGVEX            RELOCATE IN PROPER DIRECTION
         STH       R2,XDOUBLE          STORE RESULT
         MVC       ZR3(2),XDOUBLE      MOVE BACK TO ORIGINAL LOCATION
         BR        RLOOP               DONE
RLEN5    L         R2,XDOUBLE+4        LOAD STANDARD AD CON
         ST        R2,ZR3              STORE STANDARD AD CON       V1L5
         BR        RLOOP               DONE
RGVEX    L         R2,XDOUBLE+4        OP-CODE GETS CHANGED
RADCONT  DC        AL1(RLEN5-RLEN4)
         DC        AL1(RLEN2-RLEN4)
         DC        AL1(RLEN3-RLEN4)
         DC        AL1(RLEN4-RLEN4)
         SPACE
         USING     GVLIST,R8
         EJECT
RGVSC50  IF        (GVB1,NE,CBLK),RGVSC60
         SPACE
*        COMMON BLOCK NAME PROCESSOR IN PHASE THREE
         SPACE
         OFFSET    L,R15,12(R8)         GET LLIST ENTRY
         USING      LLIST,R15
         IF         (LADDR+1,EQ,X'FF'),RGVSC58
         MVC       RGVSC5T+1(3),LADDR+1
         L         R7,RGVSC5T                                      V1L5
RGVSC51  LR        R1,R8
         USING     VLIST,R1
         CLC       VLIST+10(2),KF0     ANY VARIABLES IN COMMON ?
         BER       RLOOP
         SH        R1,10(,R1)          GET FIRST ELEMENT
RGVSC54  L         R0,VOFF                                         V1L5
         LTR       R0,R0               NEGATIVE ?
         BL        RGVSC57             YES
         AR        R0,R7               NO
         LH         R3,VPAD
         N         R3,KM1631
         A         R3,RDATBASE
         IFNOT     (VB1,DIM),RGVSC56
         LA        R3,ZR3+4
RGVSC56  IC        R2,ZR3(RO)
         ST        R0,ZR3(RO)
         STC       R2,ZR3(RO)
         CSNAP     COMDRT,ZR3(RO),40
RGVSC57  SH        R1,VEC
         CR        R1,R110
         BER       RLOOP
         B         RGVSC54
RGVSC58  IC        R2,LADDR             STORE ADDRESS OF COMMON BLOCK
         LA        R5,ZR5+7
         N         R5,KM0028
         ST        R5,LADDR                                        V1L5
         STC        R2,LADDR
         LR        R7,R5
         MVC       RGVSC5T+1(3),10(R15)
         A         R5,RGVSC5T          ADD LENGTH TO R5
         B         RGVSC51
*        PSEUDO-REGISTER PROCESSOR
RGVSC60  MVI       XDOUBLE,0           SET TOP BYTE OF XDOUBLE TO ZERO
         SR        R4,R4
         IF        (CXD,NE,X'02'),RGVSC61  WERE THERE PR'S IN COMPILE ?
         ST        R4,CXD              NO - SET CXD TO ZERO        V1L5
         BR        RLOOP               DONE
         USING     LLIST,R15
RGVSC61  L         R15,12(R8)          GET A(FIRST PR)             V1L5
RGVSC62  SR        R1,R1
         IC        R1,LB2              GET ALIGNMENT FACTOR FOR PR
         AR        R4,R1               ALIGN R4 ON PROPER BOUNDARY
         LCR       R1,R1               .       -
         BCTR      R1,0                .
         NR        R4,R1               .
         MVC       XDOUBLE+1(3),LLIST+10   GET LENGTH OF PR
         L         R14,LADDR           GET A(NEXT PR) IN LLIST     V1L5
         LA        R14,ZR14            CLEAR OUT TOP BYTE
         ST        R4,LADDR            STORE OFFSET OF PR IN LLIST V1L5
         A         R4,XDOUBLE          ADD LENGTH OF PR TO R4
         LTR       R15,R14             GET A(NEXT PR) IN LLIST
         BNZ       RGVSC62             LOOP IF NOT AT END OF PRLIST
         ST        R4,CXD              STORE CUMULATIVE LENGTH AT CXD
         BR        RLOOP               DONE
         EJECT
         $FREE     R8                                              V1L5
RGVSC99  DC        0H'0'
         EJECT
RPH3A    CBALR
         ST        R5,CENDARAY                                     V1L5
         THEN      (DO,CDS0D)
         ST        R5,XENDDATA                                     V1L5
         CSNAP     XENDDATA,XENDDATA,4
         SPACE
         B         CRET
         SPACE
         $FREE     RP,R13,R15                                      V1L5
         TITLE     'LANDR     LINKR SAVE AREA'
LSAVER   DS        18F
         USING     LSAVER,R13
LENTRYP  DS        F                   ENTRY POINT OF PROGRAMME
*
* ROUTINE TO SEE WHETHER AN END CARD HAS TO BE GENERATED
*
LENDTEST IFNOT     (CSRSWTCH,RTN),DONE
         CLINK1    LENDS,DONE
         EJECT
LSAVER1  DS        18F
LBAR11   DS        F
LABEG    DS        F                   ASF ARG LIST
LAEND    DS        F                   END
LVBEG    DS        F
LVRPTR   DS        H
         EJECT
LERRFN3  $ERROR    (ZERO,FN,1,NAMR15),DONE                         V1L5
LERRFN5  $ERROR    (ZERO,RE,2),DONE                                V1L5
LERRSRA  $ERROR    (BOOT,SR,8),DONE                                V1L5
LERRSX0B $ERROR    (ZERO,SX,0,SYMRS,INVAL),DONE                    V1L5
LERRSX1B $ERROR    (ZERO,SX,1,DELRS,INVAL),DONE                    V1L5
LERRSX2B $ERROR    (ZERO,SX,2,SYMRS,INVAL),DONE                    V1L5
LERRSXAA $ERROR    (ZERO,SX,A,DELRS,INVAL),DONE                    V1L5
LERRSXAB $ERROR    (ZERO,SX,A,SYMRS,INVAL),DONE                    V1L5
LERRSXB  $ERROR    (ZERO,SX,B,DELRS,INVAL),DONE   INV CHAR FOUND   V1L5
LERRVA0  $ERROR    (ZERO,VA,4,NAMR15),DONE                         V1L5
         EJECT
LENAME   DC        0F'0',Y(LFNAME-LENAME),AL1(LBRK),AL1(CNAME+2)
         DC        0F'0',CL8'*-*'
LFNAME   DC        0F'0',Y(LSRBRK-LFNAME),AL1(COMMA),AL1(CNAME+2)
         DC        0F'0',CL8'*-*'
LSRBRK   DC        0F'0',Y(LSTERM-LSRBRK),AL1(RBRK),AL1(PHI)
LSTERM   DC        0F'0',Y(0),AL1(TERM),AL1(PHI)
         SPACE
LASTASF  DC        0H'0',X'AB',X'20',H'0'
LASTARG  DC        0H'0',X'AB',X'10',Y(0)          LAST ARG
LASTARG1 DC        0H'0',X'AC',AL1(0),Y(*-*)     IF FUNCTION
LBARND   B         *-*
LRSTNS   DC        0H'0',X'A7',AL1(0),Y(0)       STATEMENT NUMBER RET
LRVARS   DC        0H'0',X'A6',X'0',Y(*-*)       SIMPLE VARIABLE
LRVARS1  DC        0H'0',X'A6',X'80',Y(*-*)  CALLED BY NAME
LSAVER2  DS        18F
         TITLE     'LANDR     RELOC SAVE AREA'
RSAVER   DS        18F
         USING     RSAVER,R13
RDATBASE DS        F
RASFTMP  DS        F                   ASF TEMPORARY AREA
RENTSAVE DS        F                   =A(MAIN ENTRY SAVE-START)
RCURSAVE DS        F                   CURRENT SAVE AREA-START
RDATADDR DS        F                   ADDRESS OF DATAAREA-START
RVGEN3JT DS        F
RTMPO    DS        H
RTMPOM   DS        H
RVGEN10T DS        H
RKTEMP   DS        H
         EJECT
RSAVEA   DC        18F'0',F'0',6A(*-*)
RADVDIMA DC        A(RVDIMARE+2)
CVDIMBEG DC        F'0'
CVDIMEND DC        F'0'
RVGARRCN DC        X'00800000'     FORCE A PROTECTION IF NOT RESET
RVDIMARE EQU       *
RVGTEMP4 DC        F'0'
RGVEQLMX DC        F'0'
RGVSC5T  DC        F'0'
RVGEN6T  DC        F'0'
RVGEN6MX DC        F'0'
RVGEN6CU DC        F'0'
RVGEN6MG DC        F'0'
ROLDR1   DC        F'0'
ROLDR6   DC        F'0'
ROLDGEND DC        F'0'
ROLDLEND DC        F'0'
ROLDMAX  DC        F'0'
RNGVLIST DC        F'0'
RLDISP   DC        F'0'
RGVLINK1 DC        0F'0',X'0010',14X'00'
RPHEAD   EQU       RGVLINK1+10
RGVADDR  EQU       RGVLINK1+12
RVEC     EQU       RGVLINK1+14
RGVLINK  DC        H'0'
RVB3     DC        X'00'
REL45TMP DC        X'00'
RVGENEQC DC        X'00'
RBLCOMSW DC        X'00'
ROLDVEC  DC        H'0'                                            V1L3
DIM      DC        X'00'                                           V1L5
DIMP     EQU       X'80'               -> LAST DIMENSION PROCESSED V1L5
         EJECT
* DATA AREA ADDRESS GENERATORS
* REGISTER USAGE
*
*                  R3                  RSEULT REGISTER
*                  R5                  =A(TOP OF OBJEXT CODE-START)
*                  R14                 RETURN ADDRESS
*
RPADR    LR        R3,R5
RPADR1   S         R3,RDATBASE
         BR        RDONE
RSADRS   LA        R3,ZR5+4
         THEN      (DO,RPADR1),DONE
RSADRD   LA        R3,ZR5+8
         THEN      (DO,RPADR1),DONE
         EJECT
* CONSTANTS
         SPACE
RAXBOOT  EQU       XAXBOOT                                         V1L2
RCLNAME  DC        X'6412',CL6'LLIST#'
         SPACE
RGVT1    EQU       KT2
RGVARRT1 DC        AL1(1-1,2-1,4-1,8-1,16-1)
         EJECT
* LITERALS
         SPACE
KF20     DC        F'20'
KM2031   DC        X'00000FFF'
KM2531   DC        X'0000007F'
KB08     DC        X'00800000'
KP1      DC        A(PAGE)
KP5      DC        A(5*PAGE)
KP11     DC        A(11*PAGE)
KP13     DC        A(13*PAGE)
KP14     DC        A(14*PAGE)
         SPACE
         LTORG
         EJECT
         END
