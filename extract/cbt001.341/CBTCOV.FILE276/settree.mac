 SETTREE:  PROCEDURE(P)RECURSIVE REORDER;
0DECLARE
      P POINTER;
0%INCLUDE DCLTREE,DCLOPER,FILES;
0DECLARE
      P2 POINTER AUTOMATIC, /* IMP */
      NULL BUILTIN;
-/*   SETTREE IS CALLED TO INITIALIZE MAP ENTRIES IN THE
 /*      READ TREE OR SUBTREE POINTED TO BY P.
 /*      THE TREE STRUCTURE IS DESCRIBED IN THE DOCUMENTATION
 /*           FOR CMPRD.  RECURSIVE CALLS ARE USED TO PROCESS THE
 /*           SUBTREES OF EACH NODE.  EACH LEAF IS INITIALIZED
 /*           TO THE CORRECT MAP ENTRY AND MAP SUBSCRIPT.
 /*           ALL MSELECT FIELDS ARE ZEROED. */
-     IF P=NULL /* SHOULD NOT HAPPEN */
         THEN RETURN;
0     P->MSELECT=0;
0     IF P->NODE_TYPE=$LEAF
         THEN DO;
              IF P->MAP_KEY^=P->INITIAL_MAP_KEY
                   THEN DO;
                        CALL PROPAGATE;
                        READ FILE(MAP)INTO(P->MAP_ENTRY)
                             KEY(P->INITIAL_MAP_KEY);
                        P->MAP_KEY=P->INITIAL_MAP_KEY;
                   END;
              P->MAP_SUBSCRIPT=P->INITIAL_MAP_SUBSCRIPT;
              CALL PROPAGATE;
         END;
         ELSE DO P2=P->PDOWN REPEAT P2->PACROSS WHILE(P2^=NULL);
              CALL SETTREE(P2);
         END;
1PROPAGATE:  PROCEDURE;
0DECLARE
      PNEXT POINTER;
0/*   PROPAGATE MINIMIZES MAP READS BY UPDATING THE NEXT LEAF.
 /*      P AND P->PACROSS MUST BOTH POINT TO UNFOLDED LEAVES.
 /*      IF P->MAP_KEY MATCHES P->PACROSS->INITIAL_MAP_KEY,
 /*      ERIC_KEY IS COPIED ACROSS TO SAVE READING FILE(MAP). */
0     PNEXT=P->PACROSS;
      IF PNEXT^=NULL THEN IF PNEXT->NODE_TYPE=$LEAF
         THEN IF P->MAP_KEY=PNEXT->INITIAL_MAP_KEY&
              P->FOLD_CODE=0&PNEXT->FOLD_CODE=0
                   THEN DO;
                        PNEXT->MAP_KEY=P->MAP_KEY;
                        PNEXT->ERIC_KEY=P->ERIC_KEY;
                   END;
0END PROPAGATE;
0END SETTREE;
