 NEXTKEY:  PROCEDURE RETURNS(PICTURE'(3)9(8)9')REORDER;
 %INCLUDE DCLOPER,DCLTREE,FILES;
0DECLARE
      (DECIMAL,HBOUND,MIN,MOD,NULL)BUILTIN;
0DECLARE
      HIGH_KEY FIXED BINARY(31)INITIAL((32767*65536)),
      NEXT_KEY FIXED BINARY(31);
1/*   NEXTKEY USES THE RECURSIVE ROUTINE TREE_KEY TO DETERMINE
 /*      THE MINIMUM KEY VALUE SATISFYING THE TREE CONSTRUCTED
 /*      BY CMPRD AND POINTED TO BY PHEAD.
 /*      TREE_KEY IS PASSED A POINTER P TO A SUBTREE AND A
 /*           TARGET VALUE MTARGET.  TREE_KEY SETS P->MSELECT
 /*           TO THE SMALLEST KEY VALUE GREATER THAN OR EQUAL TO
 /*           MTARGET WHICH SATISFIES THE LOGICAL EXPRESSION
 /*           REPRESENTED BY THE SUBTREE.  INITIALLY NEXTKEY
 /*           PASSES A POINTER PHEAD TO THE ENTIRE TREE AND
 /*           A TARGET ONE GREATER THAN THE LAST KEY RETURNED.
 /*      THE FIRST HALFWORD OF MSELECT IS A RELATIVE TRACK
 /*           NUMBER IN THE REGIONAL(3) FILE ERIC.  THE SECOND
 /*           HALFWORD IS THE RECORDED KEY, A PICTURE'999'
 /*           NUMBER INDICATING THE RECORD SEQUENCE NUMBER
 /*           ON THE TRACK, BEGINNING WITH 1.  THE VALUES
 /*           ARE REFORMATTED IN REGIONAL(3) FORMAT AS
 /*           PICTURE'(3)9(8)9'.  THE SPECIAL KEY X'7FFF0000'
 /*           WITH RECORDED KEY 0 IS USED TO INDICATE LOGICAL
 /*           ENDFILE OF A TREE OR SUBTREE.
 /*      TREE_KEY EVALUATES SUBTREES BY CASES, WHICH ARE DISCUSSED
 /*           INDIVIDUALLY BELOW.  TIME-CONSUMING, UNNECESSARY
 /*           RECURSIVE SUBTREE EVALUATION HAS BEEN ELIMINATED
 /*           WHENEVER POSSIBLE.
 /*      1) WHEN MTARGET=HIGH_KEY.  RATHER THAN WASTING TIME
 /*           EVALUATING SUBTREES, MSELECT IS IMMEDIATELY SET
 /*           TO HIGH_KEY.
 /*      2) WHEN MSELECT>=MTARGET.  THIS INDICATES THAT TREE_KEY
 /*           HAS PREVIOUSLY EVALUATED THE SUBTREE, BUT ITS VALUE
 /*           WAS PASSED OVER.  (A $OR OR $SEMI OPERATOR WILL
 /*           SELECT ONLY ONE OF ITS OPERANDS.)  THE PREVIOUS
 /*           VALUE OF MSELECT SHOULD BE USED AGAIN.
 /*      3) WHEN NODE_TYPE=$AND.  MSELECT MUST BE SET TO THE
 /*           SMALLEST VALUE>=MTARGET WHICH SIMULTANEOUSLY
 /*           SATISFIES THE SONS OF THE SUBTREE.  UPON ENTRY,
 /*           THE MSELECT FIELDS OF P->NODE AND ITS SONS ARE
 /*           ALL EQUAL.  THIS EQUALITY MUST BE PRESERVED
 /*           AT EXIT.  MAX_KEY, A TARGET VALUE FOR RECURSIVE
 /*           INVOCATIONS OF TREE_KEY, IS INITIALIZED TO
 /*           MTARGET.  THE POINTER PCURRENT IS USED TO
 /*           TRAVERSE THE SONS, RECURSIVELY INVOKING TREE_KEY
 /*           TO FORCE THEIR MSELECT FIELDS>=MTARGET.
 /*           IF, FOR A GIVEN SON DURING THE TRAVERSAL,
 /*           MSELECT=MAX_KEY,  ALL SUBTREES CONSIDERED TO THE
 /*           LEFT HAVE MAX_KEY AS THEIR VALUE AND TRAVERSAL
 /*           CONTINUES TO THE RIGHT.  OTHERWISE THE CURRENT
 /*           SON EVALUATES TO A HIGHER KEY AND THE TRAVERSAL
 /*           IS RESTARTED FROM THE FIRST SON USING THIS VALUE
 /*           AS THE NEW MAX_KEY. (A SUBSTANTIAL OPTIMIZATION
 /*           RESULTS FROM RECOGNIZING THIS SON ON THE
 /*           RETRAVERSAL AND NOT RECURSIVELY REEVALUATING ITS
 /*           MSELECT FIELD).  WHEN THE SONS HAVE BEEN
 /*           COMPLETELY TRAVERSED, P->MSELECT IS SET TO THEIR
 /*           COMMON MSELECT VALUE.
1/*      4) WHEN NODE_TYPE=$OR OR NODE_TYPE=$SEMI.  THE SONS OF
 /*           P->NODE ARE TRAVERSED FROM LEFT TO RIGHT.  ANY
 /*           SON WITH AN MSELECT<MTARGET IS RECURSIVELY
 /*           REEVALUATED TO GIVE MSELECT>=MTARGET.  THE MINIMUM
 /*           VALUE OF MSELECT OVER THE SONS IS ASSIGNED TO
 /*           P->MSELECT.
 /*      5) WHEN NODE_TYPE=LEAF.  THE ERIC KEYS REMAINING IN THE
 /*           CURRENT MAP_ENTRY ARE EXAMINED TO LOCATE THE FIRST>=
 /*           MTARGET.  IF ONE IS FOUND, MSELECT IS SET TO THIS
 /*           VALUE, OTHERWISE A NEW MAP ENTRY IS READ AND THE
 /*           PROCESS IS REPEATED.  TERMINATION IS GUARANTEED
 /*           SINCE HIGH_KEY IS USED AS A LOGICAL ENDFILE FOR
 /*           EACH DESCRIPTOR.  */
0     SELECT;
         WHEN(PHEAD=NULL)NEXT_KEY=HIGH_KEY; /* SHOULDN'T HAPPEN */
         WHEN(PHEAD->MSELECT=HIGH_KEY)NEXT_KEY=HIGH_KEY;
         OTHERWISE DO;
              CALL TREE_KEY(PHEAD,PHEAD->MSELECT+1);
              NEXT_KEY=PHEAD->MSELECT;
         END;
      END;
0     RETURN(DECIMAL(MOD(NEXT_KEY,65536),3,0)*100000000+
         DECIMAL(NEXT_KEY/65536,8,0)); /* 65536=2**16 */
1TREE_KEY:  PROCEDURE(P,MTARGET)RECURSIVE; /* SETS P->MSELECT */
0DECLARE
      P POINTER,
      MTARGET FIXED BINARY(31);
0DECLARE
      PCURRENT POINTER,
      (MAX_KEY,MIN_KEY,KEY_SUBSCRIPT)FIXED BINARY(31);
0SELECT;
0     WHEN(MTARGET=HIGH_KEY)P->MSELECT=HIGH_KEY;
0     WHEN(P->MSELECT>=MTARGET); /* REUSE OLD VALUE */
0     WHEN(P->NODE_TYPE=$AND)DO;
         MAX_KEY=MTARGET;PCURRENT=P->PDOWN;
         DO WHILE(PCURRENT^=NULL);
              IF PCURRENT->MSELECT^=MAX_KEY
                   THEN CALL TREE_KEY(PCURRENT,MAX_KEY);
              IF PCURRENT->MSELECT=MAX_KEY
                   THEN PCURRENT=PCURRENT->PACROSS;
                   ELSE DO;
                        MAX_KEY=PCURRENT->MSELECT;
                        PCURRENT=P->PDOWN;
                   END;
         END;
         P->MSELECT=MAX_KEY;
      END;
0     WHEN(P->NODE_TYPE=$OR×P->NODE_TYPE=$SEMI)DO;
         MIN_KEY=HIGH_KEY;PCURRENT=P->PDOWN;
         DO WHILE(PCURRENT^=NULL);
              IF PCURRENT->MSELECT<MTARGET
                   THEN CALL TREE_KEY(PCURRENT,MTARGET);
              MIN_KEY=MIN(MIN_KEY,PCURRENT->MSELECT);
              PCURRENT=PCURRENT->PACROSS;
         END;
         P->MSELECT=MIN_KEY;
      END;
1     OTHERWISE DO WHILE(P->MSELECT<MTARGET); /* LEAF */
         DO KEY_SUBSCRIPT=P->MAP_SUBSCRIPT TO HBOUND(P->ERIC_KEY,1)
              WHILE(P->ERIC_KEY(KEY_SUBSCRIPT)<MTARGET);
         END;
         IF KEY_SUBSCRIPT<=HBOUND(P->ERIC_KEY,1)
              THEN DO;
                   P->MSELECT=P->ERIC_KEY(KEY_SUBSCRIPT);
                   P->MAP_SUBSCRIPT=KEY_SUBSCRIPT+1;
              END;
              ELSE DO;
                   P->MAP_KEY=P->MAP_KEY+1;
                   READ FILE(MAP)INTO(P->ERIC_KEY)KEY(P->MAP_KEY);
                   P->MAP_SUBSCRIPT=1;
              END;
      END;
 END;
0END TREE_KEY;
0END NEXTKEY;
