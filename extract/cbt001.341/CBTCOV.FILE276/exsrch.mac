*PROCESS INTERRUPT;
 EXSRCH:  PROCEDURE(STTYPE)REORDER;
0DECLARE
      STTYPE CHAR(10);
0%INCLUDE EXTVAR,EXTVAR2,DCLPHEAD,EXTRTN2,
1 FILES,DCLOPT;
0DECLARE
      (ADDR,LENGTH,NULL,SUBSTR)BUILTIN,
      (RECORDS_PRINTED,RECORDS_READ,
      RECORDS_SATISFIED_READ_STMT,
      RECORDS_SATISFIED_SEARCH_REQ)FIXED BINARY(31),
      (STILL_READING,STILL_PRINTING)BIT(1),
      PERIC EXTERNAL POINTER,
      TESTOBJ EXTERNAL ENTRY RETURNS(BIT(1)ALIGNED),
      UNPACK EXTERNAL ENTRY,
      UNPACKED_ERIC_STRING CHAR(5050) VARYING,
      PUNPK POINTER INITIAL(ADDR(UNPACKED_ERIC_STRING)),
      BUFFER_KEY PICTURE'(3)9(8)9',
      BUFFER CHAR(2700)VARYING;
1/*   EXSRCH EXECUTES THE COMPILED SEARCH.
 /*       SETTREE IS CALLED TO INITIALIZE THE TREE COMPILED BY CMPRD
 /*            AND POINTED TO BY PHEAD. NEXTKEY IS USED TO DETERMINE
 /*            THE NEXT RECORD TO BE READ.  A RECORD NUMBER OF ZERO
 /*            (FIRST THREE BYTES OF THE KEY) INDICATES LOGICAL
 /*            END OF FILE.
 /*       THE DESIRED RECORDS ARE READ FROM FILE(ERIC) INTO
 /*            BUFFER.  PREVIOUS VERSIONS USED EVENT I/O AND
 /*            MULTIPLE BUFFERS.  THIS TOOK EXTRA CPU TIME, GAVE
 /*            LITTLE BENEFIT, AND OFTEN LEAD TO MAINTENANCE ERRORS.
 /*            AN OLD VERSION IS AVAILABLE IN MEMBER EXSRCHB.
 /*       AS THE DESIRED RECORDS ARE READ IN, TESTOBJ IS CALLED TO
 /*            BRANCH INTO THE OBJECT CODE (OBJCODE) CONSTRUCTED
 /*            BY COMPILE.  DUMMY CODE IS CONSTRUCTED IF NO FIELD
 /*            STATEMENTS WERE SPECIFIED.
 /*       IF A RECORD IS ACCEPTED BY TESTOBJ, THE ASSEMBLER SUBROUTINE
 /*            UNPACK IS CALLED TO CONVERT THE RECORD TO PRINTABLE FORM.
 /*            UNPACK DOES NOT CHECK LENGTH AND MAY OVERRUN THE
 /*            WORK AREA PROVIDED.  (A CHECK ON THE UNPACKED LENGTH
 /*            IS INCLUDED TO TRY TO RECOGNIZE AN OVERRUN AND RAISE
 /*            ERROR.)  PRINT IS THEN CALLED TO FORMAT AND OUTPUT
 /*            THE RECORD.
 /*       AT THE END OF THE SEARCH, STATISTICS ON THE NUMBER OF
 /*            RECORD KEYS PASSED BACK BY NEXTKEY , THE NUMBER OF
 /*            RECORDS WHICH WERE ACTUALLY READ, THE NUMBER OF
 /*            RECORDS READ WHICH WERE ACCEPTED BY TESTOBJ, AND THE
 /*            NUMBER OF RECORDS PRINTED ARE GIVEN.
 /*       THE ABOVE PICTURE MAY BE COMPLICATED SLIGHTLY:
 /*            A LIMIT ON THE NUMBER OF RECORDS WHICH MAY BE READ
 /*            (OPT.READLIM) AND ON THE NUMBER OF RECORDS WHICH
 /*            MAY BE PRINTED (OPT.PRINTLIM) IS ALWAYS IN EFFECT
 /*            UNDER TSO, AND MAY BE ACTIVATED IN BATCH WITH AN
 /*            OPTIONS STATEMENT.  PRINTING IS HALTED WHEN THE
 /*            PRINT LIMIT IS EXCEEDED, WHEN THE READ LIMIT IS
 /*            EXCEEDED, OR (UNDER TSO) WHEN AN ATTENTION
 /*            INTERRRUPT OCCURS.  READING IS HALTED WHEN THE READ
 /*            LIMIT IS EXCEEDED, WHEN LOGICAL ENDFILE OCCURS,
 /*            OR WHEN PRINTING IS HALTED AND THE SEARCH CONSISTS
 /*            OF ONLY A READ STATEMENT (NO FIELD STATEMENTS).
 /*       A FINAL COMPLICATION:  IF STTYPE IS PASSED AS 'TALLY'
 /*            RATHER THAN 'GO', PRINTING IS HALTED UPON ENTRY
 /*            AND ONLY COUNTS ARE PRINTED. */
1ON ATTENTION CALL HALT_PRINTING;
0     RECORDS_PRINTED,RECORDS_READ=0;
      RECORDS_SATISFIED_READ_STMT,RECORDS_SATISFIED_SEARCH_REQ=0;
      STILL_READING,STILL_PRINTING='1'B;
      PERIC=ADDR(BUFFER); /* USED BY TESTOBJ */
      CALL SETTREE(PHEAD);
      IF STTYPE='TALLY     ' /* COUNT ONLY */
         THEN CALL HALT_PRINTING;
         ELSE IF ENV.TSO&OPT.PRINTLIM>0
              THEN PUT FILE(SYSPRINT)SKIP(2)EDIT
                   ('HIT ATTENTION TO STOP PRINTING REFERENCES.')(A);
0     DO BUFFER_KEY=NEXTKEY REPEAT(NEXTKEY)
         WHILE(SUBSTR(BUFFER_KEY,1,3)^='000');
         RECORDS_SATISFIED_READ_STMT=
              RECORDS_SATISFIED_READ_STMT+1;
         IF STILL_READING
              THEN DO;
                   CALL READ_RECORD;
                   IF TESTOBJ /* CALL OBJCODE */
                        THEN DO;
                             RECORDS_SATISFIED_SEARCH_REQ=
                                  RECORDS_SATISFIED_SEARCH_REQ+1;
                             IF STILL_PRINTING
                                  THEN CALL PRINT_RECORD;
                        END;
              END;
      END;
0     PUT FILE(SYSPRINT)SKIP(2)EDIT
         (RECORDS_SATISFIED_READ_STMT,
         ' RECORDS SATISFIED THE READ STATEMENT')(F(9),A);
      IF LENGTH(OBJCODE)>8 /* RECORDS WERE EXAMINED */
         THEN PUT FILE(SYSPRINT)EDIT
              (RECORDS_READ,
              ' RECORDS WERE READ',
              RECORDS_SATISFIED_SEARCH_REQ,
              ' OF THESE SATISFIED THE SEARCH REQUEST')(SKIP,F(9),A);
      IF STTYPE^='TALLY     '&OPT.PRINTLIM>0&
         ^ENV.TSO /* INCORRECT COUNT DUE TO TCAM BUFFER FLUSH */
         THEN PUT FILE(SYSPRINT)EDIT
              (RECORDS_PRINTED,
              ' RECORDS WERE PRINTED')(SKIP,F(9),A);
      PUT FILE(SYSPRINT)SKIP(5);
1READ_RECORD:  PROCEDURE;
      IF RECORDS_READ<OPT.READLIM
         THEN DO;
              RECORDS_READ=RECORDS_READ+1;
              READ FILE(ERIC)INTO(BUFFER)KEY(BUFFER_KEY);
              IF LENGTH(BUFFER)>2700 /* MAX LENGTH */
                   THEN SIGNAL ERROR;
         END;
         ELSE CALL HALT_READING;
 END READ_RECORD;
-HALT_READING:  PROCEDURE;
      STILL_READING=0B;
      IF RECORDS_READ=OPT.READLIM
         THEN PUT FILE(SYSPRINT)SKIP(2)EDIT
              ('THE READ LIMIT HAS BEEN EXCEEDED.  ',
              'NO MORE RECORDS WILL BE READ.')(A);
 END HALT_READING;
-PRINT_RECORD:  PROCEDURE;
      IF RECORDS_PRINTED<OPT.PRINTLIM
         THEN DO;
              RECORDS_PRINTED=RECORDS_PRINTED+1;
              CALL UNPACK(ADDR(BUFFER),PUNPK);
              IF LENGTH(UNPACKED_ERIC_STRING)>5050 /* MAX LENGTH */
                   THEN SIGNAL ERROR;
              CALL PRINT(PUNPK,RECORDS_PRINTED);
         END;
         ELSE CALL HALT_PRINTING;
 END PRINT_RECORD;
-HALT_PRINTING:  PROCEDURE;
      STILL_PRINTING=0B;
      IF LENGTH(OBJCODE)<=10 /* NO FIELD STMTS */
         THEN STILL_READING=0B;
      IF RECORDS_PRINTED=OPT.PRINTLIM&STTYPE^='TALLY     '
         THEN PUT FILE(SYSPRINT)SKIP(2)EDIT
              ('THE PRINT LIMIT HAS BEEN EXCEEDED.  ',
              'NO MORE RECORDS WILL BE PRINTED.')(A);
 END HALT_PRINTING;
0END EXSRCH;
