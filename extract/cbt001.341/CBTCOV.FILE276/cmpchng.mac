 (CHECK(ERRCODE)):  CMPCHNG:  PROCEDURE(STTYPE,STMT,P999)REORDER;
 %INCLUDE DCLSTMT;
0DECLARE
      P999 PICTURE'999';
 %INCLUDE DCLSTMAP,DCLOPT,DCLRTRAN;
1%INCLUDE EXTVAR,EXTVAR2,EXTRTN;
-     DECLARE
      (CHAR,INDEX,LENGTH,ONSOURCE,SUBSTR,VERIFY)BUILTIN,
      (N,N2)FIXED BINARY,
      ID_LEN FIXED BINARY,
      (ID,NEW_TYPE)CHAR(12),
      (OLD_STMT,NEW_STMT)CHAR(1201)VAR, /* >= DECLARED LENGTH(STMT) */
      NEW_SBSTMTS CHAR(2001)VAR, /* DECLARED LENGTH(SBSTMTS) */
      DELIM CHAR(1),
      (OLD_LENGTH,OLD_LOC,NEW_LENGTH)FIXED BINARY;
1/*   CMPCHNG IS CALLED TO COMPILE CHANGE AND COMPLETE STATEMENTS.
 /*      STMT IS A VARYING CHARACTER STRING WITH FORMAT SIMILAR
 /*           TO THE TSO CHANGE SUBCOMMAND OF EDIT:
 /*
 /*                CHANGE STATEMENT-ID $OLD-STRING$NEW-STRING$#
 /*
 /*           (COMPLETE STATEMENTS SAY COMPLETE RATHER THAN CHANGE.)
 /*           OTHER CHARACTERS MAY BE SUBSTITUTED FOR $ AS A
 /*           DELIMITER, AS IN TSO SPECIAL DELIMITER NOTATION.
 /*           THE DELIMITER BEFORE # IS OPTIONAL.
 /*      STATEMENT-ID REFERS TO ONE OR MORE STATEMENTS IN THE
 /*           EXTERNAL STRING SBSTMTS, WHERE A COPY OF THE CURRENT
 /*           PROGRAM TEXT IS MAINTAINED.  A STATEMENT-ID IS EITHER
 /*           A GENERAL CLASS OF STATEMENT IN SBSTMTS (E. G., 'READ'),
 /*           OR THE NUMBER OF A PARTICULAR STATEMENT IN SBSTMTS
 /*           (E. G., '2').  IF A CLASS OF STATEMENTS IS SPECIFIED,
 /*           THERE MUST BE ONLY ONE REPRESENTATIVE OF THE CLASS
 /*           IN SBSTMTS (THAT IS, THE STATEMENT-ID MUST UNIQUELY
 /*           IDENTIFY A STATEMENT).
 /*      CMPCHNG CALLS SCNSBST TO ANALYZE SBSTMTS, SAVING STATEMENT
 /*           TYPES IN STMAP.  THE SPECIFIED STATEMENT IS SBSTMTS
 /*           IS COPIED TO OLD_STMT.  OLD_STMT IS VERIFIED TO CONTAIN
 /*           THE OLD-STRING.  NEW_STMT IS CONSTRUCTED FROM OLD_STMT
 /*           EITHER BY REPLACING OLD-STRING WITH NEW-STRING
 /*           (IF OLD_STRING IS NOT NULL), OR BY APPENDING NEW-STRING
 /*           TO OLD_STATEMENT IMMEDIATELY BEFORE THE TERMINAL #.
 /*           (NOTE THAT THIS IS DIFFERENT FROM TSO, WHICH APPENDS
 /*           TO THE LEFT.)
 /*      COMPLETE STATEMENTS DIFFER FROM CHANGE STATEMENTS ONLY
 /*           IN THE INTERPRETATION OF OLD-STRING:  FOR COMPLETE
 /*           STATEMENTS, ALL OF OLD_STMT FOLLOWING OLD-STRING IS
 /*           DELETED.  THIS RESEMBLES THE TSO CHANGE STATEMENT
 /*           WHERE ONLY ONE STRING IS SPECIFIED AND THE USER IS
 /*           PROMPTED TO REPLACE THE LINE BEGINNING AT THAT POINT.
 /*      BEFORE FINAL UPDATING, A CHECK IS MADE TO PREVENT CHANGING
 /*           A READ STATEMENT TO A NON-READ STATEMENT AND VICE-VERSA.
 /*           NEW_STMT IS VERIFIED TO BE WITHIN THE MAXIMUM PERMITTED
 /*           LENGTH FOR STMT.  THE STATEMENT IN SBSTMTS IS UPDATED
 /*           AFTER CHECKING FOR STRINGSIZE.  SINCE SBSTMTS CAN NOW
 /*           CONTAIN INCORRECT STATEMENTS OR STATEMENTS WHICH
 /*           CANNOT BE OR SHOULD NOT BE STACKED, IT SHOULD BE SPEEDILY
 /*           RETRANSLATED.  RETRANSLATE IS SET AND, IF A READ STATEMENT
 /*           WAS CHANGED, RETRANSLATE_READ.  THE CALLER IS RESPONSIBLE
 /*           FOR INVOKING RETRANSLATION.
 /*      P999 IS A PICTURE'999' VARIABLE WHICH IS SET (UPON
 /*           NORMAL RETURN) TO THE NUMERIC STATEMENT-ID OF THE
 /*           CHANGED STATEMENT.  (THE INTENT IS THAT THE CALLER
 /*           ECHO THE CHANGED STATEMENT, SIMILAR TO TSO VERIFY.) */
1     IF ^OPT.CHANGE
         THEN ERRCODE=11023;
0     SCANPTR=SCANPTR+  /* 'CHANGE R'<-SCANPTR */
         VERIFY(SUBSTR(STMT,SCANPTR),' ')-1;
      IF SCANPTR=LENGTH(STMT) /* NO STATEMENT-ID */
         THEN ERRCODE=11019;
      ID_LEN=INDEX(SUBSTR(STMT,SCANPTR),' ')-1;
      IF ID_LEN<=0×ID_LEN>LENGTH(STTYPE)
         THEN ERRCODE=11119;
      ID=SUBSTR(STMT,SCANPTR,ID_LEN);
0     CALL SCNSBST(STMAP);
      IF SUBSTR(ID,1,1)>='0'
         THEN DO;
              ON CONVERSION ONSOURCE='0';
              N=ID;
              REVERT CONVERSION;
              IF N<1×N>STMT_NO
                   THEN ERRCODE=11219;
         END;
         ELSE DO;
              DO N=1 TO STMT_NO WHILE(ID^=STMT_TYPE(N));
              END;
              IF N>STMT_NO
                   THEN ERRCODE=11319;
              DO N2=N+1 TO STMT_NO WHILE(ID^=STMT_TYPE(N2));
              END;
              IF N2<=STMT_NO
                   THEN ERRCODE=11025;
         END;
      P999=N;
0     OLD_STMT=SUBSTR(SBSTMTS,STMT_START(N),
         STMT_START(N+1)-STMT_START(N));
      SCANPTR=SCANPTR+ID_LEN; /* 'CHANGE READ '<-SCANPTR */
1     SCANPTR=SCANPTR+   /* 'CHANGE READ $'<-SCANPTR */
         VERIFY(SUBSTR(STMT,SCANPTR),' ')-1;
      IF SCANPTR=LENGTH(STMT)
         THEN ERRCODE=11026;
      DELIM=SUBSTR(STMT,SCANPTR,1);
0     SCANPTR=SCANPTR+1; /* 'CHANGE READ $O'<-SCANPTR */
      OLD_LENGTH=INDEX(SUBSTR(STMT,SCANPTR),DELIM)-1;
      SELECT;
         WHEN(OLD_LENGTH<0)ERRCODE=11126;
         WHEN(OLD_LENGTH=0)OLD_LOC=LENGTH(OLD_STMT);
         WHEN(OLD_LENGTH>0)DO;
              OLD_LOC=INDEX(OLD_STMT,SUBSTR(STMT,SCANPTR,OLD_LENGTH));
              IF OLD_LOC=0
                   THEN ERRCODE=11021;
              END;
      END;
      SCANPTR=SCANPTR+OLD_LENGTH; /* 'CHANGE READ $OLD$'<-SCANPTR */
0     IF STTYPE='COMPLETE  '
         THEN OLD_LENGTH=LENGTH(OLD_STMT)-OLD_LOC;
-     SCANPTR=SCANPTR+1; /* 'CHANGE READ $OLD$N'<-SCANPTR */
      NEW_LENGTH=INDEX(SUBSTR(STMT,SCANPTR),DELIM)-1;
      IF NEW_LENGTH<0 /* NO CLOSING DELIMITER */
         THEN NEW_LENGTH=LENGTH(STMT)-SCANPTR;
      NEW_STMT=SUBSTR(OLD_STMT,1,OLD_LOC-1)××
         SUBSTR(STMT,SCANPTR,NEW_LENGTH)××
         SUBSTR(OLD_STMT,OLD_LOC+OLD_LENGTH);
      SCANPTR=  /* 'CHANGE READ $OLD$NEW#'<-SCANPTR */
         SCANPTR+NEW_LENGTH;
-     IF SCANPTR<LENGTH(STMT) /* CLOSING DELIMITER PRESENT */
         THEN DO;
              SCANPTR=SCANPTR+1; /* 'CHANGE READ $OLD$NEW$ '<-SCANPTR */
              SCANPTR=SCANPTR+ /* 'CHANGE READ $OLD$NEW$ #'<-SCANPTR */
                 VERIFY(SUBSTR(STMT,SCANPTR),' ')-1;
              IF SCANPTR^=LENGTH(STMT) /* EXTRA TEXT AT END */
                 THEN ERRCODE=11226;
         END;
1 /*  VERIFY THAT STATEMENT WILL FIT AND THAT A READ STATEMENT
  /*     STATEMENT HAS NOT BEEN CHANGED TO A NON-READ, OR VICE-VERSA. */
0     SCANPTR=1;
      IF LENGTH(NEW_STMT)<=5
         THEN NEW_TYPE=CHAR(NEW_STMT,4);
         ELSE NEW_TYPE=SUBSTR(NEW_STMT,1,5);
      IF STMT_TYPE(N)='READ        '&NEW_TYPE^='READ        '×
         STMT_TYPE(N)^='READ        '&NEW_TYPE='READ        '
         THEN ERRCODE=11022;
      IF LENGTH(NEW_STMT)>1200 /* STRINGSIZE */
         THEN ERRCODE=11002;
      NEW_SBSTMTS=SUBSTR(SBSTMTS,1,STMT_START(N)-1)××
         NEW_STMT××
         SUBSTR(SBSTMTS,STMT_START(N+1));
      IF LENGTH(NEW_SBSTMTS)>2000 /* STRINGSIZE */
         THEN ERRCODE=11014;
-     SBSTMTS=NEW_SBSTMTS;
      RETRANSLATE=1B;
      IF STMT_TYPE(N)='READ        '
         THEN RETRANSLATE_READ=1B;
-END CMPCHNG;
