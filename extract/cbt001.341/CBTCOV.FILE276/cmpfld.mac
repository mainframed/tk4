 (CHECK(ERRCODE)):  CMPFLD:  PROCEDURE(STTYPE,STMT,FIELD)REORDER;
 %INCLUDE EXTVAR,EXTVAR2,DCLBCODE,DCLOPER,SYSPRINT;
0%INCLUDE DCLSTMT;
0DECLARE
      FIELD FIXED BINARY(31);
1DECLARE
      (ALLOCATION,BINARY,EMPTY,HBOUND,INDEX,LENGTH,LOW,
      MOD,NULL,SUBSTR,UNSPEC,VERIFY)BUILTIN;
0DECLARE
      I FIXED BINARY,
      FLDISP(15)CHAR(2)STATIC,
      STMT_CODE CHAR(1000)VARYING AUTO INITIAL(''),
      ADDRESSABILITY_CODE CHAR(2),
      RETURN_CODE CHAR(8)STATIC,
      BALR_CODE BIT(16)STATIC
         INITIAL('0000010110010000'B), /* BALR 9,0 */
   01 CHAIN_STACK CONTROLLED,
      02 CHAIN_ENDS(0:1),
         03 (HEAD,TAIL)POINTER INITIAL(NULL),
      02 OPERATOR FIXED BINARY(31),
   01 PRIMARY AUTOMATIC LIKE CHAIN_STACK,
      LINK_AREA AREA(1000),
   01 LINK BASED,
      02 PPREV POINTER,
      02 LOC FIXED BINARY(31);
1/*   CMPFLD COMPILES FIELD STATEMENTS INTO 360 MACHINE CODE.
 /*      CMPFLD IS PASSED A FIELD STATEMENT, THE STATEMENT TYPE,
 /*           AND A TYPE CODE TO BE USED AS AN ARRAY INDEX.
 /*      CMPFLD BUILDS A MACHINE LANGUAGE REPRESENTATION OF
 /*           THE FIELD STATEMENT IN THE STRING STMT_CODE.
 /*           FOLLOWING A SUCCESSFUL COMPILATION, STMT_CODE IS
 /*           CONCATENATED TO OBJCODE, WHICH REPRESENTS ALL THE
 /*           FIELD STATEMENTS OF A SEARCH.
 /*      AS EACH RECORD SATISFYING THE READ STATEMENT IS READ,
 /*           OBJCODE IS USED TO DETERMINE WHETHER THE RECORD
 /*           SATIFIES THE FIELD STATEMENTS.  CONTROL IS PASSED
 /*           TO OBJCODE VIA THE ASSEMBLER ROUTINE TESTOBJ.  THE
 /*           REGISTERS AT ENTRY TO OBJCODE ARE:
 /*
 /*                R10->THE PACKED ERIC RECORD
 /*                R11->LITPOOL
 /*                R14->SUCCESSFUL RETURN TO TESTOBJ
 /*             4(R14)->UNSUCCESSFUL RETURN TO TESTOBJ
 /*
 /*           REGISTERS R0-R5 ARE AVAILABLE TO OBJCODE AS WORK
 /*           REGISTERS.  REGISTER R9 IS AVAILABLE AS A BASE
 /*           REGISTER.  TESTOBJ RETURNS A BIT STRING TO CMPFLD
 /*           INDICATING WHETHER THE RECORD SATISFIED ALL OF
 /*           THE FIELD STATEMENTS.
 /*      FIELD STATEMENTS CONSIST OF SET OPERATORS $AND, $OR,
 /*           AND $SEMI (SIMILAR TO $OR BUT LOWER IN PRIORITY)
 /*           OPERATING ON 'PRIMARY EXPRESSIONS.'  A PRIMARY
 /*           EXPRESSION IS A STRING PRECEDED BY A UNARY PREFIX
 /*           OPERATOR:  CONTAINS ('') AND NOT_CONTAINS ('^')
 /*           TEST WHETHER THE STRING OCCURS SOMEWHERE IN THE
 /*           FIELD.  GREATER_THAN ('>'), NOT_GREATER_THAN ('^>'),
 /*           LESS_THAN ('<'), NOT_LESS_THAN ('^<'), EQUALS ('='),
 /*           AND NOT_EQUALS ('^=') COMPARE THE BEGINNING OF THE
 /*           FIELD WITH THE STRING SPECIFIED:  THE PRIMARY
 /*           EXPRESSION '>ED' IS TRUE IF AND ONLY IF THE FIELD
 /*           IS AT LEAST TWO CHARACTERS LONG AND THE STRING
 /*           CONSISTING OF THE FIRST TWO CHARACTERS OF THE FIELD
 /*           IS GREATER THAN 'ED'.
 /*      CMPFLD CONSTRUCTS CODE FOR PRIMARY OPERATORS AND LATER
 /*           PATCHES THE TRUE AND FALSE EXITS TO AGREE WITH
 /*           THE SET OPERATIONS AND THEIR PRECEDENCE.  WHEN
 /*           A PRIMARY IS LOCATED BY THE ROUTINE SCAN_PRIMARY,
 /*           CONTROL IS PASSED TO A CODE GENERATOR FOR THE PRIMARY
 /*           OPERATOR.  THE CODE GENERATOR WILL BUILD PATCH LISTS
 /*           OF TRUE AND FALSE EXITS AND CONCATENATE CODE
 /*           TO STMT_CODE.  BUILD_PATCH_CHAIN WILL SAVE THE
 /*           LOCATION OF THE PATCH CHAINS IN THE STRUCTURE PRIMARY.
1/*      COMPILATION OF SET OPERATORS IS BASED ON OPERATOR
 /*           PRECEDENCE ($OR>$AND>$SEMI>$#) USING THE STACK
 /*           CHAIN_STACK OF OPERATORS AND THEIR PATCH CHAINS.
 /*           IF THE OPERATOR ON THE TOP OF THE STACK HAS A
 /*           HIGHER PRIORITY THAN THE CURRENT SET OPERATOR
 /*           (CONFUSINGLY CALLED PRIMARY.OPERATOR), ITS PATCH
 /*           CHAINS WILL BE CONCATENATED TO THE CURRENT PATCH
 /*           CHAINS AND THE STACK POPPED.  AFTER ANY CONCATENATION
 /*           IS COMPLETED, THE CURRENT OPERATOR IS EXAMINED.
 /*           IF THE CURRENT OPERATOR IS $AND, THE SUBROUTINE
 /*           PATCH IS CALLED TO PATCH CODE DISPLACEMENTS ON THE
 /*           TRUE CHAIN TO POINT PAST THE END OF STMT_CODE.  THIS
 /*           WILL CAUSE THE SECOND OPERAND OF $AND TO BE TESTED
 /*           IF THE FIRST OPERAND (PRIMARY) IS TRUE.  OR OPERATORS
 /*           AND $# SIMILARLY PATCH THE FALSE CHAIN.
 /*      WHEN THE END OF THE STATEMENT HAS BEEN REACHED, THE
 /*           FALSE PATHS WILL HAVE BEEN PATCHED BY THE $#
 /*           OPERATOR TO POINT PAST STMT_CODE.  A BC 14,4(0,14)
 /*           RETURN TO TESTOBJ IS CONCATENATED TO STMT_CODE TO
 /*           INDICATE THAT THE ERIC RECORD DID NOT SATISFY THIS
 /*           FIELD STATEMENT.  THE REMAINING TRUE CHAIN IS PATCHED
 /*           PAST THIS AND A BC 0,0(0,14) INSTRUCTION ADDED.
 /*           THIS NO-OP WILL PASS CONTROL TO THE NEXT FIELD
 /*           STATEMENT (IF ANY).  THE NO-OP ON THE LAST FIELD
 /*           STATEMENT WILL BE MODIFIED BY EXSRCH TO RETURN TO
 /*           TESTOBJ (BC 15,0(0,14)) INDICATING THAT ALL FIELD
 /*           STATEMENTS WERE SATISFIED.
 /*      AFTER PATCHING, STMT_CODE IS PREFIXED WITH ADDRESSABILITY
 /*           CODE (BALR 9,0) AND CONCATENATED TO OBJCODE. */
1ON STRINGSIZE ERRCODE=07017;
-     CALL INITIALIZE;
      ALLOCATE CHAIN_STACK;
      CHAIN_STACK.OPERATOR=0;CHAIN_STACK.CHAIN_ENDS=NULL;
0     DO WHILE(SCANPTR<=LENGTH(STMT));
         CALL COMPILE_PRIMARY;
0        DO WHILE(CHAIN_STACK.OPERATOR>=PRIMARY.OPERATOR);
              DO I=0,1;
                   IF PRIMARY.HEAD(I)=NULL
                        THEN ERRCODE=07005;
                   IF CHAIN_STACK.HEAD(I)^=NULL /* CHAIN PRESENT */
                        THEN DO; /* CONCATENATE TO PRIMARY CHAIN */
                             PRIMARY.TAIL(I)->PPREV=CHAIN_STACK.HEAD(I);
                             PRIMARY.TAIL(I)=CHAIN_STACK.TAIL(I);
                        END;
              END;
              FREE CHAIN_STACK;
         END;
0        IF PRIMARY.OPERATOR=$AND
              THEN /* PATCH TRUE PATH TO TEST 2ND OPERAND OF AND */
                   CALL PATCH(PRIMARY.CHAIN_ENDS('1'B));
              ELSE /* PATCH FALSE PATH TO TEST 2ND OPERAND OF OR */
                   CALL PATCH(PRIMARY.CHAIN_ENDS('0'B));
0        ALLOCATE CHAIN_STACK;CHAIN_STACK=PRIMARY;
      END;
0     UNSPEC(RETURN_CODE)=BCODE;
      STMT_CODE= /* ADD BC 15,4(0,14) ON FALSE PATH */
           STMT_CODE××SUBSTR(RETURN_CODE,1,4);
0     CALL PATCH(CHAIN_STACK.CHAIN_ENDS('1'B));
      FREE CHAIN_STACK,CHAIN_STACK;
      (STRINGSIZE):  /* ADD BC 0,0(0,14) ON TRUE PATH */
         STMT_CODE=STMT_CODE××SUBSTR(RETURN_CODE,5,4);
      UNSPEC(ADDRESSABILITY_CODE)=BALR_CODE;
      (STRINGSIZE):
         OBJCODE=OBJCODE××ADDRESSABILITY_CODE××STMT_CODE;
1INITIALIZE:  PROCEDURE;
0DECLARE
      (I,DISP)FIXED BINARY(15); /* IMP */
 /*   INITIALIZE IS CALLED TO REINITIALIZE CMPFLD.
 /*      ANY STORAGE WHICH MAY HAVE BEEN LEFT ALLOCATED BY A
 /*           PREVIOUS INVOCATION IS FREED.
 /*      IF EXSRCH HAS CONSTRUCTED DUMMY OBJCODE FOR A SEARCH
 /*           WITHOUT FIELD STATEMENTS, OBJCODE IS CLEARED.
 /*           (CMPFLD IS BEING CALLED TO PROCESS THE FIRST
 /*           FIELD STATEMENT UNDER A READ STATEMENT.)
 /*      IF EXSRCH HAS MODIFIED THE BC 0,0(0,14) INSTRUCTION
 /*           AT THE END OF OBJCODE TO A BC 15,0(0,14), IT IS
 /*           RESET.  (CMPFLD IS BEING CALLED TO PROCESS A
 /*           SECOND OR SUBSEQUENT FIELD STATEMENT.)
 /*      THE PACKED ERIC RECORD INCLUDES A TABLE OF HALFWORD
 /*           OFFSETS OF ERIC FIELDS WITHIN THE RECORD.  THE
 /*           FIRST ENTRY IN THE TABLE IS AT OFFSET 16 (DECIMAL)
 /*           INTO THE RECORD.  FLDISP IS SET TO THE BASE AND
 /*           DISPLACEMENT FORMAT NEEDED TO ACCESS THE TABLE
 /*           OF OFFSETS.  */
0     LINK_AREA=EMPTY;
      DO WHILE(ALLOCATION(CHAIN_STACK)>0);
         FREE CHAIN_STACK;
      END;
0     IF LENGTH(OBJCODE)<=LENGTH(RETURN_CODE) /* NULL OR DUMMY */
         THEN OBJCODE='';
         ELSE SUBSTR(OBJCODE,LENGTH(OBJCODE)-2,1)=LOW(1); /* BC 0 */
0     DO I=1 TO HBOUND(FLDISP,1);
         DISP=I*2+14;
         UNSPEC(FLDISP(I))=UNSPEC(DISP)×'1010000000000000'B;
      END;
0END INITIALIZE;
1PATCH:  PROCEDURE(CHAIN_ENDS);
0DECLARE
   01 CHAIN_ENDS,
      02 (HEAD,TAIL)POINTER;
0DECLARE
      (P,P2)POINTER,
      DISPLACEMENT CHAR(2); /* LENGTH(STMT_CODE)(R9) */
0/*   PATCH MODIFIES THE BASE AND DISPLACEMENT FIELDS OF
 /*      INSTRUCTIONS IN STMT_CODE TO POINT PAST THE END
 /*      OF STMT_CODE.  THE LOCATIONS TO BE CHANGED ARE
 /*      STORED IN A CHAIN POINTED TO BY CHAIN_ENDS. AS
 /*      THE CHAIN IS RUN, THE ELEMENTS OF THE LIST ARE
 /*      FREED. */
0ON STRINGRANGE ERRCODE=07105;
0     UNSPEC(DISPLACEMENT)=
         BINARY(LENGTH(STMT_CODE)+1001000000000000B,16,0);
      IF '0'B /* DEBUG OFF */
         THEN PUT SKIP LIST('PATCH CALLED'); /* TEMP */
      P,P2=CHAIN_ENDS.HEAD;
0     DO WHILE(P^=NULL);
         IF '0'B /* DEBUG OFF */
              THEN PUT SKIP LIST((10)'$',P->LINK.LOC,BINARY(UNSPEC(P)));
         (STRINGRANGE):
              SUBSTR(STMT_CODE,P->LINK.LOC,2)=DISPLACEMENT;
         P2=P;
         P=P->LINK.PPREV;
         FREE P2->LINK IN(LINK_AREA);
      END;
0     IF P2^=CHAIN_ENDS.TAIL
         THEN ERRCODE=07205;
      CHAIN_ENDS=NULL;
 END PATCH;
1COMPILE_PRIMARY:  PROCEDURE;
0DECLARE
      OPERATOR CHAR(2)STATIC,
      OPERAND_DISPLACEMENT CHAR(2)STATIC,
      OPERAND_LENGTH_MINUS_1 CHAR(1)STATIC,
      IMMEDIATE_OPERAND CHAR(1)STATIC;
0     CALL SCAN_PRIMARY;
0     IF '0'B /* DEBUG OFF */
         THEN PUT SKIP LIST((10)'*',OPERATOR);
0     IF OPERATOR='  '×OPERATOR='^ '
         THEN CALL COMPILE_CONTAINS;
         ELSE CALL COMPILE_RELATION;
1SCAN_PRIMARY:  PROCEDURE;
 DECLARE
      (I,L)FIXED BINARY(31),
      VALID_PRIMARY_OPERATORS CHAR(16)STATIC
         INITIAL('  ^ = ^=> ^>< ^<');
0ON STRINGSIZE ERRCODE=07006;
0     L=VERIFY(SUBSTR(STMT,SCANPTR),'=><^')-1;
      IF L>2
         THEN ERRCODE=07007;
0     OPERATOR=SUBSTR(STMT,SCANPTR,L);
      IF MOD(INDEX(VALID_PRIMARY_OPERATORS,OPERATOR)-1,
         LENGTH(OPERATOR))^=0
         THEN ERRCODE=07107;
      SCANPTR=SCANPTR+L;
0     L=VERIFY(SUBSTR(STMT,SCANPTR),
         'ABCDEFGHIJKLMNOPQRSTUVWXYZ*0123456789 -.,''')-1;
      IF L=0
         THEN ERRCODE=07008;
      IF L>255
         THEN ERRCODE=07009;
      UNSPEC(OPERAND_LENGTH_MINUS_1)=BINARY(L-1,8,0);
0     I=INDEX(LITPOOL,SUBSTR(STMT,SCANPTR,L))-1;
      IF I<0
         THEN DO;
              I=LENGTH(LITPOOL);
              (STRINGSIZE):  LITPOOL=LITPOOL××SUBSTR(STMT,SCANPTR,L);
         END;
0     IMMEDIATE_OPERAND=SUBSTR(STMT,SCANPTR,1);
0     UNSPEC(OPERAND_DISPLACEMENT)=BINARY(I+1011000000000000B,16,0);
         /* I(R11) */
      SCANPTR=SCANPTR+L;
0     PRIMARY.OPERATOR=INDEX(SCNDOPS,SUBSTR(STMT,SCANPTR,1));
      IF PRIMARY.OPERATOR=0
         THEN ERRCODE=07010;
      SCANPTR=SCANPTR+1;
0END SCAN_PRIMARY;
1BUILD_PATCH_CHAIN:  PROCEDURE(CHAIN_ENDS,PATCH_LOCATIONS);
0DECLARE
   01 CHAIN_ENDS,
      02 (HEAD,TAIL)POINTER,
      PATCH_LOCATIONS(*)FIXED BINARY,
      (P,P2)POINTER,
      I FIXED BINARY(31);
0/*   BUILD_PATCH_CHAIN CONVERTS AN ARRAY OF PATCH LOCATIONS
 /*      INTO A LIST.  THE PATCH LOCATIONS ARE ADJUSTED TO
 /*      THE CURRENT LENGTH OF STMT_CODE.  BUILD_PATCH_CHAIN
 /*      SHOULD THUS BE CALLED BEFORE THE NEW CODE IS ADDED
 /*      TO STMT_CODE.  CHAIN_ENDS IS SET TO THE HEAD AND
 /*      TAIL OF THE LIST. */
0     ALLOCATE LINK IN(LINK_AREA)SET(P);
      CHAIN_ENDS.TAIL=P;
      P->LINK.PPREV=NULL;
      P->LINK.LOC=PATCH_LOCATIONS(1)+LENGTH(STMT_CODE);
      DO I=2 TO HBOUND(PATCH_LOCATIONS,1);
         P2=P;
         ALLOCATE LINK SET(P);
         P->LINK.PPREV=P2;
         P->LINK.LOC=PATCH_LOCATIONS(I)+LENGTH(STMT_CODE);
      END;
      CHAIN_ENDS.HEAD=P;
0END BUILD_PATCH_CHAIN;
1COMPILE_CONTAINS:  PROCEDURE;
0DECLARE
      CODE CHAR(54),
      (FALSE_EXITS(2)INITIAL(19,53),
      TRUE_EXITS(1)INITIAL(43))FIXED BINARY STATIC;
0/* THE CONTAINS CODE IS LISTED BELOW.
 THE FALSE/TRUE EXITS ARE REVERSED FOR NOT CONTAINS.
0000     LH    2,FLDISP_(I+1)(10) LOAD OFFSET OF FIELD END
0032     LH    5,FLDISP_(I)(10)   LOAD OFFSET OF FIELD
0064     SR    2,5                CALCULATE FIELD LENGTH
0080     LA    0,OPERAND_LENGTH-1 LOAD OP LENGTH-1 FOR SUBTRACT
0112     SR    2,0                CALCULATE NUMBER OF COMPARISONS      X
                                  NEEDED TO TEST FOR CONTAINS
0128     BNP   FALSE              FALSE EXIT--CHAR OFFSET 19           X
                                  TAKEN IF RECORD FIELD TOO SHORT
0160     LA    5,0(5,10)          LOAD ADDRESS OF FIELD
0192     BALR  4,0                SET BRANCH REGISTER
0208     CLI   0(5),SUBSTR(OPERAND,1,1) TEST FIRST BYTE FOR EQUALITY
0240     BNE   X'12'(4)           SKIP COMPARISON FOR FULL LENGTH IF   X
                                  FIRST BYTES DO NOT MATCH
0272     CLC   0(OPERAND_LENGTH,5),OPERAND_DISPLACEMENT(11)            X
                                  COMPARE ENTIRE FIELD FOR CONTAINMENT
0320     BE    TRUE               TRUE EXIT--CHAR OFFSET 43
0352     LA    5,1(0,5)           BUMP RECORD FIELD POINTER
0384     BCTR  2,4                REPEAT TEST ON ADJACENT SUBSTR
0400     B     FALSE              FALSE EXIT--CHAR OFFSET 53
                                  TAKEN IF NO SUBSTR MATCHES
0432     EQU   *                  */
1        UNSPEC(CODE)=
 /* LH   */ '01001000001000001010111111111111'B××
 /* LH   */ '01001000010100001010111111111111'B××
 /* SR   */ '0001101100100101'B××
 /* LA   */ '01000001000000000000000011111111'B××
 /* SR   */ '0001101100100000'B××
 /* BNP  */ '01000111110100001001111111111111'B××
 /* LA   */ '01000001010101011010000000000000'B××
 /* BALR */ '0000010101000000'B××
 /* CLI  */ '10010101111111110101000000000000'B××
 /* BNE  */ '01000111011100000100000000010010'B××
 /* CLC  */ '110101011111111101010000000000001011111111111111'B××
 /* BE   */ '01000111100000001001111111111111'B××
 /* LA   */ '01000001010100000101000000000001'B××
 /* BCTR */ '0000011000100100'B××
 /* B    */ '01000111111100001001111111111111'B;
0     SUBSTR(CODE,3,2)=FLDISP(FIELD+1);
      SUBSTR(CODE,7,2)=FLDISP(FIELD);
      SUBSTR(CODE,14,1)=OPERAND_LENGTH_MINUS_1;
      SUBSTR(CODE,28,1)=IMMEDIATE_OPERAND;
      SUBSTR(CODE,36,1)=OPERAND_LENGTH_MINUS_1;
      SUBSTR(CODE,39,2)=OPERAND_DISPLACEMENT;
0     IF SUBSTR(OPERATOR,1,1)^='^'
         THEN DO;
              CALL BUILD_PATCH_CHAIN(PRIMARY.CHAIN_ENDS(0),FALSE_EXITS);
              CALL BUILD_PATCH_CHAIN(PRIMARY.CHAIN_ENDS(1),TRUE_EXITS);
         END;
         ELSE DO;
              CALL BUILD_PATCH_CHAIN(PRIMARY.CHAIN_ENDS(0),TRUE_EXITS);
              CALL BUILD_PATCH_CHAIN(PRIMARY.CHAIN_ENDS(1),FALSE_EXITS);
         END;
0     (STRINGSIZE):  STMT_CODE=STMT_CODE××CODE;
0END COMPILE_CONTAINS;
1COMPILE_RELATION:  PROCEDURE;
0DECLARE
      CODE CHAR(38),
      MASK CHAR(1),
      (FALSE_EXITS(2)INITIAL(19,33),
      TRUE_EXITS(1)INITIAL(37))FIXED BINARY STATIC;
0/* THE EQ/LT/GT CODE IS LISTED BELOW.
 THE FALSE/TRUE EXITS ARE REVERSED FOR NOT EQ/LT/GT.

0000     LH    2,FLDISP_(I+1)(10) LOAD OFFSET OF FIELD END
0032     LH    5,FLDISP_(I)(10)   LOAD OFFSET OF FIELD
0064     SR    2,5                CALCULATE FIELD LENGTH
0080     LA    0,OPERAND_LENGTH   LOAD OP LENGTH FOR COMPARE
0112     CR    2,0                COMPARE FIELD AND OPERAND LENGTHS
0128     BNH   FALSE              FALSE EXIT--CHAR OFFSET 19
0160     LA    5,0(5,10)          LOAD ADDRESS OF FIELD
0192     CLC   0(OPERAND_LENGTH,5),OPERAND_DISPLACEMENT(11)            X
                                  COMPARE FIELD AND OPERAND
0240     BC    15-MASK,FALSE      FALSE EXIT--CHAR OFFSET 33
0272     B     TRUE               TRUE EXIT--CHAR OFFSET 37
0304     EQU   *                  */
1     SELECT(OPERATOR);
         WHEN('= ','^=')UNSPEC(MASK)='10000000'B;
         WHEN('< ','^<')UNSPEC(MASK)='01000000'B;
         WHEN('> ','^>')UNSPEC(MASK)='00100000'B;
      END;
      UNSPEC(MASK)=^UNSPEC(MASK)&'11110000'B;
-     UNSPEC(CODE)=
 /* LH  */ '01001000001000001010111111111111'B××
 /* LH  */ '01001000010100001010111111111111'B××
 /* SR  */ '0001101100100101'B××
 /* LA  */ '01000001000000000000000011111111'B××
 /* CR  */ '0001100100100000'B××
 /* BNH */ '01000111110100001001111111111111'B××
 /* LA  */ '01000001010101011010000000000000'B××
 /* CLC */ '110101011111111101010000000000001011111111111111'B××
 /* BC  */ '01000111110100001001111111111111'B××
 /* B   */ '01000111111100001001111111111111'B;
0     SUBSTR(CODE,3,2)=FLDISP(FIELD+1);
      SUBSTR(CODE,7,2)=FLDISP(FIELD);
      SUBSTR(CODE,14,1)=OPERAND_LENGTH_MINUS_1;
      SUBSTR(CODE,26,1)=OPERAND_LENGTH_MINUS_1;
      SUBSTR(CODE,29,2)=OPERAND_DISPLACEMENT;
      SUBSTR(CODE,32,1)=MASK;
0     IF SUBSTR(OPERATOR,1,1)^='^'
         THEN DO;
              CALL BUILD_PATCH_CHAIN(PRIMARY.CHAIN_ENDS(0),FALSE_EXITS);
              CALL BUILD_PATCH_CHAIN(PRIMARY.CHAIN_ENDS(1),TRUE_EXITS);
         END;
         ELSE DO;
              CALL BUILD_PATCH_CHAIN(PRIMARY.CHAIN_ENDS(0),TRUE_EXITS);
              CALL BUILD_PATCH_CHAIN(PRIMARY.CHAIN_ENDS(1),FALSE_EXITS);
         END;
0     (STRINGSIZE):  STMT_CODE=STMT_CODE××CODE;
0END COMPILE_RELATION;
0END COMPILE_PRIMARY;
0END CMPFLD;
