./ ADD NAME=ANTIFIND 0111-82173-82173-1632-00001-00027-00001-JS02150
OPTION RESTORE ANTIFIND
./ ADD NAME=DIAL21   0101-80179-80183-0824-00001-00002-00001-JS02150
DUMMY
./ ADD NAME=DIAL22   0101-80179-80183-0825-00001-00002-00001-JS02150
DUMMY
./ ADD NAME=DIAL26   0101-80175-80183-0824-00001-00002-00001-JS02150
DUMMY
./ ADD NAME=DIAL7    0100-80183-80183-0825-00001-00001-00000-JS02150
DUMMY
./ ADD NAME=DLFR901A 0100-84061-84061-1121-00001-00001-00000-JS02150
 VERIFY FILE(VRFY1)
./ ADD NAME=DLFR901B 0100-84061-84061-1122-00001-00001-00000-JS02150
 VERIFY FILE(VRFY2)
./ ADD NAME=DLFR904  0100-84061-84061-1345-00008-00008-00000-JS02150
C          00080
FA
FJ             R
D     3  A1                   EQ3  V.IM                 REJ
D     3  A1                   EQ3  VX'4B8994'           REJ
D     3  A1                   EQ3  VX'4BC994'           REJ
D     3  A1                   EQ3  VX'4B89D4'           REJ
D     80 A1                     80 R1                   OUTOUT
./ ADD NAME=DLFR905  0101-84061-84069-1059-00002-00002-00000-JS02150
   AUTH 1
   SCRIPT FROM(INGO) (FILE(FRMTOUT)) TWOPASS
./ ADD NAME=DYLEXT   0104-83126-84047-1556-00039-00037-00000-GD02150
$DEFAULT #0=NULL #1=NULL #2=NULL #3=NULL #4=HOLDREC #5=NULL #6=NULL
 #7=NULL #8=NULL #9=NULL #A=NULL #B=NULL #C=NULL    #D=NULL #E=NULL
 #F=NULL #G=NULL #H=NULL #I=NULL #J=NULL #K=NULL    #L=NULL #M=NULL
 #N=NULL #O=NULL #P=NULL #Q=NULL #R=NULL #S=NULL    #T=NULL #U=NULL
 #V=NULL #W=NULL #X=NULL
$DEND
PICNSAVE #3 USING
   #4
   #5
   #6
   #7
   #8
   #9
   #A
   #B
   #C
   #D
   #E
   #F
   #G
   #H
   #I
   #J
   #K
   #L
   #M
   #N
   #O
   #P
   #Q
   #R
   #S
   #T
   #U
   #V
   #W
   #X
   BY 10
   ENDIF
./ ADD NAME=DYLLISTC 0111-83237-83241-1646-00098-00092-00000-GD02150
OPTION STRUCTURED
FILE DUMMFILE DUMMY
FILE LISTFILE VB LENGTH LISTLEN STATUS INEOF
   COLUMN1TAG  9   9
   RECTOTAL   12  21
   COLUMN2TAG 12  38
   HURBA      12  50
   COLUMN4TAG  6  96
   CISIZE      5 115
   CIPERCA     5 115
   INXLEVELS   5 115
WORKAREA
   CISIZFND    3     VALUE 'NO '
   CICAFND     3     VALUE 'NO '
   HURBAFND    3     VALUE 'NO '
   RECTOFND    3     VALUE 'NO '
WORKAREA
   VDEFINE     7     VALUE 'VDEFINE'
   VPUT        4     VALUE 'VPUT'
   VARNAME    10     VALUE ' '
   CHAR        4     VALUE 'CHAR'
   LEN         4  BI VALUE 0
WORKAREA
   WKRECTOT   12
   WKHURBA    12
   WKCISIZE    5
   WKCIPERCA   5
   WKINXLVL    5
ON ONE
   READ LISTFILE
   MOVE '(LCISIZE)' TO VARNAME
   MOVE 5 TO LEN
   CALL ISPLINK USING VDEFINE VARNAME WKCISIZE CHAR LEN
   MOVE '(LRECTOT)' TO VARNAME
   MOVE 12 TO LEN
   CALL ISPLINK USING VDEFINE VARNAME WKRECTOT CHAR LEN
   MOVE '(LHURBA)' TO VARNAME
   CALL ISPLINK USING VDEFINE VARNAME WKHURBA CHAR LEN
   MOVE '(LINXLVL)' TO VARNAME
   MOVE 5 TO LEN
   CALL ISPLINK USING VDEFINE VARNAME WKINXLVL CHAR LEN
   MOVE '(LCIPERCA)' TO VARNAME
   CALL ISPLINK USING VDEFINE VARNAME WKCIPERCA CHAR LEN
ENDONE
DOWHILE INEOF NE 'E'
   IF LISTLEN GT 118
      PERFORM CHECKMISC TO ENDMISC
      ENDIF
   IF LISTLEN GT 60
      PERFORM CHECKHURB TO ENDHURB
      ENDIF
   IF LISTLEN GT 31
      PERFORM CHECKREC  TO ENDREC
      ENDIF
   READ LISTFILE
   ENDDO
MOVE '(LCISIZE)' TO VARNAME
CALL ISPLINK USING VPUT VARNAME
MOVE '(LCIPERCA)' TO VARNAME
CALL ISPLINK USING VPUT VARNAME
MOVE '(LINXLVL)' TO VARNAME
CALL ISPLINK USING VPUT VARNAME
MOVE '(LRECTOT)' TO VARNAME
CALL ISPLINK USING VPUT VARNAME
MOVE '(LHURBA)' TO VARNAME
CALL ISPLINK USING VPUT VARNAME
STOP
CHECKMISC:
   IF COLUMN4TAG EQ 'CISIZE'
      AND CISIZFND EQ 'NO '
      MOVE CISIZE TO WKCISIZE
      MOVE 'YES' TO CISIZFND
      ENDIF
   IF COLUMN4TAG EQ 'CI/CA-'
      AND CICAFND EQ 'NO '
      MOVE CIPERCA TO WKCIPERCA
      MOVE 'YES' TO CICAFND
      ENDIF
   IF COLUMN4TAG EQ 'LEVELS'
      MOVE INXLEVELS TO WKINXLVL
      ENDIF
ENDMISC:
CHECKHURB:
   IF COLUMN2TAG EQ 'HI-USED-RBA-'
      AND HURBAFND EQ 'NO '
      MOVE HURBA TO WKHURBA
      MOVE 'YES' TO HURBAFND
      ENDIF
ENDHURB:
CHECKREC:
   IF COLUMN1TAG EQ 'REC-TOTAL'
      IF RECTOFND EQ 'YES'
         MOVE RECTOTAL TO WKRECTOT
      ELSE
         MOVE 'YES' TO RECTOFND
         ENDIF
      ENDIF
ENDREC:
./ ADD NAME=DYLPRT   0106-83123-84055-0845-00008-00009-00000-GD02150
$DEFAULT #2=NULL
$DEND
$IF #2
IF INCOUNT GT #2
   STOP
   ENDIF
$IFE
#1 #0
./ ADD NAME=DYLSEL   0110-83126-84062-1418-00041-00036-00000-GD02150
$DEFAULT #0=1    #1=EQ   #2=1    #3=NULL #4=NULL #5=NULL #6=NULL
 #7=NULL #8=NULL #9=NULL #A=NULL #B=NULL #C=NULL #D=NULL #E=NULL
 #F=NULL #G=NULL #H=NULL #I=NULL #J=NULL #K=NULL #L=NULL #M=NULL
 #N=NULL #O=NULL #P=NULL #Q=NULL #R=NULL #S=NULL #T=NULL #U=NULL
 #V=NULL #W=NULL
$DEND
IF #0
   #1
   #2
   #3
   #4
   #5
   #6
   #7
   #8
   #9
   #A
   #B
   #C
   #D
   #E
   #F
   #G
   #H
   #I
   #J
   #K
   #L
   #M
   #N
   #O
   #P
   #Q
   #R
   #S
   #T
   #U
   #V
   #W
 NEXT
 ELSE REJECT ENDIF
./ ADD NAME=DYLSPR1  0104-83132-83161-1049-00052-00127-00000-GD02150
$DEFAULT  #0=NULL #1=NULL #2=NULL #3=NULL #4=NULL #5=NULL #6=NULL
 #7=TOTAL #8=NULL #9=NULL #A=NULL #B=NULL #C=NULL #D=NULL #E=NULL
 #F=NULL  #G=NULL #H=NULL #I=NULL #J=NULL #K=NULL #L=NULL #M=NULL
 #N=NULL  #O=NULL #P=NULL #Q=NULL #R=NULL #S=NULL #T=NULL #U=NULL
 #V=NULL  #W=NULL #X=NULL
$DEND
WORKAREA
   LINETOT 7 PD 2 E (#7) VALUE 0 REINIT
$IF #0
SORT #6 USING
   #5
   #4
   #3
   #2
   #1
   #0
CONTROL
   #0
   #1
   #2
   #3
   #4
   #5
$IFE
PERFORM TOTALIT TO ENDTOT
LIST #8
#9
#A
#B
#C
#D
#E
#F
#G
#H
#I
#J
#K
#L
#M
#N
#O
#P
#Q
#R
#S
#T
#U
#V
#W
#X
LINETOT
./ ADD NAME=DYLSPR2  0104-83132-84055-0846-00270-00127-00000-GD02150
$DEFAULT #0=NULL #1=NULL #2=NULL #3=NULL #4=NULL #5=NULL #6=NULL
 #7=NULL #8=NULL #9=NULL #A=NULL #B=NULL #C=NULL #D=NULL #E=NULL
 #F=NULL #G=NULL #H=NULL #I=NULL #J=NULL #K=NULL #L=NULL #M=NULL
 #N=NULL #O=NULL #P=NULL #Q=NULL #R=NULL #S=NULL #T=NULL #U=NULL
 #V=NULL #W=NULL #X=NULL
$DEND
TOTALIT:
LINETOT = LINETOT
$IF #8
   + #8
$IFE
$IF #9
   + #9
$IFE
$IF #A
   + #A
$IFE
$IF #B
   + #B
$IFE
$IF #C
   + #C
$IFE
$IF #D
   + #D
$IFE
$IF #E
   + #E
$IFE
$IF #F
   + #F
$IFE
$IF #G
   + #G
$IFE
$IF #H
   + #H
$IFE
$IF #I
   + #I
$IFE
$IF #J
   + #J
$IFE
$IF #K
   + #K
$IFE
$IF #L
   + #L
$IFE
$IF #M
   + #M
$IFE
$IF #N
   + #N
$IFE
$IF #O
   + #O
$IFE
$IF #P
   + #P
$IFE
$IF #Q
   + #Q
$IFE
$IF #R
   + #R
$IFE
$IF #S
   + #S
$IFE
$IF #T
   + #T
$IFE
$IF #U
   + #U
$IFE
$IF #V
   + #V
$IFE
$IF #W
   + #W
$IFE
$IF #X
   + #X
$IFE
ENDTOT:
$IF #0
ON CHANGE #0
   LIST SUM(#8
   #9
   #A
   #B
   #C
   #D
   #E
   #F
   #G
   #H
   #I
   #J
   #K
   #L
   #M
   #N
   #O
   #P
   #Q
   #R
   #S
   #T
   #U
   #V
   #W
   #X
   LINETOT)
$IFE
$IF #1
ON CHANGE #1
   LIST SUM(#8
   #9
   #A
   #B
   #C
   #D
   #E
   #F
   #G
   #H
   #I
   #J
   #K
   #L
   #M
   #N
   #O
   #P
   #Q
   #R
   #S
   #T
   #U
   #V
   #W
   #X
   LINETOT)
$IFE
$IF #2
ON CHANGE #2
   LIST SUM(#8
   #9
   #A
   #B
   #C
   #D
   #E
   #F
   #G
   #H
   #I
   #J
   #K
   #L
   #M
   #N
   #O
   #P
   #Q
   #R
   #S
   #T
   #U
   #V
   #W
   #X
   LINETOT)
$IFE
$IF #3
ON CHANGE #3
   LIST SUM(#8
   #9
   #A
   #B
   #C
   #D
   #E
   #F
   #G
   #H
   #I
   #J
   #K
   #L
   #M
   #N
   #O
   #P
   #Q
   #R
   #S
   #T
   #U
   #V
   #W
   #X
   LINETOT)
$IFE
$IF #4
ON CHANGE #4
   LIST SUM(#8
   #9
   #A
   #B
   #C
   #D
   #E
   #F
   #G
   #H
   #I
   #J
   #K
   #L
   #M
   #N
   #O
   #P
   #Q
   #R
   #S
   #T
   #U
   #V
   #W
   #X
   LINETOT)
$IFE
$IF #5
ON CHANGE #5
   LIST SUM(#8
   #9
   #A
   #B
   #C
   #D
   #E
   #F
   #G
   #H
   #I
   #J
   #K
   #L
   #M
   #N
   #O
   #P
   #Q
   #R
   #S
   #T
   #U
   #V
   #W
   #X
   LINETOT)
$IFE
T1 '#6' WITH 4 AFTER
T1+2 DYLDATE
T1+120 DYLPAGE
./ ADD NAME=DYLSRT   0106-83125-84062-1418-00019-00043-00000-GD02150
$DEFAULT #1=NULL #2=NULL #3=NULL #4=NULL #5=NULL #6=NULL #7=NULL
 #8=NULL #9=NULL #A=NULL #B=NULL #C=NULL #D=NULL #E=NULL #F=NULL
$DEND
SORT #0 USING
   #1
   #2
   #3
   #4
   #5
   #6
   #7
   #8
   #9
   #A
   #B
   #C
   #D
   #E
   #F
./ ADD NAME=DYLSTD1  0110-83130-84059-1310-00052-00047-00000-GD02150
$DEFAULT #0=NULL #1=NULL #2=NULL #3=NULL #4=NULL #5=NULL #6=NULL
 #7=NULL #8=NULL #9=NULL #A=NULL #B=NULL #C=NULL #D=NULL #E=NULL
 #F=NULL #G=NULL #H=NULL #I=NULL #J=NULL #K=NULL #L=NULL #M=NULL
 #N=NULL #O=NULL #P=NULL #Q=NULL #R=NULL #S=NULL #T=NULL #U=NULL
 #V=NULL #W=NULL #X=NULL
$DEND
WORKAREA
   COLHOLDER 15 ( ) VALUE ' '
$IF #0
SORT #6 USING
   #5
   #4
   #3
   #2
   #1
   #0
CONTROL
   #0
   #1
   #2
   #3
   #4
   #5
$IFE
LIST #7
   #8
   #9
   #A
   #B
   #C
   #D
   #E
   #F
   #G
   #H
   #I
   #J
   #K
   #L
   #M
   #N
   #O
   #P
   #Q
   #R
   #S
   #T
   #U
   #V
   #W
   #X
   COLHOLDER
./ ADD NAME=DYLSTD2  0108-83130-84059-0928-00224-00207-00000-GD02150
$DEFAULT #0=NULL #1=NULL #2=NULL #3=NULL #4=NULL #5=NULL #6=NULL
 #7=NULL #8=NULL #9=NULL #A=NULL #B=NULL #C=NULL #D=NULL #E=NULL
 #F=NULL #G=NULL #H=NULL #I=NULL #J=NULL #K=NULL #L=NULL #M=NULL
 #N=NULL #O=NULL #P=NULL #Q=NULL #R=NULL #S=NULL #T=NULL #U=NULL
 #V=NULL #W=NULL #X=NULL
$DEND
$IF #0
ON CHANGE #0
   LIST SUM (#7
   #8
   #9
   #A
   #B
   #C
   #D
   #E
   #F
   #G
   #H
   #I
   #J
   #K
   #L
   #M
   #N
   #O
   #P
   #Q
   #R
   #S
   #T
   #U
   #V
   #W
   #X)
   'BREAK 1 TOTAL' AT COLHOLDER
$IFE
$IF #1
ON CHANGE #1
   LIST SUM (#7
   #8
   #9
   #A
   #B
   #C
   #D
   #E
   #F
   #G
   #H
   #I
   #J
   #K
   #L
   #M
   #N
   #O
   #P
   #Q
   #R
   #S
   #T
   #U
   #V
   #W
   #X)
   'BREAK 2 TOTAL' AT COLHOLDER
$IFE
$IF #2
ON CHANGE #2
   LIST SUM (#7
   #8
   #9
   #A
   #B
   #C
   #D
   #E
   #F
   #G
   #H
   #I
   #J
   #K
   #L
   #M
   #N
   #O
   #P
   #Q
   #R
   #S
   #T
   #U
   #V
   #W
   #X)
   'BREAK 3 TOTAL' AT COLHOLDER
$IFE
$IF #3
ON CHANGE #3
   LIST SUM (#7
   #8
   #9
   #A
   #B
   #C
   #D
   #E
   #F
   #G
   #H
   #I
   #J
   #K
   #L
   #M
   #N
   #O
   #P
   #Q
   #R
   #S
   #T
   #U
   #V
   #W
   #X)
   'BREAK 4 TOTAL' AT COLHOLDER
$IFE
$IF #4
ON CHANGE #4
   LIST SUM (#7
   #8
   #9
   #A
   #B
   #C
   #D
   #E
   #F
   #G
   #H
   #I
   #J
   #K
   #L
   #M
   #N
   #O
   #P
   #Q
   #R
   #S
   #T
   #U
   #V
   #W
   #X)
   'BREAK 5 TOTAL' AT COLHOLDER
$IFE
$IF #5
ON CHANGE #5
   LIST SUM (#7
   #8
   #9
   #A
   #B
   #C
   #D
   #E
   #F
   #G
   #H
   #I
   #J
   #K
   #L
   #M
   #N
   #O
   #P
   #Q
   #R
   #S
   #T
   #U
   #V
   #W
   #X)
   'BREAK 6 TOTAL' AT COLHOLDER
$IFE
ON FINAL
   LIST SUM (#7
   #8
   #9
   #A
   #B
   #C
   #D
   #E
   #F
   #G
   #H
   #I
   #J
   #K
   #L
   #M
   #N
   #O
   #P
   #Q
   #R
   #S
   #T
   #U
   #V
   #W
   #X)
   'FINAL TOTAL' AT COLHOLDER
T1 '#6' WITH 4 AFTER
T1+2 DYLDATE
T1+120 DYLPAGE
./ ADD NAME=DYLSUM1  0106-83132-84031-1524-00052-00020-00000-GD02150
$DEFAULT #0=NULL #1=NULL #2=NULL #3=NULL #4=NULL #5=NULL #6=NULL
 #7=NULL #8=NULL #9=NULL #A=NULL #B=NULL #C=NULL #D=NULL #E=NULL
 #F=NULL #G=NULL #H=NULL #I=NULL #J=NULL #K=NULL #L=NULL #M=NULL
 #N=NULL #O=NULL #P=NULL #Q=NULL #R=NULL #S=NULL #T=NULL #U=NULL
 #V=NULL #W=NULL #X=NULL
$DEND
WORKAREA
   BRKNAME 13 ( ) VALUE 'BREAK 1 TOTAL'
$IF #0
SORT #6 USING
   #5
   #4
   #3
   #2
   #1
   #0
CONTROL
   #0
   #1
   #2
   #3
   #4
   #5
$IFE
ON CHANGE #0
   LIST #8
   #9
   #A
   #B
   #C
   #D
   #E
   #F
   #G
   #H
   #I
   #J
   #K
   #L
   #M
   #N
   #O
   #P
   #Q
   #R
   #S
   #T
   #U
   #V
   #W
   #X
   BRKNAME
./ ADD NAME=DYLSUM2  0106-83132-84055-0849-00192-00217-00000-GD02150
$DEFAULT #0=NULL #1=NULL #2=NULL #3=NULL #4=NULL #5=NULL #6=NULL
 #7=NULL #8=NULL #9=NULL #A=NULL #B=NULL #C=NULL #D=NULL #E=NULL
 #F=NULL #G=NULL #H=NULL #I=NULL #J=NULL #K=NULL #L=NULL #M=NULL
 #N=NULL #O=NULL #P=NULL #Q=NULL #R=NULL #S=NULL #T=NULL #U=NULL
 #V=NULL #W=NULL #X=NULL
$DEND
$IF #1
ON CHANGE #1
   LIST SUM (#8
   #9
   #A
   #B
   #C
   #D
   #E
   #F
   #G
   #H
   #I
   #J
   #K
   #L
   #M
   #N
   #O
   #P
   #Q
   #R
   #S
   #T
   #U
   #V
   #W
   #X)
   'BREAK 2 TOTAL' AT BRKNAME
$IFE
$IF #2
ON CHANGE #2
   LIST SUM (#7
   #8
   #9
   #A
   #B
   #C
   #D
   #E
   #F
   #G
   #H
   #I
   #J
   #K
   #L
   #M
   #N
   #O
   #P
   #Q
   #R
   #S
   #T
   #U
   #V
   #W
   #X)
   'BREAK 3 TOTAL' AT BRKNAME
$IFE
$IF #3
ON CHANGE #3
   LIST SUM (#7
   #8
   #9
   #A
   #B
   #C
   #D
   #E
   #F
   #G
   #H
   #I
   #J
   #K
   #L
   #M
   #N
   #O
   #P
   #Q
   #R
   #S
   #T
   #U
   #V
   #W
   #X)
   'BREAK 4 TOTAL' AT BRKNAME
$IFE
$IF #4
ON CHANGE #4
   LIST SUM (#7
   #8
   #9
   #A
   #B
   #C
   #D
   #E
   #F
   #G
   #H
   #I
   #J
   #K
   #L
   #M
   #N
   #O
   #P
   #Q
   #R
   #S
   #T
   #U
   #V
   #W
   #X)
   'BREAK 5 TOTAL' AT BRKNAME
$IFE
$IF #5
ON CHANGE #5
   LIST SUM (#7
   #8
   #9
   #A
   #B
   #C
   #D
   #E
   #F
   #G
   #H
   #I
   #J
   #K
   #L
   #M
   #N
   #O
   #P
   #Q
   #R
   #S
   #T
   #U
   #V
   #W
   #X)
   'BREAK 6 TOTAL' AT BRKNAME
$IFE
ON FINAL
   LIST SUM (#7
   #8
   #9
   #A
   #B
   #C
   #D
   #E
   #F
   #G
   #H
   #I
   #J
   #K
   #L
   #M
   #N
   #O
   #P
   #Q
   #R
   #S
   #T
   #U
   #V
   #W
   #X)
   'FINAL TOTAL' AT BRKNAME
T1 '#6' WITH 4 AFTER
T1+2 DYLDATE
T1+120 DYLPAGE
./ ADD NAME=DYLVER   0110-83297-84131-1147-00054-00005-00000-GD02150
OPTION STRUCTURED
FILE IN01 STATUS INEOF
   INLEFT  80  2
   ERRMSG   5  2
   COPYMSG  6  6
   INRIGHT 80 12
   COMMENT  1 12
   HDRREC   7 12
   CROSSREF 9 13
   INREST  52 81
FILE OUT01 OUTPUT FROM OUT01 FB 80
  OUTREC 80
   OUTERR   5  1
   OUTREST 75  6
READ IN01
DOWHILE COPYMSG EQ 'COPIED' AND INEOF NE 'E'
   READ IN01
   ENDDO
IF CROSSREF EQ 'C R O S S'
   STOP
   ENDIF
ON ONE
  DOUNTIL COMMENT EQ '*' OR INEOF EQ 'E'
     READ IN01
     ENDDO
  ENDONE
IF HDRREC EQ 'DYLAKOR'
   READ IN01
   IF CROSSREF EQ 'C R O S S'
      STOP
      ENDIF
   READ IN01
   ENDIF
IF INLEFT EQ BLANK
   IF DYLCOUNT1 GT 1
      DOWHILE INLEFT EQ BLANK AND INEOF NE 'E'
         READ IN01
         ENDDO
      DYLCOUNT1 = 0
   ELSE
      DYLCOUNT1 = DYLCOUNT1 + 1
      ENDIF
   ENDIF
IF ERRMSG EQ 'ERROR'
   MOVE INLEFT TO OUTREC
   WRITE OUT01
   MOVE SPACE TO OUTREC
   MOVE ERRMSG TO OUTERR
   MOVE INREST TO OUTREST
   WRITE OUT01
ELSE
   MOVE INRIGHT TO OUTREC
   WRITE OUT01
   ENDIF
./ ADD NAME=D04TEXT  0105-84079-84089-1414-00594-00378-00000-GD02150
               IBM OS Cobol interactive debug reference summary

                 Notation conventions for TESTCOB subcommands

 1. The symbols below are used to define subcommand format. With the exc
 of the hyphen, which may be used as a continuation character under TSO,
 symbols should not be typed at the terminal.

          NAME                  SYMBOL                 MEANING

       hyphen                     -            joins lower case
                                               letters, words, and
                                               symbols to form a single
                                               variable

       underscore               ______         indicates a default
                                               option, one you need not
                                               type if it is the one
                                               you want

       slash                      //           group related items: you
                                               MAY choose one of the
                                               items between slashes

       exclamation point         !!            group related items: you
                                               MUST choose one of the
                                               items between exclamation
                                               marks

       ellipsis                   ...          indicates that the
                                               preceding item or group
                                               of items can be repeated
                                               one or more times in
                                               succession if you want

 2. Upper case letters, numbers, and symbols other than the ones above m
 typed exactly as they appear in the format.

 3. Lower case letters represent variable information that is supplied b
 user.
1




                 Notation conventions for TESTCOB subcommands

                                 (continued)

 4. The following terms have special meanings in subcommand formats:

    * addr         is a COBOL index-name, a COBOL data-name, or a COBOL
                   special register
    * expression   is a relationship expressed in this format:

                   addr-1  operator   !value! !addr-2!

                   (Addr, operator, and value are defined here.)
    * operator     is one of the following:

                   EQ or =   equal to
                   GT or >   greater than
                   LT or <   less than
                   NE or ^=  not equal to
                   GE or >=  greater than or equal to
                   LE or <=  less than or equal to

    * statement    is expressed: line number /.verb number/
    * symbol       is any character combination that follows the rules
                   for forming a data-name in the COBOL language.
    * value        is a literal constant or a figurative constant.

 5. A range of statements, which includes all statements within the rang
 delimited by two statements separated by a colon:
                   statement-1:statement-2
    (this applies to a range of data-names or index-names.)
 6. A list of statements, which includes only the statements listed, is
 enclosed in parentheses, and each statement is separated from the next
 commas, blanks, or tabs:
                   (statement-1,statement-2,statement-3)
    (this applies to a list of addrs, symbols, and so on.)
 7. Valid delimiters between operands in all TESTCOB subcommands are bla
 commas, and tabs. You can use these interchangeably.
1




 Subcommand/Operands

 AT  !statement!
     !(statement-1/,statement-2/...)!
     !statement-3:statement-4!

     /(subcommand list)/ /COUNT(n)/

     /NOTIFY/
+     ______
     /NONOTIFY/

     statement
        is the point where you want to establish an AT breakpoint.

     (statement-1,statement-2)
        are points where you want to establish AT breakpoints. Use this
        if you want to establish AT breakpoints in several NONCONSECUTIV
        statements in your program.

     statement-3:statement-4
        delimit a range of statements where you want to establish AT
        breakpoints. Using this operand establishes AT breakpoints at ev
        statement, which means at every COBOL verb, between statement-3
        statement-4. Therefore, statement-3 must appear before statement
        the program, and both statements must appear in the same program

     (subcommand list)
        is a list of one or more TESTCOB subcommands. Each subcommand in
        list must be separated from the next by a semicolon.  Also, the
        may include AT if you wish. When an AT breakpoint is executed, t
        system stops program execution and then executes the subcommand
        there is one. Once the subcommand list is executed, control is r
        to the terminal where you may enter additional subcommands or ca
        program execution to resume.

        NOTE: If the Interactive Debug command processor encounters the
        RUN subcommand in the subcommand list, no additional subcommands
        be executed after GO or RUN. In this situation, program executio
        resumed. If the END subcommand is encountered in the subcommand
        the command processor immediately terminates the debugging sessi

     COUNT(n)
        is a way to specify that you want the AT breakpoint to cause an
        interruption every nth time it is encountered during program exe
        where n is the value of a positive integer.  (Thus, if COUNT(5)
        specified, the FIRST execution of the AT breakpoint occurs the F
        time the breakpoint is encountered. The verb at this breakpoint
        executed FOUR times, and the interruption occurs before the verb
        executed a FIFTH time.)

     NOTIFY
        means that you want the system to print an identifying message e
        time the AT breakpoint is executed. To suppress the message, spe
        NONOTIFY. NOTIFY is the default.
1




 Subcommand/Operands

 DROP   /symbol/
        /(symbol-1/,symbol-2/...)/

     symbol
        is the same symbol you specified in an EQUATE subcommand.  Speci
        this symbol in EQUATE puts it in a special symbol table. Similar
        specifying this symbol in DROP removes it from that table.

        NOTE: If no symbol operand is included in DROP, the entire symbo
        is deleted. This eradicates the effect of all EQUATE subcommands
        have been entered during your debugging session.

     (symbol-1,symbol-2)
        is a list of symbols that you want to delete. This operand enabl
        to remove several symbols from the symbol table in one quick ste
1




 Subcommand/Operands

 DUMP
1




 Subcommand/Operands

 END
1




 Subcommand/Operands

 EQUATE (or EQ)

        symbol

        !data-name!
        !index-name!
        !special register!

     symbol
        is any character conbination that follows the rules for forming
        data-name. It cannot be qualified nor used as a qualifier. NOTE:
        symbol cannot be qualified by program-name.

        A symbol can represent only one data-name, index-name, or COBOL
        register. If the same symbol is used in a second EQUATE subcomma
        second definition is the only one that the system will recognize
        accept. Once a symbol has been defined by an EQUATE subcommand,
        entered into a symbol table. Thereafter, the symbol can be used
        subcommand in place of the data-name, index-name, or special reg
        it represents. The definition is effective until you remove the
        from the symbol table by using the DROP or RUN subcommand or unt
        end the debugging session, whichever comes first. If the symbol
        defined already in the program, the symbol defined in EQUATE tak
        priority.

     data-name
        is any data-name in your program, including a qualified data-nam
        as A of B of C.

     index-name
        is any index-name in your program.

     special register
        is any one of the COBOL special registers.
1




 Subcommand/Operands

 GO
        !statement!

     statement
        may correspond to any COBOL verb recognized by TESTCOB, in the
        currently executing program only.
1




 Subcommand/Operands

 HELP (or H)

        /subcommand-name/  /FUNCTION/
                           /SYNTAX/
                           /OPERANDS/(list of operands)!
                           /ALL/
+                           ___

     subcommand-name
        is the name of the TESTCOB subcommand that you want to find out
        use. Specifying only a subcommand-name in the operand field will
        you an explanation of the function, syntax, and operands of that
        subcommand. If you omit all operands, the system will display a
        all the TESTCOB subcommands that are available for your use.

     FUNCTION
        indicates that you want a description of the function of the sub
        you have specified in subcommand-name.

     SYNTAX
        indicates that you want a description of the syntax of the subco
        you have specified in subcommand-name.

     OPERANDS
        indicates that you want a description of the operands that are u
        with the subcommand you have specified in subcommand-name.

     (list-of-operands)
        is a list of the particular operands that you want described in
        Each operand in this list must be separated from the next by one
        more blanks or by a comma. List-of-operands must be used with OP
        in the HELP subcommand as shown above.

     ALL
        indicates that you want a description of the function, syntax, a
        operands of the subcommand you have specified in subcommand-name
        is the default.
1




 Subcommand/Operands

 IF (expression)   !HALT (or HA)!
                   !GO!

     (expression)
        is an expression that is evaluated immediately when the IF subco
        is executed. If the two operands in the expression are data-name
        must belong to the same program. The format of an expression is:

           addr-1   operator  !value! !addr-2!

        If addr-2 is used, the data attribute (that is, usage and catego
        must be identical to that represented by addr-1. If value is use
        must have the same data type as addr-1. For example, if addr-1 i
        floating-point, the literal must be floating point.

        The rules for comparison, such as collating sequence, truncation
        padding, will be the same as those in the COBOL language.

     HALT
        or its abbreviation, HA, indicates that you want control returne
        the terminal if the expression is true.

     GO
        indicates that you want to restart program execution if the
        expression is true.
1




 Subcommand/Operands

 LIST or L

        !addr!
        !(addr-1/,addr-2/...)!
        !addr-3:addr-4!
        !ALL!

        /PRINT/

     addr
        is the data-name, index-name, or COBOL special register whose co
        you want desplayed on an output device. If addr is a data-name w
        RENAMES clause, the effect will be the same as using the data-na
        which has been renamed except that the LIST output is displayed
        hexadecimal. If addr is a group item, it will be listed, followe
        all the group items and elementary items it contains. Items cont
        data which is invalid for the defined data type will be identifi
        such and displayed in hexadecimal.

     (addr-1,addr-2)
        is a list of several data-names, index-names, or COBOL special
        registers whose contents you want displayed on an output device.
        same rules for addr, described above, apply to this operand.

     addr-3:addr-4
        delimit a range of data-names and index-names whose contents you
        displayed on an output device. Addr-3 and addr-4 may be data-nam
        index-names, or both, but may not be COBOL special registers. Th
        contents of every data-name and index- name between addr-3 and a
        will be displayed. Addr-3 must appear in the program BEFORE addr

     ALL
        indicates you want all index names, data names, and COBOL specia
        registers, and the contents of the TGT table displayed. The tabl
        displayed in hexadecimal.

     PRINT
        indicates that the display is directed to the data set that was
        specified by the user at the beginning of the debugging session.
        PRINT is omitted, the display is directed to the terminal.
1




 Subcommand/Operands

 LISTBRKS  /PRINT/

     PRINT
        indicates that the list is directed to the data set that was spe
        by the user at the beginning of the debugging session. If PRINT
        omitted, the display is directed to the terminal.
1




 Subcommand/Operands

 LISTFILE    file-name   /PRINT/

     file-name
        is an FD name in the source program.

     PRINT
        indicates that the display is directed to the data set that was
        specified by the user at the beginning of the debugging session.
        PRINT is omitted, the display is directed to the terminal.
1




 Subcommand/Operands

 NEXT (or N)
1




 Subcommand/Operands

 OFF    /statement/
        /(statement-1/,statement-2/...)/
        /statement-3:statement-4/

     statement
        is the point where you want to remove an AT breakpoint.

     (statement-1,statement-2)
        are the points where you want to remove AT breakpoints. Use this
        operand if you want to remove AT breakpoints in several nonconse
        statements.

     statement-3:statement-4
        delimit a range of statements where you want to remove all the A
        breakpoints. Statement-3 must appear in the program before state
        All AT breakpoints are removed in this range whether they were
        established by one AT or several AT subcommands.
1




 Subcommand/Operands

 OFFWN  /identifier/
        /(identifier-1/,identifier-2/...)/

     identifier
        is the identifier that you assigned when you entered the WHEN
        subcommand. You can remove a particular WHEN breakpoint by speci
        its unique identifier in the OFFWN subcommand.

     (identifier-1,identifier-2)
        are the unique identifiers of two WHEN breakpoints that you want
        remove. Use this operand to remove several WHEN breakpoints in s
        nonconsecutive statements. This list can include two or more
        identifiers.

        NOTE: If no operand appears in the OFFWN subcommand, all WHEN
        breakpoints are removed.
1




 Subcommand/Operands

 QUALIFY (or Q)     program-name

     program-name
        is a program-name formed according to the COBOL language rules.
        first character of the program-name is a numeric character or a
        you must change it to conform to the COBOL rules.
1




 Subcommand/Operands

 RUN (or R)     /statement/

     statement
        is the point where you wnat program execution to begin; statemen
        refer to any COBOL verb recognized by TESTCOB and in the program
        is executing. If statement is omitted, program execution begins
        point of last interruption.  This statement must appear in the s
        program in which the last interruption occurred; that is, you ca
        transfer control to another program by entering RUN (or GO).
1




 Subcommand/Operands

 SET (or S)   addr-1   =   !addr-2!
                           !value!
     addr-1
        is the data-name that is initialized or modified. The contents o
        addr-2 or value replace the contents of addr-1. Addr-1 cannot co
        or be the object of an OCCURS clause with the DEPENDING ON optio
        your program.

     addr-2
        represents the contents that are moved to addr-1. The data attri
        (that is, usage and category) of addr-2 must be the same as addr
        Addr-2 and addr-1 must be data-names in the same COBOL program o
        subprogram. Truncation and padding occurs according to the COBOL

     value
        must be the same data type (that is, nonnumeric, fixed point, or
        floating point) as addr-1.
1




 Subcommand/Operands

 SOURCE (or SO)   /line number/                    /ddname/
                  /line number-1:line number -2/

     line number
        is the line number in your source program that you want to displ
        the terminal.

     line number-1:line number-2
        delimit the range of line numbers in your source program that yo
        to display at the terminal. Thus, all line numbers between line
        number-1 and line number-2 will be displayed. If no line-number
        is specified in SOURCE, the entire data set is displayed at the
        terminal. This provides compile-time output that can be used for
        reference during the debugging session.

     ddname
        is the name of the file that contains the listing of the source
        produced at compile time. If ddname is omitted, the program-name
        executing program is used as a default ddname. The program-name
        name that appears in the PROGRMAM-ID paragraph of the source pro
1




 Subcommand/Operands

 TRACE (or T)   /ENTRY/  /PRINT/
                /PARA/
+                ____
                /NAME/
                /OFF/

     ENTRY
        causes a display of the program-name every time a COBOL program
        entered.

     PARA
        causes a display of the line number of each paragraph and sectio
        the moment the execution of each paragraph and section begins. T
        the default.

     NAME
        causes a display of the paragraph-name and line number at the mo
        the execution of each paragraph and section begins.

     OFF
        terminates the effect of a previous TRACE subcommand.  (Entering
        subcommand also terminates a previous TRACE.)

     PRINT
        indicates that the display is directed to the data set that was
        specified by the user at the beginning of the debugging session.
        PRINT is omitted or if there is no PRINT file, the display is di
        to the terminal.
1




 Subcommand/Operands

 WHEN (or WN)   identifier   !addr!    !(expression)!

     identifier
        is a user-supplied string of four-or-less alphanumeric character
        Sometime later in the debugging session, you may want to remove
        breakpoint. You use the OFFWN subcommand to do this, and you spe
        the operand field of the OFFWN subcommand the identifier of each
        breakpoint you want to remove. Therefore, each identifier in a W
        subcommand must be unique.

        NOTE: An identifier cannot be qualified.

     addr
        is a data-name whose content or value is evaluated before each C
        verb is executed. If the value is different from that which it
        previously contained when the WHEN subcommand was either entered
        last executed, program execution is stopped at that point, and c
        is returned to the terminal.

     (expression)
        is an expression that is evaluated before each COBOL verb is exe
        If the two operands in the expression are data-names, they must
        to the same program. If the expression is evaluated as being tru
        program execution is stopped at that point and control is return
        the terminal so you can enter additional subcommands if you wish

        All true expressions are identified at the terminal by a message
        contains the program-name, the statement where the interruption
        occurred, and the identifier that the user assigned to that WHEN
        subcommand.
./ ADD NAME=FILEUSE  0100-82202-82202-1603-00010-00010-00000-JS02150
C          00080
FA
FJ             R
D     10 A6                   EQ10 VNONVSAM --             REJ
D     1  V                      1  R1
D     79 R1                     79 R2
D     2  A1     B               2  UINW   B
D     2  V21                  - 2  UINW   B
D     W  A22                    W  R1                   OUTOUT
END
./ ADD NAME=FILEUSE2 0100-84110-84110-0940-00001-00001-00000-JS02150
 BATCHLOG FILEUSE
./ ADD NAME=I94TP490 0100-84111-84111-1141-00001-00001-00000-JS02150
 BATCHLOG I94TP490
./ ADD NAME=JCLXREF  0100-84110-84110-0947-00001-00001-00000-JS02150
 BATCHLOG JCLXREF
./ ADD NAME=KILLGDG  0100-84110-84110-0948-00001-00001-00000-JS02150
 BATCHLOG KILLGDG
./ ADD NAME=LLINKDYL 0109-80133-80318-1502-00063-00010-00000-JS02150
C          00080              1
FA F
FJ F           R
D     1  U1                   EQ1  V1                      LB1
D     7  A45                  EQ7  VLISTIDR                REJ
D     1  V2                     1  U1                   T1 T1
DLB1  15 A28                  EQ15 VWAS PRODUCED BY     T2
D     5  A12                  EQ5  VCSECT               T3
D     1  A83                  EQ1  V/                   T4 REJ
DT1   20 V                      20 R1
D     10 V                      10 R21
D     20 A57                    20 R31
D     20 V                      20 R51
D     10 V                      10 R71
D                             WJ
D     1  V                      1  R1
D     79 R1                     79 R2
D                             WJ
D     1  V-                     1  R1
D     77 R1                     77 R2
D                             WJ
D     1  V                      1  R1
D     79 R1                     79 R2
D                             WJ                        OUTOUT
DT2   6  V                      6  R1
D     34 A7                     34 R7
D     18 A70                    18 R41
D     2  A104                   2  U11
D     3  A92                    3  U13
D         JTOSDATE            EL    U11,U21
D     2  U23                    2  R59
D     1  V/                     1  R61
D     2  U25                    2  R62
D     1  V/                     1  R64
D     2  U21                    2  R65
D     10 V                      10 R67
D     4  V                      4  R77
D                             WJ
D     1  V                      1  R1
D     79 R1                     79 R2
D                             WJ
D     1  V-                     1  R1
D     77 R1                     77 R2
D                             WJ
D     1  V                      1  R1
D     79 R1                     79 R2
D                             WJ                        OUTOUT
DT3   80 A11                    80 R1
D                             WJ
D     1  V                      1  R1
D     79 R1                     79 R2
D                             WJ                        OUTOUT
DT4   2  A81                    2  U11
D     3  A84                    3  U13
D         JTOSDATE            EL    U11,U21
D     68 A11                    68 R1
D     2  U23                    2  R69
D     1  V/                     1  R71
D     2  U25                    2  R72
D     1  V/                     1  R74
D     2  U21                    2  R75
D     4  V                      4  R77
D                             WJ                        OUTOUT
./ ADD NAME=LOADXREF 0100-84110-84110-0948-00001-00001-00000-JS02150
 BATCHLOG LOADXREF
./ ADD NAME=MOD2TAPE 0100-84110-84110-0949-00001-00001-00000-JS02150
 BATCHLOG MOD2TAPE
./ ADD NAME=OPTBLOCK 0100-84157-84157-1537-00001-00001-00000-JS02150
 BATCHLOG OPTBLOCK
./ ADD NAME=PANRESTR 0100-84110-84110-0950-00001-00001-00000-JS02150
 BATCHLOG PANRESTR
./ ADD NAME=PROCLIST 0100-84110-84110-0950-00001-00001-00000-JS02150
 BATCHLOG PROCLIST
./ ADD NAME=PRTLIB90 0100-84110-84110-0952-00001-00001-00000-JS02150
 BATCHLOG PRTLIB90
./ ADD NAME=RELINK   0100-84110-84110-0953-00001-00001-00000-JS02150
 BATCHLOG RELINK
./ ADD NAME=RJESUBIT 0100-84110-84110-0953-00001-00001-00000-JS02150
 BATCHLOG RJESUBIT
./ ADD NAME=STRUCTLC 0100-84110-84110-0954-00001-00001-00000-JS02150
 BATCHLOG STRUCTLC
./ ADD NAME=STRUCTRM 0101-84110-84110-0955-00001-00001-00000-JS02150
 BATCHLOG STRUCTRM
./ ADD NAME=STR33RM1 0101-84179-84179-1448-00048-00048-00000-JS02150
 DEL  (VSAMT.*REPL*.EDIT) PURGE CL
 DEL  (VSAMT.*REPL*.CTEXT) PURGE CL
 DEL  (VSAMT.*REPL*.CENTRY) PURGE CL
 DEL  (VSAMT.*REPL*.PAGEFILE) PURGE CL
 DEL  (VSAMT.*REPL*.REFER) PURGE CL
 DEL  (VSAMT.*REPL*.UNDEF) PURGE CL
 DEF CL-
      (NAME(VSAMT.*REPL*.EDIT)-
          CYL(1 3)-
          VOL(338019)-
          RECSZ(200 200)-
          NUMD) -
          CAT(SYS1.USERCATT)
 DEF CL-
      (NAME(VSAMT.*REPL*.CTEXT)-
          CYL(1 3)-
          VOL(338019)-
          RECSZ(88 88)-
          NUMD) -
          CAT(SYS1.USERCATT)
 DEF CL-
      (NAME(VSAMT.*REPL*.CENTRY)-
          CYL(1 3)-
          VOL(338019)-
          RECSZ(12 12)-
          NUMD) -
          CAT(SYS1.USERCATT)
 DEF CL-
      (NAME(VSAMT.*REPL*.PAGEFILE)-
          CYL(1 3)-
          VOL(338019)-
          RECSZ(88 88)-
          NUMD) -
          CAT(SYS1.USERCATT)
 DEF CL-
      (NAME(VSAMT.*REPL*.REFER)-
          CYL(1 3)-
          VOL(338019)-
          RECSZ(159 159)-
          NUMD) -
          CAT(SYS1.USERCATT)
 DEF CL-
      (NAME(VSAMT.*REPL*.UNDEF)-
          CYL(1 3)-
          VOL(338019)-
          RECSZ(155 155)-
          NUMD) -
          CAT(SYS1.USERCATT)
./ ADD NAME=STR33RM2 0100-84179-84179-1459-00006-00006-00000-JS02150
 DEL  (VSAMT.*REPL*.EDIT) PURGE CL
 DEL  (VSAMT.*REPL*.CTEXT) PURGE CL
 DEL  (VSAMT.*REPL*.CENTRY) PURGE CL
 DEL  (VSAMT.*REPL*.PAGEFILE) PURGE CL
 DEL  (VSAMT.*REPL*.REFER) PURGE CL
 DEL  (VSAMT.*REPL*.UNDEF) PURGE CL
./ ADD NAME=TELESORT 0100-84110-84110-0955-00001-00001-00000-JS02150
 BATCHLOG TELESORT
./ ADD NAME=TSTPRT   0101-84129-84159-1342-00200-00200-00000-KK00150
LINE  1
LINE  2
LINE  3
LINE  4
LINE  5
LINE  6
LINE  7
LINE  8
LINE  9
LINE 10
LINE 11
LINE 12
LINE 13
LINE 14
LINE 15
LINE 16
LINE 17
LINE 18
LINE 19
LINE 20
LINE 21
LINE 22
LINE 23
LINE 24
LINE 25
LINE 26
LINE 27
LINE 28
LINE 29
LINE 30
LINE 31
LINE 32
LINE 33
LINE 34
LINE 35
LINE 36
LINE 37
LINE 38
LINE 39
LINE 40
LINE 41
LINE 42
LINE 43
LINE 44
LINE 45
LINE 46
LINE 47
LINE 48
LINE 49
LINE 50
LINE 51
LINE 52
LINE 53
LINE 54
LINE 55
LINE 56
LINE 57
LINE 58
LINE 59
LINE 60
LINE 61
LINE 62
LINE 63
LINE 64
LINE 65
LINE 66
LINE 67
LINE 68
LINE 69
LINE 70
LINE 71
LINE 72
LINE 73
LINE 74
LINE 75
LINE 76
LINE 77
LINE 78
LINE 79
LINE 80
LINE 81
LINE 82
LINE 83
LINE 84
LINE 85
LINE 86
LINE 87
LINE 88
LINE 89
LINE 90
LINE 91
LINE 92
LINE 93
LINE 94
LINE 95
LINE 96
LINE 97
LINE 98
LINE 99
LINE100
LINE101
LINE102
LINE103
LINE104
LINE105
LINE106
LINE107
LINE108
LINE109
LINE110
LINE111
LINE112
LINE113
LINE114
LINE115
LINE116
LINE117
LINE118
LINE119
LINE120
LINE121
LINE122
LINE123
LINE124
LINE125
LINE126
LINE127
LINE128
LINE129
LINE130
LINE131
LINE132
LINE133
LINE134
LINE135
LINE136
LINE137
LINE138
LINE139
LINE140
LINE141
LINE142
LINE143
LINE144
LINE145
LINE146
LINE147
LINE148
LINE149
LINE150
LINE151
LINE152
LINE153
LINE154
LINE155
LINE156
LINE157
LINE158
LINE159
LINE160
LINE161
LINE162
LINE163
LINE164
LINE165
LINE166
LINE167
LINE168
LINE169
LINE170
LINE171
LINE172
LINE173
LINE174
LINE175
LINE176
LINE177
LINE178
LINE179
LINE180
LINE181
LINE182
LINE183
LINE184
LINE185
LINE186
LINE187
LINE188
LINE189
LINE190
LINE191
LINE192
LINE193
LINE194
LINE195
LINE196
LINE197
LINE198
LINE199
LINE200
./ ADD NAME=UCC11TBL 0101-83252-83252-1355-00001-00001-00000-GD02150
OPTION RESTORE UCC11TAB
./ ADD NAME=VBCHART  0100-84110-84110-0956-00001-00001-00000-JS02150
 BATCHLOG VBCHART
./ ADD NAME=VERIFY   0100-84017-84017-1642-00001-00001-00000-GD02150
OPTION VERIFY
