AMXPRSCD TITLE 'AMDAHL MVS/XA STATUS COLLECTION DATA (S.C.D.) FORMATTIN*
               G PROGRAM'
         MACRO
&TAG     SYMBL &TEXT
         LCLC  &LABEL
&LABEL   SETC  '&TAG'
         AIF   ('&TAG' NE '').DOIT
&LABEL   SETC  'L&SYSNDX'
.DOIT    ANOP
&LABEL   DC    0C&TEXT,AL1(L'&LABEL),C&TEXT '
         MEND
         SPACE 1
         MACRO
         REGISTER
         LCLA  &N
.LOOP    ANOP
R&N      EQU   &N
&N       SETA  &N+1
         AIF   (&N LE 15).LOOP
         MEND
         SPACE 1
         MACRO
&L       PRINTBUF &TEXT
         LCLC  &L2
&L2      SETC  '&L'
         AIF   ('&TEXT' EQ '').NOMOVE
&L2      L     R15,ADPLBUF         GET BUFFER ADDRESS.
         MVC   0(L'&TEXT,R15),&TEXT MOVE ITEM TO BUF'R.
&L2      SETC  ''
.NOMOVE  ANOP
&L2      LA    R1,ABDPL            ADDRESS PARAMETER LIST.
         L     R15,ADPLPRNT        EXTRACT PRINT ROUTINE ADDR.
         BALR  R14,R15             BRANCH TO PRINT SUBROUTINE.
         MEND
         SPACE 1
         MACRO
&L       FORMAT &PATTERN,&BADRC=
&L       LA    R0,&PATTERN         ADDRESS FORMAT PATTERN.
         LA    R1,ABDPL            ADDRESS PARAMETER LIST.
         L     R15,ADPLFRMT        EXTRACT FORMAT ROUTINE ADDR.
         BALR  R14,R15             BRANCH TO FORMAT SUBROUTINE.
         AIF   ('&BADRC' EQ '').NORC
         LTR   R15,R15             TEST RETURN CODE.
         BNZ   &BADRC              NON-ZERO, TAKE ABNORMAL EXIT.
.NORC    ANOP
         MEND
         EJECT
         MACRO
&LABEL   LOAD  &RESULT,&INPUT,&BADRC=
         AIF   ('&INPUT' NE '').INPUT
&LABEL   LA    R1,ABDPL            ADDRESS PARAMETER LIST.
         AGO   .GETMEM
.INPUT   ANOP
&LABEL   LA    R0,&INPUT           ADDRESS INPUT WITH REGISTER 0.
         LA    R1,ABDPL            ADDRESS PARAMETER LIST.
.GETMEM  ANOP
         L     R15,ADPLMEMA        LOAD ADDR OF MEMORY ROUTINE.
         BALR  R14,R15             BRANCH TO MEMORY SERVICE ROUTINE.
         LTR   R15,R15             MEMORY AVAILABLE?
         BNZ   &BADRC              NO, WE CAN'T CONTINUE.
         AIF   ('&RESULT' EQ '').NORESLT
         LR    R1,R0               LOAD RESULT POINTER INTO R1.
         ICM   &RESULT,B'1111',0(R1) LOAD AND TEST ACQUIRED STORAGE.
.NORESLT ANOP
         MEND
         EJECT
***********************************************************************
*                                                                     *
*                         AMXPRSCD                                    *
*                                                                     *
*     THIS PROGRAM IS DESIGNED TO EXECUTE AS A USER EXIT TO THE       *
*     MVS AMDPRDMP SERVICE AID.  ITS FUNCTION IS TO FORMAT THE        *
*     STATUS COLLECTION DATA BLOCKS USED IN IOS HOT I/O DETECTION     *
*     AND RECOVERY.  THE PROGRAM IS EXECUTED WHENEVER THE "MAPSCD"    *
*     CONTROL CARD IS ENCOUNTERED IN THE AMDPRDMP SYSIN FILE.  IN     *
*     ORDER TO RECOGNIZE THE "MAPSCD" CONTROL CARD, A USER ENTRY MUST *
*     BE MADE IN THE AMDPRECT USER EXIT MODULE.  APPENDIX "C" OF THE  *
*     "OS/VS2 S.P.L.:  SERVICE AIDS" MANUAL DESCRIBED HOW TO PERFORM  *
*     THIS FUNCTION.                                                  *
*                                                                     *
*     THE EXIT FIRST ACCESSED THE CVTDCB FIELD TO DETERMINE IF THE    *
*     PROGRAM IS ANALYZING AN MVS/370 OR MVS/XA DUMP.  IF AN MVS/370  *
*     DUMP IS BEING ANALYZED, CONTROL IS PASSED TO THE 370 VERSION    *
*     OF THE PROGRAM, AMDPRSCD, VIA XCTL.                             *
*                                                                     *
*     FIRST, THE HOT I/O DETECTION TABLE (HIDT) IS LOCATED BY SCAN-   *
*     ING FOR IT'S ENTRY IN THE NUCLEUS CROSS REFERENCE.  THEN THE    *
*     HIDT IS FORMATTED, AND IF PRESENT, THE FIRST HOT I/O SCD IS     *
*     LOCATED.  EACH SCD IN THE HOT I/O CHAIN IS FORMATTED INCLUDING  *
*     THE TIME OF DAY, EXPLANATIONS OF ANY FLAG BITS THAT ARE ON,     *
*     PATH MASKS AND REPEAT COUNTS AND THE I.R.B. FROM THE LAST I/O   *
*     INTERRUPT.                                                      *
*                                                                     *
*     THIS EXIT HAS NO OPERANDS.                                      *
*                                                                     *
*     THIS PROGRAM FOLLOWS ALL CONVENTIONS SPECIFIED IN THE ABOVE     *
*     MENTIONED MANUAL.  IT IS REENTRANT AND MAY BE PLACED IN LPA     *
*     TO IMPROVE PERFORMANCE (IF YOU'RE HAVING A WHOLE LOT OF IOS     *
*     PROBLEMS).  ELSE, IT MAY BE PLACED IN LINKLIB OR A USER'S       *
*     STEP LIBRARY.                                                   *
*                                                                     *
***********************************************************************
         SPACE 2
         REGISTER
         EJECT
***********************************************************************
*                                                                     *
*     PERFORM O/S HOUSEKEEPING AND ACQUIRE USER-DEPENDENT AREA.  IF   *
*     THE DUMP IS FROM AN MVS/370 SYSTEM, XCTL TO AMDPRSCD MODULE.    *
*                                                                     *
***********************************************************************
         SPACE 1
AMXPRSCD CSECT ,                   ESTABLISH PROGRAM ENTRY POINT.
         USING AMXPRSCD,R15        ESTABLISH TEMPORARY BASE.
         B     START               BRANCH AROUND PROGRAM ID
         DROP  R15                 DONE WITH TEMPORARY BASE.
         SPACE 1
         SYMBL 'AMXPRSCD V03M00 &SYSDATE &SYSTIME COPYRIGHT 1985, AMDAH*
               L CORP., SE TOOLS - SETT010, AMDIPCSE'
        SPACE 1
START    STM   R14,R12,12(R13)     SAVE CALLER'S REGISTERS.
         LR    R12,R15             LOAD PROGRAM BASE.
         USING AMXPRSCD,R12        MAKE CODE ADDRESSABLE.
         LR    R10,R1              PRESERVE PARAMETER REGISTER.
         USING ABDPL,R10           MAKE PARAMETER DSECT ADDRESSABLE.
         LA    R0,$LENGTH          GET LENGTH OF REENTRANT DSECT.
         ICM   R0,8,ADPLSBPL       INSERT PRDMP SUPPLIED SUBPOOL.
         GETMAIN R,LV=(0)          GETMAIN REENTRANT AREA.
         LR    R2,R1               LOAD ADDRESS IN EVEN REGISTER.
         LA    R3,$LENGTH          GET LENGTH TO ZERO.
         XR    R5,R5               SET FILL CHARACTER.
         MVCL  R2,R4               ZERO THE REENTRANT AREA.
         LR    R11,R1              LOAD REENTRANT BASE REGISTER.
         USING $DSECT,R11          MAKE AREA ADDRESSABLE.
         ST    R13,$SAVE+4         FORWARD CHAIN SAVE AREAS.
         LR    R2,R13              HOLD OLD SAVE ADDRESS.
         LA    R13,$SAVE           ADDRESS NEW SAVE AREA.
         ST    R13,8(,R2)          BACK CHAIN SAVE AREAS.
         SPACE 1
         ICM   R9,B'1111',ADPLCVT  LOAD CVT ADDRESS FROM DUMP.
         BZ    BADCVT              NOT THERE, WE CAN'T CONTINUE.
         LOAD  R6,CVTDCB(,R9),BADRC=BADCVT GET THE XA-MODE INDICATOR.
         BM    MODEXA              HIGH BIT ON, XA-MODE DUMP.
         L     R13,4(,R13)         POINT BACK TO CALLER'S SAVE AREA.
         LA    R0,$LENGTH          LOAD LENGTH TO FREEMAIN.
         ICM   R0,B'1000',ADPLSBPL INSERT SUBPOOL INDICATION.
         LR    R1,R11              LOAD ADDRESS OF AREA TO BE FREED.
         FREEMAIN R,LV=(0),A=(1)   FREE THE USER-DEPENDENT AREA.
         LM    R14,R12,12(R13)     RESTORE CALLER'S REGISTERS.
         PUSH  USING
         USING AMXPRSCD,R15        TEMPORARY ADDRESSABILITY FOR XCTL.
         XCTL  EP=AMDPRSCD         XCTL TO MVS/370 VERSION.
         POP   USING
         EJECT
***********************************************************************
*                                                                     *
*     PRINT THE TITLE LINE, THEN FIND THE HIDT ENTRY IN THE NUCMAP.   *
*                                                                     *
***********************************************************************
         SPACE 1
MODEXA   DS    0H
         PRINTBUF TITLE            OUTPUT THE TITLE LINE.
         PRINTBUF ,                AND A BLANK LINE.
         SPACE 1
         LOAD  R6,CVTNUCMP(,R9),BADRC=BADCVT LOAD THE NUCMAP POINTER.
***
***  WARNING - FROM HERE ON OUT, DATA REFERENCED IS ABOVE 16 MEGABYTES.
***  DO NOT USE THE INTERNAL "LOAD" MACRO OR A LOAD-ADDRESS INSTRUCTION
***  TO REFERENCE DATA.
***
         MVI   ADPLPRDP,ADPLVIRT   SET 31-BIT VIRTUAL FLAG.
         LA    R0,NUCMFLAG         LOAD FLAG WORD OFFSET.
         AR    R0,R6               OFFSET FROM START OF NUCMAP.
         LOAD  R5,BADRC=BADNUCM    GET REQUESTED MEMORY.
         N     R5,=X'00FFFFFF'     TURN OFF THE AMODE/RMODE FLAGS.
         SRL   R5,4                DIVIDE BY WIDTH OF ONE ENTRY.
         MVC   ADPLDLEN,=H'16'     REQUEST 16 BYTES RETURNED.
NUCMLOOP DS    0H
         AH    R6,=H'16'           POINT TO NEXT NUCMAP ENTRY.
         LR    R0,R6               LOAD MEMORY ADDRESS TO ACCESS.
         LOAD  BADRC=BADNUCM       ATTEMPT TO FETCH MEMORY.
         LR    R4,R0               PUT BUFFER ADDRESS INTO USABLE REG.
         CLC   IOSRHIDT,NUCMNAME(R4) THIS THE ONE WE WANT?
         BE    GOTHIDT             YES, WE'VE GOT A WINNER.
         BCT   R5,NUCMLOOP         LOOP THROUGH UNTIL HIDT IS FOUND.
         B     BADHIDT             FELL THROUGH, HIDT NOT IN NUCLEUS.
         EJECT
***********************************************************************
*                                                                     *
*     WE'VE FOUND THE HIDT.  FORMAT THE ADDRESS LINE AND THEN TRY     *
*     TO BRING IT INTO THE PROGRAM'S STORAGE.                         *
*                                                                     *
***********************************************************************
         SPACE 1
GOTHIDT  DS    0H
         XC    $FORMAT,$FORMAT     ZERO THE PATTERN LIST WORK AREA.
         MVC   $FORMAT(LPATTRN1),PATTERN1 MOVE IN SKELATON PATTERN.
         LA    R6,NUCMADDR(,R4)    POINT R6 AT THE VALUE TO BE DECODED.
         ST    R6,$FMT2            SAVE IT IN FORMAT PATTERN.
         FORMAT $FORMAT,BADRC=BADHIDT FORMAT THE ADDRESS LINE
         L     R15,ADPLBUF         POINT R15 AT PRINT BUFFER.
         MVC   0(L'HIDT@MSG,R15),HIDT@MSG MOVE IN ADDRESS TEXT.
         PRINTBUF ,                PRINT THE HIDT HEADER LINE.
         SPACE 1
         L     R0,NUCMADDR(,R4)    LOAD ADDRESS OF HIDT FROM NUCMAP.
         MVC   ADPLDLEN,=H'360'    TRY TO READ IT ALL.
         LOAD  BADRC=BADHIDT       GET HIDT INTO PROGRAM'S STORAGE.
         LR    R9,R0               LOAD ADDRESS INTO USABLE REGISTER.
         USING HIDT,R9             MAKE DSECT ADDRESSABLE.
         SPACE 2
         XC    $FORMAT,$FORMAT     ZERO THE FORMAT LIST.
         MVC   $FORMAT(LPATTRN2),PATTERN2 PATTERN FOR THRESHOLD.
         LA    R6,HIDDVTHR         LOAD OFFSET WITHIN HIDT OF THRESHOLD
         ST    R6,$FMT2            SAVE IN FORMAT PATTERN.
         FORMAT $FORMAT            FORMAT THE DEVICE THRESHOLD.
         L     R15,ADPLBUF         ADDRESS THE PRINT BUFFER.
         MVC   0(L'HIDTTHRS,R15),HIDTTHRS MOVE IN THRESHOLD MESSAGE.
         PRINTBUF ,                PRINT THE BUFFER.
         EJECT
***********************************************************************
*                                                                     *
*     FORMAT THE HOT I/O RECOVERY DEFAULT SETTING MATRIX              *
*                                                                     *
***********************************************************************
         SPACE 1
         PRINTBUF HIDTMATX         PRINT MATRIX HEADER MESSAGE.
         L     R15,ADPLBUF         LOAD BUFFER POINTER.
         MVC   5(L'HIDTMAT1,R15),HIDTMAT1 MOVE IN TOP OF LABELS BOX.
         PRINTBUF ,                PRINT TOP OF LABELS BOX.
         L     R15,ADPLBUF         LOAD BUFFER POINTER.
         MVC   5(L'HIDTMAT2,R15),HIDTMAT2 MOVE IN LABELS BOX.
         PRINTBUF ,                PRINT LABELS BOX.
         L     R15,ADPLBUF         LOAD BUFFER POINTER.
         MVC   5(L'HIDTMAT3,R15),HIDTMAT3 MOVE IN VALUES BOX.
         PRINTBUF ,                PRINT VALUES BOX.
         LA    R6,HIDMSGDT         LOAD OFFSET OF MESSAGE TABLE.
HIDLOOP1 DS    0H
         L     R15,ADPLBUF         POINT R15 AT PRINT BUFFER.
         MVC   5(L'HIDTMAT4,R15),HIDTMAT4 MOVE IN SKELATION LINE.
         TM    $FLAG,$TWOPASS      SECOND PASS THROUGH?
         BNO   PASS1ST             NOPE, LEAVE HEADER TEXT ALONE.
         MVC   7(L'NONRECUR,R15),NONRECUR MOVE IN NON-RECURSIVE MSG.
PASS1ST  DS    0H
         LA    R5,3                LOAD LOOP COUNTER.
         LA    R4,23(,R15)         POINT TO RESULT AREA IN BUFFER.
HIDLOOP2 DS    0H
         MVC   0(5,R4),=CL5'NONE'  ASSUME NO DEFAULT BIT IS SET.
         CLI   0(R6),2             DEFAULT OF "BOX"?
         BNE   NOTBOX              NOPE, SKIP MESSAGE.
         MVC   0(5,R4),=CL5' BOX'  SET MESSAGE.
         B     ENDLOOP2            TRY NEXT MATRIX ENTRY.
NOTBOX   DS    0H
         CLI   0(R6),4             DEFAULT OF "BOX"?
         BNE   NOTCPR              NOPE, SKIP MESSAGE.
         MVC   0(5,R4),=CL5' CPR'  SET MESSAGE.
         B     ENDLOOP2            TRY NEXT MATRIX ENTRY.
NOTCPR   DS    0H
         CLI   0(R6),5             DEFAULT OF "BOX"?
         BNE   ENDLOOP2            NOPE, SKIP MESSAGE.
         MVC   0(5,R4),=CL5'FORCE' SET MESSAGE.
ENDLOOP2 DS    0H
         LA    R6,1(,R6)           BUMP MATRIX POINTER.
         LA    R4,10(,R4)          BUMP OUTPUT POINTER.
         BCT   R5,HIDLOOP2         FILL OUT ONE LINE.
         PRINTBUF ,                PRINT THE BUFFER.
         L     R15,ADPLBUF         ADDRESS PRINT BUFFER.
         MVC   5(L'HIDTMAT3,R15),HIDTMAT3 MOVE IN BOX TEXT.
         PRINTBUF ,                PRINT BOX TEXT.
         TM    $FLAG,$TWOPASS      WAS THIS THE SECOND PASS?
         BO    DOLOOKUP            YES, JUST DO THE SCD LOOKUP TABLE.
         OI    $FLAG,$TWOPASS      SET TWOPASS FLAG.
         B     HIDLOOP1            AND RETURN FOR SECOND PASS.
         EJECT
***********************************************************************
*                                                                     *
*     FORMAT THE CONTENTS OF THE HIDT SCD SCAN TABLE ADDRESSES        *
*                                                                     *
***********************************************************************
         SPACE 1
DOLOOKUP DS    0H
         PRINTBUF HIDTSCDT         PRINT SCD SCAN TABLE HEADER MESSAGE.
         XC    $FORMAT,$FORMAT     ZERO THE FORMAT LIST.
         MVC   $FORMAT(LPATTRN3),PATTERN3 MOVE IN PATTERN3.
         LA    R6,HIDSCAN          LOAD R6 WITH TABLE OFFSET IN HIDT.
         LA    R5,2                LOAD LOOP COUNTER.
HIDLOOP3 DS    0H
         ST    R6,$FMT2            SAVE DATA ADDRESS IN FORMAT PATTERN.
         FORMAT $FORMAT,BADRC=BADHIDT FORMAT THE LINE.
         PRINTBUF ,                PRINT THE LINE.
         LA    R6,32(,R6)          POINT AT NEXT DUMP LINE.
         BCT   R5,HIDLOOP3         LOOP THRU SCD SCAN POINTERS.
         EJECT
***********************************************************************
*                                                                     *
*     FORMAT THE DEVICE COUNTS FOR EACH CHANNEL PATH.                 *
*                                                                     *
***********************************************************************
         SPACE 1
         PRINTBUF HIDTHOT#         PRINT HOT DEVICE HEADER.
         PRINTBUF HIDTHOTS         PRINT HOT DEVICE SCALE.
         LA    R6,HIDCPCNT         LOAD OFFSET OF HOT DEVICE COUNTS.
         LA    R5,16               LOAD LOOP COUNTER.
         XR    R4,R4               LOAD INDEX COUNTER.
         XC    $FORMAT,$FORMAT     ZERO THE FORMAT LIST.
         MVC   $FORMAT(LPATTRN4),PATTERN4 MOVE IN PATTERN.
         LA    R3,$DOUBLE          LOAD ADDRESS OF WORK AREA.
         ST    R3,$FMT2            MOVE IN LABEL ADDRESS.
HIDLOOP4 DS    0H
         STC   R4,$DOUBLE          SAVE INDEX COUNTER.
         ST    R6,$FMT5            SAVE DATA ADDRESS IN PATTERN.
         FORMAT $FORMAT            FORMAT THE LINE.
         PRINTBUF ,                PRINT THE LINE.
         LA    R6,16(,R6)          BUMP TO NEXT DUMP LINE.
         LA    R4,16(,R4)          BUMP INDEX COUNTER.
         BCT   R5,HIDLOOP4
         EJECT
***********************************************************************
*                                                                     *
*     SEE IF A HOT SCD IS ALLOCATED; IF NOT, THEN JUST RETURN.        *
*                                                                     *
***********************************************************************
         SPACE 1
         ICM   R8,B'1111',HIDHOTQ  LOAD ADDRESS OF FIRST HOT SCD.
         DROP  R9                  DONE WITH HIDT ADDRESSABILITY.
         BNZ   RUNSCDS             ONE WAS FOUND, FORMAT IT.
         PRINTBUF HIDTNSCD         TELL USER THERE'S NONE TO BE HAD.
         B     RETURN              AND RETURN TO CALLER.
         EJECT
***********************************************************************
*                                                                     *
*     FORMAT THE S.C.D. BEGINNING WITH IT'S ADDRESS.                  *
*                                                                     *
***********************************************************************
         SPACE 1
RUNSCDS  DS    0H
         PRINTBUF ,                PRINT A BLANK LINE.
         SPACE 1
         XC    $FORMAT,$FORMAT     CLEAR THE PATTERN AREA.
         MVC   $FORMAT(LPATTRN5),PATTERN5 MOVE IN SKELATON PATTERN.
         ST    R8,$DOUBLE          SAVE SCD ADDRESS.
         LA    R0,$DOUBLE          POINT R0 AT SCD ADDRESS AREA.
         ST    R0,$FMT3            SAVE IN FORMAT WORD.
         FORMAT $FORMAT            FORMAT THE AREA.
         PRINTBUF ,                THEN PRINT THE BUFFER.
         EJECT
***********************************************************************
*                                                                     *
*     LOAD A COPY OF THE SCD FROM THE DUMP.  THEN FORMAT THE DEVICE   *
*     NUMBER, ALTERNATE DEVICE NUMBER, CHANNEL PATH AND TIME OF DAY.  *
*                                                                     *
***********************************************************************
         SPACE 1
         MVC   ADPLDLEN,=H'52'     SET LENGTH TO BE RETURNED.
         LR    R0,R8               LOAD ADDRESS TO BE ACQUIRED.
         LOAD  BADRC=BADSCD        GO FETCH THE AREA.
         LR    R7,R0               LOAD ADDRESS INTO USABLE REGISTER.
         USING SCD,R7              MAKE DSECT ADDRESSABLE.
         SPACE 1
         XC    $FORMAT,$FORMAT     CLEAR THE PATTERN AREA.
         MVC   $FORMAT(LPATTRN6),PATTERN6 MOVE IN SKELATON PATTERN.
         LA    R0,SCDDEV#          POINT R0 AT SCD DEVICE NUMBER.
         ST    R0,$FMT3            SAVE IN FORMAT WORD.
         LA    R0,SCDRDEVN         POINT R0 AT ALTERNATE DEVICE NUMBER.
         ST    R0,$FMT6            SAVE IN FORMAT WORD.
         FORMAT $FORMAT            FORMAT THE AREA.
         PRINTBUF ,                THEN PRINT THE BUFFER.
         SPACE 1
         XC    $FORMAT,$FORMAT     CLEAR THE PATTERN AREA.
         MVC   $FORMAT(LPATTRN7),PATTERN7 MOVE IN SKELATON PATTERN.
         LA    R0,SCDCHP           POINT R0 AT SCD CHANNEL PATH ID.
         ST    R0,$FMT4            SAVE IN FORMAT WORD.
         FORMAT $FORMAT            FORMAT THE AREA.
         PRINTBUF ,                THEN PRINT THE BUFFER.
         SPACE 1
         L     R15,ADPLBUF         POINT R15 AT PRINT BUFFER.
         MVC   0(L'SCDTIMEM,R15),SCDTIMEM MOVE IN TIME OF 'RUPT MSG.
         LM    R0,R1,SCDHDTM       LOAD TIME INTO R0 & R1.
         BAL   R14,MICROZ          CONVERT TO PRINTABLE MESSAGE.
         PRINTBUF ,                PRINT THE BUFFER.
         EJECT
***********************************************************************
*                                                                     *
*     ISSUE MESSAGES FOR ANY SCD FLAG BIT THAT IS SET.                *
*                                                                     *
***********************************************************************
         SPACE 1
         PRINTBUF SCDRECM1         PRINT RECOVERY FLAGS MESSAGE.
         LA    R6,MSGTBL           POINT R6 AT THE MESSAGE TABLE.
SCDLOOP1 DS    0H
         ICM   R5,B'0001',1(R6)    LOAD AND TEST FLAG BITS.
         BZ    ENDSCDL1            FLAG BITS ZERO, WE'RE DONE.
         XR    R4,R4               ZONK.
         IC    R4,0(,R6)           INSERT OFFSET TO FLAG BITS.
         AR    R4,R7               OFFSET FROM SCD BASE.
         EX    R5,TM1              TEST IF THE BIT IS ON.
         BNO   BITNOTON            NOPE, DON'T ISSUE MESSAGE.
         L     R15,ADPLBUF         POINT AT PRINT BUFFER.
         L     R5,2(,R6)           LOAD ADDRESS OF MESSAGE SYMBL.
         XR    R4,R4               ZONK AGAIN.
         IC    R4,0(,R5)           LOAD LENGTH BYTE.
         BCTR  R4,0                DECREMENT FOR MVC.
         EX    R4,MVC1             MOVE IN MESSAGE.
         PRINTBUF ,                PRINT THE BUFFER.
BITNOTON DS    0H
         LA    R6,6(,R6)           POINT TO NEXT TABLE ENTRY.
         B     SCDLOOP1            AND CONTINUE THROUGH 'TILL DONE.
ENDSCDL1 DS    0H
         EJECT
***********************************************************************
*                                                                     *
*     FINALLY, FORMAT THE GROUP INDEX, LPUM, GROUP COUNTS, TOTAL      *
*     COUNT AND RECOVERY ACTION BYTE.  THEN SEE IF THERE'S MORE SCDS. *
*                                                                     *
***********************************************************************
         SPACE 1
         XC    $FORMAT,$FORMAT     CLEAR THE FORMAT PATTERN.
         MVC   $FORMAT(LPATTRN8),PATTERN8 MOVE IN THE SKELATON PATTERN.
         LA    R0,SCDGINDX         POINT AT REQUESTED DATA ELEMENT.
         ST    R0,$FMT3            SAVE IN FORMAT PATTERN.
         FORMAT $FORMAT            FORMAT THE DATA.
         PRINTBUF ,                AND THEN PRINT THE BUFFER.
         SPACE 1
         XC    $FORMAT,$FORMAT     CLEAR THE FORMAT PATTERN.
         MVC   $FORMAT(LPATTRN9),PATTERN9 MOVE IN THE SKELATON PATTERN.
         LA    R0,SCDGLPUM         POINT AT REQUESTED DATA ELEMENT.
         ST    R0,$FMT3            SAVE IN FORMAT PATTERN.
         FORMAT $FORMAT            FORMAT THE DATA.
         PRINTBUF ,                AND THEN PRINT THE BUFFER.
         SPACE 1
         XC    $FORMAT,$FORMAT     CLEAR THE FORMAT PATTERN.
         MVC   $FORMAT(LPATTRNA),PATTERNA MOVE IN THE SKELATON PATTERN.
         LA    R0,SCDGCNT          POINT AT REQUESTED DATA ELEMENT.
         ST    R0,$FMT3            SAVE IN FORMAT PATTERN.
         FORMAT $FORMAT            FORMAT THE DATA.
         PRINTBUF ,                AND THEN PRINT THE BUFFER.
         SPACE 1
         XC    $FORMAT,$FORMAT     CLEAR THE FORMAT PATTERN.
         MVC   $FORMAT(LPATTRNB),PATTERNB MOVE IN THE SKELATON PATTERN.
         LA    R0,SCDTCNT          POINT AT REQUESTED DATA ELEMENT.
         ST    R0,$FMT3            SAVE IN FORMAT PATTERN.
         FORMAT $FORMAT            FORMAT THE DATA.
         PRINTBUF ,                AND THEN PRINT THE BUFFER.
         SPACE 1
         XC    $FORMAT,$FORMAT     CLEAR THE FORMAT PATTERN.
         MVC   $FORMAT(LPATTRNC),PATTERNC MOVE IN THE SKELATON PATTERN.
         LA    R0,SCDRACTN         POINT AT REQUESTED DATA ELEMENT.
         ST    R0,$FMT3            SAVE IN FORMAT PATTERN.
         FORMAT $FORMAT            FORMAT THE DATA.
         PRINTBUF ,                AND THEN PRINT THE BUFFER.
         SPACE 1
         ICM   R6,B'1111',SCDXPTR  LOAD AND TEST EXTENSION POINTER
         BZ    NEXTSCD             NONE TO BE HAD, SKIP IT.
         PRINTBUF SCDEXMSG         PRINT EXTENSION HEADER MESSAGE.
         LA    R5,2                LOAD LOOP COUNTER.
SCDLOOP2 DS    0H
         XC    $FORMAT,$FORMAT     CLEAR THE PATTERN AREA.
         MVC   $FORMAT(LPATTRN3),PATTERN3 MOVE IN PATTERN SKELATON.
         ST    R6,$FMT2            SAVE ADDRESS IN FORMAT PATTERN.
         FORMAT $FORMAT            FORMAT THE DATA AREA.
         PRINTBUF ,                PRINT THE BUFFER.
         AH    R6,=H'32'           INCREMENT DATA POINTER.
         BCT   R5,SCDLOOP2         REPEAT FOR ALL OF THE EXTENSION.
         SPACE 1
NEXTSCD  DS    0H
         ICM   R8,B'1111',SCDHNEXT LOAD AND TEST SCD CHAIN POINTER.
         BNZ   RUNSCDS             CONTINUE IF MORE SCD'S.
         B     RETURN              OTHERWISE, WE'RE DONE.
         EJECT
***********************************************************************
*                                                                     *
*     SUBROUTINE MICROZ CONVERTS THE SCD'S TIME OF DAY CLOCK INTO     *
*     PRINTABLE YY.DDD HH:MM:SS VALUES IN THE OUTPUT RECORD.  ON      *
*     INPUT, R0 & R1 CONTAIN THE SCD'S CLOCK VALUE.                   *
*                                                                     *
***********************************************************************
         SPACE 1
MICROZ   STM   R14,R12,12(R13)       SAVE THE CALLER'S REGISTERS.
         SRDL  R0,12                 SHIFT OUT INSIGNIFICANT DIGITS.
         D     R0,=F'60000000'       GET MINUTES SINCE EPOCH.
         LR    R3,R1                 HOLD IN R3 A MOMENT.
         SRDL  R0,32                 MOVE SECONDS REMAINDER TO R0.
         D     R0,=F'1000000'        COMPUTE SECONDS FROM REMAINDER.
         XR    R2,R2                 ZONK FOR DIVIDE.
         D     R2,=F'60'             COMPUTE MINUTES.
         MH    R2,=H'100'            MOVE TO MINUTES POSITION.
         AR    R1,R2                 ADD TO SECONDS.
         XR    R2,R2                 ZONK.
         D     R2,=F'24'             COMPUTE HOURS RESIDUAL.
         MH    R2,=H'10000'          MOVE TO HOURS POSITION.
         AR    R1,R2                 SAVE TIME VALUE IN R1.
         CVD   R1,$DOUBLE            CONVERT TO PACKED.
         L     R1,$DOUBLE+4          SAVE TIME FOR A SECOND.
         XR    R2,R2                 ZONK.
         SH    R3,=H'364'            ACCOUNT FOR TODAY & 1/1/1900.
         SLDL  R2,2                  MULTIPLY BY 4 (YEARS IN DIVIDEND).
         D     R2,=F'1461'           DIVIDE BY # DAYS IN 4 YEARS.
         LA    R3,1(,R3)             ACCOUNT FOR THIS YEAR.
         MH    R3,=H'1000'           SHIFT R3 TO YEARS POSITION.
         SRL   R2,2                  DIVIDE DAYS BY 4.
         AR    R2,R3                 SUM YEARS*1000 + DAYS.
         CVD   R2,$DOUBLE            CONVERT TO PACKED.
         L     R0,$DOUBLE+4          LOAD SIGNIFICANT VALUE.
         SRL   R0,4                  SHIFT OUT SIGN.
         STCM  R0,B'0111',$DOUBLE    SAVE YY.DDD IN $DOUBLE(3).
         SRL   R1,4                  SHIFT OUT SIGN.
         STCM  R1,B'0111',$DOUBLE+3  SAVE HH:MM:SS IN $DOUBLE+3(3).
         L     R15,ADPLBUF           GET BUFFER ADDRESS.
         MVC   L'SCDTIMEM(L'EDITMASK,R15),EDITMASK MOVE IN EDIT MASK.
         ED    L'SCDTIMEM(L'EDITMASK,R15),$DOUBLE EDIT IN DATA.
         LM    R14,R12,12(R13)       RESTORE CALLER'S REGISTERS.
         BR    R14                   RETURN TO CALLER.
         EJECT
***********************************************************************
*                                                                     *
*     PRINT ERROR MESSAGE IF MEMORY COULD NOT BE ACCESSED.            *
*                                                                     *
***********************************************************************
         SPACE 1
BADCVT   PRINTBUF MESSAGE1         PRINT ERROR TEXT.
         B     SETRC               GO SET RETURN CODE.
         SPACE 1
BADNUCM  PRINTBUF MESSAGE2         PRINT ERROR TEXT.
         B     SETRC               GO SET RETURN CODE.
         SPACE 1
BADHIDT  PRINTBUF MESSAGE3         PRINT ERROR TEXT.
         B     SETRC               GO SET RETURN CODE.
         SPACE 1
BADSCD   PRINTBUF MESSAGE4         PRINT ERROR TEXT.
         EJECT
***********************************************************************
*                                                                     *
*     NORMAL AND ABNORMAL RETURN POINT.  AN ENDING MESSAGE IS         *
*     PRINTED, AND THE REENTRANT WORK AREA IS FREED (SUBPOOL NUMBER   *
*     WAS PROVIDED IN THE ABDUMP PARAMETER LIST).                     *
*                                                                     *
***********************************************************************
         SPACE 1
SETRC    LA    R2,4                SET RETURN CODE.
         B     NOENDMSG            PRDMP PROVIDES ERROR MESSAGE.
         SPACE 2
RETURN   PRINTBUF ENDMSG           PRINT ENDING MESSAGE.
         XR    R2,R2               ZERO RETURN CODE.
NOENDMSG LA    R0,$LENGTH          LOAD LENGTH TO FREEMAIN.
         ICM   R0,8,ADPLSBPL       INSERT SUBPOOL.
         LR    R1,R11              SET ADDRESS TO BE FREED.
         L     R13,4(,R13)         BACK TO CALLER'S SAVE AREA.
         FREEMAIN R,LV=(0),A=(1)   FREE REENTRANT AREA.
         ST    R2,16(,R13)         PUT RETURN CODE IN R15 SLOT.
         LM    R14,R12,12(R13)     RESTORE CALLER'S REGISTERS.
         BR    R14                 RETURN TO CALLING PROGRAM.
         EJECT
***********************************************************************
*                                                                     *
*                    CONSTANTS AND EQUATES                            *
*                                                                     *
***********************************************************************
         SPACE 2
         LTORG ,                   BUILD A LITERAL POOL.
         SPACE 1
CVTDCB   EQU   X'74'               LOGREC DCB POINTER OFFSET IN CVT.
CVTNUCMP EQU   X'4B0'              NUCLEUS MAP TABLE POINTER OFFSET.
NUCMNAME EQU   X'00'               OFFSET OF MODULE NAME IN NUCMAP.
NUCMADDR EQU   X'08'               OFFSET OF ADDRESS WORD IN NUCMAP.
NUCMFLAG EQU   X'0C'               OFFSET OF LENGTH WORD IN NUCMAP.
         SPACE 1
*********************************  FORMAT PATTERN EQUATES.
NC       EQU   X'20'                 - NO CONVERSION TO HEX REQUESTED.
CS       EQU   X'10'                 - DATA IS IN CALLER'S STORAGE.
@D       EQU   X'08'                 - DATA POINTER FOLLOWS.
D        EQU   X'04'                 - DATA IS TO BE PLACED IN BUFFER.
@L       EQU   X'02'                 - LABEL POINTER FOLLOWS.
L        EQU   X'01'                 - LABEL IS TO BE PLACED IN BUFFER.
         SPACE 2
TITLE    DC    C'AMDAHL MVS/XA STATUS COLLECTION DATA (S.C.D.) FORMATTI*
               NG PROGRAM.'
ENDMSG   DC    C'END OF S.C.D. FORMATTING PROGRAM.'
         SPACE 1
MESSAGE1 DC    C'CVT COULD NOT BE ACCESSED.'
MESSAGE2 DC    C'NUCLEUS CROSS REFERENCE COULD NOT BE ACCESSED.'
MESSAGE3 DC    C'HIDT COULD NOT BE ACCESSED.'
MESSAGE4 DC    C'SCD COULD NOT BE ACCESSED.'
         SPACE 1
EDITMASK DC    X'402021204B2020202220217A20207A2020' CLOCK MASK.
         SPACE 1
IOSRHIDT DC    C'IOSRHIDT'
HIDT@MSG DC    C'HOT I/O DETECTION TABLE (HIDT) IS AT:  '
HIDTTHRS DC    C'DEVICE THRESHOLD:  '
HIDTMATX DC    C'RECOVERY DEFAULT ACTION MATRIX:'
HIDTMAT1 DC    C'                +---------+---------+---------+'
HIDTMAT2 DC    C'                × IOS110A × IOS111A × IOS112A ×'
HIDTMAT3 DC    C'+---------------+---------+---------+---------+'
HIDTMAT4 DC    C'×   RECURSIVE   ×         ×         ×         ×'
NONRECUR DC    C'NON-RECURSIVE'
HIDTSCDT DC    C'S.C.D. SCAN TABLE FOLLOWS:'
HIDTHOT# DC    C'NUMBER OF CURRENTLY HOT DEVICES PER CHANNEL PATH:'
HIDTHOTS DC    C'          .0 .1 .2 .3 .4 .5 .6 .7 .8 .9 .A .B .C .D .E*
                .F'
DASH     DC    C'-'
HIDTNSCD DC    C'THERE ARE NO HOT S.C.D.S ALLOCATED.'
SCD@MSG  DC    C'S.C.D. AT:'
SCDDEVM1 DC    C'DEVICE NUMBER:'
SCDDEVM2 DC    C'ASSOCIATED DEVIC'
SCDDEVM3 DC    C'E NUMBER:'
SCDCPIM1 DC    C'CHANNEL PATH OF '
SCDCPIM2 DC    C'INTERRUPT:'
SCDTIMEM DC    C'INTERRUPT OCCURED AT:  '
SCDRECM1 DC    C'RECOVERY ACTION BITS SET:'
SCDGRPIX DC    C'GROUP INDEX:'
SCDLPUM  DC    C'L.P.U.M.:'
SCDINTCT DC    C'INTERRUPT COUNT:'
SCDTOTAL DC    C'TOTAL COUNT:'
SCDRECM2 DC    C'RECOVERY ACTION:'
SCDEXMSG DC    C'S.C.D. EXTENSION (INCLUDING I.R.B. FROM LAST INTERRUPT*
               ):'
         SPACE 1
         DS    0F                  ALIGN PATTERNS TO WORD BOUNDARY.
PATTERN1 DC    AL1(@D+D+CS,0*16+3,0,L'HIDT@MSG) HIDT ADDRESS LINE.
LPATTRN1 EQU   *-PATTERN1
         SPACE 1
PATTERN2 DC    AL1(@D+D+CS,0*16+1,0,L'HIDTTHRS) HIDT THRESHOLD LINE.
LPATTRN2 EQU   *-PATTERN2
         SPACE 1
PATTERN3 DC    AL1(@D+D+CS,0*16+3,0,5)       - SCD SCAN TABLE ADDRESS.
         DC    AL4(0)
         DC    AL1(D+CS,0*16+3,0,14)
         DC    AL1(D+CS,0*16+3,0,23)
         DC    AL1(D+CS,0*16+3,0,32)
         DC    AL1(D+CS,0*16+3,0,41)
         DC    AL1(D+CS,0*16+3,0,50)
         DC    AL1(D+CS,0*16+3,0,59)
         DC    AL1(D+CS,0*16+3,0,68)
LPATTRN3 EQU   *-PATTERN3
         SPACE 1
PATTERN4 DC    AL1(@D+D+CS,0*16+0,0,5)       - HOT COUNTS PER CHPID.
         DC    AL4(0)                        - INDEX ADDRESS
         DC    AL1(@D+D+@L+L+CS,0*16+0,8,10) - 0
         DC    AL4(DASH,0)                   - A(LABEL,DATA)
         DC    AL1(D+CS,0*16+0,0,13)         - 1
         DC    AL1(D+CS,0*16+0,0,16)         - 2
         DC    AL1(D+CS,0*16+0,0,19)         - 3
         DC    AL1(D+CS,0*16+0,0,22)         - 4
         DC    AL1(D+CS,0*16+0,0,25)         - 5
         DC    AL1(D+CS,0*16+0,0,28)         - 6
         DC    AL1(D+CS,0*16+0,0,31)         - 7
         DC    AL1(D+CS,0*16+0,0,34)         - 8
         DC    AL1(D+CS,0*16+0,0,37)         - 9
         DC    AL1(D+CS,0*16+0,0,40)         - A
         DC    AL1(D+CS,0*16+0,0,43)         - B
         DC    AL1(D+CS,0*16+0,0,46)         - C
         DC    AL1(D+CS,0*16+0,0,49)         - D
         DC    AL1(D+CS,0*16+0,0,52)         - E
         DC    AL1(D+CS,0*16+0,0,55)         - F
LPATTRN4 EQU   *-PATTERN4
         SPACE 1
PATTERN5 DC    AL1(@D+D+@L+L+CS,(L'SCD@MSG-1)*16+3,0,L'SCD@MSG+2)
         DC    A(SCD@MSG)
LPATTRN5 EQU   *-PATTERN1
         SPACE 1
PATTERN6 DC    AL1(@D+D+@L+L+CS,(L'SCDDEVM1-1)*16+1,0,L'SCDDEVM1+2)
         DC    A(SCDDEVM1,0)
         DC    AL1(L,(L'SCDDEVM2-1)*16+0,L'SCDDEVM1+8,0)
         DC    AL1(L+@D+D+CS,(L'SCDDEVM3-1)*16+1,L'SCDDEVM1+L'SCDDEVM2+*
               8,L'SCDDEVM1+L'SCDDEVM2+L'SCDDEVM3+10)
LPATTRN6 EQU   *-PATTERN6
         SPACE 1
PATTERN7 DC    AL1(@L+L,(L'SCDCPIM1-1)*16+0,0,0)
         DC    A(SCDCPIM1)
         DC    AL1(L+@D+D+CS,(L'SCDCPIM2-1)*16+0,L'SCDCPIM1,L'SCDCPIM1+*
               L'SCDCPIM2+2)
LPATTRN7 EQU   *-PATTERN7
         SPACE 1
PATTERN8 DC    AL1(@L+L+@D+D+CS,(L'SCDGRPIX-1)*16+0,0,L'SCDGRPIX+2)
         DC    A(SCDGRPIX)
LPATTRN8 EQU   *-PATTERN8
         SPACE 1
PATTERN9 DC    AL1(@L+L+@D+D+CS,(L'SCDLPUM-1)*16+0,0,L'SCDLPUM+2)
         DC    A(SCDLPUM,0)
         DC    AL1(D+CS,0,0,L'SCDLPUM+5)
         DC    AL1(D+CS,0,0,L'SCDLPUM+8)
         DC    AL1(D+CS,0,0,L'SCDLPUM+11)
LPATTRN9 EQU   *-PATTERN9
         SPACE 1
PATTERNA DC    AL1(@L+L+@D+D+CS,(L'SCDINTCT-1)*16+1,0,L'SCDINTCT+2)
         DC    A(SCDINTCT,0)
         DC    AL1(D+CS,1,0,L'SCDINTCT+7)
         DC    AL1(D+CS,1,0,L'SCDINTCT+12)
         DC    AL1(D+CS,1,0,L'SCDINTCT+17)
LPATTRNA EQU   *-PATTERNA
         SPACE 1
PATTERNB DC    AL1(@L+L+@D+D+CS,(L'SCDTOTAL-1)*16+1,0,L'SCDTOTAL+2)
         DC    A(SCDTOTAL)
LPATTRNB EQU   *-PATTERNB
         SPACE 1
PATTERNC DC    AL1(@L+L+@D+D+CS,(L'SCDRECM2-1)*16+0,0,L'SCDRECM2+2)
         DC    A(SCDRECM2)
LPATTRNC EQU   *-PATTERNC
         SPACE 1
MVC1     MVC   5(0,R15),1(R5)       *** EXECUTED ***
TM1      TM    0(R4),0              *** EXECUTED ***
         EJECT
***********************************************************************
*                                                                     *
*        MESSAGE TABLE USED TO CHECK FOR FLAG BITS IN THE SCD         *
*                                                                     *
*        MESSAGE TABLE FORMAT:                                        *
*           +0 = OFFSET OF FLAG IN SCD.                               *
*           +1 = FLAG BIT CORRESPONDING TO MESSAGE.                   *
*           +2 = FOUR BYTE ADDRESS OF MESSAGE "SYMBL" (LENGTH BYTE    *
*                PLUS MESSAGE TEXT).                                  *
*                                                                     *
***********************************************************************
         SPACE 1
MSGTBL   DS    0F                  MESSAGE BIT-MASK TABLE.
         DC    X'0780',AL4(MSGTXT01) SCD ASSOCIATED W/UCB.
         DC    X'0740',AL4(MSGTXT02) SLIH WAITING FOR 'RUPT.
         DC    X'0720',AL4(MSGTXT03) CLEAR RECOVERY SCHEDULED.
         DC    X'0710',AL4(MSGTXT04) FULL RECOVERY SCHEDULED.
         DC    X'1080',AL4(MSGTXT05) ICC/CCC INTERRUPT GROUP.
         DC    X'1040',AL4(MSGTXT06) UNIT CHECK INTERRUPT GROUP.
         DC    X'1020',AL4(MSGTXT07) ATTENTION/UDE INTERRUPT GROUP.
         DC    X'1010',AL4(MSGTXT08) OTHER INTERRUPT GROUP.
         DC    X'2880',AL4(MSGTXT09) DEFAULT PROCESSING TAKEN.
         DC    X'2840',AL4(MSGTXT10) OPERATOR PROMPTED FOR ACTION.
         DC    X'2980',AL4(MSGTXT11) ASSOCIATED MESSAGE:  IOS110A
         DC    X'2940',AL4(MSGTXT12) ASSOCIATED MESSAGE:  IOS111A
         DC    X'2920',AL4(MSGTXT13) ASSOCIATED MESSAGE:  IOS112A
         DC    X'3280',AL4(MSGTXT14) PREVIOUS:  CLRCH ATTEMPTED.
         DC    X'3240',AL4(MSGTXT15) PREVIOUS:  CHAN PATH OFFLINE.
         DC    X'3220',AL4(MSGTXT16) PREVIOUS:  CPR IN PROGRESS.
         DC    X'3210',AL4(MSGTXT17) PREVIOUS:  BOXED WHEN HOT.
         DC    X'3208',AL4(MSGTXT18) PREVIOUS:  NO UCB FOUND.
         DC    X'3380',AL4(MSGTXT19) CURRENT:  CLRCH ATTEMPTED.
         DC    X'3340',AL4(MSGTXT20) CURRENT:  CHAN PATH OFFLINE.
         DC    X'3320',AL4(MSGTXT21) CURRENT:  CPR IN PROGRESS.
         DC    X'3310',AL4(MSGTXT22) CURRENT:  BOXED WHEN HOT.
         DC    X'3308',AL4(MSGTXT23) CURRENT:  NO UCB FOUND.
         DC    X'0000'              END MARKER.
         SPACE 1
MSGTXT01 SYMBL 'SCDASSC  - SCD ASSOCIATED WITH A UCB.'
MSGTXT02 SYMBL 'SCDSLIHW - SLIH WAITING FOR AN INTERRUPT IN ORDER TO MA*
               KE DEVICE STATUS PENDING.'
MSGTXT03 SYMBL 'SCDRSCHC - CLEAR RECOVERY SCHEDULED BUT NOT COMPLETED.'
MSGTXT04 SYMBL 'SCDRSCHF - FULL RECOVERY SCHEDULED BUT NOT COMPLETED.'
MSGTXT05 SYMBL 'SCDDPICC - ICC/CCC INTERRUPT GROUP.'
MSGTXT06 SYMBL 'SCDDPUC  - UNIT CHECK INTERRUPT GROUP.'
MSGTXT07 SYMBL 'SCDDPATD - ATTENTION/UDE INTERRUPT GROUP.'
MSGTXT08 SYMBL 'SCDDPOTH - OTHER INTERRUPT GROUP.'
MSGTXT09 SYMBL 'SCDRDFLT - DEFAULT PROCESSING SPECIFIED IN IOSRHIDT USE*
               D.'
MSGTXT10 SYMBL 'SCDROPER - RECOVERY ACTION OBTAINED FROM THE OPERATOR.'
MSGTXT11 SYMBL 'SCDR110  - IOS110A WAS THE ASSOCIATED MESSAGE.'
MSGTXT12 SYMBL 'SCDR111  - IOS111A WAS THE ASSOCIATED MESSAGE.'
MSGTXT13 SYMBL 'SCDR112  - IOS112A WAS THE ASSOCIATED MESSAGE.'
MSGTXT14 SYMBL 'SCDRCLR  - PREVIOUS ACTIONS:  ATTEMPT HAS BEEN MADE TO *
               CORRECT THE HOT CONDITION WITH A CLEAR SUBCHANNEL.'
MSGTXT15 SYMBL 'SCDRCHOF - PREVIOUS ACTIONS:  RECOVERY HAS BEEN BYPASSE*
               D BECAUSE THE CHANNEL PATH WAS OFFLINE.'
MSGTXT16 SYMBL 'SCDRCHPI - PREVIOUS ACTIONS:  RECOVERY HAS BEEN BYPASSE*
               D BECAUSE CHANNEL PATH RECOVERY WAS IN PROGRESS.'
MSGTXT17 SYMBL 'SCDRBOXD - PREVIOUS ACTIONS:  RECOVERY WAS NOT DONE BEC*
               AUSE THE DEVICE WAS ALREADY BOXED.'
MSGTXT18 SYMBL 'SCDRUCBE - PREVIOUS ACTIONS:  RECOVERY WAS NOT DONE BEC*
               AUSE THE UCB COULD NOT BE FOUND.'
MSGTXT19 SYMBL 'SCDCCLR  - CURRENT ACTIONS:  ATTEMPT IS BEING MADE TO C*
               ORRECT THE HOT CONDITION WITH A CLEAR SUBCHANNEL.'
MSGTXT20 SYMBL 'SCDCCHOF - CURRENT ACTIONS:  RECOVERY IS BEING BYPASSED*
                BECAUSE THE CHANNEL PATH WAS OFFLINE.'
MSGTXT21 SYMBL 'SCDCCHPI - CURRENT ACTIONS:  COUNTS BEING DECREMENTED B*
               ECAUSE CHANNEL PATH RECOVERY WAS ALREADY IN PROGRESS.'
MSGTXT22 SYMBL 'SCDCBOXD - CURRENT ACTIONS:  RECOVERY NOT BEING DONE BE*
               CAUSE THE DEVICE WAS ALREADY BOXED.'
MSGTXT23 SYMBL 'SCDCUCBE - CURRENT ACTIONS:  RECOVERY WAS NOT DONE BECA*
               USE THE UCB COULD NOT BE FOUND.'
         EJECT
***********************************************************************
*                                                                     *
*        USER DEPENDENT AREA (GETMAINED TO PRESERVE REENTRANCY)       *
*                                                                     *
***********************************************************************
         SPACE 1
$DSECT   DSECT ,                   REENTRANT WORK AREA.
$SAVE    DS    18A                 SAVE AREA FOR SUBROUTINES.
         SPACE 1
$DOUBLE  DS    D                   CONVERSION WORK AREA.
         SPACE 1
$FORMAT  DS    0XL100              FORMAT PATTERN AREA.
$FMT1    DS    A                    - FORMAT PATTERN WORD 1.
$FMT2    DS    A                    - FORMAT PATTERN WORD 2.
$FMT3    DS    A                    - FORMAT PATTERN WORD 3.
$FMT4    DS    A                    - FORMAT PATTERN WORD 4.
$FMT5    DS    A                    - FORMAT PATTERN WORD 5.
$FMT6    DS    A                    - FORMAT PATTERN WORD 6.
$FMT7    DS    A                    - FORMAT PATTERN WORD 7.
$FMT8    DS    A                    - FORMAT PATTERN WORD 8.
$FMT9    DS    A                    - FORMAT PATTERN WORD 9.
$FMT10   DS    A                    - FORMAT PATTERN WORD 10.
$FMT11   DS    A                    - FORMAT PATTERN WORD 11.
$FMT12   DS    A                    - FORMAT PATTERN WORD 12.
$FMT13   DS    A                    - FORMAT PATTERN WORD 13.
$FMT14   DS    A                    - FORMAT PATTERN WORD 14.
$FMT15   DS    A                    - FORMAT PATTERN WORD 15.
$FMT16   DS    A                    - FORMAT PATTERN WORD 16.
$FMT17   DS    A                    - FORMAT PATTERN WORD 17.
$FMT18   DS    A                    - FORMAT PATTERN WORD 18.
$FMT19   DS    A                    - FORMAT PATTERN WORD 19.
$FMT20   DS    A                    - FORMAT PATTERN WORD 20.
$FMT21   DS    A                    - FORMAT PATTERN WORD 21.
$FMT22   DS    A                    - FORMAT PATTERN WORD 22.
$FMT23   DS    A                    - FORMAT PATTERN WORD 23.
$FMT24   DS    A                    - FORMAT PATTERN WORD 24.
$FMT25   DS    A                    - FORMAT PATTERN WORD 25.
         SPACE 1
$FLAG    DS    X                   FLAG FIELD AS FOLLOWS:
$TWOPASS EQU   X'80'                - SECOND PASS FIELD FOR HIDT.
         SPACE 1
$LENGTH  EQU   *-$DSECT            LENGTH OF REENTRANT AREA.
         EJECT
***********************************************************************
*                                                                     *
*        STATUS COLLECTION DATA AND HOT I/O DETECTION TABLE DSECTS    *
*                                                                     *
***********************************************************************
         SPACE 1
HIDT     DSECT ,                   GENERATE DUMMY SECTION.
HIDMODID DS    CL24                MODULE IDENTIFIER.
HIDDVTHR DS    H                   DEVICE THRESHOLD.
         DS    H                   *** RESERVED ***
HIDMSGDT DS    CL6                 RECOVERY DEFAULT ACTIONS.
         DS    H                   *** RESERVED ***
HIDHOTQ  DS    A                   ADDRESS OF HOT SCD QUEUE.
HIDSCAN  DS    16A                 ANCHOR OF SCD SCAN QUEUE.
HIDCPCNT DS    XL256               NUMBER OF HOT DEVICES PER CHPID.
HIDEND   EQU   *                   END MARKER.
         SPACE 2
SCD      DSECT ,                   GENERATE DUMMY SECTION.
SCDID    DC    CL4'SCD'            +00 - ACRONYM.
SCDDEV#  DS    H                   +04 - DEVICE NUMBER.
SCDCHP   DS    FL1                 +06 - CHANNEL PATH ID.
SCDINUSE DS    X                   +07 - SCD IN USE FLAGS.
SCDHDTM  DS    D                   +08 - TIME OF INTERRUPT.
SCDDIFPT DS    X                   +10 - DIFFERENT PATHS FLAG.
SCDGINDX DS    X                   +11 - GROUP INDEX.
SCDGLPUM DS    4X                  +12 - LPUM FROM LAST INTERRUPT.
SCDGCNT  DS    4H                  +16 - GROUP COUNTS OF INTERRUPTS.
SCDTCNT  DS    H                   +1E - TOTAL COUNT OF INTERRUPTS.
SCDHNEXT DS    A                   +20 - ADDRESS OF NEXT HOT QUEUE.
SCDXPTR  DS    A                   +24 - POINTER TO SCD EXTENSION.
SCDRINFO DS    X                   +28 - RECOVERY INFO.
SCDRMSG  DS    X                   +29 - MESSAGE TYPE.
SCDRACTN DS    X                   +2A - RECOVERY ACTION.
SCDRDEVN DS    XL2                 +2B - ASSOCIATED DEVICE NUMBER.
         DS    XL5                 +2D - UNUSED?
SCDROTHR DS    X                   +32 - MISCELLANEOUS RECOVERY FLAGS.
SCDCOTHR DS    X                   +33 - MORE MISCELLANEOUS FLAGS.
SCDEND   EQU   *                   +34 - END MARKER.
         SPACE 1
         PRINT ON,GEN,NODATA       WE'LL LET YOU SEE THE PARM LIST.
         EJECT
         IHAABDPL DSECT=YES        GENERATE DUMP PARAMETER LIST.
         SPACE 2
         END   AMXPRSCD
