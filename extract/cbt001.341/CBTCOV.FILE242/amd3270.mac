AMD3270  TITLE 'AMDAHL FULL-SCREEN DUMP ANALYSIS EXIT FOR AMDPRDMP.'
         MACRO
&LABEL   FIELD &PT=,&IC=,&FILL=,&PROT=,&AN=,&MDT=,&INTENS=,            *
               &DETECT=,&DISPLAY=,&X=,&Y=,&DATA=
         LCLA &STRDISP,&XDISP,&YDISP
         LCLC &ATTRIB,&XC,&YC,&XCIN,&YCIN
.*
         AIF   ('&PT' NE '' AND '&PT' NE 'Y' AND '&PT' NE 'N').ERR1
         AIF   ('&IC' NE '' AND '&IC' NE 'Y' AND '&IC' NE 'N').ERR2
         AIF   ('&PROT' NE '' AND '&PROT' NE 'U' AND '&PROT' NE 'P').ER*
               R3
         AIF   ('&AN' NE 'A' AND '&AN' NE 'S' AND '&AN' NE 'N' AND '&AN*
               ' NE '').ERR4
         AIF   ('&MDT' NE '' AND '&MDT' NE 'ON' AND '&MDT' NE 'OFF').ER*
               R5
         AIF   ('&INTENS' NE '' AND '&INTENS' NE 'HI' AND '&INTENS' NE *
               'LO').ERR6
         AIF   ('&DETECT' NE 'Y' AND '&DETECT' NE 'N' AND '&DETECT' NE *
               '').ERR7
         AIF   ('&DISPLAY' NE 'Y' AND '&DISPLAY' NE 'N' AND '&DISPLAY' *
               NE '').ERR8
.*
         AIF   ('&IC' EQ 'Y' AND '&PT' EQ 'Y').LERR1
         AIF   ('&PROT' EQ 'P' AND '&AN' EQ 'N').LERR2
         AIF   ('&PROT' EQ 'U' AND '&AN' EQ 'S').LERR3
         AIF   ('&INTENS' EQ 'HI' AND '&DISPLAY' EQ 'N').LERR4
         AIF   ('&DETECT' EQ 'Y' AND '&DISPLAY' EQ 'N').LERR5
         AIF   ('&X' EQ '' AND '&Y' NE '').LERR7
         AIF   ('&X' NE '' AND '&Y' EQ '').LERR7
         AIF   ('&FILL' NE '' AND '&X' EQ '').LERR8
         AIF   ('&INTENS' EQ 'HI' AND '&DETECT' EQ 'N').LERR12
.*
         AIF   ('&X' EQ '').NOCURS
         AIF   (&X LT 1 OR &X GT 80).ERR9
         AIF   (&Y LT 1 OR &Y GT 23).ERR10
&STRDISP SETA  (&Y-1)*80+&X
&YDISP   SETA  (&STRDISP-1)/64
&XDISP   SETA  &STRDISP-(&YDISP*64)
&XC      SETC  '40C1C2C3C4C5C6C7C8C94A4B4C4D4E4F50D1D2D3D4D5D6D7D8D95A5*
               B5C5D5E5F6061E2E3E4E5E6E7E8E96A6B6C6D6E6FF0F1F2F3F4F5F6F*
               7F8F97A7B7C7D7E7F'(&XDISP*2-1,2)
&YC      SETC  '40C1C2C3C4C5C6C7C8C94A4B4C4D4E4F50D1D2D3D4D5D6D7D8D95A5*
               B5C5D5E5F6061E2E3E4E5E6E7E8E96A6B6C6D6E6FF0F1F2F3F4F5F6F*
               7F8F97A7B7C7D7E7F'(&YDISP*2+1,2)
.NOCURS  ANOP
.*
&STRDISP SETA  0
         AIF   ('&PROT' EQ 'U').NOTPROT
&STRDISP SETA  32
.NOTPROT ANOP
         AIF   ('&AN' NE 'N' AND '&AN' NE 'S').ALPHA
&STRDISP SETA  &STRDISP+16
.ALPHA   ANOP
         AIF   ('&DISPLAY' NE 'N').DISPLAY
&STRDISP SETA  &STRDISP+12
         AGO   .CHKMDT
.DISPLAY ANOP
         AIF   ('&INTENS' NE 'HI').CHKDET
&STRDISP SETA  &STRDISP+8
         AGO   .CHKMDT
.CHKDET  ANOP
         AIF   ('&DETECT' NE 'Y').CHKMDT
&STRDISP SETA  &STRDISP+4
.CHKMDT  ANOP
         AIF   ('&MDT' NE 'ON').MDTOFF
&STRDISP SETA  &STRDISP+1
.MDTOFF  ANOP
&ATTRIB  SETC  '40C1C2C3C4C5C6C7C8C94A4B4C4D4E4F50D1D2D3D4D5D6D7D8D95A5*
               B5C5D5E5F6061E2E3E4E5E6E7E8E96A6B6C6D6E6FF0F1F2F3F4F5F6F*
               7F8F97A7B7C7D7E7F'(&STRDISP*2+1,2)
         AIF   ('&FILL' EQ '').NOFILL
         DC    X'3C&YC&XC',&FILL,X'1D&ATTRIB'
         AGO   .TRYTAB
.NOFILL  ANOP
         AIF   ('&X' EQ '').NOXY
         DC    X'11&YC&XC.1D&ATTRIB'
         AGO   .TRYTAB
.NOXY    ANOP
         DC    X'1D&ATTRIB'
.TRYTAB  ANOP
         AIF   ('&PT' NE 'Y').NOTAB
         DC    X'05'
         AGO   .NOCURS
.NOTAB   ANOP
         AIF   ('&IC' NE 'Y').NOIC
         DC    X'13'
.NOIC    ANOP
         AIF   ('&DATA' EQ '').MEXIT
         AIF   ('&DATA'(1,2) NE 'C''').LERR11
         AIF   ('&LABEL' EQ '').NOLABEL
&LABEL   DS    0X
.NOLABEL ANOP
D&SYSNDX DC    &DATA
.MEXIT   ANOP
         MEXIT
.ERR1    MNOTE 8,'PT=&PT MUST BE ''Y'' OR ''N''.'
         MEXIT
.ERR2    MNOTE 8,'IC=&IC MUST BE ''Y'' OR ''N''.'
         MEXIT
.ERR3    MNOTE 8,'PROT=&PROT MUST BE ''U'' OR ''P''.'
         MEXIT
.ERR4    MNOTE 8,'AN=&AN MUST BE ''A'', ''S'' OR ''N''.'
         MEXIT
.ERR5    MNOTE 8,'MDT=&MDT MUST BE ''ON'' OR ''OFF''.'
         MEXIT
.ERR6    MNOTE 8,'INTENS=&INTENS MUST BE ''HI'' OR ''LO''.'
         MEXIT
.ERR7    MNOTE 8,'DETECT-&DETECT MUST BE ''Y'' OR ''N''.'
         MEXIT
.ERR8    MNOTE 8,'DISPLAY=&DISPLAY MUST BE ''Y'' OR ''N''.'
         MEXIT
.ERR9    MNOTE 8,'X=&X VALUE MUST BE BETWEEN 1 AND 80.'
         MEXIT
.ERR10   MNOTE 8,'Y=&Y VALUE MUST BE BETWEEN 1 AND 23.'
         MEXIT
.*
.LERR1   MNOTE 8,'IC=Y AND PT=Y ARE MUTUALLY EXCLUSIVE.'
         MEXIT
.LERR2   MNOTE 8,'PROT=P AND AN=N ARE MUTUALLY EXCLUSIVE.'
         MEXIT
.LERR3   MNOTE 8,'PROT=U AND AN=S ARE MUTUALLY EXCLUSIVE.'
         MEXIT
.LERR4   MNOTE 8,'INTENS=HI AND DISPLAY=N ARE MUTUALLY EXCLUSIVE.'
         MEXIT
.LERR5   MNOTE 8,'DETECT=Y AND DISPLAY=N ARE MUTUALLY EXCLUSIVE.'
         MEXIT
.LERR7   MNOTE 8,'X OR Y COORDINATES ARE MISSING.'
         MEXIT
.LERR8   MNOTE 8,'FILL SPECIFIED WITHOUT X/Y COORDINATES.'
         MEXIT
.LERR11  MNOTE 8,'DATA=&DATA MUST BE A CHARACTER STRING.'
         MEXIT
.LERR12  MNOTE 8,'INTENS=HI AND DETECT=N ARE MUTUALLY EXCLUSIVE.'
         MEND
         SPACE 2
         MACRO
&LABEL   SBA   &X=,&Y=
         LCLA &STRDISP,&XDISP,&YDISP
         LCLC &ATTRIB,&XC,&YC,&XCIN,&YCIN
.*
         AIF   (&X LT 1 OR &X GT 80).ERR1
         AIF   (&Y LT 1 OR &Y GT 24).ERR2
&STRDISP SETA  (&Y-1)*80+&X
.CALC2   ANOP
&YDISP   SETA  (&STRDISP-1)/64
&XDISP   SETA  &STRDISP-(&YDISP*64)
&XC      SETC  '40C1C2C3C4C5C6C7C8C94A4B4C4D4E4F50D1D2D3D4D5D6D7D8D95A5*
               B5C5D5E5F6061E2E3E4E5E6E7E8E96A6B6C6D6E6FF0F1F2F3F4F5F6F*
               7F8F97A7B7C7D7E7F'(&XDISP*2-1,2)
&YC      SETC  '40C1C2C3C4C5C6C7C8C94A4B4C4D4E4F50D1D2D3D4D5D6D7D8D95A5*
               B5C5D5E5F6061E2E3E4E5E6E7E8E96A6B6C6D6E6FF0F1F2F3F4F5F6F*
               7F8F97A7B7C7D7E7F'(&YDISP*2+1,2)
.*
&LABEL   DC    X'&YC&XC'
         MEXIT
.*
.ERR1    MNOTE 8,'X=&X MUST BE BETWEEN 1 AND 80.'
         MEXIT
.ERR2    MNOTE 8,'Y=&Y MUST BE BETWEEN 1 AND 24.'
         MEND
         SPACE 2
         MACRO
         CURSORTB
         LCLA  &N,&M
         LCLB  &LABSET
CURSORTB DS    0X
.LOOP    ANOP
&N       SETA  &N+1
&M       SETA  &N+1
         AIF   (&N EQ 24).MEND
         SBA   X=15,Y=&M
         SBA   X=22,Y=&M
         DC    AL2($ADDR&N-$UDA)
         AIF   (&LABSET).SKIPLAB
&LABSET  SETB  1
LCURSENT EQU   *-CURSORTB
.SKIPLAB ANOP
         SBA   X=26,Y=&M
         SBA   X=33,Y=&M
         DC    AL2($WORD&N.A-$UDA)
         SBA   X=35,Y=&M
         SBA   X=42,Y=&M
         DC    AL2($WORD&N.B-$UDA)
         SBA   X=44,Y=&M
         SBA   X=51,Y=&M
         DC    AL2($WORD&N.C-$UDA)
         SBA   X=53,Y=&M
         SBA   X=60,Y=&M
         DC    AL2($WORD&N.D-$UDA)
         AGO   .LOOP
.MEND    ANOP
#CURSENT EQU   (*-CURSORTB)/LCURSENT
         MEND
         SPACE 2
         MACRO
         REGISTER
         LCLA  &N
.LOOP    ANOP
R&N      EQU   &N
&N       SETA  &N+1
         AIF   (&N LE 15).LOOP
         MEND
         SPACE 1
         MACRO
&L       PRINTBUF &TEXT
         LCLC  &L2
&L2      SETC  '&L'
         AIF   ('&TEXT' EQ '').NOMOVE
&L2      L     R15,ADPLBUF         GET BUFFER ADDRESS.
         MVI   0(R15),C' '         BLANK OUT FIRST BYTE.
         MVC   1(131,R15),0(R15)   CLEAR THE REST OF THE LINE.
         MVC   0(L'&TEXT,R15),&TEXT MOVE ITEM TO BUF'R.
&L2      SETC  ''
.NOMOVE  ANOP
&L2      LA    R1,ABDPL            ADDRESS PARAMETER LIST.
         L     R15,ADPLPRNT        EXTRACT PRINT ROUTINE ADDR.
         BALR  R14,R15             BRANCH TO PRINT SUBROUTINE.
         MEND
         SPACE 1
         MACRO
&L       FORMAT &PATTERN,&BADRC=
&L       LA    R0,&PATTERN         ADDRESS FORMAT PATTERN.
         LA    R1,ABDPL            ADDRESS PARAMETER LIST.
         L     R15,ADPLFRMT        EXTRACT FORMAT ROUTINE ADDR.
         BALR  R14,R15             BRANCH TO FORMAT SUBROUTINE.
         AIF   ('&BADRC' EQ '').NORC
         LTR   R15,R15             TEST RETURN CODE.
         BNZ   &BADRC              NON-ZERO, TAKE ABNORMAL EXIT.
.NORC    ANOP
         MEND
         SPACE 2
         MACRO
&LABEL   LOAD  &RESULT,&INPUT,&BADRC=
&LABEL   LA    R0,&INPUT           ADDRESS INPUT WITH REGISTER 0.
         LA    R1,ABDPL            ADDRESS PARAMETER LIST.
         L     R15,ADPLMEMA        LOAD ADDR OF MEMORY ROUTINE.
         BALR  R14,R15             BRANCH TO MEMORY SERVICE ROUTINE.
         LTR   R15,R15             MEMORY AVAILABLE?
         BNZ   &BADRC              NO, WE CAN'T CONTINUE.
         LR    R1,R0               LOAD RESULT POINTER INTO R1.
         ICM   &RESULT,B'1111',0(R1) LOAD AND TEST ACQUIRED STORAGE.
         MEND
         EJECT
***********************************************************************
*                                                                     *
*     AMD3270 - TSO/AMDPRDMP FULL-SCREEN DUMP ANALYSIS EXIT.          *
*                                                                     *
*     THIS PROGRAM IS DESIGNED TO EXECUTE AS AN AMDPRDMP EXIT OR      *
*     IPCS VERB EXIT.  IT PROVIDES THE USER WITH THE CAPABILITY       *
*     TO SCAN PORTIONS OF MEMORY ON A 3270-TYPE TERMINAL UNDER        *
*     TSO.  ADVANTAGES OF USING THIS EXIT RATHER THAN THE IPCS        *
*     "DSPL3270" SUBCOMMAND ARE AS FOLLOWS:                           *
*                                                                     *
*         1.  THE EXIT WILL RUN UNDER AMDPRDMP AS WELL AS IPCS.       *
*             THE USER DOES NOT HAVE TO ALLOCATE THE VSAM DATASETS    *
*             REQUIRED BY IPCS TO USE THE COMMAND.                    *
*         2.  THE EXIT WILL RUN UNDER BOTH MVS/XA AND MVS/370.        *
*         3.  IN MVS/XA, THE EXIT ALLOWS THE DISPLAYING OF DATA       *
*             FROM VIRTUAL AND REAL MEMORY AS WELL AS DATA FROM       *
*             THE CPU AND HEADER RECORDS OF THE DUMP.  IN MVS/370,    *
*             ONLY VIRTUAL MEMORY MAY BE ACCESSED.                    *
*         4.  THE DISPLAY WILL INCLUDE BOTH HEXADECIMAL AND EBCDIC    *
*             CHARACTER REPRESENTATION.                               *
*         5.  THE PRIME REASON FOR THE DEVELOPMENT OF THIS EXIT IS    *
*             THAT IT WILL ALLOW DISPLAYING DATA ADDRESSED BY 31-     *
*             BITS IN MVS/XA.  THE MVS/XA DSPL3270 SUBCOMMAND         *
*             IS RESTRICTED TO 24-BIT ADDRESSES.                      *
*                                                                     *
*     IN ORDER TO EXECUTE THE EXIT, THE USER MUST ADD THE EXIT'S      *
*     NAME AND LOAD MODULE NAME TO THE AMDPRDMP EXIT CONTROL TABLE.   *
*     THIS PROCESS IS DESCRIBED IN THE MVS SERVICE AIDS MANUAL.       *
*     OPTIONALLY, THE USER MAY INVOKE THIS EXIT UNDER IPCS USING      *
*     THE IPCS "VERBEXIT" SUBCOMMAND.                                 *
*                                                                     *
*     THIS MODULE FOLLOWS ALL THE CODING CONVENTIONS REQUIRED         *
*     FOR AMDPRDMP EXITS AS DESCRIBED IN THE ABOVE-MENTIONED          *
*     DOCUMENT.  IT IS REENTRANT, REUSABLE AND REFRESHABLE AND        *
*     MAY BE PLACED IN THE USER'S LINK-PACK AREA IF NECESSARY.        *
*     THE PROGRAM MUST BE ASSEMBLED USING THE MVS/XA VERSION OF       *
*     MACLIB TO ACCOUNT FOR EXTENSIONS TO THE ABDUMP PARAMETER LIST.  *
*                                                                     *
*     WHEN FIRST INVOKED, THE EXIT WILL DISPLAY VIRTUAL MEMORY        *
*     FROM ADDRESS ZERO.  THE USER MAY SELECT ANOTHER ADDRESS TO      *
*     BE DISPLAYED BY PLACING THE CURSOR UNDER THE DISPLAYED          *
*     ADDRESS WORD.  OPTIONALLY, THE USER MAY ENTER THE ADDRESS       *
*     IN THE FIRST-DISPLAYED ADDRESS WORD.  THE USER MAY ALSO         *
*     SPECIFY THE ASID.                                               *
*                                                                     *
*                                                                     *
*                                                                     *
*                                                                     *
*                                                                     *
*                                                                     *
*                                                                     *
*                                                                     *
***********************************************************************
         EJECT
***********************************************************************
*                                                                     *
*     SELECTION OF THE TYPE OF MEMORY TO BE DISPLAYED IS BASED ON     *
*     PROGRAM FUNCTION KEYS.  THE MEANING OF EACH PFK IS              *
*     DESCRIBED BELOW:                                                *
*                                                                     *
*         PF01 - HELP.                                                *
*         PF02 - TOGGLE BETWEEN 24- AND 31-BIT XA VIRTUAL MEMORY.     *
*         PF03 - EXIT.                                                *
*         PF04 - UNUSED                                               *
*         PF05 - UNUSED                                               *
*         PF06 - UNUSED                                               *
*         PF07 - SCROLL BACKWARDS.                                    *
*         PF08 - SCROLL FORWARDS.                                     *
*         PF09 - DISPLAY VIRTUAL.                                     *
*         PF10 - DISPLAY REAL (MVS/XA AMDPRDMP ONLY).                 *
*         PF11 - DISPLAY HEADER RECORD (MVS/XA ONLY).                 *
*         PF12 - DISPLAY CPU RECORD (MVS/XA ONLY).                    *
*          PA1 - STANDARD TSO ATTENTION.                              *
*          PA2 - REDISPLAY PREVIOUS PANEL.                            *
*        ENTER - DISPLAY VIRTUAL.                                     *
*                                                                     *
*    IF THE REQUESTED MEMORY CAN NOT BE ACCESSED, AN INDICATION       *
*    OF "N/A" MEANING NOT-AVAILABLE WILL APPEAR IN THE DISPLAY        *
*    WORD.                                                            *
*                                                                     *
***********************************************************************
         SPACE 2
         REGISTER
         EJECT
***********************************************************************
*                                                                     *
*        PERFORM HOUSEKEEPING, ACQUIRE USER-DEPENDENT AREA.           *
*                                                                     *
***********************************************************************
         SPACE 1
AMD3270  CSECT ,
         SAVE  (14,12),,AMD3270_FULL_SCREEN_DUMP_ANALYSIS_COPYRIGHT_198*
               5_AMDAHL_CORPORATION_SE_TOOLS_SETT010_AMDIPCSE
         LR    R12,R15         LOAD PROGRAM BASE.
         USING AMD3270,R12     MAKE PROGRAM ADDRESSABLE.
         LR    R10,R1          LOAD COPY OF ABDPL POINTER.
         USING ABDPL,R10       MAKE PARAMETER LIST ADDRESSABLE.
         LA    R0,$LENGTH      LOAD LENGTH OF USER-DEPENDENT AREA.
         ICM   R0,B'1000',ADPLSBPL INSERT SUBPOOL BYTE.
         GETMAIN R,LV=(0)      GET SOME MEMORY.
         LR    R11,R1          PRESERVE ADDRESS IN R11.
         LR    R2,R1           LOAD AREA ADDRESS INTO EVEN REGISTER.
         LA    R3,$LENGTH      LOAD LENGTH INTO FOLLOWING REGISTER.
         XR    R5,R5           ZERO THE FILL REGISTER.
         MVCL  R2,R4           CLEAR THE GETMAINED AREA.
         USING $UDA,R11        MAKE USER-DEPENDENT-AREA ADDRESSABLE.
         ST    R13,$SAVE+4     FORWARD CHAIN SAVE AREAS.
         LR    R2,R13          HOLD ADDRESS OF OLD SAVE AREA.
         LA    R13,$SAVE       ADDRESS NEW SAVE AREA.
         ST    R13,8(,R2)      BACK CHAIN SAVE AREAS.
         EJECT
***********************************************************************
*                                                                     *
*        USER AREA INITIALIZATION INCLUDES:                           *
*                                                                     *
*        1.  DETERMINE IF TSO USER ON 24X80 CRT.                      *
*        2.  INITIALIZING OUTPUT SCREEN BUFFER.                       *
*        3.  INITIALIZING FORMAT PATTERNS                             *
*        4.  DETERMINING IF DUMP IS FROM MVS/XA OR MVS/370.           *
*                                                                     *
***********************************************************************
         SPACE 1
         GTSIZE ,              LOAD TERMINAL SIZE.
         LTR   R15,R15         SUCCESSFUL GETSIZE?
         BNZ   ENVCHECK        NO, CAN'T CONTINUE.
         STM   R0,R1,$ENVDATA  SAVE CALLER'S SCREEN SIZE.
         CH    R1,=H'80'       LINE WIDTH 80?
         BL    ENVCHECK        TOO LOW, CAN'T CONTINUE.
         CH    R0,=H'24'       24 LINES?
         BL    ENVCHECK        TOO LOW, PROBABLY PRINTER.
         STSIZE LINE=24,SIZE=80 GO TO 24X80.
         SPACE 1
         L     R0,ADPLBUF      GET POINTER TO PRINT BUFFER.
         ST    R0,$ADPLBUF     SAVE FOR LATER.
         SPACE 1
         LA    R2,$TPUTBUF     ADDRESS OUTPUT AREA.
         LA    R3,LTPUTBUF     LOAD LENGTH TO MOVE.
         LA    R4,TPUTBUF      POINT TO SOURCE AREA.
         LR    R5,R3           COPY SENDING LENGTH.
         MVCL  R2,R4           MOVE TPUT BUFFER HEADER TO USER AREA.
         SPACE 1
         MVC   $PATTERN(LPATTERN),PATTERN MOVE IN SKELATON PATTERN.
         LA    R6,$DISPADR     POINT TO DISPLAY ADDRESS.
         ST    R6,$PAT@AD0     SAVE FOR ADDRESS DECODING.
         SPACE 1
         MVC   ADPLASID,=H'1'  ASSUME ASID 1.
         AIF   ('&SYSPARM' EQ '370').SKIP1
         L     R2,ADPLCVT      LOAD UP DUMPED CVT ADDRESS.
         LOAD  R2,CVTDCB(,R2),BADRC=GOREAL LOAD CVTDCB WORD.
         BM    XAMODE          HI BIT WAS ON, IT'S AN XA-MODE DUMP.
         MVI   ADPLPRDP,ADPLSAMK SET 24-BIT ONLY FLAG.
.SKIP1   ANOP
         MVC   $ANDMASK,AND24  USE 24-BIT ADDRESSES.
         MVC   $MODEMSG,MSG24  INDICATE 24-BIT VIRTUAL.
         AIF   ('&SYSPARM' EQ '370').SKIP2
         B     DISPLAY         AND GO DISPLAY LOCATION ZERO.
XAMODE   DS    0H
         MVI   ADPLPRDP,ADPLVIRT REQUEST 31-BIT VIRTUAL.
         MVC   $ANDMASK,AND31  USE 31-BIT ADDRESSES.
         MVC   $MODEMSG,MSG31  INDICATE 31-BIT VIRTUAL.
         B     DISPLAY         AND GO DISPLAY LOCATION ZERO.
GOREAL   DS    0H
         MVI   ADPLPRDP,ADPLREAL SET REAL-MEMORY FLAG.
         MVC   $ANDMASK,AND31  USE 31-BIT ADDRESSES.
         MVC   $MODEMSG,MSGREAL INDICATE REAL ADDRESSED
.SKIP2   ANOP
         EJECT
***********************************************************************
*                                                                     *
*     BUILD THE DISPLAY BUFFER BASED ON '$ADDRESS' AND DISPLAY IT.    *
*                                                                     *
***********************************************************************
         SPACE 1
DISPLAY  DS    0H
         UNPK  $DOUBLE(5),ADPLASID(3) UNPACK THE ASID.
         TR    $DOUBLE(4),TRTBL1-C'0' TRANSLATE TO PRINTABLE.
         MVC   $ASID(4),$DOUBLE MOVE TO DISPLAY AREA.
         LA    R2,$LINE1       ADDRESS FIRST LINE OF HEX DISPLAY.
         LA    R3,SBALIST      POINT TO SET-BUFFER-ADDRESS LIST.
         LA    R4,#SBAENT      LOAD LOOP ITERATION COUNTER.
         NI    $FLAG,255-$NOTAVAL ASSUME MEMORY IS AVAILABLE.
         AIF   ('&SYSPARM' EQ '370').SKIP3
         TM    ADPLPRDP,ADPLCPU CPU RECORD REQUESTED?
         BO    DOCPUREC        YES, SPECIAL CONSIDERATIONS HERE.
         TM    ADPLPRDP,ADPLHDR HEADER RECORD?
         BO    DOHEADER        YES, SPECIAL CONSIDERATIONS HERE TOO.
.SKIP3   ANOP
         L     R6,$ADDRESS     LOAD ADDRESS OF WORK FIELD.
         LR    R7,R6           COPY DISPLAY LEGEND ADDRESS.
         NI    $PATFLG2,255-CALLSTG DATA IS FROM DUMP RECORDS.
         NI    $PATFLG3,255-CALLSTG DATA IS FROM DUMP RECORDS.
         NI    $PATFLG4,255-CALLSTG DATA IS FROM DUMP RECORDS.
         NI    $PATFLG5,255-CALLSTG DATA IS FROM DUMP RECORDS.
         NI    $PATFLG6,255-CALLSTG DATA IS FROM DUMP RECORDS.
         B     LOOP            GO GET THE DATA.
DOCPUREC DS    0H
         LH    R0,ADPLASID     LOAD THE CPUID (FROM ASID FIELD).
DOHEADER DS    0H
         LA    R1,ABDPL        POINT TO AB/DUMP PARM LIST.
         L     R15,ADPLMEMA    GET ADDRESS OF MEMORY ACCESS ROUTINE.
         BALR  R14,R15         LINK TO SERVICE ROUTINE.
         LTR   R15,R15         DID WE GET IT?
         BZ    GOTMEM          YES, SKIP FLAG RAISING.
         OI    $FLAG,$NOTAVAL  SET NOT AVAILABLE FLAG.
         B     LOOP            GO FORMAT THE N/A LINES.
GOTMEM   DS    0H
         LA    R1,L'$WORKBUF   LOAD #-BYTES DISPLAYED ON A SCREEN.
         AIF   ('&SYSPARM' EQ '370').SKIP4
         TM    ADPLPRDP,ADPLCPU CPU RECORD?
         BNO   NOTCPU          NOPE, LENGTH ASSUMPTION CORRECT.
         LA    R1,192          X'C0' BYTES IN A CPU RECORD.
         XC    $WORKBUF+192(L'$WORKBUF-192),$WORKBUF+192 ZERO THE REST.
NOTCPU   DS    0H
.SKIP4   ANOP
         LR    R7,R1           SET RECEIVING LENGTH.
         LA    R6,$WORKBUF     POINT TO RECEIVING ADDRESS.
         MVCL  R6,R0           MOVE DATA TO OUR BUFFER.
         LA    R6,$WORKBUF     RESET R6 (MVCL MESSED IT UP).
         OI    $PATFLG2,CALLSTG SET DATA-IN-CALLER-STORAGE FLAG.
         OI    $PATFLG3,CALLSTG SET DATA-IN-CALLER-STORAGE FLAG.
         OI    $PATFLG4,CALLSTG SET DATA-IN-CALLER-STORAGE FLAG.
         OI    $PATFLG5,CALLSTG SET DATA-IN-CALLER-STORAGE FLAG.
         OI    $PATFLG6,CALLSTG SET DATA-IN-CALLER-STORAGE FLAG.
         XR    R7,R7           ZERO THE DISPLAY LEGEND.
         SPACE 1
LOOP     DS    0H
         MVI   0(R2),SBA       MOVE IN SET-BUFFER-ADDRESS CHARACTER.
         MVC   1(2,R2),0(R3)   MOVE IN LINE'S BUFFER ADDRESS.
         LA    R5,L'$LINE1(,R2) POINT TO FIRST TEXT AREA.
         ST    R5,ADPLBUF      SAVE UPDATED BUFFER POINTER.
         MVC   0(LNOTAVAL,R5),NOTAVAIL ASSUME MEMORY IS NOT AVAILABLE.
         N     R7,$ANDMASK     AND THE ADDRESS TO BE DISPLAYED.
         ST    R7,$DISPADR     SAVE FOR FORMAT ROUTINE.
         TM    $FLAG,$NOTAVAL  WAS CPU OR HEADER NOT AVAILABLE?
         BO    NEXTLINE        YES, SKIP FORMATTING STUFF.
         AIF   ('&SYSPARM' EQ '370').SKIP5
         TM    ADPLPRDP,ADPLCPU+ADPLHDR HEADER OR CPU REQUEST?
         BNZ   SKIPAND         YES, USE UN-ALIGNED ADDRESS.
         N     R6,$ANDMASK     AND THE ADDRESS TO BE DISPLAYED.
SKIPAND  DS    0H
.SKIP5   ANOP
         ST    R6,$PAT@AD1     SAVE FOR DATA DECODING WORD 1 IN HEX.
         ST    R6,$PAT@AD5     SAVE FOR DATA DECODING IN EBCDIC.
         LR    R8,R6          +COPY ADDRESS INTO REGISTER 8.
         AL    R8,=F'4'       +INCREMENT TO NEXT WORD.
         ST    R8,$PAT@AD2    +SAVE FOR DATA DECODING WORD 2 IN HEX.
         AL    R8,=F'4'       +INCREMENT TO NEXT WORD.
         ST    R8,$PAT@AD3    +SAVE FOR DATA DECODING WORD 3 IN HEX.
         AL    R8,=F'4'       +INCREMENT TO NEXT WORD.
         ST    R8,$PAT@AD4    +SAVE FOR DATA DECODING WORD 4 IN HEX.
         FORMAT $PATTERN       FORMAT THE LINE.
NEXTLINE DS    0H
         CH    R4,=H'23'       STILL ON FIRST LINE?
         BNE   NOT1ST          NOPE, LEAVE ATTRIBUTE ALONE.
         MVC   0(2,R5),FIRSTAD SET UNPROTECTED FLAG FOR FIRST ADDRESS.
NOT1ST   DS    0H
         TR    57(16,R5),TRTBL2 TRANSLATE EBCDIC TO PRINTABLE.
         LA    R2,LNOTAVAL+3(,R2) BUMP TO NEXT LINE POINTER.
         LA    R3,LSBAENT(,R3) INCREMENT TO NEXT SBA.
         AL    R6,=F'16'       INCREMENT TO NEXT INPUT LINE.
         AL    R7,=F'16'       INCREMENT TO NEXT DISPLAY ADDRESS.
         BCT   R4,LOOP         BUILD ALL 23 DISPLAY LINES.
         MVC   $SBAIC,SBAIC    MOVE IN INSERT-CURSOR SEQUENCE.
         SPACE 1
         LA    R1,$TPUTBUF     LOAD ADDRESS OF TPUT BUFFER.
         LA    R0,$TPUTLEN     LOAD LENGTH TO DISPLAY.
         ICM   R1,B'1000',TPUTFULL INSERT FULL-SCREEN ATTRIBUTE.
         TPUT  (1),(0),R       WRITE THE SCREEN.
         EJECT
***********************************************************************
*                                                                     *
*     GET THE RESPONSE AND EXAMINE IT.                                *
*                                                                     *
*     1.  IF ASID WAS SPECIFIED, USE IT.                              *
*     2.  IF AN ADDRESS WAS SPECIFIED, USE IT.                        *
*     3.  IF THE CURSOR WAS BENEATH ANY DISPLAYED ADDRESS, USE IT.    *
*     4.  PROCESS ACCORDING TO AID-KEY ENTERED.                       *
*                                                                     *
***********************************************************************
         SPACE 1
         TCLEARQ INPUT         CLEAR ANY STACKED INPUT.
         LA    R1,$INPUT       ADDRESS INPUT BUFFER.
         LA    R0,L'$INPUT     LOAD MAX. LENGTH TO READ.
         ICM   R1,B'1000',TGETASIS INSERT TGET FLAG BITS.
         XC    $INPUT,$INPUT   CLEAR PREVIOUS GARBAGE.
         TGET  (1),(0),R       GET USER'S RESPONSE.
         CLI   $INPUT,X'6E'    PA2 KEY DEPRESSED?
         BE    DISPLAY         SKIP OTHER STUFF AND JUST REDISPLAY.
         SPACE 1
         LA    R2,$INPUT       ADDRESS INPUT BUFFER.
         LA    R3,L'$INPUT     LOAD LENGTH OF INPUT BUFFER.
SBALOOP1 DS    0H
         CLI   0(R2),SBA       FOUND A SET-BUFFER-ADDRESS BYTE?
         BNE   NEXTSBA1        NOPE, LOOP ON THROUGH ALL THE INPUT.
         CLC   ASIDSBA,1(R2)   CURSOR ADDRESS EQUAL ASID?
         BNE   NEXTSBA1        NOPE, LOOP ON THROUGH.
         OC    3(4,R2),=CL8' ' UPCASE THE REPLY.
         TR    3(4,R2),TRTBL3-C'A' TRANSLATE TO ZONED.
         PACK  $DOUBLE(3),3(5,R2) PACK THE RESULT.
         MVC   ADPLASID,$DOUBLE MOVE RESULT TO PARM LIST.
         B     CHEKADDR        SEE IF ADDRESS WAS SPECIFIED.
NEXTSBA1 DS    0H
         LA    R2,1(,R2)       NOPE, TRY NEXT BYTE.
         BCT   R3,SBALOOP1     CHECK EACH INPUT BYTE FOR SBA.
         SPACE 1
CHEKADDR DS    0H
         LA    R2,$INPUT       ADDRESS INPUT BUFFER.
         LA    R3,L'$INPUT     LOAD LENGTH OF INPUT BUFFER.
SBALOOP2 DS    0H
         CLI   0(R2),SBA       FOUND A SET-BUFFER-ADDRESS BYTE?
         BNE   NEXTSBA2        NOPE, LOOP ON THROUGH ALL THE INPUT.
         CLC   ADDRSBA,1(R2)   CURSOR ADDRESS EQUAL DISP. ADDRESS?
         BNE   NEXTSBA2        NOPE, THROW IT AWAY.
         OC    3(8,R2),=CL8' ' UPCASE THE REPLY.
         TR    3(8,R2),TRTBL3-C'A' TRANSLATE TO ZONED.
         PACK  $DOUBLE(5),3(9,R2) PACK THE RESULT.
         MVC   $ADDRESS,$DOUBLE MOVE RESULT TO USER-DEPENDENT AREA.
         B     CHEKPFK         SKIP CURSOR ADDRESS LOOKUP.
NEXTSBA2 DS    0H
         LA    R2,1(,R2)       NOPE, TRY NEXT BYTE.
         BCT   R3,SBALOOP2     CHECK EACH INPUT BYTE FOR SBA.
         SPACE 1
CHEKCURS DS    0H
         LA    R2,CURSORTB     POINT R2 AT CURSOR TABLE.
         LA    R3,#CURSENT     LOAD R3 WITH COUNT OF ENTRIES.
         NC    $INPUT+1(2),=X'7F7F7F7F' TURN OFF HI-BITS OF ADDRESSES.
CURSLOOP DS    0H
         L     R4,0(,R2)       LOAD BOTH ADDRESS COMPARANDS.
         N     R4,=X'7F7F7F7F' TURN OFF HI-BITS OF ADDRESSES.
         CLM   R4,B'1100',$INPUT+1 CURSOR WITHIN LOW BOUNDARY?
         BH    NEXTCURS        NOPE, GET THE NEXT ONE.
         CLM   R4,B'0011',$INPUT+1 CURSOR WITHIN HIGH BOUNDARY?
         BL    NEXTCURS        NOPE, GET THE NEXT ONE.
         XR    R1,R1           ZONK FOR INSERT.
         ICM   R1,B'0011',4(R2) INSERT THE ADDRESS-WORD'S OFFSET.
         LA    R1,$UDA(R1)     GET OFFSET WITHIN DSECT.
         CLC   2(8,R1),SAMPNA  DOES CURSOR POINT TO "N/A"?
         BE    CHEKPFK         YES, CONTINUE WITH PF-KEY CHECKS.
         TR    2(8,R1),TRTBL3-C'A' TRANSLATE TO ZONED.
         PACK  $DOUBLE(5),2(9,R1) PACK THE RESULT.
         MVC   $ADDRESS,$DOUBLE MOVE RESULT TO USER-DEPENDENT AREA.
         B     CHEKPFK         GO ATTEND TO PFK CHECKING.
NEXTCURS DS    0H
         LA    R2,LCURSENT(,R2) INCREMENT TO NEXT CURSOR TABLE ENTRY.
         BCT   R3,CURSLOOP     RUN THROUGH CURSOR TABLE.
         SPACE 1
CHEKPFK  DS    0H
         LA    R2,PFKTABLE     POINT TO PROGRAM-FUNCTION-KEY TABLE.
         LA    R3,#PFKENT      LOAD COUNT OF TABLE ENTRIES.
PFKLOOP  DS    0H
         CLC   $INPUT(1),0(R2) INPUT AID MATCH TABLE ENTRY?
         BE    GOTPFK          YES, GO PROCESS IT.
         LA    R2,LPFKENT(,R2) NO, POINT TO NEXT PFK-TABLE ENTRY.
         BCT   R3,PFKLOOP      CHECK EACH POSSIBLE ENTRY.
GOTPFK   DS    0H
         L     R15,2(,R2)      LOAD CORRESPONDING ROUTINE ADDRESS.
         BR    R15             BRANCH TO THE ROUTINE.
         EJECT
***********************************************************************
*                                                                     *
*        PROCESS EACH PROGRAM FUNCTION KEY.                           *
*                                                                     *
***********************************************************************
         SPACE 1
PFK01    DS    0H
         TPUT  HELP,LHELP,FULLSCR WRITE THE HELP SCREEN.
         LA    R1,$INPUT       ADDRESS THROW-AWAY BUFFER.
         LA    R0,L'$INPUT     LOAD MAXIMUM LENGTH OF BUFFER.
         ICM   R1,B'1000',TGETASIS INSERT TGET FUNCTION BITS.
         TGET  (1),(0),R       GET RESPONSE.
         TCLEARQ INPUT         THROW ANY LEFTOVERS AWAY.
         B     DISPLAY         RE-DISPLAY PREVIOUS SCREEN.
         SPACE 2
PFK02    DS    0H
         AIF   ('&SYSPARM' EQ '370').SKIP6
         CLI   ADPLPRDP,ADPLSAMK 370-MODE DUMP?
         BE    DISPLAY         YES, DON'T TOGGLE MODE BITS.
         MVI   ADPLPRDP,ADPLVIRT MAKE SURE WE'RE GETTING VIRTUAL.
         CLC   $ANDMASK,AND24  WAS PREVIOUS MASK FOR 24-BIT?
         BE    GO31MODE        YES, GO TO 31-BIT MODE.
.SKIP6   ANOP
         MVC   $ANDMASK,AND24  NO, GO TO 24-BIT MODE.
         MVC   $MODEMSG,MSG24 MOVE IN APPROPRIATE MESSAGE.
         B     DISPLAY          AND GO GET THE DATA.
GO31MODE DS    0H
         MVC   $ANDMASK,AND31   MOVE IN 31-BIT AND MASK.
         MVC   $MODEMSG,MSG31 MOVE IN 31-BIT DISPLAY MESSAGE.
         B     DISPLAY
         SPACE 2
PFK03    DS    0H
         LA    R1,WRAPUP        ADDRESS WRAPUP BUFFER.
         LA    R0,LWRAPUP       LOAD JUST ENOUGHT LENGTH TO CLEAR.
         ICM   R1,B'1000',TPUTFULL LOAD TPUT-FULL-SCREEN BITS.
         TPUT  (1),(0),R        ISSUE TPUT.
         STLINENO LINE=1        SIGNAL VTAM FOR SURE.
         SPACE 1
         STSIZE LINELOC=$ENVDATA,SIZELOC=$ENVDATA+4 RESTORE SCRSIZE.
         SPACE 1
         L     R0,$ADPLBUF      GET PRINT BUFFER LOCATION.
         ST    R0,ADPLBUF       RESTORE CALLER'S BUFFER POINTER.
         SPACE 1
RETURN   DS    0H
         LR    R1,R11           LOAD ADDRESS OF USER-DEPENDENT AREA.
         LA    R0,$LENGTH       LOAD LENGTH TO BE FREEMAINED.
         ICM   R0,B'1000',ADPLSBPL LOAD SUBPOOL NUMBER.
         L     R13,4(,R13)      SALVAGE SAVE AREA POINTER.
         FREEMAIN R,A=(1),LV=(0) FREEMAIN THE USER AREA.
         LM    R14,R12,12(R13)  RESTORE CALLER'S REGISTERS.
         XR    R15,R15          ZERO THE RETURN CODE.
         BR    R14              RETURN TO CALLER.
         SPACE 2
PFK07    DS    0H
         L     R0,$ADDRESS      LOAD CURRENT DISPLAY ADDRESS.
         SL    R0,SCROLL        SUBTRACT SCROLL AMOUNT.
         ST    R0,$ADDRESS      SAVE FOR DISPLAY CODE.
         B     DISPLAY          GO DO IT TO IT.
         SPACE 2
PFK08    DS    0H
         L     R0,$ADDRESS      LOAD CURRENT DISPLAY ADDRESS.
         AL    R0,SCROLL        ADD SCROLL AMOUNT.
         ST    R0,$ADDRESS      SAVE FOR DISPLAY CODE.
         B     DISPLAY          GO DO IT TO IT.
         SPACE 2
PFK09    DS    0H
         AIF   ('&SYSPARM' EQ '370').SKIP7
         CLI   ADPLPRDP,ADPLSAMK 370-MODE DUMP?
         BE    DISPLAY         YES, SAY NO MORE.
         MVI   ADPLPRDP,ADPLVIRT SET VIRTUAL MODE FLAG.
         MVC   $MODEMSG,MSG31 SET THE 31-BIT MESSAGE.
.SKIP7   ANOP
         B     DISPLAY         AND DISPLAY THE REQUESTED DATA.
         SPACE 2
PFK10    DS    0H
         AIF   ('&SYSPARM' EQ '370').SKIP8
         CLI   ADPLPRDP,ADPLSAMK 370-MODE DUMP?
         BE    DISPLAY         YES, CAN'T DISPLAY REAL IN 370-MODE.
         MVI   ADPLPRDP,ADPLREAL REQUEST REAL MEMORY DISPLAY.
         MVC   $ANDMASK,AND31  WE WOULD LIKE 31-BIT REAL.
         MVC   $MODEMSG,MSGREAL SET REAL-MEMORY DISPLAY MESSAGE.
.SKIP8   ANOP
         B     DISPLAY
         SPACE 2
PFK11    DS    0H
         AIF   ('&SYSPARM' EQ '370').SKIP9
         CLI   ADPLPRDP,ADPLSAMK 370-MODE DUMP?
         BE    DISPLAY         YES, CAN'T DISPLAY HEADER IN 370-MODE.
         MVI   ADPLPRDP,ADPLHDR REQUEST HEADER MEMORY DISPLAY.
         MVC   $ANDMASK,AND31  WE WOULD LIKE 31-BIT DATA.
         MVC   $MODEMSG,MSGHDR SET REAL-MEMORY DISPLAY MESSAGE.
.SKIP9   ANOP
         B     DISPLAY
         SPACE 2
PFK12    DS    0H
         AIF   ('&SYSPARM' EQ '370').SKIP10
         CLI   ADPLPRDP,ADPLSAMK 370-MODE DUMP?
         BE    DISPLAY         YES, CAN'T DISPLAY CPU IN 370-MODE.
         MVI   ADPLPRDP,ADPLCPU REQUEST CPU RECORD DISPLAY.
         MVC   $ANDMASK,AND31  WE WOULD LIKE 31-BIT DATA.
         MVC   $MODEMSG,MSGCPU SET CPU-RECORD DISPLAY MESSAGE.
.SKIP10  ANOP
         B     DISPLAY
         SPACE 2
ENVCHECK DS    0H
         PRINTBUF ENVMSG       PRINT BAD-ENVIRONMENT MESSAGE.
         B     RETURN          RETURN TO AMDPRDMP OR IPCS.
         EJECT
***********************************************************************
*                                                                     *
*                              CONSTANTS                              *
*                                                                     *
***********************************************************************
         SPACE 1
         LTORG ,               BUILD LITERAL POOL
         SPACE 1
*** EQUATES FOR THE FORMAT PATTERN FLAG BYTE.
NOCONV   EQU   X'20'           DO NOT CONVERT DATA TO PRINTABLE HEX.
CALLSTG  EQU   X'10'           DATA IS IN CALLER'S STORAGE.
@DATA    EQU   X'0C'           ADDRESS OF DATA ELEMENT FOLLOWS.
DATA     EQU   X'04'           FORMAT A DATA ELEMENT.
@LABEL   EQU   X'03'           ADDRESS OF LABEL ELEMENT FOLLOWS.
LABEL    EQU   X'01'           FORMAT A LABEL ELEMENT
         SPACE 1
CVTDCB   EQU   X'74',4         OFFSET TO CVTDCB FIELD.
SBA      EQU   X'11'           SET-BUFFER-ADDRESS ORDER.
IC       EQU   X'13'           INSERT-CURSOR ORDER.
RA       EQU   X'3C'           REPEAT-TO-ADDRESS ORDER.
         SPACE 1
         DS    0D
PATTERN  DC    AL1(CALLSTG+@DATA+@LABEL,1*16+3,0,2)
         DC    A(LABELS)       ADDRESS OF LABEL.
         DC    A(0)            ADDRESS OF DATA.
         DC    AL1(@DATA+LABEL,4*16+3,10,15)
         DC    A(0)            ADDRESS OF DATA WORD 1.
         DC    AL1(@DATA+LABEL,1*16+3,23,25)
         DC    A(0)           +ADDRESS OF DATA WORD 2.
         DC    AL1(@DATA+LABEL,1*16+3,33,35)
         DC    A(0)           +ADDRESS OF DATA WORD 3.
         DC    AL1(@DATA+LABEL,1*16+3,43,45)
         DC    A(0)           +ADDRESS OF DATA WORD 4.
         DC    AL1(NOCONV+@DATA+LABEL,3*16+15,53,57)
         DC    A(0,0)          ADDRESS OF DATA.
LPATTERN EQU   *-PATTERN
         SPACE 1
SCROLL   DC    F'352'          PFK 7/8 SCROLL BYTE COUNT.
         SPACE 1
LABELS   DS    0X
         FIELD PROT=U,INTENS=HI,AN=A
         FIELD PROT=P,INTENS=LO,AN=S,DATA=C'='
         FIELD PROT=U,INTENS=HI,AN=A
         FIELD PROT=U,INTENS=HI,AN=A
         FIELD PROT=U,INTENS=HI,AN=A
         FIELD PROT=U,INTENS=HI,AN=A
         FIELD PROT=P,INTENS=HI,AN=S,DATA=C' ×'
         SPACE 1
FIRSTAD  DS   0X
         FIELD PROT=U,INTENS=HI,AN=A
         SPACE 1
NOTAVAIL DS    0X
         FIELD PROT=P,INTENS=HI,AN=S,DATA=C'12345678'
         FIELD PROT=P,INTENS=LO,AN=S,DATA=C'='
SAMPNA   FIELD PROT=P,INTENS=LO,AN=S,DATA=C'N/A     '
         FIELD PROT=P,INTENS=LO,AN=S,DATA=C'N/A     '
         FIELD PROT=P,INTENS=LO,AN=S,DATA=C'N/A     '
         FIELD PROT=P,INTENS=LO,AN=S,DATA=C'N/A     '
         FIELD PROT=P,INTENS=LO,AN=S,DATA=C' ×................×'
LNOTAVAL EQU   *-NOTAVAIL
         SPACE 1
TRTBL1   DC    C'0123456789ABCDEF'
         SPACE 1
TRTBL2   DC    C'................................'  00-1F
         DC    C'................................'  20-3F
         DC    C' .........Ö.<(+×&&.........!$*);^' 40-5F
         DC    C'-/.........,%_>?..........:#@''="' 60-7F
         DC    C'.abcdefghi.......jklmnopqr......'  80-9F
         DC    C'..stuvwxyz......................'  A0-BF
         DC    C'.ABCDEFGHI.......JKLMNOPQR......'  C0-DF
         DC    C'..STUVWXYZ......0123456789......'  E0-FF
         SPACE 1
TRTBL3   DC    X'0A0B0C0D0E0F',XL42'00',X'010203040506070809'
         SPACE 1
AND24    DC    X'00FFFFF0'
AND31    DC    X'7FFFFFF0'
         SPACE 1
MSG24    DC    C' 24-Bit Virtual Data '
MSG31    DC    C' 31-Bit Virtual Data '
MSGREAL  DC    C'----- Real Data -----'
MSGHDR   DC    C'---- Header Data ----'
MSGCPU   DC    C'----- CPU  Data -----'
ENVMSG   DC    C'INVALID ENVIRONMENT FOR AMD3270.  USER MUST BE LOGGED *
               ON TO TSO WITH A 24X80 3270 DEVICE.'
         SPACE 1
TPUTFULL DC    X'03'           FULL-SCREEN TPUT.
TGETASIS DC    X'81'           AS-IS TGET.
         SPACE 1
TPUTBUF  DC    X'C3',AL1(SBA)  RESET KEYBOARD, MDTS; GO TO X1/Y1.
         SBA   X=1,Y=1
         FIELD Y=1,X=1,FILL=X'00',INTENS=LO,PROT=P,AN=S
TITLE    FIELD Y=1,X=14,PROT=P,INTENS=LO,DATA=C'-----------------------*
               -------------------------------------------',AN=S
         FIELD Y=02,X=1,INTENS=LO,AN=S,PROT=P,DATA=C' ADDRESS   ='
         FIELD Y=03,X=1,INTENS=LO,AN-SKIP,PROT=P,DATA=C' ASID ='
         FIELD          INTENS=HI,AN=A,PROT=U,DATA=C'0001'
         FIELD Y=07,X=1,INTENS=LO,AN=S,PROT=P,DATA=C' PF1-Help   '
         FIELD Y=08,X=1,INTENS=LO,AN=S,PROT=P,DATA=C' PF2-24/31  '
         FIELD Y=09,X=1,INTENS=LO,AN=S,PROT=P,DATA=C' PF3-Exit   '
         FIELD Y=10,X=1,INTENS=LO,AN=S,PROT=P,DATA=C' PF4-Unused '
         FIELD Y=11,X=1,INTENS=LO,AN=S,PROT=P,DATA=C' PF5-Unused '
         FIELD Y=12,X=1,INTENS=LO,AN=S,PROT=P,DATA=C' PF6-Unused '
         FIELD Y=13,X=1,INTENS=LO,AN=S,PROT=P,DATA=C' PF7-Scroll-'
         FIELD Y=14,X=1,INTENS=LO,AN=S,PROT=P,DATA=C' PF8-Scroll+'
         FIELD Y=15,X=1,INTENS=LO,AN=S,PROT=P,DATA=C' PF9-Virtual'
         FIELD Y=16,X=1,INTENS=LO,AN=S,PROT=P,DATA=C'PF10-Real   '
         FIELD Y=17,X=1,INTENS=LO,AN=S,PROT=P,DATA=C'PF11-Header '
         FIELD Y=18,X=1,INTENS=LO,AN=S,PROT=P,DATA=C'PF12-CPU    '
         FIELD Y=19,X=1,INTENS=LO,AN=S,PROT=P,DATA=C' PA1-Attn.  '
         FIELD Y=20,X=1,INTENS=LO,AN=S,PROT=P,DATA=C' PA2-Refresh'
         FIELD Y=21,X=1,INTENS=LO,AN=S,PROT=P,DATA=C'ENTR-Display'
LTPUTBUF EQU   *-TPUTBUF
         SPACE 1
WRAPUP   DC    X'C3',AL1(SBA)  FINAL CLEAR-SCREEN SEQUENCE.
         SBA   X=1,Y=1                                    .
         FIELD X=1,Y=1,INTENS=LO,PROT=U,AN=A,FILL=X'00'   .
         DC    AL1(SBA)                                   .
         SBA   X=2,Y=1                                    .
         DC    AL1(IC)                                    .
LWRAPUP  EQU   *-WRAPUP                                   .
         SPACE 1
ADDRSBA  SBA   Y=2,X=15
ASIDSBA  SBA   Y=3,X=10
         SPACE 1
SBAIC    DC    AL1(SBA)
         SBA   Y=2,X=15
         DC    AL1(IC)
LSBAIC   EQU   *-SBAIC
         SPACE 1
SBALIST  SBA   Y=02,X=14       SET BUFFER ADDRESSES FOR EACH LINE.
LSBAENT  EQU   *-SBALIST
         SBA   Y=03,X=14
         SBA   Y=04,X=14
         SBA   Y=05,X=14
         SBA   Y=06,X=14
         SBA   Y=07,X=14
         SBA   Y=08,X=14
         SBA   Y=09,X=14
         SBA   Y=10,X=14
         SBA   Y=11,X=14
         SBA   Y=12,X=14
         SBA   Y=13,X=14
         SBA   Y=14,X=14
         SBA   Y=15,X=14
         SBA   Y=16,X=14
         SBA   Y=17,X=14
         SBA   Y=18,X=14
         SBA   Y=19,X=14
         SBA   Y=20,X=14
         SBA   Y=21,X=14
         SBA   Y=22,X=14
         SBA   Y=23,X=14
         SBA   Y=24,X=14
#SBAENT  EQU   (*-SBALIST)/LSBAENT
         SPACE 1
PFKTABLE DC    X'F100',AL4(PFK01)
LPFKENT  EQU   *-PFKTABLE
         DC    X'F200',AL4(PFK02)
         DC    X'F300',AL4(PFK03)
         DC    X'F400',AL4(DISPLAY)
         DC    X'F500',AL4(DISPLAY)
         DC    X'F600',AL4(DISPLAY)
         DC    X'F700',AL4(PFK07)
         DC    X'F800',AL4(PFK08)
         DC    X'F900',AL4(PFK09)
         DC    X'7A00',AL4(PFK10)
         DC    X'7B00',AL4(PFK11)
         DC    X'7C00',AL4(PFK12)
         DC    X'C100',AL4(PFK01)
         DC    X'C200',AL4(PFK02)
         DC    X'C300',AL4(PFK03)
         DC    X'C400',AL4(DISPLAY)
         DC    X'C500',AL4(DISPLAY)
         DC    X'C600',AL4(DISPLAY)
         DC    X'C700',AL4(PFK07)
         DC    X'C800',AL4(PFK08)
         DC    X'C900',AL4(PFK09)
         DC    X'4A00',AL4(PFK10)
         DC    X'4B00',AL4(PFK11)
         DC    X'4C00',AL4(PFK12)
#PFKENT  EQU   (*-PFKTABLE)/LPFKENT
         DC    X'7D00',AL4(DISPLAY)
         SPACE 2
         CURSORTB
         SPACE 2
HELP     DC    X'C3'           HELP WCC.
         FIELD X=1,Y=1,FILL=C' ',INTENS=LO,PROT=P,AN=S
         DC    CL40'                     Amdahl Full-Screen ' L01A
         DC    CL40'Dump Analysis Tool                      ' L01B
         DC    CL40'                                        ' L02A
         DC    CL40'                                        ' L02B
         DC    CL40'1.  You may enter any address you wish t' L03A
         DC    CL40'o have displayed in the first "ADDRESS" ' L03B
         DC    CL40'    field (following the word ADDRESS). ' L04A
         DC    CL40' You may also specify the ASID which is ' L04B
         DC    CL40'    to be used for virtual data access f' L05A
         DC    CL40'ollowing the word ASID.                 ' L05B
         DC    CL40'                                        ' L06A
         DC    CL40'                                        ' L06B
         DC    CL40'2.  You may also select an address to di' L07A
         DC    CL40'splay by positioning  the  cursor under ' L07B
         DC    CL40'    any previously displayed address.  T' L08A
         DC    CL40'he data accessed will be  displayed  in ' L08B
         DC    CL40'    the same mode as the previous data s' L09A
         DC    CL40'election.                               ' L09B
         DC    CL40'                                        ' L10A
         DC    CL40'                                        ' L10B
         DC    CL40'3.  Data may be selected for viewing in ' L11A
         DC    CL40'24 or 31-bit virtal mode,  real memory, ' L11B
         DC    CL40'    CPU records or dump header records i' L12A
         DC    CL40'n XA-mode only.  MVS/370 dumps may only ' L12B
         DC    CL40'    be viewed in 24-bit virtual mode, re' L13A
         DC    CL40'gardless of which PFK is depressed.  In ' L13B
         DC    CL40'    MVS/XA mode, PFK-2 may be used to se' L14A
         DC    CL40'lect 24/31 bit virtual displays.        ' L14B
         DC    CL40'                                        ' L15A
         DC    CL40'                                        ' L15B
         DC    CL40'4.  PA-2 may be used to refresh the prev' L16A
         DC    CL40'ious display  should  you inadvertently ' L16B
         DC    CL40'    obliterate the screen.  As usual, th' L17A
         DC    CL40'e PFK-3  key  may  be used to exit from ' L17B
         DC    CL40'    the program.  Other PFKs are explain' L18A
         DC    CL40'ed on the main display screen.          ' L18B
         DC    CL40'                                        ' L19A
         DC    CL40'                                        ' L19B
         DC    CL40'5.  The IPCS and AMDPRDMP storage access' L20A
         DC    CL40'  routines  acquire  data  in  somewhat ' L20B
         DC    CL40'    different methods.  Should you have ' L21A
         DC    CL40' difficulty  accessing   memory   under ' L21B
         DC    CL40'    IPCS, try invoking this program from' L22A
         DC    CL40' an AMDPRDMP exit.                      ' L22B
         FIELD PROT=U,IC=Y,DATA=C' ',AN=A
LHELP    EQU   *-HELP
         EJECT
***********************************************************************
*                                                                     *
*                       USER-DEPENDENT AREA.                          *
*                                                                     *
***********************************************************************
         SPACE 1
$UDA     DSECT ,               USER DEPENDENT AREA.
$SAVE    DS    18A             SAVE AREA FOR SUB-ROUTINES.
$DOUBLE  DS    D               CONVERSION WORK AREA.
$ENVDATA DS    D               CALLER'S SCREEN SIZE.
$ADPLBUF DS    A               CALLER'S PRINT BUFFER ADDRESS.
$ADDRESS DS    A               ADDRESS TO BE DISPLAYED.
$DISPADR DS    A               DISPLAY ADDRESS UPDATED BY 16 EACH LINE.
$ANDMASK DS    A               MASK FOR ANDING ADDRESSES.
         SPACE 1
$PATTERN DS    0F              FORMAT PATTERN.
$PATFLG1 DS    F               REQUEST & FLAG BITS FOR ADDRESS.
         DS    A               ADDRESS OF LABELS.
$PAT@AD0 DS    A               ADDRESS OF DATA.
$PATFLG2 DS    F               REQUEST & FLAG BITS FOR DATA WORD 1.
$PAT@AD1 DS    A               ADDRESS OF DATA WORD 1.
$PATFLG3 DS    F               REQUEST & FLAG BITS FOR DATA WORD 2.
$PAT@AD2 DS    A              +ADDRESS OF DATA WORD 2.
$PATFLG4 DS    F               REQUEST & FLAG BITS FOR DATA WORD 3.
$PAT@AD3 DS    A              +ADDRESS OF DATA WORD 3.
$PATFLG5 DS    F               REQUEST & FLAG BITS FOR DATA WORD 4.
$PAT@AD4 DS    A              +ADDRESS OF DATA WORD 4.
$PATFLG6 DS    F               REQUEST & FLAG BITS FOR CHARACTERS.
$PAT@AD5 DS    2A              ADDRESS OF DATA AND NULL WORD.
*** PATTERN BYTE DATA AND ASSOCIATED CODE FLAGGED WITH PLUS SIGN (+)
*** PRECEEDING COMMENTS WAS ADDED TO CIRCUMVENT BUG IN IBM 370-MODE
*** COMPATABILITY SOFTWARE WHICH USES "LA" INSTRUCTION FOR 31-BIT DATA.
         SPACE 1
$INPUT   DS    CL100           INPUT BUFFER.
$WORKBUF DS    CL(23*4*4)      COPY OF HEADER OR CPU RECORD.
         SPACE 1
$FLAG    DS    X               FLAG FIELD FOR CPU AND HEADER RECORDS.
$NOTAVAL EQU   X'80'            - DATA COULD NOT BE ACCESSED.
         SPACE 1
$TPUTBUF DS    0X              FULL-SCREEN TPUT BUFFER.
         DC    X'C3',AL1(SBA)  RESET KEYBOARD, MDTS; GO TO X1/Y1.
         SBA   X=1,Y=1
         FIELD Y=1,X=1,FILL=X'00',INTENS=LO,PROT=P,AN=S
$TITLE   FIELD Y=1,X=14,PROT=P,INTENS=LO,DATA=C'-----------------------*
               -------------------------------------------',AN=S
$MODEMSG EQU   $TITLE+20,21
         FIELD Y=02,X=1,INTENS=LO,AN=S,PROT=P,DATA=C' ADDRESS   ='
         FIELD Y=03,X=1,INTENS=LO,AN-SKIP,PROT=P,DATA=C' ASID ='
$ASID    FIELD          INTENS=HI,AN=A,PROT=U,DATA=C'0001'
         FIELD Y=07,X=1,INTENS=LO,AN=S,PROT=P,DATA=C' PF1-Help   '
         FIELD Y=08,X=1,INTENS=LO,AN=S,PROT=P,DATA=C' PF2-24/31  '
         FIELD Y=09,X=1,INTENS=LO,AN=S,PROT=P,DATA=C' PF3-Exit   '
         FIELD Y=10,X=1,INTENS=LO,AN=S,PROT=P,DATA=C' PF4-Unused '
         FIELD Y=11,X=1,INTENS=LO,AN=S,PROT=P,DATA=C' PF5-Unused '
         FIELD Y=12,X=1,INTENS=LO,AN=S,PROT=P,DATA=C' PF6-Unused '
         FIELD Y=13,X=1,INTENS=LO,AN=S,PROT=P,DATA=C' PF7-Scroll-'
         FIELD Y=14,X=1,INTENS=LO,AN=S,PROT=P,DATA=C' PF8-Scroll+'
         FIELD Y=15,X=1,INTENS=LO,AN=S,PROT=P,DATA=C' PF9-Virtual'
         FIELD Y=16,X=1,INTENS=LO,AN=S,PROT=P,DATA=C'PF10-Real   '
         FIELD Y=17,X=1,INTENS=LO,AN=S,PROT=P,DATA=C'PF11-Header '
         FIELD Y=18,X=1,INTENS=LO,AN=S,PROT=P,DATA=C'PF12-CPU    '
         FIELD Y=19,X=1,INTENS=LO,AN=S,PROT=P,DATA=C' PA1-Attn.  '
         FIELD Y=20,X=1,INTENS=LO,AN=S,PROT=P,DATA=C' PA2-Refresh'
         FIELD Y=21,X=1,INTENS=LO,AN=S,PROT=P,DATA=C'ENTR-Display'
$LINE1   DS    XL3             SET BUFFER ADDRESS.
$ADDR1   DS    XL13            ADDRESS & EQUAL SIGN.
$WORD1A  DS    XL10            FIRST DATA WORD.
$WORD1B  DS    XL10            SECOND DATA WORD.
$WORD1C  DS    XL10            THIRD DATA WORD.
$WORD1D  DS    XL10            FOURTH DATA WORD.
$CHAR1   DS    XL21            EBCDIC DATA REPRESENTATION.
$LINE2   DS    XL3             SET BUFFER ADDRESS.
$ADDR2   DS    XL13            ADDRESS & EQUAL SIGN.
$WORD2A  DS    XL10            FIRST DATA WORD.
$WORD2B  DS    XL10            SECOND DATA WORD.
$WORD2C  DS    XL10            THIRD DATA WORD.
$WORD2D  DS    XL10            FOURTH DATA WORD.
$CHAR2   DS    XL21            EBCDIC DATA REPRESENTATION.
$LINE3   DS    XL3             SET BUFFER ADDRESS.
$ADDR3   DS    XL13            ADDRESS & EQUAL SIGN.
$WORD3A  DS    XL10            FIRST DATA WORD.
$WORD3B  DS    XL10            SECOND DATA WORD.
$WORD3C  DS    XL10            THIRD DATA WORD.
$WORD3D  DS    XL10            FOURTH DATA WORD.
$CHAR3   DS    XL21            EBCDIC DATA REPRESENTATION.
$LINE4   DS    XL3             SET BUFFER ADDRESS.
$ADDR4   DS    XL13            ADDRESS & EQUAL SIGN.
$WORD4A  DS    XL10            FIRST DATA WORD.
$WORD4B  DS    XL10            SECOND DATA WORD.
$WORD4C  DS    XL10            THIRD DATA WORD.
$WORD4D  DS    XL10            FOURTH DATA WORD.
$CHAR4   DS    XL21            EBCDIC DATA REPRESENTATION.
$LINE5   DS    XL3             SET BUFFER ADDRESS.
$ADDR5   DS    XL13            ADDRESS & EQUAL SIGN.
$WORD5A  DS    XL10            FIRST DATA WORD.
$WORD5B  DS    XL10            SECOND DATA WORD.
$WORD5C  DS    XL10            THIRD DATA WORD.
$WORD5D  DS    XL10            FOURTH DATA WORD.
$CHAR5   DS    XL21            EBCDIC DATA REPRESENTATION.
$LINE6   DS    XL3             SET BUFFER ADDRESS.
$ADDR6   DS    XL13            ADDRESS & EQUAL SIGN.
$WORD6A  DS    XL10            FIRST DATA WORD.
$WORD6B  DS    XL10            SECOND DATA WORD.
$WORD6C  DS    XL10            THIRD DATA WORD.
$WORD6D  DS    XL10            FOURTH DATA WORD.
$CHAR6   DS    XL21            EBCDIC DATA REPRESENTATION.
$LINE7   DS    XL3             SET BUFFER ADDRESS.
$ADDR7   DS    XL13            ADDRESS & EQUAL SIGN.
$WORD7A  DS    XL10            FIRST DATA WORD.
$WORD7B  DS    XL10            SECOND DATA WORD.
$WORD7C  DS    XL10            THIRD DATA WORD.
$WORD7D  DS    XL10            FOURTH DATA WORD.
$CHAR7   DS    XL21            EBCDIC DATA REPRESENTATION.
$LINE8   DS    XL3             SET BUFFER ADDRESS.
$ADDR8   DS    XL13            ADDRESS & EQUAL SIGN.
$WORD8A  DS    XL10            FIRST DATA WORD.
$WORD8B  DS    XL10            SECOND DATA WORD.
$WORD8C  DS    XL10            THIRD DATA WORD.
$WORD8D  DS    XL10            FOURTH DATA WORD.
$CHAR8   DS    XL21            EBCDIC DATA REPRESENTATION.
$LINE9   DS    XL3             SET BUFFER ADDRESS.
$ADDR9   DS    XL13            ADDRESS & EQUAL SIGN.
$WORD9A  DS    XL10            FIRST DATA WORD.
$WORD9B  DS    XL10            SECOND DATA WORD.
$WORD9C  DS    XL10            THIRD DATA WORD.
$WORD9D  DS    XL10            FOURTH DATA WORD.
$CHAR9   DS    XL21            EBCDIC DATA REPRESENTATION.
$LINE10  DS    XL3             SET BUFFER ADDRESS.
$ADDR10  DS    XL13            ADDRESS & EQUAL SIGN.
$WORD10A DS    XL10            FIRST DATA WORD.
$WORD10B DS    XL10            SECOND DATA WORD.
$WORD10C DS    XL10            THIRD DATA WORD.
$WORD10D DS    XL10            FOURTH DATA WORD.
$CHAR10  DS    XL21            EBCDIC DATA REPRESENTATION.
$LINE11  DS    XL3             SET BUFFER ADDRESS.
$ADDR11  DS    XL13            ADDRESS & EQUAL SIGN.
$WORD11A DS    XL10            FIRST DATA WORD.
$WORD11B DS    XL10            SECOND DATA WORD.
$WORD11C DS    XL10            THIRD DATA WORD.
$WORD11D DS    XL10            FOURTH DATA WORD.
$CHAR11  DS    XL21            EBCDIC DATA REPRESENTATION.
$LINE12  DS    XL3             SET BUFFER ADDRESS.
$ADDR12  DS    XL13            ADDRESS & EQUAL SIGN.
$WORD12A DS    XL10            FIRST DATA WORD.
$WORD12B DS    XL10            SECOND DATA WORD.
$WORD12C DS    XL10            THIRD DATA WORD.
$WORD12D DS    XL10            FOURTH DATA WORD.
$CHAR12  DS    XL21            EBCDIC DATA REPRESENTATION.
$LINE13  DS    XL3             SET BUFFER ADDRESS.
$ADDR13  DS    XL13            ADDRESS & EQUAL SIGN.
$WORD13A DS    XL10            FIRST DATA WORD.
$WORD13B DS    XL10            SECOND DATA WORD.
$WORD13C DS    XL10            THIRD DATA WORD.
$WORD13D DS    XL10            FOURTH DATA WORD.
$CHAR13  DS    XL21            EBCDIC DATA REPRESENTATION.
$LINE14  DS    XL3             SET BUFFER ADDRESS.
$ADDR14  DS    XL13            ADDRESS & EQUAL SIGN.
$WORD14A DS    XL10            FIRST DATA WORD.
$WORD14B DS    XL10            SECOND DATA WORD.
$WORD14C DS    XL10            THIRD DATA WORD.
$WORD14D DS    XL10            FOURTH DATA WORD.
$CHAR14  DS    XL21            EBCDIC DATA REPRESENTATION.
$LINE15  DS    XL3             SET BUFFER ADDRESS.
$ADDR15  DS    XL13            ADDRESS & EQUAL SIGN.
$WORD15A DS    XL10            FIRST DATA WORD.
$WORD15B DS    XL10            SECOND DATA WORD.
$WORD15C DS    XL10            THIRD DATA WORD.
$WORD15D DS    XL10            FOURTH DATA WORD.
$CHAR15  DS    XL21            EBCDIC DATA REPRESENTATION.
$LINE16  DS    XL3             SET BUFFER ADDRESS.
$ADDR16  DS    XL13            ADDRESS & EQUAL SIGN.
$WORD16A DS    XL10            FIRST DATA WORD.
$WORD16B DS    XL10            SECOND DATA WORD.
$WORD16C DS    XL10            THIRD DATA WORD.
$WORD16D DS    XL10            FOURTH DATA WORD.
$CHAR16  DS    XL21            EBCDIC DATA REPRESENTATION.
$LINE17  DS    XL3             SET BUFFER ADDRESS.
$ADDR17  DS    XL13            ADDRESS & EQUAL SIGN.
$WORD17A DS    XL10            FIRST DATA WORD.
$WORD17B DS    XL10            SECOND DATA WORD.
$WORD17C DS    XL10            THIRD DATA WORD.
$WORD17D DS    XL10            FOURTH DATA WORD.
$CHAR17  DS    XL21            EBCDIC DATA REPRESENTATION.
$LINE18  DS    XL3             SET BUFFER ADDRESS.
$ADDR18  DS    XL13            ADDRESS & EQUAL SIGN.
$WORD18A DS    XL10            FIRST DATA WORD.
$WORD18B DS    XL10            SECOND DATA WORD.
$WORD18C DS    XL10            THIRD DATA WORD.
$WORD18D DS    XL10            FOURTH DATA WORD.
$CHAR18  DS    XL21            EBCDIC DATA REPRESENTATION.
$LINE19  DS    XL3             SET BUFFER ADDRESS.
$ADDR19  DS    XL13            ADDRESS & EQUAL SIGN.
$WORD19A DS    XL10            FIRST DATA WORD.
$WORD19B DS    XL10            SECOND DATA WORD.
$WORD19C DS    XL10            THIRD DATA WORD.
$WORD19D DS    XL10            FOURTH DATA WORD.
$CHAR19  DS    XL21            EBCDIC DATA REPRESENTATION.
$LINE20  DS    XL3             SET BUFFER ADDRESS.
$ADDR20  DS    XL13            ADDRESS & EQUAL SIGN.
$WORD20A DS    XL10            FIRST DATA WORD.
$WORD20B DS    XL10            SECOND DATA WORD.
$WORD20C DS    XL10            THIRD DATA WORD.
$WORD20D DS    XL10            FOURTH DATA WORD.
$CHAR20  DS    XL21            EBCDIC DATA REPRESENTATION.
$LINE21  DS    XL3             SET BUFFER ADDRESS.
$ADDR21  DS    XL13            ADDRESS & EQUAL SIGN.
$WORD21A DS    XL10            FIRST DATA WORD.
$WORD21B DS    XL10            SECOND DATA WORD.
$WORD21C DS    XL10            THIRD DATA WORD.
$WORD21D DS    XL10            FOURTH DATA WORD.
$CHAR21  DS    XL21            EBCDIC DATA REPRESENTATION.
$LINE22  DS    XL3             SET BUFFER ADDRESS.
$ADDR22  DS    XL13            ADDRESS & EQUAL SIGN.
$WORD22A DS    XL10            FIRST DATA WORD.
$WORD22B DS    XL10            SECOND DATA WORD.
$WORD22C DS    XL10            THIRD DATA WORD.
$WORD22D DS    XL10            FOURTH DATA WORD.
$CHAR22  DS    XL21            EBCDIC DATA REPRESENTATION.
$LINE23  DS    XL3             SET BUFFER ADDRESS.
$ADDR23  DS    XL13            ADDRESS & EQUAL SIGN.
$WORD23A DS    XL10            FIRST DATA WORD.
$WORD23B DS    XL10            SECOND DATA WORD.
$WORD23C DS    XL10            THIRD DATA WORD.
$WORD23D DS    XL10            FOURTH DATA WORD.
$CHAR23  DS    XL21            EBCDIC DATA REPRESENTATION.
$SBAIC   DS    XL(LSBAIC)      INSERT-CURSOR SEQUENCE.
$TPUTLEN EQU   *-$TPUTBUF      LENGTH OF BUFFER TO BE WRITTEN.
         SPACE 1
$LENGTH  EQU   *-$UDA          LENGTH OF USER-DEPENDENT AREA.
         EJECT
         IHAABDPL DSECT=YES    GENERATE ABDUMP PARAMETER LIST
         SPACE 1
         END   AMD3270
