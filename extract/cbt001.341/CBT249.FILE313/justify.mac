         TITLE 'JUSTIFY MARGINS AND ORGANIZE ASSEMBLER CODE'
*********************************************************************
*
*        THIS ROUTINE WILL READ AN ASSEMBLER SOURCE FILE
*        AND REPOSITION EACH SECTION OF EACH RECORD TO
*        STANDARD ASSEMBLER SOURCE MARGINS (1 10 16).
*        BOTH SOURCE AS WELL AS MACROS (IMBEDDED TOO) CAN
*        BE HANDLED WITHIN THE SAME EXECUTION.
*        QUOTED STRINGS ARE HANDLED BUT MUST BE PAIRED.
*        PARM VALUES MAY BE USED TO OVERRIDE THE DEFAULT
*        OF 31 AND 71 AS SPECIFICATION OF COMMENTS BOUNDARIES.
*
*        REQUIREMENTS:
*              SYSPRINT - LISTING DDNAME
*              SYSIN    - INPUT SOURCE FILE
*              SYSPUNCH - OUTPUT SOURCE FILE
*
*        PARM VALUES IF ANY MUST BE SPECIFIED AS FOLLOWS:
*              PARM='BB,EE' (DEFAULT = '31,71')
*              BB - BEGINNING COLUMN FOR COMMENTS
*              EE - ENDING COLUMN FOR COMMENTS
*
*        TRUNCATION OF COMMENTS IS HANDLED BY ADDING A CONTINUATION
*        'COMMENTS' CARD.
*
*********************************************************************
*
*        THE FOLLOWING IS AN EXAMPLE OF IT'S USE AS A TSO COMMAND
*        VIA CALL WITHIN A CLIST.  TWO SECTIONS FOLLOW, FIRST
*        THE INFORMATION TO BE INCLUDED WITHIN THE HELP DATASET,
*        AND SECOND THE CLIST ITSELF.
*
*  )F FUNCTION
*     THE JUSTASM CLIST INVOKES 'JUSTIFY' TO REALIGN ASSEMBLER
*     SOURCE FILES. EACH FIELD FOR EACH STATEMENT IS ALIGNED
*     TO THE CORRECT COLUMN (1 10 16 31 72 ETC.).
*  )X SYNTAX -
*         JUSTASM DATASET-NAME
*     REQUIRED  DATASET-NAME
*     DEFAULTS  NONE
*  )O OPERANDS -
*     DATASET-NAME
*             - UNQUALIFIED DATA SET NAME OF THE FILE TO BE
*               JUSTIFIED.  THE REAL NAME MUST HAVE A SUFFIX
*               OF 'ASM' AND A PREFIX OF YOUR USER-ID.
*               EXAMPLE: TO JUSTASM A FILE NAMED
*                        USERID.MYASM.ASM
*                        ENTER 'JUSTASM MYASM'
*
*
*********************************************************************
*
*  PROC 1 DSN
*  FREE F(SYSIN SYSPRINT SYSPUNCH)
*  ATTRIB JUSTIFY LRECL(80) BLKSIZE(400) RECFM(F B)
*  ALLOC F(SYSIN) DA(&DSN..ASM) SHR
*  ALLOC F(SYSPUNCH) DA(NEW.&DSN..ASM) NE SP(1 5) TR US(JUSTIFY) REL
*  ALLOC F(SYSPRINT) DUMMY
*  CALL 'USER.LINKLIB(JUSTIFY)' '31,71'
*  FREE ATTR(JUSTIFY)
*  FREE F(SYSPUNCH SYSIN SYSPRINT)
*  ALLOC F(SYSPRINT) DA(*)
*  ALLOC F(SYSIN) DA(*)
*  DELETE &DSN..ASM
*  REN NEW.&DSN..ASM &DSN..ASM
*********************************************************************
JUSTIFY  CSECT
*
*        EQUATES
*
BASE1    EQU   11
BASE2    EQU   12
R0       EQU   0
R1       EQU   1
R2       EQU   2
R3       EQU   3
R4       EQU   4
R5       EQU   5
R6       EQU   6
R7       EQU   7
R8       EQU   8
R9       EQU   9
R10      EQU   10
R13      EQU   13
R14      EQU   14
R15      EQU   15
*
CC       EQU   X'80'
EF       EQU   X'40'
MAC      EQU   X'20'
AIF      EQU   X'10'
SI       EQU   X'08'
LC       EQU   X'04'
GC       EQU   X'02'
CR       EQU   X'01'
ALLBITS  EQU   X'FF'
HIT      EQU   7
NOHIT    EQU   8
*
*   REGISTER ASSIGNMENTS
*     0 - WORK
*     1 - LENGTH OF TEXT - 1
*     2 - WORK
*     3 - WORK
*     4 - WORK
*     5 - POINTER TO INPUT AREA
*     6 - POINTER TO DELIMITING BLANK AFTER TEXT
*     7 - POINTER TO TEXT IN INPUT AREA
*     8 - POINTER TO OUTPUT AREA
*     9 - POINTER TO DESTNATION OF TEXT IN OUTPUT AREA
*    10 - INTERNAL LINKAGE REGISTER
*    11 - BASE REGISTER 1
*    12 - BASE REGISTER 2
*    13 - SAVE AREA POINTER
*    14 - WORK
*    15 - WORK
*
         EJECT
         PRINT NOGEN
***********************************************************************
*                                                                     *
*        PROCESS PARM INFORMATION IF ANY.  IF CMS DEFAULT TO          *
*        COMMENTS START = COL 36 (PARM1) AND COMMENTS STOP =          *
*        COL 71 (PARM2).  CHECK FOR CMS ENVIRONMENT BY LOOKING        *
*        FOR THE FENCE THAT REGISTER ONE POINTS TO WHEN NO            *
*        PARMS ARE ENTERED IN CMS. (RESTRICTION)                      *
*                                                                     *
***********************************************************************
         SAVE  (14,12)             SAVE CALLERS REGS
         LR    BASE1,R15           GET ENTRY FOR BASE
         USING JUSTIFY,BASE1       TELL ASSEMBLER
         CNOP  0,4                 ALIGNMENT FOR SAVE AREA
         BAL   R2,*+76             AROUND SAVE AREA
         DC    18F'0'              SAVE AREA
         ST    R2,8(R13)           SAVE FORWARD POINTER
         ST    R13,4(R2)           SAVE BACKWARD POINTER
         LR    R13,R2              SET UP SAVE REG
         L     BASE2,ADCON         GET SECOND BASE REG
         USING JUSTIFY+4096,BASE2  TELL ASSEMBLER
         B     BEGIN               GO TO INITIALIZATION ROUTINE
ADCON    DC    A(JUSTIFY+4096)
BEGIN    LA    R5,36               SET DEFAULT COMM START
         LA    R7,71               SET DEFAULT COMM STOP
         CLC   0(8,R1),=CL8'JUSTIFY'  IS THIS CMS ENVIRONMENT?
         BE    PARMCMS             YES, PROCESS CMS PARMS
         CLI   0(R1),C'*'          IS THIS CMS TEST?
         BNE   PARMOS              NO, MUST BE OS
PARMCMS  CLC   8(4,R1),=F'-1'      NULL PARM?
         BE    NOPARM              YES, DEFAULT
         LA    R5,6                SET LOOP LIMIT
         LA    R3,8(R1)            SET DATA POINTER
         SR    R2,R2               CLEAR COUNT REG
PARMCMSA CLI   0(R3),C' '          BLANK?
         BE    PARMCMSD            YES, DONE
         LA    R3,1(R3)            BUMP TO NEXT CHAR
         LA    R2,1(R2)            BUMP COUNT
         BCT   R5,PARMCMSA         CHECK NEXT CHAR
         B     PARMERR             GREATER THAN 5, ERROR
PARMCMSD LR    R0,R2               SAVE COUNT FOR LATER
         LA    R1,6(R1)            UPDATE TO SIMULATE OS PARM
         B     PARMSAME            CONTINUE PARM SCAN
PARMOS   L     R1,0(R1)            GET PARM POINTER
         LH    R2,0(R1)            GET PARM SIZE
         LR    R0,R2               COPY TO HOLDING REG
PARMSAME LTR   R2,R2               ANY PARM GIVEN?
         BZ    NOPARM              NO, DEFAULT
         LA    R3,2(R1)            POINT TO DATA PORTION OF PARM
         LR    R4,R3               SAVE FOR MOVE
PARM1CHK CLI   0(R3),C','          END OF PARM 1
         BE    PARM1END            YES, CHECK IF NAY GIVEN
         LA    R3,1(R3)            BUMP TO NEXT POS'N
         BCT   R2,PARM1CHK         CHECK NEXT CHARACTER
PARM1END LR    R5,R0               GET ORIGINAL SIZE
         SR    R5,R2               GET NUMBER SCANNED
         CH    R5,=H'2'            WITHIN LIMITS?
         BH    PARMERR             NO, ERROR
         LTR   R5,R5               CHECK IF 1ST PARM GIVEN
         BZ    PARM2CHK            NONE, SKIP IT (DEFAULT)
         LA    R14,PARMWORK+8      SET DATA POINTER FOR EXECUTE
         SR    R14,R5              DECREMENT BY NUMBER TO MOVE
         BCTR  R5,R0               DECREMENT FOR EXECUTE
         EX    R5,PARMMOVE         MOVE TO WORK AREA
         XC    WORK,WORK           CLEAR WORK AREA
         MVZ   WORK,PARMWORK       MOVE FOR ZONE CHECK
         CLC   WORK,ZEROS          WAS PARM NUMERIC?
         BNE   PARMERR             NO, ERROR
         PACK  WORK(8),PARMWORK(8)  MAKE DECIMAL FIRST
         CVB   R5,WORK             CONVERT TO HEX
PARM2CHK LA    R3,1(R3)            BUMP TO NEXT CHAR
         LR    R4,R3               SAVE FOR MOVE
         BCTR  R2,R0               DECREMENT PARM SIZE
         MVC   PARMWORK,ZEROS      CLEAR WORK AREA
         LA    R14,PARMWORK+8      SET DATA POINTER FOR MOVE
         SR    R14,R2              DECREMENT BY NUMBER LEFT TO MOVE
         BCTR  R2,R0               DECREMENT FY NUMBER LEFT
         EX    R2,PARMMOVE         MOVE TO WORK AREA
         XC    WORK,WORK           CLEAR WORK AREA
         MVZ   WORK,PARMWORK       MOVE ZONES FOR CHECK
         CLC   WORK,ZEROS          ALL NUMERICS?
         BNE   PARMERR             NO, ERROR
         PACK  WORK(8),PARMWORK(8)  MAKE DECIMAL FIRST
         CVB   R7,WORK             MAKE HEX
NOPARM   ST    R5,COMMSTRT         SET COMMENT START FIELD
         ST    R7,LIMIT            SET COMMENT STOP FIELD
         CH    R5,=H'60'           WITHIN LIMITS?
         BH    PARMERR             NO, ERROR
         CH    R7,=H'71'           WITHIN LIMIT?
         BH    PARMERR             NO, ERROR TOO
         SR    R7,R5               GET COMMENTS SIZE
         STH   R7,LIMITSZ          SAVE FOR FUTURE REF
         CH    R7,=H'16'           WITHIN LIMITS?
         BH    PARMEND             YES, CONTINUE
PARMERR  WTO   'JUSTIFY - INVALID PARM SPECIFIED, RETRY'
         LA    R15,20              SET RETCODE
         B     EXIT                RETURN TO CALLER
         EJECT
***********************************************************************
*                                                                     *
*        INITIALIZE TRANSLATE TABLES AND OPEN FILES.  THEN SET UP     *
*        READ AHEAD RECORD.                                           *
*                                                                     *
***********************************************************************
PARMEND  OC    QBTABLE,QTABLE      INITIALIZE QUOTE BLANK
         OC    QBTABLE,BTABLE      TABLE WITH QUOTES AND BLANKS
PRINTSET EQU   *                   SET UP TO PRINT OUTPUT
         OI    FLG2,X'01'          FORCE HEADING ON FIRST CARD
         OPEN  (PRINT,OUTPUT)
OPENIO   OPEN  (INPUT,,OUTPUT,OUTPUT)
         GET   INPUT,CURRENT       GET FIRST CARD OF INPUT
         B     PASTGET             SKIP BUFFER SHIFT
GET      MVC   CURRENT(80),NEXT    MAKE LOOK AHEAD CURRENT
         NI    FLG,ALLBITS-GC      RESET COMMENT CONTINUATION
         TM    FLG,EF              END OF FILE ON PREVIOUS
         BO    EODAD               YES, NO MORE READS
         MVC   NEXT+71(8),NINES    MOVE HIGH VALUE TO NEW SEQ
PASTGET  GET   INPUT,NEXT          READ LOOK AHEAD CARD
ONCEMORE LA    R5,CURRENT          SET PERM. INPUT REC. POINTER
         LR    R7,R5               COPY FOR WORKING REGISTER
         LA    R8,PAREA            OUTPUT AREA
         EJECT
***********************************************************************
*                                                                     *
*        CHECK TYPE OF RECORD JUST READ.  IF COMMENTS OR OTHER        *
*        NON-PROCESS CARD, SKIP IT.                                   *
*                                                                     *
***********************************************************************
         CLI   0(R7),C'*'          COMMENTS CARD
         BE    CPUTA               YES, OUTPUT AS IS
         CLC   0(2,R7),=CL2'.*'    MACRO COMMENTS
         BE    CPUT                YES, OUTPUT AS IS
         TM    FLG,CC              PREVIOUS IND. CONT?
         BZ    SKIPCONT            NO, SKIP CONT. INIT.
         LA    R6,1(R7)            SET BEGINNING OF CARD
         LR    R7,R6               COPY TO WORKING SET
         B     CONTINUE
SKIPCONT CLI   0(R7),C' '          IS LABEL PRESENT
         BE    ORCHECK             NO - FIND OPERATOR
         CLI   0(R7),C'*'          COMMENT
         BE    CPUT                YES - OUTPUT CARD AS IS
         CLI   0(R7),C'/'          JCL
         BNE   LDELIM              NO - ISOLATE LABEL
         CLI   1(R7),C'*'          /*
         BNE   CPUT                NO - OUTPUT AS IS
         OI    FLG2,X'01'          EJECT AFTER PRINTING
         B     CPUT                OUTPUT CARD
CPUTA    CLI   71(R5),C' '         CONTINUATION IN COMMENTS
         BE    CPUT                NO, BRANCH AROUND
         MVC   85(20,R8),ERR6MSG   INFORM USER
CPUT     EQU   *                   OUTPUT CARD UNCHANED
         MVC   0(80,R8),0(R5)      MOVE COMMENT OR JCL
         B     XCARD1              OUTPUT IT
         SPACE 1
***********************************************************************
*                                                                     *
*        FIND AND PROCESS LABEL IF ONE IS PRESENT.                    *
*                                                                     *
***********************************************************************
LDELIM   EQU   *                   DELIMIT LABEL
         TRT   0(9,R7),BTABLE      LOOK FOR BLANK
         BC    NOHIT,ERR1          LABEL EEROR
         LR    R0,R1               SAVE ADDRESS
         SR    R1,R7               FIND L'LABEL
         BCTR  R1,R0               -1
         EX    R1,LMOVE            MOVE TO OUTPUT
         LR    R7,R0               A(FIRST BLANK)
         EJECT
***********************************************************************
*                                                                     *
*        FIND AND PROCESS OPERATOR.  IF A SPECIAL OPERATOR IS         *
*        FOUND (MACRO TYPES)SET APPROPRIATE INDICATOR FOR COMMENT     *
*        GENERATION ROUTINES.                                         *
*                                                                     *
***********************************************************************
ORCHECK  EQU   *                   ISOLATE OPERATOR
         LA    R1,70(R5)           POINT TO COL 71
         SR    R1,R7               NUMBER OF COLS AFTER LABEL
         EX    R1,FINDNB           FIND OPERATOR
         BC    NOHIT,ERR2
         LR    R7,R1               A(OPERATOR)
         TRT   0(9,R7),BTABLE      FIND OPERATOR END
         BC    NOHIT,ERR3
         LR    R6,R1               END OF OPERATOR
         SR    R1,R7               L'OPERATOR
         BCTR  R1,R0               -1
         EX    R1,ORMOVE           MOVE OPERATOR
         LR    R0,R1               SAVE LENGTH OF OPERAND
         LA    R1,1(R1)            UPDATE FOR BLANK
         LA    R14,TSTBL           GET POINTER TO TABLE ORIGIN
         LA    R15,R2              NUMBER OF THREE BYTE ENTRIES
TRY3     EX    R1,MACOMP           COMPARE OPERATORS
         BE    MACMATCH            BRANCH IF FOUND
         LA    R14,6(R14)          UPDATE TO NEXT IN LIST
         BCT   R15,TRY3            GO CHECK NEXT
         LA    R15,R8              NUMBER OF FOUR BYTE ENTRIES
TRY4     EX    R1,MACOMP           COMPARE OPERATORS
         BE    MACMATCH            BRANCH IF FOUND
         LA    R14,6(R14)          UPDATE TO NEXT IN LIST
         BCT   R15,TRY4            GO CHECK NEXT
         LA    R15,R10             NUMBER OF FIVE BYTE ENTRIES
TRY5     EX    R1,MACOMP           COMPARE OPERATORS
         BE    MACMATCH            BRANCH IF FOUND
         LA    R14,6(R14)          UPDATE TO NEXT IN LIST
         BCT   R15,TRY5            GO CHECK NEXT IN LIST
         NI    FLG,ALLBITS-SI-AIF  RESET MAC CONTINUE FLAG
         B     MACEND              AROUND FOLLOWING TESTS
MACMATCH OI    FLG,SI              SET MACRO COMMENT FLAG
         CLC   0(6,R7),MACRO       IS THIS START OF MACRO
         BNE   TST2                NO, TO NEXT TEST
         OI    FLG,MAC             SET MACRO FLAG
         B     MACEND              SKIP FOLLOWING TESTS
TST2     CLC   0(5,R7),MEND        IS THIS END OF MACRO
         BNE   TST3                NO, TO NEXT TEST
         NI    FLG,ALLBITS-SI-AIF-MAC  RESET MACRO FLAGS
         B     MACEND              SKIP NEXT TESTS
TST3     CLC   0(4,R7),TSTBL       CHECK FOR 'AIF' OPERATOR
         BNE   MACEND              NO, OTHER OPERAND
         OI    FLG,AIF             SET 'AIF' FLAG
         EJECT
***********************************************************************
*                                                                     *
*        CHACK FOR SPECIAL ASSEMBLER CONTROL STATEMENTS, AND IF       *
*        FOUND, BRANCH TO SET SPECIAL INDICATOR IN OUTPUT.            *
*                                                                     *
***********************************************************************
MACEND   EQU   *
         CLC   0(6,R7),=CL6'EJECT'  CONTROL OPERATOR
         BE    ERR5                YES, AS IS
         CLC   0(6,R7),=CL6'SPACE'  CONTROL OPERATOR
         BE    ERR5                YES, AS IS
         LR    R1,R0               RESTORE OPERATOR LENGTH
         LR    R7,R6               POINT TO END OF OPERATOR
         SPACE 2
***********************************************************************
*                                                                     *
*        DETERMINE BEGINNING OF OPERAND ADDRESS BASED ON SIZE OF      *
*        OPERATOR.                                                    *
*                                                                     *
***********************************************************************
         C     R1,=F'4'            5-BYTE OPERATOR OR LESS
         BH    *+12                NO
CONTINUE LA    R9,15(R8)           A(DESTNATION)
         B     ODLOC               BRANCH TO CONTINUE
         C     R1,=F'6'            7-BYTE OPERATOR
         BH    *+12                NO
         LA    R9,17(R8)           A(DESTNATION)
         B     ODLOC               BRANCH TO CONTINUE
         LA    R9,19(R8)           A(DSTINATION)
ODLOC    EQU   *                   FIND OPERAND
         LA    R1,70(R5)           A(COL 71)
         SR    R1,R6               NUMBER OF COLS LEFT
         BM    XCARD               COPY CARD IF MINUS
         EX    R1,FINDNB           FIND OPERAND
         BC    NOHIT,XCARD         IF NONE OUTPUT CARD
         LR    R4,R1               COPY START OP OPERAND
         LR    R7,R1               COPY START OF OPERAND
         EJECT
***********************************************************************
*                                                                     *
*   PROCESS OPERAND INCLUDING QUOTED STRINGS AND CONTINUATIONS        *
*   IF AN 'AIF' IS BEING PROCESSED, COPY ALL OF OPERAND TO PERIOD     *
*   R1 = A(OPERAND)                                                   *
*   R4 = A(OPERAND)                                                   *
*   R5 = A(INPUT CARD)                                                *
*  R7 = A(OPERAND)                                                   *
*  R8 = A(OUTPUT CARD)                                               *
*  R9 = A(OUTPUT OPERAND DESTINATION)                                *
*   THE OPERAND SHOULD OCCUR BEFORE COL 25 - OTHERWISE IT IS          *
*   CONSIDERED COMMENTS.                                              *
*                                                                     *
***********************************************************************
         LA    R3,24(R5)           COLUMN 25
         CR    R1,R3               IS OPERAND BEFORE 25
         BNL   COMLOC0             LO, IT IS NOW A COMMENT
ODLOC2   TM    FLG,AIF             SPECIAL 'AIF' OPERATOR
         BZ    ODLOC3              NO, BRANCH AROUND
         LA    R3,70(R5)           A(COL 72-1)
         SR    R3,R1               NUMBER OF COLUMNS TO SCAN
         EX    R3,AIFCHK           SCAN FOR PERIOD
         BZ    XODMOVE3            NONE FOUND, COPY ALL OF CARD
         NI    FLG,ALLBITS-AIF     RESET AIF FLAG
         LR    R7,R1               SET NEW BEGINNING FOR SCAN
ODLOC3   LA    R3,70(R5)           A(COL 72-1)
         SR    R3,R1               NUMBER OF COLS TO SCAN
         BM    XODMOVE3            BRANCH IF NONE TO SCAN
         EX    R3,QBCHECK          FIND A BLANK OR QUOTE
         BZ    XODMOVE3            NEITHER FOUND, COPY CARD
         CLI   0(R1),X'40'         BLANK OR QUOTE FOUND
         BE    XODMOVE4            BRANCH IF BLANK
         XI    FLG,LC              FLIP LITERAL FLG
LITCONT  LA    R1,1(R1)            BUMP TO NEXT COLUMN
         LR    R7,R1               SET NEW START FOR TRT
         B     ODLOC3              BACK TO CONTINUE SCAN
XODMOVE3 LA    R1,71(R5)           SET ENTIRE CARD IF NO HIT
         B     XODMOVE5            SKIP LITERAL TEST
XODMOVE4 TM    FLG,LC              LITERAL STILL UNFINISHED?
         BO    LITCONT             YES, BACK TO CONTINUE SCAN
XODMOVE5 LR    R7,R4               RESTORE A(OPERAND)
         EJECT
***********************************************************************
*                                                                     *
*   R1 POINTS TO THE DELIMITER OF THE OPERAND, DETERMINE IF IT WILL   *
*   FIT IN THE OUTPUT RECORD.                                         *
*   R7 -A(OPERAND)                                                   *
*                                                                     *
***********************************************************************
         SR    R4,R1
         LCR   R4,R4
         LA    R2,71(,R8)          A(COL 72)
         SR    R2,R9               NUMBER OF BLANKS AFTER OP
         BNZ   MOVECHK             BRANCH IF 1 OR MORE
         DC    H'0'                PGM CHECK ************
MOVECHK  EQU   *
         CR    R4,R2               WILL OPERAND FIT
         BH    ERR4                NO - OUTPUT CARD
         BCTR  R4,R0               -1
         EX    R4,ODMOVE           MOVE OPERAND TO OUTPUT
         EJECT
***********************************************************************
*                                                                     *
*        PROCESS COMMENTS FIELDS, AND GENERATE NEW COMMENTS CARD      *
*        IF REQUIRED TO CONTINUE COMMENTS DATA.                       *
*                                                                     *
***********************************************************************
         LA    R9,1(R4,R9)         GET END OF OUTPUT
         L     R2,COMMSTRT         GET STARTING COMMENTS COL
         BCTR  R2,R0               DECREMENT FOR EXECUTE
         BCTR  R2,R0               ONCE MORE FOR FUDGE
         AR    R2,R8               2 = OUTPUT COL COMM START
         CR    R9,R2               END BEFORE COMMENT COL?
         BL    SETCOL              BRANCH YES, USE DEFINED VAL
         LA    R9,2(,R9)           NO, BUMP TO USE NEXT
RESUME   DS    0H
         LR    R7,R1               10 = INPUT END OF OP
         LA    R4,70(,R5)          4 = INPUT COL 71
         SR    R4,R1               4 = INPUT NUMBER LEFT TO MOVE
         BM    XCARD               BRANCH IF NONE LEFT
         EX    R4,FINDNB           FIND INPUT BEGIN'G OF COMMENTS
         BZ    XCARD               BRANCH IF NO COMMENTS
MOVECOM  DS    0H
         LR    R7,R1               10 = INPUT BEGIN'G OF COMMENTS
         LA    R2,70(,R5)          2 = INPUT COL 71
CHK2     CR    R7,R2               START = STOP COMMENTS
         BNL   SETSIZ              YES, DEFAULT
         CLI   0(2),C' '           BLANK CHARACTER
         BNE   SETSIZ              NO, SET SIZE OF INPUT
         BCT   R2,CHK2             GO CHECK PREVIOUS CHAR
SETSIZ   SR    R2,R1               2 = NUMB OF CHARS TO MOVE
         BNM   CHKSUPCD            INSURE RESULT IS POSITIVE
         DC    H'0'                PGM CHECK IF ERROR
CHKSUPCD EQU   *                   CHECK FOR SUPPORT CODES
         LA    R3,0(R2,R7)         COPY END OF COMMENTS ADDR
         S     R3,=F'8'            DECREMENT BY EIGHT
         CLI   1(R3),C'@'          SUPPORT CODE EXIST?
         BNE   MOVEMORE            NO, ALL COMMENTS
         S     R2,=F'9'            DECREMENT BY NINE FOR MOVE
         MVC   SUPCODE(8),1(R3)    SAVE SUPPORT CODE FOR LATER
         LTR   R2,R2               ANYTHING TO MOVE NOW?
         BNP   XCARD               NO, WRITE OUT RECORD
MOVEMORE DS    0H                  LABEL
         L     R4,LIMIT            GET END OF COMMENTS OFFSET
         BCTR  R4,R0               DECREMENT FOR EXECUTE
         AR    R4,R8               4 = OUTPUT COL COMM LIMIT
         SR    R4,R9               4 = OUTPUT COLUMNS LEFT
         NI    FLG,ALLBITS-CR      RESET COMMENT REQ
         LA    R3,1(R2)            SET INPUT SIZE AS DEFAULT
         CR    R4,R2               CHECK IF INPUT FITS OUTPUT
         BNL   SET                 BRANCH IF NO
         LR    R3,R4               SET MAX OUTPUT SIZE
         LA    R15,0(4,R7)         GET INPUT DATA PLUS OFFSET
CHK      CLI   0(R15),C' '         LOOK FOR LAST BLANK
         BE    SET                 FOUND LAST BLANK
         BCTR  R15,R0              DECREMENT TO PREVIOUS
         BCT   R3,CHK              DECR. FOR MOVE AND BRANCH
         CH    R4,LIMITSZ          MAX OUTPUT LENGTH
         BL    AROUND              TRY NEXT CARD IF LOW
         B     ERR6                ELSE ERROR ASSUMED
         EJECT
***********************************************************************
*                                                                     *
*        MOVE COMMENTS TO OUTPUT CARD, AND DETERMINE IF ANOTHER       *
*        COMMENTS CARD WILL BE NEEDED TO CONTINUE COMMENTS.           *
*                                                                     *
***********************************************************************
SET      DS    0H
         EX    R3,ODMOVE           MOVE DATA TO OUTPUT
         LA    R3,1(R3)            BUMP FOR EXECUTE
AROUND   SR    R2,R3               DECREMENT AMOUNT MOVED
         LTR   R2,R2               ANY LEFT TO MOVE
         BNP   XCARD               NO, GO GENERATE RECORD
         CLI   71(R5),C' '         CONTINUATION CARD
         BNE   ERR6                YES, CANNOT CONT. COMMENTS
         LA    R9,35(,R8)          SET NEW OUTPUT LOCATION
         LA    R7,0(R3,R7)         UPDATE INPUT RECORD POINTER
         OI    FLG,CR              SET COMMENT CONT REQUEST
         B     XCARD               GO PROCESS THIS CARD
SETCOL   L     R9,COMMSTRT         GET START OF COMMENTS COL
         BCTR  R9,R0               DECREMENT FOR EXECUTE
         AR    R9,R8               9 = OUTPUT COL COMM START
         B     RESUME              BRANCH TO CONTINUE
COMLOC0  L     R9,COMMSTRT         GET START OF COMMENTS COL
         BCTR  R9,R0               DECREMENT FOR EXECUTE
         AR    R9,R8               9 = OUTPUT COL COMM START
         B     MOVECOM             BRANCH TO CONTINUE
XCARD    DS    0H
         CLI   0(R8),C'*'          COMMENTS CARD?
         BE    SEQNEW              YES, BRANCH TO TEST MORE
         CLC   0(2,R8),=CL2'.*'    MACRO COMMENTS
         BNE   SEQOLD              NO, USE OLD SEQUENCE
SEQNEW   TM    FLG,GC              IS THIS COMMENT GENERATED
         BZ    SEQOLD              NO, USE OLD SEQ NUMBER
         MVI   80(R8),C'*'         FLAG ADDED CARD
         SR    R1,R1               CLEAR FOR COUNT
         LA    R15,CURRENT+79      FIND END OF CARD
COUNT    TM    0(R15),X'F0'        FIND NUMERICS
         BNO   SETNUMB             NON NUMERICS, SET COUNT
         LA    R1,1(R1)            UPDATE COUNT
         CH    R1,=H'8'            CHECK LIMIT
         BNL   SETNUMB             BRANCH IF ALL 8 NUMBERICS
         BCT   R15,COUNT           GO CHECK NEXT
         B     ERR7                ERROR IF FALL THROUGH
         EJECT
***********************************************************************
*                                                                     *
*        DETERMINE IF POSSIBLE WHAT THE NEXT SEQUENCE NUMBER SHOULD   *
*        BE.  IF ABLE TO, INCREASE THE OLD SEQUENCE NUMBER BY 1.      *
*                                                                     *
***********************************************************************
SETNUMB  LTR   R10,R1              COPY TO COUNT REG
         BZ    ERR7                BRANCH IF NO NUMERICS
         LR    R0,R10              SAVE COUNT OF NUMBS
         BCTR  R10,R0              DECREMENT FOR RUBBER BANDS
         MVC   SEQC(8),ZEROS       CLEAR FOR CONVERT
         MVC   SEQN(8),ZEROS       CLEAR FOR CONVERT
         LA    R15,CURRENT+80      GET POINTER TO END OF CARD
         LA    R1,SEQC+8           FIND END OF SEQ
         SR    R15,R0              BACKUP TO START OF NUMERICS
         SR    R1,R0               DITTO FOR NEXT
         EX    R10,MOVEC           MOVE CURRENT SEQ TO WORK
         LA    R15,NEXT+80         GET END OF NEXT
         LA    R1,SEQN+8           GET END OF WORK AREA
         SR    R15,R0              TO START OF NUMBS
         SR    R1,R0               DITTO
         EX    R10,MOVEC           MOVE NEXT SEQ TO WORK
         PACK  WORK(8),SEQC(R5)    PACK FOR CONVERT
         CVB   R15,WORK            MAKE SEQ NUMB BINARY
         PACK  WORK(8),SEQN(R5)    PACK FOR CONVERT
         CVB   R1,WORK             MAKE SEQ NUMB BINARY
         SR    R1,R15              GET SEQ NUMB DIFFERENCE
         BNP   ERR7                INSURE REMAINDER EXISTS
         C     R1,=F'1'            CAN NEW SEQUENCE BE ADDED?
         BNH   ERR7                CANT ADD, ERROR
         A     R15,=F'1'           UPDATE BY ONE HUNDRED
         MVC   72(8,R8),CURRENT+72  SET UP NON NUMERICS
         XC    SEQC(8),SEQC        CLEAR FOR UNPACK
         CVD   R15,WORK            MAKE DECIMAL AGAIN
         UNPK  SEQC(8),WORK+3(5)   MAKE PRINTABLE
         OI    SEQC+7,C'0'         MAKE LAST PRINT TOO
         LA    R15,SEQC+8          FIND END OF NEW SEQ
         SR    R15,R0              WHERE TO START MOVE
         LA    R1,80(R8)           END OF OUTPUT CARD
         SR    R1,R0               DECREMENT TO NUMERICS START
         EX    R10,MOVEC           MOVE UPDATED SEQ NUMB
         MVC   CURRENT+72(8),72(R8)  UPDATE CURRENT SEQ ALSO
         B     NOCONT              SKIP OLD SEQUENCE RTN
         EJECT
***********************************************************************
*                                                                     *
*        OUTPUT CARD TO THE NEW FILE, AND DETERMINE IF ANOTHER        *
*        COMMENTS CARD MUST BE GENERATED.  IF SO, RETURN TO           *
*        COMMENTS ROUTINE TO CONTINUE THEM.                           *
*                                                                     *
***********************************************************************
SEQOLD   MVC   71(9,R8),71(R5)     MOVE CONTIN. AND COMMENTS
         CLI   SUPCODE,C'@'        ANY SUPPORT CODE FOR THIS REC
         BNE   XCARD1              NO, SKIP SUPCODE
         MVC   63(8,R8),SUPCODE    UPDATE SUPCODE IN REC
XCARD1   EQU   *
         NI    FLG,ALLBITS-CC      RESET CONTINUATION FLAG
         CLI   71(R5),C' '         CONTINUATION CARD
         BE    TSTLIT2             NO, GO CHECK LITERAL SW
         OI    FLG,CC              SET CONTINUATION FLAG
         B     NOCONT              AROUND LITERAL TESTS
TSTLIT2  TM    FLG,LC              LITERAL CONTINUATION ON
         BO    ERR5                YES, ERR MESSAGE
NOCONT   DS    0H                  LABEL
         PUT   OUTPUT,0(R8)        WRITE NEW CARD
XCARD15  EQU   *
         BAL   R10,PRINTIT         PRINT OUTPUT IF DESIRES
XCARD2   MVI   0(R8),C' '
         MVC   1(125,R8),0(R8)     CLEAR OUTPUT
         MVI   SUPCODE,0           IN-VALIDATE SUPPORT CODE
         TM    FLG,CR              COMMENT CONT. REQ'D?
         BZ    GET                 NO, BRANCH TO GET NEXT
         OI    FLG,GC              SET COMMENT CONT. ACTIVE
         MVI   0(R8),C'*'          SET COMMENT CHARACTER
         TM    FLG,SI              SPECIAL OPERATOR
         BZ    MOVEMORE            NO, NORMAL COMMENTS
         TM    FLG,MAC             WITHIN A MACRO
         BZ    MOVEMORE            NO, NORMAL COMMENTS
         MVC   0(2,R8),=C'.*'      MOVE MACRO COMMENTS DATA
         B     MOVEMORE            GO GET MORE COMMENTS
         EJECT
***********************************************************************
*                                                                     *
*        EXECUTED (RUBBER BAND) INSTRUCTIONS AND END OF INPUT ROUTINE *
*                                                                     *
***********************************************************************
LMOVE    MVC   0(0,R8),0(R7)       MOVE LABEL TO OUTPUT
ORMOVE   MVC   9(0,R8),0(R7)       MOVE OPERATOR
FINDB    TRT   0(0,R7),BTABLE      FIND A BLANK
FINDNB   TRT   0(0,R7),NBTABLE     FIND A NON-BLANK
LITCHECK TRT   0(0,R7),QTABLE      FIND A QUOTE
QBCHECK  TRT   0(0,R7),QBTABLE     LOOK FOR QUOTE OR BLANK
AIFCHK   TRT   0(0,R7),PTABLE      LOOK FOR PERIOD (AIF)
ODMOVE   MVC   0(0,R9),0(R7)       MOVE OPERAND
COMMOVE  MVC   0(0,R9),0(R7)       MOVE COMMENT
SHIFTL1  MVC   0(0,R7),1(R7)       MOVE TEXT OVER 2ND QUOTE
MACOMP   CLC   0(0,R7),0(R14)      COMPARE FOR MACRO OPERATORS
MVESPACE PACK  WORK,15(0,R8)       MOVE SPACE VALUE TO WORK
CLEARHED XC    0(0,R1),0(R1)       CLEAR HEADING
MOVEC    MVC   0(1,R1),0(R15)      MOVE CURRENT SEQ
PARMMOVE MVC   0(1,R14),0(R4)      MOVE PARM TO WORK AREA
EOD      EQU   *                   EOD ON INPUT
         OI    FLG,EF              SET END OF FILE IND
         B     ONCEMORE            DO FINAL CARD
EODAD    CLOSE (INPUT,,OUTPUT,,PRINT)  CLOSE INPUT AND OUTPUTS
EXIT     L     R13,4(R13)
         L     R15,RETCODE         GET RETURN CODE
         L     R14,12(R13)         GET RETURN REG
         LM    R0,12,20(R13)       RESTORE REGS
         BR    R14                 RETURN
***********************************************************************
*                                                                     *
*        PRINT ROUTINE.  ALL RECORDS WHICH ARE OUTPUTED WILL ALSO     *
*        BE PRINTED.  THE TITLE FOR THE HEADER IS TAKEN FROM THE      *
*        INPUT SOURCE ASSEMBLY FILE IF ONE EXISTS.                    *
*                                                                     *
***********************************************************************
PRINTIT  EQU   *                   PRINTS OUTPUT
         CLI   0(R8),C'/'          JCL
         BCR   8,R10               RETURN IF SO
         CLC   9(6,R8),=C'TITLE '  IS THIS A TITLE CARD
         BNE   PRINTIT1            NO - GO PRINT CARD
         CLI   15(R8),C''''        HAS TITLE BEEN ALIGNED
         BNE   PRINTIT1            NO - PRINT WITHOUT TITLE
         MVC   HEADING+1(55),16(R8)  MOVE TITLE TO HEADING
         L     R0,=F'1'            QUOTE COUNT
         LA    R7,HEADING+1        A(HEADING+1)
         LA    R2,54               MAXIMUMUM LENGTH - 1
TQ0      EX    R2,LITCHECK         SEEK QUOTE
         BC    HIT,TQ05
         LA    R1,0(2,R7)          WHERE QUOTE SHOULD BE (COL 71)
         B     TQ1
TQ05     EQU   *
         X     R0,=F'1'            ODD OR EVEN COUNT
         CLI   1(R1),C''''         DOUBLE QUOTE
         BE    TQ06                YES
         LTR   R0,R0               EVEN NUMBER OF QUOTES
         BZ    TQ1                 YES - EXIT
TQ06     EQU   *
         X     R0,=F'1'            ODD OR EVEN COUNT
         LA    R1,1(R1)            POINT TO SECOND QUOTE
         LR    R6,R1
         SR    R1,R7               NUMBER THRU 1ST QUOTE
         SR    R2,R1               NUMBER TO SCAN
         LR    R7,R6
         EX    R2,SHIFTL1          CLEAR SECOND QUOTE
         BCT   R2,TQ0              KNOCK 1 OFF AND BRANCH BACK
TQ1      MVI   0(R1),C' '          BLANK TRAILING QUOTE
         OI    FLG2,X'01'          FORCE NEW PAGE EJECT
         LA    R7,HEADING+54       A(LAST BYTE OF TITLE)
         SR    R7,R1               FIND NUMBER OF BYTES AFTER
         BNH   PRINTIT1            IF NONE
         BCTR  R7,R0
         EX    R7,CLEARHED         BLANK HEADING PAST TITLE
         B     PRINTIT1
         EJECT
***********************************************************************
*                                                                     *
*        PRINT OUTPUT LINE, AND CAUSE OVERFLOW IF END OF PAGE OR      *
*        IF THE EJECT REQUEST BIT HAS BEEN SET.                       *
*                                                                     *
***********************************************************************
PRINTIT1 EQU   *                   PRINT OUTPUT
         L     R1,LINES            GET LINE COUNT
         LTR   R1,R1               NEW PAGE REQUIRED?
         BZ    NEWPAGE             YES, GENERATE SKIP
         TM    FLG2,X'01'          EJECT REQUIRED?
         BNO   NPRINT              NO, NORMAL PRINT
NEWPAGE  NI    FLG2,ALLBITS-X'01'  RESET EJECT REQUEST
         PUT   PRINT,HEADING
         MVI   CCHAR,C'0'          DOUBLE SPACE AFTER PRINT
         LA    R1,54               SET NEW LINE COUNT
NPRINT   EQU   *
         BCTR  R1,R0               DECREMENT LINE COUNT
         ST    R1,LINES            PUT IT BACK FOR LATER
         PUT   PRINT,CCHAR
         MVI   CCHAR,C' '
         BR    R10                 RETURN
         EJECT
***********************************************************************
*                                                                     *
*        ERROR MESSAGE GENERATION ROUTINE.  ALL ERROR MESSAGES        *
*        THAT CAN BE GENERATED WILL BE MOVE WITHIN THIS ROUTINE.      *
*                                                                     *
***********************************************************************
ERR1     MVC   85(20,R8),ERR1MSG   MOVE MSG TO OUTPUT
         B     ERRX
ERR2     MVC   85(20,R8),ERR2MSG   MOVE MSG TO OUTPUT
         B     ERRX
ERR3     MVC   85(20,R8),ERR3MSG   MOVE MSG TO OUTPUT
         B     ERRX
ERR4     MVC   85(20,R8),ERR4MSG   MOVE MSG TO OUTPUT
         B     ERRX
ERR5     MVC   85(20,R8),ERR5MSG   MOVE MSG TO OUTPUT
         B     CPUT                OUPUT CARD AS IS
ERR6     MVC   85(20,R8),ERR6MSG   MOVE MSG TO OUTPUT
         B     ERRX                GO TO ERROR COMMON
ERR7     MVC   85(20,R8),ERR7MSG   MOVE MSG TO OUTPUT
         MVC   79(1,R8),SEQSAVE    RESTORE SEQ NUMB
         MVC   NEXT+79(1),SEQSAVE+1  RESTORE SEQ NUMB
         OI    RETCODE+3,X'04'     SET RETURN CODE
         NI    FLG,ALLBITS-GC-CR   RESET COMMENTS CONTROL FLAGS
         B     XCARD1              GENERATE NEW COMMENTS CARD
ERR8     MVC   85(20,R8),ERR8MSG   MOVE MSG TO OUTPUT
         NI    FLG,ALLBITS-LC      RESET LITERAL CONTINUATION
         B     NOCONT              GO OUTPUT CARD
ERRX     EQU   *
         MVC   0(80,R8),0(R5)      MOVE ORIGINAL CARD TO OUTPUT
         OI    RETCODE+3,X'08'     SET ERROR RETURN CODE
         B     XCARD
         EJECT
***********************************************************************
*                                                                     *
*        LITERAL POOL AND CONSTANTS AREA.                             *
*                                                                     *
***********************************************************************
         LTORG
FLG2     DC    X'00'               PRINT OPTION FLAG
FLG      DC    X'00'
*                                  80 = CONTINUATION CARD
*                                  40 = END OF FILE INDICATOR
*                                  20 = PROCESSING MACRO
*                                  10 = PROCESSING 'AIF' INSTR
*                                  08 = PROCESSING SPECIAL MACRO INSTR
*                                  04 = LITERAL CONTINUATION
*                                  02 = CURRENT RECORD IS COMMENTS CONT
*                                  01 = COMMENTS CONT REQUESTED
WORK     DS    D'0'
SEQC     DS    D
SEQN     DS    D
ZEROS    DC    CL8'00000000'
NINES    DC    CL8'99999999'
PARMWORK DC    CL8'00000000'
SUPCODE  DC    CL8' '
RETCODE  DC    F'0'
LINES    DC    F'0'
PTABLE   DC    75X'00',C'.',180X'00'
PAD      DC    F'0'
COMMSTRT DC    F'0'                START OF COMMENTS
LIMIT    DC    F'0'                END OF COMMENTS
BTABLE   DC    64X'00',C' ',191X'00'
NBTABLE  DC    64X'FF',X'00',191X'FF'
QTABLE   DC    125X'00',C'''',130X'00'
QBTABLE  DC    XL256'00'           INITIALIZED ON ENTRY
SEQSAVE  DC    H'0'                SEQ SAVE AREA
LIMITSZ  DC    H'0'                SIZE OF COMMENTS
HEADING  DC    C'1'
         DC    CL126' JUSTIFY MARGINS AND ORGANIZE ASSEMBLER CODE'
CCHAR    DS    CL1
PAREA    DC    CL126' '
ERR1MSG  DC    CL20'LABEL TOO LONG'
ERR2MSG  DC    CL20'NO OPERATOR'
ERR3MSG  DC    CL20'OPERATOR TOO LONG'
ERR4MSG  DC    CL20'NOTE, NOT ALIGNED'
ERR5MSG  DC    CL20'-'
ERR6MSG  DC    CL20'COMMENT TOO LONG'
ERR7MSG  DC    CL20'SEQUENCING ERROR'
ERR8MSG  DC    CL20'UNBALANCED QUOTES'
ERR9MSG  DC    CL20'NOTE, COMMENT CONT'
         SPACE 2
***********************************************************************
*                                                                     *
*        SPECIAL OPERATORS TABLE TO HANDLE MACRO AND COPY STATEMENTS  *
*                                                                     *
***********************************************************************
TSTBL    DC    CL6'AIF'
         DC    CL6'AGO'
         DC    CL6'ANOP'
         DC    CL6'GBLA'
         DC    CL6'GBLB'
         DC    CL6'GBLC'
         DC    CL6'LCLA'
         DC    CL6'LCLB'
         DC    CL6'LCLC'
         DC    CL6'ACTR'
         DC    CL6'SETA'
         DC    CL6'SETB'
         DC    CL6'SETC'
MEND     DC    CL6'MEND'
         DC    CL6'MNOTE'
         DC    CL6'MEXIT'
         DC    CL6'PRINT'
         DC    CL6'PUNCH'
         DC    CL6'REPRO'
MACRO    DC    CL6'MACRO'
         SPACE 2
***********************************************************************
*                                                                     *
*        DATA CONTROL BLOCKS AND BUFFER AREAS FOR INPUT RECORDS.      *
*                                                                     *
***********************************************************************
INPUT    DCB   DSORG=PS,MACRF=GM,LRECL=80,EODAD=EOD,DDNAME=SYSIN
OUTPUT   DCB   DSORG=PS,MACRF=PM,LRECL=80,DDNAME=SYSPUNCH
PRINT    DCB   DSORG=PS,MACRF=PM,LRECL=120,RECFM=FA,DDNAME=SYSPRINT,   X
               BLKSIZE=120
CURRENT  DC    CL80' '
NEXT     DC    81C'9'
         END
