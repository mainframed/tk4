         TITLE ' >>> G P P  -  GENERAL PURPOSE PROMPTER FOR TSO <<<'
*
*  MSG - MACRO TO GENERATE AN ERROR MESSAGE
*
         MACRO
&NAME    MSG   &TEXT,&L
         LCLA  &N
&N       SETA  K'&TEXT-2
&NAME    DC    AL1(&N)             LENGTH OF MESSAGE TEXT
         DC    C&TEXT              ERROR MESSAGE
         AIF   ('&L' EQ '').END
L&NAME   EQU   *-&NAME
.END     SPACE 1
         MEND
         SPACE 10
*
*        LOCAL WORKAREA
*
WORKAREA DSECT
         SPACE
SAVEAREA DS    18F
         SPACE
PARMCNT  DS    H
PARMFLD  DS    CL256
         SPACE
         CNOP  6,8
ADLIST   DS    H
         DS    12D
         EJECT
PARMPTR  DS    F
ALTDPTR  DS    F
ATTACH   ATTACH EPLOC=DUMMY,SF=L
         SPACE 3
XCTL     XCTL  EPLOC=DUMMY,SF=L
         ORG   XCTL
TASKDCB  DCB   DSORG=PO,MACRF=(R),DDNAME=DUMMY
         SPACE
DCB      EQU   TASKDCB
PGMECB   DS    F
TCBSAVE  DS    F                   POINTER TO TCB
OPENCLOS DS    F              OPEN CLOSE LIST
         SPACE
ENDMAIN  EQU   *
         SPACE
CMDLEN   DS    H
CMDFLD   DS    CL256               COPY OF COMMAND
STRLEN   DS    H
STRING   DS    CL50
OSTRLEN  DS    H
SUBSTRLN DS    H
SUBSTR   DS    CL50
         SPACE
CPPLSAVE DS    F
PARMSAVE DS    F
         SPACE
DAIRRC   DS    F                   DAIR RETURN CODE
         SPACE
TEMP     DS    CL8
         SPACE
STACKPB  DS    2F
STACKPL  DS    4F
STACKECB DS    F
         SPACE
DAFLPL   DS    4F                  DAIR FAIL PARAMETER LIST
         SPACE
DAIRECB  DS    F
         SPACE
DDNAME   DS    CL8
         SPACE
         DS    0H
DSNAME   DS    0CL46
DSNLEN   DS    H
DSN      DS    CL44
         SPACE
BASICLEN DS    H                   LENGTH OF BASIC DSNAME
BASICDSN DS    CL44                BASIC DATASET NAME
BASICMEM DS    CL8                 BASIC MEMBER NAME
         SPACE
NEWSPACE DS    0H                  SPACE FOR SPACE
NEWAVLTH DS    H                   AVERAGE BLOCK LENGTH
NEWPRIME DS    H                   PRIMARY SPACE QUANTITY
NEWSEC   DS    H                   SECONDARY SPACE QUANTITY
         SPACE
NEWVOL   DS    CL8                GENERIC VOLUME SERIAL
         SPACE
MEMLIST  DS    34H                 BLDL MEMBER NAME LIST
PFIRST   DS    X
PASS     DS    X                   FIRST OR SECOND PASS BY OPTIONS
         SPACE
SW       DS    X
OFF      EQU   X'00'
ON       EQU   X'FF'
ONP      EQU   X'0F'
         SPACE
FLAGS    DS    X
NEW      EQU   128
*NOALTDD    EQU   64          NO FRICKING ALTDD FOR THIS OPTION
NULLDS   EQU   32
MEMBERED EQU   16
QUOTED   EQU   8
STARRED  EQU   4
*PDS     EQU   2
OLD      EQU   1
         SPACE
FIRSTCH  DS    X                   FIRST CHARACTER SWITCH
         SPACE
SINQED   DS    X                   SYSIN QUOTED SWITCH
         SPACE
FLAGS2   DS    X
GOTBASIC EQU   1
BASICQED EQU   2
SPCLDSN  EQU   4                   PROCESSING SPECIAL DATASETS
FLAGSUMW DS    X              EXTENTION OF FLAGS
WASRP    EQU   1              MEMBER NAME ENDED IN RIGHT PARENTHESIS
XTRAQUAL EQU   2              QUALIFIER WAS ADDED TO USERS DSN
VOLLED   EQU   4              DSN HAS :VOLSER
TDOTTED EQU   8              DSN HAS TRAILING DOT
LDOTTED  EQU   16             DSN HAS LEADING PERIOD
PSWDDED  EQU   32             DSN HAS /PASSWORD
         SPACE
EXQUOTE  DS    C              QUOTE IF = FOLLOWED BY ' OR " ELSE BLANK
EXLASTCH DS    C              CHARACTER BEFORE CURRENT ONE
EXVAR    DS    C              FLAG  INDICATES SCRIPT VAR
         SPACE
EXDEPTH  DS    X                   EXTRACT PAREN DEPTH
         SPACE
ALFLAGS  DS    X                   ALLOCATION FLAGS
BADSN    EQU   1                    INVALID DATASET NAME
FREE     EQU   2                    DATASET IS TO BE FREED
MAYBBAD  EQU   4              PERHAPS BAD. TRY WITHOUT QUAL
         EJECT
SAVE0    DS    10F
ALSAVE   EQU   SAVE0
         SPACE
SAVE1    DS    10F                 FIRST LEVEL SUBROUTINE SAVE AREA
GDSAVE   EQU   SAVE1
DSSAVE   EQU   SAVE1
SPSAVE   EQU   SAVE1
INSAVE   EQU   SAVE1
MNSAVE   EQU   SAVE1
SDSAVE   EQU   SAVE1
SRSAVE   EQU   SAVE1
SCSAVE   EQU   SAVE1
CDSAVE   EQU   SAVE1
GMSAVE   EQU   SAVE1
EXSAVE   EQU   SAVE1
IDPSAVE  EQU   SAVE1
CLNSAVE  EQU   SAVE1
DISAVE   EQU   SAVE1
SBSAVE   EQU   SAVE1
         SPACE
SAVE2    DS    10F                 SECOND LEVEL SUBROUTINE SAVE AREA
D18SAVE  EQU   SAVE2
DNSAVE   EQU   SAVE2
SMSAVE   EQU   SAVE2
         SPACE
DAIRPB18 DS    10F                 DAIR PB FOR FREEING STUFF
         SPACE
         SPACE
DAIRPB   DS    19F                 DAIR PARAMETER BLOCK
DPBLEN   EQU   *-DAIRPB
DAIRPL   DS    5F                  DAIR PARAMETER LIST
         SPACE
ENTRDAIR DS    F                   ENTRY POINT TO DAIR
ENTRPUTL DS    F                   ENTRY POINT TO PUTLINE
         SPACE
MEMPTR   DS    A              INDEX OF START OF USER ENTERED MEMBER
PASPTR   DS    A              INDEX OF START OF USER ENTERED PASSWORD
VOLPTR   DS    A              INDEX OF START OF USER ENTERED VOLSER
MEMNAME  DS    CL8            MEM ENTERED BY USER (MEMNAME)
PASSWD   DS    CL8            PSWD ENTERED BY USER /PASSWORD
VOLID    DS    CL8            VOLSER ENTERED BY USER :VOLSER
         SPACE
DTEMP    DS    CL8
         SPACE
OFLAGS   DS    10X
         SPACE
MSGAREA  DS    CL80                AREA FOR MESSAGE TEXT TO BE UPDATED
         SPACE
INMSGLEN DS    H
INMSG    DS    CL80                AREA TO READ MSEEAGE FROM TERMINAL
         SPACE
HELP     DS    CL81
LISTSW   DS    X
LASTDD   DS    F
DDSAV    DS    F
CONCATPL DS    CL20
CONCATPB DS    CL12
DDLIST   DS    20F
CTLGDSN  DS    CL50
WCAMLIST CAMLST   UCATDX,CTLGDSN
*LCAMLIST CAMLST  NAME,CTLGDSN,,LOCAREA  FOR LOCATE BY DSNAME
*LOCAREA  DS    0D             FOR LOCATE
*         DS    256C
WORKSZ   EQU   *-WORKAREA
WORK2SZ  EQU   *-ENDMAIN
         EJECT
*
*        VARIOUS DESECTS
*
CBUF     DSECT ,                   DSECT FOR COMMAND BUFFER
CBUFLEN  DS    H                   LENGTH OF THIS DSECT
CBUFOFF  DS    H                   OFFSET TO FIRST BYTE AFTER CMD NAME
CBUFCMD  DS    0C                  CHARACTER STRING FROM TERMINAL
         SPACE 3
CDL      DSECT ,                   DSECT FOR COMMAND DESCRIPTOR LIST
CDLPGM   DS    CL8                 NAME OF ASSOCIATED PROGRAM
CDLTDSN  DS    A                   ADDR OF TASKLIB DSNAME, IF ANY
CDLADL   DS    A                   ADDR OF ALTERNATE DDNAME LIST
CDLOPT   DS    A                   ADDR OF OPTION LIST
CDLSDL   DS    A                   ADDR OF SPECIAL DDNAME LIST
CDLINSRT DS    A                  ADDR OF INSERT PARM STRING
         SPACE 3
CPPL     DSECT ,                   DSECT FOR CMD PROCESSOR PARM LIST
CPPLCBUF DS    A                   PTR TO COMMAND BUFFER
CPPLUPT  DS    A                   PTR TO UPT
CPPLPSCB DS    A                   POINTER TO PSCB
CPPLECT  DS    A                   POINTER TO ECT
         SPACE 3
ADL      DSECT ,                   DSECT FOR ALTERNATE DDNAMES
ADLLEN   DS    H                   SIZE OF ADL
ADLDDNAM DS    CL8                 FIRST OF (UP TO 10) DDNAMES
         SPACE 3
OPTIONS  DSECT ,                   DSECT FOR OPTION LIST
OPTNAME  DS    A                   OPTION TO BE CHECKED FOR
OPTQUAL  DS    A                   QUALIFIER TO BE APPENDED TO DSNAME
OPTDAPB  DS    A                   ADDR OF ASSOCIATED DAIR PARM BLOCK
OPTDCB   DS    A                   ADDR OF ASSOCIATED DCB
OPTDFLT  DS    A                   ADDR OF STRING USED BY DEFAULT
OPTPRMPT DS    A                   PROMPT STRING ADDRESS
OPTHELP  DS    A                   HELP STRING ADDRESS
OPTINSRT DS    A                   INSERT STRING ADDRESS
OPTDFINS DS    A                  DEFAULT INSERT STRING
OPTNOINS DS    A                  INSERT IF 'NO' SPECIFIED
OPTCNCAT DS    A                  CONCAT THIS STRING TO RIGHT OF PARM
OPTFLAGS DS    X                   OPTION FLAGS
LAST     EQU   X'01'                 LAST OPTION IN LIST
DEFAULT  EQU   X'02'                 DEFAULT STRING ENTERED
PROMPT   EQU   X'04'                 PROMPT STRING ENTERED
INSERT   EQU   X'08'                 INSERT STRING ENTERED
CONCATST EQU   X'10'              CONCATENATION STRING ENTERED
NOALTDD  EQU   X'40'                   DONT GENERATE DAIR DDNAME
OPTALLOC DS    X                   ALLOCATION FLAGS
*OLD     EQU   1                     DATASET MUST BE OLD
*PDS     EQU   2                     DATASET MUST BE A PDS
OPTSPACE DS    3H                  SPACE TO BE ALLOC'ED FOR NEW DATASET
         DS    0F                  SPACER
OPTLEN   EQU   *-OPTIONS
         EJECT
DAPB08   DSECT
***********************************************************************
* THIS OPERATION CODE CAUSES ALLOCATION OF A DATA SET. IT CAN ALLOC.  *
* EITHER A NEW OR OLD SET.                                            *
***********************************************************************
DA08CD   DS    CL2      DAIR ENTRY CODE
DA08FLG  DS    X        FUNCTIONS TO BE PERFORMED WHEN RET CODE IS 0
DA08FPE  EQU   X'80'    FUNCT PERFORMED BUT ERROR INDICATED BY RETCD
         DS    X
DA08DARC DS    H        DYN ALLOC RETURN CODE
DA08CTRC DS    H        CATALOG RETURN CODE
DA08PDSN DS    A        POINTER TO DSNAME TO BE SEARCHED IN DSE
DA08DDN  DS    CL8      DDNAME TO BE SEARCHED IN DSE
DA08UNIT DS    CL8      UNITNAME REQUESTED
DA08SER  DS    CL8      VOLUME SERIAL NUMBER-PADDED W/BLANKS
DA08BLK  DS    CL4      DATA SET  AVERAGE RECORD LENGTH
DA08PQTY DS    CL4      PRIMARY SPACE QUANTITY
DA08SQTY DS    CL4      SECONDARY SPACE QUANTITY
DA08DQTY DS    CL4      DIRECTORY BLOCK QUANTITY
DA08MNM  DS    CL8      MEMBER NAME
DA08PSWD DS    CL8      PASSWORD
DA08DSP1 DS    X        DATA SET STATUS FLGS(IF=0 OLD ASSUMED)
DA08SHR  EQU   X'08'    DATA SET IS SHR
DA08NEW  EQU   X'04'    DATA SET IS NEW
DA08MOD  EQU   X'02'    DATA SET IS MOD
DA08OLD  EQU   X'01'    DATA SET IS OLD
DA08DPS2 DS    X        DATA SET DISPOSITION(IF=0 KEEP ASSUMED)
DA08KEEP EQU   X'08'    DS DISP IS KEEP
DA08DEL  EQU   X'04'    DS DISP IS DELETE
DA08CAT  EQU   X'02'    DS DISP IS CATLG
DA08UCAT EQU   X'01'    DS DISP IS UNCATALOG
DA08DPS3 DS    X        DATA SET CONDITIONAL DISPOSITION
DA08KEP  EQU   X'08'
DA08DELE EQU   X'04'
DA08CATL EQU   X'02'    DS DISP OF CATLG DESIRED
DA08UNCT EQU   X'01'    DS DISP OF UNCATLG DESIRED
DA08CTL  DS    X        FLAGS TO CONTROL ACTIONS TAKEN BY DAIR
DA08TRKS EQU   X'80'    UNITS ARE TRKS
DA08ABKL EQU   X'40'
DA08CYLS EQU   X'C0'    UNITS ARE CYLS
DA08UID  EQU   X'20'    USER ID IS TO BE PREFIXED
DA08RLSE EQU   X'10'    RELEASE (RLSE) REQUESTED
DA08PERM EQU   X'08'    DATA SET MUST BE SPECIFICALLY UNALLOCATED
DA08DMMY EQU   X'04'
         DS    CL3      RESERVED
DA08DSO  DS    CL1      DSORG
PDS      EQU   X'02'               BIT ON FOR A PDS
         EJECT
DAPB18   DSECT
***********************************************************************
* THIS OPERATION CAUSES THE REQUESTED DATA SET OR DDNAME TO BE        *
* UNALLOCATED. DISPOSITION CAN BE SPECIFIED TO OVERRIDE ANY PREVIOUS  *
* DISPOSITION. LIKENISE SYSOUT CLASS MAY BE SPECIFIED TO OVERRIDE ANY *
* PREVIOUS CLASS.                                                     *
***********************************************************************
DA18CD   DS    CL2      DAIR ENTRY CODE
DA18FLG  DS    X        FUNCTIONS TO BE PERFORMED WHEN RET CODE IS 0
DA18FPE  EQU   X'80'    FUNCT PERFORMED BUT ERROR INDICATED BY RETCD
         DS    X
DA18DARC DS    H                       DYNAMIC ALLOCATION RETURN CODE
DA18CTRC DS    H                  CATALOG RETURN CODE AREA
DA18PDSN DS    A        POINTER TO DSNAME TO BE SEARCHED IN DSE
DA18DDN  DS    CL8      DDNAME TO BE SEARCHED IN DSE
DA18MNM  DS    CL8      MEMBER NAME
DA18SCLS DS    CL2      SYSOUT CLASS DESIRED WHEN UNALLOCATING  A
*                       SYSOUT DATA SET
DA18DPS2 DS    X        DATA SET DISPOSITION
DA18KEEP EQU   X'08'    CHANGE DISP TO KEEP
DA18DEL  EQU   X'04'    CHANGE DISP TO DELETE
DA18CAT  EQU   X'02'    CHANGE DISP TO CATALOG
DA18UCAT EQU   X'01'    CHANGE DISP TO UNCATLOG
DA18CTL  DS    X        FLAGS FOR SPECIAL DAIR PROCESSING
DA18UID  EQU   X'20'    USER ID IS TO BE PREFIXED TO DSNAME
DA18JBNM DS    CL8
         EJECT
DAPB1C   DSECT
***********************************************************************
* THIS OPERATION CODE REQUESTS ALLOCATION TO THE TERMINAL             *
***********************************************************************
DA1CCD   DS    CL2      DAIR ENTRY CODE
DA1CFLG  DS    X        FUNCTIONS TO BE PERFORMED WHEN RET CODE IS 0
         DS    X
DA1CDARC DS    H        DYN ALLOC RETURN CODE
         DS    CL1      RESERVED
DA1CCTL  DS    CL1      CONTROL FIELD
DA1CPERM EQU   X'08'    PERMANENTLY ALLOCATE BIT
DA1CDDN  DS    CL8      DDNAME TO BE SEARCHED IN DSE
         SPACE 3
***********************************************************************
*    THE DYNAMIC ALLOCATION INTERFACE ROUTINE (DAIR) PARAMETER LIST   *
*    (DAPL) IS A LIST OF ADDRESSES PASSED FROM THE INVOKER TO DAIR    *
*    VIA REGISTER 1
***********************************************************************
DAPL     DSECT
         SPACE
DAPLUPT  DS    A        PTR TO UPT
DAPLECT  DS    A        PTR TO ECT
DAPLECB  DS    A        PTR TO CP'S ECB
DAPLPSCB DS    A        PTR TO PSCB
DAPLDAPB DS    A        PTR TO DAIR PARAMETER BLOCK
         EJECT
         DCBD
         EJECT
GPPROMPT CSECT
         SAVE  (14,12),,*          SAVE CALLER'S REGS
         LR    BASE,R15          ESTABLISH
         USING GPPROMPT,BASE        BASE REGISTER
         LA    BASE2,4094(BASE)    GET PTR TO SECOND BASE
         USING GPPROMPT+4094,BASE2  MAKE IT ADDRESSIBLE
         LR    R9,R1               GET PTR TO CPPL
         USING CPPL,R9              MAKE IT ADDRESSIBLE
*
*        GET AND SET UP A WORKAREA
*
         LA    R0,WORKSZ           GET
         GETMAIN R,LV=(0)           WORKAREA
         LR    R4,SAVE             TEMP SAVE FOR SAVE
         LR    RWORK,R1            MAKE IT
         USING WORKAREA,RWORK       ADDRESSIBLE
         ST    RWORK,8(R4)         FORWARD CHAIN
*
*        CLEAR OUR WORKAREA
*
         LA    R5,WORKAREA         GET PTR TO WORKAREA
         LA    R1,WORKSZ           GET COUNT
         BAL   LINK,CLEAR          CLEAR IT
         MVC   BASICLEN,=H'3'  INIT THE BASIC DSN TO TSO
         MVC   BASICDSN,=C'TSO'
         ST    R4,SAVEAREA+4       BACKWARD CHAIN
         ST    R9,CPPLSAVE         SAVE PTR TO CPPL
*
*        BRING IN DAIR
*
         LOAD  EP=IKJDAIR
         ST    R0,ENTRDAIR         SAVE ENTRY POINT
*
*        SET UP PARM LISTS, CLEAN COMMAND, AND OTHER INITIALIZATION
*
         BAL   LINK,SETPL          GO SET UP PL'S
         MVI   PARMFLD,C' '        BLANK OUT THE PROGRAM
         MVC   PARMFLD+1(255),PARMFLD    PARAMETER FIELD
         MVC   CMDFLD,PARMFLD      AND THE COMMAND FIELD
         L     R3,CPPLCBUF         GET PTR TO COMMAND BUFFER
         USING CBUF,R3
         LH    R1,CBUFLEN          GET LENGTH OF COMMAND FIELD
         SH    R1,=H'4'             LESS 4 FOR CTL BLKS
         LA    R2,CBUFCMD          NOW POINT AT COMMAND
         BAL   LINK,CLEANCMD        AND CLEAN UP COMMAND
         DROP  R3
         DROP  R9
         EJECT
*
*        PICK UP COMMAND AS ENTERED
*
DOCMD    DS    0H
         BAL   LINK,EXTRACT        GET COMMAND NAME
         BZ    ERROR                IT MUST BE THERE
         LH    R3,STRLEN           GET ITS LENGTH
         CLI   STRLEN+1,2
         BNE   CMDADDR        NOT POSSIBLE TO BE GPP
         CLC   STRING(3),=C'GPP'
         BNE   CMDADDR
*       GPP ...COMMAND ....  WAS ENTERED
         BAL   LINK,EXTRACT   GET REAL COMMAND
         BZ    ERROR
         LH    R3,STRLEN      LENGTH OF COMMAND
         MVC   MEMNAME(8),BLANK8
         EX    R3,MEMMVC
         LOAD  EPLOC=MEMNAME
         LR    R2,R0          ADDRESS OF COMMAND TABLE
         B     CMDSRCH
CMDADDR  L     R2,VCMDTAB     GET EXTERNAL ADDRESS
         LTR   R2,R2          IS IT RESOLVED
         BNZ   CMDSRCH
         LA    R1,MSG24       NO COMMAND TABLE
         B     MSNGR
CMDSRCH  EX    R3,CMDCLC           IS THIS THE COMMAND ?
         BE    GOTCMD               BR IF SO
         CLI   8(R2),X'FF'         CHECK FOR END OF TABLE
         BE    UMWFIRST       USE FIRST COMMAND.
         LA    R2,CMDENTLN(R2)     POINT AT NEXT ENTRY
         B     CMDSRCH              AND GO CHECK IT
UMWFIRST L     R2,VCMDTAB     ADDR OF FIRST COMMAND NAME
GOTCMD   L     R10,8(R2)           GET PTR TO CMD DESCRIPTOR LIST
         USING CDL,R10              MAKE IT ADDRESSIBLE
*  NOTE THAT R10 IS ASSUMED TO BE THE CDL POINTER FOR THE REMAINDER
*  OF THE PROGRAM.
*
*        COPY ALTERNATE DDNAME LIST TO WORKAREA
*
         L     R1,CDLADL           GET PTR TO ALT DDNAME LIST
         LTR   R1,R1               IS THERE ONE ?
         BZ    CMDEND              BR IF NONE
         USING ADL,R1
         LH    R2,ADLLEN           GET SIZE OF ADL
         LA    R2,1(R2)            ADD IN SIZE OF COUNT FIELD
         EX    R2,ADLMVC           MOVE ADL TO WORKAREA
         B     CMDEND              GO DO NEXT PROC
         SPACE
ADLMVC   MVC   ADLIST(0),0(R1)     EXECUTED MVC
CMDCLC   CLC   STRING(0),0(R2)
MEMMVC   MVC   MEMNAME(*-*),STRING
         DROP  R1
         SPACE
CMDEND   DS    0H
         EJECT
*
*        CHECK FOR OPTIONS
*
CHKOPT   DS    0H
         L     R1,CDLOPT           GET PTR TO OPTIONS
         LTR   R1,R1               ARE THERE ANY ?
         BZ    OPTDONE             BR IF NONE
         MVI   PFIRST,ON           TURN ON FIRST TIME THRU SWITCH
         MVI   PASS,1              INDICATE FIRST PASS OVER OPTIONS
         LA    R5,PARMFLD          GET PTR TO PARM FIELD
         ST    R5,PARMSAVE         SAVE PARM POINTER
*
*        EXTRACT AN OPTION AND GET ITS TABLE ENTRY
*
         CLI   CDLINSRT,X'00'
         BE    BUMPOPT
         SR    15,15
         IC    15,CDLINSRT
         L     14,CDLINSRT
         BCTR  15,0
         EX    15,CDLINSMV
         STH   15,STRLEN
         L     R1,PARMSAVE
         BAL   LINK,INSERTP
*
CDLINSMV MVC   STRING(*-*),0(14)
*
BUMPOPT  DS    0H
         BAL   LINK,EXTRACT        GET NEXT OPTION
         BZ    DONE                 BR IF NO MORE
         BAL   LINK,SCANOPT        SEARCH OPTION LIST
         BZ    PUTPARM             USE AS A PARM IF NOT AN OPTION
         USING OPTIONS,R2
*  NOTE THAT R2 IS ASSUMED TO BE THE CURRENT OPTION POINTER
*  UNTIL OPTDONE.
*
*  CHECK FOR CONCATENATION STRING FROM OPTION MACRO
*
         TM    OPTFLAGS,CONCATST
         BNO   NOCNCTST           BRANCH IF NO STRING
         CLI   PASS,2
         BE    NOCNCTST       DONT CONCAT IF DEFAULT
         BAL   LINK,CNCTST        CALL CONCAT STRING ROUTINE
NOCNCTST DS    0H
         L     R0,OPTDAPB          CHECK FOR A DAIR PARM BLOCK
         LTR   R0,R0               IF THERE ISN'T ONE THEN
         BZ    CHKOPINS             SKIP ALLOCATION
         MVC   FLAGS,OPTALLOC      INITIALIZE FLAGS
*
*        GET OR MAKE UP A DSNAME
*
         MVI   FLAGSUMW,0     INIT FLAGS
         XC    LASTDD,LASTDD
         MVI   LISTSW,C'0'
         CLI   SW,ONP              CHECK IF DSN SUPPLIED
         BE    GETODSN             BR IF THERE
         BL    DOALLOC              IF DUMMY DATASET THEN JUST ALLOC
         LA    R4,OPTQUAL          POINT TO QUALIFIER
         BAL   LINK,MAKENAM         CREATE A DSN
         B     CHECKNAM            GO ALLOCATE IT
GETODSN  LA    R4,OPTQUAL          POINT TO QUALIFIER
         BAL   LINK,SCANLIST      CHECK FOR CONCATENATION LIST
         LA    DDPTR,DDLIST       PICK UP ENTRY FOR FIRST SUBFIELD
         B     LISTGO
LISTLOOP DS    0H                 LOOP THRU SUBFIELDS, ALLOCATE EACH
         MVC   FLAGS,OPTALLOC      INITIALIZE FLAGS
         MVI   FLAGSUMW,0     INIT FLAGS
*         BAL   LINK,INITDPB
LISTGO   ST    DDPTR,DDSAV
         L     R3,0(DDPTR)        POINTER TO SUBFIELD
         L     R1,4(DDPTR)        LENGTH OF SUBFIELD
         BAL   LINK,SETDSN         EXTRACT DSNAME
*
*        ENSURE VALID DSNAME AND ALLOCATE THE DATASET
*
CHECKNAM BAL   LINK,CHECKDSN       GO SEE IF DSN IS O.K.
         BNZ   RNTRDSN              IF BAD, GO ASK FOR NEW DSN
DOALLOC  DS    0H             SET UP PARM BLOCK AND ALLOCATE
         BAL   LINK,INITDPB   GO SET UP DAIR PARM BLOCK
         BAL   LINK,ALLOCATE       NOW ALLOCATE THE DATASET
         TM    ALFLAGS,MAYBBAD     SHOULD WE TRY W/O QUAL?
         BO    RETRYAL        YUP.
         TM    ALFLAGS,BADSN  CHECK FOR INVALID DSNAME
         BO     RNTRDSN        ASK FOR ANOTHER NAME
         TM    FLAGS2,GOTBASIC     HAVE WE ALREADY GOTTEN BASIC DSN
         BO    DONEALOC              BR IF SO
         BAL   LINK,SETBASIC        ELSE, TRY TO GET A BASIC DSNAME
         B     DONEALOC       ALLOCATION COMPLETE
RETRYAL  DS    0H             RETRY ALLOC W/O QUALIFIER
         BAL   LINK,RMVQUAL   REMOVE QUALIFIER FROM DSN
*         MVC   FLAGS,OPTALLOC      INITIALIZE FLAGS
         BAL   LINK,INITDPB        GO SET UP OUR DAIR PARM BLOCK
         BAL   LINK,ALLOCATE  TRY ALLOC W/O QUALIFIER
         TM    ALFLAGS,BADSN  CHECK FOR INVALID DSNAME
         BO     RNTRDSN        ASK FOR ANOTHER NAME
DONEALOC DS    0H
         EJECT
*
*        CHECK FOR DCB AND OPEN IT FOR NEW OR TERMINAL DATASETS
*
         TM    FLAGS,NEW+STARRED   WAS THIS A NEW DATASET ?
         BZ    ENDOPEN             BR IF NOT
         L     R3,OPTDCB           WAS A DCB SUPPLIED ?
         LTR   R3,R3                IF NOT THEN
         BZ    ENDOPEN              SKIP OPEN
         MVC   DCB(LTDCB),0(R3)    MOVE IN THE DCB
         LA    R3,DCB               POINT AT IT
         USING IHADCB,R3
         MVC   DCBDDNAM,DDNAME     INSERT DDNAME
         OPEN  ((R3),OUTPUT),MF=(E,OPENCLOS)      TRY TO OPEN
         TM    DCBOFLGS,X'10'      DID IT WORK ?
         BO    OPCLOSE              BR IF SO
         MVC   MSGAREA(LMSG8),MSG8  ELSE SET UP OUR ERROR MESSAGE
         MVC   MSGAREA+17(8),DDNAME
         LA    R1,MSGAREA          AND GO TELL USER
         BAL   LINK,SENDMSG          OF THE PROBLEM
         B     ENDOPEN
OPCLOSE  CLOSE ((R3)),MF=(E,OPENCLOS)         NOW CLOSE THE DATASET
         DROP  R3
ENDOPEN  DS    0H
         L     DDPTR,DDSAV
         MVC   0(8,DDPTR),DDNAME
         LA    DDPTR,8(DDPTR)
         C     DDPTR,LASTDD
         BNH   LISTLOOP
         CLI   LISTSW,C'1'
         BNE   NOCONCAT
         BAL   LINK,CONCAT
         MVC   DDNAME,DDLIST
NOCONCAT DS    0H
*
*        PROCESS INSERT STRING
*
CHKOPINS TM    OPTFLAGS,INSERT     IS THERE AN INSERT STRING ?
         BNO   BUMPOPT              BR IF NOT
* COMMENTIZE NEXT TWO INSTRUCTIONS IF INSERT DESIRED FOR DEFAULTS
*         CLI   PASS,2              CHECK FOR PASS 2
*         BE    BUMPOPT              NO INSERT FOR DEFAULT STRINGS
         BAL   LINK,DOINSERT       GO PERFORM INSERTION
         B     BUMPOPT              AND GO GET NEXT OPTION
*
*        ASK USER TO REENTER DATASET NAME
*
RNTRDSN  DS    0H
         MVC   MSGAREA(LMSG6),MSG6 GET ERROR MESSAGE
         MVC   MSGAREA+18(44),DSN  INSERT DSNAME
         LA    R1,MSGAREA          POINT TO MESSAGE
         BAL   LINK,SENDMSG        GO TELL USER
         LA    R1,MSG16            POINT TO PROMPT MESSAGE
         BAL   LINK,GETMSG         AND ASK FOR NEW DSNAME
        OC    INMSG,BLANK80       UPPER CASE RESPONSE      UMW RCT
         LH    R1,INMSGLEN    LENGTH OF INPUT
         LA    R3,INMSG            GET PTR TO DSN
         LA    R4,OPTQUAL          GET PTR TO QUALIFIER
         MVI   FLAGSUMW,0     INIT FLAGS
         BAL   LINK,SETDSN         EXTRACT DSNAME
         B     CHECKNAM            GO RETRY
         EJECT
*
*        INSERT A NON-OPTION IN THE PARAMETER LIST
*
PUTPARM  DS    0H
         L     R1,PARMSAVE         GET POINTER TO PARM AREA
         CLI   PFIRST,ON           CHECK FOR FIRST TIME SWITCH
         BE    DOPMOVE             BR IF FIRST TIME
         MVI   0(R1),C','          MOVE IN A COMMA IF NOT FIRST TIME
         LA    R1,1(R1)            BUMP PARM POINTER
         LH    R0,PARMCNT          GET CURRENT PARM COUNT
         AH    R0,=H'1'            BUMP IT FOR ','
         STH   R0,PARMCNT          SAVE COUNT
DOPMOVE  BAL   LINK,INSERTP        INSERT PARM IN PARM FIELD
         MVI   PFIRST,OFF          TURN OFF FIRST TIME SWITCH
         B     BUMPOPT             GO TRY FOR NEXT OPTION OR PARM
RMVQUAL  DS    0H             REMOVE QUALIFIER FROM DSN
         STM   R0,R10,SAVE2   SAVE SOME REGS
         NI    FLAGSUMW,255-XTRAQUAL TURN OFF ADDED QUAL BIT
         LA    R4,OPTQUAL     -> QUALIFIER
         LA    R1,DSN              GET PTR TO DSN
         LH    R5,DSNLEN            AND DSNAME LENGTH
         LA    R3,0(R1,R5)         GET PTR TO END OF DSN + 1
         SR    R1,R1               CLEAR REG FOR IC
         IC    R1,0(R4)            GET LENGTH OF QUALIFIER
         LR    R0,R1                SAVE QUAL LENGTH
         L     R4,0(R4)            GET ADDR OF QUALIFIER
         SR    R3,R1               GET PTR TO DSN - QUALIFIER
         BCTR  R1,0                DECREMENT FOR EX
         MVC   0(0,R3),BLANK8  GETS RID OF QUALIFIER
         EX    R1,*-6    BLANK OUT QUALIFIER
         CH    R0,DSNLEN           IS THE DSN ONLY THE QUALIFIER ?
         BL    RMVOK          OF COURSE NOT
         DC    X'00'
RMVOK    DS    0H
         BCTR  R3,0                BACK UP ONE MORE
         MVI   0(R3),C' '     BLANK OUT THE '.'
         SR    R5,R0          DSNLEN=DSNLEN-QUALEN
         BCTR  R5,0           SUBTRACT 1 FOR '.'
         STH   R5,DSNLEN
         LM    R0,R10,SAVE2   RESTORE REGS
         BR    LINK           RETURN TO CALLER
OPTDONE  DS    0H
         DROP  R2
         EJECT
*
*        PLACE TO COME ON END OF COMMAND
*
DONE     DS    0H
*
*        PROMPT USER FOR MISSING OPTION OR ELSE
*        TAKE SPECIFIED DEFAULTS
*
         USING OPTIONS,R6
         L     R6,CDLOPT           RESTORE OPTION POINTER
         MVI   PASS,2              INDICATE SECOND PASS OVER OPTIONS
         MVC   MEMNAME,BLANK8      CLEAR MEMBER FIELD
         MVC   PASSWD,BLANK8      CLEAR PASSWORD FIELD
         MVC   VOLID,BLANK8      CLEAR VOLSER FIELD
         LA    R5,OFLAGS           GET PTR TO OPTION FLAGS
DOPTCHK  CLI   0(R5),ON            CHECK IF OPTION WAS SPECIFIED
         BE    DBMPOPT             BR IF SO TO GET NEXT
*
         XR    R1,R1               CLEAR REG
         IC    R1,OPTPRMPT         GET LENGTH OF PROMPT FIELD
         LTR   R1,R1               WAS THERE ONE ?
         BZ    CHECKDFL             BR IF NOT
*
*        PROMPT USER FOR MISSING INFORMATION
*
         STC   R1,MSGAREA          SET COUNT IN MESSAGE AREA
         BCTR  R1,0                DECREMENT FOR MVC
         L     R2,OPTPRMPT         GET ADDR OF PROMPT STRING
         EX    R1,PRMPTMVC         MOVE STRING TO MESSAGE AREA
         XR    R1,R1               CLEAR ANOTHER REG
         IC    R1,OPTHELP          IS HELP AVAILABLE ?
         LTR   R1,R1
         BZ    PRMPTUSR             BR IF NOT
         STC   R1,HELP             SET LENGTH OF THE HELP STRING
         L     R2,OPTHELP          GET THE ADDR OF THE HELP STRING
         BCTR  R1,0                MOVE HELP TO
         EX    R1,DHELPMVC          HELP AREA
PRMPTUSR LA    R1,MSGAREA          GET PTR TO PROMPT MSG
         BAL   LINK,GETMSG          AND PROMPT USER FOR MISSING INFO
*
*        INSERT REPLY IN THE COMMAND STRING
*
*  NOTE THAT PROMPTING WILL NOT WORK FOR NON-POSITIONAL OPERANDS YET.
         LH    R1,INMSGLEN         GET LENGTH OF THE REPLY
         LTR   R1,R1               DID WE GET ANY RESPONSE ?
         BZ    DOPTCHK              BR IF NOT - RETRY
         STH   R1,CMDLEN            SET IN COMMAND STRING
         BCTR  R1,0
         EX    R1,CMDMVC           MOVE REPLY TO CMD STRING
         MVI   PASS,1         SCAN RESPONSE IN PASS1 MODE
         B     BUMPOPT             GO CHECK REPLY
         SPACE
CMDMVC   MVC   CMDFLD(0),INMSG     MOVES REPLY TO CMD STRING
         EJECT
*
*        NO PROMPT SO TAKE DEFAULT
*
CHECKDFL DS    0H
         XR    R1,R1               GET THE LENGTH OF
         IC    R1,OPTDFLT           THE DEFAULT STRING
         LTR   R1,R1               WAS THERE ONE ?
         BZ    DBMPOPT              BR IF NOT
         STH   R1,CMDLEN           SET THE LENGTH IN CMD STRING
         BCTR  R1,0
         L     R2,OPTDFLT          GET ADDR OF THE STRING
         EX    R1,DFLMVC           MOVE DEFAULT TO COMMAND STRING
         B     BUMPOPT             GO PROCESS AS IF ENTERED
*
*        BUMP OPTION PTR AND CHECK FOR END
*
DBMPOPT  DS    0H
         TM    OPTFLAGS,LAST       WAS THIS THE LAST OPTION ?
         BO    SPECPROC             BR IF SO - WE'RE DONE HERE
         MVI   0(R5),ON            INDICATE LAST OPTION DONE
         LA    R5,1(R5)            BUMP OPTION FLAG POINTER
         LA    R6,OPTLEN(R6)       BUMP OPTION POINTER
         B     DOPTCHK              AND GO CHECK NEXT OPTION
         DROP  R6
         SPACE
DFLMVC   MVC   CMDFLD(0),0(R2)     MOVES DEFAULT STRING TO COMMAND AREA
DHELPMVC MVC   HELP+1(0),0(R2)     MOVES HELP STRING TO HELP AREA
PRMPTMVC MVC   MSGAREA+1(0),0(R2)  MOVES PROMPT STRINT
         EJECT
*
*        ALLOCATE ANY SPECIAL DATASETS
*
SPECPROC DS    0H
         MVI   FLAGSUMW,0             CLEAR FLAGS
         OI    FLAGS2,SPCLDSN      INDICATE WE'RE DOING SPECIALS
         LA    R7,DAIRPB           GET PTR TO DAIR PARM BLOCK
         USING DAPB08,R7            MAKE IT ADDRESSIBLE
         L     R1,CDLSDL           CHECK FOR LIST OF SPECIAL DDNAMES
         LTR   R1,R1               ARE THERE ANY ?
         BZ    TLIBALOC            BR IF NOT TO TRY TASKLIB ALLOC
*
SPECLOOP L     R5,0(R1)            GET PTR TO FIRST (NEXT) SDL ENTRY
         MVI   FLAGS,0             CLEAR FLAGS
         MVC   DAIRPB(DPBLEN),0(R5)     MOVE IN DAIR PB
         MVC   NEWVOL,DA08SER
         L    R2,DA08BLK BLK FOR NEW WORKDS
         STH   R2,NEWAVLTH
         L    R2,DA08PQTY PQTY FOR NEW WORKDS
         STH   R2,NEWPRIME
         L    R2,DA08SQTY SQTY FOR NEW WORKDS
         STH   R2,NEWSEC
         MVC   DA08SER,BLANK8
         L     R2,DA08PDSN         CHECK FOR DSN
         LTR   R2,R2               IS THERE ONE ?
         BZ    SPECALOC            BR IF NOT
         SR    R4,R4               GET THE LENGTH OF
         IC    R4,DA08PDSN          THE DSNAME
         STH   R4,DSNLEN           SAVE IT
         MVI   DSN,C' '            MOVE BLANKS INTO DSNAME
         MVC   DSN+1(43),DSN
         BCTR  R4,0                DECREMENT R4 FOR MVC
         EX    R4,SPMVC1           MOVE IN DSN
         LA    R2,DSNAME           GET PTR TO DSNAME
         ST    R2,DA08PDSN         SAVE IT IN DAIR PB
         OI    FLAGS,QUOTED        DON'T PREFIX USERID
         CLI   DSN,C'*'            CHECK FOR TERMINAL ALLOC
         BNE   SPECALOC             BR IF NOT TO TERMINAL
         OI    FLAGS,STARRED
*
SPECALOC BAL   LINK,ALLOCATE       ALLOCATE THE DATASET
         CLI   0(R1),X'80'         CHECK FOR END OF SDL
         BE    TLIBALOC             BR IF THIS IS ALL
         LA    R1,4(R1)            BUMP SDL POINTER
         B     SPECLOOP            AND SEE IF THERE'S MORE TO ALLOC
         SPACE
SPMVC1   MVC   DSN(0),0(R2)        EXECUTED MVC TO SET DSN
         DROP  R7
         EJECT
*
*        ALLOCATE A TASKLIB IF NECESSARY
*
TLIBMVC  MVC   DSN(0),0(R1)        EXECUTED MVC
         SPACE
TLIBALOC DS    0H
         CLI   CDLPGM,C' '         IS THERE A PROGRAM TO BE CALLED ?
         BE    ATCHEND               ALL DONE IF NONE
         L     R1,CDLTDSN          GET PTR TO TASKLIB DSNAME,IF ANY
         LTR   R1,R1               DOES IT EXIST ?
         BZ    DOXCTL              BR IF NOT
         LA    R6,DAIRPB           GET PTR TO DAIR PARM BLOCK
         USING DAPB08,R6            MAKE IT ADDRESSIBLE
         MVI   FLAGS,QUOTED        SAY NO UID TO BE PREFIXED
         BAL   LINK,DAIR8STD       GO BUILD NEW DAIR PB
         MVI   DSN,C' '             BLANK OUT DSN FIELD
         MVC   DSN+1(43),DSN
         SR    R2,R2               GET THE LENGTH OF
         IC    R2,CDLTDSN           THE TASKLIB DSNAME
         STH   R2,DSNLEN           SET DSN LENGTH
         BCTR  R2,0                DECREMENT FOR MVC
         EX    R2,TLIBMVC          MOVE IN DSN
         MVC   TASKDCB(LTDCB),TASKDCBL    GET COPY OF DCB IN WKAREA
         LA    R3,TASKDCB          GET PTR TO TASKLIB DCB
         USING IHADCB,R3
         MVI   DA08DSP1,DA08SHR    DISP=SHR
         BAL   LINK,GODAIR         GO ALLOCATE TASKLIB DCB
*
*        ATTEMPT TO OPEN TASKLIB DCB
*
TLIBOPEN DS    0H
         MVC   DCBDDNAM,DA08DDN    GET NEW DDNAME IN DCB
         OPEN  ((R3),INPUT),MF=(E,OPENCLOS)  TRY OPEN
         TM    DCBOFLGS,X'10'      DID IT OPEN ?
         BNO   NOTASK              ERROR IF NOT
         DROP  R6
         DROP  R3
         EJECT
*
*        NOW TRY ATTACH
*
DOATTACH DS    0H
         MVC   ATTACH(LATCH),ATTACHL    GET COPY OF ATTACH LIST
         LA    R1,PARMCNT          GET PARM PTR
         ST    R1,PARMPTR          SAVE IT
         LA    R1,ADLIST           GET ADL PTR
         ST    R1,ALTDPTR          SAVE IT
         OI    ALTDPTR,X'80'       SET VL FLAG
         LA    R1,PARMPTR          GET PTR TO PASS
         LA    R15,ATTACH          GET PTR TO ATTACH LIST
         ATTACH EPLOC=CDLPGM,DCB=TASKDCB,ECB=PGMECB,TASKLIB=TASKDCB,   *
               MF=(E,(1)),SF=(E,(15))
         SPACE
         ST    R1,TCBSAVE          SAVE TCB POINTER
         WAIT  ECB=PGMECB
         SPACE
         DETACH TCBSAVE            DETACH THE REQUESTED PROGRAM
         CLOSE ((R3)),MF=(E,OPENCLOS)
         SPACE
ATCHEND  BAL   LINK,FREEUP         FREE ALL GOTTEN CORE  & SERVICE RTNS
         B     RETURN              AND EXIT
         SPACE 4
ATTACHL  ATTACH EPLOC=DUMMY,SF=L,SHSPV=78
LATCH    EQU   *-ATTACHL
         EJECT
*
*        NO TASKLIB SO JUST ISSUE XCTL
*
DOXCTL   DS    0H
         BAL   LINK,FREEUP         DELETE SERVICE ROUTINES & CORE
         LA    R1,PARMCNT          GET PARM PTR
         ST    R1,PARMPTR
         LA    R1,ADLIST           GET ADL PTR
         ST    R1,ALTDPTR
         OI    ALTDPTR,X'80'
         LA    R1,PARMPTR
         MVC   XCTL(LXCTL),XCTLL   GET XCTL IN WORKAREA
         LA    R15,XCTL            GET PTR TO XCTL LIST
         L     SAVE,SAVEAREA+4
         L     RTRN,12(SAVE)
         XCTL  (2,12),EPLOC=CDLPGM,MF=(E,(1)),SF=(E,(15))
         SPACE 3
XCTLL    XCTL  EPLOC=DUMMY,SF=L
LXCTL    EQU   *-XCTLL
         EJECT
*
*  SETPL - SET UP PARAMETER LISTS FOR DAIR, PUTLINE, AND STACK
*
SETPL    DS    0H
         STM   R1,R10,SPSAVE
*
*        GET SOME USEFUL POINTERS
*
         L     R1,CPPLSAVE         GET PTR TO CPPL
         USING CPPL,R1              MAKE IT ADDRESSIBLE
         LM    R1,R4,CPPL          GET PTR'S TO CBUF,UPT,PSCB, & ECT
         DROP  R1                  SO MUCH FOR CPPL
         LR    R5,R3               SAVE PTR TO PSCB
         LR    R3,R4               REARRANGE ORDER OF ECT
*
*        SET UP DAIR PARAMETER LIST
*
         LA    R6,DAIRPL           GET PTR TO DAIR PL
         USING DAPL,R6              MAKE IT ADDRESSIBLE
         LA    R4,DAIRECB          GET PTR TO DAIR ECB
         STM   R2,R5,DAPL          PUT UPT,ECT,ECB, & PSCB IN DAIR PL
         LA    R1,DAIRPB           GET PTR TO DAIR PARM BLOCK
         ST    R1,DAPLDAPB         STORE IT IN DAIR PARM LIST
         DROP  R6
*
*        SET UP STACK PARAMETER LIST
*
         LA    R4,STACKECB         GET PT  TO STACK ECB
         STM   R2,R4,STACKPL       PUT UPT,ECT,ECB,  IN STACK PL
*
*        SET UP DAIRFAIL PARAMETER LIST
*
         LA    R1,DAIRPL           GET PTR TO DAIR PARM LIST
         LA    R2,DAIRRC            AND DAIR RETURN CODE
         LA    R3,ENTRPUTL          AND MESSAGE WRITER, IF ANY
         LA    R4,=H'1'            CONSTANT 1 REQUIRED
         STM   R1,R4,DAFLPL        SAVE IN DAIRFAIL PL
*
*        SET OPEN/CLOSE LIST
*
         MVI   OPENCLOS,X'80'
*
*        RETURN
*
         LM    R1,R10,SPSAVE
         BR    LINK                AND EXIT
         EJECT
*
*  CLEANCMD - CLEAN UP THE COMMAND, UPPERCASE
*        ON ENTRY -
*              R1 HAS LENGTH OF COMMAND STRING
*              R2 POINTS AT COMMAND STRING
CLEANCMD DS    0H
* DELETED A BIT OF RELATIVELY USELESS CODE HERE  UMW RCT
         STM   R1,R5,CLNSAVE   SAVE SOME REGS
         STH   R1,CMDLEN      COPY LENGTH TO FROM LENGTH
         BCTR  R1,0           DECREMENT FOR MVC
         EX    R1,CLEXMVC     COPY CHARS TO FROM AREA
CLEXMVC  MVC CMDFLD(0),0(R2)  EXECUTED INSTRUCTION
         LM    R1,R5,CLNSAVE   RESTORE CALLER'S REGS
         BR    LINK                RETURN
         EJECT
*
*  EXTRACT - EXTRACT A FIELD FROM THE COMMAND STRING
*        ON ENTRY -
*              CMDFLD CONTAINS THE COMMAND STRING
*              CMDLEN HAS LENGTH OF THE COMMAND STRING
*        ON EXIT -
*              FIELD IN COMMAND STRING REPLACED WITH BLANKS
*              STRLEN HAS LENGTH OF EXTRACTED FIELD - 1
*              STRING HAS THE EXTRACTED STRING
*              OSTRLEN HAS LENGTH OF THE OPTION NAME
*
EXTRACT  DS    0H
BRACOUNT EQU   6
         STM   R1,BRACOUNT,EXSAVE  SAVE SOME REGS
         SR    BRACOUNT,BRACOUNT
         LR    R15,LINK            INIT RETURN CODE TO O.K.
         MVI   EXDEPTH,0           INIT PAREN DEPTH TO ZERO
         LH    R1,CMDLEN           GET LENGTH OF COMMAND
         LA    R2,CMDFLD            AND POINTER TO COMMAND STRING
         XR    R4,R4               CLEAR STRING LENGTH INITIALLY
         STH   R4,OSTRLEN           AND INIT SUBSTR LENGTH
         LA    R3,STRING           AND GET PTR TO 'TO' AREA
*
*        SKIP OVER LEADING BLANKS, COMMAS
*
EXLOOP1  CLI   0(R2),C' '          CHECK FOR BLANK
         BE    EXBUMP1              BR IF FOUND
         CLI   0(R2),C','          CHECK FOR COMMA
         BNE   EXMOVE              BR IF NOT - EXTRACT FIELD
EXBUMP1  LA    R2,1(R2)            BUMP STRING POINTER
         BCT   R1,EXLOOP1          AND SKIP OVER BLANKS
         B     EXBDRTRN            GO RETURN WITH STRING END CC
*
*        MOVE FIELD TO WORKAREA
*UMW     MODIFIED BY R.TILLEY TO SUPPORT SCRIPT VARIABLES OF THE FORM
*        &VARIABLE=STRING      OR      +VARIABLE=STRING
*        SCRIPT STRINGS ARE NOT UPPERCASED OR OTHERWIZE CHANGED.
*        A SCRIPT STRING IS DELIMITED ON THE LEFT BY AN =
*        AND ON THE RIGHT BY A BLANK OR COMMA
*        IF THE = IS FOLLOWED BY ' OR " THEN THE BLANK OR COMMA
*        MUST BE PRECEEDED BY ' OR " RESPECTIVELY
*
EXMOVE   DS    0H
         MVI   EXVAR,X'FF'    ASSUME SCRIPT VARIABLE
         CLI   0(R2),C'&&'     START OF SCRIPT VARIABLE?
         BE    EXLOOP2        YUP
         CLI   0(R2),C'+'     START OF SCRIPT VARIABLE?
         BE    EXLOOP2        YUP
         MVI   EXVAR,X'00'    NOPE SO SET FLAG
EXLOOP2  DS    0H
         CLI   EXVAR,X'00'    ASSUME NOT A VARIABLE
         BE    EXCVTUP        IT WASNT
         CLI   0(R2),C'='          START OF SCRIPT STRING?
         BNE   EXCVTUP        NOPE. SO GET OUT OF HERE
         BAL   R5,EXBUMP3     COPY AND INCREMENT
         MVC   EXQUOTE,0(R2)            ASSUME IT IS ' OR "
         CLI   0(R2),C''''    IS IT '
         BE    EXWASQ         YUP
         CLI   0(R2),C'"'     IS IT "
         BE    EXWASQ         YUP
         MVI   EXQUOTE,C' '   USE BLANK AS DELIMITER
EXWASQ   DS    0H             THE = WAS FOLLOWED BY A QUOTE
         MVI   EXLASTCH,C' '  PROBABLY A LIE (TO AVOID PREMATURE END
         B     EXNOLAST       AVOID EXOBBERING OUR PHONY LASTCHAR
EXNOUP   DS    0H             LOOP HERE FOR CHARS NOT TO BE UPPERCASED
         MVC   EXLASTCH,0(R2) SAVE CURRENT CHAR
EXNOLAST BAL   R5,EXBUMP3     COPY AND INCREMENT
         CLI   0(R2),C','     IS IT A POTENTIAL DELIMITER
         BE    EXISDLM        YUP
         CLI   0(R2),C' '     IS IT A POTENTIAL DELIMITER
         BNE   EXNOUP         NOPE SO COPY AND INCREMENT
EXISDLM  DS    0H             WE MAY BE AT THE END OF SCRIPT STRING.
         CLI   EXQUOTE,C' '   IS BLANK THE STRING DELIMITER
         BE    EXCVTUP         YUP SO END OF SCRIPT STRING
         CLC   EXQUOTE,EXLASTCH         WAS LAST CHAR A QUOTE
         BE    EXCVTUP         YUP SO END OF SCRIPT STRING
         B     EXNOUP         FALSE ALARM. STRING CONTINUES
EXCVTUP  DS    0H
         OI    0(R2),C' '     UPPER CASE IT
         CLI   0(R2),C' '          CHECK FOR BLANK
         BE    MAYBDONE               DONE IF FOUND
         CLI   0(R2),C','          OR ELSE A COMMA WILL
         BE    MAYBDONE               TERMINATE US
NOTDONE  DS    0H
         CLI   0(R2),C')'
         BNE   NOTRIGHT
         BCTR  BRACOUNT,0
NOTRIGHT DS    0H
         CLI   0(R2),C'('          CHECK FOR START OF SUBFIELD
         BNE   EXBUMP2              BR IF NOT
         LA    BRACOUNT,1(BRACOUNT)
         CLI   EXDEPTH,0           IS THIS THE FIRST LP ?
         BNE   EXBUMP2              BR IF NOT
         MVI   EXDEPTH,1           INDICATE WE'VE BEEN HERE
         STH   R4,OSTRLEN          SAVE LENGTH OF OPTION NAME
EXBUMP2  DS    0H
         LA    R5,EXLOOP2      RETURN TO HERE
EXBUMP3  DS    0H
         MVC   0(1,R3),0(R2)       MOVE A CHARACTER TO OUR STRING
         MVI   0(R2),C' '           AND BLANK IT OUT IN THE CMD
         LA    R3,1(R3)            BUMP 'TO' POINTER
         LA    R2,1(R2)             AND 'FROM' POINTER
         AH    R4,=H'1'            UP OUR COUNTER
         BCTR  R1,R5                AND GO CHECK NEXT
         EJECT
*
*        FINISH UP
*
EXDONE   BCTR  R4,0                DECREMENT STRING LENGTH
         STH   R4,STRLEN            SAVE IT
         B     EXRTRN                AND RETURN
EXBDRTRN SR    R15,R15             SET REG FOR EMPTY RETURN CODE
*
EXRTRN   LM    R1,BRACOUNT,EXSAVE  RESTORE REGS
         LTR   R15,R15              AND SET RETURN COND CODE
         BR    LINK                   AND RETURN
*
MAYBDONE DS    0H
         LTR   BRACOUNT,BRACOUNT
         BNH   EXDONE
         CLI   OSTRLEN+1,X'00'
         BNE   NOTDONE
         CLI   STRING+L'STRING-1,X'FF'
         BE    NOTDONE
         MVC   STRING(L'STRING-1),STRING+1
         MVI   STRING+L'STRING-1,X'FF'
         BCTR  R3,0
         BCTR  R4,0
         BCTR  R4,0
         B     NOTDONE
         EJECT
*
*  CNCTST   ADD A CONCATENATION STRING TO DSNAME FIELD
*      ON ENTRY -  R1 CONTAINS LENGTH OF DSNAME FIELD
*                  R3 -> DSNAME FIELD
*      ON EXIT  -  DSNAME FIELD AND R1 HAVE BEEN ALTERED TO INCLUDE
*                  CONCAT STRING
*
*
CNCTST   DS    0H
         USING OPTIONS,R2
         STM   R2,R6,SDSAVE+8
         LA    R5,0(R1,R3)        PTR TO END OF DSNAME
         MVI   0(R5),C' '         SPACER BLANK
         CLI   SW,ONP                  DSNAME SUPPLIED?
         BE    CNCTDSN                 GO AHEAD
         MVI   SW,ONP                  DSNAME IS SUPPLIED NOW!
         LR    R5,R3                   POINT AT BEGINNING OF STRING
         BCTR  R5,0                    REMOVE THE BLANK
         SLR   R1,R1                   DSNAME LENGTH WAS ZERO
         BCTR  R1,0                    ALSO DECREMENT LENGTH
CNCTDSN  DS    0H
         SR    R4,R4              PREPARE FOR INSERT CHAR
         IC    R4,OPTCNCAT
         L     R6,OPTCNCAT
         BCTR  R4,0
         EX    R4,CNCTMOVE
         LA    R1,2(R1,R4)
         LM    R2,R6,SDSAVE+8
         BR    LINK
         DROP  R2
*
CNCTMOVE MVC   1(*-*,R5),0(R6)
         EJECT
*
*  SCANLIST - CHECK A FIELD TO SEE IF IT IS A LIST
*      ON ENTRY -
*         R3 -> START OF STRING
*         R1 HAS LENGTH OF STRING
*      ON EXIT -
*         LISTSW CONTAINS ONE OF:
*             C'0' THE STRING WAS NOT A LIST
*             C'1' - THE STRING CONTAINED MORE THAN 1 FIELD
*         DDLIST CONTAINS ONE 8 BYTE ENTRY FOR EACH SUBFIELD
*            THE FIRST WORD -> THE SUBFIELD
*            THE SECOND WORD CONTAINS THE LENGTH OF THE SUBFIELD
*         LASTDD IS A FULLWORD -> DDLIST ENTRY FOR LAST SUBFIELD
*
*
SCANLIST DS    0H
LILENGTH EQU   5
DDPTR    EQU   15
         STM   R0,R9,SDSAVE
         LA    DDPTR,DDLIST
         MVI   LISTSW,C'0'
         SR    LILENGTH,LILENGTH
LILOOP2  DS    0H
         ST    R3,0(DDPTR)
LILOOP   DS    0H
         CLI   0(R3),C' '
         BE    LIOUT
         CLI   0(R3),C','
         BE    LIOUT
         LA    R3,1(R3)
         LA    LILENGTH,1(LILENGTH)
         BCT   R1,LILOOP
         ST    LILENGTH,4(DDPTR)
         SR    LILENGTH,LILENGTH
         B     LIEND
LIOUT    DS    0H
         ST    LILENGTH,4(DDPTR)
         SR    LILENGTH,LILENGTH
LILOOP3  DS    0H
         CLI   0(R3),C' '
         BE    LICONT
         CLI   0(R3),C','
         BNE   LIOUT1
LICONT   DS    0H
         LA    R3,1(R3)
         BCT   R1,LILOOP3
         B     LIEND
LIOUT1   DS    0H
         MVI   LISTSW,C'1'
         LA    DDPTR,8(DDPTR)
         B     LILOOP2
LIEND    ST    DDPTR,LASTDD
         LM    R0,R9,SDSAVE
         BR    LINK
         EJECT
*
*  CONCAT - CONCATENATES DDNAMES IN DDLIST
*    ON ENTRY - DDNAMES TO BE CONCATENATED ARE IN DDLIST
*               LASTDD -> LAST DDNAME IN LIST
*    ON EXIT - DDNAMES ARE CONCATENATED UNDER FIRST DDNAME IN LIST
*
*
CONCAT   DS    0H
         STM   R0,R9,SDSAVE
         L     R2,LASTDD
         LA    R2,8(R2)
         LA    R3,DDLIST
         SR    R2,R3
         TPUT  CATMSG,L'CATMSG
         TPUT  (R3),(R2)
         MVC   CONCATPL,DAIRPL
         LA    R4,CONCATPB
         ST    R4,CONCATPL+16
         LA    R1,CONCATPL
         MVI   CONCATPB+1,X'0C'
         SRL   R2,3               CALC # OF DDNAMES IN LIST
         STH   R2,CONCATPB+8
         L     R15,ENTRDAIR
         BALR  14,R15
         LTR   R15,R15
         BZ    CATOK
         DC    X'00'
CATOK    DS    0H
         LM    R0,R9,SDSAVE
         BR    LINK
         EJECT
CATMSG   DC    C'DDNAMES TO BE CONCATENATED:'
         EJECT
*
*  SETDSN - SET UP A DSNAME
*        ON ENTRY -
*              R3 -> START OF STRING
*              R1 HAS LENGTH OF THE STRING
*              R4 -> QUALIFIER
*        ON EXIT -
*              DSN HAS THE PROPER FORMATTED DSNAME
*              MEMNAME HAS THE MEMBER NAME IF ANY
*              DSNLEN HAS THE LENGTH OF THE DSNAME
*              FLAGS INDICATE WHETHER DSNAME IS '*', IN QUOTES,
*                OR INCLUDES A MEMBER NAME
*
SETDSN   DS    0H
         STM   R0,R9,SDSAVE        SAVE SOME REGS
         NI    FLAGS,255-STARRED-QUOTED-MEMBERED   INIT FLAGS
         MVI   DSN,C' '            BLANK OUT DSNAME AREA
         MVC   DSN+1(43),DSN
         MVC   MEMNAME,BLANK8      BLANK OUT MEMBER NAME AREA TOO
         MVC   PASSWD,BLANK8      BLANK OUT PASSWORD AREA TOO
         MVC   VOLID,BLANK8      BLANK OUT VOLSER AREA TOO
         SR    R0,R0               SET DSNAME LENGTH TO
         STH   R0,DSNLEN            ZERO INITIALLY
*UMW RCT LR    R6,R1               SAVE DSN LENGTH
*
*        CHECK FOR TERMINAL DATASET
*
         CLI   0(R3),C'*'          ALLOC TO TERMINAL ?
         BNE   SDCHKMAN           BR IF NOT
         CH    R1,=H'1'            CHECK LENGTH
         BNE   SDGETDSN             ERROR IF NOT ONE FOR '*'
         OI    FLAGS,STARRED       INDICATE TERMINAL
         B     SDRTN               AND RETURN
*
*        CHECK FOR MANTES TYPE DSNAME
*
SDCHKMAN DS    0H
         CLI   0(R3),C'.'     STARTS WITH PERIOD?
         BNE   SDCHKQ         NOPE
         OI    FLAGS,QUOTED   PREVENT PREFIX OF USERID
         OI    FLAGSUMW,LDOTTED PREVENT MISSING TRAILING ' MESSAGE
         LA    R3,1(R3)       BUMP POINTER PAST THE DOT
         BCTR  R1,0           DECREMENT LENGTH
         B     SDGETDSN       GO EXTRACT DSNAME
*
*        CHECK FOR DSNAME IN QUOTES
*
SDCHKQ   CLI   0(R3),C''''         IS DSN QUOTED ?
         BNE   SDCHKMEM            BR IF NOT
         OI    FLAGS,QUOTED        INDICATE QUOTED DSN
         LA    R3,1(R3)            BUMP PTR TO FIRST LETTER
         BCTR  R1,0           DECREMENT LENGTH
         B     SDGETDSN             AND GO EXTRACT DSNAME
*
*        CHECK FOR MEMBER NAME
*
SDCHKMEM CLI   0(R3),C'('          CHECK FOR MEMBER NAME ONLY
         BNE   SDGETDSN             BR IF DSN EXISTS
         OI    FLAGS,MEMBERED      INDICATE MEMBER EXISTS
         LA    R5,1(R3)            SET PTR TO MEMBER NAME
         ST    R5,MEMPTR
         B     SDGETMEM            GO EXTRACT MEMBER
         EJECT
*
*        EXTRACT DSNAME
*
SDGETDSN DS    0H
         LR    R2,R3               GET WORK PTR TO DSN
         XR    R6,R6               CLEAR REG FOR DSN LENGTH
SDDLOOP  CLI   0(R2),C'('          CHECK FOR MEMBER INDICATOR
         BE    SDGOTMEM             BR IF FOUND
         CLI   0(R2),C''''         CHECK FOR TRAILING QUOTE
         BE    SDGOTQOT             BR IF FOUND
         CLI   0(R2),C' '          CHECK FOR FIELD SEPARATOR
         BE    SDGOTBL              BR IF FOUND
*         CLI   0(R2),C')'          CHECK FOR END OF LIST
*         BE    SDGOTBL              BR IF FOUND
         CLI   0(R2),C','           OR OTHER FIELD SEPARATOR
         BE    SDGOTBL               BR IF FOUND
         CLI   0(R2),C'/'     CHECK FOR START OF PASSWORD
         BE    SDGOTPW        YUP. END OF DSN FOR SURE
         CLI   0(R2),C':'     CHECK FOR START OF VOLSER
         BE    SDGOTVL        YUP. END OF DSN FOR SURE
         LA    R2,1(R2)            BUMP DSN POINTER
         AH    R6,=H'1'             AND DSN LENGTH
         BCT   R1,SDDLOOP          LOOP THROUGH DSN
         B     SDGOTBL              BR IF END OF FIELD
*
*        PROCESS END OF DSNAME INDICATOR
*
SDGOTMEM LA    R5,1(R2)            SET MEMBER POINTER
         ST    R5,MEMPTR
         OI    FLAGS,MEMBERED       SAY ONE EXISTS
         B     SDCHKDOT              AND GO EXTRACT DSNAME
*
SDGOTQOT DS    0H             FOUND TRAILING QUOTE
         TM    FLAGS,QUOTED        CHECK FOR MISSING LEADING QUOTE
         BO    SDCHKP              BR IF IT WAS THERE
         LA    R1,MSG4              ELSE GIVE USER ERROR MESSAGE
         BAL   LINK,SENDMSG
         OI    FLAGS,QUOTED          AND CONTINUE AS IF IT WERE
SDCHKP   DS    0H             CHECK FOR PASSWORD
         LA    R2,1(R2)       -> CHAR FOLLOWING QUOTE
         CLI   0(R2),C'/'     HAVE WE A SLASH?
         BE    SDGOTPW       YUP
         CLI   0(R2),C':'     HAVE WE A COLON?
         BNE   SDDSNMV        NOPE SO MOVE THE DSN
*
SDGOTVL  DS    0H             HAVE : WHICH SHOULD BEGIN A VOLSER
         LA    R5,1(R2)       SAVE POINTER TO START OF VOLSER PROPER
         ST    R5,VOLPTR
         OI    FLAGSUMW,VOLLED     REMEMBER FOR LATER
         B     SDGOTBL        GO MOVE DSNAME
*
SDGOTPW  DS    0H             HAVE / WHICH SHOULD BEGIN A PASSWORD
         LA    R5,1(R2)       SAVE POINTER TO START OF PASSWORD PROPER
         ST    R5,PASPTR
         OI    FLAGSUMW,PSWDDED    REMEMBER FOR LATER
SDGOTBL  DS    0H
*
*        MOVE IN THE DSNAME
*
SDDSNMV  DS 0H ALSO CHECK FOR TRAILING DOT  UMW RCT
         LTR   R6,R6               WAS THERE A DSN ?
         BZ    SDNODSN              BR IF NOT
         BCTR  R2,0  DECREMEMT TO BEFORE BLANK COMMA / OR :
         TM    FLAGS,QUOTED        CHECK FOR LEADING QUOTE
         BNO   SDCHKDOT              BR IF NONE - O.K.
         TM    FLAGSUMW,LDOTTED CHECK FOR LEADING DOT
         BO    SDCHKDOT        YUP SO NO MESSAGE
         CLI   0(R2),C''''    IS THERE A TRAILING QUOTE?
         BE    SDWASQOT       YUP SO NO MESSAGE
         LA    R1,MSG5               ELSE GIVE ERROR MESSAGE
         BAL   LINK,SENDMSG            AND ASSUME THE TRAILING QUOTE
         B     SDCHKDOT       SHOULDNT BE ONE BUT NO ONE ELSE CHECKS
SDWASQOT BCTR  R2,0           DECREMENT TO BEFORE TRAILING QUOTE
SDCHKDOT CLI   0(R2),C'.'     TRAILING DOT?
         BNE   SDNODOT         NOPE
         OI    FLAGSUMW,TDOTTED          REMEMBER IT
         BCT   R6,SDNODOT   REDUCE LENGTH TO GET RID OF DOT
         B     SDNODSN        LENGTH OF DSN IS ZERO
SDNODOT   DS    0H
         STH   R6,DSNLEN      SET DSN LENGTH
         BCTR  R6,0           DECREMENT FOR MOVE
         MVC   DSN(0),0(R3)        MOVES IN DSNAME
         EX    R6,*-6
         EJECT
*
         SPACE
*
SDGETMEM DS    0H
         TM    FLAGS,MEMBERED      WAS THERE ONE ?
         BNO   SDGETPAS             BR IF NOT
         L     R2,MEMPTR      -> BEGINNING OF MEMNAME CHARACTERS
         MVC   MEMNAME(8),0(R2)    MOVE IN POTENTIAL MEMBER NAME
         XR    R6,R6               SET INITIAL LENGTH
SDMLOOP  CLI   0(R2),C')'          CHECK FOR END INDICATOR
         BE    SDGOTRP              BR IF FOUND
         CLI   0(R2),C' '          CHECK FOR BAD END INDICATOR
         BE    SDRPASUM             BR IF FOUND
         CLI   0(R2),C','            BLANK OR COMMA
         BE    SDRPASUM              BR IF FOUND
         CLI   0(R2),C'/'            SLASH
         BE    SDSLASH              BR IF FOUND
         CLI   0(R2),C':'            COLON
         BE    SDCOLON              BR IF FOUND
         CLI   0(R2),C''''         CHECK FOR OTHER BAD END INDICATOR
         BE    SDQUOTE             BR IF FOUND
         CLI   0(R2),C'A'          CHECK FOR VALID CHAR
         BNL   SDMBUMP              BR IF ALPHANUMERIC
         CLI   0(R2),C'$'
         BE    SDMBUMP              O.K. IF $, #, @ ALSO
         CLI   0(R2),C'#'
         BE    SDMBUMP
         CLI   0(R2),C'@'
         BNE   BADMEM              ERROR IF NONE OF THE ABOVE
SDMBUMP  AH    R6,=H'1'            BUMP MEMBER LENGTH
         LA    R2,1(R2)             AND MEMBER POINTER
         B     SDMLOOP               AND LOOP THROUGH MEMBER NAME
*
*        EXTRACT MEMBER NAME
*
SDGOTRP  DS    0H             HAVE A CLOSE PARENTHESIS
         OI    FLAGSUMW,WASRP INDICATE RP WAS FOUND
         LA    R2,1(R2)       -> CHAR FOLLOWING RP
         CLI   0(R2),C''''    FRICKING QUOTE?
         BE    SDQUOTE        YUP
         TM    FLAGSUMW,LDOTTED    LEADING DOT?
         BO    SDCHKNXT       YUP SO NO MESSAGE
         TM    FLAGS,QUOTED   SHOULD THERE BE A TRAILING QUOTE?
         BNO   SDCHKNXT       NOPE SO NO MESSAGE
         LA    R1,MSG5               ELSE GIVE ERROR MESSAGE
         BAL   LINK,SENDMSG            AND ASSUME THE TRAILING QUOTE
         B     SDCHKNXT
SDQUOTE  LA    R2,1(R2)       -> CHAR FOLLOWING QUOTE
         TM    FLAGS,QUOTED   WAS THERE A LEADING QUOTE OR DOT?
         BO    SDCHKNXT       YUP SO NO MESSAGE
         LA    R1,MSG4              ELSE GIVE USER ERROR MESSAGE
         BAL   LINK,SENDMSG
         OI    FLAGS,QUOTED          AND CONTINUE AS IF IT WERE
SDCHKNXT DS    0H             CHECK FOR PSWD OR VOLUME
         CLI   0(R2),C'/'     HAVE WE A PASSWORD?
         BE    SDSLASH      YUP
         CLI   0(R2),C':'     HAVE WE A COLON?
         BNE   SDMEMMV        NOPE SO MOVE THE MEM
SDCOLON  DS    0H             MEMBER ENDS WITH START OF VOLSER
         LA    R5,1(R2)       SAVE POINTER TO START OF VOLSER PROPER
         ST    R5,VOLPTR
         OI    FLAGSUMW,VOLLED    REMEMBER FOR LATER
         B     SDRPASUM       GO EXTRACT MEMBER NAME
SDSLASH  DS    0H             MEMBER ENDS WITH START OF PASSWORD
         LA    R5,1(R2)       SAVE POINTER TO START OF PASSWORD PROPER
         ST    R5,PASPTR
         OI    FLAGSUMW,PSWDDED    REMEMBER FOR LATER
*
SDMEMMV  DS    0H
         TM    FLAGSUMW,WASRP WAS THERE A CLOSING PARENTHESIS?
         BO    SDWASRP        YUP SO NO MESSAGE
SDRPASUM DS    0H
         LA    R1,MSG7             TELL USER RIGHT PARENTHESIS
         BAL   LINK,SENDMSG         IS ASSUMED
SDWASRP  DS    0H             RP WAS NOT OMITTED
         CH    R6,=H'8'            CHECK FOR VALID LENGTH
         BH    BADMEM               BR IF TOO BIG
         LTR   R6,R6
         BNP   BADMEM               OR IF TOO SMALL
         MVC   MEMNAME,BLANK8      CLEAR FIELD
         BCTR  R6,0                DECREMENT FOR MVC
         L     R5,MEMPTR      -> START OF MEMBER STRING
         MVC   MEMNAME(0),0(R5)    MOVES IN MEMBER NAME
         EX    R6,*-6              MOVE IN THE NAME
         CLI   MEMNAME,C'0'        FIRST CHAR OF MEMBER CANNOT
         BL    SDGETPAS             BE NUMERIC, BR IF O.K.
         EJECT
*
*        INVALID MEMBER NAME
*
BADMEM   MVC   MSGAREA(LMSG20),MSG20    GET ERROR TEXT
         MVC   MSGAREA+LMSG20-8(8),MEMNAME      INSERT MEMBER NAME
         LA    R1,MSGAREA          NOW TELL USER OF
         BAL   LINK,MSNGR           THE PROBLEM
*
*        EXTRACT PASSWORD
*
SDGETPAS DS    0H
         TM    FLAGSUMW,PSWDDED      WAS THERE ONE ?
         BNO   DONEPASS             BR IF NOT
         L     R2,PASPTR      ->START OF PASSWORD STRING
         MVC   PASSWD(8),0(R2)   MOVE IN POTENTIAL PASSWORD
         XR    R6,R6               SET INITIAL LENGTH
SDPLOOP  CLI   0(R2),C' '          CHECK FOR END INDICATOR
         BE    SDGOTPAS             BR IF FOUND
         CLI   0(R2),C','            BLANK OR COMMA
         BE    SDGOTPAS              BR IF FOUND
         CLI   0(R2),C')'     END OF DSN LIST
         BE    SDGOTPAS              BR IF FOUND
         CLI   0(R2),C':'     START OF VOLSER
         BE    SDGOTCOL              BR IF FOUND
         AH    R6,=H'1'            BUMP PASSWORD LENGTH
         LA    R2,1(R2)             AND PASSWORD POINTER
         B     SDPLOOP               AND LOOP THROUGH PASSWORD
SDGOTCOL DS    0H             HAVE A COLON
         LA    R5,1(R2)       SAVE PTR TO START OF VOLSER
         ST    R5,VOLPTR
SDGOTPAS DS    0H
         CH    R6,=H'8'            CHECK FOR VALID LENGTH
         BH    BADPASS               BR IF TOO BIG
         LTR   R6,R6
         BNP   BADPASS               OR IF TOO SMALL
         MVC   PASSWD,BLANK8      CLEAR FIELD
         BCTR  R6,0                DECREMENT FOR MVC
         L     R5,PASPTR      -> START OF PASSWORD STRING
         MVC   PASSWD(0),0(R5)    MOVES IN PSWD
         EX    R6,*-6              MOVE IN THE PSWD
         B     DONEPASS            DONE PASSWORD
         EJECT
*
*        INVALID PASSWORD
*
BADPASS  MVC   MSGAREA(LMSG32),MSG32    GET ERROR TEXT
         MVC   MSGAREA+LMSG32-8(8),PASSWD    INSERT PASSWORD
         LA    R1,MSGAREA          NOW TELL USER OF
         BAL   LINK,MSNGR           THE PROBLEM
DONEPASS DS    0H             FINISHED WITH PASSWORD
*
*        EXTRACT VOLSER
*
SDGETVOL DS    0H
         TM    FLAGSUMW,VOLLED      WAS THERE ONE ?
         BNO   SDCHKQAL             BR IF NOT
         L     R2,VOLPTR      ->START OF VOLSER STRING
         MVC   VOLID(6),0(R2)   MOVE IN POTENTIAL VOLSER
         XR    R6,R6               SET INITIAL LENGTH
SDVLOOP  CLI   0(R2),C' '          CHECK FOR END INDICATOR
         BE    SDGOTVOL             BR IF FOUND
         CLI   0(R2),C','            BLANK OR COMMA
         BE    SDGOTVOL              BR IF FOUND
         CLI   0(R2),C')'     END OF DSN LIST
         BE    SDGOTVOL              BR IF FOUND
         CLI   0(R2),C'A'          CHECK FOR VALID CHAR
         BNL   SDVBUMP              BR IF ALPHANUMERIC
         CLI   0(R2),C'$'
         BE    SDVBUMP              O.K. IF $, #, @ ALSO
         CLI   0(R2),C'#'
         BE    SDVBUMP
         CLI   0(R2),C'-'
         BE    SDVBUMP
         CLI   0(R2),C'@'
         BNE   BADVOL              ERROR IF NONE OF THE ABOVE
SDVBUMP  AH    R6,=H'1'            BUMP VOLSER LENGTH
         LA    R2,1(R2)             AND VOLSER POINTER
         B     SDVLOOP               AND LOOP THROUGH VOLSER
SDGOTVOL DS    0H
         CH    R6,=H'6'               CHECK FOR VALID LENGTH
         BH    BADVOL               BR IF TOO BIG
         LTR   R6,R6
         BNP   BADVOL               OR IF TOO SMALL
         MVC   VOLID,BLANK8      CLEAR FIELD
         BCTR  R6,0                DECREMENT FOR MVC
         L     R5,VOLPTR      -> START OF VOLSER STRING
         MVC   VOLID(0),0(R5)    MOVES IN VOLSER
         EX    R6,*-6              MOVE IN THE VOLSER
         B     SDCHKQAL            DONE VOLSER
         EJECT
*
*        INVALID VOLSER
*
BADVOL  MVC   MSGAREA(LMSG34),MSG34    GET ERROR TEXT
         MVC   MSGAREA+LMSG34-8(6),VOLID    INSERT VOLSER
         LA    R1,MSGAREA          NOW TELL USER OF
         BAL   LINK,MSNGR           THE PROBLEM
*
*        CHECK FOR QUALIFIER ALREADY ATTACHED
*
SDCHKQAL DS    0H
         TM    FLAGS,QUOTED        WAS DSN IN QUOTES ?
         BO    SDRTN                DONE IF SO
         TM    FLAGSUMW,TDOTTED          TRAILING PERIOD?
         BO    SDRTN          DONE IF SO
         LA    R1,DSN              GET PTR TO DSN
         LH    R2,DSNLEN            AND DSNAME LENGTH
         LTR   R2,R2               WAS A DSN ENTERED ?
         BZ    SDNODSN              BR IF NONE
         LA    R3,0(R1,R2)         GET PTR TO END OF DSN + 1
         SR    R1,R1               CLEAR REG FOR IC
         IC    R1,0(R4)            GET LENGTH OF QUALIFIER
         LR    R0,R1                SAVE QUAL LENGTH
         L     R4,0(R4)            GET ADDR OF QUALIFIER
         SR    R3,R1               GET PTR TO DSN - QUALIFIER
         BCTR  R1,0                DECREMENT FOR CLC
         EX    R1,SDQALCLC         IS QUALIFIER ALREADY THERE ?
         BNE   SDAPPQAL             BR IF NOT - APPEND QUAL
         CH    R0,DSNLEN           IS THE DSN ONLY THE QUALIFIER ?
         BE    SDRTN                DONE IF SO
         BCTR  R3,0                BACK UP ONE MORE
         CLI   0(R3),C'.'          MAKE SURE IT'S REAL ('.QUAL')
         BE    SDRTN                BR IF IT IS
*
*        APPEND THE QUALIFIER TO THE DSNAME
*
SDAPPQAL AR    R3,R1               RESTORE DSN END POINTER
         OI    FLAGSUMW,XTRAQUAL   INDICATE QUALIFIER ADDED
         AH    R3,=H'1'             ONE MORE
         MVI   0(R3),C'.'          MOVE IN A SEPARATOR CHAR
         EX    R1,SDQALMVC         APPEND QUALIFIER TO DSN
         AR    R2,R1               GET NEW DSN LENGTH
         AH    R2,=H'2'
         STH   R2,DSNLEN            AND SAVE IT
         B     SDRTN               RETURN
         EJECT
*
*        NO DSNAME - QUALIFIER BECOMES DSNAME
*
SDNODSN  DS    0H
         SR    R1,R1               CLEAR REG FOR IC
         IC    R1,0(R4)            GET LENGTH OF QUALIFIER
         L     R4,0(R4)            GET ADDR OF QUALIFIER
         STH   R1,DSNLEN           SET DSNAME LENGTH
         BCTR  R1,0                DECREMENT FOR MVC
         EX    R1,SDQLMVC          SET QUAL AS DSNAME
*
*        RETURN
*
SDRTN    DS    0H
         LM    R0,R9,SDSAVE
         BR    LINK                RETURN
         SPACE 2
SDQALCLC CLC   0(0,R3),0(R4)       CHECKS FOR QUALIFIER
SDQALMVC MVC   1(0,R3),0(R4)       APPENDS QUALIFIER TO DSNAME
SDQLMVC  MVC   DSN(0),0(R4)        MOVES IN QUALIFIER AS THE DSNAME
         EJECT
*
*  SETBASIC - SET UP A BASIC DSNAME TO BE USED FOR CREATING NEW NAMES
*        ON ENTRY -
*              R2 POINTS AT THE OPTION FIELD
*              DSN CONTAINS THE DSNAME TO USE AS THE BASIC NAME
*              DSNLEN HAS THE DSNAME LENGTH
*              MEMNAME HAS THE MEMBER NAME, IF ANY
*              FLAGS CONTAINS DSNAME INFORMATION
*        ON EXIT -
*              BASICDSN CONTAINS THE NAME TO BE USED AS A BASIC NAME
*              BASICLEN HAS THE LENGTH OF THE BASIC DSNAME
*              BASICMEM HAS THE MEMBER NAME, IF ANY
*
SETBASIC DS    0H
         STM   R1,R5,SBSAVE        SAVE SOME REGS
         MVC   BASICMEM,BLANK8     SET DEFAULT MEMBER
         TM    FLAGS,STARRED       WAS DSNAME '*' ?
         BO    SBRTRN               NO HOPE IF SO - RETURN
*         LH    R1,DSNLEN           GET LENGTH OF THE DSNAME
*         STH   R1,BASICLEN         SAVE IT JUST IN CASE
*         BCTR  R1,0                NOW MOVE THE DSNAME TO OUR AREA
*         EX    R1,BASICMVC
         TM    FLAGS,QUOTED        WAS NAME IN QUOTES ?
         BO    SBRTRN         PHOOEY ON THAT
         TM    FLAGSUMW,TDOTTED          TRAILING DOT?
         BO    SBRTRN         PHOOEY ON THAT TOO
         MVC   BASICMEM,MEMNAME    SAVE BASIC MEMBER NAME, IF ANY
*
*        CHECK FOR AND DELETE QUALIFIER
*
         USING OPTIONS,R2
         SR    R3,R3               GET THE LENGTH OF
         IC    R3,OPTQUAL           THE QUALIFIER
         L     R5,OPTQUAL           ALSO ITS ADDRESS
         LH    R1,DSNLEN           RESTORE DSN LENGTH
         LA    R4,DSN(R1)          POINT AT END OF DSN
         SR    R4,R3                BACK UP TO POSSIBLE QUAL POS
         BCTR  R3,0                NOW COMPARE QUALIFIER TO ITS
         EX    R3,BASICCLC          POSSIBLE POSITION IN THE DSN
         BNE   SBRTRN              PHOOEY ON THAT
         LA    R3,1(R3)            RESTORE QUALIFIER SIZE
         CH    R3,DSNLEN           IS DSN = QUALIFIER
         BNE   SBCHKQAL             BR IF NOT
         SR    R1,R1               ELSE, QUALIFIERS WILL BE
         STH   R1,BASICLEN          USED AS THE DSNAME
         B     SBDONE
SBCHKQAL BCTR  R4,0                BACK UP ONE MORE
         CLI   0(R4),C'.'          MUST HAVE '.' TO BE A QUALIFIER
         BNE   SBRTRN              PHOOEY ON THAT
         SR    R1,R3               NEW LENGTH IS OLD LESS LENGTH
         BCTR  R1,0                 OF QUALIFIER AND '.'
         STH   R1,BASICLEN         SET THE LENGTH
         BCTR  R1,0                 DECREMENT FOR EX
         MVC   BASICDSN(0),DSN     MOVES DSN TO BASIC DSN
         EX    R1,*-6
         EJECT
*
*        RETURN
*
SBDONE   OI    FLAGS2,GOTBASIC     INDICATE WE DID GOOD
SBRTRN   LM    R1,R5,SBSAVE        RESTORE REGS
         BR    LINK                 AND RETURN
         DROP  R2
         SPACE
BASICCLC CLC   0(0,R5),0(R4)       COMPARES PART OF DSN WITH QUAL
         EJECT
*
*  CHECKDSN - CHECK FOR VALID DATASET NAME
*        ON ENTRY -
*              DSN CONTAINS THE DATASET NAME TO BE CHECKED
*              DSNLEN HAS THE LENGTH
*        ON EXIT -
*              CC = ZERO IF VALID DSNAME
*              CC = NONZERO IF INVALID
*
CHECKDSN DS    0H
         STM   R1,R3,CDSAVE        SAVE SOME REGS
         XR    R15,R15             CLEAR RETURN CODE REGISTER
         TM    FLAGS,STARRED       CHECK FOR TERMINAL DATASET
         BO    CDRTRN              NO CHECK IF SO
         MVI   FIRSTCH,ON          SAY FIRST CHAR EXPECTED
         LH    R2,DSNLEN           GET DSNAME LENGTH
         LTR   R2,R2               CHECK LENGTH
         BNP   CDSNERR              ERROR IF NOT POSITIVE
         LA    R1,DSN              GET PTR TO DSNAME
         LA    R3,0           COUNTER FOR CHARS IN A QUALIFIER
*
CDLOOP   CLI   FIRSTCH,ON          IS THIS A FIRST CHARACTER ?
         BNE   CDCHKALF             BR IF NOT FIRST
         CLI   0(R1),C'Z'          CHECK FOR NUMERIC
         BH    CDSNERR              ERROR IF NUMERIC FIRST CHAR
CDCHKALF CLI   0(R1),C'A'          CHECK FOR ALPHABETIC CHAR
         BNL   CDBUMP               OK IF ALPHABETIC
         CLI   0(R1),C'$'          CHECK FOR SPECIAL SPECIAL CHAR
         BE    CDBUMP               OK IF $, #, @
         CLI   0(R1),C'#'
         BE    CDBUMP
         CLI   0(R1),C'@'
         BE    CDBUMP
         CLI   0(R1),C'.'          CHECK FOR SEPARATOR CHAR
         BNE   CDSNERR              ERROR IF NONE OF THE ABOVE
         CLI   FIRSTCH,ON          IS THE FIRST CHAR SW ON ?
         BE    CDSNERR              ERROR IF SO, ..
         MVI   FIRSTCH,ON          TURN ON FIRST CHAR SWITCH
         LA    R3,0           RESET QUAL CHAR COUNT
         B     CDBUMP2             GO BUMP PTR
*
CDBUMP   MVI   FIRSTCH,OFF         TURN OFF FIRST CHAR SWITCH
         LA    R3,1(R3)       BUMP QUAL CHAR COUNTER
CDBUMP2  LA    R1,1(R1)            BUMP DSNAME POINTER
         CH    R3,=H'8'       MORE THAN 8 CHARS IN PREV. QUAL?
         BH    CDSNERR        YUP SO NAME IS BAD
         BCT   R2,CDLOOP           LOOP THROUGH DSNAME
         B     CDRTRN              GO DO GOOD DSNAME RETURN
*
CDSNERR  LR    R15,LINK            SET BAD DSNAME RETURN
*
CDRTRN   LM    R1,R2,CDSAVE        RESTORE SOME REGS
         LTR   R15,R15             SET RETURN CODE
         BR    LINK                RETURN
         EJECT
*
*  SCANOPT - SCAN OPTION TABLE FOR A PARTICULAR ENTRY
*        ON ENTRY -
*              STRING CONTAINS THE OPTION FIELD
*              STRLEN HAS THE LENGTH OF THE FIELD - 1
*              OSTRLEN HAS THE LENGTH OF THE OPTION NAME, IF ANY
*        ON EXIT -
*              R1 HAS LENGTH OF THE DSNAME, IF ANY
*              R2 -> OPTION ENTRY
*              R3 -> START OF DSNAME, IF ANY
*              CC = 0 IF OPTION NOT FOUND
*              SW SET TO 'OFF' FOR NO'OPTION'
*                        'ON'  FOR OPTION
*                        'ONP' FOR OPTION(DSNAME)
*
SCANOPT  DS    0H
         STM   R4,R6,SCSAVE        SAVE SOME REGS
         LA    R5,OFLAGS           GET PTR TO OPTION FLAGS
         L     R2,CDLOPT           GET PTR TO OPTION TABLES
         LA    R3,STRING           GET STRING POINTER
         USING OPTIONS,R2           MAKE IT ADDRESSIBLE
         LR    R15,LINK            SET FOR CC TO INDICATE 'FOUND'
         MVI   SW,OFF              TURN SWITCH OFF INITIALLY
*
*
*        INSERT BLANK AND RIGHT PAREN AT END OF PARM
*
         LH    R1,STRLEN
         LA    R1,STRING+1(R1)
         MVC   0(2,R1),=C' )'
*
*
*        SEARCH OPTION TABLES FOR SPECIFIED OPTION
*
SCANLOOP DS    0H
         CLI   0(R5),ON            CHECK FLAG TO SEE IF OP DONE
         BE    SCOPTBMP            BR IF SO TO CHECK NEXT ENTRY
         SR    R1,R1               CLEAR REG FOR IC
         IC    R1,OPTNAME          GET LENGTH OF OPTION - 1
         LTR   R1,R1               WAS THIS A POSITIONAL OPTION ?
         BNZ   SCOPTCHK             BR IF NOT
         MVI   SW,ONP              PRETEN PARENS EXISTED
         MVI   0(R5),ON            INDICATE OPTION DONE
         LH    R1,STRLEN            GET ITS LENGTH
         AH    R1,=H'1'             BUMP FOR TRUE LENGTH
         LA    R3,STRING           POINT TO DSNAME
         B     SCORTN               AND RETURN
SCOPTCHK BCTR  R1,0                DECREMENT FOR CLC
         L     R4,OPTNAME          GET ADDR OF OPTION NAME
         EX    R1,SCCLC1           CHECK FOR MATCH
         BE    SCGOTOPT            BR IF FOUND
         CLC   0(2,R3),NO          CHECK FOR NO'OPTION'
         BNE   SCOPTBMP             BR IF NOT
         EX    R1,SCCLC2           TRY AGAIN
         BNE   SCOPTBMP             BR IF NOT NO'OPTION'
         MVI   0(R5),ON            INDICATE OPTION DONE
         B     SCORTN               AND RETURN
SCOPTBMP TM    OPTFLAGS,LAST       WAS THIS THE LAST OPTION ?
         BO    SCANSHRT             BR IF SO TO TRY SHORT FORM
         LA    R2,OPTLEN(R2)       BUMP OPTION PTR TO NEXT ENTRY
         LA    R5,1(R5)            BUMP FLAG POINTER
         B     SCANLOOP             AND GO CHECK NEXT OPTION
         EJECT
*
*        CHECK FOR SHORT FORM OF OPTION
*
SCANSHRT LH    R1,OSTRLEN          GET LENGTH SPEC'D BY USER
         BCTR  R1,0                 ADJUST FOR CLC
         LTR   R1,R1               CHECK FOR OSTRLEN
         BNM   SCNSHRT1             BR IF O.K.
         LH    R1,STRLEN             ELSE USE STRLEN
SCNSHRT1 L     R2,CDLOPT           POINT AT START OF OPTIONS
         LA    R5,OFLAGS           AND AT START OF OPTION FLAGS
SCNLOOP2 CLI   0(R5),ON            SEE IF OPTION ALREADY DONE
         BE    SCOPBMP2             BR IF SO
         L     R4,OPTNAME          GET ADDR OF OPTION NAME
         EX    R1,SCCLC1           CHECK FOR A MATCH
         BE    SCGOTOPT             BR IF THIS IS IT
         CLC   0(2,R3),NO          CHECK FOR 'NO'OPTION
         BNE   SCOPBMP2              BR IF NOT 'NO'
         EX    R1,SCCLC2           CHECK FOR SHORT FORM OF OPTION
         BNE   SCOPBMP2             BR IF NOT IT
         MVI   0(R5),ON            INDICATE OPTION DONE
         B     SCORTN               AND RETURN
SCOPBMP2 TM    OPTFLAGS,LAST       CHECK FOR END OF TABLE
         BO    SCORTNBD            GO RETURN WITH BAD CC
         LA    R2,OPTLEN(R2)       BUMP OPTION POINTER
         LA    R5,1(R5)             AND FLAG POINTER
         B     SCNLOOP2
*
*        OPTION FOUND - CHECK FOR DSNAME
*
SCGOTOPT DS    0H
         MVI   0(R5),ON            SAY THIS OPTION IS DONE
         MVI   SW,ON               TURN SWITCH ON
         LA    R3,1(R3,R1)         BUMP PTR PAST (PART) OPTION
         CLI   0(R3),C'('          CHECK FOR LEFT PAREN
         BNE   SCORTN               RETURN IF NO DSNAME IN PARENS
         EJECT
*
*        INDICATE A DSNAME FIELD EXISTS
*
         MVI   SW,ONP              SET SW TO INDICATE DSN
         LA    R3,1(R3)            BUMP PTR TO DSNAME
         SR    R1,R1               CLEAR DSN CNT REG
         LR    R4,R3               GET A WORK DSN PTR
SCNLOOP3 CLI   0(R4),C')'          CHECK FOR RIGHT PAREN
         BE    SCGOTRP              BR IF FOUND
         AH    R1,=H'1'            ELSE BUMP COUNT
         LA    R4,1(R4)             AND POINTER
         B     SCNLOOP3            AND LOOP THROUGH DSNAME
SCGOTRP  CLI   1(R4),C')'          CHECK FOR DOUBLE RIGHT PAREN
         BNE   SCORTN               RETURN IF NOT
         AH    R1,=H'1'            ELSE BUMP COUNT AGAIN
         B     SCORTN              AND NOW RETURN
*
*        RESTORE SOME REGISTERS - OTHERS RETURN DATA
*
SCORTNBD SR    R15,R15             SET REG TO INDICATE OPTION NOT FOUND
*
SCORTN   LM    R4,R6,SCSAVE
         LTR   R15,R15             SET CONDITION CODE
         BR    LINK                RETURN
         SPACE
SCCLC1   CLC   0(0,R3),0(R4)       EXECUTED CLC
SCCLC2   CLC   2(0,R3),0(R4)       COMPARE NO'OPTION' WITH OPTNAME
         DROP  R2
         EJECT
*
*  INITDPB - INITIALIZE DAIR PARM BLOCK
*        ON ENTRY -
*              R2 POINTS TO OPTION ENTRY
*              SW INDICATES WHETHER DUMMY DATASET USED
*
INITDPB  DS    0H
         STM   R0,R4,IDPSAVE
         USING OPTIONS,R2
         MVC   NEWSPACE(6),OPTSPACE          SET SPACE FOR NEW
         TM    OPTFLAGS,NOALTDD
         BZ    ALTDD
         OI    FLAGS,NOALTDD
ALTDD    DS    0H
         L     R4,OPTDAPB          GET PTR TO DAIR PARM BLOCK
         DROP  R2
         MVC   DAIRPB(DPBLEN),0(R4)          MOVE IN NEW DAIR PB
         LA    R4,DAIRPB           GET POINTER TO PARM BLOCK
         USING DAPB08,R4
         MVC   NEWVOL,DA08SER
         MVC   DA08SER,VOLID
         LA    R1,DSNAME           GET POINTER TO DSNAME
         ST    R1,DA08PDSN         ENTER IT IN DAIR PB
         CLI   SW,OFF              CHECK FOR NO'OPTION'
         BNE   IDPRTRN              RETURN IF NOT DUMMY DATASET
*
*        SET UP BLOCK FOR A DUMMY DATASET
*
         OI    FLAGS,NULLDS   INDICATE DUMMY DATASET
         OI    DA08CTL,DA08DMMY    DUMMY UP DATASET
         LH    R0,NEWAVLTH         GET SPACE BLOCKSIZE
         ST    R0,DA08BLK          SET IN DAIRPB
         LH    R0,NEWPRIME         GET PRIMARY QUANTITY
         ST    R0,DA08PQTY
         LH    R0,NEWSEC           GET SECONDARY QUANTITY
         ST    R0,DA08SQTY
         OI    FLAGS,QUOTED        SAY QUOTED FOR NO PREFIX
         SR    R0,R0               CLEAR R0
         ST    R0,DA08PDSN         CLEAR DSN AREA OF DAIR PB
         MVI   DA08DSP1,DA08NEW    DISP=NEW
         MVI   DA08DPS2,DA08DEL    STATUS=DELETE
         MVI   DA08DPS3,DA08DELE   COND'L STATUS=DELETE
IDPRTRN  LM    R0,R4,IDPSAVE       RESTORE SOME REGS
         BR    LINK                 AND RETURN
         DROP  R4
         EJECT
*
* ALLOCATE - ALLOCATE A DATASET FOR AN OPTION
*
ALLOCATE DS    0H
         STM   R0,R9,ALSAVE        SAVE SOME REGS
         LA    R4,DAIRPB           RESTORE PTR
         USING DAPB08,R4
         MVC   DA08PSWD,PASSWD        MOVE IN PASSWORD
         MVI   ALFLAGS,0           CLEAR ALLOCATION FLAGS
         TM    FLAGS,PDS               IS THIS A PDS?
         BZ    IDPNOPDS                B IF NOT REQUIRED
         MVC   DA08MNM,MEMNAME         MOVE IN MEMBER NAME
IDPNOPDS DS    0H
         TM    FLAGS,QUOTED        WAS DSN IN QUOTES
         BO    DOALTST             BR IF SO
         OI    DA08CTL,DA08UID     SAY PREFIX DSNAME WITH USER ID
DOALTST  DS    0H
         CLI   LISTSW,C'1'
         BNE   DOSKIP
         LA    DDPTR,DDLIST
         C     DDPTR,DDSAV
         BE    DOSKIP
         MVC   DA08DDN,BLANK8
         BAL   LINK,GODAIR
         B     ALORTRN
DOSKIP   DS    0H
         TM    FLAGS,NOALTDD
         BO    DONOALT
         L     R2,CDLADL           GET PTR TO ALT DDNAME LIST
         LTR   R2,R2               TEST IF ONE EXISTS
         BNZ   DOALTALC            BR IF SO
DONOALT  DS    0H
         BAL   LINK,GODAIR         ALLOCATE THE DATASET
         B     ALORTRN             GO CHECK NEXT OPTION
*
*        ALLOCATE ALTERNATE DDNAME FOR THE OPTION
*
DOALTALC DS    0H
*         OI    FLAGS,NOALTDD         ALLOW ALTERNATE DDNAME
         MVC   TEMP,DA08DDN        SAVE DDNAME
         MVC   DA08DDN,BLANK8      BLANK OUT DDNAME FIELD IN DAIR PB
         BAL   LINK,GODAIR         ALLOCATE THE DATASET
         TM    ALFLAGS,MAYBBAD     ALLOCATE FAILED?
         BO    ALORTRN        YUP SO LEAVE ALTDDS ALONE
         LA    R4,TEMP             GET PTR TO DDNAME
         BAL   LINK,SRCHDDNM        GO FIND SLOT IN ADL
         MVC   0(8,R3),DDNAME      MOVE IN AN ALTERNATE DDNAME
*
ALORTRN  LM    R0,R9,ALSAVE        RESTORE SOME REGS
         BR    LINK                 AND RETURN
         DROP  R4
         EJECT
*
*  GODAIR - CALL DAIR TO ALLOCATE A DATASET
*
*
GODAIR   DS    0H
         STM   R1,R10,GDSAVE       SAVE SOME REGS
GODAIR1  L     R15,ENTRDAIR      GET DAIR ENTRY POINT
         XC    DAIRECB(4),DAIRECB  ZERO THE DAIR ECB
         LA    R1,DAIRPL           SET PTR TO DAIR PARM LIST
         LA    R2,DAIRPB           GET PTR TO DAIR PARM BLOCK
         USING DAPB08,R2
         TM    FLAGS,STARRED       IS THIS A TERMINAL DATASET ?
         BO    GOTERM              BR IF SO
         CALL  (15)
         MVC   DDNAME,DA08DDN      GET COPY OF DDNAME
         B     DARTST              GO CHECK RETURN CODE
*
*        ALLOCATE THE TERMINAL
*
GOTERM   DS    0H
         MVC   DTEMP,DA08DDN        MOVE OUT DDNAME
         DROP  R2
         USING DAPB1C,R2           NOW ADDRESS DAIR X'1C'
         XC    DAIRPB(DPBLEN),DAIRPB
         MVI   DA1CCD+1,X'1C'      SET DAIR ENTRY CODE FOR TERM
         MVC   DA1CDDN,DTEMP        MOVE IN DDNAME
         CALL  (15)                CALL DAIR
         MVC   DDNAME,DA1CDDN      GET COPY OF DDNAME
         DROP  R2
*
*        CHECK DAIR RETURN CODE
*
DARTST   DS    0H
         ST    R15,DAIRRC          SAVE THE RETURN CODE
         USING DAPB08,R2
         LTR   R15,R15             CHECK FOR DAIR O.K.
         BNZ   GDCHKERR             BR IF NOT O.K.
         EJECT
*
*        CHECK PARTITIONED DATASET
*
         TM    FLAGS,STARRED+NULLDS  TEST FOR TERMINAL OR NULL DATASET
         BNZ   DARETURN             RETURN IF EITHER
         TM    DA08DSO,PDS         WAS DATASET PARTITIONED ?
         BO    GDGOTPDS             BR IF SO
         CLI   MEMNAME,C' '        WAS A MEMBER SPECIFIED
         BE    GDCHKPDS             BR IF NOT, MAY BE O.K.
         LA    R1,MSG11            ELSE TELL USER
         BAL   LINK,SENDMSG         MEMBER SPECIFIED, BUT DS NOT A PDS
         B     DARETURN
GDCHKPDS TM    FLAGS,PDS           SHOULD DATASET HAVE BEEN A PDS ?
         BNO   DARETURN             O.K. IF NO
         OI    ALFLAGS,BADSN        ELSE, INDICATE ERROR
         LA    R1,MSG9               TELL USER
         BAL   LINK,SENDMSG           DATASET MUST BE PARTITIONED
         B     DARETURN            LET CALLER PROMPT FOR NEW DSN
*
*        WE HAVE A PDS, CHECK MEMBER
*
GDGOTPDS DS    0H
         TM    FLAGS,PDS           SHOULD THIS BE A PDS ?
         BO    DARETURN             DONE IF SO, NO MEMBER NAME PROC
         CLI   DA08MNM,C' '        WAS A MEMBER SPECIFIED ?
         BNE   DARETURN             DONE IF SO
         TM    FLAGS2,SPCLDSN      ARE WE PROCESSING SPECIALS ?
         BO    DARETURN             DONE IF SO
         MVC   TASKDCB(LTDCB),TASKDCBL   GET COPY OF DCB
         LA    R3,TASKDCB          SET UP THE DDNAME IN
         USING IHADCB,R3            THE DCB
         MVC   DCBDDNAM,DDNAME       FOR THE OPEN
         OPEN  ((R3),INPUT),MF=(E,OPENCLOS)   OPEN THE DATASET
         TM    DCBOFLGS,X'10'      OPEN O.K. ?
         BO    GDBUILD              BR IF O.K.
         OI    ALFLAGS,BADSN       INDICATE ERROR
         LA    R1,MSG8             TELL USER
         BAL   LINK,SENDMSG         UNABLE TO OPEN DATASET
         B     DARETURN            AND RETURN
*
*        CHECK IF MEMBER IS IN DATASET
*
GDBUILD  DS    0H
         CLI   MEMNAME,C' '        WAS A MEMBER SPECIFIED ?
         BNE   GDBLDLST             BR IF SO
         MVC   MEMNAME,TEMPNAME    SET 'TEMPNAME' AS THE MEMBER NAME
         MVC   BASICMEM,TEMPNAME   SET 'TEMPNAME' AS BASIC NAME ALSO
GDBLDLST MVC   MEMLIST(2),=H'1'    INDICATE ONE ENTRY
         MVC   MEMLIST+2(2),=H'58'  ENTRY LENGTH IS 58
         MVC   MEMLIST+4(8),MEMNAME    INSERT MEMBER NAME
         BLDL  (R3),MEMLIST        CHECK IF MEMBER IS THERE
         LTR   R15,R15             CHECK RETURN CODE
         BZ    GDGOTMEM             BR IF FOUND
         EJECT
*
*        MEMBER NOT FOUND, CHECK IF OLD DATASET REQUIRED
*
         CLOSE ((R3)),MF=(E,OPENCLOS)       DONE WITH DATASET
         TM    FLAGS,OLD           SHOULD IT ALREADY EXIST ?
         BNO   GDSETMEM             BR IF NOT NECESSARY
         MVC   MSGAREA(LMSG10),MSG10   ELSE SET UP ERROR MESSAGE
         MVC   MSGAREA+13(8),MEMNAME
         OI    ALFLAGS,BADSN       INDICATE ERROR
         LA    R1,MSGAREA          TELL USER OF THE PROBLEM
         BAL   LINK,SENDMSG         MEMBER NAME NOT FOUND
         B     DARETURN             AND EXIT
*
*        MEMBER NAME FOUND, FREE AND REALLOCATE DATASET
*
GDGOTMEM DS    0H
         CLOSE ((R3)),MF=(E,OPENCLOS)        DONE WITH THE DATASET
         MVC   DA08MNM,MEMNAME     INSERT MEMBER NAME FOR REALLOC
         OI    ALFLAGS,FREE        INDICATE FREE DESIRED
         B     FREEDD              GO FREE AND REALLOCATE
*
*        MEMBER NAME NOT FOUND, BUT MAY BE A NEW MEMBER
*
GDSETMEM DS    0H
         OI    ALFLAGS,FREE        DS IS TO BE FREED AND REALLOCATED
         CLI   MEMNAME,C' '        WAS A MEMBER SPECIFIED ?
         BNE   GDSETMNM             BR IF SO TO FREE DS
         CLI   BASICMEM,C' '       IS THERE A BASIC MEM NAME ?
         BE    GDSETMP              BR IF NOT - USE TEMPNAME
         MVC   MEMNAME,BASICMEM    USE BASIC MEMBER NAME
         B     GDSETMNM             GO INSERT IN DAIR PB
GDSETMP  MVC   MEMNAME,TEMPNAME    ELSE SET 'TEMPNAME' AS MEMBER
GDSETMNM MVC   DA08MNM,MEMNAME     SET NAME IN DAIR PB
         B     FREEDD
         EJECT
*
*        CHECK FOR DDNAME IN USE
*
GDCHKERR CH    R15,=H'20'          UNAVAILABLE DDNAME ?
         BE    FREEDD               GO FREE IT IF SO
         CH    R15,=H'12'          DAIR ERROR ?
         BNE   GDCHKDSN             BR IF NOT
         CLC   DA08DARC,=X'6708'  DSCB NOT ON VOLUME?
         BNE   NOPE           WASNT THAT
         TM    FLAGSUMW,VOLLED     DID USER SPECIFY A VOLSER?
         BNO   LASTRSRT       NOPE SO UNCAT AND ALLOC AS NEW
         B     GDTRYNEW       HE DID SO DONT DO THE UNCAT
NOPE     CLC   DA08DARC,X0408      DDNAME IN USE ?
         BNE   GODAFL               BR IF NOT - TERMINATE
*
*  REQUESTED DDNAME IS CURRENTLY UNAVAILABLE
*        SO FREE IT AND RETRY
*
FREEDD   DS    0H                  ENTER HERE TO FREE DDNAME
         BAL   LINK,DAIR18         GO SET UP DAPB18 PARM BLOCK
         LA    R3,DAIRPB18         GET PTR TO DAIR PB
         USING DAPB18,R3            MAKE IT ADDRESSIBLE
         MVC   DA18DDN,DDNAME      MOVE IN DDNAME TO BE FREED
         L     R15,ENTRDAIR        GET PTR TO DAIR
         LA    R1,DAIRPL           GET ADDR OF DAIR PARM LIST
         USING DAPL,R1              MAKE IT ADDRESSIBLE
         ST    R3,DAPLDAPB         SET ADDR OF NEW PARM BLOCK
         CALL  (15)                CALL DAIR
         ST    R15,DAIRRC          SAVE RETURN CODE FOR DAIRFAIL
         LTR   15,15               CHECK RETURN CODE
         BNZ   GODAFL               GO ISSUE MESSAGE IF BAD
         ST    R2,DAPLDAPB         NOW RESTORE DAPB ADDR
         TM    ALFLAGS,FREE        IS FREE DUE TO PDS PROC ?
         BO    GODAIR1              BR IF SO, NO MESSAGE
         MVC   MSGAREA(LMSG22),MSG22    MOVE MSG TO WORKAREA
         MVC   MSGAREA+6(8),DA18DDN     FILL IN DDNAME
         LA    R1,MSGAREA          GET PTR TO MSG
         BAL   LINK,SENDMSG        GO TELL USER FILE FREED
         B     GODAIR1              AND RETRY ALLOCATION
         DROP  R3
         DROP  R1
*
*        CHECK FOR DATASET NOT IN EXISTENCE
*
GDCHKDSN CH    R15,=H'8'           CATLG MGMT ERROR ?
         BE    GDCHKCAT             BR IF SO - MIGHT BE THE ONE
         CH    R15,=H'36'          ERROR IN CATLG INFO RTNE ?
         BNE   GODAFL               BR IF NOT - TERMINATE
GDCHKCAT CLC   DA08CTRC,=H'8'      DATASET NOT FOUND ?
         BNE   GODAFL               BR IF NOT - TERMINATE
         EJECT
*
*        TRY TO REALLOCATE DATASET AS NEW
*
GDTRYNEW DS    0H
         TM    FLAGS,OLD           CHECK IF DS MUST BE OLD
         BZ    TRYAGAIN       NOPE SO TRY NEW
         TM    FLAGSUMW,XTRAQUAL WAS A QUALIFIER ADDED?
         BZ    GODAFL         NOPE. CRAP OUT WITH MESSAGE
         OI    ALFLAGS,MAYBBAD     TRY AGAIN W/O QUALIFIER
         B    DARETURN        GO BACK TO CALLER
TRYAGAIN DS    0H
         BAL   LINK,DAIR8NEW       SET UP PARM BLOCK FOR NEW
         CLI   MEMNAME,C' '        WAS A MEMBER SPECIFIED ?
         BE    GDALCNEW             BR IF NOT TO ALLOC SEQ. D.S.
         LH    R1,=H'1'            SET DIRECTORY QUANTITY TO
         ST    R1,DA08DQTY          ONE DIRECTORY BLOCK
GDALCNEW OI    FLAGS,NEW           INDICATE WE CREATED THE DATASET
         L     R15,ENTRDAIR        GET DAIR ENTRY POINT
         LA    R1,DAIRPL           GET PTR TO DAIR PARM LIST
         CALL  (15)                CALL DAIR
         MVC   DDNAME,DA08DDN      SAVE THE DDNAME
         MVI   DA08DSP1,DA08SHR    CHANGE THE STATUS AND
         MVI   DA08DPS2,DA08KEEP    DISPOSITION IN CASE OF
         MVI   DA08DPS3,DA08KEEP     REALLOCATION
         LTR   R15,R15
         BZ    DARTST
         TM    FLAGSUMW,VOLLED     DID USER GIVE A VOLSER?
         BO    DROPQUAL       YUP SO OMIT THE UNCAT ATTEMPT
         TM    FLAGSUMW,XTRAQUAL   DID WE ADD A QUALIFIER?
         BNO   LASTRSRT       NOPE.
         CH    R15,=H'8'      CTLG MGMT ERROR?
         BNE   LASTRSRT       NOPE. LITTLE HOPE NOW
         CLC   DA08CTRC,=H'8' INDEX STRUCTURE PROBLEMS?
         BNE   LASTRSRT       NOPE
DROPQUAL       DS             0H
         OI    ALFLAGS,MAYBBAD     TRY AGAIN W/O QUALIFIER
         NI    FLAGS,255-NEW  TURN OFF NEW BIT
         B     DARETURN        TRY ALLOC OLD W/O QUALIFIER
LASTRSRT DS    0H             PROBABLY WONT GET THIS DS ALLOCATED.
         LA    15,CTLGDSN
         TM    DA08CTL,X'20'  WAS USERID PREFIXED?
         BZ    NOID
         L     14,CPPLSAVE
         USING CPPL,14
         L     14,CPPLUPT     UMW RCT
         DROP  14
         SR    15,15
         IC    15,23(14)           LENGTH OF PREFIX
         MVC   CTLGDSN(7),16(14)
         LA    15,CTLGDSN(15)
         MVI   0(15),C'.'
NOID     MVC   1(44,15),DSN
         LA    15,WCAMLIST
         MVC   WCAMLIST,CAMLIST
         LA    14,CTLGDSN
         ST    14,4+WCAMLIST
         CATALOG (15)         UNCATALOG DATASET
         LTR   R15,R15
         BZ    TRYAGAIN     TRY AGAIN
         MVC   MSGAREA(LMSG30),MSG30 GET ERROR MESSAGE
         MVC   MSGAREA+23(44),CTLGDSN  INSERT DSNAME
         LA    R1,MSGAREA          POINT TO MESSAGE
         B     MSNGR     CRAPOUT WITH MESSAGE
*
CAMLIST  CAMLST UCATDX,0
*
*        CALL DAIRFAIL TO ISSUE ERROR MESSAGE AND TERMINATE
*
GODAFL   LA    R1,DAFLPL           GET POINTER TO DAIRFAIL PARM LIST
         LINK  EP=IKJEFF18          AND CALL DAIRFAIL TO TELL USER
         B     TERMNATE              OF THE ERROR
         DROP  R2
*
*        RETURN TO CALLER
*
DARETURN LM    R1,R10,GDSAVE       RESTORE REGS
         BR    LINK                 AND RETURN
         EJECT
*
*  MAKENAM - CREATE A DSNAME FROM BASIC DSNAME + A QUALIFIER
*              R4 -> TO QUALIFIER
*
MAKENAM  DS    0H
         STM   R1,R5,MNSAVE        SAVE SOM REGS
         MVI   DSN,C' '            BLANK OUT DSNAME AREA
         MVC   DSN+1(43),DSN
         MVC   MEMNAME,BLANK8 CLEAR MEMBER NAME
         LH    R1,BASICLEN         GET LENGTH OF THE BASIC DSN
         LTR   R1,R1               CHECK IF WE EVER GOT ONE
         BNZ   MNMOVDSN             BR IF SO
         SR    R3,R3
         IC    R3,0(R4)            ELSE, THE QUALIFIER WILL
         L     R4,0(R4)             BECOME THE DSNAME
         STH   R3,DSNLEN           SAVE THE LENGTH
         BCTR  R3,0                AND MOVE IN THE QUALIFIER
         EX    R3,MNQLYMVC           AS THE DSNAME
         B     MNRTN               GO RETURN
*
MNMOVDSN BCTR  R1,0                DECREMENT FOR MVC
         EX    R1,MNDSNMVC         MOVE IN THE BASIC DSN
         LA    R2,DSN+1(R1)        POINT AT END OF DSNAME
         MVI   0(R2),C'.'          MOVE IN A SEPARATOR
         SR    R3,R3               GET LENGTH OF
         IC    R3,0(R4)             THE QUALIFIER
         L     R4,0(R4)            GET ADDR OF THE QUALIFIER
         LA    R5,2(R1,R3)         GET THE NEW DSNAME LENGTH
         BCTR  R3,0                DECREMENT FOR MVC
         EX    R3,MNQALMVC         NOW APPEND THE QUALIFIER
         CH    R5,=H'44'           CHECK DSN LENGTH
         BNH   MNSETLEN             BR IF O.K.
         LH    R5,=H'44'           GET MAX LENGTH
MNSETLEN STH   R5,DSNLEN           SET LENGTH
*
MNRTN    LM    R1,R5,MNSAVE        RESTORE REGS
         BR    LINK
         SPACE
MNDSNMVC MVC   DSN(0),BASICDSN     MOVES IN THE DSNAME
MNQALMVC MVC   1(0,R2),0(R4)       APPENDS THE QUALIFIER
MNQLYMVC MVC   DSN(0),0(R4)        MOVES IN THE QUAL AS THE DSNAME
         EJECT
*
*  DAIR8STD - CONSTRUCT THE STANDARD PORTION OF THE DAIR08 PARM BLOCK
*
DAIR8STD DS    0H
         STM   R1,R5,DSSAVE        SAVE SOME REGS
         LA    R1,DAIRPB
         USING DAPB08,R1
         XC    DAIRPB(DPBLEN),DAIRPB    ZERO OUT THE WHOLE THING
         MVC   DA08CD,=H'8'        ENTRY CODE IS X'08
         LA    R4,DSNAME           GET PTR TO WHATEVER'S IN DSNAME
         ST    R4,DA08PDSN         SAVE ADDR IN DAIR PARM BLOCK
         MVI   DA08DDN,C' '        BLANK OUT DDN, UNITNAME & VOL SER NO
         MVC   DA08DDN+1(23),DA08DDN
         MVI   DA08MNM,C' '        BLANK OUT MEMBER NAME
         MVC   DA08MNM+1(17),DA08MNM
         MVI   DA08DSP1,DA08SHR    SET STATUS = SHR
         MVI   DA08DPS2,DA08KEEP   SET DISP = KEEP
         MVI   DA08DPS3,DA08KEP    SET COND'L DISP = KEEP
         TM    FLAGS,QUOTED        WAS DSN QUOTED ?
         BO    DSNOPRE             BR IF SO - NO PREFIX OF USER ID
         OI    DA08CTL,DA08UID
         DROP  R1
DSNOPRE  LM    R1,R5,DSSAVE        RESTORE REGS
         BR    LINK                RETURN
         EJECT
*
*  DOINSERT - INSERT A STRING AT THE END OF THE COMMAND
*
DOINSERT DS    0H
         STM   R1,R4,DISAVE        SAVE SOME REGS
         USING OPTIONS,R2
         SR    R1,R1               CLEAR A REG FOR IC
         CLI   PASS,2             SPECIFIED OR DEFAULT
         BE    INSDEF              BRANCH IF DEFAULT
         CLI   SW,OFF             'NO' SPECIFIED
         BE    INSNO               BRANCH IF 'NO' SPECIFIED
         IC    R1,OPTINSRT        GET LENGTH OF INSERT STRING
         LTR   R1,R1
         BZ    INSEND             BR IF NO INSERT STRING
         L     R2,OPTINSRT        ADDR OF INSERT STRING
         B     INSDO              DO INSERTION
INSNO    IC    R1,OPTNOINS
         LTR   R1,R1
         BZ    INSEND
         L     R2,OPTNOINS
         B     INSDO
INSDEF   DS    0H
         IC    R1,OPTDFINS
         LTR   R1,R1
         BZ    INSEND
         L     R2,OPTDFINS
         DROP  R2
INSDO    LH    R3,CMDLEN           GET PRESENT LENGTH OF THE COMMAND
         LA    R4,CMDFLD(R3)       GET PTR TO END OF CMD
         MVI   0(R4),C' '          PUT IN A SEPARATOR
         LA    R3,1(R1,R3)         GET NEW LENGTH OF THE COMMAND
         STH   R3,CMDLEN            AND SAVE IT
         BCTR  R1,0                NOW MOVE THE STRING TO
         EX    R1,INSMVC            THE END OF THE COMMAND
*
INSEND   LM    R1,R4,DISAVE        RESTORE REGS
         BR    LINK                 AND RETURN
         SPACE
INSMVC   MVC   1(0,R4),0(R2)
         EJECT
*
*  CLEAR - CLEAR A BLOCK OF STORAGE
*              R5 -> AREA TO BE CLEARED
*              R1 HAS THE NUMBER OF BYTES TO CLEAR
*
CLEAR    DS    0H
CLRLOOP  CH    R1,=H'256'          IS AMT TO CLEAR < 256 ?
         BL    CLREND              BR IF SO
         XC    0(256,R5),0(R5)     CLEAR A BLOCK
         SH    R1,=H'256'          DECREMENT COUNT
         LA    R5,256(R5)          BUMP POINTER
         B     CLRLOOP             AND LOOP
CLREND   LTR   R1,R1               CHECK COUNT
         BNP   CLRTRN              DONE IF ZERO
         BCTR  R1,0                DECREMENT R1 FOR XC
         EX    R1,CLRXC            CLEAR REST OF BLOCK
CLRTRN   BR    LINK                RETURN
CLRXC    XC    0(0,R5),0(R5)       EXECUTED XC INSTRUCTION
         EJECT
*
*  DAIR8NEW - UPDATE THE DAIR-08 PARM BLOCK FOR NEW DATASETS
*
DAIR8NEW DS    0H
         ST    R1,DNSAVE           SAVE A REG
         LA    R1,DAIRPB
         USING DAPB08,R1
         MVI   DA08DSP1,DA08NEW    DISP = NEW
         MVI   DA08DPS2,DA08CAT    NORMAL DISP = CATLG
         MVI   DA08DPS3,DA08CATL   CONDITIONAL DISP = CATLG
         LH    R0,NEWAVLTH         GET AVERAGE BLOCK LENGTH
         ST    R0,DA08BLK          SAVE IT IN DAIR PB
         LH    R0,NEWPRIME         GET PRIMARY SPACE QUANTITY
         ST    R0,DA08PQTY         SAVE IT
         LH    R0,NEWSEC           GET SECONDARY SPACE QUANTITY
         ST    R0,DA08SQTY         SAVE IT
         TM    FLAGS,PDS
         BO    DANDIR
         CLI   DA08MNM,C' '        CHECK FOR PDS
         BE    DANNODIR            BR IF NOT A PDS
DANDIR   DS    0H
         LA    R0,1                GET DIRECTORY QUANTITY
         ST    R0,DA08DQTY         SAVE IT
*                                  SET FLAG FOR AVG BLOCK LENGTH & RLSE
DANNODIR DS    0H
         TM    FLAGSUMW,VOLLED     DID USER GIVE A VOLUME?
         BNO   DANOVOL        NOPE SO GET A DEFAULT
         MVC   DA08SER,VOLID  PUT USERS VOLUME IN PB
* WANTED TO ALLOC NEW KEEP THEN TRY TO CATLG BUT DAIR SAYS RC=4
*         MVI   DA08DPS2,DA08KEEP    NORMAL DISP = KEEP
*         MVI   DA08DPS3,DA08KEP   CONDITIONAL DISP = KEP
         B     DARET          AND RETURN
DANOVOL  MVC   DA08SER,NEWVOL     VOLUME SERIAL (GENERIC)
         LA    1,DA08SER
         DROP  R1
         L     15,=V(VOLSER)      CALL EXTERNAL ROUTINE
         BALR  14,15              TO FIND ACTUAL VOL SER
DARET    L     R1,DNSAVE           RESTORE A REG
         BR    LINK                RETURN
         EJECT
*
*  INSERTP - INSERT A PARM INTO THE PARM FIELD
*        ON ENTRY -
*              STRING CONTAINS THE PARM
*              STRLEN HAS LENGTH OF PARM
*              R1 -> NEXT AVAILABLE POSITION IN PARM FIELD
*        ON EXIT -
*              PARMCNT, PARMFLD ARE UPDATED
*
INSERTP  DS    0H
         STM   R0,R2,INSAVE        SAVE A REG
         LH    R2,STRLEN           GET LENGTH OF THE PARM
         EX    R2,INMVC             AND MOVE IT TO THE PARM FIELD
         AH    R2,PARMCNT          NOW BUMP THE COUNT
         AH    R2,=H'1'
         STH   R2,PARMCNT          AND SAVE IT FOR LATER
         LA    R1,PARMFLD(R2)      BUMP PARM PTR TO NEXT SLOT
         ST    R1,PARMSAVE         SAVE PARM POINTER
         LM    R0,R2,INSAVE        RESTORE SOME REGS
         BR    LINK                RETURN
         SPACE 2
INMVC    MVC   0(0,R1),STRING
         EJECT
*
*  SRCHDDNM - SEARCH THE ALTERNATE DDNAME LIST FOR A PARTICULAR DDNAME
*        ON ENTRY -
*              R4 -> DDNAME TO SEARCH FOR
*        ON EXIT -
*              R3 -> DDNAME SLOT IN ALTERNATE DDNAME LIST
*
SRCHDDNM DS    0H
         STM   R1,R2,SRSAVE        SAVE SOME REGS
         L     R1,CDLADL           GET PTR TO ALT DDNAME LIST
         USING ADL,R1
         LH    R2,ADLLEN           GET LENGTH OF ADL
         LA    R3,2(R1)         GET PTR TO REAL ADL
SRCLOOP  CLC   0(8,R3),0(R4)       CHECK A DDNAME
         BE    SRRTN               RETURN IF FOUND
         LA    R3,8(R3)            BUMP LIST POINTER
         SH    R2,=H'8'            DECREMENT COUNT
         BP    SRCLOOP             LOOP TILL FOUND
         B     ERROR               ERROR IF NOT THERE
SRRTN    DS    0H
         SLR   R3,R1
         LA    R3,ADLIST(R3)
         LM    R1,R2,SRSAVE        RESTORE REGS
         BR    LINK                RETURN
         DROP  R1
         EJECT
*
*  FREEUP - DELETE ROUTINES & FREE UP AS MUCH CORE AS POSSIBLE
*
FREEUP   DS    0H
         DELETE EP=IKJDAIR         GET RID OF DAIR
         SPACE
         LA    R1,ENDMAIN
         LA    R0,WORK2SZ
         FREEMAIN R,LV=(0),A=(1)   FREE SOME CORE
         SPACE
         BR    LINK                RETURN
         EJECT
*
*  MSNGR - WRITE AN ERROR MESSAGE TO THE TERMINAL AND TERMINATE
*        ON ENTRY -
*              R1 -> MESSAGE TO BE WRITTEN
*                    XL1'LENGTH-OF-MESSAGE',C'MESSAGE-TEXT'
*
MSNGR    DS    0H
         LA    LINK,TERMNATE       SET RETURN TO CLOSE SHOP
*
*  SENDMSG - SEND A MESSAGE TO THE TERMINAL AND RETURN
*
SENDMSG  DS    0H
         STM   R0,R1,SMSAVE
         SR    R0,R0               CLEAR R0 FOR IC
         IC    R0,0(R1)            GET LENGTH OF MESSAGE
         LA    R1,1(R1)            GET ADDR OF MESSAGE TEXT
         TPUT  (1),(0),R           WRITE OUT THE MESSAGE
         LM    R0,R1,SMSAVE
         BR    LINK                RETURN
         EJECT
*
*  GETMSG - OBTAIN A MESSAGE FROM THE TERMINAL
*        ON ENTRY -
*              R1 -> MESSAGE TO PROMPT USER WITH
*        ON EXIT -
*              INMSG   HAS USER'S RESPONSE
*
GETMSG   DS    0H
         STM   R0,R2,GMSAVE        SAVE SOME REGS
         LR    R2,R1               SAVE R1 FOR RETRY
*
*        PROMPT USER
*
GMRETRY  SR    R0,R0               CLEAR REG FOR IC
         IC    R0,0(R1)            GET LENGTH OF MESSAGE
         LA    R1,1(R1)            POINT TO START OF TEXT
         TPUT  (1),(0),R           ISSUE PROMPT
*
*        GET REPLY FROM USER
*
         LA    R1,INMSG            GET ADDR OF INMSG
         O     R1,X80              TURN ON HIGH ORDER BIT
         LA    R0,80               SPECIFY LENGTH
         TGET  (1),(0),R           GET REPLY FROM TERMINAL
         STH   R1,INMSGLEN         SAVE STRING LENGTH
*
*        CHECK FOR AND SUPPLY HELP IF REQUESTED
*
         CLI   INMSG,C'?'          CHECK FOR QUESTION MARK
         BNE   GMRTRN              RETURN IF NOT
         LA    R1,HELP             GET PTR TO HELP MESSAGE
         SR    R0,R0               GET LENGTH OF HELP
         IC    R0,0(R1)
         LA    R1,1(R1)            POINT TO TEXT
         TPUT  (1),(0),R
         MVC   HELP(LMSG23),MSG23  NEW HELP IS THE NO INFO MSG
         LR    R1,R2               RESTORE R1 FOR RETRY
         B     GMRETRY             GO RETRY GET
*
*        RETURN TO CALLER
*
GMRTRN   DS    0H
         LM    R0,R2,GMSAVE
         BR    LINK
         EJECT
*
*  DAIR18 - SET UP STANDARD DAIR X'18' PARM BLOCK
*
DAIR18   DS    0H
         STM   R1,R5,D18SAVE       SAVE SOME REGS
         LA    R5,DAIRPB18         GET PTR TO SPARE PARM BLOCK
         USING DAPB18,R5           MAKE IT ADDRESSIBLE
         XC    DAPB18(40),DAPB18   ZERO OUT THE BLOCK
         MVI   DA18CD+1,X'18'      SET ENTRY CODE
         MVI   DA18DDN,C' '        BLANK OUT THREE FIELDS
         MVC   DA18DDN+1(17),DA18DDN     DDNAME,MEMBER NAME,SYSOUT
         MVI   DA18DPS2,DA18KEEP   SET DISP TO KEEP
         MVI   DA18CTL,X'10'       SET SECRET CODE WHICH MAKES
*                                   DAIR WORK PROPERLY
         LM    R1,R5,D18SAVE       RESTORE REGS
         BR    LINK
         DROP  R5
         EJECT
*
*  PROCESSING FOR VARIOUS ERRORS ENCOUNTERED DOWN THE PIKE
*
         SPACE 2
*
*  INVALID COMMAND NAME
*
ERROR    DS    0H
         LA    R1,MSG1             GET PTR TO ERROR MESSAGE
         B     MSNGR               GO WRITE MESSAGE
         SPACE 3
*
*  UNABLE TO OPEN TASKLIB DCB
*
NOTASK   DS    0H
         LA    R1,MSG3             GET PTR TO ERROR MESSAGE
         B     MSNGR               WRITE IT
         EJECT
*
*  PERFORM ERROR TERMINATION
*
TERMNATE DS    0H
         MVC   STACKPB(8),STACKBLK      DELETE INPUT STACK
         LA    R1,STACKPL
         STACK PARM=STACKPB,DELETE=ALL,MF=(E,(1))
         TCLEARQ INPUT             DELETE INPUT QUEUE
         BAL   LINK,FREEUP
*
*  RETURN TO CALLER
*
RETURN   DS    0H
         L     SAVE,SAVEAREA+4
         L     RTRN,12(SAVE)
         LM    0,12,20(SAVE)
         BR    RTRN
         SPACE 3
STACKBLK STACK MF=L
         EJECT
*
*        VARIOUS EQUATES
*
R0       EQU   0
R1       EQU   1
R2       EQU   2
R3       EQU   3
R4       EQU   4
R5       EQU   5
R6       EQU   6
R7       EQU   7
R9       EQU   9
R10      EQU   10
R15      EQU   15
RTRN     EQU   14
SAVE     EQU   13
BASE     EQU   12
RWORK    EQU   SAVE                PTR TO LOCAL WORKAREA
BASE2    EQU   11                  SECOND BASE REGISTER
LINK     EQU   8
CMDENTLN EQU   12                  LENGTH OF COMMAND TABLE ENTRY
HORZTAB  EQU   X'05'               EBCDIC HORIZONTAL TAB
         EJECT
*
*        CONSTANT AREA
*
DUMMY    DS    0F
VCMDTAB  DC    V(GPPCMDS)  ADDR OF COMMAND TABLE
X0408    DC    X'0408'
         DS    0F
X80      DC    X'80000000'
BLANK8   DC    0CL8' '
BLANK80  DC    CL80' '
TEMPNAME DC    CL8'TEMPNAME'
NO       DC    C'NO'
         SPACE 3
TASKDCBL DCB   DSORG=PO,MACRF=(R),DDNAME=DUMMY
LTDCB    EQU   *-TASKDCBL
         EJECT
*
*        ERROR MESSAGES ISSUED BY THE PROMPTER
*
         PRINT NOGEN
MSG1     MSG   'INVALID COMMAND'
MSG3     MSG   'UNABLE TO OPEN TASKLIB DATASET'
MSG4     MSG   'LEADING QUOTE ASSUMED'
MSG5     MSG   'TRAILING QUOTE ASSUMED'
MSG6     MSG   'INVALID DSNAME -                                       *
                                      ',L
MSG7     MSG   'RIGHT PARENTHESIS ASSUMED'
MSG8     MSG   'UNABLE TO OPEN - DATASET ',L
MSG9     MSG   'DATASET MUST BE PARTITIONED'
MSG10    MSG   'MEMBER NAME          NOT FOUND',L
MSG11    MSG   'MEMBER NAME SPECIFIED, BUT DATASET IS NOT PARTITIONED'
MSG16    MSG   'REENTER -'
MSG20    MSG   'INVALID MEMBER NAME -         ',L
MSG22    MSG   'FILE          NOW UNALLOCATED',L
MSG23    MSG   'NO INFORMATION AVAILABLE',L
MSG24    MSG   'COMMAND TABLE ADDRESS NOT RESOLVED'
MSG30    MSG   'CATALOG ERROR. DSNAME=                                 *
                                           ',L
MSG32    MSG   'INVALID PASSWORD -         ',L
MSG34    MSG   'INVALID VOLSER -         ',L
         END    GPPROMPT
