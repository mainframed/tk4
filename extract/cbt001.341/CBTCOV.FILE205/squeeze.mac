SQZE     TITLE '                           * * * PROGRAM TO COMPRESS SO*
               URCE CODE * * *'
*        CSECT NAME -- SQUEEZE
*        OTHER ENTRY POINTS -- NONE
*        LANGUAGE -- IBM 370/VS ASSEMBLER
*                    (CAN EASILY BE CONVERTED TO OS/360 ASSEMBLER F)
*        ATTRIBUTES -- NOT REUSABLE
*        SUBROUTINES USED -- NONE
*        ATTACH, LINK, OR LOAD TO -- NONE
*        OPERATING SYSTEM -- OS/360/MVT REL 21.6
*        DATE WRITTEN -- MARCH 1970 (APPROX)
*        AUTHOR -- FRITZ D. PARHAM, JR.
*        INSTALLATION -- MIDDLE SOUTH SERVICES
*                        200 WEST BANK EXPRESSWAY
*                        GRETNA, LOUISIANA 70053
         SPACE 3
*        THIS PROGRAM 'COMPRESSES' SOURCE CODE.  CHARACTERS FOUND
*        ON A STANDARD IBM 029 KEYBOARD ARE COMPRESSED FROM 8 BIT
*        CODE TO 6 BIT CODE.  IN ADDITION, A STRING OF MORE THAN 3
*        BLANKS OR ASTERISKS ARE REPRESENTED BY THREE SIX BIT BYTES
*        (WITH CERTAIN EXCEPTIONS AND LIMITATIONS).
*        CHARACTERS THAT ARE NOT FOUND ON A STANDARD IBM 029 KEY PUNCH
*        REQUIRE FOUR 6 BIT BYTES TO REPRESENT. THUS THESE CHARACTERS
*        'EXPAND' WHEN THEY ARE 'COMPRESSED'.
         EJECT
***********************************************************************
*
*        INITIALIZATION -- ESTABLISH SAVEAREA AND BASE REGISTER.  NOTE
*        THAT SAVEAREA REGISTER IS USED AS BASE REGISTER.  GET THE
*        MEMBER NAME TO BE SQUEEZED. CHECK IF TO BE RENAMED AND
*        GET THE DATE FROM CVT PREFIX.
*
***********************************************************************
SQUEEZE  CSECT
         USING *,R15
         SAVE  (14,12),,*
         LA    R2,SAVEAREA              GET ADDR OF SAVE AREA
         B     SKIPSAVE                 BRANCH AROUND
         DROP  R15
SAVEAREA DS    18F                      SAVE AREA
         USING SAVEAREA,R13
         USING IHADCB,R1                GET DCB ADDRESSABILITY
SKIPSAVE DS    0H                       BYPASS SAVEAREA
         ST    R13,4(R2)                BACKWARD CHAIN
         ST    R2,8(R13)                FORWARD CHAIN
         LR    R13,R2                   GET MY PGMS SAVE AREA ADDR
         L     R10,0(R1)                LOAD ADDR OF PASSAREA
         USING PASSAREA,R10
         TM    INDBITS,NEWNMIND         IS THIS NEW NAME PROCESSING
         BNO   NOTNEWNM                 NO - PROCESS NORMALLY
         MVC   MEMBERNM(8),NEWNAME      MOVE NEWNAME TO FIELD
         B     NAMEBYP                  BYPASS STANDARD MOVE
NOTNEWNM DS    0H                       STANDARD PROCESSING
         MVC   MEMBERNM(8),NAME         MOVE THE MEMBER NAME
NAMEBYP  DS    0H                       BYPASS MOVING NAME
         MVC   GETADDR,4(R1)            MOVE EXIT ROUTINE ADDR
         MVC   MEMBWORK,MEMBERNM        MOVE NAME FOR STOW FORMAT
         L     R2,CVTPTR                GET CVT ADDR FOR DATE & REL #
         A     R2,FM8                   SUBTRACT 8 FROM CVT ADDR
         USING DCVT,R2                  ADDRESSABILITY FOR CVT
         PACK  MYRELNO(L'MYRELNO+1),CVTRELNO(3) PACKED UNSIGNED REL. #
         MVO   DATEWRK,CVTDATE+1(3)     DAY & YEAR IN PACKED UNSIGNED
         DROP  R2                       FINISHED WITH THE CVT
         EJECT
***********************************************************************
*
*        MORE INITIALIZATION -- GET THE DSNAME FOR ENQUE AND CHECK IF
*        MEMBER EXISTS ON THE LIBRARY.  GET MAIN STORAGE FOR BUFFERS
*        AND INITIALIZE DECB'S FOR BOTH BUFFERS.
*
***********************************************************************
         ENQ   (,PDSDSN),MF=(E,QLIST)   ENQUE ON COMPRESSED LIB
         OPEN  MF=(E,ROCLIST)           OPEN WITH REMOTE LIST
         TM    OOFLGS+BPAMOUT,X'10'     DID IT OPEN
         BZ    TILT2                    ABEND IF UNABLE TO OPEN
NOTFIXED EQU   X'40'                    B'01000000' ON IF VAR OR UND
FIXORUND EQU   X'80'                    B'10000000' BIT ON IF FIXED OR
         BLDL  BPAMOUT,BLDLLIST         CHK IF MEM IS ON LIB
         B     *+4(R15)                 BR BASED ON RETURN CODE
         B     REPL                     RC = 0 MEM FOUND - MUST BE REPL
         B     NEWMEMBR                 RC = 4 MEM NOT FOUND - MAY BE
*                                       EITHER ADD OR REPL
         B     TILT9                    RC = 8 I/O ERROR
REPL     DS    0H                       MEMBER IS PRESENT. CHK FOR ADD
         TM    INDBITS,REPLCTL           CHECK IF A REPL
         BNO   REPLERR                   NOT REPL - ERROR
         OI    INDBITS,REPLIND          INDICATE IT WAS REPLACED
         B     BLDLOKAY                 CONTINUE NORMAL PROCESSING
NEWMEMBR DS    0H                       THE MEM DOES NOT EXISTS ON LIB
         MVI   C,0                      MAKE IT NO HALFWRDS USER DATA
         OI    INDBITS,ADDIND            INDICATE IT WAS ADDED
ALIASTTR EQU   X'E0'                    B'11100000' MASK FOR ALIAS/TTR
BLDLOKAY DS    0H                       THE MEM WAS FOUND ON THE LIB
         TM    C,ALIASTTR               CHK IF ALIAS - TTR/NOTELIST
         BNZ   TILT3                    YES - WE DIDN'T PUT MEM ON LIB
         LH    R8,OBLKSI+BPAMOUT        LOAD BLKSIZE
         LR    R5,R8                    GET BLKSIZE IN R5
         ST    R5,BLKSIZE               SAVE COMPRESSED LIB BLKSIZE
         SR    R11,R11                  CLEAR TO CNT NO. BLKS WRITTEN
         LA    R5,3(,R8)                ADD 3 TO ROUND TO FULLWORD
         N     R5,FM4                   TURN OFF LAST 2 BITS FOR BNDRY
         LR    R0,R5                    LOAD SIZE IN R0 FOR GETMAIN
         ALR   R0,R0                    DOUBLE IT FOR TWO BUFFERS
         ST    R0,BUFSSIZE              SAVE SIZE FOR FREEMAIN
       GETMAIN R,LV=(0)                 GET MAIN STRG FOR BUFFERS
         ST    R1,ODECBUFR+DECB1        STORE ADDR FOR 1ST BUFFER
         LA    R4,8(,R1)                POINT TO FIRST BYTE OF DATA
*                                       WITH R4. VARIABLE RECS, 8 BYTES
*                                       COUNT PRECEEDS DATA
         ST    R4,CURRECAD              SAVE ADDR OF FIRST REC
         SR    R2,R2                    CLEAR FOR TRT INSTR OFFSETS
         LR    R4,R8                    GET ORIGINAL BLKSIZE IN R4
         A     R4,FM4                   ADD -4 FOR LRECL
         STH   R8,0(,R1)                ST BLKSIZE FOR ALL BUT LAST BLK
         STH   R2,2(,R1)                ZERO BLK DESCRIPTOR WORD (2BYT)
         STH   R4,4(,R1)                LRECL FOR ALL BUT LAST BLK
         STH   R2,6(,R1)                ZERO REC DESCRIPTOR WORD (2BYT)
         LA    R7,DECB1                 GET ADDR OF FIRST DECB
         USING DECBDSCT,R7               ADDRESSABILITY FOR 1ST DECB
         LR    R3,R1                    GET ADDR OF 1ST BUFFER
         AR    R3,R8                    ADD BLKSIZE TO GET END OF BUFF
         ST    R3,AFTBUFAD              STORE ADDR OF END OF BUFFER
         DROP  R7                       DROP DECB ADDRESSABILITY
         AR    R1,R5                    ADD BLKSIZE ROUNDED TO FULLWORD
*                                       THIS IS ADDRESS OF 2ND BUFFER
         ST    R1,ODECBUFR+DECB2        STORE ADDRESS OF 2ND BUFFER
*        NOW BUILD 8 BYTE PREFIX FOR SECOND BUFFER
         STH   R8,0(,R1)                BLKSIZE FOR ALL BUT LAST BLK
         STH   R2,2(,R1)                ZERO BLK DESCRIPTOR WORD
         STH   R4,4(,R1)                LRECL FOR ALL BUT LAST REC
         STH   R2,6(,R1)                ZERO REC DESCRIPTOR WORD
         LA    R6,DECB2                 GET ADDR OF 2ND DECB
         USING DECBDSCT,R6              ADDRESSABILITY FOR DECB
         AR    R1,R8                    ADD BLKSIZE FOR END OF BUFFER
         ST    R1,AFTBUFAD              STORE ADDR OF BUFFER END
         DROP  R6                       DROP DECB ADDRESSABILITY
         XR    R6,R7                    LOGICAL DIFFERENCE TO FLIP
*                                       BETWEEN BUFFERS.  IF R7 IS
*                                       XR'ED WITH R6 IT WILL POINT AT
*                                       DECB2.  IF XR'ED AGAIN IT WILL
*                                       POINT TO DECB1. (XR R7,R6)
         LA    R3,SQUEEZWK              POINT AT SQUEEZWK
         EJECT
         L     R15,GETADDR              GET ADDRESS OF EXTRN ROUTINE
         BALR  R14,R15                  LINK TO THE GET ROUTINE
         LTR   R1,R1                    WAS ADDR OF RECORD RETURNED?
         BZ    ENDDATA                  NO - TAKE EODAD ADDR
         LA    R5,78(,R1)               POINTER TO NEXT-TO-LAST BYTE
         LA    R15,8                    MAX OF 8 SEQ # ALLOWED
*
*        THE LAST 8 BYTES ARE CHECKED FOR NUMERIC.  IF SO, THESE BYTES
*        ARE NOT COMPRESSED. THE INCREMENT BETWEEN THE FIRST TWO CARDS
*        IS CALCULATED AND THIS DIFFERENCE IS ASSUMED FOR ALL CARDS.
*        IF THE INCREMENT CHANGES A FLAG IS SET AND THE NEW INCREMENT
*        IS SUPPLIED.  IF THEY ARE NOT NUMERIC THEN ALL 80 BYTES ARE
*        COMPRESSED.  IF THE SEQ FIELD IS LESS THAN 8 CHAR THEN THAT
*        MANY CHARACTERS ARE USED.
*
SEQ#LOOP DS    0H                       CHECK THE SEQ NO.S FOR NUMERIC
         CLI   1(R5),C'0'               IS IT NUMERIC
         BL    NOTNUMER                 NO - BRANCH TO SET UP
         CLI   1(R5),C'9'               CHECK HI NUMERIC END
         BH    NOTNUMER                 NOT NUMERIC - BRANCH
         BCTR  R5,0                     BACK POINTER UP ONE BYTE
         BCT   R15,SEQ#LOOP             DECREMENT AND LOOP
******** IF FALL THRU THEN DEFAULT OF 8 SEQUENCE # ON CARD
         B     DEFAULT8                 GO DO DEFAULT PROCESSING
         SPACE 2
NOTNUMER DS    0H                       A NON-NUMERIC CHAR WAS FOUND
*                                       IN THE LAST 8 BYTES OF THE
*                                       FIRST CARD
         LA    R14,70(R15)              ADD 70 TO (8 - # SEQ #'S)
         STC   R14,POINTEND+3           NOTE *** THIS MODIFIES AN INSTR
*                                       THIS IS THE NEXT TO LAST BYTE
*                                       TO SCAN
******** NEXT TWO INSTRUCTIONS STORE IN FIRST TWO BYTES OF SQUEEZWK
         MVI   0(R3),INTSTAST           SET FLAG FOR *'S OR SPECIAL RTN
         MVI   1(R3),0                  SET FLAG FOR SPECIAL ROUTINE
         LA    R14,2(R14)               ADD TWO TO GET OFFSET TO FIRST
*                                       BYTE OF SEQ NO
         STC   R14,PACKSEQ#+5           NOTE *** THIS CHANGES AN INSTR
*                                       STORE THIS OFFSET IN INSTR
         LA    R15,79                   LOAD OFFSET TO LAST BYTE
         SR    R15,R14                  SUBTRACT OFFSET OF START OF
*                                       SEQ FLD FROM 79
         BM    DONTPACK                 IF MINUS THEN NO SEQ FLD
         STC   R15,2(R3)                STORE ONE LESS THAN LEN OF SEQ
*                                       FIELD IN 3RD BYTE OF SQUEEZWK
         OI    2(R3),X'30'              TELL EXPAND NEW # OF SEQ #'S
         LA    R3,3(,R3)                INCR SQUEEZWK POINTER PAST INDS
         LA    R15,X'40'(R15)           MAKE FIRST NIBBLE LEN-1 OF 1ST
*                                       FIELD OF PACK INSTR
*                                       SECOND NIBBLE IS LEN-1 OF SEQ
*                                       FIELD
         STC   R15,PACKSEQ#+1           NOTE *** THIS CHANGES AN INSTR
*                                       PUT NEW LL FIELD IN PACK INSTR
         BCTR  R14,R0                   GET LEN-1 OF DATA PORTION OF
*                                       CARD
         STC   R14,TRANCARD+1           NOTE *** THIS CHANGES AN INSTR
*                                       CHANGE LENGTH IN TR INSTR
         B     DEFAULT8                 GO PROCESS AS IF 8 SEQ #'S
         SPACE 2
DONTPACK DS    0H                       IF BRANCH HERE THEN NO SEQ #'S
         MVC   PACKSEQ#(4),SKIPPACK     NOTE *** THIS CHANGES AN INSTR
*                                       MAKE THE PACK INSTR A BRANCH
         MVI   TRANCARD+1,79            NOTE *** THIS CHANGES AN INSTR
*                                       MOVE 80-1 TO TR INSTR LEN BYTE
         MVI   2(R3),X'3F'              TELL EXPAND NO SEQ FIELD
         LA    R3,3(,R3)           INCR PAST SPECIAL SEQ INDICATOR
BRANBASE EQU   *              BASE FOR TRT TABLE INSTRUCTION OFFSETS
         B     DEFAULT8                 PROCESS AS IF 8 SEQ NUMBERS
         EJECT
         USING DECBDSCT,R7              PROVIDE DECB ADDRESSABILITY
***********************************************************************
*
*        ON ENTRY TO THIS ROUTINE THE REGISTERS HAVE THE FOLLOWING
*
*        R1    ADDRESS OF BYTE CURRENTLY IN PROCESS
*        R3    ADDR OF NEXT BYTE IN WORK AREA
*        R4    ADDR OF FIRST BYTE AFTER A STRING OF 3 OR MORE ASTERISKS
*              OR BLANKS OR 1ST BYTE OF CARD
*        R5    ADDR OF END OF CARD (-1)
***********************************************************************
HITASTER EQU   *-BRANBASE               BR HERE IF SCAN HITS AN *
******** CHECK FOR THREE *'S IN A ROW *******
         CLI   1(R1),INTASTER           IS NEXT CHAR AN *?
         BNE   SCANLOOP                 NO - TREAT AS A NORMAL CHAR
         CLR   R1,R5                    WAS IT ON NEXT-TO-LAST COL?
         BE    THRUSCAN                 YES - FINISHED THIS CARD
         CLI   2(R1),INTASTER           IS 3RD CHAR ALSO AN *?
         BNE   SCANINCR                 NO - TREAT AS NORMAL CHAR
MOREASTR DS    0H                       ROUTINE TO HANDLE A STRING OF
*                                       MORE THAN 2 *
         LR    R15,R1                   GET ADDR OF THIS BYTE
         SR    R15,R4                   LEN   OF DATA PRIOR TO THIS STR
         EX    R15,MOVBYTES             MOVE THE STRING TO OUTPUT WRK A
******** THIS ALSO MOVES ONE ASTERISK IN INTERNAL CODE TO WORK AREA
         ALR   R3,R15                   POINT TO 1ST * FLAG IN WRK AREA
         LA    R14,2(R1)                ADDRESS OF 3RD *
         LR    R15,R5                   END ADDR OF CARD(-1)
         SR    R15,R14                  LEN-1 TO END OF CARD
         BM    RESTASTR                 BRANCH IF AT END OF CARD
         MVI   TBSCANOT+INTASTER,0      REMOVE INT CODE FOR * FROM TBL
         EX    R15,SCANOT               LOOK FOR 1ST NON-* ON REST OF C
         MVI   TBSCANOT+INTASTER,255    PUT INT CODE FOR * BACK IN TBL
         BZ    RESTASTR                 BR IF REST OF CARD WAS ASTERISK
         LR    R4,R1                    ADDR AFTER A STRING
         LR    R0,R1                    ADDR OF 1ST NON-ASTERISK
         SR    R0,R14                   # OF *'S IN STRING -2
         CL    R0,FULL63                IS IT LESS THAN 63
         BNL   MORATH64                 NO - THEN STRING IS 65 OR MORE
*                                       LONG (R0 = # IN STRING (-2))
FLAGSAST DS    0H                       BUILD FLAGS FOR A STRING OF *'S
         MVI   0(R3),INTSTAST           MOVE FLAG FOR A STRING OF *'S
         STC   R0,1(,R3)                STORE (#-2 IN STRING) IN FLAG B
         LA    R3,2(,R3)                INCREMENT WORK AREA ADDR
         BCT   R1,SCANLOOP              SUBTRACT ONE FROM R1 AND BRANCH
********       NO CHANCE OF FALLING THRU ABOVE INSTRUCTION
         SPACE 3
MORATH64 DS    0H                       BRANCH HERE IF MORE THAN 64 *
         BE    EXACT65A                 BRANCH IF EXACTLY 65 *'S IN STR
         SL    R0,FULL63                REDUCE NUMBER BY 63
         MVI   0(R3),INTSTAST           SHOW STRING OF ASTERISKS
         MVI   1(R3),61       SHOW 63 SAME CHAR IN STRING THUS FAR
         LA    R3,2(,R3)                POINT WRK AREA ADDR PAST FLAGS
         B     FLAGSAST                 BR TO HANDLE REMAINING *'S
EXACT65A DS    0H                       ROUTINE FOR EXACTLY 65 * IN STR
         LA    R3,1(,R3)                INCREMENT PAST SINGLE * IND
         BCT   R0,FLAGSAST              BRANCH AND DECREMENT # LEFT
*                                       NOW WHICH IS 62
********       NO CHANCE OF FALLING THRU ABOVE INSTRUCTION
         SPACE 3
RESTASTR DS    0H                       REST OF CARD IS ASTERISKS
         MVI   0(R3),INTSTAST           MOVE FLAG FOR STRING OF *'S
         MVI   1(R3),63                 SHOW REST OF CARD IS ASTERISKS
         LA    R3,1(,R3)                POINT TO LAST BYTE IN OUTPUT AR
         CL    R3,ADSQZPL2              CHECK IF WORD IN CONVERSION
*                                       WORK AREA
         BH    THRUMOVE                 YES - GO PROCESS WORD
         LA    R3,1(,R3)                POINT TO NEXT AVAILABLE BYTE
         B     GETCARD                  GO GET ANOTHER CARD
         SPACE 3
***********************************************************************
*
*        THE FOLLOWING TABLE GIVES THE FLAGS FOR DIFFERENT NUMBERS
*        OF ASTERISKS
*
*     # OF *'S         R0            FLAGS
*
*        63            61            3E3D
*        64            62            3E3E
*        65            63            3E3E3E
*        66            64            3E3D3E01
*        67            65            3E3D3E02
*   REST OF CARD       N/A           3E3F
*
***********************************************************************
         EJECT
***********************************************************************
*
*        THIS ROUTINE HANDLES 'SPECIAL CHARACTERS', CHARACTERS WHICH
*        IT WAS NOT CHOSEN TO REPRESENT IN 6 BITS.
*        A 'SPECIAL CHARACTER' (ONE WHICH IS NOT FOUND ON A STANDARD
*        KEYPUNCH) IS FLAGGED WITH 6 BITS OF ASTERISK SPECIAL FLAG (3E)
*        AND 6 BITS OF ZERO.  THEN, SINCE THE CHARACTER CANNOT BE
*        REPRESENTED IN SIX BITS, THE TWO NIBBLES ARE SEPARATED AND
*        PLACED IN THE LOW ORDER PORTION OF TWO BYTES.  SINCE THE
*        HIGH ORDER 2 BITS OF THE SIX BIT CODE REPRESENTING THESE
*        TWO NIBBLE-BYTES ARE ALWAYS ZERO THEY ARE USED TO INDICATE
*        IF MORE SPECIAL CHARACTERS FOLLOW THE FIRST.
*        FOR EXAMPLE, IF THE SPECIAL CHARACTERS X'B0B1' WERE INPUT
*        THEY WOULD BE TRANSLATED TO X'D7D8'.  WHEN THE SCAN
*        ENCOUNTERED THEM THIS ROUTINE WOULD GAIN CONTROL.  THE OUTPUT
*        OF THIS ROUTINE WOULD BE X'3E000D370D08'.  X'3E00' ARE THE
*        FLAGS INDICATING A SPECIAL CHARACTER.  X'0D37' IS THE FIRST
*        CHARACTER WITH EACH NIBBLE PLACED IN THE LOW ORDER POSITION
*        OF A BYTE.  THE '3' IS IN THE X'37' TO INDICATE THAT THE NEXT
*        BYTE IS ALSO A SPECIAL CHARACTER.  THE LAST CHARACTER
*        REPRESENTS THE X'D8' IN THE SAME MANNER - X'0D08' .
         SPACE
*        ON ENTRY TO THIS ROUTINE THE REGISTERS HAVE THE FOLLOWING
*
*        R1    ADDRESS OF BYTE CURRENTLY IN PROCESS
*        R3    ADDR OF NEXT BYTE IN WORK AREA
*        R4    ADDR OF FIRST BYTE AFTER A STRING OF 3 OR MORE ASTERISKS
*              OR BLANKS OR 1ST BYTE OF CARD
*        R5    ADDR OF END OF CARD (-1)
***********************************************************************
HITNOREG EQU   *-BRANBASE               BRANCH HERE IF SCAN HITS UNUSUL
         LR    R15,R1                   ADDR OF BYTE CURRENTLY IN PROC
         SR    R15,R4                   CALC LEN SINCE LAST BLK, *, SC
         BZ    DONTMOVE                 LAST CHAR WAS SOMETHING SPECIAL
         EX    R15,MOVBYTES             MOVE THOSE BYTES TO WORK AREA
         AR    R3,R15                   MAKE WORK POINTER POINT TO BYTE
*                                       CURRENTLY IN PROCESS
DONTMOVE DS    0H                       HERE IF NOTHING TO MOVE
         LA    R4,1(,R1)                POINT PAST THIS SPECIAL CHAR
         MVI   0(R3),INTSTAST           MOVE FLAG FOR STRING OF *'S OR
*                                       UNUSUAL CHARACTER
         MVI   1(R3),0                  2ND BYTE 0 - UNUSUAL CHAR
         UNPK  2(3,R3),0(2,R1)          UNPK TO SEPARATE NIBBLES
*                                       FN FN XX
         MVZ   2(2,R3),FULL63           MAKE ZONE NIBBLES ZERO
         LA    R3,3(,R3)                ADD 3 TO WORK AREA POINTER
*                                       NOW POINTING TO LAST BYTE OF
*                                       SPECIAL CHARACTER.  REQUIRES 4
*                                       BYTES TO REPRESENT SPECIAL CHAR
ANYMOSPC DS    0H                       BR POINT IF MORE SPECIAL CHAR
         CLR   R1,R5                    IS THIS END- OF-CARD
         BH    THRUMOVE                 YES - GO PROCESS SQUEEZWK AREA
         CLI   0(R4),MAXREGCH           IS NEXT CHAR UNUSUAL
         BH    MORESPEC                 IF SO GO PROCESS THEM
         LA    R3,1(,R3)                ELSE POINT PAST LAST SPECIAL
         B     SCANLOOP                 GO PROCESS REST OF CARD
         SPACE
MORESPEC DS    0H                       TO HANDLE MORE THAN 1 SPECIAL
         OI    0(R3),X'30'              FLAG PREV TO SHOW ANOTHER SPEC
         UNPK  1(3,R3),0(2,R4)          UNPK TO SEPARATE NIBBLES
         MVZ   1(2,R3),FULL63           MAKE ZONE NIBBLES ZERO
         LR    R1,R4                    ADDR OF NEXT BYTE
         LA    R4,1(,R4)                STEP PAST THIS SPECIAL
         LA    R3,2(,R3)                POINT AT LAST BYTE OF SPECIAL
         B     ANYMOSPC                 GO CHK IF AT END OF SCAN
         EJECT
***********************************************************************
*
*        ON ENTRY TO THIS ROUTINE THE REGISTERS HAVE THE FOLLOWING
*
*        R1    ADDRESS OF BYTE CURRENTLY IN PROCESS
*        R3    ADDR OF NEXT BYTE IN WORK AREA
*        R4    ADDR OF FIRST BYTE AFTER A STRING OF 3 OR MORE ASTERISKS
*              OR BLANKS OR 1ST BYTE OF CARD
*        R5    ADDR OF END OF CARD (-1)
***********************************************************************
HITBLANK EQU   *-BRANBASE               ROUTINE TO HANDLE BLANKS
******** CHECK FOR THREE BLANKS IN A ROW
         CLI   1(R1),INTBLANK           IS NEXT CHAR ALSO A BLANK
         BNE   SCANLOOP                 NO - HANDLE AS A NORMAL CHAR
         CLR   R1,R5                     ARE WE AT END-OF-CARD
         BE    THRUSCAN                 YES - GO PROCESS
         CLI   2(R1),INTBLANK            IS 3RD CHAR ALSO A BLANK
         BNE   SCANINCR                 NO - CONTINUE SCAN
         LR    R15,R1                   LOAD ADDR OF FIRST BLANK
         SR    R15,R4                   GET LENGTH OF STRING PROCESSED
*                                       UP TO NOW
         EX    R15,MOVBYTES             MOVE STRING TO OUTPUT WORK AREA
******** THIS ALSO MOVES ONE BLANK IN INTERNAL CODE TO WORK AREA
         AR    R3,R15                   MAKE R3 POINT AT BLANK FLAG
         LA    R14,2(R1)                GET ADDR OF 3RD BLANK
         LR    R15,R5                   GET ADDR OF END-OF-CARD (-1)
         SR    R15,R14                  LENGTH TO END-OF-CARD (-1)
         BM    RESTBLAN                 BR IF NOTHING LEFT TO SCAN
         MVI   TBSCANOT+INTBLANK,0      REMOVE BLANK FROM TR TABLE
         EX    R15,SCANOT               SCAN FOR FIRST NON-BLANK
         MVI   TBSCANOT+INTBLANK,255    PUT BLANK BACK IN TR TABLE
         BZ    RESTBLAN                  BR IF REST OF CARD IS BLANK
         LR    R4,R1                    ELSE - GET ADDR OF 1ST NON-BLK
         LR    R0,R1                     COPY ADDR OF 1ST NON-BLANK
         SR    R0,R14                   NUMBER OF BLANKS IN STRING (-2)
         CL    R0,FULL63                 COMPARE THIS TO 63
         BNL   MORBTH64                 BR IF 63 OR MORE. (65 OR MORE
*                                       BLANKS IN A ROW)
FLAGSBLN DS    0H                       FLAG FOR STRING OF BLANKS
         MVI   0(R3),INTSTBLN           MOVE THE FLAG FOR BLANKS
         STC   R0,1(,R3)                STORE # OF BLANKS (-2)
         LA    R3,2(,R3)                STEP PAST THE FLAGS
         BCT   R1,SCANLOOP               DECREMENT R1 AND BRANCH
********       NO CHANCE OF FALLING THRU ABOVE INSTRUCTION
         SPACE 2
MORBTH64 DS    0H                       HERE IF 65 OR MORE BLANKS IN
*                                       STRING.  R0 >= 63
         BE    EXACT65B                  BRANCH IF EXACTLY 65 IN STRING
         SL    R0,FULL63                SUBTRACT 63 FROM # IN STRING
         MVI   0(R3),INTSTBLN           MOVE FLAG FOR STRING OF BLANKS
         MVI   1(R3),61                 SHOW 63 IN STRING SO FAR
         LA    R3,2(,R3)                STEP PAST THE FLAGS
         B     FLAGSBLN                  GO HANDLE THE REST
         SPACE 2
EXACT65B DS    0H                       ROUTINE FOR EXACTLY 65 BLANKS
         LA    R3,1(,R3)                STEP PAST FIRST FLAG
         BCT   R0,FLAGSBLN              DECREMENT R0 TO 62 AND BRANCH
********       NO CHANCE OF FALLING THRU ABOVE INSTRUCTION
         SPACE 2
RESTBLAN DS    0H                       ROUTINE FOR REST OF CARD BLANK
         MVI   0(R3),INTSTBLN           MOVE FLAG FOR STRING OF BLANKS
         MVI   1(R3),63                 SHOW REST OF CARD IS BLANK
         LA    R3,1(,R3)                POINT TO LAST FLAG
         CL    R3,ADSQZPL2              IS THERE A WRD IN WORK AREA
         BH    THRUMOVE                 YES - THEN GO PROCESS
         LA    R3,1(,R3)                POINT PAST ALL FLAGS
         B     GETCARD                  GO GET ANOTHER CARD
         SPACE 3
***********************************************************************
*
*        THE FOLLOWING TABLE GIVES THE FLAGS FOR DIFFERENT NUMBERS
*        OF BLANKS.
*
*    # OF BLANKS       R0            FLAGS
*
*        63            61            3F3D
*        64            62            3F3E
*        65            63            3F3F3E
*        66            64            3F3D3F01
*        67            65            3F3D3F02
*   REST OF CARD       N/A           3F3F
*
***********************************************************************
         EJECT
SCANINCR DS    0H                       HERE IF TWO OF SAME CHAR
         LA    R1,1(,R1)                ADD ONE TO POINT TO 2ND CHAR
SCANLOOP DS    0H                       ROUTINE TO SCAN INPUT LOOKING
*                                       FOR SPECIAL CHARACTERS
*        REG 1 POINTS ONE BYTE BEFORE BYTE IN PROCESS ON ENTRY TO THIS
*        ROUTINE.
         LR    R15,R5                   END ADDR OF CARD (-1)
         SR    R15,R1                   LEN OF SCAN (-1 FOR EX)
         EX    R15,SCANREG1             EXECUTE TRT TO CHK FOR BLANKS,
*                                       *'S, OR SPECIAL CHARS
         B     *+10                     BRANCH AROUND THE EXECUTED INST
SCANREG1 TRT   1(0,R1),TBSCREG1    SCAN FOR BLANKS, **'S, IRREGULAR CHR
         BL    BRANBASE(R2)             IF ANY HIT, BR INDEXED BY BYTE
         BNH   THRUSCAN                 BR IF NOT HIT ON LAST BYTE
         CLI   0(R1),MAXREGCH+1         SEE IF IN REG CHAR SET
         BNL   BRANBASE(R2)             NO - THEN BR INDEXED BY BYTE
*                                       RETURNED
THRUSCAN DS    0H                       ELSE SCANNED ENTIRE REC W/O HIT
         LA    R5,1(,R5)                POINT AT LAST BYTE OF CARD
         SR    R5,R4                    CALC LEN (-1) FOR MOVE OF REST
*                                       OF CARD
         EX    R5,MOVBYTES              MOVE REST OF CARD IN INT CODE
         AR    R3,R5                    POINT TO LAST BYTE IN WORK AREA
THRUMOVE DS    0H                       ALL OF CARD MOVED TO 8 TO 6
*                                       CONVERT AREA
         LA    R2,4                     LOAD BXLE INCR
         SR    R3,R2                    SUBTRACT 4 FROM END ADDR
         LA    R4,SQUEEZWK-1            GET ADDR OF START
         LR    R5,R4                    SAVE ADDR FOR LATER USE
********       NOTE THAT THERE WILL BE AT LEAST 1 WORD TO PROCESS BELOW
         USING SQUEEZWD-1,R4  DSECT ADDRESSABILITY TO AVOID DIAGNOSTIC
BYTE4TO3 DS    0H                       STRIP HI ORDER 2 BITS FROM EACH
*                                       BYTE
         L     R0,SQUEEZWD              DSECT TO AVOID ASSEM DIAGNOSTIC
         SRDL  R0,6                     SHIFT 6 BITS INTO R1
         SRL   R0,2                      SHIFT OUT HI ORDER 2 BITS
         SRDL  R0,6                     SHIFT 6 BITS INTO R1
         SRL   R0,2                      SHIFT OUT HI ORDER 2 BITS
         SRDL  R0,6                     SHIFT 6 BITS INTO R1
         SRL   R0,2                      SHIFT OUT HI ORDER 2 BITS
         SRDL  R0,6                     SHIFT 6 BITS INTO R1
         ST    R1,SQUEEZWD              SAVE CONVERTED BYTES.  ONLY HI
*                                       ORDER 3 BYTES CONTAIN DATA
         BXLE  R4,R2,BYTE4TO3           ADD 4 TO R4 & BR IF LOW OR =
         DROP  R4                       END ADDRESSABILITY
         AR    R3,R2                    ADD 4 TO POINT AT LAST BYTE
         LR    R1,R4                    GET ADDR OF BYTE AFTER LAST
*                                       FULL WORD
         SR    R1,R5                    SUBTRACT START ADDR TO GET
*                                       NUMBER OF BYTES TO PROCESS
         LR    R5,R1                    COPY NUMBER OF BYTES TO PROCESS
         SRL   R1,2                     DIVIDE BY 4 TO GET NUMBER OF
*                                       WORDS TO PROCESS
         SR    R5,R1                    SUBTRACT NUMBER OF WORDS FROM
*                                       NUMBER OF BYTES TO GET NUMBER
*                                       OF BYTES OF DATA TO PROCESS.
*                                       (THERE IS 1 BYTE GARBAGE/WORD)
         L     R0,CURRECAD              ADDR OF AVAILABLE SPACE IN BUFF
         LR    R1,R0                    PUT IN R1 ALSO
         AR    R0,R5                    ADD NUMBER OF BYTES TO GET
*                                       NEXT SPACE IN BUFFER
         C     R0,AFTBUFAD              CHK WITH END ADDR TO SEE IF
*                                       ALL OF THIS WILL FIT IN BUFFER
         BNL   NOTALFIT                 BR IF JUST FITS OR WON'T FIT
         BCTR  R5,0                     SUBTRACT ONE FOR EXECUTE
         EX    R5,MOVETABL              MOVE TABLE FOR MOVING 3 OUT OF
*                                       4 BYTES.  THE TABLE CONTAINS
*                                       OFFSETS WITH EVERY 4TH ONE
*                                       OMITTED.  (E.G. 0,1,2,4,5,6,8)
*                                       THESE OFFSETS ARE USED TO STEP
*                                       INTO SQUEEZWK TO MOVE BYTES TO
*                                       THE BUFFER.
         EX    R5,GATH3OF4              EX A TR INSTR WITH SQUEEZWK
*                                       AS THE 'TABLE'. THE BYTES FROM
*                                       THE 'TABLE' REPLACE THE REAL
*                                       TABLE OF OFFSET BYTES IN THE
*                                       BUFFER.
NEWRECAD DS    0H                       HERE TO SAVE NEW ADDR OF AVAIL
*                                       SPACE IN BUFFER
         ST    R0,CURRECAD              UPDATE NEXT AVAIL SPACE IN BUFF
         SR    R3,R4                    ANY MODULUS 4 LEFTOVERS?
*                                       # OF BYTES = EVEN # OF WORDS
         BZ    NONEMOD3                 BR IF # OF BYTES IS NOT EVEN
*                                       MULTIPLE OF 4.
         MVC   SQUEEZWK(3),1(R4)        MOVE MAX LEFTOVERS TO BEGINNIN
*                                       OF WORKAREA FOR NEXT PROCESSING
NONEMOD3 DS    0H                       HERE IF NO MODULUS 4 LEFTOVERS
         LA    R3,SQUEEZWK(R3)          GET ADDR OF BEGINNING OF WORK
*                                       AREA INDEXED BY MODULUS 4
         EJECT
GETCARD  DS    0H                       GET A CARD IMAGE W ADDR IN R1
         L     R15,GETADDR              GET ADDR OF EXTRN ROUTINE
         BALR  R14,R15                  BALR TO THE GET ROUTINE
         LTR   R1,R1                    DID WE HIT END-OF-FILE
         BZ    ENDDATA                  TAKE EODAD ADDR
POINTEND LA    R5,70(,R1)               NOTE *** THIS INSTR IS MODIFIED
*                                       POINT AT NEXT-TO-LAST BYTE TO
*                                       SCAN
DEFAULT8 DS    0H                       HERE TO CONTINUE PROCESSING
         LR    R4,R1                    GET STARTING PT FOR NEXT MOVE
TRANCARD TR    0(72,R1),TBEXTINT        NOTE *** THIS INSTR IS MODIFIED
*                                       TRANSLATE CARD TO INTERNAL CODE
PACKSEQ# PACK  CURSEQ#R,72(8,R1)        NOTE *** THIS INSTR IS MODIFIED
*                                       PACK THE SEQUENCE NUMBER
         OI    CURSEQ#R+4,X'0F'         FORCE VALID SIGN
         AP    WORKSEQ#,SEQ#INCR        GEN NEXT SEQ # IF SAME INCR
         CP    CURSEQ#R,WORKSEQ#        IS IT SAME INCR AS CARD
         BNE   DIFFINCR                 NO - THEN MUST PROCESS SPECIAL
TST1STCL DS    0H                       CHECK 1ST COL FOR A BLANK
         CLI   0(R1),INTBLANK           IS FIRST COL BLANK
         BE    BRANBASE+HITBLANK        YES - GO SEE HOW MANY
         BCT   R1,SCANLOOP              ELSE GO USE TRT TO SCAN CARD
********       NO CHANCE OF FALLING THRU ABOVE INSTRUCTION
SKIPPACK B     TST1STCL                 MOVED TO PACKSEQ# IF NO SEQ #'S
         EJECT
NOTALFIT DS    0H                       HERE IF CHARACTERS WILL NOT
*                                       ALL FIT IN BUFFER IN USE
         L     R2,AFTBUFAD              GET ADDR OF END OF BUFFER
         SR    R2,R1                    CALCULATE # OF BYTES LEFT
         SR    R5,R2                    # THAT WOULD NOT GO IN THIS BUF
         BCTR  R2,0                     SUBTRACT ONE FOR EXECUTE
         EX    R2,MOVETABL              MOVE TABLE OF OFFSETS
         EX    R2,GATH3OF4              MOVE ONLY 3 OF EVERY 4 BYTES
         SPACE 2
WRITEBLK DS    0H                       HERE TO WRITE BLK JUST FILLED
         WRITE (R7),SF,MF=E             DO WRITE FOR BLK JUST FILLED
         LA    R11,1(R11)               COUNT NO. OF BLKS WRITTEN
         XR    R7,R6                    FLIP-FLOP DECB ADDRESS
         CHECK (R7)                     CHECK OTHER I/O OPERATION
         TM    INDBITS,ABENDIND         CHECK IF D37 OR E37 ABEND
         BO    ABENDEOJ                 YES - GO TERMINATE
         L     R1,ODECBUFR(,R7)         GET BUFFER ADDRESS
         LA    R1,8(,R1)                SKIP VARIABLE RECORD DESCRIPTOR
         ST    R1,CURRECAD              STORE THIS ADDR AS REC IN PROC
         LTR   R0,R5                    WERE THERE ANY FROM LAST BUFFER
         BZ    NONEOVER                 BR IF NONE LEFT OVER
         LA    R15,GATHTABL+1(R2)       WHERE TO PICK UP FROM IN TABLE
         BCTR  R5,0                     ONE LESS FOR EXECUTE
         EX    R5,MVTBLRST              MOVE REST OF TABLE OF OFFSETS
         EX    R5,GATH3OF4              MOVE REMAINDER OF 3 OF 4
NONEOVER DS    0H                       HERE IF NO BYTES LEFT FROM LAST
*                                       BUFFER
         AR    R0,R1                    ADD NUMBER LEFT TO BUFFER ADDR
         B     NEWRECAD                 GO STORE NEW ADDR AND GET NEW R
         EJECT
DIFFINCR DS    0H                       ROUTINE TO HANDLE A CHANGE IN
*                                       INCREMENT
         MVI   0(R3),INTSTAST           FLAG FOR SPECIAL ROUTINE
         MVI   1(R3),0                  2ND FLAG FOR SPECIAL ROUTINE
         SP    SEQ#INCR,WORKSEQ#        GET NEGATIVE OF LAST SEQ #
         ZAP   WORKSEQ#,CURSEQ#R        PICK UP NEW SEQ #
         AP    SEQ#INCR,CURSEQ#R        ADD NEGATIVE OF LAST SEQ # TO
*                                       PRESENT SEQ # TO GET INCREMENT
         CVB   R14,SEQ#INCR             CONVERT INCR/DECR TO BINARY
         LR    R0,R14                   SAVE IN CASE OVERFLOW
         SRDL  R14,6                    SHIFT 6 WANTED BITS INTO R15
         SRL   R15,2                    SHIFT 2 PADDING BITS INTO R15
         SRDL  R14,6                    SHIFT 6 WANTED BITS INTO R15
         SRL   R15,2                    SHIFT 2 PADDING BITS INTO R15
         SRDL  R14,6                    SHIFT 6 WANTED BITS INTO R15
         SRL   R15,2                    SHIFT 2 PADDING BITS INTO R15
         SRDL  R14,4                    SHIFT 4 WANTED BITS INTO R15
         SRL   R15,4                    SHIFT 4 PADDING BITS INTO R15
         SLA   R0,10                    SHIFT OUT 10 BITS TO SEE IF
*                                       OVERFLOW
         BO    OVERFLOW                 BR IF NEW INCR NOT FIT IN 22 B
         O     R15,FLAGINC4             INDICATE 4 CHAR NEW SEQ # INCR
         ST    R15,0(R13)               STORE FOR ALIGNMENT
         MVC   2(4,R3),0(R13)           MOVE TO NON-FULLWORD BOUNDRY
*                                       THE CODED NEW INCREMENT
         LA    R3,6(,R3)                INCR PAST ALL OF THESE FLAGS
*                                       AND INCREMENT
         B     TST1STCL                 GO TEST 1ST COLUMN FOR A BLANK
         SPACE 2
OVERFLOW DS    0H                       HERE IF 5 CHAR INCR NECESSARY
         O     R15,FLAGINC5             INDICATE 5 CHAR NEW SEQ # INCR
         ST    R15,0(R13)               STORE IN FULLWORD ALIGNED
         MVC   2(4,R3),0(R13)           MOVE NEW CODED INCR
         STC   R14,6(R3)                STORE HIGH SIGNIFICANT BITS
         LA    R3,7(,R3)                INCR PAST ALL OF THESE FLAGS
         B     TST1STCL                 GO TEST 1ST COLUMN FOR A BLANK
         EJECT
ENDDATA  DS    0H                       EODAD ROUTINE
         L     R4,CURRECAD               GET ADDR JUST PAST LAST DATA
         LA    R15,SQUEEZWK             GET ADDR OF START OF WORK AREA
         SR    R3,R15                    HOW MANY MORE TO PROCESS
******** THERE WILL NOT BE MORE THAN 3 BYTES TO PROCESS AT THIS TIME
         BNP   NOLSTMD3                 BR IF NOTHING LEFT TO PROCESS
         L     R0,SQUEEZWK              LOAD LEFTOVER IN R0
         SRL   R0,8                     SHIFT OUT EXTRA BYTE
         SR    R1,R1                    CLEAR BEFORE SHIFTING BEGINS
         SRDL  R0,6                     SHIFT 6 BITS INTO R1
         SRL   R0,2                      SHIFT OUT 2 BITS
         SRDL  R0,6                     SHIFT 6 BITS INTO R1
         SRL   R0,2                      SHIFT OUT 2 BITS
         SRDL  R0,6                     SHIFT 6 BITS INTO R1
         ST    R1,SQUEEZWK               STORE THE 6 BIT CODES
         LR    R1,R4                    GET ADDR OF NEXT LOC IN BUFFER
         AR    R4,R3                     ADD # LEFTOVER TO # TO WRITE
         BCTR  R3,0                     SUBTRACT ONE FOR THE EXECUTE
         CL    R4,AFTBUFAD               WILL THEY ALL FIT IN THIS BUFF
         BH    NOTQUITE                 NO - JUST DIDN'T MAKE IT
         EX    R3,MVTBLRST              MOVE LEFTOVERS TO BUFFER
NOLSTMD3 DS    0H                       HERE IF NOTHING LEFT IN WK AREA
         L     R1,ODECBUFR(,R7)          GET THE BUFFER ADDR FROM DECB
         SR    R4,R1                    GET LEN OF LAST BLK
WRITLAST DS    0H                        NOW WE CAN WRITE LAST BLOCK
         STH   R4,0(,R1)                PUT BLOCKSIZE IN BLOCK DESC WD
         A     R4,FM4                    ADD -4 FOR LRECL
         CH    R4,=H'4'                 CHK IF ONLY 4 BYTES LONG
         BNH   SKIPWRCK                 SKIP WRITE IF JUST REC DESC WRD
         STH   R4,4(R1)                 LRECL FOR LAST BLK
         LR    R1,R4                    GET LRECL OF LAST BLK
         LA    R1,4(R1)                 ADD 4 TO GET BLKSIZE
         ST    R1,LASTBLK               STORE SIZE OF LAST BLK
         WRITE (R7),SF,MF=E             WRITE LAST BLOCK
         XR    R7,R6                    FLIP/FLOP DECB'S
         CHECK (R7)                     CHECK NEXT-TO-LAST I/O
         TM    INDBITS,ABENDIND         CHECK IF D37 OR E37 ABEND
         BO    ABENDEOJ                 YES - GO TERMINATE
SKIPWRCK DS    0H                       SKIP WRITE AND CHECK IF NO LAST
         CLI   C,2                      CHK STOW FOR 2 HALFWRDS USER
         BL    FORCE2UD                 BR IF NOT ENOUGH USER DATA
         IC    R2,SSIUDATA+1            GET COUNTER FOR MODIFICATIONS
*                                       IN SAME DAY
         NI    SSIUDATA+1,X'0F'         CLEAR COUNTER FOR COMPARE
         CLC   SSIUDATA,MYRELNO         IS RELATIVE # AND DATE SAME
MOVEDATE MVC   SSIUDATA,MYRELNO         MOVE IN DATE AND REL# FOR DEFLT
         BNE   DIFFDATE                 IF DATE DIFF DON'T INCR COUNTER
         LA    R2,X'10'(,R2)            INCR SAME-DAY COUNTER
         STC   R2,SSIUDATA+1            STORE SAME-DAY INCR COUNTER &
*                                       YEAR DIGIT
DIFFDATE DS    0H                       HERE IF DATE HAS CHANGED
***********************************************************************
*        PROBLEM: PRB109 - 8/21/75                                    *
*        REPORTED BY: JANE HUBBARD                                    *
*        IF A PROGRAM IS CHANGED MORE THAN 10 TIMES IN ONE DAY, THE   *
*        SSI CARD FOR THE LINKAGE EDITOR CONTAINS INVALID CHARACTERS  *
*       (FA - FF), WHICH BLOWS IEWL'S MIND.                           *
*        FIX: IF MOD COUNT OVERFLOWS, RESET TO ZERO.                  *
*        8/21/75 - SP,MSS AGT                                         *
***********************************************************************
         CLI   SSIUDATA+1,X'A0'         DID MOD NUMBER OVERFLOW     JAH
         BL    *+8                      NO, BRANCH                  JAH
         NI    SSIUDATA+1,X'0F'         YES, MAKE ZERO              JAH
***********************************************************************
         MVC   STOWMEMB,MEMBWORK   MOVE NAME TO STOW FORMAT, ELIM. K, Z
         XR    R7,R6                    FLIP/FLOP DECB'S
         CHECK (R7)                     CHECK LAST I/O
         TM    INDBITS,ABENDIND         CHECK IF D37 OR E37 ABEND
         BO    ABENDEOJ                 YES - GO TERMINATE
         L     R0,BUFSSIZE              GET BUFFER SIZE FOR FREEMAIN
      FREEMAIN R,LV=(0),A=ODECBUFR+DECB1 FREE BUFFERS
         MVC   SSIDATA,SSIUDATA         MOVE SSIDATA TO PASSAREA
         STOW  BPAMOUT,STOWMEMB,R       UPDATE DIRECTORY & WRITE EOD
         B     STOWBTAB(R15)            BRANCH INTO TABLE USING COND CD
         SPACE 2
FORCE2UD DS    0H                       FORCE 2 HALFWORDS USER DATA
         MVI   C,2                      MAKE IT 2 HALFWORDS USER DATA
********       AFTER MOVE COND CODE WILL FORCE A BRANCH TO DIFFDATE
         B     MOVEDATE                 GO FORCE NEW DATE
         SPACE 2
STOWBTAB DS    0H                       BRANCH TABLE FOR STOW
         B     CLOSDEQ                  MEMBER WAS ALREADY THERE
         B     TILT4A                   INVALID COND CODE
         B     CLOSDEQ                  MEMBER REPLACED
         B     TILT4A                   NO SPACE IN DIRECTORY
         EJECT
NOTQUITE DS    0H                       LAST BYTES WILL NOT ALL FIT IN
*                                       LAST BUFFER
         L     R14,AFTBUFAD             GET ADDR JUST PAST BUFFER
         SR    R14,R1                   # BYTES LEFT IN BUFFER
         SR    R3,R14                   # BYTES THAT DIDN'T FIT (-1)
         BCTR  R14,R0                   GET # BYTES LEFT IN BUFFER (-1)
         EX    R14,MVTBLRST             MOVE THOSE THAT FIT IN BUFFER
         LA    R4,SQUEEZWK+1(R14)       ADDR OF START OF LEFTOVERS
         WRITE (R7),SF,MF=E             WRITE BLOCK JUST FILLED
         LA    R11,1(R11)               COUNT NO. OF BLKS WRITTEN
         XR    R7,R6                    FLIP/FLOP DECB'S
         CHECK (R7)                     CHECK THE WRITE
         TM    INDBITS,ABENDIND         CHECK IF D37 OR E37 ABEND
         BO    ABENDEOJ                 YES - GO TERMINATE
         L     R1,ODECBUFR(,R7)         GET THE BUFFER ADDRESS
         MVC   8(2,R1),0(R4)            MOVE MAX LEFTOVER NOW
         LA    R4,9(,R3)                LENGTH OF LAST BLOCK
         B     WRITLAST                 GO WRITE LAST BLOCK
         DROP  R7                       END DECB ADDRESSABILITY
         EJECT
CLOSDEQ  DS    0H                        EOJ - CLOSE DATA SET, DEQUEUE,
*                                       AND RETURN
         CLOSE ,MF=(E,ROCLIST)          USE REMOTE LIST
         DEQ   ,MF=(E,QLIST)            DEQUEUE DATA SET
         ST    R11,NUMBLKS              SAVE NUMBER OF BLOCKS WRITTEN
EOJ      DS    0H                       HERE TO BYPASS DEQ
         L     R15,CONDCODE             LOAD THE RETURN CODE
         L     R13,4(R13)               CHAIN BACK A SEVE AREA
         L     R14,12(R13)              RESTORE R14
         LM    R0,R12,20(R13)           RESTORE REGISTERS
         BR    R14                      RETURN
         SPACE 3
REPLERR  DS    0H                       ADD SPECIFIED FOR EXISTING MEM
         MVI   DCBADDR,X'BF'            OPEN OPTIONS - OUTPUT,LEAVE
         LA    R1,DCBADDR               LOAD ADDR FOR OPEN
         OPEN  MF=(E,(1))               OPEN SYSPRINT (WORK04)
         L     R1,DCBADDR               GET DCB ADDR
         PUT   (1),MESG1                WRTIE MESSAGE
         MVI   CONDCODE+3,X'10'         MAKE RETURN CODE 16
         B     CLOSDEQ                  GO TERMINATE
         SPACE 2
PDSEXIT  DS    0H                       DCB EXIT ROUTINE FOR BPAMOUT
         CLC   DCBBLKSI,=H'0'           CHK IF BLKSIZE SUPPLIED
         BNE   HAVEBLKZ                 NO - BLKSIZE SUPPLIED
         MVC   DCBBLKSI,=H'6447'        BLKSIZE FOR 2 BLKS/TRK FOR 3330
HAVEBLKZ DS    0H                       BLKSIZE SUPPLIED
         LH    R2,DCBBLKSI              GET BLKSIZE IN R2
         SH    R2,=H'4'                 SUBTRACT FOUR TO GET LRECL
         STH   R2,DCBLRECL              FORCE TO THIS LRECL
         BR    R14                      RETURN TO OPEN
         SPACE 3
ABENDEOJ DS    0H                       HERE IF E37 OR D37 ABEND
         MVI   CONDCODE+3,X'14'         MOVE CONDITION CODE OF 20
         B     EOJ                      GO TERMINATE
         EJECT
ABNDEXIT DS    0H                       DCB EXIT FOR DCB RELATED ABENDS
         USING DCBABPRM,R1              ESTABLISH ADDRESSABILITY TO PAR
         CLC   DCBABCOM,=X'D370'        CHECK IF A D37 ABEND
         BE    LIBFULL                  YES - THEN THE LIB IS FULL
         CLC   DCBABCOM,=X'E370'         CHECK IF AN E37 ABEND
         BE    LIBFULL                  YES -THEN THE LIB IS FULL
NOFIX    DS    0H                       HERE IF NO REORG
         MVI   DCBABOPM,X'00'           INDICATE CONTINUE ABEND
         BR    R14                      RETURN TO EOV
LIBFULL  DS    0H                        HERE IF A D37 OR E37 ABEND
         LH    R15,ABENDCNT             GET COUNT IN CASE REPEAT
         BCT   R15,GORETRY              COUNT DOWN AND BRANCH
         B     NOFIX                    ALREADY REORG ONCE IF FALL THRU
GORETRY  DS    0H                        INDICATE A REORG TO BE DONE
         STH   R15,ABENDCNT             STORE THE NEW ABEND COUNT
         MVI   DCBABOPM,X'04'           INDICATE IGNORE THE ERROR
         OI    INDBITS,ABENDIND         TURN ON THE ABEND INDICATOR
         BR    R14                      RETURN TO EOV
         SPACE 3
DCBABPRM DSECT
DCBABCOM DS    CL2                      SYSTEM COMPLETION CODE
DCBABRTC DS    CL1                      RETURN CODE
DCBABOPM DS    CL1                      OPTION CODE MASK
DCBABADR DS    CL4                      DCB ADDRESS
DCBABWAA DS    CL4                      WORK AREA ADDRESS
DCBABRWA DS    CL4                      RETRY WORK AREA ADDRESS
SQUEEZE  CSECT                          CONTINUE CSECT
         EJECT
TILT2    LA    R1,200         COMPLETION CODE FOR ABEND DUMP IN R1
         B     TILT           GO OR IN DUMP BIT AND ISSUE ABEND SVC
TILT3    LA    R1,300         COMPLETION CODE FOR ABEND DUMP IN R1
         B     TILT           GO OR IN DUMP BIT AND ISSUE ABEND SVC
******** RETCODE BRAN HERE IF PERMANENT ERROR IN ATTEMPT DIRECTORY UPDT
TILT4A   LA    R1,400(R15)    COMPLETION CODE FOR ABEND DUMP IN R1
         B     TILT           GO OR IN DUMP BIT AND ISSUE ABEND SVC
********       TILT9 FOR UNCORRECTABLE ERROR SEARCHING DIRECTORY - BLDL
TILT9    LA    R1,900         COMPLETION CODE FOR ABEND DUMP IN R1 RC 8
         B     TILT                     GO ABEND
TILT     O     R1,DUMPCODE    REQUEST DUMP WITH ABEND
         ABEND (1)            GENERATE ABEND SVC
R0       EQU   0                  SYMBOLIC REGISTER DEFINITION
R1       EQU   1                  SYMBOLIC REGISTER DEFINITION
R2       EQU   2                  SYMBOLIC REGISTER DEFINITION
R3       EQU   3                  SYMBOLIC REGISTER DEFINITION
R4       EQU   4                  SYMBOLIC REGISTER DEFINITION
R5       EQU   5                  SYMBOLIC REGISTER DEFINITION
R6       EQU   6                  SYMBOLIC REGISTER DEFINITION
R7       EQU   7                  SYMBOLIC REGISTER DEFINITION
R8       EQU   8                  SYMBOLIC REGISTER DEFINITION
R9       EQU   9                  SYMBOLIC REGISTER DEFINITION
R10      EQU   10
R11      EQU   11
R12      EQU   12
R13      EQU   13
R14      EQU   14
R15      EQU   15
MESG1    DC    CL121'0IZG016I ATTEMPT TO ADD A MEMBER THAT PRESENTLY EX*
               ISTS ON THE LIBRARY.'
CONDCODE DC    F'0'                     RETURN CODE
GETADDR  DS    F
SQUEEZWK DS    28D            COMPRESS AND SQUEEZE WORK AREA
SEQ#INCR DC    PL8'0100'     DBLWD INCREMENT BETWEEN SEQUENCE NUMBERS
***********************************************************************
MAJOR    DC    C'COPYDATA'    QNAME
FM8      DC    F'-8'          FULLWORD BINARY MINUS 8 CONSTANT
FM4      DC    F'-4'          FULLWORD BINARY MINUS 4 CONSTANT
FULL63   DC    F'63'          CONSTANT USED FOR COMPARING AND SUBTRACT
ADSQZPL2 DC    A(SQUEEZWK+2)  ADDRESS USED FOR COMPARE
FLAGINC4 DC    B'00100000000000000000000000000000'  FLAGS FOR INCREMENT
FLAGINC5 DC    B'00010000000000000000000000000000'  FLAGS FOR INCREMENT
CURRECAD DS    A              ADDRESS OF CURRENT RECORD IN OUT BUFFER
DUMPCODE DC    X'80000000'    REQUEST DUMP WITH ABEND FLAG WORD-ALIGNED
ROCLIST  OPEN  (BPAMOUT,OUTPUT),MF=L    REMOTE LIST
*        DCB ABEND EXIT DISABLED BECAUSE OF MVS PROBLEMS - AGT 8/5/79
EXTLSTOT DC    0F'0',X'85',AL3(PDSEXIT),X'91',AL3(ABNDEXIT)
QLIST    ENQ   (MAJOR,MINOROUT,E,,SYSTEM),MF=L  ENQUE LIST
***********************************************************************
         EJECT
***********************************************************************
BPAMOUT  DCB   DSORG=PO,      PARTITIONED DATA SETS                    C
               MACRF=W,       WRITE                                    C
               NCP=2,         MAX # OUTSTANDING WRITES                 C
               BUFNO=0,       DO OUR OWN BUFFERING                     C
               EXLST=EXTLSTOT,     EXIT LIST FOR READ DATA SET JFCB    C
               RECFM=V,       VARIABLE LENGTH RECORDS                  C
               DDNAME=PDS      DATA SET WHERE MEMBER ADDED/REPLACED
***********************************************************************
         EJECT
***********************************************************************
         WRITE DECB1,SF,BPAMOUT,MF=L   FIRST OF TWO DECB'S
         DC    A(0)           ADDRESS OF LOCATION JUST AFTER BUFFER
DECB2    DC    X'7F00000000200000',A(BPAMOUT),2A(0)  POSTED COMPL. DECB
         DC    A(0)           ADDRESS OF LOCATION JUST AFTER BUFFER
***********************************************************************
MINOROUT DC    0CL44' '                 DUMMY TO PROVIDE LENGTH FOR MAC
MEMBWORK DS    CL8            WORKAREA FOR MEMBER NAME FOR STOW
***********************************************************************
MYRELNO  DS    XL1            CURRENT RELEASE # IN PACKED UNSIGNED FORM
DATEWRK  DS    XL4            JULIAN DATE PACKED UNSIGNED + 1 BYTE CRUD
         ORG   *-1                 BACK UP OVER JUNK BYTE
BUFSSIZE DS    F              SIZE OF AREA FOR BUFFERS
***********************************************************************
BLDLLIST DC    H'1',Y(ENDBLENT-MEMBERNM)  # ENTRIES, LENGTH EACH ENTRY
MEMBERNM DC    CL8' '               FOR MEMBER NAME
STOWMEMB EQU   MEMBERNM+2     BEGINNING OF NAME + TTR IN STOW FORMAT
TTRK     DS    XL4                  TTR AND CONCATENATION #
Z        DS    XL1                  SHOULD BE 0 FOR PRIVATE LIBRARY
C        DS    BL1  BITS: ALIAS-1, # TTRN-2, # HALFWORDS USER DATA-5
SSIUDATA DS    XL4                  SSI FIELD IN USER DATA
         DS    XL58                 ROOM FOR MAXIMUM POSSIBLE USER DATA
ENDBLENT EQU   *                    END OF BLDL LIST ENTRY
***********************************************************************
GATHTABL DC    AL1(0,1,2,4,5,6,8,9,10,12,13,14,16,17,18,20,21,22) #1
         DC    AL1(24,25,26,28,29,30,32,33,34,36,37,38,40,41,42)  #2
         DC    AL1(44,45,46,48,49,50,52,53,54,56,57,58,60,61,62)  #3
         DC    AL1(64,65,66,68,69,70,72,73,74,76,77,78,80,81,82)  #4
         DC    AL1(84,85,86,88,89,90,92,93,94,96,97,98,100,101,102)  #5
         DC    AL1(104,105,106,108,109,110,112,113,114,116,117,118)  #6
         DC    AL1(120,121,122,124,125,126,128,129,130,132,133,134)  #7
         DC    AL1(136,137,138,140,141,142,144,145,146,148,149,150)  #8
         DC    AL1(152,153,154,156,157,158,160,161,162,164,165,166)  #9
         DC    AL1(168,169,170,172,173,174,176,177,178,180,181,182) #10
         DC    AL1(184,185,186,188,189,190,192,193,194,196,197,198) #11
         DC    AL1(200,201,202,204,205,206,208,209,210,212,213,214) #12
         DC    AL1(216,217,218,220,221,222)                    LAST-#13
***********************************************************************
TBSCANOT DC    64C'FDP2'      STOP ON ANYTHING TRT TABLE
***********************************************************************
INTBLANK EQU   0                   INTERNAL REPRESENTATION OF BLANK
INTASTER EQU   1                   INTERNAL REPRESENTATION OF ASTERISK
MAXREGCH EQU   61                  MAXIMUM INTERNAL REP IN REGULAR SET
INTSTAST EQU   62        INTERNAL REPRESENTATION OF STRING OF ASTERISKS
INTSTBLN EQU   63        INTERNAL REPRESENTATION OF STRING OF BLANKS
***********************************************************************
TBEXTINT EQU   *         TABLE TO TRANSLATE FROM EBCDIC TO SPECIAL CODE
         DC    AL1(064)  INTERNAL REPRESENTATION                00  000
         DC    AL1(065)  INTERNAL REPRESENTATION                01  001
         DC    AL1(066)  INTERNAL REPRESENTATION                02  002
         DC    AL1(067)  INTERNAL REPRESENTATION                03  003
         DC    AL1(068)  INTERNAL REPRESENTATION                04  004
         DC    AL1(069)  INTERNAL REPRESENTATION                05  005
         DC    AL1(070)  INTERNAL REPRESENTATION                06  006
         DC    AL1(071)  INTERNAL REPRESENTATION                07  007
         DC    AL1(072)  INTERNAL REPRESENTATION                08  008
         DC    AL1(073)  INTERNAL REPRESENTATION                09  009
         DC    AL1(074)  INTERNAL REPRESENTATION                0A  010
         DC    AL1(075)  INTERNAL REPRESENTATION                0B  011
         DC    AL1(076)  INTERNAL REPRESENTATION                0C  012
         DC    AL1(077)  INTERNAL REPRESENTATION                0D  013
         DC    AL1(078)  INTERNAL REPRESENTATION                0E  014
         DC    AL1(079)  INTERNAL REPRESENTATION                0F  015
         DC    AL1(080)  INTERNAL REPRESENTATION                10  016
         DC    AL1(081)  INTERNAL REPRESENTATION                11  017
         DC    AL1(082)  INTERNAL REPRESENTATION                12  018
         DC    AL1(083)  INTERNAL REPRESENTATION                13  019
         DC    AL1(084)  INTERNAL REPRESENTATION                14  020
         DC    AL1(085)  INTERNAL REPRESENTATION                15  021
         DC    AL1(086)  INTERNAL REPRESENTATION                16  022
         DC    AL1(087)  INTERNAL REPRESENTATION                17  023
         DC    AL1(088)  INTERNAL REPRESENTATION                18  024
         DC    AL1(089)  INTERNAL REPRESENTATION                19  025
         DC    AL1(090)  INTERNAL REPRESENTATION                1A  026
         DC    AL1(091)  INTERNAL REPRESENTATION                1B  027
         DC    AL1(092)  INTERNAL REPRESENTATION                1C  028
         DC    AL1(093)  INTERNAL REPRESENTATION                1D  029
         DC    AL1(094)  INTERNAL REPRESENTATION                1E  030
         DC    AL1(095)  INTERNAL REPRESENTATION                1F  031
         DC    AL1(096)  INTERNAL REPRESENTATION                20  032
         DC    AL1(097)  INTERNAL REPRESENTATION                21  033
         DC    AL1(098)  INTERNAL REPRESENTATION                22  034
         DC    AL1(099)  INTERNAL REPRESENTATION                23  035
         DC    AL1(100)  INTERNAL REPRESENTATION                24  036
         DC    AL1(101)  INTERNAL REPRESENTATION                25  037
         DC    AL1(102)  INTERNAL REPRESENTATION                26  038
         DC    AL1(103)  INTERNAL REPRESENTATION                27  039
         DC    AL1(104)  INTERNAL REPRESENTATION                28  040
         DC    AL1(105)  INTERNAL REPRESENTATION                29  041
         DC    AL1(106)  INTERNAL REPRESENTATION                2A  042
         DC    AL1(107)  INTERNAL REPRESENTATION                2B  043
         DC    AL1(108)  INTERNAL REPRESENTATION                2C  044
         DC    AL1(109)  INTERNAL REPRESENTATION                2D  045
         DC    AL1(110)  INTERNAL REPRESENTATION                2E  046
         DC    AL1(111)  INTERNAL REPRESENTATION                2F  047
         DC    AL1(112)  INTERNAL REPRESENTATION                30  048
         DC    AL1(113)  INTERNAL REPRESENTATION                31  049
         DC    AL1(114)  INTERNAL REPRESENTATION                32  050
         DC    AL1(115)  INTERNAL REPRESENTATION                33  051
         DC    AL1(116)  INTERNAL REPRESENTATION                34  052
         DC    AL1(117)  INTERNAL REPRESENTATION                35  053
         DC    AL1(118)  INTERNAL REPRESENTATION                36  054
         DC    AL1(119)  INTERNAL REPRESENTATION                37  055
         DC    AL1(120)  INTERNAL REPRESENTATION                38  056
         DC    AL1(121)  INTERNAL REPRESENTATION                39  057
         DC    AL1(122)  INTERNAL REPRESENTATION                3A  058
         DC    AL1(123)  INTERNAL REPRESENTATION                3B  059
         DC    AL1(124)  INTERNAL REPRESENTATION                3C  060
         DC    AL1(125)  INTERNAL REPRESENTATION                3D  061
         DC    AL1(126)  INTERNAL REPRESENTATION                3E  062
         DC    AL1(127)  INTERNAL REPRESENTATION                3F  063
         DC    AL1(000)  INTERNAL REPRESENTATION      BLANK     40  064
         DC    AL1(128)  INTERNAL REPRESENTATION                41  065
         DC    AL1(129)  INTERNAL REPRESENTATION                42  066
         DC    AL1(130)  INTERNAL REPRESENTATION                43  067
         DC    AL1(131)  INTERNAL REPRESENTATION                44  068
         DC    AL1(132)  INTERNAL REPRESENTATION                45  069
         DC    AL1(133)  INTERNAL REPRESENTATION                46  070
         DC    AL1(134)  INTERNAL REPRESENTATION                47  071
         DC    AL1(135)  INTERNAL REPRESENTATION                48  072
         DC    AL1(136)  INTERNAL REPRESENTATION                49  073
         DC    AL1(137)  INTERNAL REPRESENTATION                4A  074
         DC    AL1(002)  INTERNAL REPRESENTATION      .         4B  075
         DC    AL1(003)  INTERNAL REPRESENTATION      <         4C  076
         DC    AL1(004)  INTERNAL REPRESENTATION      (         4D  077
         DC    AL1(005)  INTERNAL REPRESENTATION      +         4E  078
         DC    AL1(006)  INTERNAL REPRESENTATION       (OR)    4F  079
         DC    AL1(007)  INTERNAL REPRESENTATION      &         50  080
         DC    AL1(138)  INTERNAL REPRESENTATION                51  081
         DC    AL1(139)  INTERNAL REPRESENTATION                52  082
         DC    AL1(140)  INTERNAL REPRESENTATION                53  083
         DC    AL1(141)  INTERNAL REPRESENTATION                54  084
         DC    AL1(142)  INTERNAL REPRESENTATION                55  085
         DC    AL1(143)  INTERNAL REPRESENTATION                56  086
         DC    AL1(144)  INTERNAL REPRESENTATION                57  087
         DC    AL1(145)  INTERNAL REPRESENTATION                58  088
         DC    AL1(146)  INTERNAL REPRESENTATION                59  089
         DC    AL1(147)  INTERNAL REPRESENTATION                5A  090
         DC    AL1(008)  INTERNAL REPRESENTATION      $         5B  091
         DC    AL1(001)  INTERNAL REPRESENTATION      *         5C  092
         DC    AL1(009)  INTERNAL REPRESENTATION      )         5D  093
         DC    AL1(010)  INTERNAL REPRESENTATION      ;         5E  094
         DC    AL1(011)  INTERNAL REPRESENTATION      ^         5F  095
         DC    AL1(012)  INTERNAL REPRESENTATION      -         60  096
         DC    AL1(013)  INTERNAL REPRESENTATION      /         61  097
         DC    AL1(148)  INTERNAL REPRESENTATION                62  098
         DC    AL1(149)  INTERNAL REPRESENTATION                63  099
         DC    AL1(150)  INTERNAL REPRESENTATION                64  100
         DC    AL1(151)  INTERNAL REPRESENTATION                65  101
         DC    AL1(152)  INTERNAL REPRESENTATION                66  102
         DC    AL1(153)  INTERNAL REPRESENTATION                67  103
         DC    AL1(154)  INTERNAL REPRESENTATION                68  104
         DC    AL1(155)  INTERNAL REPRESENTATION                69  105
         DC    AL1(156)  INTERNAL REPRESENTATION                6A  106
         DC    AL1(014)  INTERNAL REPRESENTATION      ,         6B  107
         DC    AL1(015)  INTERNAL REPRESENTATION      %         6C  108
         DC    AL1(016)  INTERNAL REPRESENTATION      _         6D  109
         DC    AL1(017)  INTERNAL REPRESENTATION      >         6E  110
         DC    AL1(018)  INTERNAL REPRESENTATION      ?         6F  111
         DC    AL1(157)  INTERNAL REPRESENTATION                70  112
         DC    AL1(158)  INTERNAL REPRESENTATION                71  113
         DC    AL1(159)  INTERNAL REPRESENTATION                72  114
         DC    AL1(160)  INTERNAL REPRESENTATION                73  115
         DC    AL1(161)  INTERNAL REPRESENTATION                74  116
         DC    AL1(162)  INTERNAL REPRESENTATION                75  117
         DC    AL1(163)  INTERNAL REPRESENTATION                76  118
         DC    AL1(164)  INTERNAL REPRESENTATION                77  119
         DC    AL1(165)  INTERNAL REPRESENTATION                78  120
         DC    AL1(166)  INTERNAL REPRESENTATION                79  121
         DC    AL1(019)  INTERNAL REPRESENTATION      :         7A  122
         DC    AL1(020)  INTERNAL REPRESENTATION      #         7B  123
         DC    AL1(021)  INTERNAL REPRESENTATION      @         7C  124
         DC    AL1(022)  INTERNAL REPRESENTATION      '         7D  125
         DC    AL1(023)  INTERNAL REPRESENTATION      =         7E  126
         DC    AL1(024)  INTERNAL REPRESENTATION      "         7F  127
         DC    AL1(167)  INTERNAL REPRESENTATION                80  128
         DC    AL1(168)  INTERNAL REPRESENTATION                81  129
         DC    AL1(169)  INTERNAL REPRESENTATION                82  130
         DC    AL1(170)  INTERNAL REPRESENTATION                83  131
         DC    AL1(171)  INTERNAL REPRESENTATION                84  132
         DC    AL1(172)  INTERNAL REPRESENTATION                85  133
         DC    AL1(173)  INTERNAL REPRESENTATION                86  134
         DC    AL1(174)  INTERNAL REPRESENTATION                87  135
         DC    AL1(175)  INTERNAL REPRESENTATION                88  136
         DC    AL1(176)  INTERNAL REPRESENTATION                89  137
         DC    AL1(177)  INTERNAL REPRESENTATION                8A  138
         DC    AL1(178)  INTERNAL REPRESENTATION                8B  139
         DC    AL1(179)  INTERNAL REPRESENTATION                8C  140
         DC    AL1(180)  INTERNAL REPRESENTATION                8D  141
         DC    AL1(181)  INTERNAL REPRESENTATION                8E  142
         DC    AL1(182)  INTERNAL REPRESENTATION                8F  143
         DC    AL1(183)  INTERNAL REPRESENTATION                90  144
         DC    AL1(184)  INTERNAL REPRESENTATION                91  145
         DC    AL1(185)  INTERNAL REPRESENTATION                92  146
         DC    AL1(186)  INTERNAL REPRESENTATION                93  147
         DC    AL1(187)  INTERNAL REPRESENTATION                94  148
         DC    AL1(188)  INTERNAL REPRESENTATION                95  149
         DC    AL1(189)  INTERNAL REPRESENTATION                96  150
         DC    AL1(190)  INTERNAL REPRESENTATION                97  151
         DC    AL1(191)  INTERNAL REPRESENTATION                98  152
         DC    AL1(192)  INTERNAL REPRESENTATION                99  153
         DC    AL1(193)  INTERNAL REPRESENTATION                9A  154
         DC    AL1(194)  INTERNAL REPRESENTATION                9B  155
         DC    AL1(195)  INTERNAL REPRESENTATION                9C  156
         DC    AL1(196)  INTERNAL REPRESENTATION                9D  157
         DC    AL1(197)  INTERNAL REPRESENTATION                9E  158
         DC    AL1(198)  INTERNAL REPRESENTATION                9F  159
         DC    AL1(199)  INTERNAL REPRESENTATION                A0  160
         DC    AL1(200)  INTERNAL REPRESENTATION                A1  161
         DC    AL1(201)  INTERNAL REPRESENTATION                A2  162
         DC    AL1(202)  INTERNAL REPRESENTATION                A3  163
         DC    AL1(203)  INTERNAL REPRESENTATION                A4  164
         DC    AL1(204)  INTERNAL REPRESENTATION                A5  165
         DC    AL1(205)  INTERNAL REPRESENTATION                A6  166
         DC    AL1(206)  INTERNAL REPRESENTATION                A7  167
         DC    AL1(207)  INTERNAL REPRESENTATION                A8  168
         DC    AL1(208)  INTERNAL REPRESENTATION                A9  169
         DC    AL1(209)  INTERNAL REPRESENTATION                AA  170
         DC    AL1(210)  INTERNAL REPRESENTATION                AB  171
         DC    AL1(211)  INTERNAL REPRESENTATION                AC  172
         DC    AL1(212)  INTERNAL REPRESENTATION                AD  173
         DC    AL1(213)  INTERNAL REPRESENTATION                AE  174
         DC    AL1(214)  INTERNAL REPRESENTATION                AF  175
         DC    AL1(215)  INTERNAL REPRESENTATION                B0  176
         DC    AL1(216)  INTERNAL REPRESENTATION                B1  177
         DC    AL1(217)  INTERNAL REPRESENTATION                B2  178
         DC    AL1(218)  INTERNAL REPRESENTATION                B3  179
         DC    AL1(219)  INTERNAL REPRESENTATION                B4  180
         DC    AL1(220)  INTERNAL REPRESENTATION                B5  181
         DC    AL1(221)  INTERNAL REPRESENTATION                B6  182
         DC    AL1(222)  INTERNAL REPRESENTATION                B7  183
         DC    AL1(223)  INTERNAL REPRESENTATION                B8  184
         DC    AL1(224)  INTERNAL REPRESENTATION                B9  185
         DC    AL1(225)  INTERNAL REPRESENTATION                BA  186
         DC    AL1(226)  INTERNAL REPRESENTATION                BB  187
         DC    AL1(227)  INTERNAL REPRESENTATION                BC  188
         DC    AL1(228)  INTERNAL REPRESENTATION                BD  189
         DC    AL1(229)  INTERNAL REPRESENTATION                BE  190
         DC    AL1(230)  INTERNAL REPRESENTATION                BF  191
         DC    AL1(231)  INTERNAL REPRESENTATION                C0  192
         DC    AL1(025)  INTERNAL REPRESENTATION      A         C1  193
         DC    AL1(026)  INTERNAL REPRESENTATION      B         C2  194
         DC    AL1(027)  INTERNAL REPRESENTATION      C         C3  195
         DC    AL1(028)  INTERNAL REPRESENTATION      D         C4  196
         DC    AL1(029)  INTERNAL REPRESENTATION      E         C5  197
         DC    AL1(030)  INTERNAL REPRESENTATION      F         C6  198
         DC    AL1(031)  INTERNAL REPRESENTATION      G         C7  199
         DC    AL1(032)  INTERNAL REPRESENTATION      H         C8  200
         DC    AL1(033)  INTERNAL REPRESENTATION      I         C9  201
         DC    AL1(232)  INTERNAL REPRESENTATION                CA  202
         DC    AL1(233)  INTERNAL REPRESENTATION                CB  203
         DC    AL1(234)  INTERNAL REPRESENTATION                CC  204
         DC    AL1(235)  INTERNAL REPRESENTATION                CD  205
         DC    AL1(236)  INTERNAL REPRESENTATION                CE  206
         DC    AL1(237)  INTERNAL REPRESENTATION                CF  207
         DC    AL1(238)  INTERNAL REPRESENTATION                D0  208
         DC    AL1(034)  INTERNAL REPRESENTATION      J         D1  209
         DC    AL1(035)  INTERNAL REPRESENTATION      K         D2  210
         DC    AL1(036)  INTERNAL REPRESENTATION      L         D3  211
         DC    AL1(037)  INTERNAL REPRESENTATION      M         D4  212
         DC    AL1(038)  INTERNAL REPRESENTATION      N         D5  213
         DC    AL1(039)  INTERNAL REPRESENTATION      O         D6  214
         DC    AL1(040)  INTERNAL REPRESENTATION      P         D7  215
         DC    AL1(041)  INTERNAL REPRESENTATION      Q         D8  216
         DC    AL1(042)  INTERNAL REPRESENTATION      R         D9  217
         DC    AL1(239)  INTERNAL REPRESENTATION                DA  218
         DC    AL1(240)  INTERNAL REPRESENTATION                DB  219
         DC    AL1(241)  INTERNAL REPRESENTATION                DC  220
         DC    AL1(242)  INTERNAL REPRESENTATION                DD  221
         DC    AL1(243)  INTERNAL REPRESENTATION                DE  222
         DC    AL1(244)  INTERNAL REPRESENTATION                DF  223
         DC    AL1(245)  INTERNAL REPRESENTATION                E0  224
         DC    AL1(246)  INTERNAL REPRESENTATION                E1  225
         DC    AL1(043)  INTERNAL REPRESENTATION      S         E2  226
         DC    AL1(044)  INTERNAL REPRESENTATION      T         E3  227
         DC    AL1(045)  INTERNAL REPRESENTATION      U         E4  228
         DC    AL1(046)  INTERNAL REPRESENTATION      V         E5  229
         DC    AL1(047)  INTERNAL REPRESENTATION      W         E6  230
         DC    AL1(048)  INTERNAL REPRESENTATION      X         E7  231
         DC    AL1(049)  INTERNAL REPRESENTATION      Y         E8  232
         DC    AL1(050)  INTERNAL REPRESENTATION      Z         E9  233
         DC    AL1(247)  INTERNAL REPRESENTATION                EA  234
         DC    AL1(248)  INTERNAL REPRESENTATION                EB  235
         DC    AL1(249)  INTERNAL REPRESENTATION                EC  236
         DC    AL1(250)  INTERNAL REPRESENTATION                ED  237
         DC    AL1(251)  INTERNAL REPRESENTATION                EE  238
         DC    AL1(252)  INTERNAL REPRESENTATION                EF  239
         DC    AL1(051)  INTERNAL REPRESENTATION      0         F0  240
         DC    AL1(052)  INTERNAL REPRESENTATION      1         F1  241
         DC    AL1(053)  INTERNAL REPRESENTATION      2         F2  242
         DC    AL1(054)  INTERNAL REPRESENTATION      3         F3  243
         DC    AL1(055)  INTERNAL REPRESENTATION      4         F4  244
         DC    AL1(056)  INTERNAL REPRESENTATION      5         F5  245
         DC    AL1(057)  INTERNAL REPRESENTATION      6         F6  246
         DC    AL1(058)  INTERNAL REPRESENTATION      7         F7  247
         DC    AL1(059)  INTERNAL REPRESENTATION      8         F8  248
         DC    AL1(060)  INTERNAL REPRESENTATION      9         F9  249
         DC    AL1(253)  INTERNAL REPRESENTATION                FA  250
         DC    AL1(254)  INTERNAL REPRESENTATION                FB  251
         DC    AL1(255)  INTERNAL REPRESENTATION                FC  252
         DC    AL1(062)  INTERNAL REPRESENTATION                FD  253
         DC    AL1(063)  INTERNAL REPRESENTATION                FE  254
         DC    AL1(061)  INTERNAL REPRESENTATION                FF  255
***********************************************************************
TBSCREG1 EQU   *         TABLE TO SEARCH FOR CHARS. W/SPECIAL HANDLING
         DC    AL1(HITBLANK)       BRANCH OFFSET OF BLANKS ROUTINE
         DC    AL1(HITASTER)       BRANCH OFFSET OF ASTERISKS ROUTINE
         DC    (MAXREGCH-1)XL1'00'   TRT NOT STOP ON THESE CHARACTERS
         DC    02AL1(HITNOREG)     BRANCH OFFSET OF UNUSUAL CHAR RTN
         DC    64AL1(HITNOREG)     BRANCH OFFSET OF UNUSUAL CHAR RTN
         DC    64AL1(HITNOREG)     BRANCH OFFSET OF UNUSUAL CHAR RTN
         DC    64AL1(HITNOREG)     BRANCH OFFSET OF UNUSUAL CHAR RTN
***********************************************************************
CURSEQ#R DS    PL5                 CURRENT SEQUENCE NUMBER
WORKSEQ# DC    PL5'0'              WORK SEQUENCE # AREA
***********************************************************************
MOVBYTES MVC   0(0,R3),0(R4)       MOVE CODED BYTES TO OUTPUT WORK AREA
SCANOT   TRT   1(0,R14),TBSCANOT    SCAN FOR NON-REPEATING CHARACTER
MOVETABL MVC   0(0,R1),GATHTABL    MOVE TABLE TO GATHER 3 OF 4
GATH3OF4 TR    0(0,R1),SQUEEZWK    GATHER 3 OUT OF 4 BYTES INTO BUFFER
MVTBLRST MVC   0(0,R1),0(R15)        MOVE TABLE TO GATHER REST
***********************************************************************
***********************************************************************
SQUEEZWD DSECT                USED TO AVOID DIAGNOSTIC
         DS    F              FLOATS OVER SQUEEZWK
***********************************************************************
DECBDSCT DSECT DSECT FOR DECB AND RELATED INFORMATION
         WRITE DUMMY,SF,BPAMOUT,MF=L   SPACE IN DSECT FOR DECB
ODECBUFR EQU   12             OFFSET OF BUFFER ADDRESS IN DECB
AFTBUFAD DC    A(0)           ADDRESS OF LOCATION JUST AFTER BUFFER
***********************************************************************
PASSAREA PASSAREA
         EJECT
***********************************************************************
DCVT     DSECT                FOR MACRO DESCRIBING CVT
         DS    F              NOTHING IN PARTICULAR 8 BYTES BEFORE CVT
CVTRELNO DS    ZL4            RELEASE # BEFORE CVT IN ZONED DECIMAL
         CVT
***********************************************************************
         MVCL  R2,R4               SEE THE BEAUTIFUL 370 INSTRUCTION
         CLCL  R2,R4               SEE THE BEAUTIFUL 370 INSTRUCTION
         ICM   R15,8,20(R13)       SEE THE BEAUTIFUL 370 INSTRUCTION
         STCM  R1,X'E',0(R15)      SEE THE BEAUTIFUL 370 INSTRUCTION
***********************************************************************
         EJECT
***********************************************************************
         DCBD  DSORG=QS,DEVD=DA    DUMMY SECTION FOR DCB FIELDS
***********************************************************************
OOFLGS   EQU   DCBOFLGS-IHADCB     OFFSET IN DCB OF DCBOFLGS
ORECFM   EQU   DCBRECFM-IHADCB     OFFSET IN DCB OF RECORD FORMAT
OBLKSI   EQU   DCBBLKSI-IHADCB     OFFSET IN DCB OF BLOCK SIZE
OLRECL   EQU   DCBLRECL-IHADCB     OFFSET IN DCB OF RECORD LENGTH
***********************************************************************
         END
