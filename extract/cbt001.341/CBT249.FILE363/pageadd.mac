         TITLE 'PAGEADD - MODULE COMMENTARY'
         SPACE 3
*
*
***************************************************************
*                                                             *
*        NAME      .PAGEADD VERSION 05.04                     *
*                                                             *
*        FUNCTION/ .BASED ON TESTS FOR SMF SYSTEM ID,         *
*        PURPOSE    EXECUTION DATE, DAY OF WEEK, AND TIME OF  *
*                   DAY, TO ISSUE OPERATOR COMMANDS           *
*                   AT A SPECIFIED TIME OF DAY, OR            *
*                   AFTER A DESIRED TIME INTERVAL HAS EXPIRED.*
*                                                             *
*        MAJOR     .TO ACTIVATE DRUM PAGING DATA SETS AFTER   *
*        USES       AN IPL HAS COMPLETED(THUS THE NAME        *
*                   PAGEADD).                                 *
*                  .TO DIRECT THE OUTPUT OF DISPLAY COMMANDS  *
*                   NOT SUPPORTING AN "L=" OPERAND,           *
*                   PARTICULARLY VTAM COMMANDS, TO A HARD     *
*                   COPY CONSOLE.                             *
*                  .TO EXECUTE LISTS OF COMMANDS SETTING UP   *
*                   INITIATOR CLASS PATTERNS AND SRM DOMAIN   *
*                   MULTIPROGRAMMING LEVELS FOR DIFFERENT     *
*                   TIMES OF THE DAY.                         *
*                  .TO SET A RETURN CODE BASED ON THE TESTS   *
*                   FOR SYSTEM ID, DATE, DAY OF WEEK, AND     *
*                   TIME OF DAY WHICH CAN BE TESTED BY THE    *
*                   COND PARAMETER IN OTHER STEPS OF A JOB.   *
*                                                             *
*        INPUT     .A CARD IMAGE DATA SET (OPTIONAL)          *
*                   POINTED TO BY THE SYSIN DD STATEMENT.     *
*                  .A CARD IMAGE DATA SET (OPTIONAL)          *
*                   POINTED TO BY THE SYSPARM DD STATEMENT.   *
*                                                             *
*        ENTRY     .PAGEADD                                   *
*                                                             *
*        OUTPUT    .OPERATOR COMMANDS ISSUED DIRECTLY         *
*                   TO THE OPERATING SYSTEM                   *
*                  .OPERATOR MESSAGES LISTING THE COMMANDS    *
*                   THAT ARE TO BE ISSUED.                    *
*                  .SYSPRINT DATA SET LISTING OF THE MESSAGES *
*                   AND COMMANDS THAT WERE ISSUED.            *
*                                                             *
*        RETURN    .00   SUCCESSFUL COMPLETION.               *
*        CODES     .04   PROGRAM INVOKED OUTSIDE              *
*                        SID/DATE/DOW/TIME RANGE.             *
*                  .08   PARAMETER VALUE OF "CANCEL"          *
*                        SPECIFIED.                           *
*                  .12   NO OPERATOR COMMANDS FOUND IN SYSIN  *
*                        ("INPUT" SPECIFIED OR DEFAULTED, AND *
*                        "CMDS" SPECIFIED OR DEFAULTED).      *
*                  .16   UNABLE TO OPEN -SYSIN-               *
*                        ("INPUT" SPECIFIED OR DEFAULTED),    *
*                        OR UNABLE TO OPEN -SYSPARM-          *
*                        ("PARMDD" SPECIFIED).                *
*                  .20   UNABLE TO OPEN -SYSPRINT-.           *
*                                                             *
*        MODULE    .RENT,REUS,REFR,READ-ONLY,AC(1),           *
*        ATTRIBUTES        AMODE(24),RMODE(24).               *
*                                                             *
*        UPDATE HISTORY                                       *
*                  .UPDATED FOR MVS/XA TO:                    *
*                      -USE THE "RU" FORM OF GETMAIN &        *
*                       FREEMAIN TO FACILITATE CONVERSION     *
*                       TO 31-BIT ADDRESSING LATER ON;        *
*                      -PROCESS THE WTOR PARAMETER LIST       *
*                       ASSUMING THE 31-BIT FORMAT FOR MVS/XA *
*                       HAS BEEN USED;                        *
*                      -USE BAS/BASR INSTRUCTIONS RATHER      *
*                       THAN BAL/BALR;                        *
*                      -CHANGE SEVERAL "LA" INSTRUCTIONS      *
*                       TO "A" INSTRUCTIONS;                  *
*                      -ADD ASSEMBLER AMODE/RMODE             *
*                       SPECIFICATIONS.                       *
*                                                04/02/84  TJA*
*                                                             *
*                                                             *
*        FACILITIES/FEATURES                                  *
*                                                             *
*               THIS PROGRAM ISSUES MVS AND JES OPERATOR      *
*        COMMANDS DIRECTLY TO THE SYSTEM USING THE SVC 34     *
*        INTERFACE.  IT CAN BE USED FOR EXECUTING A STREAM OF *
*        OPERATOR COMMANDS AFTER A SPECIFIED TIME PERIOD HAS  *
*        ELAPSED FOLLOWING THE COMPLETION OF IPL.  IT CAN     *
*        ALSO BE USED TO PROVIDE THE OPERATOR WITH A CONCISE  *
*        AND CONVENIENT WAY OF EXECUTING A STREAM OF          *
*        COMMANDS.  THE COMMANDS TO BE EXECUTED ARE READ FROM *
*        THE "SYSIN" DATA SET.  CONTROL OF PROGRAM EXECUTION  *
*        IS BY MEANS OF DEFAULT VALUES HARD CODED INTO THE    *
*        PROGRAM; THE PARM FIELD OF THE EXEC STATEMENT; THE   *
*        CONTENTS OF THE "SYSPARM" DATA SET; AND BY THE       *
*        OPERATOR RESPONSE TO THE PROMPT MESSAGE IF PROMPTING *
*        HAS BEEN ACTIVATED IN EITHER THE EXEC STATEMENT PARM *
*        FIELD OR THE "SYSPARM" DATA SET.  EXECUTION-TIME     *
*        DOCUMENTATION IS PROVIDED BY MESSAGES IN THE         *
*        "SYSPRINT" DATA SET.                                 *
*                                                             *
*                                                             *
*               THE OPERATOR COMMANDS TO BE EXECUTED ARE READ *
*        FROM THE DATA SET DEFINED BY THE "SYSIN" DD          *
*        STATEMENT.  THE PROGRAM HAS HARDCODED SYSIN DCB      *
*        ATTRIBUTES OF RECFM=FB,LRECL=80 BECAUSE IT IS        *
*        ASSUMED THAT THE COMMANDS TO BE EXECUTED WILL HAVE   *
*        BEEN PLACED IN A PARMLIB, PROCLIB, CARD IMAGE        *
*        TEMPORARY, OR INPUT STREAM DATA SET.  THE DCB        *
*        BLKSIZE VALUE IS NOT HARD CODED, AND IS TAKEN FROM   *
*        THE JCL OR DATA SET LABEL.  IF FOR SOME REASON, A    *
*        BLOCK SIZE VALUE HAS NOT BEEN PROVIDED BY ANY        *
*        SOURCE, THE PROGRAM SUPPLIES A DEFAULT VALUE OF      *
*        BLKSIZE=80 FOR SYSIN USING A DCB OPEN EXIT.          *
*                                                             *
*                                                             *
*               FOUR TYPES OF INPUT RECORDS ARE RECOGNIZED IN *
*        THE SYSIN DATA SET BY THE PROGRAM.....               *
*                                                             *
*               .COMMENT RECORDS.  A COMMENT RECORD IS ANY    *
*                RECORD WITH AN "*" IN BYTE 01.  THESE        *
*                RECORDS ARE BYPASSED WITHOUT PROCESSING AND  *
*                NO ATTEMPT IS MADE TO EXECUTE THEM.          *
*                                                             *
*               .JCL-TYPE COMMAND RECORDS.  ANY RECORD HAVING *
*                A "/*" OR "//" IN ITS FIRST TWO BYTES IS     *
*                CONSIDERED A JCL-TYPE COMMAND RECORD. THE    *
*                COMMAND IS ASSUMED TO BEGIN IN BYTE 03 OF    *
*                THE RECORD AND EXTEND THROUGH BYTE 72 IF     *
*                "SEQ" WAS SPECIFIED, OR THROUGH BYTE 80 IF   *
*                "NOSEQ" WAS SPECIFIED.                       *
*                                                             *
*               .CONSOLE-DIRECTED COMMAND RECORDS.  ANY       *
*                RECORD CONTAINING THE CHARACTER STRING       *
*                "CN(##)" IN BYTES 01-06 WHERE "##" IS EITHER *
*                "**", "MC", OR A NUMERIC VALUE 00-99, IS     *
*                CONSIDERED TO BE A CONSOLE-DIRECTED RECORD.  *
*                THE COMMAND IS ASSUMED TO BEGIN IN BYTE 07   *
*                OF THE RECORD AND EXTEND THROUGH BYTE 72 IF  *
*                "SEQ" WAS SPECIFIED, OR THROUGH BYTE 80 IF   *
*                "NOSEQ" WAS SPECIFIED.  A "##" VALUE OF "MC" *
*                DESIGNATES THE MASTER CONSOLE, AND A "##"    *
*                VALUE OF "**" DESIGNATES THE START COMMAND   *
*                CONSOLE IF PAGEADD WAS STARTED FROM A        *
*                CONSOLE (IF PAGEADD WAS NOT STARTED FROM A   *
*                CONSOLE, "**" DEFAULTS TO "MC").  THE "##",  *
*                WHEN NUMERIC, IS THE UCM CONSOLE NUMBER AND  *
*                CORRESPONDS TO THE CONSOLE NUMBER AS SHOWN   *
*                BY THE "D C" MVS COMMAND.  IT OVERRIDES, FOR *
*                THIS COMMAND ONLY, THE CONSOLE DESIGNATED BY *
*                DEFAULT(**) OR BY THE PARM FIELD "CN="       *
*                PARAMETER.                                   *
*                                                             *
*               .AS-IS COMMAND RECORDS.  ANY RECORD NOT       *
*                RECOGNIZED BY THE PROGRAM AS ONE OF THE      *
*                PRECEEDING RECORD TYPES IS CONSIDERED TO BE  *
*                AN AS-IS COMMAND RECORD.  THE COMMAND IS     *
*                ASSUMED TO BEGIN IN BYTE 01 OF THE RECORD    *
*                AND EXTEND THROUGH BYTE 72 OF THE RECORD IF  *
*                "SEQ" WAS SPECIFIED, OR THROUGH BYTE 80 IF   *
*                "NOSEQ" WAS SPECIFIED.                       *
*                                                             *
*                                                             *
*               CONTROL OF PROGRAM EXECUTION IS PROVIDED BY   *
*        MEANS OF HARD CODED DEFAULT VALUES, THE PARM FIELD   *
*        OF THE EXEC STATEMENT, AND THE SYSPARM DATA SET.     *
*        THE SYSPARM DATA SET PROVIDES A MEANS OF SPECIFYING  *
*        EXTENSIVE DATE AND SYSTEM ID LISTS THAT COULD NOT BE *
*        CONTAINED IN THE 100 CHARACTER EXEC STATEMENT PARM   *
*        FIELD.  IT ALSO PROVIDES A WAY OF SPECIFYING A VALUE *
*        (E.G., A SYSTEM ID) TO A LARGE NUMBER OF PROCEDURES, *
*        AND OF ALLOWING THAT VALUE TO BE CHANGED WITHOUT     *
*        UPDATING ALL OF THE AFFECTED PROCEDURES.  THE        *
*        PROGRAM HAS HARDCODED SYSPARM DCB ATTRIBUTES OF      *
*        RECFM=FB,LRECL=80, BECAUSE IT IS ASSUMED THAT THE    *
*        PARM DATA WILL RESIDE IN A PARMLIB, PROCLIB, CARD    *
*        IMAGE TEMPORARY, OR INPUT STREAM DATA SET.  THE DCB  *
*        BLKSIZE VALUE IS NOT HARD CODED, AND IS TAKEN FROM   *
*        THE JCL OR DATA SET LABEL.  IF FOR SOME REASON A     *
*        BLOCK SIZE VALUE HAS NOT BEEN PROVIDED, BY ANY       *
*        SOURCE, THE PROGRAM SUPPLIES A DEFAULT VALUE OF      *
*        BLKSIZE=80 FOR SYSPARM USING A DCB OPEN EXIT.        *
*                                                             *
*                                                             *
*               THE EXEC STATEMENT PARM FIELD IS PROCESSED    *
*        BEFORE THE SYSPARM DATA SET.  THUS VALUES SPECIFIED  *
*        VIA SYSPARM WILL OVERRIDE THOSE IN THE EXEC          *
*        STATEMENT PARM FIELD.  TWO TYPES OF INPUT RECORDS    *
*        ARE RECOGNIZED IN SYSPARM.....                       *
*                                                             *
*               .COMMENT RECORDS.  A COMMENT RECORD IS ANY    *
*                RECORD WITH AN "*" IN BYTE 01.  THESE        *
*                RECORDS ARE BYPASSED WITHOUT PROCESSING AND  *
*                NO ATTEMPT IS MADE TO EVALUATE THEM.         *
*                                                             *
*               .PARAMETER SPECIFICATION RECORDS.  ANY RECORD *
*                LACKING AN "*" IN BYTE 01 IS PROCESSED AS A  *
*                PARAMETER SPECIFICATION RECORD.  THE         *
*                PARAMETER STRING EXTENDS FROM THE FIRST      *
*                NON-BLANK RECORD BYTE THROUGH BYTE 72 IF     *
*                "SEQ" IS SPECIFIED, OR THROUGH BYTE 80 IF    *
*                "NOSEQ" IS SPECIFIED.  NOTE THAT "SEQ" AND   *
*                "NOSEQ" CAN BE SPECIFIED IN SYSPARM RECORDS, *
*                ALLOWING THE USER TO SWITCH BACK AND FORTH   *
*                AT WILL.                                     *
*                                                             *
*        PROCESSING OF THE SYSPARM DATA SET IS ACTIVATED BY A *
*        SPECIFICATION OF "PARMDD" IN THE EXEC STATEMENT PARM *
*        FIELD.  THE PROGRAM DEFAULTS TO "NOPARMDD" IN ORDER  *
*        TO PROVIDE COMPATIBILITY WITH EARLIER VERSIONS OF    *
*        THE PROGRAM; WITH "NOPARMDD", THE SYSPARM DATA SET   *
*        IS NOT OPENED, AND NO ATTEMPT IS MADE TO PROCESS IT. *
*                                                             *
*                                                             *
*               THE PARM STRING IN THE EXEC STATEMENT PARM    *
*        FIELD AND IN EACH SYSPARM PARAMETER SPECIFICATION    *
*        RECORD BEGINS AT THE FIRST NON-BLANK CHARACTER, AND  *
*        EXTENDS TO THE END OF THE FIELD OR RECORD, OR TO THE *
*        FIRST BLANK ENCOUNTERED; A COMPLETELY BLANK FIELD OR *
*        RECORD RESULTS IN NO PROCESSING.  THE SYNTAX IS      *
*        JCL-LIKE.  KEYWORDS SPECIFY VALUES, COMMAS ARE USED  *
*        AS SEPARATORS, AND EMBEDDED BLANKS ARE NOT ALLOWED   *
*        UNLESS ENCLOSED IN QUOTES.  SOME KEYWORDS SPECIFY    *
*        SWITCH SETTINGS RATHER THAN VALUES; THESE KEYWORDS   *
*        (E.G., MSG/NOMSG) ARE NOT FOLLOWED BY "=".  KEYWORDS *
*        CAN BE SPECIFIED IN ANY ORDER.  THE PARM FIELD       *
*        KEYWORDS THAT CAN BE SPECIFIED, ALONG WITH A         *
*        DESCRIPTION OF THEIR FUNCTION AND DEFAULT VALUES ARE *
*        AS FOLLOWS.....                                      *
*                                                             *
*               ."PARMDD" AND "NOPARMDD".  THESE PARAMETERS   *
*                TELL THE PROGRAM WHETHER TO PROCESS THE      *
*                SYSPARM DATA SET.  "PARMDD" DIRECTS THE      *
*                PROGRAM TO OPEN THE SYSPARM DATA SET AND     *
*                PROCESS PARAMETER STRING SPECIFICATIONS FROM *
*                IT.  "NOPARMDD" DIRECTS THE PROGRAM TO SKIP  *
*                PROCESSING OF THE SYSPARM DATA SET.  IN      *
*                ORDER TO PROVIDE COMPATIBILITY WITH EARLIER  *
*                VERSIONS OF THE PROGRAM, THE PROGRAM DEFAULT *
*                VALUE IS "NOPARMDD".  "PARMDD" AND           *
*                "NOPARMDD" ARE EFFECTIVE ONLY WHEN SPECIFIED *
*                IN THE EXEC STATEMENT PARM FIELD.  THEY CAN  *
*                BE SPECIFIED WITHOUT ERROR IN SYSPARM        *
*                PARAMETER SPECIFICATION RECORDS, BUT WILL    *
*                CAUSE NO ACTION IF SPECIFIED THERE.          *
*                                                             *
*               ."PROMPT" AND "NOPROMPT".  THESE PARAMETERS   *
*                TELL THE PROGRAM WHETHER TO PROMPT THE       *
*                OPERATOR FOR ADDITIONAL PARAMETER            *
*                SPECIFICATIONS AFTER THE EXEC STATEMENT PARM *
*                FIELD AND (OPTIONALLY) THE SYSPARM DATA SET  *
*                HAVE BEEN PROCESSED.  "PROMPT" DIRECTS THE   *
*                PROGRAM TO PROMPT THE OPERATOR; "NOPROMPT"   *
*                CAUSES OPERATOR PROMPTING TO BE SKIPPED.     *
*                "PROMPT" CAN BE SPECIFIED IN EITHER THE EXEC *
*                STATEMENT PARM FIELD OR THE SYSPARM DATA     *
*                SET.  WHEN "PROMPT" HAS BEEN SPECIFIED,      *
*                MESSAGE "IEFPGD19" IS ISSUED ASKING THE      *
*                OPERATOR TO RESPOND WITH ADDITIONAL          *
*                PARAMETERS, "CANCEL", OR "GO".  THIS MESSAGE *
*                IS ISSUED BEFORE THE THE DELAY INTERVAL IN   *
*                ORDER TO ALLOW THE INTERVAL TO BE            *
*                RESPECIFIED.  A SPECIFICATION OF "GO" CAUSES *
*                PROMPTING TO BE TURNED OFF, AND ALLOWS THE   *
*                DELAY INTERVAL TO PROCEED AND COMMANDS TO BE *
*                PROCESSED.  A SPECIFICATION OF "CANCEL"      *
*                CAUSES PROMPTING TO BE TURNED OFF, AND THE   *
*                PROGRAM PROCEEDS IMMEDIATELY TO TERMINATION  *
*                WITHOUT PROCESSING THE DELAY INTERVAL OR     *
*                OPERATOR COMMANDS.  A SPECIFICATION OF       *
*                "NOPROMPT" TURNS OFF PROMPTING, BUT DOES NOT *
*                AFFECT THE STATE OF THE GO/CANCEL INDICATOR; *
*                THUS IF THE OPERATOR REPLIES "NOPROMPT", A   *
*                PRIOR SPECIFICATION OF "CANCEL" (IF PRESENT) *
*                IS PROCESSED.  WHEN THE OPERATOR REPLY       *
*                CONTAINS NEITHER "GO", "CANCEL", OR          *
*                "NOPROMPT", THE PROMPTING INDICATOR IS LEFT  *
*                ON, AND THE PROGRAM PROCEEDS TO THE DELAY    *
*                INTERVAL.  IF PROMPTING IS ON AFTER THE      *
*                DELAY INTERVAL HAS BEEN PROCESSED, THE DELAY *
*                INTERVAL SPECIFICATION IS RESET TO "DELAY=0" *
*                TO AVOID A DOUBLE WAIT, AND THE PROGRAM GOES *
*                BACK AND REANALYZES THE EXECUTION            *
*                ENVIRONMENT.  IF COMMAND EXECUTION IS STILL  *
*                VALID AFTER THE DELAY INTERVAL HAS EXPIRED,  *
*                THE OPERATOR IS PROMPTED AGAIN.  THE         *
*                OPERATOR PROMPTING IS REPEATED UNTIL A REPLY *
*                CONTAINING "GO", "CANCEL", OR "NOPROMPT" IS  *
*                PROVIDED, OR UNTIL THE EXECUTION ENVIRONMENT *
*                IS NO LONGER SUITABLE (TIME-OF-DAY LATER     *
*                THAN AFTER= TIME FOR EXAMPLE).               *
*                                                             *
*               ."CANCEL" AND "GO".  THESE PARAMETERS ARE     *
*                DESIGNED FOR USE MAINLY WITH THE PROMPTING   *
*                FEATURE DESCRIBED UNDER "PROMPT" AND         *
*                "NOPROMPT" ABOVE.  A SPECIFICATION OF "GO"   *
*                CAUSES PROMPTING TO BE TURNED OFF, AND       *
*                ALLOWS THE DELAY INTERVAL TO PROCEED AND     *
*                COMMANDS TO BE PROCESSED.  A SPECIFICATION   *
*                OF "CANCEL" CAUSES PROMPTING TO BE TURNED    *
*                OFF, AND THE PROGRAM PROCEEDS IMMEDIATELY TO *
*                TERMINATION WITHOUT PROCESSING THE DELAY     *
*                INTERVAL OR OPERATOR COMMANDS.  THE PROGRAM  *
*                DEFAULT VALUE IS "GO" IN ORDER TO REQUIRE    *
*                EXPLICIT CANCELLATION OF COMMAND EXECUTION.  *
*                                                             *
*               ."DELAY=".  THIS KEYWORD VALUE TELLS THE      *
*                PROGRAM HOW LONG TO WAIT BEFORE ISSUING      *
*                COMMANDS.  THE WAIT INTERVAL BEGINS AFTER    *
*                BOTH THE SYSPARM AND SYSIN DATA SETS HAVE    *
*                BEEN PROCESSED.  THE PROGRAM'S DEFAULT DELAY *
*                VALUE IS 00:00:00.00; I.E., THE PROGRAM DOES *
*                NOT WAIT FOR A SPECIFIED TIME INTERVAL       *
*                BEFORE PROCESSING COMMANDS.  THE SYNTAX FOR  *
*                THE "DELAY=" KEYWORD IS AS FOLLOWS.....      *
*                                                             *
*                   DELAY=VALUE1                              *
*                   DELAY=(VALUE1)                            *
*                   DELAY=(VALUE2,VALUE3)                     *
*                   DELAY=(,VALUE3)                           *
*                WHERE VALUE1 CAN HAVE THE FORMS...           *
*                   MM                                        *
*                   HH.MM         OR  HH:MM                   *
*                   HH.MM.SS      OR  HH:MM:SS                *
*                   HH.MM.SS.TH   OR  HH:MM:SS.TH             *
*                 VALUE2 CAN HAVE THE FORMS...                *
*                   MM                                        *
*                   HH.MM         OR  HH:MM                   *
*                 VALUE3 CAN HAVE THE FORMS...                *
*                   SS                                        *
*                   SS.TH                                     *
*                                                             *
*               ."TOD=".  THIS KEYWORD TELLS THE PROGRAM TO   *
*                ISSUE THE COMANDS AT A SPECIFIC TIME OF DAY. *
*                IF THE SPECIFIED TIME OF DAY HAS ALREADY     *
*                PASSED, THE COMMANDS ARE ISSUED IMMEDIATELY  *
*                RATHER THAN WAITING FOR THE FOLLOWING DAY.   *
*                THE "TOD=" KEYWORD HAS NO DEFAULT, AND IS    *
*                INCOMPATIBLE WITH "DELAY=".  IF "TOD=" IS    *
*                SPECIFIED, ITS VALUE OVERRIDES "DELAY=" AND  *
*                THE DEFAULT DELAY INTERVAL.  IF BOTH "TOD="  *
*                AND "DELAY=" APPEAR IN PARM STRINGS, THE     *
*                LAST ONE PROCESSED DETERMINES PROGRAM        *
*                ACTION.  THE SYNTAX FOR "TOD=" IS THE SAME   *
*                AS THAT FOR "DELAY=".                        *
*                                                             *
*               ."BEFORE=".  THIS KEYWORD TELLS THE PROGRAM   *
*                NOT TO ISSUE COMMANDS IF THE EXECUTION TIME  *
*                OF DAY IS EARLIER THAN THE VALUE SPECIFIED   *
*                FOR THIS KEYWORD.  THE DEFAULT VALUE IS      *
*                00.00.00.00 WHICH EFFECTIVELY NOP'S THE TEST *
*                FOR AN EARLIEST TIME OF DAY.  THE SYNTAX FOR *
*                THIS KEYWORD IS THE SAME AS THAT FOR         *
*                "DELAY=".                                    *
*                                                             *
*               ."AFTER=".  THIS KEYWORD TELLS THE PROGRAM    *
*                NOT TO ISSUE COMMANDS IF THE EXECUTION TIME  *
*                OF DAY IS EQUAL TO OR GREATER THAN THE VALUE *
*                SPECIFIED FOR THIS KEYWORD.  THE DEFAULT     *
*                VALUE IS 24.00.00.00 WHICH EFFECTIVELY NOP'S *
*                THE TEST FOR A LATEST TIME OF DAY.  THE      *
*                SYNTAX FOR THIS KEYWORD IS THE SAME AS THAT  *
*                FOR "DELAY=".                                *
*                                                             *
*               ."DOW=".  THIS KEYWORD TELLS THE PROGRAM NOT  *
*                TO ISSUE COMMANDS IF THE EXECUTION DAY OF    *
*                THE WEEK IS NOT ONE OF THE ONES LISTED. FOR  *
*                SPECIFYING THIS KEYWORD VALUE THE DAYS OF    *
*                THE WEEK ARE ASSIGNED DIGITS "0 - 6" WHERE   *
*                "0" CORRESPONDS TO SUNDAY AND "6" TO         *
*                SATURDAY.  THE VALUE SUPPLIED FOR THIS       *
*                KEYWORD IS A NUMERIC CHARACTER STRING WHOSE  *
*                DIGITS SPECIFY THE DAYS OF THE WEEK.  THE    *
*                DEFAULT VALUE IS 0123456 WHICH SPECIFIES ALL *
*                DAYS OF THE WEEK AND EFFECTIVELY NOP'S THE   *
*                TEST FOR DAY OF THE WEEK.  FOR EXAMPLE,      *
*                MONDAY THROUGH FRIDAY WOULD BE SPECIFIED AS  *
*                "DOW=12345".  THE DIGITS CAN BE SPECIFIED IN *
*                ANY ORDER, AND DIGITS OTHER THAN 0-6 ARE     *
*                IGNORED.  THE "DOW=" KEYWORD ALSO SUPPLIES   *
*                THE "DOWA=" AND "DOWB=" VALUES AND OVERRIDES *
*                THEIR VALUES IF THEY ARE PROCESSED PRIOR TO  *
*                "DOW=".  THE DAY OF WEEK VALUES SPECIFIED    *
*                VIA THE "DOW=" KEYWORD ARE USED WHEN THE     *
*                "BEFORE=" TIME IS LESS THAN OR EQUAL TO THE  *
*                "AFTER=" TIME, AND APPLY TO THE TIME         *
*                INTERVAL BETWEEN THE "BEFORE=" TIME AND THE  *
*                "AFTER=" TIME.                               *
*                                                             *
*               ."DOWA=".  THIS KEYWORD TELLS THE PROGRAM NOT *
*                TO ISSUE COMMANDS IF THE CURRENT DAY OF THE  *
*                WEEK IS NOT ONE OF THE ONES LISTED; THE DAY  *
*                OF WEEK VALUES SPECIFIED VIA THIS KEYWORD    *
*                ARE USED WHEN THE "AFTER=" TIME IS LESS THAN *
*                THE "BEFORE=" TIME, AND APPLY TO THE TIME    *
*                INTERVAL BETWEEN 00:00:00.00 AND THE         *
*                "AFTER=" TIME.                               *
*                                                             *
*               ."DOWB=".  THIS KEYWORD TELLS THE PROGRAM NOT *
*                TO ISSUE COMMANDS IF THE CURRENT DAY OF THE  *
*                WEEK IS NOT ONE OF THE ONES LISTED; THE DAY  *
*                OF WEEK VALUES SPECIFIED VIA THIS KEYWORD    *
*                ARE USED WHEN THE "AFTER=" TIME IS LESS THAN *
*                THE "BEFORE=" TIME, AND APPLY TO THE TIME    *
*                INTERVAL BETWEEN THE "BEFORE=" TIME AND      *
*                24:00:00.00.                                 *
*                                                             *
*               ."SID=".  THIS KEYWORD TELLS THE PROGRAM NOT  *
*                TO ISSUE COMMANDS IF THE SMF IDENTIFIER OF   *
*                THE SYSTEM ON WHICH THE PROGRAM IS RUNNING   *
*                IS NOT ONE OF THE SYSTEM IDENTIFIERS LISTED. *
*                THE SYNTAX OF THE "SID=" KEYWORD IS AS       *
*                FOLLOWS.....                                 *
*                                                             *
*                    SID=VALUE                                *
*                    SID=(VALUE)                              *
*                    SID=(VALUE1,VALUE2,...)                  *
*                                                             *
*                WHERE EACH "VALUE" OR "VALUEN" IS A 1-4      *
*                CHARACTER SMF IDENTIFIER.  THE "SID="        *
*                KEYWORD SPECIFIES AN INCLUSION LIST;         *
*                COMMANDS WILL BE ISSUED ONLY ON THOSE        *
*                SYSTEMS LISTED.  THE PROGRAM HAS NO DEFAULT  *
*                FOR THIS PARAMETER, AND THIS PARAMETER IS    *
*                INCOMPATIBLE WITH THE "SIDX=" PARAMETER (SEE *
*                BELOW).  IT AUGMENTS ANY PREVIOUSLY          *
*                PROCESSED "SID=" PARAMETER, AND OVERRIDES    *
*                ANY "SIDX=" PARAMETER PROCESSED BEFORE IT IN *
*                THE SYSPARM DATA SET OR PARM FIELD,          *
*                NULLIFYING ITS LIST.                         *
*                                                             *
*               ."SIDX=".  THIS KEYWORD TELLS THE PROGRAM NOT *
*                TO ISSUE COMMANDS IF THE SMF IDENTIFIER OF   *
*                THE SYSTEM ON WHICH THE PROGRAM IS RUNNING   *
*                IS ONE OF THE SYSTEM IDENTIFIERS LISTED.     *
*                THE SYNTAX OF THE "SIDX=" KEYWORD IS AS      *
*                FOLLOWS.....                                 *
*                                                             *
*                    SIDX=VALUE                               *
*                    SIDX=(VALUE)                             *
*                    SIDX=(VALUE1,VALUE2,...)                 *
*                                                             *
*                WHERE EACH "VALUE" OR "VALUEN" IS A 1-4      *
*                CHARACTER SMF IDENTIFIER.  THE "SIDX="       *
*                KEYWORD SPECIFIES AN EXCLUSION LIST;         *
*                COMMANDS WILL BE ISSUED ONLY ON THOSE        *
*                SYSTEMS NOT LISTED.  THE PROGRAM DEFAULTS TO *
*                "SIDX=" SPECIFYING A NULL VALUE LIST; I.E.,  *
*                COMMANDS CAN BE ISSUED ON ALL SYSTEMS.  THIS *
*                PARAMETER IS INCOMPATIBLE WITH THE "SID="    *
*                PARAMETER (SEE ABOVE).  IT AUGMENTS ANY      *
*                PREVIOUSLY PROCESSED "SIDX=" PARAMETER, AND  *
*                OVERRIDES ANY "SID=" PARAMETER PROCESSED     *
*                BEFORE IT IN THE SYSPARM DATA SET OR PARM    *
*                FIELD, NULLIFYING ITS LIST.                  *
*                                                             *
*               ."DOY=" OR "MDY=".  THESE KEYWORDS TELL THE   *
*                PROGRAM TO PROCESS COMMANDS ONLY IF THE      *
*                EXECUTION DATE (TODAY'S DATE) IS ONE OF THE  *
*                DATES LISTED.  "DOY=" IS USED TO SPECIFY     *
*                DATES IN YY.DDD FORMAT, AND "MDY=" IS USED   *
*                TO SPECIFY DATES IN MM/DD/YY FORMAT.  THE    *
*                SYNTAX OF THE "DOY=" KEYWORD IS AS           *
*                FOLLOWS.....                                 *
*                                                             *
*                    DOY=VALUE                                *
*                    DOY=(VALUE)                              *
*                    DOY=(VALUE1,VALUE2,...)                  *
*                                                             *
*                WHERE EACH "VALUE" OR "VALUEN" IS A JULIAN   *
*                DATE HAVING THE FORM "YYDDD" OR "YY.DDD"     *
*                WHERE "YY" IS THE LAST TWO DIGITS OF THE     *
*                YEAR, AND "DDD" IS THE DAY OF THE YEAR.  THE *
*                SYNTAX OF THE "MDY=" KEYWORD IS AS           *
*                FOLLOWS.....                                 *
*                                                             *
*                    MDY=VALUE                                *
*                    MDY=(VALUE)                              *
*                    MDY=(VALUE1,VALUE2,...)                  *
*                                                             *
*                WHERE EACH "VALUE" OR "VALUEN" IS A          *
*                GREGORIAN DATE HAVING THE FORM "MMDDYY" OR   *
*                "MM/DD/YY" WHERE "MM" IS THE MONTH, "DD" IS  *
*                THE DAY OF THE MONTH, AND "YY" IS THE LAST   *
*                TWO DIGITS OF THE YEAR.  THE KEYWORDS CAN BE *
*                USED INTERCHANGEABLY, AND EITHER KEYWORD     *
*                SPECIFIES AN INCLUSION LIST; COMMANDS WILL   *
*                BE PROCESSED ONLY WHEN TODAY'S DATE MATCHES  *
*                ONE OF THE DATES LISTED.  THE PROGRAM HAS NO *
*                DEFAULT DATE INCLUSION LIST, AND THESE       *
*                KEYWORDS ARE INCOMPATIBLE WITH THE "DOYX="   *
*                AND "MDYX=" KEYWORDS (SEE BELOW).  IF MORE   *
*                THAN ONE "DOY=" OR "MDY=" KEYWORD IS         *
*                PROCESSED, THE FINAL LIST OF DATES USED IS   *
*                BASED ON ALL OF THE DATES SPECIFIED WITH     *
*                DUPLICATES ELIMINATED.  "DOY=" OR "MDY="     *
*                OVERRIDES ANY "DOYX=" OR "MDYX=" KEYWORD(S)  *
*                PREVIOUSLY PROCESSED, AND NULLIFIES ITS      *
*                LIST.                                        *
*                                                             *
*               ."DOYX=" OR "MDYX=".  THESE KEYWORDS TELL THE *
*                PROGRAM NOT TO PROCESS COMMANDS IF THE       *
*                EXECUTION DATE (TODAY'S DATE) IS ONE OF THE  *
*                DATES LISTED.  "DOYX=" IS USED TO SPECIFY    *
*                DATES IN YY.DDD FORMAT, AND "MDYX=" IS USED  *
*                TO SPECIFY DATES IN MM/DD/YY FORMAT.  THE    *
*                SYNTAX OF THE "DOYX=" KEYWORD IS AS          *
*                FOLLOWS.....                                 *
*                                                             *
*                    DOYX=VALUE                               *
*                    DOYX=(VALUE)                             *
*                    DOYX=(VALUE1,VALUE2,...)                 *
*                                                             *
*                WHERE EACH "VALUE" OR "VALUEN" IS A JULIAN   *
*                DATE HAVING THE FORM "YYDDD" OR "YY.DDD"     *
*                WHERE "YY" IS THE LAST TWO DIGITS OF THE     *
*                YEAR, AND "DDD" IS THE DAY OF THE YEAR.  THE *
*                SYNTAX OF THE "MDYX=" KEYWORD IS AS          *
*                FOLLOWS.....                                 *
*                                                             *
*                    MDYX=VALUE                               *
*                    MDYX=(VALUE)                             *
*                    MDYX=(VALUE1,VALUE2,...)                 *
*                                                             *
*                WHERE EACH "VALUE" OR "VALUEN" IS A          *
*                GREGORIAN DATE HAVING THE FORM "MMDDYY" OR   *
*                "MM/DD/YY" WHERE "MM" IS THE MONTH, "DD" IS  *
*                THE DAY OF THE MONTH, AND "YY" IS THE LAST   *
*                TWO DIGITS OF THE YEAR.  THE KEYWORDS CAN BE *
*                USED INTERCHANGEABLY, AND EITHER KEYWORD     *
*                SPECIFIES AN EXCLUSION LIST; COMMANDS WILL   *
*                BE PROCESSED ONLY WHEN TODAY'S DATE DOES NOT *
*                MATCH ONE OF THE DATES LISTED.  THE PROGRAM  *
*                DEFAULTS TO "DOYX=" OR "MDYX=" SPECIFYING A  *
*                NULL VALUE LIST; I.E., COMMANDS CAN BE       *
*                ISSUED ON ALL SYSTEMS.  THESE KEYWORDS ARE   *
*                INCOMPATIBLE WITH THE "DOY=" OR "MDY="       *
*                KEYWORDS (SEE ABOVE).  IF MORE THAN ONE      *
*                "DOYX=" OR "MDYX=" KEYWORD IS PROCESSED, THE *
*                FINAL LIST OF DATES USED IS BASED ON ALL OF  *
*                THE DATES SPECIFIED WITH DUPLICATES          *
*                ELIMINATED.  "DOYX=" OR "MDYX=" OVERRIDES    *
*                ANY "DOY=" OR "MDY=" KEYWORD PREVIOUSLY      *
*                PROCESSED, AND NULLIFIES ITS LIST.           *
*                                                             *
*                                                             *
*               ."SEQ" AND "NOSEQ".  THESE PARAMETERS TELL    *
*                THE PROGRAM HOW TO PROCESS BYTES 73-80 OF    *
*                EACH INPUT RECORD.  "SEQ" DIRECTS THE        *
*                PROGRAM TO DISCARD BYTES 73-80 AND NOT       *
*                CONSIDER THEM PART OF THE COMMAND.  "NOSEQ"  *
*                DIRECTS THE PROGRAM TO PROCESS BYTES 73-80   *
*                AS PART OF THE COMMAND.  THE DEFAULT VALUE   *
*                IS "SEQ".                                    *
*                                                             *
*               ."MSG" AND "NOMSG".  THESE PARAMETERS TELL    *
*                THE PROGRAM WHETHER OPERATOR MESSAGES ARE    *
*                DESIRED FOR EACH COMMAND ISSUED TO THE       *
*                SYSTEM.  "MSG" DIRECTS THE PROGRAM TO ISSUE  *
*                A WTO FOR EACH COMMAND ISSUED.  "NOMSG"      *
*                DIRECTS THE PROGRAM TO OMIT THE OPERATOR     *
*                MESSAGE FOR EACH COMMAND.  THE DEFAULT VALUE *
*                IS "MSG".                                    *
*                                                             *
*               ."INPUT" AND "NOINPUT".  THESE PARAMETERS     *
*                TELL THE PROGRAM WHETHER TO PROCESS THE      *
*                SYSIN DATA SET.  "INPUT" DIRECTS THE PROGRAM *
*                TO OPEN THE SYSIN DATA SET AND READ COMMAND  *
*                IMAGES FROM IT.  "NOINPUT" DIRECTS THE       *
*                PROGRAM TO SKIP PROCESSING OF THE SYSIN DATA *
*                SET.  A SPECIFICATION OF "NOINPUT" FORCES    *
*                "NOCMDS" (SEE BELOW).  THE PROGRAM DEFAULT   *
*                VALUE IS "INPUT".  A SPECIFICATION OF        *
*                "NOINPUT" IS USEFUL WHEN THE ONLY OUTPUT     *
*                DESIRED FROM THE PROGRAM IS THE CONDITION    *
*                CODE INDICATING THE RESULTS OF TESTS FOR     *
*                SID/DOY/DOW/BEFORE/AFTER.                    *
*                                                             *
*               ."CMDS" AND "NOCMDS".  THESE PARAMETERS TELL  *
*                THE PROGRAM WHETHER COMMANDS SHOULD ACTUALLY *
*                BE ISSUED TO THE SYSTEM.  "CMDS" DIRECTS THE *
*                PROGRAM TO ISSUE COMMANDS ACROSS THE SVC 34  *
*                INTERFACE.  "NOCMDS" DIRECTS THE PROGRAM NOT *
*                TO ISSUE COMMANDS.  A SPECIFICATION OF       *
*                "CMDS" FORCES "INPUT" (SEE ABOVE).  THE      *
*                DEFAULT VALUE IS "CMDS" (AND "INPUT").  NOTE *
*                THAT A SPECIFICATION OF "TEST" (SEE BELOW)   *
*                FORCES "NOCMDS" BUT DOES NOT FORCE           *
*                "NOINPUT"; THUS "TEST" WILL ALLOW TESTING OF *
*                ACCESS TO THE SYSIN DATA SET, UNLESS         *
*                "NOINPUT" IS EXPLICITLY SPECIFIED FOLLOWING  *
*                "TEST" IN THE PARM FIELD.                    *
*                                                             *
*               ."CN=".  THIS KEYWORD IDENTIFIES TO THE       *
*                PROGRAM THE CONSOLE ID TO BE ASSOCIATED WITH *
*                PROGRAM MESSAGES, COMMAND IMAGE MESSAGES,    *
*                AND ACTUAL COMMANDS AS THEY ARE ISSUED BY    *
*                THE PROGRAM.  THE CONSOLE ID IS PLACED IN    *
*                REGISTER R0 FOR BOTH SVC 34 (MGCR) AND SVC   *
*                35 (WTO/WTOR).  THE SYNTAX OF THE "CN="      *
*                KEYWORD IS AS FOLLOWS.....                   *
*                                                             *
*                    CN=VALUE                                 *
*                    CN=(VALUE)                               *
*                                                             *
*                WHERE "VALUE" CAN BE ONE OF THE              *
*                FOLLOWING.....                               *
*                                                             *
*                   .A NUMERIC STRING IDENTIFYING THE MCS     *
*                    CONSOLE ID (UCMID) AS SHOWN ON THE MVS   *
*                    "D C" COMMAND.                           *
*                   .THE CHARACTERS "MC" SIGNIFYING THE       *
*                    MASTER CONSOLE.                          *
*                   .THE CHARACTERS "**" SIGNIFYING THE MCS   *
*                    CONSOLE ID OF THE CONSOLE ASSOCIATED     *
*                    WITH THE PROGRAM WHEN IT IS INVOKED BY   *
*                    A PROCEDURE STARTED FROM A CONSOLE.      *
*                    WHEN THE PROGRAM IS NOT BEING INVOKED    *
*                    BY A CONSOLE STARTED PROCEDURE, "**"     *
*                    IS PROCESSED AS IF IT WERE "MC".         *
*                                                             *
*                THE PROGRAM DEFAULTS TO "**".  NOTE THAT     *
*                "**" DEPENDS ON THE PRESENCE OF THE START    *
*                CIB ASSOCIATED WITH STARTED TASKS (SEE       *
*                OS/VS2 SYSTEM PROGRAMMING LIBRARY:           *
*                SUPERVISOR; FORM GC28-0628 FOR DETAILS).  IF *
*                THE START CIB HAS BEEN FREED BY A PREVIOUS   *
*                STEP IN THE PROCEDURE, THE PROGRAM WILL BE   *
*                UNABLE TO LOCATE IT, AND WILL PROCESS "**"   *
*                AS EQUIVALENT TO "MC".  THE CONSOLE ID CAN   *
*                BE OVERRIDDEN ON AN INDIVIDUAL COMMAND BASIS *
*                BY USING THE "CN(##)" CONSOLE-DIRECTED       *
*                COMMAND RECORD FORMAT DESCRIBED ABOVE.  FOR  *
*                PROGRAM MESSAGES AND COMMAND IMAGE MESSAGES, *
*                IF "CN=" SPECIFIES A CONSOLE ID OTHER THAN   *
*                "**", OR IF THE PROGRAM IS BEING EXECUTED AS *
*                PART OF A STARTED TASK, THE MCS FLAG "REG0"  *
*                IS SET IN THE WTO/WTOR PARAMETER LIST TO     *
*                CAUSE THE MESSAGE TO BE ROUTED TO THE "CN="  *
*                CONSOLE AS WELL AS TO THE CONSOLES WHICH     *
*                WOULD NORMALLY RECEIVE IT VIA THE "ROUTCDE=" *
*                SPECIFICATION (SEE BELOW).                   *
*                                                             *
*               ."DESC=".  THIS KEYWORD IDENTIFIES TO THE     *
*                PROGRAM THE DESCRIPTOR CODE(S) TO BE         *
*                ASSOCIATED WITH PROGRAM MESSAGES AND COMMAND *
*                IMAGE MESSAGES ISSUED BY THE PROGRAM.  THE   *
*                SYNTAX OF THE "DESC=" KEYWORD IS AS          *
*                FOLLOWS...                                   *
*                                                             *
*                    DESC=VALUE                               *
*                    DESC=(VALUE)                             *
*                    DESC=(VALUE1,VALUE2,...)                 *
*                                                             *
*                WHERE EACH "VALUE" OR "VALUEN" IS A NUMERIC  *
*                VALUE IN THE RANGE 01-16.  THE DEFAULT VALUE *
*                IS DESC=6 (JOB STATUS).  NOTE THAT THE       *
*                DESCRIPTOR CODES SPECIFIED APPLY ONLY TO WTO *
*                MESSAGES.  WTOR MESSAGES ISSUED BY THE       *
*                PROGRAM ARE ASSIGNED A DESCRIPTOR CODE OF 7  *
*                (APPLICATION PROGRAM/PROCESSOR), IN KEEPING  *
*                WITH THE DOCUMENTATION OF THE WTOR MACRO IN  *
*                "OS/VS2 MVS SUPERVISOR SERVICES AND MACRO    *
*                INSTRUCTIONS", FORM NUMBER GC28-0683.        *
*                                                             *
*               ."ROUTCDE=". THIS KEYWORD IDENTIFIES TO THE   *
*                PROGRAM THE ROUTING CODE(S) TO BE ASSOCIATED *
*                WITH PROGRAM MESSAGES AND COMMAND IMAGE      *
*                MESSAGES ISSUED BY THE PROGRAM.  THE SYNTAX  *
*                OF THE "ROUTCDE=" KEYWORD IS AS FOLLOWS...   *
*                                                             *
*                    ROUTCDE=VALUE                            *
*                    ROUTCDE=(VALUE)                          *
*                    ROUTCDE=(VALUE1,VALUE2,...)              *
*                                                             *
*                WHERE EACH "VALUE" OR "VALUEN" IS A NUMERIC  *
*                VALUE IN THE RANGE 01-16.  THE DEFAULT VALUE *
*                IS ROUTCDE=(2,11) (MASTER CONSOLE            *
*                INFORMATION; PROGRAMMER INFORMATION).        *
*                UNLIKE "DESC=", THE ROUTING CODES SPECIFIED  *
*                APPLY BOTH TO WTO AND WTOR MESSAGES ISSUED   *
*                BY THE PROGRAM.                              *
*                                                             *
*               ."PAUSE" AND "NOPAUSE".  THESE PARAMETERS     *
*                TELL THE PROGRAM WHETHER TO ISSUE A WTOR AND *
*                WAIT FOR A REPLY AFTER THE DELAY INTERVAL    *
*                (IF ANY) HAS EXPIRED AND COMMANDS HAVE BEEN  *
*                PROCESSED (LISTED AND/OR ISSUED).  "PAUSE"   *
*                CAUSES THE WTOR TO BE ISSUED WHEREAS         *
*                "NOPAUSE" CAUSES THE WTOR TO BE SKIPPED,     *
*                ALLOWING THE PROGRAM TO PROCEED WITH NORMAL  *
*                TERMINATION.  NOTE THAT IF THE PROGRAM ENDS  *
*                WITH RETURN CODE 08 OR GREATER, THE PAUSE    *
*                WTOR IS BYPASSED.  THE DEFAULT VALUE IS      *
*                "NOPAUSE" WHICH CAUSES THE WTOR TO BE        *
*                BYPASSED IN KEEPING WITH THE FUNCTION OF     *
*                EARLIER VERSIONS OF THE PROGRAM.  THE        *
*                PURPOSE OF THIS FEATURE IS TO ALLOW THE      *
*                PROGRAM TO BE USED AS A WTO MESSAGE ISSUER.  *
*                WHEN PARM='INPUT,NOCMDS,MSGC' IS SPECIFIED,  *
*                THE COMMAND IMAGES IN SYSIN ARE LISTED BUT   *
*                NOT ISSUED AS COMMANDS; IN EFFECT, THEY ARE  *
*                PROCESSED AS MESSAGES TO THE OPERATOR.  IF   *
*                IN ADDITION, PARM='PAUSE' IS SPECIFIED, A    *
*                WTOR IS ISSUED AFTER THE TEXT LINES IN SYSIN *
*                HAVE BEEN DISPLAYED, ALLOWING SOME ACTION TO *
*                BE PERFORMED BEFORE THE JOB IS ALLOWED TO    *
*                CONTINUE.  AS A HELPFUL (OR UNHELPFUL        *
*                DEPENDING ON YOUR POINT OF VIEW) HINT,       *
*                SPECIFY DESC=2 TO KEEP ALL OF THE TEXT       *
*                IMAGES ON THE SCREEN UNTIL THEY ARE MANUALLY *
*                DELETED BY THE OPERATOR.                     *
*                                                             *
*               ."DOMMSGC" AND "NODOMMSGC".  THESE PARAMETERS *
*                TELL THE PROGRAM WHETHER A DOM SVC IS TO BE  *
*                ISSUED TO DELETE EACH COMMAND IMAGE MESSAGE  *
*                AFTER THE PAUSE MESSAGE (IF ISSUED) HAS BEEN *
*                RESPONDED TO AND BEFORE RETURNING CONTROL TO *
*                THE SYSTEM.  "DOMMSGC" CAUSES THE DOM SVC TO *
*                BE ISSUED, WHEREAS "NODOMMSGC" ALLOWS THE TO *
*                REMAIN ON THE SCREEN (IF THEIR DESCRIPTOR    *
*                CODES WOULD CAUSE THEM TO REMAIN).  A        *
*                PARAMETER SPECIFICATION OF "PAUSE" IMPLIES   *
*                "DOMMSGC" WHILE A SPECIFICATION (OR DEFAULT) *
*                OF "NOPAUSE" IMPLIES "NODOMMSGC".  THIS      *
*                FEATURE IS PROVIDED TO ENHANCE THE VALUE OF  *
*                THE PROGRAM WHEN IT IS BEING USED AS A WTO   *
*                MESSAGE ISSUER.  A USER CAN SPECIFY DESC=(2) *
*                TO CAUSE THE COMMAND IMAGE MESSAGES TO BE    *
*                HELD ON THE SCREEN.  THIS WILL CAUSE THE     *
*                MESSAGES TO REMAIN AVAILABLE UNTIL THE       *
*                OPERATOR REPLIES TO THE PAUSE WTOR.  BECAUSE *
*                "PAUSE" IMPLIES "DOMMSGC", THE MESSAGES WILL *
*                THEN BE AUTOMATICALLY DELETED FROM THE       *
*                SCREEN WITHOUT REQUIRING ADDITIONAL MANUAL   *
*                INTERVENTION BY THE OPERATOR.                *
*                                                             *
*               ."TEST" AND "NOTEST".  THESE PARAMETERS TELL  *
*                THE PROGRAM WHETHER TO RUN IN "TEST" MODE.   *
*                "TEST" MODE CAUSES A NUMBER OF DIAGNOSTIC    *
*                MESSAGES TO BE ISSUED WHICH ARE NOT NORMALLY *
*                SENT TO THE OPERATOR.  "TEST" ALSO CAUSES    *
*                THE "NOCMDS", AND "MSG" OPTIONS TO BE SET.   *
*                "TEST" MODE IS A WAY OF RUNNING THE PROGRAM  *
*                WHICH FACILITATES DEBUGGING PROGRAM CHANGES. *
*                                                             *
*        THESE KEYWORDS CAN BE SPECIFIED IN ANY ORDER.  IF    *
*        CONFLICTING KEYWORDS ARE SPECIFIED, THE LAST KEYWORD *
*        PROCESSED IN EITHER THE EXEC STATEMENT PARM FIELD OR *
*        IN THE SYSPARM DATA SET IS USED TO DETERMINE WHAT    *
*        THE PROGRAM WILL DO.                                 *
*                                                             *
*                                                             *
*               A RECORD OF THE MESSAGES AND COMMANDS ISSUED  *
*        DURING PROGRAM EXECUTION IS WRITTEN TO THE           *
*        "SYSPRINT" DATA SET.  THE PROGRAM HAS HARDCODED DCB  *
*        ATTRIBUTES OF RECFM=FBA,LRECL=121 FOR "SYSPRINT".    *
*        THE DCB BLKSIZE VALUE IS NOT HARD CODED AND CAN BE   *
*        TAKEN FROM THE JCL.  IF THE USER DOES NOT PROVIDE A  *
*        BLKSIZE VALUE, THE PROGRAM PROVIDES A VALUE OF       *
*        BLKSIZE=121 FOR SYSPRINT USING A DCB OPEN EXIT.      *
*                                                             *
*                                                             *
***************************************************************
***                                                         ***
***>>>>>>>>>>>>>>C U I C   D I S C L A I M E R<<<<<<<<<<<<<<***
***                                                         ***
***************************************************************
***            THE INFORMATION OR MATERIAL BEING PROVIDED   ***
***      BY COMMERCIAL UNION INSURANCE COMPANY (CUIC),      ***
***      WHETHER IN HARD COPY OR MACHINE READABLE FORM,     ***
***      HAS BEEN DEVELOPED BY CUIC FOR ITS OWN PURPOSE     ***
***      AND FOR USE ON ITS OWN EQUIPMENT AND WITHIN ITS    ***
***      OWN DATA PROCESSING SYSTEM.  CUIC MAKES NO         ***
***      REPRESENTATIONS OR WARRANTIES WHATSOEVER WITH      ***
***      RESPECT TO THE INFORMATION OR MATERIAL FURNISHED   ***
***      HEREUNDER, EXPRESSED OR IMPLIED, INCLUDING BUT     ***
***      NOT LIMITED TO ANY REPRESENTATION OR WARRANTY OF   ***
***      MERCHANTABILITY OR FITNESS FOR ANY PARTICULAR USE  ***
***      OR PURPOSE OR THAT THE USE OF THE INFORMATION OR   ***
***      MATERIAL WILL NOT INFRINGE ANY PATENT, COPYRIGHT,  ***
***      TRADEMARK, OR OTHER PROPRIETARY INTEREST.  YOU     ***
***      ARE, THEREFORE, ACCEPTING THIS INFORMATION OR      ***
***      MATERIAL ON AN "AS IS" BASIS AND WILL BE USING IT  ***
***      AT YOUR OWN RISK.  NEITHER CUIC NOR ANY OF ITS     ***
***      AFFILIATES SHALL BE LIABLE WITH RESPECT TO ANY     ***
***      CLAIM, ACTION, OR DEMAND BY ANY USER OR OTHER      ***
***      PARTY (INCLUDING ANY CLAIM, ACTION, OR DEMAND FOR  ***
***      CONSEQUENTIAL DAMAGES EVEN IF CUIC HAS BEEN        ***
***      ADVISED OF THE POSSIBILITY OF SUCH DAMAGES)        ***
***      ARISING FROM THE USE OF THE INFORMATION OR THE     ***
***      MATERIALS AND CONCEPTS RELATED THERETO.            ***
***      FURTHERMORE, CUIC WILL NOT MAINTAIN, CORRECT, OR   ***
***      UPDATE THIS INFORMATION OR MATERIAL IN THE         ***
***      FUTURE.                                            ***
***                                              01/26/83   ***
***************************************************************
*                                                             *
*              DIRECT INQUIRIES TO THE                        *
*        AUTHOR.....                                          *
*                                                             *
*                   THOMAS J. AUBREY                          *
*                   C. U. AUTOMATION SERVICES                 *
*                   COMMERCIAL UNION ASSURANCE COMPANIES      *
*                   ONE BEACON STREET - 13TH FLOOR            *
*                   BOSTON, MASSACHUSETTS  02108              *
*                   TELEPHONE (617) 725-6208                  *
*                                                             *
***************************************************************
*
*
         TITLE 'PAGEADD - MODULE EQUATES'
PAGEADD  START 000000
PAGEADD  AMODE 24                 SPECIFY ADDRESSING MODE
PAGEADD  RMODE 24                 SPECIFY MODULE RESIDENCY MODE
*
*
*        PHYSICAL REGISTER EQUATES
R0       EQU   0
R1       EQU   1
R2       EQU   2
R3       EQU   3
R4       EQU   4
R5       EQU   5
R6       EQU   6
R7       EQU   7
R8       EQU   8
R9       EQU   9
R10      EQU   10
R11      EQU   11
R12      EQU   12
R13      EQU   13
R14      EQU   14
R15      EQU   15
*
*
*        LOGICAL REGISTER EQUATES
RWORK0   EQU   00                  SUBROUTINE PARM/WORK REGISTER
RWORK1   EQU   01                  SUBROUTINE PARM/WORK REGISTER
RWORK2   EQU   02                  SUBROUTINE PARM/WORK REGISTER
RWORK3   EQU   03                  SUBROUTINE PARM/WORK REGISTER
RWORK4   EQU   04                  SUBROUTINE INTERNAL WORK REGISTER
RPAREN   EQU   04    PARAMETER VALUE ENCLOSED IN PARENTHESES
RWORK5   EQU   05                  SUBROUTINE INTERNAL WORK REGISTER
RTBL1    EQU   05    LOOP CONTROL
RWORK6   EQU   06                  SUBROUTINE INTERNAL WORK REGISTER
RTBL2    EQU   06    EVEN
RWORK7   EQU   07                  SUBROUTINE INTERNAL WORK REGISTER
RTBL3    EQU   07    ODD
RBASE1   EQU   08                  MODULE BASE REGISTER # 1
RBASE2   EQU   09                  MODULE BASE REGISTER # 2
RBASE3   EQU   10                  MODULE BASE REGISTER # 3
RBASE4   EQU   11                  MODULE BASE REGISTER # 4
*        EQU   12                         RESERVED
RSAVE    EQU   13                  WORK AREA BASE REGISTER
RLINK    EQU   14                  SUBROUTINE LINKAGE REGISTER
RENTRY   EQU   15                  ENTRY ADDRESS REGISTER
*
*
*        EQUATES FOR THE TCB/ASCB WORDS REFERENCED BY -CVTTCBP-.
TCBPNEW  EQU   X'0000',04     -> NEXT TCB TO BE DISPATCHED
TCBPOLD  EQU   X'0004',04     -> CURRENT TCB
ASCBPNEW EQU   X'0008',04     -> NEXT ASCB TO BE DISPATCHED
ASCBPOLD EQU   X'000C',04     -> CURRENT ASCB
         TITLE 'PAGEADD - ADDRESS SPACE CONTROL BLOCK(ASCB) DSECT'
         IHAASCB   DSECT=YES
         TITLE 'PAGEADD - COMMAND INPUT BUFFER (CIB) DSECT'
CIBDSECT DSECT    ,
         IEZCIB   ,
         TITLE 'PAGEADD - COMMAND SCHEDULING CONTROL BLOCK(CSCB) DSECT'
CSCDSECT DSECT  ,
         IEECHAIN ,
         TITLE 'PAGEADD - COMMUNICATION VECTOR TABLE (CVT) DSECT'
         CVT   DSECT=YES,LIST=YES
         TITLE 'PAGEADD - DATA CONTROL BLOCK(DCB) DSECT'
         PUSH  PRINT
         PRINT NOGEN
         DCBD  DSORG=PS,DEVD=DA
         POP   PRINT
         TITLE 'PAGEADD - SYSTEM MANAGEMENT CONTROL AREA (SMCA) DSECT'
         PUSH  PRINT
         PRINT NOGEN
         IEESMCA ,
         POP   PRINT
         TITLE 'PAGEADD - UNIT CONTROL MODULE(UCM) DSECT'
UCM      DSECT  ,
         IEECUCM    DSECT=YES
         TITLE 'PAGEADD - WTO/WTOR PARAMETER LIST DSECT MAPPING'
         IEZWPL     DSECT=YES
         TITLE 'PAGEADD - WORKING STORAGE DSECT'
         SPACE 3
WRKAREA  DSECT  ,
SAVE     DC    18A(0)              GENERAL REGISTER SAVE AREA
PACKAREA DC    D'0'                DOUBLEWRD BOUNDARY WORK AREA
PACK1    DC    CL16' '             HEX TO EBCDIC WORK AREA
PACK2    DC    CL16' '             HEX TO EBCDIC WORK AREA
RETURNCD DC    A(0)                RETURN CODE SAVE AREA
CMDCOUNT DC    A(0)                NUMBER OF COMMANDS FROM SYSIN
*
*        DEFAULT AND PARM-FIELD CHANGEABLE CONTROL VALUES
         DS    0D                  PROVIDE BOUNDARY ALIGNMENT
DELAYDEC DC    CL8'HHMMSSTH'       DELAY TIME IN EBCDIC DECIMAL
TODDEC   DC    CL8'HHMMSSTH'       TIME OF DAY IN EBCDIC DECIMAL
BEFORDEC DC    CL8'HHMMSSTH'       BEGINNING TOD IN EBCDIC DECIMAL
AFTERDEC DC    CL8'HHMMSSTH'       ENDING TOD IN EBCDIC DECIMAL
SPDDNAM  DC    CL8'SYSPARM '       SYSPARM  DATA SET DD NAME
INDDNAM  DC    CL8'SYSIN   '       SYSIN    DATA SET DD NAME
DELAYTME DC    A(0)                DELAY TIME IN 1/100 SECONDS
TODTME   DC    A(0)                TIME OF DAY IN 1/100 SECONDS
BEFORTME DC    A(0)                BEGINNING TOD IN 1/100 SECONDS
AFTERTME DC    A(0)                ENDING TOD IN 1/100 SECONDS
MSGDSCCD DC    Y(0)                MCS DESCRIPTOR CODE FOR CMD/MSG
MSGRTECD DC    Y(0)                MCS ROUTING    CODE FOR CMD/MSG
PRMSCALK DC    A(0)                LINK REGISTER SAVE FOR "PARMANAL"
PRMSCARF DC    A(0)                R15 SAVE AREA
PRMSCAR0 DC    A(0)                R0  SAVE AREA
PRMSCAR1 DC    A(0)                R1  SAVE AREA
PRMSCAR2 DC    A(0)                R2  SAVE AREA
PRMSCAR3 DC    A(0)                R3  SAVE AREA
PRMSCBLK DC    A(0)                LINK REGISTER SAVE FOR "PRMSCBTM"
PRMSCDLK DC    A(0)                LINK REGISTER SAVE FOR "PRMSCDOW"
PRMSCELK DC    A(0)                LINK REGISTER SAVE FOR "PRMSCETM"
PRMSCILK DC    A(0)                LINK REGISTER SAVE FOR "PRMSCITM"
PRMSCMLK DC    A(0)                LINK REGISTER SAVE FOR "PRMSIDLS"
PRMSCOLK DC    A(0)                LINK REGISTER SAVE FOR "PRMDOYLS"
PRMSCRLK DC    A(0)                LINK REGISTER SAVE FOR "PRMBITLS"
PRMSCSLK DC    A(0)                LINK REGISTER SAVE FOR "PRMSCSTR"
PRMSCVLK DC    A(0)                LINK REGISTER SAVE FOR "PRMSCVAL"
PRMSCYLK DC    A(0)                LINK REGISTER SAVE FOR "PRMSCDOY"
PRMNUMPD DC    D'0'                NMBR STRING IN PACKED DECIMAL
PRMDOYPD DC    D'0'                DAY-OF-YEAR IN PACKED DECIMAL
PRMITMAS DC    CL64' '             ITEM STRING ASSEMBLY AREA
PRMNUMAS DC    CL08'0'             NMBR STRING ASSEMBLY AREA
PRMNUMBN DC    F'0'                NMBR STRING BINARY EQUIVALENT
PRMBITAS DC    F'0'                BIT  STRING ASSEMBLY AREA
PRMSIDVL DC    CL4'    '           SMF SYSTEM ID VALUE ASSEMBLY AREA
PRMTODAS DC    F'0'                TIME-OF-DAY VALUE ASSEMBLY AREA
PRMDOYAS DC    F'0'                DAY-OF-YEAR VALUE ASSEMBLY AREA
PRMVALAS DC    F'0'                NUMERIC VALUE ASSEMBLY AREA
MSGCONID DC    Y(0)                SAVE DEFAULT CONSOLE ID VALUE
DOWMASKA DC    B'11111110'         DAYS-OF-THE-WEEK EXECUTION OK
DOWMASKB DC    B'11111110'         DAYS-OF-THE-WEEK EXECUTION OK
DOWMASKC DC    B'11111110'         DAYS-OF-THE-WEEK EXECUTION OK
*********************************************
*                                           *
*        EXECUTION ENVIRONMENT VALUES.      *
*                                           *
*********************************************
         DS    0D                  PROVIDE BOUNDARY ALIGNMENT
XEQDEC   DC    CL8'HHMMSSTH'       EXECUTION TOD IN EBCDIC DECIMAL
XEQTME   DC    A(0)                EXECUTION TOD IN 1/100 SECONDS
XEQDATE  DC    PL4'0'              EXECUTION DATE IN PACKED DECIMAL
XEQSID   DC    CL4'XXXX'           EXECUTION SYSTEM SMF ID
XEQXTRAA DS   0A                   EXTRACT MACRO ANSWER AREA (2 WORDS)
XEQTIOTA DC    A(0)                TIOT ADDRESS FROM EXTRACT
XEQCOMMA DC    A(0)                COMM ADDRESS FROM EXTRACT
XEQCONID DC    Y(00)               EXECUTION ENVIRONMENT CONSOLE ID
XEQTRKID DC    X'00'               EXECUTION ADDRESS SPACE TYPE
XEQMODE  DC    X'00'               EXECUTION ENVIRONMENT TEST RESULTS
*
*        SMF ID INCLUDE/EXCLUDE LIST FROM "SID=" OR "SIDX=".
SIDCOUNT DC    A(0)                NUMBER OF LIST ENTRIES
SIDLIST  DC  32CL4'XXXX'           SID LIST
SIDMAX#  EQU   (*-SIDLIST)/L'SIDLIST   MAX # OF LIST ENTRIES
*
*        DAY-OF-YEAR INCLUDE/EXCLUDE LIST FROM "DOY=" OR "DOYX=".
DOYCOUNT DC    A(0)                NUMBER OF LIST ENTRIES
DOYMIND  DC    PL4'00000'          LOWEST DATE FOR LIST
DOYMAXD  DC    PL4'00000'          HIGHEST DATE FOR LIST
DOYLIST  DC  16PL4'00000'          DOY LIST
DOYMAX#  EQU   (*-DOYLIST)/L'DOYLIST   MAX # OF LIST ENTRIES
*
*        EXTRACT MACRO LIST FORM.
XEQXTRLS EXTRACT *-*,'S',FIELDS=(TIOT,COMM),MF=L
XEQXTRLZ EQU   *-XEQXTRLS          LIST FORM LENGTH
*
*        TESTAUTH MACRO RESULTS SAVE AREAS
*        AND PROGRAM EXECUTION FLAG STORAGE AREAS
AUTHLKSV DS    A(0)                "TESTAPF" RLINK SAVE
AUTHSAVE DS    0A(0)               BOUNDARY ALIGN
AUTHFCTN DC    AL1(00)             TEST FOR AUTHORIZATION CODE 1
         DC    AL1(00)             RESERVED FOR TESTAUTH USE
         DC    AL1(00)             RESERVED FOR TESTAUTH USE
TESTMODE DC    AL1(00)             SET TO 04 IF PARM=TEST
MSGMODEC DC    AL1(00)             SET TO 04 IF PARM=NOMSG OR NOMSGC   X
                                   SET TO 00 IF PARM=MSG, MSGC, OR TEST
MSGMODED DC    AL1(00)             SET TO 04 IF PARM=NOMSG OR NOMSGD   X
                                   SET TO 00 IF PARM=MSG, MSGD, OR TEST
MSGMODES DC    AL1(00)             SET TO 04 IF PARM=NOMSG OR NOMSGS   X
                                   SET TO 00 IF PARM=MSG, MSGS, OR TEST
MSGMODET DC    AL1(00)             SET TO 04 IF PARM=NOMSG OR NOMSGT   X
                                   SET TO 00 IF PARM=MSG, MSGT, OR TEST
SEQMODE  DC    AL1(00)             SET TO 04 IF PARM=NOSEQ             X
                                   SET TO 00 IF PARM=SEQ
INPMODE  DC    AL1(00)             SET TO 04 IF PARM=NOINPUT           X
                                   SET TO 00 IF PARM=INPUT OR BY TEST
CMDMODE  DC    AL1(00)             SET TO 04 IF PARM=NOCMDS OR BY TEST X
                                   SET TO 00 IF PARM=CMDS
SIDMODE  DC    AL1(00)             SET TO 04 IF PARM=SIDX=             X
                                   SET TO 00 IF PARM=SID=
DOYMODE  DC    AL1(00)             SET TO 04 IF PARM=DOYX=             X
                                   SET TO 00 IF PARM=DOY=
PRMMODE  DC    AL1(00)             SET TO 04 IF PARM=NOPARMDD          X
                                   SET TO 00 IF PARM=PARMDD
PMTMODE  DC    AL1(00)             SET TO 04 IF PARM=NOPROMPT          X
                                   SET TO 00 IF PARM=PROMPT
CNCMODE  DC    AL1(00)             SET TO 04 IF PARM=CANCEL            X
                                   SET TO 00 IF PARM=GO
PSEMODE  DC    AL1(00)             SET TO 04 IF PARM=NOPAUSE           X
                                   SET TO 00 IF PARM=PAUSE
DMCMODE  DC    AL1(00)             SET TO 04 IF PARM=NODOMMSGC         X
                                   SET TO 00 IF PARM=DOMMSGC
         SPACE 5
*********************************************
*                                           *
*        WRITE-TO-OPERATOR WORK AREA        *
*                                           *
*********************************************
WTOCONID DC    Y(0)                CONSOLE ID FOR COMMAND/MESSAGE
WTODSCCD DC    Y(0)                MCS DESCRIPTOR CODE FOR CMD/MSG
WTORTECD DC    Y(0)                MCS ROUTING    CODE FOR CMD/MSG
WTSVCMDL DS    A(0)                RLINK SAVE FOR WTOCMD/ISSUECMD
WTSVMCS  DS    Y(0)                MCS FLAGS SAVE AREA FOR "ISSUECMD"
         DS    Y(0)                RESERVED
WTORECB  DS    A                   WTOR WAIT ECB
WTOREPLY DS    CL80                WTOR REPLY AREA
WTORAREA DS   2A                   WTOR PREFIX TO WTO EXPANSION
WTOAREA  DS   0A                   WTO LIST EXPANSION
WTOLEN   DC    Y(0)                OPERATOR COMMAND LENGTH
WTOMCS   DC    Y(0)                OPERATOR COMMAND MCS FLAGS
WTOMSG   DC    CL120' '            OPERATOR COMMAND TEXT
         DC    XL4'00'             MCS ROUTE AND DESCRIPTOR CODES
         EJECT  ,
*****************************************************************
*                                                               *
*        DATE PROCESSING SUBROUTINE STATIC STORAGE AREAS.       *
*                                                               *
*****************************************************************
*
*        DATE CALCULATION SUBROUTINE GLOBAL STORAGE.
DATEWKBG DS   0D              START OF STATIC STORAGE
DATPACK  DC    D'0'           CVB/CVD WORK AREA: CONTENTS UNPREDICTABLE
DATDOW   DC    A(0)    (15)   DAY OF WEEK      FOR LAST DATE PROCESSED
DATMM    DC    A(0)    (00)   MONTH            FOR LAST DATE PROCESSED
DATDD    DC    A(0)    (01)   DAY OF MONTH     FOR LAST DATE PROCESSED
DATDDD   DC    A(0)    (02)   DAY OF YEAR      FOR LAST DATE PROCESSED
DATYYYY  DC    A(0)    (03)   YEAR ("YYYY")    FOR LAST DATE PROCESSED
DATFACT  DC    A(0)    (04)   "FACTOR"         FOR LAST DATE PROCESSED
DATLFEB  DC    A(0)    (05)   LAST DAY OF FEB  FOR LAST DATE PROCESSED
DAT#DDD  DC    A(0)    (06)   # OF DAYS IN YR  FOR LAST DATE PROCESSED
DATQTR   DC    A(0)    (07)   QTR OF THE YEAR  FOR LAST DATE PROCESSED
DATJUL   DC    PL4'0000000'   JULIAN DATE  ("YYYY.DDD") IN PACKED DEC
DATYYDDD DC    PL4'00000'     JULIAN DATE  ("00YY.DDD") IN PACKED DEC
DATMDY   DC    PL4'000000'    GREGORIAN DT ("MM/DD/YY") IN PACKED DEC
DATYMD   DC    PL4'000000'    GREGORIAN DT ("YY/MM/DD") IN PACKED DEC
         SPACE 1
*        STATIC LOCAL STORAGE USED BY FACTOR DATE PROCESSING
*        ROUTINE: "FACTDATE".
SAVFCTDT DS  10A(0)           "RLINK" - "RWORK7" REGISTER SAVE
*        STATIC LOCAL STORAGE USED BY JULIAN DATE PROCESSING
*        ROUTINE: "JULDATE".
SAVJULDT EQU   SAVFCTDT       "RLINK" - "RWORK7" REGISTER SAVE
*        STATIC LOCAL STORAGE USED BY GREGORIAN DATE PROCESSING
*        ROUTINE: "MDYDATE".
SAVMDYDT EQU   SAVFCTDT       "RLINK" - "RWORK7" REGISTER SAVE
*        STATIC LOCAL STORAGE USED BY GREGORIAN DATE PROCESSING
*        ROUTINE: "YMDDATE".
SAVYMDDT EQU   SAVFCTDT       "RLINK" - "RWORK7" REGISTER SAVE
*        STATIC LOCAL STORAGE USED BY "MSGDATE".
SAVDTMSG DS  10A(0)           "RLINK" - "RWORK7" REGISTER SAVE
*        STATIC LOCAL STORAGE USED BY "CALCFACT".
SAVCLFCT DS  10A(0)           "RLINK" - "RWORK7" REGISTER SAVE
*        STATIC LOCAL STORAGE USED BY "CALCMMDD".
SAVCLMD  DS  10A(0)           "RLINK" - "RWORK7" REGISTER SAVE
*        STATIC LOCAL STORAGE USED BY "CALCYYYY".
SAVCLYYY DS  10A(0)           "RLINK" - "RWORK7" REGISTER SAVE
*        STATIC LOCAL STORAGE USED BY "CALCDDD".
SAVCLDDD DS  10A(0)           "RLINK" - "RWORK7" REGISTER SAVE
*        STATIC LOCAL STORAGE USED BY "CALCDOW".
SAVCLDOW DS  04A(0)           "RLINK" - "RWORK1" REGISTER SAVE
*        STATIC LOCAL STORAGE USED BY "CALCQTR".
SAVCLQTR EQU   SAVCLDOW       "RLINK" - "RWORK1" REGISTER SAVE
*        STATIC LOCAL STORAGE USED BY "CVDDATE".
SAVCVDDT DS  10A(0)           "RLINK" - "RWORK7" REGISTER SAVE
*
*        END OF THE DATE PROCESSING SUBROUTINE STATIC AREA.
DATEWKND DS   0D              END OF DATE SUBR STATIC STORAGE.
DATEWORK EQU   DATEWKBG,DATEWKND-DATEWKBG,C'X' LABEL STATIC STORAGE
         EJECT  ,
*********************************************
*                                           *
*        -SYSIN- DATA SET WORK AREAS        *
*                                           *
*********************************************
INFLAGS  DS    0A                    DATA SET PROCESSING FLAGS
INFLAG1  DC    AL1(00)               DATA SET STATUS FLAG
INF1EOD  EQU   X'80'                 END-OF-DATA HAS BEEN SIGNALLED
INF1OPEN EQU   X'01'                 THE DATA SET IS OPEN
INFLAG2  DC    AL1(00)               RESERVED
INFLAG3  DC    AL1(00)               RESERVED
INFLAG4  DC    AL1(00)               RESERVED
INRECCT  DC    A(0)                  INPUT RECORD COUNT
INSVOPNL DC    A(0)                  RLINK SAVE FOR "OPNINDCB"
INSVGETL DC    A(0)                  RLINK SAVE FOR "GETIN"
INSVCLSL DC    A(0)                  RLINK SAVE FOR "CLSINDCB"
INOPEN   OPEN  (0,(INPUT,LEAVE)),    OPEN MACRO LIST FORM              X
               MF=L
INEXLST  DC    A(0)
INDCB    DCB   DSORG=PS,DEVD=DA,                                       X
               DDNAME=SYSIN,MACRF=GM,                                  X
               RECFM=FB,LRECL=80
INDCBND  DS    0F                  MARK THE DCB END
INDCBSZ  EQU   INDCBND-INDCB       DCB SIZE
INAREA   DS    CL80                SYSIN DATA SET INPUT AREA
         ORG   INAREA+L'INAREA    TO END OF THE AREA
         EJECT  ,
*********************************************
*                                           *
*        -SYSPARM- DATA SET WORK AREAS      *
*                                           *
*********************************************
SPFLAGS  DS    0A                    DATA SET PROCESSING FLAGS
SPFLAG1  DC    AL1(00)               DATA SET STATUS FLAG
SPF1EOD  EQU   X'80'                 END-OF-DATA HAS BEEN SIGNALLED
SPF1OPEN EQU   X'01'                 THE DATA SET IS OPEN
SPFLAG2  DC    AL1(00)               RESERVED
SPFLAG3  DC    AL1(00)               RESERVED
SPFLAG4  DC    AL1(00)               RESERVED
SPRECCT  DC    A(0)                  SYSPARM RECORD COUNT
SPSVOPNL DC    A(0)                  RLINK SAVE FOR "OPNSPDCB"
SPSVGETL DC    A(0)                  RLINK SAVE FOR "GETSP"
SPSVCLSL DC    A(0)                  RLINK SAVE FOR "CLSSPDCB"
SPOPEN   OPEN  (0,(INPUT,LEAVE)),    OPEN MACRO LIST FORM              X
               MF=L
SPEXLST  DC    A(0)
SPDCB    DCB   DSORG=PS,DEVD=DA,                                       X
               DDNAME=SYSPARM,MACRF=GM,                                X
               RECFM=FB,LRECL=80
SPDCBND  DS    0F                  MARK THE DCB END
SPDCBSZ  EQU   SPDCBND-SPDCB       DCB SIZE
SPAREA   DS    CL80                SYSPARM DATA SET INPUT AREA
         ORG   SPAREA+L'SPAREA     TO END OF THE AREA
         EJECT  ,
*********************************************
*                                           *
*        -SYSPRINT- DATA SET WORK AREAS     *
*                                           *
*********************************************
PRFLAGS  DS    0A                    DATA SET PROCESSING FLAGS
PRFLAG1  DC    AL1(00)               DATA SET STATUS FLAG
PRF1OPEN EQU   X'01'                 THE DATA SET IS OPEN
PRFLAG2  DC    AL1(00)               RESERVED
PRFLAG3  DC    AL1(00)               RESERVED
PRFLAG4  DC    AL1(00)               RESERVED
PRSVOPNL DC    A(0)                  RLINK SAVE AREA FOR "OPNPRDCB"
PRSVCMDL DC    A(0)                  RLINK SAVE AREA FOR "PRTCMD"
PRSVCLSL DC    A(0)                  RLINK SAVE AREA FOR "CLSPRDCB"
PROPEN   OPEN  (0,(OUTPUT,LEAVE)),  OPEN MACRO LIST                    X
               MF=L
PREXLST  DC    A(0)                      EXIT LIST CONSTRUCTION AREA
PRDCB    DCB   DSORG=PS,DEVD=DA,                                       X
               DDNAME=SYSPRINT,MACRF=PM,                               X
               RECFM=FBA,LRECL=121
PRDCBND  DS    0F                  MARK THE DCB END
PRDCBSZ  EQU   PRDCBND-PRDCB       DCB SIZE
PRAREA   DS    CL121               SYSPRINT DATA SET OUTPUT AREA
         EJECT  ,
*********************************************
*                                           *
*        OPERATOR COMMAND STORAGE TABLE.    *
*        EACH ENTRY CONTAINS AN OPERATOR    *
*        COMMAND TO BE ISSUED WHEN THE      *
*        TIME INTERVAL EXPIRES.             *
*                                           *
*********************************************
TBLENDAD DC    A(0)                LAST COMMAND TABLE ENTRY ADDRESS
TABLE    DS    0A                  DESIGNATE THE START OF THE TABLE
TBLENTRY DS    0CL86               MAP COMMAND TABLE ENTRY
TBLDOMID DS    AL4                 COMMAND MESSAGE NUMBER
TBLCONID DS    YL2                 COMMAND CONSOLE ID
TBLCMD   DS    CL80                COMMAND TEXT
         DS    256CL86             ALLOW 256 COMMANDS TOTAL
         ORG   *-L'TBLENTRY        TO ORIGIN OF LAST ENTRY
TBLENDPT DS    0C                  DESIGNATE THE LAST TABLE ENTRY
         ORG    ,                  TO END OF LAST ENTRY
         SPACE 3
ENDSECT  DS    0D                  MARK THE DSECT END
LENAREA  EQU   ENDSECT-WRKAREA     LENGTH OF DSECT WORK AREA
         TITLE 'PAGEADD - MODULE INITIALIZATION PART I  '
PAGEADD  CSECT
         USING *,R15               TEMPORARY BASE
         B     BYID                BRANCH AROUND MODULE IDENTIFIER
         DC    AL1(NDID-*)         IDENTIFIER LENGTH
         DC    C'PAGEADD  '        MODULE NAME
         DC    C'VERSION 05.04 '   MODULE VERSION AND LEVEL
         DC    C'&SYSDATE '        MODULE ASSEMBLY DATE
         DC    C'&SYSTIME '        MODULE ASSEMBLY TIME
NDID     EQU   *                   MARK IDENTIFIER END
BYID     DS    0H                  BRANCH POINT AROUND IDENTIFIER
         STM   R14,R12,12(R13)     SAVE GENERAL REGISTERS
         LA    RBASE1,0(,R15)      BASE # 1
         LA    RBASE2,2048         INIT
         AR    RBASE2,RBASE2            BASE # 2 TO  4096
         LA    RBASE3,00(RBASE2,RBASE2) BASE # 3 TO  8192
         LA    RBASE4,00(RBASE3,RBASE2) BASE # 4 TO 12288
         AR    RBASE2,RBASE1       BASE # 2
         AR    RBASE3,RBASE1       BASE # 3
         AR    RBASE4,RBASE1       BASE # 4
         USING PAGEADD,RBASE1,RBASE2,RBASE3,RBASE4
         DROP  R15                 DROP TEMPORARY BASE
*
*
*        GET STORAGE FOR THE WORK  AREA
         L     R0,WORKSIZE         LOAD SIZE FOR GETMAIN
         GETMAIN RU,               GET THE WORK AREA STORAGE           X
               LOC=(BELOW,ANY),    WORK AREA LOCN (VIRT,REAL)          X
               LV=(0),             WORK AREA SIZE                      X
               SP=001              WORK AREA SUBPOOL
         ST    R1,8(,R13)              CHAIN SAVE
         ST    R13,SAVE+4-WRKAREA(,R1) AREAS TOGETHER
         LR    RSAVE,R1            WORK AREA BASE REGISTER
         USING WRKAREA,RSAVE       WORK AREA ADDRESSABILITY
*
*
*        INITIALIZE THE WORK AREA
         XC    SAVE+0(4*01),SAVE+0 CLEAR THE
         XC    SAVE+8(4*16),SAVE+8 SAVE AREA
         XC    RETURNCD,RETURNCD   RETURN CODE BUCKET
         XC    CMDCOUNT,CMDCOUNT   COUNT OF OPERATOR COMMANDS TO ISSUE
         XC    AUTHSAVE(03),AUTHSAVE       AUTHORIZATION SWITCHES
         MVI   TESTMODE,00         DEFAULT PARM=NOTEST
         MVI   MSGMODEC,00         DEFAULT PARM=MSG/MSGC
         MVI   MSGMODED,00         DEFAULT PARM=MSG/MSGD
         MVI   MSGMODES,00         DEFAULT PARM=MSG/MSGS
         MVI   MSGMODET,00         DEFAULT PARM=MSG/MSGT
         MVI   SEQMODE,00          DEFAULT PARM=SEQ
         MVI   INPMODE,00          DEFAULT PARM=INPUT
         MVI   CMDMODE,00          DEFAULT PARM=CMDS
         MVI   SIDMODE,04          DEFAULT PARM=SIDX= (EXCLUDE LIST)
         MVI   DOYMODE,04          DEFAULT PARM=DOYX= (EXCLUDE LIST)
         MVI   PRMMODE,04          DEFAULT PARM=NOPARMDD
         MVI   PMTMODE,04          DEFAULT PARM=NOPROMPT
         MVI   CNCMODE,00          DEFAULT PARM=GO
         MVI   PSEMODE,04          DEFAULT PARM=NOPAUSE
         MVI   DMCMODE,04          DEFAULT PARM=NODOMMSGC
         XC    SIDCOUNT,SIDCOUNT   SPECIFY EMPTY SMFID EXCLUDE LIST
         XC    DOYCOUNT,DOYCOUNT   SPECIFY EMPTY DOY   EXCLUDE LIST
         MVC   SPDDNAM,DFLTSPDD    ESTABLISH SYSPARM  DATASET DDNAME
         MVC   INDDNAM,DFLTINDD    ESTABLISH SYSIN    DATASET DDNAME
         MVC   DELAYTME,DFLTDLAY   ESTABLISH DEFAULT DELAY TIME
         MVC   TODTME,=F'-1'       ESTABLISH DEFAULT TOD
         MVC   BEFORTME,DFLTBFOR   ESTABLISH DEFAULT EARLIEST TIME
         MVC   AFTERTME,DFLTAFTR   ESTABLISH DEFAULT LATEST TIME
         MVC   MSGCONID,DFLTCNID   DEFAULT CONSOLE(UCM) ID
         MVC   MSGDSCCD,DFLTDSCD   DEFAULT MCS DESC  CODE
         MVC   MSGRTECD,DFLTRTCD   DEFAULT MCS ROUTE CODE
         MVC   WTODSCCD,MSGDSCCD   ASSIGN  MCS DESC  CODE
         MVC   WTORTECD,MSGRTECD   ASSIGN  MCS ROUTE CODE
         MVC   XEQCONID,DFLTXQCN   DEFAULT EXECUTION CONSOLE(UCM) ID
         MVI   XEQTRKID,00         DEFAULT ADDRESS SPACE TYPE
         MVC   DOWMASKA,DFLTDOW    DEFAULT DAY(S) OF THE WEEK
         MVC   DOWMASKB,DFLTDOW    DEFAULT DAY(S) OF THE WEEK
         MVC   DOWMASKC,DFLTDOW    DEFAULT DAY(S) OF THE WEEK
*
*
*        INITIALIZE THE -SYSIN- DCB AND ASSOCIATED AREAS
         XC    INFLAGS,INFLAGS     CLEAR THE DATA SET FLAGS
         XC    INRECCT,INRECCT     CLEAR RECORD COUNT
         MVC   INOPEN(4),OPENIN1   INITIALIZE OPEN/CLOSE LIST
         MVC   INDCB(INDCBND-INDCB),DCBIN1    DCB LIST
         LA    R1,GETINEOD         ADDRESS OF DATA END ROUTINE
         ST    R1,INEXLST          TEMPORARY STORE
         MVC   INDCB+(DCBEODAD+1-IHADCB)(3),INEXLST+1  UPDATE DCB
         LA    R1,INEXLST          ADDRESS OF EXIT LIST
         ST    R1,INEXLST          TEMPORARY STORE
         MVC   INDCB+(DCBEXLST+1-IHADCB)(3),INEXLST+1  UPDATE DCB
         LA    R1,INEXIT           OPEN EXIT ROUTINE ADDRESS
         ST    R1,INEXLST          STORE ADDRESS IN THE EXIT LIST
         MVI   INEXLST,X'85'       INDICATE DCB OPEN EXIT
*
*
*        INITIALIZE THE -SYSPARM- DCB AND ASSOCIATED AREAS
         XC    SPFLAGS,SPFLAGS     CLEAR THE DATA SET FLAGS
         XC    SPRECCT,SPRECCT     CLEAR RECORD COUNT
         MVC   SPOPEN(4),OPENSP1   INITIALIZE OPEN/CLOSE LIST
         MVC   SPDCB(SPDCBND-SPDCB),DCBSP1    DCB LIST
         LA    R1,GETSPEOD         ADDRESS OF DATA END ROUTINE
         ST    R1,SPEXLST          TEMPORARY STORE
         MVC   SPDCB+(DCBEODAD+1-IHADCB)(3),SPEXLST+1  UPDATE DCB
         LA    R1,SPEXLST          ADDRESS OF EXIT LIST
         ST    R1,SPEXLST          TEMPORARY STORE
         MVC   SPDCB+(DCBEXLST+1-IHADCB)(3),SPEXLST+1  UPDATE DCB
         LA    R1,SPEXIT           OPEN EXIT ROUTINE ADDRESS
         ST    R1,SPEXLST          STORE ADDRESS IN THE EXIT LIST
         MVI   SPEXLST,X'85'       INDICATE DCB OPEN EXIT
*
*
*        INITIALIZE THE -SYSPRINT- DCB AND ASSOCIATED AREAS
         XC    PRFLAGS,PRFLAGS     CLEAR THE DATA SET FLAGS
         MVC   PROPEN(4),OPENPR1   INITIALIZE OPEN/CLOSE LIST
         MVC   PRDCB(PRDCBND-PRDCB),DCBPR1    DCB LIST
         LA    R1,PREXLST          ADDRESS OF EXIT LIST
         ST    R1,PREXLST          TEMPORARY STORE
         MVC   PRDCB+(DCBEXLST+1-IHADCB)(3),PREXLST+1  UPDATE DCB
         LA    R1,PREXIT           OPEN EXIT ROUTINE ADDRESS
         ST    R1,PREXLST          STORE ADDRESS IN THE EXIT LIST
         MVI   PREXLST,X'85'       INDICATE DCB OPEN EXIT
         EJECT  ,
*
*
*        INITIALIZE THE EXTRACT MACRO LIST AND ISSUE THE EXTRACT MACRO.
         MVC   XEQXTRLS(XEQXTRLZ),EXTRLS1   COPY MODEL LIST FORM
         EXTRACT XEQXTRAA,MF=(E,XEQXTRLS)   ISSUE EXTRACT MACRO
*
*
*        RETRIEVE THE ADDRESS SPACE CSCB CHTRKID FIELD
*        IN ORDER TO HAVE INFORMATION AVAILABLE ON THE TYPE OF
*        ADDRESS SPACE FROM WHICH PAGEADD HAS BEEN INVOKED.
         L     R15,CVTPTR           -> CVT
         USING CVT,R15                 CVT ADDRESSABILITY
         L     R15,CVTTCBP          -> TCB/ASCB WORDS
         L     R15,ASCBPOLD(,R15)   -> OUR ASCB
         USING ASCB,R15                ASCB ADDRESSABILITY
         ICM   R15,B'1111',ASCBCSCB -> CSCB ?
         BZ    BYTRKID                 IF -> CSCB NOT PRESENT
         USING CSCDSECT,R15            CSCB ADDRESSABILITY
         ICM   R15,B'1000',CHTRKID     CSCB TRACK COMMAND ID
         DROP  R15
         SRL   R15,24               SHIFT TO LOW-ORDER BYTE
         STCM  R15,B'0001',XEQTRKID SAVE RESULT IN WORK AREA
BYTRKID  DS    0H                   END OF XEQ TRACK ID PROCESSING
*
*
*        IF PAGEADD HAS BEEN INVOKED FROM A CONSOLE-STARTED
*        PROCEDURE, PICK UP THE CONSOLE ID FROM THE START CIB
*        IF POSSIBLE.
         ICM   R1,B'1111',XEQCOMMA  COMM AREA ADDRESS FROM EXTRACT
         BZ    BYXEQCN              IF ADDRESS NOT PRESENT
         USING CHECBP,R1            COMM AREA ADDRESSABILITY
         ICM   R2,B'1111',CHCIBP    -> FIRST CIB
         BZ    BYXEQCN              IF CIB NOT PRESENT
         USING CIBNEXT,R2           CIB ADDRESSABILITY
         CLI   CIBVERB,CIBSTART     START COMMAND CIB??
         BNE   BYXEQCN              BRANCH AROUND IF NOT
         CLI   CIBCONID,00          CONSOLE ID ZERO????
         BE    BYXEQCN              BRANCH AROUND IF YES
         XC    XEQCONID,XEQCONID    CLEAR XEQCONID
         MVC   XEQCONID+L'XEQCONID-L'CIBCONID(L'CIBCONID),CIBCONID
         DROP  R1,R2
BYXEQCN  DS    0H                   END OF XEQ CONSOLE ID PROCESSING
         TITLE 'PAGEADD - ANALYZE EXEC STATEMENT PARM FIELD'
*****************************************************************
*        INITIALIZE REGISTER VALUES FOR SCANNING                *
*        THE EXEC STATEMENT PARM FIELD.                         *
*****************************************************************
PARMSCAN DS    0H                  ANALYZE PARM FIELD
         L     R1,SAVE+4           POINT TO CALLER'S SAVE AREA
         L     R1,24(,R1)          CALLER'S PARM POINTER
         L     R1,0(,R1)           -> PARM FIELD
         LH    R0,0(,R1)           LOAD PARM LENGTH
         LA    R15,2               LENGTH FIELD HEADER SIZE
         AR    R1,R15              TO FIRST PARM DATA BYTE
         BAS   RLINK,PARMANAL      GO ANALYZE PARM STRING
         TITLE 'PAGEADD - MODULE INITIALIZATION PART II '
*
*
*        OPEN THE -SYSPRINT- DCB AND TAKE THE DCB EXIT
         BAS   RLINK,OPNPRDCB      OPEN THE SYSPRINT DCB
         BNZ   RC20                DCB COULD NOT BE OPENED
         BAS   RLINK,PRTXPARM      RECORD PARM FIELD
*
*
*        IF THE PROGRAM IS RUNNING IN TEST MODE,
*        ISSUE THE WARNING MESSAGE NOW THAT SYSPRINT IS OPEN.
MODEMSG  DS    0H
         CLI   TESTMODE,00         IS PROGRAM IN TEST MODE?
         BE    NOMODMSG            BYPASS MESSAGE IF NOT
         MVC   WTOAREA(WTOMSGVZ),WTOMSGV    MOVE IN ERROR MESSAGE
         MVC   WTOCONID,MSGCONID   ASSIGN  MCS CONSOLE ID
         MVC   WTODSCCD,MSGDSCCD   ASSIGN  MCS DESC  CODE
         MVC   WTORTECD,MSGRTECD   ASSIGN  MCS ROUTE CODE
         BAS   RLINK,PRTCMD        PRINT WARNING MESSAGE AS WELL
         BAS   RLINK,WTOCMD        ISSUE WARNING MESSAGE
NOMODMSG DS    0H
         TITLE 'PAGEADD - PROCESS THE SYSPARM DATA SET'
*******************************************************
*                                                     *
*                                                     *
*        READ CARD IMAGES FROM THE SYSPARM DATA SET,  *
*        AND EVALUATE THE PARM OPTIONS AS REQUIRED.   *
*                                                     *
*                                                     *
*******************************************************
*
*
*        SEE IF THE SYSPARM DATA SET IS TO BE PROCESSED.
PRCSP0A  DS     0H
         CLI   PRMMODE,04          "NOPARMDD"??
         BE    PRCSP5              SKIP AROUND PROCESSING IF YES
*
*
*        OPEN THE SYSPARM DATA SET.
PRCSP0B  DS     0H                  OPEN SYSPARM
         BAS   RLINK,OPNSPDCB      GO TO SYSPARM OPEN ROUTINE
         BNZ   RC16                ISSUE RETURN CODE 16 IF ERROR
*
*        READ THE NEXT CARD IMAGE.
PRCSP1   DS    0H
         BAS   RLINK,GETSP         READ THE NEXT CARD IMAGE
         BZ    PRCSP4              IF AT END OF DATA SET
         CLI   SPAREA,C'*'         IS THE RECORD A COMMENT?
         BE    PRCSP1              BYPASS RECORD IF YES
*
*
*        EVALUATE THE PARM OPTIONS ON THE CARD IMAGE.
PRCSP2   DS    0H
         LA    R1,SPAREA           -> CARD IMAGE AREA
         LA    R0,72                  LENGTH OF DATA ON CARD IMAGE
         CLI   SEQMODE,04          DOES PARM DATE EXTEND BEYOND 72?
         BNE   *+L'*+4             DISCARD 73-80 IF NOT
         LA    R0,80               PROCESS ALL 80 COLUMNS
         BAS   RLINK,PARMANAL      ANALYZE PARM DATA
*
*        LOOP BACK TO GET THE NEXT CARD IMAGE.
PRCSP3   DS    0H
         B     PRCSP1              RETURN FOR THE NEXT INPUT RECORD
*
*        PROCESSING OF THE SYSPARM DATA SET IS COMPLETE.
*        CLOSE THE SYSPARM DATA SET.
PRCSP4   DS    0H
         BAS   RLINK,CLSSPDCB      CLOSE(AND FREE) THE SYSPARM DCB
*
*
*
*        FALL THRU TO CONTINUE PROCESSING.
PRCSP5   DS    0H
         BAS   RLINK,TESTAPF       TEST EXECUTION APF AUTHORIZATION
         TITLE 'PAGEADD - BUILD THE OPERATOR COMMANDS TABLE'
*
*
*        READ COMMAND IMAGES FROM PARMLIB AND STORE THE
*        IMAGES IN THE TABLE FOR EXECUTION
*        AFTER THE TIME INTERVAL ELAPSES.
*
*
*        INITIALIZE REGISTERS FOR BUILDING THE TABLE.
BLDTBL0A DS    0H
         LA    RTBL1,TABLE-L'TBLENTRY    POINT TO 0'TH TABLE ENTRY
         LA    RTBL2,L'TBLENTRY    TABLE ENTRY LENGTH
         L     RTBL3,=A(TBLENDPT-TBLENTRY)     OFFSET TO LAST ENTRY
         LA    RTBL3,TBLENTRY(RTBL3)           ADDR   OF LAST ENTRY
         ST    RTBL1,TBLENDAD      INITIALIZE LAST USED ENTRY ADDRESS
*
*
*        SEE IF THE INPUT DATA SET IS TO BE PROCESSED.
BLDTBL0B DS    0H                  OPEN SYSIN
         CLI   INPMODE,04          "NOINPUT" ??
         BE    BLDTBL9             LEAVE TABLE EMPTY IF YES
*
*
*        OPEN THE SYSIN DATA SET.
BLDTBL0C DS    0H                  OPEN SYSIN
         BAS   RLINK,OPNINDCB      GO TO SYSIN OPEN ROUTINE
         BNZ   RC16                ISSUE RETURN CODE 16 IF ERROR
*
*        READ THE NEXT OPERATOR COMMAND.
BLDTBL1  DS    0H
         BXH   RTBL1,RTBL2,BLDTBL6 IF TABLE CAPACITY EXCEEDED
         USING TBLENTRY,RTBL1      TABLE ENTRY ADDRESSABILITY
BLDTBL1A DS    0H
         BAS   RLINK,GETIN         READ THE NEXT CARD IMAGE
         BZ    BLDTBL7             IF AT END OF DATA SET
         CLI   INAREA,C'*'         IS THE RECORD A COMMENT?
         BE    BLDTBL1A            BYPASS RECORD IF YES
*
*
*        ADD THE OPERATOR COMMAND TO THE TABLE.
BLDTBL2  DS    0H
         ST    RTBL1,TBLENDAD      UPDATE THE TABLE END ADDRESS
         XC    TBLDOMID,TBLDOMID   CLEAR DOMID FIELD IN TABLE ENTRY
         MVC   TBLCONID,MSGCONID   ASSIGN DEFLT CONSOLE FOR COMMAND
         MVI   TBLCMD,X'40'         CLEAR
         MVC   TBLCMD+1(L'TBLCMD-1),TBLCMD
         CLC   INAREA(02),=C'/*'    STRIP COMMAND
         BE    BLDTBL2A             FROM
         CLC   INAREA(02),=C'//'    JCL
         BE    BLDTBL2A             INPUT
         CLC   INAREA(03),=C'CN('  CHECK
         BNE   *+L'*+4+4           FOR
         CLI   INAREA+05,C')'      CONSOLE ID
         BE    BLDTBL2B            SUPPLIED
         B     BLDTBL2F            COMMAND IS "AS IS"
*
*        THE COMMAND IS PRECEEDED BY A "/*" OR "//".
*        COPY THE COMMAND IMAGE TO THE TABLE ENTRY.
BLDTBL2A DS    0H                  COMMAND IS PRECEDED BY "/*" OR "//"
         MVC   TBLCMD+00(70),INAREA+02   COPY OPERATOR COMMAND
         CLI   SEQMODE,04                DOES COMMAND EXTEND BEYOND 72?
         BNE   *+L'*+6                   DISCARD 73-80 IF NOT
         MVC   TBLCMD+70(08),INAREA+72   SEQUENCE FIELD PORTION
         B     BLDTBL2Z            GO ADD 1 TO COUNT
*
*        THE COMMAND IS PRECEEDED BY "CN(??)"
*        EXTRACT THE CONSOLE ID.
BLDTBL2B DS    0H                  COMMAND IS PRECEDED BY CONSOLE ID
         SR    R0,R0               CLEAR CONSOLE ID REGISTER
         ICM   R0,B'0011',INAREA+03      LOAD EBCDIC CONSOLE ID
         CLM   R0,B'0011',=C'**'   REQUEST XEQ CONSOLE ID?
         BE    BLDTBL2C            STORE UNCONVERTED IF YES
         CLM   R0,B'0011',=C'MC'   REQUEST MASTER CONSOLE ID?
         BE    BLDTBL2C            STORE UNCONVERTED IF YES
         CLI   INAREA+03,C'0'      VERIFY
         BL    BLDTBL2E            THAT
         CLI   INAREA+03,C'9'      CONSOLE
         BH    BLDTBL2E            ID
         CLI   INAREA+04,C'0'      IS
         BL    BLDTBL2E            NUMERIC
         CLI   INAREA+04,C'9'      .
         BH    BLDTBL2E            .
         PACK  PACKAREA,INAREA+03(02)      PACK CONSOLE ID
         CVB   R0,PACKAREA         CONSOLE ID TO BINARY
*
*        STORE THE CONSOLE IDENTIFIER IN THE TABLE ENTRY.
BLDTBL2C DS    0H                  COMMAND IS PRECEDED BY CONSOLE ID
         STCM  R0,B'0011',TBLCONID STORE CONSOLE ID IN TABLE
*
*        THE COMMAND IS PRECEEDED BY "CN(??)".
*        COPY THE COMMAND IMAGE TO THE TABLE ENTRY.
BLDTBL2E DS    0H
         MVC   TBLCMD+00(66),INAREA+06   COPY OPERATOR COMMAND
         CLI   SEQMODE,04                DOES COMMAND EXTEND BEYOND 72?
         BNE   *+L'*+6                   DISCARD 73-80 IF NOT
         MVC   TBLCMD+66(08),INAREA+72   SEQUENCE FIELD PORTION
         B     BLDTBL2Z            GO ADD 1 TO COUNT
*
*        THE COMMAND IS ACCEPTABLE AS IT IS
*        COPY THE COMMAND IMAGE TO THE TABLE ENTRY.
BLDTBL2F DS    0H                  COMMAND IS ON THE CARD AS IS
         MVC   TBLCMD+00(72),INAREA+00   COPY OPERATOR COMMAND
         CLI   SEQMODE,04                DOES COMMAND EXTEND BEYOND 72?
         BNE   *+L'*+6                   DISCARD 73-80 IF NOT
         MVC   TBLCMD+72(08),INAREA+72   SEQUENCE FIELD PORTION
         B     BLDTBL2Z            GO ADD 1 TO COUNT
BLDTBL2Z DS    0H                  UPDATE COMMAND COUNT
         L     R1,CMDCOUNT         LOAD COMMAND COUNT
         A     R1,F1               ADD 1 TO IT
         ST    R1,CMDCOUNT         STORE UPDATED COUNT
*
*        LOOP BACK TO GET THE NEXT OPERATOR COMMAND.
BLDTBL3  DS    0H                  THE MATCHING TABLE ENTRY WAS FOUND
         B     BLDTBL1             RETURN FOR THE NEXT INPUT RECORD
         DROP  RTBL1               DROP TABLE ENTRY ADDRESSABILITY
*
*        THE PHYSICAL CAPACITY OF THE TABLE HAS BEEN EXCEEDED.
*        ISSUE AN ERROR MESSAGE AND PROCESS THE ENTRIES
*        THAT WERE ENTERED IN THE TABLE.
BLDTBL6  DS    0H
         MVC   WTOAREA(WTOMSGTZ),WTOMSGT          MOVE ERROR MSG
         MVC   WTOCONID,MSGCONID   ASSIGN  MCS CONSOLE ID
         MVC   WTODSCCD,MSGDSCCD   ASSIGN  MCS DESC  CODE
         MVC   WTORTECD,MSGRTECD   ASSIGN  MCS ROUTE CODE
         BAS   RLINK,PRTCMD        PRINT ERROR MESSAGE
         BAS   RLINK,WTOCMD        WRITE ERROR MSG TO OPERATOR
*
*        BUILDING OF THE OPERATOR COMMAND TABLE IS COMPLETE.
*        CLOSE THE INPUT DATA SET AND TEST FOR COMMANDS
*        TO BE PROCESSED.
BLDTBL7  DS    0H
         BAS   RLINK,CLSINDCB      CLOSE(AND FREE) THE PARMLIB DCB
         ICM   R1,B'1111',CMDCOUNT LOAD AND TEST COMMAND COUNT
         BNZ   BLDTBL9             CAN CONTINUE IF NON-ZERO
*
*        NO COMMANDS WERE ENTERED IN THE TABLE.
*        ISSUE AN ERROR MESSAGE AND EXIT WITH RETURN CODE 12.
BLDTBL8  DS    0H
         MVC   WTOAREA(WTOMSGLZ),WTOMSGL   MESSAGE SKELETON
         MVC   WTOCONID,MSGCONID   ASSIGN  MCS CONSOLE ID
         MVC   WTODSCCD,MSGDSCCD   ASSIGN  MCS DESC  CODE
         MVC   WTORTECD,MSGRTECD   ASSIGN  MCS ROUTE CODE
         BAS   RLINK,PRTCMD        PRINT THE ERROR MESSAGE
         BAS   RLINK,WTOCMD        WRITE ERROR MSG TO OPERATOR
         B     RC12                ISSUE RETURN CODE 12
*
*        OPERATOR COMMANDS WERE ENTERED IN THE TABLE,
*        OR THE "NOINPUT" PARM FIELD OPTION WAS SPECIFIED;
*        FALL THRU TO CONTINUE PROCESSING.
BLDTBL9  DS    0H
         TITLE 'PAGEADD - DETERMINE WHETHER COMMANDS CAN BE EXECUTED'
         SPACE 3
XEQANAL  DS    0H                  ANALYZE EXECUTION ENVIRONMENT
         MVI   XEQMODE,00          INITIALIZE TEST RESULTS TO 00 (OK)
         MVI   CNCMODE,00          TURN OFF OPERATOR CANCEL
         BAS   RLINK,TESTAPF       TEST EXECUTION APF AUTHORIZATION
         SPACE 5
*
*
*        GET THE SYSTEM'S SMF ID.
GETSMFID DS    0H
         L     R1,CVTPTR           -> CVT
         USING CVT,R1              CVT ADDRESSABILITY
         L     R1,CVTSMCA          -> SMCA
         USING SMCABASE,R1         SMCA ADDRESSABILITY
         ICM   R1,B'1111',SMCASID  LOAD SYSTEM'S SMF ID
         DROP R1
         ST    R1,XEQSID           SAVE SMF SYSTEM IDENTIFIER
         SPACE 5
*
*
*        GET THE CURRENT TIME OF DAY FROM THE SYSTEM
GETXEQTM DS    0H
         TIME  BIN                 GET TIME IN 1/100 SECONDS
         ST    R0,XEQTME           SAVE EXECUTION TIME VALUE
         ST    R1,XEQDATE          SAVE EXECUTION DATE VALUE
         LR    R15,R0              COPY TIME TO R15
         BAS   RLINK,PRMSCETM      CONVERT BINARY TIME TO EBCDIC
         STM   R2,R3,XEQDEC        SAVE EBCDIC DECIMAL TIME-OF-DAY
         SPACE 2
         L     R15,XEQDATE         LOAD CURRENT EXECUTION DATE
         BAS   RLINK,JULDATE       GO CALCULATE DATE VALUES
         CLI   TESTMODE,04         IS PROGRAM IN TEST MODE?
         BNE   *+L'*+4             BRANCH AROUND IF NOT
         BAS   RLINK,MSGDATE       GO ISSUE DIAGNOSTIC MESSAGE
         EJECT  ,
*
*        SEE IF WE ARE EXECUTING ON A SYSTEM ON WHICH EXECUTION
*        OF THE COMMANDS IS AUTHORIZED.
CHKSMFID DS    0H
         LA    R15,L'SIDLIST          SID LIST ENTRY LENGTH
         LA    R0,00               ASSUME SID NOT FOUND IN LIST
         SR    R1,R1               CLEAR REGISTER
         IC    R1,SIDMODE          LOAD SEARCH MODE VALUE
         LA    R2,SIDLIST          -> SID LIST
*
*        SEARCH THE SID LIST FOR THE CURRENT SYSTEM'S SMF ID
CHKSMFL0 DS    0H
         ICM   R3,B'1111',SIDCOUNT LOAD # OF SID ENTRIES IN LIST
         BNP   CHKSMFL3            END OF SEARCH CODE
CHKSMFL1 DS    0H
         CLC   XEQSID,00(R2)       COMPARE SID TO LIST ENTRY
         BE    CHKSMFL2            IF SID FOUND IN LIST
         AR    R2,R15              TO NEXT LIST ENTRY
         BCT   R3,CHKSMFL1         CONTINUE SCANNING LIST
         LA    R0,00               INDICATE SID NOT FOUND IN LIST
         B     CHKSMFL3            LIST SCAN COMPLETE
CHKSMFL2 DS    0H
         LA    R0,04               INDICATE SID FOUND IN LIST
CHKSMFL3 DS    0H                  SID LIST LOOKUP COMPLETE
*
*        TO DETERMINE WHETHER COMMANDS ARE AUTHORIZED ON THIS SYSTEM,
*        WE EXCLUSIVE "OR" THE SID FOUND INDICATOR WITH THE SIDMODE
*        VALUE.  A NON-ZERO RESULT (INCLUDE+FOUND OR EXCLUDE+NOTFOUND)
*        INDICATES THAT COMMANDS ARE AUTHORIZED.  A ZERO RESULT
*        (INCLUDE+NOTFOUND OR EXCLUDE+FOUND) INDICATES COMMANDS
*        ARE NOT AUTHORIZED.
         XR    R0,R1               X-OR SIDMODE WITH SEARCH RESULT
         BNZ   SMFIDOK             IF ONE OR THE OTHER BUT NOT BOTH    X
                                   IS 04, CMDS ARE OK ON THIS SYSTEM
*
*        COMMAND EXECUTION IS NOT AUTHORIZED BECAUSE OF SYSTEM ID.
*        ASSEMBLE AND ISSUE AN ERROR MESSAGE.
         MVC   WTOAREA(WTOMSG3Z),WTOMSG3        MSG SKELETON
         MVC   WTOCONID,MSGCONID   ASSIGN  MCS CONSOLE ID
         MVC   WTODSCCD,MSGDSCCD   ASSIGN  MCS DESC  CODE
         MVC   WTORTECD,MSGRTECD   ASSIGN  MCS ROUTE CODE
         MVC   WTOMSG+040(04),XEQSID            XEQ SYSTEM IDENTIFIER
         MVC   WTOMSG+049(15),=C'NOT INCLUDED IN'
         MVC   WTOMSG+069(04),=C'SID='
         CLI   SIDMODE,00                       "SID=" ??
         BE    *+L'*+6+6                        BR AROUND IF YES
         MVC   WTOMSG+049(15),=C' EXCLUDED  FROM'
         MVC   WTOMSG+069(05),=C'SIDX='
         BAS   RLINK,PRTCMD       PRINT MESSAGE ON THE PRINTER
         CLI   MSGMODES,04        ARE SID MESSAGES SUPPRESSED?
         BE    NOMSGSID           BYPASS MESSAGE IF YES
         BAS   RLINK,WTOCMD       ISSUE OPERATOR MESSAGE
NOMSGSID DS    0H
         MVI   XEQMODE,04         INDICATE TEST FAILED
SMFIDOK  DS    0H
         EJECT  ,
*******************************************************
*                                                     *
*        SEE IF COMMAND EXECUTION IS AUTHORIZED       *
*        ON TODAY'S DAY OF THE YEAR.                  *
*                                                     *
*******************************************************
CHKDOY   DS    0H
         LA    R15,L'DOYLIST          DOY LIST ENTRY LENGTH
         LA    R0,00               ASSUME DOY NOT FOUND IN LIST
         SR    R1,R1               CLEAR REGISTER
         IC    R1,DOYMODE          LOAD SEARCH MODE VALUE
         LA    R2,DOYLIST          -> DOY LIST
*
*        SEARCH THE DOY LIST FOR TODAY'S DATE.
CHKDOYL0 DS    0H
         ICM   R3,B'1111',DOYCOUNT LOAD # OF DOY ENTRIES IN LIST
         BNP   CHKDOYL3            END OF SEARCH CODE
CHKDOYL1 DS    0H
         CP    XEQDATE,0(L'DOYLIST,R2) COMPARE TODAY'S DATE TO LIST
         BE    CHKDOYL2            IF TODAY FOUND IN LIST
         AR    R2,R15              TO NEXT LIST ENTRY
         BCT   R3,CHKDOYL1         CONTINUE SCANNING LIST
         LA    R0,00               INDICATE TODAY NOT FOUND IN LIST
         B     CHKDOYL3            LIST SCAN COMPLETE
CHKDOYL2 DS    0H
         LA    R0,04               INDICATE DOY FOUND IN LIST
CHKDOYL3 DS    0H                  DOY LIST LOOKUP COMPLETE
*
*        TO DETERMINE WHETHER COMMANDS ARE AUTHORIZED BY DAY-OF-YEAR,
*        WE EXCLUSIVE "OR" THE DOY FOUND INDICATOR WITH THE DOYMODE
*        VALUE.  A NON-ZERO RESULT (INCLUDE+FOUND OR EXCLUDE+NOTFOUND)
*        INDICATES THAT COMMANDS ARE AUTHORIZED.  A ZERO RESULT
*        (INCLUDE+NOTFOUND OR EXCLUDE+FOUND) INDICATES COMMANDS
*        ARE NOT AUTHORIZED.
         XR    R0,R1               X-OR DOYMODE WITH SEARCH RESULT
         BNZ   DOYOK               IF ONE OR THE OTHER BUT NOT BOTH    X
                                   IS 04, CMDS ARE OK ON THIS DATE
*
*        COMMAND EXECUTION IS NOT AUTHORIZED BECAUSE TODAY'S DATE
*        WAS EITHER NOT INCLUDED OR WAS EXCLUDED.
*        ASSEMBLE AND ISSUE AN ERROR MESSAGE.
         MVC   WTOAREA(WTOMSG4Z),WTOMSG4        MSG SKELETON
         MVC   WTOCONID,MSGCONID   ASSIGN  MCS CONSOLE ID
         MVC   WTODSCCD,MSGDSCCD   ASSIGN  MCS DESC  CODE
         MVC   WTORTECD,MSGRTECD   ASSIGN  MCS ROUTE CODE
         MVC   WTOMSG+041(07),=X'F021204B202020'    EDIT MASK
         ED    WTOMSG+041(07),XEQDATE+01        XEQ YY.DDD
         MVI   WTOMSG+041,C'='                  RESTORE "="
         MVC   WTOMSG+048(10),=X'F0202120612020612020'
         ED    WTOMSG+048(10),DATMDY            EDIT MM/DD/YY
         MVI   WTOMSG+048,C' '                  RESTORE BLANK
         MVI   WTOMSG+049,C'('                  RESTORE "("
         MVC   WTOMSG+060(15),=C'NOT INCLUDED IN'
         MVC   WTOMSG+081(04),=C'DOY='
         MVC   WTOMSG+086(04),=C'MDY='
         CLI   DOYMODE,00                       "DOY=" ??
         BE    *+L'*+6+6+6                      BR AROUND IF YES
         MVC   WTOMSG+060(15),=C' EXCLUDED  FROM'
         MVC   WTOMSG+080(05),=C'DOYX='
         MVC   WTOMSG+086(05),=C'MDYX='
         BAS   RLINK,PRTCMD       PRINT MESSAGE ON THE PRINTER
         CLI   MSGMODED,04        ARE DOY MESSAGES SUPPRESSED?
         BE    NOMSGDOY           BYPASS MESSAGE IF YES
         BAS   RLINK,WTOCMD       ISSUE OPERATOR MESSAGE
NOMSGDOY DS    0H
         MVI   XEQMODE,04         INDICATE TEST FAILED
DOYOK    DS    0H
         EJECT  ,
*
*
*        SEE IF THE COMMANDS CAN BE EXECUTED ON THE
*        CURRENT DAY OF THE WEEK.
CHKDOW   DS    0H
         L     R15,DATDOW          DAY-OF-WEEK IN R15
         LA    RLINK,B'10000000'   LOAD MASK TEST BIT
         SRL   RLINK,0(R15)        SHIFT FOR DAY OF THE WEEK
*
*        DETERMINE THE MASK TO TEST FOR DOW.
         CLC   AFTERTME,BEFORTME   COMPARE AFTER TIME TO BEFORE TIME
         BNL   CHKDOWXC            IF BEFORE EARLIER THAN AFTER - MASKC
         CLC   XEQTME,AFTERTME     COMPARE XEQ   TIME TO AFTER  TIME
         BL    CHKDOWXA            IF BETWEEN 00:00:00.00 & AFTER TIME
         CLC   XEQTME,BEFORTME     COMPARE XEQ   TIME TO BEFORE TIME
         BNL   CHKDOWXB            IF BETWEEN BEFORE TIME & 24:00:00.00
         B     DOWOK               IF DOW TEST NOT APPLICABLE
CHKDOWXA EX    RLINK,CHKDOWA       TEST "DOWMASKA" FOR BIT SET
         B     CHKDOWXT            TEST CC FROM EXECUTED "TM"
CHKDOWXB EX    RLINK,CHKDOWB       TEST "DOWMASKB" FOR BIT SET
         B     CHKDOWXT            TEST CC FROM EXECUTED "TM"
CHKDOWXC EX    RLINK,CHKDOWC       TEST "DOWMASKC" FOR BIT SET
CHKDOWXT BO    DOWOK               IF YES, OK TO ISSUE CMDS TODAY
CHKDOWXZ DS    0H                  IF DOW TEST FAILED
         MVC   WTOAREA(WTOMSG5Z),WTOMSG5        MSG SKELETON
         MVC   WTOCONID,MSGCONID   ASSIGN  MCS CONSOLE ID
         MVC   WTODSCCD,MSGDSCCD   ASSIGN  MCS DESC  CODE
         MVC   WTORTECD,MSGRTECD   ASSIGN  MCS ROUTE CODE
         MVC   WTOMSG+041(07),=X'F021204B202020'    EDIT MASK
         ED    WTOMSG+041(07),XEQDATE+01        XEQ YY.DDD
         MVI   WTOMSG+041,C'='                  RESTORE "="
         LM    R0,R3,DATMM                      RESTORE MM,DD,DDD,YYYY
         MH    R0,=Y(100)                       MM*100
         AR    R0,R1                            +DD
         MH    R0,=Y(100)                       *100
         LH    R1,=Y(100)                       LOAD DIVISOR
         SR    R2,R2                            CLEAR R2 FOR DIVIDE
         DR    R2,R1                            GET YY IN R2
         AR    R0,R2                            +YY
         CVD   R0,PACKAREA                      MMDDYY TO DEC
         MVC   WTOMSG+048(10),=X'F0202120612020612020'
         ED    WTOMSG+048(10),PACKAREA+04       EDIT MM/DD/YY
         MVI   WTOMSG+048,C' '                  RESTORE BLANK
         MVI   WTOMSG+049,C'('                  RESTORE "("
         L     RLINK,DATDOW                     RELOAD DAY OF WEEK
         MH    RLINK,=Y(03)                     *3 FOR TABLE ENTRY LN
         LA    RLINK,DOWTABLE(RLINK)            -> DOW CHARS
         MVC   WTOMSG+064(03),0(RLINK)          DAY OF WEEK
*
*        DETERMINE THE KEYWORD VALUE TO INSERT IN THE MESSAGE.
         CLC   AFTERTME,BEFORTME   COMPARE AFTER TIME TO BEFORE TIME
         BNL   CHKDOWMC            IF BEFORE EARLIER THAN AFTER - MASKC
         CLC   XEQTME,AFTERTME     COMPARE XEQ   TIME TO AFTER  TIME
         BL    CHKDOWMA            IF BETWEEN 00:00:00.00 & AFTER TIME
         CLC   XEQTME,BEFORTME     COMPARE XEQ   TIME TO BEFORE TIME
         BNL   CHKDOWMB            IF BETWEEN BEFORE TIME & 24:00:00.00
         B     CHKDOWMC            IF THIS SHOULD NEVER HAPPENS HAPPENS
CHKDOWMA DS    0H
         CLC   DOWMASKA,DOWMASKC   BOTH MASKS THE SAME?????
         BE    CHKDOWMC            SPECIFY "DOW=" IF YES"
         MVC   WTOMSG+097(05),=C'DOWA='           "DOWA="
         B     CHKDOWMZ
CHKDOWMB DS    0H
         CLC   DOWMASKB,DOWMASKC   BOTH MASKS THE SAME?????
         BE    CHKDOWMC            SPECIFY "DOW=" IF YES"
         MVC   WTOMSG+097(05),=C'DOWB='           "DOWB="
         B     CHKDOWMZ
CHKDOWMC MVC   WTOMSG+097(04),=C'DOW='            "DOW="
CHKDOWMZ DS    0H                  IF DOW TEST FAILED
         BAS   RLINK,PRTCMD       PRINT MESSAGE ON THE PRINTER
         CLI   MSGMODED,04        ARE DAY-OF-WEEK MESSAGES SUPPRESSED?
         BE    NOMSGDOW           BYPASS MESSAGE IF YES
         BAS   RLINK,WTOCMD       ISSUE OPERATOR MESSAGE
NOMSGDOW DS    0H
         MVI   XEQMODE,04         INDICATE TEST FAILED
         B     DOWOK              CONTINUE PROCESSING
CHKDOWA  TM    DOWMASKA,*-*       *****EXECUTED*****
CHKDOWB  TM    DOWMASKB,*-*       *****EXECUTED*****
CHKDOWC  TM    DOWMASKC,*-*       *****EXECUTED*****
DOWOK    DS    0H
         EJECT  ,
***************************************************************
*                                                             *
*        SEE IF WE ARE EXECUTING EARLIER THAN THE COMMANDS    *
*        CAN BE EXECUTED VALIDLY WHEN THE AFTER TIME          *
*        SPECIFICATION IS LATER THAN THE BEFORE TIME          *
*        SPECIFICATION.                                       *
*                                                             *
***************************************************************
CHKBFXEQ DS    0H
         CLC   AFTERTME,BEFORTME   COMPARE AFTER TIME TO BEFORE TIME
         BL    BFRXEQOK            IF THIS TEST NOT PERTINENT
         L     R15,XEQTME          LOAD CURRENT EXECUTION TIME
         C     R15,BEFORTME        COMPARE EARLIEST TIME TO TOD
         BNL   BFRXEQOK            IF NOT EARLIER THAN TIME
         MVC   WTOAREA(WTOMSG7Z),WTOMSG7        MSG SKELETON
         MVC   WTOCONID,MSGCONID   ASSIGN  MCS CONSOLE ID
         MVC   WTODSCCD,MSGDSCCD   ASSIGN  MCS DESC  CODE
         MVC   WTORTECD,MSGRTECD   ASSIGN  MCS ROUTE CODE
         MVC   WTOMSG+042(02),XEQDEC+00         XEQ HOURS
         MVC   WTOMSG+045(02),XEQDEC+02         XEQ MINUTES
         MVC   WTOMSG+048(02),XEQDEC+04         XEQ SECONDS
         MVC   WTOMSG+067(02),BEFORDEC+00       TIME HOURS
         MVC   WTOMSG+070(02),BEFORDEC+02       TIME MINUTES
         MVC   WTOMSG+073(02),BEFORDEC+04       TIME SECONDS
         BAS   RLINK,PRTCMD       PRINT MESSAGE ON THE PRINTER
         CLI   MSGMODET,04        ARE TIME MESSAGES SUPPRESSED?
         BE    NOMSGBFX           BYPASS MESSAGE IF YES
         BAS   RLINK,WTOCMD       ISSUE OPERATOR MESSAGE
NOMSGBFX DS    0H
         MVI   XEQMODE,04         INDICATE TEST FAILED
BFRXEQOK DS    0H
         EJECT  ,
***************************************************************
*                                                             *
*        SEE IF THE COMMAND EXECUTION (TOD=) TIME OF DAY      *
*        SPECIFICATION IS EARLIER THAN THE "BEFORE=" TIME     *
*        WHEN THE "AFTER=" TIME SPECIFICATION IS LATER        *
*        THAN THE "BEFORE=" TIME SPECIFICATION.               *
*                                                             *
***************************************************************
CHKBFTOD DS    0H
         CLC   AFTERTME,BEFORTME   COMPARE AFTER TIME TO BEFORE TIME
         BL    BFRTODOK            IF THIS TEST NOT PERTINENT
         ICM   R15,B'1111',TODTME  "TOD=" KEYWORD SPECIFIED??
         BM    BFRTODOK            IF "TOD=" NOT SPECIFIED
         C     R15,BEFORTME        COMPARE TOD TO EARLIEST TIME
         BNL   BFRTODOK            IF NOT EARLIER THAN "BEFORE="
         MVC   WTOAREA(WTOMSG7Z),WTOMSG7        MSG SKELETON
         MVC   WTOCONID,MSGCONID   ASSIGN  MCS CONSOLE ID
         MVC   WTODSCCD,MSGDSCCD   ASSIGN  MCS DESC  CODE
         MVC   WTORTECD,MSGRTECD   ASSIGN  MCS ROUTE CODE
         MVC   WTOMSG+033(03),=C'TOD='          "TOD"
         MVC   WTOMSG+042(02),TODDEC+00         TOD HOURS
         MVC   WTOMSG+045(02),TODDEC+02         TOD MINUTES
         MVC   WTOMSG+048(02),TODDEC+04         TOD SECONDS
         MVC   WTOMSG+067(02),BEFORDEC+00       TIME HOURS
         MVC   WTOMSG+070(02),BEFORDEC+02       TIME MINUTES
         MVC   WTOMSG+073(02),BEFORDEC+04       TIME SECONDS
         BAS   RLINK,PRTCMD       PRINT MESSAGE ON THE PRINTER
         CLI   MSGMODET,04        ARE TIME MESSAGES SUPPRESSED?
         BE    NOMSGBFT           BYPASS MESSAGE IF YES
         BAS   RLINK,WTOCMD       ISSUE OPERATOR MESSAGE
NOMSGBFT DS    0H
         MVI   XEQMODE,04         INDICATE TEST FAILED
BFRTODOK DS    0H
         EJECT  ,
***************************************************************
*                                                             *
*        SEE IF WE ARE EXECUTING LATER THAN THE COMMANDS CAN  *
*        BE EXECUTED VALIDLY WHEN THE AFTER TIME              *
*        SPECIFICATION IS LATER THAN THE BEFORE TIME          *
*        SPECIFICATION.                                       *
*                                                             *
***************************************************************
CHKAFXEQ DS    0H
         CLC   AFTERTME,BEFORTME   COMPARE AFTER TIME TO BEFORE TIME
         BL    AFTXEQOK            IF THIS TEST NOT PERTINENT
         L     R15,XEQTME          LOAD CURRENT EXECUTION TIME
         C     R15,AFTERTME        COMPARE LATEST TIME TO TOD
         BL    AFTXEQOK            IF NOT LATER THAN TIME
         MVC   WTOAREA(WTOMSG8Z),WTOMSG8        MSG SKELETON
         MVC   WTOCONID,MSGCONID   ASSIGN  MCS CONSOLE ID
         MVC   WTODSCCD,MSGDSCCD   ASSIGN  MCS DESC  CODE
         MVC   WTORTECD,MSGRTECD   ASSIGN  MCS ROUTE CODE
         MVC   WTOMSG+042(02),XEQDEC+00         XEQ HOURS
         MVC   WTOMSG+045(02),XEQDEC+02         XEQ MINUTES
         MVC   WTOMSG+048(02),XEQDEC+04         XEQ SECONDS
         MVC   WTOMSG+065(02),AFTERDEC+00       TIME HOURS
         MVC   WTOMSG+068(02),AFTERDEC+02       TIME MINUTES
         MVC   WTOMSG+071(02),AFTERDEC+04       TIME SECONDS
         BAS   RLINK,PRTCMD       PRINT MESSAGE ON THE PRINTER
         CLI   MSGMODET,04        ARE TIME MESSAGES SUPPRESSED?
         BE    NOMSGAFX           BYPASS MESSAGE IF YES
         BAS   RLINK,WTOCMD       ISSUE OPERATOR MESSAGE
NOMSGAFX DS    0H
         MVI   XEQMODE,04         INDICATE TEST FAILED
AFTXEQOK DS    0H
         EJECT  ,
***************************************************************
*                                                             *
*        SEE IF THE COMMAND EXECUTION (TOD=) TIME OF DAY      *
*        SPECIFICATION IS LATER THAN THE "AFTER=" TIME        *
*        WHEN THE "AFTER=" TIME SPECIFICATION IS LATER        *
*        THAN THE "BEFORE=" TIME SPECIFICATION.               *
*                                                             *
***************************************************************
CHKAFTOD DS    0H
         CLC   AFTERTME,BEFORTME   COMPARE AFTER TIME TO BEFORE TIME
         BL    AFTTODOK            IF THIS TEST NOT PERTINENT
         ICM   R15,B'1111',TODTME  WAS "TOD=" SPECIFIED??
         BM    AFTTODOK            IF "TOD=" NOT SPECIFIED
         C     R15,AFTERTME        COMPARE TOD TO LATEST TIME
         BL    AFTTODOK            IF NOT LATER THAN TIME
         MVC   WTOAREA(WTOMSG8Z),WTOMSG8        MSG SKELETON
         MVC   WTOCONID,MSGCONID   ASSIGN  MCS CONSOLE ID
         MVC   WTODSCCD,MSGDSCCD   ASSIGN  MCS DESC  CODE
         MVC   WTORTECD,MSGRTECD   ASSIGN  MCS ROUTE CODE
         MVC   WTOMSG+033(03),=C'TOD='          "TOD"
         MVC   WTOMSG+042(02),TODDEC+00         TOD HOURS
         MVC   WTOMSG+045(02),TODDEC+02         TOD MINUTES
         MVC   WTOMSG+048(02),TODDEC+04         TOD SECONDS
         MVC   WTOMSG+065(02),AFTERDEC+00       TIME HOURS
         MVC   WTOMSG+068(02),AFTERDEC+02       TIME MINUTES
         MVC   WTOMSG+071(02),AFTERDEC+04       TIME SECONDS
         BAS   RLINK,PRTCMD       PRINT MESSAGE ON THE PRINTER
         CLI   MSGMODET,04        ARE TIME MESSAGES SUPPRESSED?
         BE    NOMSGAFT           BYPASS MESSAGE IF YES
         BAS   RLINK,WTOCMD       ISSUE OPERATOR MESSAGE
NOMSGAFT DS    0H
         MVI   XEQMODE,04         INDICATE TEST FAILED
AFTTODOK DS    0H
         EJECT  ,
***************************************************************
*                                                             *
*        SEE IF WE ARE EXECUTING AT A TIME WHEN COMMANDS CAN  *
*        BE EXECUTED VALIDLY WHEN THE AFTER TIME              *
*        SPECIFICATION IS EARLIER THAN THE BEFORE TIME        *
*        SPECIFICATION.                                       *
*                                                             *
***************************************************************
CHKBTXEQ DS    0H
         CLC   AFTERTME,BEFORTME   COMPARE AFTER TIME TO BEFORE TIME
         BNL   BTWXEQOK            IF THIS TEST NOT PERTINENT
         L     R15,XEQTME          LOAD CURRENT EXECUTION TIME
         C     R15,AFTERTME        COMPARE LATEST TIME TO TOD
         BL    BTWXEQOK            IF NOT LATER THAN TIME
         C     R15,BEFORTME        COMPARE EARLIEST TIME TO TOD
         BNL   BTWXEQOK            IF NOT LATER THAN TIME
         MVC   WTOAREA(WTOMSG9Z),WTOMSG9        MSG SKELETON
         MVC   WTOCONID,MSGCONID   ASSIGN  MCS CONSOLE ID
         MVC   WTODSCCD,MSGDSCCD   ASSIGN  MCS DESC  CODE
         MVC   WTORTECD,MSGRTECD   ASSIGN  MCS ROUTE CODE
         MVC   WTOMSG+042(02),XEQDEC+00         XEQ HOURS
         MVC   WTOMSG+045(02),XEQDEC+02         XEQ MINUTES
         MVC   WTOMSG+048(02),XEQDEC+04         XEQ SECONDS
         MVC   WTOMSG+065(02),AFTERDEC+00       TIME HOURS
         MVC   WTOMSG+068(02),AFTERDEC+02       TIME MINUTES
         MVC   WTOMSG+071(02),AFTERDEC+04       TIME SECONDS
         MVC   WTOMSG+091(02),BEFORDEC+00       TIME HOURS
         MVC   WTOMSG+094(02),BEFORDEC+02       TIME MINUTES
         MVC   WTOMSG+097(02),BEFORDEC+04       TIME SECONDS
         BAS   RLINK,PRTCMD       PRINT MESSAGE ON THE PRINTER
         CLI   MSGMODET,04        ARE TIME MESSAGES SUPPRESSED?
         BE    NOMSGBTX           BYPASS MESSAGE IF YES
         BAS   RLINK,WTOCMD       ISSUE OPERATOR MESSAGE
NOMSGBTX DS    0H
         MVI   XEQMODE,04         INDICATE TEST FAILED
BTWXEQOK DS    0H
         EJECT  ,
***************************************************************
*                                                             *
*        SEE IF THE COMMAND EXECUTION (TOD=) TIME IS EITHER   *
*        BETWEEN 00:00:00.00 AND "AFTER=" OR BETWEEN          *
*        "BEFORE=" AND 24:00:00.00 WHEN "AFTER=" HAS BEEN     *
*        SPECIFIED AS EARLIER THAN "BEFORE=".                 *
*                                                             *
***************************************************************
CHKBTTOD DS    0H
         CLC   AFTERTME,BEFORTME   COMPARE AFTER TIME TO BEFORE TIME
         BNL   BTWTODOK            IF THIS TEST NOT PERTINENT
         ICM   R15,B'1111',TODTME  LOAD COMMAND XEQ TOD
         BM    BTWTODOK            IF "TOD=" NOT SPECIFIED
         C     R15,AFTERTME        COMPARE LATEST TIME TO TOD
         BL    BTWTODOK            IF NOT LATER THAN TIME
         C     R15,BEFORTME        COMPARE EARLIEST TIME TO TOD
         BNL   BTWTODOK            IF NOT LATER THAN TIME
         MVC   WTOAREA(WTOMSG9Z),WTOMSG9        MSG SKELETON
         MVC   WTOCONID,MSGCONID   ASSIGN  MCS CONSOLE ID
         MVC   WTODSCCD,MSGDSCCD   ASSIGN  MCS DESC  CODE
         MVC   WTORTECD,MSGRTECD   ASSIGN  MCS ROUTE CODE
         MVC   WTOMSG+033(03),=C'TOD='          "TOD"
         MVC   WTOMSG+042(02),TODDEC+00         TOD HOURS
         MVC   WTOMSG+045(02),TODDEC+02         TOD MINUTES
         MVC   WTOMSG+048(02),TODDEC+04         TOD SECONDS
         MVC   WTOMSG+065(02),AFTERDEC+00       TIME HOURS
         MVC   WTOMSG+068(02),AFTERDEC+02       TIME MINUTES
         MVC   WTOMSG+071(02),AFTERDEC+04       TIME SECONDS
         MVC   WTOMSG+091(02),BEFORDEC+00       TIME HOURS
         MVC   WTOMSG+094(02),BEFORDEC+02       TIME MINUTES
         MVC   WTOMSG+097(02),BEFORDEC+04       TIME SECONDS
         BAS   RLINK,PRTCMD       PRINT MESSAGE ON THE PRINTER
         CLI   MSGMODET,04        ARE TIME MESSAGES SUPPRESSED?
         BE    NOMSGBTT           BYPASS MESSAGE IF YES
         BAS   RLINK,WTOCMD       ISSUE OPERATOR MESSAGE
NOMSGBTT DS    0H
         MVI   XEQMODE,04         INDICATE TEST FAILED
BTWTODOK DS    0H
         SPACE 5
*
*        IF THE FINAL TEST RESULTS IN "XEQMODE" ARE "00",
*        COMMANDS CAN BE ISSUED.
         CLI   XEQMODE,00         COMMAND XEQ OK?
         BNE   RC04               NO - EXIT WITH RETURN CODE 04
         TITLE 'PAGEADD - OPERATOR PROMPTING ROUTINE'
***************************************************************
*                                                             *
*        IF OPERATOR PROMPTING HAS NOT BEEN REQUESTED,        *
*        BYPASS THE PROMPTING ROUTINE.                        *
*                                                             *
***************************************************************
PROMPT   DS    0H
         CLI   PMTMODE,04             "PARM=NOPROMPT" ??
         BE    BYPROMPT               IF YES, BYPASS PROCESSING.
         SPACE 5 ,
***************************************************************
*                                                             *
*        ISSUE PROMPTING MESSAGE 19 TO THE OPERATOR,          *
*        AND GET THE OPERATOR'S REPLY.                        *
*                                                             *
***************************************************************
         MVC   WTORAREA(WTOMSGJZ),WTOMSGJ   WTOR/MSG SKELETON
         MVC   WTOCONID,MSGCONID   ASSIGN  MCS CONSOLE ID
         MVC   WTODSCCD,DFLTDSC7   ASSIGN  MCS DESC  CODE
         MVC   WTORTECD,MSGRTECD   ASSIGN  MCS ROUTE CODE
         BAS   RLINK,PRTCMD      PRINT MESSAGE ON THE PRINTER
         BAS   RLINK,WTORCMD     ISSUE OPERATOR MESSAGE AND GET REPLY
         SPACE 5 ,
***************************************************************
*                                                             *
*        USE THE PARM STRING ANALYSIS ROUTINES TO EXTRACT     *
*        VALUES FROM THE OPERATOR RESPONSE.                   *
*                                                             *
***************************************************************
         LA    R0,L'WTOREPLY             REPLY AREA LENGTH
         LA    R1,WTOREPLY            -> REPLY AREA
         BAS   RLINK,PARMANAL            ANALYZE PARM DATA
BYPROMPT DS    0H
         EJECT  ,
***************************************************************
*                                                             *
*        IF "CANCEL" WAS ENTERED, DISCONTINUE EXECUTION.      *
*                                                             *
***************************************************************
         CLI   CNCMODE,04         WAS "CANCEL" ENTERED??
         BNE   BYCANCEL           NO - CONTINUE PROCESSING
         MVC   WTOAREA(WTOMSGAZ),WTOMSGA   WTO/MSG SKELETON
         MVC   WTOCONID,MSGCONID   ASSIGN  MCS CONSOLE ID
         MVC   WTODSCCD,MSGDSCCD   ASSIGN  MCS DESC  CODE
         MVC   WTORTECD,MSGRTECD   ASSIGN  MCS ROUTE CODE
         BAS   RLINK,PRTCMD      PRINT MESSAGE ON THE PRINTER
         BAS   RLINK,WTOCMD      ISSUE OPERATOR MESSAGE
         B     RC08               EXIT WITH RETURN CODE 08
BYCANCEL DS    0H
         TITLE 'PAGEADD - ESTABLISH DELAY INTERVAL / WAIT FOR TOD'
***************************************************************
*                                                             *
*        IF A DELAY INTERVAL OR TIME-OF-DAY WAIT HAS NOT      *
*        BEEN REQUESTED, BYPASS THE DELAY ROUTINE.            *
*                                                             *
***************************************************************
DELAYBGN DS    0H
         ICM   R15,B'1111',TODTME     TEST TOD VALUE
         BNM   DODELAY                IF "TOD=" SPECIFIED, PROCESS
         ICM   R15,B'1111',DELAYTME   LOAD AND TEST INTERVAL VALUE
         BP    DODELAY                PROCESS DELAY INTERVAL IF > 0
         B     BYDELAY                TO END OF DELAY PROCESSING
DODELAY  DS    0H
         SPACE 5 ,
***************************************************************
*                                                             *
*        IF THE PROGRAM IS RUNNING IN TEST MODE,              *
*        ISSUE A MESSAGE FOR THE START OF THE DELAY INTERVAL. *
*                                                             *
***************************************************************
MSGBEGIN DS    0H
         MVC   WTOAREA(WTOMSGBZ),WTOMSGB        MSG SKELETON
         MVC   WTOCONID,MSGCONID   ASSIGN  MCS CONSOLE ID
         MVC   WTODSCCD,MSGDSCCD   ASSIGN  MCS DESC  CODE
         MVC   WTORTECD,MSGRTECD   ASSIGN  MCS ROUTE CODE
         MVC   WTOMSG+023(02),DELAYDEC+00       DELAY HOURS
         MVC   WTOMSG+026(02),DELAYDEC+02       DELAY MINUTES
         MVC   WTOMSG+029(02),DELAYDEC+04       DELAY SECONDS
         ICM   R15,B'1111',TODTME     WAS "TOD=" SPECIFIED??
         BM    MSGBGNTM               IF "TOD=" NOT SPECIFIED
         MVC   WTOMSG+017(06),=C'  TOD='        INDICATE TOD
         MVC   WTOMSG+023(02),TODDEC+00         TOD HOURS
         MVC   WTOMSG+026(02),TODDEC+02         TOD MINUTES
         MVC   WTOMSG+029(02),TODDEC+04         TOD SECONDS
MSGBGNTM TIME  DEC               GET CURRENT TOD IN DECIMAL
         ST    R0,PACKAREA       STORE TIME
         UNPK  PACK1(09),PACKAREA(05)  UNSTRING TIME
         MVC   WTOMSG+054(02),PACK1+00          TIME HOURS
         MVC   WTOMSG+057(02),PACK1+02          TIME MINUTES
         MVC   WTOMSG+060(02),PACK1+04          TIME SECONDS
         BAS   RLINK,PRTCMD      PRINT MESSAGE ON THE PRINTER
         CLI   TESTMODE,04       IS THE PROGRAM IN TEST MODE?
         BE    MSGBGWTO          ISSUE MESSAGE IF YES
         B     NOMSGBGN          BYPASS MESSAGE IF NOT
MSGBGWTO BAS   RLINK,WTOCMD      ISSUE OPERATOR MESSAGE
NOMSGBGN DS    0H
         EJECT  ,
***************************************************************
*                                                             *
*        DETERMINE THE TYPE OF DELAY INTERVAL THAT WAS        *
*        REQUESTED (OR DEFAULTED), AND ROUTE CONTROL TO       *
*        THE CORRESPONDING STIMER ROUTINE.                    *
*                                                             *
***************************************************************
STIMER   DS    0H
         ICM   R15,B'1111',TODTME     TEST TOD VALUE
         BNM   STIMERT                IF "TOD=" SPECIFIED
         B     STIMERD                IF "DELAY=" SPECIFIED
         SPACE 5 ,
***************************************************************
*                                                             *
*        ISSUE AN "STIMER" WHEN A DELAY INTERVAL WAS          *
*        REQUESTED.                                           *
*                                                             *
***************************************************************
STIMERD  DS    0H                     WAIT THE DESIRED INTERVAL
         ICM   R15,B'1111',DELAYTME   LOAD AND TEST INTERVAL VALUE
         BNP   BYSTIMER               BYPASS DELAY INTERVAL IF <= 0
         STIMER WAIT,BINTVL=DELAYTME  WAIT THE DESIRED INTERVAL
         B     BYSTIMER               TO END OF STIMER PROCESSING
         EJECT  ,
***************************************************************
*                                                             *
*        ISSUE AN "STIMER" WHEN COMMAND EXECUTION AT A        *
*        SPECIFIC TIME OF DAY WAS REQUESTED.                  *
*                                                             *
***************************************************************
STIMERT  DS    0H                     WAIT FOR THE DESIRED TOD.
         ICM   R15,B'1111',TODTME     TEST TOD VALUE
         BM    BYSTIMER               IF "TOD=" NOT SPECIFIED
         TIME  BIN                    GET THE LATEST TOD BINARY VALUE
         L     R15,MAXTME             LOAD 24 HOUR TIME VALUE
*              R0 CONTAINS THE CURRENT XEQ TIME FROM THE "TIME" SVC.
         L     R1,TODTME              LOAD COMMAND XEQ TIME OF DAY
*
*        IF THE LATEST TOD IS LESS THAN XEQTME, THEN WE HAVE
*        PASSED THROUGH MIDNIGHT, AND MUST COMPENSATE FOR IT.
         C     R0,XEQTME              COMPARE LATEST TIME TO XEQTME
         BNL   *+L'*+2                IF THE SAME OR LATER
         AR    R0,R15                 BASE UP BY 24 HOURS
*
*        IF THE LATEST TOD IS LESS THAN "BEFORE=",
*        ADD 24 HOURS TO IT.
         C     R0,BEFORTME            COMPARE LATEST TIME TO "BEFORE="
         BNL   *+L'*+2                IF THE SAME OR LATER
         AR    R0,R15                 BASE UP BY 24 HOURS
*
*        IF THE COMMAND EXECUTION TIME IS LESS THAN "BEFORE=",
*        ADD 24 HOURS TO IT.
         C     R1,BEFORTME            COMPARE "TOD=" TIME TO "BEFORE="
         BNL   *+L'*+2                IF THE SAME OR LATER
         AR    R1,R15                 BASE UP BY 24 HOURS
*
*        ADJUST THE LATEST TIME BY A TOLERANCE FACTOR,
*        AND SEE IF THE STIMER SHOULD BE ISSUED.
         A     R0,ERRTME              MARGIN OF ERROR
         CR    R0,R1                  SEE WHEN TIMER SHOULD POP
         BH    BYSTIMER               BRANCH IF LATER                  X
                                      OR NOT LONG TO WAIT
*
*
*        WAIT FOR THE DESIRED TIME OF DAY.
STIMERTT DS    0H
         STIMER WAIT,TOD=TODDEC       WAIT FOR THE DESIRED TOD
         B     BYSTIMER               TO END OF STIMER PROCESSING
         EJECT  ,
***************************************************************
*                                                             *
*        STIMER DELAY INTERVAL PROCESSING IS COMPLETE.        *
*                                                             *
***************************************************************
BYSTIMER DS    0H
         SPACE 2
***************************************************************
*                                                             *
*        IF THE PROGRAM IS RUNNING IN TEST MODE,              *
*        ISSUE A MESSAGE FOR THE END OF THE DELAY INTERVAL.   *
*                                                             *
***************************************************************
MSGEND   DS    0H
         MVC   WTOAREA(WTOMSGCZ),WTOMSGC        MSG SKELETON
         MVC   WTOCONID,MSGCONID   ASSIGN  MCS CONSOLE ID
         MVC   WTODSCCD,MSGDSCCD   ASSIGN  MCS DESC  CODE
         MVC   WTORTECD,MSGRTECD   ASSIGN  MCS ROUTE CODE
         MVC   WTOMSG+023(02),DELAYDEC+00       DELAY HOURS
         MVC   WTOMSG+026(02),DELAYDEC+02       DELAY MINUTES
         MVC   WTOMSG+029(02),DELAYDEC+04       DELAY SECONDS
         ICM   R15,B'1111',TODTME     WAS "TOD=" SPECIFIED??
         BM    MSGENDTM               IF "TOD=" NOT SPECIFIED
         MVC   WTOMSG+017(06),=C'  TOD='        INDICATE TOD
         MVC   WTOMSG+023(02),TODDEC+00         TOD HOURS
         MVC   WTOMSG+026(02),TODDEC+02         TOD MINUTES
         MVC   WTOMSG+029(02),TODDEC+04         TOD SECONDS
MSGENDTM TIME  DEC               GET CURRENT TOD IN DECIMAL
         ST    R0,PACKAREA       STORE TIME
         UNPK  PACK1(09),PACKAREA(05)  UNSTRING TIME
         MVC   WTOMSG+052(02),PACK1+00          TIME HOURS
         MVC   WTOMSG+055(02),PACK1+02          TIME MINUTES
         MVC   WTOMSG+058(02),PACK1+04          TIME SECONDS
         BAS   RLINK,PRTCMD      PRINT MESSAGE ON THE PRINTER
         CLI   TESTMODE,04       IS THE PROGRAM IN TEST MODE?
         BE    MSGNDWTO          ISSUE MESSAGE IF YES
         B     NOMSGEND          BYPASS MESSAGE IF NOT
MSGNDWTO BAS   RLINK,WTOCMD      ISSUE OPERATOR MESSAGE
NOMSGEND DS    0H
         SPACE 3
***************************************************************
*                                                             *
*        DELAY INTERVAL PROCESSING IS COMPLETE.               *
*                                                             *
***************************************************************
BYDELAY  DS    0H
         MVC   DELAYTME,DFLTDLAY   REESTABLISH DEFAULT DELAY TIME
         MVC   TODTME,=F'-1'       REESTABLISH DEFAULT TOD
         TITLE 'PAGEADD - REPROMPT VERIFICATION'
***************************************************************
*                                                             *
*        IF THE PROMPTING INDICATOR IS STILL ON,              *
*        GO BACK TO RE-ISSUE THE OPERATOR PROMPTING MESSAGE.  *
*                                                             *
***************************************************************
         CLI   PMTMODE,00             "PARM=PROMPT" ??
         BE    XEQANAL              GO REANALYZE XEQ ENVIRONMENT
         TITLE 'PAGEADD - LIST AND ISSUE OPERATOR COMMANDS'
*
*        IF COMMAND INPUT WAS SUPPRESSED,
*        BYPASS PROCESSING OF THE COMMAND TABLE.
CMDLP0   DS    0H                  INITIALIZE FOR SCANNING THE TABLE
         CLI   INPMODE,04          "NOINPUT"??
         BE    CMDLP9              BRANCH AROUND CMD TBL IF YES
*
*
*        INITIALIZE REGISTERS FOR PROCESSING THE COMMAND TABLE.
CMDLP1   DS    0H                  INITIALIZE FOR SCANNING THE TABLE
         LA    RTBL1,TABLE-L'TBLENTRY    POINT TO 0'TH TABLE ENTRY
         LA    RTBL2,L'TBLENTRY    TABLE ENTRY LENGTH
         L     RTBL3,TBLENDAD      LAST TABLE ENTRY ADDRESS
*
*
*        ADVANCE TO THE NEXT TABLE ENTRY,
*        AND TEST FOR PROCESSING COMPLETE.
CMDLP2   DS    0H                  START OF TABLE SCAN LOOP
         BXH   RTBL1,RTBL2,CMDLP9  IF ALL ENTRIES PROCESSED,WRAPUP
*
*
*        BUILD THE PARAMETER LIST FOR THE OPERATOR COMMAND
CMDLP3   DS    0H
         USING TBLENTRY,RTBL1      TABLE ENTRY ADDRESSABILITY
         MVC   WTOAREA(CMDMODLZ),CMDMODEL    OPERATOR COMMAND SKELETON
         MVC   WTOCONID,TBLCONID             COMMAND CONSOLE ID
         MVC   WTODSCCD,MSGDSCCD   ASSIGN  MCS DESC  CODE
         MVC   WTORTECD,MSGRTECD   ASSIGN  MCS ROUTE CODE
         MVC   WTOMSG+000(L'TBLCMD),TBLCMD   OPERATOR COMMAND TEXT
*
*
*        LIST AND ISSUE THE OPERATOR COMMAND.
CMDLP4   DS    0H
         BAS   RLINK,PRTCMD        GO TO PRINT ROUTINE
         CLI   MSGMODEC,04         ARE MSGS FOR OPERATOR CMDS SUPPR?
         BE    *+L'*+4+4           DON'T WTO THE COMMAND IF YES
         BAS   RLINK,WTOCMD        WRITE COMMAND AS OPERATOR MESSAGE
         STCM  RWORK1,B'1111',TBLDOMID   SAVE MESSAGE NUMBER FOR DOM
         SPACE 1
         CLI   CMDMODE,04          "NOCMDS"??
         BE    *+L'*+4             DON'T ISSUE COMMAND IF YES
         BAS   RLINK,ISSUECMD      ISSUE THE COMMAND VIA SVC 34
         B     CMDLP5              CONTINUE W/ SCAN LOOP
*
*
*        CONTINUE WITH THE COMMAND LOOP
CMDLP5   DS    0H
         B     CMDLP2              CONTINUE LOOPING
         DROP  RTBL1               DROP TABLE ENTRY ADDRESSABILITY
CMDLP9   DS    0H                  END OF COMMAND PROCESSING
         B     RC00                RETURN TO CALLER
         TITLE 'PAGEADD - RETURN TO CALLER SEQUENCE'
***************************************************************
*                                                             *
*        EXIT WITH THE PROPER RETURN CODE                     *
*                                                             *
***************************************************************
RC00     DS    0H
         MVI   RETURNCD+3,00       SUCCESSFUL COMPLETION
         B     PAUSE
RC04     DS    0H
         MVI   RETURNCD+3,04       EXECUTION ENVIRONMENT NOT SUITABLE
         B     PAUSE
RC08     DS    0H
         MVI   RETURNCD+3,08       "PARM=CANCEL" WAS SPECIFIED
         B     BYPAUSE
RC12     DS    0H
         MVI   RETURNCD+3,12       NO DATA IN SYSIN WITH "INPUT"
         B     BYPAUSE
RC16     DS    0H
         MVI   RETURNCD+3,16       UNABLE TO OPEN SYSIN/SYSPARM
         B     BYPAUSE
RC20     DS    0H
         MVI   RETURNCD+3,20       UNABLE TO OPEN SYSPRINT
         B     BYPAUSE
         SPACE 3 ,
***************************************************************
*                                                             *
*        IF "PAUSE" WAS ENTERED, ISSUE A WTOR AND WAIT.       *
*                                                             *
***************************************************************
PAUSE    DS    0H
         CLI   PSEMODE,04         WAS "NOPAUSE" SPECIFIED??
         BE    BYPAUSE            YES - BYPASS PAUSE PROCESSING
         MVI   CNCMODE,04         SET VALUE FOR CANCEL
         MVC   WTORAREA(WTOMSGYZ),WTOMSGY   WTOR/MSG SKELETON
         MVC   WTOCONID,MSGCONID   ASSIGN  MCS CONSOLE ID
         MVC   WTODSCCD,DFLTDSC7   ASSIGN  MCS DESC  CODE
         MVC   WTORTECD,MSGRTECD   ASSIGN  MCS ROUTE CODE
         BAS   RLINK,PRTCMD      PRINT MESSAGE ON THE PRINTER
         BAS   RLINK,WTORCMD      ISSUE OPERATOR MESSAGE
         LA    R0,L'WTOREPLY             REPLY AREA LENGTH
         LA    R1,WTOREPLY            -> REPLY AREA
         BAS   RLINK,PARMANAL            ANALYZE REPLY DATA
         CLI   CNCMODE,00         WAS "GO" ENTERED??
         BE    BYPAUSE            YES - CONTINUE PROCESSING
         MVC   WTOAREA(WTOMSGZZ),WTOMSGZ   WTO/MSG SKELETON
         MVC   WTOCONID,MSGCONID   ASSIGN  MCS CONSOLE ID
         MVC   WTODSCCD,MSGDSCCD   ASSIGN  MCS DESC  CODE
         MVC   WTORTECD,MSGRTECD   ASSIGN  MCS ROUTE CODE
         BAS   RLINK,PRTCMD        PRINT MESSAGE ON THE PRINTER
         BAS   RLINK,WTOCMD        ISSUE OPERATOR MESSAGE
         B     PAUSE               REISSUE PAUSE WTOR
BYPAUSE  DS    0H
         EJECT  ,
***************************************************************
*                                                             *
*        IF THE MESSAGES LISTING THE COMMANDS ARE TO BE       *
*        DELETED FROM THE SCREEN, ISSUE THE "DOM" MACRO.      *
*                                                             *
***************************************************************
DOMMSGC  DS    0H
         CLI   DMCMODE,04         WAS "NODOMMSGC" SPECIFIED??
         BE    DMCLP9             YES - BYPASS DOMMSGC PROCESSING
*
*        IF COMMAND INPUT WAS SUPPRESSED, OR COMMAND IMAGE MESSAGES
*        WERE NOT ISSUED, BYPASS PROCESSING OF THE COMMAND TABLE.
DMCLP0   DS    0H                  INITIALIZE FOR SCANNING THE TABLE
         CLI   INPMODE,04          WAS "NOINPUT" SPECIFIED??
         BE    DMCLP9              YES - BYPASS DOMMSGC PROCESSING
         CLI   MSGMODEC,04         ARE MSGS FOR OPERATOR CMDS SUPPR?
         BE    DMCLP9              YES - BYPASS DOMMSGC PROCESSING
*
*
*        INITIALIZE REGISTERS FOR PROCESSING THE COMMAND TABLE.
DMCLP1   DS    0H                  INITIALIZE FOR SCANNING THE TABLE
         LA    RTBL1,TABLE-L'TBLENTRY    POINT TO 0'TH TABLE ENTRY
         LA    RTBL2,L'TBLENTRY    TABLE ENTRY LENGTH
         L     RTBL3,TBLENDAD      LAST TABLE ENTRY ADDRESS
*
*
*        ADVANCE TO THE NEXT TABLE ENTRY,
*        AND TEST FOR PROCESSING COMPLETE.
DMCLP2   DS    0H                  START OF TABLE SCAN LOOP
         BXH   RTBL1,RTBL2,DMCLP9  IF ALL ENTRIES PROCESSED,WRAPUP
         USING TBLENTRY,RTBL1      TABLE ENTRY ADDRESSABILITY
*
*
*        DELETE THE COMMAND IMAGE MESSAGE.
DMCLP3   DS    0H
         ICM   RWORK1,B'1111',TBLDOMID    LOAD MESSAGE ID FOR DOM
         DOM   MSG=(1)             DELETE THE MESSAGE FROM THE SCREEN
*
*
*        CONTINUE WITH THE COMMAND LOOP
DMCLP5   DS    0H
         B     DMCLP2              CONTINUE LOOPING
         DROP  RTBL1               DROP TABLE ENTRY ADDRESSABILITY
DMCLP9   DS    0H                  END OF COMMAND PROCESSING
         EJECT  ,
***************************************************************
*                                                             *
*        CLEAN UP AND RETURN TO THE CALLER.                   *
*                                                             *
***************************************************************
LEAVE    DS    0H                  CLEAN UP BEFORE RETURNING
*
*        CLOSE THE -SYSPRINT- DCB
         BAS   RLINK,CLSPRDCB      CLOSE THE SYSPRINT DCB IF OPEN
*
*        RELOAD THE CALLER'S REGISTERS,
*        RELEASE THE WORK AREA, AND RETURN.
         LR    R1,RSAVE            ADDRESS TO FREEMAIN
         L     R2,RETURNCD         RETURN CODE
         L     R13,SAVE+4          CALLER'S SAVE AREA
         L     R0,WORKSIZE         LOAD SIZE FOR FREEMAIN
         FREEMAIN RU,              RELEASE THE WORK AREA               X
               LV=(0),             WORK AREA SIZE                      X
               A=(1),              WORK AREA ADDRESS                   X
               SP=001              WORK AREA SUBPOOL
         XC    8(4,R13),8(R13)     CLEAR CALLER'S -> OUR SAVE AREA
         LR    R15,R2              RETURN CODE TO R15
         RETURN    (14,12),RC=(15)
         TITLE 'PAGEADD - SYSIN DATA SET PROCESSING ROUTINES'
*
*
*        SYSIN DCB OPEN ROUTINE
*
*        OPEN THE -SYSIN- DCB AND TAKE THE DCB EXIT
OPNINDCB DS    0H
         ST    RLINK,INSVOPNL      SAVE RLINK REGISTER VALUE
         MVC   INDCB+(DCBDDNAM-IHADCB)(L'DCBDDNAM),INDDNAM  SET DDN
         OPEN  (INDCB,(INPUT,LEAVE)),MF=(E,INOPEN)
         TM    INDCB+(DCBOFLGS-IHADCB),X'10'   WAS OPEN SUCCESSFUL?
         BZ    OPNINERR            ISSUE ERROR MESSAGE IF YES
         OI    INFLAG1,INF1OPEN    INDICATE DATA SET IS OPEN
         LA    R15,00              SET ZERO RETURN CODE
         B     OPNINEND            GO RETURN TO CALLER
OPNINERR DS    0H
         MVC   WTOAREA(WTOMSG1Z),WTOMSG1    MOVE IN ERROR MESSAGE
         MVC   WTOCONID,MSGCONID   ASSIGN  MCS CONSOLE ID
         MVC   WTODSCCD,MSGDSCCD   ASSIGN  MCS DESC  CODE
         MVC   WTORTECD,MSGRTECD   ASSIGN  MCS ROUTE CODE
         MVC   WTOMSG+17(8),INDCB+(DCBDDNAM-IHADCB) COPY DD NAME
         BAS   RLINK,PRTCMD        PRINT ERROR MESSAGE
         BAS   RLINK,WTOCMD        WRITE OPERATOR MESSAGE
         LA    R15,08              SET NON-ZERO RETURN CODE
OPNINEND LTR   R15,R15             SET CC FROM RETURN CODE
         L     RLINK,INSVOPNL      RELOAD RETURN REGISTER VALUE
         BR    RLINK               RETURN TO CALLER
         EJECT  ,
*
*
*        SYSIN DCB OPEN EXIT
*
*        THIS ROUTINE SUPPLIES DCB PARAMETERS
*        WHICH HAVE NOT BEEN SUPPLIED BY OPEN TIME.
*        VALUES WHICH WILL BE SUPPLIED ARE....
*
*                   BLKSIZE
*
INEXIT   DS    0H
         LH    R1,INDCB+(DCBBLKSI-IHADCB)            LOAD BLKSIZE
         LH    R15,INDCB+(DCBLRECL-IHADCB)           LOAD LRECL
INEXTF1  DS    0H
         LTR   R1,R1               WAS BLKSIZE SUPPLIED?
         BNZ   INEXTF2             YES - BRANCH
         LR    R1,R15              SET BLKSIZE=LRECL
*        FORCE BLKSIZE TO AN EVEN MULTIPLE OF LRECL
INEXTF2  DS    0H
         SR    R0,R0               ZERO R0 FOR DIVIDE
         DR    R0,R15              DIVIDE BLKSIZE BY LRECL
         LTR   R1,R1               IF QUOTIENT IS ZERO
         BNZ   *+L'*+4             DO NOT FORCE
         LA    R1,1                BLKSIZE=LRECL
         MR    R0,R15              RECOMPUTE BLKSIZE
         STH   R1,INDCB+(DCBBLKSI-IHADCB)    STORE BLKSIZE
         BR    RLINK               RETURN TO OPEN ROUTINE
         EJECT  ,
*
*
*        SYSIN DCB READ RECORD ROUTINE
*
*        THIS ROUTINE READS THE NEXT RECORD FROM THE
*        INPUT DATA SET INTO "INAREA".
*
GETIN    DS    0H
         ST    RLINK,INSVGETL      SAVE RETURN REGISTER VALUE
         TM    INFLAG1,INF1EOD     IF EOD PREVIOUSLY FLAGGED,
         BO    GETINEOD            EXIT VIA EOD ROUTINE
         GET   INDCB,INAREA        READ THE NEXT COMMAND IMAGE RECORD
         L     RLINK,INRECCT       UPDATE
         A     RLINK,=A(1)           RECORD
         ST    RLINK,INRECCT           COUNT
         BAS   RLINK,PRTINREC      PRINT INPUT RECORD CONTENTS
         SLR   RLINK,RLINK         SET NON-ZERO RETURN CODE
         L     RLINK,INSVGETL      RELOAD RETURN REGISTER VALUE
         BR    RLINK               RETURN TO CALLER
GETINEOD DS    0H
         OI    INFLAG1,INF1EOD     SET EOD-OF-DATA FLAG
         MVI   INAREA,X'FF'        FILL INPUT AREA
         MVC   INAREA+1(L'INAREA-1),INAREA    WITH HIGH-VALUES
         SR    RLINK,RLINK         SET ZERO RETURN CODE
         L     RLINK,INSVGETL      RELOAD RETURN REGISTER VALUE
         BR    RLINK               RETURN TO CALLER
         EJECT  ,
*
*
*        SYSIN DCB CLOSE ROUTINE
*
*
*        CLOSE THE -SYSIN- DCB
CLSINDCB DS    0H
         ST    RLINK,INSVCLSL      SAVE RLINK REGISTER VALUE
         TM    INFLAG1,INF1OPEN    IS SYSIN OPEN?
         BZ    CLSINERR            BYPASS CLOSE IF NOT
         MVC   INOPEN(4),CLOSIN1   INITIALIZE OPEN/CLOSE LIST
         CLOSE (INDCB,FREE),       CLOSE THE DATA SET                  X
               MF=(E,INOPEN)
         FREEPOOL INDCB            RELEASE THE BUFFER POOL
         NI    INFLAG1,255-INF1OPEN   CLEAR DATASET OPEN FLAG
         LA    R15,00              SET ZERO RETURN CODE
         B     CLSINEND            GO RETURN TO CALLER
CLSINERR DS    0H                  THE DATA SET IS ALREADY CLOSED
         LA    R15,04              SET NON-ZERO RETURN CODE
CLSINEND LTR   R15,R15             SET CC FROM RETURN CODE
         L     RLINK,INSVCLSL      RELOAD RETURN REGISTER VALUE
         BR    RLINK               RETURN TO CALLER
         TITLE 'PAGEADD - SYSPARM DATA SET PROCESSING ROUTINES'
*
*
*        SYSPARM DCB OPEN ROUTINE
*
*        OPEN THE -SYSPARM- DCB AND TAKE THE DCB EXIT
OPNSPDCB DS    0H
         ST    RLINK,SPSVOPNL      SAVE RLINK REGISTER VALUE
         MVC   SPDCB+(DCBDDNAM-IHADCB)(L'DCBDDNAM),SPDDNAM  SET DDN
         OPEN  (SPDCB,(INPUT,LEAVE)),MF=(E,SPOPEN)
         TM    SPDCB+(DCBOFLGS-IHADCB),X'10'   WAS OPEN SUCCESSFUL?
         BZ    OPNSPERR            ISSUE ERROR MESSAGE IF YES
         OI    SPFLAG1,SPF1OPEN    INDICATE DATA SET IS OPEN
         LA    R15,00              SET ZERO RETURN CODE
         B     OPNSPEND            GO RETURN TO CALLER
OPNSPERR DS    0H
         MVC   WTOAREA(WTOMSG1Z),WTOMSG1    MOVE IN ERROR MESSAGE
         MVC   WTOCONID,MSGCONID   ASSIGN  MCS CONSOLE ID
         MVC   WTODSCCD,MSGDSCCD   ASSIGN  MCS DESC  CODE
         MVC   WTORTECD,MSGRTECD   ASSIGN  MCS ROUTE CODE
         MVC   WTOMSG+17(8),SPDCB+(DCBDDNAM-IHADCB) COPY DD NAME
         BAS   RLINK,PRTCMD        PRINT ERROR MESSAGE
         BAS   RLINK,WTOCMD        WRITE OPERATOR MESSAGE
         LA    R15,08              SET NON-ZERO RETURN CODE
OPNSPEND LTR   R15,R15             SET CC FROM RETURN CODE
         L     RLINK,SPSVOPNL      RELOAD RETURN REGISTER VALUE
         BR    RLINK               RETURN TO CALLER
         EJECT  ,
*
*
*        SYSPARM DCB OPEN EXIT
*
*        THIS ROUTINE SUPPLIES DCB PARAMETERS
*        WHICH HAVE NOT BEEN SUPPLIED BY OPEN TIME.
*        VALUES WHICH WILL BE SUPPLIED ARE....
*
*                   BLKSIZE
*
SPEXIT   DS    0H
         LH    R1,SPDCB+(DCBBLKSI-IHADCB)            LOAD BLKSIZE
         LH    R15,SPDCB+(DCBLRECL-IHADCB)           LOAD LRECL
SPEXTF1  DS    0H
         LTR   R1,R1               WAS BLKSIZE SUPPLIED?
         BNZ   SPEXTF2             YES - BRANCH
         LR    R1,R15              SET BLKSIZE=LRECL
*        FORCE BLKSIZE TO AN EVEN MULTIPLE OF LRECL
SPEXTF2  DS    0H
         SR    R0,R0               ZERO R0 FOR DIVIDE
         DR    R0,R15              DIVIDE BLKSIZE BY LRECL
         LTR   R1,R1               IF QUOTIENT IS ZERO
         BNZ   *+L'*+4             DO NOT FORCE
         LA    R1,1                BLKSIZE=LRECL
         MR    R0,R15              RECOMPUTE BLKSIZE
         STH   R1,SPDCB+(DCBBLKSI-IHADCB)    STORE BLKSIZE
         BR    RLINK               RETURN TO OPEN ROUTINE
         EJECT  ,
*
*
*        SYSPARM DCB READ RECORD ROUTINE
*
*        THIS ROUTINE READS THE NEXT RECORD FROM SYSPARM
*        INTO "SPAREA".
*
GETSP    DS    0H
         ST    RLINK,SPSVGETL      SAVE RETURN REGISTER VALUE
         TM    SPFLAG1,SPF1EOD     IF EOD PREVIOUSLY FLAGGED,
         BO    GETSPEOD            EXIT VIA EOD ROUTINE
         GET   SPDCB,SPAREA        READ THE NEXT VATLSTXX RECORD
         L     RLINK,SPRECCT       UPDATE
         A     RLINK,=A(1)           RECORD
         ST    RLINK,SPRECCT           COUNT
         BAS   RLINK,PRTSPREC      PRINT SYSPARM RECORD CONTENTS
         SLR   RLINK,RLINK         SET NON-ZERO RETURN CODE
         L     RLINK,SPSVGETL      RELOAD RETURN REGISTER VALUE
         BR    RLINK               RETURN TO CALLER
GETSPEOD DS    0H
         OI    SPFLAG1,SPF1EOD     SET EOD-OF-DATA FLAG
         MVI   SPAREA,X'FF'        FILL INPUT AREA
         MVC   SPAREA+1(L'SPAREA-1),SPAREA    WITH HIGH-VALUES
         SR    RLINK,RLINK         SET ZERO RETURN CODE
         L     RLINK,SPSVGETL      RELOAD RETURN REGISTER VALUE
         BR    RLINK               RETURN TO CALLER
         EJECT  ,
*
*
*        SYSPARM DCB CLOSE ROUTINE
*
*
*        CLOSE THE -SYSPARM- DCB
CLSSPDCB DS    0H
         ST    RLINK,SPSVCLSL      SAVE RLINK REGISTER VALUE
         TM    SPFLAG1,SPF1OPEN    IS SYSPARM OPEN?
         BZ    CLSSPERR            BYPASS CLOSE IF NOT
         MVC   SPOPEN(4),CLOSSP1   INITIALIZE OPEN/CLOSE LIST
         CLOSE (SPDCB,FREE),       CLOSE THE DATA SET                  X
               MF=(E,SPOPEN)
         FREEPOOL SPDCB            RELEASE THE BUFFER POOL
         NI    SPFLAG1,255-SPF1OPEN   CLEAR DATASET OPEN FLAG
         LA    R15,00              SET ZERO RETURN CODE
         B     CLSSPEND            GO RETURN TO CALLER
CLSSPERR DS    0H                  THE DATA SET IS ALREADY CLOSED
         LA    R15,04              SET NON-ZERO RETURN CODE
CLSSPEND LTR   R15,R15             SET CC FROM RETURN CODE
         L     RLINK,SPSVCLSL      RELOAD RETURN REGISTER VALUE
         BR    RLINK               RETURN TO CALLER
         TITLE 'PAGEADD - SYSPRINT DATA SET PROCESSING ROUTINES'
*
*
*         SYSPRINT DCB OPEN ROUTINE
*
*        OPEN THE -SYSPRINT- DCB AND TAKE THE DCB EXIT
OPNPRDCB DS    0H
         ST    RLINK,PRSVOPNL      SAVE RLINK REGISTER VALUE
         OPEN  (PRDCB,(OUTPUT,LEAVE)),MF=(E,PROPEN)
         TM    PRDCB+(DCBOFLGS-IHADCB),X'10'   WAS OPEN SUCCESSFUL?
         BZ    OPNPRERR            ISSUE ERROR MESSAGE IF YES
         OI    PRFLAG1,PRF1OPEN    INDICATE DATA SET IS OPEN
         LA    R15,00              SET ZERO RETURN CODE
         B     OPNPREND            GO RETURN TO CALLER
OPNPRERR DS    0H
         MVC   WTOAREA(WTOMSG1Z),WTOMSG1    MOVE IN ERROR MESSAGE
         MVC   WTOCONID,MSGCONID   ASSIGN  MCS CONSOLE ID
         MVC   WTODSCCD,MSGDSCCD   ASSIGN  MCS DESC  CODE
         MVC   WTORTECD,MSGRTECD   ASSIGN  MCS ROUTE CODE
         MVC   WTOMSG+17(8),PRDCB+(DCBDDNAM-IHADCB) COPY DD NAME
         BAS   RLINK,WTOCMD        ISSUE OPERATOR MESSAGE
         LA    R15,12              SET NON-ZERO RETURN CODE
OPNPREND LTR   R15,R15             SET CC FROM RETURN CODE
         L     RLINK,PRSVOPNL      RELOAD RETURN REGISTER VALUE
         BR    RLINK               RETURN TO CALLER
         EJECT  ,
*
*
*        SYSPRINT DCB OPEN EXIT
*
*        THIS ROUTINE SUPPLIES DCB PARAMETERS
*        WHICH HAVE NOT BEEN SUPPLIED BY OPEN TIME.
*        VALUES WHICH WILL BE SUPPLIED ARE....
*
*                   BLKSIZE
*
PREXIT   DS    0H
         LH    R1,PRDCB+(DCBBLKSI-IHADCB)            LOAD BLKSIZE
         LH    R15,PRDCB+(DCBLRECL-IHADCB)           LOAD LRECL
PREXTF1  DS    0H
         LTR   R1,R1               WAS BLKSIZE SUPPLIED?
         BNZ   PREXTF2             YES - BRANCH
         LR    R1,R15              SET BLKSIZE=LRECL
*        FORCE BLKSIZE TO AN EVEN MULTIPLE OF LRECL
PREXTF2  DS    0H
         SR    R0,R0               ZERO R0 FOR DIVIDE
         DR    R0,R15              DIVIDE BLKSIZE BY LRECL
         LTR   R1,R1               IF QUOTIENT IS ZERO
         BNZ   *+L'*+4             DO NOT FORCE
         LA    R1,1                BLKSIZE=LRECL
         MR    R0,R15              RECOMPUTE BLKSIZE
         STH   R1,PRDCB+(DCBBLKSI-IHADCB)    STORE BLKSIZE
         BR    RLINK               RETURN TO OPEN ROUTINE
         EJECT  ,
*
*
*        SYSPRINT PRINT OPERATOR MSG/COMMAND ROUTINE
*
*        THIS ROUTINE WRITES A PRINT LINE FROM THE OPERATOR
*        COMMAND OR MESSAGE THAT HAS BEEN BUILT IN THE WTO AREA.
*
PRTCMD   DS    0H
         ST    RLINK,PRSVCMDL      SAVE RETURN REGISTER VALUE
         MVI   PRAREA,X'40'         CLEAR
         MVC   PRAREA+1(L'PRAREA-1),PRAREA
         XR    R1,R1                  CLEAR R1
         ICM   R1,B'0001',WTOLEN+1    MSG LENGTH+4
         LA    R1,WTOAREA(R1)      -> START OF DESCRIPTOR/ROUTE CODES
         MVC   00(02,R1),WTODSCCD  APPLY DESCRIPTOR CODES
         MVC   02(02,R1),WTORTECD  APPLY ROUTING    CODES
         L     R1,WTOLEN           LOAD MSG LENGTH & MCS FLAGS
         BAS   RLINK,PRTHEX        GET EBCDIC HEX
         EX    0,PRTCMDML          MOVE LENGTH
         EX    0,PRTCMDMM          MOVE MCS FLAGS
         XR    R1,R1                  CLEAR R1
         ICM   R1,B'0001',WTOLEN+1    MSG LENGTH+4
         SH    R1,=Y(04)           CALCULATE MESSAGE TEXT LENGTH
         BCTR  R1,0                DECREMENT LENGTH FOR MVC
         EX    R1,PRTCMDMT         MOVE COMMAND TEXT TO OUTPUT AREA
         TM    WTOMCS,X'80'        IF MCS FLAGS ARE ABSENT,
         BZ    PRTCMDPT            GO WRITE OUTPUT LINE
         XR    R1,R1                  CLEAR R1
         ICM   R1,B'0001',WTOLEN+1    MSG LENGTH+4
         LA    R1,WTOAREA(R1)      -> START OF DESCRIPTOR/ROUTE CODES
         L     R1,0(,R1)           LOAD DESCRIPTOR & ROUTE CODES
         BAS   RLINK,PRTHEX        CONVERT TO EBCDIC HEX
         EX    0,PRTCMDMD          MOVE DESCRIPTOR CODES
         EX    0,PRTCMDMR          MOVE ROUTE CODES
PRTCMDPT DS    0H                  PUT OUTPUT LINE
         PUT   PRDCB,PRAREA        WRITE OUTPUT LINE
         L     RLINK,PRSVCMDL      RELOAD RETURN REGISTER
         BR    RLINK               RETURN TO CALLER
         SPACE 5
PRTHEX   DS    0H                  CONVERT BINARY TO EBCDIC HEX
         ST    R1,PACK2            STORE DATA IN PACK AREA
         UNPK  PACK1(9),PACK2(5)
         NC    PACK1(8),=8X'0F'    CLEAR ZONES
         TR    PACK1(8),=C'0123456789ABCDEF'   CONVERT TO EBCDIC
         BR    RLINK               RETURN TO CALLER
         SPACE 2
PRTCMDML MVC   PRAREA+001(004),PACK1+00   MOVE LEN  TO OUTPUT
PRTCMDMM MVC   PRAREA+006(004),PACK1+04   MOVE MCS FLAGS TO OUTPUT
PRTCMDMT MVC   PRAREA+011(*-*),WTOMSG     MOVE TEXT TO OUTPUT
PRTCMDMD MVC   PRAREA+111(004),PACK1+00   MOVE DESCRIPTOR CODES
PRTCMDMR MVC   PRAREA+116(004),PACK1+04   MOVE ROUTE CODES
         EJECT  ,
*
*
*        SYSPRINT PRINT OPERATOR REPLY ROUTINE.
*
*        THIS ROUTINE WRITES A PRINT LINE DISPLAYING THE OPERATOR'S
*        REPLY TO THE LAST WTOR.
*
PRTREPLY DS    0H
         ST    RLINK,PRSVCMDL      SAVE RETURN REGISTER VALUE
         MVI   PRAREA,X'40'         CLEAR
         MVC   PRAREA+1(L'PRAREA-1),PRAREA
         MVC   PRAREA+001(L'PRTRDESC),PRTRDESC
         MVC   PRAREA+001+L'PRTRDESC(L'WTOREPLY),WTOREPLY
         OC    PRAREA+001+L'PRTRDESC(L'WTOREPLY),EBLANKS
         PUT   PRDCB,PRAREA        WRITE OUTPUT LINE
         L     RLINK,PRSVCMDL      RELOAD RETURN REGISTER
         BR    RLINK               RETURN TO CALLER
         SPACE 5
PRTRDESC DC    C'        OPERATOR REPLY: '
         EJECT  ,
*
*
*        SYSPRINT PRINT EXEC STATEMENT PARM FIELD ROUTINE.
*
*        THIS ROUTINE WRITES A PRINT LINE BASED ON
*        THE EXEC STATEMENT PARM FIELD.
*
PRTXPARM DS    0H
         ST    RLINK,PRSVCMDL      SAVE RETURN REGISTER VALUE
         MVI   PRAREA,X'40'         CLEAR
         MVC   PRAREA+1(L'PRAREA-1),PRAREA
         MVC   PRAREA+001(L'PRTXDESC),PRTXDESC
         L     R1,SAVE+4           -> CALLER'S SAVE AREA
         L     R1,24(,R1)             CALLER'S PARM POINTER
         L     R1,0(,R1)           -> PARM FIELD HALFWORD LENGTH
         SR    RLINK,RLINK            CLEAR WORK REGISTER
         ICM   RLINK,B'0011',00(R1)   LOAD AND TEST LENGTH
         BNP   PRTXMVC0               MOVE NULL DESCRIPTOR IF EMPTY
         LA    R0,L'PRAREA-1-L'PRTXDESC    MAX PARM FOR OUTPUT
         CLR   RLINK,R0               COMPARE TO MAX LN
         BNH   *+L'*+2                BRANCH IF NOT TOO LARGE
         LR    RLINK,R0
         BCTR  RLINK,0                DECREMENT LN FOR MVC
         EX    RLINK,PRTXMVC1         COPY PARM DATA
         B     PRTXPUT                GO WRITE OUTPUT LINE
PRTXMVC0 MVC   PRAREA+001+L'PRTXDESC(L'PRTXNULL),PRTXNULL
         B     PRTXPUT                GO WRITE OUTPUT LINE
PRTXPUT  DS    0H
         PUT   PRDCB,PRAREA        WRITE OUTPUT LINE
         L     RLINK,PRSVCMDL      RELOAD RETURN REGISTER
         BR    RLINK               RETURN TO CALLER
         SPACE 5
PRTXMVC1 MVC   PRAREA+001+L'PRTXDESC(*-*),02(R1)
PRTXDESC DC    C'EXEC PARM DATA: '
PRTXNULL DC    C'(NULL)'
         EJECT  ,
*
*
*        SYSPRINT PRINT "SYSIN" RECORD ROUTINE.
*
*        THIS ROUTINE WRITES A PRINT LINE DISPLAYING THE CURRENT
*        "SYSIN" DATA SET INPUT RECORD.
*
PRTINREC DS    0H
         ST    RLINK,PRSVCMDL      SAVE RETURN REGISTER VALUE
         MVI   PRAREA,X'40'         CLEAR
         MVC   PRAREA+1(L'PRAREA-1),PRAREA
         MVC   PRAREA+001(L'PRTIDESC),PRTIDESC
         L     R1,INRECCT             LOAD RECORD COUNT
         CVD   R1,PACKAREA            CONVERT IT TO DECIMAL
         OI    PACKAREA+L'PACKAREA-1,X'0F'    EBCDIC ZONE
         UNPK  PRAREA+001+L'PRTIDESC-2-4(4),PACKAREA
         MVC   PRAREA+001+L'PRTIDESC(L'INAREA),INAREA
         PUT   PRDCB,PRAREA        WRITE OUTPUT LINE
         L     RLINK,PRSVCMDL      RELOAD RETURN REGISTER
         BR    RLINK               RETURN TO CALLER
         SPACE 5
PRTIDESC DC    C'   SYSIN RECORD # NNNN: '
         EJECT  ,
*
*
*        SYSPRINT PRINT "SYSPARM" RECORD ROUTINE.
*
*        THIS ROUTINE WRITES A PRINT LINE DISPLAYING THE CURRENT
*        "SYSPARM" DATA SET INPUT RECORD.
*
PRTSPREC DS    0H
         ST    RLINK,PRSVCMDL      SAVE RETURN REGISTER VALUE
         MVI   PRAREA,X'40'         CLEAR
         MVC   PRAREA+1(L'PRAREA-1),PRAREA
         MVC   PRAREA+001(L'PRTSDESC),PRTSDESC
         L     R1,SPRECCT             LOAD RECORD COUNT
         CVD   R1,PACKAREA            CONVERT IT TO DECIMAL
         OI    PACKAREA+L'PACKAREA-1,X'0F'    EBCDIC ZONE
         UNPK  PRAREA+001+L'PRTSDESC-2-4(4),PACKAREA
         MVC   PRAREA+001+L'PRTSDESC(L'SPAREA),SPAREA
         PUT   PRDCB,PRAREA        WRITE OUTPUT LINE
         L     RLINK,PRSVCMDL      RELOAD RETURN REGISTER
         BR    RLINK               RETURN TO CALLER
         SPACE 5
PRTSDESC DC    C' SYSPARM RECORD # NNNN: '
         EJECT  ,
*
*
*        SYSPRINT DCB CLOSE ROUTINE
*
*        CLOSE THE -SYSPRINT- DCB
CLSPRDCB DS    0H
         ST    RLINK,PRSVCLSL      SAVE RLINK REGISTER VALUE
         TM    PRFLAG1,PRF1OPEN    IS SYSPRINT OPEN?
         BZ    CLSPRERR            BYPASS CLOSE IF NOT
         MVC   PROPEN(4),CLOSPR1   INITIALIZE OPEN/CLOSE LIST
         CLOSE (PRDCB,LEAVE),      CLOSE THE DATA SET                  X
               MF=(E,PROPEN)
         FREEPOOL PRDCB            RELEASE THE BUFFER POOL
         NI    PRFLAG1,255-PRF1OPEN RESET DATASET OPEN FLAG
         LA    R15,00              SET ZERO RETURN CODE
         B     CLSPREND            GO RETURN TO CALLER
CLSPRERR DS    0H                  THE DATA SET IS ALREADY CLOSED
         LA    R15,04              SET NON-ZERO RETURN CODE
CLSPREND LTR   R15,R15             SET CC FROM RETURN CODE
         L     RLINK,PRSVCLSL      RELOAD RETURN REGISTER VALUE
         BR    RLINK               RETURN TO CALLER
         TITLE 'PAGEADD - PARM STRING ANALYSIS ROUTINES'
*****************************************************************
*                                                               *
*        THE FOLLOWING ROUTINES PROCESS DATA FROM THE           *
*        EXEC STATEMENT PARM FIELD AND FROM RECORDS             *
*        IN THE SYSPARM DATA SET.  ON ENTRY, REGISTERS R0 & R1  *
*        ARE EXPECTED AS FOLLOWS.....                           *
*                                                               *
*            R0   LENGTH OF THE PARM STRING.                    *
*            R1   ADDRESS OF THE FIRST BYTE OF THE PARM STRING. *
*                                                               *
*****************************************************************
PARMANAL DS    0H                  ANALYZE PARM STRING
         ST    RLINK,PRMSCALK      SAVE LINK REGISTER RETURN VALUE
         BAS   RLINK,PRMSCNBL      ADVANCE TO FIRST NON-BLANK
         SPACE 5
PRMLOOP1 DS    0H                  START OF PARM FIELD ANALYSIS LOOP
         EJECT  ,
*****************************************************************
*        CHECK FOR THE "TEST" PARAMETER                         *
*        TO SEE IF THE PROGRAM IS TO EXECUTE IN TEST MODE.      *
*****************************************************************
PRMTEST  DS    0H                  PROCESS "TEST" PARAMETER
         LA    R15,4               "TEST" PARM LENGTH
         CR    R0,R15              TEST PARM LENGTH
         BL    BYPRMTST            IF LN NOT SUFFICIENT
         OC    0(4,R1),EBLANKS     FORCE UPPER CASE
         CLC   0(4,R1),=C'TEST'    PARM=TEST?
         BNE   BYPRMTST            IF NOT TEST
         MVI   TESTMODE,04         INDICATE PROGRAM IN TEST MODE
         MVI   CMDMODE,04          ALSO DON'T ISSUE OPERATOR CMDS
         MVI   INPMODE,00          PROCESS INPUT DATA SET
         MVI   MSGMODEC,00         ISSUE MSGS FOR COMMANDS
         MVI   MSGMODED,00         ISSUE MSGS FOR DAY OF WEEK/YEAR
         MVI   MSGMODES,00         ISSUE MSGS FOR SYSTEM ID
         MVI   MSGMODET,00         ISSUE MSGS FOR BEFORE/AFTER
         AR    R1,R15              TO NEXT DATA BYTE
         SR    R0,R15              DECREMENT REMAINING LENGTH
         B     PRMLOOP5            GO BYPASS DELIMITER
BYPRMTST DS    0H
*****************************************************************
*        CHECK FOR THE "NOTEST" PARAMETER                       *
*        TO SEE IF THE PROGRAM IS NOT TO EXECUTE IN TEST MODE.  *
*****************************************************************
PRMNOTST DS    0H                  PROCESS "NOTEST" PARAMETER
         LA    R15,6               "NOTEST" PARM LENGTH
         CR    R0,R15              TEST PARM LENGTH
         BL    BYPRMNTS            IF LN NOT SUFFICIENT
         OC    0(6,R1),EBLANKS     FORCE UPPER CASE
         CLC   0(6,R1),=C'NOTEST'  PARM=NOTEST?
         BNE   BYPRMNTS            IF NOT "NOTEST"
         MVI   TESTMODE,00         INDICATE NOT IN TEST MODE
         AR    R1,R15              TO NEXT DATA BYTE
         SR    R0,R15              DECREMENT REMAINING LENGTH
         B     PRMLOOP5            GO BYPASS DELIMITER
BYPRMNTS DS    0H
         EJECT  ,
*****************************************************************
*        CHECK FOR THE "MSG" PARAMETER                          *
*        TO SEE IF THE PROGRAM IS TO ISSUE AN OPERATOR MESSAGE  *
*        FOR EACH COMMAND EXECUTED.                             *
*****************************************************************
PRMMSG   DS    0H                  PROCESS "MSG" PARAMETER
         LA    R15,3               "MSG" PARM LENGTH
         CR    R0,R15              TEST PARM LENGTH
         BL    BYPRMMSG            IF LN NOT SUFFICIENT
         OC    0(3,R1),EBLANKS     FORCE UPPER CASE
         CLC   0(3,R1),=C'MSG'     PARM=MSG?
         BNE   BYPRMMSG            IF NOT "MSG"
         AR    R1,R15              TO NEXT DATA BYTE
         SR    R0,R15              DECREMENT REMAINING LENGTH
         BNP   PRMMSGA             IF END, SET ALL MSG OPTIONS
         LA    R15,1               ADVANCE ONE CHARACTER FOR SUFFIX
         OI    0(R1),X'40'         SET NEXT BYTE UPPER CASE
         CLI   0(R1),C'C'          "MSGC"?
         BE    PRMMSGC             SET INDICATOR IF YES
         CLI   0(R1),C'D'          "MSGD"?
         BE    PRMMSGD             SET INDICATOR IF YES
         CLI   0(R1),C'S'          "MSGS"?
         BE    PRMMSGS             SET INDICATOR IF YES
         CLI   0(R1),C'T'          "MSGT"?
         BE    PRMMSGT             SET INDICATOR IF YES
PRMMSGA  DS    0H
         SR    R15,R15             DONT ADVANCE AFTER SETTING OPTIONS
         MVI   MSGMODEC,X'00'      SET COMMAND MESSAGE MODE
         MVI   MSGMODED,X'00'      SET DATE MESSAGE MODE
         MVI   MSGMODES,X'00'      SET SID  MESSAGE MODE
         MVI   MSGMODET,X'00'      SET TIME MESSAGE MODE
         B     PRMMSGZ             GO BYPASS DELIMITER
PRMMSGC  DS    0H
         MVI   MSGMODEC,X'00'      SET COMMAND MESSAGE MODE
         B     PRMMSGZ             GO BYPASS DELIMITER
PRMMSGD  DS    0H
         MVI   MSGMODED,X'00'      SET DATE MESSAGE MODE
         B     PRMMSGZ             GO BYPASS DELIMITER
PRMMSGS  DS    0H
         MVI   MSGMODES,X'00'      SET SID  MESSAGE MODE
         B     PRMMSGZ             GO BYPASS DELIMITER
PRMMSGT  DS    0H
         MVI   MSGMODET,X'00'      SET TIME MESSAGE MODE
         B     PRMMSGZ             GO BYPASS DELIMITER
PRMMSGZ  DS    0H                  END OF "MSG" PARM PROCESSING
         AR    R1,R15              TO NEXT DATA BYTE
         SR    R0,R15              DECREMENT REMAINING LENGTH
         B     PRMLOOP5            GO BYPASS DELIMITER
BYPRMMSG DS    0H
         EJECT  ,
*****************************************************************
*        CHECK FOR THE "NOMSG" PARAMETER                        *
*        TO SEE IF THE PROGRAM IS NOT TO ISSUE AN OPERATOR      *
*        MESSAGE FOR EACH COMMAND EXECUTED.                     *
*****************************************************************
PRMNOMSG DS    0H                  PROCESS "NOMSG" PARAMETER
         LA    R15,5               "NOMSG" PARM LENGTH
         CR    R0,R15              TEST PARM LENGTH
         BL    BYPRMNMS            IF LN NOT SUFFICIENT
         OC    0(5,R1),EBLANKS     FORCE UPPER CASE
         CLC   0(5,R1),=C'NOMSG'    PARM=NOMSG?
         BNE   BYPRMNMS            IF NOT NOMSG
         AR    R1,R15              TO NEXT DATA BYTE
         SR    R0,R15              DECREMENT REMAINING LENGTH
         BNP   PRMNMSGA            IF END, SET ALL MSG OPTIONS
         LA    R15,1               ADVANCE ONE CHARACTER FOR SUFFIX
         OI    0(R1),X'40'         SET NEXT BYTE UPPER CASE
         CLI   0(R1),C'C'          "NOMSGC"?
         BE    PRMNMSGC            SET INDICATOR IF YES
         CLI   0(R1),C'D'          "NOMSGD"?
         BE    PRMNMSGD            SET INDICATOR IF YES
         CLI   0(R1),C'S'          "NOMSGS"?
         BE    PRMNMSGS            SET INDICATOR IF YES
         CLI   0(R1),C'T'          "NOMSGT"?
         BE    PRMNMSGT            SET INDICATOR IF YES
PRMNMSGA DS    0H
         SR    R15,R15             DONT ADVANCE AFTER SETTING OPTIONS
         MVI   MSGMODEC,X'04'      SET COMMAND MESSAGE MODE
         MVI   MSGMODED,X'04'      SET DATE MESSAGE MODE
         MVI   MSGMODES,X'04'      SET SID  MESSAGE MODE
         MVI   MSGMODET,X'04'      SET TIME MESSAGE MODE
         B     PRMNMSGZ            GO BYPASS DELIMITER
PRMNMSGC DS    0H
         MVI   MSGMODEC,X'04'      SET COMMAND MESSAGE MODE
         B     PRMNMSGZ            GO BYPASS DELIMITER
PRMNMSGD DS    0H
         MVI   MSGMODED,X'04'      SET DATE MESSAGE MODE
         B     PRMNMSGZ            GO BYPASS DELIMITER
PRMNMSGS DS    0H
         MVI   MSGMODES,X'04'      SET SID MESSAGE MODE
         B     PRMNMSGZ            GO BYPASS DELIMITER
PRMNMSGT DS    0H
         MVI   MSGMODET,X'04'      SET TIME MESSAGE MODE
         B     PRMNMSGZ            GO BYPASS DELIMITER
PRMNMSGZ DS    0H                  END OF "MSG" PARM PROCESSING
         AR    R1,R15              TO NEXT DATA BYTE
         SR    R0,R15              DECREMENT REMAINING LENGTH
         B     PRMLOOP5            GO BYPASS DELIMITER
BYPRMNMS DS    0H
         EJECT  ,
*****************************************************************
*        CHECK FOR THE "INPUT" PARAMETER                        *
*        TO SEE IF THE PROGRAM IS TO READ THE INPUT DATA SET.   *
*****************************************************************
PRMINPUT DS    0H                  PROCESS "INPUT" PARAMETER
         LA    R15,5               "INPUT" PARM LENGTH
         CR    R0,R15              TEST PARM LENGTH
         BL    BYPRMINP            IF LN NOT SUFFICIENT
         OC    0(5,R1),EBLANKS     FORCE UPPER CASE
         CLC   0(5,R1),=C'INPUT'   PARM=INPUT?
         BNE   BYPRMINP            IF NOT INPUT
         MVI   INPMODE,00          PROCESS INPUT DATA SET
         MVC   INDDNAM,DFLTINDD    ESTABLISH SYSIN    DATASET DDNAME
         AR    R1,R15              TO NEXT DATA BYTE
         SR    R0,R15              DECREMENT REMAINING LENGTH
         BNP   PRMLOOP5            IF AT END OF PARM STRING
         CLI   00(R1),C'='         "INPUT=" (ALTERNATE DDNAME) ??
         BNE   PRMLOOP5            ALTERNATE DDNAME NOT PRESENT
         LA    R15,1               LOAD LENGTH OF "="
         BAS   RLINK,PRMSCSTR      SCAN STRING
         B     PRMLOOP5            IF STRING IS NULL
         LA    RLINK,INDDNAM       -> INPUT DDNAME FIELD
         LA    RENTRY,L'INDDNAM        INPUT DDNAME FIELD LN
         ICM   R3,B'1000',EBLANKS  BLANK PADDING CHARACTER
         MVCL  RLINK,R2            COPY ELEMENT TO WORK AREA
         B     PRMLOOP5            GO BYPASS DELIMITER
BYPRMINP DS    0H
*****************************************************************
*        CHECK FOR THE "NOINPUT" PARAMETER                      *
*        TO SEE IF THE PROGRAM IS NOT TO READ                   *
*        THE INPUT DATA SET.                                    *
*****************************************************************
PRMNOINP DS    0H                  PROCESS "NOINPUT" PARAMETER
         LA    R15,7               "NOINPUT" PARM LENGTH
         CR    R0,R15              TEST PARM LENGTH
         BL    BYPRMNIN            IF LN NOT SUFFICIENT
         OC    0(7,R1),EBLANKS     FORCE UPPER CASE
         CLC   0(7,R1),=C'NOINPUT' PARM=NOINPUT?
         BNE   BYPRMNIN            IF NOT NOINPUT
         MVI   INPMODE,04          DON'T PROCESS INPUT DATA SET
         MVI   CMDMODE,04          "NOINPUT" MODE IMPLIES "NOCMDS"
         AR    R1,R15              TO NEXT DATA BYTE
         SR    R0,R15              DECREMENT REMAINING LENGTH
         B     PRMLOOP5            GO BYPASS DELIMITER
BYPRMNIN DS    0H
         EJECT  ,
*****************************************************************
*        CHECK FOR THE "CMDS" PARAMETER                         *
*        TO SEE IF THE PROGRAM IS TO EXECUTE IN CMDS MODE.      *
*****************************************************************
PRMCMDS  DS    0H                  PROCESS "CMDS" PARAMETER
         LA    R15,4               "CMDS" PARM LENGTH
         CR    R0,R15              TEST PARM LENGTH
         BL    BYPRMCMD            IF LN NOT SUFFICIENT
         OC    0(4,R1),EBLANKS     FORCE UPPER CASE
         CLC   0(4,R1),=C'CMDS'    PARM=CMDS?
         BNE   BYPRMCMD            IF NOT CMDS
         MVI   INPMODE,00          "CMD" MODE IMPLIES "INPUT" MODE
         MVI   CMDMODE,00          SET "CMDS"
         AR    R1,R15              TO NEXT DATA BYTE
         SR    R0,R15              DECREMENT REMAINING LENGTH
         B     PRMLOOP5            GO BYPASS DELIMITER
BYPRMCMD DS    0H
*****************************************************************
*        CHECK FOR THE "NOCMDS" PARAMETER                       *
*        TO SEE IF THE PROGRAM IS NOT TO ISSUE OPERATOR CMDS.   *
*****************************************************************
PRMNOCMD DS    0H                  PROCESS "NOCMDS" PARAMETER
         LA    R15,6               "NOCMDS" PARM LENGTH
         CR    R0,R15              TEST PARM LENGTH
         BL    BYPRMNCM            IF LN NOT SUFFICIENT
         OC    0(6,R1),EBLANKS     FORCE UPPER CASE
         CLC   0(6,R1),=C'NOCMDS'  PARM=NOCMDS?
         BNE   BYPRMNCM            IF NOT NOCMDS
         MVI   CMDMODE,04          DON'T ISSUE OPERATOR COMMANDS
         AR    R1,R15              TO NEXT DATA BYTE
         SR    R0,R15              DECREMENT REMAINING LENGTH
         B     PRMLOOP5            GO BYPASS DELIMITER
BYPRMNCM DS    0H
         EJECT  ,
*****************************************************************
*        CHECK FOR THE "SEQ" PARAMETER                          *
*        TO SEE IF THE PROGRAM IS TO DISCARD SEQUENCE NUMBERS   *
*        IN BYTES 73-80 OF EACH INPUT RECORD.                   *
*****************************************************************
PRMSEQ   DS    0H                  PROCESS "SEQ" PARAMETER
         LA    R15,3               "SEQ" PARM LENGTH
         CR    R0,R15              TEST PARM LENGTH
         BL    BYPRMSEQ            IF LN NOT SUFFICIENT
         OC    0(3,R1),EBLANKS     FORCE UPPER CASE
         CLC   0(3,R1),=C'SEQ'     PARM=SEQ?
         BNE   BYPRMSEQ            IF NOT SEQ
         MVI   SEQMODE,00          DISCARD BYTES 73-80
         AR    R1,R15              TO NEXT DATA BYTE
         SR    R0,R15              DECREMENT REMAINING LENGTH
         B     PRMLOOP5            GO BYPASS DELIMITER
BYPRMSEQ DS    0H
*****************************************************************
*        CHECK FOR THE "NOSEQ" PARAMETER                        *
*        TO SEE IF THE PROGRAM IS TO CONSIDER BYTES 73-80       *
*        OF EACH INPUT RECORD AS PART OF THE COMMAND.           *
*****************************************************************
PRMNOSEQ DS    0H                  PROCESS "NOSEQ" PARAMETER
         LA    R15,5               "NOSEQ" PARM LENGTH
         CR    R0,R15              TEST PARM LENGTH
         BL    BYPRMNSQ            IF LN NOT SUFFICIENT
         OC    0(5,R1),EBLANKS     FORCE UPPER CASE
         CLC   0(5,R1),=C'NOSEQ'   PARM=NOSEQ?
         BNE   BYPRMNSQ            IF NOT NOSEQ
         MVI   SEQMODE,04          BYTES 73-80ARE PART OF THE COMMAND
         AR    R1,R15              TO NEXT DATA BYTE
         SR    R0,R15              DECREMENT REMAINING LENGTH
         B     PRMLOOP5            GO BYPASS DELIMITER
BYPRMNSQ DS    0H
         EJECT  ,
*****************************************************************
*        CHECK FOR THE "PAUSE" PARAMETER                        *
*        TO SEE IF THE PROGRAM IS TO ISSUE A WTOR AND WAIT      *
*        AFTER COMMANDS HAVE BEEN PROCESSED, AND BEFORE         *
*        RETURNING TO THE SYSTEM.                               *
*****************************************************************
PRMPS    DS    0H                  PROCESS "PAUSE" PARAMETER
         LA    R15,5               "PAUSE" PARM LENGTH
         CR    R0,R15              TEST PARM LENGTH
         BL    BYPRMPS             IF LN NOT SUFFICIENT
         OC    0(5,R1),EBLANKS     FORCE UPPER CASE
         CLC   0(5,R1),=C'PAUSE'   PARM=PAUSE?
         BNE   BYPRMPS             IF NOT PAUSE
         MVI   PSEMODE,00          REQUEST PAUSE WTOR
         MVI   DMCMODE,00          DELETE COMMAND MESSAGES AFTER PAUSE
         AR    R1,R15              TO NEXT DATA BYTE
         SR    R0,R15              DECREMENT REMAINING LENGTH
         B     PRMLOOP5            GO BYPASS DELIMITER
BYPRMPS  DS    0H
*****************************************************************
*        CHECK FOR THE "NOPAUSE" PARAMETER                      *
*        TO SEE IF THE PROGRAM IS TO BYPASS ISSUING OF THE WTOR *
*        AFTER COMMANDS HAVE BEEN PROCESSED, AND BEFORE         *
*        RETURNING TO THE SYSTEM.                               *
*****************************************************************
PRMNOPS  DS    0H                  PROCESS "NOPAUSE" PARAMETER
         LA    R15,7               "NOPAUSE" PARM LENGTH
         CR    R0,R15              TEST PARM LENGTH
         BL    BYPRMNPS            IF LN NOT SUFFICIENT
         OC    0(7,R1),EBLANKS     FORCE UPPER CASE
         CLC   0(7,R1),=C'NOPAUSE'       PARM=NOPAUSE?
         BNE   BYPRMNPS            IF NOT NOPAUSE
         MVI   PSEMODE,04          BYPASS PAUSE WTOR
         MVI   DMCMODE,04          LEAVE COMMAND MESSAGES ON SCREEN
         AR    R1,R15              TO NEXT DATA BYTE
         SR    R0,R15              DECREMENT REMAINING LENGTH
         B     PRMLOOP5            GO BYPASS DELIMITER
BYPRMNPS DS    0H
         EJECT  ,
*****************************************************************
*        CHECK FOR THE "PARMDD" PARAMETER                       *
*        TO SEE IF THE PROGRAM IS TO PROCESS RECORDS FROM THE   *
*        SYSPARM DATA SET IN ADDITION TO PROCESSING THE         *
*        EXEC STATEMENT PARM FIELD.                             *
*****************************************************************
PRMSP    DS    0H                  PROCESS "PARMDD" PARAMETER
         LA    R15,6               "PARMDD" PARM LENGTH
         CR    R0,R15              TEST PARM LENGTH
         BL    BYPRMSP             IF LN NOT SUFFICIENT
         OC    0(6,R1),EBLANKS     FORCE UPPER CASE
         CLC   0(6,R1),=C'PARMDD'  PARM=PARMDD?
         BNE   BYPRMSP             IF NOT PARMDD
         MVI   PRMMODE,00          REQUEST DATA SET PROCESSING
         MVC   SPDDNAM,DFLTSPDD    ESTABLISH SYSPARM  DATASET DDNAME
         AR    R1,R15              TO NEXT DATA BYTE
         SR    R0,R15              DECREMENT REMAINING LENGTH
         BNP   PRMLOOP5            IF AT END OF PARM STRING
         CLI   00(R1),C'='         "INPUT=" (ALTERNATE DDNAME) ??
         BNE   PRMLOOP5            ALTERNATE DDNAME NOT PRESENT
         LA    R15,1               LOAD LENGTH OF "="
         BAS   RLINK,PRMSCSTR      SCAN STRING
         B     PRMLOOP5            IF STRING IS NULL
         LA    RLINK,SPDDNAM       -> SYSPARM DDNAME FIELD
         LA    RENTRY,L'SPDDNAM       SYSPARM DDNAME FIELD LN
         ICM   R3,B'1000',EBLANKS  BLANK PADDING CHARACTER
         MVCL  RLINK,R2            COPY ELEMENT TO WORK AREA
         B     PRMLOOP5            GO BYPASS DELIMITER
BYPRMSP  DS    0H
*****************************************************************
*        CHECK FOR THE "NOPARMDD" PARAMETER                     *
*        TO SEE IF THE PROGRAM IS TO CONSIDER ONLY THE EXEC     *
*        STATEMENT PARM FIELD INFORMATION IN DETERMINING        *
*        THE OPTIONS TO USE FOR EXECUTION.                      *
*****************************************************************
PRMNOSP  DS    0H                  PROCESS "NOPARMDD" PARAMETER
         LA    R15,8               "NOPARMDD" PARM LENGTH
         CR    R0,R15              TEST PARM LENGTH
         BL    BYPRMNSP            IF LN NOT SUFFICIENT
         OC    0(8,R1),EBLANKS     FORCE UPPER CASE
         CLC   0(8,R1),=C'NOPARMDD'      PARM=NOPARMDD?
         BNE   BYPRMNSP            IF NOT NOPARMDD
         MVI   PRMMODE,04          BYPASS DATA SET PROCESSING
         AR    R1,R15              TO NEXT DATA BYTE
         SR    R0,R15              DECREMENT REMAINING LENGTH
         B     PRMLOOP5            GO BYPASS DELIMITER
BYPRMNSP DS    0H
         EJECT  ,
*****************************************************************
*        CHECK FOR THE "PROMPT" PARAMETER                       *
*        TO SEE IF THE PROGRAM IS TO QUERY THE OPERATOR TO SEE  *
*        IF OPERATOR COMMANDS ARE TO BE EXECUTED.               *
*****************************************************************
PRMPT    DS    0H                  PROCESS "PROMPT" PARAMETER
         LA    R15,6               "PROMPT" PARM LENGTH
         CR    R0,R15              TEST PARM LENGTH
         BL    BYPRMPT             IF LN NOT SUFFICIENT
         OC    0(6,R1),EBLANKS     FORCE UPPER CASE
         CLC   0(6,R1),=C'PROMPT'  PARM=PROMPT?
         BNE   BYPRMPT             IF NOT PROMPT
         MVI   PMTMODE,00          REQUEST OPERATOR PROMPTING
         AR    R1,R15              TO NEXT DATA BYTE
         SR    R0,R15              DECREMENT REMAINING LENGTH
         B     PRMLOOP5            GO BYPASS DELIMITER
BYPRMPT  DS    0H
*****************************************************************
*        CHECK FOR THE "NOPROMPT" PARAMETER                     *
*        TO SEE IF THE PROGRAM IS NOT TO QUERY THE OPERATOR     *
*        TO SEE IF OPERATOR COMMANDS ARE TO BE EXECUTED.        *
*****************************************************************
PRMNOPT  DS    0H                  PROCESS "NOPROMPT" PARAMETER
         LA    R15,8               "NOPROMPT" PARM LENGTH
         CR    R0,R15              TEST PARM LENGTH
         BL    BYPRMNPT            IF LN NOT SUFFICIENT
         OC    0(8,R1),EBLANKS     FORCE UPPER CASE
         CLC   0(8,R1),=C'NOPROMPT'      PARM=NOPROMPT?
         BNE   BYPRMNPT            IF NOT NOPROMPT
         MVI   PMTMODE,04          BYPASS OPERATOR PROMPTING
         AR    R1,R15              TO NEXT DATA BYTE
         SR    R0,R15              DECREMENT REMAINING LENGTH
         B     PRMLOOP5            GO BYPASS DELIMITER
BYPRMNPT DS    0H
         EJECT  ,
*****************************************************************
*        CHECK FOR THE "DOMMSGC" PARAMETER                      *
*        TO SEE IF THE PROGRAM IS TO DELETE THE COMMAND IMAGE   *
*        MESSAGES FROM THE SCREEN AFTER EXECUTION.              *
*****************************************************************
PRMDMC   DS    0H                  PROCESS "DOMMSGC" PARAMETER
         LA    R15,7               "DOMMSGC" PARM LENGTH
         CR    R0,R15              TEST PARM LENGTH
         BL    BYPRMDMC            IF LN NOT SUFFICIENT
         OC    0(7,R1),EBLANKS     FORCE UPPER CASE
         CLC   0(7,R1),=C'DOMMSGC' PARM=DOMMSGC?
         BNE   BYPRMDMC            IF NOT DOMMSGC
         MVI   DMCMODE,00          REQUEST MESSAGE DELETION
         AR    R1,R15              TO NEXT DATA BYTE
         SR    R0,R15              DECREMENT REMAINING LENGTH
         B     PRMLOOP5            GO BYPASS DELIMITER
BYPRMDMC DS    0H
*****************************************************************
*        CHECK FOR THE "NODOMMSGC" PARAMETER                    *
*        TO SEE IF THE PROGRAM IS NOT TO DELETE THE COMMAND     *
*        IMAGE MESSAGES FROM THE SCREEN AFTER EXECUTION.        *
*****************************************************************
PRMNODMC DS    0H                  PROCESS "NODOMMSGC" PARAMETER
         LA    R15,9               "NODOMMSGC" PARM LENGTH
         CR    R0,R15              TEST PARM LENGTH
         BL    BYPRMNDC            IF LN NOT SUFFICIENT
         OC    0(9,R1),EBLANKS     FORCE UPPER CASE
         CLC   0(9,R1),=C'NODOMMSGC'     PARM=NODOMMSGC?
         BNE   BYPRMNDC            IF NOT NODOMMSGC
         MVI   DMCMODE,04          BYPASS MESSAGE DELETION
         AR    R1,R15              TO NEXT DATA BYTE
         SR    R0,R15              DECREMENT REMAINING LENGTH
         B     PRMLOOP5            GO BYPASS DELIMITER
BYPRMNDC DS    0H
         EJECT  ,
*****************************************************************
*        CHECK FOR THE "CANCEL" PARAMETER                       *
*        TO SEE IF COMMAND EXECUTION IS BEING BYPASSED BY THE   *
*        OPERATOR IN RESPONSE TO A PROMPT MESSAGE.              *
*****************************************************************
PRMCNCL  DS    0H                  PROCESS "CANCEL" PARAMETER
         LA    R15,6               "CANCEL" PARM LENGTH
         CR    R0,R15              TEST PARM LENGTH
         BL    BYPRMCNC            IF LN NOT SUFFICIENT
         OC    0(6,R1),EBLANKS     FORCE UPPER CASE
         CLC   0(6,R1),=C'CANCEL'  PARM=CANCEL?
         BNE   BYPRMCNC            IF NOT CANCEL
         MVI   CNCMODE,04          INDICATE "CANCEL"
         MVI   PMTMODE,04          TURN OFF PROMPTING
         AR    R1,R15              TO NEXT DATA BYTE
         SR    R0,R15              DECREMENT REMAINING LENGTH
         B     PRMLOOP5            GO BYPASS DELIMITER
BYPRMCNC DS    0H
*****************************************************************
*        CHECK FOR THE "GO" PARAMETER                           *
*        TO SEE IF COMMAND EXECUTION IS BEING ALLOWED BY THE    *
*        OPERATOR IN RESPONSE TO A PROMPT MESSAGE.              *
*****************************************************************
PRMGO    DS    0H                  PROCESS "GO" PARAMETER
         LA    R15,2               "GO" PARM LENGTH
         CR    R0,R15              TEST PARM LENGTH
         BL    BYPRMGO             IF LN NOT SUFFICIENT
         OC    0(2,R1),EBLANKS     FORCE UPPER CASE
         CLC   0(2,R1),=C'GO'      PARM=GO?
         BNE   BYPRMGO             IF NOT "GO"
         MVI   CNCMODE,00          INDICATE "GO"
         MVI   PMTMODE,04          TURN OFF PROMPTING
         AR    R1,R15              TO NEXT DATA BYTE
         SR    R0,R15              DECREMENT REMAINING LENGTH
         B     PRMLOOP5            GO BYPASS DELIMITER
BYPRMGO  DS    0H
         EJECT  ,
*****************************************************************
*        CHECK FOR THE "CN=" PARAMETER                          *
*        TO SEE IF THE USER WANTS TO OVERRIDE THE               *
*        DEFAULT DEFAULT CONSOLE ID SPECIFICATION               *
*        USED FOR PROGRAM MESSAGES AND COMMAND IMAGE MESSAGES   *
*        ISSUED BY THE PROGRAM.                                 *
*****************************************************************
PRMCONID DS    0H                  PROCESS "CN=" PARAMETER
         LA    R15,3               "CN=" MINIMUM PARM LENGTH
         CR    R0,R15              TEST PARM LENGTH
         BL    BYPRMCON            IF LN NOT CORRECT
         OC    0(3,R1),EBLANKS     FORCE UPPER CASE
         CLC   0(3,R1),=C'CN='     CN=?
         BNE   BYPRMCON            IF NOT "CN="
         BAS   RLINK,PRMSCVAL      GET NUMERIC CONSOLE ID VALUE IN R15
         B     *+L'*+4             IF CONSOLE ID VALUE SUPPLIED NULL
         B     PRMCONUM            IF VALUE WAS EXTRACTED
*        NUMERIC VALUE WAS NULL, ATTEMPT NON-NUMERIC VALUE.
         BAS   RLINK,PRMSCSTR      GET STRING CONSOLE ID VALUE
         B     PRMCONZZ            IF CONSOLE ID VALUE SUPPLIED NULL
*
*        EXTRACTED CONSOLE ID IS NON-NUMERIC
PRMCONNN DS    0H
         LA    R15,2               "CN=" EXACT VALUE LENGTH
         CR    R3,R15              TEST EXTRACTED VALUE LENGTH
         BNE   PRMCONZZ            IF LN NOT CORRECT
         ICM   R15,B'0011',00(R2)  LOAD EBCDIC CONSOLE ID
         CLM   R15,B'0011',=C'**'  REQUEST XEQ CONSOLE ID?
         BE    PRMCONUM            PROCESS LIKE NUMERIC ID
         CLM   R15,B'0011',=C'MC'  REQUEST MASTER CONSOLE ID?
         BE    PRMCONUM            PROCESS LIKE NUMERIC ID
         B     PRMCONZZ            IF VALUE WAS INVALID
*
*        EXTRACTED CONSOLE ID IS NUMERIC
PRMCONUM DS    0H
         STCM  R15,B'0011',MSGCONID STORE CONSOLE ID
*
*        EXTRACTED CONSOLE ID HAS BEEN PROCESSED.
PRMCONZZ DS    0H
         B     PRMLOOP5            THIS PARAMETER FULLY PROCESSED
*
*        THE PARAMETER WAS NOT "CN=".
BYPRMCON DS    0H
         EJECT  ,
*****************************************************************
*        CHECK FOR THE "DELAY=" PARAMETER                       *
*        TO SEE IF THE USER WANTS TO OVERRIDE THE               *
*        DEFAULT DELAY INTERVAL.                                *
*****************************************************************
PRMDELAY DS    0H                  PROCESS "DELAY=" PARAMETER
         LA    R15,6               "DELAY=" MINIMUM PARM LENGTH
         CR    R0,R15              TEST PARM LENGTH
         BL    BYPRMDLY            IF LN NOT SUFFICIENT
         OC    0(6,R1),EBLANKS     FORCE UPPER CASE
         CLC   0(6,R1),=C'DELAY='     DELAY=?
         BNE   BYPRMDLY            IF NOT "DELAY="
         BAS   RLINK,PRMSCBTM      GET TIME INTERVAL IN 1/100 SEC BIN
         B     PRMLOOP5            IF TIME VALUE SUPPLIED NULL
         ST    R15,DELAYTME        STORE DELAY TIME IN BINARY
         MVC   TODTME,=F'-1'       "DELAY=" & "TOD=" ARE INCOMPATIBLE
         B     PRMLOOP5            THIS PARAMETER FULLY PROCESSED
BYPRMDLY DS    0H
*****************************************************************
*        CHECK FOR THE "TOD=" PARAMETER                         *
*        TO SEE IF THE USER WANTS TO SPECIFY A TIME OF DAY      *
*        WHEN THE COMMANDS SHOULD BE EXECUTED.                  *
*****************************************************************
PRMTOD   DS    0H                  PROCESS "TOD=" PARAMETER
         LA    R15,4               "TOD=" MINIMUM PARM LENGTH
         CR    R0,R15              TEST PARM LENGTH
         BL    BYPRMTOD            IF LN NOT SUFFICIENT
         OC    0(4,R1),EBLANKS     FORCE UPPER CASE
         CLC   0(4,R1),=C'TOD='       TOD=?
         BNE   BYPRMTOD            IF NOT "TOD="
         BAS   RLINK,PRMSCBTM      GET TIME-OF-DAY IN 1/100 SEC BIN
         B     PRMLOOP5            IF TIME VALUE SUPPLIED NULL
         ST    R15,TODTME          STORE TIME-OF-DAY IN BINARY
         MVC   DELAYTME,=F'-1'     "TOD=" & "DELAY=" ARE INCOMPATIBLE
         B     PRMLOOP5            THIS PARAMETER FULLY PROCESSED
BYPRMTOD DS    0H
         EJECT  ,
*****************************************************************
*        CHECK FOR THE "BEFORE=" PARAMETER                      *
*        TO SEE IF THE USER WANTS TO SPECIFY A TIME OF DAY      *
*        BEFORE WHICH THE COMMANDS SHOULD NOT BE EXECUTED.      *
*****************************************************************
PRMBEFOR DS    0H                  PROCESS "BEFORE=" PARAMETER
         LA    R15,7               "BEFORE=" MINIMUM PARM LENGTH
         CR    R0,R15              TEST PARM LENGTH
         BL    BYPRMBFR            IF LN NOT CORRECT
         OC    0(7,R1),EBLANKS     FORCE UPPER CASE
         CLC   0(7,R1),=C'BEFORE='    BEFORE=?
         BNE   BYPRMBFR            IF NOT "BEFORE="
         BAS   RLINK,PRMSCBTM      GET TIME INTERVAL IN 1/100 SEC BIN
         B     PRMLOOP5            IF TIME VALUE SUPPLIED NULL
         ST    R15,BEFORTME        STORE DELAY TIME IN BINARY
         B     PRMLOOP5            THIS PARAMETER FULLY PROCESSED
BYPRMBFR DS    0H
*****************************************************************
*        CHECK FOR THE "AFTER=" PARAMETER                       *
*        TO SEE IF THE USER WANTS TO SPECIFY A TIME OF DAY      *
*        AFTER WHICH THE COMMANDS SHOULD NOT BE EXECUTED.       *
*****************************************************************
PRMAFTER DS    0H                  PROCESS "AFTER=" PARAMETER
         LA    R15,6               "AFTER=" MINIMUM PARM LENGTH
         CR    R0,R15              TEST PARM LENGTH
         BL    BYPRMAFT            IF LN NOT CORRECT
         OC    0(6,R1),EBLANKS     FORCE UPPER CASE
         CLC   0(6,R1),=C'AFTER='     AFTER=?
         BNE   BYPRMAFT            IF NOT "AFTER="
         BAS   RLINK,PRMSCBTM      GET TIME INTERVAL IN 1/100 SEC BIN
         B     PRMLOOP5            IF TIME VALUE SUPPLIED NULL
         ST    R15,AFTERTME        STORE DELAY TIME IN BINARY
         B     PRMLOOP5            THIS PARAMETER FULLY PROCESSED
BYPRMAFT DS    0H
         EJECT  ,
*****************************************************************
*        CHECK FOR THE "DESC=" PARAMETER                        *
*        TO SEE IF AN MCS DESCRIPTOR CODE SPECIFICATION IS      *
*        TO BE USED FOR ALL PROGRAM MESSAGES AND COMMAND        *
*        IMAGE MESSAGES ISSUED BY THE PROGRAM.                  *
*****************************************************************
PRMDESC  DS    0H                  PROCESS "DESC=" PARAMETER
         LA    R15,5               "DESC=" MINIMUM PARM LENGTH
         CR    R0,R15              TEST PARM LENGTH
         BL    BYPRMDSC            IF LN NOT CORRECT
         OC    0(5,R1),EBLANKS     FORCE UPPER CASE
         CLC   0(5,R1),=C'DESC='      DESC=?
         BNE   BYPRMDSC            IF NOT "DESC="
         BAS   RLINK,PRMBITLS      GET BIT LIST
         SLL   R15,1               DROP BIT0
         STCM  R15,B'1100',MSGDSCCD    SAVE DESCRIPTOR CODE BIT MASK
         B     PRMLOOP5            THIS PARAMETER FULLY PROCESSED
BYPRMDSC DS    0H
*****************************************************************
*        CHECK FOR THE "ROUTCDE=" PARAMETER                     *
*        TO SEE IF AN MCS ROUTING CODE SPECIFICATION IS         *
*        TO BE USED FOR ALL PROGRAM MESSAGES AND COMMAND        *
*        IMAGE MESSAGES ISSUED BY THE PROGRAM.                  *
*****************************************************************
PRMRTECD DS    0H                  PROCESS "ROUTCDE=" PARAMETER
         LA    R15,8               "ROUTCDE=" MINIMUM PARM LENGTH
         CR    R0,R15              TEST PARM LENGTH
         BL    BYPRMRTE            IF LN NOT CORRECT
         OC    0(8,R1),EBLANKS     FORCE UPPER CASE
         CLC   0(8,R1),=C'ROUTCDE='   ROUTCDE=?
         BNE   BYPRMRTE            IF NOT "ROUTCDE="
         BAS   RLINK,PRMBITLS      GET BIT LIST
         SLL   R15,1               DROP BIT0
         STCM  R15,B'1100',MSGRTECD    SAVE ROUTING CODE BIT MASK
         B     PRMLOOP5            THIS PARAMETER FULLY PROCESSED
BYPRMRTE DS    0H
         EJECT  ,
*****************************************************************
*        CHECK FOR THE "DOW=" PARAMETER                         *
*        TO SEE IF THE USER WANTS TO SPECIFY THE DAYS OF THE    *
*        WEEK ON WHICH THE COMMANDS CAN BE EXECUTED.            *
*****************************************************************
PRMDOW   DS    0H                  PROCESS "DOW=" PARAMETER
         LA    R15,4               "DOW=" MINIMUM PARM LENGTH
         CR    R0,R15              TEST PARM LENGTH
         BL    BYPRMDOW            IF LN NOT CORRECT
         OC    0(4,R1),EBLANKS     FORCE UPPER CASE
         CLC   0(4,R1),=C'DOW='       DOW=?
         BNE   BYPRMDOW            IF NOT "DOW="
         BAS   RLINK,PRMSCDOW      GET DAY OF WEEK MASK
         B     PRMLOOP5            IF DOW VALUE SUPPLIED NULL
         STC   R15,DOWMASKA        STORE DAY OF WEEK MASK
         STC   R15,DOWMASKB        STORE DAY OF WEEK MASK
         STC   R15,DOWMASKC        STORE DAY OF WEEK MASK
         B     PRMLOOP5            THIS PARAMETER FULLY PROCESSED
BYPRMDOW DS    0H
*****************************************************************
*        CHECK FOR THE "DOWA=" PARAMETER                        *
*        TO SEE IF THE USER WANTS TO SPECIFY THE DAYS OF THE    *
*        WEEK ON WHICH THE COMMANDS CAN BE EXECUTED DURING THE  *
*        INTERVAL BETWEEN 00:00:00.00 AND THE "AFTER" TIME      *
*        WHEN THE "AFTER" TIME IS EARLIER THAN THE "BEFORE"     *
*        TIME.                                                  *
*****************************************************************
PRMDOWA  DS    0H                  PROCESS "DOWA=" PARAMETER
         LA    R15,5               "DOWA=" MINIMUM PARM LENGTH
         CR    R0,R15              TEST PARM LENGTH
         BL    BYPRMDWA            IF LN NOT CORRECT
         OC    0(5,R1),EBLANKS     FORCE UPPER CASE
         CLC   0(5,R1),=C'DOWA='      DOWA=?
         BNE   BYPRMDWA            IF NOT "DOWA="
         BAS   RLINK,PRMSCDOW      GET DAY OF WEEK MASK
         B     PRMLOOP5            IF DOW VALUE SUPPLIED NULL
         STC   R15,DOWMASKA        STORE DAY OF WEEK MASK
         B     PRMLOOP5            THIS PARAMETER FULLY PROCESSED
BYPRMDWA DS    0H
*****************************************************************
*        CHECK FOR THE "DOWB=" PARAMETER                        *
*        TO SEE IF THE USER WANTS TO SPECIFY THE DAYS OF THE    *
*        WEEK ON WHICH THE COMMANDS CAN BE EXECUTED DURING THE  *
*        INTERVAL BETWEEN THE "BEFORE" TIME AND 24:00:00.00     *
*        WHEN THE "AFTER" TIME IS EARLIER THAN THE "BEFORE"     *
*        TIME.                                                  *
*****************************************************************
PRMDOWB  DS    0H                  PROCESS "DOWA=" PARAMETER
         LA    R15,5               "DOWA=" MINIMUM PARM LENGTH
         CR    R0,R15              TEST PARM LENGTH
         BL    BYPRMDWB            IF LN NOT CORRECT
         OC    0(5,R1),EBLANKS     FORCE UPPER CASE
         CLC   0(5,R1),=C'DOWB='      DOWB=?
         BNE   BYPRMDWB            IF NOT "DOWB="
         BAS   RLINK,PRMSCDOW      GET DAY OF WEEK MASK
         B     PRMLOOP5            IF DOW VALUE SUPPLIED NULL
         STC   R15,DOWMASKB        STORE DAY OF WEEK MASK
         B     PRMLOOP5            THIS PARAMETER FULLY PROCESSED
BYPRMDWB DS    0H
         EJECT  ,
*****************************************************************
*        CHECK FOR THE "DOY=" PARAMETER                         *
*        TO SEE IF THE USER WANTS TO SPECIFY THE DAYS OF THE    *
*        YEAR ON WHICH COMMANDS CAN BE EXECUTED.                *
*****************************************************************
PRMDOY   DS    0H                  PROCESS "DOY=" PARAMETER
         LA    R15,4               "DOY=" MINIMUM PARM LENGTH
         LA    R2,00               INDICATE INCLUDE MODE
         CR    R0,R15              TEST PARM LENGTH
         BL    BYPRMDOY            IF LN NOT CORRECT
         OC    0(4,R1),EBLANKS     FORCE UPPER CASE
         CLC   0(4,R1),=C'DOY='       DOY=?
         BE    PRMDOYSC            PROCESS DOY LIST IF YES
*****************************************************************
*        CHECK FOR THE "DOYX=" PARAMETER                        *
*        TO SEE IF THE USER WANTS TO SPECIFY THE DAYS OF THE    *
*        YEAR ON WHICH COMMANDS CANNOT BE EXECUTED.             *
*****************************************************************
PRMDOYX  DS    0H                  PROCESS "DOYX=" PARAMETER
         LA    R15,5               "DOYX=" MINIMUM PARM LENGTH
         LA    R2,04               INDICATE EXCLUDE MODE
         CR    R0,R15              TEST PARM LENGTH
         BL    BYPRMDOY            IF LN NOT CORRECT
         OC    0(5,R1),EBLANKS     FORCE UPPER CASE
         CLC   0(5,R1),=C'DOYX='      DOYX=?
         BE    PRMDOYSC            PROCESS DOYX LIST IF YES
*
*        THE PARAMETER IS NEITHER "DOY=" NOR "DOYX=".
         B     BYPRMDOY            IF NOT DOY=/DOYX=
*****************************************************************
*        PROCESS THE "DOY=" / "DOYX=" VALUES LIST.              *
*****************************************************************
PRMDOYSC BAS   RLINK,PRMDOYLS      PROCESS DAY-OF-YEAR LIST
*****************************************************************
*        "DOY=" / "DOYX=" PARAMETER PROCESSING IS COMPLETE.     *
*****************************************************************
BYPRMDOY DS    0H
         EJECT  ,
*****************************************************************
*        CHECK FOR THE "MDY=" PARAMETER                         *
*        TO SEE IF THE USER WANTS TO SPECIFY THE DAYS OF THE    *
*        YEAR ON WHICH COMMANDS CAN BE EXECUTED.                *
*****************************************************************
PRMMDY   DS    0H                  PROCESS "MDY=" PARAMETER
         LA    R15,4               "MDY=" MINIMUM PARM LENGTH
         LA    R2,00               INDICATE INCLUDE MODE
         CR    R0,R15              TEST PARM LENGTH
         BL    BYPRMMDY            IF LN NOT CORRECT
         OC    0(4,R1),EBLANKS     FORCE UPPER CASE
         CLC   0(4,R1),=C'MDY='       MDY=?
         BE    PRMMDYSC            PROCESS MDY LIST IF YES
*****************************************************************
*        CHECK FOR THE "MDYX=" PARAMETER                        *
*        TO SEE IF THE USER WANTS TO SPECIFY THE DAYS OF THE    *
*        YEAR ON WHICH COMMANDS CANNOT BE EXECUTED.             *
*****************************************************************
PRMMDYX  DS    0H                  PROCESS "MDYX=" PARAMETER
         LA    R15,5               "MDYX=" MINIMUM PARM LENGTH
         LA    R2,04               INDICATE EXCLUDE MODE
         CR    R0,R15              TEST PARM LENGTH
         BL    BYPRMMDY            IF LN NOT CORRECT
         OC    0(5,R1),EBLANKS     FORCE UPPER CASE
         CLC   0(5,R1),=C'MDYX='      MDYX=?
         BE    PRMMDYSC            PROCESS MDYX LIST IF YES
*
*        THE PARAMETER IS NEITHER "MDY=" NOR "MDYX=".
         B     BYPRMMDY            IF NOT MDY=/MDYX=
*****************************************************************
*        PROCESS THE "MDY=" / "MDYX=" VALUES LIST.              *
*****************************************************************
PRMMDYSC BAS   RLINK,PRMMDYLS      PROCESS MM/DD/YY LIST
*****************************************************************
*        "MDY=" / "MDYX=" PARAMETER PROCESSING IS COMPLETE.     *
*****************************************************************
BYPRMMDY DS    0H
         EJECT  ,
*****************************************************************
*        CHECK FOR THE "SID=" PARAMETER                         *
*        TO SEE IF THE USER WANTS TO SPECIFY THE SMF IDENTIFIERS*
*        OF THE SYSTEMS ON WHICH COMMANDS CAN BE EXECUTED.      *
*****************************************************************
PRMSID   DS    0H                  PROCESS "SID=" PARAMETER
         LA    R15,4               "SID=" MINIMUM PARM LENGTH
         LA    R2,00               INDICATE INCLUDE MODE
         CR    R0,R15              TEST PARM LENGTH
         BL    BYPRMSID            IF LN NOT CORRECT
         OC    0(4,R1),EBLANKS     FORCE UPPER CASE
         CLC   0(4,R1),=C'SID='       SID=?
         BE    PRMSIDSC            PROCESS SID LIST IF YES
*****************************************************************
*        CHECK FOR THE "SIDX=" PARAMETER                        *
*        TO SEE IF THE USER WANTS TO SPECIFY THE SMF IDENTIFIERS*
*        OF THE SYSTEMS ON WHICH COMMANDS CANNOT BE EXECUTED.   *
*****************************************************************
PRMSIDX  DS    0H                  PROCESS "SIDX=" PARAMETER
         LA    R15,5               "SIDX=" MINIMUM PARM LENGTH
         LA    R2,04               INDICATE EXCLUDE MODE
         CR    R0,R15              TEST PARM LENGTH
         BL    BYPRMSID            IF LN NOT CORRECT
         OC    0(5,R1),EBLANKS     FORCE UPPER CASE
         CLC   0(5,R1),=C'SIDX='      SIDX=?
         BE    PRMSIDSC            PROCESS SIDX LIST IF YES
*
*        THE PARAMETER IS NEITHER "SID=" NOR "SIDX=".
         B     BYPRMSID            IF NOT SID=/SIDX=
*****************************************************************
*        PROCESS THE "SID=" / "SIDX=" VALUES LIST.              *
*****************************************************************
PRMSIDSC BAS   RLINK,PRMSIDLS      PROCESS SYSTEM ID LIST
*****************************************************************
*        "SID=" / "SIDX=" PARAMETER PROCESSING IS COMPLETE.     *
*****************************************************************
BYPRMSID DS    0H
         EJECT  ,
*
*        ADVANCE TO THE NEXT CHARACTER AND LOOP
PRMLOOP5 DS    0H
         LTR   R0,R0               TEST REMAINING LENGTH
         BNP   PRMLOOP6            DONE IF AT END OF PARM
         CLI   0(R1),C' '          IS TERMINATOR A BLANK?
         BE    PRMLOOP6            BLANK HERE SIGNALS END
         LA    R15,1               ADVANCE TO NEXT DATA BYTE
         AR    R1,R15              TO NEXT DATA BYTE
         SR    R0,R15              DECREMENT REMAINING LENGTH
         BP    PRMLOOP1            LOOP IF MORE PARM TO ANALYZE
*
*        NOW THAT THE PARM FIELD HAS BEEN COMPLETELY SCANNED,
*        CONVERT ALL OF THE BINARY TIME VALUES TO EBCDIC.
PRMLOOP6 DS    0H
         L     R15,DELAYTME        LOAD BINARY DELAY TIME
         BAS   RLINK,PRMSCETM      CONVERT BINARY TIME TO EBCDIC
         STM   R2,R3,DELAYDEC      SAVE EBCDIC DELAY TIME
         L     R15,TODTME          LOAD BINARY TIME-OF-DAY
         BAS   RLINK,PRMSCETM      CONVERT BINARY TIME TO EBCDIC
         STM   R2,R3,TODDEC        SAVE EBCDIC TIME-OF-DAY
         L     R15,BEFORTME        LOAD BINARY EARLIEST TIME
         BAS   RLINK,PRMSCETM      CONVERT BINARY TIME TO EBCDIC
         STM   R2,R3,BEFORDEC      SAVE EBCDIC EARLIEST TIME
         L     R15,AFTERTME        LOAD BINARY LATEST TIME
         C     R15,BEFORTME        COMPARE TO BEFORE TIME
         BNE   *+L'*+4+4           BRANCH IF NOT THE SAME
         A     R15,ERRTME          MARGIN OF ERROR
         ST    R15,AFTERTME        REVISE AFTER TIME
         BAS   RLINK,PRMSCETM      CONVERT BINARY TIME TO EBCDIC
         STM   R2,R3,AFTERDEC      SAVE EBCDIC LATEST TIME
         SPACE 5
*
*
*        PARM FIELD PROCESSING COMPLETE.
PRMLOOP9 DS    0H
         L     RLINK,PRMSCALK      RELOAD RETURN REGISTER VALUE
         BR    RLINK               RETURN TO CALLER
         EJECT  ,
*****************************************************************
*                                                               *
*        PARM STRING ANALYSIS SUBROUTINE TO PROCESS AN          *
*        ITEM OF THE FORM "KEYWORD=(LIST)" WHERE EACH VALUE     *
*        IN THE LIST IS A NUMERIC VALUE IN THE RANGE 00-31.     *
*        THIS ROUTINE IS USED FOR PROCESSING "ROUTCDE=", AND    *
*        "DESC=".                                               *
*                                                               *
*        REGISTERS ON ENTRY ARE EXPECTED TO BE SET UP           *
*        AS FOLLOWS:                                            *
*           R15   LENGTH OF KEYWORD INCLUDING "=".              *
*           R0    REMAINING PARM STRING LENGTH.                 *
*           R1    -> FIRST CHARACTER OF THE KEYWORD.            *
*           R2    NOT USED ON INPUT.                            *
*                                                               *
*        REGISTERS ON RETURN ARE SET AS FOLLOWS:                *
*           R15   CONTAINS THE FINAL BIT MASK WITH REGISTER     *
*                 BIT 0 CORRESPONDING TO 00, AND BIT 31         *
*                 CORRESPONDING TO 31.                          *
*           R0    REMAINING LENGTH OF THE PARM FIELD.           *
*           R1    ADDRESS OF THE TERMINATING BYTE FOR THE       *
*                 (LIST) PORTION OF THE KEYWORD.                *
*           R2    UNPREDICTABLE.                                *
*           R3    UNPREDICTABLE.                                *
*                                                               *
*****************************************************************
PRMBITLS DS    0H                  PROCESS SYSTEM ID LIST
         ST    RLINK,PRMSCRLK      SAVE RETURN REGISTER VALUE
*
*
*        INITIALIZE WORKING STORAGE AREAS.
PRMBITL0 DS    0H
         XC    PRMBITAS,PRMBITAS   CLEAR BIT STRING ASSEMBLY AREA
*
*
*        GET THE NEXT KEYWORD LIST ENTRY VALUE.
PRMBITL1 DS    0H
         BAS   RLINK,PRMSCVAL      GET THE NEXT NUMERIC VALUE IN R15
         B     PRMBITL3            SKIP PAST NULL VALUE
*
*
*        VALIDATE THE VALUE TO INSURE IT LIES IN THE RANGE 00-31,
*        AND THEN COMBINE ITS BIT VALUE WITH THE BIT STRING.
PRMBITL2 DS    0H
         CL    R15,=F'31'          TEST RETURNED VALUE
         BH    PRMBITL3            BYPASS IT IF LT 0 OR GT 31
         LA    R2,B'10000000'      LOAD BIT MASK
         SLL   R2,24               SHIFT TO TOP BYTE OF REGISTER
         SRL   R2,00(R15)          SHIFT TO CORRESPONDING POSITION
         O     R2,PRMBITAS         COMBINE WITH BIT MASK
         ST    R2,PRMBITAS         STORE UPDATED BIT MASK
*
*
*        TEST FOR THE END OF THE KEYWORD LIST,
*        AND LOOP FOR THE NEXT VALUE IF NOT.
PRMBITL3 DS    0H
         LA    R15,1               SET LENGTH TO SKIP PAST DELIMITER
         LTR   RPAREN,RPAREN       ADDITIONAL LIST ENTRIES TO PROCESS??
         BP    PRMBITL1            LOOP IF YES
*
*
*        LIST PROCESSING IS COMPLETE, RETURN TO THE CALLER.
PRMBITL9 DS    0H
         L     R15,PRMBITAS        LOAD FINAL BIT MASK
         L     RLINK,PRMSCRLK      LOAD RETURN REGISTER VALUE
         BR    RLINK               RETURN TO THE CALLER
         EJECT  ,
*****************************************************************
*                                                               *
*        SUBROUTINE TO PROCESS THE "DOY=" / "DOYX=" LIST        *
*        AND INITIALIZE AND/OR ADD TO THE DAY-OF-YEAR           *
*        LIST IN THE WORK AREA.  REGISTERS ON ENTRY ARE         *
*        EXPECTED TO BE SET UP AS FOLLOWS:                      *
*           R15   LENGTH OF DOY= / DOYX= KEYWORD.               *
*           R0    REMAINING PARM STRING LENGTH.                 *
*           R1    -> DOY=/DOYX= KEYWORD.                        *
*           R2    00 FOR DOY= ; 04 FOR DOYX=.                   *
*                                                               *
*****************************************************************
PRMDOYLS DS    0H                  PROCESS DAY-OF-YEAR LIST
         ST    RLINK,PRMSCOLK      SAVE RETURN REGISTER VALUE
*        DETERMINE THE MINIMUM AND MAXIMUM DATE VALUES
*        TO ENTER IN THE LIST.
         STM   R15,R1,PRMSCARF     SAVE R15-R1 AROUND "TIME" MACRO
         TIME  BIN                 GET CURRENT DATE
         ST    R1,DOYMIND          SAVE TODAY'S DATE
         ST    R1,DOYMAXD          INITIAL MAX DATE
         AP    DOYMAXD,=P'003'     ADD 003 DAYS TO TODAY
         CP    DOYMAXD+02(02),=P'365'  PAST END OF YEAR?
         BNH   *+L'*+6+6               BRANCH IF NOT
         ZAP   DOYMAXD+02(02),=P'003'  DAY 003
         AP    DOYMAXD+00,=P'1000'     OF THE NEXT YEAR
         LM    R15,R1,PRMSCARF     RESTORE R15-R1
*        IF THE MODE CHANGES, START A NEW LIST.
         CLM   R2,B'0001',DOYMODE  SAME MODE??
         BE    PRMDOYL1            ADD TO LIST IF YES
*
*        THE MODE VALUES DIFFER.  STORE THE NEW VALUE,
*        AND START A NEW LIST.
PRMDOYL0 DS    0H
         STC   R2,DOYMODE          SAVE INCLUDE/EXCLUDE MODE INDICATOR
         XC    DOYCOUNT,DOYCOUNT   CLEAR LIST ENTRY COUNT
*
*
*        GET THE NEXT KEYWORD LIST ENTRY VALUE,
*        AND VERIFY THAT IT IS WITHIN ACCEPTABLE BOUNDS.
PRMDOYL1 DS    0H
         BAS   RLINK,PRMSCDOY      EXTRACT DAY-OF-YEAR VALUE
         B     PRMDOYL6            SKIP PAST NULL VALUE
         CP    00(04,R2),=P'0'     VALUE ZERO?
         BNH   PRMDOYL6            DON'T ADD ZERO VALUE TO LIST
         CP    00(04,R2),DOYMIND   COMPARE TO MINIMUM DATE
         BL    PRMDOYL6            IF LOW, DONT ADD TO LIST
         CP    00(04,R2),DOYMAXD   COMPARE TO MAXIMUM DATE
         BH    PRMDOYL6            IF HIGH, DONT ADD TO LIST
*
*
*        PREPARE TO SCAN THE LIST FOR DUPLICATES.
PRMDOYL3 DS    0H
         LA    RLINK,DOYLIST       -> LIST ENTRY # 1
         LA    R15,1                  SET ENTRY COUNT TO 1
*
*
*        SCAN THE LIST FOR DUPLICATES.
PRMDOYL4 DS    0H
         C     R15,DOYCOUNT        LIST COMPLETELY SCANNED?
         BH    PRMDOYL5            ADD TO END IF COMPLETELY SCANNED
         CP    00(L'DOYLIST,RLINK),00(04,R2)  COMPARE TO LIST ENTRY
         BE    PRMDOYL6            SKIP DUPLICATE VALUE
         LA    RLINK,L'DOYLIST(,RLINK)  ADVANCE TO NEXT ENTRY
         A     R15,F1                   BUMP COUNT
         B     PRMDOYL4
*
*
*        THE NEW VALUE IS NOT A DUPLICATE,
*        ADD THE DATE TO THE END OF THE LIST.
PRMDOYL5 DS    0H                  COPY STRING TO DOY SAVE AREA
         CH    R15,=Y(DOYMAX#)     MAXIMUM NUMBER EXCEEDED??
         BH    PRMDOYL6            DON'T ADD IF YES
         ST    R15,DOYCOUNT        STORE UPDATED COUNT
         ZAP   00(L'DOYLIST,RLINK),00(04,R2)  COPY DOY VALUE
*
*
*        TEST FOR THE END OF THE KEYWORD LIST,
*        AND LOOP FOR THE NEXT VALUE IF NOT..
PRMDOYL6 DS    0H
         LA    R15,1               SET LENGTH TO SKIP PAST DELIMITER
         LTR   RPAREN,RPAREN       ADDITIONAL LIST ENTRIES TO PROCESS??
         BP    PRMDOYL1            LOOP IF YES
*
*
*        LIST PROCESSING IS COMPLETE, RETURN TO THE CALLER.
PRMDOYL9 DS    0H
         L     RLINK,PRMSCOLK      LOAD RETURN REGISTER VALUE
         BR    RLINK               RETURN TO THE CALLER
         EJECT  ,
*****************************************************************
*                                                               *
*        SUBROUTINE TO PROCESS THE "MDY=" / "MDYX=" LIST        *
*        AND INITIALIZE AND/OR ADD TO THE DAY-OF-YEAR           *
*        LIST IN THE WORK AREA.  REGISTERS ON ENTRY ARE         *
*        EXPECTED TO BE SET UP AS FOLLOWS:                      *
*           R15   LENGTH OF MDY= / MDYX= KEYWORD.               *
*           R0    REMAINING PARM STRING LENGTH.                 *
*           R1    -> MDY=/MDYX= KEYWORD.                        *
*           R2    00 FOR MDY= ; 04 FOR MDYX=.                   *
*                                                               *
*****************************************************************
PRMMDYLS DS    0H                  PROCESS DAY-OF-YEAR LIST
         ST    RLINK,PRMSCOLK      SAVE RETURN REGISTER VALUE
*        DETERMINE THE MINIMUM AND MAXIMUM DATE VALUES
*        TO ENTER IN THE LIST.
         STM   R15,R1,PRMSCARF     SAVE R15-R1 AROUND "TIME" MACRO
         TIME  BIN                 GET CURRENT DATE
         ST    R1,DOYMIND          SAVE TODAY'S DATE
         ST    R1,DOYMAXD          INITIAL MAX DATE
         AP    DOYMAXD,=P'003'     ADD 003 DAYS TO TODAY
         CP    DOYMAXD+02(02),=P'365'  PAST END OF YEAR?
         BNH   *+L'*+6+6               BRANCH IF NOT
         ZAP   DOYMAXD+02(02),=P'003'  DAY 003
         AP    DOYMAXD+00,=P'1000'     OF THE NEXT YEAR
         LM    R15,R1,PRMSCARF     RESTORE R15-R1
*        IF THE MODE CHANGES, START A NEW LIST.
         CLM   R2,B'0001',DOYMODE  SAME MODE??
         BE    PRMMDYL1            ADD TO LIST IF YES
*
*        THE MODE VALUES DIFFER.  STORE THE NEW VALUE,
*        AND START A NEW LIST.
PRMMDYL0 DS    0H
         STC   R2,DOYMODE          SAVE INCLUDE/EXCLUDE MODE INDICATOR
         XC    DOYCOUNT,DOYCOUNT   CLEAR LIST ENTRY COUNT
*
*
*        GET THE NEXT KEYWORD LIST ENTRY VALUE,
*        AND VERIFY THAT IT IS WITHIN ACCEPTABLE BOUNDS.
PRMMDYL1 DS    0H
         BAS   RLINK,PRMSCMDY      EXTRACT DAY-OF-YEAR VALUE
         B     PRMMDYL6            SKIP PAST NULL VALUE
         CP    00(04,R2),=P'0'     VALUE ZERO?
         BNH   PRMMDYL6            DON'T ADD ZERO VALUE TO LIST
         CP    00(04,R2),DOYMIND   COMPARE TO MINIMUM DATE
         BL    PRMMDYL6            IF LOW, DONT ADD TO LIST
         CP    00(04,R2),DOYMAXD   COMPARE TO MAXIMUM DATE
         BH    PRMMDYL6            IF HIGH, DONT ADD TO LIST
*
*
*        PREPARE TO SCAN THE LIST FOR DUPLICATES.
PRMMDYL3 DS    0H
         LA    RLINK,DOYLIST       -> LIST ENTRY # 1
         LA    R15,1                  SET ENTRY COUNT TO 1
*
*
*        SCAN THE LIST FOR DUPLICATES.
PRMMDYL4 DS    0H
         C     R15,DOYCOUNT        LIST COMPLETELY SCANNED?
         BH    PRMMDYL5            ADD TO END IF COMPLETELY SCANNED
         CP    00(L'DOYLIST,RLINK),00(04,R2)  COMPARE TO LIST ENTRY
         BE    PRMMDYL6            SKIP DUPLICATE VALUE
         LA    RLINK,L'DOYLIST(,RLINK)  ADVANCE TO NEXT ENTRY
         A     R15,F1                   BUMP COUNT
         B     PRMMDYL4
*
*
*        THE NEW VALUE IS NOT A DUPLICATE,
*        ADD THE DATE TO THE END OF THE LIST.
PRMMDYL5 DS    0H                  COPY STRING TO DOY SAVE AREA
         CH    R15,=Y(DOYMAX#)     MAXIMUM NUMBER EXCEEDED??
         BH    PRMMDYL6            DON'T ADD IF YES
         ST    R15,DOYCOUNT        STORE UPDATED COUNT
         ZAP   00(L'DOYLIST,RLINK),00(04,R2)  COPY DOY VALUE
*
*
*        TEST FOR THE END OF THE KEYWORD LIST,
*        AND LOOP FOR THE NEXT VALUE IF NOT..
PRMMDYL6 DS    0H
         LA    R15,1               SET LENGTH TO SKIP PAST DELIMITER
         LTR   RPAREN,RPAREN       ADDITIONAL LIST ENTRIES TO PROCESS??
         BP    PRMMDYL1            LOOP IF YES
*
*
*        LIST PROCESSING IS COMPLETE, RETURN TO THE CALLER.
PRMMDYL9 DS    0H
         L     RLINK,PRMSCOLK      LOAD RETURN REGISTER VALUE
         BR    RLINK               RETURN TO THE CALLER
         EJECT  ,
*****************************************************************
*                                                               *
*        SUBROUTINE TO PROCESS THE "SID=" / "SIDX=" LIST        *
*        AND INITIALIZE AND/OR ADD TO THE SYSTEM IDENTIFIER     *
*        LIST IN THE WORK AREA.  REGISTERS ON ENTRY ARE         *
*        EXPECTED TO BE SET UP AS FOLLOWS:                      *
*           R15   LENGTH OF SID= / SIDX= KEYWORD.               *
*           R0    REMAINING PARM STRING LENGTH.                 *
*           R1    -> SID=/SIDX= KEYWORD.                        *
*           R2    00 FOR SID= ; 04 FOR SIDX=.                   *
*                                                               *
*****************************************************************
PRMSIDLS DS    0H                  PROCESS SYSTEM ID LIST
         ST    RLINK,PRMSCMLK      SAVE RETURN REGISTER VALUE
         CLM   R2,B'0001',SIDMODE  SAME MODE??
         BE    PRMSIDL1            ADD TO LIST IF YES
*
*        THE MODE VALUES DIFFER.  STORE THE NEW VALUE,
*        AND START A NEW LIST.
PRMSIDL0 DS    0H
         STC   R2,SIDMODE          SAVE INCLUDE/EXCLUDE MODE INDICATOR
         XC    SIDCOUNT,SIDCOUNT   CLEAR LIST ENTRY COUNT
*
*
*        GET THE NEXT KEYWORD LIST ENTRY VALUE.
PRMSIDL1 DS    0H
         BAS   RLINK,PRMSCSTR      SCAN STRING
         B     PRMSIDL6            SKIP PAST NULL VALUE
*
*
*        SAVE THE LIST ENTRY VALUE IN THE WORK AREA.
PRMSIDL2 DS    0H
         LA    RLINK,PRMSIDVL      -> VALUE WORK AREA
         LA    R15,L'PRMSIDVL      LIST ENTRY LENGTH
         ICM   R3,B'1000',EBLANKS  BLANK PADDING CHARACTER
         MVCL  RLINK,R2            COPY ELEMENT TO WORK AREA
*
*
*        PREPARE TO SCAN THE LIST FOR DUPLICATES.
PRMSIDL3 DS    0H
         LA    RLINK,SIDLIST            -> LIST ENTRY # 1
         LA    R15,1                       SET ENTRY COUNT TO 1
*
*
*        SCAN THE LIST FOR DUPLICATES.
PRMSIDL4 DS    0H
         C     R15,SIDCOUNT        LIST COMPLETELY SCANNED?
         BH    PRMSIDL5            ADD TO END IF COMPLETELY SCANNED
         CLC   PRMSIDVL,00(RLINK)  COMPARE TO LIST ENTRY
         BE    PRMSIDL6            SKIP DUPLICATE VALUE
         LA    RLINK,L'SIDLIST(,RLINK)  ADVANCE TO NEXT ENTRY
         A     R15,F1                   BUMP COUNT
         B     PRMSIDL4
*
*
*        THE NEW VALUE IS NOT A DUPLICATE,
*        ADD IT TO THE END OF THE LIST.
PRMSIDL5 DS    0H                  COPY STRING TO SID SAVE AREA
         CH    R15,=Y(SIDMAX#)     MAXIMUM NUMBER EXCEEDED??
         BH    PRMSIDL6            DON'T ADD IF YES
         ST    R15,SIDCOUNT        STORE UPDATED COUNT
         MVC   00(L'SIDLIST,RLINK),PRMSIDVL      COPY STRING TO LIST
*
*
*        TEST FOR THE END OF THE KEYWORD LIST,
*        AND LOOP FOR THE NEXT VALUE IF NOT.
PRMSIDL6 DS    0H
         LA    R15,1               SET LENGTH TO SKIP PAST DELIMITER
         LTR   RPAREN,RPAREN       ADDITIONAL LIST ENTRIES TO PROCESS??
         BP    PRMSIDL1            LOOP IF YES
*
*
*        LIST PROCESSING IS COMPLETE, RETURN TO THE CALLER.
PRMSIDL9 DS    0H
         L     RLINK,PRMSCMLK      LOAD RETURN REGISTER VALUE
         BR    RLINK               RETURN TO THE CALLER
         EJECT  ,
*****************************************************************
*        SUBROUTINE TO PICK UP TIME VALUE                       *
*        FROM THE PARM FIELD, CONVERT IT TO BINARY 1/100 SEC,   *
*        AND RETURN ITS VALUE TO THE CALLER IN R15.             *
*        THIS SUBROUTINE EXPECTS REGISTERS AS FOLLOWS....       *
*             R15   LENGTH OF KEYWORD PARAMETER & "="           *
*             R0    REMAINING LENGTH OF PARM FIELD              *
*             R1    ADDRESS OF FIRST BYTE OF KEYWORD            *
*        THIS SUBROUTINE MAKES TWO RETURNS.....                 *
*             0(RLINK)   THE PARAMETER VALUE SUPPLIED IS NULL   *
*             4(RLINK)   THE PARAMETER VALUE IS IN 1/100 SEC    *
*                        IN R15.                                *
*        REGISTERS ON RETURN ARE SET AS FOLLOWS.....            *
*             R15   TIME IN BINARY 1/100 SECONDS                *
*             R0    REMAINING LENGTH OF PARM FIELD              *
*             R1    ADDRESS OF TERMINATING BYTE (COMMA OR BLANK)*
*                   FOR THE VALUE PART OF THE KEYWORD           *
*        A TIME-RELATED KEYWORD PROCESSED BY THIS SUBROUTINE    *
*        CAN HAVE THE FOLLOWING FORMATS.....                    *
*            KEYWORD=VALUE1                                     *
*            KEYWORD=(VALUE1)                                   *
*            KEYWORD=(VALUE2,VALUE3)                            *
*            KEYWORD=(,VALUE3)                                  *
*        WHERE "VALUE1" CAN BE OF THE FORMS....                 *
*            MM         FOR MINUTES                             *
*            HH.MM      FOR HOURS AND MINUTES                   *
*            HH:MM      FOR HOURS AND MINUTES                   *
*            HH.MM.SS   FOR HOURS, MINUTES, AND SECONDS         *
*            HH:MM:SS   FOR HOURS, MINUTES, AND SECONDS         *
*            HH.MM.SS.TH    HOURS, MINUTES,SECONDS,TENTHS,HUND  *
*            HH:MM:SS.TH    HOURS, MINUTES,SECONDS,TENTHS,HUND  *
*        AND "VALUE2" CAN BE OF THE FORMS....                   *
*            MM         FOR MINUTES                             *
*            HH.MM      FOR HOURS AND MINUTES                   *
*            HH:MM      FOR HOURS AND MINUTES                   *
*        AND "VALUE3" CAN BE OF THE FORMS....                   *
*            SS         FOR SECONDS                             *
*            SS.TH      FOR SECONDS AND TENTHSHUNDREDTHS        *
*****************************************************************
*
*        PROCESS THE TIME-RELATED KEYWORD
PRMSCBTM DS    0H
         ST    RLINK,PRMSCBLK      SAVE LINK REGISTER VALUE FOR RETURN
         XC    PRMTODAS,PRMTODAS   CLEAR TOD ACCUMULATION AREA
         AR    R1,R15              TO BYTE AFTER "="
         SR    R0,R15              DECREMENT REMAINING LENGTH
         BNP   0(RLINK)            NULL VALUE IF END
         CLI   0(R1),C' '          IS TERMINATOR A BLANK?
         BE    0(RLINK)            NULL VALUE IF YES
         CLI   0(R1),C','          IS TERMINATOR A COMMA?
         BE    0(RLINK)            NULL VALUE IF YES
         SR    RPAREN,RPAREN       ASSUME NOT ENCLOSED IN PARENS
*
*        THE TIME VALUE IS NON-NULL.
*
PRMSCBPR DS    0H                  PROCESS THE TIME PARAMETER VALUE
         CLI   0(R1),C'('          IS VALUE ENCLOSED IN PARENTHESES?
         BNE   PRMSCBP1            BEGIN PROCESSING DIRECTLY IF YES
*
*        THE TIME VALUE IS ENCLOSED IN PARENTHESES,
*        SKIP PAST THE ENCLOSING LEFT PARENTHESIS.
PRMSCBP0 DS    0H
         LA    RPAREN,4            INDICATE ENCLOSING PARENTHESES
         LA    R15,1               ADVANCE PAST LEFT PARENTHESIS
         AR    R1,R15              TO BYTE AFTER "("
         SR    R0,R15              DECREMENT REMAINING LENGTH
         BNP   0(RLINK)            VALUE NULL IF END OF PARM
         CLI   0(R1),C')'          IMMEDIATE ENDING PAREN????
         BNE   PRMSCBP1            VALUE SUPPLIED IF NOT
         AR    R1,R15              TO BYTE AFTER ")"
         SR    R0,R15              DECREMENT REMAINING LENGTH
         B     0(RLINK)            VALUE NULL
*
*        BEGIN PROCESSING ASSUMING WE ARE AT THE MINUTES VALUE
PRMSCBP1 DS    0H
         BAS   RLINK,PRMSCNUM      EXTRACT FIRST NUMERIC VALUE
         A     R15,PRMTODAS        ADD TO ACCUMULATED RESULT
         ST    R15,PRMTODAS        UPDATE ACCUMULATED RESULT
         LTR   R0,R0               TEST REMAINING LENGTH
         BNP   PRMSCBP3            IF TERMINATOR WAS END OF FIELD
         CLI   0(R1),C':'          IS TERMINATOR A COLON??
         BE    PRMSCBP2            IF YES, FIRST VALUE IS HOURS
         CLI   0(R1),C'.'          IS TERMINATOR A PERIOD?
         BNE   PRMSCBP3            IF NOT, GO CONVERT MINS TO SECS
*
*        IF SEPARATOR IS "." OR ":", FIRST VALUE IS HOURS
PRMSCBP2 DS    0H
         L     R15,PRMTODAS        LOAD   ACCUMULATED RESULT
         MH    R15,=Y(60)          CONVERT HOURS TO MINUTES
         ST    R15,PRMTODAS        UPDATE ACCUMULATED RESULT
         LA    R15,1               ADVANCE 1 CHARACTER
         AR    R1,R15              TO BYTE AFTER "."
         SR    R0,R15              DECREMENT REMAINING LENGTH
         BNP   PRMSCBP3            IF NO MINUTES VALUE
         BAS   RLINK,PRMSCNUM      EXTRACT NEXT NUMERIC VALUE(MINS)
         A     R15,PRMTODAS        ADD TO ACCUMULATED RESULT
         ST    R15,PRMTODAS        UPDATE ACCUMULATED RESULT
*
*        CONVERT MINUTES TO SECONDS.
PRMSCBP3 DS    0H
         L     R15,PRMTODAS        LOAD   ACCUMULATED RESULT
         MH    R15,=Y(60)          CONVERT MINUTES TO SECONDS
         ST    R15,PRMTODAS        UPDATE ACCUMULATED RESULT
*
*        WE ARE NOW AT THE SEPARATOR BETWEEN MINS & SECS
PRMSCBP4 DS    0H
         LTR   R0,R0               TEST REMAINING LENGTH
         BNP   PRMSCBP6            IF NO SECONDS VALUE
         CLI   0(R1),C':'          IS TERMINATOR A COLON??
         BE    PRMSCBP5            SECONDS IS PRESENT IF YES
         CLI   0(R1),C'.'          IS TERMINATOR A PERIOD?
         BE    PRMSCBP5            SECONDS IS PRESENT IF YES
         LTR   RPAREN,RPAREN       ENCLOSED IN PARENS????
         BZ    PRMSCBP6            IF NO, WE ARE AT END
         CLI   0(R1),C','          IS TERMINATOR A COMMA?
         BE    PRMSCBP5            SECONDS IS PRESENT IF YES
         B     PRMSCBP6            GO CONVERT SECONDS TO 1/100 SEC
*        MINUTES VALUE IS FOLLOWED BY SECONDS
PRMSCBP5 DS    0H
         LA    R15,1               ADVANCE PAST DELIMITER
         AR    R1,R15              TO NEXT CHARACTER
         SR    R0,R15              DECREMENT REMAINING LENGTH
         BNP   PRMSCBP6            IF END OF PARM FIELD
         BAS   RLINK,PRMSCNUM      EXTRACT SECONDS VALUE
         A     R15,PRMTODAS        ADD TO ACCUMULATED RESULT
         ST    R15,PRMTODAS        UPDATE ACCUMULATED RESULT
*
*        CONVERT SECONDS TO 1/100 SECONDS.
PRMSCBP6 DS    0H
         L     R15,PRMTODAS        LOAD   ACCUMULATED RESULT
         MH    R15,=Y(100)         CONVERT SECONDS TO 1/100 SECONDS
         ST    R15,PRMTODAS        UPDATE ACCUMULATED RESULT
PRMSCBP7 DS    0H
         LTR   R0,R0               TEST REMAINING LENGTH
         BNP   PRMSCBP9            IF NO TENTHS/HUNDREDTHS VALUE
         CLI   0(R1),C'.'          IS TERMINATOR A PERIOD?
         BNE   PRMSCBP9            NO TENTHS/HUNDREDTHS VALUE PRESENT
*
*        EXTRACT TENTHS,HUNDREDTHS VALUE,
*        AND ADD EXTRACTED VALUE INTO RESULT.
PRMSCBP8 DS    0H
         LA    R15,1               ADVANCE PAST DELIMITER
         AR    R1,R15              TO NEXT CHARACTER
         SR    R0,R15              DECREMENT REMAINING LENGTH
         BNP   PRMSCBP9            IF END OF PARM FIELD
         BAS   RLINK,PRMSCNUM      EXTRACT TENTHS/HUNDREDTHS VALUE
         A     R15,PRMTODAS        ADD TO ACCUMULATED RESULT
         ST    R15,PRMTODAS        UPDATE ACCUMULATED RESULT
*
*        IF THE VALUE WAS ENCLOSED IN PARENTHESES,
*        SKIP PAST THE ENDING RIGHT PARENTHESIS.
PRMSCBP9 DS    0H
         LTR   R0,R0               TEST REMAINING LENGTH
         BNP   PRMSCBPA            IF TERMINATOR WAS END OF FIELD
         LTR   RPAREN,RPAREN       ENCLOSED IN PARENS????
         BZ    PRMSCBPA            IF NO, WE ARE AT END
         CLI   0(R1),C')'          DID WE END AT A RT PARENTHESIS?
         BNE   PRMSCBPA            DONT BYPASS IT IF NOT
         LA    R15,1               ADVANCE PAST RT PARENTHESIS
         AR    R1,R15              TO BYTE AFTER ")"
         SR    R0,R15              DECREMENT REMAINING LENGTH
*
*        WE ARE NOW AT THE TERMINATOR OR THE END OF THE PARM FIELD
PRMSCBPA DS    0H
         L     R15,PRMTODAS        LOAD FINAL RESULT
         CL    R15,MAXTME          COMPARE TO LARGEST VALUE
         BNH   *+L'*+4             BRANCH IF WITHIN BOUNDS
         L     R15,MAXTME          REPLACE WITH LARGEST VALUE
         L     RLINK,PRMSCBLK      RELOAD LINK REGISTER VALUE
         B     4(RLINK)            RETURN TO CALLER AT OFFSET 04
         EJECT  ,
*****************************************************************
*        SUBROUTINE TO PICK UP A DAY-OF-YEAR VALUE              *
*        FROM THE PARM FIELD, AND RETURN ITS PACKED DECIMAL     *
*        VALUE TO THE CALLER.                                   *
*        THIS SUBROUTINE EXPECTS REGISTERS AS FOLLOWS....       *
*             R15   LENGTH OF KEYWORD PARAMETER & "="           *
*             R0    REMAINING LENGTH OF PARM FIELD              *
*             R1    ADDRESS OF FIRST BYTE OF KEYWORD            *
*        THIS SUBROUTINE MAKES TWO RETURNS.....                 *
*             0(RLINK)   THE PARAMETER VALUE SUPPLIED IS NULL   *
*             4(RLINK)   THE PARAMETER VALUE IS IN PACKED       *
*                        DECIMAL IN R15.                        *
*        REGISTERS ON RETURN ARE SET AS FOLLOWS.....            *
*             R15   DAY-OF-YEAR VALUE IN PACKED DECIMAL.        *
*             R0    REMAINING LENGTH OF PARM FIELD              *
*             R1    ADDRESS OF TERMINATING BYTE (COMMA OR BLANK)*
*                   FOR THE VALUE PART OF THE KEYWORD           *
*             R2    ADDRESS OF A FOUR-BYTE FIELD CONTAINING     *
*                   THE DAY-OF-YEAR IN PACKED DECIMAL           *
*                   IN THE FORM "00YYDDDC".                     *
*             R3    LENGTH OF RESULT (04).                      *
*             RPAREN  00 IF THIS IS THE ONLY OR LAST VALUE      *
*                        FOR THE CURRENT KEYWORD.               *
*                     04 IF THIS IS NOT THE LAST VALUE          *
*                        FOR THE CURRENT KEYWORD.               *
*        A DAY-OF-YEAR KEYWORD PROCESSED BY THIS SUBROUTINE     *
*        CAN HAVE THE FOLLOWING FORMATS.....                    *
*            KEYWORD=VALUE1                                     *
*            KEYWORD=(VALUE1)                                   *
*            KEYWORD=(VALUE1,VALUE2,...)                        *
*****************************************************************
*
*
*        PROCESS THE DAY-OF-YEAR-VALUED KEYWORD.
PRMSCDOY DS    0H
         ST    RLINK,PRMSCYLK      SAVE LINK REGISTER VALUE FOR RETURN
         XC    PRMDOYAS,PRMDOYAS   CLEAR BINARY RESULT VALUE
         ZAP   PRMDOYPD,=P'0'      CLEAR RESULT FIELD
         SR    R2,R2               CLEAR
         LR    R3,R2               STRING POINTER REGISTERS
         CH    R15,=Y(01)          KEYWORD LENGTH PRESENT?
         BNH   *+L'*+2             BRANCH IF NOT
         SR    RPAREN,RPAREN       INIT PAREN INDICATOR IF 1ST CALL
*
*        ADVANCE PAST THE KEYWORD OR THE PRECEEDING DELIMITER,
*        AND TEST FOR THE END OF THE PARM STRING.
PRMSCY00 DS    0H
         AR    R1,R15              TO BYTE AFTER "="
         SR    R0,R15              DECREMENT REMAINING LENGTH
         BNP   PRMSCY08            DROP PAREN INDICATOR IF AT END
         CLI   0(R1),C' '          IS TERMINATOR A BLANK?
         BE    PRMSCY08            DROP PAREN INDICATOR IF A BLANK
         LA    R15,1               RESET CHARACTER COUNT TO 1
*
*        IF THE ENCLOSING PARENTHESES INDICATOR IS SET,
*        PROCEED IMMEDIATELY TO EXTRACT THE NEXT VALUE.
PRMSCY01 DS    0H
         LTR   RPAREN,RPAREN       PARENTHESES INDICATOR SET??
         BP    PRMSCY05            PROCESS NEXT VALUE IF YES
*
*        THE PARENTHESES INDICATOR IS NOT SET,
*        CHECK FOR ENCLOSING PARENTHESES.
PRMSCY02 DS    0H                  PROCESS THE PARAMETER VALUE
         CLI   0(R1),C'('          IS VALUE ENCLOSED IN PARENTHESES?
         BNE   PRMSCY05            BEGIN PROCESSING DIRECTLY IF NOT
*
*        THE VALUE IS ENCLOSED IN PARENTHESES.
*        TURN THE PARENTHESES INDICATOR ON,
*        AND SKIP PAST THE ENCLOSING LEFT PARENTHESIS.
PRMSCY03 DS    0H
         LA    RPAREN,4            INDICATE ENCLOSING PARENTHESES
         AR    R1,R15              TO BYTE AFTER "("
         SR    R0,R15              DECREMENT REMAINING LENGTH
         BNP   PRMSCY08            DROP PAREN INDIC IF END
*
*        ASSEMBLE THE DAY-OF-YEAR VALUE,
*        AND DETERMINE ITS BINARY VALUE.
*        ON RETURN, REGISTER R1 POINTS TO THE CHARACTER FOLLOWING
*        THE STRING ITEM IN THE PARM FIELD.
PRMSCY05 DS    0H
         BAS   RLINK,PRMSCNUM      EXTRACT NEXT NUMERIC STRING
         LTR   R0,R0               END OF PARM FIELD??
         BNP   PRMSCY06            BRANCH IF YES
         CLI   00(R1),C'.'         "." BETWEEN YY AND DDD?
         BNE   PRMSCY06            HAVE FULL YYDDD IF NOT
         CH    R15,=Y(9999)        YEAR LT 9999 ??
         BL    *+L'*+4             BRANCH IF YES
         LH    R15,=Y(9999)        LIMIT YEAR TO 9999
         MH    R15,=Y(1000)        YEAR *1000
         ST    R15,PRMDOYAS        SAVE IN WORK AREA
         LA    R15,1               LOAD COUNT OF 1
         AR    R1,R15              ADVANCE PAST "."
         SR    R0,R15              DECREMENT REMAINING LENGTH
         BAS   RLINK,PRMSCNUM      GET DDD
         A     R15,PRMDOYAS        PACK DDD WITH YYYY
*
*
*        THE FINAL YYY.DDD BINARY VALUE IS IN R15.
*        SAVE IT, AND ADVANCE TO THE END OF THE ITEM.
PRMSCY06 DS    0H
         ST    R15,PRMDOYAS        SAVE IN WORK AREA
         CVD   R15,PRMDOYPD        GET YYYY.DDD IN PACKED DECIMAL
         BAS   RLINK,PRMSCITM      ADVANCE TO END OF ITEM
         LA    R3,04               SIGNAL NON-NULL RESULT
*
*        IF THE VALUE BEGAN WITH A LEFT PARENTHESIS,
*        IT SHOULD END WITH A RIGHT PARENTHESIS.
PRMSCY07 DS    0H
         LTR   R0,R0               TEST REMAINING LENGTH
         BNP   PRMSCY08            IF TERMINATOR WAS END OF FIELD
         CLI   0(R1),C')'          DID WE END AT A RT PARENTHESIS?
         BNE   PRMSCY09            DONT BYPASS IT IF NOT
         LA    R15,1               ADVANCE PAST RT PARENTHESIS
         AR    R1,R15              TO BYTE AFTER ")"
         SR    R0,R15              DECREMENT REMAINING LENGTH
*
*        CLEAR THE ENCLOSING PARENTHESES INDICATOR.
PRMSCY08 DS    0H
         SR    RPAREN,RPAREN       CLEAR PARENTHESES INDICATOR
*
*        RETURN THE STRING ADDRESS AND LENGTH TO THE CALLER.
PRMSCY09 DS    0H
         L     RLINK,PRMSCYLK      RELOAD LINK REGISTER VALUE
         L     R15,PRMDOYPD+04     LOAD PACKED DECIMAL VALUE
         LTR   R3,R3               TEST STRING LENGTH
         BNP   0(RLINK)            RETURN AT OFFSET 00 IF NULL
         LA    R2,PRMDOYPD+04      -> PACKED DECIMAL DAY-OF-YEAR
         LA    R3,04                  LENGTH OF RESULT
         B     4(RLINK)            RETURN AT OFFSET 04 (NON-NULL)
         EJECT  ,
*****************************************************************
*        SUBROUTINE TO PICK UP AN MM/DD/YY DATE VALUE           *
*        FROM THE PARM FIELD, AND RETURN ITS PACKED DECIMAL     *
*        YYDDD EQUIVALENT DATE VALUE TO THE CALLER.             *
*        THIS SUBROUTINE EXPECTS REGISTERS AS FOLLOWS....       *
*             R15   LENGTH OF KEYWORD PARAMETER & "="           *
*             R0    REMAINING LENGTH OF PARM FIELD              *
*             R1    ADDRESS OF FIRST BYTE OF KEYWORD            *
*        THIS SUBROUTINE MAKES TWO RETURNS.....                 *
*             0(RLINK)   THE PARAMETER VALUE SUPPLIED IS NULL   *
*             4(RLINK)   THE PARAMETER VALUE IS IN PACKED       *
*                        DECIMAL IN R15.                        *
*        REGISTERS ON RETURN ARE SET AS FOLLOWS.....            *
*             R15   DAY-OF-YEAR VALUE IN PACKED DECIMAL.        *
*             R0    REMAINING LENGTH OF PARM FIELD              *
*             R1    ADDRESS OF TERMINATING BYTE (COMMA OR BLANK)*
*                   FOR THE VALUE PART OF THE KEYWORD           *
*             R2    ADDRESS OF A FOUR-BYTE FIELD CONTAINING     *
*                   THE DAY-OF-YEAR IN PACKED DECIMAL           *
*                   IN THE FORM "00YYDDDC".                     *
*             R3    LENGTH OF RESULT (04).                      *
*             RPAREN  00 IF THIS IS THE ONLY OR LAST VALUE      *
*                        FOR THE CURRENT KEYWORD.               *
*                     04 IF THIS IS NOT THE LAST VALUE          *
*                        FOR THE CURRENT KEYWORD.               *
*        A DAY-OF-YEAR KEYWORD PROCESSED BY THIS SUBROUTINE     *
*        CAN HAVE THE FOLLOWING FORMATS.....                    *
*            KEYWORD=VALUE1                                     *
*            KEYWORD=(VALUE1)                                   *
*            KEYWORD=(VALUE1,VALUE2,...)                        *
*****************************************************************
*
*
*        PROCESS THE MM/DD/YY VALUED KEYWORD.
PRMSCMDY DS    0H
         ST    RLINK,PRMSCYLK      SAVE LINK REGISTER VALUE FOR RETURN
         XC    PRMDOYAS,PRMDOYAS   CLEAR BINARY RESULT VALUE
         ZAP   PRMDOYPD,=P'0'      CLEAR RESULT FIELD
         SR    R2,R2               CLEAR
         LR    R3,R2               STRING POINTER REGISTERS
         CH    R15,=Y(01)          KEYWORD LENGTH PRESENT?
         BNH   *+L'*+2             BRANCH IF NOT
         SR    RPAREN,RPAREN       INIT PAREN INDICATOR IF 1ST CALL
*
*        ADVANCE PAST THE KEYWORD OR THE PRECEEDING DELIMITER,
*        AND TEST FOR THE END OF THE PARM STRING.
PRMSCX00 DS    0H
         AR    R1,R15              TO BYTE AFTER "="
         SR    R0,R15              DECREMENT REMAINING LENGTH
         BNP   PRMSCX08            DROP PAREN INDICATOR IF AT END
         CLI   0(R1),C' '          IS TERMINATOR A BLANK?
         BE    PRMSCX08            DROP PAREN INDICATOR IF A BLANK
         LA    R15,1               RESET CHARACTER COUNT TO 1
*
*        IF THE ENCLOSING PARENTHESES INDICATOR IS SET,
*        PROCEED IMMEDIATELY TO EXTRACT THE NEXT VALUE.
PRMSCX01 DS    0H
         LTR   RPAREN,RPAREN       PARENTHESES INDICATOR SET??
         BP    PRMSCX04            PROCESS NEXT VALUE IF YES
*
*        THE PARENTHESES INDICATOR IS NOT SET,
*        CHECK FOR ENCLOSING PARENTHESES.
PRMSCX02 DS    0H                  PROCESS THE PARAMETER VALUE
         CLI   0(R1),C'('          IS VALUE ENCLOSED IN PARENTHESES?
         BNE   PRMSCX04            BEGIN PROCESSING DIRECTLY IF NOT
*
*        THE VALUE IS ENCLOSED IN PARENTHESES.
*        TURN THE PARENTHESES INDICATOR ON,
*        AND SKIP PAST THE ENCLOSING LEFT PARENTHESIS.
PRMSCX03 DS    0H
         LA    RPAREN,4            INDICATE ENCLOSING PARENTHESES
         AR    R1,R15              TO BYTE AFTER "("
         SR    R0,R15              DECREMENT REMAINING LENGTH
         BNP   PRMSCX08            DROP PAREN INDIC IF END
*
*        ASSEMBLE THE DAY-OF-YEAR VALUE,
*        AND DETERMINE ITS BINARY VALUE.
*        ON RETURN, REGISTER R1 POINTS TO THE CHARACTER FOLLOWING
*        THE STRING ITEM IN THE PARM FIELD.
PRMSCX04 DS    0H
         BAS   RLINK,PRMSCNUM      EXTRACT NEXT NUMERIC STRING
         LTR   R0,R0               END OF PARM FIELD??
         BNP   PRMSCX05            BRANCH IF YES
         CLI   00(R1),C'/'         "/" BETWEEN MM AND DD/YY?
         BNE   PRMSCX05            HAVE FULL MMDDYY IF NOT
         CH    R15,=Y(99)          MM GT 99 ?? (MMDD)
         BH    *+L'*+4             BRANCH IF YES
         MH    R15,=Y(100)         MM*100
         MH    R15,=Y(100)         MM*100
         ST    R15,PRMDOYAS        SAVE 10000*MM OR 100*MMDD           X
                                        IN WORK AREA
         LA    R15,1               LOAD COUNT OF 1
         AR    R1,R15              ADVANCE PAST "/"
         SR    R0,R15              DECREMENT REMAINING LENGTH
         BAS   RLINK,PRMSCNUM      EXTRACT NEXT NUMERIC STRING
         LTR   R0,R0               END OF PARM FIELD??
         BNP   PRMSCX05            BRANCH IF YES
         CLI   00(R1),C'/'         "/" BETWEEN DD AND YY?
         BNE   PRMSCX05            HAVE FULL MMDDYY IF NOT
         CH    R15,=Y(99)          DD GT 99 ?? (DDYY)
         BH    *+L'*+4             BRANCH IF YES
         MH    R15,=Y(100)         DD*100
         A     R15,PRMDOYAS        COMBINE WITH PREVIOUS RESULT
         ST    R15,PRMDOYAS        SAVE 10000*MM + 100*DD              X
                                        IN WORK AREA
         LA    R15,1               LOAD COUNT OF 1
         AR    R1,R15              ADVANCE PAST "/"
         SR    R0,R15              DECREMENT REMAINING LENGTH
         BAS   RLINK,PRMSCNUM      GET YY
*
*
*        COMBINE THE INTERMEDIATE RESULTS WITH THE LAST
*        NUMERIC VALUE SCANNED.
PRMSCX05 DS    0H
         A     R15,PRMDOYAS        COMBINE WITH FINAL RESULT
*
*
*        THE MMDDYY BINARY VALUE IS IN R15.
*        CONVERT IT TO DECIMAL, THEN TO ITS YYDDD EQUIVALENT,
*        SAVE IT, AND ADVANCE TO THE END OF THE ITEM.
PRMSCX06 DS    0H
         ST    R15,PRMDOYAS        SAVE IN WORK AREA
         CVD   R15,PRMDOYPD        GET 0MMDDYYC IN PACKED DECIMAL
         L     R15,PRMDOYPD+4      LOAD 0MMDDYYC
         BAS   RLINK,MDYDATE       GET 00YYDDDC IN RENTRY/R15
         ST    R15,PRMDOYPD+4      STORE PACKED DECIMAL 00YYDDDC
         BAS   RLINK,PRMSCITM      ADVANCE TO END OF ITEM
         LA    R3,04               SIGNAL NON-NULL RESULT
*
*        IF THE VALUE BEGAN WITH A LEFT PARENTHESIS,
*        IT SHOULD END WITH A RIGHT PARENTHESIS.
PRMSCX07 DS    0H
         LTR   R0,R0               TEST REMAINING LENGTH
         BNP   PRMSCX08            IF TERMINATOR WAS END OF FIELD
         CLI   0(R1),C')'          DID WE END AT A RT PARENTHESIS?
         BNE   PRMSCX09            DONT BYPASS IT IF NOT
         LA    R15,1               ADVANCE PAST RT PARENTHESIS
         AR    R1,R15              TO BYTE AFTER ")"
         SR    R0,R15              DECREMENT REMAINING LENGTH
*
*        CLEAR THE ENCLOSING PARENTHESES INDICATOR.
PRMSCX08 DS    0H
         SR    RPAREN,RPAREN       CLEAR PARENTHESES INDICATOR
*
*        RETURN THE STRING ADDRESS AND LENGTH TO THE CALLER.
PRMSCX09 DS    0H
         L     RLINK,PRMSCYLK      RELOAD LINK REGISTER VALUE
         L     R15,PRMDOYPD+04     LOAD PACKED DECIMAL VALUE
         LTR   R3,R3               TEST STRING LENGTH
         BNP   0(RLINK)            RETURN AT OFFSET 00 IF NULL
         LA    R2,PRMDOYPD+04      -> PACKED DECIMAL DAY-OF-YEAR
         LA    R3,04                  LENGTH OF RESULT
         B     4(RLINK)            RETURN AT OFFSET 04 (NON-NULL)
         EJECT  ,
*****************************************************************
*        SUBROUTINE TO PICK UP A CHARACTER STRING VALUE         *
*        FROM THE PARM FIELD, AND RETURN ITS ADDRESS            *
*        TO THE CALLER IN REGISTERS R2 AND R3.                  *
*        THIS SUBROUTINE EXPECTS REGISTERS AS FOLLOWS....       *
*             R15   LENGTH OF KEYWORD PARAMETER & "="           *
*             R0    REMAINING LENGTH OF PARM FIELD              *
*             R1    ADDRESS OF FIRST BYTE OF KEYWORD            *
*        THIS SUBROUTINE MAKES TWO RETURNS.....                 *
*             0(RLINK)   THE PARAMETER VALUE SUPPLIED IS NULL   *
*             4(RLINK)   THE PARAMETER VALUE IS IN BINARY       *
*                        IN R15.                                *
*        REGISTERS ON RETURN ARE SET AS FOLLOWS.....            *
*             R15   1                                           *
*             R0    REMAINING LENGTH OF PARM FIELD              *
*             R1    ADDRESS OF TERMINATING BYTE (COMMA OR BLANK)*
*                   FOR THE VALUE PART OF THE KEYWORD           *
*             R2    ADDRESS OF THE FIRST BYTE OF THE STRING     *
*                   EXTRACTED FROM THE PARM FIELD.              *
*             R3    LENGTH OF THE STRING EXTRACTED FROM THE     *
*                   PARM FIELD.                                 *
*             RPAREN  00 IF THIS IS THE ONLY OR LAST VALUE      *
*                        FOR THE CURRENT KEYWORD.               *
*                     04 IF THIS IS NOT THE LAST VALUE          *
*                        FOR THE CURRENT KEYWORD.               *
*        A STRING-VALUED KEYWORD PROCESSED BY THIS SUBROUTINE   *
*        CAN HAVE THE FOLLOWING FORMATS.....                    *
*            KEYWORD=VALUE1                                     *
*            KEYWORD=(VALUE1)                                   *
*            KEYWORD=(VALUE1,VALUE2,...)                        *
*****************************************************************
*
*
*        PROCESS THE STRING-VALUED KEYWORD.
PRMSCSTR DS    0H
         ST    RLINK,PRMSCSLK      SAVE LINK REGISTER VALUE FOR RETURN
         SR    R2,R2               CLEAR
         LR    R3,R2               STRING POINTER REGISTERS
         CH    R15,=Y(01)          KEYWORD LENGTH PRESENT?
         BNH   *+L'*+2             BRANCH IF NOT
         SR    RPAREN,RPAREN       INIT PAREN INDICATOR IF 1ST CALL
*
*        ADVANCE PAST THE KEYWORD OR THE PRECEEDING DELIMITER,
*        AND TEST FOR THE END OF THE PARM STRING.
PRMSCS00 DS    0H
         AR    R1,R15              TO BYTE AFTER "="
         SR    R0,R15              DECREMENT REMAINING LENGTH
         BNP   PRMSCS08            DROP PAREN INDICATOR IF AT END
         CLI   0(R1),C' '          IS TERMINATOR A BLANK?
         BE    PRMSCS08            DROP PAREN INDICATOR IF A BLANK
         LA    R15,1               RESET CHARACTER COUNT TO 1
*
*        IF THE ENCLOSING PARENTHESES INDICATOR IS SET,
*        PROCEED IMMEDIATELY TO EXTRACT THE NEXT VALUE.
PRMSCS01 DS    0H
         LTR   RPAREN,RPAREN       PARENTHESES INDICATOR SET??
         BP    PRMSCS05            PROCESS NEXT VALUE IF YES
*
*        THE PARENTHESES INDICATOR IS NOT SET,
*        CHECK FOR ENCLOSING PARENTHESES.
PRMSCS02 DS    0H                  PROCESS THE PARAMETER VALUE
         CLI   0(R1),C'('          IS VALUE ENCLOSED IN PARENTHESES?
         BNE   PRMSCS05            BEGIN PROCESSING DIRECTLY IF NOT
*
*        THE VALUE IS ENCLOSED IN PARENTHESES.
*        TURN THE PARENTHESES INDICATOR ON,
*        AND SKIP PAST THE ENCLOSING LEFT PARENTHESIS.
PRMSCS03 DS    0H
         LA    RPAREN,4            INDICATE ENCLOSING PARENTHESES
         AR    R1,R15              TO BYTE AFTER "("
         SR    R0,R15              DECREMENT REMAINING LENGTH
         BNP   PRMSCS08            DROP PAREN INDIC IF END
*
*        RETRIEVE THE STRING VALUE AND GET ITS ADDRESS AND LENGTH.
*        ON RETURN, REGISTER R1 POINTS TO THE CHARACTER FOLLOWING
*        THE STRING ITEM IN THE PARM FIELD.
PRMSCS05 DS    0H
         BAS   RLINK,PRMSCITM      EXTRACT NEXT ITEM
*
*        IF THE VALUE BEGAN WITH A LEFT PARENTHESIS,
*        IT SHOULD END WITH A RIGHT PARENTHESIS.
PRMSCS07 DS    0H
         LTR   R0,R0               TEST REMAINING LENGTH
         BNP   PRMSCS08            IF TERMINATOR WAS END OF FIELD
         CLI   0(R1),C')'          DID WE END AT A RT PARENTHESIS?
         BNE   PRMSCS09            DONT BYPASS IT IF NOT
         LA    R15,1               ADVANCE PAST RT PARENTHESIS
         AR    R1,R15              TO BYTE AFTER ")"
         SR    R0,R15              DECREMENT REMAINING LENGTH
*
*        CLEAR THE ENCLOSING PARENTHESES INDICATOR.
PRMSCS08 DS    0H
         SR    RPAREN,RPAREN       CLEAR PARENTHESES INDICATOR
*
*        RETURN THE STRING ADDRESS AND LENGTH TO THE CALLER.
PRMSCS09 DS    0H
         LA    R15,1               CHARACTER COUNT FOR REENTRY
         L     RLINK,PRMSCSLK      RELOAD LINK REGISTER VALUE
         LTR   R3,R3               TEST STRING LENGTH
         BNP   0(RLINK)            RETURN AT OFFSET 00 IF NULL
         B     4(RLINK)            RETURN AT OFFSET 04 IF NON-NULL
         EJECT  ,
*****************************************************************
*        SUBROUTINE TO PICK UP A NUMERIC VALUE                  *
*        FROM THE PARM FIELD, AND RETURN ITS BINARY VALUE IN    *
*        REGISTER R15, AND ITS ADDRESS AND LENGTH               *
*        IN REGISTERS R2 & R3.                                  *
*        THIS SUBROUTINE EXPECTS REGISTERS AS FOLLOWS......     *
*             R15   LENGTH OF KEYWORD PARAMETER & "="           *
*             R0    REMAINING LENGTH OF PARM FIELD              *
*             R1    ADDRESS OF FIRST BYTE OF KEYWORD            *
*        THIS SUBROUTINE MAKES TWO RETURNS.....                 *
*             0(RLINK)   THE PARAMETER VALUE SUPPLIED IS NULL   *
*             4(RLINK)   THE PARAMETER VALUE IS IN BINARY       *
*                        IN R15.                                *
*        REGISTERS ON RETURN ARE SET AS FOLLOWS.....            *
*             R15   DECIMAL VALUE CONVERTED TO BINARY           *
*             R0    REMAINING LENGTH OF PARM FIELD              *
*             R1    ADDRESS OF TERMINATING BYTE (COMMA OR BLANK)*
*                   FOR THE VALUE PART OF THE KEYWORD           *
*             R2    ADDRESS OF THE FIRST BYTE OF THE STRING     *
*                   EXTRACTED FROM THE PARM FIELD.              *
*             R3    LENGTH OF THE STRING EXTRACTED FROM THE     *
*                   PARM FIELD.                                 *
*             RPAREN  00 IF THIS IS THE ONLY OR LAST VALUE      *
*                        FOR THE CURRENT KEYWORD.               *
*                     04 IF THIS IS NOT THE LAST VALUE          *
*                        FOR THE CURRENT KEYWORD.               *
*        A NUMERIC-VALUED KEYWORD PROCESSED BY THIS SUBROUTINE  *
*        CAN HAVE THE FOLLOWING FORMATS.....                    *
*            KEYWORD=VALUE1                                     *
*            KEYWORD=(VALUE1)                                   *
*            KEYWORD=(VALUE1,VALUE2,...)                        *
*****************************************************************
*
*        PROCESS THE NUMERIC-VALUED KEYWORD
PRMSCVAL DS    0H
         ST    RLINK,PRMSCVLK      SAVE LINK REGISTER VALUE FOR RETURN
         XC    PRMVALAS,PRMVALAS   CLEAR ACCUMULATION AREA
         SR    R2,R2               CLEAR
         LR    R3,R2               STRING POINTER REGISTERS
         CH    R15,=Y(01)          KEYWORD LENGTH PRESENT?
         BNH   *+L'*+2             BRANCH IF NOT
         SR    RPAREN,RPAREN       INIT PAREN INDICATOR IF 1ST CALL
*
*        ADVANCE PAST THE KEYWORD OR THE PRECEEDING DELIMITER,
*        AND TEST FOR THE END OF THE PARM STRING.
PRMSCV00 DS    0H
         AR    R1,R15              TO BYTE AFTER "="
         SR    R0,R15              DECREMENT REMAINING LENGTH
         BNP   PRMSCV08            DROP PAREN INDICATOR IF AT END
         CLI   0(R1),C' '          IS TERMINATOR A BLANK?
         BE    PRMSCV08            DROP PAREN INDICATOR IF A BLANK
         LA    R15,1               RESET CHARACTER COUNT TO 1
*
*        IF THE ENCLOSING PARENTHESES INDICATOR IS SET,
*        PROCEED IMMEDIATELY TO EXTRACT THE NEXT VALUE.
PRMSCV01 DS    0H
         LTR   RPAREN,RPAREN       PARENTHESES INDICATOR SET??
         BP    PRMSCV05            PROCESS NEXT VALUE IF YES
*
*        THE PARENTHESES INDICATOR IS NOT SET,
*        CHECK FOR ENCLOSING PARENTHESES.
PRMSCV02 DS    0H                  PROCESS THE PARAMETER VALUE
         CLI   0(R1),C'('          IS VALUE ENCLOSED IN PARENTHESES?
         BNE   PRMSCV05            BEGIN PROCESSING DIRECTLY IF NOT
*
*        THE VALUE IS ENCLOSED IN PARENTHESES.
*        TURN THE PARENTHESES INDICATOR ON,
*        AND SKIP PAST THE ENCLOSING LEFT PARENTHESIS.
PRMSCV03 DS    0H
         LA    RPAREN,4            INDICATE ENCLOSING PARENTHESES
         AR    R1,R15              TO BYTE AFTER "("
         SR    R0,R15              DECREMENT REMAINING LENGTH
         BNP   PRMSCV08            DROP PAREN INDIC IF END
*
*        RETRIEVE THE NUMERIC VALUE,
*        AND GET ITS VALUE, ADDRESS, AND LENGTH.
*        ON RETURN, REGISTER R1 POINTS TO THE CHARACTER FOLLOWING
*        THE STRING ITEM IN THE PARM FIELD.
PRMSCV05 DS    0H
         BAS   RLINK,PRMSCNUM      EXTRACT NEXT NUMERIC VALUE
         ST    R15,PRMVALAS        SAVE VALUE
*
*        IF THE VALUE BEGAN WITH A LEFT PARENTHESIS,
*        IT SHOULD END WITH A RIGHT PARENTHESIS.
PRMSCV07 DS    0H
         LTR   R0,R0               TEST REMAINING LENGTH
         BNP   PRMSCV08            IF TERMINATOR WAS END OF FIELD
         CLI   0(R1),C')'          DID WE END AT A RT PARENTHESIS?
         BNE   PRMSCV09            DONT BYPASS IT IF NOT
         LA    R15,1               ADVANCE PAST RT PARENTHESIS
         AR    R1,R15              TO BYTE AFTER ")"
         SR    R0,R15              DECREMENT REMAINING LENGTH
*
*        CLEAR THE ENCLOSING PARENTHESES INDICATOR.
PRMSCV08 DS    0H
         SR    RPAREN,RPAREN       CLEAR PARENTHESES INDICATOR
*
*        RETURN THE STRING ADDRESS AND LENGTH TO THE CALLER.
PRMSCV09 DS    0H
         L     RLINK,PRMSCVLK      RELOAD LINK REGISTER VALUE
         L     R15,PRMVALAS        RELOAD VALUE
         LTR   R3,R3               TEST STRING LENGTH
         BNP   0(RLINK)            RETURN AT OFFSET 00 IF NULL
         B     4(RLINK)            RETURN AT OFFSET 04 IF NON-NULL
         EJECT  ,
*****************************************************************
*        SUBROUTINE TO PICK UP A DAY OF THE WEEK VALUE          *
*        FROM THE PARM FIELD, CONVERT IT TO A BIT MASK,         *
*        AND RETURN ITS VALUE TO THE CALLER IN R15.             *
*        THIS SUBROUTINE EXPECTS REGISTERS AS FOLLOWS....       *
*             R15   LENGTH OF KEYWORD PARAMETER & "="           *
*             R0    REMAINING LENGTH OF PARM FIELD              *
*             R1    ADDRESS OF FIRST BYTE OF KEYWORD            *
*        THIS SUBROUTINE MAKES TWO RETURNS.....                 *
*             0(RLINK)   THE PARAMETER VALUE SUPPLIED IS NULL   *
*             4(RLINK)   THE PARAMETER VALUE IS IN BINARY       *
*                        IN R15.                                *
*        REGISTERS ON RETURN ARE SET AS FOLLOWS.....            *
*             R15   DAY OF THE WEEK BIT MASK IN BITS 24-31.     *
*             R0    REMAINING LENGTH OF PARM FIELD              *
*             R1    ADDRESS OF TERMINATING BYTE (COMMA OR BLANK)*
*                   FOR THE VALUE PART OF THE KEYWORD           *
*        A KEYWORD PROCESSED BY THIS SUBROUTINE                 *
*        CAN HAVE THE FOLLOWING FORMATS.....                    *
*            KEYWORD=VALUE1                                     *
*            KEYWORD=(VALUE1)                                   *
*****************************************************************
*
*        PROCESS THE DAY-OF-THE-WEEK KEYWORD
PRMSCDOW DS    0H
         ST    RLINK,PRMSCDLK      SAVE LINK REGISTER VALUE FOR RETURN
         AR    R1,R15              TO BYTE AFTER "="
         SR    R0,R15              DECREMENT REMAINING LENGTH
         BNP   0(RLINK)            NULL VALUE IF END
         CLI   0(R1),C' '          IS TERMINATOR A BLANK?
         BE    0(RLINK)            NULL VALUE IF YES
         CLI   0(R1),C','          IS TERMINATOR A COMMA?
         BE    0(RLINK)            NULL VALUE IF YES
         SR    RPAREN,RPAREN       ASSUME NOT ENCLOSED IN PARENS
*
*        THE KEYWORD'S VALUE IS NON-NULL.
*
PRMSCDPR DS    0H                  PROCESS THE PARAMETER VALUE
         CLI   0(R1),C'('          IS VALUE ENCLOSED IN PARENTHESES?
         BNE   PRMSCDP1            BEGIN PROCESSING DIRECTLY IF NOT
*
*        THE VALUE IS ENCLOSED IN PARENTHESES,
*        SKIP PAST THE ENCLOSING LEFT PARENTHESIS.
PRMSCDP0 DS    0H
         LA    RPAREN,4            INDICATE ENCLOSING PARENTHESES
         LA    R15,1               ADVANCE PAST LEFT PARENTHESIS
         AR    R1,R15              TO BYTE AFTER "("
         SR    R0,R15              DECREMENT REMAINING LENGTH
         BNP   0(RLINK)            VALUE NULL IF END OF PARM
         CLI   0(R1),C')'          IMMEDIATE ENDING PAREN????
         BNE   PRMSCDP1            VALUE SUPPLIED IF NOT
         AR    R1,R15              TO BYTE AFTER ")"
         SR    R0,R15              DECREMENT REMAINING LENGTH
         B     0(RLINK)            VALUE NULL
*
*        RETRIEVE THE MASK VALUE AND CONVERT IT TO BITS.
PRMSCDP1 DS    0H
         SR    R3,R3               CLEAR BIT MASK REGISTER
PRMSCDP2 DS    0H                  PROCESS CURRENT BYTE
         CLI   0(R1),C'0'          IF LESS THAN ZERO,
         BL    PRMSCDP8            END OF NUMERIC STRING.
         CLI   0(R1),C'9'          IF GT 9,
         BH    PRMSCDP8            END OF NUMERIC STRING
         CLI   0(R1),C'7'          IF GT 7,
         BH    PRMSCDP3            IGNORE DIGIT
         LA    R15,X'0F'           LOAD MASK
         SR    R2,R2               SET ZERO VALUE (SUNDAY)
         CLI   0(R1),C'7'          IF EQ 7,
         BE    *+L'*+4             PROCESS AS SUNDAY
         IC    R2,0(,R1)           PICK UP DIGIT
         NR    R2,R15              STRIP HIGH-ORDER BITS FROM DIGIT
         LA    R15,B'10000000'     LOAD MASK FOR SUNDAY (0)
         SRL   R15,0(R2)           SHIFT FOR DAY OF THE WEEK
         OR    R3,R15              COMBINE WITH ACCUMULATED RESULT
PRMSCDP3 DS    0H                  ADVANCE TO NEXT BYTE
         LA    R15,1               PROCEED ONE BYTE AT A TIME
         AR    R1,R15              TO NEXT DATA BYTE
         SR    R0,R15              DECREMENT REMAINING LENGTH
         BP    PRMSCDP2            IF PARM NOT EXHAUSTED
*
*        IF THE VALUE BEGAN WITH A LEFT PARENTHESIS,
*        IT SHOULD END WITH A RIGHT PARENTHESIS.
PRMSCDP8 DS    0H
         LTR   R0,R0               TEST REMAINING LENGTH
         BNP   PRMSCDP9            IF TERMINATOR WAS END OF FIELD
         LTR   RPAREN,RPAREN       ENCLOSED IN PARENS????
         BZ    PRMSCDP9            IF NO, WE ARE AT END
         CLI   0(R1),C')'          DID WE END AT A RT PARENTHESIS?
         BNE   PRMSCDP9            DONT BYPASS IT IF NOT
         LA    R15,1               ADVANCE PAST RT PARENTHESIS
         AR    R1,R15              TO BYTE AFTER ")"
         SR    R0,R15              DECREMENT REMAINING LENGTH
*        WE ARE NOW AT THE TERMINATOR OR THE END OF THE PARM FIELD
PRMSCDP9 DS    0H
         LR    R15,R3              COPY VALUE TO R15
         L     RLINK,PRMSCDLK      RELOAD LINK REGISTER VALUE
         B     4(RLINK)            RETURN TO CALLER AT OFFSET 04
         EJECT  ,
*****************************************************************
*        SUBROUTINE TO CONVERT A TIME VALUE                     *
*        IN BINARY 1/100 SECONDS TO AN EBCDIC VALUE             *
*        AND RETURN THE EBCDIC VALUE IN REGISTERS R2 AND R3.    *
*****************************************************************
*
*
PRMSCETM DS    0H                  GET EBCDIC TIME INTERVAL
         ST    RLINK,PRMSCELK      SAVE LINK REGISTER VALUE FOR RETURN
         LR    R2,R15              LOAD DELAY TIME IN 1/100 SECONDS
         SRDA  R2,32               SHIFT TO R3, CLEAR R2
         C     R3,=F'-1'           IS THIS THE "INCOMPATIBLE" VALUE?
         BNE   PRMSCET1            BRANCH IF NOT TO CONVERT VALUE
         MVC   PACK1(08),=CL8'99999999'  FLAG NEGATIVE VALUE
         B     PRMSCET9            GO RETURN VALUE TO CALLER
PRMSCET1 DS    0H                  BEGIN ACTUAL CONVERSION TO EBCDIC
         D     R2,=A(100)          GET "TH" IN R2, SECONDS IN R3
         CVD   R2,PACKAREA         CONVERT TO PACKED DECIMAL
         UNPK  PACK1+06(02),PACKAREA       MOVE "TH" TO AREA
         SLR   R2,R2               CLEAR R2 FOR DIVIDE
         D     R2,=A(60)           GET "SS" IN R2, MINUTES IN R3
         CVD   R2,PACKAREA         CONVERT TO PACKED DECIMAL
         UNPK  PACK1+04(02),PACKAREA       MOVE "SS" TO AREA
         SLR   R2,R2               CLEAR R2 FOR DIVIDE
         D     R2,=A(60)           GET "MM" IN R2, HOURS IN R3
         CVD   R2,PACKAREA         CONVERT TO PACKED DECIMAL
         UNPK  PACK1+02(02),PACKAREA       MOVE "MM" TO AREA
         CVD   R3,PACKAREA         CONVERT HOURS TO PACKED DECIMAL
         UNPK  PACK1+00(02),PACKAREA       MOVE "HH" TO AREA
         OC    PACK1(08),EZEROS            FORCE EBCDIC ZONES
PRMSCET9 DS    0H                  TIME VALUE CONVERSION IS COMPLETE
         LM    R2,R3,PACK1         PUT EBCDIC VALUE IN REGS
         L     RLINK,PRMSCELK      RELOAD LINK REGISTER VALUE
         B     0(RLINK)            RETURN TO CALLER AT OFFSET 00
         EJECT  ,
*****************************************************************
*        SUBROUTINE TO PICK UP THE NEXT CHARACTER STRING        *
*        FROM THE PARM FIELD, ASSEMBLE IT IN THE WORK AREA,     *
*        AND RETURN ITS ADDRESS AND LENGTH TO THE CALLER        *
*        IN REGISTERS R2 AND R3 RESPECTIVELY.                   *
*****************************************************************
*
PRMSCITM DS    0H
         ST    RLINK,PRMSCILK      SAVE LINK REGISTER VALUE FOR RETURN
         LA    R15,1               GO 1 CHAR AT A TIME
         LA    R2,PRMITMAS+L'PRMITMAS-1 -> LAST  CHR OF ASSEMBLY AREA
         LA    R3,PRMITMAS              -> FIRST CHR OF ASSEMBLY AREA
         MVC   PRMITMAS,EBLANKS    CLEAR ITEM  EXTRACT AREA
*
*        TEST FOR THE END OF THE PARM STRING,
*        A TERMINATOR SIGNALLING THE END OF THE ITEM,
*        OR THE START OF A QUOTED STRING.
PRMSCI01 DS    0H
         BAS   RLINK,PRMSCDLQ      TEST FOR DELIMITER/QUOTE
         B     PRMSCI12       00   END OF ITEM IF PARM EXHAUSTED
         B     PRMSCI12       04   END OF ITEM IF DELIMITER
         B     PRMSCI04       08   IF START OF QUOTED STRING
         B     PRMSCI03       12   IF NONE OF THE ABOVE
*
*        OUTSIDE THE SCOPE OF A QUOTED STRING.
*        COPY THE CURRENT CHARACTER TO THE ASSEMBLY AREA,
*        AND GO TO ADVANCE TO THE NEXT PARM CHARACTER.
PRMSCI03 DS    0H
         CR    R3,R2               ASSEMBLY AREA SPACE AVAILABLE?
         BH    PRMSCI11            SKIP PAST CHARACTER IF NOT
         MVC   00(01,R3),00(R1)    COPY CHARACTER
         OI    00(R3),X'40'        FORCE UPPER CASE
         AR    R3,R15              TO NEXT AVAIL CHR POSITION
         B     PRMSCI11            GO ADVANCE TO NEXT PARM CHAR
*
*        START OF A QUOTED STRING DETECTED,
*        OR WE ARE PROCESSING A QUOTED STRING.
*        ADVANCE TO THE NEXT PARM CHARACTER.
PRMSCI04 DS    0H
         AR    R1,R15              TO NEXT DATA BYTE
         SR    R0,R15              DECREMENT REMAINING LENGTH
         BNP   PRMSCI10            IF PARM DATA EXHAUSTED
*
*        TEST FOR A QUOTE EMBEDDED WITHIN A QUOTED STRING.
PRMSCI05 DS    0H
         CLI   00(R1),C''''        QUOTE?
         BNE   PRMSCI08            GO COPY CHARACTER IF NOT
*
*        A QUOTE WITHIN A QUOTED STRING WAS ENCOUNTERED.
*        ADVANCE TO THE NEXT PARM CHARACTER.
PRMSCI06 DS    0H
         AR    R1,R15              TO NEXT DATA BYTE
         SR    R0,R15              DECREMENT REMAINING LENGTH
         BNP   PRMSCI10            IF QUOTE WAS ENDING QUOTE
*
*        THE PREVIOUS CHARACTER WAS A QUOTE.
*        TEST THE CURRENT CHARACTER FOR A QUOTE (= DOUBLE QUOTE).
PRMSCI07 DS    0H
         CLI   00(R1),C''''        QUOTE?
         BNE   PRMSCI10            IF PREVIOUS QUOTE WAS ENDING QUOTE
*
*        WITHIN THE SCOPE OF A QUOTED STRING.
*        COPY THE CURRENT CHARACTER TO THE ASSEMBLY AREA,
*        AND GO TO ADVANCE TO THE NEXT PARM CHARACTER.
PRMSCI08 DS    0H
         CR    R3,R2               ASSEMBLY AREA SPACE AVAILABLE?
         BH    PRMSCI09            SKIP PAST CHARACTER IF NOT
         MVC   00(01,R3),00(R1)    COPY CHARACTER
         AR    R3,R15              TO NEXT AVAIL CHR POSITION
*
*        WITHIN THE SCOPE OF A QUOTED STRING,
*        AND THE CURRENT CHARACTER HAS BEEN PROCESSED.
*        LOOP TO ADVANCE TO THE NEXT PARM CHARACTER.
PRMSCI09 DS    0H
         B     PRMSCI04            GO ADVANCE TO NEXT PARM DATA BYTE
*
*        THE ENDING QUOTE OF A QUOTED STRING HAS BEEN DETECTED.
*        DROP BACK TO THE ENDING QUOTE.
PRMSCI10 DS    0H
         SR    R1,R15              TO PREV DATA BYTE
         AR    R0,R15              INCREMENT REMAINING LENGTH
*
*        OUTSIDE THE SCOPE OF A QUOTED STRING.
*        ADVANCE TO THE NEXT PARM CHARACTER,
*        AND LOOP IF ADDITIONAL PARM DATA BYTES REMAIN TO PROCESS.
PRMSCI11 DS    0H
         AR    R1,R15              TO NEXT DATA BYTE
         SR    R0,R15              DECREMENT REMAINING LENGTH
         BP    PRMSCI01            IF PARM DATA BYTES REMAIN
*
*        THE END OF THE ITEM HAS BEEN REACHED.
*        CALCULATE THE LENGTH OF THE EXTRACTED STRING,
*        AND RETURN TO THE CALLER.
PRMSCI12 DS    0H
         L     RLINK,PRMSCILK      RELOAD LINK REGISTER VALUE
         LA    R2,PRMITMAS              -> FIRST CHR OF ASSEMBLY AREA
         SR    R3,R2               CALCULATE EXTRACTED STRING LENGTH
         BR    RLINK               RETURN TO THE CALLER
         EJECT  ,
*****************************************************************
*        SUBROUTINE TO PICK UP THE NEXT NUMERIC STRING          *
*        FROM THE PARM FIELD, ASSEMBLE IT IN THE WORK AREA,     *
*        CONVERT IT TO BINARY, AND RETURN ITS ADDRESS AND       *
*        LENGTH TO THE CALLER IN REGISTERS R2 AND R3            *
*        RESPECTIVELY, AND ITS BINARY VALUE IN REGISTER R15.    *
*        IF THE NUMERIC STRING IS NULL, A VALUE OF ZERO         *
*        IS RETURNED.                                           *
*****************************************************************
*
PRMSCNUM DS    0H
         LA    R15,1               GO 1 CHAR AT A TIME
         LA    R2,PRMITMAS+L'PRMNUMAS-1 -> LAST  CHR OF ASSEMBLY AREA
         LA    R3,PRMITMAS              -> FIRST CHR OF ASSEMBLY AREA
         MVC   PRMITMAS,EBLANKS    CLEAR ITEM  EXTRACT AREA
         MVC   PRMNUMAS,EZEROS     CLEAR VALUE EXTRACT AREA
*
*        TEST FOR THE END OF THE PARM STRING.
PRMSC#00 DS    0H
         LTR   R0,R0               TEST REMAINING PARM LENGTH
         BNP   PRMSC#04            END OF ITEM IF PARM EXHAUSTED
*
*        TEST FOR A TERMINATOR SIGNALLING THE END OF THE ITEM
PRMSC#01 DS    0H
         CLI   0(R1),C'0'          LESS THAN ZERO??
         BL    PRMSC#04            END OF ITEM IF YES
         CLI   0(R1),C'9'          GREATER THAN NINE??
         BH    PRMSC#04            END OF ITEM IF YES
*
*        COPY THE CURRENT CHARACTER TO THE ASSEMBLY AREA,
*        AND GO TO ADVANCE TO THE NEXT PARM CHARACTER.
PRMSC#02 DS    0H
         CR    R3,R2               ASSEMBLY AREA SPACE AVAILABLE?
         BH    PRMSC#03            SKIP PAST CHARACTER IF NOT
         MVC   00(01,R3),00(R1)    COPY CHARACTER
         OI    00(R3),X'40'        FORCE UPPER CASE
         MVC   PRMNUMAS(L'PRMNUMAS-1),PRMNUMAS+1 LEFT SHIFT ONE BYTE
         MVC   PRMNUMAS+L'PRMNUMAS-1(01),0(R3)   MOVE IN DATA CHARACTER
         AR    R3,R15              TO NEXT AVAIL CHR POSITION
*
*        ADVANCE TO THE NEXT PARM CHARACTER,
*        AND LOOP IF ADDITIONAL PARM DATA BYTES REMAIN TO PROCESS.
PRMSC#03 DS    0H
         AR    R1,R15              TO NEXT DATA BYTE
         SR    R0,R15              DECREMENT REMAINING LENGTH
         BP    PRMSC#01            IF PARM DATA BYTES REMAIN
*
*        THE END OF THE ITEM HAS BEEN REACHED.
*        CALCULATE THE LENGTH OF THE EXTRACTED STRING,
*        AND RETURN TO THE CALLER.
PRMSC#04 DS    0H
         LA    R2,PRMITMAS              -> FIRST CHR OF ASSEMBLY AREA
         SR    R3,R2               CALCULATE EXTRACTED STRING LENGTH
         PACK  PRMNUMPD,PRMNUMAS   CONVERT VALUE TO PACKED DECIMAL
         CVB   R15,PRMNUMPD        CONVERT RESULT TO BINARY
         ST    R15,PRMNUMBN        SAVE BINARY VALUE
         BR    RLINK               RETURN TO THE CALLER
         EJECT  ,
*****************************************************************
*                                                               *
*                   P R M S C N B L                             *
*                                                               *
*        SUBROUTINE TO ADVANCE THE PARM FIELD REGISTER VALUES   *
*        IN R0 & R1 TO THE NEXT NON-BLANK CHARACTER IN THE      *
*        PARM STRING.                                           *
*                                                               *
*****************************************************************
*
PRMSCNBL DS    0H
         LA    R15,1               PROCEED 1 CHAR AT A TIME
*
*        TEST FOR THE END OF THE PARM STRING.
PRMSCN00 DS    0H
         LTR   R0,R0               TEST REMAINING PARM LENGTH
         BNP   PRMSCN03            END OF ITEM IF PARM EXHAUSTED
*
*        TEST FOR A TERMINATOR SIGNALLING THE END OF THE ITEM
PRMSCN01 DS    0H
         CLI   0(R1),C' '          BLANK??
         BNE   PRMSCN03            END OF ITEM IF NOT
*
*        ADVANCE TO THE NEXT PARM CHARACTER,
*        AND LOOP IF ADDITIONAL PARM DATA BYTES REMAIN TO PROCESS.
PRMSCN02 DS    0H
         AR    R1,R15              TO NEXT DATA BYTE
         SR    R0,R15              DECREMENT REMAINING LENGTH
         BP    PRMSCN01            IF PARM DATA BYTES REMAIN
*
*        THE END OF THE PARM STRING HAS BEEN REACHED,
*        OR A NON-BLANK CHARACTER HAS BEEN FOUND.
*        RETURN TO THE CALLER.
PRMSCN03 DS    0H
         BR    RLINK               RETURN TO THE CALLER
         EJECT  ,
*****************************************************************
*                                                               *
*                   P R M S C D L M                             *
*                                                               *
*        SUBROUTINE TO TEST THE NEXT PARM FIELD CHARACTER       *
*        TO DETERMINE IF IT IS A DELIMITER.                     *
*                                                               *
*        SUBROUTINE RETURNS ARE.....                            *
*           RLINK+00     END OF PARM STRING REACHED.            *
*           RLINK+04     CHARACTER IS A DELIMITER.              *
*           RLINK+08     NONE OF THE PRECEDING.                 *
*                                                               *
*****************************************************************
*
PRMSCDLM DS    0H
*
*        TEST FOR THE END OF THE PARM STRING.
         LTR   R0,R0               TEST REMAINING PARM LENGTH
         BNP   00(RLINK)           RETURN AT OFFSET 00 IF END
*
*        TEST FOR A DELIMITER SIGNALLING THE END OF THE ITEM
         CLI   00(R1),C' '         BLANK?
         BE    04(RLINK)           END OF ITEM IF YES
         CLI   00(R1),C'('         LEFT PARENTHESIS?
         BE    04(RLINK)           END OF ITEM IF YES
         CLI   00(R1),C')'         RIGHT PARENTHESIS?
         BE    04(RLINK)           END OF ITEM IF YES
         CLI   00(R1),C','         COMMA?
         BE    04(RLINK)           END OF ITEM IF YES
         CLI   00(R1),C'='         EQUALS SIGN?
         BE    04(RLINK)           END OF ITEM IF YES
*
*
*        NOT THE END OF STRING, OR A DELIMITER;
*        RETURN TO THE CALLER AT OFFSET 08.
         B     08(RLINK)           RETURN TO THE CALLER
         EJECT  ,
*****************************************************************
*                                                               *
*                   P R M S C D L Q                             *
*                                                               *
*        SUBROUTINE TO TEST THE NEXT PARM FIELD CHARACTER       *
*        TO DETERMINE IF IT IS A DELIMITER OR QUOTE.            *
*                                                               *
*        SUBROUTINE RETURNS ARE.....                            *
*           RLINK+00     END OF PARM STRING REACHED.            *
*           RLINK+04     CHARACTER IS A DELIMITER.              *
*           RLINK+08     CHARACTER IS A QUOTE.                  *
*           RLINK+12     NONE OF THE PRECEDING.                 *
*                                                               *
*****************************************************************
*
PRMSCDLQ DS    0H
*
*        TEST FOR THE END OF THE PARM STRING.
         LTR   R0,R0               TEST REMAINING PARM LENGTH
         BNP   00(RLINK)           RETURN AT OFFSET 00 IF END
*
*        TEST FOR A TERMINATOR SIGNALLING THE END OF THE ITEM
         CLI   00(R1),C' '         BLANK?
         BE    04(RLINK)           END OF ITEM IF YES
         CLI   00(R1),C'('         LEFT PARENTHESIS?
         BE    04(RLINK)           END OF ITEM IF YES
         CLI   00(R1),C')'         RIGHT PARENTHESIS?
         BE    04(RLINK)           END OF ITEM IF YES
         CLI   00(R1),C','         COMMA?
         BE    04(RLINK)           END OF ITEM IF YES
         CLI   00(R1),C'='         EQUALS SIGN?
         BE    04(RLINK)           END OF ITEM IF YES
*
*        TEST FOR THE START OF A QUOTED STRING.
         CLI   00(R1),C''''        QUOTE?
         BE    08(RLINK)           START OF QUOTED STRING IF YES
*
*
*        NOT THE END OF STRING, A DELIMITER, OR A QUOTE;
*        RETURN TO THE CALLER AT OFFSET 12.
         B     12(RLINK)           RETURN TO THE CALLER
         TITLE 'PAGEADD - WRITE OPERATOR MESSAGE SUBROUTINE'
WTOCMD   DS    0H
         ST    RLINK,WTSVCMDL      SAVE RETURN REGISTER VALUE
         SR    R0,R0               CLEAR R0
         ICM   R0,B'0011',WTOCONID INDICATE CONSOLE OF ORIGIN
         BAS   RLINK,MAPCNID       MAP SYMBOLIC CONSOLE ID TO BINARY
         CLC   WTOCONID,DFLTCNID   IS CONSOLE ID "**"??
         BNE   *+L'*+4+4           QUEUE MESSAGE TO CONSOLE IF NOT
         CLI   XEQTRKID,CHJOBID    STARTED TASK??
         BNE   *+L'*+4             DON'T QUEUE MSG TO CONSOLE IF NOT
         OI    WTOMCS,WPLMCSFB     QUEUE MESSAGE TO CONSOLE (REG0)
         XR    R1,R1                  CLEAR R1
         ICM   R1,B'0001',WTOLEN+1    MSG LENGTH+4
         LA    R1,WTOAREA(R1)      -> START OF DESCRIPTOR/ROUTE CODES
         MVC   00(02,R1),WTODSCCD  APPLY DESCRIPTOR CODES
         MVC   02(02,R1),WTORTECD  APPLY ROUTING    CODES
         WTO   MF=(E,WTOAREA)      WRITE MESSAGE TO THE OPERATOR
         L     RLINK,WTSVCMDL      RELOAD RETURN REGISTER VALUE
         BR    RLINK               RETURN TO CALLER
         TITLE 'PAGEADD - WRITE OPERATOR MESSAGE WITH REPLY SUBROUTINE'
WTORCMD  DS    0H
         ST    RLINK,WTSVCMDL      SAVE RETURN REGISTER VALUE
         XC    WTORECB,WTORECB     CLEAR REPLY ECB
         XC    WTOREPLY,WTOREPLY   CLEAR REPLY AREA
         MVC   WTODSCCD,DFLTDSC7   FORCE DESC=(7)
         SR    R0,R0               CLEAR R0
         ICM   R0,B'0011',WTOCONID INDICATE CONSOLE OF ORIGIN
         BAS   RLINK,MAPCNID       MAP SYMBOLIC CONSOLE ID TO BINARY
         CLC   WTOCONID,DFLTCNID   IS CONSOLE ID "**"??
         BNE   *+L'*+4+4           QUEUE MESSAGE TO CONSOLE IF NOT
         CLI   XEQTRKID,CHJOBID    STARTED TASK??
         BNE   *+L'*+4             DON'T QUEUE MSG TO CONSOLE IF NOT
         OI    WTOMCS,WPLMCSFB     QUEUE MESSAGE TO CONSOLE
         XR    R1,R1                  CLEAR R1
         ICM   R1,B'0001',WTOLEN+1    MSG LENGTH+4
         LA    R1,WTOAREA(R1)      -> START OF DESCRIPTOR/ROUTE CODES
         MVC   00(02,R1),WTODSCCD  APPLY DESCRIPTOR CODES
         MVC   02(02,R1),WTORTECD  APPLY ROUTING    CODES
         WTOR  ,                                                       X
               WTOREPLY,           REPLY AREA ADDRESS                  X
               L'WTOREPLY,         REPLY AREA LENGTH                   X
               WTORECB,            REPLY ECB                           X
               MF=(E,WTORAREA)     WRITE MESSAGE TO THE OPERATOR
         WAIT  ECB=WTORECB         WAIT FOR OPERATOR REPLY
         BAS   RLINK,PRTREPLY      RECORD OPER REPLY ON SYSPRINT
         L     RLINK,WTSVCMDL      RELOAD RETURN REGISTER VALUE
         BR    RLINK               RETURN TO CALLER
         TITLE 'PAGEADD - ISSUE OPERATOR COMMAND SUBROUTINE'
ISSUECMD DS    0H
         ST    RLINK,WTSVCMDL      SAVE RETURN REGISTER VALUE
         MVC   WTSVMCS,WTOMCS      SAVE MCS FLAGS
         XC    WTOMCS,WTOMCS       CLEAR MCS FLAGS
         CLI   AUTHFCTN,00         IS THE PAGEADD PROGRAM AUTHORIZED?
         BNE   BYISCMD             BYPASS COMMAND IF NOT
         MODESET KEY=ZERO          GET INTO KEY ZERO
         SR    R0,R0               CLEAR R0
         ICM   R0,B'0011',WTOCONID INDICATE CONSOLE OF ORIGIN
         LA    R1,WTOAREA          POINT TO OPERATOR COMMAND
         BAS   RLINK,MAPCNID       MAP SYMBOLIC CONSOLE ID TO BINARY
         SVC   34                  PASS COMMAND TO SYSTEM
         MODESET KEY=NZERO         RESET PROTECT KEY
BYISCMD  DS    0H
         MVC   WTOMCS,WTSVMCS      RESTORE MCS FLAGS
         L     RLINK,WTSVCMDL      RELOAD RETURN REGISTER VALUE
         BR    RLINK               RETURN TO CALLER
         TITLE 'PAGEADD - MAP CONSOLE IDENTIFIER SUBROUTINE'
*****************************************************************
*        SUBROUTINE TO DYNAMICALLY DETERMINE THE MCS ID         *
*        FOR THE CONSOLE IDENTIFIER IN -R0-,                    *
*        AND REPLACE THE VALUE IN -R0- WITH THE CORRECT         *
*        MCS CONSOLE NUMBER.                                    *
*                                                               *
*        INPUT REGISTERS ARE:                                   *
*              R0        SYMBOLIC MCS CONSOLE IDENTIFIER        *
*                        IN THE LOW ORDER TWO BYTES;            *
*              RLINK     RETURN ADDRESS TO THE CALLER           *
*                                                               *
*        OUTPUT REGISTERS ARE:                                  *
*              R15       CHANGED                                *
*              R0        MCS BINARY CONSOLE IDENTIFIER          *
*              R1        UNCHANGED                              *
*              R2        UNCHANGED                              *
*              R3        UNCHANGED                              *
*              RLINK     RETURN ADDRESS TO THE CALLER           *
*                                                               *
*****************************************************************
*
MAPCNID  DS    0H
*
*
*        CHECK FOR A SYMBOLIC MCS CONSOLE ID.
MAPCN00  DS    0H
         CLM   R0,B'0011',=C'**'   IS CNID = '**'???
         BNE   *+L'*+4             IF IT IS,
         ICM   R0,B'0011',XEQCONID+L'XEQCONID-2  LOAD TASK CONSOLE ID
         CLM   R0,B'0011',=C'**'   IS CNID = '**'???
         BNE   *+L'*+4             IF IT IS,
         ICM   R0,B'0011',=C'MC'   DESIGNATE MASTER CONSOLE
         CLM   R0,B'0011',=Y(00)   IS CNID = ZERO???
         BE    MAPCN04             IF CONSOLE ID ZERO
         CLM   R0,B'0011',=C'MC'   IS CNID = 'MC'???
         BNE   MAPCN04             IF CONSOLE ID ALREADY NUMERIC
*
*
*        CHAIN TO THE MCS UCM PREFIX FOR THE MASTER CONSOLE MCS ID.
MAPCN01  DS    0H
         L     R15,CVTPTR          POINT TO THE CVT
         USING CVT,R15             CVT ADDRESSABILITY
         L     R15,CVTCUCB         POINT TO THE UCM BASE
         SH    R15,=Y(04)          POINT TO UCMPRFXP
         L     R15,00(,R15)        POINT TO THE UCM MCS PREFIX
         USING UCMPRFX,R15         MCS UCM PREFIX ADDRESSABILITY
*
*        POINT TO THE MASTER CONSOLE UCM ENTRY
MAPCN02  DS    0H
         L     R15,UCMMCENT        POINT TO MASTER CONSOLE UCM ENTRY
         USING UCMLIST,R15         MASTER CONSOLE UCME ADDR
*
*        PICK UP THE MASTER CONSOLE UCM IDENTIFIER
MAPCN03  DS    0H
         ICM   R0,B'0010',=Y(00)   LOAD X'00'
         ICM   R0,B'0001',UCMID    MASTER CONSOLE UCM ID
*
*        RETURN TO THE CALLER.
MAPCN04  DS    0H
         DROP  R15                 MASTER CONSOLE UCME NO LONGER AVAIL
         BR    RLINK               RETURN TO CALLER
         TITLE 'PAGEADD - TEST EXECUTION APF AUTHORIZATION SUBROUTINE'
         SPACE 4
*
*
*        TEST THE MODULE'S APF AUTHORIZATION TO SEE
*        IF OPERATOR COMMANDS CAN BE ISSUED.
TESTAPF  DS    0H                  TEST PROGRAM AUTHORIZATION
         ST    RLINK,AUTHLKSV      SAVE RLINK RETURN VALUE
         TESTAUTH FCTN=1           TEST FOR AUTHORIZATION CODE 1
         STC   R15,AUTHFCTN        SAVE RETURN CODE IN WORK AREA
         LTR   R15,R15             TEST RETURN CODE
         BZ    BYAPFTST            BRANCH IF AUTHORIZED
         CLI   INPMODE,04          "NOINPUT" ??
         BE    BYAPFTST            AUTH NOT IMPORTANT IF CMDS NOT INPUT
         CLI   CMDMODE,04          "NOCMDS"  ??
         BE    BYAPFTST            AUTH NOT IMPORTANT IF CMDS NOT XEQ
         MVC   WTOAREA(WTOMSG2Z),WTOMSG2    MOVE IN ERROR MESSAGE
         MVC   WTOCONID,MSGCONID   ASSIGN  MCS CONSOLE ID
         MVC   WTODSCCD,MSGDSCCD   ASSIGN  MCS DESC  CODE
         MVC   WTORTECD,MSGRTECD   ASSIGN  MCS ROUTE CODE
         BAS   RLINK,PRTCMD        PRINT ERROR MESSAGE
         BAS   RLINK,WTOCMD        ISSUE ERROR MESSAGE
         MVI   CMDMODE,04          FORCE "NOCMDS"
BYAPFTST DS    0H
         L     RLINK,AUTHLKSV      LOAD RLINK RETURN VALUE
         BR    RLINK               RETURN TO CALLER
         TITLE 'PAGEADD - DATE CALCULATION ROUTINES'
*****************************************************************
*                                                               *
*                   F A C T D A T E                             *
*                                                               *
*        DATE CALCULATION ROUTINE FOR CONVERTING A BINARY       *
*        "FACTOR" DATE VALUE TO ITS EQUIVALENT DATE VALUES,     *
*        SAVING THESE VALUES IN THE WORK AREA, AND RETURNING    *
*        THE PACKED DECIMAL JULIAN DATE "00YYDDDC" EQUIVALENT   *
*        VALUE IN REGISTER RENTRY.                              *
*                                                               *
*        INPUT REGISTERS ARE:                                   *
*              RLINK     RETURN ADDRESS TO THE CALLER           *
*              RENTRY    CONTAINS THE BINARY DATE "FACTOR"      *
*                        VALUE.                                 *
*              RWORK0 - RWORK7         NOT USED.                *
*                                                               *
*        OUTPUT REGISTERS ARE:                                  *
*              RLINK     UNCHANGED.                             *
*              RENTRY    CONTAINS THE YEAR AND DAY OF THE YEAR  *
*                        IN PACKED DECIMAL IN THE FORM          *
*                        "00YYDDDC".                            *
*              RWORK0 - RWORK7         UNCHANGED.               *
*                                                               *
*****************************************************************
*
*        CONVERT BINARY FACTOR DATE VALUE
*        TO PACKED DECIMAL JULIAN DATE YYDDD FORMAT.
FACTDATE DS    0H                  ROUTINE ENTRY POINT AND LABEL
         STM   RLINK,RWORK7,SAVFCTDT+00    SAVE REGISTERS
         CL    RENTRY,DATFACT      DATE IN WORK AREA?
         BE    FACTDTRT            SKIP UNNECESSARY PROCESSING IF YES
         LR    RWORK4,RENTRY       COPY DATE TO RWORK4
         BAS   RLINK,CALCYYYY      CALCULATE YEAR & DAY OF YEAR
         BAS   RLINK,CALCMMDD      CALCULATE MONTH & DAY OF MONTH
         BAS   RLINK,CVDDATE       CONVERT VALUES / UPDATE WORK AREA
FACTDTRT L     RLINK,SAVFCTDT+00                       RESTORE REGS
         L     RENTRY,DATYYDDD     LOAD JULIAN DATE VALUE
         LM    RWORK0,RWORK7,SAVFCTDT+08+04*RWORK0     RESTORE REGS
         BR    RLINK               RETURN TO CALLER
         EJECT  ,
*****************************************************************
*                                                               *
*                   J U L D A T E                               *
*                                                               *
*        DATE CALCULATION ROUTINE FOR CONVERTING A PACKED       *
*        DECIMAL JULIAN DATE IN THE FORM "00YYDDDC" OR          *
*        "YYYYDDDC" TO ITS EQUIVALENT DATE VALUES,              *
*        SAVING THESE VALUES IN THE WORK AREA,                  *
*        AND RETURNING THE "0MMDDYYC" DATE VALUE IN REGISTER    *
*        RENTRY.                                                *
*                                                               *
*        INPUT REGISTERS ARE:                                   *
*              RLINK     RETURN ADDRESS TO THE CALLER           *
*              RENTRY    CONTAINS THE JULIAN DATE IN EITHER     *
*                        THE "00YYDDDC" OR "YYYYDDDC" FORM.     *
*                        DATES HAVING THE FORM "00YYDDDC"       *
*                        ARE RETURNED IN REGISTER 1 BY THE      *
*                        SYSTEM "TIME" MACRO.                   *
*              RWORK0 - RWORK7         NOT USED.                *
*                                                               *
*        OUTPUT REGISTERS ARE:                                  *
*              RLINK     UNCHANGED.                             *
*              RENTRY    CONTAINS THE GREGORIAN DATE EXPRESSED  *
*                        IN PACKED DECIMAL "0MMDDYYC" FORM.     *
*              RWORK0 - RWORK7         UNCHANGED.               *
*                                                               *
*****************************************************************
*
*        CONVERT PACKED DECIMAL JULIAN DATE TO MMDDY FORMAT.
JULDATE  DS    0H                  ROUTINE ENTRY POINT AND LABEL
         STM   RLINK,RWORK7,SAVJULDT+00    SAVE REGISTERS
         CL    RENTRY,DATJUL       DATE IN WORK AREA?
         BE    JULDTRT             SKIP UNNECESSARY PROCESSING IF YES
         CL    RENTRY,DATYYDDD     DATE IN WORK AREA?
         BE    JULDTRT             SKIP UNNECESSARY PROCESSING IF YES
         BAS   RLINK,CVBJUL        CONVERT JULIAN DATE TO BINARY
         BAS   RLINK,CALCFACT      CALCULATE FACTOR VALUE
         BAS   RLINK,CALCMMDD      CALCULATE MONTH & DAY OF MONTH
         BAS   RLINK,CVDDATE       CONVERT VALUES / UPDATE WORK AREA
JULDTRT  L     RLINK,SAVJULDT+00                       RESTORE REGS
         L     RENTRY,DATMDY       LOAD RESULTING DATE VALUE
         LM    RWORK0,RWORK7,SAVJULDT+08+04*RWORK0     RESTORE REGS
         BR    RLINK               RETURN TO CALLER
         EJECT  ,
*****************************************************************
*                                                               *
*                   M D Y D A T E                               *
*                                                               *
*        DATE CALCULATION ROUTINE FOR CONVERTING A PACKED       *
*        DECIMAL GREGORIAN DATE IN THE FORM "0MMDDYYC"          *
*        TO ITS EQUIVALENT DATE VALUES, SAVING THESE VALUES     *
*        IN THE WORK AREA, AND RETURNING THE PACKED DECIMAL     *
*        JULIAN DATE "00YYDDDC" EQUIVALENT VALUE IN REGISTER    *
*        RENTRY.                                                *
*                                                               *
*        INPUT REGISTERS ARE:                                   *
*              RLINK     RETURN ADDRESS TO THE CALLER           *
*              RENTRY    CONTAINS THE GREGORIAN DATE EXPRESSED  *
*                        IN PACKED DECIMAL "0MMDDYYC" FORM.     *
*              RWORK0 - RWORK7         NOT USED.                *
*                                                               *
*        OUTPUT REGISTERS ARE:                                  *
*              RLINK     UNCHANGED.                             *
*              RENTRY    CONTAINS THE YEAR AND DAY OF THE YEAR  *
*                        IN PACKED DECIMAL IN THE FORM          *
*                        "00YYDDDC".                            *
*              RWORK0 - RWORK7         UNCHANGED.               *
*                                                               *
*****************************************************************
*
*        CONVERT PACKED DECIMAL GREGORIAN DATE IN MMDDYY FORMAT
*        TO PACKED DECIMAL JULIAN DATE YYYYDDD FORMAT.
MDYDATE  DS    0H                  ROUTINE ENTRY POINT AND LABEL
         STM   RLINK,RWORK7,SAVMDYDT+00    SAVE REGISTERS
         CL    RENTRY,DATMDY       DATE IN WORK AREA?
         BE    MDYDTRT             SKIP UNNECESSARY PROCESSING IF YES
         BAS   RLINK,CVBMDY        CONVERT DATE TO BINARY
         BAS   RLINK,CALCDDD       CALCULATE DATE VALUES
         BAS   RLINK,CVDDATE       CONVERT VALUES / UPDATE WORK AREA
MDYDTRT  L     RLINK,SAVMDYDT+00                       RESTORE REGS
         L     RENTRY,DATYYDDD     LOAD JULIAN DATE VALUE
         LM    RWORK0,RWORK7,SAVMDYDT+08+04*RWORK0     RESTORE REGS
         BR    RLINK               RETURN TO CALLER
         EJECT  ,
*****************************************************************
*                                                               *
*                   Y M D D A T E                               *
*                                                               *
*        DATE CALCULATION ROUTINE FOR CONVERTING A PACKED       *
*        DECIMAL GREGORIAN DATE IN THE FORM "0YYMMDDC"          *
*        TO ITS EQUIVALENT DATE VALUES, SAVING THESE VALUES     *
*        IN THE WORK AREA, AND RETURNING THE PACKED DECIMAL     *
*        JULIAN DATE "00YYDDDC" EQUIVALENT VALUE IN REGISTER    *
*        RENTRY.                                                *
*                                                               *
*        INPUT REGISTERS ARE:                                   *
*              RLINK     RETURN ADDRESS TO THE CALLER           *
*              RENTRY    CONTAINS THE GREGORIAN DATE EXPRESSED  *
*                        IN PACKED DECIMAL "0YYMMDDC" FORM.     *
*              RWORK0 - RWORK7         NOT USED.                *
*                                                               *
*        OUTPUT REGISTERS ARE:                                  *
*              RLINK     UNCHANGED.                             *
*              RENTRY    CONTAINS THE YEAR AND DAY OF THE YEAR  *
*                        IN PACKED DECIMAL IN THE FORM          *
*                        "00YYDDDC".                            *
*              RWORK0 - RWORK7         UNCHANGED.               *
*                                                               *
*****************************************************************
*
*        CONVERT PACKED DECIMAL GREGORIAN DATE IN YYMMDD FORMAT
*        TO PACKED DECIMAL JULIAN DATE YYYYDDD FORMAT.
YMDDATE  DS    0H                  ROUTINE ENTRY POINT AND LABEL
         STM   RLINK,RWORK7,SAVYMDDT+00    SAVE REGISTERS
         CL    RENTRY,DATYMD       DATE IN WORK AREA?
         BE    YMDDTRT             SKIP UNNECESSARY PROCESSING IF YES
         BAS   RLINK,CVBYMD        CONVERT DATE TO BINARY
         BAS   RLINK,CALCDDD       CALCULATE DATE VALUES
         BAS   RLINK,CVDDATE       CONVERT VALUES / UPDATE WORK AREA
YMDDTRT  L     RLINK,SAVYMDDT+00                       RESTORE REGS
         L     RENTRY,DATYYDDD     LOAD JULIAN DATE VALUE
         LM    RWORK0,RWORK7,SAVYMDDT+08+04*RWORK0     RESTORE REGS
         BR    RLINK               RETURN TO CALLER
         EJECT  ,
*****************************************************************
*                                                               *
*                   M S G D A T E                               *
*                                                               *
*        DATE CALCULATION ROUTINE FOR PRODUCING A DIAGNOSTIC    *
*        MESSAGE LISTING THE VALUES GENERATED BY THE LAST       *
*        DATE PROCESSING ROUTINE INVOKED.                       *
*                                                               *
*        INPUT REGISTERS ARE:                                   *
*              RLINK     RETURN ADDRESS TO THE CALLER           *
*              RENTRY    NOT USED.                              *
*              RWORK0 - RWORK7         NOT USED.                *
*                                                               *
*        OUTPUT REGISTERS ARE:                                  *
*              RLINK     UNCHANGED.                             *
*              RENTRY    UNCHANGED.                             *
*              RWORK0 - RWORK7         UNCHANGED.               *
*                                                               *
*****************************************************************
*
*
*        BUILD AND ISSUE A DIAGNOSTIC MESSAGE.
MSGDATE  DS    0H
         STM   RLINK,RWORK7,SAVDTMSG+00     SAVE REGISTERS
         MVC   WTOAREA(WTOMSGWZ),WTOMSGW    MOVE IN DIAGNOSTIC MSG
         MVC   WTOCONID,MSGCONID   ASSIGN  MCS CONSOLE ID
         MVC   WTODSCCD,MSGDSCCD   ASSIGN  MCS DESC  CODE
         MVC   WTORTECD,MSGRTECD   ASSIGN  MCS ROUTE CODE
         LM    RENTRY,RWORK6,DATDOW         LOAD DATE VALUES
*        DOW
         CVD   R15,PACKAREA        CONVERT DOW TO PACKED DECIMAL
         OI    PACKAREA+L'PACKAREA-1,X'0F'  EBCDIC ZONE
         UNPK  WTOMSG+030(02),PACKAREA     MOVE VALUE TO MSG
*        MM
         CVD   R0,PACKAREA         CONVERT MM TO PACKED DECIMAL
         OI    PACKAREA+L'PACKAREA-1,X'0F'  EBCDIC ZONE
         UNPK  WTOMSG+037(02),PACKAREA     MOVE VALUE TO MSG
*        DD
         CVD   R1,PACKAREA         CONVERT DD TO PACKED DECIMAL
         OI    PACKAREA+L'PACKAREA-1,X'0F'  EBCDIC ZONE
         UNPK  WTOMSG+044(02),PACKAREA     MOVE VALUE TO MSG
*        DDD
         CVD   R2,PACKAREA         CONVERT DDD TO PACKED DECIMAL
         OI    PACKAREA+L'PACKAREA-1,X'0F'  EBCDIC ZONE
         UNPK  WTOMSG+052(03),PACKAREA     MOVE VALUE TO MSG
*        YYYY
         CVD   R3,PACKAREA         CONVERT YYYY TO PACKED DECIMAL
         OI    PACKAREA+L'PACKAREA-1,X'0F'  EBCDIC ZONE
         UNPK  WTOMSG+062(04),PACKAREA     MOVE VALUE TO MSG
*        "FACTOR"
         CVD   R4,PACKAREA         CONVERT "FACTOR" TO PACKED DECIMAL
         OI    PACKAREA+L'PACKAREA-1,X'0F'  EBCDIC ZONE
         UNPK  WTOMSG+075(08),PACKAREA     MOVE VALUE TO MSG
*        ISSUE THE DIAGNOSTIC MESSAGE
         BAS   RLINK,PRTCMD        PRINT DIAGNOSTIC MSG
         BAS   RLINK,WTOCMD        ISSUE DIAGNOSTIC MSG
*
*        RETURN TO THE CALLER.
         LM    RLINK,RWORK7,SAVDTMSG+00     LOAD REGISTERS
         BR    RLINK               RETURN TO CALLER
         TITLE 'PAGEADD - DATE CALCULATION INTERNAL SUBROUTINES'
*****************************************************************
*                                                               *
*                   C A L C F A C T                             *
*                                                               *
*        INTERNAL SUBROUTINE CALLED BY DATE CALCULATION         *
*        ROUTINES TO CALCULATE THE FACTOR VALUE                 *
*        CORRESPONDING TO A DAY OF THE YEAR, DETERMINE          *
*        THE "DDD" VALUE FOR THE LAST DAY OF FEBRUARY           *
*        OF THAT YEAR, AND DETERMINE THE NUMBER OF DAYS         *
*        IN THAT YEAR.                                          *
*                                                               *
*        THE FACTOR VALUE IS USEFUL FOR CALCULATING THE         *
*        DAY OF THE WEEK, DETERMINING THE NUMBER OF DAYS        *
*        BETWEEN DATES, AND DETERMINING THE DATE ASSOCIATED     *
*        WITH A RETENTION PERIOD.  THE LAST DAY OF FEBRUARY     *
*        VALUE IS USED IN CALCULATING THE MONTH                 *
*        AND DAY OF THE MONTH VALUES CORRESPONDING TO A         *
*        DAY OF THE YEAR, AND IN CALCULATING THE DAY OF THE     *
*        YEAR FROM THE MONTH AND DAY OF THE MONTH VALUES.       *
*                                                               *
*                                                               *
*        INPUT REGISTERS ARE:                                   *
*              RLINK     RETURN ADDRESS TO THE CALLER           *
*              RENTRY    NOT USED.                              *
*              RWORK0    NOT USED.                              *
*              RWORK1    NOT USED.                              *
*              RWORK2    DAY OF THE YEAR ("DDD")                *
*                        BINARY VALUE 000-365(6).               *
*              RWORK3    YEAR ("YYYY") BINARY VALUE.            *
*              RWORK4    NOT USED.                              *
*              RWORK5    NOT USED.                              *
*              RWORK6    NOT USED.                              *
*              RWORK7    NOT USED.                              *
*                                                               *
*        OUTPUT REGISTERS ARE:                                  *
*              RLINK     SAME AS ON INPUT                       *
*              RENTRY    UNCHANGED.                             *
*              RWORK0    UNCHANGED.                             *
*              RWORK1    UNCHANGED.                             *
*              RWORK2    UNCHANGED (STILL CONTAINS "DDD").      *
*              RWORK3    UNCHANGED (STILL CONTAINS "YYYY").     *
*              RWORK4    BINARY FACTOR VALUE CORRESPONDING TO   *
*                        THE DAY ("DDD") VALUE IN RWORK2 AND    *
*                        YEAR ("YYYY") VALUE IN RWORK3.         *
*              RWORK5    BINARY VALUE CORRESPONDING TO THE      *
*                        LAST DAY OF FEBRUARY OF YEAR "YYYY".   *
*                        IF YEAR "YYYY" IS A LEAP YEAR, THIS    *
*                        VALUE WILL BE 060, OTHERWISE IT WILL   *
*                        BE 059.                                *
*              RWORK6    BINARY VALUE CORRESPONDING TO THE      *
*                        NUMBER OF DAYS IN THE YEAR "YYYY".     *
*                        IF YEAR "YYYY" IS A LEAP YEAR, THIS    *
*                        VALUE WILL BE 366, OTHERWISE IT WILL   *
*                        BE 365.                                *
*              RWORK7    UNCHANGED.                             *
*                                                               *
*                                                               *
*        THE "FACTOR" VALUE CORRESPONDING TO THE SPECIFIED      *
*        YEAR AND DAY OF THE YEAR IS CALCULATED AS FOLLOWS:     *
*            C                       FUDGE FACTOR               *
*            + DDD                   DAY OF THE YEAR            *
*            + 365*YYYY                                         *
*            +INT((YYYY+4-1)/4)      LEAP YEAR ADJUSTMENT       *
*            -INT((YYYY+100-1)/100)  CENTURY YEAR ADJUSTMENT    *
*            +INT((YYYY+400-1)/400)  400 YEAR ADJUSTMENT        *
*        WHERE.....                                             *
*            C      IS AN ADJUSTMENT VALUE CHOSEN TO MAKE       *
*                   THE "FACTOR" VALUE YIELD THE CORRECT        *
*                   DAY OF THE WEEK AS ITS REMAINDER WHEN       *
*                   DIVIDED BY 7.                               *
*            DDD    IS THE JULIAN DAY OF THE YEAR, IN BINARY.   *
*            YYYY   IS THE CURRENT YEAR INCLUDING THE CENTURY;  *
*                   E.G., 1981.                                 *
*                                                               *
*        THE YEAR ADJUSTMENT VALUES ARE USED TO COMPENSATE FOR  *
*        THE NUMBER OF YEARS OF THAT TYPE PRECEDING BUT NOT     *
*        INCLUDING THE CURRENT YEAR.  IN ORDER TO PROCESS       *
*        YEAR 0000 AS A LEAP YEAR, CENTURY YEAR, AND A          *
*        DIVISIBLE-BY-400 YEAR, THE DIVISOR IS ADDED TO YYYY    *
*        BEFORE SUBTRACTING "1".  THUS THE NUMBER OF            *
*        DIVISIBLE-BY-400 YEARS PRECEEDING 1981 IS:             *
*        INT((1981+400-1)/400) = INT(2380/400) = INT(5.95) = 5  *
*        (0000; 0400; 0800; 1200; 1600).                        *
*                                                               *
*****************************************************************
*
*        CALCULATE FACTOR AND LEAP YEAR STARTING VALUES.
CALCFACT DS    0H                  ROUTINE ENTRY POINT AND LABEL
         STM   RLINK,RWORK7,SAVCLFCT+00    SAVE REGISTERS
         LA    RLINK,DTK1          LOAD CONSTANT
*
*        BEGIN DEVELOPING THE "FACTOR" AND LAST DAY OF FEBRUARY VALUES.
         L     RWORK4,DTFUDGE      "C"
         AR    RWORK4,RWORK2       +DDD
         LA    RWORK5,DTKLFEB      NON LEAP YR LAST DAY OF FEB
         LA    RWORK6,DTKYEAR      NUMBER OF DAYS IN NON-LEAP YEAR
*
*        ADD THE NUMBER OF DAYS IN THE YEARS PRECEEDING THIS ONE,
*              365*YYYY
*        TO THE FACTOR VALUE BEING DEVELOPED IN RWORK4.
         LR    RWORK1,RWORK3       COPY YYYY TO RWORK1
         MR    RWORK0,RWORK6       COMPUTE 365*YYYY
         AR    RWORK4,RWORK1       ADD 365*YYYY TO "FACTOR"
*
*        ADD THE LEAP YEAR ADJUSTMENT VALUE
*              INT((YYYY+4-1)/4)
*        TO THE FACTOR VALUE BEING DEVELOPED IN RWORK4.
         LA    RENTRY,DTK4         LOAD DIVISOR
         SR    RWORK0,RWORK0       CLEAR RWORK0
         LR    RWORK1,RWORK3       YYYY
         AR    RWORK1,RENTRY       +4
         DR    RWORK0,RENTRY       DIVIDE YYYY BY 4, QUOTIENT IN RWORK1
         LTR   RWORK0,RWORK0       CHECK REMAINDER FOR ZERO
         BNZ   *+L'*+2+2+2         BR IF NOT DIVISIBLE BY 4
         SR    RWORK1,RLINK        DECREMENT QUOTIENT BY 1
         AR    RWORK5,RLINK        ADD 1 TO LAST DAY OF FEB
         AR    RWORK6,RLINK        ADD 1 TO # OF DAYS IN YEAR
         SPACE 1
         AR    RWORK4,RWORK1  ADD INT((YYYY+4-1)/4) TO "FACTOR"
*
*        SUBTRACT THE CENTURY YEAR ADJUSTMENT VALUE
*              INT((YYYY+100-1)/100)
*        TO THE FACTOR VALUE BEING DEVELOPED IN RWORK4.
*        CENTURY YEARS DIVISIBLE BY 100 BUT NOT BY 400 (1800; 1900)
*        ARE NOT LEAP YEARS.
         LA    RENTRY,DTK100       LOAD DIVISOR
         SR    RWORK0,RWORK0       CLEAR RWORK0
         LR    RWORK1,RWORK3       YYYY
         AR    RWORK1,RENTRY       +100
         DR    RWORK0,RENTRY       # OF CENTURY YEARS PRECEEDING       X
                                   IN RWORK1 (IF REMAINDER ^= 0).
         LTR   RWORK0,RWORK0       CHECK REMAINDER FOR ZERO
         BNZ   *+L'*+2+2+2         BR IF NOT DIVISIBLE BY 100
         SR    RWORK1,RLINK        DECREMENT QUOTIENT BY 1
         SR    RWORK5,RLINK        SUBTRACT 1 FROM LAST DAY OF FEB
         SR    RWORK6,RLINK        SUBTRACT 1 FROM # OF DAYS IN YEAR
         SPACE 1
         SR    RWORK4,RWORK1  SUBTR INT((YYYY+100-1)/100) FRM "FACTOR"
*
*        ADD BACK THE 400 CENTURY YEAR ADJUSTMENT VALUE
*              INT((YYYY+400-1)/400)
*        TO THE FACTOR VALUE BEING DEVELOPED IN RWORK4.
*        CENTURY YEARS DIVISIBLE BY 400 (0000; 1600; 2000)
*        ARE LEAP YEARS.
         LA    RENTRY,DTK400       LOAD DIVISOR
         SR    RWORK0,RWORK0       CLEAR RWORK0
         LR    RWORK1,RWORK3       YYYY
         AR    RWORK1,RENTRY       +400
         DR    RWORK0,RENTRY       # OF 400 CENTURY YEARS PRECEEDING   X
                                   IN RWORK1 (IF REMAINDER ^= 0).
         LTR   RWORK0,RWORK0       CHECK REMAINDER FOR ZERO
         BNZ   *+L'*+2+2+2         BR IF NOT DIVISIBLE BY 400
         SR    RWORK1,RLINK        DECREMENT QUOTIENT BY 1
         AR    RWORK5,RLINK        ADD 1 TO LAST DAY OF FEB
         AR    RWORK6,RLINK        ADD 1 TO # OF DAYS IN YEAR
         SPACE 1
         AR    RWORK4,RWORK1  ADD INT((YYYY+400-1)/400) TO "FACTOR"
*
*        RETURN RESULTS IN RWORK4, RWORK5, & RWORK6  TO THE CALLER.
         LM    RLINK,RWORK3,SAVCLFCT+00            RELOAD REGS
         LM    RWORK7,RWORK7,SAVCLFCT+08+04*RWORK7 RELOAD REGS
         BR    RLINK               RETURN TO CALLER
         EJECT  ,
*****************************************************************
*                                                               *
*                   C A L C M M D D                             *
*                                                               *
*        INTERNAL SUBROUTINE CALLED BY DATE CALCULATION         *
*        ROUTINES TO CALCULATE THE MONTH AND DAY OF THE MONTH   *
*        CORRESPONDING TO A YEAR AND DAY OF THE YEAR,           *
*        AND RETURN THE RESULTS TO THE CALLER IN REGISTERS.     *
*                                                               *
*        INPUT REGISTERS ARE:                                   *
*              RLINK     RETURN ADDRESS TO THE CALLER           *
*              RENTRY    NOT USED.                              *
*              RWORK0    NOT USED.                              *
*              RWORK1    NOT USED.                              *
*              RWORK2    DAY OF THE YEAR ("DDD")                *
*                        BINARY VALUE 001-365(6).               *
*              RWORK3    YEAR ("YYYY") BINARY VALUE.            *
*              RWORK4    BINARY FACTOR VALUE CORRESPONDING TO   *
*                        THE DAY ("DDD") VALUE IN RWORK2 AND    *
*                        YEAR ("YYYY") VALUE IN RWORK3.         *
*              RWORK5    BINARY VALUE CORRESPONDING TO THE      *
*                        LAST DAY OF FEBRUARY OF YEAR "YYYY".   *
*                        IF YEAR "YYYY" IS A LEAP YEAR, THIS    *
*                        VALUE WILL BE 060, OTHERWISE IT WILL   *
*                        BE 059.                                *
*              RWORK6    NOT USED.                              *
*              RWORK7    NOT USED.                              *
*                                                               *
*        OUTPUT REGISTERS ARE:                                  *
*              RLINK     SAME AS ON INPUT                       *
*              RENTRY    UNCHANGED.                             *
*              RWORK0    MONTH OF THE YEAR BINARY VALUE 01-12.  *
*              RWORK1    DAY OF THE MONTH BINARY VALUE 01-31.   *
*              RWORK2    UNCHANGED (STILL CONTAINS "DDD").      *
*              RWORK3    UNCHANGED (STILL CONTAINS "YYYY").     *
*              RWORK4    UNCHANGED (STILL CONTAINS FACTOR).     *
*              RWORK5    UNCHANGED (STILL CONTAINS LAST DAY     *
*                        LAST DAY OF FEBRUARY DDD VALUE).       *
*              RWORK6    UNCHANGED.                             *
*              RWORK7    UNCHANGED.                             *
*                                                               *
*        THE MONTH AND DAY OF THE MONTH ARE CALCULATED          *
*        USING A SEQUENCE OF FORMULAE AS FOLLOWS.....           *
*                                                               *
*            1.  D2 = DAY OF THE YEAR RELATIVE TO MARCH 1:      *
*                IF DDD > LAST DAY OF FEB,                      *
*                THEN                                           *
*                    D2 = DDD - LAST DAY OF FEB;                *
*                ELSE                                           *
*                    D2 = DDD + 306;                            *
*            2.  M2 = MONTH(MAR-FEB;MAR=00,FEB=11):             *
*                    M2 = INT((D2*10-5)/306)                    *
*            3.  MM = MONTH OF THE YEAR:                        *
*                MM = M2 - 9;                                   *
*                IF MM <= 00                                    *
*                THEN                                           *
*                    MM = MM + 12;                              *
*            4.  D3 = LAST DAY OF PREVIOUS MONTH                *
*                     IN A MARCH-FEB YEAR:                      *
*                D3 = INT((M2*306+5)/10);                       *
*            5.  DD = DAY OF THE MONTH:                         *
*                DD = D2 - D3;                                  *
*                                                               *
*****************************************************************
*
*
*        CALCULATE MONTH AND DAY OF THE MONTH.
CALCMMDD DS    0H                  ROUTINE ENTRY POINT AND LABEL
         STM   RLINK,RWORK5,SAVCLMD+00     SAVE REGISTERS
         LA    RENTRY,DTK306       LOAD FREQUENTLY USED CONSTANT
*
*
*        1.    CALCULATE D2 AND LEAVE ITS VALUE IN RWORK1.
*
         LR    RWORK1,RWORK2       COPY DDD VALUE
         SR    RWORK1,RWORK5       D2 = DDD - LAST DAY OF FEB;
         BP    *+L'*+2+2           BRANCH IF IN MARCH THRU DEC
         LR    RWORK1,RWORK2       COPY DDD VALUE
         AR    RWORK1,RENTRY       D2 = DDD + 306;
*
*
*        2.    CALCULATE M2 = INT((D2*10-5)/306)
*              AND LEAVE ITS VALUE IN RWORK3.
         LR    RWORK3,RWORK1       COPY D2 TO RWORK3
         M     RWORK2,DTF10        10*D2 IN RWORK3, RWORK2 SET TO ZERO
         S     RWORK3,DTF5         10*D2-5 IN RWORK3
         DR    RWORK2,RENTRY       GET M2  IN RWORK3
*
*
*        3.    CALCULATE MM = MONTH OF THE YEAR
*              AND LEAVE ITS VALUE IN RWORK0.
         LR    RWORK0,RWORK3       COPY M2
         S     RWORK0,DTF9         MM = M2 - 9 IN RWORK0
         BP    *+L'*+4             BRANCH IF 01 OR 02
         A     RWORK0,DTF12        OTHERWISE ADD 12 FOR MAR-DEC
*
*
*        4.    CALCULATE D3 = LAST DAY OF PREVIOUS MONTH
*              USING THE M2 VALUE STILL IN RWORK3,
*              AND END UP WITH D3 IN RWORK3.
         MR    RWORK2,RENTRY       306*M2 IN RWORK3, RWORK2 SET TO ZERO
         A     RWORK3,DTF5         306*M2 + 5 IN RWORK3
         D     RWORK2,DTF10        D3 = INT((306*M2+5)/10); IN RWORK3
*
*
*        5.    CALCULATE DD = DAY OF CURRENT MONTH = D2 - D3
*              USING THE D3 VALUE STILL IN RWORK3,
*              AND THE D2 VALUE STILL IN RWORK1,
*              AND END UP WITH DD IN RWORK1.
         SR    RWORK1,RWORK3       DD = D2 - D3;   IN RWORK1
*
*
*        RETURN RESULTS IN RWORK0 & RWORK1  TO THE CALLER.
         LM     RLINK,RENTRY,SAVCLMD+00              RELOAD REGS
         LM    RWORK2,RWORK5,SAVCLMD+08+04*RWORK2    RELOAD REGS
         BR    RLINK               RETURN TO CALLER
         EJECT  ,
*****************************************************************
*                                                               *
*                   C A L C Y Y Y Y                             *
*                                                               *
*        INTERNAL SUBROUTINE CALLED BY DATE CALCULATION         *
*        ROUTINES TO CALCULATE THE YEAR AND DAY OF THE YEAR     *
*        CORRESPONDING TO A FACTOR VALUE, DETERMINE             *
*        THE "DDD" VALUE FOR THE LAST DAY OF FEBRUARY,          *
*        AND DETERMINE THE NUMBER OF DAYS IN THAT YEAR.         *
*        THESE VALUES ARE USED IN CALCULATING THE MONTH         *
*        AND DAY OF THE MONTH VALUES CORRESPONDING TO THE       *
*        DAY OF THE YEAR.                                       *
*                                                               *
*        INPUT REGISTERS ARE:                                   *
*              RLINK     RETURN ADDRESS TO THE CALLER           *
*              RENTRY    NOT USED.                              *
*              RWORK0    NOT USED.                              *
*              RWORK1    NOT USED.                              *
*              RWORK2    NOT USED.                              *
*              RWORK3    NOT USED.                              *
*              RWORK4    BINARY FACTOR VALUE FOR WHICH THE      *
*                        DAY OF THE YEAR ("DDD") AND YEAR       *
*                        ("YYYY") ARE TO BE CALCULATED.  IT     *
*                        IS THE NUMBER OF DAYS BETWEEN THE      *
*                        SUPPLIED DATE AND DECEMBER 25, 1 BC    *
*                        (USING THE GREGORIAN CALENDAR WHICH    *
*                        IS ONLY VALID AFTER SEPTEMBER 11,      *
*                        1582).                                 *
*              RWORK5    NOT USED.                              *
*              RWORK6    NOT USED.                              *
*              RWORK7    NOT USED.                              *
*                                                               *
*        OUTPUT REGISTERS ARE:                                  *
*              RLINK     SAME AS ON INPUT                       *
*              RENTRY    UNCHANGED.                             *
*              RWORK0    UNCHANGED.                             *
*              RWORK1    UNCHANGED.                             *
*              RWORK2    DAY OF THE YEAR ("DDD") BINARY VALUE.  *
*              RWORK3    YEAR ("YYYY") BINARY VALUE.            *
*              RWORK4    UNCHANGED (STILL CONTAINS THE BINARY   *
*                        FACTOR VALUE).                         *
*              RWORK5    BINARY VALUE CORRESPONDING TO THE      *
*                        LAST DAY OF FEBRUARY OF YEAR "YYYY".   *
*                        IF YEAR "YYYY" IS A LEAP YEAR, THIS    *
*                        VALUE WILL BE 060, OTHERWISE IT WILL   *
*                        BE 059.                                *
*              RWORK6    BINARY VALUE CORRESPONDING TO THE      *
*                        NUMBER OF DAYS IN YEAR "YYYY".         *
*                        IF YEAR "YYYY" IS A LEAP YEAR, THIS    *
*                        VALUE WILL BE 366, OTHERWISE IT WILL   *
*                        BE 365.                                *
*              RWORK7    UNCHANGED.                             *
*                                                               *
*****************************************************************
*
*        CALCULATE FACTOR AND LEAP YEAR STARTING VALUES.
CALCYYYY DS    0H                  ROUTINE ENTRY POINT AND LABEL
         STM   RLINK,RWORK7,SAVCLYYY+00    SAVE REGISTERS
         LA    RLINK,DTK1          LOAD CONSTANT
*
*        BEGIN DEVELOPING THE "YYYY" AND LAST DAY OF FEBRUARY VALUES.
         LR    RWORK2,RWORK4       COPY FACTOR VALUE TO RWORK2
         S     RWORK2,DTFUDGE      REMOVE FUDGE ("C") FROM FACTOR
         SR    RWORK3,RWORK3       INITIALIZE YEAR VALUE TO ZERO
         LA    RWORK5,DTKLFEB      NON-LEAP YEAR LAST DAY OF FEB
         LA    RWORK6,DTKYEAR      NUMBER OF DAYS IN NON-LEAP YEAR
*
*        DETERMINE THE NUMBER OF FULL 400-YEAR BLOCKS (WHERE EACH
*        BLOCK OF 400 YEARS BEGINS WITH A YEAR DIVISIBLE BY 400,
*        LIKE 1600, 2000) PRECEDING THIS YEAR,
*        AND ADJUST YYYY ACCORDINGLY.
         AR    RWORK5,RLINK        FIRST YEAR IN 400-YEAR BLOCK
         AR    RWORK6,RLINK        IS A LEAP YEAR
         L     RENTRY,DTFYY400     # OF DAYS IN 400-YEAR GRP
         SR    RWORK0,RWORK0       CLEAR RWORK0
         LR    RWORK1,RWORK2       COPY RESIDUAL FACTOR VALUE
         DR    RWORK0,RENTRY       # OF 400-YEAR BLOCKS IN RWORK1,     X
                                   # OF DAYS INTO CURRENT BLK IN RWORK0
         LTR   RWORK0,RWORK0       TEST REMAINDER FOR ZERO
         BNZ   *+L'*+2+2           BRANCH IF REMAINDER NON-ZERO
         LR    RWORK0,RENTRY       COPY DIVISOR
         SR    RWORK1,RLINK        DECREMENT # OF 400-YEAR BLOCKS
         LR    RWORK2,RWORK0       SAVE NEW RESIDUAL FACTOR VALUE
         M     RWORK0,DTF400       MULTIPLY QUOTIENT IN RWORK1 BY      X
                                   NUMBER OF YEARS REPRESENTED
         AR    RWORK3,RWORK1       UPDATE YYYY VALUE
         CR    RWORK2,RWORK6       WITHIN YEAR NOW IN RWORK3??
         BNH   CALYYRTN            GO RETURN TO CALLER
         SR    RWORK2,RLINK        MAKE THE FIRST CENTURY LOOK LIKE    X
                                   THE OTHER THREE CENTURIES
*
*        DETERMINE THE NUMBER OF FULL 100-YEAR BLOCKS (WHERE EACH
*        BLOCK OF 100 YEARS BEGINS WITH A YEAR DIVISIBLE BY 100,
*        LIKE 1600, 1700) PRECEDING THIS YEAR WITHIN THE CURRENT
*        400-YEAR BLOCK,
*        AND ADJUST YYYY ACCORDINGLY.
         SR    RWORK5,RLINK        FIRST YEAR IN CENTURY
         SR    RWORK6,RLINK        IS NOT A LEAP YEAR
         L     RENTRY,DTFYY100     # OF DAYS IN 100-YEAR GRP
         SR    RWORK0,RWORK0       CLEAR RWORK0
         LR    RWORK1,RWORK2       COPY RESIDUAL FACTOR VALUE
         DR    RWORK0,RENTRY       # OF 100-YEAR BLOCKS IN RWORK1,     X
                                   # OF DAYS INTO CURRENT BLK IN RWORK0
         LTR   RWORK0,RWORK0       TEST REMAINDER FOR ZERO
         BNZ   *+L'*+2+2           BRANCH IF REMAINDER NON-ZERO
         LR    RWORK0,RENTRY       COPY DIVISOR
         SR    RWORK1,RLINK        DECREMENT # OF 100-YEAR BLOCKS
         LR    RWORK2,RWORK0       SAVE NEW RESIDUAL FACTOR VALUE
         M     RWORK0,DTF100       MULTIPLY QUOTIENT IN RWORK1 BY      X
                                   NUMBER OF YEARS REPRESENTED
         AR    RWORK3,RWORK1       UPDATE YYYY VALUE
         CR    RWORK2,RWORK6       WITHIN YEAR NOW IN RWORK3??
         BNH   CALYYRTN            GO RETURN TO CALLER IF YES
         AR    RWORK2,RLINK        ADJ FOR 100-YR NON-LEAP YR
*
*        DETERMINE THE NUMBER OF FULL 004-YEAR BLOCKS (WHERE EACH
*        BLOCK OF 004 YEARS BEGINS WITH A YEAR DIVISIBLE BY 004,
*        LIKE 1976, 1980) PRECEDING THIS YEAR WITHIN THE CURRENT
*        100-YEAR BLOCK,
*        AND ADJUST YYYY ACCORDINGLY.
         AR    RWORK5,RLINK        FIRST YEAR IN 004-YEAR BLOCK
         AR    RWORK6,RLINK        IS A LEAP YEAR
         L     RENTRY,DTFYY004     # OF DAYS IN 004-YEAR GRP
         SR    RWORK0,RWORK0       CLEAR RWORK0
         LR    RWORK1,RWORK2       COPY RESIDUAL FACTOR VALUE
         DR    RWORK0,RENTRY       # OF 004-YEAR BLOCKS IN RWORK1,     X
                                   # OF DAYS INTO CURRENT BLK IN RWORK0
         LTR   RWORK0,RWORK0       TEST REMAINDER FOR ZERO
         BNZ   *+L'*+2+2           BRANCH IF REMAINDER NON-ZERO
         LR    RWORK0,RENTRY       COPY DIVISOR
         SR    RWORK1,RLINK        DECREMENT QUOTIENT
         LR    RWORK2,RWORK0       SAVE NEW RESIDUAL FACTOR VALUE
         M     RWORK0,DTF4         MULTIPLY QUOTIENT IN RWORK1 BY      X
                                   NUMBER OF YEARS REPRESENTED
         AR    RWORK3,RWORK1       UPDATE YYYY VALUE
         CR    RWORK2,RWORK6       WITHIN YEAR NOW IN RWORK3?
         BNH   CALYYRTN            GO RETURN TO CALLER IF YES
         SR    RWORK2,RLINK        COMPENSATE FOR 004-YR LEAP YR
*
*        DETERMINE THE NUMBER OF YEARS PRECEEDING THIS YEAR
*        WITHIN THE CURRENT 004-YEAR BLOCK,
*        AND ADJUST YYYY ACCORDINGLY.
         SR    RWORK5,RLINK        FIRST YEAR IN 001-YEAR BLOCK
         SR    RWORK6,RLINK        IS NOT A LEAP YEAR
         L     RENTRY,DTFYY001     # OF DAYS IN 001-YEAR GRP
         SR    RWORK0,RWORK0       CLEAR RWORK0
         LR    RWORK1,RWORK2       COPY RESIDUAL FACTOR VALUE
         DR    RWORK0,RENTRY       # OF YEARS IN RWORK1,               X
                                   # OF DAYS INTO CURRENT BLK IN RWORK0
         LTR   RWORK0,RWORK0       TEST REMAINDER FOR ZERO
         BNZ   *+L'*+2+2           BRANCH IF REMAINDER NON-ZERO
         LR    RWORK0,RENTRY       COPY DIVISOR
         SR    RWORK1,RLINK        DECREMENT QUOTIENT
         LR    RWORK2,RWORK0       NEW RESIDUAL FACTOR VALUE IS THE    X
                                   FINAL "DDD" VALUE.
         AR    RWORK3,RWORK1       UPDATE YYYY VALUE
*
*
*        RETURN RESULTS IN RWORK2,RWORK3,RWORK5 & RWORK6 TO THE CALLER.
CALYYRTN DS    0H
         LM    RLINK,RWORK1,SAVCLYYY+00   RELOAD REGISTERS
         L     RWORK4,SAVCLYYY+08+04*RWORK4      RESTORE RWORK4
         L     RWORK7,SAVCLYYY+08+04*RWORK7      RESTORE RWORK7
         BR    RLINK               RETURN TO CALLER
         EJECT  ,
*****************************************************************
*                                                               *
*                   C A L C D D D                               *
*                                                               *
*        INTERNAL SUBROUTINE CALLED BY DATE CALCULATION         *
*        ROUTINES TO CALCULATE THE DAY OF THE YEAR,             *
*        FACTOR VALUE, LAST DAY OF FEBRUARY "DDD" VALUE,        *
*        AND NUMBER OF DAYS IN THE YEAR VALUE                   *
*        FROM MONTH, DAY, AND YEAR VALUES IN REGISTERS,         *
*        AND RETURN THE RESULTS TO THE CALLER IN REGISTERS.     *
*                                                               *
*        INPUT REGISTERS ARE:                                   *
*              RLINK     RETURN ADDRESS TO THE CALLER           *
*              RENTRY    NOT USED.                              *
*              RWORK0    MONTH OF THE YEAR BINARY VALUE 01-12.  *
*              RWORK1    DAY OF THE MONTH BINARY VALUE 01-31.   *
*              RWORK2    NOT USED.                              *
*              RWORK3    YEAR ("YYYY") BINARY VALUE.            *
*              RWORK4    NOT USED.                              *
*              RWORK5    NOT USED.                              *
*              RWORK6    NOT USED.                              *
*              RWORK7    NOT USED.                              *
*                                                               *
*        OUTPUT REGISTERS ARE:                                  *
*              RLINK     SAME AS ON INPUT                       *
*              RENTRY    UNCHANGED.                             *
*              RWORK0    MONTH OF THE YEAR BINARY VALUE 01-12.  *
*              RWORK1    DAY OF THE MONTH BINARY VALUE 01-31.   *
*              RWORK2    DAY OF THE YEAR ("DDD")                *
*                        BINARY VALUE 001-365(6).               *
*              RWORK3    UNCHANGED (STILL CONTAINS "YYYY").     *
*              RWORK4    BINARY FACTOR VALUE CORRESPONDING TO   *
*                        THE DAY ("DDD") VALUE IN RWORK2 AND    *
*                        YEAR ("YYYY") VALUE IN RWORK3.         *
*              RWORK5    BINARY VALUE CORRESPONDING TO THE      *
*                        LAST DAY OF FEBRUARY OF YEAR "YYYY".   *
*                        IF YEAR "YYYY" IS A LEAP YEAR, THIS    *
*                        VALUE WILL BE 060, OTHERWISE IT WILL   *
*                        BE 059.                                *
*              RWORK6    BINARY VALUE CORRESPONDING TO THE      *
*                        NUMBER OF DAYS IN YEAR "YYYY".         *
*                        IF YEAR "YYYY" IS A LEAP YEAR, THIS    *
*                        VALUE WILL BE 366, OTHERWISE IT WILL   *
*                        BE 365.                                *
*              RWORK7    UNCHANGED.                             *
*                                                               *
*        THE DAY OF THE YEAR IS CALCULATED FROM THE MONTH       *
*        AND DAY OF THE MONTH USING A SEQUENCE OF FORMULAE      *
*        AS FOLLOWS.....                                        *
*                                                               *
*            1.  THE "FACTOR" VALUE ASSOCIATED WITH A "DDD"     *
*                VALUE OF 000 FOR THE YEAR IS FIRST DETERMINED  *
*                BY CALLING ROUTINE "CALCFACT".  THIS ALSO      *
*                DETERMINES THE "DDD" VALUE FOR THE LAST DAY    *
*                OF FEBRUARY WHICH IS REQUIRED BY THIS          *
*                ROUTINE.                                       *
*                                                               *
*            2.  M2 = MONTH(MAR-FEB;MAR=00,FEB=11):             *
*                M2 = MM - 03;                                  *
*                IF M2 < 00                                     *
*                THEN                                           *
*                    M2 = M2 + 12;                              *
*                                                               *
*            3.  D3 = LAST DAY OF PREVIOUS MONTH                *
*                     IN A MARCH-FEB YEAR:                      *
*                D3 = INT((M2*306+5)/10);                       *
*                                                               *
*            4.  D2 = DAY OF THE YEAR RELATIVE TO MARCH 1:      *
*                D2 = D3 + DD;                                  *
*                                                               *
*            5.  CALCULATE DDD = DAY OF THE YEAR RELATIVE       *
*                TO JAN 1:                                      *
*                IF D2 > 306                                    *
*                THEN                                           *
*                    DDD = D2 - 306;                            *
*                ELSE                                           *
*                    DDD = D2 + LAST DAY OF FEB;                *
*                                                               *
*            6.  CALCULATE THE FINAL FACTOR VALUE BY ADDING     *
*                DDD TO THE FACTOR VALUE FROM STEP # 1.         *
*                                                               *
*****************************************************************
*
*
*        CALCULATE DAY OF THE YEAR.
CALCDDD  DS    0H                  ROUTINE ENTRY POINT AND LABEL
         STM   RLINK,RWORK7,SAVCLDDD+00    SAVE REGISTERS
         LA    RENTRY,DTK306       LOAD FREQUENTLY USED CONSTANT
*
*
*        1.    CALCULATE THE FACTOR VALUE ASSOCIATED WITH A DDD VALUE
*              OF 000, AND DETERMINE THE LAST DAY OF FEBRUARY VALUE.
*
*
         SR    RWORK2,RWORK2       DDD = 000;
         BAS   RLINK,CALCFACT      GET FACTOR VALUE
*
*
*        2.    CALCULATE M2 = MONTH RELATIVE TO MARCH(MAR=00;FEB=11)
*              FROM MM, AND LEAVE ITS VALUE IN RWORK3.
         LR    RWORK3,RWORK0       M2 = MM
         S     RWORK3,DTF3                 - 03;
         BNM   *+L'*+4             IF M2 < 00
         A     RWORK3,DTF12           THEN M2 = M2 + 12;
*
*
*        3.    CALCULATE D3 = LAST DAY OF PREVIOUS MONTH
*              USING THE M2 VALUE STILL IN RWORK3,
*              AND END UP WITH D3 IN RWORK3.
         MR    RWORK2,RENTRY       306*M2 IN RWORK3, RWORK2 SET TO ZERO
         A     RWORK3,DTF5         306*M2 + 5 IN RWORK3
         D     RWORK2,DTF10        D3 = INT((306*M2+5)/10); IN RWORK3
*
*
*        4.    CALCULATE D2 = DAY OF THE YEAR RELATIVE TO MARCH 1
*              USING THE D3 VALUE STILL IN RWORK3
*              AND THE DD VALUE STILL IN RWORK1,
*              AND END UP WITH D2 IN RWORK3.
*
         AR    RWORK3,RWORK1       D2 = D3 + DD;
*
*
*        5.    CALCULATE DDD = DAY OF THE YEAR RELATIVE TO JAN 1
*              FROM THE D2 VALUE IN RWORK3,
*              AND END UP WITH DDD IN RWORK2.
*
         LR    RWORK2,RWORK3       IF
         SR    RWORK2,RENTRY          D2 > 306
         BP    *+L'*+2+2              THEN DDD = D2 - 306;
         LR    RWORK2,RWORK3          ELSE
         AR    RWORK2,RWORK5               DDD = D2 + LAST DAY OF FEB;
*
*
*        6.    CALCULATE THE FINAL FACTOR VALUE BY ADDING DDD
*              TO THE VALUE IN RWORK4.
*
         AR    RWORK4,RWORK2       COMPUTE FINAL FACTOR VALUE
*
*
*        RETURN RESULTS IN RWORK2, RWORK4, RWORK5, & RWORK6.
         LM     RLINK,RWORK1,SAVCLDDD+00             RELOAD REGS
         LM    RWORK3,RWORK3,SAVCLDDD+08+04*RWORK3   RELOAD REGS
         LM    RWORK7,RWORK7,SAVCLDDD+08+04*RWORK7   RELOAD REGS
         BR    RLINK               RETURN TO CALLER
         EJECT  ,
*****************************************************************
*                                                               *
*                   C A L C D O W                               *
*                                                               *
*        INTERNAL SUBROUTINE CALLED BY DATE CALCULATION         *
*        ROUTINES TO CALCULATE THE DAY OF THE WEEK FROM THE     *
*        INTERNAL DATE FACTOR VALUE, AND RETURN THE RESULT      *
*        AS A BINARY VALUE IN THE RANGE "0" - "6" TO            *
*        THE CALLER.                                            *
*                                                               *
*        INPUT REGISTERS ARE:                                   *
*              RLINK     RETURN ADDRESS TO THE CALLER           *
*              RENTRY    NOT USED.                              *
*              RWORK0    NOT USED.                              *
*              RWORK1    NOT USED.                              *
*              RWORK2    NOT USED.                              *
*              RWORK3    NOT USED.                              *
*              RWORK4    THE BINARY INTERNAL DATE "FACTOR"      *
*                        VALUE.                                 *
*              RWORK5    NOT USED.                              *
*              RWORK6    NOT USED.                              *
*              RWORK7    NOT USED.                              *
*                                                               *
*        OUTPUT REGISTERS ARE:                                  *
*              RLINK     SAME AS ON INPUT                       *
*              RENTRY    DAY OF THE WEEK BINARY VALUE           *
*                        IN THE RANGE 0(SUNDAY)                 *
*                        THROUGH 6(SATURDAY),                   *
*              RWORK0    UNCHANGED.                             *
*              RWORK1    UNCHANGED.                             *
*              RWORK2    UNCHANGED.                             *
*              RWORK3    UNCHANGED.                             *
*              RWORK4    UNCHANGED (STILL CONTAINS FACTOR).     *
*              RWORK5    UNCHANGED.                             *
*              RWORK6    UNCHANGED.                             *
*              RWORK7    UNCHANGED.                             *
*                                                               *
*        THE DAY OF THE WEEK IS CALCULATED BY DIVIDING THE      *
*        "FACTOR" VALUE BY 7 AND KEEPING THE REMAINDER.  THE    *
*        REMAINDER IS THE DAY OF THE WEEK.                      *
*                                                               *
*****************************************************************
*
*        CALCULATE DAY-OF-WEEK
CALCDOW  DS    0H                  ROUTINE ENTRY POINT AND LABEL
         STM   RLINK,RWORK1,SAVCLDOW+00    SAVE REGISTERS
*
*        CALCULATE THE DAY OF THE WEEK FROM THE FACTOR VALUE
*        AND COPY THE RESULT TO RENTRY.
         SR    RWORK0,RWORK0       CLEAR RWORK0
         LR    RWORK1,RWORK4       COPY "FACTOR" VALUE TO RWORK1
         D     RWORK0,DTF7         REMAINDER = DAY-OF-WEEK IN RWORK0
         LR    RENTRY,RWORK0       COPY RESULT TO RENTRY
*
*        RETURN RESULT TO THE CALLER.
         L     RLINK,SAVCLDOW+00   RELOAD RETURN REGISTER VALUE
         LM    RWORK0,RWORK1,SAVCLDOW+08+04*RWORK0     REM REGS
         BR    RLINK               RETURN TO CALLER
         EJECT  ,
*****************************************************************
*                                                               *
*                   C A L C Q T R                               *
*                                                               *
*        INTERNAL SUBROUTINE CALLED BY DATE CALCULATION         *
*        ROUTINES TO CALCULATE THE QUARTER OF THE YEAR          *
*        CORRESPONDING TO A GIVEN MONTH, AND RETURN THE RESULT  *
*        AS A BINARY VALUE IN THE RANGE "1" - "4" TO            *
*        THE CALLER.                                            *
*                                                               *
*        INPUT REGISTERS ARE:                                   *
*              RLINK     RETURN ADDRESS TO THE CALLER           *
*              RENTRY    NOT USED.                              *
*              RWORK0    MONTH OF THE YEAR BINARY VALUE 01-12.  *
*              RWORK1    NOT USED.                              *
*              RWORK2    NOT USED.                              *
*              RWORK3    NOT USED.                              *
*              RWORK4    NOT USED.                              *
*              RWORK5    NOT USED.                              *
*              RWORK6    NOT USED.                              *
*              RWORK7    NOT USED.                              *
*                                                               *
*        OUTPUT REGISTERS ARE:                                  *
*              RLINK     SAME AS ON INPUT                       *
*              RENTRY    DAY OF THE WEEK BINARY VALUE           *
*                        IN THE RANGE 0(SUNDAY)                 *
*                        THROUGH 6(SATURDAY),                   *
*              RWORK0    UNCHANGED (STILL CONTAINS MONTH VALUE).*
*              RWORK1    UNCHANGED.                             *
*              RWORK2    UNCHANGED.                             *
*              RWORK3    UNCHANGED.                             *
*              RWORK4    UNCHANGED.                             *
*              RWORK5    UNCHANGED.                             *
*              RWORK6    UNCHANGED.                             *
*              RWORK7    QUARTER OF THE YEAR BINARY VALUE 1-4.  *
*                                                               *
*****************************************************************
*
*        CALCULATE QUARTER OF THE YEAR
CALCQTR  DS    0H                  ROUTINE ENTRY POINT AND LABEL
         STM   RLINK,RWORK1,SAVCLQTR+00    SAVE REGISTERS
*
*        CALCULATE THE QUARTER OF THE YEAR FROM THE MONTH VALUE
*        AND COPY THE RESULT TO RWORK7.
         SRDL  RWORK0,DTK32        SHIFT MONTH TO RWORK1, CLEAR RWORK0
         BCTR  RWORK1,0            SET DIVIDEND = MM - 1;
         D     RWORK0,DTF4         QUOTIENT = QUARTER - 1;
         A     RWORK1,DTF1         ADJUST TO RANGE 1-4;
         LR    RWORK7,RWORK1       COPY RESULT TO RWORK7
*
*        RETURN RESULT TO THE CALLER.
         LM    RLINK,RWORK1,SAVCLQTR+00   RELOAD REGISTERS
         BR    RLINK               RETURN TO CALLER
         EJECT  ,
*****************************************************************
*                                                               *
*                   C V B J U L                                 *
*                                                               *
*        INTERNAL SUBROUTINE CALLED BY DATE PROCESSING          *
*        ROUTINES TO CONVERT A PACKED DECIMAL DATE IN THE       *
*        FORMS "00YYDDDC" OR "YYYYDDDC" TO BINARY AND           *
*        INITIALIZE REGISTERS FOR PROCESSING BY OTHER INTERNAL  *
*        DATE PROCESSING SUBROUTINES.                           *
*                                                               *
*        INPUT REGISTERS ARE:                                   *
*              RLINK     RETURN ADDRESS TO THE CALLER           *
*              RENTRY    CONTAINS THE JULIAN DATE IN EITHER     *
*                        THE "00YYDDDC" OR "YYYYDDDC" FORM.     *
*                        DATES HAVING THE FORM "00YYDDDC"       *
*                        ARE RETURNED IN REGISTER 1 BY THE      *
*                        SYSTEM "TIME" MACRO.                   *
*              RWORK0    NOT USED.                              *
*              RWORK1    NOT USED.                              *
*              RWORK2    NOT USED.                              *
*              RWORK3    NOT USED.                              *
*              RWORK4    NOT USED.                              *
*              RWORK5    NOT USED.                              *
*              RWORK6    NOT USED.                              *
*                                                               *
*        OUTPUT REGISTERS ARE:                                  *
*              RLINK     UNCHANGED.                             *
*              RENTRY    UNCHANGED (STILL CONTAINS PACKED       *
*                        DECIMAL JULIAN DATE).                  *
*              RWORK0    UNCHANGED.                             *
*              RWORK1    UNCHANGED.                             *
*              RWORK2    DAY OF THE YEAR ("DDD")                *
*                        BINARY VALUE 001-365(6).               *
*              RWORK3    YEAR ("YYYY") BINARY VALUE.            *
*              RWORK4    UNCHANGED.                             *
*              RWORK5    UNCHANGED.                             *
*              RWORK6    UNCHANGED.                             *
*                                                               *
*****************************************************************
*
*        CONVERT PACKED DECIMAL JULIAN DATE TO BINARY.
CVBJUL   DS    0H                  ROUTINE ENTRY POINT AND LABEL
         SR    RWORK2,RWORK2       CLEAR RWORK2
         LR    RWORK3,RENTRY       COPY PACKED DECIMAL DATE TO RWORK3
         STM   RWORK2,RWORK3,DATPACK    STORE IN CVB/CVD WK AREA
         CVB   RWORK3,DATPACK      CONVERT DATE TO BINARY
         D     RWORK2,DTF1000      GET "DDD" IN RWORK2,                X
                                   "YY" OR "YYYY" IN RWORK3
         C     RWORK3,DTF100       "YY" (00-99) ?
         BNL   *+L'*+4             BRANCH IF "YYYY"
         A     RWORK3,DTFY1900     CONVERT "YY" TO "YYYY"
         BR    RLINK               RETURN TO CALLER
         EJECT  ,
*****************************************************************
*                                                               *
*                   C V B M D Y                                 *
*                                                               *
*        INTERNAL SUBROUTINE CALLED BY DATE PROCESSING          *
*        ROUTINES TO CONVERT A PACKED DECIMAL DATE IN THE       *
*        FORMS "0MMDDYYC" TO BINARY AND INITIALIZE REGISTERS    *
*        FOR PROCESSING BY OTHER INTERNAL DATE PROCESSING       *
*        SUBROUTINES.                                           *
*                                                               *
*        INPUT REGISTERS ARE:                                   *
*              RLINK     RETURN ADDRESS TO THE CALLER           *
*              RENTRY    CONTAINS THE GREGORIAN DATE EXPRESSED  *
*                        IN PACKED DECIMAL "0MMDDYYC" FORM.     *
*              RWORK0    NOT USED.                              *
*              RWORK1    NOT USED.                              *
*              RWORK2    NOT USED.                              *
*              RWORK3    NOT USED.                              *
*              RWORK4    NOT USED.                              *
*              RWORK5    NOT USED.                              *
*              RWORK6    NOT USED.                              *
*                                                               *
*        OUTPUT REGISTERS ARE:                                  *
*              RLINK     UNCHANGED.                             *
*              RENTRY    UNCHANGED (STILL CONTAINS PACKED       *
*                        DECIMAL "0MMDDYYC" DATE).              *
*              RWORK0    MONTH OF THE YEAR BINARY VALUE 01-12.  *
*              RWORK1    DAY OF THE MONTH BINARY VALUE  01-31.  *
*              RWORK2    UNCHANGED.                             *
*              RWORK3    YEAR ("YYYY") BINARY VALUE.            *
*              RWORK4    UNCHANGED.                             *
*              RWORK5    UNCHANGED.                             *
*              RWORK6    UNCHANGED.                             *
*                                                               *
*****************************************************************
*
*        CONVERT PACKED DECIMAL JULIAN DATE TO BINARY.
CVBMDY   DS    0H                  ROUTINE ENTRY POINT AND LABEL
         SR    RWORK0,RWORK0       CLEAR RWORK0
         LR    RWORK1,RENTRY       COPY PACKED DECIMAL DATE TO RWORK1
         STM   RWORK0,RWORK1,DATPACK    STORE IN CVB/CVD WK AREA
         CVB   RWORK1,DATPACK      CONVERT DATE TO BINARY
         D     RWORK0,DTF100       GET "YY" IN RWORK0, "MMDD" IN RWORK1
         LR    RWORK3,RWORK0       COPY "YY" TO RWORK3
         SR    RWORK0,RWORK0       CLEAR RWORK0
         D     RWORK0,DTF100       GET "DD" IN RWORK0, "MM" IN RWORK1
         XR    RWORK1,RWORK0       SWAP CONTENTS
         XR    RWORK0,RWORK1       OF RWORK0 & RWORK1 TO GET
         XR    RWORK1,RWORK0       "MM" IN RWORK0, "DD" IN RWORK1
         A     RWORK3,DTFY1900     CONVERT "YY" TO "YYYY"
         BR    RLINK               RETURN TO CALLER
         EJECT  ,
*****************************************************************
*                                                               *
*                   C V B Y M D                                 *
*                                                               *
*        INTERNAL SUBROUTINE CALLED BY DATE PROCESSING          *
*        ROUTINES TO CONVERT A PACKED DECIMAL DATE IN THE       *
*        FORMS "0YYMMDDC" TO BINARY AND INITIALIZE REGISTERS    *
*        FOR PROCESSING BY OTHER INTERNAL DATE PROCESSING       *
*        SUBROUTINES.                                           *
*                                                               *
*        INPUT REGISTERS ARE:                                   *
*              RLINK     RETURN ADDRESS TO THE CALLER           *
*              RENTRY    CONTAINS THE GREGORIAN DATE EXPRESSED  *
*                        IN PACKED DECIMAL "0YYMMDDC" FORM.     *
*              RWORK0    NOT USED.                              *
*              RWORK1    NOT USED.                              *
*              RWORK2    NOT USED.                              *
*              RWORK3    NOT USED.                              *
*              RWORK4    NOT USED.                              *
*              RWORK5    NOT USED.                              *
*              RWORK6    NOT USED.                              *
*                                                               *
*        OUTPUT REGISTERS ARE:                                  *
*              RLINK     UNCHANGED.                             *
*              RENTRY    UNCHANGED (STILL CONTAINS PACKED       *
*                        DECIMAL "0YYMMDDC" DATE).              *
*              RWORK0    MONTH OF THE YEAR BINARY VALUE 01-12.  *
*              RWORK1    DAY OF THE MONTH BINARY VALUE  01-31.  *
*              RWORK2    UNCHANGED.                             *
*              RWORK3    YEAR ("YYYY") BINARY VALUE.            *
*              RWORK4    UNCHANGED.                             *
*              RWORK5    UNCHANGED.                             *
*              RWORK6    UNCHANGED.                             *
*                                                               *
*****************************************************************
*
*        CONVERT PACKED DECIMAL GREGORIAN DATE TO BINARY.
CVBYMD   DS    0H                  ROUTINE ENTRY POINT AND LABEL
         SR    RWORK0,RWORK0       CLEAR RWORK0
         LR    RWORK1,RENTRY       COPY PACKED DECIMAL DATE TO RWORK1
         STM   RWORK0,RWORK1,DATPACK    STORE IN CVB/CVD WK AREA
         CVB   RWORK1,DATPACK      CONVERT DATE TO BINARY
         D     RWORK0,DTF100       GET "DD" IN RWORK0, "YYMM" IN RWORK1
         LR    RWORK3,RWORK0       COPY "DD" TO RWORK3
         SR    RWORK0,RWORK0       CLEAR RWORK0
         D     RWORK0,DTF100       GET "MM" IN RWORK0, "YY" IN RWORK1
         XR    RWORK1,RWORK3       SWAP CONTENTS
         XR    RWORK3,RWORK1       OF RWORK1 & RWORK3 TO GET
         XR    RWORK1,RWORK3       "DD" IN RWORK1, "YY" IN RWORK3
         A     RWORK3,DTFY1900     CONVERT "YY" TO "YYYY"
         BR    RLINK               RETURN TO CALLER
         EJECT  ,
*****************************************************************
*                                                               *
*                   C V D D A T E                               *
*                                                               *
*        INTERNAL SUBROUTINE CALLED BY DATE PROCESSING          *
*        ROUTINES AS A WRAPUP ROUTINE TO GET THE DAY OF         *
*        THE WEEK BINARY VALUE IN REGISTER RENTRY, CONVERT      *
*        THE DATE VALUE IN REGISTERS TO ITS PACKED DECIMAL      *
*        EQUIVALENTS, AND STORE THE RESULTS IN THE WORK AREA    *
*        FOR GENERAL ACCESS.                                    *
*                                                               *
*        INPUT REGISTERS ARE:                                   *
*              RLINK     RETURN ADDRESS TO THE CALLER           *
*              RENTRY    NOT USED.                              *
*              RWORK0    MONTH OF THE YEAR BINARY VALUE 01-12.  *
*              RWORK1    DAY OF THE MONTH BINARY VALUE  01-31.  *
*              RWORK2    DAY OF THE YEAR ("DDD")                *
*                        BINARY VALUE 001-365(6).               *
*              RWORK3    YEAR ("YYYY") BINARY VALUE.            *
*              RWORK4    BINARY FACTOR VALUE CORRESPONDING TO   *
*                        THE DAY ("DDD") IN RWORK2 AND          *
*                        YEAR ("YYYY") IN RWORK3.               *
*              RWORK5    BINARY VALUE CORRESPONDING TO THE      *
*                        LAST DAY OF FEBRUARY OF YEAR "YYYY".   *
*                        IF YEAR "YYYY" IS A LEAP YEAR, THIS    *
*                        VALUE WILL BE 060, OTHERWISE IT WILL   *
*                        BE 059.                                *
*              RWORK6    BINARY VALUE CORRESPONDING TO THE      *
*                        NUMBER OF DAYS IN YEAR "YYYY".         *
*                        IF YEAR "YYYY" IS A LEAP YEAR, THIS    *
*                        VALUE WILL BE 366, OTHERWISE IT WILL   *
*                        BE 365.                                *
*              RWORK7    NOT USED.                              *
*                                                               *
*        OUTPUT REGISTERS ARE:                                  *
*              RLINK     UNCHANGED.                             *
*              RENTRY    DAY OF THE WEEK BINARY VALUE 0-6.      *
*              RWORK0    UNCHANGED (STILL CONTAINS "MM").       *
*              RWORK1    UNCHANGED (STILL CONTAINS "DD").       *
*              RWORK2    UNCHANGED (STILL CONTAINS "DDD").      *
*              RWORK3    UNCHANGED (STILL CONTAINS "YYYY").     *
*              RWORK4    UNCHANGED (STILL CONTAINS FACTOR).     *
*              RWORK5    UNCHANGED (STILL CONTAINS LFEB VALUE). *
*              RWORK6    UNCHANGED (STILL CONTAINS #DDD VALUE). *
*              RWORK7    QUARTER OF THE YEAR BINARY VALUE 1-4.  *
*                                                               *
*****************************************************************
*
*        CONVERT BINARY DATE VALUE IN REGISTERS TO ITS
*        PACKED DECIMAL EQUIVALENTS.
CVDDATE  DS    0H                  ROUTINE ENTRY POINT AND LABEL
         STM   RLINK,RWORK7,SAVCVDDT+00    SAVE REGISTERS
*
*        GET THE DAY OF THE WEEK AND QUARTER VALUES.
         BAS   RLINK,CALCDOW       GET DAY OF THE WEEK VALUE IN RENTRY
         BAS   RLINK,CALCQTR       GET QUARTER               IN RWORK7
         STM   RENTRY,RWORK7,DATDOW    SAVE BINARY DATE VALUES IN W/A
*
*        DEVELOP "0YYMMDDC" DATE VALUE.
         LR    RENTRY,RWORK3                    COPY "YYYY"
         S     RENTRY,DTFY1900                  CONVERT "YYYY" TO "YY"
         MH    RENTRY,DTH100      (YY*100
         AR    RENTRY,RWORK0       + MM)
         MH    RENTRY,DTH100       *100
         AR    RENTRY,RWORK1       + DD
         CVD   RWORK0,DATPACK      CONVERT BINARY "YYMMDD" TO DECIMAL
         MVC   DATYMD,DATPACK+L'DATPACK-L'DATYMD           COPY VALUE
*
*        DEVELOP "0MMDDYYC" DATE VALUE.
         MH    RWORK0,DTH100      (MM*100
         AR    RWORK0,RWORK1       + DD)
         MH    RWORK0,DTH100       *100
         LR    RWORK1,RWORK3                    COPY "YYYY"
         S     RWORK1,DTFY1900                  CONVERT "YYYY" TO "YY"
         AR    RWORK0,RWORK1       + YY
         CVD   RWORK0,DATPACK      CONVERT BINARY "MMDDYY" TO DECIMAL
         MVC   DATMDY,DATPACK+L'DATPACK-L'DATMDY           COPY VALUE
*
*        DEVELOP "00YYDDDC" DATE VALUE.
         MH    RWORK1,DTH1000      YY*1000
         AR    RWORK1,RWORK2       + DDD
         CVD   RWORK1,DATPACK      CONVERT BINARY "YYDDD" TO DECIMAL
         MVC   DATYYDDD,DATPACK+L'DATPACK-L'DATYYDDD      COPY VALUE
*
*        DEVELOP "YYYYDDDC" DATE VALUE.
         MH    RWORK3,DTH1000      YYYY*1000
         AR    RWORK3,RWORK2       + DDD
         CVD   RWORK3,DATPACK      CONVERT BINARY "YYYYDDD" TO DECIMAL
         MVC   DATJUL,DATPACK+L'DATPACK-L'DATJUL            COPY VALUE
*
*        RESTORE REGISTERS, AND RETURN TO THE CALLER.
         LM    RLINK,RLINK,SAVCVDDT+00              RESTORE REGISTERS
         LM    RENTRY,RWORK7,DATDOW                 RESTORE REGISTERS
         BR    RLINK               RETURN TO CALLER
         TITLE 'PAGEADD - DATE CALCULATION SUBROUTINE CONSTANTS'
*****************************************************************
*                                                               *
*        DEFINE THE EQUATES AND CONSTANTS USED IN COMMON        *
*        BY THE DATE CALCULATION ROUTINES.                      *
*                                                               *
*****************************************************************
DTKYEAR  EQU   365            EQUATE - NUMBER OF DAYS IN A NORMAL YEAR
DTKLFEB  EQU   031+028        EQUATE - DDD LAST DAY OF FEB:NORMAL YR
DTKFUDGE EQU   5              EQUATE - FUDGE FOR FACTOR
DTK1000  EQU   1000           EQUATE - 1000
DTK400   EQU   400            EQUATE - 400
DTK306   EQU   306            EQUATE - 306
DTK100   EQU   100            EQUATE - 100
DTK32    EQU   32             EQUATE -  32
DTK12    EQU   12             EQUATE -  12
DTK10    EQU   10             EQUATE -  10
DTK4     EQU   4              EQUATE -   4
DTK1     EQU   1              EQUATE -   1
DTFY1900 DC    A(1900)        BASE FOR MAKING YY INTO YYYY
DTFUDGE  DC    A(DTKFUDGE)    FUDGE USED W/ FACTOR TO MAKE DOW         X
                              CALCULATION YIELD RESULT IN RANGE 0-6
DTF1000  DC    A(1000)        CONSTANT - 1000
DTH1000  EQU   DTF1000+L'DTF1000-2,2,C'H'
DTF400   DC    A(400)         CONSTANT - 400
DTF306   DC    A(306)         CONSTANT - 306
DTF100   DC    A(100)         CONSTANT - 100
DTH100   EQU   DTF100+L'DTF100-2,2,C'H'
DTF12    DC    A(12)          CONSTANT -  12
DTF10    DC    A(10)          CONSTANT -  10
DTF9     DC    A(9)           CONSTANT -   9
DTF7     DC    A(7)           CONSTANT -   7
DTF5     DC    A(5)           CONSTANT -   5
DTF4     DC    A(4)           CONSTANT -   4
DTF3     DC    A(3)           CONSTANT -   4
DTF1     DC    A(1)           CONSTANT -   1
         SPACE 5
*
*        DEFINE THE CONSTANTS RELATING FACTOR VALUES TO THE
*        NUMBER OF DAYS IN VARIOUS PERIODS OF YEARS.
DTFYY400 DC    A((400*DTKYEAR)+(400/4)-(400/100)+(400/400))
DTFYY100 DC    A((100*DTKYEAR)+(100/4)-(100/100))
DTFYY004 DC    A((004*DTKYEAR)+(004/4))
DTFYY001 DC    A((001*DTKYEAR))
         TITLE 'PAGEADD - MESSAGE AND COMMAND SKELETONS'
WTOMSG1  WTO   'IEFPGD01 PAGEADD XXXXXXXX DD COULD NOT BE OPENED',     X
               DESC=(6),ROUTCDE=(2,11),                                X
               MF=L
WTOMSG1Z EQU   *-WTOMSG1           SIZE OF MESSAGE SKELETON
         SPACE 5
WTOMSG2  WTO   'IEFPGD02 PAGEADD IS NOT APF AUTHORIZED AND OPERATOR COMX
               MANDS CANNOT BE ISSUED',                                X
               DESC=(6),ROUTCDE=(2,11),                                X
               MF=L
WTOMSG2Z EQU   *-WTOMSG2           SIZE OF MESSAGE SKELETON
         EJECT  ,
WTOMSG3  WTO   'IEFPGD03 COMMANDS NOT EXECUTED - SMF ID=???? WAS NOT INX
               CLUDED IN THE SID=  LIST',                              X
               DESC=(6),ROUTCDE=(2,11),                                X
               MF=L
WTOMSG3Z EQU   *-WTOMSG3           SIZE OF MESSAGE SKELETON
         SPACE 3
WTOMSG4  WTO   'IEFPGD04 COMMANDS NOT EXECUTED - XEQ DATE=YY.DDD (MM/DDX
               /YY) NOT INCLUDED IN THE  DOY=/MDY=  LIST',             X
               DESC=(6),ROUTCDE=(2,11),                                X
               MF=L
WTOMSG4Z EQU   *-WTOMSG4           SIZE OF MESSAGE SKELETON
         SPACE 3
WTOMSG5  WTO   'IEFPGD05 COMMANDS NOT EXECUTED - XEQ DATE=YY.DDD (MM/DDX
               /YY) DOW=??? DAY-OF-WEEK NOT SPECIFIED ON DOW= ',       X
               DESC=(6),ROUTCDE=(2,11),                                X
               MF=L
WTOMSG5Z EQU   *-WTOMSG5           SIZE OF MESSAGE SKELETON
         EJECT  ,
WTOMSG7  WTO   'IEFPGD07 COMMANDS NOT EXECUTED - XEQ TIME=HH:MM:SS IS EX
               ARLIER THAN HH:MM:SS',                                  X
               DESC=(6),ROUTCDE=(2,11),                                X
               MF=L
WTOMSG7Z EQU   *-WTOMSG7           SIZE OF MESSAGE SKELETON
         SPACE 5
WTOMSG8  WTO   'IEFPGD08 COMMANDS NOT EXECUTED - XEQ TIME=HH:MM:SS IS LX
               ATER THAN HH:MM:SS',                                    X
               DESC=(6),ROUTCDE=(2,11),                                X
               MF=L
WTOMSG8Z EQU   *-WTOMSG8           SIZE OF MESSAGE SKELETON
         SPACE 5
WTOMSG9  WTO   'IEFPGD09 COMMANDS NOT EXECUTED - XEQ TIME=HH:MM:SS IS LX
               ATER THAN HH:MM:SS AND EARLIER THAN HH:MM:SS',          X
               DESC=(6),ROUTCDE=(2,11),                                X
               MF=L
WTOMSG9Z EQU   *-WTOMSG9           SIZE OF MESSAGE SKELETON
         EJECT  ,
WTOMSGA  WTO   'IEFPGD10 COMMANDS NOT EXECUTED - THE "CANCEL" OPTION WAX
               S SPECIFIED',                                           X
               DESC=(6),ROUTCDE=(2,11),                                X
               MF=L
WTOMSGAZ EQU   *-WTOMSGA           SIZE OF MESSAGE SKELETON
         EJECT  ,
WTOMSGB  WTO   'IEFPGD11 PAGEADD DELAY=HH:MM:SS INTERVAL STARTED TIME=HX
               H:MM:SS',                                               X
               DESC=(6),ROUTCDE=(2,11),                                X
               MF=L
WTOMSGBZ EQU   *-WTOMSGB           SIZE OF MESSAGE SKELETON
         SPACE 5
WTOMSGC  WTO   'IEFPGD12 PAGEADD DELAY=HH:MM:SS INTERVAL ENDED TIME=HH:X
               MM:SS',                                                 X
               DESC=(6),ROUTCDE=(2,11),                                X
               MF=L
WTOMSGCZ EQU   *-WTOMSGC           SIZE OF MESSAGE SKELETON
         SPACE 5
WTOMSGJ  WTOR  'IEFPGD19 OPERATOR PROMPT REQUESTED: ENTER ADDITIONAL PAX
               RAMETERS, "CANCEL", OR "GO"',                           X
               *-*,                REPLY ADDRESS                       X
               *-*,                REPLY LENGTH                        X
               *-*,                ECB ADDRESS                         X
               ROUTCDE=(2,11),                                         X
               MF=L
WTOMSGJZ EQU   *-WTOMSGJ           SIZE OF MESSAGE SKELETON
         EJECT  ,
WTOMSGL  WTO   'IEFPGD21 PAGEADD RECEIVED NO OPERATOR COMMANDS TO PROCEX
               SS',                                                    X
               DESC=(6),ROUTCDE=(2,11),                                X
               MF=L
WTOMSGLZ EQU   *-WTOMSGL           SIZE OF MESSAGE SKELETON
         SPACE 4
WTOMSGT  WTO   'IEFPGD29 PAGEADD COMMAND TABLE CAPACITY EXCEEDED - REASX
               SEMBLE PROGRAM',                                        X
               DESC=(6),ROUTCDE=(2,11),                                X
               MF=L
WTOMSGTZ EQU   *-WTOMSGT           SIZE OF MESSAGE SKELETON
         EJECT ,
WTOMSGV  WTO   'IEFPGD31 PAGEADD PROGRAM RUNNING IN TEST MODE',        X
               DESC=(6),ROUTCDE=(2,11),                                X
               MF=L
WTOMSGVZ EQU   *-WTOMSGV           SIZE OF MESSAGE SKELETON
         SPACE 4
WTOMSGW  WTO   'IEFPGD32 DATECALC VALUES: DOW=XX, MM=XX, DD=XX, DDD=XXXX
               , YYYY=XXXX, FACTOR=XXXXXXXX',                          X
               DESC=(6),ROUTCDE=(2,11),                                X
               MF=L
WTOMSGWZ EQU   *-WTOMSGW           SIZE OF MESSAGE SKELETON
         EJECT  ,
WTOMSGY  WTOR  'IEFPGD34 PAGEADD PROGRAM PAUSE REQUESTED - TO CONTINUE,X
                REPLY "GO"',                                           X
               *-*,                REPLY ADDRESS                       X
               *-*,                REPLY LENGTH                        X
               *-*,                ECB ADDRESS                         X
               ROUTCDE=(2,11),                                         X
               MF=L
WTOMSGYZ EQU   *-WTOMSGY           SIZE OF MESSAGE SKELETON
         SPACE 4
WTOMSGZ  WTO   'IEFPGD35 PAUSE REPLY INVALID',                         X
               DESC=(6),ROUTCDE=(2,11),                                X
               MF=L
WTOMSGZZ EQU   *-WTOMSGZ           SIZE OF MESSAGE SKELETON
         EJECT ,
CMDMODEL WTO   '........10........20........30........40........50.....X
               ...60........70........80',                             X
               DESC=(4),ROUTCDE=(2,11),                                X
               MF=L
CMDMODLZ EQU   *-CMDMODEL          SIZE OF COMMAND SKELETON
         TITLE 'PAGEADD - MODULE  CONSTANTS'
WORKSIZE DC    A(LENAREA)          SIZE OF LOCAL WORK AREA
F1       DC    F'1'                CONSTANT
NMSK0FFF DC    X'00FFFFFF'         MASK FOR CLEARING 24-BIT ADDRESS
NMSK7FFF DC    X'7FFFFFFF'         MASK FOR CLEARING AMODE BIT
OMSK8000 DC    X'80000000'         MASK FOR SETTING  AMODE BIT
DFLTSPDD DC    CL8'SYSPARM '       DEFAULT SYSPARM  DATASET DDNAME
DFLTINDD DC    CL8'SYSIN   '       DEFAULT SYSIN    DATASET DDNAME
DFLTDLAY DC    A(00*60*100)        DEFAULT WAIT - 00 MINUTES
DFLTBFOR DC    A(0)                DEFAULT EARLIEST TIME - 00:00:00.00
DFLTAFTR DC    A(24*60*60*100)     DEFAULT LATEST   TIME - 24:00:00.00
MINTME   DC    A(00)               EARLIEST TIME - 00:00:00.00
MAXTME   DC    A(24*60*60*100)     LATEST   TIME - 24:00:00.00
ERRTME   DC    A(((00*60)+30)*100+00) ERROR MARGIN 00:00:30:00         X
                   MM     SS      TH
DFLTCNID DC   0Y(0),CL2'**'        DEFAULT CONSOLE ID - START CMD
DFLTXQCN DC   0Y(0),CL2'MC'        DEFAULT CONSOLE ID - MASTER CONSOLE
DFLTDSCD DC   0Y(0),B'0000010000000000'    DEFAULT MCS DESC=(6)
DFLTRTCD DC   0Y(0),B'0100000000100000'    DEFAULT MCS ROUTCDE=(2,11)
DFLTDSC7 DC   0Y(0),B'0000001000000000'            MCS DESC=(7)
DFLTDOW  DC    B'11111110'         DEFAULT DAYS OF THE WEEK
DOWTABLE DS    0C                  TABLE OF WEEKDAYS
         DC    CL03'SUN'                 0
         DC    CL03'MON'                 1
         DC    CL03'TUE'                 2
         DC    CL03'WED'                 3
         DC    CL03'THU'                 4
         DC    CL03'FRI'                 5
         DC    CL03'SAT'                 6
EBLANKS  DC    CL80' '            EBCDIC BLANKS
EZEROS   DC   0ZL16'0',16C'0'     EBCDIC ZEROS
EXTRLS1  EXTRACT *-*,'S',FIELDS=(TIOT,COMM),MF=L
OPENIN1  OPEN  (*-*,(INPUT,LEAVE)),MF=L
OPENSP1  OPEN  (*-*,(INPUT,LEAVE)),MF=L
OPENPR1  OPEN  (*-*,(OUTPUT,LEAVE)),MF=L
CLOSIN1  CLOSE (*-*,FREE),MF=L
CLOSSP1  CLOSE (*-*,FREE),MF=L
CLOSPR1  CLOSE (*-*,LEAVE),MF=L
DCBIN1   DCB   DSORG=PS,DEVD=DA,                                       X
               DDNAME=SYSIN,MACRF=GM,                                  X
               RECFM=FB,LRECL=80
DCBSP1   DCB   DSORG=PS,DEVD=DA,                                       X
               DDNAME=SYSPARM,MACRF=GM,                                X
               RECFM=FB,LRECL=80
DCBPR1   DCB   DSORG=PS,DEVD=DA,                                       X
               DDNAME=SYSPRINT,MACRF=PM,                               X
               RECFM=FBA,LRECL=121
         EJECT  ,
***************************************************************
*                                                             *
*        LITERAL POOL.                                        *
*                                                             *
***************************************************************
         LTORG  *
         EJECT  ,
***************************************************************
*                                                             *
*        MODULE PATCH AREA.                                   *
*                                                             *
***************************************************************
         DC    S(*)
         DC    S(*)
         DC    S(*)
         DC    S(*)
         DC    S(*)
         DC    S(*)
         DC    S(*)
         DC    S(*)
         DC    S(*)
         DC    S(*)
         DC    S(*)
         DC    S(*)
         DC    S(*)
         DC    S(*)
         DC    S(*)
         DC    S(*)
         DC    S(*)
         DC    S(*)
         DC    S(*)
         DC    S(*)
         DC    S(*)
         DC    S(*)
         DC    S(*)
         DC    S(*)
         DC    S(*)
         DC    S(*)
         DC    S(*)
         DC    S(*)
         DC    S(*)
         DC    S(*)
         DC    S(*)
         DC    S(*)
         DC    S(*)
         DC    S(*)
         DC    S(*)
         DC    S(*)
         DC    S(*)
         DC    S(*)
         DC    S(*)
         DC    S(*)
         DC    S(*)
         DC    S(*)
         DC    S(*)
         DC    S(*)
         DC    S(*)
         DC    S(*)
         DC    S(*)
         DC    S(*)
         DC    S(*)
         DC    S(*)
         DC    S(*)
         DC    S(*)
         DC    S(*)
         DC    S(*)
         DC    S(*)
         END   PAGEADD
