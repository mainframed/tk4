         TITLE 'IEFPARAM - MODULE COMMENTARY'
         SPACE 3
*
*
***************************************************************
*                                                             *
*        NAME      .IEFPARAM  LVL 02.00                       *
*                                                             *
*        FUNCTION/ .TO PROVIDE A MEANS WHEREBY                *
*        PURPOSE    DATA RECORDS CAN BE CREATED               *
*                   WITHIN PROCEDURE LIBRARY JCL.             *
*                                                             *
*        INPUT     .PARM PARAMETER ON THE EXEC CARD           *
*                   INVOKING IEFPARAM.                        *
*                                                             *
*        ENTRY     .IEFPARAM                                  *
*                                                             *
*        OUTPUT    .DATA SET REFERENCED BY DDNAME -SYSPUNCH-. *
*                                                             *
*        RETURN    .00   DATA RECORD(S) SUCCESSFULLY WRITTEN  *
*        CODES     .04   PARM FIELD DATA LENGTH ERROR         *
*                  .08   UNABLE TO OPEN -SYSPUNCH-            *
*                                                             *
*        MODULE    .REENTRANT,REUSEABLE,REFRESHABLE,READ-ONLY *
*        ATTRIBUTES                                           *
*                                                             *
*        FACILITIES/FEATURES                                  *
*                                                             *
*               THIS PROGRAM COPIES COPIES THE DATA PASSED IN *
*        THE PARM FIELD OF THE EXEC CARD TO THE -SYSPUNCH-    *
*        DATA SET.  THUS THE MAJOR USES OF THIS PROGRAM ARE   *
*        IN CONSOLE-STARTED PROCEDURES TO ALLOW THE JCL       *
*        SYMBOLIC SUBSTITUTION MECHANISM TO PASS VARIABLE     *
*        DATA SUCH AS UNIT NAME AND VOLUME SERIAL INFORMATION *
*        TO A UTILITY PROGRAM'S CONTROL INPUT DATA SET, AND   *
*        IN APPLICATIONS PROCEDURES TO ALLOW EASY CONTROL     *
*        CARD REFERENCE INSTEAD OF REQUIRING A SEPARATE       *
*        CONTROL CARD DATA SET.  NOTE ESPECIALLY THAT         *
*        -SYSPUNCH CAN HAVE DISP=MOD.                         *
*                                                             *
*                                                             *
*              THE DCB ATTRIBUTES                             *
*                   RECFM                                     *
*                   LRECL                                     *
*                   BLKSIZE                                   *
*        FOR THE -SYSPUNCH- DATA SET ARE TAKEN FROM THE JCL,  *
*        OR THE DSCB VIA THE NORMAL OPEN MERGE PROCESS.       *
*        IF NONE OF THESE DCB PARAMETERS IS SPECIFIED         *
*        FROM ANY SOURCE, THE DEFAULTS ARE.....               *
*              RECFM=FB,LRECL=80,BLKSIZE=800.                 *
*                                                             *
*              IEFPARAM CAN BUILD RECORDS WITH FORMATS F, FB, *
*        V, VB, VS, VBS, AND U.  FOR RECFM=F OR RECFM=FB, THE *
*        LENGTH OF EACH OUTPUT RECORD IS TAKEN FROM THE       *
*        -SYSPUNCH- LRECL VALUE.  FOR RECORD FORMATS V AND U, *
*        THE LENGTH OF THE DATA PORTION OF EACH OUTPUT RECORD *
*        IS THE SAME AS THE NUMBER OF BYTES TRANFERRED FROM   *
*        THE PARM FIELD. EACH OUTPUT RECORD IS INITIALIZED TO *
*        BLANKS (X'40') BEFORE DATA IS TRANSFERRED FROM THE   *
*        PARM FIELD.                                          *
*                                                             *
*                                                             *
*              THREE SPECIAL CHARACTERS ARE RECOGNIZED AS     *
*        CONTROL CHARACTERS IN THE PARM FIELD DATA. THE       *
*        SEMI-COLON (C';',X'5E',11-6-8) IS THE RECORD         *
*        DELIMITER; THE COLON (C':',X'7A', 2-8) IS THE        *
*        RECORD CONTINUATION CHARACTER; AND THE GREATER THAN  *
*        SYMBOL (C'>',X'6E',0-6-8) IS THE TAB CONTROL         *
*        CHARACTER.                                           *
*                                                             *
*                                                             *
*              THE SEMI-COLON OR RECORD DELIMITER TELLS       *
*        IEFPARAM TO FINISH BUILDING THE CURRENT OUTPUT       *
*        RECORD AND BEGIN A NEW ONE. THE SEMI-COLON DOES NOT  *
*        BECOME PART OF EITHER OUTPUT RECORD.  IF THE         *
*        SEMI-COLON IS IMMEDIATELY FOLLOWED BY A COMMA(X'6B', *
*        0-3-8) THE COMMA IS ALSO DISCARDED. THE COMMA IS     *
*        DISCARDED TO FACILITATE CONTINUATION OF THE PARM     *
*        DATA ACROSS JCL STATEMENTS WITHOUT FORCING A COMMA   *
*        TO BECOME PART OF THE OUTPUT.                        *
*                                                             *
*                                                             *
*              THE COLON OR RECORD CONTINUATION TELLS         *
*        IEFPARAM TO CONTINUE BUILDING THE CURRENT OUTPUT     *
*        RECORD BUT TO TREAT THE CHARACTER IMMEDIATELY        *
*        FOLLOWING THE COLON AS DATA. FIRST OFF, THE COLON    *
*        DOES NOT BECOME PART OF THE OUTPUT RECORD. IF A      *
*        COMMA IMMEDIATELY FOLOWS THE COLON, IT TOO IS        *
*        DISCARDED AND DOES NOT BECOME PART OF THE OUTPUT     *
*        RECORD.  AGAIN THIS WAS DONE TO FACILITATE           *
*        CONTINUATION OF THE PARM FIELD DATA WITHOUT FORCING  *
*        A COMMA TO BECOME PART OF THE OUTPUT. IF ANY         *
*        CHARACTER OTHER THAN A COMMA FOLLOWS THE COLON, IT   *
*        IS CONSIDERED A DATA CHARACTER REGARDLESS OF ITS     *
*        VALUE. THIS PROVIDES THE MECHANISM FOR A SEMI-COLON, *
*        COLON, OR TAB CONTROL CHARACTER TO BECOME PART OF    *
*        THE OUTPUT DATA WITHOUT PERFORMING ITS CONTROL       *
*        CHARACTER FUNCTION.  THUS A COLON FOLLOWED BY A      *
*        SEMI-COLON CAUSES A SEMI-COLON TO APPEAR IN THE      *
*        OUTPUT DATA BUT DOES NOT FORCE THE START OF A NEW    *
*        RECORD. LIKEWISE A DOUBLE COLON CAUSES A COLON TO    *
*        APPEAR IN THE OUTPUT.                                *
*                                                             *
*                                                             *
*              THE GREATER THAN SYMBOL OR TAB CONTROL         *
*        CHARACTER TELLS IEFPARAM TO POSITION TO A DATA       *
*        LOCATION WITHIN THE CURRENT RECORD. THE SYNTAX FOR   *
*        USE IS:                                              *
*                  .......>NNN.....                           *
*        THE TAB CHARACTER INSTRUCTS IEFPARAM TO POSITION TO  *
*        LOCATION "NNN" IN THE CURRENT OUTPUT RECORD.  "NNN", *
*        THE TAB CONTROL STRING, IS A STRING OF NUMERIC       *
*        CHARACTERS INDICATING THE LOCATION IN THE CURRENT    *
*        RECORD WHERE THE NEXT DATA CHARACTER IS TO BE        *
*        PLACED.  THE FIRST DATA BYTE OF THE RECORD IS        *
*        CONSIDERED TO BE LOCATION "001".  THE TAB CONTROL    *
*        STRING IS TERMINATED BY THE FIRST NON-NUMERIC        *
*        CHARACTER ENCOUNTERED FOLLOWING THE TAB. IF THE      *
*        FIRST DATA CHARACTER FOLLOWING THE TAB CONTROL       *
*        STRING IS NUMERIC, USE A RECORD CONTINUATION (:) TO  *
*        TERMINATE THE STRING.  IF "NNN" IS OMITTED OR HAS A  *
*        VALUE OF ZERO, THE RECORD LOCATION USED IS THE       *
*        HIGHEST UNUSED LOCATION IN THE CURRENT RECORD (LIKE  *
*        ASSEMBLER "ORG" WITHOUT OPERANDS).  IF "NNN" HAS A   *
*        VALUE EXCEEDING THE LENGTH OF THE RECORD, THE RECORD *
*        LOCATION USED IS THAT OF THE LAST DATA BYTE IN A     *
*        MAXIMUM-SIZED RECORD. THUS TO FORCE A MAXIMUM-SIZED  *
*        RECORD IN THIS CASE, FOLLOW THE TAB CONTROL STRING   *
*        BY ONE DATA CHARACTER.                               *
*                                                             *
***************************************************************
***                                                         ***
***>>>>>>>>>>>>>>C U I C   D I S C L A I M E R<<<<<<<<<<<<<<***
***                                                         ***
***************************************************************
***            THE INFORMATION OR MATERIAL BEING PROVIDED   ***
***      BY COMMERCIAL UNION INSURANCE COMPANY (CUIC),      ***
***      WHETHER IN HARD COPY OR MACHINE READABLE FORM,     ***
***      HAS BEEN DEVELOPED BY CUIC FOR ITS OWN PURPOSE     ***
***      AND FOR USE ON ITS OWN EQUIPMENT AND WITHIN ITS    ***
***      OWN DATA PROCESSING SYSTEM.  CUIC MAKES NO         ***
***      REPRESENTATIONS OR WARRANTIES WHATSOEVER WITH      ***
***      RESPECT TO THE INFORMATION OR MATERIAL FURNISHED   ***
***      HEREUNDER, EXPRESSED OR IMPLIED, INCLUDING BUT     ***
***      NOT LIMITED TO ANY REPRESENTATION OR WARRANTY OF   ***
***      MERCHANTABILITY OR FITNESS FOR ANY PARTICULAR USE  ***
***      OR PURPOSE OR THAT THE USE OF THE INFORMATION OR   ***
***      MATERIAL WILL NOT INFRINGE ANY PATENT, COPYRIGHT,  ***
***      TRADEMARK, OR OTHER PROPRIETARY INTEREST.  YOU     ***
***      ARE, THEREFORE, ACCEPTING THIS INFORMATION OR      ***
***      MATERIAL ON AN "AS IS" BASIS AND WILL BE USING IT  ***
***      AT YOUR OWN RISK.  NEITHER CUIC NOR ANY OF ITS     ***
***      AFFILIATES SHALL BE LIABLE WITH RESPECT TO ANY     ***
***      CLAIM, ACTION, OR DEMAND BY ANY USER OR OTHER      ***
***      PARTY (INCLUDING ANY CLAIM, ACTION, OR DEMAND FOR  ***
***      CONSEQUENTIAL DAMAGES EVEN IF CUIC HAS BEEN        ***
***      ADVISED OF THE POSSIBILITY OF SUCH DAMAGES)        ***
***      ARISING FROM THE USE OF THE INFORMATION OR THE     ***
***      MATERIALS AND CONCEPTS RELATED THERETO.            ***
***      FURTHERMORE, CUIC WILL NOT MAINTAIN, CORRECT, OR   ***
***      UPDATE THIS INFORMATION OR MATERIAL IN THE         ***
***      FUTURE.                                            ***
***                                              01/26/83   ***
***************************************************************
*                                                             *
*              DIRECT INQUIRIES TO THE                        *
*        AUTHOR.....                                          *
*                                                             *
*                   THOMAS J. AUBREY                          *
*                   MIS                                       *
*                   COMMERCIAL UNION ASSURANCE COMPANIES      *
*                   ONE BEACON STREET                         *
*                   BOSTON, MASSACHUSETTS  02108              *
*                   TELEPHONE (617) 725-6208                  *
*                                                             *
***************************************************************
*
*
         TITLE 'IEFPARAM - MODULE EQUATES'
IEFPARAM START 000000
R0       EQU   0
R1       EQU   1
R2       EQU   2
R3       EQU   3
R4       EQU   4
R5       EQU   5
R6       EQU   6
R7       EQU   7
R8       EQU   8
R9       EQU   9
R10      EQU   10
R11      EQU   11
R12      EQU   12
R13      EQU   13
R14      EQU   14
R15      EQU   15
*
*
*        LOGICAL REGISTER EQUATES
RSEGA    EQU   03                  OUTPUT SEGMENT - CURRENT BYTE
RSEGINC  EQU   04    EVEN          OUTPUT SEGMENT - BXH INCREMENT
RSEGND   EQU   05    ODD           OUTPUT SEGMENT - LAST BYTE ADDRESS
RDATA    EQU   08                  RECORD AREA - CURRENT BYTE
RDATAINC EQU   06    EVEN          RECORD AREA - BXH INCREMENT
RDATAND  EQU   07    ODD           RECORD AREA - LAST BYTE ADDRESS
RPARM    EQU   09                  PARM FIELD - CURRENT BYTE
RPARMINC EQU   10    EVEN          CONSTANT A(1)
RPARMND  EQU   11    ODD           PARM FIELD - LAST BYTE ADDRESS
RBASE    EQU   12                  MODULE BASE REGISTER
RWORK    EQU   13                  WORK AREA BASE REGISTER
RLINK    EQU   14                  SUBROUTINE LINKAGE REGISTER
RENTRY   EQU   15                  ENTRY ADDRESS REGISTER
*
*
*        EBCDIC CHARACTER EQUATES
ENULL    EQU   X'00'
EBLANK   EQU   X'40'
ECOMMA   EQU   C','
ESEMIC   EQU   C';'
ECOLON   EQU   C':'
ETAB     EQU   C'>'
         TITLE 'IEFPARAM - DATA CONTROL BLOCK(DCB) DSECT'
         DCBD  DSORG=PS
         TITLE 'IEFPARAM - WORKING STORAGE DSECT'
         SPACE 3
IEFSECT  DSECT  ,
SAVE     DC    18A(0)              GENERAL REGISTER SAVE AREA
PACKAREA DC    D'0'                DOUBLEWOD BOUNDARY WORK AREA
DATASPSZ DC    A(0)                RECORD ASSEMBLY AREA SP & SIZE
DATAPTR  DC    A(0)                RECORD ASSEMBLY AREA ADDRESS
DATAORG  DC    A(0)                CURRENT RECORD DATA ORIGIN ADDRESS
DATANEXT DC    A(0)                NEXT AVAILABLE DATA BYTE ADDRESS
DATANDPT DC    A(0)                CURRENT RECORD LAST BYTE ADDRESS
DATAEND  DC    A(0)                CURRENT RECORD LAST BYTE ADDRESS +1
PUTLINK  DC    A(0)                SAVE RETURN VALUE FOR PUT ROUTINES
PUTSEGNO DC    A(0)                CURRENT RECORD SEGMENT COUNT
*
*WRITE-TO-PROGRAMMER WORK AREA
WTPAREA  DS    A(0)                *
MSGAREA  DS    CL72                WTP MESSAGE AREA
         DS    XL4                 MCS ROUTE AND DESCRIPTOR CODES
*
*        OPEN/CLOSE PARAMETER LIST
OPENDCB  OPEN  (0,(INPUT,LEAVE)),MF=L
*
*        EXIT LIST FOR DCB OPEN EXIT
EXITLIST DC    A(0)
*
*        DATA CONTROL BLOCK FOR SYSPUNCH
PUNCHDCB DCB   DSORG=PS,DEVD=DA,MACRF=PL,DDNAME=SYSPUNCH
PCHDCBND DS    0F                  MARK THE DCB END
MAXPARM  DC    Y(256)              PARM SIZE MAXIMUM
MAXLRECL DS    H                   MAXIMUM LOGICAL RECORD SIZE
RETURNCD DS    H                   SAVE RETURN CODE VALUE
*
*
*        CONTROL CHARACTER DEFINITIONS
COMMA    DC    C','                JCL DELIMITER
DELIMIT  DC    C';'                CONTROL IMAGE END
CONTINUE DC    C':'                IMAGE CONTINUATION CHARACTER
TAB      DC    C'>'                TAB CONTROL CHARACTER
ENDSECT  DS    0D                  MARK THE DSECT END
LENSECT  EQU   ENDSECT-IEFSECT     LENGTH OF DSECT WORK AREA
         TITLE 'IEFPARAM - MODULE INITIALIZATION'
IEFPARAM CSECT
         USING *,R15               TEMPORARY BASE
         B     BYID                BRANCH AROUND MODULE IDENTIFIER
         DC    AL1(NDID-*)         IDENTIFIER LENGTH
         DC    CL8'IEFPARAM'       MODULE NAME
         DC    CL1' '                     SPACE
         DC    CL9'LVL 02.00'      MODULE VERSION AND LEVEL
         DC    CL1' '                     SPACE
         DC    CL8'&SYSDATE'       MODULE ASSEMBLY DATE
         DC    CL1' '                     SPACE
         DC    CL5'&SYSTIME'       MODULE ASSEMBLY TIME
NDID     EQU   *                   MARK IDENTIFIER END
BYID     DS    0H                  BRANCH POINT AROUND IDENTIFIER
         STM   R14,R12,12(R13)     SAVE GENERAL REGISTERS
         LA    RBASE,0(,R15)       LOAD BASE REGISTER
         USING IEFPARAM,RBASE      ESTABLISH PERMANENT BASE
         DROP  R15                 DROP TEMPORARY BASE
*
*
*        GET STORAGE FOR THE WORK  AREA
         L     R0,WORKSIZE         LOAD SP&SIZE FOR GETMAIN
         GETMAIN R,LV=(0)          GET THE WORK AREA STORAGE
         ST    R1,8(,R13)              CHAIN SAVE
         ST    R13,SAVE+4-IEFSECT(,R1) AREAS TOGETHER
         LR    RWORK,R1            WORK AREA BASE REGISTER
         USING IEFSECT,RWORK       WORK AREA ADDRESSABILITY
*
*
*        INITIALIZE THE WORK AREA
         XC    SAVE+0(4*01),SAVE+0 CLEAR THE
         XC    SAVE+8(4*16),SAVE+8 SAVE AREA
         SR    R0,R0               ZERO R0
         STH   R0,RETURNCD         CLEAR RETURN CODE SAVE AREA
         ST    R0,DATAPTR          CLEAR RECORD ASSEMBLY AREA ADDR.
         MVC   MAXPARM,=Y(256)     DEFAULT MAXIMUM PARM LENGTH
         MVI   COMMA,ECOMMA        INITIALIZE CONTROL CHARACTER
         MVI   DELIMIT,ESEMIC      INITIALIZE CONTROL CHARACTER
         MVI   CONTINUE,ECOLON     INITIALIZE CONTROL CHARACTER
         MVI   TAB,ETAB            INITIALIZE CONTROL CHARACTER
*
*
*        INITIALIZE THE DCB AND ASSOCIATED AREAS
         MVC   OPENDCB(4),OPENLST1 INITIALIZE OPEN/CLOSE LIST
         MVC   PUNCHDCB(PCHDCBND-PUNCHDCB),DCBLIST1   DCB LIST
         LA    R1,EXITLIST         ADDRESS OF EXIT LIST
         ST    R1,EXITLIST         TEMPORARY STORE
         MVC   PUNCHDCB+(DCBEXLST+1-IHADCB)(3),EXITLIST+1
         LA    R1,DCBEXIT          OPEN EXIT ROUTINE ADDRESS
         ST    R1,EXITLIST         STORE ADDRESS IN THE EXIT LIST
         MVI   EXITLIST,X'85'      INDICATE DCB OPEN EXIT
         EJECT  ,
*
*
*        ANALYZE THE PARAMETER INFORMATION PASSED
         L     R1,SAVE+4           @ OF CALLER'S SAVE AREA
         L     R1,24(,R1)          R1 REGISTER VALUE PASSED
*
*        IF A  DDNAME WAS PASSED,  MAKE THE SUBSTITUITION
PARM01   TM    0(R1),X'80'         IS THERE A DDNAME LIST
         BO    PARM08              BRANCH IF NOT
         L     R2,4(,R1)           ADDRESS OF DDNAME LIST
         N     R2,=A(X'FFFFFF')    IS A DDNAME LIST PRESENT?
         BZ    PARM02              BRANCH IF DDNAME LIST ABSENT
         MVC   PUNCHDCB+(DCBDDNAM-IHADCB)(L'DCBDDNAM),0(R2)
*
*        IF A  MAXIMUM PARM VALUE  WAS SUPPLIED, RETRIEVE IT.
PARM02   TM    4(R1),X'80'         IS THERE A MAX PARM VALUE ENTRY?
         BO    PARM08              BRANCH IF NOT
         L     R2,8(,R1)           ADDRESS OF MAXIMUM PARM VALUE
         N     R2,=A(X'FFFFFF')    IS A MAXIMUM VALUE PRESENT?
         BZ    PARM03              BRANCH IF MAXIMUM PARM VALUE ABSENT
         MVC   MAXPARM,0(R2)       REPLACE MAXIMUM PARM LENGTH
*
*        IF SUBSTITUTE CONTROL CHARACTERS WERE SUPPLIED,
*        COPY THEM TO THE CONTROL AREA.
PARM03   TM    8(R1),X'80'         SUBSTITUTE CHARACTERS SUPPLIED ?
         BO    PARM08              BRANCH IF NOT
         L     R2,12(,R1)          ADDRESS OF SUBSTITUTE CHARACTERS
         N     R2,=A(X'FFFFFF')    ARE SUBSTITUTE CHARACTERS PRESENT?
         BZ    PARM08              BRANCH IF NO CHARACTER STRING
         CLI   0(R2),EBLANK        SUBSTITUTE DELIMITER?
         BE    *+L'*+6             BRANCH IF NO SUBSTITUTE
         MVC   DELIMIT,0(R2)       COPY DELIMITER TO WORK AREA
         CLI   1(R2),EBLANK        SUBSTITUTE CONTINUATION?
         BE    *+L'*+6             BRANCH IF NO SUBSTITUTE
         MVC   CONTINUE,1(R2)      COPY CONTINUATION TO WORK AREA
         CLI   2(R2),EBLANK        SUBSTITUTE TAB?
         BE    *+L'*+6             BRANCH IF NO SUBSTITUTE
         MVC   TAB,2(R2)           COPY TAB TO WORK AREA
*
*        VALIDATE THE PARM FIELD DATA AND LENGTH
PARM08   DS    0H
         L     R2,0(,R1)           ADDRESS OF PARM DATA
         LH    R2,0(,R2)           LOAD DATA LENGTH
         LTR   R2,R2               IF LENGTH IS ZERO OR NEGATIVE
         BNP   RC04                PARM DATA LENGTH ERROR
         CH    R2,MAXPARM          LENGTH GT MAXIMUM
         BH    RC04                IF SO, DATA LENGTH ERROR
         EJECT  ,
*
*
*        OPEN THE DCB AND TAKE THE DCB EXIT
OPEN01   DS    0H
         MVC   OPENDCB(4),OPENLST1 INITIALIZE OPEN/CLOSE LIST
         OPEN  (PUNCHDCB,(OUTPUT,LEAVE)),MF=(E,OPENDCB)
         TM    PUNCHDCB+(DCBOFLGS-IHADCB),X'10' WAS OPEN SUCCESSFUL
         BZ    RC08                DCB COULD NOT BE OPENED
*
*        GET STORAGE FOR THE RECORD ASSEMBLY AREA
         LA    R0,01               LOAD SUBPOOL FOR GETMAIN
         SLL   R0,24               TO HIGH-ORDER BYTE OF REGISTER
         LH    R1,MAXLRECL         LOAD MAXIMUM RECORD SIZE
         OR    R0,R1               PACK LENGTH WITH SUBPOOL
         ST    R0,DATASPSZ         SAVE SP&SIZE FOR FREEMAIN
         GETMAIN R,LV=(0)          GET THE RECORD ASSEMBLY AREA
         ST    R1,DATAPTR          SAVE RECORD ASSEMBLY AREA ADDRESS
         SPACE 05
*
*
*        BUILD RECORD ROUTINE INITIALIZATION.
*
*
*        RECOVER THE PARAMETER AREA ADDRESS
*        AND INITIALIZE PARAMETER SCAN REGISTERS
BUILD00  DS    0H
         L     R1,SAVE+4           PRIOR SAVE AREA
         L     R1,20+4*R1(,R1)     R1 PARAMETER VALUE PASSED
         L     R1,0(,R1)           ADDRESS OF HALFWORD DATA LENGTH
         LH    RPARMND,0(,R1)      NUMBER OF BYTES PASSED
         LA    RPARM,1(,R1)        ADDR OF FIRST PARM BYTE-1
         AR    RPARMND,RPARM       LAST PARM BYTE
         LA    RPARMINC,1          INCREMENT OF 1
         AR    RPARM,RPARMINC      FIRST DATA BYTE
         TITLE 'IEFPARAM - BUILD OUTPUT RECORDS'
*
*
*        INITIALIZE THE RECORD ASSEMBLY AREA.
BUILD01  DS    0H
         BAL   RLINK,CLEAR         CLEAR AND INITIALIZE AREA
         SPACE 5
*
*
*        TEST FOR RECORD DELIMITER
BUILD02  DS    0H
         CLI   DELIMIT,ENULL       DELIMITER FUNCTION NULLIFIED?
         BE    BUILD03             YES - TEST CONTINUATION
         CLC   DELIMIT,0(RPARM)    RECORD DELIMITER ENCOUNTERED?
         BNE   BUILD03             NO - TEST CONTINUATION
         BXH   RPARM,RPARMINC,BUILD08  ADVANCE ONE PARM FIELD BYTE
         CLC   COMMA,0(RPARM)      FOLLOWED BY A COMMA?
         BE    BUILD08             YES - BYPASS COMMA
         SR    RPARM,RPARMINC      BACKUP TO RECORD DELIMITER
         B     BUILD08             END OF CURRENT RECORD
         SPACE  5
*
*        TEST FOR CONTINUATION AROUND COMMA
BUILD03  DS    0H
         CLI   CONTINUE,ENULL      CONTINUATION FUNCTION NULLIFIED?
         BE    BUILD04             YES - TEST FOR TAB CHARACTER
         CLC   CONTINUE,0(RPARM)   RECORD CONTINUATION?
         BNE   BUILD04             NO - TEST FOR TAB CHARACTER
         BXH   RPARM,RPARMINC,BUILD08  ADVANCE ONE BYTE
         CLC   COMMA,0(RPARM)      FOLLOWED BY A COMMA?
         BNE   BUILD06             NO - MOVE DATA BYTE
         B     BUILD07             ADVANCE TO NEXT PARM CHARACTER
         EJECT  ,
*
*        TEST FOR TAB CONTROL CHARACTER
BUILD04  DS    0H
         CLI   TAB,ENULL           TAB FUNCTION NULLIFIED?
         BE    BUILD06             YES - MOVE CHARACTER
         CLC   TAB,0(RPARM)        TAB CHARACTER?
         BNE   BUILD06             NO - MOVE CHARACTER
         MVI   PACKAREA,C'0'            CLEAR
         MVC   PACKAREA+1(L'PACKAREA-1),PACKAREA
*
*        EXTRACT THE TAB CONTROL STRING.
BUILD4A  DS    0H
         BXH   RPARM,RPARMINC,BUILD4B  ADVANCE ONE BYTE
         CLI   0(RPARM),C'0'       IF BYTE LT "0"
         BL    BUILD4B             END OF TAB CONTROL REACHED
         CLI   0(RPARM),C'9'       IF BYTE GT "9"
         BH    BUILD4B             END OF TAB CONTROL REACHED
         MVC   PACKAREA(L'PACKAREA-1),PACKAREA+1   LEFT SHIFT
         MVC   PACKAREA+L'PACKAREA-1(1),0(RPARM)   GET NEXT BYTE
         B     BUILD4A             LOOP FOR NEXT OFFSET BYTE
*
*        CONVERT THE TAB CONTROL STRING TO BINARY,
*        AND TEST ITS VALUE.
BUILD4B  DS    0H
         SR    RPARM,RPARMINC      BACK UP TO LAST TAB CONTROL
         PACK  PACKAREA,PACKAREA   GET PACKED DECIMAL LOCATION
         CVB   R0,PACKAREA         CONVERT LOCATION NUMBER TO BINARY
         SH    R0,=Y(1)            CONVERT LOCATION VALUE TO OFFSET
         BM    BUILD4C             IF MINUS, LOCATION WAS ZERO.
         B     BUILD4D             SEE IF WITHIN THE CURRENT RECORD
*
*        TAB LOCATION VALUE IS ZERO,
*        CONSIDER THE TAB LOCATION
*        TO BE THE NEXT AVAILABLE  DATA BYTE.
BUILD4C  DS    0H
         L     RDATA,DATANEXT      LOAD NEXT BYTE ADDRESS
         B     BUILD07             ADVANCE TO NEXT PARM CHARACTER
*        TAB LOCATION VALUE IS POSITIVE (TAB OFFSET GE 0),
*        COMPUTE THE TAB LOCATION AND SEE IF WITHIN THE CURRENT RECORD
BUILD4D  DS    0H
         A     R0,DATAORG          COMPUTE NEW DATA ORIGIN
         C     R0,DATANDPT         COMPARE TO RECORD END
         BH    BUILD4E             IF OUTSIDE CURRENT RECORD
         B     BUILD4F             IF WITHIN CURRENT RECORD
*        TAB LOCATION HAS GONE OUTSIDE CURRENT RECORD
BUILD4E  DS    0H
         L     RDATA,DATANDPT      POINT TO LAST BYTE IN RECORD
         B     BUILD4G
*        TAB LOCATION IS WITHIN THE CURRENT RECORD
BUILD4F  DS    0H
         LR    RDATA,R0            START DATA AT TAB LOCATION
         B     BUILD4G
*        ESTABLISH NEXT AVAILABLE DATA BYTE ADDRESS
BUILD4G  DS    0H
         C     RDATA,DATANEXT      TO NEXT AVAILABLE BYTE
         BNH   *+L'*+4             IF NOT ABOVE SAVED ADDRESS
         ST    RDATA,DATANEXT      SAVE NEXT AVAILABLE BYTE ADDRESS
         B     BUILD07             ADVANCE TO NEXT PARM CHARACTER
         EJECT  ,
*
*        MOVE ONE DATA BYTE
BUILD06  DS    0H
         MVC   0(1,RDATA),0(RPARM) MOVE THE BYTE
         BXH   RDATA,RDATAINC,BUILD6A IF RECORD END WAS REACHED
         C     RDATA,DATANEXT      TO NEXT AVAILABLE BYTE
         BNH   *+L'*+4             IF NOT ABOVE SAVED ADDRESS
         ST    RDATA,DATANEXT      SAVE NEXT AVAILABLE BYTE ADDRESS
         B     BUILD07             ADVANCE TO THE NEXT PARM CHARACTER
*
*        END OF CURRENT RECORD WAS REACHED
BUILD6A  DS    0H
         ST    RDATA,DATANEXT      ADDRESS OF LAST+1 BYTE IN RECORD
         CLI   DELIMIT,ENULL       DELIMITER FUNCTION NULLIFIED?
         BE    BUILD08             YES - COMPLETE CURRENT RECORD
         BXH   RPARM,RPARMINC,BUILD08 IF PARM DATA EXHAUSTED
         CLC   DELIMIT,0(RPARM)    RECORD FOLLOWED BY DELIMITER?
         BNE   BUILD6C             NO - BACK UP TO LAST CHARACTER
*
*        RECORD WAS IMMEDIATELY FOLLOWED BY A DELIMITER
BUILD6B  DS    0H
         BXH   RPARM,RPARMINC,BUILD08 IF PARM DATA EXHAUSTED
         CLC   COMMA,0(RPARM)      DELIMITER FOLLOWED BY A COMMA?
         BE    BUILD08             YES - COMPLETE CURRENT RECORD
*
*        BACK UP TO THE CURRENT CHARACTER AND COMPLETE THE RECORD.
BUILD6C  DS    0H
         SR    RPARM,RPARMINC      BACK UP TO CURRENT CHARACTER
         B     BUILD08             COMPLETE CURRENT RECORD
         SPACE  10
*
*        ADVANCE TO THE NEXT PARM  CHARACTER
BUILD07  DS    0H
         BXH   RPARM,RPARMINC,BUILD08 IF PARM DATA EXHAUSTED
         B     BUILD02             PROCESS NEXT DATA BYTE
         EJECT  ,
*
*
*        END OF RECORD ROUTINE - COMPLETE THIS RECORD,
*        AND START ANOTHER ONE IF MORE DATA EXISTS.
BUILD08  DS    0H
         L     RDATA,DATANEXT      ADDRESS OF LAST+1 BYTE IN RECORD
         TM    PUNCHDCB+(DCBRECFM-IHADCB),DCBRECU
         BO    BUILD82             IF RECFM=U
         TM    PUNCHDCB+(DCBRECFM-IHADCB),DCBRECF
         BO    BUILD83             IF RECFM=F OR FB
*        RECFM =V, VB, VS, OR VBS  - COMPLETE RDW
BUILD81  DS    0H
         LR    RDATAINC,RDATA      COMPUTE
         S     RDATAINC,DATAPTR    DATA LENGTH
         C     RDATAINC,=A(4)      IF BELOW MINIMUM LENGTH
         BH    *+L'*+4             SUBSTITUTE
         LA    RDATAINC,5          MINIMUM LENGTH
         STH   RDATAINC,PUNCHDCB+(DCBLRECL-IHADCB)  STORE IN DCB
         SLL   RDATAINC,16         LENGTH IN LEFT HALF OF RDW
         L     RDATA,DATAPTR       START OF RECORD ADDRESS
         ST    RDATAINC,PACKAREA   CREATE RDW
         MVC   0(4,RDATA),PACKAREA RDW TO OUTPUT AREA
         BAL   RLINK,PUTV          WRITE OUT V FORMAT RECORD
         B     BUILD84             COMPLETE CURRENT RECORD
*        RECFM=U
BUILD82  DS    0H
         LR    RDATAINC,RDATA      COMPUTE
         S     RDATAINC,DATAPTR    RECORD LENGTH
         C     RDATAINC,=A(0)      IF BELOW MINIMUM LENGTH
         BH    *+L'*+4             SUBSTITUTE
         LA    RDATAINC,1          MINIMUM LENGTH
         STH   RDATAINC,PUNCHDCB+(DCBLRECL-IHADCB)  STORE IN DCB
         BAL   RLINK,PUTU          WRITE OUT U FORMAT RECORD
         B     BUILD84
*        RECFM =F, OR FB
BUILD83  DS    0H                  FALL THRU TO COMPLETE RECORD
         BAL   RLINK,PUTF          WRITE OUT F FORMAT RECORD
         B     BUILD84
*        COMPLETE CURRENT RECORD
BUILD84  DS    0H
         CR    RPARM,RPARMND       IS THERE MORE DATA?
         BH    BUILD09             NO - CLOSE OUT DATA SET
         BXH   RPARM,RPARMINC,BUILD09   TO NEXT PARM DATA BYTE
         B     BUILD01             START ANOTHER RECORD
         TITLE 'IEFPARAM - MODULE CLEANUP AND TERMINATION'
*
*
*        PARM FIELD DATA EXHAUSTED, COMPLETE THE DATA SET
BUILD09  DS    0H
         OI    PUNCHDCB+(DCBOFLGS-IHADCB),X'80'  FORCE WRITE BIT ON
         MVC   OPENDCB(4),CLOSLST1 INITIALIZE OPEN/CLOSE LIST
         CLOSE (PUNCHDCB,LEAVE),MF=(E,OPENDCB)
*
*        RELEASE THE BUFFER POOL
         FREEPOOL PUNCHDCB        RELEASE THE BUFFERS
*
*        RELEASE THE RECORD ASSEMBLY AREA.
         L     R0,DATASPSZ         LOAD SP&SIZE FOR FREEMAIN
         L     R1,DATAPTR          LOAD RECORD ASSEMBLY AREA ADDRESS
         FREEMAIN R,LV=(0),A=(1)   RELEASE THE RECORD ASSEMBLY AREA
         SPACE 2
         B     RC00                RETURN TO THE CALLER
         EJECT ,
*
*
*        EXIT WITH THE PROPER RETURN CODE
*
*
RC00     DS    0H
         MVI   RETURNCD+1,0        SUCCESSFUL COMPLETION
         B     LEAVE
RC04     DS    0H
         MVI   RETURNCD+1,04       INVALID PARM FIELD DATA LENGTH
         B     LEAVE
RC08     DS    0H
         MVI   RETURNCD+1,08       UNABLE TO OPEN OUTPUT DATA SET
         B     LEAVE
         SPACE 5
*
LEAVE    DS    0H
         LR    R1,RWORK            ADDRESS TO FREEMAIN
         LH    R2,RETURNCD         RETURN CODE
         L     R13,SAVE+4          CALLER'S SAVE AREA
         L     R0,WORKSIZE         LOAD SP & SIZE FOR FREEMAIN
         FREEMAIN R,LV=(0),A=(1)   RELEASE THE WORK AREA
         LR    R15,R2              RETURN CODE TO R15
         RETURN    (14,12),RC=(15)
         TITLE 'IEFPARAM - SYSPUNCH DCB OPEN EXIT ROUTINE'
*
*
*        DATA CONTROL BLOCK OPEN  EXIT
*
*        THIS ROUTINE SUPPLIES DCB PARAMETERS
*        WHICH HAVE NOT BEEN SUPPLIED BY OPEN TIME.
*        VALUES WHICH WILL BE SUPPLIED ARE....
*
*                   RECFM
*                   LRECL
*                   BLKSIZE
*                   BFTEK=A FOR VS  OR VBS
*
*
DCBEXIT  DS    0H
         LH    R1,PUNCHDCB+(DCBBLKSI-IHADCB)         LOAD BLKSIZE
         LH    R15,PUNCHDCB+(DCBLRECL-IHADCB)        LOAD LRECL
         TM    PUNCHDCB+(DCBRECFM-IHADCB),DCBRECU    RECFM=U?
         BO    DCBEXTU                               IF RECFM=U
         TM    PUNCHDCB+(DCBRECFM-IHADCB),DCBRECF    RECFM=F?
         BO    DCBEXTF                               IF RECFM=F
         TM    PUNCHDCB+(DCBRECFM-IHADCB),DCBRECV    RECFM=V?
         BO    DCBEXTV                               IF RECFM=V
         B     DCBEXTNS                              RECFM NOT SUPPLIED
*
*
*        RECFM  WAS NOT SUPPLIED
*        SET DEFAULT RECFM TO FB
DCBEXTNS DS    0H
         OI    PUNCHDCB+(DCBRECFM-IHADCB),DCBRECF+DCBRECBR
         B     DCBEXTF             GO PROCESS FIXED FORMAT RECORDS
*
*
*        RECFM= F OR FB
DCBEXTF  DS    0H
         OI    PUNCHDCB+(DCBRECFM-IHADCB),DCBRECSB   TURN OFF
         XI    PUNCHDCB+(DCBRECFM-IHADCB),DCBRECSB   FS OR FBS
DCBEXTF1 DS    0H
         LTR   R1,R1               WAS BLKSIZE SUPPLIED?
         BZ    DCBEXTF4            NO, BLKSIZE=0
*        RECFM=F OR FB, BLKSIZE NE 0
DCBEXTF2 DS    0H
         LTR   R15,R15             WAS LRECL SUPPLIED?
         BZ    DCBEXTF3            NO - LRECL EQ 0
         B     DCBEXTF8            BOTH NON-ZERO, GO CHECK MULTIPLE
*        RECFM=F OR FB, BLKSIZE NE 0, LRECL EQ 0
DCBEXTF3 DS    0H
         LR    R15,R1              SET LRECL=BLKSIZE
         B     DCBEXTF8            GO CHECK MULTIPLE
*        RECFM=F OR FB, BLKSIZE EQ 0
DCBEXTF4 DS    0H
         LTR   R15,R15             WAS LRECL SUPPLIED?
         BZ    DCBEXTF6            NO, LRECL EQ 0
*        RECFM=F OR FB, BLKSIZE EQ 0, LRECL NE 0
DCBEXTF5 DS    0H
         LR    R1,R15              SET BLKSIZE=LRECL
         B     DCBEXTF7            GO CHECK MULTIPLE
*        RECFM=F OR FB, BLKSIZE EQ 0, LRECL EQ 0
DCBEXTF6 DS    0H
         LA    R15,80              SET DEFAULT LRECL=80
         LR    R1,R15              SET BLKSIZE=LRECL
         B     DCBEXTF7            GO CHECK MULTIPLE
*        RECFM=F OR FB, SET BLKSIZE FOR CURRENT LRECL
DCBEXTF7 DS    0H
         TM    PUNCHDCB+(DCBRECFM-IHADCB),DCBRECBR   RECORDS BLOCKED?
         BZ    DCBEXTF8            LEAVE BLKSIZE=LRECL IF NOT
         CH    R1,=Y(256)          IF BLKSIZE GT 256
         BH    DCBEXTF8            LEAVE BLKSIZE=AS PREVIOUSLY SET
         MH    R1,=Y(10)           MULTIPLY BLKSIZE BY 10
         B     DCBEXTF8            GO CHECK MULTIPLE
*
*
*        AT THIS POINT, RECFM=FB, LRECL NE 0, BLKSIZE NE 0
*        FORCE BLKSIZE TO AN EVEN MULTIPLE OF LRECL
DCBEXTF8 DS    0H
         SR    R0,R0               ZERO R0 FOR DIVIDE
         DR    R0,R15              DIVIDE BLKSIZE BY LRECL
         LTR   R1,R1               IF QUOTIENT IS ZERO
         BNZ   *+L'*+4             DO NOT FORCE
         LA    R1,1                BLKSIZE=LRECL
         MR    R0,R15              RECOMPUTE BLKSIZE
         B     DCBEXTND
*
*
*        RECFM=U
DCBEXTU  DS    0H
         OI    PUNCHDCB+(DCBRECFM-IHADCB),DCBRECBR+DCBRECSB
         XI    PUNCHDCB+(DCBRECFM-IHADCB),DCBRECBR+DCBRECSB
DCBEXTU1 DS    0H
         LTR   R1,R1               WAS BLKSIZE SUPPLIED?
         BZ    DCBEXTU3            NO, BLKSIZE=0
*        RECFM=U, BLKSIZE NE 0
DCBEXTU2 DS    0H
         B     DCBEXTU8            GO COMPLETE RECFM=U PROCESSING
*        RECFM=U, BLKSIZE EQ 0
DCBEXTU3 DS    0H
         LA    R1,80               SET BLKSIZE=80
         B     DCBEXTU8            GO COMPLETE RECFM=U PROCESSING
*        RECFM=U PROCESSING COMPLETE
DCBEXTU8 DS    0H
         LR    R15,R1              FORCE LRECL=BLKSIZE
         B     DCBEXTND
         EJECT  ,
*
*
*        RECFM=V, VS, VB, OR VBS.
DCBEXTV  DS    0H
         TM    PUNCHDCB+(DCBRECFM-IHADCB),DCBRECSB     VS OR VBS ?
         BZ    DCBEXTV0                                IF YES,
         OI    PUNCHDCB+(DCBBFTEK-IHADCB),DCBBFT       CLEAR
         XI    PUNCHDCB+(DCBBFTEK-IHADCB),DCBBFT       BFTEK VALUE, &
         OI    PUNCHDCB+(DCBBFTEK-IHADCB),DCBBFTS      FORCE BFTEK=S
*        TEST THE BLKSIZE VALUE FOR ZERO/NON-ZERO.
DCBEXTV0 DS    0H
         CH    R1,=Y(8)            IS BLKSIZE=0?
         BNH   DCBEXTV4            BRANCH IF YES
*        RECFM =V, VS, VB, OR VBS, BLKSIZE NE 0
DCBEXTV1 DS    0H
         S     R1,=A(4)            COMPUTE BLKSIZE-4
         C     R15,=A(4)           IS LRECL=0?
         BH    DCBEXTV2            BRANCH IF LRECL NE 0
         TM    PUNCHDCB+(DCBRECFM-IHADCB),DCBRECSB     VS OR VBS ?
         BZ    DCBEXTV3            IF NOT, CONSIDER LRECL EQ 0
         CH    R15,LRECLX          IS LRECL=X?
         BE    DCBEXTV2            IF YES, LRECL NE 0
         B     DCBEXTV3            IF NOT, LRECL EQ 0
*        RECFM=V, VS, VB, OR VBS, BLKSIZE NE 0, LRECL NE 0
DCBEXTV2 DS    0H
         TM    PUNCHDCB+(DCBRECFM-IHADCB),DCBRECSB     VS OR VBS ?
         BO    DCBEXTV8            IF YES, ALLOW LRECL GT BLKSIZE-4
         CR    R15,R1              COMPARE LRECL TO BLKSIZE-4
         BNH   DCBEXTV8            IF WITHIN MAXIMUM LRECL
         LR    R15,R1              IF MAXIMUM LRECL EXCEEDED,          X
                                   SET LRECL=BLKSIZE-4
         B     DCBEXTV8            GO RE-ESTABLISH BLKSIZE
*        RECFM=V, VS, VB, OR VBS, BLKSIZE NE 0, LRECL EQ 0
DCBEXTV3 DS    0H
         LR    R15,R1              SET LRECL=BLKSIZE-4
         B     DCBEXTV8            GO RE-ESTABLISH BLKSIZE
*
*
*        RECFM=V, VS, VB, OR VBS, BLKSIZE EQ 0
DCBEXTV4 DS    0H
         C     R15,=A(4)           IS LRECL=0?
         BH    DCBEXTV5            BRANCH IF LRECL IS POSITIVE
         TM    PUNCHDCB+(DCBRECFM-IHADCB),DCBRECSB     VS OR VBS ?
         BZ    DCBEXTV6            IF NOT, CONSIDER LRECL EQ 0
         CH    R15,LRECLX          IS LRECL=X?
         BNE   DCBEXTV6            IF NOT, LRECL EQ 0
*        RECFM=VS OR VBS, BLKSIZE EQ 0, LRECL EQ X
         LA    R1,252              SET DEFAULT BLKSIZE-4 = 252
         B     DCBEXTV7            GO DETERMINE BLKSIZE TO USE
*        RECFM=V, VS, VB, OR VBS, BLKSIZE EQ 0, LRECL NE (0 OR X)
DCBEXTV5 DS    0H
         LR    R1,R15              SET BLKSIZE-4=LRECL
         B     DCBEXTV7
*        RECFM=V, VS, VB, OR VBS, BLKSIZE EQ 0, LRECL EQ 0
DCBEXTV6 DS    0H
         LA    R15,84              SET LRECL=84
         LR    R1,R15              SET BLKSIZE-4=LRECL
         B     DCBEXTV7
*
*        RECFM=V, VS, VB, OR VBS, BLKSIZE EQ 0,
*        AND LRECL HAS BEEN ESTABLISHED.
*        IF BLOCKING IS REQUESTED, SET BLKSIZE TO A MULTIPLE OF LRECL.
DCBEXTV7 DS    0H
         TM    PUNCHDCB+(DCBRECFM-IHADCB),DCBRECBR   RECORDS BLOCKED?
         BZ    DCBEXTV8            LEAVE BLKSIZE=LRECL IF NOT
         CH    R1,=Y(256)          IF BLKSIZE GT 256
         BH    DCBEXTV8            LEAVE BLKSIZE AS PREVIOUSLY SET
         MH    R1,=Y(10)           MULTIPLY BLKSIZE BY 10
         B     DCBEXTV8            GO RECALCULATE BLKSIZE
*
*
*        RE-ESTABLISH THE TRUE BLKSIZE VALUE.
DCBEXTV8 DS    0H
         A     R1,=A(4)            REESTABLISH BLKSIZE
         B     DCBEXTND
*
*
*        RETURN FROM THE DCB EXIT  ROUTINE
*
DCBEXTND DS    0H
         STH   R15,PUNCHDCB+(DCBLRECL-IHADCB)    STORE LRECL
         STH   R15,MAXLRECL        SAVE MAXIMUM LRECL
         STH   R1,PUNCHDCB+(DCBBLKSI-IHADCB)     STORE BLKSIZE
         TM    PUNCHDCB+(DCBRECFM-IHADCB),DCBRECU    RECFM=U?
         BO    DCBEXTN9            IF RECFM=U, PROCESSING COMPLETE
         TM    PUNCHDCB+(DCBRECFM-IHADCB),DCBRECF    RECFM=F?
         BO    DCBEXTN9            IF RECFM=F, PROCESSING COMPLETE
         TM    PUNCHDCB+(DCBRECFM-IHADCB),DCBRECV+DCBRECSB VS OR VBS?
         BNO   DCBEXTN9            IF NOT, DCB PROCESSING COMPLETE
         CH    R15,LRECLX          IS LRECL=X?
         BNE   DCBEXTN9            IF NOT, DCB PROCESSING COMPLETE
         LR    R0,R1               SET
         S     R0,=A(4)            MAXLRECL
         STH   R0,MAXLRECL         EQUAL TO BLKSIZE-4
DCBEXTN9 BR    RLINK               RETURN TO OPEN ROUTINE
         TITLE  'IEFPARAM - CURRENT RECORD INITIALIZATION ROUTINE'
*
*
*        CLEAR RECORD ASSMEBLY AREA SUBROUTINE
*
*
CLEAR    DS    0H
         L     RDATA,DATAPTR       FIRST OUTPUT DATA BYTE
         LH    RDATAND,MAXLRECL    LOAD MAXIMUM RECORD SIZE
         AR    RDATAND,RDATA       LAST DATA BYTE+1
         ST    RDATAND,DATAEND     SAVE ADDR LAST BYTE +1
         BCTR  RDATAND,0           LAST DATA BYTE
         ST    RDATAND,DATANDPT    SAVE LAST DATA BYTE ADDRESS
         LA    RDATAINC,256        INCREMENT FOR BXH
CLEAR01  DS    0H
         BXH   RDATA,RDATAINC,CLEAR05   IF LESS THAN 256 BYTES REMAIN
         SR    RDATA,RDATAINC           BACK UP FROM BXH
         MVI   0(RDATA),X'40'           CLEAR
         MVC   1(255,RDATA),0(RDATA)    256 BYTES TO BLANK
         AR    RDATA,RDATAINC           FIRST SUCCEEDING BYTE
         B     CLEAR01                  AND LOOP
*
CLEAR05  DS    0H
         SR    RDATA,RDATAINC      BACK UP FROM BXH
         LR    RDATAINC,RDATAND    COMPUTE LENGTH
         SR    RDATAINC,RDATA      TO MOVE
         BM    CLEAR08             FIELD EMPTY
         MVI   0(RDATA),X'40'      CLEAR FIRST BYTE
         BZ    CLEAR08             IF ONLY ONE BYTE TO CLEAR
         BCTR  RDATAINC,0          ONE LESS THAN TOTAL LENGTH
         EX    RDATAINC,CLEARMVC   IF MORE THAN ONE BYTE TO CLEAR
*        COMPLETE CLEARING THE RECORD ASSEMBLY AREA.
CLEAR08  DS    0H
         L     RDATA,DATAPTR
         ST    RDATA,DATAORG       SET DATA ORIGIN FOR F AND U
         ST    RDATA,DATANEXT      NEXT DATA BYTE  FOR F AND U
         L     RDATAND,DATANDPT
         LA    RDATAINC,1
         TM    PUNCHDCB+(DCBRECFM-IHADCB),DCBRECU  IF RECFM=U
         BOR   RLINK                               RETURN TO CALLER
         TM    PUNCHDCB+(DCBRECFM-IHADCB),DCBRECF  IF RECFM=F
         BOR   RLINK                               RETURN TO CALLER
*        BUILD RDW FOR RECFM=V, VS, VB, OR VBS
         LH    R0,MAXLRECL         LOAD RECORD LENGTH
         SLL   R0,16               SHIFT TO LEFT HALFWORD
         ST    R0,PACKAREA         STORE IN HOLD AREA
         MVC   0(4,RDATA),PACKAREA MOVE TO RECORD AREA
         LA    RDATA,4(,RDATA)     INCREMENT DATA ADDRESS
         ST    RDATA,DATAORG       SET DATA ORIGIN FOR RECFM=V
         ST    RDATA,DATANEXT      NEXT DATA BYTE  FOR RECFM=V
         BR    RLINK               AND RETURN
CLEARMVC MVC   1(*-*,RDATA),0(RDATA)
         TITLE  'IEFPARAM - WRITE FORMAT F AND U RECORDS'
*
*
*        WRITE FORMAT F RECORDS
*
*
PUTF     DS    0H                  ENTRY FOR FORMAT F RECORDS
PUTU     DS    0H                  ENTRY FOR FORMAT U RECORDS
         ST    RLINK,PUTLINK       SAVE RETURN REGISTER VALUE
         PUT   PUNCHDCB            GET AN AREA IN THE BUFFER
         L     RDATA,DATAPTR       FIRST OUTPUT DATA BYTE
         LH    RDATAND,PUNCHDCB+(DCBLRECL-IHADCB) LOAD RECORD SIZE
         AR    RDATAND,RDATA       LAST DATA BYTE+1
         BCTR  RDATAND,0           LAST DATA BYTE
         LA    RDATAINC,256        INCREMENT FOR BXH
PUTF01   DS    0H
         BXH   RDATA,RDATAINC,PUTF05    IF LESS THAN 256 BYTES REMAIN
         SR    RDATA,RDATAINC           BACK UP FROM BXH
         MVC   0(256,R1),0(RDATA)       MOVE 256 BYTES OF THE RECORD
         AR    RDATA,RDATAINC           FIRST SUCCEEDING BYTE
         AR    R1,RDATAINC              NEXT AVAILABLE BYTE IN RECORD
         B     PUTF01                   AND LOOP
*
PUTF05   DS    0H
         SR    RDATA,RDATAINC      BACK UP FROM BXH
         LR    RDATAINC,RDATAND    COMPUTE LENGTH
         SR    RDATAINC,RDATA      TO MOVE
         BM    PUTF08              FIELD EMPTY
         MVC   0(1,R1),0(RDATA)    MOVE FIRST REMAINING BYTE
         BZ    PUTF08              IF ONLY ONE BYTE TO MOVE
         BCTR  RDATAINC,0          ONE LESS THAN TOTAL LENGTH
         EX    RDATAINC,PUTFMVC    IF MORE THAN ONE BYTE TO MOVE
*        FINISH COPYING THE RECORD ASSEMBLY AREA.
PUTF08   DS    0H
         L     RLINK,PUTLINK       RELOAD RETURN REGISTER VALUE
         BR    RLINK               RETURN TO CALLER
         SPACE 5
PUTFMVC  MVC   1(*-*,R1),1(RDATA)  MOVE REMAINING RECORD DATA
 TITLE  'IEFPARAM - WRITE FORMAT V RECORDS (SPANNED + UNSPANNED)'
*
*
*        WRITE FORMAT V RECORDS
*
*
PUTV     DS    0H                  ENTRY FOR FORMAT V RECORDS
         ST    RLINK,PUTLINK       SAVE RETURN REGISTER VALUE
         L     RDATA,DATAPTR       FIRST OUTPUT RECORD BYTE
         LH    RDATAINC,PUNCHDCB+(DCBLRECL-IHADCB) LOAD RECORD SIZE
         LA    RDATAND,0(RDATAINC,RDATA)     LAST DATA BYTE+1
         BCTR  RDATAND,0                     LAST DATA BYTE
         A     RDATA,=A(4)         FIRST OUTPUT DATA BYTE
         XC    PUTSEGNO,PUTSEGNO   CLEAR SEGMENT NUMBER COUNTER
*
*
*
*        BUILD THE INTERMEDIATE RECORD SEGMENTS
PUTV01   DS    0H
*
*        COMPUTE THE LENGTH OF THE SEGMENT THAT WOULD
*        CONTAIN THE REMAINDER OF THE RECORD.
         LA    RDATAINC,1(,RDATAND)     LAST DATA BYTE +1
         SR    RDATAINC,RDATA           COMPUTE REMAINING LENGTH
         BNP   PUTV08                   IF RECORD DATA EXHAUSTED
         A     RDATAINC,=A(4)      COMPUTE DESIRED SEGMENT SIZE
         STH   RDATAINC,PUNCHDCB+(DCBLRECL-IHADCB)     LENGTH IN DCB
*
*        UPDATE SEGMENT NUMBER
         L     R1,PUTSEGNO         LOAD PREVIOUS SEGMENT NUMBER
         A     R1,=A(1)            INCREMENT SEGMENT NUMBER
         ST    R1,PUTSEGNO         STORE UPDATED SEGMENT NUMBER
*
*        GET A SEGMENT AREA.
         PUT   PUNCHDCB            GET NEXT SEGMENT AREA
         TM    PUNCHDCB+(DCBRECFM-IHADCB),DCBRECSB  VS OR VBS?
         BO    *+L'*+2             IF SPANNED, R0 SET BY SYSTEM
         LR    R0,RDATAINC         SET R0 TO LENGTH OF RECORD
*
*        INITIALIZE REGISTERS FOR PROCESSING THE SEGMENT.
         LR    RSEGA,R1            SEGMENT ORIGIN ADDRESS
         LR    RSEGINC,R0          CURRENT SEGMENT AREA SIZE
         CR    RSEGINC,RDATAINC    COMPARE TO DESIRED SIZE
         BNH   *+L'*+2             BRANCH IF NOT EXCEEDED
         LR    RSEGINC,RDATAINC    IF LARGER, SUBSTITUTE RECORD SIZE
         LA    RSEGND,0(RSEGINC,RSEGA)   LAST SEGMENT BYTE+1
         BCTR  RSEGND,0                  LAST SEGMENT BYTE
*
*        INITIALIZE THE SDW FOR THE CURRENT SEGMENT.
         LR    R0,RSEGINC          LOAD SEGMENT AREA SIZE
         SLL   R0,16               SHIFT LENGTH TO HIGH-ORDER
         ST    R0,PACKAREA         STORE SDW IN WORK AREA
         MVC   0(4,RSEGA),PACKAREA MOVE SDW TO SEGMENT AREA
         CLC   PUTSEGNO,=A(1)      TEST FOR FIRST SEGMENT
         BH    PUTV01B             BRANCH IF NOT FIRST SEGMENT
*
*        COMPLETE THE SDW FOR THE FIRST SEGMENT
PUTV01A  DS    0H
         CR    RSEGINC,RDATAINC    WILL DATA FIT IN THIS SEGMENT?
         BNL   PUTV01C             BRANCH IF DATA WILL COMPLETELY FIT
         MVI   2(RSEGA),01         INDICATE FIRST SEGMENT
         B     PUTV01C             GO INITIALIZE REGISTERS
*
*        CONST RUCT THE SDW FOR TH E INTERMEDIATE AND LAST SEGMENTS
PUTV01B  DS    0H
         MVI   2(RSEGA),02         ASSUME LAST SEGMENT
         CR    RSEGINC,RDATAINC    WILL DATA FIT IN THIS SEGMENT?
         BNL   PUTV01C             BRANCH IF DATA WILL COMPLETELY FIT
         MVI   2(RSEGA),03         INDICATE INTERMEDIATE SEGMENT
         B     PUTV01C             GO INITIALIZE REGISTERS
*
*        INITIALIZE REGISTERS FOR THE BXH MOVE LOOP.
PUTV01C  DS    0H
         A     RSEGA,=A(4)         FIRST DATA BYTE IN SEGMENT AREA
         LA    RSEGINC,256         SET INCREMENT FOR THE BXH MOVE LOOP
         B     PUTV02              GO MOVE THE SEGMENT DATA.
*
*
*        INITIALIZE REGISTERS FOR  BXH MOVE LOOP.
PUTV02   DS    0H
PUTV02A  DS    0H
         BXH   RSEGA,RSEGINC,PUTV02B    BR IF LT 256 BYTES REMAIN
         SR    RSEGA,RSEGINC            BACK UP FROM BXH
         MVC   0(256,RSEGA),0(RDATA)    MOVE 256 RECORD BYTES TO SEG.
         AR    RDATA,RSEGINC            NEXT AVAILABLE BYTE IN RECORD
         AR    RSEGA,RSEGINC            NEXT AVAILABLE BYTE IN SEGMENT
         B     PUTV02A                  AND LOOP
PUTV02B  DS    0H                  LESS THAN 256 BYTES REMAIN TO MOVE
         SR    RSEGA,RSEGINC       BACK UP FROM BXH
         LR    RSEGINC,RSEGND      COMPUTE LENGTH-1
         SR    RSEGINC,RSEGA       FOR MVC
         BM    PUTV02D             FIELD EMPTY
         MVC   0(1,RSEGA),0(RDATA) MOVE FIRST REMAINING BYTE
         BZ    PUTV02C             IF ONLY ONE BYTE TO MOVE
         BCTR  RSEGINC,0           TWO LESS THAN TOTAL LENGTH
         EX    RSEGINC,PUTVMVC     IF MORE THAN ONE BYTE TO MOVE
         LA    RSEGINC,1(,RSEGINC) COMPENSATE FOR BCTR
         B     PUTV02C             COPYING OF RECORD COMPLETE
PUTV02C  DS    0H
         LA    RDATA,1(RSEGINC,RDATA)       NEXT AVAIL DATA BYTE
PUTV02D  DS    0H
         B     PUTV01              LOOP TO BUILD NEXT SEGMENT
*
*
*
*        COPYING OF THE RECORD ASSEMBLY AREA IS COMPLETE.
PUTV08   DS    0H
         L     RLINK,PUTLINK       RELOAD RETURN REGISTER VALUE
         BR    RLINK               RETURN TO CALLER
         SPACE 5
PUTVMVC  MVC   1(*-*,RSEGA),1(RDATA)      MOVE REMAINING RECORD DATA
         TITLE 'IEFPARAM - MODULE  CONSTANTS'
WORKSIZE DC    0A(0),AL1(01),AL3(LENSECT) SP&SIZE FOR GM/FM
LRECLX   DC    0Y(0),X'8000'
OPENLST1 OPEN  (*-*,(OUTPUT,LEAVE)),MF=L
CLOSLST1 CLOSE (*-*,LEAVE),MF=L
DCBLIST1 DCB   DSORG=PS,DEVD=DA,MACRF=PL,DDNAME=SYSPUNCH
         LTORG  *
         END   IEFPARAM
