 TITLE 'AMAVZAP - PRODUCE AMASPZAP CONTROL TO ALTER DATSET ATTRIBUTES';
   *
  /* PROGRAM DESCRIPTION:                                    */
  /*    THIS PROGRAM PROCESSES A CONTROL STATEMENT INPUT     */
  /*    FILE AGAINST A VOLUME'S VTOC AND PRODUCES THE        */
  /*    AMASPZAP CONTROL STATEMENTS REQUIRED TO UPDATE THE   */
  /*    FORMAT 1 DSCB ENTRIES TO ACHIEVE THE RESULTS         */
  /*    SPECIFIED BY THE CONTROL STATEMENT INPUT FILE.       */
  /***********************************************************/
  /*                                                         */
  /*>>>>>>>>>>>>>>C U I C   D I S C L A I M E R<<<<<<<<<<<<<<*/
  /*                                                         */
  /***********************************************************/
  /*            THE INFORMATION OR MATERIAL BEING PROVIDED   */
  /*      BY COMMERCIAL UNION INSURANCE COMPANY (CUIC),      */
  /*      WHETHER IN HARD COPY OR MACHINE READABLE FORM,     */
  /*      HAS BEEN DEVELOPED BY CUIC FOR ITS OWN PURPOSE     */
  /*      AND FOR USE ON ITS OWN EQUIPMENT AND WITHIN ITS    */
  /*      OWN DATA PROCESSING SYSTEM.  CUIC MAKES NO         */
  /*      REPRESENTATIONS OR WARRANTIES WHATSOEVER WITH      */
  /*      RESPECT TO THE INFORMATION OR MATERIAL FURNISHED   */
  /*      HEREUNDER, EXPRESSED OR IMPLIED, INCLUDING BUT     */
  /*      NOT LIMITED TO ANY REPRESENTATION OR WARRANTY OF   */
  /*      MERCHANTABILITY OR FITNESS FOR ANY PARTICULAR USE  */
  /*      OR PURPOSE OR THAT THE USE OF THE INFORMATION OR   */
  /*      MATERIAL WILL NOT INFRINGE ANY PATENT, COPYRIGHT,  */
  /*      TRADEMARK, OR OTHER PROPRIETARY INTEREST.  YOU     */
  /*      ARE, THEREFORE, ACCEPTING THIS INFORMATION OR      */
  /*      MATERIAL ON AN "AS IS" BASIS AND WILL BE USING IT  */
  /*      AT YOUR OWN RISK.  NEITHER CUIC NOR ANY OF ITS     */
  /*      AFFILIATES SHALL BE LIABLE WITH RESPECT TO ANY     */
  /*      CLAIM, ACTION, OR DEMAND BY ANY USER OR OTHER      */
  /*      PARTY (INCLUDING ANY CLAIM, ACTION, OR DEMAND FOR  */
  /*      CONSEQUENTIAL DAMAGES EVEN IF CUIC HAS BEEN        */
  /*      ADVISED OF THE POSSIBILITY OF SUCH DAMAGES)        */
  /*      ARISING FROM THE USE OF THE INFORMATION OR THE     */
  /*      MATERIALS AND CONCEPTS RELATED THERETO.            */
  /*      FURTHERMORE, CUIC WILL NOT MAINTAIN, CORRECT, OR   */
  /*      UPDATE THIS INFORMATION OR MATERIAL IN THE         */
  /*      FUTURE.                                            */
  /*                                              01/26/83   */
  /***********************************************************/
  /*                                                         */;
 DATA  ZAPCTL(KEEP=     ZAPDSNAM  ZAPDSNLN  CTL_CT   CTL1-CTL16);
 TITLE3 '--LISTING OF CONTROL CARD INPUT AND DIAGNOSTIC MESSAGES--';
 TITLE4 ' ';
       FORMAT ZAPDSNAM  $44.      ZAPDSNLN  Z2.      CTL_CT    Z2.
              CTL1-CTL16 $64.     CTL_IX    Z2.
              CTL_LN    Z2.
              CTL_KEY   $32.      CTL_KEYL  Z2.
              CTL_STR   $64.      CTL_STRL  Z2.      CTL_VAL   9.
              CTL_CHR   $CHAR1.   CHR_CT    Z2.
              VAL_FLG   1.        ERR_FLG   1.       ERR_CT    Z2.
              CHR_ERR   1.        CHR_FLG   1.
              NW1RECFM  HEX2.
              ;
       ARRAY  CTL(CTL_IX)         CTL1-CTL16;
       SKIP 1;
       *-----DEFINE THE INPUT FILE CONTAINING CONTROL CARDS------*;
       INFILE SYSIN    EOF=SIN_EOF  LINESIZE=72  MISSOVER;
       *-----DEFINE THE LIST FILE USED FOR LOGGING INPUT CARDS+MSGS--*;
       FILE PRINT      ;
       SKIP 1;
       *-----READ THE DATA SET NAME-------;
       INPUT  ZAPDSNAM : $44. @;
       *-----LIST THE INPUT RECORD JUST READ.---------*;
       PUT   @001 'INPUT RECORD #' _N_ Z3. ' :' _INFILE_;
       *-----CODE LENGTH FOR DSNAME-------;
       IF     ZAPDSNAM ^= ' '
         THEN ZAPDSNLN = LENGTH(ZAPDSNAM);
         ELSE ZAPDSNLN = 0;
       SKIP 1;
       *-----ELIMINATE BLANK CARDS AND COMMENTS FROM PROCESSING---*;
       IF     ZAPDSNLN = 0               THEN DELETE;
       IF     SUBSTR(ZAPDSNAM,1,1) = '*' THEN DELETE;
       SKIP 1;
       *-----INITIALIZE FOR PROCESSING CONTROL INFORMATION-----*;
       DO OVER CTL;   CTL = ' ';    END;
       CTL_IX = 0;    CTL_CT = 0;   ERR_CT  = 0;   ERR_FLG = 0;
       PAGE;
       *-----READ THE CONTROL INFORMATION ---------------;
       DO UNTIL(CTL = ' ' OR CTL_IX GE 16 );
          IF     ERR_FLG = 0 THEN CTL_IX = CTL_IX + 1 /*BUMP INDEX */;
          INPUT  CTL : $64.  @         /*READ THE NEXT CONTROL ITEM*/;
          SKIP 1;
          IF     CTL ^= ' '           /*VALIDATE THE CONTROL ITEM */
            THEN
              DO;
                ERR_FLG = 0         /*CLEAR ERROR FLAG FOR THIS ITEM*/;
                VAL_FLG = 0         /*SET VALIDATION FLAG TO ZERO*/;
                CTL_LN   = LENGTH(CTL)       /*CONTROL ITEM LENGTH  */;
                CTL_KEYL = INDEX(CTL,'=') /*TENTATIVE KEYWORD LENGTH*/;
                IF     CTL_KEYL > 0         /*IF WE HAVE A KEYWORD*/
                  THEN CTL_KEY  = SUBSTR(CTL,1,CTL_KEYL)   /*KEYWORD*/;
                  ELSE CTL_KEY  = CTL      /*CONTROL ITEM IS KEYWORD*/;
                CTL_KEYL = LENGTH(CTL_KEY)   /*ACTUAL KEYWORD LENGTH*/;
                CTL_STRL = CTL_LN - CTL_KEYL   /*VALUE STRING LENGTH*/;
                IF     CTL_STRL > 0      /*IF WE HAVE A VALUE STRING*/
                  THEN CTL_STR  = SUBSTR(CTL,CTL_KEYL+1,CTL_STRL);
                  ELSE CTL_STR  = ' '   /*CONTROL ITEM VALUE IS NULL*/;
                IF     CTL_STRL > 0      /*IF WE HAVE A VALUE STRING*/
                   AND                   /*AND IF ITS ALL NUMERIC,  */
                       (VERIFY(TRIM(CTL_STR),'0123456789') EQ 0)
                  THEN CTL_VAL  = INPUT(CTL_STR,32.) /*GET NUM EQUIV*/;
                  ELSE CTL_VAL  = .  /*CONTROL ITEM VALUE IS MISSING*/;
                SKIP 2;
                IF CTL_KEY = 'BLKL8'     THEN VAL_FLG = 1;
                IF CTL_KEY = 'BLKSIZE='  THEN LINK VAL_LNTH;
                IF CTL_KEY = 'CHANGE'    THEN VAL_FLG = 1;
                IF CTL_KEY = 'CREDT='    THEN LINK VAL_DATE;
                IF CTL_KEY = 'DSEOF'     THEN VAL_FLG = 1;
                IF CTL_KEY = 'DSORG='    THEN LINK VAL_DSRG;
                IF CTL_KEY = 'EXPDT='    THEN LINK VAL_DATE;
                IF CTL_KEY = 'HSM'       THEN VAL_FLG = 1;
                IF CTL_KEY = 'LRECL='    THEN LINK VAL_LRCL;
                IF CTL_KEY = 'KEYLEN='   THEN LINK VAL_LNTH;
                IF CTL_KEY = 'NEWNAME='  THEN LINK VAL_DSN;
                IF CTL_KEY = 'NOBLKL8'   THEN VAL_FLG = 1;
                IF CTL_KEY = 'NOCHANGE'  THEN VAL_FLG = 1;
                IF CTL_KEY = 'NODSEOF'   THEN VAL_FLG = 1;
                IF CTL_KEY = 'NOHSM'     THEN VAL_FLG = 1;
                IF CTL_KEY = 'NOPASWRD'  THEN VAL_FLG = 1;
                IF CTL_KEY = 'NOPWREAD'  THEN VAL_FLG = 1;
                IF CTL_KEY = 'NORACF'    THEN VAL_FLG = 1;
                IF CTL_KEY = 'PASSWORD'  THEN VAL_FLG = 1;
                IF CTL_KEY = 'RACF'      THEN VAL_FLG = 1;
                IF CTL_KEY = 'RECFM='    THEN LINK VAL_RCFM;
                IF CTL_KEY = 'REFDT='    THEN LINK VAL_DATE;
                IF CTL_KEY = 'RETPD='    THEN LINK VAL_RTPD;
                IF CTL_KEY = 'RKP='      THEN LINK VAL_LNTH;
                IF CTL_KEY = 'VOLCT='    THEN LINK VAL_CT;
                IF CTL_KEY = 'VOLSQ='    THEN LINK VAL_CT;
                PAGE;
                IF VAL_FLG EQ 0
                   THEN DO;
                           PUT @007 'UNRECOGNIZED CONTROL ITEM: "'
                                     CTL $VARYING64. CTL_LN
                                    '" INPUT CARD #'
                                     _N_ ', ITEM #' CTL_IX;
                           ERR_FLG = 1 /*SET CONTROL ITEM ERROR FLAG*/;
                        END;
                IF ERR_FLG EQ 1 THEN ERR_CT = ERR_CT + 1;
              END;
       END          /*END OF CONTROL INFORMATION PROCESSING*/;
       SKIP 3;
       *----ADJUST INDEX VALUES, AND WRITE WRAPUP DIAGNOSTICS-----*;
       IF CTL = ' ' THEN  CTL_IX = CTL_IX - 1 /*IF NULL, BACK OFF*/;
       CTL_CT = CTL_IX  /*SET ARRAY ELEMENT COUNT*/;
       *-----NOTE THE NUMBER OF ITEMS IN ERROR------------------*;
       IF ERR_CT GT 0           /*IF ITEMS WERE IN ERROR      */
         THEN
              PUT @007 'INPUT CARD #' _N_
                       'CONTAINED ' ERR_CT : 2.
                       'CONTROL ITEM(S) IN ERROR';
       *-----NOTE WHETHER THE CARD CONTAINED VALID CONTROL ITEMS--*;
       IF     CTL_CT = 0 /*IF INFO WAS MISSING OR EVERYTHING WAS BAD*/
         THEN
              PUT @007 'INPUT CARD #' _N_
                       'CONTAINED NO VALID CONTROL INFORMATION '
                       'TO PROCESS';
       *-----WRITE A BLANK LINE FOLLOWING A CONTROL RECORD.-------*;
       PUT    ' ';
       *-----DELETE OBSERVATIONS THAT DONT CONTRIBUTE-------------*;
       IF     CTL_CT = 0
         THEN DELETE       /*DELETE OBSERVATIONS WITH NO ITEMS*/;
       *-----WRITE THE ZAP CONTROL OBSERVATION DATA---------------*;
       OUTPUT;
       RETURN      /*END OF MAINLINE ROUTINE FOR CREATING ZAPCTL*/;
       SKIP 3;
       *-----PROCESS END OF DATA ON THE INPUT DATA SET.-----------*;
       SIN_EOF:    /*END OF SYSIN DATA SET ROUTINE*/;
         STOP;
         RETURN;
       PAGE;
       VAL_DATE:   /*VALIDATE KEYWORD=DATE CONTROL ITEMS*/;
         VAL_FLG = 1    /*INDICATE CONTROL ITEM RECOGNIZED*/;
         ERR_FLG = 1    /*ASSUME CONTROL ITEM ERROR       */;
       SKIP 1;
         IF    (CTL_STRL EQ 5 )
           THEN IF (CTL_STR EQ '00000' OR DATEJUL(CTL_VAL)  NE .)
                THEN ERR_FLG = 0;
         IF    (CTL_STRL EQ 7 )
           THEN IF (INPUT(CTL_STR,DATE7.)    NE .)
                THEN ERR_FLG = 0;
         IF    (CTL_STRL EQ 8 )
           THEN IF (INPUT(CTL_STR,MMDDYY8.)  NE .)
                THEN ERR_FLG = 0;
         IF    (CTL_STRL EQ 9 )
           THEN IF (INPUT(CTL_STR,DATE9.)    NE .)
                THEN ERR_FLG = 0;
         _ERROR_ = 0;  /*RESET SAS ERROR INDICATOR       */;
       SKIP 1;
         IF  ERR_FLG = 1   /*IF DATE ITEM FORMAT IS INVALID*/
           THEN DO;
                  PUT @007 'ERROR: DATE VALUE MUST CONSIST OF '
                           '"00000", '
                           'A 5 DIGIT JULIAN DATE, ' ;
                  PUT @014 'A 7 CHAR SAS DATE7. VALUE, '
                           'AN 8 CHAR SAS MMDDYY8. VALUE, ' ;
                  PUT @014 'OR '
                           'A 9 CHAR SAS DATE9. VALUE, '
                           '"'  CTL $VARYING64. CTL_LN '" '
                           'IS INVALID';
                END;
         RETURN;
       PAGE;
       VAL_DSRG:   /*VALIDATE DSORG=STRING CONTROL ITEM*/;
         VAL_FLG = 1    /*INDICATE CONTROL ITEM RECOGNIZED*/;
         *-----PROCESS THE DSORG= CONTROL STRING ------------------*;
         ERR_FLG = 1    /*ASSUME CONTROL ITEM ERROR*/;
         IF   CTL_VAL =  0      THEN ERR_FLG = 0;
         IF   CTL_STR =: 'AM'   THEN ERR_FLG = 0;
         IF   CTL_STR =: 'DA'   THEN ERR_FLG = 0;
         IF   CTL_STR =: 'DAU'  THEN ERR_FLG = 0;
         IF   CTL_STR =: 'IS'   THEN ERR_FLG = 0;
         IF   CTL_STR =: 'ISU'  THEN ERR_FLG = 0;
         IF   CTL_STR =: 'PO'   THEN ERR_FLG = 0;
         IF   CTL_STR =: 'POU'  THEN ERR_FLG = 0;
         IF   CTL_STR =: 'PS'   THEN ERR_FLG = 0;
         IF   CTL_STR =: 'PSU'  THEN ERR_FLG = 0;
         IF   ERR_FLG = 1
           THEN DO;
                  PUT @007 'ERROR: "'
                            CTL $VARYING64. CTL_LN
                           '" DOES NOT SPECIFY '
                           '0, '
                           'AM, '
                           'DA, '
                           'DAU, '
                           'IS, '
                           'ISU, '
                           'PO, '
                           'POU, '
                           'PS, '
                           'OR '
                           'PSU.';
                END;
         RETURN;
       PAGE;
       VAL_CT:     /*VALIDATE KEYWORD=COUNT CONTROL ITEMS*/;
         VAL_FLG = 1    /*INDICATE CONTROL ITEM RECOGNIZED*/;
         IF      CTL_STRL LT 1
             OR  CTL_STRL GT 5
             OR (1 <= CTL_STRL <= 5 AND CTL_VAL EQ .)
           THEN DO;
                  PUT @007 'ERROR: COUNTH VALUE MUST CONSIST OF '
                           '1 TO 5 NUMERIC DIGITS, "'
                            CTL $VARYING64. CTL_LN
                           '" IS INVALID';
                  ERR_FLG = 1    /*INDICATE CONTROL ITEM ERROR*/;
                END;
           ELSE DO;         /*IF FORMAT OF COUNT VALUE IS CORRECT*/
                  IF     CTL_VAL > 32767
                    THEN DO;
                           PUT @007 'ERROR: "'
                                     CTL $VARYING64. CTL_LN
                                    '" COUNT VALUE (' CTL_VAL
                                    ') IS GREATER THAN 32767';
                           ERR_FLG = 1 /*CONTROL ITEM ERROR*/;
                         END;
                END;
         RETURN;
       PAGE;
       VAL_LNTH:   /*VALIDATE KEYWORD=LENGTH CONTROL ITEMS*/;
         VAL_FLG = 1    /*INDICATE CONTROL ITEM RECOGNIZED*/;
         IF      CTL_STRL LT 1
             OR  CTL_STRL GT 5
             OR (1 <= CTL_STRL <= 5 AND CTL_VAL EQ .)
           THEN DO;
                  PUT @007 'ERROR: LENGTH VALUE MUST CONSIST OF '
                           '1 TO 5 NUMERIC DIGITS, "'
                            CTL $VARYING64. CTL_LN
                           '" IS INVALID';
                  ERR_FLG = 1    /*INDICATE CONTROL ITEM ERROR*/;
                END;
           ELSE DO;         /*IF FORMAT OF DATE VALUE IS CORRECT*/
                  IF     CTL_KEY =: 'BLKSIZE='
                    AND (0 < CTL_VAL <18 OR CTL_VAL > 32767)
                    THEN DO;
                           PUT @007 'ERROR: BLOCK SIZE VALUE (' CTL_VAL
                                    ') IS LESS THAN 18 '
                                    'OR GREATER THAN 32767';
                           ERR_FLG = 1 /*CONTROL ITEM ERROR*/;
                         END;
                  IF     CTL_KEY =: 'KEYLEN='
                    AND  CTL_VAL > 255
                    THEN DO;
                           PUT @007 'ERROR: "'
                                     CTL $VARYING64. CTL_LN
                                    '" SIZE VALUE (' CTL_VAL 5.
                                    ') IS GREATER THAN 255';
                           ERR_FLG = 1 /*CONTROL ITEM ERROR*/;
                         END;
                  IF     CTL_KEY =: 'RKP='
                    AND  CTL_VAL > 32767
                    THEN DO;
                           PUT @007 'ERROR: "'
                                     CTL $VARYING64. CTL_LN
                                    '" SIZE VALUE (' CTL_VAL
                                    ') IS GREATER THAN 32767';
                           ERR_FLG = 1 /*CONTROL ITEM ERROR*/;
                         END;
                END;
         RETURN;
       PAGE;
       VAL_DSN:    /*VALIDATE NEWNAME=DSNAME CONTROL ITEM*/;
         VAL_FLG = 1    /*INDICATE CONTROL ITEM RECOGNIZED*/;
         IF      CTL_STRL LT 01
             OR  CTL_STRL GT 44
           THEN DO;
                  PUT @007 'ERROR: NEWNAME VALUE MUST CONSIST OF '
                           '1 TO 44 CHARACTERS, '
                            CTL $VARYING64. CTL_LN
                           '" IS INVALID';
                  ERR_FLG = 1    /*INDICATE CONTROL ITEM ERROR*/;
                END;
         RETURN;
       PAGE;
       VAL_LRCL:   /*VALIDATE LRECL=VALUE CONTROL ITEM*/;
         VAL_FLG = 1    /*INDICATE CONTROL ITEM RECOGNIZED*/;
         IF      CTL_STRL EQ 1 AND CTL_STR =  'X'
           THEN  CTL_VAL = 8000X;
         IF      CTL_STRL LT 1
             OR  CTL_STRL GT 5
             OR (1 LE CTL_STRL LE 5 AND CTL_VAL = .)
           THEN DO;
                  PUT @007 'ERROR: LRECL VALUE MUST CONSIST OF '
                           '1 TO 5 NUMERIC DIGITS '
                           'IN THE RANGE 0-32767, '
                           'OR THE CHARACTER X, '
                           '"'  CTL $VARYING64. CTL_LN '" '
                           'IS INVALID';
                  ERR_FLG = 1    /*INDICATE CONTROL ITEM ERROR*/;
                END;
           ELSE DO;         /*IF FORMAT OF DATE VALUE IS CORRECT*/
                  IF     CTL_STR ^=  'X'
                     AND CTL_VAL > 32767
                    THEN DO;
                           PUT @007 'ERROR: "'
                                     CTL $VARYING64. CTL_LN
                                    '" SIZE VALUE (' CTL_VAL
                                    ') IS GREATER THAN 32767';
                           ERR_FLG = 1 /*CONTROL ITEM ERROR*/;
                         END;
                END;
         RETURN;
       PAGE;
       VAL_RCFM:   /*VALIDATE RECFM=CHRS CONTROL ITEM*/;
         VAL_FLG = 1    /*INDICATE CONTROL ITEM RECOGNIZED*/;
         *-----PROCESS THE RECFM= CONTROL STRING CHAR BY CHAR.-----*;
         NW1RECFM = 0              /*CLEAR RECFM BIT MASK TO ZERO*/;
         DO   CHR_CT = 1 TO CTL_STRL;
           CHR_ERR = 0   /*RESET INVALID CHARACTER FLAG*/;
           CHR_FLG = 0   /*RESET CHARACTER UNRECOGNIZED FLAG*/;
           CTL_CHR = SUBSTR(CTL_STR,CHR_CT,1);     /*CURRENT CHAR*/
           SKIP 5;
           IF   CTL_CHR = '0'
           THEN DO;
                  CHR_FLG = 1    /*CONTROL CHARACTER RECOGNIZED*/;
                  IF CTL_STR = '0' OR CTL_STR = '00'
                    THEN NW1RECFM=0;
                    ELSE DO;
                           PUT @007 'ERROR: RECFM= CHARACTER VALUE "'
                                     CTL_CHR $CHAR1.
                                    '" IS ONLY VALID WHEN '
                                    'RECFM=0 OR RECFM=00 '
                                    'HAS BEEN SPECIFIED.';
                           CHR_ERR = 1    /*CONTROL ITEM ERROR*/;
                         END;
                END;
           PAGE;
           IF   CTL_CHR = 'F'
           THEN DO;
                  CHR_FLG = 1    /*CONTROL CHARACTER RECOGNIZED*/;
                  IF NW1RECFM = '11......'B
                    THEN DO;
                           PUT @007 'ERROR: RECFM= CHARACTER VALUE "'
                                     CTL_CHR $CHAR1.
                                    '" CONFLICTS WITH PREVIOUS "U"'
                                    ' SPECIFICATION.';
                           CHR_ERR = 1    /*CONTROL ITEM ERROR*/;
                         END;
                  IF NW1RECFM = '10......'B
                    THEN DO;
                           PUT @007 'ERROR: RECFM= CHARACTER VALUE "'
                                     CTL_CHR $CHAR1.
                                    '" DUPLICATES PREVIOUS "F"'
                                    ' SPECIFICATION.';
                           CHR_ERR = 1    /*CONTROL ITEM ERROR*/;
                         END;
                  IF NW1RECFM = '01......'B
                    THEN DO;
                           PUT @007 'ERROR: RECFM= CHARACTER VALUE "'
                                     CTL_CHR $CHAR1.
                                    '" CONFLICTS WITH PREVIOUS "V"'
                                    ' SPECIFICATION.';
                           CHR_ERR = 1    /*CONTROL ITEM ERROR*/;
                         END;
                  IF NW1RECFM = '00......'B
                    THEN NW1RECFM = NW1RECFM + 80X;
                END;
           PAGE;
           IF   CTL_CHR = 'V'
           THEN DO;
                  CHR_FLG = 1    /*CONTROL CHARACTER RECOGNIZED*/;
                  IF NW1RECFM = '11......'B
                    THEN DO;
                           PUT @007 'ERROR: RECFM= CHARACTER VALUE "'
                                     CTL_CHR $CHAR1.
                                    '" CONFLICTS WITH PREVIOUS "U"'
                                    ' SPECIFICATION.';
                           CHR_ERR = 1    /*CONTROL ITEM ERROR*/;
                         END;
                  IF NW1RECFM = '10......'B
                    THEN DO;
                           PUT @007 'ERROR: RECFM= CHARACTER VALUE "'
                                     CTL_CHR $CHAR1.
                                    '" CONFLICTS WITH PREVIOUS "F"'
                                    ' SPECIFICATION.';
                           CHR_ERR = 1    /*CONTROL ITEM ERROR*/;
                         END;
                  IF NW1RECFM = '01......'B
                    THEN DO;
                           PUT @007 'ERROR: RECFM= CHARACTER VALUE "'
                                     CTL_CHR $CHAR1.
                                    '" DUPLICATES PREVIOUS "V"'
                                    ' SPECIFICATION.';
                           CHR_ERR = 1    /*CONTROL ITEM ERROR*/;
                         END;
                  IF NW1RECFM = '00......'B
                    THEN NW1RECFM = NW1RECFM + 40X;
                END;
           PAGE;
           IF   CTL_CHR = 'U'
           THEN DO;
                  CHR_FLG = 1    /*CONTROL CHARACTER RECOGNIZED*/;
                  IF NW1RECFM = '11......'B
                    THEN DO;
                           PUT @007 'ERROR: RECFM= CHARACTER VALUE "'
                                     CTL_CHR $CHAR1.
                                    '" DUPLICATES PREVIOUS "U"'
                                    ' SPECIFICATION.';
                           CHR_ERR = 1    /*CONTROL ITEM ERROR*/;
                         END;
                  IF NW1RECFM = '10......'B
                    THEN DO;
                           PUT @007 'ERROR: RECFM= CHARACTER VALUE "'
                                     CTL_CHR $CHAR1.
                                    '" CONFLICTS WITH PREVIOUS "F"'
                                    ' SPECIFICATION.';
                           CHR_ERR = 1    /*CONTROL ITEM ERROR*/;
                         END;
                  IF NW1RECFM = '01......'B
                    THEN DO;
                           PUT @007 'ERROR: RECFM= CHARACTER VALUE "'
                                     CTL_CHR $CHAR1.
                                    '" CONFLICTS WITH PREVIOUS "V"'
                                    ' SPECIFICATION.';
                           CHR_ERR = 1    /*CONTROL ITEM ERROR*/;
                         END;
                  IF NW1RECFM = '00......'B
                    THEN NW1RECFM = NW1RECFM + 80X + 40X;
                END;
           PAGE;
           IF   CTL_CHR = 'T'
           THEN DO;
                  CHR_FLG = 1    /*CONTROL CHARACTER RECOGNIZED*/;
                  IF NW1RECFM = '..1.....'B
                    THEN DO;
                           PUT @007 'ERROR: RECFM= CHARACTER VALUE "'
                                     CTL_CHR $CHAR1.
                                    '" DUPLICATES PREVIOUS "T"'
                                    ' SPECIFICATION.';
                           CHR_ERR = 1    /*CONTROL ITEM ERROR*/;
                         END;
                    ELSE NW1RECFM = NW1RECFM + 20X;
                END;
           SKIP 3;
           IF   CTL_CHR = 'B'
           THEN DO;
                  CHR_FLG = 1    /*CONTROL CHARACTER RECOGNIZED*/;
                  IF NW1RECFM = '...1....'B
                    THEN DO;
                           PUT @007 'ERROR: RECFM= CHARACTER VALUE "'
                                     CTL_CHR $CHAR1.
                                    '" DUPLICATES PREVIOUS "B"'
                                   ' SPECIFICATION.';
                           CHR_ERR = 1    /*CONTROL ITEM ERROR*/;
                         END;
                  IF NW1RECFM = '11......'B
                    THEN DO;
                           PUT @007 'ERROR: RECFM= CHARACTER VALUE "'
                                     CTL_CHR $CHAR1.
                                    '" IS INCOMPATIBLE WITH '
                                    'PREVIOUS "U" SPECIFICATION.';
                           CHR_ERR = 1    /*CONTROL ITEM ERROR*/;
                         END;
                  IF NW1RECFM = '00......'B
                    THEN DO;
                           PUT @007 'ERROR: RECFM= CHARACTER VALUE "'
                                     CTL_CHR $CHAR1.
                                    '" CANNOT BE SPECIFIED '
                                    'BEFORE "F" OR "V" '
                                    'HAS APPEARED IN THE STRING';
                           CHR_ERR = 1    /*CONTROL ITEM ERROR*/;
                         END;
                  IF      NW1RECFM = '...0....'B
                     AND  CHR_ERR  = 0
                    THEN  NW1RECFM = NW1RECFM + 10X;
                END;
           PAGE;
           IF   CTL_CHR = 'S'
           THEN DO;
                  CHR_FLG = 1    /*CONTROL CHARACTER RECOGNIZED*/;
                  IF NW1RECFM = '....1...'B
                    THEN DO;
                           PUT @007 'ERROR: RECFM= CHARACTER VALUE "'
                                     CTL_CHR $CHAR1.
                                    '" DUPLICATES PREVIOUS "S" '
                                    'SPECIFICATION.';
                           CHR_ERR = 1    /*CONTROL ITEM ERROR*/;
                         END;
                  IF NW1RECFM = '11......'B
                    THEN DO;
                           PUT @007 'ERROR: RECFM= CHARACTER VALUE "'
                                     CTL_CHR $CHAR1.
                                    '" IS INCOMPATIBLE WITH '
                                    'PREVIOUS "U" SPECIFICATION.';
                           CHR_ERR = 1    /*CONTROL ITEM ERROR*/;
                         END;
                  IF NW1RECFM = '00......'B
                    THEN DO;
                           PUT @007 'ERROR: RECFM= CHARACTER VALUE "'
                                     CTL_CHR $CHAR1.
                                    '" CANNOT BE SPECIFIED '
                                    'BEFORE "F" OR "V" '
                                    'HAS APPEARED IN THE STRING';
                           CHR_ERR = 1    /*CONTROL ITEM ERROR*/;
                         END;
                  IF      NW1RECFM = '....0...'B
                     AND  CHR_ERR  = 0
                    THEN  NW1RECFM = NW1RECFM + 08X;
                END;
           PAGE;
           IF   CTL_CHR = 'A'
           THEN DO;
                  CHR_FLG = 1    /*CONTROL CHARACTER RECOGNIZED*/;
                  IF NW1RECFM = '.....01.'B
                    THEN DO;
                           PUT @007 'ERROR: RECFM= CHARACTER VALUE "'
                                     CTL_CHR $CHAR1.
                                    '" IS INCOMPATIBLE '
                                    'WITH PREVIOUS "M" SPECIFICATION.';
                           CHR_ERR = 1    /*CONTROL ITEM ERROR*/;
                         END;
                  IF NW1RECFM = '.....10.'B
                    THEN DO;
                           PUT @007 'ERROR: RECFM= CHARACTER VALUE "'
                                     CTL_CHR $CHAR1.
                                    '" DUPLICATES PREVIOUS "A" '
                                    'SPECIFICATION.';
                           CHR_ERR = 1    /*CONTROL ITEM ERROR*/;
                         END;
                  IF      NW1RECFM = '.....00.'B
                     AND  CHR_ERR  = 0
                    THEN  NW1RECFM = NW1RECFM + 04X;
                END;
           SKIP 2;
           IF   CTL_CHR = 'M'
           THEN DO;
                  CHR_FLG = 1    /*CONTROL CHARACTER RECOGNIZED*/;
                  IF NW1RECFM = '.....1..'B
                    THEN DO;
                           PUT @007 'ERROR: RECFM= CHARACTER VALUE "'
                                     CTL_CHR $CHAR1.
                                    '" IS INCOMPATIBLE '
                                    'WITH PREVIOUS "A" SPECIFICATION.';
                           CHR_ERR = 1    /*CONTROL ITEM ERROR*/;
                         END;
                  IF NW1RECFM = '......1.'B
                    THEN DO;
                           PUT @007 'ERROR: RECFM= CHARACTER VALUE "'
                                     CTL_CHR $CHAR1.
                                    '" DUPLICATES PREVIOUS "M"'
                                    ' SPECIFICATION.';
                           CHR_ERR = 1    /*CONTROL ITEM ERROR*/;
                         END;
                  IF      NW1RECFM = '.....00.'B
                     AND  CHR_ERR  = 0
                    THEN  NW1RECFM = NW1RECFM + 02X;
                END;
           PAGE;
           IF   CHR_FLG = 0   /*IF CHARACTER NOT RECOGNIZED*/
           THEN DO;
                  PUT @007 'ERROR: RECFM= CHARACTER VALUE #'
                            CHR_CT   1.    ', "'
                            CTL_CHR $CHAR1.
                           '" IS NOT SUPPORTED.';
                  ERR_FLG = 1    /*INDICATE CONTROL ITEM ERROR*/;
                END;
           SKIP 1;
           IF   CHR_ERR = 1   /*IF CHARACTER IS INVALID*/
           THEN DO;
                  PUT @007 'ERROR: RECFM= CHARACTER VALUE #'
                            CHR_CT   1.    ', "'
                            CTL_CHR $CHAR1.
                           '" IS INVALID';
                  ERR_FLG = 1    /*INDICATE CONTROL ITEM ERROR*/;
                END;
         SKIP 3;
         END                     /*END OF CHARACTER SCAN LOOP*/;
         SKIP 1;
         IF     ERR_FLG = 1
           THEN PUT @007 'ERROR: "'
                          CTL $VARYING64. CTL_LN
                         '" IS INVALID';
         SKIP 1;
         RETURN;
       PAGE;
       VAL_RTPD:   /*VALIDATE RETPD=NNNN CONTROL ITEM*/;
         VAL_FLG = 1    /*INDICATE CONTROL ITEM RECOGNIZED*/;
         CTL_KEYL = INDEX(CTL,'=') /*LENGTH OF KEYWORD    */;
         CTL_STRL = LENGTH(CTL) - CTL_KEYL  /*VALUE STRING LENGTH*/;
         CTL_STR = SUBSTR(CTL,CTL_KEYL+1,CTL_STRL) /*VALUE STRING*/;
         IF      CTL_STRL < 1
             OR  CTL_STRL > 4
             OR (1 <= CTL_STRL <= 4 AND CTL_VAL = .)
           THEN DO;
                  PUT @007 'ERROR: RETPD VALUE MUST CONSIST '
                           'OF 1-4 NUMERIC DIGITS, "'
                            CTL $VARYING64. CTL_LN
                           '" IS INVALID';
                  ERR_FLG = 1    /*INDICATE CONTROL ITEM ERROR*/;
                END;
         RETURN;
 PAGE;
 DATA  DSCB1 (KEEP=     CCHHR
              DEVT      DEVT_LN   VOLSER    VOLSR_LN
              DS1DSNAM  DS1DSNLN
              DS1VOLSQ
              DS1CREYY  DS1CREDD  DS1CREDT
              DS1EXPYY  DS1EXPDD  DS1EXPDT
              DS1REFYY  DS1REFDD  DS1REFDT
              DS1DSORG  DS1RECFM  DS1OPTCD
              DS1BLKL   DS1LRECL  DS1KEYL   DS1RKP
              DS1DSIND  DS1SCALO  DS1LSTAR  DS1TRBAL);
       FORMAT CCHHR     $HEX10.
              DEVT      $8.       DEVT_LN   Z2.
              VOLSER    $6.       VOLSR_LN  Z2.
              UT1_DEVT  $24.      UT1_DEVC  $8.       UT1_JFCB  $176.
              DS1DSNAM  $44.      DS1DSNLN  Z2.
              DS1CREDT  DS1EXPDT  DS1REFDT  DATE7.
              ;
       RETAIN VOLSER    VOLSR_LN
              DEVT      DEVT_LN
              ;
       INFILE SYSLIB            /*DD STATEMENT DESIGNATING VTOC*/
              VTOC   CCHHR
              DEVTYPE=UT1_DEVT     JFCB=UT1_JFCB        END=UT1_EOF;
       IF     _N_ = 1          /*IF THE FIRST TIME THRU THE DATA STEP*/
         THEN
           DO;
              *------SET UP THE DEVICE TYPE SPECIFICATION-----;
              DEVT = '????';
              UT1_DEVC = PUT(SUBSTR(UT1_DEVT,1,4),$HEX8.);
              IF SUBSTR(UT1_DEVC,5,4) = '2007'  THEN DEVT = '2305-2';
              IF SUBSTR(UT1_DEVC,5,4) = '2008'  THEN DEVT = '2314';
              IF SUBSTR(UT1_DEVC,4,5) = '02009' THEN DEVT = '3330';
              IF SUBSTR(UT1_DEVC,4,5) = '82009' THEN DEVT = '3330V';
              IF SUBSTR(UT1_DEVC,5,4) = '200B'  THEN DEVT = '3350';
              IF SUBSTR(UT1_DEVC,5,4) = '200D'  THEN DEVT = '3330-1';
              IF SUBSTR(UT1_DEVC,5,4) = '200E'  THEN DEVT = '3380';
             *-----CODE DEVICE TYPE LENGTH--------;
             DEVT_LN  = LENGTH(DEVT);
             *-----CODE VOLUME SERIAL NUMBER LENGTH-----;
             VOLSR_LN = LENGTH(VOLSER);
           END;
       INPUT  @001      CCHHR               $CHAR5.
              @044+5+1  DSCFMTID            $CHAR1.   @;
       IF     DSCFMTID = '1'
         THEN
           DO;
             *-----INPUT DATA ITEMS FROM THE F1 DSCB-----;
             INPUT @001+5   DS1DSNAM        $CHAR44.
                   @051+5+1 DS1VOLSQ        PIB2.
                   @053+5+1 DS1CREYY        PIB1.
                            DS1CREDD        PIB2.
                   @056+5+1 DS1EXPYY        PIB1.
                            DS1EXPDD        PIB2.
                   @075+5+1 DS1REFYY        PIB1.
                            DS1REFDD        PIB2.
                   @082+5+1 DS1DSORG        PIB2.
                   @084+5+1 DS1RECFM        PIB1.
                   @085+5+1 DS1OPTCD        PIB1.
                   @086+5+1 DS1BLKL         PIB2.
                   @088+5+1 DS1LRECL        PIB2.
                   @090+5+1 DS1KEYL         PIB1.
                   @091+5+1 DS1RKP          PIB2.
                   @093+5+1 DS1DSIND        PIB1.
                   @094+5+1 DS1SCALO        PIB4.
                   @098+5+1 DS1LSTAR        PIB3.
                   @101+5+1 DS1TRBAL        PIB2. ;
             *-----CODE DSNAME LENGTH--------;
             DS1DSNLN = LENGTH(DS1DSNAM);
             IF DS1DSNLN = 1 AND DS1DSNAM = ' '
                THEN DS1DSNLN = 0;
             *-----CODE CREATION DATE--------;
             IF DS1CREYY > 0
                THEN DS1CREDT= DATEJUL(1000*DS1CREYY+DS1CREDD);
                ELSE DS1CREDT= .;
             *-----CODE EXPIRATION DATE--------;
             IF DS1EXPYY > 0
                THEN DS1EXPDT= DATEJUL(1000*DS1EXPYY+DS1EXPDD);
                ELSE DS1EXPDT= .;
             *-----CODE LAST REFERENCED DATE--------;
             IF DS1REFYY > 0
                THEN DS1REFDT= DATEJUL(1000*DS1REFYY+DS1REFDD);
                ELSE DS1REFDT= .;
             *-----WRITE THE OBSERVATION FOR THE F1 DSCB-----;
             OUTPUT DSCB1;
           END;
       IF     UT1_EOF = 1
         THEN
           DO;
              STOP;
           END;
 PROC SORT  DATA=ZAPCTL  EQUALS;
      BY    ZAPDSNAM;
 PROC SORT  DATA=DSCB1;
      BY    DS1DSNAM;
 PROC PRINT DATA=ZAPCTL;
      TITLE3 --LISTING OF ZAP CONTROL INFORMATION FROM FILE SYSIN--;
      TITLE4 ;
 PROC PRINT DATA=DSCB1;
      TITLE3 --LISTING OF VTOC DATA SET INFORMATION FROM FILE SYSLIB--;
      FORMAT DS1VOLSQ Z5.
             DS1CREYY DS1EXPYY DS1REFYY     HEX2.
             DS1CREDD DS1EXPDD DS1REFDD     HEX4.
             DS1DSORG HEX4.    DS1RECFM     HEX2.
             DS1OPTCD HEX2.    DS1BLKL      Z5.
             DS1LRECL Z5.      DS1KEYL      Z3.
             DS1RKP   Z5.      DS1DSIND     HEX2.
             DS1SCALO HEX8.    DS1LSTAR     HEX6.
             DS1TRBAL HEX4.    ;
 PAGE;
 DATA  _NULL_ /*GENERATE OUTPUT TO SYSPUNCH FOR AMASPZAP*/;
       TITLE3 ;
       FORMAT DS1DSNAM  UPDDSNAM  NW1DSNAM  $44.
              DS1DSNLN  Z2.
              NW1DSN1   NW1DSN2   $HEX32.   NW1DSN3   $HEX24.
              ZAPDSNAM  $44.      ZAPDSNLN  Z2.
              CTL1-CTL16 $64.     CTL_IX    Z2.       CTL_CT    Z2.
              CTL_LN    Z2.
              CTL_KEY   $32.      CTL_KEYL  Z2.
              CTL_STR   $64.      CTL_STRL  Z2.       CTL_VAL   9.
              CTL_CHR   $CHAR1.   CHR_CT    Z2.
              PREVCCHR  $HEX10.
              DATE_JJJ  DATE_YY   DATE_DDD  9.
              DATEDATE  DATE9.
              UPDDATE   NW1DATE   HEX6.
              DS1CREDT  UPDCREDT  DATE9.
              DS1CREYY  UPDCREYY  HEX2.
              DS1CREDD  UPDCREDD  HEX4.
              DS1EXPDT  UPDEXPDT  DATE9.
              DS1EXPYY  UPDEXPYY  HEX2.
              DS1EXPDD  UPDEXPDD  HEX4.
              DS1REFDT  UPDREFDT  DATE9.
              DS1REFYY  UPDREFYY  HEX2.
              DS1REFDD  UPDREFDD  HEX4.
              DS1DSIND  UPDDSIND  NW1DSIND  HEX2.
              DS1DSORG  UPDDSORG  NW1DSORG  HEX4.
              DS1BLKL   UPDBLKL   HEX4.
              DS1LRECL  UPDLRECL  HEX4.
              DS1KEYL   UPDKEYL   HEX2.
              DS1RKP    UPDRKP    HEX4.
              UPDLNTH   NW1LNTH   HEX4.
              DS1RECFM  UPDRECFM  NW1RECFM  HEX2.
              DS1VOLSQ  UPDVOLSQ  NW1VOLSQ  HEX4.
              ;
       ARRAY  CTL(CTL_IX)         CTL1-CTL16;
       *-----INITIALIZE REQUIRED CONTROL VARIABLES-------------*;
       PREVCCHR = ' ';
       *-----ESTABLISH OUTPUT FILE AND ITS CHARACTERISTICS-----*;
       FILE   SYSPUNCH NOTITLES NOPRINT
              RECFM=FB LRECL=80           COLUMN=PCH_COL;
       SKIP 5;
       *-----READ AND PROCESS THE VTOC AND ZAPCTL OBSERVATIONS----;
       LINK   DS1_READ        /*READ THE FIRST VTOC OBS*/;
       LINK   ZAP_READ        /*READ THE FIRST ZAP CONTROL OBS*/;
       DO   WHILE(DS1_EOF EQ 0 AND ZAP_EOF EQ 0);
         IF DS1DSNAM < ZAPDSNAM THEN LINK DS1_READ;
         IF DS1DSNAM = ZAPDSNAM
           THEN DO;
                  LINK GENERZAP    /*GENERATE AMASPZAP CONTROL   */;
                  LINK ZAP_READ    /*READ THE NEXT ZAPCTL OBSERV.*/;
                END;
         IF DS1DSNAM > ZAPDSNAM THEN LINK ZAP_READ;
       END;         /*END OF MAINLINE COMPARISON CONTROL LOOP*/
       STOP         /*TERMINATE EXECUTION.   */;
       RETURN       /*END OF MAINLINE ROUTINE*/;
       PAGE;
       DS1_READ:    /*SUBROUTINE TO READ THE NEXT VTOC OBSERVATION*/
          IF DS1_LAST     /*IF PREVIOUS OBSERVATION WAS THE LAST*/
             THEN DO;
                    DS1_EOF = 1;
                    DS1DSNAM = 'FFFFFFFF'X;
                  END;
             ELSE DO;
                    DS1_EOF = 0;
                    SET DSCB1     END=DS1_LAST;
                  END;
          UPDBLKL  = DS1BLKL ;  /*INIT UPDATED BLKSIZE     */
          UPDCREDD = DS1CREDD;  /*INIT UPDATED CREDT DDD   */
          UPDCREDT = DS1CREDT;  /*INIT UPDATED CREDT       */
          UPDCREYY = DS1CREYY;  /*INIT UPDATED CREDT YY    */
          UPDDSIND = DS1DSIND;  /*INIT UPDATED DS1DSIND    */
          UPDDSNAM = DS1DSNAM;  /*INIT UPDATED DSNAME VALUE*/
          UPDDSORG = DS1DSORG;  /*INIT UPDATED DSORG       */
          UPDEXPDD = DS1EXPDD;  /*INIT UPDATED EXPDT DDD   */
          UPDEXPDT = DS1EXPDT;  /*INIT UPDATED EXPDT       */
          UPDEXPYY = DS1EXPYY;  /*INIT UPDATED EXPDT YY    */
          UPDKEYL  = DS1KEYL ;  /*INIT UPDATED KEYLEN      */
          UPDLRECL = DS1LRECL;  /*INIT UPDATED LRECL       */
          UPDRECFM = DS1RECFM;  /*INIT UPDATED RECFM       */
          UPDREFDD = DS1REFDD;  /*INIT UPDATED REFDT DDD   */
          UPDREFDT = DS1REFDT;  /*INIT UPDATED REFDT       */
          UPDREFYY = DS1REFYY;  /*INIT UPDATED REFDT YY    */
          UPDRKP   = DS1RKP  ;  /*INIT UPDATED RKP         */
          UPDVOLSQ = DS1VOLSQ;  /*INIT UPDATED VOL SEQ #   */
       RETURN       /*END OF VTOC OBSERVATION READ ROUTINE */;
       SKIP 5;
       ZAP_READ:    /*SUBROUTINE TO READ THE NEXT ZAP CTL OBSERVATION*/
          IF ZAP_LAST     /*IF PREVIOUS OBSERVATION WAS THE LAST*/
             THEN DO;
                    ZAP_EOF = 1;
                    ZAPDSNAM = 'FFFFFFFF'X;
                  END;
             ELSE DO;
                    ZAP_EOF = 0;
                    SET ZAPCTL     END=ZAP_LAST;
                  END;
       RETURN       /*END OF ZAP CONTROL OBSERVATION READ ROUTINE*/;
       PAGE;
       GENERZAP:   /*GENERATE AMASPZAP CONTROL */
          DO CTL_IX = 1 TO CTL_CT;
             SKIP 1;
             *-----SET UP CONTROL KEY AND STRING RELATED VARIABLES--*;
             CTL_LN   = LENGTH(CTL)          /*CONTROL ITEM LENGTH  */;
             CTL_KEYL = INDEX(CTL,'=')    /*TENTATIVE KEYWORD LENGTH*/;
             IF     CTL_KEYL > 0            /*IF WE HAVE A KEYWORD*/
               THEN CTL_KEY  = SUBSTR(CTL,1,CTL_KEYL)      /*KEYWORD*/;
               ELSE CTL_KEY  = CTL         /*CONTROL ITEM IS KEYWORD*/;
             CTL_KEYL = LENGTH(CTL_KEY)      /*ACTUAL KEYWORD LENGTH*/;
             CTL_STRL = CTL_LN - CTL_KEYL      /*VALUE STRING LENGTH*/;
             IF     CTL_STRL > 0         /*IF WE HAVE A VALUE STRING*/
               THEN CTL_STR  = SUBSTR(CTL,CTL_KEYL+1,CTL_STRL);
               ELSE CTL_STR  = ' '      /*CONTROL ITEM VALUE IS NULL*/;
             IF     CTL_STRL > 0         /*IF WE HAVE A VALUE STRING*/
                AND                      /*AND IF ITS ALL NUMERIC,  */
                   (VERIFY(TRIM(CTL_STR),'0123456789') EQ 0)
               THEN CTL_VAL  = INPUT(CTL_STR,32.)    /*GET NUM EQUIV*/;
               ELSE CTL_VAL  = .     /*CONTROL ITEM VALUE IS MISSING*/;
             SKIP 1;
             *-----SELECT PROCESSING ROUTINE BASED ON THE KEYWORD---*;
             IF CTL_KEY = 'BLKL8'    THEN LINK SETBLKL8;
             IF CTL_KEY = 'BLKSIZE=' THEN LINK SETBLKL;
             IF CTL_KEY = 'CHANGE'   THEN LINK SETHSM;
             IF CTL_KEY = 'CREDT='   THEN LINK SETDATE;
             IF CTL_KEY = 'DSEOF'    THEN LINK SETDSEOF;
             IF CTL_KEY = 'DSORG='   THEN LINK SETDSORG;
             IF CTL_KEY = 'EXPDT='   THEN LINK SETDATE;
             IF CTL_KEY = 'HSM'      THEN LINK SETHSM;
             IF CTL_KEY = 'KEYLEN='  THEN LINK SETKEYL;
             IF CTL_KEY = 'LRECL='   THEN LINK SETLRECL;
             IF CTL_KEY = 'NEWNAME=' THEN LINK SETDSNAM;
             IF CTL_KEY = 'NOBLKL8'  THEN LINK SETNBLK8;
             IF CTL_KEY = 'NOCHANGE' THEN LINK SETNOHSM;
             IF CTL_KEY = 'NODSEOF'  THEN LINK SETNOEOF;
             IF CTL_KEY = 'NOHSM'    THEN LINK SETNOHSM;
             IF CTL_KEY = 'NOPASWRD' THEN LINK SETNOPAS;
             IF CTL_KEY = 'NOPWREAD' THEN LINK SETPASWR;
             IF CTL_KEY = 'NORACF'   THEN LINK SETNORAC;
             IF CTL_KEY = 'PASSWORD' THEN LINK SETPASRW;
             IF CTL_KEY = 'RACF'     THEN LINK SETRACF;
             IF CTL_KEY = 'RECFM='   THEN LINK SETRECFM;
             IF CTL_KEY = 'REFDT='   THEN LINK SETDATE;
             IF CTL_KEY = 'RETPD='   THEN LINK SETRETPD;
             IF CTL_KEY = 'RKP='     THEN LINK SETRKP;
             IF CTL_KEY = 'VOLCT='   THEN LINK SETVOLSQ;
             IF CTL_KEY = 'VOLSQ='   THEN LINK SETVOLSQ;
          END;
          RETURN;
       PAGE;
       SETPASRW:   /*SET READ AND WRITE PASSWORD PROTECTION*/
          NW1DSIND = UPDDSIND;
          *-----DEVELOP THE REPLACEMENT VALUE FOR DS1DSIND.-----;
          IF     NW1DSIND = '...0....'B   /*IF BIT DS1IND10 IS OFF,*/
            THEN NW1DSIND = NW1DSIND+10X        /*TURN IT ON.*/;
          IF     NW1DSIND = '.....1..'B   /*IF BIT DS1IND04 IS ON,*/
            THEN NW1DSIND = NW1DSIND-04X        /*TURN IT OFF.*/;
          *-----IF THE BITS ARE ALREADY SET, PRODUCE A MESSAGE.-;
          IF   UPDDSIND = NW1DSIND
            THEN LINK GENERROR;
            ELSE
               DO;
                 LINK GENCCHHR /*GENERATE CCHHR   STATEMENT */;
                 LINK GENDSIND /*GENERATE VER/REP STATEMENTS*/;
               END;
          PUT  'LABEL=(,,PASSWORD) INDICATED.' /*WHAT WAS CHANGED*/;
          RETURN;
       SKIP 1;
       SETPASWR:   /*SET WRITE-ONLY PASSWORD PROTECTION    */
          NW1DSIND = UPDDSIND;
          *-----DEVELOP THE REPLACEMENT VALUE FOR DS1DSIND.-----;
          IF     NW1DSIND = '...0....'B   /*IF BIT DS1IND10 IS OFF,*/
            THEN NW1DSIND = NW1DSIND+10X         /*TURN IT ON.*/;
          IF     NW1DSIND = '.....0..'B   /*IF BIT DS1IND04 IS OFF,*/
            THEN NW1DSIND = NW1DSIND+04X         /*TURN IT ON.*/;
          *-----IF THE BITS ARE ALREADY SET, PRODUCE A MESSAGE.-;
          IF   UPDDSIND = NW1DSIND
            THEN LINK GENERROR /*GENERATE ERROR MESSAGE COMMENT*/;
            ELSE
               DO;
                 LINK GENCCHHR /*GENERATE CCHHR   STATEMENT */;
                 LINK GENDSIND /*GENERATE VER/REP STATEMENTS*/;
               END;
          PUT  'LABEL=(,,NOPWREAD) INDICATED.'  /*WHAT WAS CHANGED*/;
          RETURN;
       SKIP 1;
       SETNOPAS:   /*TURN OFF PASSWORD PROTECTION FOR DATA SET*/
          NW1DSIND = UPDDSIND;
          *-----DEVELOP THE REPLACEMENT VALUE FOR DS1DSIND.-----;
          IF     NW1DSIND = '...1....'B   /*IF BIT DS1IND10 IS ON,*/
            THEN NW1DSIND = NW1DSIND-10X        /*TURN IT OFF.*/;
          IF     NW1DSIND = '.....1..'B   /*IF BIT DS1IND04 IS ON,*/
            THEN NW1DSIND = NW1DSIND-04X        /*TURN IT OFF.*/;
          *-----IF THE BITS ARE ALREADY SET, PRODUCE A MESSAGE.-;
          IF   UPDDSIND = NW1DSIND
            THEN LINK GENERROR /*GENERATE ERROR MESSAGE COMMENT*/;
            ELSE
               DO;
                 LINK GENCCHHR /*GENERATE CCHHR   STATEMENT */;
                 LINK GENDSIND /*GENERATE VER/REP STATEMENTS*/;
               END;
          PUT  'THE PASSWORD INDICATOR BITS SET OFF.';
          RETURN;
       PAGE;
       SETDSEOF:   /*SET LAST VOLUME INDICATOR FOR THE DATA SET*/
          *-----DEVELOP THE REPLACEMENT VALUE FOR DS1DSIND.-----;
          NW1DSIND = UPDDSIND;
          IF     NW1DSIND = '0.......'B   /*IF BIT DS1IND80 IS OFF,*/
            THEN NW1DSIND = NW1DSIND+80X        /*TURN IT ON.*/;
          IF   UPDDSIND = NW1DSIND /*IF UNCHANGED, ERROR MESSAGE*/
            THEN LINK GENERROR /*GENERATE ERROR MESSAGE COMMENT*/;
            ELSE
               DO;
                 LINK GENCCHHR /*GENERATE CCHHR   STATEMENT */;
                 LINK GENDSIND /*GENERATE VER/REP STATEMENTS*/;
               END;
          PUT  'THE LAST VOLUME INDICATOR BIT SET ON.';
          RETURN;
       SKIP 1;
       SETNOEOF:   /*TURN OFF LAST VOLUME INDICATOR FOR THE DATA SET*/
          *-----DEVELOP THE REPLACEMENT VALUE FOR DS1DSIND.-----;
          NW1DSIND = UPDDSIND;
          IF     NW1DSIND = '1.......'B   /*IF BIT DS1IND80 IS ON,*/
            THEN NW1DSIND = NW1DSIND-80X        /*TURN IT OFF*/;
          IF   UPDDSIND = NW1DSIND /*IF UNCHANGED, ERROR MESSAGE*/
            THEN LINK GENERROR /*GENERATE ERROR MESSAGE COMMENT*/;
            ELSE
               DO;
                 LINK GENCCHHR /*GENERATE CCHHR   STATEMENT */;
                 LINK GENDSIND /*GENERATE VER/REP STATEMENTS*/;
               END;
          PUT  'THE LAST VOLUME INDICATOR BIT TURNED OFF.';
          RETURN;
       PAGE;
       SETRACF:    /*SET RACF PROTECTION FOR THE DATA SET*/
          *-----DEVELOP THE REPLACEMENT VALUE FOR DS1DSIND.-----;
          NW1DSIND = UPDDSIND;
          IF     NW1DSIND = '.0......'B   /*IF BIT DS1IND40 IS OFF,*/
            THEN NW1DSIND = NW1DSIND+40X        /*TURN IT ON.*/;
          IF   UPDDSIND = NW1DSIND /*IF UNCHANGED, ERROR MESSAGE*/
            THEN LINK GENERROR /*GENERATE ERROR MESSAGE COMMENT*/;
            ELSE
               DO;
                 LINK GENCCHHR /*GENERATE CCHHR   STATEMENT */;
                 LINK GENDSIND /*GENERATE VER/REP STATEMENTS*/;
               END;
          PUT  'RACF PROTECTION SET ON.';
          RETURN;
       SKIP 1;
       SETNORAC:   /*DELETE RACF PROTECTION FOR THE DATA SET*/
          *-----DEVELOP THE REPLACEMENT VALUE FOR DS1DSIND.-----;
          NW1DSIND = UPDDSIND;
          IF     NW1DSIND = '.1......'B   /*IF BIT DS1IND40 IS ON,*/
            THEN NW1DSIND = NW1DSIND-40X        /*TURN IT OFF*/;
          IF   UPDDSIND = NW1DSIND /*IF UNCHANGED, ERROR MESSAGE*/
            THEN LINK GENERROR /*GENERATE ERROR MESSAGE COMMENT*/;
            ELSE
               DO;
                 LINK GENCCHHR /*GENERATE CCHHR   STATEMENT */;
                 LINK GENDSIND /*GENERATE VER/REP STATEMENTS*/;
               END;
          PUT  'RACF PROTECTION DELETED.';
          RETURN;
       PAGE;
       SETBLKL8:   /*SET BIT INDICATING BLKSIZE MULTIPLE OF 8*/;
          NW1DSIND = UPDDSIND;
          IF     NW1DSIND = '..0.....'B   /*IF BIT DS1IND20 IS OFF,*/
            THEN NW1DSIND = NW1DSIND+20X               /*TURN IT ON*/;
          IF   UPDDSIND = NW1DSIND    /*IF UNCHANGED, ERROR MESSAGE*/
            THEN LINK GENERROR     /*GENERATE ERROR MESSAGE COMMENT*/;
            ELSE
               DO;
                 LINK GENCCHHR /*GENERATE CCHHR   STATEMENT */;
                 LINK GENDSIND /*GENERATE VER/REP STATEMENTS*/;
               END;
          PUT  'BLKSIZE A MULTIPLE OF 8 INDICATED.';
          RETURN;
       SKIP 1;
       SETNBLK8:   /*RESET BIT INDICATING BLKSIZE MULTIPLE OF 8*/;
          NW1DSIND = UPDDSIND;
          IF     NW1DSIND = '..1.....'B   /*IF BIT DS1IND40 IS ON,*/
            THEN NW1DSIND = NW1DSIND-20X        /*TURN IT OFF*/;
          IF   UPDDSIND = NW1DSIND /*IF UNCHANGED, ERROR MESSAGE*/
            THEN LINK GENERROR /*GENERATE ERROR MESSAGE COMMENT*/;
            ELSE
               DO;
                 LINK GENCCHHR /*GENERATE CCHHR   STATEMENT */;
                 LINK GENDSIND /*GENERATE VER/REP STATEMENTS*/;
               END;
          PUT  'BLKSIZE NOT A MULTIPLE OF 8 INDICATED.';
          RETURN;
       PAGE;
       SETHSM:     /*SET HSM DATASET CHANGED BIT ON*/;
          NW1DSIND = UPDDSIND;
          IF     NW1DSIND = '......0.'B   /*IF BIT DS1IND02 IS OFF,*/
            THEN NW1DSIND = NW1DSIND+02X               /*TURN IT ON*/;
          IF   UPDDSIND = NW1DSIND    /*IF UNCHANGED, ERROR MESSAGE*/
            THEN LINK GENERROR     /*GENERATE ERROR MESSAGE COMMENT*/;
            ELSE
               DO;
                 LINK GENCCHHR /*GENERATE CCHHR   STATEMENT */;
                 LINK GENDSIND /*GENERATE VER/REP STATEMENTS*/;
               END;
          PUT  'THE HSM DATASET CHANGED BIT TURNED ON.';
          RETURN;
       SKIP 1;
       SETNOHSM:   /*SET HSM DATASET CHANGED BIT OFF*/;
          NW1DSIND = UPDDSIND;
          IF     NW1DSIND = '......1.'B   /*IF BIT DS1IND02 IS ON,*/
            THEN NW1DSIND = NW1DSIND-02X        /*TURN IT OFF*/;
          IF   UPDDSIND = NW1DSIND /*IF UNCHANGED, ERROR MESSAGE*/
            THEN LINK GENERROR /*GENERATE ERROR MESSAGE COMMENT*/;
            ELSE
               DO;
                 LINK GENCCHHR /*GENERATE CCHHR   STATEMENT */;
                 LINK GENDSIND /*GENERATE VER/REP STATEMENTS*/;
               END;
          PUT  'THE HSM DATASET CHANGED BIT TURNED OFF.';
          RETURN;
       PAGE;
       *-----GENERATE AMASPZAP CONTROL STATEMENTS TO SET-----------*;
       *-----A NEW DATE VALUE IN A DATE VALUE FIELD.---------------*;
       SETDATE:
          *-----DEVELOP THE NEW AND OLD DATE VALUES------------*;
          IF     CTL_KEY =: 'CREDT='
            THEN UPDDATE = UPDCREYY*65536 + UPDCREDD;
          IF     CTL_KEY =: 'EXPDT='
            THEN UPDDATE = UPDEXPYY*65536 + UPDEXPDD;
          IF     CTL_KEY =: 'REFDT='
            THEN UPDDATE = UPDREFYY*65536 + UPDREFDD;
          IF CTL_STRL EQ 5
            THEN  /*CTL_VAL ALREADY CONTAINS THE JULIAN DATE*/;
          IF CTL_STRL EQ 7
            THEN CTL_VAL = JULDATE(INPUT(CTL_STR,DATE7.));
          IF CTL_STRL EQ 8
            THEN CTL_VAL = JULDATE(INPUT(CTL_STR,MMDDYY8.));
          IF CTL_STRL EQ 9
            THEN CTL_VAL = JULDATE(INPUT(CTL_STR,DATE9.));
          DATE_YY  = INT(CTL_VAL/1000);
          DATE_DDD = MOD(CTL_VAL,1000);
          NW1DATE  = DATE_YY * 65536 + DATE_DDD;
          IF     CTL_STR = '00000'
            THEN DATEDATE = .;
            ELSE DATEDATE = DATEJUL(1000*DATE_YY + DATE_DDD);
          *-----IF THIS DATE IS ALREADY SET, PRODUCE A MESSAGE.-;
          IF   UPDDATE = NW1DATE
            THEN LINK GENERROR;
            ELSE
               DO;
                 LINK GENCCHHR /*GENERATE CCHHR   STATEMENT */;
                 IF CTL_KEY =: 'CREDT=' THEN LINK GENCREDT;
                 IF CTL_KEY =: 'EXPDT=' THEN LINK GENEXPDT;
                 IF CTL_KEY =: 'REFDT=' THEN LINK GENREFDT;
               END;
          PUT  CTL;
          PUT
             @001 '*'
             @044 '('
                   DATE_YY  Z2.
                  '.'
                   DATE_DDD Z3.
                  ';'
                   DATEDATE DATE9.
                  ') SPECIFIED.';
          RETURN;
       PAGE;
       *-----GENERATE AMASPZAP CONTROL STATEMENTS-----------------*;
       *-----TO SET A NEW DATA SET ORGANIZATION VALUE.-----------*;
       SETDSORG:   /*VALIDATE DSORG=STRING CONTROL ITEM*/;
         *-----DEVELOP THE BIT MASK FOR THE NEW DATA SET ORG.------*;
         IF CTL_VAL = 0      THEN NW1DSORG = 0000X;
         IF CTL_STR = 'AM'   THEN NW1DSORG = 0008X;
         IF CTL_STR = 'DA'   THEN NW1DSORG = 2000X;
         IF CTL_STR = 'DAU'  THEN NW1DSORG = 2100X;
         IF CTL_STR = 'IS'   THEN NW1DSORG = 8000X;
         IF CTL_STR = 'ISU'  THEN NW1DSORG = 8100X;
         IF CTL_STR = 'PO'   THEN NW1DSORG = 0200X;
         IF CTL_STR = 'POU'  THEN NW1DSORG = 0300X;
         IF CTL_STR = 'PS'   THEN NW1DSORG = 4000X;
         IF CTL_STR = 'PSU'  THEN NW1DSORG = 4100X;
         *----IF THIS DATA SET ORG. IS ALREADY SET, PRODUCE A MESSAGE-*;
         IF   UPDDSORG = NW1DSORG
           THEN LINK GENERROR;
           ELSE
             DO;
                LINK GENCCHHR /*GENERATE CCHHR STATEMENT*/;
                LINK GENDSORG /*GENERATE VER/REP STATEMENTS*/;
             END;
         PUT CTL 'SPECIFIED.';
         RETURN;
       PAGE;
       *-----GENERATE AMASPZAP CONTROL STATEMENTS-----------------*;
       *-----TO SET AN NEW RECORD FORMAT VALUE.-------------------*;
       SETRECFM:   /*VALIDATE RECFM=CHRS CONTROL ITEM*/;
         *-----DEVELOP THE BIT MASK FOR THE NEW RECORD FORMAT------*;
         NW1RECFM = 0              /*CLEAR RECFM BIT MASK TO ZERO*/;
         DO   CHR_CT = 1 TO CTL_STRL;
           CTL_CHR = SUBSTR(CTL_STR,CHR_CT,1);    /*CURRENT CHAR*/
           IF     CTL_CHR = '0'
             THEN NW1RECFM = 0;
           IF     CTL_CHR = 'F' AND NW1RECFM = '00......'B
             THEN NW1RECFM = NW1RECFM + 80X;
           IF     CTL_CHR = 'V' AND NW1RECFM = '00......'B
             THEN NW1RECFM = NW1RECFM + 40X;
           IF     CTL_CHR = 'U' AND NW1RECFM = '00......'B
             THEN NW1RECFM = NW1RECFM + 80X + 40X;
           IF     CTL_CHR = 'T' AND NW1RECFM = '..0.....'B
             THEN NW1RECFM = NW1RECFM + 20X;
           IF     CTL_CHR = 'B' AND NW1RECFM = '...0....'B
             THEN NW1RECFM = NW1RECFM + 10X;
           IF     CTL_CHR = 'S' AND NW1RECFM = '....0...'B
             THEN NW1RECFM = NW1RECFM + 08X;
           IF     CTL_CHR = 'A' AND NW1RECFM = '.....00.'B
             THEN NW1RECFM = NW1RECFM + 04X;
           IF     CTL_CHR = 'M' AND NW1RECFM = '.....00.'B
             THEN NW1RECFM = NW1RECFM + 02X;
         END;
         *----IF THIS RECORD FORMAT IS ALREADY SET, PRODUCE A MESSAGE-*;
         IF   UPDRECFM = NW1RECFM
           THEN LINK GENERROR;
           ELSE
             DO;
                LINK GENCCHHR /*GENERATE CCHHR STATEMENT*/;
                LINK GENRECFM /*GENERATE VER/REP STATEMENTS*/;
             END;
         PUT CTL 'SPECIFIED.';
         RETURN;
       PAGE;
       *-----GENERATE AMASPZAP CONTROL STATEMENTS TO SET-----------*;
       *-----A NEW EXPIRATION DATE VALUE CORRESPONDING TO----------*;
       *-----A RETPD=NNNN CONTROL SPECIFICATION.-------------------*;
       SETRETPD:
          *-----DEVELOP THE NEW AND OLD DATE VALUES------------*;
          UPDDATE = UPDEXPYY*65536 + UPDEXPDD;
          DATEDATE = TODAY() + CTL_VAL;   /*NEW EXPDT*/
          IF DATEDATE > '31DEC1999'D THEN DATEDATE = '31DEC1999'D ;
          DATE_JJJ = JULDATE(DATEDATE);    /*NEW EXPDT IN JULIAN*/
          DATE_YY = INT(DATE_JJJ/1000);
          DATE_DDD = MOD(DATE_JJJ,1000);
          NW1DATE  = DATE_YY * 65536 + DATE_DDD;
          *-----IF THIS DATE IS ALREADY SET, PRODUCE A MESSAGE.-;
          IF   UPDDATE = NW1DATE
            THEN LINK GENERROR;
            ELSE
               DO;
                 LINK GENCCHHR /*GENERATE CCHHR   STATEMENT */;
                 LINK GENEXPDT /*GENERATE EXPDT UPDATES     */;
               END;
          PUT  CTL;
          PUT
             @001 '*'
             @044 '(EXPDT=' DATEDATE DATE9.
                  ' ('
                   DATE_YY  Z2.
                  '.'
                   DATE_DDD Z3.
                  ')) SPECIFIED.';
          RETURN;
       PAGE;
       *-----GENERATE AMASPZAP CONTROL STATEMENTS TO SET-------------*;
       *-----A NEW LENGTH VALUE FOR DS1BLKL,DS1KEYL, OR DS1RKP.------*;
       SETBLKL: ;
       SETKEYL: ;
       SETLRECL:;
       SETRKP:  ;
          *-----DEVELOP THE NEW AND OLD LENGTH VALUES.---------*;
          IF     CTL_KEY =: 'BLKSIZE='  THEN UPDLNTH = UPDBLKL;
          IF     CTL_KEY =: 'KEYLEN='   THEN UPDLNTH = UPDKEYL;
          IF     CTL_KEY =: 'LRECL='    THEN UPDLNTH = UPDLRECL;
          IF     CTL_KEY =: 'RKP='      THEN UPDLNTH = UPDRKP;
          NW1LNTH  = CTL_VAL;
          IF     CTL_KEY =: 'LRECL='    AND CTL_STR = 'X'
            THEN NW1LNTH  = 8000X;
          *-----IF THIS LENGTH IS ALREADY SET, PRODUCE A MESSAGE.-;
          IF   UPDLNTH = NW1LNTH
            THEN LINK GENERROR;
            ELSE
               DO;
                 LINK GENCCHHR /*GENERATE CCHHR   STATEMENT */;
                 IF CTL_KEY =: 'BLKSIZE='  THEN LINK GENBLKL;
                 IF CTL_KEY =: 'KEYLEN='   THEN LINK GENKEYL;
                 IF CTL_KEY =: 'LRECL='    THEN LINK GENLRECL;
                 IF CTL_KEY =: 'RKP='      THEN LINK GENRKP;
               END;
          PUT  CTL 'SPECIFIED.';
          RETURN;
       PAGE;
       *-----GENERATE AMASPZAP CONTROL STATEMENTS TO SET-------------*;
       *-----A NEW COUNT VALUE FOR DS1VOLSQ.-------------------------*;
       SETVOLSQ:;
          *-----DEVELOP THE NEW AND OLD COUNT VALUES.---------*;
          NW1VOLSQ  = CTL_VAL;
          *-----IF THIS COUNT IS ALREADY SET, PRODUCE A MESSAGE.-;
          IF   UPDVOLSQ = NW1VOLSQ
            THEN LINK GENERROR;
            ELSE
               DO;
                 LINK GENCCHHR /*GENERATE CCHHR   STATEMENT */;
                 LINK GENVOLSQ;
               END;
          PUT  CTL 'SPECIFIED.';
          RETURN;
       PAGE;
       *-----GENERATE AMASPZAP CONTROL STATEMENTS TO SET-------------*;
       *-----A NEW DATA SET NAME VALUE, BYPASSING SYSTEM PROTECTION.-*;
       SETDSNAM:;
          *-----DEVELOP THE NEW AND OLD DSNAME VALUES.--------*;
          NW1DSNAM  = CTL_STR;
          *-----IF THIS NAME IS ALREADY SET, PRODUCE A MESSAGE.--;
          IF   UPDDSNAM = NW1DSNAM
            THEN LINK GENERROR;
            ELSE
               DO;
                 LINK GENCCHHR /*GENERATE CCHHR   STATEMENT */;
                 LINK GENDSNAM ;
               END;
          PUT  CTL 'SPECIFIED.';
          RETURN;
       PAGE;
       *-----GENERATE THE CCHHR AMASPZAP CONTROL STATEMENT----*;
       GENCCHHR:
          IF CCHHR NE PREVCCHR /*IF DISK CCHHR HAS CHANGED*/
          THEN DO;
                  PUT
                     @002 'CCHHR'
                     @008  CCHHR               $HEX10.
                     @022 'DSN=' DS1DSNAM      $VARYING44. DS1DSNLN;
                  NW1DSN1 = SUBSTR(DS1DSNAM,01,16);
                  NW1DSN2 = SUBSTR(DS1DSNAM,17,16);
                  NW1DSN3 = SUBSTR(DS1DSNAM,33,12);
                  PUT
                     @003 'VER  0000 ' NW1DSN1 $HEX32. @046 'CHECK DSN'
                   / @003 'VER  0010 ' NW1DSN2 $HEX32. @046 'CHECK DSN'
                   / @003 'VER  0020 ' NW1DSN3 $HEX24. @046 'CHECK DSN';
                  PREVCCHR = CCHHR /*SAVE CCHHR DISK ADDRESS*/;
               END;
          RETURN;
       SKIP 3;
       *-----GENERATE AN ERROR MESSAGE FOR UNCHANGED VALUE----*;
       GENERROR:
          PUT
             @001 '*'
             @022 'DSN=' DS1DSNAM      $VARYING44. DS1DSNLN ;
          PUT
             @001 '*'
             @026 'ALREADY HAS ' @;
          RETURN;
       PAGE;
       GENDSNAM:
          *-----GENERATE THE VERIFY AND REP CONTROL STATEMENTS---*;
          *-----TO ALTER FIELD DS1DSNAM.  -----------------------*;
          *;
          *;
          *-----GENERATE THE VERIFY CONTROL STATEMENTS.----------*;
          NW1DSN1 = SUBSTR(UPDDSNAM,01,16);
          NW1DSN2 = SUBSTR(UPDDSNAM,17,16);
          NW1DSN3 = SUBSTR(UPDDSNAM,33,12);
          PUT
             @003 'VER  0000 ' NW1DSN1 $HEX32.
           / @003 'VER  0010 ' NW1DSN2 $HEX32.
           / @003 'VER  0020 ' NW1DSN3 $HEX24.
             @046 'UPDATE DS1DSNAM';
          *;
          *;
          *-----GENERATE THE REPLACE CONTROL STATEMENTS.---------*;
          NW1DSN1 = SUBSTR(NW1DSNAM,01,16);
          NW1DSN2 = SUBSTR(NW1DSNAM,17,16);
          NW1DSN3 = SUBSTR(NW1DSNAM,33,12);
          PUT
             @003 'REP  0000 ' NW1DSN1 $HEX32.
           / @003 'REP  0010 ' NW1DSN2 $HEX32.
           / @003 'REP  0020 ' NW1DSN3 $HEX24.
           / @001 '*'
             @026 'TO HAVE ' @;
          *;
          *;
          *-----RESET THE DS1DSNAM FIELD FOR PROCESSING AGAIN.---*;
          UPDDSNAM = NW1DSNAM; /*RESET THE FIELD FOR PROCESSING AGAIN*/
          RETURN;
       PAGE;
       GENVOLSQ:
          *-----GENERATE THE VERIFY AND REP CONTROL STATEMENTS---*;
          *-----TO ALTER FIELD DS1VOLSQ.  -----------------------*;
          PUT    /*GENERATE THE VERIFY CONTROL STATEMENT*/
            @003 'VER  0033 ' UPDVOLSQ HEX4.
            @026 'UPDATE DS1VOLSQ';
          PUT    /*GENERATE THE REPLACE CONTROL STATEMENT*/
            @003 'REP  0033 ' NW1VOLSQ HEX4.
            @026 'TO HAVE ' @;
          UPDVOLSQ = NW1VOLSQ; /*RESET THE FIELD FOR PROCESSING AGAIN*/
          RETURN;
       PAGE;
       GENCREDT:
          *-----GENERATE THE VERIFY AND REP CONTROL STATEMENTS---*;
          *-----TO ALTER FIELD DS1CREDT.  -----------------------*;
          PUT    /*GENERATE THE VERIFY CONTROL STATEMENT*/
            @003 'VER  0035 ' UPDDATE  HEX6.
            @026 'UPDATE DS1CREDT';
          PUT    /*GENERATE THE REPLACE CONTROL STATEMENT*/
            @003 'REP  0035 ' NW1DATE  HEX6.
            @026 'TO HAVE ' @;
          UPDCREDT = DATEDATE; /*RESET THE FIELD FOR PROCESSING AGAIN*/
          UPDCREYY = DATE_YY ; /*RESET THE FIELD FOR PROCESSING AGAIN*/
          UPDCREDD = DATE_DDD; /*RESET THE FIELD FOR PROCESSING AGAIN*/
          RETURN;
       SKIP 2;
       GENEXPDT:
          *-----GENERATE THE VERIFY AND REP CONTROL STATEMENTS---*;
          *-----TO ALTER FIELD DS1EXPDT.  -----------------------*;
          PUT    /*GENERATE THE VERIFY CONTROL STATEMENT*/
            @003 'VER  0038 ' UPDDATE  HEX6.
            @026 'UPDATE DS1EXPDT';
          PUT    /*GENERATE THE REPLACE CONTROL STATEMENT*/
            @003 'REP  0038 ' NW1DATE  HEX6.
            @026 'TO HAVE ' @;
          UPDEXPDT = DATEDATE; /*RESET THE FIELD FOR PROCESSING AGAIN*/
          UPDEXPYY = DATE_YY ; /*RESET THE FIELD FOR PROCESSING AGAIN*/
          UPDEXPDD = DATE_DDD; /*RESET THE FIELD FOR PROCESSING AGAIN*/
          RETURN;
       SKIP 2;
       GENREFDT:
          *-----GENERATE THE VERIFY AND REP CONTROL STATEMENTS---*;
          *-----TO ALTER FIELD DS1REFD    -----------------------*;
          PUT    /*GENERATE THE VERIFY CONTROL STATEMENT*/
            @003 'VER  004B ' UPDDATE  HEX6.
            @026 'UPDATE DS1REFD';
          PUT    /*GENERATE THE REPLACE CONTROL STATEMENT*/
            @003 'REP  004B ' NW1DATE  HEX6.
            @026 'TO HAVE ' @;
          UPDREFDT = DATEDATE; /*RESET THE FIELD FOR PROCESSING AGAIN*/
          UPDREFYY = DATE_YY ; /*RESET THE FIELD FOR PROCESSING AGAIN*/
          UPDREFDD = DATE_DDD; /*RESET THE FIELD FOR PROCESSING AGAIN*/
          RETURN;
       PAGE;
       GENDSORG:
          *-----GENERATE THE VERIFY AND REP CONTROL STATEMENTS---*;
          *-----TO ALTER FIELD DS1DSORG   -----------------------*;
          PUT    /*GENERATE THE VERIFY CONTROL STATEMENT*/
            @003 'VER  0052 ' UPDDSORG HEX4.
            @026 'UPDATE DS1DSORG';
          PUT    /*GENERATE THE REPLACE CONTROL STATEMENT*/
            @003 'REP  0052 ' NW1DSORG HEX4.
            @026 'TO HAVE ' @;
          UPDDSORG = NW1DSORG; /*RESET THE FIELD FOR PROCESSING AGAIN*/
          RETURN;
       SKIP 2;
       GENRECFM:
          *-----GENERATE THE VERIFY AND REP CONTROL STATEMENTS---*;
          *-----TO ALTER FIELD DS1RECFM   -----------------------*;
          PUT    /*GENERATE THE VERIFY CONTROL STATEMENT*/
            @003 'VER  0054 ' UPDRECFM HEX2.
            @026 'UPDATE DS1RECFM';
          PUT    /*GENERATE THE REPLACE CONTROL STATEMENT*/
            @003 'REP  0054 ' NW1RECFM HEX2.
            @026 'TO HAVE ' @;
          UPDRECFM = NW1RECFM; /*RESET THE FIELD FOR PROCESSING AGAIN*/
          RETURN;
       PAGE;
       GENBLKL:
          *-----GENERATE THE VERIFY AND REP CONTROL STATEMENTS---*;
          *-----TO ALTER FIELD DS1BLKL    -----------------------*;
          PUT    /*GENERATE THE VERIFY CONTROL STATEMENT*/
            @003 'VER  0056 ' UPDBLKL  HEX4.
            @026 'UPDATE DS1BLKL ';
          PUT    /*GENERATE THE REPLACE CONTROL STATEMENT*/
            @003 'REP  0056 ' NW1LNTH  HEX4.
            @026 'TO HAVE ' @;
          UPDBLKL  = NW1LNTH; /*RESET THE FIELD FOR PROCESSING AGAIN*/
          RETURN;
       SKIP 1;
       GENLRECL:
          *-----GENERATE THE VERIFY AND REP CONTROL STATEMENTS---*;
          *-----TO ALTER FIELD DS1LRECL   -----------------------*;
          PUT    /*GENERATE THE VERIFY CONTROL STATEMENT*/
            @003 'VER  0058 ' UPDLRECL HEX4.
            @026 'UPDATE DS1LRECL';
          PUT    /*GENERATE THE REPLACE CONTROL STATEMENT*/
            @003 'REP  0058 ' NW1LNTH  HEX4.
            @026 'TO HAVE ' @;
          UPDLRECL = NW1LNTH; /*RESET THE FIELD FOR PROCESSING AGAIN*/
          RETURN;
       SKIP 1;
       GENKEYL:
          *-----GENERATE THE VERIFY AND REP CONTROL STATEMENTS---*;
          *-----TO ALTER FIELD DS1KEYL    -----------------------*;
          PUT    /*GENERATE THE VERIFY CONTROL STATEMENT*/
            @003 'VER  005A ' UPDKEYL  HEX2.
            @026 'UPDATE DS1KEYL';
          PUT    /*GENERATE THE REPLACE CONTROL STATEMENT*/
            @003 'REP  005A ' NW1LNTH  HEX2.
            @026 'TO HAVE ' @;
          UPDKEYL  = NW1LNTH; /*RESET THE FIELD FOR PROCESSING AGAIN*/
          RETURN;
       SKIP 1;
       GENRKP:
          *-----GENERATE THE VERIFY AND REP CONTROL STATEMENTS---*;
          *-----TO ALTER FIELD DS1RKP     -----------------------*;
          PUT    /*GENERATE THE VERIFY CONTROL STATEMENT*/
            @003 'VER  005B ' UPDRKP   HEX4.
            @026 'UPDATE DS1RKP';
          PUT    /*GENERATE THE REPLACE CONTROL STATEMENT*/
            @003 'REP  005B ' NW1LNTH  HEX4.
            @026 'TO HAVE ' @;
          UPDRKP   = NW1LNTH; /*RESET THE FIELD FOR PROCESSING AGAIN*/
          RETURN;
       PAGE;
       GENDSIND:
          *-----GENERATE THE VERIFY AND REP CONTROL STATEMENTS---*;
          *-----TO ALTER FIELD DS1DSIND.  -----------------------*;
          PUT    /*GENERATE THE VERIFY CONTROL STATEMENT*/
            @003 'VER  005D ' UPDDSIND HEX2.
            @026 'UPDATE DS1DSIND';
          PUT    /*GENERATE THE REPLACE CONTROL STATEMENT*/
            @003 'REP  005D ' NW1DSIND HEX2.
            @026 'TO HAVE ' @;
          UPDDSIND = NW1DSIND; /*RESET FIELD FOR PROCESSING AGAIN*/
          RETURN;
