*              /* LEVEL=0000                                         */
*PROCESS X,A,AG,S,STG,LIST,NEST,F(I),LMSG,MAP,ESD,OPT(2),OF;
 XXPARSM:
   PROC(PARM_STRING,MAX_DEVICES, CENTRE, METHOD, INFO_PTR)
   OPTIONS(REENTRANT) REORDER;
 %SKIP(4);
 /********************************************************************/
 /*               GOODMANS VERSION                                   */
 /********************************************************************/
 /*  XXPARSM IS THE PARAMETER PARSE ROUTINE OF XXDEVMN.              */
 /*  PARAMETERS ACCEPTED ARE:                                        */
 /*  MAX_DEVICES: MAXIMUM NUMBER OF DEVICES THAT ARE TO BE           */
 /*               EXPECTED.  THE PROGRAM ALLOCATES STORAGE           */
 /*               ACCORDINGLY.  (DEFAULT VALUE IS 2).                */
 /*  CENTRE:      IS USED TO PROVIDE DEVICE INFORMATION AS TO        */
 /*               WHICH CENTRE IS BEING USED. (DEFAULT COMPILED      */
 /*               IS THE CENTRE AT WHICH THE PROGRAM IS BEING RUN.   */
 /*               THIS COPY HAS GOODMANS AS THE DEFAULT.)            */
 /*  METHOD:      METHOD OF SELECTING BUSIEST CYLINDERS              */
 /*               EITHER 1. BUSIEST ROW SUMS                         */
 /*                      2. LARGEST INDIVIDUAL ENTRIES.              */
 /*                      3. LARGEST NON-DIAGONAL ENTRIES.            */
 /*               (DEFAULT IS ROW SUMS).                             */
 /********************************************************************/
 /*   LEVL(0000)  26 JANUARY 1979.                                   */
 /********************************************************************/
 /* WRITTEN BY    JOHN H LISTER,                                     */
 /*               TECHNICAL SERVICES GROUP,                          */
 /*               DATA PROCESSING DEPARTMENT,                        */
 /*               NATIONAL WESTMINSTER BANK,                         */
 /*               GOODMANS FIELDS COMPUTER CENTRE,                   */
 /*               74 ALIE STREET, LONDON   E1 8HL.                   */
 /*                                                                  */
 /*               TELEPHONE: 01-488 0707 EXT 2766.                   */
 /********************************************************************/
 %SKIP(4);
   DEFAULT
      RANGE(*) FIXED ;
 %SKIP(4);
 /* PARAMETERS */
 %SKIP;
   DCL
      PARM_STRING CHAR(100) VARYING,   /* INPUT PARM STRING AS COPIED
                                       FROM EXEC CARD (READ) */
      MAX_DEVICES BIN(15),             /* MAXIMUM NUMBER OF DEVICES
                                       ALLOWED (WRITE) */
      CENTRE FIXED BIN(15),            /* CENTRE AT WHICH PROGRAM IS
                                       RUN (WRITE) */
      METHOD BIN(15),                  /* METHOD OF EVALUATING BUSIEST
                                       ROWS (WRITE) */
      INFO_PTR POINTER;                /* POINTER TO DEVICE
                                       INFORMATION (WRITE) */
 %SKIP(4);
 /* EXTERNAL */
 %SKIP;
   DCL
      DEVCHAR(4) EXTERNAL STATIC CHAR(7) INIT('3330   ','3330-II',
   '3350   ','3350-FH');               /* CHARACTER FORMS OF DEVICE
                                       TYPES */
 %SKIP(4);
 /* CONSTANTS */
 %SKIP;
   DCL
      DOLIST(5,0:4) STATIC BIN(15) INIT( /*STATE TABLE */18, /* (1,0)
 N=2 A=1 KEYWORD AS MAIN_PARM */32, /* (1,1) N=0 A=2 BLANK KEYWORD AS
 MAIN_PARM */48, /* (1,2) N=0 A=3 EOS NO MAIN_PARM */129, /* (1,3) N=1
 A=8 ERROR ) IN WRONG PLACE */115, /* (1,4) N=3 A=7 MAIN_PARM BLANK
 SUB_PARMS**/64, /* (2,0) N=0 A=4 RETURN MAIN_PARM REUSE */32, /*
 (2,1) N=0 A=2 RETURN MAIN_PARM */64, /* (2,2) N=0 A=4 RETURN
 MAIN_PARM REUSE */130, /* (2,3) N=2 A=8 ERROR SKIP ) */115, /* (2,4)
 N=3 A=7 ( GET SUB_PARMS */84, /* (3,0) N=4 A=5 ENTER NEXT SUB_PARM */
   100, /* (3,1) N=4 A=6 BLANK SUB_PARM */144, /* (3,2) N=0 A=9 EOS
 ERROR EXIT */101, /* (3,3) N=5 A=6 BLANK SUB_PARM EOLIST */131, /*
 (3,4) N=3 A=8 ERROR IGNORE ( */83, /* (4,0) N=3 A=5 KEYWORD NEXT
 SUB_PARM */115, /* (4,1) N=3 A=7 SKIP , */144, /* (4,2) N=0 A=9 ERROR
 EOS EXIT */117, /* (4,3) N=5 A=7 END OF PARM_LIST */132, /* (4,4) N=4
 A=8 ERROR IGNORE ( */64, /* (5,0) N=0 A=4 RETURN REUSE */32, /* (5,1)
 N=0 A=2 RETURN SKIP */64, /* (5,2) N=0 A=4 RETURN REUSE */133, /*
 (5,3) N=5 A=8 ERROR IGNORE ) */133 /* (5,4) N=5 A=8 ERROR IGNORE ( */);
 /* DOLIST IS THE SYMBOL STATE TABLE DRIVING XXPARSM. THE ENTRIES ARE
 OF THE FORM ACTION*16+NEXT STATE, WHERE ACTION IS THE ACTION TO BE
 PERFORMED THIS TIME, AND NEXT STATE IS THE NEXT STATE OF THE PARSE
 ROUTINE, WHICH IS A FINITE STATE AUTOMATON */
 %SKIP(4);
 /* ENTRY */
 %SKIP;
   DCL
      XXKEGWM ENTRY() RETURNS(POINTER), /* ENTRY WHICH ALLOCATES
                                       KEGWORTH DEVICE DATA */
      XXGOODM ENTRY() RETURNS(POINTER);/* ENTRY WHICH ALLOCATES
                                       GOODMANS DEVICE DATA */
 %SKIP(4);
 /* BASED VARIABLE TEMPLATES */
 %SKIP;
   DCL
      1 ALTERATION_INFO BASED(ALTPTR), /* BLOCK CONTAINING INFORMATION
                                       ABOUT ALTERATIONS TO THE DEVICE
                                       TABLE */
         2 DEVICE_TYPE FIXED BIN(15),  /* DEVICE TYPE */
         2 BOTTOM_OF_RANGE FIXED BIN(15), /* BOTTOM OF RANGE FOR THIS
                                       DEVICE TYPE */
         2 TOP_OF_RANGE FIXED BIN(15), /* TOP OF RANGE */
         2 ALIAS_START FIXED BIN(15),  /* ALTERNATE PATH ADDRESS */
         2 NEXT_BLOCK POINTER;         /* POINTER TO NEXT BLOCK */
   DCL
      DEVICE_INFO(0:4095) FIXED BIN(15) BASED(DEV_PTR);/* POINTER TO
                                       DEVICE INFORMATION TABLE */
 %SKIP(4);
 /*LOCAL VARIABLES*/
 %SKIP;
   DCL
      1 PARMLIST,                      /*PARAMETER STRUCTURE */
         2 MAIN_PARM CHAR(8),          /* MAIN KEYWORD */
         2 SUB_PARMS(5) CHAR(8),       /* SUB PARAMETERS */
         2 #SUBPARMS BIN(15),          /* NUMBER OF SUB PARAMETERS */
         2 NO_PARM_FOUND BIT(1) ALIGNED;/* FLAG TO INDICATE END OF
                                       STRING */
   DCL
      (BOT_RANGE,
      TOP_RANGE) FIXED BIN(15);        /* BOTTOM AND TOP OF RANGES FOR
                                       DEVICE ALTERATION */
   DCL
      (IN_STRING,
      TRANSLATED_STRING) CHAR(100);    /* IN_STRING IS USED TO HOLD
                                       THE INPUT PARAMETER STRING.
                                       TRANSLATED_STRING IS USED TO
                                       HOLD THE SAME INFORMATION
                                       EXCEPT THAT EVERY DELIMITER -
                                       (), - HAS BEEN TRANSLATED TO A
                                       SPACE FOR RECOGNITION PURPOSES */
   DCL
      (KEYWORD#,                       /* NUMBER OF KEYWORD IN LIST IN
                                       VALID */
      ALT_VALUE ) BIN(15);             /* ALTERNATE NUMBER OF KEYWORD
                                       IN IN LIST */
   DCL
      ALTERATION_EXISTS BIT(1) ALIGNED INIT('0'B);/* FLAG TO INDICATE
                                       THAT THERE ARE MODIFICATIONS TO
                                       THE DEVICE_INFO TABLE */
   DCL
      PRES_SYMBOL CHAR(8),             /* CURRENT SYMBOL USED IN PARSE
                                       LOOP */
      FIRST_CHAR CHAR(1) DEF PRES_SYMBOL POS(1);/* USED TO PICK OFF
                                       FIRST CHARACTER OF PRES_SYMBOL */
   DCL
      (START_POS,                      /* STARTING POSITION, AND
                                       THEREAFTER CURRENT POSITION IN
                                       IN_STRING AND TRANSLATED_STRING
                                       WHERE SCANNING IS TO RESTART */
      END_POS ) BIN(15);               /* END POSITION IN IN_STRING
                                       AND TRANSLATED_STRING WHERE
                                       SCANNING IS TO STOP */
   DCL
      LEN1 BIN(15);                    /* TEMPORARY USED FOR LENGTHS
                                       OF STRINGS */
   DCL
      LOOP BIN(15);                    /* LOOP COUNTER */
   DCL
      (SYMB_CLASS,                     /* USED IN PARS LOOP TO DENOTE
                                       SYMBOL CLASS */
      WHATDO,                          /* USED IN PARSE LOOP TO HOLD
                                       ACTION NUMBER */
      STATE,                           /* USED IN PARSE LOOP TO HOLD
                                       STATE */
      NEXT_STATE) BIN(15);             /* USED IN PARSE LOOP TO HOLD
                                       NEXT STATE */
   DCL
      DEV_LOOP BIN(15) ;               /* LOOP COUNTER TO FIND OUT
                                       DEVICE TYPE */
   DCL
      (BASE_OF_CHAIN,                  /* POINTER TO BASE OF
                                       ALTERATION DATA CHAIN */
      DEV_PTR,                         /* USED AS TEMPORARY TO HOLD
                                       BASE OF DEVICE INFORMATION */
      LATEST_ONE,                      /* POINTER TO LATEST GENERATION
                                       OF ALTERATION INFO */
      ALTPTR ) POINTER INIT(NULL());   /* DEFAULT POINTER FOR
                                       ALTERATION INFO */
   DCL
      (DONE,                           /* FLAG TO INDICATE PARS OF ONE
                                       PARAMTER IS COMPLETE */
      DONT_GET_NEXT_KEYWORD) BIT(1) ALIGNED;/* FLAG TO INDICATE TO
                                       PARSE ROUTINE THAT IT IS TO
                                       REUSE THE LAST KEYWORD */
   DCL
      ALTADDR BIN(15);                 /* ALTERNATE PATH TEMPORARY */
   DCL
      (TEMP_DEVICE_TYPE) BIN(15);      /* DEVICE TYPE TEMPORARY */
 %SKIP(4);
 /* BUILT IN FUNCTIONS */
 %SKIP;
   DCL
      ( MAX,
      MIN,
      SUBSTR,
      INDEX,
      TRANSLATE,
      MOD,
      NULL ) BUILTIN;
 %PAGE;
 /* PRELIMINARIES */
 %SKIP(2);
 /* ASSIGN DEFAULTS */
 %SKIP;
      CENTRE=1;                        /* GOODMANS */
      MAX_DEVICES=2;                   /* MAXIMUM NUMBER OF DEVICES */
      METHOD=1;                        /* ROW SUMS */
 %SKIP(4);
      IN_STRING=PARM_STRING;           /* SAVE INPUT PARAMETER STRING
                                       AS A LOCAL FIXED LENGTH STRING */
      END_POS=SLENGTH(IN_STRING);      /* FIND ITS REAL LENGTH - IE
                                       THE INDEX IN THE STRING OF THE
                                       LAST NON-BLANK CHARACTER */
      START_POS=1;                     /* SET THE POSITION-COUNTER
                                       WITHIN THE STRING TO THE
                                       BEGINNING OF THE STRING */
      CALL SKIP_BLANKS;                /* SKIP PAST ANY BLANKS AT THE
                                       BEGINNING */
      DONT_GET_NEXT_KEYWORD='0'B;      /* SET FLAG SO THAT FIRST
                                       KEYWORD IS EXTRACTED */
      IF (END_POS = 0)×(START_POS > END_POS) THEN
         GOTO ONLY_DEFAULTS;           /* THE INPUT PARAMETER STRING
                                       IS NULL SO APPLY DEFAULTS */
 %SKIP(4);
      TRANSLATED_STRING=
      TRANSLATE(IN_STRING, '   ', '(),');/* TRANSLATE ALL THE
                                       DELIMITERS ')(,' TO BLANKS */
 %SKIP(4);
 /* PARSE LOOP */
 %SKIP;
      DO WHILE('1'B);                  /* FOREVER - OR AT LEAST UNTIL
                                       A LEAVE */
         SUB_PARMS='';                 /* BLANK OUT THE SUBPARAMETERS */
         MAIN_PARM='';                 /* BLANK OUT THE MAIN PARAMETER
                                       */
         #SUBPARMS=0;                  /* HAVEN'T FOUND ANY PARAMETER
                                       THIS TIME */
         NO_PARM_FOUND='0'B;           /* NO PARAMETER FOUND YET */
         STATE=1;                      /* FIRST STATE OF THE FINITE
                                       STATE AUTOMATON */
         DONE='0'B;                    /* FLAG TO INDICATE PARAMETER
                                       FOUND */
         DO UNTIL(DONE);
            IF ^DONT_GET_NEXT_KEYWORD THEN
               DO;                     /* GET NEXT KEYWORD */
                  PRES_SYMBOL=NEXT_SYMBOL;
                  SYMB_CLASS=INDEX(', )(',FIRST_CHAR);/* FIND THE
                                       CLASS OF THE SYMBOL WHICH
                                       DEPENDS ON ITS FIRST CHARACTER
                                       - IF IT IS ALPHAMERIC THEN THE
                                       SYMBOL IS A KEYWORD, OTHERWISE
                                       IT IS A DELMITER */
               END;
            DONT_GET_NEXT_KEYWORD='0'B;/* DEFAULT OF GET NEW KEYWORD
                                       NEXT TIME ROUND THE LOOP */
            WHATDO=DOLIST(STATE,SYMB_CLASS);/* ACTION DEPENDS ON THE
                                       STATE OF THE AUTOMATON AND THE
                                       CLASS OF THE INPUT SYMBOL */
            NEXT_STATE=MOD(WHATDO,16); /* GET NEXT STATE FROM ENCODED
                                       ENTRY */
            WHATDO=WHATDO/16;          /* DIVIDE BY 16 TO DETERMINE
                                       ACTION */
            SELECT(WHATDO);            /* SELECT ON THE ACTION TO BE
                                       PERFORMED */
               WHEN(1)
                  DO;                  /* FIRST KEYWORD FOUND THIS
                                       TIME THROUGH THE LOOP, SO IT
                                       MUST BE A MAIN PARAMETER */
                     MAIN_PARM=PRES_SYMBOL;
                  END;
               WHEN(2)
                  DO;                  /* FOUND A PARAMETER, SO SET
                                       FLAG TO INDICATE FINISHED */
                     DONE='1'B;
                  END;
               WHEN(3)
                  DO;                  /* RUN OUT OF TEXT */
                     DONE,NO_PARM_FOUND='1'B;
                  END;
               WHEN(4)
                  DO;                  /* FINISHED, BUT DECIDED THAT
                                       ON CURRENT SYMBOL WHICH IS A
                                       KEYWORD AND IS THEREFORE THE
                                       NEXT MAIN PARAMETER. SET FLAG
                                       TO INDICATE THAT THIS KEYWORD
                                       IS TO BE REUSED NEXT TIME */
                     DONE,DONT_GET_NEXT_KEYWORD='1'B;
                  END;
               WHEN(5)
                  DO;                  /* A NEW SUBPARAMETER */
                     #SUBPARMS=#SUBPARMS+1;/* UP COUNT OF NUMBER OF
                                       SUBPARAMETERS */
                     IF #SUBPARMS<=5 THEN
                        SUB_PARMS(#SUBPARMS)=PRES_SYMBOL;/* DON'T WANT
                                       TO KNOW ABOUT MORE THAN 5
                                       SUBPARAMETERS */
                  END;
               WHEN(6)
                  DO;
                     #SUBPARMS=#SUBPARMS+1;/* TWO COMMAS OCCURING
                                       TOGETHER OR SEPARATED BY SOME
                                       BLANKS - SUBPARAMETER IS A
                                       BLANK */
                  END;
               WHEN(7)
                  ;                    /* NULL ACTION - USED MERELY TO
                                       CHANGE STATE OF AUTOMATON */
               WHEN(8)
                  ;                    /* NULL - BUT AN ERROR HAS
                                       OCCURRED AND A MESSAGE
                                       DETAILING THE ERROR COULD BE
                                       OUTPUT HERE */
               WHEN(9)
                  DO;                  /* ERROR - UNEXPECTED END
                                       OFINPUT WHILE WAITING FOR A
                                       CLOSING BRACKET ON A
                                       SUBPARAMETER LIST */
                     DONE='1'B;        /* FINISHED */
                     DONT_GET_NEXT_KEYWORD='1'B;
                     NO_PARM_FOUND='1'B;/* IGNORE ANY PARM INFORMATION
                                       PRESENT */
                  END;
            END;
            STATE=NEXT_STATE;          /* SET THE AUTOMATON TO ITS NEW
                                       STATE */
         END;
 %SKIP(4);
         IF NO_PARM_FOUND THEN
            GOTO APPLY_THEM;           /* IF WE HAVEN'T FOUND ANOTHER
                                       PARAMETER GO AND APPLY THEM */
 %SKIP(4);
         ;                             /* SYNTAX CHECK OF PARAMETER
                                       COMPLETE - NOW DO THE SEMANTICS
                                       */
         LEN1=SLENGTH(MAIN_PARM);      /* LENGTH OF MAIN PARAMETER */
         IF LEN1 = 0 THEN
            DO;                        /* MAIN PARAMETER IS BLANK -
                                       THE ONLY VALID CHOICE IS A
                                       DEVICE TABLE ALTERATION LIST OF
                                       SUBPARAMETERS */
               IF ^((#SUBPARMS=3)×(#SUBPARMS=4)) THEN
                  GOTO NEXT_PARM_PROCESS;/* ERROR - DEVICE TABLE
                                       ALTERATION PARAMETERS MUST HAVE
                                       EITHER THREE OR FOUR
                                       SUBPARAMERS */
               DO DEV_LOOP = 1 TO 4;   /* SEARCH FOR DEVICE TYPE */
                  IF SUBSTR(SUB_PARMS(1),1,7)=DEVCHAR(DEV_LOOP) THEN
                     GOTO FOUND_DEVICE;/* DEVICE TYPE FOUND */
               END;
               GOTO NEXT_PARM_PROCESS; /* ERROR - IF CONTROL DROPS OUT
                                       OF THE BOTTOM OF THE LOOP, THEN
                                       THE DEVICE TYPE IS NOT FOUND -
                                       A MESSAGE COULD BE OUTPUT HERE
                                       - THE PARAMETER IS IGNORED */
 FOUND_DEVICE:
               BOT_RANGE=COMPHEX(SUB_PARMS(2),3);/* CONVERT BOTTOM OF
                                       RANGE OF ADDRESSES TO BE
                                       MODIFIED FROM HEX CHARACTERS IN
                                       EBCDIC INTO ITS BINARY VALUE */
               TOP_RANGE=COMPHEX(SUB_PARMS(3),3);/* CONVERT TOP OF
                                       RANGE OF ADDRESSES TO BE
                                       MODIFIED FROM HEX CHARACTERS IN
                                       EBCDIC INTO ITS BINARY VALUE */
               IF (BOT_RANGE < 0)×(TOP_RANGE < 0)×(
                TOP_RANGE < BOT_RANGE) THEN
                  GOTO NEXT_PARM_PROCESS;/* ERROR - COMPHEX HAS
                                       RETURNED -1 FOR ONE OR BOTH OF
                                       THE ADDRESSES INDICATING THAT
                                       THE PARAMETER WAS INVALID, OR
                                       THE BOTTOM OF THE RANGE IS
                                       GREATER THAN THE TOP OF THE
                                       RANGE */
               ALLOCATE ALTERATION_INFO;/* ALLOCATE A BLOCK DESCRIBING
                                       THE DEVICE ALTERATION */
               IF BASE_OF_CHAIN = NULL() THEN
                  DO;                  /* FIRST TIME IN */
                     BASE_OF_CHAIN=ALTPTR;
                  END;
               ELSE
                  DO;
                     LATEST_ONE->NEXT_BLOCK=ALTPTR;/* CHAIN IT ON */
                  END;
               ;                       /* ALLOCATED BLOCK IS NOW
                                       CHAINED ON TO THE END OF THE
                                       CURRENTLY ALLOCATED BLOCKS OR
                                       ITS ADDRESS STORED IN THE
                                       LOCATION OF THE BASE OF THE
                                       CHAIN */
               LATEST_ONE=ALTPTR;      /* SET END OF CHAIN POINTER TO
                                       NEW BLOCK'S ADDRESS */
               DEVICE_TYPE=DEV_LOOP;   /* PUT IN VALUES - DEVICE TYPE */
               BOTTOM_OF_RANGE=BOT_RANGE;/* BOTTOM OF THE RANGE OF
                                       ADDRESSES TO BE ALTERED */
               TOP_OF_RANGE=TOP_RANGE; /* TOP OF THE RANGE OF
                                       ADDRESSES TO BE ALTERED */
               NEXT_BLOCK=NULL();      /* NEXT BLOCK POINTER IS NULL
                                       AS THERE IS NOT A NEXT BLOCK
                                       YET */
               IF #SUBPARMS=4 THEN
                  DO;                  /* THE FOURTH SUBPARAMETER IS
                                       THE ADDRESS OF THE MAIN PATH.
                                       ONLY THE FIRST TWO DIGITS OF
                                       THIS ARE SIGNIFICANT, THE THIRD
                                       DIGIT IS TAKEN FROM THE THIRD
                                       DIGIT OF THE MAIN PATH ADDRESS.
                                       THIS ADDRESS IS THE ADDRESS OF
                                       THE FIRST DEVICE IN THE VALUE
                                       RANGE - THE ALTERNATE PATH
                                       ADDRESSES OF THE REST OF THE
                                       DEVICES ARE FOUND BY
                                       INCREMENTING THE ALTERNATE PATH
                                       ADDRESSES BY 1 EACH TIME */
                     BOT_RANGE=COMPHEX(SUB_PARMS(4),2);/* CONVERT
                                       FIRST TWO DIGITS OF ALTERNATE
                                       PATH ADDRESS INTO HEX */
                     IF BOT_RANGE >= 0 THEN
                        ALIAS_START=BOT_RANGE;/* VALID BOTTOM OF
                                       ALTERNATE PATH ADDRESS RANGE */
                     ELSE
                        ALIAS_START=-1;/* ERROR - INVALID ALTERNATE
                                       PATH ADDRESS, SO IGNORE IT AND
                                       SET FLAG TO INDICATE NO
                                       ALTERNATE PATH */
                  END;
               ELSE
                  ALIAS_START=-1;      /* FLAG VALUE TO INDICATE THAT
                                       THERE IS NO ALTERNATE PATH */
               ALTERATION_EXISTS='1'B; /* SET FLAG TO INDICATE THAT
                                       THERE HAS BEEN AT LEAST ONE
                                       DEVICE TABLE ALTERATION
                                       PARAMETER */
            END;
         ELSE
            DO;                        /* NON BLANK MAIN PARAMETER -
                                       SHOULD BE ONE OF THE KEYWORD
                                       PARAMETERS OR A NUMBER
                                       INDICATING THE MAXIMUM NUMBER
                                       OF DEVICES THE PROGRAM IS TO
                                       ACCEPT */
               KEYWORD#=VALID(MAIN_PARM,LEN1,ALT_VALUE);/* SEARCH
                                       KEYWORD TABLE TO FIND IT */
               SELECT(KEYWORD#);       /* SELECT ON THE KEYWORD NUMBER
                                       RETURNED BY VALID */
                  WHEN(0)
                     DO;               /* NOT A KEYWORD - ONLY OTHER
                                       VALID ALTERNATIVE IS NUMBER OF
                                       DEVICES */
                        ALT_VALUE=COMPDEC(MAIN_PARM,LEN1);/* CONVERT
                                       PARAMETER FROM EBCDIC DECIMAL
                                       VALUE INTO BINARY */
                        IF ALT_VALUE >= 0 THEN
                           MAX_DEVICES=MIN(20,ALT_VALUE);/* PARAMETER
                                       WAS A VALID DECIMAL VALUE */
                        ;              /* IGNORE IT OTHERWISE */
                     END;
                  WHEN(1)
                     DO;               /* PARAMETER WAS A VALID CENTRE
                                       KEYWORD, WITH THE ALTERNATIVE
                                       RETURNED IN ALT_VALUE, (1) =
                                       GOODMANS CENTRE, (2) = KEGWORTH
                                       CENTRE */
                        CENTRE=ALT_VALUE;/* ASSIGN ALTERNATE VALUE TO
                                       CONTROL VARIABLE */
                     END;
                  WHEN(2)
                     DO;               /* PARAMETER WAS A VALID METHOD
                                       KEYWORD, WITH THE METHOD TYPE
                                       RETURNED IN ALT_VALUE, (1) =
                                       ROW SUMS, (2) = MAXIMUM
                                       ELEMENTS, (3) = MAXIMUM
                                       ELEMENTS IGNORING DIAGONALS */
                        METHOD=ALT_VALUE;/* SET CONTROL VARIABLE TO
                                       VALUE SPECIFIED */
                     END;
               END;
            END;
 NEXT_PARM_PROCESS:
         ;                             /* GO ROUND THE LOOP UNTIL NO
                                       MORE PARAMETERS REMAIN */
      END;
 %PAGE;
 /* PARMS PROCESSED SO NOW PUT THEM INTO EFFECT */
 %SKIP(2);
 ONLY_DEFAULTS:
      ;                                /* GO TO HERE WHEN NO PARMS
                                       PRESENT */
 APPLY_THEM:
      ;                                /* GO TO HERE WHEN NO MORE
                                       PARAMETERS */
      SELECT(CENTRE);                  /* ALLOCATE DEVICE INFORMATION */
         WHEN(1)
            DEV_PTR=XXGOODM();         /* GOODMANS CENTRE CHOSEN */
         WHEN(2)
            DEV_PTR=XXKEGWM();         /* KEGWORTH CENTRE CHOSEN */
      END;
      IF ALTERATION_EXISTS THEN
         DO WHILE(BASE_OF_CHAIN^=NULL());/* THERE ARE DEVCE TABLE
                                       ALTERATION ENTRIES, SO STEP
                                       DOWN CHAIN OF THEM, APPLYING
                                       THEM AS WE GO */
            ALTPTR=BASE_OF_CHAIN;      /* SET POINTER TO CURRENT
                                       DEVICE TO THE BASE OF THE CHAIN
                                       OF POINTERS TO ALTERATION
                                       INFORMATION */
            BASE_OF_CHAIN=NEXT_BLOCK;  /* SET BASE OF CHAIN OF DEVICE
                                       POINTERS TO THE NEXT ONE IN THE
                                       CHAIN */
            BOT_RANGE=BOTTOM_OF_RANGE; /* EXTRACT VALUES - BOTTOM OF
                                       ADDRESS RANGE OF INFORMATION TO
                                       BE ALTERED */
            TOP_RANGE=TOP_OF_RANGE;    /* TOP OF ADDRESS RANGE OF
                                       INFORMATION TO BE ALTERED */
            TEMP_DEVICE_TYPE=DEVICE_TYPE;/* DEVICE TYPE */
            DO DEV_LOOP = BOT_RANGE TO TOP_RANGE;
               DEVICE_INFO(DEV_LOOP)=TEMP_DEVICE_TYPE;/* PUT DEVICE
                                       TYPE INFORMATION INTO ADDRESSES
                                       IN SPECIFIED RANGE */
            END;
            IF ALIAS_START >= 0 THEN
               DO;                     /* THESE DEVICES HAVE ALTERNATE
                                       PATHS TO THEM */
                  BOT_RANGE=ALIAS_START*16 +
                  MOD(BOTTOM_OF_RANGE,16);/* BOTTOM OF RANGE OF
                                       ALTERNATE PATH ADDRESSES IS THE
                                       FIRST TWO HEX DIGITS OF THE
                                       VALUE SPECIFIED IN THE PARM AND
                                       STORED IN ALIAS_START
                                       MULTIPLIED BY 16 PLUS THE VALUE
                                       OF THE FINAL HEX DITIT OF THE
                                       MAIN PATH ADDRESS */
                  TOP_RANGE=BOT_RANGE + (
                   TOP_OF_RANGE-BOTTOM_OF_RANGE);/* TOP OF RANGE OF
                                       ALTERNATE PATH ADDRESSES IS THE
                                       BOTTOM OF THE RANGE PLUS THE
                                       NUMBER OF ADDRESSES IN THE MAIN
                                       PATH RANGE */
                  IF TOP_RANGE > 4095 THEN
                     DO;               /* ERROR - THE TOP OF THE
                                       ALTERNATE PATH RANGE IS OUTSIDE
                                       THE RANGE OF VALID DEVICE
                                       ADDRESSES */
                        TOP_RANGE=4095;/* CORRECTION IS TO SET THE
                                       VALUE TO THE MAXIMUM VALID
                                       DEVICE ADDRESS */
                     END;
                  ALTADDR=-BOTTOM_OF_RANGE;/* VALUE TO BE INSERTED IS
                                       THE NEGATIVE OF THE MAIN PATH
                                       ADDRESS. FIRST VALUE IS THE
                                       NEGATIVE OF THE ADDRESS OF THE
                                       BOTTOM OF THE MAIN PATH RANGE */
                  DO DEV_LOOP = BOT_RANGE TO TOP_RANGE;
                     DEVICE_INFO(DEV_LOOP)=ALTADDR;/* INSERT VALUE FOR
                                       THIS ADDRESS */
                     ALTADDR=ALTADDR-1;/* STEP DOWN ADDRESS TO BE
                                       INSERTED */
                  END;
               END;
            FREE ALTERATION_INFO;      /* FREE THIS BLOCK OF DEVICE
                                       TABLE ALTERATION INFORMATION */
         END;                          /* OF DEVICE TABLE INFORMATION
                                       ALTERATION */
 %SKIP(4);
      INFO_PTR=DEV_PTR;                /* PARAMETER TO RETURN ADDRESS
                                       OF DEVICE TABLE */
      RETURN;                          /* TO EXTERNAL CALLING
                                       PROCEDURE */
 %PAGE;
 SLENGTH:
   PROC(UNKNOWN_STRING) RETURNS(FIXED BIN(15)) REORDER;
 %SKIP(4);
 /********************************************************************/
 /*   SLENGTH RETURNS THE 'REAL' LENGTH OF A FIXED LENGTH CHARACTER  */
 /*   STRING IE THE POSITION OF THE LAST NON-BLANK CHARACTER         */
 /********************************************************************/
 %SKIP(4);
 /* PARAMETERS */
 %SKIP;
   DCL
      UNKNOWN_STRING CHAR(*);          /* INPUT STRING */
 %SKIP(4);
 /* LOCAL VARIABLES */
 %SKIP;
   DCL
      LOOP FIXED BIN(15);              /* LOOP CONTROL VARIABLE */
 %SKIP(4);
 /* BUILT IN FUNCTIONS */
 %SKIP;
   DCL
      (LENGTH,
      SUBSTR) BUILTIN;
 %SKIP(4);
      DO LOOP = LENGTH(UNKNOWN_STRING) TO 1 BY -1
      WHILE(SUBSTR(UNKNOWN_STRING,LOOP,1)=' ');
      END;
      RETURN(LOOP);
   END;                                /* OF SLENGTH */
 %PAGE;
 NEXT_SYMBOL: /*GET NEXT SYMBOL*/
   PROC RETURNS(CHAR(8)) REORDER;
 %SKIP(4);
 /********************************************************************/
 /*  NEXT_SYMBOL RETURNS THE NEXT KEYWORD OR PUNCTUATION SYMBOL -    */
 /*  (), - BLANKS ARE USED TO DELIMIT KEYWORDS BUT ARE NOT RETURNED  */
 /*  AS SYMBOLS.                                                     */
 /********************************************************************/
 %SKIP(4);
 /*LOCAL VARIABLES*/
 %SKIP;
   DCL
      TEMPN BIN(15),
      KEYWORD CHAR(8);
 %SKIP(4);
      IF START_POS > END_POS THEN
         RETURN('        ');           /* IF WE'VE PASSED THE END OF
                                       THE STRING THEN RETURN A BLANK */
      TEMPN=
      INDEX(SUBSTR(TRANSLATED_STRING,START_POS,END_POS-START_POS+1),' ')

      ;                                /* FIND THE NEXT DELIMITER OR
                                       BLANK BY LOOKING FOR THE NEXT
                                       BLANK IN THE STRING WITH ALL
                                       DELIMITERS CONVERTED TO BLANKS */
      IF TEMPN=0 THEN
         DO;                           /* NO MORE BLANKS IN THE STRING
                                       */
            KEYWORD=
            SUBSTR(IN_STRING,START_POS, MIN(8,END_POS-START_POS+1));/*
                                       RETURN THE FIRST EIGHT
                                       CHARACTERS OF THE REST OF THE
                                       STRING AS THE NEXT KEYWORD, OR
                                       SHORTER IF THERE IS NOT ENOUGH
                                       STRING LEFT */
            START_POS=END_POS+1;       /* SET THE STARTING POSITION
                                       FOR THE NEXT SEARCH PAST THE
                                       END OF THE STRING TO INDICATE
                                       THAT THE STRING IS EXHAUSTED */
         END;
      ELSE
         DO;                           /* THERE IS A BLANK OR A
                                       DELIMITER IN THE STRING */
            IF TEMPN=1 THEN
               DO;                     /* NEXT CHARACTER FOUND IS A
                                       DELIMITER. IT CANNOT BE A BLANK
                                       AS BLANKS ARE DISCARDED
                                       IMMEDIATELY AFTER THEY ARE
                                       FOUND BY USING THE PROCEDURE
                                       SKIP_BLANKS */
                  KEYWORD=SUBSTR(IN_STRING,START_POS,1);/* RETURN IT
                                       AS THE NEXT KEYWORD */
                  START_POS=START_POS+1;/* PUSH CURRENT CHARACTER
                                       INDEX PAST IT */
               END;
            ELSE
               DO;                     /* KEYWORD IS A SYMBOL - IE NOT
                                       A DELIMITER */
                  KEYWORD=
                  SUBSTR(IN_STRING,START_POS,MIN(8,TEMPN-1));/* RETURN
                                       UP TO EIGHT CHARACTERS OF THE
                                       KEYWORD BUT TO NOT RETURN THE
                                       DELIMITER AT THE END OF IT */
                  START_POS=TEMPN-1+START_POS;/* SET INDEX IN STRING
                                       TO THE DELIMITER */
               END;
            CALL SKIP_BLANKS;          /* SKIP OVER ALL THOSE NASY
                                       BLANKS - IF THE DELIMITER OF
                                       THE SYMBOL WAS A BLANK THEN THE
                                       INDEX IN THE STRING (START_POS)
                                       WILL BE INCREMENTED PAST AS
                                       MANY BLANKS AS THERE ARE. IF
                                       THE DELIMITER WAS A NON-BLANK
                                       SYMBOL '(),' THEN THE INDEX IN
                                       THE STRING WILL REMAIN POINTING
                                       TO IT SO THAT IT WILL BE
                                       RETURNED NEXT TIME NEXT_SYMBOL
                                       IS CALLED */
         END;
      RETURN(KEYWORD);
   END;                                /*OF NEXT_SYMBOL */
 %PAGE;
 SKIP_BLANKS: /*SKIP OVER BLANKS*/
   PROC REORDER;
 %SKIP(4);
 /********************************************************************/
 /*  SKIP_BLANKS ADVANCES START_POS TO THE NEXT NON-BLANK CHARACTER  */
 /*  IN IN_STRING OR TO END_POS+1 IF THE REMAINDER OF THE STRING     */
 /*  CONSISTS OF BLANKS.                                             */
 /********************************************************************/
 %SKIP(4);
 /*LOCAL VARIABLE*/
   DCL
      SKIPTEMP BIN(15);                /*BINARY TEMPORARY*/
 %SKIP(4);
      DO SKIPTEMP = START_POS TO END_POS
      UNTIL(SUBSTR(IN_STRING,SKIPTEMP,1)^=' ');/* SEARCH FOR NEXT
                                       NON-BLANK CHARACTER */
      END;
      START_POS=SKIPTEMP;
      RETURN;
   END;                                /*OF SKIP_BLANKS*/
 %PAGE;
 COMPDEC: /* CONVERTS EBCDIC NUMBER INTO BINARY */
   PROC(DCHARS,DLENGTH) RETURNS(FIXED BINARY(15)) REDUCIBLE
   OPTIONS(REENTRANT) REORDER;
 %SKIP(4);
 /********************************************************************/
 /*  COMPDEC TAKES A CHARACTER STRING OF A NATURAL NUMBER AND        */
 /*  CONVERTS IT INTO BINARY.                                        */
 /********************************************************************/
 %SKIP(4);
 /* PARAMETERS */
 %SKIP;
   DCL
      DCHARS CHAR(8),                  /* INPUT CHARACTER STRING */
      DLENGTH BIN(15);                 /* NUMBER OF CHARACTERS TO BE
                                       USED IN STRING */
 %SKIP(4);
 /* CONSTANTS */
 %SKIP;
   DCL
      CHARSDEC CHAR(10) STATIC INTERNAL INIT('0123456789');/* LOOK UP
                                       TABLE FOR GETTING BINARY VALUES
                                       OF CHARACTERS */
 %SKIP(4);
 /* LOCAL VARIABLES */
 %SKIP;
   DCL
      CMPDLOOP BIN(15),                /* LOOP COUNTER */
      TEMPINDEX FIXED BIN(15),         /* TEMPORARY FOR TESTING INDEX
                                       VALUE TO SEE IF IT IS VALID */
      RETBIN BIN(31);                  /* VALUE RETURNED BY ROUTINE */
 %SKIP(4);
      RETBIN=0;
      DO CMPDLOOP = 1 TO DLENGTH;
         TEMPINDEX=INDEX(CHARSDEC,SUBSTR(DCHARS,CMPDLOOP,1)) ;
         IF TEMPINDEX = 0 THEN
            RETURN(-1);                /* INVALID CHARACTER */
         RETBIN=RETBIN*10+TEMPINDEX-1;
      END;
      RETURN(RETBIN);
   END;                                /* OF COMPDEC */
 %PAGE;
 COMPHEX: /*CONVERTS CHARACTER FORM OF A HEX # TO BINARY*/
   PROC(HCHARS,HLENGTH) RETURNS(FIXED BIN(31)) REDUCIBLE REORDER;
 %SKIP(4);
 /**************************************************************/
 /*  COMPHEX TAKES A CHARACTER STRING VALUE OF A HEX           */
 /*  NUMBER AND RETURNS THE BINARY VALUE.                      */
 /**************************************************************/
 %SKIP(4);
 /*PARAMETERS*/
 %SKIP;
   DCL
      HCHARS CHAR(8),                  /* STRING TO BE CONVERTED */
      HLENGTH BIN(15);                 /* NUMBER OF CHARACTERS TO BE
                                       USED */
 %SKIP(4);
 /*CONSTANTS*/
 %SKIP;
   DCL
      CHARSHEX CHAR(16) STATIC INTERNAL INITIAL('0123456789ABCDEF');/*
                                       LOOK UP TABLE OF VALID
                                       HEXADECIMAL DIGITS */
 %SKIP(4);
 /*LOCAL VARIABLES*/
 %SKIP;
   DCL
      CMPHLOOP FIXED BIN(15),          /* LOOP COUNTER ALONG
                                       CHARACTERS IN STRING */
      TEMPINDEX FIXED BIN(15),         /* TEMPORARY FOR VALUE OF
                                       CURRENT DIGIT */
      BINHRET FIXED BIN(31);           /* ACCUMULATOR OF VALUE TO BE
                                       RETURNED */
 %SKIP(4);
      BINHRET=0;
      DO CMPHLOOP = 1 TO HLENGTH;
         TEMPINDEX=INDEX(CHARSHEX,SUBSTR(HCHARS,CMPHLOOP,1));
         IF TEMPINDEX=0 THEN
            RETURN(-1);                /* INVALID CHARACTER */
         BINHRET=BINHRET*16+TEMPINDEX-1;/* CONVERT EBCDIC VALUE INTO
                                       HEX & ADD TO RETURNED VALUE */
      END;
      RETURN(BINHRET);
   END;                                /* OF COMPHEX */
 %PAGE;
 VALID: /*VALIDATE KEYWORDS*/
   PROC(VSYMBOL,VLENGTH,VALALT) RETURNS(BIN(15) FIXED) REORDER;
 %SKIP(4);
 /**************************************************************/
 /*  VALID TAKES A KEYWORD AND TESTS TO SEE WHETHER IT OCCURS  */
 /*  IN A GIVEN LIST.  IF IT DOES OCCUR, VALID RETURNS WHICH   */
 /*  GROUP THE KEYWORD BELONGS TO AND WHICH MEMBER OF THE      */
 /*  GROUP IT IS.                                              */
 /**************************************************************/
 %SKIP(4);
 /*PARAMETERS*/
 %SKIP;
   DCL
      VSYMBOL CHAR(8),                 /* SYMBOL TO BE IDENTIFIED */
      VLENGTH FIXED BINARY(15),        /* EFFECTIVE LENGTH OF SYMBOL -
                                       IE INDEX OF LAST NON-BLANK
                                       CHARACTER IN THE SYMBOL */
      VALALT FIXED BINARY(15);         /* INDEX OF KEYWORD IN GROUP -
                                       IE IF THE KEYWORD IS A VALID
                                       CENTRE KEYWORD, THEN VALID
                                       RETURNS 1 TO INDICATE THAT THE
                                       KEYWORD IS A CENTRE KEYWORD AND
                                       SETS VALALT TO 1 IF THE KEYWORD
                                       IS 'GOODMANS' OR 2 IF THE
                                       KEYWORD IS 'KEGWORTH' */
 %SKIP(4);
 /*CONSTANTS*/
 %SKIP;
   DCL
      VALID_SYMBOLS(5) CHAR(8) STATIC INTERNAL INIT('GOODMANS',
   'KEGWORTH','ROWS    ', 'MAXIMUM ','NODIAG  ');/* LIST OF ALL THE
                                       VALID KEYWORDS */
   DCL
      GROUPALTERNS(5,2) STATIC FIXED BIN(15) INIT(1,1,1,2,2,1,2,2,2,3) ;
                                       /* LIST OF KEYWORD GROUPS AND
                                       ALTERNATE VALUES WITHIN EACH
                                       GROUP FOR EACH KEYWORD. FOR THE
                                       KEYWORD APPEARING AS
                                       VALID-SYMBOLS(I),
                                       GROUPALTERNS(I,1) IS THE GROUP
                                       NUMBER AND GROUPALTERNS(I,2) IS
                                       THE KEYWORD NUMBER VALUE WITHIN
                                       THAT GROUP */
 %SKIP(4);
 /*LOCAL VARIABLES*/
 %SKIP;
   DCL
      TEMPSYMBOL CHAR(8),              /* TEMPORARY TO HOLD TRUNCATED
                                       SYMBOL */
      LOOP BIN(15);                    /* LOOP COUNTER */
      TEMPSYMBOL=SUBSTR(VSYMBOL,1,VLENGTH);/* TEMPSYMBOL HOLDS VSYMBOL
                                       TRUNCATED TO LENGTH THAT HAS TO
                                       BE COMPARED */
      DO LOOP = 1 TO 5;                /* SEARCH KEYWORD LIST */
         IF SUBSTR(TEMPSYMBOL,1,VLENGTH) =
         SUBSTR(VALID_SYMBOLS(LOOP),1,VLENGTH) THEN
            DO;                        /* PROVIDED THE SUBSTRINGS
                                       MATCH - IE ANY ABBREVIATION IS
                                       PERMISSIBLE PROVIDED THAT THE
                                       CHARACTERS MATCH ALL THE WAY
                                       ALONG - THEN THE KEYWORD HAS
                                       BEEN FOUND */
               VALALT=GROUPALTERNS(LOOP,2);/*WHICH KEYWORD IN THE
                                       GROUP ARE WE? */
               RETURN(GROUPALTERNS(LOOP,1));/* RETURN THE GROUP NUMBER
                                       */
            END;
      END;
      ;                                /* OH DEAR - IF WE DROP OUT OF
                                       THE BOTTOM, WE HAVEN'T FOUND A
                                       VALID KEYWORD. RETURN 0'S TO
                                       INDICATE AN ERROR */
      VALALT=0;
      RETURN(0);
   END;                                /* OF VALID */
   END;                                /* OF XXPARSM */
