*              /* LEVEL=0002                                         */
*PROCESS X,A,AG,S,STG,LIST,NEST,F(I),LMSG,MAP,ESD,OPT(2),OF;
 ANALYSE: /* CHANNEL  ACTIVITY  ANALYSIS  PROGRAM */
   PROC(MASKS) OPTIONS(MAIN,REENTRANT) REORDER;
 %SKIP(4);
 /********************************************************************/
 /*   ANALYSE: NWB CHANNEL ACTIVITY ANALYSIS PROGRAM                 */
 /*                                                                  */
 /*   ANALYSE IS A PROGRAM WHICH WILL TAKE SMF RECORDS TYPE 73       */
 /*   AND PROCESS THEM TO PRODUCE A REPORT ON CHANNEL ACTIVITY       */
 /*   AS GRAPHS DRAWN AGAINST TIME FOR THE MEASUREMENT PERIOD        */
 /*   WITH OPTIONAL SUMMARIES AT THE END OF CHANNEL BUSY AGAINST     */
 /*   START IO RATES AND A HISTOGRAM FOR EACH CHANNEL OF CHANNEL     */
 /*   BUSY AGAINST TIME.                                             */
 /********************************************************************/
 /*   LEVL(0002) 13 JULY 1979.  CHANGES:                             */
 /*   CONVERSION OF RECORD COUNTERS TO BIN(31) INSTEAD OF BIN(15)    */
 /*   TO PREVENT OVERFLOW.                                           */
 /********************************************************************/
 /*   LEVL(0001) 12 MARCH 1979.  CHANGES:                            */
 /*   RECOMMENTED THROUGHOUT.  XXEXPCM CHANGED TO AN EXTERNAL        */
 /*   PROCEDURE INSTEAD OF AN INTERNAL ONE.  CORRECTION OF           */
 /*   MINOR ERRORS AND REGROUPING OF DECLARATION OF VARIABLES        */
 /********************************************************************/
 /* WRITTEN BY    JOHN H LISTER,                                     */
 /*               TECHNICAL SERVICES GROUP,                          */
 /*               DATA PROCESSING DEPARTMENT,                        */
 /*               NATIONAL WESTMINSTER BANK,                         */
 /*               GOODMANS FIELDS COMPUTER CENTRE,                   */
 /*               74 ALIE STREET, LONDON   E1 8HL.                   */
 /*                                                                  */
 /*               TELEPHONE: 01-488 0707 EXT 2766.                   */
 /********************************************************************/
 %SKIP(4);
   DEFAULT
      RANGE(*) FIXED;                  /* DON'T WANT FLOATS */
 %SKIP(2);
 /* EXECUTION TIME OPTIONS */
   DCL
      PLIXOPT CHAR(100) VARYING EXTERNAL INITIAL('NR,ISASIZE(120K)');
 %SKIP(2);
 /* PARAMETERS */
   DCL
      MASKS CHAR(100) VARYING;         /* EXEC PARM STRING - VALID
                                       OPTIONS ARE THE HEX NUMBERS
                                       0-F, P AND H. IF NONE OF 0-F IS
                                       SPECIFIED, THEN THE TWO GRAPHS
                                       ARE FOR ALL CHANNELS - THE ONE
                                       ON THE LEFT BEING THE GRAPH OF
                                       CHANNEL BUSY SAMPLES, THE ONE
                                       ON THE RIGHT BEING THE GRAPH OF
                                       CHANNEL BUSY AND CPU WAIT
                                       SAMPLES. IF ANY ONE OR MORE OF
                                       0-F ARE SPECIFIED, THEN THE TWO
                                       GRAPHS ARE BOTH OF CHANNEL
                                       BUSY, WITH THE ONE ON THE RIGHT
                                       HAVING THOSE CHANNEL(S)
                                       SPECIFIED IN THE PARM STRING IN
                                       ITS DISPLAY, THE ONE ON THE
                                       LEFT HAVING ALL THE REST. USING
                                       THIS, IT IS POSSIBLE TO GRAPH
                                       TWO SETS OF CHANNELS AGAINST
                                       EACH OTHER, SAY FOR COMPARING
                                       THE USAGE OF ALTERNATE PATHS.
                                       THE OTHER TWO PARAMETERS P AND
                                       H, OPERATE COMPLETELY
                                       INDEPENDENTLY OF 0-F. THESE
                                       SPECIFY THAT THE PLOT AND
                                       HISTOGRAM OPTIONS RESPECTIVELY
                                       ARE TO BE TURNED ON. FOR
                                       FURTHER DETAILS, SEE THE
                                       DOCUMENTATION */
 %SKIP(2);
 /* CONSTANTS */
   DCL
      CHANSET CHAR(16) STATIC INTERNAL INITIAL('0123456789ABCDEF'),
      CHANCAR(0:15) CHAR(1) DEFINED CHANSET;/*EXTERNAL FORM OF CHANNEL
                                       NUMBERS IN HEX. CAN BE
                                       ADDRESSED TWO WAYS: AS AN ARRAY
                                       OF SINGLE CHARACTERS TO BE USED
                                       WHEN PRINTING CHANNEL NUMBERS
                                       IN A GRAPH, OR AS A SINGLE
                                       BLOCK OF 16 CHARACTERS USED AS
                                       AN ARGUMENT TO THE INDEX
                                       FUNCTION IN PARM PROCESSING */
   DCL
      MONCHARS(12) STATIC CHAR(3) INIT( 'JAN','FEB','MAR','APR','MAY',
   'JUN', 'JUL','AUG', 'SEP','OCT','NOV','DEC');/* CHARACTER FORM OF
                                       EACH MONTH */
 %SKIP(2);
 /* FILES */
   DCL
      INFILE FILE RECORD INPUT BUFFERED, /* INPUT FILE FOR SMF RECORDS
                                       */
      PRINT FILE OUTPUT STREAM PRINT;  /* OUTPUT FILE FOR RESULTS */
 %SKIP(2);
 /* LOCAL VARIABLES */
   DCL
      (LOOP2,
      LOOP3,
      LOOP4,
      LOOP5) FIXED BINARY(15);         /* LOOP COUNTERS */
   DCL
      (LOOP,                           /* COUNTER OF TOTAL NUMBER OF
                                       RECORDS PROCESSED. */
      #DISCARDED) FIXED BIN(31) INIT(0);/* COUNTER OF RECORDS IGNORED
                                       AS NOT BEING SMF TYPE 73. */
   DCL
      MONTHS(12) BIN(15) INITIAL(31, 28, 31, 30, 31, 30, 31, 31, 30, 31,
       30, 31);                        /* NUMBER OF DAYS IN EACH MONTH
                                       FOR CONVERTING DATE FROM IBM
                                       FORM INTO DD MMM YY */
   DCL
      PAGENO FIXED DEC(3) INITIAL(1),  /* PAGE COUNTER */
      SAMPLENOS FIXED BINARY(31),      /* TEMPORARY TO HOLD NUMBER OF
                                       SAMPLES TAKEN DURING
                                       MEASUREMENT INTERVAL COVERED BY
                                       CURRENT RECORD */
      ERRORPOS FIXED BIN(15),          /* HOLDS NEXT AVAILABLE
                                       POSITION AT RIGHT HAND SIDE OF
                                       PAGE FOR PRINTING IDS OF
                                       CHANNELS WHERE THERE HAVE BEEN
                                       ERRORS */
      (PRCNT1,
      PRCNT2) FIXED BINARY(15),        /* TEMPORARIES HOLDING
                                       PERCENTAGES BUSY FOR MAIN
                                       GRAPHS */
      CHANNUM FIXED BINARY(15),        /* USED AS INDEX TO CURRENT
                                       CHANNEL BEING PROCESSED */
      LEN1 FIXED BINARY(15),           /* TEMPORARY HOLDING LENGTH OF
                                       EXEC INPUT PARM */
      CHANNOS FIXED BINARY(15);        /* REFER OBJECT FOR INREC */
   DCL
      DOPRINT(0:15) BIT(1) ALIGNED INIT((16)('0'B)), /* IF A SELECTIVE
                                       CHANNEL PRINT IS REQUESTED,
                                       DOPRINT CONTAINS THE FLAGS TO
                                       INDICATE WHICH OF THEM ARE TO
                                       BE PRINTED ON RIGHT HAND SIDE
                                       OF PAGE */
      BLOCK(0:15) BIT(1) ALIGNED INIT((16)('0'B)), /* FLAGS - '1'B
                                       INDICATES A BLOCK MULTIPLEXOR
                                       CHANNEL */
      PRESENT(0:15) BIT(1) ALIGNED INIT((16)( '0'B )), /* FLAGS - '1'B
                                       INDICATES THAT THE CHANNEL
                                       EXISTS */
      BYTES(0:15) BIT(1) ALIGNED INIT((16)('0'B)),/* FLAGS - '1'B
                                       INDICATES THAT THE CHANNEL IS A
                                       BYTE MULTIPLEXOR CHANNEL */
      ERRCHN(0:15) BIT(1) INITIAL((16)('0'B)), /* FLAGS - '1'B
                                       INDICATES THAT THERE HAS BEEN
                                       AN ERROR ON THE CHANNEL IN
                                       QUESTION */
      (DOINLOOP,                       /* FLAG - WHEN ON, EITHER OR
                                       BOTH OF HISTOGRAM PRINTING OR
                                       PLOTTING HAS BEEN REQUESTED, SO
                                       COLLECTION OF DATA FOR THEM HAS
                                       TO BE PERFORMED */
      DOPLOT) BIT(1) ALIGNED INIT('0'B),/* FLAG - WHEN ON, PLOTTING
                                       HAS BEEN REQUESTED */
      (DOHIST,                         /* FLAG - WHEN ON, HISTOGRAM
                                       PRINTING HAS BEEN REQUESTED */
      FIRSTLOOP) BIT(1) ALIGNED INIT('0'B),/* FLAG - WHEN ON,
                                       HISTOGRAM PRINTING AND/OR
                                       PLOTTING HAS BEEN REQUESTED AND
                                       THIS IS THE FIRST TIME THROUGH
                                       THE MAIN LOOP, SO CALL
                                       SETPLOTUP TO ALLOCATE A COPY OF
                                       GRID FOR EACH BLOCK MULTIPLEXOR
                                       CHANNEL */
      ERRORS BIT(1);                   /* FLAG - WHEN ON, THERE HAVE
                                       BEEN MONITORING ERRORS FOR AT
                                       LEAST ONE CHANNEL ON THE PAGE,
                                       SO PUT OUT ERROR MESSAGE AT THE
                                       BOTTOM OF THE PAGE */
   DCL
      FILEPTR POINTER,                 /*POINTER TO CURRENT RECORD*/
      INDIC1 BIT(8) ALIGNED,           /*TEMPORARY FOR CHANNEL FLAGS*/
      TIMEPIC PIC'99.99.99';           /*TIME EDIT*/
   DCL
      BINDATE FIXED BIN(31),
      BINYEAR FIXED BIN(31),
      BINDAYS FIXED BIN(15);           /* TEMPORARIES USED IN
                                       CONVERTING IBM DATE TO DD MMM
                                       YY */
   DCL
      PRINTLINE CHAR(132);             /* PRINT BUFFER */
   DCL
      (SLCT1,                          /* USED AS AN INDEX TO HEAD4TO
                                       CONTROL WHICH OF THE TWO
                                       POSSIBLE HEADINGS IS PRINTED ON
                                       THE RIGHT HAND SIDE OF THE
                                       PAGE, AND ALSO USED AS A FLAG
                                       TO DETERMINE WHETHER OR NOT
                                       CHANNEL SELECTION FOR PRINTING
                                       ON RHS OF PAGE IS IN EFFECT */
      TEMP1) FIXED BIN(15) INITIAL(0); /* TEMPORARY */
   DCL
      TOTSAMPS FIXED BINARY(31) INIT(0), /* ACCUMULATOR OF TOTAL
                                       NUMBER OF SAMPLES MADE FOR THE
                                       RECORDS PRINTED ON CURRENT PAGE
                                       */
      BURSTSAMPS(0:15) FIXED BIN(31) INIT((15)0), /* TOTAL BUSY
                                       SAMPLES FOR EACH CHANNEL FOR
                                       THE RECORDS PRINTED ON CURRENT
                                       PAGE */
      WAITSAMPS(0:15) FIXED BIN(31) INIT((15)0), /* TOTAL BUSY AND CPU
                                       WAIT SAMPLES FOR EACH CHANNEL
                                       THIS PAGE */
      SIOSARY(0:15) FIXED BIN(31) INIT((15)0);/* ACCUMULATOR OF TOTAL
                                       NUMBER OF START IOS FOR EACH
                                       CHANNEL FROM THE RECORDS
                                       PRINTED ON THIS PAGE */
   DCL
      FIRSTIME DEC(7) INIT(0);         /*TIME OF FIRST ENTRY ON PAGE*/
   DCL
      LASTIME DEC(7) INIT(0);          /*TIME OF LAST ENTRY ON PAGE*/
   DCL
      HEAD1 CHAR(132) INIT( (
   'C H A N N E L   A C T I V I T Y   A N A L Y S I S'××
   '     DATE DD MMM YY  CPUID XXXX  OSID XXXX   '××
   '                             PAGE     ')), /* TOP HEADING ON EACH
                                       PAGE */
      HEAD2 CHAR(132) INIT( (
   '================================================='××
   '          (YY.DDD)   SYSID XXXX  MF/1   XX   '××
   '                         VERSION 5.1.0')), /* SECOND LINE OF
                                       HEADING ON EACH PAGE */
      1 HEAD1DATE DEF HEAD1 POS(60),   /* FIELDS DEFINED ON HEAD1 AND
                                       HEAD2 - THIS ONE DATE IN DD MMM
                                       YY FORM */
         2 HEAD1DTDAY PIC'Z9',         /* DAY OF THE MONTH */
         2 HEAD1DTPAD CHAR(1),         /* PADDING */
         2 HEAD1DTMON CHAR(3),         /* MONTH */
         2 HEAD1DTPAD2 CHAR(1),        /* PADDING */
         2 HEAD1DTYER PIC'99',         /* YEAR */
      HEAD1CPUID PIC'9999' DEF HEAD1 POS(77), /* CPU IDENTIFICATION -
                                       0 OR 1 IF IT IS IN A
                                       MULTIPROCESSING CONFIGURATION */
      HEAD1OSID CHAR(4) DEF HEAD1 POS(88), /* OPERATING SYSTEM VERSION
                                       NUMBER */
      HEAD1START CHAR(10) DEF HEAD1 POS(97), /* PLACE FOR CHARACTERS
                                       'START TIME' FOR
                                       PLOTTING/HISTOGRAM PAGES */
      HEAD1TIME PIC'99.99.99' DEF HEAD1 POS(108), /* PLACE FOR
                                       MEASUREMENT START TIME ON
                                       PLOTTING/HISTOGRAM PAGES */
      HEAD1PAGE PIC'ZZZ9' DEF HEAD1 POS(129), /* INSERT FOR PAGE
                                       NUMBER */
      HEAD2DATE PIC'99.999' DEF HEAD2 POS(61), /* DATE OF MEASUREMENT
                                       IN IBM (YY.DDD) FORM */
      HEAD2SYSID CHAR(4) DEF HEAD2 POS(77), /* SYSTEM IDENTIFICATION
                                       FIELD */
      HEAD2MF1 CHAR(2) DEF HEAD2 POS(90), /* MF/1 VERSION NUMBER FIELD
                                       */
      HEAD2END CHAR(10) DEF HEAD2 POS(97), /* SPACE FOR CHARACTERS
                                       'END TIME' ON
                                       PLOTTING/HISTOGRAM PAGES */
      HEAD2TIME PIC'99.99.99' DEF HEAD2 POS(108);/*SPACE FOR END TIME
                                       ON PLOTTING/HISTOGRAM PAGES */
   DCL
      SIDECHAR(6) CHAR(10) INIT('','END TIME',(2) (''), 'INTERVAL',''),
 /* VALUES PRINTED DOWN THE LHS OF THE SUMMARY PRINT AT THE BOTTOM OF
 EACH PAGE */
      ENDEDIT PIC '99.99.99' DEFINED SIDECHAR(3) POS(3), /* EDIT FIELD
                                       FOR TIME OF LAST RECORD ON PAGE
                                       IN SIDECHAR */
      DIFFEDIT PIC 'ZZZ9.99' DEFINED SIDECHAR(6) POS(3);/* EDIT FIELD
                                       FOR DIFFERENCE BETWEEN START
                                       TIME AND END TIME IN MMM.SS IN
                                       SIDECHAR */
   DCL
      STARTEDIT PIC '99.99.99',        /* USED TO EDIT TIME OF FIRST
                                       RECORD ON PAGE FOR PRINTING AT
                                       THE BOTTOM */
      (START_OF_JOB,                   /* SAVE OF TIME OF FIRST RECORD
                                       IN FILE */
      STARTSECS,                       /* USED TO HOLD TIME OF FIRST
                                       RECORD ON PAGE CONVERTED TO
                                       SECONDS SINCE MIDNIGHT */
      ENDSECS,                         /* USED TO HOLD TIME OF LAST
                                       RECORD ON PAGE CONVERTED INTO
                                       SECONDS SINCE MIDNIGHT */
      INTERVAL) DEC(7) INIT(0),        /* USED TO HOLD INTERVAL
                                       BETWEEN FIRST RECORD ON PAGE
                                       AND LAST RECORD ON PAGE BEFORE
                                       EDITING */
      BINTERVAL BINARY(31) INIT(0);    /* HOLDS INTERVAL CONVERTED
                                       INTO BINARY FOR WORKING OUT
                                       START IO RATES IN SUMMARIES AT
                                       THE BOTTOM OF EACH PAGE */
   DCL
      PTR1 POINTER,                    /* THESE DECLARES FOOL THE
                                       COMPILER OUT OF CALLING A
                                       LIBRARY ROUTINE TO CONVERT THE
                                       CHANNEL NUMBER (PRESENTED IN
                                       THE INPUT RECORD AS A BIT(8)
                                       STRING) INTO BIN(15), AND WILL
                                       ENSURE THAT THE RESULT IS
                                       ALWAYS POSITIVE */
      DUMBIN FIXED BIN(15) BASED(PTR1),
      DUMBITS(2) BIT(8) ALIGNED BASED(PTR1);
 %SKIP(2);
 /* BUILT IN FUNCTIONS */
   DCL
      (DIVIDE,
      MIN,
      DEC,
      SUM,
      LENGTH,
      INDEX,
      MOD,
      PLIDUMP,
      ROUND,
      STRING,
      SUBSTR) BUILTIN;
   DCL
      GRIDPTR POINTER,                 /* POINTER USED TO ADDRESS GRID
                                       DATA */
      INDIRECT(0:15) POINTER,          /* ARRAY OF POINTERS TO THE
                                       GRID DATA FOR THE BLOCK
                                       MULTIPLEXOR CHANNELS -
                                       INDIRECT(I) POINTS TO THE DATA
                                       FOR THE ITH CHANNEL */
      SIOSSEC FIXED BIN(15) INIT(0),   /* TEMPORARY TO HOLD NUMBER OF
                                       START IOS PER SECOND FOR
                                       UPDATING GRID */
      DURATION BIN(31) INIT(0);        /* USED TO HOLD INTERVAL
                                       BETWEEN INPUT RECORDS FOR
                                       WORKING OUT START IO RATE */
 %SKIP(2);
 /* BASED VARIABLE TEMPLATES */
   DCL
      1 INREC UNALIGNED BASED(FILEPTR),
         2 RECHEAD,
            3 SYSINDIC BIT(8) ALIGNED, /*SYSTEM INDICATOR*/
            3 RCRDTYPE BIT(8) ALIGNED, /*RECORD TYPE (73)*/
            3 BUFTIME FIXED BIN(31),   /*TIME RECORD -> BUFFER*/
            3 BUFDATE FIXED DEC(7),    /*DATE RECORD -> BUFFER*/
            3 SYSIDENT CHAR(4),        /*SYSTEM IDENTIFICATION*/
         2 COMMONCTL,                  /*COMMON CONTROL DATA*/
            3 CTLSIZE BIN(15) FIXED,   /*SIZE OF CTL AREA*/
            3 CTLTIME DEC(7) FIXED,    /*TIME OF MSRMENT*/
            3 CTLDATE FIXED DEC(7),    /*DATE OF MSRMENT*/
            3 CTLDUR FIXED DEC(7),     /*DURATION OF MSRMENT*/
            3 CTLSAMP DEC(3) FIXED,    /*SAMPLE CYCLE LENGTH*/
            3 CTLPAD CHAR(2),          /*PADDING*/
            3 NOSAMPLES BIN(31) FIXED, /*NO OF SAMPLES*/
            3 CTLVERNO CHAR(2),        /*MF/1 VERSION NO*/
            3 CTLPAD2 CHAR(2),         /*PADDING*/
            3 CTLOS CHAR(4),           /*OPERATING SYSTEM VERSION*/
         2 CHNCTL,                     /*CHANNEL CONTROL AREA*/
            3 CHNSIZE BIN(15),         /*SIZE OF CHANNEL CONTROL AREA*/
            3 NOCHANS BIN(15) FIXED,   /*NUMBER OF CHANNELS*/
            3 DATSIZE BIN(15) FIXED,   /*SIZE OF DATA AREA*/
            3 PAD3 CHAR(2),
         2 CHNDATA (CHANNOS REFER(NOCHANS)), /*DATA FOR CHANNEL*/
            3 CPUIDENT BIN(15),        /*CPU IDENTIFICATION*/
            3 CHANIDENT BIT(8) ALIGNED,/*CHANNEL IDENTIFICATION*/
            3 INDICS BIT(8) ALIGNED,   /*CHANNEL FLAGS*/
            3 SIOS BIN(31),            /*NO OF START IOS*/
            3 BURST BIN(31),           /*NO OF TIMES IN BURST MODE*/
            3 BUSY BIN(31);            /*NO OF TIMES BUSY CPU WAIT*/
   DCL
      GRID(0:50,0:100) BASED(GRIDPTR) INIT((5151)0) BIN(15);
 /* GRID FOR ACCUMULATING ENTRIES CORRELATING CHANNEL USAGE AGAINST
 NUMBER OF START IOS PER SECOND. */
 %PAGE;
 /* EXEC PARM PROCESSING */
 %SKIP(2);
      LEN1=LENGTH(MASKS);              /* LENGTH OF PARM */
      IF LEN1 > 0 THEN
         DO LOOP2 = 1 TO LEN1;         /* SCAN PARM CHARACTERS ONE BY
                                       ONE */
            CHANNUM=INDEX(CHANSET,SUBSTR(MASKS,LOOP2,1))-1;/* IS IT A
                                       CHANNEL SELECT CHARACTER? */
            IF CHANNUM >= 0 THEN
               DO;                     /* YES IT IS */
                  DOPRINT(CHANNUM)='1'B;/*PRINT THIS CHANNEL ON RIGHT
                                       HAND SIDE OF PAGE */
                  SLCT1=1;             /* SET FLAG TO INDICATE THAT
                                       THERE IS CHANNEL SELECTION
                                       TAKING PLACE */
               END;
            ELSE
               IF SUBSTR(MASKS,LOOP2,1) = 'P' THEN
                  DO;                  /* OTHERWISE IS IT THE PLOT
                                       CONTROL CHARACTER? */
                     DOPLOT='1'B;      /* SET PLOT CONTROL FLAG */
                     FIRSTLOOP='1'B;   /* SET FLAG TO INDICATE THAT
                                       THE HISTOGRAM PRINT/PLOT
                                       COUNTING ARRAY IS TO BE SET UP */
                  END;
               ELSE
                  IF SUBSTR(MASKS,LOOP2,1) = 'H' THEN
                     DO;               /* THE ONLY OTHER THING THAT IT
                                       SHOULD BE IS THE HISTOGRAM
                                       PRINT CONTROL CHARACTER 'H' */
                        DOHIST = '1'B; /* SET HISTOGRAM CONTROL FLAG
                                       ON */
                        FIRSTLOOP='1'B;/* SET CONTROL FLAG TO CAUSE
                                       THE HISTOGRAM/PLOT COUNT ARRAY
                                       IS TO BE SET UP */
                     END;
         END;                          /* OTHERWISE THE CHARACTER IS
                                       INVALID AND IS IGNORED. AN
                                       'ELSE' CLAUSE ON THE LAST IF
                                       GROUP COULD BE USED TO PRINT AN
                                       ERROR MESSAGE IF REQUIRED */
 %SKIP(5);
 /* PRELIMINARY PROCESSING */
 %SKIP;
      OPEN FILE(PRINT) LINESIZE(132) PAGESIZE(48), FILE(INFILE);
      ALLOCATE DUMBIN;                 /* ALLOCATE DUMMY FOR
                                       CONVERTING CHANNEL NUMBERS FROM
                                       BIT(8) TO BIN(15) WITHOUT
                                       CALLING LIBRARY */
      DUMBIN=0;                        /* ZEROISE DUMMY */
 %SKIP(2);
      ON ENDFILE(INFILE)
         GOTO NORUN;                   /* JUST IN CASE WE RUN OUT OF
                                       RECORDS BEFORE WE FIND ANY TYPE
                                       73S */
      ON TRANSMIT(INFILE)
         GOTO NORUN;                   /* JUST IN CASE */
 %SKIP(2);
      DO UNTIL(RCRDTYPE = '01001001'B);/* SKIP RECORDS UNTIL WE FIND A
                                       TYPE 73 */
         READ FILE(INFILE) SET(FILEPTR);
         #DISCARDED=#DISCARDED+1;      /* COUNT OF NUMBER OF RECORDS
                                       DISCARDED */
      END;
      #DISCARDED=#DISCARDED-1;         /* LAST RECORD READ WILL BE
                                       USED SO SUBTRACT 1 TO GET THE
                                       COUNT RIGHT */
 %SKIP;
      HEAD2DATE=CTLDATE;               /* EDIT DATA COLLECTION RUN
                                       DATE INTO SECOND LINE OF PAGE
                                       HEADING */
      BINDATE=CTLDATE;                 /* CONVERT DATE TO BINARY PRIOR
                                       TO CONVERTING TO DD MMM YY */
      LASTIME=CTLTIME;                 /* FIND TIME FIRST MEASUREMENT
                                       STARTED BY SUBTRACTING INTERVAL
                                       BETWEEN RECORDS FROM TIME ON
                                       FIRST RECORD */
      LASTIME=CONVT(LASTIME);          /* CONVERT TO SECONDS SINCE
                                       MIDNIGHT */
      FIRSTIME=CTLDUR/1000;            /* FIRSTIME NOW CONTAINS
                                       MEASUREMENT INTERVAL AS MMSS */
      FIRSTIME=CONVT(FIRSTIME);        /* CONVERT MEASUREMENT INTERVAL
                                       TO SECONDS */
      DURATION=FIRSTIME;               /* SAVE TIME BETWEEN RECORDS
                                       FOR USE LATER IN
                                       HISTOGRAM/PLOTTING ROUTINES */
      LASTIME=LASTIME-FIRSTIME;        /* LASTIME NOW CONTAINS TIME
                                       MEASUREMENT STARTED */
      FIRSTIME=LASTIME/3600;           /* CONVERT IT BACK INTO
                                       HH.MM.SS */
      LASTIME=MOD(LASTIME,3600);
      FIRSTIME=FIRSTIME*100+LASTIME/60;
      LASTIME=MOD(LASTIME,60);
      LASTIME=FIRSTIME*100+LASTIME;    /* NOW CONVERTED BACK INTO
                                       HHMMSS - LEFT IN LASTIME SO
                                       THAT WHEN HEADPAGE IS CALLED
                                       FOR THE FIRST TIME IT WILL PUT
                                       IT INTO FIRSTIME */
      START_OF_JOB=LASTIME;            /* SAVE FOR PLOTTING ROUTINE */
      ;                                /* CONVERSION OF DATE INTO DD
                                       MMM YY */
      BINYEAR=BINDATE/1000;
      IF MOD(BINYEAR,4)=0 THEN
         MONTHS(2)=29;                 /*FEBRUARY IN LEAPYEAR*/
      BINDAYS=BINDATE-(BINYEAR*1000);
      DO LOOP2 = 1 TO 12 WHILE(BINDAYS > MONTHS(LOOP2));
         BINDAYS=BINDAYS-MONTHS(LOOP2);/*STEP ALONG MONTHS*/
      END;
      HEAD1DTDAY=BINDAYS;              /* EDIT IN DAY OF THE MONTH */
      HEAD1DTMON=MONCHARS(LOOP2);      /* MONTH */
      HEAD1DTYER=BINYEAR;              /* YEAR */
      HEAD1CPUID=CPUIDENT(1);          /* EDIT IN CPUID FROM FIRST
                                       CHANNEL */
      HEAD1OSID=CTLOS;                 /* EDIT IN OPERATING SYSTEM
                                       VERSION NUMBER */
      HEAD2MF1=CTLVERNO;               /* EDIT IN MF/1 VERSION NUMBER */
      HEAD2SYSID=SYSIDENT;             /* EDIT IN SYSTEM TYPE (MODEL
                                       NUMBER) */
      CALL HEADPAGE;                   /* HEADING ASSEMBLED - CALL
                                       HEADPAGE TO PUT FIRST HEADING
                                       ON PAGE */
 %SKIP(3);
      ON ENDFILE(INFILE)
         GOTO ENDRUN;                  /* NORMAL END OF FILE
                                       PROCESSING */
 %SKIP(3);
      ON TRANSMIT(INFILE)
         GOTO ENDBAD;                  /* BAD READ ON INFILE
                                       PROCESSING */
 %SKIP(3);
      ON ERROR
         BEGIN;
            CALL PLIDUMP('TFB');       /* OUTPUT PLI CONTROL VARIABLES
                                       */
            CALL PLIDUMP('H');         /* THIS ENTRY IN A NWB SYSTEM
                                       CAUSES AN ABEND ,DUMP TO BE
                                       ISSUED WITH OUTPUT WRITTEN TO
                                       SYSUDUMP OR SYSABEND RATHER
                                       THAN PLIDUMP. THUS TO GET FULL
                                       DEBUGGING INFO IN NWB SYSTEM
                                       TWO CALLS TO PLIDUMP ARE NEEDED
                                       */
         END;
 %SKIP(3);
      ON ENDPAGE(PRINT)
         CALL NEWPAGE;                 /* SET UP ENDPAGE ACTION FOR
                                       PRINT */
 %PAGE;
 /*************************************/
 /*  MAIN PROCESSING LOOP             */
 /*************************************/
 %SKIP(2);
      DO LOOP = #DISCARDED+1 BY 1;     /* LOOP ONCE FOR EACH RECORD
                                       UNTIL END OF FILE, OR TRANSMIT
                                       CONDITIONS */
         IF RCRDTYPE ^= '01001001'B THEN
            DO;                        /* CHECK THAT RECORD IS A SMF
                                       TYPE 73 RECORD. (X'49').
                                       OTHERWISE ADD ONE TO DISCARDED
                                       RECORDS COUNTER AND GO READ
                                       ANOTHER ONE */
               #DISCARDED=#DISCARDED+1;
               GOTO READ_NEXT_RECORD;
            END;
         ERRORPOS=114;                 /* ERRORPOS COUNTS THE POSITION
                                       IN PRINTLINE OF THE NEXT
                                       AVAILABLE SPACE FOR CHANNEL
                                       ERROR FLAGS. FIRST AVAILABLE
                                       POSITION ON EACH LINE IS 114 */
         TIMEPIC=CTLTIME;              /* EDIT TIME OF MEASUREMENT
                                       INTO HH.MM.SS FORM */
         PRINTLINE=TIMEPIC;            /* PUT IT INTO FIRST POSITIONS
                                       OF PRINT BUFFER AND SET THE
                                       REST OF THE BUFFER TO BLANKS */
         SAMPLENOS=NOSAMPLES;          /* MOVE NUMBER OF SAMPLES INTO
                                       TEMPORARY SO THAT IT CAN BE
                                       ADDRESSED DIRECTLY */
         TOTSAMPS=TOTSAMPS+SAMPLENOS;  /* ADD TO TOTAL SAMPLES FOR
                                       THIS PAGE */
         SUBSTR(PRINTLINE,10,1), SUBSTR(PRINTLINE,64,1)='+';/* MARK
                                       BEGINNING OF VERTICAL AXES */
         SUBSTR(PRINTLINE,27,1), SUBSTR(PRINTLINE,81,1)='.';/* WARNING
                                       MARKER AT 35% BUSY */
         DO LOOP2 = 1 TO NOCHANS;      /* ONCE FOR EACH CHANNEL
                                       PRESENT */
            DUMBITS(2)=CHANIDENT(LOOP2);/* THESE TWO STATEMENTS
                                       CONVERT THE CHANNEL ID FROM A
                                       BIT(8) STRING INTO A BIN(15)
                                       NUMBER WITHOUT CALLING A
                                       LIBRARY ROUTINE */
            CHANNUM=DUMBIN;
            PRESENT(CHANNUM)='1'B;     /* CHANNEL EXISTS */
            INDIC1=INDICS(LOOP2);      /* PUT CHANNEL STATUS FLAGS
                                       INTO A TEMPORARY FOR EASIER
                                       ADDRESSING */
            IF INDIC1 & '00000110'B THEN
               DO;                     /* INFO FOR THIS CHANNEL IS
                                       INVALID SO SET UP ERROR FLAG AT
                                       THE END OF THE PRINT LINE */
                  SUBSTR(PRINTLINE,ERRORPOS,2)= CHANCAR(CHANNUM)
                  ××'*';               /* CHANNEL NUMBER AND * TO
                                       REFER TO MESSAGE AT THE BOTTOM
                                       OF THE PAGE */
                  ERRCHN(CHANNUM)='1'B;/* SET ERROR FLAG FOR THIS
                                       CHANNEL */
                  ERRORPOS=ERRORPOS+1; /* INCREMENT THE POSITION OF
                                       THE ERROR FLAGS FOR CHANNELS ON
                                       THIS LINE SO ANOTHER CHANNEL IN
                                       ERROR WILL PRINT NEXT TO THIS
                                       ONE */
                  ERRORS='1'B;         /* SET FLAG ON TO PRODUCE ERROR
                                       MESSAGE AT THE BOTTOM OF THE
                                       PAGE */
                  IF INDIC1 & '00000010'B THEN
                     DO;               /* CHANNEL ID IS VALID, BUT
                                       DATA FOR THIS CHANNEL IS NOT.
                                       (CHANNEL VARIED ONLINE OR
                                       OFFLINE DURING MEASUREMENT
                                       PERIOD. THIS SEPARATION IS
                                       NECESSARY OTHERWISE
                                       PLOTTING/HISTOGRAM STATISTICS
                                       WILL NOT BE COLLECTED IF THE
                                       CHANNEL IS VARIED
                                       ONLINE/OFFLINE DURING THE
                                       PRODUCTION OF THE FIRST RECORD */
                        PRESENT(CHANNUM)='1'B;/* CHANNEL IS DEFINITELY
                                       THERE */
                        IF INDIC1 & '00100000'B THEN
                           BLOCK(CHANNUM)='1'B;/* WE HAVE A BLOCK
                                       MULTIPLEXOR */
                        ELSE
                           IF INDIC1 & '00010000'B THEN
                              BYTES(CHANNUM)='1'B;/* WE HAVE A BYTE
                                       MULTIPLEXOR */
                     END;
               END;
            ELSE
               DO;                     /* DATA FOR THE CHANNEL IS
                                       VALID */
                  SIOSARY(CHANNUM)=SIOSARY(CHANNUM)+SIOS(LOOP2);/* ADD
                                       NUMBER OF START IOS FOR THIS
                                       CHANNEL, THIS PAGE TO TOTAL */
                  IF INDIC1 & '00010000'B THEN
                     BYTES(CHANNUM)='1'B;/* BYTE MULTIPLEXOR - CANNOT
                                       COLLECT BUSYNESS STATISTICS FOR
                                       IT */
                  ELSE
                     DO;               /*SELECTOR OR BLOCK MULTIPLEXOR*/
                        PRCNT1=
                        ROUND(DIVIDE(BURST(LOOP2)*50, SAMPLENOS, 15), 0)

                        ;              /* PERCENTAGE CHANNEL BUSY BUT
                                       CPU WORKING */
                        PRCNT2=
                        ROUND(DIVIDE(BUSY(LOOP2)*50,SAMPLENOS,15),0);/*
                                        PERCENTAGE CHANNEL BUSY AND
                                       CPU IN WAIT STATE */
                        IF SLCT1 = 0 THEN
                           DO;         /* NO SELECTION OF CHANNELS FOR
                                       SELECTIVE PRINTING ON RIGHT
                                       HAND SIDE OF PAGE */
                              SUBSTR(PRINTLINE,PRCNT1+10,1) =
                              CHANCAR(CHANNUM);
                              SUBSTR(PRINTLINE,PRCNT2+64,1) =
                              CHANCAR(CHANNUM);
                           END;
                        ELSE
                           DO;         /* SELECTED CHANNELS APPEAR IN
                                       SECOND GRAPH ON RIGHT HAND SIDE
                                       OF THE PAGE */
                              IF DOPRINT(CHANNUM) THEN
                                 TEMP1=64;/* PRINT ON RHS */
                              ELSE
                                 TEMP1=10;/* PRINT ON LHS */
                              SUBSTR(PRINTLINE,TEMP1+PRCNT1,1) =
                              CHANCAR(CHANNUM);
                           END;
                        BURSTSAMPS(CHANNUM) =
                        BURSTSAMPS(CHANNUM)+BURST(LOOP2);/* ADD
                                       SAMPLES TO TOTAL FOR THIS PAGE
                                       FOR CHANNEL IN BUSY STATE */
                        WAITSAMPS(CHANNUM)= WAITSAMPS(CHANNUM)+
                        BUSY(LOOP2);   /* ADD TO TOTAL FOR THIS PAGE
                                       FOR CHANNEL IN BUSY STATE AND
                                       CPU IN WAIT STATE */
                        IF INDIC1 & '00100000'B THEN
                           DO;         /* CHANNEL IS A BLOCK
                                       MULTIPLEXOR */
                              BLOCK(CHANNUM)='1'B;/* SET BLOCK
                                       MULTIPLEXOR FLAG */
                              IF DOINLOOP THEN
                                 DO;   /* COLLECTION OF STATISTICS FOR
                                       HISTOGRAM PRINTING AND PLOTTING
                                       OF START IOS PER SECOND AGAINST
                                       PERCENTAGE CHANNEL BUSY */
                                    SIOSSEC=SIOS(LOOP2)/DURATION;/*
                                       FIND NUMBER OF START IOS PER */
                                    SIOSSEC=MIN(SIOSSEC,100);/* MAKE
                                       SURE THAT IT DOES NOT GO
                                       OUTSIDE BOUNDS OF THE ARRAY */
                                    INDIRECT(CHANNUM)
                                    ->GRID(PRCNT1,SIOSSEC)=
                                    INDIRECT(CHANNUM)
                                    ->GRID(PRCNT1,SIOSSEC) +1;/*
                                       INDIRECT(CHANNUM) POINTS TO THE
                                       GRID DATA FOR THAT CHANNEL.
                                       THIS UPDATES THE NUMBER OF
                                       RECORDS WITH PRCNT1 CHANNEL
                                       BUSY AND SIOSSEC NUMBER OF
                                       START IOS PER SECOND */
                                 END;
                           END;
                     END;
               END;
         END;
         PUT FILE(PRINT) EDIT(PRINTLINE) (SKIP,A(132));/* WRITE OUT
                                       PRINT LINE */
         LASTIME=CTLTIME;              /* UPDATE TIME ON LAST RECORD
                                       AFTER OUTPUTTING LINE AS IF
                                       ENDPAGE IS RAISED WHILE PUTTING
                                       THAT RECORD THEN THE RECORD
                                       WILL BE THE FIRST RECORD ON THE
                                       NEW PAGE */
         IF FIRSTLOOP THEN
            CALL SETPLOTUP;            /* IF THIS IS THE FIRST TIME
                                       THROUGH AND PLOTTING/HISTOGAM
                                       IS REQUIRED, THEN CALL THE
                                       ROUTINE TO SET IT ALL UP */
 READ_NEXT_RECORD:
         READ FILE(INFILE) SET(FILEPTR);/*GET NEXT RECORD*/
      END;                             /*LOOP BACK FOR NEXT RECORD*/
 %PAGE;
 ENDRUN: /* END OF FILE RAISED ON INFILE */
      CALL END_PROCESS;                /* COMMON END PROCESSING
                                       ROUTINE */
      PUT FILE(PRINT) EDIT('END OF JOB.', LOOP,' RECORDS PROCESSED,')
      ( PAGE, X(20), A(13), F(7), A(19)) (
       LOOP-#DISCARDED, ' RECORDS USED,', #DISCARDED,
       ' RECORDS DISCARDED' ) ( F(7), A(14), F(7), A(18));
      RETURN;                          /* TO OS - DONE */
 %PAGE;
 NORUN: /* END OF FILE OR TRANSMIT RAISED ON INFILE AND NO TYPE 73
 RECORDS PROCESSED */
      PUT FILE(PRINT)
      EDIT('NO CHANNEL ACTIVITY RECORDS FOUND BEFORE END OF FILE',
       #DISCARDED, ' RECORDS DISCARDED.' ) (PAGE, X(20), A, F(7), A);
      RETURN;                          /* TO OS - NOTHING MORE TO DO */
 %PAGE;
 ENDBAD: /* TRANSMIT CONDITION RAISED FOR INFILE */
      CALL END_PROCESS;                /* COMMON END PROCESSING
                                       ROUTINE */
      PUT FILE(PRINT)
      EDIT('TRANSMIT CONDITION RAISED FOR INFILE. ', LOOP,
       ' RECORDS PROCESSED BEFORE ERROR,') (PAGE,X(20),A(38),F(7),A(32))

      (LOOP-#DISCARDED, ' RECORDS USED,', #DISCARDED,
       ' RECORDS DISCARDED' ) ( F(7), A(14), F(7), A(18) );
      RETURN;                          /* TO OS - DONE */
 %PAGE;
 NEWPAGE: /*NEW PAGE ROUTINE - PRINTS FOOTINGS & HEADINGS*/
   PROC REORDER;
 %SKIP(2);
 /* CONSTANTS */
   DCL
      1 AXISSTAT STATIC INTERNAL,
         2 PLUS1 CHAR(1) INIT('+'),
         2 PLUS2(10) CHAR(5) INIT((10)('----+')),
      AXIS CHAR(51) DEFINED AXISSTAT;  /*AXIS FOR GRAPH*/
   DCL
      1 ORDINSTAT STATIC INTERNAL,
         2 ORDINS1 CHAR(26) INIT('0        20        40     '),
         2 ORDINS2 CHAR(25) INIT('   60        80       100'),
      ORDINS CHAR(51) DEFINED ORDINSTAT;/*ORDINATES FOR GRAPH*/
   DCL
      HEAD3 CHAR(23) STATIC INTERNAL INIT( '% CHANNEL IN BURST MODE'),
                                       /* HEADING FOR LEFT HAND GRAPH */

      HEAD4(0:1) CHAR(36) STATIC INTERNAL INIT(
   '% CHANNEL IN BURST MODE AND CPU WAIT',
   '% SELECTED CHANNEL(S) IN BURST MODE '),/* ALTERNATIVE HEADINGS FOR
                                       RIGHT HAND GRAPH - (1) DEFAULT
                                       HEADING, (2) HEADING WHEN
                                       CHANNEL SELECTION OPTION HAS
                                       BEEN USED */
      HEADULINE STATIC CHAR(36) INIT((36)'_');/* UNDERLINE FOR
                                       HEADINGS */
   DCL
      TAIL5 CHAR(10) INIT('START TIME');/* PART OF HEADINGS TO GO ON
                                       THE BOTTOM OF THE PAGE */
 %SKIP(2);
 /* LOCAL VARIABLES */
   DCL
      STCHN BINARY(15) INITIAL(0),     /* CHANNEL COUNTER */
      DOHEAD BIT(1) ALIGNED;           /* FLAG - '1'B INDICATES THAT
                                       THE HEADING IS TO BE PRINTED.
                                       USED TO DISTINGUISH BETWEEN THE
                                       THREE ENTRY POINTS */
   DCL
      PBUFF CHAR(120) INIT('');        /* PRINT BUFFER FOR CHANNEL
                                       ACTIVITY ON BOTTOM OF THE PAGE */
   DCL
      1 SEGMENTS(3) DEFINED PBUFF,     /* FIELDS DEFINED ON PBUFF */
         2 CHANPRT CHAR(1),            /* CHANNEL NUMBER
                                       IDENTIFICATION */
         2 PAD1 CHAR(1),               /* PADDING */
         2 CHANDESC CHAR(5),           /* TYPE OF CHANNEL 'BLOCK' ETC */
         2 STAR CHAR(1),               /* ASTERISK APPEARS HERE IF
                                       THERE HAS BEEN AN ERROR FOR
                                       THIS CHANNEL ON THIS PAGE */
         2 PAD2 CHAR(2),               /* PADDING */
         2 SIOSPERM PIC 'ZZZ9.99',     /* SPACE FOR NUMBER OF START
                                       IOS PER MINUTE */
         2 PAD3 CHAR(4),               /* PADDING */
         2 BURSTPERC PIC 'ZZ9V.9',     /* PERCENTAGE CHANNEL BUSY IN
                                       BURST MODE IF CHANNEL IS NOT A
                                       BYTE MULTIPLEXOR */
         2 PAD4 CHAR(4),               /* PADDING */
         2 BUSYPERC PIC 'ZZ9V.9',      /* PERCENTAGE CHANNEL BUSY AND
                                       CPU IS IN WAIT STATE IF CHANNEL
                                       IS NOT A BYTE MULTIPLEXOR */
         2 PAD5 CHAR(5);               /* PADDING */
   DCL
      TAIL6 CHAR(40) STATIC INTERNAL INIT(
   'CHANNEL #  SIOS/S  % BURST   % WAIT     ');
 %SKIP(2);
      DOHEAD='1'B;                     /*DO WANT TO PRINT HEADING WITH
                                       THIS ENTRY*/
      GOTO ALLIN;
 %SKIP(3);
 TAILPAGE:
      ENTRY;                           /*ENTRY WHICH JUST PRINTS TAIL
                                       FOOTING*/
      DOHEAD='0'B;                     /*DON'T WANT TO PRINT HEADING*/
 %SKIP(3);
 ALLIN:
      ;                                /* FIRST OF ALL, FIND OUT TIME
                                       BETWEEN FIRST RECORD ON PAGE ND
                                       LAST RECORD ON PAGE */
      STARTSECS=CONVT(FIRSTIME);       /* CONVERT TIME OF FIRST RECORD
                                       ON PAGE TO SECONDS PAST
                                       MIDNIGHT */
      ENDSECS=CONVT(LASTIME);          /* DO THE SAME FOR THE LAST
                                       TIME ON THE PAGE - NOTE THAT
                                       THE LAST TIME DOES NOT TAKE
                                       INTO ACCOUNT THE LINE THAT MAY
                                       HAVE BEEN HELD OVER TO THE NEXT
                                       PAGE BY 'ENDPAGE' BECAUSE THE
                                       LAST TIME IS NOT UPDATED UNTIL
                                       THE LINE IS PRINTED */
      INTERVAL=ENDSECS-STARTSECS;      /* FIND OUT THE DIFFERENCE
                                       BETWEEN FIRST TIME AND LAST
                                       TIME */
      IF INTERVAL <= 0 THEN
         INTERVAL=INTERVAL+86400;      /* WRAPAROUND AT MIDNIGHT*/
      STARTEDIT=FIRSTIME;              /* EDIT HHMMSS INTO HH.MM.SS */
      BINTERVAL=INTERVAL;              /* CONVERT TO BINARY FOR
                                       WORKING OUT START IO RATES */
      INTERVAL=DEC(INTERVAL/60,7)*100+MOD(INTERVAL,60);/* CONVERT
                                       INTERVAL TO MMSS IN DECIMAL FOR
                                       PRINTING */
      ENDEDIT=LASTIME;                 /* EDIT HHMMSS INTO HH.MM.SS
                                       FOR PRINTING */
      DIFFEDIT=INTERVAL;               /* EDIT MMSS INTO MM.SS FOR
                                       PRINTING */
      PUT FILE(PRINT)
      EDIT(AXIS,AXIS,ORDINS,ORDINS,TAIL5,TAIL6, TAIL6,TAIL6,STARTEDIT) (
       X(6),2(X(3),A(51)),SKIP,X(6),(2)(X(3),A(51)),SKIP(2),A(10),
       X(2),( 3)A(40),SKIP,X(2),A(8)); /* PUT BOTTOM AXIS AND
                                       ORDINATES ON GRAPH PLUS
                                       HEADINGS FOR CHANNEL ACTIVITY
                                       SUMMARY FOR THE PAGE */
      STCHN=0;                         /* THE NEXT SECTION PRINTS UP
                                       TO SIX LINES CONTAINING A
                                       SUMMARY OF THE BEHAVIOUR OF
                                       EACH CHANNEL OVER THE TIME
                                       PERIOD COVERED BY THE PAGE.
                                       THREE CHANNELS ARE PRINTED PER
                                       LINE UP TO THE NUMBER OF
                                       CHANNELS EXISTING. DOWN THE
                                       LEFT HAND SIDE THE START TIME,
                                       END TIME AND INTERVAL ARE
                                       PRINTED */
      DO LOOP4 = 1 TO 6;               /* COUNT DOWN THE LINES */
         PBUFF='';                     /*CLEAR PRINT BUFFER*/
         DO LOOP5 = 1 TO 3 WHILE(STCHN <= 15);/* TRY TO FIND THREE
                                       CHANNELS TO PRINT ON THIS LINE */
            DO WHILE(STCHN<=15);       /* LOOK DOWN THE LIST OF
                                       CHANNELS */
               IF PRESENT(STCHN) THEN
                  GOTO FOUNDONE;       /* FOUND A CHANNEL */
               STCHN=STCHN+1;          /* NOT FOUND, SO COUNT UP LOOP */
            END;
            LEAVE;                     /* NO MORE CHANNELS LEFT */
 FOUNDONE:
            CHANPRT(LOOP5)=CHANCAR(STCHN);/* INSERT CHANNEL NUMBER
                                       INTO LINE */
            IF BYTES(STCHN) THEN
               CHANDESC(LOOP5)='BYTE ';/* BYTE MULTIPLEXOR */
            ELSE
               IF BLOCK(STCHN) THEN
                  CHANDESC(LOOP5)='BLOCK';/* BLOCK MULTIPLEXOR */
               ELSE
                  CHANDESC(LOOP5)='SELCT';/* SELECTOR */
            IF ERRCHN(STCHN) THEN
               STAR(LOOP5)='*';        /* AN ERROR HAS OCCURRED ON
                                       THIS CHANNEL SOME TIME THIS
                                       PAGE SO FLAG IT TO TIE IN WITH
                                       THE ERROR PRINT AT THE SIDE OF
                                       THE MAIN GRAPH AND ALSO THE
                                       MESSAGE AT THE BOTTOM */
            IF ^BYTES(STCHN) THEN
               DO;                     /* CAN PRINT OUT OVERALL
                                       PERCENTAGE BUSY FOR SELECTOR
                                       AND BLOCK MULTIPLEXOR CHANNELS */
                  BURSTPERC(LOOP5) =DEC(BURSTSAMPS(STCHN),9,4)/
                  DEC(TOTSAMPS,9,4)*100;/* PERCENTAGE BUSY AND CPU
                                       GOING */
                  BUSYPERC(LOOP5) =DEC(WAITSAMPS(STCHN),9,4)/
                  DEC(TOTSAMPS,9,4)*100;/* PERCENTAGE BUSY AND CPU IN
                                       WAIT STATE */
               END;
            SIOSPERM(LOOP5)=(SIOSARY(STCHN)*100)/BINTERVAL;/* HOWEVER
                                       CAN PUT IN NUMBER OF START IOS
                                       PER MINUTE FOR ALL CHANNELS,
                                       EVEN POOR BYTE MULTIPLEXORS */
            STCHN=STCHN+1;             /* FINISHED WITH THIS ONE, ON
                                       TO NEXT */
         END;
         PUT FILE(PRINT) EDIT(SIDECHAR(LOOP4),PBUFF) (
          SKIP,A(10),X(2),A(120));     /* OUTPUT ASSEMBLED LINE */
      END;
      IF ERRORS THEN
         PUT FILE(PRINT)
         EDIT( '*  CHANNEL VARIED OFFLINE OR ONLINE DURING MEASUREMENT'
         ××' PERIOD.  DATA FOR THIS PERIOD MAY BE INVALID') (
          SKIP(2), A(99) );
      IF ^DOHEAD THEN
         RETURN;                       /* DON'T WANT HEADING */
      PUT FILE(PRINT) PAGE;            /* NEW PAGE */
      GOTO HEADL1;
 HEADPAGE:
      ENTRY;                           /* ENTRY FOR HEADING ONLY */
      DOHEAD='0'B;                     /* NOT CALLED AT NEWPAGE */
 HEADL1:
      TOTSAMPS=0;
      SIOSARY,BURSTSAMPS,WAITSAMPS=0;  /* ZEROISE COUNTERS FOR THIS
                                       PAGE */
      ERRORS='0'B;
      ERRCHN='0'B;                     /* RESET ERROR FLAGS FOR NEXT
                                       PAGE */
      FIRSTIME=LASTIME;                /* TIME OF BEGINNING OF
                                       MEASUREMENT ON NEXT PAGE IS
                                       TIME OF ENDING MEASUREMENT ON
                                       LST PAGE */
      CALL PAGE_HEADING;               /*PUT HEADING ON PAGE.*/
      PUT FILE(PRINT)
      EDIT(HEAD3,HEAD4(SLCT1), SUBSTR(HEADULINE,1,23),HEADULINE, 'TIME',
       ORDINS,ORDINS,AXIS,AXIS) (
       SKIP(2),X(19),A(25),X(30),A(36),SKIP(0),X(19),A(25), X(30),
       A(36), SKIP(2),X(2),A(4),(2)(X(3),A(51)),SKIP,X(6),
       (2)(X(3),A(51)));               /* TOP AXES, HEADINGS AND
                                       ORDINATES FOR CHANNEL USAGE
                                       GRAPH */
      IF DOHEAD THEN
         PUT FILE(PRINT) SKIP;         /* DOHEAD IS USED AS A FLAG
                                       HERE TO DIFFERENTIATE BETWEEN
                                       HEADPAGE CALLED THE FIRST TIME
                                       TO PUT A HEADING ON THE PAGE
                                       AND BETWEEN CALLS TO NEWPAGE
                                       RESULTING FROM THE ENDPAGE
                                       CONDITION BEING RAISED. IF
                                       ENDPAGE HAS BEEN RAISED, THEN
                                       AN ADDITIONAL SKIP IS NEEDED TO
                                       ENSURE THAT THE LINE OF
                                       INFORMATION HELD OVER FROM IN
                                       PRINTLINE STARTS AT THE
                                       BEGINNING OF A PRINT LINE */
      RETURN;
   END;                                /*OF NEWPAGE*/
 %PAGE;
 CONVT: /*CONVERTS HH.MM.SS TO SECONDS*/
   PROC(HRSMSEC) RETURNS(DEC(7)) REORDER;
 %SKIP(2);
 /********************************************************************/
 /*   CONVT CONVERTS A DECIMAL(7) NUMBER WHOSE DIGITS REPRESENT      */
 /*   THE TIME AS HHMMSS INTO A DECIMAL(7) NUMBER GIVING THE NUMBER  */
 /*   OF SECONDS SINCE MIDNIGHT THAT THIS REPRESENTS                 */
 /********************************************************************/
 %SKIP(2);
 /* PARAMETERS */
   DCL
      HRSMSEC DEC(7);                  /* INPUT TIME (HHMMSS) TO BE
                                       CONVERTED */
 %SKIP(2);
 /* LOCAL VARIABLES */
   DCL
      (CONTMP1,
      CONTMP2,
      CONTMP3) FIXED DEC(7);           /* TEMPORARIES */
 %SKIP(2);
      CONTMP1=HRSMSEC/10000;           /* CONTMP1 CONTAINS HOURS */
      CONTMP2=HRSMSEC-CONTMP1*10000;   /* CONTMP2 CONTAINS MMSS */
      CONTMP3=CONTMP2/100;             /* SEPARATE OFF THE MINUTES */
      CONTMP2=CONTMP2-CONTMP3*100;     /* GET THE SECONDS */
      CONTMP1=((CONTMP1*60)+CONTMP3)*60+CONTMP2;/* CONVERT TO SECONDS */
      RETURN(CONTMP1);
   END;                                /*OF CONVT*/
 %PAGE;
 SETPLOTUP: /*SET UP DATA FOR PLOT*/
   PROC REORDER;
 /*******************************************************************/
 /*  SETPLOTUP SETS UP THE GRID FOR PLOTTING THE CHANNEL            */
 /*  ACTIVITY (AS % BUSY) AGAINST THE NUMBER OF STARTIOS            */
 /*ISSUED TO THAT CHANNEL.                                          */
 /*******************************************************************/
 %SKIP(2);
 /* LOCAL VARIABLES */
   DCL
      (#BMPLX,                         /* COUNTER OF NUMBER OF BLOCK
                                       MULTIPLEXOR CHANNELS */
      LOOP) BIN(15);                   /* LOOP COUNTER */
 %SKIP(2);
      #BMPLX=0;
      DO LOOP = 0 TO 15;
         IF BLOCK(LOOP) THEN
            DO;                        /* YES, IT IS A BLOCK
                                       MULTIPLEXOR */
               #BMPLX=#BMPLX+1;        /* INCREMENT COUNT OF BLOCK
                                       MULTIPLEXORS */
               ALLOCATE GRID SET(INDIRECT(LOOP));/* GRID IS INDIRECTLY
                                       ADDRESSED THROUGH THE POINTER
                                       ARRAY INDIRECT */
            END;
      END;
      IF #BMPLX = 0 THEN
         DO;                           /* WE HAVEN'T FOUND ANY BLOCK
                                       MULTIPLEXORS */
            DOINLOOP='0'B;             /* SET FLAG TO PREVENT
                                       COLLECTION OF PLOTTING DATA */
            DOPLOT='0'B;               /* SET FLAG TO PREVENT PLOTTING
                                       */
            DOHIST='0'B;               /* SET FLAG TO PREVENT
                                       HISTOGRAM PRINT */
            RETURN;
         END;
      DO LOOP = 0 TO 15;               /* ELSE OK. NOW PUT IN FIRST
                                       ENTRIES FOR THE BLOCK
                                       MULTIPLEXOR CHANNELS */
         IF BLOCK(LOOP)&(^ERRCHN(LOOP)) THEN
            DO;                        /* CHANNEL IS A BLOCK
                                       MULTIPLEXOR AND THE DATA FOR IT
                                       IS VALID */
               PRCNT1 =
               ROUND(DIVIDE(BURSTSAMPS(LOOP)*50,SAMPLENOS,15),0);
               SIOSSEC =SIOSARY(LOOP)/DURATION;
               INDIRECT(LOOP)->GRID(PRCNT1,SIOSSEC)=1;
            END;
      END;
      FIRSTLOOP='0'B;                  /* DO NOT WANT TO CALL
                                       INITIALISATION ROUTINE AGAIN */
      DOINLOOP='1'B;                   /* DO WANT TO COLLECT DATA IN
                                       MAIN PROCESSING LOOP */
      RETURN;
   END;                                /*OF SETPLOTUP*/
 %PAGE;
 PLOTHEM: /* PLOTTING OF CHANNEL BUSY/SIOS PER SECOND GRAPHS */
   PROC REORDER;
 %SKIP(2);
 /****************************************************************/
 /*  PLOTHEM IS CALLED AT THE END OF PROCESSING TO PRODUCE A     */
 /*  REPORT FOR EACH BLOCK MULTIPLEXOR CHANNEL OF THE CORRELATION*/
 /*  BETWEEN CHANNEL UTILITASTION AND NUMBER OF START IO         */
 /*  INSTRUCTIONS ISSUED TO THAT CHANNEL PER SECOND.             */
 /****************************************************************/
 %SKIP(2);
 /* ENTRY */
   DCL
      XXEXPCM ENTRY(FIXED BIN(15)) RETURNS(CHAR(1)) REDUCIBLE;/*
                                       ROUTINE TO CONVERT BINARY
                                       NUMBER TO CHARACTER FOR
                                       PLOTTING */
 %SKIP(2);
 /*CONSTANTS*/
   DCL
      EXPULINE CHAR(62) STATIC INIT((62)'_');/* UNDERLINE FOR HEADING */
   DCL
      1 CORDINSDUMMY STATIC,           /* X CO-ORDINATES */
         2 CORDINSDUMMY1 CHAR(40) INIT(
   '0        10        20        30        4'),
         2 CORDINSDUMMY2 CHAR(40) INIT(
   '0        50        60        70        8'),
         2 CORDINSDUMMY3 CHAR(21) INIT('0        90       100'),
      CORDINS CHAR(101) DEFINED CORDINSDUMMY;/* X CO-ORDINATES -
                                       DEFINED THIS WAY TO AVOID
                                       CONTINUING CHARACTERS OVER LINE
                                       BOUNDARY */
   DCL
      1 AXISDUMMY STATIC,              /* X AXIS */
         2 X1AXIS CHAR(1) INIT('+'),
         2 X2AXIS CHAR(100) INIT((20)'----+'),
      XAXIS CHAR(101) DEFINED AXISDUMMY;/* WHOLE OF X AXIS */
   DCL
      1 YAXISDUMMY STATIC,
         2 BLANKS1 CHAR(9) INIT(''),
         2 TEXT1 CHAR(33) INIT('**  PERCENTAGE  CHANNEL  BUSY  **'),
         2 BLANKS2 CHAR(9) INIT(''),
      YAXIS_TEXT(0:50) CHAR(1) DEFINED YAXISDUMMY;/* Y AXIS LABEL */
   DCL
      BOTTOM_LINE STATIC CHAR(43) INIT(
   '**  NUMBER  OF  START  IOS  PER  SECOND  **');/* X AXIS LABEL */
 %SKIP(2);
 /*LOCAL VARIABLES*/
   DCL
      PBUFFER CHAR(132),               /* PRINT BUFFER */
      YORDS PIC'ZZ9' DEF PBUFFER POS(7), /* EDIT PATTERN OF ORDINATES
                                       ON PRINT BUFFER */
      (LOOPX,
      LOOPY,
      LOOPZ) BIN(15);                  /* LOOP COUNTERS - LOOPZ INSIDE
                                       LOOPY INSIDE LOOPX */
   DCL
      1 CDUMMYINFO,                    /* HEADING FOR PLOT PAGES */
         2 CDUMMYINFO1 CHAR(40) INIT(
   'CHANNEL # X. PLOT OF CHANNEL UTILISATION'),
         2 CDUMMYINFO2 CHAR(22) INIT(' AGAINST START IO RATE'),
      EXPLHEAD CHAR(62) DEFINED CDUMMYINFO;/* HEADING - DEFINED THIS
                                       WAY TO AVOID CONTINUING
                                       CHARACTER CONSTANTS OVER LINES */
 %PAGE;
      DO LOOPX = 0 TO 15;
         IF BLOCK(LOOPX) THEN
            DO;                        /* CHANNEL IS A BLOCK
                                       MULTIPLEXOR SO THERE WILL BE
                                       INFO TO PRINT */
               GRIDPTR=INDIRECT(LOOPX);/*TEMPRARY FOR INDIRECT ADDRESS*/
               SUBSTR(EXPLHEAD,11,1)=CHANCAR(LOOPX);/* INSERT CHANNEL
                                       # INTO HEADING. */
               PUT FILE(PRINT) PAGE;   /*NEW PAGE*/
               CALL PAGE_HEADING;      /*NEW HEADING*/
               PUT FILE(PRINT) EDIT(EXPLHEAD,EXPULINE,CORDINS) (
                SKIP(2),X(28),A(62),SKIP(0),X(28),A(62), SKIP(2),X(9),
                A(101));               /*SPECIFIC(HEADINGS*/
               DO LOOPY = 50 TO 0 BY -1;/*ONCE PER LINE OF GRID */
                  PBUFFER='';          /*CLEAR BUFFER          */
                  SUBSTR(PBUFFER,4,1)= /*Y AXIS LABEL          */
                  YAXIS_TEXT(50-LOOPY);
                  IF (LOOPY=50)×(LOOPY=0) THEN
                     SUBSTR(PBUFFER,10,101) =XAXIS;/* PUT X AXIS ON
                                       TOP AND BOTTOM LINES */
                  DO LOOPZ = 0 TO 100;
                     IF (GRIDPTR->GRID(LOOPY,LOOPZ))^=0 THEN
                        SUBSTR(PBUFFER,LOOPZ+10,1)=
                        XXEXPCM(GRIDPTR->GRID(LOOPY,LOOPZ));/* ONLY
                                       REPLACE NON BLANK CHARACTERS */
                  END;
                  IF SUBSTR(PBUFFER,10,1) = ' ' THEN
                     IF MOD(LOOPY,5) = 0 THEN
                        SUBSTR(PBUFFER,10,1)='+';/* Y AXIS PRINT - '+'
                                       EVERY FIFTH LINE */
                     ELSE
                        SUBSTR(PBUFFER,10,1)='×';/* '×' FOR THE OTHER
                                       LINES */
                  IF MOD(LOOPY,10) = 0 THEN
                     YORDS=LOOPY*2;    /* ORDINATES AT 100, 80, 60... */
                  PUT FILE(PRINT) EDIT(PBUFFER) (SKIP,A(132));
               END;
               PUT FILE(PRINT) EDIT(CORDINS,BOTTOM_LINE) (
                SKIP,X(9),A(101),SKIP(2),X(37),A(43));
            END;
      END;
      RETURN;
   END;                                /*OF PLOTHEM*/
 %PAGE;
 PLOTHIST: /*PLOT HISTOGRAMS OF OVERALL CHANNEL ACTIVITY*/
   PROC REORDER;
 %SKIP(2);
 /****************************************************************/
 /*  PLOTHIST PRINTS, FOR EACH BLOCK MULTIPLEXOR CHANNEL,        */
 /*  A HISTOGRAM OF THAT CHANNEL'S ACVITITY OVER THE             */
 /*  ENTIRE REPORT PERIOD.  THE PLOT IS OF CHANNEL ACTIVITY      */
 /*  AGAINST NO OF MINUTES THAT THE CHANNEL MAINTAINED           */
 /*  THAT RATE OF ACTIVITY.  THIS REPORT IS PRODUCED AS AN       */
 /*  OPTION, BY CODING 'H' IN THE PARMLIST PASSED TO             */
 /*  THE MAIN PROCEDURE.  FIVE HISTOGRAMS ARE PRINTED            */
 /*  PER PAGE.                                                   */
 /****************************************************************/
 %SKIP(2);
 /*CONSTANTS*/
   DCL
      HISTAXIS CHAR(21) STATIC INIT('+----+----+----+----+'),/* AXIS
                                       FOR EACH HISTOGRAM */
      HISTORDINS CHAR(21) STATIC INIT('0   15   30   45   60'), /*
                                       ORDINATES FOR ECH HISTOGRAM */
      HISTHEAD STATIC CHAR(48) INIT(
   'SUMMARY  OF  BLOCK  MULTIPLEX  CHANNEL  ACTIVITY'), /* HEADING FOR
                                       HISTOGRAM PRINT PAGES */
      HISTULINE STATIC CHAR(48) INIT((48)'_'), /* UNDERLINE FOR
                                       HEADINGS */
      CHANHIST CHAR(10) STATIC INIT('CHANNEL # '),/* HEADING FOR EACH
                                       CHANNEL'S HISTOGRAM */
      YAXISLABELDUMMY CHAR(51) STATIC INIT(
   '        ** PERCENTAGE  CHANNEL  UTILISATION **'),/* Y-AXIS LABEL */
      YAXISLABEL(0:50) CHAR(1) DEFINED YAXISLABELDUMMY;/* ARRAY TO
                                       PICK OFF INDIVIDUAL CHARACTERS
                                       OF Y-AXIS LABEL FOR INSERTING
                                       INTO EACH LINE OF HISTOGRAM
                                       PRINTOUT */
 %SKIP(2);
 /*LOCAL VARIBLES*/
   DCL
      HISTBUFFER CHAR(132) INIT(''),   /* PRINT LINE BUFFER */
      1 HISTLINE DEFINED HISTBUFFER,   /* FIELD SELECTION OUT OF PRINT
                                       LINE */
         2 YLABELPLACE CHAR(1),        /* PLACE FOR VERTICAL Y AXIS
                                       LABEL */
         2 YORDIN PIC'ZZ9',            /* Y ORDINATES - ONLY PRINTED
                                       FOR 0,20,40... */
         2 HISPART(5),                 /* HISTOGRAM PARTS */
            3 YAXISPLACE CHAR(1),      /* Y AXIS */
            3 STARSPUT(20) CHAR(1),    /* HISTOGRAM PART */
            3 PAD1 CHAR(1),            /* ONE CHARACTER PADDING */
      1 CUMPART(5) DEF HISTBUFFER POS(113), /* CUMULATIVE PERCENTAGES
                                       FIELDS */
         2 PAD1 CHAR(1),               /* ONE CHARACTER PADDING */
         2 CUMEDIT PIC'ZZ9';           /* EDIT PATTERN FOR CUMULATIVE
                                       DATA */
   DCL
      HISTPTR(5) POINTER,              /* ARRAY OF POINTERS USED TO
                                       HOLD THE ADDRESSES OF THE GRID
                                       ARRAYS FOR THE BLOCK
                                       MULTIPLEXOR CHANNELS TO BE
                                       PRINTED IN EACH POSITION ACROSS
                                       THE PAGE. THIS MEANS THAT
                                       HISTPTR(I) POINTS TO THE DATA
                                       FOR THE ITH CHANNEL'S DETAILS */
      HISTCHARS(5) CHAR(1),            /* ARRAY USED TO HOLD THE
                                       CHARACTER FORM OF THE CHANNEL
                                       NUMBER FOR PRINTING AT THE TOP
                                       OF EACH HISTOGRAM */
      CHANS_LOOKED_AT BIN(15) INIT(0), /* COUNTER OF CHANNELS LOOKED
                                       AT IN THE SEARCH FOR BLOCK
                                       MULTIPLEXOR CHANNELS TO PRINT */
      NUM_IN_HIST BIN(15) INIT(0),     /* NUMBER OF CHANNELS TO BE
                                       PRINTED ACROSS THE PAGE THIS
                                       TIME */
      TIME_PER_REC BIN(31),            /* USED TO HOLD THE AMOUNT OF
                                       TIME THAT EACH ENTRY IS WORTH
                                       IN TENTHS OF A SECOND.
                                       CALCULATED BY DIVIDING THE
                                       NUMBER OF RECORDS READ BY THE
                                       TOTAL TIMESTAMP DIFFERENCE
                                       BETWEEN THE FIRST AND THE LAST */
      (LOOPX,
      LOOPY,
      LOOPZ) BIN(15),                  /* LOOP COUNTERS - LOOPZ IS THE
                                       LOOP INSIDE LOOPY IS THE LOOP
                                       INSIDE LOOPX */
      #TIMETEMP BIN(31),               /* TEMPORARY TO HOLD THE TIME
                                       THAT THE CHANNEL WAS IN THE
                                       CURRENT PERCENTAGE BUSY SLOT */
      #STARS BIN(15),                  /* COUNTER OF NUMBER OF STARS
                                       THAT ARE TO BE OUTPUT ON ONE
                                       LINE OF ONE HISTOGRAM */
      CUM_ENTRIES(5) BIN(15),          /* ACCUMULATOR OF NUMBER OF
                                       ENTRIES FOUND SO FAR FOR EACH
                                       CHANNEL IN THE HISTOGRAM PRINT.
                                       USED TO PROVIDE THE CUMULATIVE
                                       PERCENTAGE COLUMNS DOWN THE RHS
                                       */
      HASHPRINT BIT(1) ALIGNED,        /* FLAG TO INDICATE THAT THE
                                       NUMBER OF STARS THAT SHOULD BE
                                       PRINTED FOR THIS CHANNEL AT
                                       THIS LINE IS MORE THAN 20 AND
                                       WOULD OVERFLOW. A '#' CHARACTER
                                       IS OUTPUT AS THE LAST CHARACTER
                                       OF THE HISTOGRAM TO INDICATE
                                       THAT OVERFLOW HAS OCCURRED */
      #ENTRIES BIN(31),                /* TEMPORARY USED TO HOLD THE
                                       NUMBER OF ENTRIES IN A ROW OF
                                       GRID BEFORE CALCULATING THE
                                       NUMBER OF STARS TO BE OUTPUT */
      #RECS_USED BIN(31);              /* NUMBER OF SMF TYPE 73 USED -
                                       = LOOP (TOTAL) - #DISCARDED. */
 %PAGE;
      STARTSECS=CONVT(START_OF_JOB);   /*FIND TOTAL JOB TIME. */
      ENDSECS=CONVT(LASTIME);
      BINTERVAL=ENDSECS-STARTSECS;
      IF BINTERVAL <= 0 THEN
         BINTERVAL=BINTERVAL+86400;    /* TAKE CARE OF GOING OVER
                                       MIDNIGHT */
      #RECS_USED=LOOP-#DISCARDED;      /* GET NUMBER OF SMF TYPE 73
                                       RECORDS PROCESSED THIS TIME
                                       (=TOTAL - #INVALID RECORDS). */
      TIME_PER_REC=(BINTERVAL*10)/#RECS_USED;/* CALCULATE THE TIME
                                       INTERVAL FOR EACH RECORD BY
                                       DIVIDING TOTAL TIME INTERVAL BY
                                       THE NUMBER OF SMF TYPE 73
                                       RECORDS AND MULTIPLYING BY 10
                                       TO CONVERT RESULT TO TENTHS OF
                                       A SECOND. */
 LOOK_FOR_BLOCKS:/* LOOK FOR BLOCK MULTIPLEXOR CHANNELS */
      NUM_IN_HIST=0;                   /* COUNTER OF NUMBER OF
                                       CHANNELS FOUND */
      CUM_ENTRIES=0;
      DO WHILE(CHANS_LOOKED_AT <= 15);
         IF BLOCK(CHANS_LOOKED_AT) THEN
            DO;                        /* FOUND A BLOCK MULTIPLEXOR
                                       CHANNEL */
               NUM_IN_HIST=NUM_IN_HIST+1;/* ADD ONE TO NUMBER FOUND */
               HISTPTR(NUM_IN_HIST)=INDIRECT(CHANS_LOOKED_AT);/* SET
                                       UP INDIRECT ADDRESSING OF GRID
                                       VIA THE ARRAY HISTPTR */
               HISTCHARS(NUM_IN_HIST)=CHANCAR(CHANS_LOOKED_AT);/* SORT
                                       OUT CHARACTERFORM OF CHANNEL
                                       NUMBER FOR HEADING */
               IF NUM_IN_HIST = 5 THEN
                  DO;                  /* WE HAVE FOUND ENOUGH
                                       CHANNELS TO PRINT A PAGE */
                     CHANS_LOOKED_AT=CHANS_LOOKED_AT+1;/* START AT
                                       NEXT CHANNEL NEXT TIME IN */
                     GOTO PRINTA_PAGE;
                  END;
            END;
         CHANS_LOOKED_AT=CHANS_LOOKED_AT+1;
      END;
      IF NUM_IN_HIST = 0 THEN
         RETURN;                       /* NOTHING TO PRINT SO RETURN */
 %PAGE;
 PRINTA_PAGE: /* WE HAVE SOME CHANNELS TO PRINT, SO PRINT THEM  */
      PUT FILE(PRINT) PAGE;            /*START A NEW PAGE. */
      CALL PAGE_HEADING;               /*AND PUT A HEADING ON IT. */
      PUT FILE(PRINT)
      EDIT(HISTHEAD,HISTULINE, 'CUMULATIVE',(
       CHANHIST,HISTCHARS(LOOPX) DO LOOPX = 1 TO NUM_IN_HIST),
       'PERCENTAGES', 'MIN', (HISTORDINS DO LOOPX = 1 TO NUM_IN_HIST),
       'CHANNELS', (HISTAXIS DO LOOPX = 1 TO NUM_IN_HIST),(
       HISTCHARS(LOOPX) DO LOOPX = 1 TO NUM_IN_HIST),(
       '_' DO LOOPX = 1 TO NUM_IN_HIST)) (
       SKIP(2),X(37),A(48),SKIP(0),X(37),A(48),SKIP,X(117),A(10), SKIP,
       X(4),(NUM_IN_HIST)(X(5),A(10),A(1),X(6)), (5-NUM_IN_HIST)(X(22)),

      X(3),A(11), SKIP, A(3), X(1), (NUM_IN_HIST) (A(21),X(1)),(
       5-NUM_IN_HIST)(X(22)),X(4),A(8),SKIP,X(4),(
       NUM_IN_HIST) (A(21),X(1)),( 5-NUM_IN_HIST)(X(22)),(
       NUM_IN_HIST-1)(A(1),X(3)),A(1),SKIP(0),X(114),(
       NUM_IN_HIST)(A(1),X(3)));       /* SET UP SPECIFIC HEADING FOR
                                       HISTOGRAM PRINT, ORDINATES AND
                                       AXES (ONLY AS MANY ORDINATES
                                       AND AXES AS THERE ARE CHANNELS */
      DO LOOPX = 0 TO 50;              /*ONCE PER LINE.           */
         HISTBUFFER='';                /* CLEAR PRINT LINE */
         YLABELPLACE=YAXISLABEL(LOOPX);/*LABEL ON Y AXIS  */
         IF (MOD(LOOPX,10) = 0) THEN
            YORDIN=LOOPX*2;            /*Y-AXIS ORDINATES AT 0 20... */
         DO LOOPY = 1 TO NUM_IN_HIST;
            #ENTRIES=SUM(HISTPTR(LOOPY)->GRID(LOOPX,*));/* SUM ROW OF
                                       ARRAY TO FIND TOTAL ENTRIES FOR
                                       THIS PERCENTAGE BUSY */
            #TIMETEMP=#ENTRIES*TIME_PER_REC;
            #STARS=(#TIMETEMP+900)/1800;/* ONE * IS WORTH THREE
                                       MINUTES WHICH IS 1800 TENTHS OF
                                       SECONDS (ROUNDED TO NEAREST *) */
            IF #STARS > 20 THEN
               DO;                     /* TOO MANY STARS SO LIMIT
                                       NUMBER OF THEM TO 20 (THE
                                       LARGEST NUMBER THAT CAN BE
                                       PRINTED) */
                  #STARS=20;
                  HASHPRINT='1'B;      /* SET FLAG TO PRINT '#' AS
                                       LAST CHARACTER AS AN OVERFLOW
                                       FLAG */
               END;
            ELSE
               HASHPRINT='0'B;         /*OK - IT WILL FIT. */
            DO LOOPZ = 1 TO #STARS;
               STARSPUT(LOOPY,LOOPZ)='*';/* PUT IN '*'S ON HISTOGRAM */
            END;
            IF HASHPRINT THEN
               STARSPUT(LOOPY,20)='#'; /*FLAG FOR TOO MANY */
            CUM_ENTRIES(LOOPY)=CUM_ENTRIES(LOOPY)+#ENTRIES;/* ADD IN
                                       ENTRIES THIS TIME */
            CUMEDIT(LOOPY)=(CUM_ENTRIES(LOOPY)*100)/#RECS_USED;/* EDIT
                                       IN ENTRIES FOR THIS TIME */
            IF MOD(LOOPX,5) = 0 THEN
               YAXISPLACE(LOOPY)='+';
            ELSE
               YAXISPLACE(LOOPY)='×';  /*EDIT IN Y-AXIS */
         END;
         PUT FILE(PRINT) EDIT(HISTBUFFER) (SKIP,A(132));/* PRINT
                                       COMPLETED LINE */
      END;
      PUT FILE(PRINT)
      EDIT((HISTAXIS DO LOOPX = 1 TO NUM_IN_HIST),'MIN',
       (HISTORDINS DO LOOPX = 1 TO NUM_IN_HIST)) (
       SKIP,X(4),(NUM_IN_HIST)(A(21),X(1)), SKIP,A(3),X(1),(
       NUM_IN_HIST)(A(21),X(1)));      /* PAGE FOOTING */
      GOTO LOOK_FOR_BLOCKS;
   END;                                /*OF PLOTHIST*/
 %PAGE;
 PAGE_HEADING: /*OUTPUT PAGE HEADING*/
   PROC REORDER;
 %SKIP(2);
 /****************************************************************/
 /*  PAGE_HEADING PUTS A TWO LINE HEADING ON THE TOP             */
 /*  OF EVERY PAGE, INCREMENTING THE PAGE NUMBER EVERY TIME.     */
 /****************************************************************/
 %SKIP(2);
      HEAD1PAGE=PAGENO;                /*INSERT CURRENT PAGE NUMBER */
      PUT FILE(PRINT) EDIT(HEAD1,HEAD2) (SKIP,A(132),SKIP,A(132));
      PAGENO=PAGENO+1;
      RETURN;
   END;                                /*OF PAGE_HEADING*/
 %PAGE;
 END_PROCESS: /*END OF PROCESSING ROUTINE*/
   PROC REORDER;
 %SKIP(2);
 /*******************************************************************/
 /*  END PROCESS CONTAINS THE COMMON END OF                         */
 /*  PROCESSING CODE, INCLUDING THE                                 */
 /*  OPTIONAL CALLS TO THE PLOTTING ROUTINES.                       */
 /*******************************************************************/
 %SKIP(2);
      ON ENDPAGE(PRINT)
         ;                             /*DISABLE ENDPAGE*/
      CALL TAILPAGE;                   /*PUT FOOTING ON THE PAGE*/
      IF (DOPLOT×DOHIST) THEN
         DO;                           /* THERE ARE SOME MORE PAGES TO
                                       BE PRINTED SO ADD START TIME
                                       AND END TIME TO PAGE HEADINGS */
            HEAD1START='START TIME';
            HEAD2END ='END   TIME';
            HEAD1TIME=START_OF_JOB;    /* START TIME EDIT */
            HEAD2TIME=LASTIME;         /* END TIME EDIT   */
            IF DOPLOT THEN
               CALL PLOTHEM;           /* PLOTTING ROUTINE */
            IF DOHIST THEN
               CALL PLOTHIST;          /* HISTOGRAM ROUTINE */
         END;
      RETURN;
   END;                                /*OF END_PROCESS*/
   END;                                /*OF ANALYSE*/
