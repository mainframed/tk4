*              /* LEVEL=0005                                         */
*PROCESS X,A,AG,S,STG,LIST,NEST,F(I),LMSG,MAP,ESD,OPT(2),OF;
 XXMAINL: /* MAIN PROCESSING LOOP */
   PROC(METHOD,#OFDEVICES,PTRTODEVARAY,TIME_ON_FIRST_RECORD)
   OPTIONS(REENTRANT) REORDER;
 %SKIP(4);
 /********************************************************************/
 /*   XXMAINL IS THE MAIN PROCESSING LOOP OF XXDISKMP.  IT CONSISTS  */
 /*   OF A MAIN PROCESSING LOOP WHICH IS EXECUTED ONCE PER INPUT     */
 /*   RECORD WITH SUBROUTINES TO HANDLE SOME OF THE COMMON           */
 /*   PROCESSING BETWEEN RECORD TYPES.                               */
 /********************************************************************/
 /*   LEVL(0005)  13 MARCH 1979.  CHANGES:                           */
 /*   FIND REWRITTEN TO USE TWO LISTS OF DEVICES ALLOCATED - ONE     */
 /*   FOR THE MAIN PATH ADDRESS, AND ONE FOR THE ALTERNATE PATH      */
 /*   ADDRESS.                                                       */
 /*   PROCESS_SEEK REWRITTEN TO USE REVISED VIRTUAL ARRAY SCHEME     */
 /*   FOR SEEK ANALYSIS MATRIX.                                      */
 /*   END_OF_FILE REWRITTEN TO LIST VALUE RANGES FOR SEEK ANALYSIS   */
 /*   PRINT AND LIST COMMON CHANNEL STATUS WORDS                     */
 /*   PRINTOUT AMENDED TO PASS ALTERNATE PATH ADDRESS TO XXPRTDV     */
 /*   FOR PRINTING.                                                  */
 /********************************************************************/
 /* WRITTEN BY    JOHN H LISTER,                                     */
 /*               TECHNICAL SERVICES GROUP,                          */
 /*               DATA PROCESSING DEPARTMENT,                        */
 /*               NATIONAL WESTMINSTER BANK,                         */
 /*               GOODMANS FIELDS COMPUTER CENTRE,                   */
 /*               74 ALIE STREET, LONDON   E1 8HL.                   */
 /*                                                                  */
 /*               TELEPHONE: 01-488 0707 EXT 2766.                   */
 /********************************************************************/
 %SKIP(4);
   DEFAULT
      RANGE(*) FIXED;
 %SKIP(4);
 /* PARAMETERS */
 %SKIP;
   DCL
      (METHOD,                         /* METHOD OF EVALUATING BUSIEST
                                       CYLINDERS */
      #OFDEVICES) FIXED BIN(15),       /* MAXIMUM NUMBER OF DEVICES */
      PTRTODEVARAY POINTER,            /* POINTER TO ARRAY OF DEVICE
                                       CHARACTERISTICS */
      TIME_ON_FIRST_RECORD CHAR(12);   /* CHARACTER TIME ON FIRST
                                       RECORD */
 %SKIP(4);
 /* CONSTANTS */
 %SKIP;
   DCL
      STARS CHAR(10) STATIC INIT((10)'*'),
      CRECORD# STATIC CHAR(8 ) INIT('RECORD #'),
      CFULLSTOP STATIC CHAR(3) INIT('.  '),
      LSTBLCK(3) STATIC CHAR(11) INIT ('BUFFER FULL','LOST EVENTS',
   'LOST BLOCKS'),
      RCRDSINCE STATIC CHAR(45) INIT (
   'RECORDS SINCE LAST PRINTOUT.  RESULTS VOIDED.'),
      LSTEVENTS STATIC CHAR(12) INIT('EVENTS LOST.');
   DCL
      SIGNIFICANCE STATIC FIXED BIN(15) INIT(150);/* USED TO DETERMINE
                                       WHETHER IT IS WORTHWHILE TO
                                       PRINT DATA FOR DEVICES */
 %SKIP;
   DCL
      DEVLIST(4) STATIC BIN(15) INIT(423,827,574,574);/* LIST OF
                                       HIGHEST NUMBERED CYLINDER FOR
                                       EACH DEVICE TYPE - (1) 3330,
                                       404 CYLINDERS; (2) 3330
                                       DOUBLE-DENSITY, 808 CYLINDERS;
                                       (3,4) 3350, 3350 FIXED HEAD,
                                       555 CYLINDERS. IN EACH CASE, 20
                                       EXTRA CYLINDERS ARE ALLOWED FOR
                                       SEEKS TO ALTERNATE TRACKS */
 %SKIP(4);
 /* ENTRY */
 %SKIP(2);
   DCL
      XXNWPGE ENTRY();                 /* STARTS NEW PAGE AND PUTS
                                       HEADING ON IT */
   DCL
      XXGETRM ENTRY(FIXED BIN(31),FIXED BIN(15), 1, 2 FIXED BIN(15), 2
   CHAR(8), 2 (4) BIT(8) ALIGNED, 2 BIT(16) ALIGNED, 2 FIXED BIN(15), 2
   FIXED BIN(15), 2 BIN(31) FIXED) RETURNS(BIT(1) ALIGNED);/* INPUT
                                       ROUTINE */
 %SKIP(4);
 /* EXTERNAL */
 %SKIP;
   DCL
      1 PRINTFL CTL EXT,               /* INFORMATION ABOUT CURRENT
                                       STATE OF FILE PRINT */
         2 LINES FIXED BIN(15) INIT(0), /* LINE NUMBER IN CURRENT PAGE
                                       */
         2 MAXLINES FIXED BIN(15) INIT(59), /* MAXIMUM NUMBER OF LINES
                                       PER PAGE */
         2 PAGE# FIXED DEC(3) INIT(1); /* CURRENT PAGE NUMBER */
 %SKIP(4);
 /* FILE */
 %SKIP;
   DCL
      PRINT FILE EXTERNAL STREAM PRINT;/* MAIN OUTPUT FILE */
 %SKIP(4);
 /* LOCAL VARIABLES */
 %SKIP;
   DCL
      #LOSTDATA BIN(31) INIT(0),       /* TOTAL OF LOST DATA RECORDS */
      #SIOSZERO BIN(31) INIT(0),       /* GLOBAL TOTAL SIO CC 0
                                       RECORDS */
      #SIOSONE BIN(31) INIT(0),        /* GLOBAL TOTAL SIO CC 1
                                       RECORDS */
      #SIOSTWO BIN(31) INIT(0),        /* GLOBAL TOTAL SIO CC 2
                                       RECORDS */
      #SIOSTHREE BIN(31) INIT(0),      /* GLOBAL TOTAL SIO CC 3
                                       RECORDS */
      #IOS BIN(31) INIT(0),            /* GLOBAL TOTAL IO TRACE
                                       RECORDS */
      #NOT_KNOWN BIN(31) INIT(0),      /* GLOBAL TOTAL OF RECORDS
                                       WHICH ARE NOT USED IN THIS
                                       PROGRAM */
      #BOS BIN(31) INIT(0),            /* NUMBER OF SIO SENSE RECORDS */
      #BAD BIN(31) INIT(0),            /* GLOBAL TOTAL OF RECORDS OF
                                       IO TRACE WITH UNIDENTIFIED UCB */
      #PCI BIN(31) INIT(0),            /* TOTAL OF PCI RECORDS */
      #EOS BIN(31) INIT(0),            /* TOTAL OF END OF SENSE
                                       RECORDS */
      #BYPASSED BIN(31) INIT(0);       /* TOTAL OF RECORDS FOR DEVICES
                                       THAT ARE NOT PROCESSED BECAUSE
                                       OF PROGRAM OPTIONS */
   DCL
      BASELOOP BIN(31) INIT(0),        /* TOTAL OF ALL RECORDS
                                       PROCESSED */
      MAINLOOP BIN(31) INIT(0),        /* TOTAL OF RECORDS PROCESSED
                                       SINCE LAST LOST EVENT RECORD OR
                                       BEGINNING OF JOB */
      #TIMESTAMPS BIN(31) INIT(0);     /* NUMBER OF TIMESTAMP RECORDS */
   DCL
      DEVICE_POINTERS(20) POINTER,     /* LIST OF POINTERS FOR
                                       DEVICE_DATA, ONE FOR EACH
                                       DEVICE */
      DEVICE_ADDRESSES(20) BIN(15),    /* LIST OF DEVICE ADDRESSES FOR
                                       WHICH WE HAVE INFORMATION */
      ALTERNATE_PATH_ADDRESSES(20) BIN(15), /* LIST OF ALTERNATE PATH
                                       ADDRESSES, FOR THOSE WHICH HAVE
                                       BEEN MET */
      NO_DEVICES BIN(15) INIT(0),      /* NUMBER OF DEVICES CURRENTLY
                                       FOUND */
      CURRPTR POINTER;                 /* POINTER TO DEVICE_DATA
                                       CURRENTLY UNDER CONSIDERATION */
   DCL
      RCRDTIME BIN(31),                /* RELATIVE TIME OF THIS RECORD
                                       */
      RCRDTYPE BIN(15),                /*RETURNS TYPE OF RECORD: (1)
                                       TIMESTAMP, (2) LOST BLOCK LOST
                                       EVENT BUFFER FULL RECORDS, (3)
                                       START IO TRACE RECORD, (4) IO
                                       TRACE RECORD, (5) UNDEFINED OR
                                       UNSUPPORTED RECORD, (6) IO
                                       TRACE RECORD WITHOUT A VALID
                                       UCB, (7) PCI TRACE RECORD, (8)
                                       END OF SENSE TRACE RECORD. OF
                                       THESE (1-4) CAUSE ACTIVE
                                       PROCESSING, (5-8) MERELY
                                       INCREMENT COUNTERS*/
      1 RCRDINFO,                      /*INFORMATION ABOUT THE RECORD*/
         2 SUB_TYPE BIN(15),           /*RECORD SUB-TYPE: USED FOR
                                       LOST BLOCK &C RECORDS: (1)
                                       BUFFER FULL, (2) LOST EVENT(S),
                                       (3) LOST BLOCK(S)*/
         2 JOB_NAME CHAR(8),           /*JOB NAME FIELD ON THOSE
                                       RECORDS WHICH HAVE IT*/
         2 FLAGS(4) BIT(8) ALIGNED,    /*FLAGS - USED FOR TOPTIONS
                                       FIELD OF TIMESTAMP RECORD,
                                       G_FLAGS(1) IS USED FOR SIO
                                       CONDITION CODES, (SEE SIO_TRACE
                                       DECLARATION)*/
         2 FLAGS16 BIT(16) ALIGNED,    /*USED TO RETURN STATUS FROM
                                       SIO RECORDS FOR DETERMINING THE
                                       REASONS FOR SIO CC1*/
         2 DEVICE_ADDRESS BIN(15),     /*DEVICE ADDRESS*/
         2 SEEK_ADDRESS BIN(15),       /*SEEK ADDRESS*/
         2 LOST_COUNT BIN(31);         /*LOST EVENT COUNT FOR LOST
                                       BLOCK &C RECORDS*/
   DCL
      PBUFF CHAR(132) INIT(''),
      RECORD#ED PIC'ZZZZZ9' DEFINED PBUFF POS(20),
      #RECORDSED PIC 'ZZZ9' DEFINED PBUFF POS(70),
      #LOST_EVENTSED PIC'ZZZZ9' DEFINED PBUFF POS(29);
   DCL
      NUMBER BIN(15);                  /* USED AS AN INDEX TO
                                       DEVICE_ADDRESSES */
   DCL
      TEMPBYTE BIT(8) ALIGNED;         /* TEMPORARY TO EXTRACT
                                       CONDITION CODE OF SIOS */
   DCL
      (LATEST,                         /* LATEST RELATIVE TIME FOUND
                                       ON A RECORD */
      EARLIEST) BIN(31) INIT(0);       /* EARLIEST TIME FOUND ON A
                                       RECORD */
   DCL
      BIG_AREA AREA(*) CTL;            /* AREA IN WHICH ALL DEVICE
                                       ALLOCATIONS ARE MADE */
 %PAGE;
 /* BASED VARIABLE TEMPLATES */
 %SKIP;
   DCL
      1 DEVICE_DATA BASED(CURRPTR),    /* INFORMATION ABOUT THE
                                       ACTIVITY OF ONE DEVICE */
         2 DEVICE_TYPE BIN(15) INIT(0), /* DEVICE TYPE - (1) 3330, (2)
                                       3330-II, (3) 3350, (4) 3350-FH
                                       (FIXED HEAD ON CYLINDERS 1 & 2)
                                       */
         2 MAX_SEEK BIN(15) INIT(0),   /* LARGEST NUMBER OF CYLINDERS
                                       TRAVERSED IN ONE SEEK */
         2 TOT_SEEK BIN(31) INIT(0),   /* TOTAL NUMBER OF CYLINDERS
                                       SEEKED ACROSS */
         2 DUMMY_SEEK BIN(31) INIT(0), /* NUMBER OF DUMMY SEEKS MADE
                                       TO CYLINDERS 1 & 2 ON A 3350
                                       FIXED HEAD DEVICE */
         2 #SIOS_0 BIN(31) INIT(0),    /* NUMBER OF SIOS CC 0 ISSUED
                                       TO THIS DEVICE */
         2 #SIOS_1 BIN(31) INIT(0),    /* NUMBER OF SIOS CC 1 ISSUED
                                       TO THIS DEVICE */
         2 #SIOS_2 BIN(31) INIT(0),    /* NUMBER OF SIOS CC 2 ISSUED
                                       TO THIS DEVICE */
         2 #SIOS_3 BIN(31) INIT(0),    /* NUMBER OF SIOS CC 3 ISSUED
                                       TO THIS DEVICE */
         2 #EVENTS_MAIN BIN(31) INIT(0), /* NUMBER OF EVENTS WHEN THIS
                                       DEVICE IS ADDRESSED USING ITS
                                       MAIN PATH */
         2 #EVENTS_ALTERNATE BIN(31) INIT(0), /* NUMBER OF EVENTS WHEN
                                       THIS DEVICE IS ADDRESSED USING
                                       ITS ALTERNATE PATH */
         2 REASONS(6) BIT(16) ALIGNED INIT((6)(16)'0'B), /* REASONS
                                       RETURNED WHEN SIO CC 1 OCCURS */
         2 #REASONS(6) BIN(15) INIT((6)0), /* NUMBER OF TIMES EACH
                                       REASON OCCURS */
         2 DOESNT_COUNT BIN(31) INIT(0), /* NUMBER OF TIMES A SIO CC 1
                                       IS ISSUED TO A DEVICE IN
                                       SUCCESSION OF A SIO CC 1 IS
                                       ISSUED WHEN THERE IS A WRAP
                                       AROUND OF GTF SO THAT NO END
                                       TIME IS RECORDED AND SO THIS
                                       CANNOT COUNT TOWARDS COMPUTING
                                       THE AVERAGE DEFER TIME */
         2 #SIOS_NOT_FINISHED BIN(31) INIT(0), /* THIS IS THE SAME FOR
                                       DOESNT_COUNT AS REGARDS WRAP
                                       ROUND FOR SIO CC 0 RECORDS */
         2 TOT_DEFR BIN(31) INIT(0),   /* TOTAL DEFERRED TIME IE TIME
                                       BETWEEN SIO CC 1 OCCURRING AND
                                       INTERRUPT FOR THAT DEVICE */
         2 MAX_DEFR BIN(31) INIT(0),   /* MAXIMUM INDIVIDUAL DEFERRED
                                       TIME */
         2 MAX_TIME BIN(31) INIT(0),   /* MAXIMUM INDIVIDUAL IO TIME */
         2 TOT_TIME BIN(31) INIT(0),   /* TOTAL IO TIME */
         2 LASTIME BIN(31) INIT(0),    /* RELATIVE TIME OF LAST EVENT
                                       FOR THIS DEVICE */
         2 LAST_SEEK BIN(15) INIT(-1), /* LAST SEEK CYLINDER FOR THIS
                                       DEVICE */
         2 NOINVALSK BIN(15) INIT(0),  /* NUMBER OF SEEKS TO
                                       NON-EXISTENT CYLINDERS */
         2 LAST_EVENT BIN(15) INIT(0), /* LAST EVENT TO HAPPEN TO THIS
                                       DEVICE */
         2 #CYLINDERS BIN(15) INIT(0), /* INDEX OF HIGHEST CYLINDER
                                       NUMBER USED FOR THIS DEVICE
                                       PLUS 20 FOR ALTERNATE TRACKS
                                       ETC */
         2 LAST_USED BIN(15) INIT(0),  /* INDEX OF LAST USED MEMBER OF
                                       TO_ARRAY */
         2 FROM(0:827) BIN(15) INIT((828) -1), /* INDICES TO BEGINNING
                                       OF ROW CHAINS IN SPARSE MATRIX */
         2 TO_ARRAY(10000),            /* ENTRIES IN SPARSE MATRIX */
            3 TO_CYLINDER# BIN(15) INIT((10000)0), /* COLUMN INDEX OF
                                       ENTRY */
            3 TO_VALUE BIN(15) INIT((10000)0), /* VALUE OF ENTRY */
            3 NEXT_CYLINDER BIN(15) INIT((10000)-1);/* INDEX OF NEXT
                                       ITEM IN THE CHAIN IN TO_ARRAY */
 %SKIP;
   DCL
      DEVICE_INFO(0:4095) BIN(15) BASED(PTRTODEVARAY);/* INFORMATION
                                       ON DEVICE TYPES AND ALTERNATE
                                       PATH ADDRESSES */
 %SKIP(4);
 /* BUILT IN FUNCTIONS */
 %SKIP;
   DCL
      (ABS,
      NULL,
      MAX,
      MIN,
      MOD,
      SUBSTR,
      UNSPEC) BUILTIN;
 %SKIP(4);
 /* PRELIMINARIES */
 %SKIP(2);
      ALLOCATE BIG_AREA AREA(#OFDEVICES*65000);/* ALLOW 65,000 BYTES
                                       PER DEVICE */
      ON AREA
         GOTO BAD_END;                 /* JUST IN CASE OF AN OVERFLOW */
 %PAGE;
 /**************************************************************/
 /*  MAIN PROCESSING LOOP.  THIS LOOP IS EXECUTED ONCE PER     */
 /*  INPUT RECORD UNTIL END OF FILE.                           */
 /**************************************************************/
 %SKIP(2);
 RECORD_PROCESS:
      DO MAINLOOP = 1 BY 1;            /*LOOP VARIABLE USED AS COUNTER
                                       OF NUMBER OF RECORDS IN BLOCK. */
         IF XXGETRM(RCRDTIME,RCRDTYPE,RCRDINFO) THEN
            DO;                        /* EOF REACHED ON INPUT FILE */
               CALL END_OF_FILE;
               RETURN;                 /*TO XXDEVM */
            END;
 %SKIP(2);
         SELECT(RCRDTYPE);
            WHEN(1)
               DO;                     /*TIMESTAMP RECORD PROCESSING.
                                       OPTIONS SELECTED ARE RETURNED
                                       IN FLAG8, SO A CHECK ROUTINE
                                       COULD VERIFY SENSIBLE OPTIONS
                                       IN FORCE */
                  #TIMESTAMPS=#TIMESTAMPS+1;
               END;
 %PAGE;
            WHEN(2)
               DO;                     /* LOST DATA RECORD PROCESSING
                                       - ASSEMBLE MESSAGE GIVING THE
                                       REASON AND THE NUMBER OF
                                       RECORDS LOST */
                  PBUFF=STARS;
                  SUBSTR(PBUFF,12,8)=CRECORD#;
                  RECORD#ED= BASELOOP+ MAINLOOP;
                  SUBSTR(PBUFF,26,3)=CFULLSTOP;
                  #LOST_EVENTSED=LOST_COUNT;
                  SUBSTR(PBUFF,35,12)= LSTEVENTS;
                  SUBSTR(PBUFF,49,11)= LSTBLCK(SUB_TYPE);
                  #RECORDSED=MAINLOOP;
                  SUBSTR(PBUFF,75,45)=RCRDSINCE;
                  IF LINES > MAXLINES-2 THEN
                     CALL XXNWPGE;     /* ENSURE ENOUGH SPACE ON THE
                                       PAGE */
                  LINES=LINES+2;       /* ADD LINES USED TO THE TOTAL
                                       FOR THIS PAGE */
                  PUT FILE(PRINT) EDIT(PBUFF) ( SKIP(2),A(132));/*
                                       OUTPUT ASSEMBLED MESSAGE */
                  IF MAINLOOP > SIGNIFICANCE THEN
                     CALL PRINTOUT;    /* IF ENOUGH RECORDS THEN PRINT
                                       RESULTS */
                  CALL CLEARIT;        /*CLEAR ACCUMULATED INFO. */
                  BASELOOP=BASELOOP+MAINLOOP;/*ADD NO OF RECORDS IN
                                       THIS BLOCK TO TOTAL */
                  MAINLOOP=0;          /* SET NUMBER OF RECORDS IN NEW
                                       BLOCK TO ZERO */
                  #LOSTDATA=#LOSTDATA+1;/* COUNT OF NUMBER OF LOST
                                       DATA RECORDS */
                  LINES=LINES+2;       /* HAVE USED 2 LINES IN
                                       PRINTING MESSAGE */
               END;
 %PAGE;
            WHEN(3)
               DO;                     /* START IO RECORD PROCESSING.
                                       FIRST UPDATE GLOBAL COUNT
                                       ACCORDING TO CONDITION CODE
                                       RETURNED. (THIS IS RETURNED AS
                                       BITS 3 AND 4 OF FLAGS(1). THEN
                                       CHECK WHETHER THIS DEVICE CAN
                                       BE HANDLED. IF NOT, THEN IGNORE
                                       RECORD. OTHERWISE PROCESS IT */
                  TEMPBYTE=FLAGS(1) & '00110000'B;/* SORT OUT BITS
                                       REQUIRED */
                  SELECT(TEMPBYTE);
                     WHEN ('00000000'B)
                        #SIOSZERO=#SIOSZERO+1;/* CONDITION CODE 0 */
                     WHEN ('00010000'B)
                        #SIOSONE=#SIOSONE+1;/* CONDITION CODE 1 */
                     WHEN ('00100000'B)
                        #SIOSTWO=#SIOSTWO+1;/* CONDITION CODE 2 */
                     WHEN ('00110000'B)
                        #SIOSTHREE=#SIOSTHREE+1;/* CONDITION CODE 3 */
                  END;
                  IF FIND(DEVICE_ADDRESS,NUMBER) THEN
                     GOTO NEXT_RECORD;
                  ;                    /* OTHERWISE WE'RE OK SO SORT
                                       OUT CONDITION CODE RETURNED -
                                       FLAGS(1) CONTAINS BYTE WITH
                                       THAT FIELD IN IT. */
                  IF NUMBER < 0 THEN
                     DO;               /*IF NUMBER < 0 THEN THIS IS
                                       THE FIRST RECORD SEEN FOR THE
                                       DEVICE. */
                        SELECT(TEMPBYTE);/*SELECT ACTION ACCORDING TO
                                       CONDITION CODE RETURNED BY SIO */
                           WHEN('00000000'B)
                              DO;      /*CONDITION CODE 0*/
                                 #SIOS_0=#SIOS_0+1;/*TOTAL FOR THIS
                                       DEVICE.*/
                                 LAST_EVENT=1;/*SET LAST EVENT MARKER */
                                 LASTIME=RCRDTIME;/*SET TIME SIO
                                       STARTED. */
                                 CALL PROCESS_SEEK;/* TAKE CARE OF
                                       SEEK ADDRESSES */
                              END;
                           WHEN('00010000'B)
                              DO;      /*CONDITION CODE1*/
                                 #SIOS_1=#SIOS_1+1;/*TOTAL FOR THIS
                                       DEVICE */
                                 LAST_EVENT=2;/*SET LAST EVENT MARKER.
                                       */
                                 LASTIME=RCRDTIME;/*SET TIME SIO
                                       STARTED. */
                                 CALL DEFER_PROC('1'B);
                              END;
                           WHEN('00100000'B)
                              DO;      /*CONDITION CODE 2*/
                                 #SIOS_2=#SIOS_2+1;/*TOTAL FOR THIS
                                       DEVICE. */
                                 LAST_EVENT=3;/*SET LAST EVENT MARKER.
                                       */
                                 LASTIME=RCRDTIME;/*SET TIME OF EVENT.
                                       */
                              END;
                           WHEN('00110000'B)
                              DO;      /* CONDITION CODE 3 */
                                 #SIOS_3=#SIOS_3+1;/*TOTAL FOR THIS
                                       DEVICE*/
                                 LAST_EVENT=4;/*EVENT TYPE MARKER.   */
                              END;
                        END;
                     END;              /*OF ACTIONS FOR NEW DEVICE*/
 %PAGE;
                  ELSE
                     DO;               /* WE'VE BEEN AT THIS DEVICE
                                       BEFORE. SELECT ACTION ACCORDING
                                       TO CONDITION CODE AND LAST
                                       EVENT FOR THIS DEVICE */
                        SELECT(TEMPBYTE);
                           WHEN('00000000'B)
                              DO;      /*CONDITION CODE 0*/
                                 #SIOS_0=#SIOS_0+1;/*DEVICE TOTALS. */
                                 SELECT(LAST_EVENT);
                                    WHEN(1)
                                       DO;/* LAST EVENT WAS SIOS 0. SO
                                       IS THIS ONE. ACTION: UPDATE IO
                                       TIME TO REFLECT THAT LAST IO
                                       HAS FINISHED AND SET UP THIS
                                       ONE. */
                                       CALL SIOEND('1'B);
                                       END;
                                    WHEN(2)
                                       DO;/*LAST EVENT WAS SIO 1. THIS
                                       IS END OF DEFER TIME SO UPDATE
                                       RECORD */
                                       CALL DEFER_PROC('1'B);
                                       END;
                                    OTHERWISE
                                       IF LASTIME > RCRDTIME THEN
                                       CALL BREAK_IN_TIME;/*
                                       WRAP-AROUND HAS OCCURRED. RESET
                                       DEVICE DATA */
                                 END;  /*OF SELECT ACCORDING TO LAST
                                       EVENT. */
                                 CALL PROCESS_SEEK;/*SORT OUT SEEK
                                       ADDRESS. */
                                 LASTIME=RCRDTIME;/*TIME ON RECORD. */
                                 LAST_EVENT=1;/*SET LAST EVENT MARKER.
                                       */
                              END;
                           WHEN('00010000'B)
                              DO;      /* SIO CONDITION CODE 1 */
                                 #SIOS_1=#SIOS_1+1;/* TOTAL FOR THIS
                                       DEVICE */
                                 SELECT(LAST_EVENT);/* SELECT
                                       ACCORDING TO THE LAST EVENT FOR
                                       THIS DEVICE */
                                    WHEN(1)
                                       DO;/* LAST EVENT WAS SIO
                                       CONDITION 0. TERMINATE LAST I/O
                                       AND SET UP START OF DEFER IO */
                                       CALL SIOEND('1'B);
                                       CALL STATUS_PROCESS;
                                       LAST_EVENT=2;
                                       LASTIME=RCRDTIME;
                                       END;
                                    WHEN(2)
                                       DO;/* LAST EVENT WAS SIO CC 1,
                                       SO IS THIS ONE. THEREFORE STILL
                                       WAITING. INCREMENT DOESNT_COUNT
                                       */
                                       DOESNT_COUNT=
                                       DOESNT_COUNT+1;
                                       CALL STATUS_PROCESS;/*
                                       NEVERTHELESS COUNT THE REASON */
                                       END;
                                    WHEN(3,4,5)
                                       DO;/* LAST EVENT WAS SIO CC2,
                                       SIO CC 3, IO: START DEFERRED
                                       TIME PROCESSING */
                                       CALL STATUS_PROCESS;
                                       LAST_EVENT=2;
                                       LASTIME=RCRDTIME;
                                       END;
                                 END;
                              END;
                           WHEN('00100000'B,'00110000'B)
                              DO;      /*SIO CONDITION CODES 2, 3 */
                                 SELECT(LAST_EVENT);/* SELECT ON LAST
                                       EVENT FOR THIS DEVICE */
                                    WHEN(1)
                                       CALL SIOEND('1'B);/* LAST EVENT
                                       WAS SIO CC 0. OPERATION HAS NOW
                                       FINISHED */
                                    WHEN(2)
                                       CALL DEFER_PROC('1'B);/* LAST
                                       EVENT WAS SIO CC 1. DEVICE IS
                                       NOW NOT NECESSARILY BUSY SO
                                       GIVE IT THE BENEFIT OF THE
                                       DOUBT */
                                    OTHER
                                       ;/* OTHERWISE OK DO NOTHING */
                                 END;
                                 SELECT(TEMPBYTE);
                                    WHEN('00100000'B)
                                       DO;/* SPECIFIC PROCESSING FOR
                                       SIO CC 2 */
                                       #SIOS_2=#SIOS_2+1;/* LOCAL
                                       TOTAL */
                                       LAST_EVENT=3;
                                       END;
                                    WHEN('00110000'B)
                                       DO;/* SPECIFIC PROCESSING FOR
                                       SIO CC 3 */
                                       #SIOS_3=#SIOS_3+1;/* LOCAL
                                       TOTAL */
                                       LAST_EVENT=4;
                                       END;
                                 END;
                              END;
                        END;
                     END;
               END;
 %PAGE;
            WHEN(4)
               DO;                     /* IO RECORD PROCESSING */
                  #IOS=#IOS+1;         /* GLOBAL TOTAL OF IO RECORDS */
                  IF FIND(DEVICE_ADDRESS,NUMBER) THEN
                     GOTO NEXT_RECORD; /* IF FIND RETURNS '1'B THEN
                                       THERE IS NO ROOM FOR THIS
                                       DEVICE SO SKIP IT */
                  IF NUMBER < 0 THEN
                     ;                 /* NEW DEVICE - NOT INTERESTED
                                       UNTIL WE'VE SEEN AN SIO */
                  ELSE
                     DO;               /* WE'VE SEEN IT BEFORE */
                        SELECT(LAST_EVENT);/* ACTION CHOSEN ACCORDING
                                       TO WHAT HAPPENED LAST */
                           WHEN(1)
                              CALL SIOEND('1'B);/* LAST EVENT WAS SIO
                                       CC0. THIS ENDS IT */
                           WHEN(2)
                              CALL DEFER_PROC('1'B);/* LAST EVENT WAS
                                       SIO CC1. THIS ENDS DEFERRED
                                       TIME */
                           OTHER
                              ;        /* OTHERWISE DON'T NEED TO DO
                                       ANYTHING */
                        END;
                        LAST_EVENT=5;  /* SET LAST EVENT MARKER */
                     END;
               END;                    /*OF IO TRACE RECORD PROCESSING
                                       */
 %PAGE;
            WHEN(5)
               DO;                     /* UNDEFINED OR UNSUPPORTED
                                       RECORD TYPE */
                  #NOT_KNOWN=#NOT_KNOWN+1;
               END;
 %SKIP(4);
            WHEN(6)
               #BAD=#BAD+1;            /* IO TRACE RECORD WITHOUT
                                       VALID UCB */
 %SKIP(4);
            WHEN(7)
               #PCI=#PCI+1;            /* PCI TRACE RECORD */
 %SKIP(4);
            WHEN(8)
               #EOS=#EOS+1;            /* END OF SENSE TRACE RECORD */
 %SKIP(4);
            WHEN (9)
               #BOS=#BOS+1;            /* COUNT OF SIO SENSE RECORDS
                                       (SIO CC 0 WITH SEEK ADDRESS OF
                                       CYLINDER 0 HEAD 0 */
 %SKIP(2);
         END;                          /* OF SELECT GROUP */
 %SKIP(4);
         GOTO LOOP_IT;
 NEXT_RECORD:
         #BYPASSED=#BYPASSED+1;        /* RECORDS FOR DEVICES NOT
                                       HANDLED BECAUSE OF LACK OF
                                       SPACE */
 %SKIP(4);
 LOOP_IT:
         IF RCRDTYPE ^= 5 THEN
            DO;                        /* UPDATE EARLIEST AND LATEST
                                       TIMES */
               EARLIEST=MIN(EARLIEST,RCRDTIME);
               LATEST=MAX(LATEST,RCRDTIME);
            END;
      END;                             /*OF DO_LOOP */
 %PAGE;
 BAD_END: /* RUN OUT OF SPACE */
      IF LINES+6 > MAXLINES THEN
         CALL XXNWPGE;                 /* ENOUGH SPACE ON PAGE? */
      PUT FILE(PRINT)
      EDIT( '***** INSUFFICIENT SPACE - AREA CONDITION RAISED *****',
       '***** JOB TERMINATED *****') (SKIP(2), A(56), SKIP(2), A(30));
      RETURN;                          /* TO XXDEVMN */
 %PAGE;
 DEFER_PROC: /*PROCESS DEFERRED I/O TIMES*/
   PROC(SETMAX) REORDER;
 %SKIP(2);
 /****************************************************************/
 /*  DEFER_PROC PROCESSES DEFERRED I/O TIMES IE SIO CC1 WHEN     */
 /*  UNIT IS BUSY.  DEFERRED TIME LASTS FROM TIME SIO IS ISSUED  */
 /*  UNTIL SIO CC 0 IS ISSUED OR   I/O INTERRUPT IS RECEIVED FOR */
 /*  DEVICE.  HOWEVER MAX DEFERRED TIME IS LIMITED BY            */
 /*  MAX_DEFER_ALLOWED, AND SETMAX AS TO WHETHER  MAX_DEFR IS    */
 /*  UPDATED AND THE AMOUNT BY WHICH TOT_DEFR IS INCREMENTED.    */
 /****************************************************************/
 %SKIP(2);
 /*PARAMETERS*/
   DCL
      SETMAX BIT(1) ALIGNED;
 /*SETMAX      IF SETMAX IS '1'B, THE ROUTLNE IS ALLOWED TO    */
 /*            UPDATE MAX_DEFR.  (READ)                        */
 %SKIP(2);
 /*CONSTANTS*/
   DCL
      MAX_DEFER_ALLOWED STATIC BIN(31) INIT(20000);
 /*MAX_DEFER_ALLOWED   MAXIMUM TIME DEFERRED IS ALLOWED TO     */
 /*            LAST IN MILLISECONDS *10.  HERE 2 SECONDS.      */
 %SKIP(2);
 /*LOCAL VARIABLES*/
   DCL
      DEFERINT FIXED BIN(31);
 /*DEFERINT    TEMPORARY USED TO HOLD DEFERRED TIME.           */
 %SKIP(2);
      DEFERINT=RCRDTIME-LASTIME;       /*EVALUATE DEFERRED TIME */
      IF DEFERINT < 0 THEN
         DO;                           /* WRAP AROUND HAS OCCURRED */
            CALL BREAK_IN_TIME;
            RETURN;
         END;
      IF DEFERINT < MAX_DEFER_ALLOWED
      /*IS IT LESS THAN MAX ALLOWED?  */THEN
 /*IF SO AND SETMAX = '1'B THEN  */
         IF SETMAX /*UPDATE MAX_DEFR.              */THEN
            MAX_DEFR=MAX(MAX_DEFR,DEFERINT);
         ELSE
            ;
      ELSE
         DEFERINT=MAX_DEFER_ALLOWED;   /*OTHERWISE SET EQUAL BEFORE */
      TOT_DEFR=TOT_DEFR+DEFERINT;      /*UPDATING TOT_DEFR. */
      RETURN;
   END;                                /*OF DEFER_PROC*/
 %PAGE;
 FIND: /*FIND DEVICE DATA AND ALLOCATE IF NONE*/
   PROC(DADDRESS,NUMBER) REORDER RETURNS(BIT(1) ALIGNED);
 %SKIP(3);
 /****************************************************************/
 /*  FIND CHECKS LIST OF DEVICES ALLOCATED AND TRIES TO ALLOCATE */
 /*  A NEW ONE IF IT CAN'T FIND IT.                              */
 /****************************************************************/
 %SKIP(3);
 /*PARAMETERS*/
 %SKIP(1);
   DCL
      DADDRESS FIXED BINARY(15),       /* INPUT ADDRESS */
      NUMBER FIXED BINARY(15);         /* RETURNS INDEX OF THIS DEVICE
                                       IN DEVICE_ADDRESSES */
 %SKIP(3);
 /*LOCAL VARIABLES*/
 %SKIP(1);
   DCL
      LOOPF FIXED BIN(15);             /* LOOP COUNTER */
   DCL
      ALTTEMP BIN(15);                 /* USED IN CALCULATING
                                       ALTERNATE PATH ADDRESS SHOULD
                                       THERE BE ONE */
   DCL
      TEMPBIN BIN(15) INIT(DADDRESS);  /* TEMPBIN IS USED AS A
                                       TEMPORARY TO EVALUATE ALTERNATE
                                       PATH ADDRESS*/
   DCL
      FOUND_ON_MAIN BIT(1) ALIGNED INIT('0'B);/* FLAG AS TOINDICATE
                                       WHETHER THE DEVICE WAS
                                       ADDRESSED THROUGH ITS MAIN PATH
                                       OR THROUGH ITS ALTERNATE PATH */
   DCL
      TYPE BIN(15);                    /* TEMPORARY TO HOLD DEVICE
                                       TYPE */
   DCL
      TEMPORARY BIN(15);               /* TEMPORARY */
 %SKIP(2);
      DO LOOPF = 1 TO NO_DEVICES;
         IF DEVICE_ADDRESSES(LOOPF) = TEMPBIN THEN
            DO;                        /* FOUND ADDRESS AS THAT OF A
                                       MAIN PATH */
               NUMBER=LOOPF;
               CURRPTR=DEVICE_POINTERS(LOOPF);
               #EVENTS_MAIN=#EVENTS_MAIN+1;/* INCREMENT COUNTER OF
                                       EVENTS ON MAIN PATH */
               RETURN('0'B);           /* PROCESS DATA FOR THIS DEVICE
                                       */
            END;
         IF ALTERNATE_PATH_ADDRESSES(LOOPF) = TEMPBIN THEN
            DO;
               NUMBER=LOOPF;
               CURRPTR=DEVICE_POINTERS(LOOPF);
               #EVENTS_ALTERNATE=#EVENTS_ALTERNATE+1;/* INCREMENT
                                       NUMBER OF EVENTS ON ALTERNATE
                                       PATH */
               RETURN('0'B);           /* OK TO PROCESS DATA IN THIS
                                       RECORD */
            END;
      END;
 %SKIP(2);
      ;                                /* ELSE WE HAVEN'T FOUND IT */
      TYPE=DEVICE_INFO(TEMPBIN);       /* GET DEVICE-TYPE FROM TABLE */
      SELECT;
         WHEN(TYPE < 0)
            DO;                        /* DEVICE IS BEING ADDRESSED
                                       THROUGH AN ALTERNATE PATH.
                                       FIRST SEE IF WE HAVE SEEN THE
                                       MAIN PATH YET */
               ALTTEMP=-TYPE;          /* MAIN PATH ADDRESS */
               DO LOOPF = 1 TO NO_DEVICES;
                  IF DEVICE_ADDRESSES(LOOPF) = ALTTEMP THEN
                     DO;               /* FOUND IT */
                        NUMBER=LOOPF;  /* INDEX IN ARRAY */
                        ALTERNATE_PATH_ADDRESSES(
                        LOOPF)=TEMPBIN;/* SET UP ALTERNATE PATH TABLE
                                       SO THAT IT WILL BE FOUND NEXT
                                       TIME IN THE FIRST LOOP */
                        CURRPTR=DEVICE_POINTERS(LOOPF);/* SET UP
                                       ADDRESSING OF DEVICE DATA */
                        #EVENTS_ALTERNATE=#EVENTS_ALTERNATE+1;/* EVENT
                                       ON ALTERNATE PATH */
                        RETURN('0'B);  /* FOUND THE DEVICE AND IT IS
                                       ELIGIBLE FOR PROCESSING */
                     END;
               END;
               ;                       /* OTHERWISE THIS DEVICE IS NEW
                                       */
               TYPE=DEVICE_INFO(ALTTEMP);/* GET TYPE OF MAIN PATH
                                       DEVICE */
               IF ((TYPE<=0)×(TYPE>4)) THEN
                  RETURN('1'B);        /* EITHER DEVICE IS NOT DIRECT
                                       ACCESS, IN WHICH CASE WE'RE NOT
                                       INTERESTED IN IT, OR THE
                                       ALTERNATE PATH REFERS TO
                                       ANOTHER ALTERNATE PATH, WHICH
                                       IS AN ERROR. EITHER WAY, DO NOT
                                       PROCESS RECORDS FOR THIS DEVICE
                                       */
               TEMPORARY=ALTTEMP;      /* ALTTEMP CONTAINS THE MAIN
                                       PATH ADDRESS, TEMPBIN CONTAINS
                                       THE ALTERNATE PATH ADDRESS,
                                       CHANGE THEM ROUND */
               ALTTEMP=TEMPBIN;
               TEMPBIN=TEMPORARY;
               FOUND_ON_MAIN='0'B;     /* THE DEVICE WAS NOT ADDRESSED
                                       BY ITS MAIN PATH */
            END;
         WHEN((TYPE > 0)&(TYPE <= 4))
            DO;                        /* DEVICE TYPE IS VALID */
               ALTTEMP=-1;             /* SET THE ALTERNATE PATH
                                       ADDRESS TO AN INVALID VALUE, SO
                                       THAT IN A SEARCH, THIS DEVICE
                                       WILL NOT BE FOUND SPURIOUSLY */
               FOUND_ON_MAIN='1'B;     /* ADDRESSED THROUGH MAIN PATH */
            END;
         OTHER
            RETURN('1'B);              /* OTHERWISE DEVICE TYPE IS NOT
                                       VALID FOR THIS PROGRAM */
      END;
 %SKIP(3);
      ;                                /* OK - NEW DEVICE */
      IF NO_DEVICES = #OFDEVICES THEN
         RETURN('1'B);                 /* TOO MANY SO DISCARD */
      NO_DEVICES=NO_DEVICES+1;
      ALLOCATE DEVICE_DATA IN(BIG_AREA);/* ALLOCATE DATA FOR A NEW
                                       DEVICE */
      DEVICE_POINTERS(NO_DEVICES)=CURRPTR;/* PUT ITS ADDRESS IN THE
                                       ARRAY */
      DEVICE_ADDRESSES(NO_DEVICES)=TEMPBIN;/* MAIN PATH ADDRESS IN THE
                                       ARRAY FOR LOOKING UP NEXT TIME */
      ALTERNATE_PATH_ADDRESSES(NO_DEVICES)=ALTTEMP;/* ALTERNATE PATH
                                       ADDRESS, OR -1 IF WE DON'T KNOW
                                       IT YET */
      IF FOUND_ON_MAIN THEN
         #EVENTS_MAIN=1;               /* ADDRESSED THROUGH MAIN PATH */
      ELSE
         #EVENTS_ALTERNATE=1;          /* ADDRESSED THROUGH ALTERNATE
                                       PATH */
      NUMBER=-NO_DEVICES;              /* INDEX IN ARRAY - NEGATIVE TO
                                       INDICATE THAT THIS RECORD IS
                                       FOR A NEW DEVICE */
      DEVICE_TYPE=TYPE;                /* FILL IN DEVICE TYPE IN
                                       DEVICE_DATA */
      #CYLINDERS=DEVLIST(TYPE);        /* SET NUMBER OF CYLINDERS */
      RETURN('0'B);                    /* OK TO PROCESS THIS DEVICE */
   END;                                /* OF FIND */
 %PAGE;
 PROCESS_SEEK: /*PROCESS SEEK ADDRESSES*/
   PROC REORDER;
 %SKIP(2);
 /****************************************************************/
 /*  PROCESS_SEEK EVALUATES THE NUMBER OF CYLINDERS SEEKED       */
 /*  ACROSS AND UPDATES THE FROM_TO MATRIX.                      */
 /****************************************************************/
 %SKIP(2);
 /*LOCAL VARIABLES*/
   DCL
      #CYLSCROSSED FIXED BIN(15);      /* TEMPORARY OF NUMBER OF
                                       CYLINDERS TRAVERSED IN THIS
                                       SEEK */
   DCL
      LAST_INDEX BIN(15);              /* TEMPORARY TO HOLD INDEX OF
                                       LAST MEMBER OF TO LOOKED AT */
   DCL
      CURRENT_INDEX BIN(15);           /* TEMPORARY TO HOLD INDEX OF
                                       CURRENT MEMBER OF TO BEING
                                       LOOKED AT */
      IF (SEEK_ADDRESS < 0)×(SEEK_ADDRESS > #CYLINDERS) THEN
         NOINVALSK=NOINVALSK+1;        /*SEEK TO AN INVALID CYLINDER
                                       ADDRESS. UPDATE COUNTER BUT
                                       OTHERWISE IGNORE*/
      ELSE
         IF (DEVICE_TYPE=4)&((SEEK_ADDRESS=1)×(SEEK_ADDRESS=2)) THEN
            DO;                        /*SEEK TO TRACK UNDER A FIXED
                                       HEAD ON A 3350-FH DEVICE. NO
                                       ACTUAL HEAD MOVEMENT TAKES
                                       PLACE */
               DUMMY_SEEK=DUMMY_SEEK+1;
            END;
         ELSE
            DO;                        /*VALID SEEK TO A TRACK ON A
                                       NON-FIXED HEAD*/
               IF LAST_SEEK >= 0 THEN
                  DO;                  /* IF LAST_SEEK>=0 THEN THERE
                                       HAVE BEEN SEEKS ON THIS DEVICE
                                       BEFORE. SEARCH FOR CORRECT
                                       ARRAY ELEMENT TO INCREMENT*/
                     LAST_INDEX=-1;    /* TEMPORARY INDEX ONE BEHIND
                                       CURRENT_INDEX IN CHAIN */
                     CURRENT_INDEX=FROM(LAST_SEEK);/* SET
                                       CURRENT_INDEX TO HEAD OF THE
                                       CHAIN */
                     DO WHILE(CURRENT_INDEX ^= -1);/* CHAIN ALONG ROW
                                       LOOKING FOR THE MATCHING ENTRY */
                        IF TO_CYLINDER#(CURRENT_INDEX) = SEEK_ADDRESS
                        THEN
                           GOTO SEEKFOUND;/* FOUND IT */
                        IF TO_CYLINDER#(CURRENT_INDEX) > SEEK_ADDRESS
                        THEN
                           LEAVE;      /* NOT IN CHAIN - ELEMENTS ARE
                                       ORDERED IN INCREASING SEQUENCE */
                        LAST_INDEX=CURRENT_INDEX;/* SAVE VALUE OF
                                       CURRENT_INDEX */
                        CURRENT_INDEX=
                        NEXT_CYLINDER(CURRENT_INDEX);/* CHAIN IT DOWN */
                     END;
                     ;                 /* IF CONTROL FALLS OUT OF THE
                                       BOTTOM OF THE LOOP THEN THE
                                       ELEMENT IS NOT IN THE ROW, SO
                                       PUT IT IN. */
                     IF LAST_USED >= 32000 THEN
                        DO;            /* OVERFLOW */
                           LAST_USED=32767;/* FLAG TO INDICATE ERROR */
                           GOTO COUNT_CYLINDERS;/* CANT PROCESS THIS
                                       ELEMENT IN THE MATRIX */
                        END;
                     LAST_USED=LAST_USED+1;/* OTHERWISE THERE IS SPACE
                                       LEFT TO ADD ANOTHER ELEMENT */
                     IF CURRENT_INDEX = -1 THEN
                        IF LAST_INDEX = -1 THEN
                           DO;         /* CURRENT_INDEX=LAST_INDEX=-1.
                                       NO ELEMENTS EXIST ON CHAIN FOR
                                       THIS ROW. PUT SOME ON */
                              FROM(LAST_SEEK)=LAST_USED;/* CHAIN ON
                                       FROM 'FROM' ARRAY */
                              TO_CYLINDER#(LAST_USED)=
                              SEEK_ADDRESS;/* PUT IN COLUMN NUMBER */
                              CURRENT_INDEX=LAST_USED;/* SET CURRENT
                                       INDEX SO THAT CORRECT ELEMENT
                                       IS UPDATED IN CODE BELOW */
                           END;
                        ELSE
                           DO;         /* CURRENT_INDEX= -1,
                                       LAST_INDEX ^= -1. CHAIN ELEMENT
                                       ON END OF EXISTING CHAIN */
                              NEXT_CYLINDER(LAST_INDEX)=
                              LAST_USED;/* CHAIN ON */
                              CURRENT_INDEX=LAST_USED;/* SET CURRENT
                                       INDEX TO POINT TO IT */
                              TO_CYLINDER#(CURRENT_INDEX)=
                              SEEK_ADDRESS;/* INSERT COLUMN NUMBER */
                           END;
                     ELSE
                        IF LAST_INDEX = -1 THEN
                           DO;         /* CURRENT_INDEX ^= -1,
                                       LAST_INDEX = -1. ADD ELEMENT TO
                                       FRONT OF EXISTING CHAIN */
                              FROM(LAST_SEEK)=LAST_USED;/* CHAIN IN
                                       NEW ELEMENT */
                              NEXT_CYLINDER(LAST_USED)=
                              CURRENT_INDEX;/* AND SET NEW ELEMENT TO
                                       POINT TO EXISTING CHAIN */
                              CURRENT_INDEX=LAST_USED;/* SET CURRENT
                                       INDEX TO POINT TO NEW ELEMENT */
                              TO_CYLINDER#(CURRENT_INDEX)=
                              SEEK_ADDRESS;/* INSERT COLUMN NUMBER */
                           END;
                        ELSE
                           DO;         /* NEITHER CURRENT_INDEX NOR
                                       LAST_INDEX ARE -1. ADD ITEM TO
                                       MIDDLE OF EXISTING CHAIN */
                              NEXT_CYLINDER(LAST_INDEX)=
                              LAST_USED;/* CHAIN NEW ELEMENT ONTO END
                                       OF FRONT HALF OF EXISTING CHAIN
                                       */
                              NEXT_CYLINDER(LAST_USED)=
                              CURRENT_INDEX;/* CHAIN ON REST OF
                                       EXISTING CHAIN */
                              CURRENT_INDEX=LAST_USED;/* SET
                                       CURRENT_INDEX TO CORRECT
                                       ELEMENT */
                              TO_CYLINDER#(CURRENT_INDEX)=
                              SEEK_ADDRESS;/* SET COLUMN NUMBER */
                           END;
 SEEKFOUND:
                     TO_VALUE(CURRENT_INDEX)=
                     MIN(32766,TO_VALUE(CURRENT_INDEX)+1);/* INCREMENT
                                       ELEMENT */
 COUNT_CYLINDERS:
                     #CYLSCROSSED=
                     ABS(LAST_SEEK-SEEK_ADDRESS);/*NOW CALCULATE # OF
                                       CYLINDERS TRAVERSED. */
                     IF (DEVICE_TYPE=4) &(
                      (LAST_SEEK=0)×(SEEK_ADDRESS=0)) THEN
                        #CYLSCROSSED=#CYLSCROSSED-2;/*ALLOW FOR ORDER
                                       OF TRACKS ON 3350 FIXED HEAD*/
                     TOT_SEEK=TOT_SEEK+#CYLSCROSSED;/*TOTAL SEEKED.   */
                     MAX_SEEK= MAX(MAX_SEEK, #CYLSCROSSED);/* NEW
                                       MAXIMUM? */
                  END;
               LAST_SEEK=SEEK_ADDRESS; /*UPDATE SEEK ADDRESS */
            END;
      RETURN;
   END;                                /*OF PROCESS_SEEK*/
 %PAGE;
 STATUS_PROCESS: /*PROCESS CHANNEL/UNIT STATUS FOR SIO CC 1*/
   PROC REORDER;
 %SKIP(2);
 /****************************************************************/
 /*  STATUS_PROCESS UPDATES THE TABLE OF CSW STATUS RETURNED     */
 /*  WHEN SIO 1 OCCURS.  THE STATUS BITS OF THE CSW (32-47)      */
 /*  ARE GIVEN IN THE SSTATUS FIELD OF THE SIO RECORD AND        */
 /*  RETURNED IN FLAGS16 BY THE INPUT ROUTINE.  THERE ARE 6      */
 /*  SPACES FOR DIFFERENT REASONS.  HOWEVER IF OVERFLOW OCCURS,  */
 /*  SPACE 6 IS USED AS A GENERAL 'OTHER' REASON.                */
 /****************************************************************/
 %SKIP(2);
 /* LOCAL VARIABLES */
   DCL
      STATLOOP BIN(15);
 /*STATLOOP    LOOP COUNTER.                                   */
 %SKIP(2);
      DO STATLOOP = 1 TO 6;
         IF REASONS(STATLOOP)='0000000000000000'B THEN
            GOTO NEW_REASON;           /* THIS CODE ASSUMES THAT
                                       REASONS '0000'X AND 'FFFF'X
                                       WILL NOT BE USED. '0000'X
                                       INDICATES THAT THE SLOT IS
                                       UNUSED, 'FFFF'X INDICATES THAT
                                       ALL SLOTS ARE FULL AND THE LAST
                                       ONE IS A GENERAL 'OTHER
                                       REASONS' SLOT */
         IF REASONS(STATLOOP)=FLAGS16 THEN
            GOTO REASON_EXISTS;
      END;
 /*IF WE DROP OUT OF THE BOTTOM OF THE LOOP THEN ALL THE SLOTS */
 /*ARE USED AND WE STILL HAVEN'T FOUND A SPACE SO MARK SLOT 6  */
 /*AS A GENERAL 'OTHERS'.                                      */
      REASONS(6)='1111111111111111'B;
      #REASONS(6)=#REASONS(6)+1;
      RETURN;
 NEW_REASON:
      REASONS(STATLOOP)=FLAGS16;
 REASON_EXISTS:
      #REASONS(STATLOOP)=#REASONS(STATLOOP)+1;
      RETURN;
   END;                                /*OF STATUS_PROCESS*/
 %PAGE;
 SIOEND: /*PROCESS IO TIMES*/
   PROC(SETMAXIO) REORDER;
 %SKIP(2);
 /****************************************************************/
 /*  SIOEND PROCESSES INPUT OUTPUT TIMES.  SETMAXIO IS A         */
 /*  FLAG TO INDICATE WHETHER MAXIMUM INPUT/OUTPUT TIME MAY      */
 /*  BE UPDATED.  INPUT/OUTPUT TIME IS THE TIME FROM SIO CC0     */
 /*  TO I/O INTERRUPT OR NEXT SIO CC 0 ON SAME DEVICE.           */
 /*  MAX_IO_ALLOWED IS SET AS AN UPPER LIMIT ON INPUT/OUTPUT     */
 /*  TIME.                                                       */
 /****************************************************************/
 %SKIP(2);
 /*PARAMETERS*/
   DCL
      SETMAXIO BIT(1) ALIGNED;
 /*SETMAXIO    IF '1'B THE ROUTINE IS ALLOWED TO UPDATE        */
 /*            MAX_TIME.                                       */
 %SKIP(2);
 /*CONSTANTS*/
   DCL
      MAX_IO_ALLOWED STATIC BIN(31) INIT(30000);
 /*MAX_IO_ALLOWED  MAXIMUM TIME A SIO IS ALLOWED TO TAKE IN    */
 /*                MILLISECONDS*10.  HERE 3 SECONDS.           */
 %SKIP(2);
 /*LOCAL VARIABLES*/
   DCL
      IOINTERVAL FIXED BIN(31);
 /*IOINTERVAL  TEMPORARY USED TO HOLD I/O TIME.                */
 %SKIP(2);
      IOINTERVAL=RCRDTIME-LASTIME;     /*EVALUATE IO TIME.  IF LESS   */
      IF IOINTERVAL < 0 THEN
         DO;                           /* WRAP AROUND HAS OCCURRED */
            CALL BREAK_IN_TIME;
            RETURN;
         END;
      IF IOINTERVAL < MAX_IO_ALLOWED
      /*THAN ARTIFICIAL MAXIMUM      */THEN
 /*AND SETMAXIO = '1'B THEN     */
         IF SETMAXIO /*UPDATE MAXTIME.              */THEN
            MAX_TIME=MAX(MAX_TIME,IOINTERVAL);
         ELSE
            ;
      ELSE
         IOINTERVAL=MAX_IO_ALLOWED;    /*FORCE MAXIMUM TIME.          */
      TOT_TIME=TOT_TIME+IOINTERVAL;    /*ADD TO TOTAL IO TIME.        */
      RETURN;
   END;                                /*OF SIOEND*/
 %PAGE;
 CLEARIT: /* FREE DEVICE DATA */
   PROC REORDER;
 %SKIP(2);
 /********************************************************************/
 /*  CLEARIT FREES ALL ALLOCATIONS OF DEVICE_DATA.                   */
 /********************************************************************/
 %SKIP(2);
 /* BUILT IN FUNCTIONS */
   DCL
      EMPTY BUILTIN;
 %SKIP(2);
      BIG_AREA=EMPTY();
      NO_DEVICES=0;
      RETURN;
   END;                                /* OF CLEARIT */
 %PAGE;
 END_OF_FILE: /* END OF FILE PRINTING */
   PROC REORDER;
 %SKIP(2);
 /********************************************************************/
 /*  END_OF_FILE PRINTS THE JOB TOTAL FOR THE GLOBAL COUNTS AT THE   */
 /*  END OF THE INPUT FILE OR WHEN A TRANSMIT ERROR MAKES FURTHER    */
 /*  PROCESSING IMPOSSIBLE                                           */
 /********************************************************************/
 %SKIP(4);
 /* ENTRY */
 %SKIP(2);
   DCL
      XXTODH3 ENTRY(FIXED BIN(31), /* RELATIVE TIME (READ) */CHAR(9) /*
  DATE (WRITE) */) RETURNS(CHAR(12)) /* RETURNS TIME */;/* XXTODH3 IS
                                       THE ENTRY TO XXTODHM WHICH
                                       RETURNS THE REAL DATE AND TIME,
                                       GIVEN THE RELATIVE DATE AND
                                       TIME */
 %SKIP(4);
 /* CONTSTANTS */
 %SKIP(2);
   DCL
      1 HLINES EXTERNAL STATIC,
         2 RANGES(26) CHAR(60) INIT(
   'VALUE RANGES FOR SEEK ANALYSIS MATRICES             COMMON C',
   'HANNEL STATUS WORDS RETURNED WITH START I/O CONDITION CODE 1',
   '_______________________________________             ________',
   '____________________________________________________________',
   ' 1...9    REPRESENT THE SAME VALUES                 1000 - D',
   'EVICE BUSY                                                  ',
   '   A      REPRESENTS       9 - 19                           ',
   '                                                            ',
   '   B      REPRESENTS      20 - 39                   3000 - D',
   'EVICE BUSY, CONTROL UNIT END                                ',
   '   C      REPRESENTS      40 - 79                           ',
   '                                                            ',
   '   D      REPRESENTS      80 - 159                  5000 - C',
   'ONTROL UNIT BUSY                                            ',
   '   E      REPRESENTS     160 - 319                          ',
   '                                                            ',
   '   F      REPRESENTS     320 - 639                          ',
   '                                                            ',
   '   G      REPRESENTS     640 - 1279                         ',
   '                                                            ',
   '   H      REPRESENTS    1280 - 2559                         ',
   '                                                            ',
   '   I      REPRESENTS    2560 - 5119                 THE VALU',
   'ES PRINTED ARE BIST 32 - 47 OF THE CHANNEL STATUS WORD,     ',
   '   J      REPRESENTS    5120 - 10239                THE FIRS',
   'T BYTE BEING UNIT STATUS, THE SECOND BYTE CHANNEL STATUS.   ' );/*
                                       GENERAL LIST OF COMMON CHANNEL
                                       STATUS WORDS AND LIST OF RANGES
                                       FOR THE MATRIX PRINT */
   DCL
      FULL_LINES(13) CHAR(120) DEF(HLINES);/* COMPRESSION OF RANGES
                                       INTO FULL LINES */
   DCL
      MESSAGES(3) STATIC CHAR(23) INIT('END OF FILE REACHED',
   'TRANSMIT ERRORS ON FILE', 'TIMESTAMPS OUT OF RANGE');/* MESSAGES
                                       AS TO WHY THE JOB WAS ENDED
                                       WHEN IT WAS */
 %SKIP(4);
 /* LOCAL VARIABLES */
 %SKIP(2);
   DCL
      CHARDATE CHAR(9);                /* TEMPORARY FOR DATE */
   DCL
      (LATE_DECIMAL,                   /* LATEST TIME AS A DECIMAL */
      EARLY_DECIMAL) FIXED DEC(11);    /* EARLIEST TIME AS A DECIMAL */
 %SKIP(4);
      LATE_DECIMAL=LATEST;
      EARLY_DECIMAL=EARLIEST;
      LATE_DECIMAL=(LATE_DECIMAL-EARLY_DECIMAL+5)/10;/* COMPUTE
                                       INTERVAL */
      IF(LINES+45) > MAXLINES THEN
         CALL XXNWPGE;
      LINES=LINES+45;                  /* INCREMENT LINE COUNT */
 %SKIP(2);
 /* NOW OUTPUT TOTALS */
 %SKIP(2);
      PUT FILE(PRINT)
      EDIT(MESSAGES(RCRDTYPE), 'EARLIEST TIME FOUND:  ',
       XXTODH3(EARLIEST,CHARDATE), '   MEASUREMENT INTERVAL:  ',
       LATE_DECIMAL, ' MSEC   TIME ON FIRST RECORD:  ',
       TIME_ON_FIRST_RECORD, 'LATEST   TIME FOUND:  ',
       XXTODH3(LATEST,CHARDATE), 'TIME ON LAST  RECORD:  ',
       XXTODH3(RCRDTIME,CHARDATE), 'TOTAL RECORDS READ:  ',
       MAINLOOP+BASELOOP, 'TOTAL SIO      : ',
       #SIOSZERO+#SIOSONE+#SIOSTWO+#SIOSTHREE, 'CC 0: ', #SIOSZERO,
       'CC 1: ', #SIOSONE, 'CC 2: ', #SIOSTWO, 'CC 3: ', #SIOSTHREE,
       'TOTAL IO       : ', #IOS, 'TOTAL PCI      : ', #PCI,
       'TOTAL LOST DATA: ', #LOSTDATA, 'TOTAL SENSE     : ',#BOS,
       'TOTAL EOS      : ', #EOS, 'TOTAL BAD      : ', #NOT_KNOWN,
       'TOTAL TIMESTAMP: ', #TIMESTAMPS, 'TOTAL BYPASSED : ',
       #BYPASSED ) (
       SKIP(2), A(23) /* MES */, SKIP(2),
       A(21) /* EARLIEST TIME FOUND */, A(12) /* XXTODH3(EARL */,
       A(26) /* 'MEASUR */, P'Z,ZZZ,ZZZ,ZZ9' /* LATE_DECIMAL */,
       A(31) /* ' MSEC   TIM */, A(12) /* TIME_ */, SKIP,
       A(21) /* 'LATEST */, A(12) /* XXTODH3(LATES */, X(47),
       A(23) /* 'TIME ON LAST */, A(12) /* XXTODH3(RCRDTIME, */,
       SKIP(2), A(21) /* 'TOTAL RECORDS */, P'ZZZ,ZZ9' /* MAINLOOP + */,

      SKIP(2), A(17) /* 'TOTAL SIO */, P'ZZZ,ZZ9' /* #SIOSZERO+ */,
       X(3), A(6) /* 'CC 0 */, P'ZZZ,ZZ9' /* #SIOSZERO */,
       (3)(SKIP,X(27),A(6) /* 'CC X' */, P'ZZZ,ZZ9' /* #SIOSX */),
       (9) (SKIP(2),A(17) /* 'TOTAL TYPE */, P'ZZZ,ZZ9' /* #X */));
 %SKIP(2);
      PUT FILE(PRINT) EDIT(FULL_LINES) (
       SKIP(5), A(120), SKIP(0), A(120), SKIP(2), (11)(SKIP, A(120) ) );
 /* PRINT OF GENERAL INFORMATION ABOUT FILES */
 %SKIP(2);
      IF MAINLOOP > SIGNIFICANCE THEN
         CALL PRINTOUT;                /* WORTHWHILE DOING DETAILED
                                       ANALYSIS? */
      CALL CLEARIT;
      CALL XXNWPGE;                    /* TERMINATING MESSAGE */
      PUT FILE(PRINT) EDIT('***** END OF JOB *****')(SKIP(2),A(22));
      RETURN;
   END;                                /* OF END_OF_FILE */
 %PAGE;
 PRINTOUT: /* LOOP CONTROLLING PRINTOUT OF DEVICE DATA */
   PROC REORDER;
 %SKIP(2);
 /********************************************************************/
 /*  PRINTOUT  IS THE PROCEDURE CONTROLLING THE PRINTING OF RESULTS  */
 /*  FOR EACH DEVICE, OR A MESSAGE IF THERE HAS BEEN INSUFFICIENT    */
 /*  ACTIVITY.                                                       */
 /********************************************************************/
 %SKIP(2);
 /* LOCAL VARIABLES */
   DCL
      LOOP FIXED BIN(15),              /* LOOP COUNTER */
      SAVED_MESSAGES BIT(1) ALIGNED INIT('0'B), /* FLAG TO INDICATE
                                       WHETHER THERE ARE SAVED
                                       MESSAGES OR NOT */
      TEMPPTR POINTER;                 /* TEMPORARY POINTER FOR SAVE
                                       MESSAGE BLOCKS */
 %SKIP(2);
 /* ENTRY */
   DCL
      XXSAVEM ENTRY(POINTER);          /* ENTRY TO XXSAVEM TO PRINT
                                       MESSAGES SAVE */
   DCL
      XXSAVE1 ENTRY();                 /* ENTRY TO PRINT THEM ALL OUT
                                       AGAIN */
   DCL
      XXPRTDV ENTRY(FIXED BIN(15), FIXED BIN(15), POINTER, FIXED BIN(15)
       );                              /* PRINT INFORMATION FOR A
                                       SINGLE DEVICE. PARAMETERS: (1)
                                       MAIN PATH ADDRESS IN BINARY,
                                       (2) ALTERNATE PATH ADDRESS IN
                                       BINARY OR -1 IF THERE NO
                                       ALTERNATE PATH HAS BEEN FOUND,
                                       (3) POINTER TO DEVICE_DATA FOR
                                       THIS DEVICE, (4) METHOD TO BE
                                       USED IN EVALUATING BUSIEST
                                       CYLINDERS FOR SECOND PAGE PRINT
                                       */
   DCL
      XXCONVH ENTRY(FIXED BIN(15)) RETURNS(CHAR(3)) REDUCIBLE;/*
                                       CONVERTS DEVICE ADDRESS INTO
                                       HEX CHARACTERS */
 %SKIP(2);
 /* CONSTANTS */
   DCL
      SIGNIFICANT_#_SIOS BIN(15) STATIC INIT(50);/* MINIMUM NUMBER OF
                                       SIOS BEFORE A DEVICE IS
                                       CONSIDERED FOR PRINTING */
 %SKIP(2);
 /* EXTERNAL */
   DCL
      DEVCHAR(4) STATIC EXT CHAR(7) INIT( '3330   ', '3330-II',
   '3350   ', '3350-FH' );             /* DEVICE TYPES FOR PRINTING */
 %SKIP(2);
 /* BASED VARIABLES & TEMPLATES */
   DCL
      1 FIRSTMSG BASED,
         2 NEXTSBLOCK PTR INIT(NULL()),
         2 NEXTLINE PTR INIT(NULL()),
         2 LINES FIXED BIN(15) INIT(3),
         2 #CARS BIN(15) INIT(77),
         2 SKPL BIN(15) INIT(2),
         2 PRLN1 CHAR(132) INIT(( 'THERE ARE ONLY XX,XXX RECORDS '××
   'FOR DEVICE AT ADDRESS XXX.  DE'×× 'VICE TYPE XXXX-XX')),
      1 SECONDMSG BASED,
         2 NBP PTR INIT(NULL()),
         2 NLP PTR INIT(NULL()),
         2 LINES1 FIXED BIN(15),
         2 #CARS1 BIN(15) FIXED INIT(24),
         2 SKPL BIN(15) INIT(1),
         2 PL2 CHAR(132) INIT('INFORMATION NOT PRINTED');
   DCL
      1 DMY BASED,                     /* DUMMY TO GET CORRECT FIELDS
                                       FROM FIRST MESSAGE */
         2 D# PTR,
         2 D## PTR,
         2 L# FIXED BIN(15),
         2 #L FIXED BIN(15),
         2 ##L FIXED BIN(15),
         2 PRD CHAR(15),
         2 SIOS# PIC'ZZ,ZZ9',          /* # OF SIOS 0S  */
         2 PRDD CHAR(30),
         2 CHADDR CHAR(3),             /* ADDRESS OF DEVICE */
         2 PRPAD CHAR(15),
         2 DEVTYPED CHAR(7);           /* DEVICE TYPE */
 %SKIP(2);
 /* BUILT IN FUNCTIONS */
   DCL
      NULL BUILTIN;
 %SKIP(4);
      DO LOOP = 1 TO NO_DEVICES;
         CURRPTR=DEVICE_POINTERS(LOOP);/* GET ADDRESS OF DATA */
         IF #SIOS_0 >= SIGNIFICANT_#_SIOS THEN
            CALL
            XXPRTDV(DEVICE_ADDRESSES(LOOP),
             ALTERNATE_PATH_ADDRESSES(LOOP), CURRPTR,METHOD);/*
                                       WORTHWHILE CALLING PRINT
                                       ROUTINE */
         ELSE
            DO;                        /* NOT WORTHWHILE SO SAVE UP A
                                       MESSAGE TO BE PRINTED LATER */
               SAVED_MESSAGES='1'B;    /* YES THERE ARE SOME TO BE
                                       SAVED */
               ALLOCATE FIRSTMSG SET (TEMPPTR);/* ALLOCATE FIRST
                                       MESSAGE BLOCK */
               TEMPPTR->SIOS#=#SIOS_0; /* USE DUMMY TO INSERT FIELDS
                                       INTO FIRST MESSAGE */
               TEMPPTR->CHADDR=XXCONVH(DEVICE_ADDRESSES(LOOP));
               TEMPPTR->DEVTYPED=DEVCHAR(DEVICE_TYPE);/* DEVICE TYPE */
               ALLOCATE SECONDMSG SET(TEMPPTR->NEXTLINE);/* ALLOCATE
                                       SECOND LINE OF MESSAGE AND
                                       CHAIN IT ON */
               CALL XXSAVEM(TEMPPTR);  /* CHAIN MESSAGE ON */
            END;
      END;
 %SKIP(2);
      IF SAVED_MESSAGES THEN
         CALL XXSAVE1;                 /* IF THERE ARE MESSAGES SAVED
                                       THEN PRINT THEM */
      RETURN;
   END;                                /* OF PRINTOUT */
 %PAGE;
 BREAK_IN_TIME:
   PROC REORDER;
 %SKIP(2);
 /********************************************************************/
 /*  BREAK_IN_TIME RESETS CERTAIN FUNCTIONS ON A DEVICE, SHOULD A    */
 /*  WRAP-AROUND OF RECORDS OCCUR AND AN EARLIER RECORD FOLLOWS A    */
 /*  LATER ONE.                                                      */
 /********************************************************************/
 %SKIP(2);
      SELECT(LAST_EVENT);
         WHEN(1)
            DO;                        /* LAST EVENT WAS A SIO CC 0. */
               #SIOS_NOT_FINISHED=#SIOS_NOT_FINISHED+1;/* THIS SIO
                                       WHICH STARTED WILL NOT HAVE
                                       ANYTHING TO INDICATE ITS END SO
                                       IGNORE IT */
            END;
         WHEN(2)
            DO;                        /* LAST EVENT WAS A SIO CC 1. */
               DOESNT_COUNT=DOESNT_COUNT+1;
            END;
         OTHER
            ;
      END;
      LAST_SEEK=-1;                    /* LAST SEEK ADDRESS IS NOW
                                       INVALID */
      RETURN;
   END;                                /* OF BREAK_IN_TIME */
   END;                                /* OF XXMAINL */
