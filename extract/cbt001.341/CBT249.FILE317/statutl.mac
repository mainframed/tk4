*PROCESS FLAG(I),OF,A,AG,GN,OPT(TIME),MACRO,MAR(2,72);
 /*   STATUTL: DISPLAY OF STATDIE INFORMATION (SUPPORTS MP/AP)      */
 /* PROCEDURE: STATUTL    (WAS CPU PROGRAM)                          */
 /* FUNCTION:  DISPLAY MARGINAL STATE PROBABILITIES FOR THE CPU      */
 /*            BASED ON THE CURRENT INCORE SAMPLE FROM STATDIE       */
 /*            OR THE SMF RECORDS PRODUCED BY STATDIE.               */
 /*            ALSO FORMATS RCT, PVT AND DOMAIN INFO.                */
 /*            CAN OPTIONALLY WRITE PSW SAMPLES TO PSWS FILE.        */
 /* LANGUAGE:  PLIX                                                  */
 /* SYSTEM:    MVS R3.8 + SE2                                        */
 /* EXTERNAL:  CALLS LOADPTR ENTRY AND SDL IN PLIMISC UTILITIES      */
 /* VERSION:   MAR, 1981                                             */
 /* AUTHOR:    HOWARD GILBERT                                        */
 /*            YALE COMPUTER CENTER                                  */
 /*            175 WHITNEY AVE                                       */
 /*            NEW HAVEN, CONN. 06520                                */
 /*            203 432-4080                                          */
 /* UPGRADED BY LIONEL SILVA (GEICO)                                 */
 /* DISTRIBUTION:                                                    */
 /*    THIS PROGRAM IS NOT RESTRICTED IN ANY MANNER. IT MAY BE       */
 /* FREELY REPRODUCED AND USED FOR ANY PURPOSE. HOWEVER,             */
 /* USERS ARE MORALLY BOUND TO MARK CLEARLY ANY MODIFICATIONS        */
 /* THEY ADD PRIOR TO DISTRIBUTING A MODIFIED VERSION TO OTHERS.     */
 %PAGE;
 /* INPUT:                                                           */
 /*     EXEC CARD OR SYSIN PARAMETERS (SYSIN OVERRIDES EXEC CARD)    */
 /*           DATE=YYDDD-YYDDD       /* DATE RANGE TO SELECT         */
 /*           TIME=HHMM-HHMM         /* TIME RANGE TO SELECT         */
 /*                      USES A HELL OF A LOT OF CPU TIME!!!         */
 /*           LMOD=          IF PSWS DDNAME IS GIVEN, THE LMOD       */
 /*                      PARM CAN BE USED TO SPECIFY WHICH PSWS      */
 /*                      ARE TO BE WRITTEN (DEFAULT IS ALL NON-WAIT  */
 /*                      PSW'S). VALID LMOD VALUES ARE:              */
 /*                      *REL       ALL RELATIVIZED PSW'S            */
 /*                      <CDENAME>  1-8 CHARACTER CDENAME            */
 /*           ADRS=          IF ADDRS DDNAME IS GIVEN, THE ADRS      */
 /*                      PARM MUST BE USED TO SPECIFY WHICH ADRESSES */
 /*                      ARE TO BE WRITTEN.                          */
 /*                      VALID ADRS VALUES ARE:                      */
 /*                      *          ALL ADRESSES WITHIN PLPA         */
 /*                      *<CDENAME> 1-8 CHAR CDENAME OF PLPA MODULE  */
 /*                      <CDENAME>  1-8 CHAR CDENAME OF MODULE IN    */
 /*                                 PRIVATE AREA.  ONLY RELATIVIZED  */
 /*                                 ADDRESSES ARE WRITTEN.           */
 /*                                                                  */
 /*   THE FOLLOWING OPTIONS ONLY EFFECT THE REPORTS PRINTED          */
 /*                                                                  */
 /*           PGMS=YES                  PRINT PROGRAM ACTIVITY       */
 /*           BREAK=HHMM-HHMM-HHMM-....) /* BREAK TIMES UP TO 50     */
 /*           INTVL=NNNNN            NUMBER OF MINUTES BETWEEN       */
 /*                          CONTROL BREAKS.  WORKS LIKE BREAK BUT   */
 /*                          BASED ON INTERVALS INSTEAD OF TIME OF   */
 /*                          DAY.  BREAK AND INTVL CANNOT BOTH BE    */
 /*                          SPECIFIED.                              */
 /*                                                                  */
 /* IF NO BREAKS ARE SPECIFIED, ONE REPORT WILL BE PRODUCED          */
 /* FOR THE WHOLE RANGE SPECIFIED. OTHERWISE THERE WILL BE A REPORT  */
 /* EACH TIME A BREAK HOUR HAS BEEN PASSED.  HOURS MUST BE           */
 /* SPECIFIED IN ASCENDING ORDER. EXAMPLES ARE:                      */
 /* BREAK=0000  -  CAUSES A NEW OUTPUT FOR EACH DAY IN THE REPORT.   */
 /* BREAK=0100-0900-1700
 /*       SEPARATE REPORTS WILL BE PRODUCED FOR EACH                 */
 /*       1AM-9AM,9AM-5PM,5PM-1AM PERIOD ENCOUNTERED IN THE DATA.    */
 /*                                                                  */
 /*                                                                  */
 /* DEFAULTS: SUMMARIZE ALL RECORDS                                  */
 /*                                                                  */
 /*                                                                  */
 /*  OPTIONAL DDNAMES                                                */
 /*                                                                  */
 /*                                                                  */
 /*    IF DDNAME PSWS IS SUPPLIED, THEN THE PSW SAMPLES WILL BE      */
 /*    WRITTEN TO THE PSWS DDNAME (1 RECORD PER PSW). WORKS          */
 /*    WITH THE LMOD= PARM (SEE ABOVE). (WAIT PSWS ARE NOT WRITTEN.) */
 /*                                                                  */
 /*    IF DDNAME ADDRS IS SUPPLIED, THEN 4 BYTE VIRTUAL ADDRESES     */
 /*    (OR RELATIVE OFFSETS), ARE WRITTEN TO THE ADDRS FILE          */
 /*    (1 RECORD PER PSW). THE ADRS PARM MUST BE USED IN CONJUNTION  */
 /*    WITH THIS (SEE ABOVE).  THIS FILE IS INTENDED TO BE USED AS   */
 /*    INPUT TO THE UICC PACKLIST GENERATOR TO GENERATE PACKLISTS    */
 /*    OR LKED ORDER STATEMENTS. *NOTE*: IF ADRS PARM SUPPLIES A     */
 /*    VALUE BEGINNING WITH '*', THIS INDICATES INFORMATION ON PLPA  */
 /*    IS NEEDED.  THIS INFORMATION IS GOTTEN FROM THE DIRECT FILE   */
 /*    WHICH SHOULD BE THE OUTPUT OF THE DIRECT OR LPAMAP PROGRAM    */
 /*    SUPPLIED WITH UICC PACKLIST GENERATOR.                        */
 /*                                                                  */
 /*    DDNAME DIRECT IS USED WITH ADDRS ABOVE.                       */
 /*                                                                  */
 /*                                                                  */
 %SKIP(4);
 /* INSTALLATION NOTES:                                              */
 /* RECOMMENDED TARGET LIBRARY: LINKLIB                              */
 /* LINKEDIT SYSLIB: PLIBASE                                         */
 /*       (MUST BE LINKEDITED WITH PLIMISC SUBROUTINES)              */
 /* LINKEDIT PARAMETERS: REUS                                        */
 %PAGE;
 /* ONE PICTURE IS WORTH A LOT OF DOCUMENTATION:                     */
 %SKIP(2);
 /* STATDIE REPORT-ALL SAMPLES INCLUDED                              */
 /* SELECTED:      81/062 04.22.49    THRU 81/062 12.21.05           */
 /* SAMPLES:   109960/       0/  752  INTERFERENCE %:    4.432       */
 /* CPU UTILIZATION    38.8    0.0    STATDIE OVHD       0.05        */
 /* SUPERVISOR STATE   49.3    0.0    LOCK CODE          0.00        */
 /* USERSTATE          48.6    0.0    READY TCBS         2.12        */
 /* SUPERVISOR STATE IS  SVC: 35.9   SRB: 24.0   OTHER:  4.7         */
 /* KEY  PCT  ×  SVC  PCT  ×   PG  PCT  ×  PGM      PCT              */
 /*  0  58.6  ×    0  7.1  ×   1  43.4  ×  GEORGE     8.9            */
 /*  1   4.2  ×   10  4.8  ×   2  26.7  ×  CML        6.3            */
 /*  2   0.0  ×   16  4.0  ×   0  12.9  ×  IEDTCAM2   6.1            */
 /*  3   0.0  ×   99  1.4  ×  13   6.1  ×  IEAVAR00   5.1            */
 /*  4   0.0  ×  114  1.4  ×  12   5.7  ×  YCCMAINT   4.4            */
 /*  5   1.0  ×   93  1.3  ×   6   4.6  ×  VSAPL      3.0            */
 /*  6   3.4  ×  101  0.9  ×  10   0.2  ×  IEFIIC     2.7            */
 /*  7   0.0  ×   20  0.8  ×  14   0.0  ×  DIFF3D     2.5            */
 /*  8  32.5  ×   26  0.8  ×   3   0.0  ×  JES2PROD   2.2            */
 /*  9   0.0  ×    1  0.8  ×   4   0.0  ×  QEDMAIN    2.1            */
 /*                                                                  */
 /* STATDIE STATS:  RELATIVIZED  0.5 JPAC S/F   0.0/  0.0            */
 /*                                                                  */
 /*===>PSW SAMPLING ERROR(S) OCCURED: ******                         */
 /*    CODE      NUMBER                                              */
 /*    LCC1           4                                              */
 /*                                                                  */
 /*UICA  CPUA AFC ASMQ  PTR   DPR PAGRT  MSPP  POOL CFMCT CNTFX      */
 /*   <CONTINUED FROM ABOVE LINE>  SQAFX COMFX                       */
 /*  95  63.0 164    6 14.2  15.3  61.6 0.072  1342   593   308      */
 /*   <CONTINUED FROM ABOVE LINE>     97    49                       */
 /*                                                                  */
 /*        D O M A I N    S T A T I S T I C S  (MIN/AVG/MAX)         */
 /*        0     1     2     3     4     5                           */
 /*TMPL  255          20    13                                       */
 /*              1    20    10           2                           */
 /*      255     5    20    18          10                           */
 /*CMPL    1           4     1                                       */
 /*        1     1     7     2           1                           */
 /*        2     4    12    15           6                           */
 /*RUA     2           2                 1                           */
 /*              3     4     3           2                           */
 /*        2     9     8    18          12                           */
 %PAGE;
 /* THIS IS A TYPICAL OUTPUT REPORT.   THE VALUES ARE DEFINED        */
 /* AS FOLLOWS:                                                      */
 /* WHEN STATDIE INITIALIZES, IT ZEROS OUT THE PAGABLE BUFFERS. FOR  */
 /* THE FIRST 20 MINUTES, SOME OF THE BUFFERS ARE STILL UNFILLED.    */
 /* THERE IS NO VALID PSW WHICH CONTAINS ALL ZERO BITS, SO THE       */
 /* SAMPLE IS DEFINED AS THE SET OF PSWS WITH AT LEAST ONE BIT ON.   */
 /* THE SAMPLE SIZE IS GIVEN AS FIRST THE NUMBER OF SAMPLES ON CPU 0 */
 /* THEN THE NUMBER OF SAMPLES ON CPU1. THESE TWO NUMBERS ARE        */
 /* FOLLOWED BY THE NUMBER OF MISSED SAMPLES (I.E., SAMPLES MISSED   */
 /* BECAUSE STATDIE WAS WAITING FOR STATSRB TO EMPTY THE FIXED DATA  */
 /* BUFFER).  THE FOLLOWING CONSIDERATIONS HOLD FOR THESE VALUES:    */
 /*                                                                  */
 /*    1) IF BOTH CPUS ARE ONLINE DURING THE LAST 20 MINUTES, AND    */
 /*       YOU HAVE INSTALLED THE YALE ZAP TO IEAVRT10 TO             */
 /*       PERMIT STATDIE TO SELECT A SPECIFIC CPU, THEN YOU SHOULD   */
 /*       HAVE EQUAL SAMPLE SIZES ON BOTH CPUS, OR THEY WILL DIFFER  */
 /*       BY AT MOST 1 DURING THE INITITAL FILLING OF THE BUFFERS.   */
 /*    2) IF YOU LOSE ONE OF THE CPUS DURING THE PERIOD, ALL OF THE  */
 /*       SAMPLES WILL BE TAKEN ON THE REMAINING CPU, AND THIS WILL  */
 /*       BE REFECTED IN THE SAMPLE SIZE INFORMATION.                */
 /*    3) IF YOU DO NOT INSTALL THE ZAP TO IEAVRTI0, THEN SAMPLES    */
 /*       WILL BE TAKEN RANDOMLY ON BOTH CPUS SUBJECT TO TWO SOURCES */
 /*       OF BIAS: A) THERE ARE LIKELY TO BE MORE SAMPLES ON         */
 /*       A CPU WHICH IS DISABLED LESS OF THE TIME, B) THERE WILL    */
 /*       BE MORE SAMPLES ON THE FASTER CPU (MOD 1/ MOD 3 CONFIG     */
 /*       BOTH BIASES FAVOR THE ATTACHED PROCESSOR IN A MODEL 1 158  */
 /*       AP CONFIGURATION.                                          */
 /*                                                                  */
 /* INTERFERENCE % - TOTAL TIME STATDIE SHOULD HAVE SAMPLED ((NUMBER */
 /*    OF SAMPLES - 1) * CYCLE TIME) - ACTUAL TIME SAMPLED / TOTAL   */
 /*    TIME SHOULD HAVE SAMPLED , CONVERTED TO A PERCENT.  THIS      */
 /*    INDICATES TIME WHEN STATDIE COULD GET DISPATCHED BECAUSE THE  */
 /*    CPU WAS DISABLED WHEN STATDIE'S TQE EXPIRED (MAYBE RECOVERY   */
 /*    OR IOS).                                                      */
 /*                                                                  */
 /* CPU UTILIZATION - % OF THE SAMPLE WITH THE WAIT BIT OFF.         */
 /*    (NOTE: THIS IS THE ONLY % WHICH IS BASED ON THE WHOLE SAMPLE. */
 /*     ALL OTHER PERCENTS ARE NOW BASED ON COUNT OF NON-WAIT STATE  */
 /*     PSW'S).                                                      */
 /*   THE FIRST CPU UTILTIZATION FIGURE IS FOR CPU 0, THE SECOND IS  */
 /*    FOR CPU 1.                                                    */
 /*                                                                  */
 /* STATDIE OVHD - % OF CPU CONSUMED BY STATDIE EXIT CODE.           */
 /*                                                                  */
 /* SUPERVISOR STATE - % OF ACTIVE PSWS WITH THE PROBLEM BIT OFF.    */
 /*                                                                  */
 /* LOCK CODE -  % OF TIME STATDIE FOUND PSW IN LOCK MANAGER         */
 /*     (SPECIAL CODE IN STATDIE WHICH ATTRIBUTES PSW TO INVOKER     */
 /*     OF LOCK MANAGER)                                             */
 /*                                                                  */
 /* USER STATE - % OF ACTIVE PSWS WITH THE PROBLEM BIT ON AND        */
 /*     NON-SYSTEM KEY (>7).                                         */
 /*                                                                  */
 /* READY TCBS - AVERAGE NUMBER OF QUEUED READY TCB'S                */
 /*                                                                  */
 /* SUPERVISOR STATE IS FURTHER SUBDIVIDED INTO THE PERCENTAGES WHEN */
 /* AN SVC WAS IN CONTROL IN TASK MODE, WHEN AN SRB IS IN CONTROL,   */
 /* AND OTHER (WHICH INCLUDES FOR EXAMPLE, MODESET TIME, INITIATOR   */
 /* TIME, JES AND TCAM TASK TIME IN SUPERVISOR STATE, ETC).          */
 /*                                                                  */
 /*    COLUMN TOTALS:                                                */
 /*                                                                  */
 /* THE FOUR COLUMNS OF PERCENTAGES ARE SEPARATE AND TOTAL           */
 /* VERTICALLY. YOU DO NOT READ THEM ACROSS THE ROWS, BECAUSE THERE  */
 /* IS NO HORIZONTAL ASSOCAITION. ONLY TEN ITEMS APPEAR IN EACH      */
 /* COLUMN, THOUGH IT IS EASY TO MODIFY THE PROGRAM TO PRINT MORE.   */
 /* THE COLUMNS WILL NOT TOTAL TO 100% OF COURSE IF THERE IS ANY     */
 /* OMITTED NON-ZERO VALUE.                                          */
 /*                                                                  */
 /* KEY -  ACTIVE TIME BY PROTECT KEY.                               */
 /* SVC -  ACTIVE TIME BY THE SVC NUMBER OF THE TEN MOST ACTIVE SVCS */
 /* PG  -  ACTIVE TIME BY THE PERFORMANCE GROUP OF THE ASID IN       */
 /*        CONTROL FOR THE TEN MOST ACTIVE GROUPS                    */
 /* PGM -  ACTIVE TIME BY THE CDENAME POINTED TO BY THE HIGHEST PRB  */
 /*        ON THE RB QUEUE.  THE PGM NAME ON THE REPORT IS SET TO    */
 /*        TO ASTERISKS UNLESS PARM 'PGMS=YES' WAS SPECIFIED.        */
 /*                                                                  */
 /* STATDIE STATS -                                                  */
 /*    RELATIVIZED - THE % OF ACTIVE PSW'S WHICH HAD THE PSW ADDRESS */
 /*      RELATIVIZED FROM THE ENTRY POINT OF THE MODULE IN CONTROL   */
 /*    JPAC S/F    - THE % OF ACTIVE PSW'S FOR WHICH THE JOB PACK    */
 /*      WAS SEARCHED/ AND THE PERCENT OF SEARCHES WHICH RESULTED    */
 /*      IN FINDING THE PSW IN A JOB PACK MODULE.                    */
 /*                                                                  */
 /* PSW SAMPLING ERRORS                                              */
 /*                                                                  */
 /*  IF STATDIE ENCOUNTERED AN INVALID CONTROL BLOCK OR POINTER,     */
 /*  IT SETS A BIT IN THE SAMPLE RECORD AND PLACES A 4 CHARACTER     */
 /*  SAMPLE ERROR CODE IN THE LAST 4 BYTES OF THE CDENAME IN THE     */
 /*  SAMPLE RECORD.  IF STATUTL DETECTS ANY OF THESE, A LIST OF      */
 /*  THE NUMBER OF ERRORS BY ERROR CODE IS PRINTED.                  */
 /*                                                                  */
 /*  RCT AND PVT AVERAGES                                            */
 /*                                                                  */
 /*  UICA -  UIC COUNT                                               */
 /*  CPUA -  CPU BUSY (SRM'S PERCEPTION)                             */
 /*  AFC  -  AVAILABLE FRAM COUNT                                    */
 /*  ASMQ -  ASMQ LENGTH                                             */
 /*  PTR  -  PAGE FAULT RATE (PAGES/SECOND)                          */
 /*  DPR  -  DEMAND PAGE RATE                                        */
 /*  PAGRT-  TOTAL PAGE RATE                                         */
 /*  MSPP -  PAGE DELAY (IN SECONDS)                                 */
 /*  POOL -  TOTAL AVAILABLE PAGABLE FRAMES                          */
 /*  CFMCT-  COMMON FRAME COUNT                                      */
 /*  CNTFX-  TOTAL FIXED FRAMES                                      */
 /*  SQAFX-  SQA FRAMES (ALL ARE FIXED ANYWAY)                       */
 /*  COMFX-  COMMON AREA FIXED FRAMES                                */
 /*                                                                  */
 /*  DOMAIN STATISTICS                                               */
 /*    THESE ARE DISPLAYED IN COLUMNS WITH THE DOMAIN NUMBER AT THE  */
 /*    TOP OF THE COLUMN FOLLOWED BY 3 SETS OF THREE NUMBERS.        */
 /*    THE 3 SETS ARE THE TARGET MPL (TMPL), CURRENT MPL (CMPL) AND  */
 /*    READY USER AVERAGE (RUA).  THE 3 NUMBERS WITHIN EACH SET      */
 /*    ARE THE MIN/AVERAGE/MAX.                                      */
 /*                                                                  */
 %PAGE;
 /* PREPROCESSOR PARAMETERS GOVERNING VARIABLE DIMENSIONS */
 %DCL (HSIZE,MODULUS,MODULUS1,MAXERRS) FIXED;
 /* HSIZE AND MODULUS EFFECT THE ALLOCATION OF THE HASH TABLE        */
 /* FOR PROGRAM NAMES. THEY SHOULD BE CHOSEN BASED ON A GENEROUS     */
 /* ESTIMATE OF THE NUMBER OF UNIQUE PROGRAM NAMES. MODULUS MUST     */
 /* BE A PRIME NUMBER. IF MORE THAN 'HSIZE' UNIQUE MODULE NAMES ARE  */
 /* ENCOUNTERED, THE ERROR CONDITION IS RAISED.                      */
 %HSIZE=2000;
 %MODULUS=503;
 %MODULUS1=MODULUS+1;
 %MAXERRS=10;
 % INCLUDE STATGLBL;
 %PAGE;
 STATUTL: PROC (EXEC_PARM) OPTIONS(MAIN) REORDER;
 %SKIP(2);
 DCL PLIXOPT CHAR(100) VAR EXTERNAL INIT('ISASIZE(120K)');
 %SKIP(2);
 DCL EXEC_PARM CHAR(100)  VAR;
 DCL CARD      CHAR(80);
 DCL SYSIN     FILE STREAM INPUT;
 DCL VALUES    CHAR(2000) VAR;
 DCL OPTS      CHAR(1000) VAR;
 DCL X         CHAR(1);       /* WORK BYTE TO PARSE EXEC_PARM */
     /* INPUT PARMS */
 DCL (DATE,TIME,BREAK,PGMS,INTVL,LMOD,ADRS) CHAR(100) VAR;
 /* THE FOLLOWING STRUCTURE WILL CONTAIN INFORMATION DERIVED FROM    */
 /* PARSING THE EXEC CARD PARAMETER.   THE INITIAL VALUES ARE        */
 /* THE DEFAULTS FOR EACH PARAMETER                                  */
 DCL 1 OPTIONS,
         5 DATE_SELECT   BIT(1)        INIT('0'B),
         5 TIME_SELECT   BIT(1)        INIT('0'B),
         5 PRINT_MODULES BIT(1)        INIT('0'B),
         5 WRITE_PSWS    BIT(1)        INIT('1'B),
         5 WRITE_ADDRS   BIT(1)        INIT('1'B),
         5 ADDR_ALLPLPA  BIT(1)        INIT('0'B),
         5 ADDR_ONEPLPA  BIT(1)        INIT('0'B),
         5 ADDR_ONEPRIV  BIT(1)        INIT('0'B),
         5 ADDR_CDENAME  CHAR(8)       INIT(' '),
         5 ADDR_PLPAHI   FIXED BIN(31) INIT(0),
         5 ADDR_PLPALO   FIXED BIN(31) INIT(0),
         5 STARTDATE     FIXED DEC(7)  INIT(0),
         5 STARTTIME     FIXED BIN(31) INIT(0),
         5 ENDDATE       FIXED DEC(7)  INIT(99365),
         5 ENDTIME       FIXED BIN(31),
         5 INTERVAL      FIXED BIN(31) INIT(0),
         5 #BREAKS       FIXED BIN(31) INIT(0),
         5 BKARRAY(50)   FIXED BIN(31);
 DCL OVER_24HRS FIXED BIN(31);
 OVER_24HRS = 24*60*60*100+1;
 ENDTIME = OVER_24HRS;
 %PAGE;
 DCL STDEPTR PTR;
 % INCLUDE STDE;
 %PAGE;
 DCL STDEBUFP PTR;  /* WE WANT TO USE OUR OWN POINTER NOT STDE */
 % INCLUDE PGBUF;
 %PAGE;
 /* THE FOLLOWING BUCKETS COLLECT THE VARIOUS STATE COUNTS FOR       */
 /* USE IN CALCULATING VARIOUS PERCENTAGES.                          */
 DCL 1 ACCUM,   /* STRUCTURE CONATINS VARS TO BE ZEROED AT BREAK     */
   2 MISSED     FLOAT DEC(16) INIT(0),    /* # MISSED SAMPLES        */
   2 OVERHEAD   FLOAT DEC(33) INIT(0),    /* SAMPLING OVERHEAD       */
   2 SAMPTIME   FLOAT DEC(33) INIT(0),    /* SAMPLING TIME           */
   2 RECORDS    FLOAT DEC(16) INIT(0),    /* NUMBER OF PGBUFS USED   */
   2 RCTINFO,                   /* STATISTICS FROM PGBUF.RCTINFO     */
       3 UICA    FLOAT DEC(16) INIT(0),
       3 CPUA    FLOAT DEC(16) INIT(0),
       3 AVQC    FLOAT DEC(16) INIT(0),
       3 AFC     FLOAT DEC(16) INIT(0),
       3 ASMQ    FLOAT DEC(16) INIT(0),
       3 PTR     FLOAT DEC(16) INIT(0),
       3 DPR     FLOAT DEC(16) INIT(0),
       3 PAGRT   FLOAT DEC(16) INIT(0),
       3 MSPP    FLOAT DEC(33) INIT(0),
   2 PVTINFO,                   /* STATISTICS FROM PGBUF.PVTINFO     */
       3 POOL    FLOAT DEC(33) INIT(0),
       3 CFMCT   FLOAT DEC(33) INIT(0),
       3 CNTFX   FLOAT DEC(33) INIT(0),
       3 SQAFX   FLOAT DEC(33) INIT(0),
       3 COMFX   FLOAT DEC(33) INIT(0),
   2 DMNINFO(MAXDMN),                    /*STATISTICS FROM PGBUF.DMN */
       3 DMN#    FIXED BIN(31) INIT(0),
       3 DMNSTATS(3),   /* MIN / TOTAL / MAX */
            4 TMPL    FLOAT DEC(33) INIT(0),
            4 CMPL    FLOAT DEC(33) INIT(0),
            4 RUA     FLOAT DEC(33) INIT(0),
   2 KEYS(0:15) FLOAT DEC(16) INIT((16) 0), /* BY PROTECT KEY        */
     /* THE FOLLOWING 2 ENTRY ARRAYS ARE SUBSCRIBTED BY THE CPUID
        CPU0 = 1,  CPU1 = 2           */
   2 (PBLMCOUNT(2),                       /* PROBLEM STATE           */
         SAMPLE(2),                       /* SAMPLE SIZE             */
         ACTIVES(2),                      /* NON-WAIT                */
         USERCOUNT(2),                    /* PBLM & KEY>7            */
         RELATIVE,                        /* PSW ADDR RELATIVE       */
         JPA_SEARCHED,                    /* SEARCHED JOB PACK       */
         JPA_FOUND,                       /* FOUND CDE IN JOB PACK   */
         LOCK_CODE,                       /* PSW FOUND IN LOCK MANGR */
         TCBRDYS)                         /* COUNT READY TCBS        */
         FLOAT DEC(16) INIT(0),           /*                         */
   2 SUP,                                 /* SUP BREAKDOWN           */
        3 SVCST FLOAT DEC(16) INIT(0),     /* SVC IN TCB             */
        3 SRBST FLOAT DEC(16) INIT(0),     /* SRB                    */
        3 OTHER FLOAT DEC(16) INIT(0),     /* ALL ELSE               */
   2 SVCS(0:255) FLOAT DEC(16) INIT((256) 0), /* BY SVC NUMBER       */
   2 PG(0:999) FLOAT DEC(16) INIT((1000) 0), /* BY PERFORM           */
   2 (TENSVC,TENPGM,TENPERF)
                     (0:9) FIXED BIN(31); /* TOP 10                  */
 DCL 1 ERROR (MAXERRS),           /* DISTRIBUTION OF PSW ERROR CODES */
        2 CODE        CHAR(4) INIT('    '),
        2 COUNT FLOAT DEC(16) INIT(0);
 %PAGE;
 /* MISCELANEOUS DECLARATIONS                                        */
 DCL (LASTDATE ,  /* DATE OF LAST RECORD PROCESSED */
      FIRSTDATE ,  /* DATE OF FIRST SAMPLE */
      NEXTDATE)   /* DATE OF NEXT BREAK */
      FIXED DEC(7) INIT(0);
      FIRSTDATE=999999;
 DCL (LASTTIME ,  /* TIME OF LAST RECORD PROCESSED */
      FIRSTTIME,   /* TIME OF FIRST SAMPLE */
      NEXTTIME )  /* TIME OF NEXT BREAK */
      FIXED BIN(31) INIT(0);
      FIRSTTIME=ENDTIME;
 DCL @WORK PTR;
 DCL SMFIN  INPUT FILE RECORD;  /*WISH I COULD TO TOTAL HERE BUT VBS*/
 DCL PSWS  OUTPUT FILE RECORD ENV(FB RECSIZE(17) TOTAL);
 DCL PSW_REC CHAR(17) BASED(@WORK);
 DCL ADDRS OUTPUT FILE RECORD ENV(FB RECSIZE(4)  TOTAL);
 DCL DIRECT INPUT FILE RECORD;
 DCL DIRPTR PTR;
 DCL 1 DIRIN BASED(DIRPTR),
       4 NAME CHAR(8),
       4 (START,SIZE) FIXED BIN(31),
     1 DIRSTAT UNAL,
       4 (MODCOUNT,LPALOW,LPAHIGH,FILL) FIXED BIN(31);
 DCL (TEMP1, TEMP2, INSADDR) FIXED BIN(31);
 DCL PSW_COUNT FIXED BIN(31);
 DCL CURRENT_PGBUFF FIXED BIN(15) INIT(0);
 DCL CPU# FIXED BIN(31);
 DCL KEY  CHAR(8);
 DCL WORK_TIMESTAMP BIT(64) ALIGNED;
 DCL TITLELINE CHAR(100)  VAR; /* TO APPEAR AT TOP OF PAGE */
 DCL (ABS,ADDR,BOOL,NULL,STRING,SUBSTR,UNSPEC,MOD,ONCODE,
     MIN,HBOUND,PLIRETV,SUM,INDEX,MAX,LENGTH,VERIFY) BUILTIN;
 DCL LOADPTR ENTRY(CHAR(8),PTR) OPTIONS(ASM INTER RETCODE);
 DCL SDL ENTRY(*,*);
 DCL PTRIN   ENTRY(PTR) RETURNS(FIXED BIN(31));
 DCL PTROUT  ENTRY(FIXED BIN(31)) RETURNS(PTR);
 DCL SYSPRINT FILE OUTPUT PRINT;
 DCL INTERNAL BIT(1) INIT('0'B);  /* SET TO 1 IF NOT SMFIN */
 DCL FIRST_TIME_THRU BIT(1) INIT('1'B);
 DCL SMFID_BIT BIT(8)  INIT('10101001'B) ALIGNED;/*SMFID BIT FORMAT */
 DCL (I,J,L,II) FIXED BIN(31);
 %PAGE;
  /* HASH VARIABLES                                                  */
 /* TO EFFICIENTLY TABULATE THE PROGRAM NAMES, A HASHING             */
 /* TECHNIQUE IS USED FOR TABLE LOOKUP. THE EIGHT BYTE NAME          */
 /* IS DIVIDED UP INTO 16 BIT PIECES WHICH ARE EXCLUSIVE             */
 /* OR'D TOGETHER, THEN DIVIDED BY A PRIME NUMBER AND THE            */
 /* REMAINDER IS USED TO INDEX INTO 'HASHTAB'. THE ENTRY             */
 /* IN 'HASHTAB' POINTS TO THE FIRST ENTRY IN THE 'HASHBUCKET'       */
 /* STRUCTURE WHICH HASHED TO THAT INDEX, AND SUBSEQUENT             */
 /* NAMES WHICH HASH TO THE SAME NAME ARE CHAINED OFF                */
 /* HASHBUCKET.HASHCHAIN.                                            */
 DCL 1 HASHTAB(0:MODULUS) FIXED BIN INIT((MODULUS1) -1);
 DCL NEXTBUCKET FIXED BIN INIT(-1);
 DCL 1 HASHBUCKET(0:HSIZE),
   2 HASHNAME  CHAR(8),
   2 HASHCHAIN FIXED BIN(15),
   2 HASHCOUNT FLOAT DEC(16);
 DCL KEYBITS(4) BIT(16) ALIGNED;
 DCL INDX FIXED BIN(15);
 %PAGE;
 DCL DUMMY FILE;
 ON NAME(DUMMY)
    BEGIN;
    PUT SKIP LIST (' YOU HAVE SPECIFIED AN INCORRECT PARAMETER.');
    STOP;
    END;
 ON CONVERSION SNAP
    BEGIN;
    PUT SKIP LIST
      (' THERE IS AN INVALID CHARACTER IN A NUMERIC PARAMETER.');
    STOP;
    END;
 ON ERROR SNAP
    BEGIN;
    ON ERROR SYSTEM;
    PUT DATA;
    END;
 OPTS = EXEC_PARM;
 ON UNDEFINEDFILE(SYSIN)
    BEGIN;
    IF ONCODE=84 THEN GO TO PARSE;
    ELSE
       DO;
       PUT SKIP EDIT('EXPECTED UNDEFINED FILE ON SYSIN. ONCODE=',
                      ONCODE) (A,F(4));
       STOP;
       END;
    END;
 ON ENDFILE(SYSIN)       GO TO PARSE;
 OPEN FILE(SYSIN) INPUT;
 DO  I = 1 TO 999 UNTIL (LENGTH(OPTS) > 2000-72);;
     GET EDIT(CARD) (A(80));
     OPTS = OPTS ×× SUBSTR(CARD,1,72);
 END;
 %SKIP(2);
 PARSE: CLOSE FILE(SYSIN);
    DO I=1 TO LENGTH(OPTS);  /* SCAN EVERY CHARACTER IN PARM */
    X = SUBSTR(OPTS,I,1);
    IF X=' ' THEN LEAVE;
    IF X=',' THEN VALUES=VALUES××'''';
    VALUES=VALUES××X;
    IF X='=' THEN VALUES=VALUES××'''';
 END;
 IF LENGTH(VALUES)>0 THEN VALUES=VALUES××'''';
 VALUES=VALUES××'; ';
 GET STRING(VALUES) DATA;
 %PAGE;
 IF DATE^=' ' THEN
    DO;
    IF LENGTH(DATE)=5 THEN
       STARTDATE = DATE;
    ELSE
    IF LENGTH(DATE)=11 & SUBSTR(DATE,6,1)='-' THEN
       DO;
       STARTDATE = SUBSTR(DATE,1,5);
       ENDDATE   = SUBSTR(DATE,7,5);
       END;
    ELSE
       DO;
       PUT SKIP LIST('DATE PARM IS INVALID.  FORMAT: YYDDD(-YYDDD)');
       STOP;
       END;
    IF ENDDATE<STARTDATE THEN
       DO;
       PUT SKIP EDIT('DATE RANGE GIVEN IN PARM IS NOT IN ASCENDING',
                     ' ORDER.') (A,A);
       STOP;
       END;
    DATE_SELECT = '1'B;
    END;
 %SKIP(2);
 IF TIME^=' ' THEN
    DO;
    IF LENGTH(TIME)=9 & SUBSTR(TIME,5,1)='-' THEN
       DO;
       STARTTIME =(SUBSTR(TIME,1,2) * (60*60)  /* HRS TO SECONDS */
                 + SUBSTR(TIME,3,2) * (60)   )/* MINS TO SECONDS */
                 * 100;       /* TO SMF FORMAT (100'THS SECONDS) */
       ENDTIME   =(SUBSTR(TIME,6,2) * (60*60)  /* HRS TO SECONDS */
                 + SUBSTR(TIME,8,2) * (60)   )/* MINS TO SECONDS */
                 * 100;       /* TO SMF FORMAT (100'THS SECONDS) */
       END;
    ELSE
       DO;
       PUT SKIP LIST('TIME PARM IS INVALID.  FORMAT:  HHMM-HHMM');
       STOP;
       END;
   IF STARTTIME > ENDTIME THEN
       DO;
       PUT SKIP EDIT('TIME RANGE GIVEN IN PARM IS NOT IN ASCENDING',
                     ' ORDER.') (A,A);
       STOP;
       END;
   TIME_SELECT = '1'B;
   END;
 %PAGE;
 IF BREAK^=' ' THEN
    DO #BREAKS = 1 TO HBOUND(BKARRAY,1)
        WHILE((#BREAKS-1)*5<LENGTH(BREAK));
       J = (#BREAKS-1)*5;
       IF #BREAKS > 1 & SUBSTR(BREAK,J,1)^='-' THEN
          DO;
          PUT SKIP LIST('BREAK TIMES ARE NOT SEPARATED BY HYPHENS.');
          STOP;
          END;
       IF LENGTH(BREAK) < J + 4 THEN
          DO;
          PUT SKIP LIST('LAST BREAK TIME IS TOO SHORT.');
          STOP;
          END;
       BKARRAY(#BREAKS) =(SUBSTR(BREAK,J+1,2) * (60*60)
                        + SUBSTR(BREAK,J+3,2) * (60)   )
                        * 100;
       IF #BREAKS > 1 & BKARRAY(#BREAKS)<BKARRAY(#BREAKS-1) THEN
          DO;
          PUT SKIP EDIT('BREAK TIMES MUST BE GIVEN IN ASCENDING',
                ' ORDER.') (A,A);
          STOP;
          END;
    END;
 %SKIP(2);
 IF INTVL^=' ' THEN
    DO;
    IF #BREAKS > 0 THEN
       DO;
       PUT SKIP LIST('BREAK AND INTVL ARE MUTUALLY EXCLUSIVE.');
       STOP;
       END;
    ELSE
       DO;
       GET STRING(INTVL) LIST(INTERVAL);
       INTERVAL = INTERVAL * (60*100);  /* CONVERT TO 100THS OF SEC */
       END;
    END;
 %PAGE;
 IF LMOD ^= ' ' THEN
    IF LMOD = '*REL' × (LENGTH(LMOD) > 0 & LENGTH(LMOD) < 9) THEN;
    ELSE
       DO;
       PUT SKIP LIST('LMOD PARM IS INVALID.');
       STOP;
       END;
 %SKIP(2);
 IF ADRS ^= ' ' THEN
  DO;
         IF ADRS = '*' THEN ADDR_ALLPLPA = '1'B;
    ELSE IF SUBSTR(ADRS,1,1) = '*' THEN
            DO;
            ADDR_ONEPLPA = '1'B;
            ADDR_CDENAME = SUBSTR(ADRS,2,LENGTH(ADRS)-1) ×× '       ';
            END;
    ELSE
            DO;
            ADDR_ONEPRIV = '1'B;
            ADDR_CDENAME = ADRS ×× '       ';
            END;
  END;
 %SKIP(2);
 IF PGMS='YES' THEN PRINT_MODULES = '1'B;
 %PAGE;
 REVERT CONVERSION;
 %SKIP(3);
 /* COMPOSE TITLE LINE */
 TITLELINE='STATDIE REPORT-';
 IF DATE_SELECT × TIME_SELECT THEN
    DO;
    TITLELINE=TITLELINE××'ONLY SAMPLES BETWEEN ';
    IF DATE_SELECT THEN
       TITLELINE=TITLELINE××'DATES '××DATE;
    IF TIME_SELECT THEN
       TITLELINE=TITLELINE××' TIMES '××TIME;
    TITLELINE=TITLELINE××' INCLUDED';
    END;
 ELSE TITLELINE=TITLELINE××'ALL SAMPLES INCLUDED';
 %PAGE;
 ON UNDEFINEDFILE(ADDRS)
    BEGIN;
    IF ONCODE=84 THEN WRITE_ADDRS='0'B;
    ELSE
       DO;
       PUT SKIP EDIT('UNEXPECTED UNDEFINEDFILE ON ADDRS. ONCODE=',
                     ONCODE) (A,F(4));
       STOP;
       END;
    END;
 OPEN FILE(ADDRS) OUTPUT;
 IF WRITE_ADDRS THEN
    DO;
    ON ENDFILE(DIRECT)
       BEGIN;
       PUT SKIP LIST('UNEXPECTED END OF DIRECT FILE.');
       IF  ADDR_ONEPLPA THEN
               PUT SKIP LIST('REQUESTED MODULE NOT IN PLPA');
       STOP;
       END;
    ON UNDEFINEDFILE(DIRECT)
       BEGIN;
       PUT SKIP LIST('DIRECT FILE REQUIRED FOR ADRS=*');
       STOP;
       END;
    IF ADDR_ALLPLPA THEN
       DO;
       READ FILE(DIRECT) INTO(DIRSTAT);
       ADDR_PLPALO = LPALOW;
       ADDR_PLPAHI = LPAHIGH;
       CLOSE FILE(DIRECT);
       END;
    ELSE
    IF ADDR_ONEPLPA THEN
       DO;
       READ FILE(DIRECT) SET(DIRPTR);
       DO WHILE(ADDR_CDENAME ^= DIRIN.NAME);
          READ FILE(DIRECT) SET(DIRPTR);
       END;
       ADDR_PLPALO = DIRIN.START;
       ADDR_PLPAHI = DIRIN.START+DIRIN.SIZE;
       CLOSE FILE(DIRECT);
       END;
    ELSE
    IF ^ADDR_ONEPRIV THEN
       DO;
       PUT SKIP LIST('ADRS PARM MUST BE SUPPLIED WITH ADDRS FILE.');
       STOP;
       END;
    END;
 %PAGE;
 ON UNDEFINEDFILE(SMFIN)
    BEGIN;
    IF ONCODE=84 THEN INTERNAL='1'B;
    ELSE
       DO;
       PUT SKIP EDIT('UNEXPECTED UNDEFINEDFILE ON SMFIN. ONCODE=',
                     ONCODE) (A,F(4));
       STOP;
       END;
    END;
 OPEN FILE(SMFIN);    /* WILL RAISE UNDEFINED IF NOT THERE */
 ON ENDFILE(SMFIN) GO TO FINN;
 %SKIP;
 ON UNDEFINEDFILE(PSWS)
    BEGIN;
    IF ONCODE=84 THEN WRITE_PSWS='0'B;
    ELSE
       DO;
       PUT SKIP EDIT('UNEXPECTED UNDEFINEDFILE ON PSWS. ONCODE=',
                     ONCODE) (A,F(4));
       STOP;
       END;
    END;
 OPEN FILE(PSWS) OUTPUT;
 %PAGE;
 HASHNAME='********';
 HASHCOUNT=0;
 %SKIP(2);
 IF INTERNAL THEN   /* FIND AND USE CSA PGBUF'S INSTEAD OF SMF   */
    DO;
    CALL LOADPTR('STATSTDE',STDEPTR);
    IF PLIRETV>0 THEN DO;
       PUT EDIT('UNABLE TO LOCATE STATDIE MODULE')(COL(1),A);
       STOP;
       END;
    IF ^STDEFLGS&STDEATIV THEN
       DO;
       PUT EDIT('STATDIE EXIT IS NOT ACTIVE')(COL(1),A);
       RETURN;
       END;
    IF STDETQE(14)&'1'B THEN
       DO;
       PUT EDIT('STATDIE EXIT HAS BEEN PURGED BY AN ERROR')(COL(1),A);
       RETURN;
       END;
    STDEBUFP = STDE.STDEBUFP;  /* INITIALIZE CSA POINTER */
    STDEBUFP = PTROUT (PTRIN(STDEBUFP) + 4);  /* BUMP PAST RDW */
    END;
 %PAGE;
 PRLOOP:
 IF ^INTERNAL THEN READ FILE(SMFIN) SET(STDEBUFP);
 ELSE    /* GET NEXT CSA PG BUFFER */
    DO;
    IF CURRENT_PGBUFF = STDEPCNT THEN GO TO FINN;
    IF CURRENT_PGBUFF > 0 THEN
       STDEBUFP       = PTROUT (PTRIN (STDEBUFP) + STDEPLEN);
    CURRENT_PGBUFF = CURRENT_PGBUFF + 1;
    END;
 %SKIP(2);
 IF HDRRTY^=SMFID_BIT
  × HDRTME<STARTTIME  × HDRTME> ENDTIME
  × HDRDTE<STARTDATE  × HDRDTE> ENDDATE    THEN GO TO PRLOOP;
 %PAGE;
 /* IF BREAKS WERE REQUESTED AND WE HAVE GONE OVER A BREAK
    TIME, PRINT OUT ACCUMULATED DATA IF ANY AND REINITIALIZE */
 %SKIP;
 IF #BREAKS>0 × INTERVAL > 0
    THEN IF (HDRDTE>NEXTDATE) ×
            (HDRDTE=NEXTDATE & HDRTME>NEXTTIME)
    THEN DO;  /* HAVE HIT A BREAK */
       IF SUM(SAMPLE)>0   /* IF HAVE ANY ACCUMULATED DATA */
          THEN DO;
               CALL PRINTOUT;
               CALL REINIT;
               END;
 %SKIP;
       /* DETERMINE NEXTDATE,NEXTTIME */
      IF #BREAKS > 0 THEN
         DO;
         NEXT: DO J=1 TO #BREAKS;
            IF HDRTME<BKARRAY(J)
               THEN DO;
                    NEXTTIME=BKARRAY(J);
                    NEXTDATE=HDRDTE;
                    LEAVE NEXT;
                    END;
         END NEXT;
        IF J>#BREAKS THEN DO;
           NEXTTIME=BKARRAY(1);
           NEXTDATE=HDRDTE+1;
           END;
       END;
     ELSE  /* MUST BE INTERVAL */
        DO;
        IF FIRST_TIME_THRU THEN
           DO;
           FIRST_TIME_THRU = '0'B;
           NEXTDATE = HDRDTE;
           NEXTTIME = HDRTME;
           END;
        J = NEXTTIME + INTERVAL;
        IF  J + 2 > OVER_24HRS THEN
            DO;
            NEXTDATE = HDRDTE + 1;
            NEXTTIME = J - OVER_24HRS + 1;
            END;
        ELSE NEXTTIME = J;
        END;
     END;
 %PAGE;
  /* NOW ACCUMUALTE STATS FROM HEADER SECTION OF PGBUF              */
 IF HDRDTE<FIRSTDATE THEN
    DO;
    FIRSTDATE = HDRDTE;
    FIRSTTIME = HDRTME;
    END;
 ELSE
    IF HDRDTE=FIRSTDATE & HDRTME < FIRSTTIME THEN FIRSTTIME = HDRTME;
 %SKIP(2);
 IF HDRDTE>LASTDATE THEN
    DO;
    LASTDATE = HDRDTE;
    LASTTIME = HDRTME;
    END;
 ELSE
    IF HDRDTE=LASTDATE & HDRTME > LASTTIME THEN LASTTIME = HDRTME;
 %SKIP(2);
 @RDW = ADDR (PSWRDW);
 IF FIELD_TYPE ^= PSW_TYPE THEN
    DO;
    PUT SKIP LIST('PGBUF RECORD DESRIPTION INCORECT. PSW_TYPE WRONG.');
    SIGNAL ERROR;
    END;
 PSW_COUNT = TOTAL_LENGTH / ITEM_LENGTH;
 IF PSW_COUNT ^= SRBINTVL THEN
    DO;
    PUT SKIP LIST('PSW_COUNT GREATER THAN SRBINTVL');
    SIGNAL ERROR;
    END;
 MISSED   = MISSED   + MISSED_SAMPLES;
 OVERHEAD = OVERHEAD + SUBSTR(OVHD,1,52);
 WORK_TIMESTAMP = LAST;
 CALL SDL (WORK_TIMESTAMP, FIRST);
 SAMPTIME = SAMPTIME + SUBSTR(WORK_TIMESTAMP,1,52);
 RECORDS      = RECORDS      + 1;         /* BUMP # RECORDS */
 ACCUM.UICA   = ACCUM.UICA   + PGBUF.UICA;
 ACCUM.CPUA   = ACCUM.CPUA   + PGBUF.CPUA;
 ACCUM.AVQC   = ACCUM.AVQC   + PGBUF.AVQC;
 ACCUM.AFC    = ACCUM.AFC    + PGBUF.AFC;
 ACCUM.ASMQ   = ACCUM.ASMQ   + PGBUF.ASMQ;
 ACCUM.PTR    = ACCUM.PTR    + PGBUF.PTR;
 ACCUM.DPR    = ACCUM.DPR    + PGBUF.DPR;
 ACCUM.PAGRT  = ACCUM.PAGRT  + PGBUF.PAGRT;
 ACCUM.MSPP   = ACCUM.MSPP   + PGBUF.MSPP;
 ACCUM.POOL   = ACCUM.POOL   + PGBUF.POOL;
 ACCUM.CFMCT  = ACCUM.CFMCT  + PGBUF.CFMCT;
 ACCUM.CNTFX  = ACCUM.CNTFX  + PGBUF.CNTFX;
 ACCUM.SQAFX  = ACCUM.SQAFX  + PGBUF.SQAFX;
 ACCUM.COMFX  = ACCUM.COMFX  + PGBUF.COMFX;
 %PAGE;
 /*   GATHER DOMAIN STATS NOW (FROM HEADER TOO)  */
 DO I = 1 TO MAXDMN;
    IF I > 1 & DMDTENTRY.DMN#(I) = 0 THEN LEAVE;
    IF DMNINFO.DMN#(I) = 0 THEN
       DO;
       DMNINFO.DMN#(I)      = DMDTENTRY.DMN#(I);
       DMNINFO.TMPL(I,*) = DMDTENTRY.TMPL(I);
       DMNINFO.CMPL(I,*) = DMDTENTRY.CMPL(I);
       DMNINFO.RUA (I,*) = DMDTENTRY.RUA (I);
       END;
    ELSE
       IF DMNINFO.DMN#(I) = DMDTENTRY.DMN#(I) THEN
          DO;
          DMNINFO.TMPL(I,2) = DMNINFO.TMPL(I,2) +
                                 DMDTENTRY.TMPL(I);
          IF DMNINFO.TMPL(I,1) > DMDTENTRY.TMPL(I) THEN
             DMNINFO.TMPL(I,1) = DMDTENTRY.TMPL(I);
          IF DMNINFO.TMPL(I,3) < DMDTENTRY.TMPL(I) THEN
             DMNINFO.TMPL(I,3) = DMDTENTRY.TMPL(I);
          DMNINFO.CMPL(I,2) = DMNINFO.CMPL(I,2) +
                                 DMDTENTRY.CMPL(I);
          IF DMNINFO.CMPL(I,1) > DMDTENTRY.CMPL(I) THEN
             DMNINFO.CMPL(I,1) = DMDTENTRY.CMPL(I);
          IF DMNINFO.CMPL(I,3) < DMDTENTRY.CMPL(I) THEN
             DMNINFO.CMPL(I,3) = DMDTENTRY.CMPL(I);
          DMNINFO.RUA (I,2) = DMNINFO.RUA (I,2) +
                                 DMDTENTRY.RUA (I);
          IF DMNINFO.RUA (I,1) > DMDTENTRY.RUA (I) THEN
             DMNINFO.RUA (I,1) = DMDTENTRY.RUA (I);
          IF DMNINFO.RUA (I,3) < DMDTENTRY.RUA (I) THEN
             DMNINFO.RUA (I,3) = DMDTENTRY.RUA (I);
          END;
 END;
 %PAGE;
 /*  NOW PASS THRU THE PSW BUFFER IN PGBUF AND ACCUMULATE STATS */
 DO II=1 TO PSW_COUNT;
 INITIAL:DO;
 IF FLAGS(II)=(8)'0'B & (ADDRESS(II)=(24)'0'B × ADDRESS(II)=(24)'1'B)
          THEN LEAVE INITIAL;
 IF SUBSTR(FLAGS2(II),8,1)='0'B THEN CPU#=1;
                                ELSE CPU#=2;
 SAMPLE(CPU#)=SAMPLE(CPU#)+1;
 IF FLAGS2(II)&PSWERROR THEN
    DO;
    DO L = 1 TO MAXERRS
       UNTIL (CODE(L) = (4)' ' × CODE(L) = SUBSTR (CDENAME(II),5,4));
    END;
    IF L > MAXERRS THEN
       DO;
       PUT EDIT ('ERROR CODE TABLE OVERFLOW ON CDENAME=', CDENAME(II))
                (A,A);
       LEAVE INITIAL;
       END;
    ELSE
       DO;
       IF CODE(L) = (4)' ' THEN  CODE(L) = SUBSTR (CDENAME(II), 5, 4);
       COUNT(L) = COUNT(L) + 1;
       END;
    LEAVE INITIAL;
    END;
 %PAGE;
 IF FLAGS(II)&WAIT THEN;
 ELSE
 ACTIVE:  DO;
          IF WRITE_PSWS  & (LMOD = ' '  ×
              (LMOD = '*REL' & FLAGS2(II)&RELADDR) ×
              (LMOD = CDENAME(II)))  THEN
              DO;
              @WORK = ADDR(PSW(II));   /* FAKE OUT PL/1 */
              WRITE FILE(PSWS) FROM (PSW_REC);
              END;
 %SKIP;
          IF WRITE_ADDRS THEN
  PUT_ADDR:  DO;
             INSADDR=UNSPEC('00000000'B××ADDRESS(II));
             IF ADDR_ALLPLPA × ADDR_ONEPLPA THEN
                DO;
                IF INSADDR>ADDR_PLPALO & INSADDR<ADDR_PLPAHI THEN
                   DO;
                   IF ADDR_ONEPLPA THEN
                      INSADDR = INSADDR - ADDR_PLPALO;
                   END;
                ELSE
                   LEAVE PUT_ADDR;
                END;
             ELSE
                DO;
                IF CDENAME(II)=ADDR_CDENAME & RELADDR THEN;
                ELSE LEAVE PUT_ADDR;
                END;
             WRITE FILE(ADDRS) FROM(INSADDR);
             END;
 %PAGE;
          ACTIVES(CPU#)=ACTIVES(CPU#)+1;
          J=FLAGS(II)/16;
          KEYS(J)=KEYS(J)+1;
          TCBRDYS=TCBRDYS+TCBRDY(II);
          PG(PERFORM(II))=PG(PERFORM(II))+1;
          IF FLAGS2(II)&RELADDR    THEN RELATIVE=RELATIVE+1;
          IF FLAGS2(II)&JOBPACK1 THEN JPA_SEARCHED=JPA_SEARCHED+1;
          IF FLAGS2(II)&JOBPACK2 THEN JPA_FOUND=JPA_FOUND+1;
          IF FLAGS2(II)&INLOCK   THEN LOCK_CODE=LOCK_CODE+1;
          IF FLAGS(II)&SVCMD THEN SVCS(SVC(II))=SVCS(SVC(II))+1;
          IF FLAGS(II)&PBLM THEN
             DO;
             PBLMCOUNT(CPU#)=PBLMCOUNT(CPU#)+1;
             IF FLAGS(II)&'1'B THEN   USERCOUNT(CPU#)=USERCOUNT(CPU#)+1;
             END;
          ELSE
             IF FLAGS(II)& SRB THEN SRBST=SRBST+1;
             ELSE IF FLAGS(II)& SVCMD THEN SVCST=SVCST+1;
             ELSE OTHER=OTHER+1;
          IF PRINT_MODULES & SUBSTR (CDENAME(II),1,1)^=' ' THEN
 HASH:       DO;
             KEY=CDENAME(II);
             STRING(KEYBITS)=UNSPEC(KEY);
             KEYBITS(1)=BOOL(BOOL(KEYBITS(1),KEYBITS(2),'0110'B),
                BOOL(KEYBITS(1),KEYBITS(2),'0110'B),'0110'B);
             INDX=MOD(KEYBITS(1),MODULUS);
 OLDENTRY:      DO;
                IF HASHTAB(INDX)<0 THEN
                   DO;
                   NEXTBUCKET=NEXTBUCKET+1;
                   IF NEXTBUCKET>SIZE THEN
                      DO;
                      PUT EDIT('TOO MANY UNIQUE MODULE NAMES')
                              (COL(1), A);
                      SIGNAL ERROR;
                      END;
                   HASHTAB(INDX)=NEXTBUCKET;
                   INDX=NEXTBUCKET;
                   LEAVE OLDENTRY;
                   END;
                ELSE
                   DO   INDX=HASHTAB(  INDX)
                      REPEAT HASHCHAIN(INDX)
                      UNTIL(HASHCHAIN(INDX)=0);
                   IF KEY=HASHNAME(INDX) THEN
                      DO;
                      HASHCOUNT(INDX)=HASHCOUNT(INDX)+1;
                      LEAVE HASH;
                      END;
                   END;
                NEXTBUCKET=NEXTBUCKET+1;
                IF NEXTBUCKET>SIZE THEN SIGNAL ERROR;
                HASHCHAIN(INDX)=NEXTBUCKET;
                INDX=NEXTBUCKET;
                END OLDENTRY;
             HASHNAME(INDX)=KEY;
             HASHCHAIN(INDX)=0;
             HASHCOUNT(INDX)=1;
             END HASH;
          END ACTIVE;
       END INITIAL;
    END;
 GO TO PRLOOP;   /* LOOP UNTIL END OF FILE/RING */
 %PAGE;
 FINN: IF SUM(SAMPLE)>0 THEN CALL PRINTOUT;
   RETURN;
 %PAGE;
 (NOZERODIVIDE): PRINTOUT: PROC REORDER;
 DCL AKTIVES  FLOAT DEC(16);
 AKTIVES=SUM(ACTIVES);
 PUT PAGE EDIT(TITLELINE) (A);
 PUT EDIT('SELECTED: ', DTECHAR(FIRSTDATE),TMECHAR(FIRSTTIME),
          ' THRU ',     DTECHAR(LASTDATE), TMECHAR(LASTTIME))
         (COL(1),A,X(5),A,X(1),A,X(3),A,A,X(1),A);
 PUT EDIT('SAMPLES:',SAMPLE(1),'/',SAMPLE(2),'/',MISSED,
           ' INTERFERENCE %', /* 0 MEANS NO DISABLED INTERFERENCE */
 ((SAMPTIME-((SUM(SAMPLE)-RECORDS)*1000*MILLISC))*1000*100)
       /((SUM(SAMPLE)-RECORDS)*MILLISC*1000) )
         (COL(1),A,F(9),A,F(9),A,F(5),A,X(2),P'---9.999');
 PUT SKIP LIST(' ');
 PUT EDIT('CPU UTILIZATION',ACTIVES*1000/SAMPLE,'STATDIE OVHD',
  OVERHEAD*10000/SAMPTIME,
 'SUPERVISOR STATE',(ACTIVES-PBLMCOUNT)*1000/ACTIVES,'LOCK CODE',
 LOCK_CODE*10000/AKTIVES,
 'USERSTATE',USERCOUNT*1000/ACTIVES,'READY TCBS',TCBRDYS*100/AKTIVES)
 (COL(1),A(18),2 (P'ZZ9.9',X(2)),COL(35),A(18),P'Z9.99',
  COL(1),A(18),2 (P'ZZ9.9',X(2)),COL(35),A(18),P'Z9.99',
  COL(1),A(18),2 (P'ZZ9.9',X(2)),COL(35),A(17),P'ZZ9.99');
 PUT SKIP LIST(' ');
 PUT EDIT('SUPERVISOR STATE IS  SVC:',SVCST*1000/AKTIVES,
 '    SRB:',SRBST*1000/AKTIVES, '  OTHER:',OTHER*1000/AKTIVES)
 (COL(1), (3) (A,P'ZZ9.9'));
 CALL FIND10(TENSVC,SVCS);
 IF PRINT_MODULES THEN CALL FIND10(TENPGM,HASHCOUNT);
 ELSE TENPGM = 0;
 CALL FIND10(TENPERF,PG);
 PUT EDIT('KEY  PCT  ×  SVC  PCT  ×  PG   PCT  ×  PGM        PCT  ',
 (I,KEYS(I)*1000/AKTIVES,'×',TENSVC(I),SVCS(TENSVC(I))*1000/AKTIVES,'×',
 TENPERF(I),PG(TENPERF(I))*1000/AKTIVES,'×',HASHNAME(TENPGM(I)),
 HASHCOUNT(TENPGM(I))*1000/AKTIVES DO I=0 TO 9))(COL(1),A, (10)
 (COL(1),F(2),X(2),P'Z9.9',X(2),A(1),X(2),F(3),X(1),P'Z9.9',X(2),A(1),
 X(2),F(2),X(2),P'Z9.9',X(2),A(1),X(2),A(8),X(2),P'Z9.9'));
 PUT SKIP(1) LIST(' ');
 PUT EDIT('STATDIE STATS:','RELATIVIZED',RELATIVE*1000/AKTIVES,
 'JPAC S/F ',JPA_SEARCHED*1000/AKTIVES,'/',JPA_FOUND*1000/JPA_SEARCHED)
 (COL(1),A,X(2),A,P'ZZ9.9',X(1),A,P'ZZ9.9',A,P'ZZ9.9');
 IF SUM(ERROR.COUNT) > 0 THEN /* WE MAY HAVE PSW SAMPLING ERRORS */
    DO;
    PUT SKIP(1) LIST(' ');
    PUT EDIT ('==>PSW SAMPLING ERROR(S) OCCURRED: *******') (COL(1),A);
    PUT EDIT ('   CODE      NUMBER')                        (COL(1),A);
    DO I = 1 TO MAXERRS;
       IF ERROR.COUNT(I) > 0 THEN
     PUT EDIT(ERROR.CODE(I), ERROR.COUNT(I)) (COL(4),A,X(6),P'ZZZZZ9');
    END;
    END;
 %PAGE;
 /*  NOW PRINT RCT, PVT AND DOMAIN INFO */
 ACCUM.UICA   = ACCUM.UICA     / RECORDS;
 ACCUM.CPUA   = ACCUM.CPUA*10  / RECORDS;
 ACCUM.AFC    = ACCUM.AFC      / RECORDS;
 ACCUM.ASMQ   = ACCUM.ASMQ     / RECORDS;
 ACCUM.PTR    = ACCUM.PTR *10  / RECORDS;
 ACCUM.DPR    = ACCUM.DPR *10  / RECORDS;
 ACCUM.PAGRT  = ACCUM.PAGRT*10 / RECORDS;
 ACCUM.MSPP   = ACCUM.MSPP     / RECORDS;
 ACCUM.POOL   = ACCUM.POOL     / RECORDS;
 ACCUM.CFMCT  = ACCUM.CFMCT    / RECORDS;
 ACCUM.CNTFX  = ACCUM.CNTFX    / RECORDS;
 ACCUM.SQAFX  = ACCUM.SQAFX    / RECORDS;
 ACCUM.COMFX  = ACCUM.COMFX    / RECORDS;
 PUT SKIP LIST(' ');
 PUT EDIT('UICA  CPUA AFC ASMQ  PTR  DPR PAGRT  MSPP  POOL CFMCT',
          ' CNTFX SQAFX COMFX') (COL(1),A,A);
 PUT EDIT(ACCUM.UICA,  ACCUM.CPUA,  ACCUM.AFC,   ACCUM.ASMQ,
          ACCUM.PTR,   ACCUM.DPR,   ACCUM.PAGRT, ACCUM.MSPP,
          ACCUM.POOL,  ACCUM.CFMCT, ACCUM.CNTFX, ACCUM.SQAFX,
          ACCUM.COMFX)
   (COL(1),P'ZZZ9',P'ZZZ9.9',P'ZZZ9',P'ZZZZ9',
        2 (P'ZZ9.9'),P'ZZZ9.9',P'Z9.999',6 (P'ZZZZZ9'));
  %SKIP(2);
  /*  PRINT DOMAIN STATISTICS */
 PUT EDIT (' ') (COL(1),X(40),A);    /* SKIP A LINE */
 PUT EDIT ('D O M A I N     S T A T I S T I C S  (MIN/AVG/MAX)')
          (COL(14),A);
 PUT EDIT ('      ') (COL(1),A);
 DO I = 1 TO MAXDMN;
    IF I>1 & ACCUM.DMN#(I) = 0 THEN LEAVE;
    PUT EDIT(ACCUM.DMN#(I)) (P'ZZZZZ9');
    DMNSTATS(I,2) = DMNSTATS(I,2) / RECORDS;  /* FIND AVERAGES */
 END;
 PUT SKIP(1) LIST('                 ');
 PUT EDIT ('TMPL',((ACCUM.TMPL(I,J) DO I=1 TO MAXDMN) DO J = 1 TO 3))
          (COL(1),A, 3 (COL(7), MAXDMN (P'ZZZZZZ')));
 PUT SKIP(1) LIST('                 ');
 PUT EDIT ('CMPL',((ACCUM.CMPL(I,J) DO I=1 TO MAXDMN) DO J = 1 TO 3))
          (COL(1),A, 3 (COL(7), MAXDMN (P'ZZZZZZ')));
 PUT SKIP(1) LIST('                 ');
 PUT EDIT ('RUA ',((ACCUM.RUA (I,J) DO I=1 TO MAXDMN) DO J = 1 TO 3))
          (COL(1),A, 3 (COL(7), MAXDMN (P'ZZZZZZ')));
 END PRINTOUT;
 %PAGE;
 REINIT: PROC REORDER;
 /* ROUTINE CALLED TO REINITIALIZE BUCKETS ETC
   WHEN HAVE HIT A BREAK */
 ACCUM=0;
 FIRSTDATE = 99999;
 LASTDATE  = 0;
 LASTTIME  = 0;
 FIRSTTIME = OVER_24HRS;
 ERROR.CODE = '    ';
 ERROR.COUNT = 0;
 HASHNAME='********';
 HASHCOUNT=0;
 HASHTAB=-1;
 NEXTBUCKET=-1;
 END REINIT;
 %PAGE;
 FIND10: PROC(TEN,SELECT) REORDER;
 /* LOCATES THE INDICES OF THE           */
 /* TEN LARGEST VALUES IN A FLOAT DEC(16) ARRAY. USED TO             */
 /* SELECT WHICH SVC, PGM NAMES, AND PERFORM GRPS TO DISPLAY.        */
 DCL TEN(0:9)  FIXED BIN(31) CONNECTED;
 DCL SELECT(*) FLOAT DEC(16);
 DCL (I,J,K,N) FIXED BIN(31) INIT(-1);
    DO I=0 TO HBOUND(SELECT,1);
 SCAN:
      DO;
         DO J=0 TO N;
         IF SELECT(TEN(J))<SELECT(I) THEN
            DO;
            N=MIN(9,N+1);
               DO K=N TO J+1 BY -1;
               TEN(K)=TEN(K-1);
               END;
            TEN(J)=I;
            LEAVE SCAN;
            END;
         END;
      IF N<9 THEN
         DO;
         N=N+1;
         TEN(N)=I;
         END;
      END;
    END;
 END;
 %PAGE;
 DTECHAR: PROC(DTE) RETURNS(CHAR(6)) REORDER;
 /* PASSED AN SMFDATE STAMP AND RETURNS YY/DDD */
 DCL DTE FIXED DEC(7);
 DCL CHAR BUILTIN;
 DCL PIC PIC'99/999';
 PIC=DTE;
 RETURN(CHAR(PIC));
 END DTECHAR;
 %SKIP(7);
 TMECHAR: PROC(TME) RETURNS(CHAR(8)) REORDER;
 /* PASSED AN SMFTIME STAMP AND RETURNS HH.MM.SS */
 DCL TME FIXED BIN(31);
 DCL CHAR BUILTIN;
 DCL PIC PIC'99.99.99';
 DCL WORK FIXED BIN(31);
 DCL (HR,MIN,SEC) FIXED BIN(31) INIT(0);
 SEC = TME / 100;  /* CONVERT FROM 100'THS OF SEC TO SECONDS */
 HR = SEC /3600;
 SEC = SEC - (HR*3600);
 MIN = SEC/60;
 SEC = SEC - (MIN*60);
 WORK = (HR*10000)+(MIN*100)+SEC;
 PIC = WORK;
 RETURN(PIC);
 END TMECHAR;
 END STATUTL;
