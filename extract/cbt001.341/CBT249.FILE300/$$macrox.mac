./       ADD   NAME=$$PROSE
        H F000032 D=JUL84
        T FILE 32 - ASSEMBLER(XF) MACRO REFERENCE LIST FROM US AIR FORCE
        K AIR FORCE AIRFORCE V27 JIM MARSHALL
        K IFOX00 IFOXLIB AFOXLIB ASSEMBLER BAL ASM MACRO XREF

         ************************************************************
         DSN=SHARE.FILE032.DATARECFM=FB LRECL=80BLKSIZE=6160 BLOCKS=79/1
         ************************************************************

         RELATED FILES: 31-33, 92, 94: DOCUMENTATION ALL FILES MEMBER $$


               ASSEMBLER (XF) MACRO REFERENCE LIST

               DOCUMENTATION



           WRITTEN BY BILL GODFREY, PLANNING RESEARCH CORPORATION,
           PRC COMPUTER CENTER INC, MCLEAN VA 22101

           INSTALLED :   AIR FORCE DATA SERVICES CENTER, PENTAGON


                        JIM MARSHALL,CAPT,USAF
                        SAN ANTONIO DATA SERVICES CENTER
                        SYSTEMS SUPPORT
                        8630  BROADWAY
                        SAN ANTONIO, TEXAS  78217
                        (512) 828-0201/0334
                        AUTOVON 945-4005/3690


          NOTE: I HAVE MOVED TO TEXAS AND HAVE TAKEN THIS WITH ME.

          CHANGE LOG:

           7 APR 83 - DON MARQUARDT, MAY & SPEH, OAKBROOK, IL
                      (312) 620-8060 REPORTED THAT HE TRIED TO
                      INSTALL THE FILE USING THE MEMBER CALLED
                      'INSTALX' WHICH ESSENTIALLY USES SUPPLIED
                      MEMBERS OF OBJECT CODE. HE HAD TROUBLE, SO
                      USED THE MEMBER 'INSTALO' THAT FORCES YOU
                      TO REASSEMBLE EVERYTHING AND IT WORKED
                      WITH NO PROBLEMS. I HAVE NOT TRIED TO INSTALL
                      IT HERE, BUT DON SAYS IT GOES ON CLEAN IF
                      REASSEMBLE EVERYTHING.


            THE MACRO REFERENCE LIST IS A MODIFICATION TO THE
            IFOX00 ASSEMBLER WHICH PRODUCES A LISTING OF ALL
            MACRO AND COPY MODULE NAMES THAT THE ASSEMBLER
            READ FROM SYSLIB, ALONG WITH THE LIBRARY NUMBER,
            DSNAME, AND VOLUME WHERE THE MACRO WAS FOUND.

            THE LISTING APPEARS IMMEDIATELY AFTER THE EXTERNAL
            SYMBOL DICTIONARY LISTING.

            THE LISTING IS GENERATED ONLY IF THERE IS
            A 'MACREF' DD STATEMENT PRESENT. THE LISTING
            IS WRITTEN TO SYSPRINT, HOWEVER, SO THE 'MACREF' DD
            SHOULD BE DUMMY TO KEEP ALLOCATION OVERHEAD TO A
            MINIMUM, BECAUSE IT IS MERELY USED AS A SWITCH.

            THE LISTING IS SORTED BY MACRO NAME WITHIN LIBRARY.

            INSTALLATION REQUIRES TWO ASSEMBLIES (OPTIONAL, SINCE
            THE TWO OBJECT DECKS ARE PROVIDED), LINK-EDITING
            OF 4 MODULES, AND 3 SMALL ZAPS TO ONE MODULE.

            DURING INSTALLATION, MODULE 'AFOX00' IS CREATED BY
            COPYING MODULE 'IFOX00', AND ZAPS ARE APPLIED TO
            'AFOX00'.  TO RUN TESTS AFTER INSTALLATION, YOU MUST
            EXECUTE 'AFOX00', NOT 'IFOX00'.  AFTER YOU ARE SATISFIED
            THAT IS WORKING, YOU MAY WANT TO APPLY THE ZAPS TO
            'IFOX00' TOO. (THIS IS SIMPLER THAN DELETING IFOX00
            AND RENAMING AFOX00 TO IFOX00, BECAUSE IFOX00 HAS
            ALIASES OF 'ASMBLR' AND 'IEUASM').

            IF YOU CHOOSE TO APPLY THE ZAPS TO 'IFOX00' ITSELF,
            THAT IS UP TO YOU.  IF YOU PREFER NOT TO DO THAT, YOU
            CAN STILL USE 'AFOX00', BECAUSE IT DOES NOT INTERFERE
            WITH THE UNMODIFIED 'IFOX00' AT ALL, EVEN IF THEY ARE
            BOTH IN THE SAME LOAD LIBRARY.

            DATA SETS REQUIRED DURING INSTALLATION.

            1) INSTALLATION SOURCE LIBRARY (YOU ARE READING
               A MEMBER OF IT).  THIS IS NAMED USERID.IFOLIB
               IN THE INSTALLATION JCL.  USED AS ASSEMBLER
               SYSIN AND SYSLIB.

            2) INSTALLATION LOAD LIBRARY, WHERE 4 LOAD MODULES
               ARE TO BE WRITTEN. THIS IS NAMES USERID.LOAD
               IN THE INSTALLATION JCL.  OUTPUT ONLY. YOU MAY
               CREATE A NEW LOAD LIBRARY OR USE ONE OF YOUR
               EXISTING LOAD LIBRARIES ON YOUR SYSTEM.

            3) OLD ASSEMBLER LOAD LIBRARY, WHERE YOU CURRENTLY
               HAVE YOUR ASSEMBLER.  THIS IS NEEDED FOR INPUT ONLY
               DURING LINKEDIT.  INSTALLATION JCL USES SYS1.LINKLIB.

            DESCRIPTION OF SOURCE LIBRARY.
              MEMBER 'IFOX0F' IS INPUT TO AN ASSEMBLY.
                      IT IS MODIFIED IBM SOURCE.
              MEMBER 'IFNX4E' IS INPUT TO AN ASSEMBLY.
                      IT IS MODIFIED IBM SOURCE.

              MEMBER 'OFOX0F' IS OBJECT OUTPUT FROM AN ASSEMBLY.
              MEMBER 'OFNX4E' IS OBJECT OUTPUT FROM AN ASSEMBLY.

              MEMBER 'MACREFBL' IS COPY CODE USED DURING AN ASSEMBLY.
              MEMBER 'MACREFGM' IS COPY CODE USED DURING AN ASSEMBLY.
              MEMBER 'MACREFFI' IS COPY CODE USED DURING AN ASSEMBLY.
              MEMBER 'MACREF4E' IS COPY CODE USED DURING AN ASSEMBLY.
                     THESE 4 ARE ALL NEW CODE, NOT FROM IBM.

              MEMBER 'XDICT' IS A MODIFIED VERSION OF THE MACRO
                     FROM THE MVS PRIVATE MACROS LIBRARY.

              MEMBER 'LINKIN' IS LINKAGE EDITOR CONTROL STATEMENTS.
              MEMBER 'ZAPIN' IS AMASPZAP CONTROL STATEMENTS.
              MEMBER 'INSTALL' IS INSTALLATION JCL USING SOURCE DECKS.
              MEMBER 'INSTALO' IS INSTALLATION JCL USING OBJECT DECKS.
              MEMBER '$DOC' IS DOCUMENTATION YOU ARE READING.

              ALL OTHER MEMBERS ARE UNMODIFIED IBM SOURCE,
                     MACROS FROM THE MVS PRIVATE MACROS LIBRARY.

           3 ZAPS TO AFOX00
           VER 0414 E7F0F4, REP 0414 E7E7F4.  IFOX04 TO IFOXX4.
           VER 043A E7F4F1, REP 043A E7F4C1.  IFOX41 TO IFOX4A.
           VER 0441 E7F4F2, REP 0441 E7F4C2.  IFOX42 TO IFOX4B.

           THE IBM SOURCE CODE FOR IFOX0F HAS BEEN KEEP UP TO
           DATE LOCALLY BY MODIFING OLDER IBM SOURCE CODE.
           THE OTHER IBM SOURCE CODE IS OF UNDETERMINED LEVEL.

           MOST RECENT CHANGE: PTF UZ32460 (8010) TO IFOX0F.

           TO COMPARE THE CODE WITH THE CURRENT IBM SOURCE
           (ON MICROFICHE FOR EXAMPLE), CHANGE THE 'SETB'
           FOR &MACREF TO ZERO (IN IFOX0F AND XDICT) AND ASSEMBLE.
           THIS WILL PRODUCE AN ASSEMBLY WITHOUT THE MODIFICATIONS,
           WHICH YOU CAN COMPARE TO THE MICROFICHE OR TO AN AMASPZAP
           DUMP OF YOUR CURRENT UNMODIFIED ASSEMBLER.

           IN THE MODIFIED VERSION OF THE ASSEMBLER,
           -   MODULE AFOX00 REPLACES IFOX00 (BUT YOU CAN CALL IT
              IFOX00 IF YOU CHOOSE TO REPLACE IFOX00).
           -   MODULE IFOXX4 IS USED INSTEAD OF IFOX04,
           -   MODULE IFOX4A IS USED INSTEAD OF IFOX41,
           -   MODULE IFOX4B IS USED INSTEAD OF IFOX42.

           IFOX41/4A IS USED WHEN THE 'TEST' OPTION IS NOT SPECIFIED.
           IFOX42/4B IS USED WHEN THE 'TEST' OPTION IS SPECIFIED.
           THE MODULE PRODUCED BY THE ASSEMBLY OF IFOX4E IS
           LINK-EDITED INTO BOTH IFOX4A AMD IFOX4B.
        $EOM
./       ADD   NAME=CONTAINS
         MACRO
&PHASEID CONTAINS  &DUMMY
.*
.*             CHANGES TO RELEASE 3
.*             CHANGES TO RELEASE 2
.*             CHANGES TO RELEASE 1
.* INNER MACRO TO ICOMMON USED TO CREATE AN EXTERNAL
.* ROUTINE NAME ARRAY
         GBLC  &X0(26)
         GBLC  &X1(26)
         GBLC  &X2(26)
         GBLC  &X3(26)
         GBLC  &X4(26)
         GBLC  &X5(26)
         GBLC  &X6(26)
         GBLC  &X7(26)
         GBLC  &X8(26)
         GBLC  &X9(26)
         GBLC  &XA(26)
         GBLC  &XB(26)
         GBLC  &XC(26)
         GBLC  &XD(26)
         GBLC  &XE(26)
         GBLC  &XF(26)
.*
         LCLA  &I,&J                    INDEX
.*
         AIF   (K'&PHASEID EQ 0).ERR1
.*
         AIF   ('&X0(1)' EQ '').X0
         AIF   ('&X0(1)' EQ '&PHASEID').ERR5
         AIF   ('&X1(1)' EQ '').X1
         AIF   ('&X1(1)' EQ '&PHASEID').ERR5
         AIF   ('&X2(1)' EQ '').X2
         AIF   ('&X2(1)' EQ '&PHASEID').ERR5
         AIF   ('&X3(1)' EQ '').X3
         AIF   ('&X3(1)' EQ '&PHASEID').ERR5
         AIF   ('&X4(1)' EQ '').X4
         AIF   ('&X4(1)' EQ '&PHASEID').ERR5
         AIF   ('&X5(1)' EQ '').X5
         AIF   ('&X5(1)' EQ '&PHASEID').ERR5
         AIF   ('&X6(1)' EQ '').X6
         AIF   ('&X6(1)' EQ '&PHASEID').ERR5
         AIF   ('&X7(1)' EQ '').X7
         AIF   ('&X7(1)' EQ '&PHASEID').ERR5
         AIF   ('&X8(1)' EQ '').X8
         AIF   ('&X8(1)' EQ '&PHASEID').ERR5
         AIF   ('&X9(1)' EQ '').X9
         AIF   ('&X9(1)' EQ '&PHASEID').ERR5
         AIF   ('&XA(1)' EQ '').XA
         AIF   ('&XA(1)' EQ '&PHASEID').ERR5
         AIF   ('&XB(1)' EQ '').XB
         AIF   ('&XB(1)' EQ '&PHASEID').ERR5
         AIF   ('&XC(1)' EQ '').XC
         AIF   ('&XC(1)' EQ '&PHASEID').ERR5
         AIF   ('&XD(1)' EQ '').XD
         AIF   ('&XD(1)' EQ '&PHASEID').ERR5
         AIF   ('&XE(1)' EQ '').XE
         AIF   ('&XE(1)' EQ '&PHASEID').ERR5
         AIF   ('&XF(1)' EQ '').XF
         AIF   ('&XF(1)' EQ '&PHASEID').ERR5
.*
         AGO   .ERR4
.*
.X0      ANOP
&X0(1)   SETC  '&PHASEID'
.X01     AIF   (&I+1 GT N'&SYSLIST).END
&I       SETA  &I+1
         AIF   ('&SYSLIST(&I)' EQ '').X01
         AIF   (&J GT 24).ERR6
&X0(&J+2) SETC '&SYSLIST(&I)'
&J       SETA  &J+1
         AGO   .X01
.*
.X1      ANOP
&X1(1)   SETC  '&PHASEID'
.X11     AIF   (&I+1 GT N'&SYSLIST).END
&I       SETA  &I+1
         AIF   ('&SYSLIST(&I)' EQ '').X11
         AIF   (&J GT 24).ERR6
&X1(&J+2) SETC '&SYSLIST(&I)'
&J       SETA  &J+1
         AGO   .X11
.*
.X2      ANOP
&X2(1)   SETC  '&PHASEID'
.X21     AIF   (&I+1 GT N'&SYSLIST).END
&I       SETA  &I+1
         AIF   ('&SYSLIST(&I)' EQ '').X21
         AIF   (&J GT 24).ERR6
&X2(&J+2) SETC '&SYSLIST(&I)'
&J       SETA  &J+1
         AGO   .X21
.*
.X3      ANOP
&X3(1)   SETC  '&PHASEID'
.X31     AIF   (&I+1 GT N'&SYSLIST).END
&I       SETA  &I+1
         AIF   ('&SYSLIST(&I)' EQ '').X31
         AIF   (&J GT 24).ERR6
&X3(&J+2) SETC '&SYSLIST(&I)'
&J       SETA  &J+1
         AGO   .X31
.*
.X4      ANOP
&X4(1)   SETC  '&PHASEID'
.X41     AIF   (&I+1 GT N'&SYSLIST).END
&I       SETA  &I+1
         AIF   ('&SYSLIST(&I)' EQ '').X41
         AIF   (&J GT 24).ERR6
&X4(&J+2) SETC '&SYSLIST(&I)'
&J       SETA  &J+1
         AGO   .X41
.*
.X5      ANOP
&X5(1)   SETC  '&PHASEID'
.X51     AIF   (&I+1 GT N'&SYSLIST).END
&I       SETA  &I+1
         AIF   ('&SYSLIST(&I)' EQ '').X51
         AIF   (&J GT 24).ERR6
&X5(&J+2) SETC '&SYSLIST(&I)'
&J       SETA  &J+1
         AGO   .X51
.*
.X6      ANOP
&X6(1)   SETC  '&PHASEID'
.X61     AIF   (&I+1 GT N'&SYSLIST).END
&I       SETA  &I+1
         AIF   ('&SYSLIST(&I)' EQ '').X61
         AIF   (&J GT 24).ERR6
&X6(&J+2) SETC '&SYSLIST(&I)'
&J       SETA  &J+1
         AGO   .X61
.*
.X7      ANOP
&X7(1)   SETC  '&PHASEID'
.X71     AIF   (&I+1 GT N'&SYSLIST).END
&I       SETA  &I+1
         AIF   ('&SYSLIST(&I)' EQ '').X71
         AIF   (&J GT 24).ERR6
&X7(&J+2) SETC '&SYSLIST(&I)'
&J       SETA  &J+1
         AGO   .X71
.*
.X8      ANOP
&X8(1)   SETC  '&PHASEID'
.X81     AIF   (&I+1 GT N'&SYSLIST).END
&I       SETA  &I+1
         AIF   ('&SYSLIST(&I)' EQ '').X81
         AIF   (&J GT 24).ERR6
&X8(&J+2) SETC '&SYSLIST(&I)'
&J       SETA  &J+1
         AGO   .X81
.*
.X9      ANOP
&X9(1)   SETC  '&PHASEID'
.X91     AIF   (&I+1 GT N'&SYSLIST).END
&I       SETA  &I+1
         AIF   ('&SYSLIST(&I)' EQ '').X91
         AIF   (&J GT 24).ERR6
&X9(&J+2) SETC '&SYSLIST(&I)'
&J       SETA  &J+1
         AGO   .X91
.*
.XA      ANOP
&XA(1)   SETC  '&PHASEID'
.XA1     AIF   (&I+1 GT N'&SYSLIST).END
&I       SETA  &I+1
         AIF   ('&SYSLIST(&I)' EQ '').XA1
         AIF   (&J GT 24).ERR6
&XA(&J+2) SETC '&SYSLIST(&I)'
&J       SETA  &J+1
         AGO   .XA1
.*
.XB      ANOP
&XB(1)   SETC  '&PHASEID'
.XB1     AIF   (&I+1 GT N'&SYSLIST).END
&I       SETA  &I+1
         AIF   ('&SYSLIST(&I)' EQ '').XB1
         AIF   (&J GT 24).ERR6
&XB(&J+2) SETC '&SYSLIST(&I)'
&J       SETA  &J+1
         AGO   .XB1
.*
.XC      ANOP
&XC(1)   SETC  '&PHASEID'
.XC1     AIF   (&I+1 GT N'&SYSLIST).END
&I       SETA  &I+1
         AIF   ('&SYSLIST(&I)' EQ '').XC1
         AIF   (&J GT 24).ERR6
&XC(&J+2) SETC '&SYSLIST(&I)'
&J       SETA  &J+1
         AGO   .XC1
.*
.XD      ANOP
&XD(1)   SETC  '&PHASEID'
.XD1     AIF   (&I+1 GT N'&SYSLIST).END
&I       SETA  &I+1
         AIF   ('&SYSLIST(&I)' EQ '').XD1
         AIF   (&J GT 24).ERR6
&XD(&J+2) SETC '&SYSLIST(&I)'
&J       SETA  &J+1
         AGO   .XD1
.*
.XE      ANOP
&XE(1)   SETC  '&PHASEID'
.XE1     AIF   (&I+1 GT N'&SYSLIST).END
&I       SETA  &I+1
         AIF   ('&SYSLIST(&I)' EQ '').XE1
         AIF   (&J GT 24).ERR6
&XE(&J+2) SETC '&SYSLIST(&I)'
&J       SETA  &J+1
         AGO   .XE1
.*
.XF      ANOP
&XF(1)   SETC  '&PHASEID'
.XF1     AIF   (&I+1 GT N'&SYSLIST).END
&I       SETA  &I+1
         AIF   ('&SYSLIST(&I)' EQ '').XF1
         AIF   (&J GT 24).ERR6
&XF(&J+2) SETC '&SYSLIST(&I)'
&J       SETA  &J+1
         AGO   .XF1
.*
.ERR1    MNOTE 8,'INVALID OR NO PHASEID FURNISHED.'
         MEXIT
.ERR4    MNOTE 8,'EXTERNAL ROUTINE NAME ARRAYS FULL.'
         MEXIT
.ERR5    MNOTE 8,'DUPLICATE PHASEID.'
         MEXIT
.ERR6    MNOTE 8,'TOO MANY NAMES.'
         MEXIT
.END     AIF   (&J GT 0).MEND
         MNOTE 0,'NO ROUTINE NAMES FURNISHED.'
.MEND    MEND
./       ADD   NAME=CONTENTS
         MACRO
&PHASEID CONTENTS  &DUMMY
.*
.*             CHANGES TO RELEASE 3
.*             CHANGES TO RELEASE 2
.*             CHANGES TO RELEASE 1
.*
.* GENERATES A BRANCH TABLE IN IFNX4E TO THE ROUTINES
.* CONTAINED IN IFNX4E
         GBLC  &X0(26)
         GBLC  &X1(26)
         GBLC  &X2(26)
         GBLC  &X3(26)
         GBLC  &X4(26)
         GBLC  &X5(26)
         GBLC  &X6(26)
         GBLC  &X7(26)
         GBLC  &X8(26)
         GBLC  &X9(26)
         GBLC  &XA(26)
         GBLC  &XB(26)
         GBLC  &XC(26)
         GBLC  &XD(26)
         GBLC  &XE(26)
         GBLC  &XF(26)
.*
         LCLA  &I
.*
         AIF   (K'&PHASEID EQ 0).ERR1
.*
&PHASEID DS    0H                       START OF BRANCH TABLE
         USING &PHASEID,R12
.*
         AIF   ('&X0(1)' EQ '&PHASEID').X0
         AIF   ('&X1(1)' EQ '&PHASEID').X1
         AIF   ('&X2(1)' EQ '&PHASEID').X2
         AIF   ('&X3(1)' EQ '&PHASEID').X3
         AIF   ('&X4(1)' EQ '&PHASEID').X4
         AIF   ('&X5(1)' EQ '&PHASEID').X5
         AIF   ('&X6(1)' EQ '&PHASEID').X6
         AIF   ('&X7(1)' EQ '&PHASEID').X7
         AIF   ('&X8(1)' EQ '&PHASEID').X8
         AIF   ('&X9(1)' EQ '&PHASEID').X9
         AIF   ('&XA(1)' EQ '&PHASEID').XA
         AIF   ('&XB(1)' EQ '&PHASEID').XB
         AIF   ('&XC(1)' EQ '&PHASEID').XC
         AIF   ('&XD(1)' EQ '&PHASEID').XD
         AIF   ('&XE(1)' EQ '&PHASEID').XE
         AIF   ('&XF(1)' EQ '&PHASEID').XF
.*
         AGO   .ERR4
.*
.X0      AIF   (&I GT 24).END
&I       SETA  &I+1
         AIF   ('&X0(&I+1)' EQ '').END
         B     &X0(&I+1)
         AGO   .X0
.*
.X1      AIF   (&I GT 24).END
&I       SETA  &I+1
         AIF   ('&X1(&I+1)' EQ '').END
         B     &X1(&I+1)
         AGO   .X1
.*
.X2      AIF   (&I GT 24).END
&I       SETA  &I+1
         AIF   ('&X2(&I+1)' EQ '').END
         B     &X2(&I+1)
         AGO   .X2
.*
.X3      AIF   (&I GT 24).END
&I       SETA  &I+1
         AIF   ('&X3(&I+1)' EQ '').END
         B     &X3(&I+1)
         AGO   .X3
.*
.X4      AIF   (&I GT 24).END
&I       SETA  &I+1
         AIF   ('&X4(&I+1)' EQ '').END
         B     &X4(&I+1)
         AGO   .X4
.*
.X5      AIF   (&I GT 24).END
&I       SETA  &I+1
         AIF   ('&X5(&I+1)' EQ '').END
         B     &X5(&I+1)
         AGO   .X5
.*
.X6      AIF   (&I GT 24).END
&I       SETA  &I+1
         AIF   ('&X6(&I+1)' EQ '').END
         B     &X6(&I+1)
         AGO   .X6
.*
.X7      AIF   (&I GT 24).END
&I       SETA  &I+1
         AIF   ('&X7(&I+1)' EQ '').END
         B     &X7(&I+1)
         AGO   .X7
.*
.X8      AIF   (&I GT 24).END
&I       SETA  &I+1
         AIF   ('&X8(&I+1)' EQ '').END
         B     &X8(&I+1)
         AGO   .X8
.*
.X9      AIF   (&I GT 24).END
&I       SETA  &I+1
         AIF   ('&X9(&I+1)' EQ '').END
         B     &X9(&I+1)
         AGO   .X9
.*
.XA      AIF   (&I GT 24).END
&I       SETA  &I+1
         AIF   ('&XA(&I+1)' EQ '').END
         B     &XA(&I+1)
         AGO   .XA
.*
.XB      AIF   (&I GT 24).END
&I       SETA  &I+1
         AIF   ('&XB(&I+1)' EQ '').END
         B     &XB(&I+1)
         AGO   .XB
.*
.XC      AIF   (&I GT 24).END
&I       SETA  &I+1
         AIF   ('&XC(&I+1)' EQ '').END
         B     &XC(&I+1)
         AGO   .XC
.*
.XD      AIF   (&I GT 24).END
&I       SETA  &I+1
         AIF   ('&XD(&I+1)' EQ '').END
         B     &XD(&I+1)
         AGO   .XD
.*
.XE      AIF   (&I GT 24).END
&I       SETA  &I+1
         AIF   ('&XE(&I+1)' EQ '').END
         B     &XE(&I+1)
         AGO   .XE
.*
.XF      AIF   (&I GT 24).END
&I       SETA  &I+1
         AIF   ('&XF(&I+1)' EQ '').END
         B     &XF(&I+1)
         AGO   .XF
.*
.ERR1    MNOTE 8,'INVALID OR NO PHASEID FURNISHED.'
         MEXIT
.ERR4    MNOTE 8,'UNDEFINED PHASEID.'
.END     DROP  R12
         AIF   (&I NE 0).MEND
.ERR5    MNOTE 4,'NO ROUTINE NAME DEFINED FOR PHASE.'
.MEND    MEND
./       ADD   NAME=DBV
         MACRO
&NAME    DBV   &Z
         LCLA  &I,&J,&K,&M
         LCLC  &B(7)
.*
.*             CHANGES TO RELEASE 3
.*             CHANGES TO RELEASE 2
.*             CHANGES TO RELEASE 1
.*
.* DEFINES BYTE VALUES THROUGH THE USE OF
.* EQUATES AND DS 0X
.*
         AIF   ('&NAME' EQ '').I1
&NAME    DS    0X
.I1      AIF   (&M EQ 0).M1
&B(&M+1) SETC  ''
&M       SETA  &M-1
         AGO   .I1
.M1      ANOP
&B(&M+1) SETC  '0'
&K       SETA  0
&I       SETA  &I+1
         AIF   (K'&SYSLIST(&I) EQ 0).D1
&J       SETA  K'&SYSLIST(&I)+1
.L1      ANOP
&J       SETA  &J-1
         AIF   ('&SYSLIST(&I)'(&J,1) NE ')').S1
&K       SETA  &K+1
.S1      AIF   ('&SYSLIST(&I)'(&J,1) NE '(').S2
&K       SETA  &K-1
.S2      AIF   (&K EQ 0).S3
         AIF   (&K GT 0 AND &J GT 1).L1
.ERR     MNOTE 8,'INVALID PARAMETER SYNTAX IN OPERAND &I.'
         AGO   .D1
.S4      ANOP
&B(&M+1) SETC  '&SYSLIST(&I)'(&J+1+&M*8,8)
&M       SETA  &M+1
.S3      AIF   (K'&SYSLIST(&I)-&M*8-&J GT 9).S4
         AIF   (&J EQ K'&SYSLIST(&I)).S5
&B(&M+1) SETC  '&SYSLIST(&I)'(&J+1+&M*8,K'&SYSLIST(&I)-&M*8-&J-1)
.S5      AIF   (&J EQ 1 OR &J GT 8).ERR
&B(7)    SETC  '&SYSLIST(&I)'(1,&J-1)
&B(7)    EQU   &B(1)&B(2)&B(3)&B(4)&B(5)&B(6)
V&B(7)   DS    0X
.D1      AIF   (&I LT N'&SYSLIST).I1
         DS    1X
.MEND    MEND
./       ADD   NAME=DCDSWORK
         MACRO
&NAME    DCDSWORK  &DUMMY
.*
.*             CHANGES TO RELEASE 3
.*             CHANGES TO RELEASE 2
.*             CHANGES TO RELEASE 1
.*
.* GENERATES A WORK AREA FOR DC/DS EVALUATION ROUTINE
.* (IFNX4D AND IFNX4N). THE WORK AREA IS GENERATED IN
.* IFNX4D AND IFNX4N BY A CALL FROM MACRO ICOMMON
&NAME    DS    0F                       NAME
DCSWORK  DS    0XL11                             DC SWITCH CODES
DCSWTCH  DSW   BITLN,ESMOD,TYPEL,TYPEV,TYPEZ     DC/DS SWITCH CODE
LFDEL    DS    C                                 LEFT FIELD DELIMITER
RTDEL    DS    C                        RIGHT FIELD DELIMITER
SCADDR   DS    X                        SCAN ROUTINE ADDRESS
DCALIGN  DS    X                        IMPLIED LENGTH AND ALIGNMENT
MINLN    DS    X                        MINIMUM LENGTH LODIFIER RANGE
MAXLN    DS    H                        MAXIMUM LENGTH MODIFIER RANGE
BITINCR  DS    H                        NUMBER OF BITS PER DIGIT
HILIMIT  DS    X                        HIGHEST VALUE OF VALID DIGIT
PERIOD   EQU   D0+BITINCR               DECIMAL POINT ENCOUNTERED
EXPONENT EQU   D1+BITINCR               EXPONENT ENCOUNTERED
SUBFIELD EQU   D1+BITINCR               SUBFIELD ENCOUNTERED
TYPECALL DSW   ,DXDALIGN,DEFNAME,DLOCTREF,DCCALL,DSCALL,LTCALL,LTORGSCN
LEVELPTR DS    A                        LEVEL POINTER
DUPFAC   DS    F                        DUPLICATION FACTOR
CONLNG   DS    F                        CONSTANT LENGTH
DCDSWORK DS    0XL38                    INITIALIZE
REFCOUNT DS    H                        SYMBOL COUNT
SYMCOUNT DS    H                        SYMBOL COUNT
VEETABLE DS    16X                      V-TYPE CONSTANTS TABLE
ADSYM    DS    A                        ADDRESS OF SYMBOL TABLE ENTRY
BITADD   DS    H                        RESIDUAL BIT COUNT
OPCNT    DS    H                        OPERAND COUNT
LATTRSAV DS    H                        SAVE
DCWORK   DS    0XL8                     INITIALIZE
LATTR    DS    H                        LENGTH ATTRIBUTE
ADUPFAC  DS    A                        ADDRESS OF DUPLICATION FACTOR
CONCT    DS    H                        CONSTANT COUNT
         MEND
./       ADD   NAME=DSW
         MACRO
&NAME    DSW
         GBLA  &INDEX
         GBLC  &DEFNAME(255),&SWNAME(255)
         LCLA  &I,&J
         LCLC  &X,&Y
.*
.*             CHANGES TO RELEASE 3
.*             CHANGES TO RELEASE 2
.*             CHANGES TO RELEASE 1
.*
.* DEFINES SWITCH BYTE AND NAMES THE BITS IN THE BYTE
.*
         AIF   (N'&SYSLIST GT 8).ERR1
&X       SETC  'JSW&SYSNDX'
         AIF   (K'&NAME EQ 0).NEXT
&X       SETC  '&NAME'
.NEXT    ANOP
&X       DS    X
         AIF   (N'&SYSLIST EQ 0).EXIT
.LOOP    ANOP
&J       SETA  &I+1
         AIF   (K'&SYSLIST(&J) EQ 0).BYPASS
         AIF   (K'&SYSLIST(&J) GT 8).ERR1
&INDEX   SETA  &INDEX+1
         AIF   (&INDEX GT 255).ERR2
&Y       SETC  '&SYSLIST(&J)'
&DEFNAME(&INDEX) SETC '&X'
&SWNAME(&INDEX)  SETC '&Y'
&Y       EQU   BIT&I
.BYPASS  ANOP
&I       SETA  &I+1
         AIF   (N'&SYSLIST GT &I).LOOP
.EXIT    MEXIT
.ERR1    MNOTE 8,'PARAMETER ERROR.'
         MEXIT
.ERR2    MNOTE 8,'TOO MANY SWITCHES DEFINED FOR ASSEMBLY.'
         MEND
./       ADD   NAME=EVALWORK
         MACRO
&NAME    EVALWORK &DUMMY,&MAXTERM=20,&MAXPARN=6
         LCLA  &I
.*
.*             CHANGES TO RELEASE 3
.*             CHANGES TO RELEASE 2
.*             CHANGES TO RELEASE 1
.*
.*  GENERATES THE EVALUATION ROUTINE WORK AREA
.* IN PHASE COMMON. THIS WORK AREA IS USED BY
.* IFNX4V AND IFNX5V RESPECTIVLY
.*
SELFDEFN DBV   SELFDEF(0)
EVALMODE DSW   SUBLIST,PRDEFREQ,DCOP
CLCLNG   DS    H
IMPLNG   DS    H
EVALREGS DS    0A
ATPTR    DS    A(TERMS)
ALPTR    DS    A(RLIST)
AOPTR    DS    A(OPRNS-1)
ERRPTR   DS    F                        ERROR COLUMN POINTER
OPNEND   DS    F
&I       SETA  (&MAXTERM+1)/2*2
         DS    0D                       CAUSE DOUBLE WORD ALIGNMENT
RLIST    DS    &I.H
&I       SETA  &MAXPARN*16+25
EVALWORK DS    0XL&I
FIRST    DBV   ,
STATUS   DBV   STATUS1(1),STATUS2(2)
         DS    3H
RELOCTR  DBV   NORELOC(0)
         DS    X
         DS    3H
EVALSW   DSW   ,ENDOFEXP,LOCTREF,LNGQUOTE
EVALSW1  DSW   ,EVALERR,SDVSIZE,RELOCER,OVERFLO,NOTDEFN,,FATALER
         ORG   EVALSW1
         DBV   COMPLEX(0)
         DS    3H
PARENCNT DS    0H
         DS    X
         DBV   NOPAREN(0),MAXPARN(&MAXPARN)
         DS    3H
SHIFTN   DBV   SHIFTB(1),SHIFTD(3),SHIFTH(4),SHIFTC(8)
         DBV   MAXCHAR(4),MAXHEX(8),MAXDEC(10),MAXBIT(32)
         ORG   FIRST                    ORIGIN
&I       SETA  &MAXPARN*4+6
TERMS    DS    &I.F
         DBV   ENDPARN(0)
&I       SETA  &MAXPARN*4+4
OPRNS    DS    &I.X
         DS    X                        NOT USED
XSSAV    DS    H                        TEST ESDID
DSECT2   DSECT ,                        TERM STACK POINTER
         ORG   DSECT2                   ORIGIN
TERM1CNT DS    F
TERM1    DS    F
TERM2CNT DS    F
TERM2    DS    F
DSECT3   DSECT ,                        RELOCATION LIST POINTER
         ORG   DSECT3                   ORIGIN
ESDID    DS    H
NEXTESD  DS    H
JTEXT    DSECT ,                        OPERATOR STACK POINTER
         ORG   JTEXT                    ORIGIN
OLDOP    DBV   DEL0(JLPARN),ADD0(JPLUS),SUB0(JMINUS),MUL0(JASTER),     ,
               DIV0(JSLASH),UNY0(JSLASH+1)
NEWOP    DBV   DEL1(JLPARN),ADD1(JPLUS),SUB1(JMINUS),MUL1(JASTER),     ,
               DIV1(JSLASH),UNY1(JSLASH+1)
DSECT5   DSECT ,                        INPUT POINTER
         ORG   DSECT5                   ORIGIN
CHAR1    DS    X                        CURRENT CHARACTER
CHAR2    DS    X                        NEXT CHARACTER
CHAR3    DS    X                        NEXT CHARACTER
DSECT14  DSECT ,                        INPUT POINTER
         ORG   DSECT14                  ORIGIN
         DBV   BQUOTE(JB),CQUOTE(JC),XQUOTE(JX),LQUOTE(JL)
&SYSECT  DSECT ,                        RESUME DSECT
         MEND
./       ADD   NAME=GOIF
         MACRO
&NAME    GOIF  &SW, .                   SWITCH TO BE TESTED            X
               &SW2, .                  COMPARAND FOR CLC OR CLI       X
               &GT=, .                  BRANCH GREATER                 X
               &GE=, .                  BRANCH GREATER OR EQUAL        X
               &EQ=, .                  BRANCH EQUAL                   X
               &LE=, .                  BRANCH LESS OR EQUAL           X
               &LT=, .                  BRANCH LESS                    X
               &NE=, .                  BRANCH NOT EQUAL               X
               &ZERO=, .                STATUS CONDITION               X
               &NOTZERO=, .             STATUS CONDITION               X
               &POS=, .                 STATUS CONDITION               X
               &NOTPOS=, .              STATUS CONDITION               X
               &NEG=, .                 STATUS CONDITION               X
               &NOTNEG=, .              STATUS CONDITION               X
               &MODE=L, .               STATUS CONDITION               X
               &NO=, .                  SWITCH OFF                     X
               &YES=, .                 SWITCH ON                      X
               &EQUAL=, .               ALTERNATE FOR EQ               X
               &NOTEQ=, .               ALTERNATE FOR NE               X
               &ALL=, .                 BRANCH IF ALL ON               X
               &NONE=, .                BRANCH IF NONE ON              X
               &MIX=, .                 BRANCH IF SOME ON (BUT NOT ALL)X
               &NOTALL=, .              BRANCH IF NONE OR SOME         X
               &ANY=, .                 H NOT ALL OFF (ANY OR ALL ON)  X
               &NOTMIX=, .              BRANCH IF ALL ON OR ALL OFF    X
               &ELSE=, .                UNCONDITIONAL FINAL BRANCH     X
               &ON=, .                  BRANCH IF SINGLE SWITCH ON     X
               &OFF=, .                 BRANCH IF SINGLE SWITCH OFF    X
               &HIGH=,&HI=,&NOTLO=,&NOTLOW=,&LOW=,&LO=,&NOTHI=,        X
               &NOTHIGH=
         GBLA  &INDEX
         GBLC  &BYTE,&CRNT
         GBLC  &DEFNAME(255),&SWNAME(255)
         LCLA  &COUNT1,&COUNT2
         LCLB  &FIRST,&COND(3),&USED(6),&TM,&MASK(3)
         LCLB  &NULL
         LCLC  &PLUS(7)
.*
.*             CHANGES TO RELEASE 3
.*             CHANGES TO RELEASE 2
.*             CHANGES TO RELEASE 1
.*
.* GENERATES INSTRUCTIONS TO TEST A GIVEN CONDITION
.* AND BRANCH IF THE BRANCH CONDITION IS SATISFIED
.*
         AIF   (N'&SW GT 8).ERR1 .      TOO MANY SWITCHES
&COUNT1  SETA  0 .                      INITIALIZE FOR VALIDITY CHECK
.LOOP1   ANOP
&COUNT1  SETA  &COUNT1+1 .              NEXT OPERAND
         AIF   (&COUNT1 GT N'&SW).NXT1 . DONE
&COUNT2  SETA  0 .                      INITIALIZE SWNAME LOOKUP
.LOOP2   ANOP
&COUNT2  SETA  &COUNT2+1 .              NEXT IN SWNAME LIST
         AIF   (&COUNT2 GT &INDEX).ERR2 . DIDN'T FIND NAME
         AIF   ('&SW(&COUNT1)' EQ '&SWNAME(&COUNT2)').LOOP3 FOUND NAME
         AGO   .LOOP2
.ERR2    ANOP  , .                      LOG NO NAME FOUND
         AIF   (N'&SW GT 1).ERR2A
&NAME    GOIF1 &SW,&SW2,GT=&GT&HI&HIGH,GE=&GE&NOTLOW&NOTLO,            X
               EQ=&EQ&EQUAL,LE=&LE&NOTHIGH&NOTHI,LT=&LT&LOW&LO,        X
               ZERO=&ZERO,              STATUS CONDITION               X
               NOTZERO=&NOTZERO,        STATUS CONDITION               X
               POS=&POS,                STATUS CONDITION               X
               NOTPOS=&NOTPOS,          STATUS CONDITION               X
               NEG=&NEG,                STATUS CONDITION               X
               NOTNEG=&NOTNEG,          STATUS CONDITION               X
               MODE=&MODE,              STATUS CONDITION               X
               NE=&NE&NOTEQ,ELSE=&ELSE
         MEXIT
.ERR2A   MNOTE 8,'UNDECLARED BIT SWITCH OR MORE THAN ONE CLI SWITCH'
         MEXIT
.ERR1    ANOP
         MNOTE 8,'TOO MANY SWITCHES, ONLY 8 ALLOWED PER CALL'
         MEXIT
.LOOP3   ANOP
         AIF   (&FIRST).SECOND .        FIRST TIME THROUGH
&FIRST   SETB  1 .                      YES
&BYTE    SETC  '&DEFNAME(&COUNT2)' .    SAVE THE NAME
         AGO   .LOOP1 .                 BACK FOR MORE
.SECOND  ANOP
         AIF   ('&DEFNAME(&COUNT2)' EQ '&BYTE').LOOP1
         MNOTE 8,'SWITCHES NOT ALL IN THE SAME BYTE'
         MEXIT
.NXT1    ANOP
&NAME    GOIF3 &SW,                                                    X
               ALL=&ALL&YES&ON,                                        X
               NONE=&NONE&NO&OFF,                                      X
               MIX=&MIX,                                               X
               NOTALL=&NOTALL,                                         X
               ANY=&ANY,                                               X
               NOTMIX=&NOTMIX,                                         X
               ELSE=&ELSE,                                             X
               ON=&ALL&YES&ON,                                         X
               OFF=&NONE&NO&OFF
         MEND
./       ADD   NAME=GOIF1
         MACRO
&NAME    GOIF1 &LOC,&CMP,&EQ=,&NE=,&GT=,&LT=,&GE=,&LE=,&MODE=,         ,
               &ZERO=,&NOTZERO=,&POS=,&NOTPOS=,&NEG=,&NOTNEG=,&ELSE=
         LCLA  &W(4)
         LCLB  &B(3)
         LCLC  &R
.*
.*             CHANGES TO RELEASE 3
.*             CHANGES TO RELEASE 2
.*             CHANGES TO RELEASE 1
.*
.* INNER MACRO TO GOIF. GENERATES THE INSTRUCTIONS IF A
.* SWITCH IS TO BE TESTED
.*
         AIF   (K'&LOC EQ 0).ERR1
&W(1)    SETA  4
&W(2)    SETA  2
&W(3)    SETA  13
&W(4)    SETA  11
&B(1)    SETB  ('&EQ' NE '')
&B(2)    SETB  ('&NE' NE '')
&B(3)    SETB  ('&NE' NE '')
         AIF   ('&GT' EQ '').C1
         AIF   (&B(3)).ERR3
&B(3)    SETB  1
.C1      AIF   ('&LT' EQ '').C2
         AIF   (&B(2)).ERR3
&B(2)    SETB  1
.C2      AIF   ('&GE' EQ '').C3
         AIF   (&B(1) OR &B(3)).ERR3
&B(1)    SETB  1
&B(3)    SETB  1
.C3      AIF   ('&LE' EQ '').C4
         AIF   (&B(1) OR &B(2)).ERR3
&B(1)    SETB  1
&B(2)    SETB  1
.C4      AIF   (NOT(&B(1) AND &B(2) AND &B(3))OR '&ELSE' EQ '').C5
.ERR3    MNOTE 8,'REDUNDANT LOGIC, MACRO EXPANSION ATTEMPTED.'
.C5      AIF   (K'&CMP EQ 0).C6
.*
.*                       TWO OPERANDS SUPPLIED
.*
         AIF   ('&LOC'(1,1) EQ '(' AND '&LOC'(K'&LOC,1) EQ ')').RG1
         AIF   ('&CMP'(1,1) EQ '(' AND '&CMP'(K'&CMP,1) EQ ')').RG2
         AIF   (T'&CMP NE 'U').SS
.*
.*                       OPERAND 2 IS ASSUMED TO BE IMMEDIATE
.*
&NAME    CLI   &LOC,&CMP
         AGO   .C7
.*
.*                       ONE OPERAND ONLY
.*
.C6      AIF   ('&LOC'(1,1) EQ '(' AND '&LOC'(K'&LOC,1) EQ ')').LTR
&NAME    CLI   V&LOC,&LOC
.C7      AIF   (K'&ZERO+K'&NOTZERO+K'&POS+K'&NOTPOS+K'&NEG+K'&NOTNEG EQ,
                0).C7A
         MNOTE 8,'CALL CONTAINS OTHER THAN RELATIONAL CONDITIONS.'
.C7A     AIF   ('&EQ' EQ '').LE
         AIF   ('&EQ'EQ'&NE'OR'&EQ'EQ'&GT'AND'&EQ'EQ'&LT').ALL
         AIF   ('&EQ' EQ '&LT').LE1
         AIF   ('&EQ' EQ '&GT').GE1
         AIF   ('&EQ'(1,1) NE '(').EQ2
&R       SETC  'R'
.EQ2     BC&R  8,&EQ(1)                 BRANCH PER MACRO CALL
&R       SETC  ''
.LE      AIF   ('&LE' EQ '').GE
         AIF   ('&LE' EQ '&GT').ALL1
         AIF   ('&LE'(1,1) NE '(').LE2
&R       SETC  'R'
.LE2     BC&R  &W(3),&LE(1)             BRANCH PER MACRO CALL
&R       SETC  ''
         AGO   .GE
.LE1     AIF   ('&EQ'(1,1) NE '(').LE3
&R       SETC  'R'
.LE3     BC&R  &W(3),&EQ(1)             BRANCH PER MACRO CALL
&R       SETC  ''
.GE      AIF   ('&GE' EQ '').LT
         AIF   ('&GE' EQ '&LT').ALL2
         AIF   ('&GE'(1,1) NE '(').GE2
&R       SETC  'R'
.GE2     BC&R  &W(4),&GE(1)             BRANCH PER MACRO CALL
&R       SETC  ''
         AGO   .LT
.GE1     AIF   ('&EQ'(1,1) NE '(').GE3
&R       SETC  'R'
.GE3     BC&R  &W(4),&EQ(1)             BRANCH PER MACRO CALL
&R       SETC  ''
.LT      AIF   ('&LT' EQ '').NE
         AIF   ('&LT' EQ '&GT').NE1
         AIF   ('&LT'(1,1) NE '(').LT2
&R       SETC  'R'
.LT2     BC&R  &W(1),&LT(1)             BRANCH PER MACRO CALL
&R       SETC  ''
.NE      AIF   ('&NE' EQ '').GT
         AIF   ('&NE'(1,1) NE '(').NE2
&R       SETC  'R'
.NE2     BC&R  7,&NE(1)                 BRANCH PER MACRO CALL
&R       SETC  ''
         AGO   .END
.NE1     AIF   ('&LT'(1,1) NE '(').NE3
&R       SETC  'R'
.NE3     BC&R  7,&LT(1)                 BRANCH PER MACRO CALL
&R       SETC  ''
.GT      AIF   ('&GT' EQ '').END
         AIF   ('&GT'(1,1) NE '(').GT2
&R       SETC  'R'
.GT2     BC&R  &W(2),&GT(1)             BRANCH PER MACRO CALL
&R       SETC  ''
.END     AIF   ('&ELSE' EQ '').MEND
         AIF   ('&ELSE'(1,1) NE '(').ELSE2
&R       SETC  'R'
.ELSE2   BC&R  15,&ELSE(1)              BRANCH PER MACRO CALL
         MEXIT
.ALL     AIF   ('&EQ'(1,1) NE '(').ALL01
&R       SETC  'R'
.ALL01   BC&R  15,&EQ(1)                BRANCH PER MACRO CALL
         MEXIT
.ALL1    AIF   ('&LE'(1,1) NE '(').ALL11
&R       SETC  'R'
.ALL11   BC&R  15,&LE(1)                BRANCH PER MACRO CALL
         MEXIT
.ALL2    AIF   ('&GE'(1,1) NE '(').ALL21
&R       SETC  'R'
.ALL21   BC&R  15,&GE(1)                BRANCH PER MACRO CALL
         MEXIT
.LTRC    AIF   ('&ZERO'(1,1) NE '(').LTRV
&R       SETC  'R'
.LTRV    BC&R  15,&ZERO(1)              BRANCH PER MACRO CALL
         MEXIT
.LTRX    AIF   ('&NOTPOS'(1,1) NE '(').LTRZ
&R       SETC  'R'
.LTRZ    BC&R  15,&NOTPOS(1)            BRANCH PER MACRO CALL
         MEXIT
.LTRY    AIF   ('&NOTNEG'(1,1) NE '(').LTRW
&R       SETC  'R'
.LTRW    BC&R  15,&NOTNEG(1)            BRANCH PER MACRO CALL
         MEXIT
.RG1     AIF   ('&CMP'(1,1) EQ '(' AND '&CMP'(K'&CMP,1) EQ ')').RG12
         AIF   (L'&CMP NE 2).LNOT2
&NAME    CH    &LOC(1),&CMP
         AGO   .C7
.LNOT2   AIF   (L'&CMP EQ 4).LEQ4
         MNOTE *,'LENGTH ATTRIBUTE OF &CMP NOT 2 OR 4.'
.LEQ4    AIF   ('&MODE'(1,1) EQ 'A').NOTLOG
&NAME    CL    &LOC(1),&CMP
         AGO   .C7
.NOTLOG  ANOP
&NAME    C     &LOC(1),&CMP
         AGO   .C7
.RG2     AIF   (L'&LOC NE 2).LNOT22
&NAME    CH    &CMP(1),&LOC
         AGO   .C7R
.LNOT22  AIF   (L'&LOC EQ 4).LEQ42
         MNOTE *,'LENGTH ATTRIBUTE OF &LOC NOT 2 OR 4.'
.LEQ42   AIF   ('&MODE'(1,1) EQ 'A').NOTLOG2
&NAME    CL    &CMP(1),&LOC
         AGO   .C7R
.NOTLOG2 ANOP
&NAME    C     &CMP(1),&LOC
.C7R     ANOP
&W(1)    SETA  2
&W(2)    SETA  4
&W(3)    SETA  11
&W(4)    SETA  13
         AGO   .C7
.RG12    AIF   ('&MODE'(1,1) EQ 'A').RG12A
&NAME    CLR   &LOC(1),&CMP(1)
         AGO   .C7
.RG12A   ANOP
&NAME    CR    &LOC(1),&CMP(1)
         AGO   .C7
.SS      ANOP
&NAME    CLC   &LOC,&CMP
         AGO   .C7
.LTR     ANOP
&NAME    LTR   &LOC(1),&LOC(1)
         AIF   (&B(1)+&B(2)+&B(3) EQ 0).LTRA
         MNOTE 8,'CALL CONTAINS RELATIONAL CONDITIONS.'
.LTRA    AIF   (('&ZERO'EQ''OR'&NOTZERO'EQ''OR'&ELSE'EQ'')AND('&ZERO'EQ,
               ''OR'&POS'EQ''OR'&NEG'EQ''OR'&ELSE'EQ'')AND('&NOTPOS'EQ''
               'OR'&NEG'EQ''OR'&ELSE'EQ'')).LTRM
         MNOTE 8,'REDUNDANT LOGIC, MACRO EXPANSION ATTEMPTED.'
.LTRM    AIF   ('&NOTNEG'EQ''OR'&POS'EQ''OR'&ELSE'EQ'').LTRN
         MNOTE 8,'REDUNDANT LOGIC, MACRO EXPANSION ATTEMPTED.'
.LTRN    AIF   ('&NOTPOS' EQ '').LTRO
         AIF   ('&NOTPOS' EQ 'NEG').LTRX
         AIF   ('&NOTPOS'(1,1) NE '(').LTRP
&R       SETC  'R'
.LTRP    BC&R  13,&NOTPOS(1)            BRANCH PER MACRO CALL
&R       SETC  ''
.LTRO    AIF   ('&NOTNEG' EQ '').LTRQ
         AIF   ('&NOTNEG' EQ '&POS').LTRY
         AIF   ('&NOTNEG'(1,1) NE '(').LTRR
&R       SETC  'R'
.LTRR    BC&R  11,&NOTNEG(1)            BRANCH PER MACRO CALL
&R       SETC  ''
.LTRQ    AIF   ('&ZERO' EQ '').LTRB
         AIF   ('&ZERO' EQ '&NOTZERO' AND '&ZERO' EQ '&POS' AND '&ZERO',
                EQ '&NEG').LTRC
         AIF   ('&ZERO'(1,1) NE '(').LTRD
&R       SETC  'R'
.LTRD    BC&R  8,&ZERO(1)               BRANCH PER MACRO CALL
&R       SETC  ''
.LTRB    AIF   ('&NEG' EQ '').LTRE
         AIF   ('&NEG' EQ '&POS').LTRF
         AIF   ('&NEG'(1,1) NE '(').LTRG
&R       SETC  'R'
.LTRG    BC&R  4,&NEG(1)                 BRANCH PER MACRO CALL
&R       SETC  ''
.LTRE    AIF   ('&NOTZERO' EQ '').LTRH
         AIF   ('&NOTZERO'(1,1) NE '(').LTRI
&R       SETC  'R'
.LTRI    BC&R  7,&NOTZERO(1)            BRANCH PER MACRO CALL
&R       SETC  ''
         AGO   .LTRH
.LTRF    AIF   ('&POS'(1,1) NE '(').LTRK
&R       SETC  'R'
.LTRK    BC&R  7,&POS(1)                BRANCH PER MACRO CALL
&R       SETC  ''
.LTRH    AIF   ('&POS' EQ '').END
         AIF   ('&POS'(1,1) NE '(').LTRJ
&R       SETC  'R'
.LTRJ    BC&R  2,&POS(1)                BRANCH PER MACRO CALL
&R       SETC  ''
         AGO   .END
.ERR1    MNOTE 8,'REQUIRED OPERANDS NOT SUPPLIED.'
.MEND    MEND
./       ADD   NAME=GOIF3
         MACRO
&NAME    GOIF3 &SW,&ALL=,&NONE=,&MIX=,&NOTALL=,&ANY=,&NOTMIX=,         X
               &ELSE=,&ON=,&OFF=
         GBLA  &INDEX
         GBLC  &BYTE,&CRNT
         GBLC  &DEFNAME(255),&SWNAME(255)
         LCLA  &COUNT1,&COUNT2
         LCLB  &FIRST,&COND(3),&USED(6),&TM,&MASK(3)
.*
.*             CHANGES TO RELEASE 3
.*             CHANGES TO RELEASE 2
.*             CHANGES TO RELEASE 1
.*
.* INNER MACRO TO GOIF. GENERATES THE INSTRUCTIONS
.* IF THE FIELD TO TEST IS NOT A SWITCH
.*
 LCLC    &PLUS(7)
.NXT1    ANOP
         AIF   (N'&SW EQ 1).SNGL .      ONLY ONE SWITCH
.NXT1A   ANOP
&COND(1) SETB  0
&COND(2) SETB  0
&COND(3) SETB  0
         AIF   (&USED(1) AND &USED(2) AND &USED(3) AND &USED(4) AND &USX
               ED(5) AND &USED(6)).GEN1
&FIRST   SETB  0
.ALL     AIF   (&USED(1)).NONE
         AIF   (K'&ALL EQ 0).ALL3
&COND(1) SETB  1 .                      BRANCH CONDITION ONES
&FIRST   SETB  1
&CRNT    SETC  '&ALL(1)'
&USED(1) SETB  1
.NONE    AIF   (&USED(2)).MIX
         AIF   (K'&NONE EQ 0).NONE3
         AIF   (&FIRST).NONE2
&COND(2) SETB  1 .                      BRANCH CONDITION ZEROS
&FIRST   SETB  1
&CRNT    SETC  '&NONE(1)'
&USED(2) SETB  1
         AGO   .MIX
.NONE2   AIF   ('&CRNT' NE '&NONE').MIX
&USED(2) SETB  1
&COND(2) SETB  1
.MIX     AIF   (&USED(3)).NOTALL
         AIF   (K'&MIX EQ 0).MIX3
         AIF   (&FIRST).MIX2
&FIRST   SETB  1
&CRNT    SETC  '&MIX(1)'
&USED(3) SETB  1
&COND(3) SETB  1 .                      BRANCH CONDITION MIXED
         AGO   .NOTALL
.MIX2    AIF   ('&CRNT' NE '&MIX').NOTALL
&COND(3) SETB  1
&USED(3) SETB  1
.NOTALL  AIF   (&USED(4)).ANY
         AIF   (K'&NOTALL EQ 0).NOTALL3
         AIF   (&FIRST).NOTALL2
&FIRST   SETB  1
&CRNT    SETC  '&NOTALL(1)'
&USED(4) SETB  1
&COND(2) SETB  1 .                      BRANCH CONDITION ZEROS
&COND(3) SETB  1 .                      BRANCH CONDITION MIXED
         AGO   .ANY
.NOTALL2 AIF   ('&CRNT' NE '&NOTALL').ANY
&USED(4) SETB  1
&COND(2) SETB  1
&COND(3) SETB  1
.ANY     AIF   (&USED(5)).NOTMIX
         AIF   (K'&ANY EQ 0).ANY3
         AIF (&FIRST).ANY2
&FIRST   SETB  1
&CRNT    SETC  '&ANY(1)'
&USED(5) SETB  1 .                      THIS OPTION USED
&COND(1) SETB  1 .                      BRANCH CONDITION ONES
&COND(3) SETB  1 .                      BRANCH CONDITION MIXED
         AGO   .NOTMIX
.ANY2    AIF   ('&CRNT' NE '&ANY').NOTMIX
&USED(5) SETB  1
&COND(1) SETB  1
&COND(3) SETB  1
.NOTMIX  AIF   (&USED(6)).GEN
         AIF   (K'&NOTMIX EQ 0).NOTMIX3
         AIF   (&FIRST).NOTMIX2
&FIRST   SETB  1
&CRNT    SETC  '&NOTMIX(1)'
&USED(6) SETB  1 .                      OPTION USED
&COND(1) SETB  1 .                      BRANCH CONDITION ONES
&COND(2) SETB  1 .                      BRANCH CONDITION ZEROS
         AGO   .GEN
.NOTMIX2 AIF   ('&CRNT' NE '&NOTMIX').GEN
&USED(6) SETB  1
&COND(1) SETB  1
&COND(2) SETB  1
.NOTMIX3 ANOP
&USED(6) SETB  1
         AGO   .GEN
.ANY3    ANOP
&USED(5) SETB  1
         AGO   .NOTMIX
.NOTALL3 ANOP
&USED(4) SETB  1
         AGO   .ANY
.MIX3    ANOP
&USED(3) SETB  1
         AGO   .NOTALL
.NONE3   ANOP
&USED(2) SETB  1
         AGO   .MIX
.ALL3    ANOP
&USED(1) SETB  1
         AGO   .NONE
.GEN     ANOP
         AIF   ('&CRNT' EQ '&ELSE').NXT1
.GEN1    AIF   (&TM).GEN2 .             IF ALREADY GEN'D TM
         AIF   ('&SW' EQ '').GEN2       NO SWITCHES, DON'T DO TM
         AIF   (K'&SW(2) EQ 0).ZIP1
&PLUS(1) SETC  '+'
.ZIP1    AIF   (K'&SW(3) EQ 0).ZIP2
&PLUS(2) SETC  '+'
.ZIP2    AIF   (K'&SW(4) EQ 0).ZIP3
&PLUS(3) SETC  '+'
.ZIP3    AIF   (K'&SW(5) EQ 0).ZIP4
&PLUS(4) SETC  '+'
.ZIP4    AIF   (K'&SW(6) EQ 0).ZIP5
&PLUS(5) SETC  '+'
.ZIP5    AIF   (K'&SW(7) EQ 0).ZIP6
&PLUS(6) SETC  '+'
.ZIP6    AIF   (K'&SW(8) EQ 0).ZIP7
&PLUS(7) SETC  '+'
.ZIP7    ANOP
&NAME    TM    &BYTE,&SW(1)&PLUS(1)&SW(2)&PLUS(2)&SW(3)&PLUS(3)&SW(4)&PX
               LUS(4)&SW(5)&PLUS(5)&SW(6)&PLUS(6)&SW(7)&PLUS(7)&SW(8)
&TM      SETB  1 .                      FLAG AS GENERATED
.GEN2    ANOP
         AIF   (NOT &COND(1) AND NOT &COND(2) AND NOT &COND(3)).NOP    X
                                        NO CONDITIONS, MAY BE A NOP
         AIF   (&COND(2) AND &COND(3)).BNO
         AIF   (&COND(1) AND &COND(3)).BNZ
         AIF   (&COND(1) AND &COND(2)).BNM
         AIF   (&COND(1)).BO
         AIF   (&COND(2)).BZ
         AIF   (&COND(3)).BM
&MASK(1) SETB  1
&MASK(2) SETB  1
&MASK(3) SETB  1
         AIF   ('&CRNT'(1,1) EQ '(').BA1
         B     &CRNT                    BRANCH PER MACRO CALL
         AGO   .NXT1 .                  GO BACK FOR MORE
.BA1     BR    &CRNT                    BRANCH PER MACRO CALL
         AGO   .NXT1
.BO      AIF   (&MASK(1)).ERR4
&MASK(1) SETB  1
         AIF   ('&CRNT'(1,1) EQ '(').BO1
         BO    &CRNT                    BRANCH PER MACRO CALL
 AGO     .NXT1
.BO1     BCR   1,&CRNT                  BRANCH PER MACRO CALL
         AGO   .NXT1
.BZ      AIF   (&MASK(2)).ERR4
&MASK(2) SETB  1
         AIF   ('&CRNT'(1,1) EQ '(').BZ1
         BZ    &CRNT                    BRANCH PER MACRO CALL
         AGO   .NXT1
.BZ1     BCR   8,&CRNT                  BRANCH PER MACRO CALL
         AGO   .NXT1
.BM      AIF   (&MASK(3)).ERR4
&MASK(3) SETB  1
         AIF   ('&CRNT'(1,1) EQ '(').BM1
         BM    &CRNT                    BRANCH PER MACRO CALL
         AGO   .NXT1
.BM1     BCR   4,&CRNT                  BRANCH PER MACRO CALL
         AGO   .NXT1
.BNO     AIF   (&MASK(2) OR &MASK(3)).ERR4
&MASK(2) SETB  1
&MASK(3) SETB  1
         AIF   ('&CRNT'(1,1) EQ '(').BNO1
         BNO   &CRNT                    BRANCH PER MACRO CALL
         AGO   .NXT1
.BNO1    BCR   14,&CRNT                 BRANCH PER MACRO CALL
         AGO   .NXT1
.BNZ     AIF   (&MASK(1) OR &MASK(3)).ERR4
&MASK(1) SETB  1
&MASK(3) SETB  1
         AIF   ('&CRNT'(1,1) EQ '(').BNZ1
         BNZ   &CRNT                    BRANCH PER MACRO CALL
         AGO   .NXT1
.BNZ1    BCR   7,&CRNT                  BRANCH PER MACRO CALL
         AGO   .NXT1
.BNM     AIF   (&MASK(1) OR &MASK(2)).ERR4
&MASK(1) SETB  1
&MASK(2) SETB  1
         AIF   ('&CRNT'(1,1) EQ '(').BNM1
         BNM   &CRNT                    BRANCH PER MACRO CALL
         AGO   .NXT1
.BNM1    BCR   11,&CRNT                 BRANCH PER MACRO CALL
         AGO   .NXT1
.ERR4    ANOP
         MNOTE 8,'REDUNDANT LOGIC--CONDITION USED MORE THAN ONCE'
         AGO   .DONE
.ERR10   ANOP
         MNOTE 8,'OPTIONS ARE ONLY LEGAL FOR MULTIPLE SWITCH'
         AGO   .SNGL3
.ERR3    ANOP
.OUT     ANOP
.NOP     ANOP
.DONE    AIF   (K'&ELSE EQ 0).DONE2
         AIF   (&MASK(1) AND &MASK(2) AND &MASK(3)).ERR4
         AIF   ('&ELSE'(1,1) EQ '(').DONE3
         B     &ELSE                    BRANCH PER MACRO CALL
.DONE2   MEXIT
.DONE3   BR    &ELSE                    BRANCH PER MACRO CALL
         MEXIT
.SNGL    ANOP
         AIF   ('&MIX' NE '' OR '&NOTMIX' NE '').ERR10
.SNGL3   ANOP
&NAME    TM    &BYTE,&SW
         AIF   ((K'&ON NE 0) AND (K'&OFF NE 0)).B2
         AIF   ((K'&ON EQ 0) AND (K'&OFF EQ 0)).NOP
         AIF   (K'&ON EQ 0).SNGL2
         AIF   ('&ON'(1,1) EQ '(').BO91
         BO    &ON                      BRANCH PER MACRO CALL
         AGO   .DONE
.BO91    BCR   1,&ON(1)                 BRANCH PER MACRO CALL
         AGO   .DONE
.SNGL2   ANOP
         AIF   ('&OFF'(1,1) EQ '(').BZ91
         BZ    &OFF                     BRANCH PER MACRO CALL
         AGO   .DONE
.BZ91    BCR   8,&OFF(1)                BRANCH PER MACRO CALL
         AGO   .DONE
.B2      AIF   ('&ON' EQ '&OFF').B3
         AIF   ('&ON'(1,1) EQ '(').B20
         BO    &ON                      BRANCH PER MACRO CALL
         AGO   .B21
.B20     BCR   1,&ON(1)                 BRANCH PER MACRO CALL
.B21     AIF   ('&OFF'(1,1) EQ '(').B23
         BZ    &OFF                     BRANCH PER MACRO CALL
         AGO   .DONE
.B23     BCR   8,&OFF(1)                BRANCH PER MACRO CALL
         AGO   .DONE
.B3      ANOP
         AIF   ('&ON'(1,1) EQ '(').B30
         B     &ON                      BRANCH PER MACRO CALL
         AGO   .DONE
.B30     BR    &ON(1)                   BRANCH PER MACRO CALL
         AGO   .DONE
         MEND
./       ADD   NAME=GOTO
         MACRO
&LABEL   GOTO  &ROUTINE
.*
         GBLC  &X0(26)
         GBLC  &X1(26)
         GBLC  &X2(26)
         GBLC  &X3(26)
         GBLC  &X4(26)
         GBLC  &X5(26)
         GBLC  &X6(26)
         GBLC  &X7(26)
         GBLC  &X8(26)
         GBLC  &X9(26)
         GBLC  &XA(26)
         GBLC  &XB(26)
         GBLC  &XC(26)
         GBLC  &XD(26)
         GBLC  &XE(26)
         GBLC  &XF(26)
.*
         LCLC  &PHASEID
         LCLA  &I
.*
.*             CHANGES TO RELEASE 3
.*             CHANGES TO RELEASE 2
.*             CHANGES TO RELEASE 1
.*
.* GENERATES A BRANCH AND LINK TO A SUBROUTINE
.* WHICH NAME IS DEFINED IN THE EXTERNAL NAME
.* ARRAY BUILT BY CONTAINS
.*
         AIF   (K'&ROUTINE EQ 0 OR N'&SYSLIST GT 1).ERR1
.*
.X0      AIF   ('&X0(1)' EQ '').INT
&PHASEID SETC  '&X0(1)'(4,5)
&I       SETA  2
.X01     AIF   ('&X0(&I)' EQ '&ROUTINE').EXT
         AIF   (&I EQ 26).X1
&I       SETA  &I+1
         AIF   ('&X0(&I)' NE '').X01
.*
.X1      AIF   ('&X1(1)' EQ '').INT
&PHASEID SETC  '&X1(1)'(4,5)
&I       SETA  2
.X11     AIF   ('&X1(&I)' EQ '&ROUTINE').EXT
         AIF   (&I EQ 26).X2
&I       SETA  &I+1
         AIF   ('&X1(&I)' NE '').X11
.*
.X2      AIF   ('&X2(1)' EQ '').INT
&PHASEID SETC  '&X2(1)'(4,5)
&I       SETA  2
.X21     AIF   ('&X2(&I)' EQ '&ROUTINE').EXT
         AIF   (&I EQ 26).X3
&I       SETA  &I+1
         AIF   ('&X2(&I)' NE '').X21
.*
.X3      AIF   ('&X3(1)' EQ '').INT
&PHASEID SETC  '&X3(1)'(4,5)
&I       SETA  2
.X31     AIF   ('&X3(&I)' EQ '&ROUTINE').EXT
         AIF   (&I EQ 26).X4
&I       SETA  &I+1
         AIF   ('&X3(&I)' NE '').X31
.*
.X4      AIF   ('&X4(1)' EQ '').INT
&PHASEID SETC  '&X4(1)'(4,5)
&I       SETA  2
.X41     AIF   ('&X4(&I)' EQ '&ROUTINE').EXT
         AIF   (&I EQ 26).X5
&I       SETA  &I+1
         AIF   ('&X4(&I)' NE '').X41
.*
.X5      AIF   ('&X5(1)' EQ '').INT
&PHASEID SETC  '&X5(1)'(4,5)
&I       SETA  2
.X51     AIF   ('&X5(&I)' EQ '&ROUTINE').EXT
         AIF   (&I EQ 26).X6
&I       SETA  &I+1
         AIF   ('&X5(&I)' NE '').X51
.*
.X6      AIF   ('&X6(1)' EQ '').INT
&PHASEID SETC  '&X6(1)'(4,5)
&I       SETA  2
.X61     AIF   ('&X6(&I)' EQ '&ROUTINE').EXT
         AIF   (&I EQ 26).X7
&I       SETA  &I+1
         AIF   ('&X6(&I)' NE '').X61
.*
.X7      AIF   ('&X7(1)' EQ '').INT
&PHASEID SETC  '&X7(1)'(4,5)
&I       SETA  2
.X71     AIF   ('&X7(&I)' EQ '&ROUTINE').EXT
         AIF   (&I EQ 26).X8
&I       SETA  &I+1
         AIF   ('&X7(&I)' NE '').X71
.*
.X8      AIF   ('&X8(1)' EQ '').INT
&PHASEID SETC  '&X8(1)'(4,5)
&I       SETA  2
.X81     AIF   ('&X8(&I)' EQ '&ROUTINE').EXT
         AIF   (&I EQ 26).X9
&I       SETA  &I+1
         AIF   ('&X8(&I)' NE '').X81
.*
.X9      AIF   ('&X9(1)' EQ '').INT
&PHASEID SETC  '&X9(1)'(4,5)
&I       SETA  2
.X91     AIF   ('&X9(&I)' EQ '&ROUTINE').EXT
         AIF   (&I EQ 26).XA
&I       SETA  &I+1
         AIF   ('&X9(&I)' NE '').X91
.*
.XA      AIF   ('&XA(1)' EQ '').INT
&PHASEID SETC  '&XA(1)'(4,5)
&I       SETA  2
.XA1     AIF   ('&XA(&I)' EQ '&ROUTINE').EXT
         AIF   (&I EQ 26).XB
&I       SETA  &I+1
         AIF   ('&XA(&I)' NE '').XA1
.*
.XB      AIF   ('&XB(1)' EQ '').INT
&PHASEID SETC  '&XB(1)'(4,5)
&I       SETA  2
.XB1     AIF   ('&XB(&I)' EQ '&ROUTINE').EXT
         AIF   (&I EQ 26).XC
&I       SETA  &I+1
         AIF   ('&XB(&I)' NE '').XB1
.*
.XC      AIF   ('&XC(1)' EQ '').INT
&PHASEID SETC  '&XC(1)'(4,5)
&I       SETA  2
.XC1     AIF   ('&XC(&I)' EQ '&ROUTINE').EXT
         AIF   (&I EQ 26).XD
&I       SETA  &I+1
         AIF   ('&XC(&I)' NE '').XC1
.*
.XD      AIF   ('&XD(1)' EQ '').INT
&PHASEID SETC  '&XD(1)'(4,5)
&I       SETA  2
.XD1     AIF   ('&XD(&I)' EQ '&ROUTINE').EXT
         AIF   (&I EQ 26).XE
&I       SETA  &I+1
         AIF   ('&XD(&I)' NE '').XD1
.*
.XE      AIF   ('&XE(1)' EQ '').INT
&PHASEID SETC  '&XE(1)'(4,5)
&I       SETA  2
.XE1     AIF   ('&XE(&I)' EQ '&ROUTINE').EXT
         AIF   (&I EQ 26).XF
&I       SETA  &I+1
         AIF   ('&XE(&I)' NE '').XE1
.*
.XF      AIF   ('&XF(1)' EQ '').INT
&PHASEID SETC  '&XF(1)'(4,5)
&I       SETA  2
.XF1     AIF   ('&XF(&I)' EQ '&ROUTINE').EXT
         AIF   (&I EQ 26).XG
&I       SETA  &I+1
         AIF   ('&XF(&I)' NE '').XF1
.*
.XG      ANOP
.*
.INT     ANOP
&LABEL   BAL   R9,&ROUTINE              GO TO ROUTINE
         MEXIT
.*
.*
.EXT     ANOP
&LABEL   L     R12,&PHASEID             GET ADDRESS OF PIVOT
         AIF   (&I EQ 2).EXT1
&I       SETA  &I*4-8
         BAL   R9,&I.(,R12)             GO TO ROUTINE
         MEXIT
.EXT1    BALR  R9,R12                   GO TO ROUTINE
         MEXIT
.ERR1    MNOTE 4,'ROUTINE NAME EXCESSIVE OR MISSING.'
.MEND    MEND
./       ADD   NAME=ICOMMON
*                        DEFINE EXTERNAL ROUTINES                     *
         SPACE
         AIF   ('&TESTRAN' NE 'YES').X4D
&COMPNM.X4N01  CONTAINS  DCSCAN,XDSCAN,SYMPUNCH
         AGO   .X4N
.X4D     ANOP
&COMPNM.X4D01  CONTAINS  DCSCAN,XDSCAN
.X4N     ANOP
&COMPNM.X4E01  CONTAINS  BLDESD,MAKESD,GETESD,ENTRY,EXTRN,VCON,QCON,   ,
               REFER
&COMPNM.X4S01  CONTAINS  FIND,ENTER,SUBSET
&COMPNM.X4V01  CONTAINS  EVAL
         SPACE
         SPACE
*                        ADDRESSING VIA WORK REGISTERS                *
         SPACE
DSECT2   DSECT ,                        ADDRESS
         USING DSECT2,R2                BASE
         SPACE
DSECT3   DSECT ,                        ADDRESS
         USING DSECT3,R3                BASE
         SPACE
         USING JTEXT,R4                 BASE
         SPACE
DSECT5   DSECT ,                        ADDRESS
         USING DSECT5,R5                BASE
         SPACE
DSECT6   DSECT ,                        ADDRESS
         USING DSECT6,R6                BASE
         SPACE
DSECT7   DSECT ,                        ADDRESS
         USING DSECT7,R7                BASE
         SPACE
DSECT10  DSECT ,                        ADDRESS
         USING DSECT10,R10              BASE
         SPACE
DSECT11  DSECT                          ADDRESS
         USING DSECT11,R11              BASE
         SPACE
DSECT12  DSECT ,                        ADDRESS
         USING DSECT12,R12              BASE
         SPACE
DSECT14  DSECT ,                        ADDRESS
         USING DSECT14,R14              BASE
         SPACE
DSECT15  DSECT ,                        ADDRESS
         USING DSECT15,R15              BASE
         EJECT
DSECT7   DSECT ,                        ADDRESS
         ORG   DSECT7                   ORIGIN
         SPACE
SAVE     JSAVE BASE=NO                  SAVE REGISTER
         BR    R14                      RETURN
EXIT     JRETURN                        RESTORE REGISTERS AND RETURN
         AIF   ('&TESTRAN' NE 'YES').X4D1
X4N01    DS    A                        DC EVALUATION (TESTRAN VERSION)
         AGO   .X4N1
.X4D1    ANOP
X4D01    DS    A                        DC EVALUATION
.X4N1    ANOP
X4E01    DS    A                        ESD PROCESSING
X4S01    DS    A                        SYMBOL TABLE ROUTINES
X4V01    DS    A                        EXPRESSION EVALUATION
         EJECT
HASHNR   EQU   64                       NUMBER OF HASH CHAINS
MINDBL   EQU   1024                     MINIMUM STORAGE REQUIREMENT
MAXDBL   EQU   4095                     MAXIMUM STORAGE REQUIREMENT
ALIGNB   EQU   B'00000001'              BYTE ALIGNMENT MASK
ALIGNH   EQU   B'00000010'              HALFWORD ALIGNMENT MASK
ALIGNF   EQU   B'00000100'              FULLWORD ALIGNMENT MASK
ALIGND   EQU   B'00001000'              DOUBLEWORD ALIGNMENT MASK
         EJECT
*                        EXTERNAL SYMBOL DICTIONARY                   *
         SPACE
ESDBLK1  DS    A(*+4),H'324,0',16XL20   ESD BLOCK 1
ESDBLK2  DS    A(*+4),H'324,0',16XL20   ESD BLOCK 2
FILELAST DS    01XL9                    END OF SPILL FILE
NOTELIST DS    25XL9                    ADDRESS OF ESD BLOCKS
OOPS     DS    X                        ESD OVERFLOW VALVE
         EJECT
SYMDIMEN DS    4F                       SYMBOL TABLE POINTERS
HASHTBL  DS    (HASHNR)F                HASH TABLE
         EJECT
SWTCH1   DSW   ,                        SWITCH 1                       ,
               ,                                                       ,
               ,                                                       ,
               ,                                                       ,
               STBLOFLO,                SYMBOL TABLE OVERFLOW          ,
               ,                             NOT USED                  ,
               IOFLO,                                                  ,
               INOTE
         SPACE
SWTCH2   DSW   ,                        SWITCH 2                       ,
               ,                                                       ,
               INCSECT,                                                ,
               ,                                                       ,
               DCMODEXP,                     DC MODIFIER EXPRESSION    ,
               ,                                                       ,
               ,                             NOT USED                  ,
                                             NOT USED
MODE     DS    0H                       RESERVED FOR MODE SWITCHES ONLY
         DS    X                        RESERVED FOR MODE SWITCHES ONLY
         DSW   ,,,,MODE1,MODE2,,        RESERVED FOR MODE SWITCHES ONLY
STARTLOC DS    A                        START LOCATION
HIESDNR  DS    H                        HIGH ESD ID
DCDSSW   DSW   SDZDUPF                  SELF DEF ZERO AS DUPF
DCDSMODE DSW   NOESD,NOESDS,LMOD,BMOD,SMOD     MODE
LINECNT  DS    H                               LINE COUNT
LOCTRSAV DS    XL6                      LOCATION COUNTER SAVE AREA
SYMCARD  DS    3F                       TESTRAN CARD BUFFER ADDRESS
         ORG   LOCTRSAV                 AFTER ASSIGNMENT MODE
         DS    H                        NOT USED
CARDADDR DS    2F                       ADDRESS OF ESD CARD BUFFER
ADJINDEX DS    2F                       ESD ADJUSTMENT TABLE INDEX
LATADD   DS    F                        FIRST LITERAL ENTRY ADDRESS
LATEND   DS    F                        NEXT LITERAL ENTRY ADDRESS
LATA8    DS    F                        8 CHAIN ADDRESS
LATA4    DS    F                        4 CHAIN ADDRESS
LATA2    DS    F                        2 CHAIN ADDRESS
LATA1    DS    F                        1 CHAIN ADDRESS
XPARM    DS    F                        PARAMETER
         SPACE
*                        TESTRAN OUTPUT BUFFER                        *
         SPACE
         DS    0F                       ALIGNMENT
ORGBYTE  DBV   TSPACE(X'08'),           BYTES SKIPPED                  ,
               TCSECT(X'18'),           CSECT                          ,
               TDSECT(X'28'),           DSECT                          ,
               TCOM(X'38'),             COM                            ,
               TMOP(X'48'),             MACHINE OP                     ,
               TCCW(X'58'),             CCW                            ,
               TMIS(X'68'),             CATCH ALL                      ,
               TDATA(X'88')             DATA TYPE
         ORG   ORGBYTE                             ORIGIN
         DSW   ,MULTIPLE,CLUSTER,SCALING,LABEL     INDICATORS
ADDRESS  DS    AL3                                 ADDRESS
NAME     DS    CL8                      NAME
LENGTH   DS    F                        LENGTH
MULTIP   DS    F                        MULTIPLICITY
SCALE    DS    H                        SCALE
DATATYPE DBV   ,                        DATA TYPE                      ,
               DTYPEC(X'00'),           DATA TYPE C                    ,
               DTYPEX(X'04'),           DATA TYPE X                    ,
               DTYPEB(X'08'),           DATA TYPE B                    ,
               DTYPEF(X'10'),           DATA TYPE F                    ,
               DTYPEH(X'14'),           DATA TYPE H                    ,
               DTYPEE(X'18'),           DATA TYPE E                    ,
               DTYPED(X'1C'),           DATA TYPE D                    ,
               DTYPEA(X'20'),           DATA TYPE A                    ,
               DTYPEQ(X'20'),           DATA TYPE Q                    ,
               DTYPEY(X'24'),           DATA TYPE Y                    ,
               DTYPES(X'28'),           DATA TYPE S                    ,
               DTYPEV(X'2C'),           DATA TYPE V                    ,
               DTYPEP(X'30'),           DATA TYPE P                    ,
               DTYPEZ(X'34'),           DATA TYPE Z                    ,
               DTYPEL(X'38')            DATA TYPE L
         DS    X                        NOT USED
         SPACE
*                        SYMBOL TABLE STAGING AREA                    *
         SPACE
XWORK    DS    0F                       WORK
         DS    H                        X
XFLGA    DS    X                        WORK
XFLGB    DS    X                        WORK
XTYPE    DS    X                        WORK
XFLDI    DS    X                        WORK
XESDI    DS    H                        WORK
XLCTR    DS    F                        WORK
XNAME    DS    CL8                      WORK
XLNGQ    DS    H                        WORK
FSTCSECT DS    H                        FIRST CSECT NUMBER NUMBER
HICESDID DS    H                        HIGH EVERYTHING ELSE NUMBER
HIDESDID DS    H                        HIGH DSECT NUMBER
INOTEVAL DS    XL8                      INPUT NOT ADDRESS
         EJECT
*                        DC/DS ROUTINE WORK AREA                      *
         SPACE
         DCDSWORK
         SPACE
         DS    0F
INPUTBUF DS    XL300                    INPUT BUFFER
         EJECT
*                        EVALUATION ROUTINE WORK AREA                 *
         SPACE
         EVALWORK
ENDOFCOM DS    0F                       ENOVID
         EJECT
DSECT6   DSECT ,                        ADDRESS
         ORG   DSECT6                   ORIGIN
         SPACE
EITEM    DS    0XL20                    ESD ENTRY
ETYPE    DBV   ,                        ESD TYPE                       ,
               ETYPESD(X'00'),               CONTROL SECTION--CSECT    ,
               ETYPELD(X'01'),               LABEL DEFINITION--ENTRY   ,
               ETYPEER(X'02'),               EXTERNAL REFERENCE--EXTRN ,
               ETYPEPC(X'04'),               PRIVATE CODE--            ,
               ETYPECM(X'05'),               COMMON SECTION--COM       ,
               ETYPEXD(X'06'),               EXTERNAL DUMMY--DXD       ,
               ETYPEDX(X'07'),               EXTERNAL DUMMY--DSECT     ,
               ETYPEDS(X'08'),               DUMMY SECTION--DSECT      ,
               ETYPELX(X'09'),               LABEL DEFINITION - ENTRY  ,
               ETYPEWX(X'0A')                EXTERNAL REFERENCE - WXTRN
         SPACE
EFLGS    DSW   ,                             NOT USED                  ,
               ,                             NOT USED                  ,
               ,                             NOT USED                  ,
               ,                             NOT USED                  ,
               ESDNRSW2,                     X                         ,
               CSECTSW2,                     X                         ,
               DSECTSW2,                X                              ,
               DSCOMSW2                 X
         SPACE
ERCDC    DS    0XL6                     FIELD
ESWTS    DSW   ,DSW2,CSW2,QDSW2
         ORG   ESWTS                    ORIGIN
EESDI    DS    H                        ESD IDENTIFICATION
EFLDA    EQU   *                        FIELD
ELCTR    DS    F                        CURRENT LOCATION COUNTER VALUE
EHILC    DS    F                        HIGH LOCATION COUNTER VALUE
         ORG   EFLDA                    ORIGIN
         DS    H                        NOT USED
ELDID    DS    H                        CONTROL SECTION DEFINED
ELDAD    DS    F                        OFFSET IN CONTROL SECTION
         ORG   EFLDA                    ORIGIN
EXDAL    DBV   ,                        ALIGNMENT                      ,
               EXDALX(B'00000000'),          BYTE BOUNDARY             ,
               EXDALH(B'00000001'),          HALFWORD BOUNDARY         ,
               EXDALF(B'00000011'),          FULLWORD BOUNDARY         ,
               EXDALD(B'00000111'),          DOUBLEWORD BOUNDARY
         DS    X                        NOT USED
EXDID    DS    H                        ESDID OF DSECT REFERENCED
EXDLN    DS    F                        DUMMY SECTION LENGTH
ENAME    DS    CL8                      SYMBOL
         EJECT
DSECT14  DSECT ,                        ADDRESS
         ORG   DSECT14                  ORIGIN
         SPACE
*                        FORMAT OF SYMBOL TABLE ENTRY                 *
         SPACE
SFLGS    DSW   LNGDEF,                  X                              ,
               XDUMMY,                  X                              ,
               XENTRY,                  X                              ,
               ENTRYSW,                 X                              ,
               ESDNRSW,                 X                              ,
               CSECTSW,                 X                              ,
               DSECTSW,                 X                              ,
               DSCOMSW                  X
         SPACE
         ORG   SFLGS                    ORIGIN
SCHPT    DS    A                        CHAIN POINTER
SNAME    DS    CL8                      SYMBOL
SLNGQ    DS    H                        SYMBOL LENGTH ATTRIBUTE
SSWTS    DSW   ,DSW,CSW,,ESW            X                       OX00106
         ORG   SSWTS                    ORIGIN
SESDI    DS    H                        ESDID ASSOCIATED WITH VALUE
SLCTR    DS    F                        VALUE
         SPACE
SLAST    EQU   *                        X
         ORG   SCHPT                    ORIGIN
SITEM    DS    0XL(SLAST-SCHPT)         FIELD
         ORG   SNAME                    ORIGIN
SSEG1    DS    0XL(L'SNAME+L'SLNGQ)     FIELD
         ORG   SESDI                    ORIGIN
SSEG2    DS    0XL(L'SESDI+L'SLCTR)     FIELD
./       ADD   NAME=IFNX4E
X4E      XDICT
         JPATCH X4E00,7BE
         END
./       ADD   NAME=IFOX0F
*         ASSEMBLER (XF) MACRO REFERENCE LIST
*         WRITTEN BY BILL GODFREY, PLANNING RESEARCH CORPORATION,
*         PRC COMPUTER CENTER INC, MCLEAN VA 22101
*         DATE WRITTEN. JULY 1978.
*         DATE UPDATED. MARCH 25 1981.
*         DESCRIPTION.
*          THIS MODIFICATION TO THE ASSEMBLER (XF) PRODUCES
*          A LISTING OF ALL MACRO/COPY NAMES READ FROM
*          SYSLIB BY THE ASSEMBLER, AND THE CONCATENATION
*          NUMBER OF THE SYSLIB DATA SET IN WHICH THE
*          MEMBER WAS FOUND.
*
*          THE LISTING IS GENERATED ONLY IF THERE IS
*          A 'MACREF' DD STATEMENT PRESENT. THE LISTING
*          IS WRITTEN TO SYSPRINT, HOWEVER, SO THE MACREF
*          SHOULD BE DUMMY. IT IS MERELY A SWITCH.
*
*          THE LIST IS SORTED BY MEMBER WITHIN CONCAT NUMBER.
*
*          THE OBJECT CODE SHOULD BE LINK-EDITED WITH A NAME
*          OF IFOXX4, WHICH THE REGULAR ASSEMBLER DOES NOT USE.
*          THEN ZAP IFOX00 (OR PREFERABLY A RENAMED COPY OF IT)
*          VER 0414 E7F0F4, REP 0414 E7E7F4.  IFOX04 TO IFOXX4.
*          VER 043A E7F4F1, REP 043A E7F4C1.  IFOX41 TO IFOX4A.
*          VER 0441 E7F4F2, REP 0441 E7F4C2.  IFOX42 TO IFOX4B.
*
*          THE IBM SOURCE CODE IS FROM 8010 LEVEL, HAVING
*          BEEN KEPT UP TO DATE LOCALLY BY MODIFING OLDER
*          IBM SOURCE CODE.
*
*          FOR PTF'S UZ09886 (7707) AND UZ13353 (7710).
*          PTF UZ19741 (7808) SUPERCEDES UZ13353, BUT
*          LEAVES THIS MODULE THE SAME AS UZ13353.
*
*          MOST RECENT CHANGE: PTF UZ32460 (8010).
*
*          TO COMPARE THIS CODE WITH THE CURRENT IBM SOURCE
*          (ON MICROFICHE FOR EXAMPLE), CHANGE THE 'SETB'
*          FOR &MACREF TO ZERO AND ASSEMBLE.  THIS WILL
*          PRODUCE AN ASSEMBLY WITHOUT THE MODIFICATIONS,
*          WHICH YOU CAN COMPARE TO THE MICROFICHE.
*
         MACRO
         IEZIOB
IOB      DSECT
         DS    XL8
IOBBPAMN DS    0D
         DS    XL17
IOBCSW   DS    0CL7
         MEND
* /* START OF SPECIFICATIONS ****
*02* PROCESSOR = ASSEMBLER
**** END OF SPECIFICATIONS ***/
         GBLB  &MACREF                                            .PRC.
         GBLC  &COMPNM,&ASMID
&MACREF  SETB  1        1 = MODS    0 = NO MODS                   .PRC.
         JHEAD 'INPUT I/O MODULE - PROLOG',                            X
               PHASEID=X0F,                                            X
               LEVEL=10
*                                                                     *
*FUNCTION/OPERATION-                                                  *
*   THIS MODULE IS THE INPUT I/O MODULE FOR THE ASSEMBLER.  IT IS     *
*   USED BY THE MACRO EDITOR TO READ SOURCE INPUT, COPY CODE AND      *
*   MACROS.                                                           *
*                                                                     *
*ENTRY POINT-                                                         *
*        START+0  - GET INPUT STATEMENT. DISPLACEMENT-JINPUT.         *
*        START+4  - FIND MACRO IN LIBRARY. DISPLACEMENT-JFIND.        *
*        START+8  - NOTE POSITION OF LIBRARY. DISPLACEMENT-JNOTELB.   *
*        START+12 - POINT TO NOTED POSITION. DISPLACEMENT-JPOINTLB.   *
*        START+16 - INITIALIZE INPUT I/O MODULE, OPEN INPUT FILES ON  *
*   FIRST ENTRY, CLOSE INPUT FILES ON SECOND ENTRY. DISP.-JININIT.    *
*                                                                     *
*INPUT-                                                               *
*   SYSIN, SYSLIB.                                                    *
*                                                                     *
*OUTPUT-                                                              *
*   N/A                                                               *
*                                                                     *
*EXTERNAL ROUTINES-                                                   *
*   N/A                                                               *
*                                                                     *
*EXITS, NORMAL-                                                       *
*   RETURN TO CALLER VIA REGISTER R9.                                 *
*   FOR JINPUT, CC=2 MEANS RECORD READ CORRECTLY. CC=0 MEANS EOF READ.*
*   FOR JFIND, CC=2 MEANS MACRO OR COPY CODE FOUND. CC=0 MEANS MACRO  *
*   OR COPY CODE NOT FOUND                                            *
*                                                                     *
*EXITS, ERROR-                                                        *
*   BRANCH TO JABORT IN COMMON.                                       *
*                                                                     *
*TABLE/WORK AREAS-                                                    *
*   REGISTER R13 POINTS TO COMMON.  JADINCM, WHICH IS LOADED INTO     *
*   REGISTER R7, POINTS TO THE INPUT COMMON AREA.                     *
*                                                                     *
*ATTRIBUTES-                                                          *
*   REFRESHABLE.                                                      *
*                                                                     *
*NOTES-                                                               *
*                                                                     *
* MVS RELEASE 3.7 AND 3.8 CHANGES                           A@AZ47182 *
* A648500-650500                                            A@AZ47182 *
*                                                                     *
         SPACE 3
         PRINT OFF                      DON'T PRINT JCOMMON COPY CODE
         COPY  JCOMMON                  JCOMMON COPY CODE
         PRINT ON                       THAT'S ALL WE WON'T PRINT
         SPACE
         TITLE '&COMPNM&ASMID - INPUT I/O MODULE - JINCOM COPY CODE'
         COPY  JINCOM
         SPACE 3
         TITLE '&COMPNM&ASMID - INPUT I/O MODULE - DCBD MACRO'
         PRINT NOGEN                                              .PRC.
         DCBD  DSORG=(PS,PO),DEVD=(DA)
         PRINT GEN                                                .PRC.
         SPACE 3
    TITLE '&COMPNM&ASMID - INPUT I/O MODULE - MAPPING DSECT (MAPDSECT)'
         IEZIOB
         SPACE 3
        TITLE '&COMPNM&ASMID - INPUT I/O MODULE - DDNAME OVERRIDE LIST'
P        DSECT                          DDNAME OVERRIDE LIST
PLEN     DS    H                        LENGTH OF LIST
         DS    3CL8                     (NOT APPLICABLE)
PSYSLIB  DS    CL8                      SYSLIB DDNAME
PSYSIN   DS    CL8                      SYSIN DDNAME
PSYSPRIN DS    CL8                      SYSPRINT DDNAME
PSYSPUNC DS    CL8                      SYSPUNCH DDNAME
PSYSUT1  DS    CL8                      SYSUT1 DDNAME
PSYSUT2  DS    CL8                      SYSUT2 DDNAME
PSYSUT3  DS    CL8                      SYSUT3 DDNAME
PSYSGO   DS    CL8                      SYSGO DDNAME
D80      EQU   80                       DECIMAL 80
         SPACE 5
         TITLE '&COMPNM&ASMID - INPUT I/O MODULE - MAINLINE CONTROL'
* VS1 RELEASE 3.1 CHANGES
*C678000                                                        OY02543
*A258500-259500                                                @OZ04367
*A705100,705200                                                @AX19477
*C706500                                                       @AX19477
         JCSECT (X0F00)                 SECTION ID
         JMODID                         EMBEDDED IDENTIFIER
         USING START,R12                SET BASE OF R12
START    B     INPUT                    JINPUT ENTRY
         B     FIND                     JFIND ENTRY
         B     NOTELB                   JNOTELB ENTRY
         B     POINTLB                  JPOINTLB ENTRY
         B     ININIT                   INIT & TERM ENTRY
         SPACE 3
         JENTRY (X0F01=START)           MODULE ENTRY POINT
         SPACE 3
SAVE     JSAVE BASE=NO                  SAVE REGISTERS
         L     R7,JADINCM               LOAD ADDRESS OF INPUT COMMON
         BR    R14                      NOW GO ON WITH BUSINESS
         SPACE 3
RETURN   JRETURN                        RESTORE REGISTERS & RETURN
         SPACE 5
         TITLE '&COMPNM&ASMID - INPUT I/O MODULE - ''JINPUT'' ROUTINE'
INPUT    BAL   R14,SAVE                 GO SAVE REGISTERS
         GOIF  JINLIB,ON=INLIB          INPUT FROM LIBRARY
         LA    R6,RETURN                LOAD RETURN ADDR FOR EOD USE
         L     R1,JSYSIN                LOAD INPUT FILE DEF ADDRESS
         LR    R11,R10                  SAVE R10               @OZ04367
         LA    R10,XTIN                 GET ADDRESS TO EXIT    @OZ04367
         GET   (1)                      GET A RECORD. ADDR IN R1
         L     R14,JRECIN               WELL...NO EOF, THEN COUNT CARDS
         LA    R14,D1(,R14)             ONE MORE CARD READ
         ST    R14,JRECIN               SAVE IT FOR NEXT TIME
         TR    D0(D80,R1),JTRTABLE      TRANSLATE STATEMENT
         LTR   R11,R1                   PASS BACK RECORD ADDRESS, SET
         B     RETURN                   CC=2 AND RETURN
         SPACE 3
INLIB    LH    R4,JLIBNDX               GET BUFFER INDEX
         AH    R4,=H'80'                ADD 80 (LOGICAL RECORD LENGTH)
         L     R5,JLIBBUF               POINT TO PHYSICAL BUFFER
         GOIF  JREADPT,ON=READ          READ NECESSARY FOR POINT
CHECKSIZ CH    R4,JBLKSIZE              HAVE WE EXAUSTED PHY REC
         BL    NOREAD                   NO.
READ     LA    R6,RETURN                EOF RETURN PT AFTER CC=0
         READ  JLIBDECB,SF,,(R5),MF=E   READ PHY RECORD
         CHECK JLIBDECB                 CHECK READ
         L     R1,JSYSLIB               POINT TO DCB
         USING IHADCB,R1                FIND RECORD SIZE
         L     R14,DCBIOBA              GET ADDR OF IOB
         LH    R15,DCBBLKSI             RECORD SIZE = READ LENGTH -
         USING IOBBPAMN,R14             SET UP IOB USING
         SH    R15,IOBCSW+5             GET RESIDUAL COUNT
         DROP  R14
         STH   R15,JBLKSIZE               ''
         DROP  R1                       DROP DCB BASE
         GOIF  JREADPT,OFF=RESET        READ WASN'T NECESSARY FOR POINT
         SET   JREADPT,OFF              SET READ BECUASE OF POINT OFF
         B     CHECKSIZ                 CHK TO SEE IF END OF BUF
RESET    SR    R4,R4                    ZERO BUFFER INDEX
NOREAD   STH   R4,JLIBNDX               SAVE BUFFER INDEX
         LA    R11,D0(R4,R5)            LOG ADDR=PHY ADDR+INDEX
         TR    D0(D80,R11),JTRTABLE     TRANSLATE TO INTERNAL
         L     R14,JRECLIB              ADD ONE TO LIB CARD COUNT
         LA    R14,D1(,R14)             ''
         ST    R14,JRECLIB              ''
         LTR   R11,R11                  SET CC=2 (NO EOF) AND
         B     RETURN                   RETURN
         SPACE 5
         TITLE '&COMPNM&ASMID - INPUT I/O MODULE - ''JFIND'' ROUTINE'
FIND     BAL   R14,SAVE                 GO SAVE REGISTERS
         L     R1,JSYSLIB               POINT TO DCB
         USING IHADCB,R1                ''
         TM    DCBOFLGS,BIT3            WAS OPEN SUCCESSFUL
         BNZ   OPENSUC                  BR IF OPEN NOT SUCCESSFUL
         L     R2,JINOPEN               OPEN LIST
         TM    D0(R2),BIT0              DD CARD FOUND
         BZ    RETURN                   YES
         SET   JMISLIB,ON               SYSLIB DD CARD MISSING
         SR    R2,R2                    SET NOT FOUND
         B     RETURN                   RETURN
         DROP  R1
OPENSUC  MVC   JDWORD,D0(R10)           CONVERT MEMBER NAME
         TR    JDWORD,JTRTABLE          ''
         AIF   (&MACREF).MACREF1                                  .PRC.
         FIND  (1),JDWORD,D             FIND MEMBER
         AGO   .MACREF2                                           .PRC.
.MACREF1 ANOP                                                     .PRC.
*        FIND  (1),JDWORD,D             FIND MEMBER (REPLACED)    .PRC.
         COPY  MACREFFI                 INSERT BLDL CODE          .PRC.
.MACREF2 ANOP                                                     .PRC.
         SH    R15,=H'4'                CHECK RETURN CODE
         BZ    RETURN                   RC=4.  MEMBER NOT FOUND.  CC=0
         BP    ABORTFND                 RC=3  I/O ERROR.
         AIF   (NOT &MACREF).MACREF3                              .PRC.
         L     R1,JSYSLIB               POINT TO DCB              .PRC.
         FIND  (1),@BLDLTTR,C           POINT DCB TO TTR          .PRC.
         DROP  R6                       @B                        .PRC.
.MACREF3 ANOP                                                     .PRC.
         MVC   JLIBNDX,=X'7FAF'         FORCE READ
         SET   JREADPT,OFF              RESET FLAG
         LTR   R13,R13                  RC=0.  MEMBER FOUND.  CC=2
         B     RETURN                   RETURN
         SPACE 4
ABORTFND L     R1,JSYSLIB               PT TO DCB
         USING IHADCB,R1                ''
         O     R1,=X'FF000000'          SET FLAG TO INDICATE FIND ABORT
         L     R15,DCBSYNAD             GET ADDRESS OF SYDAD ROUTINE
         DROP  R1                       DROP DCB BASE
         BR    R15                      NOW GO ABORT
         AIF   (NOT &MACREF).MACREF4                              .PRC.
         COPY  MACREFBL                                           .PRC.
IFOX0F00 CSECT                                                    .PRC.
.MACREF4 ANOP                                                     .PRC.
         SPACE 5
         TITLE '&COMPNM&ASMID - INPUT I/O MODULE - ''NOTELB'' AND ''POIX
               NT'' ROUTINES'
         SPACE 2
NOTELB   BAL   R14,SAVE                 GO SAVE REGISTERS
         L     R1,JSYSLIB               POINT TO DCB
         NOTE  (1)                      NOTE LIBRARY POSITION
         ST    R1,JNOTEVAL              SAVE FILE POSITION
         MVC   JNOTEVAL+D6(D2),JLIBNDX  SAVE BUFFER INDEX
         B     RETURN                   RETURN
         SPACE 6
POINTLB  BAL   R14,SAVE                 GO SAVE REGISTERS
         MVC   JFWORD1,D0(R10)          ALIGN TO FULLWORD
         L     R1,JSYSLIB               POINT TO DCB
         POINT (1),JFWORD1              POSITION LIBRARY
         MVC   JLIBNDX,D6(R10)          SET BUFFER INDEX
         SET   JREADPT,ON               INDICATE NEXT READ IS FOR POINT
         B     RETURN                   RETURN
         SPACE 3
         TITLE '&COMPNM&ASMID - INPUT I/O MODULE - OPEN ROUTINE FOR ''SX
               YSIN'' AND ''SYSLIB'' DCB''S'
ININIT   BAL   R14,SAVE                 GO SAVE REGISTERS
         GOIF  JIN2ND,ON=CLOSE          SECOND TIME HERE
         SET   JIN2ND,ON                FIRST TIME. SET FLAG
         SPACE 2
         TM    D0(R11),BIT0             ANY OVERRIDING DDNAMES
         BO    NOPARM                   BR IF END OF PARM LIST
         L     R14,D4(,R11)             PT TO DDNAME LIST
         USING P,R14                    ESTABLISH PARMLIST BASE
         LA    R15,P                    CLEAR END-OF-LIST FLAG
         AH    R15,PLEN                 CALC END OF TABLE (-2)
         SPACE 1
         L     R1,JSYSLIB               PT TO SYSLIB DCB
         LA    R2,PSYSLIB               PT TO SYSLIB DDNAME
         BAL   R9,OVERRIDE              CHECK FOR OVERRIDE
         SPACE 1
         L     R1,JSYSIN                PT TO SYSIN DCB
         LA    R2,PSYSIN                PT TO SYSIN DDNAME
         BAL   R9,OVERRIDE              CHECK FOR OVERRIDE
         DROP  R14                      DROP DSECT BASE
         SPACE 2
         USING IHADCB,R1                BASE FOR DCB
NOPARM   L     R1,JSYSLIB               POINTS TO SYSLIB DCB
         LA    R15,DCBDDNAM             POINTS TO SYSLIB DDNAME
         DROP  R1
DSYSLIB  DEVTYPE (R15),JDWORD           GET DEVICE CHARACTERISTICS
         LTR   R15,R15                  WAS DDNAME FOUND
         BZ    ININIT5                  YES
         L     R15,JINOPEN              POINT TO OPEN LIST
         OI    D0(R15),BIT0             DO NOT OPEN SYSLIB
         L     R15,JINCLOS              POINT TO CLOSE LIST
         OI    D0(R15),BIT0             DO NOT CLOSE SYSLIB
ININIT5  LA    R10,XTIN                 ADDRESS OF SYSIN LIB DCB EXIT
         L     R1,JINOPEN               OPEN INPUT
         OPEN  MF=(E,(1))               ''
         SPACE 2
         USING IHADCB,R1                ESTABLISH ADDRESSABILITY
         L     R1,JSYSLIB               PT TO SYSLIB DCB
         TM    DCBOFLGS,BIT3            WAS OPEN SUCCESSFUL
         BZ    RETURN                   NO.  RETURN
         SPACE 2
         LH    R0,DCBBLKSI              GET BUFFER FOR LIBRARY
         DROP  R1                       DROP DCB BASE
         GETMAIN R,LV=(0)               ACQUIRE CORE
         ST    R1,JLIBBUF               SAVE LIBRARY BUFFER ADDRESS
         AIF   (NOT &MACREF).MACREF5                              .PRC.
         COPY  MACREFGM                 GETMAIN MACREF TABLE      .PRC.
.MACREF5 ANOP                                                     .PRC.
         B     RETURN                   RETURN
         SPACE
         TITLE '&COMPNM&ASMID - INPUT I/O MODULE - CLOSE ROUTINE FOR ''X
               SYSIN'' AND ''SYSLIB'' DCB''S'
CLOSE    L     R1,JSYSLIB               POINT TO DCB
         USING IHADCB,R1                ''
         TM    DCBOFLGS,BIT3            WAS OPEN SUCCESSFUL FOR LIBRARY
         BZ    NOTSUC                   NOT SUCCESSFUL
         LH    R0,DCBBLKSI              GET BUFFER LENGTH
         DROP  R1                       DROP DCB BASE
         L     R1,JLIBBUF               GET LIBRARY BUFFER ADDRESS
         FREEMAIN R,LV=(0),A=(1)        FREE LIBRARY BUFFER
NOTSUC   L     R1,JINCLOS               CLOSE INPUT
         CLOSE MF=(E,(1))               ''
         SPACE 3
         L     R1,JSYSIN                PT TO SYSIN DCB
         USING IHADCB,R1                ''
         TM    DCBBUFCB+D3,BIT7         IS THERE A BUFCB
         BO    NOBUFCB                  BR IF NO BUFCB
         FREEPOOL (1)                   FREE BUFFERS IN BUFCB
         L     R1,JSYSLIB                PT TO SYSLIB DCB     A@AZ47182
         USING IHADCB,R1                 ''                   A@AZ47182
         TM    DCBBUFCB+D3,BIT7          IS THERE A BUFCB     A@AZ47182
         BO    NOBUFCB                   BR IF NO BUFCB       A@AZ47182
         FREEPOOL (1)                   FREE BUFFERS IN BUFCB A@AZ47182
         DROP  R1                       DROP DCB BASE
         SPACE 1
NOBUFCB  XC    JADINCM,JADINCM          ZERO ADDRESS FOR ABORT MODULE
         B     RETURN                   RETURN
         SPACE 2
         TITLE '&COMPNM&ASMID - INPUT I/O MODULE - DCB OVERRIDE AND DCBX
                EXIT ROUTINE FOR ''SYSIN'' AND ''SYSLIB'' DCB''S'
         USING IHADCB,R1                ESTABLISH BASE FOR DCB
OVERRIDE CR    R2,R15                   PAST END OF LIST
         BHR   R9                       YES, RETURN
         CLC   D0(D8,R2),=8X'00'        IS DDNAME ZERO          OY02543
         BZR   R9                       YES, RETURN
         MVC   DCBDDNAM,D0(R2)          OVERRIDE DDNAME
         BR    R9                       RETURN
         DROP  R1                       DROP DCB BASE
         SPACE 3
         USING IHADCB,R1                ESTABLISH ADDR OF DCB
*        DCB EXIT FOR SYSIN & SYSLIB
         USING *,R10                    ESTABLISH BASE ADDRESS
XTIN     LH    R3,DCBLRECL              LOGICAL RECORD LENGTH
         TM    DCBRECFM,BIT0+BIT1       UNDEFINED LRECL        @AX19477
         BO    XTIN05                   BRANC IF YES           @AX19477
         TM    DCBRECFM,BIT0            FIXED RECORD LENGTH
         BNZ   XTIN10                   NO, MAKE RECFM=FB
XTIN05   MVI   DCBRECFM,BIT0+BIT3       FORCE RECFM=FB         @AX19477
XTIN10   LH    R5,DCBBLKSI              IS BLKSIZE SPECIFIED
         LTR   R5,R5
         BZ    XTIN20                   NO, GO SET DEFAULT BLKSIZE
         CR    R3,R5                    BLKSIZE LESS THAN LRECL
         BH    XTIN20                   IF SO SET BLKSIZE=LRECL
         OI    DCBRECFM,BIT3            SET BLOCKED
         LR    R3,R5                    SAVE BLKSIZE
         LH    R2,DCBLRECL              LOGICAL RECORD LENGTH
         SR    R4,R4                    ZERO FOR DIVIDE
         DR    R4,R2                    R4(REMAINDER)=R4R5/R2 LRECL
         SR    R3,R4                    NOW BLKSIZE IS MULT OF LRECL
         B     XTIN30                   STORE BLKSIZE
XTIN20   NI    DCBRECFM,BITFF-BIT3      SET UNBLOCKED
XTIN30   STH   R3,DCBBLKSI              STORE BLKSIZE
         BR    R14
         DROP  R1,R10                   DROP BASES
         SPACE 5
*        PATCH AREA
*
         JPATCH X0F00,302               5% PATCH AREA
         END   START
./       ADD   NAME=INSTALL
//INSTALL  JOB (ACCT),NAME,
//             MSGCLASS=A
//*
//*            THIS JOB INSTALLS THE MACRO REFERENCE FEATURE
//*            TO THE XF ASSEMBLER.
//*
//ASM1    EXEC PGM=IFOX00,PARM='OBJECT,NODECK,XREF(SHORT)',REGION=256K
//SYSPRINT DD  SYSOUT=A
//SYSLIB   DD  DSN=SYS1.MACLIB,DISP=SHR
//         DD  DSN=USERID.IFOLIB,DISP=SHR
//SYSGO    DD  DSN=&&OBJECT1,DISP=(NEW,PASS),
//             UNIT=SYSDA,SPACE=(TRK,(3,1)),
//             DCB=(RECFM=FB,LRECL=80,BLKSIZE=800)
//SYSUT1   DD  UNIT=SYSDA,SPACE=(TRK,(50,10))
//SYSUT2   DD  UNIT=SYSDA,SPACE=(TRK,(50,10))
//SYSUT3   DD  UNIT=SYSDA,SPACE=(TRK,(50,10))
//SYSIN    DD  DSN=USERID.IFOLIB(IFOX0F),DISP=SHR
//ASM2    EXEC PGM=IFOX00,PARM='OBJECT,NODECK,XREF(SHORT)',REGION=256K
//SYSPRINT DD  SYSOUT=A
//SYSLIB   DD  DSN=SYS1.MACLIB,DISP=SHR
//         DD  DSN=USERID.IFOLIB,DISP=SHR
//SYSGO    DD  DSN=&&OBJECT2,DISP=(NEW,PASS),
//             UNIT=SYSDA,SPACE=(TRK,(3,1)),
//             DCB=(RECFM=FB,LRECL=80,BLKSIZE=800)
//SYSUT1   DD  UNIT=SYSDA,SPACE=(TRK,(50,10))
//SYSUT2   DD  UNIT=SYSDA,SPACE=(TRK,(50,10))
//SYSUT3   DD  UNIT=SYSDA,SPACE=(TRK,(50,10))
//SYSIN    DD  DSN=USERID.IFOLIB(IFNX4E),DISP=SHR
//LKED    EXEC PGM=IEWL,PARM='LIST,MAP,NCAL',REGION=256K,
//             COND=((0,NE,ASM1),(0,NE,ASM2))
//*            THIS STEP CREATES 4 NEW MODULES.
//*            1) AFOX00, A COPY OF IFOX00
//*            2) IFOXX4, A NEW VERSION OF IFOX04
//*            2) IFOX4A, A NEW VERSION OF IFOX41
//*            2) IFOX4B, A NEW VERSION OF IFOX42
//SYSPRINT DD  SYSOUT=A
//SYSUT1   DD  UNIT=SYSDA,SPACE=(TRK,(10,10))
//SYSLMOD  DD  DSN=USERID.LOAD,DISP=SHR
//LINKLIB  DD  DSN=SYS1.LINKLIB,DISP=SHR
//OBJECT1  DD  DSN=&&OBJECT1,DISP=(OLD,DELETE)
//OBJECT2  DD  DSN=&&OBJECT2,DISP=(OLD,DELETE)
//SYSLIN   DD  DSN=USERID.IFOLIB(LINKIN),DISP=SHR
//ZAP     EXEC PGM=AMASPZAP,REGION=256K,
//             COND=((0,NE,ASM1),(0,NE,ASM2))
//*            THIS STEP MODIFIES AFOX00
//*            SO IT WILL CALL THE OTHER 3 NEW MODULES.
//SYSPRINT DD  SYSOUT=A
//SYSLIB   DD  DSN=USERID.LOAD,DISP=SHR
//SYSIN    DD  DSN=USERID.IFOLIB(ZAPIN),DISP=SHR
//
./       ADD   NAME=INSTALO
//INSTALO  JOB (ACCT),NAME,
//             MSGCLASS=A
//*
//*            THIS JOB INSTALLS THE MACRO REFERENCE FEATURE
//*            TO THE XF ASSEMBLER (USING OBJECT DECKS ONLY).
//*
//ASM1    EXEC PGM=IEBGENER,REGION=128K
//SYSPRINT DD  SYSOUT=A
//SYSUT1   DD  DSN=USERID.IFOLIB(OFOX0F),DISP=SHR
//SYSUT2   DD  DSN=&&OBJECT1,DISP=(NEW,PASS),
//             UNIT=SYSDA,SPACE=(TRK,(3,1)),
//             DCB=(RECFM=FB,LRECL=80,BLKSIZE=800)
//SYSIN    DD  DUMMY
//ASM2    EXEC PGM=IEBGENER,REGION=128K
//SYSPRINT DD  SYSOUT=A
//SYSUT1   DD  DSN=USERID.IFOLIB(OFNX4E),DISP=SHR
//SYSUT2   DD  DSN=&&OBJECT2,DISP=(NEW,PASS),
//             UNIT=SYSDA,SPACE=(TRK,(3,1)),
//             DCB=(RECFM=FB,LRECL=80,BLKSIZE=800)
//SYSIN    DD  DUMMY
//LKED    EXEC PGM=IEWL,PARM='LIST,MAP,NCAL',REGION=256K,
//             COND=((0,NE,ASM1),(0,NE,ASM2))
//*            THIS STEP CREATES 4 NEW MODULES.
//*            1) AFOX00, A COPY OF IFOX00
//*            2) IFOXX4, A NEW VERSION OF IFOX04
//*            2) IFOX4A, A NEW VERSION OF IFOX41
//*            2) IFOX4B, A NEW VERSION OF IFOX42
//SYSPRINT DD  SYSOUT=A
//SYSUT1   DD  UNIT=SYSDA,SPACE=(TRK,(10,10))
//SYSLMOD  DD  DSN=USERID.LOAD,DISP=SHR
//LINKLIB  DD  DSN=SYS1.LINKLIB,DISP=SHR
//OBJECT1  DD  DSN=&&OBJECT1,DISP=(OLD,DELETE)
//OBJECT2  DD  DSN=&&OBJECT2,DISP=(OLD,DELETE)
//SYSLIN   DD  DSN=USERID.IFOLIB(LINKIN),DISP=SHR
//ZAP     EXEC PGM=AMASPZAP,REGION=256K,
//             COND=((0,NE,ASM1),(0,NE,ASM2))
//*            THIS STEP MODIFIES AFOX00
//*            SO IT WILL CALL THE OTHER 3 NEW MODULES.
//SYSPRINT DD  SYSOUT=A
//SYSLIB   DD  DSN=USERID.LOAD,DISP=SHR
//SYSIN    DD  DSN=USERID.IFOLIB(ZAPIN),DISP=SHR
//
./       ADD   NAME=INSTALZ
//ASFI05K  JOB (ASFI,FI110,15U),'GODFREY-REMOTE',CLASS=P,
//             MSGCLASS=A,NOTIFY=ASFI05
//*
//*            THIS JOB INSTALLS THE MACRO REFERENCE FEATURE
//*            TO THE XF ASSEMBLER.
//*
//ASM1    EXEC PGM=IFOX00,PARM='OBJECT,NODECK,XREF(SHORT)',REGION=256K
//SYSPRINT DD  SYSOUT=A
//SYSLIB   DD  DSN=SYS1.MACLIB,DISP=SHR
//         DD  DSN=ASFI05U.FI300.IFOLIB,DISP=SHR
//SYSGO    DD  DSN=&&OBJECT1,DISP=(NEW,PASS),
//             UNIT=SYSDA,SPACE=(TRK,(3,1)),
//             DCB=(RECFM=FB,LRECL=80,BLKSIZE=800)
//SYSUT1   DD  UNIT=SYSDA,SPACE=(TRK,(50,10))
//SYSUT2   DD  UNIT=SYSDA,SPACE=(TRK,(50,10))
//SYSUT3   DD  UNIT=SYSDA,SPACE=(TRK,(50,10))
//SYSIN    DD  DSN=ASFI05U.FI300.IFOLIB(IFOX0F),DISP=SHR
//ASM2    EXEC PGM=IFOX00,PARM='OBJECT,NODECK,XREF(SHORT)',REGION=256K
//SYSPRINT DD  SYSOUT=A
//SYSLIB   DD  DSN=SYS1.MACLIB,DISP=SHR
//         DD  DSN=ASFI05U.FI300.IFOLIB,DISP=SHR
//SYSGO    DD  DSN=&&OBJECT2,DISP=(NEW,PASS),
//             UNIT=SYSDA,SPACE=(TRK,(3,1)),
//             DCB=(RECFM=FB,LRECL=80,BLKSIZE=800)
//SYSUT1   DD  UNIT=SYSDA,SPACE=(TRK,(50,10))
//SYSUT2   DD  UNIT=SYSDA,SPACE=(TRK,(50,10))
//SYSUT3   DD  UNIT=SYSDA,SPACE=(TRK,(50,10))
//SYSIN    DD  DSN=ASFI05U.FI300.IFOLIB(IFNX4E),DISP=SHR
//LKED    EXEC PGM=IEWL,PARM='LIST,MAP,NCAL',REGION=256K,
//             COND=((0,NE,ASM1),(0,NE,ASM2))
//*            THIS STEP CREATES 4 NEW MODULES.
//*            1) AFOX00, A COPY OF IFOX00
//*            2) IFOXX4, A NEW VERSION OF IFOX04
//*            2) IFOX4A, A NEW VERSION OF IFOX41
//*            2) IFOX4B, A NEW VERSION OF IFOX42
//SYSPRINT DD  SYSOUT=A
//SYSUT1   DD  UNIT=SYSDA,SPACE=(TRK,(10,10))
//SYSLMOD  DD  DSN=ASFI05U.FI300.LOAD,DISP=SHR
//LINKLIB  DD  DSN=SYS1.LINKLIB,DISP=SHR
//OBJECT1  DD  DSN=&&OBJECT1,DISP=(OLD,DELETE)
//OBJECT2  DD  DSN=&&OBJECT2,DISP=(OLD,DELETE)
//SYSLIN   DD  DSN=ASFI05U.FI300.IFOLIB(LINKIN),DISP=SHR
//ZAP     EXEC PGM=AMASPZAP,REGION=256K,
//             COND=((0,NE,ASM1),(0,NE,ASM2))
//*            THIS STEP MODIFIES AFOX00
//*            SO IT WILL CALL THE OTHER 3 NEW MODULES.
//SYSPRINT DD  SYSOUT=A
//SYSLIB   DD  DSN=ASFI05U.FI300.LOAD,DISP=SHR
//SYSIN    DD  DSN=ASFI05U.FI300.IFOLIB(ZAPIN),DISP=SHR
//
./       ADD   NAME=JCHECK
         MACRO
&NAME    JCHECK &FILE=
.*
.*       GENERATES A CALL TO WORKFILE I/O MODULE CHECK ROUTINE
.*       TO ISSUE A CHECK FOR A STARTED I/O OPERATION.
.*
         AIF   (K'&FILE EQ 0).ERR1
&NAME    JINST LA,R10,&FILE,FILE
         L     R12,JMLC                 LOAD BASE
         BAL   R9,JCHECK(,R12)          GO TO JCHECK
         MEXIT
.ERR1    MNOTE 8,'PARAMETER ERROR.'
         MEND
./       ADD   NAME=JCOMMON
J        DSECT
*A678000                                                       @AX14816
*C678500                                                       @AX14816
*A564600,831500-833800,924500-930500,831100                    @AZ13738
*C565000                                                       @AZ13738
*
*        ASSEMBLER COMMON TABLE AS OF 12/08/70.
*
*        REGISTER EQUATES
*
R0       EQU   0                        SCRATCH REGISTER
R1       EQU   1                        SCRATCH REGISTER
R2       EQU   2                        WORK REGISTER
R3       EQU   3                        WORK REGISTER
R4       EQU   4                        WORK REGISTER
R5       EQU   5                        WORK REGISTER
R6       EQU   6                        WORK REGISTER
R7       EQU   7                        MODULE COMMON REGISTER
R8       EQU   8                        BASE REGISTER
R9       EQU   9                        RETURN ADDRESS REGISTER
R10      EQU   10                       PARAMETER REGISTER (2-WAY)
R11      EQU   11                       PARAMETER REGISTER (2-WAY)
R12      EQU   12                       SUBROUTINE CALL REGISTER
R13      EQU   13                       COMMON REGISTER
R14      EQU   14                       SCRATCH
R15      EQU   15                       SCRATCH
*
*        DISPLACEMENT EQUATES
*
D0       EQU   0
D1       EQU   1
D2       EQU   2
D3       EQU   3
D4       EQU   4
D5       EQU   5
D6       EQU   6
D7       EQU   7
D8       EQU   8
D9       EQU   9
D10      EQU   10
D11      EQU   11
D12      EQU   12
D13      EQU   13
D14      EQU   14
D15      EQU   15
D16      EQU   16
D17      EQU   17
D18      EQU   18
D19      EQU   19
D20      EQU   20
D21      EQU   21
D22      EQU   22
D23      EQU   23
D24      EQU   24
D25      EQU   25
D26      EQU   26
D27      EQU   27
D28      EQU   28
D29      EQU   29
D30      EQU   30
D31      EQU   31
D32      EQU   32
*
*        BIT EQUATES
*        BIT MASKS FOR BITS 0 - 7 DEFINED BY MACRO IEZBITS
*
         IEZBITS
BITFF    EQU   B'11111111'                                   ALL
*
*        INTERNAL CODES---PRECEDED BY J
*
J0       EQU   X'00'                    NUMBER 0
J1       EQU   X'01'                           1
J2       EQU   X'02'                           2
J3       EQU   X'03'                           3
J4       EQU   X'04'                           4
J5       EQU   X'05'                           5
J6       EQU   X'06'                           6
J7       EQU   X'07'                           7
J8       EQU   X'08'                           8
J9       EQU   X'09'                           9
JA       EQU   X'0A'                    LETTER A
JB       EQU   X'0B'                           B
JC       EQU   X'0C'                           C
JD       EQU   X'0D'                           D
JE       EQU   X'0E'                           E
JF       EQU   X'0F'                           F
JG       EQU   X'10'                           G
JH       EQU   X'11'                           H
JI       EQU   X'12'                           I
JJ       EQU   X'13'                           J
JK       EQU   X'14'                           K
JL       EQU   X'15'                           L
JM       EQU   X'16'                           M
JN       EQU   X'17'                           N
JO       EQU   X'18'                           O
JP       EQU   X'19'                           P
JQ       EQU   X'1A'                           Q
JR       EQU   X'1B'                           R
JS       EQU   X'1C'                           S
JT       EQU   X'1D'                           T
JU       EQU   X'1E'                           U
JV       EQU   X'1F'                           V
JW       EQU   X'20'                           W
JX       EQU   X'21'                           X
JY       EQU   X'22'                           Y
JZ       EQU   X'23'                           Z
JDOLLAR  EQU   X'24'                           $
JPOUND   EQU   X'25'                           POUND SIGN
JAT      EQU   X'26'                           AT SIGN
JEQUAL   EQU   X'27'                    SPEC.  =
JLPARN   EQU   X'28'                           (
JPLUS    EQU   X'29'                           +
JMINUS   EQU   X'2A'                           -
JASTER   EQU   X'2B'                           *
JSLASH   EQU   X'2C'                           /
JRPARN   EQU   X'2D'                           )
JCOMMA   EQU   X'2E'                           ,
JBLANK   EQU   X'2F'                           BLANK
JQUOTE   EQU   X'30'                           '
JAMPER   EQU   X'31'                           &
JPERIOD  EQU   X'32'                           .
JNUMMIN  EQU   J0                       MINIMUM NUMBER CODE
JNUMMAX  EQU   J9                       MAXIMUM NUMBER CODE
JALFAMIN EQU   JA                       MINIMUM ALPHA CODE
JALFAMAX EQU   JAT                      MAXIMUM ALPHA CODE
JOPERMIN EQU   JPLUS                    MINIMUM OPERATOR CODE
JOPERMAX EQU   JSLASH                   MAXIMUM OPERATOR CODE
*
*        COMMON STORAGE
*
         USING JCOMMON,R13              SET UP COMMON BASE
JCOMMON  DS    0D                       BEGINNING OF COMMON
JSAVE    DS    18F                      SYSTEM SAVE AREA
JFLEBLK1 DS    14A                      FILE BLOCK 1
FILE1    EQU   JFLEBLK1-JCOMMON         FILE 1 CODE
JFLEBLK2 DS    14A                      FILE BLOCK 2
FILE2    EQU   JFLEBLK2-JCOMMON         FILE 2 CODE
JFLEBLK3 DS    14A                      FILE BLOCK 3
FILE3    EQU   JFLEBLK3-JCOMMON         FILE 3 CODE
JMAXRL1  DS    H                        MAX RL FOR FILE 1
JMAXRL2  DS    H                        MAX RL FOR FILE 2
JMAXRL3  DS    H                        MAX RL FOR FILE 3
JMAXRL   DS    H                        MIN OF MAX RL FOR ALL FILES
JADINCM  DS    A                        ADDRESS OF INPUT COMMON
JADOUTCM DS    A                        ADDRESS OF OUTPUT COMMON
JPHNAME  DS    0CL8                     PHASE NAME OF LAST PHASE LOADED
JPHPREF  DS    CL3                      PHASE NAME PREFIX
JPHSUFF  DS    CL3                      PHASE NAME SUFFIX
JPHBLANK DS    CL2                      TWO BLANKS
JLVTMDT  DS    0CL24                    ASM LEVEL, TIME, DATE
         DS    CL10                     SAME
JSYSTIME DS    CL5                             HH.MM
         DS    C                        BLANK
JSYSDATE DS    CL8                             MM/DD/YY OR DD/MM/YY
JDECKIDL DS    X                        LENGTH OF DECK ID (0 THRU 8)
JDECKID  DS    CL8                      INTERNAL DECK ID
JPARMS   DS    0XL3                     MSGLEVEL AND LINECOUNT
JMSGL    DS    X                        MSGLEVEL=
JLNCT    DS    H                        LINECNT=
JSYSPARM DS    A                        SYSPARM POINTER
JPARMPTR DS    A                        ADDR OF TRANS PARM (IF PRESENT)
JPARM    DS    0A                       OPTION PARMS (PARM 1,2,3,4)
*                                       PARAMETER (OPTION BYTE 1)
JPARM1   DSW   JLIST,                          PRINT LISTING           X
               JXREF,                          PRINT XREF              X
               JESD,                           PRINT ESD'S             X
               JRLD,                           PRINT RLD'S             X
               JDECK,                          PUNCH DECK              X
               JLINK,                          WRITE OBJECT MODULE     X
               JTEST                           PUNCH SYMBOL TABLE
*                                       PARAMETER (OPTION BYTE 2)
JPARM2   DSW   JRENT,                          RE-ENTRANT CHECKING     X
               JALGN,                          ALIGNMENT CHECKING      X
               JSYSMAC,                        PRINT SYSTEM MACROS     X
               JALOGIC,                        PRINT ASSEMBLER LOGIC   X
               JMLOGIC,                        PRINT MACRO LOGIC       X
               JCALLS                          PRINT INNER MACRO CALLS
*                                       PARAMETER (OPTION BYTE 3)
JPARM3   DSW   JTERM,                          PRINT TO TERMINAL       X
               JSTMT,                          PRINT STMT NO. ON TERM  X
               JNUM,                           PRINT SEQ NO. ON TERM   X
               JMINXREF,                       SHORT XREF              X
               JMINBUF,,                       MINIMUM BUFFERS OR      X
               JLNCTKEY,                       FIXED LINECNT           X
               JMSGLKEY                        FIXED MSGLEVEL
*                                       PARAMETER (OPTION BYTE 4)
JPARM4    DSW   JYFLAG,                 ERR MSG IFO205 IF ON   @OX09734X
               JMBUF,                   MULTIBUFFERS REQ IF ON @AZ13738X
               ,,,,JMCHECK              FLAG FOR MLC           @AZ13738
JPREFIX  DS    CL3                      COMPONENT NAME
*                                       WARNING FLAGS
JWARNFLG DSW   JYCON,                          RELOCATABLE YCON        X
               JREENTR                         REENTRANT CHK FAILED
*                                       POST PROCESSOR FLAGS
JRECCHK  DSW   JRLDCHK,                        RLD RECORDS PRESENT     X
               JXREFCHK,                       XREF RECORDS PRESENT    X
               JERRCHK,                        ERROR RECORDS PRESENT   X
               JESDCHK,                        ESDID PRESENT ON END    X
               JENDCHK                         PUNCH END CARD
*                                       ERROR FLAGS TO POST PROCESSOR
JINDERRF DSW   JMISLIN,                        MISSING SYSLIN DD CARD  X
               JMISPCH,                        MISSING SYSPUNCH DD CARDX
               JINVOPT,                        INVALID OPTION          X
               JESDOFLO,                       ESD OVERFLOW            X
               JMISPRT,                        MISSING SYSPRINT DD CARDX
               JMISTERM,                       MISSING SYSTERM DD CARD X
               JMISLIB                         SYSLIB DD CARD MISSING
*                                       PDUMP FLAGS
JPDFLAG  DSW   JDUMPX0,                        DUMP PHASE X0           X
               JDUMPX1,                        DUMP PHASE X1           X
               JDUMPX2,                        DUMP PHASE X2           X
               JDUMPX3,                        DUMP PHASE X3           X
               JDUMPX4,                        DUMP PHASE X4           X
               JDUMPX5,                        DUMP PHASE X5           X
               JDUMPX6                         DUMP PHASE X6
*                                       COMMUNICATION FLAGS FOR JINMLC
JINFLAG  DSW   JIN2ND,                         ENTERED JININIT ONCE    X
               JINLIB                          INPUT FROM LIBRARY
*                                       COMMUN. FLAGS FOR PRT/PCH
JOUTFLAG DSW   JOUT2ND,                        ENTERED JOUTINIT ONCE   X
               JNOSEQPH,                       DON'T SEQ PUNCH @AX14816X
               JSUPPRT                         SUPR PRNT 1 LINE@AX14816
*                                       COMMUNICATION FLAGS FOR MLC
JMLCFLAG DSW   JPT4STAR,                       POINT TO START OF FILE  X
               JPT4READ,                       READ TO FOLLOW POINT    X
               JPT4WRIT,                       WRITE TO FOLLOW POINT   X
               JPT4GET,                        GET TO FOLLOW POINT     X
               JDBLALL                         FILES CAN BE DBLBUF
JMLC     DS    A                        ADDRESS OF MAIN LINE CONTROL
JPUTL    EQU   0                        DISPLACEMENT FOR JPUTL
JPUTM    EQU   4                                         JPUTM
JGETL    EQU   8                                         JGETL
JTRUNC   EQU   12                                        JTRUNC
JRELSE   EQU   16                                        JRELSE
JREAD    EQU   20                                        JREAD
JWRITE   EQU   24                                        JWRITE
JCHECK   EQU   28                                        JCHECK
JGETCORE EQU   32                                        JGETCORE
JFRECORE EQU   36                                        JFRECORE
JNOTE    EQU   40                                        JNOTE
JPOINT   EQU   44                                        JPOINT
JINMLC   DS    A                        ADDR OF INPUT MAIN LINE CONTROL
JINPUT   EQU   0                        DISPLACEMENT FOR JINPUT
JFIND    EQU   4                                         JFIND
JNOTELB  EQU   8                                         JNOTELB
JPOINTLB EQU   12                                        JPOINTLB
JININIT  EQU   16                                        JININIT
JOUTMLC  DS    A                        ADDR OF OUTPUT MAIN LINE CONTRL
JPRINT   EQU   0                        DISPLACEMENT FOR JPRINT
JPUNCH   EQU   4                                         JPUNCH
JOUTINIT EQU   8                                         JOUTINIT
JPDUMP   DS    A                        ADDRESS OF PDUMP ROUTINE
JNOTEVAL DS    CL8                      VALUE FROM JNOTE
JRECIN   DS    F                        NUMBER OF RECORDS FROM SYSIN
JRECLIB  DS    F                        NUMBER OF RECORDS FROM LIBRARY
JRECPCH  DS    F                        NUMBER OF CARDS PUNCHED
JRECPRT  DS    F                        NUMBER OF LINES PRINTED
JSLEN    DS    A                        LENGTH OF AREA (JEOS-JBOS)
JBOS     DS    A                        BEGINNING OF AVAILABLE CORE
JEOS     DS    A                        NEXT AVAILABLE GETCORE AREA
JSAVELVL EQU   10                       NUMBER OF SAVE LEVELS
JSAVESZ  EQU   4*(R9-R2+1)              SIZE OF ONE SAVE AREA IN BYTES
JCLVLPTR DS    A                        CURRENT SAVE LEVEL PTR
         DS    A                        SIZE OF ONE SAVE AREA
JSAVETBL DS    (JSAVESZ*JSAVELVL/4)A    PUSH/POP SAVE AREA
JABORT   DS    A                        ABORT ROUTINE LINKAGE
JAABORT  DS    A                        ADDR OF ABORT ROUTINE
JSYSOPEN DS    A                        WORKFILE OPEN
JSYSCLOS DS    A                        WORKFILE CLOSE
CORESIZE DS    F                        REQUESTED WORKAREA     @AZ13738
OLDBUF   DS    F                        PTR TO MBUF LAST USED  @AZ13738
CURRBUF  DS    F                        PTR TO MBUF IN USE     @AZ13738
BUFSTART DS    F                        PTR TO START OF BUFTABL@AZ13738
LOWPRIOR DS    F                        PTR TO LAST ENTRY      @AZ13738
HIMASK   DS    H                        HIGEST PRIORITY VALUE  @AZ13738
LOMASK   DS    H                        LOWEST PRIORITY VALUE  @AZ13738
CURRMASK DS    H                        SAVEAREA FOR PRIORITY  @AZ13738
NRMBUF   DS    H                        NUMBER OF MBUFFERS     @AZ13738
JCONTCL  DS    H                        CONTINUE COLUMN
JENDCOL  DS    H                        END COLUMN
ENTRPUTL DS    A                        ENTRY POINT OF PUTLINE
JDWORD   DS    D                        DOUBLE WORD OF TEMP STORAGE
JFWORD1  DS    F                        TWO FULL WORDS
JFWORD2  DS    F                               OF TEMP STORAGE
JHWORD1  DS    H                        TWO HALF WORDS
JHWORD2  DS    H                               OF TEMP STORAGE
JSRCLN   DS    F                        DATA PORTION MOVE LENGTH  (1-7)
JBEGCL   DS    F                        BEGIN COLUMN MINUS 1      (2-7)
JCTCHR   DS    F                        CONT CHR COLUMN MINUS 1   (3-7)
JSEQCL   DS    F                        SEQ FLD BEGIN COL MINUS 1 (4-7)
JSEQLN   DS    F                        SEQ FLD MOVE LENGTH       (5-7)
JCTBGN   DS    F                        CONT COLUMN MINUS 1       (6-7)
JCTLN    DS    F                        CONT FLD MOVE LENGTH      (7-7)
JINFILE  DS    H                        INPUT FILE NO. FOR X4,X5,X6
JOUTFILE DS    H                        OUTPUT FILE NO. FOR X4,X5,X6
JENTRYPT DS    A                        ENTRY POINT ADDR FOR END CARD
JESDID   DS    H                        ESDID FOR OBJECT END CARD
JPAGENO  DS    H                        PAGE NUMBER FOR LISTING
JDPASS   DS    CL56                     COMMUN. BETWEEN X2A AND X3N
JSEVER   DS    X                        HIGHEST SEVERITY FOR X5, X6
JPRTONLY DS    X                        CATASTROPHIC ERROR IN X4
         DSW   JSYSGEN                  OFF INDICATES SYSGEN MODE
         DS    X                        (NOT USED)
JLITLNG  DS    H                        MAXIMUM LITERAL LENGTH
JTBLTRT  DS    CL51                     TRANSLATE AND TEST TABLE
JTRTABLE DS    CL256                    SELF MAPPING TRANSLATE TABLE
JSAFE    DS    18F                      SAVE AREA FOR PDUMPS
JIDR     DS    CL39                     IDR
JCOMEND  DS    0D                       END OF COMMON
* THIS DSECT DESCRIBE BUFFERENTRYS IN MULTIBUFFER MODE         @AZ13738
BUFENTRY DSECT                                                 @AZ13738
FWBUFPTR EQU   *-BUFENTRY               PTS TO NEXT ENTRY      @AZ13738
         DS    F                        PTS TO NEXT ENTRY      @AZ13738
FWCHAIN  EQU   *-BUFENTRY               PTS TO NEXT SEQ BUFF   @AZ13738
         DS    F                        PTS TO NEXT SEQ BUFF   @AZ13738
BWCHAIN  EQU   *-BUFENTRY               PTS TO PREV. SEQ BUFF  @AZ13738
         DS    F                        PTS TO PREV. SEQ BUFF  @AZ13738
BUFTTR   EQU   *-BUFENTRY               BUFFER TTR VALUE       @AZ13738
BUFNOTE  EQU   *-BUFENTRY               TTR VALUE WITH BUF DISP@AZ13738
         DS    F                        BUFFER TTR VALUE       @AZ13738
BUFDISPL EQU   *-BUFENTRY               DISPL OF REC INTO BUFF @AZ13738
         DS    H                        DISPL OF REC INTO BUFF @AZ13738
PRIOR    EQU   *-BUFENTRY               PRIORITY VALUE         @AZ13738
         DS    H                        PRIORITY VALUE         @AZ13738
BUFADR   EQU   *-BUFENTRY               PTR TO BUFFER          @AZ13738
         DS    F                        PTR TO BUFFER          @AZ13738
BUFFEND  EQU   *                        END OF ENTRY           @AZ13738
BUFFENLN EQU   BUFFEND-BUFENTRY         LENGTH OF ENTRY        @AZ13738
./       ADD   NAME=JCSECT
         MACRO
         JCSECT &PARM
         GBLC  &COMPNM,&ASMID
         LCLC  &X,&Y
.*
.*       THIS MACRO GENERATES A CSECT STATEMENT WITH A CSECT NAME
.*       COMPOSED FROM THE MACRO INSTRUCTION OPERANDS
.*       AND AN EQU TO THIS NAME IF WANTED.
         AIF   (K'&PARM LT 7).ERR1
         AIF   ('&PARM'(1,1) NE '(').ERR1
         AIF   ('&PARM'(K'&PARM,1) NE ')').ERR1
         AIF   (K'&PARM EQ 7).NXA
         AIF   ('&PARM'(7,1) NE '=').ERR1
.NXA     AIF   ('&PARM'(2,3) NE '&ASMID').ERR1
.*
&X       SETC  '&PARM'(2,5)
&COMPNM&X CSECT
.*
         AIF   (K'&PARM EQ 7).NXB
&Y       SETC  '&PARM'(8,K'&PARM-8)
&Y       EQU   &COMPNM&X
.NXB     MEXIT
.*
.ERR1    MNOTE 8,'PARAMETER ERROR.'
         MEND
./       ADD   NAME=JENTRY
         MACRO
         JENTRY &PARM
         GBLC  &COMPNM,&ASMID
         LCLC  &X,&Y
.*
.*       DEFINES AN ENTRY POINT BY GENERATING AN ENTRY STATEMENT
.*       AND IF WANTED, AN EQU TO IT WITH THE SPECIFIED SYMBOL.
.*       THE ENTRY POINT NAME MUST FOLLOW XF NAMING CONVENTIONS.
.*
         AIF   (K'&PARM LT 9).ERR1
         AIF   ('&PARM'(1,1) NE '(').ERR1
         AIF   ('&PARM'(K'&PARM,1) NE ')').ERR1
         AIF   ('&PARM'(7,1) NE '=').ERR1
         AIF   ('&PARM'(2,3) NE '&ASMID').ERR1
.*
&X       SETC  '&PARM'(2,5)
&Y       SETC  '&PARM'(8,K'&PARM-8)
.*
         ENTRY &COMPNM&X
&COMPNM&X EQU  &Y
         MEXIT
.*
.ERR1    MNOTE 8,'PARAMETER ERROR.'
         MEND
./       ADD   NAME=JGENIN
         MACRO
&LABEL   JGENIN &LIST,&LENGTH
         LCLA  &K,&C,&CT,&LEN
         LCLB  &SW,&SW1
         LCLC  &LET,&GEN(8)
.* GENERATES INTERNALLY CODED TEXT.
.* ACCEPTS ALPHA, NUMBERIC, AND ALL SPECIAL CHARACTERS EXCEPT
.* AMPERSAND AND QUOTE.
&K       SETA  K'&LIST
&C       SETA  1
         AIF   ('&LIST'(1,1) NE '''').M1
&C       SETA  2
&SW      SETB  1
.M1      AIF   ('&LENGTH' NE '').M2
&SW1     SETB  1
&LEN     SETA  0
.*  SW =0 - NO QUOTE
.*  SW =1 - QUOTE
.*  SW1=0 - LENGTH
.*  SW1=1 - NO LENGTH
.M2      AIF   (&SW).M3                 BRANCH QUOTE
         AIF   (&SW1).M5                BRANCH NO QUOTE, NO LENGTH
.*   NO QUOTE  LENGTH
         AIF   (&LENGTH GT &K).M2A
&K       SETA  &LENGTH
&LEN     SETA  0
         AGO   .M5
.M2A     ANOP
&LEN     SETA  &LENGTH-&K
         AGO   .M5
.*   QUOTE
.M3      AIF   (&SW1).M4                BRANCH QUOTE NO LENGTH
.*   QUOTE LENGTH
&K       SETA  &K-2
         AIF   (&LENGTH GT &K).M3A
&K       SETA  &LENGTH+1
&LEN     SETA  0
         AGO   .M5
.M3A     ANOP
&LEN     SETA  &LENGTH-&K
&K       SETA  &K+1
         AGO   .M5
.*   QUOTE  NO LENGTH
.M4      ANOP
&K       SETA  &K-1
.M5      AIF   ('&LABEL' EQ '').L2
&LABEL   DC    0CL(&K-&C+1+&LEN)' '
.L2      ANOP
&CT      SETA  1
.L3      AIF   ('&LIST'(&C,1) EQ '$').L3DOLR      DOLLAR
         AIF   ('&LIST'(&C,1) EQ '#').L3POUND     POUND
         AIF   ('&LIST'(&C,1) EQ '@').L3AT        AT
         AIF   ('&LIST'(&C,1) EQ '=').L3EQ        EQUAL
         AIF   ('&LIST'(&C,1) EQ '(').L3LP        LEFT PARN.
         AIF   ('&LIST'(&C,1) EQ '+').L3PLUS      PLUS
         AIF   ('&LIST'(&C,1) EQ '-').L3MIN       MINUS
         AIF   ('&LIST'(&C,1) EQ '*').L3AST       ASTER
         AIF   ('&LIST'(&C,1) EQ '/').L3SLASH     SLASH
         AIF   ('&LIST'(&C,1) EQ ')').L3RP        RIGHT PARN.
         AIF   ('&LIST'(&C,1) EQ ',').L3C         COMMA
         AIF   ('&LIST'(&C,1) EQ ' ').L3B         BLANK
         AIF   ('&LIST'(&C,1) EQ '.').L3P         PERIOD
&LET     SETC  'J'.'&LIST'(&C,1)
.L6      AIF   (&CT EQ 1).L7
&LET     SETC  ','.'&LET'
.L7      ANOP
&GEN(&CT) SETC '&LET'
&C       SETA  &C+1
         AIF   (&C GT &K).L9
&CT      SETA  &CT+1
         AIF   (&CT LT 9).L3
         DC    AL1(&GEN(1)&GEN(2)&GEN(3)&GEN(4)&GEN(5)&GEN(6)&GEN(7)&GEX
               N(8))
&CT      SETA  1
.L8      ANOP
&GEN(&CT) SETC ''
&CT      SETA  &CT+1
         AIF   (&CT LT 9).L8
         AGO   .L2
.L3DOLR  ANOP
&LET     SETC  'JDOLLAR'
         AGO   .L6
.L3POUND ANOP
&LET     SETC  'JPOUND'
         AGO   .L6
.L3AT    ANOP
&LET     SETC  'JAT'
         AGO   .L6
.L3EQ    ANOP
&LET     SETC  'JEQUAL'
         AGO   .L6
.L3LP    ANOP
&LET     SETC  'JLPARN'
         AGO   .L6
.L3PLUS  ANOP
&LET     SETC  'JPLUS'
         AGO   .L6
.L3MIN   ANOP
&LET     SETC  'JMINUS'
         AGO   .L6
.L3AST   ANOP
&LET     SETC  'JASTER'
         AGO   .L6
.L3SLASH ANOP
&LET     SETC  'JSLASH'
         AGO   .L6
.L3RP    ANOP
&LET     SETC  'JRPARN'
         AGO   .L6
.L3C     ANOP
&LET     SETC  'JCOMMA'
         AGO   .L6
.L3B     ANOP
&LET     SETC  'JBLANK'
         AGO   .L6
.L3P     ANOP
&LET     SETC  'JPERIOD'
         AGO   .L6
.L9      DC    AL1(&GEN(1)&GEN(2)&GEN(3)&GEN(4)&GEN(5)&GEN(6)&GEN(7)&GEX
               N(8))
         AIF   (&LEN EQ 0).L10
         DC    &LEN.AL1(JBLANK)
.L10     MEND
./       ADD   NAME=JHEAD
         MACRO
         JHEAD &TITLE,&PHASEID=,&LEVEL=
         GBLA  &ASMLEV
         GBLC  &COMPNM,&ASMID
         LCLA  &I,&J
         LCLC  &X(10)
.*
.*       GENERATES A TITLE STATEMENT AND A STATUS MNOTE
.*       IN THE PROLOUGE TO AN MODULE.
         AIF   (K'&TITLE GT 47).ERR1    TOO BIG FOR ONE TITLE CARD
         AIF   (K'&PHASEID NE 3).ERR1   IT MUST BE THREE IN LENGTH
         AIF   (K'&LEVEL EQ 0).ERR1     IT MUST BE PRESENT
.*
&ASMID   SETC  '&PHASEID'               PUT PHASEID IN GBLC
&ASMLEV  SETA  &LEVEL                   PUT LEVEL IN GBLA
.*
&COMPNM  SETC  'IFN'                    SYSTEM INDEPENDENT NAME
         AIF   ('&ASMID'(2,1) NE '0').SKIP
&COMPNM  SETC  'IFO'                    SYSTEM DEPENDENT NAME
.SKIP    ANOP
.*
&I       SETA  1                        NOW TRANSFER TITLE TO VARIABLE
&J       SETA  2
.LPA     ANOP
         AIF   (K'&TITLE EQ &J).NXA
         AIF   (K'&TITLE LT &J+8).LPA1
&X(&I)   SETC  '&TITLE'(&J,8)
&I       SETA  &I+1
&J       SETA  &J+8
         AGO   .LPA
.LPA1    ANOP
&X(&I)   SETC  '&TITLE'(&J,K'&TITLE-&J)
.NXA     ANOP
.*
&ASMID   TITLE '&COMPNM&ASMID - &X(1)&X(2)&X(3)&X(4)&X(5)&X(6)'
.*
         MNOTE *,'STATUS--CHANGE LEVEL &LEVEL'
         MEXIT
.*
.ERR1    MNOTE 8,'PARAMETER ERROR.'
         MEND
./       ADD   NAME=JINCOM
JINCOM   DSECT
         USING JINCOM,R7                SET UP MODULE COMMON BASE
JSYSIN   DS    A                        ADDR OF FILE DEF FOR INPUT
JSYSLIB  DS    A                        ADDR OF FILE DEF FOR LIBRARY
JINOPEN  DS    A                        ADDR OF OPEN PARM LIST
JINCLOS  DS    A                        ADDR OF CLOSE PARM LIST
         READ  JLIBDECB,SF,MF=L         DECB FOR LIBRARY
JLIBBUF  DS    A                        ADDR OF LIBRARY BUFFER
JBLKSIZE DS    H                        BLOCK SIZE OF CURRENT LIB REC
JLIBNDX  DS    H                        BUFFER INDEX INTO LIB BUFFER
JINSW    DSW   JREADPT                  SPECIAL READ FOR POINT
JINCMEND DS    0D                       END OF INPUT COMMON
./       ADD   NAME=JINST
         MACRO
&NAME    JINST &OP,&REG,&ADDR,&COMP
         LCLC  &X
         LCLA  &I
.*       INNER MACRO.   GENERATES MACHINE INSTRUCTIONS ACCORDING
.*       TO MACRO CALL OPERANDS VALUES.
         AIF   ('&ADDR'(1,1) NE '(').NXC
         AIF   ('&ADDR'(K'&ADDR,1) NE ')').NXC
&X       SETC  '&ADDR'(2,K'&ADDR-2)
         AIF   ('&X' NE '&REG').NXB
         AIF   (K'&NAME EQ 0).NXA
&NAME    DC    0H'0'
.NXA     MEXIT
.NXB     ANOP
&NAME    LR    &REG,&X
         MEXIT
.NXC     ANOP
&I       SETA  4
         AIF   (K'&ADDR GE 4).NXC1
&I       SETA  K'&ADDR
.NXC1    AIF   (K'&COMP NE 0 AND '&ADDR'(1,&I) NE 'FILE').ERR1
&NAME    &OP   &REG,&ADDR
         MEXIT
.ERR1    MNOTE 8,'PARAMETER ERROR.'
         MEND
./       ADD   NAME=JMODID
         MACRO
&NAME    JMODID
         GBLA  &SNUMBER,&ASMLEV
         GBLC  &ASMID,&COMPNM
.*       GENERATES EMBEDDED IDENTIFIER CONSISTING OF SIX CARACTER
.*       MODULE NAME AND A HALF WORD BINARY ASSEMBLER LEVEL.
&NAME    DC    CL6'&COMPNM&ASMID',HL2'&ASMLEV'
         MEND
./       ADD   NAME=JNOTE
         MACRO
&NAME    JNOTE &FILE=
.*       GENERATES A CALL TO THE WORKFILE I/O MODULE TO GET
.*       THE RELETIVE POSITION OF THE LAST READ OR WRITE
         AIF   (K'&FILE EQ 0).ERR1
&NAME    JINST LA,R10,&FILE,FILE
         L     R12,JMLC                 LOAD BASE
         BAL   R9,JNOTE(,R12)           GO TO JNOTE
         MEXIT
.ERR1    MNOTE 8,'PARAMETER ERROR.'
         MEND
./       ADD   NAME=JPATCH
         MACRO
&N       JPATCH &MOD,&MODLEN,&AREA,&K1=21,&K2=20
         GBLA  &PI
         GBLC  &COMPNM,&ASMID
         LCLA  &A
         LCLC  &NAME,&L1,&L3,&L4,&L5
.P2      PUSH  PRINT
&NAME    SETC  '&COMPNM&MOD'
         PRINT GEN,DATA
.*THE PATCH AREA IS INITIALIZED TO 5% OF THE ORIGINAL CSECT.  BY
.*EVOKING THE "PATCH" MACRO, SUBSEQUENT ADDITIONS TO THE MODULE WILL
.*"SHRINK" THE ORIGINAL 5%-PATCH AREA VIA THE DYNAMIC ASSIGNMENT OF A
.*NEW LESS-THAN-5%-PATCH AREA.  AT LEAST A 5%-PATCH AREA WILL BE
.*DYNAMICALLY MAINTAINED FOR DELETIONS TO THE MODULE.
&NAME    CSECT
         LTORG
         PRINT GEN,NODATA
         AIF   (T'&AREA EQ 'O').NOAREA
&A       SETA  &AREA
.NOAREA  AIF   (&PI NE 0).DS2
PATCHDC  DC    C'&NAME &SYSTIME &SYSDATE'
ABSOLEN  EQU   X'&MODLEN'-&A+L'PATCHDC  CALCULATE ACTUAL MODULE LENGTH
PTCHLEN  EQU   &NAME+ABSOLEN*&K1/&K2-*        LENGTH OF PATCH AREA
PATCH    DC    ((PTCHLEN+1)/PTCHLEN*PTCHLEN)C' '    DYNAMIC PATCH AREA
         AGO   .EXIT
.DS2     ANOP
&L4      SETC  'PATCHDC&PI'
&L5      SETC  'L'''.'PATCHDC&PI'
&L4      DC    C'&NAME &SYSTIME &SYSDATE'
&L1      SETC  'ABSOLEN&PI'
&L3      SETC  'PTCHLEN&PI'
&L1      EQU  X'&MODLEN'-&A+&L5         CALCULATE ACTUAL MODULE LENGTH
&L3      EQU   &NAME+&L1*&K1/&K2-*            LENGTH OF PATCH AREA
PATCH&PI DC    ((&L3+1)/&L3*&L3)C' '                DYNAMIC PATCH AREA
.EXIT    POP   PRINT
&PI      SETA  &PI+1                    FOR UNIQUE LABELS
         MEND
./       ADD   NAME=JPOINT
         MACRO
&NAME    JPOINT &FILE=,&ADDR=,&NEXT=
         LCLC  &XXX
         LCLA  &I
.*       GENERATES A CALL TO THE WORKFILE I/O MODULE TO POSITION
.*       THE FILE TO A SPECIFIED POSITION
         AIF   (K'&NEXT LT 4).IN1
&I       SETA  4
         AGO   .IN2
.IN1     ANOP
&I       SETA  K'&NEXT
.IN2     ANOP
         AIF   (K'&FILE EQ 0 OR K'&ADDR EQ 0 AND                       X
               '&NEXT' NE 'START').ERR1
         AIF   ('&NEXT' NE 'READ' AND '&NEXT' NE 'WRITE' AND           X
               '&NEXT' NE 'GET' AND '&NEXT' NE 'PUT' AND               X
               '&NEXT' NE 'START').ERR1
&XXX     SETC  '&NEXT'(1,&I)
&NAME    SET   JPT4&XXX,ON
         JINST LA,R10,&FILE,FILE
         AIF   ('&NEXT' EQ 'START').NXA
         JINST LA,R11,&ADDR
.NXA     L     R12,JMLC                 LOAD BASE
         BAL   R9,JPOINT(,R12)          GO TO JPOINT
         MEXIT
.ERR1    MNOTE 8,'PARAMETER ERROR.'
         MEND
./       ADD   NAME=JPRINT
         MACRO
&NAME    JPRINT
.*       GENERATES A CALL TO THE OUTPUT I/O MODULE TO PRINT A LINE
.*       ON SYSPRINT AND GET THE ADDRESS OF THE NEXT BUFFER BACK.
&NAME    L     R12,JOUTMLC              LOAD BASE
         BAL   R9,JPRINT(,R12)          GO TO JPRINT
         MEND
./       ADD   NAME=JPUNCH
         MACRO
&NAME    JPUNCH &SEQ=YES
.*       GENERATES A CALL TO THE OUTPUT I/O MODULE TO OUTPUT
.*       A 80-BYTE RECORD ON SYSPUNCH AND SYSGO AND GET THE ADDRESS
.*       OF THE NEXT BUFFER BACK.
         AIF   ('&SEQ' EQ 'YES').NXA
&NAME    SET   JNOSEQPH,ON
         L     R12,JOUTMLC              LOAD BASE
         AGO   .NXB
.NXA     ANOP
&NAME    L     R12,JOUTMLC              LOAD BASE
.NXB     BAL   R9,JPUNCH(,R12)          GO TO JPUNCH
         MEND
./       ADD   NAME=JPUTM
         MACRO
&NAME    JPUTM &FILE=,&ADDR=
.*       GENERATES A CALL TO THE WORKFILE I/O MODULE TO COPY A RECORD
.*       INTO THE OUTPUT BUFFER.
         AIF   (K'&FILE EQ 0 OR K'&ADDR EQ 0).ERR1
&NAME    JINST LA,R10,&FILE,FILE
         JINST LA,R11,&ADDR
         L     R12,JMLC                 LOAD BASE
         BAL   R9,JPUTM(,R12)           GO TO JPUTL
         MEXIT
.ERR1    MNOTE 8,'PARAMETER ERROR.'
         MEND
./       ADD   NAME=JREAD
         MACRO
&NAME    JREAD &FILE=,&PARM=
.*       GENERATES A CALL TO THE WORKFILE I/O MODULE TO READ
.*       A PHYSICAL RECORD. A JCHECK MACRO CALL MUST BE ISSUED
.*       BEFORE ANY ADDITIONAL OPERATIONS TO THE WORKFILE ARE DONE.
         AIF   (K'&FILE EQ 0 OR K'&PARM EQ 0).ERR1
&NAME    JINST LA,R10,&FILE,FILE
         JINST LA,R11,&PARM
         L     R12,JMLC                 LOAD BASE
         BAL   R9,JREAD(,R12)           GO TO JREAD
         MEXIT
.ERR1    MNOTE 8,'PARAMETER ERROR.'
         MEND
./       ADD   NAME=JRETURN
         MACRO
&NAME    JRETURN
.*       RESTORES THE REGISTERS OF THE CALLING PROGRAM FROM A PUSH
.*       DOWN SAVE AREA (R2 THRU R9) AND THEN RETUTNS TO THE CALLER
.*       VIA R9. REQUIRES A NAME FIELD.
         AIF   (K'&NAME EQ 0).ERR1
&NAME    LM    R8,R9,JCLVLPTR           GET CURRENT LVL & DECR
         BXLE  R8,R9,0                  DECREMENT LEVEL POINTER
         ST    R8,JCLVLPTR              SAVE NEW LEVEL POINTER
         LM    R2,R9,JSAVESZ(R8)        RESTORE REGISTERS R2 THRU R9
         BR    R9                       RETURN TO CALLING PROGRAM
         MEXIT
.ERR1    MNOTE 8,'OMITTED NAME.'
         MEND
./       ADD   NAME=JSAVE
         MACRO
&NAME    JSAVE &BASE=YES
.*       SAVES THE REGISTERS OF THE CALLING PROGRAM INTO A PUSH DOWN
.*       SAVE AREA (R2 THRU R9). UNLESS OVERRIDDEN THE MACRO WILL LOAD
.*       THE BASE REGISTER R8, FROM R12 AND GIVE A USING STATEMENT.
         AIF   (K'&NAME EQ 0).ERR1
         AIF   ('&BASE' EQ 'NO').NXA
         USING &NAME,R8                 SET USING FOR SUBR BASE
.NXA     ANOP
&NAME    L     R15,JCLVLPTR             POINT TO CURRENT LEVEL
         LA    R15,JSAVESZ(,R15)        INCREMENT LEVEL POINTER
         ST    R15,JCLVLPTR             STORE NEW LEVEL POINTER
         STM   R2,R9,0(R15)             SAVE R2 THRU R9
         AIF   ('&BASE' EQ 'NO').NXB
         LR    R8,R12                   ESTABLISH SUBR BASE
.NXB     MEXIT
.ERR1    MNOTE 8,'OMITTED NAME.'
         MEND
./       ADD   NAME=JTEXT
JTEXT    DSECT  ,                       TEXT RECORD DSECT
JTRLI    DS    1H                       RECORD LENGTH INDICATOR
         SPACE
*        FLAGA                OP CODE DEPENDENT FLAGS
         SPACE
JTFLGA   DSW   JPSOP,                   PSEUDO-OP FLAG                 X
               JEXTB,                   EXTENDED OPCODE FLAG           X
               JINPC,                   INITIALIZE PRIVATE CODE        X
               JINHB,                   INHIBIT BIT                    X
               JDEF,                    DEFINITION RECORD              X
               JREF,                    SCAN FOR SYMBOL REFERENCES     X
               JREQOP,                  OPERAND REQUIRED FOR INTERLUDE X
               JDCSX                    ON FOR DC, DS, AND DXD ONLY
         ORG   JTFLGA                   OVERLAY
JTFLGA1  DSW   ,,,,,                    DECLARED ABOVE                 X
               JPRESD,                  ON FOR PRE-ESD PUNCH & REPRO   X
               JLN4,                    INSTRUCTION LENGTH BIT 1       X
               JLN2                     INSTRUCTION LENGTH BIT 2
         SPACE
*        FLAGB                DYNAMIC FLAGS
         SPACE
JTFLGB   DSW   JPRONLY,                 PRINT ONLY                     X
               JERR,                    DEAD STATEMENT                 X
               JNOCNT,                  DO NOT ASSIGN STATEMENT NUMBER X
               JGEN,                    STATEMENT IS GENERATED         X
               JNMERR,                  INVALID NAME FIELD             X
               JSUBNAME,                SUBSTITUTION REQUIRED-NAME     X
               JSUBOPCD,                SUBSTITUTION REQUIRED-OP CODE  X
               JSUBOPND                 SUBSTITUTION REQUIRED-OPERAND
JTIOP    DS    0H
JTIOP1   DBV   ,                        INTERNAL OP CODES 1ST BYTE     X
               JTICTL(0),                    ICTL                      X
               JTISEQ(JTICTL+1),             ISEQ                      X
               JTOPSYN(JTISEQ+1),            OPSYN                     X
               JTCOPY(JTOPSYN+1),            COPY                      X
               JTANOP(JTCOPY+1),             ANOP                      X
               JTGBLA(JTANOP+1),             GBLA                      X
               JTGBLB(JTGBLA+1),             GBLB                      X
               JTGBLC(JTGBLB+1),             GBLC                      X
               JTLCLA(JTGBLC+1),             LCLA                      X
               JTLCLB(JTLCLA+1),             LCLB                      X
               JTLCLC(JTLCLB+1),             LCLC                      X
               JTMACRO(JTLCLC+1),            MACRO                     X
               LOGENOP(JTMACRO),   LOWEST GENERATOR OP                 X
               JTACTR(JTMACRO+1),            ACTR                      X
               JTAGO(JTACTR+1),              AGO                       X
               JTAGOB(JTAGO),                AGOB  SAME AS AGO         X
               JTAIF(JTAGO+1),               AIF                       X
               JTAIFB(JTAIF),                AIFB  SAME AS AIF         X
               JTSETA(JTAIF+1),              SETA                      X
               JTSETB(JTSETA+1),             SETB                      X
               JTSETC(JTSETB+1),             SETC                      X
               JTMEXIT(JTSETC+1),       MEXIT                          X
               JTMEND(JTMEXIT+1),            MEND                      X
               JTCALL(JTMEND+1),        MACRO CALL                     X
               JTCPKEY(JTCALL+1),            CALL PARAMETER--KEYWORD   X
               JTCPPOS(JTCPKEY+1),           CALL PARAMETER--POSITIONALX
               JTPROTO(JTCPPOS+1),      PROTOTYPE                      X
               JTPREP(JTPROTO),              MODIFIED REPRO RECORD     X
               JTPPKEY(JTPROTO+1),           PROTOTYPE PARM--KEYWORD   X
               JTPPCH(JTPPKEY),              MODIFIED PUNCH RECORD     X
               JTPPPOS(JTPPKEY+1),           PROTOTYPE PARM--POSITIONALX
               JTINPC(JTPPPOS),              UNINITIATED PRIVATE CODE  X
               JTPEND(JTPPPOS+1),       END OF PARMS--PROTO OR MACRO   X
               JTPMOP(JTPEND),               PETE'S MACHINE OP         X
               JTEND(JTPEND+1),              END                       X
               HIGENOP(JTEND),          HI GENERATOR OP                X
               LOREFOP(JTEND),          LO SYMBOL REFERENCE OP         X
               LODEFOP(JTEND),          LO SYMBOL DEFINITION OP        X
               JTDXD(JTEND+1),               DXD                       X
               JTEQU(JTDXD+1),               EQU                       X
               JTORG(JTEQU+1),               ORG                       X
               JTCNOP(JTORG+1),              CNOP                      X
               JTCCW(JTCNOP+1),              CCW                       X
               JTDC(JTCCW+1),                DC                        X
               JTDS(JTDC+1),                 DS                        X
               JTSTART(JTDS+1),              START                     X
               HIREFOP(JTSTART),        HI SYMBOL REFERENCE OP         X
               JTCSECT(JTSTART+1),           CSECT                     X
               JTDSECT(JTCSECT+1),           DSECT                     X
               JTCOM(JTDSECT+1),             COM                       X
               JTENTRY(JTCOM+1),             ENTRY                     X
               JTLTLC(JTENTRY),         CSECT FOR LITERAL POOL         X
               JTEXTRN(JTENTRY+1),           EXTRN                     X
               JTLTDC(JTEXTRN),         LITERAL DC                     X
               JTWXTRN(JTEXTRN+1),           WXTRN                     X
               JTLTND(JTWXTRN),         LITERAL POOL END               X
               JTCXD(JTWXTRN+1),             CXD                       X
               JTLTORG(JTCXD+1),             LTORG                     X
               HIDEFOP(JTLTORG),        HI SYMBOL DEFINITION OP        X
               JTLITR(JTLTORG+1),            LITERAL DEFINITIONS       X
               JTSYMBL(JTLITR+1),            SYMBOL REFERENCE          X
               JTPUNCH(JTSYMBL+1),           PUNCH                     X
               JTEOFII(JTPUNCH),             ESD ADJUSTMENT RECORD     X
               JTREPRO(JTPUNCH+1),           REPRO                     X
               JTLITII(JTREPRO),             LITERAL ADJUSTMENT RECORD X
               JTPUSH(JTREPRO+1),            PUSH                      X
               JTLTEND(JTPUSH),              END-OF-LITERAL-POOL       X
               JTPOP(JTPUSH+1),              POP                       X
               JTADJII(JTPOP),               PETE'S END-OF-FILE        X
               JTPRINT(JTPOP+1),             PRINT                     X
               JTPASS(JTPRINT),              NO PROCESS RECORD         X
               JTUSING(JTPRINT+1),           USING                     X
               JTSYMII(JTUSING),             SYMBOL TABLE ENTRY        X
               JTDROP(JTUSING+1),            DROP                      X
               JTCMNT(JTDROP+1),             COMMENT CARD              X
               JTHCMNT(JTCMNT+1),       HIDDEN COMMENT                 X
               JTERROR(JTHCMNT+1),      ERROR                          X
               JTSPACE(JTERROR+1),           SPACE                     X
               LONOPRN(JTSPACE),        LO NO-PRINT OP                 X
               JTEJECT(JTSPACE+1),           EJECT                     X
               JTTITLE(JTEJECT+1),           TITLE                     X
               JTMNOTE(JTTITLE+1),           MNOTE                     X
               JTSICTL(JTMNOTE+1),           INTERNAL ICTL ONLY        X
               JTEEOF(X'FE'),                EARLY END OF TEXT FILE    X
               JTEOF(X'FF')                  END OF TEXT FILE
JTIOP2   DBV   ,                        SECOND BYTE OF OP-CODE
JTNMP    DS    1H                       NAME FIELD POINTER
JTOCP    DS    1H                       OPCODE POINTER IN TEXT RECORD
JTOPP    DS    1H                       OPERAND POINTER IN TEXT RECORD
JTCPR    DS    1H                       COMMENTS POINTER IN TEXT
JTSPR    DS    1H                       STRING POINTER IN TEXT
JTSYMCNT DS    1C                       NUMBER OF SYMBOLS IN OPERAND
JTFLGC   DSW   JPRGMAC,                 PROGRAMMER MACRO               X
               JPRGICTL                 STANDARD ICTL
         SPACE
JTHDREND EQU   *                        END OF TEXT HEADER
JTHDRLN  EQU   JTHDREND-JTEXT           TEXT HEADER LENGTH
         SPACE 3
JTEXTA   DSECT  ,                       DSECT FOR VARIABLE TEXT PORTION
         SPACE
*        NAME FIELD IN VARIABLE TEXT
         SPACE
JTNMO    DSW   JTNMOCD,            NAME CARD POINTER--REAL PTR FOLLOWS X
               ,                        NOT USED                       X
               ,                        NOT USED                       X
               ,                        NOT USED                       X
               ,                        NOT USED                       X
               ,                        NOT USED                       X
               ,                        NOT USED                       X
                                        NOT USED
JTNML    DS    1C                       NAME LENGTH
JTNAME   EQU   *                        NAME
         SPACE
         ORG   JTNMO                    RESET LOCATION COUNTER
*                                  OPCODE POINTER IN TEXT RECORD
         SPACE
JTOCO    DSW   JTOCOCD,       OP-CODE CARD POINTER--REAL JTOCO FOLLOWS X
               ,                        NOT USED                       X
               ,                        NOT USED                       X
               ,                        NOT USED                       X
               ,                        NOT USED                       X
               ,                        NOT USED                       X
               ,                        NOT USED                       X
                                        NOT USED
         SPACE
JTOCL    DS    1C                       OP CODE LENGTH
JTOPCD   EQU   *                        OP CODE
         ORG   JTOCO                    RE-ORG AFTER VARIABLE TEXT
JTOPO    DSW   JTOPOCD,       OPND CARD POINTER--REAL JTOPO FOLLOWS    X
               ,                        NOT USED                       X
               ,                        NOT USED                       X
               ,                        NOT USED                       X
               ,                        NOT USED                       X
               ,                        NOT USED                       X
               ,                        NOT USED                       X
                                        NOT USED
JTOPL    DS    1C                       OPERAND LENGTH
JTOPND   EQU   *                        OPERAND
         ORG   JTOCO                    RE-ORG AFTER VARIABLE TEXT
JTCOP    DS    1C                       COMMENT OUTPUT POINTER
JTCML    DS    1C                       COMMENT LENGTH
JTCMM    EQU   *                        COMMENT
         ORG   JTOCO                    RE-ORG AFTER VARIABLE TEXT
JTSTC    DS    1C                       STRING COUNT
JTSTO    DS    1C                       STRING 1 OUTPUT COLUMN POINTER
JTSTL    DS    1C                       STRING 1 LENGTH
JTSTR    EQU   *                        STRING 1
         ORG   JTOCO                    RE-ORG AFTER VARIABLE TEXT
JTSTO2   DS    1C                       STRING 2 OUTPUT COLUMN POINTER
JTSTL2   DS    1C                       STRING 2 LENGTH
JTSTR2   EQU   *                        STRING 2
./       ADD   NAME=JWRITE
         MACRO
&NAME    JWRITE &FILE=,&PARM=
.*       GENERATES A CALL TO THE WORKFILE I/O PACKAGE TO WRITE
.*       A PHYSICAL RECORD. THE OPERATIN MUST BE CHECKED FOR COMPLETION
.*       BEFORE ANY ADDITIONAL OPERATIONS TO THE FILE IS DONE (JCHECK).
         AIF   (K'&FILE EQ 0 OR K'&PARM EQ 0).ERR1
&NAME    JINST LA,R10,&FILE,FILE
         JINST LA,R11,&PARM
         L     R12,JMLC                 LOAD BASE
         BAL   R9,JWRITE(,R12)          GO TO JWRITE
         MEXIT
.ERR1    MNOTE 8,'PARAMETER ERROR.'
         MEND
./       ADD   NAME=LINKIN
 INCLUDE LINKLIB(IFOX00)
 ORDER IFOX0A00,IFOX0B00
 ENTRY IFOX0A01
 NAME AFOX00(R)
 INCLUDE OBJECT1
 NAME IFOXX4(R)
 INCLUDE OBJECT2
 INCLUDE LINKLIB(IFOX41)
 ORDER IFNX4D00,IFNX4E00,IFNX4M00,IFNX4S00,IFNX4V00
 ENTRY IFNX4M01
 NAME IFOX4A(R)
 INCLUDE OBJECT2
 INCLUDE LINKLIB(IFOX42)
 ORDER IFNX4E00,IFNX4N00,IFNX4S00,IFNX4T00,IFNX4V00
 ENTRY IFNX4T01
 NAME IFOX4B(R)
./       ADD   NAME=MACREFBL
*        **************** - MACREFBL - ****************           .PRC.
@B       DSECT                                                    .PRC.
@BFREE   DS    F                   LENGTH FOR FREEMAIN            .PRC.
@BCOUNT  DS    F                   NUMBER OF NAMES IN TABLE       .PRC.
@BSEARCH DS    A(@BLIST)           ADDRESS OF FIRST ENTRY         .PRC.
         DS    A(16)               LENGTH OF AN ENTRY             .PRC.
         DS    A(0)                ADDRESS OF LAST ENTRY          .PRC.
@BDSNA   DS    A(0)                ADDRESS OF DSNAME TABLE        .PRC.
@BDSNN   DS    H                   NUMBER OF DSNAME TABLE ENTRIES .PRC.
@BDSNL   DS    H                   LENGTH OF A DSNAME TABLE ENTRY .PRC.
@BDSNS   EQU   50                  LENGTH OF A DSNAME TABLE ENTRY .PRC.
@BLDL    DC    AL2(1,14)                                          .PRC.
@BLDLMEM DC    CL8' '                                             .PRC.
@BLDLTTR DC    XL6'00'                                            .PRC.
@BFLAG   DS    X'00',X'00'         INCOMPLETE FLAG                .PRC.
         DS    0F                  ALIGN TABLE                    .PRC.
@BL      EQU   *-@B                LENGTH IF PREFIX               .PRC.
@BLIST   EQU   *                   BEGINNING OF TABLE             .PRC.
@BELL    EQU   16                  LENGTH OF AN ENTRY             .PRC.
@BMAX    EQU   512    TAKES 8K     MAXIMUM NUMBER OF ENTRIES      .PRC.
*        **************** - MACREFBL - *************END           .PRC.
./       ADD   NAME=MACREFFI
*         *************** - MACREFFI -  ******************        .PRC.
*
*         ENTERED EACH TIME A 'FIND' IS REQUESTED.
*         ISSUE A BLDL TO GET CONCATENATION NUMBER.
*         ADD MEMBER NAME, CONCAT NUMBER, AND RETURN CODE TO TABLE.
*
*         IFOX0F IS MODIFIED ELSEWHERE TO DO A FIND FROM THE
*         DIRECTORY INFO RETURNED BY THE BLDL INSTEAD OF
*         A FIND THAT REQUIRES ANOTHER DIRECTORY SEARCH.
*
*         WRITTEN BY BILL GODFREY, PLANNING RESEARCH CORPORATION,
*         PRC COMPUTER CENTER INC, MCLEAN VA
*
         SLR   R3,R3                    INDICATE TABLE FULL
         LA    R14,JSAFE                POINT TO WKAREA POINTER
         CLI   0(R14),X'77'             IS THERE A BLDL TABLE?
         BNE   @LADD                    NO - BRANCH
         L     R6,0(,R14)               POINT TO GETMAINED AREA
         USING @B,R6                    BLDL LIST ADDRESSABILITY
         LM    R2,R5,@BCOUNT            GET NUMBER OF ENTRIES
@LNXLOOP CLI   2(R3),0                  AVAILABLE ENTRY?
         BE    @LADD                    YES - ADD AN ENTRY
         CLC   2(8,R3),JDWORD           REQUESTED BEFORE?
         BE    @LOPTIM                  YES - (NEVER HAPPENS)
         BXLE  R3,R4,@LNXLOOP           CONTINUE SEARCH
         SLR   R3,R3                    INDICATE TABLE FULL
         OI    @BFLAG,X'01'             INDICATE INCOMPLETE LIST
         B     @LADD
@LOPTIM  EQU   *
         MVC   @BLDLMEM(14),2(R3)       COPY BLDL RESULT
         SLR   R15,R15
         IC    R15,0(,R3)               SET RETURN CODE
         B     @LEXIT                   BRANCH AROUND BLDL
@LADD    EQU   *
         MVC   @BLDL(4),=AL2(1,14)      SET BLDL LIST VALUES
         MVC   @BLDLMEM,JDWORD          MOVE MEMBER
         BLDL  (1),@BLDL                READ DIRECTORY ENTRY
         LTR   R3,R3                    ADDING A NEW ENTRY?
         BZ    @LEXIT                   NO - BRANCH
         MVC   2(14,R3),@BLDLMEM        YES - SAVE RESULT
         MVC   1(1,R3),@BLDLTTR+3       K OF TTRKZC
         STC   R15,0(,R3)               SAVE RETURN CODE
         LA    R2,1(,R2)                ADD 1 TO COUNT
         ST    R2,@BCOUNT               SAVE COUNT
@LEXIT   EQU   *
*        **************** - MACREFFI -  ***************END
./       ADD   NAME=MACREFGM
*         *************** - MACREFGM -  ******************        .PRC.
*
*         ENTERED JUST AFTER SYSLIB IS OPENED.
*         GETMAIN AN AREA FOR MACRO REFERENCE TABLES.
*         GET DSNAME AND VOLUME OF EACH LIBRARY.
*         FILL MEMBER TABLE WITH ZEROES.
*
*         WRITTEN BY BILL GODFREY, PLANNING RESEARCH CORPORATION,
*         PRC COMPUTER CENTER INC, MCLEAN VA
*
         L     R1,JSYSLIB               GET ADDRESS OF SYSLIB DCB
         USING IHADCB,R1
         L     R5,DCBDEBAD              GET ADDRESS OF SYSLIB DEB
         DROP  R1
         SLR   R3,R3
         IC    R3,4(,R5)                DEBAMLNG, NUMBER OF CONCATS
         LA    R1,1(,R3)                PLUS 1 FOR FIRST LIBRARY
         LA    R0,@BDSNS                LENGTH OF EACH DSNAME/VOL
         MR    R0,R0                    MULTIPLY R1 BY 50
         LA    R4,@BMAX                 TABLE CAPACITY
         SLL   R4,4                     MULTIPLY BY 16
*        MH    R4,=AL2(@BELL)           (REPLACE SLL IF @BELL NOT 16)
         LA    R0,@BL                   LENGTH OF PREFIX
         AR    R0,R4                    PLUS LENGTH OF MEMBER TABLE
         AR    R0,R1                    PLUS LENGTH OF DSNAME AREA
         LR    R6,R0                    SAVE LENGTH ACROSS GETMAIN
         GETMAIN R,LV=(0)
         ST    R1,JSAFE                 SAVE ADDRESS IN JCOMMON
         MVI   JSAFE,X'77'              INDICATE IT IS OURS
         ST    R6,0(,R1)                SAVE LENGTH FOR FREEMAIN
         LR    R6,R1
         USING @B,R6
         LA    R3,1(,R3)                NUMBER OF CONCATS
         STH   R3,@BDSNN                 PLUS 1 FOR FIRST LIBRARY
         SLR   R2,R2                    NUMBER OF NAMES IN TABLE
         LA    R3,@BL(,R6)              FIRST ENTRY IN TABLE
         LA    R5,0(R4,R3)              END OF TABLE
         ST    R5,@BDSNA                ADDRESS OF DSNAME/VOL TABLE
         LA    R4,@BELL                 LENGTH OF AN ENTRY
         SLR   R5,R4                    LAST ENTRY IN TABLE
         STM   R2,R5,@BCOUNT            SAVE COUNT AND BXLE VALUES
         MVI   @BFLAG,0
         LA    R0,@BDSNS                LENGTH OF
         STH   R0,@BDSNL                 EACH DSNAME ENTRY
         L     R5,16                    CVTPTR
         L     R5,0(,R5)                TCB WORDS
         L     R5,4(,R5)                CURRENT TCB
         L     R5,12(,R5)               TIOT
         L     R4,JSYSLIB
         USING IHADCB,R4
         MVC   4(4,R3),@BDSNA           POINTER TO DSNAME SAVE AREA
         MVC   08(2,R3),DCBTIOT         SAVE ORIGINAL TIOT OFFSET
         MVC   12(4,R3),DCBEXLST        SAVE ORIGINAL EXLST
         XC    DCBEXLST+1(3),DCBEXLST+1 ZERO EXLST ADDRESS
         LA    R1,16(,R3)               POINT TO NEW EXLST
         O     R1,DCBEXLST              RESTORE FIRST 8 BITS
         ST    R1,DCBEXLST              SET NEW EXLST IN DCB
         LA    R0,20(,R3)               POINT TO 176 BYTE JFCB AREA
         ST    R0,0(,R1)                PUT ADDRESS IN EXLST FIELD
         MVI   0(R1),X'87'              MARK EXLST FIELD AS JFCB
         MVI   0(R3),X'80'              SET RDJFCB MF=L BYTE 1
         LH    R2,@BDSNN                NUMBER OF LIBRARIES
@RDJLOOP EQU   *
         RDJFCB ((R4)),MF=(E,(R3))
         SPACE
*               THE FOLLOWING INSTRUCTIONS CAN REPLACE THE RDJFCB
*               ON THE MVS OPERATING SYSTEM, BUT NOT ON OS/MVT.
*        LH    R1,DCBTIOT               GET TIOT OFFSET
*        AR    R1,R5                    POINT TO TIOT ENTRY
*        L     R1,12(,R1)               TIOEJFCB
*        SRL   R1,8                     SHIFT ADDRESS TO RIGHT
*        L     R1,0(,R1)                POINT TO JFCB PREFIX
*        LA    R1,08(,R1)               POINT TO JFCB
*        L     R15,16(,R3)              POINT TO RECEIVING FIELD
*        MVC   0(176,R15),0(R1)         RDJFCB
         SPACE
         L     R1,16(,R3)               POINT TO JFCB
         L     R15,4(,R3)               POINT TO NEXT DSNAME AREA
         MVC   0(44,R15),0(R1)          COPY DSNAME FROM JFCB
         MVC   44(6,R15),118(R1)        COPY VOLUME FROM JFCB
         AH    R15,@BDSNL               POINT TO NEXT DSNAME
         ST    R15,4(,R3)               SAVE NEXT DSNAME POINTER
         LH    R1,DCBTIOT               GET TIOT OFFSET
         AR    R1,R5                    POINT TO TIOT ENTRY
         SLR   R0,R0
         IC    R0,0(,R1)                LENGTH OF THIS ENTRY
         AR    R1,R0                    POINT TO NEXT TIOT ENTRY
         SR    R1,R5                    COMPUTE OFFSET
         STH   R1,DCBTIOT               NEW TIOT OFFSET TO FOOL RDJFCB
         BCT   R2,@RDJLOOP
         MVC   DCBTIOT(2),08(R3)        RESTORE TIOT OFFSET
         MVC   DCBEXLST(4),12(R3)       RESTORE EXLST
         DROP  R4                       IHADCB
         LM    R3,R5,@BSEARCH
         DROP  R6                       @B
@LCLEAR  XC    0(@BELL,R3),0(R3)
         BXLE  R3,R4,@LCLEAR
*        **************** - MACREFGM -  *************** END
./       ADD   NAME=MACREF4E
*         *************** - MACREF4E -  ******************        .PRC.
*
*         ENTERED JUST AFTER THE ESD IS PRINTED.
*         CHECKS FOR PRESENCE OF 'MACREF' AS A SWITCH.
*         IF NOT PRESENT, JUST DO A FREEMAIN.
*         SORT THE MEMBER NAME TABLE BY RELATIVE LIBRARY.
*         PRINT OUT THE TABLE IN THE SYSPRINT FILE, WITH
*         LIBRARY NAME NEXT TO FIRST MEMBER MAME.
*         FREEMAIN THE TABLE.
*
*         WRITTEN BY BILL GODFREY, PLANNING RESEARCH CORPORATION,
*         PRC COMPUTER CENTER INC, MCLEAN VA.
*
@MACREF  LA    R14,JSAFE                POINT TO TABLE POINTER
         CLI   0(R14),X'77'             IS THERE A BLDL TABLE?
         BNE   EXIT                     NO - BRANCH
         GOIF  JLIST,NO=@NOLIST
         L     R6,0(,R14)               POINT TO GETMAINED AREA
         USING @B,R6
         L     R1,16                    CVTPTR
         L     R1,0(,R1)                TCB WORDS
         L     R1,4(,R1)                CURRENT TCB
         L     R1,12(,R1)               TCBTIOT
         LA    R1,24(,R1)               FIRST DD ENTRY
@TIOT    TM    0(R1),X'FF'              END OF TIOT
         BZ    @NOLIST                  YES - BRANCH
         CLC   4(8,R1),@DDNAME          DDNAME EQUAL?
         BE    @TIOTX                   YES - BRANCH
         SLR   R14,R14
         IC    R14,0(,R1)               LENGTH OF ENTRY
         LA    R1,0(R14,R1)             POINT TO NEXT DD
         B     @TIOT
@TIOTX   EQU   *
         SPACE 1
@SORT    L     R2,@BCOUNT               GET NUMBER OF NAMES
         BCTR  R2,0                     NUMBER OF COMPARES
         LTR   R2,R2                    ANYTHING TO SORT?
         BNP   @SORTX                   NO - BRANCH
@SORTOUT LR    R15,R2                   COMPARES THIS PASS
         SLR   R1,R1                    SET SWAP FLAG OFF
         LM    R3,R4,@BSEARCH           GET SEARCH VALUES
@SORTIN  CLC   1(9,R3),@BELL+1(R3)      COMPARE 2 ENTRIES
         BNH   @SWAPX                   BRANCH IF IN ORDER
         XC    000(@BELL,R3),@BELL(R3)   SWAP
         XC    @BELL(@BELL,R3),000(R3)    SWAP
         XC    000(@BELL,R3),@BELL(R3)     SWAP
         BCTR  R1,0                     SHOW SWAP OCCURRED
@SWAPX   AR    R3,R4                    NEXT ENTRY
         BCT   R15,@SORTIN              BRANCH IF MORE COMPARES
         LTR   R1,R1                    ANY SWAPS DURING PASS
         BZ    @SORTX                   NO - QUIT EARLY
         BCT   R2,@SORTOUT              REDUCE NUM OF COMPARES
@SORTX   EQU   *
         SPACE 1
         LM    R3,R5,@BSEARCH           GET SEARCH VALUES
         SLR   R2,R2                    FORCE FIRST HEADING
@LIST    EQU   *
         CLI   0(R3),0                  BLDL FAIL FOR ENTRY?
         BNZ   @SKIP                    YES - SKIP IT
         CLI   2(R3),0                  ENTRY EMPTY?
         BE    @LISTX                   YES - DONE
         LTR   R2,R2                    LINECOUNT EXHAUSTED?
         BNZ   @PUT                     NO - BRANCH
@PAGETOP EQU   *
         JPRINT                         GET PRINT BUFFER
         USING @DSECT11,R11
         MVI   @CC,0                    EJECT
         MVC   @DECKID,JDECKID
         MVC   @TITLE,@ZTITLE
         TM    @BFLAG,X'01'             INCOMPLETE?
         BZ    *+10                     NO
         MVC   @INC,@ZINC               (INCOMPLETE)
         MVC   @PAGE,@ZPAGE             PAGE
         LH    R14,JPAGENO              GET OLD PAGE NUMBER
         LA    R14,1(,R14)              INCREMENT BY 1
         STH   R14,JPAGENO              SAVE PAGE NUMBER
         CVD   R14,JDWORD               CONVERT PAGE NUMBER TO DECIMAL
         UNPK  @PAGENO,JDWORD+6(2)      UNPACK TO EBCDIC
         NC    @PAGENO,@DIGMASK         TRANSLATE TO INTERNAL CODE
         GOIF  @PAGENO,J0,NOTEQ=@PAGEX  SKIP IF NOT A LEADING ZERO
         MVI   @PAGENO,JBLANK
         GOIF  @PAGENO+1,J0,NOTEQ=@PAGEX
         MVI   @PAGENO+1,JBLANK
@PAGEX   JPRINT                         GET NEXT PRINT BUFFER
         MVC   @HEAD,@ZHEAD
         MVC   @LVTMDT,JLVTMDT          LEVEL, TIME, DATE
         LH    R2,JLNCT                 GET MAXIMUM LINE COUNT
@PUT     JPRINT                         GET NEXT PRINT BUFFER
         MVI   @CC,1                    SPACE1
         CH    R2,JLNCT                 IS THIS FIRST LINE ON THE PAGE
         BNL   @BREAK                   YES, SPACE2 AND DSNAME
         CLC   @BFLAG+1(1),1(R3)        SAME LIBRARY AS LAST MEMBER
         BE    @SAME                    YES
@BREAK   MVI   @CC,2                    NO, SPACE2
         MVC   @BFLAG+1(1),1(R3)        UPDATE BREAK FIELD
         SLR   R15,R15
         IC    R15,1(,R3)
         MH    R15,@BDSNL               GET INDEX INTO DSNAME TABLE
         A     R15,@BDSNA               POINT TO DSNAME ENTRY
         MVC   @DSNAME,0(R15)           GET DSNAME
         TR    @DSNAME,JTRTABLE         TRANSLATE TO INTERNAL
         LA    R1,@DSNAME+43            FIND
@DSREV   CLI   0(R1),JBLANK              LAST
         BNE   @DSEND                     CHARACTER
         BCT   R1,@DSREV                   IN DSNAME
@DSEND   MVC   2(2,R1),@ON              ADD ' ON '
         MVC   5(6,R1),44(R15)          MOVE VOLUME
         TR    5(6,R1),JTRTABLE         TRANSLATE TO INTERNAL
@SAME    MVC   @LINE+1(8),2(R3)         MOVE MEMBER NAME
         TR    @LINE+1(8),JTRTABLE      TRANSLATE TO INTERNAL
         SLR   R15,R15
         IC    R15,1(,R3)               K OF TTRKZC
         LA    R15,1(,R15)              ZERO-BASE TO ONE-BASE
         CVD   R15,JDWORD
         UNPK  @CONCAT,JDWORD+6(2)      UNPACK CONCAT NUMBER
         NC    @CONCAT,@DIGMASK         TRANSLATE TO INTERNAL CODE
         GOIF  @CONCAT,J0,NOTEQ=@CONCX  SKIP IF NOT A LEADING ZERO
         MVI   @CONCAT,JBLANK
         GOIF  @CONCAT+1,J0,NOTEQ=@CONCX
         MVI   @CONCAT+1,JBLANK
@CONCX   EQU   *
         BCTR  R2,0                     DECREMENT LINECOUNT
@SKIP    EQU   *
         BXLE  R3,R4,@LIST
@LISTX   EQU   *
@NOLIST  L     R0,@BFREE
         LR    R1,R6
         DROP  R6                       @B
         FREEMAIN R,LV=(0),A=(1)
         B     EXIT
         SPACE
@DDNAME  DC    CL8'MACREF'
@MAX     DC    AL2(@BMAX)               TABLE CAPACITY 256 NAMES
@DIGMASK DC    X'0F0F0F'
@ZTITLE  JGENIN 'MACRO LIBRARY REFERENCE LIST'
@ZINC    JGENIN '(INCOMPLETE)'
@ZPAGE   JGENIN 'PAGE'
@ZHEAD   JGENIN '3MEMBER    CONCAT  LIBRARY'
@ON      JGENIN 'ON'
*
@DSECT11 DSECT
@LINE    DS    0CL121
@CC      DS    C
@DECKID  DS    CL8
         ORG   @LINE+47
@TITLE   DS    C'MACRO LIBRARY REFERENCE LIST'
         DS    C
@INC     DS    C'(INCOMPLETE)'
         ORG   @LINE+112
@PAGE    DS    CL4,CL2
@PAGENO  DS    CL3
         ORG   @LINE
@HEAD    DS    C'3MEMBER    CONCAT  LIBRARY'
         ORG   @LINE+121-L'JLVTMDT
@LVTMDT  DS    CL(L'JLVTMDT)
         ORG   @LINE
         DS    CL12
@CONCAT  DS    CL3
         DS    CL4
@DSNAME  DS    CL44
*
*        **************** - MACREF4E -  ****************** END
./       ADD   NAME=OFNX4E
ESD      
TXT 
TXT 
TXT 
TXT 
TXT 
TXT 
TXT 
TXT 
TXT 
TXT 
TXT 
TXT 
TXT 
TXT 
TXT 
TXT 
TXT 
TXT 
TXT 
TXT 
TXT 
TXT 
TXT 
TXT 
TXT 
TXT 
TXT 
TXT 
TXT 
TXT 
TXT 
TXT 
TXT 
TXT 
TXT 
TXT 
TXT 
TXT 
TXT 
TXT 
TXT 
TXT 
TXT 
TXT 
TXT 
TXT 
TXT 
END                            15741SC103 020181084
./       ADD   NAME=OFOX0F
ESD      
TXT 
TXT 
TXT 
TXT 
TXT 
TXT 
TXT 
TXT 
TXT 
TXT 
TXT 
TXT 
TXT 
TXT 
TXT 
TXT 
TXT 
TXT 
TXT 
TXT 
TXT 
TXT 
TXT 
END 
./       ADD   NAME=RSYMRCD
RRCDL    DS    H                        RECORD LENGTH
         SPACE
RFLGA    DSW   RPSOP,                        PSEUDO OP                 ,
               ,                             NOT USED                  ,
               ,                             NOT USED                  ,
               ,                             NOT USED                  ,
               ,                             NOT USED                  ,
               ,                             NOT USED                  ,
               ,                             NOT USED                  ,
                                             NOT USED
         SPACE
RFLGB    DSW   ,,                                                      ,
               ,                             NOT USED                  ,
               ENTRYSW1,                     ENTRY ITEM PENDING        ,
               ESDNRSW1,                                               ,
               CSECTSW1,                                               ,
               DSECTSW1,                                               ,
               DSCOMSW1
         SPACE
RTYPE    DBV   ,                        RECORD TYPE.  (SEE 'JTEXT')
         SPACE
RFLDI    DSW   ESDOFLO,                                                ,
               DEFINED,                      SYMBOL DEFINED, NO ERROR  ,
               PRIORDEF,                     PREVIOUSLY DEFINED SYMBOL ,
               RFIELDN,                      NAME FIELD APPENDED       ,
               RFIELDX,                      FIELD 'A' OR 'B' APPENDED ,
               ,,                            LENGTH OF NAME MINUS ONE
         SPACE
RSWTS    DSW   ,DSW1,CSW1,,ESW1                                 OX00106
         ORG   RSWTS
RESDI    DS    H                        ESDID ASSOCIATED WITH VALUE
RLCTR    DS    F                        VALUE
RLNGA    DS    0X
RFLDA    EQU   RLNGA+1
RNAME    DS    CL8                      SYMBOL
RLNGQ    DS    H                        SYMBOL LENGTH ATTRIBUTE
RLNGB    DS    0X
RFLDB    EQU   RLNGB+1
         ORG   ,
RLAST    EQU   *
         ORG   RRCDL
RITEM    DS    XL(RLAST-RRCDL)
         ORG   RNAME
RSYMC1   DS    0XL(L'RNAME+L'RLNGQ)     COMMON SEGMENT
         ORG   RESDI
RSYMC2   DS    0XL(L'RESDI+L'RLCTR)     COMMON SEGMENT
RESDC    DS    0XL(L'RESDI+L'RLCTR)     COMMON SEGMENT
./       ADD   NAME=SET
         MACRO
&NAME    SET   &SW,&OP
         GBLA  &INDEX
         GBLC  &DEFNAME(255),&SWNAME(255)
         LCLA  &I,&J,&K,&II
         LCLC  &DEF,&P(8)
.*       SET A SPECIFIED BIT ON OR OFF.
         AIF   (K'&SW EQ 0).ERR1
         AIF   (N'&SW LT 1 OR N'&SW GT 8).ERR1
.LOOP1   ANOP
&I       SETA  &I+1
         AIF   (&I GT &INDEX).DBV1
         AIF   ('&SW(1)' NE '&SWNAME(&I)').LOOP1
         AIF   (K'&OP EQ 0).ERR1
&DEF     SETC  '&DEFNAME(&I)'
&I       SETA  &I-7
&J       SETA  &I+14
         AIF   (&I GE 1).OKI
&I       SETA  1
.OKI     AIF   (&J LE &INDEX).OKJ
&J       SETA  &INDEX
.OKJ     ANOP
&II      SETA  &I
&K       SETA  1
.LOOP2   ANOP
&K       SETA  &K+1
         AIF   (&K GT N'&SW).DONE1
.LOOP3   AIF   ('&SW(&K)' EQ '&SWNAME(&I)').MATCH1
&I       SETA  &I+1
         AIF   (&I LE &J).LOOP3
         AGO   .ERR2
.MATCH1  AIF   ('&DEF' NE '&DEFNAME(&I)').ERR2
&P(&K)   SETC  '+'
&I       SETA  &II
         AGO   .LOOP2
.DONE1   AIF   ('&OP' NE 'ON').TRYOFF
&NAME    OI    &DEF,&SW(1)&P(2)&SW(2)&P(3)&SW(3)&P(4)&SW(4)&P(5)&SW(5)&X
               P(6)&SW(6)&P(7)&SW(7)&P(8)&SW(8)
         AGO   .EXIT
.TRYOFF  AIF   ('&OP' NE 'OFF').TRYFLIP
&NAME    NI    &DEF,BITFF-(&SW(1)&P(2)&SW(2)&P(3)&SW(3)&P(4)&SW(4)&P(5)X
               &SW(5)&P(6)&SW(6)&P(7)&SW(7)&P(8)&SW(8))
         AGO   .EXIT
.TRYFLIP AIF   ('&OP' NE 'FLIP').ERR1
&NAME    XI    &DEF,&SW(1)&P(2)&SW(2)&P(3)&SW(3)&P(4)&SW(4)&P(5)&SW(5)&X
               P(6)&SW(6)&P(7)&SW(7)&P(8)&SW(8)
         AGO   .EXIT
.DBV1    AIF   (N'&SW NE 1).ERR1
         AIF   (K'&SW GT 7).ERR1
         AIF   (K'&OP EQ 0).DVB2
&NAME    MVI   V&SW,&OP
         AGO   .EXIT
.DVB2    ANOP
&NAME    MVI   V&SW,&SW
.EXIT    MEXIT
.ERR1    MNOTE 8,'PARAMETER ERROR.'
         MEXIT
.ERR2    MNOTE 8,'SWITCH NOT PREVIOUSLY DEFINED OR NOT IN SAME BYTE.'
         MEND
./       ADD   NAME=XDICT
         MACRO
&ID      XDICT &DUMMY,&TESTRAN=NO,&DIAG=NO,&LEVEL=1
         GBLB  &MACREF                                            .PRC.
         GBLC  &COMPNM                  COMPONENT NAME
         LCLC  &NM                      MODULE NAME
&MACREF  SETB  1       1 = WITH MODS,    0 = WITHOUT MODS         .PRC.
         JHEAD 'EXTERNAL SYMBOL DICTIONARY SUBROUTINES',               ,
               PHASEID=&ID,LEVEL=&LEVEL
&NM      SETC  '&COMPNM&ID'
*                                                                     *
*TITLE-  EXTERNAL SYMBOL DICTIONARY ROUTINES                          *
*                                                                     *
*FUNCTION/OPERATION-                                                  *
*        BUILD AND MAINTAIN THE EXTERNAL SYMBOL DICTIONARY            *
*        PRINT AND PUNCH THE EXTERNAL SYMBOL DICTIONARY               *
*        BUILD THE EXTERNAL SYMBOL DICTIONARY ADJUSTMENT TABLE        *
*                                                                     *
*ENTRY POINT-                                                         *
         ENTRY &NM.01
*                                                                     *
*INPUT-                                                               *
*        REGISTERS-                                                   *
*             R4-       REGISTER CONTAINING THE ADDRESS OF THE        *
*                       RECORD BEING PROCESSED                        *
*             R5-       REGISTER CONTAINING THE ADDRESS OF THE        *
*                       OPERAND BEING PROCESSED                       *
*             R6-       REGISTER CONTAINING THE ADDRESS OF THE        *
*                       CURRENT CONTROL SECTION ESD ENTRY             *
*                                                                     *
*OUTPUT-                                                              *
*        REGISTERS-                                                   *
*             R10       REGISTER CONTAINING THE ADDRESS OF THE        *
*                       NEW CURRENT CONTROL SECTION ESD ENTRY, IF     *
*                       CHANGED                                       *
*                                                                     *
*EXITS, NORMAL-                                                       *
*        EXITS TO THE CALLING ROUTINE                                 *
*                                                                     *
*EXITS, ERROR-                                                        *
*        EXITS TO THE CALLING ROUTINE                                 *
*                                                                     *
*TABLES/WORK AREAS-                                                   *
*        ESDBLK1-  A BLOCK IN STORAGE TO CONTAIN A MAXMI              *
*        ESDBLK1-  A BLOCK OF STORAGE TO CONTAIN A MAXIMUM OF 16 ESD  *
*                  ENTRIES, ALSO SERVES AS AN INPUT/OUTPUT BUFFER     *
*                  FOR THE OVERFLOW FILE (FILE2) WHEN NECESSARY       *
*        ESDBLK2-  SAME FUNCTION AS ESDBLK1 ABOVE                     *
*        NOTELIST- A LIST OF NOTE PARAMETERS OF OVERFLOWED ESD BLOCKS *
*                  WHEN NOT IN CORE                                   *
*                                                                     *
*ATTRIBUTES-                                                          *
*        REFRESHABLE                                                  *
*                                                                     *
*NOTES                                                                *
*                                                                     *
         EJECT
         COPY  JCOMMON
         EJECT
         COPY  JTEXT
         EJECT
         COPY  ICOMMON
         EJECT
JTEXT    DSECT ,
         ORG   JTEXT
         COPY  RSYMRCD
         EJECT
&NM.00   CSECT
* VS1 REL 2.6 CHANGES
*C221000                                                        OX00106
*A246500,430500,481500                                          OX00106
         JMODID
&NM.01   CONTENTS
         USING &NM.01,R8                BASE REGISTER
         EJECT
*TITLE-  BLDESD                                                       *
*                                                                     *
*FUNCTION/OPERATION-                                                  *
*        BUILD OR RESUME AN ESD ENTRY                                 *
*                                                                     *
*INPUT-  R4 CONTAINS A POINTER TO THE RECORD BEING PROCESSED          *
*        R10 CONTAINS A POINTER TO A PARAMETER LIST                   *
*                                                                     *
*OUTPUT- R10 CONTAINS A POINTER TO THE ESD ENTRY                      *
*                                                                     *
         SPACE
BLDESD   BALR  R14,R7                   SAVE REGISTERS IN STACK
         LR    R8,R12                   SET UP BASE REGISTER
         LA    R2,D1                    INCREMENT IN
         LR    R3,R2                    TWO REGISTER
         LR    R5,R10                   SAVE POINTER
         AH    R2,D0(,R5)               ESDID
         AH    R3,HIESDNR               ESD NUMBER
         STH   R2,XESDI                 ESDID
         STH   R3,XLNGQ                 ESD NUMBER
         MVC   XFLGB,XPARM              FLAGS
         SR    R0,R0                    ZERO
         ST    R0,XLCTR                 INITIAL VALUE
         OC    XESDI(D1),XPARM+D3       FLAG FOR DSECT OR COM
BLDESD1  MVC   XTYPE,XPARM+D1           TYPE
         MVC   XNAME,=8AL1(JBLANK)      PAD
         MVC   XNAME(D1),XTYPE          NAME
         GOIF  RFIELDN,OFF=BLDESD2      SKIP IF NO NAME
         MVC   RLNGQ,=H'1'              LENGTH ATTRIBUTE
         GOIF  PRIORDEF,ON=BLDESD2      SKIP IF PREVIOUSLY DEFINED
         MVC   XNAME,RNAME              GET NAME
         MVC   XTYPE,XPARM+D2           TYPE
BLDESD2  LA    R10,XWORK                PASS RECORD POINTER
         GOTO  ENTER                    TRY TO ENTER IN SYMBOL TABLE
         BNE   BLDESD5                  ALREADY IN SYMBOL TABLE
         STH   R2,D0(,R5)               SAVE ESDID
         STH   R3,HIESDNR               SAVE ESD NUMBER
         TM    XESDI,CSW2+DSW2          COM OR DSECT
         BNE   BLDESD4                  SKIP IF SO
         NC    FSTCSECT,FSTCSECT        SEE IF FIRST CSECT
         BNE   BLDESD3                  SKIP IF NOT
         STH   R3,FSTCSECT              FIRST CSECT ESD NUMBER
BLDESD3  CLI   XTYPE,ETYPEPC            PRIVATE CODE
         BNE   BLDESD4                  SKIP IF NOT
         STH   R2,JESDID                ESDID OF PRIVATE CODE
BLDESD4  LR    R10,R3                   ESD NUMBER
         GOTO  GETESD                   GET ESD ENTRY
         LM    R2,R3,XTYPE              TYPE, ESDID, ADDRESS
         SR    R4,R4                    INITIALIZE
         LM    R5,R6,XNAME              NAME
         STM   R2,R6,ETYPE-ETYPE(R10)   CREATE ESD ENTRY
         B     EXIT                     EXIT
BLDESD5  CLC   SFLGS,XFLGB              SEE IF SAME TYPE SECTION
         BE    BLDESD6                  RESUME SECTION IF SAME
         NI    XPARM,BITFF-(XDUMMY)     DISCOUNT EXTERNAL DUMMYS
         CLC   SFLGS,XPARM              GIVE IT ANOTHER CHANCE
         BE    BLDESD6                  LET THIS ONE GO
         SET   PRIORDEF,ON              INDICATE PREVIOUSLY DEFINED
         B     BLDESD1                  IGNORE NAME
BLDESD6  LH    R10,SLNGQ                ESD ASCENDSION NUMBER
         GOTO  GETESD                   RESUME ESD ENTRY
         SET   DEFINED,ON               INDICATE RESUMED SECTION
         B     EXIT                     EXIT
         EJECT
*TITLE-  GETESD                                                       *
*                                                                     *
*FUNCTION/OPERATION-                                                  *
*        GET AN ESD ENTRY                                             *
*                                                                     *
*INPUT-  R10 CONTAINS THE ESD NUMBER                                  *
*                                                                     *
*OUTPUT- R10 CONTAINS A POINTER TO THE ENTRY                          *
*                                                                     *
         SPACE
GETESD   BALR  R14,R7                   SAVE REGISTER IN STACK
         LR    R8,R12                   SET UP BASE REGISTER
         LR    R2,R10                   INTO WORK REGISTER
         LA    R10,D16*D25              MAXIMUM ESD ENTRIES
         CR    R10,R2                   SEE IF EXCEEDED
         BNL   GETESD0                  NOPE
         BAL   R9,GETESD                RECURSIVE CALL
         SET   JESDOFLO,ON              INDICATE ESD OVERFLOW
         MVI   D0(R10),D3               OVERFLOW ENTRY
         XC    D1(D19,R10),D1(R10)      INITIALIZE
         B     EXIT                     RETURN
GETESD0  BCTR  R2,D0                    ESD NUMBER
         SRDL  R2,D4                    BLOCK NUMBER
         LR    R4,R2                    NOTE/POINT ADDRESS FOR BLOCK
         MH    R4,=H'9'                 X
         LA    R4,NOTELIST(R4)          X
         SRL   R3,D28                   DISPLACEMENT
         MH    R3,=H'20'                DISPLACEMENT
         TM    D8(R4),BIT7              SEE IF THIS A NEW BLOCK
         BO    GETESD4                  NO
         TM    FILELAST+D8,BIT7         SEE IF FLIE POSITIONED TO WRITE
         BZ    GETESD1                  YES
         JPOINT  FILE=FILE2,ADDR=FILELAST,NEXT=WRITE   POSITION FILE
GETESD1  LA    R5,ESDBLK2               POINT TO SECOND BLOCK
         CR    R5,R6                    SEE IF BLOCK CURRENTLY IN USE
         BH    GETESD2                  NO
         LA    R5,ESDBLK1               POINT TO FIRST BLOCK
GETESD2  JWRITE  FILE=FILE2,PARM=(R5)   WRITE DESIGNATED BLOCK
         MVI   FILELAST+D8,D0           INDICATE FILE POSITIONED TO END
         JCHECK  FILE=FILE2             CHECK WRITE OPERATION
         JNOTE   FILE=FILE2             NOTE ADDRESS OF BLOCK ON FILE
         LH    R1,D6(,R5)               BLOCK NUMBER OF BLOCK WRITTEN
         MH    R1,=H'9'                 NOTE/POINT ADDRESS FOR BLOCK
         LA    R1,NOTELIST(R1)          X
         MVI   D8(R1),BIT6              INDICATE BLOCK ON FILE
         MVC   D0(D8,R1),JNOTEVAL       SAVE BLOCK NOTE/POINT ADDRESS
         MVC   FILELAST(D8),JNOTEVAL    NOTE/POINT ADDRESS OF FILE END
         TM    D8(R4),BIT6              SEE IF BLOCK ON FILE
         BZ    GETESD3                  NOPE
         JPOINT  FILE=FILE2,ADDR=(R4),NEXT=READ   POINT TO BLOCK
         JREAD   FILE=FILE2,PARM=(R5)   BRING IN BLOCK
         MVI   FILELAST+D8,BIT7         INDICATE FILE NOT POSITIONED
         JCHECK  FILE=FILE2             CHECK READ OPERATION
GETESD3  ST    R5,JFWORD1               ADDRESS OF BLOCK
         MVI   D8(R4),BIT7              INDICATE BLOCK IS IN CORE
         MVC   D0(D4,R4),JFWORD1        SAVE ADDRESS OF BLOCK IN CORE
GETESD4  MVC   JFWORD1,D0(R4)           ADDRESS TO FULLWORD BOUNDARY
         L     R5,JFWORD1               ADDRESS OF BLOCK IN CORE
         STH   R2,D6(,R5)               BLOCK NUMBER
         LA    R10,D8(R3,R5)            POINT TO ENTRY REQUESTED
         B     EXIT                     RETURN
         EJECT
*TITLE-  MAKESD                                                       *
*                                                                     *
*FUNCTION/OPERATION-                                                  *
*        CREATE THE ESD ADJUSTMENT TABLE                              *
*        ESD FINISHING AND OUTPUT                                     *
*                                                                     *
*INPUT-  THE EXTERNAL SYMBOL DICTIONARY (ESD).                        *
*                                                                     *
*OUTPUT- THE ESD ADJUSTMENT TABLE.                                    *
*        THE EXTERNAL SYMBOL DICTIONARY ON THE SYSTEM OUTPUT FILES.   *
*                                                                     *
         SPACE
ENTRY    BALR  R14,R7                  SAVE REGISTERS IN STACK
         LR    R8,R12                  SET UP BASE REGISTER
         LR    R10,R4                  PASS RECORD POINTER
         MVI   RFLGB,ESDNRSW+ENTRYSW    SET FLAGS
         GOTO  FIND                     LOOKUP IN SYMBOL TABLE
         BZ    ENTRY2                   ERROR
         GOIF  (MODE1,MODE2),ANY=EXIT   SUSPEND ACTION IF NOT MODE IA
         GOTO  ENTER                    ENTER IN SYMBOL TABLE
         LH    R10,HIESDNR              GET HIGHEST ESD NUMBER
         LA    R10,D1(,R10)             GET NEXT ESD NUMBER
         STH   R10,HIESDNR              SAVE
         STH   R10,SLNGQ                ESD ASCENDSION NUMBER
         GOTO  GETESD                   FIND ROOM IN ESD
         MVI   ETYPE-EITEM(R10),ETYPELX PRIME ESD ENTRY
ENTRY1   MVI   RTYPE,JTSYMBL            CHECK BACK IN PASS 2
         B     EXIT                     FINIS
ENTRY2   GOIF  (ESDNRSW,XENTRY,CSECTSW,DSECTSW),ALL=ENTRY1,MIX=ENTRY3
         GOIF  (CSW,DSW,ESW),ANY=ENTRY3 INVALID                 OX00106
         SR    R0,R0                    SEE IF
         CH    R0,SESDI                 ABSOLUTE
         BZ    ENTRY3                   BAD
         SET   XENTRY,ON                INDICATE VALID ENTRY
         OI    RFLGB,XENTRY             INDICATE VALID ENTRY
         MVC   RESDI(D6),SESDI          ESDID AND ADDRESS
         LH    R10,HIESDNR              GET HIGHERS ESD NUMBER
         LA    R10,D1(,R10)             GET NEXT ESD NUMBER
         STH   R10,HIESDNR              SAVE
         GOTO  GETESD                   GET ESD ENTRY
         MVI   ETYPE-EITEM(R10),ETYPELD ESD ENTRY TYPE
         MVC   EESDI-EITEM(D6,R10),RESDI     ESDID AND VALUE
         MVC   ENAME-EITEM(D8,R10),RNAME     NAME
         MVI   RTYPE,JTADJII            ADJUST VALUE IN IIA
         B     EXIT                     FINIS
ENTRY3   MVI   RTYPE,JTPASS             INVALID ENTRY
         B     EXIT                     FINIS
EXTRN    BALR  R14,R7                   SAVE REGISTERS IN STACK
         LR    R8,R12                   SET UP BASE REGISTER
         LA    R2,D1                    INCREMENT
         LR    R3,R2                    IN TWO REGISTERS
         STH   R2,RLNGQ                 LENGTH ATTRIBUTE OF SYMBOL
         AH    R2,HICESDID              NEXT ESDID
         AH    R3,HIESDNR               NEXT ESD NUMBER
EXTRN1   STH   R2,RESDI                 ESDID
         SET   ESW1,ON                  SET EXTRN/EQU FLAG      OX00106
EXTRN2   XI    RNAME,BIT0               UNIQUE NAME
         LR    R10,R4                   PASS RECORD POINTER
         GOTO  ENTER                    ENTER INTO SYMBOL TABLE
         BNE   EXTRN5                   ALREADY IN SYMBOL TABLE
         TM    RNAME,BIT0               SEE IF FIRST TIME AROUND
         BNE   EXTRN2                   ENTER SECOND TIME IF FIRST
         CH    R3,HIESDNR               SEE IF NEW ENTRY
         BNH   EXTRN3                   SKIP IF NOT NEW
         STH   R2,HICESDID              SAVE NEW ESDID
         STH   R3,HIESDNR               SAVE NEW0ESD NUMBER
EXTRN3   LR    R10,R3                   PASS ESD NUMBER
         GOTO  GETESD                   GET ESD ENTRY
         MVC   ETYPE-EITEM(D8,R10),RTYPE
         MVC   ENAME-EITEM(D8,R10),RNAME
EXTRN4   MVI   RTYPE,JTPASS             NO PROCESS RECORD IN PASS 2
         B     EXIT
EXTRN5   LH    R2,SESDI                 GET ESDID OF PREVIOUS ENTRY
         LH    R3,SLNGQ                 GET ESD ASCENDSION NUMBER
         TM    RNAME,BIT0               SEE IF FIRST TIME AROUND
         BNE   EXTRN1                   GO AGAIN IF FIRST
         SET   PRIORDEF,ON              INDICATE PREVIOUSLY DEFINED
         B     EXTRN4                   EXIT
VCON     BALR  R14,R7                   SAVE REGISTERS IN STACK
         LR    R8,R12                   SET UP BASE REGISTER
         LR    R3,R2                    IN TWO REGISTERS
         AH    R2,HICESDID              GET NEXT ESDID
         AH    R3,HIESDNR               GET NEXT ESD NUMBER
         STH   R2,XESDI                 ESDID
         STH   R3,XLNGQ                 ESD NUMBER
         MVI   XTYPE,ETYPEER            TYPE
         MVI   XFLGB,ESDNRSW            FLAGS
         OI    XNAME,BIT0               EXTERNAL NAME
         SR    R0,R0                    ZERO
         STH   R0,XLCTR                 VALUE
         LA    R10,XWORK                POINTER TO ENTRY
         GOTO  ENTER                    ENTER IN SYMBOL TABLE
         BNZ   EXIT                     ALREADY IN SYMBOL TABLE
         STH   R2,HICESDID              SAVE ESDID
         STH   R3,HIESDNR               SAVE ESD NUMBER
         XI    XNAME,BIT0               RESET
         LR    R10,R3                   GET ESD NUMBER
         GOTO  GETESD                   GET ESD ENTRY
         MVC   ETYPE-EITEM(D8,R10),XTYPE     TYPE, FLAGS, ESDID, VALUE
         MVC   ENAME-EITEM(D8,R10),XNAME     NAME
         B     EXIT                     RETURN
QCON     BALR  R14,R7                   SAVE REGISTERS IN STACK
         LR    R8,R12                   SET UP BASE REGISTER
         LA    R10,XWORK                PASS POINTER TO WORK AREA
         GOTO  FIND                     LOOKUP IN SYMBOL TABLE
         BNE   EXIT                     NOT IN SYMBOL TABLE
         GOIF  (ESDNRSW,DSECTSW,DSCOMSW,XDUMMY),NOTALL=EXIT VALID NAME
         SET   XDUMMY,OFF               ONE TIME ONLY PER DSECT NAME
         LR    R10,R2                   INCREMENT IN TWO REGISTERS
         AH    R2,HICESDID              NEXT ESDID
         STH   R2,HICESDID              SAVE ESDID
         LH    R3,SLNGQ                 ESD ASCENDSION NUMBER
         AH    R10,HIESDNR              NEXT ESD NUMBER
         STH   R10,HIESDNR              SAVE ESD NUMBER
         GOTO  GETESD                   GET ESD ENTRY
         MVC   ENAME-EITEM(D8,R10),XNAME     NAME
         STH   R2,EESDI-EITEM(,R10)     ESDID
         OI    ESWTS-EITEM(R10),QDSW2   INDICATE XD ENTRY
         STH   R3,EHILC-EITEM(,R10)     ESD ASCENDSION NUMBER
         MVI   ETYPE-EITEM(R10),ETYPEDX TYPE
         B     EXIT                     EXIT
SUMESD   BALR  R14,R7                   PUSH DOWN ONE MORE LEVEL
SUMGET   LR    R10,R4                   PASS
         BAL   R2,GOTESD                GET ESD ITEM
         SR    R2,R2                    ZERO FUNCTION BYTE REGISTER
         TRT   ETYPE,SUMTBL             GET ROUTINE ADDRESS
         B     SUMGET(R2)               GO TO ROUTINE
SUMCST   LM    R14,R15,ELCTR            GET CURRENT AND HIGH ADDRESS
         CR    R14,R15                  SEE IF CURRENT IS ALSO HIGH
         BNH   SUMCST1                  SKIP IF NOT
         LR    R15,R14                  SAVE HIGH
SUMCST1  SR    R14,R14                  ASSUME NO OFFSET
         GOIF  (CSW2,DSW2),ANY=SUMCST3  NO OFFSET FOR DSECTS OR COMS
         L     R14,STARTLOC             GET START ADDRESS
         NR    R14,R5                   ROUND TO SECTION ALIGNMENT
         LA    R0,D7                    INCREMENT
         AR    R0,R14                   COMPUTE NEXT START ADDRESS
         AR    R0,R15                   COMPUTE NEXT START ADDRESS
         ST    R0,STARTLOC              SAVE
         LTR   R14,R14                  SEE IF ADJUSTMENT REQUIRED
         BZ    SUMCST3                  NOPE
         ST    R14,D4(,R4)              ADJUSTMENT FACTOR
         MVC   D0(D2,R4),EESDI          ARGUMENT ESDID
SUMCST2  MVC   D2(D2,R4),EESDI          TARGET ESDID
         SR    R4,R5                    POINT TO NEXT ADJUSTMENT ENTRY
SUMCST3  STM   R14,R15,ELCTR            ADDRESS AND LENGTH
         B     SUMGET                   CONTINUE WITH NEXT ENTRY
SUMDXD   LM    R15,R0,ELCTR             GET LENGTH AND ALIGNMENT FACTOR
         LR    R14,R0                   REORDER
         B     SUMCST3                  SKIP
SUMDSD   MVI   ETYPE,ETYPEXD            CHANGE TYPE
         LH    R10,EHILC                GET ESD ASCENDSION NUMBER
         GOTO  GETESD                   GET ESD ENTRY
         LA    R14,D7                   ALIGNMENT FACTOR
         L     R15,EHILC-EITEM(,R10)    LENGTH
         XC    D4(D4,R4),D4(R4)
         MVC   D0(D2,R4),EESDI-EITEM(R10)
         B     SUMCST2
GOTESD   LA    R3,D1(,R3)               GET NEXT ESD NUMBER
         CH    R3,HIESDNR               SEE IF ALL THROUGH
         BH    EXIT                     FINIS
         LR    R10,R3                   PASS ESD NUMBER
         GOTO  GETESD                   GET ESD ENTRY
         LR    R6,R10                   RETURN POINTER
         BR    R2                       RETURN
         AIF   (NOT &MACREF).MACREF1
GOTESD2  LA    R3,D1(,R3)               GET NEXT ESD NUMBER
         CH    R3,HIESDNR               SEE IF ALL THROUGH
         BH    @MACREF                  FINIS
         LR    R10,R3                   PASS ESD NUMBER
         GOTO  GETESD                   GET ESD ENTRY
         LR    R6,R10                   RETURN POINTER
         BR    R2                       RETURN
.MACREF1 ANOP
MAKESD   BALR  R14,R7                   SAVE REGISTERS IN STACK
         LR    R8,R12                   SET UP BASE REGISTER
         L     R4,LATEND                ESD ADJUSTMENT TABLE POINTER
         LH    R5,=H'-8'                INCREMENT
         MVI   CARDADDR+D3,48           FLUSH CARD PUNCH BUFFER
         SR    R3,R3                    ESD NUMBER INITIALIZED
         BAL   R9,SUMESD                SUM CONTROL SECTIONS
         S     R10,LATEND               LENGTH OF ESD ADJUSTMENT TABLE
         LR    R11,R5                   INCREMENT
         STM   R10,R11,ADJINDEX         SAVE FOR PASS TWO
         AIF   (NOT &MACREF).MACREF2
MAKGET   BAL   R2,GOTESD2               GET NEXT SEQUENTIAL ESD
         AGO   .MACREF3
.MACREF2 ANOP
MAKGET   BAL   R2,GOTESD                GET NEXT SEQUENTIAL ESD ENTRY
.MACREF3 ANOP
         SR    R2,R2                    ZERO FUNCTION BYTE REGISTER
         LR    R10,R2                   CLEAR REGISTER
         TRT   ETYPE,MAKTBL             GET ROUTINE ADDRESS
         B     MAKGET(R2)               GO TO ROUTINE
MAKCST   SET   (QDSW2,DSW2,CSW2),OFF    RESET XD DSECT OR COM BITS
         CLI   ENAME,J9                 SEE IF NAMED
         BH    PRTESD                   SKIP IF NAMED
MAKPVT   MVI   ENAME,JBLANK             FAKE THE BLANK
         B     PRTESD                   PRINT ESD ITEM
MAKTRY   LM    R14,R1,ADJINDEX          ESD ADJUSTMENT INDEX
         LH    R10,EESDI                GET ESDID
MAKTRY1  BXLE  R14,R15,PRTESD           SEE IF ADJUSTMENT REQUIRED
         CH    R10,D0(R1,R14)           SEE IF THIS IS THE ENTRY
         BNE   MAKTRY1                  NO, KEEP LOOKING
         L     R10,D4(R1,R14)           GET ADJUSTMENT FACTOR
         A     R10,ELCTR                ADD OFFSET
MAKEXT   ST    R10,ELCTR                SAVE
         EJECT
*TITLE-  PRTESD                                                       *
*                                                                     *
*FUNCTION/OPERATION-                                                  *
*        PRINT AN ITEM IN THE EXTERNAL SYMBOL DICTIONARY              *
*                                                                     *
*INPUT-  REGISTER R10 IS A POINTER TO AN ESD ENTRY                    *
*                                                                     *
*OUTPUT- THE EXTERNAL SYMBOL DICTIONARY                               *
*                                                                     *
         SPACE
PRTESD   EQU   *
         GOIF  (JESD,JLIST),NOTALL=PCHESD    SKIP IF NOT OPTIONED
         LH    R5,LINECNT               GET LINE COUNT
         GOIF  (R5),POS=PRTESD2         SKIP IF NOT END OF PAGE
         JPRINT                         GET PRINT BUFFER
         SET   EJECT                    CARRIAGE CONTROL FOR TITLE LINE
         MVC   DECKID,JDECKID           DECK IDENTIFIER
         MVC   TITLE,ZTITLE             SET TITLE
         MVC   PAGE,ZPAGEZ              SET PAGE NUMBER DESIGNATOR
         LH    R14,JPAGENO              GET OLD PAGE NUMBER
         LA    R14,1(,R14)              INCREMENT BY 1
         STH   R14,JPAGENO              SAVE PAGE NUMBER
         CVD   R14,JDWORD               CONVERT PAGE NUMBER TO DECIMAL
         UNPK  PAGENO,JDWORD+6(2)       UNPACK TO EBCDIC CODE
         NC    PAGENO,DIGMASK           CONVERT TO INTERNAL CHARACTERS
         GOIF  PAGENO,J0,NOTEQ=PRTESD1  SKIP IF NOT A LEADING ZERO
         MVI   PAGENO,JBLANK            FORCE TO A BLANK
         GOIF  PAGENO+1,J0,NOTEQ=PRTESD1     SKIP IF NOT A LEADING ZERO
         MVI   PAGENO+1,JBLANK          FORCE TO A BLANK
PRTESD1  JPRINT                         GET PRINT BUFFER
         MVC   HEADING,ZHEADING         SET SUBTITLE
         MVC   LVTMDT,JLVTMDT           SET ASSEMBLER LEVEL, TIME, DATE
         LH    R5,JLNCT                 GET MAXIMUM LINE COUNT
PRTESD2  JPRINT                         GET PRINT BUFFER
         SET   SPACE1                   CARRIAGE CONTROL FOR LINE
         CH    R5,JLNCT                 COMPARE TO MAXIMUM LINE COUNT
         BL    PRTESD3                  SKIP IF NOT REACHED
         SET   SPACE2                   CARRIAGE CONTROL FOR FIRST LINE
PRTESD3  BCTR  R5,0                     DECREMENT LINE COUNT
         STH   R5,LINECNT               SAVE LINE COUNT
         MVC   ZSYMBOL,ENAME            SET NAME
         TRT   ETYPE,ZTYPESZ            TRANSLATE FIRST CHARACTER
         STC   R2,ZTYPE                 TO OUTPUT ITEM
         TRT   ETYPE,ZTYPESZ+D7         TRANSLATE SECOND CHARACTER
         STC   R2,ZTYPE+D1              TO OUTPUT ITEM
         UNPK  ZID(L'ZID+1),EESDI(L'EESDI+1) UNPACK WITH ROOM TO SPARE
         NC    ZID,DIGMASK              CONVERT TO INTERNAL CHARACTERS
         MVI   ZID+L'ZID,JBLANK         REPAIR DAMAGE
         NI    ZID+1,BITFF-ESW                                  OX00106
         GOIF  ETYPEER,EQUAL=PCHESD     FINIS FOR EXTERNAL REFERENCE
         GOIF  ETYPEWX,EQUAL=PCHESD     FINIS FOR EXTERNAL REFERENCE
         UNPK  ZADDR(L'ZADDR+1),ELCTR(L'ELCTR+1)  UNPACK WITH EXCESS
         NC    ZADDR,DIGMASK            CONVERT TO INTERNAL CHARACTERS
         MVI   ZADDR+L'ZADDR,JBLANK     REPAIR DAMAGE
         GOIF  ETYPELD,NOTEQ=PRTESD4    SKIP IF NOT LD TYPE
         MVC   ZLDID,ZID                PUT IN PROPER PERSPECTIVE
         MVC   ZID,ZID-1                REPAIR
         B     PCHESD                   FINISHED IF LD TYPE
PRTESD4  UNPK  ZLENGTH(L'ZLENGTH+1),EHILC(L'EHILC+1)   UNPACK
         NC    ZLENGTH,DIGMASK          CONVERT TO INTERNAL CHARACTERS
         MVI   ZLENGTH+L'ZLENGTH,JBLANK REPAIR
         EJECT
*TITLE-  PCHESD                                                       *
*                                                                     *
*FUNCTION/OPERATION-                                                  *
*        PUNCH ONE ITEM IN THE EXTERNAL SYMBOL DICTIONARY.            *
*                                                                     *
*INPUT-  REGISTER R6 IS A POINTER TO ONE ITEM IN THE EXTERNAL SYMBOL  *
*   DICTIONARY.                                                       *
*                                                                     *
*OUTPUT- THE EXTERNAL SYMBOL DICTIONARY ON THE PUNCH AND LINK FILES.  *
*                                                                     *
         SPACE
PCHESD   GOIF  (JDECK,JLINK),NONE=MAKGET     RETURN IF NOT OPTIONED
         LM    R10,R11,CARDADDR         GET ADDRESS OF CARD
         CLI   CARDADDR+D3,48           SEE IF ANOTHER CARD NEEDED
         BL    PCHESD1                  NOT NECESSARILY
         JPUNCH  SEQ=YES                GET ANOTHER CARD BUFFER
         SET   JENDCHK,ON               PUNCH END CARD WHEN TIME COMES
         MVC   CARDID,ZESDZ             CARD IDENTIFIER
         TR    CARDID+D1(71),JTRTABLE   TRANSLATE TO EXTERNAL CODE
         MVI   DATALN,D0                HIGH ORDER BYTE OF FIELD ZEROED
         SR    R10,R10                  NEW CARD BUFFER INDICATION
PCHESD1  LA    R10,NEXTITEM             POINT TO NEXT ENTRY SPACE
         STM   R10,R11,CARDADDR         SAVE ADDRESS OF CARD
         STC   R10,DATALN+1             LENGTH OF DATA
         ALR   R10,R11                  POINTER TO ESD DATA ITEM IN R3
         MVC   ZZSYMBOL,ENAME           SET NAME
         TR    ZZSYMBOL,JTRTABLE        CONVERT TO EXTERNAL CHARACTERS
         MVC   ZZTYPE,ETYPE             SET TYPE
         MVC   ZZADDR,ELCTR+L'ELCTR-L'ZZADDR SET ADDRESS
         GOIF  ETYPEXD,NOTEQ=PCHESD3    SKIP IF NOT XD TYPE
         MVC   ZZADDR(L'ZZADDR+L'ZZALGN),ELCTR    SET ALIGNMENT FACTOR
PCHESD3  GOIF  ETYPELD,NOTEQ=PCHESD4    SKIP IF NOT LD TYPE
         MVC   ZZLENGTH+L'ZZLENGTH-L'EESDI(L'EESDI),EESDI   LDID
         MVI   ZZLENGTH,X'00'           PAD WITH LEADING ZEROS
         B     MAKGET                   FINIS
PCHESD4  TM    FIRSTID,X'F0'            SEE IF ESDID SET
         BZ    PCHESD5                  SKIP IF ALREADY SET
         MVC   FIRSTID,EESDI            SET ESDID OF FIRST NON LD ITEM
         NI    FIRSTID,BITFF-BIT4                               OX00106
PCHESD5  GOIF  ETYPEER,EQUAL=MAKGET     FINIS FOR EXTERNAL REFERENCE
         GOIF  ETYPEWX,EQUAL=MAKGET     FINIS FOR EXTERNAL REFERENCE
         MVC   ZZLENGTH,EHILC+L'EHILC-L'ZZLENGTH  SET LENGTH
         B     MAKGET                   FINIS
         EJECT
REFER    BALR  R14,R7                   SAVE REGISTERS IN STACK
         LR    R8,R12                   SET UP BASE REGISTER
         MVC   XWORK(D12),=AL1(0,24,JPSOP,0,JTSYMBL,0,0,0,0,0,0,0)
         LA    R10,XWORK                SYMBOL POINTER
         GOTO  FIND                     LOOK UP IN SYMBOL TABLE
         BZ    REFER2                   FIND IN SYMBOL TABLE
REFER1   GOIF  MODE2,ON=EXIT            DUMPING LITERALS ON OVERFLOW
         B     REFER4                   UNDEFINED AS YET
REFER2   GOIF  ENTRYSW,ON=REFER1        NOT A DEFINED SYMBOL
         MVC   XTYPE(D2),=AL1(JTADJII,DEFINED+PRIORDEF)
         GOIF  MODE2,OFF=REFER3         SKIP IF NOT OVERFLOW
         MVI   XTYPE,JTSYMII            REHASH IN PASS TWO
REFER3   MVC   XFLGB,SFLGS              SYMBOL FLAGS
         MVC   XESDI(D6),SESDI          ESDID AND VALUE
         LH    R15,SLNGQ                LENGTH ATTRIBUTE
         GOIF  ESDNRSW,OFF=REFER5       EXTERNAL SYMBOL
REFER4   LA    R15,D1                   LENGTH ATTRIBUTE
REFER5   STH   R15,XLNGQ                SET LENGTH ATTRIBUTE
         LR    R11,R10
         LH    R10,JOUTFILE             OUTPUT FILE ADDRESS
         JPUTM FILE=(R10),ADDR=(R11)
         B     EXIT                     FINIS
         EJECT
         AIF   (NOT &MACREF).MACREF4
         COPY  MACREF4E
         COPY  MACREFBL
IFNX4E00 CSECT
         EJECT
.MACREF4 ANOP
*                        CONSTANTS                                    *
         SPACE
OIINST   OI    D0(R15),D0               EXECUTED INSTRUCTION
DIGMASK  JGENIN  'FFFFFF'               DIGIT MASK
ZTYPESZ  JGENIN  'SLEXPCXDDRWCMDXXXX'   TYPES
SUMTBL   DC    AL1(SUMCST-SUMGET)       00 - (SD) CONTROL SECTION
         DC    AL1(SUMGET-SUMGET)       01 - (LD) LABEL DEFINITION
         DC    AL1(SUMGET-SUMGET)       02 - (ER) EXTERNAL REFERENCE
         DC    AL1(SUMGET-SUMGET)       03        OVERFLOW ENTRY
         DC    AL1(SUMCST-SUMGET)       04 - (PC) PRIVATE CODE
         DC    AL1(SUMCST-SUMGET)       05 - (CM) COMMON
         DC    AL1(SUMDXD-SUMGET)       06 - (XD) EXTERNAL DUMMY
         DC    AL1(SUMDSD-SUMGET)       07 -      EXTERNAL DUMMY
         DC    AL1(SUMCST-SUMGET)       08 -      DUMMY CONTROL SECTION
         DC    AL1(SUMGET-SUMGET)       09        UNDEFINED ENTRY
         DC    AL1(SUMGET-SUMGET)       0A - (WX) EXTERNAL REFERENCE
MAKTBL   DC    AL1(PRTESD-MAKGET)       00 - (SD) CONTROL SECTION
         DC    AL1(MAKTRY-MAKGET)       01 - (LD) LABEL DIFINITION
         DC    AL1(MAKEXT-MAKGET)       02 - (ER) EXTERNAL REFERENCE
         DC    AL1(MAKGET-MAKGET)       03        OVERFLOW ENTRY
         DC    AL1(MAKPVT-MAKGET)       04 - (PC) PRIVATE CODE
         DC    AL1(MAKCST-MAKGET)       05 - (CM) COMMON
         DC    AL1(MAKCST-MAKGET)       06 - (XD) EXTERNAL DUMMY
         DC    AL1(MAKGET-MAKGET)       07 -      NOT USED
         DC    AL1(MAKGET-MAKGET)       08 -      DSECT
         DC    AL1(MAKGET-MAKGET)       09 -      UNDEFINED ENTRY
         DC    AL1(MAKEXT-MAKGET)       0A - (WX) EXTERNAL REFERENCE
ZESDZ    DC    B'00000010'              12-9-2 CARD IDENTIFIER
         JGENIN  'ESD'                  ESD CARD IDENTIFIER
ZPAGEZ   JGENIN  'PAGE'                 PAGE NUMBER DESIGNATOR
ZTITLE   JGENIN  'EXTERNAL SYMBOL DICTIONARY'     ESD TITLE
ZHEADING DC    YL1(SPACE3)              CARRIAGE CONTROL CHARACTER
         JGENIN  'SYMBOL   TYPE  ID   ADDR  LENGTH LDID'    SUBTITLE
         EJECT
DSECT10  DSECT  ,
         ORG   DSECT10
         SPACE
ZZSYMBOL DS    C'XXXXXXXX'              NAME, BLANK FOR PC OR BLANK CM
ZZTYPE   DS    C'X'                     TYPE
ZZADDR   DS    C'XXX'                   ADDRESS
ZZALGN   DS    C'X'                     ALIGNMENT FACTOR FOR SC TYPE
ZZLENGTH DS    C'XXX'                   LENGTH
NEXTITEM EQU   *                        NEXT ITEM FOLLOWS IMMEDIATELY
         SPACE
         SPACE
DSECT11  DSECT ,
         ORG   DSECT11
         SPACE
CARD     DS    0CL72
CARDID   DS    C' ESD'                  CARD IDENTIFIER
         DS    C'      '                BLANK
DATALN   DS    H                        NUMBER OF BYTES OF ESD DATA
         DS    C'  '                    BLANK
FIRSTID  DS    H                        ESDID OF FIRST NON LD TYPE ITEM
DATAITEM DS    CL16
         SPACE
         SPACE
         ORG   DSECT11
         SPACE
LINE     DS    0CL121
CTLCHAR  DBV   EJECT(0),SPACE1(1),SPACE2(2),SPACE3(3)  CARRIAGE CONTROL
DECKID   DS    CL8                      DECK IDENTIFIER
         ORG   LINE+48
TITLE    DS    C'EXTERNAL SYMBOL DICTIONARY' ESD TITLE
         ORG   LINE+112
PAGE     DS    C'PAGE'                  PAGE NUMBER DESIGNATOR
         ORG   LINE+118
PAGENO   DS    C'000'                   PAGE NUMBER
         ORG   LINE
HEADING  DS    C'3SYMBOL   TYPE  ID   ADDR  LENGTH LDID'
         ORG   LINE+L'LINE-L'JLVTMDT
LVTMDT   DS    CL(L'JLVTMDT)            ASSEMBLER LEVEL, TIME, DATE
         ORG   LINE+1
ZSYMBOL  DS    C'XXXXXXXX'              NAME, BLANK FOR PC OR BLANK CM
         DS    C'  '                    SPACES
ZTYPE    DS    C'XX'                    ESD ITEM TYPE
         DS    C'  '                    SPACES
ZID      DS    C'XXXX'                  ESD IDENTIFIER, IF NON LD TYPE
         DS    C' '                     SPACE
ZADDR    DS    C'XXXXXX'                ADDRESS, IF TYPE SD, PC, LD
         DS    C' '                     SPACE
ZLENGTH  DS    C'XXXXXX'                LENGTH, IF TYPE SD, PC, CM, SC
         DS    C' '                     SPACE
ZLDID    DS    C'XXXX'                  ESD IDENTIFIER OF SD ENTRY
         MEND
./       ADD   NAME=ZAPIN
*
* THESE ZAPS MODIFY A COPY OF IFOX00 WHICH HAS BEEN COPIED
* AND RENAMED, SO THAT THE MACRO REFERENCE LISTING CAN BE TESTED.
* THE ZAPS CAUSE THIS COPY OF THE ASSEMBLER TO LOAD NEW MODULES
* INSTEAD OF THE REGULAR ASSEMBLER MODULES.
*
 NAME AFOX00 IFOX0A00
 VER 0414 E7F0F4       IFOX04
 REP 0414 E7E7F4          XX4
 VER 043A E7F4F1       IFOX41
 REP 043A E7F4C1          X4A
 VER 0441 E7F4F2       IFOX42
 REP 0441 E7F4C2          X4B
