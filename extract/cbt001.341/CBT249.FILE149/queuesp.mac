//CSYSMASA JOB CSYSMAS,MSGCLASS=A,CLASS=F,COND=(0,NE)
/*ROUTE PRINT WYLBUR
/*JOBPARM LINES=99
//ASM      EXEC ASMHCL, ARM.ASM='NOTERM'
//  PARM.ASM='NOTERM,SYSPARM((GEN,DATA,DOC,LIST))'
//ASM.SYSLIB DD DISP=SHR,UNIT=3350,VOL=SER=MVSTST,DSN=SYS1.SMPMTS
//           DD DISP=SHR,UNIT=3350,VOL=SER=MVSTST,DSN=SYS1.MACLIB
//           DD DISP=SHR,UNIT=3350,VOL=SER=MVSTST,DSN=SYS1.AMODGEN
//           DD DISP=SHR,UNIT=3350,VOL=SER=MVSTST,DSN=SYS1.HASPSRC
//           DD DISP=SHR,UNIT=3350,VOL=SER=MVSTST,DSN=SYS1.ACFMAC
//           DD DISP=SHR,DSN=SYS1.AOACJES
//           DD DISP=SHR,DSN=SYS5.MSSMAC            (OACTMP)
//ASM.SYSIN  DD *
QUEUE    TITLE '--- QUEUE/SP PROLOG --'
***********************************************************************
*                                                                     *
*   THE QUEUE COMMAND WAS WRITTEN FOR YOUR AMUSEMENT AND AMAZEMENT BY *
*     THE INTERGALACTIC MESSIANIC INDIVIDUAL GROUP THERAPY DIVISION   *
*     OF TRW SYSTEMS, 1 SPACE PARK, REDONDO BEACH, CA. 90278          *
*   PLEASE ADDRESS ANY COMMENTS, SUGGESTIONS, COMPLAINTS, OR THREATS  *
*     TO ANDY ZIDE (R3/1040).                                         *
* - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - *
*   MAJOR CHANGES WERE MADE (AND GENERAL OVERHAUL DONE) BY            *
*     LEONARD D. WOREN OF GIBRALTAR INFORMATION SYSTEMS     --JAN80-- *
*   CHANGES INCLUDE:                                                  *
*      1) ELIMINATE SEPARATE LOAD MODULE "QUEUECMN"                   *
*      2) ENHANCED "DD" SUBCOMMAND                                    *
*      3) ENHANCED "FORMAT" SUBCOMMAND                                *
*      4) "XL" SUBCOMMAND REPLACES "XD" COMMAND (ELIMINATES           *
*         MODULE Q22 - XDS) (ELIMINATES MODULE Q22 - XDS)             *
*      5) USE OF MORE PROGRAMMER MACROS                               *
*      6) FIX BUG IN TGET CODE DUE TO TCLEARQ                         *
*      7) USE VTAM MACROS FOR FULLSCREEN SUPPORT (STFSMODE)           *
*      8) LAST, BUT NOT LEAST, MAKE THIS MONSTER ASSEMBLE IN ONE      *
*         PIECE                                                       *
* - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - *
*                                                                     *
*  UR - UCLA/OAC UPDATES/CHANGES - MICHAEL STEIN                      *
*                 - UPDATE FOR JES2/SP3 (NEW CKPT/JQE FORMAT)         *
*                 - OFFSETS FOR JQE'S/JOE'S NOW 3 BYTES               *
*                 - NEW QUEUE INTERNAL STRUCTURE / MACROS             *
*                   (MORE USE OF JES2 MACROS)                         *
*                                                                     *
***********************************************************************
         TITLE '--- QUEUE/SP HASP CONTROL BLOCK GENERATION MACRO --'
*
         MACRO
         $HASPCB &DOC=NO,&LIST=NO
         GBLC &PRINT,&GEN,&DATA
         PUSH PRINT
         PRINT &PRINT
         $KEYS LIST=&LIST
         $TGM  DOC=&DOC
         $TAB  DOC=&DOC
         $PCE  DOC=&DOC
         $BUFFER DOC=&DOC
         $JQE  DOC=&DOC
         $JOE  DOC=&DOC
         $JOT  DOC=&DOC
         $KIT  DOC=&DOC
         $QSE  DOC=&DOC
         $JCT  DOC=&DOC
         $PDDB DOC=&DOC
         $IOT  DOC=&DOC
         $CAT  DOC=&DOC
         $HCT  DOC=&DOC
         POP   PRINT
         MEND
         EJECT ,
         MACRO
&NAME    QSTART  &DUMMY
&NAME    STM   R0,R15,0(R13)      SAVE CALLERS REGS
         LR    R12,R15            LOCAL BASE REGISTER
         USING &NAME,R12
         USING QCOMMON,R11        COMMON AREA BASE
         AL    R13,QCSTACKI       PUSH SAVEAREA STACK
         MEND
*
         MACRO
&NAME    QSTOP
&NAME    SL    R13,QCSTACKI             - SAVE AREA LENGTH
         LM    R2,R14,4*R2(R13)         RESTORE REGS
         LTR   R15,R15                  SET CC ON RETURN CODE
         BR    R14                      RETURN TO CALLER
         MEND
*
         MACRO
&LBL     QCALL &RTN,&R1,&R0,&ERRAD=
         LCLC  &L
&L       SETC  '&LBL'
         AIF   ('&R1' EQ '' OR '&R1' EQ '(R1)').R1OK2
         AIF   ('&R1'(1,1) EQ '(').R1REG
         AIF   ('&R1' EQ '0').R1Z
&L       LA    R1,&R1
         AGO   .R1OK1
.R1Z     ANOP
&L       SR    R1,R1
         AGO   .R1OK1
.R1REG   ANOP
&L       LR    R1,&R1(1)
.R1OK1   ANOP
&L       SETC  ''
.R1OK2   ANOP
         AIF   ('&R0' EQ '' OR '&R0' EQ '(R0)').R0OK2
         AIF   ('&R0'(1,1) EQ '(').R0REG
         AIF   ('&R0' EQ '0').R0Z
&L       LA    R0,&R0
         AGO   .R0OK1
.R0Z     ANOP
&L       SR    R0,R0
         AGO   .R0OK1
.R0REG   ANOP
&L       LR    R0,&R0(1)
.R0OK1   ANOP
&L       SETC  ''
.R0OK2   ANOP
&L       L     R15,=A(&RTN)   @ OF ROUTINE
         BALR  R14,R15
         AIF   ('&ERRAD' EQ '').EXIT
         BNZ   &ERRAD
.EXIT    MEND
*
         MACRO
&NAME    QTILT &MESSAGE,&LENGTH=
         LCLA  &L
&L       SETA  K'&MESSAGE-2
         AIF   ('&LENGTH' EQ '').OK
&L       SETA  &LENGTH
.OK      ANOP
&NAME    LA    R1,=C&MESSAGE
         LA    R0,&L                    LENGTH OF MESSAGE
         L     R15,=A(TILT)             @ TILT ROUTINE
         BR    R15                      TILT, NEVER RETURN
         SPACE 1
         MEND
*
         MACRO
&NFS     ZIC   &REG,&ADDR
&NFS     SR    &REG,&REG
         IC    &REG,&ADDR
         MEND
*
         MACRO
&NFS     $     &TEXT,&LEN
         AIF   ('&LEN' EQ '').L80
&NFS     DC    CL&LEN&TEXT
         MEXIT
.L80     ANOP
&NFS     DC    CL80&TEXT
         MEND
         EJECT ,
QUEUE    START 0
         PRINT OFF
         COPY $HASPGEN
         PRINT ON
        $SYSPARM (OFF,GEN,NODATA,NO,NO)
        $HASPCB DOC=&DOC,LIST=&LIST
         DROP ,                   DROP ALL JES REGS
         TITLE '--- QUEUE/SP --MAINLINE MODULE ---'
*---------------------------------------------------------------------*
*                                                                     *
* CURRENT REGISTER USAGE:                                             *
*  R0  - PARM                                                         *
*  R1  - PARM                                                         *
*  R11 - @ QUEUE COMMON AREA (QCOMMON)                                *
*  R12 - LOCAL PROGRAM BASE                                           *
*  R13 - STACK PTR (@ 72 BYTE SAVE AREA IN STACK)                     *
*  R14 - RETURN ADDRESS                                               *
*  R15 - LINKAGE                                                      *
*                                                                     *
* FUTURE REGISTER USAGE: (TRY TO FREE UP R9 AND R10)                  *
*  R0  - PARM                                                         *
*  R1  - PARM                                                         *
*  R9  - @ QUEUE COMMON AREA                                          *
*  R10 - CURRENT PROGRAM BASE                                         *
*  R11 - @ LOCAL WORK AREA ON STACK                                   *
*  R12 - LOCAL PROGRAM BASE                                           *
*  R13 - STACK PTR (@ 72 BYTE SAVE AREA IN STACK)                     *
*  R14 - RETURN ADDRESS                                               *
*  R15 - LINKAGE                                                      *
*                                                                     *
*---------------------------------------------------------------------*
         SPACE 1
QUEUE    CSECT ,
         USING QUEUE,R15
         B     QUEUE1                   BRANCH AROUND IDENTIFIER
         DC    AL1(23)                  LENGTH OF ID
         DC    CL8'QUEUE'               MODULE IDENTIFIER
         DC    CL8'&SYSDATE'            ASSEMBLY DATE
         DC    CL7' &SYSTIME'           ASSEMBLY TIME
QUEUE1   STM   R14,R12,12(R13)          STANDARD REGISTER SAVE
         LR    R12,R15                  LOAD BASE REG
         DROP  R15
         USING QUEUE,R12
         LR    R2,R1              SAVE ADDR OF CPPL
         L     R11,=A(QCOMMON)          @ COMMON AREA
         USING QCOMMON,R11              ACCESS TO COMMON VECTOR TABLE
         SPACE 1
         L     R5,=A(4096*2)            SAVE AREA STACK SIZE
         GETMAIN R,LV=(R5),SP=1         GET SAVE AREA STACK
         LA    R4,0(,R1)
         LR    R0,R4
         LR    R1,R5
         SR    R15,R15
         MVCL  R0,R14             ZERO STACK
         ST    R13,QCOLDSAV       SAVE @ OF OLD SAVE AREA
         LR    R13,R4             SET @ OF STACK
         ST    R13,QFRSTSA        INIT KLUDGE *******
         SPACE 1
*---        VTAM INITIALIZATION                                    ---*
         STFSMODE  ON,INITIAL=YES
         SPACE 1
*---        JES2 DEPENDENT INITIALIZATION - INIT                   ---*
         QCALL INIT                     INITIALIZE
         LA    R10,LOOP                 INTERRUPTED RETURN ADDRESS
         L     R9,QVDSPL                @ DISPLAY WORK AREA
         USING QDISPLAY,R9
         SPACE 1
*---        READ JES2 CHECKPOINT FILE - CKPT                       ---*
LOOP     QCALL CKPT
         SPACE 1
*---        COMMAND LINE PARSE                                     ---*
         QCALL PARSE
         CLC   =C'E ',QSUBNAME          STOP?
         BE    EXIT                     YES.
         CLC   =C'EXIT ',QSUBNAME       STOP?
         BE    EXIT                     YES.
         CLC   =C'END ',QSUBNAME        STOP?
         BE    EXIT                     YES.
         CLC   =C'STOP ',QSUBNAME       STOP?
         BE    EXIT                     YES.
***********************************************************************
*                                                                     *
*   CALL - SUB-COMMAND MODULE SELECTED BY PARSE                       *
*                                                                     *
***********************************************************************
         MVC   QDHLINE,DUMMY            NO OUTPUT MESSAGE
         L     R15,QSUBCMD              ADDR OF SUBCMD FROM QCOMMON
         BALR  R14,R15                  GO TO IT
         CLC   QDHLINE,DUMMY            WAS ANYTHING WRITTEN?
         BE    NO$DATA                  NO - SKIP
         L     R1,=A(EMPTYDS)           POINT TO EMPTY DS MESSAGE
         CLC   QDHLINE,0(R1)            IS DATASET EMPTY?
         BE    NO$DATA                  YES - SKIP
         QCALL DISPLAY,ENDDATA,80       MOVE TO SCREEN
         SPACE 2
NO$DATA  QCALL DISPLAY,,0               WRITE LAST SCRN, GET NEXT INPUT
         B     LOOP                     DO IT AGAIN
***********************************************************************
*                                                                     *
*   CLEAN UP AND GO HOME                                              *
*                                                                     *
***********************************************************************
EXIT     TPUT  CLEAR,L'CLEAR,FULLSCR,,HOLD    CLEAR THE SCREEN
         SPACE 1
         STFSMODE OFF                   TELL VTAM WE'RE DONE
         SPACE 2
         USING QCKPT,R8                 BASE REG FOR CKPT WORK AREA
         L     R8,QVCKPT                LOAD BASE REG
         CLOSE MF=(E,HOCKPT)
         SPACE 1
         CLOSE MF=(E,QCSPOPNL)
         SPACE 2
         MVI   DAIRFLAG,X'2C'           INDICATE TYPE OF DAIR CALL
         LA    R2,QCSPOPNL              -> TO FIRST DCB ADDRESS
LOOP$2C  L     R1,0(,R2)                GET A DCB ADDRESS
         MVC   DA2CDDN,40(R1)           COPY DDNAME TO DAIR PARM AREA
         QCALL ALLOCATE                 MARK IT "NOT IN USE"
         TM    0(R2),X'80'              WAS THIS THE LAST HASPACE DCB?
         LA    R2,4(,R2)                -> NEXT DCB ADDRESS IN CASE NOT
         BNO   LOOP$2C                  NO - DO NEXT
         L     R1,HOCKPT                -> CKPT DCB
         MVC   DA2CDDN,40(R1)           COPY DDNAME TO DAIR PARM AREA
         QCALL ALLOCATE                 MARK IT "NOT IN USE"
         SPACE 2
*** FREE STACK AREA + OTHER AREAS?
         SPACE 1
         L     R13,QCOLDSAV       RESTORE @ OF OLD SAVE AREA
         LM    R14,R12,12(R13)     AND RESTORE QUEUE CALLERS REGS
         SR    R15,R15            RETURN CODE ZERO
         BR    R14
         SPACE 1
***********************************************************************
*                                                                     *
*   CONSTANTS AND OTHER ODDITIES                                      *
*                                                                     *
***********************************************************************
         LTORG
CLEAR    DC    X'C1115D7E1140403C4040001DC813'  *** SPF TCAM
DUMMY    DC    CL80'    NO DATA IS AVAILABLE FOR YOUR REQUEST'
ENDDATA  DC    X'1DE8'                  HIGH INTENSITY, PROTECTED
         DC    CL76'                            *** END OF DATA ***'
         DC    X'1D60'                  NORMAL INTENSITY, PROTECTED
         SPACE 1
         DROP  R9,R8
         SPACE 1
         PRINT GEN
         SPACE 1
         DROP  ,
    TITLE '--- QUEUE/SP --ALLOCATE -- DATASET ALLOCATION ROUTINES ---'
ALLOCATE QSTART ,
         L     R9,QVDAIR                @ OF DAIR WORK AREA
         USING QDAIR,R9
         SPACE 1
*---            DETERMINE REQUESTED FUNCTION                       ---*
         CLI   DAIRFLAG,X'08'           IS THE FUNCTION ALLOCATE?
         BE    ALLOC                    YES. DO IT.
         CLI   DAIRFLAG,X'18'           IS THE FUNCTION FREE?
         BE    FREE                     YES. DO IT.
         CLI   DAIRFLAG,X'2C'           IS THE FUNCTION SET NOT_IN_USE?
***%%%   BE    UNUSE                    YES. DO IT.
         B     ALC$STOP                 YES. PRETEND LIKE WE DID IT
         B     ABEND99                  INVALID FUNCTION. ABANDON SHIP.
         SPACE 1
*---            FREE DDNAME(XXXXXXXX)                              ---*
FREE     LA    R1,DA18CD                LOAD ADDR OF FREE PARM LIST
         BAL   R2,CALLDAIR              CALL DAIR
         B     ALC$STOP                 RETURN TO CALLER
         SPACE 1
*---       ALLOC DDNAME(XXXXXXXX) DSNAME(YYYYYYYY) SHR             ---*
ALLOC    XC    DA00CD(20),DA00CD        CLEAR THE PARM LIST
         MVC   DA00PDSN,DA08PDSN        COPY THE DSNAME PTR
         LA    R1,DA00CD                POINT TO PARM LIST
         BAL   R2,CALLDAIR              SEE IF IT'S ALLOCATED
         LM    R4,R5,DA08UNIT           SAVE THE UNIT
         TM    DA00FLG,X'02'            DSNAME CURRENTLY ALLOCATED?
*MAS1    BNO   *+16                     NO - USE SUPPLIED VOLSER
         B     *+16                     ALWAYS USE CORRECT VOLSER  MAS1
         MVC   DA08SER,QBLANK           YES - BLANK THE VOLSER
         MVC   DA08UNIT,QBLANK          ...AND THE UNIT
         MVC   DA08DDN,QBLANK           BLANK THE DDNAME AREA
         LA    R1,DA08CD                LOAD ADDR OF ALLOC PARM LIST
         BAL   R2,CALLDAIR              CALL DAIR - ALLOC THE DATASET
         STM   R4,R5,DA08UNIT           RESTORE THE UNIT
         B     ALC$STOP                 RETURN TO CALLER
         SPACE 1
*---         MARK DDNAME "NOT IN USE"                              ---*
UNUSE    LA    R1,DA2CCD                LOAD ADDR OF UNUSE PARM LIST
         BAL   R2,CALLDAIR              CALL DAIR - MARK "NOT IN USE"
         B     ALC$STOP                 RETURN TO CALLER
         SPACE 1
ALC$STOP QSTOP
         SPACE 1
*---         CALL DYNAMIC ALLOCATION INTERFACE ROUTINE (DAIR)      ---*
CALLDAIR ST    R1,DAPLDAPB              SET PARM LIST ADDR IN CALL LIST
         XC    DAIRECB,DAIRECB          CLEAR ECB
         LA    R1,DAPLUPT               LOAD ADDR OF DAIR CALL LIST
         LINK  EP=IKJEFD00              CALL DAIR
         LTR   R15,R15                  IS RETURN CODE ZERO?
         BZR   R2                       YES. RETURN.
         CH    R15,=H'28'               IS DATASET ALREADY FREE?
         BER   R2                       YES. RETURN.
         CLC   =C'SA',QSUBNAME          IS THIS A SAVE?
         BNE   ABEND99                  NO. ABEND.
         QTILT '*** UNABLE TO ALLOCATE DATASET ***'
         SPACE 1
*---        DAIR FAILTURE PROCESSING                               ---*
ABEND99  TPUT  MESSAGE0,L'MESSAGE0      TELL THEM A SAD STORY
         ABEND 99,DUMP                  ABEND THE JOB. USER CODE 0099.
         DROP  R12,R9
         SPACE 1
         LTORG
MESSAGE0 DC    C'A MAJOR DISASTER HAS OCCURRED IN DAIR PROCESSING.'
     TITLE '--- QUEUE/SP --CKPT -- READ JES2 CKPT RECORDS ---'
CKPT     QSTART ,
         L     R10,QVCKPT               @ CKPT WORK AREA
         USING QCKPT,R10
         SPACE 1
*---         REPOSITION AND READ MASTER RECORD                     ---*
         L     R2,QCJQTL                ADDR OF IOAREA CKPT RECS
         POINT HASPCKPT,QCMSTTR         POINT TO MASTER RECORD
         READ  HDECB1,SF,,(R2),'S',MF=E READ MASTER RECORD
         CHECK HDECB1
         SPACE 1
*---         REPOSITION AND READ JQE RECORDS                       ---*
         LA    R2,QCJQTA                @ PARM FOR CKPTRD
         BAL   R8,CKPTRD                READ JQE CKPT RECORDS
         SPACE 1
*---         REPOSITION AND READ JOE RECORDS                       ---*
         LA    R2,QCJOTA                @ PARM FOR CKPTRD
         BAL   R8,CKPTRD                READ JQE CKPT RECORDS
         QSTOP ,
         EJECT ,
*---------------------------------------------------------------------*
*                                                                     *
* CKPTRD - READ CKPT BLOCKS SUBROUTINE                                *
*                                                                     *
*  ENTRY: R2 = @ +0 - @ BUFFER AREA                                   *
*                +4 - TTR OF 1ST BLOCK TO READ IN HASPCKPT            *
*                +8 - NUMBER OF BLOCKS TO READ (EACH 4K)              *
*                                                                     *
*---------------------------------------------------------------------*
         SPACE 1
CKPTRD   POINT HASPCKPT,4(,R2)    POINT TO 1ST BLOCK TO READ
         SPACE 1
         L     R3,0(,R2)          @ 1ST BUFFER
         L     R4,8(,R2)          # OF BLOCKS TO READ
         L     R5,=F'4096'        BLOCK LENGTH
         SPACE 1
CKPTRD1  LR    R6,R4              ASSUME CAN READ ALL BLOCKS AT ONCE
         SR    R0,R0
         IC    R0,DCBNCP-IHADCB+HASPCKPT GET NCP ALLOWED
         CR    R6,R0
         BNH   *+6
         LR    R6,R0              LIMIT READ'S TO NCP MAX
         LR    R2,R6              COPY # OF READ/CHECKS TO DO
         L     R7,QCDECBPT        @ DECB WORK AREA
CKPTRD2  MVC   0(HDECB1L,R7),HDECB1 INIT DECB
         READ  (R7),SF,,(R3),(R5),MF=E START A READ
         AR    R3,R5              BUMP READ BUFFER PTR
         LA    R7,HDECB1L(,R7)    BUMP DECB PTR
         BCT   R2,CKPTRD2
         SPACE 1
         LR    R2,R6              # OF READS JUST ISSUED
         L     R7,QCDECBPT        @ DECB WORK AREA
CKPTRD3  CHECK (R7)
         LA    R7,HDECB1L(,R7)    BUMP DECB PTR
         BCT   R2,CKPTRD3
         SR    R4,R6              DCR # BLOCKS JUST READ/CHECKED
         BNZ   CKPTRD1
         BR    R8                 RETURN IF ALL DONE
         DROP  R10
         SPACE 1
         LTORG ,
    TITLE '--- QUEUE/SP --DDNAME -- LIST DDNMS && DSIDS FOR A JOB ---'
DDNAME   QSTART  Q4
         USING QCKPT,R10                BASE FOR CHECKPOINT WORK AREA
         L     R10,QVCKPT               LOAD BASE REG
         USING QDISPLAY,R9              BASE REG FOR DISPLAY WORK AREA
         L     R9,QVDSPL                LOAD BASE REG
***********************************************************************
*                                                                     *
*   CALL FINDJOB TO LOCATE THE JQE, JCT, AND IOT                      *
*                                                                     *
***********************************************************************
         QCALL FINDJOB                  FIND THE JOB
***********************************************************************
*                                                                     *
*   BUILD TABLE OF DSID'S AND RECORDS COUNTS                  --LDW-- *
*                                                                     *
***********************************************************************
         L     R6,QCSTART               -> TABLE AREA
         MVI   DDN@SW,0                 HAVEN'T READ SPIN IOT YET
         L     R5,QCIOTA                -> IOT
         USING IOTSTART,R5
         MVC   PGMNAME(80),QBLANK       BLANK THE DISPLAY LINE
         SPACE 1
DD$IOTLP LR    R4,R5                    BASE OF IOT
         A     R4,IOTPDDBP              OFFSET BEYOND LAST PDDB
         LR    R2,R5                    BASE OF IOT
         A     R2,QCPDDB1               OFFSET TO FIRST PDDB IN IOT
         USING PDBDSECT,R2
         SPACE 1
DD$PDBLP LH    R1,PDBDSKEY              GET DSID
         LTR   R1,R1                    IS IT 0?
         BZ    NXT$DSID                 YES - IGNORE IT
         TM    PDBFLAG1,PDB1NSOT        NOT FOR SYSOUT?
         BZ    DD$SYOUT                 NO - IT'S FOR SYSOUT
         CH    R1,=H'2'                 IT IS 2 THRU 4?
         BL    DD$SYOUT                 NO - OK
         CH    R1,=H'4'                 IT IS 2 THRU 4?
         BNH   NXT$DSID                 YES - IGNORE IT BECAUSE IT IS
*                                       MARKED "NOT FOR SYSOUT" AND IS
*                                       THE JOBLOG, JOBMSG, OR JCL DS,
*                                       WHICH ARE DUPLICATED ON THE
*                                       SPIN IOT WITHOUT THE "NOT FOR
*                                       SYSOUT" FLAG SET.
         SPACE 1
DD$SYOUT MVI   0(R6),SW@FOUND           INDICATE FOUND
         CVD   R1,DDN@DWD               CONVERT TO PACKED
         OI    DDN@DWD+7,X'0F'          REMOVE SIGN
         UNPK  1(4,R6),DDN@DWD          MAKE IT PRINTABLE
         MVC   DSID,QBLANK              CLEAR DISPLAY FIELD
         CLC   =H'100',PDBDSKEY         A PROBLEM PROGRAM DATASET?
         BL    DD$PDBSV                 YES - GO SAVE IT
         TM    QXAUTH,1                 AUTHORIZED USER?
         BNO   *+10    >======+         NO - DON'T DISPLAY DSID
         MVC   DSID,1(R6)     ×         YES - MOVE DSID TO PRINT LINE
         MH    R1,=H'6'  <====+         ENTRIES ARE 6 BYTES EACH
         LA    R1,DSIDTYPE-6(R1)        -> TYPE
         TM    QXAUTH,1                 AUTHORIZED USER?
         BO    DD$AUTH1                 YES - SHOW HIM EVERYTHING
         CLI   PDBDSKEY+1,1             INPUT JCL?
         BE    NXT$DSID                 YES - DON'T SHOW IT
         CLI   PDBDSKEY+1,4             JOBLOG/JCL/JOBMSG?
         BH    NXT$DSID                 NO - DON'T SHOW IT
DD$AUTH1 MVC   DSTYPE,0(R1)             MOVE IN SYSTEM DSTYPE
         TM    PDBFLAG1,PDB1HOLD        HELD DATASET?
         BNO   *+10    >======+         NO - SKIP
         MVC   HELD,=C'H-'    ×         YES - INDICATE
         L     R0,PDBRECCT  <=+         GET RECORD COUNT
         CVD   R0,DDN@DWD               CONVERT TO PACKED
         MVC   RECORDS,=X'4020202020202120'  MOVE IN EDIT MASK
         ED    RECORDS,DDN@DWD+4
         BAL   R8,DDN$DISP              ADD THIS LINE TO SCREEN
         B     NXT$DSID                 DON'T SAVE THIS ONE
         SPACE 1
DD$PDBSV MVC   0(1,R6),DDN@SW           SAVE SPIN INDICATOR
         TM    PDBFLAG1,PDB1HOLD        HELD DATASET?
         BNO   *+8                      NO - SKIP
         OI    0(R6),SW@HELD            YES - REMEMBER THIS TIDBIT
         MVC   5(4,R6),PDBRECCT         SAVE RECORD COUNT
         LA    R6,9(,R6)                -> NEXT SLOT
         LA    R0,9(,R6)                -> THE ONE AFTER THE NEXT
         C     R0,QCEND                 DOES THE NEXT ONE FIT?
         BL    NXT$DSID                 YES - OK
         QTILT '*** TOO MANY DSIDS ***'
NXT$DSID LA    R2,PDBLENG(,R2)          -> NEXT PDDB
         CR    R2,R4                    PAST LAST PDDB?
         BL    DD$PDBLP                 NO - DO NEXT
         L     R4,IOTIOTTR              DISK ADDR OF NEXT IOT
DD$RDIOT LTR   R4,R4                    ANY MORE?
         BZ    DD$SPIOT                 NO - TRY SPIN IOT
         BAL   R8,DDN$READ              READ THE IOT
         B     DD$IOTLP                 PROCESS IT
         SPACE 1
DD$SPIOT L     R1,QCJCTA                -> JCT
         TM    DDN@SW,SW@SPIN           SPIN IOT SEARCHED ALREADY?
         BO    DD$OKIOT                 YES - DONE READING IOT'S
         L     R4,JCTSPIOT-JCTSTART(,R1)  DISK ADDR OF SPIN IOT
         OI    DDN@SW,SW@SPIN           INDICATE SPIN IOT'S
         B     DD$RDIOT                 GO READ THE SPIN IOT
         SPACE 1
DD$OKIOT MVI   0(R6),SW@END             SET END FLAG
         L     R4,JCTIOT-JCTSTART(,R1)  DISK ADDR OF IOT
         BAL   R8,DDN$READ              READ IOT
         DROP  R5,R2
         SPACE 2
***********************************************************************
*                                                                     *
*   LOCATE PDDB NUMBER 5                                              *
*                                                                     *
***********************************************************************
         USING PDBDSECT,R2              BASE REG FOR PDDB
         USING IOTSTART,R3              BASE REG FOR IOT
         L     R3,QCIOTA                LOAD BASE REG
         LR    R4,R3                    BASE OF IOT
         A     R4,IOTPDDBP              OFFSET BEYOND LAST PDDB
         LR    R2,R3                    BASE OF IOT
         A     R2,QCPDDB1               OFFSET TO  FIRST PDDB IN IOT
         MVC   QPDSID,=H'0'             NULLIFY VALIDITY FOR LISTDS
FINDDS1  CLC   =H'5',PDBDSKEY           IS THIS THE DATASET?
         BE    FOUNDDS1                 YES. CONTINUE.
         LA    R2,PDBLENG(,R2)          NO. LOOK AT NEXT PDDB.
         CR    R2,R4                    PAST THE LAST PDDB?
         BL    FINDDS1                  NO. TRY AGAIN.
         QTILT '*** JOB DOES NOT HAVE DD TABLE ***'
FOUNDDS1 L     R4,PDBMTTR               DISK ADDR OF FIRST BLOCK
         L     R5,QCBLKA                ADDR OF DATASET BLOCK IOAREA
         MVC   QDMSG,QBLANK             BLANK OUT THE MESSAGE AREA
         B     DDNFIRST                 PROCESS DATASET
***********************************************************************
*                                                                     *
*   PROCESS DATASET                                                   *
*                                                                     *
***********************************************************************
DDNXTBLK L     R4,0(,R5)                DISK ADDR OF NEXT BLOCK
DDNFIRST LTR   R4,R4                    IS THE DISK ADDR ZERO?
         BZ    DDN$END                  YES. END OF DATASET.
         BAL   R8,DDN$READ              READ A BLOCK
         CLC   QPJOBID,4(R5)            DOES THE JOBID MATCH?
         BNE   DDN$END                  NO. END OF DATASET.
         CLC   =H'5',8(R5)              IS THE DSID 5?
         BNE   DDN$END                  NO. END OF DATASET.
         LA    R4,10(,R5)               ADDR OF FIRST RECORD IN BLOCK
***********************************************************************
*                                                                     *
*   PROCESS RECORDS                                                   *
*                                                                     *
***********************************************************************
NEXTREC1 CLI   0(R4),ENDIND             IS LENGTH BYTE FF?
         BE    DDNXTBLK                 YES. END OF BLOCK.
         TM    1(R4),X'10'              IS THIS A SPANNED RECORD?
         BO    DDN$SPAN                 YES. SKIP IT.
         ZIC   R6,0(,R4)                INSERT LENGTH
         TM    5(R4),2                  IS THIS AN EXEC RECORD?
         BO    EXEC                     YES. PROCESS IT.
         TM    5(R4),4                  IS THIS A DD RECORD?
         BO    DD                       YES. PROCESS IT.
SKIPREC  LA    R4,3(R6,R4)              INCREMENT TO NEXT RECORD
         B     NEXTREC1                 PROCESS NEXT RECORD
DDN$SPAN LH    R6,2(,R4)                LENGTH OF SEGMENT
         TM    1(R4),X'08'              IS THIS THE FIRST SEGMENT?
         BO    SPAN1ST1                 YES. USE HEADER LENGTH OF 6.
         LA    R4,4(R6,R4)              INCREMENT TO NEXT RECORD
         B     NEXTREC1                 PROCESS NEXT RECORD
SPAN1ST1 LA    R4,6(R6,R4)              INCREMENT TO NEXT RECORD
         B     NEXTREC1                 PROCESS NEXT RECORD
***********************************************************************
*                                                                     *
*   PROCESS AN EXEC RECORD                                            *
*                                                                     *
***********************************************************************
EXEC     CLI   7(R4),EXECK              IS THERE A STEPNAME?
         BNE   SKIPREC                  NO. SKIP THIS RECORD.
         ZIC   R1,9(,R4)                LENGTH OF PROCSTEP/STEPNAME
         TM    6(R4),X'20'              EXEC PROC=XXXX?
         BO    EXECPROC                 YES - HANDLE IT
*  ASSUME (FOR LACK OF KNOWLEDGE TO THE CONTRARY) THAT IT'S PGM=
         LA    R15,PROCSTEP             ASSUME IN PROC
         TM    6(R4),X'08'              IN A PROC?
         BO    EXECINPR                 YES - OK
         LA    R15,STEPNAME             POINT TO WHERE STEPNAME GOES
         MVC   PROCSTEP,=C'  N/A   '    INDICATE NO PROCSTEP NAME
         MVC   PROCNAME,=C' (NONE) '    THERE IS NO PROCEDURE IN EFFECT
EXECINPR MVC   0(8,R15),=C' (NONE) '    CLEAR IT
         MVC   PGMNAME,=C' (NONE) '     AND THIS TOO
         SH    R1,=H'1'                 -1 FOR EX
         BM    *+14        >=======+    SKIP IF NO STEPNAME
         MVC   0(8,R15),QBLANK     ×    CLEAR THE FIELD FIRST
         EX    R1,MVCSTEP          ×    MOVE THE STEPNAME
         LA    R15,10+1(R1,R4)  <==+    POINT TO PGMNAME KEY
         CLI   0(R15),PGMEK             IS THIS THE PROGRAM NAME?
         BNE   SKIPREC                  NO - DONE WITH THIS RECORD
         CLI   2(R15),X'83'             IS THIS PGM=*.STEP.DDNAME?
         BE    EXECSTAR                 YES - HANDLE IT
         ZIC   R1,2(,R15)               GET PGMNAME LENGTH
         SH    R1,=H'1'                 -1 FOR EX
         BM    SKIPREC                  SKIP IF NONE
         MVC   PGMNAME,QBLANK           CLEAR THE FIELD
         EX    R1,MVCPGM                MOVE PGM NAME
         B     SKIPREC                  CONTINUE PROCESSING
         SPACE 1
EXECSTAR MVC   PGMNAME,=C'*.DDNAME'     THE REAL WHOLE THING WON'T FIT
         B     SKIPREC                  IGNORE THE REST OF THE RECORD
         SPACE 1
EXECPROC MVC   PROCSTEP,=C' (NONE) '    INIT FIELD
         MVC   STEPNAME,=C' (NONE) '    THIS ONE TOO
         MVC   PROCNAME,=C' (NONE) '    AND YET ANOTHER ONE
         MVC   PGMNAME,=C' (NONE) '     AND THIS TOO
         SH    R1,=H'1'                 -1 FOR EX
         BM    *+14        >=======+    SKIP IF NONE
         MVC   STEPNAME,QBLANK     ×    BLANK THE FIELD
         EX    R1,MVCPSTEP         ×    MOVE STEPNAME
         LA    R15,10+1(R1,R4)  <==+    POINT TO PROCNAME OR NEXT UNIT
         CLI   8(R4),2                  ARE THERE 2 POSITIONAL UNITS?
         BE    EXECPR03                 YES - GO PROCESS IT
         CLI   0(R15),PROCEK            EXPLICIT EXEC PROC= ?
         BNE   SKIPREC                  NO - GET OUT
         LA    R15,2(,R15)              POINT TO PROCNAME LENGTH
EXECPR03 ZIC   R1,0(,R15)               GET PROCNAME LENGTH
         SH    R1,=H'1'                 -1 FOR EX
         BM    SKIPREC                  IGNORE IF NONE
         MVC   PROCNAME,QBLANK          BLANK THE FIELD
         EX    R1,MVCPROC               MOVE PROCNAME
         B     SKIPREC                  DONE WITH THIS RECORD
***********************************************************************
*                                                                     *
*   PROCESS DD RECORDS                                                *
*                                                                     *
***********************************************************************
DD       TM    6(R4),X'30'              IS THIS A SYSIN OR SYSOUT DD?
         BZ    SKIPREC                  NO. SKIP THE RECORD.
         MVC   DDN,QBLANK               BLANK OUT THE DDNAME
         MVC   DSID,QBLANK              BLANK OUT THE DSID
         LA    R7,7(,R4)                ADDR OF FIRST KEY
         LR    R8,R6                    REMAINING LENGTH OF RECORD
         SR    R15,R15                  CLEAR FOR IC
         SR    R14,R14                  CLEAR FOR IC
         SR    R1,R1                    CLEAR FOR IC
TRYFLD   CLI   0(R7),DDK                IS THIS THE DDNAME?
         BE    DDKEY                    YES. PROCESS IT.
         CLI   0(R7),DSNAMEK            IS THIS THE DSNAME?
         BE    DSKEY                    YES. PROCESS IT.
NEXTFLD  IC    R1,1(,R7)                NUMBER OF SUBFIELDS
         LA    R7,2(,R7)                UPDATE LOCATION
         SH    R8,=H'2'                 REMAINING COUNT
         SR    R8,R1                    REMAINING COUNT
         BNP   SKIPREC                  RECORD IS EXHAUSTED
         LTR   R1,R1                    ARE THERE ANY SUBFIELDS?
         BZ    TRYFLD                   NO. TRY NEXT FIELD.
LOOPFLD  TM    0(R7),X'80'              IS THIS A SUB-SUB-FIELD
         BZ    NOSUB                    NO. CONTINUE.
         NI    0(R7),X'7F'              CLEAR THE HEX 80 BIT
         IC    R14,0(,R7)               NUMBER OF SUB-SUB-FIELDS
         LA    R7,1(,R7)                UPDATE LOCATION
         SH    R8,=H'1'                 REMAINING COUNT
         SR    R8,R14                   REMAINING COUNT
         BNP   SKIPREC                  RECORD IS EXHAUSTED
         AR    R1,R14                   INCREASE NUMBER OF SUBFIELDS
         B     YESSUB                   DECREMENT AND TRY AGAIN
NOSUB    IC    R15,0(,R7)               SUBFIELD LENGTH
         LA    R7,1(R15,R7)             ADD TO LOCATION
         SR    R8,R15                   REMAINING COUNT
         BNP   SKIPREC                  RECORD IS EXHAUSTED
YESSUB   BCT   R1,LOOPFLD               DO NEXT SUBFIELD
         B     TRYFLD                   TRY NEXT FIELD
DDKEY    IC    R1,2(,R7)                LENGTH OF DDNAME
         LTR   R1,R1                    IS THE LENGTH ZERO?
         BZ    NEXTFLD                  YES. SKIP THE FIELD.
         BCTR  R1,0                     DECREMENT BY 1
         EX    R1,MVCDDN                MOVE THE DDNAME
         B     NEXTFLD                  PROCESS NEXT FIELD
DSKEY    MVC   DSID,19(R7)              MOVE THE DSID
         MVC   DSTYPE,=C'*ERROR'        INIT FIELD
         TM    6(R4),X'20'              SYSOUT?
         BNO   *+10                     NO - SKIP
         MVC   DSTYPE,=C'SYSOUT'
         TM    6(R4),X'10'              SYSIN?
         BNO   *+10                     NO - SKIP
         MVC   DSTYPE,=C'SYSIN '
         TM    6(R4),X'30'              BOTH????
         BNO   *+10                     NO - SKIP
         MVC   DSTYPE,=C'ERROR*'
         L     R1,QCSTART               -> DSID TABLE
         MVC   RECORDS,QBLANK           ASSUME WE WON'T FIND ANYTHING
         MVC   HELD,QBLANK              ...
DSID$LP  TM    0(R1),SW@END             HIT END OF TABLE?
         BO    NO$COUNT                 YES - IT'S NOT HERE
         CLC   DSID,1(R1)               THIS IT?
         BE    DSID$GOT                 YES
         LA    R1,9(,R1)                -> NEXT ENTRY
         B     DSID$LP
DSID$GOT L     R0,5(,R1)                GET RECORD COUNT
         CVD   R0,DDN@DWD               CONVERT TO PACKED
         TM    0(R1),SW@HELD            HELD DATASET?
         BNO   *+10                     NO - SKIP
         MVC   HELD,=C'H-'              YES - INDICATE
         OI    0(R1),SW@FOUND           INDICATE THIS ONE'S BEEN USED
         MVC   RECORDS,=X'4020202020202120'  MOVE IN EDIT MASK
         ED    RECORDS,DDN@DWD+4
NO$COUNT BAL   R8,DDN$DISP              CALL DISPLAY FOR THIS LINE
         MVC   PROCSTEP,QBLANK          RESET
         MVC   STEPNAME,QBLANK                THESE
         MVC   PROCNAME,QBLANK                      FIELDS
         MVC   PGMNAME,QBLANK                              ...
         B     SKIPREC                  PROCESS NEXT RECORD
***********************************************************************
*                                                                     *
*   DISPLAY SPIN-IOT DSID'S AND NON-SPIN DSID'S THAT WEREN'T CLAIMED  *
*   BY PREVIOUS CODE                                          --LDW-- *
*                                                                     *
***********************************************************************
DDN$END  MVC   PGMNAME(80),QBLANK       DON'T KNOW PGM NAMES ANYMORE
         L     R6,QCSTART               -> DSID TABLE
DD$SPLP  TM    0(R6),SW@END             END OF TABLE?
         BO    DDN$STOP                 YES - FINALLY DONE
         TM    0(R6),SW@FOUND           ALREADY DISPLAYED?
         BO    DD$NXTDS                 YES - SKIP IT NOW
         MVC   DSID,1(R6)               MOVE IN DSID
         MVC   DSTYPE,=C'*LOST*'        UNCLAIMED DATASET
         TM    0(R6),SW@SPIN            SPIN?
         BNO   *+10                     NO - SKIP
         MVC   DSTYPE,=C'<SPIN>'        YES - SAY SO
         L     R0,5(,R6)                GET RECORD COUNT
         CVD   R0,DDN@DWD               CONVERT TO PACKED
         MVC   RECORDS,=X'4020202020202120'   MOVE IN EDIT MASK
         ED    RECORDS,DDN@DWD+4        PUT IN RECORD COUNT
         BAL   R8,DDN$DISP              MOVE LINE TO SCREEN
DD$NXTDS LA    R6,9(,R6)                -> NEXT DSID ENTRY
         B     DD$SPLP                  FORMAT IT
***********************************************************************
*                                                                     *
*   LEAVE THIS ROUTINE                                                *
*                                                                     *
***********************************************************************
DDN$STOP QSTOP
***********************************************************************
*                                                                     *
*   READ A BLOCK FROM HASPACE                                         *
*                                                                     *
***********************************************************************
DDN$READ ST    R4,QCTRAK                STORE DISK ADDR
         LR    R1,R5                    IOAREA ADDRESS
         QCALL READSPC                  READ HASPACE
         BR    R8                       RETURN TO CALLER
***********************************************************************
*                                                                     *
*   CALL DISPLAY TO ADD A LINE TO SCREEN                              *
*                                                                     *
***********************************************************************
DDN$DISP MVC   QDHLINE,DDN#HEAD         MOVE IN HEADING
         QCALL DISPLAY,QDMSG,80
         BR    R8                       RETURN TO MAINLINE
         SPACE 1
         LTORG
MVCPSTEP MVC   STEPNAME(*-*),10(R4)     << EXECUTED >>
MVCPROC  MVC   PROCNAME(*-*),1(R15)     << EXECUTED >>
MVCSTEP  MVC   0(*-*,R15),10(R4)        << EXECUTED >>
MVCPGM   MVC   PGMNAME(*-*),3(R15)      << EXECUTED >>
MVCDDN   MVC   DDN(*-*),3(R7)           << EXECUTED >>
DSIDTYPE DC    C'JCLIN JOBLOGJCL   JOBMSGJCLTXTSWA   '
DDN#HEAD DC    CL80'PROGRAM   PROCEDURE     STEPNAME  PROCSTEP   DDNAME$
                    DSID    DSTYPE  RECORDS'
         SPACE 3
DDN@WORK DC    0D'0'
DDN@DWD  DS    D
DDN@SW   DS    X
SW@SPIN  EQU   X'01'                    THIS IS A SPIN DSID
SW@FOUND EQU   X'02'                    DSID FOUND IN PDDB 5
SW@HELD  EQU   X'04'                    THIS IS A HELD DATASET
SW@END   EQU   X'80'                    END OF TABLE INDICATOR
         SPACE 3
         DROP  R10,R9,R2,R3
     TITLE '--- QUEUE/SP --DISPLAY -- 3270 DISPLAY ROUTINES ---'
*---------------------------------------------------------------------*
*                                                                     *
*  DISPLAY - 3270 DISPLAY SUBROUTINE                                  *
*                                                                     *
* ENTRY: R1  - @ OF TEXT                                              *
*        R0  - LENGTH OF TEXT                                         *
*                                                                     *
* EXIT: QDOVER - FLAG SET IF SCREEN OVERFLOW                          *
*       QDMORE = *MORE*                                               *
*                                                                     *
*---------------------------------------------------------------------*
         SPACE 1
DISPLAY  QSTART ,
         USING QDISPLAY,R10
         L     R10,QVDSPL               @ OF DISPLAY WORK AREA
         SPACE 1
         STH   R0,QDMLNG                SET CALLERS LENGTH
         ST    R1,QDMSGA                 AND TEXT ADDRESS
*---              CHECK FOR ROOM ON SCREEN                         ---*
         MVI   QDOVER,0                 RESET THE PAGE OVRFL INDICATOR
         MVC   QDMORE,QBLANK            BLANK THE OVERFLOW INDICATOR
         LH    R4,QDMLNG                LOAD MSG LENGTH
         CH    R4,=H'1680'              IS MSG LENGTH MORE THAN 1680?
         BH    RETURN                   YES. GO AWAY.
         LTR   R4,R4                    IS MSG LENGTH ZERO?
         BZ    WRTSCR                   YES. WRITE SCREEN.
         MVC   QDMORE,=C'*MORE*'        INDICATE SCREEN OVERFLOW
         AH    R4,QDNEXT                ADD CURRENT LOCATION ON SCREEN
         CH    R4,=H'1680'              IS THERE ROOM ON THE SCREEN?
         BH    WRTSCR                   NO. WRITE SCREEN.
         SPACE 1
*---              MOVE THE MESSAGE TO THE SCREEN                   ---*
DSP2     LH    R7,QDMLNG                LOAD MESSAGE LENGTH
         LTR   R7,R7                    IS MESSAGE LENGTH ZERO?
         BZ    RETURN                   YES. RETURN.
         LH    R4,QDNEXT                GET CURRENT SCREEN LINE NUMBER
         LR    R1,R4                    SAVE LINE NUMBER
         LA    R4,QDLINE1(R4)           LOAD ADDRESS OF NEXT LINE
         L     R6,QDMSGA                LOAD ADDR OF MESSAGE
         LA    R5,80                    LENGTH MUST BE MULTIPLE OF 80
DSP3     CR    R5,R7                    IS 5 NOT LESS THAN 7?
         BNL   DSP4                     YES. GO DO IT.
         LA    R5,80(,R5)               INCR BY 80
         B     DSP3                     TRY AGAIN
DSP4     AR    R1,R5                    UPDATE LINE NUMBER
         STH   R1,QDNEXT                STORE LINE NUMBER
         ICM   R7,B'1000',=C' '         GET PAD CHAR
         LR    R1,R4                    SAVE DESTINATION ADDRESS
         LR    R0,R5                    SAVE DESTINATION LENGTH
         MVCL  R4,R6                    MOVE THE MESSAGE TO THE SCREEN
         CLC   =A(ENDDATA),QDMSGA       IS THIS THE SPECIAL MESSAGE?
         BE    RETURN                   YES - DON'T TRANSLATE
DSP5     TR    0(80,R1),D$TABLE         TRANSLATE OUT STRANGE CHARS
         LA    R1,80(,R1)               -> NEXT SCREEN LINE
         SH    R0,=H'80'                DECREMENT REMAINING LENGTH
         BP    DSP5                     KEEP TRANSLATING
RETURN   QSTOP
         SPACE 1
*---             WRITE A FULL SCREEN, WAIT FOR REPLY               ---*
*WRTSCR  TR    QDLINE1(256),D$TABLE     ENSURE PRINTABILITY
*        TR    QDLINE1+256(256),D$TABLE
*        TR    QDLINE1+512(256),D$TABLE
*        TR    QDLINE1+768(256),D$TABLE
*        TR    QDLINE1+1024(256),D$TABLE
*        TR    QDLINE1+1280(256),D$TABLE
*        TR    QDLINE1+1536(144),D$TABLE
WRTSCR   MVC   QDFINAL,=X'1140400513'   ASSUME FULL SCREEN, MOVE IN
*                                       "PT TO 1ST INPUT FIELD; IC"
         LA    R2,QDFINAL+L'QDFINAL     POINT PAST LAST CHAR
         CLC   QDFINAL-4(4),QBLANK      LAST PART OF SCREEN BLANK?
         BNE   TPUT                     NO - DON'T BOTHER WITH RA
         LA    R1,QDFINAL-4             -> FIRST CHAR TO CHECK
         BALR  R14,0                    SET LOOP ADDR
         CLI   0(R1),C' '               FIND NON-BLANK?
         BNE   *+6                      YES - EXIT LOOP
         BCTR  R1,R14                   NO - KEEP LOOKING
         MVC   1(6,R1),=X'3C4040000513' SET RA TO TOP, PT, IC
         LA    R2,7(,R1)                POINT PAST LAST CHAR
         SPACE 1
TPUT     LA    R3,QDSCREEN              LOAD ADDRESS OF SCREEN BUFFER
         SR    R2,R3                    COMPUTE TPUT LENGTH
         ICM   R3,B'1000',=X'03'        GET FULLSCR FLAG
         SPACE 1
RESHOW   LR    R1,R3                    GET THE ADDRESS
         LR    R0,R2                    GET THE LENGTH
         TPUT  (1),(0),R                WRITE SCREEN
         XC    PFREPLY,PFREPLY                                     ICBC
         XC    QDREPLY,QDREPLY                                     ICBC
         LA    R1,PFREPLY               LOAD ADDRESS OF REPLY AREA ICBC
         TGET  (1),69,ASIS              WAIT FOR REPLY             ICBC
         CLI   PFCODE,X'6E'             PA2? (RESHOW)
         BE    TCLEARQ                  YES - GO FLUSH REST OF INPUT
         CH    R15,=H'12'               INPUT LONGER THAN BUFFER?  ICBC
         BNE   NOCLEAR                  NO. CONTINUE.              ICBC
TCLEARQ  LR    R4,R1                    SAVE THE INPUT LENGTH
         TCLEARQ INPUT                  CLEAR THE QUEUE            ICBC
         LR    R1,R4                    RESTORE THE INPUT LENGTH
         CLI   PFCODE,X'6E'             PA2? (RESHOW)
         BE    RESHOW                   YES - RE-DISPLAY LAST SCREEN
NOCLEAR  LA    R4,QDLINE1               LOAD ADDRESS OF FIRST LINE
         LA    R5,1680                  LOAD LENGTH OF SCREEN
         SR    R6,R6                    NO SENDING FIELD NEEDED
         STH   R6,QDNEXT                STORE ZERO IN LINE NUMBER
         L     R7,=X'40000000'          FILL SCREEN WITH BLANKS
         MVCL  R4,R6                    CLEAR THE SCREEN
         XC    QDTLINE,QDTLINE          CLEAR INPUT AREA ON SCREEN
         LA    R6,QDREPLY                                          ICBC
         IC    R4,PFCODE                                           ICBC
         XR    R5,R5                                               ICBC
         N     R4,=X'0000000F'          EXTRACT PF-KEY NUMBER      ICBC
         CH    R4,=H'12'                                           ICBC
         BH    ENTKEY                   "ENTER" KEY                ICBC
         BCTR  R4,0                                                ICBC
         MH    R4,=H'5'                                            ICBC
         LA    R5,PFKTAB                                           ICBC
         LA    R5,0(R4,R5)                                         ICBC
         MVC   QDREPLY(5),0(R5)         MOVE PF-KEY VALUE          ICBC
         LA    R5,5                                                ICBC
         LA    R6,3(,R6)                                           ICBC
ENTKEY   SH    R1,=H'3'                                            ICBC
         BZ    NOTXT                                               ICBC
         MVC   0(60,R6),PFTXT                                      ICBC
         LA    R5,3                                                ICBC
         SH    R1,=H'3'                                            ICBC
NOTXT    LA    R1,0(R5,R1)                                         ICBC
         STH   R1,QDRLNG                STORE LENGTH OF REPLY      ICBC
         LTR   R1,R1                    RESPONSE FROM USER?        ICBC
         BNZ   INTER                    YES. INTERRUPT PROCESSING. ICBC
         MVI   QDOVER,1                 INDICATE PAGE OVERFLOW
         B     DSP2                     CONTINUE PROCESSING
INTER    CLI   QDREPLY,C'*'             REPROMPT REQUEST?
         BE    REPROMPT                 YES - DO IT
         MVC   QDPROMPT,QDREPLY         SAVE REPLY IN CASE REPROMPT
         L     R13,QFRSTSA              GO BACK TO MAIN MODULE
         LM    R0,R15,0(R13)            RESTORE REGS FROM 1ST SAVEAREA
         BR    R10                      -> INTERRUPT HANDLER IN QUEUE
****     QSTOP ,                  RETURN TO TOP LEVEL RTN
         SPACE 1
REPROMPT MVC   QDTLINE,QDPROMPT         COPY LAST COMMAND
         LA    R15,QDTLINE+L'QDTLINE-1  POINT TO LAST CHAR
         LA    R0,1                     BXH ...
         LCR   R0,R0                    ... DECREMENT
         LA    R1,QDTLINE               POINT TO FIRST CHAR (STOP ADDR)
         SPACE 1
LOOPNULL CLI   0(R15),C' '              FIND END?
         BNE   RESHOW                   YES - DISPLAY THE RESULT
         MVI   0(R15),X'00'             CHANGE TRAILING BLANK TO NULL
         BXH   R15,R0,LOOPNULL          BACKSCAN THE WHOLE THING
         B     RESHOW                   DISPLAY THE RESULT.
         SPACE 1
         LTORG ,
         SPACE 1
* PF-KEY DEFINITIONS                                               ICBC
PFKTAB   DS    0CL60                                               ICBC
         DC    CL5'H    '               PF1                        ICBC
         DC    CL5'*    '               PF2                        ICBC
         DC    CL5'E    '               PF3                        ICBC
         DC    CL5'DA   '               PF4                        ICBC
         DC    CL5'F    '               PF5                        ICBC
         DC    CL5'DI   '               PF6                        ICBC
         DC    CL5'-  21'               PF7                        ICBC
         DC    CL5'+  21'               PF8                        ICBC
         DC    CL5'DO   '               PF9                        ICBC
         DC    CL5'CO 1 '               PF10                       ICBC
         DC    CL5'CO 41'               PF11                       ICBC
         DC    CL5'ST   '               PF12                       ICBC
         SPACE 1
* TABLE OF PRINTABLE CHARACTERS
D$TABLE  DC    256C'?'                  TRANSLATE ALL GARBAGE TO '?'
         ORG   D$TABLE+C' '             BLANK
         DC    C' '
         ORG   D$TABLE+C'Ö'             CENT
         DC    C'Ö.<(+×&&'
         ORG   D$TABLE+C'!'             EXCLAMATION
         DC    C'!$*);^-/'
         ORG   D$TABLE+C'|'             BROKEN BAR
         DC    C'|,%_>?'
         ORG   D$TABLE+C'`'             ACCENT GRAVE
         DC    C'`:#@''="'
         ORG   D$TABLE+C'A'-X'40'
         DC    X'818283848586878889'
         ORG   D$TABLE+C'J'-X'40'
         DC    X'919293949596979899'
         ORG   D$TABLE+C'S'-X'40'
         DC    X'A2A3A4A5A6A7A8A9'
         ORG   D$TABLE+C'A'
         DC    C'ABCDEFGHI'
         ORG   D$TABLE+C'J'
         DC    C'JKLMNOPQR'
         ORG   D$TABLE+C'S'
         DC    C'STUVWXYZ'
         ORG   D$TABLE+C'0'
         DC    C'0123456789'
         ORG   D$TABLE+C'{'             LEFT BRACE
         DC    C'{'
         ORG   D$TABLE+C'}'             RIGHT BRACE
         DC    C'}'
         ORG   D$TABLE+C'~'             TILDE
         DC    C'~'
         ORG   D$TABLE+C'\'             BACKSLASH
         DC    C'\'
         ORG   ,
         SPACE 1
         DROP  R10
    TITLE '--- QUEUE/SP --FINDJOB -- LOC. JQE, JCT, IOT BY JOBNM ---'
FINDJOB  QSTART  Q6
         USING QCKPT,R10                BASE REG FOR CHECKPT WORK AREA
         L     R10,QVCKPT               LOAD BASE REG
***********************************************************************
*                                                                     *
*   DETERMINE IF SEARCH IS BY JOBNUMBER OR JOBNAME                    *
*                                                                     *
***********************************************************************
         LH    R1,QLNG1                 LENGTH OF PARAMETER FIELD
         SH    R1,=H'1'                 IS THE LENGTH ZERO?
         BM    FJ$TILT                  YES. TILT.
         CLI   QPARM1,C'0'              IS THE FIRST CHARACTER NUMERIC?
         BL    JOBNAME                  NO. SEARCH BY JOBNAME
         LA    R15,QPARM1               POINT TO PARM
         BAL   R14,QNUMCONV             CONVERT IT
         BNE   FJ$TILT                  TILT IF NOT NUMERIC
         LR    R5,R15                   SAVE THE VALUE
***********************************************************************
*                                                                     *
*   LOCATE JQE BY JOBNAME                                             *
*                                                                     *
***********************************************************************
JOBNAME  L     R2,QCJQHEAD              LOAD ADDR OF JQT
         LA    R1,$JQTYPES              # OF QUEUES
NEXTJQT1 L     R3,0(,R2)
NEXTJQE1 N     R3,=X'00FFFFFF'          OFFSET TO JQE
         BZ    ENDJQE                   BIF END OF QUEUE
         AL    R3,QCJQTA                ADD BASE TO OFFSET
         USING JQEDSECT,R3              BASE REG FOR JQE
         CLI   QPARM1,C'0'              IS SEARCH BY JOBNUMBER?
         BL    CLCNAME                  NO. SEARCH BY JOBNAME.
         CH    R5,JQEJOBNO              IS THIS THE RIGHT JOBNUMBER?
         BNE   NOMATCH                  NO. TRY NEXT JQE.
         B     FJ$FOUND                 YES. PROCESS IT.
CLCNAME  CLC   QPARM1,JQEJNAME          IS THIS THE RIGHT JOBNAME?
         BE    FJ$FOUND                 YES. PROCESS IT.
NOMATCH  L     R3,JQENEXT               OFFSET OF NEXT JQE OR 0 MAS/SP3
         B     NEXTJQE1                 LOOP
ENDJQE   LA    R2,$JQHEADL(,R2)         TRY NEXT QUEUE
         BCT   R1,NEXTJQT1              LOOP IF NOT LAST QUEUE
FJ$TILT  QTILT '*** JOBNAME NOT FOUND OR INVALID ***'
***********************************************************************
*                                                                     *
*   READ JCT AND IOT                                                  *
*                                                                     *
***********************************************************************
FJ$FOUND ST    R3,QCJQEA                SAVE THE ADDRESS
         MVC   QCTRAK,JQETRAK           DISK ADDR OF JCT
         DROP  R3
         L     R3,QCJCTA                ADDR OF IOAREA FOR JCT
         LR    R1,R3                    PARM FOR READSPC
         QCALL READSPC                  READ HASPACE
         USING JCTSTART,R3              BASE REG FOR JCT
         CLC   JCTID,=CL4'JCT '         IS THIS A JCT?             MAS1
         BNE   FJ$JCTER                 BIF NOT VALID JCT          MAS1
         MVC   QPJOBID,JCTJBKEY         JOB IDENTIFICATION
         MVC   QCTRAK,JCTIOT            DISK ADDR OF IOT
         DROP  R3
         L     R3,QCIOTA          @ IOT BUFFER AREA
         LR    R1,R3              PARM FOR READSPC
         QCALL READSPC            READ IOT
         USING IOTSTART,R3
         CLC   IOTID,=CL4'IOT '   IS THIS IOT?
         BNE   FJ$IOTER           BIF NOT IOT
STOP     QSTOP
         SPACE 1                                                   MAS1
FJ$JCTER QTILT 'INVALID JCT (BAD JCTID)'                           MAS1
FJ$IOTER QTILT 'INVALID IOT (BAD IOTID)'                           MAS1
         SPACE 1                                                   MAS1
         LTORG
         SPACE 3
         DROP  R10
    TITLE '--- QUEUE/SP --FORMAT -- JQE AND JOE FORMAT ROUTINES ---'
*---------------------------------------------------------------------*
*                                                                     *
*  FORMAT:  FORMAT JOE OR JQE                                         *
*                                                                     *
* ENTRY: R1 = 0 FORMAT JQE                                            *
*        R1 = 4 FORMAT JOE                                            *
*        R8 = @ JOE (IF JOE FORMAT REQUESTED)                         *
*        R9 = @ JQE                                                   *
*                                                                     *
*  NOTE THE MANY KLUDGES FOR THE 'XJ' COMMAND (HEX FORMAT).           *
*                                                                     *
*---------------------------------------------------------------------*
         SPACE 1
FORMAT   QSTART ,
         L     R10,QVDSPL               LOAD BASE REG
         USING QDISPLAY,R10             BASE REG FOR DISPLAY WORK AREA
         SPACE 1
         USING JQEDSECT,R9              BASE REG FOR JQE DSECT
         USING JOEDSECT,R8              BASE REG FOR JOE DSECT
         SPACE 1
         MVC   FCLEAR,=CL80' '          CLEAR THE PRINT AREA
         MVC   FQUEUE(1),QCLASS         CLASS NAME
         CLI   QCLASS,(2+(2*36))
         BNL   *+10
         MVC   FQUEUE,QCLASSE
         MVC   QDHLINE,FMT#HEAD         REPORT HEADING
         CLI   QSUBNAME,C'X' *KLUDGE*   IS THE REQUEST FOR A HEX DUMP?
         BE    NOTBUSY       *KLUDGE*   YES. SKIP.
         LA    R15,JOEROUT              POINT TO REMOTE ID
         LTR   R1,R1                    JQE OR JOE?
         BNZ   FMT$ROUT                 JOE
         LA    R15,JQEPUNRT             POINT TO PUNCH ROUTE FIELD
         L     R14,QCJQTL               @ MASTER CKPT RECORD
         LH    R14,$NODEID-$SAVEBEG(,R14) THIS NODE ID
         SLL   R14,16                   MAKE LOCAL ID
         CL    R14,0(,R15)              IS THIS LOCAL?
         BNE   FMT$ROUT                 NO - GO FORMAT IT
         LA    R15,JQEPRTRT             POINT TO PRINT ROUTE FIELD
FMT$ROUT BAL   R14,FMT$RJE              GO DECODE DEST (ROUTE)
         TM    JQEFLAGS,QUEBUSY         IS THE JOB EXECUTING?
         BZ    NOTBUSY                  NO. SKIP THIS ROUTINE.
         IC    R15,JQEFLAGS             GET SYSTEM NUMBER
         N     R15,=F'7'                ZERO OUT UNWANTED BITS
         SLL   R15,3                    MULTIPLY BY 8
         LA    R15,QSYSID(R15)          OBTAIN SYSTEM ID
         MVC   FSYSID,0(R15)            MOVE SYSTEM ID TO DISPLAY
NOTBUSY  CLI   QCLASS,0                 IS THIS THE TSO QUEUE?
         BE    LISTTSO                  YES. DO IT.
         CLI   QCLASS,4                 IS THIS THE STC QUEUE?
         BE    LISTSTC                  YES. DO IT.
         CLI   QCLASS,8                 IS THIS THE HELD OUTPUT QUEUE?
         BE    LISTHO                   YES. DO IT.
         LTR   R1,R1                    IS REQUEST FOR JQE OR JOE?
         BZ    LISTJQE                  JQE.
         SPACE 1
*---                     FORMAT JOE                                ---*
LISTJOE  MVI   FQNAME,C'O'              MOVE IN NAME OF QUEUE
         CLI   QSUBNAME,C'X' *KLUDGE*   IS THE REQUEST FOR A HEX DUMP?
         BE    HEXO          *KLUDGE*   YES. DO IT.
         CLC   =X'0F0000',JOEDEVID      EXTERNAL WRITER?
         BNE   *+10                     NO - SKIP
         MVC   FPRINT,=C'XWTR'          YES
*  NOTE THAT IF THE JOB IS TRULY ON THE EXTERNAL WRITER (AND NOT ALSO
*  ON A REAL PRINTER), THE FLAGS $JOEPRT & $JOEPUN WILL BE OFF.
         L     R0,JOERECCT              NUMBER OF PRINT LINES
         TM    JOEFLAG,$JOEPRT+$JOEPUN  PRINTING OR PUNCHING?
         BZ    FMT$LNCT                 NO. SKIP.
         MVC   FPRINT,=C'INT '          ASSUME IT WAS $I'D
         TM    JOEFLAG,$JOEBUSY         BUT WAS IT INTERRUPTED?
         BZ    NOT$PRT                  YES - OK
         TM    JOEFLAG,$JOEPRT          IS IT PRINTING?
         BNO   *+10                     NO - SKIP
         MVC   FPRINT,=C'PRT '          SHOW IT'S PRINTING
         TM    JOEFLAG,$JOEPUN          IS IT PUNCHING?
         BNO   *+10                     NO - SKIP
         MVC   FPRINT,=C'PUN '          SHOW IT'S PUNCHING
         MVC   FPRINT+3(1),JOEDEVID+1   GET PRINTER/PUNCH NUMBER
         OI    FPRINT+3,C'0'            MAKE IT EBCDIC
* NOTE: THE ABOVE CODE WON'T WORK RIGHT IF MORE THAN 9 PRINTERS...
NOT$PRT  TM    JOEFLAG,X'80'            IS THE CKPT VALID
         BZ    FMT$LNCT                 NO. SKIP IT.
         L     R15,JOECKPT              OFFSET TO CHECKPOINT JOE
         N     R15,=X'00FFFFFF'         DOES CKPT EXIST?
         BZ    FMT$LNCT                 BIF CKPT NONEXISTANT, SKIP
         AL    R15,QCJOTA               ADD BASE TO OFFSET
         S     R0,JOETLNC-JOEDSECT(,R15)   SUB RECS PRINTED FROM TOTAL
         SPACE 1
FMT$LNCT CVD   R0,FMT@CONV              CONVERT TO DECIMAL
         MVC   FLINES,ED5               PREPARE FOR EDIT
         C     R0,=F'99999'             TOO BIG?
         BH    FMT$LNC2                 YES - DO IT THE OTHER WAY
         ED    FLINES,FMT@CONV+5        PRINT UPDATED LINE COUNT
         B     FMT$CHAR                 FORMAT CHARACTERISTICS
         SPACE 1
FMT$LNC2 MVI   FLINES+5,C'K'            MAKE IT *1000
         ED    FLINES,FMT@CONV+4        GET JUST THE RIGHT AMOUNT
         SPACE 2
FMT$CHAR L     R8,JOECHAR               OFFSET TO CHARACTERISTICS JOE
         N     R8,=X'00FFFFFF'          ANY CHAR JOE?
         BZ    FMT$LIST                 BIF NO CHAR JOE
         L     R1,QVCKPT                GET BASE REG FOR CKPT WORK AREA
         AL    R8,QCJOTA                ADD BASE TO OFFSET
         CLC   =C'STD.',JOEFORM         IS IT STANDARD?
         BE    *+10                     YES - DON'T DISPLAY IT
         MVC   FFORM,JOEFORM            MOVE FORM NAME
         CLC   =C'****',JOEUCS          IS IT STANDARD?
         BE    *+10                     YES - DON'T DISPLAY IT
         MVC   FUCS,JOEUCS              MOVE UCS NAME
         CLC   =C'****',JOEFCB          IS IT STANDARD?
         BE    *+10                     YES - DON'T DISPLAY IT
         MVC   FFCB,JOEFCB              MOVE FCB NAME
         B     FMT$LIST                 FORMAT REST OF LINE
***********************************************************************
*                                                                     *
*   FORMAT JQE                                                        *
*                                                                     *
***********************************************************************
LISTTSO  MVC   FQNAME(3),=C'TSU'        NAME OF QUEUE
         B     FMT$LIST                 CONTINUE
LISTSTC  MVC   FQNAME(3),=C'SYS'        NAME OF QUEUE
         B     FMT$LIST                 CONTINUE
LISTHO   MVC   FQNAME(3),=C'H/O'        NAME OF QUEUE
         B     FMT$LIST                 CONTINUE
LISTJQE  MVI   FQNAME,C'I'              NAME OF QUEUE
         SPACE 1
FMT$LIST CLI   QSUBNAME,C'X'  *KLUDGE*  IS THE REQUEST FOR A HEX DUMP?
         BE    HEX            *KLUDGE*  YES. DO IT.
         MVC   FMT@CONV(6),ED5
         ED    FMT@CONV(6),QCOUNT
         MVC   FCOUNT,FMT@CONV+6-L'FCOUNT
         MVC   FNAME,JQEJNAME           MOVE IN JOBNAME
         MVC   FJOBNO-1(6),ED5          PREPARE FOR EDIT
         LH    R0,JQEJOBNO              LOAD HASP JOBNUMBER
         CVD   R0,FMT@CONV              CONVERT TO DECIMAL
         ED    FJOBNO-1(6),FMT@CONV+5   EDIT HASP JOBNUMBER
         ZIC   R0,JQEPRIO               LOAD JQE PRIORITY
         SRL   R0,4                     DIVIDE BY 16
         CVD   R0,FMT@CONV              CONVERT TO DECIMAL
         MVC   FPRIO-1(4),ED3           PREPARE FOR EDIT
         ED    FPRIO-1(4),FMT@CONV+6    EDIT JQE PRIORITY
         SPACE 1
         TM    JQEFLAGS,QUEHOLD2        HELD BECAUSE DUP JOB NAME?
         BNO   *+10                     NO - SKIP
         MVC   FHOLD,=C'DUP '           YES - FLAG IT
         TM    JQEFLAGS,QUEHOLDA        HOLD ALL?
         BNO   *+10                     NO
         MVC   FHOLD,=C'ALL '           INDICATE JOB HELD FOR HOLD ALL
         TM    JQEFLAGS,QUEHOLD1        THIS JOB HELD?
         BNO   *+10                     NO - SKIP
         MVC   FHOLD,=C'HELD'           YES - INDICATE IT
         SPACE 2
FMT$DISP QCALL DISPLAY,QDMSG,80         DISPLAY THE LINE
         QSTOP
***********************************************************************
*                                                                     *
*   TAKE HEX DUMP OF JOE                                              *
*                                                                     *
***********************************************************************
HEXO     LR    R1,R8                    GET ADDRESS TO DUMP
         BAL   R14,FMT$HEX              CONVERT JOE TO HEX
         MVC   FHEXID,=C'JOE:'          SAY WHAT IT IS
         MVC   FHEXDATA((JOEEND-JOEDSECT)/4*9-1),FMT@LINE   COPY IT
         QCALL DISPLAY,QDMSG,80         DISPLAY THE LINE
***********************************************************************
*                                                                     *
*   TAKE HEX DUMP OF JQE                                              *
*                                                                     *
***********************************************************************
HEX      LR    R1,R9                    GET ADDRESS TO DUMP
         BAL   R14,FMT$HEX              CONVERT JQE TO HEX
         MVC   FHEXID,=C'JQE:'          SAY WHAT IT IS
         MVC   FHEXDATA(JQELNGTH/4*9-1),FMT@LINE    COPY IT
         B     FMT$DISP                 CALL DISPLAY
***********************************************************************
*                                                                     *
*   SUBROUTINE TO CONVERT LONG HEX STRING TO PRINTABLE                *
*                                                                     *
***********************************************************************
FMT$HEX  UNPK  FMT@HEXW+00(14+1),00(7+1,R1)   BYTES 01-07
         UNPK  FMT@HEXW+14(14+1),07(7+1,R1)   BYTES 08-14
         UNPK  FMT@HEXW+28(14+1),14(7+1,R1)   BYTES 15-21
         UNPK  FMT@HEXW+42(14+1),21(7+1,R1)   BYTES 22-28
         UNPK  FMT@HEXW+56(14+1),28(7+1,R1)   BYTES 29-35
         TR    FMT@HEXW(70),FMT#TABL          MAKE IT PRINTABLE HEX
         MVC   FMT@LINE,QBLANK                CLEAR OUTPUT LINE
         MVC   FMT@LINE+00(08),FMT@HEXW+00    MOVE FIRST WORD
         MVC   FMT@LINE+09(08),FMT@HEXW+08    MOVE SECOND WORD
         MVC   FMT@LINE+18(08),FMT@HEXW+16    MOVE THIRD WORD
         MVC   FMT@LINE+27(08),FMT@HEXW+24    MOVE FOURTH WORD
         MVC   FMT@LINE+36(08),FMT@HEXW+32    MOVE FIFTH WORD
         MVC   FMT@LINE+45(08),FMT@HEXW+40    MOVE SIXTH WORD
         MVC   FMT@LINE+54(08),FMT@HEXW+48    MOVE SEVENTH WORD
         MVC   FMT@LINE+63(08),FMT@HEXW+56    MOVE EIGHTH WORD
         MVC   FHEXID(80-(FHEXID-FCLEAR)),QBLANK   CLEAR OUTPUT LINE
         BR    R14                            RETURN TO MAINLINE
         SPACE 1
*---------------------------------------------------------------------*
*                                                                     *
* FMT$RJE - FORMAT REMOTE ID                                          *
*                                                                     *
* ENTRY: R14 - RETURN ADDRESS                                         *
*        R15 - @ ROUTE FIELD (4 BYTES)                                *
*                                                                     *
*---------------------------------------------------------------------*
         SPACE 1
FMT$RJE  STM   R14,R12,12(R13)
         L     R14,QCJQTL         @ MASTER CKPT RECORD
         LH    R14,$NODEID-$SAVEBEG(,R14) THIS NODE ID
         SLL   R14,16             MAKE LOCAL ID
         CL    R14,0(,R15)        IS THIS LOCAL?
         BE    FMT$RJE9           RIF LOCAL ROUTING
         LA    R3,FREMOTE         @ OUTPUT FIELD FOR REMOTE ID
         LA    R0,C'R'            ASSUME IS REMOTE
         CLM   R14,B'1100',0(R15) IS THIS MY NODE?
         BE    FMT$RJE3           BIF IS RNNN
         LA    R0,C'U'            ASSUME IS U TYPE
         SR    R14,R14
         CLM   R14,B'1100',0(R15) IS THIS NODE 0?
         BE    FMT$RJE3           BIF IS UNNN
         SPACE 1
*---             NODE IS N###R### FORMAT                           ---*
         LA    R0,C'N'            1ST ID IS N###
         LH    R1,0(,R15)         GET NODE ID
         BAL   R14,FMT$RJEC       CONVERT NODE ID
         LA    R0,C'R'            RESET IS R###
FMT$RJE3 LH    R1,2(,R15)
         BAL   R14,FMT$RJEC       CONVERT OTHER ID
FMT$RJE9 LM    R14,R12,12(R13)
         BR    R14
         SPACE 1
FMT$RJEC CVD   R1,120(,R13)       CONVERT TO DEC
         MVC   128(6,R13),=X'402020202120' EDIT MASK
         LA    R1,128+5(,R13)
         LR    R2,R1
         EDMK  128(6,R13),120+5(R13)
         SR    R2,R1              LENGTH -1 OF NUMBER
         STC   R0,0(,R3)          SET TYPE ID
         EX    R2,FMT$RJEM        MVC 1(0,R3),0(R1)
         LA    R3,1+1(R2,R3)      BUMP OUTPUT PTR
         BR    R14
FMT$RJEM MVC   1(0,R3),0(R1)      * EXECUTED *
         SPACE 1
         LTORG
ED5      DC    X'402020202021'
ED3      DC    X'40202021'
FMT#HEAD DC    CL80'QUEUE POS  JOBNAME   JOB#  PRI LINES  EXEC  HOLD  P$
               RT   FORM FCB  UCS   RJE '
FMT#TABL EQU   *-C'0'
         DC    C'0123456789ABCDEF'      TRANSLATE TO PRINTABLE HEX
FMT@WORK DC    0D'0'
FMT@CONV DS    0D                       CONVERT WORK DOUBLEWORD
FMT@HEXW DS    CL71                     HEX WORK AREA
FMT@LINE DS    CL80                     HEX OUTPUT AREA
         SPACE 1
         DROP  R10,R9,R8
    TITLE '--- QUEUE/SP --HELP -- DISPLAY HELP ---'
*---------------------------------------------------------------------*
*                                                                     *
* HELP - HELP COMMAND ROUTINE (DISPLAYS HELP INFORMATION)             *
*                                                                     *
*---------------------------------------------------------------------*
         SPACE 1
HELP     QSTART ,
         L     R10,QVDSPL               ADDR OF DISPLAY WORK AREA
         USING QDISPLAY,R10             BASE REG FOR DISPLAY WORK AREA
         SPACE 1
         MVC   QDHLINE,HEADING1         MOVE HEADING
         QCALL DISPLAY,HELPMSG1,HMSG1LEN
         QCALL DISPLAY,HELPMSG2,HMSG2LEN
         LA    R0,HMSG3LEN
         TM    QXAUTH,1                 IS THE USER PRIVILEGED?
         BNO   *+6                      NO. SKIP.
         LA    R0,HMSG3LNX              LONGER MESSAGE
         L     R1,=A(HELPMSG3)
         QCALL DISPLAY,(R1),(R0)        DISPLAY THE LINE
         L     R1,=A(HELPMSG4)
         QCALL DISPLAY,(R1),HMSG4LEN
         MVC   QDHLINE,HEADING4         MOVE HEADING4              ICBC
         QSTOP ,
         DROP  R12
         SPACE 1
         LTORG ,
         EJECT
HEADING1 $     'THE FOLLOWING SUBCOMMANDS ARE SUPPORTED:'
HEADING4 $     'THE PF KEYS ARE DEFINED AS FOLLOWS:'               ICBC
         SPACE 2
HELPMSG1 DC    CL4' '                   INDENT THE FOLLOWING 4 SPACES
 $ 'STATUS <LEVEL> - DISPLAY ALL JOBS BEGINNING WITH <LEVEL>'
 $ 'DA             - DISPLAY ALL JOBS IN EXECUTION'
 $ 'DI     <CLASS> - DISPLAY ALL JOBS IN INPUT <CLASS>'
 $ 'DO     <CLASS> - DISPLAY ALL JOBS IN OUTPUT <CLASS>'
 $ 'AI     <CLASS> - DISPLAY JOBS AVAILABLE FOR PROCESSING IN <CLASS>'
 $ 'AO     <CLASS> - DISPLAY JOBS AVAILABLE FOR PRINTING/PUNCHING IN <C$
               LASS>'
 $ 'HI     <CLASS> - DISPLAY HELD JOBS IN INPUT <CLASS>'
 $ 'HO             - DISPLAY HELD OUTPUT JOBS'
 $ 'DJ     <JOBID> - DISPLAY JOB BY JOBNAME OR JOBNUMBER'
 $ 'DT             - DISPLAY TSO USERS'
 $ 'DS             - DISPLAY SYSTEM TASKS'
 $ 'END            - TERMINATE PROCESSING'
 $ '     '
 $ 'DEFAULT FOR <LEVEL> IS LOGON ID'
 $ 'DEFAULT FOR <CLASS> IS ALL CLASSES'
 $ 'NO DEFAULT FOR <JOBID>'
 $ 'A <JOBID> OF * INDICATES USE PREVIOUSLY ENTERED <JOBID>'
 $ '                              ',76  UNDO THE INDENT-BY-4
 $ 'NOTE:  WHEN YOU SEE *MORE* IN THE UPPER RIGHT-HAND CORNER OF THE SC$
               REEN, IT     '
 $ '       MEANS THAT MORE INFORMATION IS WAITING.  YOU MAY EITHER HIT $
               ENTER TO     '
 $ '       VIEW IT, OR ENTER A NEW SUBCOMMAND TO SKIP IT.'
HMSG1LEN EQU   *-HELPMSG1
         SPACE 2
HELPMSG2 DC    CL4' '                   INDENT THE FOLLOWING 4 SPACES
 $ 'JCL    <JOBID>        - LIST JCL FOR A JOB'
 $ 'JLOG   <JOBID>        - LIST JOBLOG FOR A JOB (ONLY ON OUTPUT Q)'
 $ 'JMSG   <JOBID>        - LIST SYSTEM MESSAGES FOR A JOB'
 $ 'DD     <JOBID>        - LIST SYSIN AND SYSOUT DATASETS FOR A JOB'
 $ 'LIST   <JOBID> <DSID> - LIST A SYSIN OR SYSOUT DATASET'
 $ 'FIND   <STRING>       - FIND A CHARACTER STRING IN A DATASET'
 $ 'FALL   <STRING>       - FIND ALL OCCURRENCES OF <STRING>'
 $ 'COLUMN <COL>          - REPOSITION HORIZONTALLY TO COLUMN <COL>'
 $ '@      <#>            - REPOSITION TO SPECIFIC RECORD NUMBER'
 $ '+      <#>            - REPOSITION FORWARD IN DATASET <#> RECORDS'
 $ '-      <#>            - REPOSITION BACKWARD IN DATASET <#> RECORDS'
 $ 'TOP                   - REPOSITION TO TOP OF DATASET'
 $ 'BOTTOM                - REPOSITION TO BOTTOM OF DATASET'
 $ ' '
 $ 'DEFAULT FOR <COL> IS COLUMN 1        DEFAULT FOR <#> IS 0'
 $ 'NO DEFAULT FOR <JOBID>'
 $ 'A <JOBID> OF * INDICATES USE PREVIOUSLY ENTERED <JOBID>'
 $ '<DSID> CAN BE DETERMINED BY USING "DD" SUBCOMMAND'
 $ ' '
 $ 'FOLLOWING IS A LIST OF SYNONYMS:'
 $ 'LIST, L; FIND, F; COLUMN, C; +, D; -, UP; TOP, T; BOTTOM, B',76
HMSG2LEN EQU   *-HELPMSG2
         SPACE 2
HELPMSG3 DC    CL4' '                   INDENT THE FOLLOWING 4 SPACES
 $ ':     <TSOCMD>        - EXECUTE A TSO COMMAND'
 $ '*                     - RE-PROMPT WITH PREVIOUS COMMAND'
 $ 'SLOG  <JOB#> <SEQ>    - LIST THE SYSTEM LOG DATASET'
 $ 'FTIME <TIME>          - REPOSITION SYSTEM LOG TO GIVEN TIME'
 $ 'SAVE  <DSNAME> <DISP> - CREATE A COPY OF THE CURRENT DATASET'
 $ ' '
 $ '    <JOB#>   MAY BE DETERMINED BY "STATUS SYSLOG"'
 $ '    <SEQ>    DEFAULTS TO 0 (THE CURRENT SYSLOG DATASETS)'
 $ '             (USE A VALUE OF 1, 2, ... TO OBTAIN PREVIOUS DATASETS)$
               '
 $ '    <TIME>   IS IN THE FORM HH.MM.SS'
 $ '    <DSNAME> WILL BE EXPANDED TO ''USERID.<DSNAME>.OUTLIST'''
 $ '    <JOBID>  IS JOBNAME OR JOBNUMBER'
 $ '    <LEVEL>  IS JOBNAME PREFIX'
 $ '    <DSID>   IS DATASET ID NUMBER (FROM "DD" SUBCOMMAND)'
 $ '    <STRING> IS SEARCH STRING, DELIMITED BY ANY SAME CHAR AT EACH E$
               ND'
 $ '    <DISP>   IS OLD/MOD/NEW (DEFAULT=NEW)   ',76   UNDO THE INDENT
HMSG3LEN EQU   *-HELPMSG3
 $ 'PRIVILEGED SUBCOMMANDS:'
 $ '    XJ <JOBID>        - DISPLAY UNINTERPRETED JQES AND JOES'
 $ '    XL <JOBID> <DSID> - UNRESTRICTED DISPLAY OF DATASETS'
 $ '    XB <MTTR>         - DISPLAY BLOCK FROM SYS1.HASPACE'
HMSG3LNX EQU   *-HELPMSG3
         SPACE 2
HELPMSG4 DC    CL4' '                   INDENT THE FOLLOWING 4 SPACES
 $ '        _____________________________'                         ICBC
 $ '        ×PF1     ×PF2     ×PF3      ×'                         ICBC
 $ '        ×  HELP  ×  *     ×   END   ×'                         ICBC
 $ '        ×________×________×_________×'                         ICBC
 $ '        ×PF4     ×PF5     ×PF6      ×'                         ICBC
 $ '        ×   DA   ×  FIND  ×   DI    ×'                         ICBC
 $ '        ×________×________×_________×'                         ICBC
 $ '        ×PF7     ×PF8     ×PF9      ×'                         ICBC
 $ '        ×  - 21  ×  + 21  ×   DO    ×'                         ICBC
 $ '        ×________×________×_________×'                         ICBC
 $ '        ×PF10    ×PF11    ×PF12     ×'                         ICBC
 $ '        ×  COL 1 × COL 41 ×   ST    ×'                         ICBC
 $ '        ×________×________×_________×'                         ICBC
 $ ' '                                                             ICBC
 $ 'TO SPECIFY OPERANDS (FOR PF5, AND OPTIONALLY FOR PF6, 9, 12),' ICBC
 $ 'OR TO TEMPORARILY OVERRIDE THE DEFAULTS (FOR PF7, 8, 10, 11),' ICBC
 $ 'KEY IN THE VALUE AND PRESS THE APPROPRIATE PF KEY.',76         ICBC
HMSG4LEN EQU   *-HELPMSG4
         SPACE 2
         DROP  R10
     TITLE '--- QUEUE/SP --HEXBLK -- HEXADECIMAL DUMP OF A BLOCK ---'
HEXBLK   QSTART  Q9
         USING QCKPT,R10                BASE REG FOR CKPT WORK AREA
         L     R10,QVCKPT               LOAD BASE REG
         USING QDISPLAY,R9              BASE REG FOR DISPLAY WORK AREA
         L     R9,QVDSPL                LOAD BASE REG
***********************************************************************
*                                                                     *
*   VALIDATE AND CONVERT BLOCK ADDRESS                                *
*                                                                     *
***********************************************************************
         LH    R15,QLNG1                LENGTH OF USER PARM
         LTR   R15,R15                  IS THE LENGTH ZERO?
         BNP   HB$TILT                  YES. TILT.
         CH    R15,=H'8'                IS THE LENGTH TOO BIG?
         BH    HB$TILT                  YES. TILT.
         LR    R14,R15                  COPY THE LENGTH
         BCTR  R14,0                    -1 FOR EX
         EX    R14,HB$TRT               ALL VALID CHARACTERS?
         BNZ   HB$TILT                  NO - ABORT
         MVC   QPARM2,QPARM1            LEAVE THE ORIGINAL ALONE
         TR    QPARM2,TABLEH            CONVERT TO HEX
         EX    R15,HB$PACK              PACK INTO QCTRAK
***********************************************************************
*                                                                     *
*   READ THE BLOCK FROM HASPACE                                       *
*                                                                     *
***********************************************************************
         L     R2,QCBLKA                BLOCK IOAREA ADDR
         LH    R1,HASPACE+62            BLKSIZE FROM DCB
         BCTR  R1,0                     SUBTRACT 1
         N     R1,ROUND                 ROUND TO PREV. 64 BYTE BOUNDARY
         AR    R1,R2                    ADD BASE OF BUFFER
         MVC   0(64,R1),QBLANK          BLANK LAST 64 BYTES OF BUFFER
         LR    R1,R2                    PARM FOR READSPC
         MVI   QSYNADFL,0               INIT FLAG
         QCALL READSPC                  READ HASPACE
         CLI   QSYNADFL,0               WAS THERE AN ERROR?
         BNE   HB$IOERR                 YES - SAY SO
***********************************************************************
*                                                                     *
*   PRINT THE BLOCK                                                   *
*                                                                     *
***********************************************************************
*
*** NOTE - THIS ROUTINE ASSUMES A BLOCKSIZE OF 4008
*
         L     R3,QCIOTA                USE THE IOT AREA AS A WORK AREA
         MVC   QDHLINE,QBLANK           BLANK THE TITLE LINE
         USING IN,R2                    BASE REG FOR RAW BLOCK
         USING OUT,R3                   BASE REG FOR PRINTABLE LINES
         SR    R4,R4                    START OFFSET AT ZERO
HEXB$LP  MVC   OLINE1,QBLANK            BLANK THE WORK AREA
         MVC   O1,I1                    MOVE RECORD TO PRINT LINE
         MVC   O2,I2
         MVC   O3,I3
         MVC   O4,I4
         MVC   O5,I5
         MVC   O6,I6
         MVC   O7,I7
         MVC   O8,I8
         MVC   OLINE2,OLINE1            COPY INTO LINE2
         STH   R4,QPARM2                STORE OFFSET
         UNPK  HBOFFSET(5),QPARM2(3)    CONVERT TO HEX
         TR    HBOFFSET,TABLEP          TRANSLATE TO PRINTABLE
         MVI   HBOFFSET+4,C' '          CLEAR GARBAGE BYTE
         TR    ODATA1,TABLEU            TRANSLATE TO UPPER HEX
         TR    ODATA2,TABLEL            TRANSLATE TO LOWER HEX
         QCALL DISPLAY,(R3),160         DISPLAY THE LINE
         LR    R1,R2                    SAVE ADDR OF RECORD
HB$SKIP  LA    R2,64(R2)                NEXT RECORD
         LA    R4,64(R4)                INCREMENT TO NEXT OFFSET
         CH    R4,HASPACE+62            IS THIS THE END?
         BNL   HEXBSTOP                 YES. GO HOME.
         CLC   0(64,R1),0(R2)           THIS RECORD THE SAME AS PREV?
         BE    HB$SKIP                  YES. SKIP IT.
         B     HEXB$LP                  PRINT NEXT RECORD
***********************************************************************
*                                                                     *
*   SYNAD EXIT                                                        *
*                                                                     *
***********************************************************************
HEXBLKER MVI   QSYNADFL,255             SET SYNAD FLAG
         BR    R14                      RETURN TO READSPC VIA SYSTEM
***********************************************************************
*                                                                     *
*   EXCEPTIONS AND RETURN                                             *
*                                                                     *
***********************************************************************
HB$TILT  QTILT '*** BLOCK ADDRESS WAS OMITTED OR INVALID ***'
HB$IOERR CLI   QSYNADFL,255             REAL SYNAD ERROR?
         BE    HB$SYNAD
         QTILT '*** NOT IN HASPACE EXTENT ***'
HB$SYNAD QTILT '*** SYNAD ROUTINE ENTERED ***'
HEXBSTOP QSTOP
         SPACE 1
HB$PACK  PACK  QCTRAK(5),QPARM2(1) BLOCK ADDRESS
HB$TRT   TRT   QPARM1(*-*),TABLEV       << EXECUTED >>
ROUND    DC    0F'0',X'0000FFC0'
         LTORG
* TABLE FOR HEX CONVERT
TABLEH   DC    CL193' '
         DC    X'0A0B0C0D0E0F',CL41' ',C'01234567890',CL6' '
* TABLE FOR HEX UNCONVERT
TABLEP   EQU   *-240
         DC    C'0123456789ABCDEF'
* TABLE USED TO CONVERT TO UPPER HALF OF PRINTABLE HEX
TABLEU   DS    0CL256
*                0123456789ABCDEF
         DC    C'0000000000000000'
         DC    C'1111111111111111'
         DC    C'2222222222222222'
         DC    C'3333333333333333'
         DC    C' 4444444444.<(+×'
         DC    C'&&5555555555$*);^'
         DC    C'-/666666666,%_>?'
         DC    C'7777777777:#@''="'
         DC    C'8888888888888888'
         DC    C'9999999999999999'
         DC    C'AAAAAAAAAAAAAAAA'
         DC    C'BBBBBBBBBBBBBBBB'
         DC    C'CABCDEFGHICCCCCC'
         DC    C'DJKLMNOPQRDDDDDD'
         DC    C'EESTUVWXYZEEEEEE'
         DC    C'0123456789FFFFFF'
* TABLE USED TO CONVERT TO LOWER HALF OF PRINTABLE HEX
TABLEL   DS    0CL256
*                0123456789ABCDEF
         DC    C'0123456789ABCDEF'
         DC    C'0123456789ABCDEF'
         DC    C'0123456789ABCDEF'
         DC    C'0123456789ABCDEF'
         DC    C' 123456789A     '
         DC    C' 123456789A     '
         DC    C'  23456789A     '
         DC    C'0123456789      '
         DC    C'0123456789ABCDEF'
         DC    C'0123456789ABCDEF'
         DC    C'0132456789ABCDEF'
         DC    C'0123456789ABCDEF'
         DC    C'0         ABCDEF'
         DC    C'0         ABCDEF'
         DC    C'01        ABCDEF'
         DC    C'          ABCDEF'
* TABLE USED TO VERIFY HEX OPERAND
TABLEV   DC    256X'FF'
         ORG   TABLEV+C'A'
         DC    6X'00'
         ORG   TABLEV+C'0'
         DC    10X'00'
         ORG   ,
* INPUT WORK AREA
IN       DSECT
I1       DS    CL8
I2       DS    CL8
I3       DS    CL8
I4       DS    CL8
I5       DS    CL8
I6       DS    CL8
I7       DS    CL8
I8       DS    CL8
* OUTPUT WORK AREA
OUT      DSECT
OLINE1   DS    0CL80
HBOFFSET DS    CL4
         DS    CL2
ODATA1   DS    0CL74
O1       DS    CL8
         DS    C
O2       DS    CL8
         DS    CL2
O3       DS    CL8
         DS    C
O4       DS    CL8
         DS    CL2
O5       DS    CL8
         DS    C
O6       DS    CL8
         DS    CL2
O7       DS    CL8
         DS    C
O8       DS    CL8
OLINE2   DS    0CL80
         DS    CL6
ODATA2   DS    CL74
         SPACE 3
QUEUE    CSECT ,
         DROP  R10,R9,R2,R3
    TITLE '--- QUEUE/SP --INIT -- INITIALIZATION ROUTINES ---'
INIT     QSTART ,
         L     R10,QVDAIR               LOAD BASE REG
         USING QDAIR,R10                BASE REG FOR DAIR WORK
         L     R9,QVCKPT                LOAD BASE REG
         USING QCKPT,R9                 BASE REG FOR CKPT WORK
         L     R8,QVDSPL                LOAD BASE REG
         USING QDISPLAY,R8              BASE REG FOR DISPLAY WORK
         SPACE 1
*---              MOVE PARMS FROM CPPL TO DAPL                     ---*
         USING CPPL,R2                  ADDR OF CPPL IS IN R2
         MVC   DAPLUPT,CPPLUPT          USER PROFILE TABLE
         MVC   DAPLPSCB,CPPLPSCB        PROTECTED STORAGE CNTL BLK
         MVC   DAPLECT,CPPLECT          ENVIRONMENT CNTL TABLE
         SPACE 1
*---           LOCATE LOGON ID, SAVE FOR FUTURE REFERENCE          ---*
         L     R1,CPPLPSCB              -> PSCB
         USING PSCB,R1
         MVC   QLOGON(7+1),PSCBUSER     SAVE TSO USERID AND LENGTH
         MVC   QSTKEY(7),QLOGON         SET SEARCH KEY FOR "ST"
         MVI   QSTKEY+7,C' '            FIX LAST BYTE
*MAS1 QUEUE COMMAND IS IN PROTECTED LIBRARY - NO CHECK REQUIRED...
*MAS1    TM    PSCBATR1,PSCBACCT        ACCOUNT COMMAND AUTHORITY?
*MAS1    BNO   *+8                      NO - SKIP
         OI    QXAUTH,1                 YES - AUTOMATICALLY AUTHORIZED
         DROP  R1
         SPACE 1
*---           MOVE COMMAND BUFFER TO REPLY BUFFER                 ---*
         L     R1,CPPLCBUF              ADDR OF COMMAND BUFFER
         DROP  R2                       DONE WITH THIS REGISTER
         LH    R3,0(,R1)                LENGTH OF COMMAND BUFFER
         LH    R4,2(,R1)                OFFSET TO FIRST DATA BYTE
         LA    R1,4(R1,R4)              FIRST DATA BYTE
         SR    R3,R4                    SUBTRACT OFFSET FROM LENGTH
         SH    R3,=H'4'                 SUBTRACT OVERHEAD
         SH    R3,=H'1'                 IS LENGTH ZERO?
         BM    INT$SKIP                 YES. SKIP IT.
         EX    R3,OCBUF                 TRANSLATE TO UPPER CASE
         MVC   QDREPLY,QBLANK           BLANK THE REPLY LINE
         CH    R3,=Y(QDREPLYL-1)        IS LENGTH OVER MAX?
         BNH   *+8                      NO. USE IT.
         LA    R3,QDREPLYL-1            USE MAXIMUM LENGTH
         EX    R3,MVCBUF                MOVE THE DATA
         LA    R3,1(,R3)                INCREMENT TO TRUE LENGTH
         STH   R3,QDRLNG                STORE REPLY LENGTH
         SPACE 1
*---           GETMAIN BLOCK ADDR TABLE FOR LISTDS                 ---*
INT$SKIP GETMAIN R,LV=65536,SP=1
         ST    R1,QCSTART               STORE STARTING ADDR OF TABLE
         A     R1,=F'65536'             END OF TABLE
         ST    R1,QCEND
         SPACE 1
*-----------------------------------------------------------------*MAS1
*                                                                 *MAS1
*     IF HASPCKPT ALREADY ALLOCATED USE IT                        *MAS1
*      AND USE IT'S DATASET NAME PREFIX FOR HASPACE               *MAS1
*     (THIS ALLOWS ALTERNATE CKPT OR TEST JES)                    *MAS1
*                                                                 *MAS1
*-----------------------------------------------------------------*MAS1
         SPACE 1                                                   MAS1
         RDJFCB (INT#DCB)         GET JFCB IF ANY                  MAS1
         LTR   R15,R15            ANY JFCB?                        MAS1
         BNZ   INT$CKTP           BIF NO JFCB, ALLOC CKPT          MAS1
         LA    R15,INT#JFCB                                        MAS1
         LA    R0,44                                               MAS1
INT$CLP  CLI   0(R15),C'.'                                         MAS1
         BE    INT$CLL                                             MAS1
         LA    R15,1(,R15)                                         MAS1
         BCT   R0,INT$CLP                                          MAS1
         B     INT$CKTP                                            MAS1
INT$CLL  LA    R1,INT#JFCB                                         MAS1
         SR    R15,R1             LENGTH OF PREFIX                 MAS1
         BCTR  R15,0              GET EX LENGTH                    MAS1
         MVC   DSNSPACE+2(44),=CL44' ' BLANK OUT DSN               MAS1
         EX    R15,INT$CMVC       MVC DSNSPACE+2(0),INT#JFCB       MAS1
         LA    R1,DSNSPACE+2+1(R15)                                MAS1
         MVC   0(08,R1),=C'.HASPACE'  FINISH SPACE NAME            MAS1
         LA    R15,8+1(,R15)      HASPACE NAME LENGTH              MAS1
         STH   R15,DSNSPACE       SAVE NAME LENGTH                 MAS1
         B     INT$CHAV           AND GO USE CKPT                  MAS1
INT$CMVC MVC   DSNSPACE+2(0),INT#JFCB                              MAS1
         SPACE 1                                                   MAS1
INT#DCB  DCB    MACRF=E,DSORG=PS,EXLST=INT#ELST,DDNAME=JES2CKPT    MAS1
INT#ELST DC     0F'0',X'87',AL3(INT#JFCB)                          MAS1
INT#JFCB DC     0D'0',XL176'00'                                    MAS1
         SPACE 1                                                   MAS1
*---                ALLOCATE HASPCKPT                              ---*
INT$CKTP MVC   DA08PDSN,=A(DSNCKPT)     DSNAME FOR ALLOCATE
         MVI   DAIRFLAG,X'08'           REQUEST ALLOCATE FUNCTION
         QCALL ALLOCATE                 CALL DAIR
         MVC   HASPCKPT+40(8),DA08DDN   GET DDNAME DAIR RETURNED
         SPACE 1
*---      OPEN HASPCKPT AND READ MASTER RECORD (RECORD 3)          ---*
INT$CHAV DEVTYPE HASPCKPT+40,IT#DEVTB,DEVTAB,RPS GET CKPT DEV INFO
         L     R3,IT#DEVTB+4      MAX BLKSIZE FOR DEVICE
         STH   R3,HASPCKPT+62      SET IN CKPT DCB
         SPACE 1
         LA    R3,IT#DEVTB+8      @ DEVTYPE INFO FOR TRKCALC
         L     R4,=X'01001000'    # OF 4K BLOCKS / TRK
         TRKCALC FUNCTN=TRKCAP,DEVTAB=(R3),RKDD=(R4),                  X
               REGSAVE=YES
         ST    R0,IT#CKRT         SAVE # 4K BLK/TRK ON CKPT
         SPACE 1
         OPEN  MF=(E,HOCKPT)      OPEN HASPCKPT
         SPACE 1
*---         GETMAIN DECB WORK AREA FOR CKPT ROUTINE               ---*
         SR    R0,R0
         IC    R0,DCBNCP-IHADCB+HASPCKPT NCP VALUE FROM DCB
         MH    R0,=Y(HDECB1L)     * LENGTH OF EACH DECB
         O     R0,=AL1(1,0,0,0)   SUBPOOL 1
         GETMAIN R,LV=(0)
         ST    R1,QCDECBPT        SAVE @ DECB WORK AREA FOR CKPT
         L     R2,QCSTART         USE TABLE AREA FOR IOAREA
         L     R1,HOCKPT          @ DCB
         POINT (1),QCMSTTR        POINT PAST SYNC RECORDS
         SPACE 1
         READ  HDECB1,SF,,(R2),'S',MF=E READ MASTER RECORD
         SPACE 1
         CHECK HDECB1
         SPACE 1
*---        COMPUTE OFFSET TO FIRST PDDB IN IOT                    ---*
         USING $SAVEBEG,R2              BASE REG FOR CHECKPOINT
         LH    R5,$NUMTG                # OF TRACK GROUPS
         LA    R5,7(,R5)                ROUND UP TO FULL BYTES
         SRL   R5,3                     TGM SIZE IN BYTES
         LR    R1,R5                    SAVE LENGTH OF TRACK GROUP MAP
         LA    R5,IOTTGMAP-IOTSTART+TGMAP-TGMDSECT+3(,R5)   OFFSET
         N     R5,=F'-4'                ROUND TO FULL WORD BOUNDARY
         ST    R5,QCPDDB1               SAVE OFFSET TO 1ST PDDB IN IOT
         SPACE 1
*---         FIND KIT AREA IN MASTER RECORD                        ---*
         L     R3,$MASTERL        LENGTH OF MASTER RECORD
         AR    R3,R2              @ PAST END OF MASTER RECORD
         SH    R3,=Y(KITLNGTH)    @ LAST KIT
         ST    R3,IT#KITL         SAVE @ OF LAST KIT
         USING KITDSECT,R3
IT$KIT1L CLC   KITORG,=F'0'       THIS FIRST KIT?
         BE    IT$KIT1F
         SH    R3,=Y(KITLNGTH)    BACK UP ONE KIT
         B     IT$KIT1L
         DROP  R3
IT$KIT1F ST    R3,IT#KITF         SAVE @ FIRST KIT
         SPACE 1
*---         FIND JQE TABLE BLOCK #; # OF BLOCKS                   ---*
         L     R0,=CL4'JQE '      ID FOR JQE'S
         BAL   R14,IT$KITFD       SEARCH KIT FOR JQE SLOT
         B     IT$DIE1            BIF SYSTEM HAS NO JQE'S
         USING KITDSECT,R1
         LH    R6,KITRECN         # OF BLOCKS OF JOE'S
         ST    R6,QCJQENUM        SAVE # BLOCKS OF JQE'S
         BAL   R14,IT$CKTTR       COMPUTE TTR OF JQE'S
         DROP  R1
         ST    R1,QCJQETTR        SAVE TTR OF JQE'S
         SPACE 1
*---         FIND JOE TABLE BLOCK #; # OF BLOCKS                   ---*
         L     R0,=CL4'JOE '      ID FOR JOE'S
         BAL   R14,IT$KITFD       SEARCH KIT FOR JQE SLOT
         B     IT$DIE2            BIF SYSTEM HAS NO JQE'S
         USING KITDSECT,R1
         LH    R3,KITRECN         # OF BLOCKS OF JOE'S
         ST    R3,QCJOENUM        SAVE # OF BLOCKS OF JOE'S
         BAL   R14,IT$CKTTR       COMPUTE TTR OF JOE'S
         DROP  R1
         ST    R1,QCJOETTR        SAVE TTR OF JOE'S
         SPACE 1
*---        SAVE ALL SYSTEM ID'S IN COMPLEX                        ---*
         LH    R0,$QSENO                NUMBER OF QSE'S
         LA    R1,QSYSID                OUTPUT @ FOR SYSTEM ID'S
         LA    R15,$SAVEEND             @ 1ST QSE
         USING QSEDSECT,R15
IT$QSELP MVC   0(L'QSESID,R1),QSESID    SAVE SYSTEM ID
         LA    R1,L'QSYSID(,R1)
         LA    R15,QSELEN(,R15)
         BCT   R0,IT$QSELP
         DROP  R15
         SPACE 1
*---        COMPUTE HASPACE BUFFER SIZE                            ---*
         LH    R5,$BUFSIZE              BLKSIZE FOR HASPACE
         STH   R5,HASPACE+62            STORE IN DCB
         STH   R5,HDECB2+6              STORE IN DECB
         LA    R5,63(R5)                PREPARE TO ROUND
         N     R5,=F'-64'               ROUND TO 64 BYTE BOUNDARY
         SPACE 1
*---        GETMAIN BUFFERS FOR HASPCKPT AND HASPACE               ---*
         L     R6,$MASTERL        LENGTH OF MASTER RECORD
         LA    R6,4095(,R6)       ROUND UP TO 4K BOUNDARY
         N     R6,=F'-4096'
         L     R7,QCJQENUM        # OF JQE CKPT BLOCKS
         SLL   R7,12              LENGTH OF JQE CKPT AREA
         L     R8,QCJOENUM        # OF JOE CKPT BLOCKS
         SLL   R8,12              LENGTH OF JOE CKPT AREA
         LR    R14,R5             HASPACE BUFFER SIZE
         MH    R14,=H'3'          3 BUFFERS
         AR    R14,R6             + ROUNDED MASTER RECORD
         AR    R14,R7             + JQE CKPT AREA
         AR    R14,R8             + JOE CKPT AREA
         LA    R0,256(,R14)       + SLOP
         O     R0,=AL1(1,0,0,0)   SUBPOOL 1
         GETMAIN R,LV=(0)         GET STORAGE FOR BUFFERS
         ST    R1,QCJQTL          @ MASTER CKPT RECORD
         AR    R1,R6              + ROUNDED LENGTH MASTER CKPT RECORD
         ST    R1,QCJQTA          @ JQE CKPT INFO
         AR    R1,R7              + LENGTH OF JQE CKPT INFO
         ST    R1,QCJOTA          @ JOE CKPT INFO
         AR    R1,R8              + LENGTH OF JOE CKPT INFO
         ST    R1,QCJCTA          @ JCT BUFFER
         AR    R1,R5              + SPOOL BUFFER SIZE
         ST    R1,QCIOTA          @ IOT BUFFER
         AR    R1,R5              + SPOOL BUFFER SIZE
         ST    R1,QCBLKA          @ DATA BUFFER BLOCK
         LA    R1,$JQHEADS-$SAVEBEG  OFFSET TO JQE QUEUES IN MASTER REC
         A     R1,QCJQTL          + @ MASTER RECORD
         ST    R1,QCJQHEAD        @ JQE JOB QUEUES
         SPACE 1
*---               ALLOCATE AND OPEN HASPACE                          *
         SPACE 1
         LH    R1,$QSENO          # OF QSE'S
         MH    R1,=Y(QSELEN)      * LENGTH OF EACH QSE
         AH    R1,$CKRECN         + TOTAL # 4K CKPT RECORDS
         LA    R3,$SAVEEND(R1)    @ OF DA CKPT INFO IN MASTER RECORD
         MVC   DA08PDSN,=A(DSNSPACE) DSNAME FOR ALLOCATE
         LA    R4,$MAXDA          MAX SPOOL VOLUMES
         LA    R7,QCDCBL          LENGTH OF HASPACE DCB
         MR    R6,R4              COMPUTE LENGTH OF DCB POOL
         GETMAIN R,LV=(R7),SP=1   GET SPACE FOR DCB POOL
         LR    R7,R1              SAVE ADDR OF DCB POOL
         LA    R8,QCSPOPNL-4      ADDR OF OPEN LIST
         SR    R6,R6              ACTUAL NUMBER OF SPOOL VOLUMES
         MVC   DA08SER(5),$SPOOL  PATTERN FOR VOLSER
         MVI   DAIRFLAG,X'08'     REQUEST ALLOCATE FUNCTION
         SPACE 1
IT$SP1   CLI   0(R3),0            IS THIS VOLUME UNUSED?
         BE    IT$SP2             BIF UNUSED, TRY NEXT
         MVC   DA08UNIT,=CL8'SYSALLDA' UNIT NAME FOR ALLOC
         MVC   DA08SER+5(1),1(R3) LAST DIGIT OF VOLSER
         LA    R6,1(R6)           INCREASE COUNT BY ONE
         QCALL ALLOCATE           CALL DAIR
         MVC   0(QCDCBL,R7),HASPACE  MOVE PATTERN DCB TO POOL
         MVC   40(8,R7),DA08DDN   UPDATE THE DDNAME
         ST    R7,4(R8)           STORE DCB ADDR IN OPEN LIST
         DEVTYPE 40(,R7),IT#DEVTB,DEVTAB,RPS GET HASPACE DEV INFO
         LR    R15,R6             DCB # TO R15 (ORIGIN 1)
         SLL   R15,2              * 4 FOR OFFSET INTO QCSPDCBP
         ST    R7,QCSPDCBP-4(R15) SAVE DCB ADDR FOR MTTR CONVERT
         LH    R0,IT#DEVTB+10     # OF TRACKS / CYLINDER
         ST    R0,QCSPNMTC-4(R15) SAVE # TRKS/CYL FOR THIS HASPACE
         LA    R7,QCDCBL(R7)      INCREMENT TO NEXT DCB
         LA    R8,4(R8)           NEXT ENTRY IN OPEN LIST
IT$SP2   LA    R3,6(R3)           NEXT VOLUME
         BCT   R4,IT$SP1          BIF MORE VOLUMES
         OI    0(R8),X'80'        MARK END OF OPEN LIST
         OPEN  MF=(E,QCSPOPNL)    OPEN HASPACE
         QSTOP ,
         EJECT ,
*---------------------------------------------------------------------*
*                                                                     *
*  IT$KITFD - FIND SELECTED KIT                                       *
*                                                                     *
* ENTRY: R0  - CHAR ID STRING (CL4 IN REG)                            *
*        R14 - RETURN ADDRESS                                         *
*                                                                     *
* EXIT:  R1  - @ OF KIT (IF RETURN 4(,R14); ELSE NOT FOUND)           *
*                                                                     *
*---------------------------------------------------------------------*
         SPACE 1
IT$KITFD L     R1,IT#KITF         @ FIRST KIT
         USING KITDSECT,R1
IT$KITFL CL    R0,KITID
         BE    4(,R14)            RIF SELECTED KIT FOUND
         LA    R1,KITLNGTH(,R1)   @ NEXT KIT IF ANY
         C     R1,IT#KITL         @ LAST KIT
         BNH   IT$KITFL           BIF WAS NOT LAST KIT
         BR    R14                RIF KIT NOT FOUND
         DROP  R1                 (KITDSECT)
         SPACE 1
*---------------------------------------------------------------------*
*                                                                     *
*  IT$CKTTR - COMPUTE CKPT TTR OF GROUP OF BLOCKS FROM KITORG         *
*                                                                     *
* ENTRY: R1  - @ KITDSECT                                             *
*        R14 - RETURN ADDRESS                                         *
*                                                                     *
* EXIT:  R1  - TTR0 OF THIS GROUP ON CKPT                             *
*                                                                     *
*---------------------------------------------------------------------*
         SPACE 1
         USING KITDSECT,R1
IT$CKTTR L     R1,KITORG          GET ORIGIN IN BYTES OF THIS GROUP
         DROP  R1
         SRL   R1,12              ORG TO # OF BLOCKS
         SR    R0,R0
         D     R0,IT#CKRT         / # 4K BLOCKS/TRK ON CKPT DEVICE
         SLL   R1,8               POSITION TT IN R1
         OR    R1,R0              BUILD TTR IN R1
         AL    R1,=X'00000101'    SKIP 1ST TRK/RECORD ORIGIN 1
         SLL   R1,8               NOW TTR0
         BR    R14
         SPACE 1
IT$DIE1  EX    0,*
IT$DIE2  EX    0,*
         SPACE 1
OCBUF    OC    0(0,R1),QBLANK     * EXECUTED * CMD TO UPPER CASE
MVCBUF   MVC   QDREPLY(0),0(R1)   * EXECUTED * CMD TO REPLY BUFFER
         SPACE 1
IT#KITF  DC    A(0)               @ FIRST KIT AT INIT TIME
IT#KITL  DC    A(0)               @ LAST KIT AT INIT TIME
IT#DEVTB DC    6F'0'              CKPT DEVICE DEVTYPE INFO
IT#CKRT  DC    F'0'               4K BLOCKS/TRK ON CKPT DEVICE
         LTORG ,
         SPACE 1
         DS    0F
DSNCKPT  DC    H'13',CL44'SYS1.HASPCKPT'
DSNSPACE DC    H'12',CL44'SYS1.HASPACE'
         SPACE 3
         DROP  R10,R9,R8,R2
     TITLE '--- QUEUE/SP --JCL -- LIST THE JCL FOR A JOB ---'
JCL      QSTART  Q11
***********************************************************************
*                                                                     *
*   CALL FINDJOB TO LOCATE THE JQE, JCT, AND IOT                      *
*                                                                     *
***********************************************************************
         QCALL FINDJOB                  FIND THE JOB
***********************************************************************
*                                                                     *
*   CALL LISTDS TO LIST THE DATASET                                   *
*                                                                     *
***********************************************************************
         MVC   QPOFFSET,=H'10'          PRINT OFFSET FOR EACH RECORD
         MVC   QPDSID,=H'3'             DSID OF DATASET TO BE PRINTED
         QCALL LISTDS
         QSTOP
         SPACE 2
         LTORG
     TITLE '--- QUEUE/SP --JLOG -- LIST THE JOBLOG MSGS FOR A JOB ---'
JLOG     QSTART  Q12
         USING QCKPT,R10                BASE REG FOR CKPT WORK AREA
         L     R10,QVCKPT               LOAD BASE REG
***********************************************************************
*                                                                     *
*   CALL FINDJOB TO LOCATE THE JQE, JCT, AND IOT                      *
*                                                                     *
***********************************************************************
         QCALL FINDJOB                  FIND THE JOB
***********************************************************************
*                                                                     *
*   ONLY PROCESS JOB IF IT IS ON THE OUTPUT QUEUE                     *
*                                                                     *
***********************************************************************
         L     R2,QCJQEA                ADDR OF JQE FOR THIS JOB
         USING JQEDSECT,R2              BASE REG FOR JQE
         CLI   JQETYPE,$HARDCPY         IS THE JOB ON THE OUTPUT QUEUE?
         BNE   JL$TILT                  NO. INFORM THE USER.
***********************************************************************
*                                                                     *
*   CALL LISTDS TO LIST THE DATASET                                   *
*                                                                     *
***********************************************************************
         MVC   QPOFFSET,=H'0'           PRINT OFFSET FOR EACH RECORD
         MVC   QPDSID,=H'2'             DSID OF DATASET TO BE PRINTED
         QCALL LISTDS
         QSTOP
JL$TILT  QTILT '*** JOBLOG IS NOT AVAILABLE ***'
         LTORG
         SPACE 3
         DROP  R10,R2
    TITLE '--- QUEUE/SP --JMSG -- LIST THE SYSTEM MSGS FOR A JOB ---'
JMSG     QSTART  Q13
***********************************************************************
*                                                                     *
*   CALL FINDJOB TO LOCATE THE JQE, JCT, AND IOT                      *
*                                                                     *
***********************************************************************
         QCALL FINDJOB                  FIND THE JOB
***********************************************************************
*                                                                     *
*   CALL LISTDS TO LIST THE DATASET                                   *
*                                                                     *
***********************************************************************
         MVC   QPOFFSET,=H'0'           PRINT OFFSET FOR EACH RECORD
         MVC   QPDSID,=H'4'             DSID OF DATASET TO BE PRINTED
         QCALL LISTDS
         QSTOP
         SPACE 2
         LTORG
    TITLE '--- QUEUE/SP --LIST -- PRINT A DS FROM SPOOL BY ID ---'
LIST     QSTART  Q14
         USING QCKPT,R10                BASE REG FOR CKPT WORK AREA
         L     R10,QVCKPT               LOAD BASE REG
***********************************************************************
*                                                                     *
*   CALL FINDJOB TO LOCATE THE JQE, JCT, AND IOT                      *
*                                                                     *
***********************************************************************
         QCALL FINDJOB                  FIND THE JOB
***********************************************************************
*                                                                     *
*   ENSURE JOBNAME BEGINS WITH USER ID                                *
*                                                                     *
***********************************************************************
         L     R9,QCJCTA                ADDR OF JCT
         USING JCTSTART,R9              BASE REG FOR JCT
         IC    R2,QLOGONL               GET LENGTH OF USERID
         BCTR  R2,0                     -1 FOR EX
         TM    QXAUTH,1                 IS THIS AN AUTHORIZED USER?
         BO    *+12                     YES - THE JOBNAME IS VALID.
         EX    R2,LIST$CLC              IS THE JOBNAME VALID?
         BNE   L$TILT2                  NO. TILT.
***********************************************************************
*                                                                     *
*   CHECK AND CONVERT THE DATASET ID NUMBER                           *
*                                                                     *
***********************************************************************
         LH    R1,QLNG2                 LENGTH OF DATASET ID FIELD
         SH    R1,=H'1'                 DATASET ID FIELD ZERO LENGTH?
         BM    L$TILT                   YES. QUIT.
         LA    R15,QPARM2               POINT TO PARM
         BAL   R14,QNUMCONV             CONVERT IT
         BNE   L$TILT                   QUIT IF NOT NUMERIC
         CLI   QSUBNAME,C'X'            "XL" COMMAND?
         BE    *+12                     YES - SKIP NEXT VALIDITY CHECK
         CH    R15,=H'101'              DATASET ID LESS THAN 101?
         BL    L$TILT                   YES. TILT.
         STH   R15,QPDSID               STORE DATASET ID
***********************************************************************
*                                                                     *
*   CHECK AND CONVERT THE PRINT OFFSET                                *
*                                                                     *
***********************************************************************
         MVC   QPOFFSET,=H'0'           DEFAULT TO ZERO
         LH    R2,QLNG3                 LENGTH OF OFFSET FIELD
         SH    R2,=H'1'                 OFFSET FIELD ZERO LENGTH?
         BM    L$CALIST                 YES. USE ZERO OFFSET.
         LA    R15,QPARM3               POINT TO PARM
         BAL   R14,QNUMCONV             CONVERT IT
         BNE   L$TILT                   QUIT IF NOT NUMERIC
         STH   R15,QPOFFSET             STORE OFFSET
***********************************************************************
*                                                                     *
*   CALL LISTDS TO LIST THE DATASET                                   *
*                                                                     *
***********************************************************************
L$CALIST QCALL LISTDS
         QSTOP
L$TILT   QTILT '*** DATASET ID INVALID ***'
L$TILT2  QTILT '*** JOBNAME MUST BEGIN WITH USERID ***'
         SPACE 1
LIST$CLC CLC   QLOGON(*-*),JCTJNAME     << EXECUTED >>
         LTORG
         SPACE 3
         DROP  R10,R9
   TITLE '--- QUEUE/SP --LISTDS -- LIST A DS FROM THE SPOOL PACK ---'
LISTDS   QSTART  Q15
         USING QCKPT,R10                BASE REG FOR CHECKPT WORK AREA
         L     R10,QVCKPT               LOAD BASE REG
         USING QDISPLAY,R9              BASE REG FOR DISPLAY WORK AREA
         L     R9,QVDSPL                LOAD BASE REG
***********************************************************************
*                                                                     *
*   DETERMINE FUNCTION REQUESTED                                      *
*                                                                     *
***********************************************************************
         CLI   QCODE,0                  IS REQUEST FOR REPOSITIONING?
         BNE   LD$REPOS                 YES. DO IT.
***********************************************************************
*                                                                     *
*   LOCATE PDDB FOR DATASET SPECIFIED IN QPDSID                       *
*                                                                     *
***********************************************************************
NORMAL   MVI   SWITCH,0                 INITIALIZE SWITCH
         USING PDBDSECT,R2              BASE REG FOR PDDB
         USING IOTSTART,R3              BASE REG FOR IOT
         L     R3,QCIOTA                LOAD BASE REG
         LR    R5,R3                    IOAREA FOR READ IOT BLOCK
NEXTIOT  LR    R4,R3                    BASE OF IOT
         A     R4,IOTPDDBP              OFFSET BEYOND LAST PDDB
         LR    R2,R3                    BASE OF IOT
         A     R2,QCPDDB1               OFFSET TO FIRST PDDB IN IOT
LD$DS$LP CLC   QPDSID,PDBDSKEY          IS THIS THE DATASET?
         BE    FOUNDDS2                 YES. CONTINUE.
         LA    R2,PDBLENG(R2)           NO. LOOK AT NEXT PDDB.
         CR    R2,R4                    HAVE WE PAST THE LAST PDDB?
         BL    LD$DS$LP                 NO. TRY AGAIN.
         L     R4,IOTIOTTR              DISK ADDR OF NEXT IOT
SPIN     LTR   R4,R4                    IS THERE ANOTHER IOT?
         BZ    SPINIOT                  NO. TRY THE SPIN IOT?
         BAL   R8,LDS$READ              READ THE IOT
         B     NEXTIOT                  SEARCH THE NEXT IOT
         USING JCTSTART,R1              BASE REG FOR JCT
SPINIOT  TM    SWITCH,1                 SPIN IOT SEARCHED YET?
         BO    LDS$TILT                 YES. TILT.
         OI    SWITCH,1                 SET SWITCH
         L     R1,QCJCTA                LOAD BASE REG
         L     R4,JCTSPIOT              DISK ADDR OF SPIN IOT
         DROP  R1
         B     SPIN                     SEARCH THE SPIN IOT CHAIN
LDS$TILT MVC   QPDSID,=H'0'             INVALIDATE DSID
         QTILT '*** DATASET ID NOT FOUND ***'
LD$TILT2 QTILT '*** DATASET TABLE LIMITS EXCEEDED ***'
FOUNDDS2 MVC   QCJNAME,QPARM1           SAVE THE JOBNAME
         MVC   QCDSNO,QPARM2            SAVE THE DATASET ID NUMBER
         MVC   QDHLINE,QCHLINE          MOVE IN HEADING LINE
         MVC   QCRECFM,PDBRECFM         RECORD FORMAT FOR SAVE
         MVC   QCLRECL,PDBLRECL         RECORD LENGTH FOR SAVE
         L     R4,PDBMTTR               DISK ADDR OF FIRST BLOCK
         L     R5,QCBLKA                ADDR OF DATASET BLOCK IOAREA
         L     R2,QCSTART               BEGINNING OF DISK ADDR TABLE
         ZAP   QCCREC,=P'0'             ZERO CURRENT RECORD NO
         MVC   QCCPTR,QCSTART           BEGIN OF TBL
         ZAP   QCHREC,=P'0'             ZERO HIGH REC NO
         MVC   QCHPTR,QCSTART           BEGIN OF TBL
         ZAP   QPREC,=P'1'              REPOSITION TO TOP OF DATASET
         B     LDSFIRST                 PROCESS DATASET
         DROP  R2
         DROP  R3
***********************************************************************
*                                                                     *
*   PROCESS DATASET                                                   *
*                                                                     *
***********************************************************************
LDSNXTBL L     R4,0(R5)                 DISK ADDR OF NEXT BLOCK
LDSFIRST LTR   R4,R4                    IS THE DISK ADDR ZERO?
         BZ    LDS$END                  YES. END OF DATASET.
         ST    R4,0(R2)                 STORE DISK ADDR IN TABLE
         BAL   R8,LDS$READ              READ A BLOCK
         CLC   QPJOBID(6),4(R5)         DOES THE JOBID MATCH?
         BNE   LDS$END                  NO. END OF DATASET.
         MVC   4(4,R2),QCCREC           STORE CURRENT REC NUM IN TABLE
         ST    R2,QCCPTR                STORE CURRENT TABLE ADDR
         CP    QCCREC,QCHREC            IS CURRENT REC NO > HIGHEST?
         BNH   *+10                     NO. SKIP.
         MVC   QCHREC(8),QCCREC         REPLACE HI REC CNT AND PTR
         LA    R2,8(,R2)                INCREMENT TO NEXT TBL ENTRY
         C     R2,QCEND                 IS THIS THE END OF TABLE?
         BNL   LD$TILT2                 YES. TILT.
         LA    R4,10(R5)                ADDR OF FIRST RECORD IN BLOCK
***********************************************************************
*                                                                     *
*   PROCESS RECORDS                                                   *
*                                                                     *
***********************************************************************
NEXTREC2 CLI   0(R4),X'FF'              IS LENGTH BYTE FF?
         BE    LDSNXTBL                 YES. END OF BLOCK.
         TM    1(R4),X'10'              IS THIS A SPANNED RECORD?
         BO    LDS$SPAN                 YES. SKIP IT.
         ZIC   R6,0(R4)                 INSERT LENGTH
         LR    R7,R6                    SAVE RECORD LENGTH
         LR    R1,R4                    SAVE RECORD LOCATION
         TM    1(R4),X'80'              IS CARRIAGE CONTROL SPECIFIED?
         BZ    *+8                      NO. CONTINUE.
         LA    R1,1(,R1)                SKIP OVER CARRIAGE CONTROL
         TM    1(R4),X'08'              IS THIS RECORD TO BE IGNORED?
         LR    R4,R1                    UPDATE RECORD POINTER
         BNZ   SKIPREC2                 YES. SKIP IT.
         AP    QCCREC,=P'1'             ADD ONE TO CUR REC NO
         CP    QCCREC,QPREC             REACHED THE RECORD WE WANT?
         BL    SKIPREC2                 NO. TRY NEXT RECORD.
         CLI   QCODE,4                  IS THE REQUEST FOR A FIND?
         BE    LDS$FIND                 YES. DO IT.
         CLI   QCODE,8                  IS IT A FINDTIME REQUEST?
         BE    LD$FTIME                 YES. DO IT.
FINDOFF  AH    R1,QPOFFSET              ADD OFFSET TO START OF RECORD
         SH    R7,QPOFFSET              SUBTRACT OFFSET FROM LENGTH
         BNP   ZEROPRT                  NO DATA LEFT IN RECORD.
         CH    R7,=H'80'                IS RECORD BIGGER THAN 80 CHARS?
         BNH   LT80                     NO. USE RECORD LENGTH.
         LA    R7,80                    YES. USE A LENGTH OF 80.
LT80     QCALL DISPLAY,3(,R1),(R7)
         TM    QDOVER,1                 WAS THERE A PAGE OVERFLOW?
         BNO   SKIPREC2                 NO. SKIP.
         ZAP   QPREC,QCCREC             UPDATE THE REPOSITION NUMBER
         MVC   HREC,EDIT                PATTERN FOR EDIT
         ED    HREC,QCCREC              EDIT RECORD NUMBER
SKIPREC2 LA    R4,3(R6,R4)              INCREMENT TO NEXT RECORD
         B     NEXTREC2                 PROCESS NEXT RECORD
LDS$SPAN LH    R6,2(R4)                 LENGTH OF SEGMENT
         TM    1(R4),X'08'              IS THIS THE FIRST SEGMENT?
         BO    SPAN1ST2                 YES. USE HEADER LENGTH OF 6.
         LA    R4,4(R6,R4)              UPDATE RECORD POSITION
         B     NEXTREC2                 PROCESS NEXT RECORD
SPAN1ST2 LA    R4,6(R6,R4)              UPDATE RECORD POSITION
         B     NEXTREC2                 PROCESS NEXT RECORD
ZEROPRT  LA    R1,QBLANK                PRINT A BLANK
         LA    R7,1                     LENGTH OF ONE
         B     LT80                     PRINT THE RECORD
LDS$END  CP    QCCREC,=P'0'             IS THE DATASET EMPTY
         BE    LSTDSTOP                 YES. QUIT.
         MVC   HEND,ENDLINE             TELL THEM THIS IS THE END
         MVC   HREND,EDIT               PATTERN FOR EDIT
         ED    HREND,QCCREC             LAST REC NO
         CLI   QCODE,32                 WAS REQUEST FOR BOTTOM?
         BE    BOTTOM1                  YES. BACK UP 20 LINES.
         L     R1,=A(ENDDATA)
         QCALL DISPLAY,(R1),80          MOVE "END OF DATA" TO SCREEN
         QCALL DISPLAY,,0               FLUSH THE SCREEN
         ZAP   QPREC,=P'1'              RECORD NUMBER 1
         MVC   QDHLINE,QCHLINE          BLANK THE TITLE LINE
         B     LD$TOP                   START AT TOP OF DATASET
LSTDSTOP MVC   QDHLINE,EMPTYDS
         QSTOP
***********************************************************************
*                                                                     *
*   BOTTOM OF DATASET                                                 *
*                                                                     *
***********************************************************************
BOTTOM1  ZAP   QPREC,QCCREC             LAST RECORD NUMBER
         MVI   QCODE,0                  AVOID A LOOP
         SP    QPREC,=P'19'             TOP OF PAGE
         BP    LD$REPOS                 CONTINUE IF POSITIVE.
         ZAP   QPREC,=P'1'              TOP OF DATASET
***********************************************************************
*                                                                     *
*   REPOSITION TO REQUESTED RECORD NUMBER                             *
*                                                                     *
***********************************************************************
LD$REPOS MVC   QDHLINE,QCHLINE          MOVE IN HEADING LINE
         MVC   HREC,EDIT                PREPARE FOR EDIT
         ED    HREC,QPREC               EDIT RECORD NUMBER
         CP    QPREC,QCHREC             IS THE REQ NO > HIGHEST READ?
         BNL   LD$HI                    YES. GO FROM HI.
         CP    QPREC,QCCREC             IS THE REQ NO > CURRENT REC?
         BH    UP                       YES. GO FROM CURRENT.
         CP    QPREC,=P'1'              IS REQ FOR TOP OF DATASET?
         BH    DOWN                     NO. GO DOWN FROM CURRENT.
LD$TOP   L     R2,QCSTART               START AT TOP
LDRESUME L     R4,0(R2)                 LOAD DISK ADDR
         L     R5,QCBLKA                ADDR OF BLOCK IOAREA
         MVC   QCCREC,4(R2)             RESET CURRENT REC NO
         B     LDSFIRST                 RESUME PROCESSING
LD$HI    L     R2,QCHPTR                START AT HIGHEST SO FAR
         B     DOWNLOOP                 FIND CORRECT BLOCK
UP       L     R2,QCCPTR                CURRENT TABLE PTR
UPLOOP   CP    QPREC,12(4,R2)           IS THE NEXT ENTRY > REQ NO?
         BNH   LDRESUME                 YES. PROCESS IT.
         LA    R2,8(R2)                 TRY NEXT ENTRY
         B     UPLOOP                   AGAIN
DOWN     L     R2,QCCPTR                CURRENT TABLE PTR
DOWNLOOP CP    QPREC,4(4,R2)            IS THE ENTRY < REQ NO?
         BH    LDRESUME                 YES. PROCESS IT.
         SH    R2,=H'8'                 TRY PREVIOUS ENTRY
         B     DOWNLOOP                 AGAIN
***********************************************************************
*                                                                     *
*   FIND MATCHING RECORD ROUTINE                                      *
*                                                                     *
***********************************************************************
LDS$FIND LH    R3,QPLNG                 LENGTH-1 OF COMPARE
         LR    R14,R6                   LENGTH OF RECORD
         SR    R14,R3                   NUMBER OF COMPARES
         BNP   SKIPREC2                 RECORD IS TOO SMALL. SKIP IT.
         LR    R15,R4                   FIRST BYTE OF RECORD
FLOOP    EX    R3,LDS$CLC             DOES THE FIND DATA MATCH THE REC?
         BE    MATCH                    YES. DISCONTINUE SEARCH.
         LA    R15,1(R15)               INCREMENT TO NEXT BYTE
         BCT   R14,FLOOP                TRY NEXT BYTE
         B     SKIPREC2                 SKIP THE RECORD. NO MATCH.
MATCH    CLI   QSUBNAME+1,C'A'          IS THE REQUEST FOR A FINDALL?
         BE    FALL                     YES. DO NOT DISABLE SEARCH.
         MVI   QCODE,0                  END THE SEARCH
         ZAP   QPREC,QCCREC             UPDATE THE REPOSITION NUMBER
FALL     MVC   HREC,EDIT                PREPARE FOR EDIT
         ED    HREC,QCCREC              EDIT RECORD NUMBER
         B     FINDOFF                  CONTINUE
LDS$CLC  CLC   QPFIND(1),3(R15)         COMPARE PARM TO RECORD
***********************************************************************
*                                                                     *
*   FIND THE RECORD WHICH IS GREATER THAN OR EQUAL TO TIME            *
*                                                                     *
***********************************************************************
LD$FTIME CLI   10(R4),C'.'              DOES THIS RECORD HAVE TIME?
         BNE   SKIPREC2                 NO. SKIP IT.
         CLC   QPARM1,8(R4)             IS THIS THE TIME WE WANT?
         BH    SKIPREC2                 NO. SKIP IT.
         B     MATCH                    END THE SEARCH
***********************************************************************
*                                                                     *
*   READ A BLOCK FROM HASPACE                                         *
*                                                                     *
***********************************************************************
LDS$READ ST    R4,QCTRAK                STORE DISK ADDR
         LR    R1,R5                    IOAREA ADDRESS
         QCALL READSPC                  READ HASPACE
         BR    R8                       RETURN TO CALLER
         SPACE 1
         LTORG
EMPTYDS  DC    CL80'*** DATA SET IS EMPTY ***'
ENDLINE  DC    C', END OF DATA. LAST REC #'
EDIT     DC    X'4020202020202021'
         DC    CL45' '
LDS#WORK DC    0D'0'
SWITCH   DS    C
         SPACE 1
         DROP  R10,R9
    TITLE '--- QUEUE/SP --PARSE -- COMMAND LINE PARSE ROUTINES ---'
PARSE    QSTART ,
         L     R10,QVDSPL               LOAD BASE REG
         USING QDISPLAY,R10             BASE REG FOR DISPLAY WORK AREA
***********************************************************************
*                                                                     *
*   PARSE SUBCOMMAND NAME                                             *
*                                                                     *
***********************************************************************
         LH    R2,QDRLNG                LENGTH OF REPLY LINE
         OC    QDREPLY,QBLANK           TRANSLATE TO UPPER CASE
         CLC   QDREPLY,QBLANK           IS THE ENTIRE REPLY BLANK?
         BE    LOOKUP                   YES. DO LOOKUP.
         MVC   FIELD,QBLANK             BLANK THE WORK FIELD
         MVC   P#OFFSET(4),=F'0'        ZERO THE OFFSET AND LENGTH
         MVC   QOFF0(12),P#OFFSET       INITIALIZE FIRST FIELD
         MVC   QOFF1(48),QOFF0          INITIALIZE NEXT FOUR FIELDS
         LA    R6,QOFF4+12              ADDR PAST LAST FIELD
         LA    R5,QOFF0                 ADDR OF FIRST SET OF FIELDS
         LA    R3,QDREPLY               FIRST BYTE OF REPLY LINE
ENCORE   LA    R4,FIELD                 FIRST BYTE OF WORK FIELD
BLANK    CLI   0(R3),C' '               IS THIS BYTE BLANK?
         BNE   P$FIRST                  NO. START OF FIELD.
         LA    R3,1(R3)                 YES. SKIP IT.
         BCT   R2,BLANK                 TRY NEXT BYTE
         B     EMPTY                    END OF REPLY LINE.
P$FIRST  LH    R1,QDRLNG                REPLY LENGTH
         SR    R1,R2                    COMPUTE OFFSET TO FIELD START
         STH   R1,P#OFFSET              STORE OFFSET
         LR    R1,R2                    SAVE COUNT OF REMAINING BYTES
         B     CHAR                     CONTINUE
PARSE$LP CLI   0(R3),C' '               IS THIS BYTE BLANK?
         BE    LAST                     YES. END OF FIELD.
CHAR     MVC   0(1,R4),0(R3)            MOVE BYTE TO SUBNAME
         LA    R3,1(,R3)                INCREMENT
         LA    R4,1(,R4)                INCREMENT
         BCT   R2,PARSE$LP              TRY NEXT BYTE
LAST     SR    R1,R2                    COMPUTE FIELD LENGTH
         CH    R1,=H'8'                 IS LENGTH GREATER THAN 8?
         BNH   *+8                      NO. USE IT.
         LA    R1,8                     YES. USE LENGTH OF EIGHT.
         STH   R1,LENGTH                STORE FIELD LENGTH
EMPTY    MVC   0(12,R5),P#OFFSET        MOVE FIELD TO QCOMMON
         LTR   R2,R2                    IS THE REMAINING LENGTH ZERO?
         BZ    LOOKUP                   YES. DO THE TABLE LOOKUP.
         MVC   FIELD,QBLANK             BLANK THE WORK FIELD
         MVC   P#OFFSET(4),=F'0'        ZERO OUT OFFSET AND LENGTH
         LA    R5,12(R5)                INCREMENT TO NEXT FIELD
         CR    R5,R6                    WAS THAT THE LAST FIELD?
         BL    ENCORE                   NO. PROCESS NEXT FIELD.
***********************************************************************
*                                                                     *
*   LOOK UP THE MODULE ADDRESS FOR THE SUB COMMAND                    *
*                                                                     *
***********************************************************************
LOOKUP   CLI   QSUBNAME,C'X'            IS THIS A PRIVILEGED OPERATION?
         BE    SECRET                   YES. CHECK FOR PASSWORD.
LOOKUP2  LA    R2,P$TABLE               START OF SUBCOMMAND TABLE
NEXT     CLC   0(2,R2),QSUBNAME         COMPARE FIRST TWO CHARACTERS
         BE    P$FOUND                  THIS IS THE ONE
         LA    R2,8(R2)                 NEXT ENTRY
         CLI   0(R2),X'FF'              IS THIS THE END OF TABLE?
         BNE   NEXT                     NO. TRY NEXT ENTRY.
P$FOUND  MVC   QCODE(5),3(R2)           SUBCMD CODE AND COMMAND ADDRESS
         TM    2(R2),1                  IS PARM1 A <JOBID> ?
         BNO   P$STOP                   NO - SKIP
         CLC   QPARM1,=CL8'*'           REQUEST PREVIOUS?
         BE    USE$PREV                 YES - DON'T OVERLAY IT
         CLC   QPARM1,QBLANK            ANOTHER WAY TO DO THAT?
         BE    USE$PREV                 YES - DON'T OVERLAY IT
         MVC   QJOBID(2+8),QLNG1        SAVE JOBID + LENGTH
USE$PREV MVC   QLNG1(2+8),QJOBID        RESTORE PREVIOUS
P$STOP   QSTOP
***********************************************************************
*                                                                     *
*   CHECK AUTHORITY FOR X SUBCOMMANDS                                 *
*                                                                     *
***********************************************************************
SECRET   CLI   QSUBNAME+1,C'P'          IS THIS THE PASSWORD?
         BE    PASSWD                   YES. CHECK IT.
         TM    QXAUTH,1                 IS THIS USER AUTHORIZED?
         BO    LOOKUP2                  YES. PROCESS COMMAND.
BOUNCE   LA    R2,HELPCC                NO. PRETEND IT IS INVALID.
         B     P$FOUND                  CONTINUE
PASSWD   CLC   QPARM1,=C'PASSWORD'      DID THE USER SAY PASSWORD?
         BNE   BOUNCE                   NO. REJECT.
         TPUT  WPASS,L'WPASS,FULLSCR
         LA    R1,RPASS                 REPLY ADDRESS
         CNOP  0,4                                                 MAS1
         TGET  (1),8
         CLC   RPASS,=C'YES SIR!'       IS THE PASSWORD CORRECT?
         BNE   BOUNCE                   NO. REJECT.
         XI    QXAUTH,1                 AUTHORIZE USER (OR UNDO IT)
         QTILT '=== PASSWORD ACCEPTED ==='
         SPACE 1
WPASS    DC    X'C1115D7F1140403C4040001D4C13'  *** SPF TCAM
         LTORG
         EJECT
P$TABLE  DC    0D'0'
         DC    C'ST',AL1(0,00),A(SEARCH)      STATUS
         DC    C'DA',AL1(0,04),A(SEARCH)      DISP ACTIVE
         DC    C'DI',AL1(0,08),A(SEARCH)      DISP INPUT
         DC    C'DO',AL1(0,12),A(SEARCH)      DISP OUTPUT
         DC    C'AI',AL1(0,16),A(SEARCH)      AVAIL INPUT
         DC    C'AO',AL1(0,20),A(SEARCH)      AVAIL OUTPUT
         DC    C'HI',AL1(0,24),A(SEARCH)      HELD INPUT
         DC    C'HO',AL1(0,28),A(SEARCH)      HELD OUTPUT
         DC    C'DT',AL1(0,32),A(SEARCH)      DISP TSO USERS
         DC    C'DJ',AL1(1,36),A(SEARCH)      DISP JOB
         DC    C'DS',AL1(0,40),A(SEARCH)      DISP SYS TASKS
         DC    C'XJ',AL1(1,36),A(SEARCH)      HEX JOE/JQE DISP
         DC    C'JC',AL1(1,00),A(JCL)         LIST JCL
         DC    C'JL',AL1(1,00),A(JLOG)        LIST JOBLOG
         DC    C'JM',AL1(1,00),A(JMSG)        LIST JOBMSG
         DC    C'DD',AL1(1,00),A(DDNAME)      LIST DDNAMES
         DC    C'LI',AL1(1,00),A(LIST)        LIST DATASET
         DC    C'L ',AL1(1,00),A(LIST)        LIST DATASET
         DC    C'XL',AL1(1,00),A(LIST)        LIST DATASET
         DC    C'SA',AL1(0,04),A(SAVEX)       SAVE
         DC    C'SL',AL1(1,00),A(SYSLOG)      LIST SYSLOG
         DC    C'XB',AL1(0,00),A(HEXBLK)      DISPLAY HASPACE BLOCK
         DC    C'FI',AL1(0,04),A(REPOS)       FIND
         DC    C'FA',AL1(0,04),A(REPOS)       FIND ALL
         DC    C'F ',AL1(0,04),A(REPOS)       FIND
         DC    C'FT',AL1(0,08),A(REPOS)       FIND TIME
         DC    C'CO',AL1(0,12),A(REPOS)       COLUMN
         DC    C'C ',AL1(0,12),A(REPOS)       COLUMN
         DC    C'@ ',AL1(0,16),A(REPOS)       POSITION
         DC    C'+ ',AL1(0,20),A(REPOS)       DOWN
         DC    C'D ',AL1(0,20),A(REPOS)       DOWN
         DC    C'- ',AL1(0,24),A(REPOS)       UP
         DC    C'U ',AL1(0,24),A(REPOS)       UP
         DC    C'UP',AL1(0,24),A(REPOS)       UP
         DC    C'TO',AL1(0,28),A(REPOS)       TOP
         DC    C'T ',AL1(0,28),A(REPOS)       TOP
         DC    C'BO',AL1(0,32),A(REPOS)       BOTTOM
         DC    C'B ',AL1(0,32),A(REPOS)       BOTTOM
         DC    C': ',AL1(0,00),A(TSOCMD)      EXECUTE TSO COMMAND
         DC    C'XX',AL1(0,00),A(XXCMD)       EXPERIMENTAL COMMAND
HELPCC   DC    X'FF000000',A(HELP)
         SPACE 2
P#WORK   DC    0D'0'
P#OFFSET DS    H
LENGTH   DS    H
FIELD    DS    CL8
RPASS    DS    CL8
         SPACE 1
         DROP  R10
     TITLE '--- QUEUE/SP --READSPC -- READ A BLOCK FROM HASPACE ---'
READSPC  QSTART ,
         L     R10,QVCKPT               @ CKPT WORK AREA
         USING QCKPT,R10
*---------------------------------------------------------------------*
*                                                                     *
*   CONVERT MTTR TO MBBCCHHR                                          *
*                                                                     *
*                                                                     *
* NOTE - THE INPUT TO THIS ROUTINE IS AS FOLLOWS:                     *
*            QCTRAK CONTAINS THE MTTR                                 *
*            R1 CONTAINS THE IOAREA ADDRESS                           *
*                                                                     *
*---------------------------------------------------------------------*
         SPACE 1
         LR    R2,R1                    MOVE IOAREA ADDR TO R2
         ZIC   R3,QCTRAKM               RELATIVE DCB NUMBER
         SLL   R3,2                     MULTIPLY BY 4
         MVC   QCDADR,QCTRAKR           MOVE RECORD NUMBER
         MVC   QCDADHH,QCTRAKTT         MOVE TRACK TO A HALFWORD BOUND
         LH    R5,QCDADHH               LOAD RELATIVE TRACK NUMBER
         L     R15,QCSPNMTC(R3)         # TRKS/CYL FOR THIS HASPACE
         LTR   R15,R15                  ANY DCB?
         BZ    RS$DIV0                  BIF BAD MTTR
         SR    R4,R4                    CLEAR FOR DIVIDE
RS$DIV   DR    R5-1,R15                 TT/(TRKS/CYL)-> TO TRK AND CYL
         STH   R4,QCDADHH               STORE HEAD NUMBER
         STH   R5,QCDADCC               STORE CYLINDER NUMBER
         L     R3,QCSPDCBP(R3)          DCB ADDRESS
         CLC   =C'XB',QSUBNAME          IS THIS HEXBLK?
         BNE   *+10                     NO - SKIP
         MVC   56(4,R3),=A(HEXBLKER)    YES - SET SYNAD ADDRESS
         READ  HDECB2,DI,(R3),(R2),MF=E
         CHECK HDECB2
         MVC   56(4,R3),=A(1)           RESTORE SYNAD ADDRESS
RS$EXIT  QSTOP
         SPACE 1
RS$DIV0  CLC   =C'XB',QSUBNAME          IS THIS HEXBLK?
         BNE   RS$DIV                   NO - GO BLOW UP NORMALLY
         MVI   QSYNADFL,X'D0'           INDICATE ZERO DIVIDE
         B     RS$EXIT
         SPACE 1
         LTORG ,
         DROP  R10
     TITLE '--- QUEUE/SP --REPOS -- DATASET REPOSITIONING ROUTINES ---'
REPOS    QSTART  Q18
         USING QCKPT,R10                BASE REG FOR CKPT WORK AREA
         L     R10,QVCKPT               LOAD BASE REG
         USING QDISPLAY,R9              BASE REG FOR DISPLAY WORK AREA
         L     R9,QVDSPL                LOAD BASE REG
***********************************************************************
*                                                                     *
*   BRANCH TO PROPER ROUTINE                                          *
*                                                                     *
***********************************************************************
         CLC   QPDSID,=H'0'             IS THERE A VALID DATASET?
         BNE   GO                       YES. GO AHEAD.
         QTILT '=== YOU ARE NOT PROCESSING A VALID DATASET ==='
GO       LH    R1,QCODEH                LOAD FUNCTION CODE
         CH    R1,=H'32'                IS THE FUNCTION SUPPORTED?
         BH    RP$STOP                  NO. RETURN.
         B     *+4(R1)                  BRANCH TO ROUTINE
         B     RP$TILT                  0 OFFSET
         B     RP$FIND                  4
         B     RP$FTIME                 8
         B     COLUMN                   12
         B     AT                       16
         B     RP$PLUS                  20
         B     MINUS                    24
         B     RP$TOP                   28
         B     RP$BOTTM                 32
RP$TILT  QTILT '*** PARAMETER IS INVALID OR OMITTED ***'
***********************************************************************
*                                                                     *
*   REPOSITION VERTICALLY                                             *
*                                                                     *
***********************************************************************
* SKIP FORWARD
RP$PLUS  BAL   R4,NUMERIC               VALIDATE PARAMETER
         AP    QPREC,QNUMWORK           ADD COUNT TO CURRENT RECORD
         B     RPRESUME                 CALL LISTDS
* SKIP BACKWARD
MINUS    BAL   R4,NUMERIC               VALIDATE PARAMETER
         SP    QPREC,QNUMWORK           SUBTRACT COUNT FROM CURR REC
         BP    RPRESUME                 CALL LISTDS IF RESULT POSITIVE.
* TOP OF DATASET
RP$TOP   ZAP   QPREC,=P'1'              SET CURRENT RECORD TO TOP OF DS
* RESUME AT CURRENT RECORD
RPRESUME QCALL LISTDS
RP$STOP QSTOP
* BOTTOM OF DATASET
RP$BOTTM ZAP   QPREC,=P'9999999'        SET CURRENT RECORD TO LARGEST
         B     RPRESUME                 CALL LISTDS
* POSITION TO THIS RECORD
AT       BAL   R4,NUMERIC               VALIDATE PARAMETER
         ZAP   QPREC,QNUMWORK           INDICATE REPOSITION NO
         B     RPRESUME                 CALL LISTDS
* CHECK THE PARMETER FOR VALID NUMERIC AND PACK IT
NUMERIC  LH    R1,QLNG1                 LENGTH OF PARM
         SH    R1,=H'1'                 IS THE COUNT FIELD ZERO?
         BM    RPRESUME                 YES. RESUME FROM CURRENT POSIT
         LA    R15,QPARM1               POINT TO PARM
         BAL   R14,QNUMCONV             CONVERT IT
         BNE   RP$TILT                  TILT IF NOT NUMERIC
         BR    R4                       RETURN
***********************************************************************
*                                                                     *
*   REPOSITION HORIZONTALLY                                           *
*                                                                     *
***********************************************************************
COLUMN   BAL   R4,NUMERIC               VALIDATE PARAMETER
         CP    QNUMWORK,=P'255'         IS THE COUNT FIELD TOO BIG?
         BH    RP$TILT                  YES. TILT.
         SP    QNUMWORK,=P'1'           COLUMN RELATIVE TO ZERO
         BM    RP$TILT                  INVALID. TILT.
         CVB   R5,QNUMWORK              CONVERT TO BINARY
         STH   R5,QPOFFSET              STORE IN QPOFFSET
         B     RPRESUME                 CALL LISTDS
***********************************************************************
*                                                                     *
*   LOCATE SPECIFIC RECORD                                            *
*                                                                     *
***********************************************************************
RP$FIND  CLI   QSUBNAME+1,C'A'          IS THE REQUEST FOR FIND ALL?
         BE    *+10                     YES. DO NOT UPDATE REC POINTER.
         AP    QPREC,=P'1'              START SEARCH AT NEXT RECORD
         CLI   QPARM1,C' '              IS THERE A PARAMETER?
         BE    RPRESUME                 NO. CONTINUE WITH PREV. FIND.
         LA    R2,QDREPLY+QDREPLYL-1    END OF USER REPLY
         LA    R3,QDREPLYL-2            MAXIMUM LENGTH OF PARM
         SH    R3,QOFF1                 OFFSET TO FIRST PARM
REPOS$LP CLC   0(1,R2),QPARM1           IS THIS THE DELIMITER?
         BE    RP$FOUND                 YES. CONTINUE.
         BCTR  R2,0                     TRY THE PREVIOUS BYTE
         BCT   R3,REPOS$LP              IS THE LENGTH FIELD EXHAUSTED?
         B     RP$TILT                  YES. TILT.
RP$FOUND BCTR  R3,0                     DECREMENT LENGTH BY 1
         LA    R2,QDREPLY+1             ADDR OF REPLY + 1
         AH    R2,QOFF1                 ADDR OF FIRST BYTE OF PARM
         EX    R3,MVC                   MOVE PARM TO QPFIND
         STH   R3,QPLNG                 SAVE LENGTH-1 OF PARM
         B     RPRESUME                 CALL LISTDS
MVC      MVC   QPFIND(1),0(R2)          MOVE PARM TO QPFIND
***********************************************************************
*                                                                     *
*   REPOSITION IN SYSLOG DATASET BY TIME OF DAY                       *
*                                                                     *
***********************************************************************
RP$FTIME CLI   QPARM1,C' '              IS THE PARM OMITTED?
         BE    RP$TILT                  YES. TILT.
         B     RPRESUME                 CALL LISTDS
         DROP  R10,R9
         SPACE 1
         LTORG
     TITLE '--- QUEUE/SP --SAVE -- CREATE A COPY OF CURRENT DS ---'
SAVEX    QSTART  Q19
         USING QCKPT,R10                BASE REG FOR CHECKPT WORK AREA
         L     R10,QVCKPT               LOAD BASE REG
         USING QDISPLAY,R9              BASE REG FOR DISPLAY WORK AREA
         L     R9,QVDSPL                LOAD BASE REG
***********************************************************************
*                                                                     *
*   ALLOCATE OUTPUT DATASET                                           *
*                                                                     *
***********************************************************************
         CLC   QPDSID,=H'0'             IS THERE A VALID DATASET?
         BE    SV$TILT1                 NO. TELL THE USER.
         MVC   DSNAME+2(44),QBLANK      BLANK THE DSNAME
         MVC   DSNAME+2(8),QPARM1       FIRST PART OF DSNAME
         LA    R1,DSNAME                ADDR OF DSNAME
         ST    R1,DA08PDSN              STORE IN PARM LIST
         LH    R2,QLNG1                 LENGTH OF QPARM1
         LA    R1,2(R2,R1)              OFFSET INTO DSNAME
         MVC   0(8,R1),=C'.OUTLIST'     LAST PART OF DSNAME
         LA    R1,8(,R2)                LENGTH OF DSNAME
         STH   R1,DSNAME                STORE LENGTH OF DSNAME
         CLI   QPARM2,C' '              ANY DISP?
         BNE   *+10                     YES - USE IT
         MVC   QPARM2,=CL8'NEW'         NO - USE NEW
         MVC   DA08UNIT(64),ALLOCNEW    REMAINDER OF DISP=NEW PARM LIST
         CLC   =C'NORLSE ',QPARM2       NEW BUT NO RELEASE?
         BNE   *+14                     NO - SKIP
         MVC   QPARM2,=CL8'NEW'         YES - CHANGE TO DISP=NEW
         MVI   DA08CTL,X'A0'            TURN OFF RLSE BIT
         CLC   QPARM2,=CL8'NEW'         IS THIS DISP=NEW?
         BE    SAVE$ALC                 YES - GO ALLOC
         MVC   DA08UNIT(64),ALLOCOLD    NO - ASSUME OLD
         CLC   =C'OLD ',QPARM2          IS IT?
         BE    SAVE$ALC                 YES
         MVI   DA08DSP1,X'02'           NO - CHANGE TO MOD
         CLC   =C'MOD ',QPARM2          IS IT?
         BNE   SV$TILT2                 NO - COMPLAIN
         SPACE 1
SAVE$ALC MVI   DAIRFLAG,X'08'           INDICATE ALLOC FUNCTION
         QCALL ALLOCATE                 CALL DAIR
         MVC   QCOUT+40(8),DA08DDN      GET THE DDNAME RETURNED BY DAIR
         MVC   QCOUT+36(1),QCRECFM      MOVE IN RECORD FORMAT
         NI    QCOUT+36,X'06'           TURN OFF EVERTHING BUT CCTL
         OI    QCOUT+36,X'90'           SPECIFY FIXED BLOCKED RECORDS
         LH    R1,QCLRECL               RECORD LENGTH
         LTR   R1,R1                    IS THE LRECL ZERO?
         BNZ   *+8                      NO. SKIP.
         LA    R1,133                   YES. USE LRECL 133.
         STH   R1,QCOUT+82              STORE LRECL
BIGGER   LR    R2,R1                    UPDATE BLKSIZE
         AH    R1,QCOUT+82              ADD LRECL TO BLKSIZE
         CH    R1,=H'4096'              BLKSIZE GREATER THAN 4096?
         BL    BIGGER                   NO. MAKE IT BIGGER.
         STH   R2,QCOUT+62              STORE BLKSIZE
         OPEN  MF=(E,QCOPEN)
***********************************************************************
*                                                                     *
*   REPOSITION DATASET TO TOP                                         *
*                                                                     *
***********************************************************************
         L     R4,QCSTART               TOP OF DATASET POINTER
         L     R4,0(R4)                 DISK ADDR TOP OF DATASET
         L     R5,QCBLKA                IOAREA ADDRESS
         B     SV$FIRST                 GO DO IT
***********************************************************************
*                                                                     *
*   PROCESS DATASET                                                   *
*                                                                     *
***********************************************************************
SV$NXTBL L     R4,0(R5)                 DISK ADDR OF NEXT BLOCK
SV$FIRST LTR   R4,R4                    IS THE DISK ADDR ZERO?
         BZ    SAVE$END                 YES. END OF DATASET.
         BAL   R8,SV$READ               READ A BLOCK
         CLC   QPJOBID(6),4(R5)         DOES THE JOBID MATCH?
         BNE   SAVE$END                 NO. END OF DATASET.
         LA    R4,10(R5)                ADDR OF FIRST RECORD IN BLOCK
***********************************************************************
*                                                                     *
*   PROCESS RECORDS                                                   *
*                                                                     *
***********************************************************************
NEXTREC3 CLI   0(R4),X'FF'              IS LENGTH BYTE FF?
         BE    SV$NXTBL                 YES. END OF BLOCK.
         TM    1(R4),X'10'              SPANNED RECORD?
         BO    SV$SPAN                  YES. SKIP IT.
         ZIC   R6,0(,R4)                INSERT LENGTH
         TM    1(R4),X'80'              IS CCTL SPECIFIED?
         BZ    *+8                      NO. SKIP.
         LA    R6,1(,R6)                INCREMENT LENGTH FOR CCTL
         TM    1(R4),X'08'              IS THIS RECORD TO BE IGNORED?
         BO    SKIPREC3                 YES. SKIP IT.
         MVI   BUFFER,C' '              BLANK FIRST BYTE OF BUFFER
         MVC   BUFFER+1(255),BUFFER     BLANK THE BUFFER
         LR    R7,R6                    DO NOT DESTROY R6
         SH    R7,=H'1'                 IS LENGTH ZERO?
         BM    SKIPREC3                 YES. SKIP RECORD.
         EX    R7,MVCREC                MOVE RECORD TO BUFFER
         PUT   QCOUT,BUFFER
SKIPREC3 LA    R4,3(R6,R4)              INCREMENT TO NEXT RECORD
         B     NEXTREC3                 PROCESS NEXT RECORD
SV$SPAN  LH    R6,2(R4)                 SEGMENT LENGTH
         TM    1(R4),X'08'              IS THIS THE FIRST SEGMENT?
         BO    SPAN1ST3                 YES. USE LARGER HEADER SIZE.
         LA    R4,4(R6,R4)              INCREMENT TO NEXT RECORD
         B     NEXTREC3                 PROCESS NEXT RECORD
SPAN1ST3 LA    R4,6(R6,R4)              INCREMENT TO NEXT RECORD
         B     NEXTREC3                 PROCESS NEXT RECORD
***********************************************************************
*                                                                     *
*   CLOSE UP SHOP AND GO HOME                                         *
*                                                                     *
***********************************************************************
SAVE$END CLOSE MF=(E,QCOPEN)
         MVC   DA2CDDN,QCOUT+40         GET THE DDNAME
         MVI   DAIRFLAG,X'2C'           INDICATE "NOT_IN_USE" FUNCTION
         QCALL ALLOCATE                 CALL DAIR
         QCALL LISTDS                   GO BACK TO LISTDS
         QSTOP
***********************************************************************
*                                                                     *
*   READ A BLOCK FROM HASPACE                                         *
*                                                                     *
***********************************************************************
SV$READ  ST    R4,QCTRAK                STORE DISK ADDR
         LR    R1,R5                    IOAREA ADDRESS
         QCALL READSPC                  READ HASPACE
         BR    R8                       RETURN TO CALLER
         SPACE 1
SV$TILT1 QTILT '=== YOU ARE NOT PROCESSING A VALID DATASET ==='
SV$TILT2 QTILT '*** INVALID DISP ***'
         LTORG
MVCREC   MVC   BUFFER(1),3(R4)
         DS    0F
         SPACE 1
ALLOCNEW DC    2CL8' '                  UNIT & VOLSER
         DC    F'0,10,50,0'             BLKSIZE / PRI / SEC / DIR
         DC    2CL8' '                  MEMBER & PASSWORD
         DC    X'04'                    STAT=NEW
         DC    2X'02'                   DISP=CATLG
         DC    X'B0'                    TRKS + PREFIX_USERID + RLSE
         DC    F'0',CL8' '
         SPACE 1
ALLOCOLD DC    2CL8' '                  UNIT & VOLSER
         DC    4F'0'                    BLKSIZE / PRI / SEC / DIR
         DC    2CL8' '                  MEMBER & PASSWORD
         DC    X'01'                    STAT=OLD
         DC    2X'08'                   DISP=KEEP
         DC    X'20'                    PREFIX_USERID TO DSNAME
         DC    F'0',CL8' '
         SPACE 1
SV#WORK  DC    0D'0'
BUFFER   DS    CL256
DSNAME   DS    H
         DS    CL44
         SPACE 1
         DROP  R10,R9
     TITLE '--- QUEUE/SP --SEARCH -- JQE AND JOE SEARCH AND FORMAT ---'
SEARCH   QSTART  Q20
         L     R10,QVCKPT               @ CKPT WORK AREA
         USING QCKPT,R10
         SPACE 1
         USING JQEDSECT,R9              BASE REG FOR JQE DSECT
         USING JOEDSECT,R8              BASE REG FOR JOE DSECT
         SPACE 1
*   BRANCH TO PROPER ROUTINE                                          *
         LH    R1,QCODEH                LOAD FUNCTION CODE INTO R1
         CH    R1,=H'40'                IS THE FUNCTION SUPPORTED?
         BH    SRCHSTOP                 NO. RETURN.
         B     *+4(R1)                  BRANCH TO ROUTINE
         B     ST                       0 OFFSET
         B     DA                       4
         B     DI                       8
         B     AO                       12  REALLY "DO" COMMAND
         B     AI                       16
         B     AO                       20
         B     HI                       24
         B     HO                       28
         B     DT                       32
         B     DJ                       36  ALSO "XJ" COMMAND
         B     DS                       40
***********************************************************************
*                                                                     *
*   STATUS - FIND ALL JOBS THAT MATCH LEVEL                           *
*                                                                     *
***********************************************************************
ST       CLI   QPARM1,C' '              DID USER SPECIFY LEVEL?
         BNE   *+10                     YES - SKIP
         MVC   QPARM1,QSTKEY            NO - USE LAST SEARCH KEY
         MVC   QSTKEY,QPARM1            SAVE SEARCH KEY
         BAL   R2,PARMLEN               DETERMINE PARM LENGTH
* SEARCH THE TSO QUEUE
         USING JQTDSECT,R1              BASE REG FOR JQT
DJ2      LH    R6,QLNG1                 LENGTH OF COMPARE FOR LEVEL
         L     R1,QCJQHEAD              LOAD ADDR OF JQT
         LA    R4,JQTTSU                ADDR OF TSO QUEUE
         MVI   QCLASS,0                 INDICATE THIS IS THE TSO QUEUE
         BAL   R2,SRCHJQE               SEARCH THE QUEUE
         B     DJ3                      END OF QUEUE
         EX    R6,STCLC                 IS THE JOBNAME EQUAL TO LEVEL?
         BNE   SKIPJQE                  NO. SKIP THIS RECORD.
         B     PRTJQE                   PRINT THE RECORD
* SEARCH THE SYSTEM QUEUE
DJ3      L     R1,QCJQHEAD              LOAD ADDR OF JQT
         LA    R4,JQTSTC                ADDR OF STC QUEUE
         MVI   QCLASS,4                 INDICATE THIS IS THE STC QUEUE
         BAL   R2,SRCHJQE               SEARCH THE QUEUE
         B     DJ4                      END OF QUEUE
         EX    R6,STCLC                 IS THE JOBNAME EQUAL TO LEVEL?
         BNE   SKIPJQE                  NO. SKIP THIS RECORD.
         B     PRTJQE                   PRINT THE RECORD
* SEARCH FOR HELD OUTPUT
DJ4      L     R1,QCJQHEAD              LOAD ADDR OF JQT
         LA    R4,JQTOUT                ADDR OF $OUTPUT QUEUE
         DROP  R1
         MVI   QCLASS,8                 INDICATE THIS IS THE HELD OUT Q
         BAL   R2,SRCHJQE               SEARCH THE QUEUE
         B     ST3                      END OF QUEUE
         EX    R6,STCLC                 IS THE JOBNAME EQUAL TO LEVEL?
         BNE   SKIPJQE                  NO. SKIP THIS RECORD.
         CLI   JQEHLDCT,0               ANY HELD DATASETS? (PART 1)
         BNE   PRTJQE                   YES. PRINT THE RECORD.
         TM    JQEHLDCT,X'F0'           ANY HELD DATASETS? (PART 2)
         BNZ   PRTJQE                   YES. PRINT THE RECORD.
         B     REJJQE                   REJECT THE RECORD
* SEARCH INPUT QUEUES
ST3      MVI   QCLASS,192               START WITH CLASS A
ST4      BAL   R2,NEXTJQT               FIND NEXT QUEUE
         BAL   R2,SRCHJQE               SEARCH THE QUEUE
         B     ST4                      END OF QUEUE
         CLI   JQEFLAGS,0               IS THE JOB EXECUTING OR HELD?
         BNE   ST7                      YES. SPECIAL HANDLING.
         EX    R6,STCLC                 IS THE JOBNAME EQUAL TO LEVEL?
         BNE   SKIPJQE                  NO. SKIP THIS RECORD.
         B     PRTJQE                   PRINT THE JQE
ST7      EX    R6,STCLC                 IS THE JOBNAME EQUAL TO LEVEL?
         BNE   REJJQE                   NO. SKIP THIS RECORD.
         B     PRT2JQE                  PRINT REC WITHOUT INCR COUNT
* SEARCH OUTPUT QUEUES
ST5      SR    R4,R4                    SEARCH ALL OUTPUT CLASSES
         BAL   R2,THISJOT
         B     ST6S
ST6      BAL   R2,NEXTJOT               DETERMINE NEXT QUEUE
ST6S     BAL   R2,SRCHJOE               SEARCH A JQE QUEUE
         B     ST6                      END OF QUEUE
         EX    R6,STCLC                 IS THE JOBNAME EQUAL TO LEVEL?
         BNE   SKIPJOE                  NO. SKIP THIS RECORD.
         B     PRTJOE                   PRINT THE RECORD
* COMPARE USED TO CHECK LEVEL
STCLC    CLC   QPARM1(1),JQEJNAME       IS THE JOBNAME EQUAL TO LEVEL?
***********************************************************************
*                                                                     *
*   DJ - FIND A SPECIFIC JOB                                          *
*                                                                     *
***********************************************************************
DJ       CLI   QPARM1,C' '              DID USER SPECIFY JOBNAME?
         BE    DJ9                      NO. TILT.
         MVC   QLNG1,=H'7'              COMPARE FOR 8 CHARACTERS
         B     DJ2                      USE THE STATUS ROUTINES
DJ9      QTILT '*** YOU MUST SPECIFY JOBNAME ***'
***********************************************************************
*                                                                     *
*   DI - PRINT ALL JOBS IN INPUT QUEUES                               *
*                                                                     *
***********************************************************************
DI       CLI   QPARM1,C' '              DID USER SPECIFY CLASS?
         BNE   DI5                      YES. LIMIT TO ONE QUEUE.
* SEARCH ALL QUEUES
         MVI   QCLASS,192               START WITH CLASS A
DI2      BAL   R2,NEXTJQT               DETERMINE NEXT QUEUE
         BAL   R2,SRCHJQE               SEARCH A JQE QUEUE
         B     DI2                      END OF QUEUE
         B     PRTJQE                   PRINT THE RECORD
* SEARCH ONLY ONE QUEUE
DI5      MVC   QCLASS,QPARM1            USER SPECIFIED CLASS
         BAL   R2,FINDJQT               FIND QUEUE
         BAL   R2,SRCHJQE               SEARCH THE QUEUE
         B     SRCHSTOP                 END OF QUEUE
         B     PRTJQE                   PRINT THE RECORD
***********************************************************************
*                                                                     *
*   AI - PRINT JOBS IN INPUT QUEUES THAT ARE AVAILABLE FOR SELECTION  *
*                                                                     *
***********************************************************************
AI       CLI   QPARM1,C' '              DID USER SPECIFY CLASS?
         BNE   AI5                      YES. LIMIT TO ONE QUEUE.
* SEARCH ALL QUEUES
         MVI   QCLASS,192               START WITH CLASS A
AI2      BAL   R2,NEXTJQT               DETERMINE NEXT QUEUE
         BAL   R2,SRCHJQE               SEARCH A JQE QUEUE
         B     AI2                      END OF QUEUE
         CLI   JQEFLAGS,0               IS THE JOB BUSY OR HELD?
         BNE   REJJQE                   YES. SKIP IT.
         B     PRTJQE                   PRINT THE RECORD
* SEARCH ONLY ONE QUEUE
AI5      MVC   QCLASS,QPARM1            USER SPECIFIED CLASS
         BAL   R2,FINDJQT               FIND QUEUE
         BAL   R2,SRCHJQE               SEARCH THE QUEUE
         B     SRCHSTOP                 END OF QUEUE
         CLI   JQEFLAGS,0               IS THE JOB BUSY OR HELD?
         BNE   REJJQE                   YES. SKIP IT.
         B     PRTJQE                   PRINT THE RECORD
***********************************************************************
*                                                                     *
*   AO - PRINT AVAILABLE JOBS IN THE OUTPUT QUEUE                     *
*                                                                     *
***********************************************************************
AO       CLI   QPARM1,C' '              DID USER SPECIFY CLASS?
         BNE   AO5                      YES. LIMIT TO ONE QUEUE.
* SEARCH ALL QUEUES
         SR    R4,R4                    START WITH FIRST CLASS
         BAL   R2,THISJOT               START SEARCH
AO2S     BAL   R2,SRCHJOE               SEARCH A JQE QUEUE
         B     AO2                      END OF QUEUE
         B     PRTJOE                   PRINT THE RECORD
AO2      BAL   R2,NEXTJOT               DETERMINE NEXT QUEUE
         B     AO2S
* SEARCH ONLY ONE QUEUE
AO5      MVC   QCLASS,QPARM1            USER SPECIFIED CLASS
         BAL   R2,FINDJOT               FIND QUEUE
         BAL   R2,SRCHJOE               SEARCH THE QUEUE
         B     SRCHSTOP                 END OF QUEUE
         B     PRTJOE                   PRINT THE RECORD
***********************************************************************
*                                                                     *
*   HI - PRINT JOBS IN INPUT QUEUES THAT ARE HELD                     *
*                                                                     *
***********************************************************************
HI       CLI   QPARM1,C' '              DID USER SPECIFY CLASS?
         BNE   HI5                      YES. LIMIT TO ONE QUEUE.
* SEARCH ALL QUEUES
         MVI   QCLASS,192               START WITH CLASS A
HI2      BAL   R2,NEXTJQT               DETERMINE NEXT QUEUE
         BAL   R2,SRCHJQE               SEARCH A JQE QUEUE
         B     HI2                      END OF QUEUE
         TM    JQEFLAGS,X'E0'           IS THE JOB HELD?
         BZ    REJJQE                   NO. SKIP IT.
         B     PRTJQE                   PRINT THE RECORD
* SEARCH ONLY ONE QUEUE
HI5      MVC   QCLASS,QPARM1            USER SPECIFIED CLASS
         BAL   R2,FINDJQT               FIND QUEUE
         BAL   R2,SRCHJQE               SEARCH THE QUEUE
         B     SRCHSTOP                 END OF QUEUE
         TM    JQEFLAGS,X'E0'           IS THE JOB HELD?
         BZ    REJJQE                   NO. SKIP IT.
         B     PRTJQE                   PRINT THE RECORD
***********************************************************************
*                                                                     *
*   HO - LIST ALL JOBS WITH HELD OUTPUT                               *
*                                                                     *
***********************************************************************
         USING JQTDSECT,R1              BASE REG FOR JQT
HO       L     R1,QCJQHEAD              LOAD ADDR OF JQT
         LA    R4,JQTOUT                ADDR OF $OUTPUT QUEUE
         DROP  R1
         MVI   QCLASS,8                 INDICATE THIS IS THE HELD OUT Q
         BAL   R2,SRCHJQE               SEARCH THE QUEUE
         B     SRCHSTOP                 END OF QUEUE
         CLI   JQEHLDCT,0               ANY HELD DATASETS? (PART 1)
         BNE   PRTJQE                   YES. PRINT THE RECORD.
         TM    JQEHLDCT,X'F0'           ANY HELD DATASETS? (PART 2)
         BNZ   PRTJQE                   YES. PRINT THE RECORD.
         B     REJJQE                   REJECT THE RECORD
***********************************************************************
*                                                                     *
*   DA - FIND ALL EXECUTING JOBS                                      *
*                                                                     *
***********************************************************************
DA       MVI   QCLASS,192               START WITH CLASS A
DA2      BAL   R2,NEXTJQT               DETERMINE NEXT QUEUE
         BAL   R2,SRCHJQE               SEARCH THE QUEUE
         B     DA2                      END OF QUEUE
         TM    JQEFLAGS,QUEBUSY         IS THE JOB EXECUTING?
         BZ    REJJQE                   NO. REJECT IT.
         B     PRTJQE                   PRINT THE RECORD
***********************************************************************
*                                                                     *
*   DT - LIST ALL TSO USERS                                           *
*                                                                     *
***********************************************************************
         USING JQTDSECT,R1              BASE REG FOR JQT
DT       L     R1,QCJQHEAD              LOAD ADDR OF JQT
         LA    R4,JQTTSU                ADDR OF TSO QUEUE
         DROP  R1
         MVI   QCLASS,0                 INDICATE THIS IS THE TSO Q
         BAL   R2,SRCHJQE               SEARCH THE QUEUE
         B     SRCHSTOP                 END OF QUEUE
         B     PRTJQE                   PRINT THE RECORD
***********************************************************************
*                                                                     *
*   DS - LIST ALL SYSTEM STARTED TASKS                                *
*                                                                     *
***********************************************************************
         USING JQTDSECT,R1              BASE REG FOR JQT
DS       L     R1,QCJQHEAD              LOAD ADDR OF JQT
         LA    R4,JQTSTC                ADDR OF STC QUEUE
         DROP  R1
         MVI   QCLASS,4                 INDICATE THIS IS THE STC QUEUE
         BAL   R2,SRCHJQE               SEARCH THE QUEUE
         B     SRCHSTOP                 END OF QUEUE
         B     PRTJQE                   PRINT THE RECORD
***********************************************************************
*                                                                     *
*   DETERMINE LENGTH OF LEVEL                                         *
*                                                                     *
***********************************************************************
PARMLEN  LA    R3,7                     MAXIMUM LENGTH OF 8
         LA    R4,QPARM1+7              END OF FIELD
PARMLEN2 CLI   0(R4),C' '               IS THIS BYTE BLANK?
         BNE   PARMLEN3                 NO. THIS IS THE LENGTH
         BCTR  R4,0                     TRY PREVIOUS BYTE
         BCT   R3,PARMLEN2              LOOP
PARMLEN3 STH   R3,QLNG1                 STORE THE LENGTH OF LEVEL
         BR    R2                       RETURN TO CALLER
***********************************************************************
*                                                                     *
*   SEARCH A JQE QUEUE                                                *
*                                                                     *
***********************************************************************
SRCHJQE  ZAP   QCOUNT,=P'0'             ZERO THE QUEUE COUNT
         L     R9,0(R4)                 LOAD FIRST JQE OFFSET
NEXTJQE2 N     R9,=X'00FFFFFF'          END OF QUEUE?
         BZR   R2                       RIF END OF QUEUE
         AL    R9,QCJQTA                JQE ADDRESS FROM OFFSET
         B     4(R2)                    DETERMINE ELIGIBILITY
PRTJQE   AP    QCOUNT,=P'1'             INCREMENT COUNT
PRT2JQE  SR    R1,R1                    INDICATE THIS IS A JQE
         QCALL FORMAT                   PRINT THE JQE IN R9
REJJQE   L     R9,JQENEXT               LOAD OFFSET TO NEXT JQE
         B     NEXTJQE2                 GET THE NEXT JQE
SKIPJQE  AP    QCOUNT,=P'1'             INCREMENT COUNT
         B     REJJQE                   CONTINUE
***********************************************************************
*                                                                     *
*   SEARCH A JOE QUEUE                                                *
*                                                                     *
***********************************************************************
SRCHJOE  ZAP   QCOUNT,=P'0'             ZERO THE QUEUE COUNT
FIRSTJOE L     R8,0(R4)                 LOAD FIRST JQE OFFSET
         N     R8,=X'00FFFFFF'          END OF QUEUE?              MAS1
         BZR   R2                       YES. RETURN TO CALLER.
         XC    PRIORITY(12),PRIORITY    ZERO OUT HIGHEST POINTERS
NEXTJOE  N     R8,=X'00FFFFFF'          END OF QUEUE?
         BZ    TESTJOE                  BIF END, RET HIGHEST
         AL    R8,QCJOTA                ADD BASE TO OFFSET
         L     R9,JOEJQE                OFFSET TO JQE
         N     R9,=X'00FFFFFF'          ANY POINTER?
         BZ    TRYJOE                   BIF THIS JOE ALREADY USED
         AL    R9,QCJQTA                ADD BASE TO OFFSET
         LA    R7,255                   PRESET MAXIMUM PRIORITY
         TM    JQEPRIO,240              IS THIS JOB PRIORITY 15?
         BO    HIGHJOE                  YES. PASS TO CALLER.
         LA    R1,16                    PRESET PRIORITY ONE
         CLI   JQETYPE,$HARDCPY         IS THE JOB EXECUTING?
         BNE   *+8                      YES. USE PRIORITY ONE.
         IC    R1,JQEPRIO               INSERT JQE PRIORITY
         IC    R7,JOEPRIO               INSERT JOE PRIORITY
         AR    R7,R1                    ADD PRIORITIES
         SRL   R7,1                     'CUZ HASP DOES IT, THAT'S WHY
HIGHJOE  C     R7,PRIORITY              THIS LESS THAN PREVIOUS HIGH?
         BL    TRYJOE                   YES. TRY NEXT ONE.
         STM   R7,R9,PRIORITY           NO. REPLACE PREVIOUS HIGH.
TRYJOE   L     R8,JOENEXT               ADDR OF NEXT JOE
         B     NEXTJOE                  TRY NEXT JOE
TESTJOE  LM    R7,R9,PRIORITY           LOAD ADDR OF HIGHEST JOE
         LTR   R8,R8                    WAS THE QUEUE EMPTY?
         BZR   R2                       YES. END OF QUEUE.
         MVC   JOEJQEB,=XL3'00'         INDICATE THIS JOE USED
         B     4(R2)                    DETERMINE ELIGIBILITY
PRTJOE   LA    R1,4                     INDICATE THIS IS A JOE
         AP    QCOUNT,=P'1'             INCREMENT COUNT
         QCALL FORMAT                   PRINT THE JOE IN R9
REJJOE   B     FIRSTJOE                 GET THE NEXT JOE
SKIPJOE  AP    QCOUNT,=P'1'             INCREMENT COUNT
         B     REJJOE                   CONTINUE
***********************************************************************
*                                                                     *
*   DETERMINE INPUT QUEUE                                             *
*                                                                     *
***********************************************************************
FINDJQT  TR    QCLASS,CLASSTBL          DETERMINE OFFSET
         LH    R4,QCLASSH               LOAD TABLE OFFSET
         BCTR  R4,0                     SUBTRACT 1
         STH   R4,QCLASSH               RESTORE VALUE
         B     NEXTJQT2                 CONTINUE
NEXTJQT  TR    QCLASS,CLASSTBL          DETERMINE OFFSET FROM 1ST CLASS
         LH    R4,QCLASSH               LOAD TABLE OFFSET
         CH    R4,=H'36'                IS THIS THE LAST QUEUE?
         BNL   NEXTJQT9                 YES. GO HOME.
NEXTJQT2 TR    QCLASS,NAMETBL           MOVE CLASS NAME TO QCLASS
         SLL   R4,2                     * 4
         USING JQTDSECT,R1              BASE REG FOR JQT
         L     R1,QCJQHEAD              LOAD ADDR OF JQT
         LA    R4,JQTCLSA(R4)           NEXT QUEUE
         DROP  R1
         BR    R2                       RETURN TO CALLER
NEXTJQT9 CLI   QCODE,0                  IS THIS A STATUS REQUEST?
         BE    ST5                      YES. GO TO STATUS.
         CLI   QCODE,36                 IS THIS A DJ REQUEST?
         BNE   SRCHSTOP                 NO. GO HOME.
         B     ST5                      YES. GO TO STATUS.
***********************************************************************
*                                                                     *
*   DETERMINE OUTPUT QUEUE                                            *
*                                                                     *
***********************************************************************
FINDJOT  TR    QCLASS,CLASSTBL          DETERMINE OFFSET
         LH    R4,QCLASSH               LOAD TABLE OFFSET
         LA    R4,(JOTCLSQ-JOTRDYWQ)/4  TO A-Z,0-9 CLASSES
THISJOT  STH   R4,QCLASSH
         B     FINDJOT1
NEXTJOT  LA    R4,1
         AH    R4,QCLASSH
         STH   R4,QCLASSH
FINDJOT1 CH    R4,=Y(2+(2*36))          IS THIS THE LAST QUEUE?
         BNL   SRCHSTOP                 YES. GO HOME.
         LR    R1,R4              COPY QUEUE ID
         SLL   R1,1               OFFSET OF QUEUE CHAR FORM
         LA    R1,SR#TAB1(R1)     @ OF QUEUE ID
         MVC   QCLASSE,0(R1)      RETURN QUEUE ID IN CHAR TOO
         SLL   R4,2                     * 4 FOR OFFSET
         USING JOTDSECT,R1              BASE REG FOR JOT
         L     R1,QCJOTA                LOAD ADDR OF JOT
         LA    R4,JOTRDYWQ(R4)          NEXT QUEUE
         DROP  R1
         BR    R2                       RETURN TO CALLER
***********************************************************************
*                                                                     *
*   GO HOME                                                           *
*                                                                     *
***********************************************************************
SRCHSTOP QSTOP
***********************************************************************
*                                                                     *
*   TABLES FOR CLASS DETERMINATION                                    *
*                                                                     *
***********************************************************************
NAMETBL  DC    C'ABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789'
CLASSTBL DC    192X'01'
         DC    X'00010203040506070809',7X'00'
         DC    X'0A0B0C0D0E0F101112',8X'00'
         DC    X'131415161718191A',6X'00'
         DC    X'1B1C1D1E1F2021222324',6X'00'
         SPACE 1
SR#TAB1  DC    C'DP'              DUMP QUEUE
         DC    C'NT'              NETWORK QUEUE
         DC    C'A A>B B>C C>D D>E E>F F>G G>H H>I I>J J>K K>L L>M M>'
         DC    C'N N>O O>P P>Q Q>R R>S S>T T>U U>V V>W W>X X>Y Y>Z Z>'
         DC    C'0 0>1 1>2 2>3 3>4 4>5 5>6 6>7 7>8 8>9 9>'
         LTORG
SR#WORK  DC    0D'0'
PRIORITY DS    3F
         SPACE 1
         DROP  R10,R9,R8
    TITLE '--- QUEUE/SP --SYSLOG -- PRINT THE SYSTEM LOG DATASET ---'
SYSLOG   QSTART  Q21
         USING QCKPT,R10                BASE REG FOR CKPT WORK AREA
         L     R10,QVCKPT               LOAD BASE REG
***********************************************************************
*                                                                     *
*   CALL FINDJOB TO LOCATE THE JQE, JCT, AND IOT                      *
*                                                                     *
***********************************************************************
         QCALL FINDJOB                  FIND THE JOB
***********************************************************************
*                                                                     *
*   CHECK JOBNAME EQUAL SYSLOG                                        *
*                                                                     *
***********************************************************************
         L     R9,QCJCTA                ADDR OF IOAREA FOR JCT
         USING JCTSTART,R9              BASE REG FOR JCT
         CLC   JCTJNAME,=CL8'SYSLOG'    IS THIS SYSLOG?
         BNE   SL$TILT                  NO. TILT.
***********************************************************************
*                                                                     *
*   DETERMINE NUMBER OF DATASETS FROM CURRENT DATASET                 *
*                                                                     *
***********************************************************************
         LH    R3,JCTPDDBK              HIGHEST DATASET ID NUMBER
         LH    R1,QLNG2                 LENGTH OF BACKUP PARM
         SH    R1,=H'1'                 IS THE BACKUP PARM ZERO LENGTH?
         BM    SL$CALST                 YES. SKIP.
         CLI   QPARM2,C'-'              IS THERE A MINUS SIGN?
         BNE   *+8                      NO. SKIP.
         MVI   QPARM2,C'0'              CHANGE MINUS TO ZERO
         LA    R15,QPARM2               POINT TO PARM
         BAL   R14,QNUMCONV             CONVERT IT
         BNE   SL$TILT                  QUIT IF NOT NUMERIC
         SR    R3,R15                   BACK UP NUMBER OF DATASETS
         CH    R3,=H'101'               IS THE NUMBER LESS THAN 101?
         BL    SL$TILT                  YES. TILT.
***********************************************************************
*                                                                     *
*   CALL LISTDS TO LIST THE DATASET                                   *
*                                                                     *
***********************************************************************
SL$CALST STH   R3,QPDSID                STORE DATASET ID
         MVC   QPOFFSET,=H'0'           PRINT OFFSET ZERO
         QCALL LISTDS
         QSTOP
SL$TILT  QTILT '*** INVALID PARAMETER ***'
         SPACE 1
         LTORG
         SPACE 3
         DROP  R10,R9
   TITLE '--- QUEUE/SP --TILT -- ERROR MESSAGE ROUTINE ---'
*---------------------------------------------------------------------*
*                                                                     *
*  TILT - ERROR MESSAGE ROUTINE                                       *
*                                                                     *
* ENTRY: R0  - LENGTH OF ERROR MESSAGE                                *
*        R1  - ADDRESS OF ERROR MESSAGE                               *
*        R15 - @ TILT                                                 *
*                                                                     *
*---------------------------------------------------------------------*
         SPACE 1
TILT     QSTART ,
         L     R7,QVDSPL          @ DISPLAY WORK AREA
         USING QDISPLAY,R7
         LR    R2,R1              @ ERROR MSG TEXT
         LR    R3,R0              LENGTH OF ERROR TEXT
         LA    R4,QDHLINE         ERROR MSG LINE
         LA    R5,L'QDHLINE       LENGTH OF ERROR MSG LINE
         DROP  R7
         CR    R3,R5              ERROR MSG TOO LONG?
         BNH   *+6                BIF ERROR MSG NOT TOO LONG
         LR    R3,R5              TRUNCATE ERROR MSG IF TOO LONG
         ICM   R3,B'1000',=C' '   PAD ERR MSG WITH BLANKS
         MVCL  R4,R2              MOVE ERROR MSG TO QDHLINE
TILT$L   QCALL DISPLAY,,0         DISPLAY ERROR MSG
         B     TILT$L              AND DISPLAY AGAIN
         DROP R12
   TITLE '--- QUEUE/SP --TSOCMD -- ATTACH A TSO COMMAND ---'
TSOCMD   QSTART  Q23
         CLC   QDREPLY+2(QDREPLYL-2),QBLANK  ANYTHING TO DO?
         BE    TC$TILT                  NO - ABORT
         SPACE 1
         TPUT  TC#CLEAR,L'TC#CLEAR,FULLSCR,,HOLD  CLEAR THE SCREEN
         SPACE 1
         STFSMODE  OFF                  TELL VTAM WE'RE DONE
         SPACE 2
         XC    QTMPMAC(QTMPMACL),QTMPMAC   INIT PARM LIST
         SPACE 1
         OACTMP  CMD=(QDREPLY+2,QDREPLYL-2),MF=(E,QTMPMAC)  DO IT
         SPACE 2
         STFSMODE  ON                   TELL VTAM WE'RE BACK
         SPACE 2
         QTILT '=== DONE ==='
         SPACE 2
TC$TILT  QTILT '*** MISSING OPERAND ***'
         SPACE 3
TC#CLEAR DC    X'C1115D7E1140403C40400013'   SPF TCAM CLEAR SCREEN
         LTORG ,
   TITLE '--- QUEUE/SP --XXCMD -- EXPERIMENTAL COMMAND ---'
*---------------------------------------------------------------------*
*                                                                     *
*  XXCMD -- EXPERIMENTAL COMMAND ROUTINE                              *
*                                                                     *
*---------------------------------------------------------------------*
         SPACE 1
XXCMD    QSTART ,
         SPACE 1
         L     R1,QVDSPL          @ DISPLAY WORK AREA
         USING QDISPLAY,R1
         MVC   QDHLINE,XXHEAD
         DROP  R1
         L     R3,QCJQHEAD        @ JQE QUEUE HEADS
         LA    R2,$JQTYPES        # OF JQE QUEUE HEADS
XX$QL1   LR    R4,R3              COPY @ CURRENT QUEUE HEAD
         SH    R4,=Y(QUENEXT)     MAKE LOOK LIKE JQE
         SR    R5,R5              INIT QUEUE POSITION ZERO
XX$QL2   QCALL NXT$JQE            TO NEXT JQE
         BZ    XX$NQ              BIF NO NEXT JQE
         USING JQEDSECT,R4
         MVC   XXLINE,QBLANK
         CVD   R5,XXDWD
         MVC   XXLINE(4),=X'40202120'
         ED    XXLINE(4),XXDWD+6
         QCALL CVQP$
         STCM  R1,15,XXLINE+5
         MVC   XXLINE+10(8),JQEJNAME
         LH    R0,JQEJOBNO
         CVD   R0,XXDWD
         UNPK  XXLINE+19(5),XXDWD+5(3)
         OI    XXLINE+19+5-1,C'0'
         DROP  R4                 (JQEDSECT)
         QCALL DISPLAY,XXLINE,L'XXLINE
         B     XX$QL2
XX$NQ    LA    R3,4(,R3)          @ NEXT JQE QUEUE HEAD
         BCT   R2,XX$QL1          BIF MORE QUEUES TO DO
         SPACE 1
         QCALL DISPLAY,,0
         QSTOP ,
         SPACE 1
         LTORG ,
XXDWD    DC    D'0'
XXLINE   DC    CL80' '
XXHEAD $ 'POS QUEUE JNAME JOBNO                             '
         DROP R12
         SPACE 1
*---------------------------------------------------------------------*
*                                                                     *
*  NXT$JQE -- CONTINUE "JQENEXT" SEARCH                               *
*                                                                     *
* ENTRY:  R4  - @ PREVIOUS JQE (ONLY JQENEXT FIELD IS VALID)          *
*         R5  - JQE CHAIN POSITION                                    *
*         R14 - RETURN ADDRESS                                        *
*         R15 - @ NXT$JQE                                             *
*                                                                     *
* EXIT:   CONDITION CODE SET -   0 - NO MORE JQE'S EXIST (R4 = 0)     *
*                               ^0 - R4 = @ JQE (R5 INCREMENTED)      *
*                                                                     *
*---------------------------------------------------------------------*
         SPACE 1
         USING JQEDSECT,R4
         USING NXT$JQE,R15
NXT$JQE  L     R4,JQENEXT         VALUE FROM JQENEXT
         N     R4,=X'00FFFFFF'     IS ZERO IF NO NEXT JQE
         BZR   R14                RIF NO NEXT JQE, CC ZERO, R4 = 0
         A     R4,QCJQTA          ADDRESS OF JQE FROM OFFSET
         LA    R5,1(,R5)          INCREMENT QUEUE POSITION
         BR    R14                RIF HAVE JQE, CC ^0, R4 = @ JQE
         DROP  R4,R15
         SPACE 1
*---------------------------------------------------------------------*
*                                                                     *
*  CVQP$  -- CONVERT JQEHEAD ADDRESS TO CHARACTER QUEUE ID            *
*                                                                     *
* ENTRY:  R3  - @ JQE QUEUE HEAD (IN MASTER RECORD)                   *
*         R14 - RETURN ADDRESS                                        *
*         R15 - @ NXT$JQE                                             *
*                                                                     *
* EXIT:   R1  - 4 CHARACTER QUEUE ID                                  *
*                                                                     *
*---------------------------------------------------------------------*
         SPACE 1
         USING CVQP$,R15
CVQP$    LA    R1,$JQHEADL(,R3)   OFFSET FOR $QINDEX
         S     R1,QCJQHEAD         SIMILAR LOOK UP
         CH    R1,=Y(48)          SPECIAL QUEUE? (< QUEUE 'A')
         BL    CVQP$2             BIF SPECIAL ID
         SRL   R1,2               QUEUE HEAD NUMBER
         IC    R1,CVQP#TB1-(48/4)(R1) GET QUEUE ID
         SLL   R1,24              ALIGN QUEUE ID
         ICM   R1,B'0111',QBLANK   AND BLANK REST
         BR    R14
CVQP$2   L     R1,CVQP#TB2-4(R1)  GET SPECIAL ID
         BR    R14                RIF WITH ID
         DROP  R15
         SPACE 1
CVQP#TB1 DC    0F'0',64AL1(0)     DEFAULT ALL UNKNOWN
         ORG   CVQP#TB1                 A - I
         DC    C'ABCDEFGHI'
         ORG   CVQP#TB1+C'J'-C'A'       J - R
         DC    C'JKLMNOPQR'
         ORG   CVQP#TB1+C'S'-C'A'       S - Z
         DC    C'STUVWXYZ'
         ORG   CVQP#TB1+C'0'-C'A'       0 - 9
         DC    C'0123456789'
         ORG   ,
         SPACE 1
CVQP#TB2 DC    0F'0'
         DC    CL4'FREE'          0 - FREE
         DC    CL4'PURG'          1 - PURGE
         DC    CL4'HCPY'          2 - HARDCPY
         DC    CL4'OUT '          3 - OUTPUT
         DC    CL4'REC '          4 - RECEIVE
         DC    CL4'SETU'          5 - SETUP
         DC    CL4'XMIT'          6 - XMIT
         DC    CL4'IN  '          7 - INPUT
         DC    CL4'XEQ '          8 - XEQ
         DC    CL4'STC '          9 - STC
         DC    CL4'TSU '         10 - TSU
         TITLE '--- QUEUE/SP COMMON AREA ---'
***********************************************************************
*                                                                     *
*   QUEUE COMMAND - COMMON AREA                                       *
*                                                                     *
*                                                                     *
*   VECTOR TABLE - ADDRESSES OF AREAS IN QCOMMON                      *
*                                                                     *
***********************************************************************
QCOMMON  CSECT ,
QVDSPL   DC    A(QDISPLAY)              PTR TO DISPLAY WORK AREA
QVDAIR   DC    A(QDAIR)                 PTR TO DAIR WORK AREA
QVCKPT   DC    A(QCKPT)                 PTR TO CKPT WORK AREA
QCSTACKI DC    F'72'                    SAVE AREA LENGTH
QCOLDSAV DC    A(1)                     @ QUEUE CALLERS SAVE AREA
         DC    4F'0'                    SPARE PTRS RESERVED FOR FUTURE
QFRSTSA  DC    A(0)                     ADDRESS OF FIRST SAVE AREA
QCJQHEAD DC    A(0)                     @ OF $JQHEADS IN MASTER REC
QCJQTL   DC    A(0)               @ OF MASTER RECORD
QCMSTTR  DC    0F'0',X'00000300'  TTR OF MASTRER CKPT RECORD
QCJQTA   DC    A(0)    *ORDER*    @ JQE CKPT AREA
QCJQETTR DC    F'0'    *ORDER*    TTR OF 1ST JQE CKPT BLOCK
QCJQENUM DC    F'0'    *ORDER*    # OF JQE CKPT BLOCKS
QCJOTA   DC    A(0)    *ORDER*    @ JOE CKPT AREA
QCJOETTR DC    F'0'    *ORDER*    TTR OF 1ST JQE CKPT BLOCK
QCJOENUM DC    F'0'    *ORDER*    # OF JOE CKPT BLOCKS
QCJCTA   DC    A(0)               @ OF JCT BUFFER
QCIOTA   DC    A(0)               @ OF IOT BUFFER
QCBLKA   DC    A(0)               @ OF DATASET BLOCK BUFFER
***********************************************************************
*                                                                     *
*   NUMERIC CONVERT ROUTINE                                           *
*                                                                     *
***********************************************************************
         PUSH  USING
         USING QCOMMON,R11
QNUMCONV MVC   QFZONES,QFZONE           INIT FIELD
         EX    R1,QMVZ                  COPY THE ZONES
         CLC   QFZONES,QFZONE           ALL NUMBERS?
         BNER  R14                      NO - RETURN WITH CC SET TO "NE"
         EX    R1,QPACK                 PACK IT
         CVB   R15,QNUMWORK             GET IT IN BINARY
         BR    R14                      RETURN WITH CC SET TO "EQ"
QMVZ     MVZ   QFZONES(*-*),0(R15)      << EXECUTED >>
QPACK    PACK  QNUMWORK,0(*-*,R15)      << EXECUTED >>
         POP   USING
***********************************************************************
*                                                                     *
*   MISCELLANEOUS NUTS AND BOLTS                                      *
*                                                                     *
***********************************************************************
QLOGON   DC    CL7' '                   LOGON ID (PSCBUSER)
QLOGONL  DC    AL1(0)                   LENGTH OF LOGON ID
QCLASSH  DC    0H'0',X'00'              HALFWORD BOUNDARY
QCLASS   DC    C' '                     SEARCH CLASS
QCLASSE  DC    CL2' '                   EXTERNAL CLASS
         CNOP  2,4
QCODEH   DC    0H'0',X'00'              HALFWORD BOUNDARY
QCODE    DC    X'00'                    SEARCH FUNCTION CODE
QSUBCMD  DC    A(0)                     ADDR OF CURRENT SUBCOMMAND
QOFF0    DC    H'0'                     OFFSET TO SUBCOMMAND
QLNG0    DC    H'0'                     LENGTH OF SUBCOMMAND
QSUBNAME DC    CL8'STATUS'              NAME OF SUBCOMMAND
QOFF1    DC    H'0'                     OFFSET TO QPARM1
QLNG1    DC    H'0'                     LENGTH OF QPARM1
QPARM1   DC    CL8' '                   USER SUPPLIED PARAMETER #1
QOFF2    DC    H'0'
QLNG2    DC    H'0'
QPARM2   DC    CL8' '                                           #2
QOFF3    DC    H'0'
QLNG3    DC    H'0'
QPARM3   DC    CL8' '                                           #3
QOFF4    DC    H'0'
QLNG4    DC    H'0'
QPARM4   DC    CL8' '                                           #4
QJOBID   DC    H'0',CL8' '              LAST JOBID (AND LENGTH)
QSTKEY   DC    CL8' '                   SEARCH KEY FOR "ST" SUBCMD
QXAUTH   DC    X'00'
QSYNADFL DC    X'00'                    SYNAD FLAG
         DC    XL2'0'                   RESERVED
QBLANK   DC    CL80' '                  80 BLANKS
QNUMWORK DC    D'0'                     CONVERT WORK AREA
QFZONE   DC    C'0'                     USED TO CLEAR QFZONES
QFZONES  DC    C'00000000'              USED FOR NUMERIC CHECK
QCOUNT   DC    PL3'0'                   NUMBER OF ELEMENTS IN QUEUE
QPJOBID  DC    XL4'0'                   JOB ID FOR LISTDS
QPDSID   DC    H'0'                     DATASET ID FOR LISTDS
QPOFFSET DC    H'0'                     PRINT OFFSET FROM BEG. OF REC
QPREC    DC    PL4'0'                   CURRENT RECORD COUNT
QPLNG    DC    H'0'                     LEN OF COMPARE FIELD FOR FIND
QPFIND   DC    CL64' '                  COMPARE FIELD FOR FIND
QSYSID   DC    8CL8' '                  SYSTEM ID TABLE
         SPACE 1
QTMPMAC  OACTMP  MF=L                   PARMLIST AREA FOR "TSOCMD"
QTMPMACL EQU   *-QTMPMAC                LENGTH TO CLEAR
         EJECT
***********************************************************************
*                                                                     *
*   DISPLAY WORK FIELDS                                               *
*                                                                     *
***********************************************************************
QDISPLAY DC    0D'0'                    START OS DISPLAY WORK AREA
QDREPLYL EQU   66                       LENGTH OF REPLY AREA
PFREPLY  DS    0CL(6+QDREPLYL)                                     ICBC
PFCODE   DC    CL6' '                                              ICBC
PFTXT    DC    CL(QDREPLYL)' '                                     ICBC
QDMSGA   DC    A(0)                     ADDRESS OF MSG TO BE DISPLAYED
QDMLNG   DC    H'0'                     MESSAGE LENGTH
QDMSG    DC    CL80' '                  AREA FOR BUILDING OUTPUT LINE
QDRLNG   DC    H'6'                     REPLY LENGTH
QDREPLY  DC    CL(QDREPLYL)'STATUS'     TERMINAL USER REPLY
QDPROMPT DC    CL(QDREPLYL)'STATUS'     HIS PREVIOUS COMMAND
         DC    C' '                     RESERVED
QDNEXT   DC    H'0'                     CURRENT LINE NUMBER ON SCREEN
         DC    C' '                     RESERVED
QDSCREEN DS    0C                       DISPLAY SCREEN
         DC    X'C1115D7F114040'        SPF-TCAM PREFIX
*  NOTE:  THE FIRST DISPLAY FIELD IS PROT NORM FROM ATTR BYTE AT (2,80)
         DC    X'3C405E',C'-'           RA TO (1,33) C'-'
         DC    X'1DE8'                  ATTR - PROT BRIGHT
         DC    C'QUEUE/SP'              TITLE IN CENTER OF TOP LINE
         DC    X'1D60'                  ATTR - PROT NORM
         DC    X'3CC1C9',C'-'           RA TO (1,74) C'-'
         DC    X'1DE8'                  ATTR - PROT BRIGHT
QDMORE   DC    CL6' '                   INDICATES MORE TO BE DISPLAYED
         DC    C'COMMAND ===>'          SHOW HIM WHERE TO TYPE
         DC    X'1D40'                  ATTR - INPUT NORM
QDTLINE  DC    CL(QDREPLYL)' '          INPUT AREA / LAST COMMAND
         DC    X'1DE8'                  ATTR - PROT BRIGHT
QDHLINE  DC    CL79' '                  HEADING LINE
         DC    X'1D60'                  ATTR - PROT NORM
QDLINE1  DC    CL80' '                  FIRST MESSAGE LINE ON SCREEN
         DC    20CL80' '                NEXT 20 LINES
QDFINAL  DC    X'1140400513'            PT TO FIRST INPUT FIELD; IC
*                                       (TCAM REQUIRES CURSOR AT END)
QDSLNG   EQU   *-QDSCREEN               LENGTH OF SCREEN BUFFER
QDOVER   DC    X'00'                    PAGE OVERFLOW INDICATOR
         EJECT
***********************************************************************
*                                                                     *
*   DATASET ALLOCATION FIELDS                                         *
*      (ADAPTED FROM SYS1.MACLIB (IKJDAPL,IKJDAP08,18,2C))            *
*                                                                     *
***********************************************************************
QDAIR    DC    0D'0'                    START OF DAIR WORK AREAS
DAIRECB  DC    F'0'                     ECB USED BY DAIR
DAIRFLAG DC    X'00'                    FLAG FOR ALLOCATE SUBROUTINE
         DC    XL3'0'                   DEAD SPACE FOR ALLIGNMENT
***********************************************************************
*    THE DYNAMIC ALLOCATION INTERFACE ROUTINE (DAIR) PARAMETER LIST   *
*    (DAPL) IS A LIST OF ADDRESSES PASSED FROM THE INVOKER TO DAIR    *
*    VIA REGISTER 1                                                   *
***********************************************************************
DAPLUPT  DC    A(0)                     PTR TO UPT
DAPLECT  DC    A(0)                     PTR TO ECT
DAPLECB  DC    A(DAIRECB)               PTR TO CP'S ECB
DAPLPSCB DC    A(0)                     PTR TO PSCB
DAPLDAPB DC    A(0)                     PTR TO DAIR PARAMETER BLOCK
***********************************************************************
*                                                                     *
*   CHECK TO SEE IF A DSN IS ALLOCATED                                *
*                                                                     *
***********************************************************************
DA00CD   DC    X'0008'                  DAIR ENTRY CODE
DA00FLG  DC    X'00'                    FLAGS RETURNED
         DC    X'00'                    RESERVED
DA00PDSN DC    A(0)                     PTR TO DSN TO BE SRCHED IN DSE
DA00DDN  DC    CL8' '                   DDNAME TO BE SEARCHED IN DSE
DA00CTL  DC    X'00'                    FLAG BYTE
         DC    XL2'0'                   RESERVED
DA00DSO  DC    X'00'                    RETURNED DSORG
***********************************************************************
*                                                                     *
*   ALLOCATE DDNAME(W) DSNAME(X) SHR UNIT(Y) VOLUME(Z)                *
*                                                                     *
***********************************************************************
DA08CD   DC    X'0008'                  DAIR ENTRY CODE
DA08FLG  DC    X'00'                    FLAGS SET BY DAIR
         DC    X'00'
DA08DARC DC    H'0'                     DYN ALLOC RETURN CODE
DA08CTRC DC    H'0'                     CATALOG RETURN CODE
DA08PDSN DC    A(0)                     PTR TO DSN TO BE SRCHED IN DSE
DA08DDN  DC    CL8' '                   DDNAME TO BE SEARCHED IN DSE
* YOU MUST SUPPLY THE DEFAULT UNIT AND VOLUME SERIAL FOR YOUR SYSTEM
DA08UNIT DC    CL8' '                   UNIT FOR SYS1.HASPCKPT
DA08SER  DC    CL8' '                   VOLSER FOR SYS1.HASPCKPT
DA08BLK  DC    F'0'                     DATA SET AVERAGE REC LENGTH
DA08PQTY DC    F'0'                     PRIMARY SPACE QUANTITY
DA08SQTY DC    F'0'                     SECONDARY SPACE QUANTITY
DA08DQTY DC    F'0'                     DIRECTORY BLOCK QUANTITY
DA08MNM  DC    CL8' '                   MEMBER NAME
DA08PSWD DC    CL8' '                   PASSWORD
DA08DSP1 DC    X'08'                    STATUS FLAGS - SHR
DA08DPS2 DC    X'08'                    DATA SET DISPOSITION - KEEP
DA08DPS3 DC    X'08'                    DATA SET COND. DISP. - KEEP
DA08CTL  DC    X'00'                    DAIR ACTION FLAGS
         DC    XL3'0'                   RESERVED
DA08DSO  DC    X'00'                    DSORG
DA08ALN  DC    CL8' '                   ATTR-LIST-NAME           C99236
***********************************************************************
*                                                                     *
*   FREE DDNAME(XXXXXXXX)                                             *
*                                                                     *
***********************************************************************
DA18CD   DC    X'0018'                  DAIR ENTRY CODE
DA18FLG  DC    X'00'                    FLAGS SET BY DAIR
         DC    X'00'
DA18DARC DC    H'0'                     DYNAMIC ALLOCATION RETURN CODE
DA18CTRC DC    H'0'                     CATALOG RETURN CODE AREA
DA18PDSN DC    A(0)                     PTR TO DSN TO BE SRCHED IN DSE
DA18DDN  DC    CL8' '                   DDNAME TO BE SEARCHED IN DSE
DA18MNM  DC    CL8' '                   MEMBER NAME
DA18SCLS DC    CL2' '                   SYSOUT CLASS DESIRED WHEN
*                                       UNALLOC'ING A SYSOUT DATA SET
DA18DPS2 DC    X'08'                    DATA SET DISPOSITION - KEEP
DA18CTL  DC    X'10'                    FLAGS FOR SPECIAL DAIR PROC'ING
DA18JBNM DC    CL8' '                   IGNORED AS OF OS VS/2 RELEASE 2
***********************************************************************
*                                                                     *
*   MARK A DATASET "NOT IN USE"                                       *
*                                                                     *
***********************************************************************
DA2CCD   DC    X'002C'                  DAIR ENTRY CODE
DA2CFLG  DC    X'0001'                  MARK SPECIFIC DDN "NOT IN USE"
DA2CTCB  DC    XL4'00'                  UNUSED FOR THIS CALL TYPE
DA2CDDN  DC    CL8' '                   DDNAME TO FLAG
         EJECT
***********************************************************************
*                                                                     *
*   CHECKPOINT WORK AREAS                                             *
*                                                                     *
***********************************************************************
         SPACE 1
QCKPT    DC    0D'0'
QCDECBPT DC    A(0)               @ DECB WORK AREA FOR CKPT ROUTINE
         SPACE 1
QCJQEA   DC    A(0)               ADDR CURRENT JQE (SELECTED JOB)
QCPDDB1  DC    F'0'                     OFFSET IN IOT TO FIRST PDDB
QCTRAK   DS    0F                       DISK ADDR IN THE FORM MTTR
QCTRAKM  DC    X'0'                     EXTENT NUMBER
QCTRAKTT DC    X'0000'                  ABSOLUTE TRACK NUMBER
QCTRAKR  DC    X'0'                     RECORD NUMBER
         DC    X'0'                     EXTRA SPACE NEEDED FOR HEX CONV
QCDAD    DS    0XL8                     DISK ADDR IN THE FORM MBBCCHHR
QCDADM   DC    X'0'                     EXTENT NUMBER
QCDADBB  DC    X'0000'                  BIN NUMBER
QCDADCC  DC    X'0000'                  CYLINDER NUMBER
QCDADHH  DC    X'0000'                  HEAD NUMBER
QCDADR   DC    X'0'                     RECORD NUMBER
         DC    XL3'0'                   DEAD SPACE TO GET BACK TO FW
         DS    0F
QCCREC   DC    PL4'0'                   CURRENT RECORD NUMBER
QCCPTR   DC    A(0)                     CURRENT TABLE ADDRESS
QCHREC   DC    PL4'0'                   HIGHEST RECORD NUMBER
QCHPTR   DC    A(0)                     HIGHEST TABLE ADDRESS
QCSTART  DC    A(0)                     ADDRESS OF TABLE START
QCEND    DC    A(0)                     ADDRESS OF TABLE END
QCHLINE  DS    0CL80                    HEADING LINE FOR LISTDS
         DC    C'JOB '
QCJNAME  DC    CL8' '                   JOBNAME
         DC    C'  DSID '
QCDSNO   DC    CL8' '                   DATASET ID NUMBER
         DC    C'  REC #       1'
         DC    CL40' '
QCLRECL  DC    H'0'                     LRECL FOR SAVE
QCRECFM  DC    X'0'                     RECFM FOR SAVE
QCSPOPNL DC    36F'0'                   DCB OPEN LIST FOR HASPACE
QCSPDCBP DC    36F'0'                   DCB PTRS INDEX BY M*4 (MTTR)
QCSPNMTC DC    36F'0'                   # TRK/CYL FOR HASPACE
         SPACE 1
*HASPCKPT DCB  DDNAME=JES2CKPT,DSORG=PS,MACRF=(RCP),RECFM=U
HASPCKPT DCB   DDNAME=JES2CKPT,DSORG=PS,MACRF=(RCP),RECFM=U,           X
               NCP=3
         SPACE 5
*HASPACE DCB   DDNAME=JES2ACE1,DSORG=DA,MACRF=(RIC),OPTCD=A,RECFM=F
HASPACE  DCB   DDNAME=JES2ACE1,DSORG=DA,MACRF=(RIC),OPTCD=A,RECFM=F
         SPACE 3
QCDCBL   EQU   *-HASPACE                LENGTH OF HASPACE DCB
         SPACE 5
*QCOUT   DCB   DDNAME=JES2SAVE,DSORG=PS,MACRF=(PM),BUFL=8192
QCOUT    DCB   DDNAME=JES2SAVE,DSORG=PS,MACRF=(PM),BUFL=8192
         SPACE 5
*        READ  HDECB1,SF,HASPCKPT,,'S',MF=L
         READ  HDECB1,SF,HASPCKPT,,'S',MF=L
HDECB1L  EQU   *-HDECB1           LENGTH OF DECB FOR HASPCKPT
         SPACE 3
*        READ  HDECB2,DI,HASPACE,,0,0,QCDAD,MF=L
         READ  HDECB2,DI,HASPACE,,0,0,QCDAD,MF=L
         SPACE 3
*QCOPEN  OPEN  (QCOUT,OUTPUT),MF=L
QCOPEN   OPEN  (QCOUT,OUTPUT),MF=L
         SPACE 1
*HOCKPT  OPEN  (HASPCKPT),MF=L
HOCKPT   OPEN  (HASPCKPT),MF=L
         SPACE 2
QCOMMONL EQU   *-QCOMMON                LENGTH OF COMMON AREA
         SPACE 1
QCOMMON  CSECT                          RESUME
         ORG   QDMSG
PGMNAME  DS    CL8
         DS    CL2
PROCNAME DS    CL8
         DS    CL6
STEPNAME DS    CL8
         DS    CL2
PROCSTEP DS    CL8
         DS    CL3
DDN      DS    CL8
         DS    CL3
DSID     DS    CL4
         DS    CL2
HELD     DS    CL2                      'H-' OR BLANK
DSTYPE   DS    CL6                      'SYSOUT' OR 'SYSIN'
RECORDS  DS    CL8
         SPACE 1
QCOMMON  CSECT                          RESUME
         ORG   QDMSG
FCLEAR   DS    0CL80                    FORMAT FOR QUEUE RECORDS
FQNAME   DS    C                        NAME OF QUEUE (I,O,TSU,SYS,H/O)
         DS    C
FQUEUE   DS    CL2                      CLASS NAME (IF FQNAME=I OR O)
         DS    C
FCOUNT   DS    CL4                      POSITION IN QUEUE
         DS    C
FNAME    DS    CL8                      JOBNAME
         DS    C
FJOBNO   DS    CL5                      JES2 JOB NUMBER
         DS    C
FPRIO    DS    CL3                      JOB PRIORITY
         DS    C
FLINES   DS    CL6                      NUMBER OF OUTPUT LINES
         DS    CL2
FSYSID   DS    CL4                      SYSTEM ID
         DS    CL2
FHOLD    DS    CL4                      JOB HOLD STATUS
         DS    CL2
FPRINT   DS    CL4                      PRINTING
         DS    CL2
FFORM    DS    CL4                      FORM NAME
         DS    C
FFCB     DS    CL4                      FCB NAME
         DS    C
FUCS     DS    CL4                      UCS NAME
         DS    CL2
FREMOTE  DS    CL4                      REMOTE JOB (RJE)
         SPACE 2
         ORG   FCOUNT
FHEXID   DS    CL4
         DS    C
FHEXDATA DS    CL71
         SPACE 1
QCOMMON  CSECT                          RESUME
         ORG   QDHLINE
         DS    C'JOB XXXXXXXX, DSID XXXXXXXX, REC #'
HREC     DS    CL8
HEND     DS    C', END OF DATA. LAST REC #'
HREND    DS    CL8
    TITLE '--- QUEUE/SP --IKJCPPL AND IKJPSCB DSECTS ---'
JQTDSECT DSECT ,
         ORG   JQTDSECT+8
JQTOUT   DC    A(0)
         ORG   JQTDSECT+36
JQTSTC   DC    A(0)
         ORG   JQTDSECT+40
JQTTSU   DC    A(0)
         ORG   JQTDSECT+44
JQTCLSA  DC    A(0)
         SPACE 1
         PRINT OFF
         IKJCPPL
         IKJPSCB
         IHADCB DSORG=(PS,DA)
         END   QUEUE
//*KED.SYSLMOD DD DISP=SHR,DSN=SYS9.SYSCP,SPACE=,UNIT=
//LKED.SYSLMOD DD DISP=SHR,DSN=CSYSMAS.LOAD,SPACE=,UNIT=
//LKED.SYSIN DD *
  ENTRY QUEUE
  NAME QSP$(R)
//
//C  EXEC PGM=COMPARE,PARM='QSP,QSP'
//STEPLIB  DD DISP=SHR,DSN=SYS5.MSSLOAD
//SYSPRINT DD SYSOUT=*
//I1       DD DISP=(SHR,PASS),DSN=&&GOSET
//I2       DD DISP=SHR,DSN=CSYSMAS.LOAD
//
