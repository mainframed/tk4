***********************************************************************
*
*  THIS MODULE IS INTENDED TO FUNCTION AS A FRONT END TO THE PROGRAM
*  CHECK FIRST LEVEL INTERRUPT HANDLER, IEAQPK00.  ITS PURPOSE IS TO
*  INTERCEPT ALL PROGRAM CHECKS RESULTING FROM RUNNING MVS-SE ON A
*  UNI-PROCESSOR THAT DOES NOT HAVE THE EXTENDED FACILITY HARDWARE
*  INSTALLED.
*
*  IN ADDITION TO THE PROGRAM CHECKS, IT IS NECESSARY TO INTERCEPT ALL
*  TRANSLATION SPECIFICATION EXCEPTIONS RESULTING FROM THE PRESENCE OF
*  THE COMMON AREA FLAG IN SOME OF THE SGTE ENTRIES.  RECOVERY IS
*  ACCOMPLISHED BY TURNING OFF ALL KNOWN OCCURANCES OF THE BIT IN
*  THE CURRENTLY UTILIZED SEGMENT-TABLE AND RETRYING THE FAILING
*  INSTRUCTION.  IF THE EXCEPTION IS NOT THE RESULT OF A COMMON AREA
*  FLAG, THE RE-EXECUTION OF THE INSTRUCTION WILL ALSO FAIL, AND A
*  TIGHT LOOP WILL OCCUR.  BECAUSE THIS IS EXTREMELY UNLIKELY, NO
*  ATTEMPT IS MADE TO CHECK FOR THIS PARTICULAR SITUATION.  SHOULD IT
*  EVER HAPPEN, CONSIDERATION SHOULD BE GIVEN TO ADDING SUCH CODE.
*
*  CONTROL IS GIVEN BY REPLACING THE V-CON REFERENCE TO IEAQPK00 IN
*  FLCPNPSW WITH A REFERENCE TO SEPCFLIH.  IF THE FAILURE IS AN
*  EXTENDED FACILITY INSTRUCTION, THE FUNCTION WILL BE SIMULATED.
*  OTHERWISE, CONTROL WILL BE GIVEN TO IEAQPK00 (AS IEAQPK99).
*
*  NOTE THAT PART OF THE PSA (RESERVED AREA) IS REDEFINED IN ORDER TO
*  HAVE A SAVE AREA FOR REGISTERS AND PSW DATA.
*
*  INSTALLATION IS ACCOMPLISHED BY RELINKING THE NUCLEUS, CHANGING
*  SEPCFLIH TO IEAQPK00 AND IEAQPK00 TO IEAQPK99.
*
*  A SAMPLE IS AS FOLLOWS:
*  INSERT IEAVNIP0
*  INSERT IEAVFX00
*  INSERT IGFPMCIH,IGFRWAC
*  INSERT IGFPMPFX,IGFPMSCA,IGFPMHCA
*  INSERT IGFPMRTM,IGFPMTHA,IGFPMFRS
*  INSERT IGFPMMSG,IGFPMKTA,IGFPKREF
*  INSERT IGFPTERM,IGFPTSIG
*  INSERT IGFCCHED
*  INSERT IGFPNRFH
*  INSERT IGFPXMFA,IGFPTAIM
*  INSERT IGFPBUCR,IGFPEXIT
*  INSERT IGFPSAD0
*  INSERT IGFPTCON,IGFPTREC
*  CHANGE SEPCFLIH(IEAQPK00)     ** ADDED CONTROL CARDS **
*  INCLUDE LIB(SEPCFLIH)         ** ADDED CONTROL CARDS **
*  CHANGE IEAQPK00(IEAQPK99)     ** ADDED CONTROL CARDS **
*  INCLUDE AOSC5(IEAVEPC)        ** ADDED CONTROL CARDS **
*  INCLUDE NUCLEUS(IEANUC01)
*  NAME IEANUC01(R)
*
*  NOTE THAT THE DAT IS NOT ENABLED UNLESS AN OPERATION EXCEPTION
*  HAS BEEN DETECTED.  THIS IS BECAUSE OF THE CHECKING FOR TRANSLATION
*  SPECIFICATION EXCEPTIONS.
*
*  NOTE THAT PART OF THE PSA (RESERVED AREA) IS REDEFINED IN ORDER TO
*  HAVE A SAVE AREA FOR REGISTERS AND PSW DATA.
*
*  ONE OF THE CURRENT DESIGN CONSTRAINTS IS THAT NO IBM CODE IS TO BE
*  MODIFIED (STATIC) WITHOUT SUFFICIENT CAUSE.  IN ORDER TO ACHIEVE
*  MAXIMUM PERFORMANCE, ADDITIONAL DYNAMIC CODE MODIFICATION MAY BE
*  NECESSARY.
*  THE SVC ASSIST INSTRUCTION IN IEAVESVC IS NO-OP'D AS PART OF THE
*  RECOVERY CODE (THIS IS IN THE NUCLEUS).
*  THE TEST PROTECTION INSTRUCTIONS IN IEAVEVAL AND IEAVSY50 ARE
*  NO-OP'D AS PART OF THE RECOVERY CODE (BOTH ARE IN THE NUCLEUS).
*
*  THIS CODE WILL RUN ON AN AP/MP MACHINE THAT HAS THE SE HARDWARE
*  INSTALLED.
*
*  IF THIS FACILITY IS TO BE UTILIZED IN AN AP/MP ENVIRONMENT WITHOUT
*  THE SE HARDWARE FEATURE INSTALLED, THE IPTE CODE MUST BE CHANGED
*  TO ALLOW FOR THE SHOULDER TAP OF THE OTHER CPU IN ORDER TO PERFORM
*  A PTLB ON THAT CPU AS WELL.  LOOK AT THE CODE IN IEAVINV.  IT
*  SHOULD BE POSSIBLE TO DO THIS BY TAKING THE VIRTUAL ADDRESS OF THE
*  PGTE AND PASSING CONTROL TO IEAVINV.  IT'S ADDRESS IS IN PVT+X'AC'.
*  NOTE INPUT REGISTER CONVENTIONS FOR THAT MODULE.
*
*  NOTE THAT THIS PROGRAM CANNOT BE TESTED USING THE ALTERNATE NUCLEUS
*  FACILITY OF MVS-SE UNLESS A WORKING VERSION OF IT IS ALSO PRESENT
*  IN IEANUC01.  THIS IS THE RESULT OF SE CODE IN IPL-NIP THAT IS
*  UTILIZED PRIOR TO THE PROMPTING THAT ALLOWS AN ALTERNATE NUCLEUS
*  SPECIFICATION.  IEAVESVC ISSUES SVC ASSIST, PROGRAM CHECK WILL
*  OCCUR, IEAQPK00 IS GIVEN CONTROL, TRACE PI INSTRUCTION IS ISSUED,
*  WHICH WILL PROGRAM CHECK, AND HENCE RECURSION IS IN PROGRESS.
*
*  PERFORMANCE DATA IS NOT AVAILABLE AT THIS TIME, BUT IT APPEARS
*  TO OUT-PERFORM THE NON-SE SYSTEM THAT WAS REPLACED.
*
*
* ROUTINE  INSTRUCTION             FORMAT          SAMPLE TRACE COUNT
*                                                  DURING INITIAL TEST
*                                                  (12 HOUR PERIOD)
*  PC01    IPTE                    B221........     198887
*  PC02    TEST PROTECTION         E501........     104001
*  PC03    FIX PAGE                E502....00A4    1829294
*  PC04    SVC ASSIST              E5030224021C    2685109
*  PC05    OBTAIN LOCAL LOCK       E504022402F8    1461603
*  PC06    RELEASE LOCAL LOCK      E505022402F8    3712486
*  PC07    OBTAIN CMS LOCK         E506022402F8     483141
*  PC08    RELEASE CMS LOCK        E507022402F8     468765
*  PC09    TRACE SVC INTERRUPT     E508....0020    2685109
*  PC10    TRACE PROGRAM INTERRUPT E509....0028     195612
*  PC11    TRACE SRB DISPATCH      E50A....0420     897365
*  PC12    TRACE I/O INTERRUPT     E50B....0038     687709
*  PC13    TRACE TASK DISPATCH     E50C........    1083367
*  PC14    TRACE SVC RETURN        E50D........    2208878
*  PC15    TRANSLATION SPEC EXC                          1
*
***********************************************************************
*
*  THIS MODULE IS CURRENTLY UTILIZED WITH BOTH SE-1 AND SE-2 SOFTWARE
*  WITH NO KNOWN OUTSTANDING PROBLEMS.  IT WOULD BE APPRECIATED IF ANY
*  ENHANCEMENTS, MODIFICATIONS, ETC. WOULD BE COMMUNICATED TO THE
*  UNDERSIGNED.
*
*            GREGORY GARDINER
*            UNION CARBIDE CORPORATION
*            OLD SAW MILL RIVER ROAD,
*            TARRYTOWN, NEW YORK  10591
*            914-789-3857
*                                                    MARCH 5, 1980
********************************************************************
*
         GBLC  &TRACESW                 TESTING SWITCH
         GBLC  &PROTSW                  TESTING SWITCH
&TRACESW SETC  'OFF'
&PROTSW  SETC  'ON'
*
* TRACE
*
         MACRO
         TRACE &VALUE
         GBLC  &TRACESW
         AIF   ('&TRACESW' NE 'ON').NTRACE
         LA    R14,&VALUE               SET TRACE INDICATOR
         BAL   R15,TRACE000             KEEP TRACK OF CERTAIN PATHS
.NTRACE  ANOP
         MEND
*
*  PROT - REMOVE ONCE 168 TESTING ENDS
*  IT IS NECESSARY TO TURN OFF THE LOW STORAGE PROTECT IN ORDER TO
*  UPDATE THE PC NPSW WHEN RUNNING ON A CPU THAT HAS THE EXTENDED
*  FACILITY INSTALLED.  THIS CODE IS PRESENT SINCE SOME OF THE TESTING
*  IS DONE IN SUCH AN ENVIRONMENT.
*
         MACRO
         PROT  &VALUE
         GBLC  &PROTSW
         AIF   ('&PROTSW' NE 'ON').NPROT
         PROTPSA &VALUE        USED WHEN TESTING WITH EXTENDED FACILITY
.NPROT   ANOP
         MEND
*
* NULL
*
         MACRO
&N       NULL
         AIF   (T'&N EQ 'O').NON
&N       DS    0Y
         MEXIT
.NON     ANOP
         DS   0Y
         MEND
*
* REGISTERS
R0       EQU   0                        WORK REGISTER - IF INTERNAL
*                                       TRACE IS BEING USED
R1       EQU   1                        LINKAGE REGISTER
R2       EQU   2                        WORK REGISTER
R3       EQU   3                        WORK REGISTER
R4       EQU   4                        WORK REGISTER
R5       EQU   5                        WORK REGISTER
R6       EQU   6                        NOT USED
R7       EQU   7                        NOT USED
R8       EQU   8                        ADDRESS OF FAILING INSTRUCTION
BASEREG  EQU   9                        BASE REGISTER
R10      EQU   10                       USED FOR ASCB POINTER
R11      EQU   11                       NOT USED
R12      EQU   12                       NOT USED
R13      EQU   13                       NOT USED
R14      EQU   14                       WORK REGISTER
R15      EQU   15                       LINKAGE AND WORK REGISTER
*
IEAVEPCS CSECT
         DC    CL8'SEPCFLIH'
         DC    CL8'VER 1.11'
         DC    CL8'&SYSDATE'
SEPCFLIH CSECT
         USING PSA,0
         PROT  DISABLE         *******  REMOVE ONCE 168 TESTING ENDS
*                              *******  THIS HAS THE EXTENDED FACILITY
         OI    FLCPNPSW+1,X'02'         TURN ON WAIT BIT IN PC NPSW
*                                       WILL BE TURNED OFF AT EXIT
*                                       FROM THIS MODULE
*  THIS IS DONE SO THAT A PROGRAM CHECK OF ANY TYPE WITHIN THIS MODULE
*  WILL RESULT IN A WAIT STATE RATHER THAN A RECURSION SITUATION.
*  THIS WILL AID IN DEBUGGING PROBLEMS RELATING TO THIS MODULE.
         PROT  ENABLE          *******  REMOVE ONCE 168 TESTING ENDS
         ST    BASEREG,SEPIR2           SAVE REG9 IN PSA
* ESTABLISH ADDRESSABILITY
         BALR  BASEREG,0
         USING *,BASEREG
         STM   R0,R15,SEPGR2            SAVE USERS REGS IN SE SAVE AREA
         TRACE 255
         L     R14,SEPIR2               RELOAD SAVED REG 9
         ST    R14,SEPGR2+9*4           AND SAVE IN SE SAVE AREA
         MVC   SEPPSW,FLCPOPSW          MOVE PSW TO SAVE AREA
         MVC   SEPSW,FLCPOPSW           SETUP PSW PROTOTYPE
         SLR   R2,R2                    CLEAR FOR INSERT
         IC    R2,FLCPIILC              GET ILC IN BYTES
         L     R14,SEPPSW+4             GET INSTRUCTION ADDRESS FROM
*                                       PC OLD PSW
         LA    R14,0(R14)               CLEAR HIGH ORDER BYTE
         SR    R14,R2                   GET ADDR OF FAILING INSTRUCTION
         LR    R8,R14                   KEEP INSTRUCTION ADDRESS
         CLI   FLCPIILC+2,X'01'         CHECK FOR OPERATION EXCEPTION
         BE    OPEXEC                   YES
         CLI   FLCPIILC+2,X'81'         CHECK FOR OPERATION EXCEPTION
         BE    OPEXEC                   YES
         CLI   FLCPIILC+2,X'12'         CHECK FOR TRANSLATION SPEC EXC
         BE    PC15000                  GIVE CONTROL TO RECOVERY RTN
         CLI   FLCPIILC+2,X'92'         CHECK FOR TRANSLATION SPEC EXC
         BE    PC15000                  GIVE CONTROL TO RECOVERY RTN
         B     XIEAVEPC                 GIVE CONTROL TO PC FLIH
*
OPEXEC   NULL                           OPERATION EXCEPTION
*  CHECK TO SEE IF THE OPERATION EXCEPTION IS FOR AN EXTENDED FACILITY
*  INSTRUCTION.  IF NOT, PASS CONTROL TO THE PROGRAM CHECK FLIH.
         STOSM PSASTNSM,X'04'           ENABLE FOR DAT
         CLI   0(R14),X'E5'             CHECK FOR X'E5' SERIES
         BNE   OPEXEC10                 CHECK FOR IPTE
*  NOTE THAT THE X'E5' INSTRUCTIONS ARE SEQUENCED ACCORDING TO THE
*  OBSERVED FREQUENCY OF UTILIZATION OF THE INSTRUCTIONS.
*  CHECK FOR SVC ASSIST LAST, SINCE IT IS NO-OPED AFTER THE FIRST
*  TIME THROUGH THE CODE.  OTHERWISE, IT WOULD BE SECOND IN THE LIST.
         CLI   1(R14),X'05'             CHECK FOR RELEASE LOCAL LOCK
         BE    PC06000
         CLI   1(R14),X'08'             CHECK FOR TRACE SVC INTERRUPT
         BE    PC09000
         CLI   1(R14),X'0D'             CHECK FOR TRACE SVC RETURN
         BE    PC14000
         CLI   1(R14),X'02'             CHECK FOR FIX PAGE
         BE    PC03000
         CLI   1(R14),X'04'             CHECK FOR OBTAIN LOCAL LOCK
         BE    PC05000
         CLI   1(R14),X'0C'             CHECK FOR TRACE TASK DISPATCH
         BE    PC13000
         CLI   1(R14),X'0A'             CHECK FOR TRACE SRB DISPATCH
         BE    PC11000
         CLI   1(R14),X'0B'             CHECK FOR TRACE I/O INTERRUPT
         BE    PC12000
         CLI   1(R14),X'06'             CHECK FOR OBTAIN CMS LOCK
         BE    PC07000
         CLI   1(R14),X'07'             CHECK FOR RELEASE CMS LOCK
         BE    PC08000
         CLI   1(R14),X'09'             CHECK FOR TRACE PROG INTERRUPT
         BE    PC10000
         CLI   1(R14),X'01'             CHECK FOR TEST PROTECTION
         BE    PC02000
         CLI   1(R14),X'03'             CHECK FOR SVC ASSIST
         BE    PC04000
         B     XIEAVEPC                 BRANCH TO PC FLIH
*
OPEXEC10 NULL                           IPTE
         CLC   0(2,R14),=X'B221'        CHECK FOR IPTE
         BNE   XIEAVEPC                 BRANCH TO PC FLIH
*                                       NOTE, FALL THROUGH TO PC01000
*
PC01000  NULL                           IPTE
*  THE REGISTER DESIGNATED BY THE FIRST OPERAND FIELD CONTAINS A
*  SEGMENT-TABLE ENTRY, OF WHICH ONLY THE PAGE-TABLE ORIGIN IS USED.
*  THE REGISTER DESIGNATED BY THE SECOND OPERAND FIELD CONTAINS A
*  VIRTUAL ADDRESS, OF WHICH ONLY THE PAGE INDEX IS USED.  A PROGRAM
*  INTERRUPTION FOR TRANSLATION EXCEPTION OCCURS IF THE FORMAT OF
*  BITS 8-12 OF CONTROL REGISTER 0 IS INVALID.  OTHERWISE, THE REAL
*  ADDRESS OF A PAGE-TABLE ENTRY IS COMPUTED USING THE TWO OPERANDS.
*  THIS ENTRY IS ACCESSED, TO STORE A 1 IN THE PAGE-INVALID BIT.
*  THE TRANSLATION-LOOKASIDE-BUFFER IS THEN PURGED.
         TRACE 1
         LA    R14,3(R8)                GET ADDRESS OF FIRST OPERAND
*                                       OF FAILING INSTRUCTION
         BAL   R15,RT03000
*  R2   NOW CONTAINS CONTENTS OF FIRST OPERAND - SEGMENT TABLE ENTRY
*  R3   NOW CONTAINS CONTENTS OF SECOND OPERAND - VIRTUAL ADDRESS
         N     R2,MASK2                 KEEP ONLY 24 BIT REAL ADDRESS
*                                       OF THE PAGE TABLE ORIGIN
         L     R15,X'10'                GET CVT POINTER
         L     R15,CVTPTRV-CVTTCBP(R15) TRANSLATE REAL ADDR TO VIRTUAL
         LR    R1,R2                    INPUT PARAMETER - REAL ADDRESS
         BALR  R14,R15                  USES REGS 0,1,14,15
*                                       RETURNS VIRTUAL ADDRESS IN R1
         SRL   R3,11                    MOVE 2*PAGE NUMBER IN LOW BITS
         N     R3,MASK3                 GET RID OF EXTRA BITS IN PAGE
         LA    R2,0(R1,R3)              ADDRESS OF PGTE IN R2
         OI    PGTBITS-PGTRSA(R2),PGTPVM  SET INVALID BIT ON
         PTLB  ,                        PURGE THE TLB
         B     PCBYPASS
         AGO   .PCBYP10
*  MAY WISH TO LOOK AT THIS CODE FOR REFERENCING THE PGTE BY ITS REAL
*  ADDRESS INSTEAD.  THIS CODE HAS NOT YET BEEN VALIDATED.
         N     R2,MASK2                 KEEP ONLY 24 BIT REAL ADDRESS
*                                       OF THE PAGE TABLE ORIGIN
         SRL   R3,11                    MOVE 2*PAGE NUMBER IN LOW BITS
         N     R3,MASK3                 GET RID OF EXTRA BITS IN PAGE
         LA    R2,0(R2,R3)              ADDRESS OF PGTE IN R2
         STNSM PSASTNSM,X'FB'           DISABLE DAT
         OI    PGTBITS-PGTRSA(R2),PGTPVM  SET INVALID BIT ON
         STOSM PSASTNSM,X'04'           ENABLE DAT
         PTLB  ,                        PURGE THE TLB
         B     PCBYPASS
.PCBYP10 ANOP
*
PC02000  NULL                           TEST PROTECTION
*  THE TEST PROTECTION INSTRUCTION APPARENTLY ELIMINATES THE SETFRR
*  LOGIC.  IT MAY BE POSSIBLE TO SUBSTITUTE ANY CODE THAT WILL RETURN
*  A ZERO CONDITION CODE.  HOWEVER, THIS WILL KILL THE RECOVERABILITY
*  FROM A PROTECTION EXCEPTION.  LOOK AT USING ISK INSTRUCTION AND
*  COMPARING.
*  NOTE THAT WE DO A DYNAMIC NOP OF THE SE INSTRUCTION BEING SIMULATED.
*  THIS PATH SHOULD NOT BE UTILIZED MORE THAN ONCE FOR EACH INSTRUCTION
*  INVOLVED.  IEAVEVAL AND IEAVSY50 ARE IN THE NUCLEUS AND ARE THE ONLY
*  TWO MODULES KNOWN TO UTILIZE THIS INSTRUCTION.
         TRACE 2
         MVC   0(6,R8),NOPINSTR         NOP THE SE INSTRUCTION
         NI    SEPSW+2,B'11001111'      SET CONDITION CODE INDICATORS
*                                       IN PSW TO ZERO FOR RETURN
         B     PCBYPASS
*
PC03000  NULL                           FIX PAGE
*  REFERENCE IEAVFXLD - PAGE FIX/LOAD STATEMENT NUMBER 110.
*  R0  REAL ADDRESS OF A LOCATION IN THE PAGE FRAME CONTAINING THE PAGE
*      TO BE FIXED
*  R1  THE VIRTUAL ADDRESS OF A LOCATION IN A PAGE TO BE FIXED
*  R2  THE VIRTUAL ADDRESS OF A LOCATION IN THE LAST OF A GROUP OF
*      CONSECUTIVE PAGES TO BE FIXED
*
*  OPERAND 1  CONDITIONAL BRANCH ADDRESS
*  OPERAND 2  THE ADDRESS OF THE MAPL CONTROL BLOCK (X'00A4')
*
*  IF THE PAGE TO BE FIXED IS A NUCLEUS PAGE, AN LSQA/SQA PAGE, OR
*  A V=R PAGE, THEN THE FIX COUNT FOR THE PAGE FRAME CONTAINING THAT
*  PAGE IS NOT EXAMINED OR INCREMENTED.
         TRACE 3
         L     R10,PSAAOLD              ASCB OLD POINTER
         L     R2,SEPGR2+1*4            CONTENTS OF R1 AT ENTRY
         N     R2,MASK4                 TRUNCATE TO PAGE BOUNDARY
         USING MPL,R5
         L     R5,PSAMPL                GET MAPL CONTROL BLOCK POINTER
         SRL   R2,8                     SHIFT RIGHT 8 FOR ADDRESS COMP
         CH    R2,MPLLPRIV              IS IT IN THE NUCLEUS ?
         BL    PC03400                  YES - NO FIXING REQUIRED
         L     R3,SEPGR2+0*4            CONTENTS OF R0 AT ENTRY
         N     R3,MASK4                 TRUNCATE TO PAGE BOUNDARY
         SRL   R3,8                     CONVERT REAL ADDRESS TO RBN
         AL    R3,MPLPFTP               ADD INDEX TO PFTE APPARENT
*                                       ORIGIN TO OBTAIN PFTE ADDRESS
         TM    PFTFLAG1-PFT(R3),PFTLSQA+PFTVRALC IS IT SQA,LSQA,
*                                       OR V=R?
         BNZ   PC03400                  IF SO, NO FIX IS REQUIRED
*  IF THE FIX COUNT FOR THE PAGE FRAME CONTAINING THE PAGE TO BE FIXED
*  IS ZERO, IF THE PAGE FRAME IS NOT IN THE PREFERRED AREA, AND IF THE
*  PAGE IS EITHER A PRIVATE PAGE OF A SECOND-LEVEL PREFERRED USER OR
*  A COMMON PAGE, THEN EXECUTION IS COMPLETED BY LOADING THE NEXT
*  INSTRUCTION ADDRESS PREFIXED BY EIGHT ZEROS IN GENERAL REGISTER 14;
*  BY LOADING THE CONTENTS OF MFLPFAL IN GENERAL REGISTER 15; AND BY
*  PLACING THE CONTENTS OF BITS 8-31 OF THE CONTENTS OF THE MPLPFAL
*  IN THE INSTRUCTION ADDRESS PART OF THE PSW.
         CLC   PFTFXCT-PFT(L'PFTFXCT,R3),=H'0' IS FIX COUNT ZERO
         BNE   PC03300                  NO
         TM    PFTFLAG2-PFT(R3),PFTPREF IS PFTE IN THE PREFERRED AREA
         BO    PC03300                  YES
         CH    R2,MPLLCSA               IS IT IN THE COMMON AREA
         BNL   PC03100                  YES
         TM    ASCBRSMF-ASCB(R10),ASCB2LPU IS THIS A SECOND LEVEL
*                                       PREFERRED USER ?
         BZ    PC03300                  NO
*
PC03100  NULL
         L     R15,SEPPSW+4             GET ADDRESS FROM PC OLD PSW
         LA    R15,0(R15)               CLEAR HIGH ORDER BYTE
         ST    R15,SEPGR2+14*4          PLACE INTO R14 FOR RETURN
         L     R15,MPLPFAL              GET MPLPFAL (TO MOVE PAGE TO
*                                       A PREFERRED FRAME)
         ST    R15,SEPGR2+15*4          PLACE INTO R15 FOR RETURN
         STCM  R15,7,SEPSW+5            PLACE INTO INSTRUCTION ADDRESS
*                                       OF THE PSW FOR RETURN
         B     PCBYPASS
*
PC03300  NULL
*  OTHERWISE, THE FIX COUNT FOR THE PAGE FRAME CONTAINING THE PAGE
*  TO BE FIXED IS INCREMENTED BY ONE.  IF THE INCREMENTED FIX COUNT
*  IS ONE, THEN THE TOTAL SYSTEM COUNT OF FIXED FRAMES IS INCREMENTED
*  BY ONE, AND EITHER THE NUMBER OF PRIVATE PAGES FIXED IN THE CURRENT
*  ADDRESS SPACE OR THE NUMBER OF FRAMES ALLOCATED TO FIXED COMMON
*  PAGES IS INCREMENTED BY ONE, DEPENDING ON WHETHER THE PAGE BEING
*  FIXED IS A PRIVATE OR COMMON PAGE, RESPECTIVELY.
         LH    R14,PFTFXCT-PFT(R3)      LOAD FIXED COUNT
         LA    R14,1(R14)               INCREMENT BY ONE
         STH   R14,PFTFXCT-PFT(R3)      STORE INCREMENTED COUNT
         CH    R14,=H'1'                IS THE INCREMENTED COUNT ONE ?
         BNE   PC03400                  NO
         L     R4,MPLCNTRS              PVT+X'720'  PVTCNTRS
         LH    R14,PVTCNTFX-PVTCNTRS(R4) TOTAL SYSTEM COUNT OF FIXED
*                                       FRAMES
         LA    R14,1(R14)               INCREMENT BY ONE
         STH   R14,PVTCNTFX-PVTCNTRS(R4) STORE INCREMENTED COUNT
         CH    R2,MPLLCSA               IS IT IN THE COMMON AREA
         BNL   PC03350                  YES
         L     R15,ASCBRSM-ASCB(R10)    GET RSM HEADER POINTER
         LH    R14,RSMCNTFX-RSMHD(R15)  GET COUNT OF FRAMES FIXED
*                                       IN THIS ADDRESS SPACE
         LA    R14,1(R14)               INCREMENT COUNTER BY ONE
         STH   R14,RSMCNTFX-RSMHD(R15)  STORE COUNT
         B     PC03400
*
PC03350  NULL
         LH    R14,PVTCOMFX-PVTCNTRS(R4)
*                                       GET NUMBER OF COMMON FIX FRAMES
         LA    R14,1(R14)               INCREMENT BY ONE
         STH   R14,PVTCOMFX-PVTCNTRS(R4) STORE INCREMENTED COUNT
*
PC03400  NULL
*  IF THE VIRTUAL ADDRESS OF THE PAGE FIXED IS LESS THAN THE VIRTUAL
*  ADDRESS OF THE LAST PAGE IN THE CONSECUTIVE GROUP OF PAGES TO BE
*  FIXED, THEN GENERAL REGISTER 1 IS INCREMENTED BY 4,096, AND
*  EXECUTION IS COMPLETED BY PLACING THE FIRST-OPERAND ADDRESS IN THE
*  INSTRUCTION-ADDRESS PART OF THE PSW.
         L     R14,SEPGR2+1*4           GET CONTENTS OF R1 AT ENTRY
         N     R14,MASK4                TRUNCATE TO PAGE BOUNDARY
         L     R15,SEPGR2+2*4           GET CONTENTS OF R2 AT ANTRY
         N     R15,MASK4                TRUNCATE TO PAGE BOUNDARY
         CR    R14,R15                  IS PAGE FIXED LESS THAN LAST ?
         BNL   PC03500                  NO
         LA    R14,4000(R14)
         LA    R14,0096(R14)            INCREMENT BY 4096 (4000 + 96)
         ST    R14,SEPGR2+1*4           STORE INCREMENTED VALUE
         LA    R14,2(R8)                GET ADDRESS OF FIRST OPERAND
*                                       OF INSTRUCTION
         DROP  R5
         BAL   R15,RT02000              R5 NOW HAS CONVERTED ADDRESS
         STCM  R5,7,SEPSW+5             PLACE INTO INSTRUCTION ADDRESS
*                                       OF THE PSW FOR RETURN
         B     PCBYPASS
*
PC03500  NULL
*  OTHERWISE, THE TOTAL SYSTEM COUNT OF FIXED FRAMES IS COMPARED WITH
*  THE MAXIMUM FIX-COUNT THRESHOLD.  IF THE THRESHOLD HAS BEEN REACHED,
*  INSTRUCTION EXECUTION IS COMPLETED BY LOADING THE NEXT INSTRUCTION
*  ADDRESS PREFIXED BY EIGHT ZEROS IN GENERAL REGISTER 14; BY LOADING
*  THE CONTENTS OF MPLPFCM IN GENERAL REGISTER 15; AND BY PLACING BITS
*  8-31 OF THE CONTENTS OF MPLPFCM IN THE INSTRUCTION ADDRESS OF THE
*  PSW.
         USING MPL,R5
         L     R5,PSAMPL                GET MAPL CONTROL BLOCK POINTER
         CLC   MPLMAXFX,PVTCNTFX-PVTCNTRS(R4)
*                                       COMPARE THRESHOLD TO TOTAL CNT
         BH    PC03600                  NOT REACHED YET
         L     R14,SEPPSW+4             GET ADDRESS FROM PC OLD PSW
         LA    R14,0(R14)               CLEAR HIGH ORDER ZEROS
         ST    R14,SEPGR2+14*4          PLACE INTO REG 14 FOR RETURN
         L     R14,MPLPFCM              GET MPLPFCM
         ST    R14,SEPGR2+15*4          PLACE INTO REG 15 FOR RETURN
         STCM  R14,7,SEPSW+5            PLACE INTO INSTRUCTION ADDRESS
*                                       OF PSW FOR RETURN
         B     PCBYPASS
*
PC03600  NULL
*  OTHERWISE, GENERAL REGISTER 15 IS SET TO ZERO, AND NORMAL
*  INSTRUCTION SEQUENCING PROCEEDS WITH THE UPDATED INSTRUCTION
*  ADDRESS.
         XC    SEPGR2+15*4(4),SEPGR2+15*4 CLEAR REG 15 FOR RETURN
         B     PCBYPASS
         DROP  R5
*
PC04000  NULL                           SVC ASSIST
*  TREAT ALL SVCS AS COMPLEX AND THEREFORE NON-ASSISTABLE.
*  RETURN TO NORMAL INSTRUCTION SEQUENCE.
*  NOTE THAT WE DO A DYNAMIC NOP OF THE SE INSTRUCTION BEING SIMULATED.
*  THIS PATH SHOULD NOT BE UTILIZED MORE THAN ONCE FOR EACH INSTRUCTION
*  INVOLVED.  IEAVESVC IS IN THE NUCLEUS AND HAS ONE OCCURANCE.  IT IS
*  THE ONLY MODULE KNOWN TO UTILIZE THIS INSTRUCTION.
         TRACE 4
         MVC   0(6,R8),NOPINSTR         NOP THE SE INSTRUCTION
         B     PCBYPASS
*
PC05000  NULL                           OBTAIN LOCAL LOCK
*  IF THE LOCAL LOCK IN THE ASCB IS NOT HELD, IT IS REPLACED, USING
*  AN INTERLOCKED UPDATE WITH THE VALUE FROM PSALCPUA; THE LOCAL-LOCK
*  BIT OF THE HIGHEST LOCK-HELD-INDICATOR IS SET TO ONE; AND ZEROS
*  ARE PLACED IN GENERAL REGISTER 13.
         TRACE 5
         L     R10,PSAAOLD              GET ASCB ADDRESS
         L     R2,PSALCPUA              LOAD LOGICAL CPU ADDR
         SLR   R14,R14                  CLEAR REG FOR SWAP
         CS    R14,R2,ASCBLOCK-ASCB(R10)
*                                       ATTEMPT LOCK OBTAIN
         BNZ   PC05100
         OI    PSACLHS4,PSALCLLI        SET LOCK HELD FLAG
         ST    R14,SEPGR2+13*4          R13 IS TO SET TO ZEROS ON
*                                       RETURN
         B     PCBYPASS
*
PC05100  NULL
*  OTHERWISE, THE UPDATED INSTRUCTION ADDRESS, PREFIXED BY EIGHT ZEROS,
*  IS PLACED IN GENERAL REGISTER 12; THE CONTENTS OF LITOLOC ARE
*  PLACED IN GENERAL REGISTER 13; AND BITS 8-31 OF THE CONTENTS OF
*  LITOLOC ARE PLACED IN THE INSTRUCTION ADDRESS PORTION OF THE PSW.
         L     R14,SEPPSW+4             GET ADDRESS FROM PC OLD PSW
         LA    R14,0(R14)               CLEAR HIGH ORDER ZEROS
         ST    R14,SEPGR2+12*4          PLACE INTO REG 12 FOR RETURN
         L     R14,PSALITA              ADDRESS OF LOCK INTERFACE TABLE
         SH    R14,=H'16'               DISPLACEMENT OF LITOLOC
         L     R14,0(R14)               GET THE CONTENTS
         ST    R14,SEPGR2+13*4          PLACE INTO REG 13 FOR RETURN
         STCM  R14,7,SEPSW+5            PUT CONTENTS OF LITOLOC INTO
*                                       INSTRUCTION ADDRESS PORTION OF
*                                       PSW USED FOR RETURN
         B     PCBYPASS
*
PC06000  NULL                           RELEASE LOCAL LOCK
*  IF THE HIGHEST LOCK-HELD-INDICATOR WORD FETCHED SHOWS THAT THE
*  EXECUTING CPU HOLDS THE LOCAL LOCK AND DOES NOT HOLD A CMS LOCK,
*  AND IF THE WORD AFTER THE LOCAL LOCK WORD IN THE ASCB IS ZERO, THEN
*  THE DOUBLEWORD CONTAINING THE LOCK IS SET TO ZERO.  ALSO, THE
*  LOCAL-LOCK BIT OF THE HIGHEST LOCK-HELD-INDICATOR WORD IS SET
*  TO ZERO, AND ZEROS ARE PLACED IN GENERAL REGISTER 13.
         TRACE 6
         TM    PSACLHS4,PSALCLLI        IS LOCAL LOCK ON
         BZ    PC06100                  NO
         TM    PSACLHS4,PSACMSLI        IS CMS LOCK ON
         BNZ   PC06100                  YES
         L     R10,PSAAOLD              GET ASCB ADDRESS
         L     R2,ASCBLOCK-ASCB(R10)    GET LOCAL LOCK CONTENTS FOR CS
         SLR   R3,R3                    ZERO FOR CS
         SLR   R4,R4                    ZERO FOR CS
         SLR   R5,R5                    ZERO FOR CS
         CDS   R2,R4,ASCBLOCK-ASCB(R10) ATTEMPT LOCK RELEASE
         BNZ   PC06100                  NO GO
         NI    PSACLHS4,255-PSALCLLI    SET LOCK HELD FLAG OFF
         ST    R4,SEPGR2+13*4           R13 IS TO SET TO ZEROS ON
*                                       RETURN
         B     PCBYPASS
*
PC06100  NULL
*  OTHERWISE, THE UPDATED INSTRUCTION ADDRESS, PREFIXED BY EIGHT ZEROS,
*  IS PLACED IN GENERAL REGISTER 12; THE CONTENTS OF LITRLOC ARE
*  PLACED IN GENERAL REGISTER 13; AND BITS 8-31 OF THE CONTENTS OF
*  LITRLOC ARE PLACED IN THE INSTRUCTION ADDRESS PORTION OF THE PSW.
         L     R14,SEPPSW+4             GET ADDRESS FROM PC OLD PSW
         LA    R14,0(R14)               CLEAR HIGH ORDER ZEROS
         ST    R14,SEPGR2+12*4          PLACE INTO REG 12 FOR RETURN
         L     R14,PSALITA              ADDRESS OF LOCK INTERFACE TABLE
         SH    R14,=H'12'               DISPLACEMENT OF LITRLOC
         L     R14,0(R14)               GET THE CONTENTS
         ST    R14,SEPGR2+13*4          PLACE INTO REG 13 FOR RETURN
         STCM  R14,7,SEPSW+5            PUT CONTENTS OF LITRLOC INTO
*                                       INSTRUCTION ADDRESS PORTION OF
*                                       PSW USED FOR RETURN
         B     PCBYPASS
*
PC07000  NULL                           OBTAIN CMS LOCK
*  IF THE HIGHEST LOCK-HELD-INDICATOR WORD FETCHED SHOWS THAT THE
*  EXECUTING CPU HOLDS THE LOCAL LOCK AND DOES NOT HOLD A CMS LOCK,
*  AND IF THE CMS LOCK ADDRESSED BY BITS 8-31 OF GENERAL REGISTER 11
*  IS NOT HELD, THE LOCK IS REPLACED, USING AN INTERLOCKED UPDATE,
*  WITH THE FIRST OPERAND WORD.  ALSO, THE HIGHEST LOCK-HELD-
*  INDICATOR IS SET TO SHOW THAT A CMS LOCK IS HELD, AND ZEROS ARE
*  PLACED IN GENERAL REGISTER 13.
         TRACE 7
         TM    PSACLHS4,PSALCLLI        IS LOCAL LOCK ON
         BZ    PC07100                  NO
         TM    PSACLHS4,PSACMSLI        IS CMS LOCK ON
         BNZ   PC07100                  YES
         L     R10,PSAAOLD              GET ASCB ADDRESS
         L     R14,SEPGR2+11*4          GET R11 CONTENTS AT ENTRY
         SLR   R11,R11                  CLEAR REG FOR SWAP
         CS    R11,R10,0(R14)           ATTEMPT LOCK OBTAIN
         BNZ   PC07100
         OI    PSACLHS4,PSACMSLI        SET LOCK HELD FLAG
         ST    R11,SEPGR2+13*4          R13 IS TO SET TO ZEROS ON
*                                       RETURN
         B     PCBYPASS
*
PC07100  NULL
*  OTHERWISE, THE UPDATED INSTRUCTION ADDRESS, PREFIXED BY EIGHT ZEROS,
*  IS PLACED IN GENERAL REGISTER 12; THE CONTENTS OF LITOCMS ARE
*  PLACED IN GENERAL REGISTER 13; AND BITS 8-31 OF THE CONTENTS OF
*  LITOCMS ARE PLACED IN THE INSTRUCTION ADDRESS PORTION OF THE PSW.
         L     R14,SEPPSW+4             GET ADDRESS FROM PC OLD PSW
         LA    R14,0(R14)               CLEAR HIGH ORDER ZEROS
         ST    R14,SEPGR2+12*4          PLACE INTO REG 12 FOR RETURN
         L     R14,PSALITA              ADDRESS OF LOCK INTERFACE TABLE
         SH    R14,=H'8'                DISPLACEMENT OF LITOCMS
         L     R14,0(R14)               GET THE CONTENTS
         ST    R14,SEPGR2+13*4          PLACE INTO REG 13 FOR RETURN
         STCM  R14,7,SEPSW+5            PUT CONTENTS OF LITOCMS INTO
*                                       INSTRUCTION ADDRESS PORTION OF
*                                       PSW USED FOR RETURN
         B     PCBYPASS
*
PC08000  NULL                           RELEASE CMS LOCK
*  IF THE CONTENTS OF THE CMS LOCKWORD ADDRESSED BY BITS 8-31 OF
*  GENERAL REGISTER 11 EQUAL THE CONTENTS OF THE FIRST-OPERAND WORD
*  AND IF THE WORD AFTER THE CMS LOCKWORD IS ZERO, THEN THE DOUBLEWORD
*  CONTAINING THE LOCKWORD IS SET TO ZERO USING INTERLOCK UPDATE.
*  ALSO, THE HIGHEST LOCK-HELD-INDICATOR WORD FETCHED FROM THE SECOND-
*  OPERAND LOCATION IS SET TO SHOW THAT NO CMS LOCK IS HELD, AND ZEROS
*  ARE PLACED IN GENERAL REGISTER 13.
         TRACE 8
         L     R2,PSAAOLD               GET ASCB ADDRESS
         SLR   R3,R3                    ZERO FOR CS
         SLR   R4,R4                    ZERO FOR CS
         SLR   R5,R5                    ZERO FOR CS
         L     R14,SEPGR2+11*4          GET R11 CONTENTS AT ENTRY
         CDS   R2,R4,0(R14)             ATTEMPT LOCK RELEASE
         BNZ   PC08100
         NI    PSACLHS4,255-PSACMSLI    SET LOCK HELD FLAG OFF
         ST    R4,SEPGR2+13*4           R13 IS TO SET TO ZEROS ON
*                                       RETURN
         B     PCBYPASS
*
PC08100  NULL
*  OTHERWISE, THE UPDATED INSTRUCTION ADDRESS, PREFIXED BY EIGHT ZEROS,
*  IS PLACED IN GENERAL REGISTER 12; THE CONTENTS OF LITRCMS ARE
*  PLACED IN GENERAL REGISTER 13; AND BITS 8-31 OF THE CONTENTS OF
*  LITRCMS ARE PLACED IN THE INSTRUCTION ADDRESS PORTION OF THE PSW.
         L     R14,SEPPSW+4             GET ADDRESS FROM PC OLD PSW
         LA    R14,0(R14)               CLEAR HIGH ORDER ZEROS
         ST    R14,SEPGR2+12*4          PLACE INTO REG 12 FOR RETURN
         L     R14,PSALITA              ADDRESS OF LOCK INTERFACE TABLE
         SH    R14,=H'4'                DISPLACEMENT OF LITRCMS
         L     R14,0(R14)               GET THE CONTENTS
         ST    R14,SEPGR2+13*4          PLACE INTO REG 13 FOR RETURN
         STCM  R14,7,SEPSW+5            PUT CONTENTS OF LITRCMS INTO
*                                       INSTRUCTION ADDRESS PORTION OF
*                                       PSW USED FOR RETURN
         B     PCBYPASS
*
PC09000  NULL                           TRACE SVC INTERRUPTION
         TRACE 9
         BAL   R1,RT01000               PERFORM BASIC TRACE TABLE
*                                       FORMATTING
         MVI   2(R3),X'20'              STORE RECORD TYPE ID
         MVC   3(1,R3),FLCSVCN+1        SVC NUMBER
         IC    R14,FLCSVILC             SVC LENGTH COUNTER
         N     R14,=F'6'                KEEP BITS 5-6 ONLY
         SLL   R14,5                    MOVE INTO POSITIONS 0-1 OF
*                                       RIGHTMOST BYTE
         NI    20(R3),B'00111111'       CLEAR OUT BITS 0-1
         EX    R14,ORB20                OR IN BITS INTO POSITIONS 0-1
*                                       OF BYTE 20
         B     PCBYPASS
*
PC10000  NULL                           TRACE PROGRAM INTERRUPT
         TRACE 10
         BAL   R1,RT01000               PERFORM BASIC TRACE TABLE
*                                       FORMATTING
         MVI   2(R3),X'30'              STORE RECORD TYPE ID
         LA    R14,4(R8)                ADDR OF 2ND OPRND INSTR
         BAL   R15,RT02000              R5 NOW HAS CNVRTD ADDR.
         USING LCCAPPSW,R5
         MVC   3(1,R3),LCCAPINT+3       INTERRUPT CODE
         MVC   12(4,R3),LCCAPVAD        TRANSLATION EXCPTN ADDR.
         IC    R14,LCCAPINT+1           PI LENGTH COUNTER
         DROP  R5
         N     R14,=F'6'                KEEP BITS 5-6 ONLY
         SLL   R14,5                    MOVE INTO POSITIONS 0-1 OF
*                                       RIGHTMOST BYTE
         NI    20(R3),B'00111111'       CLEAR OUT BITS 0-1
         EX    R14,ORB20                OR IN BITS INTO POSITIONS 0-1
*                                       OF BYTE 20
         B     PCBYPASS
*
PC11000  NULL                           TRACE INITIAL SRB DISPATCH
         TRACE 11
         BAL   R1,RT01000               PERFORM BASIC TRACE TABLE
*                                       FORMATTING
         MVI   2(R3),X'40'              STORE RECORD TYPE ID
         MVI   3(R3),X'00'              CLEAR
         MVC   8(2,R3),=X'0000'         CLEAR
         L     R15,SEPGR2+0*4           GET R0 AT ENTRY - SRB ADDRESS
         MVC   10(2,R3),SRBPASID-SRB(R15) GET PURGEDQ ASID IDENTIFIER
         MVI   20(R3),X'00'             CLEAR
         MVC   24(4,R3),SRBPTCB-SRB(R15) PURGEDQ TCB IDENTIFIER
         B     PCBYPASS
*
PC12000  NULL                           TRACE I/O INTERRUPTION
         TRACE 12
         BAL   R1,RT01000               PERFORM BASIC TRACE TABLE
*                                       FORMATTING
         MVI   2(R3),X'50'              STORE RECORD TYPE ID
*                                       NOTE THAT ZERO WILL BE
*                                       OVERLAYED
         MVI   3(R3),X'00'              SET UP FOR OR INSTRUCTION
         OC    2(2,R3),FLCIOAA+1        OR IN I/O ADDRESS
         NI    2(R3),X'5F'              MAKE SURE ID IS STILL '5'
         MVC   8(8,R3),FLCCSW           CHANNEL STATUS WORD
         MVI   16(R3),X'00'             ZEROS
         B     PCBYPASS
*
PC13000  NULL                           TRACE TASK DISPATCH
         TRACE 13
         BAL   R1,RT01000               PERFORM BASIC TRACE TABLE
*                                       FORMATTING
         MVI   2(R3),X'70'              STORE RECORD TYPE ID
         L     R14,SEPGR2+3*4           GET CONTENTS OF R3 AT ENTRY
*                                       POINTS TO AN RB PLUS X'10'
*                                       (RBOPSW). R3 IS HANDLED LIKE
*                                       SECOND OPERAND FOR TRACE SVC
*                                       RETURN.
         SH    R14,=H'19'               SHOULD POINT TO RBINLNTH
         MVC   3(1,R3),2(R14)           RBINTCOD+1 - INTERRUPT CODE
         IC    R14,0(R14)               INSERT RBINLNTH
         N     R14,=F'6'                KEEP BITS 5-6 ONLY
         SLL   R14,5                    MOVE INTO POSITIONS 0-1 OF
*                                       RIGHTMOST BYTE
         NI    20(R3),B'00111111'       CLEAR OUT BITS 0-1
         EX    R14,ORB20                OR IN BITS INTO POSITIONS 0-1
*                                       OF BYTE 20
         B     PCBYPASS
*
PC14000  NULL                           TRACE SVC RETURN
         TRACE 14
         BAL   R1,RT01000               PERFORM BASIC TRACE TABLE
*                                       FORMATTING
         MVI   2(R3),X'80'              STORE RECORD TYPE ID
         B     PCBYPASS
*
PC15000  NULL                           TRANSLATION SPEC EXCEPTION
*  SE DEFINES BIT 30 OF THE SEGMENT-TABLE ENTRY AS THE COMMON SEGMENT
*  BIT.  WHEN THIS BIT IS ON, IT INDICATES THAT THE ASSOCIATED SEGMENT
*  IS COMMON TO ALL SEGMENT TABLES.  THE ENTRY IN THE TLB FORMED FROM
*  A SEGMENT-TABLE ENTRY WITH THE COMMON BIT ON MAY BE USED FOR THE
*  SEGMENT INDEX AND SEGMENT SIZE FOR WHICH IT WAS FETCHED, REGARDLESS
*  OF THE VALUE OF THE SEGMENT-TABLE ORIGIN IN CONTROL REGISTER 1.
*  WHEN BIT 30 OF THE SEGMENT-TABLE ENTRY IS ZERO, THE RULES FOR THE
*  USE OF THE TLB ENTRY ARE THOSE THAT APPLY WHEN THE EXTENDED
*  FACILITY IS NOT INSTALLED.
*  WHEN THE EXTENDED FACILITY IS NOT INSTALLED, A TRANSLATION
*  SPECIFICATION EXCEPTION WILL OCCUR.  THIS ROUTINE WILL PROCESS THE
*  SEGMENT TABLE POINTED TO BY CONTROL REGISTER ONE AND TURN OFF ALL
*  OCCURANCES OF THIS BIT.  CONTROL WILL BE GIVEN BACK TO THE FAILING
*  INSTRUCTION.
*  THE FIRST FAILURE OCCURS IN IEAVNIPX FOLLOWING THE RETURN FROM THE
*  COMSEGS ROUTINE, WHICH FIRST TURNS BIT 30 ON.  IF THE DAT IS ENABLED
*  FOR THIS ROUTINE, ANOTHER TRANSLATION SPECIFICATION EXCEPTION WILL
*  OCCUR IN THIS ROUTINE.
*  AS FAR AS CAN BE DETERMINED, THE ROUTINE PC15000 IS EXECUTED ONLY
*  ONCE, FOLLOWING THE FAILURE IN IEAVNIPX.  APPARENTLY, ALL OTHER
*  SEGMENT TABLES ARE CREATED USING THE CORRECTED SEGMENT TABLE AS
*  A BASE STRUCTURE.
*  NOTE THAT THE DAT IS NOT ENABLED FOR THIS ROUTINE.
         TRACE 15
         STCTL 1,1,FLCCRSAV+4           SAVE CR1 CONTENTS SO THEY MAY
*                                       BE ACCESSED BY GENERAL REGS
         L     R1,FLCCRSAV+4            GET REAL ADDRESS OF THE SEGMENT
*                                       TABLE ENTRY
         N     R1,MASK5                 GET RID OF EXTRA BITS
         SLR   R2,R2                    CLEAR FOR INSERT
         IC    R2,FLCCRSAV+4            GET NUMBER OF 64-BYTE GROUPS OF
*                                       SGTE, MINUS ONE
         LA    R2,1(R2)                 ADD ONE
         SLL   R2,4                     MULTIPLY BY 16 (64/L'SGTE)
*                                       THIS GIVES COUNT OF SEGMENT
*                                       TABLE ENTRIES
         B     PC15100
*
PC15050  NULL
         LA    R1,4(R1)                 GET ADDRESS OF NEXT ENTRY
*                                       4 IS L'SGTE (SGTEND-SGTSTE)
*
PC15100  NULL
         NI    SGTBYTE-SGTSTE(R1),255-SGTCB TURN OFF COMMON AREA FLAG
*                                       (BIT 30)
         BCT   R2,PC15050
         STCM  R8,7,SEPSW+5             PUT ADDRESS OF FAILING
*                                       INSTRUCTION IN THE PSW
         B     PCBYPASS
*
PCBYPASS NULL                           GIVE CONTROL BACK TO PROGRAM
         TRACE 254
         LM    R0,R15,SEPGR2            RESTORE REGS FROM SAVE AREA
         PROT  DISABLE         *******  REMOVE ONCE 168 TESTING ENDS
         NI    FLCPNPSW+1,X'FD'         TURN OFF WAIT BIT IN PC NPSW
*                                       WAS TURNED ON AT ENTRY TO
*                                       THIS MODULE
         PROT  ENABLE          *******  REMOVE ONCE 168 TESTING ENDS
         LPSW  SEPSW
*
XIEAVEPC NULL                           PASS CONTROL TO IEAVEPC
         TRACE 253
         MVC   SEPSW,PCNPSW             STOW PSW IN PSA TO PASS
*                                       CONTOL TO PC FLIH
         LM    R0,R15,SEPGR2            RESTORE REGS FROM SAVE AREA
         PROT  DISABLE         *******  REMOVE ONCE 168 TESTING ENDS
         NI    FLCPNPSW+1,X'FD'         TURN OFF WAIT BIT IN PC NPSW
*                                       WAS TURNED ON AT ENTRY TO
*                                       THIS MODULE
         PROT  ENABLE          *******  REMOVE ONCE 168 TESTING ENDS
         LPSW  SEPSW
*
RT01000  NULL                           GENERAL TRACE ROUTINE CODE
*  R1 HAS RETURN ADDRESS
*  R3 WILL BE ADDRESS OF TRACE ENTRY
         L     R14,FLCTRACE             ADDRESS OF TRACE TABLE HEADER
*
RT01030  NULL
         L     R3,0(R14)                CURRENT TRACE TABLE ENTRY
         LR    R2,R3                    SAVE ADDRESS OF CURRENT POINTER
         LA    R3,32(R3)                CALCULATE ADDRESS OF NEXT ENTRY
         CL    R3,8(R14)                ARE WE AT THE END OF THE TABLE?
         BNL   RT01100                  YES, GO WRAP AROUND
*
RT01050  NULL
         CS    R2,R3,0(R14)             NO, UPDATE THE POINTER
         BNZ   RT01030                  ANOTHER CPU UPDATED, RETRY
         B     RT01150                  START TRACE TABLE UPDATE
*
RT01100  NULL
         L     R3,4(R14)                POINT TO BEGINNING OF TABLE
         B     RT01050                  BACK TO STORE IT
*
RT01150  NULL
         STCK  8(R3)                    STORE CLOCK VALUE - WILL
*                                       OVERLAY AS SOON AS BYTES 3-6
*                                       ARE FETCHED
         BZ    RT01175                  DID THE CLOCK WORK ?
         XC    8(8,R3),8(R3)            NO, CLEAR THE VALUE
*
RT01175  NULL
         MVC   28(4,R3),11(R3)          GET BYTES 3-6 OF CLOCK VALUE
         LA    R14,4(R8)                GET ADDRESS OF SECOND
*                                       INSTRUCTION OPERAND INTO R14
         BAL   R15,RT02000              R5 NOW HAS CONVERTED ADDRESS
         MVC   0(2,R3),0(R5)            BYTES 0-1 POINTED TO BY SECOND
*                                       OPERAND
         MVC   4(4,R3),4(R5)            BYTES 4-7 POINTED TO BY SECOND
*                                       OPERAND
         MVC   20(1,R3),2(R5)           BYTE 2 POINTED TO BY SECOND
*                                       OPERAND - PARTS WILL BE
*                                       OVERLAYED
*  TYPE 8 (TRACE SVC RETURN) WANTS SECOND OPERAND BYTE MINUS 19
*  BITS 5-6 STORED INTO BYTE 20, BITS 0-1.  THIS IS RBINLNTH.
*  ALSO SECOND OPERAND BYTE MINUS 17 INTO BYTE 3 OF TRACE TABLE
*  ENTRY.  THIS IS RBINTCOD, BYTE 1.
*  DO IT NOW, SINCE THE ADDRESS IS AVAILABLE.
         CLI   1(R8),X'0D'              CHECK INSTRUCTION FOR TRACE
*                                       SVC RETURN
         BNE   RT01200
         SH    R5,=H'19'
         MVC   3(1,R3),2(R5)            SECOND OPERAND MINUS 17
         IC    R14,0(R5)                GET BYTE MINUS 19
         N     R14,=F'6'                KEEP BITS 5-6 ONLY
         SLL   R14,5                    MOVE BITS 0-1 INTO POSITIONS
*                                       0-1 OF RIGHTMOST BYTE
         NI    20(R3),B'00111111'       CLEAR BITS 0-1
         EX    R14,ORB20                OR IN BITS 0-1 INTO BYTE 20
*
RT01200  NULL
         L     R14,SEPGR2+15*4          GET R15 AT ENTRY
         ST    R14,8(R3)                SAVE IN TRACE TABLE ENTRY
*                                       WILL BE OVERLAYED FOR TYPES 4,5
         L     R14,SEPGR2+0*4           GET R0 AT ENTRY
         ST    R14,12(R3)               SAVE IN TRACE TABLE ENTRY
*                                       WILL BE OVERLAYED FOR TYPES 3,5
         L     R14,SEPGR2+1*4           GET R1 AT ENTRY
         ST    R14,16(R3)               SAVE IN TRACE TABLE ENTRY
*                                       WILL BE OVERLAYED FOR TYPE 5
         MVC   21(1,R3),PSACPUSA+1      STORE PHYSICAL CPU ADDRESS
*                                       (SECOND BYTE ONLY)
         LA    R14,2(R8)                GET ADDRESS OF FIRST INSTR
*                                       OPERAND INTO R14
         BAL   R15,RT02000              R5 WILL NOW HAVE CONVERTED ADDR
         MVC   22(2,R3),0(R5)           GET FIRST 2 BYTES
         L     R14,PSATOLD              TCB OLD POINTER
         ST    R14,24(R3)               STORE PSATOLD VALUE
*                                       WILL BE OVERLAYED FOR TYPE 4
         BR    R1                       RETURN BACK
*
RT02000  NULL                           CONVERT BASE DISPLACEMENT INTO
*                                       ADDRESS
*  IT MAY BE POSSIBLE TO OPTIMIZE THIS CODE BY OVERLAYING THE OPERANDS
*  OF AN INSTRUCTION BUILT IN THE PSA AND THEN USING THE EXECUTE
*  INSTRUCTION.
*
*  R5   WILL CONTAIN CONVERTED ADDRESS
*  R14  POINTS TO BASE DISPLACEMENT ENTRY
*  R15  HAS RETURN ADDRESS
         SLR   R2,R2                    CLEAR
         SLR   R5,R5                    CLEAR
         IC    R2,0(R14)                GET BASE REGISTER PLUS 4 BITS
         SRL   R2,4                     SHIFT OUT EXTRA 4 BITS
         LTR   R2,R2                    CHECK FOR ZERO BASE REG
         BZ    RT02050                  IF SO, IGNORE
         SLL   R2,2                     MULTIPLY BY 4 TO GET DISPL
*                                       INTO SEPGR2
         L     R5,SEPGR2(R2)            GET REGISTER CONTENTS AT ENTRY
         LA    R5,0(R5)                 CLEAR HIGH ORDER BYTE
*
RT02050  NULL
         LH    R2,0(R14)                GET BASE REG PLUS DISPLACEMENT
         SLL   R2,20
         SRL   R2,20                    KEEP DISPLACEMENT ONLY
         AR    R5,R2                    ADD THE TWO TOGETHER
         BR    R15
*
RT03000  NULL                           TAKE RR INSTRUCTION AND PLACE
*                                       CONTENTS OF FIRST OPERAND IN R2
*                                       AND CONTENTS OF SECOND OPERAND
*                                       IN R3
*  IT MAY BE POSSIBLE TO OPTIMIZE THIS CODE BY OVERLAYING THE OPERANDS
*  OF AN INSTRUCTION BUILT IN THE PSA AND THEN USING THE EXECUTE
*  INSTRUCTION.
*
*  R14  POINTS TO FIRST OPERAND
*  R15  HAS RETURN ADDRESS
         SLR   R2,R2                    CLEAR
         IC    R2,0(R14)                GET BOTH OPERANDS
         SRL   R2,4                     SHIFT OUT SECOND OPERAND
         SLL   R2,2                     MULTIPLY BY 2 TO GET DISPL
*                                       INTO SEPGR2
         L     R2,SEPGR2(R2)            GET REGISTER CONTENTS OF
*                                       OPERAND AT ENTRY
         SLR   R3,R3                    CLEAR
         IC    R3,0(R14)                GET BOTH OPERANDS
         N     R3,=F'15'                KEEP SECOND OPERAND ONLY
         SLL   R3,2                     MULTIPLY BY 2 TO GET DISPL
*                                       INTO SEPGR2
         L     R3,SEPGR2(R3)            GET REGISTER CONTENTS OF
*                                       OPERAND AT ENTRY
         BR    R15                      RETURN BACK
*
PCNPSW   DC    0D'0',X'000C0000',V(IEAQPK99) STANDARD PROGRAM CHECK
*                                            NEW PSW
NOPINSTR DC    3XL2'0700'               REGISTER NOP INSTRUCTIONS
MASK2    DC    0F'0',XL4'00FFFFF8'
MASK3    DC    0F'0',XL4'0000001E'
MASK4    DC    0F'0',XL4'00FFF000'
MASK5    DC    0F'0',XL4'00FFFFC0'
ORB20    OI    20(R3),0                 USED FOR EXECUTE
         LTORG
         AIF   ('&TRACESW' NE 'ON').TRACE99
*
TRACE000 NULL                           TRACE CERTAIN CODE PATHS
*  NOTE THAT THE DAT MAY OR MAY NOT BE ENABLED, DEPENDING UPON THE
*  CALLING ROUTINE.
*
*  THIS CODE DOES NOT FOLLOW MP PROTOCOL, AND IS INTENDED FOR USE
*  DURING TESTING ONLY.
         STC   R14,TRACEVAL             FREE UP REG FOR NOW
         L     R14,TRACEPTR             GET POINTER FOR LAST ENTRY
         LA    R14,1(R14)               INCREMENT BY ONE
         C     R14,TRACEEND             ARE WE PAST END ?
         BNH   TRACE050                 NO
         L     R14,TRACEBEG             WRAP AROUND
*
TRACE050 NULL
         ST    R14,TRACEPTR             STORE UPDATED POINTER VALUE
         MVC   0(1,R14),TRACEVAL        INSERT VALUE
         SLR   R14,R14                  CLEAR FOR INSERT
         IC    R14,TRACEVAL             GET TRACE ENTRY
         SLL   R14,2                    MULTIPLY BY 4 FOR FULLWORD
         LA    R14,PATHTBL(R14)         INCREMENT INTO TABLE
         L     R0,0(R14)                GET CURRENT USE COUNT
         AH    R0,=H'1'                 INCREMENT BY ONE
         ST    R0,0(R14)                STORE IT BACK
         BR    R15                      BRANCH BACK
         LTORG
TRACEVAL DC    X'00'                    SAVE VALUE UNTIL INSERT
TRACEPTR DC    A(TRACETBL-1)            POINTER FOR CURRENT ENTRY
TRACEBEG DC    A(TRACETBL)              BEGINNING OF TABLE
TRACEEND DC    A(TRACETBL+L'TRACETBL-1) POINTER TO END OF TABLE
TRACETBL DC    XL255'00'                SE INTERNAL TRACE TABLE
PATHTBL  DC    256F'0'                  SE INTERNAL PATH USAGE TABLE
.TRACE99 ANOP
*
* PARTIAL PFTE LAYOUT - DO NOT HAVE IHAPFTE MACRO
PFT      EQU   0
PFTFXCT  EQU   8,2,C'H'                 FIX COUNT OF THIS FRAME
PFTFLAG1 EQU   12,1,C'X'                FIRST FLAG FIELD
PFTLSQA  EQU   X'20'                    LSQA OR SQA PAGE
PFTVRALC EQU   X'02'                    V=R PAGE
PFTFLAG2 EQU   13,1,C'X'                SECOND FLAG FIELD
PFTPREF  EQU   X'04'                    PFTE IN PREFERRED AREA
*
         IHAPSA
*  REDEFINE PART OF THE RESERVED AREA IN THE PSA FOLLOWING PSASTMP
*  FOR SE ASSIST.
SEAREA   EQU   PSASTMP+32               BASE POINT
SEPIR2   EQU   SEAREA,4,C'F'            R9 SAVE AREA
SEPPSW   EQU   SEAREA+4,8,C'D'          PSW SAVE
SEPSW    EQU   SEAREA+12,8,C'D'         PSW SAVE
SEPGR2   EQU   SEAREA+20,64,C'F'        R0-R15 REGISTER SAVE AREA
         CVT
         IHAASCB
         IHALCCA
         IHAMPL
         IHAPGTE
         IHAPVT
         IHARSMHD
         IHASGTE
         IHASRB
         END
