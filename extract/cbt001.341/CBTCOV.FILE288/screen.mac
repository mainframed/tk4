SCREEN   TITLE 'FULL SCREEN 3270 CONTROL FROM PL/I'
         MACRO
&LAB     SCRDISP &TREG,&SOURCE
.*
.*   &SOURCE IS THE ADDRESS OF THE SCREEN ADDR TO BE CONVERTED.
.*           IT MAY BE SPECIFIED AS AN ADDRESS OR A REGISTER (1) (15)
.*   &TREG   REGISTER TO CONTAIN THE SCREEN ADDRESS
.*
         AIF   ('&SOURCE'(1,1) NE '(').NOTREG
.*       THIS SECTION HANDLES SOURCE ADDRESS IN A REGISTER
         IC    &TREG,1&SOURCE        GET LOW BYTE OF SCREEN ADDR
         SLL   &TREG,2               MOVE IT OVER
         ICM   &TREG,2,0&SOURCE      GET THE HIGH BYTE
         AGO   .COMMON
.NOTREG  ANOP
.*       THIS SECTION HANDLES SOURCE ADDRESS AS A SYMBOL
         IC    &TREG,&SOURCE+1       GET LOW BYTE OF SCREEN ADDR
         SLL   &TREG,2               MOVE IT OVER
         ICM   &TREG,2,&SOURCE       GET THE HIGH BYTE
.COMMON  ANOP
         SRL   &TREG,2               MOVE IT BACK
         N     &TREG,=X'00000FFF'    CLEAR ALL BUT THE DISPLACEMENT
         MEND
         MACRO
&LAB     PLIRCSET &VALUE,&R1,&R2
.*
.*   THIS MACRO PLACES THE VALUE SPECIFIED IN &VALUE IN THE PLI
.*   RETURN CODE PARM USING REGISTERS &R1 AND &R2 AS WORK REGISTERS.
.*   THIS MACRO ASSUMES ADDRESSABILITY TO THE PL/I PARM LIST.
.*
&LAB     L     &R1,PLIRC            POINT TO THE PLI RC PARM
         LA    &R2,&VALUE           SET THE RETURN CODE VALUE
         STH   &R2,0(&R1)           SAVE THE RETURN CODE
         MEND
         MACRO
&LAB     PLIREA &R1
.*
.*   THIS MACRO POINTS THE REGISTER SPECIFIED BY &R1 TO THE PLI
.*   REASON CODE.  THIS MACRO ASSUMES ADDRESSABILITY TO THE PL/I
.*   PARM LIST.
.*
&LAB     L     &R1,PLIREA           POINT TO THE REASON PARM LOCATOR
         L     &R1,0(&R1)           POINT TO THE REASON PARM
         MEND
         MACRO
&LAB     NOFIELD &TARGET
.*
.*  THIS MACRO IS USED BY ROUTINE FLDBLD TO TEST IF BUFFER PROCESSING
.*  IS TO BE PERFORMED FOR THIS STRUCTURE ELEMENT.
.*
         CLI   NOFIELDS,X'FF'        IS THE NOFIELDS FLAG SET?
         BE    &TARGET               IF SO, SKIP THE BUFFER PROCESSING
         SPACE
         TM    FLAGS,DONTUSE         IF THE DONTUSE FLAG IS SET FOR
         BO    &TARGET               THIS FIELD, SKIP BUFFER PROCESSING
         MEND
*          DATA SET TSBUF3270A AT LEVEL 015 AS OF 11/12/79
         MACRO
         BUF3270A &TYPE=EQU,&ORDERS=YES,&TYPE2=EQU,&FORMAT=FULL
         LCLC  &CONV(64),&LAB
         LCLA  &POS,&BYTE1ID,&BYTE2ID,&ROW,&COL
.**********************************************************************
.*                                                                    *
.*   THIS MACRO EXPANDS TO FORM LABELED EQUATES OR LABELED DEFINE     *
.*   CONSTANTS FOR 3270 SERIES TERMINAL BUFFER ADDRESSES.  THE LABELS *
.*   ARE OF THE FORMAT 'R' ROW# 'C' COL#, E.I. ROW 1 COLUMN 1 IS      *
.*   R1C1.                                                            *
.*                                                                    *
.*   INPUT PARMS:                                                     *
.*   TYPE                                                             *
.*         VALUES  'EQU' OR 'DC'                                      *
.*         THIS PARM SPECIFIES WHETHER THE ROW COLUMN SCREEN          *
.*         ADDRESSES GENERATED WHEN FORMAT=FULL SHOULD BE EQU'S       *
.*         OR DC'S                                                    *
.*   TYPE2                                                            *
.*         VALUES  'EQU' OR 'DC'                                      *
.*         THIS PARM SPECIFIES WHETHER THE ORDERS GENERATED WHEN      *
.*         ORDERS=YES IS SPECIFIED SHOULD BE EQU'S OR DC'S            *
.*   ORDERS                                                           *
.*         VALUES: 'YES' 'NO'                                         *
.*         IF ORDERS = YES IS SPECIFIED, THEN THE 3270 ORDER          *
.*         CODES ARE ASSIGNED TO THEIR SYMBOLIC NAMES.                *
.*   FORMAT                                                           *
.*         VALUES: 'FULL'  'PART' 'BOTH'                              *
.*         IF FORMAT=FULL IS SPECIFIED, THEN THE ROW AND COLUMN       *
.*         NUMBERS IN THE FORMAT R1C1 ARE ASSIGNED TO THEIR           *
.*         SCREEN ADDRESSES.  OTHERWISE THE RAW BYTE VALUES USED      *
.*         TO CONSTRUCT THE SCREEN ADDRESSES ARE OUTPUT.  IF          *
.*         FORMAT=BOTH IS SPECIFIED, THEN BOTH ARE OUTPUT             *
.*                                                                    *
.*                                                                    *
.*   IF DEFINE CONSTANTS ARE GENERATED, THE RESULTING STORAGE MAY BE  *
.*   TREATED AS A ROW ORDERED 2 DIMENSIONAL ARRAY WHICH MAY BE        *
.*   ACCESSED THRU THE FORMULA:                                       *
.*   ORIGON + ((ROW# - 1) * 80 + (COL# - 1)) * 2                      *
.*                                                                    *
.*   THIS MACRO CAN ONLY BE ASSEMBLED UNDER 'H' LEVEL ASSEMBLER       *
.*                                                                    *
.**********************************************************************
*  3270 BUFFER ADDRESSES BY ROW AND COLUMN
&CONV(1) SETC  '40','C1','C2','C3','C4','C5','C6','C7','C8','C9','4A', *
               '4B','4C','4D','4E','4F','50','D1','D2','D3','D4','D5', *
               'D6','D7','D8','D9','5A','5B','5C','5D','5E','5F','60'
&CONV(34) SETC '61','E2','E3','E4','E5','E6','E7','E8','E9','6A','6B', *
               '6C','6D','6E','6F','F0','F1','F2','F3','F4','F5','F6', *
               'F7','F8','F9','7A','7B','7C','7D','7E','7F'
         AIF   ('&ORDERS' NE 'YES').SKIPORD
SF       &TYPE2  X'1D'
SBA      &TYPE2  X'11'
IC       &TYPE2  X'13'
PT       &TYPE2  X'05'
RA       &TYPE2  X'3C'
EUA      &TYPE2  X'12'
ESCAPECH &TYPE2  X'27'
.SKIPORD ANOP
         AIF   ('&FORMAT' EQ 'PART').SHORT
&POS     SETA  0
         AIF   ('&TYPE' EQ 'EQU').LOOP
         DS    0H             ALIGN STORAGE ON HALFWORD
.LOOP    ANOP
&BYTE1ID SETA (&POS/64)+1
&BYTE2ID SETA (&POS-((&POS/64)*64)+1)
&ROW     SETA (&POS/80)+1
&COL     SETA (&POS-((&POS/80)*80)+1)
&LAB     SETC  'R&ROW.C&COL'
&LAB     &TYPE X'&CONV(&BYTE1ID).&CONV(&BYTE2ID).'
&POS     SETA  &POS+1
         AIF   (&POS LT 1920).LOOP
SCRSIZE  EQU   1920
         AIF   ('&FORMAT' NE 'BOTH').END
.SHORT   ANOP
&POS     SETA  1
BUF3270C DS    0F
.LOOP2   ANOP
         DC    X'&CONV(&POS)'
&POS     SETA  &POS+1
         AIF   (&POS LE 64).LOOP2
BUF3270L EQU   *-BUF3270C
.END     ANOP
         MEND
         EJECT
***********************************************************************
*                                                                     *
* SEGMENT NAME:                                                       *
*                                                                     *
*    SCREEN -- CONTROL 3270 SCREEN FUNCTIONS FROM PL/I                *
*                                                                     *
* INPUTS (*TO FUNCTIONS):                                             *
*                                                                     *
*    NUM -- NUMBER OF ELEMENTS USED (*1,2)                            *
*       THIS IS THE SPECIFICATION OF THE THE NUMBER OF ELEMENTS USED  *
*       IN THE ARRAY OF STRUCTURES PASSED TO SCREEN.                  *
*       VALUES: -1 -  ISSUE THE COMMAND ONLY. NO READ OR FIELD        *
*                     PROCESSING WILL BE DONE.  NOTE THAT EVEN THOUGH *
*                     NOT USED, A FIELDEFS PARM MUST BE SUPPLIED.     *
*               0  -  USE THE NUMBER OF ELEMENTS IN THE ARRAY.        *
*               1 TO THE NUMBER OF ELEMENTS IN THE ARRAY OF           *
*                     STRUCTURES                                      *
*                                                                     *
*    CMD -- DISPLAY COMMAND (*4,5,13)                                 *
*       THE DISPLAY COMMAND SPECIFIES WHAT TYPE OF OUTPUT OPERATION   *
*       IS TO BE PERFORMED.  THE INPUT OPERATION, IF ANY, IS ALWAYS A *
*       READ MODIFIED FIELDS OPERATION.                               *
*       VALUES: ERASE/WRITE IN 5 5  THIS IS THE NORMAL OUTPUT         *
*                     OPERATION.  THE SCREEN IS ERASED AND REWRITTEN  *
*                     FROM SCRATCH.  THE OUTPUT OPERATION IS THEN     *
*                     FOLLOWED BY A READ.                             *
*               EWN - ERASE-WRITE-NOREAD                              *
*                    THIS COMMAND CAUSES AN ERASE WRITE BUT SKIPS THE *
*                    READ OPERATION.                                  *
*               WRITE                                                 *
*                    THIS COMMAND CAUSES THE FIELDS SUPPLIED WITH THE *
*                    CALL TO BE OVERLAID ONTO THE EXISTING SCREEN     *
*                    THUS REPLACING THE ORIGINAL FIELDS.  THE OUTPUT  *
*                    OPERATION IS THEN FOLLOWED BY A READ.            *
*               WN - WRITE-NOREAD                                     *
*                    THIS COMMAND CAUSES A WRITE BUT SKIPS THE READ   *
*                    OERATION.                                        *
*               EWA - ERASE-WRITE-ALTERNATE                           *
*                    THIS COMMAND IS THE SAME AS AN ERASE ALL         *
*                    UNPROTECTED EXCEPT THAT FOR TERMINALS WITH DUAL  *
*                    SIZE SCREENS, THIS COMMNAD SHIFTS THE TERMINAL   *
*                    INTO THE ALTERNATE SCREEN SIZE.  NOTE THAT THE   *
*                    WRITE COMMAND DOES NOT AFFECT THE SCREEN SIZE    *
*                    AND THAT AN ERASE/WRITE COMMAND WILL REVERT THE  *
*                    SCREEN TO THE DEFAULT SIZE.                      *
*               EWAN - ERASE-WRITE-ALTERNATE-NOREAD                   *
*                    THIS COMMAND IS LIKE AN ERASE-WRITE-ALTERNAME    *
*                    BUT IT SKIPS THE READ OPERATION.                 *
*               EAU - ERASE ALL UNPROTECTED                           *
*                    THIS COMMAND CAUSES ALL UNPROTECTED FIELDS TO BE *
*                    ERASED.  THIS OPERATION IS THEN FOLLOWED BY A    *
*                    READ.  THIS COMMAND DOES NOT USE ANY FIELD       *
*                    DEFINITIONS.  INPUT FIELDS THOUGH, MUST BE       *
*                    SUPPLIED FOR ANY FIELDS RETURNED BY THE READ     *
*                    OPERATION.                                       *
*                  NOTE: DUE TO THE RESTRICTIONS IMPOSED BY THE TPUT  *
*                  MACRO UNDER TSO, THIS COMMAND IS NOT FUNCTIONAL.   *
*                  (TOO BAD)                                          *
*                                                                     *
         EJECT
*    WCO -- WRITE CONTROL OPTIONS (*4)                                *
*       THIS 5 BIT STRING IS USED TO SPECIFY CERTAIN OPTIONS USED IN  *
*       OUTPUTTING THE DATA TO THE DISPLAY STATION.  EACH OF THE FOUR *
*       CHARACTERISTICS ASSOCIATED WITH THIS OPTION HAS 1 BIT IN THE  *
*       STRING.  THE VALUE USED FOR MOST APPLICATIONS IS '01101'.     *
*       VALUES: BIT1 - AUDIBLE ALARM                                  *
*                      IF THE TERMINAL IS EQUITPED WITH AN AUDIBLE    *
*                      ALARM, THEN SPECIFIATION OF THIS BIT WILL      *
*                      CAUSE THE ALARM TO SOUND DURING THE WRITE      *
*                      OPERATION.                                     *
*               BIT2 - RESTORE KEYBOARD                               *
*                      TURNING THIS BIT ON HAS THE FOLLOWING RESULT.  *
*                      AFTER COMPLETION OF THE OUTPUT EVENT, THE      *
*                      TERMINAL IS SET TO ALLOW KEYBOARD INPUT.  IF   *
*                      THIS BIT IS NOT SET ('0'B), THEN THE OPERATOR  *
*                      MUST PUSH THE RESET BUTTON BEFORE INPUT WILL   *
*                      BE ALLOWED.  THIS BIT IS NORMALLY USED IN THE  *
*                      ON POSITION EXCEPT WHEN USED WITH ERROR        *
*                      MESSAGES.                                      *
*               BIT3 - RESET MDT'S                                    *
*                      THE MDT BITS (FOUND BITS) ARE SET WHEN A FIELD *
*                      IS MODIFIED BY THE OPERATOR OR BY              *
*                      SPECIFICATION OF THE MDT BIT BY THE PROGRAM.   *
*                      DURING A READ OPERATION, ONLY THE FIELDS WITH  *
*                      THE MDT BITS SET ARE MARKED AS FOUND IN THE    *
*                      ARRAY OF STRUCTURES PASSED.  WHEN THIS BIT IS  *
*                      SET, ALL MDT BITS ARE RESET SO THAT ONLY THE   *
*                      FIELDS MODIFIED DURING THIS OUTPUT-INPUT CYCLE *
*                      ARE RETURNED.  THIS BIT IS NORMALLY USED IN    *
*                      THE ON POSITION.                               *
*               BIT4 - DON'T PROTECT SCREEN                           *
*                      BY DEFAULT, THE SCREEN INTERFACE INSERTS A     *
*                      TRAILING FIELD WHICH MAKES THE UNUSED PORTION  *
*                      OF THE SCREEN NON-DISPLAY AND PROTECTED.  TURN *
*                      THIS BIT ON ('1'B) TO CANCEL THIS FEATURE.  IF *
*                      THE FEATURE IS CANCELLED,  THE UNUSED PORTION  *
*                      OF THE SCREEN HAS THE SAME ATTRIBUTES AS THE   *
*                      LAST FIELD ON THE SCREEN.                      *
*               BIT5 - RETURN UPPER CASE ONLY                         *
*                      IF THIS BIT IS SET, ALL LOWER CASE LETTERS IN  *
*                      THE FIELDS READ FROM THE SCREEN WILL BE        *
*                      TRANSLATED TO UPPER CASE.                      *
*                                                                     *
*    FIELDEFS -- FIELD DEFINITIONS (*6,8,9,10,11)                     *
*       THE FIELDS TO BE READ AND WRITTEN ARE DESCRIBED BY AN ARRAY   *
*       OF STRUCTURES. (A SAMPLE ARRAY IS GIVEN IN THE NOTES)  EACH   *
*       ELEMENT IN THE ARRAY REPRESENTS 1 FIELD.  THE FIELDS MUST BE  *
*       ARRANGED IN ASSENDING ROW-COLUMN ORDER.  THUS A FIELD         *
*       STARTING AT ROW 2 COL 50 FOLLOWS A FIELD STARTING AT ROW 2    *
*       COL 1 AND A FIELD STARTING AT ROW 3 COL 1 FOLLOWS A FIELD     *
*       STARTING AT ROW 2 COL 50.                                     *
*       VALUES: STRUCTURE ELEMENTS AND VALUES                         *
*                                                                     *
*               ROW       THE STARTING ROW OF THE FIELD. FIXED        *
*                         BINARY(15)                                  *
*               COL       THE STARTING COL OF THE FIELD. FIXED        *
*                         BINARY(15)                                  *
*               PROTECT   WHEN SET, THIS FIELD IS WRITE PROTECTED.    *
*                         BIT(1)                                      *
*               AUTO_NUM  AUTOMATIC SKIP OR NUMERIC PROTECT.  IF THE  *
*                         NUMERIC PROTECT FEATURE IS INSTALLED ON THE *
*                         TERMINAL, ONLY NUMBERS MAY BE PUT IN THIS   *
*                         FIELD.  IF THIS FLAG IS SET IN CONJUNCTION  *
*                         WITH THE PROTECT FLAG, THEN THE FIELD IS    *
*                         AUTOMATICALLY SKIPPED OVER DURING TYPING.   *
*               HIGH      THIS FIELD IS TO BE DISPLAYED AT HIGH       *
*                         INTENSITY                                   *
*               NODISP    NO DISPLAY.  THIS FLAG IS USED FOR SECURITY *
*                         FIELDS SUCH AS PASSWORDS.  THE FIELD IS     *
*                         TREATED NORMALLY EXCEPT THE DATA IS NOT     *
*                         DISPLAYED ON THE TUBE.                      *
*               MDT       SETTING THIS FLAG FORCES THE MDT BIT TO BE  *
*                         ON REGARDLESS OF WHETHER THE FIELD IS       *
*                         MODIFIED.  THIS WILL FORCE THE FOUND BIT TO *
*                         BE SET.                                     *
*               INPUTONLY SETTING THIS FLAG CAUSES THE OUTPUTING OF   *
*                         THIS FIELD TO BE SUPPRESSED.  THIS FIELD    *
*                         MAY HOWEVER BE USED FOR INPUT.              *
*               CURSOR    WHEN SET THE CURSOR IS PLACED AT THE        *
*                         BEGINNING OF THIS FIELD.  THIS FLAG MAY     *
*                         ONLY BE SET ONCE PER ARRAY OF STRUCTURES.   *
*               FOUND     THIS FLAG IS SET IF THIS FIELD IS MODIFIED  *
*                         BY THE OPERATOR.                            *
*               ORDER     OUTPUT ORDER CODE FOR THIS FIELD            *
*                        THIS FIELD IS USUALLY SET TO ALL BLANKS FOR  *
*                        THE STANDARD OUTPUT FIELD.  THE ALLOWED      *
*                        VALUES ARE DESCRIBED BELOW.   THIS FIELD IS  *
*                        A 3 CHARACTER FIXED LENGTH STRING.           *
*                         (BLANK)   START FIELD.  THIS IS THE NORMAL  *
*                              INPUT OR OUTPUT FIELD.  IT SPECIFIES   *
*                              THAT A FIELD IS TO START AT THE ROW    *
*                              AND COL SPECIFIED IN THIS STRUCTURE.   *
*                         SBA       SET BUFFER ADDRESS.  THIS ORDER   *
*                              IS SIMILAR TO A START FIELD EXCEPT     *
*                              THAT IT IS USED SET THE BUFFER ADDRESS *
*                              WITHOUT STARTING A FIELD.  IT IS       *
*                              USEFULL IN UPDATING PART OF A FIELD,   *
*                              POSITIONING THE CURSOR TO THE MIDDLE   *
*                              OF A FIELD, OR SETTING UP FOR AN ERASE *
*                              UNPROTECTED TO ADDRESS OR REPEAT TO    *
*                              ADDRESS.                               *
*                         PT        PROGRAM TAB.  THIS CAUSES THE     *
*                              DATA ACCOMPANYING THIS STRUCTURE TO BE *
*                              OUTPUT STARTING AT THE NEXT            *
*                              UNPROTECTED FIELD.  THE ROW AND COL    *
*                              ELEMENTS IN THIS STRUCTURE ARE IGNORED *
*                              AS ARE THE ATTRIBUTE FLAGS.  THE       *
*                              ATTRIBUTES ARE DETERMINED FROM THE     *
*                              UNPROTECTED FIELD BEING USED.  IF THE  *
*                              CURRENT BUFFER POSITION IS IN AN       *
*                              UNPROTECTED FIELD,  THE REST OF THIS   *
*                              FIELD IS NULLED OUT. NOTE THAT NO DATA *
*                              CAN BE RETURNED IN A STRUCTURE         *
*                              SPECIFYING ORDER 'PT'.  THIS IS        *
*                              BECAUSE THE LOCATION OF THE FIELD      *
*                              BEING OUTPUT ON THE SCREEN IS UNKNOWN. *
*                              STRUCTURE ELEMENTS MARKED AS NOT USED  *
*                              MAY BE USED TO RETRIEVE DATA.          *
*                         RA        REPEAT TO ADDRESS.  THIS ORDER    *
*                              REPEATS THE SINGLE (OR FIRST) DATA     *
*                              CHARACTER UP TO BUT NOT INCLUDING THE  *
*                              ROW AND COLUMN SPECIFIED IN THIS       *
*                              STRUCTURE. THE CHARACTER INSERTION     *
*                              STARTS AT THE CURRENT SCREEN POSITION. *
*                              NOTE THAT THE CURRENT SCREEN POSITION  *
*                              MAY BE SPECIFIED BY A NULL FIELD       *
*                              IMMEDATELY PRECEDING THIS FIELD.  FOR  *
*                              THIS FIELD THE ATTRIBUTE FLAGS ARE     *
*                              IGNORED.  THE ATTRIBUTES ARE PICKED UP *
*                              FROM THE PRECEDING FIELD.              *
*                         EUA      ERASE UNPROTECTED TO ADDRESS.      *
*                              THIS ORDER ERASES ALL UNPROTECTED      *
*                              FIELDS STARTING AT THE CURRENT ROW AND *
*                              COL AND CONTINUING UP TO BUT NOT       *
*                              INCLUDING THE SPECIFIED ROW AND        *
*                              COLUMN.  DATA FOR THIS ORDER IS        *
*                              IGNORED.  NOTE THAT EAU WILL ERASE     *
*                              ATTIBUTE CHARACTERS AND THAT THE       *
*                              ATTRIBUTE FLAGS FOR THIS STRUCTURE ARE *
*                              IGNORED.                               *
*               DATA     THIS IS A VARYING LENGTH CHARACTER STRING    *
*                         CONTAINING THE DATA TO BE OUTPUT OR         *
*                         PROVIDING A PLACE TO PUT INPUT DATA.  IT    *
*                         SHOULD BE DECLARED LARGE ENOUGH TO HOLD THE *
*                         LONGEST INPUT OR OUTPUT FIELD DEFINED FOR   *
*                         THE SCREEN BEING CREATED.                   *
*                                                                     *
* FUNCTIONS:                                                          *
*                                                                     *
*    1. MAKE SURE THE NUMBER OF ARRAY ELEMENTS IS GREATER THAN THE    *
*       SIZE OF THE ARRAY OR LESS THAN -1.  VALUES ZERO AND MINUS ONE *
*       HAVE SPECIAL VALUES AS DESCRIBED IN THE INPUTS.               *
*                                                                     *
*    2. GETMAIN STORAGE FOR THE BUFFER.  THIS AMOUNT IS CALCULATED AS *
*       FOLOWS:  THE SCREEN SIZE AS CALCULATED FROM THE GTSIZE MACRO. *
*       1 BYTE FOR THE ESCAPE CHARACTER + 1 FOR THE WCC + 1 FOR THE   *
*       COMMAND + 1 FOR THE INSERT CURSOR COMMAND.  AN ADDITIONAL 12  *
*       BYTES ARE GOTTEN FOR EACH STRUCTURE ELEMENT USED(NUM).  THE   *
*       12 BYTES PER ARRAY ELEMENT USED IS BROKEN DOWN INTO 1 FOR THE *
*       SBA +2 FOR THE SCREEN ADDR + 1 FOR THE START FIELD + 8 FOR    *
*       EACH ELEMENT IN THE INTERNAL DATA STRUCTURE KNOWN AS THE ROW  *
*       COLUMN(RC) ARRAY.  NOTE THAT THE ATTIBUTE CHARACTER IS PART   *
*       OF THE FIELD AND INCLUDED IN THE 1920 BYTES.                  *
*                                                                     *
*    3. SET UP AND SAVE THE BOUNDARIES OF THE ROW COLUMN(RC) ARRAY    *
*       AND THE BUFFER AREA.  THE ROW COLUMN ARRAY HAS 3 ELEMENTS PER *
*       ARRAY ELEMENT.  THE FIRST TWO ARE THE SCREEN ADDRESSES OF THE *
*       FIRST AND LAST BYTE OF THE FIELD RESPECTIVELY.  THE LAST      *
*       ELEMENT IS THE ADDRESS OF THE STRUCTURE ELEMENT USED TO       *
*       CREATE THE SCREEN FIELD DESCRIBED BY THE FIRST TWO ELEMENTS.  *
*                                                                     *
*    4. DETERMINE AND INSET THE ESCAPE, COMMAND, AND WCC CHARACTERS   *
*       INTO THE SCREE BUFFER.                                        *
*                                                                     *
*    5. FOR COMMAND ERASE ALL UNPROTECTED, MARK THAT NO FIELDS ARE TO *
*       BE PLACED IN THE BUFFER.                                      *
*                                                                     *
*    6. FOR EACH STRUCTURE IN THE ARRAY OF FIELD DEFINITIONS PASSED,  *
*       BUILD THE FIELD AND THE RC ARRAY ELEMENT ASSOCIATED WITH THE  *
*       FIELD AND CLEAR THE FOUND BIT IN THE STRUCTURE.               *
*                                                                     *
*    7. IF WE RUN OUT OF BUFFER DURING PROCESSING, ERROR AND QUIT.    *
*                                                                     *
*    8. FOR A START FIELD ORDER, INSERT THE SF CHARACTER, CALCULATE   *
*       AND INSERT THE BUFFER ADDR, INSERT THE CUSOR IF REQUIRED, AND *
*       INSERT THE DATA IF NECESSARY.                                 *
*                                                                     *
*    9. FOR A PT ORDER, INSERT THE PT ORDER AND THE DATA AND FILL IN  *
*       THE RC ARRAY.                                                 *
*                                                                     *
*   10. FOR A REPEAT TO ADDRESS ORDER, INSERT THE ORDER CODE, THE     *
*       SCREEN ADDRESS, AND THE CHARACTER TO BE REPEATED.  ALSO FILL  *
*       IN THE RC ADDRESS                                             *
*                                                                     *
*   11. FOR A ERASE UNPROTECTED TO ADDRESS ORDER, INSERT THE ORDER    *
*       AND THE ADDRESS AND FILL IN THE RC ARRAY.                     *
*                                                                     *
*   12. ISSUE A FULL SCREEN TPUT.  IF THE TPUT FAILS RETURN WITH THE  *
*       ERROR CODES.                                                  *
*                                                                     *
*   13. IF A NOREAD COMMADN WAS USED, RETURN RC=-1.                   *
*                                                                     *
*   14. ISSUE A FULL SCREEN TGET.  IF THE TGET FAILS, RETURN WITH THE *
*       ERROR CODES                                                   *
*                                                                     *
*   15. EXTRACT THE AID AND CURSOR POSITION VALUES FROM THE TGET      *
*       BUFFER AND PUT THEM IN THE PL/I PARMS.                        *
*                                                                     *
*   16. IDENTIFY EACH RETURNED FIELD AND PUT THE DATA IN THE PROPER   *
*       STRUCTURE IN THE ARRAY OF FIELD DEFINITIONS AND SET THE FOUND *
*       BIT.                                                          *
*                                                                     *
* OUTPUTS (*FROM FUNCTIONS):                                          *
*                                                                     *
         EJECT
*    RC -- RETURN CODE (*1,4,6,7,8,9,10,11,12,13,14)                  *
*       THE RETURN CODE SPECIFIES WHAT TYPE OF ERRORS, IF ANY WERE    *
*       ENCOUNTERED DURING THE SCREEN MANIPULATION.  THE REASON CODE  *
*       GIVES MORE INFORMATION FOR SOME ERROR TYPES.                  *
*       VALUES: 0   - SUCCESS                                         *
*               4   - NOT A DISPLAY TERMINAL                          *
*               8   - STRUCTURE FORMAT ERROR. THE REASON PARM GIVES   *
*                     THE ERROR CODE AND STRUCTURE ELEMENT NUMBER.    *
*                     REASONS 1 TO 9 AND 11 TO 14 MAY BE ASSOCIATED   *
*                     WITH THIS RETURN CODE.                          *
*               12  - ERROR LOADING THE INPUT FIELDS.  THE REASON     *
*                     PARM GIVES THE ERROR CODE AND STRUCTURE ELEMENT *
*                     NUMBER.  REASONS 10 OR 11 MAY BE ASSOCIATED     *
*                     WITH THIS RETURN CODE.                          *
*               16  - TPUT ERROR.  ELEMENT 1 OF THE REASON PARM GIVES *
*                     THE TPUT RETURN CODE.                           *
*               20  - TGET ERROR.  ELEMENT 1 OF THE REASON PARM GIVES *
*                     THE TGET RETURN CODE.                           *
*               24  - INVALID COMMAND SPECIFIED IN THE CMD PARM       *
*               28  - IN LOADING THE INPUT STRUCTURE, A FIELD WAS     *
*                     RECEIVED FROM TGET FOR WHICH THERE WAS NO       *
*                     STRUCTURE FIELD IN WHICH TO PLACE IT.  THE      *
*                     REASON CODE CONTAINS THE ROW AND COLUMN AT      *
*                     WHICH THE FIELD STARTED.  DATA HAS BEEN LOST    *
*                     AND LOADING OF THE STRUCTURE HAS BE TERMINATED  *
*                     PAST THIS ROW AND COLUMN.                       *
*                                                                     *
*    REA -- REASON CODE (*1,6,7,8,9,10,11,12,14)                      *
*       THIS TWO ELEMENT FIXED BINARY(15) ARRAY CONTAINS ADDITIONAL   *
*       INFORMATION FOR SOME RETURN CODES.  THE REASON CODES FOR      *
*       RETURN CODES OF 8 AND 12 CONSIST OF ONE OF THE CODES SHOWN    *
*       BELOW IN ELEMENT 1 AND THE ELEMENT NUMBER FROM THE ARRAY OF   *
*       STRUCTURES WHICH CAUSED THE ERROR TO BE DETECTED IN ELEMENT   *
*       2. FOR RETURN CODES OF 16 AND 20, ELEMENT 1 CONTAINS THE TPUT *
*       OR TGET RETURN CODE AND ELEMENT 2 IS ZERO.  FOR RETURN CODE   *
*       28, ELEMENT 1 CONTAINS THE ROW OF THE FIELD WHICH COULD NOT   *
*       BE LOADED AND ELEMENT 2 CONAINS THE COLUMN OF THIS FIELD.     *
*       VALUES: 1  -  NUMBER OF ELEMENTS SPECIFIED IS LESS THAN 1 OR  *
*                     GREATER THAN THE NUMBER OF STRUCTURE ELEMENTS   *
*                     IN THE ARRAY PASSED.                            *
*               2  -  CANNOT INTERPRET THE ORDER SPECIFIED            *
*               3  -  ROW SPECIFIED IS INVALID                        *
*               4  -  COLUMN SPECIFIED IS INVALID                     *
*               5  -  MULTIPLE ATTEMPTS TO INSERT THE CURSOR.  SECOND *
*                     ATTEMPT IS THE ONE FLAGGED.                     *
*               6  -  TOO MUCH DATA, SCREEN BUFFER OVERFLOW           *
*               7  -  STRUCTURE ELEMENT NOT IS ROW-COL ASCENDING      *
*                     ORDER                                           *
*               8  -  PT OR EUA SPECIFIED FOR A COMMAND OTHER THAN    *
*                     WRITE OR WRITE NOREAD                           *
*               9  -  NO CHAR SPECIFIED FOR COMMAND REPEAT TO ADDRESS *
*               10 -  DATA TRUNCATION ON LOADING FIELDS.  DATA        *
*                     INSERTION COMPLETED.  ELEMENT 2 POINTS TO THE   *
*                     LAST ELEMENT TO BE TRUNCATED.                   *
*               11 -  COULD NOT IDENTIFY CURSOR POSITION OR OTHER     *
*                     SCREEN ADDRESS, BRING LISTING AND DUMP TO       *
*                     AUTHOR.  ELEMENT 2 OF THE REASON CONTAINS THE   *
*                     UNFORMATTED SCREEN ADDR.                        *
*               12 -  FIELD RUNS OFF SCREEN.                          *
*               13 -  ROW AND COLUMN SPECIFIED DESIGNATE A SCREEN     *
*                     ADDRESS BEFORE THE CURRENT SCREEN ADDRESS.      *
*                     (WITHIN THE LAST FIELD)                         *
*               14 -  REPEAT TO ADDRESS OR ERASE UNPROTECTED TO       *
*                     ADDRESS ORDER IMMEDIATELY FOLLOWING A PROGRAM   *
*                     TAB ORDER.                                      *
*                                                                     *
*    FIELDEFS -- FIELD DEFINITIONS (*6,16)                            *
*       THE FIELDS TO BE READ AND WRITTEN ARE DESCRIBED BY AN ARRAY   *
*       OF STRUCTURES. (A SAMPLE ARRAY IS GIVEN IN THE NOTES)  EACH   *
*       ELEMENT IN THE ARRAY REPRESENTS 1 FIELD.  THE FIELDS MUST BE  *
*       ARRANGED IN ASSENDING ROW-COLUMN ORDER.  THUS A FIELD         *
*       STARTING AT ROW 2 COL 50 FOLLOWS A FIELD STARTING AT ROW 2    *
*       COL 1 AND A FIELD STARTING AT ROW 3 COL 1 FOLLOWS A FIELD     *
*       STARTING AT ROW 2 COL 50.                                     *
*       VALUES: SEE INPUT FOR FIELD DEFINTION DESCRIPTIONS            *
*                                                                     *
*    AID -- ATTENTION IDENTIFICATION (*15)                            *
*       THIS CODE IS RETURNED TO THE CALLING PL/I PROGRAM IN A FIXED  *
*       BINARY(15) VARIABLE TO IDENTIFY WHCIH KEY WAS PRESSED TO      *
*       ENTER THE DATA.                                               *
*       VALUES: -1  -  RETURNED WHEN NO READ OPERATION WAS EXECUTED   *
*               0   -  ENTER KEY                                      *
*               1   -  PF1  KEY                                       *
*               2   -  PF2  KEY                                       *
*               3   -  PF3  KEY                                       *
*               4   -  PF4  KEY                                       *
*               5   -  PF5  KEY                                       *
*               6   -  PF6  KEY                                       *
*               7   -  PF7  KEY                                       *
*               8   -  PF8  KEY                                       *
*               9   -  PF9  KEY                                       *
*               10  -  PF10 KEY                                       *
*               11  -  PF11 KEY                                       *
*               12  -  PF12 KEY                                       *
*               13  -  PF13 KEY                                       *
*               14  -  PF14 KEY                                       *
*               15  -  PF15 KEY                                       *
*               16  -  PF16 KEY                                       *
*               17  -  PF17 KEY                                       *
*               18  -  PF18 KEY                                       *
*               19  -  PF19 KEY                                       *
*               20  -  PF20 KEY                                       *
*               21  -  PF21 KEY                                       *
*               22  -  PF22 KEY                                       *
*               23  -  PF23 KEY                                       *
*               24  -  PF24 KEY                                       *
*               25  -  TEST REQ KEY,  NO FIELDS READ                  *
*               26  -  CLEAR KEY, SCREEN ERASED, NO FIELDS READ       *
*               27  -  PA1 KEY, NO FIELDS READ                        *
*               28  -  PA2 KEY, NO FIELDS READ                        *
*               29  -  PA3 KEY, NO FIELDS READ                        *
*                                                                     *
*    CPOS -- CURSOR POSITION (*15)                                    *
*       THIS 2 ELEMENT FIXED BINARY(15) ARRAY IS SET TO THE POSITION  *
*       OF THE CURSOR WHEN THE INPUT OPERATION WAS COMPLETED.         *
*       VALUES: ELEMENT 1  -  ROW CURSOR WAS IN                       *
*               ELEMENT 2  -  COLUMN CURSOR WAS IN                    *
*                                                                     *
* NOTES:                                                              *
*                                                                     *
*    1. SAMPLE DECLARATIONS AND CALLS:                                *
*                                                                     *
*       DECLARE SCREEN ENTRY(                                         *
*             VARYING CHAR(*),                                        *
*             BIT(5),                                                 *
*             FIXED BINARY(15),                                       *
*             (2) FIXED BINARY(15),                                   *
*             (2) FIXED BINARY(15),                                   *
*             FIXED BINARY(15),                                       *
*             1(*),                                                   *
*                 2 FIXED BINARY(15),                                 *
*                 2 FIXED BINARY(15),                                 *
*                 2 BIT(1),                                           *
*                 2 BIT(1),                                           *
*                 2 BIT(1),                                           *
*                 2 BIT(1),                                           *
*                 2 BIT(1),                                           *
*                 2 BIT(1),                                           *
*                 2 BIT(1),                                           *
*                 2 BIT(1),                                           *
*                 2 CHAR(3),                                          *
*                 2 VARYING CHAR(*)) EXTERNAL RETURNS(FIXED           *
*                 BINARY(15));                                        *
*                                                                     *
*       DECLARE CMD VARYING CHAR(11);                                 *
*       DECLARE WCO BIT(5);                                           *
*       DECLARE AID FIXED BINARY(15);                                 *
*       DECLARE CPOS(2) FIXED BINARY(15);                             *
*       DECLARE REA(2) FIXED BINARY(15);                              *
*       DECLARE NUM    FIXED BINARY(15);                              *
*       DECLARE RC     FIXED BINARY(15);                              *
*                                                                     *
*       DECLARE  01  FIELDEFS(5),                                     *
*                    02  ROW       FIXED BINARY(15),                  *
*                    02  COL       FIXED BINARY(15),                  *
*                    02  PROTECT   BIT(1),                            *
*                    02  AUTO_NUM  BIT(1),                            *
*                    02  HIGH      BIT(1),                            *
*                    02  NODISP    BIT(1),                            *
*                    02  MDT       BIT(1),                            *
*                    02  INPUTONLY BIT(1),                            *
*                    02  CURSOR    BIT(1),                            *
*                    02  FOUND     BIT(1),                            *
*                    02  ORDER     CHAR(3),                           *
*                    02  DATA      VARYING CHAR(20);                  *
*                                                                     *
*                                                                     *
*       RC = SCREEN(CMD,WCO,AID,CPOS,REA,NUM FIELDEFS);               *
*                                                                     *
*                                                                     *
*                                                                     *
*                                                                     *
*                                                                     *
*                                                                     *
*                           RESPONSIBLE DESIGNER:                     *
*                                                                     *
*                         R. E. STYMA  DEPT. 482.23                   *
*                                                                     *
***********************************************************************
         EJECT
SCREEN   CSECT
         ENTER R,SPIE=NO
         SPACE 2
***********************************************************************
*                                                                     *
* CLEAR ALL FLAGS AND SAVE THE PARM ADDR FROM PL/I.  SET THE PL/I RC  *
* AND REASON PARMS TO ZERO.  ALSO ESTABLISH ADDRESSABILITY TO THE     *
* COMMON DATA AREA                                                    *
*                                                                     *
***********************************************************************
         SPACE
         LR    R11,R1              SAVE THE PARM LIST ADDR
         USING PLIPARMS,R11        AND OVERLAY THE NMEUMONIC NAMES
         SPACE
         L     R10,=V(DATAAREA)    LOAD THE START OF THE DATA AREA
         USING DATAAREA,R10        AND ACTIVATE THE NMEUMONIC NAMES
         SPACE
         ST    R11,PARMADDR        SAVE THE PARM ADDR SO THE
*                                  SUBROUTINES CAN USE IT
         PLIRCSET 0,R14,R15        ZERO THE PL/I RETURN CODE
         SPACE
         PLIREA R14                ACCESS THE REASON PARM
         XC    0(4,R14),0(R14)     ZERO THE REASON
         SPACE
         MVI   CURSESET,X'00'      CLEAR THE FLAGS
         MVI   NOREAD,X'00'
         MVI   NOFIELDS,X'00'
         MVI   CMDONLY,X'00'
         MVI   UPPER,X'00'
         EJECT
***********************************************************************
*                                                                     *
* MAKE SURE THAT THE NUM PARM IS NOT ZERO NOR GREATER THAN THE NUMBER *
* OF ELEMENTS IN THE ARRAY OF FIELD DEFINITION STRUCTURES.  IF NUM IS *
* NEGATIVE, TREAT IT AS A COMMAND ONLY CALL.                          *
*                                                                     *
*      REGISTER USAGE:                                                *
*              R7  -  NUMBER OF ELEMENTS USED                         *
*              R10 -  BASE FOR DATA AREA                              *
*              R11 -> PLI PARM LIST, BASE FOR PLIPARMS                *
*              R12 -> PL/I TASK COMMUNICATION AREA, DO NOT MODIFY     *
*              R13 -  BASE FOR PROGRAM AND DSA                        *
*              R14 - TEMP STORAGE FOR NUM OF ELEMENTS IN THE ARRAY    *
*              R15 - WORK                                             *
*                                                                     *
***********************************************************************
         SPACE
         L    R15,PLISTR          POINT TO THE STRUCTURE LOCATOR
         L    R15,4(R15)          POINT TO THE STRUCTURE DESCRIPTOR
         USING DESCRIPT,R15       OVERLAY THE SYMBOLIC DESCRIPTION
         SPACE
         LH   R14,ROWHB           LOAD THE UPPER BOUND
         SH   R14,ROWLB           SUBSTRACT THE LOWER BOUND
         LA   R14,1(R14)          AND ADD 1 TO GET THE NUMBER OF
*                                 ARRAY ELEMENTS
         LH   R0,DATADCL          GET THE DECLARED LENGTH OF THE
*                                 DATA PORTION OF THE STRUCTURES
         STH  R0,MAXDATA          AND SALT IT AWAY
         L    R0,ROWMULT          GET THE LENGTH OF EACH STRUCTURE
         ST   R0,STRLEN           AND SALT IT AWAY
         SPACE
         DROP R15                 WE ARE DONE WITH THE STRUCTURE DESC
         SPACE
         L    R15,PLINUM          POINT TO THE NUM PARM
         LH   R7,0(R15)           LOAD THE NUMBER OF ELEMENTS USED
         LTR  R7,R7               IS THE NUMBER NEGATIVE?
         BM   SHORT               IF SO, TREAT AS A COMMAND ONLY CALL
         SPACE
         BNZ  COMP2               IF IT IS ZERO, USE THE NUMBER OF
*                                 ELEMENTS IN THE STRUCTURE
         SPACE
         LR   R7,R14              LOAD THE NUMBER OF ELEMENTS TO USE
         B    GETSIZE             AND GO ON
         SPACE
COMP2    DS    0H
         CR    R7,R14             IS THE NUMBER TOO BIG
         BNH   GETSIZE            IF NOT, GO CONTINUE
         EJECT
***********************************************************************
*                                                                     *
* THE NUMBER OF ELEMENTS SPECIFIED IS INVALID.  SET RC=8 AND          *
* REASON=(1,0)                                                        *
*                                                                     *
***********************************************************************
         SPACE
ERROR1   DS    0H
         PLIRCSET 8,R14,R15       SET PL/I RC=8
         SPACE
         PLIREA   R14             ACCESS THE REASON CODE
         LA       R15,REASON1     LOAD REASON 1
         SLL      R15,16          MOVE TO THE HIGH HALF WORD
         ST       R15,0(R14)      SAVE THE REASON
         B        RETURN2
         SPACE 2
***********************************************************************
*                                                                     *
* SET THE FLAGS TO SHOW THAT THIS IS A COMMAND ONLY RUN AND THAT NO   *
* FIELDS ARE TO BE PROCESSED AND NO READ IS TO BE PERFORMED.          *
*                                                                     *
***********************************************************************
         SPACE
SHORT    DS    0H
         CH    R7,=H'-1'          IS THIS THE SPECIAL VALUE?
         BNE   ERROR1             IF NOT QUIT
         SPACE
         MVI   CMDONLY,X'FF'      SHOW THIS IS THE SHORT FORMAT
         MVI   NOREAD,X'FF'       SHOW NO READ TO BE PERFORMED
         SLR   R7,R7              SHOW NO ELEMENTS
         EJECT
***********************************************************************
*                                                                     *
* GET AND SAVE THE NUMBER OF ROWS AND COLUMNS ON THE SCREEN.  IF THIS *
* TERMINAL IS NOT A DISPLAY STATION, RETURN RC=4 AND REASON=(0,0).    *
* FOR NON-DISPLAY TERMINALS THE NUM ROWS IS 0 (R0 = 0).               *
*              R0  -  NUM ROWS ON THIS SCREEN                         *
*              R1  -  NUM COLUMNS PER ROW (LINE SIZE)                 *
*              R7  -  NUMBER OF ELEMENTS USED IN THE ARRAY            *
*              R10 -  BASE FOR DATA AREA                              *
*              R11 -> PLI PARM LIST, BASE FOR PLIPARMS                *
*              R12 -> PL/I TASK COMMUNICATION AREA, DO NOT MODIFY     *
*              R13 -  BASE FOR PROGRAM AND DSA                        *
*              R14 - WORK                                             *
*              R15 - WORK                                             *
*                                                                     *
***********************************************************************
         SPACE
GETSIZE  DS    0H
         GTSIZE
         SPACE
         LTR   R0,R0                IS THIS A DISPLAY STATION
         BNZ   TERMOK               IF SO. GO CONTINUE PROCESSING
         SPACE
         PLIRCSET 4,R14,R15         SET THE PLI RC=4
         SPACE
         B     RETURN2              AND GO BACK TO PL/I
         SPACE
TERMOK   DS    0H
         STH   R1,NUMCOLS           SAVE THE NUMBER OF COLUMNS
         STH   R0,NUMROWS           SAVE THE NUMBER OF ROWS
         MH    R0,NUMCOLS           GET THE TOTAL SCREEN SIZE
         STH   R0,SCREENSZ          AND SAVE IT
         EJECT
***********************************************************************
*                                                                     *
* CALCULATE THE STORAGE NECESSARY FOR THE BUFFER AND DO A GETMAIN FOR *
* THIS AMOUNT.  THE STORAGE CALCULATIONS ARE IN THE PROLOGUE.         *
*              R2  -  WORK                                            *
*              R7  -  THE NUMBER OF ELEMENTS USED IN THE ARRAY OF     *
*                     STRUCTURES                                      *
*              R10 -  BASE FOR DATA AREA                              *
*              R11 -> PLI PARM LIST, BASE FOR PLIPARMS                *
*              R12 -> PL/I TASK COMMUNICATION AREA, DO NOT MODIFY     *
*              R13 -  BASE FOR PROGRAM AND DSA                        *
*              R15 -  USED TO CALCULATE THE BUFFER SIZE               *
*                                                                     *
***********************************************************************
         SPACE
CALCBUF  DS    0H
         LA    R15,1(R7)            GET THE NUMBER OF ELEMENTS USED + 1
         MH    R15,=H'12'           CALC THE ELEMENT DEPENDENT SIZE
         LA    R15,4(R15)           ADD IN THE FIXED SIZE
         AH    R15,SCREENSZ         ADD IN THE SCREEN SIZE
         ST    R15,BUFLEN           SAVE THIS LENGTH
         LR    R2,R15                SET UP THE LENGTH
         SPACE
         GETMAIN RU,LV=(R2)          GET THE BUFFER AREA
         SPACE 2
***********************************************************************
*                                                                     *
* SET UP AND STORE THE BUFFER BEGINNING AND END AND THE ROW           *
* COLUMN(RC) ARRAY BEGINNING AND END                                  *
*                                                                     *
*      REGISTER USAGE:                                                *
*              R7  -  NUMBER OF ELEMENTS IN THE ARRAY                 *
*              R8  -> NEXT ROW COUMN ARRAY ELEMENT TO BE USED         *
*              R9  -> NEXT POSITION IN THE BUFFER TO BE FILLED        *
*              R10 -  BASE FOR DATA AREA                              *
*              R11 -> PLI PARM LIST, BASE FOR PLIPARMS                *
*              R12 -> PL/I TASK COMMUNICATION AREA, DO NOT MODIFY     *
*              R13 -  BASE FOR PROGRAM AND DSA                        *
*                                                                     *
***********************************************************************
       SPACE
       ST    R1,RCSTART          SAVE THE ROW COUMN START ADDR
       LR    R8,R1               SET THE FIRST RC ELEMENT TO BE USED
       LR    R15,R7              MOVE THE NUMBER OF ELEMENTS TO A
*                                WORKAREA
       LA    R15,1(R15)          ADD 1 ELEMENT FOR THE RC ARRAY TRAILER
       SLA   R15,3               MULTIPLY BY 8 FOR THE RC ARRAY LEN
       LA    R9,0(R15,R8)        MARK THE START OF THE OUTPUT BUFFER
       ST    R9,BUFSTART         AND SAVE IT
       SPACE
       LR    R15,R8              POINT BACK TO THE START OF THE
*                                GOTTEN AREA.
       A     R15,BUFLEN          POINT JUST PAST THE END OF THE BUFFER
       ST    R15,BUFEND          AND SAVE THIS ADDRESS
       EJECT
***********************************************************************
*                                                                     *
* INSERT THE ESCAPE CHARACTER, THE COMMAND CODE AND THE WRITE CONTROL *
* CHARACTER INTO THE BUFFER.  THE ESCAPE CHARACTER IS A CONSTANT, THE *
* COMMAND CODE IS DETERMINED BY A TABLE SEARCH AND THE WCC IS         *
* DETERMINED BY A TABLE INDEX.  THE BITS OF THE WCO FLAGS ARE USED AS *
* AN OFFSET INTO THE TABLE.  THE NOREAD FLAG IS SET TO SHOW A READ    *
* WILL NOT BE PERFORMED.  THE NOFIELDS FLAG IS USED FOR THE ERASE ALL *
* UNPROTECTED COMMAND TO SHOW THAT THERE ARE NO OUTPUT FIELDS.  THE   *
* STRUCTURE FOR THE SCREEN MUST STILL BE INCLUDED AS THE READ         *
* FOLLOWING THE TPUT WILL FILL SOME OR ALL OF THE FIELDS.             *
*                                                                     *
*      REGISTER USAGE:                                                *
*              R1  -> CURRENT COMMAND TABLE ENTTRY                    *
*              R2  -> JUST PAST THE COMMAND TABLE                     *
*              R7  -  NUMBER OF ELEMENTS IN THE ARRAY                 *
*              R8  -> NEXT ROW COUMN ARRAY ELEMENT TO BE USED         *
*              R9  -> NEXT POSITION IN THE BUFFER TO BE FILLED        *
*              R10 -  BASE FOR DATA AREA                              *
*              R11 -> PLI PARM LIST, BASE FOR PLIPARMS                *
*              R12 -> PL/I TASK COMMUNICATION AREA, DO NOT MODIFY     *
*              R13 -  BASE FOR PROGRAM AND DSA                        *
*              R14 -> COMMAND PARM                                    *
*              R15 - LENGTH OF THE COMMAND NAME BEING CHECKED FOR     *
*                                                                     *
***********************************************************************
         SPACE
         MVI   0(R9),ESCAPECH      INSERT THE ESCAPE CHARACTER
         SPACE
         L     R14,PLICMD          POINT TO THE COMMAND L/D
         L     R14,0(R14)          POINT TO THE COMMAND LEN
         LH    R15,0(R14)          LOAD THE LENGTH
         LA    R1,CMDTABLE         POINT TOT HE START OF THE CMD TABLE
         USING CMD,R1              AND OVERLAY THE DSECT
         SPACE
         LA    R2,CMDEND           USE THE END OF THE TABLE TO
*                                  TERMINATE THE CMD SEARCH LOOP
         SPACE
CMDLOOP  DS    0H
         CH    R15,CMDLEN          DOES THE COMMAND LENGTH MATCH THE
*                                  ONE IN THE TABLE?.
         BNE   NEXTCMD             IF NOT, GO TO THE NEXT COMMAND
         SPACE
         BCTR  R15,0               SUBTRACT 1 FOR THE CLC
         EX    R15,CMDCHK          IS THIS THE COMMAND?
         LA    R15,1(R15)          RESTORE R15, DOES NOT MODIFY CC
         BNE   NEXTCMD             IF NOT THE COMMAND, GO TO THE NEXT
         EJECT
***********************************************************************
*                                                                     *
* THE COMMAND HAS BEEN FOUND. MOVE THE COMMAND CODE.  IF THE COMMAND  *
* IS ERASE ALL UNPROTECTED, SET THE NOFIELDS FLAG, BUMP THE BUFFER    *
* ADDRESS, AND GO PROCESS THE SCREEN.  NO WCC CHAR IS USED.           *
*                                                                     *
***********************************************************************
         SPACE
         MVC   1(1,R9),CMDCODE     MOVE THE COMMAND CODE
         OC    NOREAD(1),CMDREAD   SET THE NOREAD FLAG FROM THE TABLE
         SPACE
         CLI   1(R9),X'F5'         IS THIS AN ERASE WRITE?
         BNE   EAU001              IF NOT, KEEP GOING
         SPACE
         CLC   NUMROWS(2),=H'43'   IS THIS A 3278 MOD 4? AND AN 'EW'
         BNE   EAU001              IF NOT, KEEP GOING
         SPACE
         MVI   1(R9),X'7E'         CHANGE ERASE WRITE TO EWA FOR MOD 4
         B     WCCLOOK             AND CONTINUE
         SPACE
EAU001   DS    0H
         CLI   1(R9),X'6F'         IS THE EAU?
         BNE   WCCLOOK             IF NOT, SKIP MARKING THE FLAG
         SPACE
         MVI   NOFIELDS,X'FF'      SET THE NOFIELDS FLAG
         LA    R9,2(R9)            BUMP THE BUFFER ADDRESS
         B     BUILDSCR            AND CONTINUE PROCESSING
         SPACE 2
***********************************************************************
*                                                                     *
* TRY THE NEXT COMMAND                                                *
*                                                                     *
***********************************************************************
         SPACE
NEXTCMD  DS    0H
         LA    R1,CMDELEN(R1)      POINT TO THE NEXT COMMAND ELEMENT
         CR    R1,R2               ARE WE PAST THE END?
         BL    CMDLOOP             IF NOT, KEEP LOOKING
         SPACE 2
***********************************************************************
*                                                                     *
* WE CANNOT IDENTIFY THE COMMAND. QUIT RC=24 AND REASON=(0,0)         *
*                                                                     *
***********************************************************************
         SPACE
         PLIRCSET 24,R14,R15       SET PLI RC=24, REASON IS ALREADY SET
         B     RETURN
         EJECT
***********************************************************************
*                                                                     *
* USE THE 3 BITS OF THE WCO AS AN OFFSET INTO THE WCC TABLE. THEN USE *
* THE CHAR FOUND AT THIS POINT IN THE TABLE AS THE WCC.               *
*                                                                     *
* WHILE WE HAVE ACCESS TO THE WCO, CHECK BIT 5 OF THE WCO TO SEE IF   *
* TRANSLATION TO UPPER CASE ON THE INPUT STREAN IS BEING REQUESTED.   *
* IF SO, SET THE FLAG.                                                *
*                                                                     *
*      REGISTER USAGE:                                                *
*              R7  -  NUMBER OF ELEMENTS IN THE ARRAY                 *
*              R8  -> NEXT ROW COUMN ARRAY ELEMENT TO BE USED         *
*              R9  -> NEXT POSITION IN THE BUFFER TO BE FILLED        *
*              R10 -  BASE FOR DATA AREA                              *
*              R11 -> PLI PARM LIST, BASE FOR PLIPARMS                *
*              R12 -> PL/I TASK COMMUNICATION AREA, DO NOT MODIFY     *
*              R13 -  BASE FOR PROGRAM AND DSA                        *
*              R14 -> WCO TABLE ENTRY                                 *
*              R15 -  WORK, USED TO CALCULATE THE OFFSET INTO THE WCC *
*                     TABLE                                           *
*                                                                     *
***********************************************************************
         SPACE
WCCLOOK  DS    0H
         L     R14,PLIWCO          POINT TO THE WCO LOCATOR/DESCRIPTOR
         L     R14,0(R14)          POINT TO THE 3 BIT FIELD
         SLR   R15,R15             ZERO THE REGISTER
         IC    R15,0(R14)          LOAD THE WCO
         SRL   R15,5               THE EXTRA BITS ARE NOT USED
         SPACE
         TM    0(R14),X'08'        IS THE UPPER CASE BIT SET?
         BZ    USEASIS             IF NOT, SKIP SETTING THE FLAG
         SPACE
         MVI   UPPER,X'FF'         MARK FOR UPPER CASE TRANSLATION
         SPACE
USEASIS  DS    0H
         LA    R15,WCCTABLE(R15)   USE THE 3 BITS AS AN OFFSET
         MVC   2(1,R9),0(R15)      MOVE THE WCC
         SPACE
         LA    R9,3(R9)            BUMP THE BUFFER POINTERR PAST THE
*                                  ESCAPE, CMD, AND WCC CHARACTERS
         SPACE
         CLI   CMDONLY,X'FF'       IS THIS COMMAND ONLY FORMAT?
         BNE   BUILDSCR            IF NOT, GO BUILD THE SCREEN
         SPACE
         MVC   0(4,R9),=XL4'11404013'  PUT IN THE SBA, ADDR, AND IC
         LA    R9,4(R9)                BUMP THE CURRENT BUFFER POS
         B     DOTPUT              AND GO DO THE TPUT
         EJECT
***********************************************************************
*                                                                     *
* GO TO THE START OF THE ARRAY OF STRUCTURES AND LOOP THROUGH THE     *
* ARRAY BUILDING THE FIELDS.  ROUTINE FLDBUILD INSERTS THE FIELD AND  *
* RETURNS THE NEW BUFFER ADDRESS ALONG WITH A RETURN CODE SHOWING THE *
* RESULT OF THE ATTEMPT. ON NON-ZERO RETURN CODE, QUIT.  FOR THE EAU  *
* COMMAND THE FLDBLD ROUTINE CHECKS THE NOFIELDS FLAG AND BUILDS ONLY *
* THE RC ARRRAY ELEMENT FOR THIS STRUCTURE.                           *
*                                                                     *
*      REGISTER USAGE:                                                *
*              R2  -  LAST ROW USED                                   *
*              R3  -  LAST COL USED                                   *
*              R4  -  COUNTER FOR THE NUMBER OF STRUCTURES TO PROCESS *
*              R5  -> CURRENT STRUCTURE                               *
*              R6  -  LENGTH OF EACH STRUCTURE                        *
*              R7  -  NUMBER OF ELEMENTS IN THE ARRAY                 *
*              R8  -> NEXT ROW COUMN ARRAY ELEMENT TO BE USED         *
*              R9  -> NEXT POSITION IN THE BUFFER TO BE FILLED        *
*              R10 -  BASE FOR DATA AREA                              *
*              R11 -> PLI PARM LIST, BASE FOR PLIPARMS                *
*              R12 -> PL/I TASK COMMUNICATION AREA, DO NOT MODIFY     *
*              R13 -  BASE FOR PROGRAM AND DSA                        *
*                                                                     *
***********************************************************************
         SPACE
BUILDSCR DS    0H
         SLR   R2,R2               CLEAR REGS TO SHOW R0 C0
         SLR   R3,R3
         L     R6,STRLEN           GET THE STRUCTURE LENGTH
         L     R5,PLISTR           POINT TO THE STRUCTURE LOCATOR
         L     R5,0(R5)            POINT TO THE FIRST STRUCTURE
         USING FIELDEFS,R5         GET SYMBOLIC ACCESS TO THE STRUCTURE
         SPACE
         LR    R4,R7               GET THE NUM OF ELEMENTS TO PROCESS
         SPACE
FILLLOOP DS    0H
         ICM   R15,X'C',ROW        GET THE ROW INTO THE HIGH HALFWORD
         ICM   R15,X'3',COL        GET THE COL INTO THE LOW HALFWORD
         LTR   R15,R15             ARE BOTH THE ROW AND COL ZERO?
         BZ    CALLFB              IF SO, DON'T CHECK FOR ASCENDING
*                                  ORDER
         SPACE
         CH    R2,ROW              COMPARE THE LAST ROW TO THIS ONE
         BH    OUTOFORD            IF NO GOOD, QUIT
         BL    ORDOK               IF LOW, OK
         SPACE
         CH    R3,COL              IF THE ROWS WERE EQUAL, TRY THE COLS
         BH    OUTOFORD            IF NO GOOD, QUIT
         SPACE
ORDOK    DS    0H
         LH    R2,ROW              THIS IS NOW THE LAST ROW USED
         LH    R3,COL              AND THIS IS THE LAST COL
         SPACE
CALLFB   DS    0H
         CALL  FLDBLD,((R5),(R9),(R8)),VL
         SPACE
         LTR   R15,R15             DID THE FIELD BUILD WORK?
         BZ    BUMP1               IF SO, GO TO THE NEXT FIELD
         EJECT
***********************************************************************
*                                                                     *
* FLDBLD DETECTED AN ERROR.  THE PLI RC PARM AND THE FIRST HALF OF    *
* THE PL/I REASON PARM ARE SET.  SET THE SECOND HALF TO THE ARRAY     *
* ELEMENT NUMBER.                                                     *
*                                                                     *
***********************************************************************
         SPACE
SETENUM  DS    0H
         SR    R7,R4                GET THE ELEMENT OFFSET
         L     R15,PLISTR           GO TO THE STRUCTURE DESCRIPTOR
         L     R15,4(R15)
         USING DESCRIPT,R15         OVERLAY THE DSECT
         SPACE
         AH    R7,ROWLB             AND ADD IN THE LOWER BOUND
         DROP  R15
         SPACE
         PLIREA R15                 POINT TO THE REASON PARM
         STH   R7,2(R15)            AND INSERT THE STRUCTURE NUMBER
         B     RETURN
         SPACE
OUTOFORD DS    0H
         PLIRCSET 8,R14,R15         SET PLI RC=8
         SPACE
         PLIREA R14                 POINT THE RHE REASON PARM
         LA    R15,REASON7          SHOW REASON 7
         STH   R15,0(R14)           AND SAVE IT
         B     SETENUM              AND GO SET THE ELEMENT NUMBER
         SPACE
***********************************************************************
*                                                                     *
* GO TO THE NEXT STRUCTURE                                            *
*                                                                     *
***********************************************************************
         SPACE
BUMP1    DS    0H
         LR    R9,R0                SAVE THE NEW BUFFER ADDRESS
         LA    R5,0(R5,R6)          POINT TO THE NEXT STRUCTURE
         LA    R8,RCARRLEN(R8)      POINT TO THE NNEXT RC ELEMENT
         BCT   R4,FILLLOOP          AND GO BACK FOR MORE
         DROP  R5
         EJECT
***********************************************************************
*                                                                     *
* ALL THE STRUCTURES ARE DONE.  BUILD A DUMMY TRAILER RC ELEMENT WITH *
* -1 FOR THE SCR ADDRESS.                                             *
*                                                                     *
***********************************************************************
         SPACE
         SLR   R15,R15             GET A ZERO
         BCTR  R15,0               GET A -1
         ST    R15,4(R8)           FILL THE SCR BEGIN AND END WITH
*                                  BINARY 1'S
         SPACE 2
***********************************************************************
*                                                                     *
* DETERMINE WHETHER OR NOT TO BUILD THE PROTECT SCREEN ELEMENT AS THE *
* LAST FIELD ON THE SCREEN.                                           *
*                                                                     *
* THERE ARE THREE CRITERIA FOR NOT BUILDING THIS FIELD.               *
* 1.   THE 4TH BIT IN THE WRITE CONTROL OPTIONS IS SET                *
* 2.   THE COMMAND IS EAU OR THE NUM VALUE WAS -1 (NO BUFFER OUTPUT). *
* 3.   WE ARE WITHIN 2 BYTES OF THE END OF THE SCREEN                 *
*                                                                     *
*      REGISTER USAGE:                                                *
*              R7  -  NUMBER OF ELEMENTS IN THE ARRAY                 *
*              R8  -> NEXT ROW COUMN ARRAY ELEMENT TO BE USED         *
*              R9  -> NEXT POSITION IN THE BUFFER TO BE FILLED        *
*              R10 -  BASE FOR DATA AREA                              *
*              R11 -> PLI PARM LIST, BASE FOR PLIPARMS                *
*              R12 -> PL/I TASK COMMUNICATION AREA, DO NOT MODIFY     *
*              R13 -  BASE FOR PROGRAM AND DSA                        *
*                                                                     *
***********************************************************************
         SPACE
         CLI   NOFIELDS,X'FF'      IS THIS A ERASE ALL UNPROTECTED
         BNE   PROTCHK             IF NOT, GO CHECK THE WCO FOR THE
*                                  DON'T PROTECT BIT
         L     R9,BUFSTART         POINT TO THE START OF THE BUFFER
         LA    R9,2(R9)            TRANSMIT ONLY THE ESCAPE & CMD
         B     DOTPUT              GO DO THE OUTPUT
         SPACE
PROTCHK  DS    0H
         L     R14,PLIWCO          POINT TO THE WCO L/D
         L     R14,0(R14)          POINT TO THE WCO
         TM    0(R14),X'10'        IS THE DON'T PROTECT BIT ON?
         BO    DOTPUT              IF SO, GO DO THE TPUT
         SPACE
         S     R8,=A(RCARRLEN)     BACK UP 1 RC ELEMENT
         LA    R15,SCREND-RCARRAY(R8)  POINT TO THE LAST SCREEN ADDR
         SCRDISP R14,(R15)         CONVERT THE LAST SCR POS TO DISP
         SPACE
         LA    R14,2(R14)          ADD THE TWO FOR THE CHARS USED
         CH    R14,SCREENSZ        COMPARE TO THE MAX DISPLACEMENT
         BNL   DOTPUT              IF TOO CLOSE, SKIP THE TRAILER
         SPACE
         MVI   0(R9),SF            LOAD THE FINAL START FIELD
         MVI   1(R9),X'6C'         LOAD THE ATTIBURE CHARACTER
         LA    R9,2(R9)            AND BUMP THE BUFFER ADDRESS
         EJECT
***********************************************************************
*                                                                     *
* DO THE TPUT.  CALCULATE THE LENGTH OF THE SCREEN TO TPUT FROM THE   *
* START OF THE SCREEN AND THE CURRENT BUFFER ADDRESS.  IF THE TPUT    *
* FAILS RETURN RC=16 REA=(0,0)                                        *
*                                                                     *
*      REGISTER USAGE:                                                *
*              R2  -> START OF THE OUTPUT BUFFER                      *
*              R7  -  NUMBER OF ELEMENTS IN THE ARRAY                 *
*              R8  -> NEXT ROW COUMN ARRAY ELEMENT TO BE USED         *
*              R9  -> NEXT POSITION IN THE BUFFER TO BE FILLED        *
*              R10 -  BASE FOR DATA AREA                              *
*              R11 -> PLI PARM LIST, BASE FOR PLIPARMS                *
*              R12 -> PL/I TASK COMMUNICATION AREA, DO NOT MODIFY     *
*              R13 -  BASE FOR PROGRAM AND DSA                        *
*                                                                     *
* NOTE:                                                               *
* REGISTER R9 IS USED AT THIS POINT TO CALC THE LENGTH OF THE TPUT    *
*                                                                     *
***********************************************************************
        SPACE
DOTPUT  DS    0H
        L     R2,BUFSTART         LOAD THE BUFFER ADDRESS
        SR    R9,R2               CALC THE BUFFER LENGTH
        SPACE
        TPUT  (R2),(R9),FULLSCR,,,BREAKIN
        SPACE
        LTR   R15,R15             DID THE TPUT WORK?
        BZ    CHECKGET            IF SO, GO SEE IF A TGET IS NEEDED
        SPACE
        SLL   R15,16              SHIFT THE TPUT RC TO THE HIGH ORDER
*                                 HALFWORD
        SPACE
        PLIREA R14                POINT TO THE REASON PARM
        ST    R15,0(R14)          SAVE THE TPUT RC
        SPACE
        PLIRCSET 16,R14,R15       SET THE PLI RC=16
        B     RETURN
        SPACE 2
***********************************************************************
*                                                                     *
* CHECK THE NOREAD FLAG TO SEE IF A READ IS REQUIRED.  IF NOT SET THE *
* RC=-1 AND RETURN.                                                   *
*                                                                     *
***********************************************************************
        SPACE
CHECKGET DS    0H
         CLI   NOREAD,X'FF'        IS THE NOREAD FLAG SET
         BNE   DOTGET              IF NOT, DO THE TGET
         SPACE
         L     R14,PLIAID          POINT TO THE PL/I AID PARM
         LH    R15,=H'-1'          SHOW RC = -1
         STH   R15,0(R14)          AND SAVE IT
         B     RETURN              GO BACK TO PL/I
         EJECT
***********************************************************************
*                                                                     *
* CALCULATE THE MAX LENGTH OF THE INPUT BUFFER FROM THE START AND END *
* ADDRESSES.  THEN DO THE TGET AND CHECK THE RC.  IF IT FAILED RETURN *
* RC=20 AND REASON=(TGETRC,0).                                        *
*                                                                     *
*      REGISTER USAGE:                                                *
*              R2  -> INPUT BUFFER                                    *
*              R9  -> USED TO CALCULATE THE MAX LENGTH OF THE INPUT   *
*                     BUFFER ALLOWED                                  *
*              R10 -> DATA AREA                                       *
*              R11 -> PL/I PARM LIST                                  *
*              R12 -> PL/I TASK COMMUNICATIONS AREA (DO NOT MODIFY)   *
*              R13 -  BASE FOR PROGRAM                                *
*              R15 -  WORK                                            *
*                                                                     *
***********************************************************************
         SPACE
DOTGET   DS    0H
         L     R9,BUFEND           POINT TO THE END OF THE BUFFER
         S     R9,BUFSTART         SUBTRACT THE START TO GET THE LENGTH
         SPACE
         CNOP  0,4
         TGET  (R2),(R9),ASIS      DO THE TGET
         SPACE
         LTR   R15,R15             DID THE TGET WORK?
         BZ    PARSE               IF SO, GO PROCESS IT
         SPACE
         PLIREA R14                POINT TO THE PLI REASON PARM
         SLL   R15,16              MOVE THE TGET RC TO THE TOP HALFWORD
         ST    R15,0(R14)          AND SAVE THE REASON CODE
         SPACE
         PLIRCSET 20,R14,R15       SET THE PLI RC TO 20
         B     RETURN
         EJECT
***********************************************************************
*                                                                     *
* GET AND EXTRACT THE AID CODE AND CURSOR POSITION AND TPUT THEM INTO *
* THEIR PARMS.  THE AID IS TRANSLATED TO THE CODE USING A TABLE.  THE *
* CURSOR POS IS RETURNED IN REGISTER R0 BY ROUTINE SCRTORC.  A        *
* NON-ZERO RETURN CODE MMEANS THE ADDR COULD NOT BE CONVERTED.  IN    *
* THIS CASE RETURN RC=12 AND REASON=(11,RAW SCREEN ADDRESS)           *
*                                                                     *
*      REGISTER USAGE:                                                *
*              R0  -  HIGH HALFWORD = ROW FOR THE CURSOR              *
*              R0  -  LOW  HALFWORD = COL FOR THE CURSOR              *
*              R7  -  LENGTH OF THE TGET LEFT TO PROCESS              *
*              R8  -> ROW COLUMN ARRAY ELEMENT UNDER INSPECTION       *
*              R9  -> CURRENT TGET BUFFER POSITION                    *
*              R10 -> DATA AREA, BASE REGSITER FOR DATA               *
*              R11 -> PLI PARM LIST                                   *
*              R12 -> PLI TASK COMMUNICATIONS AREA, DO NOT MODIFY     *
*              R13 -  BASE FOR PROGRAM                                *
*              R14 -  WORK                                            *
*              R15 -  WORK                                            *
*                                                                     *
***********************************************************************
         SPACE
PARSE    DS    0H
         LR    R7,R1               SAVE THE TGET LENGTH
         L     R9,BUFSTART         GET THE START OF THE BUFFER
         L     R8,RCSTART          GET THE FIRST RC ARRAY ELEMENT
         SPACE
         TR    0(1,R9),AIDTRT      TRANSLATE THE AID CHARACTER
         SLR   R15,R15             CLEAR THE REGISTER
         IC    R15,0(R9)           AND INSERT THE ID PARM
         SPACE
         L     R14,PLIAID          POINT TO THE AID PARM
         STH   R15,0(R14)          AND SAVE THE AID
         SPACE
         LA    R2,1(R9)            POINT R2 TO THE SCR ADDR
         SPACE
         CALL  SCRTORC,((R2)),VL   CONVERT TO ROW COL FORMAT
         SPACE
         LTR   R15,R15             DID THE CONVERSION WORK
         BZ    GOTSC               IF SO GO SAVE IT.
         SPACE 2
***********************************************************************
*                                                                     *
* BAD SCR ADDR                                                        *
*                                                                     *
***********************************************************************
         SPACE
         PLIRCSET 12,R14,R15       SET THE PL/I RC TO 12
         SPACE
         PLIREA R14                POINT TO THE REASON
         MVC   2(2,R14),0(R2)      MOVE THE SCREEN ADDRESS
         LA    R15,REASON11        SHOW REASON CODE 11
         STH   R15,0(R14)          AND SAVE IT
         B     RETURN              AND QUIT
         EJECT
***********************************************************************
*                                                                     *
* SAVE THE SCREEN ADDR FORM SCRTORC.                                  *
*                                                                     *
***********************************************************************
         SPACE
GOTSC    DS    0H
         L     R14,PLICPOS         POINT TO THE CPOS LOCATOR
         L     R14,0(R14)          POINT TO THE CPOS PARM
         ST    R0,0(R14)           AND SAVE THE PARM
         SPACE 2
***********************************************************************
*                                                                     *
* CHECK THE AID CODE TO SEE IF THE KEY PRESSED WAS A A KEY.  IN THIS  *
* CASE A SHORT READ WAS PERFORMED ANND THERE ARE NO MORE FIELDS.      *
*                                                                     *
***********************************************************************
         SPACE
         L     R14,PLIAID          POINT TO THE AID PARM
         LH    R14,0(R14)          GET THE AID CODE
         CH    R14,=H'25'          WAS A SHORT READ PERFORMED?
         BH    RETURN              IF SO, WE ARE DONE
         SPACE 2
***********************************************************************
*                                                                     *
* MOVE THE BUFFER PAST THE AID AND CPOS AND DECREMENT THE REMAINING   *
* BUFFER LENGTH TO PROCESS.                                           *
*                                                                     *
***********************************************************************
         SPACE
         LA    R9,3(R9)            BUMP THE BUFFER ADDRESS
         SH    R7,=H'3'            AND DECREMENT THE LENGTH
         BZ    RETURN              RETURN IF THERE IS NO DATA
         EJECT
***********************************************************************
*                                                                     *
* THE CURRENT BUFFER ADDR POINTS TO A SBA.  FIND THE NEXT SBA OR THE  *
* END OF THE STRING.                                                  *
*              R5  -  WORK, USED FOR THE LENGTH OF THE STRING PAST    *
*                     THE POINT BEING SCANNED.                        *
*              R6  -> PART OF THE BUFFER BEING SCANNNED FOR AN SBA.   *
*              R7  -  LENGTH OF THE TGET LEFT TO PROCESS              *
*              R8  -> ROW COLUMN ARRAY ELEMENT UNDER INSPECTION       *
*              R9  -> CURRENT TGET BUFFER POSITION                    *
*              R10 -> DATA AREA, BASE REGSITER FOR DATA               *
*              R11 -> PLI PARM LIST                                   *
*              R12 -> PLI TASK COMMUNICATIONS AREA, DO NOT MODIFY     *
*              R13 -  BASE FOR PROGRAM                                *
*                                                                     *
***********************************************************************
         SPACE
GETFIELD DS    0H
         LR    R5,R7               SET THE REMAINING LENGTH TO PROCESS
         SH    R5,=H'1'            REMOVE THE LENGTH OF THE SBA
         LA    R6,1(R9)            POINT TO THE FIRST BYTE IN THIS
*                                  FIELD.
         SPACE
NEXTSBA  DS    0H
         CH    R5,=H'256'          ARE THE 256 BYTES LEFT?
         BNH   SHRTSCAN            IF 256 OR LESS, GO PROCESS WITH AN
*                                  EXECUTE INSTRUCTION
         SPACE
         TRT   0(256,R6),SBATRT    SCAN 256 BYTES FOR AN SBA
         BNZ   FOUNDSBA            IF FOUND, GO EXTRACT THIS FIELD
         SPACE
         CLI   UPPER,X'FF'        WAS UPPER CASE TRANSLATION REQUESTED?
         BNE   NOUPPER1           IF NOT, SKIP THE TRANSLATION
         SPACE
         TR    0(256,R6),CAPITAL  TRANSLATE ALPHAS TO UPPER CASE
         SPACE
NOUPPER1 DS    0H
         LA    R6,256(R6)         GO TO THE NEXT 256 BYTES
         SH    R5,=H'256'         AND CUT DOWN THE LENGTH BY THE SAME
         B     NEXTSBA            AND TRY AGAIN
         SPACE
SHRTSCAN DS    0H
         BCTR  R5,0               SUB 1 FOR THE TRT
         EX    R5,SBACHK          SCAN TO THE END OF THE STRING
         BNZ   FOUNDSBA           IF AND SBA FOUND, GO PROCESS
         SPACE
         LA    R1,1(R5,R6)        OTHERWISE MARK THE END OF THE STRING
*                                 AT THE END OF THE BUFFER.
         EJECT
***********************************************************************
*                                                                     *
* AT THIS POINT THE START AND END OF THE FIELD ARE KNOWN.  CALCULATE  *
* THE LENGTH OF THE FIELD AND CALL INSFIELD TO LOAD THE FIELD INTO    *
* THE APPROPRIATE STRUCTURE.  THE PARMS TO INSFIELD ARE THE FIELD     *
* LENGTH, THE FIELD START, AND THE CURRENT RC ARRAY ELEMENT.  UPON    *
* RETURN, R15 WILL CONTAIN A RETURN CODE WHICH TELLS WHETHER DATA WAS *
* INSERTED.  IF R15 IS NON-ZERO, QUIT.  THE RC AND REASON HAVE BEEN   *
* INSERTED BY INSFIELD.  IF DATA TRUNCATION OCCURS, THE RC AND REASON *
* WILL BE SET BY INSFIELD BUT A ZERO RC WILL BE RETURNED SIGNALING    *
* THAT PROCESSING MAY CONTINUE.                                       *
*              R0  -> NEW CURRENT RC ARRAY ELEMENT FROM INSFIELD      *
*              R1  -> END OF THE FIELD IN THE TGET BUFFER             *
*              R2  -  HOLD AREA FOR THE START OF THE NEXT FIELD       *
*              R6  -  LENGTH OF THE FIELD BEING PROCESSED             *
*              R7  -  LENGTH OF THE TGET LEFT TO PROCESS              *
*              R8  -> ROW COLUMN ARRAY ELEMENT UNDER INSPECTION       *
*              R9  -> CURRENT TGET BUFFER POSITION                    *
*              R10 -> DATA AREA, BASE REGSITER FOR DATA               *
*              R11 -> PLI PARM LIST                                   *
*              R12 -> PLI TASK COMMUNICATIONS AREA, DO NOT MODIFY     *
*              R13 -  BASE FOR PROGRAM                                *
*                                                                     *
***********************************************************************
         SPACE
FOUNDSBA DS    0H
         LA    R1,0(R1)           CLEAR HIGH BYTE OF END
         LR    R2,R1              SAVE THE START ADDR OF THE NEXT FIELD
         SPACE
         CLI   UPPER,X'FF'        WAS UPPER CASE TRANSLATION REQURESTED
         BNE   NOUPPER2           IF NOT SKIP THE TRANSLATION.
         SPACE
         SR    R1,R6               GET THE LENGTH OF THE LAST FIELD
         BCTR  R1,0                SUB 1 FOR THE EXECUTE
         EX    R1,TRCAPS           AND TRANSLATE
         LR    R1,R2               RESTORE REGISTER R1 AS IT WAS
         SPACE
NOUPPER2 DS    0H
         SR    R1,R9              CALC THE LENGTH OF THE FIELD
         LR    R6,R1              SAVE THE LENGTH
         CALL  INSFIELD,((R6),(R9),(R8)),VL
         SPACE
         LTR   R15,R15            DID INSFIELD SUCCEED?
         BNZ   RETURN             IF NOT, QUIT
         EJECT
***********************************************************************
*                                                                     *
* THE FIELD INSERTION WORKED, GO ON TO THE NEXT FIELD OR QUIT IF WE   *
* ARE DONE.                                                           *
*                                                                     *
*      REGISTER USAGE:                                                *
*              R7  -  LENGTH OF THE TGET LEFT TO PROCESS              *
*              R8  -> ROW COLUMN ARRAY ELEMENT UNDER INSPECTION       *
*              R9  -> CURRENT TGET BUFFER POSITION                    *
*              R10 -> DATA AREA, BASE REGSITER FOR DATA               *
*              R11 -> PLI PARM LIST                                   *
*              R12 -> PLI TASK COMMUNICATIONS AREA, DO NOT MODIFY     *
*              R13 -  BASE FOR PROGRAM                                *
*                                                                     *
***********************************************************************
         SPACE
         SR    R7,R6              SUB THE LENGTH OF THIS FIELD
         BNP   RETURN             IF NOT POSITIVE, WE ARE DONE.
         SPACE
         LR    R9,R2              OTHERWISE GO TO THE NEXT FIELD,
         LR    R8,R0              SET UP THE NEW RC ADDRESS,
         B     GETFIELD           AND TRY AGAIN.
         EJECT
***********************************************************************
*                                                                     *
* RETURN IS THE EXIT USED AFTER THE BUFFER USED FOR BUILDING THE      *
* SCREEN HAS BEEN GOTTEN. RETURN2 IS USED BEFORE THE BUFFER IS        *
* GOTTEN.  FREE THE BUFFER AREA AND GO BACK TO PL/I.                  *
*                                                                     *
***********************************************************************
         SPACE
RETURN   DS    0H
         L     R2,BUFLEN
         L     R3,RCSTART
         FREEMAIN RU,LV=(R2),A=(R3)
         SPACE
RETURN2  DS    0H
         RETRN R,SPIE=NO
         SPACE
         LTORG
         SPACE
         DROP  R10,R11,R13
         EJECT
***********************************************************************
*                                                                     *
* SEGMENT NAME:                                                       *
*                                                                     *
*    INSFIELD -- INSERT FIELD                                         *
*                                                                     *
* INPUTS (*TO FUNCTIONS):                                             *
*                                                                     *
*    FLEN -- FIELD LENGTH (*1)                                        *
*       THIS IS THE LENGTH OF THE FIELD TO BE INSERTED.               *
*       VALUES: 4 BYTE FIELD.  THIS PARM IS THE FIRST ELEMENT IN THE  *
*                     PARM LIST AS OPPOSED TO BEING POINTED TO BY THE *
*                     FIRST ELEMENT IN THE PARMLIST.                  *
*                                                                     *
*    FLD -- THE FIELD (*1,2)                                          *
*       THIS IS THE FIELD TO BE INSERTED INTO THE STRUCTURE OF FIELD  *
*       DEFS.                                                         *
*                                                                     *
*    RCARRAY -- ROW COLUMN ARRAY (*1,2)                               *
*       THIS IS THE NEXT ELEMENT IN THE ROW COLUMN ARRAY UNDER        *
*       INSPECTION. THIS ROUTINE RETURNS THE ADDR OF THE NEXT ELEMENT *
*       TO BE LOOKED AT AFTER DETERMINING WHERE TO PUT THE FIELD      *
*       BEING PROCESSED.                                              *
*                                                                     *
* FUNCTIONS:                                                          *
*                                                                     *
*    1. LOAD THE PARM LIST AND OVERLAY THE DSECTS.                    *
*                                                                     *
*    2. SEARCH THE RC ARRAY FOR THE ELEMENT WHICH POINTS TO THE       *
*       STRUCTURE ELEMENT WHICH IS TO BE FILLED AND HAS THE SAME      *
*       SCREEN START ADDR AS THIS FIELD.                              *
*                                                                     *
*    3. MOVE THE FIELD TEXT INTO THE STRUCTURE AND RETURN THE ADDR OF *
*       THE FOLLOWING RC ARRAY ELEMENT.                               *
*                                                                     *
***********************************************************************
         SPACE
INSFIELD CSECT
         ENTER SPIE=NO
         SPACE
         LM   R7,R9,0(R1)         LOAD THE PARM LIST
         USING RCARRAY,R9         AND OVERLAY THE DSECT FOR RC ARRAY
         SPACE
         L    R10,=V(DATAAREA)    ESTABLISH ADDRESSABILTY TO THE DATA
         USING DATAAREA,R10
         SPACE
         L    R11,PARMADDR        GET THE PL/I PARM ADDR
         USING PLIPARMS,R11       AND OVERLAY THE DESCRIPTIONS
         EJECT
***********************************************************************
*                                                                     *
* THE RC ARRAY IS SEARCHED AS FOLLOWS:                                *
* THE RC ARRAY IS IN ASCENDING SCREEN ADDRESS ORDER AND IS SEARCHED   *
* SEQUENTIALLY FOR A SCREEN ADDRESS MATCHING THE ONE IN THE TGET      *
* BUFFER.  IF WE HIT A RC ARRAY SCREEN ADDRESS WHICH IS LARGER THAN   *
* THE ONE IN THE TGET BUFFER, THEN THERE IS NOWHERE TO PUT THE FIELD. *
* IN THIS CASE WE SET THE PLI RC =28 AND THE REASON CODE EQUAL TO THE *
* ROW AND COLUMN OF THE FIELD WHICH CANNOT BE PLACED.  IF A FIELD IS  *
* FOUND, SUCH THAT THE FIELD STARTS BEFORE THE TGET SCREEN ADDRESS    *
* AND ENDS PAST THE TGET SCREEN ADDRESS, THEN THIS RC ARRAY ELEMENT   *
* IS CHOSEN.                                                          *
*                                                                     *
* IF A PLACE IS FOUND TO PUT THE DATA, (MATCHING SCREEN ADDRS),       *
* INSERT THE DATA INTO THE FIELD DEFINITION STRUCTURE.  IF THE DATA   *
* IS TOO LONG, TRUNCATE TO THE MAX LENGTH AND SET THE PLI RC=12 AND   *
* THE REASON=10,STURCURE ELEMENT NUMBER.                              *
*                                                                     *
*      REGISTER USAGE:                                                *
*              R6  -  DISPLACEMENT INTO THE SCREEN FOR FIELD IN THE   *
*                     TGET BUFFER                                     *
*              R7  -  LENGTH OF THE TGET FIELD                        *
*              R8  -> FIRST BYTE OF THE TGET FIELD                    *
*              R9  -> CURRENT RC ELEMENT                              *
*              R10 -> DATA AREA                                       *
*              R11 -> PL/I PARM LIST                                  *
*              R12 -  PL/I TASK COMMUNICATION AREA (DO NOT MODIFY)    *
*              R13 -  BASE FOR CSECT AND DSA AREA                     *
*              R14 -  WORK                                            *
*              R15 -  DISPLACEMENT INTO THE SCREEN FOR THE FIELD      *
*                     START AND END ADDRS DESCRIBED BY THE RCARRAY.   *
*                                                                     *
***********************************************************************
         SPACE
         CLC   SCRADDR(2),=H'-1'   IF THIS THE RC TRAILER ELEMENT
         BE    ENDORC              IF SO, QUIT
         SPACE
         LA    R14,1(R8)           POINT TO THE SCREEN ADDRESS
         SCRDISP R6,(R14)          CONVERT TO A SCREEN ADDRESS
         SPACE
RCLOOK   DS    0H
         CLC   SCRADDR(2),1(R8)    COMPARE SCREEN ADDR TO THE ONE IN
*                                  THE TGET BUFFER.
         BE    USESCR              IF FOUND, GO PROCESS THE FIELD
         SPACE
         SCRDISP R15,SCRADDR       GET THE SCREEN DISPLACEMENT
         CR    R15,R6              COMPARE THE RC SCREEN ADDR OFFSET
*                                  TO THE ONE IN THE TGET BUFFER
         BH    ENDORC              IF WE ARE HIGH, QUIT
         SPACE
         SCRDISP R15,SCREND        GET THE SCREEN DISPLACEMENT FOR THE
*                                  SCREEN END.
         CR    R15,R6              COMPARE THE RC SCREEN END OFFSET
*                                  TO THE ONE IN THE TGET BUFFER TO SEE
*                                  IF THIS FIELD STARTS INSIDE THE
*                                  FIELD DESCRIBED BY THE RC ELEMENT?
         BH    USESCR              IF SO, USE THIS ADDRESS
         SPACE
         LA    R9,RCARRLEN(R9)     GO TO THE NEXT RC ARRAY ELEMENT
         CLC   SCRADDR(2),=H'-1'   IF THIS THE RC TRAILER ELEMENT
         BNE   RCLOOK              IF NOT, KEEP LOOKING
         EJECT
***********************************************************************
*                                                                     *
* CANNOT LOCATE THE ELEMENT TO PUT THIS FIELD IN.  SET THE PLI RC=28  *
* AND THE REASON TO THE ROW AND COLUMN.  THEN GO BACK RC=8.  USE      *
* SCRTORC TO CONVERT THE SCREEN ADDR.                                 *
*                                                                     *
*      REGISTER USAGE:                                                *
*              R0  -  ROW AND COLUMN FROM SCRTORC.  THE ROW IN THE    *
*                     HIGH ORDER TWO BYTES AND THE COL IN THE LOW     *
*                     ORDER TWO BYTES.                                *
*              R7  -  LENGTH OF THE TGET FIELD                        *
*              R8  -> FIRST BYTE OF THE TGET FIELD                    *
*              R9  -> CURRENT RC ELEMENT                              *
*              R10 -> DATA AREA                                       *
*              R11 -> PL/I PARM LIST                                  *
*              R12 -  PL/I TASK COMMUNICATION AREA (DO NOT MODIFY)    *
*              R13 -  BASE FOR CSECT AND DSA AREA                     *
*              R15 -  RETURN CODE FROM SCRTORC                        *
*                                                                     *
***********************************************************************
         SPACE
ENDORC   DS    0H
         PLIRCSET 28,R14,R15        SET THE PLI RC=28
         SPACE
         LA    R2,1(R8)             POINT TO THE SCREEN ADDRESS
         SPACE
         CALL  SCRTORC,((R2)),VL    GET THE ROW AND COLUMN
         SPACE
         LTR   R15,R15              DID IT WORK
         BZ    SAVERC               IF SO, SAVE THE ROW AND COL
         EJECT
***********************************************************************
*                                                                     *
* AT THIS POINT THINGS LOOK PRETTY GRIM.  WE CANNOT EVEN TURN THE SCR *
* ADDR INTO A RC ELEMENT.  ERROR RC=12, REASON=(11, RAW SCREEN        *
* ADDRESS)                                                            *
*                                                                     *
*      REGISTER USAGE:                                                *
*              R2  -> RAW SCREEN ADDRESS FROM THE TGET BUFFER         *
*              R7  -  LENGTH OF THE TGET FIELD                        *
*              R8  -> FIRST BYTE OF THE TGET FIELD                    *
*              R9  -> CURRENT RC ELEMENT                              *
*              R10 -> DATA AREA                                       *
*              R11 -> PL/I PARM LIST                                  *
*              R12 -  PL/I TASK COMMUNICATION AREA (DO NOT MODIFY)    *
*              R13 -  BASE FOR CSECT AND DSA AREA                     *
*                                                                     *
***********************************************************************
         SPACE
         PLIRCSET 12,R14,R15       SET THE PLI RC=12
         SPACE
         L        R14,PLIREA       POINT TO THE REASON PARM LOCATOR
         L        R14,0(R14)       POINT TO THE REASON PARM
         LA       R15,REASON11     SHOW REASON CODE 11
         STH      R15,0(R14)       AND SAVE THE REASON
         SPACE
         MVC      2(2,R14),0(R2)   MOVE THE RAW ADDRESS
         LA       R15,8            SHOW RETURN CODE 8
         B        RETURN15
         SPACE 2
***********************************************************************
*                                                                     *
* THE BAD SCR ADDRS WAS TRANSLATED TO ROW COL FORMAT.  PUT IT IN THE  *
* REASON.                                                             *
*                                                                     *
*      REGISTER USAGE:                                                *
*              R0  -  THE ROW AND COLUMN FOR THE TGET SCREEN ADDR     *
*              R7  -  LENGTH OF THE TGET FIELD                        *
*              R8  -> FIRST BYTE OF THE TGET FIELD                    *
*              R9  -> CURRENT RC ELEMENT                              *
*              R10 -> DATA AREA                                       *
*              R11 -> PL/I PARM LIST                                  *
*              R12 -  PL/I TASK COMMUNICATION AREA (DO NOT MODIFY)    *
*              R13 -  BASE FOR CSECT AND DSA AREA                     *
*                                                                     *
***********************************************************************
         SPACE
SAVERC   DS    0H
         L     R14,PLIREA           POINT TO THE REASON CODE LOCATOR
         L     R14,0(R14)           POINT TO THE REASON CODE
         ST    R0,0(R14)            SET THE REASON TO THE ROW AND COL
         SPACE
         LA    R15,8                SHOW RETURN CODE 8
         B     RETURN15
         EJECT
***********************************************************************
*                                                                     *
* THE TARGET STRUCTURE HAS BEEN FOUND.  R11 POINTS TO THE RC ELEMENT  *
* WE WANT.  TEST THE DATA FOR LENGTH.  IF THE DATA IS TOO LONG SET    *
* THE RC=12 AND REASON=(10,STRUCTURE ELEMENT #)                       *
*                                                                     *
***********************************************************************
         SPACE
USESCR   DS    0H
         L     R1,STRADDR           POINT TO THE STRUCTURE
         USING FIELDEFS,R1          AND OVERLAY THE SYMBOLIC DEFS
         SPACE
         SH    R7,=H'3'             SUBSTRACT THE LENGTH OF THE SBA
*                                   AND THE SCREEN ADDRESS.
         SPACE
         CH    R7,MAXDATA           CHECK THE DATA LENGTH
         BNH   LENOK                IF THE DATA WILL FIT, GO MOVE IT
         SPACE 2
***********************************************************************
*                                                                     *
* THE FIELD IS TOO LONG.  TRUNCATE TO THE MAX LENGTH ALLOWED BY USING *
* THE MAXDATA VALUE FOR THE LENGTH.  SET THE PLI RC=12 AND THE        *
* REASON=(10, STRUCTURE ELEMENT #).                                   *
*                                                                     *
*      REGISTER USAGE:                                                *
*              R1  -> FIELD DEFINITION STRUCTURE BEING FILLED         *
*              R7  -  LENGTH OF THE TGET FIELD                        *
*              R8  -> FIRST BYTE OF THE TGET FIELD                    *
*              R9  -> CURRENT RC ELEMENT                              *
*              R10 -> DATA AREA                                       *
*              R11 -> PL/I PARM LIST                                  *
*              R12 -  PL/I TASK COMMUNICATION AREA (DO NOT MODIFY)    *
*              R13 -  BASE FOR CSECT AND DSA AREA                     *
*                                                                     *
***********************************************************************
         SPACE
         LH    R7,MAXDATA           TRUNCATE THE FIELD
         SPACE
         PLIRCSET 12,R14,R15        SET THE PLI RC=12
         SPACE
         L     R14,PLIREA           POINT TO THE REASON CODE LOCATOR
         L     R14,0(R14)           POINT TO THE REASON CODE
         LA    R15,REASON10         SHOW REASON CODE 10
         STH   R15,0(R14)           SAVE THE REASON CODE
         EJECT
***********************************************************************
*                                                                     *
* CALCULATE THE ELEMENT NUMBER OF THE STRUCTURE ELEMENT               *
*                                                                     *
*      REGISTER USAGE:                                                *
*              R1  -> THE STRUCTURE                                   *
*              R2  -  WORK                                            *
*              R3  -  WORK                                            *
*              R7  -  LENGTH OF THE TGET FIELD                        *
*              R8  -> FIRST BYTE OF THE TGET FIELD                    *
*              R9  -> CURRENT RC ELEMENT                              *
*              R10 -> DATA AREA                                       *
*              R11 -> PL/I PARM LIST                                  *
*              R12 -  PL/I TASK COMMUNICATION AREA (DO NOT MODIFY)    *
*              R13 -  BASE FOR CSECT AND DSA AREA                     *
*              R14 -> THE REASON CODE PARM                            *
*                                                                     *
***********************************************************************
         SPACE
         LA    R3,0(R1)             GET THE STRUCTURE ADDRESS
         L     R2,PLISTR            GET THE STRUCTURE ARRAY LOCATOR
         L     R2,0(R2)             GET THE STRUCTURE ARRAY START
         LA    R2,0(R2)             MAKE SURE THE HIGH BYTE IS CLEAR
         SR    R3,R2                GET THE OFFSET OF THE STRUCTURE
         SPACE
         SLR   R2,R2                CLEAR R2 FOR THE DIVIDE
         D     R2,STRLEN            DIVIDE BY THE STRUCTURE LENGTH
         L     R2,PLISTR            POINT TO THE STRUCTURE LOCATOR
         L     R2,4(R2)             POINT TO THE STRUCTURE DESCRIPTOR
         USING DESCRIPT,R2          AND OVERLAY THE DSECT
         AH    R2,ROWLB             LOAD THE ROW LOW BOUND
         DROP  R2
         SPACE
         AR    R3,R2                AND ADD IN THE LOWER BOUND
         STH   R3,2(R14)            AND SAVE THE ARRAY NUMBER
         SPACE
         EJECT
***********************************************************************
*                                                                     *
* SET UP A MVCL TO MOVE THE DATA.                                     *
*              R1  -> STRUCTURE TO CONTAIN THE DATA                   *
*              R2  -> TARGET DATA ADDR                                *
*              R3  -  TARGET DATA LEN                                 *
*              R4  -> SOURCE DATA ADDR                                *
*              R5  -  SOURCE DATA LEN (= TARGET LEN)                  *
*              R7  -  LENGTH OF THE TGET FIELD                        *
*              R8  -> FIRST BYTE OF THE TGET FIELD                    *
*              R9  -> CURRENT RC ELEMENT                              *
*              R10 -> DATA AREA                                       *
*              R11 -> PL/I PARM LIST                                  *
*              R12 -  PL/I TASK COMMUNICATION AREA (DO NOT MODIFY)    *
*              R13 -  BASE FOR CSECT AND DSA AREA                     *
*                                                                     *
***********************************************************************
         SPACE
LENOK    DS  0H
         LA    R2,DATA             SET UP THE TARGET ADDR
         LR    R3,R7               SET UP THE TARGET LENGTH
         STH   R3,DATALEN          SAVE THE DATA LENGTH
         SPACE
         LA    R4,3(R8)            POINT TO THE TGET DATA
         LR    R5,R3               GET THE SOURCE LENGTH
         MVCL  R2,R4               MOVE THE FIELD
         SPACE
         OI    FLAGS,FOUND         MARK THE FIELD AS FOUND
         DROP  R1
         SPACE
         SLR   R15,R15             SHOW ZERO RETURN CODE
         LA    R0,RCARRLEN(R9)     LOAD THE ADDR OF THE NEXT RC ELEMENT
         SPACE 2
***********************************************************************
*                                                                     *
* THE RETURN CODE IS IN R15. RETURN IT                                *
*                                                                     *
***********************************************************************
         SPACE
RETURN15 DS    0H
         RETRN R,SPIE=NO,RC=(15),SAVEREG=0
         DROP  R10,R11,R13
         SPACE
         LTORG
         EJECT
***********************************************************************
*                                                                     *
* SEGMENT NAME:                                                       *
*                                                                     *
*    FLDBLD -- FIELD BUILD                                            *
*                                                                     *
* INPUTS (*TO FUNCTIONS):                                             *
*                                                                     *
*    BUFADDR -- CURRENT BUFFER ADDRESS (*1,3)                         *
*       THIS IS THE ADDRESS WHERE THE FIELD IS TO START.  THIS        *
*       ROUTINE RETURNS THE NEXT BUFFER POSITION TO FILL IN REGISTER  *
*       R0.                                                           *
*                                                                     *
*    RCADDR -- ROW COLUMN ARRAY ELEMENT (*1)                          *
*       THIS IS THE NEXT ROW COLUMN ARRAY ELEMENT TO BE FILLED.       *
*                                                                     *
*    STRUCT -- FIELD DEFINITION STRUCTURE (*1,2)                      *
*       THIS IS THE ELEMENT IN THE ARRAY OF FIELD DEFINITIONS WHICH   *
*       IS TO BE USED TO DEFINE THIS FIELD.                           *
*                                                                     *
* FUNCTIONS:                                                          *
*                                                                     *
*    1. LOAD THE PARM LIST AND OVERLAY THE DSECTS                     *
*                                                                     *
*    2. DETERMINE WHICH ORDER IS SPECIFIED BY THIS FIELD DEFINITION.  *
*                                                                     *
*    3. MODIFY THE BUFFER, STARTING AT THE BUFADDR  TO THE            *
*       SPECIFICATIONS OF THE STRUCTURE DEFINITION PASSED AND ALSO    *
*       UPDATE THE ROW COLUMN ARRAY TO REFLECT THE FIELD.  IF THE     *
*       NOFIELDS FLAG IS SET (GLOBAL) OR THE INPUT ONLY FLAG IS SET   *
*       IN THE STRUCTURE ELEMENT, UNDO THE BUFFER CHANGES BY RESETING *
*       THE BUFFER ADDRESS TO WHERE IT WAS ORIGIONALLY.               *
*                                                                     *
*    4. ON ERROR SET THE ERROR CODE AND THE PLI RETURN CODE           *
*                                                                     *
* OUTPUTS (*FROM FUNCTIONS):                                          *
*                                                                     *
*    RC -- RETURN CODE (*2)                                           *
*       THIS RETURN CODE SHOWS WHETHER THE FIELD WAS INSERTED         *
*       SUCCESSFULLY.                                                 *
*       VALUES: 0  -  FIELD BUILT                                     *
*               4  -  FIELD NOT BUILD, RETURN AND REASON CODE SET.    *
*                     ELEMENT NUMBER IN THE REASON CODE MUST BE SET   *
*                     BY CALLING ROUTINE.                             *
*                                                                     *
*    BUFADDR -- CURRENT BUFFER ADDRESS (*3)                           *
*       THIS IS THE ADDRESS WHERE THE FIELD IS TO START.  THIS        *
*       ROUTINE RETURNS THE NEXT BUFFER POSITION TO FILL IN REGISTER  *
*       R0.                                                           *
*                                                                     *
*    RCADDR -- ROW COLUMN ARRAY ELEMENT (*3)                          *
*       THIS IS THE NEXT ROW COLUMN ARRAY ELEMENT TO BE FILLED.       *
*                                                                     *
***********************************************************************
         SPACE
FLDBLD   CSECT
         ENTER SPIE=NO
         EJECT
***********************************************************************
*                                                                     *
* LOAD THE PARMLIST, SET UP DATA ADDRESSABILITY, AND OVERLAY THE      *
* DSECTS.                                                             *
*                                                                     *
*      REGISTER USAGE:                                                *
*              R7  -> STRUCTURE FROM THE ARRAY OF STRUCTURES UNDER    *
*                     INSPECTION                                      *
*              R8  -> NEXT BUFFER ADDRESS TO FILL                     *
*              R9  -> ROW COL ELEMENT TO FILL                         *
*              R10 -> DATA AREA                                       *
*              R11 -> PLI PARM LIST                                   *
*              R12 -> PL/I TASK COMMUNICATION AREA (DO NOT MODIFY)    *
*              R13 -  BASE FOR PROGRAM                                *
*                                                                     *
***********************************************************************
         SPACE
         LM    R7,R9,0(R1)         LOAD THE PARM LIST
         LA    R9,0(R9)            TURN OFF HIGH BYTE IN ADDRESS
         USING FIELDEFS,R7         ADDRESS THE STRUCTURE
         USING RCARRAY,R9          ADDRESS THE ROW COL ARRAY ELEMENT
         SPACE
         L     R10,=V(DATAAREA)    POINT TO THE DATA AREA
         USING DATAAREA,R10        AND ESTABLISH ADDRESSABILITY
         SPACE
         L     R11,PARMADDR        POINT TO THE PL/I PARM LIST
         USING PLIPARMS,R11
         EJECT
***********************************************************************
*                                                                     *
* DETERMINE WHICH ORDER WAS SPECIFIED.  THE START FIELD ORDER, WHICH  *
* IS SPECIFIED BY A BLANK ORDER AND THE 'SBA' ORDER USE THE SAME      *
* CODE.  THE ONLY DIFFERENCE IS THAT THE SBA ORDER SKIPS PAST THE     *
* CODE WHERE THE START FIELD AND ATTRIBUTE BYTE ARE INSERTED INTO THE *
* BUFFER.                                                             *
*                                                                     *
*      REGISTER USAGE:                                                *
*              R7  -> STRUCTURE FROM THE ARRAY OF STRUCTURES UNDER    *
*                     INSPECTION                                      *
*              R8  -> NEXT BUFFER ADDRESS TO FILL                     *
*              R9  -> ROW COL ELEMENT TO FILL                         *
*              R10 -> DATA AREA                                       *
*              R11 -> PLI PARM LIST                                   *
*              R12 -> PL/I TASK COMMUNICATION AREA (DO NOT MODIFY)    *
*              R13 -  BASE FOR PROGRAM                                *
*                                                                     *
***********************************************************************
         SPACE
         CLI   ORDER,C' '          IS THIS A START FIELD?
         BE    ORDERSF
         SPACE
         CLC   ORDER(3),=CL3'SBA'  IS THIS A SET BUFFER ADDRESS?
         BE    ORDERSF
         SPACE
         CLC   ORDER(3),=CL3'PT'   IS THIS A PROGRAM TAB?
         BE    ORDERPT
         SPACE
         CLC   ORDER(3),=CL3'RA'   IS THIS REPEAT TO ADDRESS?
         BE    ORDERRA
         SPACE
         CLC   ORDER(3),=CL3'EUA'  IS THIS ERASE UNPROTECTED TO ADDR?
         BE    ORDEREUA
         SPACE
         CLC   ORDER(3),=XL3'000000' ACCEPT UNINITIALIZED FIELD AS SF
         BE    ORDERSF
         SPACE 2
***********************************************************************
*                                                                     *
* THE ORDER SPECIFIED IS UNKNOW, SET UP THE REASON CODE AND QUIT.     *
*                                                                     *
***********************************************************************
         SPACE
         LA    R1,REASON2         LOAD REASON CODE 2
         B     ERR8
         EJECT
***********************************************************************
*                                                                     *
* THIS CODE IS EXECUTED FOR A START FIELD ORDER.   IF THE RC IS ZERO  *
* CACLULATE IT.  IF NOT, USE THE VALUES GIVEN AND PASS THEM TO        *
* ROUTINE ROWCOL.  ROWCOL WILL HAVE SET THE PL/I RC AND REASON CODES  *
* IF THE CONVERSION FAILED.  IF THE CONVERSION WORKED, THE SCREEN     *
* ADDRESS WILL BE RETURNED IN REGISTER R0.                            *
*                                                                     *
*      REGISTER USAGE:                                                *
*              R0  -  SCREEN ADDR FROM ROWCOL                         *
*              R7  -> STRUCTURE FROM THE ARRAY OF STRUCTURES UNDER    *
*                     INSPECTION                                      *
*              R8  -> NEXT BUFFER ADDRESS TO FILL                     *
*              R9  -> ROW COL ELEMENT TO FILL                         *
*              R10 -> DATA AREA                                       *
*              R11 -> PLI PARM LIST                                   *
*              R12 -> PL/I TASK COMMUNICATION AREA (DO NOT MODIFY)    *
*              R13 -  BASE FOR PROGRAM                                *
*              R15 -  RETURN CODE FROM ROWCOL                         *
*                                                                     *
***********************************************************************
         SPACE
ORDERSF  DS    0H
         ICM   R15,X'C',ROW        PUT THE ROW IN THE TOP HALFWORD
         ICM   R15,X'3',COL        PUT THE COL IN THE LOW HALFWORD
         LTR   R15,R15             IS THE RESULT ZERO?
         BZ    CSBA1               IF SO, GO CALC THE START ADDR
         SPACE
SFCALLRC DS    0H
         ST    R15,WORKWORD        SAVE THE ROW AND COL
         CALL  ROWCOL,(WORKWORD,(R9))  CONNVER TO SCR ADDR
         SPACE
         LTR   R15,R15             WAS THE ROWCOL GOOD?
         BNZ   RET8                IF NOT, QUIT
         EJECT
***********************************************************************
*                                                                     *
* INSERT THE SBA AND SCREEN ADDRS AND THEN BUMP THE SCREEN ADDR BY 1. *
* THE BUMP BY 1 IS BECAUSE THE SCREEN ADDR RETURNED BY THE TGET IS    *
* THE ADDR PAST THE ATTRIBUTE CHARACTER.  BEFORE INSERTING DATA, MAKE *
* SRE THERE IS ENOUGH BUFFER LEFT.                                    *
*                                                                     *
*      REGISTER USAGE:                                                *
*              R0  -  SCREEN ADDR FROM ROWCOL                         *
*              R1  -  HOLD REG FOR ERROR REASON CODES                 *
*              R4  -  WORK                                            *
*              R7  -> STRUCTURE FROM THE ARRAY OF STRUCTURES UNDER    *
*                     INSPECTION                                      *
*              R8  -> NEXT BUFFER ADDRESS TO FILL                     *
*              R9  -> ROW COL ELEMENT TO FILL                         *
*              R10 -> DATA AREA                                       *
*              R11 -> PLI PARM LIST                                   *
*              R12 -> PL/I TASK COMMUNICATION AREA (DO NOT MODIFY)    *
*              R13 -  BASE FOR PROGRAM                                *
*              R15 -  WORK                                            *
*                                                                     *
***********************************************************************
         SPACE
         LA    R1,REASON6         LOAD THE NO SPACE IN BUFFFER CODE
         LA    R4,3(R8)           POINT TO THE NEW ADDR
         C     R4,BUFEND          IS THIS PAST THE END
         BH    ERR8               IF SO, QUIT
         SPACE
         MVI   0(R8),SBA          INSERT THE SBA INTO THE BUFFER
         STH   R0,1(R8)           INSERT THE SCREEN ADDRESS
         LA    R8,3(R8)           AND BUMP THE BUFFER ADDRESS
         SPACE
SFBUMP1  DS    0H
         STH   R0,WORKWORD        SET UP TO PASS THE SCR ADDRESS
         LA    R15,1              SET THE INCREMENT
         STH   R15,WORKWORD+2     SAVE THE DISPLACEMENT
         SPACE
         CALL  ADDRBUMP,(WORKWORD,WORKWORD+2)
         SPACE
         LA    R1,REASON12        PREPARE FOR ERROR
         LTR   R15,R15            DID THE BUMP WORK?
         BNZ   ERR8               IF NOT, QUT
         B     SFSFSET
         EJECT
***********************************************************************
*                                                                     *
* ROW 0 COL 0 WAS SPECIFIED.  IF THIS IS THE FIRST FIELD, (RC ARRAY   *
* START ADDR IS THIS RC ARRAY ELEMENT ADDR), THEN SET THE ROW AND COL *
* TO 1 AND GO BACK AND PROCESS AS IF THEY WERE SPECIFIED.  OTHERWISE  *
* BACKUP TO THE LAST RC ARRAY ELEMENT AND USE THE SCREEN END ADDRESS  *
* + 2 FIELD'S START.  THE INCREMENT IS TWO BECAUSE THE ADDR WHICH     *
* WILL BE RETURNED BY THE TGET IS 1 PAST THE ATTRIBUTE CHARACTER.     *
* NOTE THAT THE SET BUFFER ADDRESS COMMAND THE THE BUFFER ADDRESS ARE *
* NOT INSERTED BY THIS CODE.  THE PLACE WHERE THE FIELD WILL GO IS    *
* CALCULATED FOR THE ROW COLUMN ARRAY BUT THE FIELD IS ALLOWED TO     *
* START RIGHT AFTER THE END OF THE PREVIOUS FIELD.                    *
*                                                                     *
*      REGISTER USAGE:                                                *
*              R0  -  SCR ADDR FORM ROWCOL                            *
*              R1  -  HOLD AREA FOR ERROR REASON CODES                *
*              R7  -> STRUCTURE FROM THE ARRAY OF STRUCTURES UNDER    *
*                     INSPECTION                                      *
*              R8  -> NEXT BUFFER ADDRESS TO FILL                     *
*              R9  -> ROW COL ELEMENT TO FILL                         *
*              R10 -> DATA AREA                                       *
*              R11 -> PLI PARM LIST                                   *
*              R12 -> PL/I TASK COMMUNICATION AREA (DO NOT MODIFY)    *
*              R13 -  BASE FOR PROGRAM                                *
*              R14 -  WORK                                            *
*              R15 -  WORK, AND RETURN CODE FORM ADDRBUMP             *
*                                                                     *
***********************************************************************
         SPACE
CSBA1    DS    0H
         C    R9,RCSTART          IS THIS THE FIRST RC ARRAY ELEMENT
         BNE  SFBACKUP            IF NOT, GO CALC THE START ADR
         SPACE
         L    R15,=X'00010001'    SHOW ROW=1 COL=1
         B    SFCALLRC            AND GO HANDLE AS IF THEY WERE PASSED
         SPACE
SFBACKUP DS    0H
         LR    R14,R9             GET THE CURRENT RC ARRAY ELEMENT ADDR
         S     R14,=A(RCARRLEN)   BACK UP 1 ELEMENT
         LA    R2,SCREND-RCARRAY(R14)  POINT TO THE SCREEN END
         LA    R15,2              LOAD THE DISPLACEMENT
         STH   R15,WORKWORD       SET IT UP AS A PARM
         SPACE
         CALL  ADDRBUMP,((R2),WORKWORD)
         SPACE
         LA    R1,REASON12        SET UP FOR ERROR
         LTR   R15,R15            DID THE BUMP WORK?
         BNZ   ERR8               IF NOT, QUIT
         EJECT
***********************************************************************
*                                                                     *
* INSERT THE SCREEN ADDR IN THE RC ARRAY ELEMENT AND CALC THE SCREEN  *
* ADDRESS FOR THE END OF THIS FIELD. ALSO CLEAR THE STRUCTURE         *
* ELEMENT'S FOUND FLAG TO OFF.                                        *
*                                                                     *
*      REGISTER USAGE:                                                *
*              R0  -  START OF FIELD SCREEN ADDRESS                   *
*              R1  -  USED TO HOLD ERROR REASON CODES                 *
*              R2  -  WORK                                            *
*              R7  -> STRUCTURE FROM THE ARRAY OF STRUCTURES UNDER    *
*                     INSPECTION                                      *
*              R8  -> NEXT BUFFER ADDRESS TO FILL                     *
*              R9  -> ROW COL ELEMENT TO FILL                         *
*              R10 -> DATA AREA                                       *
*              R11 -> PLI PARM LIST                                   *
*              R12 -> PL/I TASK COMMUNICATION AREA (DO NOT MODIFY)    *
*              R13 -  BASE FOR PROGRAM                                *
*              R15 -  RTURN CODE FROM BUMP ADDR                       *
*                                                                     *
***********************************************************************
         SPACE
SFSFSET  DS    0H
         STH   R0,SCRADDR         SAVE THE SCREEN ADDR
         LH    R2,DATALEN         POINT TO THE LENGTH OF THE DATA
         BCTR  R2,0
         STH   R2,WORKWORD+2      SAVE THIS DISPLACEMENT
         STH   R0,WORKWORD        SAVE THE SCREEN ADDRESS
         SPACE
         CALL  ADDRBUMP,(WORKWORD,WORKWORD+2)
         SPACE
         LA    R1,REASON12        SET UP IN CASE OF ERROR
         LTR   R15,R15            DID THE BUMP WORK?
         BNZ   ERR8               IF NOT, QUIT
         SPACE
         STH   R0,SCREND          SAVE THE SCREEN ADDR OF THE LAST POS
         ST    R7,STRADDR         SAVE THE STRUC ADDR IN THE RC ARRAY
         SPACE
         NI    FLAGS,NOTFOUND     SHOW FIELD NO FOUND
         SPACE
         CLC   ORDER(3),=CL3'SBA' IS THIS A SET BUFFER ADDRESS?
         BE    INSERTC            IF SO, SKIP THE SF AND ATTR BYTE
         EJECT
         SPACE
***********************************************************************
*                                                                     *
* INSERT THE START FIELD INTO THE BUFFER AND CALCULATE THE ATTRIBUTE  *
* CHARACTER USING THE FIRST FIVE BITS OF THE FLAGS AS AN OFFSET INTO  *
* THE TABLE OF ATTRIBUTE CHARACTERS.  PUT THE ATTRIBUTE CHARACTER     *
* INTO THE BUFFER.                                                    *
*                                                                     *
*      REGISTER USAGE:                                                *
*              R1  -  USED TO HOLD ERROR REASON CODES                 *
*              R7  -> STRUCTURE FROM THE ARRAY OF STRUCTURES UNDER    *
*                     INSPECTION                                      *
*              R8  -> NEXT BUFFER ADDRESS TO FILL                     *
*              R9  -> ROW COL ELEMENT TO FILL                         *
*              R10 -> DATA AREA                                       *
*              R11 -> PLI PARM LIST                                   *
*              R12 -> PL/I TASK COMMUNICATION AREA (DO NOT MODIFY)    *
*              R13 -  BASE FOR PROGRAM                                *
*              R14 -  WORK                                            *
*              R15 - WORK                                             *
*                                                                     *
***********************************************************************
         SPACE
         MVI   0(R8),SF           INSERT THE START FIELD INTO THE BUFF
         SPACE
         SLR   R15,R15            CLEAR REGISTER BEFORE INSERTING
*                                 THE FLAGS
         IC    R15,FLAGS          GET THE FLAG BITE
         SRL   R15,3              SHIFT OUT THE BITS NOT USED
         SLR   R14,R14            CLEAR ANOTHER WORK REGISTER
         IC    R14,ATTRTBL(R15)   INSET THE ATTR BYTE
         STC   R14,1(R8)          AND PUT IT IN THE BUFFER
         LA    R8,2(R8)           BUMP THE BUFFER ADDRESS
         SPACE 2
***********************************************************************
*                                                                     *
* IF THE INSERT CURSOR FLAG IS SET, MASKE SURE THAT THIS IS THE FIRST *
* INSERT.  IF NOT, QUIT REASON CODE 5.  OTHERWISE INSERT THE CURSOR   *
* AND SET THE FLAG.                                                   *
*                                                                     *
***********************************************************************
         SPACE
INSERTC  DS    0H
         TM    FLAGS,CURSOR       DOES THE CURSOR GO HERE?
         BZ    INSDATA            IF NOT, GO INSERT THE DATA
         SPACE
         LA    R1,REASON5         SET UP THE MULT CURSOR REASON
         CLI   CURSESET,X'FF'     IS THE FLAG ALREADY SET?
         BE    ERR8               IF SO, QUIT
         SPACE
         LA   R1,REASON6          SET UP NO BUFFER LEFT REASON
         C    R8,BUFEND           ARE WE AT THE END OF THE BUFFER?
         BNL  ERR8                IF SO, QUIT
         SPACE
         MVI   0(R8),IC           INSERT THE CURSOR
         LA    R8,1(R8)           BUMP THE BUFFER ADDRESS
         MVI   CURSESET,X'FF'     AND SET THE FLAG
         EJECT
***********************************************************************
*                                                                     *
* IF THERE IS ANY DATA TO BE INSERTED. MAKE SURE THERE IS ROOM AND    *
* THEN MOVE IN THE DATA.  USE A MVCL TO MOVE THE DATA.                *
*                                                                     *
*      REGISTER USAGE:                                                *
*              R1  -  USED TO HOLD ERROR REASON CODES                 *
*              R2  -> TARGET OF MOVE (THE BUFFER)                     *
*              R3  -  LENGTH TO TARGET                                *
*              R4  -> SOURCE OF MOVE (THE STRUCTURE DATA AREA)        *
*              R5  -  LENGTH OF THE SOURCE (= TARGET LENGTH)          *
*              R7  -> STRUCTURE FROM THE ARRAY OF STRUCTURES UNDER    *
*                     INSPECTION                                      *
*              R8  -> NEXT BUFFER ADDRESS TO FILL                     *
*              R9  -> ROW COL ELEMENT TO FILL                         *
*              R10 -> DATA AREA                                       *
*              R11 -> PLI PARM LIST                                   *
*              R12 -> PL/I TASK COMMUNICATION AREA (DO NOT MODIFY)    *
*              R13 -  BASE FOR PROGRAM                                *
*              R14 -  WORK                                            *
*              R15 -  WORK                                            *
*                                                                     *
***********************************************************************
         SPACE
INSDATA  DS    0H
         SLR   R15,R15            SHOW ZERO RC IN CASE WE ARE DONE
         LH    R14,DATALEN        LOAD THE DATA LENGTH?
         LTR   R14,R14            IS THE LENGTH ZERO?
         BZ    NFTEST             IF SO, WE ARE DONE
         SPACE
         LA    R1,REASON6         LOAD NO ROOM IN BUFFER REASON
         LA    R15,0(R14,R8)      POINT TO THE END OF THE FIELD
         C     R15,BUFEND         COMPARE TO THE BUFFERS END
         BH    ERR8               IF TOO LONG, QUIT
         SPACE
         LR    R2,R8              LOAD TARGET ADDR
         LR    R3,R14             LOAD TARGET LENGTH
         LA    R4,DATA            LOAD SOURCE ADDR
         LR    R5,R3              LOAD SOURCE LENGTH
         SPACE
         MVCL  R2,R4
         SPACE
         LR    R8,R15             GET THE END ADDR FROM R15
         SLR   R15,R15            SHOW ZERO RETURN CODE
         B     NFTEST             AND GO BACK
         EJECT
***********************************************************************
*                                                                     *
* THIS CODE IS EXECUTED FOR A PROGRAM TAB (PT) ORDER.  FIRST MAKE     *
* SURE THE COMMAND IS A WRITE OR A WRITE NOREAD.  IF NOT, ERROR       *
* REASON=8.  IF THIS IS A NOFIELD OPERATION, WE ARE DONE SINCE AN RC  *
* ELEMENT FROM A PT CANNOT RETURN DATA.                               *
*                                                                     *
*      REGISTER USAGE:                                                *
*              R1  -  USED TO HOLD ERROR REASON CODES                 *
*              R7  -> STRUCTURE FROM THE ARRAY OF STRUCTURES UNDER    *
*                     INSPECTION                                      *
*              R8  -> NEXT BUFFER ADDRESS TO FILL                     *
*              R9  -> ROW COL ELEMENT TO FILL                         *
*              R10 -> DATA AREA                                       *
*              R11 -> PLI PARM LIST                                   *
*              R12 -> PL/I TASK COMMUNICATION AREA (DO NOT MODIFY)    *
*              R13 -  BASE FOR PROGRAM                                *
*              R15 -  WORK                                            *
*                                                                     *
***********************************************************************
         SPACE
ORDERPT  DS    0H
         NOFIELD SKIPCHK0
         SPACE
         LA    R1,REASON8         PT INVALID FOR NON-WRITE COMMAND
         L     R15,BUFSTART       POINT TO THE START OF THE BUFFER
         CLI   1(R15),X'F1'       IS THIS A WRITE COMMAND?
         BNE   ERR8               IF NOT, QUIT
         SPACE
SKIPCHK0 DS    0H
         XC    SCRADDR(4),SCRADDR ZERO THE RC ARRAY SCR ADDRS
         ST    R9,STRADDR         AND SAVE THE STRUCTURE ADDRESS
         SPACE
         SLR   R15,R15            SHOW ZERO RC IN CASE WE ARE DONE
         NOFIELD RET15            ARE WE DONE?
         SPACE
         LA    R1,REASON6         LOAD NO SPACE IN BUFFER REASON
         C     R8,BUFEND          ARE WE AT THE END?
         BNL   ERR8               IF SO, QUT
         SPACE
         MVI   0(R8),PT           INSERT THE PROGRAM TAB ORDER
         LA    R8,1(R8)           BUMP THE ADDRESS
         B     INSDATA            AND GO INSERT THE DATA
         EJECT
***********************************************************************
*                                                                     *
* THIS CODE IS EXECUTED FOR AN ERASE UPROTECTED TO ADDRESS ORDER.     *
* MAKE SURE THIS IS A WRITE OR A WRITE NOREAD COMMMAND.  IF NOT,      *
* ERROR REASON CODE 8.  IF OK, FILL IN THE RC ELEMENT.  IF THIS NOT A *
* NOFIELD TYPE OPERATION (NO BUFFER PROCESSING), THEN INSERT THE EUA  *
* ORDER AND THE ADDRESS.                                              *
*                                                                     *
*      REGISTER USAGE:                                                *
*              R0  -  SCR ADDR FROM ROWCOL AND ADDRBUMP               *
*              R1  -  HOLDS THE REASON CODES                          *
*              R7  -> STRUCTURE FROM THE ARRAY OF STRUCTURES UNDER    *
*                     INSPECTION                                      *
*              R8  -> NEXT BUFFER ADDRESS TO FILL                     *
*              R9  -> ROW COL ELEMENT TO FILL                         *
*              R10 -> DATA AREA                                       *
*              R11 -> PLI PARM LIST                                   *
*              R12 -> PL/I TASK COMMUNICATION AREA (DO NOT MODIFY)    *
*              R13 -  BASE FOR PROGRAM                                *
*              R14 - WORK                                             *
*              R15 - WORK                                             *
*                                                                     *
***********************************************************************
         SPACE
ORDEREUA DS    0H
         NOFIELD SKIPCHK1
         SPACE
         LA    R1,REASON8         LOAD EUA INVALID FOR NON-WRITE
         L     R14,BUFSTART       POINT TO THE START OF THE BUFFER
         CLI   1(R14),X'F1'       IS THIS A WRITE?
         BNE   ERR8               IF NOT, QUIT
         SPACE
SKIPCHK1 DS    0H
         C     R9,RCSTART         IS THS THE FIRST ORDER PROCESSED?
         BNE   EUACRC             IF NOT, GO CALC THE START ADDR
         SPACE
         L     R0,=X'00010001'    SHOW ROW1 COL1
         ST    R0,WORKWORD        SAVE THE ROW AND COL
         SPACE
         CALL  ROWCOL,(WORKWORD,(R9))
         SPACE
         B     EUASTORE           GO STORE THE ADDR, FOR SURE IT WORKED
         SPACE
EUACRC   DS    0H
         LR    R2,R9              GET THE RC ADDR
         S     R2,=A(RCARRLEN)    GO BACK 1 ELEMENT
         LA    R2,SCREND-RCARRAY(R2) POINT TO THE END OF THAT SCREEN
         SPACE
         LH    R0,0(R2)           LOOK AT THE END ADDR
         LA    R1,REASON14        LOAD BAD ORDER REASON
         LTR   R0,R0              WAS THE LAST THING A PT ORDER
         BZ    ERR8               IF SO, QUIT
         SPACE
         LA    R15,1              LOAD THE BUMP NUMBER FOR ADDRBUMP
         STH   R15,WORKWORD       AND SET IT UP AS A PARM
         SPACE
         CALL ADDRBUMP,((R2),WORKWORD)
         SPACE
         LA    R1,REASON12        SET UP FOR ERROR
         LTR   R15,R15            DID THE BUMP WORK?
         BNZ   ERR8
         SPACE
EUASTORE DS    0H
         STH   R0,SCRADDR         SAVE THE START ADDR
         SPACE
         ICM   R0,X'C',ROW        LOAD THE ROW IN THE HIGH HALFWORD
         ICM   R0,X'3',COL        LOAD THE COL IN THE LOW HALFWORD
         ST    R0,WORKWORD        SAVE THE ROW AND COL
         SPACE
         CALL  ROWCOL,(WORKWORD,(R9))
         SPACE
         LTR   R15,R15            DID THE CALC WORK?
         BNZ   RET8               IF NOT, QUIT?
         EJECT
***********************************************************************
*                                                                     *
* INSERT THE EUA ORDER AND THE TARGET ADDRESS WE MUST SUBTRACT 1 FROM *
* THE TRAILING ADDR TO PUT IN THE RCARRAY. THIS IS BECAUSE THE ERASE  *
* IS UP TO BUT NOT INCLUDING THE EUA ADDRESS.                         *
*                                                                     *
***********************************************************************
         SPACE
         LA    R1,REASON6         SET UP NO ROOM ADDR
         LA    R15,3(R8)          POINT TO NEW END ADDR
         C     R15,BUFEND         HAVE WE FALLEN OFF THE END?
         BH    ERR8               IF SO,QUIT
         SPACE
         MVI   0(R8),EUA          INSERT THE EUA ORDER INTO THE BUFFER
         STH   R0,1(R8)           SAVE THE ADDRESS
         LR    R8,R15             SAVE THE NEW BUFFER ADDRESS
         SPACE
         STH   R0,WORKWORD       PUT THE ADDR AWAY
         LH    R15,=H'-1'        GET THE DISPLACEMENT
         STH   R15,WORKWORD+2    AND SAVE IT
         SPACE
         CALL ADDRBUMP,(WORKWORD,WORKWORD+2)
         SPACE
         LA    R1,REASON12        LOAD REASON CODE FOR POSSIBLE ERROR
         LTR   R15,R15            DID THE BUMP WORK?
         BNZ   ERR8               IF NOT, QUIT
         SPACE
         STH   R0,SCREND          SAVE THE END ADDRESS
         ST    R7,STRADDR         SAVE THE STRUCTURE ADDRESS
         SPACE
         SLR   R15,R15            SHOW ZERO RC
         B     RET15              AND GO BACK
         EJECT
***********************************************************************
*                                                                     *
* THIS CODE IS EXECUTED FOR A REPEAT TO ADDRESS ORDER (RA). BUILD THE *
* RC ELEMENT MAKING SURE THE PRECEEDING ORDER WAS NOT PT. IF SO, QUIT *
* REASON 14. OK, FILL IN THE RC ELEMENT.  IF THIS NOT A NOFIELD TYPE  *
* OPERATION (NO BUFFER PROCESSING), THEN INSERT THE RA ORDER, THE     *
* ADDRESS, AND THE CHARACTER.                                         *
*                                                                     *
*      REGISTER USAGE:                                                *
*              R0  -  SCR ADDR FROM ROWCOL AND ADDRBUMP               *
*              R1  -  HOLDS THE REASON CODES                          *
*              R7  -> STRUCTURE FROM THE ARRAY OF STRUCTURES UNDER    *
*                     INSPECTION                                      *
*              R8  -> NEXT BUFFER ADDRESS TO FILL                     *
*              R9  -> ROW COL ELEMENT TO FILL                         *
*              R10 -> DATA AREA                                       *
*              R11 -> PLI PARM LIST                                   *
*              R12 -> PL/I TASK COMMUNICATION AREA (DO NOT MODIFY)    *
*              R13 -  BASE FOR PROGRAM                                *
*              R14 -  WORK                                            *
*              R15 -  WORK                                            *
*                                                                     *
***********************************************************************
         SPACE
ORDERRA  DS    0H
         C     R9,RCSTART         IS THS THE FIRST ORDER PROCESSED?
         BNE   RARC               IF NOT, GO CALC THE START ADDR
         SPACE
         L     R0,=X'00010001'    SHOW ROW1 COL1
         ST    R0,WORKWORD        SAVE THE ROW AND COL
         SPACE
         CALL  ROWCOL,(WORKWORD,(R9))
         SPACE
         B     RASTORE            GO STORE THE ADDR, FOR SURE IT WORKED
         EJECT
RARC     DS    0H
         LR    R2,R9              GET THE RC ADDR
         S     R2,=A(RCARRLEN)    GO BACK 1 ELEMENT
         LA    R2,SCREND-RCARRAY(R2) POINT TO THE END OF THAT SCREEN
         SPACE
         LH    R0,0(R2)           LOOK AT THE END ADDR
         LA    R1,REASON14        LOAD BAD ORDER REASON
         LTR   R0,R0              WAS THE LAST THING A PT ORDER
         BZ    ERR8               IF SO, QUIT
         SPACE
         LA    R15,1              LOAD THE BUMP NUMBER FOR ADDRBUMP
         STH   R15,WORKWORD       AND SET IT UP AS A PARM
         SPACE
         CALL ADDRBUMP,((R2),WORKWORD)
         SPACE
         LA    R1,REASON12        SET UP FOR ERROR
         LTR   R15,R15            DID THE BUMP WORK?
         BNZ   ERR8
         EJECT
RASTORE  DS    0H
         STH   R0,SCRADDR         SAVE THE START ADDR
         SPACE
         ICM   R0,X'C',ROW        LOAD THE ROW IN THE HIGH HALFWORD
         ICM   R0,X'3',COL        LOAD THE COL IN THE LOW HALFWORD
         ST    R0,WORKWORD        SAVE THE ROW AND COL
         SPACE
         CALL  ROWCOL,(WORKWORD,(R9))
         SPACE
         LTR   R15,R15            DID THE CALC WORK?
         BNZ   RET8               IF NOT, QUIT?
         EJECT
***********************************************************************
*                                                                     *
* INSERT THE REPEAT TO ADDRESS ORDER, THE FINISH ADDRESS, AND THE     *
* DATA CHARACTER.                                                     *
* WE MUST SUBTRACT 1 FROM THE TRAILING ADDR TO PUT IN THE RCARRAY.    *
* THIS IS BECAUSE THE ERASE IS UP TO BUT NOT INCLUDING THE RA         *
* ADDRESS.                                                            *
*                                                                     *
***********************************************************************
         SPACE
         LA    R1,REASON6         SET UP NO ROOM ADDR
         LA    R15,4(R8)          POINT TO NEW END ADDR
         C     R15,BUFEND         HAVE WE FALLEN OFF THE END?
         BH    ERR8               IF SO,QUIT
         SPACE
         LA    R1,REASON9         LOAD BAD RA DATA CODE
         LH    R14,DATALEN        GET THE DATA LENGTH
         LTR   R14,R14            IS IT ZERO?
         BZ    ERR8               IF SO QUIT
         SPACE
         MVI   0(R8),RA           INSERT THE RA ORDER INTO THE BUFFER
         STH   R0,1(R8)           SAVE THE ADDRESS
         MVC   3(1,R8),DATA       MOVE IN TH CHAR TO BE REPEATED
         SPACE
         LR    R8,R15             SAVE THE NEW BUFFER ADDRESS
         SPACE
         STH   R0,WORKWORD       PUT THE ADDR AWAY
         LH    R15,=H'-1'        GET THE DISPLACEMENT
         STH   R15,WORKWORD+2    AND SAVE IT
         SPACE
         CALL ADDRBUMP,(WORKWORD,WORKWORD+2)
         SPACE
         LA    R1,REASON12        LOAD REASON CODE FOR POSSIBLE ERROR
         LTR   R15,R15            DID THE BUMP WORK?
         BNZ   ERR8               IF NOT, QUIT
         SPACE
         STH   R0,SCREND          SAVE THE END ADDRESS
         ST    R7,STRADDR         SAVE THE STRUCTURE ADDRESS
         SPACE
         SLR   R15,R15            SHOW ZERO RC
         EJECT
***********************************************************************
*                                                                     *
* AT THIS POINT, DETERMINE WHETHER THIS FIELD IS TO RECEIVE BUFFER    *
* PROCESSING.  THIS IS CHECKED BY LOOKING AT THE NOFIELD FLAG AND THE *
* DONT USE FLAG.  IF EITHER ARE SET, THEN INSERTION OF THE DATA INTO  *
* THE BUFFER IS NOT REQUIRED.  THE DATA HAS, HOWEVER, BEEN INSERTED.  *
* THIS CAN BE UNDONE BY RESETTING THE BUFFER POINTER BACK TO WHERE IT *
* WAS ON ENTRY TO THIS ROUTINE.                                       *
*                                                                     *
***********************************************************************
         SPACE
NFTEST   DS    0H
         NOFIELD RESETBUF
         B     RET15
         SPACE
RESETBUF DS    0H
         L     R8,4(R13)           POINT TO THE HSA
         L     R8,24(R8)           POINT TO THE PARM LIST
         L     R8,4(R8)            GET THE ORIGINAL BUFFER ADDRESS
         B     RET15
         EJECT
***********************************************************************
*                                                                     *
* AN ERROR HAS OCCURED, INSERT THE REASON CODE IN THE FIRST HALF OF   *
* THE PL/I REASON PARM, SET THE PLI RC = 8, AND RETURN RC=8.          *
*                                                                     *
*      REGISTER USAGE:                                                *
*              R1  -  THE REASON CODE                                 *
*              R7  -> STRUCTURE FROM THE ARRAY OF STRUCTURES UNDER    *
*                     INSPECTION                                      *
*              R8  -> NEXT BUFFER ADDRESS TO FILL                     *
*              R9  -> ROW COL ELEMENT TO FILL                         *
*              R10 -> DATA AREA                                       *
*              R11 -> PLI PARM LIST                                   *
*              R12 -> PL/I TASK COMMUNICATION AREA (DO NOT MODIFY)    *
*              R13 -  BASE FOR PROGRAM                                *
*                                                                     *
***********************************************************************
         SPACE
ERR8     DS    0H
         PLIREA   R14             ACCESS THE PL/I REASON PARM
         STH   R1,0(R14)          SAVE THE REASON
         SPACE
RET8     DS    0H
         PLIRCSET 8,R14,R15       SHOW PLI RC = 8
         SPACE
         LA    R15,8              SHOW RC = 8
         SPACE
RET15    DS    0H
         LR    R0,R8              LOAD THE NEW BUFFER ADDRESS
         RETRN R,SPIE=NO,SAVEREG=0,RC=(15)
         SPACE
         LTORG
         DROP  R7,R9,R10,R11,R13
         EJECT
***********************************************************************
*                                                                     *
* SEGMENT NAME:                                                       *
*                                                                     *
*    ROWCOL -- ROW COLUMN TO SCREEN ADDRESS                           *
*                                                                     *
* INPUTS (*TO FUNCTIONS):                                             *
*                                                                     *
*    ROW_COL -- ROW AND COLUMN (*1,2)                                 *
*       THIS FULLWORD PARAMETER CONSISTS OF THE ROW NUMBER TO BE      *
*       CONVERTED IN THE HIGH ORDER HALF WORD AND THE COLUMN NUMBER   *
*       TO BE CONVERTED IN THE LOW ORDER HALF WORD.                   *
*                                                                     *
*    RCADDR -- ROW COLUMN ARRAY ELEMENT (*1)                          *
*       THIS IS THE CURRENT RC ARRAY ELEMENT BEING FILLED. THIS FIELD *
*       IS USED TO FIND THE PREVIOUS RC ARRAY ELEMENT FOR FIELD       *
*       VALIDITY CHECKING.                                            *
*                                                                     *
* FUNCTIONS:                                                          *
*                                                                     *
*    1. VALIDATE THE ROW AND COLUMNS PASSED.  ON BAD ROW OR COL SET   *
*       THE PL/I RC=8 AND THE PL/I REASON TO 3 FOR ROW AND 4 FOR COL. *
*       THE MAIN PROGRAM WILL FILL IN THE REST OF THE REASON CODE.    *
*                                                                     *
*    2. CHANGE THE ROW AND COLUMN TO A SCREEN ADDRESS                 *
*                                                                     *
* OUTPUTS (*FROM FUNCTIONS):                                          *
*                                                                     *
*    RC -- RETURN CODE (*1,2)                                         *
*       THE RETURN CODE SHOWS WHETHER THE FIELD WAS SUCCESSFULLY      *
*       CONVERTED TO A SCREEN ADDRESS. THIS IS RETURNED IN REGISTER   *
*       R15.                                                          *
*       VALUES: 0  -  SUCCESSFULL CONVERSION                          *
*               8  -  ROW OR COL OUT OF BOUNDS.                       *
*                                                                     *
*    SCR -- SCREEN ADDRESS (*2)                                       *
*       THE SCREEN ADDRESS REPRESENTING THE ROW AND COL ARE RETURNED  *
*       IN REGISTER R0.                                               *
*                                                                     *
***********************************************************************
         SPACE
ROWCOL   CSECT
         ENTER SPIE=NO
         EJECT
***********************************************************************
*                                                                     *
* SET UP THE PARM LIST AND ADDRESSABILITY TO THE DATA.                *
*                                                                     *
***********************************************************************
         SPACE
         LM    R8,R9,0(R1)        LOAD THE PARM LIST
         USING RCARRAY,R9         ADDRESS THE RC ARRAY
         SPACE
         L     R10,=V(DATAAREA)   POINT TO THE DATAAREA
         USING DATAAREA,R10       AND ESTABLISH ADDRESSABILITY
         SPACE
         L     R11,PARMADDR       POINT TO THE PL/I PARM
         USING PLIPARMS,R11       AND ESTABLISH ADDRESSABILITY
         EJECT
***********************************************************************
*                                                                     *
* VALIDATE THE ROW AND COLUMN VALUES AND THEN MULTIPLY THEM TO GET    *
* THE OFFSET INTO THE SCREEN FROM ROW 1 COL 1.                        *
*                                                                     *
*      REGISTER USAGE:                                                *
*              R4  -  ROW WORK AREA                                   *
*              R5  -  COL WORK AREA                                   *
*              R8  -> ROW AND COLUMN PARM                             *
*              R9  -> RC ELEMENT PARM                                 *
*              R10 -> DATA AREA                                       *
*              R11 -> PL/I PARM LIST                                  *
*              R12 -> PL/I TASK COMMUNICATIONS AREA (DO NOT MODIFY)   *
*              R13 -  BASE FOR PROGRAM AND DSA                        *
*                                                                     *
***********************************************************************
         SPACE
         LA    R1,REASON3         LOAD THE ROW NO GOOD REASON
         LH    R4,0(R8)           GET THE ROW
         LTR   R4,R4              IS IT POSITIVE?
         BNP   SETREA             IF NOT, QUIT
         SPACE
         CH    R4,NUMROWS         IS IT WITHIN BOUNDS?
         BH    SETREA             IF NOT, QUIT
         SPACE
         LA    R1,REASON4         LOAD THE COL NO GOOD REASON
         LH    R5,2(R8)           GET THE COL
         LTR   R5,R5              IS IT POSITIVE?
         BNP   SETREA             IF NOT, QUIT
         SPACE
         CH    R5,NUMCOLS         IS IT WITHIN BOUNDS?
         BH    SETREA             IF NOT, QUIT
         SPACE
         BCTR  R4,0               SUB 1 FROM THE ROW
         BCTR  R5,0               SUB 1 FORM THE COL
         SPACE
         MH    R4,NUMCOLS         MULTIPLY TO GET THE OFFSET OF THE
*                                 START OF THE ROW
         AR    R5,R4              ADD IN THE COLUMN OFFSET
         EJECT
***********************************************************************
*                                                                     *
* IF THE RC ELEMENT PASSED IS NOT THE FIRST ONE IN THE ARRAY, THEN    *
* CHECK TO MAKE SURE THAT THE NEW SCREEN ADDRESS WILL BE GREATER THAN *
* THE END OF THE OLD SCREEN ADDRESS.                                  *
*                                                                     *
*      REGISTER USAGE:                                                *
*              R1  -  USED TO HOLD THE ERROR REASON CODE              *
*              R2  -  USED TO CALCULATE THE OFFSET FROM THE SCREEN    *
*                     ADDRESS                                         *
*              R5  -  OFFSET INTO THE SCREEN OF THIS ROW COL          *
*                     COMBINATION                                     *
*              R8  -> ROW AND COLUMN PARM                             *
*              R9  -> RC ELEMENT PARM                                 *
*              R10 -> DATA AREA                                       *
*              R11 -> PL/I PARM LIST                                  *
*              R12 -> PL/I TASK COMMUNICATIONS AREA (DO NOT MODIFY)   *
*              R13 -  BASE FOR PROGRAM AND DSA                        *
*                                                                     *
***********************************************************************
         SPACE
         LA    R9,0(R9)           MAKE SURE HIGH BYTE OF ADDR IS ZERO
         C     R9,RCSTART         IS THIS THE FIRST ARRAY ELEMENT?
         BE    RCSETSCR           IF SO, DON'T LOOK FURTHER
         SPACE
         LA    R1,REASON13        SHOW BAD PLACE TO START
         S     R9,=A(RCARRLEN)    BACK UP 1 RC ARRAY ELEMENT
         SCRDISP R2,SCREND        GET THE LOW BYTE OF THE SCREEN  ADDR
         CR    R5,R2              IS THE NEW ADDR PAST THE LAST START?
         BNH   SETREA             IF SO, QUIT
         EJECT
***********************************************************************
*                                                                     *
* CONVERT THE OFFSET TO A SCREEN ADDRESS                              *
*              R5  -  THE SCREEN OFFSET                               *
*              R7  -> STRUCTURE FROM THE ARRAY OF STRUCTURES UNDER    *
*                     INSPECTION                                      *
*              R8  -> NEXT BUFFER ADDRESS TO FILL                     *
*              R9  -> ROW COL ELEMENT TO FILL                         *
*              R10 -> DATA AREA                                       *
*              R11 -> PLI PARM LIST                                   *
*              R12 -> PL/I TASK COMMUNICATION AREA (DO NOT MODIFY)    *
*              R13 -  BASE FOR PROGRAM                                *
*                                                                     *
***********************************************************************
         SPACE
RCSETSCR DS    0H
         SLR   R4,R4              CLEAR R4 FOR THE DIVIDE
         D     R4,=F'64'          DIVIDE THE OFFSET
         SPACE
         SLR   R0,R0
         IC    R0,BUF3270C(R5)    SET THE HIGH BYTE
         SLL   R0,8               MOVE IT OVER
         IC    R0,BUF3270C(R4)    SET THE LOW BYTE
         SLR   R15,R15            SHOW ZERO RC
         B     RCRET15
         SPACE
SETREA   DS    0H
         PLIREA R14               ACCESS THE REASON PARM
         STH   R1,0(R14)          AND INSERT THE REASON
         SPACE
         PLIRCSET 8,R1,R14        SET THE PLI RC = 8
         LA    R15,8              SET THE RETURN CODE = 8
         SPACE
RCRET15  DS    0H
         RETRN R,SPIE=NO,RC=(15),SAVEREG=0
         SPACE
         LTORG
         DROP  R9,R10,R11,R13
         EJECT
***********************************************************************
*                                                                     *
* SEGMENT NAME:                                                       *
*                                                                     *
*    SCRTORC -- SCREEN ADDRESS TO ROW COL                             *
*                                                                     *
* INPUTS (*TO FUNCTIONS):                                             *
*                                                                     *
*    SCR -- SCREEN ADDRESS (*1)                                       *
*       THIS HALFWORD PARM CONSISTS OF THE SCREEN BUFFER ADDRESS TO   *
*       BE CONVERTED TO A ROW AND A COL.                              *
*                                                                     *
* FUNCTIONS:                                                          *
*                                                                     *
*    1. CONVERT THE SCREEN ADDRESS TO A ROW AND COLUMN                *
*                                                                     *
* OUTPUTS (*FROM FUNCTIONS):                                          *
*                                                                     *
*    ROW_COL -- ROW AND COLUMN (*1)                                   *
*       THE ROW AND COLUMN REPRESENTING THE SCREEN ADDRESS PASSED ARE *
*       RETURNED IN REGISTER R0 WITH THE ROW IN THE HIGH ORDER HALF   *
*       WORD AND THE COLUMN IN THE LOW ORDER HALF WORD.               *
*                                                                     *
*    RC -- RETURN CODE (*1)                                           *
*       THE RETURN CODE SHOWS WHETHER THE FIELD WAS SUCCESSFULLY      *
*       CONVERTED TO A SCREEN ADDRESS. THIS IS RETURNED IN REGISTER   *
*       R15.                                                          *
*       VALUES: 0  -  SUCCESSFULL CONVERSION                          *
*               8  -  CONVERSION FAILED. PROBABLE PROGRAM ERROR       *
*                                                                     *
***********************************************************************
         SPACE
SCRTORC  CSECT
         ENTER SPIE=NO
         SPACE
***********************************************************************
*                                                                     *
* SET UP THE PARM LIST AND ADDRESSABILITY TO THE DATA AREA            *
*                                                                     *
***********************************************************************
       SPACE
       L     R8,0(R1)            LOAD THE PARM LIST
       L     R10,=V(DATAAREA)    POINT TO THE DATA AREA
       USING DATAAREA,R10        AND ESTABLISH ADDRESSIBITY
       EJECT
***********************************************************************
*                                                                     *
* TAKE THE LOW SIX BITS FROM EACH OF THE TWO SCREEN ADDRESS BYTES AND *
* PUT THEM TOGETHER.  THIS IS THE OFFSET INTO THE SCREEN BUFFER OF    *
* THIS SCREEN ADDRESS.  THEN ADD IN THE DISPLACEMENT AND CHECK TO     *
* MAKE SURE THE ADDRESS IS STILL ON SCREEN.                           *
*                                                                     *
*      REGISTER USAGE:                                                *
*              R7  -  USED TO BUILD THE SCREEN DISPLACEMENT           *
*              R8  -> INPUT SCREEN ADDRESS                            *
*              R10 -> DATA AREA                                       *
*              R12 -> PL/I TASK COMMUNICATIONS AREA (DO NOT MODIFY)   *
*              R13 -  BASE FOR PROGRAM                                *
*                                                                     *
***********************************************************************
         SPACE
         SCRDISP R7,(R8)        CONVERT THE SCR ADDR TO A DISPLACEMENT
         EJECT
***********************************************************************
*                                                                     *
* DIVIDE THE SCREEN OFFSET BY THE NUMBER OF COLS PER ROW AND USE THE  *
* QUOTIENT + 1 AND THE REMAINDER + 1 AS THE ROW AND COL RESPECTIVELY. *
* THEN MOVE THE ROW AND COL INTO THE HALFWORDS OF REGISTER R0.        *
*                                                                     *
*      REGISTER USAGE:                                                *
*              R6  -  THE REMAINDER AFTER THE DIVIDE                  *
*              R7  -  THE SCREEN OFFSET TO START AND THE QUOTENT      *
*                     AFTER THE DIVIDE                                *
*              R8  -> INPUT SCREEN ADDRESS                            *
*              R10 -> DATA AREA                                       *
*              R12 -> PL/I TASK COMMUNICATIONS AREA (DO NOT MODIFY)   *
*              R13 -  BASE FOR PROGRAM                                *
*              R15 -  WORK REGISTER                                   *
*                                                                     *
***********************************************************************
         SPACE
         LH    R15,NUMCOLS         GET THE NUMBER OF COLS PER ROW
         SLR   R6,R6               CLEAR THE REG FOR THE DIVIDE
         DR    R6,R15              DIVIDE
         SPACE
         LA    R6,1(R6)            ADD 1 TO GET THE NUMBER OF COLS
         LA    R7,1(R7)            ADD 1 TO GET THE NUMBER OF ROWS
         LR    R0,R7               SET UP FOR PUTING ROW + COL IN R0
         SLL   R0,16               MOVE THE ROW TO THE HIGH HALFWORD
         OR    R0,R6               MOVE IN THE COL
         SLR   R15,R15             SHOW RC=0
         SPACE
STRET    DS    0H
         RETRN R,SPIE=NO,SAVEREG=0,RC=(R15)
         SPACE
         LTORG
         DROP R10,R13
         EJECT
***********************************************************************
*                                                                     *
* SEGMENT NAME:                                                       *
*                                                                     *
*    ADDRBUMP -- BUMP SCREEN ADDRESS                                  *
*                                                                     *
* INPUTS (*TO FUNCTIONS):                                             *
*                                                                     *
*    SCR -- SCREEN ADDR TO BE BUMPED (*1)                             *
*       THIS HALFWORD PARAMETER IS THE SCREEN BUFFER ADDRESS WHICH IS *
*       TO BE BUMPED                                                  *
*                                                                     *
*    DISP -- SCREEN ADDRESS DISPLACEMENT (*2)                         *
*       THIS HALFWORD PARM IS THE NUMBER OF SCREEN POSITIONS          *
*       DISPLACEMENT FROM THE SCREEN ADDRESS PASSED FOR WHICH THE     *
*       SCREEN ADDRESS IS TO BE CALCULATED.                           *
*                                                                     *
* FUNCTIONS:                                                          *
*                                                                     *
*    1. CONVERT THE SCREEN ADDRESS INTO A LINEAR OFFSET FROM THE      *
*       BEGINNING OF THE SCREEN.                                      *
*                                                                     *
*    2. ADD IN THE DISPLACEMENT (NEGATIVE OR POSITIVE).  AND MAKE     *
*       SURE THE NEW ADDRESS IS STILL ON SCREEN.                      *
*                                                                     *
*    3. CONVERT THE LINEAR OFFSET FROM THE BEGINNING OF THE SCREEN TO *
*       A BUFFER ADDRESS AND RETURN IT IN REGISTER R0.                *
*                                                                     *
* OUTPUTS (*FROM FUNCTIONS):                                          *
*                                                                     *
*    RC -- RETURN CODE (*2)                                           *
*       THE RETURN CODE SHOWS WHETHER THE FIELD WAS SUCCESSFULLY      *
*       CONVERTED TO A SCREEN ADDRESS. THIS IS RETURNED IN REGISTER   *
*       R15.                                                          *
*       VALUES: 0  -  SUCCESSFULL CONVERSION                          *
*               8  -  CONVERSION FAILED. PROBABLE PROGRAM ERROR       *
*                                                                     *
*    SCROUT -- NEW SCREEN ADDRESS (*3)                                *
*       THIS SCREEN ADDRESS IS RETURNED IN THE LOW HALFWORD OF        *
*       REGISTER R0 AND IS THE SCREEN ADDRESS FOR THE POSITION 'DISP' *
*       AWAY FROM THE ORIGIANAL SCREEN ADDRESS.                       *
*                                                                     *
***********************************************************************
         SPACE
ADDRBUMP CSECT
         ENTER SPIE=NO
         SPACE
***********************************************************************
*                                                                     *
* SET UP THE PARM LIST AND ADDRESSABILITY TO THE DATA AREA            *
*                                                                     *
***********************************************************************
       SPACE
       LM    R8,R9,0(R1)         LOAD THE PARM LIST
       L     R10,=V(DATAAREA)    POINT TO THE DATA AREA
       USING DATAAREA,R10        AND ESTABLISH ADDRESSABILITY
       EJECT
***********************************************************************
*                                                                     *
* TAKE THE LOW SIX BITS FROM EACH OF THE TWO SCREEN ADDRESS BYTES AND *
* PUT THEM TOGETHER.  THIS IS THE OFFSET INTO THE SCREEN BUFFER OF    *
* THIS SCREEN ADDRESS.  THEN ADD IN THE DISPLACEMENT AND CHECK TO     *
* MAKE SURE THE ADDRESS IS STILL ON SCREEN.                           *
*                                                                     *
*      REGISTER USAGE:                                                *
*              R7  -  USED TO BUILD THE SCREEN DISPLACEMENT           *
*              R8  -> INPUT SCREEN ADDRESS                            *
*              R9  -> DISPLACEMENT TO BE ADDED IN                     *
*              R10 -> DATA AREA                                       *
*              R12 -> PL/I TASK COMMUNICATIONS AREA (DO NOT MODIFY)   *
*              R13 -  BASE FOR PROGRAM                                *
*                                                                     *
***********************************************************************
         SPACE
         SCRDISP R7,(R8)        CONVERT THE SCR ADDR TO DISPLACEMENT
         SPACE
         AH    R7,0(R9)         ADD IN THE DISPLACEMENT
         BM    ABBAD            IF IT IS NEGATIVE, ERROR
         SPACE
         CH    R7,SCREENSZ      CHECK FOR OFF SCREEN
         BNH   ABSCR            IF OK ,GO CONTINUE PROCESSING
         SPACE 2
***********************************************************************
*                                                                     *
* THE NEW SCREEN ADDR IS OFF SCREEN. RETURN RC=8.                     *
*                                                                     *
***********************************************************************
         SPACE
ABBAD    DS    0H
         LA    R15,8            SHOW RC=8
         B     ABRET            AND GO BACK
         EJECT
***********************************************************************
*                                                                     *
* DIVIDE THE SCREEN ADDRESS BY 64 AND USE THE REMAINDER AND QUOTIENT  *
* TO BUILD THE SCREEN ADDRESS.                                        *
*                                                                     *
*      REGISTER USAGE:                                                *
*              R6  -  THE REMAINDER AFTER THE DIVIDE                  *
*              R7  -  THE SCREEN OFFSET ORIGINALLY AND THE QUOTENT    *
*                     AFTER THE DIVIDE                                *
*              R8  -> INPUT SCREEN ADDRESS                            *
*              R9  -> DISPLACEMENT TO BE ADDED IN                     *
*              R10 -> DATA AREA                                       *
*              R12 -> PL/I TASK COMMUNICATIONS AREA (DO NOT MODIFY)   *
*              R13 -  BASE FOR PROGRAM                                *
*                                                                     *
***********************************************************************
         SPACE
ABSCR    DS    0H
         SLR   R6,R6               CLEAR THE REG FOR THE DIVIDE
         D     R6,=F'64'           DIVIDE
         SPACE
         SLR   R0,R0               GET A ZERO
         LA    R15,BUF3270C(R7)
         ICM   R0,2,0(R15)         SET THE HIGH BYTE OF THE SCREEN ADDR
         IC    R0,BUF3270C(R6)     SET THE LOW BYTE OF THE SCREEN ADDR
         SLR   R15,R15             SHOW RC=0
         SPACE
ABRET    DS    0H
         RETRN R,SPIE=NO,SAVEREG=0,RC=(R15)
         SPACE
         LTORG
         DROP R10,R13
         EJECT
DATAAREA CSECT
         USING DATAAREA,R10       R10 WILL ALWAYS POINT HERE
         SPACE 2
***********************************************************************
*                                                                     *
* INSTRUCTIONS WHICH ARE 'EX'ECUTED                                   *
*                                                                     *
***********************************************************************
         SPACE
SBACHK   TRT   0(*-*,R6),SBATRT
CMDCHK   CLC   2(*-*,R14),CMDNAME-CMD(R1)
TRCAPS   TR    1(*-*,R6),CAPITAL
         SPACE 2
***********************************************************************
*                                                                     *
* STATIC VARIABLE STORAGE                                             *
*                                                                     *
***********************************************************************
         SPACE
BUFLEN   DC    F'0'
BUFSTART DC    A(0)
BUFEND   DC    A(0)
         SPACE
STRLEN   DC    F'0'           STRUCTURE ELEMENT LENGTH
MAXDATA  DC    H'0'           DECLARED LENGTH OF STRUCTURE DATA STRING
PARMADDR DC    A(0)           ADDR OF THE PLI PARM LIST
RCSTART  DC    A(0)           ADDRESS OF THE RC ELEMENT START, ALSO
*                             THE START OF THE GOTTEN STORAGE
         SPACE
NUMROWS  DC    H'0'           NUMBER OF ROWS ON THE SCREEN
NUMCOLS  DC    H'0'           NUMBER OF COLS PER ROW (LINE SIZE)
SCREENSZ DC    H'0'           TOTAL NUMBER OF POSITIONSON THE SCREEN
WORKWORD DC    F'0'           WORKING STORAGE
SAVEDRC  DC    H'0'           WORKING STORAGE
         SPACE 2
***********************************************************************
*                                                                     *
* FLAGS                                                               *
*                                                                     *
***********************************************************************
         SPACE
CURSESET DC  X'00'            SHOWS CURSOR POS HAS BEEN ESTABLISHED
NOREAD   DC  X'00'            SHOWS TGET IS NOT TO BE PERFORMED
NOFIELDS DC  X'00'            SHOWS NO OUTPUT FIELDS.
CMDONLY  DC  X'00'            COMMAND ONLY FORMAT.
UPPER    DC  X'00'            SET TO SHOW TRANSLATE TO UPPER CASE
         EJECT
***********************************************************************
*                                                                     *
* TABLE OF COMMANDS, LENGTHS, AND CODES, AND NOREAD FLAG SETTINGS     *
*                                                                     *
***********************************************************************
         SPACE
CMDTABLE DS    0F
         DC    H'11',X'F5',X'00',CL14'ERASE/WRITE'   ERASE WRITE
         DS    0H
CMDELEN  EQU   *-CMDTABLE
         DC    H'03',X'F5',X'FF',CL14'EWN'     ERASE WRITE NOREAD
         DC    H'05',X'F1',X'00',CL14'WRITE'   WRITE
         DC    H'02',X'F1',X'FF',CL14'WN'      WRITE NOREAD
         DC    H'03',X'7E',X'00',CL14'EWA'     ERASE WRITE ALTERNATE
         DC    H'04',X'7E',X'FF',CL14'EWAN'    ERASE WRITE ALT NOREAD
         DC    H'03',X'6F',X'00',CL14'EAU'     ERASE ALL UNPROTECTED
CMDEND   EQU   *
         SPACE 4
***********************************************************************
*                                                                     *
* TABLE OF WRITE CONTROL CHARACTERS.  THIS TABLE IS ACCESSED BY USING *
* THE THREE BITS OF THE WRITE CONTROL OPTIONS AS AN OFFSET INTO THE   *
* TABLE.                                                              *
*                                                                     *
***********************************************************************
         SPACE
WCCTABLE DS    0F
         DC    X'40C1C2C3C4C5C6C7'
WCCTLEN  EQU   *-WCCTABLE
         EJECT
***********************************************************************
*                                                                     *
* AID - ATTENTION IDENTIFIACTION TRT TABLE                            *
* THIS TABLE IS USED TO TRANSLATE THE AID CHARACTERS RETURNED TO      *
* NUMBERS FROM 1 TO 29.                                               *
*                                                                     *
***********************************************************************
         SPACE
AIDTRT   DC    256X'00'
         ORG   AIDTRT+X'F1'
         DC    X'010203040506070809'      PF1 TO PF9
         ORG   AIDTRT+X'7A'
         DC    X'0A0B0C'                  PF10 TO PF 12
         ORG   AIDTRT+X'C1'
         DC    X'0D0E0F101112131415'      PF 13 TO PF 21
         ORG   AIDTRT+X'4A'
         DC    X'161718'                  PF22 TO PF24
         ORG   AIDTRT+X'F0'
         DC    X'19'                      25 FOR TEST REQ
         ORG   AIDTRT+X'6D'
         DC    X'1A'                      26 FOR CLEAR
         ORG   AIDTRT+X'6C'
         DC    X'1B'                      27 FOR PA1
         ORG   AIDTRT+X'6E'
         DC    X'1C'                      28 FOR PA2
         ORG   AIDTRT+X'6B'
         DC    X'1D'                      29 FOR PA3
         ORG
         EJECT
***********************************************************************
*                                                                     *
*                        TABLE TO FIND AN SBA                         *
*                                                                     *
***********************************************************************
         SPACE
SBATRT   DC    256X'00'
         ORG   SBATRT+SBA
         DC    X'FF'
         ORG
         SPACE 5
***********************************************************************
*                                                                     *
*         TABLE TO TRANSLATE LOWER CASE LETTERS TO UPPER CASE         *
*                                                                     *
***********************************************************************
        SPACE
CAPITAL DC    XL16'000102030405060708090A0B0C0D0E0F'
        DC    XL16'101112131415161718191A1B1C1D1E1F'
        DC    XL16'202122232425262728292A2B2C2D2E2F'
        DC    XL16'303132333435363738393A3B3C3D3E3F'
        DC    XL16'404142434445464748494A4B4C4D4E4F'
        DC    XL16'505152535455565758595A5B5C5D5E5F'
        DC    XL16'606162636465666786966A6B6C6D6E6F'
        DC    XL16'707172737475767778797A7B7C7D7E7F'
        DC    XL16'80C1C2C3C4C5C6C7C8C98A8B8C8D8E8F'
        DC    XL16'90D1D2D3D4D5D6D7D8D99A9B9C9D9E9F'
        DC    XL16'A0A1E2E3E4E5E6E7E8E9AAABACADAEAF'
        DC    XL16'B0B1B2B3B4B5B6B7B8B9BABBBCBDBEBF'
        DC    XL16'C0C1C2C3C4C5C6C7C8C9CACBCCCDCECF'
        DC    XL16'D0D1D2D3D4D5D6D7D8D9DADBDCDDDEDF'
        DC    XL16'E0E1E2E3E4E5E6E7E8E9EAEBECEDEEEF'
        DC    XL16'F0F1F2F3F4F5F6F7F8F9FAFBFCFDFEFF'
        EJECT
***********************************************************************
*                                                                     *
* TABLE TO CHANGE THE 5 ATTRBUTE FLAGS TO THE ATTRIBUTE CHARACTER.    *
*                                                                     *
* THE 5 FLAGS, TAKEN TOGETHER, ARE USED AS AN OFFSET INTO THE TABLE.  *
*                                                                     *
***********************************************************************
         SPACE
ATTRTBL  DS    0F
         DC    X'40C14C4D'
         DC    X'C8C94C4D'
         DC    X'50D15C5D'
         DC    X'D8D95C5D'
         DC    X'60616C6D'
         DC    X'E8E96C6D'
         DC    X'F0F17C7D'
         DC    X'F8F97C7D'
         EJECT
         BUF3270A FORMAT=PART
         EJECT
FIELDEFS DSECT
ROW      DS    H
COL      DS    H
FLAGS    DS    X
PROTECT  EQU   X'80'
AUTONUM  EQU   X'40'
HIGH     EQU   X'20'
NODISP   EQU   X'10'
MDT      EQU   X'08'
DONTUSE  EQU   X'04'
CURSOR   EQU   X'02'
FOUND    EQU   X'01'
NOTFOUND EQU   X'FE'
ORDER    DS    CL3
DATALEN  DS    H
DATA     DS    C
         SPACE 5
PLIPARMS DSECT
PLICMD   DS    A
PLIWCO   DS    A
PLIAID   DS    A
PLICPOS  DS    A
PLIREA   DS    A
PLINUM   DS    A
PLISTR   DS    A
PLIRC    DS    A
         SPACE 5
RCARRAY  DSECT
STRADDR  DS    A
SCRADDR  DS    H
SCREND   DS    H
RCARRLEN EQU   *-RCARRAY
         SPACE 5
CMD      DSECT
CMDLEN   DS    H
CMDCODE  DS    X
CMDREAD  DS    X
CMDNAME  DS    C
         EJECT
DESCRIPT DSECT
ROWAOFF  DS    F
ROWRVO   DS    F
ROWMULT  DS    F
ROWHB    DS    H
ROWLB    DS    H
         SPACE
COLAOFF  DS    F
COLRVO   DS    F
COLMULT  DS    F
COLHB    DS    H
COLLB    DS    H
         SPACE
PROTAOFF DS    F
PROTRVO  DS    F
PROTMULT DS    F
PROTHB   DS    H
PROTLB   DS    H
PROTDCL  DS    H
PROTVAR  DS    H
         SPACE
AUTOAOFF DS    F
AUTORVO  DS    F
AUTOMULT DS    F
AUTOHB   DS    H
AUTOLB   DS    H
AUTODCL  DS    H
AUTOVAR  DS    H
         SPACE
HIGHAOFF DS    F
HIGHRVO  DS    F
HIGHMULT DS    F
HIGHHB   DS    H
HIGHLB   DS    H
HIGHDCL  DS    H
HIGHVAR  DS    H
         SPACE
DISPAOFF DS    F
DISPRVO  DS    F
DISPMULT DS    F
DISPHB   DS    H
DISPLB   DS    H
DISPDCL  DS    H
DISPVAR  DS    H
         SPACE
MDTBAOFF DS    F
MDTBRVO  DS    F
MDTBMULT DS    F
MDTBHB   DS    H
MDTBLB   DS    H
MDTBDCL  DS    H
MDTBVAR  DS    H
         SPACE
NOTUAOFF DS    F
NOTURVO  DS    F
NOTUMULT DS    F
NOTUHB   DS    H
NOTULB   DS    H
NOTUDCL  DS    H
NTOUVAR  DS    H
         SPACE
CURSAOFF DS    F
CURSRVO  DS    F
CURSMULT DS    F
CURSHB   DS    H
CURSLB   DS    H
CURSDCL  DS    H
CURSVAR  DS    H
         SPACE
FOUNAOFF DS    F
FOUNRVO  DS    F
FOUNMULT DS    F
FOUNHB   DS    H
FOUNLB   DS    H
FOUNDCL  DS    H
FOUNVAR  DS    H
         SPACE
ORDRAOFF DS    F
ORDRRVO  DS    F
ORDRMULT DS    F
ORDRHB   DS    H
ORDRLB   DS    H
ORDRDCL  DS    H
ORDRVAR  DS    H
         SPACE
DATAAOFF DS    F
DATARVO  DS    F
DATAMULT DS    F
DATAHB   DS    H
DATALB   DS    H
DATADCL  DS    H
DATAVAR  DS    H
         EJECT
REASON1  EQU   1
REASON2  EQU   2
REASON3  EQU   3
REASON4  EQU   4
REASON5  EQU   5
REASON6  EQU   6
REASON7  EQU   7
REASON8  EQU   8
REASON9  EQU   9
REASON10 EQU   10
REASON11 EQU   11
REASON12 EQU   12
REASON13 EQU   13
REASON14 EQU   14
         SPACE
         END
TSIZE    TITLE 'RETURN NUMBER OF LINES PER SCREEN TO PLI'
***********************************************************************
*                                                                     *
* SEGMENT NAME:                                                       *
*                                                                     *
*    TSIZE -- RETURN THE NUMBER OF LINES PER SCREEN TO PL/I           *
*                                                                     *
* INPUTS (*TO FUNCTIONS):                                             *
*                                                                     *
*    GTSIZE -- GTSIZE MACRO (*2)                                      *
*       THE GTSIZE MACRO RETURNS THE NUMBER OF LINES PER SCREEN IN    *
*       REGISTER R0.                                                  *
*                                                                     *
* FUNCTIONS:                                                          *
*                                                                     *
*    1. POINT TO THE OUTPUT PARM                                      *
*                                                                     *
*    2. ISSUE A GTSIZE MACRO AND RETURN THE VALUE IN THE OUTPUT PARM  *
*                                                                     *
* OUTPUTS (*FROM FUNCTIONS):                                          *
*                                                                     *
*    TSIZE -- THE NUMBER OF LINES PER SCREEN (*2)                     *
*       THE NUMBER OF LINES PER SCREEN IS RETURNED IN A FIXED         *
*       BINARY(15) VARIABLE                                           *
*                                                                     *
***********************************************************************
         SPACE
TSIZE    CSECT
         ENTER R,SPIE=NO
         SPACE
         L     R2,0(R1)        POINT TO THE OUTPUT PARM
         SPACE
         GTSIZE
         SPACE
         STH   R0,0(R2)        SAVE THE NUMBER OF LINES PER TERM
         SPACE
         RETRN R,SPIE=NO
         END
LSIZE    TITLE 'RETURN NUMBER OF CHARS PER LINE TO PLI'
***********************************************************************
*                                                                     *
* SEGMENT NAME:                                                       *
*                                                                     *
*    LSIZE -- RETURN THE NUMBER OF CHARS PER LINE TO PL/I             *
*                                                                     *
* INPUTS (*TO FUNCTIONS):                                             *
*                                                                     *
*    GTSIZE -- GTSIZE MACRO (*2)                                      *
*       THE GTSIZE MACRO RETURNS THE NUMBER OF CHARS PER LINE IN      *
*       REGISTER R1.                                                  *
*                                                                     *
* FUNCTIONS:                                                          *
*                                                                     *
*    1. POINT TO THE OUTPUT PARM                                      *
*                                                                     *
*    2. ISSUE A GTSIZE MACRO AND RETURN THE VALUE IN THE OUTPUT PARM  *
*                                                                     *
* OUTPUTS (*FROM FUNCTIONS):                                          *
*                                                                     *
*    LSIZE -- THE NUMBER OF CHARS PER LINE (*2)                       *
*       THE NUMBER OF CHARS PER LINE IS RETURNED IN A FIXED           *
*       BINARY(15) VARIABLE                                           *
*                                                                     *
***********************************************************************
         SPACE
LSIZE    CSECT
         ENTER R,SPIE=NO
         SPACE
         L     R2,0(R1)        POINT TO THE OUTPUT PARM
         SPACE
         GTSIZE
         SPACE
         STH   R1,0(R2)        SAVE THE NUMBER OF LINES PER TERM
         SPACE
         RETRN R,SPIE=NO
         END
