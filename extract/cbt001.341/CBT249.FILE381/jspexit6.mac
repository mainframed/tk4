         TITLE 'JES2 EXIT 6 INTERNAL TEXT EXIT'
***********************************************************************
*                                                                     *
*        ENVIRONMENT   MVS SP 1.3.0  LEVEL 8306                       *
*                      JES2 FOR SP 1.3.0                              *
*                                                                     *
*        THIS JES2 EXIT PROGRAM IS DESIGNED TO RUN AT CONVERTER       *
*        TIME TO ENFORCE INSTALLATION JCL STANDARDS AND TO DETERMINE  *
*        THE APPROPRIATE JOB CLASS BASED ON DEVICE UTILIZATION.       *
*                                                                     *
*        VIOLATIONS OF JCL STANDARDS ARE DOCUMENTED BY MESSAGES       *
*        WRITTEN TO THE JES2 MESSAGE DATA SET FOR THE JOB AND         *
*        FLAGGED FOR JCL ERROR BY THE USE OF THE JES2 EXIT RETURN     *
*        CODE TO THE JES2 CONVERTER SUB-TASK.                         *
*                                                                     *
*        THIS EXIT USES THE INTERNAL TEXT DATA SET FOR ITS            *
*        PROCESSING.  JES2 PASSES EACH INTERNAL TEXT STATEMENT        *
*        TO THIS EXIT FOR EXAMINATION AND/OR MODIFICATION.  THE       *
*        EXIT WILL MAINTAIN A TABLE OF DATASET NAMES AND DEVICE       *
*        COUNTS TO BE USED AT END OF PROCESSING FOR DETERMINING       *
*        JOB CLASS.  THE ACB FOR THE MESSAGE DATA SET IS IN THE       *
*        PCE WORK AREA AND CAN BE USED TO ISSUE ERROR MESSAGES        *
*        TO THE JOB MESSAGE PORTION OF THE LISTING.                   *
*                                                                     *
*        ALSO, THE CONVERTER IS A DUMB ANIMAL WHEN IT COMES TO        *
*        SYNTAX CHECKING.  CHECKING IS MADE FOR KEYWORD VALUES,       *
*        BUT NONE IS MADE ON THE VALUE FOR THE KEYWORD.  IE.,         *
*        50 CHARACTER DATA SET NAMES, 20 CHARACTER VOLUME SERIAL      *
*        NUMBERS, AND NUMEROUS SYNTAX ERRORS CAN PASS UNDETECTED      *
*        THROUGH THE CONVERTER.  THESE ERRORS WILL BE CAUGHT BY       *
*        THE INTERPRETER WHEN THE JOB GOES INTO EXECUTION, BUT        *
*        THIS EXIT MUST PROCESS THEM.  CURRENTLY, ALL ERRORS OF       *
*        THIS TYPE WILL ISSUE A MESSAGE TO THE EFFECT OF AN INTERNAL  *
*        ERROR AND SET THE JOB TO CLASS=A.  THE ESTAE ROUTINE,        *
*        WHEN ENTERED FOR AN ABEND, WILL ALSO SET THE CLASS TO        *
*        'A' AND RECOVER TO PROTECT THE CONVERSION SUBTASK FROM       *
*        ABEND AND CONSEQUENT LOSS OF THE JOB.                        *
*                                                                     *
***********************************************************************
         EJECT
***********************************************************************
*                                                                     *
*        CLASS DETERMINATION IS MADE BY KEEPING A COUNT OF ALL        *
*        OF THE MOUNTABLE DEVICES USED PER STEP.  THESE COUNTS        *
*        ARE SAVED IN AN INTERNAL TABLE TO BE PROCESSED AT END        *
*        OF INTERNAL TEXT.  ALSO SAVED IN THE TABLE ARE ENTRIES       *
*        FOR DD STATEMENTS WHICH USED MOUNTABLE DEVICES               *
*        FOR USE IN REFERBACKS AND UNIT=AFF.  IF THE UNIT             *
*        HAS NOT BEEN DETERMINED AT THE END OF PROCESSING             *
*        FOR A DD STATEMENT, THE CATALOG IS SEARCHED.  IF THE         *
*        CATALOGED DEVICE IS SYSDA, THE UCBS ARE SEARCHED             *
*        TO DETERMINE IF THE PACK IS MOUNTED AS PRIVATE,              *
*        RESERVED, OR PERMANENTLY RESIDENT.  IF THE PACK              *
*        IS NOT FOUND, A PRIV DISK MOUNT WILL BE CHARGED.             *
*        CLASS IS SET ON THE BASIS OF THE MAXIMUM NUMBER OF TAPES     *
*        PER STEP, MAXIMUM NUMBER OF PRIV DASD DEVICES PER STEP,      *
*        TOTAL MAXIMUM MOUNTABLE DEVICES PER STEP, MAXIMUM REGION     *
*        PER STEP, AND ESTIMATED EXECUTION TIME FOR JOB.              *
*                                                                     *
*        WHEN TESTING THIS EXIT UNDER THE TSO INTERFACE, THE LOCAL    *
*        VARIABLE &&TSO SHOULD BE CHANGED TO 'YES' FROM 'NO' TO       *
*        CHANGE THE $$WTO INSTRUCTIONS TO WTO INSTRUCTIONS AND        *
*        BYPASS THE ESTAE MACROS SO THAT THE TEST COMMAND CAN         *
*        DETERMINE THE ADDRESS OF THE ABEND.                          *
*                                                                     *
*                                                                     *
*        WRITTEN BY:                                                  *
*                        JOHN V. HOOPER                               *
*                        NORTHWESTERN BANK                            *
*                        P.O. BOX 310                                 *
*                        NORTH WILKESBORO, N.C. 28674                 *
*                                                                     *
***********************************************************************
***********************************************************************
         PRINT OFF
***********************************************************************
*                                                                     *
***** $HASPCB *****           GENERATE HASP CONTROL BLOCKS            *
*                                                                     *
***********************************************************************
         MACRO
         $HASPCB &DOC=NO,&LIST=NO
         GBLC  &PRINT,&GEN,&DATA
         PUSH  PRINT
         PRINT &PRINT
         $NEL  LIST=&LIST
         $DEB  LIST=&LIST
         $PCE
         DROP  R13
         USING PCEDSECT,R8
         $BUFFER DOC=&DOC
         $JQE
         $JCT
         $CAT
         DROP  R10
         $MIT
         $TEXT LIST=&LIST
         $KEYS LIST=&LIST
         $CNVWORK
         $RPL  LIST=&LIST
         $SDWA LIST=&LIST
         $HCT
         POP   PRINT
         PRINT &GEN,&DATA
         MEND
         PRINT ON
         EJECT
***********************************************************************
*                                                                     *
*              M A C R O S   U S E D   I N   J E S E X I T 6          *
*                                                                     *
*        01)  $$WTO        SYS1.HASPSRC                               *
*        02)  $BUFFER      SYS1.HASPSRC                               *
*        03)  $CAT         SYS1.HASPSRC                               *
*        04)  $CNVWORK     SYS1.HASPSRC                               *
*        05)  $DEB         SYS1.HASPSRC                               *
*        06)  $ENTRY       SYS1.HASPSRC                               *
*        07)  $HASPCB      INSTREAM                                   *
*        08)  $HASPGEN     SYS1.HASPSRC                               *
*        09)  $HCT         SYS1.HASPSRC                               *
*        10)  $JCT         SYS1.HASPSRC                               *
*        11)  $JQE         SYS1.HASPSRC                               *
*        12)  $KEYS        SYS1.HASPSRC                               *
*        13)  $MID         SYS1.HASPSRC                               *
*        14)  $MIT         SYS1.HASPSRC                               *
*        15)  $NEL         SYS1.HASPSRC                               *
*        16)  $MODEND      SYS1.HASPSRC                               *
*        17)  $MODULE      SYS1.HASPSRC                               *
*        18)  $RPL         SYS1.HASPSRC                               *
*        19)  $SDWA        SYS1.HASPSRC                               *
*        20)  $SYSPARM     SYS1.HASPSRC                               *
*        21)  $TEXT        SYS1.HASPSRC                               *
*        22)  CAMLST       SYS1.MACLIB                                *
*        23)  ESTAE        SYS1.MACLIB                                *
*        24)  FREEMAIN     SYS1.MACLIB                                *
*        25)  GETMAIN      SYS1.MACLIB                                *
*        26)  IEFNEL       SYS1.AMODGEN  ($NEL)                       *
*        27)  IEFTXTFT     SYS1.AMODGEN  ($TEXT)                      *
*        28)  IEFVKEYS     SYS1.AMODGEN  ($KEYS)                      *
*        29)  IEZDEB       SYS1.AMODGEN  ($DEB)                       *
*        30)  IFGRPL       SYS1.MACLIB   ($RPL)                       *
*        31)  IHASDWA      SYS1.MACLIB   ($SDWA)                      *
*        32)  LOCATE       SYS1.MACLIB                                *
*        33)  RETURN       SYS1.MACLIB                                *
*        34)  SAVE         SYS1.MACLIB                                *
*        35)  SDUMP        SYS1.MACLIB                                *
*        36)  SETRP        SYS1.MACLIB                                *
*        37)  WTO          SYS1.MACLIB                                *
*                                                                     *
*                                                                     *
*              L I N K A G E    E D I T O R    I N F O                *
*                                                                     *
*        SIZE:       15K                                              *
*        ATTRIBUTES: REENTRANT, REUSEABLE, REFRESHABLE                *
*                                                                     *
*                                                                     *
***********************************************************************
         EJECT
***********************************************************************
*                                                                     *
*        SET CONDITIONAL ASSEMBLY VARIABLES                           *
*                                                                     *
***********************************************************************
         LCLC &TSO
         LCLC &CAMLST
         LCLC &ERRMSG
         LCLC &SDUMP
         LCLC &FLUSH
         LCLC &MODIFY
         LCLC &UCBSEAR
         LCLC &BINREQD
         LCLC &ESTAE
&TSO     SETC 'NO'         ASSEMBLE FOR TSO TESTING
&CAMLST  SETC 'YES'        SEARCH CATALOG FOR DATASETS
&ERRMSG  SETC 'YES'        PRODUCE JOBFAILED BY EXIT MESSAGE
&SDUMP   SETC 'YES'        PRODUCE CONSOLE DUMP FOR ABENDS
&FLUSH   SETC 'YES'        FLUSH JOB FOR STANDARDS VIOLATIONS
&MODIFY  SETC 'YES'        MODIFY JOB CLASS IN JCT AND JQE
&UCBSEAR SETC 'YES'        SEARCH THE DASD UCBS FOR UNMOUNTED VOLUMES
&BINREQD SETC 'YES'        IS BIN NUMBER REQUIRED
&ESTAE   SETC 'YES'        CREATE ESTAE ENVIRONMENT
         EJECT
***********************************************************************
*                                                                     *
*        JES2 MACRO EXPANSIONS                                        *
*                                                                     *
***********************************************************************
         COPY  $HASPGEN
JESEXIT6 $MODULE
***********************************************************************
*                                                                     *
*        THE $SYSPARM MACRO PROVIDES JES2 MACRO DEFAULTS FOR          *
*        THE FOLLOWING PARAMETERS IN THE FOLLOWING ORDER:             *
*                                                                     *
*                 (PRINT,GEN,DATA,DOC,LIST)                           *
*                                                                     *
***********************************************************************
         $SYSPARM (OFF,GEN,NODATA,NO,NO)
         SPACE 5
         $HASPCB DOC=&DOC,LIST=&LIST
         TITLE 'JES2 EXIT 6 INTERNAL TEXT EXIT'
***********************************************************************
*                                                                     *
*        ACTUAL JES2 EXIT ENTRY POINT                                 *
*                                                                     *
***********************************************************************
EXIT6    $ENTRY  BASE=(R12,R9,R10),CSECT=YES
         SAVE  (14,12)        SAVE CALLERS REGISTERS
         LR    R2,R10         SAVE JCT ADDRESS
         LR    R12,R15        ESTABLISH BASE REGISTER
         LA    R9,2048(R12) SET SECOND
         LA    R9,2048(R9)        BASE REGISTER
         LA    R10,2048(R9)   SET THIRD
         LA    R10,2048(R10)      BASE REGISTER
         LR    R4,R0          SAVE REG 0
         L     R6,4(,R1)      LOAD ADDRESS OF INTERNAL TEXT RECORD
         USING TEXT,R6        SET ADDRESSABILITY TO TEXT RECORD
         CLC   PCEUSER0,BINZEROS SEE IF VALID EXIT WORK AREA
         BE    GETMAIN        NO, GO DO REQUIRED GETMAINS
         L     R1,PCEUSER0    GET GETMAINED AREA ADDR
         ST    R13,4(R1)      SAVE OLD SAVE ADDR IN NEW
         ST    R1,8(R13)      SAVE NEW SAVE ADDR IN OLD
         LR    R13,R1         SAVE NEW SAVE AND WORKAREA ADDRESS
         USING WORKAREA,R13   SET ADDRESSABILITY
         L    R7,SUBTABLE     RESTORE SUB TABLE AREA
         USING SAVTABLE,R7    SET ADDRESSABILITY
         B     ENDGETM        BYPASS GETMAINS
         EJECT
***********************************************************************
*                                                                     *
*        GET STORAGE FOR WORK AREAS ON FIRST ENTRY TO EXIT FOR        *
*        THE JOB                                                      *
*                                                                     *
***********************************************************************
GETMAIN  DS    0H
         LH    R0,GETLEN      LOAD GETMAIN SIZE
         GETMAIN R,LV=(0)     GET CORE FOR DYNAMIC SAVE AREA
         LR    R3,R1          SAVE GETMAINED ADDRESS
         LR    R0,R1          CLEAR
         LH    R1,GETLEN          ENTIRE
         SLR   R15,R15                GETMAINED
         MVCL  R0,R14                     TO ZEROS
         ST    R13,4(R3)      SAVE OLD SAVE ADDR IN NEW
         ST    R3,8(R13)      SAVE NEW SAVE ADDR IN OLD
         LR    R13,R3         SAVE NEW SAVE AND WORKAREA ADDRESS
         ST    R13,PCEUSER0   SAVE GETMAINED ADDRESS
         L     R0,F#8192      LOAD GETMAIN SIZE
         GETMAIN R,LV=(0)     GET CORE FOR JCL TABLE
         LR   R7,R1           SAVE GETMAIN ADDRESS
         ST   R7,SUBTABLE     STORE ADDR OF SUB TABLE AREA
         LR   R0,R7           CLEAR
         L     R1,F#8192          ENTIRE
         SLR   R15,R15                GETMAINED
         MVCL  R0,R14                     TO ZEROS
         LA    R15,MSGRPL     LOAD OUTPUT RPL ADDRESS
         ST    R15,OUTRPL     SAVE OUTPUT RPL ADDRESS
         LA    R15,JPCEMSG    LOAD OUTPUT ACB ADDRESS
         ST    R15,OUTACB     SAVE OUTPUT ACB ADDRESS
ENDGETM  ST    R2,JCTADDR     SAVE JCT ADDRESS
         ST    R6,TEXTSTAR    SAVE TEXT STARTING ADDRESS
         EJECT
***********************************************************************
*        ESTABLISH ESTAE ENVIRONMENT                                  *
***********************************************************************
         MVC   ESTAEL(LESTAEL),ESTAE INITIALIZE ESTAE LIST FORM
         STM   R14,R12,STAEREGS+12 SAVE CURRENT REGISTERS
         LA    R1,ESTAEL      LOAD ADDRESS OF ESTAE LIST FORM
         AIF   ('&TSO' EQ 'YES').TSO9
         AIF   ('&ESTAE' NE 'YES').TSO9
         ESTAE STAEXIT,CT,PARAM=(13),XCTL=NO,PURGE=NONE,ASYNCH=NO,     X
               RECORD=YES,TERM=NO,MF=(E,(1))
.TSO9    ANOP
         LR    R0,R4          RESTORE REG 0
         LTR   R0,R0          INDIVIDUAL ENTRY FOR INTERNAL TEXT
         BZ    CHECKJCT       YES, BRANCH
         B     EOF            GET OUT
         EJECT
***********************************************************************
*        SOME TYPES OF ERRORS DETECTED BY THE CONVERTER TURN ON BITS  *
*        IN THE JCTCNVRC FIELD WHICH WILL FAIL THE JOB WHEN THE       *
*        CONVERTER COMPLETES.  THESE BITS WILL BE TESTED, AND IF      *
*        THE JOB IS TO BE FAILED, ALL WORK AREAS WILL BE FREEMAINED   *
*        AND CONTROL RETURNED TO JES2.                                *
***********************************************************************
CHECKJCT L     R14,JCTADDR    LOAD JCT ADDRESS
         USING JCTDSECT,R14   SET ADDRESSABILITY TO JCT
         LA    R15,JCTCJCL    SET JCL ERROR IN CONVERTER RETURN CODE
         C     R15,JCTCNVRC   TEST CONVERTER RETURN CODE
         BNE   RECORD1        NO, OK, BRANCH
         LA    R15,4          TELL JES2 TO QUIT THIS EXIT
         ST    R15,RETCODE    AND SAVE THE RETURN CODE
         B     ENDOFIT        CONVERTER HAS ALREADY FAILED JOB
         DROP  R14            DROP ADDRESSABILITY TO JCT
         EJECT
***********************************************************************
*        WE MUST DETERMINE IF THE CURRENT STATEMENT IS THE LAST       *
*        STATEMENT FOR THE STEP.  IF THE STATEMENT IS A DD STATEMENT  *
*        AND IT IS THE LAST STATEMENT OF THE STEP, THE TEXT INDICATOR *
*        WILL REFLECT LAST STATEMENT OF THE STEP.  IF, HOWEVER, THE   *
*        CURRENT STATEMENT IS AN EXEC STATEMENT AND IT HAS NO DD      *
*        STATEMENTS, THIS INDICATOR WILL NOT BE ON, SO WE HAVE TO     *
*        CHECK FOR THIS CONDITION ALSO.                               *
***********************************************************************
RECORD1  TM    STRINDCS,LASTSTMT LAST STMT FOR STEP?
         BO    RECORD3        YES, BRANCH
         TM    STRINDCS,EXECSTR EXEC STMT?
         BNO   RECORD2        NO, BRANCH
         TM    STREINDC,ETXNODD STEP HAS NO DD STMTS?
         BO    RECORD3        TRUE, ALSO LAST STMT FOR STEP
***********************************************************************
*        AT THIS POINT THE STMT IS NOT THE LAST STMT FOR STEP         *
***********************************************************************
RECORD2  NI    EOFIND,X'FE'   TURN OFF LAST STMT IND
         B     RECORD4        GET OUT
***********************************************************************
*        AT THIS POINT THE STMT IS THE LAST STMT FOR STEP             *
***********************************************************************
RECORD3  OI    EOFIND,ENDSTEP TURN ON LAST STMT IND
RECORD4  TM    STRINDCS,JOBSTR JOB STATEMENT?
         BO    JOBCARD        YES, BRANCH
         TM    STRINDCS,EXECSTR EXEC STATEMENT?
         BO    EXECARD        YES, BRANCH
         TM    STRINDCS,DDSTR DD STATEMENT?
         BO    DDCARD         YES, BRANCH
         TM    STRINDCS,PROCSTR PROC STATEMENT?
         BO    GETNEXT        YES, BRANCH
         LA    R15,1          SET ERROR NUMBER
         BAL   R14,ERRORTN    GO ISSUE ERROR MSG
         B     GETNEXT        GO GET ANOTHER STATEMENT
         EJECT
***********************************************************************
*        THE TEXT OF THE JOBCARD IS AS FOLLOWS:                       *
*            1)  2 BYTE LENGTH OF TEXT STRING INCLUDING ITSELF        *
*            2)  1 BYTE INDICATOR COMMON TO ALL TEXT RECORDS          *
*            3)  3 BYTES OF MISCELLANEOUS INDICATORS                  *
*            4)  1 BYTE INDICATOR X'B4' INDICATING JOB POS PARAMS     *
*            5)  1 BYTE NUMBER OF POSITIONAL PARAMETERS               *
*                1ST POS PARAM IS JOBNAME                             *
*                2ND POS PARAM IS ACCT PARAM LIST                     *
*                3RD POS PARAM IS PGMR NAME                           *
*            5A) JOBNAME PRECEDED BY A 1 BYTE LENGTH FIELD            *
*            5B) HASP ACCOUNTING PARAMETERS PRECEDED BY A             *
*                1 BYTE LENGTH FIELD LOOKS LIKE THE FOLLOWING         *
*                THE 1ST HALF BYTE IS '8' IF MORE THAN 1 ACCT ENTRY   *
*                IF MORE THAN 1 ACCT ENTRY -                          *
*                THE 2ND HALF BYTE IS THE NUMBER OF ACCT ENTRIES      *
*                FOLLOWED BY A VARIABLE LENGTH LIST OF HASP PARAMETERS*
*                EACH PRECEDED BY A 1 BYTE LENGTH FIELD               *
*                IF ONLY 1 ACCT ENTRY -                               *
*                THE 2ND HALF BYTE IS THE LENGTH OF THE ACCT ENTRY    *
*                FOLLOWED BY THE ACCOUNTING ENTRY                     *
*            5C) PGMR NAME PRECEDED BY A 1 BYTE LENGTH FIELD          *
*            6)  VARIABLE LENGTH LIST OF KEYWORD PARAMETERS           *
*                EACH IS PRECEDED BY A 1 BYTE KEY, 1 BYTE NUMBER OF   *
*                POSITIONAL SUBPARAMETERS PRESENT, AND A LIST OF      *
*                SUBPARAMETERS EACH PRECEDED BY A 1 BYTE LENGTH FIELD *
*                WHICH MAY BE ZERO IF OMITTED AND FOLLOWED BY ANOTHER *
*                POSITIONAL PARAMETER.                                *
***********************************************************************
         EJECT
JOBCARD  EQU   *
***********************************************************************
*        INITIALIZE ENTRY IN TABLE SINCE ONE MUST ALWAYS BE CREATED   *
***********************************************************************
JOBINIT  L     R14,JCTADDR    LOAD JCT ADDRESS
         USING JCTDSECT,R14   SET ADDRESSABILITY TO JCT
         MVI   ENTRYTYP,TYPJOB SET TO JOB ENTRY
         MVI   JENTRY,C' '    BLANK FIRST BYTE OF JOB INFO
         MVC   JENTRY+1(30),JENTRY BLANK ENTIRE JOB INFO
         ST   R7,LASTENT      SAVE ADDR OF LAST ENTRY IN TABLE
         ST   R7,FIRSTENT     SAVE ADDR OF FIRST ENTRY IN TABLE
         XC    CLASSFLD,CLASSFLD ZERO DETERMINED JOB CLASS
         XC    MAXTIME,MAXTIME CLEAR MAXIMUM CPU TIME
         TM    JCTJOBFL,JCTSTCJB IS THIS A STARTED TASK?
         BNO   JOBINIT1       NO, BRANCH
         OI    JOBIND,JOBSTC  TURN ON STC INDICATOR
JOBINIT1 TM    JCTJOBFL,JCTTSUJB IS THIS A TSO USER?
         BNO   JOBINIT2       NO, BRANCH
         OI    JOBIND,JOBTSO  TURN ON TSO INDICATOR
         DROP  R14            DROP ADDRESSABILITY TO JCT
***********************************************************************
*        INITIALIZE MSG HANDLER PARAMETERS ON FIRST ENTRY             *
***********************************************************************
JOBINIT2 LA    R15,1          SET REG TO 1
         ST    R15,CARDNO     SET CARD COUNT TO 1
         XC    MSGCOUNT,MSGCOUNT ZERO MESSAGE COUNTER
         XC    RESOURCE,RESOURCE CLEAR JES2 RESOURCES
         MVI   INCLASS,C'A'   SET INPUT DEFAULT CLASS TO 'A'
         EJECT
***********************************************************************
*        START SCAN OF JOB CARD POSITIONAL PARAMETERS                 *
*            1ST POS PARAM IS ACCT NUMBER UNLESS ONLY 1 ENTRY         *
*            2ND POS PARAM IS BIN LOC UNLESS ONLY 2 ENTRIES           *
*            3RD POS PARAM IS EST TIME UNLESS ONLY 3 ENTRIES          *
*            LAST ENTRY IS ALWAYS PROGRAMMER NAME                     *
***********************************************************************
JOBSTART XC    LASTEXEC,LASTEXEC NO PREVIOUS EXEC CARD
         LA    R2,STRJKEY     LOAD START OF TRUE TEXT
         ST    R2,PARMADDR    SAVE START OF PARAMETER ADDRESS
         LA    R2,1(,R2)      INCR PAST JOB POSITIONAL PARM KEYWORD
         SLR   R15,R15        CLEAR REGISTER FOR IC
         IC    R15,0(R2)      LOAD NUMBER OF POS SUBPARAMS
         CH    R15,H#3        SEE IF THREE (JOBNAME, ACCT, PRMRNAME)
         BNL   JOBCK1         YES, BRANCH
         TM    JOBIND,JOBSTC+JOBTSO ARE ALL PARAMETERS REQUIRED?
         BM    JOBCK1         NO, BRANCH
         LA    R15,2          SET ERROR NUMBER
         BAL   R14,ERRORTN    GO ISSUE ERROR MSG
         B     JOBLOOP        BYPASS FIELDS
JOBCK1   LA    R2,1(,R2)      INCR PAST NUM OF POS SUBPARAMS
JOBNM    SLR   R3,R3          CLEAR REG FOR ICM
         ICM   R3,1,0(R2)     LOAD JOB NAME LENGTH
         BZ    JOBNM2         LENGTH ZERO, DO NOT MOVE
         CH    R3,H#8         SEE IF LENGTH > 8
         BNH   *+16           NO, CONTINUE
         LA    R15,3          SET ERROR NUMBER
         BAL   R14,ERRORTN    GO ISSUE ERROR MSG
         B     JOBLOOP        BYPASS FIELDS
         BCTR  R3,0           MAKE MACHINE LENGTH
         EX    R3,MOVE1       MOVE JOB NAME TO SAVE TABLE
         LA    R3,1(,R3)      RESTORE LENGTH
         CLC   JNAME,C#MOUNT  SEE IF MOUNT
         BNE   JOBNM2         NO, BRANCH
         OI    JOBIND2,MOUNT  SET MOUNT AUTHORITY
JOBNM2   LA    R2,1(R3,R2)    INCREMENT PAST JOB NAME
         TM    JOBIND,JOBSTC+JOBTSO ARE ACCOUNTING/PGMR NAME REQUIRED?
         BM    JOBLOOP        NO, BRANCH
         EJECT
JOBACT   SLR   R4,R4          CLEAR REGISTER FOR ICM
         ICM   R4,1,0(R2)     INSERT CONTROL BYTE
         BNM   JOBACT1        HIGH ORDER BIT NOT ON, ONLY 1 PARAMETER
         N     R4,F#127       'AND' OUT THE HIGH ORDER BIT
         LA    R2,1(,R2)      INCREMENT PAST CONTROL BYTE
         LTR   R4,R4          TEST NUMBER OF ACCOUNTING PARMS
         BNZ   JOBACT2        NOT ZERO, BRANCH
         LA    R15,4          SET ERROR NUMBER
         BAL   R14,ERRORTN    GO ISSUE ERROR MSG
         AIF   ('&BINREQD' NE 'YES').BIN1
         LA    R15,51         SET ERROR NUMBER
         BAL   R14,ERRORTN    GO ISSUE ERROR MSG
.BIN1    ANOP
         B     JOBPGMR        BYPASS ACCOUNTING PROCESSING
JOBACT1  LA    R4,1           SET NUMBER OF ACCOUNTING FIELDS TO 1
         EJECT
***********************************************************************
*        WE ARE CHECKING THE FIRST ACCOUNTING FIELD FOR FORMATTING    *
*        ERRORS.  THE LENGTH OF THE FIRST ACCOUNTING FIELD MUST BE    *
*        7 OR 13 DEPENDING ON WHETHER OR NOT IT IS A TEST JOB IN      *
*        WHICH CASE A SIX CHARACTER PC/70 RESOURCE CODE MUST BE       *
*        ADDED TO THE FIRST 8 CHARACTERS.                             *
*                                                                     *
*        THE FIRST ACCOUNTING FIELD IS FORMATTED AS FOLLOWS:          *
*                                                                     *
*        1)  1 CHARACTER RESOURCE CODE.                               *
*        2)  2 CHARACTER APPLICATION CODE.                            *
*        3)  4 CHARACTER GL COST CENTER NUMBER.                       *
*        4)  6 CHARACTER PC/70 CODE (NOT PRODUCTION)                  *
*                                                                     *
***********************************************************************
JOBACT2  ICM   R3,1,0(R2)     LOAD PARAMETER LENGTH
         BNZ   *+16           NOT ZERO, BRANCH
         LA    R15,35         SET ERROR NUMBER
         BAL   R14,ERRORTN    GO ISSUE ERROR MSG
         B     JOBACT17       BYPASS ACCT NUM
***********************************************************************
*        CHECK THE LENGTH OF THE FIRST ACCOUNTING FIELD FOR           *
*        7 OR 13.                                                     *
***********************************************************************
         CH    R3,H#13        COMPARE LENGTH TO 13
         BE    JOBACT3        ACCT LENGTH = 13, BRANCH
         BL    *+16           ACCT LENGTH < 13, BRANCH
         LA    R15,4          SET ERROR NUMBER
         BAL   R14,ERRORTN    GO ISSUE ERROR MSG
         B     JOBLOOP        BYPASS FIELDS
         CH    R3,H#7         SEE IF ACCT LENGTH = 7
         BE    *+16           YES, BRANCH
         LA    R15,4          SET ERROR NUMBER
         BAL   R14,ERRORTN    GO ISSUE ERROR MSG
         B     JOBACT17       BYPASS FIELD
JOBACT3  BCTR  R3,0           MAKE MACHINE LENGTH
         EX    R3,MOVE2       MOVE ACCT NUM TO SAVE TABLE
         EX    R3,MOVE16      MOVE ACCT NUM TO WORK AREA
         LA    R3,1(,R3)      RESTORE LENGTH
         STC   R3,JACCTLEN    SAVE LENGTH OF ACCT NUM
***********************************************************************
*        CHECK THE FIRST POSITION OF THE FIRST ACCOUNTING FIELD       *
*        FOR ONE OF THE FOLLOWING:                                    *
*        "S" - TECH SUPPORT                                           *
*        "P" - PRODUCTION                                             *
*        "T" - TESTING                                                *
*        "O" - OPERATIONS                                             *
*        "R" - REMOTE TSO                                             *
*        "X" - PARALLEL TEST                                          *
***********************************************************************
         CLI   JACCTNO,C'S'   TECH SUPPORT JOB?
         BE    JOBACT5        YES, BYPASS RESOURCE SETTING
         CLI   JACCTNO,C'P'   PRODUCTION JOB?
         BE    JOBACT10       YES, GO ADD 'PROD' RESOURCE
         CLI   JACCTNO,C'T'   TEST JOB?
         BE    JOBACT4        YES, BRANCH
         CLI   JACCTNO,C'O'   OPERATIONS SUPPORT JOB?
         BE    JOBACT5        YES, BRANCH
         CLI   JACCTNO,C'R'   REMOTE TSO USERS JOB?
         BE    JOBACT5        YES, BRANCH
         CLI   JACCTNO,C'X'   PARALLEL TEST JOB?
         BE    JOBACT5        YES, BRANCH
         LA    R15,36         SET ERROR NUMBER
         BAL   R14,ERRORTN    GO ISSUE ERROR MSG
         B     JOBACT11       BYPASS CHECK
***********************************************************************
*                        T E S T I N G                                *
*                                                                     *
*        1)  THE LENGTH OF THE ACCCOUNTING FIELD MUST BE 13           *
*            TO INCLUDE THE 6 CHARACTER PC/70 FIELD UNLESS THE        *
*            JOB BELONGS TO SEVERAL GROUPS IN WHICH CASE THE          *
*            PC/70 CODE IS OPTIONAL.                                  *
*        2)  THE PC/70 FIELD MUST START WITH 2 ALPHA CHARACTERS       *
*            FOLLOWED BY 4 NUMERIC CHARACTERS.                        *
*        3)  PSEUDO TESTING JOBS DO NOT REQUIRE THE PC/70 FIELD.      *
*                                                                     *
***********************************************************************
JOBACT4  OI    RESOURCE,TESTING YES, ADD 'TESTING' RESOURCE
         CLI   JNAME,C'S'     TECH SUPPORT JOB?
         BE    JOBACT5        YES, PC/70 CODE NOT REQUIRED
         CLI   JNAME,C'R'     REMOTE TSO USER JOB?
         BE    JOBACT5        YES, PC/70 CODE NOT REQUIRED
         CLI   JNAME,C'D'     DATA SECURITY ADMINISTRATOR JOB
         BE    JOBACT5        YES, PC/70 CODE NOT REQUIRED
         CLI   JNAME,C'C'     COMPUTER OPERATIONS JOB?
         BE    JOBACT5        YES, PC/70 CODE NOT REQUIRED
         CLI   JNAME,C'Q'     QUALITY CONTROL JOB?
         BE    JOBACT5        YES, PC/70 CODE NOT REQUIRED
         CLI   JNAME,C'N'     NETWORK CONTROL JOB?
         BE    JOBACT5        YES, PC/70 CODE NOT REQUIRED
         CLI   JNAME,C'A'     AUDITORS JOB?
         BE    JOBACT5        YES, PC/70 CODE NOT REQUIRED
         CLI   JNAME,C'X'     PARALLEL TEST JOB?
         BE    JOBACT5        YES, PC/70 CODE NOT REQUIRED
         CLI   JNAME,C'K'     DATA ENTRY JOB?
         BE    JOBACT5        YES, PC/70 CODE NOT REQUIRED
         CH    R3,H#13        CHECK LENGTH OF ACCOUNTING FIELD
         BE    JOBACT6        YES, BRANCH
         LA    R15,37         SET ERROR NUMBER
         BAL   R14,ERRORTN    GO ISSUE ERROR MSG
         B     JOBACT11       BYPASS CHECK
***********************************************************************
*                    T E C H     S U P P O R T                        *
*                                                                     *
*                      O P E R A T I O N S                            *
*                                                                     *
*                  N O N     P R O D U C T I O N                      *
*                                                                     *
*        1)  THE LENGTH OF THE ACCCOUNTING FIELD CAN BE 13            *
*            TO INCLUDE THE 6 CHARACTER PC/70 FIELD.                  *
*        2)  THE PC/70 FIELD (IF PRESENT) MUST START WITH 2 ALPHA     *
*            CHARACTERS FOLLOWED BY 4 NUMERIC CHARACTERS.             *
***********************************************************************
JOBACT5  CH    R3,H#13        SEE IF PC/70 FIELD PRESENT
         BNE   JOBACT11       NO, BYPASS CHECK
JOBACT6  LA    R1,JACCTNO+7   POINT TO PC/70 FIELD
         LA    R14,2          SET LENGTH OF FIELD
JOBACT7  CLI   0(R1),C'A'     SEE IF LESS THAN 'A'
         BL    JOBACT9        YES, NOT ALPHA
         CLI   0(R1),C'Z'     SEE IF GREATER THAN 'Z'
         BH    JOBACT9        YES, NOT ALPHA
         LA    R1,1(,R1)      INCREMENT TO NEXT POSITION OF ACCT
         BCT   R14,JOBACT7    LOOP UNTIL DONE
         LA    R14,4          SET LENGTH OF FIELD
JOBACT8  CLI   0(R1),C'0'     SEE IF LESS THAN '0'
         BL    JOBACT9        YES, NOT NUMERIC
         CLI   0(R1),C'9'     SEE IF GREATER THAN '9'
         BH    JOBACT9        YES, NOT NUMERIC
         LA    R1,1(,R1)      INCREMENT TO NEXT POSITION OF ACCT
         BCT   R14,JOBACT8    LOOP UNTIL DONE
         B     JOBACT11       GO CHECK REST OF ACCOUNTING FIELD
JOBACT9  LA    R15,38         SET ERROR NUMBER
         BAL   R14,ERRORTN    GO ISSUE ERROR MSG
         B     JOBACT11       GO CHECK REST OF ACCOUNTING FIELD
***********************************************************************
*                     P R O D U C T I O N                             *
*                                                                     *
*        1)  THE PC/70 CODE MUST NOT BE PRESENT                       *
***********************************************************************
JOBACT10 OI    RESOURCE,PROD  ADD 'PRODUCTION' RESOURCE
         CH    R3,H#13        SEE IF PC/70 FIELD PRESENT
         BNE   JOBACT11       NO, BRANCH
         LA    R15,39         SET ERROR NUMBER
         BAL   R14,ERRORTN    GO ISSUE ERROR MSG
***********************************************************************
*                     A L L    J O B S                                *
*                                                                     *
*        1)  THE APPLICATION CODE MUST BE 2 NUMERIC CHARACTERS.       *
*        2)  THE GL COST CENTER NUMBER MUST BE 4 NUMERIC CHARACTERS   *
***********************************************************************
JOBACT11 LA    R1,JACCTNO+1   POINT TO APPLICATION CODE FIELD
         LA    R14,2          SET LENGTH OF FIELD
JOBACT12 CLI   0(R1),C'0'     SEE IF LESS THAN '0'
         BL    JOBACT13       YES, NOT ALPHA
         CLI   0(R1),C'9'     SEE IF GREATER THAN '9'
         BH    JOBACT13       YES, NOT ALPHA
         LA    R1,1(,R1)      INCREMENT TO NEXT POSITION OF ACCT
         BCT   R14,JOBACT12   LOOP UNTIL DONE
         B     JOBACT14       GO CHECK GL COST CENTER NUMBER
JOBACT13 LA    R15,40         SET ERROR NUMBER
         BAL   R14,ERRORTN    GO ISSUE ERROR MSG
JOBACT14 LA    R14,4          SET LENGTH OF FIELD
         LA    R1,JACCTNO+3   POINT TO GL COST CENTER
JOBACT15 CLI   0(R1),C'0'     SEE IF LESS THAN '0'
         BL    JOBACT16       YES, NOT ALPHA
         CLI   0(R1),C'9'     SEE IF GREATER THAN '9'
         BH    JOBACT16       YES, NOT ALPHA
         LA    R1,1(,R1)      INCREMENT TO NEXT POSITION OF ACCT
         BCT   R14,JOBACT15   LOOP UNTIL DONE
         B     JOBACT17       GET OUT
JOBACT16 LA    R15,41         SET ERROR NUMBER
         BAL   R14,ERRORTN    GO ISSUE ERROR MSG
JOBACT17 LA    R2,1(R3,R2)    INCREMENT PAST ACCT
         BCTR  R4,0           REDUCE ACCOUNT PARM COUNT BY 1
         CH    R4,H#1         SEE IF ANOTHER ACCOUNT PARM (BIN NUMBER)
         BL    JOBACT18       NO, ERROR
         IC    R3,0(R2)       LOAD LENGTH OF BIN NUMBER
         LTR   R3,R3          TEST LENGTH OF BIN NUMBER
         BZ    JOBACT18       ZERO, NOT ENTERED
         CH    R3,H#4         TEST LENGTH OF BIN NUMBER
         BE    JOBACT19       FOUR, GOOD, BRANCH
         AIF   ('&BINREQD' NE 'YES').BIN2
         LA    R15,52         SET ERROR NUMBER
         BAL   R14,ERRORTN    GO ISSUE ERROR MSG
.BIN2    ANOP
         B     JOBACT20       CONTINUE PROCESSING ACCOUNTING PARMS
JOBACT18 DS    0H             SET MISSING BIN NUMBER MESSAGE
         AIF   ('&BINREQD' NE 'YES').BIN3
         LA    R15,51         SET ERROR NUMBER
         BAL   R14,ERRORTN    GO ISSUE ERROR MSG
.BIN3    ANOP
         B     JOBPGMR        DONE WITH ACCOUNTING PARMS
JOBACT19 LA    R2,1(R3,R2)    INCREMENT PAST PARM
         IC    R3,0(R2)       LOAD LENGTH OF NEXT PARM
JOBACT20 BCT   R4,JOBACT19    LOOP UNTIL PROCESSED ALL ACCT FIELDS
         EJECT
***********************************************************************
*        SAVE THE PROGRAMMER NAME                                     *
***********************************************************************
JOBPGMR  ICM   R3,1,0(R2)     LOAD PGMR NAME LENGTH
         BZ    PGMREND        ZERO LENGTH, MISSING PARAM
         CH    R3,H#20        SEE IF LENGTH > 20
         BNH   *+16           NO, CONTINUE
         LA    R15,5          SET ERROR NUMBER
         BAL   R14,ERRORTN    GO ISSUE ERROR MSG
         B     JOBLOOP        BYPASS FIELDS
         CH    R3,H#10        SEE IF LENGTH > 10
         BNH   PGMR10         IF NOT > 10, OK
         LH    R3,H#10        MAKE LENGTH = 10
PGMR10   BCTR  R3,0           MAKE MACHINE LENGTH
         EX    R3,MOVE3       MOVE PGMR NAME TO SAVE TABLE
         ICM   R3,1,0(R2)     RELOAD PGMR NAME LENGTH
         EJECT
***********************************************************************
*        COMPARE THE RESOURCE CODE IN THE ACCOUNTING TO THE JOB       *
*        AUTHORITY INDICATED BY THE FIRST POSITION OF THE JOB NAME.   *
*        VALID COMBINATIONS ARE AS FOLLOWS:                           *
*                                                                     *
*        1)  RESOURCE CODE = S                                        *
*            A)  "SUPPORT"      JOBS                                  *
*                                                                     *
*        2)  RESOURCE CODE = P                                        *
*            A)  "PRODUCTION"   JOBS                                  *
*            B)  "OPERATIONS"   JOBS                                  *
*                                                                     *
*        3)  RESOURCE CODE = T                                        *
*            A)  "TEST"         JOBS                                  *
*            B)  "OPERATIONS"   JOBS                                  *
*            C)  "REMOTE USERS" JOBS                                  *
*            D)  "SUPPORT"      JOBS                                  *
*            E)  "DATA SEC ADM" JOBS                                  *
*            F)  "COMP OPNS"    JOBS                                  *
*            G)  "QUALITY CTL"  JOBS                                  *
*            H)  "NETWORK CTL"  JOBS                                  *
*            I)  "AUDITORS"     JOBS                                  *
*            J)  "DATA ENTRY"   JOBS                                  *
*                                                                     *
*        4)  RESOURCE CODE = O                                        *
*            A)  "OPERATIONS"   JOBS                                  *
*                                                                     *
*        5)  RESOURCE CODE = R                                        *
*            A)  "REMOTE USERS" JOBS                                  *
*            B)  "OPERATIONS"   JOBS                                  *
*            C)  "TECH SUPPORT" JOBS                                  *
*                                                                     *
*        6)  RESOURCE CODE = X                                        *
*            A)  "PARALLEL TST" JOBS                                  *
*                                                                     *
***********************************************************************
PGMREND  CLI   JACCTNO,C'S'   IS THIS A TECH SUPPORT JOB?
         BNE   CKAUTH1        NO, BRANCH
         OI    JOBIND,JOBTECH TURN ON TECH SUPPORT INDICATOR
         CLI   JNAME,C'S'     SEE IF JOBNAME CHARACTER OK
         BE    CKAUTH7        YES, BRANCH
         B     CKAUTH6        NO, ERROR
CKAUTH1  CLI   JACCTNO,C'P'   IS THIS A PRODUCTION JOB?
         BNE   CKAUTH2        NO, BRANCH
         OI    JOBIND,JOBPROD TURN ON PRODUCTION JOB INDICATOR
         CLI   JNAME,C'P'     SEE IF JOBNAME CHARACTER OK
         BE    CKAUTH7        YES, BRANCH
         CLI   JNAME,C'O'     SEE IF JOBNAME CHARACTER OK
         BE    CKAUTH7        YES, BRANCH
         B     CKAUTH6        NO, ERROR
CKAUTH2  CLI   JACCTNO,C'T'   IS THIS A TEST JOB?
         BNE   CKAUTH3        NO, BRANCH
         OI    JOBIND,JOBTEST TURN ON TEST JOB INDICATOR
         CLI   JNAME,C'T'     SEE IF JOBNAME CHARACTER OK
         BE    CKAUTH7        YES, BRANCH
         CLI   JNAME,C'O'     SEE IF JOBNAME CHARACTER OK
         BE    CKAUTH7        YES, BRANCH
         CLI   JNAME,C'S'     SEE IF JOBNAME CHARACTER OK
         BE    CKAUTH7        YES, BRANCH
         CLI   JNAME,C'D'     SEE IF JOBNAME CHARACTER OK
         BE    CKAUTH7        YES, BRANCH
         CLI   JNAME,C'C'     SEE IF JOBNAME CHARACTER OK
         BE    CKAUTH7        YES, BRANCH
         CLI   JNAME,C'Q'     SEE IF JOBNAME CHARACTER OK
         BE    CKAUTH7        YES, BRANCH
         CLI   JNAME,C'N'     SEE IF JOBNAME CHARACTER OK
         BE    CKAUTH7        YES, BRANCH
         CLI   JNAME,C'A'     SEE IF JOBNAME CHARACTER OK
         BE    CKAUTH7        YES, BRANCH
         CLI   JNAME,C'K'     SEE IF JOBNAME CHARACTER OK
         BE    CKAUTH7        YES, BRANCH
         B     CKAUTH6        NO, ERROR
CKAUTH3  CLI   JACCTNO,C'O'   IS THIS A OPERATIONS JOB?
         BNE   CKAUTH4        NO, BRANCH
         OI    JOBIND,JOBOPER TURN ON OPERATIONS JOB INDICATOR
         CLI   JNAME,C'O'     SEE IF JOBNAME CHARACTER OK
         BE    CKAUTH7        YES, BRANCH
         B     CKAUTH6        NO, ERROR
CKAUTH4  CLI   JACCTNO,C'R'   IS THIS A REMOTE USERS JOB?
         BNE   CKAUTH5        NO, BRANCH
         OI    JOBIND,JOBTEST TURN ON TEST JOB INDICATOR
         CLI   JNAME,C'R'     SEE IF JOBNAME CHARACTER OK
         BE    CKAUTH7        YES, BRANCH
         CLI   JNAME,C'O'     SEE IF JOBNAME CHARACTER OK
         BE    CKAUTH7        YES, BRANCH
         CLI   JNAME,C'S'     SEE IF JOBNAME CHARACTER OK
         BE    CKAUTH7        YES, BRANCH
         B     CKAUTH6        NO, ERROR
CKAUTH5  CLI   JACCTNO,C'X'   IS THIS A PARALLEL TEST JOB?
         BNE   CKAUTH7        NO, BRANCH
         OI    JOBIND,JOBTEST TURN ON TEST JOB INDICATOR
         CLI   JNAME,C'X'     SEE IF JOBNAME CHARACTER OK
         BE    CKAUTH7        YES, BRANCH
         B     CKAUTH6        NO, ERROR
CKAUTH6  LA    R15,42         SET ERROR NUMBER
         BAL   R14,ERRORTN    GO ISSUE ERROR MSG
CKAUTH7  B     JOBLOOP        LOOP FOR NEXT PARAMETER
         EJECT
***********************************************************************
*        WE ARE LOOKING FOR INVALID KEYWORDS OR KEYWORDS HAVING       *
*        ILLEGAL VALUES OR OTHER THAN DEFAULT                         *
***********************************************************************
*
***********************************************************************
*        KEYWORD ENTRIES ARE NORMALLY AS FOLLOWS:                     *
*            1)  1 BYTE HEX KEYWORD                                   *
*            2)  1 BYTE NUMBER OF SUBPARAMETERS                       *
*            3)  LIST OF POSITIONAL SUBPARAMETERS EACH PRECEDED BY A  *
*                1 BYTE LENGTH FIELD                                  *
*        THERE ARE OCCASIONS WHEN THE POSITIONAL SUBPARAMETERS WILL   *
*        HAVE POSITIONAL SUBPARAMETERS THEMSELVES                     *
*        THIS WILL BE FLAGGED IN THE LENGTH FIELD FOR THAT SUBPARAM   *
*        BY A HIGH ORDER BIT IN THE FIELD.  IN THIS CASE, THIS IS NOT *
*        A LENGTH FIELD, BUT A COUNT OF SUBPARAMETERS, WHICH WILL BE  *
*        A LIST OF PARAMETERS, EACH PRECEDED BY A 1 BYTE LENGTH FIELD.*
*        THUS THE ENTRY FOR A SUBPARAMETER WITH SUBPARAMETERS WILL    *
*        APPEAR AS FOLLOWS:                                           *
*            1)  A 1 BYTE NUMBER OF SUBPARAMS AS INDICATED BY A       *
*                HIGH ORDER BIT                                       *
*            2)  A LIST OF SUBPARAMETERS EACH PRECEDED BY A 1 BYTE    *
*                LENGTH FIELD                                         *
***********************************************************************
*
JOBPARMS CLI   0(R2),ENDK     END OF TEXT STRING?????
         BNE   JCLASS         NO, BRANCH
***********************************************************************
*        IF THE JOB CPU TIME LIMIT WAS NOT SPECIFIED ON THE JOB       *
*        CARD, AN INTERNAL TEXT KEY WITH 1 MINUTE OF CPU TIME         *
*        WILL BE ADDED TO THE TEXT FOR THE JOB CARD TO SET THE        *
*        JOBS DEFAULT TIME TO 1 MINUTE.                               *
***********************************************************************
         L     R15,MAXTIME    LOAD TIME FROM JOB CARD
         CH    R15,H#0        SEE IF DEFAULT (NOT ENTERED)
         BNE   GETNEXT        NO, BRANCH
         TM    JOBIND,JOBSTC+JOBTSO SEE IF STC OR TSO
         BM    GETNEXT        YES, DO NOT RESET CPU TIME
         MVC   MAXTIME,F#1    SET DEFAULT CPU TIME
         MVC   0(8,R2),DEFTIME SET DEFAULT CPU TIME TO 1
         L     R6,TEXTSTAR    RELOAD START OF TEXT STRING
         SLR   R3,R3          CLEAR REG FOR ICM
         ICM   R3,3,STRLTH    LOAD TEXT STRING LENGTH
         AH    R3,H#8         ADD LENGTH OF CPU TIME FIELD
         STCM  R3,3,STRLTH    SAVE NEW STRING LENGTH
         BE    GETNEXT        YES, GO GET ANOTHER STRING
         EJECT
***********************************************************************
*        JOB CLASS                                                    *
***********************************************************************
JCLASS   CLI   0(R2),CLASSJK  SEE IF CLASS=KEY
         BNE   JPERF          NO, BRANCH
         MVC   INCLASS,3(R2)  SAVE INPUT CLASS
         B     JOBLOOP        GO GET NEXT PARAM
         EJECT
***********************************************************************
*        JOB PERFORM                                                  *
***********************************************************************
JPERF    CLI   0(R2),PRFMJK   SEE IF PERFORM= KEY
         BNE   JADDR          NO, BRANCH
         TM    JOBIND,JOBSTC  SEE IF ALLOWED
         BO    JOBLOOP        YES, PERFORM OK ON JOB CARD
         LA    R15,6          SET ERROR NUMBER
         BAL   R14,ERRORTN    GO ISSUE ERROR MSG
         B     JOBLOOP        BYPASS FIELDS
         EJECT
***********************************************************************
*        JOB ADDRSPC                                                  *
***********************************************************************
JADDR    CLI   0(R2),ADRSPJK  SEE IF ADDRSPC= KEY
         BNE   JPRTY          NO, BRANCH
         TM    JOBIND,JOBPROD SEE IF ALLOWED
         BO    JOBLOOP        YES, ADDRSPC OK ON JOB CARD
         LA    R15,7          SET ERROR NUMBER
         BAL   R14,ERRORTN    GO ISSUE ERROR MSG
         B     JOBLOOP        BYPASS FIELDS
         EJECT
***********************************************************************
*        JOB PRTY                                                     *
***********************************************************************
JPRTY    CLI   0(R2),PRTYJK   SEE IF PRTY= KEY
         BNE   JESTIME        NO, BRANCH
         LA    R2,1(,R2)      INCREMENT PAST KEYWORD DESCR
         SLR   R4,R4          CLEAR REGISTER FOR ICM
         ICM   R4,1,0(R2)     INSERT NUMBER OF SUBPARAMETERS
         BZ    JOBLOOP        NONE, IGNORE
         LA    R2,1(,R2)      INCREMENT PAST CONTROL BYTE
         SLR   R3,R3          CLEAR REGISTER FOR ICM
         ICM   R3,1,0(R2)     LOAD LENGTH OF PRTY VALUE
         BZ    JOBLOOP        ZERO, NULL VALUE, EXIT
         BCTR  R3,0           MAKE MACHINE LENGTH
         EX    R3,PACK6       PACK PRTY
         CP    DOUBLE,P#0     SEE IF PRTY=0
         BE    JOBLOOP        YES, DEFAULT, ALWAYS OK
         TM    JOBIND,JOBTECH+JOBPROD+JOBSTC SEE IF ALLOWED
         BM    JOBLOOP        YES, PRTY OK ON JOB CARD
*        B     JOBLOOP        ALLOW EVERYONE TO USE PRTY     OVERRIDE
         LA    R15,49         SET ERROR NUMBER
         BAL   R14,ERRORTN    GO ISSUE ERROR MSG
         B     JOBLOOP        BYPASS FIELDS
         EJECT
***********************************************************************
*        JOB TIME                                                     *
***********************************************************************
JESTIME  CLI   0(R2),TIMEJK   SEE IF TIME= KEY
         BNE   JREGN          NO, BRANCH
         LA    R2,1(,R2)      INCREMENT PAST KEYWORD DESCR
         SLR   R4,R4          CLEAR REGISTER FOR ICM
         ICM   R4,1,0(R2)     INSERT NUMBER OF SUBPARAMETERS
         BZ    JOBLOOP        NONE, IGNORE
         MVC   MAXTIME,F#1    SET DEFAULT CPU TIME
         LA    R2,1(,R2)      INCREMENT PAST CONTROL BYTE
         SLR   R3,R3          CLEAR REGISTER FOR ICM
         ICM   R3,1,0(R2)     LOAD LENGTH OF FIRST TIME FIELD
         BZ    JOBLOOP        ZERO, ONLY SECONDS ENTERED, EXIT
         LA    R4,1(,R2)      SAVE LOCATION OF TIME
         LR    R5,R3          SAVE LENGTH OF TIME
JESTIME1 CLI   0(R4),C'0'     SEE IF LESS THAN ZERO
         BL    JESTIME2       YES, NOT NUMERIC, ERROR
         CLI   0(R4),C'9'     SEE IF GREATER THAN NINE
         BH    JESTIME2       YES, NOT NUMERIC, ERROR
         LA    R4,1(,R4)      INCREMENT TO NEXT DIGIT OF REGION
         BCT   R5,JESTIME1    LOOP UNTIL DONE
         BCTR  R3,0           MAKE MACHINE LENGTH
         EX    R3,PACK5       PACK TIME
         CVB   R15,DOUBLE     CONVERT TO BINARY
         CH    R15,H#0        SEE IF ZERO
         BE    JOBLOOP        ZERO, ONLY SECONDS ENTERED, EXIT
         ST    R15,MAXTIME    SAVE CPU TIME
         CH    R15,H#1440     SEE IF TIME = 1440
         BNE   JOBLOOP        NO, BRANCH
         TM    JOBIND,JOBSTC+JOBTECH SEE IF ALLOWED
         BM    JOBLOOP        YES, TIME=1440 OK ON JOB CARD
         LA    R15,9          SET ERROR NUMBER
         BAL   R14,ERRORTN    GO ISSUE ERROR MSG
         B     JOBLOOP        GET OUT
JESTIME2 LA    R15,8          SET ERROR NUMBER
         BAL   R14,ERRORTN    GO ISSUE ERROR MSG
         B     JOBLOOP        GET OUT
         EJECT
***********************************************************************
*        JOB REGION                                                   *
***********************************************************************
JREGN    CLI   0(R2),REGINJK  SEE IF REGION= KEY
         BNE   JTYPRUN        NO, BRANCH
         TM    JOBIND,JOBTSO  SEE IF ALLOWED
         BO    JOBLOOP        YES, REGION OK ON JOB CARD
         TM    STRJINDC,JTXREGDF SEE IF REGION WAS BY DEFAULT
         BO    JOBLOOP        YES, BRANCH
         LA    R15,10         SET ERROR NUMBER
         BAL   R14,ERRORTN    GO ISSUE ERROR MSG
         B     JOBLOOP        GET OUT
         EJECT
***********************************************************************
*        JOB TYPRUN                                                   *
***********************************************************************
JTYPRUN  CLI   0(R2),TYPRUNJK SEE IF TYPRUN= KEY
         BNE   JOBLOOP        NO, BRANCH
         LA    R2,1(,R2)      INCREMENT PAST KEYWORD DESCR
         SLR   R4,R4          CLEAR REGISTER FOR ICM
         ICM   R4,1,0(R2)     INSERT NUMBER OF SUBPARAMETERS
         BZ    JOBLOOP        NONE, IGNORE
         LA    R2,1(,R2)      INCREMENT PAST CONTROL BYTE
         SLR   R3,R3          CLEAR REGISTER FOR ICM
         ICM   R3,1,0(R2)     LOAD LENGTH OF FIRST VALUE FIELD
         CH    R3,H#4         SEE IF CORRECT LENGTH
         BNE   JOBLOOP        NO, EXIT
         CLC   1(4,R2),C#HOLD SEE IF TYPRUN=HOLD
         BNE   JOBLOOP        NO, EXIT
         OI    JOBIND2,HELD   TURN ON HELD INDICATOR
         B     JOBLOOP        GET OUT
         EJECT
***********************************************************************
*        THIS ROUTINE WILL INCREMENT PAST THE STRING(S) BEING         *
*        PROCESSED.  NOTE THAT FOLLOWING THE KEYWORD DESCRIPTOR       *
*        FIELD IS A COUNT OF SUBPARAMETERS.  FOLLOWING THE COUNT      *
*        WILL BE A LENGTH OR DESCRIPTOR FIELD.  IF THE HIGH ORDER     *
*        BIT IS ON, THE FIELD IS A COUNT FIELD OF THE NUMBER OF       *
*        SUBPARAMETERS WHICH THE SUBPARAMETER ITSELF MAY HAVE.        *
*        IF THIS IS TRUE, THE DESCRIPTOR FIELD WILL BE FOLLOWED BY    *
*        A LENGTH FIELD FOR THE FIRST SUBPARAMETER.  IF THE HIGH      *
*        ORDER BIT IS NOT ON, IT IS ONLY A LENGTH FIELD FOR A         *
*        SINGLE SUBPARAMETER.                                         *
***********************************************************************
JOBLOOP  L     R2,PARMADDR    RESTORE START OF PARAMETER ADDRESS
         SLR   R5,R5          CLEAR REGISTER FOR ICM
         LA    R2,1(,R2)      INCREMENT PAST KEYWORD
         ICM   R5,1,0(R2)     LOAD SUBPARAMETER COUNT
         BNZ   JOBLOOP1       OK, BRANCH INTO ROUTINE
         LA    R2,1(,R2)      NONE, INCREMENT PAST COUNT
         B     JOBLOOP5       AND GET OUT OF ROUTINE
JOBLOOP1 LA    R2,1(,R2)      INCREMENT PAST KEYWORD DESCR
JOBLOOP2 SLR   R4,R4          CLEAR REGISTER FOR ICM
         ICM   R4,1,0(R2)     LOAD PARAMETER LENGTH
         BNM   JOBLOOP3       HIGH BIT NOT ON, ONLY 1 PARAMETER
         N     R4,F#127       'AND' OUT THE HIGH ORDER BIT
         LA    R2,1(,R2)      INCREMENT PAST CONTROL BYTE
         B     JOBLOOP4       BRANCH
JOBLOOP3 LA    R4,1           SET PARAM COUNT TO 1
JOBLOOP4 SLR   R3,R3          CLEAR REGISTER FOR ICM
         ICM   R3,1,0(R2)     LOAD PARAMETER LENGTH
         LA    R2,1(R3,R2)    INCREMENT PAST PARM
         BCT   R4,JOBLOOP4    LOOP UNTIL PROCESSED ALL PARMS
         BCT   R5,JOBLOOP2    LOOP UNTIL PROCESSED ALL PARMS
JOBLOOP5 ST    R2,PARMADDR    SAVE START OF PARAMETER ADDRESS
         B     JOBPARMS       CONTINUE
         EJECT
***********************************************************************
*        THE TEXT OF THE EXEC CARD TEXT IS AS FOLLOWS                 *
*            1)  2 BYTE LENGTH OF TEXT STRING INCLUDING ITSELF        *
*            2)  1 BYTE INDICATOR COMMON TO ALL TEXT RECORDS          *
*            3)  1 BYTE OF MISCELLANEOUS INDICATORS                   *
*            4)  1 BYTE INDICATOR X'94' INDICATING EXEC POS INFORMATN *
*            5)  1 BYTE NUMBER OF EXEC POSITIONAL PARAMETERS          *
*                THE 1ST POS PARAMETER IS THE STEP NAME               *
*                ALL OTHER POS PARAMETERS WILL BE IGNORED             *
*            6)  VARIABLE LENGTH LIST OF EXEC POS PARAMETERS          *
*                EACH PRECEDED BY A 1 BYTE LENGTH FIELD               *
*            7)  VARIABLE LENGTH LIST OF KEYWORD PARAMETERS           *
*                EACH IS PRECEDED BY A 1 BYTE KEY, 1 BYTE NUMBER OF   *
*                POSITIONAL SUBPARAMETERS PRESENT, AND A LIST OF      *
*                SUBPARAMETERS EACH PRECEDED BY A 1 BYTE LENGTH FIELD *
*                WHICH MAY BE ZERO IF OMITTED AND FOLLOWED BY ANOTHER *
*                POSITIONAL PARAMETER.                                *
***********************************************************************
         EJECT
EXECARD  EQU   *
***********************************************************************
*        UPDATE LAST EXEC TABLE (IF NEEDED) WITH UNIT INFO            *
***********************************************************************
EXECUPDT L    R7,LASTEXEC     LOAD ADDR OF LAST EXEC ENTRY
         LTR  R7,R7           SEE IF ADDR = 0
         BZ    EUPDT1         IF ZERO, NO UPDATE, BRANCH
         MVC   ETAPES,TAPECNT MOVE STEP TAPE UNIT CNT TO TABLE
         MVC   EPRIVS,PRIVCNT MOVE STEP PRIV UNIT CNT TO TABLE
         XC    TAPECNT,TAPECNT ZERO TAPE UNIT CNT
         XC    PRIVCNT,PRIVCNT ZERO PRIV UNIT CNT
         XC    LASTEXEC,LASTEXEC ZERO ADDR OF LAST EXEC ENTRY
EUPDT1   TM    STREINDC,ETXPRCV STATEMENT INVOKE A PROCEDURE?
         BO    PROCARD        YES, BRANCH
         EJECT
***********************************************************************
*        INITIALIZE NEW STEP ENTRY IN TABLE                           *
***********************************************************************
EXECINIT LH    R15,ENTCOUNT   LOAD TABLE ENTRY COUNT
         LA    R15,1(,R15)    ADD 1 TO COUNT
         CH    R15,MAXENTS    SEE IF MAXIMUM REACHED
         BNL   TBLFULL        MAXIMUM REACHED, TAKE DUMP & EXIT
         STH   R15,ENTCOUNT   STORE NEW ENTRY COUNT
         L    R7,LASTENT      LOAD ADDR OF LAST ENTRY IN TABLE
         LA   R7,ENTLEN(,R7) INCREMENT TO NEXT ENTRY
         ST   R7,LASTENT      SAVE ADDR OF LAST ENTRY IN TABLE
         ST   R7,LASTEXEC     SAVE ADDR OF LAST EXEC ENTRY
         MVI   ENTRYTYP,TYPEXEC SET TO EXEC ENTRY
         MVI   EENTRY,C' ' BLANK 1ST BYTE OF EXEC INFO
         MVC   EENTRY+1(23),EENTRY BLANK MOST OF EXEC INFO
         XC    ELIBIND(7),ELIBIND ZERO REST OF EXEC INFO
         MVC   EREGION,H#512  SET DEFAULT REGION SIZE TO 512K
         TM    STREINDC,ETXPROC STATEMENT FROM A PROC??
         BNO   EINIT1         NO, BRANCH
         MVC   EJSTEP,SAVEPROC MOVE JOB STEP NAME TO TABLE
EINIT1   TM    STREINDC,ETXSTPLB STEP HAVE STEPLIB DD??
         BNO   EINIT2         NO, BRANCH
         OI    ELIBIND,ESTEPLIB SET INDICATOR IN TABLE
EINIT2   TM    JOBIND,JOBLIB  DOES JOB HAVE JOBLIB??
         BNO   EXECSTAR       NO, BRANCH
         OI    ELIBIND,EJOBLIB SET INDICATOR IN TABLE
         EJECT
EXECSTAR MVC   ECARDNO,CARDNO SAVE CARD NUMBER OF THIS STATEMENT
         LA    R2,STREKEY     LOAD START OF TRUE TEXT
         ST    R2,PARMADDR    SAVE START OF PARAMETER ADDRESS
EXECPARM CLI   0(R2),ENDK     END OF TEXT STRING?????
         BE    PROCSEAR       YES, GO SEE IF FROM A PROC
         EJECT
***********************************************************************
*        EXEC STEPNAME                                                *
***********************************************************************
ESTEPN   CLI   0(R2),EXECK    SEE IF STEPNAME KEY
         BNE   EPGM           NO, BRANCH
         SLR   R4,R4          CLEAR REG FOR ICM
         ICM   R4,1,1(R2)     LOAD NUMBER OF SUBPARAMS
         BZ    EXELOOP        ZERO, NO STEP NAME
         SLR   R3,R3          CLEAR REG FOR ICM
         ICM   R3,1,2(R2)     LOAD LENGTH OF 1ST POS SUBPARAM
         BZ    EXELOOP        ZERO, NO STEP NAME, BRANCH
         CH    R3,H#8         SEE IF MAX LENGTH EXCEEDED
         BNH   *+16           NO, CONTINUE
         LA    R15,11         SET ERROR NUMBER
         BAL   R14,ERRORTN    GO ISSUE ERROR MSG
         B     EXELOOP        GET OUT
         BCTR  R3,0           MAKE MACHINE LENGTH
         TM    STREINDC,ETXPROC STATEMENT FROM A PROC
         BO    ESTEPN1        YES, THEN NAME IS PROC STEP NAME
         EX    R3,MOVE5       MOVE NAME TO JOBSTEP NAME
         B     EXELOOP        BRANCH
ESTEPN1  EX    R3,MOVE6       MOVE NAME TO PROCSTEP NAME
         B     EXELOOP        BRANCH
         EJECT
***********************************************************************
*        EXEC PGM                                                     *
***********************************************************************
EPGM     CLI   0(R2),PGMEK    SEE IF PGM= KEY
         BNE   EREGN          NO, BRANCH
         SLR   R3,R3          CLEAR REG FOR ICM
         ICM   R3,1,2(R2)     LOAD LENGTH OF PGM NAME
         BZ    EXELOOP        ZERO, NULL, BRANCH
         BM    EXELOOP        HIGH BIT ON, REFERBACK, IGNORE
         CH    R3,H#8         SEE IF LENGTH > 8
         BNH   *+16           NO, CONTINUE
         LA    R15,12         SET ERROR NUMBER
         BAL   R14,ERRORTN    GO ISSUE ERROR MSG
         B     EXELOOP        GET OUT
         BCTR  R3,0           MAKE MACHINE LENGTH
         EX    R3,MOVE7       MOVE PGM NAME TO TABLE
         SPACE
         CLC   PGMCICS,3(R2)  Q. CICS PGM NAME ?
         BNE   CHK7074        NO, TRY 7074
         OI    RESOURCE+1,PCICS YES, ATTACH 'CICS' RESOURCE
         B     EXELOOP        & GET NEXT EXEC PARM
CHK7074  CLC   PGM7074,3(R2)  Q. PGM NAME 7074 ?
         BNE   CHK1401        NO, TRY 1401
         OI    RESOURCE+1,P7074 YES,ATTACH '7074' RESOURCE
         B     EXELOOP        & GET NEXT EXEC PARM
CHK1401  CLC   PGM1401,3(R2)  Q. PGM NAME 1401 ?
         BNE   CHKXMIT        NO, TRY XMISSIONS
         OI    RESOURCE,P1401 YES, ATTACH '1401' RESOURCE
         B     EXELOOP        & GET NEXT EXEC PARM
CHKXMIT  CLC   PGMXMIT,3(R2)  Q. PGM NAME XMISSIONS ?
         BNE   EXELOOP        NO, GET NEXT EXEC PARM
         OI    RESOURCE+1,PXMIT YES, ATTACH 'XMIT' RESOURCE
         B     EXELOOP        BRANCH
         EJECT
***********************************************************************
*        EXEC REGION                                                  *
***********************************************************************
EREGN    CLI   0(R2),REGINEEK SEE IF REGION= KEY
         BNE   EREGN@         NO, BRANCH
         LA    R2,1(,R2)      INCREMENT PAST KEYWORD
         SLR   R3,R3          CLEAR REG FOR ICM
         ICM   R3,1,0(R2)     LOAD SUBPARAMETER COUNT
         BZ    EXELOOP        NO SUBPARAMETERS, BRANCH
         LA    R2,1(,R2)      INCREMENT PAST NUMBER OF FIELDS
         ICM   R3,1,0(R2)     LOAD LENGTH OF REGION PARAM
         BZ    EXELOOP        ZERO, NULL, BRANCH
         CH    R3,H#8         SEE IF MAX LENGTH EXCEEDED
         BNH   *+16           NO, CONTINUE
         LA    R15,13         SET ERROR NUMBER
         BAL   R14,ERRORTN    GO ISSUE ERROR MSG
         B     EXELOOP        GET OUT
         CH    R3,H#3         SEE IF AT LEAST 3 CHARACTERS
         BL    EXELOOP        NO, MAX IS 99K, IGNORE
         LA    R15,0(R3,R2)   POINT TO LAST CHAR OF REGION SIZE
         NI    ELIBIND,255-EREGIONK TURN OFF REGION SIZE IN 'K' IND
         CLI   0(R15),C'K'    END IN 'K'
         BNE   EREGN1         NO, BRANCH
         BCTR  R3,0           REDUCE REGION LENGTH BY 1
         OI    ELIBIND,EREGIONK REMEMBER REGION SIZE IN 'K'
EREGN1   LA    R4,1(,R2)      SAVE LOCATION OF REGION
         LR    R5,R3          SAVE LENGTH OF REGION
EREGN2   CLI   0(R4),C'0'     SEE IF LESS THAN ZERO
         BL    EREGN4         YES, NOT NUMERIC, ERROR
         CLI   0(R4),C'9'     SEE IF GREATER THAN NINE
         BH    EREGN4         YES, NOT NUMERIC, ERROR
         LA    R4,1(,R4)      INCREMENT TO NEXT DIGIT OF REGION
         BCT   R5,EREGN2      LOOP UNTIL DONE
         BCTR  R3,0           MAKE MACHINE LENGTH
         EX    R3,PACK1       PACK REGION SIZE
         CVB   R15,DOUBLE     CONVERT REGION SIZE TO BINARY
         TM    ELIBIND,EREGIONK WAS REGION SPECIFIED IN 'K'
         BO    EREGN3         YES, BRANCH
         SRA   R15,10         DIVIDE BY 1024 FOR 'K' VALUE
EREGN3   STH   R15,EREGION    STORE REGION SIZE IN TABLE
         B     EXELOOP        BRANCH
EREGN4   LA    R15,14         SET ERROR NUMBER
         BAL   R14,ERRORTN    GO ISSUE ERROR MSG
         B     EXELOOP        GET OUT
         EJECT
***********************************************************************
*        EXEC REGION.                                                 *
***********************************************************************
EREGN@   CLI   0(R2),REGINPEK SEE IF REGION. KEY
         BNE   ETIME          NO, BRANCH
         LA    R2,1(,R2)      INCREMENT PAST KEYWORD
         SLR   R4,R4          ZERO REGISTER
         ICM   R4,1,0(R2)     LOAD NUMBER OF SUBPARAMS
         BNZ   *+16           NOT ZERO, BRANCH
         LA    R15,13         SET ERROR NUMBER
         BAL   R14,ERRORTN    GO ISSUE ERROR MSG
         B     EXELOOP        GET OUT
         CH    R4,H#2         CHECK NUMBER OF SUBPARAMS
         BNH   *+16           NOT > 2, OK
         LA    R15,13         SET ERROR NUMBER
         BAL   R14,ERRORTN    GO ISSUE ERROR MSG
         B     EXELOOP        GET OUT
         LA    R2,1(,R2)      INCREMENT PAST NUMBER OF SUBPARAMETERS
         SLR   R3,R3          ZERO REGISTER
         ICM   R3,1,0(R2)     LOAD LENGTH OF STEPNAME
         BNZ   *+16           NOT ZERO, BRANCH
         LA    R15,13         SET ERROR NUMBER
         BAL   R14,ERRORTN    GO ISSUE ERROR MSG
         B     EXELOOP        GET OUT
         CH    R3,H#8         SEE IF MAX LENGTH EXCEEDED
         BNH   *+16           NO, CONTINUE
         LA    R15,13         SET ERROR NUMBER
         BAL   R14,ERRORTN    GO ISSUE ERROR MSG
         B     EXELOOP        GET OUT
         BCTR  R3,0           MAKE MACHINE LENGTH
         EX    R3,COMPARE3    SEE IF OVERRIDE FOR CURRENT STEP
         BNE   EXELOOP        NO, GET OUT
         LA    R2,2(R2,R3)    SET REG TO START OF 2ND PARAM
         ICM   R3,1,0(R2)     LOAD LENGTH OF 2ND PARAM
         BZ    EXELOOP        ZERO, NULL, BRANCH
         CH    R3,H#8         SEE IF MAX LENGTH EXCEEDED
         BNH   *+16           NO, CONTINUE
         LA    R15,13         SET ERROR NUMBER
         BAL   R14,ERRORTN    GO ISSUE ERROR MSG
         B     EXELOOP        GET OUT
         CH    R3,H#3         SEE IF AT LEAST 3 CHARACTERS
         BL    EXELOOP        NO, MAX IS 99K, IGNORE
         LA    R15,0(R3,R2)   POINT TO LAST CHAR OF REGION SIZE
         NI    ELIBIND,255-EREGIONK TURN OFF REGION SIZE IN 'K' IND
         CLI   0(R15),C'K'    END IN 'K'
         BNE   EREGN@1        NO, BRANCH
         BCTR  R3,0           REDUCE REGION LENGTH BY 1
         OI    ELIBIND,EREGIONK REMEMBER REGION SIZE IN 'K'
EREGN@1  LA    R4,1(,R2)      SAVE LOCATION OF REGION
         LR    R5,R3          SAVE LENGTH OF REGION
EREGN@2  CLI   0(R4),C'0'     SEE IF LESS THAN ZERO
         BL    EREGN@4        YES, NOT NUMERIC, ERROR
         CLI   0(R4),C'9'     SEE IF GREATER THAN NINE
         BH    EREGN@4        YES, NOT NUMERIC, ERROR
         LA    R4,1(,R4)      INCREMENT TO NEXT DIGIT OF REGION
         BCT   R5,EREGN@2     LOOP UNTIL DONE
         BCTR  R3,0           MAKE MACHINE LENGTH
         EX    R3,PACK4       PACK REGION SIZE
         CVB   R15,DOUBLE     CONVERT REGION SIZE TO BINARY
         TM    ELIBIND,EREGIONK WAS REGION SPECIFIED IN 'K'
         BO    EREGN@3        YES, BRANCH
         SRA   R15,10         DIVIDE BY 1024 FOR 'K' VALUE
EREGN@3  STH   R15,EREGION    STORE REGION SIZE IN TABLE
         B     EXELOOP        BRANCH
EREGN@4  LA    R15,14         SET ERROR NUMBER
         BAL   R14,ERRORTN    GO ISSUE ERROR MSG
         B     EXELOOP        GET OUT
         EJECT
***********************************************************************
*        EXEC TIME                                                    *
***********************************************************************
ETIME    CLI   0(R2),TIMEEEK  SEE IF TIME= KEY
         BNE   ETIME@         NO, BRANCH
         LA    R2,1(,R2)      INCREMENT PAST KEYWORD DESCR
         SLR   R4,R4          CLEAR REGISTER FOR ICM
         ICM   R4,1,0(R2)     LOAD NUMBER OF SUBPARAMETERS
         BZ    EXELOOP        ZERO, IGNORE
         LA    R2,1(,R2)      INCREMENT PAST CONTROL BYTE
ETIME1   SLR   R3,R3          CLEAR REGISTER FOR ICM
         ICM   R3,1,0(R2)     LOAD LENGTH OF FIRST TIME FIELD
         CH    R3,H#4         COMPARE LENGTH TO 4
         BL    EXELOOP        LT 4, GET OUT
         BE    *+16           EQ 4, COMPARE
         LA    R15,15         SET ERROR NUMBER
         BAL   R14,ERRORTN    GO ISSUE ERROR MSG
         B     EXELOOP        GET OUT
         CLC   1(4,R2),C#1440 SEE IF TIME = 1440
         BNE   EXELOOP        NO, BRANCH
         TM    JOBIND,JOBSTC+JOBTECH SEE IF ALLOWED
         BM    EXELOOP        YES, TIME=1440 OK ON JOB CARD
         LA    R15,16         SET ERROR NUMBER
         BAL   R14,ERRORTN    GO ISSUE ERROR MSG
         B     EXELOOP        GET OUT
         EJECT
***********************************************************************
*        EXEC TIME.                                                   *
***********************************************************************
ETIME@   CLI   0(R2),TIMEPEK  SEE IF TIME. KEY
         BNE   EPERF          NO, BRANCH
         SLR   R3,R3          ZERO WORK REG
         SLR   R4,R4          ZERO WORK REG
         LA    R2,1(,R2)      INCREMENT PAST KEYWORD
         ICM   R4,1,0(R2)     LOAD NUMBER OF SUBPARAMS
         BZ    EXELOOP        NO SUBPARAMS, BRANCH
         CH    R4,H#3         SEE IF MORE THAN 3 SUBPARAMS
         BNH   *+16           NO, BRANCH
         LA    R15,15         SET ERROR NUMBER
         BAL   R14,ERRORTN    GO ISSUE ERROR MSG
         B     EXELOOP        GET OUT
         LA    R2,1(,R2)      INCREMENT PAST NUMBER OF SUBPARAMETERS
         CH    R4,H#2         SEE IF AT LEAST 2 SUBPARAMS
         BL    EXELOOP        ONLY ONE, IGNORE STEPNAME
         ICM   R3,1,0(R2)     LOAD LENGTH OF STEPNAME
         BZ    EXELOOP        NO STEPNAME, BRANCH
         CH    R3,H#8         SEE IF MAX LENGTH EXCEEDED
         BNH   *+16           NO, BRANCH
         LA    R15,15         SET ERROR NUMBER
         BAL   R14,ERRORTN    GO ISSUE ERROR MSG
         B     EXELOOP        GET OUT
         BCTR  R3,0           MAKE MACHINE LENGTH
         EX    R3,COMPARE3    SEE IF CORRECT STEPNAME
         BNE   EXELOOP        NO, GET OUT
         LA    R2,2(R2,R3)    LOAD ADDR OF 2ND SUBPARAM
         IC    R3,0(R2)       LOAD LENGTH OF MINUTES PORTION
         CH    R3,H#4         COMPARE LENGTH TO 4
         BL    EXELOOP        LT 4, GET OUT
         BE    *+16           EQ 4, COMPARE
         LA    R15,15         SET ERROR NUMBER
         BAL   R14,ERRORTN    GO ISSUE ERROR MSG
         B     EXELOOP        GET OUT
         CLC   1(4,R2),C#1440 SEE IF TIME = 1440
         BNE   EXELOOP        NO, BRANCH
         TM    JOBIND,JOBSTC+JOBTECH SEE IF ALLOWED
         BM    EXELOOP        YES, TIME=1440 OK ON JOB CARD
         LA    R15,16         SET ERROR NUMBER
         BAL   R14,ERRORTN    GO ISSUE ERROR MSG
         B     EXELOOP        GET OUT
         EJECT
***********************************************************************
*        EXEC PERFORM                                                 *
***********************************************************************
EPERF    CLI   0(R2),PRFMEEK  SEE IF PERFORM= KEY
         BNE   EPERF@         NO, BRANCH
         TM    JOBIND,JOBTSO+JOBSTC+JOBTECH+JOBPROD+JOBOPER ALLOWED
         BM    EXELOOP        YES, PERFORM OK ON EXEC CARD
         LA    R15,17         SET ERROR NUMBER
         BAL   R14,ERRORTN    GO ISSUE ERROR MSG
         B     EXELOOP        GET OUT
         EJECT
***********************************************************************
*        EXEC PERFORM.                                                *
***********************************************************************
EPERF@   CLI   0(R2),PRFMPEK  SEE IF PERFORM. KEY
         BNE   EADDR          NO, BRANCH
         TM    JOBIND,JOBTSO+JOBSTC+JOBTECH+JOBPROD SEE IF ALLOWED
         BM    EXELOOP        YES, PERFORM OK ON EXEC CARD
         LA    R15,17         SET ERROR NUMBER
         BAL   R14,ERRORTN    GO ISSUE ERROR MSG
         B     EXELOOP        GET OUT
         EJECT
***********************************************************************
*        EXEC ADDRSPC                                                 *
***********************************************************************
EADDR    CLI   0(R2),ADRSPEEK SEE IF ADDRSPC= KEY
         BNE   EADDR@         NO, BRANCH
         TM    JOBIND,JOBSTC+JOBTECH SEE IF ALLOWED
         BM    EXELOOP        YES, ADDRSPC OK ON EXEC CARD
         LA    R15,18         SET ERROR NUMBER
         BAL   R14,ERRORTN    GO ISSUE ERROR MSG
         B     EXELOOP        GET OUT
         EJECT
***********************************************************************
*        EXEC ADDRSPC.                                                *
***********************************************************************
EADDR@   CLI   0(R2),ADRSPPEK SEE IF ADDRSPC. KEY
         BNE   EDPRTY         NO, BRANCH
         TM    JOBIND,JOBSTC+JOBTECH SEE IF ALLOWED
         BM    EXELOOP        YES, ADDRSPC OK ON EXEC CARD
         LA    R15,18         SET ERROR NUMBER
         BAL   R14,ERRORTN    GO ISSUE ERROR MSG
         B     EXELOOP        GET OUT
         EJECT
***********************************************************************
*        EXEC DPRTY                                                   *
***********************************************************************
EDPRTY   CLI   0(R2),SDPEEK   SEE IF  DPRTY= KEY
         BNE   EDPRTY@        NO, BRANCH
         TM    JOBIND,JOBSTC  SEE IF ALLOWED
         BO    EXELOOP        YES, DPRTY OK ON EXEC CARD
         LA    R15,19         SET ERROR NUMBER
         BAL   R14,ERRORTN    GO ISSUE ERROR MSG
         B     EXELOOP        GET OUT
         EJECT
***********************************************************************
*        EXEC DPRTY.                                                  *
***********************************************************************
EDPRTY@  CLI   0(R2),SDPPEK   SEE IF  DPRTY. KEY
         BNE   EXELOOP        NO, BRANCH
         TM    JOBIND,JOBSTC  SEE IF ALLOWED
         BO    EXELOOP        YES, DPRTY OK ON EXEC CARD
         LA    R15,19         SET ERROR NUMBER
         BAL   R14,ERRORTN    GO ISSUE ERROR MSG
         B     EXELOOP        GET OUT
         EJECT
***********************************************************************
*        THIS ROUTINE WILL INCREMENT PAST THE STRING(S) BEING         *
*        PROCESSED.  NOTE THAT FOLLOWING THE KEYWORD DESCRIPTOR       *
*        FIELD IS A COUNT OF SUBPARAMETERS.  FOLLOWING THE COUNT      *
*        WILL BE A LENGTH OR DESCRIPTOR FIELD.  IF THE HIGH ORDER     *
*        BIT IS ON, THE FIELD IS A COUNT FIELD OF THE NUMBER OF       *
*        SUBPARAMETERS WHICH THE SUBPARAMETER ITSELF MAY HAVE.        *
*        IF THIS IS TRUE, THE DESCRIPTOR FIELD WILL BE FOLLOWED BY    *
*        A LENGTH FIELD FOR THE FIRST SUBPARAMETER.  IF THE HIGH      *
*        ORDER BIT IS NOT ON, IT IS ONLY A LENGTH FIELD FOR A         *
*        SINGLE SUBPARAMETER.                                         *
***********************************************************************
EXELOOP  L     R2,PARMADDR    RESTORE START OF PARAMETER ADDRESS
         SLR   R5,R5          CLEAR REGISTER FOR ICM
         LA    R2,1(,R2)      INCREMENT PAST KEYWORD
         ICM   R5,1,0(R2)     LOAD SUBPARAMETER COUNT
         BNZ   EXELOOP1       OK, BRANCH INTO ROUTINE
         LA    R2,1(,R2)      NONE, INCREMENT PAST COUNT
         B     EXELOOP5       AND GET OUT OF ROUTINE
EXELOOP1 LA    R2,1(,R2)      INCREMENT PAST KEYWORD DESCR
EXELOOP2 SLR   R4,R4          CLEAR REGISTER FOR ICM
         ICM   R4,1,0(R2)     LOAD PARAMETER LENGTH
         BNM   EXELOOP3       HIGH BIT NOT ON, ONLY 1 PARAMETER
         N     R4,F#127       'AND' OUT THE HIGH ORDER BIT
         LA    R2,1(,R2)      INCREMENT PAST CONTROL BYTE
         B     EXELOOP4       BRANCH
EXELOOP3 LA    R4,1           SET PARAM COUNT TO 1
EXELOOP4 SLR   R3,R3          CLEAR REGISTER FOR ICM
         ICM   R3,1,0(R2)     LOAD PARAMETER LENGTH
         LA    R2,1(R3,R2)    INCREMENT PAST PARM
         BCT   R4,EXELOOP4    LOOP UNTIL PROCESSED ALL PARMS
         BCT   R5,EXELOOP2    LOOP UNTIL PROCESSED ALL PARMS
EXELOOP5 ST    R2,PARMADDR    SAVE START OF PARAMETER ADDRESS
         B     EXECPARM       CONTINUE
         EJECT
***********************************************************************
*        THE TEXT OF THE DD CARD TEXT IS AS FOLLOWS                   *
*            1)  2 BYTE LENGTH OF TEXT STRING INCLUDING ITSELF        *
*            2)  1 BYTE INDICATOR COMMON TO ALL TEXT RECORDS          *
*            3)  1 BYTE OF MISCELLANEOUS INDICATORS                   *
*            4)  1 BYTE INDICATOR X'6E' INDICATING DD POS INFORMATION *
*            5)  1 BYTE NUMBER OF DD POSITIONAL PARAMETERS            *
*                THE 1ST POS PARAMETER IS THE DDNAME IF PRESENT       *
*                ALL OTHER POS PARAMETERS WILL BE IGNORED             *
*            6)  VARIABLE LENGTH LIST OF DD POS PARAMETERS            *
*                EACH PRECEDED BY A 1 BYTE LENGTH FIELD               *
*            7)  VARIABLE LENGTH LIST OF KEYWORD PARAMETERS           *
*                EACH IS PRECEDED BY A 1 BYTE KEY, 1 BYTE NUMBER OF   *
*                POSITIONAL SUBPARAMETERS PRESENT, AND A LIST OF      *
*                SUBPARAMETERS EACH PRECEDED BY A 1 BYTE LENGTH FIELD *
*                WHICH MAY BE ZERO IF OMITTED AND FOLLOWED BY ANOTHER *
*                POSITIONAL PARAMETER.                                *
***********************************************************************
DDCARD   TM    STRDINDC,DTXDDNM  SEE IF DD DDNAME= STATEMENT
         BO    GETNEXT        YES, BYPASS
         TM    STRDINDC,DTXDYNAM SEE IF DD DYNAM STATEMENT
         BO    GETNEXT        YES, BYPASS
         TM    STRDINDC,DTXSYSIN SEE IF DD INPUT SPOOL FILE
         BO    GETNEXT        YES, BYPASS
         EJECT
***********************************************************************
*        INITIALIZE TEMPORARY ENTRY WHICH WILL BE USED                *
*        IF PRIV OR TAPE UNIT                                         *
***********************************************************************
         XC    UNITIND,UNITIND ZERO UNIT TYPE IND
         XC    DISPIND,DISPIND ZERO DISP IND
         MVI   UNITCOUN,X'01' SET DEFAULT UNIT COUNT TO 1
         MVI   TENTRY,C' '    BLANK FIRST BYTE OF TEMP ENTRY
         MVC   TENTRY+1(52),TENTRY BLANK ENTIRE TEMP ENTRY
         XC    TTYPE,TTYPE    ZERO TEMPORARY UNIT TYPE
         XC    TVOLSER,TVOLSER ZERO TEMP 1ST VOLSER
DDSTART  LA    R2,STRDKEY     LOAD START OF TRUE TEXT
         ST    R2,PARMADDR    SAVE START OF PARAMETER ADDRESS
DDPARM   CLI   0(R2),ENDK     END OF TEXT STRING??
         BE    DDEND          YES, GO CHECK FOR UPDATE
         EJECT
***********************************************************************
*        DD DDNAME                                                    *
***********************************************************************
DDDNAME  CLI   0(R2),DDK      SEE IF DDNAME KEY
         BNE   DDDUMMY        NO, BRANCH
         SLR   R3,R3          CLEAR REG FOR ICM
         ICM   R4,1,1(R2)     LOAD NUMBER OF SUBPARAMS
         BZ    DDLOOP         ZERO, NO SUBPARAMS
         SLR   R3,R3          CLEAR REG FOR ICM
         ICM   R3,1,2(R2)     LOAD LENGTH OF DDNAME
         BZ    DDLOOP         YES, CONCATINATED DD, LOOP
         CH    R3,H#8         SEE IF MAX LENGTH EXCEEDED
         BNH   *+16           NO, CONTINUE
         LA    R15,20         SET ERROR NUMBER
         BAL   R14,ERRORTN    GO ISSUE ERROR MSG
         B     DDLOOP         GET OUT
         BCTR  R3,0           MAKE MACHINE LENGTH
         EX    R3,MOVE8       MOVE DDNAME TO TEMP ENTRY
         B     DDLOOP         GO GET NEXT PARAM
         EJECT
***********************************************************************
*        DD DUMMY                                                     *
***********************************************************************
DDDUMMY  CLI   0(R2),DUMMK    SEE IF DUMMY KEY
         BNE   DDSNAME        NO, BRANCH
         B     GETNEXT        DUMMY STATEMENTS ARE IGNORED
         EJECT
***********************************************************************
*        DD DSNAME                                                    *
***********************************************************************
DDSNAME  CLI   0(R2),DSNAMEK  SEE IF DSNAME KEY
         BNE   DDISP          NO, BRANCH
         SLR   R3,R3          CLEAR REG FOR ICM
         ICM   R3,1,2(R2)     LOAD LENGTH OF DSN
         BZ    DDLOOP         ZERO, NULL, BRANCH
         BNM   DSNSTD         HIGH BIT NOT ON, STANDARD DSN
         CLI   4(R2),C'*'     SEE IF 1ST PARAM = * (REFERBACK)
         BE    DSNREFBK       YES, REFERBACK
***********************************************************************
*        DSNAME PROBABLY A GDG                                        *
***********************************************************************
DSNGDG   N     R3,F#127       TURN OFF HIGH ORDER BIT
         CH    R3,H#2         SEE IF TWO SUBPARAMS
         BE    *+16           YES, BRANCH
         LA    R15,21         SET ERROR NUMBER
         BAL   R14,ERRORTN    GO ISSUE ERROR MSG
         B     DDLOOP         GET OUT
         LA    R4,3(,R2)      LOAD ADDR OF START OF 1ST ENTRY
         IC    R3,0(R4)       LOAD LENGTH OF 1ST ENTRY
         CH    R3,H#35        SEE IF MAX LENGTH EXCEEDED
         BNH   *+16           NOT EXCEEDED, BRANCH
         LA    R15,22         SET ERROR NUMBER
         BAL   R14,ERRORTN    GO ISSUE ERROR MSG
         B     DDLOOP         GET OUT
         BCTR  R3,0           MAKE MACHINE LENGTH
         EX    R3,MOVE14      MOVE 1ST PART DSN TO TEMP ENTRY
         LA    R3,1(,R3)      MAKE TRUE LENGTH AGAIN
         LA    R4,1(R3,R4)    INCREMENT TO 2ND ENTRY
         LA    R5,TDSN        LOAD ADDR OF TEMPORARY DSN
         AR    R5,R3          LOAD ADDR WITHIN TDSN FOR GEN #
         LR    R15,R3         SAVE LENGTH OF 1ST PART DSN
         ICM   R3,1,0(R4)     LOAD LENGTH OF 2ND PART DSN
         BNZ   *+16           NOT ZERO, BRANCH
         LA    R15,21         SET ERROR NUMBER
         BAL   R14,ERRORTN    GO ISSUE ERROR MSG
         B     DDLOOP         GET OUT
         AR    R15,R3         ADD NEW LENGTH OF 2ND PART TO 1ST
         CH    R15,H#42       SEE IF TOTAL LENGTH EXCEEDS MAX
         BNH   *+16           NO, BRANCH
         LA    R15,22         SET ERROR NUMBER
         BAL   R14,ERRORTN    GO ISSUE ERROR MSG
         B     DDLOOP         GET OUT
         MVI   0(R5),C'('     PUT PARENS FOR GEN #
         LA    R5,1(,R5)      INCREMENT TO START TRUE GEN #
         BCTR  R3,0           MAKE MACHINE LENGTH
         EX    R3,MOVE15      MOVE GEN # TO TDSN
         LA    R5,1(R3,R5)    INCREMENT TO END OF TDSN FIELD
         MVI   0(R5),C')'     FINISH PARENS FOR GEN #
         B     DDLOOP         GO GET NEXT ENTRY
***********************************************************************
*        DSNAME PROBABLY A REFERBACK                                  *
***********************************************************************
DSNREFBK BAL   R14,REFBACK    GO TO REFERBACK RTN
         MVC   TDSN,REFDSN    SAVE REFERBACK DSNAME
         B     DDLOOP         GO GET NEXT ENTRY
***********************************************************************
*        DSNAME PROBABLY STANDARD                                     *
***********************************************************************
DSNSTD   CH    R3,H#44        SEE IF > MAX LENGTH
         BNH   *+16           NO, BRANCH
         LA    R15,22         SET ERROR NUMBER
         BAL   R14,ERRORTN    GO ISSUE ERROR MSG
         B     DDLOOP         GET OUT
         CLC   3(8,R2),NULLFILE SEE IF DSN=NULLFILE
         BE    GETNEXT        YES, DUMMY, IGNORE STATEMENT
         BCTR  R3,0           MAKE MACHINE LENGTH
         EX    R3,MOVE9       MOVE DSN TO TEMP ENTRY
         B     DDLOOP         GO GET NEXT ENTRY
         EJECT
***********************************************************************
*        DD DISP                                                      *
***********************************************************************
DDISP    CLI   0(R2),DISPK    SEE IF DISP= KEYWORD
         BNE   DUNIT          NO, BRANCH
         SLR   R4,R4          CLEAR REG FOR ICM
         ICM   R4,1,1(R2)     LOAD NUMBER SUBPARAMS
         BZ    DDLOOP         ZERO, NULL, BRANCH
         LA    R2,2(,R2)      LOAD START ADDR OF SUBPARAMS
         CH    R4,H#3         SEE IF NUMBER > 3
         BNH   *+16           NO, CONTINUE
         LA    R15,23         SET ERROR NUMBER
         BAL   R14,ERRORTN    GO ISSUE ERROR MSG
         B     DDLOOP         GET OUT
         SLR   R5,R5          ZERO WORK REG
DSPLOO1  LA    R5,1(,R5)      ADD 1 TO COUNTER
         CR    R5,R4          SEE IF ALL PROCESSED
         BH    DISPCHK        YES, GO CHECK RESULTS
         SLR   R3,R3          ZERO WORK REG
         IC    R3,0(R2)       LOAD LEN OF PARAM
         CH    R5,H#1         SEE IF 1ST PARAM
         BE    DSPLOO2        YES, BRANCH TO PROCESS
         CH    R5,H#2         SEE IF 2ND PARAM
         BE    DSPLOO7        YES, BRANCH TO PROCESS
         B     DSPLOO9        BRANCH TO PROCESS
***********************************************************************
*         FIRST DISP PARAMETER                                        *
***********************************************************************
DSPLOO2  LTR   R3,R3          SEE IF LENGTH = 0
         BZ    DSPLOO3        YES, GO SET TO NEW
         CLC   1(3,R2),C#NEW  SEE IF NEW
         BNE   DSPLOO4        NO, BRANCH
DSPLOO3  OI    DISPIND,NEW    SET TO NEW
         B     DSPLOO14       GO GET NEXT
DSPLOO4  CLC   1(3,R2),C#SHR  SEE IF SHR
         BNE   DSPLOO5        NO, BRANCH
         OI    DISPIND,SHR    SET TO SHR
         B     DSPLOO14       GO GET NEXT
DSPLOO5  CLC   1(3,R2),C#OLD  SEE IF OLD
         BNE   DSPLOO6        NO, MUST BE "MOD", BRANCH
         OI    DISPIND,OLD    SET TO OLD
         B     DSPLOO14       GO GET NEXT
DSPLOO6  OI    DISPIND,MOD    SET TO MOD
         B     DSPLOO14       GO GET NEXT
***********************************************************************
*         SECOND DISP PARAMETER                                       *
***********************************************************************
DSPLOO7  LTR   R3,R3          SEE IF LENGTH = 0
         BNZ   DSPLOO9        NOT ZERO, NO DEFAULT
         TM    DISPIND,OLD    SEE IF OLD
         BO    DSPLOO8        YES, GO SET DEFAULT TO KEEP
         TM    DISPIND,SHR    SEE IF SHR
         BO    DSPLOO8        YES, GO SET DEFAULT TO KEEP
         TM    DISPIND,MOD    SEE IF MOD
         BO    DSPLOO8        YES, GO SET DEFAULT TO KEEP
         OI    DISPIND,DELETE SET DEFAULT TO DELETE FOR "NEW"
         B     DSPLOO14       GO GET NEXT
DSPLOO8  OI    DISPIND,KEEP   SET TO KEEP
         B     DSPLOO14       GO GET NEXT
***********************************************************************
*         THIRD DISP PARAMETER                                        *
***********************************************************************
DSPLOO9  LTR   R3,R3          SEE IF LENGTH = 0
         BZ    DSPLOO14       YES, USE DEFAULT OF PREVIOUS PARAMETER
         CLC   1(4,R2),C#KEEP SEE IF KEEP
         BNE   DSPLOO10       NO, BRANCH
         OI    DISPIND,KEEP   SET TO KEEP
         B     DSPLOO14       GO GET NEXT
DSPLOO10 CLC   1(4,R2),C#PASS SEE IF PASS
         BNE   DSPLOO11       NO, BRANCH
         OI    DISPIND,PASS   SET TO PASS
         B     DSPLOO14       GO GET NEXT
DSPLOO11 CLC   1(5,R2),C#CATLG SEE IF CATLG
         BNE   DSPLOO12       NO, BRANCH
         OI    DISPIND,CATLG  SET TO CATLG
         B     DSPLOO14       GO GET NEXT
DSPLOO12 CLC   1(6,R2),C#DELETE SEE IF DELETE
         BNE   DSPLOO13       NO, GO SET TO "UNCATLG"
         OI    DISPIND,DELETE SET TO DELETE
         B     DSPLOO14       GO GET NEXT
DSPLOO13 OI    DISPIND1,UNCATLG SET TO UNCATLG
DSPLOO14 LA    R2,1(R3,R2)    INCREMENT TO NEXT ENTRY
         B     DSPLOO1        LOOP
***********************************************************************
*         CHECK RESULTS OF PROCESSING ALL DISP PARAMETERS             *
*         IF ONLY 1 DISP PARAMETER WAS ENTERED, THE DEFAULT           *
*         FOR THE SECOND PARAMETER MUST BE DETERMINED.                *
***********************************************************************
DISPCHK  CH    R4,H#1         SEE IF ONLY 1 ENTRY
         BNE   DISPEND        NO, DO NOT SET DEFAULT
         TM    DISPIND,OLD    SEE IF OLD
         BO    DISPCHK2       YES, BRANCH
         TM    DISPIND,SHR    SEE IF SHR
         BO    DISPCHK2       YES, BRANCH
         TM    DISPIND,MOD    SEE IF MOD
         BO    DISPCHK2       YES, BRANCH
***********************************************************************
*        DISP=NEW  DEFAULT TO DELETE                                  *
***********************************************************************
DISPCHK1 OI    DISPIND,DELETE SET TO DELETE
         B     DISPEND        GET OUT
***********************************************************************
*        DISP=OLD, MOD, OR SHR  DEFAULT TO KEEP                       *
***********************************************************************
DISPCHK2 OI    DISPIND,KEEP   SET TO KEEP
DISPEND  B     DDLOOP         GO GET NEXT PARAM
         EJECT
***********************************************************************
*        DD UNIT                                                      *
***********************************************************************
DUNIT    CLI   0(R2),UNITK    SEE IF UNIT= PARAM
         BNE   DAFF           NO, BRANCH
         ICM   R4,1,1(R2)     GET NUMBER OF POS SUBPARAMS
         BZ    DDLOOP         ZERO, NO POS SUBPARAMS
         CH    R4,H#3         SEE IF NUMBER > 3
         BNH   *+16           NO, CONTINUE
         LA    R15,24         SET ERROR NUMBER
         BAL   R14,ERRORTN    GO ISSUE ERROR MSG
         B     DDLOOP         GET OUT
         LA    R2,2(,R2)      LOAD START OF POS PARAMS
         SLR   R5,R5          ZERO WORK REG
***********************************************************************
*        LOOP ON NUMBER OF PARAMETERS.  NOTE THAT THE FIRST           *
*        PARAMETER (UNITNAME) AND THE SECOND PARAMETER (UNIT          *
*        COUNT) ARE ALL WE ARE INTERESTED IN.                         *
***********************************************************************
UNITLOO1 LA    R5,1(,R5)      ADD 1 TO COUNT
         CR    R5,R4          SEE IF PROCESSED ALL SUBPARAMS
         BH    DDLOOP         YES, GO GET NEXT PARM
         SLR   R3,R3          ZERO WORK REG
         ICM   R3,1,0(R2)     LOAD LENGTH OF SUBPARAM
         BZ    UNITLOO2       ZERO, GO GET NEXT SUBPARAM
         CH    R3,H#8         SEE IF LENGTH > 8
         BNH   *+16           NO, CONTINUE
         LA    R15,24         SET ERROR NUMBER
         BAL   R14,ERRORTN    GO ISSUE ERROR MSG
         B     DDLOOP         GET OUT
         CH    R5,H#1         SEE IF 1ST POS SUBP
         BE    UNITNM1        YES, BRANCH
         CH    R5,H#2         SEE IF 2ND POS SUBP
         BE    UNITCT         YES, BRANCH
         B     UNITLOO2       ANYTHING ELSE NOT WANTED
***********************************************************************
*        PROCESS UNIT NAME                                            *
***********************************************************************
UNITNM1  SLR   R15,R15        CLEAR REG 15
         LA    R1,DEVTABLE    LOAD ADDR OF DEV TABLE
         BCTR  R3,0           MAKE MACHINE LENGTH
         CH    R3,H#2         Q. POSSIBLE ABSOLUTE ALLOC(CUU)?
         BNE   UNITNM2        NO, CHK FOR CLASS DEVICES
         CLI   1(R2),C'0'     Q. CHAN NOS  NUMERIC?
         BL    UNITNM2        NO, CAN'T BE DEDICATED DEVICE
         OI    RESOURCE+1,DEDICATE YES, ADD 'DEDICATE' RESOURCE
***********************************************************************
*        SEARCH THE DEVICE TABLE FOR A MATCH ON UNIT NAME TO          *
*        DETERMINE THE ATTRIBUTES OF THE UNIT NAME.                   *
***********************************************************************
UNITNM2  CLI   1(R1),X'00'    SEE IF END OF TABLE
         BE    UNITNM3        YES, BRANCH
         IC    R15,1(R1)      INSERT LENGTH OF UNIT NAME
         EX    R15,COMPARE2   SEE IF UNIT NAME MATCH
         BE    UNITNM3        YES, BRANCH
         LA    R1,10(,R1)     INCREMENT TO NEXT ENTRY
         B     UNITNM2        LOOP
UNITNM3  LA    R3,1(,R3)      MAKE ORIG LENGTH
         OC    UNITIND,0(R1)  'OR' IN THE UNIT TYPE BITS
         B     UNITLOO2       GO PROCESS NEXT POS PARAM
UNITCT   CLI   1(R2),C'P'     PARALLEL MOUNTING?
         BNE   UNITCT1        NO, BRANCH
         MVI   UNITCOUN,C'P'  SET UNIT COUNT TO 'P'
         B     UNITLOO2
***********************************************************************
*        PROCESS UNIT COUNT                                           *
***********************************************************************
UNITCT1  LR    R15,R3         SAVE LENGTH OF UNIT COUNT
         LA    R14,1(,R2)     LOAD ADDRESS OF UNIT COUNT
UNITCT2  CLI   0(R14),C'0'    SEE IF NUMERIC
         BL    UNITLOO3       NO, ERROR
         CLI   0(R14),C'9'    SEE IF NUMERIC
         BH    UNITLOO3       NO, ERROR
         LA    R14,1(,R14)    INCREMENT TO NEXT CHAR UNIT COUNT
         BCT   R15,UNITCT2    LOOP UNTIL DONE
         BCTR  R3,0           MAKE MACHINE LENGTH
         EX    R3,PACK2       PACK UNIT COUNT
         LA    R3,1(,R3)      MAKE ORIG LENGTH
         CVB   R15,DOUBLE     CONVERT UNIT COUNT TO BIN
         STC   R15,UNITCOUN   SAVE UNIT COUNT
UNITLOO2 LA    R2,1(R3,R2)    INCREMENT TO NEXT ENTRY
         B     UNITLOO1       GO PROCESS NEXT SUBPARAM
UNITLOO3 LA    R15,25         SET ERROR NUMBER
         BAL   R14,ERRORTN    GO ISSUE ERROR MSG
         B     DDLOOP         GET OUT
         EJECT
***********************************************************************
*        DD UNIT=AFF                                                  *
***********************************************************************
DAFF     CLI   0(R2),AFFMK    SEE IF UNIT=AFF= KEY
         BNE   DVOL           NO, BRANCH
         MVI   REFERBCK,C' '  BLANK START OF REFERBACK WORK AREA
         MVC   REFERBCK+1(23),REFERBCK BLANK ENTIRE FIELD
         LA    R2,2(,R2)      LOAD ADDR OF AFF FIELD
         SLR   R3,R3          CLEAR REG FOR ICM
         ICM   R3,1,0(R2)     LOAD LENGTH OF DDNAME
         BZ    DDLOOP         YES, GO PROCESS NEXT PARAM
         CH    R3,H#8         SEE IF LENGTH > 8
         BNH   *+16           NO, CONTINUE
         LA    R15,24         SET ERROR NUMBER
         BAL   R14,ERRORTN    GO ISSUE ERROR MSG
         B     DDLOOP         GET OUT
         BCTR  R3,0           MAKE MACHINE LENGTH
         EX    R3,MOVE10      MOVE DDNAME TO REFERBACK FIELD
         L    R7,LASTEXEC     LOAD ADDR LAST EXEC ENTRY
         MVI   UNITIND,UNITFND SET UNIT FOUND IND
AFFLOOP  LA   R7,ENTLEN(,R7) INCREMENT TO NEXT DD ENTRY
         CLI   ENTRYTYP,TYPEND END OF TABLE?
         BE    AFFEND         YES, BRANCH
         CLC   REFDDN,DDDN    MATCH DDNAME?
         BE    AFFOUND        YES, BRANCH
         B     AFFLOOP        LOOP
AFFOUND  OC    UNITIND,DTYPE SET UNIT TYPE FROM PREV
         OI    UNITIND,AFF    TURN ON FOUND BY AFF IND
AFFEND   B     DDLOOP         GO PROCESS NEXT ENTRY
         EJECT
***********************************************************************
*        DD VOL                                                       *
***********************************************************************
DVOL     CLI   0(R2),VOLUMEK  SEE IF VOL= KEYWORD
         BNE   DSER           NO, BRANCH
         ICM   R4,1,1(R2)     LOAD NUM OF SUBPARAMS
         BZ    DDLOOP         YES, GO GET NEXT PARAM
         CH    R4,H#4         SEE IF AT LEAST 4 PARAMS
         BL    DDLOOP         LESS THAN 4, NONE NEEDED
         BNH   *+16           NO, CONTINUE
         LA    R15,26         SET ERROR NUMBER
         BAL   R14,ERRORTN    GO ISSUE ERROR MSG
         B     DDLOOP         GET OUT
***********************************************************************
*        WE NEED ONLY THE 4TH PARAM (VOL COUNT)                       *
***********************************************************************
         SR    R5,R5          ZERO WORK REG
         LA    R2,2(,R2)      LOAD START OF SUBPARAMS
VOLOOP1  LA    R5,1(,R5)      ADD 1 TO COUNTER
         SLR   R3,R3          CLEAR REG FOR IC
         IC    R3,0(R2)       LOAD LENGTH OF SUBPARAM
         CH    R5,H#4         SEE IF 4TH PARAM
         BL    VOLOOP3        LESS THAN 4, GO GET NEXT
         BH    VOLEND         GREATER THAN 4, GET OUT
         LTR   R3,R3          TEST LENGTH
         BZ    VOLEND         ZERO, GET OUT
         CH    R3,H#8         SEE IF LENGTH > 8
         BNH   *+16           NO, CONTINUE
         LA    R15,26         SET ERROR NUMBER
         BAL   R14,ERRORTN    GO ISSUE ERROR MSG
         B     DDLOOP         GET OUT
         LR    R15,R3         SAVE LENGTH OF VOL COUNT
         LA    R14,1(,R2)     LOAD ADDRESS OF VOL COUNT
***********************************************************************
*        CHECK VOLUME COUNT FOR NUMERIC                               *
***********************************************************************
VOLOOP2  CLI   0(R14),C'0'    SEE IF NUMERIC
         BL    VOLOOP4        NO, ERROR
         CLI   0(R14),C'9'    SEE IF NUMERIC
         BH    VOLOOP4        NO, ERROR
         LA    R14,1(,R14)    INCREMENT TO NEXT CHAR VOL COUNT
         BCT   R15,VOLOOP2    LOOP UNTIL DONE
         BCTR  R3,0           MAKE MACHINE LENGTH
         EX    R3,PACK3       PACK VOLUME COUNT
         LA    R3,1(,R3)      RESTORE LENGTH
         CVB   R15,DOUBLE     CONVERT VOL COUNT TO BIN
         STC   R15,VOLCNT     SAVE VOL CNT
VOLOOP3  LA    R2,1(R3,R2)    INCRMENT TO NEXT POS SUBPARAM
         B     VOLOOP1        LOOP
VOLOOP4  LA    R15,27         SET ERROR NUMBER
         BAL   R14,ERRORTN    GO ISSUE ERROR MSG
         B     DDLOOP         GET OUT
VOLEND   B     DDLOOP         GO GET NEXT PARAM
         EJECT
***********************************************************************
*        DD VOL=SER                                                   *
***********************************************************************
DSER     CLI   0(R2),SERMK    SEE IF VOL=SER= KEYWORD
         BNE   DREF           NO, BRANCH
***********************************************************************
*        ALL WE NEED IS THE NUMBER OF VOL/SER'S                       *
*        AND THE 1ST VOLSER IN THE LIST IF PRESENT                    *
***********************************************************************
         ICM   R4,1,1(R2)     LOAD NUMBER OF SUBPARAMS
         STC   R4,SERCNT      SAVE NUMBER OF VOL/SER'S
         BZ    DDLOOP         ZERO SUBPARAMS, GET OUT
         ICM   R3,1,2(R2)     LOAD LEN OF 1ST VOLSER
         BZ    DDLOOP         NULL VOLSER, GET OUT
         CH    R3,H#6         SEE IF MAX LEN EXCEEDED
         BNH   *+16           NO, BRANCH
         LA    R15,28         SET ERROR NUMBER
         BAL   R14,ERRORTN    GO ISSUE ERROR MSG
         B     DDLOOP         GET OUT
         BCTR  R3,0           MAKE MACHINE LENGTH
         EX    R3,MOVE13      MOVE 1ST VOLSER TO SAVE
         B     DDLOOP         GO GET NEXT PARAM
         EJECT
***********************************************************************
*        DD VOL=REF                                                   *
***********************************************************************
DREF     CLI   0(R2),REFMK    SEE IF VOL=REF= KEYWORD
         BNE   DLABEL         NO, BRANCH
         SLR   R4,R4          CLEAR REG FOR ICM
         ICM   R4,1,2(R2)     LOAD 'LENGTH' OF REFERBACK
         BZ    DDLOOP         ZERO LENGTH, NULL, BRANCH
         BP    DREF00         HIGH BIT NOT ON, NOT A REFERBACK
         BAL   R14,REFBACK    GO TO REFERBACK ROUTINE
         OI    UNITIND,UNITFND SET UNIT FOUND IND
         OC    UNITIND,REFUNIT SAVE UNIT OF PREV DD
         MVC   TVOLSER,REFVOL SAVE REFERBACK VOLSER
         B     DDLOOP         GO GET NEXT PARAM
***********************************************************************
*        AT THIS POINT, THE REFERBACK IS PROBABLY TO A CATALOGED      *
*        DATA SET.                                                    *
***********************************************************************
DREF00   CH    R4,H#44        SEE IF LENGTH OF DSNAME EXCEEDS MAX
         BNH   *+16           NO, BRANCH
         LA    R15,34         SET ERROR NUMBER
         BAL   R14,ERRORTN    GO ISSUE ERROR MSG
         B     DDLOOP         GET OUT
         MVC   LDSN,BLANKS    BLANK DSNAME
         BCTR  R4,0           MAKE MACHINE LENGTH
         EX    R4,MOVE17      MOVE DSNAME TO SAVE
         L    R7,FIRSTENT     LOAD START OF TABLE
         LA   R7,ENTLEN(,R7) INCREMENT PAST JOB ENTRY
DREF01   CLI   ENTRYTYP,TYPEDD  SEE IF DD ENTRY
         BE    DREF02         YES, GO SEE IF MATCH
         CLI   ENTRYTYP,TYPEND  SEE IF END OF TABLE
         BE    DREF05         NOT FOUND, GO CHECK CATALOG
         B     DREF03         LOOP
DREF02   CLC   DDSN,3(R2)     SEE IF SAME DSNAME
         BE    DREF04         YES, CHARGE FOR THE DSNAME
DREF03   LA   R7,ENTLEN(,R7) INCREMENT TO NEXT DD ENTRY
         B     DREF01         LOOP UNTIL DONE
DREF04   OI    UNITIND,UNITFND SET UNIT FOUND IND
         OC    UNITIND,DTYPE  SAVE UNIT TYPE FROM TABLE
         MVC   TVOLSER,DVOLSER SAVE VOLSER FROM TABLE
         B     DDLOOP         GO GET NEXT PARAM
DREF05   BAL   R5,LOCATE      GO READ CATALOG
         LTR   R15,R15        TEST RETURN CODE
         BNZ   DDLOOP         NOT CATALOGED, IGNORE IT
         CLC   CAMLCNT,H#0    ANY VOLUME ENTRIES?
         BE    DDLOOP         NO, IGNORE IT
         CLI   CAMVOL,X'00'   MAKE USER THAT THERE IS A VOLSER
         BE    DDLOOP         NO, VSAM LIED AGAIN, IGNORE THIS ENTRY
         MVC   VOLCNT,CAMLCNT SAVE VOLUME COUNT
         MVC   TVOLSER,CAMVOL SAVE VOLSER FROM CATALOG
         TM    UCBTYP3,X'80'  TAPE UNIT?
         BO    DREF06         YES, BRANCH
         BAL   R5,UCBSEAR     NO, GO SEARCH UCBS FOR PRIV MOUNT
         B     DDLOOP         GO GET NEXT PARAM
DREF06   OI    UNITIND,TAPE   TURN ON TAPE IND
         B     DDLOOP         GO GET NEXT PARAM
         EJECT
***********************************************************************
*        DD LABEL                                                     *
***********************************************************************
DLABEL   CLI   0(R2),LABELK   SEE IF LABEL= KEYWORD
         BNE   DEXPDT         NO, BRANCH
         SLR   R4,R4          CLEAR REG FOR ICM
         ICM   R4,1,1(R2)     LOAD NUMBER SUBPARAMS
         CH    R4,H#2         SEE IF AT LEAST 2 SUBPARAMETERS
         BL    DDLOOP         NO, BRANCH
         SLR   R3,R3          CLEAR REG FOR ICM
         ICM   R3,1,2(R2)     LOAD LENGTH OF FIRST SUBPARAM
         LA    R2,3(R3,R2)    LOAD START ADDR OF SECOND SUBPARAMETER
         ICM   R3,1,0(R2)     LOAD LENGTH OF SECOND SUBPARAM
         CLC   1(3,R2),C#BLP  SEE IF BLP PROCESSING
         BNE   DDLOOP         NO, GET OUT
***********************************************************************
*        DO NOT ALLOW BLP                                             *
***********************************************************************
         TM    JOBIND,JOBSTC+JOBTECH+JOBPROD+JOBOPER ALLOWED
         BM    DDLOOP         YES, GET OUT
         B     DDLOOP         ALLOW EVERYONE TO USE BLP      OVERRIDE
         LA    R15,44         SET ERROR NUMBER
         BAL   R14,ERRORTN    GO ISSUE ERROR MSG
         B     DDLOOP         GET OUT
         EJECT
***********************************************************************
*        DD LABEL=EXPDT                                               *
***********************************************************************
DEXPDT   CLI   0(R2),EXPDTMK  SEE IF LABEL=EXPDT KEYWORD
         BNE   DINTRDR        NO, BRANCH
         SLR   R4,R4          CLEAR REG FOR ICM
         ICM   R4,1,1(R2)     LOAD NUMBER SUBPARAMS
         BZ    DDLOOP         ZERO, NULL, BRANCH
         LA    R2,2(,R2)      LOAD START ADDR OF SUBPARAMS
         SLR   R3,R3          CLEAR REG FOR ICM
         ICM   R3,1,0(R2)     LOAD LENGTH OF FIRST SUBPARAM
         CH    R3,H#5         SEE IF LENGTH = 5
         BNE   DDLOOP         NO, GET OUT
         CLC   1(5,R2),C#98000 SEE IF EXPDT=98000
         BNE   DDLOOP         NO, GET OUT
***********************************************************************
*        DO NOT ALLOW EXPDT=98000                                     *
***********************************************************************
         TM    JOBIND,JOBSTC+JOBTECH+JOBPROD+JOBOPER ALLOWED
         BM    DDLOOP         YES, GET OUT
         LA    R15,45         SET ERROR NUMBER
         BAL   R14,ERRORTN    GO ISSUE ERROR MSG
         B     DDLOOP         GET OUT
         EJECT
***********************************************************************
*        DD SYSOUT                                                    *
***********************************************************************
DINTRDR  CLI   0(R2),SYSOUTK  SEE IF SYSOUT= KEYWORD
         BNE   DDLOOP         NO, BRANCH
         SLR   R4,R4          CLEAR REG FOR ICM
         ICM   R4,1,1(R2)     LOAD NUMBER SUBPARAMS
         BZ    DDLOOP         NONE, BRANCH
         SLR   R3,R3          CLEAR REG FOR ICM
         ICM   R3,1,2(R2)     LOAD LENGTH OF FIRST SUBPARAM
         LA    R5,PSYSOUT     LOAD ADDRESS OF PRODUCTION SYSOUT CLASSES
DINTRDR1 CLI   0(R5),X'FF'    END OF TABLE
         BE    DINTRDR3       YES, BRANCH
         CLC   0(1,R5),3(R2)  SEE IF CLASS MATCHES
         BE    DINTRDR2       YES, PRODUCTION SYSOUT CLASS
         LA    R5,1(,R5)      INCREMENT TO NEXT TABLE ENTRY
         B     DINTRDR1       LOOP
DINTRDR2 TM    JOBIND,JOBTECH+JOBPROD+JOBSTC IS PROD SYSOUT CLASS OK
         BM    DINTRDR3       YES, NOT AN ERROR
*        B     DINTRDR3       ALLOW EVERYONE ALL SYSOUT      OVERRIDE
         LA    R15,50         SET ERROR NUMBER
         BAL   R14,ERRORTN    GO ISSUE ERROR MSG
DINTRDR3 CH    R4,H#2         SEE IF AT LEAST 2 SUBPARAMETERS
         BL    DDLOOP         NO, BRANCH
         LA    R2,3(R3,R2)    LOAD START ADDR OF SECOND SUBPARAMETER
         ICM   R3,1,0(R2)     LOAD LENGTH OF SECOND SUBPARAM
         CH    R3,H#6         SEE IF LENGTH = 6
         BNE   GETNEXT        NO, GET OUT
         CLC   1(6,R2),C#INTRDR SEE IF INTERNAL READER
         BNE   GETNEXT        NO, BYPASS REST OF SYSOUT STATEMENT
***********************************************************************
*        DO NOT ALLOW INTERNAL READER                                 *
***********************************************************************
         TM    JOBIND,JOBSTC+JOBTECH ALLOWED
         BM    GETNEXT        YES, BYPASS REST OF SYSOUT STATEMENT
         B     GETNEXT        ALLOW EVERYONE TO USE INTRDR   OVERRIDE
         LA    R15,46         SET ERROR NUMBER
         BAL   R14,ERRORTN    GO ISSUE ERROR MSG
         B     GETNEXT        BYPASS REST OF SYSOUT STATEMENT
         EJECT
***********************************************************************
*        THIS ROUTINE WILL INCREMENT PAST THE STRING(S) BEING         *
*        PROCESSED.  NOTE THAT FOLLOWING THE KEYWORD DESCRIPTOR       *
*        FIELD IS A COUNT OF SUBPARAMETERS.  FOLLOWING THE COUNT      *
*        WILL BE A LENGTH OR DESCRIPTOR FIELD.  IF THE HIGH ORDER     *
*        BIT IS ON, THE FIELD IS A COUNT FIELD OF THE NUMBER OF       *
*        SUBPARAMETERS WHICH THE SUBPARAMETER ITSELF MAY HAVE.        *
*        IF THIS IS TRUE, THE DESCRIPTOR FIELD WILL BE FOLLOWED BY    *
*        A LENGTH FIELD FOR THE FIRST SUBPARAMETER.  IF THE HIGH      *
*        ORDER BIT IS NOT ON, IT IS ONLY A LENGTH FIELD FOR A         *
*        SINGLE SUBPARAMETER.                                         *
***********************************************************************
DDLOOP   L     R2,PARMADDR    RESTORE START OF PARAMETER ADDRESS
         SLR   R5,R5          CLEAR REGISTER FOR ICM
         LA    R2,1(,R2)      INCREMENT PAST KEYWORD
         ICM   R5,1,0(R2)     LOAD SUBPARAMETER COUNT
         BNZ   DDLOOP1        OK, BRANCH INTO ROUTINE
         LA    R2,1(,R2)      NONE, INCREMENT PAST COUNT
         B     DDLOOP5        AND GET OUT OF ROUTINE
DDLOOP1  LA    R2,1(,R2)      INCREMENT PAST KEYWORD DESCR
DDLOOP2  SLR   R4,R4          CLEAR REGISTER FOR ICM
         ICM   R4,1,0(R2)     LOAD PARAMETER LENGTH
         BNM   DDLOOP3        HIGH BIT NOT ON, ONLY 1 PARAMETER
         N     R4,F#127       'AND' OUT THE HIGH ORDER BIT
         LA    R2,1(,R2)      INCREMENT PAST CONTROL BYTE
         B     DDLOOP4        BRANCH
DDLOOP3  LA    R4,1           SET PARAM COUNT TO 1
DDLOOP4  SLR   R3,R3          CLEAR REGISTER FOR ICM
         ICM   R3,1,0(R2)     LOAD PARAMETER LENGTH
         LA    R2,1(R3,R2)    INCREMENT PAST PARM
         BCT   R4,DDLOOP4     LOOP UNTIL PROCESSED ALL PARMS
         BCT   R5,DDLOOP2     LOOP UNTIL PROCESSED ALL PARMS
DDLOOP5  ST    R2,PARMADDR    SAVE START OF PARAMETER ADDRESS
         B     DDPARM         CONTINUE
         EJECT
***********************************************************************
*        THIS IS WHERE WE LOOK AT WHAT WE HAVE FOUND OUT ABOUT THE    *
*        DD STATEMENT WE HAVE JUST FINISHED PROCESSING.               *
*        THE FOLLOWING ARE LOOKED AT                                  *
*          1)  THE DISPOSITION FOR SOME DATA SETS                     *
*              MUST BE AUTHORIZED FOR OTHER THAT SHR                  *
*          2)  THE TEMPORARY ENTRY MUST BE SAVED IF UNIT IS A TAPE    *
*              OR A PRIV UNIT.                                        *
*          3)  IF THE ENTRY IS A TAPE OR PRIV, THE UNIT COUNT MUST BE *
*              ADDED TO THE RUNNING COUNT FOR THE STEP.               *
***********************************************************************
*
***********************************************************************
*        DO NOT ALLOW A DISP OF "DELETE" FOR SYSTEM DATA SETS.        *
***********************************************************************
DDEND    CLC   TDSN(5),C#SYSP SEE IF SYSP. DATA SET
         BE    DDEND20        YES, BRANCH
         CLC   TDSN(5),C#SYS1 SEE IF SYS1. DATA SET
         BE    DDEND20        YES, BRANCH
         CLC   TDSN(5),C#PRD1 SEE IF PRD1. DATA SET
         BE    DDEND20        YES, BRANCH
         CLC   TDSN(5),C#TST1 SEE IF TST1. DATA SET
         BE    DDEND20        YES, BRANCH
         B     DDEND40        NO, GET OUT
DDEND20  TM    DISPIND,DELETE SEE IF DISP=DELETE
         BNO   DDEND30        NO, BRANCH
         TM    JOBIND,JOBSTC+JOBTECH IS JOB AUTHORIZED
         BM    DDEND30        YES, BRANCH
         LA    R15,29         SET ERROR NUMBER
         BAL   R14,ERRORTN    GO ISSUE ERROR MSG
         B     DDEND40        GET OUT
***********************************************************************
*        DO NOT ALLOW A DISP OTHER THAN "SHR" FOR SYSTEM DATA         *
*        SETS.                                                        *
***********************************************************************
DDEND30  TM    DISPIND,SHR    SEE IF DISP=SHR
         BO    DDEND40        YES, BRANCH
*        IF DISP NOT = SHR, MUST BE AUTHORIZED
         TM    JOBIND,JOBSTC+JOBTECH IS JOB AUTHORIZED
         BM    DDEND40        YES, BRANCH
         LA    R15,29         SET ERROR NUMBER
         BAL   R14,ERRORTN    GO ISSUE ERROR MSG
***********************************************************************
*        IF UNIT HAS NOT BEEN DETERMINED, THE UNIT TYPE MUST          *
*        BE SEARCHED FOR IN THE FOLLOWING ORDER:                      *
*                                                                     *
*        1)  THE DSNAME TABLE MAINTAINED BY THIS EXIT SINCE THE       *
*            DATASET MAY HAVE BEEN CATALOGED OR PASSED BY A           *
*            PREVIOUS DD STATEMENT.                                   *
*        2)  THE SYSTEM CATALOG                                       *
*                                                                     *
***********************************************************************
DDEND40  CLI   UNITIND,X'00'  SEE IF UNIT HAS BEEN DETERMINED
         BNE   DDEND150       YES, BRANCH
         CLI   TVOLSER,X'00'  SEE IF VOLSER SPECIFIED
         BE    DDEND45        NO, GO SEARCH TABLE AND/OR CATALOG
         BAL   R5,UCBSEAR     NO, GO SEARCH UCBS FOR PRIV MOUNT
         B     DDEND150       GET OUT
DDEND45  CLI   TDSN,C' '      SEE IF DSN SPECIFIED
         BE    DDEND150       NOT SPECIFIED, GET OUT
         TM    DISPIND,NEW    SEE IF THIS IS A NEW DATASET
         BO    DDEND150       YES, VOLSER WILL BE A WORK PACK
         L    R7,FIRSTENT     LOAD ADDR OF START OF TABLE
***********************************************************************
*        SEARCH THE DSNAME TABLE MAINTAINED BY THIS EXIT              *
***********************************************************************
DDEND50  LA   R7,ENTLEN(,R7) INCREMENT TO NEXT ENTRY
         CLI   ENTRYTYP,TYPEND END OF TABLE?
         BE    DDEND60        YES, GO CHECK CATALOG
         TM    ENTRYTYP,TYPEDD DD ENTRY?
         BNO   DDEND50        NO, LOOP
         CLC   DDSN,TDSN      DSN MATCH?
         BNE   DDEND50        NO, LOOP
         OC    UNITIND,DTYPE  SAVE UNIT INFO
         MVC   TVOLSER,DVOLSER SAVE VOLSER INFO
         B     DDEND150       GET OUT
***********************************************************************
*        SEARCH CATALOG FOR UNIT INFO                                 *
***********************************************************************
DDEND60  DS    0H
         AIF   ('&CAMLST' EQ 'YES').CAML1
         B     DDEND150       BYPASS CAMLST NOP
.CAML1   ANOP
         CLC   TDSN(5),C#SYS1 SEE IF SYS1. DATA SET
         BE    DDEND150       YES, NO NEED TO CAMLST
         TM    STRDINDC,DTXSYOUT SEE IF DD OUTPUT SPOOL FILE
         BO    DDEND150       YES, NO NEED TO CAMLST
         MVC   LDSN,TDSN      SAVE DSNAME
         BAL   R5,LOCATE      GO READ CATALOG
         LTR   R15,R15        TEST RETURN CODE
         BZ    DDEND70        ZERO, BRANCH
         CH    R15,H#8        DSNAME NOT FOUND OR GDG LEVEL?
         BE    DDEND90        YES, BRANCH
DDEND70  CLC   CAMLCNT,H#0    ANY VOLUME ENTRIES?
         BE    DDEND150       NO, BRANCH
         CLI   CAMVOL,X'00'   MAKE USER THAT THERE IS A VOLSER
         BE    DDEND150       NO, VSAM LIED AGAIN, IGNORE THIS ENTRY
         MVC   VOLCNT,CAMLCNT SAVE VOLUME COUNT
         MVC   TVOLSER,CAMVOL SAVE VOLSER FROM CATALOG
         TM    UCBTYP3,X'80'  TAPE UNIT?
         BO    DDEND80        YES, BRANCH
         BAL   R5,UCBSEAR     NO, GO SEARCH UCBS FOR PRIV MOUNT
         B     DDEND150       GET OUT
DDEND80  OI    UNITIND,TAPE   TURN ON TAPE IND
         B     DDEND150       BYPASS ROUTINES
         EJECT
***********************************************************************
*        DATA SET NOT FOUND, MAY BE GDG LEVEL                         *
*        DO A GENERIC LOCATE FOR THE DSNAME INDEX GIVEN               *
***********************************************************************
DDEND90  MVC   SVC26DS,LDSN   MOVE DSNAME TO SVC26 AREA
         LA    R1,43          LOAD MAXIMUM LENGTH OF DSN
         LA    R14,SVC26DS+42 LOAD ADDRESS OF END OF DSN
DDEND100 CLI   0(R14),C' '    SEE IF LAST CHAR DSN
         BNE   DDEND110       YES, BRANCH
         BCTR  R14,0          BACK UP DSN POINTER 1 POSITION
         BCT   R1,DDEND100    LOOP UNTIL FOUND
DDEND110 LTR   R1,R1          TEST LENGTH
         BZ    DDEND150       ZERO, NO DSN, BRANCH
         STC   R1,SVC26DSL    SAVE LENGTH OF DSN
         XC    CTGPL,CTGPL    ZERO PARM LIST
         MVI   CTGPL,B'00000111' SET CTGOPTN1
         MVI   CTGPL+2,B'00010001' SET CTGOPTN3
         LA    R1,SVC26DSN    LOAD ADDRESS OF DSNAME
         ST    R1,CTGPL+4     SET CTGENT
         XC    CTGPL+8(4),CTGPL+8 ZERO CTGCAT
         XC    CTGPL+18(4),CTGPL+18 ZERO CTGPSWD
         LH    R1,H#5000      LOAD LENGTH OF WORK AREA
         STH   R1,SVC26WRK    AND SAVE IT WORK AREA
         LA    R1,SVC26WRK    LOAD ADDRESS OF WORK AREA
         ST    R1,CTGPL+12    SET CTGWKA
         LA    R1,CTGPL       LOAD ADDRESS OF WORK AREA
         SVC   26             CALL CATALOG GENERIC SEARCH
         LTR   R15,R15        TEST RETURN CODE
         BNZ   DDEND150       NOT ZERO, BRANCH
***********************************************************************
*        FOUND DATA SETS AT THE GIVEN INDEX LEVEL.  CHECK TO SEE      *
*        IF GDG LEVEL.                                                *
***********************************************************************
         LH    R14,SVC26WRK+2 LOAD LENGTH OF AREA+4
         SH    R14,H#4        SUBTRACT LENGTH OF PREFIX
         SRDA  R14,32         SHIFT TO ODD REGISTER OF PAIR
         D     R14,F#45       DIVIDE BY LENGTH OF EACH ENTRY
         LTR   R4,15          TEST NUMBER OF DSNAMES RETURNED
         BZ    DDEND150       ZERO, NONE
         BM    DDEND150       NEGATIVE, ERROR
         LA    R2,SVC26WRK+4  POINT TO FIRST DSN
         CLI   0(R2),C'B'     IS THIS A GDG BASE (VSAM CATALOG ONLY)
         BE    DDEND140       YES, BRANCH
         CLI   0(R2),C'A'     IS THIS A NONVSAM ENTRY
         BNE   DDEND150       NO, BRANCH
         SLR   R15,R15        ZERO, REGISTER FOR IC
         IC    R15,SVC26DSL   LOAD BASE DSN LENGTH
         LA    R15,2(R15,R2)  POINT PAST TYPE, BASE, AND '.'
         CLI   0(R15),C'G'    POSSIBLE GDG
         BNE   DDEND150       NO, BRANCH
         CLI   5(R15),C'V'    POSSIBLE GDG
         BNE   DDEND150       NO, BRANCH
         CLI   8(R15),C' '    POSSIBLE GDG
         BNE   DDEND150       NO, BRANCH
         MVC   DOUBLE,0(R15)  SAVE DSN SUFFIX
         OC    DOUBLE,GDGMASK TEST NUMERIC POSITIONS
         CLC   DOUBLE,0(R15)  SEE IF CHANGED
         BNE   DDEND150       YES, NOT GDG, BRANCH
         OI    UNITIND,UNITGDG UNIT INFORMATION FROM GDG PROCESSING
***********************************************************************
*        LOCATE INDIVIDUAL DATA SETS RETURNED FROM THE GENERIC        *
*        LOCATE FROM SVC26.  ALL ENTRIES ARE LOCATED TO GET THE       *
*        VOLUME COUNT IF 'PARALLEL' MOUNTING IS REQUESTED.            *
***********************************************************************
DDEND120 MVC   LDSN,1(R2)     SAVE DSNAME
         BAL   R5,LOCATE      GO READ CATALOG
         LTR   R15,R15        TEST RETURN CODE
         BNZ   DDEND140       NOT ZERO, SOMETHINGS WRONG, LOOP
         CLC   CAMLCNT,H#0    ANY VOLUME ENTRIES?
         BE    DDEND140       NO, BYPASS ENTRY
         CLI   CAMVOL,X'00'   MAKE USER THAT THERE IS A VOLSER
         BE    DDEND140       NO, VSAM LIED AGAIN, IGNORE THIS ENTRY
         MVC   TVOLSER,CAMVOL SAVE VOLSER FROM CATALOG
         SLR   R15,R15        CLEAR REG FOR IC
         IC    R15,VOLCNT     LOAD VOLUME COUNT
         AH    R15,CAMLCNT    ADD CAMLST VOLUME COUNT
         STC   R15,VOLCNT     SAVE NEW VOLUME COUNT
         TM    UCBTYP3,X'80'  TAPE UNIT?
         BO    DDEND130       YES, BRANCH
         BAL   R5,UCBSEAR     NO, GO SEARCH UCBS FOR PRIV MOUNT
         B     DDEND140       GET OUT
DDEND130 OI    UNITIND,TAPE   TURN ON TAPE IND
DDEND140 LA    R2,45(,R2)     INCREMENT TO NEXT ENTRY
         BCT   R4,DDEND120    LOOP UNTIL DONE
***********************************************************************
*        PROCESS ONLY DD STATEMENTS WHICH ARE FOR MOUNTABLE           *
*        DEVICES.                                                     *
***********************************************************************
DDEND150 TM    UNITIND,TAPE   IS THIS A TAPE DD?
         BO    DDEND160       YES, BRANCH
         TM    UNITIND,PRIV   IS THIS A PRIV DD?
         BNO   DDEND240       NO, DO NOT SAVE
***********************************************************************
*        IF THIS STATEMENT REQUIRES A MOUNTABLE DISK PACK, WRITE      *
*        AN ERROR MESSAGE SINCE WE NO LONGER HAVE ANY MOUNTABLE       *
*        DISK PACKS.                                                  *
***********************************************************************
         TM    JOBIND2,MOUNT  DOES JOB HAVE DASD MOUNT AUTHORITY
         BO    DDEND160       YES, BRANCH
         LA    R15,48         SET ERROR NUMBER
         BAL   R14,ERRORTN    GO ISSUE ERROR MSG
***********************************************************************
*        IF THE UNIT WAS DETERMINED BY UNIT=AFF, DO NOT CHARGE        *
*        FOR THE DEVICE BUT SAVE THE TABLE ENTRY FOR POSSIBLE         *
*        REFERBACKS BY SUBSEQUENT STATEMENTS.                         *
***********************************************************************
DDEND160 TM    UNITIND,AFF    UNIT=AFF DD STATEMENT
         BO    DDEND230       YES, DO NOT ADD TO UNIT COUNTS
         CLI   TVOLSER,X'00'  VOLSER SPECIFIED??
         BE    DDEND180       NO, BRANCH
         L    R7,LASTEXEC     LOAD ADDR LAST EXEC ENTRY
***********************************************************************
*        SEE IF THE VOLSER WAS USED PREVIOUSLY IN THIS STEP.          *
*        IF SO, DO NOT CHARGE FOR THE DEVIDE BUT AGAIN SAVE THE       *
*        TABLE ENTRY FOR POSSIBLE REFERBACKS BY FOLLOWING             *
*        STATEMENTS.                                                  *
***********************************************************************
DDEND170 LA   R7,ENTLEN(,R7) INCREMENT TO NEXT ENTRY
         CLI   ENTRYTYP,TYPEND SEE IF END OF TABLE
         BE    DDEND180       YES, NO MATCH, BRANCH
         CLC   TVOLSER,DVOLSER SEE IF VOLSER ALREADY REFERENCED
         BE    DDEND230       YES, DO NOT CHARGE FOR IT
         B     DDEND170       LOOP
***********************************************************************
*        IF PARALLEL MOUNTING WAS REQUESTED, CHARGE THE GREATER       *
*        OF THE DEVICES SPECIFIED BY THE UNITCOUNT FIELD OR THE       *
*        NUMBER OF VOLUMES.                                           *
***********************************************************************
DDEND180 CLI   UNITCOUN,C'P'  SEE IF PARALLEL MOUNTING
         BE    DDEND190       YES, BRANCH
         MVC   ADDCOUNT,UNITCOUN MOVE UNIT COUNT TO COMMON
         B     DDEND210       BRANCH
DDEND190 CLC   VOLCNT,SERCNT COMPARE VOL COUNT & SERIAL CNT
         BL    DDEND200       SERIAL COUNT GREATER
         MVC   ADDCOUNT,VOLCNT MOVE VOLUME COUNT TO COMMON
         B     DDEND210       BRANCH
DDEND200 MVC   ADDCOUNT,SERCNT MOVE SERIAL COUNT TO COMMON
***********************************************************************
*        ADD THE DEVICE COUNT TO THE APPROPRIATE ACCUMULATOR.         *
***********************************************************************
DDEND210 SLR   R15,R15        ZERO WORK REG
         IC    R15,ADDCOUNT   MOVE UNIT COUNT TO REG
         TM    UNITIND,TAPE   IS THIS A TAPE DD?
         BO    DDEND220       YES, BRANCH
         AH    R15,PRIVCNT    ADD RUNNING COUNT TO THIS ONE
         STH   R15,PRIVCNT    SAVE NEW RUNNING COUNT
         B     DDEND230       BRANCH
DDEND220 AH    R15,TAPECNT    ADD RUNNING COUNT TO THIS ONE
         STH   R15,TAPECNT    SAVE NEW RUNNING COUNT
***********************************************************************
*        SAVE THE CURRENT TEMPORARY ENTRY SINCE IT SPECIFIES A        *
*        MOUNTABLE DEVICE TYPE.                                       *
***********************************************************************
DDEND230 OC    TTYPE,UNITIND  SAVE UNIT INFO
         LH    R14,ENTCOUNT   LOAD TABLE ENTRY COUNT
         LA    R14,1(,R14)    ADD 1 TO COUNT
         CH    R14,MAXENTS    SEE IF MAXIMUM REACHED
         BNL   TBLFULL        MAXIMUM REACHED, TAKE DUMP & EXIT
         STH   R14,ENTCOUNT   STORE NEW ENTRY COUNT
         L    R7,LASTENT      LOAD ADDR OF LAST ENTRY
         LA   R7,ENTLEN(,R7) INCREMENT TO NEXT ENTRY
         MVI   ENTRYTYP,TYPEDD SET ENTRY TO DD
         MVC   DENTRY,TENTRY  MOVE TEMPORARY ENTRY TO TABLE
         MVC   DVOLSER,TVOLSER MOVE TEMP VOLSER TO TABLE
         MVC   DTYPE,UNITIND  SAVE UNIT INDICATOR
         ST   R7,LASTENT      SAVE ADDR OF LAST ENTRY
***********************************************************************
*        IF THE DD STATEMENT IS FOR A JOBLIB, STEPLIB, JOBCAT,        *
*        OR A STEPCAT, THE DISPOSITION MUST BE "SHR".                 *
***********************************************************************
DDEND240 CLC   TDDN,C#JOBLIB  SEE IF JOBLIB DD
         BE    DDEND250       YES, BRANCH
         CLC   TDDN,C#STEPLI  SEE IF STEPLIB DD
         BE    DDEND260       YES, BRANCH
         CLC   TDDN,C#JOBCAT  SEE IF JOBCAT DD
         BE    DDEND270       YES, BRANCH
         CLC   TDDN,C#STEPCA  SEE IF STEPCAT DD
         BE    DDEND270       YES, BRANCH
         B     DDALLDON       NO, GET OUT
DDEND250 OI    JOBIND,JOBLIB  TURN ON JOBLIB INDICATOR
***********************************************************************
*        IF THE DD STATEMENT IS FOR A JOBLIB, THE JOB MUST BE         *
*        AUTHORIZED.                                                  *
***********************************************************************
         TM    JOBIND,JOBTECH IS JOBLIB ALLOWED
         BO    DDEND260       YES, BRANCH
*        B     DDEND260       ALLOW EVERYONE TO HAVE JOBLIB  OVERRIDE
         LA    R15,47         SET ERROR NUMBER
         BAL   R14,ERRORTN    GO ISSUE ERROR MSG
         B     DDALLDON       GET OUT
DDEND260 TM    DISPIND,SHR    SEE IF DISP=SHR
         BO    DDALLDON       YES, BRANCH
         LA    R15,33         SET ERROR NUMBER
         BAL   R14,ERRORTN    GO ISSUE ERROR MSG
         B     DDALLDON       GET OUT
***********************************************************************
*        IF THE DD STATEMENT IS FOR A JOBCAT OR A STEPCAT, THE        *
*        JOB MUST BE AUTHORIZED.                                      *
***********************************************************************
DDEND270 TM    JOBIND,JOBSTC+JOBTECH SEE IF JOBCAT/STEPCAT ALLOWED
         BM    DDEND280       YES, BRANCH
         LA    R15,43         SET ERROR NUMBER
         BAL   R14,ERRORTN    GO ISSUE ERROR MSG
DDEND280 TM    DISPIND,SHR    SEE IF DISP=SHR
         BO    DDALLDON       YES, BRANCH
         LA    R15,33         SET ERROR NUMBER
         BAL   R14,ERRORTN    GO ISSUE ERROR MSG
DDALLDON B     GETNEXT        GO GET NEXT TEXT RECORD
         EJECT
***********************************************************************
*        THE TEXT OF THE EXEC CARD WHICH CALLS A PROC IS AS FOLLOWS   *
*            1)  2 BYTE LENGTH OF TEXT STRING INCLUDING ITSELF        *
*            2)  1 BYTE INDICATOR COMMON TO ALL TEXT RECORDS          *
*            3)  1 BYTE OF MISCELLANEOUS INDICATORS                   *
*            4)  1 BYTE INDICATOR X'94' INDICATING EXEC POS INFORMATN *
*            5)  1 BYTE NUMBER OF EXEC POSITIONAL PARAMETERS          *
*                THE 1ST POS PARAMETER IS THE JOB STEP NAME           *
*                THE 2ND POS PARAMETER IS THE PROC NAME               *
*            6)  VARIABLE LENGTH LIST OF EXEC POS PARAMETERS          *
*                EACH PRECEDED BY A 1 BYTE LENGTH FIELD               *
*            7)  THE REST OF THE RECORD WILL BE IGNORED               *
***********************************************************************
*
***********************************************************************
*        THE TEXT OF THE PROC CARD WILL BE SAVED FOR SUBSEQUENT       *
*        EXEC CARD PROCESSING.  THE STEP NAME WILL BE SAVED FROM      *
*        THE PROC CARD AND AND A POINTER SAVED TO THE START OF        *
*        THE FIRST KEYWORD PARM.  AFTER THE NORMAL EXEC CARD HAS      *
*        BEEN PROCESSED, THE PROC CARD TEXT WILL BE PROCESSED         *
*        WHICH WILL OVERRIDE ANY PREVIOUSLY PROCESSED PARAMETERS      *
*        ON THE EXEC CARD.                                            *
***********************************************************************
         EJECT
***********************************************************************
*        SAVE THE ENTIRE TEXT OF THE EXECUTE STATEMENT WHICH          *
*        CALLS A PROCEDURE SO THAT ALL PROC OVERRIDES MAY BE          *
*        PROCESSED.                                                   *
***********************************************************************
PROCARD  EQU   *
PROCSTAR LR    R14,R6         SAVE ADDRESS OF CURRENT RECORD
         LH    R15,STRLTH     LOAD LENGTH OF TEXT RECORD
         CH    R15,H#512      SEE IF LENGTH EXCEEDS 512 BYTES
         BNH   *+16           NO, BRANCH
         LA    R15,30         SET ERROR NUMBER
         BAL   R14,ERRORTN    GO ISSUE ERROR MSG
         B     GETNEXT        GET OUT
         LA    R0,PROCTXT     LOAD ADDR OF TEXT SAVE AREA
         LR    R1,R15         LET REG 1 ALSO CONTAIN THE LENGTH
         MVCL  R0,R14         MOVE TEXT STRING TO SAVE
         LA    R6,PROCTXT     POINT TO START OF COPIED TEXT
         LA    R2,STREKEY     LOAD START OF TRUE TEXT
         ST    R2,PARMADDR    SAVE START OF PARAMETER ADDRESS
         LA    R2,1(,R2)      INCR PAST EXEC POS IND
         SLR   R4,R4          CLEAR REG FOR ICM
         ICM   R4,1,0(R2)     LOAD NUMBER OF SUBPARAMETERS
         BNZ   PROCEND1       NOT ZERO, BRANCH
         LA    R2,1(,R2)      ZERO, INCREMENT PAST COUNT
         B     PROCEND3       GET OUT
***********************************************************************
*        SAVE THE PROC STEP NAME                                      *
***********************************************************************
PROCEND1 LA    R2,1(,R2)      INCREMENT PAST COUNT
         MVI   SAVEPROC,C' '  MOVE BLANK TO 1ST POS SAVE
         MVC   SAVEPROC+1(7),SAVEPROC BLANK ENTIRE STEP NAME SAVE
         SLR   R3,R3          CLEAR REG FOR ICM
         ICM   R3,1,0(R2)     LOAD LENGTH OF JOB STEP NAME
         BZ    PROCEND2       IF ZERO, NO JOB STEP NAME
         CH    R3,H#8         SEE IF LENGTH > 8
         BNH   *+16           NO, CONTINUE
         LA    R15,31         SET ERROR NUMBER
         BAL   R14,ERRORTN    GO ISSUE ERROR MSG
         B     GETNEXT        GET OUT
         BCTR  R3,0           MAKE MACHINE LENGTH
         EX    R3,MOVE4       MOVE STEP NAME TO SAVE AREA
PROCEND2 ICM   R3,1,0(R2)     LOAD LENGTH OF SUBPARAMETER
         LA    R2,1(R3,R2)    INCREMENT TO NEXT SUBPARAMETER
         BCT   R4,PROCEND2    LOOP UNTIL DONE
***********************************************************************
*        SAVE POINTER TO THE FIRST KEYWORD ON THE STATEMENT           *
***********************************************************************
PROCEND3 ST    R2,PROCTEXT    SAVE ADDRESS OF FIRST KEYWORD PARM
         B     GETNEXT        GET OUT
         EJECT
***********************************************************************
*        IF THE CURRENT EXECUTE STATEMENT IS FROM A PROCEDURE,        *
*        LOAD THE ADDRESS OF THE PREVIOUS STATEMENT WHICH CALLED      *
*        THE PROCEDURE AND RETURN TO THE EXECUTE CARD PROCESSOR       *
*        TO PROCESS THE OVERRIDES WHICH MAY HAVE BEEN ENTERED         *
*        ON THAT STATEMENT.                                           *
***********************************************************************
PROCSEAR TM    STREINDC,ETXPROC STATEMENT FROM A PROCEDURE?
         BNO   GETNEXT        NO, GET OUT
         XI    PROCIND,X'01'  FLIP-FLOP SWITCH
         BZ    GETNEXT        NOW ZERO, ALREADY PROCESSED PROC TEXT
         L     R2,PROCTEXT    LOAD ADDR OF PROC TEXT
         ST    R2,PARMADDR    SAVE START OF PARAMETER ADDRESS
         B     EXECPARM       GO PROCESS ADDITIONAL TEXT
         EJECT
***********************************************************************
*                                                                     *
*                         L O C A T E                                 *
*                                                                     *
*        ISSUE THE LOCATE MACRO TO OBTAIN THE REQUESTED UNIT TYPE     *
*        AND VOLSER INFORMATION.                                      *
*                                                                     *
***********************************************************************
LOCATE   LA    R15,68         LOAD OPTION VALUE
         SLL   R15,24         SHIFT OPTION TO HIGH BYTE
         ST    R15,CAMLST     STORE INTO CAMLST AREA
         LA    R15,LDSN       LOAD ADDR OF DSN
         ST    R15,CAMLST+4   STORE INTO CAMLST AREA
         XC    CAMLST+8(4),CAMLST+8 ZERO 3RD PARAM CAMLST AREA
         XC    LOCAREA(12),LOCAREA CLEAR FIRST PART OF THE WORK AREA
         LA    R15,LOCAREA    LOAD ADDR OF LOCATE WORK AREA
         ST    R15,CAMLST+12  STORE INTO CAMLST AREA
         LOCATE CAMLST        READ CATALOG
         BR    R5             RETURN TO CALLER
         EJECT
***********************************************************************
*                                                                     *
*                         U C B S E A R                               *
*                                                                     *
*        SEARCH THE SYSTEM UCBS TO SEE IF THE REQUESTED DASD VOLUME   *
*        IS MOUNTED OR ONLY MOUNTED PRIVATE IN WHICH CASE IT WILL     *
*        BE DISMOUNTED AT END OF JOB.  IF NOT FOUND OR PRIVATE, IT    *
*        IS A 'PRIV' UNIT.                                            *
*                                                                     *
***********************************************************************
UCBSEAR  DS    0H
         AIF   ('&UCBSEAR' EQ 'YES').UCBS1
         BR    R5             RETURN TO CALLER
         AGO   .UCBS2
.UCBS1   ANOP
         STM   R14,R12,SAVEREGS SAVE REGISTERS
         XC    LASTUCB,LASTUCB ZERO LAST EBCDIC UCB ADDR
         SLR   R4,R4          CLEAR REGISTER FOR ICM INSTR
         L     R2,16          LOAD CVT ADDR
         L     R2,40(,R2)     LOAD ADDR OF UCB LOOKUP TABLE
UCBSEAR1 ICM   R4,3,0(R2)     LOAD ADDR OF NEXT UCB
         LA    R2,2(,R2)      INCREMENT TO NEXT LOOKUP ENTRY
         BZ    UCBSEAR1       ZERO, NULL ENTRY, LOOP
         C     R4,LASTUCB     SEE IF ADDR > LAST UCB ADDR
         BL    UCBSEAR1       NO, OPCHAN DEVICE,LOOP
         ST    R4,LASTUCB     SAVE LAST UCB ADDR
         C     R4,X#FFFF      SEE IF END OF TABLE
         BE    UCBSEAR2       YES, VOLSER NOT FOUND
         TM    18(R4),32      DASD DEVICE?
         BNO   UCBSEAR1       NO, LOOP
         TM    3(R4),128      ONLINE?
         BNO   UCBSEAR1       NO, LOOP
         CLC   TVOLSER,28(R4) SEE IF CAT. VOLSER IN UCB
         BNE   UCBSEAR1       NO, LOOP
         TM    3(R4),X'24'    SEE IF PERM RES OR RESERVED
         BZ    UCBSEAR2       NOT EITHER, THEN MUST BE PRIV
         B     UCBSEAR3       GET OUT, NO CHARGE
UCBSEAR2 OI    UNITIND,PRIV   SINCE VOLUME NOT MOUNTED, PRIV
UCBSEAR3 LM    R14,R12,SAVEREGS RESTORE REGISTERS
         BR    R5             RETURN TO CALLER
.UCBS2   ANOP
         EJECT
***********************************************************************
*        UPDATE LAST EXEC TABLE (IF NEEDED) WITH UNIT INFO            *
***********************************************************************
EOF      TM    JOBIND,JOBFAIL WAS JOB FAILED BY EXIT?
         BO    JOBERROR       YES, BRANCH
         L    R7,LASTEXEC     LOAD ADDR OF LAST EXEC ENTRY
         LTR  R7,R7           SEE IF ADDR = 0
         BZ    EOF1           IF ZERO, NO UPDATE, BRANCH
         MVC   ETAPES,TAPECNT MOVE STEP TAPE UNIT CNT TO TABLE
         MVC   EPRIVS,PRIVCNT MOVE STEP PRIV UNIT CNT TO TABLE
         XC    TAPECNT,TAPECNT ZERO TAPE UNIT CNT
         XC    PRIVCNT,PRIVCNT ZERO PRIV UNIT CNT
         EJECT
***********************************************************************
*        THIS ROUTINE SEARCHES THE TABLE SAVED FOR JOB, EXEC AND DD   *
*        ENTRIES TO DETERMINE THE MAXIMUM RESOURCES USED BY THE JOB   *
*        THIS INFORMATION WILL BE USED TO COMPARE AGAINST A CLASS     *
*        TABLE TO DETERMINE THE CLASS WHICH SHOULD BE SET FOR THE JOB.*
***********************************************************************
EOF1     MVC   STEPM,MSG0     INITIALIZE STEP MESSAGE
         MVC   JOBM,MSG1      INITIALIZE JOB CLASS MESSAGE
         MVC   JOBMSG(10),BLANKS BLANK MESSAGE PREFIX
         XC    MAXTAPE,MAXTAPE ZERO MAX FIELD
         XC    MAXPRIV,MAXPRIV ZERO MAX FIELD
         XC    MAXTOTAL,MAXTOTAL ZERO MAX FIELD
         XC    MAXREGN,MAXREGN ZERO MAX FIELD
         L    R7,FIRSTENT     LOAD START OF TABLE
         CLC   ENTLEN(2,R7),H#0 SEE IF ONLY JOB ENTRY
         BE    JOBERROR       ZEROS, NO OTHER ENTRIES, FLUSH JOB
EOFLOOP1 CLI   ENTRYTYP,TYPJOB SEE IF JOB ENTRY
         BE    EOFLOOP2       YES, BRANCH
         CLI   ENTRYTYP,TYPEXEC SEE IF EXEC ENTRY
         BE    EOFEXEC        YES, BRANCH
         CLI   ENTRYTYP,TYPEND SEE IF END OF TABLE
         BE    EOFSCAN        YES, BRANCH
         B     EOFLOOP2       LOOP
***********************************************************************
*        PRODUCE A STEP RESOURCE STATISTICS MESSAGE FOR EACH STEP     *
*        TO BE WRITTEN TO THE JES2 MESSAGE DATA SET.                  *
***********************************************************************
EOFEXEC  L     R4,ECARDNO     LOAD CARD NUMBER
         CVD   R4,DOUBLE      CONVERT CARD NUMBER TO PACKED
         MVC   STEPMSG-1(11),PREFIX MOVE MSG PREFIX TO MESSAGE
         ED    STEPMSG-1(6),DOUBLE+5 EDIT CARD NUMBER TO PREFIX
         MVC   STEPM+8(8),EJSTEP   MOVE JOB STEP TO MESSAGE
         MVC   STEPM+17(8),EPSTEP  MOVE PROC STEP TO MESSAGE
         LH    R4,ETAPES      LOAD NUMBER OF TAPES FOR STEP
         CVD   R4,DOUBLE      CONVERT TO PACKED
         MVC   STEPM+32(6),EDMASK  SET MESSAGE EDIT MASK
         ED    STEPM+32(6),DOUBLE+5 EDIT NUMBER OF TAPES TO MESSAGE
         LH    R4,EPRIVS      LOAD NUMBER OF PACK MOUNTS FOR STEP
         CVD   R4,DOUBLE      CONVERT TO PACKED
         MVC   STEPM+45(6),EDMASK  SET MESSAGE EDIT MASK
         ED    STEPM+45(6),DOUBLE+5 EDIT NUMBER OF PACK MOUNTS TO MSG
         LH    R4,EREGION     LOAD REGION SIZE FOR STEP
         CVD   R4,DOUBLE      CONVERT TO PACKED
         MVC   STEPM+59(6),EDMASK  SET MESSAGE EDIT MASK
         ED    STEPM+59(6),DOUBLE+5 EDIT REGION SIZE TO MESSAGE
         L     R4,MAXTIME     LOAD MAXIMUM CPU JOB CPU TIME
         CVD   R4,DOUBLE      CONVERT TO PACKED
         MVC   STEPM+73(6),EDMASK  SET MESSAGE EDIT MASK
         ED    STEPM+73(6),DOUBLE+5 EDIT REGION SIZE TO MESSAGE
         LA    R15,STEPMSG    LOAD ADDRESS OF STEP MESSAGE
         BAL   R14,MSGRTN     GO PUT MESSAGE TO JES MESSAGE DATA SET
***********************************************************************
*        COMPARE THE RESOURCES USED BY THIS STEP TO THE MAXIMUM       *
*        RESOURCES USED BY PREVIOUS STEPS.  RETAIN THE GREATER        *
*        OF THE NUMBER OF RESOURCES.                                  *
***********************************************************************
EOFCONT1 CLC   ETAPES,MAXTAPE COMPARE STEP TAPES TO PREV MAX
         BNH   EOFEXEC1       NOT GREATER, BRANCH
         MVC   MAXTAPE,ETAPES MAKE CURR COUNT NEW COUNT
EOFEXEC1 CLC   EPRIVS,MAXPRIV COMPARE STEP PRIVS TO PREV MAX
         BNH   EOFEXEC2       NOT GREATER, BRANCH
         MVC   MAXPRIV,EPRIVS MAKE CURR COUNT NEW COUNT
EOFEXEC2 LH    R4,EPRIVS      LOAD NUMBER OF PRIVS IN STEP
         AH    R4,ETAPES      ADD NUMBER OF TAPES
         CH    R4,MAXTOTAL    COMPARE STEP TOT CNT TO PREV MAX
         BNH   EOFEXEC3       NOT GREATER, BRANCH
         STH   R4,MAXTOTAL    MADE CURR TOTAL CNT NEW MAX
EOFEXEC3 CLC   EREGION,MAXREGN COMPARE STEP REGION TO PREV MAX
         BNH   EOFLOOP2       NOT GREATER, BRANCH
         MVC   MAXREGN,EREGION MAKE CURR REGION NEW MAX
EOFLOOP2 LA   R7,ENTLEN(,R7) INCREMENT TO NEXT ENTRY
         B     EOFLOOP1       LOOP
EOFSCAN  CLC   MAXTAPE,H#0    SEE IF ANY TAPES
         BE    EOFPACK        NO TAPES, GO CHECK FOR PRIV
         OI    RESOURCE,TAPES TURN ON TAPES RESOURCE
EOFPACK  CLC   MAXPRIV,H#0    SEE IF ANY PRIV
         BE    EOFLJOB        NO, BRANCH
         OI    RESOURCE,USERPACK TURN ON USERPACK RESOURCE
EOFLJOB  CLC   MAXTIME,F#15   SEE IF CPU TIME > 15
         BNH   CLASSEAR       NO, BRANCH
         OI    RESOURCE+1,LONGJOB TURN ON LONGJOB RESOURCE
         EJECT
***********************************************************************
*        THIS ROUTINE SEARCHES THE APPROPRIATE CLASS TABLES FOR       *
*        MATCHES ON RESOURCES USED TO DETERMINE THE CORRECT CLASS     *
*        FOR A JOB.  NOTE THAT EACH GROUP (TEST, PRODUCTION,          *
*        OPERATIONS, AND TECH SUPPORT HAVE CLASSES WHICH MAY BE       *
*        SPECIFIED IN ORDER TO BYPASS THE TABLES OR USED TO SINGLE    *
*        THREAD A SERIES OF JOBS BECAUSE THERE WILL ONLY BE ONE       *
*        INITIATOR SET TO THAT CLASS.                                 *
***********************************************************************
CLASSEAR TM    JOBIND,JOBSTC+JOBTSO STC OR TSO
         BM    NOCHANGE       YES, NO CHANGE OF CLASS
         L    R7,FIRSTENT     LOAD START OF TABLE
         LA    R4,JCLASS1     LOAD ADDR OF TEST CLASS TABLE
         TM    JOBIND,JOBPROD SEE IF PRODUCTION JOB
         BO    CLASSPRD       YES, BRANCH
         TM    JOBIND,JOBTEST SEE IF TEST JOB
         BO    CLASST         YES, BRANCH
         TM    JOBIND,JOBTECH SEE IF TECH SUPPORT JOB
         BO    CLASSTS        YES, BRANCH
         TM    JOBIND,JOBOPER SEE IF OPERATIONS JOB
         BNO   EOFSCAN1       NO, USE TEST CLASS TABLE
***********************************************************************
*                     O P E R A T I O N S                             *
***********************************************************************
CLASSOP  LA    R4,JCLASS1     LOAD ADDR OF TEST CLASS TABLE
         CLI   INCLASS,C'M'   SPECIAL CLASS FOR OPERATIONS
         BNE   EOFSCAN1       NO, USE TEST CLASS TABLE
         MVI   CLASSFLD,C'M'  SET NEW CLASS TO 'M'
         B     CKCLASS        BYPASS TABLE SEARCH
***********************************************************************
*                 T E C H    S U P P O R T                            *
***********************************************************************
CLASSTS  LA    R4,JCLASS1     LOAD ADDR OF TEST CLASS TABLE
         CLI   INCLASS,C'S'   SPECIAL CLASS FOR TECH SUPPORT
         BNE   EOFSCAN1       NO, USE TEST CLASS TABLE
         MVI   CLASSFLD,C'S'  SET NEW CLASS TO 'S'
         B     CKCLASS        BYPASS TABLE SEARCH
***********************************************************************
*                       T E S T                                       *
***********************************************************************
*
***********************************************************************
*        TEST JOBS HAVE SEVERAL JOB CLASSES WHICH MAY BE USED         *
*        FOR SPECIAL REASONS.  THE CLASS SPECIFIED IN THE JOB         *
*        CARD WILL BE USED TO SEARCH A TABLE TO SEE IF ONE OF         *
*        THOSE CLASSES WAS ENTERED.  THE ALLOWABLE RESOURCES          *
*        FOR THAT JOB CLASS WILL BE COMPARED TO THE RESOURCES         *
*        ACTUALLY USED BY THE JOB.  IF THE RESOURCES USED ARE         *
*        GREATER THAN THOSE ALLOWED BY THE SPECIAL CLASS, THE         *
*        JOB WILL BE GIVEN A JCL ERROR.                               *
***********************************************************************
CLASST   LA    R4,JCLASS2     LOAD ADDR OF SPECIAL TEST CLASS TABLE
         CLI   INCLASS,C'0'   SPECIAL SETUP CLASS FOR TEST JOBS
         BNE   CLASST1        NO, BRANCH
         MVI   CLASSFLD,C'0'  SET NEW CLASS TO '0'
         B     CKCLASS        BYPASS TABLE SEARCH
CLASST1  CLI   0(R4),X'00'    END OF TABLE
         BE    CLASST4        YES, GO SCAN REGULAR TABLE
         CLC   INCLASS,0(R4)  SPECIAL CLASS MATCH
         BE    CLASST2        YES, BRANCH
         LA    R4,16(,R4)     INCREMENT TO NEXT ENTRY
         B     CLASST1        LOOP
CLASST2  CLC   MAXTAPE,4(R4)  MATCH TAPE COUNT
         BH    CLASST3        COUNT EXCEEDS TABLE, BRANCH
         CLC   MAXPRIV,6(R4)  MATCH PRIV COUNT
         BH    CLASST3        COUNT EXCEEDS TABLE, BRANCH
         CLC   MAXTOTAL,8(R4) MATCH TOTAL COUNT
         BH    CLASST3        COUNT EXCEEDS TABLE, BRANCH
         CLC   MAXREGN,10(R4) MATCH REGION VALUES
         BH    CLASST3        REGION EXCEEDS TABLE, BRANCH
         CLC   MAXTIME,12(R4) MATCH MAXIMUM CPU TIME
         BH    CLASST3        CPU TIME EXCEEDS TABLE, BRANCH
         MVC   CLASSFLD,0(R4) MOVE CLASS TO SAVE AREA
         B     CKCLASS        GET OUT OF SEARCH
CLASST3  MVC   ERRORM,MSG3    INITIALIZE ERROR MESSAGE
         MVC   ERRORMSG(10),BLANKS BLANK MESSAGE PREFIX
         LA    R15,ERRORMSG   LOAD ADDRESS OF MESSAGE
         BAL   R14,MSGRTN     GO ISSUE ERROR MSG
         OI    JOBIND,JOBFAIL TURN ON JOB FAILED IND
         MVI   CLASSFLD,C'A'  SET TO CLASS=A
         B     CKCLASS        GO SET DEFAULT CLASS
CLASST4  LA    R4,JCLASS1     LOAD ADDR OF STD TEST CLASS TABLE
         B     EOFSCAN1       GO USE TEST CLASS TABLE
***********************************************************************
*                     P R O D U C T I O N                             *
***********************************************************************
CLASSPRD LA    R4,JCLASS3     LOAD ADDR OF PROD CLASS TABLE
         CLI   INCLASS,C'H'   SPECIAL SETUP CLASS FOR TEST JOBS
         BNE   EOFSCAN1       NO, GO USE PROD CLASS TABLE
         MVI   CLASSFLD,C'H'  SET NEW CLASS TO 'H'
         B     CKCLASS        BYPASS TABLE SEARCH
***********************************************************************
*        SCAN THE APPROPRIATE CLASS TABLE FOR THE CLASS WHICH         *
*        MATCHES THE RESOURCES USED BY THE JOB.                       *
***********************************************************************
EOFSCAN1 CLI   0(R4),X'00'    END OF TABLE
         BNE   EOFSCAN2       NO, CONTINUE
         MVC   ERRORM,MSG4    INITIALIZE ERROR MESSAGE
         MVC   ERRORMSG(10),BLANKS BLANK MESSAGE PREFIX
         LA    R15,ERRORMSG   LOAD ADDRESS OF MESSAGE
         BAL   R14,MSGRTN     GO ISSUE ERROR MSG
         MVI   CLASSFLD,C'A'  SET TO CLASS=A
         B     CKCLASS        GO SET DEFAULT CLASS
EOFSCAN2 CLC   MAXTAPE,4(R4)  MATCH TAPE COUNT
         BH    EOFSCAN3       COUNT EXCEEDS TABLE, BRANCH
         CLC   MAXPRIV,6(R4)  MATCH PRIV COUNT
         BH    EOFSCAN3       COUNT EXCEEDS TABLE, BRANCH
         CLC   MAXTOTAL,8(R4) MATCH TOTAL COUNT
         BH    EOFSCAN3       COUNT EXCEEDS TABLE, BRANCH
         CLC   MAXREGN,10(R4) MATCH REGION VALUES
         BH    EOFSCAN3       REGION EXCEEDS TABLE, BRANCH
         CLC   MAXTIME,12(R4) MATCH MAXIMUM CPU TIME
         BH    EOFSCAN3       CPU TIME EXCEEDS TABLE, BRANCH
         MVC   CLASSFLD,0(R4) MOVE CLASS TO SAVE AREA
         B     CKCLASS        GET OUT OF SEARCH
EOFSCAN3 LA    R4,16(,R4)     INCREMENT TO NEXT ENTRY
         B     EOFSCAN1       LOOP
***********************************************************************
*        IF THE CLASS WHICH WAS SPECIFIED OR DETERMINED WAS CLASS     *
*        "0", THE JOB MUST HAVE SPECIFIED TYPRUN=HOLD ON THE JOB      *
*        CARD.                                                        *
***********************************************************************
CKCLASS  CLI   CLASSFLD,C'0'  UNLIMITED TEST CLASS?
         BNE   SETCLASS       NO, BRANCH
         TM    JOBIND2,HELD   SEE IF HELD JOB
         BO    SETCLASS       YES, GO SET CLASS
         MVC   ERRORM,MSG2    INITIALIZE ERROR MESSAGE
         MVC   ERRORMSG(10),BLANKS BLANK MESSAGE PREFIX
         LA    R15,ERRORMSG   LOAD ADDRESS OF MESSAGE
         BAL   R14,MSGRTN     GO ISSUE ERROR MSG
         OI    JOBIND,JOBFAIL TURN ON JOB FAILED IND
         B     JOBERROR       GO KILL THE JOB
SETCLASS MVC   JOBM+21(1),CLASSFLD MOVE NEW CLASS TO MESSAGE
         LA    R15,JOBMSG     LOAD ADDRESS OF JOB CLASS MESSAGE
         BAL   R14,MSGRTN     GO WRITE MESSAGE TO JES MESSAGE DATA SET
         EJECT
CLEAR    DS    0H
         CLI   CLASSFLD,C'A'  TEST NEW CLASS
         BNL   CHGCLASS       NEW, GO RESET TO NEW CLASS
DEFAULT  MVI   CLASSFLD,C'A'  SET NEW CLASS TO 'A'
         EJECT
***********************************************************************
*                                                                     *
*              S E T     T H E    N E W    C L A S S                  *
*                                                                     *
***********************************************************************
CHGCLASS DS    0H
         AIF   ('&MODIFY' NE 'YES').MODIFY1
         L     R14,PCEJQE     LOAD JQE ADDRESS
         USING JQEDSECT,R14   SET ADDRESSABILITY TO JQE
         MVC   JQEJCLAS,CLASSFLD CHANGE CLASS IN JQE
         DROP  R14            DROP ADDRESSABILITY TO JQE
         L     R14,JCTADDR    LOAD JCT ADDRESS
         USING JCTDSECT,R14   SET ADDRESSABILITY TO JCT
         MVC   JCTJCLAS,CLASSFLD CHANGE CLASS IN JCT
         MVC   JCTCLASS,CLASSFLD CHANGE CLASS IN JCT
         DROP  R14            DROP ADDRESSABILITY TO JCT
.MODIFY1 ANOP
         EJECT
NOCHANGE XC    RETCODE,RETCODE SET RETURN CODE TO ZERO
         TM    JOBIND,JOBFAIL WAS JOB FAILED BY EXIT?
         BO    JOBERROR       YES, BRANCH
         B     ENDOFIT        BRANCH
JOBERROR DS    0H
         AIF   ('&ERRMSG' EQ 'YES').ERRMSG1
         B     JOBERR1        BYPASS WTO FOR FAILURE
.ERRMSG1 ANOP
         MVC   WTOLIST(LWTO2),WTO2 SET WTO LIST FORM
         AIF   ('&TSO' NE 'YES').TSO1
         WTO   MF=(E,WTOLIST)
         AGO   .TSO2
.TSO1    ANOP
         $$WTO WTOLIST        WRITE ERROR MESSAGE
.TSO2    ANOP
         B     JOBERR1        BYPASS WTO LIST FORM
         $MID  902
WTO2     WTO   '&MID.JOB TERMINATED BY STANDARDS ENFORCEMENT EXIT',    X
               ROUTCDE=(2),DESC=(4),MF=L
LWTO2    EQU   *-WTO2
JOBERR1  DS    0H
         AIF   ('&FLUSH' EQ 'YES').FLUSH1
         B     ENDOFIT        BYPASS SETTING OF FAILURE RETURN CODE
.FLUSH1  ANOP
         LA    R15,8          SET JOB FAIL RETURN CODE
         ST    R15,RETCODE    AND SAVE IT
         EJECT
***********************************************************************
*                        C L E A N    U P                             *
***********************************************************************
ENDOFIT  DS    0H             END OF EXIT
         LA    R1,ESTAEL      LOAD ADDRESS OF ESTAE LIST FORM
         AIF   ('&TSO' EQ 'YES').TSO10
         AIF   ('&ESTAE' NE 'YES').TSO10
         ESTAE 0,MF=(E,(1))   CANCEL ESTAE ENVIRONMENT
.TSO10   ANOP
         L     R0,F#8192      LOAD FREEMAIN LENGTH
         L     R1,SUBTABLE    LOAD JCL SUB TABLE AREA ADDRESS
         FREEMAIN R,LV=(0),A=(1)
         L     R2,RETCODE     SAVE RETURN CODE
         LH    R0,GETLEN      LOAD FREEMAIN SIZE
         LR    R1,R13         SAVE WORKAREA ADDRESS
         L     R13,4(,R13)    RESTORE ORIG REG 13
         FREEMAIN R,LV=(0),A=(1)
         XC    PCEUSER0,PCEUSER0 CLEAR WORKAREA POINTER IN PCE
         LR    R15,R2         SET RETURN CODE
         RETURN (14,12),RC=(15) GO BACK TO JES2
         EJECT
***********************************************************************
*        RETURN TO JES REQUESTING THE NEXT INTERNAL TEXT STATEMENT    *
***********************************************************************
GETNEXT  L     R4,CARDNO      LOAD CARD NUMBER FIELD
         LA    R4,1(,R4)      ADD 1 TO CARD NUMBER
         ST    R4,CARDNO      STORE NEW CARD NUMBER
         XC    RETCODE,RETCODE SET RETURN CODE TO ZERO
         LA    R1,ESTAEL      LOAD ADDRESS OF ESTAE LIST FORM
         AIF   ('&TSO' EQ 'YES').TSO11
         AIF   ('&ESTAE' NE 'YES').TSO11
         ESTAE 0,MF=(E,(1))   CANCEL ESTAE ENVIRONMENT
.TSO11   ANOP
         L     R13,4(,R13)    RESTORE ORIG REG 13
         SLR   R15,R15        SET RETURN CODE TO ZERO
         RETURN (14,12),RC=(15) GO BACK TO JES2
         EJECT
***********************************************************************
*                                                                     *
*                        E R R O R T N                                *
*                                                                     *
*        THIS ROUTINE WILL WRITE A MESSGE TO THE JES MESSAGE DATA     *
*        SET USING THE INDEX INTO THE MESSAGE TABLE PASSED BY         *
*        REGISTER 15 TO THE ROUTINE AND USE THE CARDNO FOR THE        *
*        STATEMENT NUMBER IN THE MESSAGE PREFIX.                      *
*                                                                     *
***********************************************************************
         PUSH  USING
ERRORTN  STM   R14,R12,SAVEREGS SAVE REGISTERS
         L     R6,OUTRPL      GET BASE FOR RPL
         USING IFGRPL,R6      SET ADDRESSABILITY
         LR    R2,R15         SAVE ERROR NUMBER
         BCTR  R2,0           MAKE ERROR NUMBER REL TO ZERO
         MH    R2,H#90        MULTIPLY BY 90 FOR OFFSET
         L     R3,CARDNO      LOAD CARD NUMBER
         CVD   R3,DOUBLE      CONVERT CARD NUMBER TO PACKED
         L     R4,MSGCOUNT    LOAD MESSAGE COUNTER
         LTR   R4,R4          SEE IF FIRST MESSAGE
         BNZ   MSGOUT         NO, DO NOT PUT HEADERS
         MVC   BUFFER,HEADER1 MOVE HEADER LINE1 TO JES2 BUFFER
         BAL   R5,PUTMSG      GO WRITE TO MSG DATA SET
         MVC   BUFFER,HEADER2 MOVE HEADER LINE2 TO JES2 BUFFER
         BAL   R5,PUTMSG      GO WRITE TO MSG DATA SET
MSGOUT   LA    R4,1(,R4)      ADD 1 TO MESSAGE COUNT
         ST    R4,MSGCOUNT    SAVE MESSAGE COUNTER
         MVC   MSGPREF,PREFIX MOVE MSG PREFIX TO JES2 BUFFER
         ED    MSGPREF(6),DOUBLE+5 EDIT CARD NUMBER TO PREFIX
         LA    R3,MESSAGES    LOAD ADDR OF MESSAGE TABLE
         AR    R3,R2          ADD OFFSET OF MSG TO TBL ADDR
         MVC   MSGTEXT,0(R3)  MOVE PROPER MSG TO JES2 BUFFER
         BAL   R5,PUTMSG      GO WRITE TO MSG DATA SET
         OI    JOBIND,JOBFAIL TURN ON JOB FAILED IND
MSGOUT1  LM    R14,R12,SAVEREGS RESTORE REGISTERS
         BR    R14            RETURN TO CALLER
         EJECT
***********************************************************************
*                                                                     *
*                          M S G R T N                                *
*                                                                     *
*        THIS ROUTINE WILL WRITE THE MESSAGE WHICH IS POINTED TO      *
*        BY REGISTER 15 TO THE JES MESSAGE DATA SET.                  *
*                                                                     *
***********************************************************************
         PUSH  USING
MSGRTN   STM   R14,R12,SAVEREGS SAVE REGISTERS
         LR    R2,R15         SAVE BUFFER ADDRESS
         L     R6,OUTRPL      GET BASE FOR RPL
         USING IFGRPL,R6      SET ADDRESSABILITY
         L     R3,CARDNO      LOAD CARD NUMBER
         CVD   R3,DOUBLE      CONVERT CARD NUMBER TO PACKED
         L     R4,MSGCOUNT    LOAD MESSAGE COUNTER
         LTR   R4,R4          SEE IF FIRST MESSAGE
         BNZ   MSGRTN1        NO, DO NOT PUT HEADERS
         MVC   BUFFER,HEADER1 MOVE HEADER LINE1 TO JES2 BUFFER
         BAL   R5,PUTMSG      GO WRITE TO MSG DATA SET
         MVC   BUFFER,HEADER2 MOVE HEADER LINE2 TO JES2 BUFFER
         BAL   R5,PUTMSG      GO WRITE TO MSG DATA SET
MSGRTN1  LA    R4,1(,R4)      ADD 1 TO MESSAGE COUNT
         ST    R4,MSGCOUNT    SAVE MESSAGE COUNTER
         MVC   BUFFER,0(R2)   MOVE MESSAGE FROM BUFFER
         BAL   R5,PUTMSG      GO WRITE TO MSG DATA SET
         LM    R14,R12,SAVEREGS RESTORE REGISTERS
         BR    R14            RETURN TO CALLER
         EJECT
***********************************************************************
*                                                                     *
*                          P U T M S G                                *
*                                                                     *
*        WRITE MESSAGE TO JES MESSAGE DATA SET                        *
*                                                                     *
***********************************************************************
PUTMSG   DS    0H
         MVI   RPLREQ,RPLPUT  OPERATION TO BE A PUT
         L     R0,OUTACB      LOAD OUTPUT ACB ADDRESS
         ST    R0,RPLDACB     SET IN ACB POINTER IN RPL
         LA    R0,BUFFER      LOAD ADDR OF BUFFER
         ST    R0,RPLAREA     POINT TO BUFFER
         XC    RPLARG(4),RPLARG ZERO FIELD
         MVI   RPLOPT1,RPLSEQ OPERATION TO BE SEQUENTIAL
         MVI   RPLOPT2,X'00'  ZERO FIELD
         LA    R0,100         LOAD MESSAGE LENGTH
         ST    R0,RPLRLEN     STORE MESSAGE LENGTH
         XC    RPLBUFL(4),RPLBUFL ZERO FIELD
         XC    RPLDDDD(4),RPLDDDD ZERO FIELD
         ST    R13,PUTSAVE+72 SAVE SAVE AREA POINTER
         LA    R13,PUTSAVE    SAVE AREA FOR ACCESS METHOD
         LA    R1,IFGRPL      LOAD ADDR OF RPL
         PUT   RPL=(1)        WRITE TO MESSAGE DATA SET
         L     R13,72(R13)    RESTORE SAVE AREA POINTER
         LTR   R15,R15        TEST RETURN CODE
         BNZ   MSGERROR       BAD, GO BAG JOB
         BR    R5             RETURN TO CALLER
         EJECT
MSGERROR MVC   WTOLIST(LWTO1),WTO1 SET WTO LIST FORM
         AIF   ('&TSO' NE 'YES').TSO3
         WTO   MF=(E,WTOLIST)
         AGO   .TSO4
.TSO3    ANOP
         $$WTO WTOLIST        WRITE ERROR MESSAGE
.TSO4    ANOP
         B     JOBERROR       GET OUT
         $MID  901
WTO1     WTO   '&MID.PUT TO JOB MESSAGE DATA SET FAILED',              X
               ROUTCDE=(2),DESC=(4),MF=L
LWTO1    EQU   *-WTO1
         DROP  R6
         POP   USING
         EJECT
***********************************************************************
*                                                                     *
*                          R E F B A C K                              *
*                                                                     *
*        THIS ROUTINE HANDLES DSN AND VOLSER REFERBACKS.  THE SAVE    *
*        TABLE WILL BE SEARCHED FROM THE BEGINNING FOR JOBSTEP AND/OR *
*        PROCSTEP ENTRY AND THEN WITHIN THE DD ENTRIES FOR THAT STEP. *
*        IF THE ENTRY IS FOUND, THE UNIT AND DSNAME INFORMATION WILL  *
*        BE SAVED, IF NOT, A RETURN IS MADE TO THE CALLING RTN.       *
*                                                                     *
***********************************************************************
*
REFBACK  SLR   R3,R3          CLEAR WORK REGISTER
         SLR   R4,R4          CLEAR WORK REGISTER
         SLR   R5,R5          CLEAR WORK REGISTER
         IC    R5,2(R2)       LOAD NUMBER OF DSN SUBPARAMETERS
         N     R5,F#127       'AND' OUT THE HIGH ORDER BIT
         LA    R2,3(,R2)      LOAD START OF REFBK ENTRIES
         CLI   0(R2),X'01'    SEE IF LEN OF 1ST POS = 1
         BNE   DDLOOP         NO, DSN(MEMBER) PDS DISK ONLY, IGNORE
         CLI   1(R2),C'*'     SEE IF REFERBACK
         BNE   DDLOOP         NO, DSN(MEMBER) PDS DISK ONLY, IGNORE
         CH    R5,H#4         SEE IF NUMBER PARAMS > 4
         BNH   *+16           NO, CONTINUE
         LA    R15,32         SET ERROR NUMBER
         BAL   R14,ERRORTN    GO ISSUE ERROR MSG
         B     DDLOOP         GET OUT
         MVI   REFERBCK,C' '  BLANK START OF REFBACK WORK AREA
         MVC   REFERBCK+1(23),REFERBCK BLANK ENTIRE WORK AREA
         XC    REFUNIT,REFUNIT ZERO REFERBACK UNIT FEEDBACK
         XC    REFVOL,REFVOL  ZERO REFERBACK VOLSER FIELD
         MVI   REFDSN,C' '    BLANK ENTIRE
         MVC   REFDSN+1(43),REFDSN  REFERBACK DSNAME FIELD
REFLOOP1 LA    R4,1(,R4)      ADD 1 TO COUNT
         CR    R4,R5          SEE IF COUNT EXCEEDED
         BH    REFSEAR        YES, GO SEARCH BACK
         ICM   R3,1,0(R2)     LOAD LENGTH OF ENTRY
         BNZ   *+16           NOT ZERO, OK
         LA    R15,32         SET ERROR NUMBER
         BAL   R14,ERRORTN    GO ISSUE ERROR MSG
         B     DDLOOP         GET OUT
         CH    R3,H#8         SEE IF LENGTH > 8
         BNH   *+16           NO, CONTINUE
         LA    R15,32         SET ERROR NUMBER
         BAL   R14,ERRORTN    GO ISSUE ERROR MSG
         B     DDLOOP         GET OUT
         BCTR  R3,0           MAKE MACHINE LENGTH
         CH    R4,H#1         SEE IF 1ST ENTRY
         BE    REFLOOP2       YES, IGNORE
         CH    R4,H#2         SEE IF 2ND ENTRY
         BE    REF#2          YES, GO PROCESS IT
         CH    R4,H#3         SEE IF 3RD ENTRY
         BE    REF#3          YES, GO PROCESS IT
*        THIS MUST BE THE 4TH ENTRY
REF#4    EX    R3,MOVE10      MOVE DDN TO SEARCH FIELD
         B     REFLOOP2       BRANCH
REF#3    CH    R5,H#3         SEE IF ONLY 3 ENTRIES
         BE    REF#3B         YES, MUST BE DDNAME
*        IF NOT DDNAME, MUST BE PROCSTEP NAME
REF#3A   EX    R3,MOVE11      MOVE ENTRY TO PSTEP ENTRY
         B     REFLOOP2       BRANCH
REF#3B   EX    R3,MOVE10      MOVE ENTRY TO DDNAME
         B     REFLOOP2       BRANCH
REF#2    CH    R5,H#2         SEE IF ONLY 2 ENTRIES
         BE    REF#2B         ONLY 2, MUST BE DDNAME
*        IF 3 OR 4 ENTRIES, THIS ENTRY MUST BE FOR JOBSTEP
REF#2A   EX    R3,MOVE12      MOVE ENTRY TO JSTEP
         B     REFLOOP2       BRANCH
REF#2B   EX    R3,MOVE10      MOVE ENTRY TO DDNAME
REFLOOP2 LA    R2,2(R3,R2)    INCREMENT TO NEXT ENTRY
         B     REFLOOP1       LOOP
REFSEAR  L    R7,LASTEXEC     LOAD ADDR OF LAST EXEC CARD
*        IF REFERBACK WITHIN CURRENT STEP, THIS ADDR WILL BE
*        USED FOR START OF SEARCH
         CLI   REFJSTEP,C' '  SEE IF JSTEP PART OF SEARCH
         BE    REFSEAR5       NO, SAME STEP WE ARE IN
         CLI   REFPSTEP,C' '  SEE IF PROCSTEP PART OF SEARCH
         BE    REFSEAR1       BLANK, NO PROCSTEP
         LA    R3,15          SET COMPARE LENGTH FOR JS & PS
         B     REFSEAR2       BRANCH
REFSEAR1 LA    R3,7           SET COMPARE LENGTH FOR JS ONLY
REFSEAR2 L    R7,FIRSTENT     LOAD START OF TABLE
REFSEAR3 LA   R7,ENTLEN(,R7) INCREMENT PAST JOB ENTRY
         CLI   ENTRYTYP,TYPEXEC SEE IF EXEC ENTRY
         BE    REFSEAR4       YES, GO COMPARE
         CLI   ENTRYTYP,TYPEND  SEE IF END OF TABLE
         BE    REFNO          NOT FOUND, PROBABLE JCL ERROR, EXIT
         B     REFSEAR3       LOOP
REFSEAR4 EX    R3,COMPARE1    SEE IF RIGHT STEP
         BE    REFSEAR5       YES, GO SEARCH FOR DDNAME
         B     REFSEAR3       LOOP FOR NEXT ENTRY
REFSEAR5 LA   R7,ENTLEN(,R7) INCREMENT TO NEXT DD ENTRY
         TM    ENTRYTYP,TYPEDD SEE IF DD ENTRY
         BNO   REFNO          DDNAME NOT FOUND, EXIT
REFSEAR6 CLC   REFDDN,DDDN    MATCH DDNAME????
         BNE   REFSEAR5       NO, LOOP FOR NEXT DD
REFOUND  MVC   REFDSN(L'DDSN),DDSN SAVE DSNAME
         MVC   REFUNIT,DTYPE  SAVE UNIT INFO
         MVC   REFVOL,DVOLSER SAVE VOLSER INFO
REFNO    BR    R14            RETURN
         EJECT
***********************************************************************
*                                                                     *
*                          T B L F U L L                              *
*                                                                     *
*        THE INTERNAL DD TABLE IS FULL.  ISSUE THE APPROPRIATE        *
*        MESSAGE AND EXIT WITH A JCL ERROR.                           *
*                                                                     *
***********************************************************************
TBLFULL  MVC   WTOLIST(LWTO3),WTO3 SET WTO LIST FORM
         AIF   ('&TSO' NE 'YES').TSO5
         WTO   MF=(E,WTOLIST)
         AGO   .TSO6
.TSO5    ANOP
         $$WTO WTOLIST        WRITE ERROR MESSAGE
.TSO6    ANOP
         B     JOBERROR       EXIT WITH A SEVERE ERROR
         $MID  903
WTO3     WTO   '&MID.MAXIMUM ENTRIES IN INTERNAL TABLE EXCEEDED'       X
               ROUTCDE=(2),DESC=(4),MF=L
LWTO3    EQU   *-WTO3
         EJECT
***********************************************************************
*                                                                     *
*                          S T A E X I T                              *
*                                                                     *
*        THIS ROUTINE GETS CONTROL FOR EVERY ABEND OCCURRING IN       *
*        THE EXIT.  THIS ROUTINE WILL ISSUE AN APPROPRIATE MESSAGE    *
*        TO THE OPERATOR AND TAKE A CONSOLE DUMP FOR PROBLEM          *
*        RESOLUTION.  RETRY WILL BE ATTEMPTED FOR ALL ABENDS          *
*        WHICH WILL JUST SET THE JOB CLASS TO "A" AND TERMINATE.      *
*        NOTE THAT THERE IS A RECURSION CHECK TO PROTECT FROM         *
*        ABEND LOOPS.                                                 *
*                                                                     *
***********************************************************************
         PUSH  USING
STAEXIT  LR    R8,R15         SET NEW BASE ADDR
         USING STAEXIT,R8     SET ADDRESSABILITY
         CH    R0,H#12        SEE IF CORE AVAILABLE
         BE    STAENO         NO, BRANCH
         SAVE  (14,12)        SAVE REGISTERS
         SPACE 1
         L     R2,0(R1)       LOAD PARAMETER ADDRESS
         L     R11,STAEREGS+64-WORKAREA(R2) RESTORE HCT ADDRESS
         LA    R3,STAESAVE-WORKAREA(R2) LOAD ADDRESS OF NEW SAVE
         ST    R3,8(,R13)     SAVE NEW SAVE ADDRESS IN OLD
         ST    R13,4(,R3)     SAVE OLD SAVE ADDRESS IN NEW
         LR    R13,R3         SET NEW SAVE ADDRESS
         LR    R3,R1          SAVE SDWA ADDRESS
         LA    R0,L'WTO4      LOAD LENGTH OF MESSAGE
         LA    R1,WTOLIST-WORKAREA(R2) LOAD ADDRESS OF WTO LIST FORM
         MVC   0(LWTO4,R1),WTO4 SET WTO LIST FORM
         AIF   ('&TSO' NE 'YES').TSO7
         WTO   MF=(E,(R1))
         AGO   .TSO8
.TSO7    ANOP
         $$WTO (R1)           WRITE ERROR MESSAGE
.TSO8    ANOP
         CLI   RECURS-WORKAREA(R2),X'FF'   SEE IF RECURSIVE ABEND
         BE    STAENO         YES, TELL ABEND NOT TO RETRY
         AIF   ('&SDUMP' EQ 'YES').SDUMP1
         B     STAE1          BYPASS SDUMP SWITCH
.SDUMP1  ANOP
         LA    R1,SDUMPL-WORKAREA(R2) LOAD ADDRESS OF SDUMP LIST FORM
         MVC   0(LSDUMPL,R1),SDUMP INITIALIZE SDUMP LIST FORM
         SDUMP MF=(E,(1))     TAKE SYSTEM DUMP
STAE1    DS    0H
         L     R13,4(,R13)    RESTORE ORIGINAL REG 13
         LR    R1,R3          RESTORE SDWA ADDRESS
         SETRP REGS=(14,12),DUMP=IGNORE,RC=4,FRESDWA=YES,              X
               RETADDR=STAERTRY
STAENO   LA    R0,STAERTRY    LOAD RETRY ADDRESS
         LA    R15,4          SET RETURN CODE TO RETRY
         BR    R14            GO RETRY
         SPACE 2
         $MID  904
WTO4     WTO   '&MID.JES EXIT6 ABEND',                                 X
               ROUTCDE=(2),DESC=(4),MF=L
LWTO4    EQU   *-WTO4
         SPACE 1
         DROP  R8             DROP LOCAL ADDRESSABILITY
         SPACE 2
         POP   USING
***********************************************************************
*                                                                     *
*                          S T A E R T R Y                            *
*                                                                     *
*        RESTORE ORIGINAL REGISTERS AND GET OUT                       *
*                                                                     *
***********************************************************************
STAERTRY LR    R13,R1         RESTORE GETMAINED AREA ADDRESS
         LM    R14,R12,STAEREGS+12 RESTORE REGISTERS
         CLI   RECURS,X'FF'   SEE IF RECURSIVE ABEND
         BE    NOCHANGE       YES, GET OUT AS QUICKLY AS POSSIBLE
         MVI   RECURS,X'FF'   SET RECURSIVE ABEND INDICATOR
         B     CLEAR          GET OUT
         EJECT
         LTORG
         EJECT
***********************************************************************
*        TABLES USED BY EXIT                                          *
***********************************************************************
*
***********************************************************************
*        FORMAT OF TABLE IS AS FOLLOWS                                *
*        1)  A 1 BYTE PRODUCTION SYSOUT CLASS                         *
***********************************************************************
PSYSOUT  EQU   *              PRODUCTION-ONLY SYSOUT CLASSES
         DC    C'S'           PRODUCTION 3800 SHORT STOCK
         DC    C'J'           PRODUCTION JOBLOG SYSOUT CLASS
         DC    C'C'           PRODUCTION MICROFICHE HOT
         DC    C'D'           PRODUCTION MICROFICHE MEDIUM
         DC    C'E'           PRODUCTION MICROFICHE REGULAR
         DC    C'F'           PRODUCTION SPECIAL FORMS
         DC    C'H'           PRODUCTION HELD OUTPUT
         DC    C'1'           SYSLOG SYSLOG CLASSES
         DC    C'2'           SYSLOG SYSLOG CLASSES
         DC    C'3'           SYSLOG SYSLOG CLASSES
         DC    C'4'           SYSLOG SYSLOG CLASSES
         DC    X'FF'          END OF TABLE
*
***********************************************************************
*        FORMAT OF TABLE IS AS FOLLOWS                                *
*        1)  A 1 BYTE UNIT ATTRIBUTE TYPE                             *
*            X'00'  UNIMPORTANT DEVICE TYPE                           *
*            X'02'  TAPE DEVICE                                       *
*            X'04'  PRIVATE MOUNT DISK DEVICE                         *
*            X'08'  VIO                                               *
*        2)  A 1 BYTE MACHINE LENGTH OF ENTRY                         *
*        3)  AN 8 BYTE FIELD CONTAINING THE DEVICE NAME LEFT JUSTIFIED*
***********************************************************************
DEVTABLE EQU   *              DEVICE NAME TABLE
         DC    X'00',X'04',CL8'SYSDA'    SYSDA
         DC    X'00',X'04',CL8'SYSSQ'    SYSDA
         DC    X'00',X'03',CL8'DISK'     SYSDA
         DC    X'00',X'07',CL8'SYSALLDA' SYSDA
         DC    X'00',X'03',CL8'3330'     SYSDA
         DC    X'00',X'03',CL8'3350'     SYSDA
         DC    X'00',X'03',CL8'3380'     SYSDA
         DC    X'02',X'03',CL8'TAPE'     TAPE
         DC    X'02',X'04',CL8'T6250'    TAPE
         DC    X'02',X'04',CL8'T1600'    TAPE
         DC    X'02',X'04',CL8'T0800'    TAPE
         DC    X'02',X'03',CL8'T800'     TAPE
         DC    X'02',X'03',CL8'3400'     TAPE
         DC    X'02',X'03',CL8'2400'     TAPE
         DC    X'04',X'03',CL8'PRIV'     PRIV
         DC    X'08',X'02',CL8'VIO'      VIO
         DC    X'02',X'02',CL8'480'      TAPE
         DC    X'02',X'02',CL8'481'      TAPE
         DC    X'02',X'02',CL8'482'      TAPE
         DC    X'02',X'02',CL8'483'      TAPE
         DC    X'02',X'02',CL8'484'      TAPE
         DC    X'02',X'02',CL8'485'      TAPE
         DC    X'02',X'02',CL8'486'      TAPE
         DC    X'02',X'02',CL8'487'      TAPE
         DC    X'02',X'02',CL8'488'      TAPE
         DC    X'02',X'02',CL8'489'      TAPE
         DC    X'02',X'02',CL8'48A'      TAPE
         DC    X'02',X'02',CL8'48B'      TAPE
         DC    X'02',X'02',CL8'48C'      TAPE
         DC    X'02',X'02',CL8'48D'      TAPE
         DC    X'02',X'02',CL8'48E'      TAPE
         DC    X'02',X'02',CL8'48F'      TAPE
         DC    X'02',X'02',CL8'490'      TAPE
         DC    X'02',X'02',CL8'491'      TAPE
         DC    X'02',X'02',CL8'492'      TAPE
         DC    X'02',X'02',CL8'493'      TAPE
         DC    X'02',X'02',CL8'494'      TAPE
         DC    X'02',X'02',CL8'495'      TAPE
         DC    X'02',X'02',CL8'496'      TAPE
         DC    X'02',X'02',CL8'497'      TAPE
         DC    X'02',X'02',CL8'498'      TAPE
         DC    X'02',X'02',CL8'499'      TAPE
         DC    X'02',X'02',CL8'49A'      TAPE
         DC    X'02',X'02',CL8'49B'      TAPE
         DC    X'02',X'02',CL8'49C'      TAPE
         DC    X'02',X'02',CL8'49D'      TAPE
         DC    X'02',X'02',CL8'49E'      TAPE
         DC    X'02',X'02',CL8'49F'      TAPE
         DC    10X'00'         END OF TABLE
         EJECT
***********************************************************************
*        FORMAT OF TABLES IS AS FOLLOWS                               *
*            1)  1 BYTE CLASS CODE APPLYING TO ENTRY                  *
*            2)  3 BYTE FILLER                                        *
*            3)  HALFWORD MAXIMUM TAPES PER STEP                      *
*            4)  HALFWORD MAXIMUM PRIV UNITS PER STEP                 *
*            5)  HALFWORD MAXIMUM TOTAL DEVICES PER STEP              *
*            6)  HALFWORD MAXIMUM REGION PER STEP                     *
*            7)  FULLWORD MAXIMUM CPU TIME FOR JOB                    *
***********************************************************************
JCLASS1  DS    0F             NORMAL TEST CLASS TABLE
         DC    C'1',C'   ',H'0',H'0',H'0',H'2048',F'1'
         DC    C'2',C'   ',H'0',H'0',H'0',H'4096',F'5'
         DC    C'3',C'   ',H'1',H'0',H'1',H'2048',F'1'
         DC    C'4',C'   ',H'1',H'0',H'1',H'2048',F'5'
         DC    C'5',C'   ',H'2',H'0',H'2',H'4096',F'5'
         DC    C'6',C'   ',H'0',H'0',H'0',H'2048',F'15'
         DC    C'0',C'   ',X'FFFF',X'FFFF',X'FFFF',X'FFFF',X'FFFFFFFF'
         DC    4F'0'          END OF TABLE
         SPACE 3
JCLASS2  DS    0F             SPECIAL TEST CLASS TABLE
         DC    C'7',C'   ',H'0',H'0',H'0',H'2048',F'15'
         DC    C'8',C'   ',H'1',H'0',H'1',H'2048',F'15'
         DC    C'9',C'   ',H'2',H'0',H'2',H'2048',F'15'
         DC    4F'0'          END OF TABLE
         SPACE 3
JCLASS3  DS    0F             PRODUCTION CLASS TABLE
         DC    C'A',C'   ',H'0',H'0',H'0',H'2048',F'5'
         DC    C'B',C'   ',H'0',H'0',H'0',H'2048',F'30'
         DC    C'C',C'   ',H'5',H'0',H'5',H'2048',F'60'
         DC    C'D',C'   ',H'5',H'0',H'5',H'2048',X'FFFFFFFF'
         DC    C'E',C'   ',X'FFFF',X'FFFF',X'FFFF',X'FFFF',X'FFFFFFFF'
         DC    4F'0'          END OF TABLE
         EJECT
***********************************************************************
*        CONSTANTS USED BY EXIT                                       *
***********************************************************************
*
BINZEROS DC    2F'0'          FULLWORD BINARY ZEROS
BLANKS   DC    44C' '         CONSTANT STRING OF BLANKS
MOVE1    MVC   JNAME(0),1(R2) MOVE JOBNAME TO SAVE TABLE
MOVE2    MVC   JACCTNO(0),1(R2) MOVE ACCOUNT NO TO SAVE TABLE
MOVE3    MVC   JPGMRNM(0),1(R2) MOVE PROGRAMMER NAME TO SAVE TABLE
MOVE4    MVC   SAVEPROC(0),1(R2) MOVE JOB STEP NAME TO SAVE AREA
MOVE5    MVC   EJSTEP(0),3(R2) MOVE JOB STEP NAME TO TABLE
MOVE6    MVC   EPSTEP(0),3(R2) MOVE PROC STEP NAME TO TABLE
MOVE7    MVC   EPGMNM(0),3(R2) MOVE STEP PGM NAME TO TABLE
MOVE8    MVC   TDDN(0),3(R2)   MOVE DDNAME TO TEMP DD ENTRY
MOVE9    MVC   TDSN(0),3(R2)   MOVE DSN TO TEMP DD ENTRY
MOVE10   MVC   REFDDN(0),1(R2) MOVE DDNAME TO REFERBACK
MOVE11   MVC   REFPSTEP(0),1(R2) MOVE PROCSTEP NAME TO REFERBACK
MOVE12   MVC   REFJSTEP(0),1(R2) MOVE JOBSTEP NAME TO REFERBACK
MOVE13   MVC   TVOLSER(0),3(R2) SAVE 1ST VOLSER FROM DD
MOVE14   MVC   TDSN(0),1(R4)  MOVE 1ST PART GDG DSN TO TEMP
MOVE15   MVC   0(0,R5),1(R4)  MOVE 2ND PART GDG DSN TO TEMP
MOVE16   MVC   JACCT(0),1(R2) MOVE ACCOUNT NO TO WORK AREA
MOVE17   MVC   LDSN(0),3(R2)  MOVE VOL=SER DSNAME TO SAVE
PACK1    PACK  DOUBLE,1(0,R2) PACK STEP REGION SIZE
PACK2    PACK  DOUBLE,1(0,R2) PACK UNIT COUNT
PACK3    PACK  DOUBLE,1(0,R2) PACK VOLUME COUNT
PACK4    PACK  DOUBLE,1(0,R2) PACK PROC STEP REGION OVERRIDE
PACK5    PACK  DOUBLE,1(0,R2) PACK JOB CPU TIME
PACK6    PACK  DOUBLE,1(0,R2) PACK JOB PRTY VALUE
COMPARE1 CLC   REFERBCK(0),EENTRY SEE IF REFERBACK STEPS MATCH
COMPARE2 CLC   1(0,R2),2(R1)  SEE IF UNIT NAME IN TABLE
COMPARE3 CLC   1(0,R2),EPSTEP SEE IF PROC OVERRIDE STEPNAME MATCH
DEFTIME  DC    X'A9',X'01',X'04',CL4'0001',X'FE' DFLT CPU TIME INTEXT
ZEROES   DC    8C'0'          CHARACTER CONSTANT 8 ZEROES
EDMASK   DC    X'402020202120' EDIT MASK FOR MESSAGES
GDGMASK  DC    C'G0000V00'    GDG SUFFIX MASK
X#FFFF   DC    F'65535'       FULLWORD CONSTANT X'0000FFFF'
MAXENTS  DC    Y(8192/ENTLEN) MAX ENTRIES IN 8K TABLE
GETLEN   DC    AL2(GETSIZE)   SIZE OF GETMAIN AREA
F#1      DC    F'1'           FULLWORD CONSTANT '1'
F#15     DC    F'15'          FULLWORD CONSTANT '15'
F#45     DC    F'45'          FULLWORD CONSTANT '45'
F#127    DC    F'127'         FULLWORD CONSTANT '127'
F#8192   DC    F'8192'        CONSTANT FULLWORD 8192
H#0      DC    H'0'           HALFWORD CONSTANT '0'
H#1      DC    H'1'           HALFWORD CONSTANT '1'
H#2      DC    H'2'           HALFWORD CONSTANT '2'
H#3      DC    H'3'           HALFWORD CONSTANT '3'
H#4      DC    H'4'           HALFWORD CONSTANT '4'
H#5      DC    H'5'           HALFWORD CONSTANT '5'
H#6      DC    H'6'           HALFWORD CONSTANT '6'
H#7      DC    H'7'           HALFWORD CONSTANT '7'
H#8      DC    H'8'           HALFWORD CONSTANT '8'
H#10     DC    H'10'          HALFWORD CONSTANT '10'
H#12     DC    H'12'          HALFWORD CONSTANT '12'
H#13     DC    H'13'          HALFWORD CONSTANT '13'
H#20     DC    H'20'          HALFWORD CONSTANT '20'
H#32     DC    H'32'          HALFWORD CONSTANT '32'
H#35     DC    H'35'          HALFWORD CONSTANT '35'
H#42     DC    H'42'          HALFWORD CONSTANT '42'
H#44     DC    H'44'          HALFWORD CONSTANT '44'
H#90     DC    H'90'          HALFWORD CONSTANT '90'
H#512    DC    H'512'         HALFWORD CONSTANT '512'
H#1440   DC    H'1440'        HALFWORD CONSTANT '1440'
H#5000   DC    H'5000'        HALFWORD CONSTANT '5000'
P#0      DC    P'0'           PACKED CONSTANT '0'
C#1440   DC    C'1440'        CHARACTER CONSTANT '1440'
C#SYS1   DC    C'SYS1.'       SYS1. PREFIX CONSTANT
C#SYSP   DC    C'SYSP.'       SYSP. PREFIX CONSTANT
C#PRD1   DC    C'PRD1.'       PRD1. PREFIX CONSTANT
C#TST1   DC    C'TST1.'       TST1. PREFIX CONSTANT
C#JOBLIB DC    CL8'JOBLIB'    CHARACTER CONSTANT 'JOBLIB'
C#STEPLI DC    CL8'STEPLIB'   CHARACTER CONSTANT 'STEPLIB'
C#JOBCAT DC    CL8'JOBCAT'    CHARACTER CONSTANT 'JOBCAT'
C#STEPCA DC    CL8'STEPCAT'   CHARACTER CONSTANT 'STEPCAT'
C#MOUNT  DC    CL8'MOUNT'     CHARACTER CONSTANT 'MOUNT'
C#OLD    DC    CL3'OLD'       CHARACTER CONSTANT 'OLD'
C#SHR    DC    CL3'SHR'       CHARACTER CONSTANT 'SHR'
C#NEW    DC    CL3'NEW'       CHARACTER CONSTANT 'NEW'
C#MOD    DC    CL3'MOD'       CHARACTER CONSTANT 'MOD'
C#KEEP   DC    CL4'KEEP'      CHARACTER CONSTANT 'KEEP'
C#PASS   DC    CL4'PASS'      CHARACTER CONSTANT 'PASS'
C#CATLG  DC    CL5'CATLG'     CHARACTER CONSTANT 'CATLG'
C#DELETE DC    CL6'DELETE'    CHARACTER CONSTANT 'DELETE'
C#UNCAT  DC    CL7'UNCATLG'   CHARACTER CONSTANT 'UNCATLG'
C#98000  DC    CL5'98000'     CHARACTER CONSTANT '98000'
C#INTRDR DC    CL6'INTRDR'    CHARACTER CONSTANT 'INTRDR'
C#BLP    DC    CL3'BLP'       CHARACTER CONSTANT 'BLP'
C#HOLD   DC    CL4'HOLD'      CHARACTER CONSTANT 'HOLD'
NULLFILE DC    CL8'NULLFILE'  CHARACTER CONSTANT NULLFILE
         SPACE
*              PGM NAME THAT ADD JES2 RESOURCES
PGMCICS  DC    C'DFHSIP'      CICS PGMNAME
PGM7074  DC    C'IIOEM74'     7074 PGMNAME
PGM1401  DC    C'IIQE14'      1401 PGMNAME
PGMXMIT  DC    C'BSCXMIT1'    XMISSION PGMNAME
         SPACE
DUMPMSG1 DC    CL40'MAX ENTRIES IN CONVERTER TABLE EXCEEDED '
HEADER1  DC    CL100' STMT NO. MESSAGE'
HEADER2  DC    CL100'-                '
PREFIX   DS    0CL11          NORMAL MESSAGE PREFIX
         DC    X'402020202120',CL5' '
ESTAE    ESTAE STAEXIT,CT,XCTL=NO,PURGE=NONE,ASYNCH=NO,RECORD=YES,     X
               TERM=NO,MF=L
SDUMP    SDUMP HDR='JES2 EXIT6 CONVERTER TIME ESTAE',MF=L
         EJECT
WORKAREA DSECT
SAVEAREA DS    18F            NEW SAVE AREA
SAVEREGS DS    18F            ROUTINE REGISTER SAVE AREA
STAEREGS DS    18F            REGISTERS FOR ESTAE RECOVERY
STAESAVE DS    18F            SAVE AREA FOR ESTAE ROUTINE
PUTSAVE  DS    19F            PUT SAVE AREA
JCTADDR  DS    F              ADDRESS OF JCT
TEXTSTAR DS    F              START ADDRESS OF INTERNAL TEXT
SAVER13  DS    F              SAVE AREA FOR REG 13 ON PUT RPL
SUBWORK  DS    F              ADDR OF TEXT PROCESSER WORK AREA
SUBTABLE DS    F              ADDRESS OF AREA FOR JCL STMT TABLE
EOFIND   DS    C              END OF FILE INDICATORS
ENDSTEP  EQU   1              LAST STATEMENT OF STEP IND
LASTBLK  EQU   2              BLOCK WITH LAST EXEC STMT PROCESSED
WTOSAVE  DS    4F             SAVE AREA FOR REG 14 - 1 BEFORE WTO'S
DOUBLE   DS    D              DOUBLE WORD FOR PACK & CVB
FIRSTENT DS    F              SAVE AREA FOR FIRST SAVE TABLE ENTRY
LASTENT  DS    F              SAVE AREA FOR LAST SAVE TABLE ENTRY
LASTEXEC DS    F              ADDR OF LAST EXEC TABLE ENTRY
TAPECNT  DS    H              COUNT OF TAPE UNITS USED IN STEP
PRIVCNT  DS    H              COUNT OF PRIV UNITS USED IN STEP
ENTCOUNT DS    H              NUMBER OF ACTIVE ENTRIES IN TABLE
UNITCOUN DS    XL1            COUNT OF UNITS FOR THIS DD
*        THIS MAY ALSO BE 'P' FOR PARALLEL MOUNTING
SAVEPROC DS    CL8            STEPNAME WHICH CALLS PROC
PROCTEXT DS    F              ADDR OF SAVED KEYWORD TEXT FROM PROC STMT
RETCODE  DS    F              SAVE AREA FOR RETURN CODE
PROCIND  DS    C              PROCESS PROCEDURE TEXT INDICATOR
*        X'01' INDICATES NEED TO PROCESS PROCEDURE OVERRIDE TEXT
JOBIND   DS    C              JOB RELATED INDICATORS
JOBLIB   EQU   1              JOB HAD A JOBLIB STMT
JOBFAIL  EQU   2              JOB FAILED EXIT TESTING
JOBSTC   EQU   4              JOB IS A STARTED TASK
JOBTSO   EQU   8              JOB IS A TSO LOGON
JOBTECH  EQU   16             JOB IS FOR TECH SUPPORT
JOBPROD  EQU   32             JOB IS A PRODUCTION JOB
JOBTEST  EQU   64             JOB IS A TEST JOB
JOBOPER  EQU   128            JOB IS A OPERATIONS JOB
JOBIND2  DS    C              JOB RELATED INDICATORS
HELD     EQU   1              JOB HAD TYPRUN=HOLD
MOUNT    EQU   2              JOB HAS DASD MOUNT AUTHORITY
DISPIND  DS    C              DD ENTRY DISPOSITION
NEW      EQU   1              DISP=NEW
OLD      EQU   2              DISP=OLD
SHR      EQU   4              DISP=SHR
MOD      EQU   8              DISP=MOD
CATLG    EQU   16             STEP COMPLETION DISP=CATLG
PASS     EQU   32             STEP COMPLETION DISP=PASS
KEEP     EQU   64             STEP COMPLETION DISP=KEEP
DELETE   EQU   128            STEP COMPLETION DISP=DELETE
DISPIND1 DS    C              DD ENTRY DISPOSITION
UNCATLG  EQU   1              STEP COMPLETION DISP=UNCATLG
UNITIND  DS    C              DD ENTRY UNIT TYPE
TAPE     EQU   2              UNIT USED WAS A TAPE
PRIV     EQU   4              UNIT USED WAS A PRIV DISK PACK
VIO      EQU   8              UNIT WAS VIO
AFF      EQU   16             UNIT WAS DETERMINED BY AFF
UNITGDG  EQU   32             UNIT TYPE(S) FROM GDG PROCESSING
UNITFND  EQU   128            UNIT TYPE HAS BEEN FOUND
JACCT    DS    CL14           ACCOUNT NUMBER (1ST ACCT INFO FIELD)
TENTRY   DS    0CL53          TEMPORARY DD TEXT TABLE ENTRY
TDDN     DS    CL8            TEMP DDNAME
TTYPE    DS    C              TEMP UNIT TYPE
TDSN     DS    CL44           TEMP DSN (FULL)
TVOLSER  DS    CL6            TEMP 1ST VOLSER OF DATA SET
LDSN     DS    CL44           DSNAME USED BY LOCATE
SVC26DSN DS    0CL44          DSNAME USED BY SVC26
SVC26DSL DS    CL1            LENGTH OF DSN
SVC26DS  DS    CL43           ACTUAL DSNAME INDEX
REFERBCK DS    0CL25          REFERBACK WORK AREA
REFJSTEP DS    CL8            REFERBACK JOBSTEP NAME
REFPSTEP DS    CL8            REFERBACK PROCSTEP NAME
REFDDN   DS    CL8            REFERBACK DDNAME
REFUNIT  DS    C              REFERBACK PREV UNIT TYPE
REFDSN   DS    CL44           REFERBACK DSN
REFVOL   DS    CL6            REFERBACK PREF DD 1ST VOLSER
VOLCNT   DS    XL1            VOLUME COUNT FROM UNIT=
SERCNT   DS    XL1            SERIAL COUNT FROM VOL=SER=
ADDCOUNT DS    XL1            WILL CONTAIN # OF UNITS FOR DD
RECURS   DS    CL1            RECURSIVE ABEND INDICATOR
CARDNO   DS    F              CARD NUMBER FOR MSG ROUTINE
MSGCOUNT DS    F              MESSAGE COUNT FOR MSG ROUTINE
OUTRPL   DS    F              ADDR OF OUTPUT RPL
OUTACB   DS    F              ADDR OF JOB MESSAGE DATASET ACB
PARMADDR DS    F              ADDR OF START OF CURRENT TEXT ENTRY
MAXTAPE  DS    H              MAX TAPES PER STEP USED
MAXPRIV  DS    H              MAX PRIVS PER STEP USED
MAXTOTAL DS    H              MAX TOTAL DEVICES PER STEP USED
MAXREGN  DS    H              MAX STEP REGION SIZE
MAXTIME  DS    F              MAXIMUM CPU TIME
         SPACE
RESOURCE DS    XL2            JES2 RESOURCES
*              RESOURCE BYTE ZERO
TESTING  EQU   128                     JES2 'TESTING' RESOURCE
PROD     EQU   64                      JES2 'PROD'  RESOURCE
TAPES    EQU   32                      JES2 'TAPES' RESOURCE
USERPACK EQU   8                       JES2 'USERPACK' RESOURCE
P1401    EQU   2                       JES2 '1401' RESOURCE
*              RESOURCE - BYTE ONE(1)
PCICS    EQU   128                     JES2 'CICS' RESOURCE
P7074    EQU   64                      JES2 '7074' RESOURCE
PXMIT    EQU   32                      JES2 'XMIT'/'COMTEN' RESOURCE
LONGJOB  EQU   8                       JES2 'LONGJOB' RESOURCE
DEDICATE EQU   4                       JES2 'DEDICATE' RESOURCE
*
CLASSFLD DS    C              CLASS AS DETERMINED FROM TABLE
         SPACE
INCLASS  DS    C              CLASS FROM JOB TEXT RECORD
AUTHJOB  DS    CL8            JOBNAME USED IN AUTHORIZATION CHECK
CAMLST   CAMLST NAME,TDSN,,LOCAREA LOCATE PARAM AREA
         DS    0D
LOCAREA  DS    0CL266         LOCATE CAMLST WORK AREA
CAMLCNT  DS    H              VOLUMES IN LIST
CAMLUNIT DS    0CL4           UNIT TYPE FOR 1ST VOLUME
UCBTYP1  DS    CL1            UCB TYPE BYTE 1
UCBTYP2  DS    CL1            UCB TYPE BYTE 2
UCBTYP3  DS    CL1            UCB TYPE BYTE 3
*        X'80' IN UCBTYP3 INDICATES TAPE DEVICE
UCBTYP4  DS    CL1            UCB TYPE BYTE 4
CAMVOL   DS    CL6            1ST VOLSER IN DATA SET
         DS    CL254          REST OF WORK AREA
LASTUCB  DS    F              SAVE AREA FOR LAST UCB ADDR PROCESSED
         DS    CL1            EDIT FILL CHAR FOR MSG PREFIX
STEPMSG  DS    0CL100         STEP RESOURCE MESSAGE
         DS    CL10           MESSAGE PREFIX
STEPM    DC    CL90'NWB000I XXXXXXXX XXXXXXXX TAPES= XXXXX PACKS= XXXXXX
                REGION= NNNNNK JTIME= XXXXX           '
         DS    CL1            EDIT FILL CHAR FOR MSG PREFIX
JOBMSG   DS    0CL100         JOB CLASS MESSAGE
         DS    CL10           MESSAGE PREFIX
JOBM     DC    CL90'NWB000I CLASS SET TO X                             X
                                                      '
ERRORMSG DS    0CL100         ERROR MESSAGE
         DS    CL10           MESSAGE PREFIX
ERRORM   DC    CL90' '
MSGPREF  DS    0CL11          ERROR MESSAGE PREFIX
         DS    C              EDIT FILL CHARACTER
BUFFER   DS    0CL100         JES2 MESSAGE AREA
         DS    CL10           REST OF MESSAGE PREFIX
MSGTEXT  DS    CL90           TEXT OF ERROR MESSAGE
MSGRPL   DS    19F            SKELETON RPL FOR OUTPUT MSG DATA SET
WTOLIST  DS    CL120          SET WTO LIST FORM
PROCTXT  DS    CL512          SAVE AREA FOR PROC CARD TEXT
CTGPL    DS    XL40           CATALOG MANAGEMENT PARAMETER LIST
ESTAEL   ESTAE STAEXIT,CT,XCTL=NO,PURGE=NONE,ASYNCH=NO,RECORD=YES,     X
               TERM=NO,MF=L
LESTAEL  EQU   *-ESTAEL
SDUMPL   SDUMP HDR='JES2 EXIT6 CONVERTER TIME ESTAE',MF=L
LSDUMPL  EQU   *-SDUMPL
SVC26WRK DS    CL5000         SVC26 WORK AREA
GETSIZE  EQU   *-WORKAREA     LENGTH OF WORK AREA
         EJECT
SAVTABLE DSECT
***********************************************************************
*        THIS TABLE HAS 3 ENTRY TYPES                                 *
*            THE 1ST ENTRY IN THE TABLE WILL BE FOR THE JOB CARD      *
*            THE 2ND ENTRY IN THE TABLE WILL BE FOR THE 1ST EXEC CARD *
*            FOLLOWING THE EXEC ENTRY WILL BE ANY DD ENTRIES FOR THE  *
*                STEP WHICH PASS OR CATLG PRIVATE DISK PACKS OR TAPES *
*            THE EXEC CARD ENTRY AND SUBSEQUENT DD ENTRIES WILL BE    *
*                REPEATED FOR ALL STEPS OF THE JOB.                   *
***********************************************************************
ENTLEN   EQU   40             LENGTH OF EACH TABLE ENTRY
ENTRYTYP DS    C              TABLE ENTRY TYPE
TYPEND   EQU   0              SIGNIFIES END OF TABLE
TYPJOB   EQU   1              SIGNIFIES A JOB ENTRY
TYPEXEC  EQU   2              SIGNIFIES AN EXEC ENTRY
TYPEDD   EQU   4              SIGNIFIES A DD ENTRY
***********************************************************************
*                                                                     *
*                      J O B                                          *
*                                                                     *
***********************************************************************
JENTRY   DS    0CL39          JOB STATEMENT ENTRY
JNAME    DS    CL8            JOB NAME
JPGMRNM  DS    CL10           PROGRAMMER NAME (1ST 10 BYTES ONLY)
JACCTNO  DS    CL14           ACCOUNT NUMBER (1ST ACCT INFO FIELD)
JACCTLEN DS    C              ACCOUNT NUMBER LENGTH
         ORG   JENTRY
***********************************************************************
*                                                                     *
*                     E X E C                                         *
*                                                                     *
***********************************************************************
EENTRY   DS    0CL39          EXEC STATEMENT ENTRY
EJSTEP   DS    CL8            JOB STEP NAME
EPSTEP   DS    CL8            PROC STEP NAME
EPGMNM   DS    CL8            PGM NAME
ELIBIND  DS    C              STEP HAD JOBLIB OR STEPLIB
ESTEPLIB EQU   1              STEPLIB PRESENT
EJOBLIB  EQU   2              JOBLIB PRESENT
EREGIONK EQU   4              REGION SPECIFIED IN 'K'
EREGION  DS    H              STEP REGION SIZE
ETAPES   DS    H              TAPE UNITS USED IN STEP
EPRIVS   DS    H              PRIV UNITS USED IN STEP
ECARDNO  DS    F              CARD NUMBER OF THIS STATEMENT
         ORG   JENTRY
***********************************************************************
*                                                                     *
*                       D D                                           *
*                                                                     *
***********************************************************************
DENTRY   DS    0CL39          DD STATEMENT ENTRY
DDDN     DS    CL8            DDNAME
DTYPE    DS    C              TYPE OF UNIT FOR THIS FILE
DTAPE    EQU   2              UNIT = TAPE
DPRIV    EQU   4              UNIT = PRIV OR PRIV-1
DDSN     DS    CL24           DSN FOR THIS FILE (1ST 24 CHARS ONLY)
DVOLSER  DS    CL6            FIRST VOL/SER OF DATA SET
         EJECT
EXIT6    CSECT
MSG0     DC    CL90'NWB100I XXXXXXXX XXXXXXXX TAPES= XXXXX PACKS= XXXXXX
                REGION= NNNNNK JTIME= XXXXX           '
MSG1     DC    CL90'NWB101I CLASS SET TO X                             X
                                                      '
MSG2     DC    CL90'NWB102E UNLIMITED CLASS 0 FOR TEST JOBS REQUIRES THX
               E USE OF TYPRUN=HOLD ON THE JOB CARD    '
MSG3     DC    CL90'NWB103E JOB REQUIREMENTS EXCEED THOSE ALLOWED FOR TX
               HE SPECIAL TEST JOB CLASS REQUESTED     '
MSG4     DC    CL90'NWB104I INTERNAL ERROR - MATCH WITHIN CLASS TABLE NX
               OT FOUND                               '
MESSAGES DS    0CL90          MESSAGE TABLE
M1       DC    CL90'NWB001I INTERNAL ERROR - INVALID TEXT STATEMENT TYPX
               E DETECTED                             '
M2       DC    CL90'NWB002E JOBNAME, ACCOUNTING INFORMATION, OR JOBNAMEX
                MISSING ON THE JOB CARD               '
M3       DC    CL90'NWB003I LENGTH OF JOBNAME EXCEEDS MAXIMUM OF 8 CHARX
               ACTERS                                 '
M4       DC    CL90'NWB004E INVALID LENGTH OF THE FIRST ACCOUNTING FIELX
               D                                      '
M5       DC    CL90'NWB005I LENGTH OF PROGRAMMER NAME FIELD ON THE JOB X
               CARD EXCEEDS MAXIMUM OF 20 CHARACTERS  '
M6       DC    CL90'NWB006E UNAUTHORIZED USE OF THE PERFORM KEYWORD ON X
               THE JOB CARD                           '
M7       DC    CL90'NWB007E UNAUTHORIZED USE OF THE ADDRSPC KEYWORD ON X
               THE JOB CARD                           '
M8       DC    CL90'NWB008I TIME VALUE ON THE JOB CARD IS NOT NUMERIC  X
                                                      '
M9       DC    CL90'NWB009E UNAUTHORIZED USE OF TIME=1440 ON THE JOB CAX
               RD                                     '
M10      DC    CL90'NWB010E UNAUTHORIZED USE OF THE REGION KEYWORD ON TX
               HE JOB CARD                            '
M11      DC    CL90'NWB011I LENGTH OF THE STEP NAME ON THE EXECUTE CARDX
                EXCEEDS MAXIMUM OF 8 CHARACTERS       '
M12      DC    CL90'NWB012I LENGTH OF THE PROGRAM NAME ON THE EXECUTE CX
               ARD EXCEEDS MAXIMUM OF 8 CHARACTERS    '
M13      DC    CL90'NWB013I INVALID FORMAT FOR THE REGION PARAMETER ON X
               THE EXECUTE CARD                       '
M14      DC    CL90'NWB014I REGION SIZE ON THE EXECUTE CARD IS NOT NUMEX
               RIC                                    '
M15      DC    CL90'NWB015I INVALID FORMAT FOR THE TIME PARAMETER ON THX
               E EXECUTE CARD                         '
M16      DC    CL90'NWB016E UNAUTHORIZED USE OF TIME=1440 ON THE EXECUTX
               E CARD                                 '
M17      DC    CL90'NWB017E UNAUTHORIZED USE OF THE PERFORM KEYWORD ON X
               THE EXECUTE CARD                       '
M18      DC    CL90'NWB018E UNAUTHORIZED USE OF THE ADDRSPC KEYWORD ON X
               THE EXECUTE CARD                       '
M19      DC    CL90'NWB019E UNAUTHORIZED USE OF THE DPRTY KEYWORD ON THX
               E EXECUTE CARD                         '
M20      DC    CL90'NWB020I LENGTH OF THE DDNAME ON THE DD CARD EXCEEDSX
                MAXIMUM OF 8 CHARACTERS               '
M21      DC    CL90'NWB021I INVALID FORMAT FOR THE DSNAME PARAMETER ON X
               THE DD CARD                            '
M22      DC    CL90'NWB022I LENGTH OF THE DSNAME ON THE DD CARD EXCEEDSX
                MAXIMUM OF 44 CHARACTERS              '
M23      DC    CL90'NWB023I INVALID FORMAT FOR THE DISP PARAMETER ON THX
               E DD CARD                              '
M24      DC    CL90'NWB024I INVALID FORMAT FOR THE UNIT PARAMETER ON THX
               E DD CARD                              '
M25      DC    CL90'NWB025I UNIT COUNT WITHIN THE UNIT PARAMETER ON THEX
                DD CARD IS NOT NUMERIC                '
M26      DC    CL90'NWB026I INVALID FORMAT FOR THE VOLUME PARAMETER ON X
               THE DD CARD                            '
M27      DC    CL90'NWB027I VOLUME COUNT WITHIN THE VOLUME PARAMETER ONX
                THE DD CARD IS NOT NUMERIC            '
M28      DC    CL90'NWB028I LENGTH OF THE VOLSER PARAMETER(S) ON THE DDX
                CARD EXCEEDS MAXIMUM OF 6 CHARACTERS  '
M29      DC    CL90'NWB029E UNAUTHORIZED DISPOSITION SPECIFIED FOR A SYX
               STEM DATA SET                          '
M30      DC    CL90'NWB030I INTERNAL ERROR - LENGTH OF THE INTERNAL TEXX
               T OF AN EXECUTE CARD EXCEEDS 512 CHARS '
M31      DC    CL90'NWB031I LENGTH OF THE PROC STEP NAME ON THE EXECUTEX
                CARD EXCEEDS MAXIMUM OF 8 CHARACTERS  '
M32      DC    CL90'NWB032I INVALID FORMAT FOR THE REFERBACK SUBPARAMETX
               ER ON THE DD CARD                      '
M33      DC    CL90'NWB033E INVALID DISPOSITION ON A JOBLIB, STEPLIB, JX
               OBCAT, OR STEPCAT DD CARD              '
M34      DC    CL90'NWB034I THE LENGTH OF THE DSNAME ON A VOLUME REFERBX
               ACK EXCEEDS A MAXIMUM OF 44 CHARACTERS '
M35      DC    CL90'NWB035E THE REQUIRED ACCOUNTING FIELD ON THE JOB CAX
               RD WAS NOT SPECIFIED                   '
M36      DC    CL90'NWB036E INVALID RESOURCE SPECIFIED IN THE ACCOUNTINX
               G FIELD                                '
M37      DC    CL90'NWB037E TEST JOBS REQUIRE THE PC/70 CODE TO BE IN TX
               HE ACCOUNTING FIELD                    '
M38      DC    CL90'NWB038E INVALID PC/70 CODE SPECIFIED IN THE ACCOUNTX
               ING FIELD                              '
M39      DC    CL90'NWB039E PC/70 CODE NOT ALLOWED IN THE ACCOUNTING FIX
               ELD ON A PRODUCTION JOB                '
M40      DC    CL90'NWB040E INVALID APPLICATION CODE SPECIFIED IN THE AX
               CCOUNTING FIELD                        '
M41      DC    CL90'NWB041E INVALID GL COST CENTER SPECIFIED IN THE ACCX
               OUNTING FIELD                          '
M42      DC    CL90'NWB042E JOBNAME NOT AUTHORIZED FOR THE RESOURCE SPEX
               CIFIED IN THE ACCOUNTING FIELD         '
M43      DC    CL90'NWB043E UNAUTHORIZED USE OF JOBCAT OR STEPCAT DD STX
               ATEMENT                                 '
M44      DC    CL90'NWB044E UNAUTHORIZED USE OF BYPASS LABEL PROCESSINGX
                (BLP)                                  '
M45      DC    CL90'NWB045E UNAUTHORIZED ATTEMPT TO BYPASS TMS WITH LABX
               EL=EXPDT=98000                          '
M46      DC    CL90'NWB046E UNAUTHORIZED ATTEMPT TO ALLOCATE THE JES2 IX
               NTERNAL READER                          '
M47      DC    CL90'NWB047E UNAUTHORIZED USE OF JOBLIB DD STATEMENT    X
                                                       '
M48      DC    CL90'NWB048E DATASET REQUIRES A DISK PACK WHICH IS NOT AX
               VAILABLE FOR PROCESSING AT THIS TIME    '
M49      DC    CL90'NWB049E UNAUTHORIZED USE OF THE PRTY KEYWORD ON THEX
                JOB CARD                               '
M50      DC    CL90'NWB050E UNAUTHORIZED USE OF PRODUCTION-ONLY SYSOUT X
               CLASS IN SYSOUT SPECIFICATION           '
         AIF   ('&BINREQD' NE 'YES').BIN4
M51      DC    CL90'NWB051E BIN NUMBER MUST BE SPECIFIED ON THE JOB CARX
               D                                       '
M52      DC    CL90'NWB052E BIN NUMBER MUST BE FOUR CHARACTERS LONG    X
                                                       '
.BIN4    ANOP
         $MODEND
         END
