N2QP     TITLE 'HJSTP - JES2/NJE RELEASE 2 QUEUE PROCESSOR'
         MACRO
&NAME    #RETURN &REGS,&RC=0
&NAME    DS    0H
         L     R13,4(R13)          RESTORE ORIGINAL BASE
         RETURN  &REGS,RC=&RC
         MEND
         SPACE 3
         MACRO
         $HASPCB &DOC=NO
         GBLC  &PRINT,&GEN,&DATA
         PUSH  PRINT
         PRINT GEN
         $HCT  DOC=&DOC
         $LRC  DOC=&DOC
         $BUFFER DOC=&DOC
         $JQE  DOC=&DOC
         $JCT  DOC=&DOC
         $TAB  DOC=&DOC
         $IOT  DOC=&DOC
         $PDDB DOC=&DOC
         $JOE  DOC=&DOC
         $JOT  DOC=&DOC
         $CAT  DOC=&DOC                                           SPR2
         $PCE  DOC=&DOC                                           SPR2
*        $HQR  DOC=&DOC                                           SPR2
*        $HQT  DOC=&DOC                                           SPR2
         POP   PRINT
         PRINT &GEN,&DATA
         MEND
         SPACE 4
HJSTN2QP CSECT
         HJCPYRIT
         COPY  $HASPGEN
         $SYSPARM  (OFF,GEN,NODATA,NO,YES)
         TITLE 'HJSTP - JES2/NJE RELEASE 2 QUEUE PROCESSOR'
         HJENTRY GENHJCT=NOGEN,GENSYMB=NOGEN,BASE=(HJBASE1,HJBASE2)
         EJECT
******************************
* REGISTER USAGE             *
*        R3=REQUEST BLOCK PTR*
*        R4=CURJQE           *
*                            *
*                            *
******************************
         SPACE 3
*  DETERMINE FUNCTION REQUESTED BY CALLER
         LR    R3,R1               SAVE REQUEST BLOCK PTR
         USING QPINT,R3
         CLI   QPFCTN,QPFJBRQ      JBRQ-GET JOB REQUEST
         BE    N2JBRQ
         CLI   QPFCTN,QPFOPEN      OPEN DATA SET REQUEST
         BE    N2OPEN
         CLI   QPFCTN,QPFGET      GET REQUEST
         BE    N2GET
         LA    R2,*                PT TO ERROR LOC
         B     N2BADEND
         TITLE 'JOB SELECT FUNCTION'
* REQUEST TO SELECT NEXT JOB OR TO SETUP A JOB
N2JBRQ   DS    0H
*  CHECK REQUEST TYPE
         CLI   QPTYPE,QPTNEXT      SELECT NEXT JOB?
         BE    N2JBNEXT
         CLI   QPTYPE,QPTSETUP     SETUP CURRENT JOB?
         BE    N2JBSET
         LA    R2,*                PT TO ERROR LOC
         B     N2BADEND
         SPACE 3
N2JBNEXT DS    0H                  LOCATE NEXT JOB IN JOBQ
         MVI   N2FLAGS,X'00'       RESET N2QP FLAGS
         XC    N2CKPJOE,N2CKPJOE   RESET PTR TO CHKPT JOE (DMD SETUP)
*  FREE BUFFERS USED FOR PREVIOUS JOB
         ICM   R1,15,CTCBBFRS      GET 1ST CTL BLK BAT
         BZ    N2GETJQE            BR 1ST TIME THRU (NO BATS YET)
         USING CBBDSECT,R1
         LA    R0,CBBFRADR         POINT TO FIRST BUFFER ENTRY
         ST    R0,CBBFRNXT         INVALIDATE BUFFERS
*                                  BY MAKING NEXT=FIRST
         DROP  R1
N2GETJQE ICM   R4,15,N2CURJQE       STEP TO NEXT JQE IN JOBQ
         BNZ   N2NXJQE        GO IF NOT 1ST JQE
         L     R4,N2$JOBQ     1ST JQE
         B     N2JQEST        GO STORE
N2NXJQE  DS    0H             NOT 1ST ,STEP TO NEXT
         USING JQEDSECT,R4
         LA    R4,JQELNGTH(R4)
N2JQEST  DS    0H
         ST    R4,N2CURJQE             AND SAVE
*  CHECK IF AT END OF JOBQ
         C     R4,N2EOJQ           ADDR OF JOBQ END SET BY N2QI
         BNL   N2JBEOQ             GO IF DONE
*  FILL IN JOB HDRS FROM THE JQE
         CLI   JQETYPE,X'00'       IGNORE IF FREE JQE
         BE    N2NXJQE
         CLI   JQETYPE,X'FF'       IGNORE IF JQE NEVER USED
         BE    N2NXJQE
         MVC   JHJOBNAM,JQEJNAME   JOB NAME TO JOB HDR
         MVC   JHJOBNO,JQEJOBNO    JOB NUMBER
         MVC   JHINJBNO,JQEINJNO   INITIAL JOB NUMBER
         L     R1,JQEPRTRT         JOB PRINT ROUTING               SPR2
         BAL   R14,N2RTECNV        CONVERT TO MNEMONIC
         MVC   JHPRRMT,N2ROUTE     PRINT REMOTE
         MVC   JHPRNODE,N2NODE     PRINT NODE
         L     R1,JQEPUNRT         JOB PUNCH ROUTING               SPR2
         BAL   R14,N2RTECNV
         MVC   JHPURMT,N2ROUTE     PUNCH REMOTE
         MVC   JHPUNODE,N2NODE     PUNCH NODE
         SLR   R1,R1               CLEAR REG
         ICM   R1,3,JQEXEQND       JOB EXEC NODE (NO EXEC REMOTE)  SPR2
         BAL   R14,N2RTSP2         CONVERT TO MNEMONIC (NEW BAL)   SPR2
         MVC   JHXEQNOD,N2NODE     EXECUTION NODE
         MVC   JHPRTY,JQEPRIO      PRIORITY
* SET JOB TYPE BASED ON JOB NUMBER
         MVI   JHJOBTYP,C'J'       ASSUME BATCH JOB
*        CLC   JQEJOBNO,=AL2(10000) BATCH JOB NUMBERS LT 10K      SPR2
*        BL    N2JSTAT             CHK JOB STATUS FOR BATCH JOB   SPR2
         TM    JQEFLAG3,QUEJOB     TEST FOR BATCH JOB             SPR2
         BZ    N2JSTAT             IF ZEROES THEN BATCH           SPR2
         MVI   JHJOBTYP,C'T'       ASSUME TSO USER
*        CLC   JQEJOBNO,=AL2(20000) TSO JOBS GTE 20001            SPR2
*        BNL   N2JSTAT                                            SPR2
         TM    JQEFLAG3,QUETSU     TEST FOR TSU   JOB             SPR2
         BO    N2JSTAT             IF ONES   THEN TIME SHARERER   SPR2
         MVI   JHJOBTYP,C'S'       10001 LE STC LE 19999
N2JSTAT  DS    0H
* TEST JQE STATUS TO DETERMINE JOB STATUS
         TM    JQEFLAGS,$PURGE     CHECK FOR PURGED JOB
         BO    N2PURQ
         TM    JQETYPE,$XEQ+$XMIT  EXECUTION OR JOB XMTR QUEUE?
         BNZ   N2XEQCK              BR IF EITHER
         TM    JQETYPE,$INPUT+$RECEIVE  IS JOB STILL COMING IN?
         BNZ   N2INQ                      YES, GET NEXT JOB
         TM    JQETYPE,$OUTPUT+$HARDCPY QUEUED FOR OUTPUT?
         BZ    N2JERR1              NO, THEN JQETYPE IS IN ERROR
         MVI   JHPRCSTG,JHPRCQO    SET QUEUED FOR OUTPUT
         B     N2XEQCKX            GO TEST HOLD STATUS
N2PURQ   DS    0H                  JOB IS BEING PURGED
         MVI   JHPRCSTG,JHPRCPRG
         B     N2JHDRX
N2INQ    DS    0H                  JOB WAS BEING READ
         MVI   JHPRCSTG,JHPRCINP
         B     N2JHDRX
N2OUTQ   DS    0H                  SET QUEUED FOR OUTPUT
         MVI   JHPRCSTG,JHPRCQO
         B     N2XEQCKX            GO TEST HOLD STATUS
         SPACE 3
N2XEQCK  DS    0H                  JOB ON EXEC OR JOB XMTR QUEUE
         CLI   JQETYPE,$XEQ        IF JOB IS WAITING FOR CONVERSION
         BNE   N2XMITCK             (BR IF NOT)
         MVI   JHPRCSTG,JHPRCQX        THEN SET WAIT FOR XEQ
         B     N2XEQCKX
N2XMITCK DS    0H
         CLI   JQETYPE,$XMIT       TEST FOR QUEUED FOR JOB XMTR
         BNE   N2XEQCK1             BR IF NOT
         MVI   JHPRCSTG,JHPRCXMT    IF SO, SET PROCESSING STAGE
         B     N2XEQCKX              AND CONTINUE
N2XEQCK1 DS    0H                  DETERMINE JOB TYPE
         TM    JQEFLAGS,QUEBUSY    IF QUEBUSY NOT = 0
         BNZ   N2INXEQ               THEN JOB IS IN EXECUTION
         MVI   JHPRCSTG,JHPRCQX     ELSE JOB IS WAITING EXECUTION
         B     N2XEQCK2            GO CHK JOB CLASS
N2INXEQ  DS    0H                  JOB IN EXECUTION
         MVI   JHPRCSTG,JHPRCIX
N2XEQCK2 DS    0H                  CHK TYPE OF USER
         CLI   JQETYPE,$XEQ+$INPUT IF TSO USER
         BE    N2XEQCKX
         CLI   JQETYPE,$XEQ+$XMIT IF STC ID
         BE    N2XEQCKX
         MVC   JHJOBCLS,JQETYPE   SET CLASS FROM JQE
         OI    JHJOBCLS,X'80'
N2XEQCKX DS    0H                  END OF XEQ CHK
         TM    JQEFLAGS,QUEHOLDA+QUEHOLD1 JOB HELD?
         BZ    *+8
         OI    JHFLGS1,JH1HOLD
N2JHDRX  DS    0H                  END OF SET JOB HDR
* NORMAL EXIT
N2JNEXIT DS    0H
         #RETURN (14,12),RC=0
         SPACE 3
*  END OF JOB QUEUE EXIT
N2JBEOQ  DS    0H
         L     R14,QPJNJF          PICK UP NO JOB FOUND EXIT
         #RETURN (2,12),RC=0
         DROP  R4
         TITLE 'JOB SETUP FUNCTION'
*******************************************
*  SETUP JOB POINTED TO BY CURJQE         *
*******************************************
N2JBSET  DS    0H
         L     R4,N2CURJQE         JQE SELECTED BY N2JBNEXT
         USING JQEDSECT,R4
* GET JCT FOR THIS JOB
* FIRST GET A BUFFER FOR JCT
         HJCALL GETBUF             GET CTL BLK BUFFER
         ST    R1,SPBFR            SAVE ADDR FOR SPIO
         S     R1,=A(BUFSTART-BUFDSECT)  ADJUST FOR JCT ADDRESSABILITY
         ST    R1,N2CURJCT         SAVE FOR QP JOB PROCESSING
         MVC   SPMTTR,JQETRAK      JCT PTR TO SPIO MTTR
         XC    CTSPECBS,CTSPECBS    CLEAR SYNCH ECB
         POST  CTQPECBS,C'SBR'     ASK SPIO TO READ JCT
N2JWAIT  DS    0H                  WAIT FOR SPIO POST
         WAIT  ECB=CTSPECBS        WAIT FOR I/O
         XC    CTSPECBS,CTSPECBS     CLEAR ECB
*  CHECK IF GOOD JCT
         CLI   SPFLGS,BFRERR       CHECK FOR ERROR RETURN CODE
         BE    N2JERR2
         L     R5,N2CURJCT         JCT PTR
         USING JCTDSECT,R5
         CLC   JCTID,=CL4'JCT'     CHECK CTL BLK ID
         BNE   N2JERR2
         SPACE 3
* GET ALL IOTS
         ICM   R7,15,JCTIOT        1ST IOT
         BZ    N2JERR4              GO IF NONE
         HJCALL GETBUF             GET CTL BLK BUFFER
         S     R1,=A(BUFSTART-BUFDSECT)  OFFSET FOR DATA NOT RECORDED
         ST    R1,N2JCTIOT         NEED TO LOCATE 1ST IOT LATER
         B     N2IOTLPA            GO TO SET UP FOR IOT READ
N2IOTLP  DS    0H                  LOOP TO GET IOTS
         HJCALL GETBUF             GET CTL BLK BUFFER
         S     R1,=A(BUFSTART-BUFDSECT)  OFFSET TO SKIP IOB
*  NOTE: R6 POINTS TO PREVIOUS IOT
         USING IOTDSECT,R6
         ST    R1,IOTIOT           SAVE IN-CORE PTR IN PREV IOT
N2IOTLPA DS    0H                  ENTER HERE ON 1ST IOT
         LR    R6,R1               R6 = NEW IOT PTR
*                                  POINTS TO IOT BEING READ
         A     R1,=A(BUFSTART-BUFDSECT)  NEED ACTUAL ADDR FOR SPIO
         ST    R1,SPBFR            INPUT BUFFER
         ST    R7,SPMTTR           SET SPIO MTTR
         POST  CTQPECBS,C'SBR'     ASK SPIO TO READ IOT
         WAIT  ECB=CTSPECBS        WAIT FOR I/O
         XC    CTSPECBS,CTSPECBS     CLEAR ECB
         CLI   SPFLGS,BFRERR       CHECK FOR ERROR RETURN CODE
         BE    N2JERR3
         CLC   JCTJBKEY,IOTJBKEY   MAKE SURE SAME JOB
         BNE   N2JERR3
         ICM   R7,15,IOTIOTTR      NEXT IOT
         BNZ   N2IOTLP             GET NEXT IF ANY
         TM    N2FLAGS,N2SPIOT     CHK IF SPIN IOTS PROCESSED
         BO    N2IOTX              GO IF YES
         OI    N2FLAGS,N2SPIOT     SET SPIN IOT INDICATOR
         ICM   R7,15,JCTSPIOT      1ST SPIN IOT
         BNZ   N2IOTLP             PROCESS SPIN IOTS
N2IOTX   DS    0H                  END OF IOTS
         XC    IOTIOT,IOTIOT       MAKE SURE END OF CHAIN
         DROP  R4
         DROP  R6
         SPACE 3
*  BRING IN ALL HQTS IF HARDCOPY STATUS PROCESSING TO BE DONE
*        TM    CTFLGS1,CT1UNDDS    TEST FOR HRDCPY STATUS PROC
*        BZ    N2HQTX               AND BR IF NOT BEING USED
*        OC    JCTHQRCT,JCTHQRCT   ANY HELD DS'S?
*        BNZ   *+14                 BR IF SO
*        XC    JCTHQT,JCTHQT        OTHERWISE, ZERO HQT PTR
*        B     N2HQTX                AND SKIP HQT PROCESSING
*        ICM   R7,15,JCTHQT        GET MTTR FOR 1ST HQT
*        BZ    N2JERR4              ERROR IF NONE
*        HJCALL  GETBUF            GET A BFR FOR HQT
*        S     R1,=A(BUFSTART-BUFDSECT)  ALLOW FOR BFR HDR
*        ST    R1,JCTHQT           SAVE PTR IN JCT
*        B     N2HQTLPA            BR INTO HQT LOAD LOOP
*2HQTLP  DS    0H
*        HJCALL  GETBUF            GET A BFR FOR NXT HQT
*        S     R1,=A(BUFSTART-BUFDSECT)  ALLOW FOR BFR HDR
*        USING HQTDSECT,R6         ESTABLISH HQT ADDRESSABILITY
*        ST    R1,HQTHQT           SAVE CHAIN PTR IN PREV HQT
*2HQTLPA DS    0H                  ENTRY FOR 1ST HQT
*        LR    R6,R1               SWITCH TO NEW HQT
*        A     R1,=A(BUFSTART-BUFDSECT)  ACTUAL ADDR FOR SPIO
*        ST    R1,SPBFR            SET BFR PTR FOR SPIO
*        ST    R7,SPMTTR            AND MTTR, TOO
*        POST  CTQPECBS,C'SBR'     TELL SPIO TO GET HQT
*        WAIT  ECB=CTSPECBS         AND WAIT FOR IT TO HAPPEN
*        XC    CTSPECBS,CTSPECBS   CLEAR ECB
*        CLI   SPFLGS,BFRERR       CHECK FOR I/O ERROR
*        BE    N2JERR3              BR ON ERROR
*        CLC   JCTJBKEY,HQTJBKEY   COMPARE CTL BLK KEYS
*        BNE   N2JERR3              ERROR IF NOT EQ
*        ICM   R7,15,HQTHQT        GET CHAIN FIELD
*        BNZ   N2HQTLP              AND BR IF MORE HQTS
*  FALL THRU WHEN ALL HQTS IN STORAGE
         SPACE 1
N2HQTX   DS    0H                  END OF HQT PROCESSING
*        DROP  R6                  KILL HQT ADDRESSABILITY
         SPACE 3
* CLEAR JCL AND DATA SET BUFFERS
         L     R1,CTDSBFRS         DATA SET BUFFERS
         L     R0,CTDSBRND         LAST DS BFR PTR
         BAL   R14,N2BFCLR         GO CLEAR DATA SET BUFFERS
         L     R1,CTJCLBFR         SET TO CLEAR JCL BUFFERS
         L     R0,CTJCLBND         LAST JCL BFR
         BAL   R14,N2BFCLR         CLEAR JCL BUFFERS
         SPACE 3
*  INITIALIZE CURRENT SYSIN AND SYSOUT DS KEYS
         XC    N2SINKEY,N2SINKEY  CLEAR CURRENT SYSIN
         XC    N2SOTKEY,N2SOTKEY               SYSOUT
*  FILL IN JOB HDR FIELDS
         MVC   JHMSGCLS,JCTMCLAS   JOB MESSAGE CLASS
         MVC   JHJOBCLS,JCTJCLAS   JOB CARD CLASS
         MVC   JHJOBTYP,JCTJOBID   1ST CHAR = J,S,T
         MVC   JHTSUID,JCTTSUID    TSO USERID FOR NOTIFY
         MVC   JHCPYCT,JCTCPYCT    JOB COPY COUNT
         MVC   JHLINCT,JCTLINCT    LINES PER PAGE
         TM    JCTJBOPT,JCTPRICD   PRTY CARD PRESENT?
         BZ    *+8
         OI    JHFLGS1,JH1PRICD
         TM    JCTJBOPT,JCTXBACH   X BATCH MONITOR
         BZ    *+8
         OI    JHFLGS1,JH1XBM
         TM    JCTJBOPT,JCTTHOLD   TYPRUN=HOLD
         BZ    *+8
         OI    JHFLGS1,JH1THOLD
         TM    JCTJOBFL,JCTTSCAN   TYPRUN=SCAN
         BZ    *+8
         OI    JHFLGS1,JH1TSCAN
         TM    JCTJOBFL,JCTTCOPY   TYPRUN=COPY
         BZ    *+8
         OI    JHFLGS1,JH1TCOPY    SET COPY IND
*        TM    JCTJBOPT,JCTNOLOG   /*JOBPARM NOLOG SPECIFIED  CBT  SPR2
*        BNO   *+8                                            CBT  SPR2
*        OI    JHFLGS1,JH1NJLOG    SET NOLOG FLAG             CBT  SPR2
         MVC   JHFORMS,JCTFORMS    JOB FORMS
         MVC   JHPNAME,JCTPNAME    PROGRAMMER NAME
         MVC   JHACCTNO,JCTACCTN   ACCTG FIELDS
         MVC   JHROOMN,JCTROOMN    ROOM NUMBER
         MVC   JHESTLIN,JCTESTLN   ESTIMATED PRINT LINES
         MVC   JHESTPUN,JCTESTPU   ESTIMATED PUNCH CARDS
         MVC   JHNETACT,JCTNACCT   NETWORK ACCTG NO.
         SPACE 1
*        FILL IN JOB LOG STATUS FIELDS
         MVC   JHCARDS,JCTCARDS    # CARDS READ
         MVC   JHLINES,JCTLINES    LINES PRINTED
         MVC   JHPUNCH,JCTPUNCH    CARDS PUNCHED
         MVC   JHXEQON,JCTXEQON    XEQ START TIME
         MVC   JHXEQOF,JCTXEQOF    XEQ END TIME
         SPACE 1
         MVC   JHPASS,JCTPASS      RACF PASSWORDS
         MVC   JHNUPASS,JCTNUPAS
         DROP  R5
*  NORMAL RETURN
         B     N2JNEXIT            TAKE NORMAL EXIT
         TITLE 'QPOPEN FUNCTION'
*****************************************************
*  QPOPEN REQUEST PROCESSING                        *
*****************************************************
N2OPEN   DS    0H
         CLI   QPTYPE,QPTJCL       IF JCL OPEN REQUEST
         BE    N2JCLOP                GOTO OPEN JCL DS
         CLI   QPTYPE,QPTSYSIN     IF SYSIN OPN
         BE    N2SINOP               GOTO OPEN SYSIN DS
         CLI   QPTYPE,QPTSYOUT     IF SYSOUT REQUEST
         BE    N2SOTOP              GOTO OPEN SYSOUT DS
         LA    R2,*                PT TO LOC OF INVALID REQ
         B     N2BADEND             AND QUIT
         SPACE 3
N2JCLOP  DS    0H                  OPEN JCL DATA SET REQUEST
         XC    N2CURPDB,N2CURPDB   CLEAR CURRENT PDDB PTR
         MVC   N2DSKEY,=H'1'       SET DSKEY TO JCL KEY
         BAL   R14,N2OPDDB         GO LOCATE PDDB
         LTR   R15,R15             CHK FOR PDDB FOUND
         BZ    N2OERR1             OPEN ERROR IF NO JCL
         USING PDBDSECT,R15
         CLC   PDBDSKEY,N2DSKEY    CHK FOR JCL AS FIRST PDDB
         BNE   N2OERR1
         MVC   SPMTTR,PDBMTTR      ELSE USE MTTR FROM PDDB
         DROP  R15
         BAL   R14,N2OREAD         GO DO 1ST RECORD READ
         B     N2JNEXIT            TAKE NORMAL EXIT
         SPACE 3
*  REQUEST TO OPEN SYSIN DATA SET
*  N2DSKEY HAS DATA SET KEY FROM JCL CTL REC
*  N2SINKEY HAS MTTR FROM SAME CTL REC
N2SINOP  DS    0H
N2SINPDB DS    0H                  FIND NEXT PDDB
         BAL   R14,N2OPDDB         GO SEARCH FOR SYSIN BY KEY
         LTR   R15,R15             R15 IS PDDB PTR OR ZERO
         BZ    N2OERR2             GO IF DS NOT FOUND
         USING PDBDSECT,R15
         CLC   N2DSKEY,PDBDSKEY   CHECK IF THIS IS RIGHT KEY
         BNE   N2SINPDB            NEXT PDDB
         CLC   N2SINKEY,PDBMTTR    MTTRS THE SAME
         BNE   N2OERR2             GO IF NOT
         MVC   SPMTTR,PDBMTTR      USE PDDB MTTR
*  BUILD DATA SET HDR FOR SYSIN
         MVC   DSHLRECL,PDBLRECL   LOG REC LEN
         MVC   DSHRECFM,PDBRECFM
         DROP  R15
         BAL   R14,N2OREAD         GO READ 1ST RECORD
         B     N2JNEXIT            NORMAL EXIT
         TITLE 'QPOPEN SYSOUT DATA SET FUNCTION'
*  PROCESS SYSOUT OPEN REQUEST
*        PROCESS PDDBS  WITH PDB1NSOT NOT = 0.
N2SOTOP  DS    0H
         SR    R5,R5
         ICM   R5,3,N2SOTKEY       CHK IF FIRST DS
         BNZ   N2SOTNXT            GO IF NOT FIRST
         XC    N2CURPDB,N2CURPDB   SET SEARCH TO BEGINNING
         XC    N2DSKEY,N2DSKEY     ACTUAL PDDB KEY
*        NI    N2FLAGS,255-N2HSACC1  RESET HSP DS ACCEPTED FLAG SPR2
         NI    N2FLAGS,255-N2HSACC1-N2R2RMT    AND REMOTE FLAG  SPR2
         SPACE 1
N2SOTNXT DS    0H                  STEP TO NEXT SYSOUT DS
         TM    QPOOPTN,QPOBEGIO    INITIATE I/O ON PREV OPENED DS?
         BO    N2OBEGIO             YES, DONT HAVE TO REBUILD DS HDR
         LA    R5,1(R5)            INCR DS KEY
         STH   R5,N2SOTKEY          AND SAVE IT
* DO UNTIL SYSOUT DS FOUND
N2SOTPDB DS    0H
         BAL   R14,N2OPDDB         GET NEXT PDDB
N2PDHOOK DS    0H                  LABEL FOR TEST
         LTR   R15,R15             PTR TO PDDB OR ZERO
         BZ    N2OERR3             SYSOUT NOT FOUND
         USING PDBDSECT,R15
         TM    PDBFLAG1,PDB1NSOT+PDB1NULL   CHK IF SYSOUT DS
         BNZ   N2SOTPDB            GET NEXT PDDB IF NOT
         SPACE 1
*        SYSOUT DATA SET FOUND
         TM    PDBFLAG1,PDB1MDES   MULTI-DESTINATION DS
         BZ    N2CKPREV            CHECK FOR MATCH ON EARLIER DS
         CLC   N2DSKEY,PDBDSKEY    SEE IF SAME AS PREV PDDB DS
         BNE   N2CKPREV            CHECK FOR MATCH ON EARLIER DS
         B     N2SOTPDB            SKIP PDDB IF SAME DS
         SPACE 2
*  CHECK FOR PREV PDDB FOR SAME DS
N2CKPREV MVC   N2PDBSAV,N2CURPDB   SAVE CURRENT PDDB
         MVC   N2IOTSAV,N2CURIOT    AND IOT PTRS
         MVC   N2KEYSAV,PDBDSKEY    ALSO KEY OF DS BEING CHECKED
         XC    N2CURPDB,N2CURPDB   FORCE RESCAN OF ALL PDDBS
         SPACE 1
N2CKLOOP BAL   R14,N2OPDDB         GET NEXT PDDB
         TM    PDBFLAG1,PDB1NSOT+PDB1NULL   CHK FOR SYSOUT DS
         BNZ   N2CKLOOP            LOOP IF NOT
         CLC   N2CURPDB,N2PDBSAV   ARE WE BACK WHERE WE STARTED?
         LA    R2,0                 ANTICIPATE YES
         BE    N2CKXIT              YES, THEN NO MATCH ON ANY PREV
         CLC   N2KEYSAV,PDBDSKEY   DIFF PDDBS, BUT SAME DS?
         LA    R2,4                 IN CASE YES
         BNE   N2CKLOOP             LOOP IF NOT SAME DS
         SPACE 1
N2CKXIT  MVC   N2CURPDB,N2PDBSAV   RESTORE CURRENT PDDB
         MVC   N2CURIOT,N2IOTSAV    AND IOT PTRS
         B     *+4(R2)             EXIT VIA BR VECTOR
         B     N2SOTEQ             NO MATCH WITH ANY PREV PDDB
         B     N2SOTPDB            MATCHING PDDB, SO SKIP THIS ONE
         SPACE 3
* CORRECT SYSOUT DATA SET FOUND
N2SOTEQ  DS    0H                  NEED TO PROCESS THIS SYSOUT
         L     R15,N2CURPDB        POINT TO PDDB
         MVC   N2DSKEY,PDBDSKEY    SAVE ACTUAL DSKEY
         MVC   SPMTTR,PDBMTTR      SAVE MTTR
* BUILD SYSOUT DATA SET HEADER
*        NI    N2FLAGS,255-N2HSACC1  RESET HSP DS ACCEPTED FLAG SPR2
         NI    N2FLAGS,255-N2HSACC1-N2R2RMT  AND REMOTE FLAG    SPR2
         MVC   DHCLASS,PDBCLASS    SYSOUT CLASS
         MVC   DHRECFM,PDBRECFM    RECFM
         MVC   DHLRECL,PDBLRECL    MAX LRECL
         MVC   DHCOPYS,PDBCOPYS    COPIES OF THIS DATASET
         MVC   DHRECCNT,PDBRECCT   RECORD COUNT
         MVC   DHFORMS,PDBFORMS    FORMS NUMBER
         MVC   DHFCB,PDBFCB        3211 FCB ID
         MVC   DHUCS,PDBUCS        1403 OR 3211 UCS ID
         MVC   DHINDEX,PDBINDEX    3211 FCB INDEX VALUE
         CLC   PDBDSKEY,=AL2(PDBINJNL)  IGNORE FUNC IF SYS DS
         BNH   *+10
         MVC   DHFCTN,PDBFUNC      3525 FUNCTION BYTE
         MVC   DHWTRID,PDBWTRID    OUTPUT WRITER ID OR DSID
         MVC   DHCHAR1,PDBCHAR1    3800 PRINTER XLATE TAB 1
         MVC   DHCHAR2,PDBCHAR2                           2
         MVC   DHCHAR3,PDBCHAR3                           3
         MVC   DHCHAR4,PDBCHAR4                           4
         MVC   DHFLASH,PDBFLASH    3800 FLASH CART ID
         MVC   DHCPYMOD,PDBMODF     3800 COPY MOD IMAGE
         MVC   DHCPYGRP,PDBCOPYG   3800 COPY GROUPS
         MVC   DHFLSHCT,PDBFLSHC   3800 # FLASH COPIES
         MVC   DHMODTRC,PDBMODFT   3800 TBL REF CHAR
*        CLC   PDBDDN(4),=C'ZMOP'  MOPS SPUN DATASET ?          CBTSPR2
*        BNE   ZMOP1               NOPE NO NEED TO MICKEY MOUSE CBTSPR2
*        MVC   DHWTRID,PDBDDN      SET DDNAME AS WTR ID         CBTSPR2
*MOP1    DS    0H                                               CBTSPR2
         TM    PDBFLAG1,PDB1DSID   DSID DS AND NOT WTRID
         BZ    *+8
         OI    DHFLGS1,DH1DSID
         TM    PDBFLAG1,PDB1NULL   NULL PDDB
         BZ    *+8
         OI    DHFLGS1,DH1NULL
         TM    PDBFLAG1,PDB1LOG    JES2 JOB LOG
         BZ    *+8
         OI    DHFLGS1,DH1LOG
         TM    PDBFLAG1,PDB1NSOT   NOT A SYSOUT DS
         BZ    *+8
         OI    DHFLGS1,DH1NSOT
         TM    PDBFLAG1,PDB1SPIN   SPIN DS
         BZ    *+8
         OI    DHFLGS1,DH1SPIN
         TM    PDBFLAG1,PDB1HOLD   DS IS ON HOLD
         BZ    *+8
         OI    DHFLGS1,DH1HOLD
         TM    PDBFLAG2,PDB2OPTJ   3800 OPTCD=J?
         BZ    *+8
         OI    DHFLGS1,DH1OPTJ
         TM    PDBFLAG2,PDB2BRST   3800 BURST=Y?
         BZ    *+8
         OI    DHFLGS1,DH1BRST
         DROP  R15
         SPACE 3
* NEED TO SET ROUTE CODES IN DS HDR
* IF PDB1MDES FLAG IS ON, MULTIPLE DESTINATIONS EXIST FOR DS
*
         LR    R5,R15              CONVERT ROUTE CODE USES R15
         USING PDBDSECT,R5
         LA    R7,4                # OF ROUTE CODES
         LA    R6,DHNODE1          1ST NODE/DEV PAIR
         ST    R5,N2PDBSAV         SAVE CURRENT PDDB PTR
         MVC   N2IOTSAV,N2CURIOT   SAVE CURRENT IOT PTR
N2DESTLP DS    0H
         TM    CTFLGS1,CT1UNDDS    TEST FOR HRDCPY STATUS PROCESSING
         BZ    N2ENDHSP             AND BR IF NOT REQUESTED
         SPACE 1
         L     R9,N2CURJQE         PT TO JOB'S JQE
         USING JQEDSECT,R9         ESTABLISH JQE ADDRESSABILITY
         TM    JQETYPE,$OUTPUT     JOB ON OUTPUT (NOT HRDCPY) QUEUE?
         BNZ   N2ENDHSP             YES, GO BEC NOTHING PRINTED YET
         SPACE 1
*  DETERMINE WHETHER DATA SET IS PART OF DEMAND SETUP GROUP
         TM    N2FLAGS,N2DMDSET    TEST FOR DEMAND SETUP FOR JOB
         BZ    N2HSJOTP             IF NONE, GO LOOK IN JOT
         CLC   PDBCLASS,JHMSGCLS    YES, THEN IS THIS DS PART OF GRP?
         BNE   N2HSJOTP              NO, NOT UNLESS DS CLASS=MSGCLASS
         CLC   PDBDEST,=F'0'       DS MUST ALSO HAVE MSGCLS ROUTING
         BNE   N2HSJOTP             BR IF WRONG ROUTING
         SPACE 1
*  DS IS PART OF DEMAND SETUP GROUP - NOW DETERMINE IF ALREADY PRTD
         ICM   R14,15,N2CKPJOE     TEST WHETHER GROUP INTRPTD ON PRTR
         BZ    N2HSACPT             NO CHKPT JOE, NO INTRPT, SO BR
         USING JOEDSECT,R14        ESTABLISH JOE ADDRESSABILITY
         LR    R15,R5              COPY PDDB PTR
         S     R15,N2CURIOT        GET PDDB DISPL IN IOT
         CH    R15,JOEPDDB         DET IF PDDB ACTUALLY ON PRTR
         BNL   N2HSACPT            ACCEPT IF NOW ON OR NOT YET PRTD
         B     N2HSNULL            REJECT IF ALREADY PRINTED
         SPACE 1
N2HSJOTP DS    0H
         L     R9,N2$JOT           GET PTR TO JOT
         USING JOTDSECT,R9         ESTABLISH JOT ADDRESSABILITY
         SPACE 1
*  FIND CLASS QUEUE IN JOT FOR THIS DS, THEN LOOK FOR WORK JOE
         SR    R15,R15             CLEAR WORK REG
         IC    R15,DHCLASS         GET CLASS OF DS
         SL    R15,=A(C'A')        CLASS A QUEUE OFFSET IS 0
         IC    R15,N2CNVCLS(R15)   GET CLASS QUEUE OFFSET
         SLL   R15,1               MULT BY 2 FOR 2-4 BYTE HDRS    SPR2
         LA    R15,JOTCLSQ(R15)    LOCATE CLASS QUEUE IN JOT
         SLR   R14,R14             CLEAR REG
         ICM   R14,15,0(R15)       GET OFFSET   TO Q OF WORK JOES  SPR2
         BZ    N2SP2RMT             BR IF NO QUEUE; DS MAY BE RMT  SPR2
*        SLL   R14,2               CALC ACTUAL JOE OFFSET W/IN JOT SPR2
         AR    R14,R9              PT TO 1ST WORK JOE
         ST    R14,N2WRKJOE        SAVE ADDR OF WORK JOE
*  NOW HAVE PTR TO 1ST WORK JOE ON 'DHCLASS' CLASS QUEUE
N2HSSTR2 DS    0H                  ENTRY LABEL FOR REMOTE SEARCH   SPR2
         SLR   R2,R2               CLEAR REG
         IC    R2,JHCPYCT          GET NO. JOB COPIES (= ORIGINAL
*                                   NO. WORK JOES FOR THIS DS GROUP)
         B     N2HSCKJQ            GO ANALYZE JOE
         SPACE 2
*  MAIN LOOP FOR FINDING ANY & ALL WORK AND CHAR JOES FOR THIS DS
N2HSLOOP DS    0H
         L     R14,N2WRKJOE        GET CURRENT WORK JOE PTR
         SLR   R15,R15             CLEAR REG
         ICM   R15,7,JOENEXT+1     GET OFFSET   TO NEXT WORK JOE   SPR2
         BZ    N2SP2RMT             BR IF NO MORE; GO LOOK IN HQRS
*        SLL   R15,2               CALC ACTUAL OFFSET              SPR2
         LA    R14,0(R15,R9)       PT TO NEXT WORK JOE
         ST    R14,N2WRKJOE        SAVE NEW WORK JOE PTR
         SPACE 1
N2HSCKJQ DS    0H     DETERMINE IF THIS JOE BELONGS TO CURRENT JOB
         L     R15,N2CURJQE        GET PTR TO CURRENT JQE
*    THIS RECORD DELETED BY FIX FOR JES2 APAR OZ20010              *CKP
         S     R15,N2$JOBQ         CONVERT TO OFFSET               *CKP
         LA    R15,JQELNGTH(R15)   ALLOW FOR DUMMY JQE AT START
*        SRL   R15,2               MAKE IT OFFSET/4                SPR2
*        CH    R15,JOEJQE          COMPARE W/ JQE PTR IN JOE       SPR2
         CLM   R15,7,JOEJQEB       COMPARE W/ JQE PTR IN JOE       SPR2
         BNE   N2HSLOOP            WRONG JOE IF NOT EQ, SO CONT SCAN
*  FALL THRU TO HERE IFF JOE BELONGS TO CURRENT JOB
         SPACE 1
*  LOCATE CHARACTERISTICS JOE
         L     R15,JOECHAR         GET OFFSET   TO CHAR JOE        SPR2
*        N     R15,=F'65535'       CLEAR LEFT HALFWORD             SPR2
         LA    R15,0(R15)          CLEAR HIGH ORDER BYTE           SPR2
*        SLL   R15,2               CALC ACTUAL OFFSET              SPR2
         AR    R15,R9              PT TO CHAR JOE
         ST    R15,N2CHRJOE        SAVE PTR TO CHAR JOE
         SPACE 1
*  MATCH JOE CHARACTERISTICS AGAINST PDDB
         CLC   PDBCLASS,JOEPDBCL   TEST SYSOUT CLASS
         BNE   N2HSLOOP            IF ANY MISMATCH, THEN REJECT JOE
         CLC   JOEDEST,PDBDEST     DATA SET
         BNE   N2HSLOOP             ROUTING
         LR    R14,R15             SWITCH ADDRESSABILITY TO CHAR JOE
         CLC   JOEFORM(12),PDBFORMS  CHECK FORMS, FCB,
         BNE   N2HSLOOP                AND UCS
         CLC   JOEFLASH,PDBFLASH   3800 FORMS
         BNE   N2HSLOOP             OVERLAY
         TM    PDBFLAG2,PDB2BRST   VERIFY
         BZ    *+16                 THAT
         TM    JOECFLAG,$JOEBRST     PDDB
         BZ    N2HSLOOP               BURSTER
         B     *+12                    SPECIFICATION
         TM    JOECFLAG,$JOEBRST        MATCHES
         BO    N2HSLOOP                  CHAR JOE
         CLC   JOEWTRID,PDBWTRID   WRITER
         BNE   N2HSLOOP             ID
*  NOW KNOW THESE JOES BELONG TO THIS DS
         SPACE 1
*  DETERMINE WHETHER CHKPT JOE EXISTS
         L     R14,N2WRKJOE        GET WORK JOE PTR
         TM    N2FLAGS,N2DMDSET    ALREADY FOUND DEMAND SETUP GROUP?
         BO    N2HSGCKP             IF SO, WE DONT NEED CHKPT JOE
         TM    JOEFLAG2,$JOEDMND   IS THIS DS PART OF DMD SETUP GRP?
         BZ    N2HSGCKP             NO, THEN GO FIND CHKPT JOE
         OI    N2FLAGS,N2DMDSET    INDICATE JOB HAS DEMAND SETUP GRP
         SPACE 1
N2HSGCKP DS    0H
         SR    R15,R15             CLEAR REG
         ICM   R15,7,JOECKPT+1     GET CHKPT JOE OFFSET            SPR2
         BZ    N2HSACPT             NONE, THEN ACCEPT THIS DEST OF
*                                    THIS DS
*        SLL   R15,2               ACTUAL OFFSET                   SPR2
         AR    R15,R9              ACTUAL PTR
         TM    N2FLAGS,N2DMDSET    TEST FOR DMD SETUP GROUP IN JOB
         BZ    N2HSPCKJ             NONE, GO ANALYZE CHKPT JOE
         CLC   PDBCLASS,JHMSGCLS   IS THIS DS PART OF DMD SET GRP?
         BNE   N2HSPCKJ             NOT UNLESS CLASS=MSGCLASS
         CLC   PDBDEST,=F'0'       ROUTING MUST ALSO BE MSG CLS DEST
         BNE   N2HSPCKJ             BR IF DEST WRONG
         ST    R15,N2CKPJOE        SAVE PTR TO CHKPT JOE
         SPACE 1
*  HAVE CHKPT JOE - DETERMINE WHETHER THIS PDDB ALREADY PROCESSED
N2HSPCKJ DS    0H
         LR    R14,R15             MAKE CHKPT JOE ADDRESSABLE
         L     R15,N2CURPDB        GET CURRENT PDDB PTR
         S     R15,N2CURIOT        CONVERT TO OFFSET IN IOT
         CH    R15,JOEPDDB         DETERMINE POSITION OF CURRENT
*                                   PDDB RELATIVE TO JOE PDDB
         BNL   N2HSACPT              DS NOT PROCESSED IF EQ TO OR GRTR
*                                     THAN CURRENT, SO BR
         BCT   R2,N2HSLOOP         LOOP 'JOB COPY' TIMES
         DROP  R9,R14              KILL JOT & JOE ADDRESSABILITY
         SPACE 1
*  DS NOT IN JOT, SO LOOK FOR IT AMONG HELD DS'S
N2HSHQTE DS    0H                  ENTRY TO HQT PROCESSING
*        L     R9,N2CURJCT         GET JCT PTR
*        USING JCTDSECT,R9         ESTABLISH JCT ADDRESSABILITY
*        ICM   R9,15,JCTHQT        GET PTR TO HELD DS QUEUE
*        BZ    N2HSNULL             NO QUEUE ===> DS NOT HELD
*2HSHQLP DS    0H                  LOOP FOR SCANNING ALL HQTS
*        USING HQTDSECT,R9         DROP JCT & ADD HQT ADDRESSABILITY
*        LH    R3,HQTLENG          GET LENGTH OF HQT
*        S     R3,=A(HQTHQR-HQTDSECT)   REMOVE ALL EXCEPT HQRS
*        LA    R4,HQTHQR           PT TO 1ST HQR
*        USING HQRDSECT,R4         ESTABLISH HQR ADDRESSABILITY
*        AR    R3,R4               PT TO END OF HQT
*        LA    R2,HQRLENG          SET HQR LENGTH AS INCREMENT
*        SR    R3,R2               PT TO LAST HQR
*        SPACE 1
*2HSHRLP DS    0H                  LOOP FOR SCANNING HQRS W/IN HQT
*        CLC   PDBDSKEY,HQRPDDB+PDBDSKEY-PDBDSECT  COMPARE DS KEYS
*        BL    N2HSNULL             PDDB LO ===> DS NOT HELD; GO
*        BE    N2HSHREQ             HQR FOUND, GO CHK VALIDITY
*        BXLE  R4,R2,N2HSHRLP       OTHERWISE, LOOP THRU WHOLE HQT
*  FALL THRU AFTER CHECKING ALL HQRS IN THIS HQT
*        SPACE 1
*        ICM   R9,15,HQTHQT        GET PTR TO NEXT HQT
*        BNZ   N2HSHRLP             AND LOOP IF PRESENT
*        B     N2HSNULL             OTHERWISE, DS NOT IN HQRS
*        SPACE 1
*2HSHREQ DS    0H    COME HERE WHEN PDDB FOUND IN HQRS
*        TM    HQRSTAT,HQRUNHLD+HQRCAN   TEST VALIDITY OF HQR
**       BZ    N2HSACPT            DS IS HELD IF HQR OK, SO ACCEPT
*        SPACE 1
*  FALL THRU HERE WHEN DS NEITHER IN JOT NOR IN HQRS
*        DROP  R4,R9               KILL HQR AND HQT ADDRESSABILITY
         SPACE 2
*  THIS ROUTING OF THIS DS ALREADY PROCESSED COMPLETELY - SET NULL
N2HSNULL TM    N2FLAGS,N2HSACC1    TEST FOR PREVIOUS ACCTED FLAG FIX057
         BO    N2MDSPDB            YES LEAVE ALONE               FIX057
         OI    DHFLGS1,DH1NULL     SET ALREADY PROCESSED INDIC   FIX057
         B     N2MDSPDB            DON'T SET THIS ROUTING
         SPACE 1
*  AT LEAST 1 COPY OF THIS ROUTING OF THIS DS REMAINS TO BE PROC'D
N2HSACPT NI    DHFLGS1,255-DH1NULL TURN OFF ALREADY PROCESSED INDIC
         OI    N2FLAGS,N2HSACC1    SET ONE ACCEPTED INDICATOR    FIX057
         SPACE 1
N2ENDHSP DS    0H                  END OF HRDCPY STATUS PROCESSING
         SPACE 3
         L     R1,PDBDEST          OUTPUT ROUTING                  SPR2
         BAL   R14,N2RTECNV        CONVERT TO MNEMONIC
         MVC   0(L'DHNODE1,R6),N2NODE  SET DHNODE1,2,3,4
         MVC   L'DHNODE1(L'DHRMT1,R6),N2ROUTE   SET DHRMT1,2,3,4
N2MDSPDB DS    0H                  FIND ALL PDDB'S FOR THIS DS
         TM    PDBFLAG1,PDB1MDES    CHECK FOR MULTI DEST
         BZ    N2DESEXT            ALL DONE IF NO
         BAL   R14,N2OPDDB          GET NEXT PDDB
         LTR   R5,R15              SEE IF ANY MORE PDDBS
         BZ    N2DESEXT            DONE IF NO
         CLC   N2DSKEY,PDBDSKEY    CHECK IF SAME DS
         BNE   N2DESEXT            GO IF NOT
         CLC   0(8,R6),=CL8' '     TEST FOR NULL ROUTING
         BE    *+8                  AND SKIP HDR PTR UPDATING    FIX072
         LA    R6,L'DHRMT1+L'DHNODE1(R6)   NEXT DS HDR RMT
         BCT   R7,N2DESTLP
         DROP  R5
N2DESEXT DS    0H                  ALL DONE WITH DEST THIS DS
         MVC   N2CURPDB,N2PDBSAV RESTORE PDDB AND IOT PTRS
         MVC   N2CURIOT,N2IOTSAV
         SPACE 3
N2OBEGIO BAL   R14,N2OREAD         BEGIN READ OF 1ST BUFFER
         B     N2JNEXIT            NORMAL RETURN TO CALLER
         SPACE 3
N2SP2RMT DS    0H                                                  SPR2
         USING JOTDSECT,R9         SET DSECT ADDRESSING            SPR2
         TM    N2FLAGS,N2R2RMT     HAVE WE DONE REMOTE SEARCH      SPR2
         BO    N2RMTDNE            YES. DS REALLY NOT THERE        SPR2
         OI    N2FLAGS,N2R2RMT     NO. SET FLAG AND START RMT SRCH SPR2
         SR    R15,R15             CLEAR WORK REG                  SPR2
         IC    R15,DHCLASS         GET CLASS OF DS                 SPR2
         SL    R15,=A(C'A')        CLASS A QUEUE OFFSET IS 0       SPR2
         IC    R15,N2CNVCLS(R15)   GET CLASS QUEUE OFFSET          SPR2
         SLL   R15,1               MULT BY 2 FOR 2-4 BYTE HDRS     SPR2
         LA    R15,JOTCLSQ(R15)    LOCATE CLASS QUEUE IN JOT       SPR2
         SLR   R14,R14             CLEAR REG                       SPR2
         ICM   R14,15,4(R15)       GET OFFSET   TO Q OF WORK JOES  SPR2
         BZ    N2HSNULL            BR IF NO QUEUE; DS NOT THERE    SPR2
         AR    R14,R9              PT TO 1ST WORK JOE              SPR2
         ST    R14,N2WRKJOE        SAVE ADDR OF WORK JOE           SPR2
*  NOW HAVE PTR TO 1ST WORK JOE ON 'DHCLASS' CLASS QUEUE REMOTE    SPR2
         B     N2HSSTR2            START PROCESS ALL OVER          SPR2
         SPACE
N2RMTDNE DS    0H                                                  SPR2
         NI    N2FLAGS,255-N2R2RMT RESET FLAG BIT                  SPR2
         B     N2HSNULL            BR IF NOT THERE                 SPR2
         DROP  R9                                                  SPR2
         TITLE 'QPGET FUNCTION'
*****************************************************
* QPGET PROCESSING                                  *
*                                                   *
*  N2CURBUF IS USED TO POINT TO EITHER DATA SET OR  *
*        JCL BAT ENTRY THAT POINTS TO A BUFFER BEING*
*        PROCESSED.                                 *
*  N2CURREC  POINTS TO LAST RECORD PROCESSED WITHIN *
*        N2CURBUF OR ZERO IF 1ST RECORD WITHIN BUFFER
*        IS TO BE PROCESSED.  IT IS UPDATED TO CURRENT
*        RECORD.                                    *
*  N2JCLBUF POINTS TO JCL BAT ENTRY FOR CURRENT JCL *
*        BUFFER BEING PROCESSED.  IT IS THE SAME AS *
*        N2CURBUF IF JCL DATA SET IS CURRENTLY BEING*
*        PROCESSED.                                 *
*  N2JCLREC IS SIMILAR TO N2CURREC FOR JCL          *
*        PROCESSING.                                *
*                                                   *
*  R6 IS USED TO POINT TO  CURRENT BAT ENTRY OF     *
*        BUFFER BEING PROCESSED.                    *
*                                                   *
*****************************************************
N2GET    DS    0H
         CLI   QPTYPE,QPTJCL       IF JCL REQUEST
         BNE   N2NOJCL
         MVC   N2CURBUF,N2JCLBUF   SET CURRENT BUF TO JCL
         MVC   N2CURREC,N2JCLREC   SET CURRENT REC FOR JCL
         SPACE 3
N2NOJCL  DS    0H                  PROCESS NEXT RECORD
         L     R6,N2CURBUF         PICK UP CURRENT BAT ENTRY
         USING DSBDSECT,R6
         ICM   R5,15,N2CURREC      PICK UP PREV REC PTR
         BNZ   N2NOREC0            GO IF NOT 1ST REC IN BUFFER
         TM    DSBSTATE,BFRRDY     CHECK IF BUFFER READY TO PROCESS
         BO    N2BFRDY             GO IF READY
         WAIT  ECB=CTSPECBA         WAIT FOR I/O
         XC    CTSPECBA,CTSPECBA     CLEAR ECB
         B     N2NOJCL        MAKE SURE COMPLETED THIS REQUEST
         SPACE 3
N2BFRDY  DS    0H                  BUFFER READY-PROCESS 1ST RECORD
* CHECK IF BUFFER ERROR OR HDBKEY MISMATCH
         TM    DSBSTATE,BFRERR     CHECK FOR GOOD READ
         BO    N2GERR1
         SPACE 2
N2GIOOK  DS    0H                  NO ERROR ON READ
         L     R5,DSBBFR           POINT TO CURRENT BUFFER
         S     R5,=A(BUFSTART-BUFDSECT)  ADJ FOR MISSING IOB
         USING BUFDSECT,R5
         L     R1,N2CURJCT         VERIFY JOB KEY
         USING JCTDSECT,R1
         CLC   JCTJBKEY,HDBJBKEY   IN JCT MATCHES BUFFER JOB KEY
         BNE   N2GERR1             ERROR IF NOT
         DROP R1
         CLI   QPTYPE,QPTJCL       CHK IF JCL DATA SET
         BNE   N2GIOPDB            CHK PDDB DS KEY IF NOT
         CLC   HDBPDDBK,=H'1'      JCL KEY IS 1
         BNE   N2GERR1             ERROR IF NOT EQ
         B     N2GIOCK             CHKS OK
* FOR NON-JCL KEY CHECK CURPDB KEY AGAINST BUFFER
*        FOR JCL, CURPDB MAY POINT TO SYSIN
N2GIOPDB DS    0H
         L     R1,N2CURPDB         VERIFY DS KEY IN PDDB
         USING PDBDSECT,R1
         CLC   PDBDSKEY,HDBPDDBK        MATCHES BUFFER DS KEY
         BNE   N2GERR1
         DROP  R1
N2GIOCK  DS    0H
         LA    R5,HDBSTART         1ST RECORD IN BUFFER
         DROP R5
         B     N2REC0
N2NOREC0 DS    0H                  HERE IF NOT 1ST REC IN BUFFER
* FOLLOWING CODE ASSUMES LRCTLENG IS TEXT LENGTH
* AND DOES NOT INCLUDE LRC CTL BYTES OR CHANNEL CTL CHAR
         USING LRCDSECT,R5
         TM    LRCFLAG1,LRC1SPAN   CHECK FOR SPANNED RECORDS
         BZ    N2NSPAN1
         LH    R0,LRCSEGL          PICK UP SEGMENT LENGTH
         TM    LRCFLAG1,LRC1SBGN   CHK IF FIRST SEGMENT
         BZ    *+8
         LA    R5,2(R5)            SEG 1 IS 2 BYTES LONGER
         LA    R5,4(R5)            CTL BYTES LENGTH
         AR    R5,R0               ADD TEXT LENGTH
         B     N2REC0              GO PROCESS RECORD
N2NSPAN1 DS    0H                  GET NEXT UNSPANNED REC
         SR    R0,R0
         IC    R0,LRCTLENG         PREV REC TEXT LENGTH
         TM    LRCFLAG1,LRC1CCTL   CHK IF CHAN CTL
         BZ    N2GNOCC             GO IF NO
         LA    R5,1(R5)            ALLOW FOR EXTRA CHAR
N2GNOCC  DS    0H
         AR    R5,R0               POINT TO NEXT REC
         LA    R5,3(R5)            INCLUDE LRC CTL LENGTH
N2REC0   DS    0H
         ST    R5,N2CURREC         SAVE CUREC PTR
         CLI   QPTYPE,QPTJCL       IF JCL REQUEST
         BNE   N2GNJCL2
         MVC   N2JCLREC,N2CURREC   SAVE CURRENT AS JCL CURRENT
N2GNJCL2 DS    0H
         CLI   LRCTLENG,X'FF'      CHECK IF EOF THIS BUFFER
         BNE   N2NEOB                 GO IF NOT END
         DROP R5
         L     R5,DSBBFR           POINT TO BUFFER START
         S     R5,=A(BUFSTART-BUFDSECT)   ADJ FOR MISSING IOB
         USING BUFDSECT,R5
         ICM   R5,15,HDBNXTRK      CHK IF ANY MORE BUFFERS
         BNZ   N2GNEOF             GO IF MORE BUFFERS
         DROP  R5
         L     R14,QPGEOF          RETURN TO EOF EXIT
         #RETURN (2,12),RC=0
         SPACE 3
* NEED TO GET NEXT BUFFER IN CHAIN
N2GNEOF  DS    0H
         MVI   DSBSTATE,BFRAVL     MARK PREV BUFFER AVAIL
         CLI   QPTYPE,QPTJCL       CHK IF JCL
         BNE   N2GPSTD             POST DBF
         POST  CTQECBJB,C'JBF'     JCL BUFFER AVAIL
         B     N2GSKDP             SKIP DATA POST
N2GPSTD  DS    0H
         POST  CTQECBDB,C'DBF'     LET SPIO KNOW ABOUT FREE BUFFER
N2GSKDP  DS    0H
         XC    N2CURREC,N2CURREC   SET TO 1ST REC IN BFR
         LA    R6,4(R6)            NEXT BAT BUFFER PTR
         CLI   QPTYPE,QPTJCL       CHK IF JCL RECORD
         BNE   N2GNJCL3
         XC    N2JCLREC,N2JCLREC   IF JCL SET TO 1ST REC IN BFR
         C     R6,CTJCLBND         CHK IF AT BOTTOM OF BAT
         BNH   N2GNJBND            GO IF NOT AT END
         L     R6,CTJCLBFR         POINT TO BAT START
N2GNJBND DS    0H
         ST    R6,N2JCLBUF         SAVE NEW BFR PTR
         ST    R6,N2CURBUF         ALSO CURRENT
         B     N2NOJCL             GO PROCESS NEW BUFFER
         SPACE 3
N2GNJCL3 DS    0H                  DS BFR AT END OF BAT
         C     R6,CTDSBRND         CHK IF AT BOTTOM OF BAT
         BNH   N2GNBND             GO IF NOT
         L     R6,CTDSBFRS         ELSE BACK TO TOP OF BAT
N2GNBND  DS    0H
         ST    R6,N2CURBUF         SAVE NEW BFR BAT PTR
         B     N2NOJCL             GO PROCESS NEW BFR
         DROP  R6
         SPACE 3
*  HAVE RECORD TO PROCESS POINTED TO BY CURREC
N2NEOB   DS    0H                  PROCESS CURREC
* CHECK RECORD FOR SPECIAL PROCESSING
* NEED TO CHECK RECORD FOR SYSIN DEFINING RECORD.
* HASPRDR SETS LRC1INUL AND LRC1ONUL BITS ON FOR SYSIN CTL REC.
*  TEXT + 2 IS DSKEY OF SYSIN DATA SET.
*  TEXT + 4 IS MTTR OF SYSIN DATA SET
         SPACE 1
         L     R5,N2CURREC         POINT TO CURRENT RECORD
         USING LRCDSECT,R5
         LA    R1,LRCTEXT          START OF TEXT IF NO CARR CTL
         TM    LRCFLAG1,LRC1CCTL
         BZ    N2NOCC3
         LA    R1,1(R1)            SKIP OVER CC IF PRESENT
N2NOCC3  DS    0H
*  R1 NOW USED TO CHECK JCL CARD
         CLI   QPTYPE,QPTJCL       IF JCL DATA SET
         BNE   N2GMOVE             GO MOVE RECORD IF NOT JCL
         CLC   N2DELMSG,0(R1)      CHK FOR NULL JOB DELETED BY OPER
         BE    N2GET               IGNORE IF YES
         TM    LRCFLAG1,LRC1INUL+LRC1ONUL  BOTH ON IF SYSIN DEFINE
         BNO   N2GMOVE
         MVC   N2DSKEY,2(R1)       SAVE DSKEY FROM CTL REC
         MVC   N2SINKEY,4(R1)      SAVE MTTR
         L     R14,QPGIDS          IDS EXIT
         #RETURN (0,12),RC=0
         EJECT
*  MOVE RECORD TO USERS AREA IN VARIABLE LENGTH FORMAT
*        THIS ROUTINE MUST ALSO MAKE SURE THE RECORD FORMAT FOR
*        SYSOUT RECORDS MATCHES THE CHARACTERISTICS SPECIFIED
*        IN THE PDDB FOR ASA OR MACH CTL.  IF THE LRC FOR THE
*        RECORD DOES NOT MATCH THE PDDB, THE FLAG BYTE FROM
*        THE LRC WILL BE USED AS A MACH CTL CHAR.  THE HASPPRPU
*        PROCESSING IN HASP OR JES2 WILL CORRECT THE CODE IF
*        IT IS NOT VALID.
         SPACE 2
N2GMOVE  DS    0H
         TM    LRCFLAG1,LRC1SPAN   CHK IF SPANNED RECORD
         BO    N2SPAN1
         L     R7,QPGRECD          CALLERS RECORD ADDRESS
         USING HJRDSECT,R7
         SR    R1,R1
         IC    R1,LRCTLENG         TEXT LENGTH (EXCLUDES CARRIAGE CTL)
         SR    R15,R15             RDW LENGTH ADJUST
         LA    R14,HJRTEXT         TEXT DESTINATION
         MVC   HJRFLGS1(2),LRCFLAG1  FLAG+UNTRUNCATED TEXT LENGTH
         TM    LRCFLAG1,LRC1CCTL    CHK FOR CARRIAGE CTL
         BO    N2GCCTL             R1=LENGTH-1 IF CTL CHAR
         BCTR  R1,0                LENGTH-1 FOR MOVE
         CLI   QPTYPE,QPTSYOUT     IF SYSOUT, VERIFY CARR CTL
         BNE   N2GCCTL
         L     R6,N2CURPDB         NEED TO CHK RECFM FOR ASA OR MACH
         USING PDBDSECT,R6
         TM    PDBRECFM,X'06'      ASA OR MACH
         BZ    N2GCCTL             GO IF NOT REQD
         DROP  R6
         LA    R14,1(R14)          ALLOW ROOM IN DEST FOR CTL
         LA    R15,1               RDW LENGTH INCREASED BY 1
         MVC   HJRCCTL,LRCFLAG1    USE FLAG AS CTL CHAR
         OC    HJRCCTL,HJRCCTL     CHK FOR ZERO
         BNZ   N2GCCTL             USE IF NON-ZERO
         MVI   HJRCCTL,X'09'       USE SPACE AFTER PRINT MACH CTL
*              HASPPRPU WILL CORRECT FOR PUNCH OR ASA
N2GCCTL   DS    0H
         EX    R1,N2EXMVC
         LA    R1,7(R1,R15)        ADD 1 + RDW LEN +FLAG + LRECL
         STCM  R1,3,HJRLENG        LL TO RDW
         XC    HJRSPTYP,HJRSPTYP   CLEAR REST OF RDW
N2GMHOOK DS    0H                  LABEL FOR TEST
         B     N2JNEXIT            GO TO NORMAL EXIT
         SPACE 3
* MOVE SPANNED RECORD SEGMENT TO USERS AREA
N2SPAN1  DS    0H
         TM    LRCFLAG1,LRC1SBGN   CHK IF FIRST SEGMENT
         BZ    N2NBGN1             GO IF NOT
         L     R7,QPGRECD          PICK UP CALLERS REC ADDR
         LA    R6,HJRTEXT          TEXT ADDR
         ST    R6,N2SPANA          SAVE TO ADDR
         XC    HJRFLGS1(2),HJRFLGS1  ZERO FLAGS AND LRECL
         LH    R1,LRCSRECL         PICK UP TOTAL TEXT LENGTH
         LA    R1,6(R1)            ADD RDW + FLAG + LRECL
         STH   R1,HJRLENG          RDW LRECL
         XC    HJRSPTYP,HJRSPTYP   CLEAR REST OF RDW
         C     R1,=A(32756)        VALIDATE LENGTH
         BH    N2GERR1
         LA    R14,LRCSFTXT        1ST TEXT BYTE
         B     N2BGN1
         SPACE 2
N2NBGN1  DS    0H                  NOT 1ST SEGMENT
         LA    R14,LRCSTEXT        1ST TEXT BYTE
N2BGN1   DS    0H
         LH    R15,LRCSEGL         TEXT LENGTH
         LR    R7,R15
         L     R6,N2SPANA          PICK UP TO ADDR
         MVCL  R6,R14              MOVE RECORD
         TM    LRCFLAG1,LRC1SEND   CHK IF END OF RECORD
         BO    N2JNEXIT            RETURN TO CALLER IF YES
         AR    R6,R7               UPDATE TO ADDRESS
         ST    R6,N2SPANA
         B     N2GET               REENTER QPGET FOR NEXT SEGMENT
         SPACE 2
N2SPANA  DC    A(0)                NEXT ADDR IN CALLER AREA FOR MOVE
         SPACE 2
N2EXMVC  MVC   0(0,R14),LRCTEXT    TEXT + CARRIAGE CTL IF LR1CCTL SET
         SPACE 2
         DROP  R5
         DROP  R7
         TITLE 'MISCELLANEOUS SUBROUTINES'
*****************************************************
* INVALIDATE DATA SET OR JCL BUFFERS                *
*        R1 = PTR TO BAT START                      *
*        R0 = PTR TO BAT END                        *
*****************************************************
N2BFCLR  DS    0H                  LOOP TO CLEAR D.S. BUFFERS
         USING DSBDSECT,R1
         CR    R1,R0               END OF BUFFERS?
         BHR   R14                 GO IF YES
         MVI   DSBSTATE,BFRAVL     MAKE BUFFER AVAIL
         LA    R1,4(R1)
         B     N2BFCLR
         DROP  R1
         EJECT
*****************************************************
*  SUBROUTINE TO LOCATE NEXT PDDB                   *
*       AT END, R15 POINTS TO PDDB OR ZERO          *
*****************************************************
N2OPDDB  DS    0H
         L     R1,N2CURIOT         IN CASE CURPDB VALID
         ICM   R15,15,N2CURPDB      CURRENT PDDB
         USING PDBDSECT,R15
         BNZ   N2PDBNXT            GO IF CONTINUE SEARCH FROM CURRENT
*  NEED TO BEGIN AT 1ST PDDB FOR THIS JOB
         L     R1,N2JCTIOT         POINT TO 1ST IOT
         USING IOTDSECT,R1
N2PDBLP2 DS    0H                  LOOP THRU IOTS
         ST    R1,N2CURIOT         SAVE AS CURRENT
         LH    R15,N2$PDDB         OFFSET TO 1ST PDDB
         LA    R15,0(R15,R1)       ABSOLUTE ADDR OF PDDB
N2PDBEXT DS    0H                  EXIT WITH NEW PDDB
         ST    R15,N2CURPDB         SAVE NEW CURRENT PDDB
         BR    R14                 EXIT WITH NEXT PDDB
N2PDBNXT DS    0H
         LA    R15,PDBLENG(R15)      NEXT PDDB
         L     R0,IOTPDDBP         OFFSET BEYOND LAST PDDB
         AR    R0,R1               ACTUAL ADDR OF END
         CR    R15,R0              CHECK IF IOT END
         BL    N2PDBEXT            CONTINUE IF NOT END OF IOT
         ICM   R1,15,IOTIOT        ELSE POINT TO NEXT IOT
         BNZ   N2PDBLP2                 IF NOT END OF IOTS
         XC    N2CURPDB,N2CURPDB   INDICATE NO VALID CURRENT PDDB
*        END OF PDDBS
         SR    R15,R15             INDICATE PDDB NOT FOUND
         BR    R14
         DROP  R1
         DROP  R15
         EJECT
*****************************************************
* READ 1ST RECORD DURING QPOPEN                     *
*****************************************************
N2OREAD  DS    0H
         ST    R14,N2ORSAV         SAVE RETURN ADDR
         TM    QPOOPTN,QPONOIO     CHECK IF OPEN W/O READ
         BO    N2OREADX
         CLI   QPTYPE,QPTJCL       ELSE IF JCL OPEN
         BNE   N2ORDDS
         L     R1,CTJCLBFR         START OF JCL BAT
         L     R0,CTJCLBND         END OF JCL BAT
         BAL   R14,N2BFCLR         GO PURGE JCL BFRS
         MVC   N2JCLBUF,CTJCLBFR   CURRENT JCL BUFFER = 1ST
         XC    N2JCLREC,N2JCLREC   1ST REC TO START OF BUFFER
         B     N2ORDDS2            CONTINUE WITH READ
N2ORDDS  DS    0H                  HERE IF NOT JCL OPEN
N2ORDDS2 DS    0H                  PURGE DATA SET BUFFERS
         L     R1,CTDSBFRS         START OF DS BFRS BAT
         L     R0,CTDSBRND         END OF DS BAT
         BAL   R14,N2BFCLR         GO PURGE DS BFRS
         MVC   N2CURBUF,CTDSBFRS   SET CURRENT DS BFR TO 1ST
         XC    N2CURREC,N2CURREC   INDICATE 1ST REC IN BUFFER
         XC    CTSPECBA,CTSPECBA     CLEAR ECB
         CLI   QPTYPE,QPTJCL       CHK FOR TYPE POST
         BNE   N2ORDDB
         POST  CTQECBJW,C'JWK'     JCL REQUEST
         B     N2OREADX
N2ORDDB  DS    0H
         POST  CTQECBDW,C'DWK'     ASK SPIO TO START READ
*  NOTE : QPGET WILL WAIT ON THIS READ
N2OREADX DS    0H                  EXIT
         L     R14,N2ORSAV         RESTORE RETURN
         BR    R14
N2ORSAV  DC    A(0)                RETURN ADDR
         EJECT
* USE N2$ROUTE TABLE PASSED BY N2QI FOR SPECIAL ROUTING
* IF ROUTE CODE IS NOT IN TABLE, USE DEFAULT ROUTING (NXXRXXX, RXXX,
*   OR UXXX).
* N2$SCAT PASSED BY N2QI CONTAINS LIST OF PUNCH CLASSES
*
*        JES2/SP2 RELEASE 2 ROUTE CODES ARE 2 BYTE BINARY NODE/REMOTE
*    NNNNUUUU INDICATES LOCAL ROUTING ON NODE NNNN
*    NNNNXXXX INDICATES REMOTE DESTINATION OF XX ON NODE NN
*    00000000 INDICATES INDIRECT ROUTING (USE DEST IN JQE)
*    0000XXXX INDICATES ROUTING TO SPECIFIC LOCAL DEV (ORIG NODE ONLY)
         SPACE 2
N2RTECNV DS    0H
         LTR   R0,R1               CHK FOR INDIRECT ROUTE
         BNZ   N2RTCONV             NO, GO TO ROUTE CODE ANALYSIS
         SPACE 1
*        NEED TO USE JQE ROUTE CODE
*        ROUTE CODE = 0000 INDICATES USE JQE ROUTING
N2RTIND  DS    0H
         L     R4,N2CURJQE         CURRENT JQE PTR
         USING JQEDSECT,R4
         ICM   R15,15,N2CURPDB      PICK PDDB
         BZ    N2RTERR1            SHOULD NOT OCCUR
         USING PDBDSECT,R15
         L     R1,=V(N2$SCAT)      NEED TO SEE IF PUNCH
N2RTLP1  DS    0H
         CLI   0(R1),X'FF'         TABLE END
         BE    N2RTPRT             IF YES, MUST BE PRINT
         CLC   PDBCLASS,0(R1)      CHK IF THIS PUNCH CLASS
         BE    N2RTPUN             USE JQE PUNCH IF YES
         LA    R1,1(R1)
         B     N2RTLP1
         SPACE 2
N2RTPRT  DS    0H                  USE JQE PRINT ROUTE
         L     R0,JQEPRTRT                                         SPR2
         B     N2RTJQE
N2RTPUN  DS    0H                  USE PUNCH JQE ROUTE
         L     R0,JQEPUNRT                                         SPR2
N2RTJQE  DS    0H
         LTR   R0,R0
         BZ    N2RTERR1            ERROR IF JQE INDIRECT ROUTING
         SPACE 3
N2RTCONV DS    0H                  CONVERT DEVICE PORTION OF ROUTE CODE
         CLM   R0,3,=X'0000'       TEST FOR LOCAL ROUTING          SPR2
         BE    N2RTLOC              AND BR IF SO
         L     R1,=V(N2$ROUTE)     PTR TO SPECIAL CODE TABLE FOR RMTS
N2RTLP2  DS    0H                  SEARCH FOR ROUTE CODE
         CLI   0(R1),X'FF'         TABLE END?
         BE    N2RTDEF             YES, USE DEFAULT
         CH    R0,0(R1)            CHECK CODE VS TABLE
         BE    N2RTTBL             USE TABLE ENTRY
         LA    R1,10(R1)           NEXT TABLE
         B     N2RTLP2
         SPACE 3
N2RTTBL  DS    0H                  USE TABLE ROUTE MNEMONIC
         MVC   N2ROUTE,2(R1)
         B     N2RTNODE            GO CONVERT NODE NO.
         SPACE 2
N2RTDEF  DS    0H                  USE DEFAULT ROUTE CODE
*                                  MUST BE RMTNNN=NNN
         LR    R1,R0               SAVE ROUTE CODE IN R1
         N     R0,=F'65535'        CLEAR SYS ID                    SPR2
         CVD   R0,N2CNVWK
         UNPK  N2CNVWK(3),N2CNVWK  LIMIT OF 3 NNN
         OI    N2CNVWK+2,X'F0'
         MVC   N2CNVWK+3(4),=CL4' '   SHIFT OUT LEADING ZEROES
         CLI   N2CNVWK,C'0'        SHIFT OUT UP TO 2 LEADING ZEROES
         BNE   N2RTMVE
         MVC   N2CNVWK(4),N2CNVWK+1
         CLI   N2CNVWK,C'0'
         BNE   N2RTMVE
         MVC   N2CNVWK(3),N2CNVWK+1
         SPACE 2
N2RTMVE  DS    0H                  MOVE DEV ID INTO ROUTE
         CLM   R1,12,=X'0000'      TEST FOR NODE = 0               SPR2
         BNE   *+12                 REMOTE DEV IF NOT
         MVI   N2ROUTE,C'U'         ELSE SPECIAL LOCAL ROUTING
         B     *+8                   AND GO AROUND TO COMMON CODE
         MVI   N2ROUTE,C'R'        SET RMT INDICATOR
         MVC   N2ROUTE+1(7),N2CNVWK  MOVE NS AND BLANKS
         LR    R0,R1               RESTORE ROUTE CODE TO R0
         SPACE 3
N2RTNODE DS    0H                  CONVERT NODE NO.
         SRL   R0,16               SHIFT OUT RMT NO.               SPR2
N2RTSP2  DS    0H                  EXEC NODE ENTRY POINT           SPR2
         MVC   N2NODE,=CL8' '      INITIALIZE RESULT FIELD
         CLM   R0,1,CTORGNOD       IS THIS ROUT TO OWNNODE         SPR2
         BE    N2RTEXT             YES,LEAVE AS BLANKS             SPR2
         LTR   R0,R0               TEST FOR NODE = 0
         BZ    N2RTEXT              LEAVE NODE NAME AS BLANKS IF SO
         CVD   R0,N2CNVWK          CONVERT NODE
         UNPK  N2CNVWK(2),N2CNVWK   NO. TO DECIMAL
         OI    N2CNVWK+1,X'F0'       AND INSURE IT'S PRINTABLE
         MVI   N2CNVWK+2,C' '      ELIMINATE
         CLI   N2CNVWK,C'0'         ANY
         BNE   *+10                  LEADING
         MVC   N2CNVWK(3),N2CNVWK+1   ZERO
         MVI   N2NODE,C'N'         SET 'N'
         MVC   N2NODE+1(2),N2CNVWK MOVE IN NODE NO.
         SPACE 1
N2RTEXT  DS    0H                  NORMAL EXIT
         SR    R15,R15
         BR    R14
         SPACE 2
N2RTLOC  DS    0H                  LOCAL ROUTING
         MVC   N2ROUTE,=CL8'LOCAL'
         B     N2RTNODE            GO PROCESS NODE NO.
         SPACE 2
N2RTERR1 DS    0H                  HERE IF JQE ROUTE CODE BIT 0=1
         LA    R15,4
         BR    R14
         DROP  R4
         DROP  R15
         TITLE 'ERROR PROCESSING'
*  ERROR PROCESSING
* JOB SELECT OR SETUP  ERRORS
N2JERR1  DS    0H                  JQETYPE UNKNOWN
N2JERR2  DS    0H                  JCT DOES NOT POINT TO JQE
N2JERR3  DS    0H                  IOT JOBID NOT = JCT JOBID
N2JERR4  DS    0H                  NO IOTS
         L     R14,QPJERR          ERROR EXIT
         #RETURN (2,12),RC=0
         SPACE 3
* QPOPEN ERRORS
N2OERR1  DS    0H                  JCL PDDB NOT FOUND
N2OERR2  DS    0H                  SYSIN PDDB NOT FOUND
N2OERR3  DS    0H                  SYSOUT PDDB NOT FOUND
         L     R14,QPONFF          TAKE NFF EXIT
         #RETURN (2,12),RC=0
         SPACE 3
* QPGET ERRORS
N2GERR1  DS    0H                  GET ERROR
         L     R14,QPGERR          ERROR EXIT
         #RETURN (2,12),RC=0
         SPACE 4
*        COME HERE WHEN 'IMPOSSIBLE' ERRORS OCCUR
*
N2BADEND ABEND 2989,DUMP
         TITLE 'DATA AREAS'
         ENTRY N2EOJQ,N2$JOBQ
         ENTRY N2$PDDB
         ENTRY N2$JOT
N2$JOT   DS    A                   PTR TO BEGINNING OF JOT
N2EOJQ   DS    A                   END OF JOBQ ADDR-SET BY N2QI
N2$JOBQ  DS    A                   1ST JQE-4 ($JOBQPTR)
N2CURJQE DC    A(0)                CURRENT JQE PTR
N2$PDDB  DC    H'0'                OFFSET TO 1ST PDDB IN IOT
N2SINKEY DC    F'0'                CURRENT SYSIN MTTR
N2SOTKEY DC    H'0'                CURRENT RELATIVE SYSOUT DS KEY
* NOTE: JCT AND IOT PTRS ARE OFFSET - 88 BYTES TO ALLOW FOR ABSENCE OF
* IOB IN BUFFER.
N2CURJCT DC    A(0)                PTR TO IN-CORE JCT
N2JCTIOT DC    A(0)                PTR TO 1ST IN-CORE IOT
N2CURIOT DC    A(0)                PTR TO IN-CORE IOT
N2CURPDB DC    A(0)                PTR TO IN-CORE PDDB
N2PDBSAV DC    A(0)                TEMP SAVE OF CURPDB
N2IOTSAV DC    A(0)                TEMP SAVE OF CURIOT
N2KEYSAV DC    A(0)                TEMP SAVE OF A PDBDSKEY
N2DSKEY  DC    H'0'                CURRENT DS KEY
N2CURBUF DC    A(0)                CURRENT BUFFER BAT ENTRY
N2CURREC DC    A(0)                CURRENT RECORD
N2JCLBUF DC    A(0)                CURRENT JCL BUFFER BAT
N2JCLREC DC    A(0)                CURRENT JCL RECORD
N2WRKJOE DC    A(0)                CURRENT WORK JOE
N2CHRJOE DC    A(0)                CURRENT CHAR JOE
N2CKPJOE DC    A(0)                CURRENT CHKPT JOE
N2FLAGS  DC    X'00'               FLAG BYTE USED WITHIN N2QP
N2SPIOT  EQU   X'20'               INDICATES SPIN IOTS BEING PROCESSED
*                                  DURING JOB SETUP
N2DMDSET EQU   X'08'               DEMAND SETUP SPECIFIED AT JES2 INIT
         SPACE 2
N2HSACC1 EQU   X'04'               HJP FLAG FOR MULTI DEST       FIX057
         SPACE 2
N2R2RMT  EQU   X'01'               SPR2 REMOTE QUEUES SEARCHED     SPR2
         SPACE 2
N2CNVWK  DS    D                   FOR CVD
N2ROUTE  DS    CL8                 ROUTE CODE FROM CONVERSION
N2NODE   DS    CL8                 NODE NAME FROM CONVERSION
         SPACE 1
*  TABLE FOR CONVERTING SYSOUT CLASS TO JOT CLASS QUEUE
*2CNVCLS DC    AL1(0,2,4,6,8,10,12,14,16),7AL1(0)          A-I     SPR2
* JES2   DC    AL1(18,20,22,24,26,28,30,32,34),8AL1(0)     J-R     SPR2
*  REL   DC    AL1(36,38,40,42,44,46,48,50),6AL1(0)        S-Z     SPR2
*  4.0   DC    AL1(52,54,56,58,60,62,64,66,68,70)          0-9     SPR2
*  4.1   SPACE 2
*  TABLE FOR CONVERTING SYSOUT CLASS TO JOT CLASS QUEUE
N2CNVCLS DC    AL1(0,4,8,12,16,20,24,28,32),7AL1(0)           A-I  SPR2
         DC    AL1(36,40,44,48,52,56,60,64,68),8AL1(0)        J-R  SPR2
         DC    AL1(72,76,80,84,88,92,96,100),6AL1(0)          S-Z  SPR2
         DC    AL1(104,108,112,116,120,124,128,132,136,140)   0-9  SPR2
         SPACE 2
* JOB DELETED MSG NEEDS TO BE SKIPPED IN JCL DATA SET
N2DELMSG DS    0CL79
         DC    C'******** JOB DELETED BY JES2 OR CANCELLED BY '
         DC    C'OPERATOR BEFORE EXECUTION ********'
         EJECT
         HJCBBAT
         HJDSBAT
         QPINT
         PRINT GEN
         $HASPCB
         PRINT GEN
HJSTN2QP CSECT
         END
