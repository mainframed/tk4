*PROCESS INCLUDE,MARGINS(2,72);
 /* GPPP: GENERAL PURPROSE PRE-PROCESSOR (YALE)                      */
 /* GRAMMAR MACRO                                                    */
 /* PRINT OFF                                                        */
 GPPP: PROC(PARM) OPTIONS(MAIN);
 /* PROC:     GPPP                                                   */
 /* FUNCTION:    GENERAL PURPOSE PRE PROCESSOR                       */
 /* VERSION:  AUG 10,1979                                            */
 /* COPYRIGHT   1979  BY HOWARD K. GILBERT                           */
 /*                                                                  */
 /* AUTHOR:                                                          */
 /*                                                                  */
 /*                HOWARD GILBERT                                    */
 /*                YALE COMPUTER CENTER                              */
 /*                175 WHITNEY AVE.                                  */
 /*                NEW HAVEN, CONN.   06520                          */
 /*                203 432 4080                                      */
 /*                                                                  */
 /*  PERMISSION TO MAKE PRIVATE COPIES OF THIS PROGRAM AND           */
 /*  TO USE IT FREELY IS HEREBY GRANTED BY THE AUTHOR. THIS          */
 /*  PROGRAM MAY NOT BE SOLD, NOR MAY ANY SECTION OF IT BE           */
 /*  INCORPORATED INTO ANY WORK FOR SALE WITHOUT PERMISSION OF       */
 /* THE AUTHOR.                                                      */
 /*                                                                  */
 /* ACKNOWLEDGEMENTS:                                                */
 /*      THE AUTHOR WOULD LIKE TO THANK ROB STROM AND PHIL LONG      */
 /*      OF YCC FOR THEIR COMMENTS AND SUGGESTIONS IN THE DESIGN     */
 /*      OF THIS PROGRAM.                                            */
 % PAGE;
 DCL VERSION CHAR(9)              /* VERSION DATE OF PGM             */
         INIT('10 AUG 79');       /*                                 */
 DCL COPYRIT  CHAR(40)            /* COPYRIGHT NOTICE                */
         STATIC EXT               /*                                 */
         INIT('COPYRIGHT 1979 BY HOWARD K. GILBERT');
 DCL PARM                         /* OS PARM FIELD                   */
         CHAR(100) VAR;           /*                                 */
 DCL INPUT                        /* PRIMARY INPUT DATASET           */
          INPUT RECORD;           /*    CARD IMAGE                   */
 DCL SYSPUN                       /* PRIMARY OUTPUT DATASET          */
          OUTPUT RECORD           /*                                 */
          ENV(FB RECSIZE(80)      /*                                 */
          BLKSIZE(4240));         /*                                 */
 DCL SYSPRINT                     /*                                 */
         OUTPUT STREAM;           /*                                 */
 DCL LISTING                      /*                                 */
         OUTPUT PRINT             /*                                 */
         ENV(VB RECSIZE(132)      /*                                 */
         BLKSIZE(4240 ));         /*                                 */
 DCL LISTFILE FILE VARIABLE;      /*                                 */
 DCL SYSUT1                       /* SCRATCH SEQUENTIAL WORKFILE     */
         FILE                     /*                                 */
         ENV(VB RECSIZE(13020)    /*                                 */
         BLKSIZE(13030));         /*                                 */
 DCL SYSUT2                       /*                                 */
         FILE                     /*                                 */
         ENV(VB RECSIZE(13020)    /*                                 */
         BLKSIZE(13030));         /*                                 */
 DCL SYSUT3                       /*                                 */
         FILE                     /*                                 */
         ENV(VB RECSIZE(13020)    /*                                 */
         BLKSIZE(13030));         /*                                 */
 DCL SYSUTV                       /* VSAM (KEYED) WORKFILE           */
         FILE                     /*                                 */
         ENV(VSAM  REUSE);        /*                                 */
 DCL CARD                         /* INPUT RECORD BUFFER             */
          CHAR(80);               /*                                 */
 DCL BUFF                         /* FULL TRACK BUFFER FOR SYSLIB    */
         (162) CHAR(80)           /*   INPUT BLOCKS                  */
         INIT((162)(1) '');       /*                                 */
 DCL INCL#                        /* DEPTH OF INCLUDED MEMBERS       */
         FIXED BIN                /*                                 */
         INIT(0);                 /*                                 */
 DCL REC#                         /* LAST RECORD OFFSET IN BLOCK     */
         FIXED BIN;               /*   TO DEBLOCK CARDS              */
 DCL TTRSAVE(0:10)                /* REMEMBER TTR OF BLOCKS          */
         FIXED BIN(31);           /*   WHERE INCL WAS INTERRUPTED    */
 DCL RECSAVE(0:10)                /* REMEMBER REC# OF INCLUDE IN     */
         FIXED BIN;               /*   INCLUDED MEMBER               */
 DCL 1 SYSLBBLK,                  /* PARAMETER BLOCK FOR SYSLIBR     */
         2 MEMBER CHAR(8)         /*   MEMBER NAME (REQMEM)          */
              INIT(' '),          /*                                 */
         2 TTR FIXED BIN(31),     /* TTR (REQREC)                    */
         2 BUFFAD PTR             /* ADDR OF INPUT BUFFER            */
              INIT((ADDR(BUFF))), /*                                 */
         2 WORKAPTR PTR           /* WORK AREA USED BY SYSLIBR       */
              INIT((NULL)),       /*   TO HOLD DCB & DECB            */
         2 BUFFLEN FIXED BIN      /* LENGTH OF INPUT BUFFER          */
              INIT(12960),        /*   SET TO FULL 3330 TRK          */
         2 RECSIZE FIXED BIN,     /* RETURNED LENGTH OF INPUT        */
         2 REQUEST BIT(8) ALIGNED,/* REQUEST TYPE,SEE BELOW          */
         2 ERRORS  BIT(8) ALIGNED,/* ERROR FLAGS, SEE BELOW          */
     REQMEM BIT(8) INIT('1000'B), /*  REQUEST NEW MEMBER             */
     REQREC BIT(8) INIT('0100'B), /*  REQUEST TTR SEARCH             */
     ERREOF BIT(8) INIT('1000'B), /*  END OF FILE                    */
     ERRIO  BIT(8) INIT('0100'B), /*  IO ERROR (USUSED NOW)          */
     ERROPN BIT(8) INIT('0010'B), /*  OPEN ERROR                     */
     ERRMEM BIT(8) INIT('0001'B); /*  MEMBER NOT FOUND               */
 DCL SYSLIBR ENTRY(*)             /* SYSLIB READER                   */
         OPTIONS(ASM INTER);      /*                                 */
 DCL STRING                       /* HOLDS COMPLETE MACRO STATEMENT  */
          CHAR(1024) VAR;         /*    FOR CALL TO MACCALL          */
 DCL MAXRETC                      /* HIGHEST RETURN CODE FOR         */
          FIXED BIN(31)           /*   JOB STEP COMPLETION           */
          INIT(0);                /*                                 */
 DCL CARDNUM                      /* CARD SEQUENCE NUMBER TO BE      */
          PIC'99999999';          /*   INCREMENTED BY GEN            */
 DCL SYMBOLSTORE                  /* BUFFER FOR SYMBOL TABLES        */
          CHAR(32000);            /*                                 */
 DCL MAXSTORE                     /* SIZE OF SYMBOLSTORE             */
          FIXED BIN(31)           /*   TESTED BY SYMALLOC            */
          INIT(32000);            /*                                 */
 DCL MAXLEVEL                     /* DIMENSION OF LEVELPTR VECTOR    */
          FIXED BIN               /*   TESTED BY PUSH                */
          INIT(40);               /*                                 */
 DCL STOREADDR                    /* CONVERTED VALUE OF SYMBOLSTORE  */
          FIXED BIN(31);          /*   ADDRESS FOR PTR ARITHMETIC    */
 DCL SCANSTATE                    /*                                 */
         FIXED BIN;               /*                                 */
 DCL RESET FIXED BIN INIT(0);     /* THE FOLLOWING THREE             */
 DCL PEND  FIXED BIN INIT(1);     /* VALUES ARE STATES OF            */
 DCL QUOTE FIXED BIN INIT(2);     /* SCANSTATE VARIABLE              */
 DCL I                            /*                                 */
          FIXED BIN;              /*                                 */
 DCL LMARG                        /* LEFT INPUT CARD MARGIN          */
         FIXED BIN                /*   INPUT BEFORE THIS COL         */
         INIT(1);                 /*    WILL BE IGNORED              */
 DCL RMARG                        /* RIGHT INPUT CARD MARGIN         */
         FIXED BIN                /*    INPUT AFTER THIS COL         */
         INIT(72);                /*    WILL BE IGNORED              */
 DCL SEQSTART                     /* START OF SEQUENCE NUMBER        */
         FIXED BIN                /*   FIELD ON INPUT CARDS          */
         INIT(73);                /*   ASSUMED TO BE 8 CHAR LONG     */
 DCL INCREMENT                    /* SEQUENCE NUMBER INCREMENT       */
         FIXED BIN                /*   FOR GENNED STATEMENTS         */
         INIT(1);                 /*                                 */
 DCL PAGENUM                      /* CURRENT LISTING  PAGE NUMBER    */
         FIXED BIN                /*                                 */
         INIT(0);                 /*                                 */
 DCL TITLE                        /* CURRENT LISTING TITLE           */
         CHAR(70) VAR             /*                                 */
         INIT(' ');               /*                                 */
 DCL YESNO(0:1) CHAR(3)           /*                                 */
         INIT('NO','YES');        /*                                 */
 DCL (ADDR,                       /*                                 */
      PLIRETC,                    /*                                 */
      NULL,                       /*                                 */
      MAX,                        /*                                 */
      SUBSTR,                     /*                                 */
      LOW   ,                     /*                                 */
      LENGTH,                     /*                                 */
      VERIFY,                     /*                                 */
      ONSOURCE,                   /*                                 */
      PLIDUMP,                    /*                                 */
      MIN,                        /*                                 */
      HBOUND)                     /*                                 */
          BUILTIN;                /*                                 */
 DCL PTRIN                        /* ENTRY TO PERMIT PTR ARITHMETIC  */
          ENTRY(PTR)              /*   CONVERTS PTR TO NUMBER        */
          RETURNS(FIXED BIN(31)); /*                                 */
 DCL PTROUT                       /* INVERSE OF PTRIN, CONVERTS A    */
          ENTRY(FIXED BIN(31))    /*   NUMBER TO A POINTER           */
          RETURNS(PTR);           /*                                 */
 DCL NULLPGM ENTRY;               /* IEFBR14-TYPE USED FOR TSO TEST  */
 % PAGE;
 DCL 1 GPPPTCA,
 % INCLUDE GPPPTCA;
 % PAGE;
 /*   THE SYMBOL TABLE IS STORED IN ARRAY SYMBOLSTORE. IT IS         */
 /*   ORGANIZED AS:                                                  */
 /*                                                                  */
 /*          LEVELPTR(0) ->   ---------------                        */
 /*                           ×   LEVEL 0   ×                        */
 /*          LEVELPTR(1) ->   ---------------                        */
 /*                           ×   LEVEL 1   ×                        */
 /*                           ×    . . .    ×                        */
 /*    LEVELPTR(LEVEL#)  ->   ---------------                        */
 /*                           × CURRENTLEVEL×                        */
 /*                           ---------------                        */
 /*                           ×UNUSED AREA  ×                        */
 /*   EACH LEVEL BEGINS WITH A MAJOR SYMBOL TABLE, THEN              */
 /*   CONTAINS STORAGE FOR THE STATIC AND VARIABLE DATA AREAS        */
 /*   FOR THE SYMBOLS USED AT THAT LEVEL.                            */
 /*  THE VARIABLE AND STATIC DATA PARTS ARE CHAINED OFF THE          */
 /*  SYMBOL TABLE ENTRY, AND EACH VARIABLE PART POINTS BACK          */
 /*  THROUGH SYMPTR TO ITS ORIGINATING SYMBOL TABLE ENTRY.           */
 /*   FOR CLEANUP AT EACH LEVEL, THERE IS A CHAIN FROM 'VARCHAIN'    */
 /*  THROUGH EACH VARIABLE DATA ITEM AT THIS LEVEL USING THE         */
 /*  'NEXTVAR' POINTER:                                              */
 /*     (NULL)  <-  <VAR 1>  <-  ...  <- <VAR N-1> <- <VAR N>        */
 /*      ×                                                           */
 /*     VARCHAIN -----------------------------------------           */
 /*                (LEVEL CLEAN UP CHAIN)                            */
 /*                                                                  */
 /*   FOR EACH SYMBOL, ALL OF THE COPIES OF THE VARIABLE INFO        */
 /*  AT EACH LEVEL ARE CHAINED UP USING THE 'BACKVAR' PTR.           */
 /*   ×SYMBOL TABLE ENTRY×          <STATIC> <VAR +0>                */
 /*      VARPTR -------------                    ×                   */
 /*                          ×                   ×                   */
 /*     INTERMEDIATE LEVEL   ×               <VAR +I>                */
 /*                          ×                   ×                   */
 /*     CURRENT LEVEL        --------------> <VAR +N>                */
 /*                  (VAR INFO GENERATION CHAIN)                     */
 /*                                                                  */
 /*   THERE IS ONE MAJOR SYMBOL TABLE AT THE BEGINNING OF            */
 /*  THE DATA FOR ANY LEVEL, BUT IT IS POSSIBLE FOR ANY SYMBOL       */
 /*  TO CONTAIN WITHIN ITS STATIC OR VARIABLE INFORMATION A          */
 /*  SIMILARLY FORMATTED MINOR (SUB)SYMBOL TABLE AND ITS             */
 /*  ENTRIES CAN ACQUIRE STATIC AND VARIABLE DATA AREAS. THE         */
 /*  TABLE SCAN, SYMBOL ADD, AND LEVEL CLEANUP DO NOT                */
 /*  DISTINGUISH MINOR TABLES AND THEIR VARIABLE AREAS FROM          */
 /*  MAJOR SYMBOLS.                                                  */
 % PAGE;
 % INCLUDE GPPPSYM;
 % PAGE;
 ON ENDFILE(INPUT) GO TO FINN;
 OPEN FILE(SYSPUN) OUTPUT RECORD TITLE('SYSPUNCH');
 ON ENDPAGE(LISTING )
         BEGIN;
         PAGENUM=PAGENUM+1;
         PUT FILE(LISTING ) EDIT('GPPP V0',TITLE,'PAGE',PAGENUM)
         (PAGE,A,X(15),A(70),COL(110),A(4),F(5));
         END;
 SIGNAL ENDPAGE(LISTING );
 ON ERROR CALL PLIDUMP('NF');
 %SKIP;
 SYSPUNCH=SYSPUN;
 SYSUT1F=SYSUT1;
 SYSUT2F=SYSUT2;
 SYSUT3F=SYSUT3;
 AUTOFILE=SYSUT3;
 SYSUTVF=SYSUTV;
 GEN=GENNER;
 NOTE=NOTER;
 QUIT=QUITTER;
 ERR=ERRER;
 MACCALL=MCALLER;
 PARSE=PARSER;
 PUSH=PUSHER;
 POP=POPPER;
 FIND=FINDER;
 SCAN=SCANNER;
 NEWSYM=SYMADD;
 CPYVAR=VARCPYER;
 GRAMMAR=GRAMMER;
 MACADD=MACADDER;
 READCARD=CARDREADER;
 READSTMT=STMTREADER;
 NUMBER=NUMBERS;
 GETWORD=GETWORDER;
 %SKIP;
 CALL NULLPGM(GPPPTCA);
 /*    TO ALLOW DEBUGGING USING THE TSO TEST COMMAND, WE NOW         */
 /* CALL A DUMMY ENTRY POINT PASSING IT THE TCA ADDRESS. IF          */
 /* YOU SET A BREAKPOINT AT .NULLPGM, YOU CAN USE THE TCA            */
 /* ADDRESS TO SET BREAKPOINTS AT ANY INTERNAL PROCEDURE             */
 /* ENTRY POINT, AND IF YOU REMEMBER THE TCA, YOU CAN INTERACTIVELY  */
 /* INTERROGATE THE SYMBOL TABLE AND STATUS INFO                     */
 % PAGE;
 /* INITIALIZE THE SYMBOL TABLE INFO                                 */
 PRINTON,PRINTGEN,GENON,ANNOT='1'B;
 BLKGEN,GENAUTO,DEBUGER='0'B;
 STMTSTAT,LSTSTAT='0'B;
 SELECT=' ';
 LANGUAGE='BAL';
 INCREMENT=1;
 STMTNUM=0;
 SYSCSECT='';
 SYSDSECT='';
 AUTOOF,STATOF=0;
 DSECTOF=0;
 SYMBOLSTORE=LOW(32000);
 LEVEL#=0;
 SYMBOLTABPTR,LEVELPTR(0)=ADDR(SYMBOLSTORE);
 STOREADDR=PTRIN(ADDR(SYMBOLSTORE));
 VARCHAIN=NULL;
 MAXKEYS=300;
 USEDKEYS=0;
 NEXTSTORE=STPREFIXLEN+300*ITEMLEN;
 %SKIP;
 SYMBOLPTR=NEWSYM('%GRAMMARS%',NAMELEN+STPREFIXLEN+20*ITEMLEN,12,NULL);
 TYPENAME='%SYSTEM%';
 SYMBOLTABPTR=ADDR(STATICTEXT);
 VARCHAIN=NULL;
 MAXKEYS=40;
 USEDKEYS=0;
 %SKIP;
 SYMBOLPTR=NEWSYM('%MACROS%',NAMELEN+STPREFIXLEN+300*ITEMLEN,12,NULL);
 TYPENAME='%SYSTEM%';
 SYMBOLTABPTR=ADDR(STATICTEXT);
 VARCHAIN=NULL;
 MAXKEYS=300;
 USEDKEYS=0;
 I=MACADD('GRAMMAR',GRAMMARMAC);
 I=MACADD('PRINT',PRINTMAC);
 I=MACADD('INCLUDE',INCLDMAC);
 I=MACADD('GEN',GENERMAC);
 I=MACADD('PAGE',PAGEMAC);
 I=MACADD('TITLE',TITLEMAC);
 I=MACADD('*PROCESS',PROCESSMAC);
 %SKIP(5);
 IF PARM^='' THEN
         CALL MACCALL('*PROCESS '××PARM);
 IF LANGUAGE ^='UTIL' THEN
 DO LISTFILE=SYSPRINT,LISTING;
 PUT FILE(LISTFILE ) EDIT('VERSION:',VERSION,'LANGUAGE:',
         LANGUAGE,'ID ',SELECT,'MARGINS:',LMARG,RMARG,
         'SEQ:',SEQSTART,'ANNOTATE:',YESNO(ANNOT),
         'DEBUG:',YESNO(DEBUGER))
         (SKIP(3),(3) (A,X(1),A,X(5)), A, 2 F(3),X(5),
         A,F(3),X(5),(2) (A,X(1),A,X(5)));
 END;
 % PAGE;
 /* THIS IS THE BASIC READ LOOP. ITS FUNCTION IS TO                  */
 /*   READ A CARD                                                    */
 /*   SEE IF IT IS A MACRO                                           */
 /*   IF NOT, REPRODUCE IT IN THE OUTPUT STREAM                      */
 /*   OTHERWISE, PASS IT TO MACCALL FOR EXPANSION                    */
 /* THE ERROR ROUTINES MAY PASS CONTROL BACK TO THE READLOOP         */
 /* LABEL IF EXPANSION OF THE CURRENT STATEMENT CANNOT PROCEED       */
 READLOOP:
              CALL READSTMT(STRING);
              CALL MACCALL(STRING);
         GO TO READLOOP;
 FINN:
          CALL PLIRETC(MAXRETC);
          RETURN;
 % PAGE;
 /* PROCEDURE:   GENNER */
 /* FUNCTION:    GENERATE ONE CARD IMAGE IN SYSPUNCH DATASET AND     */
 /*              PRINT IT ON LISTING  UNDER CONTROL OF THE CURRENT   */
 /*              'PRINT GEN' OPTION.                                 */
 /* LINKAGE:     THIS ROUTINE IS KNOWN IN THE TCA UNDER THE ALIAS    */
 /*              'GEN'. A MACRO LINKS BY                             */
 /*                   CALL GEN(CARDIMAGE);                           */
 /* EXTERNAL:    NONE                                                */
 GENNER:PROC(OUTCARD);
 DCL OUTCARD CHAR(*) VAR;
 DCL MYCARD CHAR(80) INIT(' ');
 DCL I FIXED BIN;
         IF ^GENON THEN RETURN;
         IF LANGUAGE='BAL'
              THEN
                   DO;
                   MYCARD=OUTCARD;
                   IF LENGTH(OUTCARD)>71
                        THEN
                             SUBSTR(MYCARD,72,1)='*';
                   CALL CARDPUT;
                   MYCARD=' ';
                        DO I=72 TO LENGTH(OUTCARD) BY 56;
                        SUBSTR(MYCARD,16)=SUBSTR(OUTCARD,I);
                        IF LENGTH(OUTCARD)>I+55
                             THEN
                                  SUBSTR(MYCARD,72,1)='*';
                        CALL CARDPUT;
                        END;
                   END;
              ELSE
                   DO I=1 TO LENGTH(OUTCARD) BY 71;
                   SUBSTR(MYCARD,2,71)=SUBSTR(OUTCARD,I,
                        MIN(71,LENGTH(OUTCARD)-I+1));
                   CALL CARDPUT;
                   END;
 %SKIP(3);
 CARDPUT: PROC;
         CARDNUM=CARDNUM+INCREMENT;
         SUBSTR(MYCARD,73)=CARDNUM;
         IF GENAUTO
              THEN
                   DO;
                   WRITE FILE(AUTOFILE) FROM(MYCARD);
                   RETURN;
                   END;
         IF PRINTON & PRINTGEN THEN
               PUT FILE(LISTING ) EDIT(MYCARD)(COL(1),X(20),A(80));
         WRITE FILE(SYSPUNCH) FROM(MYCARD);
 END CARDPUT;
 END GENNER;
 % PAGE;
 /* PROCEDURE    NOTER                                               */
 /* FUNCTION     GENERATE AN 'MNOTE' MESSAGE IN LISTING  DATASET     */
 /* LINKAGE      THIS PROCEDURE IS KNOW IN THE TCA UNDER THE ALIAS   */
 /*          'NOTE'. A MACRO CALLS IT BY                             */
 /*             CALL NOTE(RETURNCODE,MESSAGE)                        */
 /*          WHERE                                                   */
 /*             RETURNCODE IS A FIXED BIN NUMBER WHICH IS COMPARED   */
 /*             WITH THE CURRENT MAXIMUM RETURN CODE TO BE PASSED    */
 /*             BACK WHEN THE JOBSTEP ENDS,                          */
 /*             MESSAGE IS AN ERROR MESSAGE TO BE PRINTED ON THE     */
 /*             OUTPUT                                               */
 /* EXTERNAL     NONE                                                */
 NOTER:PROC(RETC,MSG);
 DCL RETC FIXED BIN;
 DCL MSG CHAR(*) VAR;
     IF RETC = 0 & LANGUAGE = 'UTIL'
        THEN
           DO;
           PUT FILE(SYSPRINT) EDIT (MSG) (COL(1),A);
           RETURN;
           END;
     DO LISTFILE=LISTING,SYSPRINT;
     PUT FILE(LISTFILE ) EDIT('*** NOTE IN STMT ',STMTNUM,RETC,MSG)
      (COL(1),A,A,X(2),F(4),COL(40),A);
     END;
 MAXRETC=MAX(MAXRETC,RETC);
 END NOTER;
 % PAGE;
 /* PROCEDURE    QUITTER                                             */
 /* FUNCTION     TO TERMINATE THE CURRENT JOBSTEP IMMEDIATELY        */
 /* LINKAGE      QUITTER IS KNOWN IN THE TCA UNDER THE ALIAS         */
 /*             'QUIT'. A MACRO INVOKES IT BY                        */
 /*                CALL QUIT;                                        */
 /* EXTERNAL     NONE                                                */
 /* EXIT         RETURNS TO THE TERMINATION LABEL OF THE MAIN        */
 /* PROCEDURE */
 QUITTER: PROC;
 GO TO FINN;
 END QUITTER;
 % PAGE;
 /* PROCEDURE    ERRER                                               */
 /* FUNTION  SIGNALS AN ERROR IN THE INPUT                           */
 /*          THIS ROUTINE WILL PRINT AN ERROR MESSAGE LINE,          */
 /*             ONE STATEMENT FROM THE INPUT DECK                    */
 /*             AND PUT A '$' UNDER THAT LINE AT THE CURRENT         */
 /*             SCAN POSITION. IT IS INTENDED FOR SYNTAX             */
 /*             ERRORS AND NOT FOR MACRO DETECTED ERRORS             */
 /*             (SEE NOTER ABOVE).                                   */
 /* LINKAGE      THIS ROUTINE IS KNOWN IN THE TCA AS 'ERR'.          */
 /* EXTERNAL     NONE                                                */
 /* EXIT         RETURNS TO THE READ LABEL OF THE MAIN PROCEDURE TO  */
 /*            GET THE NEXT STATEMENT.                               */
 ERRER: PROC(TEXT,STR,POSITION);
 DCL TEXT CHAR(*) VAR;
 DCL STR CHAR(*) VAR;
 DCL POSITION FIXED BIN;
 DCL I FIXED BIN;
 DCL LENGTH BUILTIN;
 DO LISTFILE=LISTING,SYSPRINT;
 PUT FILE(LISTFILE ) EDIT('*** ERROR IN STMT ',STMTNUM,TEXT)
         (COL(1),A,A,X(3),A);
    DO I=1 TO LENGTH(STR) BY 71;
    PUT FILE(LISTFILE) EDIT(SUBSTR(STR,I))(COL(20),A(71));
    IF POSITION>=I & POSITION<I+71 THEN
        PUT FILE(LISTFILE) EDIT('$')(COL(20+POSITION-I),A(1));
    END;
 END;
 MAXRETC=MAX(MAXRETC,12);
 GO TO READLOOP;
 END ERRER;
 % PAGE;
 /* PROCEDURE    STMTREADER                                          */
 /* FUNCTION     READ ONE GPPP STATEMENT IN, INCLUDING               */
 /*              CONTINUATION CARDS.                                 */
 STMTREADER: PROC(STRING);
 DCL STRING CHAR(1024) VAR;
 DCL CARDIN CHAR(80);
 DCL CARDLIST CHAR(80);
 DCL FIRSTCARD BIT INIT('1'B);
 DCL TRANSLATE BUILTIN;
 STRING='';
 CONTINUE:
         CALL READCARD(CARDIN);
         IF FIRSTCARD  &
            SELECT^=' ' × (LANGUAGE='BAL'  & SUBSTR(CARDIN,1,1)='*')
                 THEN
                    IF SELECT ^= SUBSTR(CARDIN,1,1)
                         THEN
                              DO;
                              IF PRINTON THEN
                                   PUT FILE(LISTING ) EDIT(CARDIN)
                                        (COL(1),X(20),A(80));
                              IF GENON THEN
                                   WRITE FILE(SYSPUNCH) FROM(CARDIN);
                              GO TO CONTINUE;
                              END;
                         ELSE
                              SUBSTR(CARDIN,1,1)=' ';
         CARDLIST=CARDIN;
         STRING=STRING××SUBSTR(CARDIN,LMARG,RMARG+1-LMARG);
         IF LANGUAGE = 'UTIL'
            THEN
 LASTSCAN:
               DO I=LENGTH(STRING) TO 1 BY -1;
               IF SUBSTR(STRING,I,1)='-'
                  THEN
                     DO;
                     SUBSTR(STRING,I,1)=' ';
                     LEAVE LASTSCAN;
                     END;
               IF SUBSTR(STRING,I,1)^=' '
                  THEN
                     DO;
                     STRING=STRING××';';
                     SUBSTR(CARDIN,72,1)=';';
                     LEAVE LASTSCAN;
                     END;
               END LASTSCAN;
         IF SEQSTART>0
            THEN
               IF SUBSTR(CARDIN,SEQSTART,8)^=' '
                  THEN
                     CARDNUM=SUBSTR(CARDIN,SEQSTART);
                  ELSE
                     CARDNUM='00000000';
            ELSE
               CARDNUM='00000000';
         IF FIRSTCARD THEN STMTNUM=CARDNUM;
         FIRSTCARD='0'B;
         IF LANGUAGE='BAL'
              THEN
                   SUBSTR(CARDLIST,1,1)='*';
         IF LANGUAGE='PLI'
              THEN
                   DO;
                   SUBSTR(CARDLIST,2,2)='/*';
                   SUBSTR(CARDLIST,70,2)='*/';
                   CARDLIST=TRANSLATE(CARDLIST,' ',';');
                   END;
         IF PRINTON & (INCL#=0×PRINTGEN) THEN
               PUT FILE(LISTING ) EDIT(CARDLIST)(COL(1),X(20),A(80));
         IF LANGUAGE='UTIL' THEN
               PUT FILE(SYSPRINT) EDIT(CARDLIST)(COL(1),X(20),A(80));
         IF ANNOT & GENON THEN
               WRITE FILE(SYSPUNCH) FROM(CARDLIST);
         SCANSTATE=0;
              DO I=1 TO 72;
                   SELECT(SUBSTR(CARDIN,I,1));
                        WHEN('"')
                             SELECT(SCANSTATE);
                                  WHEN(RESET) SCANSTATE=QUOTE;
                                  WHEN(PEND) SCANSTATE=QUOTE;
                                  WHEN(QUOTE) SCANSTATE=RESET;
                             END;
                        WHEN(';')
                             IF SCANSTATE^=QUOTE
                                  THEN GO TO ENDSTMT;
                        OTHERWISE
                             IF SCANSTATE=PEND
                                  THEN SCANSTATE=RESET;
                   END;
              END;
         GO TO CONTINUE;
 ENDSTMT:
 END STMTREADER;
 % PAGE;
 /* PROCEDURE    CARDREADER                                          */
 /* FUNCTION     TO READ A CARD FROM INPUT OR SYSLIB                 */
 /* LINKAGE      KNOW IN TCA AS 'READCARD'                           */
 CARDREADER: PROC(CARD);
 DCL CARD CHAR(80);
 BEGIN:
         IF INCL#=0 THEN
              READ FILE(INPUT) INTO(CARD);
         ELSE
              DO;
              REC#=REC#+1;
              IF REC#*80>RECSIZE THEN
                   DO;
                   REQUEST='0'B;
                   CALL SYSLIBR(SYSLBBLK);
                   IF ERRORS THEN
                        DO;
                        INCL#=INCL#-1;
                        IF INCL#=0 THEN GO TO BEGIN;
                        TTR=TTRSAVE(INCL#);
                        REC#=RECSAVE(INCL#);
                        REQUEST=REQREC;
                        CALL SYSLIBR(SYSLBBLK);
                        GO TO BEGIN;
                        END;
                   REC#=1;
                   END;
              CARD=BUFF(REC#);
              END;
         IF LANGUAGE='UTIL'
            THEN
               IF SUBSTR(CARD,1,72)='//'
                  THEN
                     CARD=' %ENDJOB% ;';
            ELSE
               IF SUBSTR(CARD,1,2)='//'
                  THEN
                     GOTO BEGIN;
         IF BLKGEN THEN
              DO;
              I=VERIFY(CARD,' ');
              IF I>0
                   THEN
                        IF SUBSTR(CARD,I,20)='@ENDGEN' ×
                           SUBSTR(CARD,I,20)='@ENDGEN;'
                           THEN
                             DO;
                             BLKGEN='0'B;
                             GENAUTO='0'B;
                             IF LANGUAGE='BAL'
                                  THEN
                                       SUBSTR(CARD,1,1)='*';
                             IF LANGUAGE='PLI'
                                  THEN
                                       DO;
                                       SUBSTR(CARD,2,2)='/*';
                                       SUBSTR(CARD,70,2)='*/';
                                       END;
                             END;
              IF PRINTON THEN
               PUT FILE(LISTING ) EDIT(CARD)(COL(1),X(20),A(80));
              IF GENON & (ANNOT × BLKGEN) THEN
                   IF GENAUTO
                        THEN
                             WRITE FILE(AUTOFILE) FROM(CARD);
                        ELSE
                             WRITE FILE(SYSPUNCH) FROM(CARD);
              GO TO BEGIN;
              END;
 END CARDREADER;
 % PAGE;
 /* PROCEDURE    MCALLER                                             */
 /* FUNCTION     PERFORM AN INTERPRETIVE MACRO CALL                  */
 /* LINKAGE      THIS PROCEDURE IS KNOWN IN THE TCA UNDER THE        */
 /*             ALIAS 'MACCALL'. IT IS INVOKED BY                    */
 /*               CALL MACCALL(STATEMENT);                           */
 /*             WHERE STATEMENT IS A CHARACTER STRING CONTAINING A   */
 /*             MACRO STATEMENT                                      */
 /* EXTERNAL     CALLS THE MACRO ENTRY POINT WHICH IT FINDS          */
 /*             IN THE SYMBOL TABLE.                                 */
 /*             CALLS FIND,SCAN, AND GETWORD                         */
 MCALLER:PROC(STRING) RECURSIVE;
 DCL STRING CHAR(1024) VAR;
 DCL POSITION FIXED BIN;
 DCL RETCODE FIXED BIN;
 DCL ENTRYPT ENTRY VARIABLE BASED(ADDR(VARTEXT));
 DCL (TEMP,NEXTWORD) CHAR(1024) VAR INIT('');
 DCL MACNAME CHAR(12);
 /* %INCLUDE GPPPSYM; */
 %NOPRINT;
 %INCLUDE GPPPSYM;
 %PRINT;
 %SKIP;
         POSITION=0;
 MACN:
         NEXTWORD=GETWORD(STRING,POSITION,RETCODE);
         IF RETCODE=8 THEN RETURN;
         IF NEXTWORD='' THEN
              CALL ERR('ERROR IN STATEMENT',STRING,POSITION);
         IF SUBSTR(STRING,POSITION,1)=':' THEN
              GO TO MACN;
         SYMBOLPTR=SCAN('%MACROS%',LEVELPTR(0));
         SYMBOLTABPTR=ADDR(STATICTEXT);
         IF RETCODE=4
            THEN
               TEMP=GETWORD(STRING,POSITION,RETCODE);
         IF RETCODE<4
            THEN
               DO;
               TEMP=GETWORD(STRING,POSITION,RETCODE);
               IF TEMP='='
                  THEN
                     NEXTWORD='%ASSIGN%';
               END;
         MACNAME=NEXTWORD;
         SYMBOLPTR=SCAN(MACNAME,SYMBOLTABPTR);
         IF SYMBOLPTR=NULL THEN
              CALL ERR('VERB NOT FOUND',STRING,POSITION);
         CALL ENTRYPT(STRING,GPPPTCA);
 END MCALLER;
 % PAGE;
 /* PROCEDURE    PARSER */
 /* FUNCTION     TO PARSE A MACRO STATEMENT AND EXTRACT THE          */
 /*          KEYWORDS AND POSITIONAL PARAMETERS.                     */
 /* LINKAGE      THIS PROCEDURE IS KNOWN IN THE TCA UNDER THE        */
 /*          ALIAS 'PARSE'. IT IS INVOKED BY                         */
 /*             CALL PARSE(STATEMENT,PARMBLOK);
 /*          WHERE STATEMENT IS A CHARACTER STRING CONTAINING A      */
 /*          MACRO CALL STATEMENT.                                   */
 /* EXTERNAL     CALLS GETWORD                                       */
 /* EXIT         FOR SYNTAX ERROR, CALLS 'ERR' TO EXIT               */
 PARSER:PROC(STRING,PARMBLOK);
 DCL STRING CHAR(1024) VAR;
 DCL POSITION FIXED BIN;
 DCL RETCODE FIXED BIN;
 DCL 1 PARMBLOK,
         2 KEYWORDS(*),
              3 PARMNAMES CHAR(12) VAR,
              3 PNUM FIXED BIN,
         2 PARAMETERS(*),
              3 PARMS CHAR(*) VAR,
              3 STATUS BIT(8) ALIGNED,
              3 SUBSCR FIXED BIN,
              3 NAMEUSED CHAR(12) VAR;
 DCL PREP   BIT(8) ALIGNED INIT('1000'B);
 DCL POSIT  BIT(8) ALIGNED INIT('0100'B);
 DCL ENDSCN BIT(8) ALIGNED INIT('0010'B);
 DCL REQ    BIT(8) ALIGNED INIT('0001'B);
 DCL ISSET  BIT(8) ALIGNED INIT('00001'B);
 DCL (NEXTWORD,VALUE) CHAR(1024) VAR INIT('');
 DCL PARM# FIXED BIN;
 DCL POSPARM FIXED BIN INIT(1);
 DCL GOTAKEY BIT INIT('0'B);
 DCL LSTPOSITION FIXED BIN;
 NAMEUSED='';
 %SKIP;
         POSITION=0;
 MACN:
         NEXTWORD=GETWORD(STRING,POSITION,RETCODE);
         IF SUBSTR(STRING,POSITION,1)=':'
              THEN
                   DO;
                   CALL SETPARM(0,NEXTWORD);
                   GO TO MACN;
                   END;
 %SKIP;
 PARMLOOP:
         NEXTWORD=GETWORD(STRING,POSITION,RETCODE);
         LSTPOSITION=POSITION-LENGTH(NEXTWORD);
         IF POSPARM>HBOUND(PARMS,1) & RETCODE<8 THEN
              CALL ERR('TOO MANY PARMS',STRING,LSTPOSITION);
         IF STATUS(POSPARM) & ENDSCN THEN RETURN;
         SELECT (RETCODE);
              WHEN (16) CALL ERR('ERROR IN CARD, SCAN IS',
                        STRING,LSTPOSITION);
              WHEN (12,8)
                   DO;
                   IF POSPARM>HBOUND(STATUS,1) THEN RETURN;
                   IF STATUS(POSPARM) & REQ THEN
                        CALL ERR('MISSING REQUIRED PARM',STRING,
                             LSTPOSITION);
                   RETURN;
                   END;
              WHEN (4)
                   DO;
                   IF (STATUS(POSPARM) & (POSIT×REQ))=(POSIT×REQ) THEN
                        DO;
                        IF SUBSCR(POSPARM)=0 THEN
                             CALL ERR('INVALID SYNTAX',
                                STRING,LSTPOSITION);
                        PARM#=SUBSCR(POSPARM);
                        CALL SETPARM(POSPARM,NEXTWORD);
                        POSPARM=POSPARM+1;
                        GO TO GOTPARM;
                        END;
                   GOTAKEY='1'B;
                        DO PARM#=1 TO HBOUND(PARMNAMES,1);
                        IF NEXTWORD=PARMNAMES(PARM#)
                             THEN GO TO GOTNAME;
                        END;
                   PUT EDIT(PARMNAMES)(COL(1),5 A(12));
                   CALL ERR('UNRECOGNIZED KEYWORD '××NEXTWORD,
                        STRING,LSTPOSITION);
 GOTNAME:
                   NAMEUSED(PNUM(PARM#))=NEXTWORD;
                   PARM#=PNUM(PARM#);
 GOTPARM:
                   VALUE=GETWORD(STRING,POSITION,RETCODE);
                   IF RETCODE>2
                        THEN
                             CALL ERR('INCOMPLETE PARAMETER',
                                      STRING,LSTPOSITION);
                   CALL SETPARM(PARM#,VALUE);
                   END;
              WHEN (2)
                   DO;
                   IF GOTAKEY THEN
                        CALL ERR('IMPROPER POSITIONAL PARM',
                             STRING,LSTPOSITION);
                   CALL SETPARM(POSPARM,NEXTWORD);
                   POSPARM=POSPARM+1;
                   END;
              WHEN (0)
                   DO;
                   IF (STATUS(POSPARM) & (POSIT×REQ))^=(POSIT×REQ) THEN
                        DO PARM#=1 TO HBOUND(PARMNAMES,1);
                        IF NEXTWORD=PARMNAMES(PARM#)
                             THEN
                                  DO;
                                  NAMEUSED(PNUM(PARM#))=NEXTWORD;
                                  PARM#=PNUM(PARM#);
                                  GOTAKEY='1'B;
                                  IF STATUS(PARM#) & PREP
                                       THEN
                                            GO TO GOTPARM;
                                  CALL SETPARM(PARM#,'');
                                  GO TO PARMLOOP;
                                  END;
                        END;
                   IF GOTAKEY THEN
                        CALL ERR('IMPROPER POSITIONAL PARM',
                             STRING,LSTPOSITION);
                   CALL SETPARM(POSPARM,NEXTWORD);
                   POSPARM=POSPARM+1;
                   END;
         END;
         GOTO PARMLOOP;
 SETPARM: PROC(I,VAL);
         DCL I FIXED BIN;
         DCL VAL CHAR(*) VAR;
         IF STATUS(I)&ISSET THEN
              CALL ERR('DUPLICATE OR EXCLUSIVE PARMS',
                   STRING,LSTPOSITION);
         STATUS(I)=STATUS(I)×ISSET;
         PARMS(I)=VAL;
         END;
 END PARSER;
 % PAGE;
 /* PROCEDURE    PUSHER */
 /* FUNCTION     PUSHES THE CURRENT SYMBOL TABLE LEVEL DOWN ONE      */
 /* LINKAGE      KNOWN IN THE TCA UNDER THE ALIAS 'PUSH'.            */
 /*             CALL PUSH(SYMBOLCOUNT);                              */
 /*          WHERE SYMBOLCOUNT IS THE MAXIMUM NUMBER OF SYMBOLS      */
 /*          IN THE MAJOR SYMBOL TABLE FOR THIS LEVEL.               */
 /* EXTERNAL     NONE                                                */
 PUSHER: PROC(SYMCOUNT);
 DCL SYMCOUNT FIXED BIN;
 /* %INCLUDE GPPPSYM; */
 %NOPRINT;
 %INCLUDE GPPPSYM;
 %PRINT;
 IF LEVEL#>=MAXLEVEL THEN
         CALL INTERR('STACK OVERFLOW');
 SYMBOLTABPTR,LEVELPTR(LEVEL#+1)=
          SYMALLOC(STPREFIXLEN+SYMCOUNT*ITEMLEN);
 LEVEL#=LEVEL#+1;
 VARCHAIN=NULL;
 MAXKEYS=SYMCOUNT;
 USEDKEYS=0;
 END PUSHER;
 % PAGE;
 /* PROCEDURE    POPPER */
 /* FUNCTION     POPS THE CURRENT SYMBOL TABLE STACK                 */
 /* LINKAGE      KNOWN IN THE TCA AS 'POP'                           */
 /*             CALL POP;                                            */
 POPPER: PROC;
 DCL MYVARPTR PTR;
 % INCLUDE GPPPSYM;
 SYMBOLTABPTR=LEVELPTR(LEVEL#);
 IF LEVEL#<0 THEN
         CALL INTERR('STACK UNDERFLOW');
         DO MYVARPTR=VARCHAIN REPEAT MYVARPTR->NEXTVAR
            WHILE(MYVARPTR^=NULL);
         MYVARPTR -> SYMPTR -> VARPTR= MYVARPTR -> BACKVAR;
         END;
 NEXTSTORE=PTRIN(LEVELPTR(LEVEL#))-STOREADDR;
 LEVEL#=LEVEL#-1;
 END;
 % PAGE;
 /* PROCEDURE    FINDER */
 /* FUNCTION     SCAN ALL MAJOR SYMBOL TABLES STARTING AT THE        */
 /*          CURRENT LEVEL FOR AN OCCURENCE OF THE NAMED SYMBOL      */
 /* LINKAGE      KNOWN IN THE TCA UNDER THE ALIAS 'FIND'             */
 /*       SYMBOLPTR= FIND(SYMBOLNAME);                               */
 /* EXTERNAL     CALLS SCAN TO DO THE WORK                           */
 FINDER: PROC(SYMNAME) RETURNS(PTR);
 DCL I FIXED BIN;
 DCL P PTR INIT(NULL);
 DCL SYMNAME CHAR(12);
         DO I=LEVEL# TO 0 BY -1 WHILE(P=NULL);
         P=SCANNER(SYMNAME,LEVELPTR(I));
         END;
 RETURN(P);
 END;
 % PAGE;
 /* PROCEDURE    SCANNER                                             */
 /* FUNCTION     EXAMINE A SPECIFIED SYMBOL TABLE FOR                */
 /*          A NAMED SYMBOL                                          */
 /* LINKAGE      THIS ROUTINE IS KNOWN IN THE TCA UNDER THE          */
 /*          ALIAS 'SCAN'.                                           */
 /*              SYMBOLPTR= SCAN(SYMBOLNAME,SYMBOLTABLEPTR);         */
 /* XTERNAL  NONE                                                    */
 SCANNER: PROC(SYMNAME,SYMBOLTABPTR) RETURNS(PTR);
 DCL SYMNAME CHAR(12);
 DCL I FIXED BIN;
 /* %INCLUDE GPPPSYM; */
 %NOPRINT;
 %INCLUDE GPPPSYM;
 %PRINT;
         DO I=1 TO USEDKEYS;
         SYMBOLPTR=ADDR(ITEM(I));
         IF SYMNAME=KEY THEN RETURN(SYMBOLPTR);
         END;
 RETURN(NULL);
 END;
 % PAGE;
 /* PROCEDURE    SYMADD */
 /* FUNCTION     ADD A NEW SYMBOL TO A SYMBOL TABLE                  */
 /* LINKAGE      THIS PROCEDURE IS KNOWN UNDER THE ALIAS 'NEWSYM'    */
 /*    SYMBOLPTR= NEWSYM(SYMBOLNAME,STATICAREASIZE,VARIABLEAREASIZE, */
 /*              SYMBOLTABLEPTR);                                    */
 /*          WHERE SYMBOLNAME IS THE NEW SYMBOL NAME                 */
 /*          STATICAREASIZE IS THE SIZE OF ITS ASSOCIATED STATIC     */
 /*          DATA AREA (MINIMUM SIZE IS 12).                         */
 /*          VARIABLEAREASIZE IS THE SIZE OF THE ASSOCIATED VARIABLE */
 /*          DATA AREA (MINIMUM SIZE IS 12).                         */
 /*          SYMBOLTABLEPTR IS NULL() IF THE SYMBOL IS TO GO IN      */
 /*          MAJOR SYMBOL TABLE AT THE CURRENT LEVEL, OR IS THE      */
 /*          ADDRESS OF THE SYMBOL TABLE THE NEW ENTRY IS TO GO IN.  */
 /* EXTERNAL     CALLS FIND AND SCAN                                 */
 SYMADD: PROC(SYMNAME,STATSIZE,VARSIZE,STPTR)
          RETURNS(PTR);
 DCL SYMNAME CHAR(12);
 DCL STATSIZE FIXED BIN;
 DCL VARSIZE FIXED BIN;
 DCL STPTR PTR;
 /* %INCLUDE GPPPSYM; */
 %NOPRINT;
 %INCLUDE GPPPSYM;
 %PRINT;
 IF STPTR^=NULL
         THEN
              SYMBOLTABPTR=STPTR;
         ELSE
              SYMBOLTABPTR=LEVELPTR(LEVEL#);
 SYMBOLPTR=SCAN(SYMNAME,SYMBOLTABPTR);
 IF SYMBOLPTR^=NULL
         THEN RETURN(NULL);
 IF USEDKEYS>=MAXKEYS THEN
         CALL INTERR('TABLE OVERFLOW');
 USEDKEYS=USEDKEYS+1;
 SYMBOLPTR=ADDR(ITEM(USEDKEYS));
 KEY=SYMNAME;
 STATICLEN=MAX(STATSIZE,12);
 VARLEN=MAX(VARSIZE,12);
 STATICPTR=SYMALLOC(STATICLEN);
 VARPTR=SYMALLOC(VARLEN);
 SYMPTR=SYMBOLPTR;
 NEXTVAR=VARCHAIN;
 VARCHAIN=VARPTR;
 BACKVAR=NULL;
 RETURN(SYMBOLPTR);
 END;
 % PAGE;
 /* PROCEDURE    SYMALLOC                                            */
 /* FUNCTION     ALLOCATES STORAGE IN THE SYMBOL TABLE FOR SOME      */
 /*          DATA AREA                                               */
 /* LINKAGE      POINTER=SYMALLOC(AREASIZE)                          */
 /* EXTERNAL     NONE                                                */
 SYMALLOC: PROC(SIZE) RETURNS(PTR);
 DCL SIZE FIXED BIN;
 DCL P PTR;
 P=PTROUT(STOREADDR+NEXTSTORE);
 NEXTSTORE=NEXTSTORE+SIZE;
 IF NEXTSTORE>MAXSTORE THEN
         CALL INTERR('SYMBOL OVERFLOW');
 RETURN(P);
 END;
 % PAGE;
 /* PROCEDURE    INTERR                                              */
 /* FUNCTION     PRINT AN INTERNAL ERROR MESSAGE ASSOCIATED          */
 /*          WITH SOME TABLE OVERFLOW, ETC.                          */
 /* LINKAGE      CALL INTERR(MESSAGE);                               */
 /* EXTERNAL     NONE                                                */
 /* EXIT         SIGNALS ERROR CONDITION AND TERMINATES PROCESSING   */
 INTERR: PROC(MSG);
 DCL MSG CHAR(*) VAR;
         DO LISTFILE=SYSPRINT,LISTING;
          PUT FILE(LISTFILE) EDIT('INTERNAL ERROR: ',MSG)(COL(1),A,A);
         END;
 CALL NULLPGM(GPPPTCA);
 SIGNAL ERROR;
 END;
 % PAGE;
 /* PROCEDURE    VARCPYER                                            */
 /* FUNCTION     PROVIDE A COPY OF THE CURRENT VARIABLE DATA         */
 /*          ASSOCIATED WITH A SYMBOL TO THE CURRENT LEVEL FOR       */
 /*          MODIFICATION BY THE MACRO.                              */
 /* LINKAGE      THIS PROCEDURE IS KNOWN IN THE TCA UNDER THE        */
 /*             ALIAS 'VARCPY'. THE CALL IS                          */
 /*                CALL VARCPY(SYMBOLPTR);                           */
 /*          WHERE SYMBOLPTR IS THE ADDRESS OF THE SYMBOLTABLE       */
 /*          ENTRY FOR THE ITEM WHOSE DATA IS TO BE COPIED. IF       */
 /*          A COPY EXISTS AT THE CURRENT LOGICAL LEVEL ALREADY,     */
 /*          WE RETURN WITHOUT DOING ANYTHING.                       */
 /*          OTHERWISE, STORAGE IS ALLOCATED AND THE APPROPRIATE     */
 /*          CHAINS ARE UPDATED.                                     */
 /* EXTERNAL     CALLS SYMALLOC                                      */
 VARCPYER: PROC(SYMBOLPTR);
 DCL P PTR;
 /* %INCLUDE GPPPSYM; */
 %NOPRINT;
 %INCLUDE GPPPSYM;
 %PRINT;
 SYMBOLTABPTR=LEVELPTR(LEVEL#);
 IF PTRIN(VARPTR)>PTRIN(LEVELPTR(LEVEL#)) THEN RETURN;
 P=SYMALLOC(VARLEN);
 P -> BACKVAR = VARPTR;
 VARPTR = P;
 SYMPTR=SYMBOLPTR;
 NEXTVAR=VARCHAIN;
 VARCHAIN=P;
 SUBSTR(VARTEXT,1,VARLEN-12)=SUBSTR(BACKVAR -> VARTEXT,1,VARLEN-12);
 RETURN;
 END;
 % PAGE;
 /* PROCEDURE    GRAMMER                                             */
 /* FUNCTIONS    ADD A GRAMMER TO THE SYSTEM, AND LINK TO IT         */
 /* LINKAGE      THIS ROUTINE IS KNOW IN THE TCA UNDER THE           */
 /*              ALIAS 'GRAMMAR'. IT IS INVOKED BY                   */
 /*                 CALL GRAMMAR(GRAMMARNAME);                       */
 /* EXTERNAL     CALLS PLILOAD TO LOAD THE GRAMMAR MODULE,           */
 /*              THEN BRANCHES TO ITS ENTRY POINT.                   */
 GRAMMER: PROC(GRAMMARNAME);
 DCL GRAMMARNAME CHAR(12);
 DCL PLILOAD ENTRY(CHAR(8),ENTRY,FIXED BIN);
 DCL RETC FIXED BIN;
 DCL ENTRYPT ENTRY VARIABLE;
 DCL ENTRYNAME CHAR(8);
 /* %INCLUDE GPPPSYM */
 %NOPRINT;
 %INCLUDE GPPPSYM;
 %PRINT;
         ENTRYNAME=SUBSTR(GRAMMARNAME,1,8);
         SYMBOLPTR=SCAN('%GRAMMARS%',LEVELPTR(0));
         SYMBOLTABPTR=ADDR(STATICTEXT);
         SYMBOLPTR=SCAN(GRAMMARNAME,SYMBOLTABPTR);
         IF SYMBOLPTR ^= NULL THEN RETURN;
         SYMBOLPTR=NEWSYM(GRAMMARNAME,12,12,SYMBOLTABPTR);
         TYPENAME='GRAMMAR';
         CALL PLILOAD(ENTRYNAME,ENTRYPT,RETC);
         IF RETC>0 THEN
              CALL INTERR('GRAMMER NOT IN LIB');
         CALL ENTRYPT(GPPPTCA);
 END;
 % PAGE;
 /* PROCEDURE    MACADDER                                            */
 /* FUNCTION     ADD A MACRO NAME AND ENTRY POINT TO THE TABLE       */
 /* LINKAGE      THIS ROUTINE IS KNOWN IN THE TCA UNDER THE          */
 /*              ALIAS 'MACADD'. IT IS CALLED BY                     */
 /*                   CALL MACADD(MACRONAME,MACROENTRY);             */
 /* EXTERNAL     NONE                                                */
 MACADDER: PROC(MACNAME,ENTRYPT) RETURNS(FIXED BIN);
 DCL MACNAME CHAR(12);
 DCL ENTRYPT ENTRY;
 DCL ENTRYENTRY ENTRY BASED(ADDR(VARTEXT));
 /* %INCLUDE GPPPSYM */
 %NOPRINT;
 %INCLUDE GPPPSYM;
 %PRINT;
         SYMBOLPTR=SCAN('%MACROS%',LEVELPTR(0));
         SYMBOLTABPTR=ADDR(STATICTEXT);
         SYMBOLPTR=SCAN(MACNAME,SYMBOLTABPTR);
         IF SYMBOLPTR ^= NULL THEN RETURN(4);
         SYMBOLPTR=NEWSYM(MACNAME,12,20,SYMBOLTABPTR);
         TYPENAME='MACRO';
         ENTRYENTRY=ENTRYPT;
         RETURN(0);
 END;
 % PAGE;
 /* PROCEDURE    GRAMMARMAC                                          */
 /* FUNCTION     IMPLIMENTS THE 'GRAMMAR' MACRO STATEMENT            */
 /*GRAMMARMAC:MACRO                                                  */
  GRAMMARMAC: PROC(STRING,GPPPTCA);
  DCL STRING CHAR(*) VAR;
  % NOPRINT;
  DCL 1 GPPPTCA CONNECTED,
  %INCLUDE GPPPTCA;
  % PRINT;
 /*PARAMETER GRAMMARN REQUIRED POSITIONAL                            */
 DCL GRAMMARNAME CHAR(12);
 /*PARSE                                                             */
  DCL 1 PARMBLOK,
      2 KEYWORDS(001),
          3 PARMN CHAR(12) VAR INIT(' '),
          3 PNUM FIXED BIN INIT(00),
     2 PARAMETERS(0:01),
          3 PARMS CHAR(256) VAR INIT('',''),
          3 STATUS BIT(8) ALIGNED INIT('0000'B,'0101'B),
          3 SUBS FIXED BIN INIT(0,0),
          3 NAMEUSED CHAR(12) VAR;
  DCL GRAMMARN CHAR(256) VAR DEF(PARMS(01));
  CALL PARSE(STRING,PARMBLOK);
 GRAMMARNAME=GRAMMARN;
 CALL GRAMMAR(GRAMMARNAME);
 END;
 % PAGE;
 /* PROCEDURE    PRINTMAC                                            */
 /* FUNCTION     IMPLIMENTS THE PRINT MACRO COMMAND                  */
 /* SYNTAX            PRINT (ON×OFF×GEN×NOGEN);                      */
 /* PRINTMAC:MACRO                                                   */
  PRINTMAC: PROC(STRING,GPPPTCA);
  DCL STRING CHAR(*) VAR;
  % NOPRINT;
  DCL 1 GPPPTCA CONNECTED,
  %INCLUDE GPPPTCA;
  % PRINT;
 /* PARAMETER  OPTION                                                */
 /* PARSE                                                            */
  DCL 1 PARMBLOK,
      2 KEYWORDS(001),
          3 PARMN CHAR(12) VAR INIT('OPTION'),
          3 PNUM FIXED BIN INIT(01),
     2 PARAMETERS(0:01),
          3 PARMS CHAR(256) VAR INIT('',''),
          3 STATUS BIT(8) ALIGNED INIT('0000'B,'0000'B),
          3 SUBS FIXED BIN INIT(0,0),
          3 NAMEUSED CHAR(12) VAR;
  DCL OPTION CHAR(256) VAR DEF(PARMS(01));
  CALL PARSE(STRING,PARMBLOK);
 IF OPTION='ON' THEN PRINTON='1'B;
 ELSE IF OPTION='OFF' THEN PRINTON='0'B;
 ELSE IF OPTION='GEN' THEN PRINTGEN='1'B;
 ELSE IF OPTION='NOGEN' THEN PRINTGEN='0'B;
 ELSE CALL NOTE(8,'INVALID PRINT OPTION');
 END;
 % PAGE;
 /* PROCEDURE    GENERMAC                                            */
 /* FUNCTION     IMPLIMENTS THE GEN   MACRO COMMAND                  */
 /* SYNTAX            GEN   "STMT";                                  */
 /* GENERMAC:MACRO (1024)                                            */
  GENERMAC: PROC(STRING,GPPPTCA);
  DCL STRING CHAR(*) VAR;
  % NOPRINT;
  DCL 1 GPPPTCA CONNECTED,
  %INCLUDE GPPPTCA;
  % PRINT;
 /* PARAMETER STMT POSITIONAL                                        */
 /* PARAMETER AUTOMATIC BIT                                          */
 /* PARSE                                                            */
  DCL 1 PARMBLOK,
      2 KEYWORDS(001),
          3 PARMN CHAR(12) VAR INIT('AUTOMATIC'),
          3 PNUM FIXED BIN INIT(02),
     2 PARAMETERS(0:02),
          3 PARMS CHAR(1024) VAR INIT('','',''),
          3 STATUS BIT(8) ALIGNED INIT('0000'B,'0100'B,'0000'B),
          3 SUBS FIXED BIN INIT(0,0,0),
          3 NAMEUSED CHAR(12) VAR;
  DCL STMT CHAR(1024) VAR DEF(PARMS(01));
  DCL AUTOMATIC BIT;
  CALL PARSE(STRING,PARMBLOK);
  AUTOMATIC=NAMEUSED(02)='AUTOMATIC';
 IF STMT=''
         THEN
              DO;
              BLKGEN='1'B;
              GENAUTO=AUTOMATIC;
              END;
         ELSE
              DO;
              IF AUTOMATIC
                   THEN
                        GENAUTO='1'B;
              CALL GEN(STMT);
              GENAUTO='0'B;
              END;
 END;
 % PAGE;
 /* PROCEDURE    INCLDMAC                                            */
 /* FUNCTION     IMPLIMENTS THE INCLUDE MACRO COMMAND                */
 /* SYNTAX            INCLUDE MEMBERNAME                             */
 /*INCLDMAC: MACRO                                                   */
  INCLDMAC: PROC(STRING,GPPPTCA);
  DCL STRING CHAR(*) VAR;
  % NOPRINT;
  DCL 1 GPPPTCA CONNECTED,
  %INCLUDE GPPPTCA;
  % PRINT;
 /*PARAMETER MEMBERNAME REQUIRED POSITIONAL                          */
 /*PARSE                                                             */
  DCL 1 PARMBLOK,
      2 KEYWORDS(001),
          3 PARMN CHAR(12) VAR INIT(' '),
          3 PNUM FIXED BIN INIT(00),
     2 PARAMETERS(0:01),
          3 PARMS CHAR(256) VAR INIT('',''),
          3 STATUS BIT(8) ALIGNED INIT('0000'B,'0101'B),
          3 SUBS FIXED BIN INIT(0,0),
          3 NAMEUSED CHAR(12) VAR;
  DCL MEMBERNAME CHAR(256) VAR DEF(PARMS(01));
  CALL PARSE(STRING,PARMBLOK);
 MEMBER=MEMBERNAME;
 TTRSAVE(INCL#)=TTR;
 RECSAVE(INCL#)=REC#;
 INCL#=INCL#+1;
 IF INCL#>10 THEN CALL INTERR('INCLUDE STACK');
 REQUEST=REQMEM;
 REC#=0;
 CALL SYSLIBR(SYSLBBLK);
 IF ERRORS&ERROPN THEN CALL INTERR('CANT OPEN SYSLIB');
 IF ERRORS THEN
         DO;
         CALL NOTE(8,'INCLUDED MEMBER NOT FOUND');
         INCL#=INCL#-1;
         TTR=TTRSAVE(INCL#);
         REC#=RECSAVE(INCL#);
         REQUEST=REQREC;
         CALL SYSLIBR(SYSLBBLK);
         IF ERRORS THEN CALL INTERR('SYSLIB READ ERROR');
         END;
 END;
 % PAGE;
 /*PAGEMAC:MACRO                                                     */
  PAGEMAC: PROC(STRING,GPPPTCA);
  DCL STRING CHAR(*) VAR;
  % NOPRINT;
  DCL 1 GPPPTCA CONNECTED,
  %INCLUDE GPPPTCA;
  % PRINT;
 SIGNAL ENDPAGE(LISTING );
 IF LANGUAGE='BAL' THEN CALL GEN('         EJECT');
 ELSE IF LANGUAGE='PLI' THEN CALL GEN(' %PAGE;');
 END;
 % PAGE;
 /* TITLEMAC:MACRO                                                   */
  TITLEMAC: PROC(STRING,GPPPTCA);
  DCL STRING CHAR(*) VAR;
  % NOPRINT;
  DCL 1 GPPPTCA CONNECTED,
  %INCLUDE GPPPTCA;
  % PRINT;
 /* PARAMETER TITLER                                                 */
 /* PARSE                                                            */
  DCL 1 PARMBLOK,
      2 KEYWORDS(001),
          3 PARMN CHAR(12) VAR INIT('TITLER'),
          3 PNUM FIXED BIN INIT(01),
     2 PARAMETERS(0:01),
          3 PARMS CHAR(256) VAR INIT('',''),
          3 STATUS BIT(8) ALIGNED INIT('0000'B,'0000'B),
          3 SUBS FIXED BIN INIT(0,0),
          3 NAMEUSED CHAR(12) VAR;
  DCL TITLER CHAR(256) VAR DEF(PARMS(01));
  CALL PARSE(STRING,PARMBLOK);
  TITLE=TITLER;
 END TITLEMAC;
 % PAGE;
 NUMBERS:PROC(STRING,WORD) RETURNS(FIXED BIN);
 DCL STRING CHAR(*) VAR;
 DCL WORD CHAR(*) VAR;
 IF STRING='' THEN GO TO BADNUM;
 ON CONVERSION
         BEGIN;
         CALL NOTE(12,'INVALID NUMBER '''××ONSOURCE××''' FOR '××WORD);
         GO TO BADNUM;
         END;
 RETURN(STRING);
 BADNUM:
         RETURN(0);
 END NUMBERS;
 % PAGE;
 /*PROCESSMAC: MACRO                                                 */
  PROCESSMAC: PROC(STRING,GPPPTCA);
  DCL STRING CHAR(*) VAR;
  % NOPRINT;
  DCL 1 GPPPTCA CONNECTED,
  %INCLUDE GPPPTCA;
  % PRINT;
 /*PARAMETER LANG REQUIRED POSITIONAL                                */
 /*PARAMETER MARGINS FIXED LIST                                      */
 /*PARAMETER SEQ FIXED DEFAULT(0)                                    */
 /*PARAMETER INCR FIXED DEFAULT(0)                                   */
 /*PARAMETER ID                                                      */
 /*PARAMETER ANNOTATE                                                */
 /*PARAMETER DEBUG DEFAULT(NO)                                       */
 /*PARAMETER GRAMMARS LIST                                           */
 DCL GRAMMARNAME CHAR(12);
 /*PARSE                                                             */
  DCL 1 PARMBLOK,
      2 KEYWORDS(007),
          3 PARMN CHAR(12) VAR INIT('MARGINS','SEQ','INCR','ID','ANNOTAT
 E','DEBUG','GRAMMARS'),
          3 PNUM FIXED BIN INIT(02,03,04,05,06,07,08),
     2 PARAMETERS(0:08),
          3 PARMS CHAR(256) VAR INIT('','','','0','0','','','NO',''),
          3 STATUS BIT(8) ALIGNED INIT('0000'B,'0101'B,'0000'B,'0000'B,'
 0000'B,'0000'B,'0000'B,'0000'B,'0000'B),
          3 SUBS FIXED BIN INIT(0,0,0,0,0,0,0,0,0),
          3 NAMEUSED CHAR(12) VAR;
  DCL LANG CHAR(256) VAR DEF(PARMS(01));
  DCL MARGINS FIXED BIN;
  DCL SEQ FIXED BIN;
  DCL INCR FIXED BIN;
  DCL ID CHAR(256) VAR DEF(PARMS(05));
  DCL ANNOTATE CHAR(256) VAR DEF(PARMS(06));
  DCL DEBUG CHAR(256) VAR DEF(PARMS(07));
  DCL GRAMMARS CHAR(256) VAR;
  DCL NEXTWORD CHAR(256) VAR;
  DCL POSITION FIXED BIN;
  DCL RETCODE FIXED BIN;
  CALL PARSE(STRING,PARMBLOK);
  SEQ=NUMBER(PARMS(03),'SEQ');
  INCR=NUMBER(PARMS(04),'INCR');
 LANGUAGE=LANG;
 IF PARMS(2)='' THEN GO TO MARGPARM;
 /*OPEN MARGINS                                                      */
  POSITION=0;
 /*GET MARGINS                                                       */
  NEXTWORD=GETWORD(PARMS(02),POSITION,RETCODE);
  MARGINS=NUMBER(NEXTWORD,'MARGINS');
 IF MARGINS<1 THEN CALL NOTE(12,'INVALID MARGINS');
 LMARG=MARGINS;
 /*GET MARGINS                                                       */
  NEXTWORD=GETWORD(PARMS(02),POSITION,RETCODE);
  MARGINS=NUMBER(NEXTWORD,'MARGINS');
 IF MARGINS>255 THEN CALL NOTE(12,'INVALID MARGINS');
 RMARG=MARGINS;
 MARGPARM:
 SEQSTART=SEQ;
 SELECTER:
 SELECT=ID;
 IF ANNOTATE='OFF' THEN ANNOT='0'B;
 ELSE IF ANNOTATE='ON' THEN ANNOT='1'B;
 ELSE IF ANNOTATE^='' THEN
         CALL NOTE(8,'INVALID ANNOTATE OPTION');
 IF DEBUG='' THEN DEBUGER='1'B;
 /*OPEN GRAMMARS                                                     */
  POSITION=0;
 /*GET GRAMMARS                                                      */
  NEXTWORD=GETWORD(PARMS(08),POSITION,RETCODE);
  GRAMMARS=NEXTWORD;
     DO WHILE(GRAMMARS^='');
     GRAMMARNAME=GRAMMARS;
     CALL GRAMMAR(GRAMMARNAME);
 /*  GET GRAMMARS                                                    */
  NEXTWORD=GETWORD(PARMS(08),POSITION,RETCODE);
  GRAMMARS=NEXTWORD;
     END;
 END PROCESSMAC;
 % PAGE;
 /* PROCEDURE    GETWORD                                             */
 /* FUNCTION     RETURN THE NEXT WORD OR SUBSTRING OF THE            */
 /*              CURRENT MACRO STATEMENT.                            */
 /* LINKAGE      NEXTWORD=GETWORD(STRING,POSITION,RETCODE);          */
 /*              WHERE                                               */
 /*              STRING IS A CHARACTER STRING CONTAINING A MACRO     */
 /*              STATEMENT                                           */
 /*              POSITION IS THE CHARACTER OFFSET IN STRING TO BEGIN */
 /*              THE SYNTAX SCAN.                                    */
 /*              NEXTWORD RECEIVES THE NEXT 'WORD' (DEFINED BELOW).  */
 /*              RETCODE RECEIVES THE RETURN CODE.                   */
 /* SYNTAX       A 'WORD' IS DELIMITED BY THE FOLLOWING:             */
 /*              1) IF THE FIRST NON-BLANK CHARACTER IS '(', THEN    */
 /*                 THE WORD ENDS WHEN A BALENCING ')' IS FOUND.     */
 /*              2) IF IT STARTS WITH DOUBLE QUOTE '"', THEN THE     */
 /*                 WORD ENDS WHEN ANOTHER DOUBLE QUOTE IS FOUND     */
 /*                 WHICH IS NOT IMMEDIATELY FOLLOWED BY A SECOND    */
 /*                 DOUBLE QUOTE. TWO ADJACENT DOUBLE QUOTES         */
 /*                 PRODUCE ONE DOUBLE QUOTE IN THE RETURNED         */
 /*                 STRING.                                          */
 /*              3) IF A DOUBLE QUOTE IS FOUND IN PARENTHESES,       */
 /*                 THEN THE SCAN PROCEEDS AS IN RULE 2) UNTIL       */
 /*                 THE QUOTE ENDS, AND PARENTHESES IN THE QUOTE     */
 /*                 ARE IGNORED, BUT AFTER THE QUOTE ENDS, THE       */
 /*                 SCAN CONTINUES TILL THE PARENTHESES ARE MATCHED. */
 /*              4) OTHERWISE (IE, THE FIRST CHAR IS A LETTER OR     */
 /*                 DIGIT, ETC), THE SCAN PROCEEDS UNTIL ONE OF      */
 /*                 FOUR CHARACTERS ARE FOUND: BLANK, COLON,         */
 /*                 OPEN PARENTHESES, OR SEMICOLON.                  */
 /*              THIS IS GOOD FOR PARSING STATEMENTS OF THE FORM     */
 /*             LABEL: MACRONAME POSIT POSIT KEYWORD(VALUE) KEYWORD; */
 /* RETURN       0 = WORD ENCOUNTERED (IE RULE 4 ABOVE)              */
 /*              2 = OBJECT WAS IN () OR QUOTES                      */
 /*              4 = OBJECT WAS WORD AND ENDED IN '('                */
 /*              8 = OBJECT WAS ';'                                  */
 /*              12= END OF STRING AND NO ';'                        */
 /*              16= SYNTAX ERROR                                    */
 GETWORDER: PROC(STRING,POSITION,RETCODE) RETURNS(CHAR(1024) VAR);
 DCL STRING CHAR(*) VAR;
 DCL POSITION FIXED BIN;
 DCL RETCODE FIXED BIN;
 DCL STRLEN FIXED BIN;
 DCL RETSTR CHAR(1024) VAR INIT('');
 DCL PAREN FIXED BIN INIT(0);
 DCL CH CHAR(1);
 DCL I FIXED BIN;
 DCL COMMA BIT(1) ALIGNED;
 DCL (LENGTH,SUBSTR) BUILTIN;
         STRLEN=LENGTH(STRING);
 % PAGE;
 /* BLOCK: PREWORD                                                   */
 /* FUNCTION: SKIPS BLANKS AND MAYBE 1 COMMA BEFORE A WORD           */
 /* ENTRY:                                                           */
 /*    POSITION POINTS TO NEXT CHAR OR PAST END OF STRING            */
 /* EXIT:                                                            */
 /*    FALLS THROUGH TO NEXTSCAN WITH UPDATED POSITION               */
 %SKIP;
 PREWORD:
         COMMA='0'B;
         IF POSITION>0 & POSITION<STRLEN
              THEN
                   IF SUBSTR(STRING,POSITION,1)='('
                        THEN
                             POSITION=POSITION-1;
              DO POSITION=POSITION+1 TO STRLEN;
              CH=SUBSTR(STRING,POSITION,1);
              IF CH=','
                   THEN
                        IF COMMA
                             THEN
                                  DO;
                                  RETCODE=0;
                                  RETURN('');
                                  END;
                        ELSE
                             COMMA='1'B;
                   ELSE
                        IF CH^=' '
                             THEN
                                  LEAVE;
              END;
 % PAGE;
 /* BLOCK: NEXTSCAN                                                  */
 /* FUNCTION: DETERMINE WHAT IS NEXT                                 */
 /* ENTRY:                                                           */
 /*   POSITION POINTS TO NEXT NON-BLANK, OR PAST END OF STRING       */
 /* EXIT:                                                            */
 /*   GO THE THE RIGHT BLOCK DEPENDING ON THE NEXT CHAR              */
 /*   CHAR   MEANING                                                 */
 /*   ;      END OF STATEMENT                                        */
 /*   (      PARENTHESIS VALUE                                       */
 /*   "      QUOTED VALUE                                            */
 /*   A-Z@$# KEYWORD OR POSITIONAL                                   */
 /*   POSITION IS INCREMENTED FOR '(' OR '"'                         */
 /*   IF WE ARE PAST END OF STRING ON ENTRY, RETURN '' RC=12         */
 %SKIP;
         RETCODE=12;
         IF POSITION>STRLEN THEN RETURN('');
 %SKIP;
         RETCODE=16;
         CH=SUBSTR(STRING,POSITION,1);
         IF CH=';'
              THEN
                   DO;
                   RETCODE=8;
                   RETURN('');
                   END;
         IF CH='('
              THEN
                   DO;
                   PAREN=1;
                   POSITION=POSITION+1;
                   GO TO PARENTHESES;
                   END;
         IF CH='"'
              THEN
                   DO;
                   POSITION=POSITION+1;
                   GO TO QUOTE;
                   END;
 % PAGE;
 /* BLOCK: WORD                                                      */
 /* FUNCTION: TO ANALYZE A KEYWORD OR POSITIONAL PARM NOT            */
 /*     IN QUOTES                                                    */
 /* ENTRY:                                                           */
 /*     POSITION POINTS TO FIRST LETTER                              */
 /* EXIT:                                                            */
 /*     WHEN NEXT CHAR IS NOT ALPHAMERICNATIONAL,                    */
 /*     RETURN INTERVENING CHARACTERS. IF NEXT CHAR                  */
 /*     IS '(', SIGNAL KEYWORD BY RC=4                               */
 %SKIP;
 WORD:
         RETSTR=CH;
              DO POSITION=POSITION+1 TO STRLEN;
              CH=SUBSTR(STRING,POSITION,1);
              IF CH=' ' × CH=':' × CH='(' × CH=';' × CH=','
                   THEN
                        GO TO ENDWORD;
                   ELSE
                        RETSTR=RETSTR××CH;
              END;
 ENDWORD:
         RETCODE=0;
         IF POSITION<=STRLEN
              THEN
                   IF CH='('
                        THEN
                             RETCODE=4;
         RETURN(RETSTR);
 % PAGE;
 /* BLOCK: PARENTHESES                                               */
 /* FUNCTION: PROCESS A VALUE STRING TILL PARENS MATCH.              */
 /* ENTRY:                                                           */
 /*   POSITION POINTS PAST FIRST PAREN                               */
 /*   PAREN=1                                                        */
 /* ENTRY ALSO FROM QUOTE WITH                                       */
 /*   POSITION PAST "                                                */
 /*   PAREN UNCHANGED                                                */
 /* EXIT:                                                            */
 /*   IF A " IS HIT, GO TO QUOTE WITH PAREN>0                        */
 %SKIP;
 PARENTHESES:
              DO POSITION=POSITION TO STRLEN;
              CH=SUBSTR(STRING,POSITION,1);
              IF CH=';'
                   THEN
                        DO;
                        RETCODE=16;
                        RETURN('');
                        END;
              IF CH='('
                   THEN
                        PAREN=PAREN+1;
              IF CH=')'
                   THEN
                        DO;
                        PAREN=PAREN-1;
                        IF PAREN=0 THEN GO TO PAREND;
                        END;
              IF CH='"'
                   THEN
                        DO;
                        POSITION=POSITION+1;
                        GO TO QUOTE;
                        END;
              RETSTR=RETSTR××CH;
              END;
 PAREND:
         RETCODE=2;
         RETURN(RETSTR);
 % PAGE;
 /* BLOCK: QUOTE                                                     */
 /* FUNCTION: TO PROCESS QUOTED BLOCK                                */
 /* ENTRY:                                                           */
 /*   POSITION POINTS PAST OPENING "                                 */
 /* EXIT:                                                            */
 /*   COMPRESS "" TO A SINGLE "                                      */
 /*   TERMINATE WHEN SINGLE " ENCOUNTERED                            */
 %SKIP;
 QUOTE:
         IF PAREN>0 THEN RETSTR=RETSTR××'"';
         DO POSITION=POSITION TO STRLEN;
         CH=SUBSTR(STRING,POSITION,1);
         IF CH='"'
              THEN
                   DO;
                   IF PAREN>0 THEN
                        RETSTR=RETSTR××'"';
                   IF POSITION=STRLEN
                        THEN
                             GOTO ENDQUOTE;
                        ELSE
                             IF SUBSTR(STRING,POSITION+1,1)='"'
                              THEN
                               DO;
                               RETSTR=RETSTR××'"';
                               POSITION=POSITION+1;
                               END;
                              ELSE
                               GOTO ENDQUOTE;
                   END;
              ELSE
                   RETSTR=RETSTR××CH;
         END;
 ENDQUOTE:
         IF POSITION>STRLEN
              THEN
                   DO;
                   RETCODE=16;
                   RETURN('');
                   END;
         POSITION=POSITION+1;
         IF PAREN>0 THEN GO TO PARENTHESES;
         RETCODE=2;
         RETURN(RETSTR);
 %SKIP;
 END GETWORDER;
 END GPPP;
