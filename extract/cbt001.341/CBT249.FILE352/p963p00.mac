        /* DATA SET S963P00    AT LEVEL 005 AS OF 03/31/81    */
        /* DATA SET S963P00    AT LEVEL 004 AS OF 05/24/78    */
        /* DATA SET S963P00    AT LEVEL 002 AS OF 11/15/77    */
 P963P00: /* DASD MONITOR PROGRAM   VERSION V2M0                     */
          PROC(PARM) OPTIONS(MAIN) REORDER;
 /*                                                                  */
 /* THIS PROGRAM READS THE DSNLOG PRODUCED BY MAPDISK, AND           */
 /* COMPARES IT TO THE GRANT DATASET TO VALIDATE DATASETS ON DISK    */
 /* PACKS.   BOTH DSNLOG AND GRANT MUST BE SORTED BY THE FOLLOWING   */
 /* KEYS.:                                                           */
 /*                                                                  */
 /*   1 DSNAME, 2 VOLUME                                             */
 /*                                                                  */
 /* THE PROGRAM PRODUCES 3 OUTPUT DATASETS FOR SUBSEQUENT PROCESSING */
 /*                                                                  */
 /*  1) VIA OUTLOG DDCARD, A MERGED GRANT/INLOG DATASET IS PRODUCED  */
 /*     FOR PROCESSING VIA MARK IV.  SEE OUTREC DCL FOR FORMAT.      */
 /*                                                                  */
 /*  2) VIA VOLSUM DDCARD, THE SUMMARY VOLUME STATISTICS ARE OUTPUT */
 /*     ALONG WITH SOME FLAGS SO HISTORICAL TRENDING OF VOLUME STATS */
 /*     CAN BE PERFORMED BY OTHER PROGRAMS.                          */
 /*                                                                  */
 /*  3) VIA OUTSCR DDCARD, SCRLOG CARDS ARE PRODUCED WHICH WHEN      */
 /*     LATER PROCESSED VIA P963P02, WILL PRODUCE IEHPROGM           */
 /*     SCRATCH AND UNCALG CARDS TO DISPOSE OF OFFENDING DATASETS.   */
 /*                                                                  */
 /*                                                                  */
 /*                                                                  */
 /*  K TRUE  21 SEPT 77.             V1M2   3 OCT 77                 */
 /*                                  V1M3  19 OCT 77                 */
 /*                                  V1M4  22 OCT 77                 */
 /*                                  V1M5   7 NOV 77                 */
 /*                                  V1M6  10 NOV 77                 */
 /*                                  V1M7  14 NOV 77                 */
 /*         MSS SUPPORT ADDED        V2M0  16 FEB 78                 */
 /*  B WILLIAMS  14 JAN 79.          V2M1  22 JAN 79                 */
 /*                                                                  */
 /*                                                                  */
 /*                                                                  */
1DCL R941X11 EXTERNAL ENTRY            /* GREGORIAN TO JULIAN DATE*/
             OPTIONS(ASSEMBLER,INTER);

 DCL R941X12 EXTERNAL ENTRY            /* JULIAN TO GREGORIAN DATE*/
             OPTIONS(ASSEMBLER,INTER);

 DCL R963A11 EXTERNAL ENTRY            /* CATALOG CHECKER V2M0    */
             OPTIONS(ASSEMBLER,INTER);

 DCL FINDENQ EXTERNAL ENTRY            /* SYSDSN ENQUEUE SCANNER  */
             OPTIONS(ASSEMBLER,INTER);


 DCL (DATE,TIME)    BUILTIN;
 DCL PARM   CHAR(100) VARYING,
     DEBUG  BIT(1)    INIT('0'B);
 DCL INLOG    FILE  RECORD SEQUENTIAL INPUT  ENV(CONSECUTIVE);
 DCL OUTLOG   FILE  RECORD SEQUENTIAL OUTPUT ENV(CONSECUTIVE);
 DCL INGRANT  FILE  RECORD SEQUENTIAL INPUT  ENV(CONSECUTIVE);
 DCL VOLSUM   FILE  RECORD SEQUENTIAL OUTPUT ENV(CONSECUTIVE);
 DCL OUTSCR   FILE  RECORD SEQUENTIAL OUTPUT ENV(CONSECUTIVE);
 DCL REPORT   FILE  STREAM PRINT OUTPUT;
 DCL SCRRPT   FILE  STREAM PRINT OUTPUT;

1DCL 1 DSNLOG,                     /* RECORD GENERATED BY MAPDISK    */
       2 DSNAME      CHAR(44),
       2 MSVGP       CHAR(8),
       2 VOLUME      CHAR(6),
       2 DEVICE      CHAR(8),
       2 UNITYPE     BIT(8),
       2 EXTNTS      BIT(8),
       2 DSORG       CHAR(3),
       2 RECFM       CHAR(4),
       2 SALLC_TYPE  CHAR(1),
       2 SALLC_QTY   FIXED BIN(15,0),
       2 LRECL       FIXED BIN(15,0),
       2 BLKSIZE     FIXED BIN(15,0),
       2 TRK_ALLOC   FIXED BIN(15,0),
       2 TRK_USED    FIXED BIN(15,0),
       2 DIR_ALLOC   FIXED BIN(15,0),
       2 DIR_USED    FIXED BIN(15,0),
       2 USE_COUNT   FIXED BIN(15,0),
       2 CREATED     FIXED DEC(5),
       2 LAST_USED   FIXED DEC(5),
       2 LAST_MOD    FIXED DEC(5),
       2 LAST_MOD_TIME BIT(16),
       2 EXP_DATE    FIXED DEC(5),
       2 MOD_USER    CHAR(8);

 DCL 1 GRANT,              /* RECORD GENERATED BY HAND (OR GENGRANT) */
       2 DSNAME      CHAR(44),
       2 VOLUME      CHAR(6),
       2 DSORG       CHAR(2),
       2 OKUNCAT     CHAR(1),
       2 TRACKS      PIC'ZZZZ9'  INIT(0),
       2 BILL_TO     CHAR(8),
       2 EXPIRES     PIC'ZZZZZZ' INIT(0),
       2 MSVGP       CHAR(8);

 DCL 1 OUTREC,                     /* MERGED OUTLOG RECORD           */
       2 DSNAME      CHAR(44)         INIT(' '),
       2 MSVGP       CHAR(8)          INIT(' '),
       2 VOLUME      CHAR(6)          INIT(' '),
       2 DEVICE      CHAR(8)          INIT(' '),
       2 DISKTYPE    CHAR(1)          INIT(' '),
       2 EXTNTS      BIT(8)           INIT((8)'0'B),
       2 DSORG       CHAR(3)          INIT(' '),
       2 RECFM       CHAR(4)          INIT(' '),
       2 SALLC_TYPE  CHAR(1)          INIT(' '),
       2 SALLC_QTY   FIXED BIN(15,0)  INIT(0),
       2 LRECL       FIXED BIN(15,0)  INIT(0),
       2 BLKSIZE     FIXED BIN(15,0)  INIT(0),
       2 TRK_ALLOC   FIXED BIN(15,0)  INIT(0),
       2 TRK_USED    FIXED BIN(15,0)  INIT(0),
       2 DIR_ALLOC   FIXED BIN(15,0)  INIT(0),
       2 DIR_USED    FIXED BIN(15,0)  INIT(0),
       2 USE_COUNT   FIXED BIN(15,0)  INIT(0),
       2 DAYS_UNUSED FIXED BIN(15,0)  INIT(0),
       2 CREATED     FIXED DEC(5)     INIT(0),
       2 LAST_USED   FIXED DEC(5)     INIT(0),
       2 LAST_MOD    FIXED DEC(5)     INIT(0),
       2 LAST_MOD_TIME BIT(16)        INIT((16)'0'B),
       2 EXP_DATE    FIXED DEC(5)     INIT(0),
       2 MOD_USER    CHAR(8)          INIT(' '),
       2 BILL_TO     CHAR(8)          INIT(' '),
       2 DSNFLAGS    CHAR(8)          INIT(' '),
       2 SCRFLAG     CHAR(1)          INIT(' '),
       2 PC_USED     FIXED DEC(5)     INIT(0),
       2 EXPIRES     PIC'ZZZZZZ'      INIT(0);

 DCL 1 OUT_V#,                           /* SUMMARY VOL STATS RECORD */
       2 VOLUME      CHAR(6)           INIT(' '),
       2 SCRFLAG     BIT(8)            INIT('00000000'B),
       2 LOGDATE     FIXED DEC(5)      INIT(0),
       2 LOGTIME     FIXED DEC(7)      INIT(0),
       2 TRK_MAX     FIXED BIN(31,0)   INIT(0),
       2 TRK_ALLOC   FIXED BIN(31,0)   INIT(0),
       2 TRK_RSVD    FIXED BIN(31,0)   INIT(0),
       2 TRK_WASTE   FIXED BIN(31,0)   INIT(0),
       2 TRK_UNUSED  FIXED BIN(31,0)   INIT(0),
       2 TRK_EXPIRED FIXED BIN(31,0)   INIT(0),
       2 TRK_SCR     FIXED BIN(31,0)   INIT(0),
       2 #OK_DSN     FIXED BIN(15,0)   INIT(0),
       2 #BOZO_DSN   FIXED BIN(15,0)   INIT(0),
       2 #SCR_DSN    FIXED BIN(15,0)   INIT(0),
       2 #_DSN       FIXED BIN(15,0)   INIT(0);


 DCL 1 SCRLOG,             /* SCRATCH LOG  USED BY P963P02           */
       2 DSNAME      CHAR(44)     INIT(' '),
       2 VOLUME      CHAR(6)      INIT(' '),
       2 FLAGS       CHAR(2)      INIT(' '),
       2 BILL_TO     CHAR(8)      INIT(' '),
       2 LAST_USED   PIC'ZZZZZ'   INIT(0),
       2 MOD_USER    CHAR(8)      INIT(' '),
       2 DEVICETYP   CHAR(7)      INIT(' ');


 DCL 1 SCRPARMS,           /* FIRST RECORD IN OUTSCR DATASET         */
       2 FILL1       CHAR(1)      INIT(' '),
       2 HEAD1       CHAR(8)      INIT('MON RUN='),
       2 $RUN_DATE   PIC'Z9/99/99' INIT(0),
       2 FILL2       CHAR(1)      INIT(' '),
       2 $RUN_TIME   PIC'Z9.99.99' INIT(0),
       2 HEAD2       CHAR(9)      INIT(' SCRATCH='),
       2 $SCR_DATE   PIC'Z9/99/99' INIT(0),
       2 HEAD3       CHAR(8)      INIT(' REASON='),
       2 $SCR_CODES  CHAR(8)      INIT(' '),
       2 FILL3       CHAR(21)     INIT(' ');



 DCL #V#      FIXED BIN(15,0) INIT(40); /* MUST BE SAME AS DIM OF */
                                        /*                        */
 DCL 1 V#     (0:40),                   /* <== V#..(0) NOT USED   */
       2 VOLUME      CHAR(6), /* */
       2 TRK_MAX     FIXED BIN(31,0),
       2 TRK_ALLOC   FIXED BIN(31,0), /* ACCUM VOLUME STATISTICS*/
       2 TRK_RSVD    FIXED BIN(31,0),
       2 TRK_WASTE   FIXED BIN(31,0),
       2 TRK_UNUSED  FIXED BIN(31,0),
       2 TRK_EXPIRED FIXED BIN(31,0),
       2 TRK_SCR     FIXED BIN(31,0),
       2 #OK_DSN     FIXED BIN(15,0),
       2 #BOZO_DSN   FIXED BIN(15,0),
       2 #SCR_DSN    FIXED BIN(15,0),
       2 #_DSN       FIXED BIN(15,0),
     VIDX            FIXED BIN(15,0) INIT(0),
     T#3330V         CHAR(8)  INIT('3330V   '),
     T#3350          CHAR(8)  INIT('3350    '),
     T#3330#1        CHAR(8)  INIT('3330-1  ');

 DCL 1 TOTALS,                /* TOTALS BUCKETS FOR VOLUME STATISTICS */
       2 TRK_MAX     FIXED BIN(31,0) INIT(0),
       2 TRK_ALLOC   FIXED BIN(31,0) INIT(0),
       2 TRK_RSVD    FIXED BIN(31,0) INIT(0),
       2 TRK_WASTE   FIXED BIN(31,0) INIT(0),
       2 TRK_UNUSED  FIXED BIN(31,0) INIT(0),
       2 TRK_EXPIRED FIXED BIN(31,0) INIT(0),
       2 TRK_SCR     FIXED BIN(31,0) INIT(0),
       2 #OK_DSN     FIXED BIN(15,0) INIT(0),
       2 #BOZO_DSN   FIXED BIN(15,0) INIT(0),
       2 #SCR_DSN    FIXED BIN(15,0) INIT(0),
       2 #_DSN       FIXED BIN(15,0) INIT(0),
     NUMVOLS         FIXED BIN(15,0) INIT(0);

 DCL 1 STATLINE,                      /* PRINT LINE FOR SUMMARY STATS*/
       2 FILL1       CHAR(1)         INIT(' '),
       2 VOLUME      CHAR(6)         INIT(' '),
       2 TRK_MAX     PIC'ZZZZ,ZZ9'   INIT(0),
       2 TRK_ALLOC   PIC'ZZZZ,ZZ9'   INIT(0),
       2 TRK_RSVD    PIC'ZZZZ,ZZ9'   INIT(0),
       2 TRK_WASTE   PIC'ZZZZ,ZZ9'   INIT(0),
       2 TRK_UNUSED  PIC'ZZZZ,ZZ9'   INIT(0),
       2 TRK_EXPIRED PIC'ZZZZ,ZZ9'   INIT(0),
       2 TRK_SCR     PIC'ZZZZ,ZZ9'   INIT(0),
       2 PC_FULL     PIC'ZZZZZ9.9'   INIT(0),
       2 PC_FULL_SCR PIC'ZZZZZ9.9'   INIT(0),
       2 FILL3       CHAR(1)         INIT(' '),
       2 #OK_DSN     PIC'ZZZZZZZ9'   INIT(0),
       2 #BOZO_DSN   PIC'ZZZZZZZ9'   INIT(0),
       2 #SCR_DSN    PIC'ZZZZZZZ9'   INIT(0),
       2 #_DSN       PIC'ZZZZZZZ9'   INIT(0),
    SSTATLINE     DEFINED STATLINE   CHAR(112);


 DCL (INREC_LOG,INREC_GRANT,INREC_NOTFOUND,RECOUT_OUTLOG,
      RPTPAGENO,SCRPAGENO,
      RECOUT_OUTSCR,I,J,K,COMPLEN,L,
      GENERIC_TRACKS,GENERIC_DATASETS,GENERIC_TRKS_MAX,GENERIC_DSN_MAX)
                     FIXED BIN(15,0) INIT(0);

 DCL RETURN_CODE  FIXED BIN(31,0) INIT(0);

  DCL PACK4       PIC'9999'     INIT(0),
      PACK5       PIC'99999'    INIT(0),
      PACK6       PIC'999999'   INIT(0),
      PACK8       PIC'99999999' INIT(0),
      $SCRDATE    PIC'Z9/99/99' INIT(0),
      $CREATED    PIC'Z9/99/99' INIT(0),
      $USED       PIC'Z9/99/99' INIT(0),
      $EXPIRED    PIC'Z9/99/99' INIT(0),
      $MOD_DATE   PIC'Z9/99/99' INIT(0),
      $MOD_TIME   PIC'Z9.99'    INIT(0),
      $RETPD_DATE PIC'Z9/99/99' INIT(0),
      $USE_INFO   CHAR(66) VAR  INIT(''),
      CATALOG_VOLUME  CHAR(6)  INIT('      '),
      $CAT_INFO   CHAR(44) VAR  INIT(''),
      UNUSED_DAYS FIXED BIN(15,0) INIT(0),
      TODAY_JDAYS FIXED BIN(31,0) INIT(0),
      SCR_JDAYS    FIXED BIN(31,0) INIT(0),
      SCRATCH_DAYS FIXED BIN(31,0) INIT(1);

  DCL EOF_INLOG      BIT(1)   INIT('0'B),
      EOF_INGRANT    BIT(1)   INIT('0'B),
      EOF_SYSIN      BIT(1)   INIT('0'B),
      FINISHED       BIT(1)   INIT('0'B),
      GENERIC_DSN    BIT(1)   INIT('0'B),
      TIMESTAMPED    BIT(1)   INIT('0'B),
      SYSTEM_DATASET BIT(1)   INIT('0'B),
      DO_CATCHK      BIT(1)   INIT('1'B),
      BIT16          BIT(16)  INIT('0'B);

  DCL 1 OPTIONS(8),
        2 TEXT       CHAR(10) VAR
            INIT('UNAUTHED', 'UNCATLGD', 'UNUSED',    'TOOBIG',
                 'EXPIRED',  'OVERALLOC','PASTRETPD', ''        ),
        2 BIT        BIT(8)
            INIT('10000000'B,'01000000'B,'00100000'B,'00010000'B,
                 '00001000'B,'00000100'B,'00000010'B,'00000001'B);

  DCL SCR            BIT(8)   INIT('11000010'B),
      SCR_UNAUTHED   BIT(1) DEF(SCR) POS(1),    /* DEFAULT=SCR */
      SCR_UNCATLGED  BIT(1) DEF(SCR) POS(2),    /* DEFAULT=SCR */
      SCR_UNUSED     BIT(1) DEF(SCR) POS(3),
      SCR_TOOBIG     BIT(1) DEF(SCR) POS(4),
      SCR_EXPIRED    BIT(1) DEF(SCR) POS(5),
      SCR_OVER_ALLOC BIT(1) DEF(SCR) POS(6),
      SCR_PAST_RETPD BIT(1) DEF(SCR) POS(7),    /* DEFAULT=SCR */

      FLAGS          BIT(8)   INIT('00000000'B),
      UNAUTHED       BIT(1) DEF(FLAGS) POS(1),
      UNCATLGED      BIT(1) DEF(FLAGS) POS(2),
      UNUSED         BIT(1) DEF(FLAGS) POS(3),
      TOOBIG         BIT(1) DEF(FLAGS) POS(4),
      EXPIRED        BIT(1) DEF(FLAGS) POS(5),
      OVER_ALLOC     BIT(1) DEF(FLAGS) POS(6),
      PAST_RETPD     BIT(1) DEF(FLAGS) POS(7),

      PRT_FLAGS      BIT(8)   INIT('11111110'B),
      PRT_UNAUTHED   BIT(1) DEF(PRT_FLAGS) POS(1),
      PRT_UNCATLGED  BIT(1) DEF(PRT_FLAGS) POS(2),
      PRT_UNUSED     BIT(1) DEF(PRT_FLAGS) POS(3),
      PRT_TOOBIG     BIT(1) DEF(PRT_FLAGS) POS(4),
      PRT_EXPIRED    BIT(1) DEF(PRT_FLAGS) POS(5),
      PRT_OVER_ALLOC BIT(1) DEF(PRT_FLAGS) POS(6),
      PRT_PAST_RETPD BIT(1) DEF(PRT_FLAGS) POS(7),

      MASK            BIT(8)   INIT('11111111'B),
      MASK_UNAUTHED   BIT(1)  DEF(MASK) POS(1),
      MASK_UNCATLGED  BIT(1)  DEF(MASK) POS(2),
      MASK_UNUSED     BIT(1)  DEF(MASK) POS(3),
      MASK_TOOBIG     BIT(1)  DEF(MASK) POS(4),
      MASK_EXPIRED    BIT(1)  DEF(MASK) POS(5),
      MASK_OVER_ALLOC BIT(1)  DEF(MASK) POS(6),
      MASK_PAST_RETPD BIT(1)  DEF(MASK) POS(7);

  DCL INDATE         CHAR(6)     INIT(' '),
      YY             CHAR(2) DEF(INDATE) POS(1),
      MM             CHAR(2) DEF(INDATE) POS(3),
      DD             CHAR(2) DEF(INDATE) POS(5);

  DCL TODAY   CHAR(5),
      EXPIRES_JDATE  PIC'99999'      INIT(0),
      TODAY_JDATE    PIC'99999'      INIT(0),
      THRESH_DAYS    FIXED BIN(31,0) INIT(40),
      THRESH_JDATE_C PIC'99999'      INIT(0),
      THRESH_JDATE   FIXED DEC(5)    INIT(0);

  DCL PC        FIXED BIN(15,0) INIT(0),
      PCC       PIC'ZZ9.9'      INIT(0),
      PC_THRESH FIXED BIN(15,0) INIT(750); /* PERCENT USED THRESHOLD */

  DCL (VTOC_KEY,GRANT_KEY) CHAR(60) INIT('');
  DCL VTOC_DSNAME  CHAR(44)   DEF(VTOC_KEY) POS(1),
      VTOC_MSVGP   CHAR(8)    DEF(VTOC_KEY) POS(46),
      VTOC_VOLUME  CHAR(6)    DEF(VTOC_KEY) POS(55);
  DCL GRANT_DSNAME CHAR(44)   DEF(GRANT_KEY) POS(1),
      GRANT_MSVGP  CHAR(8)    DEF(GRANT_KEY) POS(46),
      GRANT_VOLUME CHAR(6)    DEF(GRANT_KEY) POS(55);


  DCL SYSUSERS(8) CHAR(8)
       INIT('     MVS',
            '     TSO',
            '     IMS',
            'RESERVED',
            '        ',
            '        ',
            '        ',
            '        ');

  DCL VOLTAB (8) CHAR(6) STATIC
       INIT('IMS','MFG','PROD','FCITS','SPOOL','SOFTW','MS',' '),
      VOLLEN (8) FIXED BIN(15,0) STATIC
       INIT(   3,   3   , 4    , 5     , 5    , 5     , 2  , 0 );

  DCL DSNTAB (8) CHAR(8)   STATIC
       INIT('SYS',' ',' ',' ',' ',' ',' ',' '),
      DSNLEN (8) FIXED BIN(15,0) STATIC
       INIT(  3  , 0 , 0 , 0 , 0 , 0 , 0 , 0 );

  DCL HEADING         CHAR(130),
      RPTNO           CHAR(3)       DEF(HEADING) POS(  6),
      RUN_DATE        PIC'Z9/99/99' DEF(HEADING) POS( 95),
      RUN_JDATE       PIC'99.999'   DEF(HEADING) POS(105),
      RUN_TIME        PIC'Z9.99.99' DEF(HEADING) POS(113),
      PAGENO          PIC'ZZ9'      DEF(HEADING) POS(128),
      SUBTITLE        CHAR(112)  VAR INIT(''),
      HEADING2        CHAR(130),
      HEADING3        CHAR(130),
      HEADING4        CHAR(130),
      BLANKLINE       CHAR(130) INIT((130)' ');

 DCL  DSNHEAD         CHAR(63) INIT(' '),
      DSNHEAD1        CHAR(63) INIT(' '),
      PRNTDSN         CHAR(44) INIT(' ');

1/*  INITIALIZATION OF VARIABLES                                    */
  DEBUG = PARM = 'DEBUG';

  HEADING =   'L963-001 FAIRCHILD CAMERA AND INSTRUMENT       ' ××
              '   DASD MONITOR SYSTEM  VER(V2M0)      ' ××
              'RUN ON: 99/99/99 (99.999) 99.99.99  PAGE 999';

  HEADING2 =  '';
  HEADING3 =  '';
  HEADING4 =  '';
  V# = '';

  INDATE   = DATE;
  RUN_DATE = MM ×× DD ×× YY;
  RUN_TIME = SUBSTR(TIME,1,6);
  TODAY = JULIAN(INDATE);
  TODAY_JDATE = TODAY;
  RUN_JDATE   = TODAY;

  OPEN FILE(INLOG)    INPUT,
       FILE(INGRANT)  INPUT,
       FILE(OUTSCR)   OUTPUT,
       FILE(OUTLOG)   OUTPUT,
       FILE(VOLSUM)   OUTPUT,
       FILE(REPORT) OUTPUT LINESIZE(130),
       FILE(SCRRPT)   OUTPUT LINESIZE(130);

  ON ENDPAGE(REPORT)
     CALL FIN_PAGE(REPORT,'001',DSNHEAD,HEADING3,RPTPAGENO);

  ON ENDPAGE(SCRRPT)
     CALL FIN_PAGE(SCRRPT,'002',DSNHEAD1,HEADING4,SCRPAGENO);

  ON FINISH
    BEGIN;
      CLOSE FILE(INLOG),
            FILE(OUTSCR),
            FILE(OUTLOG),
            FILE(VOLSUM),
            FILE(REPORT),
            FILE(SCRRPT),
            FILE(INGRANT);
    END;
  SUBSTR(HEADING2,58,17) = 'CONTROL CARD LOG';
  HEADING3 =  (9)' ' ×× 'CMD' ×× (10)' ' ×× REPEAT('----+----×',7);
  SIGNAL ENDPAGE(REPORT);

  CALL GET_PARMS(RETURN_CODE);     /* GO READ CNTL CARDS/PARSE PARAMS */

  IF LENGTH(SUBTITLE) < 1 THEN HEADING2 =  '';
  TODAY_JDAYS = JUL2DAY(TODAY);
  THRESH_JDATE_C = JDY2JUL( TODAY_JDAYS   - THRESH_DAYS);
  THRESH_JDATE = THRESH_JDATE_C;

  SCR_JDAYS = TODAY_JDAYS + SCRATCH_DAYS; /* IF TGT SCR DATE FALLS ON */
  I = MOD(SCR_JDAYS,7);                   /* A SAT OR SUN..BUMP TO    */
  IF I < 2 THEN                           /* THE FOLLOWING MONDAY     */
     SCR_JDAYS = SCR_JDAYS + 2 - I;       /* BY THIS NIFTY CODE       */

  PACK5 = JDY2JUL( SCR_JDAYS);
  CALL R941X12(PACK5,PACK6);
  $SCRDATE = PACK6;

  HEADING3 =  '  RUN TIME PARAMETER LISTING';

  SIGNAL ENDPAGE(REPORT);

  CALL PRINT_PARMS('1'B);           /* PRINT ALL RUNTIME PARAMETERS  */

  IF RETURN_CODE ^= 0 THEN          /* QUIT IF ANY PARSE ERRORS ON   */
    DO;                             /*  CONTROL CARDS                */
      PUT FILE(REPORT) SKIP(3) EDIT
        ('*****RUN CANCELLED DUE TO CONTROL CARD ERRORS RC=12*****')
        (A);
      CALL PLIRETC(RETURN_CODE);
      STOP;
    END;

  HEADING3 =  '        D S N A M E';
  SUBSTR(HEADING3,48) = 'MSVGP    VOLUME    REMARKS/ACTION TAKEN';

  HEADING4 =  '    S C R A T C H   R E P O R T  -  DATASETS LISTED' ××
              ' WILL BE SCRATCHED ON ' ×× $SCRDATE ××
              ' - CONTACT SPACE MANAGER FOR DASD AUTHORIZATION';

  SCRPARMS.$RUN_DATE = RUN_DATE;
  SCRPARMS.$RUN_TIME = RUN_TIME;
  SCRPARMS.$SCR_DATE = $SCRDATE;

  DO I = 1 TO 8;
    IF SUBSTR(SCR,I,1) = '1'B THEN
       SUBSTR(SCRPARMS.$SCR_CODES,I,1) = SUBSTR('ICUBEOR ',I,1);
  END;

  WRITE FILE(OUTSCR) FROM(SCRPARMS);   /* WRITE OUT SCRPARMS TO SCRLOG*/


  SIGNAL ENDPAGE(REPORT);              /* WRITE REPORT HEADINGS       */
  SIGNAL ENDPAGE(SCRRPT);

  ON ENDFILE(INLOG)
    BEGIN;
     IF DEBUG THEN PUT FILE(SYSPRINT) SKIP LIST('**EOF ON INLOG**');
     DSNLOG.DSNAME = (44)'9'; /* MOVE HIGH VALUES TO DSNAME */
     DSNLOG.VOLUME = '999999';/* MOVE HIGH VALUES TO VOLUME */
     DSNLOG.MSVGP  = (8)'9';  /* MOVE HIGH VALUES TO MSVGP  */
     EOF_INLOG = '1'B;
    END;

  ON ENDFILE(INGRANT)
    BEGIN;
     IF DEBUG THEN PUT FILE(SYSPRINT) SKIP LIST('**EOF ON INGRANT**');
     GRANT.DSNAME  = (44)'9'; /* MOVE HIGH VALUES TO DSNAME */
     GRANT.VOLUME  = '999999';/* MOVE HIGH VALUES TO VOLUME */
     GRANT.MSVGP   = (8)'9';  /* MOVE HIGH VALUES TO MSVGP  */
     EOF_INGRANT = '1'B;
    END;

  READ FILE(INLOG) INTO(DSNLOG);      /* SET UP FOR PROCESING.. READ  */
  READ FILE(INGRANT) INTO(GRANT);     /* FIRST GRANT/DSNLOG RECORDS   */
  FINISHED = EOF_INLOG × EOF_INGRANT;
  IF ^EOF_INLOG THEN INREC_LOG = INREC_LOG + 1;
  IF ^EOF_INGRANT THEN INREC_GRANT = INREC_GRANT + 1;

1 /*    MAIN LOOP TO VALIDATE DATASETS          */

 DO WHILE(^FINISHED);

   CALL CHK_GENERIC_DSN;     /* GO HANDLE GENERIC DSN IF NEED BE */

   IF ^EOF_INLOG THEN CALL GET_STATVOL;    /* LOCATE WHICH STATS SET */
                                           /*  TO USE IF A NEW LOG   */
   FLAGS = '';

   MASK = (8)'1'B;


   IF VTOC_KEY = GRANT_KEY THEN CALL PROCESS;
     ELSE
   IF VTOC_KEY < GRANT_KEY THEN CALL ILLEGAL;
     ELSE
                                      CALL DELETED;
   IF DEBUG THEN PUT FILE(SYSPRINT) SKIP EDIT
      ('FLAGS=',FLAGS,' MASK=',MASK) ((2)(A,B(8)));
   FINISHED = EOF_INLOG & EOF_INGRANT;

 END;                           /* END OF MAIN LOOP                 */

   CALL SUMMARY;                /*  PERFORM SUMMARY REPORTING       */


   PUT FILE(REPORT) SKIP(2) EDIT
         (' **** END OF REPORT L963-001 ****')
         (A);


   PUT FILE(SCRRPT)   SKIP(2) EDIT
         (RECOUT_OUTSCR)                          (COL(3),P'ZZ,ZZ9')
         (' DATASETS TO BE SCRATCHED')            (A)
         (' **** END OF REPORT L963-002 ****')    (SKIP(2),A);

   CALL PLIRETC(RETURN_CODE);

   STOP;
0 /*    END OF MAIN PROGRAM LOOP                */
1/* ILLEGAL DATASET FOUND..ON VTOC..NOT ON GRANT FILE..               */

 ILLEGAL: PROC;
   CALL ACCUM(V#.TRK_ALLOC(VIDX),DSNLOG.TRK_ALLOC,VIDX);
   IF DEBUG THEN PUT FILE(SYSPRINT) SKIP LIST('ILLEGAL ENTERED****');
   UNAUTHED = '1'B;

   IF DO_CATCHK THEN UNCATLGED = CHK_CATALOG;

   CALL DSNSTATS(UNUSED_DAYS,PC);

   DSNHEAD = ' ' ×× PRNTDSN ×× '  ' ×× DSNLOG.MSVGP ××
             ' ' ×× DSNLOG.VOLUME ×× ' ';

   CALL POST_MSG(REPORT,DSNHEAD,FLAGS,PRT_FLAGS);

   IF SCR_UNAUTHED THEN CALL GEN_SCRATCH;
                   ELSE V#.#BOZO_DSN(VIDX) =
                              V#.#BOZO_DSN(VIDX) + 1;

   CALL WRITE_LOG('1'B);   /* FIND OUT WHO TO DING AND LOG RECORD */

   READ FILE(INLOG) INTO(DSNLOG);
   IF ^EOF_INLOG THEN INREC_LOG = INREC_LOG + 1;
   GENERIC_DSN = '0'B;     /* TURN OFF GENERIC PROCESSING         */
   RETURN;
 END ILLEGAL;


1/* DELETED DATASET FOUND..NOT ON VTOC, BUT ON GRANT FILE             */

 DELETED: PROC;

   IF DEBUG THEN PUT FILE(SYSPRINT) SKIP LIST('DELETED ENTERED****');
   DSNHEAD = '-' ×× GRANT.DSNAME ×× '  ' ×× GRANT.MSVGP ××
             ' ' ×× GRANT.VOLUME ×× ' ';

   PUT FILE(REPORT) SKIP EDIT
       (DSNHEAD,'--DATASET NOT FOUND--')
       (A,A);
       INREC_NOTFOUND = INREC_NOTFOUND + 1;
   READ FILE(INGRANT) INTO(GRANT);
   IF ^EOF_INGRANT THEN INREC_GRANT = INREC_GRANT + 1;
   GENERIC_DSN = '0'B;    /*  TURN OFF GENERIC PROCESSING  */
   RETURN;
 END DELETED;

1/* PROCESS DATASET FOUND..ON VTOC AND GRANT FILE                     */

 PROCESS: PROC;

   IF DEBUG THEN PUT FILE(SYSPRINT) SKIP LIST('PROCESS ENTERED****');

   IF DO_CATCHK THEN UNCATLGED = CHK_CATALOG;

   IF DSNLOG.TRK_ALLOC > GRANT.TRACKS THEN
     DO;
       TOOBIG = '1'B;
     END;

   TIMESTAMPED = CHK_TIMESTAMP(DSNLOG.VOLUME,DSNLOG.DSNAME);

   CALL DSNSTATS(UNUSED_DAYS,PC);  /* GO GET DSN STATISTICS   */

   IF DSNLOG.LAST_USED < THRESH_JDATE &
      DSNLOG.TRK_ALLOC > 0           &
      SUBSTR(DSNLOG.DSORG,1,2) ^= 'VS' &
      ^SYSTEM_DATASET                &
      TIMESTAMPED                              THEN
     DO;
        UNUSED  = '1'B;
        CALL ACCUM(V#.TRK_UNUSED(VIDX),DSNLOG.TRK_ALLOC,VIDX);
     END;

   EXPIRES_JDATE = 0;
   IF GRANT.EXPIRES > 0 THEN CALL R941X11(GRANT.EXPIRES,EXPIRES_JDATE);

   IF EXPIRES_JDATE > 0                 &
      EXPIRES_JDATE <= TODAY_JDATE THEN
     DO;
        EXPIRED = '1'B;
        $EXPIRED = GRANT.EXPIRES;

        CALL ACCUM(V#.TRK_EXPIRED(VIDX),DSNLOG.TRK_ALLOC,VIDX);

     END;

   IF DSNLOG.EXP_DATE > 0             &
      DSNLOG.EXP_DATE <= TODAY_JDATE  &
      ^SYSTEM_DATASET                THEN
       DO;
         PAST_RETPD = '1'B;
         PACK5 = DSNLOG.EXP_DATE;
         CALL R941X12(PACK5,PACK6);
         $RETPD_DATE = PACK6;
       END;

   IF (SUBSTR(DSNLOG.DSORG,1,2) = 'PS' ×
       SUBSTR(DSNLOG.DSORG,1,2) = 'PO' ) &
       ^SYSTEM_DATASET       &
       DSNLOG.TRK_ALLOC > 0    THEN
     DO;
        CALL ACCUM(V#.TRK_WASTE(VIDX),
                   DSNLOG.TRK_ALLOC - DSNLOG.TRK_USED,VIDX);
        IF PC < PC_THRESH THEN
          DO;
            OVER_ALLOC  = '1'B;
          END;
     END;

   IF FLAGS ^= '00000000'B  THEN /* POST ERROR MESSAGES */
     DO;

        DSNHEAD = ' ' ×× PRNTDSN ×× '  ' ×× DSNLOG.MSVGP ××
                  ' ' ×× DSNLOG.VOLUME ×× ' ';

        CALL POST_MSG(REPORT,DSNHEAD,FLAGS,PRT_FLAGS);
     END;


   IF SUBSTR(DSNLOG.DSNAME,1,13) = 'RESERVED.SPACE.' ×
      GRANT.BILL_TO = 'RESERVED'
     THEN CALL ACCUM(V#.TRK_RSVD(VIDX),DSNLOG.TRK_ALLOC,VIDX);

     ELSE CALL ACCUM(V#.TRK_ALLOC(VIDX),DSNLOG.TRK_ALLOC,VIDX);

   IF (SCR & FLAGS & MASK)  ^= '00000000'B THEN
     DO;
        CALL GEN_SCRATCH;
     END;
    ELSE
     DO;
       IF FLAGS = '00000000'B
         THEN V#.#OK_DSN(VIDX) = V#.#OK_DSN(VIDX) + 1;
         ELSE V#.#BOZO_DSN(VIDX) = V#.#BOZO_DSN(VIDX) + 1;
     END;

   CALL WRITE_LOG('0'B);  /* WRITE LOG RECORD  (NO BILL SEARCH) */

   IF ^GENERIC_DSN THEN
     DO;
        READ FILE(INGRANT) INTO(GRANT);
        IF ^EOF_INGRANT THEN INREC_GRANT = INREC_GRANT + 1;
     END;

   READ FILE(INLOG) INTO(DSNLOG);
   IF ^EOF_INLOG THEN INREC_LOG = INREC_LOG + 1;

   RETURN;

 END PROCESS;

1/* CHECK TO SEE IF DATASET IS CATALOGED PROPERLY                     */
 CHK_CATALOG: PROC  RETURNS(BIT(1));

   DCL 1 CATTAB(10),               /* AREA TO RECEIVE CATALOG LIST    */
         2 DEVICE BIT(32),
         2 VOLSER CHAR(6),
         2 FSEQ#  FIXED BIN(15,0) UNALIGNED;
   DCL #VOLS    FIXED BIN(15,0);

   DCL 1 WHOGOT(10),               /* AREA TO RECEIVE ENQUEUE LIST    */
         2 ENQUSER  CHAR(8),
         2 ENQFLAGS,
           3 ENQFOUND   BIT(1),
           3 ENQJOB     BIT(1),
           3 ENQOLD     BIT(1),
           3 ENQFILLER  BIT(5),
        #ENQMAX     FIXED BIN(15,0) INIT(10);

   DCL CAT_RETURNCD    FIXED BIN(31,0);
   DCL (I,ENQ_RTN)     FIXED BIN(15,0);

   DCL (FOUND,ENQUEUED,UCAT) BIT(1) INIT('0'B);
   $CAT_INFO = '';
                               /* SKIP LOOKING FOR SYSCATLG OR VSAM   */
                               /* DATASETS..THEY ARE CATALOGED 'FUNNY'*/

   IF SUBSTR(DSNLOG.DSNAME,1,10) = 'SYSCTLG  ' ×
      SUBSTR(DSNLOG.DSORG,1,2) = 'VS' THEN RETURN('0'B);

                               /* GO CHECK THE CATALOG FOR THE DSN    */

   CALL R963A11(DSNLOG.DSNAME,CATTAB,#VOLS,CAT_RETURNCD);

   IF CAT_RETURNCD = 0 THEN       /* SOMETHINGS CATALOGED..CHK IT OUT */

     DO;
                                  /* SEE IF WERE ON THE LIST          */
       DO I = 1 TO #VOLS WHILE(^FOUND);
         IF CATTAB.VOLSER(I) = DSNLOG.VOLUME THEN FOUND = '1'B;
       END;
       IF ^FOUND THEN
         DO;                 /* CATLGED BUT NOT TO OUR VOLUME         */
           $CAT_INFO = ' TO VOL=' ×× DSNLOG.VOLUME ×× ' CATVOL=' ××
                       CATTAB.VOLSER(1) ;
           UCAT ='1'B;
         END;
        ELSE
         DO;                 /* CATLGED TO OUR VOLUME                 */
           $CAT_INFO = '';
         END;
     END;
    ELSE
     DO;                          /* NOT CATALOGED..SEE IF ENQUEUED  */

       UCAT = '1'B;
       WHOGOT = '';
       CALL FINDENQ(DSNLOG.DSNAME,WHOGOT,1,ENQ_RTN);

                                  /* IF ENQUEUED ON BY A JOB AS OLD  */
                                  /* THEN CHANCES ARE IT WILL BE CATLG*/
                                  /* AT END-OF-STEP OR END-OF-JOB    */

       IF ENQ_RTN = 0 × ENQ_RTN = 12 THEN
         DO;                      /* SOMETHING ON ENQUEUE..CHK IT OUT*/
           DO I = 1 TO #ENQMAX WHILE(^ENQUEUED);
             IF WHOGOT.ENQFOUND(I) &
                WHOGOT.ENQJOB(I) &
                WHOGOT.ENQOLD(I)    THEN  ENQUEUED = '1'B;
           END;
           IF ENQUEUED THEN       /* GOT HIM..ASSUME JOB WILL CATLG  */
             DO;                  /* AT END OF STEP OR END OF JOB    */
               $CAT_INFO = ' ENQUEUE OLD BY JOB=' ××
                           WHOGOT.ENQUSER(I-1);
               MASK_UNCATLGED = '0'B;   /* ALLOW THIS TRAVESTRY      */
                                        /* BUT GRIPE TO SPACEMAN     */
             END;
         END;
     END;

   IF GRANT.OKUNCAT = 'Y' THEN
     DO;
       $CAT_INFO = $CAT_INFO ×× ' (UNCAT ALLOWED)';
       MASK_UNCATLGED = '0'B;
     END;

   IF DEBUG THEN PUT FILE(SYSPRINT) SKIP EDIT
      ('CATRC=',CAT_RETURNCD,FOUND,ENQUEUED,UCAT,$CAT_INFO)
      (A,P'99',(3)(X(1),B),X(2),A);

   RETURN(UCAT);
 END CHK_CATALOG;
1/* GET DATASET STATS UNUSED DAYS, PERCENT USED                       */

 DSNSTATS: PROC(UUSED,PCENT);

   DCL UUSED     FIXED BIN(15,0),
       PCENT     FIXED BIN(15,0);

   UUSED = 0;

   IF DSNLOG.TRK_ALLOC > 0           &
      DSNLOG.DSNAME ^= 'SYSCTLG '    &
      SUBSTR(DSNLOG.DSORG,1,2) ^= 'VS' THEN
     DO;
        UUSED = TODAY_JDAYS - JUL2DAY(DSNLOG.LAST_USED);
     END;

   IF ^CHK_TIMESTAMP(DSNLOG.VOLUME,DSNLOG.DSNAME) THEN UUSED=0;


   PCENT = 1000;         /* ASSUME 100 PERCENT USED                 */

   IF (SUBSTR(DSNLOG.DSORG,1,2) = 'PS' ×
       SUBSTR(DSNLOG.DSORG,1,2) = 'PO' ) &
       DSNLOG.TRK_ALLOC > 0    THEN
     DO;
        PCENT = (1000 * DSNLOG.TRK_USED)/DSNLOG.TRK_ALLOC;
        PCC= PCENT;
     END;

   RETURN;
 END DSNSTATS;

1/* TEST FOR TIMESTAMPING BY ASM2                                     */

 CHK_TIMESTAMP: PROC(VOLUME,DSNAME) RETURNS(BIT(1));

   DCL VOLUME CHAR(6),
       DSNAME CHAR(44),
       I      FIXED BIN(15,0),
       STAMP  BIT(1) INIT('0'B);

   DO I = 1 TO DIM(VOLTAB,1) WHILE(^STAMP & VOLLEN(I) > 0);
     IF SUBSTR(VOLUME,1,VOLLEN(I)) = SUBSTR(VOLTAB(I),1,VOLLEN(I))
        THEN STAMP = '1'B;
   END;

   IF STAMP THEN
     DO I = 1 TO DIM(DSNTAB,1) WHILE(STAMP & DSNLEN(I) > 0);
       IF SUBSTR(DSNAME,1,DSNLEN(I)) = SUBSTR(DSNTAB(I),1,DSNLEN(I))
          THEN STAMP = '0'B;
     END;

   RETURN (STAMP);

 END CHK_TIMESTAMP;


1/* GENERATE SCRATCH CARDS FOR ILLEGAL DATASETS                       */

 GEN_SCRATCH: PROC;

   DCL SCRHEAD   CHAR(32);

   SCRHEAD = '';

   SCRHEAD = 'DATASET SELECTED FOR SCRATCHING';

   SCRLOG = DSNLOG, BY NAME;
   SCRLOG.DEVICETYP = SUBSTR(DSNLOG.DEVICE,1,7);

   IF UNAUTHED THEN CALL GET_BILLTO(DSNLOG.DSNAME,
                                    DSNLOG.DSORG,SCRLOG.BILL_TO);
               ELSE SCRLOG.BILL_TO = GRANT.BILL_TO;

   SCRLOG.FLAGS = SUBSTR(CNVTHX(FLAGS ×× (8)'0'B),1,2);

   WRITE FILE(OUTSCR) FROM(SCRLOG);

   RECOUT_OUTSCR = RECOUT_OUTSCR + 1;

   CALL ACCUM(V#.TRK_SCR(VIDX),DSNLOG.TRK_ALLOC,VIDX);

   V#.#SCR_DSN(VIDX)=
          V#.#SCR_DSN(VIDX) + 1;

   DSNHEAD1= ' ' ×× PRNTDSN ×× '  ' ×× DSNLOG.MSVGP ××
             ' ' ×× DSNLOG.VOLUME ×× ' ';

   /* V2M1 - TO SUPPORT THE AUTO SCRATCH -----------------------*/
   /*        IF L=1 DATASET WILL NOT PRINT ON SCRATCH REPORT    */
   /*        IF L=2 DATASET WILL PRINT ON SCRATCH REPORT        */
   /*        NOTE: WILL NOT EFFECT SCRCARDS, LOG, OR REPORT     */

   IF UNAUTHED   &   UNCATLGED   ×
     ^UNAUTHED   &   UNCATLGED   &   GENERIC_DSN
      THEN   L   =  1;
      ELSE   L   =  2;

   CALL POST_MSG(SCRRPT,DSNHEAD1,FLAGS,SCR);

   IF L = 2   THEN
         PUT FILE(SCRRPT)   SKIP EDIT
         (DSNHEAD1,$USE_INFO,' ')
         (A,A,SKIP,A);
              ELSE  L = 2 ;

   PUT FILE(REPORT) SKIP EDIT
       (DSNHEAD,$USE_INFO)
       (A,A);

   DSNHEAD = ' ' ×× (44)'_';

   PUT FILE(REPORT) SKIP EDIT
       (DSNHEAD,SCRHEAD,
        '..TRACKS=',DSNLOG.TRK_ALLOC,'  ')
       (A,A,A,P'ZZ,ZZ9',SKIP,A);

 END GEN_SCRATCH;
1/* PERFORM PAGE HEADER ROUTINE */

 FIN_PAGE: PROC(PRNT,RPT,DSN_HEADER,HEADER,PAGE);

  DCL PRNT       FILE,
      RPT        CHAR(3),
      HEADER     CHAR(*),
      DSN_HEADER CHAR(*),
      PAGE FIXED BIN(15,0);

      PAGE = PAGE + 1;
      PAGENO = PAGE;

      RPTNO = RPT;

      IF SUBSTR(DSN_HEADER,2,10) = '          ' & ^EOF_INLOG THEN
        DO;
          DSN_HEADER = ' ' ×× PRNTDSN ××
                    ' (CONT.)' ;
        END;

      IF SUBSTR(DSN_HEADER,2,10) = '__________' & ^EOF_INLOG THEN
        DO;
          DSN_HEADER = ' ' ×× TRANSLATE(PRNTDSN,'_',' ') ××
                    ' (CONT.)' ;

        END;

      PUT FILE(PRNT)          EDIT
        (HEADING)    (PAGE,LINE(1),A)
        (HEADING2)   (LINE(2),A)
        (HEADER)     (LINE(4),A)
        (BLANKLINE)  (LINE(5),A);


     RETURN;
  END FIN_PAGE;

1/* PROCESS GENERIC DATASET NAME FROM GRANT FILE */

 CHK_GENERIC_DSN: PROC;

   DCL ERRFLAG BIT(1) INIT('0'B),
       #DSNS FIXED BIN(31,0) INIT(0);
   IF DEBUG THEN PUT FILE(SYSPRINT) SKIP LIST('..CHK GENERIC ENTERED');
   IF GENERIC_DSN THEN      /* ALREADY IN GENERIC MODE..SEE IF WE */
     DO;                    /*   RESET OR CONTINUE IN THIS MODE   */
       IF SUBSTR(DSNLOG.DSNAME,1,COMPLEN) ^=
          SUBSTR(GRANT_KEY,1,COMPLEN)         THEN

         DO;                /* DSN MISMATCH..END GENERIC MODE     */

           GENERIC_DSN = '0'B;
           CALL POST_GENERIC_STATS; /* GO PUT OUT MESSAGES IF NEED BE*/
           GENERIC_DSN_MAX,GENERIC_DATASETS,GENERIC_TRKS_MAX,
             GENERIC_TRACKS = 0 ;
           READ FILE(INGRANT) INTO(GRANT);
           IF ^EOF_INGRANT THEN INREC_GRANT = INREC_GRANT + 1;
           VTOC_DSNAME=DSNLOG.DSNAME;/* SET UP NEW COMPARE KEY */
           GRANT_DSNAME=GRANT.DSNAME;
         END;
        ELSE
         DO;     /* STILL IN GENERIC MODE..ACCUMULATE STATS */
           GENERIC_TRACKS   = GENERIC_TRACKS + DSNLOG.TRK_ALLOC;
           GENERIC_DATASETS = GENERIC_DATASETS + 1;
         END;
     END;


1  IF ^GENERIC_DSN THEN       /* NOT IN GENERIC MODE ..          */
     DO;
        GRANT_DSNAME = GRANT.DSNAME;
        SYSTEM_DATASET = '0'B;
        DO I = 1 TO DIM(SYSUSERS,1) WHILE(SYSUSERS(I) ^= '        ');
          IF GRANT.BILL_TO = SYSUSERS(I) THEN SYSTEM_DATASET = '1'B;
        END;
        GENERIC_DSN_MAX,GENERIC_DATASETS,GENERIC_TRKS_MAX,
          GENERIC_TRACKS = 0 ;
        I = INDEX(GRANT.DSNAME,'*'); /* FIND GDG GENERIC ENTRIES */
        IF I > 1 THEN
          DO;                        /* ENTER GENERIC MODE..     */
             J = VERIFY(SUBSTR(GRANT.DSNAME,I+1),' ');
             IF J > 0 THEN
               DO;                   /* PROCESS # DSN ENTRIES    */
                 J = J + I;
                 CALL GET_NUMBER(GRANT.DSNAME,J,#DSNS,ERRFLAG);
                 IF ^ERRFLAG THEN
                   DO;
                     GENERIC_DSN_MAX = #DSNS;
                     GENERIC_TRKS_MAX =
                             GRANT.TRACKS * GENERIC_DSN_MAX;
                   END;
               END;
             IF J = 0 × ERRFLAG THEN
               DO;
                 GENERIC_TRKS_MAX = GRANT.TRACKS;
                 GENERIC_DSN_MAX        = 32767;       /* NO LIMIT */
               END;
             GENERIC_DSN = '1'B;
             GRANT_DSNAME = SUBSTR(GRANT.DSNAME,1,I-1);
             VTOC_DSNAME  = SUBSTR(DSNLOG.DSNAME,1,I-1);
             COMPLEN = I-1;
             GENERIC_TRACKS = GENERIC_TRACKS + DSNLOG.TRK_ALLOC;
             GENERIC_DATASETS = GENERIC_DATASETS + 1;
          END;
        ELSE
          DO;                        /* DIDNT ENTER GENERIC MODE */
             COMPLEN = LENGTH(GRANT.DSNAME);
             VTOC_DSNAME = DSNLOG.DSNAME;
          END;
     END;
1                                   /* FORM REST OF KEY          */
   IF GRANT.VOLUME = '      ' THEN
     DO;                                      /* GRANT TO MSVGP  */
       VTOC_VOLUME,GRANT_VOLUME = '';  /* NULLIFY VOLUME FROM KEY*/
       VTOC_MSVGP = DSNLOG.MSVGP;
       GRANT_MSVGP = GRANT.MSVGP;
     END;
    ELSE
     DO;                                      /* GRANT TO VOLSER */
       VTOC_MSVGP,GRANT_MSVGP='';      /* NULLIFY MSVGP FROM KEY */
       VTOC_VOLUME= DSNLOG.VOLUME;
       GRANT_VOLUME=GRANT.VOLUME;
     END;

   PRNTDSN  = DSNLOG.DSNAME;
  IF DEBUG THEN
    DO;
      PUT FILE(SYSPRINT) SKIP EDIT
         (INREC_LOG,
          ' DSNLOG=',DSNLOG.DSNAME,DSNLOG.MSVGP,DSNLOG.VOLUME)
         (X(2),F(5),A,(3)(A,X(1)) )
         (INREC_GRANT,
          ' GRANT= ',GRANT.DSNAME,GRANT.MSVGP,GRANT.VOLUME)
         (SKIP,X(2),F(5),A,(3)(A,X(1)) )
         ('..END CHK GENERIC DSN..GENERIC= ',GENERIC_DSN)
         (SKIP,A,B(1));
    END;

   RETURN;
 END CHK_GENERIC_DSN;
1/* POST ERRORS CONCERNING GENERIC DATASET ABUSE */
 POST_GENERIC_STATS: PROC;

   PRNTDSN = SUBSTR(GRANT.DSNAME,1,COMPLEN+1);
   DSNHEAD = ' ' ×× PRNTDSN ×× '  ' ×× GRANT.MSVGP ××
             ' ' ×× GRANT.VOLUME ×× ' ';
   IF GENERIC_TRACKS > GENERIC_TRKS_MAX &
      PRT_TOOBIG             THEN
     DO;
        PUT FILE(REPORT) SKIP EDIT
            (DSNHEAD,
             '..TRK ALLOC=',GENERIC_TRACKS,
             ' > TRK ALLOWED=',GENERIC_TRKS_MAX)
            (A,A,P'ZZ,ZZ9',A,P'ZZ,ZZ9');
        DSNHEAD = '';
     END;
   IF GENERIC_DATASETS > GENERIC_DSN_MAX &
      PRT_TOOBIG             THEN
     DO;
        PUT FILE(REPORT) SKIP EDIT
            (DSNHEAD,
             '..#DSN=',GENERIC_DATASETS,
             ' > #DSN ALLOWED',GENERIC_DSN_MAX)
            (A,A,P'ZZ,ZZ9',A,P'ZZ,ZZ9');
        DSNHEAD = '';
     END;
   RETURN;
 END POST_GENERIC_STATS;
1/* ESTABLISH SUMMARY VOLUME STATISTICS BUCKET TO USE */
 GET_STATVOL: PROC;

   VIDX = 0;
   IF DSNLOG.DEVICE = T#3330V THEN RETURN; /* NO ACCUM FOR MASS STORE*/
   DO I = 1 TO #V# - 1 WHILE(VIDX = 0);
     IF V#.VOLUME(I) = DSNLOG.VOLUME THEN VIDX = I;

     IF VIDX=0 &
        NUMVOLS < #V# - 1 &
        DSNLOG.VOLUME > V#.VOLUME(I)           THEN
       DO;
         DO J = NUMVOLS+1 TO I+1 BY -1;
           V#(J) = V#(J-1);
         END;
         V#(I) = '';
         VIDX = I;
         V#.VOLUME(I) = DSNLOG.VOLUME;
         IF DSNLOG.DEVICE = T#3350   THEN
            V#.TRK_MAX(I) = 16650;
         IF DSNLOG.DEVICE = T#3330#1 THEN
            V#.TRK_MAX(I) = 15352;
         NUMVOLS = NUMVOLS + 1;
       END;
   END;
   IF VIDX=0 &
      NUMVOLS < #V# - 1 &
      DSNLOG.VOLUME < V#.VOLUME(1)            THEN
     DO;
       DO J = NUMVOLS+1 TO 2       BY -1;
         V#(J) = V#(J-1);
       END;
       V#(1) = '';
       VIDX = 1;
       V#.VOLUME(1) = DSNLOG.VOLUME;
       IF DSNLOG.DEVICE = T#3350   THEN
          V#.TRK_MAX(1) = 16650;
       IF DSNLOG.DEVICE = T#3330#1 THEN
          V#.TRK_MAX(1) = 15352;
       NUMVOLS = NUMVOLS + 1;
     END;
   IF VIDX = 0 THEN                /* VOL NOT FOUND DUE TO OVERFLOW */
     DO;
       VIDX = #V#;
       V#.VOLUME(VIDX) = '*OVFL*';
       V#.TRK_MAX(VIDX) = V#.TRK_MAX(VIDX) + 1;
     END;

   RETURN;

 END GET_STATVOL;
1/* PERFORM SUMMARY CALCULATIONS AND REPORTING */
 SUMMARY: PROC;

  HEADING3 =  '';

  SIGNAL ENDPAGE(REPORT);

   PUT FILE(REPORT) SKIP    EDIT
         ('SUMMARY VOLUME STATISTICS',
          'VOLUME  ',
          ' MAX    ALLOC   RSVED   WASTE   UNUSED  EXPIRED SCRATCH  ',
          ' ---% FULL---     ------NUMB. OF DATASETS------')
         (COL(53),A,SKIP(2),COL(10),A,A,A)
         ('        ',
          'TRACKS  TRACKS  TRACKS  TRACKS  TRACKS  TRACKS  TRACKS   ',
          ' CURNT  W/SCR       OK    BOZO   SCRATCH  TOTAL ')
         (SKIP,COL(10),A,A,A);

  PUT FILE(REPORT) SKIP;

  OUT_V# = '';                   /* INITIALIZE OUTPUT RECORD  */

  OUT_V#.SCRFLAG = SCR;          /* SAVE SCRATCH FLAGS        */
  OUT_V#.LOGDATE = RUN_JDATE; /* SAVE RUN JULIAN DATE         */
  OUT_V#.LOGTIME = RUN_TIME;      /* SAVE RUN TIME            */

  DO I = NUMVOLS TO 1 BY -1;     /* PRINT IN ASCENDING ORDER  */
                                 /* DETAIL VOLUME STATISTICS  */
    IF V#.TRK_MAX(I) > 0 THEN
      DO;
       J = (V#.TRK_ALLOC(I) * 1000)/V#.TRK_MAX(I);
       K = ((V#.TRK_ALLOC(I) - V#.TRK_SCR(I))*1000)/
            V#.TRK_MAX(I);
      END;
     ELSE
      DO;
       J,K=1000;
      END;

    TOTALS = V#(I) + TOTALS, BY NAME;

    V#.#_DSN(I) = V#.#OK_DSN(I) +
                      V#.#BOZO_DSN(I) +
                      V#.#SCR_DSN(I);

    OUT_V# = V#(I), BY NAME;
    WRITE FILE(VOLSUM) FROM(OUT_V#);

    STATLINE = V#(I), BY NAME;

    STATLINE.PC_FULL     = J;
    STATLINE.PC_FULL_SCR = K;

    PUT FILE(REPORT) SKIP EDIT
        (SSTATLINE) (COL(9),A);

  END;

    IF TOTALS.TRK_MAX > 0 THEN           /* FORMAT REAL DASD TOTAL */
      DO;
       J = (TOTALS.TRK_ALLOC * 1000)/TOTALS.TRK_MAX;
       K = ((TOTALS.TRK_ALLOC - TOTALS.TRK_SCR)*1000)/
            TOTALS.TRK_MAX;
      END;
     ELSE
      DO;
       J,K=1000;
      END;

    TOTALS.#_DSN = TOTALS.#OK_DSN + TOTALS.#BOZO_DSN +
                   TOTALS.#SCR_DSN;

    STATLINE = TOTALS, BY NAME;

    STATLINE.VOLUME      = 'TOTALS';
    STATLINE.PC_FULL     = J;
    STATLINE.PC_FULL_SCR = K;

    PUT FILE(REPORT) SKIP(2) EDIT            /* PRINT REAL DASD TOTALS*/
        ('REAL',SSTATLINE) (A,COL(9),A);

   TOTALS.#_DSN = V#.#OK_DSN(0) + V#.#BOZO_DSN(0) +
                   V#.#SCR_DSN(0);

   PUT FILE(REPORT) SKIP(2) EDIT
         ('MSS DATASET COUNTS:')      (COL(1),A)
         (V#.#OK_DSN(0))              (COL(91),P'ZZ,ZZZ')
         (V#.#BOZO_DSN(0))            (COL(99),P'ZZ,ZZZ')
         (V#.#SCR_DSN(0))             (COL(107),P'ZZ,ZZZ')
         (TOTALS.#_DSN)               (COL(115),P'ZZ,ZZZ');

    TOTALS = TOTALS + V#(0), BY NAME;

    TOTALS.#_DSN = TOTALS.#OK_DSN + TOTALS.#BOZO_DSN +
                   TOTALS.#SCR_DSN;

   PUT FILE(REPORT) SKIP(2) EDIT
         ('TOTAL DATASET COUNTS:')    (COL(1),A)
         (TOTALS.#OK_DSN)             (COL(91),P'ZZ,ZZZ')
         (TOTALS.#BOZO_DSN)           (COL(99),P'ZZ,ZZZ')
         (TOTALS.#SCR_DSN)            (COL(107),P'ZZ,ZZZ')
         (TOTALS.#_DSN)               (COL(115),P'ZZ,ZZZ');

    PUT FILE(REPORT) SKIP(2) EDIT
        ('PARAMETERS USED FOR THIS RUN:') (X(1),A);

   CALL PRINT_PARMS('0'B); /* PRINT SCRATCH/THRESH PARMS  */

   PUT FILE(REPORT) SKIP(3) EDIT
         (INREC_LOG,     'LOG RECORDS READ IN',
          INREC_GRANT,   'GRANT RECORDS READ IN',
          INREC_NOTFOUND,'GRANT RECORDS WITH NO DATASET ON DISK',
          RECOUT_OUTSCR, 'DATASETS SELECTED FOR SCRATCHING',
          RECOUT_OUTLOG, 'MERGED OUTPUT LOG RECORDS WRITTEN')
         ((5)(P'ZZ,ZZZ,ZZ9',X(2),A,SKIP));



   RETURN;

 END SUMMARY;

1/* CONDITIONAL ACCUMULATE VOLUME STATISTICS              */
 ACCUM: PROC(TOTAL,VALUE,INDX);

   DCL TOTAL   FIXED BIN(31,0),
       VALUE   FIXED BIN(15,0),
       INDX    FIXED BIN(15,0);

   IF INDX < 1 THEN RETURN;   /* DONT ACCUMULATE MSS STATISTICS */

   TOTAL = TOTAL + VALUE;

   RETURN;

 END ACCUM;

1/* PRINT MESSAGES TO LOG DATASETS BASED ON FLAG SETTINGS */
 POST_MSG: PROC(PRINT,HEADER_DSN,FLAG1,FLAG2);

   DCL PRINT   FILE,
       HEADER_DSN CHAR(63),
       FLAG1   BIT(8),
       FBIT1(8) BIT(1) DEF(FLAG1) POS(1),
       FLAG2   BIT(8),
       FBIT2(8) BIT(1) DEF(FLAG2) POS(1);

   CALL GET_USE;           /* GENERATE $USE_INFO FOR PRINTING   */

   IF FBIT1(2) & FBIT2(2) &  L = 2  THEN
     DO;
       PUT FILE(PRINT) SKIP EDIT
           (HEADER_DSN,
            '..DATASET NOT CATLGED',$CAT_INFO)
           (A,A,A);
       HEADER_DSN = '';
     END;
   IF FBIT1(1)  &  FBIT2(1)  &  L = 2   THEN
     DO;
       PUT FILE(PRINT) SKIP EDIT
           (HEADER_DSN,
            '..DATASET ALLOCATION NOT AUTHORIZED')
           (A,A);
       HEADER_DSN = '';
     END;

   IF FBIT1(7)  &  FBIT2(7) THEN
     DO;
       PUT FILE(PRINT) SKIP EDIT
           (HEADER_DSN,
            '..DATASET RETPD/EXPIRE DATE=',
            $RETPD_DATE,' IS PAST DUE')
           (A,A,A);
       HEADER_DSN = '';
     END;

   IF FBIT1(4)  &  FBIT2(4) THEN
     DO;
       PUT FILE(PRINT) SKIP EDIT
           (HEADER_DSN,
            '..TRK ALLOC=',DSNLOG.TRK_ALLOC,
            ' > TRK ALLOWED=',GRANT.TRACKS )
           (A,A,P'ZZ,ZZ9',A,P'ZZ,ZZ9');
       HEADER_DSN = '';
     END;

1  IF FBIT1(3)  &  FBIT2(3) THEN
     DO;
       PUT FILE(PRINT) SKIP EDIT
           (HEADER_DSN,
            '..UNUSED FOR ',UNUSED_DAYS,' DAYS..LAST USED=',
            $USED)
           (A,A,P'Z,ZZZ',A,A);
       HEADER_DSN = '';
     END;

   IF FBIT1(5)  &  FBIT2(5) THEN
     DO;
       PUT FILE(PRINT) SKIP EDIT
           (HEADER_DSN,
            '..GRANT EXPIRED ON ',$EXPIRED,
            ' TRKS=',DSNLOG.TRK_ALLOC)
           (A,A,A,A,P'ZZ,ZZ9');
       HEADER_DSN = '';
     END;

   IF FBIT1(6) &  FBIT2(6) THEN
     DO;
       PUT FILE(PRINT) SKIP EDIT
           (HEADER_DSN,
            '..TRK ALLOC=',DSNLOG.TRK_ALLOC,
            ' TRK USED=',DSNLOG.TRK_USED,' = ',PCC,'% USED')
           (A,A,P'ZZ,ZZ9',A,P'ZZ,ZZ9',A,A,A);
       HEADER_DSN = '';
     END;

   RETURN;

 END POST_MSG;

1/* WRITE MERGED LOG RECORD TO OUTLOG DATASET                 */
 WRITE_LOG: PROC(DO_GETBILLTO);

   DCL I     FIXED BIN(15,0) INIT(0),
       TYPSTR CHAR(4)        INIT(' '),
       DO_GETBILLTO BIT(1),
       INBITS      BIT(16)   INIT((16)'0'B);

   OUTREC = DSNLOG, BY NAME;  /* COPY OVER DSNLOG INFO TO RECORD */

   OUTREC.DISKTYPE = SUBSTR( CNVTHX(DSNLOG.UNITYPE ×× (8)'0'B) , 2,1);

   IF DO_GETBILLTO      /* FIND OUT WHO TO DING FOR THE DATASET    */
    THEN DO;
           CALL GET_BILLTO(DSNLOG.DSNAME,DSNLOG.DSORG,OUTREC.BILL_TO);
           OUTREC.EXPIRES = 0;

         END;
    ELSE DO;
           OUTREC.BILL_TO = GRANT.BILL_TO;
           OUTREC.EXPIRES = GRANT.EXPIRES;
         END;

   OUTREC.DSNFLAGS= '';
   DO I = 1 TO 8;                    /* PROCESS DSNFLAGS            */
     IF SUBSTR(FLAGS,I,1) = '1'B THEN
        SUBSTR(OUTREC.DSNFLAGS,I,1) = SUBSTR('ICUBEOR ',I,1);
   END;

   IF (SCR & FLAGS & MASK) ^= '00000000'B
     THEN OUTREC.SCRFLAG = 'S';
     ELSE OUTREC.SCRFLAG = ' ';


   OUTREC.DAYS_UNUSED = UNUSED_DAYS; /* SAVE UNUSED DAYS            */
   IF PC >= 0 & PC <= 1000
    THEN OUTREC.PC_USED = PC; /* SAVE PERCENT TRACK UTILIZATION     */
    ELSE OUTREC.PC_USED = 1000;

   WRITE FILE(OUTLOG) FROM(OUTREC);
   RECOUT_OUTLOG = RECOUT_OUTLOG + 1;

   RETURN;
 END WRITE_LOG;

1/* ESTIMATE WHO TO BLAME FOR DATASET IF BILL_TO IS BLANK          */
 GET_BILLTO: PROC(DSN,INDSORG,BILLSSA);
   DCL BILLSSA CHAR(8),
       DSN     CHAR(44),
       INDSORG CHAR(3),
       DSNDSORG CHAR(2) INIT(' ');

   DSNDSORG = SUBSTR(INDSORG,1,2);
   BILLSSA = '';
     /*                                                            */
     /*  FIND OUT WHO TO DING FOR THE DATASET..                    */
     /*    BY CHECKING THE DSNAME...                               */
     /*                                                            */
     /*  FORM FCIX.X00SSA, VSAM1.X00SSA ETC                        */
     /*    RETURN WITH ' UNKNOWN' IN BILSSA IF NOT FOUND           */
     /*                                                            */
         IF VERIFY(SUBSTR(DSN,7,5),'0123456789') = 0 &
            DSNDSORG ^= 'VS'          THEN
                                 /*                                */
                                 /* FORM XXXX.X00SSA DATASET       */
                                 /*                                */
           DO;
              SUBSTR(BILLSSA,4,5) = '00' ×× SUBSTR(DSN,9,3);
              IF BILLSSA = '   00000' &
                 VERIFY(SUBSTR(DSN,15,3),'0123456789') = 0
               THEN
                DO;
                  SUBSTR(BILLSSA,6,3) = SUBSTR(DSN,15,3);
                END;
           END;
     ELSE
         IF VERIFY(SUBSTR(DSN,2,3),'0123456789') = 0 &
            DSNDSORG ^= 'VS'          THEN
                                 /*                                */
                                 /* FORM XSSA.XXXX   DATASET       */
                                 /*                                */
           DO;
              SUBSTR(BILLSSA,4,5) = '00' ×× SUBSTR(DSN,2,3);
           END;
     ELSE
         IF SUBSTR(DSN,1,3) = 'SYS'  ×
            SUBSTR(DSN,1,4) = 'ARCH' ×
            SUBSTR(DSN,1,4) = 'BKUP' ×
            SUBSTR(DSN,1,4) = 'IPO1' ×
            DSNDSORG = 'VS'                      THEN
                                 /*                                */
                                 /* SYSTEM DATASETS OF SOME FORM   */
                                 /*                                */
           DO;
             SUBSTR(BILLSSA,6,3) = 'MVS';
           END;
     ELSE
         IF SUBSTR(DSN,1,3) = 'IMS' THEN
                                 /*                                */
                                 /* IN GENERAL.. FUNNY IMS DATASETS*/
                                 /*                                */
           DO;
             SUBSTR(BILLSSA,6,3) = 'IMS';
           END;
     ELSE
         IF SUBSTR(DSN,1,8) = 'RESERVED' THEN
                                 /*                                */
                                 /* RESERVED SPACE DATASETS        */
                                 /*                                */
           DO;
             BILLSSA = 'RESERVED';
           END;
     ELSE
         IF SUBSTR(DSN,1,1) = '$'            THEN
                                 /*                                */
                                 /* TSO USER DATASETS              */
                                 /*                                */
           DO;
             I = INDEX(DSN,'.');
             I = I - 1;
             IF I >= 1 THEN      /*  LEFT JUSTIFY TSO USER DATASETS */
               SUBSTR(BILLSSA,1,I) =
                      SUBSTR(DSN,1,I);
           END;
     ELSE
         IF SUBSTR(DSN,1,3) = 'TSO' ×
            SUBSTR(DSN,1,3) = 'SPF' ×
            SUBSTR(DSN,1,6) = 'ONLINE' THEN
                                 /*                                */
                                 /* TSO SYSTEM DATASETS            */
                                 /*                                */
           DO;
             SUBSTR(BILLSSA,6,3) = 'TSO';
           END;
     ELSE
         IF SUBSTR(DSN,1,6) = 'VSAM1.' THEN
           DO;
                                 /*                                */
                                 /* FORM VSAM1.X00SSA. VSAM DSNS   */
                                 /*                                */
             I = INDEX(SUBSTR(DSN,7),'.');
             I = I - 7;
             IF I >= 1 THEN
               SUBSTR(BILLSSA,9-I,I) =
                      SUBSTR(DSN,7,I+7);
             IF SUBSTR(BILLSSA,4,2) = '00' THEN
                SUBSTR(BILLSSA,1,3) = '   ';
           END;

         IF BILLSSA = '        ' THEN BILLSSA = ' UNKNOWN';

    RETURN;

  END GET_BILLTO;

1/* CONVERT ASM2 USAGE INFORMATION INTO A NICE PRINTABLE FORM */
 GET_USE: PROC;

   $USE_INFO = '';   /* INIT USEAGE INFO TO BLANK */

   PACK5 = DSNLOG.CREATED;
   CALL R941X12(PACK5,PACK6);
   $CREATED = PACK6;
   PACK5 = DSNLOG.LAST_USED;
   CALL R941X12(PACK5,PACK6);
   $USED    = PACK6;

   $USE_INFO = 'CREATED=' ×× $CREATED ×× ' USED=' ×× $USED;

   PACK5 = DSNLOG.LAST_MOD;
   IF PACK5 = 0 THEN RETURN;   /* NO MORE USE DATA PRESENT */

   CALL R941X12(PACK5,PACK6);
   $MOD_DATE= PACK6;
   BIT16 = DSNLOG.LAST_MOD_TIME;
   $MOD_TIME= CNVTHX(BIT16);
   $USE_INFO = $USE_INFO ×× ' LAST MOD=' ×× $MOD_DATE ××
               ' ' ×× $MOD_TIME ×× ' BY ' ×× DSNLOG.MOD_USER;

   RETURN;

 END GET_USE;
1/* CNVTHX - PROCEDURE TO CONVERT 16 BIT TO 4 CHAR HEX */

 CNVTHX: PROC(N) RETURNS(CHAR(4));

 DCL N  BIT(16),
     (HEXOUT,XOUT) CHAR(4) INIT(' '),
     CH(0:15) CHAR(1) STATIC INIT(
       '0','1','2','3','4','5','6','7',
       '8','9','A','B','C','D','E','F'  ),
     NUM BIT(16),
     (II,J,K)  FIXED BIN(15,0);

 NUM = UNSPEC(N);
 DO K = 1 TO 4;
   J = (K-1)*4+1;
   UNSPEC(II) = (12)'0'B ×× SUBSTR(NUM,J,4);
   SUBSTR(XOUT,K,1) = CH(II);
 END;
 HEXOUT = XOUT;
 RETURN (HEXOUT);
 END CNVTHX;


1 JULIAN : PROC (DATEX) RETURNS (CHAR(5));
0 DCL DATEX CHAR (6);
  DCL DATEY CHAR (5), NDAYS PICTURE '999'  INIT (0);
0 DCL MTHS (12) FIXED BIN (15) INIT
       (31,28,31,30,31,30,31,31,30,31,30,31);
  IF MOD ( SUBSTR (DATEX,1,2) , 4 ) = 0
  THEN MTHS (2) = 29;
  SUBSTR (DATEY,1,2) = SUBSTR (DATEX,1,2);
- DO I = 1 TO SUBSTR (DATEX,3,2) - 1;
     NDAYS = NDAYS + MTHS (I);
  END;
  NDAYS = NDAYS + SUBSTR (DATEX,5,2);
0 SUBSTR (DATEY,3,3) =      NDAYS;
0 RETURN (DATEY);
  END JULIAN;
1         JUL2DAY: PROC (INDATE) RETURNS(FIXED BIN(31));

 /*                                                                   */
 /* FUNCTION CONVERTS INTEGER DATE IN YYDDD JULIAN FORMAT TO          */
 /* JULIAN DAYS SINCE 1900 .  MOD(DAYS,7) PRODUCES 0=SAT, THRU 6=FRI  */
 /*                                                                   */
 /* KEN TRUE 2JUN77 FROM MY FORTRAN CODE (W GREG QUEEN) OF SEPT72     */
 /*                                                                   */

 DCL INDATE       PIC'99999',
     (Y,M,D,MY4,I) FIXED BIN(31,0),
     MONTH(11)    FIXED  BIN(31,0)
           INIT(31,59,90,120,151,181,212,243,273,304,334);

      D   = MOD(INDATE,1000);
      Y   = INDATE/1000;
      MY4 = MOD(Y,4);

      I   =1461*(Y/4) +365*MY4 + D;
      IF MY4 > 0 ×
         ((MY4 = 0) & D > 59) THEN I = I + 1;
      RETURN(I);
  END JUL2DAY;
1         JDY2JUL: PROC (INDAYS) RETURNS(PIC'99999');

 /*                                                                   */
 /* FUNCTION CONVERTS INTEGER DAYS SINCE 1900 INTO JULIAN DATE IN     */
 /* P'YYDDD' FORMAT.                                                  */
 /*                                                                   */
 /* KEN TRUE 2JUN77 FROM MY FORTRAN CODE (W GREG QUEEN) OF SEPT72     */
 /*                                                                   */

 DCL INDAYS       FIXED BIN(31,0),
     OUTDATE      PIC'99999',
     (YR,YREM,JYR,JDY) FIXED BIN(31,0),
     I            FIXED  BIN(15,0),
     MONTH(0:11)  FIXED  BIN(31,0)  STATIC
           INIT(0,31,59,90,120,151,181,212,243,273,304,334);

     YR=((INDAYS-1)/1461)*4;
     YREM=MOD(INDAYS-1,1461)+1;
     JYR=(YREM-1)/365;
     JDY=MOD(YREM-1,365);

     IF JYR*JDY >  0 THEN
       DO;
         YR = YR+JYR;
         OUTDATE = YR*1000 + JDY;
         RETURN (OUTDATE);
       END;

     IF JYR > 0 THEN
       DO;
         YR = YR+JYR-1;
         OUTDATE = YR*1000+365;          /* ITS DEC 31 OF THE YEAR */
         IF MOD(YR,4) = 0 THEN OUTDATE = OUTDATE + 1;
         RETURN (OUTDATE);
       END;

     IF JDY = 0 THEN
       DO;
         OUTDATE = YR*1000+1;   /* ITS JAN 1 OF THE YEAR */
         RETURN (OUTDATE);
       END;

     IF JDY = 59 THEN
       DO;
         OUTDATE = YR*1000+60;   /* ITS FEB 29 OF THE YEAR*/
         RETURN (OUTDATE);
       END;

     IF JDY < 60  THEN  JDY = JDY+1;

     YR = YR+JYR;
     OUTDATE = YR*1000 + JDY;
     RETURN (OUTDATE);

  END JDY2JUL;
1/* GET_PARMS - ROUTINE TO GET/PARSE PARAMETER CARDS     */
 /*                                                      */
  GET_PARMS: PROC (RET_CODE);
  DCL     BIN_ONCODE       FIXED BIN(31),
          COMMANDNO        FIXED BIN(15) INIT(0),
          SYNTAX_ERR       FIXED BIN(15) INIT(0),
          RET_CODE         FIXED BIN(31,0),
          COMREC           CHAR(1024) VARYING,
          CONTINUE_FLAG    BIT(1),
          EOF_FLAG         BIT(1)        INIT(0B),
          PARSE_ERR        BIT(1),
          TOOLONG          BIT(1),
          CARDRPT          EXTERNAL ENTRY,
          GETCOM           EXTERNAL ENTRY;
                             /*                                       */
                             /* DO THIS FOR ALL SYSIN INPUT           */
                             /*                                       */
          DO WHILE (^EOF_FLAG);
             COMREC='';
             COMMANDNO=COMMANDNO+1;
                                                       /* GET COMMAND */
             CALL GETCOM
                  (COMMANDNO,COMREC,EOF_FLAG,TOOLONG,CONTINUE_FLAG);
             IF TOOLONG THEN SYNTAX_ERR=SYNTAX_ERR+1;
             IF ^EOF_FLAG × CONTINUE_FLAG THEN DO;
                PARSE_ERR=0B;      /* START OUT WITH NO PARSE ERRS */
                               /*               */
                               /* PARSE COMMAND */
                               /*               */

                CALL PARSE
                     (COMMANDNO,COMREC,PARSE_ERR);
                IF PARSE_ERR THEN SYNTAX_ERR=SYNTAX_ERR+1;
             END;
          END;
                       /*          EOF ON SYSIN                       */
                       /*   DETERMINE RET_CODE BASED ON               */
                       /*   IGNORE, SYNTAX_ERR, EXEC_ERR, & EXEC_OK   */

          PUT FILE(REPORT) SKIP(2) EDIT
              (SYNTAX_ERR)                   (COL(14),P'ZZ,ZZ9')
              (' SYNTAX ERRORS ENCOUNTERED') (A);

          IF SYNTAX_ERR ^= 0 & RET_CODE = 0 THEN RET_CODE = 12;

   RETURN;

 END GET_PARMS;
1/* PARSE -  PARSE COMMANDS AND SET UP PROGRAM CONSTANTS */

  PARSE: PROC(COMNUM,COMMAND,ERROR_FLAG);
    DCL COMNUM    FIXED BIN(15,0),
        CMDNUMBER FIXED BIN(15,0) INIT(0),
        COMMAND   CHAR(*) VAR,
        OUTLINE   CHAR(120)  INIT(' '),
        (I,J,K)   FIXED BIN(15,0),
        ERROR_FLAG BIT(1),
        FOUND_CMD  BIT(1)  INIT(0B),
        COMCMD     CHAR(10) VAR,
        CARDRPT            EXTERNAL ENTRY,
        COMTAB( 8)  CHAR(10) VAR STATIC
          INIT('*','RUNOPT','SCRATCH','THRESH',
               'TIMES','SYSU','TITLE','PRINT');

    DO I=1 TO DIM(COMTAB,1) WHILE(^FOUND_CMD);
      COMCMD = SUBSTR(COMMAND,1,LENGTH(COMTAB(I)));
      IF COMCMD = COMTAB(I)
         THEN FOUND_CMD = '1'B;
    END;
    IF FOUND_CMD THEN I = I - 1;   /*  KLUDGE  */
    IF ^FOUND_CMD THEN
      DO;
        ERROR_FLAG = '1'B;
        OUTLINE = '***ERROR*** UNRECOGNIZED COMMAND';
        CALL CARDRPT(OUTLINE);
        RETURN;
      END;
    ELSE
      DO;
        ERROR_FLAG = '0'B;
        CMDNUMBER = I;
      END;
                        /*                                   */
                        /*  PROCESS: '*' (COMMENT) COMMAND   */
                        /*                                   */
  IF CMDNUMBER = 1  THEN
    DO;
       RETURN;
    END;
                        /*                                   */
                        /*  PROCESS: RUNOPTIONS    COMMAND   */
                        /*                                   */
  IF CMDNUMBER = 2  THEN
    DO;
      J  = INDEX(COMMAND,'CATCHK=YES');
      DO_CATCHK = J ^= 0;
      RETURN;
    END;
                        /*                                   */
                        /*  PROCESS: SCRATCH       COMMAND   */
                        /*                                   */
  IF CMDNUMBER = 3  THEN
    DO;
      SCR = '00000000'B;   /*CLEAR OUT SCRATCH FLAGS */
      DO I = 1 TO DIM(OPTIONS.TEXT,1);
         IF INDEX(COMMAND,OPTIONS.TEXT(I)) ^= 0 THEN
           DO;
             SCR = SCR × OPTIONS.BIT(I);
           END;
      END;
      I = INDEX(COMMAND,'INDAYS=');
      IF I > 0 THEN
         CALL GET_NUMBER(COMMAND,I+7,SCRATCH_DAYS,ERROR_FLAG);
      IF I > 0 & ERROR_FLAG THEN
        DO;
          OUTLINE = '***ERROR*** INVALID NUMBER GIVEN FOR INDAYS';
          CALL CARDRPT(OUTLINE);
        END;
      RETURN;
    END;

                        /*                                   */
                        /*  PROCESS: THRESHOLD     COMMAND   */
                        /*                                   */
  IF CMDNUMBER = 4  THEN
    DO;
      I = INDEX(COMMAND,'UNUSED=');
      IF I > 0 THEN
         CALL GET_NUMBER(COMMAND,I+7,THRESH_DAYS,ERROR_FLAG);
      IF I > 0 & ERROR_FLAG THEN
        DO;
          OUTLINE = '***ERROR*** INVALID NUMBER GIVEN FOR UNUSED';
          CALL CARDRPT(OUTLINE);
        END;
      IF THRESH_DAYS < 0 THEN ERROR_FLAG = '1'B;
      I = INDEX(COMMAND,'PERCENT=');
      IF I > 0 THEN
         CALL GET_NUMBER(COMMAND,I+9,PC_THRESH,ERROR_FLAG);

      IF I > 0 & ERROR_FLAG THEN
        DO;
          OUTLINE = '***ERROR*** INVALID NUMBER GIVEN FOR PERCENT';
          CALL CARDRPT(OUTLINE);
        END;
      IF PC_THRESH > 0 &
         PC_THRESH < 100 THEN PC_THRESH = PC_THRESH * 10;
       ELSE IF I > 0     THEN ERROR_FLAG = '1'B;

      RETURN;
    END;


                        /*                                   */
                        /*  PROCESS: TIMESTAMP     COMMAND   */
                        /*                                   */
  IF CMDNUMBER = 5  THEN
    DO;
      OUTLINE = 'WARNING: THE TIMESTAMP COMMAND IS NOT YET IMPLEMENTED';
      CALL CARDRPT(OUTLINE);

      RETURN;
    END;


                        /*                                   */
                        /*  PROCESS: SYSUSERS      COMMAND   */
                        /*                                   */
  IF CMDNUMBER = 6  THEN
    DO;
      OUTLINE = 'WARNING: THE SYSUSERS COMMAND IS NOT YET IMPLEMENTED';
      CALL CARDRPT(OUTLINE);
      RETURN;
    END;
                        /*                                   */
                        /*  PROCESS: TITLE         COMMAND   */
                        /*                                   */
  IF CMDNUMBER = 7  THEN
    DO;
      I = INDEX(COMMAND,' '); /* FIND FIRST BLANK */
      SUBTITLE = SUBSTR(COMMAND,I+1,
                        MIN(112,LENGTH(COMMAND)-I) );

      IF SUBSTR(SUBTITLE,1,1) = '''' THEN     /* REMOVE LEADING AND   */
         SUBTITLE = SUBSTR(SUBTITLE,2);       /*  TRAILING QUOTE MARKS*/
      I = LENGTH(SUBTITLE);                   /*  IF NEED BE          */
      IF SUBSTR(SUBTITLE,I,1) = '''' THEN
         SUBTITLE = SUBSTR(SUBTITLE,1,I-1);

      IF LENGTH(SUBTITLE) > 0 THEN
        DO;
          HEADING2 = '';
          I = (LENGTH(HEADING2) - LENGTH(SUBTITLE))/2;
          SUBSTR(HEADING2,I+1,LENGTH(SUBTITLE)) = SUBTITLE;
        END;


       RETURN;
    END;
                        /*                                   */
                        /*  PROCESS: PRINT         COMMAND   */
                        /*                                   */
  IF CMDNUMBER = 8  THEN
    DO;


      PRT_FLAGS = '00000000'B; /*CLEAR OUT PRINT   FLAGS */

      DO I = 1 TO DIM(OPTIONS.TEXT,1);

         IF INDEX(COMMAND,OPTIONS.TEXT(I)) ^= 0
            THEN PRT_FLAGS = PRT_FLAGS × OPTIONS.BIT(I);
      END;

      RETURN;
    END;

  RETURN;

  END PARSE;


1/* GET_NUMBER    EXTRACT A NUMBER FROM A STRING                    */

 GET_NUMBER: PROC(STRING,POSITION,NUMBER,ERROR);

 DCL STRING     CHAR(*) VAR,
     POSITION   FIXED BIN(15,0),
     NUMBER     FIXED BIN(31,0),
     ERROR      BIT(1);

 DCL NUMSTR     CHAR(11) VAR INIT(''),
     COMPCHR    CHAR(1)      INIT(' '),
     (I,J,K)    FIXED BIN(15,0) INIT(0);

   I = LENGTH(STRING);
   J = I - POSITION + 1;
   J = MIN(11,J);        /* TAKE NEXT 11 CHAR OR END OF STRING */

   ERROR = '0'B;
   NUMSTR = SUBSTR(STRING,POSITION,J);   /* EXTRACT OUT OUT STRING */

   I = VERIFY(NUMSTR,'0123456789+-');    /* CHECK IT FOR VALIDITY  */

   IF I > 0 THEN        /* SOME BOZO CHARACTER */
     DO;
       COMPCHR = SUBSTR(NUMSTR,I,1);     /* EXTRACT THE OFFIENDI.. */
       J = VERIFY(COMPCHR,' ,()');       /* SEE IF ITS ONE WE LIKE */
       IF J = 0 THEN NUMSTR = SUBSTR(NUMSTR,1,I-1);
                ELSE ERROR = '1'B;
     END;

   IF ^ERROR THEN NUMBER = NUMSTR;       /* CONVERT TO NUMBER      */

   END GET_NUMBER;

1/* PRINT RUN TIME OPTIONS */

 PRINT_PARMS: PROC (PRNTFLAG);

   DCL PARM_OPTS    CHAR(80) VARYING,
       PRNTFLAG     BIT(1);

   PARM_OPTS = '';
   IF DO_CATCHK THEN PARM_OPTS = 'CATCHK=YES';
                ELSE PARM_OPTS = 'CATCHK=NO';

   IF PRNTFLAG THEN
     PUT FILE(REPORT) SKIP(2) EDIT
       ('  RUNOPTIONS ',PARM_OPTS)
       (A,A);

   CALL SHOW_BIT_OPTS(SCR,PARM_OPTS);

   PUT FILE(REPORT) SKIP(2) EDIT
      ('  SCRATCH    OPTIONS=(',PARM_OPTS,'),',
       '             INDAYS=',SCRATCH_DAYS,',SCRDATE=',$SCRDATE)
      (A,A,A,SKIP,A,P'999',A,A);


   CALL SHOW_BIT_OPTS(PRT_FLAGS,PARM_OPTS);

   IF PRNTFLAG THEN
     PUT FILE(REPORT) SKIP(2) EDIT
        ('  PRINT      OPTIONS=(',PARM_OPTS,')')
        (A,A,A);

   PUT FILE(REPORT) SKIP(2) EDIT
      ('  THRESHOLD  UNUSED=',THRESH_DAYS,' DAYS,DATE=',THRESH_JDATE,
       'PERCENT=',PC_THRESH)
      (A,P'999',A,P'99.999',SKIP,X(13),A,P'ZZ9.9');

   PARM_OPTS = '';

   DO I = 1 TO DIM(VOLTAB,1) WHILE(VOLLEN(I) > 0);
     PARM_OPTS = PARM_OPTS ×× ',' ×× SUBSTR(VOLTAB(I),1,VOLLEN(I));
   END;

   IF SUBSTR(PARM_OPTS,1,1) = ',' THEN
       PARM_OPTS = SUBSTR(PARM_OPTS,2);

   IF PRNTFLAG THEN
     PUT FILE(REPORT) SKIP(2) EDIT
        ('  TIMESTAMP  VOLUMES=(',PARM_OPTS,'),')
        (A,A,A);

   PARM_OPTS = '';

   DO I = 1 TO DIM(DSNTAB,1) WHILE(DSNLEN(I) > 0);
     PARM_OPTS = PARM_OPTS ×× ',' ×× SUBSTR(DSNTAB(I),1,DSNLEN(I));
   END;

   IF SUBSTR(PARM_OPTS,1,1) = ',' THEN
       PARM_OPTS = SUBSTR(PARM_OPTS,2);

   IF PRNTFLAG THEN
     PUT FILE(REPORT) SKIP EDIT
        ('             OMITDSN=(',PARM_OPTS,')')
        (A,A,A);

   PARM_OPTS = '';

   DO I = 1 TO DIM(SYSUSERS,1) WHILE(SYSUSERS(I) ^= '        ');
     J = VERIFY(SYSUSERS(I),' ');
     IF J = 0 THEN J = 1;
     PARM_OPTS = PARM_OPTS ×× ',' ×× SUBSTR(SYSUSERS(I),J);
   END;

   IF SUBSTR(PARM_OPTS,1,1) = ',' THEN
       PARM_OPTS = SUBSTR(PARM_OPTS,2);

   IF PRNTFLAG THEN
     PUT FILE(REPORT) SKIP(2) EDIT
        ('  SYSUSERS   (',PARM_OPTS,')')
        (A,A,A);


   IF PRNTFLAG THEN
     PUT FILE(REPORT) SKIP(2) EDIT
        (' END OF RUN PARAMETER LIST')
        (A);


  RETURN;

 END PRINT_PARMS;
1/* GENERATE BIT OPTIONS PRINTABLE MESSAGES AS CHAR STRING       */
0 SHOW_BIT_OPTS: PROC(INBIT8,POPTION);

   DCL INBIT8    BIT(8),
       POPTION   CHAR(*) VAR ;

   POPTION = '';

   DO I = 1 TO DIM(OPTIONS.BIT,1);

     IF (INBIT8 & OPTIONS.BIT(I)) ^= '00000000'B THEN
         POPTION = POPTION ×× ',' ×× OPTIONS.TEXT(I);
   END;

   IF SUBSTR(POPTION,1,1) = ',' THEN
       POPTION = SUBSTR(POPTION,2);

   RETURN;

  END SHOW_BIT_OPTS;


 END P963P00;
