ZAP      TITLE 'ZAP --- DISPLAY AND MODIFY DATA SETS'
*
*   ASSEMBLER OPTIONS: RENT, ALIGN, LINECOUNT(53), XREF(SHORT), ...
*                    NO NEED FOR BATCH OPTION (ONE END STATEMENT), BUT
*                    YOU WILL NEED A MODGEN (OR AMODGEN) MACRO LIBRARY
*
*   LINKAGE EDITOR OPTIONS: RENT, REUS, MAP
*                      (AND AC=1 FOR MVS, IF YOU WANT TO ZAP VTOC'S)
*
         MACRO
&N       TSWORK &DUMMY
         EJECT
CS#      DS    0D
*
*  ZAP'S DATA AREA FOR EXP
*
GORF     DS    F                        SAVE AREA FOR PTR
EXPOPT   DS    X                        WHETHER TO SCAN LABEL TAB
DBLW     DS    D
EXPWORK  DS    D
EXPARMS  DS    0F                       'SAVEAREA' FOR 'EXP'
EXPFLAG  DS    4F
EXPSTART DS    A
         DS    F                        LENGTH
EXPPTR   DS    A
         SPACE 3
*
*  ZAP'S DATA AREA
*
AINVEXP  DS    A                        ADDRESS OF INVALID EXP MESSAGE
NOWBYTE  DS    F   (MUST BE TOGETHER)   LOC OF CARET
NOWBYTE2 DS    F   (MUST BE TOGETHER)   DBLW DISP INTO BUFF/8*8
BITS     DS    X   (MUST BE TOGETHER)   LOW ORDER 3 BITS OF OFFSET
OLDPOINT DS    H   (MUST BE TOGETHER)   OFFSET INTO BUFFER
         SPACE 2
AIDEFTAB DS    A                        ADDR OF DEFINE TABLE
FIRSTSCR DS    A                        ADDR OF FIRST SCREEN LOC
MAXSCR   DS    A                        ADDR OF END OF AVAIL SCR
ADDRWORK DS    F                        ADDRESS OF MSG AND WTO WORK
CSOUTWK  EQU   ADDRWORK                 CSOUT WORKAREA IS FIRST
TEMPTRT  DS    256X                     TEMP TRTAB FOR STRING ANAL
         SPACE 2
* PROVIDE SPACE FOR W 10,10   (OR 10 ABOVE CARET, CARET LINE, 10 BELOW)
SCREEN   DS    0D,21CL40                SCREEN BUFFER
SCRLINES EQU   (*-SCREEN)/40            NUMBER OF LINES/FULL SCREEN
EOFIOERR DS    CL40                     EOF OR I/O ERROR MESSAGE
GENERROR DS    CL40                     GENERAL ERROR MESSAGE
WHERELIN DS    3CL40                    3 LINES FOR WHEREAMI
WHEREL   EQU   *-WHERELIN               LENGTH
REP      DS    44C                      REPLY BUFFER
DSNAMEL  DS    H                        LENGTH OF DSN (44)
DSNAME   DS    44C                      DSN
TTR      DS    F                        TTR OF BLK
         SPACE 2
IDEFFMT  EQU   SCREEN+160               DEFINE TABLE DISP (SCR WINDOW)
IDEFAVAL DS    A                        1ST AVAL POSIT IN DEFINE TAB
IDEFTAB  DS    24XL10                   24 ENTRY DEFINE TABLE
ENDITAB  DS    X                        END OF TABLE (X'FF')
*
*  EACH ENTRY ABOVE IS OF THE FORM (8C,H), CORRESP TO 'SYMBOL,OFFSET'
*
         SPACE 2
ITRFMT   EQU   IDEFFMT                  TRACE TABLE DISPLAY
ITRAVAL  DS    A                        1ST AVAIL TRACE TAB POSIT
ITRTAB   DS    24XL5                    TRACE TABLE
ITREND   DS    X                        END OF TABLE (X'FF')
CURRITR  DS    F                        CURRENT TRACE TABLE ENTRY PTR
*
*  EACH ENTRY ABOVE IS OF THE FORM (3X,2X), CORRESP TO 'TTR,OFFSET'
*
         SPACE 2
DEVSZ    DS    H                        CYLINDER CAPACITY
DEVDT    DS    CL1                      TRACK CAPACITY
SAVEHI   DS    CL5                      HIGHEST CCHHR--FORMAT 1 DSCB'S
DSCBCC   DS    CL5                      CURRENT CCHHR IN VTOC
SAVCCHHR DS    CL5                      SAVE AREA FOR EXPECTED CCHHR
DDNAME   DS    CL8                      CURRENT DDNAME ALLOCATED
DOUBLW   DS    D                        TEMPORARY
TEMP     DS    2D                       WORK AREA
TEMP2    DS    5D                       WORK AREA
TEMP3    DS    11F                      WORK AREA
TRTABADD DS    A                        PTR TO TRTAB FOR DUMP DISPLAY
SAVECSIO DS    5F                       SAVE 2-6 IN CSIO
IKJSCAN  DS    A                        ADDRESS OF IKJSCAN (LOADED)
IKJPARS  DS    A                        ADDRESS OF IKJPARS (LOADED)
IKJDAIR  DS    A                        ADDRESS OF IKJDAIR (LOADED)
IKJHELP  DS    A                        ADDRESS OF HELP (LOADED)
         SPACE 1
MIDLINE  DS    A                        CARET
WIDTHS   DS    0F                       FOR WINDOWS      ×**********×
WIDTHD   DS    F                        FOR DOWN         ×CONTIGUOUS×
WIDTHU   DS    F                        UP               ×**********×
         SPACE 2
MAXTT    DS    H                        MAXIMUM TT OF TTR ALLOWED
MAXHH    DS    H                        MAXIMUM TRACKS/CYLINDER
EXCPBUF  DS    H                        SIZE OF EXCP BUFFER
REALRDLN DS    H                        ACTUAL COMND READ LENGTH
READLEN  DS    H                        READLENGTH FROM TGET
DSORG    DS    X                        DSORG OF CURRENT DATASET
RECFM    DS    X                        RECORD FORMAT
GODFLAG  DS    X                        MOST USEFUL FLAG
MEMTTR   DS    3X                       SAVE MEMBER'S TTR
CSINIT   DS    8C                       UID
MEMBER   DS    8C                       MEMBER FOR PDS SEARCH
TRACE    DS    X                        FLAG-TRACE IN EFFECT OR NOT
CONTINUE DS    X                        STORES, SCAN, SET IN EFFECT
IOERROR  DS    X                        FLAG-SYNAD I/O ERROR OR NOT
EOFRET   DS    X                        IGNORE EOF'S?
IDRFLAG  DS    X                        WHETHER IDR WAS UPDATED OR NOT
FLAGS2   DS    X                        MISC FLAGS FOR TSO VERSION
MUSTZAP  EQU   X'80'                      BLK NOT REP, ENTER SAVE/END
NOT1ST   EQU   X'40'                      NOT 1ST TIME THRU
QUOTED   EQU   X'08'                      DSNAME WAS 'QUOTED'
VTOC     EQU   X'04'                      VTOC PROCESSING
FILENAME EQU   X'01'                      DDNAME ALREADY ALLOCATED
         SPACE 2
         SPACE 2
LOOKFOR  DS    40X                      SCAN WORK AREA (LEN+STRING)
ZAPSTRNG DS    40X                      S,EX,O,N WORK AREA (LEN+STRING)
SETSTR   DS    40X                      SET WORK AREA (LEN+STRING)
         SPACE 2
OPTCD    DS    X                        OPTCD FIELDS FROM DSCB
LRECL    DS    H                        MAX LOGICAL RECORD LENGTH
BLKSIZE  DS    H                        MAX BUFFER SIZE
KEYLEN   DS    H                        CURRENT KEY LENGTH
BLKLEN   DS    H                        ACTUAL BLOCK LENGTH AFTER READ
ADDRBUFF DS    A,A                      ADDRESS OF KEY AND DATA
         SPACE 2
DSAVE    DS    H                        SAVE ENTRY NUMBER FOR D COMMAND
ESDID    DS    H                        ESD ID
EXLST    DS    0F                       DCB EXIT LIST WORD (FOR OPEN)
ENDTTR   DS    F                        TTR OF LAST BLK IN DATASET
         SPACE 2
DCBLIST  DS    F                        DCB PTR MF=L OPEN AND CLOSE
DSCBLIST EQU   SCREEN
VOLSER   DS    8C                       VOL=SER OF DSN
         EJECT
*
*        ORDER IS IMPORTANT IN THE FOLLOWING STATEMENTS:
*
CCW      DS    0D
CCW1INIT CCW   X'31',IOBSEEK+3-CCW,X'60',5  SEARCH ID EQUAL (CCHHR)
         CCW   X'08',*-8-CCW,X'60',1        TIC
         CCW   X'92',IOBSEEK+3-CCW,X'20',8  MT READ NEXT COUNT
*
CCW1     CCW   X'31',IOBSEEK+3-CCW,X'60',5  SEARCH ID EQUAL (CCHHR)
CCW2     CCW   X'08',*-8-CCW,X'60',1        TIC
CCW3     CCW   X'06',*-*,X'20',*-*          READ DATA
*
CCW1W    CCW   X'31',CURMBB+3-CCW,X'60',5   SEARCH ID EQUAL (CCHHR)
CCW2W    CCW   X'08',*-8-CCW,X'60',1        TIC
CCW3W    CCW   X'05',*-*,X'20',*-*          UPDATE DATA
CDATAL   EQU   *-CCW
*
         DS    0F
IOB      DS    X'C2000000'                  START OF IOB
ECBPTR   DS    A(*-*)                       POINTS TO ECB
CSW      DS    2A(0)
CPADDR   DS    A(*-*)                       POINTS TO CCW'S
IN       DS    A(*-*)                       POINTS TO DCB
         DS    2A(0)
IOBSEEK  DS    2A(0)          NEXT MBBCCHHR ADDRESS
KEYLN    DS    X              NEXT KEYLENGTH
DATALN   DS    2X             NEXT RECORD LENGTH
*
CURMBB   DS    CL8            CURRENT MBBCCHHR ADDRESS
CCWIOBL  EQU   *-CCW1
         SPACE 2
*
*   ORDER IS IMPORTANT IN THE ABOVE STATEMENTS
*
ECB      DS    F              ECB
EXCPR14  DS    F              RETURN REGISTER FOR EXCP
EXTT     DS    F              TEMPORARY FOR EXCP ROUTINES
         SPACE 2
GETLIST  GETMAIN EC,MF=L
GETLISTL EQU   *-GETLIST                LENGTH OF GETMAIN LIST
         SPACE 2
         DS    F                        CLOBBERED BY INITIALIZING DCB
DCBU     DCB   MACRF=E,DDNAME=DDNAME,DSORG=DA  EXCP LEVEL DCB
         SPACE 2
CSLEN    EQU   *-CS#                    LENGTH MY AREA
         MEND
         PRINT OFF                  **** SAVE SOME PAPER
         SPACE 3
         MACRO
&N       OP    &M,&F,&O
         LCLC  &F$
&F$      SETC  '&F'
         AIF   ('&F'(1,1) NE '''').OK
&F$      SETC  '&F'(2,1)
.OK      AIF   ('&F'(1,1) EQ 'X').HEX
&N       DC    CL5'&M',C'&F$',X'&O'
         MEXIT
.HEX     ANOP
&F$      SETC  '&F'(2,8)
&N       DC    CL5'&M',X'&F$',X'&O'
         MEND
         SPACE 3
         MACRO
&LBL     TTRMBB  &TTR,&MBB=DOUBLW  TTR TO MBBCCHHR CONVERSION MACRO
&LBL     STM     R2,R12,28(R13)    SAVE REGISTERS 2-12
         L       R1,&TTR           TTRN ACTUALLY
         SLDL    R0,24             SHIFT TTR INTO R0
         SLL     R0,8              ADJUST
         L       R1,DCBDEBAD-IHADCB+DCBU DEB ADDRESS
         LA      R2,&MBB           RESULT ADDRESS
         LR      R3,R13            SAVE SAVEAREA REGISTER
         L       R15,16            CVT POINTER
         L       R15,28(,R15)      TTRN->MBBCCHHR ROUTINE ADDRESS
         BALR    R14,R15           CALL IT
         LR      R13,R3            RESTORE R13
         LM      R2,R12,28(R13)    RESTORE REGISTERS 2-12
         MEND
         SPACE 3
         MACRO
&LBL     MBBTTR  &TTR,&MBB=DOUBLW  MBBCCHHR TO TTR CONVERSION MACRO
&LBL     STM     R2,R12,28(R13)    SAVE REGISTERS 2-12
         L       R1,DCBDEBAD-IHADCB+DCBU DEB ADDRESS
         LA      R2,&MBB           CONVERT ADDRESS
         LR      R3,R13            SAVE SAVEAREA REGISTER
         L       R15,16            CVT POINTER
         L       R15,32(,R15)      MBBCCHHR->TTRN ROUTINE ADDRESS
         BALR    R14,R15           CALL IT
         LR      R13,R3            RESTORE DESTROYED SAVE REGISTER
         ST      R0,&TTR           SAVE RESULT OF TTRN
         LM      R2,R12,28(R13)    RESTORE REGISTERS 2-12
         MEND
         SPACE 3
         MACRO
&LBL     TSENTRY &Z,&BASE=12,&SYMREG=YES,&PL=,&GETMAIN=0,&MACRO=,      X
               &DSECT=NO,&LOAD=,&MAP=,&PARSE=,&EXIT=,&SP=1
.*** TSENTRY MACRO COPIED FROM UCLA MACRO LIBRARY
         GBLB  &GDAIRM,&GPARSEM         FLAGS TO AVOID DUPLICATES
         GBLB  &GDAIR,&GPARSE           DAIR OR PARSE LOADED
         LCLA  &A,&J
         LCLB  &C,&P,&D,&I,&M
         LCLC  &PARNAME                 ENTRY PARM IF PARSE LOADED
&PARNAME SETC  ''
TSDSECT  DSECT
TSAVE    DS    18F                      SAVE AREA
         TSCPPL
         AIF   ('&PL' EQ '').L12
TSECB    DS    F                        ECB FOR THE TSO SERVICES
&A       SETA  1
.L1      AIF   ('&PL(&A)' NE 'CSCAN').L2
&C       SETB  1
         AGO   .L7
.L2      AIF   ('&PL(&A)' NE 'PARSE').L3
&P       SETB  1
         AGO   .L7
.L3      AIF   ('&PL(&A)' NE 'DAIR').L4
&D       SETB  1
         AGO   .L7
.L4      AIF   ('&PL(&A)' NE 'IO').L5
&I       SETB  1
         AGO   .L7
.L5      AIF   ('&PL(&A)' NE 'MESSAGE').L6A
&M       SETB  1
         AGO   .L7
.L6A     AIF   ('&PL(&A)' NE 'DAIRM').L6
&D       SETB  1                        DAIR PARAMETER LISTS
         AGO   .L7
.L6      MNOTE 4,'UNKNOWN PL PARAMETER = &PL(&A)'
.L7      ANOP
&A       SETA  &A+1
         AIF   (&A LE N'&PL).L1
         AIF   ('&PARSE(2)' EQ '').L7E
&M       SETB  1                        GENERATE THE MESSAGE STUFF
.L7E     AIF   (NOT &C).L8
         TSCSPL
.L8      AIF   (NOT &P).L9
         TSPPL
.L9      AIF   (NOT &D).L10
         TSDAPL
DAPBAREA DS    22F *                    AREA FOR DAIR PARAMETER BLOCK
         TSDMPL
.L10     AIF   (NOT &I).L11
         TSIOPL
.L11     AIF   (NOT &M).L12
         TSMPL
.L12     ANOP
&J       SETA  0
.L12L    ANOP
&J       SETA  &J+1
         AIF   ('&LOAD(&J)'  EQ  '').L12Z
&LOAD(&J) DS   F
         AGO   .L12L
.L12Z    AIF   ('&MACRO' NE 'YES').L12A
         SPACE 2
***********************************************************************
*                                                                     *
*        DYNAMIC STORAGE DEFINED BY USER TSWORK MACRO                 *
*                                                                     *
***********************************************************************
         SPACE
         DS    0D                       BEGIN ON DOUBLE WORD BOUNDARY
         TSWORK
.L12A    AIF   ('&GETMAIN' EQ '0').L12B
TSWORK   DS    0D                       POINTER TO USER WORK AREA
.L12B    ANOP
TSDSECTL DS    0D
         AIF   ( NOT &D ).NODM
         AIF   ( &GDAIRM ).NODM
&GDAIRM  SETB  1                        SET 1 TIME FLAG
.*       EJECT
.*       IKJDAP04
.* B04L  EQU   *-DAPB04 *               LENGTH OF DAPB04 BLOCK
         EJECT
         IKJDAP08
DAPB08L  EQU   *-DAPB08 *               LENGTH OF DAPB08 BLOCK
         EJECT
         IKJDAP18
DAPB18L  EQU   *-DAPB18 *               LENGTH OF DAPB18 BLOCK
         SPACE 3
         IKJDAP1C
DAPB1CL  EQU   *-DAPB1C *               LENGTH OF DAPB1C BLOCK
         EJECT
         IKJDAP30
DAPB30L  EQU   *-DAPB30 *               LENGTH OF DAPB30 BLOCK
.NODM    ANOP
&J       SETA  0
         AGO   .L32B
.L32L    ANOP
         MNOTE *,'GENERATED DSECT FOR &MAP(&J) '
.L32B    ANOP
&J       SETA  &J+1
         AIF   ('&MAP(&J)'  EQ  '').L32Z
         EJECT
         AIF   ('&MAP(&J)' EQ 'ECT').ECT
         AIF   ('&MAP(&J)' EQ 'PBE').PBE
         AIF   ('&MAP(&J)' EQ 'PSCB').PSCB
         AIF   ('&MAP(&J)' EQ 'UPT').UPT
         AIF   ('&MAP(&J)' EQ 'DSE').DSE
         AIF   ('&MAP(&J)' EQ 'JSCB').JSCB
         AIF   ('&MAP(&J)' EQ 'TSCVT').TSCVT
         AIF   ('&MAP(&J)' EQ 'TJB').TJB
         AIF   ('&MAP(&J)' EQ 'TJBX').TJBX
         AIF   ('&MAP(&J)' EQ 'TSB').TSB
         AIF   ('&MAP(&J)' EQ 'TCB').TCB
         AIF   ('&MAP(&J)' EQ 'CVT').CVT
         AIF   ('&MAP(&J)' EQ 'ECTX').ECTX
         AIF   ('&MAP(&J)' EQ 'TAT').TAT
         AIF   ('&MAP(&J)' EQ 'UVT').UVT
         AIF   ('&MAP(&J)' EQ 'DAPB00').DAPB00
         AIF   ('&MAP(&J)' EQ 'DAPB04').DAPB04
         AIF   ('&MAP(&J)' EQ 'DAPB10').DAPB10
         AIF   ('&MAP(&J)' EQ 'DAPB14').DAPB14
         AIF   ('&MAP(&J)' EQ 'DAPB2C').DAPB2C
         AIF   ('&MAP(&J)' EQ 'DAPB34').DAPB34
         AIF   ('&MAP(&J)' EQ 'PDEDSECT').PDEDS
         MNOTE 4,'UNSUPPORTED MAP PARAMETER &MAP(&J) '
         AGO   .L32L
.ECT     IKJECT
         AGO   .L32L
.ECTX    ECTX
         AGO   .L32L
.PBE     PBE
         AGO   .L32L
.PSCB    IKJPSCB
         AGO   .L32L
.UPT     IKJUPT
         AGO   .L32L
.DSE     IKJDSE
         AGO   .L32L
.TSB     IKJTSB
         AGO   .L32L
.UVT     ANOP
UVT      DSECT
         CCNUVT
         AGO   .L32L
.TCB     IKJTCB
         AGO   .L32L
.CVT     ANOP
CVT      DSECT
         CVT
         AGO   .L32L
.JSCB    IEZJSCB
         AGO   .L32L
.TSCVT   IKJTSCVT
         AGO   .L32L
.TJB     IKJTJB
         AGO   .L32L
.TJBX    IKJTJBX
         AGO   .L32L
.DAPB00  IKJDAP00
DAPB00L  EQU   *-DAPB00                 LENGTH OF DAPB00
         AGO   .L32L
.DAPB04  IKJDAP04
DAPB04L  EQU   *-DAPB04                 LENGTH OF DAPB04
         AGO   .L32L
.DAPB10  IKJDAP10
DAPB10L  EQU   *-DAPB10                 LENGTH OF DAPB10
         AGO   .L32L
.DAPB14  IKJDAP14
DAPB14L  EQU   *-DAPB14                 LENGTH OF DAPB14
         AGO   .L32L
.DAPB2C  IKJDAP2C
DAPB2CL  EQU   *-DAPB2C                 LENGTH OF DAPB10
         AGO   .L32L
.DAPB34  IKJDAP34
DAPB34L  EQU   *-DAPB34                 LENGTH OF DAPB34
         AGO   .L32L
.PDEDS   PDEDSECT
         AGO   .L32L
.TAT     CCNUID
         EJECT
TAT      DSECT
         CCNTAT
         AGO   .L32L
.L32Z    AIF   ('&SYMREG' NE 'YES').L13
         SPACE 2
***********************************************************************
*                                                                     *
*                   DEFINE SYMBOLIC REGISTERS                         *
*                                                                     *
***********************************************************************
         SPACE 2
R0       EQU   0                        THE SYMBOLIC REGISTERS
R1       EQU   1
R2       EQU   2
R3       EQU   3
R4       EQU   4
R5       EQU   5
R6       EQU   6
R7       EQU   7
R8       EQU   8
R9       EQU   9
R10      EQU   10
R11      EQU   11
R12      EQU   12
R13      EQU   13
R14      EQU   14
R15      EQU   15
.L13     AIF   ('&DSECT' NE 'NO').L19
         EJECT
&LBL     CSECT
         TSAVE (14,12),,*
         USNGX &LBL,&BASE(1)
         LR    &BASE(1),15              ESTABLISH ADDRESSABILITY
         AIF   ('&BASE(2)' EQ '').NOBASE2
         LA    &BASE(2),4095(&BASE(1))  EXTEND PROGRAM ADDRESSIBLITY
         LA    &BASE(2),1(&BASE(2))     WITH 2ND PROGRAM BASE REGISTER
         USNGX &LBL+4096,&BASE(2)
         AIF   ('&BASE(3)' EQ '').NOBASE2
         MNOTE 4,'BASE REGISTER &BASE(3) WAS NOT ESTABLISHED'
         MNOTE 4,'ONLY 2 BASE REGISTERS ARE SUPPORTED'
.NOBASE2 LR    5,1                      SAVE PTR TO CPPL
         GETMAIN R,LV=TSDSECTL-TSDSECT+&GETMAIN,SP=&SP
         ST    13,4(1)                  DO SAVE AREA CHAINING
         ST    1,8(13)
         LR    13,1                     ESTABLISH ADDRESSABILITY
         USNGX TSDSECT,13               FOR THE TSDSECT
         MVC   CPPL(CPPLL),0(5)         COPY CPPL TO TS AREA
         AIF   (NOT(&C OR &P OR &D OR &I OR &M)).L18A
         L     1,CPPLUPT                GET PTR TO UPT
         L     2,CPPLECT                GET PTR TO ECT
         LA    3,TSECB                  GET PTR TO ECB
         SR    0,0                      CLEAR ECB
         ST    0,TSECB
         AIF   (NOT &C).L14
         STM   1,3,CSPL                 INITIALIZE CSPL
         ST    0,CSFLG                  ZERO CSFLG
         LA    4,CSFLG
         ST    4,CSPLFLG
         LA    4,CSOA
         ST    4,CSPLOA
.L14     AIF   (NOT &P).L15
         STM   1,3,PPL                  INITIALIZE PPL. UPT,ECT,ECB
         LA    4,TSPARANS               ADRS OF PARSE ANSWER PLACE
         ST    4,PPLANS                 POINTER TO ADRS OF PARSE ANSWER
         ST    13,PPLUWA                PARSE USER WORK AREA POINTER
         XC    TSPARANS(4),TSPARANS     TO AVOID DUPLICATE IKJRLSA
.L15     AIF   (NOT &D).L16
         STM   1,3,DAPL                 INITIALIZE DAPL
         L     4,CPPLPSCB               GET PTR TO PSCB
         ST    4,DAPLPSCB               SET POINTER TO PSCB
.L16     AIF   (NOT &I).L17
         STM   1,3,IOPL                 INITIALIZE IOPL
.L17     AIF   (NOT &M).L18A
         ST    3,MPLECB                 INITIALIZE MPL, PTR TO ECB
         LA    4,CPPL                   ADDRESS OF CPPL
         ST    4,MPLCPPL                PTR TO CPPL
         LA    4,MPLCSECT               PTR TO MESSAGE CSECT
         ST    4,MPLCSECP               PTR TO MESSAGE CSECT ADDRESS
         XC    MPLSW(MPLZL),MPLSW       INITIALIZE REMAINING MPL TO 0
.L18A    ANOP
&J       SETA  0
.L72L    ANOP
&J       SETA  &J+1
         AIF   ('&LOAD(&J)'  EQ  '').L72Z
         SPACE 2
         LOAD  EP=&LOAD(&J)
         ST    0,&LOAD(&J)
         MNOTE *,'MODULE  &LOAD(&J) LOADED'
         AIF   ('&LOAD(&J)'  NE  'IKJDAIR').L72P
&GDAIR   SETB  1                        INDICATE DAIR LOADED
         AGO   .L72L
.L72P    AIF   ('&LOAD(&J)'  NE  'IKJPARS').L72L
&GPARSE  SETB  1                        PARSE WAS LOADED
&PARNAME SETC  'IKJPARS'
         AGO   .L72L
.L72Z    AIF   ('&PARSE(1)'   EQ '').L57K
         SPACE 2
***********************************************************************
*                                                                     *
*        PARSE THE COMMAND LINE                                       *
*                                                                     *
***********************************************************************
         SPACE 2
         TSPARSE CBUF=(CPPLCBUF,I),PCL=(=V(&PARSE(1)),I),              *
               SYNAD=&PARSE(2),ENTRY=&PARNAME
         MNOTE *,'COMMAND LINE WILL BE PARSED'
.L57K    AIF   ('&PARSE(2)' EQ '' AND '&EXIT' EQ '').L18
         B     TSE&SYSNDX
         AIF   ('&PARSE(2)'  EQ  '' OR &GPARSEM EQ 1).L57M
         SPACE 3
***********************************************************************
*                                                                     *
*        PARSE ERROR ANALYSIS SUBROUTINE                              *
*                                                                     *
***********************************************************************
         TSPARERR
         MNOTE  *,'PARSE ERROR ANALYSIS ROUTINE GENERATED'
&GPARSEM SETB  1                        PARSE ERROR ANALYSIS GENERATED
.L57M    AIF   ('&EXIT' EQ '').L58K
         SPACE 2
***********************************************************************
*                                                                     *
*        COMMAND PROCESSOR EXIT                                       *
*                                                                     *
***********************************************************************
         SPACE 2
&EXIT(1) EXIT  RC=(15),LV=TSDSECTL-TSDSECT,SP=&SP
         MNOTE *,'BRANCH TO &EXIT WITH RC IN R15 TO EXIT'
.L58K    SPACE 2
TSE&SYSNDX DS  0H
.L18     MNOTE *,'THE FOLLOWING BASES HAVE BEEN ESTABLISHED'
         MNOTE *,' '
         MNOTE *,'USING   TSDSECT,13'
         MNOTE *,'USING   &LBL,&BASE(1) '
         AIF   ('&BASE(2)' EQ '').L19
         MNOTE *,'USING   &LBL+4096,&BASE(2)'
         SPACE 5
.L19     MEND
         SPACE 3
         MACRO
         TSCPPL
.*** TSCPPL MACRO COPIED FROM UCLA MACRO LIBRARY
         SPACE 2
***********************************************************************
*    THE COMMAND PROCESSOR PARAMETER LIST (CPPL) IS A LIST OF         *
*    ADDRESSES PASSED FROM THE TMP TO THE CP VIA REGISTER 1           *
***********************************************************************
         SPACE 2
CPPL     DS    0A
CPPLCBUF DS    A        PTR TO COMMAND BUFFER
CPPLUPT  DS    A        PTR TO UPT
CPPLPSCB DS    A        PTR TO PSCB
CPPLECT  DS    A        PTR TO ECT
CPPLL    EQU   *-CPPL
         MEND
         SPACE 3
         MACRO
         TSCSPL
.*** TSCSPL MACRO COPIED FROM UCLA MACRO LIBRARY
         SPACE 2
***********************************************************************
*    THE COMMAND SCAN PARAMETER LIST (CSPL) IS A LIST OF ADDRESSES    *
*    PASSED FROM THE INVOKER TO COMMAND SCAN VIA REGISTER 1           *
***********************************************************************
         SPACE 2
CSPL     DS    0A
CSPLUPT  DS    A        PTR TO  UPT
CSPLECT  DS    A        PTR TO  ECT
CSPLECB  DS    A        PTR TO  CP'S ECB
CSPLFLG  DS    A        PTR TO  FLAG WORD CSFLG
*                       BIT 0 SET TO 0= SYNTAX CHECKING OF
*                       COMMAND NAME.
CSPLOA   DS    A        PTR TO OUTPUT AREA (CSOA DSECT)
CSPLCBUF DS    A        PTR TO COMMAND BUFFER
CSPLL    EQU   *-CSPL
CSFLG    DS    F
***********************************************************************
*    THE COMMAND SCAN OUTPUT AREA (CSOA) IS AN AREA POINTED TO        *
*    BY THE CSPL.  IT IS USED BY COMMAND SCAN TO INDICATE ITS         *
*    FINDINGS.  IT IS OBTAINED AND FREED BY THE INVOKER               *
***********************************************************************
CSOA     DS    0A
CSOACNM  DS    A        PTR TO COMMAND NAME-IF 0 INVALID CMD NAME
CSOALNM  DS    H        LENGTH OF CMD NAME
CSOAFLG  DS    X        FLAGS
CSOAVWP  EQU   X'80'    VALID WITH PARAMETERS
CSOAVNP  EQU   X'40'    VALID NO   PARAMS
CSOAQM   EQU   X'20'    QUESTION MARK
CSOANOC  EQU   X'10'    NO COMMAND
CSOABAD  EQU   X'08'    BAD CMD NAME
         DS    CL1      RESERVED
CSOAL    EQU   *-CSOA
         MEND
         SPACE 3
         MACRO
         TSPPL
.*** TSPPL MACRO COPIED FROM UCLA MACRO LIBRARY
         SPACE 2
***********************************************************************
*    THE PARSE PARAMETER LIST (PPL) IS A LIST OF ADDRESSES PASSED     *
*    FROM THE INVOKER TO PARSE VIA REGISTER 1                         *
***********************************************************************
         SPACE 2
PPL      DS    0A
PPLUPT   DS    A        PTR TO UPT
PPLECT   DS    A        PTR TO ECT
PPLECB   DS    A        PTR TO CP'S ECB
PPLPCL   DS    A        PTR TO PCL
PPLANS   DS    A        PTR TO ANS PLACE
PPLCBUF  DS    A        PTR TO CMD BUFFER
PPLUWA   DS    A        PTR TO USER WORK AREA (FOR VALIDITY CK RTNS)
PPLL     EQU   *-PPL
TSPARANS DS    F                        PARSE RETURNS PTR TO PDL HERE
         MEND
         SPACE 3
         MACRO
         TSDAPL
.*** TSDAPL MACRO COPIED FROM UCLA MACRO LIBRARY
         SPACE 2
***********************************************************************
*    THE DYNAMIC ALLOCATION INTERFACE ROUTINE (DAIR) PARAMETER LIST   *
*    (DAPL) IS A LIST OF ADDRESSES PASSED FROM THE INVOKER TO DAIR    *
*    VIA REGISTER 1
***********************************************************************
         SPACE 2
DAPL     DS    0F
DAPLUPT  DS    A        PTR TO UPT
DAPLECT  DS    A        PTR TO ECT
DAPLECB  DS    A        PTR TO CP'S ECB
DAPLPSCB DS    A        PTR TO PSCB
DAPLDAPB DS    A        PTR TO DAIR PARAMETER BLOCK
DAPLL    EQU   *-DAPL
         MEND
         SPACE 3
         MACRO
         TSDMPL
.*** TSDMPL MACRO COPIED FROM UCLA MACRO LIBRARY
         SPACE 2
***********************************************************************
*
* (DMPL)       DAIR MESSAGE PARAMETER LIST
*
* FUNCTION     THE ADDRESS OF THIS PARAMETER LIST IS PASSED IN
*              REGISTER 1 BY THE INVOKER OF IKJEFF18 TO DIAGNOSE DAIR
*              ERRORS AND PRINT APPROPRIATE MESSAGES.
*
***********************************************************************
         SPACE 2
DMPL     DS    0F *                     DAIR MESSAGE PARAMETER LIST
DMPLDAPL DS    A *                      PTR TO THE DAPL ADDRESS
DMPLRC   DS    A *                      PTR TO THE DAIR RETURN CODE
DMPLMSG  DS    A *                      PTR TO A(IKJEFT02) IF LOADED
DMPLCALL DS    A *                      PTR TO THE CALLER NUMBER
DMPLCODE DS    0F *                     R15 SAVE IS DAIR RETURN CODE
DMPLSAVE DS    3F *                     REGISTER SAVEAREA FOR 15-1
DMPLL    EQU   *-DMPL *                 LENGTH OF THE DMPL
         SPACE 2
         MEND
         SPACE 3
         MACRO
&NAME    TSAVE &REG,&CODE,&ID
.*** TSAVE MACRO COPIED FROM UCLA MACRO LIBRARY
.*  --CCN VERSION OF SAVE--
.*  SAVE (14,12),,* ADDS 8-BYTE DATE FIELD AFTER CSECT NAME, OF THE
.*  FORM '74MAR28'.
         LCLA  &A,&B,&C
         LCLC  &E,&F,&G,&H
         AIF   ('&REG' EQ '').E1
         AIF   ('&ID' EQ '').NULLID
         AIF   ('&ID' EQ '*').SPECID
&A       SETA  ((K'&ID+2)/2)*2+4
&NAME    B     &A.(0,15)                         BRANCH AROUND ID
&A       SETA  K'&ID
         DC    AL1(&A)                           LENGTH OF IDENTIFIER
.CONTB   AIF   (&A GT 32).SPLITUP
.CONTAA  AIF   (&A GT 8).BRAKDWN
&E       SETC  '&ID'(&B+1,&A)
         DC    CL&A'&E'                          IDENTIFIER
         AGO   .CONTA
.BRAKDWN ANOP
&E       SETC  '&ID'(&B+1,8)
         DC    CL8'&E'                           IDENTIFIER
&B       SETA  &B+8
&A       SETA  &A-8
         AGO   .CONTAA
.SPLITUP ANOP
&E       SETC  '&ID'(&B+1,8)
&F       SETC  '&ID'(&B+9,8)
&G       SETC  '&ID'(&B+17,8)
&H       SETC  '&ID'(&B+25,8)
         DC    CL32'&E.&F.&G.&H'                      IDENTIFIER
&B       SETA  &B+32
&A       SETA  &A-32
         AGO   .CONTB
.NULLID  ANOP
&NAME    DS    0H
         AGO   .CONTA
.SPECID  AIF   ('&NAME' EQ '').CSECTN
&E       SETC  '&NAME'
&A       SETA  1
.CONTQ   AIF   ('&E'(1,&A) EQ '&E').LEAVE
&A       SETA  &A+1
         AGO   .CONTQ
.LEAVE   ANOP
&B       SETA  ((&A+2)/2)*2+4+8
&NAME    B     &B.(0,15)                         BRANCH AROUND ID
         DC    AL1(&A+8)
         DC    CL&A'&E'                          IDENTIFIER
         DC    C' ',CL7'&SYSDATE'                DATE OF ASMBLY
         AGO   .CONTA
.CSECTN  AIF   ('&SYSECT' EQ '').E4
&E       SETC  '&SYSECT'
&A       SETA  1
         AGO   .CONTQ
.E4      IHBERMAC 78,360                    CSECT NAME NULL
.CONTA   AIF   (T'&REG(1) NE 'N').E3
         AIF   ('&CODE' EQ 'T').CONTC
         AIF   ('&CODE' NE '').E2
&A       SETA  &REG(1)*4+20
         AIF   (&A LE 75).CONTD
&A       SETA  &A-64
.CONTD   AIF   (N'&REG NE 2).CONTE
         STM   &REG(1),&REG(2),&A.(13)           SAVE REGISTERS
         MEXIT
.CONTE   AIF   (N'&REG NE 1).E3
         ST    &REG(1),&A.(13,0)                 SAVE REGISTER
         MEXIT
.CONTC   AIF   (&REG(1) GE 14 OR &REG(1) LE 2).CONTF
         STM   14,15,12(13)                      SAVE REGISTERS
&A       SETA  &REG(1)*4+20
         AIF   (N'&REG NE 2).CONTG
         STM   &REG(1),&REG(2),&A.(13)           SAVE REGISTERS
         MEXIT
.CONTG   AIF   (N'&REG NE 1).E3
         ST    &REG(1),&A.(13,0)                 SAVE REGISTER
         MEXIT
.CONTF   AIF   (N'&REG NE 2).CONTH
         STM   14,&REG(2),12(13)                 SAVE REGISTERS
         MEXIT
.CONTH   AIF   (N'&REG NE 1).E3
         STM   14,&REG(1),12(13)                 SAVE REGISTERS
         MEXIT
.E1      IHBERMAC 18,360                    REG PARAM MISSING
         MEXIT
.E2      IHBERMAC 37,360,&CODE              INVALID CODE SPECIFIED
         MEXIT
.E3      IHBERMAC 36,360,&REG               INVALID REGS. SPECIFIED
         MEND
         SPACE 3
         MACRO
         USNGX  &ADDR,&REG
.*** USNGX MACRO COPIED FROM UCLA MACRO LIBRARY
         GBLC  &REGADDR(16),&REGREG(16)
         LCLA  &LOOP
&LOOP    SETA  1
         USING &ADDR,&REG
.FIND    AIF   ('&REGADDR(&LOOP)' EQ '').GOT
&LOOP    SETA  &LOOP+1
         AIF   (&LOOP LE 16).FIND
         MNOTE *,'REGISTER TABLE OVERFLOW'
         MEXIT
.GOT     ANOP
&REGADDR(&LOOP) SETC '&ADDR'
&REGREG(&LOOP) SETC '&REG'
         MEND
         SPACE 3
         MACRO
         DEBDS
.*** DEBDS MACRO COPIED FROM UCLA MACRO LIBRARY
*
* DATA EXTENT BLOCK DEFINITION
*
DEBDS    DSECT ,
DEBNMSUB DS    0C .
DEBTCBAD DS    F .                TASK CONTROL BLOCK POINTER
DEBAMLNG DS    0C .
DEBDEBAD DS    F .                DEB CHAIN
DEBOFLGS DS    0C .               OPEN FLAGS
DEBIRBAD DS    F .                ASI IRB POINTER
DEBOPATB DS    0C .
DEBSYSPG DS    F .
DEBNMEXT DS    0C .               NUMBER OF EXTENTS
DEBUSRPG DS    F .
DEBPRIOR DS    0C .
DEBECBAD DS    F .
DEBPROTG DS    0C .
DEBDEBID DS    0C .
DEBDCBAD DS    F .                DCB POINTER
DEBEXSCL DS    0C .
DEBAPPAD DS    F .                APPENDAGE VECTOR TABLE POINTER
DEBDVMOD DS    0C .               FILE MASK
DEBUCBAD DS    F .                USB POINTER
         DS    H .
DEBSTRCC DS    H .                STARTING CYLINDER
DEBSTRHH DS    H .                STARTING HEAD
DEBENDCC DS    H .                LAST CYLINDER
DEBENDHH DS    H .                LAST HEAD NUMBER
DEBNMTRK DS    H .                NUMBER OF TRACKS IN THIS EXTENT
*
         MEND
         PRINT ON                ***** START USING PAPER AGAIN
 TITLE 'ZAP  ---  DISPLAY AND MODIFY DATA SETS  ---  DOC'
**********************************************************************
*                                                                    *
*  PROGRAM:  ZAP                                                     *
*                                                                    *
*  THIS PROCESSOR IS RE-ENTRANT AND SERIALLY REUSABLE                *
*                                                                    *
*  FOR FULL DOCUMENTATION OF COMMANDS AND SO ON, SEE THE LISTING     *
*  OF THE URSA VERSION IN BINDER 'URSA MISCELLANEOUS VOLUME 3'       *
*                                                                    *
*  PROGRAMMER:   VIC TOLOMEI                                         *
*                                                                    *
*                                                                    *
*  WRITTEN FOR URSA:           5/22/73                               *
*  CHANGE TO TSO VERSION:      1/22/75                               *
*  MODIFIED FOR MVT AND MVS:  11/22/79     (A. BRUCE LELAND)         *
*                                                                    *
**********************************************************************
         SPACE 3
* * * * * * *  * * * * * * * * * * * * * *  * * * * * * * * * * * * * *
*                                                                     *
*  ZAP  --  GENERAL ZAP OUTLINE:                                      *
*                                                                     *
*  THIS SERVICE WILL DISPLAY ANY TYPE OF DATA SET (EXCLUDING VSAM)    *
*  IN DUMP FORMAT, ACCEPT VARIOUS DISPLAY FORMATTING AND MODIFYING    *
*  COMMANDS, AND APPLY CHANGES AS DOES IBM'S SERVICE AID, AMASPZAP    *
*  (SUPERZAP) EXCEPT THAT ZAP IS INTERACTIVE.  IDR'S ARE UPDATED IN   *
*  LOAD PDS'S IN THE FORMAT SUPERZAP USES (WITH "TSO USERID" AS THE   *
*  ID DATA FIELD).  END-OF-FILES MAY BE JUMPED TO VIEW DATA BEYOND    *
*  (UP TO THE EXTENT OF THE DATA SET) ANY INADVERTENT EOF IN THE      *
*  DATA SET.  CHANGES ARE APPLIED ON A PHYSICAL BLOCK BASIS AND THE   *
*  BLOCK IS ONLY UPDATED (INPLACE) WHEN A ZAP SUBCOMMAND IS ISSUED.   *
*                                                                     *
*                                                                     *
*                                                                     *
*  PLEASE SEND ANY CHANGES, CORRECTIONS OR ADDITIONS TO:              *
*           BRUCE LELAND                                              *
*           P.O. BOX 235                                              *
*           PORT HUENEME, CALIF.  93041                               *
*                                                                     *
*                                                                     *
* PROGRAM CHANGES BY BRUCE LELAND:                                    *
*                                                                     *
*   1.  ADDED SEVERAL NEW COMMANDS:                                   *
*        EXTENTS, CHANGE (OR C), WHALF, DCB, CC AND X                 *
*                                                                     *
*   2.  MODIFIED SEVERAL OF THE EXISTING COMMANDS:                    *
*        ? - WAS ?1, ?2, ... ?6; NOW A LIST OF SUBCOMMAND NAMES       *
*        = - USED TO ALLOW ANYTHING AS AN EQUATED NAME                *
*        H - USED TO BE AN ALIAS FOR ? (AS WAS HELP)                  *
*        F - ADDED AS AN ALIAS FOR L                                  *
*        D - WITH NO OPERAND NOW ADJUSTS CORRECTLY TO NEXT SCREEN     *
*        M - WITH NO OPERAND USED TO POINT TO FIRST OF DATA SET       *
*        W - MAXIMUM SIZE SCREEN EXPANDED FROM  W 6,6  TO  W 10,10    *
*        EX - USED TO BE CALLED X                                     *
*        ASM - ADDED SUPPORT FOR ALL IBM/370 ASSEMBLY INSTRUCTIONS    *
*        SET - USED TO ALWAYS CHANGE AN ENTIRE PHYSICAL RECORD        *
*        LAST - ADDED SUPPORT FOR VTOC'S                              *
*        IDEF - ADDED PREDEFINED SYMBOLS FOR VTOC PROCESSING          *
*        WFULL - CHANGED FROM A SLIDING WINDOW  W 0,12  THRU  W 12,0  *
*        DISASM - USED TO DISASSEMBLE THE INSTRUCTION AT <EXP>        *
*                 NOW IT DISASSEMBLES <EXP> INSTRUCTIONS              *
*                                                                     *
*   3.  DELETED THE FOLLOWING COMMANDS:                               *
*        NN - A JOBQUEUE SCAN FACILITY                                *
*        ZCODE - ANOTHER TRANSLATION TYPE LIKE EBCDIC OR ASCII        *
*        DUMP - CREATES HARD-COPY, DUMPS ALL RECORDS FROM FILE        *
*        DUMPT - CREATES HARD-COPY, DUMPS TO TTR <EXP>                *
*        DUMPF - CREATES HARD-COPY, DUMPS <EXP> RECORDS               *
*        NOTE: THE ABOVE HARD-COPY COMMANDS WERE DEPENDENT ON         *
*              UCLA'S OPERATING ENVIRONMENT AND TSO MODIFICATIONS.    *
*                                                                     *
*   4.  THE PROGRAM'S METHOD OF OPERATION WAS CHANGED AS FOLLOWS:     *
*    * * I/O FORMERLY WAS PERFORMED VIA BDAM READS AND WRITES.        *
*          THIS DID NOT WORK UNDER MVS AT ALL; AND UNDER MVT IT       *
*          CAUSED "COMMAND REJECT" CONDITIONS ON DISK.                *
*    * * USERS WITHOUT "OPER" CAPABILITY CAN NOT MAKE DATA SET        *
*          CHANGES (THEY ARE ALLOWED READ-ONLY ACCESS ONLY).          *
*    * * FORMAT4.DSCB ALLOCATION EVIDENTLY WORKS DIRECTLY AT UCLA     *
*          DUE TO CHANGES IN DATA SET ALLOCATION; SEVERAL CHANGES     *
*          WERE NECESSARY TO CIRCUMVENT THE ALLOCATION PROBLEM FOR    *
*          AN UNMODIFIED TSO INSTALLATION.                            *
*    * * ALL DATA SET NAMES WERE FORMERLY CONSIDERED 'QUOTED';        *
*          NORMAL TSO CONVENTIONS ARE NOW OBSERVED (EXCEPT IF THE     *
*          DATA SET NAME IS SYSCTLG).                                 *
*    * * THIS PROGRAM MUST BE AUTHORIZED TO ZAP VTOC'S UNDER MVS.     *
*          NOTE THAT THE OPEN IS MADE WITH THE UPDATE BIT ON FOR      *
*          ALL USERS WITH "OPER" CAPABILITY.                          *
*    * * THE PROGRAM NOW RE-INITIALIZES ITSELF WITH EACH NEW DATA SET *
*          PROCESSED AND EACH DATA SET IS FREED AFTER PROCESSING.     *
*    * * FORMERLY NO BLANK WAS REQUIRED BETWEEN A SUBCOMMAND AND ITS  *
*          OPERAND CAUSING SOME AMBIGUITY AND SUBSTRINGING PROBLEMS.  *
*                                                                     *
*   5.  RESTRICTIONS AND AREAS FOR FUTURE WORK:                       *
*    * * EXPRESSION PARSE AND EXPRESSION PROCESSING NEED IMPROVEMENT  *
*    * * IDRDATA IS ADDED CORRESPONDING TO THE LAST PREVIOUS M SUB-   *
*          COMMAND REGARDLESS OF THE ACTUAL LOCATION OF THE CHANGE    *
*    * * ANY CHANGE TO A LOAD MODULE IS IDENTIFIED AS THE FIRST CSECT *
*    * * NEED CONTROLS TO POSITION TO A CSECT WITHIN A MEMBER         *
*    * * NEED A DIRECTORY DISPLAY FOR MEMBER NAMES IN A PDS           *
*    * * NEED A WAY TO INTERRUPT L WITHOUT ENDING ZAP (ATTENTION?)    *
*    * * NEED FACILITY TO FIND OUT WHICH MEMBER'S DATA IS POINTED AT  *
*    * * FULL SCREEN MODE IS CURRENTLY BEING WORKED ON FOR 3270'S     *
*                                                                     *
* * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *
 TITLE 'ZAP  --- DISPLAY AND MODIFY DATA SETS  --  CSECT'
ZAP      CSECT ,
         SPACE 2
F0       EQU   0
F2       EQU   2
F4       EQU   4
F6       EQU   6
         SPACE 5
**********************************************************************
*                                                                    *
*    REGISTER USAGE:                                                 *
R0     EQU   0   . . . WORK REGISTER                                 *
R1     EQU   1   . . . WORK REGISTER                                 *
R2     EQU   2   . . . WORK REGISTER                                 *
R3     EQU   3   . . . WORK REGISTER                                 *
R4     EQU   4   . . . WORK REGISTER                                 *
R5     EQU   5   . . . WORK REGISTER                                 *
R6     EQU   6   . . . WORK REGISTER                                 *
R7     EQU   7   . . . THIRD BASE REGISTER                           *
R8     EQU   8   . . . PRIMARY BAL REG                               *
R9     EQU   9   . . . WORK                                          *
R10    EQU   10  . . . SECOND BASE (ZAP)                             *
R11    EQU   11  . . . FOURTH BASE REGISTER                          *
R12    EQU   12  . . . PRIMARY BASE FOR ZAP AND FOR EXP              *
R13    EQU   13  . . . TS WORKAREA (SAVEAREA, 'CSAREA', ETC)         *
R14    EQU   14  . . . WORK AND RET ADDR                             *
R15    EQU   15  . . . WORK AND ENRTY POINT ADDR                     *
*                                                                    *
**********************************************************************
         TITLE 'ZAP --- INITIALIZATION'
ZAP      TSENTRY BASE=R12,SYMREG=NO,PL=(CSCAN,PARSE,DAIR),MACRO=YES
         LA    R10,4095(R12)            BASE #2
         LA    R10,1(R10)
         LA    R7,4095(R10)             BASE #3
         LA    R7,1(R7)
         LA    R11,4095(,R7)            BASE #4
         LA    R11,1(,R11)
         USING ZAP+4096,R10,R7,R11
         EJECT
         MVI   IKJSCAN,X'FF'            IKJSCAN NOT YET LOADED
         MVI   IKJHELP,X'FF'            HELP NOT YET LOADED
         LOAD  EP=IKJPARS
         ST    R0,IKJPARS               WILL NEED PARSE LATER
         LOAD  EP=IKJDAIR
         ST    R0,IKJDAIR               WILL NEED DAIR LATER
         L     R0,=V(PCL)               PARSE PCL
         ST    R0,PPLPCL                SAVE PCL ADDRESS FOR PARSE
         L     R0,CPPLCBUF              COMMAND BUFFER ADDRESS
         ST    R0,PPLCBUF               SAVE CBUF FOR FIRST PARSE
*
         L     R15,16                   CVT
         L     R15,0(,R15)              TCB WORDS
         L     R15,4(,R15)              CURRENT TCB
         L     R15,12(,R15)             TIOT
         MVC   CSINIT(8),0(R15)         SAVE ACTUAL USERID IN USE
*
         MVI   GODFLAG,NOGOD            ASSUME READ CAPABILITY ONLY
         L     R1,CPPLPSCB              PSCB POINTER
         TM    16(R1),X'80'             PSCBATR1 WITH PSCBCTRL ON?
         BNO   *+8                      NO, BRANCH (NO "OPER")
         OI    GODFLAG,GOD              PROVIDE READ/WRITE CAPABILITY
         EJECT
*
*     SET UP PROGRAM DEFAULTS AND INITIAL CONDITIONS
*
         XC    WIDTHS(4+4),WIDTHS       WINDOW = CARET LINE ONLY
         LA    R1,TRCHARE               INITIALIZE PTR TO...
         ST    R1,TRTABADD              TR TABLE (THE EBCDIC ONE)
         LA    R1,SCREEN+0              PT TO FIRST AVAIL SCREEN LOC
         ST    R1,FIRSTSCR              SAVE IT
         LA    R1,SCREEN+800+40         PT TO LAST AVAIL SCREEN LOC+1
         ST    R1,MAXSCR                SAVE IT
         LA    R1,IDEFTAB               PT TO DEFINE TABLE
         ST    R1,AIDEFTAB              SAVE IT
         LA    R1,INVEXP                PT TO INVALID SYNTAX MSG
         ST    R1,AINVEXP               SAVE IT FOR LATER
         XC    LOOKFOR(40),LOOKFOR      CLEAR SCAN STRING SAVE AREA
         XC    ZAPSTRNG(40),ZAPSTRNG    CLEAR ZAP STRING SAVE AREA
         XC    SETSTR(40),SETSTR        NO SET STRING YET
         XC    MEMBER(8),MEMBER         NO MEMBER NAME YET
         MVC   ESDID(2),=H'1'           ESDID DEFAULTS TO 1 FOR IBM
         MVI   CONTINUE,0               NO SCAN, STORES OR SETS YET
         XC    GETLIST(GETLISTL),GETLIST FIX IT
         XC    EXCPBUF(2),EXCPBUF        SIZE OF EXCP I/O BUFFER
 TITLE 'ZAP -- NEW DATA SET (GET PARSE RESULTS)'
PARSEDSN MVI   FLAGS2,0                 INITIALIZE GENERAL FLAGS
         MVC   DCBU(DCBUL),DCBMSK       INITIALIZE THE DCB
         LA    R1,PPL                   POINT TO THE PPL
         L     R15,IKJPARS              POINT TO PARSE
         BALR  R14,R15                  CALL IT
         LA    R1,BADPARSE              ASSUME IT DID NOT WORK
         LTR   R15,R15                  CORRECT?
         BNZ   CSIO#                    YES, ERROR MESSAGE AND RETRY
         SPACE 2
         L     R9,TSPARANS              POINT TO PARSE BLOCK
         USING IKJPARMD,R9              TEMP TO GET DSN AND VOL
         SPACE 1
         L     R1,PDEPTR-PDE+PDLDSN     POINT TO DSN SUPPLIED
         LH    R15,PDELEN-PDE+PDLDSN    POINT TO ITS LEN (<= 45)
         STH   R15,DSNAMEL              SAVE THE DSNAME LENGTH
         BCTR  R15,0                    EX LEN
         MVC   DSNAME(44),=CL44' '      BLANK DSNAME
         MVC   VOLSER(8),=CL44' '         AND VOL TOO
         MVC   DDNAME(8),=CL44' '         AND DDNAME TOO
         MVC   DSNAME(0),0(R1)          <<< EXECUTED >>>
         EX    R15,*-6                  MOVE PARSE DSN TO TARGET
         TM    PDEFLAG-PDE+PDLDSN,PDEQUOTE  QUOTED DATA SET NAME?
         BNO   *+8                          NO, BRANCH
         OI    FLAGS2,QUOTED                YES, ADD A FLAG
         CLC   =C'FORMAT4.DSCB ',DSNAME     VTOC ZAP DESIRED?
         BNE   *+8                          NO, BRANCH
         OI    FLAGS2,VTOC+QUOTED           YES, ALSO ASSUME QUOTED
         CLC   =C'SYSCTLG ',DSNAME          CATALOG ZAP DESIRED?
         BNE   *+8                          NO, BRANCH
         OI    FLAGS2,QUOTED                YES, ASSUME QUOTED NAME
         LA    R1,=C'FILE'                  POSSIBLE "FILE(DDNAME)"
         LA    R15,DSNAME                   FIRST CHECK CHARACTER
         LA    R0,4                         MAXIMUM LOOP COUNT
CHKFILE  CLC   0(1,R15),0(R1)               EQUAL?
         BNE   TRYBLK                       NO, TRY FOR A BLANK
         LA    R1,1(,R1)                    NEXT FILE CHARACTER
         LA    R15,1(,R15)                  NEXT DSNAME CHARACTER
         BCT   R0,CHKFILE                   DO 3 ALLOWED BYTES
TRYBLK   CLI   0(R15),X'40'                 FOLLOWED BY A BLANK?
         BNE   CHKVOL                       NO CANNOT BE "FILE "
         L     R1,PDEPTR-PDE+PDLDSN+8       "MEMBER" NAME (OR FILENAME)
         LH    R15,PDELEN-PDE+PDLDSN+8      FILENAME NAME LENGTH
         TM    PDEFLAG-PDE+PDLDSN+8,PDEFPRES  ANY MEMBER NAME?
         BNO   CHKVOL                       NO, BRANCH
         OI    FLAGS2,FILENAME+QUOTED       ALSO ASSUME FULL DSNAME
         BCTR  R15,0                        MOVE LENGTH
         MVC   DDNAME(0),0(R1)              <<EXECUTED>>
         EX    R15,*-6                      GET THE DESIRED DDNAME
         B     NOVOL                        IGNORE ANY VOLUME SERIAL
         SPACE 4
CHKVOL   TM    PDEFLAG+4-PDE+PDLVOL,PDEFPRES  ANY VOL SPEC?
         BNO   NOVOL                          NO, BLANK
         L     R1,PDEPTR+4-PDE+PDLVOL   GET PTR TO VOL SER
         LH    R15,PDELEN+4-PDE+PDLVOL  AND GET ITS LEN
         BCTR  R15,0                    EXECUTE LEN
         MVC   VOLSER(0),0(R1)          <<< EXECUTED >>>
         EX    R15,*-6                  MOVE VOL SPEC TO VOLSER
         DROP  R9                       NO NEED FOR IKJPARMD NOW
         SPACE 3
NOVOL    IKJRLSA TSPARANS               RELEASE THE PARSE STORAGE
         SPACE 3
         XC      TSPARANS(4),TSPARANS   NO PARSE BLOCK LEFT NOW
         CLC     DSNAME(4),=C'END '     END INSTEAD OF A DSNAME
         BE      END                    YES, QUIT THIS CP
         TITLE 'ZAP -- SET UP INITIAL DATA SET DEFAULTS'
         XC    MIDLINE(4),MIDLINE       ZERO CARET POINTER
         XC    MEMTTR(3),MEMTTR         NO MEMBER YET
         BAL   R8,CLEARDEF              INITIALIZE IDEF TABLE AND PTRS
         MVI   WHERELIN,C' '            CLEAR LINE FOR 'WHERE'
         MVC   WHERELIN+1(WHEREL-1),WHERELIN
         MVC   WHERELIN(4),=C'DSN:'     DSN:
         MVC   WHERELIN+30(4),=C'OFF:'  OFF:
         MVC   WHERELIN+40(40),TTRCCHHR TTR: ETC
         MVC   WHERELIN+80(40),ENTERCMD ENTER COMMAND ETC
         XC    ITRTAB(120),ITRTAB       INIT THE TRACE TABLE
         LA    R1,ITRTAB                PT TO IT
         ST    R1,ITRAVAL               SAVE AS PTR TO 1ST AVAIL POS
         ST    R1,CURRITR               SAVE PTR TO CURR TRACE TAB PTR
         MVI   ITREND,X'FF'             SET THE END OF THE TABLE
         LA    R0,DCBU                  POINT TO DCB
         ST    R0,DCBLIST               PUT IN OPEN/CLOSE LIST
         MVI   DCBLIST,X'80'            END OF DCB LIST MARKER
         CLI   GODFLAG,GOD              UPDATE ALLOWED?
         BNE   *+8                      NO, BRANCH
         OI    DCBLIST,X'04'            YES, ADD THE UPDATE BIT
         MVC   TTR(3),=X'000001'        INITIALIZE TTR = 000001
         LA    R1,EXLST                 EXIT LIST
         ST    R1,EXLST                          ADDRESS
         MVC   DCBEXLST-IHADCB+DCBU+1(3),EXLST+1        FOR RDJFCB
         LA    R1,SCREEN                JFCB AREA ADDRESS
         ST    R1,EXLST
         MVI   EXLST,X'80'+X'07'        END OF EXIT LIST + JFCB EXIT
         TM    FLAGS2,VTOC              VTOC PROCESSING?
         BZ    NOTVTOC                  NO, BRANCH
 TITLE 'ZAP  --- FORMAT4.DSCB PROCESSING'
*  SINCE DYNAMIC ALLOCATION DOES NOT ALLOW DIRECT ALLOCATION OF A VTOC,
*  THE FOLLOWING SEQUENCE WAS CODED TO CIRCUMVENT THE RESTRICTION:
*    A.  FIND THE FORMAT 4 DSCB ON THE NAMED VOLUME (SEARCH CAMLST)
*    B.  READ DSCB'S UNTIL THE FIRST FORMAT ONE DSCB (SEEK CAMLST)
*    C.  ALLOCATE USING THE DSNAME FOUND IN B.
*    D.  READ JFCB, REPLACE THE DSNAME WITH 44X'04'
*    E.  OPEN TYPE=J
*
         MVI   DSNAMEL+1,44             FULL LENGTH DDNAME ALLOWED
         MVI   DSNAME,X'04'             SET DSNAME
         MVC   DSNAME+1(43),DSNAME                TO 44X'04'
         LA    R1,BADDSN                INVALID DSNAME (NO VOL=SER)
         CLI   VOLSER,X'40'             ANY VOLUME CODED?
         BE    CSIO#                    NO, ERROR MESSAGE AND RETRY
*
*DSCBLIST CAMLST SEARCH,DSNAME,VOLSER,SCREEN
         L     R14,=AL1(193,0,0,0)     +CAMLST OPTIONS FOR SEARCH
         LA    R15,DSNAME              +
         LA    R0,VOLSER               +
         LA    R1,SCREEN               +
         STM   R14,R1,DSCBLIST         +
         OBTAIN DSCBLIST
         LA    R1,NOTMOUNT              VOLUME NOT ON-LINE
         CH    R15,=H'4'                MOUNTED?
         BE    CSIO#                    NO, ERROR AND RETRY
         LA    R1,IOERRORM              I/O ERROR IN THE VTOC
         CH    R15,=H'12'               CORRECT?
         BE    CSIO#                    YES, ERROR AND RETRY
*
         LA    R9,SCREEN                ESTABLISH
         USING DSCB4,R9                          ADDRESSABILITY
         LA    R1,F4NOTFND              FORMAT 4 DSCB NOT FOUND
         CLI   DS4IDFMT,X'F4'           FORMAT 4?
         BNE   CSIO#                    NO, ERROR AND RETRY
         MVC   SAVEHI(5),DS4HPCHR       HIGH FORMAT 1 DISK ADDRESS
         MVC   DEVDT(1),DS4DEVDT        TRACK CAPACITY (FOR DSCB'S)
         MVC   DEVSZ(2),DS4DEVSZ+2      CYLINDER CAPACITY (FOR DSCB'S)
         MVC   DSCBCC(4),DS4VTOCE+2     VTOC EXTENT LOWER LIMIT
         MVI   DSCBCC+4,X'01'           INITIAL RECORD (SKIP FORMAT 4)
*
NEXTDSCB SR    R1,R1
         IC    R1,DSCBCC+4              INCREMENT
         LA    R1,1(,R1)                         RECORD
         STC   R1,DSCBCC+4                             NUMBER
         CLC   DSCBCC+4(1),DEVDT        EXCEED TRACK CAPACITY?
         BNH   GETNEXT                  NO, BRANCH
         MVI   DSCBCC+4,X'01'           RESET RECORD NUMBER
         LH    R1,DSCBCC+2              INCREMENT
         LA    R1,1(,R1)                         HEAD
         STH   R1,DSCBCC+2                           NUMBER
         CH    R1,DEVSZ                 EXCEED CYLINDER CAPACITY?
         BNH   GETNEXT                  NO, BRANCH
         MVC   DSCBCC+2(3),=X'000001'   RESET HEAD AND TRACK NUMBERS
         LH    R1,DSCBCC                INCREMENT
         LA    R1,1(,R1)                         CYLINDER
         STH   R1,DSCBCC                                 NUMBER
         SPACE 2
GETNEXT  LA    R1,NOFMT1                NO FORMAT 1 DSCB'S
         CLC   SAVEHI(5),DSCBCC         BEYOND HIGH FORMAT 1 ADDRESS?
         BL    CSIO#                    YES, ERROR AND RETRY
*TEMP    CAMLST SEEK,DSCBCC,VOLSER,SCREEN
         L     R14,=AL1(192,128,0,0)   +CAMLST OPTIONS FOR SEEK
         LA    R15,DSCBCC              +
         LA    R0,VOLSER               +
         LA    R1,SCREEN               +
         STM   R14,R1,TEMP             +
         OBTAIN TEMP                    READ THIS DSCB
         LA    R1,IOERRORM
         CH    R15,=H'12'               I/O ERROR IN VTOC?
         BE    CSIO#                    YES, ERROR AND RETRY
         CLI   DSCBLIST+44,X'F1'        FORMAT 1 DSCB?
         BNE   NEXTDSCB                 NO, CONTINUE LOOKING
*
         MVC   DSNAME(44),DSCBLIST      ALLOCATE THIS DATA SET NAME
         BAL   R8,ALLOC
         MVC   DCBDDNAM-IHADCB+DCBU(8),DDNAME  UPDATE DDNAME
         RDJFCB MF=(E,DCBLIST)          GET THE JFCB
         LA    R9,SCREEN                ADDRESSABILITY
         USING JFCB,R9                                TO JFCB
         MVI   JFCRECFM,DCBRECU         RECFM=U
         MVI   JFCDSORG,DCBDSGPS        DSORG=PS
         MVI   JFCOPTCD,0               NO OPTCD OPTIONS
         MVI   JFCBDSNM,X'04'           CHANGE DSNAME
         MVC   JFCBDSNM+1(43),JFCBDSNM               TO 44X'04'
         MVC   DSNAME(44),JFCBDSNM      SAVE IN DSNAME AREA
         MVI   JFCKEYLE,44              KEYLENGTH=44
         MVC   JFCBLKSI,=H'96'          BLKSIZE=96
         B     GOOPEN
 TITLE 'ZAP  ---  OPEN AND INITIALIZE FOR PROCESSING'
NOTVTOC  LA    R9,SCREEN                POINT TO JFCB INPUT AREA
         TM    FLAGS2,FILENAME          FILENAME ALREADY ALLOCATED?
         BNO   NOTFILE                  NO, BRANCH
         MVC   DCBDDNAM-IHADCB+DCBU(8),DDNAME
         RDJFCB MF=(E,DCBLIST)          READ JFCB
         MVC   DSNAME(44),JFCBDSNM      GET THE DATA SET NAME
         MVI   DSNAMEL+1,44             ALLOW FULL LENGTH NAME
         B     GOOPEN                   OPEN
         SPACE 2
NOTFILE  BAL   R8,ALLOC                 ALLOCATE THE FILE
         MVC   DCBDDNAM-IHADCB+DCBU(8),DDNAME
         RDJFCB MF=(E,DCBLIST)          READ JFCB
GOOPEN   OI    JFCBTSDM,X'08'           ALLOW NO REVERSE MERGE TO JFCB
         MVC   DSORG(1),JFCDSORG        SAVE THE DSORG
         MVC   OPTCD(1),JFCOPTCD        SAVE THE OPTCD CODE
         MVC   BLKSIZE(2),JFCBLKSI      SAVE THE BLOCKSIZE
         MVC   LRECL(2),JFCLRECL        SAVE THE LRECL
         MVI   KEYLEN,0                 ZERO FIRST KEY LENGTH BYTE
         MVC   KEYLEN+1(1),JFCKEYLE     SAVE THE KEY LENGTH
         MVC   RECFM(1),JFCRECFM        SAVE THE RECORD FORMAT
         OPEN  MF=(E,DCBLIST),TYPE=J    OPEN THE DATASET
         DROP  R9                       NO NEED FOR JFCB ANY MORE
         SPACE 1
         LA    R1,BADDSN                OPEN FAILED
         TM    DCBU+48,X'10'            DID IT OPEN?
         BNO   CSIO#                    NO, DARN (ERROR MSG. AND RETRY)
         SPACE 2
         XC    DCBEXLST-IHADCB+DCBU+1(3),DCBEXLST-IHADCB+DCBU+1
*                                       CLEAR THE DCB EXIT ADDRESS
         EJECT
*  GET LAST TTR OF DATASET FOR LATER
*
         L     R1,DCBDEBAD-IHADCB+DCBU  GET THE DEB PTR
         L     R3,DEBUCBAD-DEBDS(,R1)   GET THE UCB PTR
         MVC   VOLSER(6),28(R3)         SAVE VOL=SER OF DATASET
         SPACE 1
         SR    R14,R14
         IC    R14,DEBNMEXT-DEBDS(,R1)  NUMBER OF EXTENTS IN DATASET
         SR    R0,R0                    TRACK TOTAL ACCUMULATOR
         AH    R0,DEBNMTRK-DEBDS(,R1)   TRACKS IN THIS EXTENT
         LA    R1,16(,R1)               GET NEXT EXTENT DESCRIPTOR
         BCT   R14,*-8                  DO ALL EXTENTS
         STH   R0,MAXTT                 SAVE AS THE MAXIMUM TT OF TTR
         SPACE 2
*
*  FIND THE LAST TTR FROM THE FORMAT 1 DSCB OF THE DATASET, OBTAINED,
*  CLEVERLY ENOUGH, BY AN 'OBTAIN' (ASSUMING IT'S NOT A VTOC)
*
         TM    FLAGS2,VTOC              VTOC PROCESSING?
         BO    SKIPCAML                 YES, USE ENDTTR FOR DS1LSTAR
         MVC   TEMP3(44),DSNAME         ASSUME QUOTED DSNAME
         TM    FLAGS2,QUOTED            CORRECT?
         BO    NOADJUST                 YES, BRANCH
         L     R15,CPPLPSCB             PSCB POINTER
         SR    R14,R14                  PREPARE FOR IC
         IC    R14,7(,R15)              USERID ACTUAL LENGTH
         MVC   TEMP3(*-*),0(R15)        <<EXECUTED>>
         EX    R14,*-6                  MOVE IN USERID (AND EXTRA BYTE)
         LA    R15,TEMP3(R14)           POINT TO PERIOD LOCATION
         MVI   0(R15),C'.'              ADD FOLLOWING PERIOD
         LA    R1,42                    MAXIMUM DSNAME LENGTH -2
         SR    R1,R14                   MACHINE LENGTH TO MOVE
         MVC   1(*-*,R15),DSNAME        <<EXECUTED>>
         EX    R1,*-6                   ADD REMAINDER OF THE NAME
NOADJUST DS    0H
*DSCBLIST CAMLST SEARCH,TEMP3,VOLSER,SCREEN
         L     R14,=AL1(193,0,0,0)     +MOVE IN OPTIONS
         LA    R15,TEMP3               +DSNAME FOR OBTAIN
         LA    R0,VOLSER               +POINT TO VOLSER
         LA    R1,SCREEN               +DSCB BUFFER
         STM   R14,R1,DSCBLIST         +STORE ALL FOUR VALUES
         OBTAIN DSCBLIST                GET THE FMT1 DSCB
         MVC   ENDTTR(3),DS1LSTAR-DSCB+SCREEN-44  SAVE IT
         EJECT
         CLI   DSORG,0  ***  OVERLAY ZERO JFCB VALUES WITH DSCB VALUES
         BNE   *+10
         MVC   DSORG(1),DS1DSORG-DSCB+SCREEN-44      DSORG
         CLI   OPTCD,0
         BNE   *+10
         MVC   OPTCD(1),DS1OPTCD-DSCB+SCREEN-44      OPTCD
         CLC   BLKSIZE(2),=H'0'
         BNE   *+10
         MVC   BLKSIZE(2),DS1BLKL-DSCB+SCREEN-44     BLKSIZE
         CLC   LRECL(2),=H'0'
         BNE   *+10
         MVC   LRECL(2),DS1LRECL-DSCB+SCREEN-44      LRECL
         CLI   KEYLEN+1,0
         BNE   *+10
         MVC   KEYLEN+1(1),DS1KEYL-DSCB+SCREEN-44    KEYLEN
         CLI   RECFM,0
         BNE   *+10
         MVC   RECFM(1),DS1RECFM-DSCB+SCREEN-44      RECFM
SKIPCAML LH    R0,BLKSIZE              BLKSIZE
         AH    R0,KEYLEN               ADD THE KEYLENGTH
         CH    R0,=H'2048'             ABOVE MINIMUM BUFFER SIZE?
         BNL   *+8                     YES, BRANCH
         LH    R0,=H'2048'             NO, USE 2K FOR BUFFER SIZE
         LH    R15,EXCPBUF             SIZE OF PREVIOUS BUFFER
         CR    R0,R15                  NEED MORE CORE?
         BNH   NOGETCOR                NO, BRANCH
         STH   R0,EXCPBUF              SAVE DESIRED SIZE
         LTR   R0,R15                  ANY PREVIOUS BUFFER?
         BZ    NOFREE                  NO, BRANCH
         AH    R0,=H'256'              256 BYTE HIDDEN BUFFER FOR TRT
         FREEMAIN E,LV=(0),A=ADDRWORK,MF=(E,GETLIST)
NOFREE   LH    R0,EXCPBUF              SAVE FOR LATER
         AH    R0,=H'256'              256 BYTE HIDDEN BUFFER FOR TRT
         GETMAIN EC,LV=(0),A=ADDRWORK,MF=(E,GETLIST)
         L     R1,ADDRWORK              GET ADDR OF AREA WE HOPE
         BXLE  R15,R15,OKGETCS          IT WORKED
         LA    R1,GETCSMSG              NO, PT TO MSG
         XC    EXCPBUF(2),EXCPBUF       NO BUFFER NOW
         B     CSIO#                    ERROR MESSAGE AND RETRY
         EJECT
OKGETCS  ST    R1,ADDRBUFF              PT TO KEY (IF ANY)
         AH    R1,KEYLEN                PT TO THE ACTUAL DATA
         ST    R1,ADDRBUFF+4            SAVE PTR TO ACTUAL DATA
         SPACE 2
NOGETCOR MVC   CCW(CCWIOBL),CCWI        INITIALIZE CCW'S AND THE IOB
         LA    R0,CDATAL/8              NUMBER OF CCW'S
         LA    R1,CCW                   BASE ADDRESS FOR CCW'S
         LR    R14,R1                   CURRENT CCW POINTER
CCWREL   L     R15,0(,R14)              CURRENT DISPLACEMENT
         ALR   R15,R1                     MADE RELATIVE
         ST    R15,0(,R14)                AND REPLACED
         LA    R14,8(,R14)              NEXT CCW
         BCT   R0,CCWREL                REPEAT FOR ALL CCW'S
*
         LA    R1,ECB                   POINT TO THE ECB
         ST    R1,ECBPTR                  FROM THE IOB
         LA    R1,DCBU                  POINT TO THE DCB
         ST    R1,IN                      FROM THE IOB
         MVC   CCW3+1(3),ADDRBUFF+1     READ BUFFER ADDRESS
         MVC   CCW3W+1(3),ADDRBUFF+1    WRITE BUFFER ADDRESS
         CLI   KEYLEN+1,0               ANY KEYS TO BE READ?
         BE    *+12                     NO, BRANCH
         OI    CCW3,X'08'               SET FOR READ KEY AND DATA
         OI    CCW3W,X'08'                AND WRITE KEY AND DATA
         SPACE 1
*  GET FREE DEFINE TABLE SYMBOLS FOR 'LRECL', 'KEYLEN', AND 'BLKSIZE'
*
         L     R1,AIDEFTAB              PT TO DEFINE TABLE
         MVC   0(5,R1),=C'LRECL'        'LRECL' SYMBOL
         MVC   8(2,R1),LRECL            GET LRECL, PUT IN TAB
         MVC   10(7,R1),=C'BLKSIZE'     'BLKSIZE' (MAX)
         MVC   18(2,R1),BLKSIZE         GET BLKSIZE, PUT IN TAB
         MVC   20(6,R1),=C'KEYLEN'      'KEYLEN' SYMBOL
         MVC   28(2,R1),KEYLEN          GET KEYLEN AND PUT IN TABLE
         LA    R1,30(R1)                UPDATE DEFINE TABLE PTR
         TM    FLAGS2,VTOC              VTOC PROCESSING?
         BNO   IDEFOK                   NO, BRANCH
         L     R1,AIDEFTAB              POINT TO DEFINE TABLE
         MVC   0(F1SIZE,R1),F1TBL       MOVE IN FORMAT1 SYMBOLS
         LA    R1,F1SIZE(,R1)           UPDATE LENGTH OF TABLE
*
IDEFOK   ST    R1,IDEFAVAL              SAVE IT A PTR TO CURR ENTRY
         MVC   GENERROR(40),=CL44' '    CLEAR ERROR MSG PART OF SCREEN
         DEVTYPE DDNAME,TEMP2,DEVTAB    DEVICE CHARACTERISTICS
         MVC     MAXHH(2),TEMP2+10      TRACKS/CYLINDER
 TITLE 'ZAP --- SCREEN FORMATTING'
*  HERE IF A NEW BLOCK IS TO BE READ AND THE SCREEN IS TO BE BUILT
*  FROM IT
         SPACE 2
READX    XC    NOWBYTE(12),NOWBYTE      CLEAR ALL OF WORK AREA (CONTIG)
         BAL   R8,READBLK               GET A BLK FROM DATA SET
         B     READZ
*
*  HERE IF NO TRACE OF THIS COMMAND IS DESIRED (ERROR OR STATUS MSG.)
*
READY    MVI   TRACE,NOTRACE            DO NOT TRACE THIS COMMAND
*
*  HERE IF BUILD SCREEN WITHOUT READING A NEW BUFFER IN
*
READZ    BAL   R8,CLEAR                 CLEAR THE SCREEN
         OC    BLKLEN(2),BLKLEN         0 READ BEFORE?
         BZ    DISPLAY                  YES - THERE'S NOTHING TO DISP
         L     R8,NOWBYTE               OFFSET INTO BUFFER
         L     R5,NOWBYTE2              DBLW OFFSET INTO BUFFER
         A     R8,ADDRBUFF              GET ADDRESS INTO BUFFER
         A     R5,ADDRBUFF              GET DBLW ADDRESS INTO BUFFER
         L     R15,FIRSTSCR             PT TO FIRST AVAIL SCREEN POS
*
*  FORMAT ONE LINE OF SCREEN DISPLAY
*
LOOP1    LR    R2,R8                    SAVE BUFFER PTR TO FOOL WITH
         CR    R2,R5                    IS THE BUFF PTR = DATA PTR?
         BNE   FORMTA#1                 NO - FORGET CARET BUSINESS
         SR    R1,R1                    YES - CLEAR WORK REG FOR IC
         IC    R1,BITS                  GET LOW ORDER BYTES OF ADDR
         LA    R3,BYTES(R1)             PT TO TAB COLUMN OF SCREEN
         IC    R1,0(R3)                 GET TAB COLUMN
         LA    R4,0(R15,R1)             PTR TO WHERE CARET WILL GO
         TM    BITS,1                   ODD BOUNDARY IN ADDR?
         BO    FORMTAB2                 YES - SO MAKE CARET '<'
         MVI   0(R4),C'>'               NO - MAKE CARET '>' ON SCR
         B     FORMTAB1                 GO ON WITH FORMAT
FORMTAB2 MVI   0(R4),C'<'               MOVE IN CARET
FORMTAB1 ST    R4,MIDLINE               CARET LINE FOR WINDOW
FORMTA#1 S     R2,ADDRBUFF              OFFSET INTO BUFFER FOR SCR
         ST    R2,TEMP                  SAVE IT FOR UNPK
         UNPK  TEMP2(9),TEMP(5)         GET READY FOR CHAR HEX CONV
         TR    TEMP2(8),TRHEX           MAKE OFFSET CHAR HEX
         MVC   0(6,R15),TEMP2+2         MOVE OFFSET TO SCREEN
         UNPK  TEMP2(9),0(5,R8)         GET THE DATA ITSELF
         TR    TEMP2(8),TRHEX           GET IT IN CHAR HEX
         MVC   8(4,R15),TEMP2           MOVE FULLWORD TO SCREEN
         MVC   13(4,R15),TEMP2+4        MOVE THE OTHER FULLWORD
         UNPK  TEMP2(9),4(5,R8)         THE SAME...
         TR    TEMP2(8),TRHEX           OPERATION FOR...
         MVC   19(4,R15),TEMP2          DATA DOUBLEWORD...
         MVC   24(4,R15),TEMP2+4        NUMBER TWO
         MVI   30(R15),C'×'             MOVE IN 'DUMP' FORMAT DELIMS
         MVI   39(R15),C'×'             ON THE OTHER END
         MVC   31(4,R15),0(R8)          MOVE STUFF TO SCR IN BETWEEN
         L     R1,TRTABADD              GET RIGHT TRTAB PTR
         TR    31(4,R15),0(R1)          MAKE IT VALID CHARS
         MVC   35(4,R15),4(R8)          MOVE STUFF TO SCR IN BETWEEN
         TR    35(4,R15),0(R1)          MAKE IT VALID CHARS
         LA    R8,8(R8)                 UPDATE BUFFER PTR
         LA    R15,40(R15)              UPDATE SCREEN PTR
         LR    R1,R8                    SAVE BUFF PTR SO THAT WE CAN...
         S     R1,ADDRBUFF              GET THE OFFSET INTO BUFFER
         CH    R1,BLKLEN                ARE WE PAST THE BLKLENGTH?
         BL    SCRCHK                   NO - BUT CHECK SCREEN LEFT NOW
*
*  WE ARE AT THE END OF THE BLK, SO MAKE SURE WE DON'T DISPLAY MORE
*  THAN WE HAVE TO.  THAT IS, BLANK OUT GARBAGE WHICH IS NOT IN THE
*  BUFFER IN BOTH THE DATA AND THE TRANSLATED SECTIONS OF THE SCREEN.
*
         LH    R1,BLKLEN                GET THE ACTUAL LEN OF BLK
         N     R1,=F'7'                 GET LOW ORDER 3 BITS FOR '>'
         LTR   R1,R1                    ON DBLW BOUNDARY NOW?
         BZ    DISPLAY                  YES - NO GARBAGE, NO BLANK
         STC   R1,0(R13)                SAVE THE BITS
         LA    R2,BYTES(R1)             FIND CARET OFFSET
         XR    R1,R1                    CLEAR FOR IC
         IC    R1,0(R2)                 GET CARET OFFSET
         TM    0(R13),1                 HALFWORD BOUNDARY?
         BNO   HWORDBND                 YES - WE HAVE RIGHT OFFSET
         SH    R1,=H'3'                 NO - WE ARE 3 OFF HERE
HWORDBND SH    R15,=H'40'               SO MAKE IT THE RIGHT LINE TOO
*  NOTE:  R2 WILL PT  1 BYTE PAST LAST ACTUAL DATA BYTE ON THE CORRECT
*         SCREEN LINE (IE - THE FIRST POSITION TO START BLANKING)
         LA    R2,1(R1,R15)             PT PAST ACTUAL LAST DATA BYTE
         LA    R3,28-1-1                GET MAX BLANKING LENGTH
*  NOTE:  26 IS THE VIABLE LINE LENGTH (28) -1 FOR EXECUTE LENGTH
*         AND -1 FOR THE MVI OF 1 BLANK.
         SR    R3,R1                    GET ACTUAL BLANKING LENGTH
         MVI   0(R2),C' '               BLANK AT LEAST 1 BYTE
         LTR   R3,R3                    IS THERE ANY LEFT TO DO?
         BM    BLANKTR                  NO - GO ONWARD WITH XLATE SCTN
JUNKMVC  MVC   1(0,R2),0(R2)            <<< EXECUTED >>>
         EX    R3,JUNKMVC               YES - SO BLANK OUT THE GARBAGE
*
*  TRANSLATED PORTION OF SCREEN GETS THE TREATMENT TOO
*
BLANKTR  XR    R1,R1                    CLEAR FOR IC
         IC    R1,0(R13)                PICK UP BITS AGAIN
         LA    R3,8-1-1                 GET MAX NUM LEN -1 MVI -1 EXLEN
         SR    R3,R1                    GET NUMBER TO BE BLANKED
*  (-1 FOR MVI  AND  -1 FOR EX LEN OF COURSE)
         LA    R2,31(R1,R15)            POINT TO BEGINNING OF JUNK
         MVI   0(R2),C' '               NAIL AT LEAST ONE BYTE
         LTR   R3,R3                    IS THERE ANY MORE?
         BM    DISPLAY                  NO - WE'RE DONE HERE, GO DISP
         EX    R3,JUNKMVC               YES - GET RID OF THE REST THEN
         B     DISPLAY
SCRCHK   C     R15,MAXSCR               NO - ARE WE OUT OF SCREEN THEN?
         BNE   LOOP1                    NO - THEN MAKE ANOTHER LINE
         SPACE 3
DISPLAY  MVI   TTR+3,0                  MAKE TTRN AND TURN OFF SEQ
         MVI   EOFRET,YESEOF            SAY EOF'S WILL BE RECOGNIZED
         TM    FLAGS2,NOT1ST            IS THIS THE 1ST TIME?
         BO    NOTWHERE                 NO, DONT SHOW 'WHERE' LINES
         BAL   R8,WHEREAMI              YES, FORMAT WHERE I AM
         OI    FLAGS2,NOT1ST            NO LONGER 1ST TIME
NOTWHERE BAL   R8,CSIO                  DISPLAY SCREEN JUST MADE
 TITLE 'ZAP --- ANALYZE REPLY AND ROUTE PROCESSING'
*
*  ANALYZE REPLY -- FIND REPLY LENGTH AND COPY IT TO TEMP2
*
ANALREP  LA    R1,REP-1                 POINT TO FIRST CHAR AND FUDGE
         LR    R15,R1                   POINT TO FIRST
         XR    R14,R14                  CLEAR A REGISTER
         BCTR  R14,0                    GET A MINUS 1 FOR DECREMENT
         LH    R0,READLEN               GET READ LENGTH    (CSDECB+14)
         AR    R1,R0                    AND POINT TO LAST CHAR READ
COMGET   CLI   0(R1),C' '               END OF STRING?
         BNE   COMGOT                   YES - WE HAVE END OF STRING
         BXH   R1,R14,COMGET            BACKSCAN FOR NON-BLANK
         B     READY                    ALL BLANK, IGNORE WITH NO TRACE
COMGOT   SR    R1,R15                   GET LENGTH
COMNEXT  LA    R15,1(,R15)              NEXT BYTE
         CLI   0(R15),X'40'             BLANK OPERATION?
         BNE   COMCHK                   NO, FOUND THE START
         BCT   R1,COMNEXT               DECREMENT LENGTH AND SCAN
COMCHK   LTR   R1,R1                    LENGTH > 0?
         BNP   READY                    NO, IGNORE IT
PB       STH   R1,REALRDLN              PHONY UP THE ACTUAL READ LEN
         MVC   TEMP2(40),=CL44' '       CLEAR BUFFER
         BCTR  R1,0                     EXECUTE LENGTH
COMMVC   MVC   TEMP2(0),0(R15)          <<< EXECUTED >>>
         EX    R1,COMMVC                COPY ACROSS
         TITLE 'ZAP --- COMMAND CHECKING AND ROUTING'
*  SEE IF THE COMMAND IS IN THE COMMAND TABLE
         SPACE 2
         SR    R1,R1                    CLEAR REG FOR IC'S
         LA    R2,COMTAB                PT TO COMMAND TABLE
COMLOOP  CLI   0(R2),X'FF'              END OF TABLE
         BE    EXPR                     YES - NOT IN TAB, AN EXPRESS?
         IC    R1,0(R2)                 NO - PICK UP LEN OF COMMAND
COMCLC   CLC   1(0,R2),TEMP2            <<< EXECUTED >>>
         EX    R1,COMCLC                COMMAND MATCH?
         BE    GOTCOM                   YES - GO DO IT
         LA    R2,12(R2)                NO - PT TO NEXT TAB ENTRY
         B     COMLOOP
GOTCOM   CH    R1,REALRDLN              NEED ADJUSTING?
         BNL   COMLOAD                  NO, BRANCH
         LA    R1,TEMP2(R1)             CHARACTER FOLLOWING THE OPCODE
         CLI   0(R1),X'40'              TO BE ADJUSTED?
         BNE   COMLOAD
         LR    R15,R1                   REMEMBER THIS POSITION
         LH    R14,REALRDLN             PREVIOUSLY COMPUTED LENGTH
COMSCAN  LA    R1,1(,R1)                TRY THE NEXT BYTE
         BCTR  R14,0                    ONE LESS CHARACTER
         CLI   0(R1),X'40'              BLANK AGAIN?
         BE    COMSCAN                  YES, LOOP
         STH   R14,REALRDLN             UPDATE NEW LENGTH
         MVC   0(0,R15),0(R1)           <<EXECUTED>>
         EX    R14,*-6                  SLIDE THE OPERANDS BACK DOWN
COMLOAD  L     R2,8(R2)                 PICK UP ROUTINE ADDR
         BR    R2                       GO DO IT
         TITLE 'ZAP --- COMMAND EXECUTION --- EXPRESSION'
*
*****  NO COMMAND (EXPRESSION)  *****
*
EXPR     LA    R1,TEMP2                 GET EXPRESSION PTR
         LH    R0,REALRDLN              GET EXPRESSION LEN
         SPACE 2
PARSE    LH    R15,OLDPOINT             GET '*' (CURRENT VALUE)
         MVI   EXPOPT,YESSYMB           SAY 'LOOK AT THE SYMBOL TABLE'
         BAL   R14,EXP                  GO PARSE THE EXPRESSION
         SPACE 1
         LTR   R1,R1                    ERROR (POS=YES AND LOCATION)
         BM    OKFALL                   NO - GO ON
INVEXPER L     R2,AINVEXP               YES - SAY INVALID SYNTAX
*  NOTE:  R1 WILL PT TO THE COLUMN OF THE ERROR
         B     BOTCH                    AND GO TELL HIM WITH NO TRACE
OKFALL   LTR   R15,R15                  WHAT IS PARSED FINAL VALUE?
         BNM   POSFALL                  IT'S NON-NEG, SO WE'RE OK
         XR    R15,R15                  CAN'T HAVE NEGATIVE
POSFALL  LR    R1,R15                   PUT IN RIGHT REG
         SPACE 2
*  THE FOLLOWING CODE CONVERTS AN ABSOLUTE OFFSET INTO THE BLK
*  INTO THE CORRECT INFORMATION NEEDED FOR CARET AND 1ST_LINE
*  POSITIONING LATER
         SPACE 2
SETPOINT LR    R2,R1                    SAVE FOR THE FOLLOWING TOO
         N     R2,=F'7'                 KILL ALL BUT LOW ORDER 3 BITS
         STC   R2,BITS                  SAVE WHERE IS BELONGS FOR CARET
         LR    R2,R1                    PICK UP ADDR AGAIN
         N     R2,=XL4'FFFFFFF8'        GET HI ORDR 3 BYTES AND 1 BIT
         ST    R2,NOWBYTE2              SAVE THAT FOR CARET TOO
         LH    R2,BLKLEN                GET BLKLENGTH
         BCTR  R2,0                     -1 FOR COMPARE
         CR    R1,R2                    ARE WE STILL WITHIN THE BLK?
         BNH   DISPLAY3                 YES - WE'RE OK
         LR    R1,R2                    NO - MAKE IT THE END OF BLK
         B     SETPOINT                 GO FIX UP POINTER
DISPLAY3 STH   R1,OLDPOINT              SAVE OFFSET FOR CURR LOC
         SH    R1,=AL2((SCRLINES-1)/2*8) MOVE TOP OF FORMATED AREA BY
*                                        1/2 OF THE MAXIMAL SCREEN
*  NOTE: MULTIPLIED BY 8 SINCE 8 BYTES ARE DISPLAYED ON A LINE
*
         BNM   DISPLAY4                 IF POS OR 0 WE'RE OK, ELSE
         SR    R1,R1                    ZERO OUT OFFSET FOR MID SCR
DISPLAY4 N     R1,=XL4'FFFFFFF8'        GET HI ORDER 3 BYTES + 1 BIT
         ST    R1,NOWBYTE               SAVE IT
         B     READZ                    GO DO IT
         TITLE 'ZAP --- COMMAND EXECUTION --- HELP AND H'
*
*****  HELP  AND  H  *****
*
HELP     LA    R1,TEMP2+1               OPERAND STARTS AT TEMP2+1
         LH    R15,REALRDLN             ADJUST
         LA    R15,3(,R15)                    APPARENT COMMAND
         STH   R15,REALRDLN                                   LENGTH
         B     HELP#+4                  SKIP NEXT LOAD ADDRESS
*
HELP#    LA    R1,TEMP2+4               OPERAND STARTS AT TEMP2+4
         MVC   TEMP3+5(30),0(R1)        MOVE TO TEMPORARY HOLD AREA
         CLI   TEMP3+5,C'='             EQUATE INSTRUCTION?
         BNE   *+8                      NO, BRANCH
         MVI   TEMP3+5,C'E'             YES, CHANGE IT TO "E" FOR HELP
         LH    R1,REALRDLN              LENGTH OF CODED DATA
         LA    R1,2(,R1)
         STH   R1,TEMP3                 COMMAND LENGTH
         LA    R1,1                     POINTER TO
         STH   R1,TEMP3+2                         OPERANDS
         LA    R1,TEMP3                 PPL POINTS TO DATA
         ST    R1,CPPLCBUF                 FOLLOWING LENGTH & OFFSET
         CLI   IKJHELP,X'FF'            HELP ADDRESS LOADED?
         BNE   HELPLOAD                 YES, BRANCH
         LOAD  EP=HELP                  LOAD
         ST    R0,IKJHELP               SAVE ENTRY POINT FOR LATER
HELPLOAD LA    R1,CPPL                  POINT TO THE SCAN WORK AREA
         L     R15,IKJHELP
         BALR  R14,R15                  CALL HELP
         STC   R15,IKJHELP              SAVE RETURN CODE FOR MESSAGE
         MVC   TEMP3(8),DDNAME          SAVE CURRENT DDNAME
         MVC   DDNAME(8),=CL8'SYSHELP'  FREE SYSHELP
         BAL   R8,FREE                              FOR LATER CALLS
         MVC   DDNAME(8),TEMP3          RESTORE CURRENT DDNAME
         LA    R2,HELPFAIL              ASSUME "NO HELP"
         CLI   IKJHELP,0                CORRECT
         BNE   BOTCH                    YES, BRANCH
         B     BOTCH2                   NO, NORMAL DISPLAY
         TITLE 'ZAP --- COMMAND EXECUTION --- END, CHANGE AND C'
*
*****  END  *****
*
         SPACE 2
END      BAL   R8,CHKPT                 CHECK TO SEE IF ZAP REQ
         BAL   R8,CLOSE                 CLOSE THE FILE AND FREE IT
         LH    R0,EXCPBUF               CURRENT EXCP BUFFER SIZE
         LTR   R0,R0                    ANYTHING TO FREE?
         BNP   ENDL                     NO, BRANCH
         AH    R0,=H'256'               256 BYTE HIDDEN BUFFER FOR TRT
         FREEMAIN E,LV=(0),A=ADDRWORK,MF=(E,GETLIST)  FREE THE BUFFER
ENDL     L     R13,4(,R13)              RESTORE THE REG STUPID
         LM    R14,R12,12(R13)          RESTORE
         XR    R15,R15                  RC=0
         BR    R14                      BYE BYE
         SPACE 3
*
*****  CHANGE  AND  C  *****
*
CHANGE   LA    R1,TEMP2+1               OPERAND STARTS AT TEMP2+1
         LH    R15,REALRDLN             ADJUST
         LA    R15,4(,R15)                    APPARENT COMMAND
         STH   R15,REALRDLN                                   LENGTH
         B     CHANGE#+4                SKIP NEXT LOAD ADDRESS
*
CHANGE#  LA    R1,TEMP2+6               OPERAND STARTS AT TEMP2+6
         MVC   TEMP3+5(39),0(R1)        MOVE TO TEMPORARY HOLD AREA
         BAL   R8,CHKPT                 CHECK IF ZAP REQUIRED
         BAL   R8,CLOSE                 CLOSE AND FREE THE DATA SET
         LH    R1,REALRDLN              LENGTH OF CODED DATA
         STH   R1,TEMP3                 COMMAND LENGTH
         LA    R1,1                     POINTER TO
         STH   R1,TEMP3+2                         OPERANDS
         LA    R1,TEMP3
         ST    R1,PPLCBUF               CBUF POINTS TO THE OPERAND
         B     PARSEDSN                 TRY PARSING THIS DATA
         TITLE 'ZAP --- COMMAND EXECUTION --- EBCDIC, ASCII'
*
*****  EBCDIC  *****
*
EBCDIC   LA    R1,TRCHARE               PICK UP PTR TO EBCDIC TRTAB
         LA    R2,EBCDCMSG              TELL HIM WHAT JUST HAPPENED
         B     ASCII2                   GO DO IT AND DISPLAY
         SPACE 10
*
*****  ASCII  *****
*
ASCII    LA    R1,TRCHARA               PICK UP PTR TO ASCII TRTAB
         LA    R2,ASCIIMSG              TELL HIM WHAT JUST HAPPENED
ASCII2   ST    R1,TRTABADD              SAVE FOR LATER DISPLAYS
         MVC   GENERROR+5(20),0(R2)     EBCDIC / ASCII TRANSLATE MSG
         MVC   GENERROR(3),=C'***'      STARS TOO
         B     READY                    DISPLAY
         TITLE 'ZAP --- COMMAND EXECUTION --- LAST, EXTENTS'
*
*****  LAST  *****
*
LAST     BAL   R8,CHKPT                 CHECK TO SEE IF ZAP REQ
         MVC   TTR(3),ENDTTR            PICK UP LAST TTR
         TM    FLAGS2,VTOC              VTOC PROCESSSING?
         BNO   READX                    NO, GO GIVE IT TO HIM
         SR    R2,R2                    EXTENT ZERO
         ST    R2,TEMP2                 INITIALIZE MBB TO ZEROS
         MVC   TEMP2+3(5),SAVEHI        ADDRESS OF LAST FORMAT 1 DSCB
         B     THISEXT                  GO TO THIS CCHHR
         SPACE 2
*
*****  EXTENTS  *****
*
EXTENTS  MVI   TRACE,NOTRACE                     DO NOT TRACE EXTENTS
         BAL   R8,CLEAR                          CLEAR THE SCREEN
         MVC   SCREEN+160(L'EXTENT#),EXTENT#     EXTENT HEADER MSG
         L     R1,DCBDEBAD-IHADCB+DCBU      DEB ADDRESS
         SR    R14,R14                      CLEAR FOR IC
         IC    R14,DEBNMEXT-DEBDS(,R1)      NUMBER OF EXTENTS
         LA    R15,SCREEN+200               FIRST SCREEN ADDRESS
         XC    TEMP(8),TEMP                 CLEAR COUNTERS
*
EXTLOOP  L     R2,TEMP                      EXTENT NUMBER
         CVD   R2,DOUBLW
         LA    R2,1(,R2)                    NEXT EXTENT
         ST    R2,TEMP
         MVC   1(3,R15),EDMASK+9
         ED    0(4,R15),DOUBLW+6
         UNPK  TEMP2(9),DEBSTRCC-DEBDS(5,R1) CCHH START ADDRESS
         TR    TEMP2(8),TRHEX                IN PRINTABLE HEX
         MVC   7(8,R15),TEMP2
         MVI   15(R15),C'-'
         UNPK  TEMP2(9),DEBENDCC-DEBDS(5,R1) CCHH END ADDRESS
         TR    TEMP2(8),TRHEX                IN PRINTABL HEX
         MVC   16(8,R15),TEMP2
         LH    R2,DEBNMTRK-DEBDS(,R1)       NUMBER OF TRACKS IN EXTENT
         CVD   R2,DOUBLW
         MVC   27(5,R15),EDMASK+7
         ED    26(6,R15),DOUBLW+5
         UNPK  TEMP2(5),TEMP+6(3)           RELATIVE TTR
         TR    TEMP2(4),TRHEX
         MVC   36(4,R15),TEMP2
         A     R2,TEMP+4                    ACCUMULATE
         ST    R2,TEMP+4
         LA    R1,16(,R1)                   NEXT EXTENT
         LA    R15,40(,R15)                 NEXT SCREEN
         BCT   R14,EXTLOOP
         B     DISPLAY                      SHOW IT OFF
         TITLE 'ZAP --- COMMAND EXECUTION --- D'
*
*****  D  *****
*
DISPLAY# LH    R0,REALRDLN              GET READ LENGTH
         SH    R0,=H'1'                 -1 FOR THE 'D'
         BNZ   MORED                    MORE THAN A 'D'
         LH    R1,DSAVE                 GET DOWN LINES
         A     R1,WIDTHU                ADD WIDTH UP FOR NEXT DISPLAY
         SPACE 1
*
*  NOTE: ADD THE FOLLOWING TO DELETE THE ONE LINE DISPLAY OVERLAP
*        LA    R1,1(,R1)                +1 FOR REAL WIDTH
*
         SLL   R1,3                     EACH LINE 8 BYTES
         LH    R15,OLDPOINT             CURR OFFSET
         AR    R15,R1                   WHAT TO ADD FOR DOWN AND UP
         CH    R15,BLKLEN               PAST BLK?
         BL    POSFALL                  NO - GO ON
         SRL   R1,1                     TRY HALF WAY THEN
         SR    R15,R1                   MAYBE NOW?
         CH    R15,BLKLEN               STILL ICKY?
         BNL   OFLOD                    YES - GIVE UP AND NEXT BLK
         LH    R15,BLKLEN               NO - PT TO END OF BLK + 1
         B     POSFALL                  GO GIVE IT TO HIM
         SPACE 2
OFLOD    BAL   R8,CHKPT                 CHECK TO SEE IF ZAP REQ
         MVI   TTR+3,1                  SAY SEQ READ NEXT BLK
         BAL   R8,READBLK               GET THE NEX BLK
         XR    R15,R15                  OFFSET 0
         B     POSFALL                  GO GIVE IT TO HIM
MORED    LA    R1,TEMP2+1               PT TO THE EXPRESSION
         B     PARSE                    GO FIX IT UP
         TITLE 'ZAP --- COMMAND EXECUTION --- ='
*
*****  =  *****
*
EQUALS   LA    R1,TEMP2+1               POINT TO INVALID CHARACTER
         CLI   0(R1),C'0'               FIRST DIGIT POSSIBLE ALPHA?
         BNL   INVEXPER                 NO, INVALID
         LH    R0,REALRDLN              TOTAL BYTES
         BCTR  R0,0                     BYTES AFTER THE =
         CLI   0(R1),C'A'               ALPHA OR NUMERIC DIGITS?
         BL    INVEXPER                 NO, INVALID
         LA    R1,1(,R1)                NEXT BYTE
         BCT   R0,*-12                  CHECK ALL DIGITS
*
         L     R15,IDEFAVAL             GET PTR TO 1ST AVAIL TABL POS
         LA    R3,IDEFTAB               PT TO BEGINNING
         SPACE 1
*  SEE IF THE SYMBOL IS ALREADY DEFINED
         SPACE 1
ICLOOP   CR    R3,R15                   UP TO FIRST AVAIL POS YET?
         BNL   OKIDEF                   YES - NO DUPLICATE, SO DEFINE
         CLC   0(8,R3),TEMP2+1          NO - SYMBOL ALREADY HERE?
         BE    REDEF                    YES - SO REDEFINE IT
         LA    R3,10(R3)                NO - PT TO NEXT SPOT IN TABLE
         B     ICLOOP                   KEEP GOING TILL OUT
REDEF    MVC   8(2,R3),OLDPOINT         MOVE IN THE OFFSET
         LA    R2,REDEFMSG              PT TO MSG SAYING REDEFINED SYM
         B     BOTCH                    DONT RESET FIRST AVAIL - LEAVE
OKIDEF   LA    R2,TABFULL               ASSUME TABLE FULL
         CLI   0(R15),X'FF'             CORRECT?
         BE    BOTCH                    YES, DO NOT ALLOW
         MVC   0(8,R15),TEMP2+1         MOVE IN THE SYMBOL TO TAB
         MVC   8(2,R15),OLDPOINT        MOVE IN OFFSET INTO BLK
         LA    R15,10(,R15)             POINT TO NEXT AVAIL
         ST    R15,IDEFAVAL             SAVE FOR NEXT TIME
         LA    R2,DEFINED               SAY "IT'S DEFINED"
         B     BOTCH
         TITLE 'ZAP --- COMMAND EXECUTION --- NODEF  AND  IDEF'
*
*****  NODEF  *****
*
NODEF    BAL   R8,CLEARDEF              YES - LET HIM HAVE IT
         LA    R2,DEFRESET              TELL HIM WE RESET THE TABLE
         B     BOTCH                    GO BACK TO DISPLAY (NOTRACE)
         SPACE 5
*
*****  IDEF  *****
*
IDEF     BAL   R8,CLEAR                 CLEAR THE SCREEN
         MVC   IDEFFMT(16),IDEFMASK     MOVE IN MASK TIMES 1 (COL)
         MVC   IDEFFMT+20(16),IDEFMASK  MOVE IN MASK TIMES 2 (COL)
         LA    R1,IDEFFMT+40            PT TO DISPLAY
         L     R2,IDEFAVAL              PT PAST LAST LOC TO FORMAT
         LA    R3,IDEFTAB               PT TO TABLE
IFMTLOOP CR    R3,R2                    DONE WITH FORMATTABLE STUFF?
         BL    IFMTOK#                  YES - DISPLAY WITH NO TRACE
         MVI   TRACE,NOTRACE            NOTRACE
         B     DISPLAY                  GO GIVE IT
IFMTOK#  MVC   0(8,R1),0(R3)            MOVE SYMBOL TO DISPLAY
         UNPK  TEMP2(5),8(3,R3)         MOVE IN OFFSET TOO
         TR    TEMP2(4),TRHEX           FLIP BYTE
         MVC   11(4,R1),TEMP2           TO DISPLAY
         LA    R1,20(R1)                UPDATE DISPLAY PTR
         LA    R3,10(R3)                UPDATE TABLE PTR
         B     IFMTLOOP                 KEEP UP THE GOOD WORK
         TITLE 'ZAP --- COMMAND EXECUTION --- ITRACE'
*
*****  ITRACE  *****
*
ITRACE   LA    R2,ITRTAB                PT TO BEGINNING OF TABLE
         BAL   R8,CLEAR                 CLEAR THE SCREEN
         MVC   ITRFMT+1(11),ITRMASK     MOVE IN MASK TIMES 1
         MVC   ITRFMT+14(11),ITRMASK    MASK TIMES 2
         MVC   ITRFMT+27(11),ITRMASK    MASK TIMES 3
         LA    R3,ITRFMT+40+1           FIRST AVAIL SCREEN POSIT
NEWLINE  LA    R4,3                     CNT FOR GOOD OFFSET DISP LOOP
ITRFMTLP CLI   0(R2),X'FF'              END OF TABLE
         BNE   MOREITR                  NO - KEEP FORMATTING
         MVI   TRACE,NOTRACE            DO NOT TRACE
         B     DISPLAY                  GO DISPLAY
MOREITR  UNPK  TEMP2(7),0(4,R2)         PICK UP TTR ENTRY
         TR    TEMP2(6),TRHEX           MAKE IT CHAR HEX
         MVC   0(6,R3),TEMP2            MOVE TO SCREEN
         UNPK  TEMP2(5),3(3,R2)         PICK UP OFFSET
         TR    TEMP2(4),TRHEX           MAKE IT HEX
         MVC   7(4,R3),TEMP2            MOVE TO SCREEN
         C     R2,CURRITR               IS THIS THE CURRENT TRACE TAB
         BNE   NOTCURR                  NO - GO ON WITH FORMATTING
         BCTR  R3,0                     YES - BACK UP SCREEN PTR TO
         MVI   0(R3),C'>'               MOVE IN THE PTR TO CURR ENTRY
         LA    R3,1(R3)                 AND RESET THE PTR
NOTCURR  LA    R3,13(R3)                UPDATE SCREEN PTR
         LA    R2,5(R2)                 UPDATE TABLE PTR
         BCT   R4,ITRFMTLP              DO IT THRICE
         LA    R3,1(R3)                 MAKE UP FOR ODDBALL SCREEN
         B     NEWLINE                  DO IT ALL OVER
         TITLE 'ZAP --- COMMAND EXECUTION --- >, <'
*
*****  >  *****
*
FORWARD  L     R3,ITRAVAL               PICK UP PTR TO NEXT TRACE
         CLI   0(R3),X'FF'              END OF TABLE?
         BNE   *+8                      NO - NO PROBLEM
         LA    R3,ITRTAB                YES - SO RAP AROUND TO TOP
         LA    R2,INVFMSG               ASSUME NO TRACE ENTRY
         OC    0(5,R3),0(R3)            IS THERE ANY ENTRY?
         BZ    BOTCH                    NONE, GO TELL HIM
         LA    R4,5(,R3)                PT TO NEXT ONE AFTER THAT
         B     CARET                    FINISH ALL THE REST
         SPACE 2
*
*****  <  *****
*
BACKWARD LA    R2,ITRTAB                PT TO TRACE TABLE
         L     R3,ITRAVAL               PT TO NEXT CURRENT ENTRY
         CR    R3,R2                    CURRENT ENTRY = FIRST ENTRY?
         BNE   *+8                      NO - NO PROBLEM (YET)
         LA    R3,ITREND                YES, START AT END OF TABLE
         SH    R3,=H'5'                 BACKTRACK ONE ENTRY
         LR    R4,R3                    SAVE FOR LATER ITRAVAL
         CR    R3,R2                    IS THAT THE BEGINNING NOW?
         BNE   *+8                      NO - NO MORE WORRIES
         LA    R3,ITREND                YES - WE MUST LOOP TO ENDTAB
         SH    R3,=H'5'                 BACKTRACK ONE ENTRY
         LA    R2,INVBMSG               ASSUME NO TRACE TABLE ENTRY
         OC    0(5,R3),0(R3)            DOES THAT ENTRY EXIST?
         BZ    BOTCH                    NO, GO TELL HIM
         SPACE 2
*
*  DO THE CARET.  IF LEAVING BLOCK, CHECK TO SEE OF BLK REPLACED.
*
CARET    MVI   TRACE,NOTRACE            DON'T TRACE < OR >
         CLC   TTR(3),0(R3)             NEW BLOCK NEEDED?
         BE    RDNOTNEC                 NO, DON'T BOTHER WITH CHECK
         BAL   R8,CHKPT                 YES, MAKE SURE THIS ONES OK
         MVC   TTR(3),0(R3)             NEW BLK - GET CORRECT TTR
         BAL   R8,READBLK               READ THE BLOCK IN
         SPACE 1
RDNOTNEC ST    R4,ITRAVAL               NEW TRACE TABLE PTR
         ST    R3,CURRITR               SAVE CURRENT TRACE TAB ENTRY
         MVC   TEMP(2),3(R3)            NOW GET OFFSET FROM TRACE TAB
         LH    R1,TEMP                  INTO RIGHT REG
         B     SETPOINT                 GO FAKE A '+' COMMAND
         TITLE 'ZAP --- COMMAND EXECUTION --- CC'
*
*****  CC  (OF CCHHR)  *****
*
CC       BAL   R8,CHKPT                 ANY ZAP NEEDED?
         LH    R3,REALRDLN              READ LENGTH
         SH    R3,=H'2'                 -2 FOR CC
         CH    R3,=H'10'                VALID LENGTH?
         BH    LENERROR                 NO, ERROR MESSAGE
         LR    R1,R3                    LENGTH OF STRING
         LA    R9,TEMP2+2               POINT TO START OF STRING
         BAL   R8,HEXCHECK              VALID HEXADECIMAL DIGITS?
         B     CCHHROK                  YES, BRANCH
         LA    R2,INVHEX                INVALID HEXADECIMAL
         B     BOTCH                    AND TELL HIM
*
CCHHROK  LA    R4,TEMP2+2               POINT TO STRING
         LA    R5,DOUBLW                RESULT ADDRESS
         BAL   R6,GETSTRNG              GET THE CODED HEX STRING
         SR    R5,R5                    CLEAR FOR IC
         IC    R5,DOUBLW                LENGTH OF RESULT STRING
         XC    TEMP2(8),TEMP2           MBBCCHHR WORK AREA
         LA    R2,TEMP2+7               ADDRESS OF END OF STRING -1
         SR    R2,R5                    WHERE TO START MOVING
         MVC   0(5,R2),DOUBLW+1         MOVE IN MAX LENGTH STRING
         SPACE 2
         L     R1,DCBDEBAD-IHADCB+DCBU  DEB ADDRESS
         SR    R14,R14                  CLEAR FOR IC
         IC    R14,DEBNMEXT-DEBDS(,R1)  NUMBER OF EXTENTS
         SR    R2,R2                    EXTENT NUMBER
*
FINDEXT  CLC   TEMP2+3(2),DEBSTRCC-DEBDS(R1)   THIS START CC?
         BL    BUMPEXT                         NO, BRANCH
         BH    ENDCC                           MAYBE, BRANCH
         CLC   TEMP2+5(2),DEBSTRHH-DEBDS(R1)   THIS START HH?
         BL    BUMPEXT                         NO, BRANCH
ENDCC    CLC   TEMP2+3(2),DEBENDCC-DEBDS(R1)   THIS END CC?
         BH    BUMPEXT                         NO, BRANCH
         BL    SIZEHH                          MAYBE, CHECK THE HH
         CLC   TEMP2+5(2),DEBENDHH-DEBDS(R1)   THIS END HH?
         BH    BUMPEXT                         NO, BRANCH
SIZEHH   CLC   TEMP2+5(2),MAXHH                VALID HH FOR DEVICE?
         BL    THISEXT                         YES, BRANCH
BUMPEXT  LA    R2,1(,R2)                       NEXT EXTENT NUMBER
         LA    R1,16(,R1)                      NEXT EXTENT IN DEB
         BCT   R14,FINDEXT                     CHECK ALL EXTENTS
         LA    R2,INVALIDX                     INVALID EXTENT MSG
         B     BOTCH                           TELL ABOUT IT
*
THISEXT  STC   R2,TEMP2                SET THE EXTENT NUMBER
         MBBTTR TTR,MBB=TEMP2          CONVERT TO TTR ADDRESS
         B     READX                   AND GO THERE
         TITLE 'ZAP --- COMMAND EXECUTION --- T'
*
*****  T  *****
*
TRACK    BAL   R8,CHKPT                 ANY ZAP NEEDED?
         LH    R0,REALRDLN              READLEN
         SH    R0,=H'1'                 -1 FOR 'T'
         BNZ   MORET                    NOT JUST 'T'
         LH    R15,TTR                  JUST A T (T=T+1)
         LA    R15,1(R15)               POINT TO NEXT TRACK
         B     POSTRACK                 GO DO IT
MORET    LA    R1,TEMP2+1               PT TO EXPRESSION
         LH    R15,TTR                  PICK UP '*' TRACK
         BAL   R14,EXP                  GO PARSE
         LTR   R1,R1                    OK?
         BNM   INVEXPER                 NO - ERROR
         LTR   R15,R15                  TRACK NEGATIVE?
         BM    TTRLT1                   YES - TTR < 1, GO TELL HIM
POSTRACK CH    R15,MAXTT                TOO LARGE TTR?
         BNL   OVMAXTTR                 YES, BRANCH
         STH   R15,TTR                  SAVE TRACK #
         MVI   TTR+2,X'01'              GIVE HIM REC=01
         B     READX                    READ AND DISPLAY
         TITLE 'ZAP --- COMMAND EXECUTION --- P'
*
*****  P  *****
*
POINT    BAL   R8,CHKPT                 ANY ZAP NEEDED?
         LH    R0,REALRDLN              LEN OF READ
         SH    R0,=H'1'                 -1 FOR 'P'
         BNZ   MOREP                    MORE THAN P - GET TTR
JUSTP    MVC   TTR(3),=X'000001'        JUST 'P', GIVE HIM TTR=000001
         B     READX                    DO IT
MOREP    LA    R1,TEMP2+1               ADDR OF EXPRESSION
         SPACE 1
TTRPARSE L     R15,TTR                  GET '*' = CURRENT TTR
         SRL   R15,8                    RIGHT JUSTIFY
         BAL   R14,EXP                  GET THE NUMBER HE WANTS
         LTR   R1,R1                    OK EXPRESSION?
         BNM   INVEXPER                 NO - ITS UGLY
         LTR   R15,R15                  NEGATIVE OR 0 TTR?
         BP    OKTTRZ                   NO - TTR IS OK
TTRLT1   LA    R2,TTRSMALL              YES - CANT HAVE THAT (< 000001)
         B     BOTCH                    DISPLAY ERROR STYLE
OKTTRZ   ST    R15,TEMP                 SAVE THE VALUE RETURNED
         SRL   R15,8                    GET TT OF TTR
         CH    R15,MAXTT                TOO LARGE TTR
         BNL   OVMAXTTR                 YES, BRANCH
         LA    R2,REC0INV               ASSUME RECORD ZERO
         CLI   TEMP+3,0                 CORRECT?
         BE    BOTCH                    YES, GIVE A MESSAGE
         MVC   TTR(3),TEMP+1            MOVE IN TTR
         B     READX                    GO GET IT
OVMAXTTR LA    R2,TTRLARGE              TTR TO LARGE FOR DATA SET
         B     BOTCH
         TITLE 'ZAP --- COMMAND EXECUTION --- B'
*
*****  B  *****
*
BACK     BAL   R8,CHKPT                 ANY ZAP NEEDED?
         MVC   TEMP2+1(2),=C'-1'        PHONY UP AN R-1 COMMAND
         MVI   EOFRET,NOEOF             TREAT EOF'S AS DATA BLKS
         LA    R0,2                     LENGTH OF DUMMY OPERAND
         B     MORER
         TITLE 'ZAP --- COMMAND EXECUTION --- R'
*
*****  R  *****
*
RECORD   BAL   R8,CHKPT                 ANY ZAP NEEDED?
         CLI   DSORG,DCBDSGPO           ARE WE IN A PDS?
         BNE   *+8                      NO - TELL HIM ABOUT EOF'S
         MVI   EOFRET,NOEOF             YES - TREAT EOF'S AS DATA BLKS
         LH    R0,REALRDLN              READ LEN
         SH    R0,=H'1'                 -1 FOR 'R'
         BP    MORER                    NOT JUST 'R'
         MVI   TTR+3,1                  GO TO NEXT RECORD
         B     READX                    READ AND DISPLAY
MORER    LA    R1,TEMP2+1               POINT TO EXPRESSION
         XR    R15,R15                  CLEAR FOR IC
         IC    R15,TTR+2                GET CURRENT RECORD
         BAL   R14,EXP                  GO PARSE
         LTR   R1,R1                    OK?
         BNM   INVEXPER                 ITS UGLY
         XR    R1,R1                    CLEAR FOR IC
         IC    R1,TTR+2                 GET CURRENT RECORD
         LR    R3,R15                   PRESERVE ABSOLUTE FOR BACK
         SR    R3,R1                    FIND OFFSET
         LR    R5,R15                   SAVE IT
* R3 IS RELATIVE OFFSET
* R5 IS ABSOLUTE VALUE
         BZ    READX                    IF STILL HERE, REREAD
         BM    RGOBACK                  IF NEGATIVE, BACK UP
         SPACE 2
*
*  OFFSET IS POSITIVE: READ FORWARD ENOUGH TIMES
*
RGOFORW  MVI   TTR+3,1                  ASK FOR NEXT BLOCK
         MVI   EOFRET,YESEOF            WE WANT TO STOP AT EOF FOR +
         BAL   R8,READBLK               READ NEXT BLOCK
         CLI   IOERROR,YESSYN           WAS THERE AN I/O ERROR?
         BE    READY                    YES - CUT THIS OUT
         BCT   R3,RGOFORW               GO FORWARD
         B     READX                    WHEN DONE, DISPLAY IT
         EJECT
*
*  OFFSET IS NEGATIVE: READ BACKWARD ENOUGH TIMES
*
RGOBACK  LTR   R5,R5                    WAS ABSOLUTE ON THIS TRACK?
         BNP   RDOTRACK                 NO, BACK UP A TRACK
         STC   R5,TTR+2                 SET NEW RECORD
         B     READX                    AND READ IT
RDOTRACK LH    R0,TTR                   GET TRACK NUMBER
         BCTR  R0,0                     MINUS ONE
         LTR   R0,R0                    BACK TO ZERO?
         BNM   RCOUNT                   ITS GOOD, COUNT TRACK
         MVC   TTR(3),=X'000001'        BACKED UP TOO FAR
         BAL   R8,READBLK               POSITION IT AT 000001
         LA    R2,TTRSMALL              BACKED UP TOO FAR
         B     BOTCH                    TELL ALL ABOUT IT
RCOUNT   STH   R0,TTR                   SAVE FOR COUNT
         MVI   TTR+2,1                  IT WILL INCREMENT
         MVC   TEMP(3),TTR              SAVE TTR
         B     BCKCNT+4                 SKIP SEQUENTIAL FLAG FIRST TIME
*
BCKCNT   MVI   TTR+3,1                  ASK FOR NEXT BLOCK
         BAL   R8,READBLK               GET A BLK
         CLC   TEMP(2),TTR              STILL THIS TRACK?
         BNE   RNEWTRK                  NO
         CLI   IOERROR,YESSYN           I/O ERROR?
         BE    READY                    GET OUTA HERE
         MVC   TEMP+2(1),TTR+2          SAVE THIS RECORD
         B     BCKCNT                   CONTINUE DOWN TRACK
*
RNEWTRK  MVC   TTR(2),TEMP              RESTORE PREVIOUS TRACK
         XR    R1,R1                    CLEAR FOR PICKUP
         IC    R1,TEMP+2                GET NUMBER OF RECS
         AR    R5,R1                    WE NOW ARE THIS FAR BACK
         B     RGOBACK                  GO SEE IF ITS ON THIS TRK
         TITLE 'ZAP --- COMMAND EXECUTION --- L'
*
*****  L  *****
*
LOCATE   CLI   REALRDLN+1,X'01'         JUST L?
         BE    LGO                      YES - THEN HE WANTS CONTINUE
         LH    R3,REALRDLN              GET READ LEN
         BCTR  R3,0                     GET STRING LEN (-1 FOR 'L')
         LA    R4,TEMP2+1               PT TO STRING
         LA    R5,LOOKFOR               POINT TO STRING SAVEAREA
         BAL   R6,GETSTRNG              GET THE HEX OR CHAR STRING
         B     AROUND1
*
*  CONTINUE SCAN
*
LGO      LA    R2,NOOPERND              ASSUME OPERAND REQUIRED
         TM    CONTINUE,YESCONTL        CAN WE CONTINUE SCAN?
         BNO   BOTCH                    NO, SO HOW CAN HE CONTINUE?
         SR    R3,R3                    YES - CLEAR REG FOR IC
         IC    R3,LOOKFOR               GET THE SCAN LEN
         SR    R1,R1                    CLEAR REG FOR IC
         IC    R1,BITS                  GET LOW ORDER BITS OF ADDR
         LA    R1,1(R1)                 ADD 1 TO CONTIN WITH NEXT BYTE
*
*  SET UP SCAN
*
AROUND1  XR    R2,R2                    CLEAR REG FOR IC (WHAT ELSE?)
         IC    R2,LOOKFOR+1             GET 1ST CHAR TO FIND
         LA    R2,TEMPTRT(R2)           PT TO OFFSET IN TRTAB
         XC    TEMPTRT(256),TEMPTRT     CLEAR TRTAB
         MVI   0(R2),X'FF'              MOVE IN FF THERE
         OI    CONTINUE,YESCONTL        SAY HE CAN CONTINUE SCAN NOW
         CLI   REALRDLN+1,X'01'         JUST 1 READ ('L' CONTINUE)?
         BE    *+8                      YES - WE ALREADY HAVE OFFSET
         IC    R1,BITS                  NO - GET OFFSET INTO BLK
         A     R1,NOWBYTE2              ADD DISPLACEMENT TO IT
         B     LOOK8                    GO ON
         EJECT
*
*  BLOCK SCAN LOOP
*
LOOK7    SR    R1,R1                    RESET BUFFER PTR
LOOK8    A     R1,ADDRBUFF              PT TO OFFSET IN BUFFER
         BCTR  R1,0                     -1
         LH    R5,BLKLEN                GET BLK LENGTH
         A     R5,ADDRBUFF              PT TO END OF BLK
*
*  DO THE SCAN
*
LOOKLOOP TRT   1(256,R1),TEMPTRT        IS 1ST CHAR THERE?
         BZ    LOOK1                    NOT YET - KEEP TRYING
         CR    R1,R5                    YES - BUT IS IS PAST THE BLK?
         BNL   TOOFAR                   YES - SO GET A NEW ONE
SCANCLC  CLC   0(0,1),LOOKFOR+1         <<< EXECUTED >>>
         EX    R3,SCANCLC               NO - IS ALL OF IT THERE?
         BNE   LOOKLOOP                 NO - KEEP CHECKING
         MVC   GENERROR(40),SCANMTCH    YES - SCAN MATCH
         S     R1,ADDRBUFF              YES - GET WHERE IT IS AND...
         B     SETPOINT                 FAKE A '+' COMMAND TO IT
LOOK1    LA    R1,256(R1)               UPDATE TRT PTR TO BUFFER
         CR    R1,R5                    PAST BLK?
         BL    LOOKLOOP                 NO - KEEP SCANNING
         SPACE 1
TOOFAR   BAL   R8,CHKPT                 ANY ZAP NEEDED?
         MVI   TTR+3,1                  SET UP TO GO TO NEXT BLOCK
         BAL   R8,READBLK               GET ANOTHER BLK FOR SCANNING
         CLI   IOERROR,YESSYN           I/O ERROR?
         BE    READY                    YES - GET OUT
         B     LOOK7                    GO SCAN IT THEN
         TITLE 'ZAP --- COMMAND EXECUTION --- S, EX, O, N'
*
*****  N  *****
*
AND      LA    R2,ZAPNC                 PT TO THE RIGHT EXECUTED INSTR
         B     SXON                     GO DO IT
         SPACE 3
*
*****  O  *****
*
OR       LA    R2,ZAPOC                 PT TO THE RIGHT EXECUTED INSTR
         B     SXON                     GO DO IT
         SPACE 3
*
*****  EX  *****
*
EXOR     LA    R2,ZAPXC                 PT TO THE RIGHT EXECUTED INSTR
         LH    R1,REALRDLN              LENGTH OF OPERATION AND OPERAND
         BCTR  R1,0                       LESS ONE
         STH   R1,REALRDLN              BACK UP TO JUST "E"
         MVC   TEMP2+1(0),TEMP2+2       <<EXECUTED>>
         EX    R1,*-6                   SLIDE DOWN ONE POSITION
         B     SXON                     GO DO IT
         SPACE 3
*
*****  S  *****
*
STORE    LA    R2,ZAPMVC                PT TO THE RIGHT EXECUTED INSTR
         SPACE 3
*  ALLOW HIM TO USE PREVIOUS STRING IF HE JUST ENTERS THE COMMAND
*  WITH NO SUBSEQUENT STRING OPERAND.
         SPACE 5
SXON     ST    R2,0(,R13)               SAVE THE EX INSTR PTR
         CLI   REALRDLN+1,X'01'         LEN = 1, JUST 'S' ETC?
         BNE   SXONNEW#                 NO, USE SPECIFIED STRING
         SPACE 2
*  USE AN OLD STRING FOR S,EX,O,N WITH NO OPERANDS
         SPACE 1
         TM    CONTINUE,YESCONTS        JUST 'S'.  OLD STRING YET?
         BO    SXONNEW                  YES, GO ON
         LA    R2,NOOPERND              POINT TO MESSAGE
         B     BOTCH                    AND IGNORE COMMAND
         SPACE 2
*  USE SPECIFIED STRING
         SPACE 1
SXONNEW# LH    R3,REALRDLN              NO, GET LEN OF READ FOR STRING
         BCTR  R3,0                     -1 FOR COMMAND
         LA    R4,TEMP2+1               POINT TO STRING OPERAND
         LA    R5,ZAPSTRNG              POINT TO STRING WORK AREA
         BAL   R6,GETSTRNG              GET AL1(LEN),C'STRING'
         SPACE 1
*  AT THIS POINT, ZAPSTRNG CONTAINS THE INFO NECESSARY TO STORE:
*        AL1(STRING_LENGTH),C'STRING'
         SPACE 1
SXONNEW  OI    CONTINUE,YESCONTS        CAN DO 'SXON' WITH NO OPERANDS
         OC    BLKLEN(2),BLKLEN         ANYTHING TO CHANGE HERE?
         BNZ   OKSXON                   YES - CHANGE IT THEN
INVALCOM LA    R2,INVCOM                NO - PT TO MSG
         B     BOTCH                    AND TELL HIM
OKSXON   XR    R4,R4                    CLEAR REG FOR IC (STRING LEN)
         IC    R4,ZAPSTRNG              GET LEN
         LH    R5,OLDPOINT              PT TO ZAPPED OFFSET
*
*  CHECK TO SEE IF STRING WILL FIT IN THE REMAINING PART OF THE BLK
*  WHERE HE IS POINTING
*
         LH    R6,BLKLEN                GET LENGTH OF BLK
         SR    R6,R5                    GET LENGTH OF PIECE REMAINING
         LA    R2,LENERR                ASSUME IT WILL NOT FIT
         CR    R6,R4                    IS IT SMALLER THAN THE STRING?
         BNH   BOTCH                    NO, SO GO TELL HIM
         A     R5,ADDRBUFF              PT TO ACTUAL ZAPPED DATA
         OI    FLAGS2,MUSTZAP           BLK NEEDS A ZAP NOW
         L     R2,0(R13)                RESTORE EX INSTRUCTION PTR
         EX    R4,0(R2)                 MAKE THE APPROPRIATE CHANGE
         CLI   GODFLAG,GOD              UPDATE CAPABILITY?
         BE    READY                    YES, BRANCH
         LA    R2,STORMSG               NO UPDATE MESSAGE
         B     BOTCH                    GIVE IT TO HIM
         SPACE 2
ZAPMVC   MVC   0(0,R5),ZAPSTRNG+1       <<< EXECUTED >>>    'SET'
ZAPXC    XC    0(0,R5),ZAPSTRNG+1       <<< EXECUTED >>>    'EX'
ZAPOC    OC    0(0,R5),ZAPSTRNG+1       <<< EXECUTED >>>    'O'
ZAPNC    NC    0(0,R5),ZAPSTRNG+1       <<< EXECUTED >>>    'N'
         TITLE 'ZAP --- COMMAND EXECUTION --- SET'
*
*  *****  SET  *****
*
SET      CLI   REALRDLN+1,X'03'         JUST SET, NO STRING?
         BNE   SETNEW#                  NO, USE SPECIFIED STRING
         SPACE 1
*  USE OLD STRING FOR SET NO OPERANDS
         SPACE 1
         TM    CONTINUE,YESCONTT        IS THERE AN OLD ONE TO USE?
         BO    SETNEW                   YES, GO ON WITH OLD STRING
         LA    R2,NOOPERND              POINT TO MSG
         B     BOTCH                    INVALID SYNTAX COL 4
         SPACE 2
*  USE SPECIFIED STRING
         SPACE 1
SETNEW#  LH    R3,REALRDLN              NO, LET READ LEN
         SH    R3,=H'3'                 -3 FOR 'SET'
         LA    R4,TEMP2+3               POINT TO THE STRING OPERAND
         LA    R5,SETSTR                WHERE TO SAVE THE INFO
         BAL   R6,GETSTRNG              GET AL1(LEN),C'STRING'
         SPACE 2
*  NOW SETSTR CONTAINS:
*        AL1(SET_LEN),C'SET_STRING'
         SPACE 1
SETNEW   OI    CONTINUE,YESCONTT        CAN DO SET WITH NO OPERANDS
         OC    BLKLEN(2),BLKLEN         IS THERE ANYTHING TO SET?
         BZ    INVALCOM                 NO - SO DON'T AND TELL HIM
         XR    R4,R4                    CLEAR FOR IC
         IC    R4,SETSTR                GET BCTR'D STRING LEN
         LH    R5,OLDPOINT              POINT TO ZAPPED OFFSET
         LH    R6,BLKLEN                CURRENT BLOCK LENGTH
         SR    R6,R5                    LENGTH OF REMAINING PIECE
         LA    R2,LENERR                ASSUME IT DOES NOT FIT
         CR    R6,R4                    CORRECT?
         BNH   BOTCH                    YES, ERROR
         OI    FLAGS2,MUSTZAP           BLK NEEDS A ZAP NOW
         L     R5,ADDRBUFF              POINT TO BUFFER
         AH    R5,OLDPOINT                 AND ZAP START ADDRESS
         XR    R8,R8                    CLEAR REM REG FOR DIVIDE
         LR    R9,R6                    LENGTH OF PIECE TO ZAP
         LA    R1,1(R4)                 GET REAL STRING LENGTH
         DR    R8,R1                    HOW MANY STRINGS FIT IN PIECE?
         LTR   R9,R9                    BLK SHORTER THAN STRING?
         BZ    JUSTSPEW                 YES - JUST MOVE IN REMAINDER
*  R9 HAS BCT COUNT OF HOW MANY STRINGS CAN FIT IN THIS
*  PARTICULAR BLK, WHILE R8 HAS THE LENGTH OF THE PIECE LEFT OVER.
SETLOOP  EX    R4,SETMVC                MOVE 1 STRING IN
         LA    R5,1(R4,R5)              UPDATE BUFFER PTR FOR NEXT
         BCT   R9,SETLOOP               FILL AS MUCH OF BUFFER AS CAN
JUSTSPEW LTR   R8,R8                    IS THERE A SMALL PIECE LEFT?
         BZ    SETDONE                  NO - WE ARE ALL DONE
         BCTR  R8,0                     YES - GET EXECUTE LEN
         EX    R8,SETMVC                MOVE AS MUCH AS WILL FIT IN
SETDONE  CLI   GODFLAG,GOD              UPDATE CAPABILITY?
         BE    READY                    YES, BRANCH
         LA    R2,STORMSG               NO, WARN HIM ABOUT NO UPDATE
         B     BOTCH                    AND GO DISPLAY
         SPACE 1
SETMVC   MVC   0(0,R5),SETSTR+1         <<< EXECUTED >>>
         TITLE 'ZAP --- COMMAND EXECUTION --- X (EXIT FOR PCF)'
*
* ***** CALL IKJSCAN ONLY TO ALLOW COMMAND EXIT FOR PCF
*
X        MVC   TEMP3+6(38),TEMP2+1      CREATE
         MVC   TEMP3+4(2),=C'X '              A
         LH    R1,REALRDLN                     TEMPORARY
         AH    R1,=H'5'                                 COMMAND
         STH   R1,TEMP3                                        BUFFER
         XC    TEMP3+2(2),TEMP3+2
         LA    R1,TEMP3
         ST    R1,CSPLCBUF              POINT TO THE COMMAND BUFFER
         CLI   IKJSCAN,X'FF'            IKJSCAN LOADED?
         BNE   SCANLOAD                 YES, BRANCH
         LOAD  EP=IKJSCAN               GET ITS ADDRESS
         ST    R0,IKJSCAN                  AND SAVE FOR LATER
SCANLOAD L     R15,IKJSCAN
         LA    R1,CSPL                 COMMAND SCAN AREA ADDRESS
         BALR  R14,R15                 CALL IKJSCAN
         TM    CSOAFLG,CSOANOC         DID COMMAND EXIT FIND A COMMAND?
         BO    BOTCH2                  YES, NO MESSAGE
         LA    R2,NOSUCH               NO, SAY NO SUCH COMMAND
         B     BOTCH
         TITLE 'ZAP --- COMMAND EXECUTION --- ZAP/SAVE'
*
*****  ZAP/SAVE  *****
*
REPLACE  CLI   IOERROR,YESSYN           WAS THERE AN I/O ERROR ON BLK?
         BE    WRTNONO                  YES - CAN'T ZAP THAT
         OC    BLKLEN(2),BLKLEN         NO - BUT IS THERE A BLK TO ZAP?
         BZ    WRTNONO                  NO - SO DON'T ZAP ALREADY
         CLI   GODFLAG,NOGOD            CAN THIS GUY WRITE?
         BE    WRTNONO                  NO - TOUGH BEANS FOR HIM
         BAL   R8,WRITE                 WRITE THE BUFFER OUT
         CLI   IOERROR,YESSYN           I/O ERROR?
         BE    READY                    YES - IGNORE TELLING HIM OK
         NI    FLAGS2,255-MUSTZAP       BLK NO LONGER NEEDS ZAP
         SPACE 2
*  UPDATE THE IDR IF APPLICABLE
*  IDR FOR SUPERZAP (AND THEREFORE ZAP) TAKES THE FOLLOWING FORM:
*        BYTE  0.....'80' FOR ID
*        BYTE  1.....LENGTH OF IDR (USUALLY X'FA' = 250.)
*        BYTE  2.....WHO'S IDR IT IS (X'01' FOR SUPERZAP AND ZAP)
*        BYTE  3.....NUMBER OF 13-BYTE IDR DATA ENTRIES (BITS 2-7)
*        BYTES 4-16, 17-29,... IDR DATA ENTRY AS FOLLOWS:
*              BYTES 0-1 --- ESD ID (DEFAULT 1)
*              BYTES 2-4 --- DATE ('YYDDDF')
*              BYTES 5-12 -- INFO ('USERID' WHERE USERID=TSO USERID)
         SPACE 2
         CLI   DSORG,DCBDSGPO           IS THIS A PDS?
         BNE   FINZAP                   NO - FORGET THE IDR
         CLI   DCBRECFM-IHADCB+DCBU,DCBRECU  IS THIS A LIBRARY?
         BNE   FINZAP                   NO - DON'T UPDATE THE 'IDR'
         CLI   IDRFLAG,CHGIDR           ALREADY UPDATED THIS IDR
         BE    FINZAP                   YES - DON'T DO IT AGAIN NOW
         MVC   0(3,R13),TTR             LET'S SAVE WHERE HE WAS FIRST
         OC    MEMTTR(3),MEMTTR         WAS THERE A 'M' COMMAND?
         BZ    ENDIDR                   NO - FORGET IT
         MVC   TTR(3),MEMTTR            PICK UP MEMBER PTR
         BAL   R8,READBLK               READ 1ST BLK OF MEMBER
         SPACE 1
IDRFIND  L     R1,ADDRBUFF              GET BUFFER PTR
         TM    0(R1),X'01'              CONTROL RECORD OF SOME SORT?
         BO    ENDIDR                   YES - WE ARE ALL DONE LOOKING
         CLI   0(R1),X'80'              IDR?
         BNE   NEWBLK                   NO - GET ANOTHER BLK
         TM    2(R1),X'01'              YES - BUT DONE BY SUPERZAP?
         BNO   NEWBLK                   NO - FORGET THIS ONE
         XR    R2,R2                    CLEAR WORK REG
         IC    R2,3(R1)                 PICK UP # OF IDR DATA ENTRIES
         LR    R4,R2                    SAVE IT FOR LATER
         N     R2,=XL4'0000003F'        WE JUST WANT BITS 2-7
         MH    R2,=H'13'                EACH ENTRY IS 13 BYTES LONG
         LA    R2,3(R2)                 IDR HDR IS 3 BYTES LONG
*  SO NOW R2 HAS AN OFFSET TO THE NEXT AVAILABLE POSITION IN THE IDR
         XR    R3,R3                    CLEAR WORK REG
         IC    R3,1(R1)                 PICK UP IDR LENGTH
         CR    R3,R2                    ARE WE AT END OF IDR?
         BH    UPDATIDR                 NO - SO UPDATE THE IDR
*
NEWBLK   MVI   TTR+3,1                  SAY SEQUENTIAL READ
         MVI   EOFRET,NOEOF             TREAT EOF'S AS DATA BLKS
         BAL   R8,READBLK               READ ON ANOTHER BLK
         CLC   EOFIOERR(20),EOFMSG      DID I HIT END OF FILE?
         BE    ENDIDR                   YES - STOP THIS STUPID THING
         CLI   IOERROR,YESSYN           I/O ERROR?
         BE    ENDIDR                   YES - LEAVE
         B     IDRFIND                  NO - CHECK THIS BLK
*
UPDATIDR AR    R2,R1                    R2 PTS TO NEXT IDR SPOT
         LA    R4,1(R4)                 INCREMENT # OF IDR ENTRIES...
         STC   R4,3(R1)                 AND PUT IT BACK
         MVC   1(2,R2),ESDID            MOVE IN ESDID (IF ANY)
*
         TIME  ,                        GET THE DATE IN R1
*
         ST    R1,DBLW                  SAVE IT IN TEMP WORD
         MVC   3(3,R2),DBLW+1           MOVE YYDDDF TO IDR
         MVC   6(8,R2),CSINIT           THE LOGON USERID OF THE GUY
         BAL   R8,WRITE                 GO WRITE THE RECORD BACK
         CLI   IOERROR,YESSYN           I/O ERROR?
         BE    ENDIDR                   YES - SAY WE DIDN'T UPDATE
         MVI   IDRFLAG,CHGIDR           NO - SO WE DID UPDATE THE IDR
         SPACE 1
ENDIDR   DS    0H
         CLC   TTR(3),0(R13)            HAS HE MOVED ANY?
         BE    FINZAP                   YES - DON'T BOTHER PUTTING BACK
         MVC   TTR(3),0(R13)            LET'S PUT HIM BACK WHERE HE WAS
         BAL   R8,READBLK               HE'LL NEVER KNOW WHAT HAPPENED
FINZAP   MVC   GENERROR(40),WRITEOK     TELL HIM THE ZAP WORKED OK
         B     READY                    YES - DISPLAY WITH NO TRACE
WRTNONO  LA    R2,WRITERR               TELL HIM WRITE NOT ALLOWED
         B     BOTCH                    AND DISPLAY
         TITLE 'ZAP --- COMMAND EXECUTION --- #'
*
*****  # (CALC)  *****
*
CALC     LH    R0,REALRDLN              GET LEN OF READ
         BCTR  R0,0                     -1 FOR '#' = EXPRESS LEN
         XR    R15,R15                  GET '*' = 0
         LA    R1,TEMP2+1               PT TO THE EXPRESSION
         MVI   EXPOPT,YESSYMB           TELL HIM SCAN SYMB TAB
         BAL   R14,EXP                  GO PARSE IT OUT
         LTR   R1,R1                    OK?
         BNM   INVEXPER                 NO - BOTCH UP
         MVC   GENERROR(20),CALCMSG     YES - MOVE IN MASK
         CVD   R15,TEMP                 GET THE RESULT
         LA    R1,GENERROR+28           INITIALIZE LOC FOR FLOAT SIGN
         MVC   GENERROR+17(12),EDMASK   MOVE IN EDMASK
         EDMK  GENERROR+17(12),TEMP+2   EDIT IT
         TM    TEMP+7,X'0D'             WAS IT NEGATIVE?
         BNO   POSCALC                  NO - FORGET THE SIGN
         BCTR  R1,0                     PT TO WHERE SIGN SHOULD GO
         MVI   0(R1),C'-'               MOVE IT IN
POSCALC  ST    R15,TEMP                 PUT NUMBER TO WORK AREA
         UNPK  TEMP2(9),TEMP(5)         STRETCH IT OUT
         TR    TEMP2(8),TRHEX           MAKE IT HEX CHARS
         MVC   GENERROR+31(8),TEMP2     MOVE IT TO SCREEN
         B     BOTCH2                   GIVE IT TO HIM
         TITLE 'ZAP --- COMMAND EXECUTION --- DISASM'
*
*****  DISASM
*
DIS      LA    R1,TEMP2+3               PT TO OP
         B     DISASM+4                 SKIP NEXT INSTRUCTION
DISASM   LA    R1,TEMP2+6               PT TO OP
         MVI   TRACE,NOTRACE            DO NOT TRACE THIS
         SR    R15,R15                  CURR RELATIVE TO ZERO
         MVI   EXPOPT,YESSYMB           WANT SYM TAB LOOKUP
         BAL   R14,EXP                  PARSE
         LTR   R1,R1                    WORK?
         BNM   INVEXPER                 NO
         LTR   R3,R15                   OUTPUT LINES:
         BM    INVEXPER                    NEGATIVE -- INVALID
         BP    *+8                         POSITIVE -- GOOD
         LA    R3,1                        ZERO -- USE 1 INSTEAD
         LA    R0,SCRLINES              MAXIMUM LINES ALLOWED
         CR    R3,R0                    FIT ON MAXIMUM ALLOWED SCREEN?
         BNH   *+6                      YES, BRANCH
         LR    R3,R0                    NO, USE THE MAXIMUM
         BAL   R8,CLEAR                 CLEAR SCREEN FOR DISASM OUTPUT
         LH    R4,OLDPOINT              START AT CURRENT OFFSET
         LA    R8,SCREEN+0              OUTPUT START LINE
         LH    R9,BLKLEN                GET LENGTH BLK
         SH    R9,=H'2'                 LAST POSSIBLE INSTRUCTION
         LA    R2,PASTBUF               BEYOND END OF BUFFER MESSAGE
         CR    R4,R9                    PAST END OF BLK?
         BH    BOTCH                    YES, DON'T START
DISLOOP  LR    R15,R4                   CURRENT POSITION IN BUFFER
         CR    R15,R9                   PAST END OF BLK?
         BH    DISPLAY                  YES, DISPLAY WHAT WE HAVE
         ST    R4,TEMP                  SAVE FOR DISPLAY
         UNPK  0(7,R8),TEMP+1(4)        SPREAD OUT THE DIGITS
         TR    0(6,R8),TRHEX            MAKE THEM HEX
         MVI   7(R8),X'40'              BLANK THE LAST DIGIT
         A     R15,ADDRBUFF             GET ADDR IN BUFFER
         LNR   R1,R15                   NEGATIVE FOR 'DISASM'
         LA    R0,12(,R8)               GIVE HIM 27 BYTES TO WORK WITH
         LA    R2,TEMP2                 GIVE HIM SOME WORKAREA TOO
         L     R15,=V(ASMZASM)          POINT TO 'ASSEMBLER' HAR HAR
         BALR  R14,R15                  DISASSEMBLE IT
         AR    R4,R1                    ADD LENGTH OF DISASSEMBLED CODE
         LA    R8,40(,R8)               NEXT SCREEN LINE
         BCT   R3,DISLOOP               DO AS MANY LINES AS REQUIRED
         B     DISPLAY                  GO DISPLAY THE SCREEN
         TITLE 'ZAP --- COMMAND EXECUTION --- ASM,  ?  AND  WHERE'
*
*****  ASM
*
ASM      CLI   REALRDLN+1,3             NO OP?
         LA    R1,TEMP2+3               BAD COL IF NOT, SET PARM TOO
         BNH   INVEXPER                 NASTY
         LA    R0,GENERROR+7            33 BYTES TO WORK WITH
         LA    R2,TEMP2                 WORKAREA
         L     R15,=V(ASMZASM)          PT TO SUB
         BALR  R14,R15                  GET OBJECT
         LA    R2,INVOPCOD              ASSUME NO
         BXH   R15,R15,BOTCH
         B     BOTCH2                   SHOW IT
         SPACE 3
*
*****  ?   (SHORT HELP FOR NAMES OF SUBCOMMANDS)
*
OP       MVI   TRACE,NOTRACE            DON'T TRACE
         BAL   R8,CLEAR                 CLEAR SCREEN
         MVC   SCREEN+160(240),OPERANDS MOVE FORMAT LINES TO SCREEN
         B     DISPLAY                  SHOW IT OFF
         SPACE 3
*****  WHERE
*
WHERE    MVI   TRACE,NOTRACE            DON'T TRACE
         BAL   R8,CLEAR                 CLEAR SCREEN
         BAL   R8,WHEREAMI              FORMAT LINE
         B     DISPLAY                  SHOW IT OFF
         TITLE 'ZAP --- COMMAND EXECUTION -- DCB'
*
*****  DCB
*
*   OUTPUT FORMAT:
*   DCB=(DSORG=PSU,KEYLEN=123,OPTCD=WUCOZT,
*     RECFM=VBSTA,LRECL=12345,BLKSIZE=12345),
*     VOL=SER=123456
*   123456789012345678901234567890123456789012
*
DCB      MVI   TRACE,NOTRACE            DONT TRACE
         BAL   R8,CLEAR                 CLEAR SCREEN
         LA    R1,SCREEN+280            OUTPUT START ADDRESS
         MVC   0(13,R1),=CL13'DCB=(DSORG=??'
         LA    R1,11(,R1)
         TM    DSORG,DCBDSGPS   PS?
         BNO   *+10             NO, BRANCH
         MVC   0(2,R1),=C'PS'
         TM    DSORG,DCBDSGPO   PO?
         BNO   *+10             NO, BRANCH
         MVC   0(2,R1),=C'PO'
         TM    DSORG,DCBDSGDA   DA?
         BNO   *+10             NO, BRANCH
         MVC   0(2,R1),=C'DA'
         TM    DSORG,DCBDSGIS   IS?
         BNO   *+10             NO, BRANCH
         MVC   0(2,R1),=C'IS'
         TM    DSORG,DCBDSGU    UNMOVEABLE?
         BNO   *+12             NO, BRANCH
         MVI   2(R1),C'U'
         LA    R1,1(,R1)
         MVC   2(8,R1),=C',KEYLEN='
         LA    R1,10(,R1)
         LH    R15,KEYLEN
         CVD   R15,DOUBLW
         UNPK  DOUBLW(5),DOUBLW+5(3)
         LA    R15,DOUBLW-1
         LA    R15,1(,R15)        SCAN
         CLI   0(R15),C'0'            PAST LAST
         BE    *-8                             LEADING ZERO
         OI    DOUBLW+4,X'F0'
KEYLENAA MVC   0(1,R1),0(R15)     MOVE IN EACH CHARACTER
         LA    R1,1(,R1)
         LA    R15,1(,R15)
         TM    0(R15),X'F0'       NEXT CHARACTER NUMERIC?
         BO    KEYLENAA           NO, LOOP
         LA    R2,=CL8' TZ OCUW'
         TM    DSORG,DCBDSGPO+DCBDSGPS    PARTITIONED OR SEQUENTIAL?
         BM    OPTCDAA                    YES, BRANCH
         LA    R2,=CL8'RL YIM W'
         TM    DSORG,DCBDSGIS             ISAM DATA SET?
         BO    OPTCDAA                    YES, BRANCH
         LA    R2,=CL8'R  AFETW'
         TM    DSORG,DCBDSGDA             DIRECT ACCESS DATA SET?
         BNO   NOOPTCD                    NO, I DON'T KNOW THEN
OPTCDAA  MVC   0(7,R1),=C',OPTCD='
         LA    R1,7(,R1)                  POINT AFTER OPTCD=
         LM    R14,R15,0(R2)              USE REGISTERS R14 AND R15
         LA    R0,8                       SHIFT LOOP COUNTER
         LA    R2,X'80'                   HIGH-ORDER BIT
         TM    OPTCD,*-*                  <<EXECUTED>>
OPTCDBB  EX    R2,*-4                     THIS BIT ON?
         BNO   OPTCDCC                    NO, BRANCH
         STC   R15,0(,R1)                 YES, SAVE A CHARACTER
         CLI   0(R1),X'40'                LEGAL CHARACTER FOR DSORG?
         BE    OPTCDCC                    NO, SKIP INCREMENT
         LA    R1,1(,R1)
OPTCDCC  SRDL  R14,8                      NEXT CHARACTER
         SRL   R2,1                       NEXT BIT MASK
         BCT   R0,OPTCDBB                 DO ALL EIGHT BITS
NOOPTCD  MVI   0(R1),C','                 ADD A FOLLOWING COMMA
*
         LA    R1,SCREEN+320              *** NEXT LINE
         MVC   2(7,R1),=C'RECFM=*'
         LA    R1,8(,R1)
         TM    RECFM,DCBRECU    RECFM=U?
         BNO   *+12             NO, BRANCH
         MVI   0(R1),C'U'
         B     RECFMAA
         TM    RECFM,DCBRECF    RECFM=F?
         BNO   *+12             NO, BRANCH
         MVI   0(R1),C'F'
         B     RECFMAA
         TM    RECFM,DCBRECV    RECFM=V?
         BNO   *+8              NO, BRANCH
         MVI   0(R1),C'V'
RECFMAA  LA    R1,1(,R1)
         TM    RECFM,DCBRECBR   RECFM=.B?
         BNO   *+12             NO, BRANCH
         MVI   0(R1),C'B'
         LA    R1,1(,R1)
         TM    RECFM,DCBRECSB   RECFM=.S?
         BNO   *+12             NO, BRANCH
         MVI   0(R1),C'S'
         LA    R1,1(,R1)
         TM    RECFM,DCBRECTO   RECFM=.T?
         BNO   *+12             NO, BRANCH
         MVI   0(R1),C'T'
         LA    R1,1(,R1)
         TM    RECFM,DCBRECCA   RECFM=.A?
         BNO   *+12             NO, BRANCH
         MVI   0(R1),C'A'
         LA    R1,1(,R1)
         TM    RECFM,DCBRECCM   RECFM=.M?
         BNO   *+12             NO, BRANCH
         MVI   0(R1),C'M'
         LA    R1,1(,R1)
         TM    RECFM,DCBRECU    RECFM=U?
         BO    BLKSIZAA         YES, NO LRECL MESSAGE
         MVC   0(7,R1),=CL7',LRECL='
         LA    R1,7(,R1)
         LH    R15,LRECL
         CVD   R15,DOUBLW
         UNPK  DOUBLW(5),DOUBLW+5(3)
         LA    R15,DOUBLW-1
         LA    R15,1(,R15)      SCAN
         CLI   0(R15),C'0'          PAST LAST
         BE    *-8                           LEADING ZERO
         OI    DOUBLW+4,X'F0'
LRECLAA  MVC   0(1,R1),0(R15)   MOVE IN EACH CHARACTER
         LA    R1,1(,R1)
         LA    R15,1(,R15)
         TM    0(R15),X'F0'     NEXT CHARACTER NUMERIC?
         BO    LRECLAA          NO, BRANCH
BLKSIZAA MVC   0(9,R1),=CL9',BLKSIZE='
         LA    R1,9(,R1)
         LH    R15,BLKSIZE
         CVD   R15,DOUBLW
         UNPK  DOUBLW(5),DOUBLW+5(3)
         LA    R15,DOUBLW-1
         LA    R15,1(,R15)      SCAN
         CLI   0(R15),C'0'          PAST LAST
         BE    *-8                           LEADING ZERO
         OI    DOUBLW+4,X'F0'
BLKSIZBB MVC   0(1,R1),0(R15)   MOVE IN EACH CHARACTER
         LA    R1,1(,R1)
         LA    R15,1(,R15)
         TM    0(R15),X'F0'     NEXT CHARACTER NUMERIC?
         BO    BLKSIZBB         NO, BRANCH
         MVC   0(2,R1),=C'),'
*
         LA    R1,SCREEN+360            *****  LAST LINE
         MVC   2(8,R1),=C'VOL=SER='
         MVC   10(6,R1),VOLSER
         B     DISPLAY
 TITLE 'ZAP --- COMMAND EXECUTION --- W (WINDOW), WFULL, WHALF'
*
*****  W   (WINDOW)       SYNTAX:  W <DOWN>,<UP>
*
WINDOW   LH    R0,REALRDLN              LENGTH
         SH    R0,=H'1'                 NO 'W'
         BP    OKWIND                   OK
         XC    WIDTHS(4+4),WIDTHS       ONLY 'W', SET DEFAULTS
         B     READY                    AND QUIT
WHALF    LA    R5,SCRLINES/4     ****   HALF WINDOW SPECIFIED
         LR    R6,R5                    SAME FOR <UP> TOO
         B     WINDSAVE                 SKIP FIRST LOAD ADDRESS
WFULL    LA    R5,SCRLINES/2     ****   FULL WINDOW SPECIFIED
         LA    R6,SCRLINES/2-1          ONE LESS FOR UP LINES
         B     WINDSAVE                 WE ARE DONE
OKWIND   LM    R5,R6,WIDTHS             ASSUME WINDOW=CURR WINDOW
         LR    R2,R0                    SAVE LEN OP(S)
         LA    R1,TEMP2+1               PT TO THEM
         LA    R8,(SCRLINES-1)/2        MAXIMUM ALLOWED <UP> OR <DOWN>
         LR    R3,R1                    SAVE FOR LATER
WINDLOOP CLI   0(R3),C','               END 1ST OP?
         LA    R3,1(,R3)                ASSUME YES
         BE    WINDGOT                  RIGHT, DO 1ST
         BCT   R2,WINDLOOP              TRY TRY
         SPACE 1
WINDGOT  SR    R0,R2                    LEN 1ST
         LTR   R0,R0                    ANY?
         BZ    WIND2                    NO, DO 2ND
         XR    R15,R15                  YES, *=0
         BAL   R14,EXP                  PARSE, R1 SET
         LTR   R1,R1                    WORK?
         BNM   INVEXPER                 NO
         LTR   R5,R15                   NEG <DOWN>?
         BM    INVEXPER                 YES
         CR    R5,R8                    TOO BIG?
         BNH   WIND2                    NO, BRANCH
         LR    R5,R8                    YES, USE MAXIMUM <DOWN>
         SPACE 1
WIND2    LR    R0,R2                    LEN LEFT = LEN 2ND (ALMOST)
         SH    R0,=H'1'                 -1 FOR COMMA (IF ANY)
         BNP   WINDSAVE                 NO 2ND OP, LEAVE ALONE
         LR    R1,R3                    SET OP PTR FOR EXP
         XR    R15,R15                  *=0
         BAL   R14,EXP                  GO PARSE 2
         LTR   R1,R1                    WORK?
         BNM   INVEXPER                 NO
         LTR   R6,R15                   NEG <UP>?
         BM    INVEXPER                 YES
         CR    R6,R8                    TOO BIG?
         BNH   WINDSAVE                 NO, BRANCH
         LR    R6,R8                    YES, USE MAXIMUM <UP>
         SPACE 1
WINDSAVE STM   R5,R6,WIDTHS             SAVE THE 2 WIDTHS
         B     READY
         TITLE 'ZAP --- COMMAND EXECUTION --- FLOAT'
*
*****  FLOAT
*
*  (ORIGINAL INTX SVCX 6 CODE WRITTEN BY STEVE SILVER.  MODIFIED
*   FOR ZAP USE BY JCJ AND VIC - IE:  WE DON'T UNDERSTAND)
         SPACE 1
FLOAT    LH    R2,REALRDLN              GET THE READ LEN
         SH    R2,=H'6'                 GET EXECUTE LENGTH
         BM    FLOAT#                   YES - NULL OPERAND, MAKE IT 0
         CH    R2,=H'15'                WAS THE OPERAND TOO LONG?
         BH    LENERROR                 YES - TELL HIM AND QUIT
         LA    R1,1(R2)                 PICK UP LENGTH OF STRING
         LA    R9,TEMP2+5               POINT TO THE STRING
         BAL   R8,HEXCHECK              IS IT VALID HEX?
         B     OKFLOAT                  YES - SO LET'S DO IT
         LR    R1,R9                    NO - POINT TO THE ERROR
         B     INVEXPER                 AND SAY SYNTAX ERROR
OKFLOAT  EX    R2,TRFLOAT               START TRANSLATE TO REAL HEX
FLOAT#   PACK  TEMP(8),TEMP2+5(15)      MAKE IT HONEST-TO-GOODNESS HEX
         MVN   TEMP+7(1),TEMP2+20       GET THE LAST NIBBLE TOO
         LD    F0,TEMP                  LOAD IT IN FLOAT REG 0
         LA    R9,GENERROR+19           PT TO START OF SCRN RESULT AREA
         SPACE 2
*  SET THE PROGRAM MASK TO MASK OUT FIX PT OFLO, DEC OFLO,
*  EXPON UNFLO, AND SIGNIFICANCE.  SAVE IT IN R6 TO RESET IT LATER.
         SPACE 1
         XR    R2,R2                    0 R2 FOR SPM
         BALR  R6,0                     SAVE PGM MASK FOR RESTORE
         SPM   R2                       0 THE PGM MASK (NO INTERR)
         SPACE 1
         MVI   16(R9),C'0'              ASSUME ANSWER IS 0
         XC    TEMP(8),TEMP             MAKE A DC D'0' THE CHEAP WAY
         AD    F0,TEMP                  NORMALIZE BY ADDING 0
         LTDR  F0,F0                    CHECK THE SIGN
         BZ    CVFCI3                   ZERO (WE'RE ALMOST DONE)
         BP    CVFC00                   PLUS - GO ON
         LPDR  F0,F0                    MINUS - MAKE IT PLUS...
         MVI   0(R9),C'-'               INSERT SIGN AND GO ON LIKE PLUS
CVFC00   LA    R9,1(R9)                 UPDATE OUTPUT PTR EITHER CASE
         CD    F0,EXPOVFLW              DATA WILL CAUSE EXP OVERFLOW?
         BNH   *+8                      NO - SKIP PREVENT LOAD
         LD    F0,EXPOVFLW              ELSE GET MAX ALLOWABLE
* MAX ALLOWABLE IS X'7FFFFFFFFFFFFF00'
         MD    F0,CVFCFUDG              MULT BY FUDGE FACTOR
         EJECT
*
*  GENERATE THE NUMBER IN D-FORMAT
*
         SPACE 2
         XR    R2,R2                    INITIALIZE EXPON REG
         LD    F4,=D'10'                SET F4 TO 10
         LD    F6,=D'1'                 SET F6 TO 1
         LD    F2,CVDPFTH               SET F2 TO .1
         MVI   0(R9),C'.'               SET UP OUTPUT
         LA    R9,1(R9)                 INCREMENT LINE POINTER
         MVI   14(R9),C'D'              FORM THE OUTLINE OF EXPONENT
         MVI   15(R9),C'+'              MOVE IN EXPONENT SIGN
*  GET THE EXPONENT IN R2 (>=1)
CVFC1A   CDR   F0,F6                    SEE IF # < 1
         BL    CVFC2                    IF SO, GO TO NEXT PART
         DDR   F0,F4                    NO - DIVIDE BY 10
         LA    R2,1(R2)                 INCREMENT EXPONENT
         B     CVFC1A                   CONTINUE
*  GET THE EXPONENT (<.1)
CVFC2    CDR   F0,F2                    SEE IF >= .1
         BNL   CVFC3                    IF SO, GO TO NEXT PART
         BCTR  R2,0                     DECREMENT EXPONENT
         MDR   F0,F4                    MULT NUMBER BY 10
         B     CVFC2                    CONTINUE
*  GET EXPONENT SIGN
CVFC3    LTR   R2,R2                    SEE IF EXPONENT +
         BNM   CVFC3A                   IF SO, SKIP CODE
         LPR   R2,R2                    MAKE IT PLUS BUT.....
         MVI   15(R9),C'-'              WRITE OUT A MINUS
CVFC3A   LA    R0,10                    DIVISER FOR BELOW
         SRDL  R2,32                    SET UP FOR DIVIDE
         DR    R2,R0                    DO THE DIVIDE
         LA    R2,C'0'(R2)              GET THE EBCDIC VALUE
         LA    R3,C'0'(R3)              GET THE EBCDIC VALUE
         STC   R2,17(R9)                AND STORE IT
         STC   R3,16(R9)                AND STORE IT
         LA    R0,14                    GET NUMBER OF DIGITS FOR BCT
         LD    F6,CVFCWZ                LOAD F6 WITH UN-NORMALIZER
*  GET THE MANTISSA
CVFC4    MDR   F0,F4                    MULT NUMBER BY 10
         AWR   F0,F6                    UN-NORMALIZE
         STD   F0,TEMP                  STORE RESULT
         SR    R4,R4                    ZERO FOR IC
         IC    R4,TEMP+1                GET FIRST HEX DIGIT
         SRA   R4,4                     KILL LOW NIBBLE (LAST HEX DIG)
         LA    R3,C'0'(R4)              CONVERT TO CHAR
         STC   R3,0(R9)                 MOVE RESULT TO OUTPUT
         XC    TEMP(8),TEMP             SET UP DBLW
         LA    R9,1(R9)                 POINT TO NEXT OUTPUT COL
         LTR   R4,R4                    IS R4 0?
         BZ    CVFC4#                   YES - WE HAVE NOTHING TO DO
         MVI   TEMP,X'41'               MAKE DBLW INTERNAL FLOATING PT
         SLL   R4,4                     MOVE NUMBER TO HIGH ORDR NIBBLE
         STC   R4,TEMP+1                AND MOVE IT TO DBLW
*
*  WE HAVE NOW BUILT A DBLW WHICH MAY CONTAIN D'0' THROUGH D'10'
*
         SD    F0,TEMP                  SUBTRACT THE INTEGER PART
CVFC4#   BCT   R0,CVFC4                 DO TILL END
         B     CVFCI3                   CLEAN UP AND GO AWAY
         SPACE 4
*  IF NUMBER IS ZERO TO BEGIN WITH, THERE'S NOTHING TO DO BUT.......
         SPACE 1
         MVI   16(R9),C'0'              SET UP ZERO RESULT
         SPACE 2
*  RESTORE PROGRAM MASK TO WHAT IT WAS
         SPACE 2
CVFCI3   SPM   R6                       RESET PROGRAM MASK
         SPACE 2
         MVC   GENERROR(15),FLOATMSG    PUT IN CL15'FLOATING POINT:'
         B     BOTCH2                   DISPLAY IT
TRFLOAT  TR    TEMP2+5(0),TRHEXX        <<< EXECUTED >>>
         TITLE 'ZAP --- COMMAND EXECUTION --- M'
*
*****  M  *****
*
MEMBER#  BAL   R8,CHKPT                 NEED ZAP?
         LA    R2,NOMCOM                ASSUME NOT PARTITIONED
         TM    DSORG,DCBDSGPO           CORRECT?
         BNO   BOTCH                    YES, RAISE HELL
OKDSORG  MVC   0(3,R13),TTR             SAVE TTR IN CASE NO FIND
         MVC   TTR(3),=X'000001'        POINT TO DIRECTORY START
         LH    R1,REALRDLN              YES - GET READLEN
         SH    R1,=H'2'                 GET EX LENGTH -- ANY NAME?
         BNM   GETMEMB                  YES, BRANCH
         OC    MEMTTR(3),MEMTTR         ANY PREVIOUS TTR?
         BNZ   ZMEMTTR                  YES, BRANCH
         MVI   IDRFLAG,NOCHGIDR         WE HAVEN'T CHANGED IDR HERE YET
         CLI   MEMBER,0                 PREVIOUS MEMBER NAME
         BE    JUSTP                    NO, USE THE START OF DIRECTORY
         B     MLOOP#                   YES, LOOK FOR IT AGAIN
ZMEMTTR  MVC   TTR(3),MEMTTR            USE THE TTR FOR THIS MEMBER
         B     READX                    AND START THERE
         SPACE 1
GETMEMB  MVI   IDRFLAG,NOCHGIDR         WE HAVEN'T CHANGED IDR HERE YET
         MVC   MEMBER(8),=CL44' '       BLANK THE MEMBER NAME
         C     R1,=F'7'                 GREATER THAN 7 LONG (8?)
         BNH   OKMEMLEN                 NO - WE'RE OK
         LA    R1,7                     YES - MAKE IT 7
MEMBMVC  MVC   MEMBER(0),TEMP2+1        <<< EXECUTED >>>
OKMEMLEN EX    R1,MEMBMVC               MOVE MEMBER TO MEMBER AREA
         B     MLOOP#                   NO FLAG SET FOR FIRST READ
*
*  FIND THE MEMBER IN THE DIRECTORY
*
*  READ A DIRECTORY BLOCK
*
MLOOP    MVI   TTR+3,1                  SAY PAGE THRU DATASET SEQ
MLOOP#   BAL   R8,READBLK               GET A BLK
         CLI   IOERROR,YESSYN           I/O ERROR?
         BE    READY                    YES - GET OUT
         L     R3,ADDRBUFF              GET BUFFER PTR
         LH    R2,0(R3)                 GET BLK LEN USED
         BCTR  R2,0                     -1
         BCTR  R2,0                     AND -2 FOR REAL LEN USED
         LA    R3,2(R3)                 POINT TO REAL BEGIN LOC
         XR    R4,R4                    CLEAR WORK REG
*
*  MEMBER SCAN LOOP WITHIN BLK
*
MLOOP2   CLI   0(R3),X'FF'              END OF DIRECTORY?
         BNE   NOTEND                   NO - THERE'S MORE TO LOOK
         MVC   TTR(3),0(R13)            PICK UP WHERE HE WAS
         BAL   R8,READBLK               PUT HIM BACK WHERE HE WAS
         LA    R2,INVMEM                SAY MEMBER NOT FOUND
         B     BOTCH                    AND SAY SO
*
NOTEND   CLC   0(8,R3),MEMBER           MEMBER HERE?
         BE    FOUNDM                   YES - GO WORK ON IT
         IC    R4,11(R3)                GET THE 'INDICATORS' FOR MEM
         LA    R3,12(R3)                POINT PAST SOME MEMBER STUFF
         SH    R2,=H'12'                WE HAVE LESS BLK TO WORK WITH
         SLL   R4,27                    KILL HI ORDER BIT
         SRL   R4,26                    RESTORE AND *2 FOR HALFWORDS
*
*  (NOW R4 HAS THE LENGTH OF THE MEMBER USER DATA)
*
         AR    R3,R4                    UPDATE BLK PTR
         SR    R2,R4                    LESS BLK LEFT TO USE
         BNP   MLOOP                    NEG - END BLK - READ ANOTHER
         B     MLOOP2                   MORE TO GO - KEEP LOOKING
FOUNDM   MVC   TTR(3),8(R3)             PICK UP MEMBER'S TTR
         MVC   MEMTTR(3),8(R3)          SAVE IT FOR LATER USE
         B     READX                    GO DO IT
         TITLE 'ZAP --- UTILITY BAL ROUTINES'
*  ROUTINES INCLUDE:
*
*  CLEAR  . . . CLEAR SCREEN
*  READBLK  . . GET A DATA BLOCK (CONTROL FOR NEXTTR AND EXCP)
*  HEXCHECK . . VALIDITY CHECK HEX
*  GETSTRNG . . VALIDITY CHECK AND PARSE HEX/CHAR STRING
*  CSIO . . . . PRIMARY SCREEN DISPLAY
*  CSIOERR# . . ERROR AND STATUS MESSAGE DISPLAY
*  CSIO#  . . . SECONDARY SCREEN DISPLAY
*  CLEARDEF . . RESET DEFINE TABLE
*  CLOSE  . . . CLOSE DATASET
*  FREE . . . . FREE THE DATASET BY DDNAME
*  ALLOC  . . . ALLOCATE THE DATASET BY DSNAME
*  WRITE  . . . EXCP UPDATE OF A DISK DATA RECORD
*  NEWTTR . . . INPUTS RECORD AT PROVIDED TTR FROM DATA SET
*  BOTCH  . . . DISPLAY ERROR MESSAGES
*  CHKPT  . . . CHECK IF ZAP NEEDED.  IF SO IGNORE COMMAND PENDING
*  WHEREAMI . . FORMAT WHERE LINES
*  EXP  . . . . EXPRESSION ANALYZER
         SPACE 5
**********************************************************************
********************************  CLEAR  *****************************
**********************************************************************
         SPACE 3
* CLEAR THE SCREEN
         SPACE 1
CLEAR    MVI   SCREEN,C' '              CLEAR
         MVC   SCREEN+1(256),SCREEN         THE
         MVC   SCREEN+256(256),SCREEN+240        SCREEN
         MVC   SCREEN+512(256),SCREEN+240             THOROUGHLY
         MVC   SCREEN+768(072),SCREEN+240                      NOW
         BR    R8                       RET TO CALLER
         EJECT
**********************************************************************
********************************  READBLK  ***************************
**********************************************************************
         SPACE 3
*  READ A BLOCK (PHYSICAL RECORD) INCLUDING KEY (IF A KEYED DATA SET).
*  IF TTR+3 CONTAINS A 1 (FLAG) THEN READ SEQUENTIALLY.
         SPACE 1
READBLK  MVI   IOERROR,NOSYN            START WITH NO I/O ERROR
         MVC   EOFIOERR(40),=CL44' '    CLEAR OUT ANY I/O ERROR MESSAGE
         NI    FLAGS2,255-MUSTZAP       NEW BLOCK, NO ZAP NEEDED YET
         BAL   R14,NEWTTR               READ THE BLOCK AT TTR
         MVI   TTR+3,0                  RESET SEQUENTIAL READ FLAG
         B     *+4(R15)                 READ RETURN CODE:
         B     R15IS0           R15 = 0   NO PROBLEM
         B     R15IS4           R15 = 4   END OF FILE OR DATA SET
R15IS8   MVI   IOERROR,YESSYN   R15 = 8   I/O ERROR OR OTHER DISK ERROR
         XC    BLKLEN(2),BLKLEN         ASSUME NOTHING READ
         BR    R8                       YES - THEN NOTHING WAS READ
*
R15IS4   XC    BLKLEN(2),BLKLEN         NOTHING READ
*        NOTE: WHEN SKIPPING RECORDS, EOF'S ARE COUNTED AS BLOCKS.
*              IN A PDS, HOWEVER, AN END OF FILE MESSAGE IS DISPLAYED.
         LR    R2,R8                    SAVE RET TO READ
         BAL   R8,CLEAR                 CLEAR SCREEN
         MVC   EOFIOERR(40),EOFMSG      TELL HIM END OF FILE
         CLI   EOFRET,YESEOF            EOF ALLOWED HERE?
         BE    DISPLAY                  YES - SO EOF ALREADY (W/ TRACE)
         BR    R2                       NO - EXIT FROM READBLK (EOF)
*
R15IS0   BR    R8                       GOOD READ
         EJECT
**********************************************************************
*******************************  HEXCHECK  ***************************
**********************************************************************
         SPACE 3
*  VALIDITY CHECK FOR HEXADECIMAL, DECIMAL, OR CHARACTER
*
*  R9 = POINTER TO STRING
*  R1 = LENGTH OF STRING
*  R8 = RETURN ADDR - NOTE: 0(R8)=GOOD HEX, 4(R8)=BAD HEX AT 0(R9)
*  R15= 0 IF PURE DECIMAL UP TO EXIT, 4 IF HEX
         SPACE 1
HEXCHECK XR    R15,R15                  ASSUME DECIMAL
HEXCHK   TM    0(R9),X'F0'              NUMBER?
         BO    OKHEX                    YES - ITS OK
         CLI   0(R9),C'A'               LESS THAN ALPHA?
         BL    4(R8)                    YES, MUST BE CHARACTER
         CLI   0(R9),C'F'               'F' OR SMALLER?
         BH    4(R8)                    NO - MUST BE CHARACTER
         LA    R15,4                    INDICATE HEX (NOT DECIMAL)
OKHEX    LA    R9,1(R9)                 SO FAR SO GOOD, UPDATE HEX PTR
         BCT   R1,HEXCHK                DO THE WHOLE STRING
         BR    R8                       WE'RE OK - ALL DONE
         EJECT
**********************************************************************
********************************  GETSTRNG  **************************
**********************************************************************
         SPACE 3
*  PARSE OUT HEX OR CHARACTER STRING FOR S, EX, O, N, L AND SET COMMS.
*  DETERMINE STRING LENGTH AND STRING ITSELF, AND SAVE BOTH IN AREA.
*
*  IF DECIMAL - A FULLWORD IS STORED (< 2147483647.)
*  IF HEXADECIMAL - UP TO 16 DIGITS (DOUBLEWORD) MAY BE STORED
*  IF CHARACTER - ANY DELIMITERS MAY SURROUND THE STRING (EXCEPT
*                 HEX DIGITS) AND UP TO 36 CHARACTERS MAY BE STORED.
*
*  R3 = ACTUAL LENGTH OF STRING TO BE PARSED
*  R4 = PTR TO THE STRING ITSELF
*  R5  =  PTR TO STRING SAVEAREA  (1ST BYTE = LEN)
         SPACE 1
GETSTRNG LA    R1,1                     LEN OF HEX TO BE CHECKED
         LR    R9,R4                    LOC OF HEX TO BE CHECKED
         BAL   R8,HEXCHECK              DO IT
         B     HEXSTR                   FIRST CHAR HEX - SO HEX STRING
*
*  CHARACTER STRING
*
         CH    R3,=H'38'                STRING LONGER THAN 36 CHARS?
         BNH   SHORTSTR                 NO - IT'S OK
LENERROR LA    R2,LENERR                YES - SAY LENGTH ERROR
         B     BOTCH                    GO TELL HIM
SHORTSTR XC    TEMPTRT(256),TEMPTRT     CLEAR OUT TRTAB
         SR    R1,R1                    CLEAR OUT WORK REG
         IC    R1,0(R4)                 GET DELIM FOR CHAR STRING
         STC   R1,TEMPTRT(R1)           PUT IT IN RIGHT PLACE IN TRTAB
         SH    R3,=H'2'                 GET ADJUST STRING LEN (DELIMS)
         BNP   LENERROR                 HE ENTERED S'' OR LESS - ERROR
DELIMTRT TRT   1(0,R4),TEMPTRT          <<< EXECUTED >>>
         LA    R2,INVDELIM              ASSUME NO ENDING DELIMITER
         EX    R3,DELIMTRT              FIND THE OTHER DELIMITER
         BZ    BOTCH                    NOT FOUND, SAY SO
         LA    R3,1(R4)                 PT TO BEGINNING OF STRING
         SR    R1,R3                    GET STRING LEN (NO DELIMS)
         LR    R3,R1                    PUT IN RIGHT REG
         BCTR  R3,0
         LTR   R3,R3                    NULL INPUT?
         BM    LENERROR                 YES - SAY LENGTH ERROR
CHARMVC  MVC   1(0,R5),1(R4)            <<< EXECUTED >>>
         EX    R3,CHARMVC               MOVE STRING CHARS TO SAVE AREA
         STC   R3,0(R5)                 SAVE STRING LENGTH
         BR    R6                          AND RETURN
         EJECT
*
*  HEX STRING
*
HEXSTR   CH    R3,=H'16'                HEX STRING LONGER THAN 16?
         BH    LENERROR                 YES - SAY LENGTH ERROR
         LR    R1,R3                    PUT IT IN RIGHT REG FOR CHECK
         LR    R9,R4                    POINT TO LOC TO CHECK
         BAL   R8,HEXCHECK              CHECK THE HEX
         B     OK1#                     ITS GOOD
         CLI   0(R9),C' '               IS IT HEX?
         BE    OK1#                     YES, GO DO IT
         CLI   0(R9),C'.'               DECIMAL?
         BE    DECMAYBE                 MAYBE SO
         LA    R2,INVHEX                ITS BAD - PT TO MSG
         B     BOTCH                    TELL HIM
OK1#     TR    0(16,R4),TRHEXX          YES - START TO CONVERT TO HEX
         CH    R3,=H'15'                WHICH CASE?
         BL    HEXPACK                     ACTUAL LENGTH 14 (OR LESS)
         BH    MAXPACK                     ACTUAL LENGTH 16
         BCTR  R4,0                        ACTUAL LENGTH 15
         MVI   0(R4),0                  REPLACE THE 'SXON' OPERATOR
MAXPACK  PACK  TEMP(5),0(9,R4)          PACK FIRST GROUP
         PACK  TEMP+4(5),8(9,R4)        PACK SECOND GROUP
         LA    R3,7                     NUMBER OF BYTES
         MVC   1(8,R5),TEMP             GET HEX,
         STC   R3,0(R5)                    UPDATE LENGTH
         BR    R6                              AND RETURN TO CALLER
* R3 IS NOT BCTRED BECAUSE WE NEED A FLIP BYTE ON THE END
HEXPACK  PACK  TEMP(8),0(0,R4)          <<< EXECUTED >>>
         EX    R3,HEXPACK               PACK TO MAKE REAL HEX
         LA    R3,1(R3)                 ROUND UP ...
         SRL   R3,1                     AND FIND NUMBER OF BYTES
         LA    R15,TEMP+7               POINT TO GORF BYTE
         SR    R15,R3                   POINT TO FIRST BYTE
         BCTR  R3,0                     GET EXECUTE LENGTH
MOVEHEX  MVC   1(0,R5),0(R15)           <<< EXECUTED >>>
         EX    R3,MOVEHEX               MOVE HEX TO OUTPUT LOCATION
         STC   R3,0(R5)                 SAVE THE LEN IN SCAN AREA
         BR    R6                       RET TO CALLER
         EJECT
*
*  DECIMAL STRING
*
DECMAYBE BXLE  R15,R15,DECOK            IF REALLY DECIMAL - JUMP
         LA    R2,INVDEC                NO - TELL HIM SO BECAUSE...
         B     BOTCH                    ITS GOT A-F IN IT
DECOK    CH    R3,=H'10'                APPROACHING LEN ERR (BCTR'D)?
         BL    DECOK#                   NO - DON'T WORRY ABOUT IT
         CLC   0(11,R4),=C'2147483647.' TOO BIG FOR FULLWORD?
         BH    LENERROR                 YES - TELL HIM AND GET OUT
DECPACK  PACK  TEMP(8),0(0,R4)          <<< EXECUTE >>>
DECOK#   LA    R0,1(R4)                 POINT TO STRING + 1 FOR TO....
         SR    R9,R0                    GET EXECUTE LENGTH
         EX    R9,DECPACK               PACK UP YOUR DECIMALS IN ...
*        COMMENT TYPE=CONTINUED         IN YOUR OLD DOUBLE WORD
         CVB   R1,TEMP                  AND CONVERT, CONVERT, CONVERT
         ST    R1,TEMP                  SAVE IN ALIGNED PLACE
         MVC   1(4,R5),TEMP             COPY TO OUTPUT STRING
         MVI   0(R5),3                  EXECUTE LENGTH
         BR    R6                       RETURN
         EJECT
**********************************************************************
*********************************  CSIO  *****************************
**********************************************************************
         SPACE 3
*  MAIN SCREEN DISPLAY.
*  CREATE TRACE TABLE ENTRY IF NECESSARY.
*  DISPLAY WITH TPUTS FOR NOW
         SPACE 1
CSIO     TM    TRACE,NOTRACE            TRACE FOR THIS GUY?
         BO    NOTRACIT                 NO - SO DONT
*
*  MAKE THE TRACE TABLE ENTRY
*
         L     R1,ITRAVAL               PICK UP NEXT SPOT IN TABLE
         CLI   0(R1),X'FF'              END?
         BNE   MORETAB                  NO - THERE'S MORE
         LA    R1,ITRTAB                YES - START OVER WITH BEG PTR
         ST    R1,ITRAVAL               AND RESET AVAIL POS PTR
MORETAB  MVC   0(3,R1),TTR              MOVE TTR TO TABLE
         MVC   3(2,R1),OLDPOINT         AND OFFSET TOO
         ST    R1,CURRITR               SAVE PTR TO CURR TRACE ENTRY
         LA    R1,5(R1)                 UPDATE AVAIL PTR
         ST    R1,ITRAVAL               SAVE IT
NOTRACIT STM   R2,R6,SAVECSIO           SAVE REGS JUST IN CASE
         SPACE 1
         LA    R6,40                    LEN 1 LINE
         CLC   EOFIOERR(40),=CL44' '    ANY EOF - I/O ERROR MSG
         BE    NOTOP                    NO, NO TOP
         LA    R1,EOFIOERR              YES, TPUT IT
         TPUT  (1),(R6),R
         SPACE 1
NOTOP    L     R5,MIDLINE               ADDR OF CARET
         LTR   R5,R5                    ANY CARET (BLK DISPLAY?)
         BNZ   DOWINDOW                 YES, WINDOW SCREEN
         LA    R3,SCREEN+0              NO, FULL SCR, BEGIN
         LA    R5,SCREEN+800-40         END (BXLE)
         B     DUMPSCR                  DUMP IT
         EJECT
*  CREATE TSO SCREEN WINDOW. DEFAULT SIZE IS ONLY CARET LINE. THE
*  'W' COMMAND CHANGES IT TILL NEXT 'W' COMMAND.  LINES ABOVE AND
*  BELOW 'CARET' LINE ARE SPECIFIED.  THIS ALLOWS FEWER LINES FOR
*  HARDCOPY TERMINALS.  EG:
*
*  D,U ... U LINES ABOVE, CARET LINE, D LINES BELOW
*  ,U .... U LINES ABOVE, CARET LINE, PREVIOUS D LINES BELOW
*  D×D, .. PREVIOUS U LINE ABOVE, CARET LINE, D LINES BELOW
*
         SPACE 1
DOWINDOW S     R5,FIRSTSCR              OFFSET TO SCREEN CARET
         XR    R4,R4                    DIVIDE
         DR    R4,R6                    LINE NUMBER CARET
         LR    R3,R5                    SAVE IT
         LNR   R15,R5                   SAVE NEGATIVE
         S     R3,WIDTHU                BACK UP 'U' LINES <UP>
         A     R5,WIDTHD                GO DOWN 'D' LINES <DOWN>
         LTR   R3,R3                    TOP TO LOW
         BNM   *+6                      NO, OK
         XR    R3,R3                    YES, MAKE IT 0, TOP OF BUFF
         LA    R0,SCRLINES-1            MAX LINE NUM (-1 FOR OFFSET)
         CR    R5,R0                    BOTTOM TOO HIGH
         BNH   *+6                      NO
         LR    R5,R0                    YES, MAKE IT MAX LINE#
         AR    R15,R5                   LINES DOWN FROM CARET -1
         STH   R15,DSAVE                SAVE FOR "D" WITH NO OPERANDS
         MR    R2,R6                    GET OFFSET TO TOP LINE
         MR    R4,R6                    GET OFFSET TO BOTT LINE
         A     R3,FIRSTSCR              POINT TO TOP
         A     R5,FIRSTSCR              POINT TO BOTTOM
DUMPSCR  LR    R4,R6                    GET LENGTH IN BXLE REG
         SPACE 1
*  R3=BEGIN, R4=LEN, R5=END
         SPACE 1
TPUTL    CLC   0(40,R3),=CL44' '        BLANK LINE HERE?
         BE    CSIONXT1                 YES, DON'T TPUT IT
         TPUT  (R3),(R4),R              TPUT 1 LINE
CSIONXT1 BXLE  R3,R4,TPUTL
         B     CSIOERR#+4               SKIP THE STM INSTRUCTION
         SPACE 3
**********************************************************************
*********************************  CSIOERR#  *************************
**********************************************************************
         SPACE 2
*        NO TRACE IF ENTRY BELOW -- TURN ON TRACE FOR LATER
CSIOERR# STM   R2,R6,SAVECSIO           SAVE REGISTERS "JUST IN CASE"
         LA    R6,40                    MESSAGE LENGTH
         MVI   TRACE,YESTRACE           ERROR AND STATUS MESSAGES
         LA    R2,GENERROR              POSSIBLE MSGS BELOW WINDOW
         LA    R3,1                     ONE LINE MAXIMUM
         CLI   WHERELIN,C'D'            WHERAMI DISPLAY DESIRED?
         BNE   CSIOMORE                 NO, DO THE TPUT
         LA    R3,WHEREL/40             SET FOR MAXIMUM NUMBER OF LINES
         LA    R2,WHERELIN              FIRST OUTPUT LINE
         SPACE 1
CSIOMORE CLC   0(40,R2),=CL44' '        BLANK LINE?
         BE    CSIOLINE                 YES, IGNORE
         TPUT  (R2),(R6),R              TPUT 1 LINE
CSIOLINE LA    R2,40(,R2)               DO ALL LINES
         BCT   R3,CSIOMORE              DO ALL LINES
         SPACE 2
         SR    R3,R3                    TGET LOOP COUNTER
         MVC   REP(40),=CL44' '         CLEAR AREA
         MVI   WHERELIN,X'40'      ***  TURN OFF WHEREAMI DESIRED FLAG
TGET     LR    R0,R6                    HOW MUCH TO READ (40)
         LA    R1,REP                   WHERE
         O     R1,=XL4'80000000'        SAY TGET
         TGET  (1),(0),R                GET COMMAND
         CH    R15,=H'8'                ATTN SIGNALLED?
         BE    TGET                     YES, BRANCH
         LA    R2,TGETTOO               ASSUME LINES ARE DROPPED
         LTR   R3,R3                    CORRECT?
         BP    BOTCH                    YES, BRANCH
         LA    R3,1(,R3)                LINE DROPPED COUNTER
         CH    R15,=H'12'               REPLY LONGER THAN 40 BYTES?
         BE    TGET                     YES, IGNORE THE INPUT
         SPACE 1
         STH   R1,READLEN               PUT LENGTH AWAY
         MVC   GENERROR(40),=CL44' '    40 BYTES BLANKS
         XC    MIDLINE,MIDLINE          NO CARET LINE NOW
         LM    R2,R6,SAVECSIO           RESTORE REGS
         BXLE  R1,R1,READY              NO COMMAND
         OC    REP(40),=CL44' '         FOLD THE REPLY FOR TSO TGET
         BR    R8                       YES, PARSE IT
         EJECT
**********************************************************************
*********************************  CSIO#  ****************************
**********************************************************************
         SPACE 3
*  SECONDARY DISPLAY.
*  SHORT SCREEN MSGS
*
*  R1 = ADDR OF BUFFER (40 BYTES ONLY)
         SPACE 1
CSIO#    LA    R0,40                    LEN
         SPACE 1
         TPUT  (1),(0),R                PUT THE LINE
         SPACE 2
         NI    FLAGS2,255-MUSTZAP       TURN OFF ZAP NEEDED FLAG
         MVC   REALRDLN(2),=H'1'        AND FAKE A C SUBCOMMAND
         L     R1,CPPLUPT               GET USER PROFILE (UPT) ADDRESS
         TM    12(R1),X'40'             PROMPTING ALLOWED?
         BO    END                      NO, NO MORE CHANCES ALLOWED
         B     CHANGE                   YES, TRY TRY AGAIN
         SPACE 5
**********************************************************************
********************************  CLEARDEF  **************************
**********************************************************************
         SPACE 3
*  RESET AND/OR INITIALIZE THE DEFINE TABLE
         SPACE 1
CLEARDEF LA    R2,IDEFTAB               PT TO BEGINNING OF TABLE
         ST    R2,IDEFAVAL              MAKE THAT THE 1ST AVAIL POSIT
         MVI   IDEFTAB,C' '             CLEAR OUT...
         MVC   IDEFTAB+1(239),IDEFTAB   THE TABLE ALSO
         MVI   ENDITAB,X'FF'            MAKE THE END OF THE TABLE
         BR    R8                       RET TO CALLER
         EJECT
**********************************************************************
**********************************  CLOSE  ***************************
**********************************************************************
         SPACE 3
*  CLOSE THE DATASET
         SPACE 1
CLOSE    TM    DCBU+48,X'10'            IS IT OPEN?
         BNO   FREE                     NO, WHY CLOSE? -- TRY A FREE
         CLOSE MF=(E,DCBLIST)           GOODBYE DATASET
         SPACE 2
**********************************************************************
*********************************  FREE  *****************************
**********************************************************************
         SPACE 1
*  FREE THE DATASET
FREE     CLI   DDNAME,0                 ANY DDNAME TO FREE?
         BE    R8                       NO, RETURN
         CLC   DDNAME(8),=C'SYSHELP '   SYSHELP DDNAME?
         BE    *+10                     YES, ALWAYS FREE IT
         TM    FLAGS2,FILENAME          PREALLOCATED FILE NAME?
         BOR   R8                       YES, DO NOT FREE IT
         LA    R2,DAPBAREA              ADDRESSING
         USING DAPB18,R2                          DA18 VARIABLES
         XC    DAPB18(DAPB18L),DAPB18   CLEAR THE FREE BLOCK
         MVI   DA18CD+1,X'18'           DAIR ENTRY CODE
         MVC   DA18DDN,DDNAME           FREE BY DDNAME
         MVC   DA18MNM,=CL44' '         NO MEMBER NAME
         MVC   DA18SCLS,=CL44' '        NO SYSOUT CLASS
         ST    R2,DAPLDAPB              START OF AREA
         LA    R1,DAPL                  POINT TO IT
         L     R15,IKJDAIR              DAIR ENTRY POINT
         BALR  R14,R15                  CALL DAIR
         XC    DDNAME,DDNAME            DDNAME IS GONE
         BR    R8                       RETURN
         DROP  R2                       DAIR NOT NEED
         EJECT
**********************************************************************
*********************************  ALLOC  ****************************
**********************************************************************
         SPACE 1
*  ALLOCATE THE FILE
ALLOC    LA    R2,DAPBAREA              POINT TO THE
         USING DAPB08,R2                            DAIR BLOCK
         XC    DAPB08(DAPB08L),DAPB08   CLEAR THE DAIR AREA
         MVI   DA08CD+1,X'08'           DAIR ENTRY CODE
         LA    R0,DSNAMEL
         ST    R0,DA08PDSN              DATA SET NAME
         MVC   DA08DDN,=CL44' '         ANY DDNAME IS OK
         MVC   DA08SER(8),VOLSER        SERIAL NUMBER OR BLANK
         MVC   DA08UNIT,=CL44' '        ANY UNIT IS OK
         MVC   DA08MNM,=CL44' '         MEMBER NAME NOT SUPPORTED
         MVC   DA08PSWD,=CL44' '        PASSWORD NOT SUPPORTED
         TM    FLAGS2,QUOTED            QUOTED DATASET NAME?
         BO    NOQUOTES                 YES, BRANCH
         OI    DA08CTL,DA08UID          NO, PREFIX WITH USERID
NOQUOTES MVI   DA08DSP1,DA08SHR         DISP=(SHR,
         MVI   DA08DPS2,DA08KEEP                  KEEP,
         MVI   DA08DPS3,DA08KEP                        KEEP)
         MVC   DA08ALN,=CL44' '         NONE
         ST    R2,DAPLDAPB              POINT TO DAPL PARAMETER BLOCK
         LA    R1,DAPL                  POINT TO DAIR PARAMETER LIST
         L     R15,IKJDAIR              DAIR ADDRESS
         BALR  R14,R15                  CALL DAIR
         MVC   DDNAME,DA08DDN           SAVE THE DDNAME
         LTR   R15,R15                  ANY ERRORS?
         BZR   R8                       NO, RETURN
         MVC   TEMP3(40),DAIRERR        DAIR GENERAL ERROR MESSAGE
         CVD   R15,TEMP
         UNPK  TEMP3+15(2),TEMP+6(2)
         OI    TEMP3+16,X'F0'           DECIMAL RETURN CODE
         UNPK  TEMP2(5),DA08CTRC(3)
         TR    TEMP2(4),TRHEX
         MVC   TEMP3+24(4),TEMP2        CATALOG RETURN CODE
         UNPK  TEMP2(5),DA08DARC(3)
         TR    TEMP2(4),TRHEX
         MVC   TEMP3+35(4),TEMP2        DYNAMIC ALLOCATION RETURN CODE
         LA    R1,TEMP3
         B     CSIO#                    ERROR MESSAGE AND RETRY
         DROP  R2
         EJECT
**********************************************************************
*********************************  WRITE  ****************************
**********************************************************************
         SPACE 2
WRITE    LA    R1,CCW1W                 POINT TO THE WRITE CCW'S
         ST    R1,CPADDR                PLACE IN THE IOB
         MVC   CCW3W+6(2),BLKLEN        LAST LENGTH INPUT
         EXCP  IOB                      WRITE THE DATA
         WAIT  ECB=ECB                  WAIT FOR COMPLETION
         CLI   ECB,X'7F'                SUCESSFUL?
         BER   R8                       YES, RETURN
         MVI   IOERROR,YESSYN           SET I/O ERROR FLAG
         ST    R8,EXCPR14               SAVE RETURN REGISTER
         LA    R1,=CL16'UPDATE ERROR' ERROR IN THE UPDATE
         B     IOERRXIT                 FORMAT MESSAGE
         SPACE 3
**********************************************************************
*********************************  NEWTTR  ***************************
**********************************************************************
*
*   NEWTTR ROUTINE: GET RECORD POINTED AT BY TTR
*
NEWTTR   ST    R14,EXCPR14             SAVE THE RETURN ADDRESS
         CLI   TTR+3,1                 SEQUENTIAL MODE?
         BNE   THISTTR                 NO, BRANCH
         SR    R1,R1                   YES,
         IC    R1,TTR+2                    INCREMENT
         LA    R1,1(,R1)                            R OF
         STC   R1,TTR+2                                 TTR
*
THISTTR  TTRMBB TTR,MBB=IOBSEEK        CONVERT THE DESIRED TTR
         MVC   SAVCCHHR(5),IOBSEEK+3   SAVE EXPECTED CCHHR
         SR    R15,R15                 CLEAR FOR IC
         IC    R15,IOBSEEK+7           R OF MBBCCHHR
         BCTR  R15,0                     IS REDUCED BY ONE
         STC   R15,IOBSEEK+7             FOR MT READ
         B     MTREADC                 GET KEY AND DATA COUNTS
         SPACE 2
*
*    FOR EACH EXTENT, INITIALIZE CCHHR, READ IN THE LENGTH OF THE
*        FIRST RECORD.
*
EACHXTNT SR    R1,R1              AFTER THE FIRST EXTENT --
         IC    R1,IOBSEEK
         LA    R1,1(,R1)
         STC   R1,IOBSEEK         INCREMENT THE EXTENT NUMBER
         L     R15,DCBDEBAD-IHADCB+DCBU
         CLC   IOBSEEK(1),DEBNMEXT-DEBDS(R15)  PAST LAST EXTENT
         BNL   EOF$DS                          YES, END OF DATA SET
         SLL   R1,4                         CURRENT EXTENT DISPLACEMENT
         LA    R1,32(R1,R15)                EXTENT ADDRESS
         MVC   IOBSEEK+3(4),6(R1)           INITIAL CCHH
         MVI   IOBSEEK+7,0                  R OF MBBCCHHR IS ZERO
MTREADC  LA    R1,CCW1INIT                  CHANNEL PROGRAM TO
         ST    R1,CPADDR                         READ NEXT KEY
         EXCP  IOB                               AND DATA LENGTH
         WAIT  ECB=ECB
         CLI   ECB,X'42'                    EXTENT VIOLATION?
         BE    EACHXTNT                     YES, BRANCH
         LA    R1,=CL16'RECORD NOT FOUND'
         CLI   ECB,X'7F'                    GOOD READ?
         BNE   IOERRXIT                     NO, BRANCH
         CLC   SAVCCHHR(4),IOBSEEK+3        SAME TRACK?
         BE    GOODTTR                      YES, BRANCH
         CLI   TTR+3,1                      SEQUENTIAL INPUT?
         BNE   IOERRXIT                     NO, ERROR
         MVC   SAVCCHHR(5),IOBSEEK+3        SAVE FOR POSSIBLE OUTPUT
         LH    R1,TTR                       YES,
         LA    R1,1(,R1)                        INCREMENT
         STH   R1,TTR                                    TT OF TTR
         MVI   TTR+2,1                      R=1 (FIRST RECORD)
*
GOODTTR  LA    R1,CCW1                 POINT TO MAIN READ CCW'S
         ST    R1,CPADDR               PUT IN IOB
         MVC   EXTT+1(3),KEYLN         GET NEXT KEY AND DATA LENGTH
         MVI   EXTT,0                  CLEAR TOP BYTE OF KEY LENGTH
         LH    R0,EXTT+2               GET DATA LENGTH
         CLI   KEYLEN+1,0              KEY TO BE INPUT?
         BE    *+8                     NO, BRANCH
         AH    R0,EXTT                 YES, ADD KEY LENGTH
         STH   R0,CCW3+6               GET LENGTH FOR THIS READ
         LA    R1,=CL16'BUFFER OVERFLOW'  ASSUME BUFFER TOO SMALL
         CH    R0,EXCPBUF                 CORRECT?
         BH    IOERRXIT                   YES, BRANCH
         MVC   CURMBB(8),IOBSEEK  SAVE THE DISK ADDRESS OF THIS RECORD
         STH   R0,BLKLEN          SAVE EXPECTED DATA LENGTH (KEY+DATA)
         EXCP  IOB                     INPUT THE RECORD
         WAIT  ECB=ECB                    AND WAIT FOR IT
         SR    R15,R15            GOOD READ FLAG
         CLI   ECB,X'7F'          GOOD READ?
         BE    ENDEXCP            YES, QUIT
*
         LA    R1,=CL16'UNKNOWN ECB=ZZ'  ASSUME ECB NOT 41, 42 OR 7F
         CLI   ECB,X'41'                 PERMANENT ERROR?
         BNE   IOERRXIT                  NO, ERROR MESSAGE AND QUIT
         SPACE 2
         LA    R1,=CL16'PERMANENT ERROR'  ASSUME PERMANENT ERROR
         TM    CSW+4,X'01'                ACTUALLY EOF?
         BO    EOF$DS                     YES, BRANCH
         CLC   CSW+4(4),=X'00200000'      NULL MEMBER OR DATA SET?
         BE    EOF$DS                     YES, BRANCH
         SPACE 3
IOERRXIT MVC   EOFIOERR(40),IOERRMSG   GENERAL I/O ERROR MESSAGE
         MVC   EOFIOERR+17(16),0(R1)   SPECIFIC PART OF MESSAGE
         LA    R15,8                   I/O ERROR RETURN CODE
         CLC   0(16,R1),=CL16'UNKNOWN ECB=ZZ'  ECB MESSAGE?
         BNE   ENDEXCP                         NO, BRANCH
         UNPK  EXTT(3),ECB(2)                  CONVERT
         TR    EXTT(2),TRHEX                          ECB TO
         MVC   EOFIOERR+29(2),EXTT                          PRINTABLE
         B     ENDEXCP
EOF$DS   LA    R15,4              END OF FILE RETURN
ENDEXCP  L     R14,EXCPR14        RETURN ADDRESS
         BR    R14
         EJECT
*
*       ORDER IS IMPORTANT IN THE FOLLOWING INITIALIZATION STATEMENTS:
*
CCWI     DS    0D
         CCW   X'31',IOBSEEKI+3-CCWI,X'60',5  SEARCH ID EQUAL (CCHHR)
         CCW   X'08',*-8-CCWI,X'60',1         TIC
         CCW   X'92',IOBSEEKI+3-CCWI,X'20',8  MT READ NEXT COUNT
*
         CCW   X'31',IOBSEEKI+3-CCWI,X'60',5  SEARCH ID EQUAL (CCHHR)
         CCW   X'08',*-8-CCWI,X'60',1         TIC
         CCW   X'06',*-*,X'20',*-*            READ DATA
*
         CCW   X'31',CURMBBI+3-CCWI,X'60',5   SEARCH ID EQUAL (CCHHR)
         CCW   X'08',*-8-CCWI,X'60',1         TIC
         CCW   X'05',*-*,X'20',*-*            UPDATE DATA
*
         DS    0F
         DC    X'C2000000'
         DC    A(*-*)
         DC    2A(0)
         DC    A(*-*)
         DC    A(*-*)
         DC    2A(0)
IOBSEEKI DC    2A(0)          NEXT MBBCCHHR ADDRESS
         DS    X              NEXT KEYLENGTH
         DS    2X             NEXT RECORD LENGTH
*
CURMBBI  DC    XL8'00'        CURRENT MBBCCHHR ADDRESS
         SPACE 3
*
*     ORDER IS IMPORTANT IN THE ABOVE INITIALIZATION STATEMENTS
*
         SPACE 5
**********************************************************************
***********************  BOTCH  AND  BOTCH2  *************************
**********************************************************************
         SPACE 3
*  DISPLAY ERROR MESSAGES AND STATUS MESSAGES
*  MOVE IN MSG AND HYPHENS TO ERROR MSG LINE ON SCREEN.
*  TRACE WILL BE DISABLED.  IF SYNTAX ERROR MSG IS TO BE DISPLAYED,
*  THE COLUMN IN QUESTION IS COMPUTED AND DISPLAYED WITH THE MSG.
*
*  R2 = PTR TO MESSAGE
*  R1 = PTR TO INVALID LOC IN EXPRESSION (IF APPLICABLE)
         SPACE 1
BOTCH    MVC   GENERROR+5(20),0(R2)     MOVE IN MSG
         MVC   GENERROR(3),=C'==='      MOVE IN HYPHENS
         MVC   GENERROR+26(3),=C'==='   MOVE IN HYPHENS
         C     R2,AINVEXP               IS THIS AN INVALID EXPRESS MSG?
         BNE   BOTCH2                   NO - GO ON
         LA    R3,TEMP2                 PT TO REPLY
         SR    R1,R3                    GET OFFSET TO BAD HEX
         LA    R1,1(R1)                 MAKE THE OFFSET A COLUMN #
         CVD   R1,TEMP                  YES - GET OFFSET OF ERROR INTO
         UNPK  TEMP2(8),TEMP+6(4)       THE EXPRESSION AND
         MVC   GENERROR+23(2),TEMP2+2   MOVE IT TO THE SCREEN
BOTCH2   BAL   R8,CSIOERR#              ERROR/STATUS MESSAGE (NO TRACE)
         B     ANALREP                  CHECK THE INPUT FROM ABOVE
         SPACE 5
***********************************************************************
*********************************  CHKPT  *****************************
***********************************************************************
         SPACE 2
CHKPT    TM    FLAGS2,MUSTZAP           BLOCK NEED A ZAP 1ST?
         BNOR  R8                       NO, LET COMMAND THRU
         NI    FLAGS2,255-MUSTZAP       YES, WE TOLD HIM ONCE
         LA    R2,MUSTZAPM              TELL HIM, IGNORE COMMAND
         B     BOTCH                    HE CAN ALWAYS DO IT AGAIN
         SPACE 5
***********************************************************************
********************************  WHEREAMI  ***************************
***********************************************************************
         SPACE 2
WHEREAMI UNPK  TEMP2(11),SAVCCHHR(6)    CURRENT CCHHR
         MVI   WHERELIN,C'D'         ***TURN ON WHERE DISPLAY DESIRED
         TR    TEMP2(10),TRHEX          MAKE IT HEX
         MVC   WHERELIN+59(10),TEMP2    MOVE IT TO SCREEN
         UNPK  TEMP2(9),TTR(5)          GET TTR
         TR    TEMP2(8),TRHEX           MAKE IT HEX ALSO
         MVC   WHERELIN+45(6),TEMP2     MOVE IT TO SCREEN
         CLI   DSNAME,X'04'             VTOC (X'04')
         BNE   MAKEDSN                  NO - GO ON
         MVC   WHERELIN+5(8),=C'VTOC FOR' SAY ITS A VTOC FOR...
         MVC   WHERELIN+14(6),VOLSER    THE VOLUME SPECIFIED
         B     WASVTOC                  AND GO ON WITH DISPLAY
MAKEDSN  MVC   WHERELIN+005(24),DSNAME    SHOW THE DSNAME
WASVTOC  UNPK  TEMP2(9),OLDPOINT(3)     GET OFFSET
         TR    TEMP2(8),TRHEX           MAKE IT HEX ALSO
         MVC   WHERELIN+036(4),TEMP2+4  MOVE IT TO WHERELIN
         MVC   WHERELIN+075(5),EDMASK+7 GET READY TO EDIT IN BLKLEN
         LH    R1,BLKLEN                GET THE LENGTH READ
         CVD   R1,TEMP                  CONV TO DECIMAL
         ED    WHERELIN+074(6),TEMP+5   EDIT IT TO WHERELIN
         MVC   TEMP2(40),=CL44' '       CLEAR WORK AREA
         BR    R8
         SPACE 5
***********************************************************************
********************************  EXP  ********************************
***********************************************************************
         SPACE 2
*        EXP: THIS ROUTINE WILL ANALYZE AN EXPRESSION PASSED TO IT
*        AND RETURN ITS VALUE CONCATENATED WITH A STARTING VALUE.
*
*        INPUT: R13 - SAVEAREA
*               R14 - RETURN ADDRESS
*                     IF EXPOPT IS ZERO - TABLE NOT SCANNED
*                     ELSE SYMBOL TABLE IS SCANNED.
*               R15 - STARTING VALUE OF '*'
*               R1  - ADDRESS OF EXPRESSION TO PARSE
*               R0  - LENGTH OF EXPRESSION TO PARSE
*        OUTPUT:R1  - RETURN CODE
*                     IF NEGATIVE: NO ERRORS DETECTED
*                     IF ZERO OR POSITIVE AN ERROR OCCURED AT ADDRESS
*                     GIVEN IN R1
*               R15 - IF NO ERROR, THE NEW VALUE CALCULATED.
         SPACE 1
*  THIS ROUTINE WAS WRITTEN BY DON WORTH.
         SPACE 1
EXP      STM   R14,R1,EXPARMS+12        SAVE CALLER'S REGS ONE PLACE
         STM   R2,R12,12+(4*4)(R13)     SAVE REST IN OTHER PLACE
         LR    R4,R15                   ALWAYS BEGIN WITH *
         LR    R3,R1                    START SCAN
         BCTR  R3,0                     HE WILL ADD ONE FIRST
         LR    R2,R0                    BCT INDEX
         XC    EXPFLAG(2),EXPFLAG       RESET FLAGS
         LA    R2,1(R2)                 ALLOW FOR FIRST PASS
         ST    R1,GORF                  FIRST BAD SPOT
         B     EXPBACK                  START AFTER ITEM
         SPACE 1
*        SEE WHAT NEXT ITEM IS
         SPACE 1
EXPITEM  LTR   R2,R2                    ANYTHING LEFT?
         BP    EXPON                    YES
         ST    R4,EXPSTART              NEW STARTER
         OI    EXPPTR,X'80'             NO ERROR
         B     EXPRET                   RETURN
EXPON    CLI   0(R3),C' '               BLANK?
         BNE   EXPCHECK                 NO, WE CAN USE IT
EXPNEXT  LA    R3,1(R3)                 NEXT SPOT TO CHECK
         BCT   R2,EXPITEM               CONTINUE
         MVI   EXPFLAG+1,0              NOTHING FOR NEXT TIME
         B     EXPCONV                  WHEN AT END, USE LAST IF ANY
EXPCHECK ST    R3,GORF                  KEEP TRACK OF WHERE WE ARE
         CLI   0(R3),C'*'               CURRENT LOC?
         BE    EXPCURR                  YES, GO LOAD IT
         CLI   0(R3),C'+'               ADD?
         BE    EXPADD                   YES
         CLI   0(R3),C'-'               SUBTRACT?
         BE    EXPSUB                   YES
         CLI   0(R3),C'.'               DECIMAL DONE?
         BE    EXPDEC                   YES
         SPACE 1
*        IF NO TERMINATOR IS FOUND, SAVE UP FOR LATER
         SPACE 1
         LA    R0,EXPWORK+8             POINT PAST IT
         CR    R0,R5                    TOO FAR?
         BNH   EXPERR                   YES
         MVC   0(1,R5),0(R3)            COPY IT TO WORKAREA
         LA    R5,1(R5)
         B     EXPNEXT                  CONTINUE
         SPACE 1
*        IF AN ERROR IS DETECTED, PASS BACK ADDR OF IT
         SPACE 1
EXPERR   MVC   EXPPTR(4),GORF           SAVE POINTER FOR RETURN
EXPRET   MVI   EXPOPT,NOSYMB            RESET NO SYMB TAB LOOKUP
         LM    R14,R1,EXPARMS+X'C'      GET RETURN REGS
         LM    R2,R12,12+(4*4)(R13)     RESTORE REST OF REGS FROM SAVE
         BR    R14
         LM    R14,R12,12(R13)          RESTORE HIS REGS
         BR    R14                      RETURN TO CALLER
         SPACE 1
*        IF '*' WAS ENTERED, USE CURRENT VALUE
         SPACE 1
EXPCURR  L     R15,EXPSTART             GET STARTING VALUE
         MVI   EXPFLAG+1,0              NO FLAGS TO SET
         B     EXPUSE                   AND GO USE IT
         SPACE 1
*        IF '+' WAS ENTERED, TERMINATE PREVIOUS AND SET FLAG
         SPACE 1
EXPADD   MVI   EXPFLAG+1,EXPFPLUS       INDICATE ADD NEXT TIME
         B     EXPCONV                  GO CONVERT IT
         SPACE 1
*        IF '-' WAS ENTERED, TERMINATE PREVIOUS AND SET FLAG
         SPACE 1
EXPSUB   MVI   EXPFLAG+1,EXPFMINS       INDICATE ADD NEXT TIME
         B     EXPCONV                  GO CONVERT IT
         SPACE 1
*        IF '.' WAS ENTERED, TERMINATE PREVIOUS AS DECIMAL
         SPACE 1
EXPDEC   OI    EXPFLAG,EXPFDEC          INDICATE DECIMAL THIS TIM
*        B     EXPCONV                  GO CONVERT IT
         SPACE 1
*        WHEN UP TO 8 CHARS SCANNED OUT, CONVERT THEM APPROPRIATELY
         SPACE 1
EXPCONV  LA    R15,EXPWORK+1            POINT TO START
         SR    R5,R15                   FIND EXECUTE LENGTH
         LR    R15,R5                   SAVE IT
         BNM   EXPCOK                   IF SOMETHINGS THERE, CONTINUE
         TM    EXPFLAG,EXPFTERM         SOMETHING EXPECTED?
         BZ    EXPBACK                  NO, IGNORE THIS TIME
         B     EXPERR                   OTHERWISE ITS NO GOOD
EXPCOK   MVC   DBLW(0),EXPWORK          <<<  EXECUTED  >>>
         MVC   DBLW(8),=CL44' '         CLEAR AN AREA
         EX    R15,EXPCOK               MOVE TO IT
         SPACE 1
*        IF SYMBOL TABLE SCAN REQUESTED, DO SO
         SPACE 1
         CLI   EXPOPT,NOSYMB            SCAN LABEL TABLE?
         BE    EXPNTAB                  NO, GO ON
         TM    EXPFLAG,EXPFDEC          DECIMAL?
         BO    EXPNTAB                  THEN CAN'T BE THIS
         L     R14,AIDEFTAB             POINT TO TABLE
EXPIDSCN CLI   0(R14),255               END OF TABLE?
         BE    EXPNTAB                  THEN WE DIDN'T FIND IT
         CLC   0(8,R14),DBLW            SEE IF THIS IS HIS LABEL
         BE    EXPGLAB                  YES, IT IS
         LA    R14,10(R14)              NEXT ENTRY IN TABLE
         B     EXPIDSCN                 GO ON
EXPGLAB  LH    R15,8(R14)               GET VALUE OF IT
         B     EXPUSE                   AND USE IT
         SPACE 1
*        VALIDITY CHECK FOR NUMERICS
         SPACE 1
EXPNTAB  LA    R0,1(R15)                GET LENGTH OF THINGY
         LA    R14,EXPWORK              FIND IT
EXPCCHK  CLI   0(R14),C'0'              IF ITS NUMERIC I ALWAYS LIKE IT
         BNL   EXPCGOOD                 GO
         TM    EXPFLAG,EXPFDEC          DECIMAL?
         BO    EXPERR                   THEN NO GOOD
         CLI   0(R14),C'A'              OTHERWISE NOT LESS THAN A
         BL    EXPERR                   GO
         CLI   0(R14),C'F'              OR GREATER THAN F
         BH    EXPERR                   GO
         IC    R1,0(R14)                GET IT
         AH    R1,EXPFUDGE              MAKE FA-FF
         STC   R1,0(R14)                REPLACE IT
EXPCGOOD LA    R14,1(R14)               NEXT
         BCT   R0,EXPCCHK               CONTINUE CHECKING
         SPACE 1
*        CONVERT DECIMAL
         SPACE 1
         TM    EXPFLAG,EXPFDEC          DECIMAL?
         BZ    EXPNDEC                  NO
EXPPACK  PACK  DBLW(8),EXPWORK(0)       <<< EXECUTED >>>
         EX    R15,EXPPACK              PACK IT
         CVB   R15,DBLW                 CONVERT IT
         B     EXPUSE                   AND USE IT
         SPACE 1
*        CONVERT FOR HEX
         SPACE 1
EXPNDEC  LA    R15,1(R15)               DO AN EXTRA CHAR
         EX    R15,EXPPACK              PACK IT
         LM    R14,R15,DBLW             GET OFFSET
         SRDL  R14,8                    SHIFT OUT BAD BYTE (FLIP)
*        B     EXPUSE                   GO USE IT
         SPACE 1
*        WHEN VALUE OBTAINED, ADD, SUB OR WHATEVER
         SPACE 1
EXPUSE   TM    EXPFLAG,EXPFPLUS         ADDING?
         BO    EXPUADD                  YES
         TM    EXPFLAG,EXPFMINS         SUBTRACTING?
         BO    EXPUSUB                  YES
         LR    R4,R15                   ELSE, OVERLAY
EXPBACK  LA    R5,EXPWORK               START AGAIN
         MVC   EXPFLAG(1),EXPFLAG+1     NEW FLAGS
         MVI   EXPFLAG+1,0              NO MORE
         B     EXPNEXT                  SKIP LAST ONE
EXPUADD  AR    R4,R15
         B     EXPBACK                  GO ON
EXPUSUB  SR    R4,R15                   SUBTRACT
         B     EXPBACK                  GO
         SPACE 5
*
*  EXP'S DATA
*
         SPACE 1
EXPFUDGE DC    0H'0',XL2'0039'
EXPFPLUS EQU   X'80'                    ADD NEXT VALUE
EXPFMINS EQU   X'40'                    SUBTRACT NEXT VALUE
EXPFDEC  EQU   X'20'
EXPFTERM EQU   EXPFPLUS+EXPFMINS+EXPFDEC SOMETHING REQUIRED
         TITLE 'ZAP --- CONSTANTS, DATA, FLAGS, ETC'
*
*  ERROR AND INFORMATIVE MESSAGES
*
         SPACE 1
BADDSN   DC    CL40'DATA SET UNAVAILABLE OR NON-EXISTENT'
NOTMOUNT DC    CL40'THE VOLUME IS NOT ON-LINE'
IOERRORM DC    CL40'I/O ERROR READING THE VTOC'
F4NOTFND DC    CL40'FORMAT 4 DSCB WAS NOT FOUND'
NOFMT1   DC    CL40'NO FORMAT 1 DSCB ON THIS VOLUME'
DAIRERR  DC    CL40'DAIR ERROR--RC=12; CTRC=1234; DARC=1234;'
EXTENT#  DC    CL40'EXT #  START-END  (CCHH)  TRACKS  REL TT'
********              1    00C3000A-00C3000F      5     0000
IOERRMSG DC    CL40'***** I/O ERROR: XXXXXXXXXXXXXXXX *****'
GETCSMSG DC    CL40'NOT ENOUGH CORE FOR BUFFERS'
SCANMTCH DC    CL40'          ***  SCAN MATCH  ***'
EOFMSG   DC    CL40'         ***  END OF FILE  ***'
WRITEOK  DC    CL40'      ***  BLOCK REPLACED  ***'
TTRCCHHR DC    CL40'TTR: XXXXXX CCHHR: XXXXXXXXXX LEN: XXXXX'
ENTERCMD DC    CL40'ENTER COMMAND, OR ?, H, OR HELP FOR HELP'
BADPARSE DC    CL40'INVALID PARSE INPUT - (PROFILE NOPROMPT)'
OPERANDS DC    CL40'SUBCOMMANDS:  ?, #, =, <, >, ASCII, ASM,'
         DC    CL40'  B, C, CC, CHANGE, D, DCB, DIS, DISASM,'
         DC    CL40'  EBCDIC, END, EX, EXTENTS, F, FLOAT, H,'
         DC    CL40'  HELP, IDEF, ITRACE, L, LAST, M, N,    '
         DC    CL40'  NODEF, O, P, R, S, SAVE, SET, T, W,   '
         DC    CL40'  WHALF, WFULL, WHERE AND ZAP.          '
INVMEM   DC    CL20'MEMBER NOT FOUND'
WRITERR  DC    CL20'WRITE NOT ALLOWED'
NOSUCH   DC    CL20'COMMAND NOT FOUND'
ASCIIMSG DC    CL20'ASCII TRANSLATION'
EBCDCMSG DC    CL20'EBCDIC TRANSLATION'
HELPFAIL DC    CL20'SUBCOMMAND NOT FOUND'
INVFMSG  DC    CL20'NO FORWARD CHAIN'
INVBMSG  DC    CL20'NO BACKWARD CHAIN'
CALCMSG  DC    CL20'CALCULATED VALUE:'
INVHEX   DC    CL20'INVALID HEXADECIMAL'
INVEXP   DC    CL20'SYNTAX ERROR COL. XX'
TGETTOO  DC    CL20'IGNORED, > 40 BYTES '
INVALIDX DC    CL20'CCHHR NOT IN DATASET'
TABFULL  DC    CL20'DEFINE TABLE FULL'
REDEFMSG DC    CL20'SYMBOL REDEFINED'
PASTBUF  DC    CL20'BEYOND END OF BUFFER'
INVDELIM DC    CL20'NO ENDING DELIMITER'
DEFRESET DC    CL20'DEFINE TABLE RESET'
DEFINED  DC    CL20'SYMBOL ADDED      '
REC0INV  DC    CL20'RECORD 0 INVALID'
TTRLARGE DC    CL20'TTR TOO LARGE'
INVCOM   DC    CL20'INVALID COMMAND'
NOOPERND DC    CL20'OPERAND REQUIRED'
NOMCOM   DC    CL20'NOT PARTITIONED'
INVOPCOD DC    CL20'INVALID OP CODE '
INVDEC   DC    CL20'INVALID DECIMAL'
TTRSMALL DC    CL20'TTR < 000001 INVALID'
LENERR   DC    CL20'LENGTH INVALID'
FLOATMSG DC    CL20'FLOATING POINT:'
STORMSG  DC    CL20'NOTE: NOT UPDATING'
MUSTZAPM DC    CL20'**** ZAP  NEEDED ****'
IDEFMASK DC    CL16' SYMBOL   OFFSET'
ITRMASK  DC    CL11' TTR   OFFS'
         SPACE 4
*  CONSTANTS FOR 'FLOAT' COMMAND
         SPACE 2
         DS    0D
CVFCFUDG DC    XL8'4110000000000010'    FUDGE FACTOR FOR CONVERSION
CVFCWZ   DC    XL8'4100000000000000'    UN-NORMALIZER
EXPOVFLW DC    XL8'7FFFFFFFFFFFFF00'    CHECK FOR EXP OVERFLOW
CVDPFTH  DC    X'401999999999999A'
*
*  HEX TO CHAR HEX TRTAB
*
         DC    C'0123456789ABCDEF'
TRHEX    EQU   *-256
         SPACE 2
*
*  DUMP FORMAT TRTAB (*** ASCII ***)
*
TRCHARA  DC    256C'.'
         ORG   TRCHARA+X'20'
         DC    C' !"#$%&&''()*+,-./0123456789:;<=>?'
         ORG   TRCHARA+X'40'
         DC    C'@ABCDEFGHIJKLMNOPQRSTUVWXYZ...._'
         ORG   TRCHARA+X'60'
         DC    X'79818283848586878889919293949596'
         ORG   TRCHARA+X'70'
         DC    X'979899A2A3A4A5A6A7A8A94B4F4B5F4B'
         ORG   TRCHARA+X'A0'
         DC    C' !"#$%&&''()*+,-./'
         DC    C'0123456789'
         DC    C':;<=>?'
         ORG   TRCHARA+X'C0'
         DC    C'@ABCDEFGHIJKLMNOPQRSTUVWXYZ...._'
         ORG   TRCHARA+X'E0'
         DC    X'79818283848586878889919293949596'
         ORG   TRCHARA+X'F0'
         DC    X'979899A2A3A4A5A6A7A8A94B4F4B5F4B'
         SPACE 1
         ORG   ,
         SPACE 3
*
*  DUMP FORMAT TRTAB (*** EBCDIC ***)
*
TRCHARE  DC    256C'.'
         ORG   TRCHARE+C' '
         DC    C' '
         ORG   TRCHARE+X'4A'            CENT SIGN
         DC    X'4A',C'.<(+×&&'
         ORG   TRCHARE+X'5A'            EXCLAMATION PT
         DC    X'5A',C'$*);^-/'
         ORG   TRCHARE+C','
         DC    C',%_>?'
         ORG   TRCHARE+C':'
         DC    C':#@''=',X'7F'          DOUBLE QUOTE
         ORG   TRCHARE+X'81'
         DC    9AL1(*-TRCHARE)          LOWER CASE A-I
         ORG   TRCHARE+X'91'
         DC    9AL1(*-TRCHARE)          LOWER CASE J-R
         ORG   TRCHARE+X'A2'
         DC    8AL1(*-TRCHARE)          LOWER CASE S-Z
         ORG   TRCHARE+C'A'
         DC    9AL1(*-TRCHARE)          UPPER CASE A-I
         ORG   TRCHARE+C'J'
         DC    9AL1(*-TRCHARE)          UPPER CASE J-R
         ORG   TRCHARE+C'S'
         DC    8AL1(*-TRCHARE)          UPPER CASE S-Z
         ORG   TRCHARE+C'0'
         DC    10AL1(*-TRCHARE)         NUMBERS
         SPACE 1
         ORG   ,
         SPACE 5
EDMASK   DC    X'402020202020202020202120'
BYTES    DC    X'070C0C111217171C'      TABS FOR CARET ON SCREEN
*
*
*  CHAR HEX TO HEX TRTAB
*
         DC    X'0A0B0C0D0E0F'
         DC    41C'.'
         DC    X'00010203040506070809'
TRHEXX   EQU   *-256+6
         SPACE 2
YESSYMB  EQU   X'FF'                    EXP LOOK AT SYMBOL TAB
NOSYMB   EQU   X'00'                    EXP LOOK AT SYMBOL TAB
         SPACE 1
YESTRACE EQU   X'00'                    TRACE IN EFFECT
NOTRACE  EQU   X'FF'                    NO TRACE
         SPACE 1
YESCONTL EQU   X'80'                    SCAN CONTINUE IS OK
YESCONTS EQU   X'40'                    S,EX,O,N NO OPERANDS OK
YESCONTT EQU   X'20'                    SET NO OPERAND OK
         SPACE 1
YESSYN   EQU   X'FF'                    SYNAD I/O ERROR HAS OCCURRED
NOSYN    EQU   X'00'                    NO ERROR HAS OCCURRED
         SPACE 2
         SPACE 1
GOD      EQU   X'FF'                    ONLY HE CAN CHANGE HIS MIND
NOGOD    EQU   X'00'                    TOUGH BANANAS
         SPACE 1
YESEOF   EQU   X'FF'                    DO NOT IGNORE EOF'S
NOEOF    EQU   X'00'                    TREAT EOF'S AS DATA BLK
         SPACE 1
CHGIDR   EQU   X'FF'                    WE HAVE CHANGED THE IDR
NOCHGIDR EQU   X'00'                    WE HAVE NOT UPDATED IT YET
 TITLE 'ZAP --- COMMAND TABLE'
*
*  COMMAND TABLE
*
         PRINT DATA
COMTAB   DS    0F
         DC    AL1(7),CL8'EXTENTS',AL3(EXTENTS)   LIST OF EXTENTS
         DC    AL1(6),CL8'EBCDIC ',AL3(EBCDIC)    EBCDIC TRANSLATION
         DC    AL1(6),CL8'ITRACE ',AL3(ITRACE)    DISPLAY TRACE TABLE
         DC    AL1(6),CL8'DISASM ',AL3(DISASM)    DISSASEMBLE
         DC    AL1(6),CL8'CHANGE ',AL3(CHANGE#)   SWITCH TO NEW DATASET
         DC    AL1(5),CL8'NODEF  ',AL3(NODEF)     CLEAR DEF TABLE
         DC    AL1(5),CL8'ASCII  ',AL3(ASCII)     ASCII TABLE
         DC    AL1(5),CL8'FLOAT  ',AL3(FLOAT)     D'NNN' EQUIVALENT
         DC    AL1(5),CL8'WHALF  ',AL3(WHALF)     HALF-SIZED WINDOW
         DC    AL1(5),CL8'WFULL  ',AL3(WFULL)     FULL-SIZED WINDOW
         DC    AL1(5),CL8'WHERE  ',AL3(WHERE)     WHERE IN DATA SET
         DC    AL1(4),CL8'LAST   ',AL3(LAST)      DS1LSTAR
         DC    AL1(4),CL8'HELP   ',AL3(HELP#)     GENERAL HELP
         DC    AL1(4),CL8'IDEF   ',AL3(IDEF)      DISPLAY DEF TABLE
         DC    AL1(4),CL8'SAVE   ',AL3(REPLACE)   ZAP THE BLOCK
         DC    AL1(3),CL8'DIS    ',AL3(DIS)       DISASSEMBLE
         DC    AL1(3),CL8'ASM    ',AL3(ASM)       HEX OP CODE FOR MNEM.
         DC    AL1(3),CL8'DCB    ',AL3(DCB)       DCB DATA FOR DATA SET
         DC    AL1(3),CL8'ZAP    ',AL3(REPLACE)   ZAP THE BLOCK
         DC    AL1(3),CL8'END    ',AL3(END)       QUIT
         DC    AL1(3),CL8'SET    ',AL3(SET)       CHANGE REST OF RECORD
         DC    AL1(2),CL8'CC     ',AL3(CC)        CCHHR ADDRESS
         DC    AL1(2),CL8'EX     ',AL3(EXOR)      EXCLUSIVE OR
         DC    AL1(1),CL8'C      ',AL3(CHANGE)    SWITCH TO NEW DATASET
         DC    AL1(1),CL8'S      ',AL3(STORE)     STORE
         DC    AL1(1),CL8'O      ',AL3(OR)        OR
         DC    AL1(1),CL8'N      ',AL3(AND)       AND
         DC    AL1(1),CL8'L      ',AL3(LOCATE)    SEARCH FOR STRING
         DC    AL1(1),CL8'F      ',AL3(LOCATE)    SEARCH FOR STRING
         DC    AL1(1),CL8'X      ',AL3(X)         PCF EXIT
         DC    AL1(1),CL8'M      ',AL3(MEMBER#)   POSITION TO A MEMBER
         DC    AL1(1),CL8'B      ',AL3(BACK)      BACK ONE RECORD
         DC    AL1(1),CL8'D      ',AL3(DISPLAY#)  POINT TO ADDRESS
         DC    AL1(1),CL8'T      ',AL3(TRACK)     POINT TO TRACK
         DC    AL1(1),CL8'H      ',AL3(HELP)      CALL HELP
         DC    AL1(1),CL8'R      ',AL3(RECORD)    POINT TO REL. RECORD
         DC    AL1(1),CL8'P      ',AL3(POINT)     POINT TO GIVEN TTR
         DC    AL1(1),CL8'W      ',AL3(WINDOW)    DEFINE DISPLAY SIZE
         DC    AL1(1),CL8'=      ',AL3(EQUALS)    ADD A DEF ENTRY
         DC    AL1(1),CL8'#      ',AL3(CALC)      EVALUATE EXPRESSION
         DC    AL1(1),CL8'>      ',AL3(FORWARD)   FORWARD IN TRACE TBL
         DC    AL1(1),CL8'<      ',AL3(BACKWARD)  BACKWARD IN TRACE TBL
         DC    AL1(1),CL8'?      ',AL3(OP)        SUBCOMMANDS
         DC    X'FF'
         PRINT NODATA
 TITLE 'ZAP --- LITERALS AND FORMAT 1 DSCB DISPLACEMENTS'
         LTORG
         SPACE 4
F1TBL    DC    CL8'DS1DSNAM',XL2'00'  DISPLACEMENTS FOR FORMAT 1 DSCB
         DC    CL8'DS1FMTID',XL2'2C'
         DC    CL8'DS1DSSN ',XL2'2D'
         DC    CL8'DS1VOLSQ',XL2'33'
         DC    CL8'DS1CREDT',XL2'35'
         DC    CL8'DS1EXPDT',XL2'38'
         DC    CL8'DS1NOEPV',XL2'3B'
         DC    CL8'DS1NOBDB',XL2'3C'
         DC    CL8'DS1SYSCD',XL2'3E'
         DC    CL8'DS1DSORG',XL2'52'
         DC    CL8'DS1RECFM',XL2'54'
         DC    CL8'DS1OPTCD',XL2'55'
         DC    CL8'DS1BLKL ',XL2'56'
         DC    CL8'DS1LRECL',XL2'58'
         DC    CL8'DS1KEYL ',XL2'5A'
         DC    CL8'DS1RKP  ',XL2'5B'
         DC    CL8'DS1DSIND',XL2'5D'
         DC    CL8'DS1SCALO',XL2'5E'
         DC    CL8'DS1LSTAR',XL2'62'
         DC    CL8'DS1TRBAL',XL2'65'
         DC    CL8'DS1EXT1 ',XL2'69'
         DC    CL8'DS1EXT2 ',XL2'73'
         DC    CL8'DS1EXT3 ',XL2'7D'
         DC    CL8'DS1PTRDS',XL2'87'
F1SIZE   EQU   *-F1TBL
         EJECT
         PRINT GEN
DCBMSK   DCB   MACRF=E,DDNAME=DDNAME,DSORG=DA  EXCP LEVEL DCB
DCBUL    EQU   *-DCBMSK
         TITLE 'ZAP --- TSO PARSE DSECTS/CSECTS  -  PDL, PCL, PDE, ETC'
ZAP      CSECT
         PRINT NOGEN
PCL      IKJPARM DSECT=IKJPARMD
         SPACE 2
PDLDSN   IKJPOSIT DSNAME,PROMPT='DATA SET NAME'
         SPACE 2
PDLVOL   IKJKEYWD
         IKJNAME 'VOLUME',SUBFLD=VOLUME
VOLUME   IKJSUBF
VOLVOL   IKJIDENT 'SERIAL',FIRST=ALPHANUM,OTHER=ALPHANUM,MAXLNTH=6
         SPACE 2
         IKJENDP
         SPACE 2
         PRINT NOGEN
         TITLE 'ZAP --- DSECT MASK EXPANSIONS'
JFCB     DSECT
         IEFJFCBN
         SPACE 3
PDE      DSECT ,                        PARSE DESCRIPTOR ELEMENT
PDEPTR   DS    A                        TEXT PTR
PDELEN   DS    H                        LEN
PDEFLAG  DS    X                        FLAGS
PDEFPRES EQU   X'80'                    PARM PRESENT
PDEQUOTE EQU   X'40'                    DSNAME IS QUOTED
         DS    X                        RESERVED
PDEL     EQU   *-PDE
         SPACE 3
         PRINT NOGEN
         DCBD  DSORG=DA,DEVD=DA        DCB DSECT
         SPACE 3
CVT      DSECT
         CVT                            CVT EXPANSION
         SPACE 3
         DEBDS                          DEB EXPANSION
         SPACE 3
DSCB     DSECT
         IECSDSL1 1                     FORMAT 1 DSCB EXPANSION
DSCB4    DSECT
         IECSDSL1 4                     FORMAT 4 DSCB EXPANSION
         PRINT GEN
 TITLE 'ZAP --- ASMZASM --- EQUIVALENT HEX OPERATION CODE FOR MNEMONIC'
*
*  ASSEMBLE OR DISASSEMBLE.
*
         SPACE 2
ASMZASM  CSECT ,
         SPACE 1
         SAVE  (14,12),,*
         SPACE 1
         LR    R12,R15                  BASE
         USING ASMZASM,R12
         SPACE 2
*
*  REGISTERS -- R1 = PTR TO BUFF LOC OF OBJECT CODE OR MNEMONIC
*           R7, R0 = PTR TO OUTPUT BUFFER  (33 BYTES)
*           R9, R2 = PTR TO 5 DOUBLEWORDS WORKAREA
*  OUTPUT:      R15= RC
*               R1 = INSTR LEN IF R15=0 FOR DISASSEMBLE
         SPACE 2
JCJWORK  DSECT
DOUBLE   DS    D
DWORK    DS    D
WORKAREA DS    6C
FLAGS    DS    X
         SPACE 2
ASMZASM  CSECT
         SPACE 3
         USING JCJWORK,R9               WORK AREA
         LR    R9,R2                    SAVE WORK BASE
         LR    R7,R0                    SAVE OUTPUT BUFF PTR
         SPACE 3
         LTR   R1,R1                    ASM OR DISASM?
         BM    DISASSM                  GUESS...
         EJECT
*  ASM  ---  R1 = PTR TO CL5'MNEMONIC'
         SPACE 2
         LA    R2,OPCODES               TABLE
         L     R15,=A(OPEND-OPLEN)      END BXLE
         LA    R14,OPLEN                LENGTH
         SPACE 1
OPLOOP   CLC   0(5,R1),0(R2)            THIS ONE (KLUGE)
         BNE   GOLOOP                   YES
         CLI   5(R2),C'K'        ***    IF OPTYPE='K'
         BNE   GOTOP             ***      AND OPCODE>=X'9C'
         CLI   6(R2),X'9C'       ***      THEN USE THE NEXT TABLE ENTRY
         BL    GOTOP
GOLOOP   BXLE  R2,R14,OPLOOP            TRY ALL POSSIBLES
         SPACE 1
BADRET   LA    R15,4                    INVALID OP CODE
         B     RETURN                   BYE
         SPACE 3
GOTOP    MVC   0(8,R7),=C'OP CODE:'     HEADER DATA
         UNPK  DOUBLE(3),6(2,R2)        OPERATION CODE
         TR    DOUBLE(2),HEXTAB         MAKE HEXADECIMAL
         MVC   10(2,R7),DOUBLE          MOVE TO SCREEN
*
         TM    5(R2),X'C0'              NORMAL OPERATION?
         BNZ   GOODRET                  YES, BRANCH
         SR    R1,R1
         IC    R1,5(,R2)                ATTRIBUTE BYTE
         TM    5(R2),X'20'              EXTENTED MNEMONIC BRANCH?
         BZ    BRANCHI                  YES, BRANCH
         N     R1,=X'0000001F'          DROP OFF FLAG BIT
         STC   R1,DOUBLE+4              READY FOR CONVERSION
         UNPK  DOUBLE(3),DOUBLE+4(2)
         TR    DOUBLE(2),HEXTAB         MAKE HEXADECIMAL
         MVC   14(12,R7),=C'SECOND BYTE:'
         MVC   27(2,R7),DOUBLE          SECOND OPERATION CODE DIGIT
         B     GOODRET
         SPACE 3
BRANCHI  UNPK  DOUBLE(3),5(2,R2)       MASK DIGIT
         TR    DOUBLE+1(1),HEXTAB                FOR BRANCH INSTR.
         MVC   14(10,R7),=C'MASK BYTE:'
         MVC   26(1,R7),DOUBLE+1
         SPACE 2
GOODRET  XR    R15,R15                  RC=0
RETURN   L     R14,12(,R13)             RESTORE R14  **** NOTE R0 NOT
         LM    R2,R12,12+16(R13)        REST REGS         RESTORED ****
         BR    R14                      BYE
 TITLE 'ZAP --- ASMZASM --- PSEUDO-ASSEMBLY EQUIVALENT OF RECORD DATA'
DISASSM  LPR   R1,R1                    GET POS 1ST
         SPACE 2
*
*  THIS ROUTINE WRITTEN BY JCJ 1/75
*
         SPACE 2
         MVC   DWORK(8),0(R1)           ALIGN POSSIBLE INSTRUCTION
         LA    R6,DWORK                 POINT TO INSTR
         SPACE 2
***********************************************************************
*                                                                     *
* DISASSEM                                                            *
* RETURNS:                                                            *
*     R15 - LENGTH OF INSTRUCTION OR ZERO IF NON-VALID OPCODE         *
*     FILLED IN SCREEN BUFFER IF OPCODE WAS VALID                     *
*                                                                     *
*                                                                     *
* NOTE WE GO THROUGH SOME CONTORTIONS IN ORDER TO BE ABLE TO SPECIFY  *
* THE OPCODE FLAG FIELDS IN EBCDIC CHARACTER FORM (IMAGE-ENTERABLE).  *
*                                                                     *
***********************************************************************
         SPACE 2
         LA    R2,OPCODES               START OF OPERATION FIELD
         L     R15,=A(OPEND-OPLEN)      TABLE LENGTH
         LA    R14,OPLEN                TABLE WIDTH
         SPACE 2
OPLOOP2  CLC   0(1,R1),OPLEN-1(R2)      THIS ENTRY?
         BE    FOUNDIT                  HERE IT IS
         BXLE  R2,R14,OPLOOP2           CONTINUE SEARCHING
         B     DC                       NOT IN TABLE, GENERATE A  DC
         SPACE 2
FOUNDIT  LA    R4,1                     GET F'1' FOR LATER
         LR    R1,R2                    PNT TO PROPER MNENOMIC
         MVC   0(5,R7),0(R1)            MOVE IN MNENOMIC
         MVC   FLAGS(1),5(R1)           GET THE FLAG BYTE
         XR    R15,R15                  READY FOR IC
         IC    R15,1(,R6)               GET THE REG BYTE
         LR    R2,R15                   GET IT IN R2 FOR LATER
         SPACE 1
* NOW CHECK IF IT IS AN EXTENDED MNENOMIC INSTRUCTION
         SPACE 1
         CLI   0(R6),X'07'              BCR INSTRUCTION?
         BE    GETMNE                   YES, BRANCH
         CLI   0(R6),X'47'              BC INSTRUCTION?
         BE    GETMNE                   YES, BRANCH
         CLI   FLAGS,X'D2'              2-BYTE OPERATION CODE?
         BNE   GETTYPE                  NO, BRANCH
         CLI   1(R6),X'00'              FIRST ENTRY DESIRED?
         BE    GETTYPE                 YES, ALREADY SET RIGHT
         LA    R2,KTABLE               START OF KTABLE
         L     R15,=A(KEND-KLEN)       TABLE END
         LA    R14,KLEN                TABLE WIDTH
         SPACE 2
GET2LOOP CLC   DWORK(2),5(R2)          THIS ENTRY?
         BE    FOUNDEXT                YES, BRANCH
         BXLE  R2,R14,GET2LOOP         TRY THE NEXT ENTRY
         B     DC                      NOT IN THE TABLE, GENERATE A  DC
*
FOUNDEXT MVC   0(5,R7),0(R2)           FOUND IT, MODIFY THE OP CODE
         B     GETTYPE
         SPACE 2
GETMNE   SRDL  R2,4                     SHIFT TO CLEAR OUT REG NIBBLE
         MH    R2,H6                    INDEX INTO TABLE
         LA    R1,MNEOPS(R2)            PNT TO TABLE ENTRY
         MVC   0(3,R7),0(R1)            MOVE IN PRIMARY MNEMONIC
         CLI   3(R1),C' '               SECONDARY MNENOMIC PRESENT?
         BE    GETMNE#                  NO - CONTINUE ON
         MVC   5(3,R7),3(R1)            GET SECONDARY ONE
         LR    R14,R7                   SAVE CURR BUFFER PNTR
         AH    R7,H6                    AND UP WORK BUFFER PNTR
         SPACE 1
GETMNE#  TM    FLAGS,X'80'              NON 2 BYTE INSTRUCTION?
         BO    GETINST                  YES - LEAVE
         CLI   3(R1),C' '               TWO MNENOMICS NEEDED?
         BE    ONEMNE                   NO - SO DO ONE DUMMY...
         BAL   R5,RLOOP                 PUT IN A 'R' (RR TYPE)
         SPACE 1
ONEMNE   LR    R14,R7                   PNT TO CURR MNEMONIC
         LA    R5,GETINST               FAKE OUT A BAL AND RETURN
         SPACE 2
RLOOP    ALR   R14,R4                   PNT TO NEXT CHAR
         CLI   0(R14),C' '              A BLANK WAITING FOR 'R'?
         BNE   RLOOP                    NO - INCREMENT
         MVI   0(R14),C'R'              YES - PUT IN THE 'R'
         BR    R5
         SPACE 2
GETINST  CLI   1(R7),C'C'               GOT AN EXTENDED MNENOMIC?
         BNE   *+8                      YES - SKIP THE BIT RESET
         OI    FLAGS,X'02'              NO - FAKE OUT A RR(OR RX) TYPE
         SPACE 2
GETTYPE  LA    R7,7(,R7)                INCREMENT LINE PNTR
         TM    FLAGS,X'90'              IS LENGTH FOUR BYTES?
         BZ    GETRR                    NO - GET 2 BYTE INSTRUCTION
         BM    GETSS                    NO - GET 6 BYTE INSTRUCTION
         EJECT
*
* HAVE AN FOUR BYTE TYPE WHEN WE FALL THROUGH TO HERE
*
         SPACE 2
GETRX    CLI   FLAGS,C'M'               DO WE WANT A REGISTER?
         BNH   RXDISP                   NO - GO GET DISP FIELD
         LR    R2,R15                   GET REG BYTE BACK
         SRDL  R2,4                     SHIFT TO GET FIRST REG
         BAL   R14,GETNUM               PUT CHAR VALUE IN SCREEN
         BAL   R14,COMMA                PUT IN A COMMA
         CLI   FLAGS,C'R'               TWO REGISTERS NEEDED?
         BNE   RXDISP                   NO - GET DISPLACEMENT
         SLDL  R2,4                     GET THE OTHER REG
         BAL   R14,GETNUM               AND PUT IT IN SCREEN
         BAL   R14,COMMA                MOVE IN A COMMA
RXDISP   BAL   R5,GETDISP               GET THE DISP FIELD
         TM    FLAGS,X'04'              NEED AN INDEX REG?
         BZ    RXNOIND                  NO - GET THE BASE ONLY
         SLDL  R2,4                     AND PICK UP THE INDEX REG
         BAL   R14,GETNUM               PUT IT IN SCREEN
         BAL   R14,COMMA                MOVE IN A COMMA
RXNOIND  BAL   R5,GETBASE               GET THE BASE BYTE
         CLI   FLAGS,C'L'               IMMEDIATE TYPE?
         BNE   DISLEAVE                 NO - LEAVE
         SPACE
* WE HAVE AN SI TYPE HERE
         SPACE
         MVC   0(3,R7),SICHAR           MOVE IN ,X'
         UNPK  3(3,R7),1(2,R6)          MAKE THE OPERAND 'DECIMAL'
         TR    3(2,R7),HEXTAB           TRANSLATE IT TO EBCDIC
         MVI   5(R7),C''''              MOVE IN AN ENDING QUOTE
         B     DISLEAVE                 AND LEAVE
         SPACE 2
*
* TWO BYTE INSTRUCTIONS
*
GETRR    LR    R2,R15                   GET REG BYTE BACK
         CLI   FLAGS,C'+'               SVC?
         BE    RRSVC                    YES - GO PROCESS IT
         BL    MNENT                    EXTENDED MNENOMIC HERE
         SPACE 1
GETRR#   SRDL  R2,4                     GET FIRST REGISTER VALUE
         BAL   R14,GETNUM               MOVE IN THE CHAR VALUE
         CLI   0(R6),X'04'              SPM INST?
         BE    DISLEAVE                 YES - LEAVE
         BAL   R14,COMMA                MOVE IN A COMMA
MNENT    XR    R2,R2                    ZERO PARM REG
         SLDL  R2,4                     GET OTHER REG
RRSVC    BAL   R14,GETNUM               MOVE IN THE CHAR AGAIN
         B     DISLEAVE                 GO AWAY
         EJECT
*
* THIS SECTION HANDLES 6 BYTE INSTRUCTIONS
*
GETSS    LR    R0,R2                    SAVE THE REG BYTE (LENGTH)
         BAL   R5,GETDISP               GEN FIRST DISPLACEMENT
         LR    R2,R0                    GET THE REG BYTE BACK
         TM    FLAGS,X'01'              ONLY ONE LENGTH FIELD?
         BO    *+8                      YES - SKIP THE REG SHIFT
         SRDL  R2,4                     GET THE FIRST LENGTH FIELD
         BAL   R14,GETNUMI              MOVE IN THE CHAR VALUE
         BAL   R14,COMMA                MOVE IN A COMMA
         BAL   R5,GETBASE               GET THE BASE FIELD
         BAL   R14,COMMA                MOVE IN A COMMA
         LH    R2,4(,R6)                GET SECOND DISP FIELD
         BAL   R5,GETDISP#              MOVE IT TO THE SCREEN
         TM    FLAGS,X'06'              IMMEDIATE FOR SRP?
         BO    SSI3                     YES, BRANCH
         TM    FLAGS,X'01'              SINGLE LENGTH?
         BO    SSL1                     YES - SKIP 2ND LEN PROCESSING
         SLDL  R2,4                     GET 2ND LENGTH
         BAL   R14,GETNUMI              AND MOVE IT TO SCREEN
         BAL   R14,COMMA                A DELIMITER OR TWO
SSL1     IC    R2,4(,R6)                GET SECOND BASE FIELD
         BAL   R5,GETBASE#              GET THE BASE IN SCREEN
         B     DISLEAVE
SSI3     IC    R2,4(,R6)                SECOND BASE REGISTER
         BAL   R5,GETBASE#              ADD THE BASE REGISTER
         BAL   R14,COMMA                ADD A COMMA
         SLDL  R2,4                     GET THE IMMEDIATE VALUE
         BAL   R14,GETNUM                  AND ADD IT TOO
         SPACE 1
DISLEAVE TM    FLAGS,X'10'              DO WE HAVE A BAD LENGTH?
         BZ    *+8                      NO - HOP OVER THE BIT RESET
         NI    FLAGS,255-X'40'          FIX FOR CORRECT LENGTH
         XR    R1,R1                    SET UP FOR IC
         IC    R1,FLAGS                 GET THE LENGTH
         SRL   R1,5                     WIPE OUT FLAG BITS  = LENGTH
         B     GOODRET                  EXIT OK
         SPACE 2
*
*    THIS SECTION HANDLES INVALID OPERATION CODES
*
DC       MVC   0(9,R7),=C'DC     X'''   MAKE IT INTO A  DC  INSTRUCTION
         UNPK  9(5,R7),0(3,R6)          SPREAD OUT THE HEX DIGITS
         TR    9(4,R7),HEXTAB           MAKE HEXADECIMAL
         MVI   13(R7),C''''             ADD THE ENDING QUOTE
         LA    R1,2                     INSTRUCTION LENGTH OF TWO
         B     GOODRET                  RETURN
  EJECT
*
* DISASSEMBLER BAL ROUTINES - USED TO SAVE BYTES HERE AND THERE
*
         SPACE 2
* THIS SECTION GETS THE BASE REG
         SPACE
GETBASE  IC    R2,2(,R6)      GET THE BASE
GETBASE# SRL   R2,4           SHIFT OUT GARBAGE
         BAL   R14,GETNUM     GO MOVE TO SCREEN
         MVI   0(R7),C')'     PUT IN A R-PAREN
         ALR   R7,R4          INCREMENT LINE PNTR
         BR    R5             GO TO CALLER
         SPACE 1
* THIS SECTION GETS THE DISPLACEMENT FIELD
         SPACE
GETDISP  LH    R2,2(,R6)      LOAD THE DISPLACEMENT
GETDISP# N     R2,DISPMASK    WIPE OUT BASE BITS
         BAL   R14,GETNUM     DO THE MOVE TO SCREEN
         CLI   FLAGS,C'J'     IS IT SVCX OR DIAGNOSE?
         BE    DISLEAVE       YES - GO AWAY
         MVI   0(R7),C'('     ELSE MOVE IN A L-PAREN
         ALR   R7,R4          INCREMENT LINE PNTR
         BR    R5             GO TO CALLER
         SPACE
COMMA    MVI   0(R7),C','     MOVE IN A COMMA
         ALR   R7,R4          INCREMENT PNTR
         BR    R14            GO TO CALLER
         SPACE
*
* THIS ROUTINE PUTS THE CHAR VALUE OF THE CONTENTS OF R2 INTO THE
* SCREEN(VIA R7) AND UPDATES R7 (POINT TO THE NEXT AVAILABLE POSITION)
*
         SPACE 2
GETNUMI  ALR   R2,R4                    INCREMENT FOR A LENGTH FIX
GETNUM   CVD   R2,DOUBLE                GET IT IN DECIMAL
         MVC   WORKAREA(6),EDITMASK     SET UP FOR EDIT
         LA    R15,WORKAREA+5           PNT TO END OF AREA
         LR    R1,R15                   SET UP R1 FOR EDMK
         EDMK  WORKAREA(6),DOUBLE+5     DO THE EDIT
         SR    R15,R1                   GET THE EXECUTE LENGTH
         EX    R15,NUMMOVE              MOVE THE VALUE TO THE SCREEN
         LA    R7,1(R15,R7)             UPDATE THE SCREEN PNTR
         XR    R2,R2                    ZERO OUR WORK REG
         BR    R14                      GO HOME
NUMMOVE  MVC   0(0,R7),0(R1)            <<< EXECUTED >>>
 EJECT
DISPMASK DC    0F'0',XL4'00000FFF'
H6       DC    H'6'
EDITMASK DC    X'402020202120'
SICHAR   DC    C',X'''
         DC    C'0123456789ABCDEF'
HEXTAB   EQU   *-256
         SPACE 5
MNEOPS   DC    CL6'NOP   '        EXTENDED BRANCH MNEMONICS
         DC    CL6'BO    '
         DC    CL6'BH BP '
         DC    CL6'BC    '
         DC    CL6'BL BM '
         DC    CL6'BC    '
         DC    CL6'BC    '
         DC    CL6'BNEBNZ'
         DC    CL6'BE BZ '
         DC    CL6'BC    '
         DC    CL6'BC    '
         DC    CL6'BNLBNM'
         DC    CL6'BC    '
         DC    CL6'BNHBNP'
         DC    CL6'BNO   '
         DC    CL6'B     '
         SPACE 2
KTABLE   DC    CL5'SIOF',X'9C01'  TWO-BYTE OPERATION CODE INSTRUCTIONS
         DC    CL5'CLRIO',X'9D01'
         DC    CL5'HDV',X'9E01'
         DC    CL5'STIDP',X'B202'
         DC    CL5'STIDC',X'B203'
         DC    CL5'SCK',X'B204'
         DC    CL5'STCK',X'B205'
         DC    CL5'SCKC',X'B206'
         DC    CL5'STCKC',X'B207'
         DC    CL5'SPT',X'B208'
         DC    CL5'STPT',X'B209'
         DC    CL5'SPKA',X'B20A'
         DC    CL5'IPK',X'B20B'
         DC    CL5'PTLB',X'B20D'
         DC    CL5'SPX',X'B210'
         DC    CL5'STPX',X'B211'
         DC    CL5'STAP',X'B212'
         DC    CL5'RRB',X'B213'
KEND     EQU   *
KLEN     EQU   7
 TITLE 'ZAP --- ASMZASM ---   O P C O D E   T A B L E'
*
*
*   FOLLOWING IS A TABLE OF POSSIBLE FLAG FIELDS IN THE OPCODES TABLE:
*
* RR TYPE:
*    C'('   X'4D' - EXTENDED MNEMONIC
*    C'+'   X'4E' - SVC       IMED
*    C'×'   X'4F' - NORMAL RR TYPE
*    C'&'   X'50' - SPM TYPE
*
* RX TYPE:
*    C'O'   X'D6' - INDEX REGISTER USED   R1,D2(X2,B2)
*    C'M'   X'D4' - EXTENDED MNENOMIC     D2(X2,B2)
*    C'L'   X'D3' - SI TYPE               D1(B1),I2
*    C'J'   X'D1' - DIAGNOSE              I     --- (IMMEDIATE)
*    C'K'   X'D2' - DISP(BASE) TYPE       D1(B1)
*    C'R'   X'D9' - BXLE,BXH,STM,LM       R1,R3,D2(B2)
*    C'Q'   X'D8' - REG SHIFT TYPE        R1,D2(B2)
*
* SS TYPE:
*    C'B'   X'C2' - TWO LENGTHS REQUIRED
*    C'C'   X'C3' - ONLY ONE LENGTH
*    C'F'   X'C6' - ONE LENGTH AND AN IMMEDIATE VALUE (LIKE SRP)
*
*
* SPECIAL TYPES:   FOR EXTENDED MNENOMIC DECODING ONLY
*           X'0N'     -  FOR OPCODE=X'07' FOR BCR MASKS
*           X'0N'     -  FOR OPCODE=X'47' FOR BC MASKS
*           X'20+NN'  -  FOR TWO-OPERATION INSTRUCTIONS WHERE NN IS
*                          THE SECOND OPERATION CODE DIGITS (FOR FIRST
*                          OPERATION CODES 9C, 9D, 9E, 9F AND B2).
*
*
*
*  TABLE FORMAT:
*
*        CL5'MNEMONIC',C'FLAG',X'OPCODE'
*
         PRINT NOGEN
OPCODES  DS    0C
         OP    SPM,×,04
         OP    BALR,×,05
         OP    BCTR,×,06
         OP    BCR,'(',07
         OP    SSK,×,08
         OP    ISK,×,09
         OP    SVC,+,0A
         OP    MVCL,×,0E
         OP    CLCL,×,0F
         OP    LPR,×,10
         OP    LNR,×,11
         OP    LTR,×,12
         OP    LCR,×,13
         OP    NR,×,14
         OP    CLR,×,15
         OP    OR,×,16
         OP    XR,×,17
         OP    LR,×,18
         OP    CR,×,19
         OP    AR,×,1A
         OP    SR,×,1B
         OP    MR,×,1C
         OP    DR,×,1D
         OP    ALR,×,1E
         OP    SLR,×,1F
         OP    LPDR,×,20
         OP    LNDR,×,21
         OP    LTDR,×,22
         OP    LCDR,×,23
         OP    HDR,×,24
         OP    LRDR,×,25
         OP    MXR,×,26
         OP    MXDR,×,27
         OP    LDR,×,28
         OP    CDR,×,29
         OP    ADR,×,2A
         OP    SDR,×,2B
         OP    MDR,×,2C
         OP    DDR,×,2D
         OP    AWR,×,2E
         OP    SWR,×,2F
         OP    LPER,×,30
         OP    LNER,×,31
         OP    LTER,×,32
         OP    LCER,×,33
         OP    HER,×,34
         OP    LRER,×,35
         OP    AXR,×,36
         OP    SXR,×,37
         OP    LER,×,38
         OP    CER,×,39
         OP    AER,×,3A
         OP    SER,×,3B
         OP    MER,×,3C
         OP    DER,×,3D
         OP    AUR,×,3E
         OP    SUR,×,3F
         OP    STH,O,40
         OP    LA,O,41
         OP    STC,O,42
         OP    IC,O,43
         OP    EX,O,44
         OP    BAL,O,45
         OP    BCT,O,46
         OP    BC,M,47
         OP    LH,O,48
         OP    CH,O,49
         OP    AH,O,4A
         OP    SH,O,4B
         OP    MH,O,4C
         OP    CVD,O,4E
         OP    CVB,O,4F
         OP    ST,O,50
         OP    N,O,54
         OP    CL,O,55
         OP    O,O,56
         OP    X,O,57
         OP    L,O,58
         OP    C,O,59
         OP    A,O,5A
         OP    S,O,5B
         OP    M,O,5C
         OP    D,O,5D
         OP    AL,O,5E
         OP    SL,O,5F
         OP    STD,O,60
         OP    MXD,O,67
         OP    LD,O,68
         OP    CD,O,69
         OP    AD,O,6A
         OP    SD,O,6B
         OP    MD,O,6C
         OP    DD,O,6D
         OP    AW,O,6E
         OP    SW,O,6F
         OP    STE,O,70
         OP    LE,O,78
         OP    CE,O,79
         OP    AE,O,7A
         OP    SE,O,7B
         OP    ME,O,7C
         OP    DE,O,7D
         OP    AU,O,7E
         OP    SU,O,7F
         OP    SSM,K,80
         OP    LPSW,K,82
         OP    DIAG,J,83
         OP    WRD,L,84
         OP    RDD,L,85
         OP    BXH,R,86
         OP    BXLE,R,87
         OP    SRL,Q,88
         OP    SLL,Q,89
         OP    SRA,Q,8A
         OP    SLA,Q,8B
         OP    SRDL,Q,8C
         OP    SLDL,Q,8D
         OP    SRDA,Q,8E
         OP    SLDA,Q,8F
         OP    STM,R,90
         OP    TM,L,91
         OP    MVI,L,92
         OP    TS,K,93
         OP    NI,L,94
         OP    CLI,L,95
         OP    OI,L,96
         OP    XI,L,97
         OP    LM,R,98
         OP    SIO,K,9C
         OP    TIO,K,9D
         OP    HIO,K,9E
         OP    TCH,K,9F
         OP    STNSM,L,AC
         OP    STOSM,L,AD
         OP    SIGP,R,AE
         OP    MC,L,AF
         OP    LRA,O,B1
         OP    STIDP,K,B2
         OP    STCTL,R,B6
         OP    LCTL,R,B7
         OP    CS,R,BA
         OP    CDS,R,BB
         OP    CLM,R,BD
         OP    STCM,R,BE
         OP    ICM,R,BF
         OP    MVN,C,D1
         OP    MVC,C,D2
         OP    MVZ,C,D3
         OP    NC,C,D4
         OP    CLC,C,D5
         OP    OC,C,D6
         OP    XC,C,D7
         OP    TR,C,DC
         OP    TRT,C,DD
         OP    ED,C,DE
         OP    EDMK,C,DF
         OP    SRP,F,F0
         OP    MVO,B,F1
         OP    PACK,B,F2
         OP    UNPK,B,F3
         OP    ZAP,B,F8
         OP    CP,B,F9
         OP    AP,B,FA
         OP    SP,B,FB
         OP    MP,B,FC
         OP    DP,B,FD
         OP    NOPR,X00,07
         OP    NOP,X00,47
         OP    BOR,X01,07
         OP    BO,X01,47
         OP    BHR,X02,07
         OP    BH,X02,47
         OP    BPR,X02,07
         OP    BP,X02,47
         OP    BLR,X04,07
         OP    BL,X04,47
         OP    BMR,X04,07
         OP    BM,X04,47
         OP    BNZR,X07,07
         OP    BNZ,X07,47
         OP    BNER,X07,07
         OP    BNE,X07,47
         OP    BER,X08,07
         OP    BE,X08,47
         OP    BZR,X08,07
         OP    BZ,X08,47
         OP    BNLR,X0B,07
         OP    BNL,X0B,47
         OP    BNMR,X0B,07
         OP    BNM,X0B,47
         OP    BNHR,X0D,07
         OP    BNH,X0D,47
         OP    BNPR,X0D,07
         OP    BNP,X0D,47
         OP    BNOR,X0E,07
         OP    BNO,X0E,47
         OP    BR,X0F,07
         OP    B,X0F,47
         OP    SIO,X20,9C
         OP    SIOF,X21,9C
         OP    TIO,X20,9D
         OP    CLRIO,X21,9D
         OP    HIO,X20,9E
         OP    HDV,X21,9E
         OP    TCH,X20,9F
         OP    STIDP,X22,B2
         OP    STIDC,X23,B2
         OP    SCK,X24,B2
         OP    STCK,X25,B2
         OP    SCKC,X26,B2
         OP    STCKC,X27,B2
         OP    SPT,X28,B2
         OP    STPT,X29,B2
         OP    SPKA,X2B,B2
         OP    IPK,X2A,B2
         OP    PTBL,X2D,B2
         OP    SPX,X30,B2
         OP    STPX,X31,B2
         OP    STAP,X32,B2
         OP    RRB,X33,B2
OPEND    EQU   *
OPLEN    EQU   7
         TITLE 'ZAP -- ASMZASM --  LITERALS'
         LTORG
         SPACE 2
         END   ZAP
