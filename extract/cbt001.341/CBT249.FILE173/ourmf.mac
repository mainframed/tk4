*PROCESS F(I),M,NIS,X(S),STMT,GS,OFFSET,OPT(2),MAR(2,72);
   /* OUR-MF, THE ROLL-YOUR-OWN MEASUREMENT FACILITY*/
 OURMF: PROC(PARM) OPTIONS(MAIN );
 /********************************************************************/
 /* PROCEDURE:    OURMF                                              */
 /* FUNCTION:     WRITE A TRACE DATASET FROM THE DATA IN STATDIE'S   */
 /*               PAGABLE BUFFERS, COLLECT PAGING AND SWAP COUNTS,   */
 /*               AND OPTIONALLY COLLECT WORKLOAD ACTIVITY           */
 /* LANGUAGE:     PLIX  RELEASE 3.0                                  */
 /* SYSTEM:       MVS RELEASE 3.7 WITH SUPERVISOR 2 SU               */
 /* ATTRIBUTES:   AUTHORIZED                                         */
 /* EXTERNAL:     CALLS ENTRY POINTS OF PLIMISC.                     */
 /*               STATDIE MUST BE INITIALIZED AND RUNNING.           */
 /* MACROS:       DYNALLOC,IHAPSA,CVT,IHALCCA,IRARMCT,IRARMCA,IHAPVT */
 /* VERSION:      MAY 1977                                           */
 /* AUTHOR:       HOWARD GILBERT                                     */
 /*               YALE COMPUTER CENTER                               */
 /*               175 WHITNEY AVE                                    */
 /*               NEW HAVEN, CT. 06520                               */
 /*               203 432-4080                                       */
 /****************************************************************   */
 /* SYSTEM INTEGRITY CONSIDERATIONS:                                 */
 /*    THIS MODULE IS APF AUTHORIZED ONLY TO PERMIT IT TO USE        */
 /* THE AUTHORIZED BITS IN DYNAMIC ALLOCATION TO WAIT FOR A DEVICE   */
 /* IF ALL YOUR TAPE DRIVES ARE FULL WHEN IT IS TIME TO DUMP         */
 /* TO TAPE, AND TO PERMIT USE OF THE SMF WRITING SVC.               */
 /* THERE IS NO KEY ZERO CODE IN THIS MODULE OR IN ANY OF ITS        */
 /* SUBROUTINES.                                                     */
 /*****************************************************************  */
 /* INSTALLATION NOTES:                                              */
 /* COMPLIER: PLIX R3.0 OR ABOVE                                     */
 /* COMPILER PARMS: SEE *PROCESS CARD                                */
 /* COMPILER SYSLIB: SYS1.OURMFSRC                                   */
 /* LINKEDIT PARMS: NOT REENTRANT                                    */
 /* LINKEDIT SYSLIB: PLIBASE                                         */
 /*     (ALSO REQUIRES PLIMISC, CNTLOMF, AND S99FAIL SUBROUTINES)    */
 /* TARGET LIBRARY: LINKLIB (SUGGESTED)                              */
 /* ADDITIONAL NOTES:                                                */
 /* PRIOR TO ACTIVATION YOU MUST ALLOCATE THE DISK TRACE DATASET     */
 /* AND INSTALL A CATALOGED PROCEDURE POINTING TO THAT DATASET       */
 /* IN YOUR STARTED TASK PROCLIB. A PARAMETER DATASET SHOULD         */
 /* BE PROVIDED, WE SUGGEST YOU USE 'SYS1.PARMLIB(OMFPRM00)'         */
 /* IF THE TAPE SPILL FILE IS NOT CATALOGED WHEN OURMF FIRST         */
 /* DUMPS THE DISK FILE TO TAPE, IT WILL MAKE A NON-VOLUME-SPECIFIC  */
 /* PRIVATE TAPE REQUEST AND CATALOG THE DATASET UNDER THE NAME      */
 /* SPECIFIED IN THE PARAMETERS                                      */
 /****************************************************************** */
 /* OPERATIONS:                                                      */
 /*   // EXEC PGM=OURMF,TIME=1440                                    */
 /*   //OUT DD DSN=LOCAL.DISK.DATASET.NAME,DISP=MOD                  */
 /*   //OLD DD DSN=LOCAL.DISK.DATASET.NAME,DISP=OLD                  */
 /*   //SYSIN DD DSN=SYS1.PARMLIB(OMFPRM00),DISP=SHR,FREE=CLOSE      */
 /* OURMF IS GENERALLY RUN AS A STARTED TASK. IT SHOULD BE STARTED   */
 /* AFTER STATDIE AND IF WORKLOAD REPORTING IS REQUIRED, AFTER MF1.  */
 /* ALTHOUGH IT IS POSSIBLE TO CHOOSE OTHER REPORTING PERIODS,       */
 /* IT IS HIGHLY RECOMMENDED THAT 'INTERVAL' BE '15' IN BOTH         */
 /* OURMF AND MF1, SO THAT REPORTING IS DONE EVERY 15 MINUTES.       */
 /****************************************************************   */
 %PAGE;
  /*              P A R A M E T E R S                                */
 % INCLUDE STATGLBL;
  %PAGE;
  /*  NOW TO DECLARE MAJOR SYSTEM CONTROL BLOCKS                     */
 % INCLUDE YCCSTART;
 % DCL (RMCTPTR,RMCAPTR,PVTPTR,LCCAPTR) CHAR;
 % RMCTPTR='CVTOPCTP';
 % RMCAPTR='RMCTRMCA';
 % PVTPTR='CVTPVTP';
 % LCCAPTR='PSALCCAV';
   /* % INCLUDE IHAPSA            */
   /* % INCLUDE CVT               */
   /* % INCLUDE IHALCCA           */
   /* % INCLUDE IRARMCT           */
   /* % INCLUDE IRARMCA           */
   /* % INCLUDE IHAPVT            */
 % NOPRINT;
 % INCLUDE IHAPSA;
 % INCLUDE CVT;
 % INCLUDE IHALCCA;
 % INCLUDE IRARMCT;
 % INCLUDE IRARMCA;
 % INCLUDE IHAPVT;
 % PRINT;
 % INCLUDE STDE;
 DCL 1 STDE2 BASED(STDEPTR),
     2 FILL CHAR(176),
     2 STDENBUF BIT(8) ALIGNED;
 DCL PGBUF CHAR(4096) BASED(PGBUFPTR);
 DCL STATADDR PTR;
 DCL WAMTPTR PTR  BASED(STATADDR);
 DCL WAMTBUF CHAR(4096) BASED(WAMTPTR);
 DCL 1 WAMT BASED(WAMTPTR),
 % INCLUDE IRAWAMT;
  %SKIP(5);
  /*  DECLARE LOCAL VARIABLES                                  */
 DCL PARM CHAR(100) VAR;
 DCL OUT RECORD OUTPUT ENV(VB TOTAL BLKSIZE(6008) RECSIZE(6000));
 DCL DLY FIXED BIN(31) ;
 DCL IOBUF CHAR(4096) VAR;
  DCL (LASTBUF,NEXTBUF,IBUF) FIXED BIN(8);
 DCL WRITTEN FIXED BIN INIT(0);
 DCL LASTTOC CHAR(8) INIT(' ');
 DCL 1 LASTIME,  2 (LAST1,LAST2) FIXED BIN(31);
 DCL 1 THISTIME, 2 (THIS1,THIS2) FIXED BIN(31);
 DCL MODIFY CHAR(256) VAR;
 DCL PTRIN ENTRY(PTR) RETURNS(FIXED BIN(31));
 DCL LOADPTR ENTRY(CHAR(8),PTR) OPTIONS(ASM INTER RETCODE);
 DCL PTROUT ENTRY(FIXED BIN(31)) RETURNS(PTR) REDUCIBLE;
 DCL SDL ENTRY(CHAR(8),CHAR(8));
 DCL STCK ENTRY(* );
 DCL TODCNVT ENTRY(*) RETURNS(CHAR(24));
 DCL COMWAIT ENTRY(FIXED BIN(31), CHAR(256) VAR)
    RETURNS(FIXED BIN);
 DCL CNTLOMF ENTRY;
 DCL OPCODE FIXED BIN;
    DCL 1 OPTIONS ,               /* SYSIN PARAMETERS */
         2 INTERVAL FIXED BIN INIT(15),
         2 SMF BIT ALIGNED INIT('0'B),
         2 CPUSUM BIT ALIGNED INIT('0'B),
         2 DISKSPACE FIXED BIN INIT(300),
         2 TAPEDSN CHAR(44) VAR INIT('SYS1.OURMF.TAPE'),
         2 TAPEUNIT CHAR(6) VAR INIT('TAPE');
 %PAGE;
 DCL 1 OMF3,
    2 OMF3ID   CHAR(4) INIT('OMF3'),    /* RECORD ID FIELD         */
    2 TIMESTAMP CHAR(8),           /* TIME MOVED TO BUFFER    */
    2 RDW,                               /* SORTA RECORD DESCRIPTOR */
        3 TYPE BIT(8) INIT('00000101'),  /* SUBFIELD TYPE           */
        3 ITEM BIT(8) INIT('00000000'),  /* ITEM LENGTH (UNUSED)    */
        3 LEN FIXED BIN INIT(100),         /* TOTAL SUBFIELD LENGTH   */
    2 LCCAWTIM CHAR(8),                  /* ACCUMULATED WAIT TIME   */
    2 PAGINGINFO,
     3 PVTNPIN  FIXED(31),          /* NUMBER OF PAGES PAGED IN,
                                       EXCLUDING SWAP-INS AND VIO
                                       PAGE-INS.                     */
     3 PVTNPOUT FIXED(31),          /* NUMBER OF PAGES PAGED OUT,
                                       EXCLUDING SWAP-OUTS AND VIO
                                       PAGE-OUTS                     */
     3 PVTVAMI  FIXED(31),          /* NUMBER OF VIO PAGE-INS
                                       EXCLUDING SWAP                */
     3 PVTVAMO  FIXED(31),          /* NUMBER OF VIO PAGE-OUTS
                                       EXCLUDING SWAP                */
     3 PVTVAMR  FIXED(31),          /* NUMBER OF VIO RECLAIMS        */
     3 PVTSPIN  FIXED(31),          /* NUMBER OF PAGES SWAPPED-IN    */
     3 PVTSPOUT FIXED(31),          /* NUMBER OF PAGES SWAPPED-OUT   */
     3 PVTNPREC FIXED(31),          /* NUMBER OF PAGES RECLAIMED,
                                       EXCLUDING SWAP AND VIO RECLAIMS
                                                                    */
     3 PVTNSWPS FIXED(31),          /* NUMBER OF SUCCESSFUL SWAP-INS */
     3 PVTCAIN  FIXED(31),          /* NUMBER OF COMMON AREA PAGE-INS
                                                                    */
     3 PVTCAOUT FIXED(31),          /* NUMBER OF COMMON AREA
                                       PAGE OUTS                    */
     3 PVTCAREC FIXED(31),          /* NUMBER OF RECLAIMS OF COMMON
                                       AREA PAGES                   */
     3 PVTSPREC FIXED(31),          /* NUMBER OF PRIVATE AREA PAGEABLE
                                       PAGES RECLAIMED ACROSS A SWAP
                                                                    */
    2 SWAPINFO ,
        3 RMCATOSC FIXED(31),     /* TERMINAL OUTPUT SWAP COUNT     */
        3 RMCATISC FIXED(31),     /* TERMINAL  INPUT SWAP COUNT     */
        3 RMCALWSC FIXED(31),     /* LONG WAIT SWAP COUNT           */
        3 RMCAXSSC FIXED(31),     /* AUT STOR SHORTAGE SWAP COUNT   */
        3 RMCARSSC FIXED(31),     /* REAL STOR SHORTAGE SWAP COUNT  */
        3 RMCADWSC FIXED(31),     /* DETECTED WAIT SWAP COUNT       */
        3 RMCARQSC FIXED(31),     /* REQSWAP SWAP COUNT             */
        3 RMCANQSC FIXED(31),     /* CAP ENQ EXCHANGE SWAP COUNT    */
        3 RMCAEXSC FIXED(31),     /* CAP EXCHANGE BASED ON RECOMM.
                                       VALUE SWAP COUNT             */
        3 RMCAUSSC FIXED(31);     /* CAP UNILATERAL SWAP OUT COUNT  */
 DCL 1 HOLDMF3,
    2 LCCAWTIM CHAR(8),
    2 PAGINGINFO,
        3 PVTNPIN  FIXED(31),
        3 PVTNPOUT FIXED(31),
        3 PVTVAMI  FIXED(31),
        3 PVTVAMO  FIXED(31),
        3 PVTVAMR  FIXED(31),
        3 PVTSPIN  FIXED(31),
        3 PVTSPOUT FIXED(31),
        3 PVTNPREC FIXED(31),
        3 PVTNSWPS FIXED(31),
        3 PVTCAIN  FIXED(31),
        3 PVTCAOUT FIXED(31),
        3 PVTCAREC FIXED(31),
        3 PVTSPREC FIXED(31),
    2 SWAPINFO ,
        3 RMCATOSC FIXED(31),
        3 RMCATISC FIXED(31),
        3 RMCALWSC FIXED(31),
        3 RMCAXSSC FIXED(31),
        3 RMCARSSC FIXED(31),
        3 RMCADWSC FIXED(31),
        3 RMCARQSC FIXED(31),
        3 RMCANQSC FIXED(31),
        3 RMCAEXSC FIXED(31),
        3 RMCAUSSC FIXED(31);
  %SKIP(5);
  /*  INCLUDE PREPROCESSOR PROCEDURES (A COMPILER RESTRICTION    */
  /* REQUIRES THEY BE INCLUDED BEFORE BEING USED.                    */
 %INCLUDE DYNALLOC;
 %PAGE;
 /* INITIALIZATION:                                                  */
 /* CALL LOADPTR TO LOCATE THE VARIOUS STATDIE ENTRY POINTS          */
 /*   AND  VERIFY THAT STATDIE HAS BEEN ACTIVATED. SINCE             */
 /*   IT IS FREQUENTLY DESIRABLE TO START STATDIE, MF1, AND          */
 /*   OURMF ALL DURING THE IPL PROCEDURE, THIS TEST IS               */
 /*   PRECEEDED BY A ONE-MINUTE DELAY TO ALLOW THE OTHER             */
 /*   STARTED TASKS A HEAD START AND INSURE THE PREREQUISTE          */
 /*   CONTROL BLOCKS ARE INITIALIZED.                                */
 /* CALL THE EMPTY INTERNAL ENTRY POINT SO DATA LEFT IN THE          */
 /*   DISK DATASET AFTER A CANCEL OR CRASH IS SPILLED TO             */
 /*   TAPE.                                                          */
 /* SAVE THE CURRENT VALUES OF VARIOUS CONTROL BLOCK FIELDS          */
 /*   TO ALLOW DIFFERENCE CALCULATIONS WHEN THE FIRST                */
 /*   RECORDS ARE WRITTEN.                                           */
 DELAY(60000) /*WAIT A MINUTE*/;
 CALL LOADPTR('STATSTDE',STDEPTR);
 IF PLIRETC>0 THEN DO;
     DISPLAY('OUR-MF CANNOT LOCATE STATDIE LOAD MODULE');
     STOP;
     END;
 IF STDEFLGS='0'B THEN
     DO;
     DISPLAY('OUR-MF TERMINATED -- STATDIE NOT RUNNING');
     STOP;
     END;
 CALL LOADPTR('STATWAMT',STATADDR);
 CALL CNTLOMF(OPTIONS);
 LASTBUF=STDENBUF;
 CALL EMPTY;
 HOLDMF3.LCCAWTIM=LCCA.LCCAWTIM;
 HOLDMF3.PAGINGINFO=PVT, BY NAME;
 HOLDMF3.SWAPINFO=RMCASRC;
 CALL STCK(LASTIME);
 %SKIP(5);
 /* THIS IS THE MAIN PROCESSING SECTION. THIS LOOP IS REPEATED       */
 /* EVERY 'INTERVAL' MINUTES. IT PERFORMS THE FOLLOWING FUNCTIONS:   */
 /* 1) THE DELAY INTERVAL IS CALCULATED BASED ON A CURRENT TIME      */
 /*    STAMP AND ONE FROM THE IMMEDIATELY PRECEEDING WAKE UP         */
 /*    TIME. IF EMPTY HAS BEEN CALLED IN THE PREVIOUS PERIOD,        */
 /*    AND IT WAS NECESSARY TO WAIT FOR A TAPE, THEN A FIXED         */
 /*    WAIT TIME WOULD PRODUCE A LONG GAP BETWEEN THE LAST AND       */
 /*    NEXT RECORDING PERIOD.                                        */
 /* 2) COMWAIT IS CALLED TO SWAP US OUT UNTIL THE INTERVAL ENDS      */
 /*    OR THE OPERATOR ISSUES A 'P OURMF'.                           */
 /* 3) THE PAGEABLE BUFFERS WHICH WERE FILLED SINCE THE LAST         */
 /*    RECORDING INTERVAL ARE WRITTEN OUT TO DISK AS 'OMF1'          */
 /*    RECORDS. IT IS NECESSARY TO CONVERT THE STCK FORMAT           */
 /*    TIMESTAMP TO DATE AND HOUR FORMAT.                            */
 /* 4) IF THERE IS A WAMT IN THE WAMTBUFFER, AND IF IT IS NOT        */
 /*    THE SAME ONE WRITTEN LAST TIME, THEN IT IS CONVERTED          */
 /*    TO AN 'OMF2' RECORD AND WRITTEN TO DISK.                      */
 /* 5) A FEW 'BY NAME' STRUCTURE OPERATIONS CALCULATE THE            */
 /*    PAGING EVENT COUNTS, SWAP REASON COUNTS, AND WAIT TIME        */
 /*   FROM THE SYSTEM CONTROL BLOCKS AND THE SAVED VALUES            */
 /*   FROM THE PREVIOUS WAKE UP PERIOD.                              */
 /* 6) THE CURRENT VALUES OF THESE COUNTERS ARE SAVED FOR THE        */
 /*    NEXT PERIOD. IF THE DISK DATASET IS NOW FULL, CALL            */
 /*    EMPTY TO SPILL IT TO TAPE.                                    */
 DOITAGAIN:
 CALL STCK(THISTIME);
 DLY=(INTERVAL*60-(THIS1-LAST1))*100;
 OPCODE=COMWAIT(DLY,MODIFY);
 CALL STCK(LASTIME);
 IF STDETQE(14)&'1'B THEN
    DO;
    PUT EDIT('STATDIE HAS AN ERROR, OURMF IS TERMINATING')(COL(1),A);
    STOP;
    END;
 NEXTBUF=SUBSTR(UNSPEC(STDEBUFP),1,8);
      DO IBUF=LASTBUF REPEAT MOD(IBUF+1,PGBFCT) WHILE(IBUF^=NEXTBUF);
      PGBUFPTR=PTROUT(PTRIN(STDEBUFP)+STDEPLEN*IBUF);
      IOBUF='OMF1'××SUBSTR(PGBUF,1,STDEPLEN);
      SUBSTR(IOBUF,5,8)=FIXTIME(SUBSTR(IOBUF,5,8));
      WRITE FILE(OUT) FROM(IOBUF);
      WRITTEN=WRITTEN+1;
      END;
 IF OPCODE>0 THEN DO;
     CALL EMPTY;
     RETURN;
     END;
 IF WAMT.SIZ>0 THEN
     DO;
     IOBUF='OMF2        '××SUBSTR(WAMTBUF,1,WAMT.SIZ);
     IF LASTTOC^=SUBSTR(IOBUF,29,8) THEN
         DO;
         LASTTOC=SUBSTR(IOBUF,29,8);
         SUBSTR(IOBUF,5,8)=FIXTIME(LASTTOC);
         WRITE FILE(OUT) FROM(IOBUF);
         END;
     END;
 OMF3.LCCAWTIM=LCCA.LCCAWTIM;
 CALL SDL(OMF3.LCCAWTIM,HOLDMF3.LCCAWTIM);
 OMF3.PAGINGINFO=PVT-HOLDMF3.PAGINGINFO, BY NAME;
 OMF3.SWAPINFO=RMCASRC-HOLDMF3.SWAPINFO;
 HOLDMF3.LCCAWTIM=LCCA.LCCAWTIM;
 HOLDMF3.PAGINGINFO=PVT, BY NAME;
 HOLDMF3.SWAPINFO=RMCASRC;
 CALL STCK(OMF3.TIMESTAMP);
 OMF3.TIMESTAMP=FIXTIME(OMF3.TIMESTAMP);
 WRITE FILE(OUT) FROM(OMF3);
 WRITTEN=WRITTEN+2;
 CLOSE FILE(OUT);
 LASTBUF=NEXTBUF;
 IF WRITTEN>DISKSPACE THEN CALL EMPTY;
 GO TO DOITAGAIN;
 %PAGE;
 EMPTY: PROC;
  /* THE EMPTY PROCEDURE EMPTIES THE DISK DATASET BY COPYING IT      */
  /* TO A DYNAMICALLY ALLOCATED TAPE DATASET, THEN REOPENING THE     */
  /* DISK DATASET FOR OUTPUT UNDER A DDNAME WHERE IT HAS DISP=OLD.   */
 DCL (OLD INPUT, OLD2 OUTPUT, TAPE OUTPUT)
        FILE RECORD ENV(VB TOTAL BLKSIZE(6008) RECSIZE(6000));
 ON ENDFILE(OLD) GO TO REOPEN;
 OPEN FILE(OLD) INPUT RECORD;
 READ FILE(OLD) INTO(IOBUF);
 /* DATASET IS NOT ALREADY EMPTY, SO GO EMPTY IT */
 ON ENDFILE(OLD) GO TO REOPEN;
  /* DYNALLOC FILE(TAPE) DSN(@TAPEDSN) DISP1(MOD) UNIT(@TAPEUNIT)    */
  /*     DISP2(CATLG) FREE(CLOSE) AUTH(1001)                         */
 %NOPRINT;
 DYNALLOC FILE(TAPE) DSN(@TAPEDSN) DISP1(MOD) UNIT(@TAPEUNIT)
     DISP2(CATLG) FREE(CLOSE) AUTH(1001);
 %PRINT;
     /* AUTHORIZED FLAG BITS ARE SET TO WAIT FOR UNIT */
 LOOP: WRITE FILE(TAPE) FROM(IOBUF);
 READ FILE(OLD) INTO(IOBUF);
 GO TO LOOP;
 REOPEN: CLOSE FILE(OLD);
 CLOSE FILE(TAPE);
 OPEN FILE(OLD2) OUTPUT RECORD TITLE('OLD');
 RET: CLOSE FILE(OLD2);
 WRITTEN=0;
 RETURN;
 END EMPTY;
 %SKIP(5);
 FIXTIME: PROC(ARG) RETURNS(CHAR(8));
 DCL ARG CHAR(8);
 DCL  TODCNVT ENTRY(*) RETURNS(CHAR(24));
 DCL 1 TIMECHR,
    2 DATE CHAR(5),
    2 HOUR CHAR(2),
    2 P1 CHAR(1),
    2 MIN CHAR(2),
    2 P2 CHAR(1),
    2 SEC CHAR(2);
 DCL FRED CHAR(6);
 DCL SAM PIC'999999' DEFINED(FRED) POS(1);
 DCL 1 DECIMA,
    2 DECDATE FIXED DEC(7),
    2 DECHOUR FIXED DEC(7);
 DCL RETN CHAR(8);
 STRING(TIMECHR)=SUBSTR(TODCNVT(ARG),3,13);
 FRED='0'××DATE;
 DECDATE=SAM;
 FRED=HOUR××MIN××SEC;
 DECHOUR=SAM;
 UNSPEC(RETN)=UNSPEC(DECDATE)××UNSPEC(DECHOUR);
 RETURN(RETN);
 END FIXTIME;
 %SKIP(5);
 END OURMF;
