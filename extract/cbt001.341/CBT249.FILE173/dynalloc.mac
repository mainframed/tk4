 % DYNALLOC: PROC(FILE,DSN,CYL,TRK,DIR,MEMBER,TERMINAL,
    SYSOUT,DUMMY,UNIT,RLSE,CONTIG,SER,POSITION,FREE,PERM,AUTH,
    DISP1,DISP2,DISP3,SPACE1,SPACE2,ONERROR,TRTCH,FCB,UCS,DEST,
    INTRDR,FORMS,COPIES,LABEL,PROTECT,VERB,ID,MF,DDNRTN)
    STATEMENT RETURNS(CHAR);
  /*****************************************************************/
  /*  MACRO : DYNALLOC                                             */
  /*  VERSION:  JAN 21, 1977                                       */
  /*  LANGUAGE: PLIX RELEASE 3.0                                   */
  /*  SYSTEM:   MVS                                                */
  /*                                                               */
  /* PURPOSE:                                                      */
  /* PERFORMS A DYNAMIC ALLOCATION OR BUILDS A DYNAMIC ALLOCATION  */
  /* PARAMETER BLOCK FROM THE KEYWORD ARGUMENTS PROVIDED BY THE    */
  /* CALLER. REFERENCE INFORMATION ON DYNAMIC ALLOCATION THROUGH   */
  /*  SVC 99 IS PROVIDED IN SPL: JOB MANANGEMENT (GC28-0627) WHICH */
  /* SHOULD BE REVIEWED IF THE FOLLOWING DOCUMENTATION IS          */
  /* INADEQUATE TO YOUR NEEDS.                                     */
  /*                                                               */
  /*   KEYWORDS HAVE BEEN CHOSEN FROM JCL AND THE TSO ALLOC        */
  /* COMMAND. A KEYWORD CAN BE DEFINED FOR EVERY KEYWORD OR        */
  /* POSITIONAL PARAMETER THAT CAN BE SPECIFIED IN JCL, BUT        */
  /* SOME CENSORSHIP HAS BEEN IMPOSED TO MAKE THE PROGRAMMING      */
  /* EFFORT BEARABLE AT THIS POINT. BTAM AND TCAM KEYWORDS,        */
  /* UNIT RECORD DEVICE OPTIONS, AND MOST DCB SUBFIELDS HAVE       */
  /* BEEN OMITTED FROM THIS VERSION BECAUSE THEY ARE UNLIKELY      */
  /* TO BE NEEDED OR BECAUSE THEY OVERLAP FEATURES OF 'ENV'.       */
  /*                                                               */
  /*   WHEN USING THIS FACILITY YOU INHERIT THE DEFAULTS           */
  /* AND RESTRICTIONS OF THE SVC 99 INTERFACE. OMITTED             */
  /* PARAMETERS DEFAULT ACCORDING TO JCL CONVENTIONS (EXAMPLE:     */
  /* IF DISP1 IS OMMITTED 'NEW' IS ASSUMED). CERTAIN               */
  /* KEYWORDS ARE MUTUALLY EXCLUSIVE, BUT NO CHECK IS              */
  /* MADE FOR THIS IN THE MACRO. SVC 99 WILL FAIL IF THE           */
  /* OPTION GROUP SPECIFIED IS ILLEGAL. YOUR USERID                */
  /* IS NOT INSERTED INTO THE 'DSN' KEYWORD, SO YOU                */
  /* MUST PROVIDE THIS SERVICE YOURSELF IF YOU NEED IT.            */
  /*                                                               */
  /*   THERE ARE THREE FORMS OF THE MACRO BASED ON THE             */
  /* VALUE OF THE 'MF' KEYWORD. IF 'MF' IS OMMITTED,               */
  /* THE STANDARD FORM OF THE MACRO IS GENERATED                   */
  /* INCLUDING A BEGIN STATEMENT, PARAMETER AND ENTRY              */
  /* DECLARATION, SVC CALL, AND ERROR ANALYSIS. IF 'MF(L)'         */
  /* IS SPECIFIED, ONLY THE PARAMETER BLOCK STRUCTURE IS           */
  /* DECLARED, AND NO EXECUTABLE STATEMENTS ARE PRODUCED.          */
  /* IF 'MF(E)' IS SPECIFIED, THE EXECUTE FORM OF THE MACRO        */
  /* EXPANDS TO A BEGIN STATEMENT, ENTRY DECLARATIONS, A           */
  /* SEQUENCE OF ASSIGNMENTS MODIFYING THE PARAMETER BLOCK         */
  /* GENERATED BY A PREVIOUS 'MF(L)' MACRO CALL, AN SVC            */
  /* CALL, AND ERROR ANALYSIS. THE NAME GENERATED BY               */
  /* MF(L) MUST BE KNOWN TO THE MF(E) BLOCK. THE SHAPE OF          */
  /* THE PARAMETER BLOCK CANNOT BE CHANGED BY MF(E), SO            */
  /* A COMPILER ERROR IS GENERATED IF A KEYWORD IS                 */
  /* SPECIFIED IN MF(E) WHICH IS NOT ALSO SPECIFIED IN             */
  /* THE MF(L).                                                    */
  /*       DYNALLOC FILE(XXX) TERMINAL ID(TERM) MF(L);             */
  /*               ...                                             */
  /*       DYNALLOC FILE(SYSTERM) ID(TERM) MF(E);                  */
  /* THE MF(L) GENRATES A PARMETER BLOCK FOR ALLOCATING THE        */
  /* TERMINAL AS A DATASET. THE MF(E) THEN CHANGES THE DDNAME      */
  /* TO 'SYSTERM' AND ISSUES THE ACTUAL ALLOCATION REQUEST.        */
  /*                                                               */
  /* FIVE KINDS OF KEYWORDS EXIST: CHARACTER, NUMERIC, LOGICAL,    */
  /* RESTRICTED OPTION, AND SPECIAL.                               */
  /* THE FOLLOWING KEYWORDS ARE CHARACTER. THEY ARE SPECIFIED      */
  /* WITH A CHARACTER STRING (WITHOUT QUOTES) OR AS '@' FOLLOWED   */
  /* BY THE NAME OF A CHARACTER VARIABLE (EXAMPLE: FILE(IN) MEANS  */
  /* THE DDNAME 'IN' WHILE FILE(@IN) MEANS THE DDNAME CONTAINED    */
  /* IN THE PLI VARIABLE WHOSE NAME IS 'IN'). NOTE THAT MF(L)      */
  /* PARAMETER DECLARATIONS USE 'INIT' TO ASSIGN VALUES, SO        */
  /* IF @VARNAME IS USED, THE VALUE USED WILL BE THE VALUE IN      */
  /* THE VARIABLE WHEN THE CONTAINING BLOCK IS ENTERED, WHILE      */
  /* MF(E) EXPANDS TO ASSIGNMENT STATEMENTS AND UPDATES THE        */
  /* MF(L) PARAMETER BLOCK WITH THE CURRENT VALUE OF THE           */
  /* VARIABLE.                                                     */
  /*  KEYWORD   MEANING                                            */
  /*  FILE      DDNAME ASSIGNED TO ALLOCATED FILE                  */
  /*  DSN       FULLY QUALIFIED DATASET NAME                       */
  /*  MEMBER    MEMBER OF A PDS (THIS CANNOT BE SPECIFIED IN DSN)  */
  /*  SYSOUT    SYSOUT CLASS                                       */
  /*  UNIT      DEVICE TYPE (3330, SYSDA, ETC)                     */
  /*  SER       VOL=SER=                                           */
  /*  FORMS     FOUR CHARACTER FORM ID FOR SYSOUT                  */
  /*                                                               */
  /* THE FOLLOWING KEYWORDS ARE NUMERIC AND SHOULD BE GIVEN AN     */
  /* ARITHMETIC CONSTANT, VARIABLE, OR EXPRESSION-IN-PARENTHESES   */
  /* AS VALUE.                                                     */
  /*  KEYWORD   MEANING                                            */
  /*  DIR       NUMBER OF DIRECTORY BLOCKS FOR NEW PDS             */
  /*  POSITION  FILE SEQUENCE NUMBER FOR TAPE                      */
  /*  SPACE1    PRIMARY SPACE ALLOCATION QUANTITY                  */
  /*  SPACE2    SECONDARY ALLOCATION QUANTITY                      */
  /*  COPIES    NUMBER OF COPIES OF SYSOUT OUTPUT                  */
  /*                                                               */
  /* THE FOLLOWING LOGICAL KEYWORDS TAKE NO VALUE. THEY SHOULD BE  */
  /* SPECIFIED WITHOUT FOLLOWING PARENTHESES.THEY ARE ILLEGAL      */
  /* IF MF(E) IS SPECIFIED SINCE ONLY THE VALUES AND NOT THE SHAPE */
  /* OF A PARAMETER BLOCK CAN BE CHANGED IN THE EXECUTE FORM OF    */
  /* THE MACRO.                                                    */
  /*  KEYWORD   MEANING                                            */
  /*  CYL       ALLOCATION UNIT IS CYLINDERS                       */
  /*  TRK       ALLOCATION UNIT IS TRACKS                          */
  /*  TERMINAL  ALLOCATION TO TSO TERMINAL                         */
  /*  DUMMY     ALLOCATION TO A DUMMY DATASET                      */
  /*  RLSE      RELASE UNUSED SPACE                                */
  /*  CONTIG    CONTIGUOUS ALLOCATION                              */
  /*  INTRDR    ALLOCATION TO AN INTERNAL READER                   */
  /*  PROTECT   SHORTHAND FOR EXPDT=99350                          */
  /*  FREE      FREE=CLOSE                                         */
  /*  PERM      ALLOCATION ENDURES BEYOND CURRENT TSO COMMAND      */
  /* THE FOLLOWING KEYWORDS TAKE ONE OPTION FROM A RESTRICED LIST  */
  /*  KEYWORD   OPTIONS                                            */
  /*  DISP1     NEW,OLD,MOD,SHR                                    */
  /*  DISP2     KEEP,CATLG,UNCATLG,DELETE (PASS IS NOT ACCEPTABLE) */
  /*  DISP3     KEEP,CATLG,UNCATLG,DELETE                          */
  /*  LABEL     SL,NL,BLP,LTM,NSL,AL,AUL,SUL                       */
  /*  TRTCH     E,C,T,ET                                           */
  /*  VERB      ALLOC,FREE (IF OMMITTED, ALLOC ASSUMED)            */
  /* THE FOLLOWING KEYWORDS ARE SPECIAL:                           */
  /*  MF        DESCRIBED ABOVE                                    */
  /*  ID        SPECIFIES THE LEVEL 1 NAME FOR THE SVC 99          */
  /*            PARAMETER STRUCTURE. IF OMMITTED 'S99PARMS'        */
  /*            IS GENERATED. ID ALLOWS UNABMIGUOUS REFERENCE      */
  /*            TO ONE OF SEVERAL SUCH STRUCTURES.                 */
  /*  DDNRTN    IF 'FILE' IS OMITTED, DYNAMIC ALLOCATION WILL      */
  /*            GENERATE A DDNAME. THIS IS THE ONLY KEYWORD        */
  /*            WHICH RETURNS A VALUE RATHER THAN SPECIFIES ONE.   */
  /*            WHEN USED IN MF(L), DDNRTN WILL CREATE A           */
  /*            VARIABLE IN THE STRUCTURE WITH THE NAME            */
  /*            ID××'.S99DDRTRN.S99DATA' WHICH IS A CHAR(8)        */
  /*            VARIABLE FILLED IN BY DYNAMIC ALLOCATION.          */
  /*            WHEN USED IN STANDARD OR MF(E) FORMS,              */
  /*             IT MUST REFER TO A CHARACTER VARIABLE WHICH       */
  /*             WILL BE ASSIGNED THE DDNAME AFTER ALLOCATION.     */
  /*  ONERROR    ONE OR MORE PLI STATEMENTS TO BE EXECUTED         */
  /*             IN THE EVENT SVC 99 RETURNS A NON-ZERO CODE.      */
  /*             UPON ENTRY TO THESE STATEMENTS, THE FOLLOWING     */
  /*             VARIABLES ARE DEFINED:                            */
  /*             R15 (FIXED BIN(31)) SVC 99 RETURN CODE            */
  /*             &ID..S99ERROR (FIXED BIN) SVC 99 ERROR CODE       */
  /*             &ID..S99INFO  (FIXED BIN) SVC 99 INFORMATION CODE */
  /*             MSG ( (2) CHAR(251) VAR) A FIRST AND SECOND LEVEL */
  /*               MESSAGE ABOUT THE ERROR.                        */
  /*             ERROR CODES ARE DOCUMENTED IN SPL:JOB MANAGEMENT. */
  /*             IF THE SEQUENCE OF STATEMENTS IN 'ONERROR' DOES   */
  /*               NOT END IN A GOTO, THEN CONTROL WILL FALL       */
  /*               THROUGH TO THE PLI STATEMENTS:                  */
  /*                   PUT EDIT(MSG)(COL(1),A);                    */
  /*                   SIGNAL ERROR;                               */
  /*             NOTE THAT GOTO MAY TERMINATE THE BLOCK IN WHICH   */
  /*             VARIABLES R15,S99ERROR,S99INFO, AND MSG ARE KNOWN */
  /*             SO PRESERVE THEIR VALUES IN OTHER VARS            */
  /*             IF THEY ARE NEEDED ELSEWHERE.                     */
  /*                                                               */
  /* AUTHOR: HOWARD GILBERT                                        */
  /*         YALE COMPUTER CENTER                                  */
  /*         175 WHITNEY AVE                                       */
  /*         NEW HAVEN, CONN  06520                                */
  /*         203 432 4080                                          */
  /*                                                               */
 DCL(FILE,DSN,CYL,TRK,DIR,MEMBER,TERMINAL,
    SYSOUT,DUMMY,UNIT,RLSE,CONTIG,SER,POSITION,FREE,PERM,AUTH,
    DISP1,DISP2,DISP3,SPACE1,SPACE2,ONERROR,TRTCH,FCB,UCS,DEST,
    INTRDR,FORMS,COPIES,LABEL,PROTECT,VERB,ID,MF,DDNRTN)
    CHAR;
 DCL (RTNR,RTNR2,WORK,WORK2) CHAR;
  /****************************************************************/
  /* THE RETURNED CHARACTER STRING FROM THIS FUNCTION  IS BUILT   */
  /* UP IN TWO PARTS IN THE LOCAL VARIABLES RTNR AND RTRN2 WHICH  */
  /* ARE CONCATENATED TOGETHER AT THE END. THIS ALLOWS THE MF(L)  */
  /* AND STANDARD FORMS OF THE MACRO TO BUILD SIMULTANEOUSLY THE  */
  /* STRUCTURE OF CONTIGUOUS TEXT UNITS AND ALSO THE PSEUDO-ARRAY */
  /* OF TEST POINTERS WHICH POINT TO THEM. EACH OF THE TEXT-UNIT  */
  /* DO GROUPS BELOW ADDS ONE TEXT UNIT STRUCTURE TO RTNR, AND    */
  /* ONE POINTER TO IT TO RTNR2. 'WORK' IS USED TO HOLD A         */
  /* TEMPORARY CHARACTER STRING FOR LATER INSERTION INTO THE      */
  /* GENERATED OUTPUT. 'WORK2' HOLDS THE LEVEL 1 STRUCTURE NAME   */
  /* PASSED BY 'ID' OR GENERATED BY DEFAULT.                      */
  /****************************************************************/
 RTNR='';
 RTNR2='';
 IF ID='' THEN
    DO;
    WORK2='S99PARMS';
    IF MF^='' THEN
          NOTE(' LEVEL 1 ID S99PARMS GENERATED, DONT DO IT TWICE',4);
    END;
 ELSE WORK2=ID;
  /****************************************************/
  /* IF MF=E OR MF OMITTED, THEN WE GENERATE A BEGIN  */
  /* BLOCK TO LOCALIZE NAMES, AND SINCE WE WILL BE    */
  /* CALLING SVC99 WE DECLARE THE SUBROUTINE INTERFACE*/
  /* VARIABLES AND ENTRY POINTS.                      */
  /****************************************************/
  IF MF^='L' THEN
    RTNR=RTNR××' BEGIN;
         DCL SVC ENTRY(FIXED BIN,*) OPTIONS(ASM INTER RETCODE);
         DCL 1 REGS,
              2 R0 PTR,
              2 R1 PTR,
              2 R15 FIXED BIN(31);
         DCL ARGPTR PTR;
         ARGPTR=ADDR('××WORK2××');
         UNSPEC(ARGPTR)=UNSPEC(ARGPTR)×''1''B;
         R1=ADDR(ARGPTR);
         DCL S99FAIL ENTRY ;
         DCL MSG(2) CHAR(251) VAR;';
  /*************************************************/
  /* IF MF=L OR IS OMITTED WE ARE GOING TO GENERATE*/
  /* A PARAMETER BLOC. IF MF=E THE BLOCK ALREADY   */
  /* EXISTS, SO SKIP TO THE BLOCK MODIFY SECTION   */
  /*************************************************/
  IF MF='E' THEN GO TO MFECODE;
 IF VERB=''×VERB='ALLOC' THEN
    WORK='00000001';
 ELSE IF VERB='FREE' THEN
    WORK='00000010';
 ELSE NOTE('UNSUPPORTED VERB',8);
 RTNR=RTNR××' DCL 1 '××WORK2××' UNALIGNED,
    2 S99PRMBLK,
         3 S99PLEN BIT(8) INIT(''00010100''B),
         3 S99VERB BIT(8) INIT('''××WORK××'''B),
         3 S99FLG1 BIT(16) INIT(''0''B),
         3 S99ERROR BIT(16) INIT(''0''B),
         3 S99INFO BIT(16) INIT(''0''B),
         3 S99PRTP PTR INIT((ADDR('××
              WORK2××'.S99PTRS))),
         3 S99RSVD BIT(32) INIT(''0''B),
         3 S99FLG2 BIT(32) INIT('''××AUTH××'0''B),
    2 S99TEXTFLDS,';
 IF PARMSET(FILE) THEN
    DO;
    RTNR=RTNR××DYNALLOC2('S99FILE',FILE,1,1,8,'C');
    RTNR2=RTNR2××'4 S99FILEP PTR INIT((ADDR('××
              WORK2××'.S99FILE))),';
    END;
 IF PARMSET(DSN) THEN
    DO;
    RTNR=RTNR××DYNALLOC2('S99DSN',DSN,2,1,44,'C');
    RTNR2=RTNR2××'4 S99DSNP PTR INIT((ADDR('××
              WORK2××'.S99DSN))),';
    END;
 IF PARMSET(MEMBER) THEN
    DO;
    RTNR=RTNR××DYNALLOC2('S99MEMBER',MEMBER,3,1,8,'C');
    RTNR2=RTNR2××'4 S99MEMBERP PTR INIT((ADDR('××
              WORK2××'.S99MEMBER))),';
    END;
 IF PARMSET(TRK) THEN
    DO;
    RTNR=RTNR××DYNALLOC2('S99TRK',TRK,7,0);
    RTNR2=RTNR2××'4 S99TRKP PTR INIT((ADDR('××
              WORK2××'.S99TRK))),';
    END;
 IF PARMSET(CYL) THEN
    DO;
    RTNR=RTNR××DYNALLOC2('S99CYL',CYL,8,0);
    RTNR2=RTNR2××'4 S99CYLP PTR INIT((ADDR('××
              WORK2××'.S99CYL))),';
    END;
 IF PARMSET(DIR) THEN
    DO;
    RTNR=RTNR××DYNALLOC2('S99DIR',DIR,12,1,3,'F');
    RTNR2=RTNR2××'4 S99DIRP PTR INIT((ADDR('××
              WORK2××'.S99DIR))),';
    END;
 IF PARMSET(RLSE) THEN
    DO;
    RTNR=RTNR××DYNALLOC2('S99RLSE',RLSE,13,0);
    RTNR2=RTNR2××'4 S99RLSEP PTR INIT((ADDR('××
              WORK2××'.S99RLSE))),';
    END;
 IF PARMSET(CONTIG) THEN
    DO;
    RTNR=RTNR××DYNALLOC2('S99CONTIG','00001000',14,1,1,'B');
    RTNR2=RTNR2××'4 S99CONTIGP PTR INIT((ADDR('××
              WORK2××'.S99CONTIG))),';
    END;
 IF PARMSET(SER) THEN
    DO;
    RTNR=RTNR××DYNALLOC2('S99SER',SER,16,1,6,'C');
    RTNR2=RTNR2××'4 S99SERP PTR INIT((ADDR('××
              WORK2××'.S99SER))),';
    END;
 IF PARMSET(UNIT) THEN
    DO;
    RTNR=RTNR××DYNALLOC2('S99UNIT',UNIT,21,1,8,'C');
    RTNR2=RTNR2××'4 S99UNITP PTR INIT((ADDR('××
              WORK2××'.S99UNIT))),';
    END;
 IF PARMSET(SYSOUT) THEN
    DO;
    RTNR=RTNR××DYNALLOC2('S99SYSOUT',SYSOUT,24,1,1,'C');
    RTNR2=RTNR2××'4 S99SYSOUTP PTR INIT((ADDR('××
              WORK2××'.S99SYSOUT))),';
    END;
 IF PARMSET(FORMS) THEN
    DO;
    RTNR=RTNR××DYNALLOC2('S99FORMS',FORMS,26,1,4,'C');
    RTNR2=RTNR2××'4 S99FORMSP PTR INIT((ADDR('××
              WORK2××'.S99FORMS))),';
    END;
 IF PARMSET(COPIES) THEN
    DO;
    RTNR=RTNR××DYNALLOC2('S99COPIES',COPIES,29,1,1,'F');
    RTNR2=RTNR2××'4 S99COPIESP PTR INIT((ADDR('××
              WORK2××'.S99COPIES))),';
    END;
 IF PARMSET(POSITION) THEN
    DO;
    RTNR=RTNR××DYNALLOC2('S99POSITION',POSITION,31,1,2,'F');
    RTNR2=RTNR2××'4 S99POSITIONP PTR INIT((ADDR('××
              WORK2××'.S99POSITION))),';
    END;
 IF PARMSET(PROTECT) THEN
    DO;
    RTNR=RTNR××DYNALLOC2('S99PROTECT','99350',34,1,5,'C');
    RTNR2=RTNR2××'4 S99PROTECTP PTR INIT((ADDR('××
              WORK2××'.S99PROTECT))),';
    END;
 IF PARMSET(DUMMY) THEN
    DO;
    RTNR=RTNR××DYNALLOC2('S99DUMMY',DUMMY,36,0);
    RTNR2=RTNR2××'4 S99DUMMYP PTR INIT((ADDR('××
              WORK2××'.S99DUMMY))),';
    END;
 IF PARMSET(TERMINAL) THEN
    DO;
    RTNR=RTNR××DYNALLOC2('S99TERMINAL',TERMINAL,40,0);
    RTNR2=RTNR2××'4 S99TERMINALP PTR INIT((ADDR('××
              WORK2××'.S99TERMINAL))),';
    END;
 IF PARMSET(FREE) THEN
    DO;
    RTNR=RTNR××DYNALLOC2('S99FREE',FREE,28,0);
    RTNR2=RTNR2××'4 S99FREEP PTR INIT((ADDR('××
              WORK2××'.S99FREE))),';
    END;
 IF PARMSET(DDNRTN) THEN
    DO;
    RTNR=RTNR××DYNALLOC2('S99DDNRTN','        ',85,1,8,'C');
    RTNR2=RTNR2××'4 S99DDNRTNP PTR INIT((ADDR('××
              WORK2××'.S99DDNRTN))),';
    END;
 IF PARMSET(FCB) THEN
    DO;
    RTNR=RTNR××DYNALLOC2('S99FCB',FCB,37,1,4,'C');
    RTNR2=RTNR2××'4 S99FCBP PTR INIT((ADDR('××
              WORK2××'.S99FCB))),';
    END;
 IF PARMSET(UCS) THEN
    DO;
    RTNR=RTNR××DYNALLOC2('S99UCS',UCS,41,1,4,'C');
    RTNR2=RTNR2××'4 S99UCSP PTR INIT((ADDR('××
              WORK2××'.S99UCS))),';
    END;
 IF PARMSET(DEST) THEN
    DO;
    RTNR=RTNR××DYNALLOC2('S99DEST',DEST,88,1,8,'C');
    RTNR2=RTNR2××'4 S99DESTP PTR INIT((ADDR('××
              WORK2××'.S99DEST))),';
    END;
 IF PARMSET(SPACE1) THEN
    DO;
    RTNR=RTNR××DYNALLOC2('S99SPACE1',SPACE1,10,1,3,'F');
    RTNR2=RTNR2××'4 S99SPACE1P PTR INIT((ADDR('××
              WORK2××'.S99SPACE1))),';
    END;
 IF PARMSET(SPACE2) THEN
    DO;
    RTNR=RTNR××DYNALLOC2('S99SPACE2',SPACE2,11,1,3,'F');
    RTNR2=RTNR2××'4 S99SPACE2P PTR INIT((ADDR('××
              WORK2××'.S99SPACE2))),';
    END;
 IF PARMSET(DISP1) THEN
    DO;
    WORK='00000000';
    IF DISP1='SHR' THEN WORK='00001000';
    ELSE IF DISP1='NEW' THEN WORK='00000100';
    ELSE IF DISP1='MOD' THEN WORK='00000010';
    ELSE IF DISP1='OLD' THEN WORK='00000001';
    ELSE NOTE('INVALID DISP1 VALUE',8);
    RTNR=RTNR××DYNALLOC2('S99DISP1',WORK,4,1,1,'B');
    RTNR2=RTNR2××'4 S99DISP1P PTR INIT((ADDR('××
              WORK2××'.S99DISP1))),';
    END;
 IF PARMSET(DISP2) THEN
    DO;
    WORK='00000000';
    IF DISP2='KEEP' THEN WORK='00001000';
    ELSE IF DISP2='DELETE' THEN WORK='00000100';
    ELSE IF DISP2='CATLG' THEN WORK='00000010';
    ELSE IF DISP2='UNCATLG' THEN WORK='00000001';
    ELSE NOTE('INVALID DISP2 VALUE',8);
    RTNR=RTNR××DYNALLOC2('S99DISP2',WORK,5,1,1,'B');
    RTNR2=RTNR2××'4 S99DISP2P PTR INIT((ADDR('××
              WORK2××'.S99DISP2))),';
    END;
 IF PARMSET(DISP3) THEN
    DO;
    WORK='00000000';
    IF DISP3='KEEP' THEN WORK='00001000';
    ELSE IF DISP3='DELETE' THEN WORK='00000100';
    ELSE IF DISP3='CATLG' THEN WORK='00000010';
    ELSE IF DISP3='UNCATLG' THEN WORK='00000001';
    ELSE NOTE('INVALID DISP3 VALUE',8);
    RTNR=RTNR××DYNALLOC2('S99DISP3',WORK,6,1,1,'B');
    RTNR2=RTNR2××'4 S99DISP3P PTR INIT((ADDR('××
              WORK2××'.S99DISP3))),';
    END;
 IF PARMSET(LABEL) THEN
    DO;
    WORK='00000000';
    IF LABEL='SL' THEN WORK='00000010';
    ELSE IF LABEL='NSL' THEN WORK='00000100';
    ELSE IF LABEL='NL' THEN WORK='00000001';
    ELSE IF LABEL='BLP' THEN WORK='00010000';
    ELSE IF LABEL='LTM' THEN WORK='00100001';
    ELSE IF LABEL='SUL' THEN WORK='00001000';
    ELSE IF LABEL='AL' THEN WORK='01000000';
    ELSE IF LABEL='AUL' THEN WORK='01001000';
    ELSE NOTE('INVALID LABEL VALUE',8);
    RTNR=RTNR××DYNALLOC2('S99LABEL',WORK,30,1,1,'B');
    RTNR2=RTNR2××'4 S99LABELP PTR INIT((ADDR('××
              WORK2××'.S99LABEL))),';
    END;
 IF PARMSET(TRTCH) THEN
    DO;
    WORK='00000000';
    IF TRTCH='E' THEN WORK='00100011';
    ELSE IF TRTCH='T' THEN WORK='00111011';
    ELSE IF TRTCH='C' THEN WORK='00010011';
    ELSE IF TRTCH='ET' THEN WORK='00101011';
    ELSE NOTE('INVALID TRTCH VALUE',8);
    RTNR=RTNR××DYNALLOC2('S99TRTCH',WORK,78,1,1,'B');
    RTNR2=RTNR2××'4 S99TRTCHP PTR INIT((ADDR('××
              WORK2××'.S99TRTCH))),';
    END;
 IF PARMSET(INTRDR) THEN
    DO;
    RTNR=RTNR××DYNALLOC2('S99SYSOUT','A',24,1,1,'C');
    RTNR2=RTNR2××'4 S99SYSOUTP PTR INIT((ADDR('××
         WORK2××'.S99SYSOUT))),';
    RTNR=RTNR××DYNALLOC2('S99INTRDR','INTRDR',25,1,6,'C');
    RTNR2=RTNR2××'4 S99INTRDRP PTR INIT((ADDR('××
         WORK2××'.S99INTRDR))),';
    END;
 /* NOW TO ADD A DUMMY ELEMENT TO THE END TO SET HIGH BIT
    IN TEXT PTR INDICATING END OF LIST */
 IF PARMSET(PERM) THEN
    DO;
    RTNR=RTNR××
         '3 S99CONVERT,
              4 S99KEY FIXED BIN INIT(82),
              4 S99COUNT FIXED BIN INIT(0),';
    RTNR2=RTNR2××
         '4 S99ENDP BIT(32) INIT((''1''B×UNSPEC(ADDR('××
              WORK2××'.S99CONVERT))));';
    END;
 ELSE
    DO;
    RTNR=RTNR××
         '3 S99CONVERT,
              4 S99KEY FIXED BIN INIT(83),
              4 S99COUNT FIXED BIN INIT(0),';
    RTNR2=RTNR2××
         '4 S99ENDP BIT(32) INIT((''1''B×UNSPEC(ADDR('××
              WORK2××'.S99CONVERT))));';
    END;
  IF MF='L' THEN GO TO RETURN;
  ELSE GO TO SVCCALL;
 MFECODE:
  /***************************************************/
  /*  MF(E) CODE TO SET PARAMETER VALUES INTO        */
  /*  STRUCTURE BUILT BY MF(L). CALLS DYNALLOC3      */
  /*  PREPROCESSOR PROCEDURE FOR COMMON ASSISTANCE   */
  /***************************************************/
 IF PARMSET(FILE) THEN
    RTNR=RTNR××DYNALLOC3(WORK2××'.S99FILE',FILE,1,1,8,'C');
 IF PARMSET(DSN) THEN
    RTNR=RTNR××DYNALLOC3(WORK2××'.S99DSN',DSN,2,1,44,'C');
 IF PARMSET(MEMBER) THEN
    RTNR=RTNR××DYNALLOC3(WORK2××'.S99MEMBER',MEMBER,3,1,8,'C');
 IF PARMSET(TRK) THEN
    RTNR=RTNR××DYNALLOC3(WORK2××'.S99TRK',TRK,7,0);
 IF PARMSET(CYL) THEN
    RTNR=RTNR××DYNALLOC3(WORK2××'.S99CYL',CYL,8,0);
 IF PARMSET(DIR) THEN
    RTNR=RTNR××DYNALLOC3(WORK2××'.S99DIR',DIR,12,1,3,'F');
 IF PARMSET(RLSE) THEN
    RTNR=RTNR××DYNALLOC3(WORK2××'.S99RLSE',RLSE,13,0);
 IF PARMSET(CONTIG) THEN
    RTNR=RTNR××DYNALLOC3(WORK2××'.S99CONTIG','00001000',14,1,1,'B');
 IF PARMSET(SER) THEN
    RTNR=RTNR××DYNALLOC3(WORK2××'.S99SER',SER,16,1,6,'C');
 IF PARMSET(UNIT) THEN
    RTNR=RTNR××DYNALLOC3(WORK2××'.S99UNIT',UNIT,21,1,8,'C');
 IF PARMSET(SYSOUT) THEN
    RTNR=RTNR××DYNALLOC3(WORK2××'.S99SYSOUT',SYSOUT,24,1,1,'C');
 IF PARMSET(FORMS) THEN
    RTNR=RTNR××DYNALLOC3(WORK2××'.S99FORMS',FORMS,26,1,4,'C');
 IF PARMSET(COPIES) THEN
    RTNR=RTNR××DYNALLOC3(WORK2××'.S99COPIES',COPIES,29,1,1,'F');
 IF PARMSET(POSITION) THEN
    RTNR=RTNR××DYNALLOC3(WORK2××'.S99POSITION',POSITION,31,1,2,'F');
 IF PARMSET(PROTECT) THEN
    RTNR=RTNR××DYNALLOC3(WORK2××'.S99PROTECT','99350',34,1,5,'C');
 IF PARMSET(DUMMY) THEN
    RTNR=RTNR××DYNALLOC3(WORK2××'.S99DUMMY',DUMMY,36,0);
 IF PARMSET(TERMINAL) THEN
    RTNR=RTNR××DYNALLOC3(WORK2××'.S99TERMINAL',TERMINAL,40,0);
 IF PARMSET(FCB) THEN
    RTNR=RTNR××DYNALLOC3(WORK2××'S99FCB',FCB,37,1,4,'C');
 IF PARMSET(UCS) THEN
    RTNR=RTNR××DYNALLOC3(WORK2××'S99UCS',UCS,41,1,4,'C');
 IF PARMSET(DEST) THEN
    RTNR=RTNR××DYNALLOC3(WORK2××'S99DEST',DEST,88,1,8,'C');
 IF PARMSET(SPACE1) THEN
    RTNR=RTNR××DYNALLOC3(WORK2××'.S99SPACE1',SPACE1,10,1,3,'F');
 IF PARMSET(SPACE2) THEN
    RTNR=RTNR××DYNALLOC3(WORK2××'.S99SPACE2',SPACE2,11,1,3,'F');
 IF PARMSET(DISP1) THEN
    DO;
    WORK='00000000';
    IF DISP1='SHR' THEN WORK='00001000';
    ELSE IF DISP1='NEW' THEN WORK='00000100';
    ELSE IF DISP1='MOD' THEN WORK='00000010';
    ELSE IF DISP1='OLD' THEN WORK='00000001';
    ELSE NOTE('INVALID DISP1 VALUE',8);
    RTNR=RTNR××DYNALLOC3(WORK2××'.S99DISP1',WORK,4,1,1,'B');
    END;
 IF PARMSET(DISP2) THEN
    DO;
    WORK='00000000';
    IF DISP2='KEEP' THEN WORK='00001000';
    ELSE IF DISP2='DELETE' THEN WORK='00000100';
    ELSE IF DISP2='CATLG' THEN WORK='00000010';
    ELSE IF DISP2='UNCATLG' THEN WORK='00000001';
    ELSE NOTE('INVALID DISP2 VALUE',8);
    RTNR=RTNR××DYNALLOC3(WORK2××'.S99DISP2',WORK,5,1,1,'B');
    END;
 IF PARMSET(DISP3) THEN
    DO;
    WORK='00000000';
    IF DISP3='KEEP' THEN WORK='00001000';
    ELSE IF DISP3='DELETE' THEN WORK='00000100';
    ELSE IF DISP3='CATLG' THEN WORK='00000010';
    ELSE IF DISP3='UNCATLG' THEN WORK='00000001';
    ELSE NOTE('INVALID DISP3 VALUE',8);
    RTNR=RTNR××DYNALLOC3(WORK2××'.S99DISP3',WORK,6,1,1,'B');
    END;
 IF PARMSET(LABEL) THEN
    DO;
    WORK='00000000';
    IF LABEL='SL' THEN WORK='00000010';
    ELSE IF LABEL='NSL' THEN WORK='00000100';
    ELSE IF LABEL='NL' THEN WORK='00000001';
    ELSE IF LABEL='BLP' THEN WORK='00010000';
    ELSE IF LABEL='LTM' THEN WORK='00100001';
    ELSE IF LABEL='SUL' THEN WORK='00001000';
    ELSE IF LABEL='AL' THEN WORK='01000000';
    ELSE IF LABEL='AUL' THEN WORK='01001000';
    ELSE NOTE('INVALID LABEL VALUE',8);
    RTNR=RTNR××DYNALLOC3(WORK2××'.S99LABEL',WORK,30,1,1,'B');
    END;
    DO;
    WORK='00000000';
    IF TRTCH='E' THEN WORK='00100011';
    ELSE IF TRTCH='T' THEN WORK='00111011';
    ELSE IF TRTCH='C' THEN WORK='00010011';
    ELSE IF TRTCH='ET' THEN WORK='00101011';
    ELSE NOTE('INVALID TRTCH VALUE',8);
    RTNR=RTNR××DYNALLOC3('S99TRTCH',WORK,78,1,1,'B');
    END;
 SVCCALL:
  /***********************************************************/
  /* NOW TO ISSUE SVC 99 AND ANALYZE THE RETURN. THIS CODE   */
  /* IS BYPASSED FOR MF=L.                                   */
  /***********************************************************/
  RTNR2=RTNR2×× '  CALL SVC(99,REGS);';
  IF PARMSET(DDNRTN) THEN
        DO;
        IF SUBSTR(DDNRTN,1,1)^='@' THEN
             NOTE('DDNRTN DOES NOT REFER TO CHAR VARIABLE',8);
        RTNR2=RTNR2××SUBSTR(DDNRTN,2)××'='××
               WORK2××'.S99DDNRTN.S99DATA;';
        END;
    RTNR2=RTNR2××' IF R15>0 THEN DO;';
  RTNR2=RTNR2××' CALL S99FAIL('××WORK2××',R15,MSG);'××ONERROR××';
    PUT EDIT(MSG)(COL(1),A); SIGNAL ERROR;';
    RTNR2=RTNR2××' END;
  END;';
  RETURN:
  IF MF^='E' THEN RTNR=RTNR××' 3 S99PTRS, '××RTNR2;
  ELSE RTNR=RTNR××RTNR2;
  RETURN(RTNR);
 % END;
 %SKIP(5);
 % DYNALLOC2:PROC(NAME,VAL,KEY,COUNT,LEN,TYPE) RETURNS(CHAR);
  /* SUBSIDIARY PREPROCESSOR PROCEDURE FOR DYNALLOC.               */
  /* GENERATES A DYNAMIC ALLOCATION TEXT UNIT AS A LEVEL           */
  /* 3 SUBSTRUCTURE ELEMENT AND RETURNS IT TO THE CALLER.          */
  /* THE STRUCTURE CONTAINS:                                       */
  /*    3 'NAME',                                                  */
  /*        4 S99KEY FIXED BIN,   /* NUMBER CHARACTERISTIC OF THE  */
  /*                              /* KEYWORD BEING SPECIFIED.      */
  /*        4 S99COUNT FIXED BIN, /* 0 FOR A LOGICAL TEXT UNIT     */
  /*                              /* 1 FOR ALL OTHER TEXT UNITS    */
  /*        4 S99LEN FIXED BIN,   /* OMITTED IF S99COUNT=0,        */
  /*                              /* OTHERWISE THE LENGTH IN BYTES */
  /*                              /* THE FOLLOWING DATA.           */
  /*        4 S99DATA ??????      /* THE CHARACTER, NUMERIC, OR BIN*/
  /*                              /* DATA REQUIRED FOR THE GIVEN   */
  /*                              /* KEYWORD.                      */
  /* SEE SPL:JOB MANAGMENT FOR AN EXHAUSTIVE DISCUSSION OF TEXT    */
  /* UNITS.                                                        */
 DCL (NAME,VAL,TYPE,RTNR) CHAR;
 DCL (KEY,COUNT,LEN) FIXED;
 RTNR=' 3 '××NAME××',
    4 S99KEY FIXED BIN INIT('××KEY××'),
     4 S99COUNT FIXED BIN INIT('××COUNT××'),';
 IF COUNT=0 THEN RETURN(RTNR);
 IF TYPE='C' THEN
    IF SUBSTR(VAL,1,1)^='@'
    THEN RTNR=RTNR××
              '4 S99LEN FIXED BIN INIT('××LENGTH(VAL)××'),
               4 S99DATA CHAR('××LEN××') INIT('''××VAL××'''),';
         ELSE RTNR=RTNR××
              '4 S99LEN FIXED BIN INIT((LENGTH('××SUBSTR(VAL,2)××'))),
               4 S99DATA CHAR('××LEN××') INIT(('××SUBSTR(VAL,2)××')),';
 ELSE IF TYPE='F' THEN
    RTNR=RTNR××
         '4 S99LEN FIXED BIN INIT('××LEN××'),
         4 S99DATA FIXED BIN(31) INIT(('××VAL××'*256**(4-'××LEN××'))),';
 ELSE IF TYPE='B' THEN
    RTNR=RTNR××
         '4 S99LEN FIXED BIN INIT(1),
     4 S99DATA BIT(8) INIT('''××VAL××'''B),';
 RETURN(RTNR);
 % END;
 %SKIP(5);
 % DYNALLOC3:PROC(NAME,VAL,KEY,COUNT,LEN,TYPE) RETURNS(CHAR);
  /* SUBSIDIARY PREPROCESSOR PROCEDURE FOR DYNALLOC. MODIFIES      */
  /* ONE TEXT UNIT FOR MF(E) VERSION OF THE MACRO. GENERATES       */
  /* AN ASSIGNMENT STATEMENT WHERE THE TARGET IS THE VARIABLE      */
  /* NAME FROM 'ID' AND THE KEYWORD NAME (EXAMPLE: FOR             */
  /* ID(XXXX) AND YYY(DATA), THE ASSIGNMENT IS                     */
  /*  XXXX.S99YYY.S99LEN= ????;                                    */
  /*  XXXX.S99YYY.S99DATA= ????;                                   */
  /* THE FORM OF THE SOURCE DEPENDS ON THE TYPE OF KEYWORD AND     */
  /* THE PRESENCE OF AN "@" IN CHARACTER KEYWORDS.                 */
 DCL (NAME,VAL,TYPE,RTNR) CHAR;
 DCL (KEY,COUNT,LEN) FIXED;
 IF COUNT=0 THEN NOTE(SUBSTR(NAME,INDEX(NAME,'.S99')+4)
               ××' ILLEGAL FOR MF(E)',8);
 RTNR='';
 IF TYPE='C' THEN
    IF SUBSTR(VAL,1,1)^='@'
    THEN RTNR=RTNR××
              NAME××'.S99LEN ='××LENGTH(VAL)××';'××
               NAME××'.S99DATA ='''××VAL××''';';
         ELSE RTNR=RTNR××
              NAME××'.S99LEN =LENGTH('××SUBSTR(VAL,2)××');'××
               NAME××'.S99DATA ='××SUBSTR(VAL,2)××';';
 ELSE IF TYPE='F' THEN
    RTNR=RTNR××
          NAME××'.S99DATA ='××VAL××'*256**(4-'××LEN××');';
 ELSE IF TYPE='B' THEN
    RTNR=RTNR××
     NAME××'.S99DATA ='''××VAL××'''B;';
 RETURN(RTNR);
 % END;
 %ACTIVATE DYNALLOC;
