*PROCESS OPT(TIME),LC(60);
 /*     R E C 7 3   ---   PROCESS SMF RECORD 73                       */
 REC73: PROC(REC_PTR, LOG_SIOR, LOG_QLEN,    /* VER 1.1  */
             LOG_PART_BUSY, LOG_PHYS_BUSY, LOG_REQ_DEFER,
             LOG_DEF_PHYS,  LOG_DEF_LOG, PHYS_SIOR,
             PHYS_AVGMS, PHYS_BUSY, PHYS_CPU_WAIT,
             LOG_CPU_MAP, LOG_PHYS_MAP, PHYS_TYPE);
 /* WRITTEN BY V.TICE (SCE) 02/03/78
0        MODIFIED 7/26/78  M.SPRINZEN
       COLLECT DATA FOR PHYSICAL CHANNELS
0        MODIFIED 4/3/78
       MAKE THE VECTOR SUBSCRIPT VALUE EQUAL TO THE LOGICAL PATH
       NUMBER
0   THE FUNCTION OF THIS PROGRAM IS TO LOOK AT SMF TYPE 76 RECORDS
    GENERATED BY RMF2 AND TO EXTRACT, COMPUTE AND RETURN THE
    REQUESTED DATA.
0   THE ARGUEMENTS ARE AS FOLLOWS:
0   INPUT:
        REC_PTR              POINTER TO RMF SMF COMMON SECTION
    OUTPUT:
        LOG_SIOR(*)      SIO RATES FOR (*) LOGICAL CHANNELS
        LOG_QLEN(*)      AVERAGE QUEUE LENGTH
        LOG_PART_BUSY(*) PARTIAL BUSY PERCENT
        LOG_PHYS_BUSY(*) PHYSICAL BUSY PERCENT
        LOG_REQ_DEFER(*) % REQUESTS DEFERED
        LOG_DEF_PHYS(*)  %DEFRD DUE TO PHYS BUSY
        LOG_DEF_LOG(*)   %DEFRD DUE TO LOGICAL BUSY
        PHYS_SIOR(*,*)   SIO RATE
        PHYS_AVGMS(*,*)  AVERAGE SERVICE TIME (MS,*)
        PHYS_BUSY(*,*)    % BUSY
        PHYS_CPU_WAIT(*,*) % CHAN BUSY AND CPU WAIT
        LOG_CPU_MAP(*)   INDICATES WHICH CPU FOR ABOVE ARRAY (0,1).
        LOG_PHYS_MAP(*)  INDICATES WHICH PHYS CHANNELS (0-F)
        PHYS_TYPE(*,*)   INDICATES TYPE OF CHANNEL
               WHERE 11.. ....   RESERVED
                     ..1. ....   BLOCK MULTIPLEXOR
                     ...1 ....   BYTE     "
                     .... 1...   RESERVED
                     .... .1..   INVALID CHANNEL ID
                     .... ..1.   CHAN VARIED (INVALID DATA)
                     .... ...1   CHAN CURRENTLY ONLINE
                     .... ....   SELECTOR
        NOTE: "PHYS_..." DATA ONLY SAVED IF CHAN CURRENTLY ONLINE.
              "PHYS_TYPE" IS ALWAYS PASSED BACK THOUGH.
0*/
0DCL REC_PTR           POINTER;
 DCL LOG_SIOR(*)       DEC FLOAT(6) CONNECTED;
 DCL LOG_QLEN(*)       DEC FLOAT(6) CONNECTED;
 DCL LOG_PHYS_BUSY(*)  DEC FLOAT(6) CONNECTED;
 DCL LOG_PART_BUSY(*)  DEC FLOAT(6) CONNECTED;
 DCL LOG_REQ_DEFER(*)  DEC FLOAT(6) CONNECTED;
 DCL LOG_DEF_PHYS(*)   DEC FLOAT(6) CONNECTED;
 DCL LOG_DEF_LOG(*)    DEC FLOAT(6) CONNECTED;
 DCL PHYS_SIOR(*,*)    DEC FLOAT(6) CONNECTED;
 DCL PHYS_AVGMS(*,*)   DEC FLOAT(6) CONNECTED;
 DCL PHYS_BUSY(*,*)    DEC FLOAT(6) CONNECTED;
 DCL PHYS_CPU_WAIT(*,*) DEC FLOAT(6) CONNECTED;
 DCL LOG_CPU_MAP(*)    BIT(16) ALIGNED;
 DCL LOG_PHYS_MAP(*)   BIT(16) ALIGNED;
 DCL PHYS_TYPE(*,*)    BIT(8)  ALIGNED;
0  /* FOLLOWING VARIABLES INTERNAL TO THIS ROUTINE */
 DCL COUNT      STATIC DEC FLOAT(6); /* WORK FOR SAMPLES */
 DCL LB         STATIC FIXED BIN(31); /* LOWER BOUND OF ARRAYS */
 DCL NLC        STATIC FIXED BIN(31); /* NO. OF ITEMS IN ARRAYS */
 DCL NLCP       STATIC FIXED BIN(31); /* PTR TO CURRENT ELEMENT */
 DCL TOTSAMPS   STATIC DEC FLOAT(6);  /* TOTAL SAMPLES IN INTERVAL */
 DCL I                 STATIC FIXED BIN(15);
 DCL TIME              STATIC FLOAT DEC(6);
 DCL 1 CHANNEL_ACTIVITY              BASED(REC_PTR) UNALIGNED,
     2 COMMON_SECT,
       3 CHANNEL_SIZ                 FIXED BIN(15),
       3 CHANNEL_INT_START           FIXED DEC(7),          /* HHMMSS */
       3 CHANNEL_RMF_START_DATE      FIXED DEC(7),          /* YYDDD  */
       3 CHANNEL_INT_DUR             FIXED DEC(7,5),      /* MMSSTTT */
       3 CHANNEL_RESV1               CHAR(4),
       3 CHANNEL_TOTAL_SAMPLES       FIXED BIN(31),
       3 CHANNEL_RMF_VERS            CHAR(2),
       3 CHANNEL_RESV3               CHAR(2),
       3 CHANNEL_OS_REL_LVL          CHAR(4),               /* NNLL   */
       3 CHANNEL_CYCLE_LENGTH        FIXED DEC(7,3),    /* SECONDS */
     2 CHANNEL_CONTROL_SECT,
       3 CHANNEL_RESV4               CHAR(2),
       3 CHANNEL_NO_PHYS             FIXED BIN(15),
       3 CHANNEL_SIZ_PHYS            FIXED BIN(15),
       3 CHANNEL_NO_LOG              FIXED BIN(15),
       3 CHANNEL_SIZ_LOG             FIXED BIN(15),
       3 CHANNEL_RESV5               CHAR(18),
     2 CHANNEL_PHYS_SECT(NDUM REFER(CHANNEL_NO_PHYS))
                       CHAR(NDUM REFER(CHANNEL_SIZ_PHYS)),
     2 CHANNEL_LOG_SECT(NDUM REFER(CHANNEL_NO_LOG))
                       CHAR(NDUM REFER(CHANNEL_SIZ_LOG));
0DCL 1 CHANNEL_LOG_MAP_SECT          BASED(LOG_PTR),
       2 CHANNEL_LOG_PATH              FIXED BIN(15),
       2 CHANNEL_RESV7                 FIXED BIN(15),
       2 CHANNEL_LOG_BIT_MAP           BIT(16) ALIGNED,
       2 CHANNEL_LOG_CPU_MAP           BIT(16) ALIGNED,
       2 CHANNEL_LOG_PHYS_BUSY         FIXED BIN(31),
       2 CHANNEL_LOG_PART_BUSY         FIXED BIN(31),
       2 CHANNEL_LOG_SIO               FIXED BIN(31),
       2 CHANNEL_LOG_RESV8             CHAR(20),
       2 CHANNEL_LOG_QUEUED            FIXED BIN(31),
       2 CHANNEL_LOG_DPHYS             FIXED BIN(31),
       2 CHANNEL_LOG_DLOG              FIXED BIN(31),
       2 CHANNEL_LOG_FPHYS             FIXED BIN(31),
       2 CHANNEL_LOG_FLOG              FIXED BIN(31);
0DCL 1 CHANNEL_PHYS_MAP_SECT          BASED(PHYS_PTR),
       2 CPU                           FIXED BIN(15), /* 0 OR 1 */
       2 CHANNEL_PHYS_ID               BIT(8) ALIGNED,  /* 0-15 */
       2 CHANNEL_PHYS_TYPE             BIT(8) ALIGNED,
       2 CHANNEL_PHYS_SIO              FIXED BIN(31),
       2 CHANNEL_PHYS_BUSY             FIXED BIN(31),
       2 CHANNEL_PHYS_CPUW             FIXED BIN(31);
0DCL   (LBOUND,HBOUND,ADDR,TRUNC,MOD)  BUILTIN;
0DCL   (LOG_PTR,PHYS_PTR)           POINTER STATIC;
0TIME = CHANNEL_INT_DUR;
 TIME = TRUNC(TIME) * 60 + MOD(TIME,1) * 1.E2;
 LB = LBOUND(LOG_SIOR,1);           /* MAKE SUBSCRIPTING OF PARMS
                                       INDEPENDENT OF LOWER BOUNDS */
 TOTSAMPS = CHANNEL_TOTAL_SAMPLES;
0LOG_LOOP: DO I = 1 TO CHANNEL_NO_LOG;
    LOG_PTR = ADDR(CHANNEL_LOG_SECT(I));
    NLCP = CHANNEL_LOG_PATH + LB;
    IF  NLCP <= HBOUND(LOG_SIOR,1) THEN DO; /* BYPASS OUT OF RANGE
                                               LOGICAL CHANNELS  */
         LOG_CPU_MAP(NLCP)  = CHANNEL_LOG_CPU_MAP;
         LOG_PHYS_MAP(NLCP) = CHANNEL_LOG_BIT_MAP;
         COUNT = CHANNEL_LOG_SIO;
         LOG_SIOR(NLCP) = COUNT/TIME;
         COUNT = CHANNEL_LOG_QUEUED;
         LOG_QLEN(NLCP) = COUNT/TOTSAMPS;
         COUNT = CHANNEL_LOG_PHYS_BUSY;
         LOG_PHYS_BUSY(NLCP) = 100*COUNT/TOTSAMPS;
         COUNT = CHANNEL_LOG_PART_BUSY;
         LOG_PART_BUSY(NLCP) = 100*COUNT/TOTSAMPS;
         COUNT = CHANNEL_LOG_DPHYS + CHANNEL_LOG_DLOG;
         IF CHANNEL_LOG_SIO ^= 0 THEN
              LOG_REQ_DEFER(NLCP) = 100*COUNT/CHANNEL_LOG_SIO;
         ELSE LOG_REQ_DEFER(NLCP) = 0;
         IF COUNT ^= 0 THEN
              LOG_DEF_PHYS(NLCP) = 100*CHANNEL_LOG_DPHYS / COUNT;
         ELSE LOG_DEF_PHYS(NLCP) = 0;
         LOG_DEF_LOG(NLCP)  = 100 - LOG_DEF_PHYS(NLCP);
         END;
    END; /* LOG_LOOP */
0LB = LBOUND(PHYS_SIOR,1);           /* MAKE SUBSCRIPTING OF PARMS
                                        INDEPENDENT OF LOWER BOUNDS */
0PHYS_LOOP: DO I = 1 TO CHANNEL_NO_PHYS;
    PHYS_PTR = ADDR(CHANNEL_PHYS_SECT(I));
    NLCP = CHANNEL_PHYS_ID   + LB;
    IF  NLCP <= HBOUND(PHYS_SIOR,1)  THEN DO ; /* BYPASS OUT OF RANGE*/
        PHYS_TYPE(NLCP,CPU) = CHANNEL_PHYS_TYPE; /* ALWAYS SAVE TYPE*/
        IF ( CHANNEL_PHYS_TYPE & '00000001'B ) THEN DO; /* ONLINE */
           COUNT = CHANNEL_PHYS_SIO;
           PHYS_SIOR(NLCP,CPU) = COUNT/TIME;
           IF ^(CHANNEL_PHYS_TYPE & '00010000'B) THEN DO; /*NOT BYTE*/
              COUNT = CHANNEL_PHYS_CPUW;
              PHYS_CPU_WAIT(NLCP,CPU) = 100 * COUNT/TOTSAMPS;
              COUNT = CHANNEL_PHYS_BUSY;
              PHYS_BUSY(NLCP,CPU) = 100*COUNT/TOTSAMPS;
              IF PHYS_SIOR(NLCP,CPU) ^= 0 THEN
                   PHYS_AVGMS(NLCP,CPU) = ( PHYS_BUSY(NLCP,CPU) /
                                         PHYS_SIOR(NLCP,CPU) ) * 10;
              ELSE PHYS_AVGMS(NLCP,CPU) = 0;
              END;
           END;
        END;
    END; /* PHYS_LOOP */
0END; /* REC73 */
