*PROCESS MACRO,INSOURCE,OPT(TIME),LC(60);
 /*     R M F R P T   ---   RMF-II POST PROCESSOR REPORT GENERATOR    */
 (SUBRG):RMFRPT: PROC  OPTIONS(MAIN);
 /*
                              R M F R P T

                              VERSION 2.09
                                08/02/78

                       SOUTHERN CALIFORNIA EDISON

                       WRITTEN BY: M.J. SPRINZEN
                                   V.S. TICE
                                   S.C. LANGLEY

     (RMFRPT MUST BE COMPILED WITH RELEASE 3 OR LATER PLI OPTIMIZER)



 RMFRPT DESCRIPTION
 ------------------

 RMFRPT IS AN RMF-II POST-PROCESSOR THAT GENERATES CONDENSED REPORTS
 UNDER USER CONTROL TO SUMMARIZE DATA FROM RMF INTERVALS. THE USER
 SPECIFIES THE SYSTEM PERFORMANCE PARAMETERS THAT SHOULD BE PRINTED
 AND THE TIME INTERVAL OVER WHICH THEY WERE GATHERED. RMFRPT THEN
 PRODUCES A CONCISE REPORT OVER ALL THE INCLUDED RMF INTERVALS. AN
 AVERAGE VALUE OVER THE INTERVALS IN QUESTION IS ALSO SUPPLIED.

 EACH RMF INTERVAL OCCUPIES ONE COLUMN OF THE REPORT, WITH 11 COLUMNS
 PER PAGE (DEFAULT) AND UP TO FIFTY INTERVALS IN A REPORT SET. FOR
 EXAMPLE, A REPORT SET COULD BE PRODUCED FOR ALL RMF INTERVALS FROM
 0900 TO 1200 ON 78019. IF THE INTERVALS ARE 10 MINUTES IN LENGTH,
 THE REPORT SET WOULD CONSIST OF 18 INTERVALS AND WOULD REQUIRE 19
 COLUMNS ON THE OUTPUT REPORT. (THE EXTRA COLUMN IS FOR AVERAGES)

 THE PROGRAM IS DESIGNED TO GIVE THE USER COMPLETE CONTROL OF THE
 REPORT FORMAT. THE USER CHOOSES: (1) WHICH OF THE APPROX 100 VARIABLES
 ARE TO BE PRINTED, (2) THE POSITION OF THE DECIMAL POINT FOR EACH
 VARIABLE, (3) LINE SKIPPING OR PAGE SKIPPING, (4) AN OPTIONAL
 OFFSET PARAMETER FOR READABILITY (SHIFTS REPORT LINE TO THE RIGHT),
 AND (5) THE PARAMETER NAME IF THE DEFAULT IS NOT ACCEPTABLE (I.E.
 "TSO USERS" RATHER THAN "PERFORM 2").

 A WIDE RANGE OF PERFORMANCE PARAMETERS MAY BE SELECTED: A LIST MAY
 BE FOUND IN THE SECTION "DESCRIPTION OF PARAMETERS". PARAMETERS COME
 IN 3 DIFFERENT TYPES: (1) "REGULAR" OR "SINGLE VALUE" PARAMETERS
 (SUCH AS 'CPU PERCENT BUSY' OR 'AVERAGE TSO USERS'), (2) "GROUP"
 PARAMETERS THAT REQUIRE A ADDITIONAL NUMBER BE SPECIFIED (SUCH AS
 'LOGICAL CHANNEL START IO'S, WHICH REQUIRES THAT A LOGICAL CHANNEL
 NUMBER BE SPECIFIED), AND (3) "DEVICE" PARAMETERS PERTAINING TO
 DIRECT ACCESS DEVICE DATA.

 WHEN PRINTING INFORMATION ABOUT DIRECT ACCESS DEVICES, THE USER
 HAS THE OPTION OF SELECTING DEVICES BY DEVICE ADDRESS, BY VOLUME
 SERIAL NUMBER, OR BY ASKING FOR THE DEVICE PRODUCING THE HIGHEST
 VALUE FOR SOME PARAMETER (THIS IS REFERED TO AS 'EXCEPTION REPORTING')
1JCL REQUIREMENTS
 ----------------


 SYSPRINT - REPORT OUTPUT. LRECL = 133.
 SYSIN    - INPUT CONTROL CARDS. LRECL = 80.
 SYSUT1   - SMF INPUT DATASET.


 INPUT CONTROL CARD DESCRIPTION
 ------------------------------

  GENERAL CONTROL CARD FORMAT:

         COL 1      CONTROL CARD TYPE    (BLANK OR 0,1,2,3,4, AND 9)
         COL 2 -72  CONTROL INFORMATION(DESCRIBED BELOW)
         COL 73-80  IGNORED   (CARD SEQUENCE NUMBERS)

  NOTES: (1) THE MINIMUM CARD REQUIREMENTS ARE: A TYPE "2" CARD(S) AND
             A TYPE "9" CARD.
         (2) CARDS MAY APPEAR IN ANY ORDER. ANY INFORMATION ON A CARD
             REPLACES ANY PREVIOUSLY STORED INFORMATION.
         (3) A "9" CARD INITIATES A RUN BY SPECIFYING A REPORT SET. NO
             MORE CARDS ARE READ UNTIL RUN COMPLETES.
         (4) MULTIPLE "9" CARDS MUST BE IN CHRONOLOGICAL ORDER (I.E.
             ASCENDING DATE/TIME SEQUENCE).
         (5) A "2" CARD(S) FOLLOWING A "9" CARD CAUSES COMPLETE RE-
             INITIALIZATION OF THE OUTPUT FORMAT.
         (6) OTHER THAN THE DEVICE EXCEPTION PARAMETERS,
             PARAMETERS (VIA A "2" CARD SPECIFICATION) MAY BE REPEATED
             ON THE OUTPUT REPORT.

  CONTROL CARD DESCRIPTIONS:

    CARD TYPE 0 (OR BLANK) - COMMENT CARD - OPTIONAL
         CARD IS SIMPLY PRINTED ON OUTPUT IN CONTROL CARD LISTING. THIS
         IS USEFUL FOR DOCUMENTING THE CONTROL CARD INPUT DATASET.

    CARD TYPE 1 - TITLE CARD - OPTIONAL
         TITLE IS TAKEN FROM COLS 2-72 AND APPEARS ON EACH REPORT PAGE.

    CARD TYPE 2 - REPORT FORMAT CONTROL CARD - REQUIRED
         (1) EACH CARD CONSISTS OF 3 'CONTROL FIELDS' OF 20 BYTES EACH.
             (COLUMNS 11-30, 31-50 AND 51-70).
         (2) BLANK CONTROL FIELDS ARE ACCEPTABLE AND WILL BE IGNORED.
         (3) EACH CONTROL FIELD IS DEFINED AS FOLLOWS:
             BYTE 1-3   'ID' NUMBR OF PARAMTER (REQUIRED)
                        REFER TO "DESCRIPTION OF PARAMETERS" SECTION.
             BYTE 4-5   'GROUP NUMBER'         (REQUIRED BY GROUP PARMS)
                        USER BY GROUP PARMS ONLY (500 SERIES)
                        (LCHN #, DOMAIN #, SWAP DS #, ETC.)
             BYTE 6     LINE CONTROL           (OPTIONAL)
                        0 OR BLANK - NO ACTION
                        1- SKIP ONE LINE BEFORE PRINTING
                        2- SKIP TO NEW PAGE BEFORE PRINTING
             BYTE 7     OFFSET CONTROL         (OPTIONAL)
                        SHIFT LINE N POSTIONS TO THE RIGHT
             BYTE 8     FORMAT CONTROL         (OPTIONAL)
                        N WHERE OUTPUT FORMAT IS F(8,N) (DEFAULT=0)
             BYTE 9-10  RESERVED               (IGNORED)
             BYTE 11-16 VOLUME SERIAL NUMBER   (OPTIONAL)
                        USED BY DEVICE PARMS ONLY (600 SERIES)
             BYTE 17-19 UNIT ADDRESS           (OPTIONAL)
                        USED BY DEVICE PARMS ONLY (600 SERIES)
             BYTE 20    RESERVED               (IGNORED)
         (4) IF A 'DEVICE' PARM IS SPECFIED (599 < ID < 700) AND NEITHER
             AN ADDRESS OR VOLSER IS GIVEN, AN 'EXCEPTION' REQUEST IS
             ASSUMED. FOR EXAMPLE, A 600 EXCEPTION REQUEST WOULD
             CAUSE DATA TO BE PRINTED FOR THE DEVICE WITH THE HIGHEST
             ACTIVITY IN EACH INTERVAL. EACH SUCEEDING 600 FOUND
             CAUSES THE DEVICE WITH THE NEXT LOWEST ACTIVITY TO BE
             PRINTED ON THE REPORT.
         (5) IF A 'GROUP' PARMAMETER IS SPECIFIED (499 < ID < 600)
             A SPECIFICATION MUST ALSO BE MADE FOR WHICH GROUP IS
             DESIRED IN BYTES 3-4. FOR EXAMPLE, TO PRINT THE NUMBER
             OF SIOS/SEC FOR LOGICAL CHANNEL 3, BYTES 1-5 OF THE
             CONTROL FIELD WOULD BE SPECIFIED AS '600 3'.
         (6) MULTIPLE TYPE '2' CARDS ARE USUALLY REQUIRED.

    CARD TYPE 3 - FIELD NAME CHANGE FOR REPORT OUTPUT - OPTIONAL
          CONTAINS FOLLOWING 2 FIELDS:
          COL   8-10  FIELD NUMBER
          COL  11-13  GROUP NUMBER (USED ONLY TO CHANGE GROUP PARM NAME)
          COL  14-25  NEW NAME

    CARD TYPE 4 - CONSTANTS CONTROL CARD - OPTIONAL
          CONTAINS FOLLOWING 4 FIELDS:
          COL   6-10  CONST: NON-TCB CPU CALCS (DEFAULT=.213 FOR 168-3)
                      - A CPU DEPENDENT # FROM "PERFORMANCE NOTEBOOK".
          COL  11-15  TSO PERFORMANCE GROUP (DEFAULT=2).
          COL  16-20  MIN NO SAMPLES IN AN INTERVAL - INTERVALS WITH
                      LESS THAN THIS AMOUNT WILL BE SKIPPED (DFLT=400).
          COL  21-25  INTERVALS (I.E. COLUMNS) PER PAGE (DFLT=11).

    CARD TYPE 9 - RUN CONTROL CARD - STARTS REPORT PROCESSING - REQUIRED
          CONTAINS FOLLOWING 3 FIELDS:
          COL  2      IF 1, THE IO CONFIGURATION REPORT IS SUPPRESSED.
          COL  6 -10  JULIAN DATE (YYDDD). IF THIS FIELD IS LEFT BLANK,
                      THE 1ST DAY IN THE SMF FILE WILL BE USED. IF THIS
                      FIELD IS "99999" THEN EVERY DAY IN SMF DATASET IS
                      IS USED WITH ONLY THIS REPORT SET (I.E. SYSIN FILE
                      IS NO LONGER READ).
          COL  12-15  START TIME (HHMM) - REQUIRED.
          COL  17-20  STOP  TIME (HHMM) - REQUIRED.
1SAMPLE INPUT DECK
 ------------------

  //STEPA EXEC PGM=RMFRPT
  //SYSUT1 DD DSN=SYS1.MANX,DISP=SHR
  //SYSPRINT DD SYSOUT=A
  //SYSIN    DD *
  1  ***** SAMPLE RUN *****       RMF REPORT GENERATOR
  0
  0  "2" CARD FORMAT:
  0  ID NUMBER, GROUP NUMBER, LINE CONTROL, OFFSET, FMT, VOLSER, ADDR
  0                 (F(3),F(2),(3)F(1),X(2),A(6),A(3),X(1))
  0
  0  PAGE 1: CPU BUSY & ADDRESS SPACE QUEUES
  2         001                 004  1 1            002    1
  2         003    1            005   11            006    1
  2         007    1            008    1
  0          PAGE RATES  TOT,SWAP,DMND,VIO,COMMON
  2         009  1              010                 011
  2         012                 013
  0          SWAPS (MOST HERE, SOME ON SECOND PAGE)
  2         014  1 2            015    2            016   12
  2         017    2            018    2            019   12
  2         020    2            021    2
  0          ASMQ, ASMIO, UIC, AFCAVG, & LOCAL AVERAGE BSY
  0             (NOTE: 1ST 3 DEPEND ON TRACING BEING IN EFFECT)
  2         054  1 1            057    1            055
  2         027                 052
  0          SU RATES - PERF GROUPS 1,6,7,4,8,10,2,3,5,15 AND TOTAL
  2         505 11              505 6               505 7
  2         505 4               505 8               50510
  2         505 2               505 3               505 5
  2         50515               030
  0          TSO RESPONSE - SHORT, MEDIUM, & LONG
  2         032  111            033    2            034    1
  2         035                 036   11            037    2
  2         038    1            039                 040   11
  2         041    2            042    1            043
  0  PAGE 2: DOMAIN TAR,MPL, & RUA TOTALS
  2         065  2 1            066    1            067    1
  0          DOMAIN TRACE INFO (NOTE: TRACING MUST BE IN EFFECT)
  0            TAR MPL
  2         500 21 1            500 3  1            500 7 11
  2         500 0  1            500 4 11            500 6  1
  2         500 8  1            500 1  1
  0            MPL
  2         501 21 1            501 3  1            501 7 11
  2         501 0  1            501 4 11            501 6  1
  2         501 8  1            501 1  1
  0            RUA
  2         502 21 1            502 3  1            502 7 11
  2         502 0  1            502 4 11            502 6  1
  2         502 8  1            502 1  1
  0            IN USER
  2         503 21 1            503 3  1            503 7 11
  2         503 0  1            503 4 11            503 6  1
  2         503 8  1            503 1  1
  0            OUT USER
  2         504 21 1            504 3  1            504 7 11
  2         504 0  1            504 4 11            504 6  1
  2         504 8  1            504 1  1
  0  PAGE 3: PAGE DATASET BUSY, AVG SLOTS USED, VIOSLOTS
  2         044  2              046                 050
  2         051                 523 11              523 2
  2         523 3               523 4               523 5
  2         523 6
  2         052                 053  1              028
  0          FRAME: COMMON, LPA/CSA, & FIXED FRAMES, DEFRD FR ALLOC, STE
  2         058  1              029                 059
  2         056                 062
  0          AFCMIN, AFCMAX, CHAN UTIL, & AVQLOW  (LAST 2 REQUIRE TRACIN
  2         025  1              026                 060
  2         061    1
  0          CPU CALCS (USES EQUATIONS FROM PERFORMANCE NOTEBOOK
  0                     WITH CONSTANT OF A 168-1/168-3 MP - .2435)
  2         068  1 1            069    1
  0            FMT:(5(X),(4)F(5)) - CPU CONST, TSO PG, MIN SAMP, COLS/PA
  4    .2435
  0  PAGE 4: CHANNELS
  0         LOGICAL CHANNEL UTILIZATIONS: 1,2,& 6 - SIO,QUE,& PBSY
  2         506 12              506 2               506 6
  2         507 11 2            507 2  2            507 6  2
  2         510 11              510 2               510 6
  2         511 11              511 2               511 6
  0         PHYSICAL CHANNEL UTILIZATIONS: 1,2,3,4,7,8 ON BOTH CPUS
  0         BUSY %
  2         515 11 1            519 1 11
  2         515 2 21            519 2 31
  2         515 3  1            519 3 11
  2         515 4 21            519 4 31
  2         515 7  1            519 7 11
  2         515 8 21            519 8 31
  0         ACTIVITY /SEC
  2         513 11 1            517 1 11
  2         513 2 21            517 2 31
  2         513 3  1            517 3 11
  2         513 4 21            517 4 31
  2         513 7  1            517 7 11
  2         513 8 21            517 8 31
  0         AV MS
  2         514 11 1            518 1 11
  2         514 2 21            518 2 31
  2         514 3  1            518 3 11
  2         514 4 21            518 4 31
  2         514 7  1            518 7 11
  2         514 8 21            518 8 31
  0  PAGE 5: SPECIFIC DEVICE ACTIVITY
  2         602  2 1  PAGEA5
  2         601    3  PAGEA5    600   10  PAGEA5    603    1  PAGEA5
  2         608    0  PAGEA5    609   1   PAGEA5
  2         610       PAGEA5    611   1   PAGEA5
  2         602  1 1  PAGEA6
  2         601    3  PAGEA6    600   10  PAGEA6    603    1  PAGEA6
  2         608    0  PAGEA6    609   1   PAGEA6
  2         610       PAGEA6    611   1   PAGEA6
  2         602  1 1  VSRESA
  2         601    3  VSRESA    600   10  VSRESA    603    1  VSRESA
  2         608   10  VSRESA    609       VSRESA
  2         610       VSRESA    611   1   VSRESA
  2         602  1 1  SYS003
  2         601    3  SYS003    600   10  SYS003    603    1  SYS003
  2         604       SYS003    605       SYS003
  2         608   10  SYS003    609       SYS003
  2         610       SYS003    611   1   SYS003
  0         % BUSY   - EXCEPTION REPORT
  2         602  1 0            602    0            602    0
  2         602    0            602    0            602    0
  2         602    0            602    0
  0  PAGE 4: DEVICE EXCEPTION REPORTING
  0         QUEUE LENGTH
  2         601  2 2            601    2            601    2
  0         ACTIVITY /S
  2         600  1 1            600    1
  0         % RESV
  2         604  1 0            604    0
  0         % DRESV
  2         605    0            605    0
  0         AVG QUEUE MS
  2         609  1 0            609    0            609    0
  2         609    0            609    0
  0         AVG DEV MS
  2         610  1 0            610    0            610    0
  2         610    0            610    0
  0         TOTAL MS
  2         611  1 0            611    0
  0         % CU DELAY
  2         603  1 0
  0         AVG DS OPEN
  2         606                 606
  0
  0    CHANGE SOME TITLES
  3      505 1SU/S S BATCH
  3      505 2SU/S TSO
  3      505 3SU/S PERF 3
  3      505 4SU/S SPECL
  3      505 5SU/S CICS
  3      505 6SU/S R BATCH
  3      505 7SU/S PROD
  3      505 8SU/S STC
  3      50510SU/S EMRGNCY
  3       30  SU/S   TOTAL
  0
  0    COCATENATED DATASET MUST FOLLOW WITH "9" CARDS SPECIFIED
  0
  0    DATE  START END   (DATE IS BLANK - USE FIRST DATE FOUND)
  9          0800 0900
  91         0900 1010
  //
1         D E S C R I P T I O N   O F   P A R A M E T E R S


 NUMBER   ABBREVIATION      DESCRIPTION

    1     'CPU BUSY %  '
    2     'IN READY    '    AVG JOBS(ADDRESS SPACES) SWAPPED IN & RDY
    3     'AVG SWP IN  '    AVG JOBS IN MEMORY, READY OR WAITING
    4     'OUT READY   '    AVG JOBS SWAPPED OUT AND READY
    5     'TSO USERS   '    AVG TSO USERS LOGGED ON
    6     'BATCH JOBS  '    AVG BATCH JOBS
    7     'STARTD TASKS'    AVG STARTED TASKS
    8     'OUT WAIT    '    AVG JOBS OUT AND WAITING (I.E.,INACT TSO)
    9     'PAGE TOT/SEC'    AVG TOTAL PAGES TRANSFERRED PER SEC.
   10     'PAGE SWAP   '    AVG SWAP PAGES IN OR OUT PER SEC.
   11     'PAGE VIO    '        VIRTUAL I/O PAGES PER SEC.
   12     'PAGE DEMAND '        DEMAND PAGES PER SEC.
   13     'PAGE COMMON '        SYSTEM AREA PAGES PER SEC.
   14     'SWAP TOT/SEC'    AVG TOTAL SWAPS PER SEC.
   15     'SWAP TINPT/S'        TERMINAL INPUT SWAPS PER SEC.
   16     'SWAP TOUT /S'        TERMINAL OUTPUT   "
   17     'SWAP LWAIT/S'        LONG WAIT (>.5 SECS) "
   18     'SWAP DWAIT/S'        DETECTED WAIT      "
   19     'SWAP UNIL /S'        UNILATERAL         "
   20     'SWAP XCHG /S'        EXCHANGE           "
   21     'SWAP ENQUE/S'        ENQUE              "
   22     'SWAP REQST/S'        REQUEST            "
   23     'SWAP ASS  /S'        AUXIALLIARY STORAGE SHORTAGE (SLOTS)
   24     'SWAP RSS  /S'        REAL STORAGE SHORTAGE (FRAMES)
   25     'AFC MIN     '     MINIMUM AVAILABLE FRAME COUNT
   26     'AFC MAX     '     MAXIMUM AVAILABLE FRAME COUNT
   27     'AFC AVG     '     AVERAGE AVAILABLE FRAME COUNT
   28     'VIO SLOTS   '     AVG TOTAL VIO SLOTS ALLOCATED
   29     'LPACSA FRM  '     AVG LPA/CSA FRAMES
   30     'SU/SEC TOTAL'     AVG SERVICE UNITS/SEC FOR ALL PERF. GROUPS
   32     'SEC TSO SHRT'     PERF GRP 2 PERIOD 1 -- AVG RESPONSE TIME
   33     'TRANS/S SHRT'          ENDED TRANS PER SEC. (SHORT)
   34     'SWAP/TR SHRT'          SWAPS/ENDED TRANSACTION
   35     'SU/S    SHRT'          SERVICE UNITS PER SEC IN PERIOD
   36     'SEC TSO MEDM'        PERIOD 2 (MEDIUM) AVG RESPONSE TIME
   37     'TRANS/S MEDM'          TRANS PER SEC.
   38     'SWAP/TR MEDM'          SWAPS PER TRAN.
   39     'SU/S    MEDM'          SERVICE UNITS PER SEC IN PERIOD
   40     'SEC TSO LONG'        PERIOD 3 (LONG) AVG RESPONSE TIME
   41     'TRANS/S LONG'          TRANS PER SEC.
   42     'SWAP/TR LONG'          SWAPS PER TRANS
   43     'SU/S    LONG'          SERVICE UNITS PER SEC
   44     'PLPA  BSY%  '     PLPA PAGE DATASET, % IN USE
   45     'PLPA  SLOT  '          SLOTS USED
   46     'COM   BSY%  '     COMMON PAGE DATASET, % IN USE
   47     'COM   SLOT  '            SLOTS USED
   48     'DUPLX BSY%  '     DUPLEX PAGE DATASET, % IN USE
   49     'DUPLX SLOT  '            SLOTS USED
   50     'SWAP AV BSY%'     SWAP DATASET(S), AVG % IN USE (BUSY)
   51     'SWAP AV SETS'            AVG SWAP SETS (12 SLOTS PER) ALLOC
   52     'LOC AVG BSY%'     LOCAL PAGE DATASET(S), AVG % IN USE
   53     'LOC AVG SLOT'            AVG SLOTS USED
                       THE FOLLOWING ARE FROM TYPE 76 TRACE RECORDS
                       IF AVG TRACED THEN AVG, ELSE AVG OF END VALUES
   54     'ASMQ        '  RCVASMQA-- DIFF BETWEEN PAGE OPS REQ'D & DONE
   55     'UIC         '  RCVUICA -- HI UNREFERENCED INTERVAL COUNT
   56     'PAGE REQ DEF'  PVTDFRS -- PAGES STOLEN (FRM ALLOC DEFERRED)
   57     'ASMIO CNT   '  ASMIOCNT -- NO. OF ASM I/OS IN PROGRESS
   58     'COMMON FRM  '  PVTCFMCT -- COMMON FRAMES ALLOCATED
   59     'PAGES FXED  '  PVTCNTFX -- FIXED FRAMES
   60     'TOT CHN UTIL'  RCVTOTDF -- AVG UTIL OF ALL LOG CHS
   61     'AVG LOWCNT  '  RCVAVQC -- NO. TIMES AVQ BELOW THRESH
   62     'FRCE STEAL  '  MCVFRCNT -- NO. PAGES FOR FORCED STEAL RT
   63     'HIGH UIC    '  MCVSTCRI -- HIGHEST SYSTEM UIC
   64     'NSW - ENQ   '  CCVENQCT -- ADDR SPACES NSW DUE TO ENQUE
   65     'TOT TAR MPL '  DMDTMPLT -- AVG TOTAL TARGET MPL
   66     'TOT MPL     '  DMDTCMPL -- TOTAL MPL
   67     'TOT RUA     '  DMDTRUA  -- TOTAL RDY AVG

   68     'SWAP CPU    '  %CPU USED FOR SWAP OPERATION (SEE PERF. NTBK)
   69     'PAGE CPU    '                PAGING               "
1

      THE FOLLOWING ARE "GROUP" PARAMETERS. THEY REQUIRE THAT AN
      ADDITIONAL NUMBER BE SPECIFIED IN COLUMNS 4-5 OF THE CONTROL
      FIELD DENOTING WHICH ITEM WITHIN THE GROUP IS DESIRED. FOR
      EXAMPLE, PARAMETERS 500-505 WOULD REQUIRE THAT A PARTICULAR
      DOMAIN NUMBER BE SPECIFIED.


  500     'TAR MPL: DOM'  DMDTMPLT--(TRACE REQ) DOMAIN TARGET MPL
  501     'MPL:  DOMAIN'  DMDTCMPL--(TRACE REQ) DOMAIN MPL
  502     'RUA:  DOMAIN'  DMDTRUA --(TRACE REQ) DOMAIN READY USERS AVG
  503     'IN USER: DOM'  DMDTINCU--(TRACE REQ) DOMAIN IN USERS
  504     'OUT USR: DOM'  DMDTOUTU--(TRACE REQ) DOMAIN OUT USERS
  505     'SU/S PRF GRP'  EACH PERF GROUP -- SERVICE UNITS PER SEC
  506     'REQ/S:  LCHN'  LOGICAL CHAN START I/OS PER SECOND
  507     'QUE:    LCHN'  AVG LOGICAL CHAN QUEUE
  508     'TOTBSY: LCHN'  % TIME ALL PHYS CH OF LOGICAL CH WERE BUSY
  509     'PRTBSY: LCHN'  % TIME LOG CH PARTIAL BUSY (>=1 & < ALL PH BS)
  510     'DEFRD%: LCHN'  % REQUESTS DEFFERRED
  511     'DF PHS%:LCHN'     % OF DEFERRED DUE TO PHYS BUSY (HDW COND)
  512     'DF LOG%:LCHN'     % OF DEFERRED DUE TO LOG BUSY  (SFTW COND)
  513     '% BUSY: CH 0'  % BUSY PHYS CH      -- FOR CPU 0
  514     '%CPUWT: CH 0'  % PHYS CH BUSY AND CPU WAIT
  515     'IO/SEC: CH 0'  ACTIVITY PER SEC
  516     'AVG MS: CH 0'  AVG MILLISECS CH SERVICE TIME
  517     '% BUSY: CH 1'  AS ABOVE BUT FOR CPU 1
  518     '%CPUWT: CH 1'             "
  519     'IO/SEC: CH 1'             "
  520     'AVG MS: CH 1'             "
  521     '% BUSY: SWAP'  % SWAP DS IN USE ( 1 FOR EACH SWAP DS)
  522     'SETS:   SWAP'  NUMBER SWAP SETS ALLOC ON PARTICULAR SWAP DS
  523     '% BSY: LOCAL'  % LOCAL PAGE DS IN USE (1 FOR EACH LOCAL)
  524     'SLOT:  LOCAL'  NUMBER SLOTS ALLOC ON PARTICULAR LOCAL DS


      THE FOLLOWING ARE "DEVICE" PARAMETERS. YOU MAY OPTIONALLY
      SPECIFY (1) THE VOLUME SERIAL NUMBER, (2) THE UNIT ADDRESS
      OR (3) REQUEST AN EXCEPTION REPORT. IF NEITHER (1) OR (2) IS
      SPECIFIED (3) WILL BE ASSUMED. FOR EXAMPLE, SIMPLY ISSUING THE
      PARAMETER 600 THREE TIMES WITHOUT A VOLSER OR ADDRESS WOULD
      CAUSE THE SIO/SEC AND VOLSER OF THE THREE MOST ACTIVE DEVICES
      TO BE PRINTED IN DESCENDING ORDER FOR EACH INTERVAL.


  600     'ACTIVITY/SEC'    DEVICE ACTIVITY - START IO'S / SECOND
  601     'QUEUE LENGTH'    AVERAGE IO QUEUE LENGTH
  602     '% BUSY      '    PCT TIME DEVICE WAS BUSY
  603     '%CU DELAY   '    % CONTROL UNIT DELAY (SEE RMF MANUAL)
  604     '% RESV      '    % RESERVE DELAY          "
  605     '% DEV RESV  '    % DEVICE RESERVED BY PROCESSOR RUNNING RMF
  606     'AVG DS OPEN '    AVERAGE NUMBER OF DATASETS OPEN
  607     '% REQ DEVBSY'    % OF REQ DEFERRED BECAUSE DEVICE BUSY
  608     '%REQ PATHBSY'    % OF REQ DEFERRED BECAUSE PATHBUSY
  609     'AVG QUEUE MS'    AVERAGE QUEUE LENGTH IN MS (SEE PERF NTBK)
  610     'AVG DEV MS  '    AVG DEVICE TIME PER I/O IN MS
  611     'TOTAL MS    '    AVG IO TIME (QUEUE + DEVICE)
1                  **** PREPROCESSOR STATEMENTS ****                 */
0%DCL  @MAX_SWAP             FIXED;
 %DCL  @MAX_LOCAL            FIXED;
 %DCL  @MAX_DEVICES          FIXED;
 %DCL  @MAX_DOM              FIXED;
 %DCL  @MAX_PG               FIXED;
 %DCL  @MAX_PERIOD           FIXED;
 %DCL  @MAX_LOGCHAN          FIXED;
 %DCL  @MAX_PHYSCHAN         FIXED;
 %DCL  @MAX_LOGCHAN1         FIXED;
 %DCL  @MAX_PHYSCHAN1        FIXED;
 %DCL  @NUM_PARMS            FIXED;
 %DCL  @NUM_INTM             FIXED;
 %DCL  @NUM_INT              FIXED;
 %DCL  @MAX_PAGEDS           FIXED;
 %DCL  @TOT_TRACE            FIXED;
 %DCL  @SNG_TRACE            FIXED;
 %DCL  @NUM_LINES            FIXED;
 %DCL  @NUM_GRP_PARMS        FIXED;
 %DCL  @NUM_DEV_PARMS        FIXED;
 %DCL  @MAX_GRPS             FIXED;
 %DCL  @MAX_GRPS1            FIXED;
 %DCL  @MAX_DEV_REQ          FIXED;
 %DCL  @LAST_SV              FIXED;
 %DCL  @FIRST_GRP            FIXED;
 %DCL  @LAST_GRP             FIXED;
 %DCL  @FIRST_DEV            FIXED;
 %DCL  @LAST_DEV             FIXED;
 %DCL  @@                    FIXED;
 %DCL  (@NUM_SWAP_PARMS, @NUM_LOCAL_PARMS,   @NUM_DOM_PARMS,
        @NUM_PG_PARMS,   @NUM_LOGCHAN_PARMS, @NUM_PHYSCHAN_PARMS)
        FIXED;
1/*********************************************************************/
 /*                                                                   */
 /*     THE FOLLOWING PREPROCESSOR VARIABLES MAY BE CHANGED BY THE    */
 /*     USER AS REQUIRED. THEY SET MAXIMUM VALUES THAT WILL BE        */
 /*     INSTALLATION DEPENDENT, SUCH AS NUMBER OF LOGICAL CHANNELS,   */
 /*     NUMBER OF DOMAINS, ETC.  ORDINARILY NO OTHER CHANGES SHOULD   */
 /*     BE NECESSARY TO INSTALL RMFRPT.                               */
 /*                                                                   */
 /*********************************************************************/
 %@MAX_SWAP      =   12;    /* MAX NUMBER SWAP DATASETS         12    */
 %@MAX_LOCAL     =   12;    /* MAX NUMBER LOCAL  "              12    */
 %@MAX_DOM       =   16;    /* MAX NUMBER DOMAINS               16    */
 %@MAX_PG        =   20;    /* MAX NUMBER PERFORMANCE GROUPS    20    */
 %@MAX_LOGCHAN   =   16;    /* MAX NUMBER LOGICAL CHANNELS      16    */
 %@MAX_PHYSCHAN  =   16;    /* MAX NUMBER PHYSICAL CHANNELS     16    */
 %@NUM_LINES     =  500;    /* MAX NUMBER OF LINES IN OUTPUT = 500    */
 %@MAX_PERIOD    =    8;    /* MAX NUMBER PERIODS = 8                 */
 %@MAX_DEVICES   =  100;    /* MAX NUMBER OF DEVICES = 100            */
 %@MAX_DEV_REQ   =  100;    /* MAX NUMBER OF DEVICE REQUESTS = 100    */
     /* I.E. MAX NUMBER OF '600' SERIES PARMS  */

 /*********************************************************************/
 /*                                                                   */
 /*     THE FOLLOWING PARAMETERS SHOULD NEVER HAVE TO BE CHANGED BY   */
 /*     THE USER *UNLESS* NEW GROUP PARAMETERS ARE ADDED TO THE       */
 /*     PROGRAM. (THIS REQUIRES SIGNIFIGANT PROGRAM MODIFICATION.)    */
 /*                                                                   */
 /*********************************************************************/
 /* FOLLOWING IS NUMBER OF PARMS WITHIN EACH OF ABOVE (I.E. FOR LOGCHAN
    "SIO/S", "%BUSY"  ETC. ARE COLLECTED - IN TOTAL, 7 PARMS */
 %@NUM_SWAP_PARMS     = 2;
 %@NUM_LOCAL_PARMS    = 2;
 %@NUM_DOM_PARMS      = 5;
 %@NUM_PG_PARMS       = 1;
 %@NUM_LOGCHAN_PARMS  = 7;
 %@NUM_PHYSCHAN_PARMS = 8;
 /* GET THE TOTAL NUMBER */
 %@NUM_GRP_PARMS =
        @NUM_SWAP_PARMS + @NUM_LOCAL_PARMS  + @NUM_DOM_PARMS +
        @NUM_PG_PARMS   + @NUM_LOGCHAN_PARMS+ @NUM_PHYSCHAN_PARMS;

  /* CALCULATE MAX GROUP PARM LIMIT - USED FOR DIMENSIONING ARRAYS   */
 %@@ = @MAX_SWAP ; /* GET LARGEST GROUP PARM */
 % IF @MAX_LOCAL    > @@  % THEN %@@ = @MAX_LOCAL  ;
 % IF @MAX_DOM      > @@  % THEN %@@ = @MAX_DOM    ;
 % IF @MAX_PG       > @@  % THEN %@@ = @MAX_PG     ;
 % IF @MAX_LOGCHAN  > @@  % THEN %@@ = @MAX_LOGCHAN   ;
 % IF @MAX_PHYSCHAN > @@  % THEN %@@ = @MAX_PHYSCHAN  ;
 %@MAX_GRPS      =   @@;

  /*  INTERNALLY USED PARAMETERS - DO NOT CHANGE UNLESS CHANGE PROGRAM*/
 %@NUM_PARMS     =   69;    /* NUMBER OF SINGLE VALUE PARMS = 69      */
 %@NUM_INT       =   51;    /* MAXIMUM INTERVALS (PER SET) = 51       */
 %@NUM_INTM      =   @NUM_INT - 1;
 %@MAX_LOGCHAN1  =   @MAX_LOGCHAN - 1;
 %@MAX_PHYSCHAN1 =   @MAX_PHYSCHAN - 1;
 %@MAX_PAGEDS    =  3 + @MAX_SWAP + @MAX_LOCAL;
 %@SNG_TRACE     =   11;    /* TRACE PARMS ^ REFERING TO DOMAINS = 11 */
                            /* TOTAL TRACE PARMS = 91                 */
 %@TOT_TRACE     =   5 * @MAX_DOM + 12;
 %@NUM_DEV_PARMS =   12;    /* NUMBER OF DEVICE PARMS = 12            */
 %@MAX_GRPS1     =   @MAX_GRPS + 1;
 %@LAST_SV       =  499;    /* LAST SINGLE VALUED PARM = 499          */
 /*********************************************************************/
 /*                                                                   */
 /*     NOTE THAT PREPROCESSOR VARIABLES '@FIRST_GRP' AND             */
 /*     '@FIRST_DEV' ARE ALSO DECLARED IN EXTERNAL SUBROUTINE         */
 /*     'REPORT'. THE VALUES ASSIGNED TO THEM MUST BE THE SAME IN     */
 /*     BOTH RMFRPT AND REPORT. (HOWEVER, THEY SHOULD NEVER HAVE TO   */
 /*     BE MODIFIED.)                                                 */
 /*                                                                   */
 /*********************************************************************/
 %@FIRST_GRP     =  500;    /* FIRST GROUP PARM = 500                */
 %@LAST_GRP      =  @FIRST_GRP + @NUM_GRP_PARMS - 1;
 %@FIRST_DEV     =  600;    /* FIRST DEVICE PARM = 600, LAST =611    */
 %@LAST_DEV      =  @FIRST_DEV + @NUM_DEV_PARMS - 1;

1/*********************************************************************/
 /*                                                                   */
 /*     DECLARE VARIABLES                                             */
 /*                                                                   */
 /*********************************************************************/
  DEFAULT RANGE(I:N) VALUE(FIXED BIN(15)),
          RANGE(*)   STATIC;

  DCL   DESCRIBE_RESULTS(@NUM_PARMS) CHAR(12) INIT(

   /*       1 =>  8    REC70 DATA                      8 FIELDS */
   /*  1 */ 'CPU BUSY %  ','IN READY    ','AVG SWP IN  ','OUT READY   ',
   /*  5 */ 'TSO USERS   ','BATCH JOBS  ','STARTD TASKS','OUT WAIT    ',

   /*       9 => 29    REC71 DATA                     21 FIELDS */
   /*  9 */ 'PAGE TOT/SEC','PAGE SWAP   ','PAGE VIO    ','PAGE DEMAND ',
   /* 13 */ 'PAGE COMMON ',
   /* 14 */ 'SWAP TOT/SEC','SWAP TINPT/S','SWAP TOUT /S','SWAP LWAIT/S',
   /* 18 */ 'SWAP DWAIT/S','SWAP UNIL /S','SWAP XCHG /S','SWAP ENQUE/S',
   /* 22 */ 'SWAP REQST/S','SWAP ASS  /S','SWAP RSS  /S','AFC MIN     ',
   /* 26 */ 'AFC MAX     ','AFC AVG     ','VIO SLOTS   ','LPACSA FRM  ',

   /*      30 => 43   REC72       TSO RESPONSE        14 FIELDS */
   /* 30 */ 'SU/SEC TOTAL','OUT QUE TIME',
   /* 32 */ 'SEC TSO SHRT','TRANS/S SHRT','SWAP/TR SHRT','SU/S    SHRT',
   /* 36 */ 'SEC TSO MEDM','TRANS/S MEDM','SWAP/TR MEDM','SU/S    MEDM',
   /* 40 */ 'SEC TSO LONG','TRANS/S LONG','SWAP/TR LONG','SU/S    LONG',

   /*     44  =>  53  REC75   (PAGE/SWAP DEVICE)      10 FIELDS */
   /* 44 */ 'PLPA   BSY% ','PLPA   SLOTS',
   /* 46 */ 'COMMON BSY% ','COMMON SLOTS',
   /* 48 */ 'DUPLEX BSY% ','DUPLEX SLOTS',
   /* 50 */ 'SWAP AV BSY%','SWAP AV SETS',
   /* 52 */ 'LOC AVG BSY%','LOC AV SLOTS',

   /*     54 => 64   REC76  - TRACE DATA             11 FIELDS */
   /* 54 */ 'ASMQ        ','UIC         ','PAGE REQ DEF',
   /* 57 */ 'ASMIO CNT   ','COMMON FRM  ','PAGES FIXED ',
   /* 60 */ 'TOT CHN UTIL','AVQ LOWCNT  ','FORCE STEAL ',
   /* 63 */ 'HIGH UIC    ','NSW - ENQ   ',

   /*       65 => 69                              */
   /* 65 */ 'TOT TAR MPL ','TOTAL MPL   ','TOTAL RUA   ',
   /* 68 */ 'SWAP CPU    ','PAGE CPU    '              );
1 DCL   DESCRIBE_GRP_RESULTS(@FIRST_GRP:@LAST_GRP,0:@MAX_GRPS) CHAR(12)
        INIT(
   /*500*/ (@MAX_GRPS1)(1)'TAR MPL: DOM',
   /*501*/ (@MAX_GRPS1)(1)'MPL:  DOMAIN',
   /*502*/ (@MAX_GRPS1)(1)'RUA:  DOMAIN',
   /*503*/ (@MAX_GRPS1)(1)'IN USER: DOM',
   /*504*/ (@MAX_GRPS1)(1)'OUT USR: DOM',
   /*505*/ (@MAX_GRPS1)(1)'SU/S PRF GRP',
   /*506*/ (@MAX_GRPS1)(1)'REQ/S:  LCHN',
   /*507*/ (@MAX_GRPS1)(1)'QUE:    LCHN',
   /*508*/ (@MAX_GRPS1)(1)'TOTBSY: LCHN',
   /*509*/ (@MAX_GRPS1)(1)'PRTBSY: LCHN',
   /*510*/ (@MAX_GRPS1)(1)'DEFRD%: LCHN',
   /*511*/ (@MAX_GRPS1)(1)'DF PHS% LCHN',
   /*512*/ (@MAX_GRPS1)(1)'DF LOG%:LCHN',
   /*513*/ (@MAX_GRPS1)(1)'IO/SEC: CH 0',
   /*514*/ (@MAX_GRPS1)(1)'AVG MS: CH 0',
   /*515*/ (@MAX_GRPS1)(1)'% BUSY: CH 0',
   /*516*/ (@MAX_GRPS1)(1)'%CPUWT: CH 0',
   /*517*/ (@MAX_GRPS1)(1)'IO/SEC: CH 1',
   /*518*/ (@MAX_GRPS1)(1)'AVG MS: CH 1',
   /*519*/ (@MAX_GRPS1)(1)'% BUSY: CH 1',
   /*520*/ (@MAX_GRPS1)(1)'%CPUWT: CH 1',
   /*521*/ (@MAX_GRPS1)(1)'% BUSY: SWAP',
   /*522*/ (@MAX_GRPS1)(1)'SETS:   SWAP',
   /*523*/ (@MAX_GRPS1)(1)'% BSY: LOCAL',
   /*524*/ (@MAX_GRPS1)(1)'SLOT:  LOCAL');
-  DCL  DESCRIBE_DEV_RESULTS(@FIRST_DEV:@LAST_DEV) CHAR(12) INIT(

   /*       1 => 12    REC75 DATA                     12 FIELDS */
   /*600 */ 'ACTIVITY/SEC','QUEUE LENGTH','% BUSY      ','% CU DELAY  ',
   /*604 */ '% RESV      ','% DEV RESV  ','AVG DS OPEN ','% REQ DEVBSY',
   /*608 */ '%REQ PATHBSY','AVG QUEUE MS','AVG DEV MS  ','TOTAL MS   ');
-  DCL  D76_LIST(@TOT_TRACE) CHAR(8) INIT(
   /* THIS ARRAY MUST BE INITIALIZE AS "DESCRIBE_RESULTS" */
   /*   */ 'RCVASMQA','RCVUICA ','PVTDFRS ',
   /*   */ 'ASMIOCNT','PVTCFMCT','PVTCNTFX',
   /*   */ 'RCVTOTDF','RCVAVQC ','MCVFRCNT',
   /*   */ 'MCVSTCRI','CCVENQCT', (5*@MAX_DOM)(1)'FILL LTR' ),
   /*  REST OF THIS ARRAY IS FILLED IN AT RUN TIME */
       D76_TRACE         FLOAT DEC(6);
1  DCL (P1,P2,P3,P4,P5,P6,P7,P8,P9,P10,P11,P12,P13,P14,P15,P16,P17,
        P18,P19,P20,P21,P22,P23,P24)  FIXED BIN(15);

  /* POSITION POINTERS INTO RESULTS ARRAY */
     P1  = 1;        /* CPU BUSY %   */
     P2  = 9;        /* PAGE TOT/S   */
     P7  = 44;       /* PLPA  BSY%   */
     P8  = 45;       /* PLPA  SLOT   */
     P9  = 54;       /* ASMQ         */
     P11 = 30;       /* SU/S TOTAL   */
     P12 = 32;       /* SEC TSO SH   */
     P13 = 52;       /* LCLAV BSY%   */
     P14 = 53;       /* LCL AVSLOT   */
     P17 = 50;       /* SWPAV BSY%   */
     P18 = 51;       /* SWP AV SET   */
     P21 = 65;       /* TOT TAR MP   */
     P23 = 68;       /* SWAP CPU     */
     P24 = 69;       /* PAGE CPU     */

   DCL (G1,G2,G3,G4,G5,G6,G7,G8,G9,G10,G11,G12,G13,G14,G15,G16,G17,
        G18,G19,G20,G21,G22,G23,G24,G25) FIXED BIN(15);

  /* POSITION POINTERS INTO GRP_RESULTS ARRAY */
     G9  = @FIRST_GRP +  0;       /* TAR MPL  DOM */
     G10 = @FIRST_GRP +  1;       /* MPL      DOM */
     G11 = @FIRST_GRP +  2;       /* RUA      DOM */
     G24 = @FIRST_GRP +  3;       /* IN USERS DOM */
     G25 = @FIRST_GRP +  4;       /* OUT USRS DOM */
     G12 = @FIRST_GRP +  5;       /* SU / SEC     */
     G1  = @FIRST_GRP +  6;       /* LCHN SIO   */
     G2  = @FIRST_GRP +  7;       /* LCHN QUE   */
     G3  = @FIRST_GRP +  8;       /* LCHN TBSY  - TOTAL   BUSY */
     G4  = @FIRST_GRP +  9;       /* LCHN PBSY  - PARTIAL BUSY */
     G13 = @FIRST_GRP + 10;       /* LCHN %DEFR   */
     G14 = @FIRST_GRP + 11;       /* LCHN %DEF PHY*/
     G15 = @FIRST_GRP + 12;       /* LCHN %DEF LOG*/
     G16 = @FIRST_GRP + 13;       /* PCHN SIO/S   CPU 0 */
     G17 = @FIRST_GRP + 14;       /* PCHN AVG MS  CPU 0 */
     G18 = @FIRST_GRP + 15;       /* PCHN % BUSY  CPU 0 */
     G19 = @FIRST_GRP + 16;       /* PCHN % CPU W CPU 0 */
     G20 = @FIRST_GRP + 17;       /* PCHN SIO/S   CPU 1 */
     G21 = @FIRST_GRP + 18;       /* PCHN AVG MS  CPU 1 */
     G22 = @FIRST_GRP + 19;       /* PCHN % BUSY  CPU 1 */
     G23 = @FIRST_GRP + 20;       /* PCHN % CPU W CPU 1 */
     G5  = @FIRST_GRP + 21;       /* SWP BSY%   */
     G6  = @FIRST_GRP + 22;       /* SWP SETS   */
     G7  = @FIRST_GRP + 23;       /* LOCAL BSY%   */
     G8  = @FIRST_GRP + 24;       /* LOCAL SLOTS  */
1 /* FOLLOWING DECLARE FOR VARIABLES THAT NEED TO BE INITIALIZED
     ONLY ONCE PER RUN OF PROGRAM                              */
  DCL (RMF_STOPPED_FLAG, READ_NEXT_DATE_FLAG, INPUT_FLAG)
                            FIXED BIN(15) INIT(0),
       PASS                 FIXED BIN(15) INIT(0),
       EOFHIT               FIXED BIN(15) INIT(0),
       NO_LINES             FIXED BIN(15) INIT(0),
       DATE_WAS_99999       FIXED BIN(15) INIT(0),
       /* TSO RESPONSE INFO. IS TAKEN FROM THIS PERFORMANCE GROUP*/
       TSO_PG               FIXED BIN(15) INIT(2),
       INT_PER_PAGE         FIXED BIN(15) INIT(11),
       C_MIN_SAMPLES        FIXED BIN(31) INIT(400),
       WEEKDAY_TYPE         FIXED BIN(31) INIT(3),/*USED BY "WEEKDAY"*/
       OLD_SMFXXIST         FIXED DEC(6)  INIT(0),
       RMFHIT(0:255)        FIXED BIN(15)
          INIT((70)0,70,71,72,73,74,75,76,77,78,79,(176)0),
      (SYSPRINT,SYSIN,SYSUT1)             FILE,
       /* FOR NON-TCB CPU CALCS, DEFAULT IS FOR A 168-3 CPU -
          IS .213 -- MAY OVERRIDE ON TYPE "4" CONTROL CARD */
       CONST                FLOAT DEC(6)  INIT(.213);
0 DCL  TITLE                CHAR (71),  /* COL 2-72 */
      (I,J,II,JJ,M,N,L,K)   FIXED BIN(15),  /* TEMPORARY VARIABLES */
       REC_READ             FIXED BIN(31),
      (RMFTYPE,SUPPRESS_CONFIG)   FIXED BIN(15),
       TIME_INT_START(@NUM_INT)   FIXED DEC(7),
       DURATION      (@NUM_INT)   FIXED DEC(7),
       NUM_SAMPLES   (@NUM_INT)   FIXED BIN(31),
       1 PRNT(@NUM_LINES),
         2 PARM             FIXED BIN(15),
         2 GROUP            FIXED BIN(15),
         2 EXCEPT           FIXED BIN(15),
         2 VOLSER           CHAR(6),
         2 ADDR             CHAR(3),
         2 CNTL             FIXED BIN(15),
         2 OFFSET           FIXED BIN(15),
         2 FMT              FIXED BIN(15),
         2 DEVPTR           FIXED BIN(15),
       DEV_REQ_PTR          FIXED BIN(15)   INIT(0),
       D74_VOLSER(@MAX_DEV_REQ)     CHAR(6),
       D74_ADDR(@MAX_DEV_REQ)       CHAR(3),
       D74_TYPE(@MAX_DEV_REQ)       FIXED BIN(15),
       D74_DEV_TYPE(@MAX_DEV_REQ)   FIXED BIN(15),
       D74_COND(@MAX_DEV_REQ)       FIXED BIN(15),
       D74_VOLSER_TAB(@MAX_DEVICES) CHAR(6),
       D74_ADDR_TAB(@MAX_DEVICES)   CHAR(3),
       D74_NUMDEVICES               FIXED BIN(15),
       SYSID                CHAR(4),
       JCHAR                PIC'999',
       DATEX                FIXED DEC(7),   /* 00YYDDDF */
       YEAR                 FIXED DEC(2),
       DAYS                 FIXED DEC(3),
      (TIME_BEGIN,TIME_END) FIXED DEC(7), /* OHHMMSSF FORMAT */
      (RMF_PTR,REC_PTR)                   POINTER,
      (PLIRETC,ADDR,ONCODE,SUBSTR,HBOUND,MOD,TRUNC,TIME,
       FLOAT,SUM,CEIL)  BUILTIN,
      (REPORT,WEEKDAY)  ENTRY EXTERNAL;

  /* FOLLOWING PAGE DSN INFO */
  DCL  D75_ADDR    (@MAX_PAGEDS) CHAR(3),
       D75_DSN     (@MAX_PAGEDS) CHAR(44),
       D75_VOLSER  (@MAX_PAGEDS) CHAR(6);

1 /* FOLLOWING DECLARE FOR VARIABLES THAT NEED TO BE
     INITIALIZED PRIOR TO EACH SET OF INTERVALS TO BE PROCESSED
     ------------------------------------------                      */
0 DCL  INTERVAL               FIXED BIN(15),
      (FLAG2,FLAG3)           FIXED BIN(15),
       INT_1ST_READ_FLAG      FIXED BIN(15),
       TIME_NOW               FIXED DEC (7),
       JUL                    FIXED DEC (7), /*00YYDDDF */
       GREG                   CHAR(6),       /* YYMMDD  */
       WEEK_DAY               CHAR(9),
       TIME_INT_SECONDS  (@NUM_INT)          FLOAT DEC (6);
0 DCL
     ( RESULTS    (@NUM_PARMS,@NUM_INT),
       GRP_RESULTS(@FIRST_GRP:@LAST_GRP,0:@MAX_GRPS,@NUM_INT),
       DEV_RESULTS(@MAX_DEV_REQ,@NUM_INT),
       RESULTS_PG (@MAX_PG, @MAX_PERIOD, 4, @NUM_INT) ) FLOAT DEC (6),
       EXCEPT_VOLSER(@MAX_DEV_REQ,@NUM_INT)  CHAR(6),
       DEV_EXCEPT(@FIRST_DEV:@LAST_DEV) INIT((@NUM_DEV_PARMS)(0)),
0       /* LOGICAL CHANNEL DEFINITIONS - (CPU, PHYSICAL CHAN) */
      (D73_LOG_CPU_BITS,D73_LOG_CHAN_BITS) (0:@MAX_LOGCHAN1)
       BIT(16) ALIGNED,
       D73_PHYS_TYPE (0:@MAX_PHYSCHAN1,0:1) BIT(8) ALIGNED;
       /* 2ND DIMEN IS FOR 2 CPUS.
          BIT MEANINGS:   .... .... SELECTOR
                          11.. .... RESERVED
                          ..1. .... BLOCK MPX
                          ...1 .... BYTE  MPX
                          .... 1... RESERVED
                          .... .1.. INVALID CHAN ID
                          .... ..1. CHAN VARIED (INVALID DATA)
                          .... ...1 CHAN CURRENTLY ONLINE
                      IF  0000 0000 PGM ASSUMES NON-EXISTENT CHAN */
- DCL 1 SMF_RECORD BASED(REC_PTR),
        2 SMF_COMMON,   /* 14 BYTES LONG */
          3 DUM1 CHAR(1),
          3 SMFXXRTY BIT(8) ALIGNED,  /* RECORD TYPE */
          3 DUM2 CHAR(4),
          3 SMFXXDTE FIXED DEC(7),    /* DATE */
          3 SMFXXSID CHAR(4),         /* SYSTEM ID */
        2 RMF_COMMON,   /* 34 BYTES LONG */
          3 DUM3 CHAR(2),
          3 SMFXXIST FIXED DEC(7),  /* START TIME        - 0HHMMSSF */
          3 SMFXXDAT FIXED DEC(7),  /* DATE              - 00YYDDDF */
          3 SMFXXINT FIXED DEC(7),  /* INTERVAL DURATION - MMSSTTTF */
          3 DUM4 CHAR(4),
          3 SMFXXSAM FIXED BIN(31), /* NO. OF SAMPLES */
          3 SMFXXMFV CHAR(2),       /* RMF VERSION NUMBER - EBCDIC*/
          3 DUM4X CHAR(10);

  /* ASSIGN INITIAL VALUES TO DOMAIN SEARCH ARGUMENTS FOR TRACE RECD*/
  DO J = 1 TO @MAX_DOM;
      JCHAR = J-1;  /* COVERT TO 3 EBCDIC CHARS - START DOM 0 */
      D76_LIST( J + @SNG_TRACE              ) = 'DMTAR'××JCHAR;
      D76_LIST( J + @SNG_TRACE +   @MAX_DOM ) = 'DMMPL'××JCHAR;
      D76_LIST( J + @SNG_TRACE + 2*@MAX_DOM ) = 'DMRUA'××JCHAR;
      D76_LIST( J + @SNG_TRACE + 3*@MAX_DOM ) = 'DMINU'××JCHAR;
      D76_LIST( J + @SNG_TRACE + 4*@MAX_DOM ) = 'DMOUT'××JCHAR;
  END;

1/*********************************************************************/
 /*                                                                   */
 /*     (1) OPEN FILES                                                */
 /*     (2) SETUP ON CONDITIONS                                       */
 /*                                                                   */
 /*********************************************************************/
  OPEN FILE(SYSPRINT) PRINT LINESIZE(132),
       FILE(SYSIN)    RECORD INPUT,
       FILE(SYSUT1)   RECORD INPUT;

  /* IF DATA EXCEPTION, DUMP SMF RECORD */
  ON ERROR BEGIN;
     IF ONCODE=8097 THEN
       PUT EDIT(SMF_RECORD) (A,X(1));
  END;

  /* IF EOF HIT ON SYSUT1, END TIME NOT SPEC. CORRECTLY, PRINT
     WARNING MESSAGE AND REPORT                     */
  ON ENDFILE (SYSUT1) BEGIN;
     EOFHIT = 1;
     CLOSE FILE(SYSUT1), FILE(SYSIN);
       /* WAS EOF HIT ON PRIMING READ ?  */
     IF (REC_READ = 0) THEN
       DO;
         PUT EDIT('***** SMF DATASET IS EMPTY  -  ABORT *****')
                 (SKIP,A);
         CALL PLIRETC(12);
         GO TO RETC;
       END;
     IF (INTERVAL > 0) THEN
       DO;
         PUT SKIP(2) EDIT('***** WARNING - EOF ON SYSUT1 PRIOR TO',
         ' LAST INTERVAL SPECIFIED *****') ((2)A);
         CALL PLIRETC(4);
         GO TO ALLDONE;
       END;
     ELSE
       DO;
         /* THIS IS NORMAL TERMINATION FOR '99999' DATE OPTION */
         IF DATE_WAS_99999 = 1 THEN
           DO;
             PUT EDIT('EOF ON SYSUT1 - NORMAL TERMINATION FOR ',
                      '''99999'' OPTION') (PAGE,(2)A);
             GO TO RETC;
           END;
         PUT SKIP(2) EDIT('***** ERROR - DATE AND TIME SPECIFIED NOT ',
             'IN SMF FILE OR RMF INACTIVE - EOF ON SYSUT1') ((2)A);
         CALL PLIRETC(8);
         GO TO RETC;
       END;
  END;

1/*********************************************************************/
 /*                                                                   */
 /*     START PROCESSING: PERFORM PRIMING READ ON SMF FILE            */
 /*                                                                   */
 /*********************************************************************/
  /* NEED PRIMING READ FOR 1ST INTERVAL SET */
  READ   FILE(SYSUT1)   SET(REC_PTR);
  REC_READ = 1;
  SYSID = SMFXXSID;

  /* GET DATE FROM ROUTINE WEEKDAY - FUNCTION TYPE 3 (USE SYSTEM DATE*/
  CALL WEEKDAY(WEEKDAY_TYPE,JUL,GREG,WEEK_DAY);

  /* PUT FIRST HEADING LINE */
  PUT EDIT('RMFRPT    LEVEL 2 ','SYSTEM ID: ',SYSID,
            SUBSTR(TIME,1,2),':',SUBSTR(TIME,3,2),WEEK_DAY,
            SUBSTR(GREG,3,2),'/',SUBSTR(GREG,5,2),'/',JUL)
        (A,X(25),(2)A,X(35),P'99',A,P'99',X(4),A,X(1),(4)A,P'99.999');
  PUT SKIP;

 /*********************************************************************/
 /*                                                                   */
 /*     MAJOR SMF READ LOOP - IF VALID RECORD, CALLS "CALLREC"        */
 /*                                                                   */
 /*********************************************************************/
  LOOP:    /* MAJOR PROGRAM LOOP, FOR EACH SET OF INTERVALS */

  IF PASS = 1 THEN  PUT PAGE;   /* START NEW PAGE FOR OUTPUT */
              ELSE  PASS = 1;

  /*  CALL ROUTINE TO PROCESS INPUT CARDS - UNLESS "99999" DATE SPEC */
  IF DATE_WAS_99999 = 0   THEN  CALL INPUT;
  ELSE DO;
         /*INCREMENT DATE FOR SEARCH - BUT CHECK FOR NEW YEAR (>365)*/
         DAYS = MOD(DATEX,1000);
         YEAR = TRUNC(DATEX/1000);
         /* CHECK FOR 365 DAYS OR A LEAP YEAR */
         IF DAYS < 365 × ( DAYS=365 & MOD(YEAR,4)=0 ) THEN
               DATEX = DATEX + 1;
         ELSE  DATEX = (YEAR+1)*1000 + 1;  /* SET FOR 1/1 OF NEXT YEAR*/
       END;

  /* INITIALIZE PROPER VARIABLES PRIOR TO EACH INTERVAL SET */

  INT_1ST_READ_FLAG = 0;
  TIME_NOW      = 0;
  INTERVAL      = 0;
  FLAG2, FLAG3  = 0;
  RESULTS       = -.001;  /* INIT TO SHOW DATA NOT COLLECTED */
  DEV_RESULTS   = -.001;  /* INIT TO SHOW DATA NOT COLLECTED */
  GRP_RESULTS   = -.001;  /* INIT TO SHOW DATA NOT COLLECTED */
  RESULTS_PG    = 0E0;
  TIME_INT_SECONDS = 0E0;
  D73_PHYS_TYPE     = '00000000'B;
                 /*    0123456789012345  */
  D73_LOG_CPU_BITS  = '0000000000000000'B;
  D73_LOG_CHAN_BITS = '0000000000000000'B;

  /* LOOP READING SMF RECORDS SEARCHING FOR RMF RECORDS */

  DO REC_READ = REC_READ BY 1;
   /* IS THIS AN RMF RECORD ? */
   IF RMFHIT(SMFXXRTY) > 0 THEN
    DO;  /* CHECK THIS DATA ONCE PER INTERVAL SET */
      IF INT_1ST_READ_FLAG = 0 THEN
        DO;
         INT_1ST_READ_FLAG = 1;
         /* IF DATE IS 0 USE PRESENT DATE */
         IF DATEX = 0 THEN  DATEX = SMFXXDTE;
         /* IF DATE IS "99999" SET DATE AND FLAG */
         IF DATEX = 99999 THEN
           DO;
             DATEX = SMFXXDTE;
             DATE_WAS_99999 = 1;
           END;
         /* ASSURE DATE IS NOT EARLIER THAN SMF FILE */
         IF DATEX < SMFXXDTE THEN
           DO;
             PUT EDIT('***** ERROR - DATE SPECIFIED IS "PREVIOUS" TO',
                 ' DATES IN SMF FILE- CARD SKIPPED') (SKIP(2),(2)A);
             /* SET TO INDICATE TO "INPUT" TO LOOK FOR NEXT DATE*/
             READ_NEXT_DATE_FLAG = 1;
             GO TO ALLDONE;
           END;
        END;
      /* CHECK IF THIS IS DATE OF INTEREST */
      IF SMFXXDAT = DATEX  THEN
        DO;
          /*IF REC_READ <= NN THEN     /* DEBUG */
          /*PUT EDIT(SMFXXDTE,SMFXXDAT,SMFXXIST) (X(6),(3)F(9))   */
          RMFTYPE = RMFHIT(SMFXXRTY);
          /* ASSURE RMF II RECORD TYPE */
          IF SMFXXMFV ^= '03' THEN
            DO;
              PUT EDIT('***** RMF RECORD NOT RMFII TYPE - ABORT *****')
                     (SKIP,A);
              CALL PLIRETC(12);
              GO TO RETC;
            END;
          /* CHECK TO SEE IF RUN COMPLETED */
          IF SMFXXIST >  TIME_END   THEN GO TO ALLDONE;
          /* IS THIS INTERVAL WITHIN TIME LIMITS SPECIFIED ? */
          IF SMFXXIST >= TIME_BEGIN THEN
            DO;            /* THIS RMF RECORD IS NEEDED */
              /* PUT EDIT(SMFXXIST,TIME_BEGIN) ((2)F(10))  /* DEBUG */
              CALL CALLREC;
              IF FLAG2 = 1 THEN GO TO ALLDONE; /*MAX INTERVALS DONE*/
              RMF_STOPPED_FLAG = 1; /* INDICATE TIME FRAME IN PROGRESS*/
            END;
        END;
      ELSE IF RMF_STOPPED_FLAG = 1 THEN /* DATE CHANGED BUT STILL
        PROCESSING INTERVALS - RMF MUST HAVE STOPPED */
        DO;
          PUT EDIT('***** WARNING - RMF PROCESSING STOPPED PRIOR TO',
              ' LAST INTERVAL SPECIFIED *****') (SKIP(2),(2)A);
          /* SET FLAG TO INDICATE TO PROC INPUT TO LOOK FOR NEXT DATE*/
          READ_NEXT_DATE_FLAG = 1;
          GO TO ALLDONE;
        END;
    END;

   /* READ NEXT RECORD */
   READ FILE(SYSUT1) SET(REC_PTR);

  END;

1/*********************************************************************/
 /*                                                                   */
 /*     ALL INTERVALS DONE - CALL ROUTINES TO GENERATE REPORT         */
 /*                                                                   */
 /*********************************************************************/

  ALLDONE: ;  /* CAN ONLY GET TO THIS POINT VIA "GOTO" */

  RMF_STOPPED_FLAG = 0; /* RESET - TURN OFF PROC IN PROGRESS FLAG*/

  IF (INTERVAL > 0) THEN
    DO;
      /* CALL ROUTINE TO CALC AVGS FOR LAST INTERVAL */
      CALL EOINTVL;
      /* GET AVERAGE FOR ALL INTERVALS */
      CALL AVERAGE;
      /* PRINT IO CONFIGURATION INFO. IF NOT REQ. TO BE SUPPRESSED*/
      IF SUPPRESS_CONFIG = 0 THEN
      CALL IOCONFG;
      /* PRINT REPORT */
      CALL REPORT (INT_PER_PAGE,INTERVAL,NO_LINES,DATEX,TIME_BEGIN,
                   TIME_END,TITLE,SYSID,
                   PRNT,RESULTS,DESCRIBE_RESULTS,GRP_RESULTS,
                   DESCRIBE_GRP_RESULTS,DEV_RESULTS,
                   DESCRIBE_DEV_RESULTS,EXCEPT_VOLSER,TIME_INT_START);
    END;
  ELSE
    DO;
      /* ONLY PRINT MSG IF TIME CHANGES - NOT FOR
         EACH RMF RECORD */
      IF SMFXXIST ^= OLD_SMFXXIST THEN
        PUT EDIT('***** ERROR - NO INTERVALS FOUND',
            ' FOR TIME FRAME SPECIFIED -- RMF RECORD',
            ' DATE & TIME = ',SMFXXDAT,SMFXXIST)
            (SKIP(2),(3)A,X(2),P'Z99.999',
                          X(2),P'Z9.99.99');
      OLD_SMFXXIST = SMFXXIST;
      CALL PLIRETC(4);
    END;

  /* IF EOF NOT HIT ON SYSUT1 - SEE IF MORE INTERVALS SETS */
  IF EOFHIT ^= 1 THEN  GO TO LOOP;

  /* END OF RUN - WITH OR W/O ERROR */
  RETC:
    PUT  EDIT('NUMBER OF SMF RECORDS READ = ',REC_READ)
             (PAGE,A,F(8));
    CLOSE FILE(SYSPRINT);
    RETURN;

1/*********************************************************************/
 /*                                                                   */
 /*     CALLREC: DRIVER THAT DIRECTS PROCESSING TO "REC7X" PROCS.     */
 /*              THE RESULTS ARRAYS ARE FILLED IN.                    */
 /*                                                                   */
 /*********************************************************************/
 (SUBRG):CALLREC: PROC ; /* FIRST CHECKS FOR VALID INTERVAL - THEN
                    CALLS THE PROPER RECORD ANALYZING PROCEDURE */

  DCL (NUM_PD,NUM_PG) FIXED BIN(15),
       SEQNO            FIXED BIN(31),
       INT_FLAG         FIXED BIN(15),
       FLAG1            FIXED BIN(15),
       LABEL(70:79)  LABEL INIT(LAB70,LAB71,LAB72,LAB73,LAB74,
                          LAB75,LAB76,LAB77,LAB78,LAB79) AUTOMATIC,
       /* IDENTIFY CALCULATION PROCS AS EXTERNAL */
      (REC70,REC71,REC72,REC73,REC74,REC76)  ENTRY        EXTERNAL,
       REC75  ENTRY(,,,,,,,,,FIXED BIN(15),FIXED BIN(15)) EXTERNAL;

  DCL (D70_CPUWAIT,D70_INREADY,D70_TOTIN,D70_OUTREADY,D70_TOTTSO,
       D70_TOTBATCH,D70_TOTSTC,D70_OUTWAIT)                FLOAT DEC(6);

  DCL (D71_TOTPG,D71_SWAPPG,D71_VIOPG,D71_DMNDPG,D71_TOTAL_SWAP,
       D71_TI_SWAP,D71_TO_SWAP,D71_LW_SWAP,D71_DW_SWAP,
       D71_UNI_SWAP,D71_XCHG_SWAP,D71_ENQ_SWAP,
       D71_REQ_SWAP,D71_ASS_SWAP,D71_RSS_SWAP,
       D71_COMPG,D71_AFCMIN,D71_AFCMAX,D71_AFCAVG,
       D71_VIOSLOTS,D71_LPACSA_FRAMES)                     FLOAT DEC(6);

     /* DIMEN AS @MAX_PG */
  DCL (D72_SU_RATE,D72_NO_TRANS,D72_RESPONSE,D72_SWAPS_TRANS)
                            (@MAX_PG)                      FLOAT DEC(6);

     /* DIMEN TO HANDLE '@MAX_LOGCHAN' LOGICAL CHANNELS */
  DCL (D73_LOG_SIO,D73_LOG_QUE,D73_LOG_PARTBSY,D73_LOG_PHYSBSY,
       D73_LOG_DEF,D73_LOG_DPHYS,D73_LOG_DLOG)  (0:@MAX_LOGCHAN1)
                                                           FLOAT DEC(6);

     /* DIMEN TO HANDLE '@MAX_PHYSCHAN' PHYSICAL CHANNELS .
        ALLOW FOR MP - GIVE SECOND DIMENSION           */
  DCL (D73_PHYS_SIO,D73_PHYS_AVGMS,D73_PHYS_BSY,
       D73_PHYS_CPUW)   (0:@MAX_PHYSCHAN1,0:1)             FLOAT DEC(6);

     /* FOLLOWING DIMEN. ACCORDING TO '@MAX_DEV_REQ' */
  DCL (D74_ACTIVITY,D74_QLNGTH,D74_PCTBSY,D74_PCTCUDELAY,
       D74_PCTRESV,D74_PCTDRESV,D74_AVGDSOPEN,D74_PCTREQBSY,
       D74_PCTREQPATHBSY,D74_AVGQMS,D74_AVGDEVMS,D74_TOTMS)
              (@MAX_DEV_REQ)                               FLOAT DEC(6);

     /* FOLLOWING DIMEN. ACCORDING TO '@MAX_SWAP' AND '@MAX_LOCAL' */
  DCL (D75_BUSY,D75_QUE,D75_AVG_SLOTS)
              (@MAX_PAGEDS)                                FLOAT DEC(6),
       /* INDICATE PLPA,COM,SWAP,& LOCAL INFO. DESIRED */
       D75_BYTE  BIT(8) ALIGNED INIT('11011000'B);
0  /* NEW INTERVAL - SAVE TIME + ASSURE VALID */
   /*PUT EDIT('R',SMFXXIST,TIME_NOW) (A,(2)F(10))  /* FOR DEBUG */
   IF TIME_NOW ^= SMFXXIST THEN
      DO;
        FLAG1 = 0;              /* RESET FLAG1 */
        TIME_NOW = SMFXXIST;    /* RESET TIME  */

        /* CHECK TO ASSURE MINIMUM SAMPLES - OTHERWISE SKIP */
        IF SMFXXSAM < C_MIN_SAMPLES THEN     /*    THIS INTERVAL */
           DO;
             PUT EDIT('INTERVAL SKIPPED AT ',SMFXXIST,' SINCE ONLY ',
                 SMFXXSAM,' SAMPLES') (SKIP,A,P'Z9.99.99',A,F(3),A);
             FLAG1 = 1;  /* SO THAT FUTURE CALLS WILL BE IGNORED*/
             RETURN;
           END;

        /* MAXIMUM OF @NUM_INTM INTERVALS PER REPORT */
        IF INTERVAL = (HBOUND(RESULTS,2) - 1) THEN
           DO;
             PUT SKIP EDIT('MORE THAN @NUM_INTM INTERVALS FOUND ',
                 'DURING TIME PERIOD SPECIFIED - REST IGNORED') ((2)A);
             FLAG2 = 1;   /* INDICATE TO SKIP THIS INTERVAL */
             RETURN;
           END;

        /* CALL ROUTINE TO CALCULATE AVERAGES AT END OF INTERVAL */
        IF INTERVAL ^= 0 THEN   /* NOTE: ON FIRST CALL INTERVAL=0 */
           CALL EOINTVL;

        /* RESET INTERVAL NUMBER TO NEW INTERVAL */
        INTERVAL = INTERVAL + 1;

        PUT SKIP EDIT('INTERVAL',INTERVAL,' NOW BEING PROCESSED',
            ' WITH START TIME OF ',SMFXXIST,'# SAMPLES=',SMFXXSAM,
            'DURATION=',SMFXXINT)
            (A,F(3),(2)A,P'Z9.99.99',X(5),A,F(6),X(5),A,P'99.99.999');

        TIME_INT_START(INTERVAL) = SMFXXIST; /* SAVE            */
        NUM_SAMPLES   (INTERVAL) = SMFXXSAM; /* PERTINENT       */
        DURATION      (INTERVAL) = SMFXXINT; /* INTERVAL INFO   */

        /* SAVE LENGTH OF INTERVAL IN SECONDS */
        TIME_INT_SECONDS(INTERVAL) =
                     TRUNC(SMFXXINT/1.0E5) * 60.E0
                     + MOD(SMFXXINT,1.0E5) / 1.0E3;

        /* INDICATE START OF NEW INTERVAL FOR REC75 */
        INT_FLAG = 0;

      END;

   /* IF FLAG1 IS 1, RETURN - DO NOT PROCESS THIS INTERVAL */
   IF FLAG1 = 1 THEN RETURN;

   /* RESET RECORD POINTER TO RMF_COMMON SECTION - 18 BYTES IN */
   RMF_PTR = ADDR (RMF_COMMON);

   /* CALL PROPER ROUTINE TO ANALYZE RECORD TYPE */
   GO TO LABEL (RMFTYPE) ;
-/*********************************************************************/
 /*                                                                   */
 /*                        SMF RECORD TYPE 70                         */
 /*                                                                   */
 /*********************************************************************/
   LAB70:  /* FIRST CALL REC70 TO COMPUT DATA - PASS LOC OF RECORD */
      CALL REC70 (RMF_PTR,D70_CPUWAIT,D70_INREADY,D70_TOTIN,
                  D70_OUTREADY,D70_TOTTSO,D70_TOTBATCH,
                  D70_TOTSTC,D70_OUTWAIT);
      /* MOVE DATA INTO RESULTS ARRAY - STARTING AT POS P1 */
      RESULTS ( P1   ,INTERVAL) = 100.E0 - D70_CPUWAIT;
      RESULTS ( P1+1 ,INTERVAL) = D70_INREADY;
      RESULTS ( P1+2 ,INTERVAL) = D70_TOTIN;
      RESULTS ( P1+3 ,INTERVAL) = D70_OUTREADY;
      RESULTS ( P1+4 ,INTERVAL) = D70_TOTTSO;
      RESULTS ( P1+5 ,INTERVAL) = D70_TOTBATCH;
      RESULTS ( P1+6 ,INTERVAL) = D70_TOTSTC;
      RESULTS ( P1+7 ,INTERVAL) = D70_OUTWAIT;
      RETURN;    /* RETURN - RECORD ANALYZED AND DATA SAVED */
-/*********************************************************************/
 /*                                                                   */
 /*                        SMF RECORD TYPE 71                         */
 /*                                                                   */
 /*********************************************************************/
   LAB71:  /* FIRST CALL REC71 TO COMPUT DATA - PASS LOC OF RECORD */
      CALL REC71 (RMF_PTR,D71_TOTPG,D71_SWAPPG,D71_VIOPG,D71_DMNDPG,
                  D71_TOTAL_SWAP,D71_TI_SWAP,D71_TO_SWAP,D71_LW_SWAP,
                  D71_DW_SWAP,D71_UNI_SWAP,D71_XCHG_SWAP,D71_ENQ_SWAP,
                  D71_REQ_SWAP,D71_ASS_SWAP,D71_RSS_SWAP,
                  D71_COMPG,D71_AFCMIN,D71_AFCMAX,D71_AFCAVG,
                  D71_VIOSLOTS,D71_LPACSA_FRAMES);
      /* MOVE DATA INTO RESULTS ARRAY - POSITIONS 10-24) */
      RESULTS ( P2   ,INTERVAL) = D71_TOTPG;
      RESULTS ( P2+1 ,INTERVAL) = D71_SWAPPG;
      RESULTS ( P2+2 ,INTERVAL) = D71_VIOPG;
      RESULTS ( P2+3 ,INTERVAL) = D71_DMNDPG;
      RESULTS ( P2+4 ,INTERVAL) = D71_COMPG;
      RESULTS ( P2+5 ,INTERVAL) = D71_TOTAL_SWAP;
      RESULTS ( P2+6 ,INTERVAL) = D71_TI_SWAP;
      RESULTS ( P2+7 ,INTERVAL) = D71_TO_SWAP;
      RESULTS ( P2+8 ,INTERVAL) = D71_LW_SWAP;
      RESULTS ( P2+9 ,INTERVAL) = D71_DW_SWAP;
      RESULTS ( P2+10,INTERVAL) = D71_UNI_SWAP;
      RESULTS ( P2+11,INTERVAL) = D71_XCHG_SWAP;
      RESULTS ( P2+12,INTERVAL) = D71_ENQ_SWAP;
      RESULTS ( P2+13,INTERVAL) = D71_REQ_SWAP;
      RESULTS ( P2+14,INTERVAL) = D71_ASS_SWAP;
      RESULTS ( P2+15,INTERVAL) = D71_RSS_SWAP;
      RESULTS ( P2+16,INTERVAL) = D71_AFCMIN;
      RESULTS ( P2+17,INTERVAL) = D71_AFCMAX;
      RESULTS ( P2+18,INTERVAL) = D71_AFCAVG;
      RESULTS ( P2+19,INTERVAL) = D71_VIOSLOTS;
      RESULTS ( P2+20,INTERVAL) = D71_LPACSA_FRAMES;
      RETURN;    /* RETURN - RECORD ANALYZED AND DATA SAVED */
-/*********************************************************************/
 /*                                                                   */
 /*                        SMF RECORD TYPE 72                         */
 /*                      PERFORMANCE GROUP DATA                       */
 /*                                                                   */
 /*********************************************************************/
   LAB72:  /* FIRST CALL REC72 TO COMPUT DATA - PASS LOC OF RECORD */
      D72_SU_RATE, D72_NO_TRANS, D72_RESPONSE, D72_SWAPS_TRANS = 0E0;
      CALL REC72 (RMF_PTR,NUM_PG,NUM_PD,D72_SU_RATE,
                  D72_NO_TRANS,D72_RESPONSE,D72_SWAPS_TRANS);
      IF NUM_PG > @MAX_PG THEN
         DO;
           PUT SKIP EDIT('WARNING - PROGRAM CAN ONLY HANDLE',@MAX_PG,
               ' PERFORMANCE GROUPS - OTHERS ARE IGNORED')
                (A,F(3),A);
           RETURN;
         END;
      /* MOVE DATA INTO RESULTS ARRAY */
      DO J = 1 TO NUM_PD;
        RESULTS_PG (NUM_PG,J,4,INTERVAL) = D72_SU_RATE(J);
         /* CONVERT TRANSACTIONS TO TRANS/RATE */
        RESULTS_PG (NUM_PG,J,2,INTERVAL) = D72_NO_TRANS(J)
                                / TIME_INT_SECONDS(INTERVAL);
        RESULTS_PG (NUM_PG,J,1,INTERVAL) = D72_RESPONSE(J);
        RESULTS_PG (NUM_PG,J,3,INTERVAL) = D72_SWAPS_TRANS(J);
      END;
      RETURN;    /* RETURN - RECORD ANALYZED AND DATA SAVED */
-/*********************************************************************/
 /*                                                                   */
 /*                        SMF RECORD TYPE 73                         */
 /*                           CHANNEL DATA                            */
 /*                                                                   */
 /*********************************************************************/
   LAB73:  /* FIRST CALL REC73 TO COMPUT DATA - PASS LOC OF RECORD */
      CALL REC73 (RMF_PTR,D73_LOG_SIO,D73_LOG_QUE,D73_LOG_PARTBSY,
              D73_LOG_PHYSBSY,D73_LOG_DEF,D73_LOG_DPHYS,D73_LOG_DLOG,
              D73_PHYS_SIO,D73_PHYS_AVGMS,D73_PHYS_BSY,
              D73_PHYS_CPUW,D73_LOG_CPU_BITS,D73_LOG_CHAN_BITS,
              D73_PHYS_TYPE);

      /* MOVE DATA INTO RESULTS ARRAY */
      DO J = 0 TO HBOUND(D73_LOG_SIO,1);
        IF  D73_LOG_SIO(J) > 0  THEN
          DO;
            GRP_RESULTS ( G1,J,INTERVAL) = D73_LOG_SIO(J);
            D73_LOG_SIO(J)               = 0;
            GRP_RESULTS ( G2,J,INTERVAL) = D73_LOG_QUE(J);
            GRP_RESULTS ( G3,J,INTERVAL) = D73_LOG_PHYSBSY(J);
            GRP_RESULTS ( G4,J,INTERVAL) = D73_LOG_PARTBSY(J);
            GRP_RESULTS ( G13,J,INTERVAL) = D73_LOG_DEF(J);
            GRP_RESULTS ( G14,J,INTERVAL) = D73_LOG_DPHYS(J);
            GRP_RESULTS ( G15,J,INTERVAL) = D73_LOG_DLOG(J);
          END;
      END;
      DO J = 0 TO HBOUND(D73_PHYS_SIO,1);
        IF D73_PHYS_SIO(J,0) > 0
           & ^(D73_PHYS_TYPE(J,0) & '00000010'B) THEN
          DO;   /* VALID DATA FOR CPU 0 CHANNELS */
            GRP_RESULTS ( G16,J,INTERVAL) = D73_PHYS_SIO(J,0);
            D73_PHYS_SIO(J,0)             = 0;
            IF (D73_PHYS_TYPE(J,0) & '00010000'B) THEN LEAVE;
            GRP_RESULTS ( G17,J,INTERVAL) = D73_PHYS_AVGMS(J,0);
            GRP_RESULTS ( G18,J,INTERVAL) = D73_PHYS_BSY(J,0);
            GRP_RESULTS ( G19,J,INTERVAL) = D73_PHYS_CPUW(J,0);
          END;
        IF  D73_PHYS_SIO(J,1) > 0
            & ^(D73_PHYS_TYPE(J,1) & '00000010'B) THEN
          DO;   /* VALID DATA FOR CPU 1 CHANNELS */
            GRP_RESULTS ( G20,J,INTERVAL) = D73_PHYS_SIO(J,1);
            D73_PHYS_SIO(J,1)             = 0;
            IF (D73_PHYS_TYPE(J,1) & '00010000'B) THEN LEAVE;
            GRP_RESULTS ( G21,J,INTERVAL) = D73_PHYS_AVGMS(J,1);
            GRP_RESULTS ( G22,J,INTERVAL) = D73_PHYS_BSY(J,1);
            GRP_RESULTS ( G23,J,INTERVAL) = D73_PHYS_CPUW(J,1);
          END;
      END;
      RETURN;    /* RETURN - RECORD ANALYZED AND DATA SAVED */
-/*********************************************************************/
 /*                                                                   */
 /*                        SMF RECORD TYPE 74                         */
 /*                           DEVICE DATA                             */
 /*                                                                   */
 /*********************************************************************/
   LAB74:  /* FIRST CALL REC74 TO COMPUT DATA - PASS LOC OF RECORD */
      CALL REC74 (RMF_PTR,
                  D74_DEV_TYPE,D74_VOLSER,D74_ADDR,D74_TYPE,
                  D74_ACTIVITY,D74_QLNGTH,D74_PCTBSY,D74_PCTCUDELAY,
                  D74_PCTRESV,D74_PCTDRESV,D74_AVGDSOPEN,
                  D74_PCTREQBSY,D74_PCTREQPATHBSY,D74_AVGQMS,
                  D74_AVGDEVMS,D74_TOTMS,D74_COND,
                  D74_VOLSER_TAB,D74_ADDR_TAB,D74_NUMDEVICES);

      DO I = 1 TO NO_LINES;
         IF PRNT(I).DEVPTR > 0 THEN DO;
            J = PRNT(I).DEVPTR;
            PRNT(I).VOLSER   = D74_VOLSER(J);
            PRNT(I).ADDR     = D74_ADDR(J);
            EXCEPT_VOLSER(J,INTERVAL) = D74_VOLSER(J);
            IF      D74_COND(J) = 2 THEN DO;
              PRNT(I).VOLSER = '*VARY*';
              DEV_RESULTS(J,INTERVAL) = -.001 ;
            END;
            ELSE IF D74_COND(J) = 3 THEN DO;
              PRNT(I).VOLSER = '*NOTF*';
              PRNT(I).ADDR   = '***';
              DEV_RESULTS(J,INTERVAL) = -.001 ;
            END;
            ELSE IF D74_COND(J) = 4 THEN DO;
              PRNT(I).VOLSER = '*BADT*';
              PRNT(I).ADDR   = '***';
              DEV_RESULTS(J,INTERVAL) = -.001 ;
            END;
            ELSE DO;
               SELECT (PRNT(I).PARM);
                 WHEN (@FIRST_DEV     ) DEV_RESULTS(J,INTERVAL) =
                      D74_ACTIVITY(J);
                 WHEN (@FIRST_DEV +  1) DEV_RESULTS(J,INTERVAL) =
                      D74_QLNGTH(J);
                 WHEN (@FIRST_DEV +  2) DEV_RESULTS(J,INTERVAL) =
                      D74_PCTBSY(J);
                 WHEN (@FIRST_DEV +  3) DEV_RESULTS(J,INTERVAL) =
                      D74_PCTCUDELAY(J);
                 WHEN (@FIRST_DEV +  4) DEV_RESULTS(J,INTERVAL) =
                      D74_PCTRESV(J);
                 WHEN (@FIRST_DEV +  5) DEV_RESULTS(J,INTERVAL) =
                      D74_PCTDRESV(J);
                 WHEN (@FIRST_DEV +  6) DEV_RESULTS(J,INTERVAL) =
                      D74_AVGDSOPEN(J);
                 WHEN (@FIRST_DEV +  7) DEV_RESULTS(J,INTERVAL) =
                      D74_PCTREQBSY(J);
                 WHEN (@FIRST_DEV +  8) DEV_RESULTS(J,INTERVAL) =
                      D74_PCTREQPATHBSY(J);
                 WHEN (@FIRST_DEV +  9) DEV_RESULTS(J,INTERVAL) =
                      D74_AVGQMS(J);
                 WHEN (@FIRST_DEV + 10) DEV_RESULTS(J,INTERVAL) =
                      D74_AVGDEVMS(J);
                 WHEN (@FIRST_DEV + 11) DEV_RESULTS(J,INTERVAL) =
                      D74_TOTMS(J);
               END;
            END;
         END;
      END;

      RETURN;    /* RETURN - RECORD ANALYZED AND DATA SAVED */
-/*********************************************************************/
 /*                                                                   */
 /*                        SMF RECORD TYPE 75                         */
 /*                       PAGING DATASET DATA                         */
 /*                                                                   */
 /*********************************************************************/
   LAB75:  /* FIRST CALL REC75 TO COMPUT DATA - PASS LOC OF RECORD */
      CALL REC75 (RMF_PTR,
                  D75_QUE,D75_BUSY,D75_DSN,D75_ADDR,D75_VOLSER,
                  D75_AVG_SLOTS,INT_FLAG,D75_BYTE,@MAX_SWAP,@MAX_LOCAL);
      /* ALL ARRAYS ARE DIMEN WITH FOLLOWING ORDER IN MIND:
         PLPA, COMMON, DUPLEX, '@MAX_SWAP' SWAPS, '@MAX_LOCAL' LOCALS */
      /* MOVE DATA INTO RESULTS ARRAY */
      DO J = 1 TO 3;
         RESULTS ( (P7+(J-1)*2) , INTERVAL ) = D75_BUSY(J);
         RESULTS ( (P8+(J-1)*2) , INTERVAL ) = D75_AVG_SLOTS(J);
      END;
      DO J = 1 TO @MAX_SWAP;
         GRP_RESULTS (G5,J,INTERVAL) = D75_BUSY(J + 3);
         GRP_RESULTS (G6,J,INTERVAL) = D75_AVG_SLOTS(J + 3);
      END;
      DO J = 1 TO @MAX_LOCAL;
         GRP_RESULTS (G7, J,INTERVAL) = D75_BUSY(J + 3 + @MAX_SWAP);
         GRP_RESULTS (G8,J,INTERVAL) = D75_AVG_SLOTS(J + 3 +@MAX_SWAP);
      END;
      RETURN;    /* RETURN - RECORD ANALYZED AND DATA SAVED */
-/*********************************************************************/
 /*                                                                   */
 /*                        SMF RECORD TYPE 76                         */
 /*                            TRACE DATA                             */
 /*                                                                   */
 /*********************************************************************/
   LAB76:  /* FIRST CALL REC76 TO COMPUT DATA - PASS LOC OF RECORD */
      CALL REC76 (RMF_PTR,D76_TRACE,D76_LIST,SEQNO);
      /* MOVE DATA INTO RESULTS ARRAY UNLESS SEQNO IS 0 - MEANS
         NO MATCH FOUND WITH LIST ARRAY */
      IF SEQNO > 0 THEN DO;
        IF SEQNO <= @SNG_TRACE THEN
          RESULTS ((P9+SEQNO-1),INTERVAL) = D76_TRACE;
        ELSE DO;
   GLOOP:  DO J = 0 TO @NUM_DOM_PARMS - 1;
              I = @SNG_TRACE + J * @MAX_DOM;
              K = I + @MAX_DOM + 1;
              IF SEQNO > I & SEQNO < K THEN DO;
                 L = SEQNO - I - 1; /* -1 SINCE DOM START AT 0 */
                 GRP_RESULTS(G9 + J,L,INTERVAL) = D76_TRACE;
                 LEAVE GLOOP;
              END;
           END;
        END;
      END;
      RETURN;    /* RETURN - RECORD ANALYZED AND DATA SAVED */
-/*********************************************************************/
 /*                                                                   */
 /*                  SMF RECORD TYPES 77,78 AND 79                    */
 /*                  NO PROCESSING DONE AT PRESENT                    */
 /*                                                                   */
 /*********************************************************************/
   LAB77: ;
   LAB78: ;
   LAB79: ;
   RETURN;
-END CALLREC;
1/*********************************************************************/
 /*                                                                   */
 /*     IOCONFIG: LISTS PAGE VOLS, ONLINE VOLS, AND CHANNELS          */
 /*               PRIOR TO EACH SET OF INTERVALS - OPTIONAL           */
 /*                                                                   */
 /*********************************************************************/
 (SUBRG):IOCONFG: PROC ; /* NOTE: NOT CALLED IF COL 2 OF "9" CARD
                                               CONTAINS A "1"  */
   DCL  TEMPA       CHAR(3),
        TEMPD       CHAR(1),
        TEMPV       CHAR(6),
        DTAB(0:15)  CHAR(1)  INIT('0','1','2','3','4','5','6','7',
                                  '8','9','A','B','C','D','E','F' ),
        D75_TYPE(3)  CHAR(7) INIT('PLPA','COMMON','DUPLEX'),
        CHAN_TYPE(3) CHAR(9) INIT('SELECTOR','BYTE MPX','BLOCK MPX'),
        CHAN_STATUS(3) CHAR(7) INIT('ONLINE','OFFLINE','VARIED');

        PUT EDIT ('IO CONFIGURATION INFORMATION') (PAGE,A);

        PUT EDIT ('PAGE DATASET INFORMATION:') (SKIP(2),A);
        PUT EDIT ('TYPE    DSNAME','ADDR VOLSER')
            (SKIP(2),A,X(38),A);
        PUT EDIT ('------  ',('-' DO I = 1 TO 43),' ---- ------')
            (SKIP,(45)A);
        DO J = 1 TO 3;
          IF D75_DSN(J) ^= ' ' THEN
             PUT EDIT
             (D75_TYPE(J),D75_DSN(J),D75_ADDR(J),D75_VOLSER(J))
             (SKIP,(4)(A,X(1)));
        END;
        DO J = 4 TO 3 + @MAX_SWAP;
          IF D75_DSN(J) ^= ' ' THEN
             PUT EDIT
             ('SWAP',J-3,D75_DSN(J),D75_ADDR(J),D75_VOLSER(J))
             (SKIP,A(4),F(2),X(2),(3)(A,X(1)));
        END;
        DO J = 4 + @MAX_SWAP TO @MAX_PAGEDS;
          IF D75_DSN(J) ^= ' ' THEN
             PUT EDIT ('LOCAL',J - (3 + @MAX_SWAP),
                 D75_DSN(J),D75_ADDR(J),D75_VOLSER(J))
             (SKIP,A(5),F(2),X(1),(3)(A,X(1)));
        END;

0       /* VOLUME CONFIGURATION */
        PUT SKIP(4) EDIT('VOLUME CONFIGURATION:') (A);
        PUT SKIP(2) EDIT(('ADDR VOLSER   ' DO J = 1 TO 8)) ((8)(A));
        PUT SKIP    EDIT(('---- ------   ' DO J = 1 TO 8)) ((8)(A));
        TEMPA = '   ';
        TEMPV = ' ';
        DO J = 1 TO D74_NUMDEVICES;
           TEMPD = SUBSTR(D74_ADDR_TAB(J),3,1);
           IF TEMPD >= '0' & TEMPD <= '7' THEN DO;
              IF SUBSTR(TEMPA,1,2) ^= SUBSTR(D74_ADDR_TAB(J),1,2)
                 THEN DO;
                 TEMPV = 'LOW';
                 TEMPA = D74_ADDR_TAB(J);
                 PUT SKIP;
                 DO I = 0 TO 7;
                    IF TEMPD > DTAB(I) THEN PUT EDIT(' ') (A(14));
                 END;
              END;
           END;
           ELSE DO;
              IF SUBSTR(TEMPA,1,2) ^= SUBSTR(D74_ADDR_TAB(J),1,2)
                 × TEMPV ^= 'HIGH' THEN DO;
                 TEMPV = 'HIGH';
                 TEMPA = D74_ADDR_TAB(J);
                 PUT SKIP;
                 DO I = 8 TO 15;
                    IF TEMPD = DTAB(I) THEN LEAVE;
                    PUT EDIT(' ') (A(14));
                 END;
              END;
           END;
           PUT EDIT( D74_ADDR_TAB(J),D74_VOLSER_TAB(J) )
               ( A(3),X(2),A(9) );
        END;
0       PUT SKIP(3) EDIT(('VOLSER ADDR   ' DO J = 1 TO 8)) ((8)(A));
        PUT SKIP(1) EDIT(('------ ----   ' DO J = 1 TO 8)) ((8)(A));
        DO J = 2 TO D74_NUMDEVICES;
           DO I = 1 TO J - 1;
              IF D74_VOLSER_TAB(J) < D74_VOLSER_TAB(I) THEN DO;
                 TEMPV = D74_VOLSER_TAB(J);
                 TEMPA = D74_ADDR_TAB(J);
                 DO K = J TO I + 1 BY -1;
                    D74_VOLSER_TAB(K) = D74_VOLSER_TAB(K - 1);
                    D74_ADDR_TAB(K)   = D74_ADDR_TAB(K - 1);
                 END;
                D74_VOLSER_TAB(I) = TEMPV;
                D74_ADDR_TAB(I)   = TEMPA;
              END;
           END;
        END;
        PUT EDIT( ( D74_VOLSER_TAB(J),D74_ADDR_TAB(J) DO J = 1 TO
            D74_NUMDEVICES ) )
            ( SKIP, (8)( A(6),X(2),A(6) ) );

0       /* PHYSICAL CHANNEL INFO. */
        PUT EDIT('PHYSICAL CHAN  CPU  TYPE        STATUS   LOG',
                 ' CHAN') (SKIP(4),(2)A);
        PUT EDIT('-------------  ---  ---------   -------  ---',
                 '-----') (SKIP,(2)A);
        DO J=0 TO 1;  /* FOR 2 CPUS */
        DO I=0 TO (@MAX_PHYSCHAN-1); /*FOR ALL PHYSICAL CHANS*/
          IF D73_PHYS_TYPE(I,J) ^= '00000000'B THEN
          DO;
            II = 1; /* FIRST ASSUME SELECTOR CHAN */
            IF SUBSTR(D73_PHYS_TYPE(I,J), 3,1) THEN II=3;
            IF SUBSTR(D73_PHYS_TYPE(I,J), 4,1) THEN II=2;
            JJ = 2; /* FIRST ASSUME OFFLINE */
            IF SUBSTR(D73_PHYS_TYPE(I,J), 8,1) THEN JJ=1;
            IF SUBSTR(D73_PHYS_TYPE(I,J), 7,1) THEN JJ=3;
            PUT EDIT(I,J,CHAN_TYPE(II),CHAN_STATUS(JJ))
                    (SKIP,F(4),X(11),F(2),X(3),A,X(3),A,X(3));
            /* SEARCH LOGICAL CHAN BIT MAPS */
            DO L = 0 TO (@MAX_LOGCHAN-1);
              IF SUBSTR(D73_LOG_CPU_BITS(L),(J+1),1) THEN
              /* RIGHT CPU - CHK PHYS CHANS */
              /* CHECK FOR I-TH BIT IN EACH LOG_CHAN_BIT MAP */
              IF SUBSTR(D73_LOG_CHAN_BITS(L),(I+1),1) THEN
              PUT EDIT (L) (X(1),F(2));
            END;
          END;
        END;
        END;
        PUT SKIP(4);
        RETURN;
0END IOCONFG;
1/*********************************************************************/
 /*                                                                   */
 /*     EOINTVL: ROUTINE INVOKED AT END OF EACH INTERVAL              */
 /*              CALCULATES TOTALS, AVERAGES ETC.                     */
 /*                                                                   */
 /*********************************************************************/
 (SUBRG):EOINTVL: PROC ;

        /* THIS PROC CALCULATES AVERAGES AT THE END OF EACH
           INTERVAL */

        /* CALCULATE TOTAL SU RATE FOR EACH PERF. GROUP */
        DO II = 1 TO @MAX_PG;
         DO  J = 1 TO @MAX_PERIOD;   /* PLACE IN RESULTS */
            GRP_RESULTS(G12,II,INTERVAL)
                        = GRP_RESULTS(G12,II,INTERVAL)
                        + RESULTS_PG(II,J,4,INTERVAL);
         END;
        END;

        /* CALC. SYSTEM TOTAL SU_RATE FOR EACH INTERVAL */
        DO II = 1 TO @MAX_PG;
            RESULTS(P11,INTERVAL) = RESULTS(P11,INTERVAL)
                              + GRP_RESULTS(G12,II,INTERVAL);
        END;

        /* MOVE TSO DATA INTO RESULTS ARRAY */
        DO J = 1 TO 3;  /* FOR PERIODS 1,2,3 - SHORT,MEDIUM,& LONG*/
          DO L = 1 TO 4;
             RESULTS( P12+(J-1)*4 + (L-1), INTERVAL)
               = RESULTS_PG (TSO_PG, J, L, INTERVAL);
          END;
        END;

        /* CALCULATE AVERAGES FOR SWAP  PAGE DATASETS */
        M = 0;
        DO J = 1 TO @MAX_SWAP;
           RESULTS (P17,INTERVAL) = RESULTS (P17,INTERVAL)
                   + GRP_RESULTS (G5,J,INTERVAL);
           RESULTS (P18,INTERVAL) = RESULTS (P18,INTERVAL)
                   + GRP_RESULTS (G6,J,INTERVAL);
           IF GRP_RESULTS (G5,J,INTERVAL) > .000001
              THEN M = M + 1;
        END;
        IF M ^= 0 THEN
          DO;
           RESULTS(P17,INTERVAL) = RESULTS (P17,INTERVAL) /M;
           RESULTS(P18,INTERVAL) = RESULTS (P18,INTERVAL) /M;
          END;

        /* CALCULATE AVERAGES FOR LOCAL PAGE DATASETS */
        M = 0;
        DO J = 1 TO @MAX_LOCAL;
           RESULTS (P13,INTERVAL) = RESULTS (P13,INTERVAL)
                   + GRP_RESULTS (G7,J,INTERVAL);
           RESULTS (P14,INTERVAL) = RESULTS (P14,INTERVAL)
                   + GRP_RESULTS (G8,J,INTERVAL);
           IF GRP_RESULTS (G7,J,INTERVAL) > .000001
              THEN M = M + 1;
        END;
        IF M ^= 0 THEN
          DO;
           RESULTS(P13,INTERVAL) = RESULTS (P13,INTERVAL) /M;
           RESULTS(P14,INTERVAL) = RESULTS (P14,INTERVAL) /M;
          END;

        /* CALCULATE TOTALS FOR DOMAIN DATA */
        DO N = 1 TO 3;  /* FOR EACH TYPE OF 3 TYPES DOMAIN DATA */
         DO J = 1 TO @MAX_DOM;
                    RESULTS (P21+N-1,INTERVAL) =
                    RESULTS (P21+N-1,INTERVAL)
                  + GRP_RESULTS (G9 + N - 1, J , INTERVAL);
         END;
        END;

        /* CALCULATE CPU TIME FOR SWAPPING & PAGING USING FORMULAS
           FROM PERFORMANCE NOTEBOOK */
             /* CPU TIME DUE TO SWAPPING */
        RESULTS (P23,INTERVAL) =
           (  51000.E0 *  RESULTS (P2+5,INTERVAL)
            + 2667.E0  *  RESULTS (P2+1,INTERVAL) )
            * (CONST*100.E0/1.E6);
             /* CPU TIME DUE TO PAGING   */
        RESULTS (P24,INTERVAL) =
           (  5000.E0 * (RESULTS (P2+2,INTERVAL)
                       + RESULTS (P2+3,INTERVAL)) )
            * (CONST*100.E0/1.E6);
        RETURN;
0END EOINTVL;
1/*********************************************************************/
 /*                                                                   */
 /*     AVERAGE: CALCULATES AVERAGES FOR "AVERAGE COLUMN"             */
 /*              DONE AT END OF A SET OF INTERVALS(I.E.9 CARD)        */
 /*                                                                   */
 /*********************************************************************/
 (SUBRG):AVERAGE: PROC;

   DCL   SUM_SECONDS  FLOAT DEC(6);

   /* CALCULATE AVERAGES FOR AVERAGE COLUMN (LAST COLUMN) */
   DO JJ = 1 TO HBOUND(RESULTS,1);
     SUM_SECONDS = 0;
     RESULTS(JJ,INTERVAL+1) = 0;
     DO J = 1 TO INTERVAL;
       /* DO NOT INCLUDE NON ACTIVE INTERVALS (I.E. DOMAIN DATA)*/
       IF RESULTS(JJ,J) >= 0 THEN
        DO;
          RESULTS(JJ,INTERVAL+1)  =  RESULTS(JJ,INTERVAL+1)
                      + RESULTS(JJ,J) * TIME_INT_SECONDS(J);
          SUM_SECONDS = SUM_SECONDS + TIME_INT_SECONDS(J);
        END;
     END;
     IF SUM_SECONDS ^= 0 THEN
        RESULTS(JJ,INTERVAL+1) = RESULTS(JJ,INTERVAL+1) / SUM_SECONDS;
     ELSE
        RESULTS(JJ,INTERVAL+1) = -.001; /* BY CONVENTION */
   END;

   DO JJ = @FIRST_GRP TO @LAST_GRP;
     DO II = 0 TO @MAX_GRPS;
     SUM_SECONDS = 0;
     GRP_RESULTS(JJ,II,INTERVAL+1) = 0;
     DO J = 1 TO INTERVAL;
       /* DO NOT INCLUDE NON ACTIVE INTERVALS (I.E. DOMAIN DATA)*/
       IF GRP_RESULTS(JJ,II,J) >= 0 THEN
        DO;
          GRP_RESULTS(JJ,II,INTERVAL+1) = GRP_RESULTS(JJ,II,INTERVAL+1)
                      + GRP_RESULTS(JJ,II,J) * TIME_INT_SECONDS(J);
          SUM_SECONDS = SUM_SECONDS + TIME_INT_SECONDS(J);
        END;
     END;
     IF SUM_SECONDS ^= 0 THEN
        GRP_RESULTS(JJ,II,INTERVAL+1) =
            GRP_RESULTS(JJ,II,INTERVAL+1) / SUM_SECONDS;
     ELSE
        GRP_RESULTS(JJ,II,INTERVAL+1) = -.001; /* BY CONVENTION */
     END;
   END;

   DO II = 1 TO DEV_REQ_PTR;
      SUM_SECONDS = 0;
      DEV_RESULTS(II,INTERVAL+1) = 0;
      DO J = 1 TO INTERVAL;
        /* DO NOT INCLUDE NON ACTIVE INTERVALS (I.E. DOMAIN DATA)*/
        IF DEV_RESULTS(II,J) >= 0 THEN
        DO;
           DEV_RESULTS(II,INTERVAL+1) = DEV_RESULTS(II,INTERVAL+1)
                       + DEV_RESULTS(II,J) * TIME_INT_SECONDS(J);
           SUM_SECONDS = SUM_SECONDS + TIME_INT_SECONDS(J);
         END;
      END;
      IF SUM_SECONDS ^= 0 THEN
         DEV_RESULTS(II,INTERVAL+1) =
             DEV_RESULTS(II,INTERVAL+1) / SUM_SECONDS;
      ELSE
         DEV_RESULTS(II,INTERVAL+1) = -.001; /* BY CONVENTION */
   END;

   /* INCR. INTERVAL AND TREAT AVERAGES AS AN EXTRA INTERVAL */
   INTERVAL = INTERVAL + 1;
   RETURN;
0END AVERAGE;
1/*********************************************************************/
 /*                                                                   */
 /*     INPUT: PROC TO READ ALL INPUT CARDS.                          */
 /*            SETS UP OUTPUT STRUCTURE. RETURN WHEN "9" CARD FOUND   */
 /*                                                                   */
 /*********************************************************************/
 (SUBRG):INPUT:  PROC;

  DCL  CONTROL_CARD     CHAR(80),
       WORK2            CHAR(20),
       OLDDATE          FIXED DEC(7),
       TCONST           FLOAT DEC(6),
      (TC1,TC2,TC3)     FIXED BIN(15),
      TEMPRESULTS       CHAR(12),
      (COLUMN,CTYPE,FMT,OFFSET,CNTL,IPOS) FIXED BIN(15),
      (PARM#,EXCEPT#,GROUP#)              FIXED BIN(15),
      PVOLSER  CHAR(6),   PADDR   CHAR(3),
       LAB (0:9) LABEL INIT(NEXTCARD,LAB1,LAB2,LAB3,LAB4,LAB5,
           LAB6,LAB7,LAB8,LAB9) AUTOMATIC;
  /* IF EOF HIT ON SYSIN, SEE IF ERROR */
  ON ENDFILE (SYSIN) BEGIN;
     IF FLAG3 = 1 THEN    /* ERROR IN INPUT CARDS */
       DO;
         PUT SKIP EDIT('ERROR - DATA CARDS MISSING ON SYSIN ',
             'RUN ABORTED') ((2)A);
         CLOSE FILE(SYSUT1), FILE(SYSIN);
         CALL PLIRETC(8);
         GO TO RETC;
       END;
     ELSE
       DO;
         CLOSE FILE(SYSUT1), FILE(SYSIN);
         GO TO RETC;
       END;
  END;

  /* CK IF "INPUT" IS REQUESTED TO SEARCH FOR A "9" CARD WITH A NEW
     DATE - IF SO, SAVE OLD DATE */
  IF READ_NEXT_DATE_FLAG = 1 THEN
     OLDDATE = DATEX;

  NEXTCARD:
   /* READ CONTROL CARDS     */
   READ FILE(SYSIN) INTO (CONTROL_CARD);
   PUT  SKIP EDIT('CONTROL CARD:',CONTROL_CARD) ((2)A);
   /* GET CARD TYPE TO BRANCH TO PROPER ANALYSIS CODE */
   GET  STRING(CONTROL_CARD)
              EDIT (CTYPE)    (F(1));
   GO TO LAB (CTYPE);  /* IF 1ST COL IS BLANK GOTO NEXTCARD(COMMENT)*/
-/*********************************************************************/
 /*                                                                   */
 /*                          CONTROL CARD 1                           */
 /*                            TITLE CARD                             */
 /*                                                                   */
 /*********************************************************************/
   LAB1:
     TITLE = SUBSTR (CONTROL_CARD,2,71);
     GO TO NEXTCARD;
-/*********************************************************************/
 /*                                                                   */
 /*                          CONTROL CARD 2                           */
 /*                    OUTPUT FORMAT CONTROL CARD                     */
 /*                                                                   */
 /*********************************************************************/
   LAB2:
     /* SEE IF NEED TO RE-INITIALIZE ARRAYS */
     IF INPUT_FLAG = 0 THEN
       DO;
         NO_LINES = 0;
         INPUT_FLAG = 1;
       END;
     COLUMN = 11;     /* INITIALIZE TO COL 11 - FOR EACH CARD */
     DO  M = 1 TO 3;  /* 3 SETS OF 20 COLUMNS                 */
      WORK2 = SUBSTR (CONTROL_CARD,COLUMN,20);
      COLUMN = COLUMN + 20;
      GET STRING (WORK2) EDIT (PARM#,GROUP#,CNTL,OFFSET,FMT,
          PVOLSER,PADDR)  (F(3),F(2),(3)F(1),X(2),A(6),A(3),X(1));
      IF PARM# > 0 THEN
        DO;
          NO_LINES = NO_LINES + 1;     /* INDICATE ANOTHER PRINT LINE*/
          PRNT(NO_LINES).FMT    = FMT;
          PRNT(NO_LINES).OFFSET = OFFSET;
          PRNT(NO_LINES).CNTL   = CNTL;
          PRNT(NO_LINES).PARM   = PARM#;
          PRNT(NO_LINES).DEVPTR = 0;
          PRNT(NO_LINES).GROUP  = 0;
0         IF PRNT(NO_LINES).PARM >= @FIRST_GRP &
             PRNT(NO_LINES).PARM <= @LAST_GRP  THEN DO;
             PRNT(NO_LINES).GROUP = GROUP#;
          END;
0         ELSE IF PRNT(NO_LINES).PARM >= @FIRST_DEV &
             PRNT(NO_LINES).PARM      <= @LAST_DEV THEN DO;
             PRNT(NO_LINES).VOLSER = PVOLSER;
             PRNT(NO_LINES).ADDR   = PADDR;
             DEV_REQ_PTR = DEV_REQ_PTR + 1;
             PRNT(NO_LINES).DEVPTR     = DEV_REQ_PTR;
             D74_DEV_TYPE(DEV_REQ_PTR) = 0;
             IF      PVOLSER ^= ' ' THEN DO;
                D74_VOLSER(DEV_REQ_PTR)   = PVOLSER;
                D74_ADDR  (DEV_REQ_PTR)   = ' ';
                D74_TYPE  (DEV_REQ_PTR)   = 1;
             END;
             ELSE IF PADDR ^= ' ' THEN DO;
                D74_VOLSER(DEV_REQ_PTR)   = ' ';
                D74_ADDR  (DEV_REQ_PTR)   = PADDR;
                D74_TYPE  (DEV_REQ_PTR)   = 2;
             END;
             ELSE DO;
                D74_VOLSER(DEV_REQ_PTR)   = ' ';
                D74_ADDR  (DEV_REQ_PTR)   = ' ';
                D74_TYPE  (DEV_REQ_PTR)   = -(PARM# - @FIRST_DEV + 1);
                DEV_EXCEPT(PARM#) = DEV_EXCEPT(PARM#) + 1;
                PRNT(NO_LINES).EXCEPT = DEV_EXCEPT(PARM#);
             END;
          END;
          ELSE IF PARM# < 1 × PARM# > @NUM_PARMS THEN DO;
             PUT SKIP EDIT('**** ABOVE CONTROL CARD HAS INVALID',
             ' CONTROL PARAMETER: ',PARM#,' ****') (A,A,F(3),A);
          END;
        END;
     END;
     GO TO NEXTCARD;
-/*********************************************************************/
 /*                                                                   */
 /*                          CONTROL CARD 3                           */
 /*                  FIELD NAME CHANGE CONTROL CARD                   */
 /*                                                                   */
 /*********************************************************************/
   LAB3:
     GET STRING (CONTROL_CARD) EDIT (JJ,II,TEMPRESULTS)
         ( X(7),F(3),F(2),A(12));
     IF       JJ >= @FIRST_DEV & JJ <= @LAST_DEV THEN
         DESCRIBE_DEV_RESULTS(JJ) = TEMPRESULTS;
     ELSE IF  JJ >= @FIRST_GRP & JJ <= @LAST_GRP THEN
         DESCRIBE_GRP_RESULTS(JJ,II) = TEMPRESULTS;
     ELSE IF  JJ >= 1          & JJ <= @NUM_PARMS THEN
         DESCRIBE_RESULTS(JJ) = TEMPRESULTS;
     GO TO NEXTCARD;
-/*********************************************************************/
 /*                                                                   */
 /*                          CONTROL CARD 4                           */
 /*                          CONSTANTS CARD                           */
 /*                                                                   */
 /*********************************************************************/
   LAB4:
     GET STRING (CONTROL_CARD) EDIT (TCONST,
                                     TC1,TC2,TC3)
         ( X(5), (4)F(5) );
     IF TCONST ^= 0.0 THEN  CONST = TCONST;
     IF TC1    ^= 0   THEN  TSO_PG = TC1;
     IF TC2    ^= 0   THEN  C_MIN_SAMPLES = TC2;
     IF TC3    ^= 0   THEN  INT_PER_PAGE  = TC3;
     GO TO NEXTCARD;
-/*********************************************************************/
 /*                                                                   */
 /*                    CONTROL CARDS 5,6,7 AND 8                      */
 /*                    NOT PRESENTLY USED - ERROR                     */
 /*                                                                   */
 /*********************************************************************/
   LAB5: ; LAB6: ; LAB7: ; LAB8: ;
      PUT SKIP EDIT('**** ABOVE CARD IGNORED - UNKNOWN TYPE ****') (A);
      GO TO NEXTCARD;
-/*********************************************************************/
 /*                                                                   */
 /*                          CONTROL CARD 9                           */
 /*                    TIME AND DATE CONTROL CARD                     */
 /*                                                                   */
 /*********************************************************************/
   LAB9:
     GET STRING (CONTROL_CARD) EDIT (SUPPRESS_CONFIG,DATEX,TIME_BEGIN,
         TIME_END)  ( X(1),F(1),X(3),F(5), (2)(X(1),F(4)) );
     TIME_BEGIN = TIME_BEGIN * 100; /* SHIFT 2 DECIMAL DIGITS FOR  */
     TIME_END   = TIME_END   * 100; /* COMPARISION WITH SMF RECORD */
     PUT SKIP;

     /*  SINCE A "9" CARD INITIATES A RUN, SET INPUT_FLAG SO LATER
         "2" CARDS CAN RE-INITIALIZE THE OUTPUT FORMAT */
     INPUT_FLAG = 0;
     /* DEBUG ****
        PUT EDIT ((PRNT_FMT(J),PRNT_OFFSET(J),PRNT_CNTL(J),PRNT_POS(J)
          DO J = 1 TO HBOUND(POS,1)) (SKIP,(10)(X(1),(3)F(1),F(3)))*/
     /*  INPUT ALL READ - NOW RETURN TO PROCESS UNLESS SEARCHING
         FOR A "9" CARD WITH A NEW DATE (I.E. RMF NOT ACTIVE) */
     IF READ_NEXT_DATE_FLAG = 1 THEN
       DO;
         IF DATEX = OLDDATE THEN
           DO;
             PUT EDIT('***** NOTE: ABOVE TIME FRAME SKIPPED - RMF',
                 ' NOT ACTIVE *****') (SKIP,(2)A);
             GO TO NEXTCARD;
           END;
         ELSE
           DO;   /* NEW DATE FOUND */
             READ_NEXT_DATE_FLAG = 0; /*RESET*/
           END;
       END;

     RETURN;

 END INPUT;

 END RMFRPT;
