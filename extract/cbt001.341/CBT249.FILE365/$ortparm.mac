         TITLE '$ORTPARM - MODULE COMMENTARY'
***************************************************************
*                                                             *
*        NAME      .$ORTPARM VERSION 02.27                    *
*                                                             *
*        TITLE     .SYNCSORT PARMEXIT FACILITY EXIT ROUTINE.  *
*                                                             *
*        FUNCTION/ .PROVIDE THE EXIT ROUTINE TO DETERMINE     *
*        PURPOSE    THE PERFORMANCE RELATED OPTIONS TO BE     *
*                   USED BY SYNCSORT DURING DIFFERENT PERIODS *
*                   OF THE DAY BASED ON AN ASSESSMENT OF THE  *
*                   STATE OF THE EXECUTION ENVIRONMENT AT THE *
*                   TIME THE EXIT ROUTINE IS INVOKED.         *
*                                                             *
*        MODULE    .NORENT,NOREUS,NOREFR,AC(0),               *
*        ATTRIBUTES        AMODE(24),RMODE(24).               *
*                                                             *
*                  .THIS EXIT IS CODED REENTRANTLY, BUT IS    *
*                   NOT REENTRANT.  THE REENTRANCY VIOLATION  *
*                   IS THAT THE STORAGE IN WHICH THE PARM     *
*                   FIELD RETURNED TO THE SORT IS BUILT, IS   *
*                   CONTAINED WITHIN THE EXIT.  THE USE OF    *
*                   STORAGE WITHIN THE EXIT TO BUILD THE      *
*                   PARAMETER STRING RETURNED TO SYNCSORT IS  *
*                   A CONVENTION REQUIRED OF THE EXIT BY      *
*                   SYNCSORT.  SYNCSORT USES A "LOAD/BALR     *
*                   14,15/DELETE" LINKAGE TECHNIQUE FOR       *
*                   PASSING CONTROL TO THE EXIT.  THIS        *
*                   TECHNIQUE AVOIDS THE VIRTUAL STORAGE      *
*                   FRAGMENTATION WHICH WOULD OCCUR IF THE    *
*                   PARM STRING WERE BUILT IN A GETMAIN'D     *
*                   AREA FOR WHICH SYNCSORT HAD NO            *
*                   INFORMATION ON HOW TO RELEASE.  IN ALL    *
*                   OTHER RESPECTS, THE EXIT IS REENTRANT.    *
*                                                             *
*        ENTRY     .$ORTPARM                                  *
*                                                             *
*        INPUT     .INPUT TO THE EXIT IS PROVIDED BY THE      *
*                   $ORTDATA MODULE AND BY EXTRACTING         *
*                   VALUES FROM THE EXECUTION ENVIRONMENT     *
*                   AS DESCRIBED IN THE FACILITIES/FEATURES   *
*                   COMMENTARY BELOW.  THE EXIT RECEIVES NO   *
*                   INPUT FROM SYNCSORT.                      *
*                                                             *
*                                                             *
*        OUTPUT    .FOR RETURN CODE 00 IN REGISTER 15,        *
*                   REGISTER 1 POINTS TO A FULLWORD WHICH     *
*                   POINTS TO A HALFWORD LENGTH VALUE         *
*                   FOLLOWED BY THE PARAMETER STRING BEING    *
*                   RETURNED TO SYNCSORT.                     *
*                                                             *
*                  .FOR RETURN CODE 04 IN REGISTER 15,        *
*                   NO PARM VALUE IS RETURNED TO SYNCSORT.    *
*                                                             *
*                                                             *
*        EXIT      .RETURN TO THE CALLER VIA BR14.            *
*                                                             *
*                                                             *
*        RETURN    .00   A PARAMETER STRING IS BEING RETURNED *
*        CODES           TO SYNCSORT.                         *
*                  .04   A PARAMETER STRING IS NOT BEING      *
*                        RETURNED TO SYNCSORT.                *
*                                                             *
*                                                             *
*        RESTRICTIONS/LIMITATIONS                             *
*                                                             *
*                  .THIS VERSION OF THE EXIT RUNS ONLY UNDER  *
*                   MVS/XA/JES2.  THE TECHNIQUE USED TO       *
*                   DETERMINE THE NAMES OF THE OTHER JOBS     *
*                   RUNNING IN THE SYSTEM IS DEPENDENT ON     *
*                   THE MVS ADDRESS SPACE VECTOR TABLE        *
*                   (ASVT).  THE TECHNIQUE USED TO DETERMINE  *
*                   THE NAME OF THE FIRST PROGRAM EXECUTED    *
*                   IN THE STEP IS DEPENDENT ON THE PROGRAM   *
*                   NAME FIELD IN THE JSCB (SU64).  USE OF    *
*                   THE "ERRET=" OPERAND ON THE LOAD MACRO    *
*                   FOR $ORTDATA IS A FUNCTION OF MVS.  THE   *
*                   PERFORMANCE GROUP NUMBER IS OBTAINED      *
*                   FROM THE OUCB WHIC RESIDES ABOVE THE      *
*                   LINE IN MVS/XA.  LASTLY, THE JOB CLASS    *
*                   DETERMINATION SUBROUTINE IS DEPENDENT ON  *
*                   JES2 (ALTHOUGH THIS IS THE ONLY JES2      *
*                   DEPENDENCY IN THE EXIT).                  *
*                                                             *
*                  .MVS/JES3 AND OPERATING SYSTEMS OTHER      *
*                   THAN MVS ARE NOT SUPPORTED BY THIS        *
*                   VERSION OF THE EXIT.                      *
*                                                             *
*                                                             *
*        PACKAGING/ASSEMBLY                                   *
*                                                             *
*                  .TO SIMPLIFY INSTALLATION AND UPDATES,     *
*                   THE SYNCSORT EXIT IS PACKAGED AS TWO      *
*                   ASSEMBLER SOURCE MODULES AND A MEMBER     *
*                   OF ASSEMBLER "COPY" CODE:                 *
*                                                             *
*                      -$ORTPARM IS THE ACTUAL SYNCSORT EXIT  *
*                       AND CONTAINS PROGRAM MACRO            *
*                       DEFINITIONS, DOCUMENTATION, AND ALL   *
*                       EXECUTABLE CODE.                      *
*                                                             *
*                      -$ORTDATA IS THE PARAMETER TABLE       *
*                       MODULE WHICH IS "LOADED" BY $ORTPARM. *
*                       THIS MODULE CONTAINS THE DEFINITION   *
*                       OF THE #PARM MACRO, AND COPIES THE    *
*                       $ORTABLE PARAMETER TABLE ENTRY        *
*                       DEFINITIONS INTO ITS ASSEMBLY         *
*                       TO PRODUCE THE PARAMETER TABLE WHICH  *
*                       IS LOADED AND REFERENCED BY $ORTPARM. *
*                                                             *
*                      -$ORTABLE IS ASSEMBLER COPY CODE       *
*                       CONTAINING THE PARAMETER TABLE        *
*                       ENTRIES SPECIFYING SORT PARAMETER     *
*                       VALUES AND THE EXECUTION STATE        *
*                       DEPENDENCIES FOR USE OF THE SPECIFIED *
*                       PARAMETER VALUES.  EACH PARAMETER     *
*                       TABLE ENTRY IS DEFINED USING A MACRO, *
*                       #PARM, WHICH IS DEFINED AS A PROGRAM  *
*                       MACRO IN $ORTDATA.                    *
*                                                             *
*                  .THE FOLLOWING SYSTEM LIBRARIES MUST BE    *
*                   INCLUDED IN THE SYSLIB CONCATENATION      *
*                   DURING ASSEMBLY OF $ORTPARM:              *
*                      -SYS1.AMACLIB                          *
*                      -SYS1.AMODGEN                          *
*                      -SYS1.ATSOMAC                          *
*                      -SYS1.HASPSRC.                         *
*                   IN ADDITION, THE LIBRARY CONTAINING       *
*                   $ORTABLE MUST BE INCLUDED IN THE SYSLIB   *
*                   CONCATENATION WHEN ASSEMBLING $ORTDATA.   *
*                                                             *
*                                                             *
*        UPDATE HISTORY                                       *
*                  .EXIT DESIGNED, CODED, AND TESTED.         *
*                                                08/09/81  TJA*
*                  .REPACKAGED AS TWO LOAD MODULES            *
*                   FOR EASE OF MAINTENANCE.     09/30/81  TJA*
*                                                             *
*                  .UPDATED FOR MVS/XA TO:                    *
*                      -USE 31-BIT ADDRESSING TO ACCESS       *
*                       THE OUCB WHICH WAS MOVED ABOVE THE    *
*                       LINE IN MVS/SP 2.1.0;                 *
*                      -USE THE "RU" FORM OF GETMAIN &        *
*                       FREEMAIN TO FACILITATE CONVERSION     *
*                       TO 31-BIT ADDRESSING LATER ON;        *
*                      -BUILD THE WTOR PARAMETER LIST USING   *
*                       THE 31-BIT FORMAT FOR MVS/XA;         *
*                      -ADD LOGIC TO PROCESS THE TCBJSCB      *
*                       FIELD IN THE TCB AS A 24-BIT ADDRESS. *
*                       AN "N" INSTRUCTION WAS INSERTED AFTER *
*                       EACH "L" INSTRUCTION FROM TCBJSCB,    *
*                       IN ORDER TO CLEAR THE TOP BYTE OF     *
*                       THE REGISTER;                         *
*                      -USE THE JES2 $SJB MAPPING MACRO AND   *
*                       ELIMINATE EQUATES FOR JES2 SJB        *
*                       FIELDS TO SIMPLIFY CHANGING THIS      *
*                       EXIT WHEN JES2 CHANGES;               *
*                      -ADD DIAGNOSTIC MESSAGES MSG020 AND    *
*                       MSG029 TO DOCUMENT THE LOADING AND    *
*                       DELETING OF $ORTDATA.                 *
*                                                03/22/84  TJA*
*                      -USE BAS/BASR INSTEAD OF BAL/BALR      *
*                       INSTRUCTIONS;            03/26/84  TJA*
*                      -ADD ASSEMBLER AMODE/RMODE             *
*                       SPECIFICATIONS;          04/02/84  TJA*
*                      -ADD DIAGNOSTIC MESSAGE 01             *
*                       DOCUMENTING THE LEVEL OF $ORTPARM.    *
*                                                04/03/84  TJA*
*                      -ADD #SETMODE MACRO TO SUPPORT         *
*                       EXECUTION ON EITHER MVS/XA OR 370.    *
*                                                04/12/84  TJA*
*                      -CHANGE #SETMODE TO SETAMODE AND       *
*                       PICK UP CHANGES IN MACRO.             *
*                                                04/12/84  TJA*
*                      -PICK UP SETAMODE VERSION 02.00        *
*                                                07/13/84  TJA*
*                                                             *
*                                                             *
*        FACILITIES/FEATURES                                  *
*                                                             *
*               THIS EXIT DETERMINES THE EXECUTION OPTIONS    *
*        TO BE USED BY SYNCSORT BASED ON AN EVALUATION OF THE *
*        STATE OF THE SYSTEM AT THE TIME THE EXIT IS          *
*        INVOKED, AND RETURNS A STANDARD OS/MVS PARAMETER     *
*        STRING CONTAINING THESE OPTIONS.  THIS ALLOWS OUR    *
*        INSTALLATION TO RESTRICT THE USE OF OPTIONS WHOSE    *
*        USE COULD DEGRADE THE RESPONSIVENESS OF ONLINE       *
*        APPLICATIONS (E.G., TSO & CICS), WHILE PERMITTING USE*
*        OF THE MORE EFFICIENT SORTING OPTIONS AT OTHER TIMES.*
*        THE OPTIONS MOST COMMONLY SPECIFIED BY THIS EXIT     *
*        ARE VSCORE=, VSIO=, AND OPT=.                        *
*                                                             *
*                                                             *
*               AS NOTED ABOVE, THE EXIT IS TABLE DRIVEN,     *
*        USING A PARAMETER TABLE ASSEMBLED AS A SEPARATE      *
*        MODULE THAT IS LOADED BY THE EXIT.  THE PARAMETER    *
*        TABLE MODULE, $ORTDATA, IS PACKAGED AS A SEPARATE    *
*        LOAD MODULE TO EASE THE MAINTENANCE AND UPDATING     *
*        PROCESS.  $ORTDATA IS FORMATTED TO APPEAR LIKE A     *
*        BLOCK OF DATA FROM A VARIABLE LENGTH RECORD FILE;    *
*        EACH TABLE ENTRY IS A LOGICAL RECORD WITHIN THE      *
*        BLOCK.  A TABLE ENTRY IS DEFINED USING THE "#PARM"   *
*        MACRO WHICH IS A PROGRAM MACRO DEFINED INTERNALLY    *
*        TO $ORTDATA.  THE "#PARM" MACRO HAS SEVERAL KEYWORD  *
*        PARAMETERS FOR SPECIFYING WHEN THE EXIT SHOULD       *
*        PROCESS THE TABLE ENTRY, A KEYWORD FOR ACTIVATING    *
*        DIAGNOSTIC MESSAGES UNDER CERTAIN CONDITIONS, TWO    *
*        KEYWORDS FOR SPECIFYING PROCESSING OPTIONS IF        *
*        "$ORTPARM" OR "SORTMSG" DD STATEMENTS ARE FOUND IN   *
*        THE TIOT, AND A KEYWORD FOR SPECIFYING THE           *
*        PARAMETER STRING TO BE USED IF THE TABLE ENTRY       *
*        SATISFIES ALL OF THE CONSTRAINTS SPECIFIED ON THE    *
*        OTHER KEYWORD PARAMETERS.  THE KEYWORD PARAMETERS    *
*        THAT ARE SUPPORTED ON THE #PARM MACRO FOR            *
*        INDICATING WHEN THE TABLE ENTRY SHOULD BE SELECTED   *
*        FOR PROCESSING ARE AS FOLLOWS:                       *
*                                                             *
*               ."SID=".  THIS KEYWORD PARAMETER TELLS THE    *
*                EXIT TO PROCESS THIS TABLE ENTRY IF THE      *
*                SYSTEM'S SMF ID MATCHES THE SMF ID SPECIFIED *
*                FOR THIS PARAMETER.  A GENERIC COMPARISON IS *
*                PERFORMED TO DETERMINE WHETHER THERE IS A    *
*                MATCH.  THE DEFAULT VALUE FOR THIS KEYWORD IS*
*                "====", INDICATING THAT THE ENTRY SHOULD BE  *
*                PROCESSED ON ALL SYSTEMS (I.E., THAT EXECU-  *
*                TION ON A SPECIFIC SYSTEM IS NOT A FACTOR IN *
*                SELECTING THIS TABLE ENTRY FOR PROCESSING).  *
*                                                             *
*               ."BEGIN=".  THIS KEYWORD PARAMETER TELLS THE  *
*                EXIT TO SELECT THIS TABLE ENTRY FOR          *
*                PROCESSING IF THE CURRENT TIME OF DAY IS     *
*                GREATER THAN OR EQUAL TO THIS TIME VALUE.    *
*                BEGINNING TIME VALUES ARE SPECIFIED AS ONE   *
*                THROUGH EIGHT DECIMAL DIGITS INDICATING TIME *
*                SPECIFICATIONS AS FOLLOWS:                   *
*                   BEGIN=H                                   *
*                   BEGIN=HH                                  *
*                   BEGIN=HHM                                 *
*                   BEGIN=HHMM                                *
*                   BEGIN=HHMMS                               *
*                   BEGIN=HHMMSS                              *
*                   BEGIN=HHMMSST                             *
*                   BEGIN=HHMMSSTH                            *
*                THE DEFAULT VALUE IS "0000", SPECIFYING A    *
*                BEGINNING TIME OF 00:00:00.00.               *
*                                                             *
*               ."END=".  THIS KEYWORD PARAMETER TELLS THE    *
*                EXIT TO SELECT THIS TABLE ENTRY FOR          *
*                PROCESSING IF THE CURRENT TIME OF DAY IS     *
*                STRICTLY LESS THAN THIS TIME VALUE.  ENDING  *
*                TIME VALUES ARE SPECIFIED AS ONE THROUGH     *
*                EIGHT DECIMAL DIGITS AND ARE INTERPRETED IN  *
*                THE SAME WAY AS "BEGIN=" SPECIFICATIONS.     *
*                THE DEFAULT VALUE IS "2400" SPECIFYING AN    *
*                ENDING TIME OF 24:00:00.00.                  *
*                                                             *
*               ."DOW=".  THIS KEYWORD PARAMETER TELLS THE    *
*                EXIT TO PROCESS THIS TABLE ENTRY IF THE      *
*                CURRENT DAY OF THE WEEK IS SPECIFIED.  THE   *
*                "DOW=" VALUE IS SPECIFIED A ONE THROUGH SEVEN*
*                DECIMAL DIGITS, WITH EACH DIGIT SPECIFYING A *
*                DAY OF THE WEEK; DIGITS 0-6 ARE VALID WITH   *
*                "0" SPECIFYING SUNDAY, AND "6" SPECIFYING    *
*                SATURDAY.  THE DEFAULT VALUE FOR THIS KEYWORD*
*                IS "0123456" INDICATING THAT THE TABLE ENTRY *
*                SHOULD BE PROCESSED ON EVERY DAY OF THE WEEK *
*                (I.E., DAY-OF-WEEK IS NOT A FACTOR IN        *
*                SELECTING THIS TABLE ENTRY FOR PROCESSING).  *
*                                                             *
*               ."JCLAS=".  THIS KEYWORD PARAMETER TELLS THE  *
*                EXIT TO PROCESS THIS TABLE ENTRY IF THE      *
*                CURRENT JOB'S EXECUTION CLASS MATCHES THE JOB*
*                CLASS VALUE SPECIFIED FOR THIS PARAMETER.    *
*                THE JOB CLASS VALUE, IF SPECIFIED, MUST      *
*                CONSIST OF A SINGLE CHARACTER; ENCLOSING     *
*                QUOTES ARE OPTIONAL.  A GENERIC COMPARISON IS*
*                PERFORMED TO DETERMINE WHETHER THERE IS A    *
*                MATCH.  THE DEFAULT VALUE FOR THIS PARAMETER *
*                IS "=" INDICATING THAT ALL JOB CLASSES MATCH *
*                (I.E., THAT JOB CLASS IS NOT A FACTOR IN     *
*                SELECTING THIS TABLE ENTRY FOR PROCESSING).  *
*                                                             *
*               ."JNAME=".  THIS KEYWORD PARAMETER TELLS THE  *
*                EXIT TO PROCESS THIS TABLE ENTRY IF THE      *
*                CURRENT JOB'S JOBNAME MATCHES THE JOBNAME    *
*                VALUE SPECIFIED FOR THIS PARAMETER.  THE     *
*                JOBNAME VALUE, IF SPECIFIED, MUST CONSIST OF *
*                ONE THROUGH EIGHT CHARACTERS; ENCLOSING      *
*                QUOTES ARE OPTIONAL.  A GENERIC COMPARISON IS*
*                PERFORMED TO DETERMINE WHETHER THERE IS A    *
*                MATCH.  THE DEFAULT VALUE FOR THIS PARAMETER *
*                IS "========" INDICATING THAT ALL JOBNAMES   *
*                MATCH (I.E., THAT JOB NAME IS NOT A FACTOR IN*
*                SELECTING THIS TABLE ENTRY FOR PROCESSING).  *
*                                                             *
*               ."SNAME=".  THIS KEYWORD PARAMETER TELLS THE  *
*                EXIT TO PROCESS THIS TABLE ENTRY IF THE      *
*                CURRENT JOB'S STEPNAME MATCHES THE STEPNAME  *
*                VALUE SPECIFIED FOR THIS PARAMETER.  THE     *
*                STEPNAME VALUE, IF SPECIFIED, MUST CONSIST OF*
*                ONE THROUGH EIGHT CHARACTERS; ENCLOSING      *
*                QUOTES ARE OPTIONAL.  A GENERIC COMPARISON IS*
*                PERFORMED TO DETERMINE WHETHER THERE IS A    *
*                MATCH.  THE DEFAULT VALUE FOR THIS PARAMETER *
*                IS "========" INDICATING THAT ALL STEPNAMES  *
*                MATCH (I.E., THAT STEP NAME IS NOT A FACTOR  *
*                IN SELECTING THIS TABLE ENTRY FOR            *
*                PROCESSING).                                 *
*                                                             *
*               ."PSNAME=".  THIS KEYWORD PARAMETER TELLS THE *
*                EXIT TO PROCESS THIS TABLE ENTRY IF THE      *
*                CURRENT JOB'S PROCSTEP NAME MATCHES THE      *
*                PROCSTEPNAME VALUE SPECIFIED FOR THIS        *
*                PARAMETER.  THE PROCSTEP NAME VALUE, IF      *
*                SPECIFIED, MUST CONSIST OF ONE THROUGH EIGHT *
*                CHARACTERS; ENCLOSING QUOTES ARE OPTIONAL.  A*
*                GENERIC COMPARISON IS PERFORMED TO DETERMINE *
*                WHETHER THERE IS A MATCH.  THE DEFAULT VALUE *
*                FOR THIS PARAMETER IS "========" INDICATING  *
*                THAT ALL PROCSTEP NAMES MATCH (I.E., THAT    *
*                PROCSTEP NAME IS NOT A FACTOR IN SELECTING   *
*                THIS TABLE ENTRY FOR PROCESSING).            *
*                                                             *
*               ."PGM=".  THIS KEYWORD PARAMETER TELLS THE    *
*                EXIT TO PROCESS THIS TABLE ENTRY IF THE      *
*                CURRENT JOBSTEP'S PROGRAM NAME MATCHES THE   *
*                PROGRAM NAME VALUE SPECIFIED FOR THIS        *
*                PARAMETER.  THE PROGRAM NAME VALUE, IF       *
*                SPECIFIED, MUST CONSIST OF ONE THROUGH EIGHT *
*                CHARACTERS; ENCLOSING QUOTES ARE OPTIONAL.  A*
*                GENERIC COMPARISON IS PERFORMED TO DETERMINE *
*                WHETHER THERE IS A MATCH.  THE DEFAULT VALUE *
*                FOR THIS PARAMETER IS "========" INDICATING  *
*                THAT ALL PROGRAM  NAMES MATCH (I.E., THAT    *
*                PROGRAM  NAME IS NOT A FACTOR IN SELECTING   *
*                THIS TABLE ENTRY FOR PROCESSING).            *
*                                                             *
*               ."PERFORM=".  THIS KEYWORD TELLS THE EXIT TO  *
*                PROCESS THIS TABLE ENTRY IF THE CURRENT JOB'S*
*                PERFORMANCE GROUP NUMBER (OUCBNPG) AT THE    *
*                TIME THE EXIT IS INVOKED MATCHES ONE OF THE  *
*                PERFORMANCE GROUP NUMBERS LISTED BY THIS     *
*                KEYWORD.  EACH PERFORMANCE GROUP SPECIFIED   *
*                MUST HAVE A VALUE BETWEEN 1 AND 999; ZERO    *
*                VALUES WILL BE IGNORED BY THE EXIT, AND      *
*                VALUES GREATER THAN 999 WILL BE FLAGGED      *
*                DURING ASSEMBLY.  THE DEFAULT VALUE FOR THIS *
*                PARAMETER IS NULL(PERFORM=,) INDICATING THAT *
*                ALL PERFORMANCE GROUP VALUES MATCH (I.E.,    *
*                THAT PERFORMANCE GROUP NUMBER IS NOT A FACTOR*
*                IN SELECTING THIS TABLE ENTRY FOR            *
*                PROCESSING).                                 *
*                                                             *
*               ."OJOB=".  THIS KEYWORD TELLS THE EXIT TO     *
*                PROCESS THIS TABLE ENTRY IF A JOB HAVING ANY *
*                OF THE JOB NAMES LISTED BY THIS KEYWORD IS   *
*                FOUND RUNNING ALONGSIDE THE THE CURRENT JOB. *
*                IF THIS KEYWORD IS USED, EACH JOBNAME        *
*                SPECIFIED MUST CONSIST OF ONE THROUGH EIGHT  *
*                CHARACTERS; ENCLOSING QUOTES ARE OPTIONAL.  A*
*                GENERIC COMPARISON IS PERFORMED TO DETERMINE *
*                WHETHER THERE IS A MATCH.  THE DEFAULT VALUE *
*                FOR THIS PARAMETER IS NULL (OJOB=,)          *
*                INDICATING THAT ALL JOB NAMES MATCH (I.E.,   *
*                THAT THE NAMES OF CORESIDENT JOBS ARE NOT A  *
*                FACTOR IN SELECTING THIS TABLE ENTRY FOR     *
*                PROCESSING).  IT SHOULD BE NOTED THAT USE OF *
*                THIS PARAMETER CAN BE COSTLY IN TERMS OF CPU *
*                TIME; THE JOB NAME FOR EACH JOB IN THE SYSTEM*
*                OTHER THAN THE CURRENT JOB MUST BE COMPARED  *
*                AGAINST EACH ENTRY IN THE LIST.  THUS THE    *
*                NUMBER OF COMPARISONS IS EQUAL TO (THE NUMBER*
*                OF ACTIVE ADDRESS SPACES IN THE SYSTEM       *
*                EXCLUDING THE CURRENT JOB) MULTIPLIED BY (THE*
*                NUMBER OF JOB NAME ENTRIES IN THE LIST).  THE*
*                MOST FREQUENT USES OF THIS PARAMETER WILL BE *
*                FOR LIMITING THE RESOURCE USE OF SORTS       *
*                RUNNING ALONGSIDE CRITICAL ONLINE            *
*                APPLICATIONS LIKE CICS, IMS, OR TSO.         *
*                                                             *
*               ."DATE=".  THIS KEYWORD TELLS THE EXIT TO     *
*                PROCESS THIS TABLE ENTRY IF TODAY'S JULIAN   *
*                DATE IS LISTED BY THIS KEYWORD.  THE DATES   *
*                SPECIFIED FOR THIS KEYWORD MUST BE IN A      *
*                FORM THAT CAN BE COMPARED WITH THE DATE      *
*                VALUE RETURNED FROM THE "TIME" MACRO;  THUS  *
*                EACH DATE VALUE MUST CONSIST OF EXACTLY      *
*                FIVE NUMERIC DIGITS REPRESENTING A DATE      *
*                IN "YYDDD" FORM.  THE MOST FREQUENT USES     *
*                OF THIS OPTION WILL BE FOR SPECIFYING        *
*                TABLE ENTRIES FOR HOLIDAYS TO SUPERCEDE      *
*                PREVIOUS TABLE ENTRIES APPLYING AT ALL       *
*                OTHER TIMES.                                 *
*                                                             *
*                                                             *
*               THE GENERIC COMPARISON USED WITH THE SID=,    *
*        JCLAS=, JNAME=, SNAME=, PSNAME=, PGM=, AND OJOB=     *
*        KEYWORDS IS MODELED AFTER THE PICTURE STRING         *
*        IMPLEMENTATION FOR THE FIND AND CHANGE COMMANDS OF   *
*        ISPF BROWSE AND EDIT.  THE NAMES SPECIFIED AS VALUES *
*        FOR THESE KEYWORDS ARE TREATED AS STRING SELECTION   *
*        MASKS.  BLANKS, ALPHABETIC CHARACTERS, AND NUMERIC   *
*        DIGITS ARE VALID AND REPRESENT THEMSELVES; IF A BLANK*
*        IS BEING USED AS A SELECTION CHARACTER IN ANY        *
*        POSITION OTHER THAN AT THE END OF THE MASK, THE      *
*        SELECTION MASK MUST BE ENCLOSED IN QUOTES.  SIX      *
*        CHARACTERS HAVE SPECIAL SIGNIFICANCE IN SELECTION    *
*        MASKS:                                               *
*                                                             *
*             #  -  NUMERIC CHARACTER                         *
*             -  -  NON-NUMERIC CHARACTER                     *
*             @  -  ALPHABETIC CHARACTER                      *
*             $  -  SPECIAL CHARACTER ($,#,@,.,-,=)           *
*             ^  -  ANY NON-BLANK CHARACTER                   *
*             =  -  ANY CHARACTER                             *
*                                                             *
*        THE SELECTION MASK IS COMPARED CHARACTER BY CHARACTER*
*        WITH THE ARGUMENT STRING (THE SMF ID, JOB CLASS, JOB *
*        NAME, STEP NAME, PROCSTEP NAME OR STEP PROGRAM NAME  *
*        BEING TESTED) MOVING FROM LEFT TO RIGHT.  THE FIRST  *
*        CHARACTER NOT SATISFYING THE SELECTION REQUIREMENTS  *
*        OF ITS CORRESPONDING MASK BYTE TERMINATES THE        *
*        COMPARE.  A SELECTION MASK SHORTER THAN ITS ARGUMENT *
*        STRING IS PROCESSED AS IF IT WERE EXTENDED ON THE    *
*        RIGHT WITH "="; A SELECTION STRING LONGER THAN ITS   *
*        ARGUMENT STRING IS CHECKED TO INSURE THAT ITS BYTES  *
*        EXTENDING BEYOND THE LENGTH OF THE ARGUMENT STRING   *
*        ALL CONTAIN "=" BEFORE AN EQUAL COMPARISON IS        *
*        ALLOWED.                                             *
*                                                             *
*                                                             *
*               THE TABLE ENTRY IS SELECTED FOR PROCESSING IF *
*        ALL OF THE TESTS DESCRIBED FOR THE SELECTION KEYWORDS*
*        ARE MET.  BECAUSE THE SELECTION IS MADE BASED ON THE *
*        RESULT OF A LOGICAL "AND" OF ALL THE INTERMEDIATE    *
*        SELECTION TEST RESULTS, THE DEFAULTS FOR THE         *
*        SELECTION TEST KEYWORDS HAVE BEEN ESTABLISHED SO THAT*
*        THE EACH TEST YIELDS A MATCH IN ALL CASES IF         *
*        OVERRIDING VALUES ARE NOT SUPPLIED.  THUS THE USER   *
*        NEEDS TO SPECIFY ONLY THOSE SELECTION KEYWORDS AND   *
*        VALUES OF INTEREST; KEYWORDS NOT SPECIFIED HAVE NO   *
*        EFFECT ON THE SELECTION PROCESS.                     *
*                                                             *
*                                                             *
*               THE KEYWORD PARAMETERS ON THE #PARM MACRO THAT*
*        SPECIFY EXIT PROCESSING OPTIONS WHICH ARE INCIDENTAL *
*        TO THE PRIMARY FUNCTION OF ASSEMBLING A PARAMETER    *
*        STRING VALUE FOR THE SORT ARE AS FOLLOWS:            *
*                                                             *
*               ."ML=".  THIS KEYWORD PARAMETER SPECIFIES A   *
*                MESSAGE LEVEL VALUE.  THIS VALUE IS PROVIDED *
*                TO ALLOW MESSAGES TO THE USER TO BE ISSUED   *
*                CONDITIONALLY WITHOUT REQUIRING USE OF A     *
*                "//$ORTML##" DD STATEMENT (SEE THE           *
*                DESCRIPTION OF THE "//$ORTML## DD" FACILITY  *
*                BELOW.)  TEN VALUES ARE SUPPORTED: ML00-ML09;*
*                EQUATES ARE PROVIDED IN $ORTPARM TO ALLOW    *
*                THESE VALUES TO BE USED AND PROVIDE A        *
*                WHERE-USED INDICATION ON THE ASSEMBLY CROSS  *
*                REFERENCE.  THE DEFAULT VALUE FOR THIS       *
*                KEYWORD IN THE MACRO IS "ML00" WHICH         *
*                INDICATES THAT THIS ENTRY DOES NOT PROVIDE A *
*                MESSAGE LEVEL VALUE OVERRIDING ANY NON-ZERO  *
*                MESSAGE LEVEL VALUE (IF ANY) OBTAINED FROM A *
*                PREVIOUSLY PROCESSED TABLE ENTRY.  THE       *
*                INITIAL DEFAULT VALUE SET BY THE EXIT BEFORE *
*                PROCESSING THE #PARM TABLE IS "ML01"         *
*                (INDICATING THAT NO MESSAGES ARE TO BE       *
*                ISSUED), OR THE "##" VALUE SPECIFIED IN THE  *
*                LAST "$ORTML##" DD STATEMENT FOUND IN THE    *
*                TIOT.                                        *
*                                                             *
*               ."$P=".  THIS KEYWORD PARAMETER SPECIFIES THE *
*                PROCESSING REQUIRED IF A "//$ORTPARM" DD     *
*                STATEMENT IS FOUND IN THE TIOT FOR THE       *
*                CURRENT JOB STEP.  THREE VALUES ARE          *
*                SUPPORTED: $P00-$P02; EQUATES ARE PROVIDED TO*
*                ALLOW THESE VALUES TO BE USED AND PROVIDE A  *
*                WHERE-USED INDICATION ON THE ASSEMBLY CROSS  *
*                REFERENCE.  THESE VALUES HAVE THE FOLLOWING  *
*                SIGNIFICANCE:                                *
*                      -$P00  THIS ENTRY DOES NOT PROVIDE A   *
*                             $ORTPARM PROCESSING VALUE       *
*                             OVERRIDING ANY NON-ZERO $ORTPARM*
*                             PROCESSING OPTION (IF ANY)      *
*                             OBTAINED FROM A PREVIOUSLY      *
*                             PROCESSED TABLE ENTRY.          *
*                      -$P01  USE OF THE "//$ORTPARM DD"      *
*                             STATEMENT IS AUTHORIZED AND ANY *
*                             SORT OPTIONS PROVIDED VIA A     *
*                             "$ORTPARM" DD STATEMENT WILL    *
*                             OVERRIDE VALUES RETURNED BY THE *
*                             EXIT.                           *
*                      -$P02  USE OF THE "//$ORTPARM DD"      *
*                             STATEMENT IS NOT AUTHORIZED; THE*
*                             TIOT WILL BE SCANNED TO LOCATE  *
*                             THESE DD STATEMENTS, AND IF ANY *
*                             "$ORTPARM" DD STATEMENT IS      *
*                             FOUND, AN ERROR MESSAGE WILL BE *
*                             ISSUED WARNING THE USER THAT THE*
*                             USE VIOLATES AN INSTALLATION    *
*                             STANDARD.  THE DATA SET IS NOT  *
*                             DYNAMICALLY UNALLOCATED.        *
*                      -$P03  USE OF THE "//$ORTPARM DD"      *
*                             STATEMENT IS NOT AUTHORIZED; THE*
*                             TIOT WILL BE SCANNED TO LOCATE  *
*                             THESE DD STATEMENTS, AND ANY DD *
*                             STATEMENTS FOUND WILL BE        *
*                             DYNAMICALLY UNALLOCATED USING   *
*                             SVC 99 (DYNALLOC) TO PREVENT    *
*                             SYNCSORT FROM RECOGNIZING THE   *
*                             FIRST SUCH DD STATEMENT AND     *
*                             PROCESSING OPTIONS FROM IT.     *
*                THE DEFAULT VALUE FOR THIS KEYWORD IN THE    *
*                MACRO IS "$P00".  THE INITIAL VALUE SET BY   *
*                THE EXIT BEFORE PROCESSING THE #PARM TABLE IS*
*                "$P01".                                      *
*                                                             *
*               ."MD=".  THIS KEYWORD PARAMETER SPECIFIES THE *
*                PROCESSING REQUIRED IF A "//SORTMSG DD"      *
*                STATEMENT IS FOUND IN THE TIOT FOR THE       *
*                CURRENT JOB STEP.  THREE VALUES ARE          *
*                SUPPORTED: MD00-MD02; EQUATES ARE PROVIDED TO*
*                ALLOW THESE VALUES TO BE USED AND PROVIDE A  *
*                WHERE-USED INDICATION ON THE ASSEMBLY CROSS  *
*                REFERENCE LISTING.  THE SIGNIFICANCE OF THESE*
*                VALUES IS AS FOLLOWS:                        *
*                      -MD00  THIS ENTRY DOES NOT PROVIDE A   *
*                             SORTMSG DD PROCESSING OPTION    *
*                             VALUE.  ANY NON-ZERO SORTMSG    *
*                             PROCESSING OPTION VALUE (IF ANY)*
*                             OBTAINED FROM A PREVIOUSLY      *
*                             PROCESSED TABLE ENTRY REMAINS IN*
*                             FORCE.                          *
*                      -MD01  THE TIOT IS NOT TO BE SCANNED   *
*                             FOR THE PRESENCE OF A           *
*                             "//SORTMSG" DD STATEMENT, AND   *
*                             THE SORT OPTION IS NOT TO BE    *
*                             ADDED TO THE PARAMETER STRING   *
*                             BEING BUILT FOR SORT.           *
*                      -MD02  THE TIOT IS TO BE SCANNED FOR   *
*                             THE PRESENCE OF A "//SORTMSG DD"*
*                             STATEMENT.  IF ONE IS FOUND, THE*
*                             SORT OPTION "MSGDD=SORTMSG" IS  *
*                             TO BE ADDED TO THE PARAMETER    *
*                             STRING BEING BUILT FOR SORT.    *
*                THE DEFAULT VALUE FOR THIS KEYWORD IN THE    *
*                MACRO IS "MD00".  THE INITIAL VALUE SET BY   *
*                THE EXIT BEFORE PROCESSING THE #PARM TABLE IS*
*                "MD02".                                      *
*                                                             *
*                                                             *
*               THE FINAL PROCESSING OPTION VALUES ARE BASED  *
*        ON A COMPLETE SCAN OF THE #PARM TABLE.  EVERY TABLE  *
*        ENTRY SATISFYING THE SELECTION CRITERIA (AND WHICH IS*
*        THEREFORE TO BE PROCESSED) IS EVALUATED, AND ALL     *
*        NON-ZERO PROCESSING OPTION VALUES ARE SAVED,         *
*        SUPERSEDING VALUES PREVIOUSLY SAVED.  A PROCESSING   *
*        OPTION VALUE OF ZERO (ML00, $P00, MD00) IS NOT       *
*        RETAINED, ALLOWING THE LAST STORED OPTION TO REMAIN  *
*        IN FORCE.  THIS ALLOWS THE TABLE TO BE CONSTRUCTED   *
*        WITH TABLE ENTRIES FOR EXCEPTIONS PLACED AT THE END; *
*        THE EXCEPTION ENTRIES NEED ONLY SPECIFY THOSE VALUES *
*        THAT CHANGE WITH THE EXCEPTION; THE PREVIOUS VALUES  *
*        REMAIN IN FORCE.                                     *
*                                                             *
*                                                             *
*               A COMMENT ABOUT THE ORDER WITH WHICH SORT     *
*        PROCESSING OPTIONS ARE DETERMINED IS IN ORDER.  THE  *
*        OPTIONS SPECIFIED VIA THE "//$ORTPARM" DD STATEMENT  *
*        HAVE THE HIGHEST AUTHORITY AND OVERRIDE CORRESPONDING*
*        VALUES PROVIDED BY THE PARMEXIT FACILITY ($ORTPARM   *
*        EXIT ROUTINE) OR THE SORT CALLER (EXEC STATEMENT     *
*        PARM FIELD OR LINK/ATTACH PARAMETER LIST); OPTIONS   *
*        SUPPLIED BY THE PARMEXIT FACILITY, IN TURN,          *
*        OVERRIDE CORRESPONDING VALUES PROVIDED BY THE SORT   *
*        CALLER'S PARAMETER LIST.  BECAUSE OPTIONS SPECIFIED  *
*        VIA THE "//$ORTPARM" DD STATEMENT CAN OVERRIDE       *
*        THOSE PROVIDED BY THE EXIT, THE EXIT PROVIDES THE    *
*        ABILITY TO DYNAMICALLY UNALLOCATE THE "//$ORTPARM"   *
*        DATA SET BEFORE RETURNING CONTROL TO SYNCSORT, IN    *
*        ORDER TO KEEP SYNCSORT FROM RECOGNIZING THE          *
*        PRESENCE OF THE DATA SET AND PROCESSING ITS CONTENTS.*
*                                                             *
*                                                             *
*               THE FINAL KEYWORD SUPPORTED ON THE #PARM      *
*        MACRO IS "PARM=":                                    *
*               ."PARM=".  THIS KEYWORD PARAMETER SPECIFIES THE
*                PARAMETER STRING VALUE TO BE RETURNED TO     *
*                SYNCSORT.  THE STRING VALUE CONSISTS OF ONE  *
*                TO ONE HUNDRED CHARACTERS; IF THE STRING     *
*                VALUE CONTAINS SPECIAL CHARACTERS, IT MUST   *
*                BE ENCLOSED IN QUOTES TO PREVENT ASSEMBLY    *
*                ERRORS ("," AND "=" ARE TWO SUCH CHARACTERS).*
*                THE DEFAULT VALUE FOR THIS KEYWORD IN THE    *
*                MACRO IS NULL (PARM=),  INDICATING THAT THIS *
*                TABLE ENTRY DOES NOT PROVIDE A PARM STRING,  *
*                AND THAT THE PARM STRING VALUE (IF ANY)      *
*                OBTAINED FROM PROCESSING A PRECEDING #PARM   *
*                TABLE ENTRY IS TO REMAIN IN FORCE.  IF THIS  *
*                KEYWORD PARAMETER IS SPECIFIED AS:           *
*                      -PARM='STRING'                         *
*                      -PARM=('STRING')                       *
*                THE "STRING" VALUE REPLACES ANY PARAMETER    *
*                ALREADY DETERMINED.  THE FACILITY TO ADD AN  *
*                OPTION TO THE END OF AN ALREADY PRESENT      *
*                STRING VALUE IS ALSO PROVIDED.  IF THIS      *
*                KEYWORD PARAMETER IS SPECIFIED AS:           *
*                      -PARM=('STRING',UPD)                   *
*                THE "STRING" VALUE IS APPENDED TO ANY STRING *
*                VALUE ALREADY ASSEMBLED.  IF A STRING VALUE  *
*                IS ALREADY PRESENT, A SEPARATING COMMA IS    *
*                INSERTED; IF THE STRING VALUE SO FAR IS NULL,*
*                THE STRING VALUE TO BE APPENDED BECOMES THE  *
*                PARAMETER STRING VALUE FOR SYNCSORT.  NO     *
*                VERIFICATION PROCESSING IS PERFORMED FOR     *
*                DUPLICATE OPTIONS WHEN UPDATING THE CURRENT  *
*                PARAMETER STRING WITH ADDITIONAL VALUES.     *
*                                                             *
*               THE EXIT CONTAINS A DIAGNOSTIC MESSAGE        *
*        FACILITY WHICH CAN BE ACTIVATED IF DIFFICULTIES ARISE*
*        IN USING THE EXIT.  EACH DIAGNOSTIC MESSAGE ISSUED BY*
*        THE EXIT IS ASSOCIATED WITH A MESSAGE LEVEL VALUE.   *
*        IF THE EXIT'S MESSAGE LEVEL IS LESS THAN THE MESSAGE *
*        LEVEL ASSOCIATED WITH THE MESSAGE, THE MESSAGE IS    *
*        SUPPRESSED; WHEN THE EXIT'S MESSAGE LEVEL IS GREATER *
*        THAN OR EQUAL TO THE MESSAGE LEVEL ASSOCIATED WITH   *
*        THE MESSAGE, THE MESSAGE IS ISSUED.  TEN MESSAGE     *
*        LEVEL VALUES ARE SUPPORTED BY THE EXIT:  ML00-ML09.  *
*        ASSEMBLER EQUATES ARE PROVIDED WITHIN THE EXIT TO    *
*        ASSIGN EACH MESSAGE LEVEL ITS NUMERIC EQUIVALENT.    *
*        MESSAGE LEVEL ML00 IS USED ONLY IN #PARM TABLE       *
*        ENTRIES TO INDICATE THAT THE TABLE ENTRY DOES NOT    *
*        CONTAIN A MESSAGE LEVEL OVERRIDE VALUE; IT IS THE    *
*        LOWEST VALUE.  MESSAGE LEVEL ML01 IS USED WHEN ONLY  *
*        EXECUTION ERROR MESSAGES ARE TO BE ISSUED AND ALL    *
*        DIAGNOSTIC MESSAGES ARE TO BE SUPPRESSED.  MESSAGE   *
*        LEVELS ML02-ML09 PROVIDE INCREASING DIAGNOSTIC       *
*        MESSAGE DETAIL.  THE FINAL VALUES MESSAGE, MSG099, IS*
*        THE ONLY MESSAGE ASSOCIATED WITH MESSAGE LEVEL ML02. *
*        AT MESSAGE LEVEL ML09, ALL DIAGNOSTIC MESSAGES ARE   *
*        ISSUED.  THE MESSAGE LEVEL VALUES IN BETWEEN ARE     *
*        ASSOCIATED WITH INCREASING LEVELS OF DETAIL.         *
*                                                             *
*                                                             *
*               THE DEFAULT MESSAGE LEVEL VALUE ASSEMBLED INTO*
*        THE EXIT IS "ML01".  ALTHOUGH THE MESSAGE LEVEL FOR  *
*        SOME MESSAGES CAN BE SPECIFIED VIA THE #PARM TABLE,  *
*        THOSE MESSAGES ISSUED BEFORE OR DURING THE PROCESSING*
*        OF THE #PARM TABLE CANNOT BE TIED TO THE PROCESSING  *
*        OF THE TABLE.  TO SPECIFY A MESSAGE LEVEL VALUE WHICH*
*        APPLIES TO THE ENTIRE EXIT'S PROCESSING, ENTER A     *
*                                                             *
*               //$ORTML##  DD  DUMMY                         *
*                                                             *
*        DD STATEMENT IN THE JCL FOR THE SORT STEP, WHERE "##"*
*        INDICATES THE DESIRED MESSAGE LEVEL VALUE.  THE EXIT *
*        SCANS THE ENTIRE TIOT AND USES THE "##" VALUE FROM   *
*        THE LAST "$ORTML##" DD ENTRY FOUND.  SCANNING THE    *
*        ENTIRE TIOT ALLOWS A "$ORTML##" DD CONTAINED IN A    *
*        CATALOGED PROCEDURE TO BE OVERRIDDEN BY THE EXECUTION*
*        JCL; A DD STATEMENT OVERRIDE WHOSE DDNAME DOES NOT   *
*        MATCH ANY DDNAME IN A CATALOGED PROCEDURE STEP IS    *
*        PLACED AFTER ALL OF THE DD ENTRIES FOR THE PROCEDURE *
*        JCL.                                                 *
*                                                             *
*                                                             *
***************************************************************
***                                                         ***
***>>>>>>>>>>>>>>C U I C   D I S C L A I M E R<<<<<<<<<<<<<<***
***                                                         ***
***************************************************************
***            THE INFORMATION OR MATERIAL BEING PROVIDED   ***
***      BY COMMERCIAL UNION INSURANCE COMPANY (CUIC),      ***
***      WHETHER IN HARD COPY OR MACHINE READABLE FORM,     ***
***      HAS BEEN DEVELOPED BY CUIC FOR ITS OWN PURPOSE     ***
***      AND FOR USE ON ITS OWN EQUIPMENT AND WITHIN ITS    ***
***      OWN DATA PROCESSING SYSTEM.  CUIC MAKES NO         ***
***      REPRESENTATIONS OR WARRANTIES WHATSOEVER WITH      ***
***      RESPECT TO THE INFORMATION OR MATERIAL FURNISHED   ***
***      HEREUNDER, EXPRESSED OR IMPLIED, INCLUDING BUT     ***
***      NOT LIMITED TO ANY REPRESENTATION OR WARRANTY OF   ***
***      MERCHANTABILITY OR FITNESS FOR ANY PARTICULAR USE  ***
***      OR PURPOSE OR THAT THE USE OF THE INFORMATION OR   ***
***      MATERIAL WILL NOT INFRINGE ANY PATENT, COPYRIGHT,  ***
***      TRADEMARK, OR OTHER PROPRIETARY INTEREST.  YOU     ***
***      ARE, THEREFORE, ACCEPTING THIS INFORMATION OR      ***
***      MATERIAL ON AN "AS IS" BASIS AND WILL BE USING IT  ***
***      AT YOUR OWN RISK.  NEITHER CUIC NOR ANY OF ITS     ***
***      AFFILIATES SHALL BE LIABLE WITH RESPECT TO ANY     ***
***      CLAIM, ACTION, OR DEMAND BY ANY USER OR OTHER      ***
***      PARTY (INCLUDING ANY CLAIM, ACTION, OR DEMAND FOR  ***
***      CONSEQUENTIAL DAMAGES EVEN IF CUIC HAS BEEN        ***
***      ADVISED OF THE POSSIBILITY OF SUCH DAMAGES)        ***
***      ARISING FROM THE USE OF THE INFORMATION OR THE     ***
***      MATERIALS AND CONCEPTS RELATED THERETO.            ***
***      FURTHERMORE, CUIC WILL NOT MAINTAIN, CORRECT, OR   ***
***      UPDATE THIS INFORMATION OR MATERIAL IN THE         ***
***      FUTURE.                                            ***
***                                              01/26/83   ***
***************************************************************
*                                                             *
*                                                             *
*               DIRECT INQUIRIES TO THE                       *
*        AUTHOR........                                       *
*                                                             *
*                    THOMAS J. AUBREY                         *
*                    C.U. AUTOMATION SERVICES                 *
*                    COMMERCIAL UNION INSURANCE COMPANIES     *
*                    ONE BEACON STREET - THIRTEENTH FLOOR     *
*                    BOSTON, MASSACHUSETTS  02108             *
*                    TELEPHONE: (617) 725-6208                *
*                                                             *
***************************************************************
         TITLE '$ORTPARM - PROGRAM MACROS'
         MACRO
&LABEL  #FSTR  &FSTR,              SPECIFY CHARACTER STRING            X
               &LN=                SPECIFY STRING LENGTH
.**************************************************************
.*             THIS MACRO IS DEFINES A FIXED LENGTH           *
.*       CHARACTER STRING ACCORDING TO THE CONVENTIONS        *
.*       USED IN THIS PROGRAM.                                *
.*                                                            *
.**************************************************************
.*
.*
.*       DEFINE THE GLOBAL SET SYMBOLS USED BY #FSTR.
         GBLA   &#FSTRCT           NUMBER OF #FSTR MACROS ISSUED
.*
.*
.*
.*       DEFINE THE LOCAL SET SYMBOLS USED IN #FSTR.
         LCLA   &LBLZ              USED FOR SIZE IN LABEL ROUTINE
         LCLA   &LBL#              USED FOR COUNT IN LABEL ROUTINE
         LCLC   &LBLSEQ            CONVERT CT TO CHR IN LABEL ROUTINE
         LCLC   &FLBLLBL           LABEL FOR USER REFERENCE
         LCLC   &FLBLEND           LABEL FOR END OF STRING
.*
.*
.*       INCREMENT THE #FSTR INVOCATION COUNT.
&#FSTRCT SETA &#FSTRCT+1           INCREMENT #FSTR COUNTER
.*
.**************************************************************
.*                                                            *
.*       BUILD THE INTERNAL LABLES USED                       *
.*       IN THE MACRO EXPANSION.                              *
.*                                                            *
.**************************************************************
.BLDLABL ANOP  ,
.*
.*
.*       DEVELOP THE LABEL USED FOR THE ENTRY BEGINNING
.BLDLBL  ANOP  ,
&LBL#    SETA  &#FSTRCT            SEQUENCE NUMBER FOR THE LABEL
&LBLSEQ  SETC  '&LBL#'             CONVERT NUMBER TO A CHARACTER STR
.BLDLBL1 AIF   (K'&LBLSEQ GE 3).BLDLBL2
&LBLSEQ  SETC  '0'.'&LBLSEQ'       ADD A LEADING ZERO
         AGO   .BLDLBL1            LOOP UNTIL IT'S LARGE ENOUGH
.BLDLBL2 ANOP  ,                   COMPLETE LABEL CONSTRUCTION
&LBLZ    SETA  K'&LBLSEQ           GET THE NUMBER OF DIGITS
&LBLZ    SETA  07-&LBLZ            GET THE SIZE OF THE LABEL HEADER
&FLBLLBL SETC  '#FST'(1,&LBLZ).'&LBLSEQ'.'L'    DEVELOP LABEL
&FLBLEND SETC  '#FST'(1,&LBLZ).'&LBLSEQ'.'E'    DEVELOP LABEL
.**************************************************************
.*                                                            *
.*                                                            *
.*       IF BOTH &FSTR AND &LN ARE OMITTED,                   *
.*       GENERATE AN ERROR MESSAGE.                           *
.*                                                            *
.*                                                            *
.**************************************************************
         AIF   ('&LN(1)' NE '' OR '&FSTR(1)' NE '').GENFSTR
         MNOTE 08,'#FSTR MACRO ERROR -- BOTH "FSTR" AND "LN" ARE OMITTEX
               D, AT LEAST ONE IS REQUIRED'
         AIF   ('&LABEL' EQ '').MEXIT
&LABEL   DS    0C                  PREVENT FURTHER ASSEMBLY ERRORS
         SPACE 1
.MEXIT   MEXIT
.**************************************************************
.*                                                            *
.*                                                            *
.*       GENERATE THE FIXED LENGTH STRING                     *
.*                                                            *
.*                                                            *
.**************************************************************
.GENFSTR ANOP  ,
         DC    Y(&FLBLEND-&FLBLLBL)  STRING LENGTH
.*
.*
.*       DEVELOP THE CHARACTER STRING CONSTANT
.FSTR01  AIF   ('&LN(1)' EQ '').FSTR05       IF NO &LN VALUE
         AIF   ('&FSTR(1)'  EQ '').FSTR04    IF &FSTR NOT SPEC
         AIF   ('&FSTR(1)'(1,1) EQ '''').FSTR03
.*
.*       &FSTR DOES NOT BEGIN WITH A QUOTE, AND &LN IS SPECIFIED
.FSTR02  ANOP
&FLBLLBL DC    CL(&LN(1))'&FSTR(1)' DEFINE STRING
         AGO   .FSTR08
.*
.*       &FSTR BEGINS WITH A QUOTE, AND &LN IS SPECIFIED
.FSTR03  ANOP
&FLBLLBL DC    CL(&LN(1))&FSTR(1)   DEFINE STRING
         AGO   .FSTR08
.*
.*       &FSTR IS OMITTED, AND &LN IS SPECIFIED
.FSTR04  ANOP
&FLBLLBL DC    CL(&LN(1))' '        DEFINE STRING
         AGO   .FSTR08
.*
.*
.*       &LN IS OMITTED, CHECK FOR QUOTES AROUND &FSTR
.FSTR05  AIF   ('&FSTR(1)'(1,1) EQ '''').FSTR07
.*
.*       &FSTR DOES NOT BEGIN WITH A QUOTE, AND &LN IS OMITTED
.FSTR06  ANOP
&FLBLLBL DC    C'&FSTR(1)'          DEFINE STRING
         AGO   .FSTR08
.*
.*       &FSTR BEGINS WITH A QUOTE, AND &LN IS OMITTED
.FSTR07  ANOP
&FLBLLBL DC    C&FSTR(1)            DEFINE STRING
         AGO   .FSTR08
.*
.*
.*       DEFINE THE ENDING LABEL FOR LENGTH STRINGS
.FSTR08  ANOP
&FLBLEND DS    0C                   DEFINE MAXIMUM END OF STRING
         AIF   ('&LABEL' EQ '').NOULBL
&LABEL   EQU   &FLBLLBL,&FLBLEND-&FLBLLBL,C'F'  USER LABEL FOR STRING
.NOULBL  ANOP   ,
         SPACE 1
         MEND
         EJECT  ,
         MACRO
&LABEL  #PATCH  &BYTES             GENERATE PATCH AREA
.**************************************************************
.*             THIS MACRO IS A GENERAL-PURPOSE MACRO          *
.*       WRITTEN BY COMMERCIAL UNION TO FACILITATE THE        *
.*       ADDITION OF A PATCH AREA TO THE END OF AN ASSEMBLER  *
.*       CONTROL SECTION.  TO USE THIS MACRO, SIMPLY CODE     *
.*       THE NUMBER OF BYTES WANTED IN THE PATCH AREA.        *
.*       THE NUMBER OF BYTES IS ROUNDED UP TO A HALFWORD      *
.*       BOUNDARY AND SCON'S ARE GENERATED TO FILL THE PATCH  *
.*       AREA.  BECAUSE SCON'S GENERATE ADDRESSES IN          *
.*       BASE-DISPLACEMENT FORM, THE SUPERZAP PROCESS         *
.*       IS EASED.                                            *
.**************************************************************
.*
.*
.*       DEFINE THE LOCAL SET SYMBOLS USED IN THIS MACRO
         LCLA   &LENGTH            COMPUTED LENGTH OF PATCH AREA
         LCLA   &CTR               LOOP CONTROL FOR SCON GENERATION
         LCLA   &CTRLIM            NUMBER OF S-CONS TO GENERATE
         LCLA   &CMNTSIZ           SIZE OF HEADER COMMENT
         LCLC   &COMMENT
.*
.*       COMPUTE THE LENGTH OF THE PATCH AREA
&LENGTH  SETA  128                 DEFAULT PATCH AREA LENGTH
         AIF   (T'&BYTES(1) NE 'N').BYTDFLT  VALUE MUST BE NUMERIC
         AIF   (&BYTES(1) LT 32).BYTDFLT     AT LEAST 32 BYTES NEEDED
&LENGTH  SETA  &BYTES(1)
         AIF   (&LENGTH LE 512).BYTDFLT      AT MOST 512 BYTES ALLOWED
&LENGTH  SETA  512
.BYTDFLT ANOP  ,
&LENGTH  SETA  ((&LENGTH+1)/2)*2             ROUND UP TO MULTIPLE OF 2
.*
.*       COMPUTE THE NUMBER OF S-CONS REQUIRED TO FILL THE PATCH AREA
&CTRLIM  SETA  &LENGTH/2
.*
.*
.*       ASSEMBLE A COMMENT PRECEEDING THE PATCH AREA
&COMMENT SETC  '&LENGTH BYTE PATCH AREA FOR &SYSECT FOLLOWS THIS COMMENX
               T'
&CMNTSIZ SETA  K'&COMMENT          NUMBER OF BYTES IN THE COMMENT
&CMNTSIZ SETA  ((&CMNTSIZ+1)/2)*2  ROUND UP TO EVEN NUMBER OF BYTES
         AIF   (K'&COMMENT EQ &CMNTSIZ).NOBLNK
&COMMENT SETC  ' '.'&COMMENT'      ADD A BLANK ON THE FRONT
.NOBLNK  ANOP  ,
         DS    0H                  BOUNDARY ALIGN
         DC    C'&COMMENT'
.*
.*
.*       GENERATE THE PATCH AREA
&LABEL   DC    S(*)                PATCH AREA DEFINITION
&CTR     SETA  1                   1 SCON HAS BEEN DEFINED
.LOOP1   ANOP
&CTR     SETA  &CTR+1              INCREMENT LOOP CONTROL COUNTER
         AIF   (&CTR GT &CTRLIM).LOOP9       IF SCON GENERATION DONE
         DC    S(*)
         AGO   .LOOP1              LOOP FOR NEXT SCON
.LOOP9   ANOP
         MEND
         EJECT  ,
         MACRO
&LABEL  #VSTR  &VSTR,              SPECIFY CHARACTER STRING            X
               &MAXLN=             SPECIFY MAXIMUM STRING LENGTH
.**************************************************************
.*             THIS MACRO IS DEFINES A VARIABLE LENGTH        *
.*       CHARACTER STRING ACCORDING TO THE CONVENTIONS        *
.*       USED IN THIS PROGRAM.                                *
.*                                                            *
.**************************************************************
.*
.*
.*       DEFINE THE GLOBAL SET SYMBOLS USED BY #VSTR.
         GBLA   &#VSTRCT           NUMBER OF #VSTR MACROS ISSUED
.*
.*
.*
.*       DEFINE THE LOCAL SET SYMBOLS USED IN #VSTR.
         LCLA   &LBLZ              USED FOR SIZE IN LABEL ROUTINE
         LCLA   &LBL#              USED FOR COUNT IN LABEL ROUTINE
         LCLC   &LBLSEQ            CONVERT CT TO CHR IN LABEL ROUTINE
         LCLC   &VLBLLBL           LABEL FOR USER REFERENCE
         LCLC   &VLBLSTR           LABEL FOR START OF STRING
         LCLC   &VLBLEND           LABEL FOR MAX     END OF STRING
         LCLC   &VLBLCUR           LABEL FOR CURRENT END OF STRING
.*
.*
.*       INCREMENT THE #VSTR INVOCATION COUNT.
&#VSTRCT SETA &#VSTRCT+1           INCREMENT #VSTR COUNTER
.*
.**************************************************************
.*                                                            *
.*       BUILD THE INTERNAL LABELS                            *
.*       USED IN THE MACRO EXPANSION.                         *
.*                                                            *
.**************************************************************
.BLDLABL ANOP  ,
.*
.*
.*       DEVELOP THE LABEL USED FOR THE ENTRY BEGINNING
.BLDLBL  ANOP  ,
&LBL#    SETA  &#VSTRCT            SEQUENCE NUMBER FOR THE LABEL
&LBLSEQ  SETC  '&LBL#'             CONVERT NUMBER TO A CHARACTER STR
.BLDLBL1 AIF   (K'&LBLSEQ GE 3).BLDLBL2
&LBLSEQ  SETC  '0'.'&LBLSEQ'       ADD A LEADING ZERO
         AGO   .BLDLBL1            LOOP UNTIL IT'S LARGE ENOUGH
.BLDLBL2 ANOP  ,                   COMPLETE LABEL CONSTRUCTION
&LBLZ    SETA  K'&LBLSEQ           GET THE NUMBER OF DIGITS
&LBLZ    SETA  07-&LBLZ            GET THE SIZE OF THE LABEL HEADER
&VLBLLBL SETC  '#VST'(1,&LBLZ).'&LBLSEQ'.'L'    DEVELOP LABEL
&VLBLSTR SETC  '#VST'(1,&LBLZ).'&LBLSEQ'.'S'    DEVELOP LABEL
&VLBLCUR SETC  '#VST'(1,&LBLZ).'&LBLSEQ'.'C'    DEVELOP LABEL
&VLBLEND SETC  '#VST'(1,&LBLZ).'&LBLSEQ'.'E'    DEVELOP LABEL
.**************************************************************
.*                                                            *
.*                                                            *
.*       IF BOTH &VSTR AND &MAXLN ARE OMITTED,                *
.*       GENERATE AN ERROR MESSAGE.                           *
.*                                                            *
.*                                                            *
.**************************************************************
         AIF   ('&MAXLN(1)' NE '' OR '&VSTR(1)' NE '').GENVSTR
         MNOTE 08,'#VSTR MACRO ERROR -- BOTH "VSTR" AND "MAXLN" ARE OMIX
               TTED, AT LEAST ONE IS REQUIRED'
         AIF   ('&LABEL' EQ '').MEXIT
&LABEL   DS    0C                  PREVENT FURTHER ASSEMBLY ERRORS
         SPACE 1
.MEXIT   MEXIT
.**************************************************************
.*                                                            *
.*                                                            *
.*       GENERATE THE VARIABLE LENGTH STRING                  *
.*                                                            *
.*                                                            *
.**************************************************************
.GENVSTR ANOP  ,
         DC    Y(&VLBLEND-&VLBLSTR)          MAXIMUM STRING LENGTH
&VLBLLBL DC    Y(&VLBLCUR-&VLBLSTR)          CURRENT STRING LENGTH
         DC   0Y(&VLBLEND-&VLBLCUR)  THIS INSTR FLAGGED IF             X
                                     CURRENT LENGTH > MAXIMUM LENGTH
.*
.*
.*       DEVELOP THE CHARACTER STRING CONSTANT
.VSTR01  AIF   ('&MAXLN(1)' EQ '').VSTR05    IF NO &MAXLN VALUE
         AIF   ('&VSTR(1)'  EQ '').VSTR04    IF &VSTR NOT SPEC
         AIF   ('&VSTR(1)'(1,1) EQ '''').VSTR03
.*
.*       &VSTR DOES NOT BEGIN WITH A QUOTE, AND &MAXLN IS SPECIFIED
.VSTR02  ANOP
&VLBLSTR DC    C'&VSTR(1)'          DEFINE CURRENT STRING
&VLBLCUR DS    0C                   DEFINE END OF CURRENT STRING
         ORG   &VLBLSTR             OVERLAY CURRENT STRING
         DC    CL(&MAXLN(1))'&VSTR(1)'      MAX LN STRING
         AGO   .VSTR08
.*
.*       &VSTR BEGINS WITH A QUOTE, AND &MAXLN IS SPECIFIED
.VSTR03  ANOP
&VLBLSTR DC    C&VSTR(1)            DEFINE CURRENT STRING
&VLBLCUR DS    0C                   DEFINE END OF CURRENT STRING
         ORG   &VLBLSTR             OVERLAY CURRENT STRING
         DC    CL(&MAXLN(1))&VSTR(1)        MAX LN STRING
         AGO   .VSTR08
.*
.*       &VSTR IS OMITTED, AND &MAXLN IS SPECIFIED
.VSTR04  ANOP
&VLBLSTR DS    0C                   DEFINE CURRENT STRING START
&VLBLCUR DS    0C                   DEFINE END OF CURRENT STRING
         DC    CL(&MAXLN(1))' '            MAX LN STRING
         AGO   .VSTR08
.*
.*
.*       &MAXLN IS OMITTED, CHECK FOR QUOTES AROUND &VSTR
.VSTR05  AIF   ('&VSTR(1)'(1,1) EQ '''').VSTR07
.*
.*       &VSTR DOES NOT BEGIN WITH A QUOTE, AND &MAXLN IS OMITTED
.VSTR06  ANOP
&VLBLSTR DC    C'&VSTR(1)'          DEFINE CURRENT STRING
&VLBLCUR DS    0C                   DEFINE END OF CURRENT STRING
         AGO   .VSTR08
.*
.*       &VSTR BEGINS WITH A QUOTE, AND &MAXLN IS OMITTED
.VSTR07  ANOP
&VLBLSTR DC    C&VSTR(1)            DEFINE CURRENT STRING
&VLBLCUR DS    0C                   DEFINE END OF CURRENT STRING
         AGO   .VSTR08
.*
.*
.*       DEFINE THE ENDING LABEL FOR MAXIMUM LENGTH STRINGS
.VSTR08  ANOP
&VLBLEND DS    0C                   DEFINE MAXIMUM END OF STRING
         AIF   ('&LABEL' EQ '').NOULBL
&LABEL   EQU   &VLBLLBL,&VLBLEND-&VLBLLBL,C'V'  USER LABEL FOR STRING
.NOULBL  ANOP   ,
         SPACE 1
         MEND
         EJECT  ,
         MACRO
&LABEL   SETAMODE &REG1,&REG2, NON-ZERO WORK REGISTER(S)               X
               &AMODE=,        SPECIFY ADDRESSING MODE                 X
               &AMASK=,        ADDR OF FULLWORD X'80000000'            X
               &S370=MVS,      S/370 SYSTEM EXECUTION CAPABILITY       X
               &BALR=BALR,     SPECIFY OPCODE FOR BALR/BASR            X
               &ASMHV2=YES,    IF ASM H V2 IS BEING USED               X
               &CVTMAP=YES     IF MVS/XA CVT MAP IS IN PROGRAM
.**************************************************************
.*                                                            *
.*             S E T A M O D E   V E R S I O N   02.00        *
.*                                                            *
.*             THIS  IS A GENERAL-PURPOSE MACRO WRITTEN       *
.*       AT COMMERCIAL UNION TO FACILITATE SWITCHING          *
.*       BETWEEN 24-BIT AND 31-BIT ADDRESSING MODE IN         *
.*       MVS/XA.  THIS MACRO IS CAPABLE OF GENERATING         *
.*       CODE THAT CAN EXECUTE ON BOTH MVS/370 AND            *
.*       MVS/XA SYSTEMS, BUT IT CAN ALSO GENERATE A           *
.*       SHORT EXPANSION, NOT INCLUDING THE TEST FOR          *
.*       SYSTEM TYPE, WHICH WILL EXECUTE ONLY ON AN XA        *
.*       SYSTEM (IN EITHER 24-BIT OR 31-BIT MODE).            *
.*       ASSEMBLER H VERSION 2 IS REQUIRED TO ASSEMBLE        *
.*       THIS MACRO (UNLESS ASMHV2=NO IS SPECIFIED),          *
.*       BECAUSE THE EXPANSION INCLUDES A "BSM"               *
.*       INSTRUCTION WHICH IS NEW FOR XA AND IS               *
.*       RECOGNIZED ONLY BY ASSEMBLER H VERSION 2, OR A       *
.*       COMPARABLE ASSEMBLER.                                *
.*                                                            *
.*                                                            *
.*       WHEN &S370=NO IS SPECIFIED, &REG1 SPECIFIES A        *
.*       NON-ZERO WORK REGISTER THAT IS USED TO LOAD          *
.*       THE AMODE VALUE AND BRANCH ADDRESS FOR THE BSM       *
.*       INSTRUCTION.  &REG2 IS NOT USED WHEN &S370=NO,       *
.*       AND AN MNOTE(00) WARNING MESSAGE WILL BE             *
.*       GENERATED BY THIS MACRO IF &REG2 IS USED WITH        *
.*       &S370=NO.                                            *
.*                                                            *
.*       WHEN &S370=MVS, &REG1 AND &REG2 SPECIFY WORK         *
.*       REGISTERS (NOT ZERO) THAT ARE USED TO SET UP         *
.*       VALUES FOR THE BSM INSTRUCTION IN MVS/XA.  THE       *
.*       GENERATED BSM INSTRUCTION SAVES THE CURRENT          *
.*       AMODE VALUE IN THE HIGH-ORDER BIT OF &REG1.          *
.*       WHEN EXECUTING ON AN MVS/370 SYSTEM, A BALR          *
.*       INSTRUCTION IS EXECUTED INSTEAD OF BSM;              *
.*       BECAUSE THE ILC FOR BALR IS B'01', BALR CLEARS       *
.*       THE HIGH-ORDER BIT OF &REG1 (AS IF AMODE 24          *
.*       HAD BEEN IN EFFECT).  IF TWO REGISTERS AREN'T        *
.*       AVAILABLE, THE SECOND REGISTER CAN BE OMITTED;       *
.*       OMITTING &REG2 WILL INCREASE THE LENGTH OF THE       *
.*       GENERATED CODE, BUT THE RESULT WILL BE THE           *
.*       SAME.  WHEN TWO REGISTERS ARE SPECIFIED, THEY        *
.*       MUST DESIGNATE DIFFERENT, NON-ZERO, REGISTERS.       *
.*                                                            *
.*                                                            *
.*       THREE VALUES ARE SUPPORTED FOR &AMODE:               *
.*                                                            *
.*             -"24"      SETS AMODE 24, AND SAVES THE        *
.*                        CURRENT AMODE IN THE                *
.*                        HIGH-ORDER BIT OF &REG1;            *
.*                                                            *
.*             -"31"      SETS AMODE 31, AND SAVES THE        *
.*                        CURRENT AMODE IN THE                *
.*                        HIGH-ORDER BIT OF &REG1;            *
.*                                                            *
.*             -"RESET"   USES THE AMODE BIT THAT WAS         *
.*                        SAVED IN THE HIGH-ORDER BIT         *
.*                        OF &REG1 TO SET THE AMODE;          *
.*                        THE CURRENT AMODE IS SAVED IN       *
.*                        THE HIGH-ORDER BIT OF &REG1;        *
.*                                                            *
.*                                                            *
.*       THE CODE GENERATED BY THIS MACRO REQUIRES            *
.*       ACCESS TO A FULLWORD OF X'80000000' FOR              *
.*       EXTRACTING AND MANIPULATING THE AMODE BIT IN         *
.*       THE WORK REGISTERS.  IF THE USER DOES NOT            *
.*       SUPPLY THE ADDRESS OF SUCH A FULLWORD USING          *
.*       THE AMASK= KEYWORD, A FULLWORD CONSTANT IS           *
.*       GENERATED INLINE.  TO SAVE ON STORAGE, THE           *
.*       USER CAN SUPPLY THE ADDRESS OF SUCH A FULLWORD       *
.*       TO BE USED BY THE MACRO EXPANSION.  IF THE           *
.*       USER PROVIDES SUCH AN ADDRESS, USING THE             *
.*       AMASK= KEYWORD, THE INLINE FULLWORD IS NOT           *
.*       GENERATED, SAVING FOUR BYTES WITH EACH USE OF        *
.*       THIS MACRO.  THE SYMBOL SUPPLIED VIA AMASK=          *
.*       MUST DESIGNATE THE ADDRESS OF A FULLWORD IN          *
.*       STORAGE CONTAINING THE VALUE X'80000000', OR         *
.*       BE THE VALUE IN REGISTER NOTATION (DOUBLE            *
.*       ENCLOSING PARENTHESES) OF A GENERAL REGISTER         *
.*       CONTAINING THE VALUE X'80000000'.                    *
.*                                                            *
.*                                                            *
.*       WHEN S370=MVS, THE GENERATED CODE INTERROGATES       *
.*       THE CVT TO DETERMINE WHETHER IT IS EXECUTING         *
.*       ON MVS/370 OR MVS/XA.  IF THE MVS/XA CVT             *
.*       MAPPING MACRO IS NOT EXPANDED IN THE ASSEMBLY        *
.*       CONTAINING SETAMODE, THE USER SHOULD SPECIFY         *
.*       CVTMAP=NO ON THE SETAMODE MACRO.  THE                *
.*       GENERATED CODE WILL THEN USE HEXADECIMAL             *
.*       VALUES FOR "CVTDCB" AND "CVTMVSE" INSTEAD OF         *
.*       THE SYMBOLS FROM THE CVT MACRO.  THE SETAMODE        *
.*       DEFAULT IS TO USE THE SYMBOLS (&CVTMAP=YES) SO       *
.*       THAT THEY APPEAR ON THE ASSEMBLY CROSS               *
.*       REFERENCE LISTING.  THE CVT MAPPING MACRO IS         *
.*       IN SYS1.AMODGEN ON THE DLIB VOLUME, AND IS           *
.*       CALLED "CVT".                                        *
.*                                                            *
.*                                                            *
.**************************************************************
.**************************************************************
.**                                                         ***
.**>>>>>>>>>>>>>>C U I C   D I S C L A I M E R<<<<<<<<<<<<<<***
.**                                                         ***
.**************************************************************
.**            THE INFORMATION OR MATERIAL BEING PROVIDED   ***
.**      BY COMMERCIAL UNION INSURANCE COMPANY (CUIC),      ***
.**      WHETHER IN HARD COPY OR MACHINE READABLE FORM,     ***
.**      HAS BEEN DEVELOPED BY CUIC FOR ITS OWN PURPOSE     ***
.**      AND FOR USE ON ITS OWN EQUIPMENT AND WITHIN ITS    ***
.**      OWN DATA PROCESSING SYSTEM.  CUIC MAKES NO         ***
.**      REPRESENTATIONS OR WARRANTIES WHATSOEVER WITH      ***
.**      RESPECT TO THE INFORMATION OR MATERIAL FURNISHED   ***
.**      HEREUNDER, EXPRESSED OR IMPLIED, INCLUDING BUT     ***
.**      NOT LIMITED TO ANY REPRESENTATION OR WARRANTY OF   ***
.**      MERCHANTABILITY OR FITNESS FOR ANY PARTICULAR USE  ***
.**      OR PURPOSE OR THAT THE USE OF THE INFORMATION OR   ***
.**      MATERIAL WILL NOT INFRINGE ANY PATENT, COPYRIGHT,  ***
.**      TRADEMARK, OR OTHER PROPRIETARY INTEREST.  YOU     ***
.**      ARE, THEREFORE, ACCEPTING THIS INFORMATION OR      ***
.**      MATERIAL ON AN "AS IS" BASIS AND WILL BE USING IT  ***
.**      AT YOUR OWN RISK.  NEITHER CUIC NOR ANY OF ITS     ***
.**      AFFILIATES SHALL BE LIABLE WITH RESPECT TO ANY     ***
.**      CLAIM, ACTION, OR DEMAND BY ANY USER OR OTHER      ***
.**      PARTY (INCLUDING ANY CLAIM, ACTION, OR DEMAND FOR  ***
.**      CONSEQUENTIAL DAMAGES EVEN IF CUIC HAS BEEN        ***
.**      ADVISED OF THE POSSIBILITY OF SUCH DAMAGES)        ***
.**      ARISING FROM THE USE OF THE INFORMATION OR THE     ***
.**      MATERIALS AND CONCEPTS RELATED THERETO.            ***
.**      FURTHERMORE, CUIC WILL NOT MAINTAIN, CORRECT, OR   ***
.**      UPDATE THIS INFORMATION OR MATERIAL IN THE         ***
.**      FUTURE.                                            ***
.**                                              01/26/83   ***
.**************************************************************
.*                                                            *
.*              DIRECT INQUIRIES TO THE                       *
.*       AUTHOR........                                       *
.*                                                            *
.*                   THOMAS J. AUBREY                         *
.*                   C.U. AUTOMATION SERVICES                 *
.*                   COMMERCIAL UNION INSURANCE COMPANIES     *
.*                   ONE BEACON STREET - THIRTEENTH FLOOR     *
.*                   BOSTON, MASSACHUSETTS  02108             *
.*                   TELEPHONE: (617) 725-6208                *
.*                                                            *
.**************************************************************
.*************************************************
.*                                               *
.*       DEFINE THE SET SYMBOLS USED IN THIS     *
.*       MACRO, AND ASSIGN INITIAL VALUES        *
.*       TO THEM:                                *
.*                                               *
.*************************************************
.*
.*
         LCLB  &R2AVAIL        IF SECOND REGISTER AVAILABLE
         LCLB  &ACONGEN        IF ADDRESS CONSTANT IS TO BE GEN'ED
         LCLB  &AMSKGEN        IF X'80000000' IS TO BE INLINE
         LCLB  &OFSTGEN        IF Y(IHB&IX.S-IHB&IX.B) TOBE GEN'ED
         LCLC  &IX             INDEX VALUE FOR LABELS
         LCLC  &AMSKLBL        LABEL FOR FULLWORD X'80000000'
         LCLC  &AR             "R" IF X'80000000' IS IN A REGISTER
         LCLC  &R1,&R2         REGISTER VALUES
         LCLC  &LB,&LS         BALR/BSM LABEL VALUES
         LCLC  &LU             USER'S LABEL
         LCLC  &AMD            ADDRESSING MODE VALUE
         LCLC  &AMDHEX         ADDRESSING MODE FOR ACON
&IX      SETC  '&SYSNDX'       ASSIGN LABEL INDEX VALUE
&LB      SETC  'IHB&IX.B'      ASSIGN LABEL VALUE
&LS      SETC  'IHB&IX.S'      ASSIGN LABEL VALUE
&LU      SETC  '&LABEL'        ASSIGN LABEL VALUE
.*
.*       DETERMINE THE LABEL VALUE FOR &AMSKLBL:
&AMSKLBL SETC  'IHB&IX.M'      ASSIGN DEFAULT LABEL FOR AMASK
         AIF  ('&AMASK(2)' EQ '').NOAM12
&AMSKLBL SETC  '&AMASK(2)'     GEN IT NOW, USE IT LATER
.NOAM12  ANOP   ,
&AMSKGEN SETB  1               GENERATE CONSTANT INLINE
&AR      SETC  ''              CONSTANT IS IN STORAGE
         AIF  ('&AMASK(1)' EQ '').BYAM1    IF ADDR NOT SUPPL
&AMSKLBL SETC  '&AMASK(1)'     ASSIGN LABEL FOR AMASK
&AMSKGEN SETB  0               DON'T GENERATE CONSTANT INLINE
.*       IF &AMASK VALUE IS IN REGISTER NOTATION:
         AIF  ('&AMSKLBL'(1,1) NE '(' OR                               X
               '&AMSKLBL'(K'&AMSKLBL,1) NE ')').BYAM1  IF IN STORAGE
&AR      SETC  'R'                           CONSTANT IS IN A REGISTER
&AMSKLBL SETC  '&AMSKLBL'(2,K'&AMSKLBL-2)    DROP PARENTHESES
.BYAM1   ANOP   ,
.*
.*       DETERMINE THE REGISTER VALUES TO USE,
.*       AND SET &R2AVAIL TO INDICATE WHETHER
.*       A SECOND REGISTER IS AVAILABLE:
&R1      SETC  '&REG1(1)'      FIRST  REGISTER VALUE
&R2      SETC  '&R1'           USE FIRST REGISTER TWICE
&R2AVAIL SETB  0               ASSUME SECOND REGISTER NOT AVAILABLE
&OFSTGEN SETB  1               ASSUME OFFSET TO BE GENERATED
         AIF  ('&S370(1)' NE 'NO').TSR2
&OFSTGEN SETB  0               DON'T NEED OFFSET WHEN S370=NO
.TSR2    AIF  ('&REG2(1)' EQ '' OR '&REG2(1)' EQ '&R1').BYR2
         AIF  ('&S370(1)' NE 'NO').OKR2
         MNOTE 00,'REG2 SPECIFICATION ''&REG2(1)'' IS NOT USED WHEN S37X
               0=NO, REGISTER VALUE HAS BEEN IGNORED'
         AGO   .BYR2
.OKR2    ANOP   ,
&R2      SETC  '&REG2(1)'      SECOND REGISTER VALUE
&R2AVAIL SETB  1               SECOND REGISTER IS AVAILABLE
&OFSTGEN SETB  0               DON'T NEED OFFSET WHEN TWO REGS AVAIL
.BYR2    ANOP   ,
.*
.*
.*       VALIDATE THE AMODE SPECIFICATION, AND SET LOCAL SYMBOL
.*       VALUES BASED ON THE AMODE/S370 SPECIFICATIONS:
         AIF   ('&AMODE(1)' EQ '24').AMD24
         AIF   ('&AMODE(1)' EQ '31').AMD31
         AIF   ('&AMODE(1)' EQ 'RESET' OR '&AMODE(1)' EQ 'RS').AMDRS
         MNOTE 08,'AMODE SPECIFICATION ''&AMODE(1)'' INVALID, SUPPORTEDX
               VALUES ARE 24, 31, AND RESET'
         MNOTE *,'AMODE=31 HAS BEEN ASSUMED'
         AGO   .AMD31
.AMD24   ANOP   ,                    AMODE=24
&AMD     SETC  '24'
&AMDHEX  SETC  ''
&ACONGEN SETB  1               GENERATE ADDRESS CONSTANT
         AIF  ('&S370(1)' NE 'NO').AMDZZ
&LS      SETC  ''                    LABEL IS NOT NEEDED
&ACONGEN SETB  0               ADDRESS CONSTANT NOT NEEDED
         AGO   .AMDZZ
.AMD31   ANOP   ,                    AMODE=31
&AMD     SETC  '31'
&AMDHEX  SETC  ''
&ACONGEN SETB  1               GENERATE ADDRESS CONSTANT
         AIF  ('&S370(1)' NE 'NO').AMDZZ
&LS      SETC  ''                    LABEL IS NOT NEEDED
&AMDHEX  SETC  '+X''80000000'''
         AGO   .AMDZZ
.AMDRS   ANOP   ,                    AMODE=RESET
&AMD     SETC  'RS'
&AMDHEX  SETC  ''
&ACONGEN SETB  1               GENERATE ADDRESS CONSTANT
         AIF  ('&S370(1)' NE 'NO').AMDZZ
&LS      SETC  ''                    LABEL IS NOT NEEDED
         AGO   .AMDZZ
.*
.AMDZZ ANOP     ,
.*************************************************
.*                                               *
.*       GENERATE THE IN-LINE EXPANSION.         *
.*                                               *
.*************************************************
.*
.*
.*-----------------------------------------------------
.*                                                    
.*       DEPENDING ON THE &AMODE AND &S370            
.*       SPECIFICATIONS, GENERATE THE INSTRUCTIONS    
.*       TO PUT THE ADDRESSING MODE VALUE INTO THE    
.*       HIGH-ORDER BIT OF &REG1.  IF &S370=NO WAS    
.*       SPECIFIED, THE LOW-ORDER 31 BITS OF &REG1    
.*       ARE SET TO THE BRANCH ADDRESS FOR BSM.       
.*       IF &S370=MVS, THE LOW-ORDER 31 BITS OF       
.*       &REG1 ARE SET TO ZERO, SO THAT AN OFFSET     
.*       VALUE CAN BE PLACED THERE LATER IN THE       
.*       EXPANSION.                                   
.*                                                    
.*-----------------------------------------------------
         AIF   ('&AMD' EQ '24').GAMD24
         AIF   ('&AMD' EQ '31').GAMD31
         AIF   ('&AMD' EQ 'RS').GAMDRS
.GAMD24  AIF   ('&S370(1)' EQ 'NO').GAMD24X
         AGO   .GAMD24S
.GAMD31  AIF   ('&S370(1)' EQ 'NO').GAMD31X
         AGO   .GAMD31S
.GAMDRS  AIF   ('&S370(1)' EQ 'NO').GAMDRSX
         AGO   .GAMDRSS
.GAMD24S ANOP   ,        ----------->AMODE=24,S370=MVS<--------
&LU      XR    &R1,&R1              CLEAR ADDR/SET  BIT FOR AMODE=24
         AGO   .GAMDZZ
.GAMD24X ANOP   ,        ----------->AMODE=24,S370=NO<---------
&LU      LA    &R1,IHB&IX.N         LOAD  ADDR AND  BIT FOR AMODE=24
         AGO   .GAMDZZ
.GAMD31S ANOP   ,        ----------->AMODE=31,S370=MVS<--------
&LU      L&AR  &R1,&AMSKLBL         CLEAR ADDR/SET  BIT FOR AMODE=31
         AGO   .GAMDZZ
.GAMD31X ANOP   ,        ----------->AMODE=31,S370=NO<---------
&LU      L     &R1,IHB&IX.A         LOAD  ADDR AND  BIT FOR AMODE=31
         AGO   .GAMDZZ
.GAMDRSS ANOP   ,        ----------->AMODE=RESET,S370=MVS<-----
&LU      N&AR  &R1,&AMSKLBL         CLEAR ADDR/SAVE BIT FOR AMODE=RESET
         AGO   .GAMDZZ
.GAMDRSX ANOP   ,        ----------->AMODE=RESET,S370=NO<------
&LU      N&AR  &R1,&AMSKLBL         CLEAR ADDR/SAVE BIT FOR AMODE=RESET
         O     &R1,IHB&IX.A         PACK BR ADDR W/ AMODE BIT
         AGO   .GAMDZZ
.GAMDZZ  ANOP   ,
.*
.*-----------------------------------------------------
.*                                                    
.*       IF S370=NO WAS REQUESTED, PROCEED            
.*       IMMEDIATELY TO GENERATE THE BSM              
.*       INSTRUCTION:                                 
.*                                                    
.*-----------------------------------------------------
         AIF  ('&S370(1)' EQ 'NO').GENBSM
.*
.*
.*-----------------------------------------------------
.*                                                    
.*       IF MVS/370 EXECUTABILITY WAS REQUESTED,      
.*       DETERMINE THE TYPE OF SYSTEM ON WHICH WE     
.*       ARE EXECUTING BY TESTING THE CVTMVSE BIT     
.*       IN THE CVT.  THE RESULT OF THIS TEST WILL    
.*       BE THE PLACING OF AN OFFSET VALUE INTO       
.*       THE LOW-ORDER 31 BITS OF &REG1.    THE       
.*       OFFSET VALUE WILL BE USED FOR BRANCHING      
.*       TO THE MODE CHANGE INSTRUCTION DEPENDING     
.*       ON WHETHER THE EXECUTING SYSTEM IS           
.*       MVS/370 OR MVS/XA.                           
.*                                                    
.*-----------------------------------------------------
.*
         AIF   (&R2AVAIL).R2CVT
.R1CVT   AIF   ('&CVTMAP(1)' EQ 'NO').R1CVTN
         AGO   .R1CVTY
.R2CVT   AIF   ('&CVTMAP(1)' EQ 'NO').R2CVTN
         AGO   .R2CVTY
.*
.*       SINGLE REGISTER, CVT MAP AVAILABLE:
.R1CVTY  X     &R1,CVTPTR                  -> CVT                      X
                                           (POSSIBLY INVERT AMODE BIT)
         TM    CVTDCB-CVT(&R1),CVTMVSE     IN MVS/XA SYSTEM ??
         BZ    IHB&IX.Y                    BRANCH IF MVS/370
IHB&IX.X X     &R1,CVTPTR                  CLEAR CVT ADDRESS,          X
                                           (AND RESTORE AMODE BIT)
         AH    &R1,IHB&IX.O         PACK OFFSET WITH AMODE BIT
         B     IHB&IX.Z                    W/ OFFSET IN REGISTER
IHB&IX.Y X     &R1,CVTPTR                  CLEAR CVT ADDRESS,          X
                                           (AND RESTORE AMODE BIT)
IHB&IX.Z DS   0H                    END OF SYSTEM TYPE DETERMINATION
         AGO   .CVTEND
.*
.*       SINGLE REGISTER, NO CVT MAP:
.R1CVTN  X     &R1,16                      -> CVT                      X
                                           (POSSIBLY INVERT AMODE BIT)
         TM    X'74'(&R1),X'80'            IN MVS/XA SYSTEM ??
         BZ    IHB&IX.Y                    BRANCH IF MVS/370
IHB&IX.X X     &R1,16                      CLEAR CVT ADDRESS,          X
                                           (AND RESTORE AMODE BIT)
         AH    &R1,IHB&IX.O         PACK OFFSET WITH AMODE BIT
         B     IHB&IX.Z                    OFFSET IS IN REGISTER
IHB&IX.Y X     &R1,16                      CLEAR CVT ADDRESS,          X
                                           (AND RESTORE AMODE BIT)
IHB&IX.Z DS   0H                    END OF SYSTEM TYPE DETERMINATION
         AGO   .CVTEND
.*
.*       DOUBLE REGISTER, CVT MAP AVAILABLE:
.R2CVTY  L     &R2,CVTPTR                  -> CVT
         TM    CVTDCB-CVT(&R2),CVTMVSE     IN MVS/XA SYSTEM ??
         LR    &R2,&R1                     COPY AMODE  VALUE
         BZ    IHB&IX.Z                    BRANCH IF MVS/370
         LA    &R1,IHB&IX.S-IHB&IX.B       OFFSET TO BSM INSTR
IHB&IX.Z DS   0H                    END OF SYSTEM TYPE DETERMINATION
         AGO   .CVTEND
.*
.*       DOUBLE REGISTER, NO CVT MAP:
.R2CVTN  L     &R2,16                      -> CVT
         TM    X'74'(&R2),X'80'            IN MVS/XA SYSTEM ??
         LR    &R2,&R1                     COPY AMODE  VALUE
         BZ    IHB&IX.Z                    BRANCH IF MVS/370
         LA    &R1,IHB&IX.S-IHB&IX.B       OFFSET TO BSM INSTR
IHB&IX.Z DS   0H                    END OF SYSTEM TYPE DETERMINATION
         AGO   .CVTEND
.CVTEND  ANOP   ,
.MVSEND  ANOP   ,
.*-----------------------------------------------------
.*                                                    
.*       IF ONLY ONE REGISTER IS AVAILABLE, &REG1     
.*       CONTAINS THE AMODE BIT VALUE TO BE SET,      
.*       AND AN OFFSET VALUE ITS THE LOW-ORDER 31     
.*       BITS.  IF TWO REGISTERS ARE AVAILABLE,       
.*       &REG1 CONTAINS THE OFFSET VALUE IN ITS       
.*       LOW-ORDER 31 BITS, AND &REG2 CONTAINS THE    
.*       AMODE BIT VALUE TO BE SET, WITH ITS          
.*       LOW-ORDER 31 BITS SET TO ZERO.  THE          
.*       OFFSET VALUE WILL BE USED TO SELECT THE      
.*       MODE CHANGE INSTRUCTION DYNAMICALLY.         
.*                                                    
.*                                                    
.*-----------------------------------------------------
.*                                                    
.*                                                    
.*       WE NOW SELECT THE MODE CHANGE INSTRUCTION    
.*       TO BE EXECUTED.  IF TWO REGISTERS ARE        
.*       AVAILABLE, PACK THE BRANCH ADDRESS INTO      
.*       THE LOW-ORDER 31 BITS OF &REG2, AND THEN     
.*       BRANCH TO THE MODE CHANGE INSTRUCTION        
.*       USING THE OFFSET VALUE IN &REG1.             
.*                                                    
.*       IF ONLY ONE REGISTER IS AVAILABLE, FIRST     
.*       BRANCH USING THE OFFSET VALUE IN &REG1;      
.*       THEN CLEAR THE OFFSET VALUE FROM &REG1       
.*       AND PACK THE BRANCH ADDRESS INTO &REG1       
.*       (THIS MEANS DUPLICATED CODE); AND EXECUTE    
.*       THE BALR OR BSM INSTRUCTION.                 
.*                                                    
.*-----------------------------------------------------
.*
.*       USE THE OFFSET IN &REG1 TO SELECT
.*       THE MODE CHANGE INSTRUCTION:
         AIF  (NOT &R2AVAIL).R2AD1  IF &REG2 NOT AVAILABLE
         O     &R2,IHB&IX.A         PACK BR ADDR W/ AMODE BIT
.R2AD1   ANOP  ,
         B     IHB&IX.B(&R1)        PROCEED WITH BALR OR BSM
.*
.*
.*       GENERATE THE SETUP SEQUENCE AND "BALR".
.*       BECAUSE THE OFFSET VALUE TO GET HERE IS ZERO,
.*       IT IS NOT NECESSARY TO CLEAR THE OFFSET VALUE FIRST:
         AIF  (&R2AVAIL).R2AD2      IF &REG2 AVAILABLE
&LB      O     &R1,IHB&IX.A         PACK BR ADDR W/ AMODE BIT          X
                                    (OFFSET VALUE WAS ZERO)
&LB      SETC  ''                   LABEL HAS BEEN USED
.R2AD2   ANOP  ,
&LB      &BALR &R1,&R2              JUST CONTINUE IF MVS/370
.*
.*
.*       GENERATE THE SETUP SEQUENCE FOR "BSM":
         AIF  (&R2AVAIL).R2AD3      IF &REG2 AVAILABLE
&LS      N&AR  &R1,&AMSKLBL         CLEAR OFFSET VALUE
         O     &R1,IHB&IX.A         PACK BR ADDR W/ AMODE BIT
&LS      SETC  ''                   LABEL HAS BEEN USED
.R2AD3   ANOP  ,
.*-----------------------------------------------------
.*                                                    
.*       GENERATE THE "BSM" INSTRUCTION:              
.*                                                    
.*-----------------------------------------------------
.GENBSM  AIF  ('&ASMHV2(1)' EQ 'NO').AHV2N
.AHV2Y   ANOP   ,                   ASM "H" V2 IS BEING USED
&LS      BSM   &R1,&R2              CHANGE/SAVE ADDRESSING MODE
         AGO   .AHV2Z
.AHV2N   ANOP   ,                   ASM "H" V2 ISN'T BEING USED
&LS      DC   0Y(0)                 CHANGE/SAVE ADDRESSING MODE
         DC    X'0B',AL.4(&R1,&R2)           "BSM" INSTRUCTION
.AHV2Z   ANOP   ,                   ASM "H" V2 IS BEING USED
.*
.*
.*       GENERATE THE INLINE CONSTANTS.  THE BALR
.*       OR BSM INSTRUCTION WILL BRANCH AROUND
.*       THESE CONSTANTS USING THE ADDRESS IN IHB&IX.A:
.*
         AIF  (NOT (&OFSTGEN OR &AMSKGEN OR &ACONGEN)).NOCONS
         AIF  (NOT &OFSTGEN).OFNO
.OFGN    CNOP  2,4                  BOUNDARY ALIGN
IHB&IX.O DC    Y(IHB&IX.S-IHB&IX.B) OFFSET TO BSM
         AGO   .OFZZ
.OFNO    CNOP  0,4                  BOUNDARY ALIGN
.OFZZ    ANOP   ,
.*
         AIF  (NOT &AMSKGEN).BYAM2  IF ADDR SUPPLIED
&AMSKLBL DC    A(X'80000000')       AMODE 31 BIT MASK
.BYAM2   ANOP   ,
.*
         AIF  (NOT &ACONGEN).BYAC2  IF ADDR SUPPLIED VIA "LA"
IHB&IX.A DC    A(IHB&IX.N&AMDHEX)       BRANCH ADDRESS FOR BSM
.BYAC2   ANOP   ,
.NOCONS  ANOP   ,
.*
.*
.*       GENERATE THE "N" INSTRUCTION TO CLEAR THE RESULT
.*       REGISTER AND SET THE CONDITION CODE:
IHB&IX.N N&AR  &R1,&AMSKLBL         CLEAR ADDR, PRESERVE AMODE BIT,    X
                                    AND SET CC FOR INVOKER
         MEND
         TITLE '$ORTPARM - MODULE EQUATES'
$ORTPARM START 000000
$ORTPARM AMODE 24
$ORTPARM RMODE 24
*
*
*        PHYSICAL REGISTER EQUATES
R0       EQU   0
R1       EQU   1
R2       EQU   2
R3       EQU   3
R4       EQU   4
R5       EQU   5
R6       EQU   6
R7       EQU   7
R8       EQU   8
R9       EQU   9
R10      EQU   10
R11      EQU   11
R12      EQU   12
R13      EQU   13
R14      EQU   14
R15      EQU   15
         SPACE 3
*
*
*        LOGICAL REGISTER EQUATES
RWORK0   EQU   00                  TEMPORARY WORK/PARM REGISTER
RWORK1   EQU   01                  TEMPORARY WORK/PARM REGISTER
RWORK2   EQU   02                  TEMPORARY WORK/TRT  REGISTER
RWORK3   EQU   03                  TEMPORARY WORK/PARM REGISTER
RWORK4   EQU   04                  TEMPORARY WORK/PARM REGISTER
RWORK5   EQU   05                  SUBROUTINE INTERNAL WORK REGISTER
RWORK6   EQU   06                  SUBROUTINE INTERNAL WORK REGISTER
RWORK7   EQU   07                  SUBROUTINE INTERNAL WORK REGISTER
RPRMPTR  EQU   08   (EVEN)         CURRENT PARM TABLE ENTRY
RPRMRLN  EQU   09   (ODD )         REMAINING PARM TABLE LENGTH
RBASE1   EQU   10                  MODULE BASE REGISTER # 1
RBASE2   EQU   11                  MODULE BASE REGISTER # 2
RBASE3   EQU   12                  MODULE BASE REGISTER # 3
RSAVE    EQU   13                  WORK AREA BASE REGISTER
RLINK    EQU   14                  SUBROUTINE LINKAGE REGISTER
RENTRY   EQU   15                  ENTRY ADDRESS/RETURN CODE REGISTER
         EJECT  ,
*
*
*        EBCDIC CHARACTER AND MISCELLANEOUS EQUATES
SP001    EQU   001                 EQUATE FOR SUBPOOL 001
EBLANK   EQU   X'40'               BLANK
EZERO    EQU   C'0'                EBCDIC ZERO
BZERO    EQU   B'00000000'         BINARY ZERO
EAMPSAND EQU   C'&&'               EBCDIC AMPERSAND
EQUOTE   EQU   C''''               EBCDIC QUOTE
EASTRISK EQU   C'*'                EBCDIC ASTERISK
EPERIOD  EQU   C'.'                EBCDIC PERIOD
ECOMMA   EQU   C','                EBCDIC COMMA
ELPAREN  EQU   C'('                EBCDIC LEFT PARENTHESIS
ERPAREN  EQU   C')'                EBCDIC RIGHT PARENTHESIS
ESLASH   EQU   C'/'                EBCDIC SLASH
ESEMIC   EQU   C';'                EBCDIC SEMICOLON
ECOLON   EQU   C':'                EBCDIC COLON
EQUERY   EQU   C'?'                EBCDIC QUESTION MARK
EMINUS   EQU   C'-'                EBCDIC MINUS SIGN
EPLUS    EQU   C'+'                EBCDIC PLUS SIGN
EEQUAL   EQU   C'='                EBCDIC EQUALS SIGN
EDOLLAR  EQU   C'$'                EBCDIC DOLLAR SIGN
EPOUND   EQU   C'#'                EBCDIC POUND SIGN
EAT      EQU   C'@'                EBCDIC AT SIGN
         SPACE 3
*
*
*        EQUATES FOR NUMERIC CONSTANTS
*        USED IN IMMEDIATE AND "LA" INSTRUCTIONS
K0       EQU   0
K1       EQU   1
K2       EQU   2
K3       EQU   3
K4       EQU   4
K5       EQU   5
K6       EQU   6
K7       EQU   7
K8       EQU   8
K10      EQU   10
K11      EQU   11
K12      EQU   12
K16      EQU   16
K18      EQU   18
K24      EQU   24
K32      EQU   32
K59      EQU   59
K60      EQU   60
K64      EQU   64
K80      EQU   80
K100     EQU   100
K120     EQU   120
K128     EQU   128
K132     EQU   132
K150     EQU   150
K255     EQU   255
K256     EQU   256
K306     EQU   306
K365     EQU   365
K400     EQU   400
K512     EQU   512
K1000    EQU   1000
K1900    EQU   1900
K2048    EQU   2048
         SPACE 3
*
*
*        EQUATES FOR MESSAGE LEVEL
ML00     EQU   00             MESSAGE LEVEL VALUE NOT PROVIDED
ML01     EQU   01             NO MESSAGES ARE TO BE ISSUED
ML02     EQU   02
ML03     EQU   03
ML04     EQU   04
ML05     EQU   05
ML06     EQU   06
ML07     EQU   07
ML08     EQU   08
ML09     EQU   09
MLDFLT   EQU   ML01   DEFAULT MESSAGE LEVEL VALUE
         SPACE 3
*
*
*        EQUATES FOR $ORTPARM DDNAME USE
$P00     EQU   00             $ORTPARM DD AUTHORIZATION NOT PROVIDED
$P01     EQU   01             $ORTPARM DD USE IS AUTHORIZED
$P02     EQU   02             $ORTPARM DD USE NOT AUTHORIZED (ERR MSG)
$P03     EQU   03             $ORTPARM DD USE NOT AUTHORIZED (UNALLOC)
$PDFLT   EQU   $P01   DEFAULT $ORTPARM DD USE AUTHORITY
         SPACE 3
*
*
*        EQUATES FOR "MSGDD=SORTMSG" PROCESSING OPTIONS
MD00     EQU   00             "MSGDD=SORTMSD" OPTION NOT PROVIDED
MD01     EQU   01             "MSGDD=SORTMSG" IS NOT TO BE PROCESSED
MD02     EQU   02             "MSGDD=SORTMSG" IS TO BE PROCESSED
MDDFLT   EQU   MD02   DEFAULT "MSGDD=SORTMSG" PROCESSING
         EJECT  ,
*
*
*        RETURN CODE EQUATES
RC00     EQU   00             PARM VALUE RETURNED TO SORT
RC04     EQU   04             PARM VALUE NOT RETURNED TO SORT
         SPACE 3
*
*
*        EQUATES FOR THE TCB/ASCB WORDS REFERENCED BY -CVTTCBP-.
TCBPNEW  EQU   X'0000',04     -> NEXT TCB TO BE DISPATCHED
TCBPOLD  EQU   X'0004',04     -> CURRENT TCB
ASCBPNEW EQU   X'0008',04     -> NEXT ASCB TO BE DISPATCHED
ASCBPOLD EQU   X'000C',04     -> CURRENT ASCB
   TITLE '$ORTPARM - ADDRESS SPACE CONTROL BLOCK(ASCB) DSECT'
         IHAASCB   DSECT=YES
   TITLE '$ORTPARM - ADDRESS SPACE VECTOR TABLE (ASVT) DSECT'
         IHAASVT   DSECT=YES
   TITLE '$ORTPARM - COMMUNICATIONS VECTOR TABLE(CVT) DSECT'
         CVT       LIST=YES,DSECT=YES
   TITLE '$ORTPARM - DATA CONTROL BLOCK(DCB) DSECT'
         DCBD  DSORG=(PS,PO),DEVD=DA
   TITLE '$ORTPARM - DATA EXTENT BLOCK(DEB) DSECT'
         IEZDEB LIST=YES
DEBDSECT EQU   DEBBASIC       ALTERNATE NAME FOR DSECT
   TITLE '$ORTPARM - DAIRFAIL ROUTINE IKJEFF18 MAPPING MACROS'
         IKJEFFDF DFDSECT=YES,DFDSEC2=YES
   TITLE '$ORTPARM - DYNAMIC ALLOCATION MAPPING MACROS'
         IEFZB4D0  ,
         EJECT  ,
         IEFZB4D2  ,
   TITLE '$ORTPARM - JOB STEP CONTROL BLOCK (JSCB) DSECT'
         IEZJSCB ,
   TITLE '$ORTPARM - SRM USER CONTROL BLOCK(OUCB) DSECT'
         IRAOUCB   DSECT=YES
   TITLE '$ORTPARM - JES2 SUBSYSTEM JOB BLOCK (SJB) DSECT'
$ORTPARM CSECT  ,            PREVENT ASSEMBLY ERROR WITH $SJB
         $SJB   DOC=NO       TITLE PROVIDED WITHIN MACRO
   TITLE '$ORTPARM - SMF SYSTEM MANAGEMENT CONTROL AREA (SMCA) DSECT'
         IEESMCA ,
   TITLE '$ORTPARM - SUBSYSTEM IDENTIFICATION BLOCK (SSIB) DSECT'
         IEFJSSIB ,
   TITLE '$ORTPARM - TASK CONTROL BLOCK(TCB) DSECT'
         IKJTCB     LIST=YES,DSECT=YES
   TITLE '$ORTPARM - TASK INPUT/OUTPUT TABLE (TIOT) DSECT'
TIODSECT DSECT  ,
         IEFTIOT1 ,
   TITLE '$ORTPARM - WRITE-TO-OPERATOR PARAMETER LIST DSECT MAPPING'
         IEZWPL     DSECT=YES
         PRINT ON
         TITLE '$ORTPARM - WORKING STORAGE DSECT'
         SPACE 3
WRKAREA  DSECT  ,
***************************************************************
*                                                             *
*        -$ORTPARM - MODULE GENERAL REGISTER SAVE AREA        *
*                                                             *
***************************************************************
*
*
SAVE     DC    18A(0)              GENERAL REGISTER SAVE AREA
*
***************************************************************
*                                                             *
*        TEMPORARY WORK AREAS USED IN SUBROUTINES AND         *
*        IN MAINLINE CODE FOR MANIPULATING AND EDITING        *
*        CHARACTER STRINGS AND VALUES.  THESE AREAS ARE       *
*        NEVER USED FOR PASSING VALUES BETWEEN ROUTINES.      *
*                                                             *
***************************************************************
*
*
PACKAREA DC    D'0'           DOUBLEWRD BOUNDARY/WORK AREA
PACK1    DC    CL64' '        PACK/UNPK/CVD/CVB/EDIT
PACK2    DC    CL64' '             WORK
PACK3    DC    CL64' '                  AREAS
VWRK1    #VSTR MAXLN=256      STRING MANIPULATION WORK AREA
VWRK2    #VSTR MAXLN=256      STRING MANIPULATION WORK AREA
***************************************************************
*                                                             *
*        PROGRAM EXECUTION CONTROL VARIABLES THAT ARE         *
*        ASSIGNED DEFAULT VALUES DURING MODULE INITIALIZATION,*
*        AND THAT CAN BE CHANGED BY EVENTS DURING PROGRAM     *
*        EXECUTION.                                           *
*                                                             *
***************************************************************
*
*
         DS    0D                  PROVIDE BOUNDARY ALIGNMENT
XITMSGDD #VSTR 'SORTMSG',MAXLN=08  ALTERNATE MESSAGE DDNAME
XITPRMDD #VSTR '$ORTPARM',MAXLN=08 SORT PARM         DDNAME
XITMLDDN #VSTR '$ORTML##',MAXLN=08 MESSAGE LEVEL     DDNAME
*
XITPARMA DC    A(0)                -> PARM LIST FOR SORT
XITRC    DC    Y(0)                EXECUTION RETURN CODE
XITDFML  DC    AL1(MLDFLT)         DEFAULT MESSAGE LEVEL
XITDF$P  DC    AL1($PDFLT)         DEFAULT $ORTPARM DD AUTH
XITDFMD  DC    AL1(MDDFLT)         DEFAULT "MSGDD=SORTMSG" OPTION
XITML    DC    AL1(ML01)           MESSAGE LEVEL
XIT$P    DC    AL1($P02)           $ORTPARM DD AUTHORIZATION
XITMD    DC    AL1(MD02)           "MSGDD=SORTMSG" PROCESSING OPTION
***************************************************************
*                                                             *
*        EXECUTION VARIABLES USED IN THE MAINLINE             *
*        #PARM TABLE SCAN ROUTINE.                            *
*                                                             *
***************************************************************
*
*
         DS    0D                  PROVIDE BOUNDARY ALIGNMENT
*        THE FOLLOWING AREAS ARE USED TO LOAD $ORTDATA.
XIT#DATA DC    CL8'$ORTDATA'       $ORTDATA LOAD MODULE NAME
XIT#DAT@ DC    A(0)                $ORTDATA LOAD MODULE ADDRESS
XIT#DATF DC    AL1(00)             $ORTDATA LOAD MODULE APF AUTH
XIT#DATL DC    FL3'0'              $ORTDATA LOAD MODULE LENGTH
XIT#RSCD DC    A(0)        (15)    $ORTDATA LOAD FAILURE REASON CODE
XIT#ABCD DC    A(0)        (01)    $ORTDATA LOAD FAILURE ABEND  CODE
*        END OF THE AREAS USED FOR LOADING $ORTDATA.
*
*        THE FOLLOWING AREAS ARE USED IN PROCESSING $ORTDATA.
XIT#JOBN DC    CL8' '              SAVE JOB NAME FROM CURRENT ASID
XIT#PRM# DC    A(0)                CURRENT PARM TABLE ENTRY #
*        THE NEXT TWO VARIABLES MUST REMAIN IN THE ORDER SHOWN
XIT#PRMP DC    A(0)                -> CURRENT PARM TABLE ENTRY
XIT#PRML DC    A(0)                REMAINING PARM TABLE LENGTH
***************************************************************
*                                                             *
*        EXECUTION ENVIRONMENT VALUES OBTAINED VIA            *
*        SYSTEM MACROS, OR VIA REFERENCE TO SYSTEM DATA AREAS.*
*                                                             *
***************************************************************
*
*
         DS    0D                  PROVIDE BOUNDARY ALIGNMENT
*        THE NEXT TWO FIELDS MUST REMAIN IN ORDER - TIME BEFORE DATE
XEQTME   DC    A(0)                EXECUTION TOD IN 1/100 SECONDS
XEQDATE  DC    PL4'0'              EXECUTION DATE IN PACKED DECIMAL
*
XEQDOW   DC    A(0)                EXECUTION DAY OF WEEK   BINARY 0-6
XEQMOY   DC    A(0)                EXECUTION MONTH OF YEAR BINARY 1-12
XEQDOM   DC    A(0)                EXECUTION DAY OF MONTH  BINARY 1-31
XEQSMFID DC    CL4' '              EXECUTION SYSTEM SMF IDENTIFIER
XEQJOBL  DC    Y(0)                EXECUTION JOB NAME      LENGTH
XEQJOBN  DC    CL8'JJJJJJJJ'       EXECUTION JOB NAME      FROM TIOT
XEQSTEPL DC    Y(0)                EXECUTION STEP NAME     LENGTH
XEQSTEPN DC    CL8'SSSSSSSS'       EXECUTION STEP NAME     FROM TIOT
XEQPROCL DC    Y(0)                EXECUTION PROCSTEP NAME LENGTH
XEQPROCN DC    CL8'PPPPPPPP'       EXECUTION PROCSTEP NAME FROM TIOT
XEQPGMNL DC    Y(0)                EXECUTION STEP PROGRAM NAME LN
XEQPGMNM DC    CL8'XXXXXXXX'       EXECUTION STEP PROGRAM NAME
XEQNPG   DC    YL2(000)            EXECUTION PERFORMANCE GROUP
XEQJCLS  DC    CL1'X'              EXECUTION JOB CLASS
***************************************************************
*                                                             *
*        EXTRACT MACRO ANSWER AREAS AND PARAMETER LIST.       *
*                                                             *
***************************************************************
*
*
EXTRANSW DS   0A(0)                BOUNDARY ALIGN/START ANSWER AREA
EXTRTIOT DS    A(0)                -> TIOT
EXTRLIST EXTRACT 0,                EXTRACT MACRO LIST FORM             X
               FIELDS=(TIOT),                                          X
               MF=L
***************************************************************
*                                                             *
*        WRITE-TO-OPERATOR AND MESSAGE ASSEMBLY ROUTINE       *
*        WORK AREAS.                                          *
*                                                             *
***************************************************************
*
*        GENERAL REGISTER SAVE AREAS
SAVMSGIT DS   10A(0)               SAVE AREA FOR "INITMSG "
SAVMSGUP DS   10A(0)               SAVE AREA FOR "UPDTMSG "
SAVMSGCT DS   10A(0)               SAVE AREA FOR "CONTMSG "
SAVMSGPT DS   10A(0)               SAVE AREA FOR "POSITMSG"
SAVMSGND DS   10A(0)               SAVE AREA FOR "ENDMSG  "
SAVMSGSK DS   02A(0)               SAVE AREA FOR "MSGSKCPY"
SAVMSGWT DS   10A(0)               SAVE AREA FOR "WRTMSG  "
*
*        WORK AREAS USED BY THE MESSAGE ASSEMBLY ROUTINES
*              THE NEXT FOUR WORDS MUST REMAIN CONTIGUOUS AS SHOWN
MSGSKLND DS    A(0)                END+1      OF WTO MSG SKELETON TEXT
MSGSKLBG DS    A(0)                ADDRESS    OF WTO MESSAGE SKELETON
MSGOUTBG DS    A(0)                ADDRESS    OF MESSAGE OUTPUT AREA
MSGOUTSZ DS    A(0)                SIZE(LN+4) OF MESSAGE OUTPUT AREA
*              THE NEXT TWO WORDS MUST REMAIN CONTIGUOUS AS SHOWN
MSGTXTAD DS    A(0)                START ADDR OF TEXT PART OF OUTAREA
MSGTXTLN DS    A(0)                LENGTH     OF TEXT PART OF OUTAREA
*              THE NEXT FOUR WORDS MUST REMAIN CONTIGUOUS AS SHOWN
MSGOUTAD DS    A(0)                CURRENT  ADDRESS IN OUTPUT AREA
MSGOUTLN DS    A(0)                REMAINING LENGTH IN OUTPUT AREA
MSGSKLAD DS    A(0)                CURRENT  ADDRESS IN MSG SKELETON
MSGSKLLN DS    A(0)                REMAINING LENGTH IN MSG SKELETON
MSGSKLEP DS    A(0)                END+1 OF CURRENT SKELETON STRING
*
*        WORK AREAS USED BY THE WRITE TO OPERATOR ROUTINES,
*        AND THE REPLY AND ECB AREAS FOR WTOR.
WTOCONID DS    A(0)                CONSOLE ID FOR MESSAGE
WTODOMID DS    A(0)                DOM ID FOR DELETING MESSAGE
WTOREPLN DS    FL1                 WTOR REPLY AREA LENGTH
WTOREPLY DS    CL15' '             REPLY AREA FOR WTOR
WTORECB  DS    A(0)                ECB FOR USE WITH WTOR
*
*        DEFINE THE WTOR PREFIX TO THE WTO PARAMETER LIST
         DS   0A                   BOUNDARY ALIGN
WTORAREA DS    XL8                 WTOR PREFIX TO LIST
WTOREPAD DS    A                   WTOR REPLY AREA ADDRESS
WTORECBA DS    A                   WTOR WAIT ECB ADDRESS
*
*        DEFINE THE WTO PARAMETER LIST AND MESSAGE TEXT AREA.
WTOAREA  DS    0A                  BOUNDARY ALIGN
WTOLEN   DS   0Y(0)                OPERATOR COMMAND LENGTH
WTO31RLN DC    YL1(0)              31-BIT WTOR REPLY BUFFER LENGTH
WTO31LEN DC    YL1(0)              31-BIT   COMMAND LENGTH+4
WTOMCS   DC    Y(0)                OPERATOR COMMAND MCS FLAGS
WTOMSG   DC    CL128' '            OPERATOR COMMAND TEXT
         DC    XL8'00'             MCS ROUTE AND DESCRIPTOR CODES
***************************************************************
*                                                             *
*        STRING PROCESSING SUBROUTINE WORK AREAS.             *
*                                                             *
***************************************************************
*
*        GENERAL REGISTER SAVE AREAS
SAVCATST DC   8A(0)           RLINK-RWORK5 SAVE AREA FOR "CATSTR  "
SAVCLRST DC   8A(0)           RLINK-RWORK5 SAVE AREA FOR "CLRSTR  "
SAVCMPST DC   8A(0)           RLINK-RWORK5 SAVE AREA FOR "CMPSTR  "
SAVLENST DC   6A(0)           RLINK-RWORK3 SAVE AREA FOR "LENSTR  "
SAVNDXST DC  10A(0)           RLINK-RWORK7 SAVE AREA FOR "NDXSTR  "
SAVPUTST DC   8A(0)           RLINK-RWORK5 SAVE AREA FOR "PUTSTR  "
SAVSCNST DC  10A(0)           RLINK-RWORK7 SAVE AREA FOR "SCNSTR  "
SAVSELST DC   8A(0)           RLINK-RWORK5 SAVE AREA FOR "SELSTR  "
SAVVFYCH DC  10A(0)           RLINK-RWORK7 SAVE AREA FOR "VFYCHR  "
SAVVFYST DC  10A(0)           RLINK-RWORK7 SAVE AREA FOR "VFYSTR  "
STRSCTBL DS  XL256                         TRT TABLE FOR "SCNSTR  "
STRVFTBL DS  XL256                         TRT TABLE FOR "VFYSTR  "
***************************************************************
*                                                             *
*        EXECUTION ENVIRONMENT INTERFACE ROUTINE WORK AREAS.  *
*                                                             *
***************************************************************
*
*        GENERAL REGISTER SAVE AREAS
SAVLOCDD DC   8A(0)           RLINK-RWORK5 SAVE AREA FOR "LOCDDNAM"
SAVGTNPG DC   8A(0)           RLINK-RWORK5 SAVE AREA FOR "GETNPG  "
XNVLDDRG DC   8A(0)           RLINK-RWORK5 REG  SAVE FOR "LOCDDCNT"
XNVLDDEA EQU  XNVLDDRG+04,4,C'A'    LABEL FOR TIOT ENTRY ADDRESS
XNVLDDEO EQU  XNVLDDRG+08,4,C'A'    LABEL FOR TIOT ENTRY OFFSET
***************************************************************
*                                                             *
*        EDITING AND FORMATTING ROUTINE WORK AREAS.           *
*                                                             *
***************************************************************
*
*        GENERAL REGISTER SAVE AREAS
SAVEDBIN DC  10A(0)           RLINK-RWORK7 SAVE AREA FOR "EDITBIN "
SAVEDBIT DC  10A(0)           RLINK-RWORK7 SAVE AREA FOR "EDITBIT "
SAVEDHEX DC  10A(0)           RLINK-RWORK7 SAVE AREA FOR "EDITHEX "
SAVEDTMB DC  10A(0)           RLINK-RWORK7 SAVE AREA FOR "EDITTIMB"
SAVEDYDD DC  10A(0)           RLINK-RWORK7 SAVE AREA FOR "EDITYDDD"
EDTRSLT  DC  CL64' '          EDIT ROUTINE COMMON RESULT AREA
***************************************************************
*                                                             *
*        DYNAMIC ALLOCATION INTERFACE WORK AREAS.             *
*                                                             *
***************************************************************
         DS    0D             PROVIDE BOUNDARY ALIGNMENT
*
*
*        DEFINE THE WORK AREAS AND VARIABLES USED TO MAINTAIN
*        THE DYNALLOC PARAMETER LISTS.
XAL99RBP DC    A(0)           SVC 99 REQUEST BLOCK POINTER
*        CURRENT KEY AND PARM COUNT - MUST REMAIN TOGETHER AS SHOWN.
XAL99KEY DC    Y(0)           CURRENT KEY
XAL99#KY DC    Y(0)           CURRENT PARM COUNT
XAL99KY# DC    A(0)           KEY COUNT FOR CURRENT REQUEST
*        VARIABLES USED TO BUILD AND MAINTAIN
*        THE TEXT UNIT POINTER LIST AND THE TEXT UNITS.
*        THE NEXT 5 WORDS MUST REMAIN TOGETHER AS SHOWN.
XAL99KPT DC    A(0)     (3)   -> CURRENT KEY UNDER CONSTRUCTION
XAL99TUA DC    A(0)     (4)   -> FIRST AVAIL BYTE IN TU ASSEMBLY AREA
XAL99TUZ DC    A(0)     (5)      REMAINING SPC IN TU ASSEMBLY AREA
XAL99TPA DC    A(0)     (6)   -> CURRENT ENTRY IN TU POINTER LIST
XAL99TPZ DC    A(0)     (7)      REMAINING SPC IN TU POINTER LIST
*
*
*        DEFINE THE PARAMETER LISTS AND AREAS
*        REQUIRED BY "DYNALLOC".
XAL99RB  DC    XL20'00'       SVC 99 REQUEST BLOCK
XAL99RC  DC    A(0)           SVC 99 SAVED RETURN CODE
XAL99TPP DC  64A(0)           SVC 99      TEXT UNIT POINTERS
XAL99TPE DS   0A              SVC 99      TEXT UNIT POINTER LIST END+1
XAL99TPL EQU   XAL99TPE-XAL99TPP     LAST TEXT UNIT POINTER LIST LENGTH
XAL99TU  DS    CL512          SVC 99 TEXT UNIT ASSEMBLY AREA
XAL99TUN DS   0C              SVC 99 TEXT UNIT ASSEMBLY AREA END+1
XAL99TUL EQU   XAL99TUN-XAL99TU      TEXT UNIT ASSEMBLY AREA LENGTH
*
*
*        DEFINE THE PARAMETER LIST AND ASSOCIATED VARIABLES
*        REQUIRED BY DAIRFAIL ROUTINE IKJEFF18.
XALDFPRM DC   6A(0)           DAIRFAIL (IKJEFF18) PARAMETER LIST
XALDFF02 DC    A(0)           -> IKJEFF02 ENTRY POINT OR ZERO
XALDFIDP DC    X'00'          DARIFAIL SWITCHES
         DC    X'00'          DAIRFAIL CALLER ID NUMBER
***************************************************************
*                                                             *
*                "D A T E C A L C"                            *
*        GENERAL PURPOSE DATE CALCULATION ROUTINE             *
*                WORK AREAS.                                  *
*                                                             *
***************************************************************
SAVDATCL DC    10A(0)              "DATECALC" REGISTER SAVE AREA:      X
                                              RLINK-RWORK7
SAVDTMSG DC    08A(0)              "DATEMSG"  REGISTER SAVE AREA:      X
                                              RLINK-RWORK5
*
*        THE VALUES BELOW ARE AVAILABLE TO THE CALLER
*        UPON RETURN FROM "DATECALC" AND ARE LEFT UNCHANGED
*        UNLESS "DATECALC" IS REENTERED.
DATDOW   DC    A(0)   15   BINARY  DAY OF WEEK  FROM "DATECALC"
DATMM    DC    A(0)    0   BINARY  MONTH        FROM "DATECALC"
DATDD    DC    A(0)    1   BINARY  DAY OF MONTH FROM "DATECALC"
DATDDD   DC    A(0)    2   BINARY  DAY OF YEAR  FROM "DATECALC"
DATYYYY  DC    A(0)    3   BINARY  YEAR         FROM "DATECALC"
DATFACT  DC    A(0)    4   BINARY  "FACTOR"     FROM "DATECALC"
DATEYYDD DC   0C'YYYY.DDD' EBCDIC  DATE VALUE   FROM "DATECALC"
DATEYYYY DC    C'YYYY'     EBCDIC  YYYY         FROM "DATECALC"
DATEP1   DC    C'.'        EBCDIC  "."          FROM "DATECALC"
DATEDDD  DC    C'DDD'      EBCDIC  DDD          FROM "DATECALC"
DATEMDY  DC   0C'MM/DD/YY' EBCDIC  DATE VALUE   FROM "DATECALC"
DATEMM   DC    C'MM'       EBCDIC  MM           FROM "DATECALC"
DATES1   DC    C'/'        EBCDIC  "/"          FROM "DATECALC"
DATEDD   DC    C'DD'       EBCDIC  DD           FROM "DATECALC"
DATES2   DC    C'/'        EBCDIC  "/"          FROM "DATECALC"
DATEYY   DC    C'YY'       EBCDIC  YY           FROM "DATECALC"
DATEWW   DC    C'WW'       EBCDIC  WW           FROM "DATECALC"
         SPACE 5
ENDSECT  DS    0D                  MARK THE DSECT END
LENAREA  EQU   ENDSECT-WRKAREA     LENGTH OF DSECT WORK AREA
         TITLE '$ORTPARM - PARM TABLE ENTRY MAPPING DSECT'
***************************************************************
*                                                             *
*        PARM TABLE ENTRY MAPPING DSECT.                      *
*                                                             *
***************************************************************
#PARMMAP DSECT
#PRMRDW  DS   YL2          TABLE ENTRY RDW
         DS   YL2          2ND HALF OF RDW
#PRMSID  DS   CL4          SYSTEM ID COMPARISON MASK
#PRMBGN  DS   AL4          START TIME IN 1/100 SECONDS
#PRMEND  DS   AL4          END   TIME IN 1/100 SECONDS
#PRMDOW  DS   B'00000000'  DAY OF WEEK ELIGIBILITY BIT MASK
#PRMMLVL DS   AL1(00)      MESSAGE LEVEL OVERRIDE
#PRM$PRM DS   AL1(00)      $ORTPARM DD AUTHORIZATION
#PRMMSGD DS   AL1(00)      "MSGDD=SORTMSG" PROCESSING OPTION
#PRMFLAG DS   B'00000000'  FLAG BYTE
#PRMFUPD EQU  B'00010000'  PARM VALUE UPDATES EXISTING VALUE
#PRMJCLS DS   CL1          JOB  CLASS     COMPARISON MASK
#PRMJNAM DS   CL8          JOB  NAME      COMPARISON MASK
#PRMSNAM DS   CL8          STEP NAME      COMPARISON MASK
#PRMPSNM DS   CL8          PROC STEP NAME COMPARISON MASK
#PRMPGMN DS   CL8          PROGRAM   NAME COMPARISON MASK
*
*        VARIABLE LENGTH LIST PORTION OF THE ENTRY BEGINS HERE.....
#PRMNOFF DS   YL2          OFFSET TO  PGN     LIST LENGTH
#PRMOOFF DS   YL2          OFFSET TO  JOBNAME LIST LENGTH
#PRMDOFF DS   YL2          OFFSET TO  DATE    LIST LENGTH
#PRMPOFF DS   YL2          OFFSET TO  PARM STRING  LENGTH
#PRMNLEN DS   YL2          PERFORMANCE GROUP NUMBER LIST LENGTH
#PRMNPG# DS  0YL2          PERFORMANCE GROUP NUMBER
#PRMOLEN DS   YL2          CORESIDENT JOBNAME LIST LENGTH
#PRMOJOB DS  0CL8          CORESIDENT JOBNAME ENTRY(VARIABLE COUNT)
#PRMDLEN DS   YL2          DATE LIST LENGTH
#PRMDATE DS  0PL4          DATE LIST ENTRY(VARIABLE COUNT)
#PRMPLEN DS   YL2          PARM TEXT LENGTH
#PRMPTXT DS  0CL100        PARM TEXT (VARIABLE LENGTH)
         TITLE '$ORTPARM - MODULE AND WORK AREA INITIALIZATION'
***************************************************************
*                                                             *
*        MODULE ENTRY POINT AND IDENTIFYING CONSTANTS         *
*                                                             *
***************************************************************
$ORTPARM CSECT
         USING *,R15               TEMPORARY BASE
         B     BYID                BRANCH AROUND MODULE IDENTIFIER
         DC    AL1(NDID-*)         IDENTIFIER LENGTH
$ORTNAME DC    C'$ORTPARM'         MODULE NAME
         DC    C' '                       SPACE
$ORTVER  DC    C'02.27'            MODULE VERSION AND LEVEL
         DC    C' '                       SPACE
$ORTASDT DC    C'&SYSDATE'         MODULE ASSEMBLY DATE
         DC    C' '                       SPACE
$ORTASTM DC    C'&SYSTIME'         MODULE ASSEMBLY TIME
         DC    C' '                       SPACE
$ORTSIZE DC    AL4($ORTEND-$ORTPARM)      SIZE IN BYTES
NDID     EQU   *                   MARK IDENTIFIER END
BYID     DS    0H                  BRANCH POINT AROUND IDENTIFIER
***************************************************************
*                                                             *
*        SAVE THE CALLER'S REGISTERS AND                      *
*        ESTABLISH MODULE BASE REGISTER VALUES.               *
*                                                             *
***************************************************************
*
*
*        PROVIDE CODE TO ALLOW DISABLING THE EXIT
NOPEXIT  B     GOEXIT       *******ZAP TO NOP TO DISABLE EXIT*********
         LA    R15,RC04            SET RETURN CODE=04
         BR    R14                 RETURN TO SYNCSORT
*
*
*        SAVE CALLER'S REGISTERS AND ESTABLISH BASE REGISTERS
GOEXIT   DS    0H                  START ACTUAL PROCESSING
         STM   R14,R12,12(R13)     SAVE GENERAL REGISTERS
         LA    RBASE1,0(,R15)           LOAD FIRST
         LA    RBASE2,K2048             SET UP SECOND
         AR    RBASE2,RBASE2            BASE REGISTER OFFSET  (4096)
         LA    RBASE3,00(RBASE2,RBASE2) THIRD BASE REG OFFSET (8192)
         AR    RBASE2,RBASE1            SET UP SECOND BASE REGISTER
         AR    RBASE3,RBASE1            SET UP THIRD  BASE REGISTER
         USING $ORTPARM,RBASE1,RBASE2,RBASE3   PERMANENT BASE REGS
         DROP  R15                 DROP TEMPORARY BASE
***************************************************************
*                                                             *
*        GETMAIN AND CLEAR THE WORK AREA USED THROUGHOUT      *
*        THIS MODULE.  THEN CHAIN SAVE AREAS TOGETHER         *
*        AND MAKE THE WORK AREA ADDRESSABLE.                  *
*                                                             *
***************************************************************
*
*        GET STORAGE FOR THE WORK AREA
         L     R0,WORKSIZE         LOAD    SIZE      FOR GETMAIN
         GETMAIN RU,               GET WORK AREA STORAGE               X
               LOC=(BELOW,ANY),    WORK AREA LOCN (VIRT,REAL)          X
               LV=(0),             WORK AREA SIZE                      X
               SP=SP001            WORK AREA SUBPOOL
*
*        CLEAR THE WORK AREA OBTAINED
         LR    RWORK6,R1           SAVE WORK AREA ADDRESS
         LR    RWORK0,R1           COPY WORK AREA ADDRESS
         L     RWORK1,WORKSIZE     LOAD WORK AREA SIZE
         SR    RWORK3,RWORK3       SET PAD=X'00', LN = 0
         MVCL  RWORK0,RWORK2       CLEAR THE WORK AREA
         LR    R1,RWORK6           RESTORE WORK AREA ADDRESS
*
*        CHAIN SAVE AREAS TOGETHER
         ST    R1,8(,R13)              CHAIN SAVE
         ST    R13,SAVE+4-WRKAREA(,R1) AREAS TOGETHER
         LR    RSAVE,R1            WORK AREA BASE REGISTER
         USING WRKAREA,RSAVE       WORK AREA ADDRESSABILITY
***************************************************************
*                                                             *
*        INITIALIZE VALUES IN THE WORK AREA.                  *
*        BECAUSE THE WORK AREA HAS ALREADY BEEN CLEARED,      *
*        ONLY NON-ZERO VALUES NEED TO BE INITIALIZED.         *
*        DESPITE THIS, SOME ZERO VALUES ARE EXPLICITLY        *
*        INITIALIZED TO MAKE THE PROGRAM EASIER TO ZAP.       *
*                                                             *
***************************************************************
*
*
*        INITIALIZE PROGRAM CONTROL VARIABLES
         MVC   XITMSGDD-2(L'XITMSGDD+2),DFLTMSDD-2
         MVC   XITPRMDD-2(L'XITPRMDD+2),DFLTPRDD-2
         MVC   XITMLDDN-2(L'XITMLDDN+2),DFLTMLDD-2
         MVC   XIT#DATA,DATANAME   $ORTDATA LOAD MODULE NAME FOR       X
                                   LOAD/DELETE
         MVC   XITPARMA,PARMPTRA   ADDRESS OF PARM LIST FOR SORT
         MVI   XITDFML,MLDFLT      DEFAULT ML IS "QUIET"
         MVI   XITDF$P,$PDFLT      DEFAULT $P DD AUTH"
         MVI   XITDFMD,MDDFLT      DEFAULT "MSGDD=SORTMSG" OPT
         MVC   XITML,XITDFML       INITIALIZE XITML
         MVC   XIT$P,XITDF$P       INITIALIZE XIT$P
         MVC   XITMD,XITDFMD       INITIALIZE XITMD
*
*
*        INITIALIZE EXECUTION ENVIRONMENT VALUES.
         MVC   XEQSMFID,EBLANKS    SET TO BLANKS
         MVC   XEQJOBN(L'XEQJOBN),EBLANKS     SET TO BLANKS
         MVC   XEQSTEPN(L'XEQSTEPN),EBLANKS   SET TO BLANKS
         MVC   XEQPROCN(L'XEQPROCN),EBLANKS   SET TO BLANKS
         MVC   XEQJCLS(L'XEQJCLS),EBLANKS     SET TO BLANKS
*
*
*        INITIALIZE EXTRACT MACRO PARAMETER LIST AND ANSWER AREA
         MVC   EXTRLIST(EXTRLS1Z),EXTRLS1   COPY MODEL PARM LIST
         EJECT  ,
***************************************************************
*                                                             *
*        ISSUE THE EXTRACT MACRO TO LOCATE THE ADDRESS        *
*        OF THE TIOT.                                         *
*                                                             *
***************************************************************
*
EXTRACT  DS    0H                  TEST PROGRAM AUTHORIZATION
         EXTRACT EXTRANSW,         EXTRACT TCB INFORMATION             X
               MF=(E,EXTRLIST)     USING LIST FORM IN WORK AREA
***************************************************************
*                                                             *
*        COPY THE JOB, STEP, AND PROCSTEP NAMES               *
*        FROM THE TASK I/O TABLE TO THE WORK AREA,            *
*        AND DETERMINE THE SIGNIFICANT LENGTHS FOR USE        *
*        IN THE MESSAGE ASSEMBLY ROUTINES.                    *
*                                                             *
***************************************************************
*
JSPNAMES DS    0H                  PROCESS TIOT TO GET J/S/P NAMES
         L     RWORK5,EXTRTIOT     TIOT ADDRESS
         USING TIODSECT,RWORK5     TIOT ADDRESSABILITY
*
*        SAVE THE JOB, STEP, AND PROCEDURE STEP NAMES
         MVC   XEQJOBN,TIOCNJOB    COPY JOB      NAME
         MVC   XEQSTEPN,TIOCSTEP   COPY STEP     NAME
         MVC   XEQPROCN,TIOCSTEP+8 COPY PROCSTEP NAME
*
*        DETERMINE THE LENGTH OF THE JOB NAME.
JSPJOBN  DS    0H
         LA    RWORK0,XEQJOBN      ADDRESS OF JOB NAME SAVE BUCKET
         LA    RWORK1,L'XEQJOBN    LENGTH  OF JOB NAME SAVE BUCKET
         LA    RWORK2,VBLANK       -> BLANK CHARACTER
         BAS   RLINK,SCNSTRFV      SCAN TO FIRST BLANK
         STH   RENTRY,XEQJOBL      STORE JOB NAME LENGTH IN WORK AREA
*
*        DETERMINE THE LENGTH OF THE STEP NAME.
JSPSTEPN DS    0H
         LA    RWORK0,XEQSTEPN     ADDRESS OF STEP NAME SAVE BUCKET
         LA    RWORK1,L'XEQSTEPN   LENGTH  OF STEP NAME SAVE BUCKET
         LA    RWORK2,VBLANK       -> BLANK CHARACTER
         BAS   RLINK,SCNSTRFV      SCAN TO FIRST BLANK
         STH   RENTRY,XEQSTEPL     STORE STEP NAME LENGTH IN WORK AREA
*
*        DETERMINE THE LENGTH OF THE PROCSTEP NAME.
JSPPROCN DS    0H
         LA    RWORK0,XEQPROCN     ADDRESS OF PROCSTEP NAME SAVE BUCKET
         LA    RWORK1,L'XEQPROCN   LENGTH  OF PROCSTEP NAME SAVE BUCKET
         LA    RWORK2,VBLANK       -> BLANK CHARACTER
         BAS   RLINK,SCNSTRFV      SCAN TO FIRST BLANK
         STH   RENTRY,XEQPROCL     STORE PROCSTEP NAME LNGTH IN W/A
*
*        END OF JOB/STEP/PROCSTEP INITIALIZATION.
         DROP  RWORK5              TIOT NO LONGER ADDRESSABLE
         SPACE 5
***************************************************************
*                                                             *
*        GET THE STEP PROGRAM NAME, AND DETERMINE ITS         *
*        LENGTH FOR USE IN THE REMAINDER OF THE PROGRAM.      *
*                                                             *
***************************************************************
*
*        GET THE STEP PROGRAM NAME.
JSPPGMNM DS    0H
         BAS   RLINK,GETPGMNM      GET PROGRAM NAME IN RWORK0-RWORK1
         STM   RWORK0,RWORK1,XEQPGMNM  STORE PROGRAM NAME
*
*        DETERMINE THE LENGTH OF THE PROGRAM NAME.
         LA    RWORK0,XEQPGMNM     ADDRESS OF PROGRAM NAME SAVE BUCKET
         LA    RWORK1,L'XEQPGMNM   LENGTH  OF PROGRAM NAME SAVE BUCKET
         LA    RWORK2,VBLANK       -> BLANK CHARACTER
         BAS   RLINK,SCNSTRFV      SCAN TO FIRST BLANK
         STH   RENTRY,XEQPGMNL     STORE PROGRAM NAME LNGTH IN W/A
         EJECT  ,
***************************************************************
*                                                             *
*        SCAN THE TIOT FOR A //$ORTML## DD STATEMENT.         *
*        FOR EACH SUCH DD FOUND, SET THE MESSAGE LEVEL        *
*        VALUE IN THE WORK AREA.  THIS FEATURE ALLOWS THE     *
*        USER TO REQUEST DIAGNOSTIC MESSAGES IN CASE A        *
*        PROBLEM ARISES IN THE USE OF THIS EXIT.              *
*                                                             *
***************************************************************
*
*
SETMLVL  DS    0H                  SET EXIT MESSAGE LEVEL VALUE
         NOP   SETML09       ******ZAP TO BRANCH TO TURN OFF FEATURE**
*
*
*        PREPARE TO SCAN THE TIOT.
SETML00  DS    0H
         LA    RWORK2,XITMLDDN+2   -> GENERIC DDNAME TO USE FOR SCAN
         LA    RWORK5,LOCDDSTR     -> GENERIC DDNAME SEARCH ROUTINE
*
*
*        SCAN THE TIOT FOR A "$ORTML##" DD STATEMENT.
SETML01  DS    0H
         BASR  RLINK,RWORK5        GO SEARCH FOR DDNAME
         BZ    SETML09             IF TIOT SCAN COMPLETE
         LA    RWORK5,LOCDDCNT     -> DDN SEARCH CONTINUATION ROUTINE
         USING TIOENTRY,RENTRY     TIOT ENTRY ADDRESSABILITY
         CLI   TIOEDDNM,EDOLLAR    FIRST CHARACTER "$" ??
         BNE   SETML01             CONTINUE SEARCH IF NOT
*
*
*        A "$ORTML##" DD ENTRY HAS BEEN FOUND.
*        CONVERT THE MESSAGE LEVEL VALUE IN THE DDNAME TO BINARY,
*        AND UPDATE THE MESSAGE LEVEL VALUE.
SETML02  DS    0H
         LA    RWORK1,K255         LARGEST MESSAGE LVL VALUE ALLOWED
         PACK  PACKAREA,TIOEDDNM+6(2) GET MSG LVL IN PACKED DEC
         CVB   RWORK0,PACKAREA     CONVERT TO BINARY
         LTR   RWORK0,RWORK0       IS IT GT ZERO??
         BNP   SETML01             DONT UPDATE IF NOT
         CR    RWORK0,RWORK1       IS IT GT MAXIMUM??
         BH    SETML01             DONT UPDATE IF TOO LARGE
         STC   RWORK0,XITDFML      UPDATE MESSAGE LEVEL VALUE
         STC   RWORK0,XITML        UPDATE MESSAGE LEVEL VALUE
         B     SETML01             AND CONTINUE SCAN
*
*
*        END OF  INITIAL MESSAGE LEVEL VALUE PROCESSING.
SETML09  DS    0H
         DROP  RENTRY              DROP TIOT ENTRY ADDRESSABILITY
         EJECT  ,
***************************************************************
*                                                             *
*        GET THE EXECUTION JOB CLASS, AND SAVE IT             *
*        IN THE WORK AREA.                                    *
*                                                             *
***************************************************************
*
*
JOBCL    DS    0H                  RETRIEVE THE EXECUTION JOB CLASS
         BAS   RLINK,GETJOBCL      GO GET JOB CLASS
         STC   RENTRY,XEQJCLS      SAVE VALUE IN WORK AREA
***************************************************************
*                                                             *
*        GET THE CURRENT PERFORMANCE GROUP NUMBER,            *
*        AND SAVE IT IN THE WORK AREA.                        *
*                                                             *
***************************************************************
*
*
STEPPGN  DS    0H                  RETRIEVE THE PERFORMANCE GROUP NMBR
         BAS   RLINK,GETNPG        GO GET PGN IN BINARY
         STH   RENTRY,XEQNPG       SAVE VALUE IN WORK AREA
***************************************************************
*                                                             *
*        ACCESS THE EXECUTION SYSTEM'S SMF ID AND SAVE IT     *
*        IN THE WORK AREA.                                    *
*                                                             *
***************************************************************
*
*
SMFID    DS    0H                  RETRIEVE THE SMF SYSTEM IDENTIFIER
         BAS   RLINK,GETSMFID      GO GET SMF ID
         STCM  RENTRY,B'1111',XEQSMFID    SAVE VALUE IN WORK AREA
***************************************************************
*                                                             *
*        GET THE CURRENT DATE AND TIME-OF-DAY,                *
*        AND SAVE THE VALUES IN THE WORK AREA.                *
*                                                             *
***************************************************************
*
*
TIMEXEQ  DS    0H                  RETRIEVE THE TIME & DATE
         BAS   RLINK,GETTIMEB      GO GET CURRENT DATE/TIME
         STM   RWORK0,RWORK1,XEQTME    STORE TIME & DATE
         BAS   RLINK,DATECALC      GO CALCULATE DATE VALUES
         EJECT  ,
***************************************************************
*                                                             *
*        ISSUE DIAGNOSTIC MESSAGE 01                          *
*        DOCUMENTING THE LEVEL OF $ORTPARM                    *
*        THAT WAS INVOKED:                                    *
*                                                             *
***************************************************************
*
*
PUTMSG01 DS   0H
         CLI   XITDFML,ML04        MSGLVL = 04 OR GREATER??
         BL    BYMSG01             SKIP DIAGNOSTIC MSG IF LT 04
         LA    RWORK1,MSG001       -> MESSAGE SKELETON
         BAS   RLINK,INITWTO       BEGIN MESSAGE ASSEMBLY
         SPACE 1
         LA    RWORK0,$ORTNAME     $ORTPARM MODULE NAME
         LA    RWORK1,L'$ORTNAME            MODULE NAME LENGTH
         BAS   RLINK,CONTWTO       CONTINUE MESSAGE ASSEMBLY
         SPACE 1
         LA    RWORK0,$ORTVER      $ORTPARM VERSION & LEVEL
         LA    RWORK1,L'$ORTVER             VERSION & LEVEL LENGTH
         BAS   RLINK,CONTWTO       CONTINUE MESSAGE ASSEMBLY
         SPACE 1
         LA    RWORK0,$ORTASDT     $ORTPARM ASSEMBLY DATE
         LA    RWORK1,L'$ORTASDT            ASSEMBLY DATE LENGTH
         BAS   RLINK,CONTWTO       CONTINUE MESSAGE ASSEMBLY
         SPACE 1
         LA    RWORK0,$ORTASTM     $ORTPARM ASSEMBLY TIME
         LA    RWORK1,L'$ORTASTM            ASSEMBLY TIME LENGTH
         BAS   RLINK,CONTWTO       CONTINUE MESSAGE ASSEMBLY
         SPACE 1
         LA    RWORK0,$ORTPARM     $ORTPARM EP ADDRESS
         ST    RWORK0,PACKAREA              STORE IN WORK AREA
         LA    RWORK0,PACKAREA   ->$ORTPARM EP ADDRESS
         LA    RWORK1,K4                    EP ADDRESS LN
         BAS   RLINK,EDITHEX0      EXPRESS EP IN HEX W/ NO SPACES
         BAS   RLINK,CONTWTO       CONTINUE MESSAGE ASSEMBLY
         SPACE 1
         LA    RWORK0,$ORTSIZE   ->$ORTPARM SIZE IN BYTES
         LA    RWORK1,L'$ORTSIZE   $ORTPARM SIZE LN
         BAS   RLINK,EDITHEX0      EXPRESS SIZE IN HEX W/ NO SPACES
         BAS   RLINK,ENDWTO        COMPLETE MESSAGE ASSEMBLY
         SPACE 1
         BAS   RLINK,MSGWTO        ISSUE DIAGNOSTIC MESSAGE
BYMSG01  DS   0H
         EJECT  ,
***************************************************************
*                                                             *
*        ISSUE DIAGNOSTIC MESSAGE 51                          *
*        DOCUMENTING THE DATE CALCULATION ROUTINE RESULTS:    *
*                                                             *
***************************************************************
*
*
PUTMSG51 DS   0H
         CLI   XITDFML,ML05        MSGLVL = 05 OR GREATER??
         BL    *+L'*+4             SKIP DIAGNOSTIC MSG IF LT 05
         BAS   RLINK,DATEMSG       GO ISSUE DIAGNOSTIC MSG
         EJECT  ,
***************************************************************
*                                                             *
*        ISSUE DIAGNOSTIC MESSAGES 11, 12, & 13               *
*        LISTING THE EXECUTION VALUES OBTAINED FROM THE       *
*        ENVIRONMENT.                                         *
*                                                             *
***************************************************************
*
*
*
PUTMSGXQ DS    0H
         CLI   XITDFML,ML04        MSGLVL = 04 OR GREATER??
         BL    BYMSGXEQ            SKIP DIAGNOSTIC MSGS IF LT 04
*
*        BEGIN ASSEMBLY OF MSG011.
         LA    RWORK1,MSG011       -> MESSAGE SKELETON
         BAS   RLINK,INITWTO       BEGIN MESSAGE IN WTO AREA
*
*        WRAP UP MESSAGE CONSTRUCTION, AND ISSUE MSG011.
         BAS   RLINK,ENDMSG        FINISH MESSAGE  CONSTRUCTION
         BAS   RLINK,MSGWTO        ISSUE DIAGNOSTIC MESSAGE
*
*        ASSEMBLE MSG012.
         LA    RWORK1,MSG012       -> MESSAGE SKELETON
         BAS   RLINK,INITWTO       BEGIN MESSAGE IN WTO AREA
         LA    RWORK0,XEQPGMNM     -> PROGRAM NAME
         LH    RWORK1,XEQPGMNL        LENGTH OF PROGRAM NAME
         BAS   RLINK,CONTMSG       COPY TO OUTPUT AREA,                X
                                   AND CONTINUE MESSAGE CONSTRUCTION
         LH    RENTRY,XEQNPG       LOAD PERFORMANCE GROUP NUMBER
         BAS   RLINK,EDITBIN       EDIT PGN VALUE INTO MESSAGE
         BAS   RLINK,CONTMSG       COPY TO OUTPUT AREA,                X
                                   AND CONTINUE MESSAGE CONSTRUCTION
*
*        WRAP UP MESSAGE CONSTRUCTION, AND ISSUE MSG012.
         BAS   RLINK,ENDMSG        FINISH MESSAGE  CONSTRUCTION
         BAS   RLINK,MSGWTO        ISSUE DIAGNOSTIC MESSAGE
*
*        BEGIN ASSEMBLY OF MSG013.
         LA    RWORK1,MSG013       -> MESSAGE SKELETON
         BAS   RLINK,INITWTO       BEGIN MESSAGE IN WTO AREA
*
*        DATE=
         L     RENTRY,XEQDATE      LOAD PACKED DECIMAL DATE VALUE
         BAS   RLINK,EDITYDDD      EDIT DATE VALUE INTO MESSAGE
         BAS   RLINK,CONTMSG       COPY TO OUTPUT AREA,                X
                                   AND CONTINUE MESSAGE CONSTRUCTION
         LA    RWORK0,DATEMDY      -> DATE IN "MM/DD/YY" FORMAT
         LA    RWORK1,L'DATEMDY       LENGTH OF "MM/DD/YY" FORMAT DATE
         BAS   RLINK,CONTMSG       COPY TO OUTPUT AREA,                X
                                   AND CONTINUE MESSAGE CONSTRUCTION
*
*        TIME=
         L     RENTRY,XEQTME       LOAD BINARY 1/100 SEC TIME VALUE
         BAS   RLINK,EDITTIMB      EDIT TIME VALUE INTO MESSAGE
         BAS   RLINK,CONTMSG       COPY TO OUTPUT AREA,                X
                                   AND CONTINUE MESSAGE CONSTRUCTION
*
*        DOW=
         L     RENTRY,DATDOW       LOAD DAY-OF-WEEK BINARY VALUE
         LA    RWORK0,DOWTABLE     -> DAY-OF-WEEK NAME TABLE
         LA    RWORK1,L'DOWTABLE      LENGTH OF TABLE ENTRY
         MR    RLINK,RWORK1        OFFSET TO TABLE ENTRY IN RENTRY
         AR    RWORK0,RENTRY       -> DAY-OF-WEEK TABLE ENTRY
         BAS   RLINK,CONTMSG       COPY TO OUTPUT AREA,                X
                                   AND CONTINUE MESSAGE CONSTRUCTION
*
*        WRAP UP MESSAGE CONSTRUCTION, AND ISSUE MSG013.
         BAS   RLINK,ENDMSG        FINISH MESSAGE  CONSTRUCTION
         BAS   RLINK,MSGWTO        ISSUE DIAGNOSTIC MESSAGE
BYMSGXEQ DS    0H
         TITLE '$ORTPARM - SCAN PARM TABLE/DEVELOP PARM STRING'
***************************************************************
*                                                             *
*        THIS SECTION OF THE EXIT SCANS THE PARM TABLE        *
*        AND COMPARES VALUES IN EACH TABLE ENTRY AGAINST      *
*        THE CURRENT EXECUTION ENVIRONMENT.  IF A MATCHING    *
*        PARM TABLE ENTRY IS FOUND, PROGRAM CONTROL VALUES    *
*        IN THE WORK AREA ARE UPDATED AS REQUIRED, AND        *
*        AN INITIAL PARM STRING VALUE IS MOVED TO THE         *
*        PARM STRING CONSTRUCTION AREA IF THE TABLE ENTRY     *
*        CONTAINS A NON-NULL PARM STRING.                     *
*                                                             *
***************************************************************
*
*
PARMSCAN DS    0H                  SCAN THE PARAMETER TABLE
*
*
*        LOAD THE PARAMETER TABLE.
PRMSC01  DS   0H
         LOAD  EPLOC=XIT#DATA,RELATED=(PRMSC95,'LOAD $ORTDATA'),       X
               ERRET=PRMSC02       "LOAD" ABEND ERROR ROUTINE
         STM   RWORK0,RWORK1,XIT#DAT@   STORE AMODE, ADDRESS,          X
                                              APF CODE, & LN(DBLWRDS)
         B     PRMSC03             GO ISSUE MESSAGE FOR MODULE LOADED
         EJECT  ,
*
*
*        IF THE LOAD FAILED FOR $ORTDATA,
*        ISSUE ERROR MESSAGE MSG021, AND BYPASS TABLE PROCESSING.
PRMSC02  DS   0H
         ST    RENTRY,XIT#RSCD     SAVE REASON CODE
         ST    RWORK1,XIT#ABCD     SAVE ABEND  CODE
         SPACE 1
         LA    RWORK1,MSG021       -> MESSAGE SKELETON
         BAS   RLINK,INITWTO       BEGIN MESSAGE ASSEMBLY
         SPACE 1
         LA    RWORK0,XIT#DATA     $ORTDATA MODULE NAME LOADED
         LA    RWORK1,L'XIT#DATA   $ORTDATA MODULE NAME LENGTH
         BAS   RLINK,CONTWTO       CONTINUE MESSAGE ASSEMBLY
         SPACE 1
         LA    RWORK0,XIT#ABCD     $ORTDATA LOAD FAILURE ABEND CODE
         LA    RWORK1,L'XIT#ABCD   $ORTDATA LOAD FAILURE CODE LN
         BAS   RLINK,EDITHEX0      EXPRESS CODE IN HEX W/ NO SPACES
         BAS   RLINK,CONTWTO       CONTINUE MESSAGE ASSEMBLY
         SPACE 1
         LA    RWORK0,XIT#RSCD     $ORTDATA LOAD FAILURE REASON CODE
         LA    RWORK1,L'XIT#RSCD   $ORTDATA LOAD FAILURE CODE LN
         BAS   RLINK,EDITHEX0      EXPRESS CODE IN HEX W/ NO SPACES
         BAS   RLINK,ENDWTO        COMPLETE MESSAGE ASSEMBLY
         SPACE 1
         BAS   RLINK,MSGWTO        ISSUE ERROR MESSAGE
         B     PRMSC99             BYPASS TABLE PROCESSING
         EJECT  ,
*
*
*        IF $ORTDATA WAS SUCCESSFULLY LOADED,
*        ISSUE DIAGNOSTIC MESSAGE MSG020:
PRMSC03  DS   0H
         CLI   XITDFML,ML06        MSGLVL = 06 OR GREATER??
         BL    PRMSC03Z            SKIP DIAGNOSTIC MSG IF LT 06
         LA    RWORK1,MSG020       -> MESSAGE SKELETON
         BAS   RLINK,INITWTO       BEGIN MESSAGE ASSEMBLY
         SPACE 1
         LA    RWORK0,XIT#DATA     $ORTDATA MODULE NAME LOADED
         LA    RWORK1,L'XIT#DATA   $ORTDATA MODULE NAME LENGTH
         BAS   RLINK,CONTWTO       CONTINUE MESSAGE ASSEMBLY
         SPACE 1
         MVC   PACKAREA(L'XIT#DAT@),XIT#DAT@     EP ADDRESS
         NI    PACKAREA,X'7F'                    CLEAR AMODE IND
         LA    RWORK0,PACKAREA     $ORTDATA EP ADDRESS
         LA    RWORK1,L'XIT#DAT@   $ORTDATA EP ADDRESS LN
         BAS   RLINK,EDITHEX0      EXPRESS EP IN HEX W/ NO SPACES
         BAS   RLINK,CONTWTO       CONTINUE MESSAGE ASSEMBLY
         SPACE 1
         XR    RWORK0,RWORK0       CLEAR REGISTER
         ICM   RWORK0,B'0111',XIT#DATL           LN IN DBLWORDS
         SLL   RWORK0,K3                         *8
         ST    RWORK0,PACKAREA                   SAVE
         LA    RWORK0,PACKAREA     $ORTDATA SIZE IN BYTES
         LA    RWORK1,K4           $ORTDATA SIZE LN
         BAS   RLINK,EDITHEX0      EXPRESS SIZE IN HEX W/ NO SPACES
         BAS   RLINK,CONTWTO       CONTINUE MESSAGE ASSEMBLY
         SPACE 1
         LA    RWORK0,XIT#DATF     $ORTDATA APF CODE
         LA    RWORK1,L'XIT#DATF   $ORTDATA APF CODE LN
         BAS   RLINK,EDITHEX0      EXPRESS APF IN HEX W/ NO SPACES
         BAS   RLINK,CONTWTO       CONTINUE MESSAGE ASSEMBLY
         SPACE 1
         LA    RWORK0,=C'24'       ASSUME AMODE 24
         LA    RWORK1,K2           LENGTH OF AMODE DESCRIPTION
         TM    XIT#DAT@,X'80'      AMODE=31 ??
         BZ    *+L'*+4             BRANCH IF AMODE 24
         LA    RWORK0,=C'31'       INDICATE AMODE 31
         BAS   RLINK,ENDWTO        COMPLETE MESSAGE ASSEMBLY
         SPACE 1
         BAS   RLINK,MSGWTO        ISSUE DIAGNOSTIC MESSAGE
PRMSC03Z DS   0H                   PROCEED WITH TABLE PROCESSING
         EJECT  ,
*
*
*        INITIALIZE REGISTERS FOR SCANNING THE #PARM TABLE.
PRMSC09  DS    0H
         L     RPRMPTR,XIT#DAT@    POINT TO BDW PRECEEDING ENTRIES
         LH    RPRMRLN,00(,RPRMPTR)      LOAD TABLE LENGTH
         LA    RENTRY,K4           LOAD CONSTANT
         AR    RPRMPTR,RENTRY      ADJUST FOR
         SR    RPRMRLN,RENTRY      BDW LENGTH
         STM   RPRMPTR,RPRMRLN,XIT#PRMP       SAVE ADDRESS AND LENGTH
*
*
*        BEGIN SCANNING THE #PARM TABLE.
PRMSC10  DS    0H
         USING #PARMMAP,RPRMPTR    PARM TABLE ENTRY ADDRESSABILITY
         LTR   RPRMRLN,RPRMRLN     CHECK REMAINING LENGTH
         BNP   PRMSC90             IF SCAN COMPLETED
         L     RWORK0,XIT#PRM#     LOAD ENTRY COUNTER
         A     RWORK0,F1           UPDATE COUNTER
         ST    RWORK0,XIT#PRM#     AND SAVE UPDATED VALUE
         EJECT  ,
*
*
**********************************************
*                                            *
*        COMPARE THE SYSTEM SMF ID, THE      *
*        CURRENT TIME AND THE DAY-OF-WEEK    *
*        TO THE TABLE ENTRY.                 *
*                                            *
**********************************************
*
*
*        COMPARE THE SYSTEM SMF ID TO THE TABLE ENTRY
PRMSC11  DS    0H
         LA    RWORK0,XEQSMFID     -> SAVED SYSTEM SMF ID
         LA    RWORK1,L'XEQSMFID   LENGTH OF TABLE ENTRY MASK
         LA    RWORK2,#PRMSID      -> SELECTION STRING
         LA    RWORK3,L'#PRMSID    LENGTH OF TABLE ENTRY MASK
         BAS   RLINK,SELSTRFF      GOTO COMPARE SELECTION STRING
         BNE   PRMSC70             REJECT ENTRY IF NO MATCH
*
*
*        THE CURRENT EXECUTION TIME MUST BE >= THE BEGINNING
*        TIME IN THE PARM TABLE ENTRY.
PRMSC12  DS    0H
         CLC   XEQTME,#PRMBGN      COMPARE TO BEGINNING TIME
         BL    PRMSC70             IF LOW, REJECT ENTRY
*
*
*        THE CURRENT EXECUTION TIME MUST BE <  THE ENDING
*        TIME IN THE PARM TABLE ENTRY.
PRMSC13  DS    0H
         CLC   XEQTME,#PRMEND      COMPARE TO ENDING TIME
         BNL   PRMSC70             IF EQ OR HIGH, REJECT ENTRY
*
*
*        THE CURRENT DAY OF THE WEEK MUST BE SPECIFIED
*        IN THE PARM TABLE ENTRY.
PRMSC14  DS    0H
         L     RENTRY,DATDOW       CURRENT DAY-OF-THE-WEEK
         LA    RWORK1,X'80'        BIT FOR TESTING
         SRL   RWORK1,00(RENTRY)   SHIFT TO CORRECT POSITION
         EX    RWORK1,PRMSC14T     TEST FOR BIT PRESENT
         BZ    PRMSC70             IF NOT ON, REJECT ENTRY
         B     PRMSC14Z            CONTINUE WITH NEXT TEST
PRMSC14T TM    #PRMDOW,*-*         TEST FOR DAY-OF-WEEK BIT SET ON
PRMSC14Z DS    0H
         EJECT  ,
*
*
**********************************************
*                                            *
*        COMPARE THE JOB CLASS, JOB NAME     *
*        STEP NAME, PROC STEP NAME, AND      *
*        STEP PROGRAM NAME TO THE TABLE      *
*        ENTRY.                              *
*                                            *
**********************************************
*
*
*        COMPARE THE JOB CLASS TO THE TABLE ENTRY
PRMSC21  DS    0H
         CLC   #PRMJCLS,EEQUALS    ARE ALL CLASSES ACCEPTABLE?????
         BE    PRMSC21Z            BYPASS COMPARES IF YES
         LA    RWORK0,XEQJCLS      -> SAVED JOB  CLASS
         LA    RWORK1,L'XEQJCLS    LENGTH OF JOB CLASS
         LA    RWORK2,#PRMJCLS     -> SELECTION STRING
         LA    RWORK3,L'#PRMJCLS   LENGTH OF TABLE ENTRY MASK
         BAS   RLINK,SELSTRFF      GOTO COMPARE SELECTION STRING
         BNE   PRMSC70             REJECT ENTRY IF NO MATCH
PRMSC21Z DS    0H
*
*
*        COMPARE THE JOB NAME TO THE TABLE ENTRY
PRMSC22  DS    0H
         CLC   #PRMJNAM,EEQUALS    ARE ALL NAMES ACCEPTABLE?????
         BE    PRMSC22Z            BYPASS COMPARES IF YES
         LA    RWORK0,XEQJOBN      -> SAVED JOB  NAME
         LA    RWORK1,L'XEQJOBN    LENGTH OF TABLE ENTRY MASK
         LA    RWORK2,#PRMJNAM     -> SELECTION STRING
         LA    RWORK3,L'#PRMJNAM   LENGTH OF TABLE ENTRY MASK
         BAS   RLINK,SELSTRFF      GOTO COMPARE SELECTION STRING
         BNE   PRMSC70             REJECT ENTRY IF NO MATCH
PRMSC22Z DS    0H
*
*
*        COMPARE THE STEP NAME TO THE TABLE ENTRY
PRMSC23  DS    0H
         CLC   #PRMSNAM,EEQUALS    ARE ALL NAMES ACCEPTABLE?????
         BE    PRMSC23Z            BYPASS COMPARES IF YES
         LA    RWORK0,XEQSTEPN     -> SAVED STEP NAME
         LA    RWORK1,L'XEQSTEPN   LENGTH OF TABLE ENTRY MASK
         LA    RWORK2,#PRMSNAM     -> SELECTION STRING
         LA    RWORK3,L'#PRMSNAM   LENGTH OF TABLE ENTRY MASK
         BAS   RLINK,SELSTRFF      GOTO COMPARE SELECTION STRING
         BNE   PRMSC70             REJECT ENTRY IF NO MATCH
PRMSC23Z DS    0H
*
*
*        COMPARE THE PROC STEP NAME TO THE TABLE ENTRY
PRMSC24  DS    0H
         CLC   #PRMPSNM,EEQUALS    ARE ALL NAMES ACCEPTABLE?????
         BE    PRMSC24Z            BYPASS COMPARES IF YES
         LA    RWORK0,XEQPROCN     -> SAVED STEP NAME
         LA    RWORK1,L'XEQPROCN   LENGTH OF TABLE ENTRY MASK
         LA    RWORK2,#PRMPSNM     -> SELECTION STRING
         LA    RWORK3,L'#PRMPSNM   LENGTH OF TABLE ENTRY MASK
         BAS   RLINK,SELSTRFF      GOTO COMPARE SELECTION STRING
         BNE   PRMSC70             BYPASS ENTRY IF NO MATCH
PRMSC24Z DS    0H
*
*
*        COMPARE THE STEP PROGRAM NAME TO THE TABLE ENTRY.
PRMSC25  DS    0H
         CLC   #PRMPGMN,EEQUALS    ARE ALL NAMES ACCEPTABLE?????
         BE    PRMSC25Z            BYPASS COMPARES IF YES
         LA    RWORK0,XEQPGMNM     -> SAVED STEP PROGRAM NAME
         LA    RWORK1,L'XEQPGMNL   LENGTH OF TABLE ENTRY MASK
         LA    RWORK2,#PRMPGMN     -> SELECTION STRING
         LA    RWORK3,L'#PRMPGMN   LENGTH OF TABLE ENTRY MASK
         BAS   RLINK,SELSTRFF      GOTO COMPARE SELECTION STRING
         BNE   PRMSC70             BYPASS ENTRY IF NO MATCH
PRMSC25Z DS    0H
         EJECT  ,
*
*
**********************************************
*                                            *
*        COMPARE THE PERFORMANCE GROUP NUMBER*
*        LIST IN THE TABLE ENTRY AGAINST     *
*        THE CURRENT JOB'S PERFORMANCE       *
*        GROUP.                              *
*                                            *
**********************************************
*
*
*        DETERMINE WHETHER A PERFORMANCE GROUP NUMBER LIST
*        IS PRESENT IN THE TABLE ENTRY.
PRMSC30  DS    0H
         SR    RWORK6,RWORK6       CLEAR WORK REGISTER
         ICM   RWORK6,B'0011',#PRMNOFF PGN LIST LENGTH OFFSET
         BNP   PRMSC39             IF LIST IS EMPTY
*
*
*
*        PREPARE TO COMPARE THE PGN LIST ENTRIES
*        AGAINST THE CURRENT JOB'S PGN.
PRMSC32  DS    0H
         LA    RWORK2,#PARMMAP(RWORK6)    -> PGN LIST LENGTH
         USING #PRMNLEN,RWORK2     LIST LENGTH  ADDRESSABILITY
         ICM   RWORK6,B'0011',#PRMNLEN LENGTH OF PGN LIST
         LA    RWORK2,#PRMNPG#     -> FIRST  PGN LIST ELEMENT
         USING #PRMNPG#,RWORK2     LIST ELEMENT ADDRESSABILITY
         LA    RWORK3,L'#PRMNPG#   PGN LIST ELEMENT LENGTH
         SR    RWORK7,RWORK7       CLEAR WORK REGISTER
*
*
*        COMPARE THE PGN ELEMENT IN THE PARM TABLE ENTRY LIST
*        AGAINST THE CURRENT JOB'S PGN.
PRMSC33  DS    0H
         ICM   RWORK7,B'0011',#PRMNPG#      DUMMY LIST ELEMENT??
         BZ    PRMSC34             IF DUMMY LIST ELEMENT
         CLM   RWORK7,B'0011',XEQNPG        COMPARE TO CURRENT PGN
         BNE   PRMSC34             IF LIST ELEMENT DOESN'T MATCH
         B     PRMSC39             IF PGN IS LISTED
*
*
*
*        ADVANCE TO THE NEXT PGN LIST ELEMENT
*        AND TEST FOR THE END OF THE LIST.
PRMSC34  DS    0H
         AR    RWORK2,RWORK3       -> NEXT PGN LIST ELEMENT
         SR    RWORK6,RWORK3          DECREMENT LIST LENGTH
         BP    PRMSC33             IF LIST ELEMENTS REMAIN
         DROP  RWORK2
*
*
*        END OF PROCESSING THE PGN LIST.....
*        THE LIST CONTAINED ENTRIES,
*        BUT THE CURRENT JOB'S PGN WAS NOT ONE OF THEM.
PRMSC35  DS    0H
         B     PRMSC70             REJECT ENTRY IF PGN NOT FOUND
*
*
*        END OF PROCESSING.....
*        EITHER A PGN LIST WAS NOT PRESENT
*        IN THE TABLE ENTRY, OR ONE OF THE PGNS IN THE LIST
*        WAS THE CURRENT JOB'S PGN.   CONTINUE TO ACCEPT
*        THE TABLE ENTRY.
PRMSC39  DS    0H
         EJECT  ,
*
*
**********************************************
*                                            *
*        COMPARE THE CORESIDENT JOB NAMES    *
*        LIST IN THE TABLE ENTRY AGAINST     *
*        THE JOB NAMES OF OTHER WORK IN      *
*        THE SYSTEM.                         *
*                                            *
*                                            *
*                                            *
**********************************************
*
*
*        DETERMINE WHETHER A CORESIDENT JOB NAMES LIST
*        IS PRESENT IN THE TABLE ENTRY.
PRMSC40  DS    0H
         SR    RWORK6,RWORK6       CLEAR WORK REGISTER
         ICM   RWORK6,B'0011',#PRMOOFF JOB NAMES LIST LENGTH OFFSET
         BNP   PRMSC49             IF LIST IS EMPTY
*
*
*        INITIALIZE REGISTER VALUES THAT WILL BE USED
*        THROUGHOUT THIS SCAN ROUTINE.
PRMSC41  DS     0H
*
*
*        OUTER LOOP.....
*        PREPARE TO SCAN THE ADDRESS SPACE VECTOR TABLE
PRMSC42  DS     0H
         L     RWORK4,CVTPTR       -> CVT
         USING CVT,RWORK4             CVT ADDRESSABILITY
         L     RWORK4,CVTASVT      -> ADDRESS SPACE VECTOR TABLE
         USING ASVT,RWORK4            ASVT ADDRESSABILITY
         ICM   RWORK5,B'1111',ASVTMAXU   MAX NUMBER OF ADDRESS SPACES
         LA    RWORK4,ASVTENTY     -> 1ST ASCB POINTER ENTRY
         USING ASVTENTY,RWORK4        ASVT ENTRY ADDRESSABILITY
         SLL   RWORK5,K2           CONVERT NUMBER TO LENGTH
         LA    RENTRY,K4           LENGTH OF EACH ENTRY IN ASVT
*
*
*        OUTER LOOP.....
*        PROCESS THE ASCB REFERENCED BY THE CURRENT ASVT ENTRY.
*        IF THE ASCB IS OUR ASCB, OR
*        IF THE ASCB DOES NOT POINT TO A JOB NAME,
*        SKIP THE ENTRY AND ADVANCE TO THE NEXT ENTRY.
PRMSC43  DS     0H
         L     RWORK1,CVTPTR       -> CVT
         USING CVT,RWORK1             CVT ADDRESSABILITY
         L     RWORK1,CVTTCBP      -> TCB/ASCB WORDS
         DROP  RWORK1
         ICM   RWORK1,B'1111',ASCBPOLD(RWORK1) -> CURRENT ASCB
         CLM   RWORK1,B'1111',ASVTENTY       OUR ASCB?
         BE    PRMSC47                       SKIP IT IF YES
         ICM   RWORK1,B'1111',ASVTENTY -> ASCB
         BNP   PRMSC47             IF NO POINTER, ADVANCE TO NEXT ENTRY
         USING ASCB,RWORK1            ASCB ADDRESSABILITY
         ICM   RLINK,B'1111',ASCBJBNI -> JOBNM FOR INITIATED PROGRAMS
         BNZ   *+L'*+4                IF JOB NAME -> IS PRESENT
         ICM   RLINK,B'1111',ASCBJBNS -> JOBNM FOR START/MOUNT/LOGON
         DROP  RWORK1
         BZ    PRMSC47                IF NO JOB NAME POINTER
         MVC   XIT#JOBN,00(RLINK)     COPY JOB NAME
         LA    RWORK0,XIT#JOBN     ->        JOB NAME
         LA    RWORK1,L'XIT#JOBN   LENGTH OF JOB NAME
*
*
*        INNER LOOP.....
*        PREPARE TO COMPARE THE JOB NAMES LIST
*        AGAINST THE JOB NAME ASSOCIATED WITH THE CURRENT ASCB.
PRMSC44  DS     0H
         ICM   RWORK6,B'0011',#PRMOOFF OFFSET TO JOB NAMES LIST LENGTH
         LA    RWORK2,#PARMMAP(RWORK6)    -> JOB NAMES LIST LENGTH
         USING #PRMOLEN,RWORK2     LIST LENGTH  ADDRESSABILITY
         ICM   RWORK6,B'0011',#PRMOLEN LENGTH OF JOB NAMES LIST
         LA    RWORK2,#PRMOJOB     -> FIRST LIST ELEMENT
         USING #PRMOJOB,RWORK2     LIST ELEMENT ADDRESSABILITY
         LA    RWORK3,L'#PRMOJOB   JOB NAMES LIST ELEMENT LENGTH
*
*
*        INNER LOOP.....
*        COMPARE THE JOB NAME ASSOCIATED WITH THE ASCB
*        AGAINST THE JOB NAME ELEMENT IN THE TABLE ENTRY LIST.
PRMSC45  DS     0H
         CLC   #PRMOJOB,EEQUALS    DUMMY LIST ENTRY MATCHING ALL??
         BE    PRMSC49             IF DUMMY LIST ENTRY
         CLI   #PRMOJOB,EBLANK     DUMMY LIST ENTRY MATCHING NONE??
         BE    PRMSC46             IF DUMMY LIST ENTRY
         BAS   RLINK,SELSTRFF      GOTO COMPARE SELECTION STRING
         BNE   PRMSC46             IF NOT A MATCH
         B     PRMSC49             IF A MATCH
*
*
*        INNER LOOP.....
*        ADVANCE TO THE NEXT JOB NAMES LIST ELEMENT,
*        AND TEST FOR THE END OF THE LIST.
PRMSC46  DS     0H
         AR    RWORK2,RWORK3       -> NEXT JOB NAME ELEMENT
         SR    RWORK6,RWORK3          DECREMENT LIST LENGTH
         BP    PRMSC45             IF LIST ELEMENTS REMAIN
         DROP  RWORK2              DROP LIST ELEMENT ADDRESSABILITY
*
*
*        OUTER LOOP.....
*        ADVANCE TO THE NEXT ASVT ENTRY,
*        AND TEST FOR THE END OF THE LIST.
PRMSC47  DS     0H
         AR    RWORK4,RENTRY       -> NEXT ASVT ENTRY
         SR    RWORK5,RENTRY       DECREMENT REMAINING LENGTH
         BP    PRMSC43             IF ENTRIES REMAIN
         DROP  RWORK4              ASVT ENTRY NO LONGER ADDRESSABLE
*
*
*        END OF PROCESSING BOTH LISTS.....
*        NONE OF THE CORESIDENT JOB NAMES
*        WERE FOUND IN THE SYSTEM.
PRMSC48  DS     0H
         B     PRMSC70             REJECT ENTRY IF JOB NAME NOT FOUND
*
*
*        END OF PROCESSING.....
*        EITHER A CORESIDENT JOB NAMES LIST WAS NOT PRESENT
*        IN THE TABLE ENTRY, OR ONE OF THE JOB NAMES IN THE LIST
*        WAS DETECTED IN THE SYSTEM.  CONTINUE TO ACCEPT
*        THE TABLE ENTRY.
PRMSC49  DS    0H
         EJECT  ,
*
*
**********************************************
*                                            *
*        COMPARE THE APPLICABLE DATES        *
*        LIST IN THE TABLE ENTRY AGAINST     *
*        TODAY'S DATE.                       *
*                                            *
*                                            *
**********************************************
*
*
*        DETERMINE WHETHER AN APPLICABLE DATES LIST
*        IS PRESENT IN THE TABLE ENTRY.
PRMSC50  DS    0H
         SR    RWORK6,RWORK6       CLEAR WORK REGISTER
         ICM   RWORK6,B'0011',#PRMDOFF DATE LIST LENGTH OFFSET
         BNP   PRMSC59             IF LIST IS EMPTY
*
*
*
*        PREPARE TO COMPARE THE DATE LIST ENTRIES
*        AGAINST THE CURRENT EXECUTION DATE.
PRMSC51  DS    0H
         LA    RWORK2,#PARMMAP(RWORK6)    -> DATE LIST LENGTH
         USING #PRMDLEN,RWORK2     LIST LENGTH  ADDRESSABILITY
         ICM   RWORK6,B'0011',#PRMDLEN LENGTH OF DATE LIST
         LA    RWORK2,#PRMDATE     -> FIRST DATE LIST ELEMENT
         USING #PRMDATE,RWORK2     LIST ELEMENT ADDRESSABILITY
         LA    RWORK3,L'#PRMDATE   DATE LIST ELEMENT LENGTH
*
*
*        COMPARE THE DATE ELEMENT IN THE PARM TABLE ENTRY LIST
*        AGAINST THE CURRENT EXECUTION DATE.
PRMSC52  DS    0H
         CP    #PRMDATE,PZERO      DUMMY LIST ELEMENT??
         BE    PRMSC54             IF DUMMY LIST ELEMENT
         CP    #PRMDATE,XEQDATE    COMPARE TO CURRENT DATE
         BNE   PRMSC54             IF LIST ELEMENT DOESN'T SPEC TODAY
         B     PRMSC59             IF TODAY IS LISTED
*
*
*
*        ADVANCE TO THE NEXT DATE LIST ELEMENT
*        AND TEST FOR THE END OF THE LIST.
PRMSC54  DS     0H
         AR    RWORK2,RWORK3       -> NEXT DATE LIST ELEMENT
         SR    RWORK6,RWORK3          DECREMENT LIST LENGTH
         BP    PRMSC52             IF LIST ELEMENTS REMAIN
         DROP  RWORK2
*
*
*        END OF PROCESSING THE DATE LIST.....
*        THE LIST CONTAINED ENTRIES,
*        BUT TODAY'S DATE WAS NOT ONE OF THEM.
PRMSC55  DS     0H
         B     PRMSC70             REJECT ENTRY IF DATE NOT FOUND
*
*
*        END OF PROCESSING.....
*        EITHER A DATE LIST WAS NOT PRESENT
*        IN THE TABLE ENTRY, OR ONE OF THE DATES IN THE LIST
*        WAS TODAY'S DATE.  CONTINUE TO ACCEPT
*        THE TABLE ENTRY.
PRMSC59  DS    0H
         EJECT  ,
*
*
**********************************************
*                                            *
*        A MATCHING ENTRY HAS BEEN FOUND,    *
*        UPDATE VALUES IN THE WORK AREA;     *
*        AND BUILD AND ISSUE MSG025.         *
*                                            *
**********************************************
PRMSC60  DS    0H
*
*
*************************************
*                                   *
*        INITALIZE MSG025           *
*                                   *
*************************************
PRMSC61  DS    0H
         CLI   XITDFML,ML07        MSGLVL = 06 OR GREATER??
         BL    PRMSC61Z            DONT INIT MSG IF LOWER
         LA    RWORK1,MSG025       -> MESSAGE SKELETON
         BAS   RLINK,INITWTO          BEGIN MESSAGE IN WTO AREA
         L     RENTRY,XIT#PRM#     PARM TABLE ENTRY NUMBER
         BAS   RLINK,EDITBIN       PUT IN OUTPUT MESSAGE
         BAS   RLINK,CONTWTO       CONTINUE MESSAGE ASSEMBLY
         LA    RWORK0,FBLANK       -> " "
         LA    RWORK1,L'FBLANK     LENGTH OF " "
         BAS   RLINK,UPDTMSG       UPDATE MESSAGE POINTERS
         LR    RWORK7,RWORK2       SAVE CURRENT MSG POINTER
PRMSC61Z DS    0H                  END OF MSG025 INITIALIZATION
*
*
*************************************
*                                   *
*        UPDATE THE MESSAGE LEVEL,  *
*        AND ADD TEXT TO THE MSG025.*
*                                   *
*************************************
PRMSC62  DS    0H
         CLI   #PRMMLVL,ML00       MESSAGE LEVEL VALUE SUPPLIED??
         BE    PRMSC62Z            BYPASS UPDATE IF NOT
*        SAVE PARM TABLE ENTRY VALUE.
         MVC   XITML,#PRMMLVL      UPDATE MESSAGE LEVEL
*        PUT VALUE IN DIAGNOSTIC MSG.
         CLI   XITDFML,ML07        MSGLVL = 06 OR GREATER??
         BL    PRMSC62Z            DONT UPDATE MSG IF NOT
         L     RWORK1,MINUS1       LOAD OFFSET OF "-1"
         BAS   RLINK,POSITWTO      REFRESH MSG POINTERS IN RWORK2&3
         CR    RWORK2,RWORK7       PREVIOUS VALUES IN MSG??
         BE    *+L'*+4+4+4         BRANCH AROUND ", " IF NOT
         LA    RWORK0,FCMBL        -> ", "
         LA    RWORK1,L'FCMBL      LENGTH OF ", "
         BAS   RLINK,UPDTMSG       UPDATE MESSAGE POINTERS
         LA    RWORK0,FMLEQ        -> "ML="
         LA    RWORK1,L'FMLEQ      LENGTH OF "ML="
         BAS   RLINK,UPDTMSG       UPDATE MESSAGE POINTERS
         SR    RENTRY,RENTRY       CLEAR REGISTER
         IC    RENTRY,#PRMMLVL     LOAD VALUE
         BAS   RLINK,EDITBIN       COPY VALUE TO MESSAGE
         BAS   RLINK,UPDTMSG       UPDATE MESSAGE POINTERS
PRMSC62Z DS    0H
*
*
*************************************
*                                   *
*        UPDATE THE $ORTPARM DD USE *
*        AUTHORIZATION CODE,        *
*        AND ADD TEXT TO THE MSG025.*
*                                   *
*************************************
*
*
*        UPDATE THE $ORTPARM DD USE AUTHORIZATION CODE.
PRMSC63  DS    0H
         CLI   #PRM$PRM,$P00       $ORTPARM DD AUTHORIZATION??
         BE    PRMSC63Z            BYPASS UPDATE IF NOT
*        SAVE PARM TABLE ENTRY VALUE.
         MVC   XIT$P,#PRM$PRM      UPDATE $ORTPARM DD AUTHORIZATION
*        PUT VALUE IN DIAGNOSTIC MSG.
         CLI   XITDFML,ML07        MSGLVL = 06 OR GREATER??
         BL    PRMSC63Z            DONT UPDATE MSG IF NOT
         L     RWORK1,MINUS1       LOAD OFFSET OF "-1"
         BAS   RLINK,POSITWTO      REFRESH MSG POINTERS IN RWORK2&3
         CR    RWORK2,RWORK7       PREVIOUS VALUES IN MSG??
         BE    *+L'*+4+4+4         BRANCH AROUND ", " IF NOT
         LA    RWORK0,FCMBL        -> ", "
         LA    RWORK1,L'FCMBL      LENGTH OF ", "
         BAS   RLINK,UPDTMSG       UPDATE MESSAGE POINTERS
         LA    RWORK0,F$PEQ        -> "$P="
         LA    RWORK1,L'F$PEQ      LENGTH OF "$P="
         BAS   RLINK,UPDTMSG       UPDATE MESSAGE POINTERS
         SR    RENTRY,RENTRY       CLEAR REGISTER
         IC    RENTRY,#PRM$PRM     LOAD VALUE
         BAS   RLINK,EDITBIN       COPY VALUE TO MESSAGE
         BAS   RLINK,UPDTMSG       UPDATE MESSAGE POINTERS
PRMSC63Z DS    0H
*
*
*************************************
*                                   *
*        UPDATE THE "MSGDD=SORTMSG" *
*        PROCESSING OPTION CODE,    *
*        AND ADD TEXT TO THE MSG025.*
*                                   *
*************************************
*
*
*        UPDATE THE "MSGDD=SORTMSG" PROCESSING OPTION CODE.
PRMSC64  DS    0H
         CLI   #PRMMSGD,MD00       "MSGDD=SORTMSG" OPTION PROVIDED??
         BE    PRMSC64Z            BYPASS UPDATE IF NOT
*        SAVE PARM TABLE ENTRY VALUE.
         MVC   XITMD,#PRMMSGD      UPDATE "MSGDD=SORTMSG" OPTION VALUE
*        PUT VALUE IN DIAGNOSTIC MSG.
         CLI   XITDFML,ML07        MSGLVL = 06 OR GREATER??
         BL    PRMSC64Z            DONT UPDATE MSG IF NOT
         L     RWORK1,MINUS1       LOAD OFFSET OF "-1"
         BAS   RLINK,POSITWTO      REFRESH MSG POINTERS IN RWORK2&3
         CR    RWORK2,RWORK7       PREVIOUS VALUES IN MSG??
         BE    *+L'*+4+4+4         BRANCH AROUND ", " IF NOT
         LA    RWORK0,FCMBL        -> ", "
         LA    RWORK1,L'FCMBL      LENGTH OF ", "
         BAS   RLINK,UPDTMSG       UPDATE MESSAGE POINTERS
         LA    RWORK0,FMDEQ        -> "MD="
         LA    RWORK1,L'FMDEQ      LENGTH OF "MD="
         BAS   RLINK,UPDTMSG       UPDATE MESSAGE POINTERS
         SR    RENTRY,RENTRY       CLEAR REGISTER
         IC    RENTRY,#PRMMSGD     LOAD VALUE
         BAS   RLINK,EDITBIN       COPY VALUE TO MESSAGE
         BAS   RLINK,UPDTMSG       UPDATE MESSAGE POINTERS
PRMSC64Z DS    0H
*
*
*************************************
*                                   *
*        UPDATE THE PARM STRING     *
*        VALUE,                     *
*        AND ADD TEXT TO THE MSG025.*
*                                   *
*************************************
*
*
*
*        UPDATE THE PARM STRING VALUE AS REQUIRED.
PRMSC66  DS    0H
         SR    RWORK5,RWORK5       CLEAR WORK REGISTER
         ICM   RWORK5,B'0011',#PRMPOFF PARM STRING LENGTH OFFSET
         BNP   PRMSC66Z            IF STRING IS NULL
         LA    RWORK4,#PARMMAP(RWORK5)    -> PARM STRING LENGTH
         USING #PRMPLEN,RWORK4     STRING LENGTH  ADDRESSABILITY
         ICM   RWORK5,B'0011',#PRMPLEN LENGTH OF PARM STRING
         BNP   PRMSC66Z            IF STRING IS NULL
         LA    RWORK0,PARMSTR      -> PARM STRING AREA
         SR    RWORK1,RWORK1       GET MAXLEN FROM PREFIX
*              RWORK4 POINTS TO THE PARM STRING LENGTH IN THE ENTRY
         DROP  RWORK4
         TM    #PRMFLAG,#PRMFUPD   PARM STRING UPDATE??
         BO    PRMSC66C            BRANCH IF UPDATE
*
*
*        THE PARM STRING IS TO BE INITIALIZED
*        WITH THE PARM STRING VALUE FROM THE TABLE ENTRY.
PRMSC66A DS    0H
         LR    RWORK2,RWORK4       -> TABLE ENTRY PARM STRING
         BAS   RLINK,PUTSTRVV      COPY INITIAL PARM STRING
*
*
*        UPDATE MSG025 FOR INITIAL PARM STRING VALUE.
PRMSC66B DS    0H
         CLI   XITDFML,ML07        MSGLVL = 06 OR GREATER??
         BL    PRMSC66Z            DONT UPDATE MSG IF LOWER
         L     RWORK1,MINUS1       LOAD OFFSET OF "-1"
         BAS   RLINK,POSITWTO      REFRESH MSG POINTERS IN RWORK2&3
         CR    RWORK2,RWORK7       PREVIOUS VALUES IN MSG??
         BE    *+L'*+4+4+4         BRANCH AROUND ", " IF NOT
         LA    RWORK0,FCMBL        -> ", "
         LA    RWORK1,L'FCMBL      LENGTH OF ", "
         BAS   RLINK,UPDTMSG       UPDATE MESSAGE POINTERS
         LA    RWORK0,FPRMEQQ      -> "PARM='"
         LA    RWORK1,L'FPRMEQQ    LENGTH OF "PARM='"
         BAS   RLINK,UPDTMSG       UPDATE MESSAGE POINTERS
         LA    RWORK0,K2(,RWORK4)  -> TABLE ENTRY PARM STRING
         LH    RWORK1,00(,RWORK4)     TABLE ENTRY PARM STRING LENGTH
         BAS   RLINK,UPDTMSG       UPDATE MESSAGE POINTERS
         LA    RWORK0,FQUOTE       -> "'"
         LA    RWORK1,L'FQUOTE     LENGTH OF "'"
         BAS   RLINK,UPDTMSG       UPDATE MESSAGE POINTERS
         B     PRMSC66Z            END OF PARM STRING INITIALIZATION
*
*        THE PARM STRING IS TO BE UPDATED
*        WITH THE PARM STRING VALUE FROM THE TABLE ENTRY.
*        IF A PARM STRING IS ALREADY PRESENT,
*        INSERT A SEPARATING COMMA.
PRMSC66C DS    0H
         ICM   RWORK2,B'0011',PARMSTR IS LENGTH > 0 ??
         BNP   PRMSC66D            BRANCH IF NOT
         LA    RWORK2,VCOMMA       ","
         BAS   RLINK,CATSTRVV      CONCATENATE COMMA TO CURRENT PARM
*
*
*        ADD "MSGDD=SORTMSG" TO THE CURRENT PARM STRING.
PRMSC66D DS    0H
         LR    RWORK2,RWORK4       -> TABLE ENTRY PARM STRING
         BAS   RLINK,CATSTRVV      CONCATENATE "SORTMSG" TO PARM
*
*
*        UPDATE MSG025 FOR UPDATED PARM STRING VALUE.
PRMSC66E DS    0H
         CLI   XITDFML,ML07        MSGLVL = 06 OR GREATER??
         BL    PRMSC66Z            DONT UPDATE MSG IF LOWER
         L     RWORK1,MINUS1       LOAD OFFSET OF "-1"
         BAS   RLINK,POSITWTO      REFRESH MSG POINTERS IN RWORK2&3
         CR    RWORK2,RWORK7       PREVIOUS VALUES IN MSG??
         BE    *+L'*+4+4+4         BRANCH AROUND ", " IF NOT
         LA    RWORK0,FCMBL        -> ", "
         LA    RWORK1,L'FCMBL      LENGTH OF ", "
         BAS   RLINK,UPDTMSG       UPDATE MESSAGE POINTERS
         LA    RWORK0,FPRMUEQQ     -> "PARMUPD='"
         LA    RWORK1,L'FPRMUEQQ    LENGTH OF "PARMUPD='"
         BAS   RLINK,UPDTMSG       UPDATE MESSAGE POINTERS
         LA    RWORK0,K2(,RWORK4)  -> TABLE ENTRY PARM STRING
         LH    RWORK1,00(,RWORK4)     TABLE ENTRY PARM STRING LENGTH
         BAS   RLINK,UPDTMSG       UPDATE MESSAGE POINTERS
         LA    RWORK0,FQUOTE       -> "'"
         LA    RWORK1,L'FQUOTE     LENGTH OF "'"
         BAS   RLINK,UPDTMSG       UPDATE MESSAGE POINTERS
         B     PRMSC66Z            END OF PARM STRING UPDATING
*
*
*        END OF PARM STRING UPDATE PROCESSING.
PRMSC66Z DS    0H
*
*
*************************************
*                                   *
*        ISSUE MSG025               *
*                                   *
*************************************
PRMSC69  DS    0H
         CLI   XITDFML,ML07        MSGLVL = 06 OR GREATER??
         BL    PRMSC69Z            DONT ISSUE MSG IF LOWER
         SR    RWORK0,RWORK0       INDICATE
         SR    RWORK1,RWORK1         NO FINAL STRING TO COPY
         BAS   RLINK,ENDWTO        COMPLETE MESSAGE IN WTO AREA
         BAS   RLINK,MSGWTO        ISSUE DIAGNOSTIC MESSAGE
PRMSC69Z DS    0H                  END OF MSG025 PROCESSING
         SPACE 5
         SPACE 5
         B     PRMSC80             ADVANCE TO NEXT ENTRY
         EJECT  ,
*
*
**********************************************
*                                            *
*        THE CURRENT TABLE ENTRY HAS BEEN    *
*        REJECTED.                           *
*                                            *
**********************************************
PRMSC70  DS    0H
         B     PRMSC80             ADVANCE TO NEXT ENTRY
         EJECT  ,
*
*
**********************************************
*                                            *
*                                            *
*        ADVANCE TO THE NEXT TABLE ENTRY,    *
*        AND LOOP TO EXAMINE THE NEXT ENTRY. *
*                                            *
**********************************************
PRMSC80  DS    0H
         LH    RWORK0,#PRMRDW      TABLE ENTRY LENGTH
         AR    RPRMPTR,RWORK0      ADVANCE TO
         SR    RPRMRLN,RWORK0      NEXT ENTRY
         BNP   PRMSC90             IF ALL ENTRIES HAVE BEEN SCANNED
         STM   RPRMPTR,RPRMRLN,XIT#PRMP       SAVE ADDRESS AND LENGTH
         B     PRMSC10             IF ADDITIONAL ENTRIES EXIST
         EJECT  ,
*
*
**********************************************
*                                            *
*                                            *
*        THE TABLE HAS BEEN FULLY SCANNED,   *
*        TABLE PROCESSING IS COMPLETE.       *
*                                            *
**********************************************
PRMSC90  DS    0H
*
*
*        BUILD AND ISSUE DIAGNOSTIC MESSAGE MSG027.
PRMSC91  DS    0H
         CLI   XITDFML,ML04        MSGLVL = 04 OR GREATER??
         BL    PRMSC91Z            SKIP DIAGNOSTIC MSG IF LT 04
*
*
         LA    RWORK1,MSG027       -> MESSAGE SKELETON
         BAS   RLINK,INITWTO       BEGIN MESSAGE IN WTO AREA
*
*        ML=
         SR    RENTRY,RENTRY       CLEAR PARMAETER REGISTER
         IC    RENTRY,XITML        LOAD MESSAGE LEVEL
         BAS   RLINK,EDITBIN       CONVERT TO EBCDIC,                  X
                                   AND COPY TO OUTPUT AREA
         BAS   RLINK,CONTMSG       CONTINUE MESSAGE CONSTRUCTION
*
*        $P=
         SR    RENTRY,RENTRY       CLEAR PARMAETER REGISTER
         IC    RENTRY,XIT$P        LOAD $ORTPARM DD USE AUTH
         BAS   RLINK,EDITBIN       CONVERT TO EBCDIC,                  X
                                   AND COPY TO OUTPUT AREA
         BAS   RLINK,CONTMSG       CONTINUE MESSAGE CONSTRUCTION
*
*        MD=
         SR    RENTRY,RENTRY       CLEAR PARMAETER REGISTER
         IC    RENTRY,XITMD        LOAD MSGDD=SORTMSG PROCESSING OPTN
         BAS   RLINK,EDITBIN       CONVERT TO EBCDIC,                  X
                                   AND COPY TO OUTPUT AREA
         BAS   RLINK,ENDMSG        FINISH MESSAGE  CONSTRUCTION
*
*        ISSUE MSG027
         BAS   RLINK,MSGWTO        ISSUE DIAGNOSTIC MESSAGE
PRMSC91Z DS    0H
*
*
*        BUILD AND ISSUE DIAGNOSTIC MESSAGE MSG028.
PRMSC92  DS    0H
         CLI   XITDFML,ML04        MSGLVL = 04 OR GREATER??
         BL    PRMSC92Z            SKIP DIAGNOSTIC MSG IF LT 04
*
*
         LA    RWORK1,MSG028       -> MESSAGE SKELETON
         BAS   RLINK,INITWTO       BEGIN MESSAGE IN WTO AREA
*
*        PARM="PARM"
         LA    RWORK0,PARMSTR      -> PARM STRING TEXT LENGTH
         BAS   RLINK,LENSTRFV      CONVERT TO FIXED LENGTH STRING PTRS
         BAS   RLINK,ENDMSG        FINISH MESSAGE  CONSTRUCTION
*
*        ISSUE MSG028
         BAS   RLINK,MSGWTO        ISSUE DIAGNOSTIC MESSAGE
PRMSC92Z DS    0H
         EJECT  ,
*
*
**********************************************
*                                            *
*        DELETE THE PARAMETER TABLE MODULE.  *
*        AND ISSUE DIAGNOSTIC MSG029:        *
*                                            *
**********************************************
PRMSC95  DS    0H
         DELETE EPLOC=XIT#DATA,RELATED=(PRMSC01,'DELETE $ORTDATA')
         SPACE 1
         CLI   XITDFML,ML06        MSGLVL = 06 OR GREATER??
         BL    PRMSC95Z            SKIP DIAGNOSTIC MSG IF LT 06
         SPACE 1
         LA    RWORK1,MSG029       -> MESSAGE SKELETON
         BAS   RLINK,INITWTO       BEGIN MESSAGE ASSEMBLY
         SPACE 1
         LA    RWORK0,XIT#DATA     $ORTDATA MODULE NAME LOADED
         LA    RWORK1,L'XIT#DATA   $ORTDATA MODULE NAME LENGTH
         BAS   RLINK,ENDWTO        COMPLETE MESSAGE ASSEMBLY
         SPACE 1
         BAS   RLINK,MSGWTO        ISSUE DIAGNOSTIC MESSAGE
PRMSC95Z DS   0H                   PROCEED WITH TABLE PROCESSING
         SPACE 5
*
*
**********************************************
*                                            *
*        END OF PARAMETER TABLE PROCESSING.  *
*                                            *
**********************************************
PRMSC99  DS    0H
         EJECT  ,
***************************************************************
*                                                             *
*        SCAN THE TIOT FOR THE //SORTMSG DD STATEMENT.        *
*        IF A SORTMSG DD IS PRESENT IN THE TIOT, ADD          *
*        THE PARM OPTION "MSGDD=SORTMSG" TO THE PARM STRING   *
*        VALUE ALREADY IN THE CONSTRUCTION AREA.              *
*                                                             *
***************************************************************
*
*
PRMMDD   DS    0H                  PROCESS "MSGDD=SORTMSG"
         NOP   PRMMDD09      ******ZAP TO BRANCH TO TURN OFF FEATURE**
         CLI   XITMD,MD02          IS PROCESSING REQUIRED?????
         BL    PRMMDD09            IF NOT TO BE PERFORMED
*
*
*        SCAN THE TIOT FOR A "SORTMSG" DD STATEMENT.
PRMMDD01 DS    0H
         LA    RWORK2,XITMSGDD+2   -> DDNAME TO USE FOR SCAN
         BAS   RLINK,LOCDDNAM      GO SCAN FOR DDNAME
         BZ    PRMMDD09            IF DD IS NOT IN THE TIOT
*
*        A "//SORTMSG DD" STATEMANT APPEARS IN THE TIOT.
*        INSPECT THE PARM STRING ALREADY BUILT TO SEE
*        THE "MSGDD=" OPTION IS ALREADY SPECIFIED.
PRMMDD02 DS    0H
         LA    RWORK0,PARMSTR      -> PARM STRING
         LA    RWORK2,VMSGDD       -> "MSGDD=" KEYWORD
         BAS   RLINK,NDXSTRVV      GO SEARCH FOR KEYWORD
         BNZ   PRMMDD09            IF KEYWORD ALREADY SPECIFIED
*
*        IF A PARM STRING IS ALREADY PRESENT,
*        INSERT A SEPARATING COMMA.
PRMMDD03 DS    0H
         ICM   RWORK0,B'0011',PARMSTR IS LENGTH > 0 ??
         BNP   PRMMDD04            BRANCH IF NOT
         LA    RWORK0,PARMSTR      -> PARM STRING CONSTRUCTION AREA
         SR    RWORK1,RWORK1       GET MAXLEN FROM PREFIX
         LA    RWORK2,VCOMMA       ","
         BAS   RLINK,CATSTRVV      CONCATENATE COMMA TO CURRENT PARM
*
*
*        ADD "MSGDD=SORTMSG" TO THE CURRENT PARM STRING.
PRMMDD04 DS    0H
         LA    RWORK0,PARMSTR      -> PARM STRING CONSTRUCTION AREA
         SR    RWORK1,RWORK1       GET MAXLEN FROM PREFIX
         LA    RWORK2,VMSGDD       "MSGDD="
         BAS   RLINK,CATSTRVV      CONCATENATE "MSGDD=" TO PARM
         LA    RWORK2,XITMSGDD     -> DDNAME LENGTH PREFIX
         BAS   RLINK,CATSTRVV      CONCATENATE "SORTMSG" TO PARM
*
*
*        END OF  "MSGDD=SORTMSG" OPTION PROCESSING
PRMMDD09 DS    0H
         EJECT  ,
***************************************************************
*                                                             *
*        IF USE OF THE //$ORTPARM DD STATEMENT IS NOT AUTH,   *
*        SCAN THE TIOT FOR THE //$ORTPARM DD STATEMENT.       *
*        IF A $ORTPARM DD IS PRESENT IN THE TIOT, DYNAMICALLY *
*        UNALLOCATE IT USING SVC 99, AND ISSUE A MESSAGE      *
*        INDICATING THE DD STATEMENT WAS UNALLOCATED          *
*        IF A SUFFICIENTLY HIGH MESSAGE LEVEL IS SET.         *
*                                                             *
***************************************************************
*
*
PRM$PARM DS    0H                  PROCESS $ORTPARM DD STATEMENT
         NOP   PRM$PR90      ******ZAP TO BRANCH TO TURN OFF FEATURE**
         CLI   XIT$P,$P02          IS DD STATEMENT USE AUTHORIZED?????
         BL    PRM$PR90            IF DD AUTHORIZED - SKIP PROCESSING
*
*
*        SCAN THE TIOT FOR A "$ORTPARM" DD STATEMENT.
PRM$PR01 DS    0H
         LA    RWORK2,XITPRMDD+2   -> DDNAME TO USE FOR SCAN
         BAS   RLINK,LOCDDNAM      GO SCAN FOR DDNAME
         BZ    PRM$PR90            IF DD IS NOT IN THE TIOT
         SPACE 3
*
*
*********************************************
*                                           *
*        AN UNAUTHORIZED USE                *
*        OF THE $ORTPARM DD STATEMENT       *
*        HAS BEEN DETECTED -                *
*        ISSUE ERROR MESSAGE MSG031.        *
*                                           *
*********************************************
*
*        CHECK FOR MSG031 REQUIRED.
PRM$PR30 DS    0H
         CLI   XIT$P,$P01          IS ERROR MESSAGE REQUESTED??
         BH    PRM$PR31            IF ERROR MSG ONLY - SKIP PROCESSING
         CLI   XITDFML,ML03        MSGLVL = 03 OR GREATER??
         BL    PRM$PR39            IF ERROR MSG ONLY - SKIP PROCESSING
*
*        BUILD AND ISSUE MSG031.
PRM$PR31 DS    0H
         LA    RWORK1,MSG031       -> MESSAGE SKELETON
         BAS   RLINK,INITWTO       BEGIN MESSAGE IN WTO AREA
         LA    RWORK0,XITPRMDD+2   -> DDNAME
         LH    RWORK1,XITPRMDD        DDNAME LENGTH
         BAS   RLINK,CONTWTO       CONTINUE MESSAGE CONSTRUCTION
         BAS   RLINK,ENDWTO        FINISH MESSAGE  CONSTRUCTION
         BAS   RLINK,MSGWTO        ISSUE DIAGNOSTIC MESSAGE
PRM$PR39 DS    0H
         EJECT  ,
*
*
*********************************************
*                                           *
*        AN UNAUTHORIZED USE                *
*        OF THE $ORTPARM DD STATEMENT       *
*        HAS BEEN DETECTED -                *
*        DYNAMICALLY UNALLOCATE THE         *
*        $ORTPARM DD STATEMENTS IF          *
*        THE AUTHORIZATION CODE IS $P03     *
*        OR GREATER.                        *
*                                           *
*********************************************
*
*
*        SEE IF THE AUTHORIZATION CODE REQUESTS DYNAMIC UNALLOCATION.
PRM$PR40 DS    0H
         CLI   XIT$P,$P03          IS DD STATEMENT TO BE UNALLOCATED??
         BL    PRM$PR90            IF ERROR MSG ONLY - SKIP PROCESSING
*
*
*        INITIALIZE THE SVC99 REQUEST BLOCK POINTER.
PRM$PR41 DS    0H
         LA    RWORK1,XAL99RBP          -> SVC99 REQUEST BLOCK POINTER
         USING S99RBP,RWORK1               RBP ADDRESSABILITY
         LA    RWORK2,XAL99RB           -> SVC99 REQUEST BLOCK
         ST    RWORK2,S99RBPTR          SET SVC99 REQUEST BLOCK PTR
         OI    S99RBPTR,S99RBPND        SET LAST POINTER INDICATOR
*
*
*        INITIALIZE THE SVC99 REQUEST BLOCK.
PRM$PR42 DS    0H
         LR    RWORK1,RWORK2            -> SVC99 REQUEST BLOCK
         USING S99RB,RWORK1                RB  ADDRESSABILITY
         XC    S99RB(S99RBEND-S99RB),S99RB CLEAR REQUEST BLOCK
         MVI   S99RBLN,S99RBEND-S99RB      REQUEST BLOCK LENGTH
         MVI   S99VERB,S99VRBUN            UNALLOCATION VERB
         LA    RWORK2,XAL99TPP          -> TEXT UNIT POINTER LIST
         ST    RWORK2,S99TXTPP             STORE IN REQUEST BLOCK
         DROP RWORK1
*
*
*        SET UP REGISTER VALUES FOR BUILDING THE
*        SVC99 TEXT UNITS AND ASSEMBLING THE TEXT UNIT POINTER LIST.
PRM$PR44 DS    0H
         LA    RWORK4,XAL99TUN          -> TEXT UNIT ASSEMBLY AREA
         LA    RWORK5,XAL99TUL          =  TEXT UNIT ASSEMBLY AREA SZ
         LR    RWORK6,RWORK2            -> SVC99 TEXT UNIT PTR LIST
         LA    RWORK7,XAL99TPL          =  TEXT UNIT PTR LIST SIZE
         USING S99TUPL,RWORK6              TUPL  ADDRESSABILITY
*
*
*        ASSEMBLE THE "DUNDDNAM" KEY.
PRM$PR45 DS    0H
         LR    RWORK3,RWORK4            -> START OF TEXT UNIT
         USING S99TUNIT,RWORK3             TEXT UNIT ADDRESSABILITY
         LA    RWORK0,L'S99TUKEY+L'S99TUNUM      OFFSET TO 1ST PARM FLD
         AR    RWORK4,RWORK0               TO FIRST PARM FIELD
         SR    RWORK5,RWORK0               DECREMENT REMAINING LENGTH
*        ASSEMBLE THE TEXT UNIT KEY.
         LA    RENTRY,DUNDDNAM             LOAD KEY
         SLL   RENTRY,K16                  SHIFT TO TOP HALF OF REG
*        ASSEMBLE THE FIRST PARAMETER.
         USING S99TUFLD,RWORK4             TEXT UNIT PARM ADDR
         AL    RENTRY,F1                   UPDATE PARM COUNT
         LH    RWORK0,XITPRMDD             LOAD DDNAME LENGTH
         MVC   S99TUPRM(K8),XITPRMDD+2     COPY DDNAME
         STCM  RWORK0,B'0011',S99TULEN     STORE DDNAME LENGTH
         LA    RWORK1,L'S99TULEN           ACCOUNT
         AR    RWORK0,RWORK1                  FOR LENGTH FIELD
         AR    RWORK4,RWORK0               TO NEXT AVAILABLE SPACE
         SR    RWORK5,RWORK0               DECREMENT REMAINING LENGTH
         DROP  RWORK4                      DROP TEXT UNIT PARM ADDR
*        STORE THE FINAL KEY AND PARM COUNT VALUES.
         STCM  RENTRY,B'1111',S99TUKEY     STORE TEXT UNIT KEY & PARMCT
         DROP RWORK3                       DROP TEXT UNIT KEY ADDR
*        UPDATE THE TEXT UNIT POINTER LIST.
         ST    RWORK3,S99TUPTR             SET TEXT UNIT POINTER
         LA    RWORK0,L'S99TUPTR           TEXT UNIT PTR LIST ENTRY LN
         AR    RWORK6,RWORK0               TO NEXT AVAILABLE ENTRY
         SR    RWORK7,RWORK0               DECREMENT REMAINING LENGTH
*
*
*        ASSEMBLE THE "DUNUNALC" KEY.
PRM$PR46 DS    0H
         LR    RWORK3,RWORK4            -> START OF TEXT UNIT
         USING S99TUNIT,RWORK3             TEXT UNIT ADDRESSABILITY
         LA    RWORK0,L'S99TUKEY+L'S99TUNUM      OFFSET TO 1ST PARM FLD
         AR    RWORK4,RWORK0               TO FIRST PARM FIELD
         SR    RWORK5,RWORK0               DECREMENT REMAINING LENGTH
*        ASSEMBLE THE TEXT UNIT KEY.
         LA    RENTRY,DUNUNALC             LOAD KEY
         SLL   RENTRY,K16                  SHIFT TO TOP HALF OF REG
*        STORE THE FINAL KEY AND PARM COUNT VALUES.
         STCM  RENTRY,B'1111',S99TUKEY     STORE TEXT UNIT KEY & PARMCT
         DROP RWORK3                       DROP TEXT UNIT KEY ADDR
*        UPDATE THE TEXT UNIT POINTER LIST.
         ST    RWORK3,S99TUPTR             SET TEXT UNIT POINTER
         OI    S99TUPTR,S99TUPLN           FLAG LAST TUPL LIST ENTRY
         LA    RWORK0,L'S99TUPTR           TEXT UNIT PTR LIST ENTRY LN
         AR    RWORK6,RWORK0               TO NEXT AVAILABLE ENTRY
         SR    RWORK7,RWORK0               DECREMENT REMAINING LENGTH
*
*
*        DYNAMICALLY UNALLOCATE THE "$ORTPARM" DD,
*        THEN SCAN THE TIOT AGAIN TO SEE IF ALL OF THE "$ORTPARM"
*        DD STATEMENTS HAVE BEEN UNALLOCATED.
*        IF "$ORTPARM" DD STATEMENTS REMAIN IN THE TIOT,
*        CONTINUE TO ISSUE "DYNALLOC" UNTIL ALL ALL OF THE DD'S
*        HAVE BEEN RELEASED.
PRM$PR47 DS    0H
         DROP  RWORK6                      DROP TEXT UNIT PTR LIST ADDR
         LA    RWORK1,XAL99RBP          -> SVC99 REQUEST BLOCK POINTER
         DYNALLOC ,                        ISSUE SVC 99
         ST    RENTRY,XAL99RC              SAVE RETURN CODE VALUE
         LTR   RENTRY,RENTRY               TEST RETURN CODE
         BNZ   PRM$PR51                    IF ANY ERROR DETECTED
*
*
*
*        IF THE MESSAGE LEVEL IS 02 OR GREATER,
*        ISSUE MSG032 INDICATING THE DD HAS BEEN UNALLOCATED.
PRM$PR48 DS    0H
         CLI   XITDFML,ML03        MSGLVL = 03 OR GREATER??
         BL    PRM$PR49            SKIP DIAGNOSTIC MSG IF LT 03
         LA    RWORK1,MSG032       -> MESSAGE SKELETON
         BAS   RLINK,INITWTO       BEGIN MESSAGE IN WTO AREA
         LA    RWORK0,XITPRMDD+2   -> DDNAME
         LH    RWORK1,XITPRMDD        DDNAME LENGTH
         BAS   RLINK,CONTWTO       CONTINUE MESSAGE CONSTRUCTION
         LA    RWORK0,XNVLDDEO+L'XNVLDDEO-K2  -> TIOT OFFSET
         LA    RWORK1,K2                         TIOT OFFSET BYTE COUNT
         BAS   RLINK,EDITHEX0      EXPRESS TIOT OFFSET IN HEX
         BAS   RLINK,CONTMSG       CONTINUE MESSAGE CONSTRUCTION
         BAS   RLINK,GETTIMEB      GET CURRENT TIME
         LR    RENTRY,RWORK0       COPY TIME VALUE
         BAS   RLINK,EDITTIMB      PUT TIME IN MESSAGE
         BAS   RLINK,ENDMSG        FINISH MESSAGE  CONSTRUCTION
         BAS   RLINK,MSGWTO        ISSUE DIAGNOSTIC MESSAGE
*
*
*
*        SCAN THE TIOT FOR ADDITIONAL $ORTPARM DD STATEMENTS.
*        IF $ORTPARM DD'S ARE STILL FOUND IN THE TIOT,
*        REPEAT THE DYNAMIC UNALLOCATION PROCESS UNTIL ALL OF THEM
*        HAVE BEEN RELEASED.
PRM$PR49 DS    0H
         LA    RWORK2,XITPRMDD+2        -> DDNAME TO USE FOR SCAN
         BAS   RLINK,LOCDDNAM              GO SCAN FOR DDNAME
         BZ    PRM$PR59                    IF DD IS NOT IN THE TIOT
         B     PRM$PR47                    IF DD IS     IN THE TIOT
*
*
*********************************************
*                                           *
*        A DYNAMIC UNALLOCATION ERROR       *
*        HAS OCCURRED.  ISSUE DIAGNOSTIC    *
*        MESSAGES, AND CONTINUE             *
*        PROCESSING.                        *
*                                           *
*********************************************
*
*
*        SET UP AND ISSUE MSG038.
PRM$PR51 DS    0H
         LA    RWORK1,MSG038            -> MESSAGE SKELETON
         BAS   RLINK,INITWTO            BEGIN MESSAGE IN WTO AREA
         LA    RWORK0,XITPRMDD+2        -> DDNAME
         LH    RWORK1,XITPRMDD             DDNAME LENGTH
         BAS   RLINK,CONTWTO            PUT DDNAME IN MSG
         SR    RWORK1,RWORK1            CLEAR RWORK1
         IC    RWORK1,XAL99RB+(S99VERB-S99RB) LOAD VERB CODE
         SLL   RWORK1,K2                *4 FOR INDEX VALUE
         L     RWORK1,MSG038IP(RWORK1)  -> MESSAGE TEXT INSERT
         LA    RWORK0,K2                LOAD CONSTANT
         SR    RWORK1,RWORK0            -> TEXT INSERT LENGTH
         AR    RWORK0,RWORK1            RECOVER -> TEXT INSERT
         LH    RWORK1,00(,RWORK1)       TEXT INSERT LENGTH
         BAS   RLINK,CONTWTO            PUT TEXT IN MSG & CONTINUE
         L     RENTRY,XAL99RC           LOAD RETURN CODE VALUE
         BAS   RLINK,EDITBIN            CONVERT RETURN CODE TO DECIMAL
         BAS   RLINK,CONTWTO            PUT RC IN MSG & CONTINUE
         LA    RWORK0,XAL99RB+(S99ERROR-S99RB)    -> ERRROR REASON CODE
         LA    RWORK1,L'S99ERROR                     LN OF CODE
         BAS   RLINK,EDITHEX0           CONVERT ERROR CODE TO HEX
         BAS   RLINK,CONTWTO            PUT ERROR CODE IN MSG
         LA    RWORK0,XAL99RB+(S99INFO-S99RB)     -> INFO REASON CODE
         LA    RWORK1,L'S99INFO                      LN OF CODE
         BAS   RLINK,EDITHEX0           CONVERT INFO CODE TO HEX
         BAS   RLINK,CONTWTO            PUT ERROR CODE IN MSG
         BAS   RLINK,ENDWTO             COMPLETE MESSAGE ASSEMBLY
         BAS   RLINK,MSGWTO             ISSUE DIAGNOSTIC MESSAGE
*
*
*        INITIALIZE THE DAIRFAIL PARAMETER LIST.
PRM$PR52 DS    0H
         LA    RWORK1,XALDFPRM          -> IKJEFF18 PARAMETER LIST
         LA    RWORK2,XAL99RB           -> SVC 99 REQUEST BLOCK
         LA    RWORK3,XAL99RC           -> SVC 99 RETURN CODE WORD
         LA    RWORK4,XALDFF02          -> -> IKJEFF02 ENTRY POINT
         LA    RWORK5,XALDFIDP          -> SWITCHES & IDP BYTE
         SR    RWORK6,RWORK6            -> CPPL
         SR    RWORK7,RWORK7            -> DFBUFS BUFFER
         STM   RWORK2,RWORK7,XALDFPRM  *INITIALIZE PARAMETER LIST*
         XC    XALDFF02,XALDFF02        INDICATE IKJEFF02 EP UNKNOWN
         MVI   XALDFIDP+0,DFWTP         REQUEST WTP FUNCTION
         MVI   XALDFIDP+1,DFSVC99       INDICATE SVC 99
*
*
*        PASS CONTROL TO DAIRFAIL(IKJEFF18) TO ISSUE THE ERROR MSG.
PRM$PR53 DS    0H
         LINK  EP=IKJEFF18
*
*
*        TERMINATE THIS FUNCTION, AND CONTINUE PROCESSING.
PRM$PR59 DS    0H
         B     PRM$PR90                 FINISHED UNALLOCATING DD'S
*
*
*********************************************
*                                           *
*        $ORTPARM AUTHORIZATION PROCESSING  *
*        IS COMPLETE.                       *
*                                           *
*********************************************
*
*
*        END OF  $ORTPARM AUTHORIZATION PROCESSING.
PRM$PR90 DS    0H
         EJECT  ,
***************************************************************
*                                                             *
*        DETERMINE THE RETURN CODE TO BE RETURNED             *
*        TO SYNCSORT.  IF A PARM STRING HAS BEEN BUILT,       *
*        SET RETURN CODE ZERO.  OTHERWISE SET RETURN CODE     *
*        FOUR.                                                *
*                                                             *
***************************************************************
*
*
PRMSETRC DS    0H                  SET SYNCSORT RETURN CODE
         SR    RWORK1,RWORK1       CLEAR WORK REGISTER
         LA    RWORK2,RC04         ASSUME RETURN CODE 04(= NO PARM)
         CLM   RWORK1,B'0011',PARMSTR CHECK PARM STRING LENGTH
         BE    *+L'*+4             BRANCH IF LENGTH IS ZERO
         LA    RWORK2,RC00         SET RETURN CODE 00(= PARM)
         STH   RWORK2,XITRC        SAVE RETURN CODE IN WORK AREA
         EJECT  ,
***************************************************************
*                                                             *
*        ISSUE MSG099 DISPLAYING THE RETURN CODE              *
*        AND FINAL PARM STRING CONTENTS RETURNED TO           *
*        SYNCSORT.                                            *
*                                                             *
***************************************************************
*
*
*
PRMVAL   DS    0H                  DISPLAY MSG099
         CLI   XITDFML,ML02        MSGLVL = 02 OR GREATER??
         BL    PRMVAL09            SKIP DIAGNOSTIC MSG IF LT 02
*
*
*        BUILD AND ISSUE MSG099.
PRMVAL01 DS    0H                  END OF DISPLAY MSG099
         LA    RWORK1,MSG099       -> MESSAGE SKELETON
         BAS   RLINK,INITWTO       BEGIN MESSAGE IN WTO AREA
*        RC=
         LH    RENTRY,XITRC        LOAD RETURN CODE VALUE
         BAS   RLINK,EDITBIN       CONVERT TO EBCDIC,                  X
                                   AND COPY TO OUTPUT AREA
         BAS   RLINK,CONTMSG       CONTINUE MESSAGE CONSTRUCTION
*        PARM=
         LA    RWORK0,PARMSTR      -> PARM STRING TEXT LENGTH
         BAS   RLINK,LENSTRFV      CONVERT TO FIXED LENGTH STRING PTRS
         BAS   RLINK,CONTMSG       CONTINUE MESSAGE CONSTRUCTION
*        TIME=
         BAS   RLINK,GETTIMEB      GET CURRENT TIME
         LR    RENTRY,RWORK0       COPY TIME VALUE
         BAS   RLINK,EDITTIMB      PUT TIME IN MESSAGE
         BAS   RLINK,ENDMSG        FINISH MESSAGE  CONSTRUCTION
*        ISSUE MSG099
         BAS   RLINK,MSGWTO        ISSUE DIAGNOSTIC MESSAGE
*
*
*
PRMVAL09 DS    0H                  END OF DISPLAY MSG099
         SPACE 5
         B     TERMNATE            GO TO MODULE TERMINATION
         TITLE '$ORTPARM - MODULE CLEANUP AND TERMINATION'
TERMNATE DS    0H                  TERMINATION ROUTINE
***************************************************************
*                                                             *
*        LOAD THE RETURN CODE AND SAVE IT IN A WORK           *
*        REGISTER.  THEN DECHAIN THE SAVE AREA FROM THE       *
*        CALLER'S SAVE AREA, FREEMAIN THE WORK AREA,          *
*        AND RETURN TO THE CALLER WITH THE RETURN CODE        *
*        IN REGISTER 15.                                      *
*                                                             *
***************************************************************
*
*        LOAD THE RETURN CODE AND PARM STRING POINTER.
         LH    RWORK2,XITRC        LOAD RETURN CODE
         L     RWORK3,XITPARMA     LOAD PARM LIST ADDR FOR SORT
*
*        DECHAIN THE SAVE AREA AND PREPARE TO FREEMAIN
         L     R0,WORKSIZE         LOAD    SIZE      FOR FREEMAIN
         LR    R1,RSAVE            WORK AREA ADDRESS TO FREEMAIN
         L     R13,SAVE+4          -> CALLER'S SAVE AREA
         XC    08(04,R13),08(R13)  CLEAR CALLER'S LSA POINTER
*
*        FREEMAIN THE WORK AREA STORAGE
         FREEMAIN RU,              RELEASE THE WORK AREA               X
               LV=(0),             WORK AREA SIZE                      X
               A=(1),              WORK AREA ADDRESS                   X
               SP=SP001            WORK AREA SUBPOOL
*
*        COPY THE RETURN CODE TO R15 AND PARM POINTER TO R1,
*        RESTORE THE CALLER'S REGISTERS AND RETURN.
         LM    R14,R1,12(R13)      RESTORE R14-R1
         LTR   R15,RWORK2          COPY RETURN CODE
         BNZ   *+L'*+2             IF RC=04, NO PARM
         LR    R1,RWORK3           COPY PARM POINTER
         LM    R2,R12,20+4*R2(R13) RESTORE R2-R12
         BR    R14                 RETURN TO SYNCSORT
         TITLE '$ORTPARM - MESSAGE PROCESSING AND WTO/WTOR SUBROUTINES'
***************************************************************
*                                                             *
*                   I N I T M S G                             *
*                                                             *
*        THIS ROUTINE INITIALIZES AND BEGINS THE ASSEMBLY     *
*        OF A MESSAGE IN AN OUTPUT AREA.                      *
*                                                             *
*        INPUT REGISTERS FOR "INITMSG " ARE:                  *
*              RWORK0    =  NOT USED.                         *
*              RWORK1    -> MESSAGE SKELETON IN WTO/WTOR      *
*                           MACRO LIST FORMAT.                *
*              RWORK2    -> MESSAGE OUTPUT AREA.              *
*              RWORK3    =  LENGTH OF THE MESSAGE OUTPUT AREA *
*                           INCLUDING THE FOUR BYTE WTO LENGTH*
*                           AND MCS FLAGS FIELDS.             *
*                                                             *
*        OUTPUT REGISTERS ARE....                             *
*              RWORK0    =  ZERO.                             *
*              RWORK1    =  LENGTH OF THE FIRST CHARACTER     *
*                           STRING BEGINNING WITH A "?",      *
*                           OR ZERO IF NO CHARACTER STRINGS   *
*                           BEGINNING WITH "?" APPEARED IN    *
*                           THE MESSAGE SKELETON.             *
*                                                             *
*              RWORK2    -> ADDRESS OF THE CURRENT MESSAGE    *
*                           BYTE IN THE OUTPUT AREA.  THE     *
*                           CHARACTER STRING BEGINNING WITH   *
*                           "?" HAS BEEN MOVED TO THE OUTPUT  *
*                           AREA, AND THIS REGISTER POINTS    *
*                           TO THE FIRST BYTE OF IT.          *
*                                                             *
*              RWORK3    =  REMAINING LENGTH OF THE OUTPUT    *
*                           AREA.                             *
*                                                             *
***************************************************************
*
*        ENTRY POINT TO INITIALIZE FOR MESSAGE ASSEMBLY
*        IN THE WRITE-TO-OPERATOR MESSAGE AREA FOR WTOR.
INITWTOR DS    0H
         STM   RLINK,RWORK7,SAVMSGIT+0  SAVE RETURN/WORK REGISTERS
WORIT00  DS    0H
         MVI   WTOREPLN,L'WTOREPLY      STORE REPLY AREA LENGTH
         MVC   WTOREPLY,EBLANKS         CLEAR REPLY AREA
         MVC   WTORECB,BZEROS           CLEAR REPLY ECB
         LA    RWORK2,WTOREPLY          ADDRESS OF WTOR REPLY AREA
         LA    RWORK3,WTORECB           ADDRESS OF WTOR ECB
         STM   RWORK2,RWORK3,WTORAREA   STORE IN WTOR PREFIX TO WTO
         OI    WTORAREA,X'80'           SET FLAG FOR MVS/XA
         B     WOMIT00                  CONTINUE WITH WTO INIT
*
*        ENTRY POINT TO INITIALIZE MESSAGE ASSEMBLY
*        IN THE WRITE-TO-OPERATOR MESSAGE AREA FOR WTO.
INITWTO  DS    0H
         STM   RLINK,RWORK7,SAVMSGIT+0  SAVE RETURN/WORK REGISTERS
         MVI   WTOREPLN,00              CLEAR REPLY AREA LENGTH
         XC    WTORAREA,WTORAREA        CLEAR WTOR PREFIX
WOMIT00  DS    0H
         LA    RWORK2,WTOAREA           ADDRESS OF WTO MESSAGE AREA
         LA    RWORK3,L'WPLLGH+L'WPLMCSF+L'WPLTXT  AREA LENGTH
         B     MSGIT00                  CONTINUE MESSAGE ASSEMBLY INIT
*
*
*        GENERAL ENTRY POINT
INITMSG  DS    0H
         STM   RLINK,RWORK7,SAVMSGIT+0  SAVE RETURN/WORK REGISTERS
         MVI   WTOREPLN,00              CLEAR REPLY AREA LENGTH
         XC    WTORAREA,WTORAREA        CLEAR WTOR PREFIX
*
*
*
MSGIT00  DS    0H
         LH    RWORK0,00(,RWORK1)       MESSAGE SKELETON LENGTH
         AR    RWORK0,RWORK1            MESSAGE SKELETON END+1 ADDRESS
         STM   RWORK0,RWORK3,MSGSKLND   SAVE SKELETON/OUTPUT AREA ADDR
*
*        PREPARE REGISTERS FOR PROCESSING MESSAGE TEXT.
MSGIT01  DS    0H
         LR    RWORK4,RWORK2            OUTPUT AREA START ADDRESS
         LR    RWORK5,RWORK3            OUTPUT AREA LENGTH
         LR    RWORK6,RWORK1            MESSAGE SKELETON START ADDRESS
         LH    RWORK7,00(,RWORK1)       MESSAGE SKELETON LENGTH
*
*        UPDATE REGISTERS TO POINT TO THE START OF THE TEXT AREAS,
*        AND THEN SAVE REGISTER VALUES IN THE WORK AREA.
MSGIT02  DS    0H
         LA    RWORK0,L'WPLLGH+L'WPLMCSF       LENGTH+MCSFLAGS
         AR    RWORK4,RWORK0            OUTPUT AREA START ADDRESS
         SR    RWORK5,RWORK0            OUTPUT AREA LENGTH
         AR    RWORK6,RWORK0            MESSAGE SKELETON START ADDRESS
         SR    RWORK7,RWORK0            MESSAGE SKELETON LENGTH
         STM   RWORK4,RWORK5,MSGTXTAD   SAVE STARTING VALUES IN W/A
         STM   RWORK4,RWORK7,MSGOUTAD   SAVE STARTING VALUES IN W/A
*
*        CLEAR THE TEXT PORTION OF THE MESSAGE OUTPUT AREA
*        TO BLANKS.
MSGIT03  DS    0H
         LA    RWORK1,EBLANK            LOAD CLEAR CHARACTER
         SLL   RWORK1,24                SHIFT TO TOP BYTE & SET LN=0
         MVCL  RWORK4,RWORK0            CLEAR TEXT PORTION OF OUTAREA
*
*        COPY THE MESSAGE SKELETON (WITH APPROPRIATE SUBSTITUTION)
*        TO THE OUTPUT AREA UNTIL A STRING IS ENCOUNTERED
*        BEGINNING WITH A "?".
MSGIT04  DS    0H
         BAS   RLINK,MSGSKCPY           COPY SKELETON TO OUTPUT AREA
*
*        RETURN TO THE CALLER WITH REGISTERS RWORK0-RWORK3 SET.
MSGIT05  DS    0H
         LM    RLINK,RENTRY,SAVMSGIT+0            RESTORE REGISTERS
         LM    RWORK4,RWORK7,SAVMSGIT+8+4*RWORK4  RESTORE REGISTERS
         BR    RLINK                    RETURN TO CALLER
         EJECT  ,
***************************************************************
*                                                             *
*                   U P D T M S G                             *
*                                                             *
*        THIS ROUTINE COPIES A STRING THE MESSAGE             *
*        OUTPUT AREA AND RETURNS TO THE CALLER WITHOUT        *
*        COPYING ANY ADDITIONAL SKLETON MESSAGE TEXT.         *
*                                                             *
*        INPUT REGISTERS FOR "UPDTMSG " ARE:                  *
*              RWORK0    :  THE ADDRESS OF THE STRING TO COPY *
*                           TO THE OUTPUT AREA, OR, IF SET TO *
*                           ZERO, INDICATES THE STRING IS     *
*                           ALREADY IN THE OUTPUT AREA, AND   *
*                           THE LENGTH IS IN REGISTER RWORK1. *
*                                                             *
*              RWORK1    :  THE LENGTH OF THE STRING TO COPY  *
*                           TO THE OUTPUT AREA, OR, IF        *
*                           RWORK0 IS SET TO ZERO, THE LENGTH *
*                           OF THE STRING THE CALLER COPIED   *
*                           TO THE OUTPUT AREA.               *
*                                                             *
*              RWORK2    :  NOT USED.                         *
*              RWORK3    :  NOT USED.                         *
*                                                             *
*        OUTPUT REGISTERS ARE....                             *
*              RWORK0    :  ZERO.                             *
*              RWORK1    :  SAME AS ON INPUT.                 *
*                                                             *
*              RWORK2    -> UPDATED ADDRESS OF THE CURRENT    *
*                           MESSAGE BYTE IN THE OUTPUT AREA.  *
*                                                             *
*              RWORK3    =  REMAINING LENGTH OF THE OUTPUT    *
*                           AREA.                             *
*                                                             *
***************************************************************
*
*        ENTRY POINT FOR ALL REFERENCES
UPDTWTO  DS    0H                       FALL THRU TO UPDTMSG
UPDTMSG  DS    0H
*
*        SAVE CALLER'S REGISTERS
         STM   RLINK,RWORK7,SAVMSGUP+0  SAVE RETURN/WORK REGISTERS
*
*        COPY THE CALLER'S STRING TO THE OUTPUT AREA.
         BAS   RLINK,MSGSTCPY           COPY STRING TO OUTPUT AREA
*
*        RETURN TO THE CALLER WITH REGISTERS RWORK0-RWORK3 SET.
         LM    RLINK,RENTRY,SAVMSGUP+0            RESTORE REGISTERS
         LM    RWORK1,RWORK1,SAVMSGUP+8+4*RWORK1  RESTORE REGISTERS
         LM    RWORK4,RWORK7,SAVMSGUP+8+4*RWORK4  RESTORE REGISTERS
         BR    RLINK                    RETURN TO CALLER
         EJECT  ,
***************************************************************
*                                                             *
*                   C O N T M S G                             *
*                                                             *
*        THIS ROUTINE CONTINUES THE ASSEMBLY OF A MESSAGE     *
*        IN AN OUTPUT AREA.                                   *
*                                                             *
*        INPUT REGISTERS FOR "CONTMSG " ARE:                  *
*              RWORK0    :  THE ADDRESS OF THE STRING TO COPY *
*                           TO THE OUTPUT AREA, OR, IF SET TO *
*                           ZERO, INDICATES THE STRING IS     *
*                           ALREADY IN THE OUTPUT AREA, AND   *
*                           THE LENGTH IS IN REGISTER RWORK1. *
*                                                             *
*              RWORK1    :  THE LENGTH OF THE STRING TO COPY  *
*                           TO THE OUTPUT AREA, OR, IF        *
*                           RWORK0 IS SET TO ZERO, THE LENGTH *
*                           OF THE STRING THE CALLER COPIED   *
*                           TO THE OUTPUT AREA.               *
*                                                             *
*              RWORK2    :  NOT USED.                         *
*              RWORK3    :  NOT USED.                         *
*                                                             *
*        OUTPUT REGISTERS ARE....                             *
*              RWORK0    :  ZERO.                             *
*              RWORK1    :  LENGTH OF THE NEXT CHARACTER      *
*                           STRING BEGINNING WITH A "?",      *
*                           OR ZERO IF NO CHARACTER STRINGS   *
*                           BEGINNING WITH "?" APPEARED IN    *
*                           THE MESSAGE SKELETON.             *
*                                                             *
*              RWORK2    -> ADDRESS OF THE CURRENT MESSAGE    *
*                           BYTE IN THE OUTPUT AREA.  THE     *
*                           CHARACTER STRING BEGINNING WITH   *
*                           "?" HAS BEEN MOVED TO THE OUTPUT  *
*                           AREA, AND THIS REGISTER POINTS    *
*                           TO THE FIRST BYTE OF IT.          *
*                                                             *
*              RWORK3    =  REMAINING LENGTH OF THE OUTPUT    *
*                           AREA.                             *
*                                                             *
***************************************************************
*
*        ENTRY POINT FOR ALL REFERENCES
CONTWTO  DS    0H                       FALL THRU TO CONTMSG
CONTMSG  DS    0H
*
*        SAVE CALLER'S REGISTERS
         STM   RLINK,RWORK7,SAVMSGCT+0  SAVE RETURN/WORK REGISTERS
*
*        COPY THE CALLER'S STRING TO THE OUTPUT AREA.
         BAS   RLINK,MSGSTCPY           COPY STRING TO OUTPUT AREA
*
*        COPY THE MESSAGE SKELETON (WITH APPROPRIATE SUBSTITUTION)
*        TO THE OUTPUT AREA UNTIL ANOTHER STRING IS ENCOUNTERED
*        BEGINNING WITH A "?".
         BAS   RLINK,MSGSKCPY           COPY SKELETON TO OUTPUT AREA
*
*        RETURN TO THE CALLER WITH REGISTERS RWORK0-RWORK3 SET.
         LM    RLINK,RENTRY,SAVMSGCT+0            RESTORE REGISTERS
         LM    RWORK4,RWORK7,SAVMSGCT+8+4*RWORK4  RESTORE REGISTERS
         BR    RLINK                    RETURN TO CALLER
         EJECT  ,
***************************************************************
*                                                             *
*                   P O S I T M S G                           *
*                                                             *
*        THIS ROUTINE POSITIONS THE MESSAGE OUTPUT AREA       *
*        POINTERS TO A PARTICULAR TEXT BYTE.                  *
*                                                             *
*        INPUT REGISTERS FOR "POSITMSG" ARE:                  *
*              RWORK0    :  NOT USED.                         *
*              RWORK1    :  THE OFFSET TO THE MESSAGE BYTE    *
*                           FOR WHICH POSITIONING IS DESIRED; *
*                           THE OFFSET TO THE FIRST BYTE OF   *
*                           MESSAGE TEXT IS 00.  TO RETRIEVE  *
*                           THE CURRENT VALUES OF THE         *
*                           MESSAGE TEXT AREA POINTER AND     *
*                           MESSAGE TEXT AREA REMAINING       *
*                           LENGTH, SPECIFY AN OFFSET VALUE   *
*                           OF -1.                            *
*              RWORK2    :  NOT USED.                         *
*              RWORK3    :  NOT USED.                         *
*                                                             *
*        OUTPUT REGISTERS ARE....                             *
*              RWORK0    :  SAME AS ON INPUT.                 *
*              RWORK1    :  ACTUAL OFFSET VALUE.              *
*                                                             *
*              RWORK2    -> UPDATED ADDRESS OF THE CURRENT    *
*                           MESSAGE BYTE IN THE OUTPUT AREA.  *
*                                                             *
*              RWORK3    =  REMAINING LENGTH OF THE OUTPUT    *
*                           AREA.                             *
*                                                             *
***************************************************************
*
*        ENTRY POINT WHEN THE MESSAGE IS BEING BUILT IN THE WTO AREA.
POSITWTO DS    0H                       FALL THRU TO POSITMSG
*
*        GENERAL PURPOSE ENTRY POINT.
POSITMSG DS    0H
         STM   RLINK,RWORK7,SAVMSGPT+0  SAVE RETURN/WORK REGISTERS
*
*        VALIDATE THE CALLER'S INPUT VALUE.
MSGPT00  DS    0H
         LTR   RWORK1,RWORK1            TEST INPUT VALUE
         BNM   MSGPT02                  BRANCH IF NON-NEGATIVE
*
*
*        IF THE USER'S OFFSET VALUE IS NEGATIVE,
*        SUPPLY AN OFFSET WHICH WILL RESULT IN RETURNING THE
*        CURRENT VALUES OF THE TEXT POINTER AND REMAINING LENGTH.
MSGPT01  DS    0H
         L     RWORK1,MSGOUTAD          CURRENT OUTPUT AREA BYTE
         S     RWORK1,MSGTXTAD              ->  START OF MSG TEXT
*
*
*        INSURE THAT THE OFFSET VALUE DOES NOT EXCEED
*        THE LENGTH OF THE TEXT AREA.
MSGPT02  DS    0H
         CL    RWORK1,MSGTXTLN          COMPARE TO LENGTH OF TEXT AREA
         BL    MSGPT03                  BRANCH IF OFFSET IS SMALLER
         L     RWORK1,MSGTXTLN          POINT TO END+1
*
*
*        UPDATE THE MESSAGE AREA VALUES.
MSGPT03  DS    0H
         LM    RWORK2,RWORK3,MSGTXTAD   OUTPUT AREA START ADDRESS/LN
         AR    RWORK2,RWORK1            UPDATE ADDRESS
         SR    RWORK3,RWORK1            DECREMENT REMAINING LENGTH
         STM   RWORK2,RWORK3,MSGOUTAD   UPDATE OUTPUT AREA VALUES
*
*        RETURN TO THE CALLER WITH REGISTERS RWORK2-RWORK3 SET.
MSGPT09  DS    0H
         LM    RLINK,RWORK0,SAVMSGPT+0            RESTORE REGISTERS
         LM    RWORK4,RWORK7,SAVMSGPT+8+4*RWORK4  RESTORE REGISTERS
         BR    RLINK                    RETURN TO CALLER
         EJECT  ,
***************************************************************
*                                                             *
*                   E N D M S G                               *
*                                                             *
*        THIS ROUTINE COMPLETES THE ASSEMBLY OF A MESSAGE     *
*        IN AN OUTPUT AREA.                                   *
*                                                             *
*        INPUT REGISTERS FOR "ENDMSG " ARE:                   *
*              RWORK0    :  THE ADDRESS OF THE STRING TO COPY *
*                           TO THE OUTPUT AREA, OR, IF SET TO *
*                           ZERO, INDICATES THE STRING IS     *
*                           ALREADY IN THE OUTPUT AREA, AND   *
*                           THE LENGTH IS IN REGISTER RWORK1. *
*                                                             *
*              RWORK1    :  THE LENGTH OF THE STRING TO COPY  *
*                           TO THE OUTPUT AREA, OR, IF        *
*                           RWORK0 IS SET TO ZERO, THE LENGTH *
*                           OF THE STRING THE CALLER COPIED   *
*                           TO THE OUTPUT AREA.               *
*                                                             *
*              RWORK2    :  NOT USED.                         *
*              RWORK3    :  NOT USED.                         *
*                                                             *
*        OUTPUT REGISTERS ARE....                             *
*              RWORK0    :  SAME AS ON INPUT.                 *
*              RWORK1    -> START OF THE WTO MESSAGE          *
*                           PARAMETER LIST ASSEMBLED IN THE   *
*                           OUTPUT AREA.                      *
*                                                             *
*              RWORK2    -> ADDRESS OF THE LAST BYTE+1 OF     *
*                           THE OUTPUT MESSAGE.  THIS IS      *
*                           ALSO THE POINTER TO THE START OF  *
*                           THE DESCRIPTOR CODES FOLLOWING    *
*                           THE MESSAGE TEXT IF THE MCS FLAG  *
*                           (BIT 0) WAS SET IN THE MESSAGE    *
*                           SKELETON.                         *
*                                                             *
*              RWORK3    =  LENGTH+4 OF THE OUTPUT MESSAGE.   *
*                           AREA.                             *
*                                                             *
***************************************************************
*
*        ENTRY POINT WHEN THE MESSAGE IS BEING BUILT IN THE WTO AREA.
ENDWTO   DS    0H                       FALL THRU TO ENDMSG
*
*        GENERAL PURPOSE ENTRY POINT.
ENDMSG   DS    0H
         STM   RLINK,RWORK7,SAVMSGND+0  SAVE RETURN/WORK REGISTERS
*
*        START OF ROUTINE.
MSGND00  DS    0H
*
*        COPY THE CALLER'S STRING TO THE OUTPUT AREA.
MSGND01  DS    0H
         BAS   RLINK,MSGSTCPY           COPY STRING TO OUTPUT AREA
         BNP   MSGND03                  IF OUTPUT AREA EXHAUSTED
*
*        COPY THE REMAINDER OF THE MESSAGE SKELETON
*        TO THE OUTPUT AREA.  IF THE COPY IS INTERRUPTED BY A STRING
*        BEGINNING WITH A "?", LEAVE THE "?" IN THE OUTPUT AREA,
*        AND LOOP UNTIL THE SKELTON HAS BEEN COMPLETELY COPIED,
*        OR UNTIL THE OUTPUT AREA IS EXHAUSTED.
MSGND02  DS    0H
         BAS   RLINK,MSGSKCPY           COPY SKELETON TO OUTPUT AREA
         BNP   MSGND03                  IF AT END OF COPY
         SR    RWORK0,RWORK0            THE STRING ("?") IS IN         X
                                        THE OUTPUT AREA.
         B     MSGND01                  LOOP UNTIL ALL COPIED
*
*
*        COMPLETE PROCESSING OF THE OUTPUT AREA.
MSGND03  DS    0H
         LM    RWORK1,RWORK2,MSGSKLBG   LOAD SKELETON & AREA START ADRS
         USING WPL,RWORK2               WTO PARM LIST ADDRESSABILITY
         LM    RWORK4,RWORK7,MSGOUTAD   LOAD CURRENT ADDRESSES
         LR    RWORK3,RWORK4            OUTPUT AREA END+1 ADDRESS
         SR    RWORK3,RWORK2            LENGTH+4 OF OUTPUT MESSAGE
         STH   RWORK3,WPLLGH            STORE LENGTH IN OUTPUT MESSAGE
         TM    WTOREPAD,X'80'           WTOR BEING ASSEMBLED ??
         BZ    *+L'*+6                  BRANCH IF NOT
         MVC   WPL31RLN,WTOREPLN        COPY REPLY LENGTH
         MVC   WPLMCSF,WPLMCSF-WPL(RWORK1)    COPY MCS FLAGS
         AH    RWORK1,WPLLGH-WPL(,RWORK1)  ->CODES IN SKELETON MSG
         TM    WPLMCSF,WPLMCSFA         ?? ROUTE & DESC CODES PRESENT?
         LR    RWORK2,RWORK4            -> ROUTE & DESC CODES AREA
         BZ    MSGND05                  IF NOT PART OF MSG SKELETON
*
*
*        COPY THE FLAGS FIELDS FOLLOWING THE TEXT PORTION.
MSGND04  DS    0H
         MVC   WPLDESC,WPLDESC-WPLFLGS(RWORK1)     COPY DESC CODES
         MVC   WPLROUT,WPLROUT-WPLFLGS(RWORK1)     COPY ROUT CODES
         DROP  RWORK2                   DROP WPL ADDRESSABILITY
*
*
*        RETURN TO THE CALLER WITH REGISTERS RWORK1-RWORK3 SET.
MSGND05  DS    0H
         LM    RLINK,RWORK0,SAVMSGND+0            RESTORE REGISTERS
         LM    RWORK4,RWORK7,SAVMSGND+8+4*RWORK4  RESTORE REGISTERS
         BR    RLINK                    RETURN TO CALLER
         EJECT  ,
***************************************************************
*                                                             *
*                   M S G S K C P Y                           *
*                                                             *
*        THE FOLLOWING IS A MESSAGE ASSEMBLY SUBROUTINE       *
*        USED BY THE FOLLOWING MESSAGE ASSEMBLY ROUTINES:     *
*              INITMSG,                                       *
*              CONTMSG,                                       *
*              ENDMSG.                                        *
*        THIS ROUTINE COPIES TEXT FROM THE USER-SUPPLIED      *
*        MESSAGE SKELETON (IN WTO LIST FORMAT) TO THE         *
*        MESSAGE ASSEMBLY OUTPUT AREA.                        *
*                                                             *
*        INPUT REGISTERS FOR "MSGSKCPY" ARE:                  *
*              RLINK        RETURN ADDRESS TO THE CALLER.     *
*                           TO THE OUTPUT AREA.               *
*              RWORK0    :  NOT SAVED OR RESTORED.            *
*              RWORK1    :  NOT SAVED OR RESTORED.            *
*              RWORK2    :  NOT SAVED OR RESTORED.            *
*              RWORK3    :  NOT SAVED OR RESTORED.            *
*                                                             *
*                                                             *
*        OUTPUT REGISTERS ARE....                             *
*              RWORK0    :  ZERO.                             *
*              RWORK1    =  LENGTH OF THE NEXT CHARACTER      *
*                           STRING BEGINNING WITH "?",        *
*                           OR ZERO IF THE MESSAGE SKELETON   *
*                           HAS BEEN COMPLETELY PROCESSED.    *
*                                                             *
*              RWORK2    -> ADDRESS OF THE CURRENT MESSAGE    *
*                           BYTE IN THE OUTPUT AREA.          *
*                                                             *
*              RWORK3    =  REMAINING LENGTH OF THE OUTPUT    *
*                           AREA.                             *
*                                                             *
***************************************************************
*
*
*        SUBROUTINE ENTRY POINT.
MSGSKCPY DS    0H
         ST    RLINK,SAVMSGSK           SAVE REGISTERS
*
*        LOAD OUTPUT AREA AND MESSAGE SKELETON CONTROL VARIABLES.
MSGSK00  DS    0H
         LM    RWORK4,RWORK7,MSGOUTAD   ADDR/SIZE, ADDR/SIZE
         SR    RWORK0,RWORK0            CLEAR VERIF STRING ADDRESS
         LA    RWORK2,VMSGDLM1          -> DELIMITER TABLE
         BAS   RLINK,SCNSTRFV           GO INIT SCNSTR TRT TABLE
*
*
*        PREPARE REGISTERS FOR SCANNING THE CURRENT STRING
*        IN THE MESSAGE SKELETON.
MSGSK01  DS    0H
         LA    RENTRY,K1                REFRESH CONSTANT VALUE
         SR    RWORK1,RWORK1            ZERO STRING LENGTH COPIED
         LTR   RWORK7,RWORK7            TEST REMAINING SCAN LENGTH
         BNP   MSGSK28                  IF AT END OF SKELETON
         LR    RWORK1,RWORK7            COPY SCAN REMAINING LENGTH
         LR    RWORK2,RWORK6            MAKE SCAN START ACCESSIBLE
         LR    RWORK3,RENTRY            COPY CONSTANT K1
         CLI   00(RWORK2),EBLANK        ARE WE SCANNING A BLANK STRING?
         BE    MSGSK05                  YES - SCAN TO NEXT NON-BLANK
         CLI   00(RWORK2),EQUERY        ARE WE SCANNING A "???" STRING?
         BE    MSGSK04                  YES - SCAN TO NEXT LAST "?"
         CLI   00(RWORK2),EAMPSAND      DOES STRING BEGIN W/ "&" ??
         BNE   MSGSK03                  NO, SCAN TO NEXT DELIMITER
*
*
*        THE STRING BEGINS W/ AN AMPERSAND.
MSGSK02  DS    0H
         AR    RWORK2,RWORK3            ADVANCE SCAN END+1 PAST 1ST "&"
         SR    RWORK1,RWORK3            DECREMENT SCAN LENGTH
         BNP   MSGSK06                  IF "&" IS LAST IN SKELETON,    X
                                        GO PROCESS IT
         CLI   00(RWORK2),EAMPSAND      ARE THERE TWO IN A ROW?????
         BNE   MSGSK03                  BRANCH IF NOT TO SCAN STRING
*        COPY DOUBLE AMPERSAND AS SINGLE AMPERSAND TO OUTPUT.
         AR    RWORK6,RWORK3            ADVANCE SCAN START ADDRESS
         SR    RWORK7,RWORK3            DECREMENT REMAINING LENGTH
         AR    RWORK2,RWORK3            PICK OFF SINGLE "&"
         B     MSGSK06                  TO PROCESS "&" SCANNED
*
*
*        WE ARE AT A NON-BLANK CHARACTER,
*        SCAN TO THE NEXT DELIMITER CHARACTER.
MSGSK03  DS     0H
         LR    RWORK0,RWORK2            COPY SCAN START
         SR    RWORK2,RWORK2            USE ALREADY EXISTING TRT TBL
         BAS   RLINK,SCNSTRFV           SCAN TO NEXT DELIMITER
         LR    RWORK2,RWORK0            RESTORE SCAN START
         AR    RWORK2,RENTRY            ADVANCE TO DELIMITER CHAR
         CR    RWORK2,RWORK6            STOP ON 1ST CHAR SCANNED?
         BH    *+L'*+2                  BRANCH IF DATA WAS SCANNED
         AR    RWORK2,RWORK3            PICK OFF SINGLE DELIMITER
         B     MSGSK06                  TO PROCESS STRING SCANNED
*
*
*        WE ARE AT THE START OF A STRING OF "?" CHARACTERS.
*        ADVANCE TO THE FIRST NON-"?" CHARACTER.
MSGSK04  DS    0H
         LR    RWORK0,RWORK2            COPY VERIFY START
         LA    RWORK2,VQUERY            -> "?" CHARACTER
         BAS   RLINK,VFYCHRFV           ADVANCE TO FIRST NON-"?"
         LR    RWORK2,RWORK0            RESTORE VERIFY START
         LA    RWORK2,00(RENTRY,RWORK2) COMPUTE VERIFY END ADDRESS
         B     MSGSK06                  TO PROCESS STRING SCANNED
*
*
*        WE ARE AT THE START OF A BLANK STRING,
*        ADVANCE TO THE FIRST NON-BLANK CHARACTER.
MSGSK05  DS    0H
         LR    RWORK0,RWORK2            COPY VERIFY START
         LA    RWORK2,VBLANK            -> BLANK CHARACTER
         BAS   RLINK,VFYCHRFV           ADVANCE TO FIRST NON-BLANK
         LR    RWORK2,RWORK0            RESTORE VERIFY START
         LA    RWORK2,00(RENTRY,RWORK2) COMPUTE VERIFY END ADDRESS
         BNZ   MSGSK05B                 BR IF NOT AT END
*        THE BLANK STRING IS AT THE END OF THE MESSAGE SKELETON,
*        SO WE DROP IT FROM THE MESSAGE BEING BUILT.
MSGSK05A DS    0H
         LR    RWORK1,RWORK2            COPY END+1 ADDRESS
         SR    RWORK1,RWORK6            COMPUTE LENGTH SCANNED
         AR    RWORK6,RWORK1            UPDATE SCAN START ADDRESS
         SR    RWORK7,RWORK1            ELIMINATE REMAINING LENGTH
MSGSK05B DS    0H
         B     MSGSK06                  TO PROCESS STRING SCANNED
*
*        IF THE STRING JUST SCANNED BEGAN WITH A "?",
*        OR BEGAN WITH AN "&" AND WAS LONGER THAN ONE BYTE;
*        WE MUST CHECK FURTHER TO SEE IF THE STRING IS FOLLOWED
*        BY A CONCATENATION SYMBOL (".").  IF THE STRING SATISFIES
*        NEITHER OF THE TWO CONDITIONS ABOVE, WE COPY IT AND
*        DO NOT LOOK FOR A CONCATENATION SYMBOL.
MSGSK06  DS    0H
         LA    RENTRY,K1                REFRESH CONSTANT VALUE
         ST    RWORK2,MSGSKLEP          SAVE SCAN END+1 ADDRESS
         LR    RWORK0,RWORK6            START OF STRING SCANNED
         LR    RWORK1,RWORK2            COMPUTE
         SR    RWORK1,RWORK6                LENGTH OF STRING SCANNED
         BNP   MSGSK21                  GO TO COPY IF NULL STRING
         CLI   00(RWORK6),EQUERY        STRING BEGIN WITH "?" ??
         BE    MSGSK20                  TEST CONCATENATION SYMBOL      X
                                        BEFORE COPY IF YES
         CR    RWORK1,RENTRY            IF STRING HAS LENGTH 1,
         BNH   MSGSK21                  GO COPY STRING
         CLI   00(RWORK6),EAMPSAND      STRING BEGIN WITH "&" ??
         BNE   MSGSK21                  IF NOT, GO COPY STRING
*
*
*        BEGIN PROCESSING SYMBOLIC SUBSTITUTION VARIABLES.
MSGSK07  DS    0H
*
*        IF THE SYMBOLIC VARIABLE BEGINNING WITH "&" IS "&MID",
*        COPY THE MESSAGE IDENTIFIER TO THE OUTPUT AREA.
MSGSK10  DS    0H
         C     RWORK1,F4                COMPARE KEYWORD LENGTH
         BNE   MSGSK10Z                 IF NOT THIS KEYWORD
         CLC   K1(L'FMID,RWORK6),FMID   &MID ?????
         BNE   MSGSK10Z                 IF NOT THIS KEYWORD
         LA    RWORK0,MSGIDHDR+2        ADDRESS OF MESSAGE HEADER
         LH    RWORK1,MSGIDHDR          LENGTH  OF MESSAGE HEADER
         B     MSGSK20                  TO COPY MESSAGE HEADER
MSGSK10Z DS    0H
*
*        IF THE SYMBOLIC VARIABLE BEGINNING WITH "&" IS "&SID",
*        COPY THE SYSTEM SMF IDENTIFIER TO THE OUTPUT AREA.
MSGSK11  DS    0H
         C     RWORK1,F4                COMPARE KEYWORD LENGTH
         BNE   MSGSK11Z                 IF NOT THIS KEYWORD
         CLC   K1(L'FSID,RWORK6),FSID   &SID ?????
         BNE   MSGSK11Z                 IF NOT THIS KEYWORD
         LA    RWORK0,XEQSMFID          ADDRESS OF SMF ID
         LA    RWORK1,L'XEQSMFID        LENGTH  OF SMF ID
         B     MSGSK20                  TO COPY MESSAGE HEADER
MSGSK11Z DS    0H
*
*        IF THE SYMBOLIC VARIABLE BEGINNING WITH "&" IS "&C",
*        COPY THE JOB CLASS TO THE OUTPUT AREA.
MSGSK12  DS    0H
         C     RWORK1,F2                COMPARE KEYWORD LENGTH
         BNE   MSGSK12Z                 IF NOT THIS KEYWORD
         CLC   K1(L'FC,RWORK6),FC       &C ?????
         BNE   MSGSK12Z                 IF NOT THIS KEYWORD
         LA    RWORK0,XEQJCLS           ADDRESS OF JOB CLASS
         LA    RWORK1,L'XEQJCLS         LENGTH  OF JOB CLASS
         B     MSGSK20                  TO COPY MESSAGE HEADER
MSGSK12Z DS    0H
*
*        IF THE SYMBOLIC VARIABLE BEGINNING WITH "&" IS "&J",
*        COPY THE JOB NAME TO THE OUTPUT AREA.
MSGSK13  DS    0H
         C     RWORK1,F2                COMPARE KEYWORD LENGTH
         BNE   MSGSK13Z                 IF NOT THIS KEYWORD
         CLC   K1(L'FJ,RWORK6),FJ       &J ?????
         BNE   MSGSK13Z                 IF NOT THIS KEYWORD
         LA    RWORK0,XEQJOBN           ADDRESS OF JOB NAME
         LH    RWORK1,XEQJOBL           LENGTH  OF JOB NAME
         B     MSGSK20                  TO COPY JOB NAME
MSGSK13Z DS    0H
*
*        IF THE SYMBOLIC VARIABLE BEGINNING WITH "&" IS "&S",
*        COPY THE STEP NAME TO THE OUTPUT AREA.
MSGSK14  DS    0H
         C     RWORK1,F2                COMPARE KEYWORD LENGTH
         BNE   MSGSK14Z                 IF NOT THIS KEYWORD
         CLC   K1(L'FS,RWORK6),FS       &S ?????
         BNE   MSGSK14Z                 IF NOT THIS KEYWORD
         LA    RWORK0,XEQSTEPN          ADDRESS OF STEP NAME
         LH    RWORK1,XEQSTEPL          LENGTH  OF STEP NAME
         B     MSGSK20                  TO COPY STEP NAME
MSGSK14Z DS    0H
*
*        IF THE SYMBOLIC VARIABLE BEGINNING WITH "&" IS "&P",
*        COPY THE PROCSTEP NAME TO THE OUTPUT AREA.
MSGSK15  DS    0H
         C     RWORK1,F2                COMPARE KEYWORD LENGTH
         BNE   MSGSK15Z                 IF NOT THIS KEYWORD
         CLC   K1(L'FP,RWORK6),FP       &P ?????
         BNE   MSGSK15Z                 IF NOT THIS KEYWORD
         LA    RWORK0,XEQPROCN          ADDRESS OF PROCSTEP NAME
         LH    RWORK1,XEQPROCL          LENGTH  OF PROCSTEP NAME
         B     MSGSK20                  TO COPY PROCSTEP NAME
MSGSK15Z DS    0H
*
*        IF THE STRING ENDED WITH A "." INDICATING CONCATENATION,
*        ADJUST THE END+1 VALUE TO DISREGARD THE ".".
MSGSK20  DS    0H
         L     RWORK2,MSGSKLEP          RELOAD SCAN END+1 ADDRESS
         C     RWORK2,MSGSKLND          ARE WE AT END OF SKELETON??
         BNL   MSGSK21                  DONT CHECK PERIOD IF AT END
         CLI   00(RWORK2),EPERIOD       STRING END WITH "." ???
         BNE   MSGSK21                  IF NOT, END POINTER IS OK
         AR    RWORK2,RENTRY            ADVANCE PAST ENDING PERIOD
         ST    RWORK2,MSGSKLEP          SAVE NEW SCAN END+1 ADDRESS
*
*        LIMIT THE LENGTH OF THE TEXT TO BE COPIED
*        TO THE REMAINING SPACE AVAILABLE IN THE OUTPUT AREA,
*        AND LEAVE THE RESULTING LENGTH IN RWORK3.
*        THE PRECEEDING STRING SELECTION ROUTINES HAVE PLACED
*        THE ADDRESS AND LENGTH OF THE STRING TO BE COPIED
*        IN REGISTERS RWORK0 & RWORK1.
MSGSK21  DS    0H
         CR    RWORK1,RWORK5            COMPARE TO REMAINING OUTAREA LN
         BL    *+L'*+2                  BRANCH IF SMALLER
         LR    RWORK1,RWORK5            LIMIT COPY TO REMAINING LNGTH
         LR    RWORK2,RWORK4            START FOR COPY TO OUTAREA
         LTR   RWORK3,RWORK1            COPY LENGTH AND TEST
         BNP   MSGSK24                  IF OUTPUT AREA CAPACITY EXH
*
*
*        COPY THE CHARACTER STRING
*        TO THE OUTPUT WORK AREA.
MSGSK22  DS    0H
         MVCL  RWORK2,RWORK0            COPY STRING TO OUTPUT AREA
*
*        DEVELOP THE LENGTH ACTUALLY COPIED
*        AND LEAVE THE LENGTH COPIED IN REGISTER "RWORK1".
MSGSK23  DS    0H
         LR    RWORK1,RWORK2            END+1 OF TEXT COPIED
         SR    RWORK1,RWORK4            CALCULATE LENGTH COPIED TO OUT
*
*
*        UPDATE THE SKELTON TEXT POINTER CONTROL VARIABLES
*        LEAVING THE START ADDRESS AND LENGTH SCANNED
*        FROM THE SKELETON IN REGISTERS RWORK2 & RWORK3.
MSGSK24  DS    0H
         L     RWORK3,MSGSKLEP          LOAD SCAN END+1 ADDRESS
         LR    RWORK2,RWORK6            COPY SCAN START ADDRESS
         SR    RWORK3,RWORK6            COMPUTE STRING LENGTH PROCESSED
         AR    RWORK6,RWORK3            UPDATE SKELETON TEXT POINTER
         SR    RWORK7,RWORK3            DECREMENT REMAINING SKL LNGTH
*
*        TEST THE FIRST CHARACTER OF THE STRING JUST SCANNED
*        FROM THE SKELETON FOR A "?" (CALLER SUBSTITUTION),
*        AND EXIT TO THE CALLING MESSAGE ASSEMBLY ROUTINE IF YES.
MSGSK25  DS    0H
         CR    RWORK1,RENTRY            COMPARE LENGTH TO "1"
         BL    MSGSK26                  IF NO STRING WAS COPIED
         CR    RWORK3,RENTRY            CHECK STRING LENGTH SCANNED
         BL    MSGSK26                  IF NO STRING WAS SCANNED
         CLI   00(RWORK2),EQUERY        STRING BEGIN WITH "?"
         BE    MSGSK28                  IF INTERRUPT FOR CALLER SUBST
*
*        UPDATE THE OUTPUT AREA POINTERS TO REFLECT THE
*        STRING JUST COPIED.
MSGSK26  DS    0H
         AR    RWORK4,RWORK1            ADVANCE OUTPUT AREA POINTER
         SR    RWORK5,RWORK1            DECREMENT REMAINING LENGTH
         B     MSGSK01                  AND LOOP
*
*        THE SCAN AND COPY HAS BEEN INTERRUPTED (BY A STRING
*        BEGINNING WITH A "?"), OR TERMINATED (AT THE END OF THE
*        MESSAGE SKELETON).  UPDATE THE OUTPUT AREA AND
*        MESSAGE SKELETON POINTERS IN THE WORK AREA
*        TO REFLECT THE RESULTS SO FAR.  THE LENGTH OF THE LAST
*        STRING COPIED HAS BEEN PLACED IN REGISTER RWORK1.
MSGSK28  DS    0H
         STM   RWORK4,RWORK7,MSGOUTAD   ADDR/SIZE, ADDR/SIZE
         LR    RWORK2,RWORK4            COPY OUTPUT AREA ADDRESS
         LR    RWORK3,RWORK5            COPY OUTPUT AREA LENGTH
*
*        RETURN TO THE CALLER.
MSGSK29  DS    0H
         SR    RWORK0,RWORK0            SET RWORK0 TO ZERO
         LTR   RWORK1,RWORK1            SET CC FROM STRING LENGTH
         L     RLINK,SAVMSGSK           RESTORE REGISTERS
         BR    RLINK                    RETURN TO THE CALLER
         EJECT  ,
***************************************************************
*                                                             *
*                   M S G S T C P Y                           *
*                                                             *
*        THE FOLLOWING IS A MESSAGE ASSEMBLY SUBROUTINE       *
*        USED BY THE FOLLOWING MESSAGE ASSEMBLY ROUTINES:     *
*              UPDTMSG,                                       *
*              CONTMSG,                                       *
*              ENDMSG.                                        *
*        THIS ROUTINE COPIES A CHARACTER STRING TO THE        *
*        MESSAGE ASSEMBLY AREA AND UPDATES THE MESSAGE        *
*        ASSEMBLY CONTROL VARIABLES ACCORDINGLY.              *
*                                                             *
*        INPUT REGISTERS FOR "MSGSTCPY" ARE:                  *
*              RWORK0    :  THE ADDRESS OF THE STRING TO COPY *
*                           TO THE OUTPUT AREA, OR, IF SET TO *
*                           ZERO, INDICATES THE STRING IS     *
*                           ALREADY IN THE OUTPUT AREA, AND   *
*                           THE LENGTH IS IN REGISTER RWORK1. *
*                                                             *
*              RWORK1    :  THE LENGTH OF THE STRING TO COPY  *
*                           TO THE OUTPUT AREA, OR, IF        *
*                           RWORK0 IS SET TO ZERO, THE LENGTH *
*                           OF THE STRING THE CALLER COPIED   *
*                           TO THE OUTPUT AREA.               *
*                                                             *
*              RWORK2    :  NOT SAVED OR RESTORED.            *
*              RWORK3    :  NOT SAVED OR RESTORED.            *
*                                                             *
*                                                             *
*        OUTPUT REGISTERS ARE....                             *
*              RWORK0    :  ZERO.                             *
*              RWORK1    :  THE NUMBER OF BYTES ACTUALLY      *
*                           COPIED TO THE OUTPUT AREA.        *
*              RWORK2    -> ADDRESS OF THE CURRENT MESSAGE    *
*                           BYTE IN THE OUTPUT AREA.          *
*                                                             *
*              RWORK3    =  REMAINING LENGTH OF THE OUTPUT    *
*                           AREA.                             *
*                                                             *
***************************************************************
*
*
*        SUBROUTINE ENTRY POINT.
MSGSTCPY DS    0H
*
*        LOAD OUTPUT AREA CONTROL VARIABLES
MSGST00  DS    0H
         LM    RWORK4,RWORK5,MSGOUTAD   LOAD MSG AREA ADDRESS/REM LEN
*
*        LIMIT THE LENGTH OF THE STRING COPIED TO THE REMAINING
*        SPACE AVAILABLE IN THE OUTPUT AREA.
MSGST01  DS    0H
         CR    RWORK1,RWORK5            COMPARE TO REMAINING AREA LNGTH
         BL    *+L'*+2                  BRANCH IF SMALLER
         LR    RWORK1,RWORK5            LIMIT COPY TO REMAINING LNGTH
         LTR   RWORK1,RWORK1            TEST INPUT STRING LENGTH
         BNP   MSGST04                  IF NO DATA TO COPY
         LTR   RWORK0,RWORK0            TEST INPUT STRING ADDRESS
         BNP   MSGST03                  IF ALREADY IN OUTPUT AREA
*
*
*        COPY THE STRING TO THE OUTPUT AREA.
MSGST02  DS    0H
         LR    RWORK2,RWORK4            COPY OUTPUT AREA ADDRESS
         LR    RWORK3,RWORK1            COPY LENGTH FOR MVCL
         MVCL  RWORK2,RWORK0            COPY STRING TO THE OUTPUT AREA
         LR    RWORK1,RWORK2            RECOVER
         SR    RWORK1,RWORK4            MVCL COPY LENGTH
*
*        UPDATE THE OUTPUT AREA POINTER CONTROL VARIABLES.
MSGST03  DS    0H
         AR    RWORK4,RWORK1            UPDATE OUTPUT AREA ADDRESS
         SR    RWORK5,RWORK1            DECREMENT REMAINING LENGTH
         STM   RWORK4,RWORK5,MSGOUTAD   UPDATE OUTPUT AREA CONTROL VARS
*
*        SET REGISTER VALUES AND RETURN TO THE CALLER.
MSGST04  DS    0H
         SR    RWORK0,RWORK0            SET RWORK0 TO ZERO
         LR    RWORK2,RWORK4            OUTPUT AREA CURRENT ADDRESS
         LTR   RWORK3,RWORK5            OUTPUT AREA REMAINING LNGTH    X
                                        (AND SET CC FOR CALLER)
         BR    RLINK                    RETURN TO CALLER
         EJECT  ,
*****************************************************************
*                                                               *
*                   M S G W T O                                 *
*                                                               *
*        THIS ROUTINE ISSUES A MESSAGE TO THE OPERATOR.         *
*        THE MESSAGE IS ASSUMED TO HAVE BEEN BUILT IN THE       *
*        WRITE-TO-OPERATOR MESSAGE WORK AREA IN THE WORKING     *
*        STORAGE DSECT.                                         *
*                                                               *
*        INPUT REGISTERS ARE:                                   *
*              RWORK1    ADDRESS OF THE WTO PARAMETER LIST      *
*                        BUILT BY THE MESSAGE ASSEMBLY          *
*                        ROUTINES.                              *
*                                                               *
*              RLINK     RETURN ADDRESS TO THE CALLER           *
*                                                               *
*****************************************************************
MSGWTO   DS    0H
         STM   RLINK,RWORK3,SAVMSGWT+0  SAVE RETURN/WORK REGISTERS
         LA    RWORK1,WTOAREA           ADDRESS OF WTO OUTPUT AREA
         B     MSGWT00                  TO COMMON CODE
MSGWRT   DS    0H
         STM   RLINK,RWORK3,SAVMSGWT+0  SAVE RETURN/WORK REGISTERS
MSGWT00  DS    0H
         WTO   MF=(E,WTOAREA)           WRITE MESSAGE TO THE OPERATOR
         LM    RLINK,RWORK3,SAVMSGWT+0  RELOAD RETURN/WORK REGISTERS
         BR    RLINK                    RETURN TO CALLER
         TITLE '$ORTPARM - GENERAL-PURPOSE DATE CALCULATION SUBROUTINE'
*****************************************************************
*                                                               *
*                   D A T E C A L C                             *
*                                                               *
*        THIS ROUTINE CALCULATES A NUMBER OF VALUES RELEVANT    *
*        TO A DATE VALUE AND RETURNS THE CALCULATED RESULTS     *
*        IN REGISTERS.                                          *
*                                                               *
*        THIS SUBROUTINE EXPECTS REGISTERS AS FOLLOWS....       *
*             RLINK    RETURN ADDRESS TO THE CALLER             *
*             RWORK1   CONTAINS THE DATE IN PACKED DECIMAL      *
*                      IN THE FORM "00YYDDDC"                   *
*                                                               *
*        REGISTERS ON RETURN ARE SET AS FOLLOWS.....            *
*             RLINK    SAME AS ON INPUT                         *
*             RENTRY   DAY OF THE WEEK BINARY VALUE             *
*                      IN THE RANGE 0(SUNDAY)                   *
*                           THROUGH 6(SATURDAY),                *
*             RWORK0   MONTH OF THE YEAR BINARY VALUE 01-12,    *
*             RWORK1   DAY OF THE MONTH  BINARY VALUE 01-31,    *
*             RWORK2   DAY OF THE YEAR   BINARY VALUE           *
*                                                  001-365(6),  *
*             RWORK3   YEAR(YYYY)        BINARY VALUE,          *
*             RWORK4   A "FACTOR" VALUE USED AS THE BASIS FOR   *
*                      CALCULATING DAY OF THE WEEK AND USEFUL   *
*                      FOR CALCULATING THE NUMBER OF DAYS       *
*                      BETWEEN DATES.  IT IS THE NUMBER         *
*                      OF DAYS BETWEEN THE SUPPLIED DATE,       *
*                      AND DECEMBER 25, 1 BC (USING THE         *
*                      GREGORIAN CALENDAR WHICH IS ONLY         *
*                      VALID AFTER SEPTEMBER 11, 1582).         *
*                                                               *
*        THE "FACTOR" VALUE IS CALCULATED AS FOLLOWS.....       *
*            C                       FUDGE FACTOR               *
*            + DDD                   DAY OF THE YEAR            *
*            + 365*YYYY                                         *
*            +INT((YYYY-1)/4)        LEAP YEAR ADJUSTMENT       *
*            -INT((YYYY-1)/100)      CENTURY YEAR ADJUSTMENT    *
*            +INT((YYYY-1)/400)      400 YEAR ADJUSTMENT        *
*        WHERE.....                                             *
*            C      IS AN ADJUSTMENT VALUE CHOSEN TO MAKE       *
*                   THE "FACTOR" VALUE YIELD THE CORRECT        *
*                   DAY OF THE WEEK AS ITS REMAINDER WHEN       *
*                   DIVIDED BY 7.                               *
*            DDD    IS THE JULIAN DAY OF THE YEAR AS RETURNED   *
*                   BY THE "TIME" MACRO.                        *
*            YYYY   IS THE CURRENT YEAR INCLUDING THE CENTURY;  *
*                   E.G., 1900.                                 *
*                                                               *
*        THE DAY OF THE WEEK IS CALCULATED BY DIVIDING THE      *
*        "FACTOR" VALUE BY 7 AND KEEPING THE REMAINDER.  THE    *
*        REMAINDER IS THE DAY OF THE WEEK.                      *
*                                                               *
*        THE MONTH AND DAY OF THE MONTH ARE CALCULATED          *
*        USING A SERIES OF FORMULAS AS FOLLOWS.....             *
*            1.  D2 = DAY OF THE YEAR RELATIVE TO MARCH 1.      *
*                IF DDD <= LAST DAY OF FEB,                     *
*                THEN                                           *
*                    D2 = DDD + 306;                            *
*                IF DDD > LAST DAY OF FEB(MAR-DEC),             *
*                THEN                                           *
*                    D2 = DDD - LAST DAY OF FEB;                *
*            2.  CALCULATE M2 = MONTH(MAR-FEB)                  *
*                    M2 = INT((D2*10-5)/306)                    *
*            3.  CALCULATE MM = MONTH OF THE YEAR.              *
*                MM = M2 + 3;                                   *
*                IF MM > 12                                     *
*                THEN                                           *
*                    MM = MM - 12;                              *
*            4.  CALCULATE D3 = LAST DAY OF PREVIOUS MONTH      *
*                               IN A MARCH-FEB YEAR.            *
*                D3 = INT((M2*306+5)/10);                       *
*            5.  CALCULATE DD = DAY OF THE MONTH.               *
*                DD = D2 - D3;                                  *
*                                                               *
*                                                               *
*****************************************************************
*
*
DATECALC DS    0H                  ROUTINE ENTRY POINT AND LABEL
         STM   RLINK,RWORK7,SAVDATCL SAVE REGISTERS RLINK(R14) - RWORK7
         SR    RWORK2,RWORK2       CLEAR RWORK2
         LR    RWORK3,RWORK1       COPY 00YYDDDC TO RWORK3
         STM   RWORK2,RWORK3,PACKAREA STORE DATE IN DOUBLE WORD
         CVB   RWORK3,PACKAREA     CONVERT YYDDD TO BINARY
         LA    RENTRY,K1000        DIVISOR TO SEPARATE YY FROM DDD
         DR    RWORK2,RENTRY       GET YY IN RWORK3, DDD IN RWORK2
         LA    RWORK3,K1900(,RWORK3) GET YYYY IN RWORK3
         LA    RWORK5,K59     NON LEAP YEAR LAST DAY OF FEB IN RWORK5
*
*        BEGIN DEVELOPING THE "FACTOR" VALUE IN RWORK4.
         LA    RWORK4,06           "C" IN RWORK4
         AR    RWORK4,RWORK2       ADD "DDD"
*
*        ADD THE NUMBER OF DAYS IN THE YEARS PRECEEDING THIS ONE,
*              365*YYYY
*        TO THE FACTOR VALUE BEING DEVELOPED IN RWORK4.
         LA    RENTRY,K365         LOAD MULTIPLIER
         LR    RWORK1,RWORK3       COPY YYYY TO RWORK1
         MR    RWORK0,RENTRY       COMPUTE 365*YYYY
         AR    RWORK4,RWORK1       ADD 365*YYYY TO "FACTOR"
*
*        ADD THE LEAP YEAR ADJUSTMENT VALUE
*              INT((YYYY-1)/4)
*        TO THE FACTOR VALUE BEING DEVELOPED IN RWORK4.
         LA    RENTRY,K4           LOAD DIVISOR
         SR    RWORK0,RWORK0       CLEAR RWORK0
         LR    RWORK1,RWORK3       COPY YYYY TO RWORK1
         DR    RWORK0,RENTRY       DIVIDE YYYY BY 4, QUOTIENT IN RWORK1
         LTR   RWORK0,RWORK0       CHECK REMAINDER FOR ZERO
         BNZ   *+L'*+2+4           BR IF NOT DIVISIBLE BY 4
         BCTR  RWORK1,0            DECREMENT QOUTIENT BY 1
         LA    RWORK5,1(,RWORK5)   ADD 1 TO LAST DAY OF FEB
         AR    RWORK4,RWORK1       ADD INT((YYYY-1)/4) TO "FACTOR"
*
*        SUBTRACT THE CENTURY YEAR ADJUSTMENT VALUE
*              INT((YYYY-1)/100)
*        TO THE FACTOR VALUE BEING DEVELOPED IN RWORK4.
*        CENTURY YEARS DIVISIBLE BY 100 BUT NOT 400 (1800,1900)
*        ARE NOT LEAP YEARS.
         LA    RENTRY,K100         LOAD DIVISOR
         SR    RWORK0,RWORK0       CLEAR RWORK0
         LR    RWORK1,RWORK3       COPY YYYY TO RWORK1
         DR    RWORK0,RENTRY       # OF CENTURY YEARS PRECEEDING       X
                                   IN RWORK1.
         LTR   RWORK0,RWORK0       CHECK REMAINDER FOR ZERO
         BNZ   *+L'*+2+2           BR IF NOT DIVISIBLE BY 100
         BCTR  RWORK1,0            DECREMENT QUOTIENT BY 1
         BCTR  RWORK5,0            ADJUST FOR NON LEAP YEAR
         SR    RWORK4,RWORK1       SUBTR INT((YYYY-1)/100) FRM "FACTOR"
*
*        ADD BACK THE 400 CENTURY YEAR ADJUSTMENT VALUE
*              INT((YYYY-1)/400)
*        TO THE FACTOR VALUE BEING DEVELOPED IN RWORK4.
*        CENTURY YEARS DIVISIBLE BY 400 (1600,2000)
*        ARE LEAP YEARS.
         LA    RENTRY,K400         LOAD DIVISOR
         SR    RWORK0,RWORK0       CLEAR RWORK0
         LR    RWORK1,RWORK3       COPY YYYY TO RWORK1
         DR    RWORK0,RENTRY       # OF 400 CENTURY YEARS PRECEEDING   X
                                   IN RWORK1.
         LTR   RWORK0,RWORK0       CHECK REMAINDER FOR ZERO
         BNZ   *+L'*+2+4           BR IF NOT DIVISIBLE BY 400
         BCTR  RWORK1,0            DECREMENT QUOTIENT BY 1
         LA    RWORK5,1(,RWORK5)   ADD 1 TO LAST DAY OF FEB
         AR    RWORK4,RWORK1       ADD INT((YYYY-1)/400) TO "FACTOR"
*
*        CALCULATE THE DAY OF THE WEEK FROM THE FACTOR VALUE
*        AND SAVE THE RESULT TEMPORARILY IN RWORK6.
         LA    RENTRY,K7           LOAD DIVISOR
         SR    RWORK0,RWORK0       CLEAR RWORK0
         LR    RWORK1,RWORK4       COPY "FACTOR" VALUE TO RWORK1
         DR    RWORK0,RENTRY       RWORK0 REMAINDER = DAY OF THE WEEK
         LR    RWORK6,RWORK0       SAVE DAY OF THE WEEK IN RWORK6
*
*
*        BEGIN CALCULATING THE MONTH AND DAY OF THE MONTH.
*
*
*        1.    CALCULATE D2 AND LEAVE ITS VALUE IN RWORK5
         LCR   RWORK5,RWORK5       MAKE LAST DAY OF FEB NEGATIVE
         AR    RWORK5,RWORK2       D2 = DDD - LAST DAY OF FEB IN RWORK5
         BP    *+L'*+4             BRANCH IF IN MARCH THRU DEC
         LA    RWORK5,K306(,RWORK2)     D2 = DDD + 306(DEC 31)
*
*
*        2.    CALCULATE M2 = INT((D2*10-5)/306)
*              AND LEAVE ITS VALUE IN RWORK1.
         LA    RWORK1,K10          MULTIPLIER OF 10
         MR    RWORK0,RWORK5       10*D2 IN RWORK1, RWORK0 SET TO ZERO
         S     RWORK1,F5           10*D2-5 IN RWORK1
         D     RWORK0,F306         GET M2 IN RWORK1
*
*
*        3.    CALCULATE MM = MONTH OF THE YEAR
*              AND SAVE ITS VALUE IN RENTRY.
         LA    RWORK0,K12          LOAD COMPARAND
         LA    RENTRY,03(,RWORK1)  MM = M2 + 3 IN RENTRY
         CR    RENTRY,RWORK0       IS MM GT 12?
         BNH   *+L'*+2             BRANCH IF 12 OR LESS
         SR    RENTRY,RWORK0       OTHERWISE SUBTRACT 12 FOR JAN/FEB
*
*
*        4.    CALCULATE D3 = LAST DAY OF PREVIOUS MONTH
*              USING THE M2 VALUE STILL IN RWORK1,
*              AND END UP WITH D3 IN RWORK1.
         M     RWORK0,F306         306*M2 IN RWORK1, RWORK0 SET TO ZERO
         A     RWORK1,F5           306*M2 + 5 IN RWORK1
         D     RWORK0,F10          D3 = INT((306*M2+5)/10) IN RWORK1
*
*
*        5.    CALCULATE DD = DAY OF CURRENT MONTH = D2 - D3
*              USING THE D2 VALUE STILL IN RWORK5,
*              AND END UP WITH DD IN RWORK1.
         LCR   RWORK1,RWORK1       MAKE D3 VALUE NEGATIVE
         AR    RWORK1,RWORK5       D2 - D3 IN RWORK1
*
*
*        ESTABLISH AND SAVE FINAL REGISTER VALUES
         LR    RWORK0,RENTRY       PUT MM IN RWORK0
         LR    RENTRY,RWORK6       PUT DAY OF WEEK IN RENTRY
         STM   RENTRY,RWORK4,DATDOW SAVE COMPUTED VALUES
*
*
*        CONVERT THE DAY-OF-THE-WEEK, YEAR, AND DAY OF THE YEAR
*        TO EBCDIC AND SAVE THEM IN THE WORK AREA.
         LR    RWORK7,RENTRY       PUT DAY OF WEEK IN RWORK6
         LA    RENTRY,K100         LOAD MULTIPLIER
         MR    RWORK6,RENTRY       DAY OF WEEK*100
         MR    RWORK6,RENTRY                  *100 (= DOW*10000)
         AR    RWORK7,RWORK3       +YYYY
         LA    RWORK6,K1000        LOAD MULTIPLIER
         MR    RWORK6,RWORK6       *1000
         AR    RWORK7,RWORK2       +DDD
         CVD   RWORK7,PACKAREA     CONVERT WYYYYDDD TO PACKED DECIMAL
         OI    PACKAREA+L'PACKAREA-1,X'0F'  EBCDIC ZONE
         UNPK  PACK1(09),PACKAREA  UNPACK TO GET WWYYYYDDD
         MVC   DATEWW,PACK1+00     COPY VALUE TO WORK AREA
         MVC   DATEYYYY,PACK1+02   COPY VALUE TO WORK AREA
         MVI   DATEP1,C'.'         SEPARATE "YYYY" FROM "DDD"
         MVC   DATEDDD,PACK1+02+04 COPY VALUE TO WORK AREA
*
*
*        CONVERT THE MONTH AND DAY-OF-THE-MONTH
*        TO EBCDIC AND SAVE THEM IN THE WORK AREA.
         LR    RWORK7,RWORK0       PUT MONTH IN RWORK7
         MR    RWORK6,RENTRY       MONTH*100
         AR    RWORK7,RWORK1       +DD
         CVD   RWORK7,PACKAREA     CONVERT MMDD TO PACKED DECIMAL
         OI    PACKAREA+L'PACKAREA-1,X'0F'  EBCDIC ZONE
         UNPK  PACK1(04),PACKAREA  UNPACK TO GET MMDD
         MVC   DATEMM,PACK1+00     COPY VALUE TO WORK AREA
         MVI   DATES1,C'/'         SEPARATE "MM" FROM "DD"
         MVC   DATEDD,PACK1+02     COPY VALUE TO WORK AREA
         MVI   DATES2,C'/'         SEPARATE "DD" FROM "YY"
         MVC   DATEYY,DATEYYYY+2   SAVE LAST 2 DIGITS OF YEAR
*
*
*        RETURN TO THE CALLER.
DATRTRN  DS    0H
         L     RLINK,SAVDATCL      RELOAD RETURN REGISTER VALUE
         LM    RLINK,RLINK,SAVDATCL+0             RELOAD REGISTERS
         LM    RENTRY,RWORK4,DATDOW          LOAD COMPUTED VALUES
         LM    RWORK5,RWORK7,SAVDATCL+8+4*RWORK5  RELOAD REGISTERS
         BR    RLINK               RETURN TO CALLER
         EJECT  ,
*****************************************************************
*                                                               *
*                   D A T E M S G                               *
*                                                               *
*        SUBROUTINE TO BUILD AND ISSUE A DIAGNOSTIC MESSAGE     *
*        REPORTING THE VALUES CALCULATED BY THE "DATECALC"      *
*        SUBROUTINE.                                            *
*                                                               *
*        INPUT REGISTERS ARE:                                   *
*              RLINK     RETURN ADDRESS TO THE CALLER           *
*              RENTRY    NOT USED                               *
*              RWORK1    NOT USED                               *
*              RWORK2    NOT USED                               *
*              RWORK3    NOT USED                               *
*                                                               *
*        OUTPUT REGISTERS ARE:                                  *
*              RWORK0    UNCHANGED                              *
*              RWORK1    UNCHANGED                              *
*              RWORK2    UNCHANGED                              *
*              RWORK3    UNCHANGED                              *
*              RLINK     RETURN ADDRESS TO THE CALLER           *
*              RENTRY    UNCHANGED                              *
*                                                               *
*****************************************************************
*
DATEMSG  DS    0H
         STM   RLINK,RWORK5,SAVDTMSG     SAVE CALLER'S REGISTERS
*
*
*        INITIALIZE MESSAGE IN WTO AREA
         LA    RWORK1,MSG051       POINT TO MESSAGE SKELETON
         BAS   RLINK,INITWTO       CONSTRUCT MESSAGE IN WTO AREA
*
*        DOW
         LA    RWORK0,DATEWW       -> EBCDIC DAY-OF-WEEK
         BAS   RLINK,CONTWTO       COPY VALUE TO MESSAGE
*
*        MM
         LA    RWORK0,DATEMM       -> EBCDIC MM
         BAS   RLINK,CONTWTO       COPY VALUE TO MESSAGE
*
*        DD
         LA    RWORK0,DATEDD       -> EBCDIC DD
         BAS   RLINK,CONTWTO       COPY VALUE TO MESSAGE
*
*        DDD
         LA    RWORK0,DATEDDD      -> EBCDIC DDD
         BAS   RLINK,CONTWTO       COPY VALUE TO MESSAGE
*
*        YYYY
         LA    RWORK0,DATEYYYY     -> EBCDIC YYYY
         BAS   RLINK,CONTWTO       COPY VALUE TO MESSAGE
*
*        "FACTOR"
         L     RENTRY,DATFACT      LOAD FACTOR VALUE
         BAS   RLINK,EDITBIN       EDIT FACTOR VALUE,                  X
                                   AND COPY TO OUTPUT AREA
         BAS   RLINK,ENDWTO        COMPLETE THE MESSAGE
*
*        ISSUE THE DIAGNOSTIC MESSAGE
         BAS   RLINK,MSGWTO        ISSUE DIAGNOSTIC MSG
*
*        RETURN TO THE CALLER.
         LM    RLINK,RWORK5,SAVDTMSG         RELOAD REGISTERS
         BR    RLINK               RETURN TO CALLER
         TITLE '$ORTPARM - EXECUTION ENVIRONMENT INTERFACE ROUTINES'
*****************************************************************
*                                                               *
*                   L O C D D N A M                             *
*                                                               *
*        SUBROUTINE TO SCAN THE TIOT AND LOCATE A SPECIFIED     *
*        DD ENTRY.  THE ADDRESS OF THE TIOD DD ENTRY,           *
*        IF FOUND, IS RETURNED IN REGISTER -RENTRY-.            *
*                                                               *
*        INPUT REGISTERS ARE:                                   *
*              RLINK     RETURN ADDRESS TO THE CALLER           *
*              RENTRY    NOT USED                               *
*              RWORK0    NOT USED                               *
*              RWORK1    NOT USED                               *
*              RWORK2    ADDRESS OF AN 8-BYTE CHARACTER STRING  *
*                        CONTAINING THE DDNAME ARGUMENT.        *
*              RWORK3    NOT USED                               *
*                                                               *
*        OUTPUT REGISTERS ARE:                                  *
*              RWORK0    UNCHANGED                              *
*              RWORK1    UNCHANGED                              *
*              RWORK2    UNCHANGED                              *
*              RWORK3    UNCHANGED                              *
*              RLINK     RETURN ADDRESS TO THE CALLER           *
*              RENTRY    ADDRESS OF THE TIOT ENTRY, OR ZERO     *
*                                                               *
*****************************************************************
*
LOCDDNAM DS    0H                  LOCATE SPECIFIC DDNAME
         STM   RLINK,RWORK5,SAVLOCDD     SAVE CALLER'S REGISTERS
         LA    RWORK5,CMPSTRFF     -> STRING COMPARE ROUTINE
         B     LOCDD00             GO INIT REGS
LOCDDSTR DS    0H                  LOCATE GENERIC DDNAME
         STM   RLINK,RWORK5,SAVLOCDD     SAVE CALLER'S REGISTERS
         LA    RWORK5,SELSTRFF     -> STRING COMPARE ROUTINE
         B     LOCDD00             GO INIT REGS
LOCDDCNT DS    0H                  CONTINUE SCANNING TIOT W/ PREV PARMS
         STM   RLINK,RWORK5,SAVLOCDD     SAVE CALLER'S REGISTERS
         LM    RENTRY,RWORK5,XNVLDDRG+4  RELOAD LOOP REGISTERS
         LTR   RENTRY,RENTRY       AT TIOT END??
         BNZ   LOCDD03             ADVANCE TO NEXT ENTRY IF NOT
         B     LOCDD04             IF AT END ALREADY
*
*
*        POINT TO THE FIRST DD ENTRY IN THE TIOT.
LOCDD00  DS    0H
         L     RENTRY,EXTRTIOT     POINT TO THE TIOT
         USING TIOT1,RENTRY        TIOT ADDRESSABILITY
         LA    RENTRY,TIOENTRY     POINT TO FIRST TIOT DD ENTRY
         USING TIOENTRY,RENTRY     TIOT ENTRY ADDRESSABILITY
         LA    RWORK1,K8           DDNAME LENGTH
         LR    RWORK3,RWORK1       DDNAME LENGTH
*
*
*        TEST THE CURRENT DD ENTRY FOR THE DDNAME
LOCDD01  DS    0H
         ICM   RWORK4,B'1111',TIOENTRY IF FIRST 04 BYTES OF ENTRY
         BZ    LOCDD04             ARE ZERO, WE ARE AT END
         SRA   RWORK4,K24          IF LENGTH IS ZERO,
         BZ    LOCDD04             WE ARE AT END
         LA    RWORK0,TIOEDDNM     -> DDNAME
*
*
*        COMPARE THE TIOT ENTRY TO THE CHARACTER STRING ARGUMENT
LOCDD02  DS    0H
         BASR  RLINK,RWORK5        COMPARE DDNAMES
         BE    LOCDD05             IF DDNAME FOUND
*
*
*        ADVANCE TO THE NEXT TIOT ENTRY AND LOOP
LOCDD03  DS    0H                             SUBTRACT:
         AR    RENTRY,RWORK4       ADD LENGTH TO ADVANCE TO NEXT ENTRY
         B     LOCDD01             LOOP TO PROCESS NEXT ENTRY
*
*        THE MATCHING TIOT DD ENTRY WAS NOT FOUND,
*        RETURN A ZERO ADDRESS VALUE IN REGISTER -RENTRY-, AND
*        PLACE  A ZERO OFFSET  VALUE IN REGISTER -RWORK0-.
LOCDD04  DS    0H
         SR    RENTRY,RENTRY       SET NULL TIOT ENTRY ADDRESS
         LR    RWORK0,RENTRY       SET NULL TIOT ENTRY OFFSET
         B     LOCDD06             TO RETURN REGISTER VALUES
*
*        THE MATCHING TIOT DD ENTRY WAS FOUND,
*        RETURN ITS ADDRESS IN REGISTER -RENTRY-,
*        AND PUT ITS OFFSET IN REGISTER -RWORK0-.
LOCDD05  DS    0H
         LR    RWORK0,RENTRY       CALCULATE
         S     RWORK0,EXTRTIOT     TIOT ENTRY OFFSET
*
*        TIOT SEARCH PROCESSING IS COMPLETE.
*        SAVE REGISTERS TO ALLOW CONTINUATION OF THE SEARCH TO LOCATE
*        MULTIPLE DD ENTRIES WITH THE SAME NAME, AND RETURN
*        THE TIOT ENTRY ADDRESS TO THE CALLER IN REGISTER -RENTRY-.
LOCDD06  DS    0H
         STM   RENTRY,RWORK5,XNVLDDRG+4            SAVE LOOP REGISTERS
         LM      RLINK,RLINK,SAVLOCDD+0              RESTORE REGISTERS
         LM    RWORK0,RWORK5,SAVLOCDD+8+4*RWORK0     RESTORE REGISTERS
         LTR   RENTRY,RENTRY       SET CC FOR CALLER
         BR    RLINK               RETURN TO CALLER
         DROP  RENTRY              TIOT ENTRY NO LONGER ADDRESSABLE
         EJECT  ,
*****************************************************************
*                                                               *
*                   G E T J O B C L                             *
*                                                               *
*        SUBROUTINE TO RETURN THE JES2 JOB CLASS                *
*        OF THE EXECUTING JOB.                                  *
*                                                               *
*        INPUT REGISTERS ARE:                                   *
*              RLINK     RETURN ADDRESS TO THE CALLER           *
*              RENTRY    NOT USED.                              *
*              RWORK1    NOT USED.                              *
*                                                               *
*        OUTPUT REGISTERS ARE:                                  *
*              RENTRY    CONTAINS THE JOB CLASS IN THE          *
*                        LOW ORDER BYTE.                        *
*              RLINK     RETURN ADDRESS TO THE CALLER.          *
*                                                               *
*****************************************************************
*
GETJOBCL DS    0H
         L     RENTRY,CVTPTR       LOAD POINTER TO THE CVT
         USING CVT,RENTRY          CVT ADDRESSABILITY
         L     RENTRY,CVTTCBP      -> TCB/ASCB WORDS
         L     RENTRY,TCBPOLD(,RENTRY)    -> OUR TCB
         LR    RWORK0,RENTRY          ***DEBUG***
         USING TCB,RENTRY          TCB ADDRESSABILITY
         L     RENTRY,TCBJSCB      -> JOB STEP CONTROL BLOCK (24-BIT)
         N     RENTRY,NMSK0FFF        CLEAR FLAG BITS
         LR    RWORK1,RENTRY          ***DEBUG***
         USING IEZJSCB,RENTRY      JSCB ADDRESSABILITY
         L     RENTRY,JSCBSSIB     -> SUBSYSTEM IDENTIFICATION BLK
         LR    RWORK2,RENTRY          ***DEBUG***
         USING SSIB,RENTRY         SSIB ADDRESSABILITY
         ICM   RENTRY,B'1111',SSIBSUSE DOES SJB EXIST????????
         LR    RWORK3,RENTRY          ***DEBUG***
         BZ    GETJC09             BRANCH IF NOT
         USING SJBDSECT,RENTRY     SJB ADDRESSABILITY
         ICM   RENTRY,B'1000',SJBJCLAS    JOB CLASS BYTE FROM SJB
         DROP  RENTRY              NO LONGER POINTS TO ANYTHING
         SRL   RENTRY,K24          MOVE TO LOW-ORDER BYTE
GETJC09  DS    0H
         BR    RLINK               RETURN TO CALLER
         EJECT  ,
*****************************************************************
*                                                               *
*                   G E T N P G                                 *
*                                                               *
*        SUBROUTINE TO DETERMINE THE PERFORMANCE GROUP          *
*        NUMBER CURRENTLY ASSIGNED TO THE EXECUTING JOB,        *
*        (OUCBNPG), AND RETURN ITS VALUE TO THE CALLER.         *
*                                                               *
*        INPUT REGISTERS ARE:                                   *
*              RLINK     RETURN ADDRESS TO THE CALLER           *
*              RENTRY    NOT USED.                              *
*              RWORK1    NOT USED.                              *
*                                                               *
*        OUTPUT REGISTERS ARE:                                  *
*              RENTRY    CONTAINS THE PERFORMANCE GROUP NUMBER. *
*              RLINK     RETURN ADDRESS TO THE CALLER.          *
*                                                               *
*****************************************************************
*
GETNPG   DS    0H
         STM   RLINK,RWORK5,SAVGTNPG    SAVE REGISTERS
         SPACE 1
*        IN MVS/XA (MVS/SP2.1.0), THE OUCB WAS MOVED
*        ABOVE THE 16 MEGABYTE LINE.  TO ACCOMMODATE
*        THIS CHANGE, WE MUST SWITCH TO 31-BIT
*        ADDRESSING MODE TO ACCESS THE OUCB.
*        NOTE THAT THE CODING TECHNIQUE USED IN THIS ROUTINE
*        IS DESIGNED TO WORK INDEPENDENTLY OF WHETHER
*        $ORTPARM IS EXECUTING IN 24-BIT OR 31-BIT MODE
*        WHEN THIS ROUTINE IS ENTERED.          03/17/84 TJA
         SETAMODE RWORK2,RWORK3,   SWITCH TO 31-BIT ADDRESSING         X
               AMASK=OMSK8000,AMODE=31
         SPACE 1
         L     RLINK,CVTPTR        LOAD POINTER TO THE CVT
         USING CVT,RLINK           CVT ADDRESSABILITY
         L     RLINK,CVTTCBP       -> TCB/ASCB WORDS
         L     RLINK,ASCBPOLD(,RLINK)    -> OUR ASCB
         USING ASCB,RLINK          ASCB ADDRESSABILITY
         L     RLINK,ASCBOUCB            -> OUR OUCB
         USING OUCB,RLINK          OUCB ADDRESSABILITY
         SR    RENTRY,RENTRY       CLEAR RENTRY
         SR    RWORK4,RWORK4       CLEAR RWORK4
         LA    RWORK5,B'1111'      LOAD BIT MASK
         SLL   RWORK5,K32-K4       ALIGN FOR SLDL
         SLDL  RWORK4,L'OUCBNPG    GET BIT MASK FOR ICM
         EX    RWORK4,GETNPGIC     LOAD OUCBNPG
         DROP  RLINK               OUCB NO LONGER ADDRESSABLE
         SETAMODE RWORK2,RWORK3,   RETURN TO MODULE'S AMODE            X
               AMASK=OMSK8000,AMODE=RESET
         LM     RLINK,RLINK,SAVGTNPG              RELOAD REGISTERS
         LM    RWORK0,RWORK5,SAVGTNPG+8+4*RWORK0  RELOAD REGISTERS
         BR    RLINK               RETURN TO CALLER
         SPACE 2
GETNPGIC ICM   RENTRY,*-*,OUCBNPG-OUCB(RLINK)     LOAD OUCBNPG
         EJECT  ,
*****************************************************************
*                                                               *
*                   G E T P G M N M                             *
*                                                               *
*        SUBROUTINE TO RETURN THE STEP PROGRAM NAME             *
*        OF THE EXECUTING JOB STEP.                             *
*                                                               *
*        INPUT REGISTERS ARE:                                   *
*              RLINK     RETURN ADDRESS TO THE CALLER           *
*              RENTRY    NOT USED.                              *
*              RWORK1    NOT USED.                              *
*                                                               *
*        OUTPUT REGISTERS ARE:                                  *
*              RLINK     RETURN ADDRESS TO THE CALLER.          *
*              RWORK0    CONTAINS THE FIRST FOUR BYTES OF THE   *
*                        PROGRAM NAME.                          *
*              RWORK1    CONTAINS THE LAST FOUR BYTES OF THE    *
*                        PROGRAM NAME.                          *
*                                                               *
*****************************************************************
*
GETPGMNM DS    0H
         L     RWORK3,CVTPTR       LOAD POINTER TO THE CVT
         USING CVT,RWORK3          CVT ADDRESSABILITY
         L     RWORK3,CVTTCBP      -> TCB/ASCB WORDS
         L     RWORK3,TCBPOLD(,RWORK3)    -> OUR TCB
         USING TCB,RWORK3          TCB ADDRESSABILITY
         L     RWORK3,TCBJSCB      -> JOB STEP CONTROL BLOCK (24-BIT)
         N     RWORK3,NMSK0FFF        CLEAR FLAG BITS
         USING IEZJSCB,RWORK3      JSCB ADDRESSABILITY
         LM    RWORK0,RWORK1,JSCBPGMN   LOAD PROGRAM NAME FROM JSCB
         DROP  RWORK3              JSCB NO LONGER ADDRESSABLE
         BR    RLINK               RETURN TO CALLER
         EJECT  ,
*****************************************************************
*                                                               *
*                   G E T S M F I D                             *
*                                                               *
*        SUBROUTINE TO RETURN THE SMF ID OF THE SYSTEM ON       *
*        WHICH THE JOB IS EXECUTING.                            *
*                                                               *
*        INPUT REGISTERS ARE:                                   *
*              RLINK     RETURN ADDRESS TO THE CALLER           *
*              RENTRY    NOT USED.                              *
*              RWORK1    NOT USED.                              *
*                                                               *
*        OUTPUT REGISTERS ARE:                                  *
*              RENTRY    CONTAINS THE SYSTEM'S SMF ID           *
*              RLINK     RETURN ADDRESS TO THE CALLER           *
*                                                               *
*****************************************************************
*
GETSMFID DS    0H
         L     RENTRY,CVTPTR       LOAD POINTER TO THE CVT
         USING CVT,RENTRY          CVT ADDRESSABILITY
         L     RENTRY,CVTSMCA      LOAD POINTER TO SMCA
         USING SMCABASE,RENTRY     SMCA ADDRESSABILITY
         ICM   RENTRY,B'1111',SMCASID LOAD SYSTEM'S SMF ID
         DROP  RENTRY              NO LONGER POINTS TO ANYTHING
         BR    RLINK               RETURN TO CALLER
         EJECT  ,
*****************************************************************
*                                                               *
*                   G E T T I M E B                             *
*                                                               *
*        SUBROUTINE TO GET THE CURRENT DATE IN PACKED DECIMAL   *
*        AND TIME IN 1/100 SECONDS.                             *
*                                                               *
*        INPUT REGISTERS ARE:                                   *
*              RLINK     RETURN ADDRESS TO THE CALLER           *
*              RENTRY    NOT USED.                              *
*              RWORK0    NOT USED.                              *
*              RWORK1    NOT USED.                              *
*                                                               *
*        OUTPUT REGISTERS ARE:                                  *
*              RWORK0    CONTAINS THE TIME IN 1/100 SECONDS     *
*              RWORK1    CONTAINS THE DATE IN PACKED DECIMAL    *
*              RLINK     RETURN ADDRESS TO THE CALLER           *
*              RENTRY    UNCHANGED                              *
*                                                               *
*****************************************************************
*
GETTIMEB DS    0H
         TIME  BIN                 INVOKE SYSTEM "TIME" ROUTINE
         BR    RLINK               RETURN TO CALLER
         TITLE '$ORTPARM - STRING PROCESSING SUBROUTINES'
***************************************************************
*                                                             *
*                   C A T S T R                               *
*                                                             *
*        THIS SUBROUTINE CONCATENATES THE VALUE CONTAINED     *
*        IN AN INPUT STRING TO THE END OF AN OUTPUT STRING.   *
*                                                             *
*        THIS SUBROUTINE EXPECTS REGISTERS AS FOLLOWS....     *
*             RWORK0   CONTAINS THE ADDRESS OF THE OUTPUT     *
*                      STRING.                                *
*             RWORK1   CONTAINS THE LENGTH OF THE OUTPUT      *
*                      STRING AREA.                           *
*             RWORK2   CONTAINS THE ADDRESS OF THE INPUT      *
*                      STRING.                                *
*             RWORK3   CONTAINS THE LENGTH OF THE INPUT       *
*                      STRING.                                *
*             RLINK    RETURN ADDRESS TO THE CALLER.          *
*             RENTRY   NOT USED.                              *
*                                                             *
*        REGISTER VALUES ON RETURN ARE:                       *
*            RWORK0  SAME AS ON ENTRY.                        *
*            RWORK1  SAME AS ON ENTRY.                        *
*            RWORK2  SAME AS ON ENTRY.                        *
*            RWORK3  SAME AS ON ENTRY.                        *
*                                                             *
***************************************************************
*
*
*
*
CATSTRVF DS    0H                  ENTRY POINT;  OUT=V,IN=F
         STM   RLINK,RWORK5,SAVCATST  SAVE INPUT AND VOLATILE REGISTERS
         LA    RENTRY,K2           LOAD OFFSET TO TEXT
         LR    RWORK4,RWORK0       -> OUTPUT STRING CURRENT LN
         SR    RWORK4,RENTRY       -> MAX VALUE HALFWORD
         AR    RENTRY,RENTRY       ADJUST TEXT OFFSET
         LTR   RWORK5,RWORK1       COPY OUTPUT STR MAX LENGTH
         BP    *+L'*+4             IF MAX VALUE SUPPLIED
         LH    RWORK5,00(,RWORK4)  LOAD OUTPUT STRING MAX LENGTH
         SH    RWORK5,02(,RWORK4)  COMPUTE OUTPUT STR REM LENGTH
         CR    RWORK5,RWORK3       COMPARE REM LN TO INPUT LENGTH
         BL    *+L'*+2             KEEP    REM LN IF SMALLER
         LR    RWORK5,RWORK3       OTHERWISE USE INPUT LN AS ADDED LN
         LH    RWORK3,02(,RWORK4)  LOAD     CURRENT LENGTH
         AR    RWORK3,RWORK5       + LENGTH BEING ADDED
         STH   RWORK3,02(,RWORK4)  UPDATE      CURRENT LENGTH
         SR    RWORK3,RWORK5       RECOVER ORIGINAL CURRENT LENGTH
         AR    RWORK4,RWORK3       -> FIRST OUTPUT TEXT BYTE -4
         LR    RWORK3,RWORK5       SET INPUT LN = ADDED LENGTH
         AR    RWORK4,RENTRY       -> FIRST OUTPUT TEXT BYTE
         B     CATST00             TO COMMON ROUTINE
*
*
CATSTRVV DS    0H                  ENTRY POINT;  OUT=V,IN=V
         STM   RLINK,RWORK5,SAVCATST  SAVE INPUT AND VOLATILE REGISTERS
         LA    RENTRY,K2           LOAD OFFSET TO TEXT
         LH    RWORK3,00(,RWORK2)  LOAD INPUT  STRING LENGTH
         LR    RWORK4,RWORK0       -> OUTPUT STRING CURRENT LN
         SR    RWORK2,RENTRY       -> MAX VALUE HALFWORD FOR INPUT
         SR    RWORK4,RENTRY       -> MAX VALUE HALFWORD FOR OUTPUT
         AR    RENTRY,RENTRY       ADJUST TEXT OFFSET
         LTR   RWORK5,RWORK1       COPY OUTPUT STRING MAX LENGTH
         BP    *+L'*+4             IF MAX VALUE SUPPLIED
         LH    RWORK5,00(,RWORK4)  LOAD OUTPUT STRING MAX LENGTH
         SH    RWORK5,02(,RWORK4)  COMPUTE OUTPUT STR REM LENGTH
         CR    RWORK5,RWORK3       COMPARE REM LN TO INPUT LENGTH
         BL    *+L'*+2             KEEP    REM LN IF SMALLER
         LR    RWORK5,RWORK3       OTHERWISE USE INPUT LN AS ADDED LN
         LH    RWORK3,02(,RWORK4)  UPDATE      CURRENT LENGTH
         AR    RWORK3,RWORK5       + LENGTH BEING ADDED
         STH   RWORK3,02(,RWORK4)  UPDATE      CURRENT LENGTH
         SR    RWORK3,RWORK5       RECOVER ORIGINAL CURRENT LENGTH
         AR    RWORK4,RWORK3       -> FIRST OUTPUT TEXT BYTE -4
         LR    RWORK3,RWORK5       SET INPUT LN = ADDED LENGTH
         AR    RWORK2,RENTRY       -> FIRST INPUT  TEXT BYTE
         AR    RWORK4,RENTRY       -> FIRST OUTPUT TEXT BYTE
         B     CATST00             TO COMMON ROUTINE
*
*        SET THE PADDING CHARACTER, AND COPY THE STRING.
CATST00  DS    0H                  START OF STRING SCAN INIT.
         ICM   RWORK3,B'1000',EBLANKS INSERT PADDING CHARACTER
         MVCL  RWORK4,RWORK2       COPY INPUT STRING TO OUTPUT
         LM    RLINK,RWORK5,SAVCATST   RELOAD INPUT REGISTERS
         BR    RLINK               RETURN TO CALLER
         EJECT  ,
*****************************************************************
*                                                               *
*                   C L R S T R                                 *
*                                                               *
*        SUBROUTINE TO CLEAR A STRING TO ANY SPECIFIED          *
*        CHARACTER.                                             *
*                                                               *
*        INPUT REGISTERS ARE:                                   *
*              RLINK     RETURN ADDRESS TO THE CALLER;          *
*              RWORK0    ADDRESS OF THE FIRST BYTE OF THE       *
*                        STRING TO BE CLEARED.                  *
*              RWORK1    IN ITS HIGH ORDER BYTE, THE PADDING    *
*                        CHARACTER TO USE TO CLEAR THE STRING;  *
*                        IN ITS LOW ORDER THREE BYTES, THE      *
*                        LENGTH OF THE STRING TO CLEAR.         *
*              RWORK2    NOT USED                               *
*              RWORK3    NOT USED                               *
*                                                               *
*        OUTPUT REGISTERS ARE:                                  *
*              RLINK     RETURN ADDRESS TO THE CALLER;          *
*              RENTRY    UNCHANGED                              *
*              RWORK0    UNCHANGED                              *
*              RWORK1    THE PADDING CHARACTER IS CLEARED FROM  *
*                        THE HIGH ORDER BYTE.  THE LENGTH IN    *
*                        THE LOW ORDER THREE BYTES IS UNCHANGED.*
*              RWORK2    UNCHANGED                              *
*              RWORK3    UNCHANGED                              *
*                                                               *
*****************************************************************
*
*
CLRSTRF  DS    0H                  ENTRY POINT OUT=F
         STM   RLINK,RWORK3,SAVCLRST               SAVE REGISTERS
         B     CLRST00             TO COMMON ROUTINE
CLRSTRV  DS    0H                  ENTRY POINT OUT=V
         STM   RLINK,RWORK3,SAVCLRST               SAVE REGISTERS
         LA    RENTRY,K2           LOAD OFFSET TO TEXT
         LR    RWORK2,RWORK0       -> OUTPUT STRING CURRENT LN
         SR    RWORK2,RENTRY       -> MAX VALUE HALFWORD
         CLM   RWORK1,B'0111',BZEROS IS STRING LENGTH SPECIFIED ??
         BNE   *+L'*+4             IF MAX VALUE SUPPLIED
         ICM   RWORK1,B'0011',00(RWORK2) MAX STRING LENGTH FROM HDR
         SR    RWORK3,RWORK3       CLEAR WORK REGISTER
         STCM  RWORK1,B'0011',00(RWORK2) SET MAX STRING LENGTH
         STCM  RWORK3,B'0011',02(RWORK2) SET CURRENT LENGTH TO ZERO
         AR    RWORK0,RENTRY       -> FIRST OUTPUT TEXT BYTE
         B     CLRST00             TO COMMON ROUTINE
CLRST00  DS    0H                  COMMON CLEAR ROUTINE
         L     RWORK3,NMSK1000     MASK TO RETAIN THE PADDING CHAR,    X
                                   AND ZERO THE LENGTH
         NR    RWORK3,RWORK1       PUT PADDING CHARACTER IN RWORK3
         MVCL  RWORK0,RWORK2       CLEAR THE STRING
         LM    RLINK,RWORK3,SAVCLRST               RESTORE REGS
         N     RWORK1,NMSK0FFF     CLEAR PADDING CHARACTER FOR CALLER
         BR    RLINK               RETURN TO CALLER
         EJECT  ,
***************************************************************
*                                                             *
*                   C M P S T R                               *
*                                                             *
*        THIS SUBROUTINE COMPARES A CHARACTER STRING          *
*        TO ANOTHER AND RETURNS THE RESULT                    *
*        AS A CONDITION CODE SETTING.                         *
*                                                             *
*        THIS SUBROUTINE EXPECTS REGISTERS AS FOLLOWS....     *
*             RWORK0   CONTAINS THE ADDRESS OF THE CHARACTER  *
*                      STRING TO BE COMPARED TO THE SELECTION *
*                      STRING.                                *
*             RWORK1   CONTAINS THE LENGTH OF THE CHARACTER   *
*                      STRING TO BE COMPARED TO THE SELECTION *
*                      STRING.                                *
*             RWORK2   CONTAINS THE ADDRESS OF THE SELECTION  *
*                      STRING.                                *
*             RWORK3   CONTAINS THE LENGTH OF THE SELECTION   *
*                      STRING.                                *
*             RLINK    RETURN ADDRESS TO THE CALLER.          *
*             RENTRY   NOT USED.                              *
*                                                             *
*        REGISTER VALUES ON RETURN ARE:                       *
*            RWORK0  SAME AS ON ENTRY.                        *
*            RWORK1  SAME AS ON ENTRY.                        *
*            RWORK2  SAME AS ON ENTRY.                        *
*            RWORK3  SAME AS ON ENTRY.                        *
*                                                             *
***************************************************************
*
*
CMPSTRFF DS    0H                  ENTRY POINT;  OUT=F,IN=F
         STM   RLINK,RWORK5,SAVCMPST  SAVE INPUT AND VOLATILE REGISTERS
         LR    RWORK4,RWORK0       LOAD STRING START ADDRESS
         LR    RWORK5,RWORK1       LOAD STRING LENGTH
         B     CMPST00             TO COMMON ROUTINE
CMPSTRFV DS    0H                  ENTRY POINT;  OUT=F,IN=V
         STM   RLINK,RWORK5,SAVCMPST  SAVE INPUT AND VOLATILE REGISTERS
         LA    RENTRY,K2           LOAD OFFSET TO TEXT
         LH    RWORK3,00(,RWORK2)  LOAD INPUT  STRING CURRENT LENGTH
         LR    RWORK4,RWORK0       -> OUTPUT STRING TEXT
         LR    RWORK5,RWORK1       COPY CURRENT STRING LENGTH
         AR    RWORK2,RENTRY       -> FIRST INPUT  TEXT BYTE
         B     CMPST00             TO COMMON ROUTINE
CMPSTRVF DS    0H                  ENTRY POINT;  OUT=V,IN=F
         STM   RLINK,RWORK5,SAVCMPST  SAVE INPUT AND VOLATILE REGISTERS
         LA    RENTRY,K2           LOAD OFFSET TO TEXT
         LR    RWORK4,RWORK0       -> OUTPUT STRING CURRENT LN
         LH    RWORK5,00(,RWORK4)  LOAD CURRENT STRING LENGTH
         AR    RWORK4,RENTRY       -> FIRST OUTPUT TEXT BYTE
         B     CMPST00             TO COMMON ROUTINE
CMPSTRVV DS    0H                  ENTRY POINT;  OUT=V,IN=F
         STM   RLINK,RWORK5,SAVCMPST  SAVE INPUT AND VOLATILE REGISTERS
         LA    RENTRY,K2           LOAD OFFSET TO TEXT
         ICM   RWORK3,B'0100',BZEROS    CLEAR THIRD BYTE OF LEN
         ICM   RWORK3,B'0011',00(RWORK2) INPUT STRING CURRENT LENGTH
         LR    RWORK4,RWORK0       -> OUTPUT STRING CURRENT LN
         LH    RWORK5,00(,RWORK4)  LOAD CURRENT STRING LENGTH
         AR    RWORK2,RENTRY       -> FIRST INPUT  TEXT BYTE
         AR    RWORK4,RENTRY       -> FIRST OUTPUT TEXT BYTE
         B     CMPST00             TO COMMON ROUTINE
CMPST00  DS    0H                  COMMON COMPARE ROUTINE
         ICM   RWORK3,B'1000',EBLANKS SET BLANK PADDING CHARACTER
         CLCL  RWORK4,RWORK2       COMPARE STRINGS AND SET CC
         LM    RLINK,RWORK5,SAVCMPST  SAVE INPUT AND VOLATILE REGISTERS
         BR    RLINK               RETURN TO CALLER
         EJECT  ,
***************************************************************
*                                                             *
*                   L E N S T R                               *
*                                                             *
*        THIS SUBROUTINE RETURNS THE LENGTH VALUE             *
*        FOR A VARIABLE LENGTH STRING, AND RETURNS THE VALUE  *
*        IN REGISTER RWORK1 WITH THE CORRESPONDING            *
*        CONDITION CODE SET.                                  *
*                                                             *
*        THIS SUBROUTINE EXPECTS REGISTERS AS FOLLOWS....     *
*             RWORK0   CONTAINS THE ADDRESS OF THE CHARACTER  *
*                      STRING WHOSE LENGTH IS TO BE RETURNED. *
*             RWORK1   NOT USED.                              *
*             RWORK2   NOT USED.                              *
*             RWORK3   NOT USED.                              *
*             RLINK    RETURN ADDRESS TO THE CALLER.          *
*             RENTRY   NOT USED.                              *
*                                                             *
*        REGISTER VALUES ON RETURN ARE:                       *
*            RWORK0  FOR VARIABLE STRING OUTPUT, SAME AS ON   *
*                    ENTRY; FOR FIXED LENGTH STRING OUTPUT,   *
*                    THIS REGISTER IS UPDATED TO POINT TO THE *
*                    FIRST BYTE OF STRING TEXT.               *
*            RWORK1  CONTAINS THE STRING TEXT LENGTH.         *
*            RWORK2  SAME AS ON ENTRY.                        *
*            RWORK3  SAME AS ON ENTRY.                        *
*                                                             *
***************************************************************
*
*
LENSTRFV DS    0H                  ENTRY POINT;  OUT=F,IN=V
         STM   RLINK,RWORK3,SAVLENST  SAVE INPUT AND VOLATILE REGISTERS
         LA    RENTRY,K2           LOAD OFFSET TO TEXT
         LR    RWORK2,RWORK0       COPY STRING START ADDRESS
         LH    RWORK1,00(,RWORK2)  LOAD STRING CURRENT LENGTH
         AR    RWORK0,RENTRY       CONVERT TO FIXED LENGTH STRING PTR
         B     LENST00             TO COMMON ROUTINE
*
*
LENSTRVV DS    0H                  ENTRY POINT;  OUT=V,IN=V
         STM   RLINK,RWORK3,SAVLENST  SAVE INPUT AND VOLATILE REGISTERS
         LR    RWORK2,RWORK0       COPY STRING START ADDRESS
         LH    RWORK1,00(,RWORK2)  LOAD STRING CURRENT LENGTH
         B     LENST00             TO COMMON ROUTINE
*
*
LENSTRFF DS    0H                  ENTRY POINT;  OUT=F,IN=F
         STM   RLINK,RWORK3,SAVLENST  SAVE INPUT AND VOLATILE REGISTERS
         LA    RENTRY,K2           LOAD OFFSET TO TEXT
         LR    RWORK2,RWORK0       COPY STRING START ADDRESS
         SR    RWORK2,RENTRY       -> LENGTH VALUE PRECEEDING STRING
         LH    RWORK1,00(,RWORK2)  LOAD STRING LENGTH
         B     LENST00             TO COMMON ROUTINE
*
*
LENST00  DS    0H                  COMMON STRING LENGTH ROUTINE
         LM    RLINK,RENTRY,SAVLENST              RESTORE REGISTERS
         LM    RWORK2,RWORK3,SAVLENST+8+4*RWORK2  RESTORE REGISTERS
         LTR   RWORK1,RWORK1       SET CONDITION CODE FROM LENGTH
         BR    RLINK               RETURN TO CALLER
         EJECT  ,
***************************************************************
*                                                             *
*                   N D X S T R                               *
*                                                             *
*        THIS SUBROUTINE SEARCHES AN INPUT CHARACTER STRING   *
*        FOR THE PRESENCE OF AN INDEX ARGUMENT STRING,        *
*        AND RETURNS THE OFFSET TO THE BYTE                   *
*        AT WHICH THE INDEX ARGUMENT                          *
*        STRING BEGINS.  IF THE INDEX ARGUMENT STRING IS      *
*        FOUND, A NON-ZERO CONDITION CODE IS ALSO SET.  IF    *
*        THE INDEX ARGUMENT STRING IS NOT FOUND, CONDITION    *
*        CODE ZERO IS SET, AND AN OFFSET VALUE EQUAL TO THE   *
*        LENGTH OF THE INPUT STRING IS RETURNED.              *
*                                                             *
*                                                             *
*        THIS SUBROUTINE EXPECTS REGISTERS AS FOLLOWS....     *
*             RWORK0   CONTAINS THE ADDRESS OF THE CHARACTER  *
*                      STRING TO BE SEARCHED FOR THE PRESENCE *
*                      OF THE INDEX ARGUMENT STRING.          *
*             RWORK1   CONTAINS THE LENGTH OF THE CHARACTER   *
*                      STRING TO BE SEARCHED FOR THE PRESENCE *
*                      OF THE INDEX ARGUMENT STRING.          *
*             RWORK2   CONTAINS THE ADDRESS OF THE INDEX      *
*                      ARGUMENT STRING.                       *
*             RWORK3   CONTAINS THE LENGTH OF THE INDEX       *
*                      ARGUMENT STRING.                       *
*             RLINK    RETURN ADDRESS TO THE CALLER.          *
*             RENTRY   NOT USED.                              *
*                                                             *
*        REGISTER VALUES ON RETURN ARE:                       *
*            RENTRY  CONTAINS THE BYTE OFFSET VALUE.          *
*            RWORK0  SAME AS ON ENTRY.                        *
*            RWORK1  SAME AS ON ENTRY.                        *
*            RWORK2  SAME AS ON ENTRY.                        *
*            RWORK3  SAME AS ON ENTRY.                        *
*                                                             *
***************************************************************
*
*
NDXSTRFF DS    0H                  ENTRY POINT;  IN=F,NDX=F
         STM   RLINK,RWORK7,SAVNDXST  SAVE INPUT AND VOLATILE REGISTERS
         LR    RWORK4,RWORK0       INPUT STRING START ADDRESS
         LR    RWORK5,RWORK1       INPUT STRING START LENGTH
         LR    RWORK6,RWORK2       INDEX ARGUMENT STRING START ADDRESS
         LR    RWORK7,RWORK3       INDEX ARGUMENT STRING LENGTH
         B     NDXST00             TO COMMON ROUTINE
*
*
NDXSTRFV DS    0H                  ENTRY POINT;  IN=F,NDX=V
         STM   RLINK,RWORK7,SAVNDXST  SAVE INPUT AND VOLATILE REGISTERS
         LA    RENTRY,K2           LOAD OFFSET TO TEXT
         LR    RWORK4,RWORK0       INPUT STRING START ADDRESS
         LR    RWORK5,RWORK1       INPUT STRING START LENGTH
         LR    RWORK6,RWORK2       INDEX ARGUMENT STRING START ADDRESS
         LH    RWORK7,00(,RWORK2)  INDEX ARGUMENT STRING LENGTH
         AR    RWORK6,RENTRY       -> FIRST TEXT BYTE
         B     NDXST00             TO COMMON ROUTINE
*
*
NDXSTRVF DS    0H                  ENTRY POINT;  IN=V,NDX=F
         STM   RLINK,RWORK7,SAVNDXST  SAVE INPUT AND VOLATILE REGISTERS
         LA    RENTRY,K2           LOAD OFFSET TO TEXT
         LR    RWORK4,RWORK0       INPUT STRING START ADDRESS
         LH    RWORK5,00(,RWORK4)  INPUT STRING START LENGTH
         LR    RWORK6,RWORK2       INDEX ARGUMENT STRING START ADDRESS
         LR    RWORK7,RWORK3       INDEX ARGUMENT STRING LENGTH
         AR    RWORK4,RENTRY       -> FIRST TEXT BYTE
         B     NDXST00             TO COMMON ROUTINE
*
*
NDXSTRVV DS    0H                  ENTRY POINT;  IN=V,NDX=F
         STM   RLINK,RWORK7,SAVNDXST  SAVE INPUT AND VOLATILE REGISTERS
         LA    RENTRY,K2           LOAD OFFSET TO TEXT
         LR    RWORK4,RWORK0       INPUT STRING START ADDRESS
         LH    RWORK5,00(,RWORK4)  INPUT STRING START LENGTH
         LR    RWORK6,RWORK2       INDEX ARGUMENT STRING START ADDRESS
         LH    RWORK7,00(,RWORK2)  INDEX ARGUMENT STRING LENGTH
         AR    RWORK4,RENTRY       -> FIRST TEXT BYTE
         AR    RWORK6,RENTRY       -> FIRST TEXT BYTE
         B     NDXST00             TO COMMON ROUTINE
*
*
*        PREPARE TO BEGIN SEARCHING THE INPUT STRING
NDXST00  DS    0H                  COMMON SEARCH ROUTINE
         LA    RENTRY,K1           LOAD INCREMENT VALUE
         LR    RLINK,RWORK4        SAVE COMPARE START ADDRESS
         SR    RLINK,RENTRY             -1
*
*
*        VERIFY THAT THE INPUT STRING HAS SUFFICIENT
*        REMAINING LENGTH TO CONTAIN THE INDEX ARGUMENT STRING.
NDXST01  DS    0H
         CR    RWORK5,RWORK7       COMPARE REMAINING LENGTH            X
                                   TO INDEX ARGUMENT STRING LENGTH
         BL    NDXST05             IF INSUFFICIENT LENGTH REMAINS
*
*
*        SET UP REGISTERS FOR THE COMPARE.
NDXST02  DS    0H
         LR    RWORK0,RWORK4       INPUT STRING CURRENT BYTE
         LR    RWORK1,RWORK7       INDEX ARGUMENT STRING LENGTH
         LR    RWORK2,RWORK6       INDEX ARGUMENT STRING START ADDRESS
         LR    RWORK3,RWORK7       INDEX ARGUMENT STRING LENGTH
*
*
*        SEE IF THE INDEX ARGUMENT STRING
*        BEGINS AT THE CURRENT BYTE.
NDXST03  DS    0H
         CLCL  RWORK0,RWORK2       INDEX ARGUMENT STRING???
         BE    NDXST06             IF STRING FOUND
*
*
*        THE INDEX ARGUMENT STRING WAS NOT FOUND AT THE
*        CURRENT BYTE.  ADVANCE TO THE NEXT BYTE AND LOOP.
NDXST04  DS    0H
         AR    RWORK4,RENTRY       ADVANCE TO NEXT BYTE
         SR    RWORK5,RENTRY       DECREMENT REMAINING LENGTH
         B     NDXST01             AND LOOP
*
*
*        THE INDEX ARGUMENT STRING WAS NOT FOUND IN THE
*        INPUT STRING.  SET REGISTERS "RWORK4 & 5" SO THAT THE
*        OFFSET VALUE CALCULATION WILL YIELD A ZERO COND CODE.
NDXST05  DS    0H
         SR    RWORK4,RLINK        LENGTH+1 ALREADY SCANNED
         AR    RWORK5,RWORK4       LENGTH+1 OF INPUT STRING
         LR    RWORK4,RLINK        SET RWORK4 TO YIELD A ZERO RESULT
*
*
*        EITHER THE INDEX ARGUMENT STRING WAS FOUND,
*        OR THE LENGTH OF THE INPUT STRING WAS EXHAUSTED.
*        CALCULATE THE OFFSET VALUE AND SET THE CC.
NDXST06  DS    0H
         LR    RENTRY,RWORK4       CALCULATE
         SR    RENTRY,RLINK           BYTE NUMBER AND SET CC
         BNZ   *+L'*+2             BRANCH IF BYTE NUMBER
         LR    RENTRY,RWORK5       SUBSTITUTE LENGTH+1 OF INPUT STR
         BCTR  RENTRY,0            CONVERT BYTE NUMBER TO AN OFFSET
*
*
*
*        RETURN TO THE CALLER.
NDXST07  DS    0H
         LM     RLINK,RLINK,SAVNDXST              RESTORE REGISTERS
         LM    RWORK0,RWORK7,SAVNDXST+8+4*RWORK0  RESTORE REGISTERS
         BR    RLINK               RETURN TO CALLER
         EJECT  ,
***************************************************************
*                                                             *
*                   P U T S T R                               *
*                                                             *
*        THIS SUBROUTINE COPIES AN INPUT STRING TO AN         *
*        OUTPUT STRING, EFFECTIVELY INITIALIZING IT.          *
*                                                             *
*        THIS SUBROUTINE EXPECTS REGISTERS AS FOLLOWS....     *
*             RWORK0   CONTAINS THE ADDRESS OF THE OUTPUT     *
*                      STRING.                                *
*             RWORK1   CONTAINS THE LENGTH OF THE OUTPUT      *
*                      STRING AREA.                           *
*             RWORK2   CONTAINS THE ADDRESS OF THE INPUT      *
*                      STRING.                                *
*             RWORK3   CONTAINS THE LENGTH OF THE INPUT       *
*                      STRING.                                *
*             RLINK    RETURN ADDRESS TO THE CALLER.          *
*             RENTRY   NOT USED.                              *
*                                                             *
*        REGISTER VALUES ON RETURN ARE:                       *
*            RWORK0  SAME AS ON ENTRY.                        *
*            RWORK1  SAME AS ON ENTRY.                        *
*            RWORK2  SAME AS ON ENTRY.                        *
*            RWORK3  SAME AS ON ENTRY.                        *
*                                                             *
***************************************************************
*
*
PUTSTRFF DS    0H                  ENTRY POINT;  OUT=F,IN=F
         STM   RLINK,RWORK5,SAVPUTST  SAVE INPUT AND VOLATILE REGISTERS
         LR    RWORK4,RWORK0       LOAD STRING START ADDRESS
         LR    RWORK5,RWORK1       LOAD STRING LENGTH
         B     PUTST00             TO COMMON ROUTINE
*
*
PUTSTRFV DS    0H                  ENTRY POINT;  OUT=F,IN=V
         STM   RLINK,RWORK5,SAVPUTST  SAVE INPUT AND VOLATILE REGISTERS
         LA    RENTRY,K2           LOAD OFFSET TO TEXT
         LH    RWORK3,00(,RWORK2)  LOAD INPUT  STRING CURRENT LENGTH
         LR    RWORK4,RWORK0       -> OUTPUT STRING CURRENT LN
         LR    RWORK5,RWORK1       COPY OUTPUT STRING MAX LENGTH
         AR    RWORK2,RENTRY       -> FIRST INPUT  TEXT BYTE
         B     PUTST00             TO COMMON ROUTINE
*
*
PUTSTRVF DS    0H                  ENTRY POINT;  OUT=V,IN=F
         STM   RLINK,RWORK5,SAVPUTST  SAVE INPUT AND VOLATILE REGISTERS
         LA    RENTRY,K2           LOAD OFFSET TO TEXT
         LR    RWORK4,RWORK0       -> OUTPUT STRING CURRENT LN
         SR    RWORK4,RENTRY       -> MAX VALUE HALFWORD
         AR    RENTRY,RENTRY       ADJUST TEXT OFFSET
         LTR   RWORK5,RWORK1       COPY OUTPUT STR MAX LENGTH
         BP    *+L'*+4             IF MAX VALUE SUPPLIED
         LH    RWORK5,00(,RWORK4)  LOAD MAX STRING LENGTH FROM HDR
         STCM  RWORK5,B'0011',00(RWORK4) INITIALIZE MAX LENGTH FIELD
         CR    RWORK5,RWORK3       COMPARE MAX LN TO INPUT LENGTH
         BL    *+L'*+2             IF MAX LN IS SMALLER
         LR    RWORK5,RWORK3       OTHERWISE USE INPUT LN FOR CURRENT
         STCM  RWORK5,B'0011',02(RWORK4) INITIALIZE CUR LENGTH FIELD
         LR    RWORK3,RWORK5       SET INPUT LN = OUTPUT LN
         AR    RWORK4,RENTRY       -> FIRST OUTPUT TEXT BYTE
         B     PUTST00             TO COMMON ROUTINE
*
*
PUTSTRVV DS    0H                  ENTRY POINT;  OUT=V,IN=V
         STM   RLINK,RWORK5,SAVPUTST  SAVE INPUT AND VOLATILE REGISTERS
         LA    RENTRY,K2           LOAD OFFSET TO TEXT
         LH    RWORK3,00(,RWORK2)  LOAD INPUT  STRING CURRENT LENGTH
         LR    RWORK4,RWORK0       -> OUTPUT STRING CURRENT LN
         SR    RWORK2,RENTRY       -> MAX VALUE HALFWORD FOR INPUT
         SR    RWORK4,RENTRY       -> MAX VALUE HALFWORD FOR OUTPUT
         AR    RENTRY,RENTRY       ADJUST TEXT OFFSET
         LTR   RWORK5,RWORK1       COPY OUTPUT STRING MAX LENGTH
         BP    *+L'*+4             IF MAX VALUE SUPPLIED
         LH    RWORK5,00(,RWORK4)  LOAD MAX STRING LENGTH FROM HDR
         STCM  RWORK5,B'0011',00(RWORK4) INITIALIZE MAX LENGTH FIELD
         CR    RWORK5,RWORK3       COMPARE MAX LN TO INPUT LENGTH
         BL    *+L'*+2             IF MAX LN IS SMALLER
         LR    RWORK5,RWORK3       OTHERWISE USE INPUT LN FOR CURRENT
         STCM  RWORK5,B'0011',02(RWORK4) INITIALIZE CUR LENGTH FIELD
         LR    RWORK3,RWORK5       SET INPUT LN = OUTPUT LN
         AR    RWORK2,RENTRY       -> FIRST INPUT  TEXT BYTE
         AR    RWORK4,RENTRY       -> FIRST OUTPUT TEXT BYTE
         B     PUTST00             TO COMMON ROUTINE
*
*        SET THE PADDING CHARACTER, AND COPY THE STRING.
PUTST00  DS    0H                  START OF STRING SCAN INIT.
         ICM   RWORK3,B'1000',EBLANKS INSERT PADDING CHARACTER
         MVCL  RWORK4,RWORK2       COPY INPUT STRING TO OUTPUT
         LM    RLINK,RWORK5,SAVPUTST   RELOAD INPUT REGISTERS
         BR    RLINK               RETURN TO CALLER
         EJECT  ,
***************************************************************
*                                                             *
*                   S C N S T R                               *
*                                                             *
*        THIS SUBROUTINE SEARCHES AN INPUT STRING AND         *
*        RETURNS A BINARY INTEGER VALUE INDICATING THE        *
*        OFFSET TO THE FIRST INPUT STRING BYTE ALSO           *
*        CONTAINED IN THE SCAN CONTROL STRING.  IF SUCH A BYTE*
*        IS FOUND, A NON-ZERO CONDITION CODE IS ALSO SET.     *
*        IF THE INPUT STRING ADDRESS IS NOT PROVIDED,         *
*        THE INPUT STRING LENGTH IS ZERO, THE SCAN CONTROL    *
*        STRING LENGTH IS ZERO, OR ALL OF THE BYTES IN THE    *
*        INPUT STRING APPEAR IN THE SCAN CONTROL STRING,      *
*        A CONDITION CODE OF ZERO IS SET, AND AN OFFSET       *
*        VALUE EQUAL TO THE TOTAL LENGTH OF THE INPUT STRING  *
*        IS RETURNED.                                         *
*                                                             *
*                                                             *
*        THIS SUBROUTINE EXPECTS REGISTERS AS FOLLOWS....     *
*             RWORK0   CONTAINS THE ADDRESS OF THE INPUT      *
*                      STRING TO BE SCANNED.                  *
*             RWORK1   CONTAINS THE LENGTH OF THE INPUT       *
*                      STRING TO BE SCANNED.                  *
*             RWORK2   CONTAINS THE ADDRESS OF THE            *
*                      SCAN CONTROL STRING.  IF THIS ADDRESS  *
*                      IS ZERO, THE TRT TABLE BUILT DURING    *
*                      THE LAST EXECUTION OF THIS ROUTINE     *
*                      WITH A VALID SCAN CONTROL STRING IS    *
*                      USED, SAVING THE EXECUTION TIME        *
*                      REQUIRED TO REBUILD THE TRT TABLE.     *
*             RWORK3   CONTAINS THE LENGTH OF THE             *
*                      SCAN CONTROL STRING.                   *
*             RLINK    RETURN ADDRESS TO THE CALLER.          *
*             RENTRY   NOT USED.                              *
*                                                             *
*                                                             *
*        REGISTER VALUES ON RETURN ARE:                       *
*            RENTRY  CONTAINS THE OFFSET VALUE.               *
*            RWORK0  SAME AS ON ENTRY.                        *
*            RWORK1  SAME AS ON ENTRY.                        *
*            RWORK2  SAME AS ON ENTRY.                        *
*            RWORK3  SAME AS ON ENTRY.                        *
*                                                             *
***************************************************************
*
*
*
*
SCNSTRFF DS    0H                  ENTRY POINT;  IN=F,SCN=F
         STM   RLINK,RWORK7,SAVSCNST                  SAVE REGISTERS
         LR    RWORK4,RWORK0       INPUT STRING START ADDRESS
         LR    RWORK5,RWORK1       INPUT STRING START LENGTH
         LR    RWORK6,RWORK2       SCAN CONTROL STRING START ADDRESS
         LR    RWORK7,RWORK3       SCAN CONTROL STRING LENGTH
         B     SCNST00             TO COMMON ROUTINE
*
*
*
*
SCNSTRFV DS    0H                  ENTRY POINT;  IN=F,SCN=V
         STM   RLINK,RWORK7,SAVSCNST                  SAVE REGISTERS
         LA    RENTRY,K2           LOAD OFFSET TO TEXT
*
         LR    RWORK4,RWORK0       INPUT STRING START ADDRESS
         LR    RWORK5,RWORK1       INPUT STRING START LENGTH
*
         LTR   RWORK6,RWORK2       SCAN CONTROL STRING START ADDRESS
         BZ    *+L'*+4+2           IF ADDRESS NOT SUPPLIED
         LH    RWORK7,00(,RWORK2)  SCAN CONTROL STRING LENGTH
         AR    RWORK6,RENTRY       -> FIRST TEXT BYTE
*
         B     SCNST00             TO COMMON ROUTINE
*
*
SCNSTRVF DS    0H                  ENTRY POINT;  IN=V,SCN=F
         STM   RLINK,RWORK7,SAVSCNST                  SAVE REGISTERS
         LA    RENTRY,K2           LOAD OFFSET TO TEXT
*
         LTR   RWORK4,RWORK0       INPUT STRING START ADDRESS
         BZ    *+L'*+4+2           IF ADDRESS NOT SUPPLIED
         LH    RWORK5,00(,RWORK4)  INPUT STRING START LENGTH
         AR    RWORK4,RENTRY       -> FIRST TEXT BYTE
*
         LR    RWORK6,RWORK2       SCAN CONTROL STRING START ADDRESS
         LR    RWORK7,RWORK3       SCAN CONTROL STRING LENGTH
*
         B     SCNST00             TO COMMON ROUTINE
*
*
*
*
SCNSTRVV DS    0H                  ENTRY POINT;  IN=V,SCN=F
         STM   RLINK,RWORK7,SAVSCNST                  SAVE REGISTERS
         LA    RENTRY,K2           LOAD OFFSET TO TEXT
*
         LTR   RWORK4,RWORK0       INPUT STRING START ADDRESS
         BZ    *+L'*+4+2           IF ADDRESS NOT SUPPLIED
         LH    RWORK5,00(,RWORK4)  INPUT STRING START LENGTH
         AR    RWORK4,RENTRY       -> FIRST TEXT BYTE
*
         LTR   RWORK6,RWORK2       SCAN CONTROL STRING START ADDRESS
         BZ    *+L'*+4+2           IF ADDRESS NOT SUPPLIED
         LH    RWORK7,00(,RWORK2)  SCAN CONTROL STRING LENGTH
         AR    RWORK6,RENTRY       -> FIRST TEXT BYTE
*
         B     SCNST00             TO COMMON ROUTINE
***************************************************************
*
*
*        PREPARE TO BEGIN SCANNING THE INPUT STRING.
SCNST00  DS    0H                  COMMON SCAN ROUTINE
         LA    RLINK,STRSCTBL      -> SCAN TRT TABLE IN WORK AREA
         LA    RENTRY,K256         LOAD CONSTANT VALUE
         LR    RWORK0,RWORK4       SAVE INPUT STRING START ADDRESS
         BCTR  RWORK0,0                              -1
*
*
*        TEST FOR THE PRESENCE OF A SCAN CONTROL STRING,
*        AND IF ONE IS PROVIDED,
*        INITIALIZE THE TRT TABLE TO ALL ZERO VALUES -- X'00'.
SCNST01  DS    0H
         LTR   RWORK6,RWORK6       SCAN CONTROL STRING ADDR SUPPLIED?
         BZ    SCNST04             IF NOT - USE TRT TABLE PREV BUILT
         LTR   RWORK7,RWORK7       SCAN CONTROL STRING LENGTH ZERO???
         BNP   SCNST07             IF NOT - RETURN ZERO RESULT
         SR    RWORK1,RWORK1       SET RWORK1 TO ZERO
         LR    RWORK2,RLINK        -> TRT TABLE IN WORK AREA
         LR    RWORK3,RENTRY          TRT TABLE LENGTH
         MVCL  RWORK2,RWORK0       SET TRT TABLE TO ALL X'00'
*
*
*        SET UP REGISTER VALUES TO ALLOW SETTING
*        TRT TABLE BYTES TO X'01.
SCNST02  DS    0H
         LA    RWORK2,K1           LOAD BXLE INCREMENT
         LA    RWORK3,00(RWORK7,RWORK6)      SCAN STR END+1 ADDR
         SR    RWORK3,RWORK2       SCAN STRING END ADDR FOR BXLE
*
*
*        SET THE TRT TABLE BYTES CORRESPONDING
*        TO THE SCAN CONTROL CHARACTERS TO X'01'.
SCNST03  DS    0H
         IC    RWORK1,00(,RWORK6)  LOAD SCAN CONTROL CHARACTER
         STC   RWORK2,00(RWORK1,RLINK)  SET TRT TABLE BYTE TO Z'01'
         BXLE  RWORK6,RWORK2,SCNST03    LOOP UNTIL ALL SCAN CONTROL    X
                                   CHARACTERS HAVE BEEN PROCESSED
*
*
*        TEST FOR THE PRESENCE OF AN INPUT STRING,
*        AND INITIALIZE REGISTERS FOR SCANNING THE INPUT STRING.
SCNST04  DS    0H
         LTR   RWORK1,RWORK4       INPUT STRING ADDR SUPPLIED?
         BZ    SCNST07             IF NOT - RETURN ZERO RESULT
         LTR   RWORK2,RWORK5       INPUT STRING LENGTH ZERO???
         BNP   SCNST07             IF NOT - RETURN ZERO RESULT
         CR    RWORK2,RENTRY       MORE THAN 256 BYTES TO SCAN??
         BNH   SCNST06             BRANCH IF NOT
         LR    RWORK2,RENTRY       COPY INCREMENT FOR BXLE
         LA    RWORK3,00(RWORK5,RWORK4) INPUT STRING END+1 BYTE ADDR
         SR    RWORK3,RWORK2       INPUT STRING END BYTE ADDR FOR BXLE
*
*
*        THE INPUT STRING IS LONGER THAN 256 BYTES,
*        LOOP THROUGH THE STRING IN 256 BYTE SEGMENTS USING TRT
*        UNTIL ALL 256 BYTE SEGMENTS HAVE BEEN PROCESSED, OR UNTIL
*        A BYTE MEETING THE SCAN CRTIERIA IS FOUND.
SCNST05  DS    0H
         TRT   00(K256,RWORK1),00(RLINK)   SCAN 256 BYTES
         BNZ   SCNST08             IF SCAN CHARACTER FOUND
         BXLE  RWORK1,RWORK2,SCNST05    LOOP UNTIL ALL 256 BYTE        X
                                        SEGMENTS HAVE BEEN PROCESSED
         AR    RWORK2,RWORK3            RECOVER END+1 ADDRESS
         SR    RWORK2,RWORK1            COMPUTE REMAINING LENGTH
         BNP   SCNST07                  IF NO LENGTH REMAINS,          X
                                        ALL BYTES WERE PROCESSED
*
*
*        EITHER THE INPUT STRING CONTAINS 256 BYTES OR LESS,
*        OR THERE WERE BYTES REMAINING TO PROCESS AFTER ALL
*        COMPLETE 256 BYTE SEGMENTS WERE PROCESSED.
SCNST06  DS    0H
         BCTR  RWORK2,0            DECREMENT LENGTH FOR TRT
         EX    RWORK2,SCNSTTRT     SCAN LAST GROUP OF BYTES
         BNZ   SCNST08             IF SCAN CHARACTER FOUND
*
*
*        EITHER THE INPUT STRING WAS MISSING, HAD ZERO LENGTH,
*        THE SCAN CONTROL STRING HAD ZERO LENGTH,
*        OR THE INPUT STRING WAS COMPLETELY PROCESSED
*        WITHOUT A SCAN CONTROL CHARACTER'S BEING FOUND.
*        SET THE VALUE OF RWORK1 TO FORCE A ZERO RESULT.
SCNST07  DS    0H
         LR    RWORK1,RWORK0       SET END ADDR = START-1 ADDR
*
*
*        THE SCANNING PROCESS IS COMPLETE,
*        CALCULATE THE RESULT VALUE TO RETURN TO THE CALLER
*        IN REGISTER "RENTRY", AND SET THE CONDITION CODE.
SCNST08  DS    0H
         LR    RENTRY,RWORK1       COPY END ADDRESS
         SR    RENTRY,RWORK0       COMPUTE RESULT VALUE,               X
                                   AND SET THE CONDITION CODE
         BNZ   *+L'*+4             BRANCH IF BYTE NUMBER CALCULATED
         LA    RENTRY,K1(,RWORK5)  SET BYTE NUMBER = LENGTH+1
         BCTR  RENTRY,0            CONVERT BYTE NUMBER TO OFFSET
*
*
*
*        RELOAD REGISTERS AND RETURN TO THE CALLER,
*        WITH THE RESULT VALUE IN REGISTER "RENTRY".
SCNST09  DS    0H
         LM     RLINK,RLINK,SAVSCNST              RESTORE REGISTERS
         LM    RWORK0,RWORK7,SAVSCNST+8+4*RWORK0  RESTORE REGISTERS
         BR    RLINK               RETURN TO CALLER
         SPACE 5
*
*
*
*        THE FOLLOWING INSTRUCTION IS EXECUTED.
SCNSTTRT TRT   00(*-*,RWORK1),00(RLINK)
         EJECT  ,
***************************************************************
*                                                             *
*                   S E L S T R                               *
*                                                             *
*        THIS SUBROUTINE COMPARES A CHARACTER STRING          *
*        TO A SELECTION STRING AND RETURNS THE RESULT         *
*        AS A CONDITION CODE SETTING.                         *
*                                                             *
*        THIS SUBROUTINE EXPECTS REGISTERS AS FOLLOWS....     *
*             RWORK0   CONTAINS THE ADDRESS OF THE CHARACTER  *
*                      STRING TO BE COMPARED TO THE SELECTION *
*                      STRING.                                *
*             RWORK1   CONTAINS THE LENGTH OF THE CHARACTER   *
*                      STRING TO BE COMPARED TO THE SELECTION *
*                      STRING.                                *
*             RWORK2   CONTAINS THE ADDRESS OF THE SELECTION  *
*                      STRING.                                *
*             RWORK3   CONTAINS THE LENGTH OF THE SELECTION   *
*                      STRING.                                *
*             RLINK    RETURN ADDRESS TO THE CALLER.          *
*             RENTRY   NOT USED.                              *
*                                                             *
*        REGISTER VALUES ON RETURN ARE:                       *
*            RWORK0  SAME AS ON ENTRY.                        *
*            RWORK1  SAME AS ON ENTRY.                        *
*            RWORK2  SAME AS ON ENTRY.                        *
*            RWORK3  SAME AS ON ENTRY.                        *
*                                                             *
***************************************************************
*
*
SELSTRFF DS    0H                  ENTRY POINT;  OUT=F,IN=F
         STM   RLINK,RWORK5,SAVSELST  SAVE INPUT AND VOLATILE REGISTERS
         LR    RWORK4,RWORK0       LOAD STRING START ADDRESS
         LR    RWORK5,RWORK1       LOAD STRING LENGTH
         B     SELST00             TO COMMON ROUTINE
*
*
SELSTRFV DS    0H                  ENTRY POINT;  OUT=F,IN=V
         STM   RLINK,RWORK5,SAVSELST  SAVE INPUT AND VOLATILE REGISTERS
         LA    RENTRY,K2           LOAD OFFSET TO TEXT
         LH    RWORK3,00(,RWORK2)  LOAD SELECT STRING CURRENT LENGTH
         LR    RWORK4,RWORK0       LOAD STRING START ADDRESS
         LR    RWORK5,RWORK1       LOAD STRING LENGTH
         AR    RWORK2,RENTRY       -> FIRST SELECT STRING TEXT BYTE
         B     SELST00             TO COMMON ROUTINE
*
*
SELSTRVF DS    0H                  ENTRY POINT;  OUT=V,IN=F
         STM   RLINK,RWORK5,SAVSELST  SAVE INPUT AND VOLATILE REGISTERS
         LA    RENTRY,K2           LOAD OFFSET TO TEXT
         LR    RWORK4,RWORK0       -> OUTPUT STRING CURRENT LN
         LH    RWORK5,00(,RWORK4)  LOAD  CURRENT LENGTH
         AR    RWORK4,RENTRY       -> FIRST TEXT BYTE
         B     SELST00             TO COMMON ROUTINE
*
*
SELSTRVV DS    0H                  ENTRY POINT;  OUT=V,IN=F
         STM   RLINK,RWORK5,SAVSELST  SAVE INPUT AND VOLATILE REGISTERS
         LA    RENTRY,K2           LOAD OFFSET TO TEXT
         LH    RWORK3,00(,RWORK2)  LOAD SELECT STRING CURRENT LENGTH
         LR    RWORK4,RWORK0       -> ARG STRING CURRENT LN
         LH    RWORK5,00(,RWORK4)  LOAD CURRENT STRING LENGTH
         AR    RWORK2,RENTRY       -> FIRST SELECT STRING TEXT BYTE
         AR    RWORK4,RENTRY       -> FIRST ARGUMENT STRING TEXT BYTE
         B     SELST00             TO COMMON ROUTINE
*
*        VALIDATE STRING LENGTHS, AND INITIALIZE REGISTERS.
SELST00  DS    0H                  START OF STRING SCAN INIT.
*
*        CHECK FOR A SELECTION STRING OF ALL "="
         LA    RENTRY,C'='         LOAD PADDING CHARCTER
         SLL   RENTRY,24           POSITION PADDING CHARACTER
         LR    RWORK0,RWORK2       COPY SELECT STRING START
         LR    RWORK1,RWORK3       COPY SELECT STRING LENGTH
         CLCL  RWORK0,RLINK        IS SELECT STRING ALL "=" ???
         BE    SELST18             RETURN EQUAL COMPARE IF YES
*
*        COMPARE STRING LENGTHS
         CR    RWORK5,RWORK3       ARGUMENT STRING TO SELECT STR LN
         BNH   *+L'*+2             IF ARGUMENT STRING SHORTER OR SAME
*        WHEN THE SELECTION STRING IS SHORTER, THIS ROUTINE
*        CONSIDERS IT TO BE EXTENDED ON THE RIGHT WITH "=",
*        THUS NO CHECK OF EXCESS CHARACTERS IN THE ARGUMENT STRING
*        IS DONE.
         LR    RWORK5,RWORK3       IF ARGUMENT STR LONGER - LIMIT CMPR
         BNL   SELST00Z            IF ARG STR LONGER OR EQ LN
*        THE SELECTION STRING IS LONGER - ITS EXCESS CHARACTERS
*        MUST BE EQUAL TO "=".
         LR    RWORK0,RWORK2       COPY SELECT STRING START
         LR    RWORK1,RWORK3       COPY SELECT STRING LENGTH
         AR    RWORK0,RWORK5       -> 1ST EXCESS CHARACTER
         SR    RWORK1,RWORK5       # OF EXCESS BYTES
         CLCL  RWORK0,RLINK        CHECK FOR EXCESS = "="
         BNE   SELST19             IF NOT EQUAL
SELST00Z DS    0H
         LA    RENTRY,K1           LOAD CONSTANT FOR LOOP CONTROL
         LR    RWORK1,RWORK2       SAVE COMPARE START ADDRESS
*
*        START OF THE SELECTION STRING SCAN CONTROL LOOP.
SELST01  DS    0H                  START OF STRING SCAN LOOP
         CLI   00(RWORK2),C'='     IS MASK STRING CHAR "=" ????
         BE    SELST16             ANY CHARACTER IN CURRENT BYTE IS OK
         TM    00(RWORK2),X'C0'    IS MASK CHAR A TEXT CHARACTER ???
         BC    8+1,SELST02         IF IN RANGE 00-3F(BZ) OR C0-FF(BO)
         MVC   PACKAREA(01),00(RWORK4) COPY STRING CHAR TO WORK AREA
         TR    PACKAREA(01),TRCHRTYP   GET BIT MASK DESCRIBING CHR TYPE
         CLI   00(RWORK2),C'#'     IS MASK STRING CHAR "#" ????
         BE    SELST03             ANY NUMERIC DIGIT IS OK
         CLI   00(RWORK2),C'-'     IS MASK STRING CHAR "-" ????
         BE    SELST04             ANY MON-NUMERIC CHAR IS OK
         CLI   00(RWORK2),C'@'     IS MASK STRING CHAR "@" ????
         BE    SELST05             ANY ALPHABETIC CHR IS OK
         CLI   00(RWORK2),C'$'     IS MASK STRING CHAR "$" ????
         BE    SELST06             ANY SPECIAL CHR IS OK
         CLI   00(RWORK2),C'^'     IS MASK STRING CHAR "^" ????
         BE    SELST07             ANY NON-BLANK CHR IS OK
*
*        THE CURRENT STRING CHARACTER IS A TEXT CHARACTER
SELST02  DS    0H                  PROCESS TEXT CHARACTER
         CLC   00(1,RWORK2),00(RWORK4) COMPARE TEXT BYTES
         BE    SELST17             CONTINUE SCAN IF CHARACTERS EQUAL
         B     SELST19             IF NOT EQUAL, REJECT THE STRING
*
*        THE CURRENT CHARACTER MUST BE NUMERIC.
SELST03  DS    0H                  CHECK FOR NUMERIC DIGIT
         TM    PACKAREA,X'01'      IS CHARACTER NUMERIC ???
         BO    SELST17             CONTINUE SCAN IF WITHIN RANGE
         B     SELST19             REJECT THE STRING OTHERWISE
*
*        THE CURRENT CHARACTER MUST BE NON-NUMERIC.
SELST04  DS    0H                  CHECK FOR NON-NUMERIC
         TM    PACKAREA,X'01'      IS CHARACTER NUMERIC ???
         BZ    SELST17             CONTINUE SCAN IF NON-NUMERIC
         B     SELST19             REJECT THE STRING OTHERWISE
*
*        THE CURRENT CHARACTER MUST BE ALPHABETIC.
SELST05  DS    0H                  CHECK FOR ALPHABETIC CHARACTER
         TM    PACKAREA,X'02'      IS CHARACTER ALPHABETIC ???
         BO    SELST17             CONTINUE SCAN IF WITHIN RANGE
         B     SELST19             REJECT THE STRING OTHERWISE
*
*        THE CURRENT CHARACTER MUST BE A NATIONAL OR SPECIAL CHARACTER.
SELST06  DS    0H                  CHECK FOR SPECIAL CHARACTER
         TM    PACKAREA,X'0C'      IS CHARACTER SPECIAL ???
         BNZ   SELST17             CONTINUE SCAN IF WITHIN RANGE
         B     SELST19             REJECT THE STRING OTHERWISE
*
*        THE CURRENT CHARACTER MUST BE NON-BLANK.
SELST07  DS    0H                  CHECK FOR SPECIAL CHARACTER
         CLI   PACKAREA,X'40'      IS CHARACTER BLANK   ???
         BNE   SELST17             CONTINUE SCAN IF NON-BLANK
         B     SELST19             REJECT THE STRING OTHERWISE
*
*        THE CURRENT CHARACTER CAN BE ANY CHARACTER.
*        FALL THROUGH TO ACCEPT THE CHARACTER.
SELST16  DS    0H                  ALLOW ANY CHARACTER HERE
*
*        THE CURRENT CHARACTER IS ACCEPTABLE.
*        ADVANCE TO THE NEXT CHARACTER, AND LOOP.
SELST17  DS    0H                  CONTROL THE STRING SCAN LOOP
         AR    RWORK2,RENTRY       ADVANCE -> MASK   CHARACTER
         SR    RWORK3,RENTRY       DECREMENT MASK CHARACTER COUNT
         AR    RWORK4,RENTRY       ADVANCE -> STRING CHARACTER
         BCT   RWORK5,SELST01      LOOP IF ADDITIONAL CHARS TO CHECK
*
*        THE CHARACTER STRING COMPARED EQUAL,
*        SET CC = 0 AND RETURN TO THE CALLER.
SELST18  DS    0H
         SR    RWORK0,RWORK0       SET ZERO CONDITION CODE
         LM    RLINK,RWORK5,SAVSELST   RELOAD INPUT REGISTERS
         BR    RLINK               RETURN TO CALLER
*
*        THE CHARACTER STRING DID NOT COMPARE EQUAL,
*        SET CC ^= 0 AND RETURN TO THE CALLER.
SELST19  DS    0H
         SLR   RWORK0,RWORK0       SET NON-ZERO CONDITION CODE
         LM    RLINK,RWORK5,SAVSELST   RELOAD INPUT REGISTERS
         BR    RLINK               RETURN TO CALLER
         EJECT  ,
***************************************************************
*                                                             *
*                   V F Y C H R                               *
*                                                             *
*        THIS SUBROUTINE PROVIDES FUNCTION EQUIVALENT         *
*        TO THE "VFYSTR" ROUTINE FOR A VERIFICATION STRING    *
*        CONSISTING OF A SINGLE CHARACTER.  THIS ROUTINE      *
*        RETURNS A BINARY INTEGER VALUE INDICATING THE        *
*        OFFSET TO THE FIRST INPUT STRING BYTE                *
*        NOT EQUAL TO THE FIRST BYTE OF THE VERIFICATION      *
*        STRING.  IF SUCH A BYTE IS FOUND, A NON-ZERO         *
*        CONDITION CODE IS ALSO SET.  IF THE INPUT STRING ADDR*
*        IS NOT PROVIDED, THE INPUT STRING LENGTH IS ZERO,    *
*        THE VERIFICATION STRING ADDRESS IS NOT PROVIDED,     *
*        THE VERIFICATION STRING LENGTH IS ZERO, OR ALL       *
*        OF THE BYTES IN THE INPUT STRING ARE EQUAL TO THE    *
*        FIRST BYTE OF THE VERIFICATION STRING,               *
*        CONDITION CODE ZERO IS SET AND AN OFFSET VALUE       *
*        EQUAL TO THE TOTAL LENGTH OF THE INPUT STRING        *
*        IS RETURNED.                                         *
*                                                             *
*        THIS SUBROUTINE EXPECTS REGISTERS AS FOLLOWS....     *
*             RWORK0   CONTAINS THE ADDRESS OF THE INPUT      *
*                      STRING TO BE VERIFIED.                 *
*             RWORK1   CONTAINS THE LENGTH OF THE INPUT       *
*                      STRING TO BE VERIFIED.                 *
*             RWORK2   CONTAINS THE ADDRESS OF THE            *
*                      VERIFICATION STRING.                   *
*             RWORK3   CONTAINS THE LENGTH OF THE             *
*                      VERIFICATION STRING.                   *
*             RLINK    RETURN ADDRESS TO THE CALLER.          *
*             RENTRY   NOT USED.                              *
*                                                             *
*                                                             *
*        REGISTER VALUES ON RETURN ARE:                       *
*            RENTRY  CONTAINS THE OFFSET VALUE.               *
*            RWORK0  SAME AS ON ENTRY.                        *
*            RWORK1  SAME AS ON ENTRY.                        *
*            RWORK2  SAME AS ON ENTRY.                        *
*            RWORK3  SAME AS ON ENTRY.                        *
*                                                             *
***************************************************************
*
*
*
*
VFYCHRFF DS    0H                  ENTRY POINT;  IN=F,VFY=F
         STM   RLINK,RWORK7,SAVVFYCH                  SAVE REGISTERS
         LR    RWORK4,RWORK0       INPUT STRING START ADDRESS
         LR    RWORK5,RWORK1       INPUT STRING START LENGTH
         LR    RWORK6,RWORK2       VERIFICATION STRING START ADDRESS
         LR    RWORK7,RWORK3       VERIFICATION STRING LENGTH
         B     VFYCH00             TO COMMON ROUTINE
*
*
*
*
VFYCHRFV DS    0H                  ENTRY POINT;  IN=F,VFY=V
         STM   RLINK,RWORK7,SAVVFYCH                  SAVE REGISTERS
         LA    RENTRY,K2           LOAD OFFSET TO TEXT
*
         LR    RWORK4,RWORK0       INPUT STRING START ADDRESS
         LR    RWORK5,RWORK1       INPUT STRING START LENGTH
*
         LTR   RWORK6,RWORK2       VERIFICATION STRING START ADDRESS
         BZ    *+L'*+4+2           IF ADDRESS NOT SUPPLIED
         LH    RWORK7,00(,RWORK2)  VERIFICATION STRING LENGTH
         AR    RWORK6,RENTRY       -> FIRST TEXT BYTE
*
         B     VFYCH00             TO COMMON ROUTINE
*
*
VFYCHRVF DS    0H                  ENTRY POINT;  IN=V,VFY=F
         STM   RLINK,RWORK7,SAVVFYCH                  SAVE REGISTERS
         LA    RENTRY,K2           LOAD OFFSET TO TEXT
*
         LTR   RWORK4,RWORK0       INPUT STRING START ADDRESS
         BZ    *+L'*+4+2           IF ADDRESS NOT SUPPLIED
         LH    RWORK5,00(,RWORK4)  INPUT STRING START LENGTH
         AR    RWORK4,RENTRY       -> FIRST TEXT BYTE
*
         LR    RWORK6,RWORK2       VERIFICATION STRING START ADDRESS
         LR    RWORK7,RWORK3       VERIFICATION STRING LENGTH
*
         B     VFYCH00             TO COMMON ROUTINE
*
*
*
*
VFYCHRVV DS    0H                  ENTRY POINT;  IN=V,VFY=F
         STM   RLINK,RWORK7,SAVVFYCH                  SAVE REGISTERS
         LA    RENTRY,K2           LOAD OFFSET TO TEXT
*
         LTR   RWORK4,RWORK0       INPUT STRING START ADDRESS
         BZ    *+L'*+4+2           IF ADDRESS NOT SUPPLIED
         LH    RWORK5,00(,RWORK4)  INPUT STRING START LENGTH
         AR    RWORK4,RENTRY       -> FIRST TEXT BYTE
*
         LTR   RWORK6,RWORK2       VERIFICATION STRING START ADDRESS
         BZ    *+L'*+4+2           IF ADDRESS NOT SUPPLIED
         LH    RWORK7,00(,RWORK2)  VERIFICATION STRING LENGTH
         AR    RWORK6,RENTRY       -> FIRST TEXT BYTE
*
         B     VFYCH00             TO COMMON ROUTINE
***************************************************************
*
*
*        TEST FOR THE PRESENCE OF A VERIFICATION STRING,
*        AND OF AN INPUT STRING.  IF NEITHER IS PROVIDED,
*        BRANCH TO RETURN A ZERO RESULT.
VFYCH00  DS    0H
         LR    RWORK0,RWORK4       SAVE INPUT STRING START ADDRESS
         BCTR  RWORK0,0                              -1
         LTR   RWORK6,RWORK6       VERIFICATION STRING ADDR SUPPLIED?
         BZ    VFYCH02             IF NOT - RETURN ZERO RESULT
         LTR   RWORK7,RWORK7       VERIFICATION STRING LENGTH ZERO???
         BNP   VFYCH02             IF NOT - RETURN ZERO RESULT
         LTR   RWORK2,RWORK4       INPUT STRING ADDR SUPPLIED?
         BZ    VFYCH02             IF NOT - RETURN ZERO RESULT
         LTR   RWORK3,RWORK5       INPUT STRING LENGTH ZERO???
         BNP   VFYCH02             IF NOT - RETURN ZERO RESULT
*
*
*        BOTH THE INPUT STRING AND A NON-EMPTY VERIFICATION STRING
*        HAVE BEEN PROVIDED; COMPARE UP TO THE FIRST NON-EQUAL BYTE,
*        OR TO THE END OF THE INPUT STRING.
VFYCH01  DS    0H
         IC    RWORK1,00(,RWORK6)  LOAD VERIFICATION CHARACTER
         SLL   RWORK1,K24          SHIFT TO TOP BYTE FOR CLCL
         CLCL  RWORK2,RWORK0       TO END OF STRING OR FIRST ^= BYTE
         BNE   VFYCH03             IF VERIFICATION FAILURE
*
*
*        EITHER THE INPUT STRING WAS MISSING OR HAD ZERO LENGTH;
*        THE VERIFICATION STRING WAS MISSING OR HAD ZERO LENGTH;
*        OR THE INPUT STRING WAS COMPLETELY PROCESSED
*        WITHOUT A VERIFICATION FAILURE.
*        SET THE VALUE OF RWORK2 TO FORCE A ZERO RESULT.
VFYCH02  DS    0H
         LR    RWORK2,RWORK0       SET END ADDR = START-1 ADDR
*
*
*        THE VERIFICATION PROCESS IS COMPLETE,
*        CALCULATE THE RESULT VALUE TO RETURN TO THE CALLER
*        IN REGISTER "RENTRY", AND SET THE CONDITION CODE.
VFYCH03  DS    0H
         LR    RENTRY,RWORK2       COPY END ADDRESS
         SR    RENTRY,RWORK0       COMPUTE RESULT VALUE,               X
                                   AND SET THE CONDITION CODE
         BNZ   *+L'*+4             BRANCH IF BYTE NUMBER CALCULATED
         LA    RENTRY,K1(,RWORK5)  SET BYTE NUMBER = LENGTH+1
         BCTR  RENTRY,0            CONVERT BYTE NUMBER TO OFFSET
*
*
*
*        RELOAD REGISTERS AND RETURN TO THE CALLER,
*        WITH THE RESULT VALUE IN REGISTER "RENTRY".
VFYCH04  DS    0H
         LM     RLINK,RLINK,SAVVFYCH              RESTORE REGISTERS
         LM    RWORK0,RWORK7,SAVVFYCH+8+4*RWORK0  RESTORE REGISTERS
         BR    RLINK               RETURN TO CALLER
         EJECT  ,
***************************************************************
*                                                             *
*                   V F Y S T R                               *
*                                                             *
*        THIS SUBROUTINE SEARCHES AN INPUT STRING AND         *
*        RETURNS A BINARY INTEGER VALUE INDICATING THE        *
*        OFFSET TO THE FIRST INPUT STRING BYTE NOT CONTAINED  *
*        IN THE VERIFICATION STRING.  IF SUCH A BYTE IS FOUND,*
*        A NON-ZERO CONDITION CODE IS ALSO SET.  IF           *
*        THE INPUT STRING ADDRESS IS NOT PROVIDED,            *
*        THE INPUT STRING LENGTH IS ZERO, THE VERIFICATION    *
*        STRING LENGTH IS ZERO, OR ALL OF THE BYTES IN THE    *
*        INPUT STRING APPEAR IN THE VERIFICATION STRING,      *
*        CONDITION CODE ZERO IS SET AND AN OFFSET VALUE       *
*        EQUAL TO THE TOTAL LENGTH OF THE INPUT STRING        *
*        IS RETURNED.                                         *
*                                                             *
*                                                             *
*                                                             *
*        THIS SUBROUTINE EXPECTS REGISTERS AS FOLLOWS....     *
*             RWORK0   CONTAINS THE ADDRESS OF THE INPUT      *
*                      STRING TO BE VERIFIED.                 *
*             RWORK1   CONTAINS THE LENGTH OF THE INPUT       *
*                      STRING TO BE VERIFIED.                 *
*             RWORK2   CONTAINS THE ADDRESS OF THE            *
*                      VERIFICATION STRING.  IF THIS ADDRESS  *
*                      IS ZERO, THE TRT TABLE BUILT DURING    *
*                      THE LAST EXECUTION OF THIS ROUTINE     *
*                      WITH A VALID VERIFICATION STRING IS    *
*                      USED, SAVING THE EXECUTION TIME        *
*                      REQUIRED TO REBUILD THE TRT TABLE.     *
*             RWORK3   CONTAINS THE LENGTH OF THE             *
*                      VERIFICATION STRING.                   *
*             RLINK    RETURN ADDRESS TO THE CALLER.          *
*             RENTRY   NOT USED.                              *
*                                                             *
*                                                             *
*        REGISTER VALUES ON RETURN ARE:                       *
*            RENTRY  CONTAINS THE OFFSET VALUE.               *
*            RWORK0  SAME AS ON ENTRY.                        *
*            RWORK1  SAME AS ON ENTRY.                        *
*            RWORK2  SAME AS ON ENTRY.                        *
*            RWORK3  SAME AS ON ENTRY.                        *
*                                                             *
***************************************************************
*
*
*
*
VFYSTRFF DS    0H                  ENTRY POINT;  IN=F,VFY=F
         STM   RLINK,RWORK7,SAVVFYST                  SAVE REGISTERS
         LR    RWORK4,RWORK0       INPUT STRING START ADDRESS
         LR    RWORK5,RWORK1       INPUT STRING START LENGTH
         LR    RWORK6,RWORK2       VERIFICATION STRING START ADDRESS
         LR    RWORK7,RWORK3       VERIFICATION STRING LENGTH
         B     VFYST00             TO COMMON ROUTINE
*
*
*
*
VFYSTRFV DS    0H                  ENTRY POINT;  IN=F,VFY=V
         STM   RLINK,RWORK7,SAVVFYST                  SAVE REGISTERS
         LA    RENTRY,K2           LOAD OFFSET TO TEXT
*
         LR    RWORK4,RWORK0       INPUT STRING START ADDRESS
         LR    RWORK5,RWORK1       INPUT STRING START LENGTH
*
         LTR   RWORK6,RWORK2       VERIFICATION STRING START ADDRESS
         BZ    *+L'*+4+2           IF ADDRESS NOT SUPPLIED
         LH    RWORK7,00(,RWORK2)  VERIFICATION STRING LENGTH
         AR    RWORK6,RENTRY       -> FIRST TEXT BYTE
*
         B     VFYST00             TO COMMON ROUTINE
*
*
VFYSTRVF DS    0H                  ENTRY POINT;  IN=V,VFY=F
         STM   RLINK,RWORK7,SAVVFYST                  SAVE REGISTERS
         LA    RENTRY,K2           LOAD OFFSET TO TEXT
*
         LTR   RWORK4,RWORK0       INPUT STRING START ADDRESS
         BZ    *+L'*+4+2           IF ADDRESS NOT SUPPLIED
         LH    RWORK5,00(,RWORK4)  INPUT STRING START LENGTH
         AR    RWORK4,RENTRY       -> FIRST TEXT BYTE
*
         LR    RWORK6,RWORK2       VERIFICATION STRING START ADDRESS
         LR    RWORK7,RWORK3       VERIFICATION STRING LENGTH
*
         B     VFYST00             TO COMMON ROUTINE
*
*
*
*
VFYSTRVV DS    0H                  ENTRY POINT;  IN=V,VFY=F
         STM   RLINK,RWORK7,SAVVFYST                  SAVE REGISTERS
         LA    RENTRY,K2           LOAD OFFSET TO TEXT
*
         LTR   RWORK4,RWORK0       INPUT STRING START ADDRESS
         BZ    *+L'*+4+2           IF ADDRESS NOT SUPPLIED
         LH    RWORK5,00(,RWORK4)  INPUT STRING START LENGTH
         AR    RWORK4,RENTRY       -> FIRST TEXT BYTE
*
         LTR   RWORK6,RWORK2       VERIFICATION STRING START ADDRESS
         BZ    *+L'*+4+2           IF ADDRESS NOT SUPPLIED
         LH    RWORK7,00(,RWORK2)  VERIFICATION STRING LENGTH
         AR    RWORK6,RENTRY       -> FIRST TEXT BYTE
*
         B     VFYST00             TO COMMON ROUTINE
***************************************************************
*
*
*        PREPARE TO BEGIN VERIFYING THE INPUT STRING.
VFYST00  DS    0H                  COMMON VERIFY ROUTINE
         LA    RLINK,STRVFTBL      -> VERIFY TRT TABLE IN WORK AREA
         LA    RENTRY,K256         LOAD CONSTANT VALUE
         LR    RWORK0,RWORK4       SAVE INPUT STRING START ADDRESS
         BCTR  RWORK0,0                              -1
*
*
*        TEST FOR THE PRESENCE OF A VERIFICATION STRING,
*        AND IF ONE IS PROVIDED,
*        INITIALIZE THE TRT TABLE TO ALL NON-ZERO VALUES -- X'01'.
VFYST01  DS    0H
         LTR   RWORK6,RWORK6       VERIFICATION STRING ADDR SUPPLIED?
         BZ    VFYST04             IF NOT - USE TRT TABLE PREV BUILT
         LTR   RWORK7,RWORK7       VERIFICATION STRING LENGTH ZERO???
         BNP   VFYST07             IF NOT - RETURN ZERO RESULT
         LA    RWORK1,K1           LOAD NON-ZERO VALUE
         SLL   RWORK1,K24          SHIFT TO TOP BYTE FOR MVCL
         LR    RWORK2,RLINK        -> TRT TABLE IN WORK AREA
         LR    RWORK3,RENTRY          TRT TABLE LENGTH
         MVCL  RWORK2,RWORK0       SET TRT TABLE TO ALL X'01'
*
*
*        SET UP REGISTER VALUES TO ALLOW SETTING
*        TRT TABLE BYTES TO ZERO.
VFYST02  DS    0H
         SR    RWORK1,RWORK1       CLEAR REGISTER
         LA    RWORK2,K1           LOAD BXLE INCREMENT
         LA    RWORK3,00(RWORK7,RWORK6)      VERIF STR END+1 ADDR
         SR    RWORK3,RWORK2       VERIF STRING END ADDR FOR BXLE
*
*
*        SET THE TRT TABLE BYTES CORRESPONDING
*        TO THE VERIFICATION CHARACTERS TO ZERO.
VFYST03  DS    0H
         IC    RWORK1,00(,RWORK6)  LOAD VERIFICATION CHARACTER
         STC   RENTRY,00(RWORK1,RLINK)  SET TRT TABLE BYTE TO ZERO
         BXLE  RWORK6,RWORK2,VFYST03    LOOP UNTIL ALL VERIFICATION    X
                                   CHARACTERS HAVE BEEN PROCESSED
*
*
*        TEST FOR THE PRESENCE OF AN INPUT STRING,
*        AND INITIALIZE REGISTERS FOR VERIFYING THE INPUT STRING.
VFYST04  DS    0H
         LTR   RWORK1,RWORK4       INPUT STRING ADDR SUPPLIED?
         BZ    VFYST07             IF NOT - RETURN ZERO RESULT
         LTR   RWORK2,RWORK5       INPUT STRING LENGTH ZERO???
         BNP   VFYST07             IF NOT - RETURN ZERO RESULT
         CR    RWORK2,RENTRY       MORE THAN 256 BYTES TO VERIFY??
         BNH   VFYST06             BRANCH IF NOT
         LR    RWORK2,RENTRY       COPY INCREMENT FOR BXLE
         LA    RWORK3,00(RWORK5,RWORK4) INPUT STRING END+1 BYTE ADDR
         SR    RWORK3,RWORK2       INPUT STRING END BYTE ADDR FOR BXLE
*
*
*        THE INPUT STRING IS LONGER THAN 256 BYTES,
*        LOOP THROUGH THE STRING IN 256 BYTE SEGMENTS USING TRT
*        UNTIL ALL 256 BYTE SEGMENTS HAVE BEEN PROCESSED, OR UNTIL
*        A BYTE FAILING VERIFICATION IS FOUND.
VFYST05  DS    0H
         TRT   00(K256,RWORK1),00(RLINK)   VERIFY 256 BYTES
         BNZ   VFYST08             IF VERIFICATION FAILURE
         BXLE  RWORK1,RWORK2,VFYST05    LOOP UNTIL ALL 256 BYTE        X
                                        SEGMENTS HAVE BEEN PROCESSED
         AR    RWORK2,RWORK3            RECOVER END+1 ADDRESS
         SR    RWORK2,RWORK1            COMPUTE REMAINING LENGTH
         BNP   VFYST07                  IF NO LENGTH REMAINS,          X
                                        ALL BYTES WERE PROCESSED
*
*
*        EITHER THE INPUT STRING CONTAINS 256 BYTES OR LESS,
*        OR THERE WERE BYTES REMAINING TO PROCESS AFTER ALL
*        COMPLETE 256 BYTE SEGMENTS WERE PROCESSED.
VFYST06  DS    0H
         BCTR  RWORK2,0            DECREMENT LENGTH FOR TRT
         EX    RWORK2,VFYSTTRT     VERIFY LAST GROUP OF BYTES
         BNZ   VFYST08             IF VERIFICATION FAILURE
*
*
*        EITHER THE INPUT STRING WAS MISSING, HAD ZERO LENGTH,
*        THE VERIFICATION STRING HAD ZERO LENGTH,
*        OR THE INPUT STRING WAS COMPLETELY PROCESSED
*        WITHOUT A VERIFICATION FAILURE.
*        SET THE VALUE OF RWORK1 TO FORCE A ZERO RESULT.
VFYST07  DS    0H
         LR    RWORK1,RWORK0       SET END ADDR = START-1 ADDR
*
*
*        THE VERIFICATION PROCESS IS COMPLETE,
*        CALCULATE THE RESULT VALUE TO RETURN TO THE CALLER
*        IN REGISTER "RENTRY", AND SET THE CONDITION CODE.
VFYST08  DS    0H
         LR    RENTRY,RWORK1       COPY END ADDRESS
         SR    RENTRY,RWORK0       COMPUTE RESULT VALUE,               X
                                   AND SET THE CONDITION CODE
         BNZ   *+L'*+4             BRANCH IF BYTE NUMBER CALCULATED
         LA    RENTRY,K1(,RWORK5)  SET BYTE NUMBER = LENGTH+1
         BCTR  RENTRY,0            CONVERT BYTE NUMBER TO OFFSET
*
*
*
*        RELOAD REGISTERS AND RETURN TO THE CALLER,
*        WITH THE RESULT VALUE IN REGISTER "RENTRY".
VFYST09  DS    0H
         LM     RLINK,RLINK,SAVVFYST              RESTORE REGISTERS
         LM    RWORK0,RWORK7,SAVVFYST+8+4*RWORK0  RESTORE REGISTERS
         BR    RLINK               RETURN TO CALLER
*
*
*
*        THE FOLLOWING INSTRUCTION IS EXECUTED.
VFYSTTRT TRT   00(*-*,RWORK1),00(RLINK)
         TITLE '$ORTPARM - EDITING AND FORMATTING ROUTINES'
*****************************************************************
*                                                               *
*                   E D I T B I N                               *
*                                                               *
*        SUBROUTINE TO EDIT AN INTEGER VALUE EXPRESSSED         *
*        IN BINARY TO AN EBCDIC VALUE, AND COPY THE EDITED      *
*        RESULT TO THE CALLER'S ANSWER AREA, LEFT JUSTIFIED.    *
*                                                               *
*        INPUT REGISTERS ARE:                                   *
*              RLINK     RETURN ADDRESS TO THE CALLER;          *
*              RENTRY    INTEGER VALUE IN BINARY.               *
*              RWORK0    NOT USED.                              *
*              RWORK1    NOT USED.                              *
*              RWORK2    ADDRESS OF AN OUTPUT AREA TO           *
*                        WHICH THE EDITED RESULT WILL BE        *
*                        COPIED, OR ZERO.                       *
*              RWORK3    LENGTH OF THE OUTPUT AREA IF RWORK2    *
*                        IS NOT ZERO.                           *
*                                                               *
*        OUTPUT REGISTERS ARE:                                  *
*              RLINK     RETURN ADDRESS TO THE CALLER;          *
*              RENTRY    UNCHANGED - SAME AS ON INPUT           *
*                                                               *
*              RWORK0    ZERO IF THE OUTPUT AREA ADDRESS WAS    *
*                        PROVIDED(RWORK2 ^= 0), OTHERWISE       *
*                        THE ADDRESS OF THE EDITED RESULT       *
*                        IN EDIT ROUTINE COMMON RESULT AREA     *
*                        "EDTRSLT".                             *
*                                                               *
*              RWORK1    LENGTH OF THE FIELD ACTUALLY COPIED    *
*                        IF THE OUTPUT AREA ADDRESS WAS         *
*                        PROVIDED(RWORK2 ^= 0), OTHERWISE       *
*                        THE LENGTH OF THE EDITED RESULT        *
*                        IN EDIT ROUTINE COMMON RESULT AREA     *
*                        "EDTRSLT".                             *
*                                                               *
*              RWORK2    UNCHANGED - SAME AS ON INPUT           *
*              RWORK3    UNCHANGED - SAME AS ON INPUT           *
*                                                               *
*                                                               *
*****************************************************************
*
*
EDITBIN  DS    0H                 SUBROUTINE ENTRY POINT
         STM   RLINK,RWORK5,SAVEDBIN        SAVE CALLER'S REGISTERS
*
*
*        CONVERT THE INTEGER TO PACKED DECIMAL FORMAT
*        AND EDIT IT.
EDBIN00  DS    0H                  BEGIN ACTUAL CONVERSION TO EBCDIC
         CVD   RENTRY,PACKAREA     CONVERT INTEGER TO PACKED DECIMAL
         MVC   EDTRSLT(L'EDBINMSK),EDBINMSK COPY EDIT MASK TO WORK AREA
         LA    RWORK1,EDTRSLT+L'EDBINMSK-1  SET REGISTER FOR EDMK
         EDMK  EDTRSLT(L'EDBINMSK),PACKAREA+02  EDIT INTEGER VALUE:    X
                                   RWORK1 -> FIRST SIGNIFICANT DIGIT
         BNM   *+L'*+2+4           BRANCH IF RESULT NOT NEGATIVE
         BCTR  RWORK1,0            RWORK1 -> FIRST SIGNIFICANT DIGIT-1
         MVI   00(RWORK1),EMINUS   PROVIDE MINUS SIGN
*
*
*        COPY THE EDITED VALUE TO THE CALLER'S OUTPUT AREA.
EDBIN01  DS    0H                  COPY RESULT TO ANSWER AREA
         LR    RWORK0,RWORK1       ADDRESS OF RESULT IN WORK AREA
         LA    RWORK1,EDTRSLT+L'EDBINMSK   RIGHTMOST+1 DIGIT OF RESULT
         SR    RWORK1,RWORK0       COMPUTE LENGTH OF RESULT
         LM    RWORK2,RWORK3,SAVEDBIN+8+4*RWORK2  OUTPUT AREA ->S
         LTR   RWORK4,RWORK2       COPY OUTPUT AREA START ADDRESS
         BZ    EDBIN02             RETURN ADDR & LN IF NO OUTPUT AREA
         CR    RWORK1,RWORK3       COMPARE TO LENGTH OF AREA
         BNH   *+L'*+2             BRANCH IF RESULT NOT LARGER,
         LR    RWORK1,RWORK3       OTHERWISE USE SMALLER LENGTH
         LR    RWORK3,RWORK1       SET TARGET LENGTH FOR COPY
         MVCL  RWORK2,RWORK0       COPY RESULT TO ANSWER AREA
         SR    RWORK0,RWORK0       SET REGISTER TO ZERO
         LR    RWORK1,RWORK2               COMPUTE LENGTH
         SR    RWORK1,RWORK4               ACTUALLY COPIED
*
*
*        RESTORE REGISTERS AND RETURN TO THE CALLER.
EDBIN02  DS    0H
         LM     RLINK,RENTRY,SAVEDBIN+0              RESTORE REGISTERS
         LM    RWORK2,RWORK5,SAVEDBIN+8+4*RWORK2     RESTORE REGISTERS
         BR    RLINK                                 RETURN TO CALLER
*
*
*        CONSTANTS USED BY THE "EDITBIN " ROUTINE.
EDBINMSK DC    X'4020206B2020206B2020206B202120'  EDIT MASK - INTEGERS
         EJECT  ,
*****************************************************************
*                                                               *
*                   E D I T B I T                               *
*                                                               *
*        SUBROUTINE TO CONVERT A CHARACTER STRING TO ITS        *
*        EBCDIC BIT STRING EQUIVALENT AND COPY THE RESULTS      *
*        TO AN OUTPUT AREA PROVIDED BY THE CALLER.              *
*                                                               *
*        INPUT REGISTERS ARE:                                   *
*              RLINK     RETURN ADDRESS TO THE CALLER;          *
*              RENTRY    NUMBER OF BYTES TO BE REPRESENTED      *
*                        IN AN OUTPUT GROUP.  EACH OUTPUT       *
*                        GROUP CONSISTS OF A STRING OF          *
*                        EBCDIC ZEROS AND ONES, AND             *
*                        EACH COMPLETE GROUP IS SEPARATED BY    *
*                        A BLANK CHARACTER.  IF THIS REGISTER   *
*                        IS ZERO, NO BLANK SEPARATION OCCURS.   *
*              RWORK0    ADDRESS OF THE FIRST BYTE OF THE       *
*                        CHARACTER STRING TO BE REPRESENTED     *
*                        IN THE OUTPUT AREA AS EBCDIC ZEROS     *
*                        AND ONES.                              *
*              RWORK1    LENGTH OF THE CHARACTER STRING         *
*                        IN BYTES.                              *
*              RWORK2    ADDRESS OF AN OUTPUT AREA TO WHICH     *
*                        THE EBCDIC BIT STRING REPRESENTATION   *
*                        WILL BE PLACED.                        *
*              RWORK3    LENGTH OF THE OUTPUT AREA.             *
*                                                               *
*        OUTPUT REGISTERS ARE:                                  *
*              RLINK     RETURN ADDRESS TO THE CALLER;          *
*              RENTRY    UNCHANGED - SAME AS ON INPUT           *
*              RWORK0    ZERO                                   *
*              RWORK1    LENGTH OF THE RESULT PLACED IN THE     *
*                        OUTPUT AREA.                           *
*              RWORK2    UNCHANGED - SAME AS ON INPUT           *
*              RWORK3    UNCHANGED - SAME AS ON INPUT           *
*                                                               *
*                                                               *
*****************************************************************
*
*
*        SECONDARY ENTRY POINT TO PROVIDE OUTPUT
*        IN GROUPS OF ONE BYTE (EIGHT EBCDIC BITS PER GROUP).
EDITBIT1 DS    0H                  GENERAL ENTRY POINT
         STM   RLINK,RWORK7,SAVEDBIT+0      SAVE CALLER'S REGISTERS
         LA    RENTRY,K1           LOAD GROUP SIZE
         B     EDBIT00             ENTER MAINLINE ROUTINE
*
*
*        SECONDARY ENTRY POINT TO PROVIDE OUTPUT
*        WITHOUT GROUPING.
EDITBIT0 DS    0H                  GENERAL ENTRY POINT
         STM   RLINK,RWORK5,SAVEDBIT+0      SAVE CALLER'S REGISTERS
         SR    RENTRY,RENTRY       SET GROUP SIZE TO ZERO
         B     EDBIT00             ENTER MAINLINE ROUTINE
*
*
*        GENERAL PURPOSE ENTRY POINT WHERE THE CALLER HAS PROVIDED
*        THE OUTPUT GROUP SIZE IN REGISTER "RENTRY".
EDITBIT  DS    0H                  GENERAL ENTRY POINT
         STM   RLINK,RWORK5,SAVEDBIT+0      SAVE CALLER'S REGISTERS
*
*
*        SET UP REGISTERS FOR PROCESSING
EDBIT00  DS    0H
         LR    RWORK4,RWORK2       OUTPUT AREA START
         LR    RWORK5,RWORK3       OUTPUT AREA LENGTH
         LR    RWORK6,RWORK0       CHARACTER STRING START
         LR    RWORK7,RWORK1       CHARACTER STRING LENGTH
         LTR   RENTRY,RENTRY       INPUT GROUP SIZE
         BP    *+L'*+2             BRANCH IF POSITIVE
         LR    RENTRY,RWORK7       MAKE INPUT A SINGLE GROUP
*
*
*        BEGIN PROCESSING THE NEXT GROUP OF BYTES:
*        DETERMINE THE NUMBER OF BYTES TO CONVERT IN THIS PASS.
EDBIT01  DS    0H                  BEGIN ACTUAL CONVERSION TO EBCDIC
         LR    RWORK2,RWORK5       NUMBER OF BYTES THAT CAN BE
         SRL   RWORK2,K3           REPRESENTED AS BITS IN OUTPUT AREA
         CR    RWORK2,RWORK7       COMPARE TO SIZE OF REMAINING INPUT
         BL    *+L'*+2             BRANCH IF SMALLER THAN INPUT
         LR    RWORK2,RWORK7       LIMIT TO REMAINING INPUT
         CR    RWORK2,RENTRY       COMPARE TO OUTPUT GROUP SIZE
         BL    *+L'*+2             BRANCH IF SMALLER THAN GROUP SIZE
         LR    RWORK2,RENTRY       LIMIT TO OUTPUT GROUP SIZE
         SRDA  RWORK2,K32          SHIFT FOR DIVIDE AND SET CC
         BNP   EDBIT09             IF INPUT STRING EDIT IS COMPLETE
*
*
*        DETERMINE THE NUMBER OF ITERATIONS REQUIRED TO EDIT THE
*        CURRENT GROUP TO THE OUTPUT AREA.
EDBIT02  DS    0H                  BEGIN ACTUAL CONVERSION TO EBCDIC
         LA    RWORK1,K4           LOAD DIVISOR (SEGMENT SIZE)
         LR    RWORK0,RWORK1       COPY DIVISOR
         SLL   RWORK0,K3                DIVISOR * 8
         DR    RWORK2,RWORK1       GET NUMBER OF SEGMENTS IN RWORK3,   X
                                   AND REMAINDER IN RWORK2
         LTR   RWORK3,RWORK3       TEST NUMBER OF FULL SEGMENTS
         BNP   EDBIT04             IF NO FULL SEGMENTS TO EDIT
*
*
*        COPY FULL SEGMENTS(32 RESULT BYTES) OF EBCDIC BIT CHARACTERS
*        TO THE OUTPUT AREA.
EDBIT03  DS    0H                  BEGIN ACTUAL CONVERSION TO EBCDIC
         MVC   PACK1(1*K4),00(RWORK6)    COPY INPUT STRING SEGMENT
         UNPK  PACK3+0*K4(2*K4+1),PACK1+0*K4(K4+1)   UNPACK BYTES
         TR    PACK3(2*K4),TRQBIT4-X'F0' CONVERT TO BASE4 PACKED DIGITS
         UNPK  PACK2+0*K4(2*K4+1),PACK3+0*K4(K4+1)   UNPACK BYTES
         UNPK  PACK2+2*K4(2*K4+1),PACK3+1*K4(K4+1)   UNPACK BYTES
         TR    PACK2(4*K4),TRQBIT2-X'F0' CONVERT TO BASE2 PACKED DIGITS
         UNPK  PACK1+0*K4(2*K4+1),PACK2+0*K4(K4+1)   UNPACK BYTES
         UNPK  PACK1+2*K4(2*K4+1),PACK2+1*K4(K4+1)   UNPACK BYTES
         UNPK  PACK1+4*K4(2*K4+1),PACK2+2*K4(K4+1)   UNPACK BYTES
         UNPK  PACK1+6*K4(2*K4+1),PACK2+3*K4(K4+1)   UNPACK BYTES
         MVC   00(8*K4,RWORK4),PACK1      COPY RESULT TO OUTPUT
         AR    RWORK4,RWORK0             UPDATE OUTPUT AREA ADDR
         SR    RWORK5,RWORK0             DECREMENT REMAINING LENGTH
         AR    RWORK6,RWORK1             UPDATE CHARACTER STRING ADDR
         SR    RWORK7,RWORK1             DECREMENT REMAINING LENGTH
         BCT   RWORK3,EDBIT03            LOOP UNTIL DONE
*
*
*        TEST FOR ANY PARTIAL SEGMENTS TO BE CONVERTED AND COPIED
*        TO THE OUTPUT AREA.
EDBIT04  DS    0H                  COPY RESULT TO ANSWER AREA
         LTR   RWORK1,RWORK2       NUMBER OF BYTES IN LAST SEGMENT
         BNP   EDBIT06             IF NONE
         LR    RWORK0,RWORK1       COPY # OF BYTES IN LAST SEGMENT
         SLL   RWORK0,K3           OUTPUT SIZE CORRESPONDING TO SGMNT
*
*
*        CONVERT THE LAST SEGMENT OF THE GROUP.
EDBIT05  DS    0H                  TIME VALUE CONVERSION IS COMPLETE
         BCTR  RWORK2,0            DECREMENT LENGTH FOR MVC
         EX    RWORK2,EDBITMV1     COPY INPUT STRING TO PACK1
         UNPK  PACK3+0*K4(2*K4+1),PACK1+0*K4(K4+1)   UNPACK BYTES
         TR    PACK3(2*K4),TRQBIT4-X'F0' CONVERT TO BASE4 PACKED DIGITS
         UNPK  PACK2+0*K4(2*K4+1),PACK3+0*K4(K4+1)   UNPACK BYTES
         UNPK  PACK2+2*K4(2*K4+1),PACK3+1*K4(K4+1)   UNPACK BYTES
         TR    PACK2(4*K4),TRQBIT2-X'F0' CONVERT TO BASE2 PACKED DIGITS
         UNPK  PACK1+0*K4(2*K4+1),PACK2+0*K4(K4+1)   UNPACK BYTES
         UNPK  PACK1+2*K4(2*K4+1),PACK2+1*K4(K4+1)   UNPACK BYTES
         UNPK  PACK1+4*K4(2*K4+1),PACK2+2*K4(K4+1)   UNPACK BYTES
         UNPK  PACK1+6*K4(2*K4+1),PACK2+3*K4(K4+1)   UNPACK BYTES
         LR    RWORK2,RWORK0       LENGTH OF RESULT IN OUTPUT
         BCTR  RWORK2,0            DECREMENT LENGTH FOR MVC
         EX    RWORK2,EDBITCY1     COPY RESULT TO OUTPUT
         AR    RWORK4,RWORK0             UPDATE OUTPUT AREA ADDR
         SR    RWORK5,RWORK0             DECREMENT REMAINING LENGTH
         AR    RWORK6,RWORK1             UPDATE CHARACTER STRING ADDR
         SR    RWORK7,RWORK1             DECREMENT REMAINING LENGTH
*
*
*        IF ADDITIONAL BYTES REMAIN TO PROCESS,
*        INSERT A BLANK AT THE END OF THE OUTPUT GROUP.
EDBIT06  DS    0H
         LTR   RWORK7,RWORK7       DO ANY INPUT BYTES REMAIN??
         BNP   EDBIT09             IF INPUT EXHAUSTED
         C     RWORK5,F9           ANY ROOM LEFT IN OUTPUT AREA??
         BL    EDBIT09             IF OUTPUT AREA EXHAUSTED
         LA    RWORK0,K1           LENGTH OF BLANK
         MVI   00(RWORK4),EBLANK   INSERT BLANK SEPARATOR
         AR    RWORK4,RWORK0       UPDATE OUTPUT AREA POINTER
         SR    RWORK5,RWORK0       DECREMENT REMAINING LENGTH
         B     EDBIT01             LOOP FOR THE NEXT OUTPUT GROUP
*
*
*        RESTORE REGISTERS AND RETURN TO THE CALLER.
EDBIT09  DS    0H
         LR    RWORK1,RWORK4       COPY OUTPUT END+1 ADDRESS
         LM     RLINK,RENTRY,SAVEDBIT+0              RESTORE REGISTERS
         LM    RWORK2,RWORK7,SAVEDBIT+8+4*RWORK2     RESTORE REGISTERS
         SR    RWORK0,RWORK0       ZERO RWORK0
         SR    RWORK1,RWORK2       COMPUTE LENGTH & SET CC
         BR    RLINK                                 RETURN TO CALLER
*
*
*        THE FOLLOWING INSTRUCTIONS ARE "EXECUTED".
EDBITMV1 MVC   PACK1(*-*),00(RWORK6)       COPY INPUT STRING
EDBITCY1 MVC   00(*-*,RWORK4),PACK1        COPY RESULT TO OUTPUT
         EJECT  ,
*****************************************************************
*                                                               *
*                   E D I T H E X                               *
*                                                               *
*        SUBROUTINE TO CONVERT A CHARACTER STRING TO ITS        *
*        EBCDIC HEXADECIMAL EQUIVALENT AND COPY THE RESULTS     *
*        TO AN OUTPUT AREA PROVIDED BY THE CALLER.              *
*                                                               *
*        INPUT REGISTERS ARE:                                   *
*              RLINK     RETURN ADDRESS TO THE CALLER;          *
*              RENTRY    NUMBER OF BYTES TO BE REPRESENTED      *
*                        IN AN OUTPUT GROUP.  EACH OUTPUT       *
*                        GROUP CONSISTS OF A STRING OF          *
*                        EBCDIC HEXADECIMAL DIGITS, AND         *
*                        EACH COMPLETE GROUP IS SEPARATED BY    *
*                        A BLANK CHARACTER.  IF THIS REGISTER   *
*                        IS ZERO, NO BLANK SEPARATION OCCURS.   *
*              RWORK0    ADDRESS OF THE FIRST BYTE OF THE       *
*                        CHARACTER STRING TO BE REPRESENTED     *
*                        IN THE OUTPUT AREA IN EBCDIC           *
*                        HEXADECIMAL.                           *
*              RWORK1    LENGTH OF THE CHARACTER STRING.        *
*              RWORK2    ADDRESS OF AN OUTPUT AREA TO WHICH     *
*                        THE EBCDIC HEXADECIMAL REPRESENTATION  *
*                        WILL BE PLACED.                        *
*              RWORK3    LENGTH OF THE OUTPUT AREA.             *
*                                                               *
*        OUTPUT REGISTERS ARE:                                  *
*              RLINK     RETURN ADDRESS TO THE CALLER;          *
*              RENTRY    UNCHANGED - SAME AS ON INPUT           *
*              RWORK0    ZERO                                   *
*              RWORK1    LENGTH OF THE RESULT PLACED IN THE     *
*                        OUTPUT AREA.                           *
*              RWORK2    UNCHANGED - SAME AS ON INPUT           *
*              RWORK3    UNCHANGED - SAME AS ON INPUT           *
*                                                               *
*                                                               *
*****************************************************************
*
*
*        SECONDARY ENTRY POINT TO PROVIDE OUTPUT
*        IN GROUPS OF TWO BYTES (FOUR HEXADECIMAL DIGITS PER GROUP).
EDITHEX2 DS    0H                  GENERAL ENTRY POINT
         STM   RLINK,RWORK7,SAVEDHEX+0      SAVE CALLER'S REGISTERS
         LA    RENTRY,K2           LOAD GROUP SIZE
         B     EDHEX00             ENTER MAINLINE ROUTINE
*
*
*        SECONDARY ENTRY POINT TO PROVIDE OUTPUT
*        WITHOUT GROUPING.
EDITHEX0 DS    0H                  GENERAL ENTRY POINT
         STM   RLINK,RWORK7,SAVEDHEX+0      SAVE CALLER'S REGISTERS
         SR    RENTRY,RENTRY       SET GROUP SIZE TO ZERO
         B     EDHEX00             ENTER MAINLINE ROUTINE
*
*
*        GENERAL PURPOSE ENTRY POINT WHERE THE CALLER HAS PROVIDED
*        THE OUTPUT GROUP SIZE IN REGISTER "RENTRY".
EDITHEX  DS    0H                  GENERAL ENTRY POINT
         STM   RLINK,RWORK7,SAVEDHEX+0      SAVE CALLER'S REGISTERS
*
*
*        SET UP REGISTERS FOR PROCESSING
EDHEX00  DS    0H
         LR    RWORK4,RWORK2       OUTPUT AREA START
         LR    RWORK5,RWORK3       OUTPUT AREA LENGTH
         LR    RWORK6,RWORK0       CHARACTER STRING START
         LR    RWORK7,RWORK1       CHARACTER STRING LENGTH
         LTR   RENTRY,RENTRY       INPUT GROUP SIZE
         BP    *+L'*+2             BRANCH IF POSITIVE
         LR    RENTRY,RWORK7       MAKE INPUT A SINGLE GROUP
*
*
*        BEGIN PROCESSING THE NEXT GROUP OF BYTES:
*        DETERMINE THE NUMBER OF BYTES TO CONVERT IN THIS PASS.
EDHEX01  DS    0H                  BEGIN ACTUAL CONVERSION TO EBCDIC
         LR    RWORK2,RWORK5       NUMBER OF BYTES THAT CAN BE
         SRL   RWORK2,K1           REPRESENTED IN THE OUTPUT AREA
         CR    RWORK2,RWORK7       COMPARE TO SIZE OF REMAINING INPUT
         BL    *+L'*+2             BRANCH IF SMALLER THAN INPUT
         LR    RWORK2,RWORK7       LIMIT TO REMAINING INPUT
         CR    RWORK2,RENTRY       COMPARE TO OUTPUT GROUP SIZE
         BL    *+L'*+2             BRANCH IF SMALLER THAN GROUP SIZE
         LR    RWORK2,RENTRY       LIMIT TO OUTPUT GROUP SIZE
         SRDA  RWORK2,K32          SHIFT FOR DIVIDE AND SET CC
         BNP   EDHEX09             IF INPUT STRING EDIT IS COMPLETE
*
*
*        DETERMINE THE NUMBER OF ITERATIONS REQUIRED TO EDIT THE
*        CURRENT GROUP TO THE OUTPUT AREA.
EDHEX02  DS    0H                  BEGIN ACTUAL CONVERSION TO EBCDIC
         LA    RWORK1,K8           LOAD DIVISOR (SEGMENT SIZE)
         LR    RWORK0,RWORK1       COPY DIVISOR
         SLL   RWORK0,K1                DIVISOR * 2
         DR    RWORK2,RWORK1       GET NUMBER OF SEGMENTS IN RWORK3,   X
                                   AND REMAINDER IN RWORK2
         LTR   RWORK3,RWORK3       TEST NUMBER OF FULL SEGMENTS
         BNP   EDHEX04             IF NO FULL SEGMENTS TO EDIT
*
*
*        COPY FULL SEGMENTS OF EBCDIC HEXADECIMAL DIGITS
*        TO THE OUTPUT AREA.
EDHEX03  DS    0H                  BEGIN ACTUAL CONVERSION TO EBCDIC
         MVC   PACK3(1*K8),00(RWORK6)    COPY INPUT STRING SEGMENT
         UNPK  PACK1+0*K8(1*K8+1),PACK3+0*K4(K4+1)   UNPACK BYTES
         UNPK  PACK1+1*K8(1*K8+1),PACK3+1*K4(K4+1)   UNPACK BYTES
         TR    PACK1(2*K8),TRBHEX-X'F0'  CONVERT BINARY HEX TO EBCDIC
         MVC   00(2*K8,RWORK4),PACK1     COPY RESULT TO OUTPUT
         AR    RWORK4,RWORK0             UPDATE OUTPUT AREA ADDR
         SR    RWORK5,RWORK0             DECREMENT REMAINING LENGTH
         AR    RWORK6,RWORK1             UPDATE CHARACTER STRING ADDR
         SR    RWORK7,RWORK1             DECREMENT REMAINING LENGTH
         BCT   RWORK3,EDHEX03            LOOP UNTIL DONE
*
*
*        TEST FOR ANY PARTIAL SEGMENTS TO BE CONVERTED AND COPIED
*        TO THE OUTPUT AREA.
EDHEX04  DS    0H                  COPY RESULT TO ANSWER AREA
         LTR   RWORK1,RWORK2       NUMBER OF BYTES IN LAST SEGMENT
         BNP   EDHEX06             IF NONE
         LR    RWORK0,RWORK1       COPY # OF BYTES IN LAST SEGMENT
         SLL   RWORK0,K1           OUTPUT SIZE CORRESPONDING TO SGMNT
*
*
*        CONVERT THE LAST SEGMENT OF THE GROUP.
EDHEX05  DS    0H                  TIME VALUE CONVERSION IS COMPLETE
         BCTR  RWORK2,0            DECREMENT LENGTH FOR MVC
         EX    RWORK2,EDHEXMV3     COPY INPUT STRING TO PACK3
         UNPK  PACK1+0*K8(1*K8+1),PACK3+0*K4(K4+1)   UNPACK BYTES
         UNPK  PACK1+1*K8(1*K8+1),PACK3+1*K4(K4+1)   UNPACK BYTES
         TR    PACK1(1*K8),TRBHEX-X'F0'  CONVERT BINARY HEX TO EBCDIC
         LR    RWORK2,RWORK0       LENGTH OF RESULT IN OUTPUT
         BCTR  RWORK2,0            DECREMENT LENGTH FOR MVC
         EX    RWORK2,EDHEXCY1     COPY RESULT TO OUTPUT
         AR    RWORK4,RWORK0             UPDATE OUTPUT AREA ADDR
         SR    RWORK5,RWORK0             DECREMENT REMAINING LENGTH
         AR    RWORK6,RWORK1             UPDATE CHARACTER STRING ADDR
         SR    RWORK7,RWORK1             DECREMENT REMAINING LENGTH
*
*
*        IF ADDITIONAL BYTES REMAIN TO PROCESS,
*        INSERT A BLANK AT THE END OF THE OUTPUT GROUP.
EDHEX06  DS    0H
         LTR   RWORK7,RWORK7       DO ANY INPUT BYTES REMAIN??
         BNP   EDHEX09             IF INPUT EXHAUSTED
         C     RWORK5,F3           ANY ROOM LEFT IN OUTPUT AREA??
         BL    EDHEX09             IF OUTPUT AREA EXHAUSTED
         LA    RWORK0,K1           LENGTH OF BLANK
         MVI   00(RWORK4),EBLANK   INSERT BLANK SEPARATOR
         AR    RWORK4,RWORK0       UPDATE OUTPUT AREA POINTER
         SR    RWORK5,RWORK0       DECREMENT REMAINING LENGTH
         B     EDHEX01             LOOP FOR THE NEXT OUTPUT GROUP
*
*
*        RESTORE REGISTERS AND RETURN TO THE CALLER.
EDHEX09  DS    0H
         LR    RWORK1,RWORK4       COPY OUTPUT END+1 ADDRESS
         LM     RLINK,RENTRY,SAVEDHEX+0              RESTORE REGISTERS
         LM    RWORK2,RWORK7,SAVEDHEX+8+4*RWORK2     RESTORE REGISTERS
         SR    RWORK0,RWORK0       ZERO RWORK0
         SR    RWORK1,RWORK2       COMPUTE LENGTH & SET CC
         BR    RLINK                                 RETURN TO CALLER
*
*
*        THE FOLLOWING INSTRUCTIONS ARE "EXECUTED".
EDHEXMV3 MVC   PACK3(*-*),00(RWORK6)       COPY INPUT STRING
EDHEXCY1 MVC   00(*-*,RWORK4),PACK1        COPY RESULT TO OUTPUT
         EJECT  ,
*****************************************************************
*                                                               *
*                   E D I T T I M B                             *
*                                                               *
*        SUBROUTINE TO CONVERT A TIME VALUE                     *
*        IN BINARY 1/100 SECONDS TO AN EBCDIC VALUE             *
*        AND COPY THE EDITED RESULT TO THE CALLER'S             *
*        ANSWER AREA.                                           *
*                                                               *
*        INPUT REGISTERS ARE:                                   *
*              RLINK     RETURN ADDRESS TO THE CALLER;          *
*              RENTRY    TIME VALUE IN BINARY 1/100 SECONDS     *
*                        AS RETURNED FROM THE "TIME" MACRO.     *
*              RWORK0    NOT USED.                              *
*              RWORK1    NOT USED.                              *
*              RWORK2    ADDRESS OF AN 11 BYTE OUTPUT AREA TO   *
*                        WHICH THE EDITED RESULT WILL BE        *
*                        COPIED, OR ZERO.  THE EDITED RESULT    *
*                        HAS THE FORM "HH:MM:SS.TH".            *
*              RWORK3    LENGTH OF THE OUTPUT AREA IF RWORK2    *
*                        IS NOT ZERO.                           *
*                                                               *
*        OUTPUT REGISTERS ARE:                                  *
*              RLINK     RETURN ADDRESS TO THE CALLER;          *
*              RENTRY    UNCHANGED - SAME AS ON INPUT           *
*                                                               *
*              RWORK0    ZERO IF THE OUTPUT AREA ADDRESS WAS    *
*                        PROVIDED(RWORK2 ^= 0), OTHERWISE       *
*                        THE ADDRESS OF THE EDITED RESULT       *
*                        IN EDIT ROUTINE COMMON RESULT AREA     *
*                        "EDTRSLT".                             *
*                                                               *
*              RWORK1    LENGTH OF THE FIELD ACTUALLY COPIED    *
*                        IF THE OUTPUT AREA ADDRESS WAS         *
*                        PROVIDED(RWORK2 ^= 0), OTHERWISE       *
*                        THE LENGTH OF THE EDITED RESULT        *
*                        IN EDIT ROUTINE COMMON RESULT AREA     *
*                        "EDTRSLT".                             *
*                                                               *
*              RWORK2    UNCHANGED - SAME AS ON INPUT           *
*              RWORK3    UNCHANGED - SAME AS ON INPUT           *
*                                                               *
*                                                               *
*****************************************************************
*
*
EDITTIMB DS    0H                  GET EBCDIC TIME INTERVAL
         STM   RLINK,RWORK5,SAVEDTMB        SAVE CALLER'S REGISTERS
*
*
*        VALIDATE THE TIME VALUE AND PREPARE FOR PROCESSING
EDTMB00  DS    0H                  BEGIN ACTUAL CONVERSION TO EBCDIC
         LR    RWORK0,RENTRY       COPY TIME VALUE
         SRDL  RWORK0,K32          CLEAR RWORK0 & PREPARE FOR DIVIDE
         CL    RWORK1,EDTMBMAX     IS THE MAXIMUM TIME VALUE EXCEEDED?
         BNH   EDTMB01             BRANCH IF NOT TO CONVERT VALUE
         L     RWORK1,EDTMBMAX     SUBSTITUTE THE MAXIMUM TIME VALUE
*
*
*        DIVIDE UP THE VALUE TO GET:
*              "HH" IN -RWORK1-
*              "MM" IN -RWORK2-
*              "SS" IN -RWORK3-
*              "TH" IN -RWORK4-
EDTMB01  DS    0H                  BEGIN ACTUAL CONVERSION TO EBCDIC
*
*        EXTRACT AND SAVE "TH"
         LA    RENTRY,K100         DIVISOR TO EXTRACT "TH"
         DR    RWORK0,RENTRY       GET "TH"  IN RWORK0,                X
                                   SECONDS   IN RWORK1
         LR    RWORK4,RWORK0       SAVE "TH" IN RWORK4
*
*        EXTRACT AND SAVE "SS"
         LA    RENTRY,K60          DIVISOR TO EXTRACT "SS","MM","HH"
         SR    RWORK0,RWORK0       CLEAR RWORK0 FOR DIVIDE
         DR    RWORK0,RENTRY       GET "SS"  IN RWORK0,                X
                                   MINUTES   IN RWORK1
         LR    RWORK3,RWORK0       SAVE "SS" IN RWORK3
*
*        EXTRACT AND SAVE "MM" AND "HH
         SR    RWORK0,RWORK0       CLEAR RWORK0 FOR DIVIDE
         DR    RWORK0,RENTRY       GET "MM"  IN RWORK0,                X
                                       "HH"  IN RWORK1
         LR    RWORK2,RWORK0       SAVE "MM" IN RWORK2
*
*
*        RECOMBINE THE TIME VALUES IN SUCH A WAY THAT THE RESULT,
*        WHEN CONVERTED, YIELDS "0HHMMSSTHS" IN PACKED DECIMAL.
EDTMB02  DS    0H                  BEGIN ACTUAL CONVERSION TO EBCDIC
         LA    RENTRY,K100         LOAD MULTIPLIER
         MR    RWORK0,RENTRY    (((100*HH
         AR    RWORK1,RWORK2       + MM)
         MR    RWORK0,RENTRY       *100
         AR    RWORK1,RWORK3       + SS)
         MR    RWORK0,RENTRY       *100
         AR    RWORK1,RWORK4       + TH)
*
*
*        CONVERT THE RESULT TO PACKED DECIMAL, AND EDIT IT.
EDTMB03  DS    0H                  BEGIN ACTUAL CONVERSION TO EBCDIC
         CVD   RWORK1,PACKAREA     CONVERT THE RESULT TO DECIMAL:      X
                                     00 00 00 0H HM MS ST HZ
         MVC   EDTRSLT(L'EDTMBMSK),EDTMBMSK     COPY EDIT MASK
         ED    EDTRSLT(L'EDTMBMSK),PACKAREA+K3  EDIT TIME VALUE:       X
                                                F0HH.MM.SS.TH
*
*
*        COPY THE EDITED VALUE TO THE CALLER'S OUTPUT AREA.
EDTMB04  DS    0H                  COPY RESULT TO ANSWER AREA
         LA    RWORK0,EDTRSLT+K2   ADDRESS OF RESULT IN WORK AREA
         LA    RWORK1,L'EDTMBMSK-K2       MAX LENGTH OF RESULT
         LM    RWORK2,RWORK3,SAVEDTMB+8+4*RWORK2  OUTPUT AREA ->S
         LTR   RWORK4,RWORK2       COPY OUTPUT AREA START ADDRESS
         BZ    EDTMB05             RETURN ADDR & LN IF NO OUTPUT AREA
         CR    RWORK1,RWORK3       COMPARE TO LENGTH OF AREA
         BNH   *+L'*+2             BRANCH IF RESULT NOT LARGER,
         LR    RWORK1,RWORK3       OTHERWISE USE SMALLER LENGTH
         LR    RWORK3,RWORK1       SET TARGET LENGTH FOR COPY
         MVCL  RWORK2,RWORK0       COPY RESULT TO ANSWER AREA
         SR    RWORK0,RWORK0       SET REGISTER TO ZERO
         LR    RWORK1,RWORK2               COMPUTE LENGTH
         SR    RWORK1,RWORK4               ACTUALLY COPIED
*
*
*        RESTORE REGISTERS AND RETURN TO THE CALLER.
EDTMB05  DS    0H                  TIME VALUE CONVERSION IS COMPLETE
         LM     RLINK,RENTRY,SAVEDTMB+0              RESTORE REGISTERS
         LM    RWORK2,RWORK5,SAVEDTMB+8+4*RWORK2     RESTORE REGISTERS
         BR    RLINK                                 RETURN TO CALLER
*
*
*        CONSTANTS USED BY THE "EDITTIMB" ROUTINE.
EDTMBMAX DC    A(99*60*60*100+59*60*100+59*100+99)   MAXIMUM TIME
EDTMBMSK DC    X'F02120207A20207A20204B2020' EDIT MASK FOR HH:MM:SS.TH
         EJECT  ,
*****************************************************************
*                                                               *
*                   E D I T Y D D D                             *
*                                                               *
*        SUBROUTINE TO EDIT A PACKED DECIMAL DATE VALUE         *
*        IN THE FORM RETURNED FROM THE "TIME" MACRO,            *
*        AND COPY THE EDITED RESULT TO THE CALLER'S             *
*        ANSWER AREA.                                           *
*                                                               *
*        INPUT REGISTERS ARE:                                   *
*              RLINK     RETURN ADDRESS TO THE CALLER;          *
*              RENTRY    DATE VALUE IN PACKED DECIMAL           *
*                        AS RETURNED FROM THE "TIME" MACRO      *
*                        IN THE FORM "00YYDDDC".                *
*              RWORK0    NOT USED.                              *
*              RWORK1    NOT USED.                              *
*              RWORK2    ADDRESS OF AN 08 BYTE OUTPUT AREA TO   *
*                        WHICH THE EDITED RESULT WILL BE        *
*                        COPIED, OR ZERO.  THE EDITED RESULT    *
*                        HAS THE FORM "YYYY.DDD".               *
*              RWORK3    LENGTH OF THE OUTPUT AREA IF RWORK2    *
*                        IS NOT ZERO.                           *
*                                                               *
*        OUTPUT REGISTERS ARE:                                  *
*              RLINK     RETURN ADDRESS TO THE CALLER;          *
*              RENTRY    UNCHANGED - SAME AS ON INPUT           *
*                                                               *
*              RWORK0    ZERO IF THE OUTPUT AREA ADDRESS WAS    *
*                        PROVIDED(RWORK2 ^= 0), OTHERWISE       *
*                        THE ADDRESS OF THE EDITED RESULT       *
*                        IN EDIT ROUTINE COMMON RESULT AREA     *
*                        "EDTRSLT".                             *
*                                                               *
*              RWORK1    LENGTH OF THE FIELD ACTUALLY COPIED    *
*                        IF THE OUTPUT AREA ADDRESS WAS         *
*                        PROVIDED(RWORK2 ^= 0), OTHERWISE       *
*                        THE LENGTH OF THE EDITED RESULT        *
*                        IN EDIT ROUTINE COMMON RESULT AREA     *
*                        "EDTRSLT".                             *
*                                                               *
*              RWORK2    UNCHANGED - SAME AS ON INPUT           *
*              RWORK3    UNCHANGED - SAME AS ON INPUT           *
*                                                               *
*                                                               *
*****************************************************************
*
*
EDITYDDD DS    0H                  GET EBCDIC DATE VALUE
         STM   RLINK,RWORK5,SAVEDYDD        SAVE CALLER'S REGISTERS
*
*
*        STORE THE DATE VALUE IN THE WORK AREA, AND EDIT IT.
EDYDD01  DS    0H                  BEGIN ACTUAL CONVERSION TO EBCDIC
         ST    RENTRY,PACKAREA     STORE DATE VALUE
         MVC   EDTRSLT(L'EDYDDMSK),EDYDDMSK     COPY EDIT MASK
         LA    RWORK1,EDTRSLT+L'EDYDDMSK-K6     SET REGISTER FOR EDMK
         EDMK  EDTRSLT(L'EDYDDMSK),PACKAREA     EDIT DATE VALUE:       X
                                                F0YYYY.DDD
*
*
*        COPY THE EDITED VALUE TO THE CALLER'S OUTPUT AREA.
EDYDD02  DS    0H                  COPY RESULT TO ANSWER AREA
         LR    RWORK0,RWORK1       ADDRESS OF RESULT IN WORK AREA      X
                                   FROM EDMK
         LA    RWORK1,EDTRSLT+L'EDYDDMSK   RIGHTMOST+1 DIGIT OF RESULT
         SR    RWORK1,RWORK0       COMPUTE LENGTH OF RESULT
         LM    RWORK2,RWORK3,SAVEDYDD+8+4*RWORK2  OUTPUT AREA ->S
         LTR   RWORK4,RWORK2       COPY OUTPUT AREA START ADDRESS
         BZ    EDYDD03             RETURN ADDR & LN IF NO OUTPUT AREA
         CR    RWORK1,RWORK3       COMPARE TO LENGTH OF AREA
         BNH   *+L'*+2             BRANCH IF RESULT NOT LARGER,
         LR    RWORK1,RWORK3       OTHERWISE USE SMALLER LENGTH
         LR    RWORK3,RWORK1       SET TARGET LENGTH FOR COPY
         MVCL  RWORK2,RWORK0       COPY RESULT TO ANSWER AREA
         SR    RWORK0,RWORK0       SET REGISTER TO ZERO
         LR    RWORK1,RWORK2               COMPUTE LENGTH
         SR    RWORK1,RWORK4               ACTUALLY COPIED
*
*
*        RESTORE REGISTERS AND RETURN TO THE CALLER.
EDYDD03  DS    0H                  TIME VALUE CONVERSION IS COMPLETE
         LM     RLINK,RENTRY,SAVEDYDD+0              RESTORE REGISTERS
         LM    RWORK2,RWORK5,SAVEDYDD+8+4*RWORK2     RESTORE REGISTERS
         BR    RLINK                                 RETURN TO CALLER
*
*
*        CONSTANTS USED BY THE "EDITYDDD" ROUTINE.
EDYDDMSK DC    X'F0202120204B202020'         EDIT MASK FOR YYYY.DDD
         TITLE '$ORTPARM - MESSAGE AND COMMAND SKELETONS'
MSG001   WTO  '&&MID.01 MODULE=? ENTERED, VER=?, ASMDATE=?, ASMTIME=?, X
               EP=X''?'', SIZE=X''?'' BYTES',                          X
               DESC=(6),ROUTCDE=(11),                                  X
               MF=L
MSG001Z  EQU   *-MSG001            SIZE OF MESSAGE SKELETON
         EJECT ,
MSG011   WTO  '&&MID.11 XEQ VALUES: SID=&&SID, JCLASS=&&C, JNAME=&&J, SX
               NAME=&&S, PSNAME=&&P',                                  X
               DESC=(6),ROUTCDE=(11),                                  X
               MF=L
MSG011Z  EQU   *-MSG011            SIZE OF MESSAGE SKELETON
         SPACE 4
MSG012   WTO  '&&MID.12 XEQ VALUES: PGM=?, PERFORM(NPG)=?',            X
               DESC=(6),ROUTCDE=(11),                                  X
               MF=L
MSG012Z  EQU   *-MSG012            SIZE OF MESSAGE SKELETON
         SPACE 4
MSG013   WTO  '&&MID.13 XEQ VALUES: DATE=?(?), TIME=?, DOW=?',         X
               DESC=(6),ROUTCDE=(11),                                  X
               MF=L
MSG013Z  EQU   *-MSG013            SIZE OF MESSAGE SKELETON
         EJECT ,
MSG020   WTO  '&&MID.20 MODULE=? LOADED, EP=X''?'', SIZE=X''?'' BYTES, X
               AC=?, AMODE=?',                                         X
               DESC=(6),ROUTCDE=(11),                                  X
               MF=L
MSG020Z  EQU   *-MSG020            SIZE OF MESSAGE SKELETON
         SPACE 4
MSG021   WTO  '&&MID.21 LOAD FAILED FOR MODULE=?, ABEND CODE=?, REASON X
               CODE=?',                                                X
               DESC=(6),ROUTCDE=(11),                                  X
               MF=L
MSG021Z  EQU   *-MSG021            SIZE OF MESSAGE SKELETON
         EJECT  ,
MSG022   WTO  '&&MID.22 TABLE ENTRY # ??? EVALUATION STARTED',         X
               DESC=(6),ROUTCDE=(11),                                  X
               MF=L
MSG022Z  EQU   *-MSG022            SIZE OF MESSAGE SKELETON
MSG023   WTO  '&&MID.23 TABLE ENTRY # ??? MATCHED ON ?',               X
               DESC=(6),ROUTCDE=(11),                                  X
               MF=L
MSG023Z  EQU   *-MSG023            SIZE OF MESSAGE SKELETON
         SPACE 2
         PRINT NOGEN               DON'T EXPAND #VSTR
MSG023SI #VSTR 'SID'               MATCHING CONDITION
MSG023JN #VSTR 'JNAME'             MATCHING CONDITION
MSG023SN #VSTR 'SNAME'             MATCHING CONDITION
MSG023PN #VSTR 'PSNAME'            MATCHING CONDITION
MSG023PG #VSTR 'PGM'               MATCHING CONDITION
MSG023P# #VSTR 'PERFORM'           MATCHING CONDITION
MSG023OJ #VSTR 'OJOB'              MATCHING CONDITION
MSG023DW #VSTR 'DOW'               MATCHING CONDITION
MSG023TM #VSTR 'TIME'              MATCHING CONDITION
MSG023DT #VSTR 'DATE'              MATCHING CONDITION
         PRINT GEN                 DON'T EXPAND #VSTR
         SPACE 3
MSG024   WTO  '&&MID.24 TABLE ENTRY # ??? REJECTED ON ?',              X
               DESC=(6),ROUTCDE=(11),                                  X
               MF=L
MSG024Z  EQU   *-MSG024            SIZE OF MESSAGE SKELETON
         EJECT ,
MSG025   WTO  '&&MID.25 TABLE ENTRY # ??? VALUES USED:',               X
               DESC=(6),ROUTCDE=(11),                                  X
               MF=L
MSG025Z  EQU   *-MSG025            SIZE OF MESSAGE SKELETON
         SPACE 4
MSG027   WTO  '&&MID.27 TABLE EVALUATION RESULTS: ML=??, $P=??, MD=??',X
               DESC=(6),ROUTCDE=(11),                                  X
               MF=L
MSG027Z  EQU   *-MSG027            SIZE OF MESSAGE SKELETON
         SPACE 4
MSG028   WTO  '&&MID.28 TABLE EVALUATION RESULTS: PARM=''?''',         X
               DESC=(6),ROUTCDE=(11),                                  X
               MF=L
MSG028Z  EQU   *-MSG028            SIZE OF MESSAGE SKELETON
         EJECT  ,
MSG029   WTO  '&&MID.29 MODULE=? DELETED',                             X
               DESC=(6),ROUTCDE=(11),                                  X
               MF=L
MSG029Z  EQU   *-MSG029            SIZE OF MESSAGE SKELETON
         EJECT ,
MSG031   WTO  '&&MID.31 UNAUTHORIZED USE OF ???????? DD STATEMENT DETECX
               TED BY $ORTPARM EXIT ROUTINE',                          X
               DESC=(6),ROUTCDE=(11),                                  X
               MF=L
MSG031Z  EQU   *-MSG031            SIZE OF MESSAGE SKELETON
         SPACE 5
MSG032   WTO  '&&MID.32 DDNAME=???????? AT TIOT OFFSET X''????'' DYNAMIX
               CALLY UNALLOCATED, TIME=?',                             X
               DESC=(6),ROUTCDE=(11),                                  X
               MF=L
MSG032Z  EQU   *-MSG032            SIZE OF MESSAGE SKELETON
         EJECT ,
MSG038   WTO  '&&MID.38 DDNAME=???????? DYNAMIC ?????????? FAILURE, RC=X
               ??, ERROR CODE=????, INFO CODE=????',                   X
               DESC=(6),ROUTCDE=(11),                                  X
               MF=L
MSG038Z  EQU   *-MSG038            SIZE OF MESSAGE SKELETON
         SPACE 5
*
*        POINT TO THE DYNAMIC ALLOCATION VERB CODE DESCRIPTOR:
MSG038IP DS   0A                   START OF ->S TO DESCRIPTORS
         DC    A(MSG03800)    00   S99VERB  = 00
         DC    A(MSG038AL)    01   S99VRBAL = ALLOCATION
         DC    A(MSG038UN)    02   S99VRBUN = UNALLOCATION
         DC    A(MSG038CC)    03   S99VRBCC = CONCATENATION
         DC    A(MSG038DC)    04   S99VRBDC = DECONCATENATION
         DC    A(MSG038RI)    05   S99VRBRI = REMOVE IN-USE
         DC    A(MSG038DN)    06   S99VRBDN = DDNAME ALLOCATION
         DC    A(MSG038IN)    07   S99VRBIN = INFORMATION RETRIEVAL
*
*        DEFINE THE DYNAMIC ALLOCATION VERB CODE DESCRIPTOR:
         PRINT NOGEN
MSG03800 #FSTR 'S99VERB = 00'               S99VERB = 00
MSG038AL #FSTR 'ALLOCATION'                 S99VRBAL
MSG038UN #FSTR 'UNALLOCATION'               S99VRBUN
MSG038CC #FSTR 'CONCATENATION'              S99VRBCC
MSG038DC #FSTR 'DECONCATENATION'            S99VRBDC
MSG038RI #FSTR 'REMOVE IN-USE'              S99VRBRI
MSG038DN #FSTR 'DDNAME ALLOCATION'          S99VRBDN
MSG038IN #FSTR 'INFORMATION RETRIEVAL'      S99VRBDN
         PRINT GEN
         EJECT ,
MSG051   WTO  '&&MID.51 DATECALC VALUES: DOW=??, MM=??, DD=??, DDD=???,X
                YYYY=????, FACTOR=????????',                           X
               DESC=(6),ROUTCDE=(11),                                  X
               MF=L
MSG051Z  EQU   *-MSG051            SIZE OF MESSAGE SKELETON
         SPACE 10
MSG099   WTO  '&&MID.99 FINAL VALUES: RC=??, PARM=''?''; TIME=?',      X
               DESC=(6),ROUTCDE=(11),                                  X
               MF=L
MSG099Z  EQU   *-MSG099            SIZE OF MESSAGE SKELETON
         TITLE '$ORTPARM - MACRO LIST FORM SKELETONS'
ESTALS1  ESTAE *-*,                                                    X
               CT,                                                     X
               PURGE=QUIESCE,                                          X
               XCTL=NO,                                                X
               MF=L
ESTALS1Z EQU   *-ESTALS1           SIZE OF THE ESTAE MACRO LIST FORM
         SPACE 5
EXTRLS1  EXTRACT 0,                                                    X
               FIELDS=(TIOT),                                          X
               MF=L
EXTRLS1Z EQU   *-EXTRLS1           SIZE OF THE EXTRACT MACRO LIST FORM
         TITLE '$ORTPARM - MODULE  CONSTANTS, TABLES, AND LITERALS'
         DS    0D                  BOUNDARY ALIGN
EBLANKS  DC    CL128' '            EBCDIC BLANKS
EZEROS   DC   0CL032'0',032C'0'    EBCDIC ZEROS
EASTRSKS DC   0CL016'*',016C'*'    EBCDIC ASTERISKS
EEQUALS  DC   0CL016'=',016C'='    EBCDIC EQUALS SIGNS
BZEROS   DC    XL032'00'           BINARY ZEROS
XZEROS   EQU   BZEROS,,C'X'        HEXADECIMAL ZEROS
PZERO    DC    PL4'0'              PACKED DECIMAL ZERO
MINUS1   DC   8F'-1'               UBIQUITOUS CONSTANT: -1
WORKSIZE DC    A(LENAREA)          WORK AREA SIZE FOR GETMAIN
         PRINT NOGEN
DFLTMSDD #VSTR 'SORTMSG',MAXLN=08  SYNCSORT MSG  DATASET DEFAULT DDN
DFLTPRDD #VSTR '$ORTPARM',MAXLN=08 SYNCSORT PARM DATASET DEFAULT DDN
DFLTMLDD #VSTR '$ORTML##',MAXLN=08 SYNCSORT $ORTPARM MLV DEFAULT DDN
MSGIDHDR #VSTR '$ORTPARM'          MESSAGE ID HEADER
DATANAME #FSTR '$ORTDATA'          LOAD MODULE NAME
         PRINT GEN
F1       DC    F'1'                ARITHMETIC CONSTANT
H1       EQU   F1+2,2              ARITHMETIC CONSTANT
F2       DC    F'2'                ARITHMETIC CONSTANT
H2       EQU   F2+2,2              ARITHMETIC CONSTANT
F3       DC    F'3'                ARITHMETIC CONSTANT
H3       EQU   F3+2,2              ARITHMETIC CONSTANT
F4       DC    F'4'                ARITHMETIC CONSTANT
H4       EQU   F4+2,2              ARITHMETIC CONSTANT
F5       DC    F'5'                ARITHMETIC CONSTANT
H5       EQU   F5+2,2              ARITHMETIC CONSTANT
F6       DC    F'6'                ARITHMETIC CONSTANT
F7       DC    F'7'                ARITHMETIC CONSTANT
F8       DC    F'8'                ARITHMETIC CONSTANT
F9       DC    F'9'                ARITHMETIC CONSTANT
F10      DC    F'10'               ARITHMETIC CONSTANT
H10      EQU   F10+2,2             ARITHMETIC CONSTANT
F100     DC    F'100'              ARITHMETIC CONSTANT
F306     DC    F'306'              ARITHMETIC CONSTANT
NMSK1000 DC    X'FF000000'         "N" INSTRUCTION MASK FOR CLEARING RG
NMSK7FFF DC    X'7FFFFFFF'         "N" INSTRUCTION MASK FOR CLEARING RG
NMSK0FFF DC    X'00FFFFFF'         "N" INSTRUCTION MASK FOR CLEARING RG
NMSK007F DC    X'00007FFF'         "N" INSTRUCTION MASK FOR CLEARING RG
NMSK0011 DC    X'0000FFFF'         "N" INSTRUCTION MASK FOR CLEARING RG
NMSK0001 DC    X'000000FF'         "N" INSTRUCTION MASK FOR CLEARING RG
OMSK8000 DC    X'80000000'         "O" INSTRUCTION MASK FOR FLAGGING RG
         PRINT NOGEN
FMID    #FSTR  'MID'               FL STRING "MID"
FSID    #FSTR  'SID'               FL STRING "SID"
FMLEQ   #FSTR  'ML='               FL STRING "ML="
F$PEQ   #FSTR  '$P='               FL STRING "$P="
FMDEQ   #FSTR  'MD='               FL STRING "MD="
FPRMEQQ #FSTR  'PARM='''           FL STRING "PARM='"
FPRMUEQQ #FSTR 'PARMUPD='''        FL STRING "PARMUPD='"
FCMBL   #FSTR  ', '                FL STRING ", "
FC      #FSTR  'C'                 FL STRING "C"
FJ      #FSTR  'J'                 FL STRING "J"
FS      #FSTR  'S'                 FL STRING "S"
FP      #FSTR  'P'                 FL STRING "P"
FQUOTE  #FSTR  ''''                FL STRING "'"
FBLANK  #FSTR  ' '                 FL STRING BLANK
VBLANK  #VSTR  ' '                 VL STRING BLANK
VCOMMA  #VSTR  ','                 VL STRING COMMA
VEQUAL  #VSTR  '='                 VL STRING "="
VQUERY  #VSTR  '?'                 VL STRING "?"
VMSGDD  #VSTR  'MSGDD='            VL STRING "MSGDD="
VMSGDLM1 #VSTR ' &&.?/,()=''"'     VL MESSAGE TEXT DELIMITERS
         PRINT GEN
EOUTLINE DC   0CL100' '            CHARS TO OUTLINE STRING DISPLAYS
         DC    C'....+...10....+...20....+...30....+...40....+...50'
         DC    C'....+...60....+...70....+...80....+...90....+..100'
         SPACE 3
DOWTABLE DS   0CL3                 TABLE OF WEEKDAY NAMES
         DC    CL3'SUN'                   0
         DC    CL3'MON'                   1
         DC    CL3'TUE'                   2
         DC    CL3'WED'                   3
         DC    CL3'THU'                   4
         DC    CL3'FRI'                   5
         DC    CL3'SAT'                   6
         SPACE 3
MONTABLE DS   0CL3                 TABLE OF MONTH NAMES
         DC    CL3'JAN'                  01
         DC    CL3'FEB'                  02
         DC    CL3'MAR'                  03
         DC    CL3'APR'                  04
         DC    CL3'MAY'                  05
         DC    CL3'JUN'                  06
         DC    CL3'JUL'                  07
         DC    CL3'AUG'                  08
         DC    CL3'SEP'                  09
         DC    CL3'OCT'                  10
         DC    CL3'NOV'                  11
         DC    CL3'DEC'                  12
         SPACE 3
         LTORG  *                  MODULE LITERAL POOL
         TITLE '$ORTPARM - MODULE  PATCH AREA'
        #PATCH  256                128 BYTE PATCH AREA
         TITLE '$ORTPARM - TRANSLATE TABLES'
*--------------------------------------------------------------
*-                                                            -
*-       TRANSLATE TABLE USED FOR CONVERTING EBCDIC           -
*-       HEXADECIMAL CHARACTER STRINGS TO THEIR EQUIVALENT    -
*-       BINARY INDEX VALUES.                                 -
*-                                                            -
TREHEX   DC   0XL256'00',256AL1(016)   TR EBCDIC HEXADECIMAL
         ORG   TREHEX+C'0'         UPPERCASE NUMERIC PORTION
         DC    AL1(00,01,02,03,04,05,06,07,08,09)
         ORG   TREHEX+C'A'         UPPERCASE "A" - "F"
         DC    AL1(10,11,12,13,14,15)
         ORG   TREHEX+L'TREHEX     END OF NUMERIC STRING SCAN TABLE
         SPACE 5
*--------------------------------------------------------------
*-                                                            
*-       TRANSLATE TABLE USED FOR CONVERTING UNPACKED BINARY  
*-       HEXADECIMAL CHARACTER STRINGS TO THEIR EQUIVALENT    
*-       EBCDIC HEXADECIMAL CHARACTER REPRESENTATION VALUES.  
*-                                                            
TRBHEX   DC    CL16'0123456789ABCDEF'  TR EBCDIC HEXADECIMAL
         DC    C'0'
         SPACE 5
*--------------------------------------------------------------
*-                                                            
*-       TRANSLATE TABLE USED FOR DEVELOPING A BASE 4 SET OF  
*-       PACKED DIGITS IN THE PROCESS OF CONVERTING           
*-       CHARACTER STRINGS TO THEIR EBCDIC BIT STRING         
*-       REPRESENTATIONS.                                     
*-                                                            
TRQBIT4  DC    XL16'00010203101112132021222330313233'
         SPACE 5
*--------------------------------------------------------------
*-                                                            
*-       TRANSLATE TABLE USED FOR DEVELOPING A BASE 2 SET OF  
*-       PACKED DIGITS IN THE PROCESS OF CONVERTING           
*-       CHARACTER STRINGS TO THEIR EBCDIC BIT STRING         
*-       REPRESENTATIONS.                                     
*-                                                            
TRQBIT2  DC    XL04'00011011'
         EJECT  ,
*--------------------------------------------------------------
*-                                                            
*-       TRANSLATE TABLE FOR TRANSFORMING EACH CHARACTER OF A 
*-       CHARACTER STRING TO A BIT MASK DESCRIBING            
*-       THE CHARACTER TYPE.  BIT SETTINGS ARE:               
*-             X'80'      CHARACTER IS INVALID                
*-             X'40'      CHARACTER IS UPPER CASE             
*-             X'08'      SPECIAL CHARACTER                   
*-             X'04'      NATIONAL CHARACTER                  
*-             X'02'      ALPHABETIC CHARACTER                
*-             X'01'      NUMERIC CHARACTER                   
TRCHRTYP DC   0XL256'00',256X'80'  INITIALIZE TABLE
         ORG   TRCHRTYP+C' '       BLANK
         DC    X'40'                               " "
         ORG   TRCHRTYP+C'.'       SPECIAL
         DC    X'48'                               "."
         ORG   TRCHRTYP+C'-'       SPECIAL
         DC    X'48'                               "-"
         ORG   TRCHRTYP+C'='       SPECIAL
         DC    X'48'                               "="
         ORG   TRCHRTYP+C'#'       NATIONAL
         DC    X'44'                               "#"
         ORG   TRCHRTYP+C'$'       NATIONAL
         DC    X'44'                               "$"
         ORG   TRCHRTYP+C'@'       NATIONAL
         DC    X'44'                               "@"
         ORG   TRCHRTYP+C'A'-X'40' LOWERCASE
         DC   9X'02'                               "A" - "I"
         ORG   TRCHRTYP+C'J'-X'40' LOWERCASE
         DC   9X'02'                               "J" - "R"
         ORG   TRCHRTYP+C'S'-X'40' LOWERCASE
         DC   8X'02'                               "S" - "Z"
         ORG   TRCHRTYP+C'0'-X'40' LOWERCASE
         DC  10X'01'                               "0" - "9"
         ORG   TRCHRTYP+C'A'       UPPERCASE
         DC   9X'42'                               "A" - "I"
         ORG   TRCHRTYP+C'J'       UPPERCASE
         DC   9X'42'                               "J" - "R"
         ORG   TRCHRTYP+C'S'       UPPERCASE
         DC   8X'42'                               "S" - "Z"
         ORG   TRCHRTYP+C'0'       UPPERCASE
         DC  10X'41'                               "0" - "9"
         ORG   TRCHRTYP+L'TRCHRTYP TO END OF TABLE
         TITLE '$ORTPARM - PARM STRING CONSTRUCTION AREA FOR SYNCSORT'
PARMPTRA DC    A(PARMPTR)              ADDR OF -> PARM STRING
PARMPTR  DC    A(PARMSTR+X'80000000')  -> PARM STRING
PARMSTR  #VSTR MAXLN=100               PARM STRING
         SPACE 10
$ORTEND  DS   0C                   MARK THE END OF $ORTPARM
         END   $ORTPARM
