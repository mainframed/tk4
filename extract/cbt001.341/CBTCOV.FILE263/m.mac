.he ABE, T. Smith, Appendix M

Appendix M - MISCELLANEOUS EXAMPLES.                                   @









                       A B E  E d i t o r


                         T .  S m i t h

                       A P P E N D I X  M

          M I S C E L L A N E O U S    E X A M P L E S









This appendix gives examples of various ways ABE has been used to
quickly satisfy some text manipulation need.  The objective is to
provide food for thought on how your particular need might be
accomplished.

CALENDAR                                                               @

Following is a list of member CALENDAR in my SYSRUN library:

  $* p1=month, e.g. jan, p2=year, e.g. 87
  xlate p1
  setl names JANFEBMARAPRMAYJUNJULAUGSEPOCTNOVDEC
  calc start#10000*&P2+100*(fixed(index(names,p1)/3)+1)+1
  calc days#mod(monthend(start),100)
  calc take#dow(start)-1
  calc rows#ceil((take+days)/7)
  setl hdr ' Sun Mon Tue Wed Thu Fri Sat'
  APL F(28Y' &P1 &P2'),{1}'&HDR',{1}4 0F&ROWS 7R(&TAKE.Y0),(I&DAYS),7Y0

If, while in ABE, I issue the command -

  %%calendar jan 88

the result will be a dataset containing the following:

                 1         2         3         4         5         6
        12345678901234567890123456789012345678901234567890123456789012

  PB                                                      ×T69××8X28.1
  ====>          Ö Ö Ö Ö Ö Ö Ö Ö Ö Ö Ö Ö Ö
  00001 JAN 88
  00002 Sun Mon Tue Wed Thu Fri Sat
  00003   0   0   0   0   0   1   2
  00004   3   4   5   6   7   8   9
  00005  10  11  12  13  14  15  16
  00006  17  18  19  20  21  22  23
  00007  24  25  26  27  28  29  30
  00008  31   0   0   0   0   0   0


FORTRAN INCLUDE STATEMENT                                              @

In this case, I needed to compile several fortran programs written
for the VSFORTRAN compiler under the FORTRAN IV Compiler (H-extended).
the programs contained INCLUDE statements, which are not supported
by the H-extended compiler.  To solve the problem, I set up the
following JCL procedure to be run just prior to the FORTRAN compile
step:

 INCLUDE JCL PROCEDURE

   //INCLUDE EXEC PGM=IKJEFT01,DYNAMNBR=30,REGION=4000K
   //****************************************************************
   //*
   //* WRITTEN BY T. SMITH.
   //*
   //* THIS PROCEDURE WAS WRITTEN TO SUPPORT THE VSFORTRAN INCLUDE
   //* STATEMENT WHEN USING FORTRAN H-EXTENDED.  TWO DD STATEMENTS
   //* MUST BE SUPPLIED TO THIS PROCEDURE:
   //*
   //* SYSLIB - SHOULD POINT TO A PARTITIONED DATA SET CONTAINING
   //*          MEMBERS REFERRED ON INCLUDE STATEMENTS IN THE
   //*          FORTRAN PROGRAM.
   //* SYSIN  - SHOULD POINT TO THE SEQUENTIAL DATA SET CONTAINING
   //*          THE FORTRAN SOURCE PROGRAM CONTAINING INCLUDE
   //*          STATEMENTS, WHICH ARE OF THE FORMAT -
   //*
   //*                INCLUDE (MEMBER)
   //*
   //*          WHERE THE WORD INCLUDE BEGINS IN COLUMN 7, AND
   //*          'MEMBER' INDICATES THE MEMBER FROM SYSLIB TO BE
   //*          INCLUDED.  NOTE THAT ALL MEMBERS TO BE INCLUDED MUST
   //*          HAVE SEQUENCE NUMBERS IN COLUMNS 73-80.
   //*
   //* OUTPUT FROM THIS PROCEDURE WILL BE TEMPORARY DATA SET NAMED
   //* &&SORC CONTAINING THE UPDATED FORTRAN SOURCE PROGRAM, WITH ALL
   //* INCLUDE STATEMENTS RESOLVED.
   //*
   //****************************************************************
   //SYSTSPRT DD  SYSOUT=*
   //SYSPRINT DD  SYSOUT=*
   //SYSRUN   DD  DSN=SYS2.CNTCARD,DISP=SHR
   //SORC     DD  DSN=&&SORC,DISP=(NEW,PASS),
   //             UNIT=DISK,SPACE=(TRK,(10,10)),
   //             DCB=(LRECL=80,BLKSIZE=800,RECFM=FB)
   //SYSTSIN  DD  DSN=SYS2.CNTCARD(U109200Y),DISP=SHR

DSN=SYS2.CNTCARD(U109200Y)

   ABE '' INFI(SYSIN) OUTFI(SORC) HARDCOPY NAME(SORC)
   RUN U109200Z
   SE

DSN=SYS2.CNTCARD(U109200Z)

   TOP
   $ NEXT
   N B F '      INCLUDE' 1
   $IF LASTCC=0
     * 1.1 SUBSTR C
     * SNO ANCHOR TRIM INDEX() '(' BREAK(')') $ A RTAB(0)
     R INCLUDE &A
     $GOTO NEXT

SAMPLE EXECUTION

   //S01      EXEC FINCLUDE
   //SYSLIB   DD  DSN=X75826.PLOT79.DRIVER.FORT,DISP=SHR
   //SYSIN    DD  DSN=X75826.PLOT79.DRIVER.FORT(DDIDL),DISP=SHR
   //S02      EXEC FORTXC,FXTERM='SYSOUT=*'
   //SYSPRINT DD  SYSOUT=*
   //SYSLIN   DD  DSN=X75826.PLOT79.DRIVER.OBJ(DDIDL),DISP=OLD
   //SYSIN    DD  DSN=&&SORC,DISP=(OLD,DELETE)


BUZZWORDS                                                              @

Anyone that works in a bureaucracy will inevitably be required to
produce meaningless reports.  These reports are very useful, because
they provide others with the job of shuffling them, and thereby
families don't starve.  So don't cavil, pitch in and help stamp out
malnutrition in this world.

If you feel frustrated when writing such reports, it's probably
because you are trying to make sense where nonsense is called for.
if you eliminate this neurotic compulsion, everybody, but especially
you, will be much happier.

To help you in this task, consider BUZZWORD, a list of ABE subcommands
which, when RUN, will produce meaningless but impressive three-word
phrases.  It does this by randomly selecting one word from each of
three lists of words and concatenating them.  Some examples are:

    Compatible Incremental Mobility
    Compatible Reciprocal Time-phase
    Balanced Transitional Programming
    Balanced Transitional Mobility

You run BUZZWORD by invoking ABE with file SYSRUN pointing to a
partitioned data set containing the member BUZZWORD (see list below).
Just enter %%BUZZWORD on the command line, and the three-word phrase
will show up in the message area.  To store the current phrase in the
currently edited data set, the subcommand "r nl &A" can be used.

Following is the list of subcommands contained in BUZZWORD:

    A XXX END N
    DEFINE XXX LO
    A XXX NL Integrated       Management       Options
    A XXX NL Total            Organizational   Flexibility
    A XXX NL Systematized     Monitored        Capability
    A XXX NL Parallel         Reciprocal       Mobility
    A XXX NL Functional       Digital          Programming
    A XXX NL Responsive       Logistical       Concept
    A XXX NL Optional         Transitional     Time-phase
    A XXX NL Synchronized     Incremental      Projection
    A XXX NL Compatible       Third-generation Hardware
    A XXX NL Balanced         Policy           Contingency
    apl xxx#10 3 17 1`Rxxx
    apl xxx#(,xxx{1?10;1;}),(,xxx{1?10;2;}),(,xxx{1?10;3;})
    A XXX C '  ' ' ' RESCAN
    A XXX SNOT
    A XXX END N
    SYMC A

ELIMINATE INIT CLAUSES IN PL/I STRUCTURE USING SNO                     @

Given the following structure, I would like to eliminate all the
INIT clauses:

   DCL 1 SAVE_STRUCTURE BASED(SAVEPTR),
     2 DSSIZE DEC FLOAT(6) INIT(27.94),
     2 HORZNT BIT(32) INIT('0'B),
     2 IMAGE BIT(32) INIT('0'B),
     2 LINEWT FIXED BIN(31,0) INIT(1),
     2 PLSTPX DEC FLOAT(6) INIT(.031750),
     2 PLSTPY DEC FLOAT(6) INIT(.035278),
     2 SX DEC FLOAT(6) INIT(799),
     2 SY DEC FLOAT(6) INIT(504),
     2 TIMAGE(4,4) DEC FLOAT(6),
     2 XMAX DEC FLOAT(6) INIT(1),
     2 YMAX DEC FLOAT(6) INIT(1),
     2 ZMAX DEC FLOAT(6) INIT(0),
     2 PLXDPI FIXED BIN(31,0) INIT(80),
     2 PLYDPI FIXED BIN(31,0) INIT(72),
     2 PLMAXX FIXED BIN(31,0) INIT(792),
     2 PLMAXY FIXED BIN(31,0) INIT(504),
     2 MAXBTX FIXED BIN(31,0) INIT(800),
     2 MAXBTY FIXED BIN(31,0) INIT(504),
     2 CURPEN CHAR(1) INIT('1'),
     2 PENARY(9) CHAR(1),
     2 BITMAP_ELSIZE FIXED BIN(15,0) INIT(8);

This can be done with the following SNO subcommand:

  SNO ' INIT(' INDEX() ')' (',' × ';') $ B = B

The results are as follows:

   DCL 1 SAVE_STRUCTURE BASED(SAVEPTR),
     2 DSSIZE DEC FLOAT(6),
     2 HORZNT BIT(32),
     2 IMAGE BIT(32),
     2 LINEWT FIXED BIN(31,0),
     2 PLSTPX DEC FLOAT(6),
     2 PLSTPY DEC FLOAT(6),
     2 SX DEC FLOAT(6),
     2 SY DEC FLOAT(6),
     2 TIMAGE(4,4) DEC FLOAT(6),
     2 XMAX DEC FLOAT(6),
     2 YMAX DEC FLOAT(6),
     2 ZMAX DEC FLOAT(6),
     2 PLXDPI FIXED BIN(31,0),
     2 PLYDPI FIXED BIN(31,0),
     2 PLMAXX FIXED BIN(31,0),
     2 PLMAXY FIXED BIN(31,0),
     2 MAXBTX FIXED BIN(31,0),
     2 MAXBTY FIXED BIN(31,0),
     2 CURPEN CHAR(1),
     2 PENARY(9) CHAR(1),
     2 BITMAP_ELSIZE FIXED BIN(15,0);


HOW MANY CHARACTERS IN A DATA SET?                                     @

I have a dataset, and I want to find out how many characters are in
the dataset, not counting trailing blanks on each line.  If I create
symbolic dataset named PFK06 containing the following statements, and
then press program function key 6, the answer will appear in the
message area:


     CALC TOT#0
     SNO STACK TRIM ANCHOR LEN(0) RPOS(0) = SEQ ' DEL'
     REN 1 1
     B MK 1
     GETMK 1 CNT
     $WHILE CNT>0
       CALC TOT#TOT+CNT
       SL 1
       SNO STACK TRIM ANCHOR LEN(0) RPOS(0) = SEQ ' DEL'
       REN 1 1
       B MK 1
       GETMK 1 CNT
     SYMC TOT

SNO  - A SIMPLE EXAMPLE                                                @

Line 32 in my SAS source program reads as follows:

 PLOT DATE*DOWNTIME='D' DATE*BADRESP='B' DATE*AVGATNS='A' / OVERLAY;

the following SNO subcommand -

 32 SNO RESCAN 'DATE*' INDEX() $ A '=' = A '*DATE='

changes lines 32 to appear as follows:

 PLOT DOWNTIME*DATE='D' BADRESP*DATE='B' AVGATNS*DATE='A' / OVERLAY;

thereby interchanging the values on the two coordinate axes.

SNO AND APL - A COMPLEX EXAMPLE                                        @

I have a FORTRAN program in which there are a series of declarations
as follows:

      INTEGER*2 CHARS(7208)
      INTEGER*2 CHAR1(116) / 116, -16, -9, 12, -11, 11, -11, -9, -9,
     *-7, -7, -6, -4, -6, -2, -7, -4, -9, -5, -8, -8, -8, -11, -9, -64,
      .
      ........(lines omitted for brevity)
      .
      INTEGER*2 CHAR2(200) / 200, -16, -9, 12, -12, 12, -8, -9, -4, -8,
     *1, -8, 3, -9, 5, -7, 7, -6, 9, -6, 9, 0, 8, 2, 5, 4, 7, 6, 7, 9,
      .
      ........(lines omitted for brevity)
      .
      INTEGER*2 CHAR3(130) / 130, -16, -9, 12, -13, 11, -2, -4, -1, -3,
     *0, -1, 0, 9, -64, 0, 1, 10, 3, 9, 5, 9, 7, 10, 8, 12, 7, 11, 5,
      .
      ........(lines omitted for brevity)
      .
      INTEGER*2 CHAR62(108)/108,-16,-9,12,-10,10,-7,-7,-5,-7,-3,
     *-8, -2, -9, 0, -8, 4, -7, 6, -7, 6, 9, 8, 10, 6, 10, 4, 11, 3, 12,
      etc.

I would like to overlay-define CHAR1 thru CHAR62 over CHARS with a
series of FORTRAN EQUIVALENCE STATEMENTS.  The following sequence
will perform the task:

     define aaa
     sno anchor trim stack +
       tab(6) 'integer*2 char' any('0123456789') index() '(' +
       break(')') $ n rtab(0) = 'a aaa nl ' n
     a aaa b del
     a aaa 0 bl 1
     a aaa t substr '1'
     a aaa ren 1 1
     apl bbb#4 0F62 1R+\62 3`Raaa
     a bbb ren 1 1
     define ccc recsize(80)
     a bbb co ccc
     a bbb end n
     a ccc snot 7 'equivalence (chars(' a '),char' seq '(1))'

The resulting EQUIVALENCE statements in dataset CCC would appear as
follows:

      EQUIVALENCE (CHARS(   1),CHAR1(1))
      EQUIVALENCE (CHARS( 117),CHAR2(1))
      EQUIVALENCE (CHARS( 317),CHAR3(1))
      EQUIVALENCE (CHARS( 447),CHAR4(1))
      EQUIVALENCE (CHARS( 583),CHAR5(1))
      .
      .
      .
      EQUIVALENCE (CHARS(6911),CHAR60(1))
      EQUIVALENCE (CHARS(6983),CHAR61(1))
      EQUIVALENCE (CHARS(7101),CHAR62(1))

APL - COLUMNARIZING A LIST OF NAMES USING APL                          @

Given a list of 198 6-character names as follows:

     ASCCOL
     ASCGET
     ASCHLT
     .
     .....(lines omitted for brevity)
     .
     SSQF
     SSREAD
     SSWRT

the following APL subcommand -

    apl bbb#F22 9R198 7`Raaa

will produce a list like the following:

    ASCCOL ASCGET ASCHLT ASCPUT ASCSS  ASDFLD ASDFLT ASDFMT ASD
    ASFCLR ASFCOL ASFCUR ASFEND ASFHLT ASFIN  ASFINT ASFMOD ASF
    ASFPSS ASFTRN ASFTYP ASGGET ASGPUT ASMODE ASQCOL ASQCUR ASQ
    .
    .
    .
    MSQFIT MSQFLD MSQGRP MSQMAP MSQMOD MSQPOS MSREAD PSDSS  PSL
    PSLSSC PSQSS  PSRSS  PSRSV  PTNCRT PTNDEL PTNMOD PTNQRY PTN
    PTSCRT PTSDEL PTSQRY PTSQUN PTSSEL SSQF   SSREAD SSWRT

SUPPRESSING ALL LINES INDENTED A SPECIFIC AMOUNT                       @

Given a dataset like the following:

            10        20        30        40
   1234567890123456789012345678901234567890123456

      SELECT(SUBSTR(SUBRTNE_NAME,1,1));
        WHEN('A') SELECT(SUBRTNE_NAME);
          WHEN('ASCCOL') DO;
            SUBRTNE=ASCCOL;
            CALL SETPARM('BIN FIXED(31)');
            CALL SETPARM('BIN FIXED(31)');
            CALL SETPARM('CHAR');
            END;
          WHEN('ASCGET') DO;
            SUBRTNE=ASCGET;
            CALL SETPARM('BIN FIXED(31)');
            CALL SETPARM('BIN FIXED(31)');
            CALL SETPARM('CHAR');
            END;
          WHEN('ASCHLT') DO;
            SUBRTNE=ASCHLT;
            CALL SETPARM('BIN FIXED(31)');
            CALL SETPARM('BIN FIXED(31)');
          .
          .
          .
          etc.

I can suppress printing all lines beginning in column 10 with the
following subcommand -

  sno anchor trim stack span(' ') pos(9) rtab(0) = seq ' suppress'

the resulting display would look like the following -

            10        20        30        40
   1234567890123456789012345678901234567890123456

      SELECT(SUBSTR(SUBRTNE_NAME,1,1));
        WHEN('A') SELECT(SUBRTNE_NAME);
          WHEN('ASCCOL') DO;
   ------LINES SUPPRESSED =  5
          WHEN('ASCGET') DO;
   ------LINES SUPPRESSED =  5
          WHEN('ASCHLT') DO;
   ------LINES SUPPRESSED =  5
          .
          .
          .
          etc.




SUBMITTING BATCH JOBS AND RETRIEVING SYSOUT                            @

ABE has several subcommands which facilitate the submission of jobs
for batch execution, and for examining the resultant output.  Those
subcommands will be discussed here.

First, suppose JCL is being edited as follows:

                 1         2         3         4         5         6
        12345678901234567890123456789012345678901234567890123456789012

  PB
  ====>          Ö Ö Ö Ö Ö Ö Ö Ö Ö Ö Ö Ö Ö
  00020 //EUP02711 JOB (10-338-MISC-027-B4,1),
  00030 // 'SMITH-TC',CLASS=X,MSGCLASS=1,NOTIFY=EUP027,TYPRUN=SCAN
  00031 // EXEC PGM=IEFBR14

This job can be submitted for batch execution by entering the SUB
subcommand, which will store the jcl in data set lastjcl.cntl, and will
generate a submit command for lastjcl.cntl.  When SUB is finished, you
will be left in xmode:

                 1         2         3         4         5         6
        12345678901234567890123456789012345678901234567890123456789012

  sub
  ====>          Ö Ö Ö Ö Ö Ö Ö Ö Ö Ö Ö Ö Ö
  00020 //EUP02711 JOB (10-338-MISC-027-B4,1),
  00030 // 'SMITH-TC',CLASS=X,MSGCLASS=1,NOTIFY=EUP027,TYPRUN=SCAN
  00031 // EXEC PGM=IEFBR14

the resulting display:

   ABEX

entering the $ command results in:

   ABEX
   $
   $HASP165 JOB 1419 EUP02711 ENDED CN(00)
   OUTPUT    1419 EUP02711
   ABEX

Entering a null line returns the display to full-screen mode. Now, to
examine the sysout from job eup02711, I enter the ABE subcommand
specifying the last two characters of the job name (11), and the sysout
keyword:

                 1         2         3         4         5         6
        12345678901234567890123456789012345678901234567890123456789012

  /abe 11 sysout/lines
  ====>          Ö Ö Ö Ö Ö Ö Ö Ö Ö Ö Ö Ö Ö
  00020 //EUP02711 JOB (10-338-MISC-027-B4,1),
  00030 // 'SMITH-TC',CLASS=X,MSGCLASS=1,NOTIFY=EUP027,TYPRUN=SCAN
  00031 // EXEC PGM=IEFBR14

the resulting display:

                 1         2         3         4         5         6
        12345678901234567890123456789012345678901234567890123456789012
 WARNING - DATA CONTAINS UNPRINTABLE CHARACTERS TRANSLATED
  PB
       F         Ö Ö Ö Ö Ö Ö Ö Ö Ö Ö Ö Ö Ö
  00010 .
  00020 .                                                J E S 2   J O
  00030     1     //EUP02711 JOB (10-338-MISC-027-B4,1),
  00040           // 'SMITH-TC',CLASS=X,MSGCLASS=1,NOTIFY=EUP027,TYPRU
  00050     2     // EXEC PGM=IEFBR14

The first thing you will notice is the message about unprintable
characters.  Many times, sysout will have been generated using machine
carriage control characters, which are unprintable at a 3270 crt
terminal.  In fact, if such characters were transmitted to the
terminal, they could easily cause an error which would cause you to be
disconnected from the system. ABE scans for such characters when it
reads the sysout, and will translate them to periods.  It also prints
But the message as above, and sets a flag to prevent you from doing a
save with the data altered in this fashion.

Now suppose I decide I would like a hardcopy listing of the sysout.
I can schedule a copy for printing by entering the $PRT subcommand
as follows:

                 1         2         3         4         5         6
        12345678901234567890123456789012345678901234567890123456789012
 WARNING - DATA CONTAINS UNPRINTABLE CHARACTERS TRANSLATED
  $prt
       F         Ö Ö Ö Ö Ö Ö Ö Ö Ö Ö Ö Ö Ö
  00010 .
  00020 .                                                J E S 2   J O
  00030     1     //EUP02711 JOB (10-338-MISC-027-B4,1),
  00040           // 'SMITH-TC',CLASS=X,MSGCLASS=1,NOTIFY=EUP027,TYPRU
  00050     2     // EXEC PGM=IEFBR14

When the ABE subcommand was originally entered to obtain the sysout,
ABE created a data set named 'userid.jobname.OUTLIST', where userid is
the current userid (or prefix), and jobname is the job name of the job
for which sysout is to be displayed (in this case EUP02711). When you
are done looking at the sysout, you can end editing of it and delete
the ".OUTLIST" dataset all at one time by entering the subcommand
$PURGE as follows:

                 1         2         3         4         5         6
        12345678901234567890123456789012345678901234567890123456789012
  TRANSLATED
  $purge
       F         Ö Ö Ö Ö Ö Ö Ö Ö Ö Ö Ö Ö Ö
  00010 .
  00020 .                                                J E S 2   J O
  00030     1     //EUP02711 JOB (10-338-MISC-027-B4,1),
  00040           // 'SMITH-TC',CLASS=X,MSGCLASS=1,NOTIFY=EUP027,TYPRU
  00050     2     // EXEC PGM=IEFBR14

the resulting display:

                 1         2         3         4         5         6
        12345678901234567890123456789012345678901234567890123456789012

  PB
       F         Ö Ö Ö Ö Ö Ö Ö Ö Ö Ö Ö Ö Ö
  00020 //EUP02711 JOB (10-338-MISC-027-B4,1),
  00030 // 'SMITH-TC',CLASS=X,MSGCLASS=1,NOTIFY=EUP027,TYPRUN=SCAN
  00031 // EXEC PGM=IEFBR14

As you can see above, the display is back to the original JCL we were
editing when the ABE subcommand was entered to retrieve the sysout.
Now look at some different sysout, which has already been retrieved:

                 1         2         3         4         5         6
        12345678901234567890123456789012345678901234567890123456789012

  *abe eup02749.outlist name(sysou) tran*end n
       F         Ö Ö Ö Ö Ö Ö Ö Ö Ö Ö Ö Ö Ö
  (lines omitted for brevity)

the resulting display:

                 1         2         3         4         5         6
        12345678901234567890123456789012345678901234567890123456789012
  TRANSLATED
  PF
       F         Ö Ö Ö Ö Ö Ö Ö Ö Ö Ö Ö Ö Ö
  00010 .
  00020 .                                                J E S 2   J O

  00030 .13.24.20 JOB 1611  $HASP373 EUP02749 STARTED - INIT 18 - CLAS
  00040 .13.24.20 JOB 1611  IEF403I EUP02749 - STARTED - TIME=13.24.20
  00050 .13.27.49 JOB 1611  IEF404I EUP02749 - ENDED - TIME=13.27.49
  00060 .13.27.49 JOB 1611  $HASP395 EUP02749 ENDED
  00070     1     //EUP02749 JOB (10-338-MISC-027-B4,1),
  00080           // 'SMITH-TC',CLASS=X,MSGCLASS=1,NOTIFY=EUP027
  00090     2     //STEP2  EXEC  PANVALET
  00100     3     XXPANVALET PROC PN=1,TYPE=T                      SOF
  00110     4     XXPANVALET EXEC PGM=PAN#&PN,TIME=1
  00120     5     XXPANDD1    DD DSN=SYSIMSV&TYPE..PANVALET.LIBRARY,DI
  00130     6     XXPANDD2    DD DSN=&&SOURCE,DISP=(,PASS),SPACE=(3120
  00140           XX             UNIT=SYSDA,DCB=(RECFM=FB,LRECL=80,BLK
  00150     7     //PANVALET.SYSPRINT DD DUMMY
  00160           X/SYSPRINT  DD SYSOUT=*
  00170     8     XXSYSPUNCH  DD SYSOUT=B
  00180     9     //SYSIN     DD *
  00190           X/SYSIN     DD DDNAME=SYSIN

To get a quick look at the return codes from all steps in the job, I
use the $CC subcomand, which suppresses the printing of all MSGCLASS
sysout except the messages indicating return codes:

                 1         2         3         4         5         6
        12345678901234567890123456789012345678901234567890123456789012
  TRANSLATED
  $cc
       F         Ö Ö Ö Ö Ö Ö Ö Ö Ö Ö Ö Ö Ö
  00010 .
  00020 .                                                J E S 2   J O
  00030 .13.24.20 JOB 1611  $HASP373 EUP02749 STARTED - INIT 18 - CLAS
  00040 .13.24.20 JOB 1611  IEF403I EUP02749 - STARTED - TIME=13.24.20
  (lines omitted for brevity)

the resulting display:

                 1         2         3         4         5         6
        12345678901234567890123456789012345678901234567890123456789012
  TRANSLATED
  PF
       F         Ö Ö Ö Ö Ö Ö Ö Ö Ö Ö Ö Ö Ö
  00010 ------LINES SUPPRESSED =  79
  00800  IEF142I EUP02749 PANVALET STEP2 - STEP WAS EXECUTED - COND CO
  00810 ------LINES SUPPRESSED =  36
  01170  IEF142I EUP02749 SAS STEP3 - STEP WAS EXECUTED - COND CODE 00
  01180 ------LINES SUPPRESSED =  46
  01640  IEF142I EUP02749 DIST - STEP WAS EXECUTED - COND CODE 0000
  01650 ------LINES SUPPRESSED =  24
  01890  IEF142I EUP02749 COPYRPT - STEP WAS EXECUTED - COND CODE 0000
  01900 ------LINES SUPPRESSED =  30
  02200  IEF376I  JOB /EUP02749/ STOP  80316.1327 CPU    0MIN 15.23SEC
  (lines omitted for brevity)

To skip quickly to the end of the MSGCLASS sysout, use the $JE
subcommand as follows:

                 1         2         3         4         5         6
        12345678901234567890123456789012345678901234567890123456789012
  TRANSLATED
  $je
       F         Ö Ö Ö Ö Ö Ö Ö Ö Ö Ö Ö Ö Ö
  00010 ------LINES SUPPRESSED =  79
  00800  IEF142I EUP02749 PANVALET STEP2 - STEP WAS EXECUTED - COND CO
  (lines omitted for brevity)

The resulting display:

                 1         2         3         4         5         6
        12345678901234567890123456789012345678901234567890123456789012
  TRANSLATED
  PF
       F         Ö Ö Ö Ö Ö Ö Ö Ö Ö Ö Ö Ö Ö
  02200  IEF376I  JOB /EUP02749/ STOP  80316.1327 CPU    0MIN 15.23SEC
  02210 11                                        S T A T I S T I C A
  02220 0NOTE: THE JOB EUP02749 HAS BEEN RUN UNDER RELEASE 79.3A OF SA
  02230 0NOTE: IF YOU HAVE ANY PROBLEMS OR QUESTIONS
  (lines omitted for brevity)

PROGRAM FUNCTION KEYS: TWO-BUTTON ENTRY OF SUBCOMMANDS:                @

The program function keys of the 3270 terminal have default ABE
subcommands associated with them.  If, for example, you enter program
function key 1, the LAST subcommand will be entered for you, causing
the last subcommand you entered to be re-displayed in the command area
(you can then alter it and re-enter it). Other defaults are: PF for
pfk 8, PB for pfk 7, TOP for pfk 9, etc. IBM has a small plastic
folder with a cardboard insert that you can place above your keyboard
to show you what each PFK stands for.  The order number if GX20-2040.

You can also define your own lists of subcommands to be associated
with each program function key.  In the following displays, program
function keys four and five are set to find, respectively, the next
line with '1' in column one, and the previous line with '1' in column
one:

                 1         2         3         4         5         6
        12345678901234567890123456789012345678901234567890123456789012
  TRANSLATED
  /define pfk05 support/a pfk05 lines 999
  SYSOU          Ö Ö Ö Ö Ö Ö Ö Ö Ö Ö Ö Ö Ö
  02200  IEF376I  JOB /EUP02749/ STOP  80316.1327 CPU    0MIN 15.23SEC
  02210 11                                        S T A T I S T I C A
  (lines omitted for brevity)

the resulting display:

                 1         2         3         4         5         6
        12345678901234567890123456789012345678901234567890123456789012

  PB
  PFK05

The DEFINE subcommand tells ABE you want a new data set defined,
which will exist only in virtual memory.  In this case, I specified
the symbolic name PFK05 be associated with the new data set, and
specified the keyword "support" to prevent it from showing up on the
display in response to a "lines" subcommand with no operands.

A lot of different things are done on the next display:

                 1         2         3         4         5         6
        12345678901234567890123456789012345678901234567890123456789012

  /nl n b find 1 1/top/co pfk06
  PFK05
        n b find 1 1

the resulting display:

                 1         2         3         4         5         6
        12345678901234567890123456789012345678901234567890123456789012

  PB
  PFK05
  00001 N B FIND 1 1

  (lines omitted for brevity)

  PFK06
  00001 N B FIND 1 1

With one depression of the ENTER key above, I told ABE: (1) that I
wanted a line inserted in data set with symbolic name PFK05 containing
"n b f find 1 1". (2) that I wanted to move the display to the top of
the data set with symbolic name PFK05; (3) that I wanted to copy all
lines data set with symbolic name PFK05 to the data set with symbolic
name PFK06 (since such a data set doesn't exist when the subcommand is
entered, ABE will create one);

Now I make one change to data set with symbolic name PFK06, and return
the sysout data set to the display:

                 1         2         3         4         5         6
        12345678901234567890123456789012345678901234567890123456789012

  lines
  PFK05
  00001 n b find 1 1

  (lines omitted for brevity)

  PFK06 /support/show sysou
  00001 p t find 1 1

the resulting display:

                 1         2         3         4         5         6
        12345678901234567890123456789012345678901234567890123456789012
  TRANSLATED
  PF
  SYSOU          Ö Ö Ö Ö Ö Ö Ö Ö Ö Ö Ö Ö Ö
  02200  IEF376I  JOB /EUP02749/ STOP  80316.1327 CPU    0MIN 15.23SEC
  02210 11                                        S T A T I S T I C A
  02220 0NOTE: THE JOB EUP02749 HAS BEEN RUN UNDER RELEASE 79.3A OF SA
  02230 0NOTE: IF YOU HAVE ANY PROBLEMS OR QUESTIONS
  02240        REGARDING SAS 79.3 AT KIMBERLY-CLARK
  (lines omitted for brevity)

Now, to move the display to the next line with a '1' in column one,
I only have to press program function key 5, and the result will
be:

                 1         2         3         4         5         6
        12345678901234567890123456789012345678901234567890123456789012
  TRANSLATED
  PF
  SYSOU          Ö Ö Ö Ö Ö Ö Ö Ö Ö Ö Ö Ö Ö
  02210 11                                        S T A T I S T I C A
  02220 0NOTE: THE JOB EUP02749 HAS BEEN RUN UNDER RELEASE 79.3A OF SA
  02230 0NOTE: IF YOU HAVE ANY PROBLEMS OR QUESTIONS
  (lines omitted for brevity)

Pressing pfk 5 again:

                 1         2         3         4         5         6
        12345678901234567890123456789012345678901234567890123456789012
  TRANSLATED
  PF
  SYSOU          Ö Ö Ö Ö Ö Ö Ö Ö Ö Ö Ö Ö Ö
  02780 12                                        S T A T I S T I C A
  02790 052          E_HOUR = FLOOR(JOB_END  / 3600);
  02800  53          CLASS = 4;
  (lines omitted for brevity)

Now pressing pfk 6:

                 1         2         3         4         5         6
        12345678901234567890123456789012345678901234567890123456789012
  TRANSLATED
  PF
  SYSOU          Ö Ö Ö Ö Ö Ö Ö Ö Ö Ö Ö Ö Ö
  02210 11                                        S T A T I S T I C A
  02220 0NOTE: THE JOB EUP02749 HAS BEEN RUN UNDER RELEASE 79.3A OF SA
  02230 0NOTE: IF YOU HAVE ANY PROBLEMS OR QUESTIONS
  (lines omitted for brevity)

WORD PROCESSING: SPLIT, SORTQ, LL.                                     @

ABE also has some facilities which can be used for word processing.
consider the following edited data set, which contains an entire list
of ABE subcommands:

                 1         2         3         4         5         6
        12345678901234567890123456789012345678901234567890123456789012

  PB
  ====>          Ö Ö Ö Ö Ö Ö Ö Ö Ö Ö Ö Ö Ö
  00010 X, A, NAME, HARDCOPY, SAVE, TAB, TABK, FAB, LAST, PBSR, PB, MB
  00130 PBSL, SCAN, AC, $CC, MC, MD, MDEL, $EDIT, MERGE, HELP, ME, MER
  00250 REFRESH, DEFINE, DELETE, DENT, RESET, SETSEQ, RENUM, SEQ, RESE
  00340 HEX, VERIFY, PF, PFK, SHOW, CHANGE, CHAR, LINES, HI, FINDALL,
  00440 DISTRUNC, FIB, AID, FIND, LIST, $JE, MK, AL, LL, BLANK, SL, NL
  00560 FLIP, CLEAR, OL, EMODE, CMODE, MM, END, UNNUM, INSERT, DO, DOW
  00670 LOG, JOIN, CONTENT, SORTQL, COLUMN, LO, SORTL, BOTTOM, SORT, M
  00770 COPY, TOP, SORTQ, SPFF, $PP, $PK, $PURGE, UP, SPLIT, SPFC, $PR
  00890 DREM, TRACE, TRUNCATE, TRANSLAT, AR, RUN, MS, LSS, DSNOUT, LS
  00990 DSNIN, ASYNCH, DSN, ITEIN, MT, AT, CURSOR, FULLSCR, SUBMIT, RU
  01090 SUPPRESS, DUMP, SUBSTR, MV, EXEC, SYNCH

As you can see above, the list is not collated.  The following will
show how to get this list in sequence by entering only four ABE
subcommands.  First, the SPLITB subcommand is entered to isolate each
name on a separate line:

                 1         2         3         4         5         6
        12345678901234567890123456789012345678901234567890123456789012

  splitb
  ====>          Ö Ö Ö Ö Ö Ö Ö Ö Ö Ö Ö Ö Ö
  00010 X, A, NAME, HARDCOPY, SAVE, TAB, TABK, FAB, LAST, PBSR, PB, MB
  00130 PBSL, SCAN, AC, $CC, MC, MD, MDEL, $EDIT, MERGE, HELP, ME, MER
  (lines omitted for brevity)

The resulting display:

                 1         2         3         4         5         6
        12345678901234567890123456789012345678901234567890123456789012

  PF
  ====>          Ö Ö Ö Ö Ö Ö Ö Ö Ö Ö Ö Ö Ö
  00010 X,
  00011 A,
  00012 NAME,
  00013 HARDCOPY,
  00014 SAVE,
  (lines omitted for brevity)

Now the SORTQ subcommand is used to sort the records into sequence:

                 1         2         3         4         5         6
        12345678901234567890123456789012345678901234567890123456789012

  sortq 1 8 A
  ====>          Ö Ö Ö Ö Ö Ö Ö Ö Ö Ö Ö Ö Ö
  00010 X,
  (lines omitted for brevity)

The resulting display:

                 1         2         3         4         5         6
        12345678901234567890123456789012345678901234567890123456789012

  PF
  ====>          Ö Ö Ö Ö Ö Ö Ö Ö Ö Ö Ö Ö Ö
  00010 $CC,
  00020 $EDIT,
  00030 $JE,
  00040 $PK,
  00050 $PP,
  00060 $PRT,
  00070 $PURGE,
  00080 A,
  00090 AC,
  00100 AID,
  00110 AL,
  00120 AR,
  00130 RUN,
  00140 ASYNCH,
  00150 AT,
  00160 BLANK,
  00170 BOTTOM,
  00180 CHANGE,
  00190 CHAR,

Now the LL subcommand (stands for line-length) is used to
reassemble 68-character lines:

                 1         2         3         4         5         6
        12345678901234567890123456789012345678901234567890123456789012

  ll 68
  ====>          Ö Ö Ö Ö Ö Ö Ö Ö Ö Ö Ö Ö Ö
  00010 $CC,
  00020 $EDIT,
  00030 $JE,
  (lines omitted for brevity)

the resulting display:

                 1         2         3         4         5         6
        12345678901234567890123456789012345678901234567890123456789012

  PB
  ====>          Ö Ö Ö Ö Ö Ö Ö Ö Ö Ö Ö Ö Ö
  00010 $CC, $EDIT, $JE, $PK, $PP, $PRT, $PURGE, A, AC, AID, AL, AR, A
  00140 ASYNCH, AT, BLANK, BOTTOM, CHANGE, CHAR, CLEAR, CMODE, COLUMN,
  00230 CONTENT, COPY, CURSOR, DEFINE, DELETE, DENT, DISTRUNC, DO, DOW
  00320 DREM, DSN, DSNIN, DSNOUT, DUMP, EMODE, END, EXEC, FAB, FIB, FI
  00430 FINDALL, FLIP, FULLSCR, HARDCOPY, HELP, HEX, HI, INSERT, ITEIN
  00520 JOIN, LAST, LINES, LIST, LL, LO, LOG, LSP, LSS, MB, MC, MD, MD
  00650 ME, MERD, MERGE, MK, MM, MOVE, MS, MT, MV, NAME, NL, OL, PB, P
  00790 PBSR, PF, PFK, REFRESH, RENUM, RESEQ, RESET, RUN, SAVE, SCAN,
  00900 SETSEQ, SHOW, SL, SORT, SORTL, SORTQ, SORTQL, SPFC, SPFF, SPLI
  01010 SUBMIT, SUBSTR, SUPPRESS, SYNCH, TAB, TABK, TOP, TRACE, TRANSL
  01100 TRUNCATE, UNNUM, UP, VERIFY, X,

WORD PROCESSING - A FEW EXAMPLES                                       @

                 1         2         3         4         5         6
        12345678901234567890123456789012345678901234567890123456789012

  PB
  ====>          Ö Ö Ö Ö Ö Ö Ö Ö Ö Ö Ö Ö Ö
  00024 You should be aware of the special use of the unquoted
  00025 strings 0m  1m  2m, etc., as positional operands on any
  00026 abe subcommand.  Such strings will be replaced with
  00027 the value of the corresponding mark array element before
  00028 the subcommand is executed.  For more information on the
  00029 mark array, see help data for the MARK subcommand.

In the above text, I would like to insert the sentence "How now
brown cow?" following the sentence beginning 'Such strings will".
Also, I want to change the right margin from column 55 to column 40.
First, I enter the SPLIT subcommand as follows:

                 1         2         3         4         5         6
        12345678901234567890123456789012345678901234567890123456789012

  26 split Such
  ====>          Ö Ö Ö Ö Ö Ö Ö Ö Ö Ö Ö Ö Ö
  00024 You should be aware of the special use of the unquoted
  00025 strings 0m, 1m, 2m, etc., as positional operands on any
  00026 abe subcommand.  Such strings will be replaced with
  00027 the value of the corresponding mark array element before
  00028 the subcommand is executed.  For more information on the
  00029 mark array, see help data for the MARK subcommand.

the resulting display:

                 1         2         3         4         5         6
        12345678901234567890123456789012345678901234567890123456789012

  PB
  ====>          Ö Ö Ö Ö Ö Ö Ö Ö Ö Ö Ö Ö Ö
  00024 You should be aware of the special use of the unquoted
  00025 strings 0m, 1m, 2m, etc., as positional operands on any
  00026 dent subcommand.
  00027 Such strings will be replaced with
  00028 the value of the corresponding mark array element before
  (lines omitted for brevity)

Then, I enter the sentence "How now brown cow.", and use the LL
subcommand to change the right margin to column 40:

                 1         2         3         4         5         6
        12345678901234567890123456789012345678901234567890123456789012

  ll 40
  ====>          Ö Ö Ö Ö Ö Ö Ö Ö Ö Ö Ö Ö Ö
  00024 You should be aware of the special use of the unquoted
  00025 strings 0m, 1m, 2m, etc., as positional operands on any
  00026 abe subcommand.  How now brown cow.
  00027 Such strings will be replaced with
  00028 the value of the corresponding mark array element before
  00029 the subcommand is executed.  For more information on the
  00030 mark array, see help data for the MARK subcommand.

the resulting display:

                 1         2         3         4         5         6
        12345678901234567890123456789012345678901234567890123456789012

  PB
  ====>          Ö Ö Ö Ö Ö Ö Ö Ö Ö Ö Ö Ö Ö
  00024 You should be aware of the special use
  00025 of the unquoted strings m0, m1, m2,
  00026 etc., as positional operands on any abe
  00027 subcommand.  How now brown cow.  Such
  00028 strings will be replaced with the value
  00029 of the corresponding mark array element
  00030 before the subcommand is executed.  For
  00031 more information on the mark array, see
  00032 help data for the MARK subcommand.

Another common word processing requirement is the generation of form
letters in which most of the text is standard, but items such as name
and address change for each letter.  All you want to do is supply the
variable information and have the system stuff it into the generated
letter at appropriate points. Following is an example of doing this.

First I enter the following command from READY mode:

    abe '' lo

This will establish an empty virtual data set as the one currently
being edited.  Then, I enter the following ABE subcommand:

                 1         2         3         4         5         6
        12345678901234567890123456789012345678901234567890123456789012

  %%letter fullnam(Tom Smith) first(Tom) addr1(23rd St.) +         ××
        F        Ö Ö Ö Ö Ö Ö Ö Ö Ö Ö Ö Ö Ö

The text "%%letter" is just a shorthand way of saying "run letter."
A list of the "letter" subcommand list will be shown later on.

The plus at the end of the subcommand line will be recognized by ABE
as a continuation indicator.  ABE will clear the screen and prompt
for continuation of the subcommand text, after repeating the text
already entered for the subcommand on the screen so you can read it
while entering the rest of the subcommand:

  ====> : %%letter fullnam(Tom Smith) first(Tom) addr1(23rd St.) +

I now enter the rest of the subcommand:

    addr2(Neenah, Wis.) days(30) amt(500) date(09/12/82)

the result will be the following:

                 1         2         3         4         5         6
        12345678901234567890123456789012345678901234567890123456789012

                                                                   ××
        F        Ö Ö Ö Ö Ö Ö Ö Ö Ö Ö Ö Ö Ö
                                                        Tom Smith
    02                                                  23rd St.
    03                                                  Neenah, Wis
    04
    05  Dear Tom
    06
    07  Our records show that you are 30 days in arrears on your
    08  unpaid bills.  If we have not received the $500 you owe us
    09  by 09/12/82, we will break your bones.
    10
    11                                Sincerely,
    12
    13
    14
    15
    16                                ACME Collection Agency

Following is a listing of the "letter" run data set:

     1 $control nl
     2                                                   &FULLNAM
     3                                                   &ADDR1
     4                                                   &ADDR2
     5
     6  Dear &FIRST
     7
     8  Our records show that you are &DAYS days in arrears on your
     9  unpaid bills.  If we have not received the $&AMT you owe us
    10  by &DATE, we will break your bones.
    11
    12                                Sincerely,
    13
    14
    15
    16
    17                                ACME Collection Agency
    18 $cmd top

Now suppose you have an account file of the following format:

  COLUMNS DESCRIPTION

   1-19   Person's full name
  20-39   Street address
  40-59   City, State
  60-60   Contains '-' if the balance is negative.
  61-63   Account balance.

The listing of a sample account file follows:

               1         2         3         4         5         6
      123456789012345678901234567890123456789012345678901234567890123

    PF                                    ×SAMPLE×X75826.SAMPLE.DATA×
      F        Ö Ö Ö Ö Ö Ö Ö Ö Ö Ö Ö Ö Ö
    1 Tom Smith          306 Bell            Neenah, Wis.         230
    2 Henry Goldfarb     221 Conkel          Chicago, Ill.       -430
    3 Timothy Leary      416 Congress        New Haven, Conn.     560
    4 Howard Johnson     770 Lincoln         Buffalo, N.Y.       -700

You would like to generate a form letter like the one already shown
for every person in the account file with a negative balance.  You
can do this with a command such as the following:

               1         2         3         4         5         6
      123456789012345678901234567890123456789012345678901234567890123

    %%lettera                             ×SAMPLE×X75826.SAMPLE.DATA×
      F        Ö Ö Ö Ö Ö Ö Ö Ö Ö Ö Ö Ö Ö
    1 Tom Smith          306 Bell            Neenah, Wis.         230
    2 Henry Goldfarb     221 Conkel          Chicago, Ill.       -430
    3 Timothy Leary      416 Congress        New Haven, Conn.     560
    4 Howard Johnson     770 Lincoln         Buffalo, N.Y.       -700

The results would appear as follows:


               1         2         3         4         5         6
      123456789012345678901234567890123456789012345678901234567890123

   PF                                    ×SAMPLE×X75826.SAMPLE.DATA×
      F        Ö Ö Ö Ö Ö Ö Ö Ö Ö Ö Ö Ö Ö
   01 1
   02                                                   Henry Goldfarb
   03                                                   221 Conkel
   04                                                   Chicago, Ill.
   05
   06  Dear Henry
   07
   08  Our records show that you are 30 days in arrears on your
   09  unpaid bills.  If we have not received the $430 you owe us
   10  by 09/12/82, we will break your bones.
   11
   12                                Sincerely,
   13
   14
   15
   16
   17                                ACME Collection Agency
   18 1
   19                                                   Howard Johnson
   20                                                   770 Lincoln
   21                                                   Buffalo, N.Y.
   22
   23  Dear Howard
   24
   25  Our records show that you are 30 days in arrears on your
   26  unpaid bills.  If we have not received the $700 you owe us
   27  by 09/12/82, we will break your bones.
   28
   29                                Sincerely,
   30
   31
   32
   33
   34                                ACME Collection Agency

Note that in the text above, the 1 in column 1 in the line at the
front of each generated letter will cause a skip to a new page when
the data is printed on sysout.

Following is a listing of the "lettera" run:

               1         2         3         4         5         6
      123456789012345678901234567890123456789012345678901234567890123

   PF                                 ×LETTERA×U.SD.U000.RUN(LETTERA)
     F         Ö Ö Ö Ö Ö Ö Ö Ö Ö Ö Ö Ö Ö
   01 $CONTROL NL
   02 $CMD SETL DAYS 30
   03 $CMD SETL DATE 09/12/82
   04 $CMD B BL 1
   05 $CMD B MK 6
   06 $ LOOP
   07   $CMD F '-' STC(60)
   08   $IF LASTCC=0
   09     $CMD SETD AMT * 61 3
   10     $CMD SETD ADDR2 * 40 19
   11     $CMD SETD ADDR1 * 20 19
   12     $CMD SETD FULLNAM * 01 19
   13     $CMD * AC ' ' 20
   14     $CMD * AL 1 19
   15     $CMD SETD FIRST * 01 19
   16     $CMD * DEL
   17     $CMD SET NEW 1
   18     $CMD B V
   19     $CMD RUN LETTER
   20     $GOTO LOOP
   21 $CMD T 6M DEL
   22 $CMD TOP

POWER TYPING                                                           @

You can enter text under ABE using what is called the power typing
technique.  That is, after issuing the IN subcommand, entering text
without regard to end-of-line conditions.  Since a good example of this
technique is shown in PART II under the LL subcommand, no more will be
said about it here.


EDITING UNPRINTABLE DATA: HEX, TRANSLAT, COL.                          @

Suppose you want to edit data containing unprintable characters.
In a prior section on editing sysout data sets, it was noted that such
data can cause problems when displayed on a 3270 crt terminal.
data set EUP027.SHOWSMF.DATA contains data with unprintable
characters in it.  Here is what happens when I edit this data:

    abe showsmf

The resulting display:

                 1         2         3         4         5         6
        12345678901234567890123456789012345678901234567890123456789012
  WARNING - DATA CONTAINS UNPRINTABLE CHARACTERS
  PF
  ====>          Ö Ö Ö Ö Ö Ö Ö Ö Ö Ö Ö Ö Ö
  00010 . . . . . . . . . . K C 7 6 . . . . . .   . . .   . 0 . . . .
  00010 0200001E71770080328FD2C3F7F60000001E0000400000004000F000002000
  00020 . . . . . " . . . . K C 7 6 . . . . . . . . .     . . .   . .
  00020 0208001E717F0080328FD2C3F7F601B60804000A1008004040150043405300
  (lines omitted for brevity)

As you can see above, ABE recognized the unprintable characters when
it read in the data set, so it automatically displayed it in HEX
mode.  In this mode, each data line is displayed twice.  On the first
line it is displayed in EBCDIC, with spaces between each character,
and unprintable characters replaced with periods.  On the second line
it is displayed in hexadecimal, two print positions per EBCDIC
character.

It should be mentioned in passing that data not displayed from
records because they are too long to fit on the screen can be viewed
by use of the COL subcommand:

                 1         2         3         4         5         6
        12345678901234567890123456789012345678901234567890123456789012

  col 70
  ====>          Ö Ö Ö Ö Ö Ö Ö Ö Ö Ö Ö Ö Ö
  00010 . . . . . . . . . . K C 7 6 . . . . . .   . . .   . 0 . . . .
  00010 0200001E71770080328FD2C3F7F60000001E0000400000004000F000002000
  00020 . . . . . " . . . . K C 7 6 . . . . . . . . .     . . .   . .
  00020 0208001E717F0080328FD2C3F7F601B60804000A1008004040150043405300
  (lines omitted for brevity)

The resulting display (next page):

                  8         9         0         1         2         3
        01234567890123456789012345678901234567890123456789012345678901

  PF
  ====>
  00010
  00010
  00020 l . a   l . b   l . c   l . d   l . e   l . f   l . g   l . h
  00020 93008140930082409300834093008440930085409300864093008740930088
  (lines omitted for brevity)

As you can see above, the "col 70" subcommand caused the display to
be changed so that each line of the display begins with data from
column 70 of each record.  To return the display to begin in column
1, enter the following:

                  8         9         0         1         2         3
        01234567890123456789012345678901234567890123456789012345678901

  col
  ====>
  00010
  00010
  00020 l . a   l . b   l . c   l . d   l . e   l . f   l . g   l . h
  00020 93008140930082409300834093008440930085409300864093008740930088
  (lines omitted for brevity)

The resulting display:

                 1         2         3         4         5         6
        12345678901234567890123456789012345678901234567890123456789012

  PF
  ====>          Ö Ö Ö Ö Ö Ö Ö Ö Ö Ö Ö Ö Ö
  00010 . . . . . . . . . . K C 7 6 . . . . . .   . . .   . 0 . . . .
  00010 0200001E71770080328FD2C3F7F60000001E0000400000004000F000002000
  00020 . . . . . " . . . . K C 7 6 . . . . . . . . .     . . .   . .
  00020 0208001E717F0080328FD2C3F7F601B60804000A1008004040150043405300
  (lines omitted for brevity)

Suppose, however, that I want to look at the data in normal mode, with
dach data record appearing in EBCDIC on only one line of the display.
this mode is called "character" mode, and is invoked by entering the
CHAR subcommand.  But first we have to get rid of the unprintable
characters.  DO NOT enter character mode without first getting rid
pf the unprintable characters unless you know precisely what you
are doing.  If you do and you don't you will probably get disconnected
from the system because of I/O errors on your terminal.  To get
rid of unprintable characters, enter the TRANSLAT subcommand:

                 1         2         3         4         5         6
        12345678901234567890123456789012345678901234567890123456789012

  translat
  ====>          Ö Ö Ö Ö Ö Ö Ö Ö Ö Ö Ö Ö Ö
  00010 . . . . . . . . . . K C 7 6 . . . . . .   . . .   . 0 . . . .
  00010 0200001E71770080328FD2C3F7F60000001E0000400000004000F000002000
  00020 . . . . . " . . . . K C 7 6 . . . . . . . . .     . . .   . .
  00020 0208001E717F0080328FD2C3F7F601B60804000A1008004040150043405300
  (lines omitted for brevity)

The resulting display:

                 1         2         3         4         5         6
        12345678901234567890123456789012345678901234567890123456789012
  TRANSLATED
  PF
  ====>          Ö Ö Ö Ö Ö Ö Ö Ö Ö Ö Ö Ö Ö
  00010 . . . . . . . . . . K C 7 6 . . . . . .   . . .   . 0 . . . .
  00010 4B4B4B4B4B4B4B4B4B4BD2C3F7F64B4B4B4B4B4B404B4B4B404BF04B4B4B4B
  00020 . . . . . " . . . . K C 7 6 . . . . . . . . .     . . .   . .
  00020 4B4B4B4B4B7F4B4B4B4BD2C3F7F64B4B4B4B4B4B4B4B4B40404B4B4B404B4B
  (lines omitted for brevity)

As you can see above, TRANSLAT changed all unprintable characters to
periods.  Now we can safely go to character mode:

                 1         2         3         4         5         6
        12345678901234567890123456789012345678901234567890123456789012
  TRANSLATED
  char
  ====>          Ö Ö Ö Ö Ö Ö Ö Ö Ö Ö Ö Ö Ö
  00010 . . . . . . . . . . K C 7 6 . . . . . .   . . .   . 0 . . . .
  00010 4B4B4B4B4B4B4B4B4B4BD2C3F7F64B4B4B4B4B4B404B4B4B404BF04B4B4B4B
  00020 . . . . . " . . . . K C 7 6 . . . . . . . . .     . . .   . .
  00020 4B4B4B4B4B7F4B4B4B4BD2C3F7F64B4B4B4B4B4B4B4B4B40404B4B4B404B4B
  (lines omitted for brevity)

The resulting display:

                 1         2         3         4         5         6
        12345678901234567890123456789012345678901234567890123456789012
  TRANSLATED
  PF
  ====>          Ö Ö Ö Ö Ö Ö Ö Ö Ö Ö Ö Ö Ö
  00010 ..........KC76...... ... .0....
  00020 ....."....KC76.........  ... ..- ../ ... ... ... l.@ l.' l.= l
  00030 .....a....KC76................
  00040 .!...a....KC76....................01SMF     ...........%......
  00050 .!...a....KC76....................01SRM     j.......IEAIPS00IE
  (lines omitted for brevity)

Now see what happens if you try to do a SAVE subcommand after using
the TRANSLAT subcommand:

                 1         2         3         4         5         6
        12345678901234567890123456789012345678901234567890123456789012
  TRANSLATED
  s
  ====>          Ö Ö Ö Ö Ö Ö Ö Ö Ö Ö Ö Ö Ö
  00010 ..........KC76...... ... .0....
  00020 ....."....KC76.........  ... ..- ../ ... ... ... l.@ l.' l.= l
  00030 .....a....KC76................
  00040 .!...a....KC76....................01SMF     ...........%......
  00050 .!...a....KC76....................01SRM     j.......IEAIPS00IE
  (lines omitted for brevity)

The resulting display:

                 1         2         3         4         5         6
        12345678901234567890123456789012345678901234567890123456789012
 TRANSLATED DATA CAN ONLY BE SAVED WITH THE ST SUBCOMMAND TRANSLATED

  ====>          Ö Ö Ö Ö Ö Ö Ö Ö Ö Ö Ö Ö Ö
  00010 ..........KC76...... ... .0....
  00020 ....."....KC76.........  ... ..- ../ ... ... ... l.@ l.' l.= l
  00030 .....a....KC76................
  00040 .!...a....KC76....................01SMF     ...........%......
  00050 .!...a....KC76....................01SRM     j.......IEAIPS00IE
  (lines omitted for brevity)

As you can see, ABE protects you from saving data to which the
TRANSLAT subcommand has been applied.  You should enter "end n"
as follows:

                 1         2         3         4         5         6
        12345678901234567890123456789012345678901234567890123456789012
 TRANSLATED DATA CAN ONLY BE SAVED WITH THE ST SUBCOMMAND TRANSLATED
  end n
  ====>          Ö Ö Ö Ö Ö Ö Ö Ö Ö Ö Ö Ö Ö
  00010 ..........KC76...... ... .0....
  00020 ....."....KC76.........  ... ..- ../ ... ... ... l.@ l.' l.= l
  00030 .....a....KC76................
  00040 .!...a....KC76....................01SMF     ...........%......
  00050 .!...a....KC76....................01SRM     j.......IEAIPS00IE
  (lines omitted for brevity)


FORMATTING YOUR OWN FULL-SCREEN DISPLAYS                               @

ABE has a facility for easily defining your own full-screen displays.
However, since this facility was developed, several other facilities
have become available that do a better job of full-screen management.
See documentation of the ISPF facility, and also appendix O to this
manual, which documents an interface to GDDM (Graphical Data Display
manager).

To start the discussion, an example of simple data entry using
a full-screen display will be illustrated.  I will first step
through the process without giving any details as to how it is
accomplished:

Suppose I enter the following at the terminal:

     %tstpnl

The next thing I will see on my terminal will be the following
full-screen display (some blank lines have been omitted from the
following displays for the sake of brevity):

SAMPLE PANEL TO INPUT DATA LINE 00010

              NAME: _

                             ADDR:

                                            PHONE:


This display has three unprotected fields on it in which I can key in
name, address, and phone number.  I have added an underscore
character in the position where the cursor shows up on the real
display.  I can key in the name, and then using the tab key, which is
on the left of most 3278 keyboards, and is marked with a right arrow
pointing at a vertical line, I can quickly move the cursor to the
next input field to key in the address.  When I am through keying,
just before hitting the ENTER key, the display will look as it
does below:

SAMPLE PANEL TO INPUT DATA LINE 00010

              NAME: t. smith

                             ADDR: 306 bell, neenah

                                            PHONE: 725-3484_

When I hit ENTER, the display is changed to look like the
following:

SAMPLE PANEL TO INPUT DATA LINE 00020

              NAME:

                             ADDR:


                                            PHONE:

Keying in data as before, the display will look like the
following:

SAMPLE PANEL TO INPUT DATA LINE 00020

              NAME: teesha smith

                             ADDR: red rose lane

                                            PHONE: 734-2178

Now, instead of hitting the ENTER key, I press program function
key 1 to indicate that I am through entering data.  The next
thing I will see is the READY prompt.  If I now list my data
set named X75826.TEST.DATA, it will appear as follows:

    NAME=T. SMITH, ADDR=306 BELL, NEENAH, PHONE=725-3484
    NAME=TEESHA SMITH, ADDR=RED ROSE LANE, PHONE=734-2178

As you can see, the data I entered on the full-screen display
got stored in records of data set X75826.TEST.DATA.  Now I will
go into detail as to how this was accomplished.

This first thing I had to do to set this process up was to define the
new full-screen display format.  To do this, I entered the following
ABE command:

  abe cntl(testpnl) pdf

You will notice the new keyword PDF.  This tells ABE that you don't
want to edit a normal data set, but instead you want to either define
A new full-screen display format or alter an existing one. The
referenced data set should be a member of a partitioned data set with
RECFM=FB or RECFM=VB and a maximum LRECL of 255.  My pds has
attributes LRECL=80,BLKSIZE=19040,RECFM=FB.  If the member doesn't
currently exist, ABE will blank out the screen in preparation for you
to enter the new panel definition.  The following is the appearance
of the screen after I finished entering the new definition:

 testing panel

             @name:&xxxxxxxxxxxxxxx@

                             addr:&xxxxxxxxxxxxxxxxxxxx@

                                            phone:&xxxxxxxxxxxx

@ characters on the display define protected, or literal, fields. The
program can write in these fields, but the terminal user can't write
in them.  Note the blank at the upper left hand corner of the panel,
just in front of the string "testing panel".  For technical reasons,
ABE puts this blank here, which you can't erase when defining your
panel.  You should assume this position contains an @ character.

You can put any characters in a literal field you want to, except
@ and &.  The & character is used to define unprotected, or input
fields.  I defined three of them on this panel.  Both the program
and the terminal user can write in these fields.  You will see how
this is done later.  After each & character, you should put enough
x characters to define the length of the input field.

When I hit ENTER after defining the new panel, ABE will store the
new definition in the specified library, and will return to
READY mode.

The next thing I did to implement this data entry example was to
define an RUN command list.  You will have read about this
subcommand of ABE earlier in this tutorial under the heading
"HEADIER STUFF:  FORMATTING JCL."  The command list appears as
follows:

  1 $UNTIL PFK^=0
  2   CALC LINE#LINE+10
  3   $SETO TESTPNL 1 'SAMPLE PANEL TO INPUT DATA LINE &LINE'
  4   $FULLSCR TESTPNL
  5   $CMD SET &LINE 'NAME=&F00003, ADDR=&F00005, PHONE=&F00007'

Line 1 of the RUN command list is a $UNTIL statement, which gives an
expression; the indented statements below the $UNTIL statement
statement will be repeatedly executed until the specified expression
proves true.  In this case, the test will be true as long as the
terminal user hit the ENTER key. PFK is one of two symbolic variables
that is always set whenever a panel is displayed via the $fullscr
statement.  It is set to 00000 if the ENTER key was used, 00001 if
program function key 1 was used, 00002 if program function key 2 was
used, etc.  The other symbolic variable, &CURSOR, will be set to the
location, relative 0, where the cursor was located when the terminal
user hit ENTER or one of the program function keys. Line 2 increments
symbolic variable LINE by 10.  Line 3 sets field #1 in panel TESTPNL
to the literal 'SAMPLE PANEL TO INPUT DATA LINE &LINE'.  You will
recall that TESTPNL is the name of the panel we just described the
definition of. Each field of a panel is numbered consecutively
starting with field number 1.  Each field of a panel also has a name
associated with it of the form Fddddd, where ddddd contains the number
of that field. you will see below that after the panel has been
displayed, any input values keyed in at the terminal can be accessed
by referencing the field name as a symbolic variable. Line 4 causes
the specified panel to be displayed at the terminal. Line 5 causes the
ABE subcommand SET to be issued to store any input from fields 3, 5,
and 7 in the next data line of the currently edited data set.

The final thing that needed to be done to implement this sample data
entry function was to build a TSO CLIST to allocate the necessary
files and invoke the ABE editor.  It looks as follows:

  1 ALLOC FI(SYSPNL) DA(CNTL) SHR REUSE
  2 ABE TEST.DATA NON HARDCOPY
  3 DELETE
  4 RUN TEST
  5 SE

You will recall that library CNTL contains the sample panel definition
TESTPNL.  ABE looks for this library to be allocated with the file
name SYSPNL.  Line 2 of the CLIST invokes the ABE editor, and the
HARDCOPY keyword tells ABE that it is being invoked from a CLIST.
lines 3 and 4 are ABE subcommands, the first of which deletes any
lines currently in the data set, and the second invoking the RUN
command list previously shown. When the RUN command list terminates
the SE subcommand will save the new data, and end the ABE editor.


WORDCNT - THE WORD COUNTING RUN                                        @

What follows is a description of a list of ABE subcommands invoked
via RUN to count all the words in a data set.  I recognize this
isn't something you need every day, but the function lets me show off
the power and flexibility of ABE.  A list of the WORDCNT command list
follows:

     COPY AAA
     A AAA C $ ' ' PICTURE
     A AAA SPLITB
     A AAA 8. CLEAR
     A AAA SORT 1 7 A
     A AAA COPY BBB
     A AAA SR 6
     A AAA 1.5 SUBSTR INCR
     A AAA RUN AAA
     A BBB DELDUP 1:7
     A BBB SUBSTR 1 COL OFF(9) LEN(7)
     A BBB SR 8
     A BBB 1.8 SUBSTR '$WRITE &&'
     RUN BBB
     A AAA END N
     A BBB END N

the data set we will be counting words in is as follows:

     E
     STILL ROUND THE CORNER THERE MAY WAIT,
     A NEW ROAD OR A SECRET GATE.
     AND THO I OFT HAVE PASSED THEM BY,
     A DAY WILL COME AT LAST WHEN I
     SHALL TAKE THE HIDDEN PATHS THAT RUN,
     WEST OF THE MOON, EAST OF THE SUN.

Following is a job deck that will produce the word counts on the
sysout from a batch job (This demonstrates that ABE can be used
effectively in batch without having to run it interactively under
TSO):

     /*IWT 5
     //X75826DT JOB (10-337-MISC-027-B4,1),
     //             'SMITH-TCC',CLASS=E,MSGCLASS=1,
     //             NOTIFY=X75826
     //         EXEC PGM=ABEB,REGION=3000K,TIME=(0,3)
     //SYSPRINT DD  SYSOUT=*
     //SYSRUN   DD  DSN=U.SD.U000.RUN,DISP=SHR
     //IN       DD  DSN=X75826.SAMPLE.TEXT,DISP=SHR
     //OUT      DD  DUMMY
     //SYSIN    DD  *
     RUN WORDCNT

the resulting word counts follow:

      00003       A
      00001     AND
      00001      AT
      00001      BY
      00001    COME
      00001  CORNER
      00001     DAY
      00001       E
      00001    EAST
      00001    GATE
      00001    HAVE
      00001  HIDDEN
      00002       I
      00001    LAST
      00001     MAY
      00001    MOON
      00001     NEW
      00002      OF
      00001     OFT
      00001      OR
      00001  PASSED
      00001   PATHS
      00001    ROAD
      00001   ROUND
      00001     RUN
      00001  SECRET
      00001   SHALL
      00001   STILL
      00001     SUN
      00001    TAKE
      00001    THAT
      00004     THE
      00001    THEM
      00001   THERE
      00001     THO
      00001    WAIT
      00001    WEST
      00001    WHEN
      00001    WILL

What follows is an explanation of each subcommand in the WORDCNT
command list.

     COPY AAA

The above subcommand tells ABE to copy all lines in the current data
set to a virtual data set with symbolic name AAA.  These lines will
contain the text "STILL ROUND THE CORNER ..." etc.

     A AAA C $ ' ' PICTURE

The above subcommand tells ABE to change all non-alphameric
characters in data set named AAA to blanks.  This will eliminate
all punctuation, such as commas, periods, etc.

     A AAA SPLITB

The above subcommand splits each word onto a separate line, left
justified.

     A AAA 8. CLEAR

All words are truncated to 7 characters - WORDCNT only gives
an accurate count if the first 7 characters in each word are unique.

     A AAA SORT 1 7 A

Now the words are sorted into ascending sequence.

     A AAA COPY BBB

A list of all the words is copied to a new virtual data set named
 BB.

     A AAA SR 6

In data set AAA, all lines are shifted right 6 positions.

     A AAA 1.5 SUBSTR INCR

Data set named AAA is transformed into a series of INCR subcommands,
e.g., INCR A, INCR ANY, INCR THE, etc.

     A AAA RUN AAA

Now the $INCR subcommands in data set AAA are executed to get the
word counts.

     A BBB DELDUP 1:7

The above subcommand reduces the lines in data set BBB so that each
line represents a unique word in the original data set.

     A BBB SUBSTR 1 COL OFF(9) LEN(7)

Each word in BBB is duplicated from column 1 in each line to
column 9

     A BBB SR 8

All lines in BBB are shifted right 8 positions.

     A BBB 1.8 SUBSTR '$WRITE &&'

Each line in BBB is transformed into a $WRITE subcommand of the
form "$WRITE &WORD WORD".

     RUN BBB

The above subcommand executes all the $WRITE subcommands in BBB
to be executed, causing the word counts to be listed on the
terminal (or in this case on sysout from a batch job).

     A AAA END N
     A BBB END N

The above two subcommands eliminate the two data sets AAA and BBB,
which were temporary anyway.

Note that the following set of subcommands will do the same thing as
WORDCNT

    COPY AAA
    A AAA C $ ' ' PICTURE
    A AAA SPLITB
    A AAA USE ×NAME $      ×
    A AAA ORDER BY NAME
    A AAA SELECT COUNT,NAME GROUP BY NAME TO RESULT

DATE CONVERSION                                                        @

Given a dataset containing julian dates such as the following -

     84328
     84359
     84366
     82228
     84097
     85001
     85147
     85185
     85186
     85245
     85332
     85333
     85357
     85358
     85359

When the following list of commands -

     use ×jul ××greg ×
     update set greg=juldate(jul)

will produce -

     ×JUL ××GREG ×
     84328 841123
     84359 841224
     84366 841231
     82228 820816
     84097 840406
     85001 850101
     85147 850527
     85185 850704
     85186 850705
     85245 850902
     85332 851128
     85333 851129
     85357 851223
     85358 851224
     85359 851225

SCHEDULING SYSTEM                                                      @

I have used the system described here for some time to automate the
scheduling of batch jobs.

There is a facility of JES2 which allows for a given command to be
scheduled for automatic execution at a specified time every day.  I
use this facility to schedule the execution of a job named AU109200,
the JCL for which is shown below.

    //AU109200 JOB 10-339-2320-PRO-A0,'T.SMITH',CLASS=C,MSGCLASS=9
    //IKJ      EXEC PGM=IKJEFT01,DYNAMNBR=30,REGION=4000K
    //SYSTSPRT DD  SYSOUT=*
    //SYSPRINT DD  SYSOUT=*
    //SYSRUN   DD  DSN=SYS2.CNTCARD,DISP=SHR MEMBER=U109200A
    //PDS      DD  DSN=X75826.SCHEDLIB,DISP=SHR
    //SCHEDDTE DD  DSN=X75826.SCHEDDTE,DISP=OLD
    //ML       DD  DSN=&ML,DISP=(NEW,PASS),
    //             UNIT=DISK,SPACE=(TRK,(10,10)),
    //             DCB=(LRECL=80,BLKSIZE=800,RECFM=FB)
    //SYSTSIN  DD  DSN=SYS2.CNTCARD(U109200B),DISP=SHR

Job AU109200 is submitted for execution automatically at 8:00 A.M.,
10:00 A.M., and every time the MVS/XA system is IPLed.  As you can
see, it executes the TSO Terminal Monitor Program in batch, using
commands in SYS2.CNTCARD(U109200B) as input.  SYS2.CNTCARD(U109200B)
contains the following:

    PROFILE PREFIX(X75826)
    GPDS 'X75826.SCHEDLIB' NOL OUTFI(ML)
    ABE '' INFI(ML) HARDCOPY NAME(ML)
    RUN U109200C
    END N

The GPDS command in line 2 will store in the sequential dataset
allocated under the ddname ML a list of all the member names in
partitioned dataset X75826.SCHEDLIB.  ABE is then invoked with
this list as input, and is told to execute the list of subcommands
in SYS2.CNTCARD(U109200C), which contains the following:

    CALC TODAY#DATE
    ABE '' INFI(SCHEDDTE) NAME(SCHEDDTE)
    A SCHEDDTE SETD CHECK * 1 6
    A SCHEDDTE DEL
    A SCHEDDTE NL &TODAY
    A SCHEDDTE SE
    $IF DATE^=CHECK
      A ML SNO ANCHOR TRIM RTAB(0) $ A = +
        'ABE ''X75826.SCHEDLIB(' A ')'' INP(/RUN U109200A/END N)'
      A ML RUN
    $ELSE
      $WRITE AU109200 ALREADY RUN THIS DATE, &CHECK

The above subcommand list checks to see if job AU109200 has already
run on today's date.  If so, the message "AU109200 ALREADY RUN
THIS DATE" will be printed, and processing is terminated.  Otherwise,
the list of member names is transformed into a set of subcommands
of the form -

    ABE 'X75826.SCHEDLIB(<member-name>)' INP(/RUN U109200A/END N)

Each of these subcommands is in turn executed, which causes the
list of subcommands in SYS2.CNTCARD(U109200A) to be executed for
each member in partitioned dataset X75826.SCHEDLIB.
SYS2.CNTCARD(U109200A) contains the following:

    F '//*SCHED ' ALL NAME(XXX)
    A XXX 73. CLEAR
    A XXX SL 9
    RUN XXX
    A XXX END N
    GETMEM MEM
    $IF RC^=0
      $WRITE &MEM WILL BE RUN TODAY
      JOB
    $ELSE
      $WRITE &MEM WILL NOT BE RUN TODAY

The function of subcommand list U109200A is to scan for a comment
JCL statement beginning with the sequence //*SCHED.  Every member
of X75826.SCHEDLIB must have such a comment statement in it,
and such a comment statement must have a special format.
An example, X75826.SCHEDLIB(AU109546), appears below:

    //AU109232 JOB  (10-339-SAS1-292-A0),PROD,CLASS=D,MSGCLASS=9
    //* RUN ON THE 2D WORKING DAY OF EACH MONTH
    //*SCHED CALC RC#WORKDOM(DATE)=2 && WORK(DATE)=1
    //S1 EXEC AU109232,TYPE=MONTH

As you can see above, the //*SCHED statement must contain an ABE CALC
subcommand which sets variable RC to zero or non-zero according to
whether the job is to execute or not.  If you refer in the ABE
Reference Manual to Appendix I, which documents the CALC subcommand,
you will find that: (1) DATE is a function which returns the current
date; (2) WORKDOM is a function accepting a date, and returning the
mumber of workdays spanned since the beginning of the month containing
that date; and (3) WORK is a function accepting a date, and returning
the number of workdays spanned since the beginning of the week
containing that date. Thus, the effect of the CALC subcommand is to set
RC non-zero if DATE is a working day, and it is the second working day
of the month.

SNO - GENERATING JCL                                                   @

Given the following display -

                10        20        30        40
       12345678901234567890123456789012345678901234567890

   %%fixjcl                               ×NAMES××50X80.1
   001 X75826.ABE.TEXT
   002 X75826.ABE.HELP
   003 X75826.ABE.APPENDIX.A.TEXT
   004 X75826.ABE.APPENDIX.B.TEXT
   005 X75826.ABE.APPENDIX.C.TEXT
   006 X75826.ABE.APPENDIX.D.TEXT
   ==>                                   ×FIXJCL××4X256.1
   001 SNOT '//IN' SEQ 10 ' DD ' 16 'DSN=' A ',DISP=SHR' +
   002  0 '//OUT' SEQ 10 ' DD ' 16 'DSN=&&OUT' SEQ +
   003    ',DISP=(NEW,PASS),UNIT=DISK,' +
   004  0 '//' 16 'SPACE=(CYL,(10,10),RLSE),DCB=*.CONTENT'

the result would be as follows -

                10        20        30        40
       12345678901234567890123456789012345678901234567890

   %%fixjcl                               ×NAMES××50X80.1
   001 //IN1     DD   DSN=X75826.ABE.TEXT,DISP=SHR
   002 //OUT1    DD   DSN=&OUT1,DISP=(NEW,PASS),UNIT=DISK,
   003 //             SPACE=(CYL,(10,10),RLSE),DCB=*.CONTENT
   004 //IN2     DD   DSN=X75826.ABE.HELP,DISP=SHR
   005 //OUT2    DD   DSN=&OUT2,DISP=(NEW,PASS),UNIT=DISK,
   006 //             SPACE=(CYL,(10,10),RLSE),DCB=*.CONTENT
   ==>                                   ×FIXJCL××4X256.1
   001 SNOT '//IN' SEQ 10 ' DD ' 16 'DSN=' A ',DISP=SHR' +
   002  0 '//OUT' SEQ 10 ' DD ' 16 'DSN=&&OUT' SEQ +
   003    ',DISP=(NEW,PASS),UNIT=DISK,' +
   004  0 '//' 16 'SPACE=(CYL,(10,10),RLSE),DCB=*.CONTENT'

PEEK - LOOKING AT MVS/XA Memory                                        @

     I've often thought the PEEK/POKE in interpretive BASIC on my PC
     would be useful on the mainframe. Poking about in memory from a
     TSO terminal on an MVS/XA system will dredge up all kinds of
     useful information.  For instance, the following sequence of
     commands will produce the ID of the cpu you're logged on to:

         test 'sys1.linklib(iefbr14)'
         l 10.%+c4%+10 c len(4)

     TEST is of course part of the standard command set on TSO, and
     among other things allows one to peek at memory. However I've
     never found any handy way in TEST of handling loops. Consider the
     task of listing the current linklist entries, describing which
     load libraries will be automatically scanned for programs:

       test 'sys1.linklib(iefbr14)'
       list 10.%+4dc%+9  c len(44)
       list 10.%+4dc%+36 c len(44)
       list 10.%+4dc%+63 c len(44)
       etc.

     Each subsequent LIST command produces the next dataset name in the
     linklist. The end is indicated when something other than a dsname
     is listed.  The following assembler code increments the offset
     into the list of dsnames and tests for end-of-list automatically:

     ASSEMBLER:
+    __________
            L   R2,X'10'      R2=A(CVT)
            L   R2,X'4DC'(R2) R2=A(LINKLIST)
            LA  R2,9(R2)      R2=A(FIRST DSNAME)
       LOOP BAL R3,PRINT      GO PRINT IT
            LA  R2,X'2D'(R2)  NEXT ENTRY, MAYBE
            CLI 0(R2),X'80'   END OF LIST?
            BO  LOOP          BR YES TO PRINT NEXT

     But I don't want to code an assembler program every time I go
     looking at a new control block chain. A more elegant solution
     might be the following PL/I program:

     PL/I
+    ____
       LNKLST: PROC OPTIONS(MAIN);
         DCL 1 DSNAME CHAR(44) BASED(D);
         DCL C FIXED BIN(31,0) BASED(ADDR(D));
         C=POINT(POINT(16)->C+1244)->C+9;
         DO UNTIL(UNSPEC(SUBSTR(DSNAME,1,1))='1'B);
           PUT SKIP DATA(DSNAME);
           C=C+45;
           END;
       POINT: PROC(C) RETURNS(PTR);
         DCL C FIXED BIN(31,0), D PTR BASED(ADDR(C));
         RETURN(D);
         END POINT;
         END LNKLST;

     Instead of compile/linkediting a program, however, unless response
     time must be short, I use an interpretive command language I
     designed and wrote.  It provides the tight addressing notation of
     the TEST command, and also loops. To list the linklist datasets
     requires the following:

       1 PEEK 10.%+4DC NUM 4 R3
       2 CALC R3#R3+9
       3 $UNTIL TST=128
       4   PEEK R3 CHAR 44 DSN
       5   $WRITE DSNAME=&DSN
       6   CALC R3#R3+45
       7   PEEK R3 NUM 1 TST

     The commands are created and may be executed directly from an
     editor under TSO, and can be saved in a partitioned dataset and
     executed simply by entering the member name preceded by two
     percent signs, e.g. %%LNKLST.

     The language contains the usual control structures IF-THEN-ELSE,
     DO-WHILE and DO-UNTIL, and the syntax is designed to let you be
     brief but readable. Indentation determines the extent of statement
     blocks, so END statements aren't necessary.  Also, the assignment
     operator (#) may appear anywhere in an expression, similar to the
     C language, often allowing you to write a single statement where
     several would be necessary in PL/I.

     Here's another example called DSPACE, which selects the one disk
     from a group of volumes which has the most available free
     cylinders on it.  The equivalent assembler program was 470
     statements:

       8 PEEK 10.%+434 NUM 4 UCBSCAN
       9 PARM WORKAREA LOW 100
      10 PARM DEVCLASS HEX 20000000
      11 PARM UCBADDR LOW 4
      12 PARM MSG78 LOW 30
      13 PARM SVC78 HEX 58F010005800F00058101004411010001BFF0A4E07FE
      14 CALC AVL#0
      15 $WHILE 0=ENTRY(UCBSCAN,WORKAREA,DEVCLASS,UCBADDR)
      16   PEEK UCBADDR%+3 N 1 UCBSTAT
      17   $IF 128=(UCBSTAT&&128) && 0=(UCBSTAT&&64)
      18     $* DEVICE IS ONLINE(128) AND NOT BEING VARIED OFFLINE(64)
      19     PEEK UCBADDR%+1C CHAR 6 VOLSER
      20     $IF LENGTH(P1)=0 × INDEX(VOLSER,P1)=1
      21       $IF 0=RET78#ENTRY(SVC78,UCBADDR,MSG78)
      22         PEEK MSG78+6 C 4 CYLS
      23         $IF OLDAVL^=AVL#MAX(CYLS,OLDAVL#AVL)
      24           SETL MAXSER &VOLSER
      25       $ELSE
      26         $WRITE NONZERO RETURN FROM SVC 78 = &RET78
      27         $GOTO EOJ
      28 $IF AVL=0
      29   $WRITE NO SPACE AVAILABLE
      30 $ELSE
      31   $WRITE MAXIMUM FREE CYLINDERS = &AVL ON VOLSER = &MAXSER

     Symbolic variables may have both a real number and a character
     string value associated with them.  "R3#R3+45" causes the real
     number value associated with symbolic variable R3 to be
     incremented by 45. Line 19 above assigns the 6-byte character
     string at the address pointed to by UCBADDR plus hexadecimal 1C to
     VOLSER.

     The character string associated with a symbolic variable replaces
     it anywhere it appears preceded by an ampersand (&), as in line
     31. If only a real number has been assigned, then its character
     representation is used, as in &AVL on line 31.  And of course, if
     the character string "123.45" has been assigned to variable X via
     e.g. the SETL statement, then "CALC A#X**2" will cause character
     to real number conversion, and 15239.9025 will be assigned to A.

     Normally, as already indicated, if both the character string and
     real number associated with a given symbolic variable are valid,
     the character string is simply the printable representation of the
     real number.  But the PARM statement assigns a value to the
     character string, and the address of the character string to the
     real number.  This is handy for establishing arguments to the
     ENTRY function as in lines 15 and 21, where respectively the
     operating system UCB scan routine, and the machine language
     instructions defined on line 13, are invoked.

     In a few cases I've written routines to access control blocks not
     normally in memory.  The following, which displays information
     about a dataset similar to the TSO LISTDS command, illustrates
     access to the JFCB (Job File Control Block) and DSCB (Data Set
     Control Block):

      32 $IF Q1
      33   XT 'ALLOC FI(IN) DA(''&P1'') SHR REUSE'
      34 $ELSE
      35   XT 'ALLOC FI(IN) DA(&P1) SHR REUSE'
      36 JFCB IN
      37 XT 'FREE FI(IN)'
      38 PEEK IN C 44 DSNAME
      39 PEEK IN+76 C 6 VOLSER
      40 DSCB &DSNAME &VOLSER DSCB1
      41 DSCB 4 &VOLSER DSCB4
      42 PEEK DSCB4+14 N 2 DS4DEVTC
      43 PEEK DSCB1-2C+3B N 1 NOEPV
      44 CALC EXTPTR#DSCB1-X'2C'+X'69'
      45 CALC I#TRKS#0
      46 $WHILE MIN(3,NOEPV)>=I#I+1
      47   CALC STRT#PEEK(EXTPTR+2,2)*DS4DEVTC+PEEK(EXTPTR+4,2)
      48   CALC STOP#PEEK(EXTPTR+6,2)*DS4DEVTC+PEEK(EXTPTR+8,2)
      49   CALC TRKS#TRKS+STOP-STRT+1
      50   CALC EXTPTR#EXTPTR+X'A'
      51 $IF NOEPV>3
      52   PEEK EXTPTR C 5 DS1PTRDS
      53   DSCB 3 &VOLSER DSCB3 DS1PTRDS
      54   CALC EXTPTR#DSCB3+4
      55   $UNTIL NOEPV<I#I+1
      56     $IF I=8
      57       CALC EXTPTR#EXTPTR+1
      58     CALC STRT#PEEK(EXTPTR+2,2)*DS4DEVTC+PEEK(EXTPTR+4,2)
      59     CALC STOP#PEEK(EXTPTR+6,2)*DS4DEVTC+PEEK(EXTPTR+8,2)
      60     CALC TRKS#TRKS+STOP-STRT+1
      61 PEEK DSCB1-2C+58 N 2 LRECL
      62 PEEK DSCB1-2C+56 N 2 BLKSIZE
      63 PEEK DSCB1-2C+54 N 1 DS1RECFM
      64 PEEK DSCB1-2C+52 N 1 DS1DSORG
      65 SETL R1 ?VFU
      66 SETL R1 &SUBSTR(R1,&SYSEVAL(1+MIN(3,
      67   MAX(0,INT(DS1RECFM/64)))),1)
      68 SETL R2 B
      69 SETL R2 &SUBSTR(R2,1,&SYSEVAL(16&&DS1RECFM))
      70 SETL R3 S
      71 SETL R3 &SUBSTR(R3,1,&SYSEVAL(8&&DS1RECFM))
      72 SETL R4 ' MA'
      73 SETL R4 &SUBSTR(R4,&SYSEVAL(1+(6&&DS1RECFM)/2),1)
      74 $SELECT
      75   $WHEN 128 && DS1DSORG
      76     SETL DSORG PO
      77   $WHEN  64 && DS1DSORG
      78     SETL DSORG PS
      79   $WHEN  32 && DS1DSORG
      80     SETL DSORG DA
      81   $WHEN  02 && DS1DSORG
      82     SETL DSORG PO
      83   $OTHERWISE
      84     SETL DSORG ?
      85 $IF 1 && DS1DSORG
      86   SETL DSORG &DSORG.U
      87 $WRITE DSNAME=&DSNAME
      88 $WRITE   LRECL=&LRECL BLKSIZE=&BLKSIZE
      89 $WRITE   RECFM=&R1&R2&R3&R4 DSORG=&DSORG
      90 $WRITE   VOL=&VOLSER, EXTENTS = &NOEPV,
      91 $WRITE   TRACKS ALLOCATED = &TRKS


     Other examples are -

     List the current MVS Version number:
       PEEK 10.%-4

     List your current TSO region size:
       PEEK 220.%+30%+CC N 4 SIZE
       MSG TSO SIZE=&SYSEVAL(SIZE/1024)

     List information related to your TSO session:
       PEEK 10.%%+4%+C% CHAR 6 UID
       PEEK 10.%%+4%+B4%+104%+37%+18 CHAR 20 NAME
       PEEK 10.%%+4%+B4%+104%+37%+31 CHAR 11 ACCT
       MSG USERID="&UID" NAME="&NAME" TSO ACCT.="&ACCT"

     List the first SMF dataset currently in use.
       PEEK 10.%+C4%+F0+C%+10 C 10

