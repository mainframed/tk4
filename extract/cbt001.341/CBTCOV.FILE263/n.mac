.he ABE, T. Smith, Appendix N

Appendix N - PLOT79 GRAPHICS SUPPORT.                                  @









                       A B E  E d i t o r


                         T .  S m i t h

                       A P P E N D I X  N

           P L O T 7 9   G R A P H I C S    S U P P O R T

.np

This appendix documents the support of graphics under ABE.

  1.  ABE maintains internally a pixel map, and provides interfaces so
      you can set, reset, and interrogate pixels during the process of
      creating a drawing.

  2.  ABE has interfaces to several print devices so you can print
      a given pixel map.  Supported devices are:

      a.  C.ITOH.  Two different C.ITOH printers are supported;
          the CI600 and the CI3500 models.  In the case of the
          CI600, the printer must be manually set to 13 characters
          per inch, and in the case of the CI3500, the setting
          must be 12 characters per inch.  In any syntax
          descriptions in this appendix, when you see the item
          <TYPE>, you may replace it with either "CI600" or
          "CI3500" depending on the actual output device.

      b.  PRINTRONIX.

      c.  IBM 3800.

  3.  ABE supplies an interface to the PLOT79 graphics package.  This
      is a "large software system written in Portable FORTRAN ....
      which is designed to allow computer production of line drawings,
      contour plots, and hidden-line mesh plots of user data."

  4.  ABE will interface to SAS/GRAPH (trademark), and will allow you
      to place multiple output graphs from SAS on the same page of
      printed output, or drawing.

  5.  ABE provides for editing the pixel map directly at the terminal
      in full-screen mode.  You can turn pixels on and off directly
      by moving the cursor to the appropriate location on the screen
      and keying in zeros or ones.

A SIMPLE DRAWING - PRINTING A BOX                                      @

When creating drawings with PLOT79 in 2 dimensions, it is useful to
think that you are working with an imaginary flatbed plotter.
subcommands of the form "GR MOVn2 x y" will move the pen to the
designated (x,y) coordinates on the drawing with the pen raised so that
no line is drawn. Subcommands of the form "GR LINn2 x y" move the pen
from its current location to the designated (x,y) coordinates with the
pen lowered so that a line is drawn on the paper.

The "n" in these two formats may be either "A" or "R" designating
absolute or relative pen movement, respectively, in world coordinates.
the following sequence of subcommands -

  GR79
  GR PLT00
  GR SETSZ 17.78
  GR MOVA2 0 0
  GR LINR2 0 1
  GR LINR2 1 0
  GR LINR2 0 -1
  GR LINR2 -1 0
  GPR TCD1

would draw a line on the border of the drawing, and then would print
the drawing on the C.ITOH printer at destination TCD1.  If the printer
were properly set to 13 cpi, a 17.78-centimeter by 17.78-centimeter
box (7-inch by 7-inch) would be printed.

All of the subroutines PLT00, SETSZ, MOVA2, and LINR2 used above are
part of the PLOT79 graphics package, and are documented in the PLOT79
User's Manual.  All of the PLOT79 routines, about 500, listed below,
are available through the GR subcommand of ABE.

GR79 SUBCOMMAND                                                        @

Note that the first subcommand used above in drawing the box was a GR79
subcommand.  If GR79 were not specified, only a limited number of
PLOT79 subroutines would subsequently be accessible.  You will see
a list below.  The abbreviated list is sufficient for using such
subcommands as GSAS and GED, which are documented later on in this
appendix, and considerable main storage is saved.  But if PLOT79
subroutines other that those listed below are required, then the
GR79 subcommand must have been issued at least once during the
current ABE invocation before any of the following subcommands are
used.

  GR, GED, GPR, MOVEP, DR, NEWPEN, TEXT, LINEWT, GSAS, GSASR, PD,
  PU, GFILL, IMGET, IMPUT, IMGETB, or IMPUTB

LIST OF SUPPORTED PLOT79 SUBROUTINES WHEN GR79 IS NOT USED             @

     CLPL3, CLPL4, ERRAR, ERRAT, ERRCK, ERRIN, ERRMS, ERRTR, LINA3,
     MATMM, MATPM, MATTV, MATUN, MOVA3, PLTCL, PLTDL, PLTIO, PLTLS,
     PLTML, PLT00, SETSZ, SETTR, SET00, SYMSF, SYMSS, SYM00, UTITTY,
     UTRXP

LIST OF SUPPORTED PLOT79 SUBROUTINES WHEN GR79 IS USED                 @

    ABSFA  ABSMA  ABSNP  ABSRC  ABSSL  ABSWC  ABSWI  ABSWT  ACOS
    ASIN   CARG   CLPL2  CLPL3  CLPL4  CLPPG2 CLPPG3 CLPPH
    CLPPI  CLPP2  CLPP3  CLPP4  CLPTR  CLP2D  CLP3D  CONCA  CONCB
    CONCC  CONCL  CONCP  CONGV  CONIT  CONNC  CONOR  CONRE  CONSA
    CONSC  CONSC3 CONSK  CONSK3 CONSU  CONSX  CONSY  CONXC  CONXS
    CONXV  CONYC  CONYS  COSD   COSH   DCOSH  DEFCS  DEFPR  DEFRP3
    DEFTR  DEFUP3 DEFVD  DEFVN  DEF00  DEMLA  DFLOAT DSINH  ERRAI
    ERRAL  ERRAR  ERRAS  ERRAT  ERRCB  ERRCK  ERRCR  ERRES  ERRIN
    ERRMS  ERRTR  FILBX  FILPA2 FILPA3 FILPI  FILXA2 FILXA3 FITAP
    FITBS2 FITBS3 FITBV  FITBZ2 FITBZ3 FITCF  FITCS  FITC1  FITC2
    FITDIN FITDS  FITDSM FITD2  FITIN  FITK1  FITK2  FITPB2 FITPB3
    FITP1  FITP2  FITSF  FITSM  FITTAP FITTC1 FITTC2 FITTDE FITTDO
    FITTEV FITTFT FITTGR FITTIN FITTOP FITTPR FITTSF FITTSR FITTSS
    FITTSV FITTTR FITVBV FITVCL FITVGR FITVLC FITVPD FITVPT FITVSF
    FITVTA FITVXC GRFAC  GRFAV  GRFAX3 GRFCI  GRFCX  GRFEB  GRFFI
    GRFGA  GRFGD  GRFGG  GRFGG3 GRFGI  GRFGP  GRFHP  GRFIG  GRFPI
    GRFRG  GRFSM  GRFTG  GRFUN  GRFUR  HIDAX  HIDBV  HIDCS  HIDCV
    HIDDO  HIDDOS HIDEV  HIDGV  HIDGVS HIDGV2 HIDHV  HIDIV  HIDIVS
    HIDNE  HIDNES HIDNW  HIDNWS HIDOV  HIDPV  HIDRV  HIDRVS HIDSE
    HIDSES HIDSK  HIDSV  HIDSW  HIDSWS HIDTR  HIDTRS HIDTV  HIDWV
    HLPTX  HZNBO  HZNCV  HZNGV  HZNIL  HZNNH  HZNSK  INQBC  INQBUG
    INQBXV INQCC  INQCI  INQCM  INQCO  INQCP2 INQCP3 INQCP4 INQCS
    INQDP  INQDS2 INQDS3 INQFC  INQIT  INQLI  INQLS  INQLW  INQMS
    INQMSZ INQPA  INQPCI INQPES INQPFI INQPIS INQPN  INQPPA INQPPO
    INQPR  INQPVI INQRP2 INQRP3 INQSS  INQSZ  INQTFN INQTJU INQTPA
    INQTPD INQTR  INQTRT INQTSS INQTSZ INQTUP INQUP2 INQUP3 INQVC
    INQVD  INQVN  INQVP2 INQVP3 INQWC  INQWM  INQWW  INQ3D  IOPCLS
    IOPINI IOPOPF IOPOPN IOPPOP IOPPSH ISAMAX LINA2  LINA3  LINA4
    LINR2  LINR3  LINR4  MATEU  MATGT  MATIN  MATMM  MATPM  MATPX
    MATPY  MATPZ  MATRA  MATRF  MATRS  MATRX  MATRY  MATRZ  MATSC
    MATSH  MATTR  MATTV  MATUN  MOVA2  MOVA3  MOVA4  MOVR2  MOVR3
    MOVR4  MRKA2  MRKA3  MRKA4  MRKR2  MRKR3  MRKR4  NINT   PGNA2
    PGNA3  PGNR2  PGNR3  PLNA2  PLNA3  PLNA4  PLNR2  PLNR3  PLNR4
    PLTAL  PLTAM  PLTAX  PLTAX3 PLTBO  PLTBX  PLTBX3 PLTCL  PLTDL
    PLTEJ  PLTEU  PLTFM  PLTFR  PLTFV  PLTHB  PLTHF  PLTID  PLTIL
    PLTIO  PLTLAB PLTLAH PLTLAQ PLTLL  PLTLS  PLTLVP PLTLX  PLTMA
    PLTME  PLTML  PLTQB  PLTQF  PLTRM  PLTSQ  PLTVB  PLTVF  PLTVPH
    PLTVPV PLTVS  PLT00  PL2CA  PL2EL  PL2MC  PL2PO  PL2SP  PL2TP
    PL2TR  PL3CA  PL3CY  PL3EL  PL3SP  PMKA2  PMKA3  PMKA4  PMKR2
    PMKR3  PMKR4  PVIDS  PVIIS  PVIIV  PVISE  PVISW  PVITS  PVITV
    SAXPY  SDOT   SETBC  SETBUG SETCI  SETCM  SETCO  SETCS  SETDP
    SETDS2 SETDS3 SETEJ  SETFC  SETIT  SETLI  SETLS  SETLW  SETMS
    SETMSZ SETNF  SETPA  SETPCI SETPES SETPFI SETPIS SETPN  SETPPA
    SETPPO SETPR  SETPVI SETRP2 SETRP3 SETSZ  SETTR  SETUP2 SETUP3
    SETVD  SETVN  SETVP2 SETVP3 SETWC  SETWM  SETWW  SET00  SET3D
    SGEDI  SGEFA  SGESL  SIND   SINH   SSCAL  SSWAP  SYMCG  SYMCG3
    SYMCK  SYMCS  SYMDS  SYMEX  SYMEX3 SYMJU  SYMMK  SYMMK2 SYMMK3
    SYMNF  SYMPA  SYMPD  SYMRS  SYMRT  SYMSF  SYMSP  SYMSS  SYMSZ
    SYMTX  SYMTXB SYMTX3 SYMUP  SYMUPK SYMXD  SYM00  SYSDEF UTDRAN
    UTICA  UTICF  UTICI  UTICR  UTIDA  UTIDF  UTIDI  UTIDL  UTIDR
    UTIDT  UTIFA  UTISL  UTITI  UTITTY UTLFA  UTRBA  UTRCA  UTRCO
    UTREPS UTRE2  UTRE3  UTRFA  UTRIV  UTRLS  UTRMA  UTRP10 UTRP2
    UTRRD  UTRSA  UTRSB  UTRSC  UTRS1  UTRS2  UTRS3  UTRXP  UTTCK
    UTTDA  UTTIK  UTTSL  UTTTI  VISBO  VISCB  VISCH  VISDC  VISDO
    VISES  VISGV  VISGV2 VISHH  VISHO  VISHS  VISII  VISIS  VISLI
    VISLI2 VISNH  VISNP  VISOS  VISPS  VISRB  VISSB  VISSL  VISSP
    VISSS  VISTR  VISTS  VISTW  VISWS

GR SUBCOMMAND                                                          @

The general format for the GR subcommand is as follows:

    GR <NAME> <OPERANDS>

where -

  <NAME> is the name of the PLOT79 subroutine to be invoked.
  <OPERANDS> consists of zero or more operands to be passed to
    the specified subroutine as arguments documented in the PLOT79
    User's Manual.  An operand may be any of the following:

    1.  NUMERIC CONSTANT, e.g. 123.45.

    2.  CHARACTER LITERALS, e.g. 'How now brown cow', or any string of
        text surrounded by apostrophes.

    3.  VARIABLE NAMES, e.g. xarray, where the APL subcommand
        "apl xarray#1 4`B.5+.5X2O(O2)X(Ipoints)%points" had previously
        been issued.  More discussion of this kind of argument will
        be seen below under the heading "PASSING ARRAYS TO PLOT79
        SUBROUTINES."

        For another example, consider the following string of commands
        in which a string of text ("Do ants sleep?") is passed to
        PLOT79 subroutine SYMTX:

        define xxx
        a xxx nl Do ants sleep?
        gr symtx xxx 1 14

        ***NOTE*** There are two important exceptions to this rule.
        The first is variable name UG01, which will  always refer to a
        4-by-4 REAL matrix in FORTRAN common.  See also documentation
        on the SETUG01 subroutine described later in this appendix.

        The second exception is variable name BITMAP, which always
        refers to the internal pixel map maintained and manipulated
        using the GR subcommand.

    4.  ENTRY NAMES, e.g. pl2ca.  Many of the PLOT79 subroutines
        expect one or more arguments to be entry points to
        other PLOT79 subroutines.  In such cases, just specify the
        name of the desired subroutine in that argument position.
        the GR subcommand knows which arguments must be entry
        points, and so will be able to differentiate entry point
        names from variables names, which were already described
        above.

    5.  SYMBOLIC NAMES preceded by an &ampersand.  The replacement
        value currently associated with the specified symbolic name
        will be passed to the specified PLOT79 subroutine, e.g.:

        calc x#a+23
        gr mova2 &id 0

    6.  SYMBOLIC NAMES preceded by a percent sign.  The specified
        symbolic name will be assigned a replacement value according
        to whatever is returned by the PLOT79 subroutine being
        invoked, e.g.:

        gr inqbc %clipon
        symc clipon

        When these subcommands are completed, symbolic variables CLIPON
        will contain a value assigned by the PLOT79 subroutine INQBC.
        In this case, CLIPON would contain 1 if back plane clipping is
        enabled, and 0 otherwise.


STARTING A NEW DRAWING - PLT00                                         @

Whenever you want to start a new drawing, you should first enter the
subcommand GR PLT00. PLT00 is a PLOT79 subroutine which initializes the
PLOT79 environment (see PLOT79 User's Manual).  Among other things, it
turns off all the pixels in the internal pixel map (e.g. sets the pixel
map to hex zeros).

Also initialized when you issue the GR PLT00 subcommand are three
coordinate systems: (1) World coordinates; (2) Window coordinates; and
(3) Normalized Device Coordinates (NDC for short).  The PLOT79 User's
manual gives a detailed description of these coordinate systems and how
they relate to one another.  By default, PLT00 initializes all three
coordinate systems so they match, so at least initially, you don't need
to worry about it.  You can just consider that after you invoke PLT00,
you will have access to a clean 2-dimensional plane of pixels, any
pixel of which can be addressed by a set of 2 numbers, each ranging
from 0 to 1.

PIXELS                                                                 @

A pixel is the smallest addressible unit of a drawing.  On a black and
white printer such as the C.ITOH, when a drawing is printed, each
pixel is represented by the presence or absence of a dot of ink.
pixel densities on various graphics devices range from 60 by 72
per square inch on the C.ITOH to 240 by 240 per square inch on the
IBM 3800.

GR DEVICE SUBCOMMAND - ESTABLISHING PIXEL MAP DEFINITION               @

810,000 bytes are reserved internally in ABE for the pixel map.
through use of the GR DEVICE subcommand, you can establish how the
matrix of pixels representing a drawing are to be layed over this
810,000 bytes.  Format for the GR DEVICE subcommand is as follows:

  GR DEVICE <PLXDPI> <PLYDPI> <PLMAXX> <PLMAXY> <ELSIZE>

where -

  <PLXDPI> is the number of pixels per inch horizontally (along the
    x axis) on the device to which the final drawing is to be sent.
  <PLYDPI> is the number of pixels per inch vertically (along the
    y axis) on the device to which the final drawing is to be sent.
  <PLMAXX> is the maximum number of pixels horizontally in the final
    drawing.
  <PLMAXY> is the maximum number of pixels vertically in the final
    drawing.
  <ELSIZE> is the number of bits to be used in representing each
    pixel.  <PLMAXX>*<PLMAXY)*<ELSIZE>/8 cannot exceed 810,000.

If you don't issue the GR DEVICE subcommand before starting a drawing,
the defaults are:

  <PLXDPI> - 80
  <PLYDPI> - 72
  <PLMAXX> - 792
  <PLMAXY> - 504
  <ELSIZE> - 8

these settings are suitable for printing on the C.ITOH printer in low
density plot mode, with the printer set to 13 characters per inch.

NOTE that invoking the GR DEVICE subcommand reinitializes the bit map
and invokes PLT00.

IBM3800 AND THE GR DEVICE SUBCOMMAND                                   @

If you expect your output to be printed on the IBM 3800 printer, you
should use the GR DEVICE subcommand with the following values and
restrictions:

  <PLXDPI> - 240
  <PLYDPI> - 240
  <PLMAXX> - Must be divisible by 32, and the maximum value you
             should specify is 2624.
  <PLMAXY> - Must be divisible by 32.  A good value is 1696.
  <ELSIZE> - 1 - If you don't specify 1, the GPR subcommand, which
             is used to produce the print data stream, will
             terminate with an error message and a return code of
             16 without generating the data stream.

SETSZ SUBROUTINE - SETTING PHYSICAL DIMENSIONS OF THE DRAWING          @

In the example above where a 17.78-centimeter square (7 inches) was
drawn and printed, the SETSZ subroutine was invoked to establish the
physical dimensions of the drawing.  If "GR SETSZ 10.16" had been
issued instead, the square would have measured 10.16 centimeters on a
wide (4 inches). But suppose "GR SETSZ 27.94" had been issued. From the
description so far, you would expect a square 27.94 centimeters on a
wide. What would actually print would be a rectangle 25.145996
centimeters wide by 17.78 centimeters high.  These are the maximum
physical dimensions of a drawing to be printed on the C.ITOH printer
set at 13 cpi.

The SETSZ subroutine establishes scaling factors for the X and Y axes
of the drawing which are applied when the drawing is printed to give
you the requested physical dimensions, except when you exceed the
capacity of the printer, which is 25.145996 by 17.78 centimeters.  If
you exceed the capacity the scaling factors for each axis are
separately adjusted to the maximum allowable by the printer.  This
distorts the picture, making things wider and shorter than they ought
to be.

INQCP2, INQCP3, INQCP4 - WHERE IS THE PEN CURRENTLY?                   @

In the sample drawing in 2 dimensions shown above, an imaginary pen
has moved about the paper using MOVe and LINe type subcommands.  To
find out where the pen is currently, subroutines INQCP2, INQCP3, and
INQCP4 can be used according to whether you are working in 2, 3, or
4 dimensions.  The following sequence of subcommands -

  apl x#y#1 4`B0
  gr79
  gr inqcp2 x y
  apl result#10 5Fx,y

would produce a dataset named RESULT containing the text record -

   0.00000   0.00000

If the following sequence of subcommands were then issued -

  gr mova2 .43785 .0012
  gr inqcp2 x y
  apl result#10 5Fx,y

dataset RESULT would then contain -

   0.43785   0.00120

PASSING ARRAYS TO PLOT79 SUBROUTINES                                   @

A number of subroutines documented in the PLOT79 User's Manual accept
arrays as arguments.  An example is PLNA2, documented under the heading
"Polyline Absolute" in the PLOT79 User's Manual.  It accepts 5
arguments, the first and fourth of which are 2-dimensional arrays
containing the (x,y) coordinates of a series of points which are to be
connected by a line.

The APL subcommand of ABE is often an effective way of producing arrays
to be passed to PLOT79 subroutines.  When using the APL subcommand, the
`B operator must be used to produce the required base and precision.
For example, if the RUN subcommand were issued for a data set
containing the following sequence of ABE subcommands, the result would
be a drawing containing a circle 7 inches in diameter printed at TCD1:

     calc points#32
     apl points#&POINTS
     gr79
     gr plt00
     gr setsz 17.78
     gr mova2 1 .5
     apl xarray#1 4`B.5+.5X2O(O2)X(Ipoints)%points
     apl yarray#1 4`B.5+.5X1O(O2)X(Ipoints)%points
     gr plna2 xarray 1 yarray 1 &POINTS
     gpr tcd1

Consider what would be printed if the RUN subcommand were issued for
the following sequence of subcommands:

     calc points#630
     apl points#&POINTS
     apl theta#(O2)X(Ipoints)%points
     apl r#2O6Xtheta
     apl xarray#1 4`B.5+.5XrX2Otheta
     apl yarray#1 4`B.5+.5XrX1Otheta
     gr79
     gr plt00
     gr setsz 17.78
     gr mova2 1 .5
     gr plna2 xarray 1 yarray 1 &POINTS

PRINTING TEXT ON DRAWINGS - SYMTX                                      @

Of the RUN subcommand were entered for a data set containing the
following ABE subcommands, for example, a sample of all the Hershey
fonts would be produced on a new drawing:

    $CONTROL LIST
    GR79
    GR PLT00
    GR SYMSZ 1 .03
    GR MOVA2 .0 .00
    GR SYMSF 'UCKR1' '='
    GR SYMTX 'CARTOGRAPHIC ROMAN' 1 18
    GR MOVA2 .0 .05
    GR SYMSF 'UCKG1' '='
    GR SYMTX 'CARTOGRAPHIC GREEK' 1 18
    GR MOVA2 .0 .10
    GR SYMSF 'UCIR1' '='
    GR SYMTX 'COMPLEX INDEXICAL ROMAN' 1 23
    GR MOVA2 .0 .15
    GR SYMSF 'UCII1' '='
    GR SYMTX 'COMPLEX INDEXICAL ROMAN ITALIC' 1 30
    GR MOVA2 .0 .20
    GR SYMSF 'UCIG1' '='
    GR SYMTX 'COMPLEX INDEXICAL GREEK' 1 23
    GR MOVA2 .0 .25
    GR SYMSF 'UCSR1' '='
    GR SYMTX 'SIMPLEX ROMAN' 1 13
    GR MOVA2 .0 .30
    GR SYMSF 'UCSS1' '='
    GR SYMTX 'SIMPLEX ROMAN SCRIPT' 1 20
    GR MOVA2 .0 .35
    GR SYMSF 'UCSG1' '='
    GR SYMTX 'SIMPLEX GREEK' 1 13
    GR MOVA2 .0 .40
    GR SYMSF 'UCCR1' '='
    GR SYMTX 'COMPLEX NORMAL ROMAN' 1 20
    GR MOVA2 .0 .45
    GR SYMSF 'UCCI1' '='
    GR SYMTX 'COMPLEX NORMAL ROMAN ITALIC' 1 27
    GR MOVA2 .0 .50
    GR SYMSF 'UCCG1' '='
    GR SYMTX 'COMPLEX NORMAL GREEK' 1 20
    GR MOVA2 .0 .55
    GR SYMSF 'UCCS1' '='
    GR SYMTX 'COMPLEX ROMAN SCRIPT' 1 20
    GR MOVA2 .0 .60
    GR SYMSF 'UCDR1' '='
    GR SYMTX 'DUPLEX ROMAN' 1 12
    GR MOVA2 .0 .65
    GR SYMSF 'UCTR1' '='
    GR SYMTX 'TRIPLEX ROMAN' 1 13
    GR MOVA2 .0 .70
    GR SYMSF 'UCGE1' '='
    GR SYMTX 'GOTHIC ENGLISH' 1 14
    GR MOVA2 .0 .75
    GR SYMSF 'UCGI1' '='
    GR SYMTX 'GOTHIC ITALIAN' 1 14
    GR MOVA2 .0 .80
    GR SYMSF 'UCGG1' '='
    GR SYMTX 'GOTHIC GERMAN' 1 13
    GR MOVA2 .0 .85
    GR SYMSF 'UCGG1' '='
    GR SYMTX 'COMPLEX CYRILLIC' 1 16

SETUG01, PL2SPA, PL3SPA, SYMTB3 - NON-STANDARD SUBROUTINES             @

When going through the sample library supplied with the PLOT79
package, several useful subroutines were encountered which are not
documented in the PLOT79 User's Manual:

PL2SPA applies the transformation matrix UG01 in COMMON to (U,V)
arguments before passing them to PL2PO.  PL3SPA does the same for
3-dimensional arguments (U,V,W). PL2SPA and PL3SPA both refer to a 4X4
matrix of single precision real numbers in FORTRAN COMMON called UG01.
SETUG01 may be called to set the values in variable UG01 in COMMON.
Call format for SETUG01 is as follows:

  GR SETUG01 <MATIN>

  <MATIN> is the name of an apl variable, which must be a vector or
  array of 16 elements (normally a 4X4 array) of single precision
  floating point (4 bytes per element).  The GR subcommand will
  copy the contents of this apl variable into the UG01 matrix in
  FORTRAN COMMON.

SYMTB3 can be invoked to generate boldface letters by repeatedly
redrawing a text string, moving the origin about the circumference of
a small circle whose diameter is that of the simulated thick pen.
Call format for SYMTB3 is as follows:

  GR SYMTB3 <TEXT> <LOC> <PL3> <H> <PENDIA>

  <TEXT> is of course the text to be printed.
  <LOC> is the offset within <TEXT> to the first character to be
    printed.
  <PL3> is the name of a transformation routine, usually PL3SPA.
  <H> is the height of the characters to be printed.
  <PENDIA> is the thickness of the simulated pen.

The following sequence of subcommands would produce a drawing
containing the name "Thomas Glen Smith" written on the surface of a
sphere on which a matrix of latitude and longitude lines are also
written:

 R79
 R PLT00
 R MATEU UG01 0 25 0
 R SET3D 1
 R SETDS3 .772727 1 1
 R SETVP3 0 .772727 0 1 0 1
 R SETWW 0 1 0 1
 R PLTBX
 R SETVP2 .022727 .75 .136364 .863636
 R GRFCI 0.5 0.5 0.5 PL2CA
 R SETLS 7232
 R GRFCX 11 0 PL2SPA
 R SETLS 1
 R SYMUP 0 -1 0
 R SYMJU 'CENTER' 'CENTER'
 R SYMSF 'UCTR1' 0
 R SYMSZ 1 .04
 R PL3SPA .75 .45 1 0
 R SYMTB3 '<T>HOMAS' 1 8 PL3SPA .04 .0006
 R PL3SPA .75 .55 1 0
 R SYMTB3 '<G>LEN' 1 6 PL3SPA .03 .0006
 R PL3SPA .75 .65 1 0
 R SYMTB3 '<S>MITH' 1 7 PL3SPA .05 .0006

PASSING ENTRIES TO PLOT79 SUBROUTINES                                  @

A number of PLOT79 subroutines expect the entry point to another
subroutine as an argument.  In the previous sample, where text is being
printed on the surface of a sphere, the line -

    GR SYMTB3 '<T>HOMAS' 1 PL3SPA .04 .0006

has such an entry point specified as the fourth argument ("PL3SPA").
Generally, any of the PLOT79 subroutine names are acceptable
when specified as entry point names.  The GR subcommand will search
a table of possible PLOT79 subroutine names for a match to the one
you specify, and if a match is not found, an error message will be
issued.

GSAS SUBCOMMAND - INVOKING SAS/GRAPH                                   @

Use the GSAS subcommand to invoke SAS/GRAPH and have the resulting
graphics output stored in the internal pixel map.  This subcommand
Should be entered on the subcommand line for the currently edited
dataset containing the SAS source statements necessary to invoke
SAS/GRAPH.  This source need not contain a GOPTIONS statement;
the GSAS command will generate its own GOPTIONS statement which will
Örecede your statements when SAS is invoked.

Format for invoking GSAS is -

  GSAS <X1> <Y1> <X2> <Y2> '<SASOPTIONS>' <DEST> <TYPE>

The coordinates (x1,y1) and (x2,y2) respectively specify in inches the
lower left corner and the upper right corner of the box in which the
SAS/GRAPH output is to be stored in the pixel map.

<SASOPTIONS> is optional, but the surrounding apostrophes are not;
that is, if you want to specify <DEST> and perhaps <TYPE>, you must
specify at least the surrounding apostrophes if you don't want to
also specify <SASOPTIONS>, e.g. "gsas 0 0 10 7 '' wed12".

<DEST> is optional, and should only be specified if you want the
SAS/GRAPH drawing to be printed immediately.  It is used to specify the
VTAM printer destination, e.g. TCD1.  If <DEST> is specified, the
internal pixel map will be cleared after the drawing is printed.  Note
that PREALC may be specified for <DEST>, in which case you must have
preallocated ddname ABEPRT with DCB attributes
LRECL=133,BLKSIZE=137,RECFM=VA (file may optionally be blocked).

<TYPE> is used to specify the kind of printer at the specified
destination.  The default is a C.ITOH model CI600, which is assumed to
be manually set at 13 characters per inch.  If CI3500 is specified for
<TYPE>, it is assumed to be manually set at 12 characters per inch.

NOTE:  I can remember thinking when IBM first announced operating
systems supporting virtual storage that I would never have another
program abend because of insufficient main storage.  Ignorance is
bliss.  If you don't use a large SIZE value when you LOGON to TSO, you
don't be able to use the GSAS subcommand.  Even then, if you use the
GR79 subcommand to gain access to the full PLOT79 subroutine package,
you can only use it once during any ABE invocation, and you must do so
before invoking any PLOT79 subroutine.  If you try to invoke GSAS a
second time without returning to READY mode, you will get error
messages from SAS indicating it ran out of main storage.  Normally, it
is best NOT to try to use GR79 when you plan on using the GSAS
subcommand.

GSASR SUBCOMMAND - READING A FILE PRODUCED BY SAS/GRAPH                @

Use the GSASR subcommand to read a file produced previously using
SAS/GRAPH with a GOPTIONS statement such as the following:

    GOPTIONS DEVICE=COMPLOT NOCHARACTERS NOCELL HSIZE=10 VSIZE=7
      VPOS=40 HPOS=75 NOTEXT82;

When SAS/GRAPH is invoked with the above GOPTIONS statement, a file
with ddname FT14F001 must have been  preallocated to a dataset with DCB
attributes LRECL=84,RECFM=VBS,BLKSIZE=18000 (BLKSIZE may vary).
this is the dataset that will be read by the GSASR subcommand.

GSASR differs from the GSAS subcommand previously described in that
gSAS first invokes SAS to process a set of SAS/GRAPH statements, and
when reads the resultant output into the internal pixel map.  GSASR
assumes you have previously invoked SAS, and now simply want the
resultant output read into the internal pixel map.

Format for invoking GSASR is -

  GSASR <X> <Y> <DEST> <TYPE> <DDNAME>

The coordinates (x,y) specify in inches the offset where the GSASR
subcommand is to place the SAS/GRAPH output on the current drawing
represented in the internal pixel map.

<DEST> is optional, and should only be specified if you want the
SAS/GRAPH drawing to be printed immediately.  It is used to specify the
VTAM printer destination, e.g. TCD1.  If <DEST> is specified, the
internal pixel map will be cleared after the drawing is printed.  Note
that PREALC may be specified for <DEST>, in which case you must have
preallocated ddname ABEPRT with DCB attributes
LRECL=133,BLKSIZE=137,RECFM=VA (file may optionally be blocked).

<TYPE> is used to specify the kind of printer at the specified
destination.  The default is a C.ITOH model CI600, which is assumed to
be manually set at 13 characters per inch.  If CI3500 is specified for
<TYPE>, it is assumed to be manually set at 12 characters per inch.

<DDNAME> is the ddname from which the SAS/GRAPH output is to be read.
the default is FT14F001.

GED SUBCOMMAND - VIEWING AND EDITING THE PIXEL MAP                     @

Suppose I have run the following list of subcommands:

     calc points#630
     apl points#&POINTS
     apl theta#(O2)X(Ipoints)%points
     apl r#2O6Xtheta
     apl xarray#1 4`B.5+.5XrX2Otheta
     apl yarray#1 4`B.5+.5XrX1Otheta
     gr79
     gr plt00
     gr setsz 17.78
     gr mova2 1 .5
     gr plna2 xarray 1 yarray 1 &POINTS

You can view the pixel map generated from this list of subcommands by
entering the GED subcommand.  When you do so, your screen will look
like the following:

.ni 42
      1         11        21        31        41        51        61
      12345678901234567890123456789012345678901234567890123456789012345

 0038
 0037
 0036
 0035
 0034
 0033
 0032
 0031
 0030
 0029
 0028
 0027
 0026
 0025
 0024
 0023
 0022
 0021
 0020
 0019
 0018
 0017
 0016
 0015
 0014
 0013
 0012
 0011
 0010
 0009
 0008
 0007
 0006
 0005
 0004
 0003
 0002
 0001

What you're looking at is the lower left corner of the pixel map.
the numbers from 00001 to 00038 running along the left side indicate
the pixel row number.  The numbers running along the top of the screen
indicate the pixel column number.

Program function key 13 is set up as a toggle switch.  Press it,
and the rules along the left side and top change to reflect inches
instead of pixel numbers:


.ni 42
       0 .025 .0875 .1625 .2375 .3125 .2875 .4625 .5375 .6125 .6875


 .5138
 .5
 .4861
 .4722
 .4583
 .4444
 .4305
 .4166
 .4027
 .3888
 .375
 .3611
 .3472
 .3333
 .3194
 .3055
 .2916
 .2777
 .2638
 .2519
 .2361
 .2222
 .2083
 .1944
 .1805
 .1666
 .1527
 .1388
 .125
 .1111
 .0972
 .0833
 .0694
 .0555
 .0416
 .0277
 .0138
 0

Pressing program function key 13 a second time returns the display to
show pixel numbers instead of inches.

Program function key 2 is set up as a zoom or scaling key.
the following screen display was produced by entering the
number 12 before pressing PF2.  The 12 indicates that each print
position on the 3270 screen is to represent a pixel matrix 12
pixels on a side, or 144 pixels total:




.ni 42
      1         121       241       361       481       601       721
      13579135791357913579135791357913579135791357913579135791357913579

 0445            X  XX     X   X     XX  X
 0433            X   XX    X   X    XX   X
 0421            XX   X    X   X   XX   X
 0409             X   XX   X   X   X    X
 0397             XX   XX  X   X  XX   XX
 0385              X    X  X   X XX   XX
 0373    XXXXX     XX   XX X   X X    X     XXXXXX
 0361    X    XXX   XX   X X   XXX   XX   XXX    X
 0349    XX     XXX  X   XXX   XX   XX  XXX     XX
 0337     XX      XX XX   XX  XXX   X XXX     XX
 0325      XXX      XXXX  XX  XX   XXXX      XX
 0313        XXX     XXXX  XX XX  XXXX     XXX
 0301          XXX     XXX XX XX XXX     XXX
 0289            XXX    XXX X X XXX   XXXX
 0277              XXXX  XXXXXXXX   XXX
 0265  XXXXXXXXXXXXXXXXXXX XXXXX XXXXXXXXXXXXXXXXXXX
 0253 XX                XXXXXXXXXXX                XX
 0241 XX                XXXXXXXXXXX                XX
 0229  XXXXXXXXXXXXXXXXXXX XXXXX XXXXXXXXXXXXXXXXXXX
 0217              XXXX  XXXXXXXX   XXX
 0205            XXX    XXX X X XXX   XXXX
 0193          XXX     XXX XX XX XXX     XXX
 0181        XXX     XXXX  XX XX  XXXX     XXX
 0169       XX     XXXXX  XX  XX   XXXX      XX
 0157     XX      XX XX   XX  XXX   X XXX     XXX
 0145    XX     XXX  X   XXX   XX   XX  XXX     XX
 0133    X    XXX   XX   X X   XXX   XX   XXX    X
 0121    XXXXX     XX   XX X   X X    X     XXXXXX
 0109              X    X  X   X XX   XX
 0097             XX   XX  X   X  XX   XX
 0085             X   XX   X   X   X    X
 0073            XX   X    X   X   XX   X
 0061            X   XX    X   X    XX   X
 0049            X  XX     X   X     XX  X
 0037            XXXX      X   X      XX X
 0025            XX        X  XX       XXX
 0013                      XX X
 0001                       XXX

Program function key 2 can also be used to move the display around the
pixel map.  To create the following pixel display I moved the cursor
to about the center of the display and pressed PF2:

.ni 42
      241       361       481       601       721       841       961
      13579135791357913579135791357913579135791357913579135791357913579

 0673
 0661
 0649
 0637
 0625
 0613
 0601
 0589
 0577
 0565
 0553
 0541
 0529
 0517
 0505
 0493   XXX
 0481  XX X
 0469  X  XX       XXX
 0457  X   X      XX X
 0445  X   X     XX  X
 0433  X   X    XX   X
 0421  X   X   XX   X
 0409  X   X   X    X
 0397  X   X  XX   XX
 0385  X   X XX   XX
 0373  X   X X    X     XXXXXX
 0361  X   XXX   XX   XXX    X
 0349 XX   XX   XX  XXX     XX
 0337 XX  XXX   X XXX     XX
 0325 XX  XX   XXXX      XX
 0313  XX XX  XXXX     XXX
 0301  XX XX XXX     XXX
 0289 X X X XXX   XXXX
 0277 XXXXXXX   XXX
 0265  XXXXX XXXXXXXXXXXXXXXXXXX
 0253 XXXXXXXXX                XX
 0241 XXXXXXXXX                XX
 0229  XXXXX XXXXXXXXXXXXXXXXXXX

Eight other program function keys are set up to move the display
about the pixel map:

  PFK
   5 - Move the display to the left side of the pixel map.
   6 - Move the display to the right side of the pixel map.
   7 - Move the display up.
   8 - Move the display down
   9 - Move the display to the top of the pixel map.
  10 - Move the display left.
  11 - Move the display right.
  12 - Move the display to the bottom of the pixel map.

Subcommands UP and DOWN can also be entered on the subcommand line
to move the display up or down a specified number of pixels, e.g.
"up 5" moves the display up 5 pixels.

Note that you can change the pixels directly on the display.  Keying
a "1" on the screen turns the pixels represented by that position
on, and a "0" turns the pixels off.

Finally, pressing PF3 returns you to normal ABE editing mode.  The
pixel map will still be there, and can be subsequently viewed again
by re-entering the GED subcommand.

SAVING THE PIXEL MAP TO A TSO DATASET - PLOT KEYWORD OF ABE            @

There is a PLOT keyword on the ABE subcommand.  It is used to indicate
that the specified dataset will contain an image of the pixel map,
and also environmental information such as pixel density, bitmap
elsize, etc.  To save the current pixel map image, one might enter -

  abe plotsave plot

Entering the SAVE subcommand on the command line for this data set
will then save the pixel map image.  The REFRESH subcommand can
subsequently be used to restore the pixel map image to the state
it was in at the last SAVE subcommand.

SOME ADDITIONAL GRAPHICS SUBCOMMANDS - MOVEP, DRAW, NEWPEN, TEXT       @

I often find it more convenient to work in inches or pixel numbers,
regardless of how world coordinates are mapped into NDC coordinates.
So I have implemented two subcommands, MOVEP and DRAW, which do what
you might expect, e.g. the following draws a 3-inch square 2 inches
from the bottom and left margins of the drawing:

  gr plt00
  movep 2 2
  draw 5 2
  draw 5 5
  draw 2 5
  draw 2 2

Format for the MOVEP and DRAW subcommands is:

  <NAME> <X> <Y> <Z> ('INCHES' × 'PIXELS')

where -

  <NAME> is either "MOVEP" or "DRAW".
  <X> is the X coordinate value.  The default is "+0".
  <Y> is the y coordinate value.  The default is "+0".
  <Z> is the z coordinate value.  The default is "+0".

Each of the coordinate values is considered to be either in units of
inches, or pixel numbers, depending on which of the keywords INCHES or
PIXELS is specified.  If neither of the keywords INCHES nor PIXELS is
specified, the default is INCHES.

Each coordinate value is specified as a real number optionally preceded
by a sign ("+" or "-").  If a sign is not specified, the number is
considered to be relative to the (x,y,z) point (0,0,0). If a sign is
specified, the number specified is considered to be relative to the
current pen location, which is determined by the previous MOVEP or DRAW
subcommand.

NEWPEN                                                                 @

If you will eventually print this drawing on a device which has
selectable pens, you can select different pens to be used in drawing
lines with the NEWPEN subcommand.  Format is -

  NEWPEN <N>

where <N> is the pen number, which must range from 1 thru 9.  Pen
number 9 is the eraser.  Selecting this pen will cause pixels to be
turned off when subsequent DRAW subcommands are issued.

.ni 41
TEXT                                                                   @

TEXT is a shorthand way of specifying text to be placed on a drawing.
Call format is -

  TEXT <TEXT> <HEIGHT> <FONT> <WSCALE> <SWCHAR>

where -

  <TEXT> is a string of text.  The string "<t>homas <g>len <s>mith"
    will be printed as "Thomas Glen Smith."  The characters "<" and
    ">" are used to toggle upper and lower case within the string.
  <HEIGHT> is optional, and specifies the height in inches of the
    characters printed.  If not specified, <HEIGHT> defaults to
    .1 inch.
  <FONT> may be one of the following:

       KR - CARTOGRAPHIC ROMAN
       KG - CARTOGRAPHIC GREEK
       IR - COMPLEX INDEXICAL ROMAN
       II - COMPLEX INDEXICAL ROMAN ITALIC
       IG - COMPLEX INDEXICAL GREEK
       SR - SIMPLEX ROMAN
       SS - SIMPLEX ROMAN SCRIPT
       SG - SIMPLEX GREEK
       CR - COMPLEX NORMAL ROMAN
       CI - COMPLEX NORMAL ROMAN ITALIC
       CG - COMPLEX NORMAL GREEK
       CS - COMPLEX ROMAN SCRIPT
       DR - DUPLEX ROMAN
       TR - TRIPLEX ROMAN
       GE - GOTHIC ENGLISH
       GI - GOTHIC ITALIAN
       GG - GOTHIC GERMAN
       GG - COMPLEX CYRILLIC

  <WSCALE> - Same as the WSCALE parameter to SYMTX as documented in
    the PLOT79 User's Manual.  Defaults to 1.
  <SWCHAR> - Same as the WSCALE parameter to SYMTX as documented in
    the PLOT79 User's Manual.  Defaults to 0.

PD AND PU SUBCOMMANDS - COMPATIBILITY WITH IBM GL (GRAPHICS LANGUAGE)  @

The PD and PU subcommands were added to provide some compatibility with
the IBM GL (Graphics Language).  The function of these two subcommands
is implied by their names; PD derives from Pen Down, and PU from Pen
up.

Format for the PD subcommand is as follows:

  PD <X1> <Y1> <X2> <Y2> ... <X10> <Y10>

Each (Xn,Yn) pair specifies, in world coordinates, a new location to
which a line is to be drawn.  Up to 10 pairs can be specified.

Format for the PU subcommand is as follows:

  PU <X1> <Y1>

specifies the location in world coordinates to which the pen holder
is to be moved with the pen up.

GRFGG - GENERALIZED GRAPH SUBROUTINE                                   @

First create an UNNUMBERED dataset of fixed length, 80-column records
containing the following (note that &DATA begins in column 2):

 ni 8
 &DATA
 X(1,1)=1,3,4,7
 Y(1,1)=3.6,2*6.7,1.3
 N(1)=4
 &END
 GRAPH TITLE
 X-AXIS TITLE
 Y-AXIS TITLE

For the sake of argument, suppose such a dataset exists with the name
of PLOT.DATA.  Next issue the following two TSO commands in X-mode:

 alloc fi(ft16f001) da(*) recfm(f) reuse
 alloc fi(ft15f001) da(plot.data) reuse

Then enter the subcommand -

 gr grfgg 15 16

This will produce a nice little graph on the pixel map, which may
be subsequently printed with "gpr tcd1" assuming destination tcd1
is a C.ITOH printer appropriately set at 13 pitch, or can simply be
viewed at the terminal with the GED subcommand.

Personally, I think SAS/GRAPH does a better job, but for those that
want to use GRFGG, list 'U.TC.PLOT79.FILE047(GRFGG)' to see
documentation on the various parameters you can supply.

HIDDEN LINE ROUTINES - SAMPLE RUN                                      @

If the RUN subcommand is issued for a dataset containing the
following list of subcommands, the equivalent of DEMO #1 in the
PLOT79 DEMONSTRATION PROGRAMS manual will be created.  Unfortunately,
the amount of processing time required to do this interpretively
is prohibitive; this demo takes about 30 minutes to executed on a
3084.  See the section titled "WRITING YOUR OWN PL/I PROGRAMS TO DO
GRAPHICS" later in this section:

    calc mx#my#nx#ny#51
    calc sx#int(.4*(nx-1))
    calc sy#int(.6*(ny-1))
    calc lx#ly#2
    apl wy#1 4`B &NY &NX R0
    CALC J#0
    $while ny>=j#j+1
      calc i#0
      $while nx>=i#i+1
        calc x1#(i-sx)/10
        calc y1#(j-sy)/10
        calc x2#(i-sy)/10
        calc y2#(j-sx)/10
        calc r1#sqrt(rr1#x1**2+2*(y1**2+x1*y1))
        calc rr2#.5*(2*x2**2-y2**2-x2*y2)
        calc p1#r1*sin(.4*rr1)*exp(-.25*rr1)
        calc p2#cos(rr2)*exp(-0.2*abs(rr2))
        calc val#-tanh(.4*p1**2+.2*p2**2+.005*x2*y1)
        apl wy{ &I ; &J}# &VAL
    gr79
    gr plt00
    gr pltfr
    gr demla 'dem01'
    gr pltlab '<S>OUTHEAST <V>IEW' 18 1 1
    GR HIDSE -1 -1 WY 1 &MX &MY &NX &NY &LX &LY 0 PL2CA
    gpr tcd1
    gr plt00
    gr pltfr
    gr demla 'dem01'
    gr pltlab '<S>OUTHWEST <V>IEW' 18 1 1
    GR HIDSW -1 -1 WY 1 &MX &MY &NX &NY &LX &LY 0 PL2CA
    gpr tcd1
    gr plt00
    gr pltfr
    gr demla 'dem01'
    GR PLTLAB '<S>OUTH STEREO <V>IEW' 21 1 1
    GR HIDSES -1 -1 WY 1 &MX &MY &NX &NY &LX &LY 0 PL2CA
    gpr tcd1

HIDDEN LINES ROUTINES - SPHERICAL COORDINATES                          @

If the RUN subcommand is issued for a dataset containing the
following list of subcommands, the equivalent of DEMO #13 in the
PLOT79 DEMONSTRATION PROGRAMS manual will be created.

    calc nt#mt#31
    CALC np#mp#60
    apl ef#1 4`B &NT &NP R0
    apl t#1 4`B4 4R0
    calc dt#3.14159/(nt-1)
    calc dp#6.28318/np
    calc th#0
    calc i#0
    $while nt>=i#i+1
      calc ph#0.45
      calc j#0
      $while np>=j#j+1
        calc tf#.33*(2-cos(2*th))
        calc pf#.85+.25*sin(7*ph)
        calc val#.9*tf*pf+.05*mod(j+i,2)
        apl ef{ &I ; &J}# &VAL
        calc ph#ph+dp
      calc th#th+dt
    gr79
    gr plt00
    gr plteu t 143.13 65.91 39.23
    gr pltsq
    gr demla 'DEM13'
    gr pltlab '<S>PHERICAL <V>IEW' 18 1 1
    gr hidsv ef &MP &MT &NP &NT 1 t vissp pl2po

WRITING YOUR OWN PL/I PROGRAMS TO DO GRAPHICS                          @

You can write PL/I programs to be run under ABE to generate graphics
using the PLOT79 subroutines.  Following is a set of ABE subcommands
which, when executed, produce a graph with the appearance of a
12-petalled flower:

    CALC PI#3.14159
    CALC PI2#2*PI
    GR79
    GR PLT00
    GR SETSZ 17.78
    GR SET3D 1
    SETL OP MOV
    CALC PHI#0
    CALC CTL#PI2+.1
    $UNTIL CTL<PHI#PHI+.01
      CALC R#ABS(COS(6*PHI))
      CALC W#.5+R/2*SIN(PHI)
      CALC U#.5+R/2*COS(PHI)
      CALC V#SIN(R*1.5*PI-PI/2)/3+.5
      GR &OP.A3 &U &V &W
      SETL OP LIN

The following PL/I program, when executed under ABE, will produce
exactly the same flower-like graph a great deal faster:

    %INCLUDE ABESUB;
    ABESUB(FLOWER);
    %INCLUDE ABESUBA;
    %INCLUDE ABE79ENT;

    DCL RTNE ENTRY VARIABLE;
    DCL (PHI,PI,R,U,V,W) FLOAT;

    PI=3.14159;
    I=#CMD('GR79',RHPTR,RHHDRPT);
    I=#CMD('GR PLT00',RHPTR,RHHDRPT);
    I=#CMD('GR SETSZ 17.78',RHPTR,RHHDRPT);
    I=#CMD('GR SET3D 1',RHPTR,RHHDRPT);
    RTNE=#MOVA3;
    DO PHI=0 REPEAT PHI+.01 WHILE(PHI<(2.0*PI+.01));
      R=ABS(COS(6.0*PHI));
      W=.5+R/2.0*SIN(PHI);
      U=.5+R/2.0*COS(PHI);
      V=SIN(R*1.5*PI-PI/2.0)/3.0+.5;
      CALL RTNE(U,V,W);
      RTNE=#LINA3;
      END;
    END FLOWER;

If you have never written a PL/I program for execution under ABE, you
should review Appendix A to this manual before proceeding.

As you can see above, PLOT79 subroutines can be accessed either
indirectly via the #CMD routine, or directly via the list of routines
in the structure defined by the "%INCLUDE ABE79ENT" statement.  In the
above program, both of the routines #MOVA3 and #LINA3 are invoked in
this second manner.  It is important to always invoke the PLT00
subroutine by invoking #CMD, however, because essential functions
internal to ABE are also done when PLT00 is invoked in this manner.

Assuming that your TSO userid were TSOUSER, and that dataset
TSOUSER.FLOWER.PLI exists containing the above source statements, then
the following TSO commands will get the program compiled, linkedited,
and executed:

  pli flower m lib('sys2.maclib' 'x75826.abe.pli') obj cs(60)
  link (flower *) load(test(flower)) lib('sys2.plibase') plib pr(*)
   entry flower

  t test.load(abe) '' inp(/pgm flower/gpr tcd1/end n)

Note that the line containing " entry flower" and the null line
immediately following it are both entered in response to a prompt from
the linkage editor for control statements.  The flower-like graph will
be printed at destination TCD1, assuming that destination is for a
CITOH printer equipped with the necessary graphics circuitry board.

IMGET - STORES PIXEL MATRIX IN EDITED DATASET                          @
IMPUT - STORES PIXEL MATRIX IN INTERNAL PIXEL STORAGE                  @

IMGET and IMPUT are companion subcommands which can be used to move
pixel maps back and forth between the internal pixel map and edited
datasets.  Suppose you are currently editing a dataset named GLASS
containing a representation of a 20-by-20 pixel matrix:

.ni 23
              10        20
     12345678901234567890123456789
                          ×GLASS××
  01 11111111111111111111
  02 1                111
  03  1               11
  04   1              1
  05    1            1
  06     1          1
  07      1        1
  08       1      1
  09        1    1
  10         1  1
  11          11
  12          11
  13          11
  14          11
  15          11
  16          11
  17          11
  18 1        11
  19 11       11
  20 11111111111111111111

The IMPUT subcommand can get used to store such a pixel matrix at
various locations in the internally maintained pixel map.  Following
are various IMPUT subcommands, and a representation of the 20-by-20
pixel matrix as it would appear in the lower left corner of the
internal pixel map displayed using the GED subcommand:

.ni 23
    imput glass 1 20 20 1                  imput glass 20 20 1 1

    11111111111111111111                   11111111111111111111
    1                111                   111                1
     1               11                     11               1
      1              1                       1              1
       1            1                         1            1
        1          1                           1          1
         1        1                             1        1
          1      1                               1      1
           1    1                                 1    1
            1  1                                   1  1
             11                                     11
             11                                     11
             11                                     11
             11                                     11
             11                                     11
             11                                     11
             11                                     11
    1        11                                     11        1
    11       11                                     11       11
    11111111111111111111                   11111111111111111111

.ni 23
    imput glass 1 1 20 20                  imput glass 20 1 1 20

    11111111111111111111                   11111111111111111111
    11       11                                     11       11
    1        11                                     11        1
             11                                     11
             11                                     11
             11                                     11
             11                                     11
             11                                     11
             11                                     11
             11                                     11
            1  1                                   1  1
           1    1                                 1    1
          1      1                               1      1
         1        1                             1        1
        1          1                           1          1
       1            1                         1            1
      1              1                       1              1
     1               11                     11               1
    1                111                   111                1
    11111111111111111111                   11111111111111111111

The IMGET subcommand is companion to, and does the reverse of, IMPUT,
e.g. -

   IMGET glass 1 20 20 1

stores the 20-by-20 pixel matrix at location (1,20) thru (20,1) in
the internal pixel map as 20 lines of data in dataset with symbolic
name GLASS.

syntax for IMGET and IMPUT is as follows:

  <subcmd> <name> <xpel1> <ypel1> <xpel2> <ypel2>

where -
  <subcmd> is either IMGET or IMPUT.

  <name> is the symbolic name associated with the dataset to which
    or from which pixels are to be stored or fetched, depending
    on whether the current subcommand is IMGET or IMPUT.  In the
    case of IMGET, if a dataset with that name isn't currently
    being edited, a virtual dataset will be created.  An asterisk (*)
    can be specified for <name>, in which case the current dataset
    will be used.

    Note that in the case of IMGET, the new records containing
    pixel representations will be added to the specified dataset
    following the current line, and in the case of IMPUT, the
    records from which pixel representations of extracted are
    selected beginning with the current line.

  <xpel1>, <ypel1>, <xpel2>, and <ypel2> are all pixel coordinates
    in the internal pixel map.  The combination of the four values
    delineates a rectangular area of pixels to be dealt with.

IMGETB - STORES PIXEL MATRIX IN EDITED DATASET                         @
IMPUTB - STORES PIXEL MATRIX IN INTERNAL PIXEL STORAGE                 @

IMGETB and IMPUTB have identical syntax with IMGET and IMPUT.  They
differ functionally only in that IMGETB and IMPUTB deal with pels
each represented by a single bit, whereas IMGET and IMPUT deal with
pels each represented by a printable '1' or '0'.

IMPUTB is used in RUN subcommand list GDDMIMAG, which is described
in Appendix O under the heading "GDDM OUTPUT ON A NON-GRAPHICS DEVICE".

GFILL - FILL IN A CLOSED AREA ON THE DRAWING                           @

GFILL lets you fill in a closed area.  Syntax is -

  gfill <x> <y> <span> ('inches' × 'pixels' × 'inches')

CAUTION:  <x> and <y> must be in an area which has a complete border.
if there is a leak, the entire drawing will be filled in.

