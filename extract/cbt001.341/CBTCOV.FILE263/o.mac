.he ABE, T. Smith, Appendix O
.gr 54 TITLE
.np
Appendix O - GDDM GRAPHICS SUPPORT.                                    @

This appendix documents the support of graphics using GDDM under ABE.
GDDM (Graphical Data Display Manager) is a software product marketed
by IBM that "enables application programs to produce graphics and
alphanumerics on display devices and printers, and to read input from
display devices."

This manual is printed on an IBM 3800 Model 3 Laser Printer using
IBM's Print Services Facility (PSF).  The graphic drawings in this
manual, such as on the title page just previous to this one, were
produced using GDDM under ABE.

GDDM SUBCOMMAND                                                        @

The GDDM subcommand of ABE provides the interface to the IBM GDDM
product. The general format for the GDDM subcommand is as follows:

    GDDM <NAME> <OPERANDS>

where -

  <NAME> is the name of the GDDM subroutine to be invoked.  Following
    is a list of the subroutines which may be invoked via the GDDM
    subcommand.  All of them are documented in the GDDM Programming
    Reference, SC33-0101:

    ASCCOL ASCGET ASCHLT ASCPUT ASCSS  ASDFLD ASDFLT ASDFMT ASD
    ASFCLR ASFCOL ASFCUR ASFEND ASFHLT ASFIN  ASFINT ASFMOD ASF
    ASFPSS ASFTRN ASFTYP ASGGET ASGPUT ASMODE ASQCOL ASQCUR ASQ
    ASQHLT ASQMAX ASQMOD ASQSS  ASRATT ASREAD ASRFMT ASTYPE DSC
    DSDROP DSOPEN DSQDEV DSQUID DSQUSE DSRNIT DSUSE  ESLIB  ESP
    FSALRM FSCHEK FSCLS  FSCOPY FSEXIT FSFRCE FSINIT FSLOG  FSO
    FSPCLR FSPCRT FSPDEL FSPQRY FSPSEL FSPWIN FSQCPG FSQDEV FSQ
    FSQUPG FSQURY FSQWIN FSREST FSRNIT FSSAVE FSSHOR FSSHOW FST
    FSTRCE GSARC  GSAREA GSCA   GSCB   GSCD   GSCH   GSCHAP GSC
    GSCLP  GSCLR  GSCM   GSCOL  GSCOPY GSCS   GSDSS  GSELPS GSE
    GSENDA GSFLD  GSFLSH GSFLW  GSGET  GSGETE GSGETS GSIDVF GSI
    GSILOC GSIMG  GSIMGS GSIPIK GSLINE GSLSS  GSLT   GSLW   GSM
    GSMIX  GSMOVE GSMRKS GSMS   GSMSC  GSPAT  GSPFLT GSPLNE GSP
    GSPUT  GSQATI GSQATS GSQCA  GSQCB  GSQCD  GSQCEL GSQCH  GSQ
    GSQCLP GSQCOL GSQCM  GSQCP  GSQCS  GSQCUR GSQFLW GSQLOC GSQ
    GSQLW  GSQMAX GSQMIX GSQMS  GSQMSC GSQNSS GSQPAT GSQPIK GSQ
    GSQPS  GSQSIM GSQSS  GSQTAG GSQTB  GSQVIE GSQWIN GSREAD GSR
    GSSATI GSSATS GSSCLS GSSDEL GSSEG  GSSPOS GSTAG  GSVECM GSV
    GSWIN  ISSE   MSCPOS MSDFLD MSGET  MSPCRT MSPQRY MSPUT  MSQ
    MSQFIT MSQFLD MSQGRP MSQMAP MSQMOD MSQPOS MSREAD PSDSS  PSL
    PSLSSC PSQSS  PSRSS  PSRSV  PTNCRT PTNDEL PTNMOD PTNQRY PTN
    PTSCRT PTSDEL PTSQRY PTSQUN PTSSEL SSQF   SSREAD SSWRT

  <OPERANDS> consists of zero or more operands to be passed to the
    specified subroutine. These arguments are documented in the GDDM
    Programming Reference. An operand may be any of the following:

    1.  NUMERIC CONSTANT, e.g. GDDM GSMOVE 23.45 57.346.

    2.  CHARACTER LITERALS, which may be any string of text surrounded
        by apostrophes, e.g. GDDM GSCHAR 70 95 9 'Tom Smith'.

    3.  VARIABLE NAMES, which are references to currently edited
        datasets.  For example, consider the following string of
        commands in which a string of text ("Do ants sleep?") is passed
        to GDDM subroutine ASCPUT:

          DEFINE XXX
          A XXX NL DO ANTS SLEEP?
          GDDM ASCPUT 10 23 XXX

        For another example, consider the following string of
        subcommands in which the APL subcommand is used to produce
        arrays of numeric variables to be passed to GDDM subroutine
        GSPLNE:

          apl theta#(O2)X(I630)%630
          apl r#2O6Xtheta
          apl xarray#1 4`B50+50XrX2Otheta
          apl yarray#1 4`B50+50XrX1Otheta
          gddm gsmove 100 50
          gddm gsplne 630 xarray yarray

        NOTE:  The variable name BITMAP is a special case.  It
        refers to the internal pixel map maintained and manipulated
        using the GR subcommand.  See also in the index, "GDDM -
        DISPLAYING BITMAP USING GDDM."

    4.  SYMBOLIC NAMES preceded by an & ampersand.  The replacement
        value currently associated with the specified symbolic name
        will be passed to the specified GDDM subroutine, e.g.:

          calc id#a+23
          gddm ascput &id 66 'how now brown cow'

    5.  SYMBOLIC NAMES preceded by a percent sign.  The specified
        symbolic name will be assigned a replacement value according
        to whatever is returned by the GDDM subroutine, e.g.:

          gddm asread %type %mod %count

        When this subcommand is completed, symbolic variables TYPE,
        MOD, and COUNT will all contain values assigned by the GDDM
        subroutine ASREAD.  In this case, TYPE for example, would
        contain 0 if the ENTER key was pressed at the terminal, or
        1 if program function key 1 was pressed, etc.

GDDM SAMPLES                                                           @

The GDDM Application Programming Guide lists several examples, two of
which I have reproduced here as datasets for which the RUN subcommand
can be issued.

GDDM SAMPLE #1 - THE ENVELOPE                                          @

The first example in the GDDM Application Programming Guide produces
a picture of an envelope on a terminal with graphics capability.  The
equivalent of this program as a dataset for which RUN can be issued
is as follows:

   GDDM FSINIT
   GDDM GSSEG 0
   GDDM GSCOL 5
   GDDM GSLW 2
   $* DRAW OUTLINE OF ENVELOPE
   GDDM GSMOVE 20.0 60.0
   GDDM GSLINE 20.0 10.0
   GDDM GSLINE 80.0 10.0
   GDDM GSLINE 80.0 60.0
   GDDM GSLINE 20.0 60.0
   GDDM GSLINE 50.0 80.0
   GDDM GSLINE 80.0 60.0
   $* NOW DRAW THE STAMP
   GDDM GSCOL 2
   GDDM GSMOVE 76.0 43.0
   GDDM GSAREA 1
   GDDM GSLINE 76.0 55.0
   GDDM GSLINE 68.0 55.0
   GDDM GSLINE 68.0 43.0
   GDDM GSLINE 76.0 43.0
   GDDM GSENDA
   $* NOW WRITE THE ADDRESS
   GDDM GSCOL 4
   GDDM GSCHAR 35.0 38.0 13 'A. LESTRANGE,'
   GDDM GSCHAR 43.0 29.0 17 '32 CHURCH STREET,'
   GDDM GSCHAR 55.0 20.0 10 'HAMBLEDON.'
   $* SEND THE PICTURE TO THE SCREEN
   GDDM ASREAD 0 0 0
   GDDM FSTERM

A drawing, in black and white of course, of the envelope you would see
it your color crt terminal follows:

.gr 30 ENVELOPE
GDDM SAMPLE #2 - SAMPLE ALPHANUMERICS PROGRAM                          @

The second example in the GDDM Application Programming Guide shows a
program that gives details of a bank customer and his account balances
in response to a typed-in account number.  It only uses the
alphanumerics capabilities of a terminal, and doesn't use any graphics
functions, so it is of limited interest here.  Nevertheless, I
reproduced it here to show that it could be done using the ABE/GDDM
interface. Following is that program reproduced as a dataset for which
the ABE RUN subcommand can be issued.  I have modified the program to
run on a screen with at most 24 lines; the original version assumed a
screen with at least 32 lines:

   $* DEFINE POSSIBLE ACCOUNT NUMBERS
   SETL A00001 1
   SETL A00002 2
   SETL A00003 5
   SETL A00004 7
   $* DEFINE DEPOSIT AMOUNTS
   SETL D00001 '   1247'
   SETL D00002 '     23'
   SETL D00003 '    -57'
   SETL D00004 '    641'
   $* DEFINE CURRENT AMOUNTS
   SETL C00001 '     17'
   SETL C00002 '   -121'
   SETL C00003 '    340'
   SETL C00004 '     -8'
   $* DEFINE ADDRESSES
   SETL A00011 'W.D.LANGHURST,           '
   SETL A00012 '21 BLAKE COTTAGES,       '
   SETL A00013 'ASHGROVE.                '
   SETL A00021 'G.HUCKLE,                '
   SETL A00022 'THE RISE,                '
   SETL A00023 'LITTLEHAMPTON.           '
   SETL A00031 'MRS. E.C.BOTERILL,       '
   SETL A00032 '47 CURTIS ROAD,          '
   SETL A00033 'SHERWOOD.                '
   SETL A00041 'L.M.FORRESTER,           '
   SETL A00042 '6 VILLAGE ROAD,          '
   SETL A00043 'ROMSEY.                  '
   CALC RED#2
   CALC GREEN#4
   CALC TURQ#5
   CALC YELLOW#6
   $*
   GDDM FSINIT
   $* DEFINE ALPHANUMERIC FIELD
   $*         FIELD_ID ROW COLUMN DEPTH WIDTH TYPE
   GDDM ASDFLD 1        4   25     1     21    2
   $* SET FIELD COLOR ATTRIBUTE
   GDDM ASFCOL 1 &GREEN
   $* ASSIGN DATA TO FIELD 1
   GDDM ASCPUT 1 21 'ENTER ACCOUNT NUMBER:'
   $* DEFINE A NUMERIC ONLY FIELD, COLORED YELLOW
   GDDM ASDFLD 2 4 47 1 4 1
   GDDM ASFCOL 1 &YELLOW
   $* DEFINE ALPHA FIELDS TO HOLD CUSTOMER'S ADDRESS
   CALC I#0
   $WHILE 4>I#I+1
     GDDM ASDFLD (I+2) (I*2+13) (I*4+25) 1 25 2
     GDDM ASFCOL (I+2) &TURQ
   $* DEFINE PROTECTED FIELD AND ASSIGN DATA TO IT
   GDDM ASDFLD 6 22 5 1 16 2
   GDDM ASCPUT 6 16 'CURRENT ACCOUNT:'
   $* WILL HOLD CURRENT ACCT. BALANCE
   GDDM ASDFLD 7 22 22 1 7 2
   $* DEFINE PROTECTED FIELD AND ASSIGN DATA TO IT
   GDDM ASDFLD 8 22 45 1 16 2
   GDDM ASCPUT 8 16 'DEPOSIT ACCOUNT:'
   $* WILL HOLD DEPOSIT ACCT. BALANCE
   GDDM ASDFLD 9 22 62 1 7 2
   $* DEFINE MESSAGE FIELD, COLORED RED
   GDDM ASDFLD 10 24 16 1 48 2
   GDDM ASFCOL 10 &RED
   $*
   $* TOP OF LOOP TO PROCESS ACCOUNT REQUESTS
   $*
   $ OUTPUT
   $* POSITION THE CURSOR IN ACCOUNT NUMBER FIELD
   GDDM ASFCUR 2 1 1
   GDDM ASREAD %TYPE %MOD %COUNT
   $IF TYPE^=0
     $GOTO ENDIT
   $* RETRIEVE DATA FROM FIELD
   GDDM ASCGET 2 4 %ACCTNO
   CALC AC#0
   $WHILE 5>AC#AC+1
     SETLZF AC
     SETL SYM &&A&AC
     $IF '&ACCTNO'='&SYM'
       $GOTO VALID
   $* INVALID OR BLANK ACCOUNT NUMBER, ISSUE ERROR MESSAGE
   GDDM ASCPUT 10 48 'INVALID OR BLANK ACCOUNT NUMBER. PLEASE RE-ENTER.'
   GDDM FSALRM
   $GOTO OUTPUT
   $ VALID
   GDDM ASCPUT 10 23 'PRESS ANY PFKEY TO QUIT'
   $* RED IF DEBIT, GREEN IF CREDIT
   SETL SYM &&C&AC
   $IF &SYM<0
     GDDM ASFCOL 7 &RED
   $ELSE
     GDDM ASFCOL 7 &GREEN
   GDDM ASCPUT 7 7 '&SYM       '
   $* RED IF DEBIT, GREEN IF CREDIT
   SETL SYM &&D&AC
   $IF &SYM<0
     GDDM ASFCOL 9 &RED
   $ELSE
     GDDM ASFCOL 9 &GREEN
   GDDM ASCPUT 9 7 '&SYM       '
   CALC I#0
   $WHILE 4>I#I+1
     CALC SY#AC*10+I
     SETLZF SY
     SETL SYM &&A&SY
     GDDM ASCPUT (I+2) 25 '&SYM'
   $GOTO OUTPUT
   $ ENDIT
   GDDM FSTERM

GDDM IN A BATCH JOB - OUTPUT TO THE 3800 LASER PRINTER                 @

Following is JCL that can be used to run GDDM in batch using the ABE
interface, directing the output to the 3800 laser printer:

    /*IWT 5
    //<userid> JOB (10-337-MISC-027-B4,1),
    //             '<name>',CLASS=E,MSGCLASS=G,NOTIFY=<userid>
    //         EXEC GDDM3800,RUN='GSTAR 50 50 50'
    //SYSRUN   DD DSN=<userid>.SYSRUN,DISP=SHR
    //         DD DSN=SYS2.CNTCARD,DISP=SHR

Replace <userid> in the above JCL with your own userid.
A list of the pertinent JCL procedures and datasets follows:

  DSN=SYS2.PROCLIB(GDDM3800)
    //GDDM3800 PROC RUN=
    //S1       EXEC PGM=ABEB,REGION=6500K,DYNAMNBR=30,PARM='RUN(&RUN)'
    //STEPLIB  DD DSN=SYS1.GDDMLOAD,DISP=SHR
    //ADMDEFS  DD DSN=SYS2.CNTCARD(ADMDEFS),DISP=SHR
    //ADMSYMBL DD DSN=SYS1.GDDMSYM,DISP=SHR
    //SYSPRINT DD SYSOUT=*
    //OUT1 OUTPUT PRMODE=PAGE,PAGEDEF=090C0,FORMDEF=0101
    //IBM3800  DD SYSOUT=A,OUTPUT=(*.OUT1),
    //            DCB=(LRECL=2004,BLKSIZE=2008,RECFM=VA)
    //OUT      DD SYSOUT=*,DCB=(LRECL=80,BLKSIZE=80,RECFM=FA)
    //IN       DD DSN=SYS2.CNTCARD(GDDM38IN),DISP=SHR
    //SYSRUN   DD DSN=SYS2.CNTCARD,DISP=SHR

  DSN=SYS2.CNTCARD(ADMDEFS)
     ADMMNICK NAME=IBM3800,DEVTOK=FINEGRAF,
       PROCOPT=((HRISWATH,2),(HRISPILL,NO))

  DSN=SYS2.CNTCARD(GDDM38IN)
    $CONTROL LIST
    $CMD RUN GDDM3800 &RUN

  DSN=SYS2.CNTCARD(GDDM3800)
    $* GDDM3800
    $* USED IN GDDMBTCH WHICH RUNS GDDM IN BATCH, OUTPUT TO 3800
    GDDM FSINIT
    GDDM DSOPEN 12 4 '*        ' 0 0 1 'IBM3800 '
    GDDM DSUSE 1 12
    RUN &P1 &P2 &P3 &P4 &P5 &P6 &P7 &P8 &P9
    GDDM FSFRCE
    GDDM DSCLS 12 1
    GDDM FSTERM

The name GSTAR in RUN='GSTAR 50 50 50' in the JCL above refers to a
member in <userid>.SYSRUN, and might appear as follows:

    $* (P1,P2)=CENTER, P3=RADIUS
    GDDM GSMOVE (P1) (P2+P3)
    GDDM GSAREA 1
    GDDM GSLINE (P1-P3*COSD(30)) (P2-P3*SIND(30))
    GDDM GSLINE (P1+P3*COSD(30)) (P2-P3*SIND(30))
    GDDM GSLINE (P1) (P1+P3)
    GDDM GSMOVE (P1+P3*COSD(30)) (P2+P3*SIND(30))
    GDDM GSLINE (P1-P3*COSD(30)) (P2+P3*SIND(30))
    GDDM GSLINE (P1) (P2-P3)
    GDDM GSLINE (P1+P3*COSD(30)) (P2+P3*SIND(30))
    GDDM GSENDA

The result of running GSTAR follows:

.gr 30 GSTAR 50 50 50
DEVTOK=GRAF or FINEGRAF                                                @

On the JCL above under the heading "GDDM IN A BATCH JOB" dataset
ADMDEFS contains an ADMMNICK statement with NAME=IBM3800.  The GDDM
FSOPEN statement in SYSRUN dataset member GDDM3800 refers to this
nickname.  The ADMMNICK statement specifies a device token FINEGRAF,
which is unique to our installation.  It defines the paper size on
which the drawing is to be printed to be 11 inches wide along the x
axis, and 7.5 inches tall along the y axis.  Lines will be 1 pel wide.
device token GRAF uses the same paper dimensions, but defines lines to
be 3 pels wide.  Other standard device tokens are documented in the
manual "GDDM Base Programming Reference."

GDDM FROM TSO - OUTPUT TO A GRAPHICS TERMINAL                          @

In order to display graphics from TSO you first need a terminal with
graphics capabilities.  Two such terminals are the IBM3279G and
IBM3179G video display terminals (of these, the IBM3179G is far
superior).  Be sure the model name of your terminal ends with "G"; we
have IBM3179 and IBM3279 terminals that do not have graphics
capability.

Given that you have a terminal with graphics capability, you must then
use a different command when you logon to TSO.  For example, on my
IBM3179G terminal, I must enter "tso23x" instead of "logon".  The
systems software department can tell you what you need to use for
your type terminal.

Once you've logged on to TSO, you need to obtain access to a number
of GDDM libraries.  I do so by executing a clist containing the
following commands:

    ALLOC FI(SYSLOAD) DA('SYS1.GDDMLOAD') SHR REUSE
    ALLOC FI(ADMSYMBL) DA('SYS1.GDDMSYM') SHR REUSE
    T BIGIDLE

Once I've executed the above commands, until I enter the command
"end idle" I will have access to the necessary GDDM libraries.
until I enter "end idle" I will be prompted with the text
"YES_MASTER?" instead of "READY".  I must enter "end idle" before I
logoff.

Given all of the above, I can invoke ABE and perhaps use the
%%GDDMSHOW subcommand to display graphics at my terminal.

GDDMSHOW - MAINTAINING OUTPUT INDEPENDENCE                             @

With a little care in organizing datasets containing GDDM subcommands
to be executed via the RUN subcommand of ABE, you can maintain maximum
flexibility and device independence.  For example, previously shown was
the printing on the IBM 3800 laser printer the GDDM output
produced as a result of executing the subcommand -

    $CMD RUN GDDM3800 GSTAR 50 50 50

The same drawing, without modification, can be displayed interactively
at a 3179G terminal by entering the subcommand -

    %%gddmshow gstar 50 50 50

Following is a list of GDDMSHOW, which is a member of the partitioned
dataset I have allocated under the ddname SYSRUN:

    GDDM FSINIT
    GDDM GSCLP 1
    %%&P1 &P2 &P3 &P4 &P5 &P6 &P7 &P8 &P9
    GDDM ASREAD 0 0 0
    GDDM FSTERM

As you will see below under the heading "GDDM OUTPUT ON A NON-GRAPHICS
DEVICE," the same drawing can be viewed on a non-graphics terminal, or
on a C.ITOH graphics printer, by slightly altering the run subcommand
just shown.

GDDM OUTPUT ON A NON-GRAPHICS DEVICE - GDDMIMAG                        @

If I am sitting at a non-graphics terminal, and I would like to view
the drawing of the star described above, I can do so after a fashion
by entering the following subcommand:

    %%gddmimag gstar 50 50 50

This will store the drawing in the internal pixel map described
in Appendix N, and I can view the drawing using the GED subcommand
also described in Appendix N.  When I am through viewing the
drawing, I can use the GPR subcommand to print the box drawing on
a C.ITOH printer.

Following is a list of GDDMIMAG:

  $* USED TO DISPLAY PEL MAP OF GDDM DRAWING
  XT 'ALLOC FI(IBM3800) NEW TR SP(50 10) REUSE +
    LR(2004) BL(19060) RECFM(V B A)'
  GDDM FSINIT
  GDDM DSOPEN 12 4 'CANCI600' 0 0 1 'IBM3800 '
  GDDM DSUSE 1 12
  RUN &P1 &P2 &P3 &P4 &P5 &P6 &P7 &P8 &P9
  GDDM FSFRCE
  GDDM DSCLS 12 1
  GDDM FSTERM
  GR DEVICE 80 72 792 504 1
  ABE '' INFI(IBM3800) NON HEX INP(/IMPUTB/END)

Note that the device token CANCI600 produces a pixel matrix 768 pels
wide, and 480 pels tall.  For reasons which I don't understand, GDDM
couldn't cooperate in producing a pel map exactly 792 by 504 pels,
which would be the ideal size for the C.ITOH CI600 printer.  Also, the
pel matrix produced seems to be missing a row of pels along the top and
right sides.  This may be due to a bug in my code or in GDDM itself.
Of you take the default GDDM drawing dimensions of 0-100 along each
axes, this means any pels beyond 99.8 won't be obtained.

CURSORS - GRAPHIC AND ALPHANUMERIC ON IBM 3179                         @

( have a lot of questions about how to use and manipulate cursors
on the 3179 display, so this section will be expanded as I get
more answers.  Briefly, however, I've been able to get the
graphics cursor, which shows up as cross-hairs, by doing the
following sequence:

    gddm fsinit
    gddm gsiloc 1 0 50 50
    gddm gsenab 2 1 1
    gddm gsread 1 0 0
    gddm fsterm

With the above sequence, two cursors are displayed, the alphanumeric
cursor, which shows up as a solid rectangle or underscore line
depending on which way AltCr is toggled, and the graphics cursor,
which shows up as either short cross-hairs or as screen-spanning
cross-hairs, also  depending on which way AltCr is toggled.

You can only manipulate one cursor at a time, either the alphanumeric
or the graphics cursor.  Which one is determined by toggling +Cr.
when the graphics cursor is the one that is currently manipulable, the
symbol "+Cr" will appear at the bottom of the screen.

GDDMLOC - QUERYING LOCATIONS WITH THE GRAPHICS CURSOR                  @

Following is a list of dataset GDDMLOC -

    GDDM FSINIT
    %%&P1 &P2 &P3 &P4 &P5 &P6 &P7 &P8 &P9
    GDDM GSILOC 1 0 50 50
    GDDM GSENAB 2 1 1
    GDDM GSREAD 1 0 0
    GDDM GSQLOC 1 %X %Y
    GDDM FSTERM
    MSG X=&X Y=&Y

If I issue the subcommand -

    %%gddmloc drawing

The cross-hairs representing the graphics cursor will show up on my
drawing, and I can move it about using the arrow keys.  When GDDMLOC
finishes, the message area will contain the (x,y) coordinates of the
cursor.  Thus, I can query the locations of items in my drawing.

SKETCH - A RUN DATASET TO SKETCH A DRAWING                             @

Suppose the following set of subcommands is stored in the PDS allocated
under the SYSRUN dd statement:

    GDDM FSINIT
    GDDM GSILOC 1 0 50 50
    GDDM GSENAB 2 1 1
    CALC SAMECNT#0
    CALC XLAST#YLAST#50
    $UNTIL SAMECNT>=2
      GDDM GSREAD 1 0 0
      GDDM GSQLOC 1 %X %Y
      $IF X=XLAST && Y=YLAST
        CALC SAMECNT#SAMECNT+1
        $IF SAMECNT=1
          NL GDDM GSLINE &X &Y
          * RUN
      $ELSE
        CALC SAMECNT#0
        NL GDDM GSMOVE &XLAST &YLAST
        * RUN
      CALC XLAST#X
      CALC YLAST#Y
    GDDM FSTERM

The SKETCH dataset is designed to let you sketch drawings on the screen
using the graphics cursor to indicate movements of an imaginary pen,
where the screen represents a piece of drawing paper. Suppose you are
currently editing an empty dataset with symbolic name DRAWING, and you
issue the subcommand %%SKETCH.  The screen will clear with the graphics
cursor enabled.  You can do a number of things:

  1.  Using the arrow keys, move the graphics cursor to a new
      location on the screen, and press ENTER twice.  This
      will cause a line to be drawn from the prior location
      to the current location of the cursor.  This is equivalent
      to a move of the imaginary pen while it is touching the
      drawing paper.

  2.  Using the arrow keys, move the graphics cursor to a new
      location on the screen, and press ENTER once.  This is
      equivalent to a move of the imaginary pen while it is not
      touching the drawing paper.

  3.  Without moving the graphics cursor, press ENTER twice.  This
      terminates the execution of SKETCH, and returns you to edit
      mode.

When SKETCH completes, the current dataset will contain a record of
your sketch in the form of a series of GDDM GSMOVE and GSLINE
subcommands, and will appear similar to the following:

                   1         2         3         4         5
          12345678901234567890123456789012345678901234567890123456789

      PF                                          ×DRAWING××175X256.1
      001 GDDM GSMOVE 00050 00050
      002 GDDM GSMOVE 24.305542 75.976563
      003 GDDM GSLINE 31.25 77.148438
      004 GDDM GSMOVE 31.25 77.148438
      005 GDDM GSLINE 38.055557 77.148438
      006 GDDM GSMOVE 38.055557 77.148438
      007 GDDM GSLINE 42.638885 75.585938
      008 GDDM GSMOVE 42.638885 75.585938
      009 GDDM GSLINE 44.444443 72.460938
      010 GDDM GSMOVE 44.444443 72.460938
      (lines omitted for brevity)

You can redisplay the drawing by issuing the subcommand -

      %%gddmshow drawing

GDDMSHOW was described previously in this appendix under the heading
"GDDMSHOW - MAINTAINING OUTPUT INDEPENDENCE".  The resultant display
might look like the following:

.gr 30 DRAWING

GSUWIN GDDM SUBROUTINE - ESTABLISHING UNIFORM AXES SCALES              @

Suppose member WINBOX in the PDS allocated under the ddname SYSRUN
contains the following:

    GDDM GSUWIN 0 150 0 150
    GDDM GSMOVE 0 0
    GDDM GSLINE 100 0
    GDDM GSLINE 100 100
    GDDM GSLINE 0 100
    GDDM GSLINE 0 0

Suppose you print the drawing produced by WINBOX on the IBM 3800 Laser
printer using the GDDM3800 subcommand previously shown (see GDDM IN A
BATCH JOB - OUTPUT TO THE 3800 LASER PRINTER). Knowing what device
token GRAF describes, one could predict that the box drawn will start
In the lower left corner of the page, and will be 5 inches on a side.
Without the GSUWIN statement in WINBOX, the box would be a rectangle 11
inches wide and 7.5 inches tall.

Note however, that neither GSUWIN nor GSWIN may be invoked in a drawing
to be displayed using JCL procedure BOOK3800 (see this appendix under
PRINTING THIS MANUAL - HOW IT'S DONE).  This is because in order to
properly position and scale the drawing, a graphics segment must be
defined prior to doing the drawing.  GSUWIN and GSWIN will fail if
a segment is currently open.

To bypass this problem, a special symbolic variable, &WINDOW, has been
set up.  When either the .gg or .gr print control sequences are
encountered in BOOK3800, before the drawing is printed, the replacement
value for variable &WINDOW is interrogated.  If it is nonblank,  the
GDDM subcommand will be issued before any graphic segments have been
defined for the drawing, specifying as operands the replacement value
for &WINDOW. You can set the replacement value for &WINDOW in your text
stream to BOOK3800 with an inline print control statement .cm, as in
the following example:

    .cm window gswin 0 150 0 150
    .gr 25 drawing1
    .cm window gwuwin 0 300 0 450
    .gr 25 drawing2

If the above text were left-aligned and supplied to procedure BOOK3800,
drawing1 would be printed with window coordinates 0 thru 150 on both
axes.  Drawing2 would be printed with uniform window coordinates
containing the ranges 0 thru 300 and 0 thru 450 for the two axes.

.np
GDDM - DISPLAYING BITMAP USING GDDM                                    @

As documented in Appendix N, ABE provides an interface to PLOT79,
which is a large system of FORTRAN subroutines designed to facilitate
producing graphic drawings.  An internal pixel map, referred to
with the special variable name BITMAP, is maintained using THE PLOT79
interface.  You can access BITMAP for display using the GDDM
subroutine GSIMG, as in the following example, which prints a
12-petalled flower on an IBM3179 graphics terminal:


    GDDM FSINIT
    GDDM GSSEG 0
    GR DEVICE 100 100 720 384 1
      calc points#630
      apl points#&POINTS
      apl theta#(O2)X(Ipoints)%points
      apl r#2O6Xtheta
      apl xarray#1 4`B.5+.5XrX2Otheta
      apl yarray#1 4`B.5+.5XrX1Otheta
      gr plt00
      gr setsz 17.78
      gr mova2 1 .5
      gr plna2 xarray 1 yarray 1 &POINTS
    GDDM GSMOVE 0 100
    GDDM GSIMG 0 720 384 34560 BITMAP
    GDDM ASREAD 0 0 0
    GDDM FSTERM

The resulting picture would look like the following:

.gr 19 PETALS
.np
GDDM - SOME GENERAL EXAMPLES                                           @

Following are listings of several members of my SYSRUN dataset
illustrating the use of GDDM.  The first drawing, called SINECURV, will
be printed as background to the text on this page just to demonstrate
the total flexibility with which drawings can be placed and scaled.
subsequent drawings will generally be printed on separate pages.

  DSN=SYSRUN(SINECURV)
    apl xc#yc#50
    apl radius#45
    apl points#7 4`B400
    apl theta#(O2)Xtmp#(Ipoints)%points
    apl r#radius+(1O(O100)Xtmp)X.1Xradius
    apl xarray#1 4`Bxc+rX2Otheta
    apl yarray#1 4`Byc+rX1Otheta
    apl xs#1 4`B1Yxarray
    apl ys#1 4`B1Yyarray
    gddm gsmove xs ys
    gddm gsplne points xarray yarray
    gddm gsline xs ys

.gg 5 1 50 71 SINECURV

  DSN=SYSRUN(ARROWS)
    CALC ANGLE#0
    $UNTIL 360<ANGLE#ANGLE+10
      %%ARROW 50 50 (50*ANGLE/360) &ANGLE
  DSN=SYSRUN(ARROW)
    $* P1,P2 = (X,Y) COORDINATES OF STARTING POINT
    $* P3=LENGTH OF ARROW
    $* P4=ANGLE OF ARROW
    $* P5=PROPORTION OF LENGTH FOR ARROWHEAD WIDTH
    $IF P5=0
      CALC P5#.05
    GDDM GSMOVE &P1 &P2
    GDDM GSLINE (P1+P3*COSD(P4)) (P2+P3*SIND(P4))
    GDDM GSQCP %P6 %P7
    GDDM GSLINE (P6+P5*P3*COSD(MOD(P4+135,360))) +
                (P7+P5*P3*SIND(MOD(P4+135,360)))
    GDDM GSMOVE &P6 &P7
    GDDM GSLINE (P6+P5*P3*COSD(MOD(P4+225,360))) +
                (P7+P5*P3*SIND(MOD(P4+225,360)))

.gr 999 ARROWS
  DSN=SYSRUN(LOGO)
    $* kc logo
    $* p1=1 if solid version of logo is to be generated
    $* p2=reduction factor
    $* p3=gridsize
    $if p2=0
      calc p2#1
    gddm gsuwin 0 (p2*100) 0 (p2*100)
    gddm gsclp 1
    calc blue#1
    calc white#-2
    $if p1
      $call solid
    $else
      $call outline
    $if p3^=0
      %%grid &P3 &BLUE
    $return
    $return
    $ solid
      $* produces the logo in solid form
      calc span#100/29
      apl span#100%29
      gddm gslw 1
      calc xcenter#50
      calc ycenter#span*1.5+minaxis#span*(24.5-1.5)/2
      calc majaxis#27*span/2
      gddm gscol (blue)
      gddm gsarea 1
      $call ellipse
      gddm gsenda
      gddm gscol (white)
      gddm gsarea 1
      calc s#-1
      apl s#_1
      $call insolid
      calc s#1
      apl s#1
      $call insolid
      gddm gsenda
      $return
    $ insolid
      $* draw contained figure
      gddm gsmove 50              (22*span)
      gddm gsline (50+s*2.5*span) (22*span)
      gddm gsline (50+s*2.5*span) (15*span)
      apl xin#1 4`B   02.50 03.00 05.44
      apl xin#1 4`B   50+spanXsXxin
      apl yin#1 4`B   15.00 16.03 18.00
      apl yin#1 4`B   spanXyin
      apl count#7 4`BRxin
      gddm gspflt count xin yin
      gddm gsline (50+s*11*span) (18*span)
      apl xin#1 4`B   11.00  8.44  7.42  6.68  6.46  7.43  8.89 11.50
      apl xin#1 4`B   50+spanXsXxin
      apl yin#1 4`B   18.00 16.03 15.01 13.99 12.97 12.01 12.00 12.00
      apl yin#1 4`B   spanXyin
      apl count#7 4`BRxin
      gddm gspflt count xin yin
      gddm gsline (50+s*11.5*span) (8*span)
      gddm gsline (50+s*6.5*span)  (8*span)
      %%arc 2 (50+s*6.5*span) (8*span) (50+s*2.5*span) (10*span) +
        (50+s*6.5*span) (9*span)
      gddm gsline (50+s*2.5*span) (5*span)
      gddm gsline 50 (5*span)
      $return
    $ outline
      $* this produces the logo in outline form
      $* draw containing elipse
        calc span#100/25
        gddm gslw 1
        gddm gscol (blue)
        calc xcenter#50
        calc ycenter#47
        calc majaxis#48
        calc minaxis#41
        gddm gsarea 1
        $call ellipse
        calc majaxis#44
        calc minaxis#37
        $call ellipse
        gddm gsenda
        gddm gscol (white)
        gddm gsarea 1
        $call ellipse
        gddm gsenda
      $* now draw contained figure
        gddm gscol (blue)
        gddm gsarea 1
        calc s#-1
        apl s#_1
        $call outer
        calc s#+1
        apl s#1
        $call outer
        gddm gsenda
        gddm gscol (white)
        gddm gsarea 1
        calc s#-1
        apl s#_1
        $call inner
        calc s#+1
        apl s#1
        $call inner
        gddm gsenda
        $return
    $ inner
    $* draw inner edge of contained figure
      gddm gsmove 50 72
      gddm gsline (50+s*6) 72
      gddm gsline (50+s*6) 47
      %%arc 2 (50+s*6) 47 (50+s*10) 54 (50+s*14) 44
      %%arc 2 (50+s*10) 54 (50+s*17.2) 60 (xc) (yc)
      gddm gsline (50+s*27.7) 60
      apl xin#1 4`B   27.70 23.44 19.92 18.16 18.36 22.07 25.98 33.98
      apl xin#1 4`B50+sXxin
      apl yin#1 4`B20Y60.00 56.05 52.15 47.85 43.95 40.43 40.00 40.00
      apl count#7 4`BRxin
      gddm gspflt count xin yin
      gddm gsline (50+s*34) 32
      gddm gsline (50+s*18) 32
      %%arc 2 (50+s*18) 32 (50+s*6) 41 (50+s*18) 33
      gddm gsline (50+s*6) 23
      gddm gsline 50 23
      $return
    $ outer
    $* draw outer edge of contained figure
      gddm gsmove 50 76
      gddm gsline (50+s*10) 76
      gddm gsline (50+s*10) 59
      %%arc 2 (50+s*10) 59 (50+s*15.6) 64 (50+s*15.8) 54
      gddm gsline (50+s*38.67) 64
      apl xin#1 4`B38.67 33.98 30.08 25.98 22.85 23.05 25.59 30.08 37.89
      apl xin#1 4`B50+sXxin
      apl yin#1 4`B64.00 60.16 56.45 52.93 48.44 45.31 44.34 44.00 44.00
      apl count#7 4`BRxin
      gddm gspflt count xin yin
      gddm gsline (50+s*38) 44
      gddm gsline (50+s*38) 28
      gddm gsline (50+s*18) 28
      %%arc 2 (50+s*18) 28 (50+s*10) 30.8 (50+s*18) 29
      gddm gsline (50+s*10) 19
      gddm gsline 50 19
      $return
    $ ellipse
      gddm gsmove (xcenter+majaxis) (ycenter)
      gddm gselps (majaxis) (minaxis) 0 (xcenter-majaxis) (ycenter)
      gddm gselps (majaxis) (minaxis) 0 (xcenter+majaxis) (ycenter)
      gddm gsline (xcenter+majaxis) (ycenter)
      $return
.gr 43 LOGO

Note that the above KC LOGO was printed using the print control
statement ".gr 43 LOGO".  The value 43 is critical because it gives
the drawing the proper aspect ratio.
.np
  DSN=SYSRUN(RINGS)
    $* SET NO TO NUMBER OF RINGS TO DISPLAY
    CALC NO#36
    $* SET RAD TO RADIUS OF EACH RING
    CALC RAD#20
    $*
    GDDM GSCOL 2
    GDDM GSLW 2
    CALC INCR#360/NO
    CALC THETA#0
    CALC COLOR#0
    $UNTIL 360<THETA#THETA+INCR
      GDDM GSCOL &COLOR
      CALC CX#50+COSD(THETA)*RAD
      CALC CY#50+SIND(THETA)*RAD
      CALC SX#50+COSD(THETA)*RAD*2
      CALC SY#50+SIND(THETA)*RAD*2
      GDDM GSMOVE &SX &SY
      GDDM GSARC &CX &CY 360
      CALC COLOR#MOD(COLOR+1,8)
.gr 999 RINGS
  DSN=SYSRUN(SPIRAL)
    $* INCR IS DEGREES TO INCREMENT ANGLE EACH ITERATION
    CALC INCR#10
    $* TURNS IS NUMBER OF TURNS IN SPIRAL
    CALC TURNS#10
    GDDM GSLW 2
    $CALL SUBRTNE
    $* CALC INCR#-INCR
    $* $CALL SUBRTNE
    $RETURN
    $ SUBRTNE
      CALC RADIUS#ANGLE#0
      GDDM GSMOVE 50 50
      $WHILE RADIUS<45
        CALC ANG#MOD(ANGLE#ANGLE+INCR,360)
        CALC RADIUS#50*ABS(ANGLE)/(TURNS*360)
        GDDM GSCOL (MOD(ABS(ANGLE)/360,8))
        GDDM GSLINE  (50+RADIUS*COSD(ANG)) (50+RADIUS*SIND(ANG))
      $RETURN
.gr 999 SPIRAL
  DSN=SYSRUN(GDDMFONT)
    LO
    CALC I#0
    CALC HEIGHT#WIDTH#4
    SETL PREF ADMUW
    $CALL SUBRTNE
    CALC WIDTH#2
    SETL PREF ADMUV
    $CALL SUBRTNE
    $RETURN
    $ SUBRTNE
    CALC J#(I^=0)*11
    $WHILE (J+12)>I#I+1
      CALC K#I-J
      $SELECT
        $WHEN K=1
          SETL FONT ARP
        $WHEN K=2
          SETL FONT CIP
        $WHEN K=3
          SETL FONT CRP
        $WHEN K=4
          SETL FONT CSP
        $WHEN K=5
          SETL FONT DRP
        $WHEN K=6
          SETL FONT GEP
        $WHEN K=7
          SETL FONT GGP
        $WHEN K=8
          SETL FONT GIP
        $WHEN K=9
          SETL FONT SRP
        $WHEN K=10
          SETL FONT TIP
        $WHEN K=11
          SETL FONT TRP
      SETL FONTNAM &PREF&FONT
      GDDM GSLSS 2 '&FONTNAM  ' 194
      GDDM GSCS 194
      GDDM GSCM 3
      GDDM GSCB &WIDTH &HEIGHT
      GDDM GSCHAR 0 (100-I*HEIGHT) 28 '&FONTNAM - Thomas Glen Smith  '
      GDDM GSRSS 2 194
      $RETURN
.gr 999 GDDMFONT
  DSN=SYSRUN(SOMEBUGS)
    %%BUGIMAGE
    CALC I#0
    $WHILE 30>I#I+1
      GDDM GSCOL (INT(RND(-1)*8))
      GDDM GSMOVE (10+RND(-1)*80) (10+RND(-1)*80)
      GDDM GSIMG 0 48 33 198 IMAGE
  DSN=SYSRUN(BUGIMAGE)
    A IMAGE END N
    ABE '' NAME(IMAGE) HEX SUPPORT
    A IMAGE NL 000000000000000000000000000000000000000000000000
    A IMAGE NL 000000000000000000000000010000000000000000000000
    A IMAGE NL 000000000000100000000000010000000000000000000000
    A IMAGE NL 000000000000010000000000100000000000000000000000
    A IMAGE NL 000000000000010000000001000000000000000000000000
    A IMAGE NL 000000000000010000000010000000000000000000000000
    A IMAGE NL 000000000000010000000100000000000000000000000000
    A IMAGE NL 000000000000010000001000000000000000000000000000
    A IMAGE NL 000000000000010000001000000000000000000000000000
    A IMAGE NL 000000000000001000001000000000000000000000000000
    A IMAGE NL 000000000000001000001000000110000000000000000000
    A IMAGE NL 000000000000000100001000011111000000000011000000
    A IMAGE NL 000000000000000100001000011111000000000100000000
    A IMAGE NL 100000000000000010001000011111000000011000000000
    A IMAGE NL 011111111100000010111111111110000000100000000000
    A IMAGE NL 000000000011000011111111110000000011000000000000
    A IMAGE NL 000000000000110111111111110000000100000000000000
    A IMAGE NL 000000000000001111111111111111111000000000000000
    A IMAGE NL 000000000000001111111111110000000000000000000000
    A IMAGE NL 000000000000001111111111110000000000000000000000
    A IMAGE NL 000000001111111111111111110000000000000000000000
    A IMAGE NL 000000110000001111111111101110000000000000000000
    A IMAGE NL 000011000000000111111110000001110000000000000000
    A IMAGE NL 011100000000000011111010000000001111111111000000
    A IMAGE NL 000000000000000000100001100000000000000000000000
    A IMAGE NL 000000000000000000100000010000000000000000000000
    A IMAGE NL 000000000000000000100000001000000000000000000000
    A IMAGE NL 000000000000000000010000000100000000000000000000
    A IMAGE NL 000000000000000000010000000100000000000000000000
    A IMAGE NL 000000000000000000010000000100000000000000000000
    A IMAGE NL 000000000000000000100000000100000000000000000000
    A IMAGE NL 000000000000000001000000000010000000000000000000
    A IMAGE NL 000000000000000001000000000000000000000000000000
    A IMAGE CONVERT CHAR(1 48) BIT(49 6)
    A IMAGE SL 48
    A IMAGE JOIN 33
.gr 999 SOMEBUGS
.gr 999 squares .1 1
  DSN=SYSRUN(SQUARES)
    $* P1=INCR, P2=1 IF NOFILL, P2=2 IF JUST SPIRAL
    $if p1^=0
      calc incr#p1
    $else
      calc incr#.1
    $if p2=2
      calc jlim#4
    $else
      calc jlim#3
    gddm gsuwin 0 100 0 100
    calc angle#col#0
    calc xs#90+x#y#ys#5
    $until r<1
      $if p2=0
        gddm gscol ((col#mod(col+1,7)))
        gddm gsarea 1
      gddm gsmove &X &Y
      calc r#sqrt((xs-x)**2+(ys-y)**2)
      calc angle#atan(ys-y,xs-x)
      calc xn#x
      calc yn#y
      calc j#0
      $until jlim=j#j+1
        calc i#angle+j*1.570796
        calc xt#xn+incr*r*cos(i)
        calc yt#yn+incr*r*sin(i)
        $if j=1
          calc xs#xt
          calc ys#yt
        calc xn#xn+r*cos(i)
        calc yn#yn+r*sin(i)
        $if p2=2
          gddm gscol &J
          gddm gsline &XT &YT
          gddm gsmove &XN &YN
        $else
          gddm gsline &XN &YN
      $if p2^=2
        gddm gsline &X &Y
        $if p2=0
         gddm gsenda
      calc x#x+incr*r*cos(angle)
      calc y#y+incr*r*sin(angle)

PRINTING THIS MANUAL - HOW IT'S DONE                                   @

Following is the job deck I use for printing this manual.  Note that
the first step executes SAS (Trademark of SAS Institute).  This is
to produce the drawing on the page in this appendix titled
"GDDMSASR - SAS/GRAPH OUTPUT IN A DOCUMENT."

    //<userid> JOB ....
    //COWBOY   EXEC SAS
    //FT14F001 DD  DSN=&COWBOY,DISP=(NEW,PASS),
    //             UNIT=DISK,SPACE=(TRK,(20,20),RLSE),
    //             DCB=(LRECL=84,BLKSIZE=18960,RECFM=VBS)
    //FT06F001 DD  SYSOUT=*
    //SYSIN    DD  DSN=X75826.SAS.CARDS(COWBOY),DISP=SHR
    //STEP1   EXEC BOOK
    //SYSRUN  DD   DSN=X75826.SYSRUN,DISP=SHR
    //IN1     DD   DSN=X75826.ABE.TEXT,DISP=SHR
    //OUT1    DD   DSN=&OUT1,DISP=(NEW,PASS),UNIT=DISK,
    //             SPACE=(CYL,(10,10),RLSE),DCB=*.CONTENT
    //IN2     DD   DSN=X75826.ABE.HELP,DISP=SHR
    //OUT2    DD   DSN=&OUT2,DISP=(NEW,PASS),UNIT=DISK,
    //             SPACE=(CYL,(10,10),RLSE),DCB=*.CONTENT
    //IN3     DD   DSN=X75826.ABE.APPENDIX.A.TEXT,DISP=SHR
    //OUT3    DD   DSN=&OUT3,DISP=(NEW,PASS),UNIT=DISK,
    //             SPACE=(CYL,(10,10),RLSE),DCB=*.CONTENT
    .
    . (lines omitted for brevity)
    .
    //IN17    DD   DSN=X75826.ABE.APPENDIX.O.TEXT,DISP=SHR
    //OUT17   DD   DSN=&OUT17,DISP=(NEW,PASS),UNIT=DISK,
    //             SPACE=(CYL,(10,10),RLSE),DCB=*.CONTENT
    //COVER   EXEC GDDM3800,RUN=ABEHDR
    //SYSRUN   DD DSN=X75826.SYSRUN,DISP=SHR
    //         DD DSN=SYS2.CNTCARD,DISP=SHR
    //PRINT   EXEC BOOK3800,REGION=6500K,PITCH=10
    //DOCIN   DD  DSN=&&CONTENT,DISP=(OLD,DELETE)
    //        DD  DSN=&&OUT1,DISP=(OLD,DELETE)
    .
    . (lines omitted for brevity)
    .
    //        DD  DSN=&&OUT17,DISP=(OLD,DELETE)
    //        DD  DSN=&&INDEX,DISP=(OLD,DELETE)
    //SYSRUN  DD  DSN=X75826.SYSRUN,DISP=SHR
    //FT14F001 DD  DSN=&COWBOY,DISP=(OLD,DELETE)
    //DRAWING1 DD  DSN=X75826.ABE.DRAWING1,DISP=SHR

The GDDM3800 JCL procedure used in the above job deck is documented
in this appendix under the heading "GDDM IN A BATCH JOB - OUTPUT TO
THE 3800 LASER PRINTER."  The other JCL procedures BOOK and BOOK3800
and related datasets are printed below:

  DSN=SYS2.PROCLIB(BOOK)
    //BOOK     PROC
    //*****************************************************************
    //*                                                               *
    //* From one or more input datasets containing text and           *
    //* instructions, this procedure will produce a document,         *
    //* complete with numbered pages, heading lines, a Table of       *
    //* Contents, and an Index. If the document is to be printed on   *
    //* the IBM3800 Laser Printer, it may contain graphic drawings    *
    //* in addition to text.                                          *
    //*                                                               *
    //* Text is taken from the first 71 positions of each input       *
    //* record. Any line of text with an @ character in position 72   *
    //* will appear in the Table of Contents and the Index, as well   *
    //* as in the body of the document.                               *
    //*                                                               *
    //* Instructions may be interspersed with the text in the input   *
    //* dataset, controlling such things as heading line              *
    //* information and the placement of graphic drawings.  All such  *
    //* instructions begin with a period in record position 1.  A     *
    //* list of instructions follows:                                 *
    //*                                                               *
    //* .cm <command> <operands>                                      *
    //*   This command is ignored in the BOOK procedure, but is left  *
    //*   intact in the text because it is recognized when the text   *
    //*   is processed in the BOOK3800 procedure.                     *
    //* .gg <line1> <charpos1> <line2> <charpos2> <command>           *
    //*   Also specifies a graphics drawing, with more flexibility    *
    //*   in placement than with the .gr instruction.  See the ABE    *
    //*   manual, Appendix O, heading "PRINT CONTROL STATEMENT .GG,"  *
    //*   or call Tom Smith at 8-2174.                                *
    //* .gr <nnn> <command>                                           *
    //*   Specifies a graphics drawing is to be placed in the         *
    //*   document at this point.  See the ABE manual, Appendix O,    *
    //*   heading "PRINT CONTROL STATEMENT .GR."  The .gr statement   *
    //*   may also be used for inserting SAS/GRAPH output in a        *
    //*   document.  See the ABE manual, Appendix O, heading          *
    //*   "SAS/GRAPH OUTPUT IN A DOCUMENT - GDDMSASR."                *
    //* .he <Heading information>                                     *
    //*   Specifies information to be printed at the top of each      *
    //*   page.                                                       *
    //* .im <ddname>                                                  *
    //*   Specifies ddname associated with a file containing a        *
    //*   graphics image to be included on the current page.          *
    //* .in <include_spec>                                            *
    //*   The INCLUDE subcommand of ABE will be issued with           *
    //*   <include_spec> as operands, and the included text will      *
    //*   replace the .in statement in the dataset.                   *
    //* .ni <n>                                                       *
    //*   Specifies that a new page is to be started if at least <n>  *
    //*   lines don't remain on the current page.                     *
    //* .np                                                           *
    //*   Specifies that a new page is to be started.  Otherwise, a   *
    //*   new page is started after every 55 lines of input text.     *
    //*                                                               *
    //* The BOOK procedure accepts it's input from one or more        *
    //* datasets with ddnames of the form "//in<n> dd ..." where <n>  *
    //* is a number, e.g. for three input datasets, the ddnames       *
    //* would be IN1, IN2, and IN3.  This is useful when the manual   *
    //* is large, because it can be broken up into smaller, more      *
    //* manageable chunks.  For each IN<n> DD statement, there must   *
    //* also be a corresponding OUT<n> DD statement.                  *
    //*                                                               *
    //* A sample job deck follows:                                    *
    //*                                                               *
    //* RECORD POSITION 1                          RECORD POSITION 72 *
    //* ×                                                           × *
    //* ×                                                           × *
    //* V                                                           V *
    //* //STEP1 EXEC BOOK                                             *
    //* //OUT1 DD DSN=&OUT1,DISP=(NEW,PASS),                          *
    //* //        UNIT=DISK,SPACE=(TRK,(1,1)),                        *
    //* //        DCB=*.CONTENT                                       *
    //* //IN1 DD *                                                    *
    //* .he Sample Document                                           *
    //* INTRODUCTION                                                @ *
    //* This is a sample document to illustrate use of the BOOK       *
    //* procedure.  A ".np" instruction is next to force a new page.  *
    //* .np                                                           *
    //* BODY                                                        @ *
    //* This is the main body of the sample document.                 *
    //* CONCLUSION                                                    *
    //* This is the conclusion of the sample document.              @ *
    //* //STEP2 EXEC PGM=IEBGENER                                     *
    //* //SYSPRINT DD DUMMY                                           *
    //* //SYSIN DD DUMMY                                              *
    //* //SYSUT1 DD DSN=&CONTENT,DISP=(OLD,DELETE)                    *
    //* //       DD DSN=&OUT1,DISP=(OLD,DELETE)                       *
    //* //       DD DSN=&INDEX,DISP=(OLD,DELETE)                      *
    //* //SYSUT2 DD SYSOUT=*,CHARS=TN,DCB=*.SYSUT1                    *
    //*                                                               *
    //* The results, with carriage control in record position 1,      *
    //* follows:                                                      *
    //*                                                               *
    //* RECORD POSITION 1                          RECORD POSITION 72 *
    //* ×                                                           × *
    //* ×                                                           × *
    //* V                                                           V *
    //* 1                                                             *
    //*  TABLE OF CONTENTS                                            *
    //*  INTRODUCTION-----------------------------------------------1 *
    //*  BODY-------------------------------------------------------2 *
    //*  CONCLUSION-------------------------------------------------2 *
    //*  INDEX                                                      3 *
    //* 1                                                             *
    //* 1Sample Document                                      PAGE  1 *
    //*                                                               *
    //*                                                               *
    //*  INTRODUCTION                                                 *
    //*  This is a sample document to illustrate use of the BOOK      *
    //*  procedure.  A ".np" instruction is next to force a new       *
    //*  page.                                                        *
    //* 1Sample Document                                      PAGE  2 *
    //*                                                               *
    //*                                                               *
    //*  BODY                                                         *
    //*  This is the main body of the sample document.                *
    //*  CONCLUSION                                                   *
    //*  This is the conclusion of the sample document.               *
    //* 1INDEX                                                PAGE  3 *
    //*                                                               *
    //*                                                               *
    //*                                                               *
    //*  INDEX                                                        *
    //*  BODY-------------------------------------------------------2 *
    //*  CONCLUSION-------------------------------------------------2 *
    //*  INTRODUCTION-----------------------------------------------1 *
    //* 1INDEX                                                PAGE  4 *
    //*                                                               *
    //*****************************************************************
    //BOOK     EXEC PGM=ABEB,REGION=4000K,DYNAMNBR=30
    //SYSPRINT DD  SYSOUT=*
    //OUT      DD  SYSOUT=*,DCB=(LRECL=80,BLKSIZE=80,RECFM=FA)
    //IN       DD  DSN=SYS2.CNTCARD(BOOK),DISP=SHR
    //CONTENT  DD  DSN=&&CONTENT,DISP=(NEW,PASS),
    //             UNIT=DISK,SPACE=(CYL,(1,1)),
    //             DCB=(LRECL=81,BLKSIZE=19035,RECFM=FBA)
    //INDEX    DD  DSN=&&INDEX,DISP=(NEW,PASS),
    //             UNIT=DISK,SPACE=(CYL,(1,1)),
    //             DCB=(LRECL=81,BLKSIZE=19035,RECFM=FBA)

  DSN=SYS2.CNTCARD(BOOK)
    $CMD PGM ABEBOOK

  DSN=SYS2.PROCLIB(BOOK3800)
    //BOOK3800 PROC PITCH=' ',LINE=' ',ANGLE=' ',LP=' ',EDGE=' ',
    // COPIES=1,BURST=N,FORM=STD
    //*****************************************************************
    //*                                                               *
    //* BOOK3800 can be used to print a document on the IBM           *
    //* 3800 Laser Printer.  Depending of the values for keywords     *
    //* PITCH, LINE, ANGLE, and LP (stands for Logical Pages Per      *
    //* Physical Page), text will be printed in various forms on the  *
    //* page, e.g. with lines of text running either across (ANGLE=0) *
    //* or down (ANGLE=-90) the physical page.  The following table   *
    //* gives acceptable values for various combinations of           *
    //* keyword values, and the resulting number of text lines        *
    //* printed per logical page:                                     *
    //*                                                               *
    //*                      LOGICAL PAGES                            *
    //*                      PER PHYSICAL  LINE      LINES PER        *
    //* FORM  PITCH LINESIZE PAGE          DIRECTION LOGICAL PAGE     *
    //*                                                               *
    //* STD   20    1-71     4             -90       60               *
    //* STD   20    1-106    4             0         39               *
    //* STD   20    1-148    1             -90       123              *
    //* STD   20    1-218    1             0         81               *
    //* STD   10    1-71     1             -90       60               *
    //* STD   10    1-106    1             0         39               *
    //*                                                               *
    //* 009X  20    1-100    4             -90       51               *
    //* 009X  20    1-85     4             0         60               *
    //* 009X  20    1-200    1             -90       102              *
    //* 009X  20    1-170    1             0         120              *
    //* 009X  10    1-50     4             -90       25               *
    //* 009X  10    1-42     4             0         30               *
    //* 009X  10    1-100    1             -90       51               *
    //* 009X  10    1-85     1             0         60               *
    //*                                                               *
    //* Keyword EDGE may be set to either 0 or 1.  If EDGE=1, a       *
    //* line will be drawn around the border of each page.            *
    //*                                                               *
    //* The procedure expects ASA carriagle control to be in          *
    //* position 1 of each record.                                    *
    //*                                                               *
    //* Instructions controlling the production of graphic drawings   *
    //* via GDDM and ABE may be interspersed with the text in the     *
    //* input dataset.  All such instructions begin with a period in  *
    //* record position 1.  Format for the possible intructions       *
    //* are listed below:  See the ABE manual, Appendix O, heading    *
    //* "PRINTING THIS MANUAL - HOW IT'S DONE," or call Tom Smith at  *
    //* 8-2174.                                                       *
    //*                                                               *
    //* .cm <command> <operands>                                      *
    //*   The RUN subcommand of ABE will be issued for <command> with *
    //*   the specified <operands>.  <command> should be a member of  *
    //*   a partitioned dataset allocated to this step under the      *
    //*   ddname SYSRUN.  See the AB$E manueal for more details.      *
    //* .im <ddname>                                                  *
    //*   Specifies the ddname associated with a file containing a    *
    //*   graphics image to be included on the current page.          *
    //* .gr <nnn> <command>                                           *
    //*   Specifies a graphics drawing is to be placed in the         *
    //*   document at this point.                                     *
    //* .gg <line1> <charpos1> <line2> <charpos2> <command>           *
    //*   Also specifies a graphics drawing, with more flexibility    *
    //*   in placement than with the .gr instruction.                 *
    //*                                                               *
    //* BOOK3800 is set up to work in conjunction with procedure      *
    //* BOOK, also in SYS2.PROCLIB.  A sample job deck follows:       *
    //*                                                               *
    //*                                                               *
    //* //STEP1 EXEC BOOK                                             *
    //* //OUT1 DD DSN=&OUT1,DISP=(NEW,PASS),                          *
    //* //        UNIT=DISK,SPACE=(TRK,(1,1)),                        *
    //* //        DCB=*.CONTENT                                       *
    //* //IN1 DD *                                                    *
    //* .he Sample Document                                           *
    //* INTRODUCTION                                                @ *
    //* This is a sample document to illustrate use of the BOOK       *
    //* procedure.  A ".np" instruction is next to force a new page.  *
    //* .np                                                           *
    //* BODY                                                        @ *
    //* This is the main body of the sample document.                 *
    //* CONCLUSION                                                    *
    //* This is the conclusion of the sample document.              @ *
    //* //STEP2 EXEC BOOK3800                                         *
    //*                                                               *
    //*****************************************************************
    //BOOK3800 EXEC PGM=ABEB,REGION=5000K,DYNAMNBR=30,
    // PARM='PI(&PITCH) LI(&LINE) AN(&ANGLE) LP(&LP) BO(&EDGE)
      FO(&FORM)'
    //STEPLIB  DD  DSN=SYS1.GDDMLOAD,DISP=SHR
    //ADMSYMBL DD  DSN=SYS1.GDDMSYM,DISP=SHR
    //ADMDEFS  DD  DSN=SYS2.CNTCARD(ADMDEFS),DISP=SHR
    //SYSPRINT DD  SYSOUT=*
    //OUT1     OUTPUT PRMODE=PAGE,PAGEDEF=090C0,FORMDEF=0101
    //DOCOUT   DD  SYSOUT=(A,,&FORM),OUTPUT=(*.OUT1),
    //             COPIES=&COPIES,BURST=&BURST,
    //             DCB=(LRECL=2004,BLKSIZE=2008,RECFM=VA)
    //DOCIN    DD  DSN=&&CONTENT,DISP=(OLD,DELETE)
    //         DD  DSN=&&OUT1,DISP=(OLD,DELETE)
    //         DD  DSN=&&INDEX,DISP=(OLD,DELETE)
    //SYSRUN   DD  DSN=SYS2.CNTCARD,DISP=SHR
    //IBM3800  DD  UNIT=DISK,SPACE=(CYL,(5,1)),
    //             DCB=(LRECL=2004,BLKSIZE=19000,RECFM=VBA)
    //OUT      DD  SYSOUT=*,DCB=(LRECL=80,BLKSIZE=80,RECFM=F)
    //IN       DD  DSN=SYS2.CNTCARD(BOOK3800),DISP=SHR
    //INTERO   DD  DSN=U.TC.INTERO.IMAGE,DISP=SHR

  DSN=SYS2.CNTCARD(ADMDEFS)
     ADMMNICK NAME=IBM3800,DEVTOK=FINEGRAF,
       PROCOPT=((HRISWATH,3),(HRISPILL,NO))

  DSN=SYS2.CNTCARD(BOOK3800)
    $CONTROL LIST
    $IF '&PI'=' '
      $CMD SETL PI 20
    $IF '&LI'=' '
      $CMD SETL LI 71
    $IF '&AN'=' '
      $IF (PI=20 && LI<149) × (PI=10 && LI<72)
        $CMD SETL AN -90
      $ELSE
        $CMD SETL AN 0
    $IF '&LP'=' '
      $IF PI=20 && LI<=71
        $CMD SETL LP 4
      $ELSE
        $CMD SETL LP 1
    $IF '&BO'=' '
      $CMD SETL BO 1
    $CMD PGM ABE3800 &PI &LI &AN &LP &BO &FO

PRINT CONTROL STATEMENT .GR                                            @

In the previous section titled "PRINTING THIS MANUAL - HOW IT'S DONE"
reference was made to the .gr print control statement, used for
generating graphics drawings in a document.  Format for the .GR
statement is -

  .gr <nnn> <command>

where -
  <nnn> is the number of print lines on the current page to be reserved
    for the drawing.  The drawing will be scaled to have a height
    equivalent to the specified number of lines.  Its width will always
    be scaled to fit between the left and right margins of the page. If
    there aren't sufficient lines remaining on the current page, a new
    page is defined.  If 999 is specified for <nnn>, the drawing will
    occupy an entire page.
  <command> - This string of text will be inserted in the string
    "%%gddm3800 abeqtr <n> cmd(<cmd>)" in place of "<cmd>" and the
    result will be executed as an ABE subcommand.  GDDM3800 is stored
    in SYS2.CNTCARD, and a listing of it appears in this appendix
    under the heading "GDDM IN A BATCH JOB - OUTPUT TO THE 3800 LASER
    PRINTER."  ABEQTR is also in SYS2.CNTCARD.  It is listed below:

    DSN=SYS2.CNTCARD(ABEQTR)
      $* P1=1 THRU 4 IF QUADRANT IS DESIRED.
      $* IF P1=5 THEN (P2,P3) (P4,P5) ARE COORDINATES OF LOWER LEFT AND
      $* UPPER RIGHT CORNERS OF DESIRED AREA.  VALUES RANGE FROM 0 TO 1.
      $* P6=0 IF DRAWING IS TO BE ROTATED -90 DEGREES, AND =1 IF NOT.
      $* CMD(<CMD>) INDICATES DRAWING TO BE DISPLAYED.
      $* WINDOW(<WIN>) INDICATES GDDM WINDOW COMMAND TO BE ISSUED.
      GDDM GSQPS %WIDTH %HEIGHT
      $* NOW SET UP WINDOW FOR APPROPRIATE QUARTER
        $SELECT
          $WHEN P1=1
            GDDM GSVIEW (.5*WIDTH) (WIDTH-.001) (.5*HEIGHT) (HEIGHT-.001
          $WHEN P1=2
            GDDM GSVIEW (.5*WIDTH) (WIDTH-.001) 0 (.5*HEIGHT)
          $WHEN P1=3
            GDDM GSVIEW 0 (.5*WIDTH) (.5*HEIGHT) (HEIGHT-.001)
          $WHEN P1=4
            GDDM GSVIEW 0 (.5*WIDTH) 0 (.5*HEIGHT)
          $OTHERWISE
            GDDM GSVIEW (P2*WIDTH) (MIN(WIDTH-.001,P4*WIDTH)) +
                        (P3*HEIGHT) (MIN(HEIGHT-.001,P5*HEIGHT))
      $* NOW PRODUCE PICTURE.
        GDDM GSCLP 1
        $IF '&WINDOW'^=''
          GDDM &WINDOW
          SETL WINDOW ''
        $IF P6=0
          GDDM GSSATI 4 2
          GDDM GSQWIN %U1 %U2 %V1 %V2
          $* ESTABLISH INITIAL SCALE TO PREVENT CLIPPING LOSSES.
          CALC P7#MIN(U1,V1)
          CALC P8#MAX(U2,V2)
          GDDM GSWIN &P7 &P8 &P7 &P8
          CALC P9#(U2-U1)
          CALC P10#(V2-V1)
        GDDM GSSEG &P1
        %%&CMD
        GDDM GSSCLS
        $IF P6=0
          GDDM GSSORG &P1 &P7 &P7
          CALC P11#(P8-P7)
          GDDM GSSAGA &P1 (P9/P11) (P10/P11) 0 1 0 -1 0 &P11 0

Numerous examples of the use of the .gr statement appear in this
appendix.  For example, see the heading "GDDM SAMPLE #1 - THE
ENVELOPE."  The drawing produced there was a result of the following
statement appearing in the text for this appendix, with the initial
period beginning in column 1:

  .gr 30 ENVELOPE

PRINT CONTROL STATEMENT .GG                                            @

In a previous section titled "PRINTING THIS MANUAL - HOW IT'S DONE"
reference was made to the .gg print control statement, used for
generating graphics drawings in a document.  The .gg statement
functions very similarly to the .gr statement just previously
described.  The difference is that .gg allows you to scale the drawing
to any dimensions you desire, and it also allows you to place the
drawing anywhere on the current page.

format for the .GG statement is -

  .gg <line1> <charpos1> <line2> <charpos2> <command>

shere -
  <command> is the same as for the .gr statement just previously
    described.
  <line1> identifies the print line on the page where the top of the
    drawing is to begin.  This may be in the form of an absolute
    line number (e.g. 50), or it may be relative to the current line,
    e.g. * refers to the current line, *-1 refers to the previous
    line, and *+2 refers to the second line down from the current
    line.
  <charpos1> identifies the character position from the left page
    margin where the left side of the drawing is to begin.
  <line2> identifies the print line on the page where the bottom of
    the drawing is to begin, and is similar in syntax to <line1>.
  <charpos2) identifies the character position from the left page
    margin where the right side of the drawing is to begin.

Several examples of the use of the .gg statement appear in this
appendix. One appears on the page headed "GDDM - SOME GENERAL EXAMPLES"
and is the drawing called SINECURV.  The .gg statement producing that
drawing is as follows:

  .gg 5 1 50 71 SINECURV

Two more examples of the use of .gg appear in this appendix under the
reading "GD AND GU SUBCOMMANDS - IBM GRAPHICS LANGUAGE."
.np
GDDMSASR - SAS/GRAPH OUTPUT IN A DOCUMENT                              @

Following is a drawing produced by SAS/GRAPH (trademark of SAS
Institute, Inc.):

.gr 30 gddmsasr

The .gr statement producing the above graph is -

  .gr 30 gddmsasr

If you review the JCL in the appendix under the heading "PRINTING THIS
MANUAL - HOW IT'S DONE" you will see that the first step executes
SAS.  The SYSIN dataset to SAS is as follows:

  DSN=X75826.SAS.CARDS(COWBOY)
    GOPTIONS DEVICE=COMPLOT NOCHARACTERS NOCELL HSIZE=10 VSIZE=10
      NOTEXT82;
    DATA;
      DO X=-5 TO 5 BY .25;
        DO Y=-5 TO 5 BY .25;
          Z=SIN(SQRT(X*X+Y*Y));
          OUTPUT;
          END;
        END;
    PROC G3D;
      TITLE C=GREEN F=COMPLEX 'THE COWBOY HAT';
      PLOT Y*X=Z/CAXIS=GREEN CTEXT=GREEN;
      RUN;

The output from that first SAS step is the temporary dataset &COWBOY,
which is received in the BOOK step under the ddname FT14F001.
when the statement ".gr 30 gddmsasr" above is encountered, this
causes member GDDMSASR of my SYSRUN dataset to be executed.  This
dataset is as follows:

  DSN=SYS2.CNTCARD(GDDMSASR)
    $IF '&P1'=''
      SETL DDNAME FT14F001
    $ELSE
      SETL DDNAME &P1
    $IF P2=0
      CALC WIDTH#10
    $ELSE
      CALC WIDTH#&P2
    $IF P3=0
      CALC HEIGHT#10
    $ELSE
      CALC HEIGHT#&P3
    GDDMSASR &DDNAME &WIDTH &HEIGHT

The GDDMSASR subcommand of ABE reads input from the specified ddname
(in this case ft14f001).  This dataset must have been created using
AAS/GRAPH with a GOPTIONS statement like the one shown above. The
second and third operands on the GDDMSASR subcommand are respectively
the HSIZE and VSIZE values specified on the GOPTIONS statement
(you can rescale the drawing if you desire by adjusting these numbers
on the GDDMSASR subcommand).  This dataset will contain graphics
instructions (move and draw commands) which GDDMSASR will interpret
and pass on to GDDM to produce the drawing.

.np
GD AND GU SUBCOMMANDS - IBM GRAPHICS LANGUAGE                          @

.gg 6 1 28 35 cadam1
                                    In the upper left quarter of this
                                    page you will see a drawing of a
                                    furry little man holding a bunch
                                    of heart-shaped balloons.  This is
                                    a drawing produced on our CAD/CAM
                                    system.  It was inserted into this
                                    document with the statement -

                                      .gg 6 1 28 35 cadam1

                                    Member CADAM1  of my sysrun dataset
                                    is as follows:

                                      abe '' infi(drawing1) non inp( +
                                      /run drawcad .007 0 .01 0/end n)

                                    The file with ddname DRAWING1
                                    contains data describing the
                                    drawing, and was extracted from the
                                    CAD/CAM system at KCWEST.  It's
                                    format will be explained later, as
                                    will also member DRAWCAD of my
                                    SYSRUN dataset.


.gg 29 36 55 71 cadam2
In the lower right quarter of this
page you will see part of the same
drawing shown above, except it has
been rescaled and clipped so that
only the figure of the furry little
man is shown.  This was done by
inserting in this document the
statement -

  .gg 29 36 55 71 cadam2

Member CADAM2 of my sysrun dataset
is as follows:

  abe '' infi(drawing1) non inp( +
   /run drawcad .022743 93.315 +
   .0197 13.4748/end n

The file with ddname DRAWING1 has
the form of the data stream that
could be passed to the IBM7375
Color Pen Plotter.  An abbreviated
.np
Listing of this dataset appears below:

                 10        20        30        40   50
        123456789012345678901234567890123456789012345678901234
                        ×DRAWING1×X75826.ABE.DRAWING1×800X80.1
    001 SP1;SP2;PU5704,2267;PD5471,2905;PU5189,3679;
    002 PD4243,6280,4309,6383,4371,6488;PU4356,6461;
    .
    . (lines omitted for brevity)
    .
    800 SP2;PU0,0;SP0;NR;

The DRAWING1 dataset above contains commands in the IBM Graphics
Language (GL).  In this language, all commands begin with a 2-character
command name, e.g. SP for "Select Pen", PU for "move Pen Up", and
PD for "move Pen Down."  The PU command is followed by a single
(X,Y) coordinate pair indicating where on the drawing the pen is to
be moved.  The PD command may be followed by one or more such pairs
of coordinates, to which the pen is to be successively moved.

Member DRAWCAD of my SYSRUN dataset is designed to transform a dataset
containing IBM Graphics Language commands, as shown above, into a
series of ABE/GDDM subcommands.  These subcommands are then executed
to produce the drawing.  A list of the resulting subcommands follows:

                 10        20        30        40   50
        123456789012345678901234567890123456789012345678901234
                       ×DRAWING1×X75826.ABE.DRAWING1×1500X80.1
    001 GDDM GSCOL 1
    002 GDDM GSCOL 2
    003 GU 5704 2267
    004 GD 5471 2905
    005 GU 5189 3679
    006 GD 4243 6280 4309 6383 4371 6488
    .
    . (lines omitted for brevity)
    .

The GU and GD subcommands shown above are ABE subcommands used in
conjunction with the XSCALE, YSCALE, XOFFSET, and YOFFSET subcommands
to allow producing drawings under GDDM based on input in the
IBM Graphics Language.  A description of each of these subcommands
follows:

  gd <x1> <y1> <x2> <y2> ... <x10> <y10)
    Each set of (x,y) values is transformed into a call to the GDDM
    GSLINE subcommand as follows:

      GDDM GSLINE <x>*<xscale>-<xoffset> <y>*<yscale>-<yoffset>

    <xscale>, <yscale>, <xoffset>, and <yoffset> are all described
    below:

  gu <x> <y>
    The specified values are transformed into a call to the GDDM
    GSMOVE subcommand as follows:

      GDDM GSMOVE <x>*<xscale>-<xoffset> <y>*<yscale>-<yoffset>

    <xscale>, <yscale>, <xoffset>, and <yoffset> are all described
    below:

  xoffset <xoffset>
    This ABE subcommand allows you to set an offset value which is
    used in the gd and gu subcommands (see above).  The default
    offset value is 0.

  yoffset <yoffset>
    This ABE subcommand allows you to set an offset value which is
    used in the gd and gu subcommands (see above).  The default
    offset value is 0.

  xscale <xscale>
    This ABE subcommand allows you to set a scaling value which is
    used in the gd and gu subcommands (see above).  The default
    scaling value is 1.

  yscale <yscale>
    This ABE subcommand allows you to set a scaling value which is
    used in the gd and gu subcommands (see above).  The default
    scaling value is 1.

  list of DRAWCAD follows:

  DSN=X75826.SYRUN(DRAWCAD)
    $* P1=XSCALE P2=XOFFSET P3=YSCALE P4=YOFFSET
    AL
    SPLIT SP ALL
    SPLIT PU ALL
    SPLIT PD ALL
    SPLIT NR ALL
    DEL NR
    3. SR 1
    C ',' ' '
    C ';' ''
    C SP 'GDDM GSCOL'
    1.2 C PU GU
    1.2 C PD GD
    XSCALE  &P1
    XOFFSET &P2
    YSCALE  &P3
    YOFFSET &P4
    RUN
    %%BOX 0 0 100 100
.np
HCHART - DRAWING HIERARCHICAL CHARTS                                   @

Member HCHSAMP of my SYSRUN dataset appears as follows:

  DSN=X75826.SYSRUN(HCHSAMP)
    a xxx end n
    define xxx lo
    A XXX NL Big Cheese
    A XXX NL  Pungent
    A XXX NL   Limburger
    A XXX NL   Gorgonzola
    A XXX NL  Mild
    A XXX NL   Edam
    A XXX NL   Gouda
    A XXX NL   Cheddar
    a xxx pgm abechrt
    a xxx end n

The graphic result of executing "%%gddmshow hchsamp" at a graphics
terminal is as follows:

.gr 30 hchsamp

Program abechrt is stored in my dataset X75826.ABE.PLI if you're
interested in how it is written.

GDDM SHADING PATTERNS                                                  @

GDDM offers considerable flexibility in using shading patterns.
There are 16 system-defined patterns, and 64 sample user-defined
patterns that come from IBM with GDDM.  All these patterns are
illustrated in the following drawing, produced by running the
following list of ABE subcommands:

  DSN=X75826.SYSRUN(PATSAMP)
    LO
    GDDM GSLSS 2 'ADMUVSRP' 194
    GDDM GSCS 194
    GDDM GSCM 3
    GDDM GSCB 2 4
    CALC BASE#95
    GDDM GSCHAR 0 (BASE) 29 'GDDM-Defined Shading Patterns '
    CALC MAXROW#1
    CALC SIDE#12.5
    CALC FILLBASE#1
    $CALL SUBRTNE
    GDDM GSCB 2 4
    CALC BASE#64
    GDDM GSCHAR 0 (BASE) 39 'GDDM-Sample Geometric Shading Patterns '
    GDDM GSLSS 3 'ADMPATTR' 0
    CALC MAXROW#7
    CALC SIDE#8
    CALC FILLBASE#65
    $CALL SUBRTNE
    $RETURN
    $ SUBRTNE
      CALC GAP#.2*SIDE
      GDDM GSCB (GAP/2) (GAP)
      CALC I#0
      $UNTIL MAXROW<I#I+1
        CALC Y1#(Y2#BASE-I*SIDE)-SIDE
        CALC J#0
        $UNTIL 7<J#J+1
          CALC X2#(X1#J*SIDE)+SIDE
          ZCALC FILL#(I*8+J+FILLBASE)
          %%BOXFILL &X1 (Y1+GAP) &X2 &Y2 &FILL
          GDDM GSCHAR &X1 &Y1 3 '&FILL  '
      $RETURN
  DSN=X75826.SYSRUN(BOXFILL)
    $* (P1,P2)=LOWER LEFT CORNER
    $* (P3,P4)=UPPER RIGHT CORNER
    $* P5=FILL PATTERN
    GDDM GSPAT &P5
    GDDM GSAREA 1
    GDDM GSMOVE &P1 &P2
    GDDM GSLINE &P3 &P2
    GDDM GSLINE &P3 &P4
    GDDM GSLINE &P1 &P4
    GDDM GSLINE &P1 &P2
    GDDM GSENDA
.gr 999 patsamp
GDDM also supplies 64-color Pattern Sets ADMCOLSD, ADMCOLSN, and
ADMCOLSR, which differ only in the size of the symbols.  The IBM
3800 is black-and-white only, of course, but if you run the
following on a color graphics device such as an IBM3179G, you will
see a sample drawing:

  DSN=X75826.SYSRUN(COLSAMP)
    LO
    GDDM GSLSS 2 'ADMUVSRP' 194
    GDDM GSCS 194
    GDDM GSCM 3
    GDDM GSCB 2 4
    CALC BASE#95
    GDDM GSCHAR 0 (BASE) 36 'GDDM 64-Color Pattern Set - ADMCOLSD '
    GDDM GSLSS 3 'ADMCOLSD' 0
    CALC SIDE#11.875
    CALC GAP#.2*SIDE
    GDDM GSCB (GAP/2) (GAP)
    CALC I#0
    $UNTIL 7<I#I+1
      CALC Y1#(Y2#BASE-I*SIDE)-SIDE
      CALC J#0
      $UNTIL 7<J#J+1
        CALC X2#(X1#J*SIDE)+SIDE
        ZCALC FILL#(I*8+J+65)
        GDDM GSCOL 7
        %%BOXFILL &X1 (Y1+GAP) &X2 &Y2 &FILL
        GDDM GSCOL 6
        GDDM GSCHAR &X1 &Y1 3 '&FILL  '

COLORS USING GDDM - GSCOL                                              @

You specify the current color by a call to GDDM subroutine GSCOL, the
sole argument being a number from -2 to 7 indicating the desired
color.  Execute the following to see a sample of colors:

  DSN=X75826.SYSRUN(COLORS)
    GDDM GSLSS 2 'ADMUVCRP' 194
    GDDM GSCM 3
    GDDM GSCB 5 5
    GDDM GSCS 194
    CALC J#I#-2
    $UNTIL 7<I#I+1
      ZCALC I#I
      GDDM GSCOL (I)
      GDDM GSCHAR 45 (95-(I-J)*5) 2 '&I '

COLOR MIXING                                                           @

GDDM also allows you to mix colors on some devices.  Given a color
terminal, the following set of subcommands will illustrate:

  DSN=X75826.SYSRUN(MIXSAMP)
    SETL C00001 BLUE
    SETL C00002 RED
    SETL C00003 PINK
    SETL C00004 GREEN
    SETL C00005 TURQ
    SETL C00006 YELLOW
    SETL C00007 WHITE
    GDDM GSLSS 2 'ADMUVSRP' 194
    GDDM GSCS 194
    GDDM GSCM 3
    GDDM GSCB 2 4
    GDDM GSCHAR 33 95 17 'GDDM COLOR MIXING '
    GDDM GSCB 1 2
    GDDM GSMIX 1
    CALC BASE#64
    CALC SIDE#8
    GDDM GSCB (GAP/2) (GAP)
    CALC I#1
    $UNTIL 7<I#I+1
      CALC Y1#(Y2#BASE-(I-1)*SIDE)-SIDE
      CALC J#1
      $UNTIL 7<J#J+1
        CALC X2#(X1#(J-1)*SIDE+(100-BASE)/2)+SIDE
        GDDM GSCOL &I
        $IF J=1
          SETL SYM &&C&I
          GDDM GSCHAR (X1-8) &Y1 8 '&SYM        '
        $CALL BOX
        GDDM GSCOL &J
        $IF I=1
          SETL SYM &&C&J
          GDDM GSCHAR &X1 &BASE 8 '&SYM        '
        $CALL BOX
    $RETURN
    $ BOX
      GDDM GSAREA 1
      GDDM GSMOVE &X1 &Y1
      GDDM GSLINE &X2 &Y1
      GDDM GSLINE &X2 &Y2
      GDDM GSLINE &X1 &Y2
      GDDM GSLINE &X1 &Y1
      GDDM GSENDA
      $RETURN

ANIMATION, SORT OF                                                     @

The subcommand "GDDM GSCOL 8" specifies the background color, which is
always invisible.  You can use this to give an appearance of animation
by drawing an image in a visible color, then erasing that image by
issuing "GDDM GSCOL 8" and redrawing the same image at the same
location, then changing slightly the location of the image and
repeating the process.  If you run the following list of subcommands
on an IBM3179G terminal, it will appear as if a bug moves across the
screen from lower left to upper right while it changes colors
(bugimage is listed in this appendix under the heading GDDM - SOME
 ENERAL EXAMPLES):

  DSN=X75826.SYSRUN(BUGMOVE)
    %%BUGIMAGE
    CALC I#0
    $WHILE 100>I#I+1
      GDDM GSCOL (INT(RND(-1)*8))
      GDDM GSMOVE &I &I
      GDDM GSIMG 0 48 33 198 IMAGE
      GDDM GSCOL 8
      GDDM GSIMG 0 48 33 198 IMAGE

CHARACTER SIZE - WHAT IS THE SMALLEST FOR YOUR TERMINAL                @

If you're curious as to how small graphic characters can be on your
terminal, issue the RUN subcommand for the following set of
subcommands, and each time you press ENTER, the poem by J.R.R. Tolkien
will be displayed 10 percent smaller:

  DSN=X75826.SYSRUN(SIZETEST)
    $* TEST FOR MINIMUM CHARACTER SIZE
    LO
    GDDM GSLSS 2 'ADMUVCRP' 194
    GDDM GSCS 194
    GDDM GSCM 3
    ZCALC WIDTH#2.6
    $UNTIL TYPE^=0
      ZCALC HEIGHT#2*WIDTH#WIDTH-.1*WIDTH
      GDDM GSCB (WIDTH) (2*WIDTH)
      $CALL SUBRTNE
      GDDM ASREAD %TYPE %VAL %CNT
      GDDM GSCOL 8
      %%BOXFILL 0 0 100 100
    $RETURN
    $ SUBRTNE
      GDDM GSCOL 1
      GDDM GSCHAR ((X#50-WIDTH*38/2)) ((Y#50+6*WIDTH)) 38 +
        'WIDTH=&WIDTH Y=&HEIGHT                           '
      GDDM GSCHAR &X ((Y#Y-2*WIDTH)) 38 +
        'Still round the corner there may wait,  '
      GDDM GSCHAR &X ((Y#Y-2*WIDTH)) 38 +
        'A new road or a secret gate.            '
      GDDM GSCHAR &X ((Y#Y-2*WIDTH)) 38 +
        'And tho I oft have passed them by,      '
      GDDM GSCHAR &X ((Y#Y-2*WIDTH)) 38 +
        'A day will come at last when I,         '
      GDDM GSCHAR &X ((Y#Y-2*WIDTH)) 38 +
        'Shall take the hidden paths that run,   '
      GDDM GSCHAR &X ((Y#Y-2*WIDTH)) 38 +
        'East of the Moon, West of the Sun.      '
      $RETURN

.np
.gg 1 1 40 71 tomhdr 0 name(Thomas Glen Smith)







      06/09/86


      To Whom It May Concern
      KCWOF                                      cc: Interested Party

      Memorandums



      This page is written in the form of an inter-office memorandum.
      The heading lines at the top of the page were produced using
      GDDM subroutines via the ABE interface.

      Typical JCL to produce a memorandum such as this follows:

         //S3       EXEC BOOK3800,PITCH=10
         //DOCIN    DD  DSN=X75826.SYSRUN(MEMOTEXS),DISP=SHR
         //         DD  DSN=X75826.MEMO.SAMPLE.TEXT,DISP=SHR
         //         DD  DUMMY
         //SYSRUN   DD  DSN=X75826.SYSRUN,DISP=SHR
         //         DD  DSN=SYS2.CNTCARD,DISP=SHR
         //INTERO   DD  DSN=X75826.MYMEMO.IMAGE,DISP=SHR

      Replace the dsname X75826.MEMO.SAMPLE.TEXT in the above JCL
      with one for your dataset containing text such as you see on
      this page beginning with the line above containing "06/09/86".
      Note that this text is indented 5 spaces, and that ASA carriage
      control is expected to be in record position 1.

.gg * 5 *+2 22 signatu



      Thomas Glen Smith
      TCC

      /tgs
.np
PRINT CONTROL STATEMENT .IM                                            @

The previous page contains a memorandum in which JCL to produce such
memorandums is shown.  In that JCL is a DD statement with ddname
INTERO, pointing to dataset X75826.MYMEMO.IMAGE.  This dataset was
produced using the following JCL:

    //S1       EXEC BOOK3800,PITCH=10
    //DOCOUT   DD  DUMMY,DCB=(LRECL=2004,BLKSIZE=2008,RECFM=VA)
    //DOCIN    DD  *
    1
    .gg 1 1 40 71 tomhdr
    //         DD  DUMMY
    //         DD  DUMMY
    //SYSRUN   DD  DSN=X75826.SYSRUN,DISP=SHR
    //IBM3800  DD  DSN=X75826.MYMEMO.IMAGE,DISP=(NEW,CATLG,DELETE),
    //             UNIT=DISK,SPACE=(TRK,(5,1),RLSE),VOL=SER=FSRTS1,
    //             DCB=(LRECL=2004,BLKSIZE=19000,RECFM=VBA)

DSN=X75826.SYSRUN(TOMHDR) is as follows:

    LO
    %%BOXFILL 0 99.22 100 99.78 16
    GDDM GSLW 1
    GDDM GSLSS 2 'ADMUWSRP' 194
    GDDM GSCS 194
    GDDM GSCM 3
    GDDM GSCB 2.5 5
    GDDM GSCH .17 .98
    GDDM GSCHAR 0 94 10 'Memorandum'
    GDDM GSMOVE 14.67 91.5
    GDDM GSLINE 100 91.5
    GDDM GSCB 2 4
    GDDM GSCH 0 1
    GDDM GSCHAR    14.67 87 16 'From the Desk of '
    %%CHARBOLD .20 35.28 87    'Thomas Glen Smith'
    %%PETALS 12 91.5 2.5 700

Both BOXFILL and PETALS have been shown previously in this appendix.
DSN=X75826.SYSRUN(CHARBOLD) is as follows:

    $* USED TO CREATE BOLDFACE CHARACTERS
    $* P1=BOLDNESS, FROM 0 TO 100
    $* (P2,P3)=(X,Y) COORDINATES OF START OF TEXT
    $* P4=TEXT
    $* P6=RADIUS
    CALC P6#P1/2
    $* P5=ANGLE
    CALC P5#0
    CALC INCR#36
    $UNTIL 360<=P5#P5+INCR
      GDDM GSCHAR (P2+P6*SIND(P5)) (P3+P6*COSD(P5)) +
        (LENGTH(P4)) '&P4'

The results of running the JCL above is that dataset
X75826.MYMEMO.IMAGE contains the GDDM image necessary to graphically
produce the lines and text at the top of the memorandum page.  This
image is then included in the printer data stream for the memorandum
with a ".im" print control statement in dataset
X75826.SYSRUN(MEMOTEXS), listed below:

                   1         2         3         4         5
          12345678901234567890123456789012345678901234567890123456789

      PF                    ×MEMOTEXS×X75826.SYSRUN(MEMOTEXS)×11X80.1
      001 1
      002 .im intero
      003
      004
      005
      006
      007
      008
      009
      010
      011

format for the .IM statement is -

  .im <ddname>

where -
  <ddname> specifies the ddname associated with a file containing a
    graphics image to be included on the current page.

You may be asking, why use the ".im" control statement when the
".gg 1 1 40 71 memohdr" could just as easily have been included
directly in the MEMOTEXT dataset?  The answer is overhead;  It takes
2.1 cpu seconds on our 3084 to produce the memorandum header, and
only .63 cpu seconds to produce the rest of the memorandum page.
Since the header doesn't change, it makes sense to produce it one
time in a permanent dataset, thereby saving 2.1 cpu seconds every
time a memorandum is produced on the 3800.

PRINT CONTROL STATEMENT .IN                                            @

The JCL procedure BOOK, previously described in this appendix under
the heading "PRINTING THIS MANUAL - HOW IT'S DONE," will recognize
lines beginning with ".in" in record position 1 as print control
statements.  Format is as follows:

        .in <include_spec>

The INCLUDE subcommand of ABE will be issued with <include_spec> as
operands, and the included text will replace the .in statement in the
dataset.







