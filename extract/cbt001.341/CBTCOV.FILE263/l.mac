.he ABE, T. Smith, Appendix L

Appendix L - APL subcommand.                                           @












                       A B E  E d i t o r


                         T .  S m i t h

                       A P P E N D I X  L

                  A P L   S U B C O M M A N D











The APL subcommand provides a subset of the APL language as defined
in the IBM publication "APL Language", publication number GC26-3847-4.
Many of the examples shown in that publication were tried using the
APL subcommand to ensure equivalent results.  You will see these
examples scattered throughout this appendix.

Note that you don't need an APL keyboard to use the APL subcommand.
through use of a combination of upper and lower case characters, and
the accent character (`), all of the APL language primitives are
represented on a non-APL keyboard.

A simple APL subcommand might be "apl b#F3 3RI9", which produces a
dataset named B, as follows:

                10       20
       12345678902345678901. . .
                         ×B××3X15.1
   001  1.00 2.00 3.00
   002  4.00 5.00 6.00
   003  7.00 8.00 9.00

USAGE NOTE:  All datasets created via the apl subcommand are marked
as NOSHOW datasets.  If the name of the resultant dataset is of the
form "Tnnnnnnn", i.e. a default name, it will be given all lines of
the display.  Such would be the case if the subcommand
"apl 3 0F15 1RI15" were issued.

If the name of the resultant dataset is not of the form "Tnnnnnnn" it
will not be given any lines on the display. In order to see the
resultant dataset, you must issue a SHOW or LINES subcommand.  Thus, to
see the dataset named B created as a result of entering the subcommand
"apl b#F3 3RI9" you would have to subsequently enter e.g. "a b lines
"99".

In general, variable names are specified in lower case letters (e.g.
variable name b in "apl b#F3 3RI9" above), and upper case letters are
reserved to specify APL characters not available on a standard
keyboard (e.g. R is the rho operator, I is the iota operator, and F is
the format operator).  A list of all the character sequences that
represent APL operators follow:

APL CHARACTER SET TRANSLATION TABLE                                    @

     `B =ACCENT BASE (see ACCENT BASE - DATA TYPE CONVERSION below)
     `R =ACCENT RHO(see below)    <  =LESS
     `A =ALPHA                    @  =LOG
     &  =AND                      P  =NAND
     -  =BAR                      |  =NOR
     B  =BASE                     ^  =NOT EQUAL
     C  =BASE NULL                K  =NOT GREATER
     `C =CAP                      Z  =NOT LESS
     "  =CAP NULL                 J  =NULL
     O  =CIRCLE                   `W =OMEGA
     `Ö =CIRCLE BAR               V  =OR
     Ö  =CIRCLE STILE             _  =OVERBAR
     T  =CIRCLE SLOPE             +  =PLUS
     :  =COLON                    L  =QUAD
     ,  =COMMA                    ?  =QUERY
     `V =CUP                      !  =QUOTE DOT
     G  =DEL                      Q  =QUOTE-QUAD
     W  =DEL STILE                R  =RHO
     `G =DEL TILDE                $  =RIGHT ARROW
     H  =DELTA                    }  =RIGHT BRACKET
     A  =DELTA STILE              )  =RIGHT PAREN
     `H =DELTA UNDERBAR           `X =RIGHT SHOE
     `1 =DIERESIS                 ;  =SEMICOLON
     %  =DIVIDE                   /  =SLASH
     M  =DOMINO                   `/ =SLASH BAR
     .  =DOT                      \  =SLOPE
     U  =DOWN ARROW               `\ =SLOPE BAR
     D  =DOWNSTILE                *  =STAR
     E  =EPSILON                  ×  =STILE
     =  =EQUAL                    ~  =TILDE
     >  =GREATER THAN             X  =TIMES
     `I =I-BEAM                   N  =TOP
     I  =IOTA                     F  =TOP NULL
     #  =LEFT ARROW               `_ =UNDERBAR
     {  =LEFT BRACKET             Y  =UP ARROW
     (  =LEFT PAREN               S  =UPSTILE
     `Z =LEFT SHOE

APL VARIABLES                                                          @

Variable names used with the APL subcommand refer to datasets currently
being edited.  For example, specifying "apl a#1 2 3" assigns the
vector 1 2 3 to dataset named A.  If such a dataset is already being
edited, it will be replaced by the new vector.  If it doesn't exist,
a new virtual dataset will be created to contain the new vector.

Note that any variable (dataset) created by the APL subcommand will
have associated with it a rank, shape, and length of each element. For
example, the subcommand "apl b#F3 3RI9" was used above to create a
variable (dataset) named B. This variable has rank 2, and is shaped as
a 3 by 15 matrix, each element being 1-character long. In other words,
the APl statement "apl c#FRb", which asks for the shape of b,
would produce the following result:

                10       20
       12345678902345678901. . .
                         ×C××X11.1
   001  3.00 15.00


If a variable is referenced in an APL subcommand, and that variable
exists, but wasn't previously created by the APL subcommand, a default
rank of 2 is assumed, and the first dimension will be set to the
current number of records in the dataset, the second dimension will be
set to the maximum length of each record, and the element length will
be set to 1.  For example, if this text were being edited with the
symbolic name L, and the subcommand "apl a#FRl" were entered, dataset
A would then contain -

                10        20
       123456789012345678901. . .
                         ×A××X14.1
   001  1363.00 80.00

You may override these defaults by using the accent rho (`R) operator,
which is described below under the heading "ACCENT RHO - NONSTANDARD
APL OPERATOR."

APL SHAPE, ELEMENT LENGTH SHOWN ON COMMAND LINE                        @

Note that information about the shape and element length is shown at
the right end of the command line for each data set.  In the example
just previous, this information is indicated by "X14.1", which
indicates a vector of 14 elements, with each element being 1 record
position long.  In general, the right end of the command line will
contain a series of numbers separated by either "X" or "x". The
rightmost number is the element length, and the other numbers indicate
the dimensions.

The uppercase X identifies a demarcation point.  The product of those
dimensions to the left of the uppercase X gives the number of records
in the dataset, e.g. 2X3x5 indicates a 3-dimensional array defined
over a data set with 2 records in it, each record containing 15
elements.

APL VARIABLES - DATA TYPES                                             @

Variables can be either numeric or character.  In the case of numeric
values, they may be stored in an internal format.  For example, a
numeric constant, as in "apl a#1 2 3" is stored as follows:

                    1 0                 2 0
  1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5
                                          ×A××X3.8
  . . . . . . . . . . . . . . . . . . . . . . .
  411000000000000041200000000000004130000000000000

These numeric values are stored as 8-byte floating point numbers.

When specifying numeric constants, a negative number is indicated by
immediately preceding it with an underscore, e.g. _1 (note that the
underscore represents the standard APL overbar character).

Character vector constants are always specified as a string of 0 or
more characters surrounded by single apostrophes, as in "apl
a#'abcdefgh'", which creates character vector A of dimension 8,
appearing as follows:

          ×A××X8.1
  abcdefgh

USE SUBCOMMAND AND APL VARIABLES                                       @

As mentioned previously, numeric APL variables created by the ABE
subcommand are by default stored as 8-byte floating point numbers.  An
example was shown above from the subcommand "apl a#1 2 3".  Actually,
if a "show a" subcommand were issued, the display would look like
the following:

                 10        20        30
        1234567890123456789012345678901234567890
                                        ×A××X3.8
        ×1×2×3
    001 1 2 3

This is because a "use display" subcommand is issued automatically by
ABE for any APL variable that is to be shown on the display.  The
variable is still stored in floating point, but because of the "use
display" subcommand, it is represented on the display in EBCDIC.  Where
The DBD line would normally appear on the display (See Appendix D), a
string of index values is shown.  Note the index values in the
following display, which was produced by the sequence of subcommands
"/apl a#2 3RI6/show a":

                 10        20        30
        1234567890123456789012345678901234567890
                                        ×A××X3.8
        ×1;1×1;2×1;3×2;1×2;2×2;3
    001 1   2   3   4   5   6

The variable can be viewed as it is actually stored by issuing the
subcommand "use nodisplay":

                          1 0                 2 0
        1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5
                                                ×A××X3.8
        . . . . . . . . . . . . . . . . . . . . . . .
    001 411000000000000041200000000000004130000000000000

And can be restored to EBCDIC again by issuing the "use display". Note
that you can change the values on the display by moving the cursor down
and keying over the value:

                 10        20        30
        1234567890123456789012345678901234567890
                                        ×A××X3.8
        ×1;1×1;2×1;3×2;1×2;2×2;3
    001 1   5.3 3   4   5   6

A subsequent "use nodisplay" shows that the value "5.3" is now stored
in floating point:

                          1 0                 2 0
        1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5
                                                ×A××X3.8
        . . . . . . . . . . . . . . . . . . . . . . .
    001 41100000000000004154CCCCCCCCCCCC4130000000000000


APL FORMAT FUNCTION - F                                                @

The format function (F) is used to obtain the character representation
if any variable.  For a numeric array, the shape of the result is the
name as the shape of the argument except the final dimension is
expanded to account for the conversion to character representation.
A scalar number will be represented by a character vector.

Format may be either monadic or dyadic, the right argument always
referring to the variable to be formatted, and the optional left
argument containing information on exactly how to format the data,
e.g. the number of decimal positions, field width, etc.

Only the monadic form accepts a character variable as a right argument.
it returns the data unchanged except for the demarcation point (see
also "APL Shape, Element Length Shown on Command Line"), which will
be chosen such that only the final dimension will be arrayed across
each record in the file, e.g.

Given - apl a#3 2R'abcdef'

               10        20
      123456789012345678901234
                     ×A×X3x2.1
  001 abcdef

then "apl Fa" produces

               10        20
      123456789012345678901234
               ×T0000003×3X2.1
  001 ab
  002 cd
  003 ef

Dyadic format uses the left argument, which may be a single number,
a pair of numbers, or a vector of length "apl 2X_1Y1,Ra" where a is
the right argument, e.g. fFa.  In the left argument, each pair of
numbers is used to control the result of a single column of output.
If a single number is used for a left argument, it is treated as
though a pair of numbers were specified, the first being 0.

The first number in each pair in the left argument to format determines
the width in characters of an output column, and the second determines
the precision and form of the output.  The form is either decimal form
or scientific notation (scaled form) depending on whether the second
number of the pair is positive or negative.  If decimal form, the
second number specifies the number of digits to the right of the
decimal point in the output.  If scaled form, the second number
specifies the number of digits in the multiplier.

Given "apl a#3 2R12.34 _34.567 0 12 _0.26 _123.45"

 apl Fa" produces -

           10        20
  123456789012345678901
              ×t0000007××3X13.1
   12.34  -34.57
    0.00   12.00
   -0.25 -123.45

 apl 12 3Fa" produces -

                10        2030
       1234567890123456789012345678901
                     ×t0000008××3X24.1
   001       12.340     -34.567
   002        0.000      12.000
   003       -0.260    -123.450

 apl R12 3Fa" produces the vector 3 24

 apl 9 _2Fa" produces -

                10        20        30
       1234567890123456789012345678901
                     ×t0000009××3X18.1
   001   1.2E+01  -3.E+01
   002   4.9E-02  1.2E+01
   003   -2.E-01  -1.E+02

If a width indicator in the left argument to format is 0, the default
is a field width such that at least one space will be between adjacent
columns.

Each column can be separately formatted by specifying individual
control pairs in the left argument, e.g.

 apl 0 2 0 2Fa" produces -

                10        20        30
       1234567890123456789012345678901
                     ×t0000009××3X13.1
   001  12.34  -34.57
   002   0.00   12.00
   003  -0.26 -123.45

The following sequence of apl subcommands illustrates the flexibility
available with format:

  apl rowhds#4 3R'JANAPRJULOCT'
  apl years#75+I4
  apl tbl#.001X_400000+?4 4R800000
  apl F(' ',{1}rowhds),(2Ö9 0Fyears),{1}9 2Ftbl


                  10        20        30
         123456789012345678901234567890123456789
                               ×t0000009××5X39.1
     001         76       77       78       79
     002 JAN   329.02  -313.81  -108.21  -108.21
     003 APR  -108.21   182.26   182.26  -242.25
     004 JUL  -242.25  -242.25   218.39   218.39
     005 OCT   218.39   -35.66   -35.66  -204.26

As mentioned previously, numeric results of apl subcommands are by
default stored in internal floating point (see also "APL Variables -
data Types").  In all further examples in this appendix, the use of
the format operator will not be shown unless omitting it would be
confusing.  Any time you see the results of an apl subcommand in
an example, however, bear in mind that format was probably used,
because otherwise the result would be in an unreadable, internal
floating point format.

APL PRIMITIVE SCALAR FUNCTIONS                                         @

Primitive functions can either be mixed or scalar, and within these
classifications, can be either niladic, monadic, or dyadic, depending
on whether they accept zero, one, or two arguments.  Scalar functions
work on scalar arguments, and are extended to vectors and arrays
item-by-item, e.g. "apl 1+1" produces the scalar value 2, and
"apl (1 2)+1 2" produces the vector (2 4).

A monadic scalar function accepts only one argument.  The result is an
array of the same shape as the argument, with each item of the result
obtained by applying the function to the corresponding item of the
argument, e.g. "apl X_3 0 4" produces the vector (-1 0 1) (see signum
function below).

A dyadic scalar function accepts two arguments, left and right, which,
with two exceptions, must be of the same rank and shape.  The elements
are paired item by item to produce the result. The exceptions are that
at least one argument may be a scalar or a one-element array, in which
case the one item is paired to every element in the other argument to
determine the result.  If both arguments have one item, but differing
ranks, the result has the higher rank.  An example of a dyadic
scalar function is the times function, e.g. "apl 1 2 3X4 5 6" produces
the vector (4 10 18).

The following table summarizes all of the primitive scalar functions,
both monadic and dyadic:

_______________________________________________________________________
×                                 × ×                                 ×
×Monadic form, Fb                 × ×Dyadic form, aFb                 ×
×_________________________________× ×_________________________________×
×                     ×           × ×           ×                     ×
×Definition or Example×Name       ×F×Name       ×Definition or Example×
×_____________________×___________×_×___________×_____________________×
×                     ×           × ×           ×                     ×
×+b is b              ×Conjugate  ×+×Plus       ×2+3.2 is 5.2         ×
×-b is 0-b            ×Negative   ×-×Minus      ×2-3.2 is -1.2        ×
×Xb is (b>0)-b<0      ×Signum     ×X×Times      ×2X3.2 is 6.4         ×
×%b is 1%b            ×Reciprocal ×%×Divide     ×2%3.2 is 0.625       ×
××_3.14 is 3.14       ×Magnitude  ×××Residue    ×a×b is b-aXDb%a+a=0  ×
×D3.14 _3.14 is 3 -4  ×Floor      ×D×Minimum    ×3D7 is 3             ×
×S3.14 _3.14 is 4 -3  ×Ceiling    ×S×Maximum    ×3S7 is 7             ×
×?b is Random select  ×Roll       ×?×Deal       ×w?y is Random deal of×
×   from Ib           ×           × ×           ×  w elements from Iy ×
×*b is (2.71828..)*b  ×Exponential×*×Power      ×                     ×
×@*b is b is *@b      ×Natural log×@×General log×                     ×
×Ob is bX3.14159...   ×Pi times   ×O×Circular, Hyperbolic, Pythagorean×
×                     ×           × ×see table, below left            ×
×!0 is 1              ×Factorial  ×!×Binomial   ×a!b is (!b)%(!a)X!b-a×
×!b is bX!b-1 for     ×           × ×           ×2!5 is 10 3!5 is 10  ×
×   positive integers ×           × ×           ×                     ×
×!b is Gamma(b+1) for ×           × ×           ×                     ×
×   negative integers ×           × ×           ×                     ×
×                     ×           × ×           ×                     ×
×~0 is 1, ~1 is 0     ×Not        ×~×           ×                     ×
×_________________________        ×&×And        ×_____________________×
×(-a)Ob     ×a×          ×        ×V×Or         ×a×b×a&b×aVb×aPb×a|b× ×
×___________×_×__________×        ×P×Nand       ×_×_×___×___×___×___×_×
×(1-b*2)*.5 ×0×(1-b*2)*.5×        ×|×Nor(note)  ×0×0× 0 × 0 × 1 × 1 × ×
×Arcsin b   ×1×Sine b    ×        ×<×Less       ×0×1× 0 × 1 × 1 × 0 × ×
×Arccos b   ×2×Cosine b  ×        ×K×Not greater×1×0× 0 × 1 × 1 × 0 × ×
×Arctan b   ×3×Tangent b ×        ×=×Equal      ×1×1× 1 × 1 × 0 × 0 × ×
×(-1+b*2)*.5×4×(1+b*2)*.5×        ×Z×Not less   ×_____________________×
×Arcsinh b  ×5×sinh b    ×        ×>×Greater    ×For relations, result×
×Arccosh b  ×6×cosh b    ×        ×^×Not Equal  ×is 1 if true, else 0:×
×arctanh b  ×7×tanh b    ×        × ×           ×3>7 is 0, 7<3 is 1   ×
×_____________________________________________________________________×
NOTE:  the NOR operator (|) must be given special consideration.
Because this character is used to delimit information on the right
end of the command line, you must surround any apl subcommand that
uses the nor operator with double quotation marks, e.g.
"apl 0 0 1 1 | 0 1 0 1".

ACCENT RHO - NONSTANDARD APL OPERATOR                                  @

Accent rho (`R) represents a special SHAPE operator which is not part
of the standard APL language.  It is used to designate a shape for a
dataset which may or may not have been previously assigned a shape. It
is dyadic, and the right operand specifies the variable name to which a
shape is to be assigned.  The right operand is assumed to be character,
and if arithmetic operations are later applied to this operand, the
elements will be converted to internal floating point.

The left operand must be a vector, and designates the rank, shape, and
element length, as follows.  The number of elements in the vector, less
1, gives the rank. The rightmost element of the vector specifies the
element length, and the rest of the vector specifies the dimensions.

The ACCENT RHO operator must determine a demarcation point in the
vector of dimensions.  Those dimensions to the right of this point will
be defined over each record of the data set, and the product of the
rest must match the number of records in the data set.  For example,
given data set named abc containing 6 records for which the subcommand
"apl abc#2 3 4 5 3`R abc" has been entered, as follows:

                10        20        30        40        50
       123456789012345678901234567890123456789012345678901234567890
                                                   ×ABC××2x3X4x5.3
   001 1a 1b 1c 1d 1e 1f 1g 1h 1i 1j 1k 1l 1m 1n 1o 1p 1q 1r 1s 1t
   002 2a 2b 2c 2d 2e 2f 2g 2h 2i 2j 2k 2l 2m 2n 2o 2p 2q 2r 2s 2t
   003 3a 3b 3c 3d 3e 3f 3g 3h 3i 3j 3k 3l 3m 3n 3o 3p 3q 3r 3s 3t
   004 4a 4b 4c 4d 4e 4f 4g 4h 4i 4j 4k 4l 4m 4n 4o 4p 4q 4r 4s 4t
   005 5a 5b 5c 5d 5e 5f 5g 5h 5i 5j 5k 5l 5m 5n 5o 5p 5q 5r 5s 5t
   006 6a 6b 6c 6d 6e 6f 6g 6h 6i 6j 6k 6l 6m 6n 6o 6p 6q 6r 6s 6t

The subcommand "apl abc{1;2;3;4}" refers to "2n".  The subcommand
"apl (6 5 4 3`R abc){2;4;2}" also refers to "2n".


APL SUBCOMMAND WITHOUT AN ASSIGNMENT OPERATOR                          @

If you enter an APL subcommand in which the leftmost operator is not
assignment (#), a virtual dataset will be created with a default name
to contain the result.  For example, "apl 2 0FI5" would produce a
dataset with a name such as the following:

                10       20
       12345678902345678901. . .
                  ×T0000001××X10.1
   001  1 2 3 4 5

INDEX GENERATOR - MONADIC IOTA (I)                                     @

INDEX GENERATOR (I) is monadic.  The argument must be either a
one-element vector, or a non-negative scalar integer, N.  The result
is a vector of length N containing the first N integers in order
beginning with 1.  An example is shown above.  Note that "apl I0"
fields an empty vector.

INDEX OF - DYADIC IOTA (I)                                             @

INDEX OF is dyadic.  Its left argument must be a vector, V.  The right
argument may be of any rank and shape (including scalar).  The result
is numeric, and has the same rank and shape as the right argument,
each item, S, being the index of the earliest occurrence of S in V. If
S doesn't occur in V, the result is the first index outside the range
of V.  As an example, consider variables A and B shown below:

                10       20
       12345678902345678901. . .
                            ×A××X3.1
   001 ABC
   ==>                      ×B××3X3.1
   001 XBC
   002 AXC
   003 ABX

The subcommand "apl c#1 0FaIb" would produce the following result:

                10       20
       12345678902345678901. . .
                            ×C××3X3.1
   001 423
   002 143
   003 124

RESHAPE - DYADIC RHO (R)                                               @

The reshape function reshapes its right argument to the shape specified
by its left argument.  The left argument must be a vector of scalar. If
a is an empty vector, then dRa is a scalar.  In general, if m#dRv, then
m is an array of dimension d with elements from v, e.g.

  apl 2 3RI6

produces the 2-row by 3-column matrix -

  1 2 3
  4 5 6

In general, if a is any array, then dRa is equivalent to dR,a
(see ravel).  In other words, in the explanation which follows, always
think of the right-hand argument being raveled into vector v.  Now
let n be the total number of elements required in the result of
"apl dRv".  If n is equal to the dimension of vector v, then the
ravel of dRv is equal to v.  If n is less than "apl Rv" then only the
first n elements of v are used.  If n is greater than "apl Rv", then
the elements of v are repeated cyclically, e.g.:

  apl 2 3R1 2                apl 3 3R1 0 0 0

  produces                   produces

  1 2 1                      1 0 0
  2 1 2                      0 1 0
                             0 0 1

INDEXING - ({})                                                        @

In indexing, a new variable is created by selecting elements from a
specified variable according to a set of bracketed index values.
If x is a vector and i is a scalar, then "apl x{i}" is a scalar
equaling the ith element of X, e.g. if "apl x#2 3 5 7 11", then
"apl x{2}" is the scalar 3.

In general Rx{i} equals Ri.  In the sample shown in the previous
paragraph, since i was a scalar, the result was a scalar.  If i had
been a matrix, then x{i} would also be a matrix, e.g.:

  apl F'abcdefg'{4 3R3 1 4 2 1 4 4 1 2 4 1 4}

produces the result -

  cad
  bad
  dab
  dad

If m is a matrix or array of n dimensions, it is indexed by an n-part
list of the form {I1;I2;...;In}, where each Ix is a scalar, vector,
matrix or array of any dimensions, e.g. if "apl m#3 4RI12", then:

  apl m         apl m{2;3}     apl m{1 3;2 3 4}

  produces      produces       produces

  1  2  3  4    7               2  3  4
  4  6  7  8                   10 11 12
  9 10 11 12

In general, Rm{i1;i2;...;in} equals (Ri1),(Ri2),...,Rin.  Thus, if all
of the i1,i2,...,in are scalars, m{i1;i2;...;in} is also a scalar.

Levels may be omitted from the index list, e.g. if m is a matrix,
m{i;} and m{;j} are both legitimate, and respectively select all
columns and all rows, e.g.

    apl 3 0Fm{;m#(2 4R3 1 4 2 1 4 4 1)}

produces -

    4 3 2 1
    3 2 2 3
    4 1 1 4
    1 1 1 1

With a shape prior to applying the format operator of -

    2 2 4

An indexed variable may appear to the left of a specification arrow
(#), e.g.

     apl 2 0F(x#I9){1 3 5 7 9}#0

which would produce the result -

     0 2 0 4 0 6 0 8 0

If l and r denote the left- and right-hand expressions in such an
assignment, then either "apl 1=X/Rr" or "apl ((1^Rl)/Rl)=(1^Rr)/Rr"
must be true (see reduction and multiply operators).  The first
case simply says that a single value appears in the right-hand
expression, regardless of its rank.  The second case simply says that
the number of elements indexed on the left must match the number of
elements on the right.

CATENATE APL FUNCTION                                                  @

Catenate appends one vector to another, and is denoted by a comma:

  apl (6-x),x#I5

    produces the vector

  5 4 3 2 1 1 2 3 4 5

Variables of rank greater than one are treated as aggregates of
vectors, and an axis operator (see also the heading "AXIS APL
OPERATOR") is used to determine the axis along which the vectors are
to be catenated, e.g.:

  apl m#3 3R'abcdefghi'

  apl Fm,{1}m    apl Fm,{2}m    apl Fm,m

    abc          abcabc         abcabc
    def          defdef         defdef
    ghi          ghighi         ghighi
    abc
    def
    ghi

You will note by the third example above that the default axis is the
last.

Two arrays conform for catenate along axis I if all other dimensions
agree.  Also, two arrays may be catenated along axis I if they differ
in rank by 1 and if the shape of the array of lower rank equals the
shape of the array of higher rank after dropping dimension I, e.g.:

  apl v#'pqr'

  apl Fm,{1}v    apl Fm,{2}v    apl Fm,v

    abc           abcp         abcp
    def           defq         defq
    ghi           ghir         ghir
    pqr

Either argument to catenate can be a scalar, in which case it will
be replicated to form a vector or array of necessary dimensions to
be conformable with the other argument, e.g.:

  apl F'*',('*',{1}(3 3R'abcdefghi'),{1}'*'),'*'

    *****
    *abc*
    *def*
    *ghi*
    *****

AXIS APL OPERATOR                                                      @

As mentioned above in the description of CATENATE, various APL
language operators are applied to arrays along a particular axis.  It
helps when dealing of the concept of axes to think of any array as a
collection of vectors.  For example, a matrix can either be thought of
is a series of column or row vectors.  In this case, the AXIS
operator would be used to indicate whether the matrix is to be treated
as an aggregate of either row or column vectors, e.g. for a matrix
of 2 dimensions, an axis value of 1 indicates column vectors, and an
axis value of 2 indicates row vectors.  In other words, the axis value
specifies the dimension that will be incremented most rapidly when
indexing through the matrix during processing.

Certain APL operators, namely CATENATE, COMPRESS, REDUCE, EXPAND,
SCAN, ROTATE and REVERSE, are designed to work on vectors.  These
operators can be applied to arrays of rank 2 or more only if the
arrays are considered to be aggregates of vectors, as indicated in the
previous paragraph.

The AXIS value is indicated by an expression enclosed in brackets
located immediately to the right of the operator, CATENATE, COMPRESS,
etc.

LAMINATE APL OPERATOR                                                  @

Laminate joins two arrays of identical rank and shape along a new
axis (As in the case of most APL operators, a scalar argument will be
replicated to match the rank and shape of the other argument).
the position of the new axis is indicated by a fractional axis number,
surrounded by brackets, and located to the left of a comma in a
format similar to that of catenate, e.g. "apl m,{1.5}n".

If the two arguments have rank 3, for example,  and the new axis is to
be inserted between axes 2 and 3, the specified value would be 2.5. If
the new axis is to be first, the specified value would be between 0
and 1, and if the new axis is to be last, the specified value would be
between I and I+1, where I is the rank of the two arguments.

The result of laminate will of course have rank 1 greater than the
rank of the arguments, and the new dimension is always 2.  The
other dimensions will all match the shape of the arguments.

Examples of laminate follow:

  Given:

    apl m#F3 3R'abcdefghi'
    apl n#F3 3R'123456789'

               1         1                             1         1
      123456789012345678901                   123456789012345678901
                   ×M×3X3.1                                ×N×3X3.1

    1 abc                                   1 123
    2 def                                   2 456
    3 ghi                                   3 789

  Then:

    apl Fm,{.5}n                             apl Fm,{2.5}n

  Produce:

               1         1                             1         1
      123456789012345678901                   123456789012345678901
          ×t0000001×2x3X3.1                       ×t0000002×3x3X2.1

    1 abc                                     a1
    2 def                                     b2
    3 ghi                                     c3
    4 123                                     d4
    5 456                                     e5
    6 789                                     f6
                                              g7
                                              h8
                                              i9


  And:

    apl Fm,{1.5}n                            apl F'1234',{1.5}'+'

  Produce:

               1         1                             1         1
      123456789012345678901                   123456789012345678901
          ×t0000003×3X2X3X1                         ×t0000004×4X2X1

    1 abc                                   1 1+
    2 123                                   2 2+
    3 def                                   3 3+
    4 456                                   4 4+
    5 ghi
    6 789

REDUCE APL OPERATOR                                                    @

This operator accepts a single right argument, which may be either a
scalar, vector, or array of higher dimension.  The result when the
argument is a scalar or a one-element vector is the single value
itself.  For non-empty, non-scalar arguments, as the name implies,
reduce will produce an array which is reduced in rank by 1 compared to
the argument, e.g. for a matrix the result will be a vector, and the
result for a vector will be a scalar.

The formats for using REDUCE are fov and fo{a}v, where v is the
argument, a is the axis along which reduction is to take place, o is
either / (slash) or `/ (slash bar), and f is one of the dyadic scalar
functions listed previously under the heading APL PRIMITIVE SCALAR
FUNCTIONS. If {a} is not specified, the default axis is the last
dimension of the argument if o is a slash, and the first dimension if
o is a slash bar.

The result is obtained by evaluating the expressions formed by placing
the function symbol f between the elements of the vectors along the
specified axis.  Thus, if "apl v#I5", then "apl +/v" produces the
scalar value 15, and "apl X/v" produces the scalar value 120.  Two
further examples follow:

  Given:  apl 2 0Fm#2 3RI6

      1 2 3
      4 5 6

  Then:

    apl +/m                                 apl +/{1}m

  Or:

    apl +/{2}m                              apl +`/m


  Produce:

    6 15                                    5 7 9

SCAN APL OPERATOR                                                      @

The scan operator, like reduce, also accepts a single right argument,
but the result is always the same shape and rank as the argument.
format for SCAN is identical to REDUCE, fov or fo{a}v, except that
o is either \ (slope) or `\ (slope bar).

Like reduce, the result when the argument is a scalar or one-element
vector is the single value itself. For non-empty, non-scalar
arguments, the result is obtained by dealing with the argument as a
series of vectors, and the axis operator is used to designate the
dimension along which vectors are to run, just as with reduce. In fact
the same default axis value is used for scan as for reduce, namely the
last dimension of the argument if the scan operator is designated by \
(slope), and the first dimension if `\ (slope bar) is used.

In the simplest non-scalar case in which SCAN is applied to a vector
v, the result is a vector of the same shape with the Kth element
equal to the REDUCE of the first K elements of v, e.g:

  apl +\I5  Produces: 1 3 6 10 15

  apl V\0 0 1 0 1  Produces: 0 0 1 1 1

  apl &\1 1 0 1 0  Produces: 1 1 0 0 0

As mentioned previously, for arguments of rank higher than 1, they
are treated as a series of vectors along a particular axes, e.g:

  Given:  apl 3 0Fm#3 4RI12

               1         1
      123456789012345678901
                   ×t0000067×3X12.1

    1   1  2  3  4
    2   5  6  7  8
    3   9 10 11 12

  Then:

    apl +\{1}m                              apl +\m

  Produce:

       1  2  3  4                            1  3  6 10
       6  8 10 12                            5 11 18 26
      15 18 21 24                            9 19 30 42


INNER PRODUCT APL OPERATOR                                             @

The APL inner product operator is more commonly referred to as the
matrix product, e.g.

    apl (2 3RI6)+.X3 2RI6

  Produces:

      22 28
      49 64

For arrays of dimension higher than 2, matrix product is applied along
the last axis of the first argument, and the first axis of the second
argument.  The shape of the result is obtained by deleting these axes
and chaining the remaining axes together, e.g.:

    apl 3 0Fa#(2 2 2RI8)+.X2 2 2RI8

  Produces:

               1         1
      123456789012345678901234567890
                 ×t0000001×2x2x2X6.1

    1 11 14
    2 17 20
    3 23 30
    4 37 44
    5 35 46
    6 57 68
    7 47 62
    8 77 92

  where "apl 2 0FRa" produces the vector 2 2 2 2.

Either argument may be a scalar or one-element vector, and will be
extended to the required shape to complete the matrix product.

OUTER PRODUCT APL OPERATOR                                             @

Outer product is specified in the form aJ.fb, where a and b are
arguments, and f is a primitive scalar dyadic function.  The result
is obtained by applying the specified scalar function to all possible
combinations of elements from the two arguments, e.g.

    apl 3 0F(I3)J.XI5                       apl 2 0F(I3)J.<I5

  Produce:

      1  2  3   4  5                        0 1 1 1 1
      2  4  6   8 10                        0 0 1 1 1
      3  6  9  12 15                        0 0 0 1 1

For any two arguments a and b, the expression (Ra),(Rb) yields the
shape of the result.  If r is the result of "apl aJ.+b" then
a{i;j;k;l;m} equals a{i;j}+b{k;l;m}.

RAVEL APL OPERATOR                                                     @

The monadic function RAVEL, denoted by a comma, produces a vector
from the argument, which may be any shape or dimension.  The elements
pf the vector are the elements of the argument selected in sequence
with the right-most dimension being incremented most frequently.

    apl ,2 3RI6

  Produces a vector containing:

    1 2 3 4 5 6

REVERSE MONADIC APL OPERATOR                                           @

In the simplest case, if x is a vector, then     x produces a vector
with the same values as x, except in reverse order, e.g.

    apl result#Öx#2 0FI6

produces:

               1         1
      123456789012345678901234567890
                         ×RESULT×X12.1

   01 6 5 4 3 2 1
   =>                         ×X×X12.1
   01  1 2 3 4 5 6

Reverse is denoted by both Ö (circle stile) and `Ö (circle bar),
the first denoting reversal along the last axis and the second
denoting reversal along the first.  In either case, the default axis
can be overridden by the axis operator, denoted by a bracketed axis
value immediately succeeding the circle stile or circle bar in the
apl expression.

ROTATE DYADIC APL OPERATOR                                             @

Rotate, like reverse, is denoted by both Ö (circle stile) and
`Ö (circle bar).  It is dyadic, and if k is a scalar or one-element
vector and x is a vector, the kÖx is a cyclic rotation of X and is
equal to x{1+(Rx)×_1+k+IRx}, e.g. 1ÖI3 produces the vector 2 3 1.

The axis operator can be used with rotate.  The defaults are the last
dimension if Ö is used, and the first dimension if `Ö is used. When the
axis operator is used, the coordinate j along which rotation is to take
place is specified in the form z#kÖ{j}x.  The shape of k must equal the
shape of x with the axis dimension removed.  Each vector along the jth
axis is rotated as specified by the corresponding element of k, e.g. if
Rx is 3 4, then the shape of k must be 4 if j is 2, and 3 if j is 1.
then j is 1 z{;i} is equal to k{i}Öx{;i}, and when j is 2 z{i;} is
equal to k{i}Öx{i;}/.

If the left argument to rotate is a scalar or one-element vector, it
is extended to the required shape.

Rotate example:

  Given:  apl 3 0Fm#3 4RI12


      1  2  3  4
      5  6  7  8
      9 10 11 12

  Then:

    apl 3 0F(_1+I4)`Öm                      apl 3 0F(I3)Öm

  Produce:

      1  6 11  4                            2  3  4  1
      5 10  3  8                            7  8  5  6
      9  2  7 12                           12  9 10 11


TRANSPOSE APL OPERATOR                                                 @

If p is any permutation of the dimension numbers of an array a (i.e.
1st dimension is 1, 2d is 2, etc.), then the dyadic transpose, pTa, is
a rearrangement or cross section of array a where p specifies how the
elements are to be selected from a.  Monadic transpose, Ta, is
equivalent to (ÖIRRa)Ta.  Essentially, this reverses the order of the
axes of its argument, and for a matrix, this is what is commonly called
the "transpose" of the matrix, e.g.

    apl 3 0F(ÖIRRa)Ta#3 4RI12

and

    apl 3 0FTa#3 4RI12

both produce:

               10        20
      12345678901234567890123456789
                   ×t0000001×14X9.1

    1   1  5  9
    2   2  6 10
    3   3  7 11
    4   4  8 12

In general, qTa is valid if q is a vector equal in length to the rank of
a, and q is "complete" in that if n is the largest value in q, then n
can't be larger than the rank of a, and q must also contain all positive
integers less than n, e.g.:

  Given:
    apl 3 0Fm#3 3 3RI27

                 10        20
        123456789012345678901234567890
                     ×t0000048×3x3X9.1

    001   1  2  3
    002   1  2  3
    003   4  5  6
    004   7  8  9
    005  10 11 12
    006  13 14 15
    007  16 17 18
    008  19 20 21
    009  22 23 24
    010  25 26 27

  Then:

    apl 3 0F1 1 2Tm                         apl 3 0F1 1 1Tm

  Produce:

               10        20                          10        20
      12345678901234567890123               123456789012345678901234
              ×T0000000×3X9.1                         ×T0000001×X9.1

    1   1  2  3                           1   1 14 27
    2  13 14 15
    3  25 26 27

TAKE AND DROP APL OPERATORS                                            @

TAKE and DROP are respectively denoted by the up arrow (Y) and down
arrow (U).  The general form for TAKE is wYa, where w must be a vector
having one element for each axis of a.  If a is a vector, then w must
be a one-element vector or scalar, e.g.:

  apl 3Y'abcde'

produces a vector of shape 3 containing

  abc

The result is obtained by taking the first w{i} elements along the Ith
axis of a, and if w{i}>(Ra){i}, padding with zeros if a is numeric and
by spaces if not, e.g.:

  apl 7Y2 3 5 7

produces a vector of shape 7 containing

  2 3 5 7 0 0 0

If s is a negative integer, the sYv takes the last elements of v and
pads on the left, e.g.:

  apl _7Y2 3 5 7

produces a vector of shape 7 containing

  0 0 0 2 3 5 7

Following are examples showing TAKE applied to a matrix:

  Given:  apl a#3 4RI12


      1  2  3  4
      5  6  7  8
      9 10 11 12

  Then:

    apl 3 0F2 _3Ya    apl 3 0F2 3Ya    apl 3 0F_2 6Ya

  Produce:

      2  3  4         1  2  3          5  6  7  8  0  0
      6  7  8         5  6  7          9 10 11 12  0  0

DROP is functionally equivalent to TAKE except that the indicated
number of elements are dropped rather than taken, e.g. _1 1Ua is
equivalent to 2 _3Ya.  If the number of elements to be dropped
along any axis equals or exceeds the length of the axis, the
resulting shape has a zero length for that axis.


COMPRESS AND EXPAND APL OPERATORS                                      @

Given "apl x#2 3 5 7 11" and "apl u#1 0 1 1 0", then "apl u/x" produces
the vector 2 5 7, and "apl (~u)/x" produces 3 11.  This is called the
COMPRESS operation.  The general form is ufx, where u must be a vector,
and x may be of any dimension and shape; f is either / or `/, depending
on whether the default axis is to be the last or first, respectively.
the elements of the result are comprised of those elements of x
corresponding to non-zero elements of u.

  Given:
    apl q#3 4R'abcdefghijkl'

               10        20
      123456789012345678901
                  ×Q×X3x4.1

    1 abcdefghijkl

  Then:

    apl 0 1 1 0/q             apl 1 0 1/{1}q         apl 1 0 1`/q

  Produce:

               10        20            10        20             10
      123456789012345678901   123456789012345678901  1234567890123456
           ×T0000001×X3x2.1        ×T0000002×X2x4.1   ×T0000003×X2x4.1

    1 bcfgjk                1 abcdijkl             1 abcdijkl

EXPAND is the converse of COMPRESS, e.g. "apl 1 1 0 1\I3" produces the
vector 1 2 0 3, and is denoted by either \ of `\, depending on whether
the default axis is to be the last or first, respectively.  u\x
expands x to the format indicated by the non-zero elements in u, and
fills in zeros or spaces.  To be conformable, +/u must equal Rx.

MEMBERSHIP APL OPERATOR                                                @

"apl xEy" produces v the same shape as x, with any particular element
of v set to 1 if the corresponding element of x is a member of y, e.g.
"apl 'abcdefgh'E'coffee'" produces the vector 0 0 1 0 1 1 0 0, and
"apl (2 4R'abcdefgh')E'coffee'" produces the 2 by 4 matrix -

     0 0 1 0
     1 1 0 0

ATOMIC VECTOR - APL SYSTEM VARIABLE                                    @

The sequence "Lav" in an apl statement references a read-only variable
built in to the system.  This variable is a character vector, each
element being 1 character long containing one of the 256 possible
characters.  Given a data set named var, the following APL statement
would translate all lower case characters to upper case (Note there
is a more efficient way of doing this using the CHANGE subcommand with
the OPICTURE operand.  The APL statement below is merely for
illustration purposes):

apl var{I1YRvar;I_1YRvar}#Lav{((I256) +
 {LavI'abcdefghijklmnopqrstuvwxyz'}#LavI'ABCDEFGHIJKLMNOPQRSTUVWXYZ') +
 {LavIvar}}

GRADE APL FUNCTIONS                                                    @

GRADE UP, "apl Av", grades vector v in ascending sequence, and GRADE
DOWN, "apl Wv", grades vector v in descending sequence. Given a numeric
vector v, in the case of GRADE UP, the first element in this resulting
vector is the index of the smallest item in v, the second element is
the index of the next smallest item, etc.  In the case of GRADE DOWN,
the first element in the resulting vector is the index of the largest
item v, the second element is the index of the next largest item, etc.
when character vectors are graded, the "smallest" or "largest" element
is determined by collating sequence, e.g. "apl A'abc'" produces the
vector 1 2 3, and "apl W'abc'" produces the vector 3 2 1.

DECODE APL OPERATOR                                                    @

DECODE converts from any base numbering system to decimal.  The number
to be converted is the left argument to DECODE, and must be stored as a
vector, each element of the vector being the value of a radix position,
e.g. the vector 1 0 7 might be the octal representation of the decimal
number 71. In the case of higher dimensioned arguments, each vector
along the last axis is considered to be an encoded number.

The radices are specified by the right argument to DECODE, e.g.
if r#24 60 60, and x#1 2 3, then "apl rBx" produces the scalar 3723.
In this example, the radices 24 60 60 might be hours, minutes, and
seconds, respectively, and 1 2 3 is 1 hour, 2 minutes and 3 seconds.

Scalar or one-element vector arguments are extended to conform, e.g.
"apl 10B1 7 7 6" produces 1776.

Arguments are not restricted to integers.  If x is a scalar, then
you can interpret "apl xBc" as producing the value of polynomial with
coefficients c, arranged in descending order on the powers of x.

The extension to arrays is similar to inner product, except that if
either the last axis of the left argument, or the first axis of the
right argument is length 1, it will be extended by replication to
conform.  The shape of the result of aBb is (_1URa),1YRb; the same
as for inner product.

Normally, rBx is equal to +/wXx, where w is the weighting factor
determined as follows: w{Rw} is equal to 1 and w{i-1} is equal to
r{i}Xw{i}.


ENCODE APL OPERATOR                                                    @

ENCODE, rNx, for some arguments is the inverse to the decode
function, e.g. "apl (4R10)N1776" produces the vector 1 7 7 6.
normally, the definition of the ENCODE function is defined for a
vector left argument and scalar right argument according to the
following APL function, which was copied directly from the IBM
APL Language manual:

     z#a e b
     z#0Xa
     i#Ra
     l:$(i=0)/0
     z{i}#a{i}×b
     $(a{i}=0)/0
     b#(b-z{i})%a{i}
     i#i-1
     $l

Some examples follow:

     apl (3R2)N13   produces 1 0 1
     apl (3R_2)N13  produces _1 _1 _1
     apl 2 0 2N13   produces 0 6 1
     apl (3R2)N_13  produces 0 1 1
     apl _2 2 _2N13 produces 0 1 _1

ENCODE, rNx, is extended to arrays by applying each vector along
the first axis of r to each element of x, storing the resulting
vectors along the first axis of the result, e.g.

  apl (3R10)N215 486 72 219 3

produces a 3 by 5 matrix containing

  2 4 0 2 0
  1 8 7 1 0
  5 6 2 9 3

  apl (10 10 10,{1.5}8 8 8)N123

produces a 3 by 2 matrix containing

  1 1
  2 7
  3 3

EXECUTE, OR COMPUTE, APL OPERATOR                                      @

Monadic EXECUTE, denoted by C, accepts a character vector or scalar
containing the representation of an APL statement, and executes it.
the result replaces the EXECUTE operator and its operand in the
current expression, e.g.

  apl 1+C'4%2'

produces the scalar 3.

MATRIX INVERSE AND MATRIX DIVIDE - M                                   @

Given a non-singular matrix a, "apl Ma" produces of the inverse of a.
"apl x#bMa" produces a variable x which produces the result 1 for the
subcommand "apl &/,b=a+.Xx".  In other words, it produces the solution
for the system of linear equations as in Ax=b.

  Given:
    apl 2 0Fa#(I4)J.ZI4

      1 0 0 0
      1 1 0 0
      1 1 1 0
      1 1 1 1

    apl 2 0Fb#1 3 6 10

      1 3 6 10

  Then:
    apl 2 0FMa

  Produces:

     1 0 0 0
    -1 1 0 0
     0-1 1 0
     0 0-1 1

    apl 2 0FbMa

  Produces:

     1 2 3 4

If the right argument to matrix inverse is non-square, the result is
the left inverse:

    apl 10 4FMT2 3RI6

  Produces:

   -0.9444   -0.1111    0.7222
    0.4444    0.1111   -0.2222

Matrix Divide can also be thought of as deriving estimates for the
coefficients in a simple linear regression problem.  Suppose
variables x and y contain respectively values for the independent
variable and the response variable in the model -

  Y = a + bX + U

Given:
  apl y#55 70 90 100 90 105 80 110 125 115 130 130
  apl x#100 90 80 70 70 70 70 65 60 60 55 50

When the apl subcommand -

  apl 6 2FyM1,{2}12 1Rx

produces the vector containing -

  210.44  -1.58

In other words "apl yMx" produces a result equivalent to the matrix
expression INV(X'X)X'Y, where INV is the matrix inverse function,
the appostrophe indicates transposition of the matrix referred to
immediately to the left in the expression, and the matrix multiply
operator is implied between operands.


ACCENT BASE - DATA TYPE CONVERSION                                     @

Unless you tell it otherwise, the APL subcommand stores all numeric
values in doubleword floating point.  The ACCENT BASE (`B) operator
allows you to specify both the data type, e.g. float, character,
zoned, packed decimal, hexadecimal, bit, and fixed binary, and the
length of each element.  Format of the ACCENT BASE operator is -

  v `B x

Where the right operand, x, is any APL expression deriving a variable,
and the left operand, v, is a scalar or vector of 1 or 2 elements.  The
first or only value in the left operand is a number from 1 to 7
specifying the new data type, as follows:

     1 - float
     2 - character
     3 - zoned decimal
     4 - packed decimal
     5 - hexadecimal
     6 - bit
     7 - fixed binary

The second value in the left operand specifies the new length.  This
number is optional, and if not specified, the defaults are

     4 - float
    20 - character
    20 - zoned decimal
     8 - packed decimal
     4 - hexadecimal
     4 - bit
     4 - fixed binary

The ACCENT BASE operator was designed for use in conjunction with the
GR and GDDM subcommands, which respectively interface to the PLOT79
graphics subroutine package, and to the IBM GDDM product. Many of the
PLOT79 subroutines, for example, are written in FORTRAN, and accept
only single precision (4 bytes) floating point numbers, or 4-byte fixed
binary integer values.

SYSAPL - A SPECIAL SYMBOLIC VARIABLE                                   @

&SYSAPL, which is followed by a parenthesized expression, is a special
symbolic variable. The APL subcommand will be invoked to evaluate the
expression, and the result will replace both the string &SYSAPL and
the parenthesized expression, e.g. the subcommand -

    r nl The trigonometric sin of 45 degrees is &SYSAPL(1O.25XO1))

will create a new record in the current dataset containing the string
"The trigonometric sin of 45 degrees is .707107".





