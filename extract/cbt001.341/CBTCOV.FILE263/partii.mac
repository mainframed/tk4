.he ABE, T. Smith, Part II

.di

PART II - General Reference                                            @

 !!!!!!IMPORTANT!!!!!!! - If you haven't done so before, you should
 read Appendix H to the ABE Reference Manual, which describes LSUs
 The items <prefix>, <lsu>, <l1>, <l2>, <incr>, <off>, <len>, and
 <ncols> are commonly referred to in this text, and their complete
 descriptions are given only in Appendix H.  AN UNDERSTANDING OF
 LSUS IS ESSENTIAL TO THE USE OF MOST ABE SUBCOMMANDS.

 !!!!!!IMPORTANT!!!!!!! - A modified Backus-Naur Form (BNF) is used
 throughout this text to describe syntax.  If you are not familiar
 with BNF, you should read Appendix G to the ABE Reference Manual
 before attempting to use this text.

)S SUBCOMMANDS -
 $CC, $CLEAR, $CURSOR, $DECR, $DISPLAY, $EDIT, $FULLSCR, $GETMK, $INCR,
 $JE, $PK, $PP, $SETD, $SETO, $SETQUOT, $STORE, $XLATE, AC, AID, AL,
 ALTCASE, AR, BASE, BLANK, BNDS, BOTTOM, BRIGHT, CALC, CHANGE, CHAR,
 CL, CLEAR, CLEARSC, CLIST, CLL, COLADJ, COLUMN, CONTENT, CONVERT,
 COPY, CURSOR, DATAENT, DB2, DCODE, DEFINE, DELAY, DELDUP, DELETE,
 DOTAB, DOWN, DRAW, DREM, DSCB, ECHO, END, ENTER, EXEC, FILL, FILLET,
 FIND, FLIP, FORMJCL, FULLSCR, GD, GDDM, GED, GETDDN, GETDSN, GETMEM,
 GETNAME, GETVOL, GFILL, GPR, GR, GS, GSAS, GU, HALFB, HALFF, HARDCOPY,
 HELP, HEX, HI, IMGET, IMGETB, IMPUT, IMPUTB, INCLUDE, INSERT, ISPLINK,
 ITEIN, JOB, JOIN, LAST, LINES, LIST, LISTRF, LL, LO, LOAD, LOCATE, LSP,
 LSS, MARK, MB, MCALC, MD, MEMORY, MERD, MERGE, MK, ML, MLL, MOVE,
 MOVEP, MSG, NAME, NAMELOC, NCODE, NEWPEN, NL, NUM, NUMCK, OL, ORDER,
 OW, PARM, PB, PBSL, PBSR, PDF, PDFC, PDFD, PDFE, PDFQ, PDFS, PEEK, PEL,
 PF, PFK, PGM, PLOT, POOL, PRT, PURGE, R, RANDOM, REFRESH, RELJOIN,
 REMOVE, RENUM, RESEQ, RESET, RLIM, RUN, SAS, SAVE, SCAN, SCANPDS, SE,
 SELECT, SEQ, SET, SETD, SETHEX, SETL, SETLZF, SETN, SETQUOT, SETRC,
 SETSEQ, SHOW, SL, SLB, SLC, SLE, SNO, SNOT, SORT, SORTL, SORTQ, SORTQL,
 SORTNX, SORTNXL, SORTX, SORTXL, SPLINE, SPLIT, SPLITB, SR, SRB, SRC,
 SRE, SUBMIT, SUBSTR, SUFFIX, SUPPORT, SUPPRESS, SWAP, SX, SYMC, TAB,
 TABK, TEXT, TGET, TOGGLE, TOP, TPG, TPUT, TRACE, TRANSLAT, TRANSPOS,
 TRTAB, TRUNCATE, TS, UNNUM, UP, UPDATE, UPDATEC, USE, V, VERIFY,
 VOLSER, VTOC, WATDATE, X, XLATE, XOFFSET, XSCALE, XT, YOFFSET, YSCALE,
 Z, ZCALC

)X SYNTAX -

  <SSE-SUBCOMMAND> # ABE <DSNAME> <KEYWORDS>

  <KEYWORDS> # <0, <KEYWORD> / ' '>

  <KEYWORD> # CLIST
            × COUNT(<NUMBER>)
            × DBD
            × DB2
            × DB2IN
            × DB2OUT
            × FAM(<MODULE>)
            × HARDCOPY
            × HEX
            × HICASE
            × INFI(<DDNAME>)
            × INP(<SUBCOMMAND-LIST>)
            × INTERNAL
            × LINE(<NUMBER>)
            × LOCASE
            × NAME(<NAME>)
            × NODBD
            × NOFREE
            × NONUM
            × NOPREFIX
            × NOPROMPT
            × NOSHOW
            × OUTDA(<DSNAME>)
            × OUTFI(<DDNAME>)
            × OVOL(<VOLSER>)
            × PDF
            × PDFC
            × PDFE
            × PRI(<NUMBER>)
            × PROFILE
            × RECSIZE(<NUMBER>)
            × SAS
            × SASIN
            × SASOUT
            × SECY(<NUMBER>)
            × SUPPORT
            × SYSOUT(<SYSOUT-CLASS>)
            × TRANSLAT
            × VOL(<VOLSER>)

NOTE:  Normally, the cursor will returned to the start of the top
       command line (see also CURSOR subcommand).  However, if the
       editor determines that it may be more efficient for the
       cursor to be placed elsewhere, it will do so.  For example,
       after using the BLANK subcommand to insert blank lines in
       the data set, the editor assumes you are going to key
       something in the new lines, so it leaves the cursor
       positioned in the first blank line, aligned under the first
       non-blank character of the previous line
NOTE:  ABE does not support operating with "profile noprefix" in
       effect.
NOTE:  ABE does not support editing data with a beginning sequence
       number of zero.  If you edit such a data set, a warning
       message will be given, and you should renumber before
       continuing editing.
NOTE:  For a number of subcommands, operands can be parenthesized
       expressions to be evaluated before the subcommand is processed,
       e.g. -

          run arc (.5+s*.40141) .38732

       Suppose when the above subcommand is executed, variable s has
       the value -1.  Then when the run subcommand is processed, the
       second operand will have the value .09859.  This is
       accomplished during subcommand initialization, when each
       operand is inspected.  If it is not a quoted string (e.g.
       'abc') and it begins and ends with left and right
       parentheses, it is interpreted to be an arithmetic
       expression, and is passed to the CALC subcommand for
       evaluation.  The resulting value replaces the expression as
       the operand in the current subcommand.  See Appendix I on the
       CALC subcommand for information on what can appear in such
       expressions.

       The list of subcommands which may have such operands is
       listed below:

         GDDM, GR, RUN.

)M - Abbreviated subcommand list showing syntax for subcommands:

 Following list shows the syntax for abe  subcommands:

 =        repeat last subcommand
         =
$CC      list condition codes from sysout
         $CC
$CLEAR   reset output values on a display panel
         $CLEAR <PANEL>
$CURSOR  change cursor position on a given display panel
         $CURSOR <PANEL> <POS>
$DECR    decrement replacement value
         $DECR <SYMBOL> <AMOUNT>
$DISPLAY load up and display data on a given display panel
         $DISPLAY <PANEL> DUP(<N>) LIST LINE(<L>) NOBREAK
$EDIT    delete current data set and edit lastjcl.cntl
         $EDIT
$FULLSCR display data in full screen format.
         $FULLSCR <PANEL>
$GETMK   set replacement value to value from the mark array.
         $GETMK <NUMBER> <LABEL> <NAME>
$INCR    increment replacement value
         $INCR <SYMBOL> <AMOUNT>
$JE      move display to last msgclass line
         $JE
$PK      $PRT and then keep the data set
         $PK
$PP      $PRT and then $PURGE the data set
         $PP
$SETD    set replacement value from data in a record.
         $SETD <VARIABLE> <LINE> <OFF> <LEN> <NAME>
$SETO    set output values on a display panel
         $SETO <PANEL> <FLDNO> <VALUE> PREMOD NOPREMOD HIGH LOW PROT
               UNPROT SUPPRESS TRAN NOTRAN
$SETQUOT transform replacement value into a quoted string
         $SETQUOT <SYMBOL-1> <SYMBOL-2>
$STORE   stores data enter at the terminal on a display panel
         $STORE <PANEL> DUP(<N>) LIST LINE(<L>) MASK NOBREAK
$XLATE   translates replacement value to upper case
         $XLATE <SYMBOL>
ABE      edit additional data sets
         ABE    <DSNAME>  OUTDA(<DSNAME2>) HARDCOPY INFILE()
                          NONUM LOCASE HICASE SYSOUT NAME()
                          TRANSLAT NOPREFIX HEX NOFREE
                          LINE() COUNT() PRI() SECY() PDF PDFC
                          PDFE INP() SUPPORT CLIST RECSIZE()
                          DBD NODBD DB2 DB2IN DB2OUT SAS SASIN
                          SASOUT
AC       shift all lines to align on a character string
         <LSU> AC <STR> <POS> <LM> <RM>
AID      prompt for operands
         AID <subcommand name>
AL       shift all lines to a left margin
         <LSU> AL <LM> <RM>
ALTCASE  temporarily change the hi/lo mode
         ALTCASE
AR       shift all lines to a right margin
         <LSU> AR <RM> <LM>
BASE     convert matrix of numbers from one numeric base to another
         <LSU> BASE <FROMBASE> <TOBASE>
BLANK    insert blank lines
         <LSU> BLANK <COUNT>
BNDS     set bounds
         BNDS LIST
              LEFT
              RIGHT
              <L>
              <L> <R>
BOTTOM   display last line of data set
         BOTTOM
BRIGHT   change intensity of display fields
         'BRIGHT' ('LO' × 'HI' × 'SU') +
           ('ALL' × 'CMD' × 'DATA' × 'HEADINGS')
CALC     calculator function
         CALC <optional-expression>
CHANGE   changes one character string to another
         <LSU> CHANGE <STRING-1> <STRING-2> ANY NALL() NOSH BNDS NOR
                                            PREFIX
                                            SUFFIX
                                            WORD
                                            PICTURE
                                            HEX
                                            TEXT
                                            CHARS
                                            OPIC
CHAR     display in character mode (in contrast to hex mode)
         CHAR
CL       Obtain a list of cataloged dataset member names
         cl <level> <qual>
CLEAR    truncate lines at a specific column
         <LSU> CLEAR <OFFSET>
CLEARSC  Clear the screen
         CLEARSC <PAUSE>
CLIST    invoke ABE subcommand clists.
         CLIST <CLIST_NAME> <CLIST_OPERANDS>
CLL      Obtain a list of cataloged dataset member names
         cll <level> <qual>
COLADJ   FORMAT MATRIX OF DATA INTO REGULAR COLUMNS
         <LSU> COLADJ ('LEFT' × 'RIGHT' × 'DECIMAL' × 'UNIFORM')
COLUMN   first column of each record to be displayed
         COLUMN <NUMBER> <TRUNC>
CONTENT  list data sets currently being edited
         CONTENT <NAME>
CONVERT  convert from one data format to another
         <LSU> CONVERT <FROM_SPEC> <TO_SPEC> LEFT NAME()
                                             RIGHT
COPY     copy lines
         <LSU> 'COPY' '('(<NAME>) (<LSU>)')' (<COUNT>)
           ('OL' × 'FROM' × 'TO')
CURSOR   cursor control
         CURSOR
DATAENT  data entry subcommand
         DATAENT <PANEL> <$STORE_OPERANDS>
DB2      issue db2 statement
         DB2 <STATEMENT>
DCODE    decode data encrypted via ncode subcommand
         <LSU> DCODE <KEY>
DEFINE   define a virtual data set
         DEFINE <NAME> ...
DELAY    wait <time> milliseconds
         DELAY <TIME>
DELDUP   delete duplicate lines
         <LSU> DELDUP  <COL1>:COL2  <COL3>:COL4  ...
DELETE   delete lines
         <LSU> DELETE   <STR> NOT
DOTAB    perform tabbing
         DOTAB <TAB_CHAR> <TAB_ARRAY>
DOWN     move the display down
         DOWN <NUMBER>
DRAW     draw a line - see Appendix N
         DRAW <X> <Y> <Z> ('INCHES' × 'PIXELS')
DREM     copy lines from this data set to another data set
         DREM <NAME> <L1> <L2> <TO>
DSCB     obtain Data Set Control Blocks from the VTOC
         DSCB <NAME> <VOLSER> <SYMNAME> <cchhr name>
DUMP     abe  debugging subcommand
         DUMP
ECHO     turn on or off the printing of all subcommands issued
         ECHO ON × OFF
END      end editing of a data set
         END <SAVE> × <NOSAVE>
ENTER    data entry
         ENTER
EXEC     execute a series of tso commands
         <LSU> EXEC <NAME>
FILL     fill to the right with blanks
         FILL <COLUMN>
FILLET   Draws a smooth curve based on the input points
         FILLET <XARRAY> <YARRAY>
FIND     find next occurrence of a character string
         <LSU> FIND <STRING-1> CHARS  NOT STCOL() NAME() MARK() BNDS
                               PREFIX                    MK()
                               SUFFIX
                               WORD
                               MASK()
                               OPER()
                               PICTURE
                               HEX
                               TEXT
                               ANY

FLIP     flip columns with each other
         <LSU> FLIP <LSU>
FORMJCL  format JCL into standardized columns
         %%FORMJCL
FULLSCR  puts terminal in full-screen mode
         FULLSCR
GD       Graphics Draw - see Appendix O
         GD <X1> <Y1> <X2> <Y2> ... <X10> <Y10)
GDDM     interface to GDDM - see Appendix O
         GDDM <NAME> <OPERANDS>
GED      edit BITMAP - see Appendix N
         GED
GETDDN   set replacement value to ddname of currently edited data set
         GETDDN <SYMBOL_NAME>
GETDSN   set replacement value to dsname of currently edited data set
         GETDSN <SYMBOL_NAME>
GETMEM   set replacement value to member name of current data set
         GETMEM <SYMBOL_NAME>
GETNAME  set replacement value to symbolic name of current data set
         GETNAME <SYMBOL_NAME>
GETVOL   set replacement value to volser of current data set
         GETVOL <SYMBOL_NAME>
GFILL    fill in an area of a graphics drawing
         'GFILL' <X> <Y> <Z> ('INCHES' × 'PIXELS' × 'NDC')
GPR      print graphics drawing - see Appendix N
         GPR <DEST> <DEVICE>
GR       interface to PLOT79 - see Appendix N
         GR <NAME> <OPERANDS>
GSAS     Interactive SAS/GRAPH on a non-graphics terminal
         GSAS <X1> <Y1> <X2> <Y2> <SAS-PARMS> <DEST> <TYPE>
GU       Graphics Move - see Appendix O
         GU <X> <Y>
HARDCOPY puts terminal in hardcopy mode
         HARDCOPY
HELP     help data
         HELP
HEX      display data in hexadecimal
         HEX
HI       causes all data entered to be translated to upper case
         HI
IMGET    retrieves a rectangle of pixels from internal pixel map
         IMGET <NAME> <XPEL1> <YPEL1> <XPEL2> <YPEL2>
IMGETB   retrieves a rectangle of pixels (in bits)  from pixel map
         IMGETB <NAME> <XPEL1> <YPEL1> <XPEL2> <YPEL2>
IMPUT    assigns a rectangle of pixels to the internal pixel map
         IMPUT <NAME> <XPEL1> <YPEL1> <XPEL2> <YPEL2>
IMPUTB   assigns a rectangle of pixels (in bits) to the pixel map
         IMPUTB <NAME> <XPEL1> <YPEL1> <XPEL2> <YPEL2>
INCLUDE  include text from a partitioned data set
         INCLUDE <name-spec> <line-number> LAST REP
INSERT   put terminal in input mode
         INSERT <NUMBER>
ISPLINK  invoke ISPF services
         ISPLINK <ispf-parms>
ITEIN    properly indent PL/I and SAS source
         ITEIN INDENT() SUPPRESS SAS PLI
JOB      fast submission to batch
         <LSU> JOB
JOIN     join two or more lines
         <LSU> JOIN <PAIRS>
LAST     retrieve the last subcommand executed.
         LAST
LINES    change the number of lines a data set owns on the display
         LINES <CNT>
LIST     list lines while editing on a hardcopy terminal
         <LSU> LIST
LISTRF   Obtain reference dates for a list of dataset names
         <LSU> LISTRF VOLSER
LL       adjusts data to a new line length
         <LSU> LL <LEN> <LM> <RM>
LO       causes all data entered to remain in lower case
         LO
LSP      line selection processor
         LSP <TEMPLATE> <KEYWORDS>
MB       merge back
         MB <NAME> NODEL MASK OVERLAY
MCALC    perform calculations on a matrix of numbers
         <LSU> MCALC <EXPRESSION>
MD       move display
         MD <NUMBER>
ME       set mark array element 2
         ME
MEMORY   Find out how much memory is free in the region.
         MEMORY
MERD     merge lines from one edited data set to another
         MERD   <NAME> <IN-LINE-RANGE> <LINENUM3>
MERGE    merge lines from disk data set into edited data set
         MERGE   <DSNAME> <IN-LINE-RANGE> <LINENUM3>
MK       set a mark array element
         MK <IX>
ML       Obtain a list a partitioned dataset member names
         ML <pdsname> <volser>
MLL      Obtain a list a partitioned dataset member names
         MLL <pdsname> <volser>
MOVE     move lines in data set
         <LSU> 'MOVE' '('(<NAME>) (<LSU>)')' (<COPIES>)
           ('OL' × 'FROM' × 'TO')
MOVEP    move the graphics pen - see Appendix N
         MOVE <X> <Y> <Z> ('INCHES' × 'PIXELS')
MS       set mark array element 1
         MS
MSG      set the contents of the message area
         MSG <DATA>
MT       set mark array element 3
         MT
MV       set mark array element 4
         MV
NAME     assign a symbolic name to an edited data set
         NAME <NAME> SUPPORT
NAMELOC  determine if symbolic name for edited data set is in use.
         NAMELOC <NAME>
NCODE    data encryption
         <LSU> NCODE <KEY>
NEWPEN   select a new graphics pen - see Appendix N
         NEWPEN <N>
NL       add a new line to the data set
         NL <DATA>
NUM      specify that a data set is numbered
         NUM
NUMCK    check a symbolic variable for numerics or justification
         NUMCK <SYMBOL> ALL PERIOD LEFT RIGHT CHAR
OL       overlay lines
         <LSU> OL <LSU> <NAME>
ORDER    sort for data sets with views
         ORDER BY name ('ASC' × 'DESC'), ...
OW       change screen size
         OW
PARM     Used in conjunction with ENTRY function to set parameters
         PARM <NAME> <KEYWORD> <VALUE>
PB       page back
         PB
PBSL     shift lines left
         <LSU> PBSL <AMT> <SCOL> <ECOL> R
PBSR     shift lines right
         <LSU> PBSR <AMT> <SCOL> <ECOL> <R × <MAXLEN>>
PDFC     convert from scrdef output to ABE panel definition
         PDFC
PDFD     display panel definition from card images in full-screen
         PDFD
PDFQ     set panel definition from card images
         PDFQ
PDFS     convert panel definition from card images and save
         PDFS <data set>
PEEK     Peek at main storage.
         PEEK <ADDRESS> (<KEYWORD> (<LEN> (<SYMBOL>)))
PEL      Set bits on or off in BITMAP.
         PEL <PEL> <XREF> <YREF>
PF       page forward
         PF
PFK      program function keys
         PFK <NUMBER> <OPERANDS>
PGM      invoke user-written subcommands
         PGM <PGM-SPEC> <OPERANDS>
PLOT     plot an expression
         PLOT <EXPRESSION>
POOL     dump a symbolic variable pool
         POOL <pool>
PRT      print the data set directly on sysout
         PRT SYSOUT() CC() DEST() NOCC HOLD SEQ
PURGE    delete the currently edited data set
         PURGE
R        execute any ABE subcommand after symbolic replacement
         R <SUBCOMMAND>
RANDOM   generate a sequence of random numbers
         RANDOM <RANGE> <COUNT> <SEED> INTERNAL
REFRESH  restore from last save
         REFRESH <LINE> <COUNT>
RELJOIN  do a relational data base type join
         RELJOIN <TAB-A> <TAB-B> <TAB-C> <OFFSET> <LENGTH>
RENUM    renumber data set
         RENUM   <NEW-LINENUM>  <INCREM>
RESEQ    resequence data set
         RESEQ <OFFSET> <LENGTH>
RESET    reset suppressed lines
         RESET <CNT> F
                     L
RLIM     set return code stack flush limit
         RLIM <limit>
RUN      execute list of ABE subcommands
         <LSU> RUN <NAME> <KEYWORDS>
SAS      ABE interface to SAS
         SAS <KEYWORDS>
SAVE     save the edited data set
         SAVE   <DSNAME>
SCAN     puts terminal in scan mode (in contrast to input mode)
         SCAN <NUMBER>
SCANPDS  Used to apply ABE subcommands to all records in a PDS.
         SCANPDS <DSNSPEC) <SUBCOMMANDS> <OPTIONAL>
SELECT   part of Relational Query Language (RQL) subset
         (see appendix D)
SEQ      make line number data editable
         SEQ <OFFSET>
SET      replace data in a line
         SET <LINENO> <NEWDATA>
SETHEX   set replacement value for symbolic variable to hex data
         SETHEX <NAME> <HEX-STRING>
SETL     set replacement value
         SETL <VARIABLE> <TEXT> <OFF> <LENGTH>
SETLZF   set replacement value, left-zero filled to a given length
         SETLZF <VARIABLE> <N>
SETN     set replacement value
         SETL <VARIABLE> <TEXT>
SETRC    set system return code
         SETRC <RC>
SETSEQ   change line numbers
         SETSEQ <OLD_NUMBER> <NEW_NUMBER>
SHOW     show a data set on the display
         SHOW <NAME>
SL       shift lines left
         <LSU> SL <AMT> <SCOL> <ECOL> NOTRUNC
SLB      shift lines left within bounds
         <LSU> SLB <AMT> NOTRUNC
SLC      shift lines left based on cursor location
         <LSU> SL <AMT> 0 <ECOL> NOTRUNC
SNO      pattern recognition, selection and replacement
         <LSU> SNO <KEYWORDS> (':') <STATEMENT>
SORT     sort all lines
         SORT OFF1 LEN1 SEQ1 ... OFFN LENN SEQN
SORTL    sort specified lines
         <LSU> SORTL OFF1 LEN1 SEQ1 ... OFFN LENN SEQN
SORTNX   sort all unsuppressed lines
         SORTNX OFF1 LEN1 SEQ1 ... OFFN LENN SEQN
SORTNXL  sort specified unsuppressed lines
         <LSU> SORTNXL OFF1 LEN1 SEQ1 ... OFFN LENN SEQN
SORTQ    sort all lines quickly
         SORTQ OFF1 LEN1 SEQ1 ... OFFN LENN SEQN
SORTQL   sort specified lines quickly
         <LSU> SORTQL OFF1 LEN1 SEQ1 ... OFFN LENN SEQN
SORTX    sort all suppressed lines
         SORTX OFF1 LEN1 SEQ1 ... OFFN LENN SEQN
SORTXL   sort specified suppressed lines
         <LSU> SORTXL OFF1 LEN1 SEQ1 ... OFFN LENN SEQN
SPLINE   Draws a smooth curve based on the input points
         SPLINE <XARRAY> <YARRAY> <XOUTARRAY> <YOUTARRAY> <K> <1>
SPLIT    divide lines
         <LSU> SPLIT <<'NUMBER'> × <'STRING'>> ALL
SPLITB   divide lines using blanks as a delimiter
         <LSU> SPLITB
SR       shift lines right
         <LSU> SR <AMT> <SCOL> <ECOL> NOTRUNC
SRB      shift lines right within bounds
         <LSU> SRB <AMT> NOTRUNC
SRC      shift lines right based on cursor location
         <LSU> SR <AMT> 0 <ECOL> NOTRUNC
SUBMIT   submit current edited data set
         SUBMIT
SUBSTR   store constant data in records
         <SUBCOMMAND> ::=
             <LSU> 'SUBSTR' <POSITIONAL> ('OFF('<SUB-OFF>')')
             ('LEN('<SUB-LEN>')') (<KEYWORD>)
         <KEYWORD> ::= 'RND' × 'COL' × 'SAMECOL' × 'INCR' × 'DECR' ×
             'CYCLE' × 'EXPRESSION' × 'CTLLEN' × 'CTLOFF' ×
             'LOOKUP' × 'PUKOOL' × 'HEX'

SUFFIX   eliminates trailing blanks
         SUFFIX
SUPPORT  changes support status of data set
         SUPPORT ON × OFF × SHOW × NOSHOW
SUPPRESS suppress lines from being displayed
         <LSU> SUPPRESS S
SWAP     exchange positions of two data sets on display
         SWAP <NAME>
SYMC     display replacement values
         SYMC <SYMBOL>
TAB      set tab positions
         TAB <INTEGER-LIST>
TABK     assign a tab key character
         TABK <TABCHARACTER>
TEXT     specify text on graphics drawing - see Appendix N
         TEXT <TEXT> <HEIGHT> <FONT> <WSCALE> <SWCHAR>
TGET     issue the TGET macro and obtain input
         TGET <NAME> EDIT   WAIT
                     ASIS   NOWAIT
TOGGLE   scan for delimiters
         TOGGLE <START> <STOP>
TOP      move display to top of data set
         TOP
TPG      issue the TPG macro and obtain input
         TPG <OUTPUT> × '<HEXDATA>' <INPUT> WAIT    NOHOLD
                                            NOWAIT  HOLD
TPUT     issue the TPUT macro
         TPUT <name> × '<hexdata>' FULLSCR  WAIT   NOHOLD
                                   EDIT     NOWAIT HOLD
                                   NOEDIT
                                   ASIS
                                   CONTROL
TRACE    create a record of all screen displays
         TRACE 'ON' × 'OFF'
TRANSLAT translate unprintable characters to periods
         <LSU> TRANSLAT <Y> <Z>
TRANSPOS rotate the characters in a range of lines about an axis.
         <LSU> TRANSPOS <AXIS> <SUBGROUP>
TRTAB    modify the global character translate table.
         TRTAB <HEX_CHAR> <HEX_TRANSLATE>
TRUNCATE indicate last column of data set to be displayed
         TRUNCATE <NUMBER>
TS       split a line at a location indicated by the cursor
         TS <NUMBER>
UNNUM    make the data set unnumbered
         UNNUM
UP       move display up
         UP <NUMBER>
UPDATE   update fields defined via USE subcommand
         (see appendix D)
UPDATEC  update fields defined via USE subcommand in current record
         (see appendix D)
USE      define record fields
         USE INPUT <FIELD-SPECS> <ORDER-SPECS> <WHERE-SPECS>
             FIXED
             LIST
             LISTAVL
             SET
             NOSYM
             IN
             OUT
             <NAME>
VERIFY   compare two or more data sets for equality
         VERIFY <START-COL> <END-COL>
VOLSER   Obtain the volume serial under which a dataset is cataloged.
         VOLSER <DSNAME> <SYMNAME>
VTOC     obtain dscbs from a vtoc
         VTOC <VOLSER> ('0') ('1') ('2') ('3') ('4') ('5')
WATDATE  convert dates between the forms YYDDD, MMDDYY, and YYMMDD
         <lsu> WATDATE <date>
X        puts terminal in xmode
         X PROMPT() NEW CONTINUE × X 'CMD' × X
XOFFSET  Set graphics offset - see Appendix O
         XOFFSET <XOFFSET>
XSCALE   Set graphics scale - see Appendix O
         XSCALE <XSCALE>
YOFFSET  Set graphics offset - see Appendix O
         YOFFSET <YOFFSET>
YSCALE   Set graphics scale - see Appendix O
         YSCALE <YSCALE>
ZCALC    calculator function - results are zero supporessed
         ZCALC <optional-expression>

 Following is a list of line subcommands.  These are subcommands
 that can be entered in the sequence number fields on the display.
 See help for each subcommand for more details:

  b  - blank
  i  - blank
  a  - blank
  c  - clear
  cc - clear
  r  - copy
  rr - copy
  d  - delete
  dd - delete
  e  - exec
  ee - exec
  hi - hi
  lo - lo
  v  - md
  p  - md
  m  - mk n
  me - mk 2
  mk - mk n
  ms - mk 1
  mt - mk 3
  mv - mk 4
  f  - reset
  l  - reset
  g  - run
  gg - run
  s  - setseq
  <  - sl
  << - sl
  (  - slb
  (( - slb
  sl - slc
  >  - sr
  >> - sr
  )  - srb
  )) - srb
  sr - src
  &  - symc
  x  - suppress
  xx - suppress
  ts - ts

  NOTE:  the line subcommands MS, ME, and MT differ slightly from
  the other line subcommands in that they can appear concurrently
  in the same line number field, e.g. "msme" would be legitimate
  in a given line number field, and would cause that line number to
  be stored in both mark array elements 1 and 2.

)F FUNCTION -
  The ABE command is used to create or modify sequential data sets
  or members of partitioned data sets. It is designed to work on a
  3270 crt display terminal, and uses the special capabilities of
  the terminal to display the data set(s) being edited.  ABE is also
  useable from other types of terminals.  Through use of the
  HARDCOPY keyword, ABE may also be invoked from a clist.  The
  following clist, for example, will edit any member of data set
  "u.sd.u000.subrtnes.list", and will delete the last line if it
  contains a 1 in column 1, and will delete lines 10 thru 60 if line
  30 contains "PAGE    0" beginning in column 53.

          PROC 1 MEM
          ABE  'U.SD.U000.SUBRTNES.LIST(&MEM.)' NON HARDCOPY
          '&&1 DEL' 1(('1':1:1 B))
          '10 60 DEL' 1(('PAGE    0':53 30))
          SE

 +Records may be either fixed or varying in  length.
 +Note that ABE is continually being changed and enhanced.  Any
  program bugs currently outstanding are documented in this help
  data.  You can get a list of these problems by entering "help
  problems" while in xmode entered via the help subcommand.
 +Note that ABE is a virtual editor.  That is, it keeps the entire
  data set being edited in virtual storage.  This means that you
  must supply a large enough region.  Use the size parameter at
  logon to specify at least a 2000k region.
 +Note that help can be entered under abe  either as a subcommand
  to find out about other subcommands of the abe  command (find,
  top, bottom, etc.), or as a major command to find out about
  other major commands (pli, listc, listds, etc.).  While under
  abe , if you are not currently in xmode (see help data for the
  x subcommand), and you enter "help" in the command area,
  abe  assumes the help subcommand, and will give you a list of
  subcommands.  When the list is displayed, abe  puts you in
  xmode.  If you have entered xmode in this fashion, until you
  return to scan mode, any help commands you enter are assumed to
  be requests for subcommand data.  If you enter xmode via the x
  subcommand, any help commands you enter are assumed to be
  requests for major command data.
 +Note that you can display and edit several data sets at
  the same time.  In this situation, each data set displayed has its
  own command line, and a subcommand entered on each command line
  applies only to the data set owning that command line.  In
  addition, any subcommand prefixed by the word "all" entered on any
  command line applies to all data sets currently being edited.  In
  the case of the top data set on the display, the command line is
  the fourth line down.  For other data sets on the display, the
  command line is the top line of the display area owned by the data
  set, and is identified by the character string ====> at the left
  end of the line.  Subcommands can be entered on any number of
  command lines at the same time.  Also, multiple commands can be
  entered at the same time in a single command line by entering a
  non-alphameric character (e.g. /, @) other than % as the first
  character on the command line.  Dent will recognize this character
  as a delimiter.  For example, /10 80 50. sr 5/10 80 40. sr 5/top,
  which is a string of three subcommands, could be entered on a
  command line.
 +Note also that if a subcommand is too long to fit on the command
  line, enter a plus sign (+) as the last character on the command
  line.  This is considered by ABE to be a continuation character.
  It will clear the screen and prompt you for more text for the
  command.  For example, you enter -

      1 2  +

  the screen will be cleared, and you will be prompted.  If you
  then enter -

      substr +

  you will be prompted again.  If you then enter

      'how now brown cow'

  the actual subcommand executed will be -

      1 2 substr 'how now brown cow'

 +Note that ABE can also be executed as a batch utility.
  Sample JCL follows:

  // EXEC PGM=ABEB,REGION=3000K,DYNAMNBR=30,
  // PARM='FIRST(TOM) LAST(SMITH)'
  //SYSPRINT DD SYSOUT=*
  //SYSRUN DD DSN=U.SD.U000.RUN,DISP=SHR  RUN LIBRARY
  //SYSLIB DD DSN=U.SD.U000.TEXT,DISP=SHR INCLUDE LIBRARY
  //OUT DD DSN=&OUT,DISP=(NEW,PASS),
  // UNIT=DISK,SPACE=(TRK,(1)),
  // DCB=(LRECL=80,BLKSIZE=80,RECFM=F)
  //IN DD *
  $CMD ECHO
  $CMD RLIM 4
  MY FIRST NAME IS &FIRST
  AND MY LAST NAME IS &LAST
  //SYSIN DD *
  LIST

  In the above JCL, the PARM field may contain any keyword you
  choose.  The keywords specify symbolic variable names and the
  associated parenthesized values specify their replacement
  values.  DD statements IN and OUT are both required.  IN must
  contain a RUN command list which will be run from OUT as though
  "$control nl" were preceding it.  When the RUN on IN is
  finished, a SAVE will be automatically issued to save the
  results in the OUT data set, and if SYSIN is supplied, it
  will be opened and any subcommands it contains will be executed.
  Finally, an "all end nosave" subcommand will be issued to
  terminate any further ABE processing.

)O OPERANDS -
  <dsname> - If the sysout keyword is not specified,
   this is the name of the data set to be created or edited.  If
   the fully qualified data set name is specified, it must be
   enclosed in single quotes.  If the data set name is not
   entered within quotes, the userid as a qualifier is appended
   to the left of the name, unless the "noprefix" keyword is
   specified (see help data).  If the rightmost qualifier is not
   entered by the user, one will be appended for him.  If more
   than one data set exists with the specified name, the user
   will be prompted to select the appropriate qualifier.

   <dsname> may also be a parenthesized list of dsnames,
   as in -

      abe (jobcard cntl(jcltemp) sample.data)

   In this case, all three data sets will be brought up on the
   display for editing at the same time.

   If the ABE subcommand is being entered on the subcommand line
   for a partitioned data set member currently being edited, and
   the ABE subcommand being entered specifies a member of the
   same partitioned dataset, a shorthand reference can be used
   in which the partitioned dataset name is not specified.  Only
   the member name is entered surrounded either by double
   parentheses or single braces, e.g. -

     abe ((jcltemp))

       or

     abe {jcltemp}

  +Note - the abe  command will enqueue on this data set,
   DISP=SHR.  If you subsequently do a SAVE subcommand, a system
   enqueue on the same name as used by utility u098ms01 will be
   issued before the save operation is done.
  +If the SYSOUT keyword is specified, <dsname> is not a dsname.
   instead, it indicates a job on sysout.  ABE will retrieve the
   sysout via the output command, and then display the data for
   editing.  The specification is in the form xx(jnn), where "xx"
   is the characters suffixed to your userid in the jobname,
   or if "xx" is longer than two characters, it is assumed to be
   the entire job name.
   The "(jnn)" part of the specification is optional.  Replace the
   "nn" with the jes job number.  The sysout will be retreived
   into a data set with name in the form "userid.jobname.outlist".
   Dent will check to see if the data set already exists.  If it
   does, it will use the existing copy.  If it doesn't, it will
   create one with the attributes lr(137) bl(19000) recfm(vba).
))CLIST - This keyword is used to specify which symbolic
   substitution subroutines are to be used, and should only be
   specified when ABE is being invoked from a clist.  To better
   understand what this keyword does, consider the following
   clist statements:

      1 ABE xyz hardcopy
      2 1982 mk 1
      3 getmk 1 lastln
      4 symc lastln
      5 set 10 'lastln = &lastln'

   Line 4 in the clist will cause the value "1982" to be printed
   at the terminal.  Line 5 will fail with an error message from
   TSO indicating that symbolic variable LASTLN is not initialized.
   The problem arises because ABE has its own internal symbolic
   substitution routines, which reference a different set of
   symbolic variables than those referenced in the CLIST logic.
   To get the above clist to work as desired, add the CLIST keyword
   on the ABE command in line 1 (ABE xyz hardcopy clist).  This
   will tell ABE to use the clist substitution facilities instead
   of its own.
))COUNT() - This keyword is used to limit the number of lines
   brought in for editing.  If count(500) is specified, for
   example, a maximum of 500 lines will be read in.  If you
   subsequently do a save back into the original data set,
   any lines not read for editing will be lost.
))DBD - This keyword tells ABE to immediately issue a "use in"
   subcommand for the new data set.  Note that the DBD keyword is
   the default if the low-level qualifier for the data set to be
   edited is DB (e.g. X75826.INVENTRY.DB).  If you don't want this
   default, use the NODBD keyword. See documentation for the USE
   subcommand for further details.
))DB2 - Equivalent to entering both the DB2IN and DB2OUT keywords.
))DB2IN - Indicates that the input data set is a table currently
   residing in a DB2 database.  See Appendix K for further
   information.
))DB2OUT - Indicates that the output data set is to be a table
   residing in a DB2 database.  See Appendix K for further
   information.
))FAM() - Specifies the name of aload module to be used when
   accessing records in the file.  This module receives a
   standard parameter list, which is documented in Appendix A
   under the title "file access modules".
))HARDCOPY - This keyword is used to force abe  to operate as
   though it were being invoked on a terminal other than a 3270.
   If HARDCOPY is specified, ABE will not use full screen mode,
   but instead will prompt you at the terminal for each
   subcommand with the string "ABE".  The HARDCOPY keyword is
   especially useful for running ABE in a clist.  The following
   clist, for example, will edit any member of data set
   "u.sd.u000.subrtnes.list", and will delete the last line if it
   contains a 1 in column 1, and will delete lines 10 thru 60 if
   line 30 contains "PAGE    0" beginning in column 53.

          PROC 1 MEM
          ABE  'U.SD.U000.SUBRTNES.LIST(&MEM.)' NON HARDCOPY
          '&&1 DEL' 1(('1':1:1 B))
          '10 60 DEL' 1(('PAGE    0':53 30))
          SE

))HEX - This keyword causes the data set to be displayed in hex
   mode.  In this mode, each record is displayed on two lines of
   the screen.  The first line will contain the record in ebcdic,
   except that unprintable characters will be translated to
   blanks, and a space will be inserted after each character
   of the record.  This spacing is done so that the characters
   will match up with their hexadecimal representation, which is
   displayed on the second line.  You can change data for the
   record in either line of the display, but remember that the
   first line contains periods where unprintable characters
   exist in the record; if you change data in this line, the
   unprintable characters in the record will be replaced with the
   periods from the display.  If you change data in the second
   line for a record, use hexadecimal character representations
   (e.g.  C1 = 'a').
))HICASE - Use this keyword to indicate that the data lines
   entered by the user in lower case on the display are to
   translated to upper case.  Note that the default for data sets
   with the descriptive qualifier "text" is locase, and for all
   others is hicase.
))INFILE() - This keyword may be used when you have preallocated
   the data set to be edited under a particular file name.  For
   example, if you had previously entered the TSO command
   "ALLOC FI(PPP) DA('U.SD.U000.DATA') SHR VOL(FSD300)", then
   you could edit that specific data set by entering
   "ABE X INFILE(PPP)".  Note that the X in the sample ABE
   command just shown has no meaning, but must be supplied
   because the parsing routine requires that a positional
   parameter always be entered as the first operand to ABE .
   Note also that when the END subcommand is entered for this
   data set, the file will remain allocated under the ddname PPP.
   This is contrary to the normal operand of ABE in which the
   edited file is freed when the END subcommand is entered.
))INPUT() - This keyword is used to specify an initial set of ABE
   subcommands to be executed immediately.  For example,
   "abe  data inp(/0 bl 5/top)" indicates that as soon as data
   set "data" is brought in for editing, the two subcommands
   "0 bl 5" and "top" are to be executed immediately.
   NOTE:  Maximum length of the INPUT string is 80 characters.
))INTERNAL - This keyword is ignored unless either the DB2 or the
   DB2IN keyword is also specified.  In this case, INTERNAL tells
   the editor to maintain fields retrieved from a DB2 table in
   internal form (packed decimal, floating point, fixed point, etc.).
   This may provide more efficient processing because data conversion
   need not be done to evaluate expressions involving fields in
   the data set.
))LINE() - This keyword is used to indicate the first line to be
   read from the data set to be edited.  If line(1000) is
   specified, for example, the first 999 lines will be skipped,
   and the first line read in for editing will be line 1000.
   Note that if you do a save back into the original data set,
   any lines not read for editing will be lost.  In the example,
   just cited, the first 999 lines would be lost.
))LOCASE - Use this keyword to indicate that the data lines
   entered by the user in lower case on the display are to remain
   in lower case.  Note that the default for data sets with the
   descriptive qualifier "text" is locase, and for all others is
   hicase.
))NAME() - This keyword can be used to assign a name (8
   characters or less) to the data set to be edited.  Note that this
   name has nothing to do with the data set name.  It is merely a
   tag to be used in certain ABE subcommands, such as MERD, and
   PFK.  This name will be displayed, along with the dsname, to the
   right end of the command line for that data set.
))NODBD - This keyword tells ABE NOT to immediately issue a "use in"
   subcommand for the new data set.  It would normally only issue
   the "use in" subcommand automatically if the DBD keyword were
   specified, or the low-level qualifier for the data set to be
   edited is DB (e.g. X75826.INVENTRY.DB). See documentation for the
   USE subcommand for further details.
))NOFREE - Specifying this keyword causes the data set to remain
   allocated when the END subcommand is entered for the data set.
   Normally, unless the edited data set is part of a concatenation,
   ABE  will automatically free the data set.
))NONUM - Use this keyword to indicate that the data set to be
   edited is an unnumbered data set.
))NOPREFIX - This keyword affects way the dsname that you
   specify for the data set to be edited is to be handled.  If
   you specify "noprefix", the data set name should not be
   entered in quotes, and your userid will not be prefixed.
))NOPROMPT - Specifies that if the data set to be edited does
   not already exist, ABE will create it without prompting you
   at the terminal.  If this keyword is not specified, the message
   "Data set does not exist - enter 'yes' to create one or 'no'".
))NOSHOW - Specifies that the data set is not to be given ownership
   of display lines if does not currently own any lines when a lines
   subcommand without operands is issued for another data set
   currently being edited.  See also the SHOW and NOSHOW keywords of
   the SUPPORT subcommand.
))OUTFI() - may be used to specify a preallocated data set into
   which data will be written when a SAVE subcommand is issued.
))OUTDA() - This keyword specifies an optional output data set
   into which the edited data will be written when a save subcommand
   is issued without a dsname operand.  If the fully qualified data
   set name is specified, it must be enclosed in single quotes.  If
   the data set name is not entered within quotes, the userid is
   always appended to the left of the name.  If the rightmost
   qualifier is not entered by the user, one will be appended for
   him if the output data set already exists.  If more than one data
   set exists with the specified name, the user will be prompted to
   select the appropriate qualifier.  If no data sets exist with the
   specified name, one will be created.
))OVOL(<VOLSER>) -  If this keyword is NOT specified, a search is
   made of currently allocated datasets to see if a matching output
   dsname can be found (The OUTDA keyword is used to specify the
   output dsname). If no match, the catalog is used allocate the
   dataset.  If the OVOL keyword is specified, the output dataset
   must exist on that disk volume for the ABE subcommand to be
   successful.
))PDF - This keyword is used when you want to add or change a
   panel format definition.  Such definitions are used in
   conjunction with the $fullscr and $seto statements of the PIL
   language used with the RUN subcommand.  This facility allows
   you to easily define your own full-screen panel displays.

   Suppose, for example, I wanted to create a new panel definition
   called "TSTPNL". To do so, I would issue the ABE  command as
   follows:

     abe  'u.sd.u000.panel(tstpnl)' pdf

   Data set 'U.SD.U000.PANEL' is my panel definition library.
   It should be a partitioned data set, and can have any LRECL
   up to 256, and can be either RECFM=VB or RECFM=FB, and can
   have any BLKSIZE up to full-track.  My panel definition
   library has the attributes (LRECL=80,BLKSIZE=19040,RECFM=FB).

   Since member TSTPNL does not exist, ABE  will display a blank
   screen on which I can define the new panel format.  Note that
   if the panel had already existed, ABE  would have displayed the
   existing definition so that I could make alterations.  If
   ABE  displays an existing panel, and I don't alter anything on
   the panel, it assumes I was just browsing and it will not update
   the library.

   You can define two different kinds of fields on the display:
   (1) literal fields, which are protected, and are used only
   for output; (2) input fields, which are unprotected, and are
   used both for output and for input from the terminal.

   You define the starting position of literal fields by
   placing an @ character on the screen, followed by any literal
   data you want displayed.  Note that you should always assume
   that an @ character is in the upper left-hand corner of the
   panel definition, but for technical reasons, it isn't displayed
   on the blank screen supplied by abe  during panel definition.

   You define the starting position of input fields by placing
   an & character on the screen, followed by a sequence of one
   or more X characters defining the length of the input field.

   The following box surrounded by asterisks simulates the
   appearance of the screen after defining a panel consisting of
   seven fields, four of which are literal fields and three of
   which are input fields:

   *****************************************************************
   * sample panel definition                                       *
   *                                                               *
   *       @first input field:&xxxxxx@                             *
   *                                                               *
   *                  second input field:&xxxxxx@                  *
   *                                                               *
   *                            third input field:&xxxxxx          *
   *                                                               *
   *****************************************************************

   Fields in a panel are referenced by name, and the field names by
   default have the form Fddddd, where ddddd is a five-digit number.
   The first field in the panel will be named F00001, and in this
   case, is a literal field in which the characters "SAMPLE PANEL
   DEFINITION" will be displayed by default.  The second field on
   the panel is named F00002, and in this case is also a literal
   field containing "FIRST INPUT FIELD:". The third field in our
   sample panel definition is called F00003, and is an input field
   of length 6, and so on.

   Note that you may override the default names for input fields.
   Specifying "&address   " on a panel, for example, would designate
   an input field named "address".  Note that your input field names
   must begin with an alphabetic character "A" to "Z", other than
   "X", and can only be up to eight characters long.

   Once you have finished defining all of the fields on a panel,
   the last thing you should do before hitting enter is to place
   the cursor where you want it when the panel is displayed.

   For further discussion on using your own full-screen panel
   displays, see the $fullscr and $seto statements of the PIL
   language described in the documentation for the RUN
   subcommand of ABE .

   It is frequently the case that you will want to repeat the
   field pattern on the screen.  For example, you want to define
   a panel such as the following:


   *****************************************************************
   *                 personal profile data panel                   *
   * division:&xxx@  department:&xxxx@                             *
   *         name              age       height      weight        *
   *  --------------------      --         ---         ---         *
   * &xxxxxxxxxxxxxxxxxxxx@    &xx@       &xxx@       &xxx@        *
   * &xxxxxxxxxxxxxxxxxxxx@    &xx@       &xxx@       &xxx@        *
   * &xxxxxxxxxxxxxxxxxxxx@    &xx@       &xxx@       &xxx@        *
   * &xxxxxxxxxxxxxxxxxxxx@    &xx@       &xxx@       &xxx@        *
   * &xxxxxxxxxxxxxxxxxxxx@    &xx@       &xxx@       &xxx@        *
   * &xxxxxxxxxxxxxxxxxxxx@    &xx@       &xxx@       &xxx@        *
   * &xxxxxxxxxxxxxxxxxxxx@    &xx@       &xxx@       &xxx@        *
   * &xxxxxxxxxxxxxxxxxxxx@    &xx@       &xxx@       &xxx@        *
   * &xxxxxxxxxxxxxxxxxxxx@    &xx@       &xxx@       &xxx@        *
   * &xxxxxxxxxxxxxxxxxxxx@    &xx@       &xxx@       &xxx@        *
   *                                                               *
   *****************************************************************

   To define this panel, you would merely type in the first five
   lines, and then hit program function key 1, as follows:


   *****************************************************************
   *                 personal profile data panel                   *
   * division:&xxx@  department:&xxxx@                             *
   *         name              age       height      weight        *
   *  --------------------      --         ---         ---         *
   * &xxxxxxxxxxxxxxxxxxxx@    &xx@       &xxx@       &xxx@        *
   *                                                               *
   *****************************************************************

   Hitting program function key 1 tells ABE to replicate the last
   line defined on the panel for as many times as will fit on the
   screen.

   You may find it desireable to manipulate the panel definition
   as an editable data set consisting of 80-column card-images,
   one card for each line of the panel display.  This would allow
   you with the full capabilities of all the ABE subcommands in
   making changes to the panel definition.  You can achieve
   this state by either entering the PDFE keyword on the ABE
   command instead of the PDF keyword, or once the panel definition
   is in full-screen display, by pressing the program function key
   2.  You can subsequently return to the full-screen display of
   the panel definition by entering the PDFD subcommand, or you
   convert back from card-images and save the panel definition by
   entering the PDFS subcommand.
))PDFC - Used to specify that the input data set contains a screen
   format created using the SCRDEF command.  ABE will convert to
   the format useable by $FULLSCR in RUN.
))PDFE - This keyword is used when you want to add or change a
   panel format definition.  Such definitions are used in
   conjunction with the $fullscr and $seto statements of the PIL
   language used with the RUN subcommand.  A more detailed
   explanation of full-screen definitions may be obtained by
   looking at the help data for the PDF keyword of ABE.  The
   PDFE keyword differs from the PDF keyword in that the screen
   image comes up as a series of 80-column card-images in edit
   mode.  Thus, you can manipulate the screen definition with
   any of the ABE subcommands.  When you have completed a screen
   definition, you can convert it to the format useable by
   $fullscr and save it by using the PDFS subcommand (see help).
))PRI() - This keyword is used only in conjunction with the
   sysout keyword, and indicates the number of tracks to be
   allocated as primary space for the outlist data set to be
   created.  The default is 1.
))PROFILE - This keyword tells the editor to immediately issue
   the subcommand 'RUN $PROFILE' when the editor is invoked
   from READY mode.  The keyword will be ignored if ABE is
   issued as a subcommand.
))RECSIZE() - This parameter is used only if the <dsname> parameter
   is specified as ''.  It is used to establish a record size for
   a virtual data set.  The default recsize value is 256.
))SAS - Equivalent to entering both the DB2IN and DB2OUT keywords.
))SASIN - Indicates that the input data set is a table currently
   residing in a SAS library.  See Appendix K for further
   information.
))SASOUT - Indicates that the output data set is to be a table
   residing in a SAS library.  See Appendix K for further
   information.
))SECY() - This keyword is used only in conjunction with the
   sysout keyword, and indicates the number of tracks to be
   allocated as secondary space for the outlist data set to be
   created.  The default is 1.
))SUPPORT - Specify this keyword if the data set is to be a
   support data set.  See the help data for the ABE SUPPORT
   subcommand for details.
))SYSOUT() - this keyword specifies that the data set to be edited
   is currently a sysout data set.  Dent will retrieve the sysout
   via the output command, and then display the data for editing.
   The first operand of abe  ('dsname') indicates the job for
   which sysout is to be retrieved.  The specification is in the
   form xx(jnn), where "xx" is the characters suffixed to your
   userid in the jobname, or if "xx" is longer than two characters,
   it is assumed to be the entire job name.
   The "(jnn)" part of the specification
   is optional.  Replace the "nn" with the jes job number.
  +Note that you may optionally specify a list of sysout classes
   with the sysout parameter, e.g., "sysout(1 2 a)" indicates that
   only sysouts from classes 1, 2, and A are to be retrieved.
  +Note that if the entire job name is specified ("xx" longer than
   two characters) and you do not specify any sysout classes,
   the default will be sysout class 2.
  +Note that the ABE  subcommands $CC, $EDIT, $JE, $PK, $PP, $PRT,
   and $PURGE are designed to facilitate viewing msgclass
   sysout.
  +Note that all unprintable characters are automatically
   translated to periods before the data is displayed.
))TRANSLAT - This keyword specifies that all unprintable
   characters in the data set are to be translated to periods
   before the data is displayed.  For more information,
   see the help data for the translat subcommand.  Note that
   the sysout keyword implies the translat keyword.
))VOL(<VOLSER>) -  If this keyword is NOT specified, a search is
   made of currently allocated datasets to see if a matching input
   dsname can be found.  If no match, the catalog is used allocate
   the dataset.  If the VOL keyword is specified, the specified
   dataset must exist on that disk volume for it to be edited.

=equals (=)                                                            @
)F FUNCTION -
  Entering = on the command line will cause the most recent
  subcommand to be reissued.
)X SYNTAX -
         =
  required - none
  defaults - none
)O OPERANDS - NONE

=$CC                                                                   @
)F FUNCTION -
  The $cc subcommand is designed for use when editing the msgclass
  sysout for a batch job.  It will cause all lines from the msgclass
  sysout except the lines indicating whether each step executed
  successfully or not to be suppressed from the display.  Thus, you
  can quickly scan to see which steps ran successfully, and which
  did not.
)X SYNTAX -
         $cc
  required - none
  defaults - none
)O OPERANDS - NONE

=$CLEAR                                                                @
)F FUNCTION -
  The $clear subcommand is used to reset the value to be displayed in
  each input field of the specified panel to blanks.  Note that the
  $clear subcommand is identical to the $clear statement of the PIL
  language described in the help data for the RUN subcommand
)X SYNTAX -
         $clear <panel>
  required - none
  defaults - none
)O OPERANDS - see above under FUNCTION

=$CURSOR                                                               @
)F FUNCTION -
  The $cursor subcommand is used to change the position of the
  cursor on the specified panel.
)X SYNTAX -
         $cursor <panel> <pos>
  required - none
  defaults - none
)O OPERANDS -
  <panel> is the name of the panel, and <pos> is the position at
  which the cursor is to be located. <pos> can be a number,
  indicating the position, relative 0, or it can be a field name,
  in which case the cursor will be positioned at the start of that
  field on the panel.

=$DECR=DECR                                                            @
)F FUNCTION -
  $DECR will decrement the replacement value for the specified
  symbolic variable by 1.  If the symbolic variable doesn't
  currently exist, or has a replacement value of blanks, the assumed
  value is 0.  When the decrement operation is complete, the
  replacement value will be set to a five digit number, left zero
  filled.  <amount> is optional, and indicates the amount to
  increment by.
)X SYNTAX -
  decr <symbol> <amount>
  required - <symbol>
  defaults - <amount>=1
)O OPERANDS - see above under FUNCTION

=$DISPLAY                                                              @
)F FUNCTION -
  The $display subcommand is used to load and display a panel with
  information from one or more records in the currently edited data
  set.
)X SYNTAX -
         $display <panel> break dup() line() list name() nobreak
            skip() premod nopremod high low
  required - none
  defaults - none
)O OPERANDS -
  $display is designed to work in conjunction with
  $store (see below), and the algorithm it uses for selecting data
  associated with each field on the display is identical to that
  used in $store.  This algorithm will first be described assuming
  that the LIST, DUP, NOBREAK, BREAK, and SKIP keywords are not
  used. Then, the manner in which the algorithm changes when any
  of these keywords are used will be described.

  It will simplify the explanation to define two imaginary
  cursors, called the "data cursor" and the "panel cursor".
  The data cursor is initialized to point at column 1 of the
  current record (which may be established using the LINE
  keyword).  The panel cursor is initialized to point at the
  start of the first line of the display containing an input
  field.  The algorithm then enters its main loop.

  In the main loop, the panel cursor is first moved to the
  starting position of the next input field defined on the panel
  display.  If the next input field is on a new line of the panel
  display, the current record pointer is changed to point at the
  next consecutive record in the file, and the data cursor is
  reset to 1. Data from the current record starting at the
  position defined by the data cursor for the length defined by
  the current input field is then set up for display in that input
  field.  Then, the data cursor is incremented by the defined
  length of the current input field.  If this causes the data
  cursor to point beyond the end of the current record, the next
  consecutive record is made the current record, and the data
  cursor is reset to 1.  The main loop is then repeated until all
  input fields defined on the panel display have been exhausted,
  at which time the loaded panel will be displayed.

  The BREAK() keyword is used to specify the display line-group
  size.  BREAK(1) for example, which is the default if neither
  the BREAK nor the NOBREAK keywords are specified, indicates
  that data from a single record will occupy fields on one line
  of the display.  BREAK(2) would indicate that data from one
  or more records will be used to fill 2 lines of the display,
  etc.  When filling fields of a display line-group with data,
  when the end of the current line-group is reached, any data
  in the current record not yet displayed will be ignored, and
  a new line-group will be defined, and a new record will be
  obtained to begin filling.

  The DUP keyword is used to indicate that data from a particular
  number of input fields on the display is common data. When the
  DUP keyword is specified, the algorithm works the same for the
  first record processed by $display, but, when the algorithm
  selects the first input field on a new line of the display, and
  consequently selects the next consecutive record in the file
  as the new "current record", the data cursor is not reset to 1,
  but instead will be reset to 1 plus the sum of the lengths of
  the first n input fields defined on the panel display, where n
  is the value specified in parenthesis following the DUP keyword.
  This facility is useful when you have defined a panel for data
  entry in which a certain number of input fields at the top of
  the display are for common information, and then each subsequent
  line of the display contains all the input fields for a
  particular observation, or entity.  The common information will
  be repeated at the start of the first record in each group of
  records containing the data for a particular observation, or
  entity.

  The LINE keyword may be used to specify the line number of the
  first record from which data is to be selected for display.
  If the LINE keyword is not specified, the current data record,
  which would be the top record on the display in normal edit
  mode, will be the first record from which data is to be selected
  for display.

  If the LIST keyword is specified, it is assumed that data items
  in the records are separated from each other by a blank space.
  This alters the algorighm in the main loop, where the data
  cursor is incremented by the defined length of the current
  input field, PLUS 1.

  The NAME keyword can be used to indicate the symbolic name of
  the data set from which data is to be displayed.

  The NOBREAK keyword is useful when you have defined a panel for
  data entry in which all fields on the panel constitute one
  observation, or entity.  When NOBREAK is specified, $display
  doesn't define a new current record each time a new line is
  encountered on the panel.  Instead, it just keeps processing
  data from the current record.   If the current record ends
  before all of the input fields from the panel have been
  processed, a new current record is defined, and data is
  processed from this record beginning in column 1 (the DUP
  keyword is ignored if NOBREAK is specified).

  The SKIP keyword is used to indicate those positions of each
  record which are to be ignored.  For example, suppose the
  records to be displayed have four fields; FLDAin columns 1 to
  10, FLDB in columns 11 to 20, FLDC in columns 21 to 30, and
  FLDD in columns 31 to 40.  Each line of the display named
  TEST has three input fields; call them IN1, IN2, and IN3 for
  this discussion.  The subcommand "$display test" will cause
  FLDA to be displayed in field IN1, FLDB to be displayed in
  IN2, and FLDC to be displayed in IN3.  FLDD will not be
  displayed.  However, the subcommand "$display test skip(11:20)"
  will cause FLDA to be displayed in field IN1, FLDC to be
  displayed in IN2, and FLDD to be displayed in IN3.

  Any number of column range specifications can be specified
  with the SKIP keyword, e.g. "skip(11:20 31:40 50:75)".

  Note that SKIP specifications must be coordinated with field
  lengths in the records.  That is, skip specifications and
  field boundaries may not overlap.  For example, if three
  fields are to be displayed, each 10 columns long, with NOBREAK
  in effect, these fields would be extracted from columns 1-10,
  11-20, and 21-30, respectively, from each data record.  If
  SKIP(11:22) were specified, the data would be extracted from
  columns 1-10, 23-34, and 35-46.  But is SKIP(15:22) were
  specified, the data would be extracted from columns 1-10,
  11-20, and 23-34.

  Note that $display is now also an ABE subcommand.

  The keywords PREMOD, NOPREMOD, HIGH, and LOW, are all similar in
  effect to the same keywords of the $SETO subcommand, except that
  when these keywords are used on the $DISPLAY subcommand, they
  apply to all input fields on the panel.

=$EDIT                                                                 @
)F FUNCTION -
  The $edit subcommand is designed for use when editing the
  msgclass sysout for a batch job.  It will first cause the
  currently edited data set to be deleted, and will then
  display for editing data set lastjcl.cntl.
)X SYNTAX -
         $edit
  required - none
  defaults - none
)O OPERANDS - NONE

=$FULLSCR                                                              @
)F FUNCTION -
  The $fullscr subcommand is used to display data in full-screen
  format.
)X SYNTAX -
         $fullscr <panel>
  required - none
  defaults - none
)O OPERANDS -
  <panel> identifies a member of the panel format definition
  library, which must be allocated under the ddname SYSPNL.  Each
  member of the panel format definition library is defined and
  changed using the ABE command.  See documentation on the PDF
  keyword of ABE  for more information on defining panel formats.

  Once the specified panel has been displayed, certain symbolic
  variables will have been assigned new replacement values.
  Symbolic variable &CURSOR will have a replacement value of five
  digits equal to the cursor location when the user at the
  terminal hit ENTER or one of the program function keys. Symbolic
  variable &PFK will have a replacement value of "00000" if the
  user at the terminal hit the ENTER key, or will have one of the
  replacement values "00001" thru "00012" depending on which of
  the program function keys 1 thru 12 the user hit. Symbolic
  variables with names of the form &Fddddd will be defined for
  each unprotected input field in the panel.  If you have read the
  documentation of the PDF keyword of the ABE  command, you will
  recall that each field on the display is assigned a name of the
  form Fddddd.  If a panel has an input field named F00003, for
  example, then after that panel has been displayed via the
  $FULLSCR statement, provided you haven't protected the input
  field via the $SETO or $DISPLAY subcommands, symbolic variable
  &F00003 will have a replacement value equal to the value keyed
  by the user in that input field.

  See documentation on the $seto statement to see how to set the
  value to be displayed in each field of a panel.

=$GETMK=GETMK                                                          @
)F FUNCTION -
  Used to obtain the current value stored in the mark array.
  <number> tells the mark array element number from which data
  is to be extracted.  <label> tells the symbolic variable name
  to which the data is to be assigned.  <name> is optional, and
  gives the symbolic name associated with the data set whose
  mark array is to be accessed.
)X SYNTAX -
  $getmk <number> <label> <name>
)O OPERANDS - see above under FUNCTION

=$INCR=INCR                                                            @
)F FUNCTION -
  $INCR will increment the replacement value for the specified
  symbolic variable by 1.  If the symbolic variable doesn't
  currently exist, or has a replacement value of blanks, the assumed
  value is 0.  When the increment operation is complete, the
  replacement value will be set to a five digit number, left zero
  filled.  <amount> is optional, and indicates the amount to
  increment by.
)X SYNTAX -
  $incr <symbol> <amount>
  required - <symbol>
  defaults - <amount>=1
)O OPERANDS - see above under FUNCTION

=$JE                                                                   @
)F FUNCTION -
  The $je subcommand is designed for use when editing the
  msgclass sysout for a batch job.  It will locate message
  ief376i (job end), which is normally the last message in
  jcl.
)X SYNTAX -
         $je
  required - none
  defaults - none
)O OPERANDS - NONE

=$PK                                                                   @
)F FUNCTION -
  The $pk subcommand is designed for use when editing the
  msgclass sysout for a batch job.  It will first issue the
  $prt subcommand to cause the data set to be printed, and
  will then end editing of the msgclass sysout data set.
)X SYNTAX -
         $pk
  required - none
  defaults - none
)O OPERANDS - NONE

=$PP                                                                   @
)F FUNCTION -
  The $pp subcommand is designed for use when editing the
  msgclass sysout for a batch job.  It will first issue the
  $prt subcommand to cause the data set to be printed, and
  will then end editing of the msgclass sysout data set,
  and will also delete the outlist data set containing the
  sysout data.
)X SYNTAX -
         $pp
  required - none
  defaults - none
)O OPERANDS - NONE

=$SETD=SETD                                                            @
)F FUNCTION -
  The $setd statement is used to set the replacement value for
  a symbolic variable to data from a line in one of the data
  sets currently being edited.  <variable> is the name of the
  symbolic variable whose replacement value is to be set.  Note
  that the ampersand should not precede the variable name.
  <line> is the line number of the line from which data is to
  be extracted.  if * is specified, the current line in the data
  set will be used.  <off> is the offset, relative 1, at which
  data in the specified line is to be selected.  <len> is the
  length of data to be selected.  <name> is optional.  If
  specified, it indicates the symbolic name (assigned perhaps
  with the NAME subcommand) associated with the data set from
  which the line is to be selected.
)X SYNTAX -
  $setd <variable> <line> <off> <len> <name>
)O OPERANDS - see above under FUNCTION

=$SETO                                                                 @
)F FUNCTION -
  The $seto subcommand is part of the package that facilitates using
  full-screen displays under ABE.
)X SYNTAX -
         $seto <panel> <fldno> <value> premod nopremod high low
               prot unprot suppress tran notran
  required - <panel> <fldno> <value>
  defaults - none
)O OPERANDS -
  This statement is part of the package that facilitates
  full-screen displays.  See also the $FULLSCR subcommand.

  $SETO allows you to specify the value that is to be displayed in
  a particular field of a particular panel.  <panel> specifies the
  name of the panel to be displayed.  <fldno> specifies either the
  field number or the field name of the field whose output is to
  be changed. <value> is the value to be displayed.

  PREMOD is an optional keyword useful only when setting the
  output value for unprotected input fields.  If specified, it
  indicates that the premodified flag is turned on for this field.
  This means that if the user doesn't modify this field, the
  output value you specify will be assumed as the input value.
 +Note that you cannot specify the PREMOD keyword for a literal
  field; PREMOD applies only to input fields.  If you specify
  PREMOD for a literal field, an error message will be generated,
  and the return code from $SETO will be set to nonzero.

  HIGH is an optional keyword which, when specified, causes the
  indicated field to be displayed in high intensity.

  LOW is an optional keyword which, when specified, causes the
  indicated field to be displayed in low intensity.

  PROT is an optional keyword which, when specified, causes the
  specified input field to be protected so that the terminal user
  cannot modify it.  Specifying the prot keyword will also cause
  the tab key to bypass the indicated field.

  UNPROT is an optional keyword used to unprotect an input field
  which was previously protected via the prot keyword.  Note that
  the unprot keyword does not apply to fields that were initially
  defined as literal fields (defined with an @ sign).

  SUPPRESS is an optional keyword used to indicate that the data
  keyed in the input field by the terminal user is not to appear
  on the screen.  You might use this option to protect a password
  which must be entered on the screen.

  TRAN is an optional keyword which indicates that the
  specified input field is to be translated to upper case.

  NOTRAN is an optional keyword indicating that the specified
  input field is not to be translated to upper case.

  Note that $seto is now also an ABE subcommand.

=$SETQUOT=SETQUOT                                                      @
)F FUNCTION -
  Transforms the replacement value for a symbolic variable into a
  quoted string (see also help data for SYMREP subcommand).
)X SYNTAX -
  $setquot <symbol-1> <symbol-2>
  required - none
  defaults - none
)O OPERANDS -
  <symbol-1> is the symbolic variable to which the results of
  this operation are to be assigned.  <symbol-2> is optional.
  If <symbol-2> is omitted, $setquot will transform &ANSWER
  into a quoted string.
  If <symbol-2> is specified, $setquot will transform the
  replacement value for <symbol-2> into a quoted string, and
  assign the result as the replacement value for <symbol-1>.
  Any apostrophes contained in the response will be doubled,
  and the entire response will be surrounded in apostrophes.

=$STORE                                                                @
)F FUNCTION -
  The $store subcommand is part of the package that facilitates using
  full-screen displays under ABE.
)X SYNTAX -
         $store <panel> dup(<n>) list line(<l>) mask nobreak skip()
  required - none
  defaults - none
)O OPERANDS -
  The $store statement provides a fast way of storing the input
  after displaying a panel using $fullscr or $display. The
  algorithm for storing data from the display into records is
  iabe ical to that used in $display for selecting data from
  records for display.  You might get a better understanding of
  this algorithm by first reading the documentation on $display,
  and then continuing on with this explanation.  The following
  process takes place:

  1.  Data from the first <n> unprotected input fields defined on
      the panel are obtained to create the string of data to be
      duplicated at the front of each new record group added to
      the data set.  <n> is the value specified in the DUP
      keyword, and defaults to 0.  Each field is padded with
      blanks to the length defined on the panel, and then is
      concatenated with the other input fields to form the string.
      If the LIST keyword was specified, a blank is also
      concatenated after each field in the string.

  2.  Next, a current record is defined, and the string of data to
      be duplicated (from step 1) is stored in it.  Then data in
      each succeeding unprotected input field is accessed, padded
      to its defined length with blanks, and concatenated onto the
      current record (with an extra blank inserted between fields
      if the LIST keyword was specified).  When the end of a line
      on the panel is reached, the record currently being built is
      stored in the data set, and step 2 is repeated.  Step 2 will
      continue to be repeated until (a) the end of the panel is
      reached, or (b) a line of the panel is encountered
      containing unprotected input fields, all of which are blank.
      Note also that if no more room exists in the current record,
      yet there are more unprotected input fields on the current
      line of the panel, the record will be stored in the data
      set, and a new current record will be defined, but the
      string of data to be duplicated (from step 1) will not be
      stored in it.  Instead, data from the next input field on
      the line will be stored beginning in column 1 of the new
      record.

  You will note that in the above discussions, the phrase
  "unprotected input field" is often used.  This is must be
  emphasized because if you have used $SETO or $DISPLAY to
  protect an input field, you must also use $SETO or $DISPLAY
  to unprotect that field before issuing $STORE, or $STORE will
  ignore that input field.

  If the LINE keyword is not specified, records containing the
  data from the input fields of the panel are added at the
  end of the edited data set.  Otherwise, data from the input
  fields of the panel will be stored in records beginning with
  the one specified in the LINE keyword.

  The MASK keyword can be used in conjunction with the LINE
  keyword to perform an update operation on the file from data
  keyed in on the display.  When MASK is specified, only those
  record fields associated with input fields on the display in
  which data was actually entered will be changed.

  The NOBREAK keyword is useful when you have defined a panel for
  data entry in which all fields on the panel constitute one
  observation, or entity.  When NOBREAK is specified, $store
  doesn't define a new current record each time a new line is
  encountered on the panel.  Instead, it just keeps adding data to
  the current line.  If the current line fills up before all of
  the input fields from the panel have been processed, a new
  current line is defined, and data is added to this record
  beginning in column 1 (the DUP keyword is ignored if NOBREAK is
  specified.  Note also that ALL input fields will be processed,
  regardless of whether a line on the panel is encountered in
  which all input fields are empty).

  <panel> defines the name of the panel from which input is to be
  obtained.

  The other keywords such as SKIP and BREAK are thoroughly
  described in the help data for $display.  When trying to
  understand how $display and $store work, remember that $display
  and $store are designed to work together.  To understand
  more clearly what this means, consider the situation in
  which you have displayed data using a $display subcommand
  with some set of operand values.  If you were to make some
  change to all of the displayed data, and then were to
  subsequently issue the $store command WITH EXACTLY THE SAME
  OPERANDS YOU USED ON THE PREVIOUS $DISPLAY, the data will be
  stored in exactly the same format as it was in when the
  $display was issued.

  Note that $store is now also an ABE subcommand.

=$XLATE                                                                @
)F FUNCTION -
  Ensures that the replacement value for the specified
  symbolic variable is all in upper case.  You might use
  this function after prompting for input from the terminal.
)X SYNTAX -
  $xlate <symbol>
)O OPERANDS - see above under FUNCTION

=ABE=SSE=LOAD                                                          @
)F FUNCTION -
  use the abe  subcommand to display additional data sets at the
  same time that the original data set is still displayed.
  When you enter the initial abe command, the specified data set
  is considered to "own" all 19 lines of the screen on which data
  is displayed.  When you subsequently enter the abe  subcommand,
  the 19 lines "owned" by the original data set will be split,
  with 9 lines used to display the second data set.  The first line
  allocated for the new data set will be taken as a command line.
  If you enter another abe subcommand on the new command
  line, the 9 lines "owned" by this data set will be split, and
  half will go to the new data set.  When you enter the end
  subcommand for a data set "owning" lines of the display, those
  lines will be inherited by the data set owning lines just above
  on the display, or the next lower data set in the display if the
  data set being ended is the top data set.
    Ownership of display lines by a data set can be altered by
  using the lines subcommand (see help data).
)X SYNTAX -
         abe    <dsname>  outda('dsname2') hardcopy infi()
                          nonum locase hicase sysout() name()
                          translat noprefix hex nofree
                          line() count() pri() secy() pdf pdfc
                          pdfe inp() support profile noprompt
                          clist recsize() outfi() dbd nodbd noshow

  required - <dsname>
  defaults - none
  alias    - sse, load
)O OPERANDS -
  The operands of the abe subcommand are identical to the same
  operands on the abe command.  See help data for the
  abe command.

=AC                                                                    @
)F FUNCTION -
  AC will shift data in each column so that a particular character
  string, if it exists in a given line, will appear in a specified
  position.
)X SYNTAX -
         <lsu> ac <str> <pos> <lm> <rm>
       or
         <lsu> ac <str> <pos> <rm>
  required - <str> <pos>
)O OPERANDS -
 <str> is the string to be scanned for in each line of the range.
       if the string is found in a given line, that line will be
       shifted either right or left so that the string will appear
       in the column specified as the second operand of the
       ac subcommand.
 <col> is the position to which data is to be aligned within
 <lm> is the left-most position in each column to be involved in the
      shift (see example below)
 <rm> is the right-most position in each column to be involved in the
      shift.  For example the subcommand "ac * 3 9" applied
      to the following data -

          *111111111
          2*22222222
          33*3333333
          444*444444
          5555*55555
          66666*6666
          777777*777
          8888888*88
          99999999*9

      would produce the following result

            *1111111
           2*2222222
          33*3333333
          44*44444 4
          55*5555  5
          66*666   6
          77*77    7
          88*8     8
          99*      9

=AID=$                                                                 @
)F FUNCTION -
  AID can be used to generate any subcommand when you don't
  remember the syntax.  The subcommand will prompt you for all
  The operands and options, will generate and display the
  subcommand, and will give you the option at the terminal
  of executing it.
 +Note:  The subcommand "$" with no operands is designed to direct
  you to the correct subcommand when you don't know which one
  to use to perform a function.
 +In order to use AID, file SYSAID must be allocated to data set
  X75826.ABE.AID.TEXT.
 +The AID subcommand will print explanatory text at the terminal,
  and will then prompt you to enter an operand.  Each prompt
  is indicated by a colon printed at the terminal.
)X SYNTAX -
         aid <subcommand name>
  required - <subcommand name>
  defaults - none
  alias    - $
)O OPERANDS -
 <subcommand name> is the name of the subcommand for which you
     want aid.
=AL                                                                    @
)F FUNCTION -
  AL will shift data to the left margin.
)X SYNTAX -
         <lsu> al <lm> <rm>
  required - none
  defaults - l1=0, l2=99999, l3=1 rm=0
)O OPERANDS -
 <lm> is the left margin to which data is to be adjusted in each
      column processed.  The default is position 1.
 <rm> changes significantly the operation of the AL subcommand
      depending on whether its value is 0 (or omitted) or not. If
      <rm>=0 (or omitted), ALL data in each column will be shifted
      so that the first non-blank character will appear in position
      <lm>.  If <rm>^=0, ONLY data in positions <lm> through <rm>
      are involved in the shift operation.

=ALTCASE                                                               @
)F FUNCTION -
  The ALTCASE subcommand can ONLY be issued by hitting program
  function key 24.  It is used to temporarily reverse the hi/lo
  translate setting.  For example, suppose HI is currently in
  effect, meaning that all data keyed in on the screen will be
  translated to upper case, and you want to key in some lines that
  are to remain in lower case.  You would do this by keying in your
  lines of data on the screen, and hitting pfk 24 instead of the
  ENTER key.  The reversal is in effect only for lines keyed in just
  before hitting pfk 24.
)X SYNTAX -
  altcase
)O OPERANDS - none

=AR                                                                    @
)F FUNCTION -
  AR will shift data to the right margin.
)X SYNTAX -
         <lsu> ar <rm> <lm>
  required - none
  defaults - l1=0, l2=99999
)O OPERANDS -
 <rm> This parameter is optional, and specifies an arbitrary
      right margin to which columns are to be adjusted.  If
      this parameter is not specified, the right margin is
      considered to be the maximum column length.
 <lm> changes significantly the operation of the AR subcommand
      depending on whether its value is 0 (or omitted) or not. If
      <lm>=0 (or omitted), ALL data in each colunn will be shifted
      so that the last non-blank character will appear in position
      <rm>.  If <lm>^=0, ONLY data in positions <lm> through <rm>
      are involved in the shift operation.

=BASE                                                                  @
)F FUNCTION -
  BASE converts numbers from one base to another, e.g. 1011 in base
  2 becomes 11 in base 10.
)X SYNTAX -
  <lsu> base <frombase> <tobase>
  required - <frombase> <tobase>
  defaults - none.
)O OPERANDS -
 <frombase> - Base of existing numbers. Must be greater than 1 and
   less than 37.
 <tobase> - Base to be converted to.  Must be greater than 1 and
   less than 37.

=BLANK=BL                                                              @
)F FUNCTION -
  Blank inserts blank records into the data set.  Note that an
  alternative for inserting blanks on the display is to place the
  character "b" (or "a" or "i") in the sequence number field of
  any line on the display.  Any number to the left of the
  character "b" (or "a" or "i") indicates how many blank lines
  are to be inserted at that point.  No number to the left of the
  "b" (or "a" or "i") indicates 1 blank line is to be inserted.
)X SYNTAX -
         <lsu> blank  <count>
  See note under OPERANDS for this subcommand regarding sequence 0.
  required - none
  defaults - none
  alias    - bl
)O OPERANDS -
 <count>
   The number of blank lines to be inserted. The inserted blank
   records are sequenced incrementing by 1 from the previous record.
   If the sequence number of a record to be inserted exceeds the
   sequence number of the record following it, ABE will resequence,
   beginning with the following record, incrementing by 1, for as
   many records as necessary.
 NOTE:  In the special case where the starting line number in the
   <lsu> is 0, the BLANK subcommand performs special processing
   in that blank lines will be inserted starting in front of the
   dataset, e.g. "0 bl 1" would insert a blank line as the first
   line in the dataset, and "t bl 1" would insert a blank line
   following the top line in the dataset.

=BNDS=BOUNDS                                                           @
)F FUNCTION -
  BNDS can be used to set bounds for those subcommands which honor
  them (see the SLB and SRB subcommands).
 +Note that the current boundaries are shown on the display, if
  within range, by the characters L and R.
)X SYNTAX -
  bnds left
       right
       list
       <l>
       <l> <r>
  required - none
  defaults - list
  alias    - bounds
)O OPERANDS -
 <l> - is a number indicating the position of the left boundary.
 <r> - is a number indicating the position of the right boundary.
))LEFT - If this keyword is specified, the new left boundary is
  indicated by the cursor position when the BNDS subcommand is
  entered.
))RIGHT - If this keyword is specified, the new right boundary is
  indicated by the cursor position when the BNDS subcommand is
  entered.
))LIST - Asks for the current bounds to be listed in the message
  area of the display.

=BOTTOM=BOT=BF=BB                                                      @
)F FUNCTION -
  The bottom subcommand repositions the display to the
  last line of the data set being edited.
)X SYNTAX -
           bottom
  required - none
  defaults - none
  alias    - b
)O OPERANDS -
  none

=BRIGHT                                                                @
)F FUNCTION -
  The BRIGHT subcommand can be used to change the light intensity of
  a display field.
)X SYNTAX -
  'bright' ('lo' × 'hi' × 'su') +
    ('all' × 'cmd' × 'data' × 'headings')
  required - none
  defaults - 'hi'.  If none of the keywords ALL, DATA, or HEADINGS
    are specified, the field for which intensity is to be changed
    is identified by the cursor location when the subcommand is
    entered.
)O OPERANDS -
))LO - Specified field(s) to be set to low intensity.
))HI - Specified field(s) to be set to high intensity.
))SU - Specified field(s) is to be suppressed (not printed).
))ALL - All fields on the display are to be set to the specified
   intensity.
))ALL - Only the command line is set to the specified intensity.
))DATA - Only unprotected (input) fields are to be set to the
   specified intensity.
))HEADINGS - Only protected fields are to be set to the specified
   intensity.

=CALC                                                                  @
)F FUNCTION -
 CALC provides a desk calculator function under ABE.  It accepts
 statements which consist of arithmetic expressions, assignment
 operators, and function references, and prints results at the
 terminal.  See Appendix I of the ABE reference manual for a
 detailed description of the CALC subcommand.
+NOTE there is also a subcommand named ZCALC.  Syntax for ZCALC
 is identical to CALC.  The difference is that CALC expands all
 integer results to 5 digits by left zero filling, and ZCALC
 suppresses left zeros on results.
)X SYNTAX
 CALC <expression>

 Example: calc 23*sin(3.14159/4)
)O OPERANDS
 <expression> is optional.  If specified, CALC will evaluate the
   expression, print the results, and return to ready.  If not
   specified, CALC will prompt you for expressions to be evaluated
   with the phrase 'CALC:', and will continue to do so until you
   enter the word 'end'.

=CHANGE=C                                                              @
)F FUNCTION -
  CHANGE is use to change one character string to another.
)X SYNTAX -
  <lsu> change <ver> <rep> chars  nall()  nosh bnds rescan opicture
                           prefix
                           suffix
                           word
                           picture
                           hex
                           text
                           any

  required - <ver> <rep>
  defaults - chars
 +Note:  If the C subcommand is entered without any operands,
  this will have the effect of re-issuing the last C subcommand
  entered prior to the current one.
)O OPERANDS -
 <ver> This is the string to be scanned for.  Surrounding
   apostrophes are required only if the string contains commas
   or blanks.
 <rep> The string will replace <ver> in the data.
))ANY - Indicates that <string-1> is a set of characters, any
  one of which will cause the change to be successful.
  for example, 'c @#$ a nall any' will cause 'you dirty @(_@#$'
  to be changed to 'you dirty a(_@#$'.  Also 'c @#$ a any'
  will cause 'you dirty @(_@#$' to be changed to 'you dirty a(-aaa'.
))BNDS - (this keyword has an alias of BOUNDS) Specifying this
  keyword has exactly the same effect as entering the same CHANGE
  subcommand with <col>=<lb> and <len>=<lb>+<rb>-1, where
  <lb> and <rb> are the boundaries set via the BNDS subcommand,
  and <col> and <len> are specified in the LSU.
))CHARS - See word keyword.
))HEX - implies the CHARS keyword, and indicates that <ver> and
  <rep> are specified as hexadecimal characters
  (e.g. c f1f2f3 c1c2c3 hex indicates that the character string
  '123' is to be changed to 'abc').
))NALL() - Used to specify that only the one occurrence is be
  changed.  If either NALL or NALL(1) is specified, only the first
  occurrence encountered will be changed.  If NALL(2) is specified,
  only the second occurrence will be changed, etc.
))NOSHIFT - Specify this keyword when <ver> and <rep>
  are of different lengths and you want a more sophisticated
  data shifting algorithm to be used rather than the default.
  Given the data line -

       IF XYZ  > '23'        /* COMMENT */

  the subcommand "c xyz xyz123" would result in -

       IF XYZ123  > '23'        /* COMMENT */

  but the subcommand "c xyz xyz123 noshift" would result in -

       IF XYZ123 > '23'      /* COMMENT */

  Given the original data line, the subcommand "c xyz x"
  would result in -

       IF X  > '23'        /* COMMENT */

  but the subcommand "c xyz x noshift" would result in -

       IF X    > '23'        /* COMMENT */

  As you can see above, the NOSHIFT keyword causes the minimal
  shifting of data.  The other major difference is that the NOSHIFT
  keyword prevents the truncation of data at the end of the column if
  <rep> is larger than <ver> and the replacement would
  cause the length of the nonblank data in the resulting column to
  be larger than the column length.  If this case occurs, the
  CHANGE subcommand will terminate with the error message 'CHANGE
  WOULD CAUSE TRUNCATION TO OCCUR'.
))OPICTURE
  Implies <rep> is a picture string with the following rules:
    . <ver> and <rep> must be the same length.
    . only '<', '=', and '>' are allowed in <rep>.
      '=' - 'from' character to be unchanged.
      '>' - if 'from' is lower case, change to upper.
      '<' - if 'from' is upper, change to lower.
  OPICTURE implies PICTURE.
))PICTURE - implies the CHARS keyword, and indicates that <ver>
  is a picture clause consisting of the following characters:
       = - any character (don't care)
       ^ - any non-blank character
       . - any non-displayable character
       # - any numeric character (0-9)
       _ - any non-numeric character
       @ - any alphabetic character (upper or lower case)
       < - any lowercase alphabetic character
       > - any uppercase alphabetic character
       $ - any special character (not alpha or numeric)
))PREFIX - See word keyword.
))RESCAN - If this keyword is specified, after a given
  occurrence of <ver> is replaced by <rep>, then the rescan begins
  with the first character of <rep> as long as the length of the
  column data changes by at least 1.  If the length doesn't change,
  the rescan begins with the second character of <rep>. If RESCAN is
  not specified, the rescan begins with the first character after
  <rep>.
))STC() - indicates that the <ver> must begin in this
  specific column.  Note that if the first operand after <rep>
  (or string-1 in the case of the FIND subcommand) is simply a
  number, it is assumed to be a value for the STC keyword.  For
  example, "f abc 1" is the same as "f abc stc(1)".
))SUFFIX - See work keyword.
))TEXT - may be used with any of the keyword CHARS, PREFIX, SUFFIX,
  or WORD.  It indicates the search for string-1 is to be done
  without regard to upper/lower case alphabetics.  For example,
  'c done xyz text' would successfully change all of the
  following:  Done, DONE, done.
))WORD - The keywords chars, prefix, suffix, and word are
  mutually exclusive, and can be used to control the conditions
  for a successful "match" with string-1 based on whether
  the data string begins and/or ends with a non-alphameric
  character.  In the following illustration, the underscored
  strings would be found, and the non-underscored strings would
  be ignored:

                  do dont ado adopt
     chars 'do'   __ __    __  __
     prefix 'do      __
     suffix 'do'           __
     word 'do'    __

=CHAR                                                                  @
)F FUNCTION -
  The char subcommand is used to return to normal character display
  mode from hex display mode.  See also the help data for the
  hex subcommand.
)X SYNTAX -
         char
  required - none
  defaults - none
  alias    - none
)O OPERANDS - NONE

=CL                                                                    @
)F FUNCTION -
  The cl subcommand is used to obtain a list of cataloged dataset
  names.  CAUTION:  The list will be stored in the currently edited
  dataset with symbolic name @CL.  If no such dataset is being
  edited, a virtual dataset will be defined.  If such a dataset
  is already being edited, all lines in it will be deleted by the
  CL subcommand before it stores the new list of cataloged dataset
  names.
)X SYNTAX -
    cll <level> <qual>
  required - none
  defaults - level defaults to TSO userid prefix (&SYSPREF).
  alias    - none
)O OPERANDS -
  <level> - Only cataloged datasets with dsnames beginning
    with <level> will be listed, e.g. "cl u.tc" lists only names
    beginning with "u.tc".  The default is your TSO user prefix,
    &SYSPREF.  If the first character of <level> is "." then
    &SYSPREF is prefixed before the list is produced, e.g.
    "cl .install" would produce a list of all cataloged datasets
    with names beginning with X75826.INSTALL, assuming &SYSPREF
    were set to X75826.
  <qual> - Only cataloged datasets with dsname ending with
    <qual> will be listed, e.g. "cl '' .text" lists only names under
    your TSO userid ending with ".text".

=CLEAR                                                                 @
)F FUNCTION -
  Clear resets all or part of a range of records to blanks.  Note
  that an alternative for clearing records on the display is to
  place the single character "c" anywhere in the sequence number
  field.  This will clear that particular line.  A range of lines
  on the display can be cleared by placing the characters "cc"
  anywhere in the sequence number field of the first record to be
  cleared, and the last record to be cleared.
)X SYNTAX -
         <lsu> clear <offset>
  required - none
  defaults - <offset>=1
  alias    - none
)O OPERANDS -
  <offset> - Offset at which clearing is begun.  A specification
     of 10, for example, indicates that everything from position 10
     to the right in each column processed is to be set to blanks.
     The default for <offset> is 1.

=CLEARSC                                                               @
)F FUNCTION -
  Clearsc clears the screen so that text from the next $write will be
  written at the top of the screen.
)X SYNTAX -
  clearsc <pause>
  required - none
)O OPERANDS -
  <pause> is not required.  If omitted, the screen is cleared without
     pause.  If "clearsc 1" is specified, the message "Press ENTER to
     continue" is displayed, and the screen is not cleared until the
     ENTER key is pressed.  If "Clearsc 'Hi there!'" is specified,
     the message "Hi there!" is displayed, and the screen is not
     cleared until the ENTER key is pressed.

     If the ENTER key must be pressed to continue, whatever the
     terminal user enters will be assigned as the replacement value
     for symbolic variable &ANSWER.

=CLIST                                                                 @
)F FUNCTION -
  CLIST lets you invoke TSO clists containing ABE subcommands.
  The specified clist must be a member of the library pointed to
  by the file name SYSPROC.
 +Note that the symbolic substitution done in the clist is the
  normal substitution done in any TSO clist.  That is, the system
  globals available under RUN will not be available in the clist
  (e.g. &SYSACCT is not a system global in TSO clists, but it is in
  RUN lists).  However, symbolic variables set after a $FULLSCR or
  $DISPLAY WILL STILL BE AVAILABLE (e.g. &PFK will still refer to
  the program function key used, and &F00001 will still refer to the
  contents entered in the first input field, etc.).
)X SYNTAX -
         clist <name> <operands>
      or
         %<name> <operands>

      NOTE: no blank should appear between the % and <name>
            (e.g. %mylist xyz)
  required - <name>
  defaults - none
  alias    - none
)O OPERANDS -
  <name> - this is the clist name.  It must be the name of a
     member in the partitioned data set allocated under the
     file name (ddname) of SYSPROC.
  <operands> - any operands required in the clist.  Note that
     standard TSO syntax should be used for invoking a clist.

=CLL                                                                   @
)F FUNCTION -
  The CLL subcommand is almost identical in syntax and function to
  the CL subcommand.  The only difference is that the list of dataset
  names will be in the form of executable ABE subcommands.
)X SYNTAX -
    cll <level> <qual>
  required - none
  defaults - level defaults to TSO userid prefix (&SYSPREF).
  alias    - none
)O OPERANDS -
  <level> - Only cataloged datasets with dsnames beginning
    with <level> will be listed, e.g. "cl u.tc" lists only names
    beginning with "u.tc".  The default is your TSO user prefix,
    &SYSPREF.
  <qual> - Only cataloged datasets with dsname ending with
    <qual> will be listed, e.g. "cl '' .text" lists only names under
    your TSO userid ending with ".text".

=COLADJ                                                                @
)F FUNCTION -
  Use the coladj subcommand to reformat a matrix of data into
  regular columns.
)X SYNTAX -
           <lsu> coladj (left × right × decimal × uniform)
  required - none
  defaults - left
)O OPERANDS -
  NOTE:  The descriptions for all the keywords availabe on COLADJ
  refer to the following SAMPLE data set:

                   10        20        30        40
          12345678901234567890123456789012345678901234
                                             ×SAMPLE××
     0001 1 .5 5.7 50 3.0 27.3
     0002 2 .7 5.7 273 51.3 27.3
     0003 3 .6 9.5 50 9.1 27.5
     0004 4 .6 9.5 263 90.9 27.4
     0005 5 6.5 9.5 263 121.8 28.3
     0006 6 6.3 9.5 50 43.4 28.0
     0007 7 6.8 5.7 263 56.7 27.4
     0008 8 6.2 5.7 45 29.2 27.2
     0009 9 2.9 7.5 146 26.8 27

))DECIMAL
  Formats the data matrix so that data in each column is adjusted so
  that decimal points are aligned, e.g. "a sample coladj decimal"
  produces:

                   10        20        30        40
          12345678901234567890123456789012345678901234
                                             ×SAMPLE××
     0001 1   .5 5.7  50   3.0 27.3
     0002 2   .7 5.7 273  51.3 27.3
     0003 3   .6 9.5  50   9.1 27.5
     0004 4   .6 9.5 263  90.9 27.4
     0005 5  6.5 9.5 263 121.8 28.3
     0006 6  6.3 9.5  50  43.4 28.0
     0007 7  6.8 5.7 263  56.7 27.4
     0008 8  6.2 5.7  45  29.2 27.2
     0009 9  2.9 7.5 146  26.8 27

))LEFT
  Formats the data matrix so that data in each column is adjusted to
  the left margin of that column, e.g. "a sample coladj left"
  produces:

                   10        20        30        40
          12345678901234567890123456789012345678901234
                                             ×SAMPLE××
     0001 1 .5  5.7 50  3.0   27.3
     0002 2 .7  5.7 273 51.3  27.3
     0003 3 .6  9.5 50  9.1   27.5
     0004 4 .6  9.5 263 90.9  27.4
     0005 5 6.5 9.5 263 121.8 28.3
     0006 6 6.3 9.5 50  43.4  28.0
     0007 7 6.8 5.7 263 56.7  27.4
     0008 8 6.2 5.7 45  29.2  27.2
     0009 9 2.9 7.5 146 26.8  27

))RIGHT
  Formats the data matrix so that data in each column is adjusted to
  the right margin of that column, e.g. "a sample coladj right"
  produces:

                   10        20        30        40
          12345678901234567890123456789012345678901234
                                             ×SAMPLE××
     0001 1  .5 5.7  50   3.0 27.3
     0002 2  .7 5.7 273  51.3 27.3
     0003 3  .6 9.5  50   9.1 27.5
     0004 4  .6 9.5 263  90.9 27.4
     0005 5 6.5 9.5 263 121.8 28.3
     0006 6 6.3 9.5  50  43.4 28.0
     0007 7 6.8 5.7 263  56.7 27.4
     0008 8 6.2 5.7  45  29.2 27.2
     0009 9 2.9 7.5 146  26.8   27

))UNIFORM
  Formats the data matrix so that data in each column is adjusted to
  the right margin in that column, and all columns are the same
  width, e.g. "a sample coladj uniform" produces:

                   10        20        30        40
          12345678901234567890123456789012345678901234
                                             ×SAMPLE××
     0001 1      .5     5.7    50     3.0    27.3
     0002 2      .7     5.7    273    51.3   27.3
     0003 3      .6     9.5    50     9.1    27.5
     0004 4      .6     9.5    263    90.9   27.4
     0005 5      6.5    9.5    263    121.8  28.3
     0006 6      6.3    9.5    50     43.4   28.0
     0007 7      6.8    5.7    263    56.7   27.4
     0008 8      6.2    5.7    45     29.2   27.2
     0009 9      2.9    7.5    146    26.8   27

=COLUMN=COL                                                            @
)F FUNCTION -
  Use the column subcommand to indicate the first position of each
  card image to be displayed.
)X SYNTAX -
           column <number> <trunc>
        OR
           COL L
        OR
           COL R
        OR
           COL (<list>)
  required - none
  defaults - <trunc> = <number>+72
  alias - col
)O OPERANDS -
  If the subcommand is specified as "col r", then the display will
  be shifted right so that the first position to the right of the
  current display will be in position 1 of the new display.
  If the subcommand is specified as "col l", then the display will
  be shifted left so that the last position on the right edge of
  the new display will be the position just to the left of the
  leftmost position on the current display.
 +Note that you can think of the subcommands "COL R" and "COL L"
  as being equivalent to the PF and PB subcommands, except the
  "paging" will be done horizontally instead of vertically.
 <number> - Indicates the position at which the display is to start.
 <trunc> - This number is optional.  If specified, it indicates
  The last position of the data set to be displayed.  If not
  specified, a value consistent with the screen size, or the
  last position in the data set, whichever is smaller, will be
  assumed.
 <list> is a group of one or more position range specifications,
  all enclosed in parenthesis. "col (1:10 20:29 30:39)" for example,
  indicates that only positions 1 thru 10, 20 thru 29, and 30 thru
  39 are to be displayed

=CONTENT                                                               @
)F FUNCTION -
  Use the content subcommand to obtain a list of the data sets
  currently being edited.  The screen will be temporarily cleared
  to display the list.
)X SYNTAX -
   content <name>
  required - none
  defaults - none
  alias - none
)O OPERANDS -
 <name> - Is optional.  If not supplied, the screen will be
  temporarily cleared to display the list.  If <name> is supplied
  it is the name associated with the currently edited dataset into
  which the list is to be stored.  If the name isn't associated with
  any datasets currently being edited, a virtual dataset will be
  created to contain the list.

=CONVERT                                                               @
)F FUNCTION -
  CONVERT can be used to convert from one data format to another,
  e.g., packed decimal to character.
)X SYNTAX -
  <lsu> convert <from-spec> <to-spec> left  name()
                                      right

  example: convert char(1 3) packed(5 4)

)O OPERANDS -
 <from-spec> - specifies the format and location of the data as
   it now exists in each record.  The format of the <from-spec>
   operand is identical to the format of the <to-spec> operand
   described below.
 <to-spec> - specifies the format and location of the data as it
   is to exist after conversion.  Note that the locations of
   the <from-spec> and <to-spec> operands can overlap in any
   fashion you choose.  The format of the <from-spec> and <to-spec>
   operands is identical, and will now be described.  These
   operands always consist of one of the keywords BEST, CHAR, HEX,
   FIXED, PACKED, FLOAT, and BIT, indicating the type of data.
   These data types, with the exception of HEX, are all equivalent
   to the same data types in the PL/I language, and in fact, the
   rules PL/I uses in data conversion will be followed in the
   CONVERT subcommand.

   NOTE:  When converting floating point to char, allow plenty of
   room in the to-spec because the value will be printed in
   scientific notation with lots of redundant zeros.

   The HEX data type is the printable representation of the internal
   hexadecimal format of any of the 256 possible EBCDIC characters.
   For example, the characters 'ABC' would be converted to C1C2C3.

   Following the keyword (CHAR, HEX, etc.), a parenthesized list of
   up to three numbers SEPARATED BY BLANKS may be specified,
   <offset>, <length>, and <scale>.

     <offset> is the offset, relative 1, in each column to the to-
              or from- data.
     <length> is the length of the data.
     <scale>  is a scaling factor to be applied to the data during
              the conversion process.  If not specified, <scale>
              is assumed to be zero.  After the data has been
              converted from the <from-spec> format to the <to-spec>
              format, the <scale> of the <to-spec> is subtracted
              from the <scale> of the <from-spec>, and the result
              is multiplied by 10.  Call the result of this
              arithmetic RESULT.  If RESULT is positive, the
              converted data is divided by result before being
              assigned to the <to-spec> location.  If RESULT is
              negative, the converted data is multiplied by the
              absolute value of RESULT before being assigned to
              the <to-spec> location.

   The parenthesized list of numbers may be entirely omitted for
   the <to-spec> in which case, the <offset>, and <length> parameters
   from the <from-spec> will also be used for the <to-spec>.

   Following are some other restrictions applying to the <offset>,
   <length>, and <scale> parameters:

     1.  A <scale> value is not allowed for the keywords CHAR, HEX,
         FLOAT, or BIT.
     2.  The maximum <length> for BIT is 4095.
     3.  The only acceptable <length> values for FLOAT are 4, 8,
         and 16.
     4.  The maximum <length> for PACKED is 8.
     5.  The only acceptable <length> values for FIXED are 2, and 4.
     6.  The maximum <length> for CHAR and HEX is 32767.

   There are also some rules for padding, if the <length> of the
   <to-spec> is longer than the <length> of the <from-spec>.  The
   padding character for CHAR is a blank, and for HEX is a zero (0).
   All other data types get a hexadecimal 00 for a padding
   character.

   Given that the LEFT or RIGHT keywords haven't been specified to
   indicate which side padding is to occur, CHAR, FLOAT, and BIT
   data types will be left-justified in the output location, and
   padding will occur on the right.  in all other cases, the
   default is to right-justify and pad on the left.

   Truncation will not occur.  If the data will not fit in the
   output location, the output location is filled with asterisks
   (*****).

   If data cannot be converted from one format to another (conversion
   condition in PL/I), the output field will also be filled with
   asterisks.

   Note that data will always be justified.  For example, if the
   subcommand is "convert all char(1 4) char(5 4)", and the data
   in columns 1-4 is " abc", when the subcommand is finished,
   columns 5-8 will contain "abc ".

))LEFT - indicates that data in the output field is to be left-
   justified, and padding is to occur on the right.
))RIGHT - indicates that data in the output field is to be
   right-justified, and padding is to occur on the left.

=COPY=CO                                                               @
)F FUNCTION -
  This subcommand has the same function as the move subcommand,
  except that the original lines are not deleted, and an additional
  operand can optionally be specified.  The additional operand
  specifies the number of copies to be made.  Note that you can
  copy a particular line on the display immediately following
  itself by entering the character "r" in the sequence field of
  that line.  If a number does not appear to the left of the "r",
  then one copy will be made of the line.  A number to the left
  of the "r" indicates how many copies should be made.  A group of
  lines can be copied by entering "rr" in the sequence fields of
  the first and last lines to be copied.  The copied lines will be
  inserted following the last line to be copied. A number to the
  left of the second "rr" (the one in the sequence field of the last
  line to be copied) indicates the number of copies to be made. For
  syntax rules and information about operands of the copy
  subcommand, enter help for the move subcommand.
)X SYNTAX - SEE MOVE SUBCOMMAND.
    <lsu> 'copy' '('(<name>) (':') (<lsu>)')' (<copies>)
      ('ol' × 'from' × 'to')
)O OPERANDS - See move subcommand, which has identical syntax.

=CURSOR                                                                @
)F FUNCTION -  The cursor command is used to set the position to
  which the cursor is to be moved after each time you hit enter.
  There are two cursor modes, "homebase" and "float", and
  each time you enter the cursor subcommand, the
  mode is switched from one to the other.  When you initially
  enter abe , the mode is "homebase".  In "homebase" mode the
  cursor always returns to the same spot on the display.  The
  first time you enter the cursor subcommand, the mode will be
  switched to "float" mode.  In "float" mode, the cursor is left
  in the spot you leave it in each time you hit enter, except that
  if the cursor is found in any command line on the display, it
  will be shifted to the beginning of that command line.  If you
  are currently in "float" mode, and enter the cursor subcommand
  to return to "homebase" mode, the position of the cursor when
  the cursor command is entered determines "home base"; that is,
  the spot to which the cursor is to be returned each time you
  hit enter.
)X SYNTAX - CURSOR
)O OPERANDS - none

=DATAENT                                                               @
)F FUNCTION -
  DATAENT is a shorthand way of setting up data entry.  When you
  are going to do data entry with ABE, many times you will define
  a data entry panel (using the PDF keyword of ABE).  To get this
  data entry panel displayed, and the data entered on that panel
  stored, before DATAENT was implemented you usually created an
  RUN of the following form -

    $ LOOP
    $FULLSCR PANEL
    $STORE PANEL
    $IF &PFK = 00000 LOOP

  where "panel" is the name of your data entry panel.  The above
  RUN list will loop, first displaying the data entry panel,
  and then storing any data entered on that panel in new records
  added to the current data set, until the user hits any
  program function key instead of the ENTER key.  The DATAENT
  subcommand implements the above RUN loop without you having to
  define an RUN list.

)X SYNTAX - DATAENT <panel> <other-$store-operands>

)O OPERANDS -
 <panel> - is the name of the data entry panel to be used.  The
   DATAENT subcommand will repeatedly issue a $FULLSCR subcommand,
   followed by a $STORE subcommand until the user hits a program
   function key instead of the ENTER key.
 <other-$store-operands> - are any keyword operands to be
   specified on the $STORE subcommand issued by DATAENT.
   For example, "dataent mypnl dup(2)".

=DB2                                                                   @
)F FUNCTION -
  DB2 can be used to issue DB2 statements, e.g. CREATE, DROP,
  INSERT, etc.  Note that you must have invoked ABE in the
  following manner to use this subcommand:

     PROMPT  RESPONSE
     ______  ______________________

     READY
             DSN
     DSN
             RUN CP PLAN(ABE)
     ENTER TSO COMMAND
             ABE etc.

)X SYNTAX - db2 <statement>

)O OPERANDS -
 <statement> - Most DB2 SQL statements, such as CREATE, DROP, etc.
   There is also a special DB2 statement called CONTENT which can
   be used.  The format is -

     db2 content <table-name>

   where <table-name> is the name of any table stored under DB2.
   The result will be that the current data set will contain a
   description of all the fields in the specified table; sort of
   like PROC CONTENTS under SAS (trademark).
   NOTE:  If <statement> is a DB2 SELECT statement, then all the
   records in the current data set will be deleted, the results
   of the SELECT will be stored in the current data set, and the
   view will be changed to reflect the result.

=DCODE                                                                 @
)F FUNCTION -
 Can be used to decrypt data encrypted via the NCODE subcommand.
)X SYNTAX -
 <lsu> dcode <key>

  example: dcode teesha

)O OPERANDS -
 <key> - must be the same key specified on the NCODE subcommand when
  the data was encrypted.  The length of <key> may not exceed 8.
 +note that <len> specified in the LSU must be evenly divisible by
  8.

=DEFINE=DEF                                                            @
)F FUNCTION -
This command can be used to create a new virtual data set, which
exists only in virtual storage.
)X SYNTAX - DEFINE <NAME> ...
)O OPERANDS -
 <name> is the name, 8 characters or less, to be associated with
   the new virtual data set (note this is not a dsname).  This
   short-hand name will appear on the command line between two
   vertical broken bars.

   If you intend for this data set to be a subcommand list to be
   associated with a program function key, then the name should
   be in the form "pfknn", where nn is a number from 1 to 99.

   Other operands on the define command may be any of those
   keywords specified on the ABE subcommand.

=DELAY
)F FUNCTION -
  The DELAY subcommand halts processing for the specified number of
  milliseconds.
)X SYNTAX -
  delay <time>
)O OPERANDS -
  <time> - is the number of milliseconds to delay.

=DELDUP                                                                @
)F FUNCTION -
  DELDUP removes lines from the dataset if they contain the same
  information as the previous line in the dataset.  The default
  action is to use the entire line for the comparisons, however
  this can be modified by specifing the column(s) to be compared.
)X SYNTAX -
         <lsu> deldup  <pos1>:pos2  <pos3>:pos4  ...
  required - none
  defaults - pos1 = 1   pos2 = record length of dataset
  note     - zero to thirteen position pairs may be given
)O OPERANDS -
  pos1 - Beginning position in 1st set of positions to be compared.
         If not specified, it is equal to pos2.
  pos2 - Ending position in 1st set of positions to be compared, or
         if specified in the form "+nnn", the number of positions
         to be compared.
  pos3 - Beginning position in 2nd set of positions, etc.
  pos4 - Ending position in 2nd set of positions, etc.

=DELETE=DEL                                                            @
)F FUNCTION -
  Delete removes records from the data set.  Note that an
  alternative for deleting records on the display is to place the
  single character "d" anywhere in the sequence number field.
  This will delete that particular line.  A range of
  lines on the display can be deleted by placing the characters
  "dd" anywhere in the sequence number field of the first record
  to be deleted, and the last record to be deleted.
)X SYNTAX -
         <lsu> delete <str> not
  required - none
  defaults - none
  alias    - del
)O OPERANDS -
  <str> - This operand, in conjunction with the NOT
    keyword, can be used to provide additional control over lines to
    be deleted in the specified range.  If the keyword NOT is
    omitted, only those lines in the range that contain the
    specified character string will be deleted.  If keyword NOT is
    specified, only those lines not containing the specified
    character string will be deleted.
  +Note that the LSU parameters <off> and <len> can be used to
    limit the scan for <str> to specified columns.

=DOTAB                                                                 @
)F FUNCTION -
 DOTAB allows you to do tabbing on existing data lines,  e.g.
 "dotab @ 2 4 6" applied to a data lines containing "@a@b@c"
 would produce " a b c".
)X SYNTAX -
         <lsu> dotab <tab_char> <tab_array>
  required - none
  defaults - <tab_char> defaults to value specified via the TABK
             subcommand.  <tab_array> defaults to values specified
             via the TAB subcommand.
  alias    - none
)O OPERANDS -
 <tab_char> - specifies the tab character to be scanned for, e.g.
   "dotab @ 5 10 15" applied to the data "@a@b@c" would result in
   "    a    b    c".  <tab_char> may also be specified as a
   hexadecimal constant, e.g. "dotab x'05'".  If <tab_char> is
   not specified, the default is the value specified via the TABK
   subcommand.
 <tab_array> - specifies one or more tabbing positions to override
   corresponding values specified via the TAB subcommand, e.g.
   "/tab 5 10 15/dotab @ '' 12" applied to "@a@b@c" would result in
   "    a      b  c". Up to sixteen values may be specified in
   <tab_array>.

=DOWN                                                                  @
)F FUNCTION -
  Use the down subcommand to move the display down 1 or more lines.
)X SYNTAX -
           down <number>
  required - none
  default - 1
  alias - d
)O OPERANDS -
 <number> - the number of lines to move the display.

=DRAW                                                                  @
)F FUNCTION -
  Use the DRAW subcommand to draw a line on the graphics drawing.
  see Appendix N, subtitle SOME ADDITIONAL GRAPHICS SUBCOMMANDS.
)X SYNTAX -
    draw <x> <y> <z> ('inches' × 'pixels')
  required - none
  default - 1
)O OPERANDS - See Appendix N.

=DREM                                                                  @
)F FUNCTION -
  Drem can be used to copy a range of lines from the data set
  owning this command line to another data set currently being
  edited.  Drem can be thought of as the companion to merd,
  which can be used to copy a range of lines from another data
  set being edited to the data set owning this command line.
)X SYNTAX -
         drem   <name> <l1> <l2> <to>

  NOTE: the DREM subcommand is converted to a COPY subcommand
  of the format "<l1> <l2> copy (<name> <to>)".  THE DREM COMMAND
  IGNORES ANY LSU YOU MIGHT SPECIFY.

)O OPERANDS -
  <name> refers to the symbolic name (assigned through one
    of the subcommands abe, name, or define) associated with a data
    set currently being edited.  The selected lines will be copied
    to this virtual data set.  If there is no data set with the
    specified symbolic name, one will be created, and the specified
    lines will be copied to it.
  <l1> specifies the first or only line to be copied.
  <l2> is optional, and specifies the last line to be copied.
  <to> is the line number in the named data set behind which
    the selected lines are to be copied.

=DSCB                                                                  @
)F FUNCTION -
  Use the DSCB subcommand to obtain DSCB information from the VTOC.
)X SYNTAX -
  dscb <dsname> <volser> <symname> <cchhr name>
  required: <dsname> <volser>
  defaults <symname>=DSCB, <keyword>=''

)O OPERANDS -
  <dsname> is either the name of the dataset for which you want the
    format 1 dscb, or if <dsname> is 4, then the format 4 DSCB for the
    VTOC is obtained. If <dsname> is 3, then <cchhr name> must be the
    name of a macro variable whose replacement value is the cchhr
    address of the dscb to be obtained.
  <volser> is the volume from which the DSCB is to be obtained.
  <symname> is the macro variable name whose replacement value is to
    be set to the contents of the specified DSCB.  The default name
    is DSCB.
  <cchhr name> see above under <dsname>.

=DUMP                                                                  @
)F FUNCTION -
  Used to dump memory, or to convert hexadecimal constants to decimal,
  and vice versa.
  WARNING:  When the DUMP command is used to dump memory, all lines
  in the current data set will be replaced with the memory dump.
)X SYNTAX -
  'dump' <address> (<len>)

  'dump' <constant> ('hex' or 'dec' or 'cha') +
    ('find' (<address> (<len>))

  'dump'

  required - none
  defaults - none
)O OPERANDS -
  If just the word 'dump' is entered without any operands, it indicates
  that a PL/I dump is to be written to the PLIDUMP data set.
 <address> - is similar to the address format used in the TSO TEST
  command, and is identical to that used in the PEEK subcommand (see
  help text for PEEK).

  WARNING: If <address> is specified,
  all lines in the current data set will be deleted, and memory from
  the specified address for the specified <len> will be displayed
  in lines in the current data set.

 <constant> - is either a hexadecimal, decimal, or character
  constant, depending on which of the keywords HEX, DEC, or CHA
  respectively is specified. This constant is used in two
  different ways, depending on whether the keyword 'find' is
  specified.

  If keyword "find" is not specified, For a decimal constant, the
  hexadedimal equivalent will be displayed in the message area, and
  for a hexadecimal constant the decimal equivalent will be
  displayed. For a character constant, the hexadecimal EBCDIC
  representation will be displayed.

 <len> is optional, and tells how much memory is to be dumped.  The
  default is 1024 bytes.

))CHA - Tells the dump subcommand that <constant> is character.
))DEC - Tells the dump subcommand that <constant> is decimal.  Note
  that constant may be prefixed with a minus sign, e.g. -15643
  is a valid decimal constant.
))FIND - indicates that the specified <constant> is to be searched
  for in memory, and when it is found, memory is to be dumped
  beginning at that location for a length of 1024 bytes.
  if <address> and <len> are not specified, all memory from address
  0 to 16777215 will be searched.  Otherwise, only the memory at
  the specified <address> for the specified <len> will be
  searched.
))HEX - Tells the dump subcommand that <constant> is hexadecimal.

=ECHO                                                                  @
)F FUNCTION -
  This subcommand is most useful when executing ABE in batch, and
  when debugging an RUN subcommand list.  It causes each subcommand
  which is executed by ABE to be printed at the terminal under TSO,
  and on the SYSPRINT log in batch.
)X SYNTAX -
    echo on × off
  required - none
  defaults - on
)O OPERANDS -
))ON - turns on printing.
))OFF - turns off printing.

=END                                                                   @
)F FUNCTION -
  End requests that the abe  command be terminated and control
  returned to the invoking program level that accepts system
  commands, if this is the only data set on display.  If the abe
  subcommand has previously been issued to display additional
  data sets, and end subcommands have not been entered for all of
  them, the display lines owned by this data set will be
  inherited by the next higher data set on the display, or the
  next lower if this is the top data set, and editing for this
  data set alone will be ended.
 +Note that if the END subcommand is entered for the only data set
  being edited which has not been designated as a support data
  set, an "END NOSAVE" will be scheduled for all of the rest of
  the support data sets currently being edited.  See the SUPPORT
  subcommand for details on what a support data set is.
)X SYNTAX -
         end 'save' × 'nosave'
  required - none
  defaults - none
 'save' - Entering 'end save' is the equivalent of entering "se".
 'nosave' - If you have altered the data set currently being
    edited since you last entered the save subcommand, then
    abe  won't accept an end subcommand until you either enter
    the save or se subcommands, or enter the nosave operand on
    the end subcommand.
)O OPERANDS - NONE

=ENTER                                                                 @
)F FUNCTION -
  The ENTER subcommand makes it easier to do bulk data entry
  into a data set which has a view defined over it.  A detailed
  description of the use of this subcommand can be found in
  Appendix D, which documents RQL (Relational Query Language).
)X SYNTAX -
         enter
  required - none
  defaults - none
)O OPERANDS - NONE

=EXEC=EX                                                               @
)F FUNCTION -
  Exec is used to indicate that a range of lines are tso
  commands to be executed in xmode.  When the commands have
  been executed, you will be left in xmode, and any further
  commands you enter will be added to the end of the current
  data set.
 +Note that if a line ends with a plus (+) sign, the next line will
  be treated as a continuation.
 +Note that an alternative for executing tso commands on the
  display is to place the single character "e" anywhere in the
  sequence number field.  This will execute that particular line
  as a tso command.  A range of lines on the display can be
  executed by placing the characters "ee" anywhere in the
  sequence number field of the first record to be executed, and
  the last record to be executed.
 +Note that all TSO command processors specified directly will be
  executed before any TSO commands from clists, regardless of
  order in the range of lines.
)X SYNTAX -
         <lsu> exec <name>
  required - none
  defaults - none
)O OPERANDS -
 <name> - Optional.  Specifies the symbolic name associated with
      the data set containing the lines to be executed as TSO
      commands.

=FILL                                                                  @
)F FUNCTION -
  Can be used to pad each line on the display with blanks up to a
  specified column.
 +Note that the current fill amount is indicated on the display by
  the appearance of the character "F" in the line that also shows
  the current tab positions.
)X SYNTAX -
  fill <column>
)O OPERANDS -
  <column> - if a data line is shorter than this column, it will be
    padded with blanks on the display up through this column.

=FILLET                                                                @
)F FUNCTION -
  Draws a smooth curve based on the input points.  The FILLET
  subcommand provides an interactive interface to the GSPFLT
  subroutine of GDDM.  It can only be used from a terminal having
  graphics capabilities, and GDDM must be available (see Appendix
  N). Given as input datasets describing points in 2-space, the user
  at the terminal will be shown the resulting curve, and will be
  allowed to edit the set of points, adding, deleting, and moving
  individual points.
)X SYNTAX -
         FILLET <XARRAY> <YARRAY>
  A typical calling sequence might be "%%gddmshow sample" where
  sample is a dataset containing the following -
    apl xin#1 4`B20Y10 20 30 40 50 60
    apl yin#1 4`B20Y50 55 45 65 35 75
    fillet xin yin
  gddmshow is documented in Appendix N.

)O OPERANDS -
<xarray> - This must be a virtual dataset containing the x
  coordinate values for the series of points defining the curve. The
  dataset can be created with an apl subcommand similar to "apl
  xin#1 4`B20Y10 20 30 40 50 60". Refer to Appendix L for more
  information on the APL subcommand.  Notable constraints are that
  the variable must be in internal floating point, 4 bytes per
  element, and must be a vector of four or more items.
 +NOTE: In order to add points, empty elements must be supplied at
  the end of the <xarray>/<yarray> vectors.  Elements with a value
  of zero are considered to be empty, e.g. "xin#1 4`B20Y10 20 30 40"
  produces an array with 16 empty elements.  Once the fillet
  subcommand is finished, you can view the edited (x,y) pairs in
  EBCDIC by entering the following apl subcommand, which also will
  drop the empty elements at the end:

    apl 10 5F(tmp/xin),{1.5}(tmp#0<xin)/yin

<yarray> - This must be a virtual dataset containing the y
  coordinate values corresponding to the x values in <xarray>.
  The same constraints that apply to <xarray> also apply to
  <yarray>.

=FIND=F=FF=FB                                                          @
)F FUNCTION -
  FIND is used to locate lines containing particular character
  strings.
 +NOTE:  The value of symbolic variable &LASTCC will be set to
  0 if the find was successful, and will be set to 4 if not.
  See also help data for the SYMREP subcommand.
)X SYNTAX -
  <lsu> f <string-1> chars  not stc() all name() mark() bnds suppress
                     prefix                  mk()resetsetrc
                     suffix
                     word
                     mask()
                     oper()
                     picture
                     hex
                     text
                     any

 +Note:  If the F subcommand is entered without any operands,
  this will have the effect of re-issuing the last F subcommand
  entered prior to the current one.
)O OPERANDS -
  With the exception of the string-2 operand of CHANGE, the NOT and
  MASK keywords of FIND, and the ALL, SUPPRESS, and RESET keywords,
  the syntax of these two commands is identical. Except for the NOT,
  NAME and MASK keywords, enter help for the appropriate operand of
  the CHANGE subcommand to get information about the same operand of
  the FIND subcommand.
))ALL - If the SUPPRESS and RESET keywords are not specified, the
  ALL keyword indicates that a new virtual data set is to be
  created, and all lines that meet the selection criteria are to be
  copied (with the same line numbers) to the new data set.
  If SUPPRESS or RESET is specified, the ALL keyword indicates
  that all lines in the data set that meet the selection criteria
  are to be either SUPPRESSed or RESET (see also the SUPPRESS and
  RESET subcommands).
))MARK() - Use this keyword if you want to find the location of a
  particular character string, but don't want to have the display
  moved to that location.  Instead, the specified mark array element
  (see also the MARK subcommand) will be set to the line number of
  the line containing the specified string.  Note that the
  parenthesized mark array element number is optional, and if the
  keyword MARK is specified without subsequent parenthesis, by
  default mark array element 1 will be set.  Note that the line
  number will also be written in the message area of the display
  in addition to being written in the mark array element.
))MASK() - This keyword specifies that string-1 is a mask of
  characters to be looked for.  If the MASK keyword is specified
  without any following parenthesis, then a period ('.') appearing
  anywhere in the mask will compare equally with any character in
  the same position in the data set.  For example,
  "find abc...xy mask next" finds the next line containing the
  characters "abc" and "xy" with any three characters in between.
  If you don't want to use period (".") as the masking character,
  you can override with any other character,
  (e.g. "find abc###xy mask(#)").
))MK - See help for the MARK keyword above.
))NAME() - This keyword operand will be ignored unless 'ALL'
  is also specified.  It specifies a symbolic name to be associated
  with the virtual data set to contain copies of the lines
  containing the specified character string.
))NOT - This keyword causes a "match" condition to occur only
  if the record does not meet the criteria specified by the
  other keywords on the find command.
))OPER() - This keyword specifies a relational operator you want
  used in comparing <string-1> to what is in each column examined
  Valid specifications are =, ^=, >=, <=, >, and <.  Note that if
  the OPER keyword is specified, the CHARS, PREFIX, SUFFIX, WORD,
  and MASK keywords will be ignored.  An example of the use of this
  keyword is as follows:  Suppose you had a data set consisting of
  four lines, each respectively having the characters AAA, BBB, CCC,
  and DDD in columns 12 thru 14.  The following FIND subcommand
  would copy the last three lines to the new virtual data set:

    FIND BBB OPER(>=) ALL

))PICTURE - See HELP data for the same operand of the CHANGE
  subcommand.
))RESET - Specifying this keyword causes lines which meet the
  selection criteria to be reset so that they will be displayed
  (see also the SUPPRESS and RESET subcommands).
))SUPPRESS - Specifying this keyword causes lines which meet the
  selection criteria to be suppressed so that they will not be
  displayed (ABE also the SUPPRESS and RESET subcommands).
))SETRC - this keyword may be useful when invoking ABE from a CLIST.
  Normally, the return code from ABE is 0, but if the FIND
  subcommand is invoked with the SETRC keyword, and the specified
  text is not found, the return code from ABE will be 4.

=FLIP                                                                  @
)F FUNCTION -
  Use the flip subcommand to exchange the data in two sets of
  columns in a range of lines.
)X SYNTAX -
         <lsu> flip <lsu>
  required - <lsu>
  defaults - none
  alias    - none
)O OPERANDS -
 <lsu> is a Line Specification Unit as documented elsewhere in this
  manual.  Example -

                  1
         1234567890
       1.1 flip 1 2.1.3

       1 a123
       2 b
       3 c

  would produce -

                  1
         1234567890


       1 1abc
       2 2
       3 3

  Note that if <ncols> in the two <lsu>s don't match, the flip will
  terminate when the number of columns specified in the prefixed
  <lsu> have been exhausted. For example -

                  1
         1234567890
       1.1.2 flip 1,2 5.1.4

       1 12  abcd
       2 34  efgh
       3 56

  would produce -

                  1
         1234567890


       1 ab  1234
       2 cd  56gh
       3 ef

 NOTE: if the columns in the two LSUs specified in the flip
 subcommand overlap, your guess is as good as mine as to the
 results.

=FORMJCL                                                               @
)F FUNCTION -
  %%FORMJCL will reformat a data set containing JCL statements
  so that:  (1) all EXEC and DD keywords will begin in column 10;
  (2) all parameters on EXEC and DD statements will begin in
  column 16; (3) all continuation statements will begin in
  column 16.

)X SYNTAX -
  %%formjcl

  NOTE #1:  %%FORMJCL is actually a set of ABE subcommands stored in
  data set 'X75826.CNTL'.  You must have allocated this file under
  the ddname of SYSRUN for the %%FORMJCL subcommand to work.  A
  typical TSO command to do this is "alloc fi(sysrun)
  da('x75826.run') shr reuse".

  NOTE #2:  %%FORMJCL will create several temporary virtual data
  sets which will be deleted before FORMJCL is finished.  The
  symbolic data set names used are TMP and FORM.  If you already
  have data sets being edited with these symbolic data set names
  when you invoke %%FORMJCL, it will not work correctly.

)O OPERANDS - none

=FULLSCR                                                               @
)F FUNCTION -
  The fullscr subcommand is used return to normal full screen
  display mode after using the hardcopy subcommand.
)X SYNTAX -
         fullscr
  required - none
  defaults - none
  alias    - none
)O OPERANDS - NONE

=GD                                                                    @
)F FUNCTION -
    Each set of (x,y) values is transformed into a call to the GDDM
    GSLINE subcommand as follows:

      GDDM GSLINE <x>*<xscale>+<xoffset> <y>*<yscale>+<yoffset>

    See also the xscale, yscale, xoffset, and yoffset subcommands,
    and Appendix O for details.
)X SYNTAX -
    gd <x1> <y1> <x2> <y2> ... <x10> <y10)
  required - <x1> <y1>
  defaults - none
  alias    - none
)O OPERANDS - See Appendix O.

=GDDM                                                                  @
)F FUNCTION -
  The GDDM subcommand provides an interface to the GDDM program
  product licensed from IBM.  It provides a convenient way of
  experimenting with the various functions of GDDM without the
  necessity for compiling the linkediting a new program.
  See Appendix O for details.
)X SYNTAX -
    GDDM <name> <operands>
  required - <name>
  defaults - none
  alias    - none
)O OPERANDS - See Appendix O.

=GED                                                                   @
)F FUNCTION -
  The GED subcommand displays the variable BITMAP, which is
  a matrix of pixel values representing a rasterized scan of
  a graphics drawing.  See Appendix N for details.
)X SYNTAX -
    GED
  required - none
  defaults - none
  alias    - none
)O OPERANDS - none

=GETDDN                                                                @
)F FUNCTION -
  The GETDDN subcommand is used to set the replacement value for
  a symbolic variable to the ddname of the currently edited data
  set.
)X SYNTAX -
         getddn <symbolic-name>
  required - none
  defaults - <symbolic-name> defaults to SYSDDN
  alias    - none
)O OPERANDS -
 <symbolic-name> is the name of the symbolic variable (don't specify
   the preceding ampersand, e.g., &MYNAME would be specified MYNAME)
   whose replacement value is to be set to the dsname.  If
   <symbolic-name> is not specified, the default is SYSDDN.

=GETDSN                                                                @
)F FUNCTION -
  The GETDSN subcommand is used to set the replacement value for
  a symbolic variable to the dsname of the currently edited data
  set.  If the data set is partitioned, only the dsname, not
  including the member name, will be assigned as the replacement
  value.  The member name may be obtained via the GETMEM subcommand.
)X SYNTAX -
         getdsn <symbolic-name>
  required - none
  defaults - <symbolic-name> defaults to SYSDSN
  alias    - none
)O OPERANDS -
 <symbolic-name> is the name of the symbolic variable (don't specify
   the preceding ampersand, e.g., &MYNAME would be specified MYNAME)
   whose replacement value is to be set to the dsname.  If
   <symbolic-name> is not specified, the default is SYSDSN.

=GETMEM                                                                @
)F FUNCTION -
  The GETMEM subcommand is used to set the replacement value for
  a symbolic variable to the member name of the currently edited
  data set, if the data set is partitioned.  If the currently
  edited data set is not partitioned, the repaclement value will
  be set to blanks.
)X SYNTAX -
         getmem <symbolic-name>
  required - none
  defaults - <symbolic-name> defaults to SYSMEM
  alias    - none
)O OPERANDS -
 <symbolic-name> is the name of the symbolic variable (don't specify
   the preceding ampersand, e.g., &MYNAME would be specified MYNAME)
   whose replacement value is to be set to the member name.  If
   <symbolic-name> is not specified, the default is SYSMEM.

=GETNAME                                                               @
)F FUNCTION -
  The GETNAME subcommand is used to set the replacement value for
  a symbolic variable to the symbolic name of the currently edited
  data set.  The symbolic name may have been assigned using the
  NAME subcommand, or the NAME operand of the ABE subcommand.
)X SYNTAX -
         getname <symbolic-name>
  required - none
  defaults - <symbolic-name> defaults to SYSSYMB
  alias    - none
)O OPERANDS -
 <symbolic-name> is the name of the symbolic variable (don't specify
   the preceding ampersand, e.g., &MYNAME would be specified MYNAME)
   whose replacement value is to be set to the member name.  If
   <symbolic-name> is not specified, the default is SYSMEM.

=GETVOL                                                                @
)F FUNCTION -
  The GETVOL subcommand is used to set the replacement value for
  a symbolic variable to the volume serial of the currently edited
  data set.  The message area on the display will also be filled in
  with the volume serial.
)X SYNTAX -
         getvol <symbolic-name>
  required - none
  defaults - <symbolic-name> defaults to SYSVOL
  alias    - none
)O OPERANDS -
 <symbolic-name> is the name of the symbolic variable (don't specify
   the preceding ampersand, e.g., &MYNAME would be specified MYNAME)
   whose replacement value is to be set to the volume serial.  If
   <symbolic-name> is not specified, the default is SYSVOL.

=GFILL                                                                 @
)F FUNCTION -
  The GFILL subcommand is used to fill in an area of the graphics
  drawing represented in the internal pixel map described in
  Appendix N.
)X SYNTAX -
    'gfill' <x> <y> <z> ('inches' × 'pixels' × 'ndc')
  required - <x> <y>
  defaults - 'inches'
)O OPERANDS -  See Appendix N

=GPR                                                                   @
)F FUNCTION -
  The GPR subcommand generates the necessary data stream to display
  variable BITMAP, which is a matrix of pixel values representing a
  rasterized scan of a graphics drawing, on a specified graphics
  device. See Appendix N for details.
)X SYNTAX -
    gpr <dest> <device>
  required - <dest>
  defaults - <device> = CITOH
  alias    - none
)O OPERANDS - See Appendix N.

=GR=GS                                                                 @
)F FUNCTION -
  The GR subcommand is one of a number of ABE subcommands that
  facilitate the manipulation of rasterized graphic images.  A large
  chunk of memory, 810000 bytes, above the 16M line, called BITMAP, is
  organized to contain these rasterized graphic images, and  various
  other subcommands allow you to manipulate the images, e.g. GR, GED,
  GPR, etc.

  The GR subcommand also provides an interface to the PLOT79 program
  product.  It provides a convenient way of experimenting with the
  various functions of PLOT79 without the necessity for compiling
  and linkediting a new program. See Appendix N for details.

)X SYNTAX -
    GR <name> <operands>
  required - <name>
  defaults - none
  alias    - GS
    Use of the alias GS invokes an abbreviated version.  The BITMAP
    is still available, but only a limited number of PLOT79 subroutines
    are available:

     CLPL3 CLPL4 ERRAR ERRAT ERRCK ERRIN ERRMS ERRTR LINA3 MATMM MATPM
     MATTV MATUN MOVA3 PLTCL PLTDL PLTIO PLTLS PLTML PLT00 SETSZ SETTR
     SET00 SYMSF SYMSS SYM00 UTITTY UTRXP

)O OPERANDS - See Appendix N.

=GSAS                                                                  @
)F FUNCTION -
  The GSAS subcommand allows interactive use of SAS/GRAPH on a
  non-graphics terminal.  See also Appendix N.
)X SYNTAX -
  gsas <X1> <Y1> <X2> <Y2> <SAS-PARMS> <DEST> <TYPE>
  required - none
  defaults - <X1>=0 <Y1>=0 <X2>=10.2 <Y2>=7 <TYPE>=CI600
  alias    - none
)O OPERANDS - See Appendix N.

=GU                                                                    @
)F FUNCTION -
    The set of (x,y) values is transformed into a call to the GDDM
    GSMOVE subcommand as follows:

      GDDM GSMOVE <x>*<xscale>+<xoffset> <y>*<yscale>+<yoffset>

    See also the xscale, yscale, xoffset, and yoffset subcommands,
    and Appendix O for details.
)X SYNTAX -
    gu <x> <y>
  required - <x> <y>
  defaults - none
  alias    - none
)O OPERANDS - See Appendix O.

=HALFB                                                                 @
)F FUNCTION -
  Enter the HALFB subcommand to move the display half a page
  backwards.
)X SYNTAX -
         halfb <number>
  required - none
  defaults - <number>=1
  alias    - none
)O OPERANDS -
 <number> - is the number of half pages to scroll.

=HALFF                                                                 @
)F FUNCTION -
  Enter the HALFF subcommand to move the display half a page
  forewards.
)X SYNTAX -
         halff <number>
  required - none
  defaults - <number>=1
  alias    - none
)O OPERANDS -
 <number> - is the number of half pages to scroll.

=HARDCOPY                                                              @
)F FUNCTION -
  The hardcopy subcommand is used change the display to hardcopy
  mode.  In the mode, the screen is scrolled in the same fashion as
  when in READY mode.  This advantage of going to this mode is that
  a full 240 characters can be entered as a subcommand.
)X SYNTAX -
         fullscr
  required - none
  defaults - none
  alias    - none
)O OPERANDS - NONE

=HELP=H                                                                @
)F FUNCTION -
  Use the help subcommand to obtain information about other abe
  subcommands.
 +Note that help can be entered under abe  either as a subcommand
  to find out about other subcommands of the abe  command (find,
  top, bottom, etc.), or as a major command to find out about
  other major commands (pli, listc, listds, etc.).  While under
  abe , if you are not currently in xmode (see help data for the
  x subcommand), and you enter "help" in the command area, abe
  assumes the help subcommand, and will give you a list of abe
  subcommands.  When the list is displayed, abe  will put you in
  xmode.  If you have entered xmode in this fashion, until you
  return to scan mode, any help commands you enter are assumed to
  be requests for subcommand data.  If you enter xmode via the x
  subcommand, any help commands you enter are assumed to be
  requests for major command data.
)X SYNTAX - SAME AS FOR EDIT, OPER, AND TEST
         help
  required - none
  defaults - none
  alias    - h
)O OPERANDS - NONE

=HEX                                                                   @
)F FUNCTION -
   This subcommand causes the data set to be displayed in hex
   mode.  In this mode, each record is displayed on two lines of
   the screen.  The first line will contain the record in ebcdic,
   except that unprintable characters will be translated to
   blanks, and a space will be inserted after each character
   of the record.  This spacing is done so that the characters
   will match up with their hexadecimal representation, which is
   displayed on the second line.  You can change data for the
   record in either line of the display, but remember that the
   first line contains periods where unprintable characters
   exist in the record; if you change data in this line, the
   unprintable characters in the record will be replaced with the
   periods from the display.  If you change data in the second
   line for a record, use hexadecimal character representations
   (e.g.  C1 = 'a').  To return to normal display mode, enter the
   char subcommand.
)X SYNTAX -
         hex
  required - none
  defaults - none
)O OPERANDS - NONE

=HI                                                                    @
)F FUNCTION -
  Use the hi subcommand to indicate that any further input by you
  is to be translated to upper case.
 +Note that if hi is not currently in effect, and you want a
  particular line of input to be translated to upper case, you
  can cause this by entering "hi" in the line number field for
  that line.
)X SYNTAX -
         hi
  required - none
  defaults - none
)O OPERANDS - NONE

=IMGET                                                                 @
)F FUNCTION -
  IMGET retrieves a rectangle of pixels from the internal pixel map,
  and stores them in the specified dataset as one or more lines of
  printable '0's and '1's.  See Appendix N for details.
)X SYNTAX -
  imget <name> <xpel1> <ypel1> <xpel2> <ypel2>
  required - none
  defaults - <name>=* <xpel1>,<ypel2>=1 <ypel1>=plmaxy <ypel2>=plmaxx
)O OPERANDS - See Appendix N

=IMGETB                                                                @
)F FUNCTION -
  IMGET retrieves a rectangle of pixels from the internal pixel map,
  and stores them in the specified dataset, each pixel being
  represented by a bit.  See Appendix N for details.
)X SYNTAX -
  imgetb <name> <xpel1> <ypel1> <xpel2> <ypel2>
  required - none
  defaults - <name>=* <xpel1>,<ypel2>=1 <ypel1>=plmaxy <ypel2>=plmaxx
)O OPERANDS - See Appendix N

=IMPUT                                                                 @
)F FUNCTION -
  IMPUT stores a rectangle of pixels into the internal pixel map,
  based on pixel representations in the specified dataset. The
  pixels are represented in the specified dataset by strings of
  printable '0's and '1's. See Appendix N for details.
)X SYNTAX -
  imput <name> <xpel1> <ypel1> <xpel2> <ypel2>
  required - none
  defaults - <name>=* <xpel1>,<ypel2>=1 <ypel1>=plmaxy <ypel2>=plmaxx
)O OPERANDS - See Appendix N

=IMPUTB                                                                @
)F FUNCTION -
  IMPUTB stores a rectangle of pixels into the internal pixel map,
  based on pixel representations in the specified dataset. The
  pixels are represented in the specified dataset by strings of
  bits.  See Appendix N for details.
)X SYNTAX -
  imputb <name> <xpel1> <ypel1> <xpel2> <ypel2>
  required - none
  defaults - <name>=* <xpel1>,<ypel2>=1 <ypel1>=plmaxy <ypel2>=plmaxx
)O OPERANDS - See Appendix N

=INCLUDE                                                               @
)F FUNCTION -
  Provide a convenient method for including commonly used text in
  the currently edited data set.
)X SYNTAX -

  include <name-spec> <line-number> rep

  required - <name-spec>
  defaults - <line-number> defaults to LAST
)O OPERANDS -
 <name-spec> - may be one of the forms "member" or "ddname(member)".
  In the first form, the ddname is assumed to be SYSLIB.  You must
  have preallocated the specified ddname before invoking the
  INCLUDE subcommand.  Note that the specified member must be
  a numbered data set.
 <line-number> - indicates the line number behind which the included
  text is to be inserted.  If <line-number> is not specified, then
  the included text will be inserted following the current line
  number.  If <line-number> is specified as "LAST", then the
  included text will be inserted at the end of the currently edited
  data set.
))REP - If specified, it indicates that symbolic substitution is
  is to be performed on each line before it is inserted (see also
  the description for the SYMREP subcommand).

=INSERT=IN=I=IF=IB                                                     @
)F FUNCTION -
  Use the insert subcommand to change from scan mode to insert
  mode.  Note that you can insert records at the end of the data
  set without leaving scan mode simply by keying them on the
  display in blank lines following the last record displayed.
  They will be assigned numbers beginning one higher than the
  last record in the file, and will increment by one.
)X SYNTAX -
           insert <number>
  required - none
  alias    - in/i/if/ib
)O OPERANDS -
 <number> - The line number of the line behind which records
   are to be inserted.  To insert records at the front of the
   data set, enter "i 0".  If number is not specified, the
   records will be inserted following the first line on the
   display.
  +If the line specified doesn't exist, the records will be
   inserted following the line with the next lower line number.
  +You may key up to 19 lines to be inserted on each screen.
   after you hit enter, abe  will provide a new blank screen for
   you to key up to 19 more lines.  This will continue until you
   enter the scan subcommand to return to scan mode.
  +The inserted records are sequenced incrementing by 1 from the
   previous record.  If the sequence number of a record to be
   inserted exceeds the sequence number of the record in front of
   which it is to be inserted,  abe  will resequence,
   incrementing by 1, for as many records as necessary.

=ISPLINK                                                               @
)F FUNCTION -
  This subcommand provides an interface to ISPF services, provided
  ABE was originally invoked as follows:

    ISPEXEC SELECT PGM(ABESPFA) PARM('<PARAMETERS> CLIST')

  Note that the entire topic of how ISPF and ABE are to relate and
  interact with one another is discussed more fully in appendix F
  to this manual.
)X SYNTAX -
  isplink <parameters>

  sample:  isplink browse cntl(jcltemp)

)O OPERANDS -
 <parameters> - this is a series of one to five parameters that
  are to be passed to isplink in a fashion similar to that used
  in PL/I when calling the ISPLINK procedure supplied by ISPF.
  For example, if you enter the subcommand "isplink browse
  cntl(jcltemp)", the invocation will be equivalent to the
  following in PL/I:

       CALL ISPLINK('BROWSE ','CNTL(JCLTEMP) ');

=ITEIN                                                                 @
)F FUNCTION -
  ITEIN can be used to re-format PL/I and SAS source, using
  inabe ation to iabe ify the level of nesting.  if-then-else-do
  structures, among others, are inabe ed to show level of
  nesting.
)X SYNTAX -
           ITEIN   SUPPRESS SAS PLI
  required - none
  defaults - insert indent(2) pli
  alias    - none
)O OPERANDS -
))SUPPRESS - Specifying this keyword causes all lines except
   those containing if, then, else, do, proc, begin, select, or
   end clauses to be suppressed from the display (see also the
   suppress/reset subcommands).
))SAS - Indicates that the data set contains SAS source statements
   to be re-formatted.
))PLI - Indicates that the data set contains PLI source statements
   to be re-formatted.

=JOB                                                                   @
)F FUNCTION -
  The JOB subcommand can be used to quickly submit a jobdeck for
  batch execution.  Unlike the SUB subcommand, the jobdeck is not
  first stored in LASTJCL.CNTL.  Also, the card-images will not have
  sequence numbers in 73-80.  The big advantage of this subcommand
  is that it is very fast.
)X SYNTAX -
  <lsu> job
  required - none
  defaults - none
  alias    - none
)O OPERANDS -none

=JOIN                                                                  @
)F FUNCTION -
  Use the join subcommand to combine one or more
  pairs of consecutive lines.
 +Note that trailing blanks are discarded during the join
  operation. For example, if two lines containing 'ABC   ' and
  ' DEF   ' respectively, are to be joined, the resultant line
  will contain 'ABC DEF   '.
)X SYNTAX -
         <lsu> join <pairs>
  defaults - none
)O OPERANDS -
   <pairs> - This operand is optional, and indicates the number
             of lines in each group to be combined.  If not
             specified, the default is 2.
   +NOTE: Everything but <l1> and <l2> in the LSU will be ignored.

=LAST                                                                  @
)F FUNCTION -
  Use the last subcommand to retreive the last ABE subcommand you
  entered into the command input area.  You can then make changes
  to the subcommand and re-enter.  Note that pfk 1 is equivalent
  to entering the last subcommand.
)X SYNTAX -
         last
  required - none
  defaults - none
)O OPERANDS - NONE

=LINES                                                                 @
)F FUNCTION -
  Use the lines subcommand to change the number of display lines
  "owned" by a data set being edited.  More detailed information
  can be obtained under help data for the abe  subcommand.
)X SYNTAX -
         lines <cnt>
  required - none
  defaults - 0
)O OPERANDS -
  <cnt> - This value indicates the number of data display lines
  to be owned by this data set, or, if <cnt> is not numeric, it
  is the symbolic name of the data set that is to inherit the lines
  currently owned by this data set.
    When display lines
  are given up for a data set, those lines are adopted by:
  (1) The data set owning the next lower set of display lines;
  (2) The data set owning the previous set of display lines;
  (3) or a data set which is being edited, but does not currently
  own any display lines.
    NOTE:  <cnt> can now either expand or shrink the number of
  display lines owned by the current data set.  In earlier versions
  of ABE, you were permitted only to give up lines.

=LIST=L                                                                @
)F FUNCTION -
  Use the list subcommand to list lines while editing data sets
  on a hardcopy terminal.
)X SYNTAX -
         <lsu> list
)O OPERANDS - none

=LISTRF                                                                @
)F FUNCTION -
  Use the listrf subcommand to obtain the last reference date for
  a list of dataset names.  This subcommand is especially useful
  in conjunction with the CL subcommand, e.g. the subcommand
  "cl x75826.ibm3800" produces the following listing:


                10        20        30        40
       12345678901234567890123456789012345678901234567890
                                            ×@CL××3X256.1
    01 X75826.IBM3800.DATA
    02 X75826.IBM3800.HELP
    03 X75826.IBM3800.TEXT

  If the subcommand "a @cl listrf" is entered, dataset @cl will be
  changed to appear as follows, with the date the dataset was
  last referenced in the form YYMMDD prefixed to each line:

                10        20        30        40
       12345678901234567890123456789012345678901234567890
                                            ×@CL××3X256.1
    01 870712 X75826.IBM3800.DATA
    02 870623 X75826.IBM3800.HELP
    03 870624 X75826.IBM3800.TEXT

)X SYNTAX -
         <lsu> listrf volser
)O OPERANDS -
))VOLSER - If this keyword is specified, the volume serial in
  addition to the last referenced dated is listed.

=LL                                                                    @
)F FUNCTION -
  Use the ll subcommand to change the length of one or more
  lines.  The lines are considered to contain words, and when the
  lines are adjusted, words will not be divided.  Words will be
  shifted from one line to another to fill out each line as
  close as possible to the specified line length.
 +Note that the shifting of words is done only within groups of
  lines having the same left margin, and also a new group will be
  defined if a blank line is encountered.
 +Note that LL is also useful after doing power typing text entry.
  See text on the <rm> operand below

)X SYNTAX -

         <lsu> ll <len> <lm> <rm>
  required - <len>
  defaults - none
)O OPERANDS -
  NOTE: everything but <l1> and <l2> in the LSU will be ignored.
  <lm>     - is optional, and indicates the left margin of the
   data to be adjusted.  Only words to the right of this margin
   will be adjusted, and if words must be moved to a new line,
   they will be placed to the right of this margin.  Also, no
   words will be shifted to the next line if that line contains
   non-blanks to the left of the specified margin.  Instead, a
   new line will be inserted to contain the shifted word.
  <rm> - If this operand is specified, the text is assumed to be in
   a special format, as though it had been entered in what is called
   power typing text entry.  An example of such text is shown below:

              10        20        30        40        50
     123456789012345678901234567890123456789012345678901

     Still round the corner there may wait, A new road
      or a secret gate.  And tho I oft have passed the
     m by, A day will come at last when I, shall take
     the hidden paths that run, East of the Moon, West
      of the Sun. Hark, what light by yonder window sh
     ines? It is the East and Juliet is the Sun.  Aris
     e fair Sun and kill the envious Moon, who is alre
     ady sick and pale with grief that thou, her maid,
      art far more fair than she.

   You might have produced such text under ABE using the IN
   subcommand.  If the subcommand "LL ALL 50 1 49" were applied
   to the above data set, the following would be the result:

              10        20        30        40        50
     123456789012345678901234567890123456789012345678901

     Still round the corner there may wait, A new road
     or a secret gate.  And tho I oft have passed them
     by, A day will come at last when I, shall take the
     hidden paths that run, East of the Moon, West of
     the Sun. Hark, what light by yonder window shines?
     It is the East and Juliet is the Sun. Arise fair
     Sun and kill the envious Moon, who is already sick
     and pale with grief that thou, her maid, art far
     more fair than she.

   The <rm> operand indicates the right-most column in which text
   is entered.  If <rm> is specified, <lm> must be 1.  Starting
   with the last line in the specified range, if column 1 is
   nonblank, and column <rm> in the previous line is also nonblank,
   it is assumed that a word has been split between the two lines,
   and it will be re-combined in the resulting text.

=LO                                                                    @
)F FUNCTION -
  Use the lo subcommand to indicate that any further input by you
  is not to be translated to upper case.
 +Note that if lo is not currently in effect, and you want a
  particular line of input not to be translated to upper case, you
  can cause this by entering "lo" in the line number field for
  that line before hitting enter.
)X SYNTAX -
         lo
  required - none
  defaults - none
)O OPERANDS - NONE

=LSP=LSS                                                               @
)F FUNCTION -
  The lsp command can be used to apply any other ABE subcommand
  or subcommands to a range of lines selected via more
  sophisticated criteria other than simply line-a thru line-b.
  See Appendix J to the ABE Reference Manual for a detailed
  description of this subcommand.
)X SYNTAX -
         lsp <template> <keywords> topdown
  required - <template>
  defaults - none

  NOTE:  If <template> begins with an apostrophe, the command
  name, "lsp", does not have to be entered.  For example,
  "lsp 'bl &1' 1(a)", and "'bl &1' 1(a)" are equivalent
  commands.

)O OPERANDS - see Appendix J

=MB                                                                    @
)F FUNCTION -
  Use the mb subcommand to merge back lines copied via the
  findall subcommand.  Lines with matching sequence numbers
  will be overlayed.  Lines without matching sequence numbers
  will be interleaved.
 +Note that if no operands are specified, the position of the data
  sets on the display is critical.  The mb command should be
  entered on the command line of the original data set, and the
  temporary data set containing the copied lines must own the
  display lines just below those owned by the original data set.
 +Note:  You should be intimately familiar with how MB works when
  using it in a subcommand list executed via the run or do
  subcommands.  MB first merges back the specified lines from
  data set <name>, and then puts an "end n" subcommand on the
  subcommand stack for data set <name>.  In the case of an MB
  in a subcommand list executed via run, the "end n"
  subcommand may not get executed until the entire list of
  subcommands has been executed.  This may not be desirable.
  To ensure the "end n" is executed immediately after the MB
  subcommand, use the following sequence, when <name> is bbb:

    mb bbb nodel
    a bbb end n

)X SYNTAX -
         mb <name> nodel mask overlay
  required - none
  defaults - none
)O OPERANDS -
 <name> - This operand is optional.  If specified, it indicates the
   symbolic name associated with the data set to be interleaved back
   into this data set.  If not specified, the data set containing
   lines to be interleaved back should be on the display immediately
   below this one.
 nodel - If this keyword is specified, editing of the data set
   containing the lines being copied will not be ended.  If this
   keyword is not specified, an "end nosave" subcommand will be
   issued for the data set from which lines are copied.
 mask - synonymous with the overlay keyword.  See below.
 overlay - If either the mask or the overlay keyword is specified,
   only nonblanks in the named data set will be merged back.

=MCALC                                                                 @
)F FUNCTION -
 MCALC can be used to perform calculations on a matrix of numbers.
)X SYNTAX -
  <lsu> mcalc <expression>
  required - <expression>
  alias    - none
)O OPERANDS -
 <expression> - this may be an expression involving any of the
   functions and variables described under the CALC subcommand.
   To reference the value of each element of the matrix, use
   variable E.  The current row and column of the element will
   be stored in variables R and C, respectively.
))EXAMPLE - The subcommand "1.5.4 mcalc e+240" applied to -

  ==>
  001 1    2    3    4
  002 5    6    7    8
  003 9   10   11   12

  would produce the result -

  ==>
  001 241  242  243  244
  002 245  246  247  248
  003 .    .    .    242

=MD=V                                                                  @
)F FUNCTION -
  Use the md subcommand to move the display.  Note that in addition
  to entering the md subcommand in the command area, the character
  "v" or "p" can also be entered in the line number field to
  indicate where the display is to be moved.
)X SYNTAX -
           md <number>
 required - none
 alias - v
 defaults - none
)O OPERANDS -
 <number> - the line number of the line to which the display
   is to be moved.  If the line specified doesn't exist, the
   display will be moved to line with the next lower line number.
   if <number> is not specified, the display will be moved to
   line <l1> specified in the LSU.

=ME                                                                    @
)F FUNCTION -
  The me subcommand is strictly a line command.  That is, it
  can only be used in the line number field of the display.
  It is used to set the mark array element number two
  with the line number over which the me line command was
  entered.  See the mc, mdel, mk, mm, ms, and mt subcommands
  for further information.
)X SYNTAX -
         Can only be entered as a line command.
)O OPERANDS - NONE

=MEMORY                                                                @
)F FUNCTION -
  Call this subcommand to find out how much free memory is available
  in the region.  symbolic variable &MEMORY is set, and also a message
  is produced in the message area.
)X SYNTAX -
  memory
)O OPERANDS - NONE

=MERD                                                                  @
)F FUNCTION -
  Merd is identical in function to merge, except the <dsname>
  operand of merge is replaced with a <name> operand in merd.
  the <name> operand of merd refers to the symbolic name (assigned
  through one of the subcommands abe , name, or define) associated
  with a data set currently being edited.  The lines to be merged
  will be selected from that data set in virtual storage.
)X SYNTAX -
         merd   <name> <in-line-range> <linenum3>

 NOTE: the MERD subcommand ignores any LSU you might specify.

)O OPERANDS - for all operands except <NAME>, see the merge
  subcommand.

=MERGE=M                                                               @
)F FUNCTION -
  Merge causes all or part of a specified data set to be merged
  with the data set being edited.  Only the data set being edited
  is altered.
)X SYNTAX -
         merge   <dsname> <in-line-range> <linenum3>
  required - <dsname> <linenum3> defaults - none

  alias    - m
)O OPERANDS -
  <dsname> - The data set to be merged with the data set being
             edited.  Note that if you enter a fully qualified
             data set name, you must surround it in
             quotes.  For example, 'sys2.proclib(au109209)'.

  <in-line-range>
           - Specifies a range of lines in the data set to be
             merged with the data set being edited.  One or two
             line numbers may be specified.  If these line
             numbers are omitted, the entire data set is merged
             into the data set being edited.
  <linenum3>
           - Specifies a line number in the data set being
             edited.  Merged records will be inserted following
             this line.  If the specified line number doesn't
             exist, records will be inserted following the line
             with the next lower line number.  The minimum
             resequencing of subsequent records in the edited
             data set will be done automatically.

=MK=MARK                                                               @
)F FUNCTION -
  The mk subcommand is used to set elements of the mark array.
  Effectively, this is a 9-element "memory", indexed by numbers 1
  thru 9, which can be referenced in the LSU. "20000 mk 1" sets mark
  array element 1 to 20000, for example.  Note that you can see a
  display of the current settings of the mark array by entering the
  mk subcommand with no operands. The mark array is initialized to
  zero.
 +Note that M can be entered in the line number field at the left
  of each line, e.g., if you change the line number field for line
  460 to read "5m460" (the 60 is residual);  when you hit enter,
  mark array element 5 is set to 460.
)X SYNTAX -
         <lsu> mk <ix>
  required - none
  alias    - none
)O OPERANDS -
 <ix> - is a number from 1 thru 9 which is used as the index
    to the proper element in the mark array.  That element will be
    set to the line number specified by <l1> in the LSU.

=ML                                                                    @
)F FUNCTION -
  The ML subcommand obtains a list of member names for the specified
  partitioned dataset name. CAUTION:  The list will be stored in the
  currently edited dataset with symbolic name @ML.  If no such
  dataset is being edited, a virtual dataset will be defined.  If
  such a dataset if already being edited, all lines in it will be
  deleted by the ML subcommand before it stores the new list.
)X SYNTAX -
         ml <pdsname> <volser>
  required - <pdsname> may be omitted if the subcommand is being
    entered on the command line for a currently edited partitioned
    dataset, in which case that name will be used for <pdsname>.
  alias    - none
)O OPERANDS -
 <pdsname> - Name of partitioned dataset from which the member name
    list is to be obtained.
 <volser> - Optional volume serial.  If not specified, the catalog
    is searched to find the volume serial of the disk containing
    the dataset.

=MLL                                                                   @
)F FUNCTION -
  The MLL subcommand is almost identical in syntax and function to the
  ML subcommand.  It differs in that the list of member names stored
  in dataset @ML will be in the form of executable ABE subcommands.
)X SYNTAX -
         ml <pdsname> <volser>
  required - <pdsname> may be omitted if the subcommand is being
    entered on the command line for a currently edited partitioned
    dataset, in which case that name will be used for <pdsname>.
  alias    - none
)O OPERANDS -
 <pdsname> - Name of partitioned dataset from which the member name
    list is to be obtained.
 <volser> - Optional volume serial.  If not specified, the catalog
    is searched to find the volume serial of the disk containing
    the dataset.

=MOVE=MO                                                               @
)F FUNCTION -
  Move a matrix of data from one place to another in the data set
  being edited.  The concept of a matrix of data is critical to
  understanding and using both the MOVE and COPY subcommands.
  See appendix H to this manual, which describes line specification
  units, and also explains the data matrix concept.

)X SYNTAX -
         <lsufrom> 'move' '('(<name>) (':') (<lsuto>)')' (<copies>)
           ('ol' × 'from' × 'to')

   alias - mo
)O OPERANDS -
  The colon (':') shown in the above syntax may be used when the
  <name> to be specified could be mistaken for part of <lsuto>.
  For example, you might specify the subcommand 'co b' intending that
  the entire dataset be copied to a new data set named B.  The actual
  function performed would be that the entire data set would be
  replicated following the current bottom line.  To get the desired
  function accomplished, you would specify 'co b:'.

  The manner in which the move/copy operation is done varies
  depending on which of the three keywords OL, FROM, or TO is
  specified or defaulted to.  Note first that the keywords are
  mutually exclusive; that is, only one of them can be specified. If
  you don't specify any of the three keywords, A default will be
  taken as follows:

    1.  If <lsuto> specifies at most a single line number, that is it
        either specifies a single line number, or doesn't specify any
        line numbers at all, then the FROM keyword is the default.
    2.  If <name> is used to specify an empty data set, and no line
        range is specified in <lsuto>, then the FROM keyword is the
        default.

  The FROM and TO keywords determine whether <lsufrom> or <lsuto>
  will drive the operation.  That is, if the FROM keyword is
  specified, the operation will continue as long as columns specified
  by <lsufrom> are available.  If the TO keyword is specified, the
  operation will continue as long as columns specified by <lsuto>
  have not yet been processed.

  For example, given the following data -

    abcd
    efgh
    ijkl

  the subcommand "1.1.4 move (1,5 1.1.3)", which defaults to the TO
  keyword, produces -

    abc
    def
    ghi
    jkl
    abc

  But by adding the FROM keyword, "1.1.4 move (1,5 1.1.3) from",
  the result would be -

    abc
    def
    ghi
    jkl

  to take another example, the subcommand 2.2 move xxx

  will cause new lines containing the data -

     bc
     fg
     jk

  to be added to data set with short hand name xxx.  If such a data
  set doesn't currently exist, a virtual data set will be defined
  to contain the data lines.  If the data set already exists, the
  new lines will be added following the top line in that data set.

  <copies> - A number indicating the number of times the range of
   lines is to be copied.
  <name> - is optional, and specifies the short-hand name of the
   data set to which the lines are to be moved.
  <lsuto> - is as described in Appendix H.  For example, given the
   data set and move subcommand below -

                      1
             1234567890

           1.1.6 mo (1,6 1.1.2)

           1 ABCDEF
           2 GHIJKL

   The result would be -

                      1
             1234567890


           1 AB
           2 CD
           3 EF
           4 GH
           5 IJ
           6 KL

  Note that if <lsuto> specifies at most a single line number, the
  defaults for <off> <len> and <ncols> in the <lsuto> processing
  will be the values indicated for the <lsu> preceding the move
  command.

))FROM - As previously indicated, the FROM keyword indicates that the
  move/copy process is to continue as long as a column specified by
  <lsufrom> has not been processed.
))OL - If this keyword is NOT specified, move/copy will always create
  new lines to contain the copied data.  If the OL keyword is
  specified, however, the data is copied to existing lines specified
  by the <l1> and <l2> values from <lsuto>.  For example, given the
  data -

    abc
    def
    ghi

  the subcommand "1.1.3 copy (1 10.1.9) ol" would produce the
  following -

    abc      abcdefghi
    def
    ghi

  whereas given the same original data, the same subcommand without
  the ol keyword, "1.1.3 copy (1 10.1.9)" would produce the
  following -

    abc
             abcdefghi
    def
    ghi

  The OL keyword provides for some interesting propagations.  Given
  a dataset with 6 lines as follows -

               10        20        30        40        50
      123456789012345678901234567890123456789012345678901

    1 S
    2 m
    3 i
    4 t
    5 t
    6 y

  The subcommand -

    1.1.49 co 2.1.49 ol

  would produce -

               10        20        30        40        50
      123456789012345678901234567890123456789012345678901

    1 SSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSS
    2 mmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmm
    3 iiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiii
    4 tttttttttttttttttttttttttttttttttttttttttttttttttt
    5 tttttttttttttttttttttttttttttttttttttttttttttttttt
    6 yyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyy

))TO - As previously indicated, the TO keyword indicates that the
  move/copy process is to continue as long as a column specified by
  <lsuto> has not been processed.  If more columns are specified in
  <lsuto> than in <lsufrom>, then columns in the <fromlsu> will be
  recycled.

=MOVEP                                                                 @
)F FUNCTION -
  Use the MOVEP subcommand to move the pen on the graphics drawing.
  see Appendix N, subtitle SOME ADDITIONAL GRAPHICS SUBCOMMANDS.
)X SYNTAX -
    draw <x> <y> <z> ('inches' × 'pixels')
  required - none
  default - 1
)O OPERANDS - See Appendix N.

=MS                                                                    @
)F FUNCTION -
  The ms subcommand is strictly a line command.  That is, it
  can only be used in the line number field of the display.
  It is used to set the mark array element number one
  with the line number over which the ms line command was
  entered.
)X SYNTAX -
         Can only be entered as a line command.
)O OPERANDS - NONE

=MSG                                                                   @
)F FUNCTION -
  The MSG subcommand can be used to put a message in the message
  area of the display.
)X SYNTAX -
  msg <data>
)O OPERANDS -
  <data> - consists of any text from 1 character beyond "msg" to
    the end of the command, e.g. "msg hi there!".

=MT                                                                    @
)F FUNCTION -
  The mt subcommand is strictly a line command.  That is, it
  can only be used in the line number field of the display.
  It is used to set the mark array element number three
  with the line number over which the mt line command was
  entered.
)X SYNTAX -
         Can only be entered as a line command.
)O OPERANDS - NONE

=MV                                                                    @
)F FUNCTION -
  The mv subcommand may be entered only as a line subcommand. It
  will store the line number it is entered on in mark array element
  four.  You can think of this as "remembering" where you want the
  display moved at a later time.  Later, you can enter "4m v" to
  return the display to this line.
)X SYNTAX -
         line subcommand only.
)O OPERANDS -

=NAME                                                                  @
)F FUNCTION -
  Use the name subcommand to assign a short-hand name to the current
  data set. This name will appear to the left of the command line
  for this data set, unless it is the top data set on the display.
  Note that this name is not a dsname, but is merely a short handle
  with which to reference the data set in ABE subcommands.
)X SYNTAX - NAME <NAME> SUPPORT
  required - <name>
)O OPERANDS -
 <name> - is the short-hand name, 8 characters or less, to be
   assigned to the current data set.  If the current data set is to
   be a subcommand list to be associated with a program function
   key, then the name should be of the form "pfknn", when nn
   is a number from 0 to 99.
))SUPPORT - Specify this keyword if the data set is to act
   as a support data set.  For a description of support data sets,
   see the help data for the SUPPORT subcommand.

=NAMELOC                                                               @
)F FUNCTION -
  Use the nameloc subcommand to determine if the specified symbolic
  name is currently in use with a currently edited dataset.  Symbolic
  names are assigned via e.g. the NAME subcommand.
)X SYNTAX -
    nameloc <name>
  required - <name>
)O OPERANDS -
 <name> - is the short-hand name, 8 characters or less, to be
   searched for.  If found, the return code (symbolic &LASTCC) is
   set to 0, and otherwise is set to 4.

=NCODE                                                                 @
)F FUNCTION -
 Can be used to encrypt data.  See also the DCODE subcommand.
)X SYNTAX -
 <lsu> ncode <key>

  example: ncode teesha

)O OPERANDS -
 <key> - Key which will be used in the encryption process, and must
  later be specified on the DCODE subcommand to decrypt the data.
  The length of <key> may not exceed 8.

 NOTE: The <len> specification in the LSU must be evenly divisible
 by 8.

=NEWPEN                                                                @
)F FUNCTION -
  Use the NEWPEN subcommand to select a new graphics pen.
  See Appendix N, subtitle SOME ADDITIONAL GRAPHICS SUBCOMMANDS.
)X SYNTAX -
    newpen <n>
  required - <n>
)O OPERANDS - See Appendix N.

=NL                                                                    @
)F FUNCTION -
 This subcommand adds the data on the subcommand as a new line
 in the data set.

)X SYNTAX -

 nl <data>


)O OPERANDS -
 <data> - data to be stored in the new line in the data set.
  The new line will be added following the current line, and the
  current line pointer will be changed to point to the new line.
 +NOTE: Syntax for the NL subcommand is slightly different from most
  other ABE subcommands in that <data> does not have to be enclosed
  in quotes if it contains blanks or other special characters.
  Instead <data> is considered to begin with the second character
  after the subcommand command name, "nl", e.g. "nl    abc" produces
  a line containing "   abc".

=NUM                                                                   @
)F FUNCTION
 If the data set currently being edited is an unnumbered data
 set, issuing the num subcommand will cause it to become a
 numbered data set when it is saved the next time.

=NUMCK                                                                 @
)F FUNCTION -
 Use NUMCK to check the replacement value for a symbolic value for
 valid numeric data, or for left- or right- justification.
 The return code from the subcommand will be set to 0 if the
 replacement value meets the specified criteria, and will be set
 to 4 if not.
)X SYNTAX -
  numck <symbol> all left right char period

  example  - numck xyz left
  required - <symbol>
)O OPERANDS -
 <symbol> - this is the name of the symbolic variable whose
  replacement value is to be check for valid numeric data, or for
  left- or right justification.
))ALL - All positions in the value must be numeric.  That is,
  replacement values '123 ' and ' 123.45' would not be acceptable,
  and the return code would be set to 4.  But replacement values
  '123' and '123.45' would be acceptable, and the return code
  would be set to 0.
))LEFT - The variable must be left justified.
  For example, values '123 ' and 'abc ' might both be
  acceptable (depending on whether the CHAR keyword was also
  specified), whereas ' 123' and ' abc' would not.
))RIGHT - The variable must be right justified.
  For example, values ' 123' and ' abc' might both be
  acceptable (depending on whether the CHAR keyword was also
  specified), whereas '123 ' and 'abc ' would not.
))CHAR - The variable may contain non-numeric data. This
  keyword might be used in conjunction with the LEFT and RIGHT
  keywords if you didn't care whether data was numeric or not,
  but were concerned solely with left- or right justification.
))PERIOD - Specify this keyword if a single period in the
  replacement value is acceptable as numeric data.  For example,
  '123' and '123.45' are acceptable, but '123.45.78' is not.
=OL                                                                    @
)F FUNCTION -
  Use the ol subcommand to overlay one range of lines with
  nonblank data from a second range.
)X SYNTAX -
         <lsu> ol <lsu> <name>
  required - <lsu>
)O OPERANDS -
  <lsu> is an LSU as documented in appendix H.  For example, given
   the data set and OL subcommand below -

                1
       1234567890

     2,4 ol 1

     1 *   *
     2   A
     3   B
     4   C

   The results would be -

                1
       1234567890


     1 *   *
     2 * A *
     3 * B *
     4 * C *

  <name> is optional and specifies the symbolic name associated with
   the data set containing the lines to overlay.  If <name> is not
   used the lines will be obtained from the current data set.

=ORDER                                                                 @
)F FUNCTION -
  The order subcommand can be used to sort data sets that have
  views defined.  See also HELP data for the USE subcommand, and
  Appendix D, which documents RQL (Relational Query Language).
)X SYNTAX -
   order by <name> ('ASC' × 'DESC'), ...
   example - order by partno desc,name,date
)O OPERANDS -
  <name> is a field name, the contents of which is to determine
   the ordering of records in the file.
))ASC - this keyword, which is the default, indicates that ascending
   sequence is requested for the previous field name.
))DESC - indicates that descending sequence is requested for the
   previous field name.

=OW                                                                    @
)F FUNCTION -
  Use the ow subcommand to change screen formats.  Some 3278-type
  cathode ray tube display terminals will display data with more than
  one screen size.  For example, common terminal sizes are 24X80
  (24 rows, 80 columns per row), 43X80, and 27X132.  At logon time,
  you are allowed to select two different screen sizes to be used
  during that TSO session.  The OW subcommand allows you to flip
  back and forth between these screen formats.  Additionally, the
  logical display lines can be defined different from the physical
  screen line size, e.g. 2 physical lines per logical line.
)X SYNTAX -
         ow <num>
  required - none
  NOTE - If no operands are specified on the ow subcommand, it will
  flip to the alternate physical screen size.  A subsequent ow
  subcommand will flip back to the original screen size, and so
  forth.
)O OPERANDS -
  <num> - A number indicating how the physical screen is to be
    divided into logical lines.  "ow 1" for example, says two
    physical lines will be used for each logical display line.
    A table of examples is shown below:

      ow  3 -- 4 physical lines per logical line
      ow  2 -- 3 physical lines per logical line
      ow  1 -- 2 physical lines per logical line
      ow  0 -- 1 physical line per logical line
      ow -1 -- 2 logical lines per physical line
      ow -2 -- 3 logical lines per physical line
      ow -3 -- 4 logical lines per physical line

=PARM                                                                  @
)F FUNCTION -
  The PARM subcommand is used to establish for a given symbolic value
  two different simultaneous replacement values: a string replacement
  value; and a numeric replacement value.  The numeric value will be
  the address in memory of the string replacement value.  For example,
  consider the subcommand "parm xyz string 'how now brown cow'." If the
  subcommand "symc xyz" is subsequently issued, the value "how now
  brown cow" will appear in the message area.  If the subcommand "calc
  xyz" is subsequently issued, the value "2801780" might appear, where
  2801780 is the address in memory of the string "how now brown cow."

  Such symbolic variables are used as arguments to the ENTRY function
  in expressions evaluated by the CALC subcommand. See Appendix I for
  more information on CALC and ENTRY.

)X SYNTAX -
    parm <name> <keyword> <value>
  required - <name> <keyword> <value>
  defaults - none
  alias - none

)O OPERANDS -
 <name> - Is the name of the symbolic variable for which replacement
   values are to be set.
 <keyword> - Determines how <value> will be processed, and is one
   of the following -

     HEX - <value> is treated as printable hex to be converted to
           internal hexadecimal to be used as replacement string.
     HIGH - <value> is a number indicating the number of bytes of
           x'FF' to be used as replacement string.
     LOW - <value> is a number indicating the number of bytes of
           x'00' to be used as replacement string.
     STRING - <value> is a string of text to be used as replacement
           string.
     SYMBOL - <value> is the name of a symbolic variable whose string
           replacement value is to the used as replacement string.

=PB                                                                    @
)F FUNCTION -
  The pb subcommand is used to move the display one page backward.
  With the descan panel, "pb" is equivalent to a "up 18" subcommand.
)X SYNTAX -
           pb <number>
  required - none
  defaults - 1
  alias - none
)O OPERANDS -
 <number> - Indicates the number of pages to move the display.

=PBSL                                                                  @
)F FUNCTION -
  Use the pbsl subcommand to shift text to the left in one or more
  lines.  This subcommand differs from the sl subcommand in that
  with the pbsl subcommand, the <scol> and <ecol> operands indicate
  the starting and ending columns of the data to be shifted, whereas
  with the sl subcommand, these operands indicate the columns in
  which data is to be shifted.
)X SYNTAX -
         <lsu> pbsl <amt> <spos> <epos> R
  required - <amt>
  defaults - none
)O OPERANDS -
  <amt>    - Number of positions to shift within each column.
  <spos>   - First position within column to be shifted.
             the default is position 1.
  <epos>   - Ending position of data to be shifted.
             the default is position 9999.
))R - If this keyword is not specified, data will be shifted left
      only so long as nonblank data is not lost.
=PBSR                                                                  @
)F FUNCTION -
  Use the pbsr subcommand to shift text to the right in one or more
  lines.  This subcommand differs from the sr subcommand in that
  with the pbsr subcommand, the <scol> and <ecol> operands indicate
  the starting and ending columns of the data to be shifted, whereas
  with the sr subcommand, these operands indicate the columns in
  which data is to be shifted.
)X SYNTAX -
         <lsu> pbsr <amt> <scol> <ecol> <R × <maxlen>>
  required - <amt>
  defaults - none
)O OPERANDS -
  <amt>    - Number of positions to shift.
  <scol>   - First position within column to be shifted.
             the default is 1.
  <ecol>   - Ending position within column to be shifted.
             the default is  9999.
  <maxlen> - Specifies the maximum position to which data is to
             be shifted right.  The shift operation will stop
             for a particular column when the first nonblank
             character is shifted into this position.  <maxlen>
             must be the sixth operand.
))R - If this keyword is not specified, data will be shifted right
      only so long as nonblank data is not lost.  This keyword is
      mutually exclusive with the <maxlen> operand.  If R is
      specified, it must be the sixth operand.

=PDFC                                                                  @
)F FUNCTION -
  The PDFC subcommand is used to convert output from the scrdef
  command to the format useable by $fullscr.
)X SYNTAX -
           PDFC
  required - none
  defaults - none
  alias - none
)O OPERANDS - none
=PDFD                                                                  @
)F FUNCTION -
  The PDFD subcommand is used to convert a panel definition from
  line-images to the format useable by $fullscr.  Before
  converting, the panel definition is displayed in full-screen mode.
  If you then hit enter without changing anything, the conversion
  will not be done, and you will be returned to edit mode. But if
  you have made changes to the definition in full-screen mode, when
  you hit enter the conversion will be done, the new panel
  definition will be saved, and editing will be ended.  If after
  making changes in full-screen mode, you would like to return to
  edit mode, with the panel definition stored in
  line-images, hit program function key 2 instead of the enter key.
)X SYNTAX -
           PDFD
  required - none
  defaults - none
  alias - none
)O OPERANDS - none

=PDFQ                                                                  @
)F FUNCTION -
  The PDFQ subcommand
  will create the necessary control blocks so that when any of the
  subcommands $DISPLAY, $FULLSCR, $STORE, and DATAENT refer to the
  specified panel name, the display will be formatted according to
  the line-images stored in the current data set.
)X SYNTAX -
           PDFQ <panel-name>
  required - none
  alias - none
)O OPERANDS -
 <panel-name> - The panel name to be used when constructing the
  control blocks.  If <panel-name> is not specified, the symbolic
  name associated with the current data set will be used.  If
  a set of control blocks already exists for the specified name,
  they will be replaced by the new set.

=PDFS                                                                  @
)F FUNCTION -
  The PDFS subcommand is used to convert a panel definition from
  80-column card-images to the format useable by $fullscr, and
  then save it in the specified data set.
)X SYNTAX -
           PDFS <dsname>
  required - none
  defaults - <dsname> defaults to the data set name originally
    specified on the ABE command, or the most recent PDFS or SAVE
    subcommand.
  alias - none
)O OPERANDS -
  <dsname> - Data set name to be assigned.  The same rules as
    apply to the SAVE subcommand apply here as well.

=PEEK                                                                  @
)F FUNCTION -
  The PEEK subcommand is used to look at main storage, e.g. the
  subcommand -

    PEEK 10.%+C4%+10

  will display the current cpu system identification (SYSID), which is
  located 16-bytes (hex 10) into the control block pointed to by the
  word 196-bytes (hex c4) into the CVT.

  Note that all memory references are done in 31-bit address mode,
  so memory above the 16-megabyte line can be addressed.  Appendix
  M of the ABE Manual has additional examples of using PEEK.

)X SYNTAX -
  peek <address> (<keyword> (<length> (<symbol>)))
  required - address
  defaults - <length> defaults to 4. <keyword> defaults to CHAR if
    <symbol> isn't specified, and NUM otherwise.
)O OPERANDS -
  <keyword> is either CHAR, NUM, or HEX:
    CHAR - indicates the string addressed is character.
    NUM - indicates the string addressed is integer binary.
    HEX - indicates the string addressed is to be converted to
    printable hex and printed in the message area.
  <address> specifies the address in memory where the data is to be
    obtained.  The specification is similar to that of the TSO TEST
    command, e.g. 45E10. indicates hexadecimal address 45E10, which is
    equivalent to decimal 286224.  "13r%+4%" asks for memory located
    at the address stored in the word +4 from the address stored in
    register 13. You can also specify an address as a decimal
    constant, e.g. specifying "286224" is equivalent to specifying
    "45e10.".
  <length> is the length of memory to reference.  The default is
    4-bytes.
  <symbol> If specified, <symbol> indicates the name of a symbolic
    variable whose replacement value is to be set to the referenced
    memory locations.

=PEL                                                                   @
)F FUNCTION -
  The PEL subcommand is used to set pels on or off in the special
  matrix known as BITMAP.  Appendix N contains a detailed description
  of BITMAP, but briefly, it is a very large area in memory above the
  16-megabyte line used to store rasterized scans of graphic images.
  These images can be displayed on an all-points-addressible display
  terminal such as the IBM3192G, and can also be printed on either
  the CITOH dot-matrix, or IBM3800 laser printers.  BITMAP may
  also be edited directly with the GED subcommand (see Appendix N).

)X SYNTAX -

  pel <pel> <xref> <yref>

  required - <pel> <xref> <yref>
  defaults - none
)O OPERANDS -
  <pel> If the BITMAP represents a black-and-white image, which it
    usually does, <pel> may be either 1 or 0 to turn the referenced
    pels on or off, respectively.
  <xref> Refers to one or more x coordinate values.  The syntax is
    identical to that for <yref> below.
  <yref> Refers to one or more y coordinate values, which will be
    truncated to integer.  Five different formats are permitted:

    1.  Constants, e.g "pel 1 2 3" says to turn on the pel at
        x-coordinate 2, y-coordinate 3.
    2.  Symbolic names, e.g. suppose the subcommand "calc a#47" had
        previously been issued.  Then the subcommand "pel 0 &a 1"
        would turn off the pel as x-coordinate 47, y-coordinate 1.
    3.  Asterisk (*), refers to all pels along that axis, e.g.
        "pel 1 1 *" would turn on all the pels along the left
        margin of BITMAP, and "pel 1 * 1" would turn on all the
        pels on the bottom margin.
    4.  APL-variable name, e.g. suppose the subcommand "apl x#I15"
        had previously been issued.  Then the subcommand
        "pel 1 x 5" would turn on all the pels with x-coordinates
        in the range 1<=x<=15, and y-coordinate 5.  Note that if
        the APL-variable has a higher rank than 1, its values will
        be ravelled.
    5.  RQL-variable name, e.g. suppose the following subcommands
        were executed:

        define xxx
        a xxx use ×x     ×y     ×
        a xxx bl 15
        a xxx update set x=seq,y=x**2
        pel 1 xxx.x xxx.y

        Then pels at coordinates (1,1),(2,4),(3,9),...,(15,225)
        would be turned on.

=PF                                                                    @
)F FUNCTION -
  The pf subcommand is used to move the display one page forward.
  With the descan panel, "pf" is equivalent to a "down 18"
  subcommand.
)X SYNTAX -
           pf <number>
  required - none
  defaults - 1
  alias - none
)O OPERANDS -
 <number> - Indicates the number of pages to move the display.

=PFK                                                                   @
)F FUNCTION -
  The pfk subcommand is used to execute a subcommand list
  associated with a program function key.  The subcommand list
  must be a data set currently being edited, and it must have
  a name associated with it (assigned by the define or name
  subcommands) of the form "pfknn", where nn is a number from
  0 to 99, except 1, 13, or 24.
 +Note that the pfk subcommand can be implied by hitting one
  of the program function keys.  If program function key 2 is
  hit, this implies the subcommand "pfk 2", which will be
  applied to the top data set on the display.
 +Note that some of the program function keys have default
  subcommands which are implied if a data set with a name
  of the form "pfknn" cannot be found.  In the case of pfk 1,
  the default is the "last" subcommand, and cannot be
  overridden by defining a data set named "pfk01".  All other
  program function key defaults can be overridden.  Following
  is a list of the defaults:
     pfk
      1 --- last
      2 --- fill 50
      3 --- end
      4 --- abe {&P1}   *** see note below
      5 --- find
      6 --- c
      7 --- pb
      8 --- pf
      9 --- top
     10 --- col l
     11 --- col r
     12 --- bottom
     13 ---
     14 --- 1m 2m del
     15 --- 4m v
     16 --- 1m 2m copy 3m
     17 --- 1m 2m move 3m
     18 --- ts 0m
     19 --- halfb
     20 --- halff
     21 --- lines
     22 --- hex
     23 --- char
     24 --- altcase

 *** Default processing for PFK 4 is handled somewhat differently
     than the other function keys.  PFK 4 is useful when you are
     editing a member of a partitioned data set, and want to edit
     another member of that same PDS.  Before pressing PFK 4, on the
     command line enter a space followed by the member name to be
     edited (referred to below as <member>), and optionally followed
     by other parameter values (referred to below as <additional
     parameters>. This information will be transformed into a
     subcommand of the form -

       abe {<member>} <additional parameters>

)X SYNTAX -
           pfk <number> <operands>
  required - <number>
  defaults - none
  alias - none
)O OPERANDS -
 <number> - Indicates the number nn in the name "pfknn".
   the command will search for a data set currently being edited
   which has a name of that form associated with it (assigned via
   either the name or the define subcommands).  This data set must
   contain a list of valid abe  subcommands.  If found, the list of
   subcommands will be executed.  If not found, a default (see
   above) subcommand is executed.
  +Note that <number> cannot be 1 or 24.  These are reserved
   for the LAST and ALTCASE subcommands respectively.
 <operands> - These can be a mixture of positional and keyword
   operands which will be used to establish the replacement values
   for corresponding symbolic variables which may be referenced
   in the list of subcommands defined in the "pfknn" data set.
   For example, suppose a data set is defined with the name
   "pfk05" containing one subcommand as follows:

       nl first=&p1 third=&p3 nonpositional=&key

   Now suppose I enter "pfk 5 'how now' key(aaa) def" on the command
   line and press ENTER.  The result will be the following line
   added to the current data set:

       first=how now third=def nonpositional=aaa

   Each operand in the <operands> section of the pfk subcommand
   can be positional or keyword in form.  An operand is always
   considered to be positional if it is surrounded in quotes,
   e.g. 'how now'.  If it is not in quotes, it is considered to
   be positional if it is not in the form "keyword(value)" (note:
   if an operand is to contain a left parenthesis and you want
   it to be considered positional, you should always use surrounding
   quotes, e.g. 'how(now').

   If an operand is positional, its entire value will be assigned
   as the replacement value for a symbolic variable with a name
   of the form &Pn, where n is 1 for the first operand in the
   <operands> section, 2 for the second operand, etc.  If an
   operand is of keyword form, that is "keyword(value)", then
   "value" will be assigned as the replacement value for a symbolic
   variable with name "keyword".

   If a positional operand is surrounded in quotes, the quotes are
   removed in the replacement value assigned to the corresponding
   &Pn variable.  For each positional parameter, a corresponding
   symbolic variable with a name in the form &Qn, n being the number
   of the positional parameter, is defined with the replacement
   values 0 or 1, depending on whether the corresponding positional
   parameter was surrounded in quotes or not.

   Now suppose I enter " aaa bbb ccc key()" on the command line
   and press pfk 5.  The result will be the following line added to
   the current data set:

       first=how now third=def nonpositional=aaa

   Notice that the text entered on the command line was preceded by
   a blank (" aaa").  If the blank hadn't been there, ABE
   would have tried to recognize the text in the command line as a
   subcommand instead of as operands for the PFK subcommand.

=PGM                                                                   @
)F FUNCTION -
  The pgm subcommand is used to invoke user-written load modules
  as ABE subcommands.  Appendix A to this manual gives a detailed
  description of how to write such a program.
)X SYNTAX -
           pgm <module> <operands>
        or
           pgm <dsname>(<module>) <operands>
  required - none
  alias - none
)O OPERANDS -
 <module> - This is the name of the program to be invoked.  If
   <module> is specified without <dsname>, the program is
   assumed in a library in the link list or in a step library.
 <dsname> - If <module> is not in the link list or a step library,
   you can specify the library name (using standard TSO nameing
   conventions) where PGM is to look for the module.
 <operands> - these are operands to be passed to the invoked
   module (see Appendix A).

=PLOT                                                                  @
)F FUNCTION -
  The plot subcommand is used to plot values produced by an
  expression.
)X SYNTAX -
  <lsu> plot <expression>
  required - <expression>
  alias - none
)O OPERANDS -
 <expression> - This can be any expression acceptable to the CALC
   subcommand, e.g. X**2.  For each column in the range, the value
   of variable X will first be set, based on the relative line
   position (e.g. x=0 for first line, x=1 for second line, etc.).
   Variable Y will be set to 0 for the first column in the line,
   1 for the second, etc.  The expression will be evaluated,
   setting variable Z to the result.  If the result is non-zero
   the current column will be set to '1'.

=POOL                                                                  @
)F FUNCTION -
  The pool subcommand is used to dump a pool of symbolic variables
  into the current dataset.  Information is included so a balanced
  binary tree could be reconstructed from the dumped pool.  Records
  of the following format will be constructed in the current dataset:

    RECORD
  POSITIONS   DESCRIPTION
    1-8       name of variable
   10-17      name of left child
   19-26      name of right child
   28-        replacement value of the named variable.

  For example, the following set of subcommands -

    setl a 123 '' '' mypool
    setl b 456 '' '' mypool
    setl c 789 '' '' mypool
    setl d 012 '' '' mypool
    setl e 345 '' '' mypool
    pool mypool

  will result in the following records being added to the current
  dataset:

    B        A        D        456
    A        .        .        123
    D        C        E        012
    C        .        .        789
    E        .        .        345

)X SYNTAX -
  pool <pool>
  required - <pool>
  alias - none
)O OPERANDS -
 <pool> - Name of the pool to be dumped.

=PROBLEMS                                                              @
)F FUNCTION
  There is no subcommand called "problems".  This is an
  artifice to allow easy reference to the list of outstanding
  problems and future enhancements.
)X SYNTAX
  Each problem is reported as a separate keyword.
)O OPERANDS - The list is broken up as follows:

  WISHLIST - future enhancements.
  EDIT     - problems associated with editing data.

))WISHLIST - future enhancements.
  WISH01 - Add an operand to the SAVE subcommand to allow user
    data to be specified for storing in the directory entry for
    a member of a partitioned data set.
  WISH02 - Add subcommand to sound the beeper on the terminal.
  WISH03 - Add option to RELJOIN so that all lines appearing in
    dataset 1 will appear in dataset 3.
  WISH04 - Add START() keyword to specify which input field to start
    with on $DISPLAY and $STORE.  This would allow some input fields
    for control.
  WISH05 - Allow the user to define a default command delimiter so
    he doesn't have to start the command line with the delimiter
    character.
  WISH06 - Change the COL L/R subcommands to go only halfway.
  WISH07 - Add option to suppress the "SAVED" message from the
    ABE SAVE subcommand.
  WISH09 - Make &SYSACCT available even if CLIST keyword is
    specified.
  WISH10 - Add subcommand to permit getting the cursor location of
    a given panel field.  This could be used for comparison to
    &CURSOR.
  WISH11 - Modify symbolic replacement so that if the symbolic
    variable isn't located, search the list of currently edited
    dataset names for a match, and if found extract data from
    the current record.
  WISH12 - Create a MEMORY subcommand to determine how much
    memory is currently free.
  WISH13 - Create a DSCB subcommand to obtain the format 1 DSCB
    for a dataset in a virtual dataset.
  WISH14 - Create a JFCB subcommand to obtain the JFCB for a
    specified ddname in a virtual dataset.

))EDIT - problems with editing data.
  ABE001 - Saving into a pds which is full causes a d37 or e37
    abend which returns you to ready mode.  Plans are to cause
    abe  to trap this abend, and to optionally compress before
    retrying the save.
  ABE002 - Nonumbered data sets with varying length records
    may contain records with a length of zero.  PL/I will
    read these records, but will not write them.  The problem
    has been bypassed by having ABE check the length of each
    record.  If the length is zero, the record is replaced with
    one containing one blank.
  ABE003 - When you save to a new data set, ABE  does not
    calculate the amount of space needed to contain the data set.
    Consequently, you may run out of space on a large data set.
  ABE005 - ITEIN is not indenting begin blocks preceded by an ON
    specification (e.g. ON ATTENTION BEGIN;).  The source is still
    valid; it just isn't inabe ed to iabe ify the begin block.
  ABE011 - ITEIN is not indenting properly for text of the form
    'IF ...'xyz' then ...'.  The source is still valid; it just
    leaves an extraneous blank line in the source and doesn't
    position the THEN properly.
  ABE012 - Change ABE to check to see if a user is saving a
    data set with a larger record length into a data set with
    smaller record length.  Warn him that data may be lost due
    to truncation.
  ABE014 - If a clist abnormally terminates, the symbolic substitution
    subroutines are not getting properly reset.  A subsequent
    "symc sysuid" subcommand will obtain a null string, and abe
    subcommands no longer work properly because abe can't find the
    right dsname prefix.
  ABE015 - When running ABE in batch, the following type JCL will
    cause an abend 013-C0 for file sysin:

    // exec pgm=abeb
    //in  dd *
    $cmd abe '' infi(sysin) inp(/list/end)
    //out dd sysout=*,dcb=(lrecl=80,blksize=80,recfm=fa)
    //sysin dd *
    How now, brown cow?

    The problem only occurs for file sysin, and the above jcl runs
    ok when it is changed as follows:

    // exec pgm=abeb
    //in  dd *
    $cmd abe '' infi(input) inp(/list/end)
    //out dd sysout=*,dcb=(lrecl=80,blksize=80,recfm=fa)
    //input dd *
    How now, brown cow?
  ABE016 - "@& co )" causes loop.
  ABE017 - "PFK" with no operands causes ABEND 4000.
  ABE018 - SNO/SNOT commands aren't freeing up control blocks. After
   repeated invocations, an abend will result, often at statement
   200340 in ARG within SNOFUN.

=PRT                                                                   @
)F FUNCTION -
  The prt subcommand is designed for use when editing the
  msgclass sysout for a batch job.  It is used to print
  a copy of the currently edited data set on sysout.
)X SYNTAX -
         prt sysout() cc() dest() nocc hold seq
  required - none
  defaults - sysout(a) dest(local)
             cc defaults to either A, M, or none, depending on the
             record format of the dataset being edited.  If the dataset
             is virtual, the default is no carriage control.
)O OPERANDS -
))SYSOUT() - Indicates the sysout class to be used.  The default
    is sysout(a).
))CC() - Indicates the type of carriage control supplied.  Either cc(a)
    for asa carriage control, or cc(m), for machine carriage control,
    can be specified.
))NOCC - Indicates that no carriage control has been supplied.
))HOLD - Indicate that the output is to be held on the
    sysout queue.  Specifying this keyword makes it possible
    to later retrieve the sysout at your terminal via the
    output command.
))DEST() - Indicates jes remote station at which the sysout
    is to be printed.  The default if dest(local).
))SEQ - Indicates that sequence numbers are to be printed at
    the left of each line.

=PURGE                                                                 @
)F FUNCTION -
  The purge subcommand is designed for use when editing the
  msgclass sysout for a batch job.  It will end editing of
  the msgclass sysout data set, and will issue the tso delete
  command for the data set.
)X SYNTAX -
         purge
  required - none
  defaults - none
)O OPERANDS - NONE

=R                                                                     @
)F FUNCTION -
  The r subcommand can be used to cause a subcommand entered
  on this command line to be executed after symbolic replacement
  has been done.  For example, "r nl time=&systime uid=&sysuid"
  would cause the following line to be added to the data set:

       time=15:26:43 uid=X75826

)X SYNTAX -
         r <subcommand>
  required - <subcommand>
  defaults - none
)O OPERANDS -
 <subcommand> - is the abe  subcommand to be applied.

=RANDOM                                                                @
)F FUNCTION -
  RANDOM allows you to take a random sample from a list of
  numbers.  WARNING - THE FIRST THING RANDOM WILL DO WILL BE A
  DEL SUBCOMMAND.  For example, entering "random 20 5 0"
  would result in the current data set containing the following,
  regardless of what the data set contained before the random
  command was entered:

                 1         2
        12345678901234567890123456789

      1       11
      2        3
      3        8
      4        7
      5       14

)X SYNTAX -
      random <range> <count> <seed> internal
  required - none
  defaults - <range>=0 <count>=0 <seed>=0
)O OPERANDS -

  <range> - is the range of numbers from which the random sample is
    to be picked, e.g. "random 20 5 0" says pick 5 numbers from
    the range 1 to 20.
  <count> - is the count of numbers to be in the sample (see
    example above).
  <seed> - is the seed upon which random numbers are to be
    generated.  Actually, the numbers selected aren't "random", in
    the truest sense of the word.  If you issue the subcommand
    "random 20 5 1" twice in a row, the same 5 numbers will be
    picked.  However, the distribution of the numbers selected will
    be consistent with that of a random selection.  If you issue
    "random 20 5 -1", however, the numbers will be in a certain
    sense random in that the initial seed used will be determined
    by taking the number of milliseconds from the current time of
    day and dividing by 1000.
))INTERNAL - Specifying this keyword will cause the random numbers
    to be generated as a series of fixed bin(31,0) numbers
    concatenated to form a single record in the data set, e.g.
    "random 20 5 0 internal" produces in hex a record as follows:

      0000000B0000000300000008000000070000000E


=REFRESH                                                               @
)F FUNCTION -
  The refresh subcommand is used to restore the edited data set to
  its condition just after the last save subcommand.
)X SYNTAX -
            refresh <line> <count>
)O OPERANDS - NONE
 <line> - Indicates the first line of the data set to be read
   in for editing.  "refresh 1000", for example, indicates that
   the first 999 lines are to be skipped, and the rest are to
   be read in for editing.  If a save subcommand is subsequently
   issued, the first 999 lines will be lost.
 <count> - Indicates the maximum number of the lines to be read
   in for editing.  "refresh 1 500", for example, indicates that
   a maximum of the first 500 lines are to be read in for
   editing.  If a save subcommand is subsequently issued, any
   of the original lines beyond the 500th will be lost.

=RELJOIN=RELJ                                                          @
)F FUNCTION -
  RELJOIN performs the type of join operation normally associated
  with relational data base systems.  The logic is as follows:
    1.  Take the first line from <table-a> and search <table-b> to
        find a record that matches on the specified columns.
    2.  When a match is found, put the two lines together, forming
        a new line in <table-c>.  The new line is formed by
        overlaying the line from <table-a> with non-blank columns
        from <table-b>.
    3.  Continue until <table-b> is exhausted.
    4.  Take the next line from <table-a> and search <table-b> for
        a match again.
    5.  Repeat until <table-a> is also exhausted.  <table-b> has now
        been searched as many times as there are lines in <table-a>.
)X SYNTAX -
  reljoin <table-a> <table-b> <table-c> <offset> <length>
  ALIAS - relj
  REQUIRED OPERANDS - <table-a> <table-b> <table-c> <offset> <length>
)O OPERANDS - NONE
 <table-a> - symbolic name associated with the data set to be
   designated as <table-a> in the algorithm described under
   "function" for this subcommand.  The symbolic name may have
   been assigned to the data set by the NAME keyword of the ABE
   or FIND subcommands, or it may have been assigned via the
   NAME subcommand.
 <table-b> - symbolic name associated with the data set to be
   designated as <table-b> in the algorithm described above.
 <table-c> - symbolic name associated with the data set to be
   designated as <table-c> in the algorithm described above.
   If a data set with the specified symbolic name is not found,
   a new one will be defined.  If one is found, the new records
   will be added following the first line displayed for the data
   set (current line).
 <offset> - Offset, relative 1, where the matching field starts.
 <length> - Length of the field where matching occurs.

=RENUM=REN                                                             @
)F FUNCTION -
  Renum renumbers the records in virtual storage.  Note that this
  has no effect on an unnumbered data set when it is saved; the
  sequence numbers will still be stripped off before the save is
  done.  To cause an unnumbered data set to be saved with
  sequence numbers, use the num subcommand.
)X SYNTAX -
         renum   <new-linenum>  <increm>
  required - none
  defaults - Both <new-linenum> and <increm> default to 10, or to
             the last <new-linenum> and <increm> entered on a
             previous renum subcommand.

  alias    - ren
)O OPERANDS -
 <new-linenum>
    The significance of this operand depends on whether the
    first position is a plus (+) or minus (-) sign.  If no sign
    appears, this is the number to be assigned to the first line
    in the data set.  If a sign is present, it indicates that
    the number supplied is to be added to each sequence number
    in the data set.  In this case, <increm> need not be supplied.
 <increm>
    Specifies the increment to be used in renumbering.

=RESEQ                                                                 @
)F FUNCTION -
  Use the reseq subcommand to reseq the data set according
  to line numbers which are stored as data in the records.
  Note that no validity check is done, so if the data field
  you specify does not contain proper sequence numbers in
  ascending collating sequence, the data set will end up
  out of sequence.
)X SYNTAX -
           reseq <offset> <length>
  required - none
)O OPERANDS -
  <offset> is the column in which the line number data
    starts.  If "seq 1" were specified, for example,
    line number data should start in columns 1 thru 8.
    If "seq 0" is specified,  the line numbers are still
    obtained beginning in column 1, but all other data in each
    record is shifted left afterwards.  If <offset> is not
    specified, the default is the last 8 columns of the
    maximum record length.
  <length> is the length of data which is to be used as
    lines numbers.  The maximum length is 8.  If <length>
    is not specified, the default is 8.

=RESET                                                                 @
)F FUNCTION -
  Reset marks lines for display which were previously not
  displayed by using the suppress command.
)X SYNTAX -
         <lsu> reset  s
          or
         <lsu> reset  <cnt> f
                              l
  required - none
  defaults - none
  alias    - none
)O OPERANDS -
 +Note that the RESET subcommand can also be entered as a line
  command in the line number field of a line on which the
  message "------LINES SUPPRESSED =  n" appears.  For examples,

      2f50 ------LINES SUPPRESSED =   10

  would cause the first two lines in that group of suppressed
  lines to be reset, and -

      l050 ------LINES SUPPRESSED =   10

  would cause the last line an that group of suppressed lines to
  be reset.

))F - Specifies that the first <cnt> lines in a group of suppressed
  lines are to be reset.
))L - Specifies that the last <cnt> lines in a group of suppressed
  lines are to be reset.
))S - Specifies that only the leftmost suppressed lines in the
  group are to be reset.

=RLIM                                                                  @
)F FUNCTION -
 RLIM may be used to control the abnormal termination of stacked
 subcommands and RUNs in case of errors.  Each subcommand sets a
 return code indicating its success or failure.  In the case of
 in invalid oeprand, for example, the return code will be 8 or
 greater.  In the case of the FIND subcommand,
 if the specified text isn't found, the return code will be set to
 4, and if the text is found, return code will be 0.
   When a subcommand terminates, ABE will compare the return code
 to the value most recently specified as the operand to the RLIM
 subcommand.  If the return code is greater, all currently stacked
 subcommands will be flushed, and all currently executing ARUNs
 will be terminated.
   The default RLIM value at the start is 99999999.
)X SYNTAX -
    RLIM <limit>
  required - <limit>
  defaults - none
  alias    - none
)O OPERANDS -
 <limit> - is the new return code limit.

=RUN=GO=G                                                              @
)F FUNCTION -
  Use the RUN subcommand to execute a list a ABE subcommands.
 +Note that Appendix F to this manual documents the special language
  which may be used within subcommand lists executed via the RUN
  subcommand.
 +Note that a single line in a currently edited dataset can be
  executed via the RUN subcommand simply by entering a "g" in the
  line number field for that line.  A range of lines can also be
  executed in a similar fashion by entering "gg" in the first and
  last lines in the range to be executed.
)X SYNTAX -
         <lsu> run <name>  <operands>
  required - <name>
  aliases - go,g
)O OPERANDS -
 ****** NOTE ****** The only values recognized from the <lsu> are
    the starting and ending line values, <l1> and <l2>.
    Additionally, <l1> and <l2> are derived from the current
    dataset, and not the one specified by <name>, e.g. t+3 will
    reference the line number of the fourth line in the current
    data set.
 <name> - This is the name, 8 characters or less, associated with a
    data set currently being edited.  The name was previously assigned
    using either the define, or the name subcommand.  The data set
    associated with the name must contain a valid list of ABE
    subcommands.  if no name is supplied, or if * is specified, the
    current data set will be used.
 <operands> This is a series of parameters specified by the user.
    The format for <operands> is the same for both the RUN and PFK
    subcommands, and if you check the help data for the PFK
    subcommand, you will see some examples of their use.
    NOTE:  The replacement values for positional operands &p1 thru
    &p16 are retained and restored whenever a RUN subcommand
    is nested, e.g. given the following two members in the
    PDS allocated with file name SYSRUN -

    TESTRUN1:

        $WRITE TESTRUN1 P1=&P1
        %%TESTRUN2 2
        $WRITE TESTRUN1 P1=&P1

    TESTRUN2:

        $WRITE TESTRUN2 P1=&P1
        CALC P1#3
        $WRITE TESTRUN2 P1=&P1

    then if the following subcommand were issued -

    %%TESTRUN1 1

    the resulting display would be -

    TESTRUN1 P1=1
    TESTRUN2 P1=2
    TESTRUN2 P1=00003
    TESTRUN1 P1=1

 NOTE: Symbolic replacement is accomplished on each line before it
 is executed as a subcommand.  Briefly,  variable names beginning
 with the ampersand symbol (&) are replaced with their previously
 assigned replacement value.  See help data for the SYMREP
 subcommand for more details on symbolic replacement. subcommand to
 perform symbolic replacement before each subcommand is executed,
 the first keyword specified should be the "NOSYM" keyword. The
 "NOSYM" keyword is especially useful when lsp subcommands are to be
 executed;  Since the "template" portion of lsp subcommands contain
 ampersand (&) symbols,

=SAS                                                                   @
)F FUNCTION -
 The SAS subcommand provides an interface to the %SAS clist as it is
 defined at Kimberly-Clark (the SAS clist at KC has been modified
 from the way it comes from SAS institute).  Note that a detailed
 description of how this subcommand works can be found in appendix D
 to the ABE manual.
)X SYNTAX -
  SAS <keywords>
  required - none
)O OPERANDS -
 <keywords> - this can be any of the the keywords normally specified
  with the %SAS clist as it is invoked from TSO READY mode, except
  the LOG and OUTPUT keywords.  See also appendix D.

=SAVE=S=SF=SB=SE=SX=ST=ES                                              @
)F FUNCTION -
  Save is used to retain the data set being edited. The alias ST
  must be used if you want to save a data set which has been
  processed via the TRANSLAT subcommand. IMPORTANT NOTE:  If a DBD
  is defined for the data set, SAVE may issue a "use out" subcommand
  before saveing the data set. This will be done automatically if
  the low-level qualifier for the data set is DB (e.g.
  X75826.INVENTRY.DB).  Otherwise, if you haven't specified the
  NOPROMPT keyword, SAVE will prompt you at the terminal to see if
  you want the "use out" subcommand to be issued. See also the USE
  subcommand.
)X SYNTAX -
         save   <dsname> noprompt temp db2 sas in(<dbname.tsname>)
  required - none
  defaults - <dsname> defaults to the first data set name
             specified with the abe  command unless either the
             output keyword operand is specified, in which case
             that data set is used, or the save command was
             previously issued specifying a dsname, in which case
             that data set is used.
  alias    - sf, sb, se, es, sx, st
  NOTE     - The alias' se and es are
             equivalent to entering a save subcommand followed
             by the end subcommand.
  NOTE     - The alias sx is equivalent to entering a save
             subcommand followed by the x subcommand.  The result
             is that after the save has successfully completed,
             the terminal is placed in x mode (see the x
             subcommand).
)O OPERANDS -
  <dsname> - Name to be assigned the retained copy.  If <dsname>:
        1.   Specifies an existing partitioned data set (pds),
             without specifying member name, member name
             <tempname> is used.  A new member is created if named
             member does not exist.
        2.   Specifies an existing sequential data set or pds
             member different from that specified with the edit
             command, the data set will be reused, and will
             become the default for the next save subcommand.
        3.   Specifies a data set which does not already
             exist, a new sequential data set will be allocated.
        4.   Specifies only a parenthesized member name not
             preceded by a data set name, the data will be saved in
             the specified member of the default data set currently
             associated with the data.  The dsname for this data
             set is always printed at the right end of the command
             line on the display.
   If the fully qualified data set name is specified, it must be
   enclosed in quotes (e.g. 'sys2.proclib(au109209)').
   If the data set name is not entered within quotes, the userid
   is always appended to the left of the name.  If the rightmost
   qualifier is not entered by the user, one will be appended for
   him if the output data set already exists.  If more than one
   data set exists with the specified name, the user will be
   prompted to select the appropriate qualifier.  If no data sets
   exist with the specified name, one will be created.
))DB2 -
   Can be used only if you are running under DSN command (see
   Appendix K).  The Keyword DB2 tells ABE to save the data as a
   DB2 table.
))IN(<dbname.tsname>) -
   Implies the DB2 keyword.  Specifies the database name (dbname)
   and optionally the table space name (tsname) in DB2 where the
   data is to be stored.
))NOPROMPT - specify this keyword if you don't want to be prompted
   during the SAVE operation.  If you don't specify NOPROMPT, you
   may be prompted in either of 2 cases: (1) if the specified
   dsname does not currently exist, you will be prompted to confirm
   that a new data set is to be created; (2) if the specified
   dsname is a partitioned data set, and the specified member
   already exists, you will be prompted to confirm that it is
   indeed to be replaced.
))TEMP - specify this keyword if you don't want the default data set
   to change.  The default data set is where a SAVE subcommand which
   does not specify a dsname will save the data. The dsname for the
   default data set prints at the right end of the command line.
   For example, you are editing JOBCARD.CNTL, and you want to save a
   copy in TEST.DATA without changing the default data set.  To do
   this, you would enter "s test.data temp".
))SAS - Tells ABE that the data is to be stored in a SAS library.
   See also appendix K.

=SCAN=SC                                                               @
)F FUNCTION -
  Use the scan subcommand to change from insert mode to scan mode.
)X SYNTAX -
           scan <number>
  required - none
  alias    - sc
)O OPERANDS -
 <number> - The line number of the first line to be displayed
   on the panel may optionally be specified.  If you don't
   specify a number, the last line entered in insert mode will be
   the first line of the display.

=SCANPDS                                                               @
)F FUNCTION -
  Use scanpds to apply certain ABE subcommands to all records in a
  partitioned dataset as though these records were a part of the same
  sequential dataset.  Scanpds is useful for finding all occurrences
  of a particular character string or pattern in a partitioned dataset.
)X SYNTAX -
  scanpds <dsnspec) <subcommands> <optional>

  required - <dsnspec> <subcommands>

  example - scanpds cntl 'f job word all name(jobs)'
    This sample scanpds subcommand would find all occurrences of the
    word "job" in the partitioned dataset named "cntl."
)O OPERANDS -
 <dsnspec> - <dsnspec> will be substituted for &DSNSPEC in the
   subcommand "abe &DSNSPEC fam(fampdsr) bpam support".  At the end
   of processing by scanpds, and "end nosave" subcommand will be
   issued for the partitioned dataset edited with this abe
   subcommand.
 <optional> - may be anything to be added to the ABE subcommand
   issued to edit the specified dataset, e.g. "scanpds 'sys1.proclib'
   'f proc all name(xxx)' vol(gss000)".

 <subcommands> - is a list of one or more subcommands (delimited by
   e.g. /) to be applied to the partitioned dataset.  These
   subcommands should be ones that process data in a read-only
   fashion, e.g. the find subcommand with the 'all' keyword, and the
   sno subcommand with the 'find' keyword.

=SELECT                                                                @
)F FUNCTION -
  The SELECT subcommand is part of the Relational Query Language
  (RQL) incorporated into ABE. SELECT in its most basic use is
  similar in function to the DREM subcommand in that it selects data
  records from the current data set and copies them to another data
  set.  The big difference is that the syntax of SELECT allows
  reference to fields within records based on a database definition
  done using the USE subcommand. The description of this subcommand
  here will be brief.  To obtain more extensive information on
  SELECT and RQL in general, see Appendix D.
 )X SYNTAX -
           see appendix D
)O OPERANDS -
 see appendix D

=SEQ                                                                   @
)F FUNCTION -
  Use the seq subcommand to make the current line numbers available
  as part of the data for editing.  You might find this useful if
  you want to use the sort subcommand to temporarily change the
  sequence of the data set.  You can subsequently sort on the line
  number field added by the seq subcommand to restore the original
  sequence.
)X SYNTAX -
           seq <offset>
  required - none
)O OPERANDS -
  <offset> is the column in which the editable line numbers
    are to start.  If "seq 1" were specified, for example, line
    numbers will overlay data in columns 1 thru 8. If "seq 0" is
    specified,  the line numbers are still stored in columns 1 thru
    8, but all other data in each record is shifted right first.  If
    <offset> is not specified, the default is the last 8 columns of
    the maximum record length.

=SET                                                                   @
)F FUNCTION -
  Use the set subcommand to replace data in a line with new data.
)X SYNTAX -
           set <lineno> <newdata>
  required - <lineno>
)O OPERANDS -
  <lineno> is the line number in which data is to be replaced.
    if the line doesn't currently exist, a new one will be created.
    If an asterisk ('*') is specified, data in the top line on the
    display will be replaced.  If "new" is specified instead of a
    line number or "*", a line will be added at the end of the data
    set.
  <newdata> is the new data to be placed in the specified line.
    If the data contains quotes, commas, or other delimiters, it
    should be surrounded in quotes (e.g. set 23 'abc def').

=SETD                                                                  @
)F FUNCTION -
 The setd subcommand is used to set the replacement value for a
 symbolic variable to data from a line in one of the data sets
 currently being edited.
)X SYNTAX -
  setd <variable> <line> <off> <len> <name>
   required - <lineno>
   defaults - <line>=*
              <off>=1
              <len>=offset to last non-blank in record
)O OPERANDS -
 <variable> - is the name of the symbolic variable whose
   replacement value is to be set.  Note that the ampersand should
   not precede the name.
 <line> - is the line number of the line from which data is to be
   extracted. If * is specified, the current line in the data set
   will be used.
 <off> - is the offset, relative 1, at which data in the specified
   line is to be selected.
 <len> - is the length of data to be selected.
 <name> - is optional. If specified, it indicates the symbolic
   name (assigned perhaps with the NAME subcommand) associated with
   the data set from which the line is to be selected.

=SETHEX                                                                @
)F FUNCTION -
  The SETHEX subcommand is used to set the replacement value for a
  symbolic variable to a string represented hexadecimally.
)X SYNTAX -
  sethex <variable> <hex-string>
)O OPERANDS -
 <variable> - is the name of the symbolic variable (less ampersand)
  for which the replacement value is to be set.
 <hex-string> - is the new replacement value, specified as a
   hexadecimal string, e.g. c1c2c3, which is equivalent to ABC.

=SETL                                                                  @
)F FUNCTION -
  The SETL subcommand is used to set the replacement value for a
  symbolic variable.  Note that the ampersand should not precede the
  variable name in the <variable> specification.
)X SYNTAX -
  setl <variable> <text> <off> <len> <pool>
)O OPERANDS -
 <variable> - is the name of the symbolic variable (less ampersand)
   for which the replacement value is to be set.
 <text> - is the new replacement value.  Note that if <text> contains
   blanks, it must be a quoted string (surrounded in single
   apostrophes) and any contained apostrophes must be doubled, e.g.
   'don''t you know?'.  See also the SETN subcommand.
 <off> is optional, unless <len> is to be specified.  The default is
   1.  This is the offset within <text> where the replacement value
   is to be taken from.
 <length> is optional.  The default is the length of <text> minus
   <off> plus 1.  This is the length of the string to be taken from
   <text> as the new replacement value.
 <pool> - name of symbolic variable pool.  If none specified, the
   global pool will be used.

=SETLZF                                                                @
)F FUNCTION -
  The SETLZF subcommand is used to set the replacement value for a
  symbolic variable so that, if possible, it will be exactly n
  characters long, with zeros filled in on the left.  For example,
  if the replacement value for variable &ABC is 23, then the
  subcommand "setlzf abc 6" will result in the replacement value
  being changed to 000023.
)X SYNTAX -
  setlzf <variable> <n>
)O OPERANDS -
 <variable> - is the name of the symbolic variable (less ampersand)
   for which the replacement value is to be set.
 <n> - is the number of characters the replacement value is to contain,
   left-zero filled.

=SETN                                                                  @
)F FUNCTION -
  The SETN subcommand is used to set the replacement value for a
  symbolic variable.  It differs from SETL in that <text> does not have
  to be enclosed in quotes if it contains blanks or other special
  characters. Instead <text> is considered to begin with the second
  character after the variable name, e.g. "setn xxx    abc" produces
  the replacement value "   abc" for symbolix variable xxx.
)X SYNTAX -
  setn <variable> <text>
)O OPERANDS -
 <variable> - is the name of the symbolic variable (less ampersand)
   for which the replacement value is to be set.
 <text> - is the new replacement value.

=SETRC                                                                 @
)F FUNCTION -
  The SETRC subcommand is used to set the return code returned to
  the operating system when ABE terminates.  One use of this
  might be to set the return code to 0 or 4 depending on a
  particular character string exists in a data set or not.
  For example, the following sequence might appear in a clist:

    1 ABE DATASET CLIST HARDCOPY
    2 FIND GRUNDIE WORD FIRST
    3 R SETRC &&LASTCC
    4 WHEN SYSRC(EQ 4) END
      .
      .
      .

  The above clist will end at line 4 if dataset DATASET doesn't
  contain the word GRUNDIE.

)X SYNTAX -
  setrc <rc>
)O OPERANDS -
  <rc> - this is the numeric value that the system return code is
  to be set to

=SETSEQ                                                                @
)F FUNCTION -
  Use the setseq command to change the line number of a line, or
  to move the line to a new location.  For example, if lines
  numbered 10, 20, and 30 exist, and you enter the subcommand
  "setseq 10 15", line number 10 would be changed to 15.  If you
  entered the subcommand "setseq 10 25", line number 10 would be
  change to 25, and the line would be moved between lines 20 and
  30.
 +Note that if the character "s" preceded by a number is entered
  in a line number field on the display, that line number will be
  changed to the new number, and the line will be moved if
  necessary.
)X SYNTAX -
           setseq <old-number> <new-number>
  required - <old-number> <new-number>
)O OPERANDS -
  <old-number> line number to be changed.
  <new-number> new line number.
    line numbers will overlay data in columns 1 thru 8.

=SHOW                                                                  @
)F FUNCTION -
  Use the show subcommand to eliminate a data set from the
  display, giving the display lines it owns to another data
  set which is currently being edited, but which does not
  currently own any lines on the display.
)X SYNTAX -
           show <name>
  required - <name>
)O OPERANDS -
  <name> - This is the symbolic name (assigned bia one of the
    subcommands abe , define, or name) associated with the
    data set which is to inherit the lines of the display
    owned by the data set on whose command line the show
    subcommand was entered.

=SL                                                                    @
)F FUNCTION -
  Use the sl subcommand to shift text to the left. If necessary,
  data will be truncated on the left side. Note that an alternate
  method for shifting a line left on the display is to place the
  character "<", preceded by a number, in the sequence number field
  of the line on the display.  For example, if a sequence number
  field appeared as "00050", changing it to "5<050" would shift that
  one line left five positions.  A range of lines can be shifted
  left by entering the characters "<<" in the first and last
  sequence number fields of the range to be shifted.  the "<<" in
  the last sequence number field should be preceded by the number of
  positions to be shifted (e.g. 5<<).

)X SYNTAX -
         <lsu> sl <amt> <spos> <epos> notrunc
  required - <line-1>
  defaults - none
)O OPERANDS -
  <amt>    - Number of positions to shift.
  <spos>   - Starting position within each column where shift is to
             take place.  The default is position 1.
  <epos>   - Ending position within each column where shift is to
             take place.  The default is position 9999.
))NOTRUNC - Specifying this keyword prevents loss of data due to
  truncation.  For example, given the following data -

      123456789
          abcde
            12

  the subcommand "sl 5 1 9" produces -


      6789
      bcde
       12

  and subcommand "sl 5 1 9 notr" produces -

      123456789
      abcde
      12

=SLB                                                                   @
)F FUNCTION -
  Use the SLB subcommand to shift text to the left in one or more
  lines within the boundaries specified previously with the BNDS
  subcommand.  Essentially, the SLB subcommand will be translated
  into an SL subcommand with the fourth and fifth operands (<spos>
  and <epos>) set to the current boundaries.

  Note that an alternate method for shifting data in a group of
  lines on the display is to place the string "((" in the sequence
  number field of the beginning line, and the string "((" preceded
  by a number indicating the amount to shift in the sequence number
  field of the last line of the range to be shifted.  Data in a
  single line may be shifted by placing in the line number field
  for that line the string "(" preceded by a  number indicating the
  amount to shift.

)X SYNTAX -
         <lsu> slb <amt> notrunc
  required - <amt>
  defaults - none
)O OPERANDS -
  <amt>    - Number of positions to shift.
))NOTRUNC - Specifying this keyword prevents loss of data due to
  truncation.  enter "help sl o(notrunc) for examples of use".

=SLC                                                                   @
)F FUNCTION -
  Use the SLC subcommand to shift text to the left in one or more
  lines based on the current cursor location.  Essentially, the
  SLC subcommand will be translated into an SL subcommand with
  <spos> set to the current cursor location.

  Note that an alternate method for shifting data in a group of
  lines on the display is to place the string "sl" in the sequence
  number field of the beginning line, and the string "sl" preceded
  by a number indicating the amount to shift in the sequence number
  field of the last line of the range to be shifted.  Before hitting
  enter, you should then move the cursor to the starting column
  where data is to be shifted.

)X SYNTAX -
         <lsu> slc <amt> 0 <epos> notrunc
  required - <amt>
  defaults - none
)O OPERANDS -
  <amt>    - Number of positions to shift.
  0        - This 0 will be replaced by the cursor location, and
             will be interpreted as the starting position in which
             data is to be shifted.
  <epos>   - Ending position in which shift is to take place.
             the default is 9999.
))NOTRUNC - Specifying this keyword prevents loss of data due to
  truncation.  enter "help sl o(notrunc) for examples of use".

=SLE                                                                   @
)F FUNCTION -
  SLE shrinks the size of the columns in a matrix defined over a
  range of lines.
)X SYNTAX -
  <lsu> sle <amt>
)O OPERANDS -
 <amt> is the amount to shrink each column of the matrix by.

=SNO                                                                   @
)F FUNCTION -
  The SNO subcommand is useful in pattern recognition.  It is an
  implementation of the SNOBOL language, and is similar to the
  ALTER subcommand of the MTS (Michigan Terminal System) Editor.
  The syntax for this subcommand is complex.  Therefore, a separate
  appendix to this manual (Appendix E) documents the SNO subcommand
  in detail.

)X SYNTAX -
         <lsu> sno <keywords> (':') <statement>
  see also appendix e to the ABE manual.
)O OPERANDS - see appendix E to the ABE manual.

=SNOT                                                                  @
)F FUNCTION -
  SNOT is a shorthand version of SNO.  Entering "snot 'pds(' a ')'"
  is equivalent to entering "sno anchor trim rtab(0) $ a = 'pds(' a
  ')'".
)X SYNTAX -
         <lsu> snot <partial statement>
  see also appendix e to the ABE manual.
)O OPERANDS - see appendix E to the ABE manual.

=SORT                                                                  @
)F FUNCTION -
  Use the sort subcommand to sort a data set being edited on up to
  five fields.
)X SYNTAX -
         sort off1 len1 seq1 ...  Offn lenn seqn
  required - off1 len1 seq1
  defaults - none
)O OPERANDS -
 'off len seq' -  "off" is the offset, relative 1, from the
  beginning of each record to the sort field, "len" is the length
  of the sort field, and "seq" is either of the characters "a"
  or "d", which indicate ascending or descending sequence,
  respectively.

=SORTL                                                                 @
)F FUNCTION -
  Use the sortl subcommand to sort specified lines of a data set
  being edited on up to four fields.
)X SYNTAX -
         <lsu> sortl off1 len1 seq1 ...  Offn lenn seqn
  required - off1 len1 seq1
  defaults - none
)O OPERANDS -
 'off len seq' -  "off" is the offset, relative 1, from the
    beginning of each record to the sort field, "len" is the length
    of the sort field, and "seq" is either of the characters "a"
    or "d", which indicate ascending or descending sequence,
    respectively.

=SORTQ=SORTX=SORTNX                                                    @
)F FUNCTION -
  The SORTNX, SORTQ, and SORTX subcommands are identical in syntax
  to the SORT subcommand.  They differ in that they are all
  considerably faster than SORT, and SORTX only sorts lines which
  have been suppressed using the SUPPRESS subcommand, while SORTNX
  only sorts lines which have not been suppressed using the SUPPRESS
  subcommand. The SORT subcommand uses the bubble sort technique,
  whereas SORTNX, SORTQ, and SORTX use the Shell-Metzner technique.
  However, SORTNX, SORTQ and SORTX will not maintain any previous
  sequence, and SORT will.
)X SYNTAX -
         sortnx
         or
         sortq
         or
         sortx off1 len1 seq1 ...  Offn lenn seqn
  required - off1 len1 seq1
  defaults - none
)O OPERANDS -
 'off len seq' -  "off" is the offset, relative 1, from the
  beginning of each record to the sort field, "len" is the length
  of the sort field, and "seq" is either of the characters "a"
  or "d", which indicate ascending or descending sequence,
  respectively.

=SORTQL=SORTXL=SORTNXL                                                 @
)F FUNCTION -
  The SORTQL, SORTXL, and SORTNXL subcommands are identical in
  syntax to the SORTL subcommand.  They differ in that they are
  considerably faster, and SORTXL sorts only lines suppressed with
  the SUPPRESS subcommand, and SORTNXL sorts only lines not
  suppressed with the SUPPRESS subcommand. The SORTL subcommand uses
  the bubble sort technique, and the others use the Shell-Metzner
  technique.  However, SORTL maintains any previous sequence, and
  the others don't.
)X SYNTAX -
               sortxl
               or
               sortnxl
               or
         <lsu> sortql off1 len1 seq1 ...  Offn lenn seqn
  required - off1 len1 seq1
  defaults - none
)O OPERANDS -
 'off len seq' -  "off" is the offset, relative 1, from the
    beginning of each record to the sort field, "len" is the length
    of the sort field, and "seq" is either of the characters "a"
    or "d", which indicate ascending or descending sequence,
    respectively.

=SPLINE                                                                @
)F FUNCTION -
  Spline interpolates a smooth curve through a set of points.  The
  curve is based on a series of cubic functions whose domains range
  between contiguous pairs of points in the input set. Given as
  input datasets describing points in 2-space, the user at the
  terminal will be shown the resulting curve, and will be allowed to
  edit the set of points, adding, deleting, and moving individual
  points. It can only be used from a terminal having graphics
  capabilities, and GDDM must be available (see Appendix N).
)X SYNTAX -
         spline <xarray> <yarray> <xoutarray> <youtarray> <k> <1>
  A typical calling sequence might be "%%gddmshow sample" where
  sample is a dataset containing the following -
    apl xin#1 4`B20Y10 20 30 40 50 60
    apl yin#1 4`B20Y50 55 45 65 35 75
    apl xout#1 4`Byout#1 4`B100R0
    spline xin yin xout yout 0.5
  gddmshow is documented in Appendix N.

)O OPERANDS -
<xarray> - This must be a virtual dataset containing the x
  coordinate values for the series of points defining the curve.
  <xarray> must be ordered such that x(n-1)<x(n)<x(n+1). The dataset
  can be created with an apl subcommand similar to "apl xin#1
  4`B20Y10 20 30 40 50 60". Refer to Appendix L for more information
  on the APL subcommand. Other notable constraints are that the
  variable must be in internal floating point, 4 bytes per element,
  and must be a vector of four or more items.
<yarray> - This must be a virtual dataset containing the y
  coordinate values corresponding to the x values in <xarray>.
  The same constraints that apply to <xarray> also apply to
  <yarray>, except that it need not be true that y(n-1)<y(n)<y(n+1).
<xoutarray> and <youtarray> will be filled in with (x,y) coordinate
  values uniformly spaced along the range of x in <xarray>.  Once
  spline has been invoked, the resultant curve can be reviewed as in
  the following sequence of subcommands:

    apl xin#1 4`B20Y10 20 30 40 50 60
    apl yin#1 4`B20Y50 55 45 65 35 75
    $* fillet xin yin
    apl xout#1 4`Byout#1 4`B100R0
    spline xin yin xout yout 0.5 1
    apl count#7 4`BRxout
    gddm gsmove xout yout
    gddm gsplne count xout yout

  To view the matching pairs of (x,y) coordinate values in EBCDIC,
  the following apl subcommand can be used:

    apl 10 5Fxout,{1.5}yout

  The first few lines of the resulting dataset are as follows:

                   10        20        30        40
        12345678901234567890123456789012345678901234
                                      ×T44××100X20.1
    001 10.00000  50.00000
    002 10.50000  50.87898
    003 11.00000  51.70651
    004 11.50000  52.48007
      .
      etc.
      .

<k> is a factor used in the cubic smoothing algorithms to control
  endpoint conditions.  The default value is 0.5, and if you
  override, the value must be greater than 0.
<1> If the sixth operand to the SPLINE subcommand is nonblank, the
  calculation of output points is done, but the interactive display
  of points is not done.  Thus, SPLINE can be invoked in a batch
  environment.

=SPLIT                                                                 @
)F FUNCTION -
  Use the split subcommand to separate one or more lines into
  pairs of consecutive lines.
)X SYNTAX -
         <lsu> split <<'number'> × <'string'>> all
  required - none
  defaults - <number> defaults to half the length of the line to
             be split.
  NOTE: SPLIT only recognizes the <l1> and <l2> values from the LSU,
  and ignores everything else.
)O OPERANDS -
  <number> -  This operand is mutually exclusive with
              the <string> operand.  It specifies the number of
              characters to be included in the first resulting
              line.  If neither <number> nor <string> is
              specified, <number> defaults to half the length of
              the line to be split.
  <string> -  This operand is mutually exclusive with the <number>
              operand.  <string> specifies the group of contiguous
              characters that are to begin each newly created
              line.  The split subcommand will scan each line in
              the specified range, beginning in column 2.  Each
              line will be split at the point where <string> is
              found.
))ALL - This keyword is optional, and specifies that each original
  line in the range is to be split as many times as there are
  occurrences of <string> in the line.  If ALL is not specified,
  each line in the range will be split only at the first
  occurrence of <string>.

=SPLITB                                                                @
)F FUNCTION -
  Use the splitb subcommand to separate one or more lines into
  multiple lines, each new line containing an item of text
  from the original that was delimited by blanks. It helps
  to understand how the subcommand works if you realize that
  the new lines will contain absolutely no blanks. For example,
  the following text -

      STILL ROUND THE CORNER THERE MAY WAIT,
      A NEW ROAD OR A SECRET GATE.
      AND THO I OFT HAVE PASSED THEM BY,
      A DAY WILL COME AT LAST WHEN I
      SHALL TAKE THE HIDDEN PATHS THAT RUN,
      WEST OF THE MOON, EAST OF THE SUN.

  would appear as follows after the SPLITB subcommand has been
  applied:

      STILL
      ROUND
      THE
      CORNER
      etc.

)X SYNTAX -
         <lsu> splitb
  required - none
  defaults - none
)O OPERANDS - none

=SR                                                                    @
)F FUNCTION -
  Use the sr subcommand to shift text to the right. If necessary
  data will be truncated on the right side. Blanks will be inserted
  on the left. Note that an alternate method for shifting a line
  right on the display is to place the character ">", preceded by a
  number, in the sequence number field of the line on the display.
  For example, if a sequence number field appeared as "00050",
  changing it to "5>050" would shift that one line right five
  positions.  A range of lines can be shifted right by entering the
  characters ">>" in the first and last sequence number fields of
  the range to be shifted. the ">>" in the last sequence number
  field should be preceded by the number of positions to be shifted
  (e.g. 5>>).
)X SYNTAX -
         <lsu> sr <amt> <spos> <epos> notrunc
  required - <line-1>
  defaults - none
)O OPERANDS -
  <amt>    - Number of positions to shift.
  <spos>   - Starting position within column where shift is to take
             place.  The default is column 1.
  <epos>   - Ending position within column where shift is to take
             place.  The default is column 1.
))NOTRUNC - Specifying this keyword prevents loss of data due to
  truncation.  For example, given the following data -

      123456789
      abcde
       12

  the subcommand "sr 5 1 9" produces -


           1234
           abcd
            12

  and subcommand "sr 5 1 9 notr" produces -

      123456789
          abcde
            12

=SRB                                                                   @
)F FUNCTION -
  Use the SRB subcommand to shift text to the right in one or more
  lines within the boundaries specified previously with the BNDS
  subcommand.  EssEntially, the SRB subcommand will be translated
  into an SR subcommand with <spos> and <epos> set to the current
  boundaries.

  Note that an alternate method for shifting data in a group of
  lines on the display is to place the string "))" in the sequence
  number field of the beginning line, and the string "))" preceded
  by a number indicating the amount to shift in the sequence number
  field of the last line of the range to be shifted.  Data in a
  single line may be shifted by placing in the line number field
  for that line the string ")" preceded by a  number indicating the
  amount to shift.

)X SYNTAX -
         <lsu> srb <amt> notrunc
  required - <amt>
  defaults - none
)O OPERANDS -
  <amt>    - Number of positions to shift.
))NOTRUNC - Specifying this keyword prevents loss of data due to
  truncation.  enter "help sl o(notrunc) for examples of use".

=SRC                                                                   @
)F FUNCTION -
  Use the SRC subcommand to shift text to the right in one or more
  lines based on the current cursor location.  Essentially, the
  SRC subcommand will be translated into an SR subcommand with
  the fourth operand, <scol>, set to the current cursor location.

  Note that an alternate method for shifting data in a group of
  lines on the display is to place the string "sr" in the sequence
  number field of the beginning line, and the string "sr" preceded
  by a number indicating the amount to shift in the sequence number
  field of the last line of the range to be shifted.  Before hitting
  enter, you should then move the cursor to the starting column
  where data is to be shifted.

)X SYNTAX -
         <lsu> sr <amt> 0 <epos> notrunc
  required - <amt>
  defaults - none
)O OPERANDS -
  <amt>    - Number of positions to shift.
  0        - This 0 will be replaced by the cursor location, and
             will be interpreted as the starting column in which
             data is to be shifted.
  <epos>   - Ending position in which shift is to take place.
             the default is column 9999.
))NOTRUNC - Specifying this keyword prevents loss of data due to
  truncation.  enter "help sr o(notrunc) for examples of use".

=SRE                                                                   @
)F FUNCTION -
  SRE expands the size of the columns in a matrix defined over a
  range of lines.
)X SYNTAX -
  <lsu> sre <amt>
)O OPERANDS -
 <amt> is the amount to expand each column of the matrix by.

=SUBMIT=SUB                                                            @
)F FUNCTION -
  The submit subcommand is used to enter the current edited data
  set into the background for execution.  The data set will be
  saved in data set lastjcl.cntl, and lastjcl.cntl will then
  be submitted.
)X SYNTAX  -
         submit
  required - none.
  defaults - none.
  alias    - sub
)O OPERANDS - NONE

=SUBSTR                                                                @
)F FUNCTION -
  Use the substr subcommand to insert data in specified columns of
  a range of lines.  Several methods are available for specifying
  the data to be inserted, some of which allow you to specify more
  data than each column is wide.  If this occurs, SUBSTR will
  truncate on the left.
)X SYNTAX -
  <subcommand> ::= <lsu> 'substr' <positional> ('off('<sub-off>')')
                   ('len('<sub-len>')') (<keyword>)
  <positional> ::= <str> × <numerics>
  <keyword> ::= 'rnd' × 'col' × 'samecol' × 'incr' × 'decr' ×
    'cycle' × 'expression' × 'ctllen' × 'ctloff' ×
    'lookup' × 'pukool' × 'hex'

  required - <str> × <line-3>>
  defaults - none
)O OPERANDS -
  <positional> - If any of the keywords COL, SAMECOL, INCR, or
   DECR is specified, then <positional> must be a numeric value.
   Otherwise, it can be any character string.  If <positional> is
   not a quoted string, and contains only numeric characters, and
   none of the keywords RND, COL, SAMECOL, CYCLE, INCR, DECR, EXPR,
   CTLOFF, CTLLEN, LOOKUP, or PUKOOK has been specified, then
   <positional> is assumed to be the line number of the line
   containing data to be assigned to each column specified by the
   <lsu>.  Data is taken beginning in column 1 of the line with
   sequence number <positional>. The length of data taken will be
   equal to <rh-len> (or <sub-len>, if specified).

))COL - If specified, indicates that in each column specified by the
   <lsu>, data beginning in position <off> (or <sub-off>, if
   specified) for a length of <rh-len> (or <sub-len>, if specified),
   is to be replaced with data beginning in position <numerics> of the
   same column.

))CTLLEN - Is used in conjunction with keyword CTLOFF to specify
   positions containing control information.  Each succeeding
   column in a group with matching control information will have
   an incremental number starting with 1 stored at the offset
   specified by the OFF keyword for a length specified by the
   LEN keyword, e.g. given -

     A
     A
     A
     B
     B
     C
     C
     C

   the subcommand -

     substr '' ctloff(1) ctllen(1) off(3) len(1)

   will produce

     A 1
     A 2
     A 3
     B 1
     B 2
     C 1
     C 2
     C 3

))CTLOFF - see the CTLLEN keyword.

))CYCLE - specifies that characters are to be assigned to each
   column from <str> in a cyclic manner, e.g. suppose your data set
   contains 6 blank lines when the subcommand "1.1 substr abc cycle"
   is entered; the results would be:

                1
       1234567890

     1 A
     2 B
     3 C
     4 A
     5 B
     6 C

))DECR - specifies that a decremental number, starting with the one
   specified in <str>, is to be assigned to each column.  Other
   than the fact that the number decrements instead of increments,
   this keyword works exactly the same as the INCR keyword.

))EXPRESSION - specifies that <str> is an expression to be evaluated
   for each column and the result is to be stored in the column. The
   expression can be anything acceptable to the CALC subcommand (see
   appendix I). For example, given a data set containing 5 blank
   lines, the subcommands "/calc a#0/substr 'sin(a#a+1)' expr"
   would produce the following result:

     .841471
     .909297
     .14112
     -0.756802
     -0.958924

))HEX Indicates that <positional> represents a hexadecimal constant,
   and SUBSTR will translate it to internal hexadecimal format.

))INCR - specifies that an incremental number, starting with the one
   specified in <str>, is to be assigned to each column, e.g.
   "1.2 substr 1 incr" in a data set currently containing 6 blank
   lines would produce the result:

                1
       1234567890

     1 01
     2 02
     3 03
     4 04
     5 05
     6 06

   By default, the incremental number is left-zero filled.  If you
   specify LEN(0), however, left-zero filling will not occur.

   Also by default, the number is incremented by one.  You can
   override this as in the subcommand "1.2 substr 1 incr(2)", which
   in a dataset with 6 blank lines would produce the result:

                1
       1234567890

     1 01
     2 03
     3 05
     4 06
     5 09
     6 11

))LOOKUP - <positional> must be the symbolic name (assigned for
  example by the NAME keyword of the ABE command) of a dataset
  currently being edited.  Each column specified by the <lsu>
  must contain only a number matching a sequence number of a
  line in the dataset referred to by <positional>.  The number
  in each column specified by the <lsu> will be replaced by the
  data in the line with matching sequence number from the dataset
  referred to by <positional>.  For example, suppose dataset
  MONTHS contains 12 lines as follows:

                1
       123456789012345678
                ×MONTHS××
     1 JAN
     2 FEB
     3 MAR
     4 APR
     5 MAY
     6 JUN
     7 JUL
     8 AUG
     9 SEP
    10 OCT
    11 NOV
    12 DEC

  Then the following sequence of commands -

    define xxx
    a xxx bl 5
    a xxx substr 'int(12*rnd(-1))+1' expr
    a xxx substr months lookup

  will create a dataset XXX with a random selection (with
  replacement) of five month names, and might appear as follows:

                1
       123456789012345
                ×XXX××
     1 NOV
     2 JAN
     3 APR
     4 JUL
     5 DEC

  And the following sequence of commands -

    define xxx
    a xxx random 12 5 -1
    a xxx substr months lookup

  will create a dataset XXX with a random selection (without
  replacement) of five month names, and might appear as follows:

                1
       123456789012345
                ×XXX××
     1 NOV
     2 MAY
     3 DEC
     4 JUL
     5 FEB

))PUKOOL - Undoes what the LOOKUP keyword has done, e.g. given dataset
  MONTHS as described under the keyword LOOKUP, and dataset XXX
  as follows:

                1
       123456789012345
                ×XXX××
     1 NOV
     2 MAY
     3 DEC
     4 JUL
     5 FEB

  then the subcommand -

    a xxx substr months pukool

  will produce -

                1
       123456789012345
                ×XXX××
     1 11
     2 5
     3 12
     4 7
     5 2

))RND
   If RND is specified, <str> specifies a string of characters which
   are to be randomly selected to fill out the specified length,
   e.g. "1.3 substr '0123456789' rnd" might produce data such as the
   following:

                   1          2         3
          1234567890123456768901234567890

          820
          661
          601
          436
          772
          993
          245
          567
          079
          868

))SAMECOL - If specified, <numerics> specifies the line number
   containing data to be assigned to each line in the range. Data is
   taken from line numbered <numerics> beginning at offset <off> (or
   <sub-off>, if specified>, for a length equal to <len> (or
   <sub-len>, if specified).

=SUFFIX                                                                @
)F FUNCTION -
  Ensures that trailing blanks are eliminated in all lines in the
  data set.
)X SYNTAX -
         suffix
  required - none
  defaults - none
)O OPERANDS - none

=SUPPORT                                                               @
)F FUNCTION -
  SUPPORT is used to indicate whether a data set is a support data
  set (ON/OFF keywords) or may simply indicate whether it is to
  inherit ownership of display lines (SHOW/NOSHOW keywords). When a
  data set is a support or noshow data set, if it currently doesn't
  own any lines on the display, it will never inherit any lines
  given up by issuing the LINES subcommand for a data set currently
  on the display.  The only way you can get a support or noshow data
  set to show up on the display is to issue the SHOW command for it.
  The other significant functional difference related to support
  data sets is that, if you issue the END subcommand for a data set,
  and that results in only support data sets currently being edited,
  an "END NOSAVE" will be scheduled for every one of the support
  data sets currently being edited.  Note that a data set may also
  be designated as support by the SUPPORT keyword, and may be
  designated as noshow by the NOSHOW keyword on the ABE, DEFINE, and
  NAME subcommands.
 +Note - you might want to designate user-defined program function
  key data sets as support data sets.
)X SYNTAX -
         SUPPORT ON × OFF × SHOW × NOSHOW
  required - none
  defaults - ON
)O OPERANDS -
))ON - Indicates data set is to be a support data set.
))OFF - Indicates data set is no longer to be a support data set.
))SHOW - Indicates data set is to inherit lines.
))NOSHOW - Indicates data set is not to inherit lines.

=SUPPRESS=SU                                                           @
)F FUNCTION -
  Suppress designates lines which are not to be displayed. The
  beginning line on the display where a group of suppressed lines
  would normally be displayed will contain the message "lines
  suppressed = nnn" where nnn is the number of lines suppressed.
 +Note that an alternative for suppressing records on the
  display is to place the single character "x" anywhere in the
  sequence number field.  This will suppress that particular line.
  A range of lines on the display can be suppressed by placing
  the characters "xx" anywhere in the sequence number field of
  the first and the last records to be suppressed.
 +Note that suppressed lines can be redisplayed by using the
  reset subcommand.
)X SYNTAX -
  <subcommand> ::= <lsu> 'suppress' ('0 s')
  required - none
  defaults - none
  alias    - su
)O OPERANDS -
))S Specifies that all but the leftmost unsuppressed lines in
  the group are to be suppressed.  Note that the preceding '0'
  is required if you want to specify the S keyword.  It is a
  bug in the SUPPRESS subcommand I don't have the time to fix.

=SWAP                                                                  @
)F FUNCTION -
  This subcommand can be used to interchange the positions of two
  data sets on the display.  if data set with symbolic name XXX
  is the top data set on the display, and YYY is the third data set
  on the display, entering "swap yyy" of the command line for XXX
  will cause YYY to become the first data set on the display, and
  XXX to become the third.  Entering "swap zzz" where ZZZ is not
  currently on the display causes the SWAP subcommand to perform
  the equivalent of the SHOW subcommand.
)X SYNTAX -
  swap <name>
)O OPERANDS
  <name> - this is the symbolic name associated with the data set
  with which the display position swap is to be performed.  If
  <name> is not specified, the swap will be with the next available
  dataset on the display.

=SYMC                                                                  @
)F FUNCTION -
  This subcommand can be used to interrogate the current replacement
  value for a symbolic variable (see also help for the SYMREP
  subcommand).  Entering "symc sysuid" for example, will cause your
  userid to be displayed in the message area.

  Note that the symc can also be entered as a line subcommand by
  entering an ampersand followed by the variable name in the
  sequence number field.  The replacement value for the specified
  symbolic variable will then be set to that line number.  For
  example, suppose line numbered 00010 were displayed, and
  the following were keyed in that line -

     &abc0 how now brown cow

  After hitting enter, a subsequent "symc abc" subcommand would
  show that the replacement value for variable ABC had been set to
  "10".  Note that if the variable name ends in numerics, you
  should follow it with a blank.

)X SYNTAX -
  symc <symbol> <pool>
)O OPERANDS
 <symbol> - this is the name of the symbolic variable (less the
   ampersand) for which replacement data is to be displayed.
 <pool> - name of symbolic variable pool.  If none specified, the
   global pool will be used.

=SYMREP                                                                @
)F FUNCTION -
  There is no SYMREP subcommand of ABE.  This is merely an artifice to
  isolate the documentation on symbolic variables and symbolic
  replacement, making it easy to reference.

  Those subcommands of ABE which use symbolic replacement (e.g. PFK,
  RUN) usually have a syntax which allows keyword parameters to be
  specified following all of the positional operands of the subcommand.
  These keyword parameters are of the form "krv(value)".  "krv" can be
  any character string 1 to 7 characters in length.  "value" can be any
  character string 0 to 256 characters in length.

  As each line is selected by the subcommand which uses symbolic
  replacement, the line is scanned for symbols of the form &nnn, where
  nnn is a string of from 1 to 7 characters delimited by a non-
  alphameric character such as a blank, comma, parentheses, etc. Such
  symbols are called symbolic variables, and they have a replacement
  value associated with them. Each occurrence of each symbolic variable
  in the selected line is replaced by its associated replacement value.

  The previously mentioned keyword parameters are used to set the
  replacement values for symbolic variables.  For example, the keyword
  parameter "count(50)" associates the replacement value "50" with the
  symbolic variable "&count".  If a symbolic variable is found for
  which a keyword parameter was not specified on the subcommand, either
  the value specified for the same symbolic variable on a previous
  subcommand will be used, or if the variable has never been set, a
  null string will be used.

  When you specify a replacement value for a symbolic variable, that
  replacement value remains established until you either return to
  READY mode (i.e. end ABE altogether), or you specify a new
  replacement value.

  There are currently 12 global symbolic variables.  These are
  variables which have an initial replacement value which does not need
  to be set by the user.  These globals are -

    - &LASTCC, which returns the return code issued by the ABE
        subcommand most recently executed.  &LASTCC is especially
        useful in an RUN command list to determine if a FIND or FIND
        subcommand was successful or not.
    - &SUBSTR, which returns a substring of the replacement value
        assigned to a given symbolic variable.  The general format is -

          &SUBSTR(SYMNAME,OFF,LEN)

        where -

        - SYMNAME is the name of a symbolic variable.  The substring
          will be extracted from the replacement value assigned to
          this variable.
        - OFF is an integer constant specifying the starting position
          of the substring.
        - LEN is an integer constant specifying the length of the
          substring.  LEN is optional, and if not specified, the
          substring returned is position OFF to the end of the
          replacement value for SYMNAME.

        Examples -

          setl str 'How now brown cow'
          r msg &&SUBSTR(str,5,3)=&SUBSTR(str,5,3)
          setl word brown
          r msg The cow is &SUBSTR(str,&SYSEVAL(index(str,word)), +
            &SYSEVAL(length(word)))..

        The resulting messages would be -

          &SUBSTR(str,5,3)=now
          The cow is brown.

    - &SYSACCT, which returns the account number that was specified
        when the user logged on the system.
    - &SYSATTN, which returns the number of times the attention key
        was pressed at the terminal since the last time SYSATTN
        was referenced.
    - &SYSAPL, which is followed by a parenthesized expression.
        The APL subcommand will be invoked to evaluate the expression,
        and the result will replace both the string &SYSAPL and the
        parenthesized expression, e.g. the subcommand -

          r nl &SYSAPL(*1)

        will create a new record in the current dataset containing
        the string "2.718282".
    - &SYSDATE, which returns the current date.
    - &SYSEVAL, which is followed by a parenthesized expression.
        The CALC subcommand will be invoked to evaluate the expression,
        and the result will replace both the string &SYSEVAL and the
        parenthesized expression, e.g. the subcommand -

          r nl &SYSEVAL(sind(45))

        will create a new record in the current dataset containing
        the string ".707107".
    - &SYSNAME, which returns the contents of the programmer name
        field.
    - &SYSPREF, which returns a prefix if set via the TSO PROFILE
        command.
    - &SYSTIME, which returns the current time.
    - &SYSUID, which returns the TSO userid associated with the
        current TSO session.
    - &SYSUNQ, which returns a unique value each time it is invoked,
        e.g. the subcommand "symc sysunq" might return "4" this time,
        and return "5" if it is repeated.

)X SYNTAX - NONE
)O OPERANDS - NONE

=TAB                                                                   @
)F FUNCTION
  Tab can be used to establish tab values or to nullify existing
  tab values.
)X SYNTAX -
         tab <integer-list>
  example  - tab 10 15 20 25 30
  required - none
  defaults - turn off all tabs
  alias    - none
)O OPERANDS -
 <integer-list>
           - Specifies the relative column positions in each
             line to which tab values are to be set.  This operand
             is optional.  If omitted, all current tab values are
             turned off.  Up to fifteen tab values can be set.
             At initial entry to the abe  command, tab settings
             are in positions 10 12 14 16 18 20 22 24 26 28 30 32
             34

=TABK                                                                  @
)F FUNCTION -
  Use the tabk subcommand to specify the character which is to
  signal a tabbing operation.  At initial entry to the abe
  command, the Ö character is set as the default tab character.
)X SYNTAX -
           tabk <tabcharacter>
 example  - tabk ×
 required - none
 defaults - no operand specified turns of tabbing.
 alias - none
)O OPERANDS -
 <tabcharacter> -
         Specifies the tabbing character.

=TEXT                                                                  @
)F FUNCTION -
  Use the TEXT subcommand to print text on the graphics drawing.
  See Appendix N, subtitle SOME ADDITIONAL GRAPHICS SUBCOMMANDS.
)X SYNTAX -
    text <text> <height> <font> <wscale> <swchar>
)O OPERANDS - See Appendix N.

=TGET                                                                  @
)F FUNCTION -
  Use the TGET subcommand to interface to the TGET macro as
  documented in "TSO Guide to Writing a Terminal Monitor Program or
  Command Processor," GC28-1295.
)X SYNTAX -
   tget <name> edit   wait
               asis   nowait
 required - <name>
 defaults - EDIT and WAIT.
 alias - none
)O OPERANDS -
 <name> - specifies the symbolic name (assigned e.g. via the NAME
  subcommand) associated with a dataset into which the data
  received from the terminal as a result of issuing the TGET macro
  is to be stored.  If a dataset with the specified symbolic name
  is found, all of its current lines will be deleted, and replaced
  by lines containing the terminal input.  If a dataset isn't
  found with the specified symbolic name, a virtual dataset will
  be created.
))ASIS - Documented in GC28-1295.
))EDIT - Documented in GC28-1295.
))WAIT - Documented in GC28-1295.
))NOWAIT - Documented in GC28-1295.

=TOGGLE                                                                @
)F FUNCTION -
  TOGGLE is a rather specialized subcommand designed to detect
  start and stop delimiters in a string of text records.  The
  example below is easier to understand than a long-winded
  description.

  Given a text dataset with ASA carriage control as follows -

                10        20        30
       1234567890123456789012345678901234567890

   010 1@A Sample Text Dataset#
   020 0This music should be listened to
   030  with just a candle to light to room.
   040  And as you listen,
   050  think of me.  @If you call my name,
   060  I'll be there.#

  The following sequence of subcommands will modify the text to
  underline those portions delimited beginning with an @
  character and ending with a # character.

    2. CO TMP
    A TMP REN +1
    A TMP TOGGLE @ #
    A TMP C 1 _
    A TMP SNO STACK TRIM ANCHOR LEN(0) RPOS(0) = SEQ ' DEL'
    A TMP 1.1 SUBSTR '+'
    MB TMP
    C @ ''
    C # ''

  The results would be as follows:

                10        20        30
       1234567890123456789012345678901234567890

   010 1A Sample Text Dataset
   011 +_____________________
   020 0This music should be listened to
   030  with just a candle to light to room.
   040  And as you listen,
   050  think of me. If you call my name,
   051 +             ____________________
   060  I'll be there.
   061 +______________

)X SYNTAX -
   toggle <start> <stop>
 required - <none>
 defaults - <start>=x'34', <stop>=x'35'.
 alias - none
)O OPERANDS -
 <start> - Starting delimiter.
 <stop> - Ending delimiter.

=TPG                                                                   @
)F FUNCTION -
  Use the TPG subcommand to interface to the TPG macro as
  documented in "TSO Guide to Writing a Terminal Monitor Program or
  Command Processor," GC28-1295.  The TPG subcommand will also
  issue a TGET macro following the TPG macro to receive the
  response from the terminal hardware.
)X SYNTAX -
   tpg <output> × '<hexdata>' <input> wait    nohold
                                      nowait  hold
 example - If the RUN subcommand is issued for a dataset containing
  the following two lines, dataset RESPONSE will then contain
  hardware information if the terminal is an IBM3179G:
    TPUT 'C2'
    TPG  'F3000501FF02' RESPONSE
 required - <output> <input>
 defaults - wait, nohold.
 alias - none
)O OPERANDS -
 <name> -  This is the symbolic name of a currently edited dataset
   the records of which contain printable hexadecimal representations
   of the data to the transmitted to the terminal.  The data will
   be converted to internal hexadecimal by the TPG subcommand
   before being transmitted.
 <hexdata> -  <hexdata> must be surrounded in apostrophes to
   distinquish it from <name>.  <hexdata> must contain a string
   of printable hexadecimal characters.  TPG will translate to
   internal hexadecimal, and will transmit to the terminal.
 <input> - specifies the symbolic name (assigned e.g. via the NAME
  subcommand) associated with a dataset into which the data
  received from the terminal as a result of issuing the TGET macro
  is to be stored.  If a dataset with the specified symbolic name
  is found, all of its current lines will be deleted, and replaced
  by lines containing the terminal input.  If a dataset isn't
  found with the specified symbolic name, a virtual dataset will
  be created.
))WAIT   - Documented in GC28-1295.
))NOWAIT - Documented in GC28-1295.
))HOLD   - Documented in GC28-1295.
))NOHOLD - Documented in GC28-1295.

=TPUT                                                                  @
)F FUNCTION -
  Use the TERM subcommand to specify a data stream to be transmitted
  to a 3270-type terminal using the TPUT facility under TSO.
)X SYNTAX -
   tput <name> × '<hexdata>' fullscr  wait   nohold
                             edit     nowait hold
                             noedit
                             asis
                             control

 Example  - If the RUN subcommand is issued for a dataset containing
   the following set of subcommands, snowflakes (asterisks) will
   appear at random locations on the screen:

   A WRK END N
   DEFINE WRK
   A WRK BL 100
   A WRK USE FIXED @ 1 A IB2.
   A WRK UPDATE SET A=SBA(INT(RND(-1)*1900))
   A WRK CONVERT CHAR(1 2) HEX(10 4)
   A WRK SL 9
   A WRK SNOT 'TPUT ''F111' A '5C'''
   TPUT 'F11140403C4040001140C113'
   RUN WRK

 required - <name> × '<hexdata>'
 defaults - fullscr, wait, nohold
 alias - none
)O OPERANDS -
 <name> -  This is the symbolic name of a currently edited dataset
   the records of which contain printable hexadecimal representations
   of the data to the transmitted to the terminal.  The data will
   be converted to internal hexadecimal by the TPUT subcommand
   before being transmitted.
 <hexdata> -  <hexdata> must be surrounded in apostrophes to
   distinquish it from <name>.  <hexdata> must contain a string
   of printable hexadecimal characters.  TPUT will translate to
   internal hexadecimal, and will transmit to the terminal.
))EDIT    - Documented in GC28-1295.
))NOEDIT  - Documented in GC28-1295.
))ASIS    - Documented in GC28-1295.
))CONTROL - Documented in GC28-1295.
))FULLSCR - Documented in GC28-1295.
))WAIT    - Documented in GC28-1295.
))NOWAIT  - Documented in GC28-1295.
))HOLD    - Documented in GC28-1295.
))NOHOLD  - Documented in GC28-1295.

=TOP=T                                                                 @
)F FUNCTION -
  Top causes the display to be moved to the first line of the
  data set.
)X SYNTAX -
         top
  required - none
  defaults - none
  alias - t
)O OPERANDS -
  none

=TRACE                                                                 @
)F FUNCTION -
  TRACE causes a copy of each full screen display to be written to
  the file allocated with the ddname "PRTSCR".  This file must be
  allocated by you before issuing the TRACE subcommand.  The
  file may be disk, tape, or sysout, it must have the DCB attributes
  LRECL=81, RECFM=FA or RECFM=FBA, and the BLKSIZE must be a
  multiple of 81.
)X SYNTAX -
         trace on  × trace off
  required - none
  defaults - off
  alias - none
)O OPERANDS -
))ON - Indicates tracing is to begin.
))OFF - Indicates tracing is to terminate.  Note, however, that
  the tracing file prtscr will not be closed until you return to
  READY mode.

=TRANSLAT                                                              @
)F FUNCTION -
  TRANSLAT is a generalized interface to the PL/I TRANSLATE BUILTIN
  function.  It can be used, for example, to translate all
  unprintable characters in all records to periods.  This subcommand
  may be necessary when displaying a data set containing characters
  which will be recognized by the 3270 display terminal as terminal
  commands. For example, attempting to display a record containing a
  set-buffer-address command with an invalid buffer address will
  cause an error to be signalled which will cause you to be logged
  off.  If you attempt to logon/reconnect, the same error will be
  signalled, and you will be logged off again.  The only way out is
  an operator cancel command for your session.
 +Note that the translat subcommand is issued automatically
  when either of the keywords "sysout" or "translat" are
  entered on the abe  command or subcommand.
)X SYNTAX -
         <lsu> translat <y> <z>
  required - none
  defaults - see below under operands.
  alias - none
)O OPERANDS -
  If <y> and <z> are not specified, a default global translate
  table (updated via the TRTAB subcommand) will be used in a PL/I
  TRANSLATE instruction applied to each column specified in the
  <lsu>.  If BUF refers to each column specified in the <lsu> and
  TRTAB refers to the default global translate table, a function
  equivalent to the following PL/I statement will be accomplished
  for each value of BUF:

    BUF=TRANSLATE(BUF,TRTAB);

  In this case, a switch is turned on that causes the message
  TRANSLATED to continually be displayed in the message area,
  and you must use the ST subcommand to save the data set (see
  Help data for the SAVE/ST subcommand).
 <y> - If BUF refers to each column specified in the <lsu>, a
  function equivalent to the following PL/I statement will be
  accomplished for each value of BUF:

    BUF=TRANSLATE(BUF,'<y>');

 <z> - If BUF refers to each column specified in the <lsu>, a
  function equivalent to the following PL/I statement will be
  accomplished for each value of BUF:

    BUF=TRANSLATE(BUF,'<y>','<z>');

=TRANSPOS                                                              @
)F FUNCTION -
  TRANSPOS can be used to rotate characters in a range of lines
  about one of four axes.  The functions performed are similar to
  the reverse and transpose functions of APL.
)X SYNTAX -
         <lsu> transpos <axis> <subgroup>
  required - none
  defaults - <axis>=\
  alias - none
)O OPERANDS -
 <axis> - Axis of rotation.  May be one of the values ×, -, \, or /.
   Default is \.  See EXAMPLES below.
 <subgroup> - is used when you want the transposition to take place
   on subgroups of lines within the specified range.  See EXAMPLES
   below.

))EXAMPLES -
 Example 1: The subcommand "1.1.9 transpos ×" applied to -

     001 ABCDEFGHI

   produces

     001 IHGFEDCBA

 Example 2:  The subcommand "transpos -" applied to -

     001 ABCDEFGHI
     002 JKLMNOPQR
     003 STUVWXYZ0
     004 123456789

   produces

     001 123456789
     002 STUVWXYZ0
     003 JKLMNOPQR
     004 ABCDEFGHI

 Example 3:  The subcommand "1.1.9 transpos \" applied to -

     001 ABCDEFGHI
     002 JKLMNOPQR
     003 STUVWXYZ0
     004 123456789

   produces

     001 AJS1
     002 BKT2
     003 CLU3
     004 DMV4
     005 ENW5
     006 FOX6
     007 GPY7
     008 HQZ8
     009 IR09

 Example 4:  The subcommand "1.1.9 transpos /" applied to -

     001 ABCDEFGHI
     002 JKLMNOPQR
     003 STUVWXYZ0
     004 123456789

   produces

     001 90RI
     002 8ZQH
     003 7YPG
     004 6XOF
     005 5WNE
     006 4VMD
     007 3ULC
     008 2TKB
     009 1SJA

 Example 5:  The subcommand "1.2.1 transpos \ 3" applied to -

     001 A1
     002 A2
     003 A3
     004 B1
     005 B2
     006 B3
     007 C1
     008 C2
     009 C3

   produces

     001 A1A2A3
     002 B1B2B3
     003 C1C3C3

=TRTAB                                                                 @
)F FUNCTION -
  Use the TRTAB subcommand to modify the character translation table
  that is used in a number of places in ABE.  One use of this table
  is when displaying data in hex mode, where each data line is
  displayed twice, the first line being EBCDIC, with unprintable
  characters replaced by periods, and the second line being the
  internal hexadecimal representation of the data.
    Another situation in which the character translation table
  modified by the TRTAB subcommand is used in in the TRANSLAT
  subcommand.
)X SYNTAX -
           trtab <hex-char> <hex-translate>
  required - <hex-char> <hex-translate>
  defaults - none
)O OPERANDS -
 <hex-char> - This is the hexadecimal representation of the
   character for which the character translation table entry
   is to be modified, e.g. to modify the entry for upper case
   "A", specify "C1".
 <hex-translate> - This is the hexadecimal representation of the
   character to be inserted in the character translation table,
   e.g. if "trtab c1 6b" were entered, the character translation
   table would be changed so that upper case "A" (hex C1) would be
   translated to a comma (hex 6b).

=TRUNCATE=TRUNC=TR                                                     @
)F FUNCTION -
  Use the truncate subcommand to indicate the last column of each
  card image to be displayed.
)X SYNTAX -
           truncate <number>
  required - <number>
  defaults - none
  alias - trunc/tr
)O OPERANDS -
 <number> - Indicates the column at which the display is to stop.

=TS                                                                    @
)F FUNCTION -
  Splits a data line at the point indicated by the location of the
  cursor.  Everything to the right of the cursor will be split off
  and placed in a new line. The data on the new line will be
  adjusted so that the first non-blank character aligns with the
  first non-blank of the previous line. A number of blank lines
  (specified by the second operand) are then inserted between the
  original line and the line containing the split data.
 +Note that TS is also a line command, and is used by placing the
  characters "ts" in the line number field of a line, and then
  moving the cursor to the point at which the split is to occur.
  A number to the left of the "ts" in the line number field
  indicates the number of blank lines to be inserted.
 +Note that Program Function Key 18 is set up to execute a "TS"
  subcommand.  Thus, you can move the cursor to a point on the
  line to be split, and then hit pfk 18 to cause the split to occur.
)X SYNTAX -
         ts <blanks>
  required - <none>
  defaults - <blanks> =0
)O OPERANDS -
  <blanks> is optional, and is the number of blank lines to
    be inserted at the split point.
=UNNUM=UN                                                              @
)F FUNCTION -
  Use the unnum to move blanks over the sequence field in all
  records of the data set currently being edited.
)X SYNTAX -
         unnum
  required - none
  defaults - none
  alias    - un
)O OPERANDS - NONE

=UPDATE                                                                @
)F FUNCTION -
  This subcommand is part of the relational query language (RQL)
  built into ABE.  It is use to update fields defined over a
  dataset via the USE subcommand.  See Appendix D for more
  information.
)X SYNTAX -
         see appendix D
)O OPERANDS -
 see appendix D

=UP                                                                    @
)F FUNCTION -
  Use the up subcommand to move the display up 1 or more lines.
)X SYNTAX -
           up <number>
  required - none
  default - 1
)O OPERANDS -
 <number> - The number of lines to move the display.

=USE                                                                   @
)F FUNCTION -
  The USE subcommand is used to define and manipulate fields
  in the records of the currently edited data set.  Note that
  the description of USE will be fairly succinct here.  To
  see a more detailed description, including sample usage,
  see Appendix D, which contains a complete description of the
  Relational Query Language built into ABE, and Appendix L, which
  contains a description of the APL subcommand.
)X SYNTAX -
  use <form-spec>
   or
  use input <field-specs><where-specs><order-specs>
      fixed
      list
      listavl
      set
      nosym
      in
      out
      <name>
      display
      nodisplay

)O OPERANDS -
 <form-spec> - this format is recognized by the fact that the first
  token beyond the "USE" subcommand name will be a vertical bar (×),
  e.g. "use × fld1    ×     × fld2   ×z×".  The first vertical bar
  identifies column 1 of the record layout, and all subsequent
  vertical bars identify segments of the record layout relative to
  this position.  In the example just shown, a field named "fld1"
  begins in column 1 of each record, and ends in column 10.  A
  filler is identified in columns 11 thru 17.  Field named "fld2"
  starts in column 18, and ends in 27.  The next field is special
  because it has what looks like a field name of "z".  The actual
  field name is "descript", but that was too long to specify on the
  subcommand itself.  By using a field name of "z", you tell the USE
  subcommand to prompt you for the real field name.
    You can also specify free-format fields (ones without fixed
  offset/length specifications, which are filled in based on the
  the current record each time USE subcommand is issued without any
  operand) as in "use × name1 × (name2 name3) × name4 ×".  This
  is equivalent to "use input name1 1-8 name2 name3 name4 25-32".

 <field-specs> - each field specification consists of a field name
  optionally followed by one or more blanks and a dollar sign ($),
  optionally followed by a column specification.  The column
  specification may either consist of a single column number, or
  two column numbers separated by a blank, e.g. "descript $ 1-23".
  See appendix D for a more detailed explanation.
 <where-specs> - see Appendix D.
 <order-specs> - see Appendix D.
 <name> - If the first word after the subcommand name is not one
  of the keywords FIXED, LIST, SET, NOSYM, IN, OUT, DISPLAY, or
  NODISPLAY, then it is assumed that the word is a reference to a
  symbolic name associated with another currently edited data set.  The
  DBD for the referenced data set will be copied as the DBD for the
  current data set.

))DISPLAY - Can be used for fields which contain data not directly
  printable, such as floating point or fixed binary data.  See
  both Appendix D and L.
))FIXED - this keyword indicates that the current USE subcommand
  contains one or more field definitions.  If column specifications
  for a field are not supplied on this USE subcommand, they will
  be derived immediately according to the format of the current
  data record.
))IN - this keyword indicates that the subcommand is to look for a
  DBD definition in the initial records of the data set.  A DBD is
  stored on disk as SAS source statements such as the following:

     DATA SUPPLIER;
     INPUT  SUPPNO   1-7 NAME     $ 8-23 ADDRESS  $ 24-56;
     CARDS;
     51     DEFECTO PARTS.  16 BUM ST., BROKEN HAND WY
     52     VESUVIUS, INC.  312 ANCIENT BLVD., POMPEII NY
     53     ATLANTIS CO.    8 OCEAN AVE., WASHINGTON DC
     54     TITANIC PARTS   32 LARGE ST., BIGTOWN TX
     57     EAGLE HARDWARE  64 TRANQUILITY PLACE, APOLLO MN
     61     SKY PARTS       128 ORBIT BLVD., SIDNEY AUSTRALIA
     64     KNIGHT LTD.     256 ARTHUR COURT, CAMELOT ENGLAND

  A "use in" subcommand will cause these SAS source statements to
  be used to create the DBD line, and they will then be deleted
  from the currently edited data set.
))LIST - A "use list" subcommand will cause the screen to be
  temporarily cleared, and a list of all the field definitions
  described by the current DBD will be displayed.  The list
  will be in order by the location of each field within each
  records.
))LISTAVL - A "use listavl" subcommand will cause the screen to be
  temporarily cleared, and a list of all the field definitions
  described by the current DBD will be displayed.  The list
  will be in alphabetical order by field name.
))OUT - this keyword indicates that the existing DBD definition is
  to be converted to SAS source statements at the front the of the
  dataset.  The results will appear similar to the example shown
  above under the description for the IN keyword.
))INPUT - This keyword indicates that the current USE subcommand
  contains one or more field definitions that are to replace any
  existing definitions.  If column specifications
  for a field are not supplied on this USE subcommand, they will
  be derived dynamically according to the format of the current
  record when a "use set" subcommand is issued.  See the examples
  given above, and see also the FIXED keyword.
))NODISPLAY - Reverses the effect of a previously issued
  "use display" subcommand.
))NOSYM - This keyword indicates the USE subcommand is to resolve
  field offsets and lengths for any freeform fields defined by the
  current DBD based on data in the current record.  NOSYM differs
  from the SET keyword in that replacement values for symbolic
  variables are not set (see the SET keyword below).
))SET - This keyword indicates the USE subcommand is to do two
  things based on data in the current record:  (1) Resolve field
  offsets and lengths for any freeform fields defined by the
  current DBD; (2) Set the replacement value for symbolic variables
  with names matching field names in the current DBD.  Note that
  this makes field values from the current record available to the
  CALC subcommand.  For example, given the dataset -

                 10        20        30
        1234567890123456789012345678901234567890

        ×SUPPNO×PARTNO×PRICE×DELIV×QONORDER×
    001 51     221      .30 10    50
    002 51     231      .10 10    0
    003 53     222      .25 15    0
    004 53     232     .10  15    200
    005 53     241      .08 15    0

  Then the following sequence of subcommands -

    top
    use set
    calc price*qonorder

  would produce the result 15 in the message area.

=VERIFY                                                                @
)F FUNCTION -
 Use the verify subcommand to compare all data sets currently on the
 display. The comparison will stop whenever a line in one of the data
 sets doesn't match the others. If the top line on the display for a
 dataset is the first line in the dataset, that is the line with which
 the verify operation begins.  Otherwise the process begins with the
 second line on the display for each data set.
)X SYNTAX -
            verify <start-col> <end-col>
 required - none
)O OPERANDS -
 <start-col> - is options, but if specified, indicates the
  starting column in which verification is to take place in each
  record.  If a starting column is not specified, the entire record
  is verified.
 <end-col> - is optional, but if specified, indicates the last
  column to be verified in each record.  If an ending column is
  not specified, verification goes from the starting column
  through to the end of each record.

=VOLSER                                                                @
)F FUNCTION -
 The VOLSER subcommand gives you the volume serial to which a given
 dataset name is cataloged.  After the command is issued, the volume
 serial appears in the message area of the display, and also is set
 as the replacement value for the specified symbolic variable.
)X SYNTAX -
   volser <dsname> <symname>
 required - <dsname>
 defaults - <symname>=VOLSER
)O OPERANDS -
 <dsname> - is the dataset name for which the volume serial is to be
  obtained.  Standard TSO dsname conventions must be used, i.e.
  a dsname specified in quotes will not have your userid prefixed to
  it.
 <symname> - is optional.  You can specify the symbolic name to
  which the volume serial is to be assigned as the replacement value.
  If you don't specify <symname>, the default name used is VOLSER.

=VTOC                                                                  @
)F FUNCTION -
 Use the VTOC subcommand to obtain dscbs from the vtoc for a
 specified volume.
)X SYNTAX -
 vtoc <volser> ('0') ('1') ('2') ('3') ('4') ('5')
 required - <volser>
)O OPERANDS -
 <volser> - Serial of volume from which dscbs are to be obtained.
  A new virtual dataset named @<volser> will be created to contain
  the dscbs.  If no other operands are specified, all dscbs in the
  vtoc will be copied to the virtual dataset.  Otherwise, only those
  dscbs of the specified format number(s) will be copied.

=WATDATE                                                               @
)F FUNCTION -
 Use WATDATE to convert dates between the forms YYDDD, MMDDYY, and
 YYMMDD.
)X SYNTAX -
 <lsu> watdate <date>
 required - <date>
)O OPERANDS -
 <date> - Is either -
   1.  A date in one of the forms YYDDD, MMDDYY, and YYMMDD,
   e.g. "watdate 870724" produces the message "GREGORIAN = 07/24/87,
   JULIAN = 87205, DATE = FRIDAY, JULY 24, 1987."

   2.  An LSU.  The distinction from form 1 depends on whether the
   operand is all numerics, e.g. 88131 would be taken for form 1,
   8.50 would be taken for an LSU.  To ensure form 2 is assumed,
   surround the operand in apostrophes, e.g. '1,5 23.4'.  If an LSU
   is assumed, it specifies where the output from the watdate
   subcommand is to be stored.  Input is obtained based on the <lsu>
   specification preceding the WATDATE command word in the command
   line.

=X=XT                                                                  @
)F FUNCTION -
 Use the x subcommand to get in xmode.  In this mode, the screen
 is cleared, and you may enter any tso command except test and
 time.  You are prompted with the word "ABEX" rather
 than "ready".  You may return to scan mode by entering a null
 line.  Note that you can optionally cause a log of all your
 tso commands entered in xmode to be maintained.  You do this
 by entering any of the keywords PROMPT, NEW, or CONTINUE.
+Note that the maximum tso command length you can enter in xmode
 is 240 characters.
)X SYNTAX -
  format 1:  x prompt() new continue

  format 2:  x '<cmd>'

  format 3:  xt '<cmd>'

  format 4:  x

)O OPERANDS -
 <cmd> is a tso command to be executed in xmode.
  When the command is completed, you will be left in xmode,
  unless the XT alias is used, in which case the terminal
  will return to edit mode once the command is finished.
  NOTE:  If the XT alias is used, you should not try to invoke
  a clist.  If a clist is invoked via XT, the clist will be
  stacked but not executed until you later enter the X
  subcommand.
))PROMPT() - Use this keyword to indicate the phrase you want to be
  be prompted with in xmode.  If not specified, the default is
  ABEX.
))NEW - Indicates that a new virtual data set is to be defined
  to contain the log of tso commands you enter while in xmode.
  Once you return to edit mode, the log will be
  available for editing.
))CONTINUE - Indicates that the log of tso commands you enter
  while in xmode should be added to the current data set.

=XLATE                                                                 @
)F FUNCTION -
 XLATE can  be used to ensure the replacement value of a symbolic
 variable is upper case.
)X SYNTAX
 XLATE <name>
)O OPERANDS -
 <name> is the name of the symbolic variable.

=XOFFSET                                                               @
)F FUNCTION -
  This ABE subcommand allows you to set an offset value which is
  used in the gd and gu subcommands (see above).  The default offset
  value is 0. See Appendix O for details.
)X SYNTAX -
    xoffset <xoffset>
  required - <xoffset>
  defaults - none
  alias    - none
)O OPERANDS - See Appendix O.

=XSCALE                                                                @
)F FUNCTION -
  This ABE subcommand allows you to set a scaling value which is
  used in the gd and gu subcommands (see above).  The default scale
  value is 1. See Appendix O for details.
)X SYNTAX -
    xscale <xscale>
  required - <xscale>
  defaults - none
  alias    - none
)O OPERANDS - See Appendix O.

=YOFFSET                                                               @
)F FUNCTION -
  This ABE subcommand allows you to set an offset value which is
  used in the gd and gu subcommands (see above).  The default offset
  value is 0. See Appendix O for details.
)X SYNTAX -
    yoffset <yoffset>
  required - <yoffset>
  defaults - none
  alias    - none
)O OPERANDS - See Appendix O.

=YSCALE                                                                @
)F FUNCTION -
  This ABE subcommand allows you to set a scaling value which is
  used in the gd and gu subcommands (see above).  The default scale
  value is 1. See Appendix O for details.
)X SYNTAX -
    yscale <yscale>
  required - <yscale>
  defaults - none
  alias    - none
)O OPERANDS - See Appendix O.

=ZCALC                                                                 @
)F FUNCTION -
 ZCALC is identical in function and syntax to the CALC subcommand.
 The difference is that CALC expands all integer results to 5 digits
 by left zero filling, and ZCALC suppresses left zeros on results.
 See appendix I.
)X SYNTAX
 ZCALC <expression>
)O OPERANDS - see appendix I.
