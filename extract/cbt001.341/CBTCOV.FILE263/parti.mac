.he ABE, T. Smith, Part I

Part I                                                                 @


                       A B E  E d i t o r

                         T .  S m i t h

                           P A R T  I

                         T U T O R I A L

LEVEL OF ACCESS                                                        @

The Spring 1988 issue of ABACUS magazine has an article in it
describing "Level of Access," which is an index describing "the
balance in a computer program or system between power and flexibility
on the one hand and simplicity and ease of use on the other."  If
P is the proportion of a given population who can effectively use
any system, then the Level of Access is given by -log10(P).  Thus,
if .1% of all computer users will benefit from attempting to use ABE,
then ABE's Level of Access is 3, which is probably in the quantum
ballpark with the truth.

In other words, this is not an editor for the casual or infrequent
user.  I can practically guarantee you won't find more power in any
other editor, but be prepared for a long and arduous learning curve.

ACKNOWLEDGMENTS                                                        @

Although I had the original idea of a text editor written in PL/I, it
can no longer be said that ABE has a sole author.  Many people have
contributed their ideas. For example, Paul Dixon designed the syntax
for the LSP subcommand, and also wrote the DELDUP and CONTENT
subcommands. Mike Kimps conceived the OPER keyword of the FIND
subcommand. Claude Doud originated the idea for the $SETD RUN
statement. Dick Rettke suggested the displaying of the data set name of
the edited data set on the right end of the command line. Dan Bauman
suggested the facility for splitting a line of text based on the
location of the cursor.

ABOUT THIS MANUAL                                                      @

This manual is in several parts, the first of which is designed to be
tutorial and introductory in nature.  It moves from simple to
progressively more sophisticated examples.  Note that it does not
encompass every possible function that can be performed by ABE.
instead, it tries to give you the flavor of many of the functions
without getting bogged down in a lot of details. The details you can
get from the appendices, and Part II, which is designed to be a
reference and might be used when using ABE at a terminal.

INTRODUCTION                                                           @

ABE is a programming and text editing aid that operates in the TSO
environment and is designed to increase productivity in developing and
modifying programs and other text such as JCL, utility control
statements, etc.  The primary functions that it provides include:

  - Full screen editing which allows multiple lines to be modified in
    a single interaction, and forward, backward, and sideways
    scrolling of source code or other data.
  - Split screen, allowing editing functions to be applied to many
    data sets at the same time.
  - The Structured Query Language common to IBM's DB2 and other DBMS
    systems is incorporated into the subcommand set of the editor,
    allowing the manipulation of data in a relational fashion (see
    Appendix D for details).
  - Pattern recognition/replacement functions similar to those
    available in the SNOBOL programming language are available through
    the SNO subcommand (see Appendix E).
  - All of the APL primitives are available for data manipulation
    through the APL subcommand (see Appendix L).
  - Interactive help facility which selects and generates the
    appropriate subcommand based on a series of questions answered by
    the user at his terminal.

ABE is the successor to SSE (Split Screen Editor).  Essentially, it is
the same editor with a different front end.  One of the complaints
about SSE was the inconsistencies with which operands with the same
meanings had to be entered on different subcommands.  ABE addresses and
hopefully solves a good part of that problem. ABE is an acronym for A
Better Editor.

A syntactical unit called a Line Specification Unit (LSU) can be
prefixed to almost all ABE subcommands.  The LSU specifies which lines
and which positions within those lines are to be processed. If no LSU
is specified, by default all lines and all record positions are
specified.  Thus the subcommand "bl 1" indicates that a blank line is
to be inserted after every line currently in the dataset.  A detailed
discussion of LSUs is in Appendix H.

ABE contains an eclectic selection of functions from other editors, so
you may see functions in ABE you will already be familiar with.  Don't
skip over the explanation of a particular subcommand or function,
however, just because you've seen it elsewhere, because in most cases,
the function was further enhanced as it was incorporated into
ABE.  Thus, the SPLIT and JOIN subcommands for example, which have
counterparts in the VSPC editor, have additional functions under ABE.
the same is also true of the FIND and CHANGE subcommands, which are
patterned after the FIND and CHANGE subcommands of the IBM Structured
Programming Facility.  Another example is the LSP subcommand, which
incorporates concepts from the editor used under the MISTIC system at
Michigan State University.

STARTING AND STOPPING ABE, AND LOOKING BUT NOT TOUCHING                @

ABE operates as a TSO command processor.  A typical TSO command to
invoke ABE is:

     abe 'sys2.proclib(au109208)'

If you are on a 3270 crt-type terminal, the screen will be cleared, and
data as shown on the next page will be displayed (Note: All of the
sample displays in this manual were created using ABE.  The details are
inappropriate at this point, but you can see more about how this was
done by looking up the TRACE subcommand in Part II. Note that the
rightmost part of each display had to be truncated in order to fit it
within the margins on 8.5 X 11-inch paper. Most activity takes place
along the left side of the screen anyway, so this won't be any great
handicap.).  Also, at times lines will be omitted to accommodate the
bottom margin.  When this occurs, it will be indicated by the message
 (lines omitted for brevity)". Now see the display below:

                 1         2         3         4         5         6
        12345678901234567890123456789012345678901234567890123456789012

  PF                                  ×AU109208×SYS2.PROCLIB(AU109208)
       F         Ö Ö Ö Ö Ö Ö Ö Ö Ö Ö Ö Ö Ö
  00010 //* AU109208
  00020 //COPIER EXEC PGM=U058IS01,PARM=YAU109208
  00030 //SYSPRINT DD SYSOUT=A
  00040 //SYSIN DD DSN=SYS2.CNTCARD(U109208A),DISP=SHR
  00050 //GENSMF EXEC PGM=IEBGENER
  00060 //SYSPRINT DD SYSOUT=A
  00070 //SYSIN DD DUMMY
  00080 //SYSUT1 DD DSN=U.SD.U000.MVSSMF,DISP=OLD
  00100 //SYSUT2 DD DSN=&MVSSMF,DISP=(NEW,PASS),UNIT=DISK,SPACE=(CYL,(
  00101 //          DCB=(RECFM=VBS,LRECL=32760,BLKSIZE=19060)
  00111 //ABN EXEC PGM=NONAME,REGION=8K,COND=(0,EQ,GENSMF)
  00120 //SORTSMF EXEC PGM=SORT,PARM='MSG=AP'
  00130 //SYSPRINT DD SYSOUT=*
  00140 //SYSOUT DD SYSOUT=*
  00150 //SORTLIB DD DSN=SYS1.SORTLIB,DISP=SHR
  00160 //SORTWK01 DD UNIT=DISK,SPACE=(CYL,(50,10))
  00170 //SORTWK02 DD UNIT=DISK,SPACE=(CYL,(50,10))
  00180 //SORTWK03 DD UNIT=DISK,SPACE=(CYL,(50,10))
  00190 //SORTIN DD DSN=&MVSSMF,DISP=(OLD,DELETE)

The cursor will be located under the "P" in "PF" in the upper left
corner.  The line containing "PF" is known as the command line, and
this is the location where many ABE subcommands are entered. The "PF"
is printed as an indication of what will happen if you depress the
enter key next without changing anything.  That is, the PF subcommand
will be executed.  PF is an acronym for "page forward," and that is
precisely what the PF subcommand does;  it changes the display so that
the next set of lines in the data set being edited are displayed.

At the right end of the command line, you see a vertical bar (×)
followed by the characters AU109208, followed by another vertical bar,
and the text SYS2.PROCLIB(AU109208).  The text following the first
vertical bar is known as a shorthand name. There will be more about
this later, but briefly, this shorthand name may be used in some ABE
subcommands as a shorthand way of referencing the data set to which
the subcommand is to be applied.

The text following the second vertical bar is the name of the data
set associated with the data being edited.  If you do a SAVE
subcommand without any operands, this is the name of the data
set where the data will be saved.

The next sample you see was produced by hitting enter on the display
shown above without changing anything on the screen):

                 1         2         3         4         5         6
        12345678901234567890123456789012345678901234567890123456789012

  PF                                 ×AU109208×SYS2.PROCLIB(AU109208)×
       F         Ö Ö Ö Ö Ö Ö Ö Ö Ö Ö Ö Ö Ö
  00200 //SORTOUT DD DSN=&SORTSMF,DISP=(NEW,PASS),UNIT=DISK,
  00210 // SPACE=(CYL,(50,10)),DCB=(LRECL=32760,BLKSIZE=19060,RECFM=VB
  00220 //SYSIN DD DSN=SYS2.CNTCARD(U109208B),DISP=SHR
  00230 //ABNSRT EXEC PGM=NONAME,REGION=8K,COND=(0,EQ,SORTSMF)
  00240 //SPLIT EXEC PGM=SMFSPLIT
  00245 //STEPLIB  DD DSN=U.SD.U000.TGSLOAD,DISP=SHR
  00250 //SYSPRINT DD SYSOUT=A
  00260 //SMFDATA DD DSN=&SORTSMF,DISP=(OLD,PASS)
  00270 //D252 DD DSN=K.GA.K0933.VIOLATE,DISP=OLD
  00280 //TGSEDIT EXEC PGM=SMFMVSED
  00290 //STEPLIB DD DSN=U.OC.U0000.OPERLIB,DISP=SHR
  00300 //SYSPRINT DD SYSOUT=A
  00310 //SMFOUT  DD DSN=U.SD.U000.SMFDATA,DISP=OLD
  00320 //SMFDATA DD DSN=&SORTSMF,DISP=(OLD,DELETE)
  00330 //ABN EXEC PGM=NONAME,REGION=8K,COND=(0,EQ,TGSEDIT)
  00340 //SCR EXEC PGM=IEFBR14,REGION=8K
  00350 //SMFDATA DD DSN=U.SD.U000.MVSSMF,UNIT=(,,DEFER),DISP=(OLD,DEL
  00360 //BACKUP EXEC PGM=IEBGENER
  00370 //SYSPRINT DD SYSOUT=A

Hitting enter again:

                 1         2         3         4         5         6
        12345678901234567890123456789012345678901234567890123456789012

  PF                                 ×AU109208×SYS2.PROCLIB(AU109208)×
       F         Ö Ö Ö Ö Ö Ö Ö Ö Ö Ö Ö Ö Ö
  00380 //SYSIN DD DUMMY
  00390 //SYSUT1 DD DSN=U.SD.U000.MVSSMFMO(0),DISP=OLD,VOL=(,RETAIN)
  00400 //SYSUT2 DD DSN=U.SD.U000.MVSSMFBK(+1),DISP=(NEW,CATLG,DELETE)
  00410 // LABEL=EXPDT=99000,UNIT=TAPE,DCB=MODLDSCB,VOL=(,,,5)
  00420 //BACKERR EXEC PGM=NONAME,COND=(0,EQ,BACKUP)
  00430 //HISTORY EXEC PGM=IEBGENER
  00440 //SYSPRINT DD SYSOUT=A
  00450 //SYSIN DD DUMMY
  00460 //SYSUT1 DD DSN=U.SD.U000.SMFDATA,DISP=SHR
  00470 //SYSUT2 DD DSN=U.SD.U000.MVSSMFMO(0),DISP=(MOD,CATLG),
  00480 // LABEL=EXPDT=99000
  00485 //AB2 EXEC PGM=NONAME,REGION=8K,COND=(0,EQ,HISTORY)
  00490 //SPLITA EXEC PGM=SMFSPLIT,REGION=1024K
  00500 //STEPLIB DD DSN=U.SD.U000.TGSLOAD,DISP=SHR
  00510 //SYSPRINT DD SYSOUT=*
  00520 //SMFDATA DD DSN=U.SD.U000.SMFDATA,DISP=SHR
  00530 //D5@35 DD DSN=U.SD.U000.SMF.DAILY.D5@35,DISP=OLD,
  00540 // DCB=(LRECL=6496,BLKSIZE=6500,RECFM=VBS)
  00550 //D4@34 DD DSN=U.SD.U000.SMF.DAILY.D4@34,DISP=OLD,

The data set being edited will continue to be "paged forward" each
time you hit enter without changing anything on the display.  To
change the direction of paging, or in other words, to "page backward",
enter the "PB" subcommand on the command line:

                 1         2         3         4         5         6
        12345678901234567890123456789012345678901234567890123456789012

  pb                                 ×AU109208×SYS2.PROCLIB(AU109208)×
       F         Ö Ö Ö Ö Ö Ö Ö Ö Ö Ö Ö Ö Ö
  00380 //SYSIN DD DUMMY
  00390 //SYSUT1 DD DSN=U.SD.U000.MVSSMFMO(0),DISP=OLD,VOL=(,RETAIN)
  00400 //SYSUT2 DD DSN=U.SD.U000.MVSSMFBK(+1),DISP=(NEW,CATLG,DELETE)
  00410 // LABEL=EXPDT=99000,UNIT=TAPE,DCB=MODLDSCB,VOL=(,,,5)
  00420 //BACKERR EXEC PGM=NONAME,COND=(0,EQ,BACKUP)
  00430 //HISTORY EXEC PGM=IEBGENER
  00440 //SYSPRINT DD SYSOUT=A
  00450 //SYSIN DD DUMMY
  00460 //SYSUT1 DD DSN=U.SD.U000.SMFDATA,DISP=SHR
  00470 //SYSUT2 DD DSN=U.SD.U000.MVSSMFMO(0),DISP=(MOD,CATLG),
  00480 // LABEL=EXPDT=99000
  00485 //AB2 EXEC PGM=NONAME,REGION=8K,COND=(0,EQ,HISTORY)
  00490 //SPLITA EXEC PGM=SMFSPLIT,REGION=1024K
  00500 //STEPLIB DD DSN=U.SD.U000.TGSLOAD,DISP=SHR
  00510 //SYSPRINT DD SYSOUT=*
  00520 //SMFDATA DD DSN=U.SD.U000.SMFDATA,DISP=SHR
  00530 //D5@35 DD DSN=U.SD.U000.SMF.DAILY.D5@35,DISP=OLD,
  00540 // DCB=(LRECL=6496,BLKSIZE=6500,RECFM=VBS)
  00550 //D4@34 DD DSN=U.SD.U000.SMF.DAILY.D4@34,DISP=OLD,

the resulting display:

                 1         2         3         4         5         6
        12345678901234567890123456789012345678901234567890123456789012

  PB                                 ×AU109208×SYS2.PROCLIB(AU109208)×
       F         Ö Ö Ö Ö Ö Ö Ö Ö Ö Ö Ö Ö Ö
  00200 //SORTOUT DD DSN=&SORTSMF,DISP=(NEW,PASS),UNIT=DISK,
  00210 // SPACE=(CYL,(50,10)),DCB=(LRECL=32760,BLKSIZE=19060,RECFM=VB
  00220 //SYSIN DD DSN=SYS2.CNTCARD(U109208B),DISP=SHR
  00230 //ABNSRT EXEC PGM=NONAME,REGION=8K,COND=(0,EQ,SORTSMF)
  00240 //SPLIT EXEC PGM=SMFSPLIT
  00245 //STEPLIB  DD DSN=U.SD.U000.TGSLOAD,DISP=SHR
  00250 //SYSPRINT DD SYSOUT=A
  00260 //SMFDATA DD DSN=&SORTSMF,DISP=(OLD,PASS)
  00270 //D252 DD DSN=K.GA.K0933.VIOLATE,DISP=OLD
  00280 //TGSEDIT EXEC PGM=SMFMVSED
  00290 //STEPLIB DD DSN=U.OC.U0000.OPERLIB,DISP=SHR
  00300 //SYSPRINT DD SYSOUT=A
  00310 //SMFOUT  DD DSN=U.SD.U000.SMFDATA,DISP=OLD
  (data omitted for brevity)

The "PB" on the command line in the display above indicates that
backward paging has commenced, and will continue each time enter is
hit without changing anything.  If you were to continue hitting enter
without changing anything until the top of the display were reached,
then the paging direction will change automatically as follows:

Hitting enter again puts the display at top of data set:

                 1         2         3         4         5         6
        12345678901234567890123456789012345678901234567890123456789012

  PF                                 ×AU109208×SYS2.PROCLIB(AU109208)×
       F         Ö Ö Ö Ö Ö Ö Ö Ö Ö Ö Ö Ö Ö
  00010 //* AU109208
  00020 //COPIER EXEC PGM=U058IS01,PARM=YAU109208
  00030 //SYSPRINT DD SYSOUT=A
  00040 //SYSIN DD DSN=SYS2.CNTCARD(U109208A),DISP=SHR
  00050 //GENSMF EXEC PGM=IEBGENER
  00060 //SYSPRINT DD SYSOUT=A
  00070 //SYSIN DD DUMMY
  00080 //SYSUT1 DD DSN=U.SD.U000.MVSSMF,DISP=OLD
  00100 //SYSUT2 DD DSN=&MVSSMF,DISP=(NEW,PASS),UNIT=DISK,SPACE=(CYL,(
  00101 //          DCB=(RECFM=VBS,LRECL=32760,BLKSIZE=19060)
  00111 //ABN EXEC PGM=NONAME,REGION=8K,COND=(0,EQ,GENSMF)
  00120 //SORTSMF EXEC PGM=SORT,PARM='MSG=AP'
  00130 //SYSPRINT DD SYSOUT=*
  00140 //SYSOUT DD SYSOUT=*
  00150 //SORTLIB DD DSN=SYS1.SORTLIB,DISP=SHR
  00160 //SORTWK01 DD UNIT=DISK,SPACE=(CYL,(50,10))
  00170 //SORTWK02 DD UNIT=DISK,SPACE=(CYL,(50,10))
  00180 //SORTWK03 DD UNIT=DISK,SPACE=(CYL,(50,10))
  00190 //SORTIN DD DSN=&MVSSMF,DISP=(OLD,DELETE)

"Bottom" is another subcommand that can be used to control what lines
are to be displayed.  It tells the editor to display the last page
of the data set as follows:

                 1         2         3         4         5         6
        12345678901234567890123456789012345678901234567890123456789012

  bottom                             ×AU109208×SYS2.PROCLIB(AU109208)
       F         Ö Ö Ö Ö Ö Ö Ö Ö Ö Ö Ö Ö Ö
  00010 //* AU109208
  00020 //COPIER EXEC PGM=U058IS01,PARM=YAU109208
  00030 //SYSPRINT DD SYSOUT=A
  00040 //SYSIN DD DSN=SYS2.CNTCARD(U109208A),DISP=SHR
  00050 //GENSMF EXEC PGM=IEBGENER
  00060 //SYSPRINT DD SYSOUT=A
  (data omitted for brevity)

the resulting display:

                 1         2         3         4         5         6
        12345678901234567890123456789012345678901234567890123456789012

  PB                                 ×AU109208×SYS2.PROCLIB(AU109208)
       F         Ö Ö Ö Ö Ö Ö Ö Ö Ö Ö Ö Ö Ö
  00720 //SYSPRINT DD SYSOUT=A
  00730 //IEFRDER DD DSN=SYS2.JOBPROC(AU109870),DISP=SHR
  00740 //INTRDR DD SYSOUT=(9,INTRDR)
  00750 //JOBRDR   EXEC PGM=JOBRDR
  00760 //SYSPRINT DD SYSOUT=A
  00770 //IEFRDER  DD DSN=SYS2.JOBPROC(AU109500),DISP=SHR
  00780 //INTRDR   DD SYSOUT=(9,INTRDR)
  00790 //JOBRDR   EXEC PGM=JOBRDR
  00800 //SYSPRINT DD SYSOUT=A
  00810 //IEFRDER  DD DSN=SYS2.JOBPROC(AU109545),DISP=SHR
  00820 //INTRDR   DD SYSOUT=(9,INTRDR)
  00830 //JOBRDR   EXEC PGM=JOBRDR
  00840 //SYSPRINT DD SYSOUT=A
  00850 //IEFRDER  DD DSN=SYS2.JOBPROC(AU109659),DISP=SHR
  00860 //INTRDR   DD SYSOUT=(9,INTRDR)
  00870 //JOBRDR   EXEC PGM=JOBRDR
  00871 //SYSPRINT DD SYSOUT=A
  00872 //IEFRDER  DD DSN=ACFUSER.REPORTS.CNTL,DISP=SHR
  00873 //INTRDR   DD SYSOUT=(9,INTRDR)

Another subcommand is "top", which tells the editor to display the
first page in the data set:

                 1         2         3         4         5         6
        12345678901234567890123456789012345678901234567890123456789012

  top                                ×AU109208×SYS2.PROCLIB(AU109208)
       F         Ö Ö Ö Ö Ö Ö Ö Ö Ö Ö Ö Ö Ö
  00720 //SYSPRINT DD SYSOUT=A
  00730 //IEFRDER DD DSN=SYS2.JOBPROC(AU109870),DISP=SHR
  00740 //INTRDR DD SYSOUT=(9,INTRDR)
  00750 //JOBRDR   EXEC PGM=JOBRDR
  00760 //SYSPRINT DD SYSOUT=A
  00770 //IEFRDER  DD DSN=SYS2.JOBPROC(AU109500),DISP=SHR
  00780 //INTRDR   DD SYSOUT=(9,INTRDR)
  00790 //JOBRDR   EXEC PGM=JOBRDR
  00800 //SYSPRINT DD SYSOUT=A
  00810 //IEFRDER  DD DSN=SYS2.JOBPROC(AU109545),DISP=SHR
  00820 //INTRDR   DD SYSOUT=(9,INTRDR)
  00830 //JOBRDR   EXEC PGM=JOBRDR
  00840 //SYSPRINT DD SYSOUT=A
  (data omitted for brevity)


The resulting display:

                 1         2         3         4         5         6
        12345678901234567890123456789012345678901234567890123456789012

  PF                                 ×AU109208×SYS2.PROCLIB(AU109208)
       F         Ö Ö Ö Ö Ö Ö Ö Ö Ö Ö Ö Ö Ö
  00010 //* AU109208
  00020 //COPIER EXEC PGM=U058IS01,PARM=YAU109208
  00030 //SYSPRINT DD SYSOUT=A
  00040 //SYSIN DD DSN=SYS2.CNTCARD(U109208A),DISP=SHR
  00050 //GENSMF EXEC PGM=IEBGENER
  00060 //SYSPRINT DD SYSOUT=A
  00070 //SYSIN DD DUMMY
  00080 //SYSUT1 DD DSN=U.SD.U000.MVSSMF,DISP=OLD
  00100 //SYSUT2 DD DSN=&MVSSMF,DISP=(NEW,PASS),UNIT=DISK,SPACE=(CYL,(
  00101 //          DCB=(RECFM=VBS,LRECL=32760,BLKSIZE=19060)
  00111 //ABN EXEC PGM=NONAME,REGION=8K,COND=(0,EQ,GENSMF)
  00120 //SORTSMF EXEC PGM=SORT,PARM='MSG=AP'
  00130 //SYSPRINT DD SYSOUT=*
  00140 //SYSOUT DD SYSOUT=*
  00150 //SORTLIB DD DSN=SYS1.SORTLIB,DISP=SHR
  00160 //SORTWK01 DD UNIT=DISK,SPACE=(CYL,(50,10))
  00170 //SORTWK02 DD UNIT=DISK,SPACE=(CYL,(50,10))
  00180 //SORTWK03 DD UNIT=DISK,SPACE=(CYL,(50,10))
  00190 //SORTIN DD DSN=&MVSSMF,DISP=(OLD,DELETE)

"FIND" is another subcommand that can be used to move the display. In
the following example, the editor is being asked to move the display
to the first line containing the characters "split". The search for
the next line begins with the top line of the data set ("f" is
short for "find"):

                 1         2         3         4         5         6
        12345678901234567890123456789012345678901234567890123456789012

  f split                            ×AU109208×SYS2.PROCLIB(AU109208)
       F         Ö Ö Ö Ö Ö Ö Ö Ö Ö Ö Ö Ö Ö
  00010 //* AU109208
  00020 //COPIER EXEC PGM=U058IS01,PARM=YAU109208
  00030 //SYSPRINT DD SYSOUT=A
  00040 //SYSIN DD DSN=SYS2.CNTCARD(U109208A),DISP=SHR
  00050 //GENSMF EXEC PGM=IEBGENER
  00060 //SYSPRINT DD SYSOUT=A
  00070 //SYSIN DD DUMMY
  00080 //SYSUT1 DD DSN=U.SD.U000.MVSSMF,DISP=OLD
  00100 //SYSUT2 DD DSN=&MVSSMF,DISP=(NEW,PASS),UNIT=DISK,SPACE=(CYL,(
  (data omitted for brevity)

the resulting display:

                 1         2         3         4         5         6
        12345678901234567890123456789012345678901234567890123456789012

  PF                                 ×AU109208×SYS2.PROCLIB(AU109208)
       F         Ö Ö Ö Ö Ö Ö Ö Ö Ö Ö Ö Ö Ö
  00240 //SPLIT EXEC PGM=SMFSPLIT
  00245 //STEPLIB  DD DSN=U.SD.U000.TGSLOAD,DISP=SHR
  00250 //SYSPRINT DD SYSOUT=A
  00260 //SMFDATA DD DSN=&SORTSMF,DISP=(OLD,PASS)
  00270 //D252 DD DSN=K.GA.K0933.VIOLATE,DISP=OLD
  00280 //TGSEDIT EXEC PGM=SMFMVSED
  00290 //STEPLIB DD DSN=U.OC.U0000.OPERLIB,DISP=SHR
  00300 //SYSPRINT DD SYSOUT=A
  00310 //SMFOUT  DD DSN=U.SD.U000.SMFDATA,DISP=OLD
  00320 //SMFDATA DD DSN=&SORTSMF,DISP=(OLD,DELETE)
  00330 //ABN EXEC PGM=NONAME,REGION=8K,COND=(0,EQ,TGSEDIT)
  00340 //SCR EXEC PGM=IEFBR14,REGION=8K
  00350 //SMFDATA DD DSN=U.SD.U000.MVSSMF,UNIT=(,,DEFER),DISP=(OLD,DEL
  00360 //BACKUP EXEC PGM=IEBGENER
  00370 //SYSPRINT DD SYSOUT=A
  00380 //SYSIN DD DUMMY
  00390 //SYSUT1 DD DSN=U.SD.U000.MVSSMFMO(0),DISP=OLD,VOL=(,RETAIN)
  00400 //SYSUT2 DD DSN=U.SD.U000.MVSSMFBK(+1),DISP=(NEW,CATLG,DELETE)
  00410 // LABEL=EXPDT=99000,UNIT=TAPE,DCB=MODLDSCB,VOL=(,,,5)

If you know the line number you want the display moved to, you can
use the "view" subcommand ("v" for short) as follows:

                 1         2         3         4         5         6
        12345678901234567890123456789012345678901234567890123456789012

  100 v                              ×AU109208×SYS2.PROCLIB(AU109208)
       F         Ö Ö Ö Ö Ö Ö Ö Ö Ö Ö Ö Ö Ö
  00240 //SPLIT EXEC PGM=SMFSPLIT
  00245 //STEPLIB  DD DSN=U.SD.U000.TGSLOAD,DISP=SHR
  00250 //SYSPRINT DD SYSOUT=A
  00260 //SMFDATA DD DSN=&SORTSMF,DISP=(OLD,PASS)
  00270 //D252 DD DSN=K.GA.K0933.VIOLATE,DISP=OLD
  00280 //TGSEDIT EXEC PGM=SMFMVSED
  00290 //STEPLIB DD DSN=U.OC.U0000.OPERLIB,DISP=SHR
  00300 //SYSPRINT DD SYSOUT=A
  00310 //SMFOUT  DD DSN=U.SD.U000.SMFDATA,DISP=OLD
  00320 //SMFDATA DD DSN=&SORTSMF,DISP=(OLD,DELETE)
  00330 //ABN EXEC PGM=NONAME,REGION=8K,COND=(0,EQ,TGSEDIT)
  00340 //SCR EXEC PGM=IEFBR14,REGION=8K
  00350 //SMFDATA DD DSN=U.SD.U000.MVSSMF,UNIT=(,,DEFER),DISP=(OLD,DEL
  (data omitted for brevity)

The resulting display:

                 1         2         3         4         5         6
        12345678901234567890123456789012345678901234567890123456789012

  PF                                 ×AU109208×SYS2.PROCLIB(AU109208)
       F         Ö Ö Ö Ö Ö Ö Ö Ö Ö Ö Ö Ö Ö
  00100 //SYSUT2 DD DSN=&MVSSMF,DISP=(NEW,PASS),UNIT=DISK,SPACE=(CYL,(
  00101 //          DCB=(RECFM=VBS,LRECL=32760,BLKSIZE=19060)
  00111 //ABN EXEC PGM=NONAME,REGION=8K,COND=(0,EQ,GENSMF)
  00120 //SORTSMF EXEC PGM=SORT,PARM='MSG=AP'
  00130 //SYSPRINT DD SYSOUT=*
  00140 //SYSOUT DD SYSOUT=*
  00150 //SORTLIB DD DSN=SYS1.SORTLIB,DISP=SHR
  00160 //SORTWK01 DD UNIT=DISK,SPACE=(CYL,(50,10))
  00170 //SORTWK02 DD UNIT=DISK,SPACE=(CYL,(50,10))
  00180 //SORTWK03 DD UNIT=DISK,SPACE=(CYL,(50,10))
  00190 //SORTIN DD DSN=&MVSSMF,DISP=(OLD,DELETE)
  00200 //SORTOUT DD DSN=&SORTSMF,DISP=(NEW,PASS),UNIT=DISK,
  00210 // SPACE=(CYL,(50,10)),DCB=(LRECL=32760,BLKSIZE=19060,RECFM=VB
  00220 //SYSIN DD DSN=SYS2.CNTCARD(U109208B),DISP=SHR
  00230 //ABNSRT EXEC PGM=NONAME,REGION=8K,COND=(0,EQ,SORTSMF)
  00240 //SPLIT EXEC PGM=SMFSPLIT
  00245 //STEPLIB  DD DSN=U.SD.U000.TGSLOAD,DISP=SHR
  00250 //SYSPRINT DD SYSOUT=A
  00260 //SMFDATA DD DSN=&SORTSMF,DISP=(OLD,PASS)

There are many other ABE subcommands which can be used to move the
display, but this will give you enough to get started. Note that
to end ABE, use the END subcomand as follows:

                 1         2         3         4         5         6
        12345678901234567890123456789012345678901234567890123456789012

  end                                ×AU109208×SYS2.PROCLIB(AU109208)
       F         Ö Ö Ö Ö Ö Ö Ö Ö Ö Ö Ö Ö Ö
  00100 //SYSUT2 DD DSN=&MVSSMF,DISP=(NEW,PASS),UNIT=DISK,SPACE=(CYL,(
  00101 //          DCB=(RECFM=VBS,LRECL=32760,BLKSIZE=19060)
  00111 //ABN EXEC PGM=NONAME,REGION=8K,COND=(0,EQ,GENSMF)
  00120 //SORTSMF EXEC PGM=SORT,PARM='MSG=AP'
  00130 //SYSPRINT DD SYSOUT=*
  00140 //SYSOUT DD SYSOUT=*
  00150 //SORTLIB DD DSN=SYS1.SORTLIB,DISP=SHR
  00160 //SORTWK01 DD UNIT=DISK,SPACE=(CYL,(50,10))
  00170 //SORTWK02 DD UNIT=DISK,SPACE=(CYL,(50,10))
  00180 //SORTWK03 DD UNIT=DISK,SPACE=(CYL,(50,10))
  00190 //SORTIN DD DSN=&MVSSMF,DISP=(OLD,DELETE)
  00200 //SORTOUT DD DSN=&SORTSMF,DISP=(NEW,PASS),UNIT=DISK,
  (data omitted for brevity)

SIMPLE CHANGES AND ADDITIONS                                           @

To illustrate the changing of data in existing lines and adding new
lines to a data set, I will use the data set 'EUP027.JOBCARD.CNTL'.
the ABE command would appear as below. Since my tso userid is
'EUP027', I don't have to specify the name in quotes on the abe
command.  Also, the qualifier '.CNTL' has not been specified because
ABE will automatically supply it:

  abe jobcard

The display will then appear as follows:

                  1         2         3         4         5         6
         1234567890123456789012345678901234567890123456789012345678901

   PB                                     ×JOBCARD×EUP027.JOBCARD.CNTL
        F         Ö Ö Ö Ö Ö Ö Ö Ö Ö Ö Ö Ö Ö
   00020 //EUP02711 JOB (10-338-MISC-027-B4,1),
   00030 // 'SMITH-TC',CLASS=X,MSGCLASS=1,NOTIFY=EUP027

As the following display shows, I have moved the cursor down to:
(1) change the job name from "EUP02711" to "EUP027AB"; (2) change the
job class from "X" to "E"; and (3) to add the statement
"// EXEC PGM=IEFBR14".

                  1         2         3         4         5         6
         1234567890123456789012345678901234567890123456789012345678901

   PB                                     ×JOBCARD×EUP027.JOBCARD.CNTL
        F         Ö Ö Ö Ö Ö Ö Ö Ö Ö Ö Ö Ö Ö
   00020 //EUP027ab JOB (10-338-MISC-027-B4,1),
   00030 // 'SMITH-TC',CLASS=e,MSGCLASS=1,NOTIFY=EUP027
         // exec pgm=iefbr14

After hitting enter, the display will be changed as follows:

                  1         2         3         4         5         6
         1234567890123456789012345678901234567890123456789012345678901

   PB                                     ×JOBCARD×EUP027.JOBCARD.CNTL
        F         Ö Ö Ö Ö Ö Ö Ö Ö Ö Ö Ö Ö Ö
   00020 //EUP027AB JOB (10-338-MISC-027-B4,1),
   00030 // 'SMITH-TC',CLASS=E,MSGCLASS=1,NOTIFY=EUP027
   00031 // EXEC PGM=IEFBR14


At this point, I realize that I want to add one or more statements
following line 30.  To do this, I first enter the BLANK subcommand
(BL for short) to insert two blank lines following line 30.
Note that ABE will renumber automatically to the extent needed to
insert the two blank lines:

                  1         2         3         4         5         6
         1234567890123456789012345678901234567890123456789012345678901

   30 bl 2                                ×JOBCARD×EUP027.JOBCARD.CNTL
        F         Ö Ö Ö Ö Ö Ö Ö Ö Ö Ö Ö Ö Ö
   00020 //EUP027AB JOB (10-338-MISC-027-B4,1),
   00030 // 'SMITH-TC',CLASS=E,MSGCLASS=1,NOTIFY=EUP027
   00031 // EXEC PGM=IEFBR14

and after hitting enter, the display will appear as follows:

                  1         2         3         4         5         6
         1234567890123456789012345678901234567890123456789012345678901

   PB                                     ×JOBCARD×EUP027.JOBCARD.CNTL
        F         Ö Ö Ö Ö Ö Ö Ö Ö Ö Ö Ö Ö Ö
   00020 //EUP027AB JOB (10-338-MISC-027-B4,1),
   00030 // 'SMITH-TC',CLASS=E,MSGCLASS=1,NOTIFY=EUP027
   00031
   00032
   00033 // EXEC PGM=IEFBR14

The cursor will be positioned on the first blank line, numbered 31. I
key in the ROUTE statement, but at the same time, I realize that I
didn't really need two blank lines inserted, so I enter the DELETE
subcommand (DEL for short) to delete line 32.

                  1         2         3         4         5         6
         1234567890123456789012345678901234567890123456789012345678901

   32 del                                 ×JOBCARD×EUP027.JOBCARD.CNTL
        F         Ö Ö Ö Ö Ö Ö Ö Ö Ö Ö Ö Ö Ö
   00020 //EUP027AB JOB (10-338-MISC-027-B4,1),
   00030 // 'SMITH-TC',CLASS=E,MSGCLASS=1,NOTIFY=EUP027
   00031 /*route print remote15
   00032
   00033 // EXEC PGM=IEFBR14


After hitting enter, the display will appear as follows:

                  1         2         3         4         5         6
         1234567890123456789012345678901234567890123456789012345678901

   PB                                     ×JOBCARD×EUP027.JOBCARD.CNTL
        F         Ö Ö Ö Ö Ö Ö Ö Ö Ö Ö Ö Ö Ö
   00020 //EUP027AB JOB (10-338-MISC-027-B4,1),
   00030 // 'SMITH-TC',CLASS=E,MSGCLASS=1,NOTIFY=EUP027
   00031 /*ROUTE PRINT REMOTE15
   00033 // EXEC PGM=IEFBR14

At this point, I want to save the changed data set under data set
name 'EUP027.LASTJCL.CNTL'.  So I enter the SAVE subcommand as
follows (Note that if I had just specified "save" without an operand,
the changes would have been saved back in 'eup027.jobcard.cntl'):

                  1         2         3         4         5         6
         1234567890123456789012345678901234567890123456789012345678901

   save lastjcl.cntl                      ×JOBCARD×EUP027.JOBCARD.CNTL
        F         Ö Ö Ö Ö Ö Ö Ö Ö Ö Ö Ö Ö Ö
   00020 //EUP027AB JOB (10-338-MISC-027-B4,1),
   00030 // 'SMITH-TC',CLASS=E,MSGCLASS=1,NOTIFY=EUP027
   00031 /*ROUTE PRINT REMOTE15
   00033 // EXEC PGM=IEFBR14

After hitting enter, the display will appear as follows:

                 1         2         3         4         5         6
        12345678901234567890123456789012345678901234567890123456789012
 SAVED
  PB                                     ×LASTJCL×EUP027.LASTJCL.CNTL
       F         Ö Ö Ö Ö Ö Ö Ö Ö Ö Ö Ö Ö Ö
  00020 //EUP027AB JOB (10-338-MISC-027-B4,1),
  00030 // 'SMITH-TC',CLASS=E,MSGCLASS=1,NOTIFY=EUP027
  00031 /*ROUTE PRINT REMOTE15
  00033 // EXEC PGM=IEFBR14

If I were to enter the SAVE subcommand again, but without any dsname
operand, ABE would automatically save into data set
 EUP027.LASTJCL.CNTL'.


AID & HELP - GETTING ASSISTANCE AT THE TERMINAL.                       @

You wouldn't have much difficulty remembering the syntax and function
of the subcommands you've been shown so far.  However, you've only
just begun to see the functions you can perform under ABE.  Even the
subcommands shown so far haven't been presented in their entirety.
and there are over 150 subcommands in ABE.

Needless to say, you're going to need some sort of assistance at the
terminal while you are using ABE.  This service is supplied by the HELP
and AID subcommands.

HELP works basically the same under ABE as it does under the IBM
editor. To see HELP data describing the syntax for the DELETE
subcommand, for example, you would enter the following on the display:

                 1         2         3         4         5         6
        12345678901234567890123456789012345678901234567890123456789012

  help delete s                          ×LASTJCL×EUP027.LASTJCL.CNTL
       F         Ö Ö Ö Ö Ö Ö Ö Ö Ö Ö Ö Ö Ö
  00020 //EUP027AB JOB (10-338-MISC-027-B4,1),
  00030 // 'SMITH-TC',CLASS=E,MSGCLASS=1,NOTIFY=EUP027
  00031 /*ROUTE PRINT REMOTE15
  00033 // EXEC PGM=IEFBR14

The next thing that will happen is that the display will be erased,
and the help data for delete will be displayed as follows:

 SYNTAX -
          <lsu> delete <str> not
   required - none
   defaults - none
   alias    - del
 HELP

When you've seen enough, you can return to the display you had when you
entered the HELP subcommand by entering a null line (you can enter a
null line simply by pressing the ENTER key without typing anything on
the display).


                 1         2         3         4         5         6
        12345678901234567890123456789012345678901234567890123456789012

                                         ×LASTJCL×EUP027.LASTJCL.CNTL
       F         Ö Ö Ö Ö Ö Ö Ö Ö Ö Ö Ö Ö Ö
  00020 //EUP027AB JOB (10-338-MISC-027-B4,1),
  00030 // 'SMITH-TC',CLASS=E,MSGCLASS=1,NOTIFY=EUP027
  00031 /*ROUTE PRINT REMOTE15
  00033 // EXEC PGM=IEFBR14

LINE SPECIFICATION UNITS (LSUS) - IMPORTANT                            @

IMPORTANT:  Notice that you don't see anything about how to specify the
line numbers of the lines to delete in the above help data. This is
because the line numbers are specified in the Line Specification Unit
(LSU), which is a standard part of the syntax for almost all ABE
subcommands.  Because the format for LSUs is common to all ABE
subcommands, rather than repeat its description for every subcommand,
it is documented only once in appendix H. You should read Appendix H
before attempting to use ABE.  In fact, if you now first read Appendix
G, which describes the syntactical notation used throughout this
manual, and then Appendix H, you will better understand the rest of
this section.

AID SUBCOMMAND                                                         @

You may find the AID subcommand more useful than HELP.  This is because
it provides "intelligent" assistance.  That is, it is structured to
guide you to the subcommand that will perform the function you want
performed.  To illustrate, suppose I want to duplicate lines 20 thru 33
in the data set above. In the following pages, a sample session is
shown in which AID is used to solve this problem.

Note that the text used in the following sample session was actually
created using ABE AID.  But, for the sake of readability, the format
has been adjusted so that text produced by AID at the terminal is
indented 10 spaces, any responses required from the user at the
terminal will be indented 5 spaces, and my commentary describing what
as happening will be enclosed in parentheses, and will be indented 15
spaces.

To start, you should ensure that file SYSAID is allocated to data set
'X75826.ABE.AID.TEXT'. Then, you invoke AID by entering a dollar sign
($) on the command line as follows:

                 1         2         3         4         5         6
        12345678901234567890123456789012345678901234567890123456789012

  $                                      ×LASTJCL×EUP027.LASTJCL.CNTL
       F         Ö Ö Ö Ö Ö Ö Ö Ö Ö Ö Ö Ö Ö
  00020 //EUP027AB JOB (10-338-MISC-027-B4,1),
  00030 // 'SMITH-TC',CLASS=E,MSGCLASS=1,NOTIFY=EUP027
  00031 /*ROUTE PRINT REMOTE15
  00033 // EXEC PGM=IEFBR14

             (The screen will be cleared, and the following
             will appear):

        ABE subcommands can be separated into the following
        categories:
          1 - MOVING, COPYING, SHIFTING, REARRANGING, ADDING LINES.
          2 - ALTERING EXISTING LINES.
          3 - DISPLAY OF DATASETS AND INFORMATION ABOUT DATASETS.
          4 - EDITING SYSOUT FROM BATCH JOBS: $cc $edit $je $pp $prt
              $purge.
         10 - MISCELLANEOUS:  Various functions of general interest,
              e.g. adding incremental numbers to a range of records.

             (I enter the number "1" to see more information about
              CATEGORY 1):

   1

        CATEGORY 1:
          MOVING, COPYING, SHIFTING, REARRANGING, ADDING LINES.
          The subcategories are:

        1 - MOVING OR COPYING LINES OR PARTS OF LINES.
        2 - REARRANGING OR SHIFTING DATA WITHIN EACH LINE.
        3 - SORTING LINES.
        4 - ADDING NEW LINES:

This process of prompting will continue until a specific subcommand
can be chosen, and then you will be prompted for the appropriate
operands for that subcommand.

Note that if you already know which ABE subcommand you want to use,
but you want to use AID to generate the subcommand, you can do so
directly by entering the subcommand name following a dollar sign on
the command line of the display (e.g. "$ copy").

ENDING ABE WITHOUT SAVING CHANGES.                                     @

If, after making one or more changes within the current data set I
enter the END subcommand as follows:

                 1         2         3         4         5         6
        12345678901234567890123456789012345678901234567890123456789012

  end                                    ×LASTJCL×EUP027.LASTJCL.CNTL
       F         Ö Ö Ö Ö Ö Ö Ö Ö Ö Ö Ö Ö Ö
  00020 //EUP027AB JOB (10-338-MISC-027-B4,1),
  00030 // 'SMITH-TC',CLASS=E,MSGCLASS=1,NOTIFY=EUP027
  00031 /*ROUTE PRINT REMOTE15
  00033 // EXEC PGM=IEFBR14
  00034 //EUP027AB JOB (10-338-MISC-027-B4,1),
  00035 // 'SMITH-TC',CLASS=E,MSGCLASS=1,NOTIFY=EUP027
  00036 /*ROUTE PRINT REMOTE15
  00037 // EXEC PGM=IEFBR14

the result will be the following:

                 1         2         3         4         5         6
        12345678901234567890123456789012345678901234567890123456789012
 ENTER "SAVE" SUBCOMMAND OR "END NOSAVE"
  PB                                     ×LASTJCL×EUP027.LASTJCL.CNTL
       F         Ö Ö Ö Ö Ö Ö Ö Ö Ö Ö Ö Ö Ö
  00020 //EUP027AB JOB (10-338-MISC-027-B4,1),
  00030 // 'SMITH-TC',CLASS=E,MSGCLASS=1,NOTIFY=EUP027
  00031 /*ROUTE PRINT REMOTE15
  00033 // EXEC PGM=IEFBR14
  00034 //EUP027AB JOB (10-338-MISC-027-B4,1),
  00035 // 'SMITH-TC',CLASS=E,MSGCLASS=1,NOTIFY=EUP027
  00036 /*ROUTE PRINT REMOTE15
  00037 // EXEC PGM=IEFBR14

ABE prints out the message as above to warn me that I've made changes
to the data set since the last time I did a SAVE subcommand. In this
case, I don't want to retain the changes, so to return to TSO READY
mode, I reenter the END subcommand with the NOSAVE operand as follows:

                 1         2         3         4         5         6
        12345678901234567890123456789012345678901234567890123456789012
 ENTER "SAVE" SUBCOMMAND OR "END NOSAVE"
  end nosave                             ×LASTJCL×EUP027.LASTJCL.CNTL
       F         Ö Ö Ö Ö Ö Ö Ö Ö Ö Ö Ö Ö Ö
  00020 //EUP027AB JOB (10-338-MISC-027-B4,1),
  00030 // 'SMITH-TC',CLASS=E,MSGCLASS=1,NOTIFY=EUP027
  00031 /*ROUTE PRINT REMOTE15
  00033 // EXEC PGM=IEFBR14
  00034 //EUP027AB JOB (10-338-MISC-027-B4,1),
  00035 // 'SMITH-TC',CLASS=E,MSGCLASS=1,NOTIFY=EUP027
  00036 /*ROUTE PRINT REMOTE15
  00037 // EXEC PGM=IEFBR14

 READY


EDITING MORE THAN ONE DATA SET AT A TIME, AND VERIFY                   @

Many people have found that they often would like to divide the
3270 display screen into sections so they can display several
data sets at the same time.  One instance in which you might
want to do this is when you want to examine the error messages
produced by a compile, and at the same time edit the source to make
appropriate corrections.

Another instance is when you have two different versions of the same
program, and you would like to examine them both at the same time to
see what the differences are.  To illustrate, I have two versions
if a sample PL/I program which are slightly different.  The first is
in data set 'EUP027.ABE.SAMPLE(TESTA)'.  To edit this data set, I
enter the ABE command as follows:

     abe abe.sample(testa)

The display would appear as follows:

                 1         2         3         4         5         6
        12345678901234567890123456789012345678901234567890123456789012

  PB                                   ×TESTA×EUP027.ABE.SAMPLE(TESTA)
       F         Ö Ö Ö Ö Ö Ö Ö Ö Ö Ö Ö Ö Ö
  00010  TESTA:  PROC OPTIONS(MAIN);
  00011    DCL PSTR ENTRY(CHAR(*) VAR, FIXED BIN(15,0))
  00012      RETURNS(FIXED BIN(15,0));
  00031    DCL STR CHAR(80) VAR INIT('(('',100) '' A))');
  00032    I=PSTR(STR,1);
  00033    PUT DATA(I,STR);
  00034    END;

The second version of my source program is in data set
'EUP027.ABE.SAMPLE(TESTB)'.  To get this data set on the display
also, I enter the ABE subcommand on the command line as follows:

                 1         2         3         4         5         6
        12345678901234567890123456789012345678901234567890123456789012

  abe abe.sample(testb)                ×TESTA×EUP027.ABE.SAMPLE(TESTA)
       F         Ö Ö Ö Ö Ö Ö Ö Ö Ö Ö Ö Ö Ö
  00010  TESTA:  PROC OPTIONS(MAIN);
  00011    DCL PSTR ENTRY(CHAR(*) VAR, FIXED BIN(15,0))
  00012      RETURNS(FIXED BIN(15,0));
  00031    DCL STR CHAR(80) VAR INIT('(('',100) '' A))');
  00032    I=PSTR(STR,1);
  00033    PUT DATA(I,STR);
  00034    END;

the display will then appear as follows:

                 1         2         3         4         5         6
        12345678901234567890123456789012345678901234567890123456789012

  PB                                   ×TESTA×EUP027.ABE.SAMPLE(TESTA)
       F         Ö Ö Ö Ö Ö Ö Ö Ö Ö Ö Ö Ö Ö
  00010  TESTA:  PROC OPTION
  00011    DCL PSTR ENTRY(CHAR(*) VAR, FIXED BIN(15,0))
  00012      RETURNS(FIXED BIN(15,0));
  00031    DCL STR CHAR(80) VAR INIT('(('',100) '' A))');
  00032    I=PSTR(STR,1);
  00033    PUT DATA(I,STR);
  00034    END;



  ====>                                ×TESTB×EUP027.ABE.SAMPLE(TESTB)
  00010  TESTB:  PROC OPTIONS(MAIN);
  00011    DCL PSTR ENTRY(CHAR(*) VAR, FIXED BIN(15,0))
  00012      RETURNS(FIXED BIN(15,0));
  00031    DCL STR CHAR(80) VAR INIT('(('',100) '' A))');
  00032    I=PSTB(STR,1);
  00033    PUT DATA(I,STR);
  00034    END;

As you can see above, the screen now displays two data sets.  Each
data set on the display has its own command line.  In the case of the
top data set, the command line is the one containing the string "PB".
the second command line is the one on which occurs the string
 ====>".

Now, to locate differences between the two data sets, I use the
VERIFY subcommand:

                 1         2         3         4         5         6
        12345678901234567890123456789012345678901234567890123456789012

  verify                               ×TESTA×EUP027.ABE.SAMPLE(TESTA)
       F         Ö Ö Ö Ö Ö Ö Ö Ö Ö Ö Ö Ö Ö
  00010  TESTA:  PROC OPTIONS(MAIN);
  00011    DCL PSTR ENTRY(CHAR(*) VAR, FIXED BIN(15,0))
  00012      RETURNS(FIXED BIN(15,0));
  00031    DCL STR CHAR(80) VAR INIT('(('',100) '' A))');
  00032    I=PSTR(STR,1);
  00033    PUT DATA(I,STR);
  00034    END;



  ====>                                ×TESTB×EUP027.ABE.SAMPLE(TESTB)
  00010  TESTB:  PROC OPTIONS(MAIN);
  00011    DCL PSTR ENTRY(CHAR(*) VAR, FIXED BIN(15,0))
  00012      RETURNS(FIXED BIN(15,0));
  00031    DCL STR CHAR(80) VAR INIT('(('',100) '' A))');
  00032    I=PSTB(STR,1);
  00033    PUT DATA(I,STR);
  00034    END;

the resulting display:

                 1         2         3         4         5         6
        12345678901234567890123456789012345678901234567890123456789012
 NOT VERIFIED
  PB                                   ×TESTA×EUP027.ABE.SAMPLE(TESTA)
       F         Ö Ö Ö Ö Ö Ö Ö Ö Ö Ö Ö Ö Ö
  00032    I=PSTR(STR,1);
  00033    PUT DATA(I,STR);
  00034    END;







  ====>                                ×TESTB×EUP027.ABE.SAMPLE(TESTB)
  00032    I=PSTB(STR,1);
  00033    PUT DATA(I,STR);
  00034    END;


As you can see above, line 32 in TESTA has string "PSTR", whereas
line 32 in TESTB has string "PSTB".  To find the next difference,
I enter the VERIFY subcommand again:

                 1         2         3         4         5         6
        12345678901234567890123456789012345678901234567890123456789012
 NOT VERIFIED
  verify                               ×TESTA×EUP027.ABE.SAMPLE(TESTA)
       F         Ö Ö Ö Ö Ö Ö Ö Ö Ö Ö Ö Ö Ö
  00032    I=PSTR(STR,1);
  00033    PUT DATA(I,STR);
  00034    END;







  ====>                                ×TESTB×EUP027.ABE.SAMPLE(TESTB)
  00032    I=PSTB(STR,1);
  00033    PUT DATA(I,STR);
  00034    END;

the resulting display:

                 1         2         3         4         5         6
        12345678901234567890123456789012345678901234567890123456789012
 VERIFIED
  PB                                   ×TESTA×EUP027.ABE.SAMPLE(TESTA)
       F         Ö Ö Ö Ö Ö Ö Ö Ö Ö Ö Ö Ö Ö










  ====>                                ×TESTB×EUP027.ABE.SAMPLE(TESTB)

As you can see above, when the VERIFY subcommand reaches the end of
the data set without finding any more differences, it prints out
the message "VERIFIED".


THE "ALL" AND "A" KEYWORDS, AND THE NAME SUBCOMMANDS                   @

Now suppose I want to view the top of both data sets on the display.
I can do this as follows:

                 1         2         3         4         5         6
        12345678901234567890123456789012345678901234567890123456789012
 VERIFIED
  all top                              ×TESTA×EUP027.ABE.SAMPLE(TESTA)
       F         Ö Ö Ö Ö Ö Ö Ö Ö Ö Ö Ö Ö Ö










  ====>                                ×TESTB×EUP027.ABE.SAMPLE(TESTB)

the resulting display:

                 1         2         3         4         5         6
        12345678901234567890123456789012345678901234567890123456789012

  PB                                   ×TESTA×EUP027.ABE.SAMPLE(TESTA)
       F         Ö Ö Ö Ö Ö Ö Ö Ö Ö Ö Ö Ö Ö
  00010  TESTA:  PROC OPTIONS(MAIN);
  00011    DCL PSTR ENTRY(CHAR(*) VAR, FIXED BIN(15,0))
  00012      RETURNS(FIXED BIN(15,0));
  00031    DCL STR CHAR(80) VAR INIT('(('',100) '' A))');
  00032    I=PSTR(STR,1);
  00033    PUT DATA(I,STR);
  00034    END;



  ====>                                ×TESTB×EUP027.ABE.SAMPLE(TESTB)
  00010  TESTB:  PROC OPTIONS(MAIN);
  00011    DCL PSTR ENTRY(CHAR(*) VAR, FIXED BIN(15,0))
  00012      RETURNS(FIXED BIN(15,0));
  00031    DCL STR CHAR(80) VAR INIT('(('',100) '' A))');
  00032    I=PSTB(STR,1);
  00033    PUT DATA(I,STR);
  00034    END;

The ALL keyword prefixed to any subcommand entered on any command line
(such as the TOP subcommand above) tells ABE that the subcommand is to
be applied to every data set currently being edited.

You may recall mentioned earlier the shorthand name associated with a
data set.  This shorthand name appears to the right of the first
vertical bar (×) on the command line.  ABE assigns a default shorthand
name initially to each data set, but you can override. One way of
assigning this name (which must be 8 characters or less) is through
the NAME subcommand as follows (next page):

                 1         2         3         4         5         6
        12345678901234567890123456789012345678901234567890123456789012

  name aaaaa                           ×TESTA×EUP027.ABE.SAMPLE(TESTA)
       F         Ö Ö Ö Ö Ö Ö Ö Ö Ö Ö Ö Ö Ö
  00010  TESTA:  PROC OPTIONS(MAIN);
  00011    DCL PSTR ENTRY(CHAR(*) VAR, FIXED BIN(15,0))
  00012      RETURNS(FIXED BIN(15,0));
  00031    DCL STR CHAR(80) VAR INIT('(('',100) '' A))');
  00032    I=PSTR(STR,1);
  00033    PUT DATA(I,STR);
  00034    END;



  ====> name bbbbb                     ×TESTB×EUP027.ABE.SAMPLE(TESTB)
  00010  TESTB:  PROC OPTIONS(MAIN);
  00011    DCL PSTR ENTRY(CHAR(*) VAR, FIXED BIN(15,0))
  00012      RETURNS(FIXED BIN(15,0));
  00031    DCL STR CHAR(80) VAR INIT('(('',100) '' A))');
  00032    I=PSTB(STR,1);
  00033    PUT DATA(I,STR);
  00034    END;

the resulting display:

                 1         2         3         4         5         6
        12345678901234567890123456789012345678901234567890123456789012

  PB                                   ×AAAAA×EUP027.ABE.SAMPLE(TESTA)
       F         Ö Ö Ö Ö Ö Ö Ö Ö Ö Ö Ö Ö Ö
  00010  TESTA:  PROC OPTIONS(MAIN);
  00011    DCL PSTR ENTRY(CHAR(*) VAR, FIXED BIN(15,0))
  00012      RETURNS(FIXED BIN(15,0));
  00031    DCL STR CHAR(80) VAR INIT('(('',100) '' A))');
  00032    I=PSTR(STR,1);
  00033    PUT DATA(I,STR);
  00034    END;



  ====>                                ×BBBBB×EUP027.ABE.SAMPLE(TESTB)
  00010  TESTB:  PROC OPTIONS(MAIN);
  00011    DCL PSTR ENTRY(CHAR(*) VAR, FIXED BIN(15,0))
  00012      RETURNS(FIXED BIN(15,0));
  00031    DCL STR CHAR(80) VAR INIT('(('',100) '' A))');
  00032    I=PSTB(STR,1);
  00033    PUT DATA(I,STR);
  00034    END;


As you can see above, the names specified with the NAME subcommand now
appear on the display where "TESTA" and "TESTB" were before. These
short hand names are essential in the use of many of the ABE
subcommands.  One of the simplest uses of these names is in conjunction
with the "A" keyword prefix to a subcommand. It tells ABE to apply the
subcommand to a different data set than the one owning the command line
on which the subcommand is entered. For example, suppose I wanted to
enter the END subcommand for data set with symbolic name TESTB as in
the display above.  I could move the cursor down to the second command
line to enter the END subcommand, or I could do as follows:

                 1         2         3         4         5         6
        12345678901234567890123456789012345678901234567890123456789012

  a bbbbb end                          ×AAAAA×EUP027.ABE.SAMPLE(TESTA)
       F         Ö Ö Ö Ö Ö Ö Ö Ö Ö Ö Ö Ö Ö
  00010  TESTA:  PROC OPTIONS(MAIN);
  00011    DCL PSTR ENTRY(CHAR(*) VAR, FIXED BIN(15,0))
  00012      RETURNS(FIXED BIN(15,0));
  00031    DCL STR CHAR(80) VAR INIT('(('',100) '' A))');
  00032    I=PSTR(STR,1);
  00033    PUT DATA(I,STR);
  00034    END;



  ====>                                ×BBBBB×EUP027.ABE.SAMPLE(TESTB)
  00010  TESTB:  PROC OPTIONS(MAIN);
  00011    DCL PSTR ENTRY(CHAR(*) VAR, FIXED BIN(15,0))
  00012      RETURNS(FIXED BIN(15,0));
  (lines omitted for brevity)

the resulting display:

                 1         2         3         4         5         6
        12345678901234567890123456789012345678901234567890123456789012

  PB                                   ×AAAAA×EUP027.ABE.SAMPLE(TESTA)
       F         Ö Ö Ö Ö Ö Ö Ö Ö Ö Ö Ö Ö Ö
  00010  TESTA:  PROC OPTIONS(MAIN);
  00011    DCL PSTR ENTRY(CHAR(*) VAR, FIXED BIN(15,0))
  00012      RETURNS(FIXED BIN(15,0));
  00031    DCL STR CHAR(80) VAR INIT('(('',100) '' A))');
  00032    I=PSTR(STR,1);
  00033    PUT DATA(I,STR);
  00034    END;

As you can see above, editing for the data set associated with symbolic
name BBBBB was terminated by entering "a bbbbb end" on the first
command line.

HEADIER STUFF:  FORMATTING JCL.                                        @

Up to now, you've only been shown some of the more basic things ABE can
do.  Now you'll see some trickier stuff.  In the sample session that
follows, we will step through the ABE subcommands necessary to change
some JCL written in free-form style into a more rigid, columnar format.
Then you'll see how this same series of subcommands can be stored and
executed under one name, sort of like a clist under IBM TSO editor.

The first subcommand is REN, which renumbers the
data set so that the first line is sequence 10, the second 20, etc,

                 1         2         3         4         5         6
        12345678901234567890123456789012345678901234567890123456789012

  REN 10 10                               ×ORIG×SYS2.PROCLIB(AU109209)
       F         Ö Ö Ö Ö Ö Ö Ö Ö Ö Ö Ö Ö Ö
  00010 //* AU109209
  00020 //STEP1 EXEC PGM=U058IS01,PARM='YAU109209',REGION=8K
  00031 //SYSPRINT DD SYSOUT=A
  00040 //SYSIN DD DSN=SYS2.CNTCARD(U109209J),DISP=SHR
  00055 //STEP2 EXEC PGM=U058IS01,PARM='YAU109209',REGION=8K
  00060 //SYSPRINT DD SYSOUT=(A,,A413),COPIES=(1,(1,1,1,1,1,1))
  00070 //SYSIN DD DSN=SYS2.CNTCARD(U109209B),DISP=SHR
  00081 //SORT1 EXEC PGM=SORT
  (lines omitted for brevity)

the resulting display:

                 1         2         3         4         5         6
        12345678901234567890123456789012345678901234567890123456789012

  PF                                      ×ORIG×SYS2.PROCLIB(AU109209)
       F                                                        Ö Ö Ö
  00010 //* AU109209
  00020 //STEP1 EXEC PGM=U058IS01,PARM='YAU109209',REGION=8K
  00030 //SYSPRINT DD SYSOUT=A
  00040 //SYSIN DD DSN=SYS2.CNTCARD(U109209J),DISP=SHR
  00050 //STEP2 EXEC PGM=U058IS01,PARM='YAU109209',REGION=8K
  00060 //SYSPRINT DD SYSOUT=(A,,A413),COPIES=(1,(1,1,1,1,1,1))
  00070 //SYSIN DD DSN=SYS2.CNTCARD(U109209B),DISP=SHR
  00080 //SORT1 EXEC PGM=SORT
  00090 //SYSPRINT DD SYSOUT=A
  00100 //SYSOUT DD SYSOUT=A
  00110 //SORTWK01 DD UNIT=DISK,SPACE=(CYL,(10))
  00120 //SORTWK02 DD UNIT=DISK,SPACE=(CYL,(10))
  00130 //SORTWK03 DD UNIT=DISK,SPACE=(CYL,(10))
  (lines omitted for brevity)

Next, the FIND subcommand is used to eliminate any lines in the data
set which do not begin with "//" in column 1.  The way this is done is
that all lines with "//" in column 1 will be copied to a new virtual
data set which will appear in the second half of the screen.  This
"virtual data set" is the one that will be changed, and later a
subcommand called "MB" will be used to restore the altered lines back
in the original data set:

                 1         2         3         4         5         6
        12345678901234567890123456789012345678901234567890123456789012

  f // 1 all name(tmp)                    ×ORIG×SYS2.PROCLIB(AU109209)
       F                                                        Ö Ö Ö
  00010 //* AU109209
  00020 //STEP1 EXEC PGM=U058IS01,PARM='YAU109209',REGION=8K
  00030 //SYSPRINT DD SYSOUT=A
  (lines omitted for brevity)

the resulting display:

                 1         2         3         4         5         6
        12345678901234567890123456789012345678901234567890123456789012

  PF                                      ×ORIG×SYS2.PROCLIB(AU109209)
       F                                                        Ö Ö Ö
  00010 //* AU109209
  00020 //STEP1 EXEC PGM=U058IS01,PARM='YAU109209',REGION=8K
  00030 //SYSPRINT DD SYSOUT=A
  00040 //SYSIN DD DSN=SYS2.CNTCARD(U109209J),DISP=SHR
  00050 //STEP2 EXEC PGM=U058IS01,PARM='YAU109209',REGION=8K
  00060 //SYSPRINT DD SYSOUT=(A,,A413),COPIES=(1,(1,1,1,1,1,1))
  00070 //SYSIN DD DSN=SYS2.CNTCARD(U109209B),DISP=SHR
  00080 //SORT1 EXEC PGM=SORT
  00090 //SYSPRINT DD SYSOUT=A
  00100 //SYSOUT DD SYSOUT=A
  ====>                                                        ×TMP××
  00010 //* AU109209
  00020 //STEP1 EXEC PGM=U058IS01,PARM='YAU109209',REGION=8K
  00030 //SYSPRINT DD SYSOUT=A
  00040 //SYSIN DD DSN=SYS2.CNTCARD(U109209J),DISP=SHR
  00050 //STEP2 EXEC PGM=U058IS01,PARM='YAU109209',REGION=8K
  00060 //SYSPRINT DD SYSOUT=(A,,A413),COPIES=(1,(1,1,1,1,1,1))
  00070 //SYSIN DD DSN=SYS2.CNTCARD(U109209B),DISP=SHR
  00080 //SORT1 EXEC PGM=SORT

Since we temporarily don't need the original data set, we can eliminate
it from the display without ending edit for it altogether (next page):

                 1         2         3         4         5         6
        12345678901234567890123456789012345678901234567890123456789012

  lines                                   ×ORIG×SYS2.PROCLIB(AU109209)
       F                                                        Ö Ö Ö
  00010 //* AU109209
  00020 //STEP1 EXEC PGM=U058IS01,PARM='YAU109209',REGION=8K
  00030 //SYSPRINT DD SYSOUT=A
  00040 //SYSIN DD DSN=SYS2.CNTCARD(U109209J),DISP=SHR
  00050 //STEP2 EXEC PGM=U058IS01,PARM='YAU109209',REGION=8K
  00060 //SYSPRINT DD SYSOUT=(A,,A413),COPIES=(1,(1,1,1,1,1,1))
  00070 //SYSIN DD DSN=SYS2.CNTCARD(U109209B),DISP=SHR
  00080 //SORT1 EXEC PGM=SORT
  00090 //SYSPRINT DD SYSOUT=A
  00100 //SYSOUT DD SYSOUT=A
  ====>                                                       ×TMP××
  00010 //* AU109209
  00020 //STEP1 EXEC PGM=U058IS01,PARM='YAU109209',REGION=8K
  00030 //SYSPRINT DD SYSOUT=A
  00040 //SYSIN DD DSN=SYS2.CNTCARD(U109209J),DISP=SHR
  00050 //STEP2 EXEC PGM=U058IS01,PARM='YAU109209',REGION=8K
  00060 //SYSPRINT DD SYSOUT=(A,,A413),COPIES=(1,(1,1,1,1,1,1))
  00070 //SYSIN DD DSN=SYS2.CNTCARD(U109209B),DISP=SHR
  00080 //SORT1 EXEC PGM=SORT

the resulting display:

                 1         2         3         4         5         6
        12345678901234567890123456789012345678901234567890123456789012

  PF                                                           ×TMP××
       F                                                        Ö Ö Ö
  00010 //* AU109209
  00020 //STEP1 EXEC PGM=U058IS01,PARM='YAU109209',REGION=8K
  00030 //SYSPRINT DD SYSOUT=A
  00040 //SYSIN DD DSN=SYS2.CNTCARD(U109209J),DISP=SHR
  00050 //STEP2 EXEC PGM=U058IS01,PARM='YAU109209',REGION=8K
  00060 //SYSPRINT DD SYSOUT=(A,,A413),COPIES=(1,(1,1,1,1,1,1))
  00070 //SYSIN DD DSN=SYS2.CNTCARD(U109209B),DISP=SHR
  00080 //SORT1 EXEC PGM=SORT
  00090 //SYSPRINT DD SYSOUT=A
  00100 //SYSOUT DD SYSOUT=A
  00110 //SORTWK01 DD UNIT=DISK,SPACE=(CYL,(10))
  00120 //SORTWK02 DD UNIT=DISK,SPACE=(CYL,(10))
  00130 //SORTWK03 DD UNIT=DISK,SPACE=(CYL,(10))
  00140 //SORTIN DD DISP=SHR,DSN=U.SD.U000.SMFDATA
  00150 //SORTOUT DD UNIT=DISK,DISP=(,PASS),
  00160 // SPACE=(CYL,(10)),
  00170 // DSN=&&SMF,
  00180 // DCB=(RECFM=VB,LRECL=4096,BLKSIZE=6440)
  00190 //SYSIN DD DISP=SHR,DSN=SYS2.CNTCARD(U109209E)

The temporary data set on the screen contains only lines from the
original data set that contain "//" in column one.  But this includes
comments statements (beginning with "//*"), which we don't want to
mess with.  So we eliminate them with the following find subcommand:

                 1         2         3         4         5         6
        12345678901234567890123456789012345678901234567890123456789012

  f * 3 not all name(form)                                      ×TMP××
       F                                                        Ö Ö Ö
  00010 //* AU109209
  00020 //STEP1 EXEC PGM=U058IS01,PARM='YAU109209',REGION=8K
  00030 //SYSPRINT DD SYSOUT=A
  00040 //SYSIN DD DSN=SYS2.CNTCARD(U109209J),DISP=SHR
  00050 //STEP2 EXEC PGM=U058IS01,PARM='YAU109209',REGION=8K
  00060 //SYSPRINT DD SYSOUT=(A,,A413),COPIES=(1,(1,1,1,1,1,1))
  00070 //SYSIN DD DSN=SYS2.CNTCARD(U109209B),DISP=SHR
  00080 //SORT1 EXEC PGM=SORT
  00090 //SYSPRINT DD SYSOUT=A
  00100 //SYSOUT DD SYSOUT=A
  00110 //SORTWK01 DD UNIT=DISK,SPACE=(CYL,(10))
  (lines omitted for brevity)

the resulting display:

                 1         2         3         4         5         6
        12345678901234567890123456789012345678901234567890123456789012

  PF                                                            ×TMP××
       F         Ö Ö Ö Ö Ö Ö Ö Ö Ö Ö Ö Ö Ö
  00010 //* AU109209
  00020 //STEP1 EXEC PGM=U058IS01,PARM='YAU109209',REGION=8K
  00030 //SYSPRINT DD SYSOUT=A
  00040 //SYSIN DD DSN=SYS2.CNTCARD(U109209J),DISP=SHR
  00050 //STEP2 EXEC PGM=U058IS01,PARM='YAU109209',REGION=8K
  00060 //SYSPRINT DD SYSOUT=(A,,A413),COPIES=(1,(1,1,1,1,1,1))
  00070 //SYSIN DD DSN=SYS2.CNTCARD(U109209B),DISP=SHR
  00080 //SORT1 EXEC PGM=SORT
  00090 //SYSPRINT DD SYSOUT=A
  00100 //SYSOUT DD SYSOUT=A
  ====>                                                     ×FORM××
  00020 //STEP1 EXEC PGM=U058IS01,PARM='YAU109209',REGION=8K
  00030 //SYSPRINT DD SYSOUT=A
  00040 //SYSIN DD DSN=SYS2.CNTCARD(U109209J),DISP=SHR
  00050 //STEP2 EXEC PGM=U058IS01,PARM='YAU109209',REGION=8K
  00060 //SYSPRINT DD SYSOUT=(A,,A413),COPIES=(1,(1,1,1,1,1,1))
  00070 //SYSIN DD DSN=SYS2.CNTCARD(U109209B),DISP=SHR
  00080 //SORT1 EXEC PGM=SORT
  00090 //SYSPRINT DD SYSOUT=A

We can now get rid of the temporary data set containing comments as
well as JCL statements as follows:

                 1         2         3         4         5         6
        12345678901234567890123456789012345678901234567890123456789012

  end n                                                         ×TMP××
       F         Ö Ö Ö Ö Ö Ö Ö Ö Ö Ö Ö Ö Ö
  00010 //* AU109209
  00020 //STEP1 EXEC PGM=U058IS01,PARM='YAU109209',REGION=8K
  00030 //SYSPRINT DD SYSOUT=A
  00040 //SYSIN DD DSN=SYS2.CNTCARD(U109209J),DISP=SHR
  00050 //STEP2 EXEC PGM=U058IS01,PARM='YAU109209',REGION=8K
  00060 //SYSPRINT DD SYSOUT=(A,,A413),COPIES=(1,(1,1,1,1,1,1))
  00070 //SYSIN DD DSN=SYS2.CNTCARD(U109209B),DISP=SHR
  00080 //SORT1 EXEC PGM=SORT
  00090 //SYSPRINT DD SYSOUT=A
  00100 //SYSOUT DD SYSOUT=A
  ====>                                                        ×FORM××
  00020 //STEP1 EXEC PGM=U058IS01,PARM='YAU109209',REGION=8K
  00030 //SYSPRINT DD SYSOUT=A
  (lines omitted for brevity)

the resulting display:

                 1         2         3         4         5         6
        12345678901234567890123456789012345678901234567890123456789012

  PF                                                           ×FORM××
       F         Ö Ö Ö Ö Ö Ö Ö Ö Ö Ö Ö Ö Ö
  00020 //STEP1 EXEC PGM=U058IS01,PARM='YAU109209',REGION=8K
  00030 //SYSPRINT DD SYSOUT=A
  00040 //SYSIN DD DSN=SYS2.CNTCARD(U109209J),DISP=SHR
  00050 //STEP2 EXEC PGM=U058IS01,PARM='YAU109209',REGION=8K
  00060 //SYSPRINT DD SYSOUT=(A,,A413),COPIES=(1,(1,1,1,1,1,1))
  00070 //SYSIN DD DSN=SYS2.CNTCARD(U109209B),DISP=SHR
  00080 //SORT1 EXEC PGM=SORT
  00090 //SYSPRINT DD SYSOUT=A
  00100 //SYSOUT DD SYSOUT=A
  00110 //SORTWK01 DD UNIT=DISK,SPACE=(CYL,(10))
  00120 //SORTWK02 DD UNIT=DISK,SPACE=(CYL,(10))
  00130 //SORTWK03 DD UNIT=DISK,SPACE=(CYL,(10))
  00140 //SORTIN DD DISP=SHR,DSN=U.SD.U000.SMFDATA
  00150 //SORTOUT DD UNIT=DISK,DISP=(,PASS),
  00160 // SPACE=(CYL,(10)),
  00170 // DSN=&&SMF,
  00180 // DCB=(RECFM=VB,LRECL=4096,BLKSIZE=6440)
  00190 //SYSIN DD DISP=SHR,DSN=SYS2.CNTCARD(U109209E)
  00200 //STEP5 EXEC PGM=U0378

Now we want to replace each string of two or more blanks with a single
blank.  This will give us a more predictable format to deal with in
some of the later commands.  The following CHANGE (C for short)
subcommand replaces all strings of two blanks ('  ') with a single
blank (' ').

                 1         2         3         4         5         6
        12345678901234567890123456789012345678901234567890123456789012

  c '  ' ' '                                                   ×FORM××
  FORM           Ö Ö Ö Ö Ö Ö Ö Ö Ö Ö Ö Ö Ö
  00020 //STEP1 EXEC PGM=U058IS01,PARM='YAU109209',REGION=8K
  00030 //SYSPRINT DD SYSOUT=A
  00040 //SYSIN DD DSN=SYS2.CNTCARD(U109209J),DISP=SHR
  00050 //STEP2 EXEC PGM=U058IS01,PARM='YAU109209',REGION=8K
  00060 //SYSPRINT DD SYSOUT=(A,,A413),COPIES=(1,(1,1,1,1,1,1))
  00070 //SYSIN DD DSN=SYS2.CNTCARD(U109209B),DISP=SHR
  00080 //SORT1 EXEC PGM=SORT
  00090 //SYSPRINT DD SYSOUT=A
  00100 //SYSOUT DD SYSOUT=A
  00110 //SORTWK01 DD UNIT=DISK,SPACE=(CYL,(10))
  00120 //SORTWK02 DD UNIT=DISK,SPACE=(CYL,(10))
  00130 //SORTWK03 DD UNIT=DISK,SPACE=(CYL,(10))
  00140 //SORTIN DD DISP=SHR,DSN=U.SD.U000.SMFDATA
  00150 //SORTOUT DD UNIT=DISK,DISP=(,PASS),
  00160 // SPACE=(CYL,(10)),
  00170 // DSN=&&SMF,
  00180 // DCB=(RECFM=VB,LRECL=4096,BLKSIZE=6440)
  00190 //SYSIN DD DISP=SHR,DSN=SYS2.CNTCARD(U109209E)
  00200 //STEP5 EXEC PGM=U0378

the resulting display:

                 1         2         3         4         5         6
        12345678901234567890123456789012345678901234567890123456789012
 TEXT NOT FOUND
  PF                                                           ×FORM××
       F         Ö Ö Ö Ö Ö Ö Ö Ö Ö Ö Ö Ö Ö
  00020 //STEP1 EXEC PGM=U058IS01,PARM='YAU109209',REGION=8K
  00030 //SYSPRINT DD SYSOUT=A
  00040 //SYSIN DD DSN=SYS2.CNTCARD(U109209J),DISP=SHR
  00050 //STEP2 EXEC PGM=U058IS01,PARM='YAU109209',REGION=8K
  00060 //SYSPRINT DD SYSOUT=(A,,A413),COPIES=(1,(1,1,1,1,1,1))
  00070 //SYSIN DD DSN=SYS2.CNTCARD(U109209B),DISP=SHR
  00080 //SORT1 EXEC PGM=SORT
  00090 //SYSPRINT DD SYSOUT=A
  (lines omitted for brevity)

As you can see above, CHANGE didn't find any repeating strings.
To it put out an error message and returned control to the user at
the terminal.  Next, we want to adjust the data in each line so that
the first blank appears in column 12.  Why this needs to be done will
become apparent later.  To do this, we use the AC subcommand
(stands for "adjust column") as follows:

                 1         2         3         4         5         6
        12345678901234567890123456789012345678901234567890123456789012
 TEXT NOT FOUND
  ac ' ' 12                                                    ×FORM××
       F         Ö Ö Ö Ö Ö Ö Ö Ö Ö Ö Ö Ö Ö
  00020 //STEP1 EXEC PGM=U058IS01,PARM='YAU109209',REGION=8K
  00030 //SYSPRINT DD SYSOUT=A
  00040 //SYSIN DD DSN=SYS2.CNTCARD(U109209J),DISP=SHR
  00050 //STEP2 EXEC PGM=U058IS01,PARM='YAU109209',REGION=8K
  00060 //SYSPRINT DD SYSOUT=(A,,A413),COPIES=(1,(1,1,1,1,1,1))
  00070 //SYSIN DD DSN=SYS2.CNTCARD(U109209B),DISP=SHR
  00080 //SORT1 EXEC PGM=SORT
  00090 //SYSPRINT DD SYSOUT=A
  00100 //SYSOUT DD SYSOUT=A
  (lines omitted for brevity)

the resulting display:

                 1         2         3         4         5         6
        12345678901234567890123456789012345678901234567890123456789012

  PF                                                           ×FORM××
       F         Ö Ö Ö Ö Ö Ö Ö Ö Ö Ö Ö Ö Ö
  00020     //STEP1 EXEC PGM=U058IS01,PARM='YAU109209',REGION=8K
  00030  //SYSPRINT DD SYSOUT=A
  00040     //SYSIN DD DSN=SYS2.CNTCARD(U109209J),DISP=SHR
  00050     //STEP2 EXEC PGM=U058IS01,PARM='YAU109209',REGION=8K
  00060  //SYSPRINT DD SYSOUT=(A,,A413),COPIES=(1,(1,1,1,1,1,1))
  00070     //SYSIN DD DSN=SYS2.CNTCARD(U109209B),DISP=SHR
  00080     //SORT1 EXEC PGM=SORT
  00090  //SYSPRINT DD SYSOUT=A
  00100    //SYSOUT DD SYSOUT=A
  00110  //SORTWK01 DD UNIT=DISK,SPACE=(CYL,(10))
  00120  //SORTWK02 DD UNIT=DISK,SPACE=(CYL,(10))
  00130  //SORTWK03 DD UNIT=DISK,SPACE=(CYL,(10))
  00140    //SORTIN DD DISP=SHR,DSN=U.SD.U000.SMFDATA
  00150   //SORTOUT DD UNIT=DISK,DISP=(,PASS),
  00160          // SPACE=(CYL,(10)),
  00170          // DSN=&&SMF,
  00180          // DCB=(RECFM=VB,LRECL=4096,BLKSIZE=6440)
  00190     //SYSIN DD DISP=SHR,DSN=SYS2.CNTCARD(U109209E)
  00200     //STEP5 EXEC PGM=U0378
  (lines omitted for brevity)

The following display introduces the LSP subcommand, which in this case
is used to eliminate any JCL override statements (e.g. //pli.sysprint
dd sysout=*) in the deck.  LSP is one of the most powerful ABE
subcommands, and also the most complicated and difficult to learn.
appendix J to this manual documents the LSP subcommand in detail.

                 1         2         3         4         5         6
        12345678901234567890123456789012345678901234567890123456789012

  lsp '&1 del' 1(('.':3:11 a))                                 ×FORM××
       F         Ö Ö Ö Ö Ö Ö Ö Ö Ö Ö Ö Ö Ö
  00020     //STEP1 EXEC PGM=U058IS01,PARM='YAU109209',REGION=8K
  00030  //SYSPRINT DD SYSOUT=A
  00040     //SYSIN DD DSN=SYS2.CNTCARD(U109209J),DISP=SHR
  00050     //STEP2 EXEC PGM=U058IS01,PARM='YAU109209',REGION=8K
  00060  //SYSPRINT DD SYSOUT=(A,,A413),COPIES=(1,(1,1,1,1,1,1))
  (lines omitted for brevity)

the resulting display, which is unchanged because in this case no
overrides were found:

                 1         2         3         4         5         6
        12345678901234567890123456789012345678901234567890123456789012

  PB                                                           ×FORM××
       F         Ö Ö Ö Ö Ö Ö Ö Ö Ö Ö Ö Ö Ö
  00020     //STEP1 EXEC PGM=U058IS01,PARM='YAU109209',REGION=8K
  00030  //SYSPRINT DD SYSOUT=A
  00040     //SYSIN DD DSN=SYS2.CNTCARD(U109209J),DISP=SHR
  00050     //STEP2 EXEC PGM=U058IS01,PARM='YAU109209',REGION=8K
  00060  //SYSPRINT DD SYSOUT=(A,,A413),COPIES=(1,(1,1,1,1,1,1))
  (lines omitted for brevity)

Now all lines are readjusted back to the left margin:

                 1         2         3         4         5         6
        12345678901234567890123456789012345678901234567890123456789012

  al                                                           ×FORM××
       F         Ö Ö Ö Ö Ö Ö Ö Ö Ö Ö Ö Ö Ö
  00020     //STEP1 EXEC PGM=U058IS01,PARM='YAU109209',REGION=8K
  00030  //SYSPRINT DD SYSOUT=A
  00040     //SYSIN DD DSN=SYS2.CNTCARD(U109209J),DISP=SHR
  00050     //STEP2 EXEC PGM=U058IS01,PARM='YAU109209',REGION=8K
  00060  //SYSPRINT DD SYSOUT=(A,,A413),COPIES=(1,(1,1,1,1,1,1))
  (lines omitted for brevity)

the resulting display:

                 1         2         3         4         5         6
        12345678901234567890123456789012345678901234567890123456789012

  PB                                                           ×FORM××
       F         Ö Ö Ö Ö Ö Ö Ö Ö Ö Ö Ö Ö Ö
  00020 //STEP1 EXEC PGM=U058IS01,PARM='YAU109209',REGION=8K
  00030 //SYSPRINT DD SYSOUT=A
  00040 //SYSIN DD DSN=SYS2.CNTCARD(U109209J),DISP=SHR
  00050 //STEP2 EXEC PGM=U058IS01,PARM='YAU109209',REGION=8K
  00060 //SYSPRINT DD SYSOUT=(A,,A413),COPIES=(1,(1,1,1,1,1,1))
  (lines omitted for brevity)

Now lines are adjusted so the first blank is in column 11:

                 1         2         3         4         5         6
        12345678901234567890123456789012345678901234567890123456789012

  ac ' ' 11                                                    ×FORM××
       F         Ö Ö Ö Ö Ö Ö Ö Ö Ö Ö Ö Ö Ö
  00020 //STEP1 EXEC PGM=U058IS01,PARM='YAU109209',REGION=8K
  00030 //SYSPRINT DD SYSOUT=A
  00040 //SYSIN DD DSN=SYS2.CNTCARD(U109209J),DISP=SHR
  00050 //STEP2 EXEC PGM=U058IS01,PARM='YAU109209',REGION=8K
  00060 //SYSPRINT DD SYSOUT=(A,,A413),COPIES=(1,(1,1,1,1,1,1))
  (lines omitted for brevity)

the resulting display:

                 1         2         3         4         5         6
        12345678901234567890123456789012345678901234567890123456789012

  PB                                                           ×FORM××
       F         Ö Ö Ö Ö Ö Ö Ö Ö Ö Ö Ö Ö Ö
  00020    //STEP1 EXEC PGM=U058IS01,PARM='YAU109209',REGION=8K
  00030 //SYSPRINT DD SYSOUT=A
  00040    //SYSIN DD DSN=SYS2.CNTCARD(U109209J),DISP=SHR
  00050    //STEP2 EXEC PGM=U058IS01,PARM='YAU109209',REGION=8K
  00060 //SYSPRINT DD SYSOUT=(A,,A413),COPIES=(1,(1,1,1,1,1,1))
  (lines omitted for brevity)

The following display introduces several facilities.  First, note that
three subcommands are being entered at the same time.  They are "t mk
1", "b mk 2", and "mk".  ABE recognizes this because the first
character on the command line is a special character (i.e. any of the
characters ~`×@#^&_=|\!/). This first character is recognized as
the delimiting character that will appear only between subcommands on
the command line.

The next display also introduces the mark array.  There is a mark
array associated with each data set being edited.  It has 9 elements
that can be set in various ways by the user at the terminal.  In this
case, mark array element number 1 is being set to the sequence number
of the first line in the data set ("t mk 1" - the t keyword stands for
"top line number"), and mark array element number 2 is being set to
the sequence number of the last line in the data set ("b mk 2" -
the b keyword stands for "bottom line number").  Finally, the MK
subcommand is entered with no operands to cause the current contents
of the mark array to be listed on the display:

                 1         2         3         4         5         6
        12345678901234567890123456789012345678901234567890123456789012

  /t mk 1/b mk 2/mk                                            ×FORM××
       F         Ö Ö Ö Ö Ö Ö Ö Ö Ö Ö Ö Ö Ö
  00020    //STEP1 EXEC PGM=U058IS01,PARM='YAU109209',REGION=8K
  00030 //SYSPRINT DD SYSOUT=A
  00040    //SYSIN DD DSN=SYS2.CNTCARD(U109209J),DISP=SHR
  00050    //STEP2 EXEC PGM=U058IS01,PARM='YAU109209',REGION=8K
  00060 //SYSPRINT DD SYSOUT=(A,,A413),COPIES=(1,(1,1,1,1,1,1))
  00070    //SYSIN DD DSN=SYS2.CNTCARD(U109209B),DISP=SHR
  00080    //SORT1 EXEC PGM=SORT
  00090 //SYSPRINT DD SYSOUT=A
  00100   //SYSOUT DD SYSOUT=A
  00110 //SORTWK01 DD UNIT=DISK,SPACE=(CYL,(10))
  00120 //SORTWK02 DD UNIT=DISK,SPACE=(CYL,(10))
  00130 //SORTWK03 DD UNIT=DISK,SPACE=(CYL,(10))
  00140   //SORTIN DD DISP=SHR,DSN=U.SD.U000.SMFDATA
  00150  //SORTOUT DD UNIT=DISK,DISP=(,PASS),
  (lines omitted for brevity)

the resulting display:

                 1         2         3         4         5         6
        12345678901234567890123456789012345678901234567890123456789012
     20   770     0     0     0     0                          ×FORM××
  PF
       F         Ö Ö Ö Ö Ö Ö Ö Ö Ö Ö Ö Ö Ö
  00020    //STEP1 EXEC PGM=U058IS01,PARM='YAU109209',REGION=8K
  00030 //SYSPRINT DD SYSOUT=A
  (lines omitted for brevity)

The next display shows the use of the COPY subcommand to duplicate all
of the lines in the data set.  In this case, the operands "1m" and
"2m" are references to the corresponding mark array elements. Any time
ABE sees an operand in an LSU (Line Specification Unit - see Appendix
H) of the form "nm", where "n" is a number from 1 to 9, it is
recognized as a reference to the mark array. The value stored in the
corresponding element will replace the operand before the subcommand
is executed.  In this case, the actual copy subcommand executed will
be "20 770 copy 770":

                 1         2         3         4         5         6
        12345678901234567890123456789012345678901234567890123456789012
     20   770     0     0     0     0
  1m 2m copy 2m                                                ×FORM××
       F         Ö Ö Ö Ö Ö Ö Ö Ö Ö Ö Ö Ö Ö
  00020    //STEP1 EXEC PGM=U058IS01,PARM='YAU109209',REGION=8K
  00030 //SYSPRINT DD SYSOUT=A
  (lines omitted for brevity)

the resulting display (you will see no change, because new records
are at the end of the data set):

                 1         2         3         4         5         6
        12345678901234567890123456789012345678901234567890123456789012

  PF                                                           ×FORM××
       F         Ö Ö Ö Ö Ö Ö Ö Ö Ö Ö Ö Ö Ö
  00020    //STEP1 EXEC PGM=U058IS01,PARM='YAU109209',REGION=8K
  00030 //SYSPRINT DD SYSOUT=A
  (lines omitted for brevity)

Now the subcommand "2m v" is entered to move the display to what
had been the last line in the data set before the copy subcommand
was executed above:

                 1         2         3         4         5         6
        12345678901234567890123456789012345678901234567890123456789012

  2m v                                                         ×FORM××
       F         Ö Ö Ö Ö Ö Ö Ö Ö Ö Ö Ö Ö Ö
  00020    //STEP1 EXEC PGM=U058IS01,PARM='YAU109209',REGION=8K
  00030 //SYSPRINT DD SYSOUT=A
  00040    //SYSIN DD DSN=SYS2.CNTCARD(U109209J),DISP=SHR
  00050    //STEP2 EXEC PGM=U058IS01,PARM='YAU109209',REGION=8K
  00060 //SYSPRINT DD SYSOUT=(A,,A413),COPIES=(1,(1,1,1,1,1,1))
  00070    //SYSIN DD DSN=SYS2.CNTCARD(U109209B),DISP=SHR
  00080    //SORT1 EXEC PGM=SORT
  00090 //SYSPRINT DD SYSOUT=A
  00100   //SYSOUT DD SYSOUT=A
  (lines omitted for brevity)

the resulting display:

                 1         2         3         4         5         6
        12345678901234567890123456789012345678901234567890123456789012

  PF                                                           ×FORM××
       F         Ö Ö Ö Ö Ö Ö Ö Ö Ö Ö Ö Ö Ö
  00770   //DBFILE DD DSN=U.SD.U000.PERF.DATA,DISP=MOD
  00771    //STEP1 EXEC PGM=U058IS01,PARM='YAU109209',REGION=8K
  00772 //SYSPRINT DD SYSOUT=A
  00773    //SYSIN DD DSN=SYS2.CNTCARD(U109209J),DISP=SHR
  00774    //STEP2 EXEC PGM=U058IS01,PARM='YAU109209',REGION=8K
  (lines omitted for brevity)

In the following display, the down subcommand is first used to move
the display down to line 771 (down 1), then mark array element 3 is
set to the line number 771 (* mark 3), mark array element 4 is set to
the sequence number of the last line in the data set (b mark 4),
and finally all mark array elements are displayed (mk):

                 1         2         3         4         5         6
        12345678901234567890123456789012345678901234567890123456789012

  /down 1/* mk 3/b mk 4/mk                                     ×FORM××
  FORM           Ö Ö Ö Ö Ö Ö Ö Ö Ö Ö Ö Ö Ö
  00770   //DBFILE DD DSN=U.SD.U000.PERF.DATA,DISP=MOD
  00771    //STEP1 EXEC PGM=U058IS01,PARM='YAU109209',REGION=8K
  00772 //SYSPRINT DD SYSOUT=A
  00773    //SYSIN DD DSN=SYS2.CNTCARD(U109209J),DISP=SHR
  (lines omitted for brevity)

the resulting display:

                 1         2         3         4         5         6
        12345678901234567890123456789012345678901234567890123456789012
     20   770   771   846     0     0
  PF                                                           ×FORM××
  FORM           Ö Ö Ö Ö Ö Ö Ö Ö Ö Ö Ö Ö Ö
  00771    //STEP1 EXEC PGM=U058IS01,PARM='YAU109209',REGION=8K
  00772 //SYSPRINT DD SYSOUT=A
  00773    //SYSIN DD DSN=SYS2.CNTCARD(U109209J),DISP=SHR
  00774    //STEP2 EXEC PGM=U058IS01,PARM='YAU109209',REGION=8K
  (lines omitted for brevity)

Now the CLEAR subcommand is used to eliminate all the data from column
11 to the right end of each of the duplicate records produced by the
COPY subcommand above:

                 1         2         3         4         5         6
        12345678901234567890123456789012345678901234567890123456789012
     20   770   771   846     0     0
  3m 4m clear 11                                               ×FORM××
       F         Ö Ö Ö Ö Ö Ö Ö Ö Ö Ö Ö Ö Ö
  00771    //STEP1 EXEC PGM=U058IS01,PARM='YAU109209',REGION=8K
  00772 //SYSPRINT DD SYSOUT=A
  00773    //SYSIN DD DSN=SYS2.CNTCARD(U109209J),DISP=SHR
  (lines omitted for brevity)

the resulting display:

                 1         2         3         4         5         6
        12345678901234567890123456789012345678901234567890123456789012

  PF                                                           ×FORM××
       F         Ö Ö Ö Ö Ö Ö Ö Ö Ö Ö Ö Ö Ö
  00771    //STEP1
  00772 //SYSPRINT
  00773    //SYSIN
  (lines omitted for brevity)

Now the AL subcommand (stands for "adjust left") is used to adjust the
duplicate records so that the first non-blank character in each
line is in column 1:

                 1         2         3         4         5         6
        12345678901234567890123456789012345678901234567890123456789012

  3m 4m al                                                     ×FORM××
       F         Ö Ö Ö Ö Ö Ö Ö Ö Ö Ö Ö Ö Ö
  00771    //STEP1
  00772 //SYSPRINT
  00773    //SYSIN
  (lines omitted for brevity)

the resulting display:

                 1         2         3         4         5         6
        12345678901234567890123456789012345678901234567890123456789012

  PF                                                           ×FORM××
       F         Ö Ö Ö Ö Ö Ö Ö Ö Ö Ö Ö Ö Ö
  00771 //STEP1
  00772 //SYSPRINT
  00773 //SYSIN
  (lines omitted for brevity)

Now lets look at the top of the data set:

                 1         2         3         4         5         6
        12345678901234567890123456789012345678901234567890123456789012

  top                                                          ×FORM××
       F         Ö Ö Ö Ö Ö Ö Ö Ö Ö Ö Ö Ö Ö
  00771 //STEP1
  00772 //SYSPRINT
  00773 //SYSIN
  (lines omitted for brevity)

the resulting display:

                 1         2         3         4         5         6
        12345678901234567890123456789012345678901234567890123456789012

  PF                                                           ×FORM××
       F         Ö Ö Ö Ö Ö Ö Ö Ö Ö Ö Ö Ö Ö
  00020    //STEP1 EXEC PGM=U058IS01,PARM='YAU109209',REGION=8K
  00030 //SYSPRINT DD SYSOUT=A
  00040    //SYSIN DD DSN=SYS2.CNTCARD(U109209J),DISP=SHR
  (lines omitted for brevity)

Now the SUBSTR subcommand is used to set to blanks the first 11 columns
of the original records:

                 1         2         3         4         5         6
        12345678901234567890123456789012345678901234567890123456789012

  1m 2m 1.11 substr ' '                                        ×FORM××
       F         Ö Ö Ö Ö Ö Ö Ö Ö Ö Ö Ö Ö Ö
  00020    //STEP1 EXEC PGM=U058IS01,PARM='YAU109209',REGION=8K
  00030 //SYSPRINT DD SYSOUT=A
  00040    //SYSIN DD DSN=SYS2.CNTCARD(U109209J),DISP=SHR
  (lines omitted for brevity)

the resulting display:

                 1         2         3         4         5         6
        12345678901234567890123456789012345678901234567890123456789012

  PF                                                           ×FORM××
       F         Ö Ö Ö Ö Ö Ö Ö Ö Ö Ö Ö Ö Ö
  00020            EXEC PGM=U058IS01,PARM='YAU109209',REGION=8K
  00030            DD SYSOUT=A
  00040            DD DSN=SYS2.CNTCARD(U109209J),DISP=SHR
  (lines omitted for brevity)

Now the AL subcommand is used to ensure range 1m thru 2m is aligned
to column 12:

                 1         2         3         4         5         6
        12345678901234567890123456789012345678901234567890123456789012

  1m 2m al 12                                                  ×FORM××
       F         Ö Ö Ö Ö Ö Ö Ö Ö Ö Ö Ö Ö Ö
  00020            EXEC PGM=U058IS01,PARM='YAU109209',REGION=8K
  00030            DD SYSOUT=A
  00040            DD DSN=SYS2.CNTCARD(U109209J),DISP=SHR
  (lines omitted for brevity)

the resulting display (no change in this case):

                 1         2         3         4         5         6
        12345678901234567890123456789012345678901234567890123456789012

  PF                                                           ×FORM××
       F         Ö Ö Ö Ö Ö Ö Ö Ö Ö Ö Ö Ö Ö
  00020            EXEC PGM=U058IS01,PARM='YAU109209',REGION=8K
  00030            DD SYSOUT=A
  00040            DD DSN=SYS2.CNTCARD(U109209J),DISP=SHR
  (lines omitted for brevity)

Now the OL subcommand (stands for "overlay line") is used to overlay
the original lines with the non-blank data from the copies:

                 1         2         3         4         5         6
        12345678901234567890123456789012345678901234567890123456789012

  1m 2m ol 3m 4m                                               ×FORM××
       F         Ö Ö Ö Ö Ö Ö Ö Ö Ö Ö Ö Ö Ö
  00020            EXEC PGM=U058IS01,PARM='YAU109209',REGION=8K
  00030            DD SYSOUT=A
  00040            DD DSN=SYS2.CNTCARD(U109209J),DISP=SHR
  (lines omitted for brevity)

the resulting display:

                 1         2         3         4         5         6
        12345678901234567890123456789012345678901234567890123456789012

  PF                                                           ×FORM××
       F         Ö Ö Ö Ö Ö Ö Ö Ö Ö Ö Ö Ö Ö
  00020 //STEP1    EXEC PGM=U058IS01,PARM='YAU109209',REGION=8K
  00030 //SYSPRINT DD SYSOUT=A
  00040 //SYSIN    DD DSN=SYS2.CNTCARD(U109209J),DISP=SHR
  (lines omitted for brevity)

we don't need the copies any more, so they are deleted:

                 1         2         3         4         5         6
        12345678901234567890123456789012345678901234567890123456789012

  3m 4m del
  FORM           Ö Ö Ö Ö Ö Ö Ö Ö Ö Ö Ö Ö Ö
  00020 //STEP1    EXEC PGM=U058IS01,PARM='YAU109209',REGION=8K
  00030 //SYSPRINT DD SYSOUT=A
  00040 //SYSIN    DD DSN=SYS2.CNTCARD(U109209J),DISP=SHR
  (lines omitted for brevity)

the resulting display:

                 1         2         3         4         5         6
        12345678901234567890123456789012345678901234567890123456789012

  PF                                                           ×FORM××
       F         Ö Ö Ö Ö Ö Ö Ö Ö Ö Ö Ö Ö Ö
  00020 //STEP1    EXEC PGM=U058IS01,PARM='YAU109209',REGION=8K
  00030 //SYSPRINT DD SYSOUT=A
  00040 //SYSIN    DD DSN=SYS2.CNTCARD(U109209J),DISP=SHR
  (lines omitted for brevity)

You can see jcl starting to clean up now.  Next, DD statements are
further adjusted so that data following the identifier "DD" is
adjusted to begin in column 16.  In doing this, the LSP subcommand
(stands for line specification processor) is used.  In prose, here is
what the LSP subcommand below is doing.  In every line in the data set
with the character string ' DD ' beginning in column 11, apply the SR
subcommand to shift the data in columns 15 thru 80 right 1 position:

                 1         2         3         4         5         6
        12345678901234567890123456789012345678901234567890123456789012

  lsp '&1 &1 15.80 sr 1' 1((' DD ':11 a))                      ×FORM××
       F         Ö Ö Ö Ö Ö Ö Ö Ö Ö Ö Ö Ö Ö
  00020 //STEP1    EXEC PGM=U058IS01,PARM='YAU109209',REGION=8K
  00030 //SYSPRINT DD SYSOUT=A
  00040 //SYSIN    DD DSN=SYS2.CNTCARD(U109209J),DISP=SHR
  00050 //STEP2    EXEC PGM=U058IS01,PARM='YAU109209',REGION=8K
  (lines omitted for brevity)

the resulting display:

                 1         2         3         4         5         6
        12345678901234567890123456789012345678901234567890123456789012

  PF                                                           ×FORM××
       F         Ö Ö Ö Ö Ö Ö Ö Ö Ö Ö Ö Ö Ö
  00020 //STEP1    EXEC PGM=U058IS01,PARM='YAU109209',REGION=8K
  00030 //SYSPRINT DD  SYSOUT=A
  00040 //SYSIN    DD  DSN=SYS2.CNTCARD(U109209J),DISP=SHR
  00050 //STEP2    EXEC PGM=U058IS01,PARM='YAU109209',REGION=8K
  (lines omitted for brevity)

Now the LSP subcommand is used once again to perform the following:
For every line in the data set which DOES NOT contain either the
characters ' DD ' or ' EXEC ' beginning in column 11, and DOES contain
the characters '// ' beginning in column 1, apply the SR subcommand to
shift the data in columns 12 thru 80 right 4 positions. This will
adjust continuation lines to column 16. Note that the name "LSP" is
omitted from the command line.  If ABE sees a quote as the first
character on the command, it assumes the LSP subcommand:

                 1         2         3         4         5         6
        12345678901234567890123456789012345678901234567890123456789012

  '&1 &1 12.80 sr 4' 1(('// ':1 (^' DD ':11 (^' EXEC ':11 a))))
       F         Ö Ö Ö Ö Ö Ö Ö Ö Ö Ö Ö Ö Ö
  00020 //STEP1    EXEC PGM=U058IS01,PARM='YAU109209',REGION=8K
  00030 //SYSPRINT DD  SYSOUT=A
  (lines omitted for brevity)
  00150 //SORTOUT  DD  UNIT=DISK,DISP=(,PASS),
  00160 //         SPACE=(CYL,(10)),

the resulting display:

                 1         2         3         4         5         6
        12345678901234567890123456789012345678901234567890123456789012

  PF                                                           ×FORM××
       F         Ö Ö Ö Ö Ö Ö Ö Ö Ö Ö Ö Ö Ö
  00020 //STEP1    EXEC PGM=U058IS01,PARM='YAU109209',REGION=8K
  00030 //SYSPRINT DD  SYSOUT=A
  (lines omitted for brevity)
  00150 //SORTOUT  DD  UNIT=DISK,DISP=(,PASS),
  00160 //             SPACE=(CYL,(10)),

Now the SUBSTR subcommand is used to ensure that all lines in the data
set are filled out with blanks.

                 1         2         3         4         5         6
        12345678901234567890123456789012345678901234567890123456789012

  t b 80.1 substr ' '                                          ×FORM××
       F         Ö Ö Ö Ö Ö Ö Ö Ö Ö Ö Ö Ö Ö
  00020 //STEP1    EXEC PGM=U058IS01,PARM='YAU109209',REGION=8K
  00030 //SYSPRINT DD  SYSOUT=A
  (lines omitted for brevity)

The display will not change.

Now the LSP subcommand is used again to delete all lines that are
not blank in columns 72 thru 80.  This will eliminate any lines that
have been expanded too far to the right during the re-formatting:

                 1         2         3         4         5         6
        12345678901234567890123456789012345678901234567890123456789012

  '&1 del' 1((^'        ':72 a))                               ×FORM××
       F         Ö Ö Ö Ö Ö Ö Ö Ö Ö Ö Ö Ö Ö
  00020 //STEP1    EXEC PGM=U058IS01,PARM='YAU109209',REGION=8K
  00030 //SYSPRINT DD  SYSOUT=A
  (lines omitted for brevity)
  00150 //SORTOUT  DD  UNIT=DISK,DISP=(,PASS),
  00160 //             SPACE=(CYL,(10)),

the resulting display (looks the same):

                 1         2         3         4         5         6
        12345678901234567890123456789012345678901234567890123456789012

  PF                                                           ×FORM××
       F         Ö Ö Ö Ö Ö Ö Ö Ö Ö Ö Ö Ö Ö
  00020 //STEP1    EXEC PGM=U058IS01,PARM='YAU109209',REGION=8K
  00030 //SYSPRINT DD  SYSOUT=A
  (lines omitted for brevity)
  00150 //SORTOUT  DD  UNIT=DISK,DISP=(,PASS),
  00160 //             SPACE=(CYL,(10)),

Now the SHOW subcommand is used to replace the temporary data set
currently on the display (it has the symbolic name "form") with the
original data set, which has symbolic name "orig".  Note that the
temporary data set is still being edited; it has just been "set aside,"
so to speak, while we look at something else:

                 1         2         3         4         5         6
        12345678901234567890123456789012345678901234567890123456789012

  show orig                                                    ×FORM××
       F         Ö Ö Ö Ö Ö Ö Ö Ö Ö Ö Ö Ö Ö
  00020 //STEP1    EXEC PGM=U058IS01,PARM='YAU109209',REGION=8K
  00030 //SYSPRINT DD  SYSOUT=A
  (lines omitted for brevity)
  00150 //SORTOUT  DD  UNIT=DISK,DISP=(,PASS),
  00160 //             SPACE=(CYL,(10)),

the resulting display (next page):

                 1         2         3         4         5         6
        12345678901234567890123456789012345678901234567890123456789012

  PF                                      ×ORIG×SYS2.PROCLIB(AU109209)
       F         Ö Ö Ö Ö Ö Ö Ö Ö Ö Ö Ö Ö Ö
  00010 //* AU109209
  00020 //STEP1 EXEC PGM=U058IS01,PARM='YAU109209',REGION=8K
  00030 //SYSPRINT DD SYSOUT=A
  00040 //SYSIN DD DSN=SYS2.CNTCARD(U109209J),DISP=SHR
  00050 //STEP2 EXEC PGM=U058IS01,PARM='YAU109209',REGION=8K
  (lines omitted for brevity)

Now the MB subcommand (stands for "merge back") is used to overlay the
original lines with the re-formatted copies in temporary data set with
symbolic name FORM.  At the same time, MB will also delete the
temporary data set:

                 1         2         3         4         5         6
        12345678901234567890123456789012345678901234567890123456789012

  mb form                                 ×ORIG×SYS2.PROCLIB(AU109209)
       F         Ö Ö Ö Ö Ö Ö Ö Ö Ö Ö Ö Ö Ö
  00010 //* AU109209
  00020 //STEP1 EXEC PGM=U058IS01,PARM='YAU109209',REGION=8K
  00030 //SYSPRINT DD SYSOUT=A
  00040 //SYSIN DD DSN=SYS2.CNTCARD(U109209J),DISP=SHR
  00050 //STEP2 EXEC PGM=U058IS01,PARM='YAU109209',REGION=8K
  (lines omitted for brevity)

the resulting display:

                 1         2         3         4         5         6
        12345678901234567890123456789012345678901234567890123456789012

  PF                                      ×ORIG×SYS2.PROCLIB(AU109209)
       F         Ö Ö Ö Ö Ö Ö Ö Ö Ö Ö Ö Ö Ö
  00010 //* AU109209
  00020 //STEP1    EXEC PGM=U058IS01,PARM='YAU109209',REGION=8K
  00030 //SYSPRINT DD  SYSOUT=A
  00040 //SYSIN    DD  DSN=SYS2.CNTCARD(U109209J),DISP=SHR
  (lines omitted for brevity)
  00130 //SORTWK03 DD  UNIT=DISK,SPACE=(CYL,(10))
  00140 //SORTIN   DD  DISP=SHR,DSN=U.SD.U000.SMFDATA
  00150 //SORTOUT  DD  UNIT=DISK,DISP=(,PASS),
  00160 //             SPACE=(CYL,(10)),
  00170 //             DSN=&&SMF,
  00180 //             DCB=(RECFM=VB,LRECL=4096,BLKSIZE=6440)
  00190 //SYSIN    DD  DISP=SHR,DSN=SYS2.CNTCARD(U109209E)

Obviously, you're not going want to enter the entire set of subcommands
just shown every time you want to re-format jcl. There is a way of
storing lists of ABE subcommands in a partitioned data set so that the
entire list can be executed by entering just one subcommand. The
subcommands just shown, with some minor modifications to handle
procedure override jcl statements and concatenated DD statements, has
been stored in data set 'SYS2.CMDPROC(ABEJCL)'. Following is a list of
that data set:

    REN 10 10
    F // 1 ALL NAME(TMP)
    A TMP F * 3 NOT ALL NAME(FORM)
    A TMP END N
    A FORM C '  ' ' '
    A FORM C '  ' ' '
    A FORM AC ' ' 12
    A FORM LSP '&&1 DEL' 1(('.':3:11 A))
    A FORM AL
    A FORM AC ' ' 11
    A FORM T MK 1
    A FORM B MK 2
    A FORM 1M 2M COPY 2M
    A FORM 2M V
    A FORM DOWN 1
    A FORM * MK 3
    A FORM B MK 4
    A FORM 3M 4M CLEAR 11
    A FORM 3M 4M AL
    A FORM 1M 2M 1.11 SUBSTR ' ' LEN(11)
    A FORM 1M 2M AL 12
    A FORM 1M 2M OL 3M 4M
    A FORM 3M 4M DEL
    A FORM LSP '&&1 &&1 15.80 SR 1' 1((' DD ':11 A))
    A FORM LSP '&&1 &&1 12.80 SR 4' +
      1(('// ':1 (^' DD ':11 (^' EXEC ':11 A))))
    A FORM T B 80.1 SUBSTR ' '
    A FORM LSP '&&1 DEL' 1((^'        ':72 A))
    MB FORM

To demonstrate how you would invoke such a list, suppose you were
editing a procedure such as the following:

                 1         2         3         4         5         6
        12345678901234567890123456789012345678901234567890123456789012

  PF                                  ×AU109706×SYS2.PROCLIB(AU109706)
       F         Ö Ö Ö Ö Ö Ö Ö Ö Ö Ö Ö Ö Ö
  00010 //* AU109706
  00020 //GENSMF EXEC PGM=IEBGENER
  (lines omitted for brevity)

The necessary subcommand to get the list of ABE subcommands in data set
'SYS2.CMDPROC(ABEJCL)' executed is the RUN subcommand . RUN requires
that the partitioned data set in which the list of subcommands is
stored be allocated to the session under the file name of SYSRUN.  I'm
first going to demonstrate what happens if this file isn't allocated
and what you can do about it:

                 1         2         3         4         5         6
        12345678901234567890123456789012345678901234567890123456789012

  run abejcl                          ×AU109706×SYS2.PROCLIB(AU109706)
  ====>          Ö Ö Ö Ö Ö Ö Ö Ö Ö Ö Ö Ö Ö
  00010 //* AU109706
  00020 //GENSMF EXEC PGM=IEBGENER
  (lines omitted for brevity)

the resulting display:

                 1         2         3         4         5         6
        12345678901234567890123456789012345678901234567890123456789012
 SYSRUN FILE INVALID OR MISSING
  PF                                  ×AU109706×SYS2.PROCLIB(AU109706)
  ====>          Ö Ö Ö Ö Ö Ö Ö Ö Ö Ö Ö Ö Ö
  00010 //* AU109706
  00020 //GENSMF EXEC PGM=IEBGENER
  (lines omitted for brevity)

As you can see above, I got an error message telling me that file
SYSRUN is missing.  To allocate the file without leaving ABE, I will
enter x mode by entering the x subcommand:

                 1         2         3         4         5         6
        12345678901234567890123456789012345678901234567890123456789012
 SYSRUN FILE INVALID OR MISSING
  x                                   ×AU109706×SYS2.PROCLIB(AU109706)
       F         Ö Ö Ö Ö Ö Ö Ö Ö Ö Ö Ö Ö Ö
  00010 //* AU109706
  00020 //GENSMF EXEC PGM=IEBGENER
  (lines omitted for brevity)

The result of entering the above X subcommand is that the screen will
be cleared, and the prompt "ABEX" will appear in the upper left hand
corner of the screen.  This means I am in x mode.  In x mode, I can
enter any TSO command processor name, such as edit, list, etc:

    ABEX
    alloc fi(sysrun) da('sys2.cmdproc') shr reuse
    ABEX

To get out of x mode and back into the full-screen display of ABE,
just enter a null line, and the full-screen display will re-appear:

                 1         2         3         4         5         6
        12345678901234567890123456789012345678901234567890123456789012

  PF                                  ×AU109706×SYS2.PROCLIB(AU109706)
       F         Ö Ö Ö Ö Ö Ö Ö Ö Ö Ö Ö Ö Ö
  00010 //* AU109706
  00020 //GENSMF EXEC PGM=IEBGENER
  (lines omitted for brevity)

Now when I enter the RUN subcommand, the result is as follows:

                 1         2         3         4         5         6
        12345678901234567890123456789012345678901234567890123456789012

  run abejcl                          ×AU109706×SYS2.PROCLIB(AU109706)
       F         Ö Ö Ö Ö Ö Ö Ö Ö Ö Ö Ö Ö Ö
  00010 //* AU109706
  00020 //GENSMF EXEC PGM=IEBGENER
  (lines omitted for brevity)

the resulting display:

                 1         2         3         4         5         6
        12345678901234567890123456789012345678901234567890123456789012

  PF                                  ×AU109706×SYS2.PROCLIB(AU109706)
       F         Ö Ö Ö Ö Ö Ö Ö Ö Ö Ö Ö Ö Ö
  00010 //* AU109706
  00020 //GENSMF   EXEC PGM=IEBGENER
  00030 //SYSPRINT DD  SYSOUT=A
  00040 //SYSIN    DD  DUMMY
  00050 //SYSUT1   DD  DSN=U.SD.U000.MVSSMF,DISP=OLD
  00060 //SYSUT2 DD DSN=&MVSSMF,DISP=(NEW,PASS),UNIT=DISK,SPACE=(CYL,(
  00070 //             DCB=(RECFM=VBS,LRECL=32760,BLKSIZE=19060)
  00080 //ABN      EXEC PGM=NONAME,REGION=8K,COND=(0,EQ,GENSMF)
  00090 //SORTSMF  EXEC PGM=SORT,PARM='MSG=AP'
  00100 //SYSPRINT DD  SYSOUT=*
  00110 //SYSOUT   DD  SYSOUT=*
  00120 //SORTLIB  DD  DSN=SYS1.SORTLIB,DISP=SHR
  (lines omitted for brevity)


This concludes Part I of this manual.  For more sophisticated
examples, see Appendix M.
