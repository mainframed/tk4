         TITLE     'IEFUJV - PROGRAM DESCRIPTION'
***********************************************************************
*
*        PROGRAM: IEFUJV
*        AUTHOR: D. HALBIG
*        INSTALLATION: U. S. SENATE
*        DATE WRITTEN: FEB. 1979.
*        FUNCTION: INTERROGATE CONVERTED JCL TO DETERMINE RESOURCE
*        REQUIREMENTS OF USER'S JOB; COMPARE THESE RESOURCE
*        REQUIREMENTS AGAINST A LOOK-UP TABLE OF JOB CLASSES &
*        RESET JOB INTO A CLASS APPROPRIATE TO RESOURCE REQUIREMENTS.
*
*        MAINTENANCE:
*         12FEB82(DGH) - ADD BYPASS AND DIAGNOSTIC FACILITY;
*          CHANGE ACCOUNT CODE CHECKING FACILITY TO USE ACCOUNT CODE
*          TABLES FOUND IN CSA; CHANGE JOB CLASS ASSIGNMENT ROUTINE
*          TO USE RESOURCE LIMIT TABLE NOW PART OF TABLES FOUND IN
*          CSA.  THE TABLES IN CSA ARE ANCHORED OFF THE CVTUSER FIELD.
*
*
*        REGISTER                 USAGE
*              R15                ENTRY PT/RET. CODE / WORK REG
*              R14                BRANCH BACK ADDR / WORK REG / DIAG
*              R13                SAVE AREA/ WORK AREA
*              R12                COMMON WORK AREA
*              R10,R11            BASE REGISTERS
*              R9                 RETURN ADDRESS FOR SUBROUTINE CALL
*              R8                 RETURN ADDR OF MINOR SUBROUTINES
*              R7-R0              WORK REGS
*
*                                 THIS MOD INDEXED UNDER 'LCMOD16'
*
***********************************************************************
         TITLE     '''$BF'' MACRO'
***********************************************************************
*
*        THE '$BF' MACRO WAS LIFTED FROM THE BEGINNING LINES OF
*        'HASPSSSM' (V4.1 - JES2). NOTE ANY CHANGES  IN SUBSEQUENT
*         RELEASES OF JES2.
*
*
***********************************************************************
         MACRO
         $BF   &DOC=NO
         GBLA  &BUFSIZE
         TITLE 'GENERALIZED SUBSYSTEM DATASET BUFFER'
*
*
*              GENERALIZED SUBSYSTEM DATASET BUFFER DSECT
*
*
BFDSECT  DSECT
BFD      EQU   BFDSECT
         SPACE 3
BFID     DS    CL4                 ID - PBF, UBF, OR HBF
BFLENG   DS    AL2(4096)           LENGTH                            R4
BFFL1    DS    B                   FLAG BYTE 1
BFFL2    DS    B                   FLAG BYTE 2
BFBF     DS    A                   CHAIN POINTER
BFTRK    DS    F                   TRACK ADDRESS OF BUFFER
BFTCB    DS    A                   TCB ADDRESS FOR FREEMAIN
BFASCB   DS    A                   ASCB ADDRESS FOR FREEMAIN
BFLOC    DS    A                   CURRENT LOCATION IN BUFFER
BFLEN    DS    0F                  OUTPUT - LENGTH REMAINING
BFECB    DS    F                   INPUT - ECB ON WHICH TO WAIT
BFRBA    DS    D                   RELATIVE BLOCK ADDRESS
BFRCT    DS    F                   RECORD COUNTER
*
*              ONLY THE FOLLOWING DATA IS WRITTEN TO DISK
*
BFIO     EQU   *                   START OF AUXILIARY STORAGE DATA   R4
BFNXT    DS    F                   CHAINING TRACK
BFKEY    DS    0CL6                UNIQUE DATA SET KEY ---
BFJBK    DS    CL4                 4-BYTE JOB KEY BASED ON TOD CLOCK
BFDSK    DS    CL2                 2-BYTE SEQUENTIAL DATA SET KEY
BFDAT    EQU   *                   USER DATA AREA                    R4
         EJECT
*
*              FLAG DEFINITIONS
*
         SPACE 3
*              FLAGS 1 ---
         SPACE 1
BF1EOB   EQU   B'10000000'         END-OF-BUFFER INDICATOR           R4
BF1RSV1  EQU   B'01000000'         RESERVED
BF1RSV2  EQU   B'00100000'         RESERVED
BF1RSV3  EQU   B'00010000'         RESERVED
BF1GSG   EQU   B'00001000'         HGMOVE SPAN ENTRY FLAG
BF1IOC   EQU   B'00000100'         PBF I/O IS COMPLETE
BF1PMV   EQU   B'00000010'         HPMOVE ENTRY FLAG
BF1PSG   EQU   B'00000001'         HPMOVE SPAN ENTRY FLAG
         SPACE 3
*              FLAGS 2 ---
         SPACE 1
BF2IOC   EQU   B'10000000'         UBF NOT PRIMED BY HCEGET     OZ30886
BF2RSV1  EQU   B'01000000'         RESERVED
BF2RSV2  EQU   B'00100000'         RESERVED
BF2RSV3  EQU   B'00010000'         RESERVED
BF2RSV4  EQU   B'00001000'         RESERVED
BF2RSV5  EQU   B'00000100'         RESERVED
BF2RSV6  EQU   B'00000010'         RESERVED
BF2RSV7  EQU   B'00000001'         RESERVED
         SPACE 6
&SYSECT  CSECT
         MEND
         TITLE     'GETBUF/FREEBUF MACROS'
***********************************************************************
*
*        THE INSTREAM MACROS $GETBUF,$FREEBUF, AND $MAIN WERE 'LIFTED'
*        FROM V4.1 OF HASPSSSM OF JES2 - CHECK EACH SUBSEQUENT RELEASE
*        TO INSURE NO SIGNIFICAT CHANGES HAVE OCCURRED - IPO 4.0
*        LINES T0177000 - T02505000
*
***********************************************************************
         MACRO
&L       $FREMAIN &TYPE,&A=,&LV=,&SP=,&KEY=,&TCB=NO
&L       $MAIN 1,&TYPE,&A,&LV,&SP,&KEY,&TCB
         MEND
         SPACE 3
         MACRO
&L       $GETBUF &TYPE=PROT,&A=
         AIF   ('&TYPE' EQ 'PROT').PROT
&L       $MAIN 0,BC,0,4096,229,15  UNPROTECTED                       R4
         MEXIT
.PROT    ANOP
&L       $MAIN 0,BC,0,4096,229,5   PROTECTED                         R4
         MEND
         SPACE 3
         MACRO
&L       $FREEBUF &TYPE=PROT,&A=
         AIF   ('&TYPE' EQ 'PROT').PROT
&L       $MAIN 1,BU,&A,4096,229,15 UNPROTECTED                       R4
         MEXIT
.PROT    ANOP
&L       $MAIN 1,BU,&A,4096,229,5  PROTECTED                         R4
         MEND
         SPACE 3
         MACRO
&L       $MAIN &T,&TYPE,&A,&LV,&SP,&KEY,&TCB
         LCLA  &TYPA,&TYP,&I
         LCLB  &B
         LCLC  &C
* REGISTERS DESTROYED -- R0,R1,R2,R3,R4,R7,R14,R15
.*
.*             TEST REGULAR OR BUFFER TYPE
.*
         AIF   ('&TYPE'(1,1) NE 'B').NOTB  GO IF NOT BUFFER-TYPE.
&TYPA    SETA  &TYPA+64            SHOW BUFFER-TYPE
.NOTB    ANOP
.*
.*             SET &TYPA BIT 2 IF GETMAIN, BIT 3 IF FREEMAIN
.*
&TYPA    SETA  &TYPA+32            ASSUME GETMAIN
         AIF   (NOT &T).NOTFREE    GO IF ASSUMPTION CORRECT.
&TYPA    SETA  &TYPA+16-32         SET FREEMAIN
.NOTFREE ANOP
.*
.*             SET &TYPA BIT 4 IF TCB=YES
.*
         AIF   ('&TCB' NE 'YES').NOTCB   SKIP IF TCB NOT YES.
&TYPA    SETA  &TYPA+8             FLAG TCB=YES.
.NOTCB   ANOP                      CONTINUE.
.*
.*             TEST CONDITIONALITY AND GET/FREE
.*
&B       SETB  ('&TYPE'(2,1) EQ 'U')
&TYP     SETA  &T+2*&B
.*
.*             SET INDEX TO DESCRIBE ARGUMENTS
.*
         AIF   ('&LV' EQ '(R0)').T3  IF LR IS REQUIRED FOR LV=,
&I       SETA  &I+1                ADD 1 TO INDEX
         AIF   ('&LV'(1,1) EQ '(').T3  IF ADCON REQUIRED FOR LV=,
&I       SETA  &I+1                ADD 1 TO INDEX.
.T3      AIF   ('&A' EQ '(R1)').T6  IF SLR OR LR REQUIRED FOR A=,
&I       SETA  &I+3                ADD 3 TO INDEX.
         AIF   (NOT &T OR '&A'(1,1) EQ '(').T6  IF L REQUIRED FOR A=,
&I       SETA  &I+3                ADD 3 TO INDEX.
.T6      ANOP
.*
.*             SET CONDITIONAL NO-OPERATION
.*
         AIF   (&I-&I/2*2 EQ 0).CNOP2  IF INDEX IS ODD,
         CNOP  0,4
         AGO   .LABEL              START ON WD BDRY, ELSE HALFWORD.
.CNOP2   CNOP  2,4
.LABEL   ANOP
.*
.*             SET UP LABEL IF PROVIDED
.*
         AIF   ('&L' EQ '').NOLABEL  GO IF BLANK LABEL
&L       DS    0H
.NOLABEL ANOP
.*
.*             SET UP LENGTH VALUE ARGUMENT LV=
.*
&C       SETC  '012012012'(&I+1,1)  EXTRACT LV= FROM INDEX.
         AIF   (&C EQ 2).A         IF LENGTH TO BE PASSED IN R0,
&TYPA    SETA  &TYPA+128           SHOW SO BY FLAG.
         AIF   (&C EQ 0).A         IF LV=(R0),LENGTH ALREADY LKAY.
&C       SETC  '&LV'(2,K'&LV-2)    ELSE REMOVE PARENTHESES.
         LR    R0,&C
.A       ANOP
.*
.*             SET UP ADDRESS VALUE &A=
.*
&C       SETC  '000111222'(&I+1,1)  EXTRACT A= FROM INDEX.
         AIF   (&T).A0             IF GETMAIN, ZERO ADDRESS REGISTER.
         SLR   R1,R1
         AGO   .A3
.A0      AIF   (&C EQ 0).A3        IF R1 ALREADY SET UP, BRANCH.
         AIF   (&C NE 1).A2        IF LR IS REQUIRED,
&C       SETC  '&A'(2,K'&A-2)      REMOVE PARENTHESES AND LR.
         LR    R1,&C
         AGO   .A3
.A2      L     R1,&A
.A3      ANOP
.*
.*             CALL HGFMAIN
.*
         L     R15,=A(HGFMAIN)
         BALR  R4,R15
.*
.*
.*             DESCRIPTION OF FOLLOWING FULLWORD ---
.*
.*       BYTE 0 ---
.*             BIT 0 IS ON IF LV= OPERAND IS IN R0, OFF IF LV=
.*                 OPERAND IS IN THE FULLWORD FOLLOWING THIS.
.*             BIT 1 IS ON IF $GETBUF/$FREEBUF, OFF IF $GETMAIN/
.*                 $FREMAIN.
.*             BIT 2 IS ON IF $GETMAIN/$GETBUF.
.*             BIT 3 IS ON IF $FREMAIN/$FREEBUF.
.*             BIT 4 IS ON IF TCB SUPPLIED FOR $FREMAIN.
.*             BITS 5-7 ARE RESERVED FOR FUTURE USE.
.*
.*       BYTE 1 ---
.*             BITS 0-3 CONTAIN STORAGE PROTECTION KEY, OR X'F'.
.*                 THE LATTER IS AN INDICATION TO HGFMAIN TO USE
.*                 THE PROTECT KEY FROM TCBPKF.
.*             BITS 4-7 MUST BE ZERO.
.*
.*       BYTE 2 ---
.*             BITS 0-7 CONTAIN SUBPOOL NUMBER.
.*
.*       BYTE 3 ---
.*             BITS 0-7 CONTAIN A CODE USED BY VIRTUAL STORAGE
.*                 SUPERVISOR --
.*                 0 - CONDITIONAL GETMAIN
.*                 1 - CONDITIONAL FREEMAIN
.*                 2 - UNCONDITIONAL GETMAIN
.*                 3 - UNCONDITIONAL FREEMAIN
.*
.*
         DC    AL1(&TYPA,&KEY*16,&SP,&TYP)
.*
.*             ADD LENGTH ADCON IF NOT IN R0
.*
         AIF   (&TYPA GE 128).NOLAD  GO IF LENGTH ALREADY IN REG.
         DC    A(&LV)
.NOLAD   ANOP
         MEND
         TITLE 'INTERPRETER/CONVERTER COMMON WORK AREA'
         IEFCOMWA
         IEFCVRWA
         TITLE     'INTERNAL TEXT KEYWORD INTERNAL KEY VALUES'
         IEFVKEYS
         TITLE     'IEFUJV - IOS REQUEST QUEUE ELEMENT(RQE)'
         IECDRQE
         TITLE     'MAP OF PARM LIST PASSED TO IEFUJV'
         UJVMAP
         TITLE     'COMMON EXIT PARAMETER LIST'
         COMMEXIT
         TITLE     'IEFUJV - BINARY SEARCH ROUTINE CONTROL PARMS'
         TABLE
         TITLE     'IEFUJV - LAYOUT OF CSA ACCOUNTING AREA'
         ACCTABLE
         TITLE     'IEFUJV - USER SMF RECORD LAYOUT'
         SMF239
         TITLE     'IEFUJV - REQUEST PARAMETER LIST'
         PRINT     ON,NOGEN
         IFGRPL
         TITLE     'IEFUJV - RPL RETURN CODE LIST'
         IDARMRCD
         PRINT     ON,GEN
         TITLE     'IEFUJV - LAYOUT OF INTERNAL TEXT RECORD'
         IEFTXTFT
         TITLE     'IEFUJV - MISC EQUATES AND JES MACROS'
IEFUJV   CSECT
         COPY      $HASPGEN
         PUSH      PRINT
         PRINT     OFF
         $TAB      DOC=NO
         $ACB      LIST=NO
         $ASCB     LIST=NO
         $BUFFER   DOC=NO
         $BF       DOC=YES
         $CVT      LIST=NO
         $JESCT    LIST=YES
         $SSCT     LIST=YES
         $DCB      LIST=NO
         $DEB      LIST=NO
         $JCT      DOC=NO
         $CAT      DOC=NO
         $JQE      DOC=NO
         $PCE      DOC=NO
         $HCT      DOC=NO
         $JSCB     LIST=NO
         $NEL      LIST=NO
         $PSA      LIST=NO
         $PDDB     DOC=NO
         $SDB      DOC=NO
         $SJB      DOC=NO
         $TCB      LIST=NO
         $SVT      DOC=NO
         $TED      DOC=NO
         POP       PRINT
         DROP      JCT,BASE1
         PRINT     ON,GEN,NODATA
         TITLE     'IEFUJV - MAIN ROUTINE'
IEFUJV   CSECT
***********************************************************************
*
*        IEFUJV - MAIN ROUTINE
*
***********************************************************************
         SAVE      (14,12),,IEFUJV-&SYSDATE-&SYSTIME
         LR        R11,R15        ESTABLISH BASE REGS
         USING     IEFUJV,R11
         LR        R9,R1          GET PTR TO PARM LIST
         USING     UJVMAP,R9      TELL ASSEMBLER
         SR        R15,R15        RC=0
         L         R8,UJVENTRY    ENTRY CODES (0-32)
         TM        0(R8),UJVCNVTR IS THIS CONVERTER ENTRY? (=16)
         BZ        FASTEXIT    BIF NOT
MAIN16   EQU       *
         L         R8,UJVCEPA     ADDR OF COMMON EXIT PARM AREA
         USING     COMMEXIT,R8    GIVE IT ADDRESSABILITY
         L         R1,WANELPTR          INTERPRETER PARM LIST
         USING     NELDSECT,R1
         L         R1,NELTXTCB          NEL -> TEXT ACB
         USING     IFGACB,R1
         L         R1,ACBDEB-1          ACB -> DEB
         USING     DEBBASIC,R1
         L         R1,DEBIRBAD          DEB -> SDB
         USING     SDBDSECT,R1
         L         R1,SDBSJB            SDB -> SJB
         USING     SJBDSECT,R1
         PACK      CEPUSRID,SJBJOBID+3(5) USE FIELD AS A WORK AREA
         CVB       R3,CEPUSRID    GET JES ID INTO BINARY FORMAT
         XC        CEPUSRID,CEPUSRID NOW CLEAR AREA
         L         R2,SJBJCT            SJB -> JCT
         USING     JCTDSECT,R2
         CLC       JCTPNAME,=CL20'@@@SMF EXIT DIAG@@@@' WANT DIAGS?
         BNE       MAIN16AA    BIF NOT
         OI        CEPIDFLG,CEPIDF06   SET DIAG SWITCH FOR SMF EXITS
MAIN16AA EQU       *
         CLC       JCTPNAME,=CL20'@@@SMF EXIT BYPASS@@' WANT BYPASS?
         DROP      R2
         BNE       MAIN16BB    BIF NOT
         OI        CEPIDFLG,CEPIDF05   SET BYPASS SWITCH
         B         FASTEXIT      NOW LEAVE
MAIN16BB EQU       *
         CLC       SJBJOBID(3),=C'JOB'  BATCH JOB?
         BNE       MAIN16CC             BIF NOT
         OI        CEPIDFLG,CEPIDF02
         B         MAIN16EE
MAIN16CC EQU       *
         CLC      SJBJOBID(3),=C'TSU'   TSO SESSION?
         BNE      MAIN16DD
         OI       CEPIDFLG,CEPIDF03     TSO SESSION FLAG
         A        R3,=A(20000)          ADJUST JES # FOR TSO ID
         B        MAIN16EE
MAIN16DD EQU      *
         OI       CEPIDFLG,CEPIDF04     ASSUME SYSTEM TASK
         A        R3,=A(10000)          ADJUST JES # FOR STC ID
         CLC      SJBJOBID(3),=C'STC'   SYSTEM TASK?
         BE       MAIN16EE              BIF YES
         EX       R0,*                  OTHERWISE; ERROR (FORCE OC3)
MAIN16EE EQU      *
         DROP     R1
         STH       R3,CEPIDJES          STOW MODIFIED JES ID FOR LATER
         TM        CEPIDFLG,CEPIDF04+CEPIDF03 TSU OR STC?
         BM        FASTEXIT       BIF IT IS: DO NOT DO CLASS SCHED.
         DROP      R9             NO LONGER NEED PARMS PASSED TO IEFUJV
         LA        R7,WAJOBPFX    ADDR OF PSEUDO-JOB PREFIX
         USING     TEXT,R7        GET LAYOUT FOR THIS PREFIX
         TM        STRJINDC,JTXJOBFL WAS JOB PREV. FAILED?
         BO        FASTEXIT       BIF YES
         TM        STRJINDC,JTXREGDF IS 'REGION=' ON STMT A DEFAULT?
         BZ        MAININIT       BIF NOT; DON'T SET FLAG
         OI        CEPIDFLG,CEPIDF07 IF SO, SET STATUS FLAG FOR LATER
         DROP      R7,R8
MAININIT EQU       *
         L         R10,=A(INITRTN) DO INITIALIZATION
         BALR      R9,R10
         USING     WORKAREA,R13   FROM HERE TO END, R13-> WORKAREA
         TM        ERRSW,ERINITRT ERROR IN INITIALIZATION ROUTINE?
         BO        MAINERR        BIF YES
         SPACE     1
READTEXT EQU       *
         TM        PARMSW,DIAGFLAG   IS DIAGNOSTIC FLAG SET?
         BNO       READNODG      BIF NOT; READ WITHOUT DIAGNOSTICS
         STM       R0,R15,SNAPREGS    STOW FOR DIAGNOSTICS
         BAL       R8,SNAPRTN    SNAP INFO TO DATA SET
READNODG EQU       *
         L         R10,=A(READRTN)
         BALR      R9,R10
         TM        ERRSW,ERREADRT ERROR IN READ ROUTINE?
         BO        MAINERR        BIF YES
         TM        PARMSW,EOFSW   EOF REACHED?
         BO        CALLLOOK       IF EOF, DO CLASS LOOK-UP
         L         R7,TEXTBUFP    R7 -> INTERNAL TEXT BUFFER
         LA        R7,0(,R7)      CLEAR HI-BYTE
         USING     TEXT,R7        TELL ASSEMBLER
         LH        R6,STRLTH      GET LENGTH OF STRING
         AR        R6,R7          CALC END-OF-STRING ADDRESS
         ST        R6,ENDSTRNG    STOW ADDRESS FOR THE FUTURE
         TM        STRINDCS,DDSTR IS THE STRING A 'DD' STRING?
         BZ        TRYEXEC        BIF NOT
         L         R10,=A(DODDSTMT)
         BALR      R9,R10         GO PERFORM IT
         TM        ERRSW,ERDDRT   ERROR IN DD STMT PROCESSOR?
         BO        MAINERR        BIF YES
         L         R7,TEXTBUFP    RELOAD R7 (DESTROYED BY SUBR)
         TM        STRINDCS,LASTSTMT IS THIS THE LAST DD STMT IN STEP?
         BZ        ENDMAIN        BIF NOT
         L         R10,=A(DOEXECSM) 'EXEC' SUMMARIZATION RTN.
         BALR      R9,R10
         TM        ERRSW,EREXSMRT  ERROR IN SUMMARIZATION RTN?
         BO        MAINERR        BIF ERROR IN EXEC SUMMARIZATION RTN
         B         ENDMAIN        OTHERWISE, ON TH THE NEXT STATEMENT
         SPACE     1
TRYEXEC  EQU       *
         TM        STRINDCS,EXECSTR EXECUTE STRING?
         BZ        TRYPROC        BIF NOT
         L         R10,=A(DOEXEC) 'EXEC' STMT' PROCESSOR RTN
         BALR      R9,R10
         TM        ERRSW,EREXECRT ERROR IN 'EXEC' PROC SUBROUTINE?
         BO        MAINERR        BIF YES
         L         R7,TEXTBUFP    SINCE SUBR MODIFIED R7, RESET
         TM        STRINDCS,LASTSTMT LAST STMT IN STEP?
         BZ        ENDMAIN        BIF NOT
         L         R10,=A(DOEXECSM) 'EXEC' SUMMARIZATION RTN
         BALR      R9,R10
         TM        ERRSW,EREXSMRT ERROR IN EXEC SUMMARIZATION RTN?
         BO        MAINERR        BIF YES
         B         ENDMAIN        ON TO NEXT CARD (STATEMENT)
         SPACE     1
TRYPROC  EQU       *
         TM        STRINDCS,PROCSTR IS THIS A 'PROC'STRING?
         BZ        TRYJOB         BIF NOT
         L         R10,=A(DOPROC) 'PROC' STMT PROCESSSOR RTN
         BALR      R9,R10
         TM        ERRSW,ERPROCRT ERROR IN 'PROC' STMT PROCESSING RTN?
         BO        MAINERR        BIF YES
         B         ENDMAIN        OTHERWISE, ON TO NEXT STMT
         SPACE     1
TRYJOB   EQU       *
         LA        R14,*          SET VALUE IN CASE BR TO MAINERR
         TM        STRINDCS,JOBSTR IS THIS A 'JOB' STATMENT
         BZ        MAINERR        BIF UNIDENTIFIED STRING
         L         R10,=A(DOJOB) 'JOB' STMT STRING PROCESSOR
         BALR      R9,R10
         TM        ERRSW,ERJOBRT  ERROR IN 'JOB' STMT PROCESSOR?
         BO        MAINERR        BIF YES
         SPACE     1
ENDMAIN  EQU       *
         TM        PARMSW,JOBFAIL WAS JOB FAILED BY PREV. RTN?
         BZ        READTEXT       BIF NOT (ON TO NEXT SMT)
         LA        R15,4          OTHERWISE, FAIL JOB
         B         SLOWEXIT
         SPACE     1
CALLLOOK EQU       *
         L         R10,=A(DOLOOKUP) JOB CLASS DETERMINATION RTN
         BALR      R9,R10
         TM        ERRSW,ERLKUPRT ERROR IN CLASS LOOKUP RTN?
         BO        MAINERR        BIF YES
         TM        PARMSW,DIAGFLAG   IS DIAGNOSTIC FLAG SET?
         BNO       LOOKNODG      BIF NOT; LOOKUP WITHOUT DIAGNOSTICS
         STM       R0,R15,SNAPREGS    STOW FOR DIAGNOSTICS
         BAL       R8,SNAPRTN    SNAP INFO TO DATA SET
LOOKNODG EQU       *
         DROP      R7
         SPACE     1
         L         R10,=A(DOSMFREC) WRITE OUT SMF RECORD
         BALR      R9,R10
         TM        PARMSW,DIAGFLAG   IS DIAGNOSTIC FLAG SET?
         BNO       SMFNODG       BIF NOT; READ WITHOUT DIAGNOSTICS
         STM       R0,R15,SNAPREGS    STOW FOR DIAGNOSTICS
         BAL       R8,SNAPRTN    SNAP INFO TO DATA SET
SMFNODG  EQU       *
         B         SLOWEXIT        NOW LEAVE
         SPACE     1
MAINERR  EQU       *
***********************************************************************
*
*        NOTE THAT THE CONTENTS OF R14, AS STOWED IN 'SNAPREGS',
*        SHOULD CONTAIN A PTR TO THE 'BAL' INSTRUCTION WHICH
*        CAUSED THE ERROR -> SUBTRACT R11 FROM R14 & YOU SHOULD
*        HAVE THE RELATIVE DISPLACEMENT OF THE STATEMENT WHICH
*        SIGNALLED THE ERROR
*
***********************************************************************
         STM       R0,R15,SNAPREGS   STOW FOR DIAGNOSTICS
         WTO       'IEFUJV-01-W - CALL SYSTEMS PROGRAMMING - FATAL ERROX
               R',ROUTCDE=1,DESC=2
         BAL       R8,SNAPRTN     CALL DIAG RTN
         SR        RF,RF          LEAVE QUIETLY
         ST        RF,JBRETURN
         SPACE     1
***********************************************************************
*
*        'SLOWEXIT' IS USED IF GETMAIN WAS DONE ABOVE;
*        'FASTEXIT' IS USED IF NO SUCH GETMAIN WAS DONE (-> NO SAVE
*        AREA CHAINING).
*
***********************************************************************
SLOWEXIT EQU       *
         TM        SNAPDCB+(DCBOFLGS-IHADCB),DCBOFOPN IS'SNAPDCB'OPEN?
         BZ        SLOWXIT1       BIF NOT
         CLOSE     MF=(E,CLOSLIST) CLOSE SNAP FILE
SLOWXIT1 EQU       *
         L         R3,JBRETURN    HOLD ONTO RETURN CODE FOR A SEC
         LTR       R3,R3          WAS RETURN CODE NON-ZERO?
         BZ        SLOWXIT2       BIF ZERO; DON'T FAIL JOB
         WTO       'IEFUJV-26-I - JOB FAILED',DESC=6,ROUTCDE=2
SLOWXIT2 EQU       *
         LR        R1,RD
         L         RD,SAVEAREA+4  LOAD SAVEAREA ADDRESS
         L         R0,GETPARM     R0,R1 USED FOR FREEMAIN
         FREEMAIN  R,LV=(0),A=(1)
         LR        RF,R3          PUT RC INTO IT'S RIGHTFUL REG.
FASTEXIT EQU       *
         RETURN    (14,12),RC=(15)
         TITLE     'IEFUJV - DIAGNOSTIC ROUTINE'
SNAPRTN  EQU       *
***********************************************************************
*
*        ROUTINE IS ENTERED VIA BAL R8,SNAPRTN
*        IF 'SNAPDCB' IS NOT ALREADY OPEN, THIS ROUTINE OPENS IT &
*        LEAVES IT OPEN; MAIN ROUTINE DURING TERMINATION WILL CLOSE IT.
*
*        THE CONTROL BLOCKS ARE 'SNAP'-DISPLAYED IN THE FOLLOWING
*        ORDER (WITH TITLES):
*              . CWA
*              . TEXTBUF FOR INTERNAL TEXT
*              . WORKAREA OF THIS PROGRAM
*              . INTERNAL TEXT ACB
*              . INTERNAL TEXT SDB
*              . SJB
*              . PDDB
*              . ACCOUNTING AREA ANCHORED OFF CVTUSER FIELD
*              . JMR (COMMON EXIT PARM AREA)
*
***********************************************************************
         LA        R1,0(,R12)     GET ADDR OF COMMON WORK AREA
         ST        R1,SNAPSTR1
         A         R1,CWAL        ADD LENGTH OF THAT AREA
         ST        R1,SNAPEND1
         L         R1,TEXTBUFP    CURRENT TEXT BUFFER
         LA        R1,0(,R1)      CLEAR HI-BYTE
         ST        R1,SNAPSTR2
         A         R1,WARPL+(RPLRLEN-IFGRPL) TEXT LENGTH
         ST        R1,SNAPEND2
         LA        R1,0(,R13)     IEFUJV WORKAREA
         ST        R1,SNAPSTR3
         LA        R1,WORKLGTH-8(,R1)
         ST        R1,SNAPEND3
         L         R1,WANELPTR
         USING     NELDSECT,R1
         L         R1,NELTXTCB    ADDR OF INTERNAL TEXT ACB
         USING     IFGACB,R1
         LA        R0,0(,R1)
         ST        R0,SNAPSTR4    ACB
         AH        R0,ACBLENG
         ST        R0,SNAPEND4
         L         R1,ACBDEB-1    ACB-> DEB
         USING     DEBBASIC,R1
         L         R2,DEBIRBAD    DEB - > SDB
         USING     SDBDSECT,R2
         LA        R2,0(,R2)      CLEAR HI-BYTE
         ST        R2,SNAPSTR5    SDB
         LA        R0,SDBLNG(,R2)
         ST        R0,SNAPEND5
         L         R1,SDBSJB      SDB -> SJB
         DROP      R1
         LA        R0,0(,R1) CLEAR HI-BYTE
         ST        R0,SNAPSTR6
         LA        R0,SJBLENG-SJBDSECT(,R1) SJB
         ST        R0,SNAPEND6
         L         R1,SDBPDDB     SDB -> PDDB
         LA        R1,0(,R1)
         ST        R1,SNAPSTR7
         LA        R1,PDBLENG(,R1)
         ST        R1,SNAPEND7
         L         R1,16          ADDR OF CVT
         USING     CVT,R1         MAKE IT ADDRESSABLE
         L         R1,CVTUSER
         USING     ACCTABLE,R1    MAKE ACCOUNTING AREA ADDRESSABLE
         LA        R1,0(,R1)      CLEAR HI-BYTE
         LTR       R1,R1          IS THERE AN ACCOUNTING AREA?
         BZ        SRNOACCT       BIF NOT
         ST        R1,SNAPSTR8
         L         R2,ACTBLEND
         ST        R2,SNAPEND8
SRNOACCT EQU       *
         DROP      R1
         L         R1,CWAJMRPT    GET PTR TO JMR
         LA        R1,0(,R1)      CLEAR HI-BYTE
         ST        R1,SNAPSTR9
         LA        R1,CEPLGTH(,R1)  BUMP TO ENDING ADDRESS
         ST        R1,SNAPEND9
         OI        SNAPEND9,X'80' END OF THIS MISERABLE LIST
         DROP      R2
         TM        SNAPDCB+(DCBOFLGS-IHADCB),DCBOFOPN ALREADY OPEN?
         BO        SROPENOK       BIF YES
         OPEN      MF=(E,OPENLIST)
         TM        SNAPDCB+(DCBOFLGS-IHADCB),DCBOFOPN OPEN OK?
         BO        SROPENOK       BIF YES
         WTO       'IEFUJV-02-W - OPEN FAILED FOR SNAPDUMP STATEMENT', X
               ROUTCDE=1,DESC=2
         BR        R8
SROPENOK EQU       *
         SNAP      MF=(E,SNAPMACR),DCB=SNAPDCB,LIST=SNAPLIST,          X
               PDATA=(REGS,SA),STRHDR=SNAPHDRA
         LTR       R15,R15        SNAP OK?
         BZ        SRSNAPOK
         WTO       'IEFUJV-03-W - SNAP OF DIAGNOSTIC AREAS FAILED',    X
               ROUTCDE=1,DESC=2
SRSNAPOK EQU       *
         BR        R8             RETURN
         TITLE     'IEFUJV - FUNCTION TO ADD ELEMENTS TO LIST'
LISTADD  EQU       *
***********************************************************************
*
*        ROUTINE ADDS AN ENTRY TO A STACK OF OBJECTS.  R1 -> TO
*        STACK PARAMETERS; R15 -> OBJECT TO BE ADDED TO LIST IF OBJECT
*        ADDED, BRANCH BACK TO ADDR STOWED IN R8; IF NOT ADDED, BRANCHE
*        BACK TO ADDR + 4 STOWED IN R8.
*
***********************************************************************
         LM        R2,R6,0(R1)    GET TABLE PARMS
         CR        R5,R3          WILL THIS BLOW TABLE?
         SPACE     1
         BH        4(,R8)         BIF NO ROOM LEFT
         EX        R6,LAMVC       ADD NEW ELEMENT
         LR        R2,R3          R2 -> NEW ENTRY
         SR        R3,R4          BUMP PTR FOR NEW AVAIL. SLOT
         ST        R3,4(,R1)      UPDATE PTR
         BR        R8             BRANCH TO NORMAL RETURN ADDR
LAMVC    MVC       0(0,R3),0(R15) PATTERN MVC INSTR
         TITLE     'IEFUJV - FUNCTION TO REMOVE ELEMENT FROM LIST'
LISTPULL EQU       *
***********************************************************************
*
*        ROUTINE REMOVE AN ENTRY FROM A STACK OF OBJECTS; R1 ->
*        TO STACK PARMS; R15 -> OBJECT TO BE DELETED FROM LIST; IF DEL
*        FAILS BECAUSE UNABLE TO FIND MATCH IN STACK,
*        RETURN TO ADDR+4(R8), OTHERWISE RETURN TO ADDR GIVEN IN R8.
*
***********************************************************************
         LM        R2,R6,0(R1)    GET STACK PTRS
         LR        R5,R2
         B         LPBXLE         INTO THE FRAY
LPCHECK  EQU       *
         EX        R6,LPCLC       DO WE HAVE A MATCH?
         BE        LPHIT          BIF YES
LPBXLE   EQU       *
         BXLE      R3,R4,LPCHECK  MARCH THRU TABLE
         B         4(,R8)         IF NO MORE TABLE, BR TO ERROR ADDR
         SPACE     1
LPHIT    EQU       *
         L         R5,4(,R1)      GET PREV. NEXT-AVAIL-SLOT ADDR
         LR        R6,R3          PTR TO SLOT TO BE OVERLAID
         LR        R14,R4         LENGTH OF ONE ELEMENT
         BCTR      R14,0          LENGTH -> LENFTH CODE
         LNR       R4,R4          MAKE ELEMENT LENGTH NEG.
         B         LPBXH          NOW SHIFT TABLE TO CLOSE HOLE
LPSHIFT  EQU       *
         EX        R14,LPMVC      SHIFT ONE ELEMENT
         AR        R6,R4          BUMP THE 'TO' PTR
LPBXH    EQU       *
         BXH       R3,R4,LPSHIFT  MARCH THRU UNTIL ALL SHIFTS MADE
         SR        R5,R4          UPDATE NEXT-AVAIL-SLOT-PTR
         ST        R5,4(,R1)      REPLACE VALUE IN STACK PARMS
         BR        R8             NORMAL RETURN
LPCLC    CLC       0(0,R3),0(R15) PATTERN CLC INSTR
LPMVC    MVC       0(0,R6),0(R3)  PATTERN MVC INSTR
         TITLE     'IEFUJV - FUNCTION TO SEARCH STACK SERIALLY'
LISTCHCK EQU       *
***********************************************************************
*
*        ROUTINE CHECKS FOR MATCH IN STACK W/ ARGUMENT POINTED TO
*        BY R15, IF MATCH FOUND, RETURN TO ADDR GIVEN IN R8 @ ENTRY;
*        IF NO MATCH, RETURN TO ADDR+4(R8).
*
***********************************************************************
         LM        R2,R6,0(R1)    GET STACK PARMS
         LR        R5,R2
         B         LCBXLE
LCCHECK  EQU       *
         EX        R6,LCCLC       DO WE HAVE A HIT?
         BNE       LCBXLE         BIF NOT
         LR        R2,R3          R2 HAS ADDR OF 'FOUND' ELEM
         BR        R8             NORMAL RETURN
LCBXLE   EQU       *
         BXLE      R3,R4,LCCHECK  MARCH THRU TABLE
         B         4(,R8)         ERROR RETURN (R8+4)
LCCLC    CLC       0(0,R3),0(R15) PATTERN CLC INSTR
         TITLE     'IEFUJV - BINARY SEARCH FUNCTION'
         TBINSRCH
         TITLE     'IEFUJV - PROGRAM CONSTANTS'
***********************************************************************
*
*        CONSTANTS
*
***********************************************************************
         DS        0D
CONSTNTS EQU       *
GETPARM  DC        AL1(241),AL3(WORKLGTH) SUBPOOL 241, ASSEM LGTH
SMFGMPRM DC        AL1(241),AL3(S239LTH)
PATRNDCB DCB       DSORG=PS,RECFM=VBA,MACRF=(W),BLKSIZE=882,           X
               LRECL=125,DDNAME=SNAPDUMP
SNAPHDRA DC        A(SNAPHDR1,SNAPHDR2,SNAPHDR3,SNAPHDR4,SNAPHDR5)
         DC        A(SNAPHDR6,SNAPHDR7,SNAPHDR8),AL1(128),AL3(SNAPHDR9)
SNAPHDR1 DC        AL1(30),CL30'COMMUNICATION WORK AREA'
SNAPHDR2 DC        AL1(30),CL30'BUFFER FOR INTERNAL TEXT'
SNAPHDR3 DC        AL1(30),CL30'PROGRAM WORKAREA'
SNAPHDR4 DC        AL1(30),CL30'INTERNAL TEXT ACB'
SNAPHDR5 DC        AL1(30),CL30'INTERNAL TEXT SDB'
SNAPHDR6 DC        AL1(30),CL30'SJB'
SNAPHDR7 DC        AL1(30),CL30'PDDB'
SNAPHDR8 DC        AL1(30),CL30'CVTUSER ACCT AREA'
SNAPHDR9 DC        AL1(30),CL30'JMR'
ZEROS    DC        3F'0'          USED IN REGISTER INITIALIZATION
MOVER    MVC       0(0,R1),1(R7)  USED BY 'EX' INSTR
PACKER   PACK      PACKWK,1(0,R7) DITTO
MOVERWL  MVC       0(0,R1),0(R7)  MOVER W/ LENGTH BYTE
*
PATRNTAB DS        0F             TAPE VOL TABLE INIT PATTERN
         DC        A(DHMAXVOL)    MAX VOLSERS PERMITTED IN STACK
         DC        A(0,0)         CURR/OVERFLOW COUNTERS
         DC        A(1)           BEGINNING REC FOR BINARY SEARCH
         DC        A(L'DHVOLSER-1) COMPARAND LENGTH CODE
         DC        A(DHVOLBT-DHVOLSER) ELEMENT LENGTH
         DC        AL1(TABINARY),AL3(0)  CONTROL FLAGS
*
PATRNPT  EQU       *              PATTERN PICKING TICKET
         DC        C'JOBNAME  *  PG# CPU-TIME KCORE'
         DC        C' KLNES 6250 1600 1K-DASD 1K-VIO TP DU UR'
*
PATRNWT1 WTO       'IEFUJV-27-I - XXXXXXXX HAS CPU AFFINITY RESTRICTION*
               S',ROUTCDE=2,DESC=6,MF=L
*
ACCTTRT  DS        0D
***********************************************************************
*        ACCOUNTING RTN PATTERN TEST TRANS TABLE
***********************************************************************
         DC        96XL1'00',C'-',96XL1'00',9CL1'A'
         DC        7XL1'00',9CL1'A',8CL1'00',8CL1'A'
         DC        6XL1'00',10CL1'N',6XL1'00'
         TITLE     'IEFUJV - DEVICE NAME VS UCBTYPE LOOKUP TABLE'
         DS        0D
DEVNAMET EQU       *
***********************************************************************
*
*        LOOKUP TABLE FOR DEVICE NAME VS UCBTYPE FIELD - INSTALLATION
*        DEPENDENT
*        TABLE IS ORDERED
*              1) BY LENGTH OF THE UNIT NAME - E.G. 8-CHAR, 7-CHAR
*              2) WITHIN SAME-LENGTH NAMES, BY RELATIVE FREQUENCY OF
*              OCCURRANCE
*
***********************************************************************
DEVNAME8 EQU       *
         DC        CL8'SLOWTAPE',XL4'00078000'
         DC        CL8'DSOBTAPE',XL4'00098000'
DEVNAME7 EQU       *
         DC        CL8'DUALDEN ',XL4'00088000'
DEVNAME6 EQU       *
         DC        CL8'3330-1  ',XL4'3050200D'
         DC        CL8'3400-6  ',XL4'32108003'
         DC        CL8'3400-5  ',XL4'32008003'
         DC        CL8'3400-4  ',XL4'34208003'
         DC        CL8'3400-3  ',XL4'34008003'
         DC        CL8'3400-2  ',XL4'30C08003'
         DC        CL8'2400-4  ',XL4'34208001'
         DC        CL8'2400-3  ',XL4'34008001'
         DC        CL8'2400-2  ',XL4'30C08001'
         DC        CL8'2400-1  ',XL4'30808001'
         DC        CL8'3286-2  ',XL4'1200100B'
         DC        CL8'3277-2  ',XL4'12001009'
         DC        CL8'SYSRDR  ',XL4'000D0800'
         DC        CL8'2305-1  ',XL4'30502006'
DEVNAME5 EQU       *
         DC        CL8'SYSWK   ',XL4'00032000'
         DC        CL8'SYSDA   ',XL4'00022000'
         DC        CL8'SYS50   ',XL4'00042000'
         DC        CL8'TAPE9   ',XL4'00068000'
         DC        CL8'PRIVL   ',XL4'00132000'
         DC        CL8'STRVL   ',XL4'00142000'
         DC        CL8'UCCVL   ',XL4'00152000'
         DC        CL8'SYSSQ   ',XL4'00012000'
         DC        CL8'SYSTS   ',XL4'000F2000'
         DC        CL8'V2314   ',XL4'00102000'
         DC        CL8'V3330   ',XL4'00112000'
         DC        CL8'V2305   ',XL4'00112000'
         DC        CL8'D2741   ',XL4'000B4000'
DEVNAME4 EQU       *
         DC        CL8'TAPE    ',XL4'00058000'
         DC        CL8'3350    ',XL4'3050200B'
         DC        CL8'BSC3    ',XL4'000C4000'
         DC        CL8'3213    ',XL4'10000830'
         DC        CL8'3211    ',XL4'10800809'
         DC        CL8'3215    ',XL4'10000823'
         DC        CL8'2540    ',XL4'10000801'
         DC        CL8'3505    ',XL4'10000806'
         DC        CL8'3525    ',XL4'1000080C'
         DC        CL8'2671    ',XL4'10000810'
         DC        CL8'2501    ',XL4'50000804'
         DC        CL8'1403    ',XL4'10000808'
         DC        CL8'3705    ',XL4'50004015'
         DC        CL8'3158    ',XL4'1200100C'
DEVNAME3 EQU       *
         DC        CL8'VIO     ',XL4'000E2000'
         DC        CL8'TWX     ',XL4'000A4000'
DEVNAME2 EQU       *
DEVNAME1 EQU       *
DEVNEND  EQU       *
DVNAME0A DC        A(DEVNEND)
DVNAME1A DC        A(DEVNAME1)
DVNAME2A DC        A(DEVNAME2)
DVNAME3A DC        A(DEVNAME3)
DVNAME4A DC        A(DEVNAME4)
DVNAME5A DC        A(DEVNAME5)
DVNAME6A DC        A(DEVNAME6)
DVNAME7A DC        A(DEVNAME7)
DVNAME8A DC        A(DEVNAME8)
         TITLE     'IEFUJV - ESOTERIC NAME TABLE'
         DS        0D
ESOTNAME EQU       *
***********************************************************************
*
*        TABLE OF ESOTERIC NAMES - INSTALLATION-DEFINED ESOTERIC
*        NAMES HAVE A SEQ. # EMBEDDED IN THE UCBTYPE FIELD THEY
*        ARE ASSOCIATED WITH - THIS TABLE IS ORDERED BY THIS SEQ. #.
*        THE HEX MASKS IN THE TABLE ARE 'EXCLUSIVE OR'ED' AGAINST
*        THE UCBTYPE FIELD MASKS ASSOCIATED WITH THE ESOTERIC NAME
*        THE RESULT SHOULD BE A UCBTYPE FIELD VALUE WHICH CORRESPONDS
*        A SPECIFIC DEVICE TYPE (E.G. 3330-11) - TRY ONE & SEE
*
***********************************************************************
ENSYSSQ  DC        X'3051000B'    1
ENSYSDA  DC        X'3052000B'    2
ENSYSWK  DC        X'3053000B'    3
ENSYS50  DC        X'3054000B'    4
ENTAPE   DC        X'32150003'    5
ENTAPE9  DC        X'34260003'    6
ENSLWTAP DC        X'32170003'    7
EN2DEN   DC        X'34280003'    8
ENDSOBTP DC        X'34290003'    9
ENTWX    DC        X'010A0050'    A
END2741  DC        X'050B0020'    B
ENBSC3   DC        X'060C0070'    C
ENSYSRDR DC        X'100D0006'    D
ENVIO    DC        X'FFF1000B'    E
ENSYSTS  DC        X'305F000B'    F
ENV2314  DC        X'FFEF0008'    10
ENV3330  DC        X'FFEE0009'    11
ENV2305  DC        X'FFED0007'    12
ENPRIVL  DC        X'3043000B'    13
ENSTRVL  DC        X'3044000B'    14
ENUCCVL  DC        X'3045000B'    15
         TITLE     'IEFUJV - DASD ATTRIBUTE TABLE'
         DS        0D
DABEG    DC        A(DA2305II)
DANXT    DC        A(DASDATTR-(DAEND-DA2305II))
DALTH    DC        A(DAEND-DA2305II)
DAMAX    DC        A(DASDATTR)
DALC     DC        A(1)
DASDATTR EQU       *
***********************************************************************
*
*        DASD ATTRIBUTE TABLE - USED IN CALC OF SPACE REQUESTS
*
***********************************************************************
*                  UCBTYP;TRKS/CYL;BYTES/TRK;OVERH'D;BYTES/CYL
DA333011 DC        X'200D',H'19',F'13165',F'135',F'247570'
DA3350   DC        X'200B',H'30',F'19254',F'185',F'572070'
DA3340   DC        X'200A',H'12',F'08535',F'167',F'100416'
DA3375   DC        X'200C',H'12',F'36000',F'224',F'429312'
DA3380   DC        X'200E',H'15',F'47968',F'256',F'715680'
DA2314   DC        X'2008',H'20',F'07395',F'101',F'145880'
DA3330   DC        X'2009',H'19',F'13165',F'135',F'247570'
DA2305II DC        X'2007',H'06',F'14858',F'198',F'087960'
DAEND    EQU       *
         TITLE     'IEFUJV - KEYWORD PROCESSOR LOOKUP TABLE'
KEYWDTAB EQU       *
***********************************************************************
*
*        TABLE USED AS LOOK-UP TO FIND CORRECT PROCOCESSOR FOR
*        AN INTERNAL TEXT STRING.
*
***********************************************************************
         DC        256XL1'00'     ALL ENTRIES INITIALL ZERO
ENDKYTAB EQU       *
         ORG       KEYWDTAB
         ORG       *+PROTECTK     DD 'PROTECT=' KEYWORD
         DC        AL1(4)
         ORG       KEYWDTAB
         ORG       *+DSIDK        DD 'DSID=' KEYWORD
         DC        AL1(8)
         ORG       KEYWDTAB
         ORG       *+MSVGPK       DD 'MSVGP=' KEYWORD PROCESSOR
         DC        AL1(12)
         ORG       KEYWDTAB
         ORG       *+HOLDK        DD 'HOLD=' KEYWORD PROCESSOR
         DC        AL1(16)
         ORG       KEYWDTAB
         ORG       *+DESTK        DD 'DEST=' KEYWORD
         DC        AL1(20)
         ORG       KEYWDTAB
         ORG       *+FUNCMK       DD 'FUNC=' MINOR KEYWORD
         DC        AL1(24)
         ORG       KEYWDTAB
         ORG       *+TERMK        DD 'TERM=' KEYWORD
         DC        AL1(28)
         ORG       KEYWDTAB
         ORG       *+OUTLIMK      DD 'OUTLIM=' KEYWORD
         DC        AL1(32)
         ORG       KEYWDTAB
         ORG       *+COPIESK      DD 'COPIES=' KEYWORD
         DC        AL1(36)
         ORG       KEYWDTAB
         ORG       *+UNITK        DD 'UNIT=' KEYWORD
         DC        AL1(40)
         ORG       KEYWDTAB
         ORG       *+LABELK       DD 'LABEL=' KEYWORD
         DC        AL1(44)
         ORG       KEYWDTAB
         ORG       *+VOLUMEK      DD 'VOLUME=' KEYWORD
         DC        AL1(48)
         ORG       KEYWDTAB
         ORG       *+AFFK         DD 'AFF=' KEYWORD
         DC        AL1(52)
         ORG       KEYWDTAB
         ORG       *+DISPK        DD 'DISP=' KEYWORD
         DC        AL1(56)
         ORG       KEYWDTAB
         ORG       *+SPACEK       DD 'SPACE=' KEYWORD
         DC        AL1(60)
         ORG       KEYWDTAB
         ORG       *+SPLITK       DD 'SPLIT=' KEYWORD
         DC        AL1(64)
         ORG       KEYWDTAB
         ORG       *+DSNAMEK      DD 'DSNAME=' KEYWORD
         DC        AL1(68)
         ORG       KEYWDTAB
         ORG       *+SYSOUTK      DD 'SYSOUT=' KEYWORD
         DC        AL1(72)
         ORG       KEYWDTAB
         ORG       *+SUBALLOK     DD 'SUBALLOC=' KEYWORD
         DC        AL1(76)
         ORG       KEYWDTAB
         ORG       *+AFFMK        DD 'AFF=' MINOR KEYWORD
         DC        AL1(80)
         ORG       KEYWDTAB
         ORG       *+SERMK        DD 'SER=' MINOR KEYWORD
         DC        AL1(84)
         ORG       KEYWDTAB
         ORG       *+REFMK        DD 'REF=' MINOR KEYWORD
         DC        AL1(88)
         ORG       KEYWDTAB
         ORG       *+EXPDTMK      DD 'EXPDT=' MINOR KEYWORD
         DC        AL1(92)
         ORG       KEYWDTAB
         ORG       *+RETPDMK      DD 'RETPD=' MINOR KEYWORD
         DC        AL1(96)
         ORG       KEYWDTAB
         ORG       *+BLKSIZMK     DD 'BLKSIZE=' MINOR KEYWORD
         DC        AL1(100)
         ORG       KEYWDTAB
         ORG       *+DENMK        DD 'DEN=' MINOR KEYWORD
         DC        AL1(104)
         ORG       KEYWDTAB
         ORG       *+DSORGMK      DD 'DSORG=' MINOR KEYWORD
         DC        AL1(108)
         ORG       KEYWDTAB
         ORG       *+LRECLMK      DD 'LRECL=' MINOR KEYWORD
         DC        AL1(112)
         ORG       KEYWDTAB
         ORG       *+OPTCDMK      DD 'OPTCD=' MINOR KEYWORD
         DC        AL1(116)
         ORG       KEYWDTAB
         ORG       *+RECFMMK      DD 'RECFM=' MINOR KEYWORD
         DC        AL1(120)
         ORG       KEYWDTAB
         ORG       *+DDK          DD 'DD' KEYWORD (DDNAME FIELD)
         DC        AL1(124)
         ORG       KEYWDTAB
         ORG       *+PRFMPEK
         DC        AL1(4)         EXEC 'PERFORM.' PROCESSOR
         ORG       KEYWDTAB
         ORG       *+PRFMEEK
         DC        AL1(8)         EXEC 'PERFORM=' PROCESSOR
         ORG       KEYWDTAB
         ORG       *+ADRSPPEK
         DC        AL1(12)        EXEC 'ADRSP.' PROCESSOR
         ORG       KEYWDTAB
         ORG       *+ADRSPEEK
         DC        AL1(16)        EXEC 'ADRSP=' PROCESSOR
         ORG       KEYWDTAB
         ORG       *+PGMEK        EXEC 'PGM=' KEYWORD
         DC        AL1(20)
         ORG       KEYWDTAB
         ORG       *+REGINPEK     EXEC 'REGION.' KEYWORD
         DC        AL1(24)
         ORG       KEYWDTAB
         ORG       *+REGINEEK
         DC        AL1(28)        EXEC 'REGION=' PROCESSOR
         ORG       KEYWDTAB
         ORG       *+TIMEPEK
         DC        AL1(32)        EXEC 'TIME.' PROCESSOR
         ORG       KEYWDTAB
         ORG       *+TIMEEEK
         DC        AL1(36)        EXEC 'TIME=' PROCESSOR
         ORG       KEYWDTAB
         ORG       *+EXECK        EXEC 'EXEC' PROCESSOR
         DC        AL1(40)
         ORG       KEYWDTAB
         ORG       *+PRFMJK
         DC        AL1(4)         JOB 'PERFORM=' PROCESSOR
         ORG       KEYWDTAB
         ORG       *+ADRSPJK
         DC        AL1(8)         JOB 'ADDRSP=' PROCESSOR
         ORG       KEYWDTAB
         ORG       *+TIMEJK
         DC        AL1(12)        JOB 'TIME=' PROCESSOR
         ORG       KEYWDTAB
         ORG       *+REGINJK
         DC        AL1(16)        JOB 'REGION=' PROCESSOR
         ORG       KEYWDTAB
         ORG       *+CLASSJK
         DC        AL1(28)        JOB 'CLASS=' KEYWORD PROCESSOR
         ORG       KEYWDTAB
         ORG       *+PRTYJK       JOB 'PRTY=' KEYWORD PROCESSOR
         DC        AL1(20)
         ORG       KEYWDTAB
         ORG       *+TYPRUNJK     JOB 'TYPRUN=' KEYWORD PROCESSOR
         DC        AL1(32)
         ORG       KEYWDTAB
         ORG       *+JOBK         JOB JOBNAME & ACCTING FIELD PROCESSOR
         DC        AL1(24)
         ORG       KEYWDTAB
         ORG       *+ENDK         END KEY PROCESSOR
         DC        AL1(128)
         ORG       ENDKYTAB
         LTORG
         TITLE     'IEFUJV - INITIALIZATION ROUTINE'
         DS        0D
INITRTN  EQU       *
***********************************************************************
*
*        ROUTINE TO INITIALIZE WORK AREAS & SWITCH INTERNAL
*        TEXT SCB FROM OUTPUT TO INPUT (PRETTY SLICK, EH?)
*
***********************************************************************
         USING     INITRTN,R10
         L         R0,GETPARM     SET UP SUBPOOL & LENGTH FOR GETMAIN
         GETMAIN   R,LV=(0)
         LR        R2,R1          HOLD ONTO GETMAIN PTR
         L         R3,GETPARM
         LA        R3,0(,R3)      CLEAR HI-BYTE
         SR        R4,R4
         SR        R5,R5
         MVCL      R2,R4          ZERO OUT GETMAINED AREA
         ST        R13,4(R1)      COMPLETE SAVEAREA CHAINING
         ST        R1,8(R13)
         LR        R13,R1
         MVI       AFFMASK,X'7F'  SET CPU AFFINITY MASK TO 'ALL'
         MVC       SNAPDCB(SNAPDCBL),PATRNDCB INITIALIZE AREAS
         MVI       JBNAME,C' '    PRIME THE FIRST BYTE
         MVC       JBNAME+1(JBSPCEND-JBNAME-1),JBNAME BLANK AREA
         LA        R1,SNAPDCB     BUILD 'OPEN' PARM LIST
         ST        R1,OPENLIST
         OI        OPENLIST,143   SET OPEN OPTIONS
         LA        R1,SNAPDCB
         ST        R1,CLOSLIST
         OI        CLOSLIST,128   OPTIONS FOR CLOSING THE FILE
         L         R1,CWAJMRPT    GET PTR TO JMR
         USING     COMMEXIT,R1    MAKE IT ADDRESSABLE
         TM        CEPIDFLG,CEPIDF06  IS DIAGNOSE SWITCH SET?
         DROP      R1
         BNO       INITNOPE       BIF NOT
         OI        PARMSW,DIAGFLAG SET IT ON IN OPTIONS AREA
         MVC       EYECATCH,=CL8'INITRTN '  EYE-CATCHER
         STM       R0,R15,SNAPREGS HOLD FOR DIAGNOSTICS
         BAL       R8,SNAPRTN     DISPLAY AREA
INITNOPE EQU       *
         LA        R1,PCREGEND    END OF LIST
         ST        R1,PCREGMAX    MAX ADDR FOR A TABLE ENTRY
         LA        R1,PCREGCMP    LENGTH CODE OF COMPARE OPERAND
         ST        R1,PCREGLC
         LA        R1,PCREGSIZ    SIZE OF ONE ENTRY
         ST        R1,PCREGLTH
         LA        R2,PCREG1ST    ADDR OF 1ST SLOT
         SR        R2,R1
         ST        R2,PCREGBEG
         ST        R2,PCREGNXT    INITIALLY, NEXT AVAIL SLOT
*
         LA        R1,PCTIMEND
         ST        R1,PCTIMMAX
         LA        R1,PCTIMCMP    LENGTH CODE FOR COMPARE OPER.
         ST        R1,PCTIMLC
         LA        R1,PCTIMSIZ    LENGTH OF ONE ELEMENY
         ST        R1,PCTIMLTH
         LA        R2,PCTIM1ST    ADDR OF 1ST ELEM
         SR        R2,R1          ADDJUST ADDR O FOR BXLE
         ST        R2,PCTIMBEG
         ST        R2,PCTIMNXT
*
         LA        R1,PCPFMEND
         ST        R1,PCPFMMAX
         LA        R1,PCPFMCMP    LENGTH CODE OF COMPARAND
         ST        R1,PCPFMLC
         LA        R1,PCPFMSIZ    LENGTH OF ONE ELEMENT
         ST        R1,PCPFMLTH
         LA        R2,PCPFM1ST
         SR        R2,R1
         ST        R2,PCPFMBEG
         ST        R2,PCPFMNXT
*
         LA        R1,PCADSEND
         ST        R1,PCADSMAX
         LA        R1,PCADSCMP    LENGTH CODE FOR COMPARAND
         ST        R1,PCADSLC
         LA        R1,PCADSSIZ
         ST        R1,PCADSLTH
         LA        R2,PCADS1ST
         SR        R2,R1
         ST        R2,PCADSBEG
         ST        R2,PCADSNXT
*
         LA        R1,PSDSEND
         ST        R1,PSDSMAX
         LA        R1,PSDSCMP     LENGTH CODE OF COMPARAND
         ST        R1,PSDSLC
         LA        R1,PSDSSIZE
         ST        R1,PSDSLGTH
         LA        R2,PSDS1ST
         SR        R2,R1
         ST        R2,PSDSBEG
         ST        R2,PSDSNXT
*
         LA        R1,UNAFEND
         ST        R1,UNAFMAX
         LA        R1,UNAFCMP
         ST        R1,UNAFLC
         LA        R1,UNAFSIZ
         ST        R1,UNAFLGTH
         LA        R2,UNAF1ST
         SR        R2,R1
         ST        R2,UNAFBEG
         ST        R2,UNAFNXT
*
         LA        R1,68          OPTION VALUE FOR 'CAMLST' MACRO
         STC       R1,DDCAMLST
         LA        R1,DDCAMDSN
         ST        R1,DDCAMLST+4
         LA        R1,DDCAMWRK
         ST        R1,DDCAMLST+12
*
         MVC       DHVOLTAB(TABENTRY-TABLE),PATRNTAB
*
         L         R6,WANELPTR    PTR TO INTERPRETER EXIT LIST
         USING     NELDSECT,R6    TELL ASSEMBLER
         LA        R7,NELTIME-1   GET DEFAULT JOB STEP TCB TIME
         LA        R1,3           LENGTH CODE
         EX        R1,PACKER      VALUE IS IN EBCDIC
         CVB       R3,PACKWK
         MH        R3,=H'60'      CONV. TO SECS.
         LA        R7,4(,R7)      BOUNCE TO SECS PORTION
         LA        R1,1
         EX        R1,PACKER
         CVB       R1,PACKWK
         AR        R3,R1          ADD REM. SECS. TO MINUTES
         ST        R3,JBNELTIM    STOW FOR LATER USE
         LA        R7,NELREG-1    GET ADDR OF DEFAULT REGION
         LA        R1,2           LENGTH CODE OF FIELD
         EX        R1,PACKER      CONVERT DEFAULT REGION VALUE
         CVB       R1,PACKWK
         STH       R1,JBNELREG    HOLD READER-DEFAULT REGION
         L         R6,NELTXTCB    GET ADDR OF INTERNAL TEXT ACB
         USING     IFGACB,R6
         ST        R6,WARPL+(RPLDACB-IFGRPL) STOW FOR LATER USE
         MVI       WARPL+(RPLOPT1-IFGRPL),RPLSEQ SET UP FOR 'ENDREQ'
         MVI       WARPL+(RPLOPT2-IFGRPL),00
         ST        RD,IWASACHN    STOW PREVIOUS S/A PTR
         LA        RD,IWAIOSA     GET ONE USED FOR I/O OPER.
         LA        R1,RPLADDR
         ENDREQ    RPL=(1)
         L         RD,IWASACHN    RESTORE ORIG S/A PTR
         LTR       RF,RF          BR IF PROBS
         BZ        INITTST1       BIF NO ERROR IN 'ENDREQ'
         BAL       R14,INITERR    PASS BACK ADDR @ WHICH ERROR OCCUR'D
INITTST1 EQU       *
         L         R6,ACBDEB-1    ACB -> DEB
         USING     DEBBASIC,R6
         L         R6,DEBIRBAD    DEB -> SDB
         USING     SDBDSECT,R6
         $GETBUF   TYPE=PROT      GET A PROTECTED BUFFER (FOR INTPUT)
         BZ        INITTST2       BIF 'GETBUF' DIDN'T FAIL
         BAL       R14,INITERR    GET ADDR OF THIS INSTR OFOR DIAG
INITTST2 EQU       *
         MODESET EXTKEY=ZERO,SAVEKEY=(2)
         ST    R2,SAVEPK    KOK (KEEP OLD KEY)
         LR    R4,R1        A(BUFFER)
         USING BFD,R4
         MVI   BFID,C'P'    MARK BUFFER PROTECTED
         ST    R1,SDBPBF    POINTER TO BUFFER
         LA    R0,BFIO      SET BUFFER I/O ADDR
         ST    R0,SDBCCW4   IN READ_DATA CCW
         DROP  R4
         MVI   SDBCCW4,6           CHANGE CCW TO READ
         MVI   SDBCHEND,SDBCEPNT   CHANGE CHAN END APP. TO POINT
         XI    SDBFLG1,SDB1GET+SDB1PUT CONVERT FROM PUT TO GET PROC.
         L     R2,SAVEPK    RESTORE OLD KEY
         MODESET KEYADDR=(2)
         L     R5,WANELPTR
         USING NELDSECT,R5
         MVI   WARPL+(RPLREQ-IFGRPL),RPLPOINT REQUEST POINT
         MVC   WARPL+(RPLDACB-IFGRPL)(4),NELTXTCB A(INT. TEXT ACB)
         DROP  R5
         MVC   WARPL+(RPLRBAR-IFGRPL)(8),=X'0000000000000000' PFFT
         LA    R5,WARPL+(RPLRBAR-IFGRPL) GET ADDR OF ARG
         ST    R5,WARPL+(RPLARG-IFGRPL)  STUFF IN RPL
         ST    RD,IWASACHN         SWAP S/A PTRS
         LA    RD,IWAIOSA          BLAH BLAH
         LA    R1,RPLADDR          FOR POINTER (OR RETRIEVER??)
         POINT RPL=(1)
         L     RD,IWASACHN         RESTORE RD
         LTR   RF,RF               POINT OK ??
         BZ    INITTST4            B IF OK
         BAL   R14,INITERR         POINT SMELLS
INITTST4 EQU   *
         MVI       WARPL+(RPLREQ-IFGRPL),RPLGET 'GET' OPERATION
         MVC       WARPL+(RPLAREA-IFGRPL)(4),TEXTBUFP PTR TO BUFFER
         MVI       WARPL+(RPLOPT1-IFGRPL),RPLSEQ SEQUENTIAL OPER.
         MVI       WARPL+(RPLOPT2-IFGRPL),00 NO INTERFERENCE
         LH        R0,=H'8184'
         ST        R0,WARPL+(RPLBUFL-IFGRPL) BUF LGHT = BUFTH-HDR
         XC        WARPL+(RPLDDDD-IFGRPL)(4),WARPL+(RPLDDDD-IFGRPL)
         XC        WARPL+(RPLERRCD-IFGRPL)(1),WARPL+(RPLERRCD-IFGRPL)
         L         R4,SDBSJB
         USING     SJBDSECT,R4
         ST        R4,JOBSJB      HOLD ONTO JOB'S SJB ADDRESS
         SR        R0,R0          CLEAR REGISTER
         L         R1,SJBESTLN    GET # OF EST LINES OF SYSOUT
         LA        R1,999(,R1)    FORCE ROUNDING
         D         R0,=F'1000'    CONV. TO 1,000'S OF LINES
         STH       R1,JBLINES     STOW FOR LATER USE
         MVC       JBHASP#(5),SJBJOBID+3 GET JES-ASSIGNED #
         MVC       JBHASP(4),SJBJOBID+4 HOLD FOR OTHER USES AS WELL
         PACK      PACKWK,JBHASP  CONV. & STOW JES JOB #
         CVB       R15,PACKWK
         L         R14,CWAJMRPT   GET ADDR OF JOB'S JMR
         USING     COMMEXIT,R14
         STH       R15,CEPIDJES
         DROP      R14
         L         R4,SJBJCT      GET JCT ADDR
         USING     JCTDSECT,R4    GIVE IT ADDRESSABILITY
         ST        R4,JOBJCT      STOW JCT POINTER
         MVC       JBPGMRNM,JCTPNAME GET 'PROGRAMMER NAME' FIELD
         MVC       JBACTWRK(2),JCTPRTY
         CLI       JBACTWRK,C' '  LEADING BLANK?
         BNE       INITTST3       BIF NOT
         MVI       JBACTWRK,C'0'  MAKE IT A LEADING ZERO
INITTST3 EQU       *
         TR        JBACTWRK(2),ACCTTRT CHECK FOR VALID NUMERICS
         CLC       JBACTWRK(2),=C'NN' NUMERIC?
         BNE       INITSHFT       IF NOT, BYPASS STOW OPERATION
         LA        R7,JCTPRTY-1
         LA        R1,1           LENGTH CODE
         EX        R1,PACKER
         CVB       R0,PACKWK
         STH       R0,JBPRTY
INITSHFT EQU       *
         LA        R1,JBHASP#     LEFT-JUSTIFY THIS #
         LA        R2,1
         LA        R3,JBHASP#+4
INITCLI  EQU       *
         CLI       0(R1),C' ' LOOK FOR FIRST NON-BLANK CHAR
         BNE       INITMOVE
         BXLE      R1,R2,INITCLI KEEP ON TRUCKIN'
INITMOVE EQU       *
         LA        R2,JBHASP#
         LA        R3,JBHASP#+4
         SR        R3,R1
         BM        INITEND        CAN'T USE NEG. #
         EX        R3,INITMVC     MOVE # INTO FIELD LEFT-JUSTIFIED
         LA        R2,1(R2,R3)    BOUNCE TO BYTE AFTER STRING
         MVI       0(R2),C' '     PUT A BLANK IN HERE TO SIGNAL ENTEXT
         B         INITEND
INITERR  EQU       *
         OI        ERRSW,ERINITRT SET ERROR SWITCH FOR THIS RTN
INITEND  EQU       *
         BR        R9             RETURN
INITMVC  MVC       0(0,R2),0(R1)  PATTERN MVC
         LTORG
         DROP      R4,R6,R10
         TITLE     'IEFUJV - INTERNAL TEXT READ ROUTINE'
         DS        0D
***********************************************************************
*
*        ROUTINE TO READ INTERNAL TEXT FILE
*
***********************************************************************
READRTN EQU        *
         USING     READRTN,R10    ESTAB. ADDRESSABILITY
         MVC       EYECATCH,=CL8'READRTN '  PUT IN EYECATCHER
         ST        RD,IWASACHN    SAVE CURR. S/A PTR
         LA        RD,IWAIOSA     GET PTR TO I/O S/A PTR
         LA        R1,RPLADDR     ADDR OF REQUEST PARM LIST
         GET       RPL=(1)
         L         RD,IWASACHN    RESTORE CURR S/A PTR
         LTR       RF,RF          HOW'D WE DO?
         BZ        READEND        BIF OK
         CLI       WARPL+(RPLRTNCD-IFGRPL),RPLLOGER LOCICAL ERROR?
         BE        READTST1       BIF SO
         BAL       R14,READERR    OTHERWISE, FLAG AS ERROR
READTST1 EQU       *
         CLI       WARPL+(RPLERRCD-IFGRPL),RPLEODER EOD DETECTED?
         BE        READEOF        BIF NOT
         BAL       R14,READERR    OTHERWISE, FLAG AS ERROR
READEOF  EQU       *
         OI        PARMSW,EOFSW   SET EOF SWITCH
         B         READEND
         SPACE     1
READERR  EQU       *
         OI        ERRSW,ERREADRT SET ERROR INDICATOR
READEND  EQU       *
         BR        R9             RETURN
         LTORG
         DROP      R10
         TITLE     'IEFUJV - JOB STATEMENT PROCESSOR'
         DS        0D
DOJOB    EQU       *
***********************************************************************
*
*        PROCESS KEYWORDS ON THE JOB CARD
*
***********************************************************************
         USING     DOJOB,R10      ESTAB BASE REG
         MVC       EYECATCH,=CL8'JOBCARD'  MOVE IN EYECATCHER
         USING     TEXT,R7        GIVE TEXT STRING ADDRESSABILITY
         LA        R7,STRJKEY     ADDR OF INTERNAL TEXT STRING
         DROP      R7
DJNXTSTG EQU       *
         C         R7,ENDSTRNG    HAVE WE EXCEEDED STRING LENGTH?
         BL        DJSTGOK        BIF WE HAVEN'T EXCEEDED STR. LGTH
         BAL       R14,DJERROR    CAPTURE THIS ADDR BEFORE BR.
DJSTGOK  EQU       *
         MVC       KEYVALUE(1),0(R7)
         TR        KEYVALUE,KEYWDTAB FIGURE OUT WTG DISPLACEMENT
         LM        R4,R6,ZEROS    ZERO OUT CERTAAIN WORK REGS
         IC        R5,KEYVALUE    GET DISP FOR WTG TABLE
         CLI       0(R7),ENDK     END OF STRING INDICATOR?
         BE        DJWTGBR        BIF IT IS; BYPASS ADDIT'L TESTS
         IC        R6,1(,R7)      # OF POSITIONAL PARMS
         CLC       1(2,R7),=X'0100' NULL STRING?
         LA        R7,2(,R7)      BUMP UP STRING POINTER
         BE        DJSKPFLD       BIF NULL STRING
         LTR       R6,R6          NO PARMS
         BZ        DJNXTSTG       BIF NOT
DJWTGBR  B         DJWTG(R5)      DIVE INTO WTG
DJWTG    EQU       *
         B         DJSKPFLD       =0; SKIP TO NEXT KEYWORD
         B         DJPFRM         =4; PERFORM = KEYWORD PROCESSOR
         B         DJADDRSP       =8; ADDRSP= KEYWORD PROCESSOR
         B         DJTIME         =12; TIME= KEYWORD PROCESSOR
         B         DJREGION       =16; REGION= KEYWORD PROCESSOR
         B         DJPRTY         =20; PRTY= KEYWORD PROCESSOR
         B         DJOBNAME       =24; JOBNAME & ACCTING PROCESSOR
         B         DJCLASS        =28; CLASS= KEYWORD PROCESSOR
         B         DJTYPRUN       =32; TYPRUN= KEYWORD PROCESSOR
         BAL       R14,DJERROR    =36; WE SHOULDN'T BE HERE
         BAL       R14,DJERROR    =40; WE SHOULDN'T BE HERE
         BAL       R14,DJERROR    =44; WE SHOULDN'T BE HERE
         BAL       R14,DJERROR    =48; WE SHOULDN'T BE HERE
         BAL       R14,DJERROR    =52; WE SHOULDN'T BE HERE
         BAL       R14,DJERROR    =56; WE SHOULDN'T BE HERE
         BAL       R14,DJERROR    =60; WE SHOULDN'T BE HERE
         BAL       R14,DJERROR    =64; WE SHOULDN'T BE HERE
         BAL       R14,DJERROR    =68; WE SHOULDN'T BE HERE
         BAL       R14,DJERROR    =72; WE SHOULDN'T BE HERE
         BAL       R14,DJERROR    =76; WE SHOULDN'T BE HERE
         BAL       R14,DJERROR    =80; WE SHOULDN'T BE HERE
         BAL       R14,DJERROR    =84; WE SHOULDN'T BE HERE
         BAL       R14,DJERROR    =88; WE SHOULDN'T BE HERE
         BAL       R14,DJERROR    =92; WE SHOULDN'T BE HERE
         BAL       R14,DJERROR    =96; WE SHOULDN'T BE HERE
         BAL       R14,DJERROR    =100; WE SHOULDN'T BE HERE
         BAL       R14,DJERROR    =104; WE SHOULDN'T BE HERE
         BAL       R14,DJERROR    =108; WE SHOULDN'T BE HERE
         BAL       R14,DJERROR    =112; WE SHOULDN'T BE HERE
         BAL       R14,DJERROR    =116; WE SHOULDN'T BE HERE
         BAL       R14,DJERROR    =120; WE SHOULDN'T BE HERE
         BAL       R14,DJERROR    =124; WE SHOULDN'T BE HERE
         B         DJENDKEY       =128; END-OF-TEXT PROCESSOR
         SPACE     2
DJPRTY   EQU       *
DJSKPFLD EQU       *
***********************************************************************
*        SKIP TO ANOTHER KEYWORD
***********************************************************************
         IC        R5,0(,R7)      GET POS. PARM LENGTH/SUBFIELD INDIC
         S         R5,=F'128'     IF X'80' IN FIELD, WE HAVE A SUBFIELD
         BNZ       DJSKPTST       HOPE THIS NEVER FALLS THRU
         BAL       R14,DJERROR    RECORD 'FROM' ADDR
DJSKPTST EQU       *
         BM        DJREGSTG       BIF WE HAVE REG STRING
         LA        R7,1(,R7)      BUMP TO NEXT POS.
DJSUBSTG EQU       *
         IC        R4,0(,R7)      GET LENGTH OF SUBFIELD
         LA        R7,1(R4,R7)    BOUNCE TO NEXT SUBFIELD STRING
         BCT       R5,DJSUBSTG    FINISHED WITH SUBSTRING?
         B         DJTSTEND
         SPACE     1
DJREGSTG EQU       *
         LA        R7,129(R7,R5)  POINT TO NEXT LENGTH INDIC
         SR        R5,R5
DJTSTEND EQU       *
         BCT       R6,DJSKPFLD    ARE WE @ END OF CURR. STRING?
DJLEAVE  EQU       *
         B         DJNXTSTG
         SPACE     3
DJPFRM   EQU       *
***********************************************************************
*        PROCESS 'PERFORM=' KEYWORD
***********************************************************************
         IC        R5,0(,R7)      GET LENGTH OF DATA
         S         R5,=F'1'       LENGTH TO LENGTH CODE
         BM        DJ4            BIF BAD LENGTH CODE
DJPGNOK  EQU       *
         EX        R5,PACKER      PACK THE NUMERIC PERF. GROUP #
         CVB   R0,PACKWK
         STH       R0,JBPGN       STOW FOR LATER USE
         OI        JBSW,JBPERFM   SET SWITCH TO SAY WE HAVE PGN
DJ4      EQU       *
         LA        R7,2(R5,R7)    BOUNCE TO NEXT CHUNK OF TEXT
DJPFRMED EQU       *
         B         DJNXTSTG       ONWARD
         SPACE     3
DJADDRSP EQU       *
***********************************************************************
*        PROCESS 'ADDRSP=' KEYWORD
***********************************************************************
         IC        R5,0(,R7)      LENGTH OF DATA IN TEXT STRING
         S         R5,=F'4'       CHECK FOR VALID TEXT LENGTH
         BNZ       DJVEQV         BIF BAD OPERAND LENGTH
DJVRTST1 EQU       *
         CLI       1(R7),C'V'     'VIRT'?
         BE        DJVEQV         V=V REQUESTED (DEFAULT)
         OI        JBSW,JBVEQR    V=R
DJVEQV   EQU       *
         LA        R7,5(,R7)      SKIP TO NEXT KEYWORD VALUE
DJADSPED EQU       *
         B         DJNXTSTG       ONWARD
         SPACE     3
DJTIME   EQU       *
***********************************************************************
*        PROCESS 'TIME=' KEYWORD
***********************************************************************
         OI        JBSW,JBTIMEQ   'TIME=' WAS SPEC. ON JOB CARD
         IC        R5,0(,R7)      GET LENGTH/SUBFIELD INDIC
         S         R5,=F'1'       SEE IF 'MINUTES' PORTION PRESENT
         BM        DJSCONLY       BIF SECONDS ONLY
         EX        R5,PACKER
         CVB       R0,PACKWK
         STH       R0,JBMINS      # OF TCB MINUTES PERMITTED
DJSCONLY EQU       *
         LA        R7,2(R5,R7)    SKIP TO NEXT SUBFIELD
         S         R6,=F'1'       ANY MORE SUBFIELDS?
         BP        DJSECS         DO SECONDS
         B         DJENDTIM       OTHERWISE,, ON TO OTHER THINGS
DJSECS   EQU       *
         SR        R5,R5          MAKE SURE R5 HAS NO UNUSUAL VALUE
         IC        R5,0(,R7)      PICK UP LENGTH OF FIELD
         S         R5,=F'1'       LENGTH -> LENGTH CODE
         BM        DJNULLTM       NULL SECONDS VALUE
         OI        JBSW,JBTIMEQ   'TIME=' WAS SPEC. ON JOB CARD
         EX        R5,PACKER
         CVB       R0,PACKWK
         STH       R0,JBSECS      STOW 'SECONDS' FOR LATER USE
DJNULLTM EQU       *
         LA        R7,2(R5,R7)    BOUNCE PAST IT ALL
DJENDTIM EQU       *
         LH        R0,JBMINS      CONVERT THIS ALL TO SECS
         MH        R0,=H'60'
         AH        R0,JBSECS
         ST        R0,JBTIME
         B         DJNXTSTG       ONWARD
         SPACE     3
DJREGION EQU       *
***********************************************************************
*        PROCESS 'REGION=' KEYWORD
***********************************************************************
         IC        R5,0(,R7)
         S         R5,=F'2'       -> LENGTH CODE - 1
         BM        DJENDREG       BIF NEGATIVE REGION VALUE LGTH
         EX        R5,PACKER      PACK REGION VALUE
         CVB       R0,PACKWK
         STH       R0,JBREGION
DJENDREG EQU       *
         LA        R7,3(R5,R7)    BOUNCE PAST TEXT TO NEXT KEYWORD
         B         DJNXTSTG
         SPACE     3
DJTYPRUN EQU       *
***********************************************************************
*        PROCESS 'TYPRUN=' KEYWORD
***********************************************************************
         IC        R5,0(,R7)      LENGTH OF STRING
         C         R5,=F'4'       CORRECT LENGTH FOR 'HOLD'?
         BNE       DJNOTYPR       BIF NOT
         CLI       1(R7),C'H'     TYPRUN=HOLD?
         BNE       DJNOTYPR       BIF NOT
         OI        JBSW,JBHOLDRQ  SET SWITCH FOR 'TYPRUN=HOLD'
DJNOTYPR EQU       *
         LA        R7,1(R5,R7)    BOUNCE TO NEXT STRING
         B         DJNXTSTG       ONWARD
         SPACE     3
DJOBNAME EQU       *
***********************************************************************
*        PROCESS 'JOBNAME' & ACCOUNTING INFO
***********************************************************************
         IC        R5,0(,R7)      LENGTH OF 1ST STRING
         S         R5,=F'1'
         LA        R1,JBNAME      MOVE JOBNAME
         EX        R5,MOVER
         LA        R5,1(,R5)
         S         R6,=F'1'       DECREMENT STRING COUNT
         BNP       DJENDJOB       END OF JOBNAME/ACCTING INFO
         LA        R7,1(R5,R7)    BOUNCE TO NEXT FIELD
         IC        R5,0(,R7)      LENGTH OF NEXT STRING
         S         R5,=F'128'     CHECK FOR SUBSTRINGS
         BNZ       DJOBTST1       HOPE FALL-THRU CASE DOESN'T OCCUR
         BAL       R14,DJERROR
DJOBTST1 EQU       *
         BM        DJ1ACCT        IF NEG, THIS STRNG HAS ONLY 1 ACCT
         IC        R4,1(,R7)      GET LENGTH OF SUBLFIELD
         LA        R1,JBACCT1
         LA        R7,1(,R7)      BOUNCE TO BEG. OF SUBFIELD
         EX        R4,MOVERWL     MOVE ACCT1 FIELD W/LENGTH
         LA        R7,1(R4,R7)    BOUNCE TO NXET FIELD
         S         R5,=F'1'       HOW MANY MORE SUBFIELDS
         BZ        DJTSTLOP       BIF NO MORE
         LA        R1,JBACCT2
         IC        R4,0(,R7)
         EX        R4,MOVERWL
         LA        R7,1(R4,R7)
         S         R5,=F'1'       ANY MORE SUBFIELDS
         BZ        DJTSTLOP       BIF NONE MORE
DJACTLOP EQU       *
         IC        R4,0(,R7)      KEEP SKIPING IUNTIL NEXT KEYWORD
         LA        R7,1(R4,R7)
         BCT       R5,DJACTLOP
         B         DJTSTLOP
DJJOBLOP EQU       *
         IC        R5,0(,R7)
         LA        R7,1(R5,R7)    GRIND UNTIL TURU LOOP
DJTSTLOP EQU       *
         BCT       R6,DJJOBLOP
         B         DJENDJOB
DJ1ACCT  EQU       *
         LA        R5,128(,R5)
         LA        R1,JBACCT1
         EX        R5,MOVERWL     MOVE W/ LENGTH BYTE
         LA        R7,1(R5,R7)
         B         DJTSTLOP
DJENDJOB EQU       *
         B         DJNXTSTG       ONWARD
         SPACE     3
DJCLASS  EQU       *
***********************************************************************
*        PROCESS 'CLASS=' KEYWORD
***********************************************************************
         IC        R5,0(,R7)      GET LENGTH OF KEYWORD VALUE
         S         R5,=F'1'       LENGTH -> LENGTH CODE
         BM        DJCLSXIT       BIF NULL STRING
         LA        R1,JBCLSVAL    STOW CLASS VALUE
         EX        R5,MOVER
DJCLSXIT EQU       *
         LA        R7,2(R5,R7)    BOUNCE TO NEXT STRING
         B         DJNXTSTG
         SPACE     3
DJENDKEY EQU       *
***********************************************************************
*
*        ACCOUNT VALIDATE ROUTINE CHECKS FOR THE FOLLOWING INFO:
*              . JOB CARD MUST HAVE THE FOLLOWING FORMAT:
*
*                  //AAXXXXXX JOB UUU-AA-FF-T,PGMRNAME,.....
*                                 OR
*                  //AAXXXXXX JOB (UUU-AA-FF-T,WWWWWW),PGMRNAME,....
*                                 OR
*                  //AAXXXXXX JOB (UUU-AA-FF-T,WWWWWWWW),PGMRNAME,...
*              WHERE:
*                  AA = APPLICATION CODE
*                  UUU = USER CODE
*                  FF = FUNCTION CODE
*                  T = RUNTYPE CODE
*                  W = WORK ORDER # - IF THE WORK ORDER # IS 8 CHAR,
*                                 IT MUST HAVE THE FORMAT: MMDDYYNN,
*                                 WHERE MM = MONTH, DD = DAY, YY = YEAR
*                                 & NN ARE ANY 2 NUMBERS
*                  XXXXXX = ANY USER-SPECIFIED CHARACTERS
*
***********************************************************************
         PRINT     ON,NOGEN
         SR        R6,R6
         IC        R6,JBACCT1     GET LENGTH OF 1ST ACCTING FIELD
         CH        R6,=H'11'      CORRECT LENGTH?
         BE        DJENDOK1       BIF PASSED 1ST TEST
         OI        JBSW,JBINVACT  OTHERWISE, SET 'INV. ACCT ' FLAG
         WTO       'IEFUJV-04-I - ACCOUNTING CODE FIELD HAS INVALID LENX
               GTH',ROUTCDE=2,DESC=6
         B         DJENDXIT       CAN'T DO ANYTHING MORE
DJENDOK1 EQU       *
         MVC       JBACTWRK(11),JBACCT1+1 TRANSFER FOR TR INSTR
         TR        JBACTWRK(11),ACCTTRT CONVERT TO TEST PATTERN
         CLC       JBACTWRK,=C'NNN-AA-AA-A' N=NUMERIC;A=ALPHA
         BE        DJENDOK2       BIF VALID FORMAT
         OI        JBSW,JBINVACT  SET 'INVALID ACCT' SWITCH
         WTO       'IEFUJV-05-I - 1ST ACCOUNTING CODE FIELD HAS INVALIDX
                FORMAT',ROUTCDE=2,DESC=6
         B         DJENDXIT       BYPASS ADDITIONAL FORMAT TESTS
DJENDOK2 EQU       *
         MVC       JBACTWRK(2),JBNAME MOVE JOBNAME TO WORK AREA
         TR        JBACTWRK(2),ACCTTRT CONVERT TO TEST PATTERN
         CLC       JBACTWRK(2),=C'AA' ALPHABETIC?
         BE        DJENDOK3       BIF YES
DJENDBD1 EQU       *
         WTO       'IEFUJV-06-I - APPLICATION CODE IS NOT IN JOBNAME FIX
               ELD',ROUTCDE=2,DESC=6
DJENDOK3 EQU       *
         CLC       JBNAME(2),JBACCT1+5 IS APPL CODE IN JOB NAME?
         BE        DJENDOK4       BIF YES
         OI        JBSW,JBINVACT  FATAL ERROR FOR JOB
         WTO       'IEFUJV-07-I - APPLICATION CODE IN ACCTNO AND JOBNAMX
               E FIELD DO NOT MATCH',ROUTCDE=2,DESC=6
DJENDOK4 EQU       *
         SR        R6,R6
         IC        R6,JBACCT2     LENGTH OF 2ND ACCOUNTING FIELD
         LTR       R6,R6          IS THERE ANY?
         BZ        DJENDOK8       NO WORK ORDER #
         CH        R6,=H'6'       SINCE WE HAVE W/O#, IS IT VALID LGTH?
         BNE       DJENDCK1       CHECK FOR SCC WO# LENGTH
         MVC       JBACTWRK(6),JBACCT2+1 IS SERVICE DEPT. W/O #
         TR        JBACTWRK(6),ACCTTRT CONVERT TO TEST PATTERN
         CLC       JBACTWRK(6),=C'NNNNNN' NUMERIC ?
         BE        DJENDOK8       W/O # IS OK
         OI        JBSW,JBINVACT  OTHERWISE, INVALID W/O # FORMAT
         WTO       'IEFUJV-08-I - SERVICE DEPT. WORK ORDER # IS INVALIDX
               ',ROUTCDE=2,DESC=6
         B         DJENDOK8
DJENDCK1 EQU       *
         CH        R6,=H'8'       IF NOT 6-LONG, THEN 8-LONG?
         BE        DJENDOK6       BIF 8-LONG
         OI        JBSW,JBINVACT  OTHERWISE, INVALID W/O # LENGTH
         WTO       'IEFUJV-09-I - INVALID WORK ORDER # LENGTH',        X
               ROUTCDE=2,DESC=6
         B         DJENDOK8       ON TO OTHER TESTS
DJENDOK6 EQU       *
         MVC       JBACTWRK(8),JBACCT2+1 MOVE 2ND ACCTING FIELD INTO
         TR        JBACTWRK(8),ACCTTRT WORK AREA FOR TST PAT. CONV.
         CLC       JBACTWRK(8),=C'NNNNNNNN' VALID NUMERICS?
         BE        DJENDOK7       BIF OK
         OI        JBSW,JBINVACT OTHERWISE, SIGNAL ACCTING ERROR
         WTO       'IEFUJV-10-I - SCC WORK ORDER # IS INVALID',        X
               ROUTCDE=2,DESC=6
         B         DJENDOK8
DJENDOK7 EQU       *
         PACK      PACKWK,JBACCT2+1(2) GET 'MONTH' VALUE
         CP        PACKWK,=P'01' CHECK FOR VALID RANGE (01-12)
         BL        DJENDBD2
         CP        PACKWK,=P'12'
         BH        DJENDBD2
         PACK      PACKWK,JBACCT2+3(2) GET 'DAY' VALUE
         CP        PACKWK,=P'01' CHECK FOR VALID RANGE (01-31)
         BL        DJENDBD3
         CP        PACKWK,=P'31'
         BH        DJENDBD3
         PACK  PACKWK,JBACCT2+5(2) GET 'YEAR' VALUE
         CP        PACKWK,=P'78' CHECK FOR REASONABLE VALUE
         BL        DJENDBD4
         CP        PACKWK,=P'90'
         BNH       DJENDOK8       BIF RANGE CHECK OK
DJENDBD4 EQU       *
         OI        JBSW,JBINVACT  SET 'INVALID ACCT' SWITCH
         WTO       'IEFUJV-11-I - INVALID YEAR IN WORK ORDER #',       X
               ROUTCDE=2,DESC=6
         B         DJENDOK8       CONTINUE W/ OTHER CHECKS
DJENDBD3 EQU       *
         OI        JBSW,JBINVACT  SET 'INVALID ACCT' SWITCH
         WTO       'IEFUJV-12-I - INVALID DAY IN WORK ORDER #',        X
               ROUTCDE=2,DESC=6
         B         DJENDOK8
DJENDBD2 EQU       *
         OI        JBSW,JBINVACT
         WTO       'IEFUJV-13-I - INVALID MONTH IN WORK ORDER #',      X
               ROUTCDE=2,DESC=6
         B         DJENDOK8
DJENDOK8 EQU       *
         L         R1,16          GET POINTER TO CVT
         USING     CVT,R1         MAKE IT ADDRESSABLE
         L         R1,CVTUSER     GET POINTER TO ACCT AREA
         LA        R1,0(,R1)      CLEAR HI-BYTE
         LTR       R1,R1          IS ACCTING TABLE LOADED?
         BZ        DJENDOKX       BIF NOT
         ST        R1,JBACTADR    HOLD ONTO THIS POINTER
         USING     ACCTABLE,R1    GIVE AREA ADDRESSABILITY
         CLI       ACFLAG,ACLOADED IS THE ACCTING TABLE LOADED?
         BE        DJENDOK5       BIF YES
DJENDOKX EQU       *
         WTO       'IEFUJV-14-I - ACCOUNTING CODE TABLES NOT LOADED - CX
               ALL SYSTEMS PROGRAMMING',ROUTCDE=2,DESC=6
         B         DJENDXIT
DJENDOK5 EQU       *
         CLI       ACVERSN,ACVER# IS CORRECT VERSION OF TABLES AVAIL?
         BE        DJENDTOK       BIF YES
*
         WTO       'IEFUJV-29-I - INCORRECT VERSION OF ACCOUNTING TABLE*
               S LOADED',ROUTCDE=2,DESC=6
         B         DJENDXIT       NOW LEAVE
*
DJENDTOK EQU       *
         L         R7,ACAPADDR    ADDR OF APPLICATION CODE TABLE
         USING     APPLCODE,R7    GIVE TABLE ADDRESSABILITY
         LA        R15,JBACCT1+5  GET APPLICATION CODE FROM ACCT FIELD
         BAL       R8,TBINSRCH    USE BINARY LOOKUP RTN TO FIND HIT
         B         DJENDOK9       RC=0  GOT A HIT
         BAL       R14,DJERROR    RC=4; DOESN'T OCCUR IF READ-ONLY
         B         DJENDNG1       RC=8; NO HIT
         BAL       R14,DJERROR    RC=12; ERROR IN SEARCH ROUTINE/TABLE
*
DJENDNG1 EQU       *
         OI        JBSW,JBINVACT  SET 'INVALID ACCT' SWITCH
         WTO       'IEFUJV-15-I - INVALID APPLICATION CODE IN ACCOUNTINX
               G FIELD',ROUTCDE=2,DESC=6
         B         DJENDXIT
*
DJENDOK9 EQU       *
         MVC       JBAPCFLG,APCDFLGS-APCDTEXT(R2) HOLD ONTO APCD FLAG
         L         R1,JBACTADR GET ADDR OF ACCOUNTING  AREA
         USING     ACCTABLE,R1 GIVE IT ADDRESSABILITY
         L         R7,ACUSADDR    GET ADDR OF USER CODE TABLE
         USING     USERCODE,R7
         LA        R15,JBACCT1+1 GET USER CODE VALUE ADDR
         BAL       R8,TBINSRCH    SEARCH FOR THIS VALUE
         B         DJENDOKA       RC=0; MATCH FOUND
         BAL       R14,DJERROR    RC=4; DOESN'T OCCUR W/READ-ONLY
         B         DJENDNG2       RC=8; NO HIT FOUND
         BAL       R14,DJERROR    RC=12; ERROR IN SEARCH ROUTINE/TABLE
*
DJENDNG2 EQU       *
         OI        JBSW,JBINVACT  SET 'INVALID ACCT' SWITCH
         WTO       'IEFUJV-16-I - INVALID USER CODE IN ACCOUNTING FIELDX
               ',ROUTCDE=2,DESC=6
         B         DJENDXIT
*
DJENDOKA EQU       *
         MVC       JBUSCFLG,USCDFLGS-USCDTEXT(R2) HOLD USER CODE FLAG
         L         R1,JBACTADR    GET ADDR OF ACCOUNTING  AREA
         USING     ACCTABLE,R1
         L         R7,ACFNADDR    GET ADDR OF FUNCTION CODE TABLE AREA
         USING     FUNCCODE,R7
         LA        R15,JBACCT1+8 GET FUNCTION CODE VALUE FROM ACCTING
         BAL       R8,TBINSRCH
         B         DJENDOKB       RC=0; MATCH FOUND FOR FUNCTION CODE
         BAL       R14,DJERROR    RC=4; DOESN'T OCCUR IF READ-ONLY
         B         DJENDNG3       RC=8; NO HIT
         BAL       R14,DJERROR    RC=12; ERROR IN SEARCH ROUTINE/TABLE
*
DJENDNG3 EQU       *
         OI        JBSW,JBINVACT  SET 'INVALID ACCT' SWITCH
         WTO       'IEFUJV-17-I - INVALID FUNCTION CODE IN ACCOUNTING FX
               IELD',ROUTCDE=2,DESC=6
         B         DJENDXIT
*
DJENDOKB EQU       *
         L         R1,JBACTADR
         USING     ACCTABLE,R1
         L         R7,ACRTADDR    RUN TYPE CODES
         USING     RUNTYPE,R7
         LA        R15,JBACCT1+11
         BAL       R8,TBINSRCH
         B         DJENDOKC       RC=0: MATCH WAS FOUND
         BAL       R14,DJERROR    RC=4; DOESN'T OCCUR IF READ-ONLY
         B         DJENDNG4       RC=8; NO HIT FOUND
         BAL       R14,DJERROR    RC=12; ERROR IN SEARCH RTN/TABLE
*
DJENDNG4 EQU       *
         OI        JBSW,JBINVACT  SET 'INVALID ACCOUNT' SWITCH
         WTO       'IEFUJV-18-I - INVALID RUN TYPE CODE IN ACCOUNTING FX
               IELD',ROUTCDE=2,DESC=6
         B         DJENDXIT
*
DJENDOKC EQU       *
         MVC       JBRTCFLG,RTCDFLGS-RTCDTEXT(R2) HOLD ONTO RUN TYPE CD
         TM        RTCDFLGS-RTCDTEXT(R2),RTCDTEST 'TEST' JOB?
         BZ        DJENDCK2       BIF NOT
         L         R1,CWAJMRPT    GET JMR POINTER
         USING     COMMEXIT,R1    GIVE IT ADDRESSABILITY
         OI        CEPIDFLG,CEPIDF01 SET 'TEST' JOB FLAG
         TM        JBSW,JBTIMEQ   'TIME=' ON JOB CARD?
         BO        DJENDXIT       BIF YES
         OI        JBSW,JBINVACT  OTHERWISE, SIGNAL ERROR
         WTO       'IEFUJV-28-I - ''TIME='' KEYWORD REQUIRED FOR TEST JX
               OBS',ROUTCDE=2,DESC=6
         B         DJENDXIT       IF TEST, BYPASS ADDITIONAL CODE
DJENDCK2 EQU       *
         TM        JBUSCFLG,USCDF01 IS USER CODE PERM. IN ACCT FIELD?
         BZ        DJENDOKD       BIF PERMITTED
         OI        JBSW,JBINVACT  OTHERWISE, SIGNAL ERROR
         WTO       'IEFUJV-19-I - 2ND MASTER AND JOINT MASTER CODES NOTX
                PERMITTED IN ACCOUNT FIELD',ROUTCDE=2,DESC=6
DJENDOKD EQU       *
         TM        JBRTCFLG,RTCDWONR WORK ORDER NOT REQ'D?
         BO        DJENDOKF       IF SO, BYPASS ADDITIONAL TESTS
         TM        JBAPCFLG,APCDWORQ DOES APPL CODE REQ. A WO #?
         BZ        DJENDOKF       BIF IT DOESN'T
         SR        R6,R6          GET LENGTH OF WORK ORDER # FIELD
         IC        R6,JBACCT2
         LTR       R6,R6          LENGTH ZERO?
         BNZ       DJENDOKF       IF NOT = ZERO, WE HAVE WO#
         OI        JBSW,JBINVACT  OTHERWISE, SIGNAL ERROR
         WTO       'IEFUJV-20-I - APPLICATION CODE REQUIRES A WORK ORDEX
               R #',ROUTCDE=2,DESC=6
DJENDOKF EQU       *
         TM        JBAPCFLG,APCDUSRC IS USER CODE REQ'D IN JOB NAME
         BZ        DJENDXIT       BIF NOT
         L         R1,JBACTADR    GET ADDR OF ACCOUNTING   DATA
         USING     ACCTABLE,R1    GIVE IT ADDRESSABILITY
         L         R7,ACUSADDR    GET ADDR OF USER CODE TABLE
         USING     USERCODE,R7    GIVE IT ADDRESSABILITY
         LA        R15,JBNAME+5   GET USER CODE FROM JOB NAME
         BAL       R8,TBINSRCH    IS IT VALID?
         B         DJENDOKG       RC=0: YES IT IS
         OI        JBSW,JBINVACT  RC=4: COULDN'T FIND IT
         WTO       'IEFUJV-21-I - USER CODE MUST BE IN JOB NAME FOR THIX
               S APPLICATION',ROUTCDE=2,DESC=6
         B         DJENDXIT
DJENDOKG EQU       *
         CLC       JBNAME+6(2),JBACCT1+2 DOES USER CODE SUFFIX MATCH?
         BE        DJENDXIT       BIF YES
         WTO       'IEFUJV-22-I - USER CODE SUFFIX IN JOB NAME AND ACCOX
               UNT FIELD DO NOT MATCH',ROUTCDE=2,DESC=6
DJENDXIT EQU       *
         TM        JBSW,JBINVACT  INVALID ACCOUNTING SWITCH SET?
         BZR       R9             BIF NOT - NOT FAILD FOR ACCTING
         LA        R15,4          SET RC=4
         ST        R15,JBRETURN   FAIL THE JOB
         OI        PARMSW,JOBFAIL
         BR        R9
DJERROR  EQU       *
         OI        ERRSW,ERJOBRT  TURN ON ERROR INDICATIOR SW.
         BR        R9
         LTORG
         DROP      R1,R7,R10
         TITLE     'IEFUJV - EXEC STATEMENT PROCESSOR'
         PRINT     ON,GEN
DOEXEC   DS        0H
***********************************************************************
*
*        PROCESS KEYWORDS ON THE EXEC STATEMENT
*
***********************************************************************
         USING     DOEXEC,R10
         MVC       EYECATCH,=C'EXECCARD'  MOVE IN EYECATCHER
         USING     TEXT,R7        @ ENTRY R7 -> TEXT RECORD
         LA        R7,STREKEY     LOAD ADDR OF TEXT STRING BEGIN
         DROP      R7
         XC        EXNAME(EXEND-EXNAME),EXNAME CLEAR AREAS
         MVC       EXNAME,=C'        ' BLANK OUT STEPNAME
         MVC       EXPGMNAM+1(8),=C'        ' BLANK OUT PGM= NAME FIELD
         XC        DDGLBSTR(DDGLBEND-DDGLBSTR),DDGLBSTR ZERO OUT AREA
         LA        R1,UNAFSIZ
         LA        R2,UNAF1ST
         SR        R2,R1
         ST        R2,UNAFNXT     RE-INIT UNIT AFFINITY TABLE
         L         R1,JBNELTIM    ESTAB. DEFAULT JOB STEP TIME
         ST        R1,EXTIME
         LH        R1,JBNELREG    PRESET READER-DEFAULT REGION FOR STEP
         STH       R1,EXREGION
DXNXTSTG EQU       *
         C         R7,ENDSTRNG    HAVE WE GONE BEYOND END OF TEXT?
         BL        DXSTGTS1       BIF WE'RE NOT LOST YET
         BAL       R14,DXERROR
DXSTGTS1 EQU       *
         MVC       KEYVALUE(1),0(R7) COMPUTE WTG OFFSET FROM KEYWORD
         TR        KEYVALUE(1),KEYWDTAB VALUE
         LM        R4,R6,ZEROS    ZERO OUT CERTAIN WORK REGS
         IC        R5,KEYVALUE
         CLI       0(R7),ENDK     END-OF-STRING INDICATOR?
         BE        DXWTGBR        BIF YES (BYPASS ADDIT'L TESTS)
         IC        R6,1(,R7)      # OF PISITIONAL PARMS
         CLC       1(2,R7),=X'0100' NULL STRING?
         LA        R7,2(,R7)       BOUNCE TO BEG. OF SUBSTRING
         BE        DXSKPFLD       BIF NULL STRING
         LTR       R6,R6          ANY MORE STRINGS
         BZ        DXNXTSTG
DXWTGBR  B         DXWTG(R5)
DXWTG    EQU       *
         B         DXSKPFLD       =0; SKIP TO NEXT KEYWORD
         B         DXPFMPD        =4; PERFORM. KEYWORD
         B         DXPFMEQ        =8; PERFORM= KEYWORD
         B         DXADSPD        =12; ADDRSP. KEYWORD
         B         DXADSEQ        =16; ADDRSP= KEYWORD
         B         DXPGMNAM       =20; PGM= KEYWORD
         B         DXREGNPD       =24; REGION. KEYWORD
         B         DXREGNEQ       =28; REGION= KEYWORD
         B         DXTIMEPD       =32; TIME. KEYWORD
         B         DXTIMEEQ       =36; TIME= KEYWORD
         B         DXEXECNM       =40; STEPNAME KEYWORD (SORT OF)
         BAL       R14,DXERROR    =44; WE SHOULDN'T BE HERE
         BAL       R14,DXERROR    =48; WE SHOULDN'T BE HERE
         BAL       R14,DXERROR    =52; WE SHOULDN'T BE HERE
         BAL       R14,DXERROR    =56; WE SHOULDN'T BE HERE
         BAL       R14,DXERROR    =60; WE SHOULDN'T BE HERE
         BAL       R14,DXERROR    =64; WE SHOULDN'T BE HERE
         BAL       R14,DXERROR    =68; WE SHOULDN'T BE HERE
         BAL       R14,DXERROR    =72; WE SHOULDN'T BE HERE
         BAL       R14,DXERROR    =76; WE SHOULDN'T BE HERE
         BAL       R14,DXERROR    =80; WE SHOULDN'T BE HERE
         BAL       R14,DXERROR    =84; WE SHOULDN'T BE HERE
         BAL       R14,DXERROR    =88; WE SHOULDN'T BE HERE
         BAL       R14,DXERROR    =92; WE SHOULDN'T BE HERE
         BAL       R14,DXERROR    =96; WE SHOULDN'T BE HERE
         BAL       R14,DXERROR    =100; WE SHOULDN'T BE HERE
         BAL       R14,DXERROR    =104; WE SHOULDN'T BE HERE
         BAL       R14,DXERROR    =108; WE SHOULDN'T BE HERE
         BAL       R14,DXERROR    =112; WE SHOULDN'T BE HERE
         BAL       R14,DXERROR    =116; WE SHOULDN'T BE HERE
         BAL       R14,DXERROR    =120; WE SHOULDN'T BE HERE
         BAL       R14,DXERROR    =124; WE SHOULDN'T BE HERE
         B         DXENDKEY       =128; END-OF-TEXT PROCESSOR
         SPACE     3
DXSKPFLD EQU       *
***********************************************************************
*        BOUNCE TO THE NEXT KEYWORD
***********************************************************************
         IC        R5,0(,R7)      POS. PARM LENGTH / SUBFIELD INDIC
         S         R5,=F'128'     CHECK FOR SUB-STRINGS (X'80')
         BNZ       DXSKPTS1       HOPE FALL-THRU CASE DOESN'T OCCUR
         BAL       R14,DXERROR
DXSKPTS1 EQU       *
         BM        DXREGSTG       BIF THIS IS A REG. STRING
         LA        R7,1(,R7)      IF SUB-SUB STRING, BUMP TO STRING
DXSUBSTG EQU       *
         IC        R4,0(,R7)      LENGTH OF STRING
         LA        R7,1(R4,R7)    BOUNCE TO NEXT SUBFIELD ENTRY
         BCT       R5,DXSUBSTG    END OF THE SUBSTRING?
         B         DXTSTEND
DXREGSTG EQU       *
         LA        R7,129(R7,R5)  BOUNCE TO THE NEXT FIELD
         SR        R5,R5
DXTSTEND EQU       *
         BCT       R6,DXSKPFLD    TRUCK THRU FIELDS UNTIL NEXT KWD
         B         DXNXTSTG
         SPACE     3
DXADSPD  EQU       *
***********************************************************************
*        PROCESS 'ADDRSP.' KEYWORD
***********************************************************************
         IC        R5,0(,R7)      FOR NOW, SKIP TO NEXT KEYWORD
         LR        R3,R7          RETAIN PTR TO TEXT
         LA        R7,1(R5,R7)
         BCT       R6,DXADSPD
         CLI       0(R3),X'04'    STRING CORRECT LENGTH?
         BNE       DXADSPX        BIF NOT
         CLI       1(R3),C'R'     V=R?
         BNE       DXADSPX        BIF NOT
         OI        EXADRSW,EXADRRL SET INDICATOR
DXADSPX  EQU       *
         B         DXNXTSTG
         SPACE     3
DXADSEQ  EQU       *
***********************************************************************
*        PROCESS 'ADDRSP=' KEYWORD
***********************************************************************
         IC        R5,0(,R7)
         C         R5,=F'4'       CORRECT KEYWORD LENGTH?
         BNE       DXADRVRT       BIF CORRECT
DXADRTS1 EQU       *
         CLI       1(R7),C'V'     ADR=VIRT?
         BE        DXADRVRT
         OI        EXADRSW,EXADRRL
DXADRVRT EQU       *
         LA        R7,1(R5,R7)
         B         DXNXTSTG
         SPACE     3
DXEXECNM EQU       *
***********************************************************************
*        PROCESS STEPNAME FROM EXEC STATEMENT
***********************************************************************
         IC        R5,0(,R7)      GET STRING LENGTH
         S         R5,=F'1'
         BM        DXNONAME
         LA        R1,EXNAME
         EX        R5,MOVER       MOVE NAME TO HOLD AREA
DXNONAME EQU       *
         LA        R7,2(R5,R7)    BOUNCE TO NEXT KEYWORD
         S         R6,=F'1'       ANY MORE STRINGS?
         BZ        DXEXCXIT       BIF NOT
         SR        R5,R5
         IC        R5,0(,R7)      SKIP PAST THIS STRING AS WELL
         LA        R7,1(R5,R7)
         S         R6,=F'1'       ANY MORE STRINGS?
         BZ        DXEXCXIT       BIF NOT
         IC        R5,0(,R7)      GET LENGTH OF STRING
         LA        R7,1(R5,R7)    BOUNCE TO NEXT STRING
DXEXCXIT EQU       *
         B         DXNXTSTG
         SPACE     3
DXPFMPD  EQU       *
***********************************************************************
*        PROCESS 'PERFORM.' KEYWORD
***********************************************************************
         IC        R5,0(,R7)      FOR NOW, JUST SKIP TO NEXT KEYWORD
         LR        R3,R7
         LA        R7,1(R5,R7)
         BCT       R6,DXPFMPD
         SR        R2,R2          CLEAR R2
         IC        R2,0(,R3)      GET PREV. STRING'S LENGTH CODE
         S         R2,=F'1'       LENGTH -> LENGTH CODE
         BM        DXPFMPX        BIF NOT USEABLE
         CLI       1(R3),C'0'     IS STRING NUMERIC?
         BL        DXPFMPX        BIF NOT
         EX        R2,DXPACK      OTHERWISE, PACK & STOW
         CVB       R0,PACKWK
         STH       R0,EXPFM
DXPFMPX  EQU       *
         B         DXNXTSTG
         SPACE     3
DXPFMEQ  EQU       *
***********************************************************************
*        PROCESS 'PERFORM=' KEYWORD
***********************************************************************
         IC        R5,0(,R7)
         S         R5,=F'1'
         BM        DXPFMNO#       BIF NO PERFORM KEYWORD F VALUE
         EX        R5,PACKER
         CVB       R0,PACKWK
         STH       R0,EXPFM       STOW FOR LATER USE
DXPFMNO# EQU       *
         LA        R7,2(R5,R7)
         B         DXNXTSTG
         SPACE     3
DXPGMNAM EQU       *
***********************************************************************
*        PROCESS 'PGM=' KEYWORD
***********************************************************************
         IC        R5,0(,R7)      GET STRING LENGTH
         S         R5,=F'128'     SUBSTRINGS?
         BNZ       DXPGMTS1       HOPE FALL-THRU CASE DOESN'T OCCUR
         BAL       R14,DXERROR    INVALID SUBSTRING INDIC.
DXPGMTS1 EQU       *
         BM        DXPGMRS        BIF REGULAR STRING
         LA        R7,1(,R7)      SUBSTRING: BUMP TO SUB-STG BEGIN
DXPGMSS  EQU       *
         IC        R4,0(,R7)      GET SUBSTRING LENGTH
         LA        R7,1(R4,R7)    BOUNCE TO NEXT SUBSTRING
         BCT       R5,DXPGMSS     ANY MORE SUBSTRINGS?
         B         DXPGMTSE       GO TEST FOR STRINGS
DXPGMRS  EQU       *
         LA        R1,EXPGMNAM    ADDR OF WHERE TO STORE PGM= NAME
         LA        R5,128(,R5)    RESTORE ORIG. R5 CONTENTS
         EX        R5,MOVERWL     MOVE PGM= NAME + LENGTH OF STRING
         LA        R7,1(R5,R7)    BOUNCE TO NEXT STRING
DXPGMTSE EQU       *
         BCT       R6,DXPGMNAM    LOOP UNTIL ALL STRINGS EXHAUSTED
         B         DXNXTSTG       GO GET NEXT KEYWORD
         SPACE     3
DXREGNPD EQU       *
***********************************************************************
*        PROCESS 'REGION.' KEYWORD
***********************************************************************
         IC        R5,0(,R7)
         LR        R3,R7          HOLD ONTO STRING PTR
         LA        R7,1(R5,R7)    FOR NOW, BOUNCE TO NEXT KEYWORD
         BCT       R6,DXREGNPD    BOUNCE UNTIL STRING EXHAUSTED
         SR        R2,R2          CLEAR R2
         IC        R2,0(,R3)      GET LENGTH OF PREV. STRING
         S         R2,=F'2'       LENGTH -> LENGTH CODE - 1
         BM        DXREGNPX       BIF UNSUITABLE LENGTH CODE
         CLI       1(R3),C'0'     IS STRING NUMERIC?
         BL        DXREGNPX       BIF NOT NUMERIC
         EX        R2,DXPACK      MOVE STUFF ALNOG
         CVB       R0,PACKWK
         STH       R0,EXREGION    STOW FOR LATER USE
DXREGNPX EQU       *
         B         DXNXTSTG
         SPACE     3
DXREGNEQ EQU       *
***********************************************************************
*        PROCESS 'REGION=' KEYWORD
***********************************************************************
         IC        R5,0(,R7)
         S         R5,=F'2'       LENGTH -> LENGTH CODE & LETTER 'K'
         BM        DXREGNO#       BIF NO NUMBER TO BE FOUND
         EX        R5,PACKER
         CVB       R0,PACKWK
         STH       R0,EXREGION    STOW FOR LATER USE
DXREGNO# EQU       *
         LA        R7,3(R5,R7)    BOUNCE TO NEXT KEYWORD
         B         DXNXTSTG
         SPACE     3
DXTIMEPD EQU       *
***********************************************************************
*        PROCESS 'TIME.' KEYWORD
***********************************************************************
         IC        R5,0(,R7)
         S         R5,=F'128'     CHECK FOR SUBTRINGS
         BNZ       DXTIMTS1       HOPE FALL-THRU CASE DOESN'T OCCUR
         BAL       R14,DXERROR
DXTIMTS1 EQU       *
         BM        DXTIMRS        IF REG STRING, BRANCH
         LA        R7,1(,R7)
DXTIMSS  EQU       *
         IC        R4,0(,R7)      GET LENGTH OF SUBSTRING
         LA        R7,1(R4,R7)    BOUNCE TO NEXT SUBSTRING
         BCT       R5,DXTIMSS     CONTINUE UNTILSUBSTRINS EXHAUSTED
         B         DXTIMTST
         SPACE     1
DXTIMRS  EQU       *
         LA        R7,129(R5,R7)  BOUNCE TO NEXT STRING
         SR        R5,R5
DXTIMTST EQU       *
         BCT       R6,DXTIMEPD
DXTIMEND EQU       *
         B         DXNXTSTG
         SPACE     3
DXTIMEEQ EQU       *
***********************************************************************
*        PROCESS 'TIME=' KEHWORD
***********************************************************************
         IC        R5,0(,R7)
         CLI       1(R7),C'0'     NUMERIC FIELD?
         BL        DXTIMPTS       BIF NOT
         SR        R0,R0
         ST        R0,EXTIME
         S         R5,=F'1'       SEE IF MINUTES PORTION PRESENT
         BM        DXTIMPSO       BIF SECONDS ONLY
         EX    R5,PACKER
         CVB       R0,PACKWK
         STH       R0,EXMINS
DXTIMPSO EQU       *
         LA        R5,1(,R5)
         C         R6,=F'1'       ANY MORE FIELDS?
         BNH       DXTIMPTS       BIF NOT
         LA        R7,1(R5,R7)
         BCTR      R6,0           REDUCE STRING COUNT BY 1
         IC        R5,0(,R7)
         S         R5,=F'1'       LENGTH -> LENGTH CODE
         BM        DXTIMPNT       BIF UNUSEABLE LENGTH (NEG.)
         EX        R5,PACKER
         CVB       R0,PACKWK
         STH       R0,EXSECS
DXTIMPNT EQU       *
         LA        R5,1(,R5)      RESTORE R5 TO ORIG VALUE
DXTIMPTS EQU       *
         IC        R5,0(,R7)      GET LENGTH OF NEXT STRING
         LA        R7,1(R5,R7)
         BCT       R6,DXTIMPTS    LOOP UNTIL END-OF-STRING
         B         DXNXTSTG
         SPACE     3
DXENDKEY EQU       *
***********************************************************************
*        PROCESS FOLLOW-UP AFTER END-OF-STRING
***********************************************************************
         L         R1,EXTIME
         LTR       R1,R1          IF NO DEFAULT TIME FALL THRU
         BNZ       DXENDTIM
         LH        R1,EXMINS
         MH        R1,=H'60'      CONV. TO SECONDS
         AH        R1,EXSECS
DXENDTIM EQU       *
         CLI       EXPGMNAM+1,C' '  DOES EXEC STMT HAVE PGM= ON IT?
         BE        DXENDREG       BIF NOT; (IMPLIES PROC=)
         A         R1,EHTIME      INCR TIME
         ST        R1,EHTIME
         L         R1,16          GET ADDR OF CVT
         USING     CVT,R1
         ICM       R1,7,CVTUSER+1 GET OUR ACCOUNTING AREA
         BZ        DXENDREG       BIF NO CVT USER FIELD
         USING     ACCTABLE,R1    OTHERWISE, PROCEED
         CLI       ACFLAG,ACLOADED IS TABLE LOADED (SUCCESSFULLY)?
         BNE       DXENDREG       BIF NOT; DON'T ASK FOR TROUBLE
         L         R1,ACJRADDR    GET ADDR OF JOB ROUTING PGM NAME TAB
         USING     JOBROUTE,R1    MAKE AREA ADDRESSABLE
         LA        R7,JRLOOKUP    GET ADDR OF BINARY LOOKUP TABLE
         DROP      R1
         LA        R15,EXPGMNAM+1 GET PGM= NAME FROM USER'S JCL
         BAL       R8,TBINSRCH    SEE IF USER'S PGM NAME IN TABLE
         B         DXENDNOK       RC=0; NAME FOUND
         BAL       R14,DXERROR    RC=4; SHOULDN'T OCCUR IF READ-ONLY
         B         DXENDREG       RC=8; NO ENTRY FOUND FOR THIS NAME
         BAL       R14,DXERROR    RC=12; ERROR IN SEARCH RTN
*
DXENDNOK EQU       *
         NC        AFFMASK(1),JRMASK-JRPGMNAM(R2) 'AND' THE ORIG MASK
         MVC       AFFWTO1(AFFWTO1L),PATRNWT1 MOVE IN PATTERN WTO
         MVC       AFFWTO1+18(8),EXPGMNAM+1 MOVE IN PGM NAME
         LA        R1,AFFWTO1
         WTO       ' ',ROUTCDE=2,DESC=6,MF=(E,(1))
DXENDREG EQU       *
         LH        R1,EXREGION    GET REGION SIZE USED BY STEP
         CH        R1,EHREGION    > PREV. REGION?
         BNH       DXDOADRP       BIF NOT
         STH       R1,EHREGION    IF SO, STOW
DXDOADRP EQU       *
         TM        EXADRSW,EXADRRL V=R SPECIFIED?
         BZ        DXDOPFM        BIF NOT
         OI        EHSW,EHASREAL IF SO, MARK AS SO
DXDOPFM  EQU       *
         LH        R1,EXPFM       PERFORMANCE GROUP #
         CH        R1,EHPFM#      PREV. HIGH PGN
         BNH       DXENDEND       BIF WE CAN'T BEAT IT
         STH       R1,EHPFM#      OTHERWISE, MAKE IT THE NEW HI-WATER-M
DXENDEND EQU       *
         BR        R9             'BYE, FELLAS
         SPACE     3
DXERROR  EQU       *
         OI        ERRSW,EREXECRT TURN ON 'EXEC' RTN ERROR SWITCH
         BR        R9
DXPACK   PACK      PACKWK,1(0,R3) PATTERN PACK INSTR
         LTORG
         DROP      R10
         TITLE 'IEFUJV - PROC STATEMENT PROCESSOR'
         DS        0D
DOPROC   EQU       *
***********************************************************************
*
*        PROCESS 'PROC' STATEMENT
*
***********************************************************************
         USING     DOPROC,R10
         MVC       EYECATCH,=CL8'PROCCARD' MOVE IN EYECATCHER
         BR        R9             RETURN W/O DOING ANYTHING
         LTORG
         DROP      R10
         TITLE     'IEFUJV - DD STATEMENT PROCESSOR'
         DS        0D
DODDSTMT EQU       *
***********************************************************************
*
*        PROCESS DD STATEMENT STRING
*
***********************************************************************
         USING     DODDSTMT,R10   ESABLISH ADDRESSABILITY
         MVC       EYECATCH,=CL8'DDCARD' MOVE IN EYECATCHER
         USING     TEXT,R7
         TM  STRDINDC,DTXDDNM+DTXDYNAM+DTXSYOUT+DTXSUBSK+DTXSYSIN SKIP?
         BZ        DSCONT1        BIF WE WANT STRING
         B         DSENDXIT       IF NOT, RETURN
         SPACE     3
DSCONT1  EQU       *
         LA        R7,STRDKEY     GET ADDR OF TEXT STRING BEGIN
         DROP      R7
         XC        DDBEGIN(DDEND-DDBEGIN),DDBEGIN BLANK OUT AREA
         LA        R0,1           INITIALIZE DEVICE COUNT
         STH       R0,DDDEVCNT
         OI        DDISP,DDISPNEW+DDISPDEL DEFAULT OF (NEW,DELETE)
         MVI       DDBLNKST,C' ' BLANK OUT VOL STORAGE AREA
         MVC       DDBLNKST+1(DDBLNKED-DDBLNKST-1),DDBLNKST
         ZAP       DDRETPD,=P'0'
         ZAP       DDEXPDT,=P'0'
DSNXTSTG EQU       *
         C         R7,ENDSTRNG    HAVE WE GONE BEYOND END OF TEXT?
         BL        DSSTGTS1       BIF WE'RE NOT LOST YET
         BAL       R14,DSERROR
DSSTGTS1 EQU       *
         MVC       KEYVALUE(1),0(R7)
         TR        KEYVALUE(1),KEYWDTAB CONVERT TO WTG OFFSET
         LM        R4,R6,ZEROS    ZERO OUT SELECTED REGS
         IC        R5,KEYVALUE
         CLI       0(R7),DUMMK    IS THIS A 'DUMMY' STMT?
         BE        DSENDXIT       BIF YES
         CLI       0(R7),ENDK     END-OF-STRING INDICATOR?
         BE        DSWTGBR        BIF SO; CIRCUMVENT OTHER TESTS
         IC        R6,1(,R7) # OF POSITIONAL PARMS.
         CLC       1(2,R7),=X'0100' NULL STRING?
         LA        R7,2(,R7)      BOUNCE TO FIRST POS. PARM STRING
         BE        DSSKPFLD       BIF NULL STRING
         LTR       R6,R6          ANY MORE SUBSTRINGS?
         BZ        DSNXTSTG       BIF NO  MORE
DSWTGBR  B         DSWTG(R5)      DIVE INTO WTG TABLE
DSWTG    EQU       *
         B         DSSKPFLD       =0; SKIP THIS KEYWORD
         B         DSPRTCT        =4; 'PROTECT' KEYWORD
         B         DSDSID         =8; 'DSID=' KEYWORD
         B         DSMSVGP        =12; 'MSVGP=' KEYWORD PROCESSOR
         B         DSHOLD         =16; 'HOLD=' KEYWORD PROCESSOR
         B         DSDEST         =20; 'DEST=' KEYWORD PROCESSOR
         B         DSFUNC         =24; 'FUNC=' MINOR KEYWORD PROCSSOR
         B         DSTERM         =28; 'TERM=' KEYWORD PROCSSOR
         B         DSOUTLIM       =32; 'OUTLIM=' KEYWORD PROCSSOR
         B         DSCOPIES       =36; 'COPIES=' KEYWORD PROCXSOR
         B         DSUNIT         =40; 'UNIT=' KEYWORD PROCCSSOR
         B         DSLABEL        =44; 'LABEL=' KEYWORD PROCESSOR
         B         DSVOLUME       =48; 'VOLUME=' KEYWORD PROCESSOR
         B         DSAFF          =52; 'AFF=' KEYWORD PROCESSOR
         B         DSDISP         =56; 'DISP=' KEYWORD PROCESSOR
         B         DSSPACE        =60; 'SPACE=' KEYWORD PROCESSOR
         B         DSSPLIT        =64; 'SPLIT=' KEYWORD PROCESSOR
         B         DSDSNAME       =68; 'DSNAME=' KEYWORD PROCESSOR
         B         DSSYSOUT       =72; 'SYSOUT=' KEYWORD PROCESSOR
         B         DSSUBALL       =76; 'SUBALLOC=' KEYWORD PROCESSOR
         B         DSAFFM         =80; 'AFF=' MINOR KEYWORD PROCESSOR
         B         DSSER          =84; 'SER=' MINOR KEYWORD PROCESSOR
         B         DSREF          =88; 'REF=' MINOR KEYWORD PROCESSOR
         B         DSEXPDT        =92; 'EXPDT=' MINOR KEYWORD PROCESSOR
         B         DSRETPD        =96; 'RETPD=' MINOR KEYWORD PROCESSOR
         B         DSBLKSIZ       =100; 'BLKSIZE=' MINOR KEYWORD PROC
         B         DSDEN          =104; 'DEN=' MONOR KEYWORD PROCESSOR
         B         DSDSORG        =108; 'DSORG=' MINOR KEYWORD PROCESS.
         B         DSLRECL        =112; 'LRECL=' MINOR KEYWORD PROC.
         B         DSOPTCD        =116; 'OPTCD=' MINOR KEYWORD PROCESS.
         B         DSRECFM        =120; 'RECFM=' MINOR KEYWORD PROC.
         B         DSDD           =124; 'DD' KEYWORD PROCESSOR
         B         DSENDKEY       =128; END OF TEXT PROCESSOR
         SPACE     3
DSSKPFLD EQU       *              BOUNCE PAST UNUSED KEYWORDS
DSPRTCT  EQU       *
DSDSID   EQU       *
DSMSVGP  EQU       *
DSHOLD   EQU       *
DSDEST   EQU       *
DSFUNC   EQU       *
DSTERM   EQU       *
DSOUTLIM EQU       *
DSCOPIES EQU       *
DSLABEL  EQU       *
DSVOLUME EQU       *
DSAFF    EQU       *
DSSYSOUT EQU       *
DSBLKSIZ EQU       *
DSDEN    EQU       *
DSLRECL  EQU       *
DSRECFM  EQU       *
***********************************************************************
*        BOUNCE PAST UNUSED KEYWORDS
***********************************************************************
         IC        R5,0(,R7)
         S         R5,=F'128'     CHECK FOR SUB-STRINGS
         BNZ       DSSTGOK        IF SUBSTRING INDIC ON(=X'80')& ZERO
         BAL       R14,DSERROR    SUBSTRINGS PRESENT, THEN ERROR
DSSTGOK  EQU       *
         BM        DSSTGRS        BIF REGULAR STRING
         LA        R7,1(,R7)      BOUNCE TO SUBSTRING
DSSTGSS  EQU       *              (WE HAVE A SUBSTRING)
         IC        R4,0(,R7)      GET LENGTH OF SUBSTRING
         LA        R7,1(R4,R7)    BOUNCE TO NEXT SUBSTRING
         BCT       R5,DSSTGSS     LOOP UNTIL ALL SUBSTRINGS PROCESSED
         B         DSSTGTST       THEN CHECK FOR ADDITIONAL STRINGS
DSSTGRS  EQU       *              (WE HAVE A REGULAR STRING)
         LA        R7,129(R5,R7)  BOUNCE TO NEXT STRING & RECOVER R5
         SR        R5,R5
DSSTGTST EQU       *
         BCT       R6,DSSKPFLD    LOOP UNTIL ALL STRINGS PROCESSED
         B         DSNXTSTG       ONWARD
         SPACE     3
DSUNIT   EQU       *
***********************************************************************
*        PROCESS 'UNIT=' KEYWORD
***********************************************************************
         IC        R5,0(,R7)      LENGTH OF STRING
         LTR       R4,R5
         BZ        DSUNTNXT       IF NULL STG, SKIP TO NEXT
         C         R5,=F'8'       UNIT NAME MAY NOT EXCEED 8 CHARS
         BNH       DSUNTST1       BIF NAME DOESN'T EXCEED 8 CHAR
         BAL       R14,DSERROR
DSUNTST1 EQU       *
         SLL       R4,2           USE UNIT NAME LENGTH FOR OFFSET
         LA        R4,DVNAME0A(R4) R4 NOW -> TO ADDR BEG.
         L         R4,0(,R4)      GET THIS BEGINNING ADDR
         LA        R2,12          EACH ENTRY IS 12 BYTES
         LA        R3,DEVNEND-12  END ADDR OF BXLE
         S         R5,=F'1'       CONVERT LENGTH -> LENGTH CODE
         BM        DSUNTEND       BIF NEG. LENGTH COCE
DSUNTLOP EQU       *
         EX        R5,DSUNTCLC    HAVE WE GOT A HIT YET?
         BE        DSUNTHIT       BIF YES
         BXLE      R4,R2,DSUNTLOP LOPP UNTIL WE DO OR RUN OUT OF TABLE
         MVC       DDUNITYP,=X'FFFFFFFF' SPECIAL VALUE
         B         DSUNTEND       NOW YOU CAN LEAVE
         SPACE     1
DSUNTHIT EQU       *
         MVC       DDUNITYP,8(R4) MOVE THE UNIT TYPE TO WORK AREA
         CLI       DDUNITYP+3,X'00' WAS ESOTERIC NAME USED?
         BNE       DSUNTEND       BIF NOT
         CLI       DDUNITYP,X'00' MAKE DOUBLY SURE
         BNE       DSUNTEND       BIF NOT ESOTERIC NAME
         SR        R2,R2
         IC        R2,DDUNITYP+1  GET RELATIVE ESOTERIC NAME LOCATION
         BCTR      R2,0           MUST BE RELATIVE TO 0, NOT 1
         SLL   R2,2               MULT BY 4 TO ESTABLISH OFFSET
         LA        R1,ESOTNAME(R2) GET MASK TO BE USED IN UCBTYP CONV
         XC        DDUNITYP(4),0(R1) CONVERT ESOTERIC -> GENERIC
DSUNTEND EQU       *
         LA        R5,1(,R5)      RESTORE R5 TO ORIG. VALUE
DSUNTNXT EQU       *
         LA        R7,1(R5,R7)    BOUNCE TO NEXT STRING
         S         R6,=F'1'       ANY MORE STRINGS ON THIS KEYWORD?
         BZ        DSUNTXIT       BIF NO MORE
         SR        R5,R5
         IC        R5,0(,R7)      LENGTH OF STRING
         LTR       R5,R5          ZERO-LENGTH STRING?
         BZ        DSUNTSKP       BIF YES
         S         R5,=F'1'       LENGTH -> LENGTH CODE
         BM        DSUNTBNC       IF NULL STRING, BOUNCE TO NEXT
         CLI       1(R7),C'P'     PARALELL MOUNTING?
         BNE       DSUNTCNT       BIF NOT
         OI        DDUNITFG,DDUNITPM PARALLEL MOUNTING REQ.
         B         DSUNTSKP
         SPACE     1
DSUNTCNT EQU       *
         EX        R5,PACKER      PACK # OF UNITS TO BE USED
         CVB       R0,PACKWK
         STH       R0,DDDEVCNT    STOW IT
DSUNTBNC EQU       *
         LA        R7,2(R5,R7)    BOUNCE TO NEXT TRING
         B         DSUNTTST
DSUNTSKP EQU       *
         SR        R5,R5          CLEAR THIS REG
         IC        R5,0(,R7)      KEEP ON TRUCKIN' UNTIL ITS DONE
         LA        R7,1(R5,R7)
DSUNTTST EQU       *
         BCT       R6,DSUNTSKP
DSUNTXIT EQU       *
         B         DSNXTSTG
DSUNTCLC CLC       1(0,R7),0(R4)
         SPACE     3
DSAFFM   EQU       *
***********************************************************************
*        PROCESS 'AFF=' KEYWORD
***********************************************************************
         IC        R5,0(,R7)      LENGTH OF STRING
         S         R5,=F'1'       LENGTH -> LENGTH CODE
         BNM       DSAFFTS1       BIF LENGTH CODE VALUE OK
         B         DSAFFEND
DSAFFTS1 EQU       *
         LA        R1,DDAFFNAM    MOVE AFF NAME TO WORK AREA
         EX        R5,MOVER
         STM       R0,R7,DDREGSAV HOLD ONTO THESE REGS FOR A WHILE
         LA        R0,0           GIVE R0 AN INITIAL VALUE
         STH       R0,DDDEVCNT    BECAUSE OF UNIT=AFF, DEVCNT=0
         LA        R1,UNAFBEG     SEARCH DDNAME TABLE FOR UNIT AFF
         LA        R15,DDAFFNAM
         BAL       R8,LISTCHCK
         L         R0,8(,R2)      IF RC=0, THIS INSTR IS EXECUTED
         ST        R0,DDUNITYP    IF RC=4, THIS 1ST INSTR EXECUTED
         LM        R0,R7,DDREGSAV NOW BRING THEM BACK
DSAFFEND EQU       *
         LA        R7,2(R5,R7)    BOUNCE TO NEXT WORK AREA
         B         DSNXTSTG
         SPACE     3
DSDISP   EQU       *
***********************************************************************
*        PROCESS 'DISP=' KEYWORD
***********************************************************************
         IC        R5,0(,R7)      LENGTH OF STRING
         LTR       R5,R5          NULL STRING?
         BNP       DSDSPFL2       BIF NULL
         CLI       1(R7),C'N'     DISP=NEW?
         BE        DSDSPFL2       BIF YES (DEFAULT)
         CLI       1(R7),C'S'     DISP=SHR?
         BNE   DSDSPOLD           BIF NOT SHR
         XI        DDISP,DDISPSHR+DDISPNEW+DDISPDEL+DDISPKEP
         B         DSDSPFL2       ONWARD
         SPACE     1
DSDSPOLD EQU       *
         CLI       1(R7),C'O'     DISP=OLD?
         BNE       DSDSPMOD
         XI        DDISP,DDISPOLD+DDISPNEW+DDISPDEL+DDISPKEP
         B         DSDSPFL2       ONWARD
         SPACE     1
DSDSPMOD EQU       *
         XI        DDISP,DDISPMOD+DDISPNEW+DDISPDEL+DDISPKEP
DSDSPFL2 EQU       *              2ND POS. PARAMETER
         LA        R7,1(R5,R7)    BOUNCE TO BEG. OF TRING
         S         R6,=F'1'       IS THERE SECOND STRING?
         BZ        DSDSPEND       BIF NOT
         IC        R5,0(,R7)      LENGTH OF SECOND STRING
         LTR       R5,R5          NULL STRING?
         BZ        DSDSPF3A       BIF YES
         NI        DDISP,255-DDISPDEL-DDISPKEP
         CLI       1(R7),C'P'     DISP=(,PASS)?
         BE        DSDSPF2D       BIF SO
         CLI       1(R7),C'C'     CATLG?
         BNE       DSDSPF2B       BIF NOT
DSDSPF2D EQU       *              TREAT 'CATLG' & 'PASS' AS 'PASS'
         OI        DDISP,DDISPASS
         B         DSDSPF3A
         SPACE     1
DSDSPF2B EQU       *
         CLI       1(R7),C'D'     DISP=(,DELETE)?
         BNE       DSDSPF2C       BIF NOT
         OI        DDISP,DDISPDEL BIF DISP=(,DELETE)
         B         DSDSPF3A
DSDSPF2C EQU       *
         OI        DDISP,DDISPKEP TURN ON 'KEEP'
DSDSPF3A EQU       *
         LA        R7,1(R5,R7)    BOUNCE TO NEXT STRING
         S         R6,=F'1'       IS THERE ANOTHER STRING
         BZ        DSDSPEND       BIF NOT
         IC        R5,0(,R7)      LENGTH OF NEXT STRING
         LA        R7,1(R5,R7)    BOUNCE TO NEXT STRING
         B         DSDSPTST       GO TEST FOR ADDT'L FIELDS
DSDSPSKP EQU       *
         SR        R5,R5
         IC        R5,0(,R7)      GET LENGTH OF FIELD
         LA        R7,1(R5,R7)    SKIP TO NEXT FIELD
DSDSPTST EQU       *
         BCT       R6,DSDSPSKP
DSDSPEND EQU       *
         B         DSNXTSTG       ONWARD
         SPACE     3
DSSPLIT  EQU       *
***********************************************************************
*        PROCESS 'SPLIT=' KEYWORD
***********************************************************************
         IC        R5,0(,R7)      LENGTH OF STRING
         LA        R7,1(R5,R7)    SKIP PAST 1ST OPERAND
         S         R6,=F'1'       WAS THERE ONLY 1 OPERAND?
         BZ        DSSPCEND       BIF YES
         SPACE     1
DSSPACE  EQU       *
DSSUBALL EQU       *
***********************************************************************
*        PROCESS 'SPACE=', 'SPLIT=', & 'SUBALLOC=' KEYWORDS
***********************************************************************
         IC        R5,0(,R7)      LENGTH OF STRING
         CLC       1(3,R7),=C'CYL' IT MIGHT BE 'CYL'
         BNE       DSSPCHK1       BIF NOT
         OI        DDSPCUNT,DDSPCCYL MARK AS 'CYL' ALLOC
         B         DSSPCPRI       GO IN SEARCH OF PRIMARY ALLOC QTY
DSSPCHK1 EQU       *
         CLC       1(3,R7),=C'TRK' IS IT UNITS OF TRACKS?
         BNE       DSSPCHK2       BIF NOT
         OI        DDSPCUNT,DDSPCTRK MARK AS ALLOC IN 'TRK'
         B         DSSPCPRI       GO FORTH IN SEARCH OF PRIMARY QTY
DSSPCHK2 EQU       *
         CLC       1(5,R7),=C'ABSTR' ASK FOR 'ABSTR'?
         BNE       DSSPCHK3       BIF NOT
         OI        DDSPCUNT,DDSPCABS MARK AS 'ABSTR' ALLOC
         B         DSSPCPRI       GO FORTH IN SEARCH OF PRIMARY QTY
         SPACE     1
DSSPCHK3 EQU       *
         OI        DDSPCUNT,DDSPCBLK MARK AS ALLOC IN 'AVEBLK'
         S         R5,=F'1'       LENGTH -> LENGTH CODE
         BNM       DSSPCTS0
         BAL       R14,DSERROR
DSSPCTS0 EQU       *
         EX        R5,PACKER      SURE HOPE IT'S NUMERIC HERE
         CVB       R0,PACKWK
         STH       R0,DDSPCAVE    STOW AVE BLK LENGTH
         LA        R5,1(,R5)      RESTORE R5 TO ITS ORIG VALUE
DSSPCPRI EQU       *              FIND PRIMARY QTY
         LA        R7,1(R5,R7)    BOUNCE TO NEXT STRING
         S         R6,=F'1'       ANY MORE STRINGS?
         BZ        DSSPCEND       BIF NOT
         IC        R5,0(,R7)      GET LENGTH OF NEXT STRING
         S         R5,=F'128'     CHECK FOR SUBSTRING INDIC. (=X'80')
         BNZ       DSSPCTS1       IF SUBSTRING INDIC ON & NO SUBSTR,
         BAL       R14,DSERROR    THEN THERE IS AN ERROR
DSSPCTS1 EQU       *
         BM        DSSPCREG       BIF NO SUBSTRINGS FOUND
         LA        R7,1(,R7)      BOUNCE TO NEXT (1ST) SUBSTRING
         IC        R4,0(,R7)      GET LENGTH OF 1ST SUBSRING
         S         R4,=F'1'       LENVTH -> LENGTH CODE
         BM        DSSPCTS2       BIF NULL STRING
         EX        R4,PACKER      STOW PRI ALLOC QTY
         CVB       R0,PACKWK
         STH       R0,DDSPCPRI
DSSPCTS2 EQU       *
         LA        R7,2(R4,R7)    BOUNCE TO NEXT SUBFIELD
         SR        R4,R4          STABILIZE R4
         S         R5,=F'1'       ANY MORE SUBSTRINGS?
         BZ        DSSPCTST       BIF NO; PROCESS STRINGS
         IC        R4,0(,R7)      LENGTH OF SUBSTRING
         S         R4,=F'1'       LENGTH - > LENGTH CODE
         BM        DSSPCTS3
         TM        DDSPCUNT,DDSPCABS
         BO        DSSPCTS3       BIF SPACE=(ABSTR,(....)
         EX        R4,PACKER
         CVB       R0,PACKWK
         STH       R0,DDSPCSEC    STOW SEC. ALLOC QTY
DSSPCTS3 EQU       *
         LA        R7,2(R4,R7)    BOUNCE TO NEXT SUBSTRING
         SR        R4,R4          STABILIZE R4
         S         R5,=F'1'       ANY MORE SUBSTRINGS
         BZ        DSSPCTST
         IC        R4,0(,R7)      GET LAST SUBSTR LENGTH
         LA        R7,1(R4,R7)    BOUNCE PAST IT
         B         DSSPCTST
DSSPCREG EQU       *
         LA        R5,128(,R5)    RESTORE R5 TO FORMER SELF
         S         R5,=F'1'       IS THIS A NULL FIELD?
         BM        DSSPCSKP       BIF YES
         EX        R5,PACKER
         CVB       R0,PACKWK
         STH       R0,DDSPCPRI    STOW JUST PRI. QTY
DSSPCSKP EQU       *
         LA        R7,2(R5,R7)    SKIP TO NEXT STRING
         S         R6,=F'1'       ANY MORE STRINGS LEFT?
         BZ        DSSPCEND       BIF NOT
DSSPCLOP EQU       *
         SR        R5,R5          CLEAR R5
         IC        R5,0(,R7)      LENGTH OF STRING
         LA        R7,1(R5,R7)    BOUNCE TO NEXT STRING
DSSPCTST EQU       *
         BCT       R6,DSSPCLOP
DSSPCEND EQU       *
         B         DSNXTSTG
         SPACE     3
DSDSNAME EQU       *
***********************************************************************
*        PROCESS 'DSNAME=' KEYWORD
***********************************************************************
         IC        R5,0(,R7)      STRING LENGTH
         S         R5,=F'128'     DO WE HAVE SUBSTRINGS?
         BM        DSDSNREG       BIF NOT
         BNZ       DSDSNTS1       HOPE FALL-THRU CASE DOESN'T OCCUR
         BAL       R14,DSERROR
DSDSNTS1 EQU       *
         LA        R7,1(,R7)      SKIP TO SUBSTRING LENGTH INDIC
         IC        R4,0(,R7)      GET STRING LENGTH
         CLI       1(R7),C'*'     IS THIS A REFERBACK DSN?
         BNE       DSDSNSUB       BIF NOT
         LA        R1,DDDSNAME-1  ADDR OF RECEIVING AREA - 1
DSDSNLOP EQU       *              FALL THRU IF REFERBACK DSN
         IC        R4,0(,R7)      FETCH LENGTH OF SUBSTRING
         LA        R1,1(,R1)      BOUNCE TO RECEIVING LOC
         EX        R4,MOVER       MOVE TEXT SUBSTRING
         LA        R1,0(R4,R1)    BOUNCE TO NEXT RECEIVING BYTE LOC.
         MVI       0(R1),C'.'     PLACE PERIOD HERE
         LA        R7,1(R4,R7)    BOUNCE TO NEXT SUBSTRING
         BCT       R5,DSDSNLOP    LOOP UNTIL NO MORE SUBSTRINGS
         MVI       0(R1),C' '     MOVE TERM. BLANK OVER LAST PERIOD
         B     DSDSNEND
DSDSNSUB EQU       *
         S         R4,=F'1'       LENGTH -> LENGTH CODE
         LA        R1,DDDSNAME
         EX        R4,MOVER       MOVE DSNAME TO HOLD AREA
         IC        R4,0(,R7)      RE-FETCH SUBSTRING LENGTH
         LA        R7,1(R4,R7)    BOUNCE TO NEXT SUBSTRING
         LA        R2,DDDSNAME(R4) IF WE DECIDE TO BUILD NAME START HER
         IC        R4,0(,R7)      GET 2ND SUBSTRING LENGTH
         S         R4,=F'1'       LENGTH - > LENGTH CODE
         BM        DSDSNSNL       BIF ZERO-LENGTH SUBSTRING
         LA        R1,DDMEMNAM    ADDR INTO WHICH TO STOW MEMBER NAME
         EX        R4,MOVER
         CLI       1(R7),C'0'     CHECK FOR A NUMERIC VALUE
         BNL       DSMEMNUM       BIF NUMERIC
         CLI       1(R7),C'-'     CHECK FOR MINUS SIGN
         BE        DSMEMNUM       BIF MINUS SIGN
         CLI       1(R7),C'+'     CLI FOR '+' SIGN
         BE        DSMEMNUM       BIF '+' SIGN
DSDSNSNL EQU       *
         LA        R7,2(R4,R7)    IF NONE OF ABOVE, BOUNCE TO NEXT
         B         DSDSNEND       TH.TH.TH.THAT'S ALL, FLKS
         SPACE     1
DSMEMNUM EQU       *
         MVI       0(R2),C'('     R2 -> TO WHERE WE WANT '('
         EX        R4,DSDSNMVC
         LA        R2,2(R4,R2)    GET ADDR FOR PLACEMENT OF ')'
         MVI       0(R2),C')'     WHY, HERE, OF COURSE
         LA        R7,2(R4,R7)    BOUNCE TO END OF SUBSTRING
         B         DSDSNEND
         SPACE     1
DSDSNREG EQU       *
         LA        R5,127(,R5)    REVERT BACK TO LENGTH CODE
         LA        R1,DDDSNAME
         EX        R5,MOVER
         LA        R7,2(R5,R7)
DSDSNEND EQU       *
         B         DSNXTSTG
DSDSNMVC MVC       1(0,R2),1(R7)
         SPACE     3
DSSER    EQU       *
***********************************************************************
*        PROCESS 'SER=' MINOR KEYWORD
***********************************************************************
         STH       R6,DDVOLCNT    ASSUME WE CAN STOW # OF VOLUMES
         LA        R4,DDVOLIST    BE PREPARED TO STOW VOL NAMES
         LA        R2,6           EACH IS 6 BYTES LONG
         LA        R3,DDVOLIST+((DDVOLSIZ-1)*6) STOP INDIC FOR BXLE
DSSERLOP EQU       *
         IC        R5,0(,R7)      LENFTH OF 1ST STRING AFTER KEYWORD
         S         R5,=F'1'       WILL NOT ACCEPT NEG LENGTHS
         BM        DSSERCH0
         LR        R1,R4          R4 -> TO CURR ENTRY IN VOLLIST STACK
         EX        R5,MOVER       MOVE VOLUME INTO STACK
DSSERCH1 EQU       *
         LA        R7,2(R5,R7)    BOUNCE TO NEXT STRING
         SR        R5,R5          STABIZE VALUE IN R5
         BCT       R6,DSSERCHK    ANY MORE VOL=SER='S
         B         DSSEREND       NOW LEAVE
DSSERCH0 EQU       *
         S         R4,=F'6'       SKIP NULL VOL=SER=
         LH        R0,DDVOLCNT    IF NULL VOL=SER= SLOT FOUND,
         BCTR      R0,R0          THEN DECREMENT VOLCNT
         STH       R0,DDVOLCNT
         B         DSSERCH1       BACK INTO THE FRAY
DSSERCHK EQU       *
         BXLE      R4,R2,DSSERLOP LOOP UNTIL STACK AREA FULL
         LA        R0,DDVOLSIZ
         STH       R0,DDVOLCNT
DSSERTST EQU       *
         LTR       R6,R6          ANY MORE SERIAL # IN STRING?
         BZ        DSSEREND       BIF NO MORE
DSSERSKP EQU       *
         IC        R5,0(,R7)      SKIP PAST STRINGS IF STACK FULL
         LA        R7,1(R5,R7)
         BCT       R6,DSSERSKP    KEEP ON TRUCKIN' UNTIL END OF STRINGS
DSSEREND EQU       *
         B         DSNXTSTG       ONWARD
         SPACE     3
DSREF    EQU       *
***********************************************************************
*        PROCESS   'REF=' MINOR KEYWORD
***********************************************************************
         IC        R5,0(,R7)      GET LENGTH OF STRING
         S         R5,=F'128'     CHECK FOR SUBSTRINGS
         BM        DSREFREG       BIF NO SUBSTRINGS
         BNZ       DSREFSUB       BIF SUBSTRINGS DISCOVERED
         BAL       R14,DSERROR    SUBSTRING INDIC & SUBSTRING CNT = 0
DSREFSUB EQU       *
         STH       R5,DDREFCNT    STOW # OF ELEM'S IN *.REF KEYWORD
         LA        R7,1(,R7)      BOUNCE TO FIRST SUBSTRING LENGTH
         LA        R1,DDREF-1     GET ADDR OF RECIEVING AREA - 1
DSREFLOP EQU       *
         IC        R4,0(,R7)      GET LENGTH OF SUBSTRING
         LA        R1,1(,R1)      BOUNCE TO ADDR OF RECEIVING BYTE
         EX        R4,MOVER       MOVE SUBSTRING + 1 BYTE TO TARGET ARE
         LA        R1,0(R4,R1)    ADJUST TARGET AREA ADDRESS
         MVI       0(R1),C'.'     MOVE IN PERIOD AS SEPARATOR
         LA        R7,1(R4,R7)    BOUNCE TO NEXT SUBSTRING
         BCT       R5,DSREFLOP
         MVI       0(R1),C' '     OVERLAY LAST PERIOD W/ BLANK
         B         DSREFXIT       LEAVE
DSREFREG EQU       *
         LA        R5,128(,R5)    RESTORE R5 TO FORMER VALUE
         S         R5,=F'1'       LENGTH -> LENGTH CODE
         BM        DSREFEND       BIF ZERO-LENGTH STRING
         LA        R1,DDREF
         EX        R5,MOVER
DSREFEND EQU       *
         LA        R7,2(R5,R7)    BOUNCE TO NEXT STRING
DSREFXIT EQU       *
         B         DSNXTSTG       RETURN
         SPACE     3
DSEXPDT  EQU       *
***********************************************************************
*        PROCESS 'EXPDT=' KEYWORD
***********************************************************************
         IC        R5,0(,R7)      LENGTH OF EXPDT VALUE
         S         R5,=F'1'
         BM        DSEXPEND       BIF ZERO-LENGTH OPERAND
         EX        R5,PACKER      -> PACK IT
         ZAP       DDEXPDT,PACKWK STOW FOR LATER USE
DSEXPEND EQU       *
         LA        R7,2(R5,R7)
         B         DSNXTSTG
         SPACE     3
DSRETPD  EQU       *
***********************************************************************
*        PROCESS 'RETPD=' KEYWORD
***********************************************************************
         IC        R5,0(,R7)      GET STRING LENGTH
         S         R5,=F'1'       LENGTH -> LENGTH CODE
         BM        DSRTPEND       BIF ZERO-LENGTH OPERAND
         EX        R5,PACKER
         ZAP       DDRETPD,PACKWK STOW FOR LATER USE
DSRTPEND EQU       *
         LA        R7,2(R5,R7)
         B         DSNXTSTG
         SPACE     3
DSDSORG  EQU       *
***********************************************************************
*        PROCESS 'DSORG=' KEYWORD
***********************************************************************
         IC        R5,0(,R7)      GET LENGTH OF STRING
         C         R5,=F'2'       TWO-CHAR OPERAND?
         BL        DSORGEND       BIF NOT USEABLE LENGHT
         CLI       1(R7),C'I'     INDEXED SEQ?
         BNE       DSTRYDA        BIF NOT EQ.
         OI        DDDSORG,DDDSRGIS+DDDSRGU 'IS' & 'U'
         B         DSORGEND
         SPACE     1
DSTRYDA  EQU       *
         CLI       1(R7),C'D'     DIRECT?
         BNE       DSTRYPO        IF NOT 'DA', TRY 'PO'
         OI        DDDSORG,DDDSRGDA
         C         R5,=F'3'       OPERAND 3-CHAR LONG?
         BNE       DSORGEND       BIF NOT
         CLI       3(R7),C'U'     UNMOVEABLE?
         BNE       DSORGEND       BIF NOT
         OI        DDDSORG,DDDSRGU
         B         DSORGEND
         SPACE     1
DSTRYPO  EQU       *
         CLI       2(R7),C'O'     PARTITIONED?
         BNE       DSTRYPS        IF NOT , TRY 'PS'
         OI        DDDSORG,DDDSRGPO
         C         R5,=F'3'       CHECK FOR 3-CHAR OPERAND
         BNE       DSORGEND
         CLI       3(R7),C'U'     CHECK FOR 'UNMOVEABLE'
         BNE       DSORGEND       BIF NOT
         OI        DDDSORG,DDDSRGU
         B         DSORGEND
         SPACE     1
DSTRYPS  EQU       *
         CLI       1(R7),C'P'     PHYSICAL SEQUENTIAL?
         BNE       DSISUNK        BIF UNKNOWN
         OI        DDDSORG,DDDSRGPS OTHERWISE, MARK AS 'PS'
         C         R5,=F'3'       3-CHAR STRING?
         BNE       DSORGEND       BIF NOT
         CLI       3(R7),C'U'     IS IT UNMOVEABLE?
         BNE       DSORGEND       BIF NOT
         OI        DDDSORG,DDDSRGU
         B         DSORGEND
         SPACE     1
DSISUNK  EQU       *
         OI        DDDSORG,DDDSRGCX BTAM LINE OR UNKNOWN
DSORGEND EQU       *
         LA        R7,1(R5,R7)    BOUNCE TO NEXT STRING
         B         DSNXTSTG       ONWARD
         SPACE     3
DSOPTCD  EQU       *
***********************************************************************
*        PROCESS 'OPTCD=' KEYWORD
***********************************************************************
         IC        R5,0(,R7)      GET LENGTH OF STRING
         LA        R7,1(R5,R7)    FOR NOW, BOUNCCE TO NEXT STRING
         BCT       R6,DSOPTCD
         B         DSNXTSTG       ONWARD
         SPACE     3
DSDD     EQU       *
***********************************************************************
*        PROCESS 'DD' KEYWORD (DDNAME FIELD)
***********************************************************************
         IC        R5,0(,R7)      GET LENGTH OF A STRING
         S         R5,=F'1'       LENGTH -> LENGTH CODE
         BM        DSDDEND        IF ZERO LENGTH, HAVE CONCAT.
         LA        R1,DDDDNAME
         EX        R5,MOVER       MOVE DDNAME
DSDDEND  EQU       *
         LA        R7,2(R5,R7)    ON TO NEXT STRING
         S         R6,=F'1'       ANY MORE STRINGS?
         BZ        DSDDEXIT       BIF NOT
         SR        R5,R5          CLEAR R5
         IC        R5,0(,R7)      GET LENGTH OF STRING
         LA        R7,1(R5,R7)    BOUNCE TO NEXT STRING
DSDDEXIT EQU       *
         B         DSNXTSTG
         SPACE     3
DSENDKEY EQU       *
***********************************************************************
*        FOLLOW-UP PROCESSING FOR DD STATEMENT
***********************************************************************
         CLC       DDDSNAME(9),=C'NULLFILE ' DUMMY?
         BE        DSENDXIT                  BIF DD DUMMY
**********************************************************************
*        IF D.S. OLD & NO VOL=SER OR VOL=REF SPEC, SCAN
*        PASSED DATA SET TABLE OR OS CATLG
***********************************************************************
         TM        DDISP,DDISPNEW IF NEW, NOT A CANDIDATE
         BO        DSENDTOT       BIF NEW
         LH        R1,DDVOLCNT    IF VOL=SER=, CAN'T USE PASSED D.S.
         LTR       R1,R1          TABLE
         BNZ       DSENDTOT       BIF VOL=SER= WAS SPEC
         CLI       DDREF,C' '     IF VOL=REF=, CAN'T USE PASSED D.S.
         BNE       DSENDTOT       TABLE
         CLI       DDDSNAME,C' ' IF NO DSN, CAN'T USE PASSED D.S. TAB
         BE        DSENDTOT       BIF NO DSN
         LA        R1,PSDSBEG     PARM LIST FOR PASSED D.S. TABLE
         LA        R15,DDDSNAME   SEARCH ARG
         BAL       R8,LISTCHCK    IS D.S. IN TABLE?
         B         DSENDHPS       RC=0; FOUND PASSED D.S.
         B         DSENDCTL       RC=4;  TRY CATALOG SEARCH RTN
DSENDHPS EQU       *
         MVC       DDUNITYP(4),44(R2) TRANSFER UNIT & SPACE INFO
         MVC       DDSPC1KB(4),48(R2)
         B         DSENDTOT
DSENDCTL EQU       *
         CLI       DDDSNAME,C'&&' TEMP DSN?
         BE        DSENDCHM       BIF SO; CHECK DISP=MOD
         CLI       DDMEMNAM,C'+'  NEW GDG GENERATION?
         BE        DSENDCHM       BIF YES; CHECK FOR DISP=MOD
         CLI       DDDSNAME,C'*'  REFERBACK DSN?
         BE        DSENDTOT       BIF YES; CAN'T USE IT AT ALL
         MVC       DDCAMDSN,DDDSNAME MUST WORK ON THIS IN SEPARATE AREA
         LOCATE    DDCAMLST
         B         DSCAMWTG(R15)  USE R15 RET. CODE FOR BRANCH TABLE
DSCAMWTG B         DSENDCOK       0; CAMLST OK - FOUND DSN
         B         DSENDCHM       4; NOT FOUND - CHECK FOR DISP=MOD
         B         DSENDCHM       8; NOT FOUND - CHECK FOR DISP=MOD
         B         DSENDXIT       12; BAD CATLG STRUCTURE - IGNORE
         B         DSENDXIT       16; BAD CATLG STRUCTURE - IGNORE
         B         DSENDXIT       20; BAD CATLG STRUCTURE - IGNORE
         BAL       R14,DSERROR    24; I/O ERROR - SIGNAL ERROR
         BAL       R14,DSERROR    28; REL. TTR OUTSIDE CATLG - ERROR
         BAL       R14,DSERROR    32; RESERVED - CHECK ANYWAY
DSENDCHM EQU       *
         TM        DDISP,DDISPMOD
         BZ        DSENDTOT       BIF NOT 'DISP=MOD' -
         XI        DDISP,DDISPMOD+DDISPNEW 'MOD' MEANS 'NEW'
         B         DSENDTOT
DSENDCOK EQU       *              WAS ABLE TO FIND CATALOG ENTRY
         LH        R1,DDCAMWRK    GET # OF VOLUMES
         LTR       R1,R1          IS # OF VOLUMES = ZERO?
         BNP       DSENDXIT       BIF SO (CAN'T USE)
         STH       R1,DDVOLCNT    WE MAY REVISE THIS LATER
         CLC       DDUNITYP,=X'00000000' ALREADY HAVE UCBTYP?
         BNE       DSENDNOU       BIF WE DON'T ANT TO USE CATLG VALUE
         MVC       DDUNITYP(4),DDCAMWRK+2 GET 1ST UCBTYPE
         CLI       DDUNITYP+3,X'00'  ESOTERIC NAME?
         BNE       DSENDNOU          BIF NOT
         CLI       DDUNITYP,X'00'    MAKE DOUBLY SURE
         BNE       DSENDNOU          BIF NOT ESOTERIC NAME
         SR        R2,R2
         IC        R2,DDUNITYP+1     GET REL. ESOTERIC NAME #
         BCTR      R2,0
         SLL       R2,2              MULT BY 4
         LA        R1,ESOTNAME(R2)   GET ADDR OF ESOT. NAME MASK
         XC        DDUNITYP(4),0(R1) CONVERT TO UCBTYPE VALUE
         LH        R1,DDVOLCNT       RESTORE VALUE
DSENDNOU EQU       *
         LA        R2,DDVOLIST-6  PREPARE TO LOAD VOLLIST
         LA        R3,DDCAMWRK+6-12
         C         R1,=A(DDVOLSIZ) # OF VOLUMES IN D.S. > VOLLIST ?
         BNH       DSENDLP1       BIF NOT
         LA        R1,DDVOLSIZ    CAN HANDLE ONLY 20 VOLSERS @ PRESENT
DSENDLP1 EQU       *
         LA        R2,6(,R2)      BUMP TO VOLSER 'TO' LOC
         LA        R3,12(,R3)     BUMP TO VOLSER 'FROM'LOC
         MVC       0(6,R2),0(R3)  MOVE TO VOLLIST STACK
         BCT       R1,DSENDLP1    LOOP UNTIL ALL VLS MOVED
         SPACE     1
DSENDTOT EQU       *
         TM        DDUNITFG,DDUNITPM PARRALLEL MTG REQ.?
         BZ        DSENDDUA       BIF NOT
         LH        R1,DDVOLCNT    ADJUST FOR # OF VOL'S
         C         R1,=F'1'       MUST BE AT LEAST 1
         BNH   DSENDDUA           BYPASS THIS IF INVALID VOLCNT
         STH       R1,DDDEVCNT    OTHERWISE, REVISE DEVICE COUNT
DSENDDUA EQU       *
         CLC   DDUNITYP,=X'FFFFFFFF' DIRECT UNIT ASSIGN?
***********************************************************************
*        HANDLE DIRECT UNIT ASSIGNMENTS
***********************************************************************
         BNE       DSENDTRD       IF NOT, TRY DASD
         LH        R1,DDDUACNT
         LA        R1,1(,R1)      INCR BY ONE
         STH       R1,DDDUACNT
         B         DSENDDSP       HANDLE DEALLOCATION DISPOSITION
DSENDTRD EQU       *
         CLI       DDUNITYP+2,X'20' DASD?
***********************************************************************
*        HANDLE DASD ALLOCATIONS
***********************************************************************
         BNE       DSENDTRT       BIF NOT; TRY TAPE
         L         R1,DDSPC1KB
         LTR       R1,R1
         BNZ       DSENDCDA       BIF SPACE HAS ALREADY BEEN CALC.
         SR        R1,R1
         CH        R1,DDSPCPRI    NO PRI. ALLOC?
         BNL       DSENDDSP       IF NO PRI, GO TO DEALLOC RTN
         TM        DDISP,DDISPOLD+DDISPSHR OLD OR SHR?
         BNZ       DSENDDSP       IF IS, NO CALC NEEDED
         LA        R1,DABEG       SEARCH DASD DEVICE ATTRIBUTE TABLE
         LA        R15,DDUNITYP+2
         BAL       R8,LISTCHCK
         B         DSENDSPC       IF RC=0; THIS STMT WILL BE EXECUTED
         BAL       R14,DSERROR    IF RC=4; THIS STMT WILL BE EXEC.
DSENDSPC EQU       *
         LR        R1,R2
         TM        DDSPCUNT,DDSPCCYL ALLOC IN CYLINDERS?
         BZ        DSENDTRK       IF NOT, TRY TRK
         LH        R3,DDSPCSEC    GET SEC ALLOC
         SLL       R3,1           MULT. BY 2
         AH        R3,DDSPCPRI    ADD PRI. ALLOC TO MODIFIED SECONDARY
         M         R2,12(R1)      MULT # OF CYLS BY # OF BYTES/CYL
         D         R2,=F'1000'    # OF 1000-BYTE BLOCKS
         ST        R3,DDSPC1KB    STOW THIS VALUE
         B         DSENDCDA GO FINISH CALC OF DASD SPACE
DSENDTRK EQU       *
         TM        DDSPCUNT,DDSPCTRK TRACK ALLOC?
         BZ        DSENDBLK       IF NOT, TRY AVE BLK ALLOC
         LH        R3,DDSPCSEC    GET SEC. ALLOC
         SLL       R3,1           MULT BY 2
         AH        R3,DDSPCPRI    PRI ALLOC
         L         R4,4(,R1)      ADJUST # OF BYTES / TRK TO EXCLUDE
         S         R4,8(,R1)      UNUSABLE AREA
         MR        R2,R4          BULT # OF TRKS BY # OF BYTES/TRK
         D         R2,=F'1000' # O# OF BYTES, IN 1000'S, FOR DASD
         ST        R3,DDSPC1KB    # OF 1000-BYTE AREAS
         B         DSENDCDA       GO FINISH CALC OF DASD REQ.
DSENDBLK EQU       *
         TM        DDSPCUNT,DDSPCBLK AVE BLK ALLOC?
         BZ        DSENDABS       IF NOT, MUST BE ABSTR
         SR        R0,R0
         LM        R1,R2,4(R1)    BYTES/TRK; OVERHEAD
         LR        R4,R1
         SR        R4,R2
         AH        R2,DDSPCAVE    AVE BLK LENGTH
         CR        R2,R1          MAKE SURE THIS AVE BLK WILL FIT ON
         BNH       DSENDDFT       THIS DEVICE TYPE; OTHERWISE ADJUST
         LR        R2,R1          TO MAX TRK SIZE FOR DEVICE
DSENDDFT EQU       *
         DR        R0,R2          # OF BLOCKS/TRK
         SR        R2,R2
         LH        R3,DDSPCSEC    SECONDARY ALLOC
         SLL       R3,1           MULT BY 2
         AH        R3,DDSPCPRI    ADD PRIMARY ALLOC TO IT
         DR        R2,R1          # OF TRKS USED BY ALLOC
         MR        R2,R4          # OF BYTES USED BY ALLOC
         D         R2,=F'1000'    # OF BYTES,IN 1,000'S
         ST        R3,DDSPC1KB    STOW FOR LATER USE
         B         DSENDCDA
DSENDABS EQU       *              ASSUME ABSTR ALLOC
         SR        R0,R0
         LM        R1,R2,4(R1)
         SR        R1,R2
         MH        R1,DDSPCPRI
         D         R0,=F'1000'    # OF 1,000-BYTE BLKS
         ST        R1,DDSPC1KB
DSENDCDA EQU       *
         CLC       DDUNITYP(2),=X'FFFF' VIO?
         BNE       DSENDNVI       BIF NOT VIO
         L         R1,DDSPC1KB    # OF 1,000-BYTE BLKS
         A         R1,DDSPCVIO
         ST        R1,DDSPCVIO    INCREMENT VIO SPACE REQUEST
         B         DSENDDSP       GO TO DEALLOC RTN
DSENDNVI EQU       *
         L         R1,DDSPC1KB    # OF 1,000-BYTE BLKS
         A         R1,DDSPCREG    REGULAR (NON-VIO) SPACE REQ.
         ST        R1,DDSPCREG
         B         DSENDDSP       GO TO DEALLOC RTN
         SPACE     1
DSENDTRT EQU       *
         CLI       DDUNITYP+2,X'80' IS THIS A TAPE DEVICE CLASS?
***********************************************************************
*        HANDLE TAPE ALLOCATIONS
***********************************************************************
         BNE       DSENDTRU       IF NOT, TRY UNIT RECORD
         LH        R2,DDREFCNT    GET # OF PIECES IN *.REF KEYWORD
         CH        R2,=H'2'       IS IT EXACTLY 2?
         BE        DSENDDOT       BIF YES; TREAT AS UNIT=AFF=
         LH        R2,DDDEVCNT    GET # OF DEVICES REQ BY THIS DD STMT
         TM        DDUNITYP+1,X'20' 800/1600 BPI DRIVE?
         BO        DSEND800       BIF 800/1600
         LH        R1,DDTA6250
         AR        R1,R2          # OF TAPE DEVICES TO TOTAL TAPE DEV.
         STH       R1,DDTA6250
         B         DSENDDOT       DO TAPE PROC.
DSEND800 EQU       *
         LH        R1,DDTA1600
         AR        R1,R2          # OF TAPE DEVICES TO TOTAL TAPE DEV.
         STH       R1,DDTA1600    # OF 800/1600 BPI DRIVES REQ
DSENDDOT EQU       *
         LA        R15,DDVOLIST-6
         LA        R7,DHVOLTAB ADDR OF MASTER TAPE VOL. TABLE
         LH        R14,DDVOLCNT   # OF VOL'S IN THIS DD STMT'S STACK
         LTR       R14,R14 IF NO VOLSERS YET, MUST BE SCRATCH REQ.
         BNZ       DSENDVCT       BIF VOLSERS ALREADY SPEC.
         TM        DDISP,DDISPNEW IF DISP NOT = NEW, THEN NOT SCRATCH
         BZ        DSENDDSP       BIF NOT DISP=NEW
         LH        R2,DDREFCNT    WAS VOL=REF=.... SPECIFIED?
         LTR       R2,R2
         BNZ       DSENDDSP       BIF YES: DON'T COUNT ADDT'L SCR
         LA        R14,1
         MVC       DDVOLIST(6),=C'SCRTCH' PLACE THIS IN BIN SRCH TABLE
DSENDVCT EQU       *
         LA        R15,6(,R15)    POINT TO NEXT VOL IN STACK
         BAL       R8,TBINSRCH    TRY TO PUT A VOLSER INTO STACK
         B         DSENDSOK       RC=0; VOLSER OF SAME VALUE FOUND
         B         DSENDSOK       RC=4; NEW VOLSER VALUE INSERTED
         B         DSENDSOV       RC=8; FULL - GET 'SCRATCH' MAYBE
         BAL       R14,DSERROR    RC=12; TABLE LOGIC ERROR
*
DSENDSOK EQU       *
         LH        R1,6(,R2)
         LA        R1,1(,R1)      INCR VOL. HIT COUNT BY 1
         STH       R1,6(,R2)
DSENDSOV EQU       *
         BCT       R14,DSENDVCT   LOOP UNTIL THRU DD STMT STACK
         B         DSENDDSP       GO HANDLE DEALLOC DISP
*
DSENDTRU EQU       *
         CLI       DDUNITYP+2,X'08' UNIT RECORD CLASS?
***********************************************************************
*        HANDLE UNIT RECORD ALLOCATIONS
***********************************************************************
         BNE       DSENDTRC       BIF NOT; TRY COMM. GEAR
         LH        R1,DDURCNT     INCR. U/R CNT
         LA        R1,1(,R1)
         STH       R1,DDURCNT
         B         DSENDDSP
         SPACE     1
DSENDTRC EQU       *
         CLI       DDUNITYP+2,X'40' COMM. GEAR?
***********************************************************************
*        HANDLE T/P EQUIPMENT ALLOCATIONS
***********************************************************************
         BNE       DSENDDSP       IF NOT - HANDLE DEALLOC DISP
         LH        R1,DDTELCM
         LA        R1,1(,R1)
         STH       R1,DDTELCM
         SPACE     1
DSENDDSP EQU       *
***********************************************************************
*        HANDLE DEALLOC DISP
***********************************************************************
         TM        DDUNITYP+2,X'A0' IS IT EITHER DISK OR TAPE?
         BNM       DSENDEND       BIF NOT - IT IS NEITHER
         TM        DDISP,DDISPASS WAS DISP=(...,PASS) SPECIFIED
         BZ        DSENDCHD       BIF =(...,PASS) NOT SPEC
         CLI       DDDSNAME,C' '  WAS DSN=' SPEC?
         BNE       DSENDDS3       BIF DSN WAS SPEC
         MVC       DDDSNAME(2),=C'*.' BUILD A REFERBACK-STYLE DSN
         MVC       DDDSNAME+2(8),EXNAME
         LA        R1,DDDSNAME+2  LOOP UNTIL BLANK IS FOUND
         LA        R2,1
         LA        R3,DDDSNAME+9
DSENDDS1 EQU       *
         CLI       0(R1),C' ' DO WE HAVE BLANK?
         BE        DSENDDS2       END-OF-STEPNAME FOUND
         BXLE      R1,R2,DSENDDS1 LOOP UNTIL E-O-S OR BLANK FOUND
DSENDDS2 EQU       *
         MVI       0(R1),C'.'     PERIOD MUST SEPARATE SEGS
         MVC       1(8,R1),DDDDNAME
DSENDDS3 EQU       *
         LA        R1,PSDSBEG     IS THIS DSN ALREADY IN PASSED D.S. TA
         LA        R15,DDDSNAME
         BAL       R8,LISTCHCK
         B         DSENDEND       RC=0; FOUND EXISTING ENTRY
         B         DSENDDS4       RC=4; NO EXISTING ENTRY FOUND
DSENDDS4 EQU       *
         LA        R1,PSDSBEG     SINCE NONE EXISTS, ADD ONE
         LA        R15,DDDSNAME
         BAL       R8,LISTADD
         B         DSENDDS5       RC=0; DSN ADDED SUCCESSFULLY
         B         DSENDEND       RC=4; NOT ADDED - NO MORE ROOM
DSENDDS5 EQU       *
         MVC       44(4,R2),DDUNITYP MOVE UCBTYP & SPACE DATA IN AFTER
         MVC       48(4,R2),DDSPC1KB DSNAME
         B         DSENDEND
DSENDCHD EQU       *
         LA        R1,PSDSBEG     ATTEMPT TO DELETE DSN FROM STACK
         LA        R15,DDDSNAME
         BAL       R8,LISTPULL
         B         DSENDEND       RC=0; DELETED
         B         DSENDEND       RC=4; DSN TO-BE-DELETED WAS NOT FND
         SPACE     1
DSENDEND EQU       *
         CLI       DDDDNAME,C' '  WAS THERE A DDNAME?
         BE        DSENDXIT       BIF NOT
         CLI       DDUNITYP+2,X'00' WAS A UNIT TYPE FOUND OR SPEC?
         BE        DSENDXIT       BIF NONE WAS FOUND OR SPEC.
         LA        R15,DDDDNAME   ADD THIS DDNAME TO UNIT=AFF= TABLE
         LA        R1,UNAFBEG
         BAL       R8,LISTADD
         B         DSENDMUT       IF RC=0; EXEC THIS STMT
         B         DSENDXIT       IF RC=4: EXEC THIS STMT
DSENDMUT EQU       *
         MVC       8(4,R2),DDUNITYP MOVE UNIT TYPE TO UNIT=AFF TABLE
DSENDXIT EQU       *
         BR        R9
DSERROR  EQU       *
         OI        ERRSW,ERDDRT   TURN ON ERROR INDICATOR
         BR        R9
         LTORG
         DROP      R10
         TITLE     'IEFUJV - EXECUTE STATEMENT SUMMARIZATION RTN'
         DS        0D
DOEXECSM EQU       *
***********************************************************************
*
*        ROUTINE TO SUMMARIZE PROCESSING FOR ENTIRE STEP AFTER ALL
*        DD CARDS (IF ANY) HAVE BEEN PROCESSED.
*
***********************************************************************
         USING     DOEXECSM,R10
         MVC       EYECATCH,=CL8'SUMEXEC ' MOVE IN EYECATCHER
         L         R1,DDSPCREG
         C         R1,DHSPCREG
         BNH       ESDOVIO
         ST        R1,DHSPCREG
ESDOVIO  EQU       *              'SPACE=' FOR VIO
         L         R1,DDSPCVIO
         C         R1,DHSPCVIO
         BNH       ESDO6250
         ST        R1,DHSPCVIO
ESDO6250 EQU       *              6250-BPI TAPE DRIVES
         LH        R1,DDTA6250
         CH        R1,DHTA6250
         BNH       ESDO1600
         STH       R1,DHTA6250
ESDO1600 EQU       *              800/1600-BPI TAPE DRIVES
         LH        R1,DDTA1600
         CH        R1,DHTA1600
         BNH       ESDODUA
         STH       R1,DHTA1600
ESDODUA  EQU       *              DIRECT UNIT ASSIGN CASES
         LH        R1,DDDUACNT
         CH        R1,DHDUACNT
         BNH       ESDOTLM
         STH       R1,DHDUACNT
ESDOTLM  EQU       *              TELECOMM DEVICES
         LH        R1,DDTELCM
         CH        R1,DHTELCM
         BNH       ESDOUREC
         STH       R1,DHTELCM
ESDOUREC EQU       *
         LH        R1,DDURCNT
         CH        R1,DHURCNT
         BNH       ESEND
         STH       R1,DHURCNT
ESEND    EQU       *
         BR        R9
         LTORG
         DROP      R10
         TITLE     'IEFUJV - JOB CLASS LOOKUP PROCESSOR'
         DS        0D
DOLOOKUP EQU       *
***********************************************************************
*
*        ROUTINE TO PERFORM LOOKUP OF JOB CLASS, PERFORM PRINTING
*        OF MOUNTABLE-DEVICE VOLSERS( IF ANY), AND RESET JOB INTO
*        A SPECIFIED CLASS
*
***********************************************************************
         USING     DOLOOKUP,R10
         MVC       EYECATCH,=CL8'LOOKUP'
         L         R1,JBTIME      WAS JOB LEVEL EXEC TIME SPEC?
         LTR       R1,R1
         BNZ       LRDOREGN       BIF SO
         L         R1,EHTIME      OTHERWIZE, USE CONSTRUCTED TIME
         ST        R1,JBTIME
LRDOREGN EQU       *
         L         R1,CWAJMRPT    GET PTR TO JMR
         USING     COMMEXIT,R1    MAKE IT ADDRESSABLE
         TM        CEPIDFLG,CEPIDF07 IS 'REGION=' ON JOB STMT A DEFAULT
         DROP      R1             NO LONGER NEED JMR
         BZ        LRDOPFM        BIF NOT; USE JOB-LEVEL VALUE AS IS
         LH        R1,EHREGION    OTHERWISE, TAKE LARGEST FROM ANY STEP
         STH       R1,JBREGION    & USE AS JOB -LEVEL VALUE
LRDOPFM  EQU       *
         TM        JBSW,JBPERFM   WAS 'PERFORM=' ON JOB STMT?
         BO        LRDOFLAG       BIF YES; DON'T SUBST. 'EXEC' STMT VAL
         LH        R1,EHPFM#
         STH       R1,JBPGN
LRDOFLAG EQU       *
         OC        JBSW,EHSW      PROPAGATE V=R & 'PERFORM=' FLAGS
         L         R1,16          GET ADDR OF CVT
         USING     CVT,R1         MAKE IT ADDRESSABLE
         L         R1,CVTUSER     GET CONTENTS OF CVTUSER FIELD
         LA        R1,0(,R1)      CLEAR HI-BYTE
         LTR       R1,R1          IS THERE AN ADDRESS HERE?
         BNZ       LRDOHVTB       BIF AN ADDRESS APPEARS TO BE PRESENT
         WTO       'IEFUJV-25-W - RESOURCE LIMIT TABLE ADDRESS NOT FOUNX
               D',ROUTCDE=2,DESC=6
         B         LREND          LEAVE QUIETLY
LRDOHVTB EQU       *
         USING     ACCTABLE,R1    MAKE ACCOUNTING AREA ADDRESSABLE
         CLI       ACVERSN,ACVER# CORRECT VERSION OF ACCT TABLES?
         BNE       LREND          BIF NOT; DON'T NEED TROUBLE
*
         L         R1,ACRLADDR    GET ADDR OF RESOURCE LIMIT TABLE
         USING     RESLIMIT,R1    MAKE IT ADDRESSABLE
         L         R2,RLLENGTH    SIZE OF ONE TABLE ELEMENT
         L         R3,RLTABLST    STOP ADDR-ADDR OF LAST ELEMENT IN TAB
         LA        R1,RLTABLE     BEGINNING ADDR OF TABLE
         USING     RESLIMIT+(RLTABLE-RESLIMIT),R1 REVISE START ADDR
LRDOCHCK EQU       *              CHECK JOB REQ. AGAINST CLASS VALUES
         L         R4,RLVIO       VIO LIMIT / STEP
         C         R4,DHSPCVIO    DOES USER EXCEED CLASS VIO LIMIT /STE
         BL        LRDOLOOP       BIF HE DOES; ON TO NEXT CLASS
         L         R4,RLDASD      'REGULAR' DASD LIMIT
         C         R4,DHSPCREG    DOES USER EXCEED CLASS DASD LIMIT/STE
         BL        LRDOLOOP       BIF HE DOES; ON TO NEXT CLASS
         L         R4,RLCPU       JOB CPU TIME LIMIT
         C         R4,JBTIME      DOES USER EXCEED CLASS CPU TIME LIMIT
         BL        LRDOLOOP       BIF HE DOES
         LH        R4,RLMEMORY    VIRTUAL MEMORY LIMIT
         CH        R4,JBREGION    DOES USER EXCEED CLASS REGION LIMIT
         BL        LRDOLOOP       BIF HE DOES
         LH        R4,RLLINES     PRINT LINE LIMIT PER JOB
         CH        R4,JBLINES     DOES USER EXCEED CLASS PRINT LINE LIM
         BL        LRDOLOOP       BIF HE DOES
         LH        R4,RL6250      MAX 6250/1600 BPI DRIVES/STEP
         CH        R4,DHTA6250
         BL        LRDOLOOP
         LH        R4,RL1600      MAX 1600/800 BPI DRIVES/STEP
         CH        R4,DHTA1600
         BL        LRDOLOOP
         TM        JBSW,JBVEQR    WAS V=R SPECIFIED?
         BZ        LRTSTPFM       BIF NOT; TRY 'PERFORM='J
         TM        RLFLAGS,RLVEQR IS V= R PERMITTED?
         BZ        LRDOLOOP       BIF NOT
LRTSTPFM EQU       *
         LH        R4,JBPGN       DID PERFORM= VALUE EXCEED LIMIT?
         CH        R4,RLPRFORM    CHECK AGAINST RESOURCE LIMIT TABLE
         BH        LRDOLOOP       BIF 'PERFORM=' VALUE EXCEEDED LIMIT
LRTSTHLD EQU       *
LRTSTDUA EQU       *
         LH        R4,RLDUA       MAX # OF DIRECT UNIT ASSIGNS/STEP
         CH        R4,DHDUACNT DOES USER EXCEED LIMIT?
         BL        LRDOLOOP                BIF YES
LRTSTTP  EQU       *
         LH        R4,RLTP        MAX # OF T/P DEVICES/STEP
         CH        R4,DHTELCM   DID USER EXCEED LIMIT?
         BL        LRDOLOOP     BIF YES
LRTSTPTY EQU       *
         LH        R4,RLPRTY      MAX SELECTION PRIORITY
         CH        R4,JBPRTY        DID JOB EXCEED IT?
         BL        LRDOLOOP         BIF YES
LRTSTUR  EQU       *
         LH        R4,DHURCNT     # OF UNIT RECORD (NON-JES) ASSIGNS
         LTR       R4,R4          WERE THERE ANY?
         BZ        LRHAVEIT       BIF WE MADE IT (VALID CLASS)
         TM        RLFLAGS,RLUROK UNIT RECORD DEVICE DIRECT ASSIGN OK?
         BO        LRHAVEIT       BIF WE HAVE A VALID CLASS
LRDOLOOP EQU       *
         BXLE      R1,R2,LRDOCHCK LOOP UNTIL THRU CLASS TABLE
         LR        R1,R3          IF FALL INTO HERE, HAVE BAD JOB
LRHAVEIT EQU       *
         MVC       JBCLASS,RLCLASS GET ASSIGNED JOB CLASS
         TM        RLFLAGS,RLTIMOUT ARE CPU TIME & SYSOUT LIMITS ENF?
         BZ        LRNOENF        BIF NOT; EXTENSIONS MAY BE GRANTED
         L         R2,CWAJMRPT    GET ADDR OF COMMON EXIT PARM AREA
         USING     COMMEXIT,R2    MAKE IT ADDRESSABLE
         OI        CEPIDFLG,CEPIDF01 STRICTLY ENFORCE CPU TIME & LINE
LRNOENF  EQU       *
         DROP      R1,R2          NO LONGER NEED DSECT FOR ADDRESSING
         ST        R1,JBCLSPTR    HOLD ONTO THIS PTR FOR A WHILE
         LA        R2,74          LENGTH OF PICKING TICKET
         STH       R2,PTL1LGTH
         STH       R2,PTL2LGTH
         LH        R2,=X'8040'    MCS FLAGS
         STH       R2,PTMCSFLG
         LH        R2,=X'0400'
         STH       R2,PTDESCOD    DESCRIPTOR CODES
         LH        R2,=X'0002'    ROUTING CODES
         STH       R2,PTROUTCD
         LH        R2,=X'2000'    LINE TYPE
         STH       R2,PTL1TYPE
         STH       R2,PTL2TYPE
         LA        R2,10          # OF LINES
         STC       R2,PT#LINES
         MVI       PTL2TEXT,C' '  BLANK OUT TEXT AREAS
         MVC       PTL2TEXT+1(L'PTL2TEXT-1),PTL2TEXT
         LA        R2,PTL2LGTH    BLANK OUT REMAINING LINES
         LA        R4,PTL3LGTH-PTL2LGTH
         LA        R5,PTL9LGTH
LRPTLOOP EQU       *
         MVC       (PTL3LGTH-PTL2LGTH)(PTL3LGTH-PTL2LGTH,R2),0(R2)
         BXLE      R2,R4,LRPTLOOP
         OI        PTLATYPE,X'10' SET FLAG FOR LAST LINE IN ML-WTO
         MVI       PTL1TEXT,C' '  BLANK OUT 1ST LINE
         MVC       PTL1TEXT+1(L'PTL1TEXT-1),PTL1TEXT
         L         R1,JBCLSPTR    GET PTR TO JOB CLASS ENTRY
         USING     RLTABLE,R1
         TM        RLFLAGS,RLHOLD IS JOB TO BE HELD BY THE SCHEDULER?
         DROP      R1
         BO        LRHLDMSG       BIF YES
         TM        JBSW,JBHOLDRQ  TYPRUN=HOLD' SPEC.?
         BZ        LRPGMRN        BIF NOT
LRHLDMSG EQU       *
         MVC       PTL1TEXT(15),=C'*** H O L D ***'
LRPGMRN  EQU       *
         MVC       PTL1TEXT+20(20),JBPGMRNM PROGRAMMER NAME
         MVC       PTL1TEXT+40(11),JBACCT1+1 MOVE ACCTNO
         SR        R6,R6          CLEAR R6
         IC        R6,JBACCT2     GET LENGTH OF 2ND ACCT FIELD
         LTR       R6,R6          ZERO LENGTH (NO ACCT)?
         BZ        LRNO2ACT       BIF NO 2ND FIELD
         BCTR      R6,0           LENGTH -> LENGTH CODE
         LA        R1,PTL1TEXT+52 ADDR OF LOCATION FOR 2ND ACCTING FLD
         LA        R7,JBACCT2     GET 'FROM' DATA ADDRESS
         EX        R6,MOVER       MOVE TO DISPLAY AREA
         MVI       PTL1TEXT+51,C',' PUT COMMA IN BETWEEN FIELDS
LRNO2ACT EQU       *
         MVC       PTL1TEXT+63(7),=X'D7D9E3E8212020' 'PRTY=XX' DISPLAY
         LH        R0,JBPRTY
         CVD       R0,PACKWK
         ED        PTL1TEXT+67(3),PACKWK+6
         MVI       PTL1TEXT+67,C'='
         MVC       PTL2TEXT,PATRNPT PICKING TICKET HEADER
         MVC       PTL3TEXT+67(3),=X'202120'
         LH        R2,DHURCNT     UNIT RECORD COUNT
         CVD       R2,PACKWK
         ED        PTL3TEXT+66(4),PACKWK+6
         MVC       PTL3TEXT+64(3),=X'202120'
         LH        R2,DHDUACNT    DIRECT UNIT ASSIGNMENT COUNT
         CVD       R2,PACKWK
         ED        PTL3TEXT+63(4),PACKWK+6
         MVC       PTL3TEXT+61(3),=X'202120'
         LH        R2,DHTELCM     # OF TELECOMM DEVICES
         CVD       R2,PACKWK
         ED        PTL3TEXT+60(4),PACKWK+6
         MVC       PTL3TEXT+54(7),=X'2020206B202120'
         L         R2,DHSPCVIO    VIO DASD SPACE
         CVD       R2,PACKWK
         SRP       PACKWK,1,0
         ED        PTL3TEXT+53(8),PACKWK+4
         MVC       PTL3TEXT+46(8),=X'202020206B202120'
         L         R2,DHSPCREG    NON-VIO DASD
         CVD       R2,PACKWK
         ED        PTL3TEXT+45(9),PACKWK+4
         MVC       PTL3TEXT+41(5),=X'2020202120'
         LH        R2,DHTA1600    1600/800 BPI TAPE DRIVES
         CVD       R2,PACKWK
         ED        PTL3TEXT+40(6),PACKWK+5
         MVC       PTL3TEXT+36(5),=X'2020202120'
         LH        R2,DHTA6250    6250/1600 BPI TAPE DRIVES
         CVD       R2,PACKWK
         ED        PTL3TEXT+35(6),PACKWK+5
         MVC       PTL3TEXT+30(6),=X'20206B202120'
         LH        R2,JBLINES     # OF 1,000'S OF SYSOUT LINES (EST)
         CVD       R2,PACKWK
         ED        PTL3TEXT+29(7),PACKWK+5
         MVC       PTL3TEXT+24(6),=X'20206B202120'
         LH        R2,JBREGION    EST. REGION TO BE USED
         CVD       R2,PACKWK
         ED        PTL3TEXT+23(7),PACKWK+5
         MVC       PTL3TEXT+16(8),=X'20207A20207A2120'
         L         R3,JBTIME      EST JOB CPU TIME LIMIT
         SR        R2,R2
         D         R2,=F'60'      DIVIDE BY # OF SECS
         CVD       R2,PACKWK1     CONV FOR DISPLAY THE # OF SECS
         SR        R2,R2
         D         R2,=F'60'      DIVIDE BY # OF MINS IN HOUR
         CVD       R2,PACKWK      PUT IN STAGING AREA
         SRP       PACKWK,2,0     MULT BY 100 THRU SHIFT OPER
         AP        PACKWK1,PACKWK ESTAB MM:SS
         CVD       R3,PACKWK
         SRP       PACKWK,4,0     MULT BY 1000 BY SHIFT OPER
         AP        PACKWK1,PACKWK ESTAB HH:MM:SS FORMAT
         SRP       PACKWK1,1,0    PREPARE FOR EEDIT INSTR
         ED        PTL3TEXT+15(9),PACKWK1+4
         MVC       PTL3TEXT+12(3),=X'202120' PERFORMANCE GROUP #
         LH        R3,JBPGN
         CVD       R3,PACKWK
         ED        PTL3TEXT+11(4),PACKWK+6
         MVC       PTL3TEXT+9(1),JBCLASS EXIT-ASSIGNED JOB CLASS
         MVC       PTL3TEXT(8),JBNAME JOB NAME
         MVC       PTL4TEXT(4),=C'JOB '
         MVC       PTL4TEXT+4(4),JBHASP JES JOB #
         LA        R7,DHVOLTAB    ADDR OF BINARY LOOKUP TAPE VOLUME TAB
         USING     TABLE,R7       MAKE IT ADDRESSABLE
         L         R6,TABCURR     # OF ENTRIES NOW IN USE
         LTR       R6,R6          ARE ANY IN USE?
         BZ        LRPRNTKT       BIF NOT: PRINT TICKET AS IS
         LA        R5,TABENTRY
         LA        R2,8           FROM/TO ELEMENT LENGTH
         LA        R3,PTL5LGTH-8
         LA        R1,PTL5LGTH-6
*
LRVOLOOP EQU       *
         LA        R1,PTL5TEXT-PTL5LGTH+6(,R1) CURR LINE START
         LA        R3,PTL6LGTH-PTL5LGTH(,R3)   CURR LINE STOP
LRLNLOOP EQU       *
         AR        R5,R2
         MVC       0(6,R1),0(R5)  MOVE VOLSER TO OUTPUT AREA
         CLC       0(6,R1),=C'SCRTCH' SCRATCH TAPE?
         BNE       LRLNTST
         MVC       2(4,R1),=X'21202020'
         LH        R0,6(,R5)      GET # OF SCRATCH TAPES
         STH       R0,DHSCRCNT    HOLD ON TO IT
         CVD       R0,PACKWK      CONVERT FOR DISPLAY
         SRP       PACKWK,1,0     SHIFT LEFT 1 POS
         ED        2(4,R1),PACKWK+5
         MVI       2(R1),C'R'     REPLACE 'R' IN 'SCR'
LRLNTST  EQU       *
         BCT       R6,LRCHKLNE
         B         LRPRNTKT       AFTER ALL VOLSERS MOVED, PRINT TICKET
LRCHKLNE EQU       *
         BXLE      R1,R2,LRLNLOOP LOOP UNTIL LINE IS FULL
         B         LRVOLOOP       WHEN COMMAND FALLS THRU, NEW LINE
LRPRNTKT EQU       *
         DROP      R7
         L         R1,JBRETURN    GET RETURN CODE
         LTR       R1,R1          NON-ZERO RETURN CODE?
         BNZ       LRSRTICK       BIF JOB IS TO BE FAILED
         L         R2,JBCLSPTR    GET BACK PTR TO CLASS ENTRY
         USING     RLTABLE,R2
         TM        RLFLAGS,RLHOLD DOES JOB CLASS REQUIRE 'TYPRUN=HOLD?'
         DROP      R2
         BO        LRREGTIK       BIF REGULAR (FULL) TICKET
         TM        JBSW,JBHOLDRQ  WAS 'HOLD' REQUESTED?
         BO        LRREGTIK       BIF YES (REG. TICKET)
LRSRTICK EQU       *
         LA        R1,3           SYSTEM LOG ONLY
         STC       R1,PT#LINES
         OI        PTL3TYPE,X'10' FORCE 'LAST LINE' INDIC
         XC        PTROUTCD,=X'0006' ROUTCDE 15 -> 14
         SR       R0,R0     PREVENT INTERFERENCE
         LA       R1,PICKTICK GET TEXT FOR MULTI-WTO
         WTO      MF=(E,(1))    ISSUE WTO
         B        LRCHKCLS      NOW CHECK FOR CLASS RESET
LRREGTIK EQU       *
         SR        R0,R0          CLEAR REG TO PREVENT INTERFERENCE
         LA        R1,PICKTICK
         WTO       MF=(E,(1))
         LA        R2,74          LENGTH OF PICKING TICKET
         STH       R2,PTL1LGTH
         STH       R2,PTL2LGTH
         LH        R2,=X'8040'    MCS FLAGS
         STH       R2,PTMCSFLG
         LH        R2,=X'0400'
         STH       R2,PTDESCOD    DESCRIPTOR CODES
         LH        R2,=X'0002'    ROUTING CODES
         STH       R2,PTROUTCD
         LH        R2,=X'2000'    LINE TYPE
         STH       R2,PTL1TYPE
         STH       R2,PTL2TYPE
         LA        R2,10          # OF LINES
         STC       R2,PT#LINES
         MVI       PTL2TEXT,C' '  BLANK OUT TEXT AREAS
         MVC       PTL2TEXT+1(L'PTL2TEXT-1),PTL2TEXT
         LA        R2,PTL2LGTH    BLANK OUT REMAINING LINES
         LA        R4,PTL3LGTH-PTL2LGTH
         LA        R5,PTL9LGTH
LRLOOP#5 EQU       *
         MVC       (PTL3LGTH-PTL2LGTH)(PTL3LGTH-PTL2LGTH,R2),0(R2)
         BXLE      R2,R4,LRLOOP#5
         OI        PTLATYPE,X'10' SET FLAG FOR LAST LINE IN ML-WTO
         MVI       PTL1TEXT,C' '  BLANK OUT 1ST LINE
         MVC       PTL1TEXT+1(L'PTL1TEXT-1),PTL1TEXT
         SR       R0,R0       CLEAR REG TO PREVENT INTERFERENCE
         LA       R1,PICKTICK GET ADDR OF PICKING TICKET
         WTO      MF=(E,(1))  PRINT OUT 10 BLANK LINES
         WTO      ' ',ROUTCDE=15,DESC=6     NOW THE 21ST LINE
LRCHKCLS EQU       *
         L         R1,JOBSJB      GET SJB ADDRESS
         USING     SJBDSECT,R1
         MVC       SJBJCLAS,JBCLASS  TELL JES OF THE NEW CLASS
         L         R1,JOBJCT      GET JCT ADDRESS
         USING     JCTDSECT,R1    TELL ASSEMBLER
         MVC       JCTJCLAS,JBCLASS MOVE IN JOB CLASS
         MVC       JCTCLASS,JBCLASS MOVE IT INTO YET ANOTHER AREA
         L         R3,16          GET ADDR OF CVT
         USING     CVT,R3
         L         R3,CVTJESCT    CVT -> JESCT
         USING     JESCT,R3
         L         R3,JESSSCT     JESCT -> SSCVT
         USING     SSCT,R3
         L         R3,SSCTSSVT    SSCVT -> SSVT
         USING     SSVT,R3
         L         R3,$SVHCT      SSVT -> HCT
         USING     HCTDSECT,R3
         L         R3,$JOBQPTR    GET STACK OF JQE POINTERS
         A         R3,JCTJQE      FIELD CONTAINS OFFSET TO JQE
         USING     JQEDSECT,R3
         AIF       ('&SYSPARM' EQ 'NONSE' OR '&SYSPARM' EQ 'SE2' OR    *
               '&SYSPARM' EQ 'SP10' OR '&SYSPARM' EQ 'SP11').PRESP3A
         AIF       ('&SYSPARM' EQ 'SP12' OR '&SYSPARM' EQ 'SP13').SP3A
         MNOTE     12,'IEFUJV - INVALID SYSPARM VALUE'
.SP3A    ANOP
         MVC       JQEJCLAS,JBCLASS UPDATE POINTER HERE AS WELL
.PRESP3A ANOP
         TM        JQEFLAG2,QUEINDAF  INDEPENDENT MODE?
         BO        LRINDEP       BIF INDEPENDENT MODE
         NC        AFFMASK(1),JQEFLAG2 DISCOVER FINAL CPU AFFINITY
         L         R4,16          GET CVT ADDRESS
         USING     CVT,R4         MAKE IT ADDRESSABLE
         ICM       R4,7,CVTUSER+1 GET OUR ACCOUNTING AREA
         BZ        LRINDEP        BIF NO CVT USER FIELD
         USING     ACCTABLE,R4    OTHERWISE, PROCEED
         CLI       ACFLAG,ACLOADED IS TABLE LOADED (SUCCESSFULLY)?
         BNE       LREND          BIF NOT; DON'T ASK FOR TROUBLE
         CLI       ACVERSN,ACVER# CORRECT VERSION OF ACCT TABLES?
         BNE       LREND          BIF NOT; DON'T ASK FOR TROUBLE
         L         R4,ACJRADDR    GET ADDR OF JOB ROUTING PGM NAME TAB
         USING     JOBROUTE,R4    MAKE AREA ADDRESSABLE
         LH        R4,JR#CPU      GET # OF CPU'S IN OUR JES2 COMPLEX
         C         R4,=A(7)       MAX # OF CPU'S FOR A JES2 COMPLEX
         BNL       LRCHKAFF       IF WE HAVE MAX, CHECK DIRECTLY
         LA        R5,0           SET UP A REG TO BUILD AN 'AND' MASK
         LA        R6,1           SET UP A BIT FLIPPER
         B         LRSLBCT        POSITION BIT OVER MASK FOR UNUSED CPU
LRSLLOOP EQU       *
         SLL       R6,1           MOVE FLIPPER TO LEFT 1
LRSLBCT  EQU       *
         OR        R5,R6          BUILD AN 'AND' MASK FOR OUR COMPLEX
         BCT       R4,LRSLLOOP
         EX        R5,LRNIINST    TURN OFF SYSAFF BITS FOR CPUS NOT IN
*                                 COMPLEX (I.E. 7-N WHERE N= # OF CPUS)
LRCHKAFF EQU       *
         CLI       AFFMASK,X'00' ANY ELIGIBLE PROCESSORS?
         BNE       LRAFFOK       BIF AT LEAST ONE
         WTO       'IEFUJV-28-I - NO ELIGIBLE CPUS FOUND',ROUTCDE=2    X
               DESC=6
         LA        R15,4         SET RC=4 FOR JOB CANCEL
         ST        R15,JBRETURN
         OI        PARMSW,JOBFAIL
         B         LREND
LRNIINST NI        AFFMASK,X'00' PATTERN 'NI' INSTRUCTION
LRAFFOK  EQU       *
         MVC       JQEFLAG2(1),AFFMASK  RESET SYSTEM AFFINITY
LRINDEP  EQU       *
         L         R2,JBCLSPTR    GET PTR TO CLASS ENTRY
         USING     RLTABLE,R2
         TM        RLFLAGS,RLHOLD DOES JOB CLASS REQUIRE 'TYPRUN=HOLD'?
         DROP      R2,R3,R4
         BZ        LREND          BIF NOT
         OI        JCTJBOPT,JCTTHOLD PUT JOB ON 'HOLD'
         DROP      R1
LREND    EQU       *
         BR        R9
         LTORG
         DROP      R10
         TITLE     'IEFUJV - SMF RECORD PROCESSOR'
DOSMFREC DS        0D
***********************************************************************
*
*        WRITE OUT SMF STATISTICS RECORD CONTAINING JOB RESOURCE
*        REQUIREMENTS DISCOVERED BY THIS EXIT
*
***********************************************************************
         USING     DOSMFREC,R10   GIVE ROUTINE ADDRESSABILITY
         MVC       EYECATCH,=CL8'SMFREC  ' MOVE IN EYECATCHER
         L         R0,SMFGMPRM    GET SMF GETMAIN PARM
         GETMAIN   R,LV=(0)       GET AN AREA FOR THE RECORD
         LR        R7,R1          HOLD ONTO AREA PTR
         USING     SMF239,R7      GIVE RECORD AREA ADDRESSABILITY
         XC        SMF239(S239LTH),SMF239 BLANK OUT AREA
         MVC       S239LGTH(2),SMFGMPRM+2 PUT IN RDW VALUE
         OI        S239FLAG,S239VS2 RECORD CREATED UNDER VS2 (MVS)
         LA        R1,239         RECORD TYPE #
         STC       R1,S239RTY
         TIME      BIN            GET DATE & TIME
         ST        R0,S239TME
         ST        R1,S239DTE
         L         R1,CWAJMRPT    GET JMR POINTER
         USING     COMMEXIT,R1
         MVC       CEPIDSCL,JBCLASS PUT IN EXIT-ASSIGNED CLASS
         MVC       S239SID,CEPSYSID
         MVC       S239JBN,CEPJOBN
         MVC       S239RST,CEPRDRTM TIME THIS JOB HIT READER
         MVC       S239RSD,CEPRDRDT DATE THIS JOB HIT READER
         MVC       S239UIF,CEPUSRID USER ID FIELD
         MVC       S239CLS,JBCLSVAL USER-SPECIFIED CLASS
         MVC       S239JCLS,JBCLASS EXIT-ASSIGNED CLASS
         MVC       S239ACT1,JBACCT1 1ST ACCT'ING FIELD
         MVC       S239ACT2,JBACCT2 2ND ACCOUNTING FIELD
         MVC       S239CPU,JBTIME EST TCB TIME
         MVC       S239REGN,JBREGION MAX REGION FOR JOB
         MVC       S239PRTY,JBPRTY '/*PRIORITY' OR 'PRTY=' VALUE
         MVC       S239LNES,JBLINES EST # OF LINES
         MVC       S239HASP,JBHASP HASP JOB NUMBER
         MVC       S239PG#,JBPGN PERF. GROUP #
         MVC       S239JBSW,JBSW EXIT-SUPPLIED SWITCHES
         L         R1,JBRETURN    RETURN CODE ISSUED BY IEFUJV
         STH       R1,S239UJVR
         MVC       S239SREG,DHSPCREG NON-VIO TEMP DASD REQ.
         MVC       S239SVIO,DHSPCVIO VIO TEMP DASD REQ.
         MVC       S2396250,DHTA6250 MAX # OF 6250-BPI DRIVES REQ'D
         MVC       S2391600,DHTA1600 MAX # OF 1600/800-BPI DR/STEP
         MVC       S239DUA,DHDUACNT MAX # OF DIRECT UNIT ASSIGNS
         MVC       S239TLCM,DHTELCM MAX # OF TELECOMM DEVICES REQ'D
         MVC       S239UR,DHURCNT MAX # OF UNIT-RECORD DEVICE ASSIGN'S
         MVC       S239SCRT,DHSCRCNT # OF SCRATCH TAPES USED BY EXIT
         SMFWTM    (R7)           WRITE SMF RECORD
         L         R0,SMFGMPRM
         LR        R1,R7          LOAD PARMS FOR FREEMAIN
         FREEMAIN  R,LV=(0),A=(1)
         BR        R9             RETURN
         LTORG
         DROP      R1,R10
         TITLE    'IEFUJV - HGFMAIN ROUTINE LIFTED FROM HASPSSSM'
*
*
*              BRANCH-TYPE GETMAIN/FREEMAIN SUBROUTINE
*
*
HGFMAIN  DS    0H
         USING *,R15
*
*              SET PROTECTION KEY TO ZERO
*
         MODESET EXTKEY=ZERO,SAVEKEY=(2)  SAVE KEY, SET KEY ZERO.
         LA    R4,0(,R4)           SAVE FORMER KEY
         SLL   R2,24               IN REGISTER 4,
         OR    R4,R2               BITS 0-3.
*
*              SAVE REGISTERS PREPARATORY TO SETLOCK
*
         LR    R3,R11              SAVE REGISTER 11 IN REGISTER 3.
         LR    R7,R12              SAVE REGISTER 12 IN REGISTER 7.
         LR    R2,R13              SAVE REGISTER 13 IN REGISTER 2.
*
*              ACQUIRE LOCAL LOCK AND SAVE RETURN CODE
*
HGF010   SETLOCK OBTAIN,TYPE=LOCAL,MODE=UNCOND,RELATED=HGF020
         SLL   R13,24              SAVE SETLOCK RETURN CODE
         OR    R4,R13              IN REGISTER 4 BITS 4-7.
*
*              RESTORE REGISTERS AFTER SETLOCK
*
         LR    R11,R3              RESTORE REGISTER 11 FROM REG 3.
         LR    R12,R7              RESTORE REGISTER 12 FROM REGISTER 7.
         LR    R13,R2              RESTORE REGISTER 13 FROM REGISTER 2.
*
*              LOAD CRBRANCH, TCB, AND ASCB ADDRESSES
*
         LR    R2,R4               SAVE CONTENTS OF R4 IN R2.
         TM    0(R2),X'50'         IS THIS BUFFER FREEMAIN...
         BNO   HGFB10              BRANCH IF NOT.
* BUFFER FREEMAIN - TCB, ASCB ARE USED FROM BUFFER
         USING BFD,R1              USE THE BUFFER DSECT.
         USING PSA,R0              USE PREFIX SAVE AREA DSECT  @OZ42546
         L     R3,PSATOLD          POINT TO CURRENT TCB        @OZ42546
         TM    TCBPKF-TCB(R3),X'80' IF NOT PROBLEM PROGRAM     @OZ42546
         BZ    HGF015                  STATE, BRANCH           @OZ42546
         CLI   1(R2),X'F0'         IS THIS A UBUF...           @OZ42546
         BE    HGFB10              ...BRANCH IF SO             @OZ42546
HGF015   L     R4,BFTCB            R4=TCB ADDRESS.             @OZ42546
         B     HGFB20              CONTINUE.
* OTHER OPERATION - TCB, ASCB ARE USED FROM IEATCBP
*              THIS LINE DELETED BY APAR ===>                  @OZ42546
HGFB10   EQU   *                                               @OZ43706
         ICM   R4,15,PSATOLD       GET CURRENT TCB             @OZ43706
         BNZ   HGFB102             R4=TCB IF TCB MODE          @OZ43706
*              THIS LINE DELETED BY APAR NUMBER                @OZ43706
*              THIS LINE DELETED BY APAR NUMBER                @OZ43706
*        GET TCB FROM INPUT RQE IF UNDER SRB FOR CHAN-END      @OZ43706
HGFB101  L     R4,4(R13)           R4=RQE FROM CHANNEL-END     @OZ43706
*              THIS LINE DELETED BY APAR NUMBER                @OZ43706
         L     R4,RQETCB-RQE(R4)   R4=TCB FROM RQE             @OZ43706
HGFB102  LR    R3,R4               SAVE R4                     @OZ43706
         USING TCB,R4              SET TCB ADDRESSABILITY.
         L     R4,TCBJSCB          POINT TO TCB'S JSCB.
         USING IEZJSCB,R4          SET JSCB ADDRESSABILITY.
         L     R4,JSCBACT          POINT TO ACTIVE JSCB.
         L     R4,JSCBTCBP         POINT THENCE TO TCB.
         LTR   R4,R4               IF NONZERO POINTER,
         BNZ   *+6                 KEEP IT                     @OZ43706
         LR    R4,R3               RESTORE TCB ADDRESS         @OZ43706
         TM    0(R2),X'18'         IS TCB SUPPLIED FOR FREEMAIN...
         BNO   *+8                 SKIP IF NOT.
         L     R4,0(,R1)           USE USER-SUPPLIED TCB.
         DROP  R4                  DROP JSCB BASE.
HGFB20   L     R7,PSAAOLD          R7 = ASCB ADDRESS.
* SINCE R15 IS OUR BASE, POINT TO CRBRANCH WITH R14.
         L     R3,CVTPTR           POINT TO CVT
         USING CVT,R3              AND USE DSECT.
         L     R14,CVTCRMN         LOAD ADDRESS OF CRBRANCH.
*
*              SET UP ARGUMENTS - R0, R1, AND R3
*
         DROP  R0,R1,R3            DROP ADDRESSABILITIES.
         L     R3,0(,R2)           R3 = KEY, SUBPOOL, TYPE.
         LTR   R3,R3               SET CC=1 IF R0 ALREADY SET.
         LA    R3,0(,R3)           ZERO OUR FLAG BYTE IN R3.
         BM    *+8                 SKIP IF R0 IS ALREADY SET.
         L     R0,4(,R2)           R0 = LENGTH.
* R1 IS ALWAYS SET IN MACRO-EXPANSION.
         CLI   1(R2),X'F0'         ARE WE TO USE TCBPKF AS KEY...
         BNE   HGFB201             NO                          @OZ43706
         ICM   R3,15,PSATOLD-PSA   GET CURRENT TCB             @OZ43706
         BNZ   HGFB203             BR IF IN TCB MODE           @OZ43706
*        GET TCB FROM INPUT RQE IF UNDER SRB FOR CHAN-END      @OZ43706
         L     R3,4(R13)           GET RQE ADDR FROM INPUT     @OZ43706
*              THIS LINE DELETED BY APAR NUMBER                @OZ43706
         L     R3,RQETCB-RQE(R3)   GET TCB FROM RQE            @OZ43706
*              THIS LINE DELETED BY APAR NUMBER                @OZ43706
*              THIS LINE DELETED BY APAR NUMBER                @OZ43706
HGFB203  EQU   *                                               @OZ43706
         LR    R15,R3              PUT TCB ADDRESS IN R15      @OZ43706
         L     R3,0(,R2)           RESTORE PARM                @OZ43706
         LA    R3,0(,R3)           CLEAR HIGH BYTE             @OZ43706
         USING TCB,R15             USE TCB DSECT,
         ICM   R3,4,TCBPKF         AND PICK UP CURRENT KEY.
         DROP  R15                 DROP TCB ADDRESSABILITY.
*
*              CALL CRBRANCH
*
HGFB201  EQU   *                                               @OZ43706
         LR    R15,R14             R15 POINTS TO CRBRANCH.
         BALR  R14,R15             CALL VIRT STORAGE SUPERVISOR.
         USING *,R3                USE R3 AS LOCAL BASE.
         LR    R3,R14              SET R3 FROM R14 FOR BASE.
*
*              IF BUFFER GETMAIN, INITIALIZE THE
*              FOLLOWING FIELDS ---
*                  BFID   TO C'XBF '
*                  BFLENG TO CONTENTS OF R0
*                  BFTCB  TO CONTENTS OF R4
*                  BFASCB TO CONTENTS OF R7
*                  ALL OTHER FIELDS TO X'00'
*
         LTR   R15,R15             WAS CRBRANCH SUCCESSFUL...
         BNZ   HGFB30              BRANCH IF NOT.
         TM    0(R2),X'20'         WAS THIS A GETMAIN...
         BZ    HGFB30              BRANCH IF NOT.
         ST    R4,0(,R1)           RETURN TCB ADDRESS TO CALLER.
         STH   R0,4(,R1)           RETURN AREA LENGTH TO CALLER.     R4
         TM    0(R2),X'40'         WAS GETMAIN FOR BUFFER...
         BZ    HGFB30              BRANCH IF NOT.
         USING BFD,R1              USE THE BUFFER DSECT.
         XC    0(BFIO-BFD,R1),0(R1)  CLEAR BUFFER UP TO BFIO.
         MVC   BFID,=CL4'XBF'      SET BUFFER IDENTIFIER.
         STH   R0,BFLENG           SET BUFFER LENGTH.
         ST    R4,BFTCB            SET TCB ADDRESS IN BUFFER.
HGFB30   DS    0H                  CONTINUE.
*
*              TEST LOCAL LOCK CONDITION UPON ENTRY
*
         L     R0,=X'0F000000'     DID SETLOCK AT HGF010
         NR    R0,R2               RETURN NONZERO CODE...
         BNZ   HGF030              IF SO, DON'T RELEASE LOCAL LOCK.
*
*              SAVE REGISTERS PREPARATORY TO SETLOCK
*
         LR    R0,R11              SAVE REGISTER 11 IN REGISTER 0.
         LR    R4,R12              SAVE REGISTER 12 IN REGISTER 4.
         LR    R7,R13              SAVE REGISTER 13 IN REGISTER 7.
         LR    R3,R15              SAVE REGISTER 15 IN REGISTER 3.
*
*              RELEASE LOCAL LOCK
*
HGF020   SETLOCK RELEASE,TYPE=LOCAL,RELATED=HGF010
*
*              RESTORE REGISTERS AFTER SETLOCK
*
         LR    R11,R0              RESTORE REGISTER 11 FROM REGISTER 0.
         LR    R12,R4              RESTORE REGISTER 12 FROM REGISTER 4.
         LR    R13,R7              RESTORE REGISTER 13 FROM REGISTER 7.
         LR    R15,R3              RESTORE REGISTER 15 FROM REG 3.
*
*              RESTORE ORIGINAL PROTECT KEY
*
HGF030   DS    0H
         BALR  R3,0                RE-ESTABLISH                      R4
         USING *,R3                 LOCAL BASE                       R4
         LR    R4,R2               RESTORE CALLER'S LINK REGISTER.
         SRL   R2,24               SET KEY IN R2 BITS 24-27.
         MODESET KEYADDR=(2)       RESTORE ORIGINAL PROTECT KEY.
*
*              RETURN TO CALLER WITH CODE IN REGISTER 15
*
         TM    0(R4),X'80'         SET CC=3 IF LENGTH IN R0.
         LA    R4,4(,R4)           BUMP RETURN PAST R3 PARAMETER.
         BO    *+8                 SKIP IF NO ASSEMBLED LENGTH.
         LA    R4,4(,R4)           BUMP RETURN PAST R0 PARAMETER.
         LTR   R15,R15             SET CONDITION CODE
         BR    R4                  AND RETURN TO CALLER.
         DROP  R1,R3               DROP DSECT, BASE.
         SPACE 3
         LTORG
         TITLE     'IEFUJV - GETMAINED WORKAREA'
WORKAREA DSECT
***********************************************************************
*
*        WORKAREA FOR IEFUJV
*
***********************************************************************
SAVEAREA DS        18F            SAVEAREA MUST BE FISRT AREA IN G/M
SAVEPK   DC        A(0)
***********************************************************************
*
*        ERROR ROUTINE SNAP DISPLAY WORK AREA
*
***********************************************************************
EYECATCH DS        D              EYE-CATCHER
SNAPREGS DS        16F
SNAPLIST EQU       *
SNAPSTR1 DS        A
SNAPEND1 DS        A
SNAPSTR2 DS        A
SNAPEND2 DS        A
SNAPSTR3 DS        A
SNAPEND3 DS        A
SNAPSTR4 DS        A
SNAPEND4 DS        A
SNAPSTR5 DS        A
SNAPEND5 DS        A
SNAPSTR6 DS        A
SNAPEND6 DS        A
SNAPSTR7 DS        A
SNAPEND7 DS        A
SNAPSTR8 DS        A
SNAPEND8 DS        A
SNAPSTR9 DS        A
SNAPEND9 DS        A
SNAPDCB  DCB       DSORG=PS,RECFM=VBA,MACRF=(W),BLKSIZE=882,           X
               LRECL=125,DDNAME=SNAPDUMP
SNAPDCBL EQU       *-SNAPDCB
SNAPMACR SNAP      MF=L
SNAPMACL EQU       *-SNAPMACR
OPENLIST OPEN      (,(OUTPUT)),MF=L
CLOSLIST CLOSE     (,),MF=L
PACKWK1  DS        D              WORK AREA FOR PACK INSTR
PACKWK   DS        D              WORK AREA FOR PACK INSTR
PARMSW   DS        CL1            OVER-ALL SYSTEM INDICATORS
EOFSW    EQU       1              END-OF-FILE ON INTERNAL TEXT FILE
JOBFAIL  EQU       2              JOB PREVIOUSLY FAILED BY CONVERTER
JOBPASS  EQU       4              JOB ALLOWED THRU UNCONDITIONALLY
DIAGFLAG EQU       8              DIAGNOSTIC ROUTINES ARE TO BE USED
ERRSW    DS        CL1            ERROR INDICATOR SWITCHES
ERINITRT EQU       1              ERROR IN INITIALIZATION RTN
ERREADRT EQU       2              ERROR IN INTERNAL TEXT READ RTN
ERJOBRT  EQU       4              ERROR IN JOB STMT PROCESSING RTN
EREXECRT EQU       8              ERROR IN 'EXEC' STMT PROCESSING RTN
ERPROCRT EQU       16             ERROR IN 'PROC' STMT PROCESSING RTN
ERDDRT   EQU       32             ERROR IN DD STATEMENT RTN
ERLKUPRT EQU       64             ERROR IN 'CLASS KLOOKUP' RTN
EREXSMRT EQU       128            ERROR IN 'EXEC' SUMMARIZATION RTN
KEYVALUE DS        CL1            AREA FOR CONVERTING KEY VALUE TO WTG
ENDSTRNG DS        A              ADDR OF END OF CURRENT STRING
CMDLGTH  DS        F              LENGTH FIELD FOR JES COMMAND
CMDAREA  DS        CL80
JBNELTIM DS        F              DEFAULT JOB STEP TIME, IN SECONDS
         TITLE     'IEFUJV - WORKAREAS FOR VARIOUS STMT PROCESSORS'
***********************************************************************
*
*        WORK AREA FOR JOB STATEMENT STRING PROCESSOR
*
***********************************************************************
JBNAME   DS        CL8            JOBNAME
JBRSTPRC DS        CL8            STEP RESTORT PROC NAME
JBRSTSTP DS        CL8            STEP RESTART STEP NAME
JBCLSVAL DS        CL1            JOB CLASS VALUE FROM USER JOB CARD
JBCLASS  DS        CL1            JOB CLASS ASSG'D BY EXIT
JBPGMRNM DS        CL20           PROGRAMMER NAME (FROM JCT)
JBSPCEND EQU       *
JBACCT1 DS         CL30           ACCTING DATA / LENGTH IN 1ST BYTE
JBACCT2 DS         CL30           ACCTING DATA / LENGTH IN 1ST BYTE
JBMINS   DS        H              MINUTES OF TCB TIME PERMITTED
JBSECS   DS        H              SECONDS OF TCB TIME PERMITTED
JBTIME   DS        F              TOTAL SECS OF TCB TIME PERMITTED
JBPGN    DS        H              PERFORMANCE GROUP #
JBREGION DS        H              REGION FROM JOB CARD(USER-SPECIFIED)
JBNELREG DS        H              DEFAULT READER-ASSIGNED REGION
JBPRTY   DS        H              PRIORITY REQUESTED
JBLINES  DS        H              1,000'S OF PRINT LINES (EST)
JBHASP#  DS        CL5            PUT # IN HERE LEFT-JUSTIFIED
JBHASP   DS        CL4            JES-ASSG'D # - RIGHT-JUSTIFIED
JBUSCFLG DS        XL1            USER CODE FLAG FIELD
JBRTCFLG DS        XL1            RUN TYPE CODE FLAG FIELD
JBAPCFLG DS        XL1            APPL CODE FLAG FIELD
JBSW     DS        X              SWITCHES
JBVEQR   EQU       X'01'          V=R SPECIFIED
JBPERFM EQU        X'02'          PERFORM= SPECIFIED IN JOB STATMENT
JBHOLDRQ EQU       X'04'          'TYPRUN=HOLD' REQUESTED
JBTIMEQ  EQU       X'10'          'TIME=' STMT SPECIFIED ON JOB CARD
JBINVACT EQU       X'20'          INVALID ACCOUNTING SWITCH
JBACTWRK DS        CL11           WORK AREA FOR ACCTING PROCESSOR
JBACTADR DS        A              ADDR OF ACCTING AREA ANCHORED IN CSA
JBRETURN DS        F              RETURN CODE FROM IEFUJV
JBCLSPTR DS        A              PTR TO CLASS TABLE ENTRY FOR CURR JOB
JOBJCT   DS        A              POINTER TO THIS JOB'S JCT
JOBSJB   DS        A              POINTER TO THIS JOB'S SJB
         SPACE     3
***********************************************************************
*
*        EXECUTE/PROC STATEMENT PROCESSOR WORKAREA
*        (NOT CURRENTLY USED)
*
***********************************************************************
PCREGBEG DS        A              BEGINNING ADDR OF TABLE
PCREGNXT DS        A              PTR TO NEXT AVAIL SLOT (IF ANY)
PCREGLTH DS        A              LENGTH OF AN ENTRY
PCREGMAX DS        A              ADDR OF TABLE END
PCREGLC  DS        A              LENGTH CODE FOR COMPARAND
PCREGEND EQU       *              ADDR OF TABLE END
PCREGOV  DC        CL8'        ',H'0' 'REGION=' OVERRIDE
         DC        CL8'        ',H'0'
PCREG1ST EQU       *              ADDR OF TABLE BEGIN
PCREGSIZ EQU       10             SIZE OF ONE ENTRY
PCREGCMP EQU       7              LENGTH CODE FOR COMPARE
         SPACE     1
PCTIMBEG DS        A              ADDR OF END OF TABLE
PCTIMNXT DS        A              ADDR OF NEXT AVAIL SLOT (IF AN)
PCTIMLTH DS        A              LENGTH OF ONE ENTRY
PCTIMMAX DS        A              ADDR OF END OF TABLE
PCTIMLC  DS        A              LENGTH CODE FOR COMPARAND
PCTIMEND EQU       *              ADDR OF TABLE END
PCTIMOV  DC        CL8'        ',H'0' 'TIME=' OVERRRIDE
         DC        CL8'        ',H'0'
PCTIM1ST EQU       *              ADDR OF TABLE BEGIN
PCTIMSIZ EQU       10             SIZE OF ONE ENTRY
PCTIMCMP EQU       7              LENGTH CODE FOR COMPARE
         SPACE     1
PCPFMBEG DS        A              ADDR OF BEG. OF TABLE
PCPFMNXT DS        A              ADDR OF NEXT AVAIL SLOT (IF AN)
PCPFMLTH DS        A              LENGTH OF ONE ENTRY
PCPFMMAX DS        A              ADDR OF END OF TABLE
PCPFMLC  DS        A              LENGTH CODE FOR COMPARAND
PCPFMEND EQU       *              ADDR OF END OF TABLE
PCPFMOV DC         CL8'        ',H'0' 'PERFORM=' STACK
         DC        CL8'        ',H'0'
PCPFM1ST EQU       *              ADDR OF BEG. OF TABLE
PCPFMSIZ EQU       10             SIZE OF ONE ENTRY
PCPFMCMP EQU   7   LENGTH CODE FOR COMPARE
         SPACE     1
PCADSBEG DS        A              ADDR OF BEG. OF TABLE
PCADSNXT DS        A              ADDR OF NEXT AVAIL. SLOT (IF ANY)
PCADSLTH DS        A              LENGTH OF ONE ENTRY
PCADSMAX DS        A              ADDR OF END OF TABLE
PCADSLC  DS        A              LENGTH CODE FOR COMPARAND
PCADSEND EQU       *
PCADSOV DC         CL8'        ',X'00' 'ADDRSP=' OVERRIDE STACK
PCADSRL  EQU       X'01'          IF FLAG = 1; V=R
         DC        CL8'        ',X'00'
         DC        CL8'        ',X'00'
PCADS1ST EQU       *
PCADSSIZ EQU       9              SIZE OF ONE ENTRY
PCADSCMP EQU       7              LENGTH CODE FOR COMPARE
         SPACE     3
***********************************************************************
*
*        EXEC STATEMENT PROCESSOR WORKAREA
*
***********************************************************************
EXNAME   DS        CL8            STEPNAME
EXPGMNAM DS        CL9            PROGRAM NAME (INCL LENGTH CODE)
EXREGION DS        H              REGION SIZE (MAX)
EXMINS   DS        H              MINUTES OF EXEC TIME
EXSECS   DS        H              EXEC TIME IN SECONDS
EXTIME   DS        F              TIME, IN SECONDS , FOR STEP
EXPFM    DS        H              PERFORMANCE GROUP #
EXADRSW DS         X              ADDRSPACE TYPE SWITCH
EXADRRL EQU        X'01'          IF FLAGE = 1; V = R
EXEND    EQU       *
         SPACE     3
***********************************************************************
*
*        JOB CPU AFFINITY FACILITY WORKAREA
*
***********************************************************************
AFFMASK  DS        X              MASK SAME AS JQEFLAG2 FIELD
AFFWTO1  WTO       'IEFUJV-27-I - XXXXXXXX HAS CPU AFFINITY RESTRICTION*
               S',ROUTCDE=2,DESC=6,MF=L
AFFWTO1L EQU       *-AFFWTO1      LENGTH OF WTO
         SPACE     3
***********************************************************************
*
*        UNIT AFFINITY TABLE
*
***********************************************************************
UNAFBEG  DS        A              BEGINNING ADDR OF STACK
UNAFNXT  DS        A              ADDR OF NEXT AVAIL SLOT IN STACK
UNAFLGTH DS        A              LENGTH OF ONE STACK ELEMENT
UNAFMAX  DS        A              ADDR OF LAST ELEM. IN STACK
UNAFLC   DS        A              LENGTH CODE FOR COMPARAND
UNAFEND  EQU       *
UNAFNAME DS        CL8
UNAFUTYP DS        CL4
         DS        40CL12
UNAF1ST  EQU       *
UNAFSIZ  EQU       12
UNAFCMP  EQU       7              LENGTH CODE FOR COMPARAND
         SPACE     2
         SPACE     3
***********************************************************************
*
*        PASSED DATA SET ENTRY LIST
*
***********************************************************************
PSDSBEG  DS        A              ADDR OF BEG. OF TABLE
PSDSNXT  DS        A              ADDR OF NEXT AVAIL SLOT (IF ANY)
PSDSLGTH DS        A              LENGTH OF ONE ENTRY (NEG. ENTRY)
PSDSMAX  DS        A              ADDR OF END OF TABLE
PSDSLC   DS        A              LENGTH CODE FOR COMPARAND
PSDSEND  EQU       *
PSDSN    DS        CL44
PSUCBTYP DS        XL4
PSTRKS   DS        F
         ORG       PSTRKS
PSREFBAK DS        CL4
         DS      15CL52
PSDS1ST  EQU       *
PSDSSIZE EQU       52             SIZE OF ONE ENTRY
PSDSCMP  EQU       43             LENGTH CODE FOR COMPARE
         TITLE     'IEFUJV - DD STATMENT PROCESSOR WORK AREA'
***********************************************************************
*
*        WORKAREA FOR DD STATEMENT PROCESSOR
*
***********************************************************************
DDBEGIN  EQU       *
DDUNITYP DS        XL4            UCBTYPE FOR THIS DD
DDUNITFG DS        XL1            UNIT= ALLOC FLAGS
DDUNITPM EQU       1              PARALLEL MOUNTING REQ
DDDEVCNT DS        H              # OF PARALLEL DEVICES REQ
DDISP    DS        XL1            'DISP=' FLAGS
DDISPNEW EQU       1              DISP=(NEW,....
DDISPOLD EQU       2              DISP=(OLD,....)
DDISPMOD EQU       4              DISP=(MOD,....
DDISPSHR EQU       8              DISP=(SHR,....)
DDISPDEL EQU       16             DISP=(,DELETE,.....)
DDISPKEP EQU       32             DISP=(,KEEP,....)
DDISPASS EQU       64             DISP=(,PASS,....
DDSPCUNT DS        XL1            UNITS OF ALLOC FOR SPACE
DDSPCCYL EQU       1              SPACE=(CYL,....
DDSPCTRK EQU       2              SPACE=(TRK,....
DDSPCABS EQU       4              SPACE=(ABSTR,....
DDSPCBLK EQU       8              SPACE=(AVEBLK,....
DDSPCAVE DS        H              AVE BLK LENGTH FOR AVE BLK ALLOC
DDSPCPRI DS        H              # OF UNITS IN PRIMARY SPACE ALLOC
DDSPCSEC DS        H              # OF UNITS IN SEC SPACE ALLOC
DDSPC1KB DS        F              # OF 1,000-BYTE BLOCKS
DDVOLCNT DS        H              # OF MOUNTABLE OBJECTS
DDREFCNT DS        H              # OF ITEMS IN *.REF KEYWORD
DDDSORG  DS        XL1            'DSORG=' FLAGS
DDDSRGIS EQU       128            DSORG=IS
DDDSRGPS EQU       64             DSORG=PS
DDDSRGDA EQU       32             DSORG=DA
DDDSRGCX EQU       16             BTAM/QTAM LINE GROUP & UNIDENT
DDDSRGPO EQU       2
DDDSRGU  EQU       1              UNMOVEABLE
DDEND    EQU       *
DDEXPDT  DS        PL3            STORAGE AREA FOR EXPDT= VALUE
DDRETPD  DS        PL3            STORAGE AREA FOR RETPD= VALUE
DDBLNKST EQU       *              ADDR TO START BLANKING OPER
DDVOLIST DS        20CL6          VOLSERS OF TAPE VOLUMES
DDVOLSIZ EQU       20             # OF PERMISSABLE ENTRIES IN ABLE
DDAFFNAM DS        CL8            DDNAME WITH WHICH WE HAVE AFF.
DDREF    DS        CL29           REFERBACK VOLSER FORMAT
DDDSNAME DS        CL44           EXPLICIT DSN
DDMEMNAM DS        CL8            MEMBER/INDEX NAME
DDDDNAME DS        CL8            DDNAME (IF ANY))
DDBLNKED EQU       *              ADDR TO STOP BLANKING OPER.
DDREGSAV DS        8F             TEMP SAVE AREA FOR REGS USED BY PROC
         DS        0D
DDCAMDSN DS        CL44           DSNAME WORK AREA FOR CAMLST MACRO
         DS        0D
DDCAMLST EQU       *              'CAMLST' : 'NAME,DDDSNAME,,DDCAMWRK'
         DS        AL1            OPTION BYTES: 68:0:0:0
         DS        AL1
         DS        AL1
         DS        AL1
         DS        A              ADDR OF DSNAME
         DS        A              MAKE THIS ZEROS
         DS        A              ADDR OF CAMLIST WORK AREA
         DS        0D             BOUNDARY ALING
DDCAMWRK DS        CL265          WORK AREA FOR CAMLIST PROCESSOR
DDGLBSTR DS        0F             BEGINNING ADDR OF STEP-LEVEL STATS
DDSPCREG DS        F              # OF NON-VIO 1,000-BYTE BLOCKS
DDSPCVIO DS        F                         # OF VIO 1,000-BYTE BLOCK
DDTA6250 DS        H              # OF 6250-BPI TAPE DRIVES
DDTA1600 DS        H              # OF 800/1600 BPI TAPE DRIVES
DDDUACNT DS        H              DIRECT UNIT ASSIGNMENT CNT
DDTELCM  DS        H              TELECOMM. GEAR COUNT
DDURCNT  DS        H              UNIT RECORD DEVICE ALLOC CNT
DDGLBEND EQU       *              ENDING ADDR OF STEP-LEVEL STATS
         SPACE     3
***********************************************************************
*
*        EXEC STMT STATISTICS TABLE
*
***********************************************************************
EHTIME   DS        A              MAX TIME, ANY STEP - IN SECS
EHREGION DS        H              MAX REGION, IN K
EHPFM#   DS        H              MAX PERF. GRP #
EHSW     DS        XL1            EXEC STMT OPTION SWITCHES
EHASREAL EQU       X'01'          VIRT=REAL WAS SPECIFIED
EHPERFM  EQU       X'02'          'PERFORM=' WAS SPECIFIED
         SPACE 3
***********************************************************************
*
*        DD STMT STATISTICS TABLE
*
***********************************************************************
DHSPCREG DS        F              # OF NON-VIO 1,000-BYTE BLOCKS OF DA
DHSPCVIO DS        F              # OF VIO 1,000-BYTE BLOCKS
DHTA6250 DS        H              HIGHEST # OF 6250-BPI DRIVES/STEP
DHTA1600 DS        H              HIGHEST # OF 800/1600 BPI DRIVES/STEP
DHSCRCNT DS        H              # OF SCRATCH TAPES USED BY JOB
DHDUACNT DS        H              HIGHEST # OF DIRECT UNIT ASSIGNS/STEP
DHTELCM  DS        H              HIGHEST # OF TELECOMM UNITS/STEP
DHURCNT  DS        H              HIGHEST # OF U/R UNITS / STEP
         TITLE     'IEFUJV - MASTER VOLSER TABLE, BY VOLSER'
***********************************************************************
*
*        MASTER TAPE VOLSER TABLE - ORDERED BY VOLSER
*
***********************************************************************
DHVOLTAB DS        0F
DHMAXVOL EQU       30
DHVOLPRM DS        CL(TABENTRY-TABLE) AREA FOR TABLE MGMT DATA
DHVOLSER DS        CL6            AREA FOR VOLSER NAMES
DHVOLCNT DS        H              COUNT OF # OF TIMES THIS VOL OCCURRED
DHVOLBT  EQU       *
         DS        (DHMAXVOL*(DHVOLBT-DHVOLSER))C SPACE FOR VOLSERS
DHVOLEND EQU       *
         TITLE     'IEFUJV - PICKING TICKET FORMATTING AREA'
         DS        0D             FORCE BOUND. ALIGN
PICKTICK EQU       *
***********************************************************************
*
*        PICKING TICKET FORMATTING AREA
*
***********************************************************************
PTL1LGTH DS        AL2            1ST LINE TEXT LENGTH
PTMCSFLG DS        XL2            MCS FLAGS (=X'8040')
PTL1TEXT DS        CL70           1ST LINE TEXT
PTDESCOD DS        XL2            DESC. CODES (=X'0400')
PTROUTCD DS        XL2            ROUT CODES (=X'0002')
PTL1TYPE DS        XL2            1ST LINE LINE TYPE (=X'2000')
         DS        XL1            RESERVED
PT#LINES DS        AL1            TOTAL # OF LINES (=AL1(10))
PTL2LGTH DS        AL2            2ND LINE TEXT LENGTH
PTL2TYPE DS        XL2            2ND LINE LINE TYPE (=X'2000')
PTL2TEXT DS        CL70           2ND LINE TEXT
PTL3LGTH DS        AL2            3RK LINE TEXT LENGTH
PTL3TYPE DS        XL2            3RD LINE LINE TYPE =X'2000'
PTL3TEXT DS        XL70           3RD LINE TEXT
PTL4LGTH DS        AL2            4TH LINE TEXT LENGTH
PTL4TYPE DS        XL2            4TH LINE LINE TYPE =X'2000'
PTL4TEXT DS        CL70           4TH LINE TEXT
PTL5LGTH DS        AL2            5TH LINE TEXT LENGTH
PTL5TYPE DS        XL2            5TH LINE LINE TYPE =X'2000'
PTL5TEXT DS        CL70           5TH LINE TEXT
PTL6LGTH DS        AL2            6TH LINE TEXT LENGTH
PTL6TYPE DS        XL2            6TH LINE LINE TYPE =X'20000'
PTL6TEXT DS        CL70           6TH LINE TEXT
         DS        (2*(PTL3LGTH-PTL2LGTH))C
PTL9LGTH DS        AL2            9TH LINE TEXT LENGTH
PTL9TYPE DS        CL2            9TH LINE LINE TYPE
PTL9TEXT DS        CL70           9TH LINE TEXT
PTLALGTH DS        AL2            10TH LINE TEXT LENGTH
PTLATYPE DS        XL2            10TH LINE LINE TYPE =X'3000'
PTLATEXT DS        CL70           10TH LINE TEXT
PTEND    EQU       *
WORKLGTH EQU       (((*-WORKAREA+7)/8)*8)
         END
