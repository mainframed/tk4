         TABLE
         TITLE     'REQUEUER - RESOURCE CNTL RECORD LAYOUT'
         RCRECORD
         TITLE     'REQUEUER - DATA CONTROL BLOCK (DCB)'
         DCBD      DSORG=DA,DEVD=DA
         TITLE     'REQUEUER - DATA EVENT CONTROL BLOCK (DECB)'
         IHADECB
         TITLE     'REQUEUER - COMMUNICATIONS VECTOR TABLE (CVT)'
         CVT
         AIF       ('&SYSPARM' EQ 'NONSE' OR '&SYSPARM' EQ 'SE2' OR    *
               '&SYSPARM' EQ 'SP10' OR '&SYSPARM' EQ 'SP11').PRESP3A
         AIF       ('&SYSPARM' EQ 'SP12' OR '&SYSPARM' EQ 'SP13').SP3A
         MNOTE     12,'REQUEUER - INVALID VALUE IN SYSPARM FIELD'
         AGO       .RESUMEA
.SP3A    ANOP
         TITLE     'REQUEUER - RESOURCE INFORMATION BLOCK(RIB)'
         ISGRIB
         AGO       .RESUMEA
.PRESP3A ANOP
         TITLE     'REQUEUER - QUEUE CONTROL BLOCK(QCB)'
         IHAQCB
.RESUMEA ANOP
         TITLE     'REQUEUER - TASK CONTROL BLOCK (TCB)'
         IKJTCB
         TITLE     'REQUEUER - JOB STEP CONTROL BLOCK (JSCB)'
         IEZJSCB
         TITLE     'REQUEUER - SYSTEM MGMT COMM AREA (SMCA)'
         IEESMCA
         TITLE     'REQUEUER - COMMAND INPUT BUFFER (CIB)'
CIB      DSECT
         IEZCIB
         TITLE     'REQUEUER - JES CONTROL TABLE (JESCT)'
         IEFJESCT
         TITLE     'REQUEUER - SUBSYSTEM OPTIONS BLOCK (SSOB)'
         IEFJSSOB  (CS)
         TITLE     'REQUEUER - CROSS-MEMORY COMMUNICATIONS AREA'
         CROSSMEM
         TITLE     'REQUEUER - TASK CSA ANCHOR POINTER'
         RNMANCHR
         TITLE     'REQUEUER - PROGRAM WORK AREA'
WORKAREA DSECT
**********************************************************************
*
*        PROGRAM WORK AREA
*
**********************************************************************
SAVEAREA DS        18F            PROGRAM SAVE AREA
ERRSAVE  DS        16F            HOLD AREA FOR REGS IN ERR RTN
FLUPREGS DS        4F             HOLD AREA FOR DIAGNOSTICS
ERRORSW  DS        XL1            ERROR INDICATOR(S)
ERRINIT  EQU   X'01'              ERROR IN INITIALIZATION RTN
ERRFILUP EQU   X'02'              ERROR IN FILE UPDATE RTN
ERRCMD   EQU   X'04'              ERROR IN COMMAND PROCESSOR RTN
ERRTERM  EQU   X'08'              ERROR IN TERMINATION RTN
ERRIO    EQU   X'10'              I/O ERROR ON RES. CNTL FILE
SNAPDUMP DCB       DDNAME=SNAPDUMP,MACRF=(W),LRECL=125,                X
               BLKSIZE=882,RECFM=VBA,DSORG=PS
SNAPMACR SNAP  DCB=0,LIST=0,MF=L
SNAPLIST DS        0F             STRING OF ADDR'S TO BE SNAPPED
SNAPSTR1 DS        A
SNAPEND1 DS        A
SNAPSTR2 DS        A
SNAPEND2 DS        A
SNAPSTR3 DS        A              COMMAND PARM LIST
SNAPEND3 DS        A
SNAPSTR4 DS        A
SNAPEND4 DS        A
TIMEWAIT DS        A              FIELD USED BY 'TIME=XX' COMMAND
MAINFLAG DS        XL1            SWITCHES USED BY MAIN RTN
SHUTDOWN EQU   X'08'              THIS TASK IS IN TERMINATION
ECBTABLE DS        0F             ECB LIST USED BY 'WAIT' MACRO
ECBCRME  DS        A              ADDR OF CROSS-MEM ECB
ECBENQA  DS        A              ADDR OF ECB USED BY ENQ
ECBCMDA  DS        A              ADDR OF CIRB ECB
ECBENQ   DS        A              'ENQ ECB=' ECB
LOOPCNT  DS        A              LOOP COUNTER
         READ      RESDECB,DI,,'S','S',0,0,MF=L
HOLDJES# DS        H              HOLD AREA FOR JES JOB #
HOLDHDSN DS        A              HOLD AREA FOR HASH-CODED DSN VALUE
WRKKEY   DS        0D,0CL(RCRKEYL) BUILD-AREA FOR NEW ELEMENT
WRKHDSN  DS        F              HASH-CODED DSNAME
WRKPRTY  DS        H  2'S COMPLEMENT OF JOB SEL. PRTY
WRKDATE  DS        PL4            READER START DATE
WRKTIME  DS        BL4            READER START TIME
WRKJES#  DS        H              JES JOB #
WRKJOBNM DS        CL8            JOBNAME
COMMAPTR DS        A              ADDR OF PTR TO CIRB
CMDWORK  DS        0CL84          WORK AREA FOR COMMAND PROCESSOR
CMDLGTH  DS        H              LENGTH OF COMMAND AREA
         DS        H              (RESERVED)
CMDAREA  DS        CL80           AREA FOR COMMAND TEXT
EXTRLIST EXTRACT   0,FIELDS=COMM,MF=L
ENQQNAME DS        CL8            QNAME
ENQRNAME DS        CL8            RNAME
ENQHOLD  DS        CL8
ENQMACRO ENQ       (,,E,8,SYSTEM),ECB=0,MF=L
         AIF       ('&SYSPARM' EQ 'NONSE' OR '&SYSPARM' EQ 'SE2' OR    *
               '&SYSPARM' EQ 'SP10' OR '&SYSPARM' EQ 'SP11').RESUMEB
RIBADDR  DS        A
ENQGQSCN GQSCAN    AREA=(),                                            *
               SCOPE=LOCAL,                                            *
               RESNAME=(),                                             *
               MF=L
.RESUMEB ANOP
POSTMAC  POST      0,,ASCB=0,ERRET=0,MF=L
REGSAVE  DS        7A             HOLD AREA FOR REGS
OPENLIST DS        A
CLOSLIST DS        A
SSOBADDR DS        A              ADDR OF SSOB PARM LIST
DOUBLE   DS        D              WORK AREA
SSOBAREA DS        CL(SSOBLEN2)
RESFILE  DCB       DDNAME=RESFILE,MACRF=(RISC,WIC),OPTCD=R,            X
               DSORG=DA
RESBLKAD DS        A
WORKEND  EQU       *
WORKLGTH EQU       (((*-WORKAREA+7)/8)*8)
         TITLE     'REQUEUER - MAIN PROGRAM'
REQUEUER CSECT
**********************************************************************
*
*        PROGRAM: REQUEUER TASK
*        DATE WRITTEN: JANUARY 1980.
*        AUTHOR: D. HALBIG
*        INSTALLATION: U.S. SENATE COMPUTER CENTER
*        FUNCTION:
*              THIS PROGRAM, WHICH IS TO EXECUTE AS A CONTINUOUSLY-
*              RUNNING SYSTEM TASK, IS DESIGNED TO KEEP TRACK OF
*              BATCH JOBS INVOLVED IN DATA SET CONTENTION
*              CONFLICTS.  COMMUNICATION BETWEEN THIS ROUTINE'S
*              ADDRESS SPACE AND THOSE OF RESOURCE HOLDERS AND
*              REQUESTORS IS VIA AN AREA IN THE CSA.  THE AREA IS
*              GETMAINED BY THIS ROUTINE.  THE ADDRESS OF THIS AREA
*              IS MADE AVAILABLE
*              TO ALL OTHER ADDRESS SPACES BY PUTTING IT IN A LIST
*              WITH A UNIQUE IDENTIFIER (SMFID) AND USING THE LIST AS
*              AN RNAME IN AN ENQ REQUEST.  TO FORCE SERIALIZATION OF
*              ACCESS AGAINST THE RESOURCE CONTROL FILE, A SEPARATE
*              ENQ/DEQ IS DONE EACH TIME THE FILE IS TO BE ACCESSED/
*              UPDATED.  THE QNAME/RNAME IS 'REQUEUER'/'RESOURCE'.
*              THIS ROUTINE USES THIS QNAME/RNAME COMBINATION FOR:
*                  . INITIALIZATION;
*                  . TERMINATION;
*                  . CONSOLE COMMAND PROCESSING, AS WITH A MODIFY OR
*                    STOP COMMAND.
*              IN STEADY-STATE, THIS ROUTINE 'WAITS' ON 2 ECB'S:
*                  . COMMAND INPUT BUFFER ECB;
*                  . ECB USED BY OTHER ADDRESS SPACES(IEFUJI/IEFACTRT)
*                    TO WAKE UP THE REQUEUER TASK VIA X-MEMORY POST;
*              THE ECB USED BY THE SMF EXITS IS MAINTAINED
*              IN THE CSA WORK AREA MENTIONED EARLIER.  THIS SAME AREA
*              CONTAINS AN ECB WHICH THE OTHER ADDRESS SPACES(IEFUJI/
*              IEFACTRT) CAN USE TO 'WAIT' ON UNTIL THE
*              REQUEUER TASK FINISHES THEIR REQUEST.
*              SEVERAL EXAMPLES MAY CLARIFY THIS:
*              ASSUME A JOB ATTEMPTS TO INITIATE & ENCOUNTERS A DSNAME
*              ENQ CONFLICT.  IEFUJI FOR THAT JOB WILL HAVE ALREADY
*              ENQ'ED ON 'REQUEUER'/'RESOURCE' TO ENSURE THE RESOURCE
*              CONTROL FILE CAN BE LOOKED AT/MODIFIED WITHOUT INTER-
*              FERENCE.  CHAINING THRU THE QCB'S (GQSCAN IN SP1.3)
*              IEFUJI THEN FINDS
*              THE ANCHOR FOR THE REQUEUER-TASK-PROVIDED
*              COMMUNICATIONS AREA IN THE CSA.  AFTER LOADING PARMS
*              INTO THIS AREA, IEFUJI ISSUES A CROSS-MEMORY POST TO
*              'WAKE UP' THE REQUEUER TASK.  IEFUJI THEN WAITS ON YET
*              ANOTHER ECB IN THE ABOVE CSA UNTIL THE REQUEUER COM-
*              PLETES.  THE REQUEUER LOADS ITS REPLY INTO THE CSA
*              AND ISSUES A CROSS-MEMORY POST TO 'WAKE UP' IEFUJI.
*              COMMUNICATIONS BETWEEN THIS ROUTINE AND IEFACTRT
*              ARE HANDLED IN THE SAME MANNER.  IEFACTRT IS USED
*              TO NOTIFY THE REQUEUER TASK OF A JOB COMPLETION - USED
*              WHEN THE JOB NOW COMPLETING IS A CONFLICTOR.
*
*              04/14/82(DGH) - MODIFICATIONS/ENHANCEMENTS:
*               . ADD SUPPORT FOR SP1.3 (MUST USE SYSPARM DURING ASSEM)
*               . ADD 'TIME=XX' FUNCTION VIA MODIFY COMMAND
*               . ADD 'FORMAT' OPTION AT STARTUP
*               . ADD INITIALIZATION/COMMAND PROCESSING/TERMINATION
*                 STATUS MESSAGES
*               . FIX MINOR BUGS
*
*        REGISTER                 USAGE
*              R15                ENTRY POINT ADDRESS/RETURN CODE
*              R14                RETURN ADDRESS/ERROR INDICATOR
*              R13                SAVE AREA/WORK AREA
*              R12                MAIN ROUTINE BASE REGISTER
*              R11                SECONDARY RTN RETURN REG
*              R10                SECONDARY RTN BASE REGISTER
*              R9                 ADDR OF CSA     WORK AREA
*              R8                 FUNCTION RETURN REGISTER
*              R7-R0              WORK REGISTERS
*
********************************************************************
         REGEQU
         SAVE      (14,12),,REQUEUER-&SYSDATE-&SYSTIME
         LR        R12,R15        ESTABLISH BASE REG.
         USING     REQUEUER,R12   TELL ASSEMBLER
         MODESET   KEY=ZERO,MODE=SUP   PK=0,SUPERVISOR STATE
         L         R0,GETPARMS    GET PARMS FOR GETMAIN
         GETMAIN   R,LV=(0)
         LR        R2,R1          ZERO OUT G/M AREA
         L         R3,GETPARMS
         SR        R4,R4
         SR        R5,R5
         MVCL      R2,R4
         ST        R1,8(,R13)     COMPLETE S/A CHAINING
         ST        R13,4(,R1)
         LR        R13,R1
         USING     WORKAREA,R13
         L         R11,=A(INITRTN) DO INITIALIZATION
         BALR      R10,R11
         TM        ERRORSW,ERRINIT ERROR IN INITIALIZATION?
         BO        ERRORTN        GO HANDLE ERROR
         TM        MAINFLAG,SHUTDOWN WAS SHUTDOWN SIGNALLED?
         BO        MAINEXIT       BIF YES
         USING     CROSSMEM,R9    FROM HERE ON, ALLOC CSA IS ADDRESSBLE
MAINWAIT EQU       *
**********************************************************************
*        THE 'WAIT'  MACRO BELOW WAITS ON ONE OF
*        TWO EVENTS:
*             1) SMF EXITS IEFUJI OR IEFACTRT HAVE 'POSTED' (VIA
*        CROSS-MEMORY POST) THE REQUEUER (ECB NAME 'CRMRQECB');
*             2) A CONSOLE COMMAND ISSUED (E.G.'MODIFY' OR 'STOP'
*        COMMAND).
*********************************************************************
         WAIT      1,ECBLIST=ECBTABLE
         L         R1,COMMAPTR    GET ADDR OF COMMND ECB/CIRB PTR
         L         R1,0(,R1)      GET ADDR OF COMMAND ECB
         TM        0(R1),X'40'      WAS CIRB ECB POSTED?
         BZ        MAINSMFX         BIF NOT; MUST HAVE BEEN SMF EXIT
***********************************************************************
*        FOR COMMANDS, ENQ ON RESOURCE NAME
***********************************************************************
         MVC       ENQQNAME,=C'REQUEUER' SET UP ENQ FOR RESOURCE
         MVC       ENQRNAME(8),=C'RESOURCE'
         OI        ENQMACRO,X'C0' SET END-OF-LIST
         MVI       ENQMACRO+2,X'44' SET OPTIONS TO ECB=&SCOPE=SYSTEMS
         XC        ECBENQ,ECBENQ      CLEAR ECB FOR RESOURCE WAIT
         ENQ       (ENQQNAME,ENQRNAME,E,8,SYSTEM),ECB=ECBENQ,          X
               MF=(E,ENQMACRO)
         LTR       R15,R15        DID WE GET RESOURCE?
         BZ        MAINCMDS       BIF YES; PROCESS COMMAND(S)
         LA        R1,10          SET LOOP COUNTER
         ST        R1,LOOPCNT
         SR        R1,R1          CLEAR R1
         IC        R1,ENQMACRO+3  GET RETURN CODE
         B         MAINWTG(R1)    USE RETURN CODE FOR WTG TABLE
MAINWTG  EQU       *
         BAL       R14,ERRORTN    RC=0; UNEXPECTED RC VALUE
         B         MAINPEND       RC=4; EXIT REQUEST ALREADY PENDING
         BAL       R14,ERRORTN    RC=8; ENQ ALREADY ISSUED/HAVE RESOURC
         BAL       R14,ERRORTN    RC=12; UNEXPECTED RC VALUE
         BAL       R14,ERRORTN    RC=16; UNEXPECTED RC VALUE
         BAL       R14,ERRORTN    RC=20; PREV. REQ PENDING & FAILED
*
MAINPEND EQU       *
         TM        CRMRQECB,X'40' IS DELAY FROM SMF EXIT IN THIS SYSTEM
         BZ        MAINHSEC       IF NOT, JUST WAIT HALF SECOND
         L         R11,=A(FILEUPDT) IF SO, PROCESS SMF EXIT INFO
         BALR      R10,R11
         TM        ERRORSW,ERRFILUP ERROR IN FILE UPDATE RTN?
         BO        ERRORTN        BIF YES; PROCESS ERROR
MAINHSEC EQU       *
         STIMER    WAIT,BINTVL=HALFSEC  WAIT 1/2 SECOND
         TM        ECBENQ,X'40'   DO WE HAVE THE RESOURCE YET?
         BO        MAINCMDS       BIF YES
         L         R1,LOOPCNT     WE'LL DO THIS 10 TIMES ONLY
         S         R1,=A(1)       DECREMENT BY 1
         ST        R1,LOOPCNT     STOW
         BP        MAINPEND       KEEP ON TRUCKIN'
         BAL       R14,ERRORTN    AFTER 10 ATTEMPTS, GIVE UP
*
MAINSMFX EQU       *              REQUEUER POSTED BY SMF EXIT
         L         R11,=A(FILEUPDT) GET ADDR OF FILE UPDATE RTN
         BALR      R10,R11        PERFORM IT
         TM        ERRORSW,ERRFILUP ERROR IN FILE UPDATE RTN
         BO        ERRORTN        BIF YES; PROCESS ERROR
         BZ        MAINWAIT        BRANCH BACK TO WAIT FOR MORE
MAINCMDS EQU       *
         L         R11,=A(CMDRTN) GET ADDR OF COMMAND PROCESSOR
         BALR      R10,R11        PERFORM COMMAND PROCESSOR
         TM        ERRORSW,ERRCMD ERROR IN COMMAND RTN?
         BO        ERRORTN        BIF YES
         TM        MAINFLAG,SHUTDOWN WAS SHUTDOWN SIGNALLED?
         BO        MAINEXIT       IF SO, GET OUT OF HERE
         XC        ECBENQ,ECBENQ   CLEAR IT FOR 'WAIT' MACRO
         DEQ       (ENQQNAME,ENQRNAME,8,SYSTEM),RET=HAVE,              X
               MF=(E,ENQMACRO)
         B         MAINWAIT
*
MAINEXIT EQU       *
         L         R11,=A(TERMRTN) GET ADDR OF TERMINATION RTN
         BALR      R10,R11        PERFORM IT
         L         R0,GETPARMS    GET SUBPOOL & LENGTH FOR FREEMAIN
         LR        R1,R13         GET ADDR OF GETMAINED AREA
         L         R2,SAVEAREA+4 GET CALLER'S S/A PTR
         FREEMAIN  R,LV=(0),A=(1)
         LR        R13,R2         PUT CALLER'S S/A PTR IN R13
         MODESET   KEY=NZERO,MODE=PROB  BACK DOWN TO EARTH, SUPERMAN
         RETURN    (14,12),RC=0
         TITLE     'REQUEUER - ERROR FUNCTION'
ERRORTN  DS        0H
**********************************************************************
*
*        THE ERROR FUNCTION IS TO RECEIVE CONTROL ON A-N-Y
*        ERROR CONDITION.  AT ENTRY, R14 HAS BEEN LOADED WITH
*        AN ADDRESS REPRESENTING A LOCATION NEAR WHERE THE
*        ERROR WAS DETECTED.  TO FIND OUT WHERE THE ERROR WAS
*        DETECTED THEN, SUBTRACT R12 FROM R14 TO GET THE
*        RELATIVE OFFSET WITHIN THE CODE WHERE THE ERROR
*        OCCURRED.
*
**********************************************************************
         STM       R0,R15,ERRSAVE HOLD ONTO REGS FOR DIAGNOSTICS
         WTO       'REQUEUER-04-W FATAL ERROR - CALL SYSTEMS PROGRAMMINX
               G',ROUTCDE=1,DESC=2
         OI        OPENLIST,X'80' SET END-OF-LIST
         OPEN      (SNAPDUMP,(OUTPUT)),MF=(E,OPENLIST)
         TM        SNAPDUMP+DCBOFLGS-IHADCB,DCBOFOPN OPEN SUCCESSFUL?
         BO        ERROPNOK       BIF OPEN OK
         WTO       'REQUEUER-01-I - OPEN FAILED FOR SNAPDUMP DD STATEMEX
               NT',ROUTCDE=2,DESC=6
         B         ERREXIT        LEAVE ERROR RTN
ERROPNOK EQU       *
         ST        R13,SNAPSTR1   BUILD SNAP PARM LIST
         LA        R1,WORKLGTH(,R13)
         ST        R1,SNAPEND1    WORK AREA
         LR        R1,R9          GET ADDR OF CSA WORK AREA
         ST        R1,SNAPSTR2
         LA        R1,CRMLGTH(,R1)   ADD LENGTH OF CSA     WRK AREA
         ST        R1,SNAPEND2
         L         R1,COMMAPTR    GET ADDR OF COMMAND PARMS
         LA        R1,0(,R1)      CLEAR HI-BYTE
         ST        R1,SNAPSTR3
         LA        R1,8(,R1)      IT IS 8 BYTES LONG
         ST        R1,SNAPEND3
         L         R1,COMMAPTR
         L         R1,4(,R1)      PTR TO CIB
         LA        R1,0(,R1)      CLEAR HI-BYTE
         ST        R1,SNAPSTR4
         USING     CIB,R1         MAKE CIB ADDRESSABLE
         LH        R2,CIBDATLN    GET LENGTH OF USER DATA
         LA        R1,CIBDATA-CIB(R2,R1)
         ST        R1,SNAPEND4
         DROP      R1
         OI        SNAPEND4,X'80'
         SNAP      DCB=SNAPDUMP,ID=1,SDATA=(CB,Q,DM,IO),               X
               PDATA=(ALL),LIST=SNAPLIST,MF=(E,SNAPMACR)
         LTR       R15,R15        SNAP OK?
         BZ        ERRSNPOK       BIF SNAP OK
         WTO       'REQUEUER-02-I - SNAP FAILED',                      X
               ROUTCDE=2,DESC=6
         B         ERREXIT
ERRSNPOK EQU       *
         OI        CLOSLIST,X'80' SET END-OF-LIST
         CLOSE     SNAPDUMP,MF=(E,CLOSLIST)
ERREXIT  EQU       *
         B         MAINEXIT       NOW LEAVE ALTOGETHER
         TITLE     'REQUEUER - MODIFIED SERIAL TABLE SEARCH'
         TPRTSRCH
         TITLE     'REQUEUER - BINARY SEARCH FUNCTION'
         TBINSRCH
         TITLE     'REQUEUER - TABLE ELEMENT DELETE FUNCTION'
         TDELETE
         TITLE     'REQUEUER - JES JOB RELEASE FUNCTION'
         JESRLFNC
         TITLE     'REQUEUER - JES JOB STATUS CHECKER FUNCTION'
         JESCKFNC
         TITLE     'REQUEUER - RESOURCE CONTROL FILE SYNAD FUNCTION'
RFSYNAD  DS        0H
***********************************************************************
*
*        RESOURCE CONTROL FILE SYNAD ROUTINE
*
***********************************************************************
         OI        ERRORSW,ERRIO SIGNAL I/O ERROR
RFSEXIT  EQU       *
         BR        R14
         TITLE     'REQUEUER - PROGRAM CONSTANTS'
PATSNMAC SNAP      DCB=0,ID=3,SDATA=(CB,Q,DM,IO),                      X
               PDATA=(ALL),LIST=0,MF=L
PATSNMCL EQU       *-PATSNMAC
PATSNDCB DCB       DDNAME=SNAPDUMP,MACRF=(W),LRECL=125,                X
               BLKSIZE=882,RECFM=VBA,DSORG=PS
PATSNLEN EQU       *-PATSNDCB     LENGTH OF PATTERN DCB
PATRFDCB DCB       DDNAME=RESFILE,MACRF=(RISC,WIC),OPTCD=R,            X
               DSORG=DA,EXLST=RFSYNAD
PATRFLEN EQU       *-PATRFDCB
PATCSDCB DCB       DDNAME=RESFILE,MACRF=(WL),DSORG=PS,                 X
               RECFM=F,SYNAD=RFSYNAD
PATCSLEN EQU       *-PATCSDCB
HALFSEC  DC        A(50)          HALF SECOND, IN 100THS OF SECONDS
GETPARMS DC        0F'0',AL1(0),AL3(4096) ******WORK AREA = 4096******
REQNAME  DC        CL8'REQUEUER'
         LTORG
         TITLE     'REQUEUER - INITIALIZATION RTN'
INITRTN  DS        0H
***********************************************************************
*
*        INITIALIZATION RTN
*
***********************************************************************
         USING     INITRTN,R11    ESTAB. ADDRESSABILITY
         SR        R9,R9          CLEAR CSA-BASED WORK AREA POINTER
         MVC       SNAPDUMP(PATSNLEN),PATSNDCB MOVE PATTERN DCB
         MVC       SNAPMACR(PATSNMCL),PATSNMAC MOVE PATTERN SNAP MACR
         SYSEVENT  DONTSWAP MAKE US NON-SWAPPABLE
         OI        ENQMACRO,X'C0' SET END-OF-LIST
         MVC       ENQQNAME,=C'REQUEUER' SET UP QNAME/RNAME
         MVC       ENQRNAME(8),=C'RESOURCE'
         ENQ       (ENQQNAME,ENQRNAME,E,8,SYSTEM),MF=(E,ENQMACRO)
         AIF       ('&SYSPARM' EQ 'NONSE' OR '&SYSPARM' EQ 'SE2' OR    *
               '&SYSPARM' EQ 'SP10' OR '&SYSPARM' EQ 'SP11').PRESP3C
***********************************************************************
*        SEE IF REQUEUER ALREADY STARTED; IF SO, ISSUE MSG & END
***********************************************************************
         L         R3,GETPARMS    GET CURRENT SIZE OF WORK AREA
         LA        R3,0(,R3)      CLEAR HI-BYTE
         LA        R2,WORKEND-WORKAREA GET CURRENTLY-USED AREA LENGTH
         SR        R3,R2          CALC SIZE OF AREA NOT IN USE
         SRL       R3,3           ROUND DOWN TO DOUBLEWORD
         SLL       R3,3
         LA        R2,WORKEND+7   FIND NEXT DOUBLEWORD BOUNDARY
         SRL       R2,3
         SLL       R2,3
         ST        R2,RIBADDR
         GQSCAN    AREA=((2),(3)),                                     *
               SCOPE=LOCAL,                                            *
               REQLIM=MAX,                                             *
               RESNAME=(REQNAME),                                      *
               MF=(E,ENQGQSCN)
         B         INITWTG1(R15)  USE R15 FOR WTG TABLE
INITWTG1 EQU       *
         B         INITFDRB       RC=0; SEE IF REQUEUER ANCHOR PRESENT
         B         INITDOEQ       RC=4; NO OTHER REQUEUERS PRESENT
         BAL       R14,INITERR    RC=8; REPLY AREA TOO SMALL
         BAL       R14,INITERR    RC=12; ABNORMAL CONDITION
         BAL       R14,INITERR    RC=16; INVALID SYSNAME VALUE
*
INITFDRB EQU       *
         LR        R2,R0          PICK APART VALUES RETURNED BY GQSCAN
         SLL       R2,16          EXTRACT LENGTH OF AN RIBE
         SRL       R2,16
         LR        R3,R0
         SRL       R3,16          EXTRACT LENGTH OF RIB FIXED PORTION
         L         R5,16(0,0)     GET CVT ADDRESS
         USING     CVTMAP,R5
         L         R5,CVTSMCA     GET SMCA ADDRESS
         USING     SMCABASE,R5
         L         R4,RIBADDR
INITCHK1 EQU       *
         USING     RIB,R4
         L         R7,RIBNRIBE    GET # OF RIBE'S FOR THIS RIB
         LH        R0,RIBVLEN     GET SIZE OF VARIABLE RIB PORTION
         AR        R4,R3          BUMP TO VARIABLE PORTION
         USING     RIBVAR,R4      MAKE IT ADDRESSABLE
         CLC       SMCASID(4),RIBRNAME IS THIS THE RIB WE'VE LOOKED FOR
         BNE       INITLP01       BIF NOT
         WTO       'REQUEUER-04-I - REQUEUER ALREADY STARTED',         X
               ROUTCDE=2,DESC=6
         OI        MAINFLAG,SHUTDOWN SIGNAL SHUTDOWN
         B         INITEXIT
INITLP01 EQU       *
         SR        R6,R6          BUMP TO NEXT RIB
         MR        R6,R2          COMPUTE AREA TAKEN BY CURRENT RIBE'S
         AR        R4,R7          ADD SIZE TAKEN BY RIBE'S
         AR        R4,R0          ADD SIZE TAKEN BY VARIABLE PORTION
         BCT       R1,INITCHK1    LOOP UNTIL ALL RIB'S ARE CHECKED
         AGO       .RESUMEC
.PRESP3C ANOP
***********************************************************************
*        SEE IF REQUEUER ALREADY STARTED; IF SO, ISSUE MSG & END
***********************************************************************
         L         R1,16(0,0)     GET CVT ADDR
         USING     CVTMAP,R1      MAKE IT ADDRESSABLE
         L         R2,CVTSMCA     GET ADDR OF SMCA
         USING     SMCABASE,R2    MAKE SMCA ADDRESSABLE
         L         R1,CVTFQCB     GET BEG. ADDR OF CVT CHAIN
         USING     QCB,R1         MAKE 1ST MAJOR ADDRESSABLE
INITSRC1 EQU       *
         CLC       MAJNAME(8),=C'REQUEUER' CHECK MAJOR NAME
         BE        INITMAJN       BIF WE HAVE MAJOR NAME
         L         R1,MAJNMAJ     OTHERWISE, GET NEXT MAJOR
         LTR       R1,R1          IS THERE ANOTHER MAJOR?
         BNZ       INITSRC1       BIF YES
         B         INITDOEQ       DO ENQ(REQUEUER STARTED ONLY ONCE)
INITMAJN EQU       *
         L         R1,MAJFMIN     GET 1ST MINOR FOR THIS MAJOR
         USING     MIN,R1         MAKE IT ADDRESSABLE
INITSRC2 EQU       *
         CLC       MINNAME(4),SMCASID ALREADY A REQUEUER ACTIVE?
         BE        INIT2STR       BIF ONE ALREADY ACTIVE
         L         R1,MINNMIN     OTHERWISE, GET NEXT MINOR
         LTR       R1,R1          IS THERE ANOTHER MINOR?
         BNZ       INITSRC2       BIF YES; KEEP LOOKING
         B         INITDOEQ       DO ENQ:(ONLY 1 REQUEUER STARTED)
         DROP      R1,R2
INIT2STR EQU       *
         WTO       'REQUEUER-04-I - REQUEUER ALREADY STARTED',         X
               ROUTCDE=2,DESC=6
         OI        MAINFLAG,SHUTDOWN SIGNAL SHUTDOWN
         B         INITEXIT
.RESUMEC ANOP
INITDOEQ EQU       *
***********************************************************************
*        ESTABLISH CSA-BASED WORK AREA; ISSUE ENQ TO PROVIDE ANCHOR
***********************************************************************
         L         R1,16(0,0)     GET CVT ADDRESS
         USING     CVTMAP,R1      MAKE CVT ADDRESSABLE
         L         R1,CVTSMCA     GET ADDR OF SMCA
         DROP      R1
         LTR       R1,R1          IS SMF ACTIVE?
         BNZ       INITSMOK       BIF YES
         BAL       R14,INITERR    SIGNAL ERROR
INITSMOK EQU       *
         USING     SMCABASE,R1  MAKE IT ADDRESSABLE
         MVC       ENQRNAME+(RNASMFID-RNMANCHR)(4),SMCASID SMF ID
         LA        R0,CRMLGTH     LENGTH OF OUR CSA COMM. AREA
         LA        R1,CRMSUBPL    GET SUBPOOL #
         SLL       R1,24          SHIFT TO HI-BYTE
         OR        R0,R1          IMPOSE SUBPOOL ONTO R0
         GETMAIN   R,LV=(0)
         LR        R2,R1
         LA        R3,CRMLGTH
         SR        R4,R4
         SR        R5,5
         MVCL      R2,R4          CLEAR THIS CSA AREA
         LR        R9,R1          R9 WILL ALWAYS POINT TO CSA
         ST        R1,ENQRNAME+(RNAANCHR-RNMANCHR) PUT CSA PTR IN RNAME
         MVC       ENQHOLD,ENQRNAME HOLD ONTO RNAME FOR A SEC
         L         R1,16(0,0)     GET CVT ADDR
         USING     CVTMAP,R1      MAKE IT ADDRESSABLE
         L         R1,CVTTCBP     GET NEXT-CURRENT TCB/ASCB PTRS
         DROP      R1
         MVC       CRMRQASC(4),12(R1) GET REQUEUER'S ASCB ADDR
         LA        R1,CRMRQECB    GET ADDR OF ECB WE WAIT ON
         ST        R1,ECBCRME     PUT IT IN WAIT LIST
         MVC       ENQQNAME,=C'REQUEUER'
         ENQ       (ENQQNAME,ENQRNAME,E,8,SYSTEM),MF=(E,ENQMACRO)
         LA        R1,ECBENQ      GET ADDR OF ENQ ECB
         ST        R1,ECBENQA     STOW THE ADDRESS
         LA        R2,COMMAPTR
         EXTRACT   (2),FIELDS=COMM,MF=(E,EXTRLIST) GET CIRB INFO
         L         R1,COMMAPTR
         L         R1,0(,R1)      GET ECB ADDRESS
         LA        R1,0(,R1)      CLEAR HI-BYTE
         ST        R1,ECBCMDA     STOW ADDRESS OF CMD ECB
         OI        ECBCMDA,X'80'  SET END-OF-LIST FOR WAIT-MULTIPLE
         L         R1,COMMAPTR GET ADDR OF PTR TO CIB
         L         R1,4(,R1)   GET ADDR OF CIB
         LTR       R1,R1          WAS THIS GUY STARTED AS SYSTEM TASK?
         BZ        INITNFMT       BIF NOT; DO REGULAR (NON-COLD) START
         USING     CIB,R1      MAKE IT ADDRESSABLE
         CLC       =H'0',CIBDATLN ANY COMMAND ISSUED ON START STMT?
         BE        INITNFMT    BIF NOT; NON-FORMAT STARTUP
         CLC       =H'6',CIBDATLN CORRECT LENGTH FOR 'FORMAT'?
         BNE       INITNFMT    BIF NOT; DO REGULAR (NON-COLD) START
         CLC       =CL6'FORMAT',CIBDATA FORMAT REQUESTED?
         DROP      R1
         BNE       INITNFMT    BIF NOT; DO REGULAR (NON-COLD) START
*
INITFMT  EQU       *
***********************************************************************
*        IF REQUESTED, DO FORMAT(COLD) START
***********************************************************************
         WTO       'REQUEUER-05-I CONTROL FILE COLD START REQUESTED',  *
               ROUTCDE=2,DESC=6
         MVI       OPENLIST,X'80'
         MVC       RESFILE(PATCSLEN),PATCSDCB MOVE IN COLD START DCB
         OPEN      (RESFILE,(OUTPUT)),MF=(E,OPENLIST)
         TM        RESFILE+(DCBOFLGS-IHADCB),DCBOFOPN OPEN OK?
         BO        INITFMT1       BIF YES
         WTO       'REQUEUER-03-I OPEN FAILED FOR RESFILE DD STMT',    *
               ROUTCDE=2,DESC=6
         BAL       R14,INITERR    SIGNAL ERROR
INITFMT1 EQU       *
         LH        R0,RESFILE+DCBBLKSI-IHADCB GET BLOCKSIZE OF FILE
         GETMAIN   R,LV=(0) USE TO OBTAIN BUFFER AREA
         LR        R7,R1          USE FOR TABLE
         USING     TABLE,R7
         LR        R2,R1          CLEAR THE TABLE
         LH        R3,RESFILE+(DCBBLKSI-IHADCB) GET LENGTH OF BLOCK
         SR        R4,R4
         SR        R5,R5
         MVCL      R2,R4
         LH        R1,RESFILE+(DCBBLKSI-IHADCB)
         S         R1,=A(TABENTRY-TABLE) REMOVE SIZE OF PREFIX
         S         R1,=A(RCREND-RCRECORD) SIZE OF OVERFLOW
         SR        R0,R0
         D         R0,=A(RCREND-RCRECORD) SIZE OF ONE RECORD
         ST        R1,TABMAX   MAX # OF ENTRIES
         LA        R1,1        BEGINNING RECORD FOR BINARY SEARCH
         ST        R1,TABSRCST
         L         R1,=A(RCRKEYND-RCRKEY-1) LENGTH C-O-D-E OF KEY
         ST        R1,TABLC
         L         R1,=A(RCREND-RCRECORD) LENGTH OF AN ELEMENT
         ST        R1,TABELEML
         OI        TABFLAGS,TABINARY+TABREAD BINARY SEARCH+READ-ONLY
         DROP      R7
         WRITE     RESDECB,SF,RESFILE,(7),MF=(E,RESDECB)
         CHECK     RESDECB
         TM        ERRORSW,ERRIO I/O ERROR?
         BZ        INITCLOS       BIF NOT; NOW CLOSE FILE
         BAL       R14,INITERR    OTHERWISE, SIGNAL ERROR
INITCLOS EQU       *
         LH        R0,RESFILE+(DCBBLKSI-IHADCB) GET SIZE OF WORK AREA
         LR        R1,R7          GET ADDR OF WORK AREA
         FREEMAIN  R,LV=(0),A=(1)
         MVI       CLOSLIST,X'80'  END-OF-LIST
         CLOSE     RESFILE,MF=(E,CLOSLIST)
*
INITNFMT EQU       *
***********************************************************************
*        CONTINUE WITH STANDARD (NON-COLD START) INITIALIZATION
***********************************************************************
         L         R2,COMMAPTR    SET UP TO CLEAR OUT CIB'S
         L         R1,4(,R2)      GET POINTER TO CIB
         LTR       R1,R1          IF NO CIB, THEN STARTED AS BATCH JOB
         BZ        INITQEDT
         LA        R2,4(,R2)      GET PTR TO ADDR OF CIB'S
         QEDIT     ORIGIN=(2)     CLEAR CIB'S
INITQEDT EQU       *
         QEDIT     ORIGIN=(2),CIBCTR=1 PERMIT 1 CIB AT A TIME
         OI        OPENLIST,X'80' SET END-OF-LIST
         MVC       RESFILE(PATRFLEN),PATRFDCB MOVE PATTERN DCB
         OPEN      (RESFILE,(UPDAT)),MF=(E,OPENLIST)
         TM        RESFILE+DCBOFLGS-IHADCB,DCBOFOPN OPEN OK?
         BO        INITOPOK       BIF OK
         WTO       'REQUEUER-03-I - OPEN FAILED FOR RESFILE DD STMT',  X
               ROUTCDE=2,DESC=6
         BAL       R14,INITERR
INITOPOK EQU       *
         XC        RESBLKAD,RESBLKAD ZERO OUT REL REC PTR
         READ      RESDECB,DI,RESFILE,'S','S',0,RESBLKAD,MF=(E,RESDECB)
         CHECK RESDECB
         TM        ERRORSW,ERRIO I/O ERROR SIGNALLED?
         BZ        INITCHKS       BIF NOT; DO CHECKS
         BAL       R14,INITERR
INITCHKS EQU       *
         L         R7,RESDECB+(DECAREA-DECB)    GET TABLE ADDRESS
         USING     TABLE,R7       MAKE IT ADDRESSABLE
         LM        R0,R5,TABMAX LOAD TABLE PARMS
         C         R1,=A(0)       IS TABLE EMPTY?
         BE        INITFREB       BIF YES; GO FREE I/O BUFFER
         OI        TABFLAGS,TABMOD INDICATE TABLE MODIFED
         NI        TABFLAGS,X'FF'-TABREAD TURN OFF READ-ONLY SWITCH
         MR        R0,R5          R1 NOW HAS OFFSET TO LAST ELEM
         LA        R1,TABENTRY(R1) CALC ADDR OF LAST ELEM
         LA        R2,TABENTRY(R5)  CALC ADDR OF 1ST ELEM
         LR        R0,R5          SET UP FOR BXLE
INITLOOP EQU       *
         USING     RCRECORD,R2 MAKE RES. CNTL REC ADDRESSABLE
         STM       R0,R5,REGSAVE HOLD ONTO REGISTERS
         LA        R3,RCRJOBNM    GET ADDR OF JOBNAME
         LH        R2,RCRJES#     GET JES JOB # FROM THIS ELEM
         DROP      R2
         BAL       R8,JESCKFNC SEE IF JOB IN SYSTEM
         B         INITGOTJ       RC=0; GOT INFO ON JOB
         B         INITNOJB       RC=4; JOB NOT FOUND
         BAL       R14,INITERR    RC=8; ERROR IN ROUTINE
INITNOJB EQU       *
         L         R2,REGSAVE+8 GET PTR TO PREV. TABLE ENTRY
         USING     RCRECORD,R2
         BAL       R8,TDELETE     DELETE TAB ENTRY - JOB NOT IN JES
         B         INITNEXT       RC=0; DELETE OK
         BAL       R14,INITERR    RC=4; ERROR IN DELETE RTN
INITGOTJ EQU       *
         L         R2,REGSAVE+8   GET PTR TO PREV. TAB ENTRY
         TM        SSOBAREA+(SSCSFLG1-SSOB),SSCSEXCQ AWAIT EXEC?
         BO        INITHOLD       BIF JOB AWAITING EXEC
         TM        SSOBAREA+(SSCSFLG1-SSOB),SSCSJACT IS JOB EXEC?
         BO        INITEXEC       JOB IS CURRENTLY EXEC
         BAL       R8,TDELETE IF FALL-THRU, JOB OF NO INTEREST
         B         INITNEXT       RC=0; UNINTERESTING JOB DELETED
         BAL       R14,INITERR    RC=4; ERROR IN DELETE RTN
INITHOLD EQU       *
         USING     RCRECORD,R2    MAKE TABLE ELEMENT ADDRESSABLE
         MVI       RCRFLAGS,X'00' BLANK ALL FLAGS
         LM        R0,R5,REGSAVE  RESTORE REGS FOR BXLE
         B         INITBXLE       ONWARD
         DROP      R2
INITEXEC EQU       *
         USING     RCRECORD,R2    MAKE ELEMENT ADDRESSABLE
         MVI       RCRFLAGS,RCREXEC SAY THAT JOB IS IN EXEC
         LM        R0,R5,REGSAVE  RESTORE REGS FOR BXLE
         B         INITBXLE
         DROP      R2
INITNEXT EQU       *
         L         R2,REGSAVE+8   GET ADDR OF ELEM WE LAST LOOKED @
         S         R2,TABELEML    GO BACK ONE BECAUSE OF DELETE
         L         R1,TABCURR     GET CURR. # OF TABLE ELEM'S
         L         R3,TABELEML    GET ELEMENT LENGTH
         MR        R0,R3          CALC OFFSET TO LAST ELEM
         LA        R1,TABENTRY(R1) CALC ADDR OF LAST ELEM
         LR        R0,R3          PUT INCR IN R0 FOR BXLE
INITBXLE EQU       *
         BXLE      R2,R0,INITLOOP FOR JOBS TO DELETE
***********************************************************************
*        LOOK FOR CANDIDATES TO BE RELEASED BY INITIALIZATION:
*        I.E., 'HDSN' VALUE CHANGES & FIRST ENTRY IN NEW 'HDSN'
*        IS MARKED AS BEING ON 'HOLD'
***********************************************************************
         LM        R0,R5,TABMAX   GET TABLE PARMS (AGAIN)
         C         R1,=A(0)       ARE THERE ANY ELEMENTS LEFT?
         BZ        INITWRIT       BIF NOT; REWRITE RES. CNTL REC
         MR        R0,R5          CALC OFFSET TO LAST ELEM
         LA        R1,TABENTRY(R1) CALC ADDR OF LAST ELEM
         LA        R2,TABENTRY(R5) CALC ADDR OF 1ST ELEM
         LR        R0,R5          LOAD ELEM LENGTH FOR BXLE
         XC        HOLDHDSN,HOLDHDSN ZERO OUT HOLD AREA
INITAJLP EQU       *
         USING     RCRECORD,R2
         CLC       HOLDHDSN,RCRHDSN HAS THE HDSN VALUE CHANGED?
         BE        INITAJBX       BIF NOT; ON TO NEXT ENTRY
         MVC       HOLDHDSN,RCRHDSN HOLD ONTO THIS NEW VALUE
         XC        RCRPRTY,RCRPRTY SET KEY TO ZERO
         ZAP       RCRDATE,=P'0'
         XC        RCRTIME,RCRTIME
         TM        RCRFLAGS,RCREXEC IS JOB NOT ON HOLD?
         BO        INITAJBX       BIF NOT; ON TO NEXT ENTRY
         STM       R0,R5,REGSAVE
         LH        R2,RCRJES#     GET JES JOB # FOR THIS ONE
         BAL       R8,JESRLFNC    GO RELEASE THE JOB
         LM        R0,R5,REGSAVE  RESTORE REGS
         MVI       RCRFLAGS,RCREXEC MARK JOB AS IN EXEC
INITAJBX EQU       *
         BXLE      R2,R0,INITAJLP KEEP LOOKING FOR CANDIDATES
INITWRIT EQU       *
         TM        TABFLAGS,TABMOD WAS TABLE MODIFIED?
         BZ        INITFREB       BIF NOT; GO FREE I/O BUFFER
         OI        TABFLAGS,TABREAD MAKE TABLE READ-ONLY AGAIN
         NI        TABFLAGS,255-TABMOD TURN OFF 'MODIFIED' FLAG
         WRITE     RESDECB,DI,RESFILE,'S','S',0,RESBLKAD,              X
               MF=(E,RESDECB)
         CHECK     RESDECB
         TM        ERRORSW,ERRIO I/O ERROR?
         BZ        INITEND
         BAL       R14,INITERR
INITFREB EQU       *
         FREEDBUF  RESDECB,D,RESFILE FREE I/O BUFFER
         B         INITEND        NOT LEAVE
INITERR  EQU       *
         OI        ERRORSW,ERRINIT
         B         INITEXIT       NOW LEAVE
INITEND  EQU       *
         MVC       ENQRNAME(8),=C'RESOURCE' PUT IN RNAME AGAIN
         DEQ       (ENQQNAME,ENQRNAME,8,SYSTEM),MF=(E,ENQMACRO)
INITEXIT EQU       *
         WTO       'REQUEUER-06-I - INITIALIZATION COMPLETE',          *
               ROUTCDE=2,DESC=6
         BR        R10
         LTORG
         DROP      R11
         TITLE     'REQUEUER - CONTROL FILE UPDATE RTN'
FILEUPDT DS        0H
***********************************************************************
*
*        RESOURCE CONTROL FILE UPDATE ROUTINE
*
***********************************************************************
         USING     FILEUPDT,R11
         XC        RESBLKAD,RESBLKAD WANT TO READ RECORD 0
         READ      RESDECB,DI,RESFILE,'S','S',0,RESBLKAD,              X
               MF=(E,RESDECB)
         CHECK     RESDECB
         TM        ERRORSW,ERRIO I/O ERROR?
         BZ        FLUPRDOK       BIF READ WAS OK
         BAL       R14,FLUPERR    OTHERWISE, ERROR
FLUPRDOK EQU       *
         L         R7,RESDECB+(DECAREA-DECB) GET TABLE ADDR FROM DECB
         USING     TABLE,R7       MAKE TABLE ADDRESSABLE
         TM        CRMFLAGS,CRMACTRT DID IEFACTRT MAKE THE CALL?
         BZ        FLUPUJI        BIF NOT; IEFUJI MADE THE CALL
FLUPACTR EQU       *
*********************************************************************
*        HERE IT IS DETERMINED IEFACTRT MADE THE CALL:
*        THE RESOURCE CONTROL RECORD IS READ IN TO
*        CHECK FOR THE OCCURRANCE OF ANY ENTRIES IN THE
*        CONTROL RECORD WHICH CORRESPOND TO THE JOB
*        CURRENTLY BEING PROCESSED BY IEFACTRT-JOBTERM.
*        IF ANY ARE FOUND, ANY JOBS FOUND TO BE REQUESTING
*        THE ASSOCIATED DSNAME ARE RELEASED.
*********************************************************************
         LA        R0,RCRJES#-RCRECORD GET OFFSET TO JES JOB #
         LA        R1,L'RCRJES#   LENGTH OF JES JOB # FIELD
         SR        R2,R2          START SEARCH W/1ST ELEMENT
         LA        R15,CRMONJES   ADDR OF OWNERS JES JOB #
         BAL       R8,TPRTSRCH    LOOK FOR THIS VALUE
         B         FLUPACHT       RC=0; WE FOUND AN ELEMENT W/JES #
         B         FLUPWRIT       RC=4; NO ASSOCIATED ELEMENTS FOUND
         BAL       R14,FLUPERR    RC=8; LOGIC ERROR IN ROUTINE
FLUPACHT EQU       *
         NI        TABFLAGS,255-TABREAD TURN OFF 'READ-ONLY' SW
         USING     RCRECORD,R2    MAKE THE ASSOC. ELEM ADDRESSABLE
         MVC       HOLDHDSN,RCRHDSN HOLD ONTO THE ASSOC. HDSN
         BAL       R8,TDELETE     NOW DELETE THE ASSOC. ELEM
         B         FLUPACDO       RC=0; DELETE OK
         BAL       R14,FLUPERR    RC=4; ERROR IN DELETE RTN
         DROP      R2             NO LONGER NEED ADDRESSABILITY
FLUPACDO EQU       *
         OI        TABFLAGS,TABMOD TABLE WAS MODIFIED
         LA        R0,RCRHDSN-RCRECORD OFFSET TO HASH-DSN
         LA        R1,L'RCRHDSN LENGTH OF HASH-DSN
         SR        R2,R2          START @ BEGINNING OF TABLE
         LA        R15,HOLDHDSN   GET ADDR OF ASSOC. HDSN
         BAL       R8,TPRTSRCH
         B         FLUPACHO       RC=0; FOUND AN ASSOC. REQUESTOR JOB
         B         FLUPACTR       RC=4; NONE ELSE FOUND: TRY AGAIN
         BAL       R14,FLUPERR    RC=8; SIGNAL SOME SORT OF ERROR
FLUPACHO EQU       *
         USING     RCRECORD,R2    MAKE REQ. JOB ELEM ADDRESSABLE
         STM       R0,R5,REGSAVE  HOLD ONTO REGS FOR A SEC
         LA        R3,RCRJOBNM    GET ADDR OF JOBNAME
         LH        R2,RCRJES#     GET ASSOC. JES JOB #
         BAL       R8,JESCKFNC    SEE IF THIS JOB STILL AWAIT EXEC
         B         FLUPACJP       RC=0; JOB PRESENT - CHECK STATUS
         B         FLUPACNJ       RC=4; NO JOB - DELETE ITS ENTRY
         BAL       R14,FLUPERR    RC=8; LOGIC ERROR IN RTN
FLUPACNJ EQU       *
         LM        R0,R5,REGSAVE
         BAL       R8,TDELETE     DELETE JOB - JES DOESN'T HAVE IT
         B         FLUPACDO       RC=0; ELEM DELETED - LOOK FOR OTHERS
         BAL       R14,FLUPERR    RC=4; ERROR IN DELETION RTN
FLUPACJP EQU       *
         TM        SSOBAREA+(SSCSFLG1-SSOB),SSCSEXCQ IS IT WAITING?
         BZ        FLUPACNJ       BIF NOT; DELETE ITS ASSOC. ELEM
         LM        R0,R5,REGSAVE  RESTORE REGS
         XC        RCRPRTY,RCRPRTY FOR JOB IN EXEC, SET KEY
         ZAP       RCRDATE,=P'0' TO ZERO
         XC        RCRTIME,RCRTIME
         OI        RCRFLAGS,RCREXEC SAY THAT JOB IN EXEC
         LH        R2,RCRJES#     GET ITS ASSOC JES #
         BAL       R8,JESRLFNC    RELEASE THIS JOB
         B         FLUPACTR       NOW CHECK FOR OTHERS
         SPACE     2
FLUPUJI  EQU       *
***********************************************************************
*        HERE IT IS DETERMINED THAT IEFUJI IS MAKING A REQUEST.
*        USING THE REQUESTOR'S JES JOB #, DELETE ANY EXISTING
*        ELEMENTS WHICH REFER TO THE SAME JES JOB #, THEN
*        BUILD A NEW ENTRY FOR THE SAME JES JOB #.  BUILD
*        A (NEW) ELEMENT FOR THE RESOURCE HOLDER.
***********************************************************************
         XC        HOLDHDSN,HOLDHDSN CLEAR HOLD AREA
         NI        TABFLAGS,255-TABREAD
         OI        TABFLAGS,TABMOD INDICATE TABLE WAS MODIFIED
         LA        R0,RCRJES#-RCRECORD GET OFFSET TO JES JOB #
         LA        R1,L'RCRJES#   GET LENGTH OF JES JOB #
         SR        R2,R2          START SEARCH @ TABLE BEGIN
         LA        R15,CRMVCJES   LOOK FOR THIS JES JOB #
         BAL       R8,TPRTSRCH
         B         FLUPUJHT       RC=0; FOUND AN EXISTING ENTRY
         B         FLUPUJNH       RC=4; NO CORRESP. ENTRIES FOUND
         BAL       R14,FLUPERR    RC=8; LOGIC ERROR
FLUPUJHT EQU       *
         USING     RCRECORD,R2
         MVC       HOLDHDSN,RCRHDSN
         DROP      R2
         BAL       R8,TDELETE     DELETE ANY EXISTING ENTRY
         B         FLUPUJRL       RC=0; DELETE OK - LOOK FOR OTHERS
         BAL       R14,FLUPERR    RC=4; ERROR IN DELETE RTN
FLUPUJRL EQU       *
         CLC       HOLDHDSN,CRMHDSN  IF IT'S WITH SAME DSN, DO NOTHING
         BE        FLUPUJNH
         LA        R0,RCRHDSN-RCRECORD OFFSE T TO HASH DSN
         LA        R1,L'RCRHDSN   LENGTH OF HASH DSNAME
         SR        R2,R2          START @ BEG. OF TABLE
         LA        R15,HOLDHDSN   LOOK FOR CURR. OWNER
         BAL       R8,TPRTSRCH
         B         FLUPUJCJ       RC=0; FOUND CURR. RES. HOLDER
         B         FLUPUJNH       RC=4; NO HIT; BUILD NEW ELEM
         BAL       R14,FLUPERR    RC=8; ERROR IN GENERIC KEY SEARCH RTN
FLUPUJCJ EQU       *
         USING     RCRECORD,R2    MAKE ASSOC. ELEM ADDRESSABLE
         STM       R0,R5,REGSAVE HOLD ONTO REGS FOR A SEC
         LA        R3,RCRJOBNM    GET JOBNAME ADDR
         LH        R2,RCRJES#     GET JES JOB #
         BAL       R8,JESCKFNC    CHECK JOB STATUS
         B         FLUPUJT1       RC=0; HAVE JOB STATUS
         B         FLUPUJT2       RC=4; JOB NOT FOUND; DELETE ITS ENTRY
         BAL       R14,FLUPERR    RC=8; ERROR IN ROUTINE
FLUPUJT1 EQU       *
         TM        SSOBAREA+(SSCSFLG1-SSOB),SSCSJACT IS JOB ACTIVE?
         BO    FLUPUJNH           BIF YES; DNO'T WORRY ABOUT IT
         TM        SSOBAREA+(SSCSFLG1-SSOB),SSCSEXCQ AWAITING EXEC?
         BZ        FLUPUJT2       BIF NOT; DELETE ITS ENTRY
         LM        R0,R5,REGSAVE RESTORE REGS
         USING     RCRECORD,R2
         LH        R2,RCRJES# GET JES JOB #
         DROP      R2
         BAL       R8,JESRLFNC    RELEASE THIS JOB
         B         FLUPUJNH       NOW, ON WITH ORIG. JOB
FLUPUJT2 EQU       *
         LM        R0,R5,REGSAVE RESTORE REGS
         BAL       R8,TDELETE DELETE UNFOUND JOB
         B         FLUPUJRL       RC=0; DELETE OK
         BAL       R14,FLUPERR    RC=4; ERROR IN ROUTINE
FLUPUJNH EQU       *
         MVC       WRKHDSN,CRMHDSN  BUILD A NEW ELEM FROM HASH-DSN
         LH        R1,CRMVCPTY REQUESTOR'S JOB SEL. PRTY
         LA        R1,1(,R1)      INCR PRTY FOR GOOD COMPL.
         LCR       R1,R1          TAKE 2'S COMPLEMENT
         STH       R1,WRKPRTY
         MVC       WRKDATE,CRMVCRDT REQUESTOR'S READER DATE
         MVC       WRKTIME,CRMVCRTM REQUESTOR'S READER TIME
         MVC       WRKJES#,CRMVCJES REQUESTOR'S JES JOB #
         LA        R15,WRKKEY     INSERT THIS ELEM IN TABLE
         BAL       R8,TBINSRCH
         BAL       R14,FLUPERR    RC=0; EXISTING ELEM FOUND
         B         FLUPUJAD       RC=4; NEW ELEM ADDED OK
         B         FLUPUJOV       RC=8; RES. CNTL TABLE OVERFLOWED
         BAL       R14,FLUPERR    RC=12; LOGIC ERROR
FLUPUJOV EQU       *
         BAL       R14,FLUPERR    TABLE OVERFLOW; SIGNAL ERROR
FLUPUJAD EQU       *
         USING     RCRECORD,R2
         MVC       RCRJOBNM,CRMVCNAM MOVE JOB NAME
         DROP      R2
         XC        WRKPRTY,WRKPRTY BUILD AN ELEM FOR RES. HOLDER
         ZAP       WRKDATE,=P'0'
         XC        WRKTIME,WRKTIME
         MVC       WRKJES#,CRMONJES OWNER'S JES JOB #
         LA        R15,WRKKEY
         BAL       R8,TBINSRCH    ADD THIS ONE TO TABLE
         B         FLUPWRIT       RC=0; EXISTING OWNER ELEM FOUND
         B         FLUPUJOA       RC=4; NEW ELEM ADDED OK
         B         FLUPUJOV       RC=8; TABLE OVERFLOW OCCURRED
         BAL       R14,FLUPERR    RC=12; LOGIC ERROR
FLUPUJOA EQU       *
         USING     RCRECORD,R2 MAKE NEW ELEM ADDRESSABLE
         MVC       RCRJOBNM,CRMONNAM MOVE JOBNAME
         OI        RCRFLAGS,RCREXEC MARK OWNER AS IN EXEC
         DROP      R2
FLUPWRIT EQU       *
         TM        TABFLAGS,TABMOD   WAS TABLE MODIFIED?
         BZ        FLUPFREB       BIF NOT; FREE BUFFER BEFORE EXIT
         OI        TABFLAGS,TABREAD MAKE TABLE READ-ONLY AGAIN
         NI        TABFLAGS,255-TABMOD TURN OFF 'TABLE MOD' SW
         WRITE     RESDECB,DI,RESFILE,'S','S',0,RESBLKAD,              X
               MF=(E,RESDECB)
         CHECK     RESDECB
         TM        ERRORSW,ERRIO ANY ERRORS IN WRITE?
         BZ        FLUPPOST       BIF NOT; DO POSTING
         BAL       R14,FLUPERR OTHERWISE, SIGNAL ERROR
FLUPFREB EQU       *
         FREEDBUF  RESDECB,D,RESFILE FREE I/O BUFFER
         B         FLUPPOST       NOW EXIT
FLUPERR  EQU       *
         OI        CRMFLAGS,CRMRQERR SIGNAL ERROR IN REQUEUE RTN
         OI        ERRORSW,ERRFILUP
         STM       R0,R3,FLUPREGS HOLD FOR DIAGNOSTICS
FLUPPOST EQU       *
         XC        CRMRQECB,CRMRQECB CLEAR OUR ECB
         L         R2,16(0,0)   GET CVT ADDRESS
         USING     CVTMAP,R2
         L         R3,CRMEXASC    GET ADDR OF EXIT'S ASCB
         POST     CRMEXECB,0,ASCB=(3),ERRET=CVTBRET,MF=(E,POSTMAC)
         DROP      R2
FLUPEXIT EQU       *
         BR        R10
         LTORG
         DROP      R11
         TITLE     'REQUEUER - CONSOLE COMMAND PROCESSOR'
CMDRTN   DS        0H
***********************************************************************
*
*        CONSOLE COMMAND PROCESSING RTN
*
***********************************************************************
         USING     CMDRTN,R11
         L         R1,COMMAPTR    GET ADDR OF PTR TO CIB
         L         R1,4(,R1)      GET ADDR OF CIB
         USING     CIB,R1         MAKE IT ADDRESSABLE
         TM        CIBVERB,CIBMODFY IS THIS THE 'MODIFY' CIB?
         BNO       CMDSTOP        BIF NOT; TRY 'STOP'
         CLC       =CL4'DUMP',CIBDATA IS THIS DUMP REQUEST?
         BE        CMDDUMP        BIF YES
         CLC       =CL6'VERIFY',CIBDATA IS THIS VERIFY REQUEST
         BE        CMDVERFY       BIF YES
         CLC       =CL5'TIME=',CIBDATA IS THIS 'TIME=XX' REQUEST?
         BE        CMDTIME        BIF YES
         WTO       'REQUEUER-12-I - INVALID REQUEST - REENTER',        *
               ROUTCDE=2,DESC=6
         B         CMDEXIT
*
CMDVERFY DS        0H
**********************************************************************
*        PROCESS 'VERIFY' COMMAND
**********************************************************************
         WTO       'REQUEUER-07-I - VERIFY REQUESTED',ROUTCDE=2,DESC=6
         XC        RESBLKAD,RESBLKAD ZERO OUT REL REC PTR
         READ      RESDECB,DI,RESFILE,'S','S',0,RESBLKAD,MF=(E,RESDECB)
         CHECK     RESDECB
         TM        ERRORSW,ERRIO I/O ERROR SIGNALLED?
         BZ        CMDRCHKS       BIF NOT; DO CHECKS
         BAL       R14,CMDERR
CMDRCHKS EQU       *
         L         R7,RESDECB+(DECAREA-DECB)    GET TABLE ADDRESS
         USING     TABLE,R7       MAKE IT ADDRESSABLE
         LM        R0,R5,TABMAX LOAD TABLE PARMS
         C         R1,=A(0)       IS TABLE EMPTY?
         BE        CMDEXIT        BIF YES; NOTHING TO CHECK
         NI        TABFLAGS,X'FF'-TABREAD TURN OFF READ-ONLY SWITCH
         MR        R0,R5          R1 NOW HAS OFFSET TO LAST ELEM
         LA        R1,TABENTRY(R1) CALC ADDR OF LAST ELEM
         LA        R2,TABENTRY(R5)  CALC ADDR OF 1ST ELEM
         LR        R0,R5          SET UP FOR BXLE
CMDRLOOP EQU       *
         USING     RCRECORD,R2 MAKE RES. CNTL REC ADDRESSABLE
         STM       R0,R5,REGSAVE HOLD ONTO REGISTERS
         LA        R3,RCRJOBNM    GET ADDR OF JOBNAME
         LH        R2,RCRJES#     GET JES JOB # FROM THIS ELEM
         DROP      R2
         BAL       R8,JESCKFNC SEE IF JOB IN SYSTEM
         B         CMDRGOTJ       RC=0; GOT INFO ON JOB
         B         CMDRNOJB       RC=4; JOB NOT FOUND
         BAL       R14,CMDERR    RC=8; ERROR IN ROUTINE
CMDRNOJB EQU       *
         L         R2,REGSAVE+8 GET PTR TO PREV. TABLE ENTRY
         USING     RCRECORD,R2
         BAL       R8,TDELETE     DELETE TAB ENTRY - JOB NOT IN JES
         B         CMDRNEXT       RC=0; DELETE OK
         BAL       R14,CMDERR    RC=4; ERROR IN DELETE RTN
CMDRGOTJ EQU       *
         L         R2,REGSAVE+8   GET PTR TO PREV. TAB ENTRY
         TM        SSOBAREA+(SSCSFLG1-SSOB),SSCSEXCQ AWAIT EXEC?
         BO        CMDRHOLD       BIF JOB AWAITING EXEC
         TM        SSOBAREA+(SSCSFLG1-SSOB),SSCSJACT IS JOB EXEC?
         BO        CMDREXEC       JOB IS CURRENTLY EXEC
         BAL       R8,TDELETE IF FALL-THRU, JOB OF NO INTEREST
         B         CMDRNEXT       RC=0; UNINTERESTING JOB DELETED
         BAL       R14,CMDERR    RC=4; ERROR IN DELETE RTN
CMDRHOLD EQU       *
         USING     RCRECORD,R2    MAKE TABLE ELEMENT ADDRESSABLE
         MVI       RCRFLAGS,X'00' BLANK ALL FLAGS
         LM        R0,R5,REGSAVE  RESTORE REGS FOR BXLE
         B         CMDRBXLE       ONWARD
         DROP      R2
CMDREXEC EQU       *
         USING     RCRECORD,R2    MAKE ELEMENT ADDRESSABLE
         MVI       RCRFLAGS,RCREXEC SAY THAT JOB IS IN EXEC
         LM        R0,R5,REGSAVE  RESTORE REGS FOR BXLE
         B         CMDRBXLE
         DROP      R2
CMDRNEXT EQU       *
         L         R2,REGSAVE+8   GET ADDR OF ELEM WE LAST LOOKED @
         S         R2,TABELEML    GO BACK ONE BECAUSE OF DELETE
         L         R1,TABCURR     GET CURR. # OF TABLE ELEM'S
         L         R3,TABELEML    GET ELEMENT LENGTH
         MR        R0,R3          CALC OFFSET TO LAST ELEM
         LA        R1,TABENTRY(R1) CALC ADDR OF LAST ELEM
         LR        R0,R3          PUT INCR IN R0 FOR BXLE
CMDRBXLE EQU       *
         BXLE      R2,R0,CMDRLOOP FOR JOBS TO DELETE
***********************************************************************
*        LOOK FOR CANDIDATES TO BE RELEASED BY 'VERIFY':
*        I.E., 'HDSN' VALUE CHANGES & FIRST ENTRY IN NEW 'HDSN'
*        IS MARKED AS BEING ON 'HOLD'
***********************************************************************
         LM        R0,R5,TABMAX   GET TABLE PARMS (AGAIN)
         C         R1,=A(0)       ARE THERE ANY ELEMENTS LEFT?
         BZ        CMDRWRIT       BIF NOT; REWRITE RES. CNTL REC
         MR        R0,R5          CALC OFFSET TO LAST ELEM
         LA        R1,TABENTRY(R1) CALC ADDR OF LAST ELEM
         LA        R2,TABENTRY(R5) CALC ADDR OF 1ST ELEM
         LR        R0,R5          LOAD ELEM LENGTH FOR BXLE
         XC        HOLDHDSN,HOLDHDSN ZERO OUT HOLD AREA
CMDRAJLP EQU       *
         USING     RCRECORD,R2
         CLC       HOLDHDSN,RCRHDSN HAS THE HDSN VALUE CHANGED?
         BE        CMDRAJBX       BIF NOT; ON TO NEXT ENTRY
         MVC       HOLDHDSN,RCRHDSN HOLD ONTO THIS NEW VALUE
         TM        RCRFLAGS,RCREXEC IS JOB NOT ON HOLD?
         BO        CMDRAJBX       BIF NOT; ON TO NEXT ENTRY
         STM       R0,R5,REGSAVE
         LH        R2,RCRJES#     GET JES JOB # FOR THIS ONE
         BAL       R8,JESRLFNC    GO RELEASE THE JOB
         LM        R0,R5,REGSAVE  RESTORE REGS
         MVI       RCRFLAGS,RCREXEC MARK JOB AS IN EXEC
CMDRAJBX EQU       *
         BXLE      R2,R0,CMDRAJLP KEEP LOOKING FOR CANDIDATES
CMDRWRIT EQU       *
         OI        TABFLAGS,TABREAD MAKE TABLE READ-ONLY AGAIN
         WRITE     RESDECB,DI,RESFILE,'S','S',0,RESBLKAD,              X
               MF=(E,RESDECB)
         CHECK     RESDECB
         TM        ERRORSW,ERRIO I/O ERROR?
         BZ        CMDEXIT
         BAL       R14,CMDERR
*
CMDSTOP  DS        0H
**********************************************************************
*        PROCESS 'STOP' COMMAND
**********************************************************************
         WTO       'REQUEUER-08-I - SHUTDOWN REQUESTED',ROUTCDE=2,     *
               DESC=6
         OI        MAINFLAG,SHUTDOWN THIS IS 'STOP'-SIGNAL TERMINATION
         B         CMDEXIT        NOW CLOSE DOWN
*
CMDDUMP  DS        0H
**********************************************************************
*        PROCESS 'DUMP' COMMAND
**********************************************************************
         WTO       'REQUEUER-09-I - CONTROL BLOCK DUMP REQUESTED',     *
               ROUTCDE=2,DESC=6
         XC        RESBLKAD,RESBLKAD ZERO OUT REL. REC. PTR
         READ      RESDECB,DI,RESFILE,'S','S',0,RESBLKAD,MF=(E,RESDECB)
         CHECK     RESDECB
         TM        ERRORSW,ERRIO  I/O ERROR?
         BZ        CMDDRDOK       BIF NO I/O ERROR
         BAL       R14,CMDERR     OTHERWISE; I/O ERROR
CMDDRDOK EQU       *
         STM       R0,R15,ERRSAVE HOLD ONTO REGS FOR DIAGNOSTICS
         OI        OPENLIST,X'80' SET END-OF-LIST
         OPEN      (SNAPDUMP,(OUTPUT)),MF=(E,OPENLIST)
         TM        SNAPDUMP+DCBOFLGS-IHADCB,DCBOFOPN OPEN SUCCESSFUL?
         BO        CMDDOPOK       BIF OPEN OK
         WTO       'REQUEUER-01-I - OPEN FAILED FOR SNAPDUMP DD STATEMEX
               NT',ROUTCDE=2,DESC=6
         BAL       R14,CMDERR     SIGNAL AN ERROR
CMDDOPOK EQU       *
         ST        R13,SNAPSTR1   BUILD SNAP PARM LIST
         LA        R1,WORKLGTH(,R13)
         ST        R1,SNAPEND1    WORK AREA
         LR        R1,R9          GET ADDR OF CSA WORK AREA
         ST        R1,SNAPSTR2
         LA        R1,CRMLGTH(,R1)   ADD LENGTH OF CSA     WRK AREA
         ST        R1,SNAPEND2
         L         R1,COMMAPTR    GET ADDR OF COMMAND PARMS
         LA        R1,0(,R1)      CLEAR HI-BYTE
         ST        R1,SNAPSTR3
         LA        R1,8(,R1)      IT IS 8 BYTES LONG
         ST        R1,SNAPEND3
         L         R1,COMMAPTR
         L         R1,4(,R1)      PTR TO CIB
         LA        R1,0(,R1)      CLEAR HI-BYTE
         ST        R1,SNAPSTR4
         USING     CIB,R1         MAKE CIB ADDRESSABLE
         LH        R2,CIBDATLN    GET LENGTH OF USER DATA
         LA        R1,CIBDATA-CIB(R2,R1)
         ST        R1,SNAPEND4
         DROP      R1
         OI        SNAPEND4,X'80'
         SNAP      DCB=SNAPDUMP,ID=2,SDATA=(CB,Q,DM,IO),               X
               PDATA=(ALL),LIST=SNAPLIST,MF=(E,SNAPMACR)
         LTR       R15,R15        SNAP OK?
         BZ        CMDDMPOK       BIF SNAP OK
         WTO       'REQUEUER-02-I - SNAP FAILED',                      X
               ROUTCDE=2,DESC=6
         B         ERREXIT
CMDDMPOK EQU       *
         OI        CLOSLIST,X'80' SET END-OF-LIST
         CLOSE     SNAPDUMP,MF=(E,CLOSLIST)
         FREEDBUF  RESDECB,D,RESFILE FREE I/O BUFFER
         B         CMDEXIT        NOW LEAVE
*
CMDTIME  DS        0H
***********************************************************************
*        PROCESS 'TIME=XX' COMMAND
***********************************************************************
         USING     CIB,R1         R1 STILL POINTS TO CIB
         CLC       CIBDATLN,=H'7' RIGHT LENGTH FOR 'TIME=XX'?
         BE        CMDOTIME       BIF YES
         BAL       R14,CMDERR     OTHERWISE SIGNAL AN ERROR
CMDOTIME EQU       *
         PACK      DOUBLE,CIBDATA+5(2) PACK TIMER VALUE
         DROP      R1
         WTO       'REQUEUER-10-I - TIME DELAY REQUESTED',ROUTCDE=2,   *
               DESC=6
         CVB       R2,DOUBLE
         MH        R2,=H'100'     MULT BY 100
         ST        R2,TIMEWAIT
         STIMER    WAIT,BINTVL=TIMEWAIT WAIT SPECIFIED INTERVAL
         B         CMDEXIT
*
CMDERR   EQU       *
         OI        ERRORSW,ERRCMD   ERROR IN COMMAND ROUTINE
         BR        R10
*
CMDEXIT  EQU       *
         L         R2,COMMAPTR    GET ADDR OF COMM ECB & CIB PTRS
         LA        R2,4(,R2)      GET ADDR OF PTR TO CIB'S
         QEDIT     ORIGIN=(2)      DELETE ALL CIB'S
         BR        R10
         LTORG
         DROP      R11
         TITLE     'REQUEUER - TERMINATION ROUTINE'
TERMRTN  DS        0H
*********************************************************************
*
*        TERMINATION ROUTINE
*
********************************************************************
         USING     TERMRTN,R11
         WTO       'REQUEUER-11-I - TERMINATION IN PROGRESS',ROUTCDE=2,*
               DESC=6
         MVC       ENQRNAME,ENQHOLD DO DEQ ON ANCHOR
         DEQ       (ENQQNAME,ENQRNAME,8,SYSTEM),RET=HAVE,              X
               MF=(E,ENQMACRO)
         MVC       ENQRNAME(8),=C'RESOURCE'
         DEQ       (ENQQNAME,ENQRNAME,8,SYSTEM),RET=HAVE,              X
               MF=(E,ENQMACRO)
         LA        R0,CRMLGTH     FREEMAIN COMM. AREA IN CSA
         LA        R1,CRMSUBPL    GET SUBPOOL #
         SLL       R1,24          SHIFT TO HI-BYTE
         OR        R0,R1          'OR' THE SUBPOOL # INTO R0
         LTR       R1,R9          LOAD R1 & SEE IF AREA PRESENT
         BZ        TERMSYSE       BIF NO AREA PRESENT
         FREEMAIN  R,LV=(0),A=(1)
TERMSYSE EQU       *
         SYSEVENT  OKSWAP
         OI        CLOSLIST,X'80' SET END-OF-LIST MARKER
         TM        RESFILE+(DCBOFLGS-IHADCB),DCBOFOPN IS FILE OPEN?
         BZ        TERMEXIT       BIF NOT
         CLOSE     RESFILE,MF=(E,CLOSLIST)
TERMEXIT EQU       *
         BR        R10
TERMERR  EQU       *
         OI        ERRORSW,ERRTERM SIGNAL ERROR IN TERMINATION
         BR        R10
         LTORG
         DROP      R11
         END
