*-------------------------------------------------------------------*
×   SMF DATA REDUCTION IN AN MVS/RMF II ENVIRONMENT                 ×
×                                                                   ×
×   THE PURPOSE OF THIS JOB IS TO UTILIZE SAS TO ACCOMPLISH THE     ×
×   REDUCTION OF DATA FOR MOST OF THE MORE COMMONLY UTILIZED        ×
×   FIELDS WITHIN THE FOLLOWING SMF RECORD TYPES:                   ×
×   5,34,35,40,70,71,72,73,74.                                      ×
×                                                                   ×
×   NO REPORTS ARE CREATED BY THIS JOB, BUT THE DATA IS PLACED      ×
×   IN THE FILE CALLED 'SMF' IN ORDER TO ACCOMPLISH ANALYSIS BY     ×
×   OTHER JOBS.                                                     ×
×                                                                   ×
×   THIS PROGRAM IS CURRENTLY RUNNING IN AN RMF II, MVS-MP          ×
×   ENVIRONMENT AND CONTAINS NO CPU-DEPENDENT CODE. HOWEVER,        ×
×   IT IS STRONGLY SUGGESTED THAT ONE HAVE A THOROUGH UNDERSTANDING ×
×   OF THE PROGRAM BEFORE UTILIZING IT.  BECAUSE EACH INSTALLATION  ×
×   POSSESSES ITS OWN UNIQUE REQUIREMENTS, THIS PROGRAM IS PRIMARILY×
×   INTENDED TO DEMONSTRATE THE FLEXIBILITY AND CAPABILITY OF SAS   ×
×   IN THE ANALYSIS OF SMF DATA. RATHER THAN BEING UTILIZED IN ITS  ×
×   CURRENT FORM, IT BEST SERVES AS A STARTING POINT FOR THE        ×
×   DEVELOPMENT OF FACILITIES THAT BEST SUIT THE INDIVIDUAL         ×
×   INSTALLATION                                                    ×
×                                                                   ×
×   KENNETH C. TUCKER                                               ×
×   UNION CARBIDE CORPORATION                                       ×
×   P.O. BOX 8361                                                   ×
×   SOUTH CHARLESTON, W VA. 25303                                   ×
×                                                                   ×
*-------------------------------------------------------------------*
;
TITLE1 SMF REDUCTION;
DATA SMF.S5
(KEEP = TIME     DATE     SID      SMF5JBN  SMF5RST  SMF5RSD
        SMF5JIT  SMF5JID  SMF5TRAN SMF5JICL SMF5SRBT SMF5TJS
        SMF5TTAT SMF5PGNO SMF5JCPU
        Q_WAIT EX_TIME LAPSED RLAPSED CPU_TIME)
        SMF.S34 (KEEP=USERID DATE TIME_ON TIVPGIN TIVPGOUT TIVRGNS
                      TIVSIN TIVSOUT TIVVPI TIVVPO TIVSST TIVACT_S
                      TIVTRA_S TIVRECLM TIVRCLAM TIVCPGIN TIVCRECL
                      TIVPGSTL TPAGING
                      SDATE TIME_ON TIME_OFF CON_MIN TPUTS TGETS
                      TCB_SEC SRB_SEC CPU_SEC EXCP EXCP_D USERID GROUP)
        SMF.S35 (KEEP=NO_TRANS USERID SDATE DATE TIME_ON)
        SMF.S40 (KEEP=SDATE USERID DATE EXCP_D)
     SMF.S70
(KEEP = DATE TIME DURATION CPU0_BUS SERIAL_0 CPU1_BUS SERIAL_1
        AVE_BUSY SID)
     SMF.S71
(KEEP = DATE T1 DURATION TIME PAGEINS PAGEOUTS RECLAIMS ADSPSWAP
        PGSWAPIN PQSWAPOT VIOPGIN VIOPGOUT VIOPGRCL SPAPGIN SPAPGOUT
        SPARCLM SPAVIOI SPAVIOO SPAVIOR DFFRAME TOTSLOTS
        DSSLOTS ASPSLOT FREESLT HOUR PAGERATE SYSIRATE
        SWAPRATE SWPGRATE AVGPGOUT AVGPGIN PG_FLTS
        SMF71AVF SMF71AVP SMF71AVS SMF71AVQ SMF71AVC SMF71AVR
        SMF71TIS SMF71LWS SMF71DWS SMF71ULS SMF71NRS SMF71ASS
        SMF71RSS SMF71EXS SMF71EES SMF71TOS SID)
     SMF.S72
(KEEP = DATE TIME DURATION PGN PERIOD SMF72TTX SMF72ACT SMF72SER
        SMF72TTM IPS
        SMF72LEV SMF72MTS SMF72ITS SMF72CTS SMF72TAT SMF72SPP SID)
     SMF.S73
(KEEP = DATE TIME DURATION SAMPLES CPU_ID CHAN_ID TYPE SIO BUSY
        BUSY_CW SID)
     SMF.S74
(KEEP = DATE TIME DURATION SAMPLES DEV_ADDR TYPE VOLSER IO BUSY
        QUED SMF74ACT SMF74QUE
        CU_DEL RESV_DEL DEV_RESV DEV_ALC SID)
         ;
INFILE ISMF;

INPUT @2 REC_ID PIB1. @;
IF REC_ID = 5  THEN GO TO _5;
IF REC_ID = 34 THEN GO TO _34;
IF REC_ID = 35 THEN GO TO _35;
IF REC_ID = 40 THEN GO TO _40;
IF REC_ID = 70 THEN GO TO _70;
IF REC_ID = 71 THEN GO TO _71;
IF REC_ID = 72 THEN GO TO _72;
IF REC_ID = 73 THEN GO TO _73;
IF REC_ID = 74 THEN GO TO _74;

DONE:
INPUT; DELETE;
_5:
INPUT
                   @3  TIME     PIB4.2
                       DATE     PD4.
                       SID      $4.
                       SMF5JBN  $8.
                       SMF5RST  PIB4.2
                       SMF5RSD  PD4.
                   +9  SMF5JIT  PIB4.2
                       SMF5JID  PD4.
                   +17 SMF5TRAN PIB4.
                   +3  SMF5JICL $1.
                   +1  SMF5SRBT PIB3.2
                       SMF5TJS  PIB4.
                       SMF5TTAT PIB4.
                   +4  SMF5PGNO PIB2.
                   +23 SMF5JCPU PIB3.2
                       @;
Q_WAIT=1440*(SMF5JID-SMF5RSD)+(SMF5JIT-SMF5RST)/60;
IF Q_WAIT LT 0 THEN Q_WAIT=0;
EX_TIME=1440*(DATE-SMF5JID)+(TIME-SMF5JIT)/60;
IF EX_TIME LT 0 THEN EX_TIME=0;
LAPSED=Q_WAIT+EX_TIME;
RLAPSED=10*INT(LAPSED/10);
IF RLAPSED GT 240 THEN RLAPSED=240;
SMF5JCPU=SMF5JCPU/60;
SMF5SRBT=SMF5SRBT/60;
CPU_TIME=SMF5JCPU+SMF5SRBT;
SMF5TRAN=(SMF5TRAN*1024/1000000)/60;
SMF5TTAT=(SMF5TTAT*1024/1000000)/60;
DATE=DATEJUL(DATE);
OUTPUT SMF.S5;
GO TO DONE;
_34:
   INPUT  @7  DATE PD4.
          @23 SDATE SMFSTAMP8.
          @23 T_ONH PIB4.
          @27 DATE_ON PD4.
          @3 T_OFFH PIB4.
          @7 DATE_OFF PD4.
          @44 TPUTS PIB4. TGETS PIB4.
          @96 SRBH PIB3.
          @101 DISP_REL PIB2.
          @103 LEN_IO PIB2.
          @LEN_IO+104 TCBH PIB3.
          @DISP_REL+1  TIVPGIN  PIB4.
                       TIVPGOUT PIB4.
                       TIVRGNS  PIB4.
                       TIVSIN   PIB4.
                       TIVSOUT  PIB4.
                       TIVVPI   PIB4.
                       TIVVPO   PIB4.
                       TIVSST   PIB4.
                       TIVACT   PIB4.
                    +2 TIVTRANT PIB4.
                       TIVRECLM PIB4.
                       TIVRCLAM PIB4.
                       TIVCPGIN PIB4.
                       TIVCRECL PIB4.
                       TIVPGSTL PIB4.
          @15 USERID $8. @;
   DATE=DATEJUL(DATE);
   TIVACT_S=TIVACT*1024/1000000;
   TIVTRA_S=TIVTRANT*1024/1000000;
   TCB_SEC=TCBH/100;
   SRB_SEC=SRBH/100;
   CPU_SEC=TCB_SEC+SRB_SEC;
   TIME_ON=T_ONH/360000;
   TIME_OFF=T_OFFH/360000;
   TPAGING=(TIVPGIN+TIVPGOUT+TIVVPI+TIVVPO+TIVSIN+TIVSOUT);
   CON_MIN=(TIME_OFF-TIME_ON)*60+(DATE_OFF-DATE_ON)*24*60;
   EXCP=0;
   CT=(LEN_IO-2)/8;
   LOOP=1;
   INPUT @103 LEN_IO PIB2. @;
L: IF CT LT LOOP THEN GO TO OUT;
   INPUT +4 E PIB4. @;
   LOOP+1;
   EXCP+ E;
   GO TO L;
OUT:
   OUTPUT SMF.S34;
   GO TO DONE;
_35:
   INPUT @7  DATE PD4.
         @15 USERID $8.
         @85 NO_TRANS PIB4.
         @23 SDATE SMFSTAMP8.
         @23 T_ONH PIB4. @;
   DATE=DATEJUL(DATE);
   TIME_ON=T_ONH/360000;
   OUTPUT SMF.S35;
   GO TO DONE;
_40:
   INPUT @7  DATE PD4.
         @23 SDATE SMFSTAMP8.
         @39 STEP_NO PIB1.
         @61 LEN_IO PIB2.
         @15 USERID $8. @;
   DATE=DATEJUL(DATE);
   IF STEP_NO NE 1 THEN GO TO DONE;
   EXCP_D=0;
   CT=(LEN_IO-2)/8;
   LOOP=1;
   INPUT @61 LEN_IO PIB2. @;
L1: IF CT LT LOOP THEN GO TO OUT1;
   INPUT+4 E1 PIB4. @;
   LOOP+1;
   EXCP_D+E1;
   GO TO L1;
OUT1:
   IF EXCP_D LT 1 THEN GO TO DONE;
   OUTPUT SMF.S40;
   GO TO DONE;
_70:
INPUT @3 T1 PIB4.
      @11 SID $4. @;
HOUR = T1/360000;
POINTER = 15;
INPUT @ POINTER
               COM_SIZE PIB2.
               TIME PD4.
               DATE PD4.
               DURATION PD4.3
               @;
POINTER = POINTER + COM_SIZE;
LINK _DATE1;
DATE=DATEJUL(DATE);
INPUT @ POINTER
               CON_SIZE PIB2.
               CPU_NO PIB2.
               CPU_SIZE PIB2.
               @;
POINTER = POINTER + CON_SIZE;
INPUT @ POINTER
               CPU_WT  PIB8.
               CPU_ID PIB2.
            +1 VALID PIB1.
            +1 SERIAL_0 PIB3.
               @;
CPU_WT=CPU_WT/4096; * CONVERT TO MICROSECONDS;
CPU_WT=CPU_WT/1000000; * CONVERT TO SECONDS;
X=60*FLOOR(DURATION/100)+MOD(DURATION,100); * CONVERT TO SECONDS;
CPU0_BUS=100*(1-CPU_WT/X);
CPU1_BUS=.;
SERIAL_1=.;
AVE_BUSY=.;
IF CPU_NO = 1 THEN GO TO _70_2;
CPU_NO = CPU_NO - 1;
POINTER = POINTER + CPU_SIZE;
INPUT @ POINTER
               CPU_WT  PIB8.
               CPU_ID PIB2.
            +1 VALID PIB1.
            +1 SERIAL_1 PIB3.
               @;
CPU_WT=CPU_WT/4096; * CONVERT TO MICROSECONDS;
CPU_WT=CPU_WT/1000000; * CONVERT TO SECONDS;
X=60*FLOOR(DURATION/100)+MOD(DURATION,100); * CONVERT TO SECONDS;
CPU1_BUS=100*(1-CPU_WT/X);
AVE_BUSY=(CPU0_BUS+CPU1_BUS)/2;
_70_2:
OUTPUT SMF.S70;
GO TO DONE;
_71:
INPUT @3 T1 PIB4.
      @11 SID $4. @;
HOUR = T1/360000;
POINTER = 15;
INPUT @POINTER COM_SIZE PIB2.
               TIME PD4.
               DATE PD4.
               DURATION PD4.3
               @;
POINTER = POINTER + COM_SIZE;
INPUT @POINTER PCSIZ PIB2. @;
POINTER = POINTER + PCSIZ;
INPUT @POINTER
                 PAGEINS      PIB4.
                 PAGEOUTS     PIB4.
                 RECLAIMS     PIB4.
                 ADSPSWAP     PIB4.
                 PGSWAPIN     PIB4.
                 PGSWAPOT     PIB4.
                 VIOPGIN      PIB4.
                 VIOPGOUT     PIB4.
                 VIOPGRCL     PIB4.
                 SPAPGIN      PIB4.
                 SPAPGOUT     PIB4.
                 SPARCLM      PIB4.
                 SPAVIOI      PIB4.
                 SPAVIOO      PIB4.
                 SPAVIOR      PIB4.
                 AVFRAME      PIB4.
                 DFFRAME      PIB4.
                 TOTSLOT      PIB4.
                 DSSLOTS      PIB4.
                 ASPSLOT      PIB4.
                 FREESLT      PIB4.
             +12 SMF71AVF     PIB4.
             +8  SMF71AVP     PIB4.
             +8  SMF71AVS     PIB4.
             +20 SMF71AVQ     PIB4.
             +8  SMF71AVC     PIB4.
             +8  SMF71AVR     PIB4.
             +72 SMF71TIS     PIB4.
                 SMF71LWS     PIB4.
                 SMF71DWS     PIB4.
                 SMF71ULS     PIB4.
                 SMF71NRS     PIB4.
                 SMF71ASS     PIB4.
                 SMF71RSS     PIB4.
                 SMF71EXS     PIB4.
                 SMF71EES     PIB4.
                 SMF71TOS     PIB4.
                 @;
LINK _DATE1;
DATE=DATEJUL(DATE);
X = 60 * FLOOR(DURATION/100) + MOD(DURATION,100);
PG_FLTS = (PAGEINS + RECLAIMS + SPAPGIN)/X;
SYSIRATE = (SPAPGIN + SPAPGOUT + SPAVIOI + SPAVIOO) / X;
PAGERATE = (PAGEINS + PAGEOUTS + VIOPGIN + VIOPGOUT +
           PGSWAPIN + PGSWAPOT + SYSIRATE) / X;
SWAPRATE = ADSPSWAP / X;
SWPGRATE = (PGSWAPIN + PGSWAPOT) / X;
AVGPGOUT = 0;
AVGPGIN = 0;
IF ADSPSWAP NE 0 THEN AVGPGOUT = PGSWAPOT / ADSPSWAP;
IF ADSPSWAP NE 0 THEN AVGPGIN = PGSWAPIN /ADSPSWAP;
OUTPUT SMF.S71;
GO TO DONE;
_72:
INPUT @3 T1 PIB4.
      @11 SID $4. @;
HOUR = T1/360000;
POINTER = 15;
INPUT @ POINTER
                 COM_SIZE PIB2.
                 TIME PD4.
                 DATE PD4.
                 DURATION PD4.3
              +2 PGN PIB2.
                 @;
POINTER = POINTER + COM_SIZE;
LINK _DATE1;
DATE=DATEJUL(DATE);
INPUT @ POINTER
                 WC_SIZE PIB2.
                 NO_PG PIB2.
                 PG_SIZE PIB2.
              +2 IPS $8.
                 @;
POINTER = POINTER + WC_SIZE;
PERIOD = 1;
_72_1:
INPUT @ POINTER
                 SMF72TTX PIB4.
                 SMF72ACT PIB4.
                 SMF72SER PIB4.
                 SMF72TTM PIB4.
                 SMF72LEV PIB4.
                 SMF72MTS PIB4.
                 SMF72ITS PIB4.
                 SMF72CTS PIB4.
                 SMF72TAT PIB4.
                 SMF72SPP PIB4.
                 @;
IF SMF72ACT=0 THEN GO TO _72_3;
SMF72ACT=SMF72ACT*1024/1000000;
SMF72TTM=SMF72TTM*1024/1000000;
SMF72TAT=SMF72TAT*1024/1000000;
SMF72LEV=SMF72LEV/256;
SMF72ACT=SMF72ACT/60;
SMF72TTM=SMF72TTM/60;
SMF72TAT=SMF72TAT/60;
OUTPUT SMF.S72;
_72_3:
IF NO_PG = PERIOD THEN GO TO DONE;
PERIOD = PERIOD + 1;
POINTER = POINTER + PG_SIZE;
GO TO _72_1;
_73:
INPUT @3 T1 PIB4.
      @11 SID $4. @;
HOUR = T1/360000;
POINTER = 15;
INPUT @ POINTER
                 COM_SIZE PIB2.
                 TIME PD4.
                 DATE PD4.
                 DURATION PD4.3
              +4 SAMPLES PIB4.
                 @;
POINTER = POINTER + COM_SIZE;
LINK _DATE1;
DATE=DATEJUL(DATE);
INPUT @ POINTER
                 CHN_SIZE PIB2.
                 NO_CHAN PIB2.
                 DS_SIZE PIB2.
                 @;
POINTER = POINTER + CHN_SIZE;
_73_1:
INPUT @ POINTER
                 CPU_ID PIB2.
                 CHAN_ID PIB1.
                 TYPE PIB1.
                 SIO PIB4.
                 SMF73BSY PIB4.
                 CBC_CNT PIB4.
                 @;
SKIP 5;
IF MOD(TYPE,8) ^= 1 THEN GO TO NEXTCHAN;
*                THIS KEEPS ONLY CHANNELS WHICH ARE ONLINE AND VALID;
BUSY = 100 * SMF73BSY/SAMPLES;
BUSY_CW=100*CBC_CNT/SAMPLES;
OUTPUT SMF.S73;
NEXTCHAN:
IF NO_CHAN = 1 THEN GO TO DONE;
NO_CHAN = NO_CHAN - 1;
POINTER = POINTER + DS_SIZE;
GO TO _73_1;
_74:
INPUT @3 T1 PIB4.
      @11 SID $4. @;
HOUR = T1/360000;
POINTER = 15;
INPUT @ POINTER
                 COM_SIZE PIB2.
                 TIME PD4.
                 DATE PD4.
                 DURATION PD4.3
              +3 UCBTYP3 PIB1.
                 SAMPLES PIB4.
                 @;
IF ^MOD(FLOOR(UCBTYP3/32),2) THEN GO TO DONE;
*                THIS ELIMINATES ALL BUT DASD DEVICES;
POINTER = POINTER + COM_SIZE;
LINK _DATE1;
DATE=DATEJUL(DATE);
INPUT @ POINTER
                 DC_SIZE PIB2.
                 NO_DD PIB2.
                 DD_SIZE PIB2.
                 @;
POINTER = POINTER + DC_SIZE;
_74_1:
INPUT @ POINTER
                 DEV_ADDR PIB2.
              +1 ONLINE PIB1.
                 TYPE PIB4.
                 VOLSER $6.
             +2  IO PIB4.
                 SMF74ACT PIB4.
                 SMF74QUE PIB4.
             +8  SMF74ALC PIB4.
                 SMF74CUB PIB4.
             +28 SMF74RSV PIB4.
             +4  SMF74RDL PIB4.
                 @;
SKIP 3;
IF ONLINE ^= 1 THEN GO TO NEXTDEV;
*         THIS KEEPS ONLY DEVICES WHICH WERE ONLINE THE WHOLE PERIOD;
DEV_ADDR = FLOOR(DEV_ADDR/16);
BUSY = 100 * SMF74ACT/SAMPLES;
QUED = SMF74QUE/SAMPLES;
CU_DEL=100*SMF74CUB/SAMPLES;
RESV_DEL=100*SMF74RDL/SAMPLES;
DEV_RESV=100*SMF74RSV/SAMPLES;
DEV_ALC=100*SMF74ALC/SAMPLES;
OUTPUT SMF.S74;
NEXTDEV:
IF NO_DD = 1 THEN GO TO DONE;
NO_DD = NO_DD - 1;
POINTER = POINTER + DD_SIZE;
GO TO _74_1;
_DATE1:
H=INT(TIME/10000);
M=INT(TIME/100)-100*H;
M1=INT(DURATION/100+.5);
M=M+M1;
IF M LT 60 THEN GO TO _DATE2;
H=H+1;
M=M-60;
_DATE2:
IF H LT 24 THEN GO TO _DATE3;
DATE=DATE+1;
H=H-24;
_DATE3:
TIME=100*H+M;
RETURN;
PROC SORT DATA=SMF.S5; BY DATE SMF5JICL;
PROC SORT DATA=SMF.S34; BY DATE;
PROC SORT DATA=SMF.S35; BY DATE;
PROC SORT DATA=SMF.S40; BY DATE;
PROC SORT DATA=SMF.S70; BY DATE SID TIME;
PROC SORT DATA=SMF.S71; BY DATE SID TIME;
PROC SORT DATA=SMF.S72; BY DATE SID PGN PERIOD;
PROC SORT DATA=SMF.S73; BY DATE SID CHAN_ID CPU_ID TIME;
PROC SORT DATA=SMF.S74; BY DATE SID DEV_ADDR VOLSER TIME;
