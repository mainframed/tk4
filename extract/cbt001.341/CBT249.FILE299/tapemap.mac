XYZZY    OPSYN PRINT               CUSTOMIZED PRINT CONTROL   06/84 DBC
PRINT    OPSYN ANOP                SUPPRESS STD PRINT CONTROL 06/84 DBC
TAPEMAP  TITLE 'TAPE ANALYSIS PROGRAM  (T A P E M A P)'
***********************************************************************
*                                                                     *
*                                                                     *
*  THIS PROGRAM MAY NOT BE DISTRIBUTED WITHOUT PERMISSION OF THE      *
*  AUTHOR.  ALTHOUGH THIS PROGRAM HAS BEEN EXTENSIVELY TESTED, AND    *
*  IS IN USE IN A PRODUCTION ENVIRONMENT (MVT 21.8 ON A 360/91) AT    *
*  UCLA'S OFFICE OF ACADEMIC COMPUTING (FORMERLY CAMPUS COMPUTING     *
*  NETWORK), NO GUARANTEE IS MADE OF (OR RESPONSIBILITY ASSUMED FOR)  *
*  CORRECT OR RELIABLE OPERATION.  WE MAY TRY TO HELP WITH PROBLEMS.  *
*                                                                     *
*  CONTACT:  CHRIS THOMAS  (213) 825-7424                             *
*                                                                     *
***********************************************************************
         SPACE 2
***********************************************************************
*                                                                     *
*  THIS PROGRAM IS BASED ON THE PROGRAM TAPEINDX WRITTEN BY           *
*  MICHAEL S. MAITEN OF THE UCLA COMPUTER CLUB.                       *
*  IT HAS BEEN ALMOST COMPLETELY REWRITTEN BY LEONARD D. WOREN OF     *
*  THE UCLA COMPUTER CLUB.                                            *
*                                                                     *
*  MODIFIED  1979 BY WALT FARRELL, RAINIER NATIONAL BANK              *
*                                                           * 09/84 DBC
*  HI GUYS. GEE, CAN I PLAY TOO?                            * 09/84 DBC
*                                                                     *
***********************************************************************
         EJECT ,                                              09/84 DBC
************************************************************* 09/84 DBC
*                                                           * 09/84 DBC
* LAST CHANGE DATE - OCTOBER 1, 1984                        * 09/84 DBC
*                                                           * 09/84 DBC
*                  - I RECEIVED FROM ARNIE CASINGHINO (OF   * 09/84 DBC
*                    THE CONNECTICUT BANK AND TRUST) A TAPE * 09/84 DBC
*                    CONTAINING A VERSION OF TAPEMAP THAT   * 09/84 DBC
*                    WAS BASED ON AN EARLIER UCLA VERSION   * 09/84 DBC
*                    AND WAS MODIFIED BY WALT FARRELL OF    * 09/84 DBC
*                    THE RAINIER NATIONAL BANK. THE MODS    * 09/84 DBC
*                    WERE MAINLY IN SUPPORT OF DETAILED     * 09/84 DBC
*                    LISTINGS OF THE CONTENTS OF FDR AND    * 09/84 DBC
*                    FDRDSF TAPES. I HAVE NOW TRANSPORTED   * 09/84 DBC
*                    THOSE MODS INTO THIS VERSION OF        * 09/84 DBC
*                    TAPEMAP.                               * 09/84 DBC
*                                                           * 09/84 DBC
*                  - I ADDED SUPPORT FOR BLKSIZES GREATER   * 09/84 DBC
*                    THAN 32K UP TO 64K-1 BYTES. (THE       * 09/84 DBC
*                    RECENT RELEASES OF FDR WRITE BLOCKS    * 09/84 DBC
*                    THAT ARE 50K LARGE OR LARGER).         * 09/84 DBC
*                                                           * 09/84 DBC
*                  - I HAVE ADDED A REWIND COMMAND JUST     * 09/84 DBC
*                    AFTER THE TAPE IS OPENED TO INSURE     * 09/84 DBC
*                    THAT THE TAPE IS PROPERLY POSITIONED.  * 09/84 DBC
*                    THIS MAKES MAPPING STANDARD LABELED    * 09/84 DBC
*                    TAPES IN A UCC/1 ENVIRONMENT A LITTLE  * 09/84 DBC
*                    EASIER.                                * 09/84 DBC
*                                                           * 09/84 DBC
************************************************************* 09/84 DBC
         EJECT ,                                              06/84 DBC
************************************************************* 06/84 DBC
*                                                           * 06/84 DBC
* LAST CHANGE DATE - JUNE 4, 1984                           * 06/84 DBC
*                                                           * 06/84 DBC
*                  - ADDED OPSYN STATEMENTS TO SUPPRESS THE * 06/84 DBC
*                    AUTHOR'S USE OF "PRINT NOGEN".         * 06/84 DBC
*                                                           * 06/84 DBC
*                  - ADDED CODE TO RECOGNIZE FILES IN       * 06/84 DBC
*                    IEBUPDAT RELOAD FORMAT.                * 06/84 DBC
*                                                           * 06/84 DBC
*                  - DELETED THE SILLY JFCBDSNM CHANGE THAT * 06/84 DBC
*                    MADE TAPE MANAGEMENT SYSTEMS SO        * 06/84 DBC
*                    UNHAPPY.                               * 06/84 DBC
*                                                           * 06/84 DBC
*                  - UPDATED THE LIST OF KNOWN DEVICE TYPES * 06/84 DBC
*                    TO INCLUDE 3375S AND 3380S.            * 06/84 DBC
*                                                           * 06/84 DBC
*                  - CHANGED THE PARM DEFAULT FROM NOSCAN   * 06/84 DBC
*                    TO SCAN.                               * 06/84 DBC
*                                                           * 06/84 DBC
*                  - ADDED THE "INFO SOURCE" COLUMN TO THE  * 06/84 DBC
*                    SYSPRINT OUTPUT.                       * 06/84 DBC
*                                                           * 06/84 DBC
*                  - FIXED THE CCC ON THE LINE OF DASHES    * 06/84 DBC
*                    (WAS RANDOM, NOW IS C' ').             * 06/84 DBC
*                                                           * 06/84 DBC
************************************************************* 06/84 DBC
         EJECT
***********************************************************************
*                                                                     *
*   UPDATES:                                                          *
*                                                                     *
*  ADD CHECK FOR FILE WITH HEADER OF                     05/01/79 WBF *
*    $$TAPEMAP.PRINT.FILE$$                                           *
*  AND PRINT THE CONTENTS OF THE FILE                                 *
*  IF ONE IS FOUND                                                    *
*                                                                     *
*  LIST DETAILS OF SLICK BACKUP FILES                    04/23/79 WBF *
*                                                                     *
*  FIX MINOR BUGS IN NL CODE,                            04/08/79 WBF *
*  LIST DETAILS OF FDR OR FDRDSF FILES,                      "        *
*  FORCE BLP AND EXPDT=98000 (FOR UCC-1),                    "        *
*  COSMETIC CHANGES FOR RAINIER NATIONAL BANK                "        *
*                                                                     *
*                                                                     *
*  FIX BUG IN I/O ERROR RECOVERY                     U16 06/16/79 LDW *
*                                                                     *
*  FIX VOLSER FOR NL TAPES;  PRINT SENSE BIT MEANINGS;  CHANGE FORMAT *
*  OF "REQUESTED VOL" MSG;  FIX ./DDNAME= BUG        U15 02/10/79 LDW *
*                                                                     *
*  RE-ARRANGE CODE, ADD 'NULL=' PARM.                U14 06/28/78 LDW *
*                                                                     *
*  PRINT SENSE INFO WHEN I/O ERROR OCCURS            U13 05/05/78 LDW *
*                                                                     *
*  FIX A COUPLE OF TURKEY BUGS                03/24/78 - 04/06/78 LDW *
*                                                                     *
*  LIST MEMBERS IN AN IEBUPDTE INPUT STREAM              02/22/78 LDW *
*                                                                     *
*  LIST MEMBERS UNLOADED BY IEHMOVE                      01/05/78 LDW *
*                                                                     *
*  NL TAPE ANALYSIS CODE ADDED                           12/26/77 LDW *
*                                                                     *
*  DO A SENSE TO DETERMINE TRUE TAPE DENSITY             11/14/77 LDW *
*                                                                     *
*  FIX SOME MISCELLANEOUS MINOR BUGS                     11/08/77 LDW *
*                                                                     *
*  ADD CODE TO LIST MEMBERS UNLOADED BY IEBCOPY, AND ATTRS FOR        *
*     IEBISAM AND IEHDASDR UNLOADED DATASETS.            03/16/77 LDW *
*                                                                     *
*  GENERAL RE-WRITING OF TAPE READ CODE TO PUT IN CODE TO PRINT OUT   *
*     THE ORIGINAL ATTRS FOR UNLOADED DATASETS CREATED BY IEHMOVE     *
*     (SYSMOVE) AND IEBCOPY (VS2COPY);  CHANGE TAPE I/O ERROR AND     *
*     TAPE MARK DETECTION ALGORITHM.                     02/13/77 LDW *
*                                                                     *
*  PUT IN DSECTS FOR LABELS;  FIX A 01/06/77 BUG;  RE-WRITE PRINTLIN  *
*     MACRO (CHANGE TO PRTLN)                            02/07/77 LDW *
*                                                                     *
*  MORE FIXES:  COUNT LINES AND DO PAGE EJECT;  AND MUCH OTHER        *
*     MISCELLANEOUS STUFF                                01/06/77 LDW *
*                                                                     *
*  UNCLUDGED A LITTLE:  FIX LENGTH CALCULATION;  MAKE SOME MACROS     *
*     INTO SUBROUTINES (IT SEEMS THAT MSM NEVER HEARD OF SUBROUTINES; *
*     PUT IN SYMBOLIC OFFSETS FOR PRINT LINE INFO.       11/08/76 LDW *
*                                                                     *
*  TAPEINDX -- CLUDGED UP IN A HURRY FROM A SPASM PROGRAM TO MAKE A   *
*          QUICK LOAD MODULE                             10/30/74 MSM *
*                                                                     *
***********************************************************************
         EJECT
         MACRO
&NFS     FL2   &DSECT=YES
         LCLC  &P
&P       SETC  'FL2'
         AIF   ('&NFS' EQ '').NO$NFS
&P       SETC  '&NFS'
.NO$NFS  AIF   ('&DSECT' NE 'YES').NODSECT
&P.D     DSECT
.NODSECT ANOP
.***************
&P.LABI  DC    C'HDR'                   OR 'EOF' OR 'EOV'
&P.NO    DC    C'2'                     CONSTANT
&P.RECFM DC    C' '                     F/V/U/D
&P.BLKL  DC    CL5' '                   BLKSIZE
&P.LRECL DC    CL5' '                   RECORD LEN (X=99999)
&P.DEN   DC    C' '                     DENSITY (C'0' TO C'3')
&P.FILP  DC    C' '                     1=VOL SW OCCURRED, 0=NOT
&P.JOBD  DC    CL8' '                   JOBNAME OF CREATOR
&P.JSSP  DC    C'/'                     SLASH
&P.STEPD DC    CL8' '                   STEPNAME OF CREATOR
&P.TRTCH DC    CL2' '
&P.CNTRL DC    C' '                     A/M/<BLANK>
         DC    C' '
&P.BLKA  DC    C' '                     B/S/R/<BLANK>
         DC    CL41' '
         SPACE 2
         MEND
         EJECT ,                                              09/84 DBC
         MACRO
&NFS     FL1   &DSECT=YES
         LCLC  &P
&P       SETC  'FL1'
         AIF   ('&NFS' EQ '').NO$NFS
&P       SETC  '&NFS'
.NO$NFS  AIF   ('&DSECT' NE 'YES').NODSECT
&P.D     DSECT
.NODSECT ANOP
&P.LABI  DC    C'HDR'                   OR 'EOF' OR 'EOV'
&P.NO    DC    C'1'                     CONSTANT
&P.ID    DC    CL17' '                  DATASET NAME
&P.FILSR DC    CL6' '                   FIRST VOL NAME
&P.VOLSQ DC    CL4' '                   VOL # OF DS
&P.FILSQ DC    CL4' '                   DS SEQ #
&P.GNO   DC    CL4' '                   GENERATION NUMBER
&P.VNG   DC    CL2' '                   VERSION NUMBER
&P.CREDT DC    CL6' YYDDD'              CREATION DATE
&P.EXPDT DC    CL6' YYDDD'              EXPIRATION DATE
&P.FSEC  DC    C' '                     0=NO PW, 1=PW, 3=NOPWREAD
&P.BLKCT DC    CL6' '                   # OF BLOCKS
&P.SYSCD DC    CL13' '
         DC    CL7' '
         SPACE 2
         MEND
         EJECT ,                                              09/84 DBC
         MACRO
&NFS     VOL   &DSECT=YES
         LCLC  &P
&P       SETC  'VOL'
         AIF   ('&NFS' EQ '').NO$NFS
&P       SETC  '&NFS'
.NO$NFS  AIF   ('&DSECT' NE 'YES').NODSECT
&P.D     DSECT
.NODSECT ANOP
&P.LABI  DC    C'VOL'                   CONSTANT
&P.NO    DC    C'1'                     CONSTANT
&P.SERNO DC    CL6'VOLSER'              VOLUME NAME
         DC    C'0'
         DC    CL30' '
&P.OWNER DC    CL10' '                  OWNER ID
         DC    CL29' '
         SPACE 2
         MEND
         EJECT ,                                              09/84 DBC
         MACRO
&NFS     HEXTAB &DUAL=YES
.*  HEXTAB  LDW  UPDATED 02-21-79
.*  UPDATED 03-17-79
         GBLC  &HEXTAB#
         LCLC  &N
&N       SETC  '&NFS'                   ASSUME GIVEN
         AIF   ('&N' NE '').OK          YEP - USE IT
&N       SETC  '&HEXTAB#'               ASSUME GLOBAL PRESENT
         AIF   ('&N' NE '').OK          YEP - USE IT
&HEXTAB# SETC  'HEXTAB'                 ELSE, SET IT
&N       SETC  'HEXTAB'                 HERE TOO
.OK      AIF   ('&DUAL' EQ 'YES').DUAL
&N       EQU   *-C'0'
         DC    C'0123456789ABCDEF'
         MEXIT
.DUAL    ANOP
&N       EQU   *-C'A'
         DC    X'0A0B0C0D0E0F'
         ORG   &N+C'0'
         DC    C'0123456789ABCDEF'
         ORG
         MEND
         EJECT ,                                              09/84 DBC
         MACRO
&NFS     HEX   &TO,&FROM,&L,&LEN=,&HEXTAB=,&BYTE=C' ',&DIGITS=
.*  HEX -- 12/18/76 -- LDW      FIXED 5-2-77    12-25-77
.*      REWRITTEN FROM SCRATCH -- 01/29/79  FIXED  02-16-79  03-03-79
.*      UPDATED  04-21-79
         GBLC  &HEXTAB#
         LCLA  &LT                      UNPK "TO" LENGTH
         LCLA  &LF                      UNPK "FROM" LENGTH
         LCLA  &LTR                     TR "TO" LENGTH
         LCLA  &LL                      &LEN ONE WAY OR ANOTHER
         LCLC  &F1,&F2,&T1,&T2,&LX
&F1      SETC  '&FROM(1)'               FOR SHORTER STRING LATER
&F2      SETC  '&FROM(2)'               FOR SHORTER STRING LATER
&T1      SETC  '&TO(1)'                 FOR SHORTER STRING LATER
&T2      SETC  '&TO(2)'                 FOR SHORTER STRING LATER
&LX      SETC  '&L&LEN'                 GET LENGTH USING EITHER METHOD
         AIF   ('&LX' EQ '').DEFLEN     LENGTH WILL DEFAULT TO 4
&LL      SETA  &LX                      GET IT
         AGO   .OKLEN
.DEFLEN  ANOP
&LL      SETA  4                        SET THE DEFAULT LENGTH
.OKLEN   AIF   ('&HEXTAB' EQ '').OKHEX1
&HEXTAB# SETC  '&HEXTAB'
.OKHEX1  AIF   ('&HEXTAB#' NE '').OKHEX2
&HEXTAB# SETC  'HEXTAB'
.OKHEX2  ANOP
&LT      SETA  &LL*2
         AIF   ('&DIGITS' EQ '').OKDIGIT
&LT      SETA  &DIGITS
.OKDIGIT AIF   (N'&TO NE 2).TO1
         AIF   (N'&FROM NE 2).T2F1
.*  N'&TO = 2     N'&FROM = 2
&NFS     UNPK  &T1.(&LT+1,&T2),&F1.(&LL+1,&F2)
         TR    &T1.(&LT,&T2),&HEXTAB#
         MVI   &T1+&LT.(&T2),&BYTE
         AGO   .DONE
.T2F1    AIF   (N'&FROM NE 1).ERRF
.*  N'&TO = 2     N'&FROM = 1
&NFS     UNPK  &T1.(&LT+1,&T2),&FROM.(&LL+1)
         TR    &T1.(&LT,&T2),&HEXTAB#
         MVI   &T1+&LT.(&T2),&BYTE
         AGO   .DONE
.TO1     AIF   (N'&TO NE 1).ERRT
         AIF   (N'&FROM NE 2).T1F1
.*  N'&TO = 1     N'&FROM = 2
&NFS     UNPK  &TO.(&LT+1),&F1.(&LL+1,&F2)
         TR    &TO.(&LT),&HEXTAB#
         MVI   &TO+&LT,&BYTE
         AGO   .DONE
.T1F1    AIF   (N'&FROM NE 1).ERRF
.*  N'&TO = 1     N'&FROM = 1
&NFS     UNPK  &TO.(&LT+1),&FROM.(&LL+1)
         TR    &TO.(&LT),&HEXTAB#
         MVI   &TO+&LT,&BYTE
         AGO   .DONE
.ERRF    MNOTE 8,'ERROR IN "FROM" PARAMETER, MACRO TERMINATED'
         MEXIT
.ERRT    MNOTE 8,'ERROR IN "TO" PARAMETER, MACRO TERMINATED'
         MEXIT
.DONE    SPACE 1
         MEND
         EJECT ,                                              09/84 DBC
         MACRO
&NFS     MONTHS  &DUMMY                 04-19-77 LDW
&NFS     DC    H'31',C'JAN '            THIRTY DAYS
         DC    H'28',C'FEB '            HATH SEPTEMBER,
         DC    H'31',C'MAR '            APRIL, JUNE,
         DC    H'30',C'APR '            AND NOVEMBER.
         DC    H'31',C'MAY '            ALL THE REST
         DC    H'30',C'JUN '            HAVE THIRTY ONE,
         DC    H'31',C'JUL '            EXCEPT FEBRUARY,
         DC    H'31',C'AUG '            WHICH HAS ONLY 28.
         DC    H'30',C'SEP '
         DC    H'31',C'OCT '
         DC    H'30',C'NOV '
         DC    H'31',C'DEC '
         SPACE 2
         MEND
         EJECT ,                                              09/84 DBC
         MACRO
&NFS     DAYS  &TYPE,&LEN=9                                04-19-77 LDW
         AIF   ('&TYPE' EQ 'RIGHT').RIGHT
&NFS     DC    CL&LEN'SUNDAY   '
         DC    CL&LEN'MONDAY   '
         DC    CL&LEN'TUESDAY  '
         DC    CL&LEN'WEDNESDAY'
         DC    CL&LEN'THURSDAY '
         DC    CL&LEN'FRIDAY   '
         DC    CL&LEN'SATURDAY '
         AGO   .EXIT
.RIGHT   ANOP
&NFS     DC    CL&LEN'   SUNDAY'
         DC    CL&LEN'   MONDAY'
         DC    CL&LEN'  TUESDAY'
         DC    CL&LEN'WEDNESDAY'
         DC    CL&LEN' THURSDAY'
         DC    CL&LEN'   FRIDAY'
         DC    CL&LEN' SATURDAY'
.EXIT    SPACE 2
         MEND
         EJECT ,                                              09/84 DBC
         MACRO
&NFS     TODAY &LOC,&MONTHS=MONTHS,&DAYS=DAYS,&WORK=DWD,               $
               &PUNCT=YES,&WEEKDAY=,&TIME=,                            $
               &F15==F'15',&F6==F'6',&H2==H'2',&H12==H'12',            $
               &H10==H'10',&H13==H'13',&F5==F'5',&H34==H'34',          $
               &F7==F'7'                                   06-23-78 LDW
         LCLC  &LQ
&LQ      SETC  'L'''
&LQ      SETC  '&LQ&DAYS'
&NFS     L     R1,16                    -> CVT
         UNPK  &LOC+16(5),57(3,R1)      UNPK THE DATE
         OI    &LOC+20,C'0'             FIX THE SIGN
         MVC   &LOC+15(2),&LOC+16       MOVE THE YEAR OVER
         MVI   &LOC+17,C'.'             PUT IN THE DOT
         AIF   ('&PUNCT' NE 'YES').NOP1
         MVI   &LOC+14,C'('
         MVI   &LOC+21,C')'
.NOP1    TM    57(R1),X'01'             LEAP YEAR?
         BO    IHB&SYSNDX.N             NO (ODD YEAR) - NOT LEAP
         TM    57(R1),X'12'             DIVISIBLE BY 4?
         BM    IHB&SYSNDX.N             NO - NOT LEAP YEAR
         MVI   &MONTHS+7,29             FEB HAS 29 DAYS THIS YEAR
         SPACE 1
IHB&SYSNDX.N MVC &WORK+6(2),58(R1)      COPY DDDF
         XC    &WORK.(6),&WORK          CLEAR BEGINNING
         CVB   R0,&WORK                 GET DAY OF YEAR IN BINARY
         LA    R15,&MONTHS              POINT TO TABLE
         SPACE 1
IHB&SYSNDX.L SH R0,0(,R15)              SUB NUMBER OF DAYS THIS MONTH
         BNP   IHB&SYSNDX.H             HAVE MONTH
         LA    R15,6(,R15)              NEXT TABLE ENTRY
         B     IHB&SYSNDX.L             KEEP LOOKING
         SPACE 1
IHB&SYSNDX.H MVC &LOC.(3),2(R15)        MOVE NAME OF MONTH
         AH    R0,0(,R15)               GET BACK CORRECT RESIDUAL
         CVD   R0,&WORK
         UNPK  &LOC+4(2),&WORK+6(2)     DAY OF MONTH
         OI    &LOC+5,C'0'              FIX SIGN
         MVC   &LOC+10(2),&LOC+15       MOVE IN YEAR
         AIF   ('&PUNCT' NE 'YES').NOP2
         MVC   &LOC+6(4),=C', 19'
.NOP2    AIF   ('&WEEKDAY' EQ '').NODAY
         ST    R0,&WORK                 SAVE DAY OF MONTH
.*
.* MONTH=MOD(MONTH+9,12)+1
.* IF (MONTH=11 × MONTH=12) YEAR=YEAR-1  ==> IF MONTH > 10 YEAR=YEAR-1
.* A=(13*MONTH-1)/5
.* B=YEAR/4
.* C=CENTURY/4
.* D=A+B+C+DAY+YEAR-2*CENTURY
.* Z=MOD(D,7)+1
.* WHERE Z=DAY OF WEEK, 1=SUNDAY,... 7=SATURDAY
.*
.* THIS MACRO ASSUMES 1900-1999... IE, CENTURY=19
         SPACE 2
         LA    R14,&MONTHS-6
         SR    R15,R14                  GET MONTH # * 6
         XR    R14,R14                  CLEAR FOR DIVIDE
         D     R14,&F6                  GET MONTH #
* MONTH=MOD(MONTH+9,12)+1
         SH    R15,&H2
         BP    *+8
         AH    R15,&H12
.***     XR    R14,R14                  CLEAR FOR DIVIDE
.***     LA    R15,9(,R15)              MONTH+9
.***     D     R14,=F'12'               DIVIDE BY 12
.***     LA    R14,1(,R14)
         SPACE 1
         IC    R0,57(,R1)               GET YEAR
         SRL   R0,4
         N     R0,&F15
         MH    R0,&H10
         IC    R1,57(,R1)
         N     R1,&F15
         AR    R1,R0                    = YEAR IN BINARY
         SPACE 1
         CH    R15,&H10                 MONTH = 11 OR 12 ?
         BNH   *+6                      NO - SKIP
         BCTR  R1,0                     -1 FROM YEAR
* A=(13*MONTH-1)/5
         MH    R15,&H13                 MONTH * 13
         BCTR  R15,0                    -1
         XR    R14,R14                  CLEAR FOR DIVIDE
         D     R14,&F5                  ALL OVER 5 (R5=A)
* B=YEAR/4
         LR    R0,R1                    COPY YEAR
         SRL   R0,2                     YEAR/4
         AR    R15,R0                   D=A+B SO FAR
* C=CENTURY/4 = 19/4 = 4                CENTURY*2 = 19*2 = 38
* +C-2*CENTURY = -34
         SH    R15,&H34                 D=A+B+C-2*CENT NOW
* D=A+B+C+DAY+YEAR-2*CENTURY
         A     R15,&WORK                ADD DAY
         AR    R15,R1                   ADD YEAR
* Z=MOD(D,7)+1
         XR    R14,R14                  CLEAR FOR DIVIDE
         D     R14,&F7                  GET MOD(D,7) IN R4=Z
         MH    R14,=Y(&LQ)              OFFSET INTO TABLE
         LA    R14,&DAYS.(R14)          POINT TO DAY IN TABLE
         MVC   &WEEKDAY.(&LQ),0(R14)    DAY TO OUTPUT LOCATION
*  SEEMS LIKE A LOT, BUT BETTER THAN AN SVC CALL, AND TRANSPORTABLE!!
.NODAY   AIF   ('&TIME' EQ '').NOTIME
         SPACE 2
*        TIME  DEC                      GET TIME
         TIME  DEC                      GET TIME
         ST    R0,&WORK                 PUT TIME INTO WORK AREA
         OI    &WORK+3,X'0F'            FIX THE SIGN
         MVC   &TIME.(9),=X'4021207A20207A2020'      ' DD:DD:DD'
         ED    &TIME.(9),&WORK
.NOTIME  SPACE 2
         MEND
         EJECT ,                                              09/84 DBC
         MACRO
&NFS     DCBEXIT  &BLKSIZE=,&BUFNO=
.*  DCBEXIT   04-20-78  LDW
         LCLC  &NAME
&NAME    SETC  '&NFS'
         PUSH  USING
         DROP
         USING *,R15
         AIF   ('&BLKSIZE' EQ '').B1
&NAME    CLC   62(2,R1),=F'0'           BLKSIZE GIVEN?
&NAME    SETC  ''
         AIF   ('&BUFNO' EQ '').A1
         BNE   *+10                     YES - USE IT
         AGO   .A2
.A1      BNER  R14                      YES - USE IT
.A2      MVC   62(2,R1),=Y(&BLKSIZE)    SET DEFAULT
.B1      AIF   ('&BUFNO' EQ '').C1
&NAME    CLI   20(R1),0                 BUFNO GIVEN?
         BNER  R14                      YES - USE IT
         MVI   20(R1),&BUFNO            SET DEFAULT
.C1      BR    R14                      RETURN TO OPEN
         SPACE 2
         POP   USING
         SPACE 3
         MEND
         EJECT ,                                              09/84 DBC
         MACRO
         $$ASM &M=(JAN,FEB,MAR,APR,MAY,JUN,JUL,AUG,SEP,OCT,NOV,DEC)
.*.
.*$MACRO=$$ASM      DATE=10/07/79       SOURCE=LDW
.*
.*  THIS MACRO SETS GBLC'S FOR VARIOUS DATE AND TIME FORMATS:
.*
.*       &$$DATE1    DDMMMYY (EX: 29NOV79)
.*       &$$DATE2    MM/DD/YY
.*       &$$ASM      ASSEMBLER: 'F'=FX, 'G', 'H', 'S'=SPASM
.*       &$$MM       MM OF CURRENT MONTH (NUMERIC)
.*       &$$DD       DD OF CURRENT DAY (NUMERIC)
.*       &$$YY       YY OF CURRENT DAY (LAST 2 DIGITS)
.*       &$$MONTH    MMM - 3 CHAR MONTH ABBREV.
.*       &$$DAY      (NOT CURRENTLY SET)
.*       &$$YEAR     4 DIGIT YEAR
.*.
         GBLC  &$$DATE1,&$$DATE2,&$$ASM
         GBLC  &$$MM,&$$DD,&$$YY
         GBLC  &$$MONTH,&$$DAY,&$$YEAR
         LCLC  &D
         LCLA  &I
&D       SETC  '&SYSDATE'
         AIF   ('&D'(3,1) EQ '/').D1
.*  ASMG:  10JUL79
&$$ASM   SETC  'G'
&$$YY    SETC  '&D'(1,2)                GET YEAR YY
&$$MONTH SETC  '&D'(3,3)                GET MONTH MMM
         AIF   (K'&D EQ 6).D2
&$$DD    SETC  '&D'(6,2)                GET DAY DD
         AGO   .D3
.D2      ANOP
&$$DD    SETC  '0&D'(6,1)               GET DAY 0D
.D3      ANOP
&$$DATE1 SETC  '&$$DD&$$MONTH&$$YY'     SET DDMMMYY
.D3A     ANOP
&I       SETA  &I+1
         AIF   ('&$$MONTH' NE '&M(&I)').D3A    FIND MONTH NAME
&$$MM    SETC  '&I'
         AIF   (&I GT 9).D4
&$$MM    SETC  '0&I'
.D4      ANOP
&$$DATE2 SETC  '&$$MM/&$$DD/&$$YY'      SET MM/DD/YY
         AGO   .COMMON
.D1      ANOP
&$$DATE2 SETC  '&D'                     SET MM/DD/YY
&$$MM    SETC  '&D'(1,2)                GET MM
&$$DD    SETC  '&D'(4,2)                GET DD
&$$YY    SETC  '&D'(7,2)                GET YY
&$$MONTH SETC  '&M(&$$MM)'              GET MONTH MMM
&$$DATE1 SETC  '&$$DD&$$MONTH&$$YY'
.*  NOW: ASMF(X) OR ASMH OR SPASM?
&D       SETC  'ABCDEFGHI'
         AIF   (K'&D EQ 8).D5           ASMF OR SPASM
&$$ASM   SETC  'H'
         AGO   .COMMON
.D5      AIF   (K'&SYSTIME GT 5).D6
&$$ASM   SETC  'F'
         MEXIT
.D6      ANOP
&$$ASM   SETC  'S'
.COMMON  ANOP
&$$YEAR  SETC  '19&$$YY'                GET 19YY
         MEND
         EJECT ,                                              09/84 DBC
         MACRO
         DROPX &PARMS,&DUMMY
         GBLB  &USESKIP                 USNGX SKIPPED SAVE TABLE SETUP
         GBLC  &USELAB(32),&USEREG(16)  PGM LABELS,REGISTERS USED
         LCLA  &RCNT,&UNDX              # OF OPERANDS, USE INDICES
         LCLA  &PNDX,&DNDX              INPUT PARM,DROP STRING INDICES
         LCLC  &C(16),&R(16)            COMMAS,REGS TO DROP
         LCLB  &GOTREG                  FOUND A REG FOR DROP
&RCNT    SETA  N'&SYSLIST               COUNT THE OPERANDS/REGISTERS
         AIF   ((&RCNT EQ 0) OR ('&PARMS' EQ '')).DROPALL BR IF ALL
.COMLOOP ANOP                           BUILD COMMA/REG LIST LOOP
&PNDX    SETA  &PNDX+1                  UP THE COMMA/REG INDEX
&UNDX    SETA  0                        INITIALIZE USE ARRAY INDEX
.REGCHK  ANOP                           VALID DROP REG CHECK LOOP
&UNDX    SETA  &UNDX+1                  UP THE USE ARRAY COUNT
         AIF   ('&USEREG(&UNDX)' EQ '&SYSLIST(&PNDX)').SETREG REG OK?
         AIF   (&UNDX LT 16).REGCHK     LOOP FOR ALL ENTRIES IF NEEDED
         MNOTE 4,'REGISTER &SYSLIST(&PNDX) WAS NOT A USNGX OPERAND'
         AIF   (NOT &USESKIP).REGLOOP   NO DROP IF USNGX DID NO SKIPS
.SETREG  ANOP
&DNDX    SETA  &DNDX+1                  UP THE DROP STRING INDEX
&R(&DNDX) SETC '&SYSLIST(&PNDX)'        GET A REG
&C(&DNDX) SETC ','                      AND A COMMA
&USEREG(&UNDX) SETC ''                  BLANK THE REG/INDICATOR FIELD
&GOTREG  SETB  1                        SAY HAVE SOMETHING TO DROP
.REGLOOP AIF   (&PNDX LT &RCNT).COMLOOP LOOP TIL DONE WITH REGS
.DROPGO  AIF   (NOT &GOTREG).EXIT       SKIP THE DROP IF NOTHING TO DO
&C(&DNDX) SETC ''                       KILL THE LAST COMMA
         DROP  &R(1)&C(1)&R(2)&C(2)&R(3)&C(3)&R(4)&C(4)&R(5)&C(5)&R(6)&^
               C(6)&R(7)&C(7)&R(8)&C(8)&R(9)&C(9)&R(10)&C(10)&R(11)&C(1^
               1)&R(12)&C(12)&R(13)&C(13)&R(14)&C(14)&R(15)&C(15)&R(16)
.EXIT    MEXIT
.DROPALL AIF   (&UNDX GE 16).DROPGO     CHECK FOR END OF TABLE
&UNDX    SETA  &UNDX+1                  UP THE USE INDEX COUNT
         AIF   ('&USEREG(&UNDX)'  EQ '').DROPALL
&DNDX    SETA  &DNDX+1                  UP THE DROP STRING INDEX
&R(&DNDX) SETC '&USEREG(&UNDX)'         GET REG FOR THE DROP
&C(&DNDX) SETC ','                      AND A DELIMITER
&USEREG(&UNDX) SETC ''                  KILL THE REG/INDICATOR
&GOTREG  SETB  1                        SAY WE FOUND SOMETHING
         AGO   .DROPALL                 CONTINUE WITH THE SCAN
         MEND
         EJECT ,                                              09/84 DBC
         MACRO
         INUSE &DUMMY
         GBLC  &USELAB(32),&USEREG(16)  PGM LABELS,REGISTERS USED
         LCLA  &UCNT                    USE INDEX
         LCLB  &GOTREG                  WHETHER WE FOUND REGS IN USE
         SPACE 2
         MNOTE *,'THE FOLLOWING REGISTERS ARE IN USE:'
         SPACE 1
.USELOOP ANOP                           USED REGS LOOP
&UCNT    SETA  &UCNT+1                  UP THE USE INDEX
         AIF   ('&USEREG(&UCNT)' EQ '').CHKEND THIS ENTRY IN USE?
         MNOTE *,'    &USELAB(&UCNT+&UCNT-1)&USELAB(&UCNT+&UCNT),&USERE^
               G(&UCNT)'
&GOTREG  SETB  1                        SAY WE FOUND SOMETHING
.CHKEND  AIF   (&UCNT LT 16).USELOOP    CHECK FOR END OF ARRAY
         AIF   (&GOTREG).EXIT           LEAVE IF WE HAD REGS IN USE
         MNOTE *,'    *** NONE ****'
.EXIT    ANOP
         SPACE 2
         MEND
         EJECT ,                                              09/84 DBC
         MACRO
         USNGX &PARMS
         GBLB  &USESKIP                 IF TABLE SETUP SKIPPED (DROPX)
         GBLC  &USELAB(32),&USEREG(16)  PGM LABELS,USE REGISTERS
         LCLA  &RCNT,&PNDX,&UNDX        # OF OPERANDS,PARM/USE INDICES
         LCLA  &TP1,&HOLE               TEMP WORK,1ST UNUSED SAVE ENTRY
         LCLB  &GOTREG                  WHETHER TO DO USING OR NOT
         LCLC  &CHR1,&CHR2,&CHR3,&C(16) TEMPORARY WORK CHARS,COMMAS
         LCLC  &R(16),&S,&T             REGS,&SYSLIST(1)+REMAINDER
         LCLC  &U,&V,&W                 R(15),C(16),R(16)
&PNDX    SETA  1                        SET UP PARM STRING INDEX
&RCNT    SETA  N'&SYSLIST               GET NUMBER OF OPERANDS
         AIF   (&RCNT LE 1).ERR01       TOO FEW INPUT PARAMETERS
         AIF   (&RCNT LE 17).CHK01      CONTINUE IF LOW ENOUGH
&RCNT    SETA  17                       ELSE GET MAX
         MNOTE 4,'TOO MANY INPUT PARAMETERS. ONLY 17 PROCESSED'
.CHK01   AIF   (((K'&SYSLIST(1) LE 16) AND (&RCNT EQ 02)) OR           @
               ((K'&SYSLIST(1) LE 11) AND (&RCNT LE 04)) OR            @
               ((K'&SYSLIST(1) LE 10) AND (&RCNT LE 17))).SYS1#CK
         MNOTE 12,'LENGTH OF ''&SYSLIST(1)'' OR LENGTH PLUS NUMBER OF R@
               EGISTERS INHIBIT SAVE TABLE PROCESSING'
&USESKIP SETB  1                        TELL DROPX TO ALWAYS DROP
         AIF   (&RCNT EQ 2).USE#TRY     NO MSG IF ONLY TWO OPERANDS
         MNOTE 4,'ONLY USING FOR FIRST DATA AREA/REG GENERATED'
.USE#TRY USING &SYSLIST(1),&SYSLIST(2)
         MEXIT
.SYS1#CK ANOP
&S       SETC  '&SYSLIST(1)'            SET FOR SHORTER STRING BELOW
         AIF   (K'&SYSLIST(1) LE K'&S).COMLOOP BRANCH IF NO MORE CHARS
.******  NOTE THE FOLLOWING SETC ASSUMES THE MAX SETC SIZE IS 8 CHARS.
&T       SETC  '&SYSLIST(1)'(9,K'&SYSLIST(1)-8) ELSE GET REMAINDER
.COMLOOP ANOP
&PNDX    SETA  &PNDX+1                  INCREMENT INPUT STRING INDEX
&UNDX    SETA  0                        INITIALIZE USE INDEX
&HOLE    SETA  0                        INITIALIZE UNUSED ENTRY INDEX
.USELOOP AIF   ('&SYSLIST(&PNDX)' EQ '').CHK#END BR IF NULL STRING
&UNDX    SETA  &UNDX+1                  UP THE USE INDEX
         AIF   ('&USEREG(&UNDX)' EQ '&SYSLIST(&PNDX)').DO#USE PREVUSE?
         AIF   ((&HOLE NE 0) OR ('&USEREG(&UNDX)' NE '')).CHKEND
.* WE BRANCH TO CHKEND IF WE ALREADY HAVE A HOLE OR NO HOLE EXISTS HERE
&HOLE    SETA  &UNDX                    KEEP THE SAVE TABLE FREE INDEX
.CHKEND  AIF   (&UNDX LT 16).USELOOP    LOOP FOR ALL ENTRIES
&UNDX    SETA  &HOLE                    GET FREE ENTRY INDEX IN CASE
         AIF   (&HOLE NE 0).DO#USE2     BRANCH IF SPACE FOR ENTRY
         MNOTE 4,'USNGX SAVE TABLE FULL. OPERAND TRUNCATED'
         AGO   .USINGGO                 GO DO JUST WHAT WE CAN
.DO#USE  ANOP
&CHR1    SETC  '********'(1,K'&SYSLIST(&PNDX)) STARS FOR THE REG
&CHR2    SETC  '********'(1,K'&USELAB(&UNDX+&UNDX-1)) FIRST OPERAND SEG
&CHR3    SETC  '&USELAB(&UNDX+&UNDX)'   GET NULL STRING POSSIBLY
         AIF   (K'&CHR3 EQ 0).DO#USE1   SKIP IF IT IS NULL
&CHR3    SETC  '********'(1,K'&CHR3)    ELSE CONVERT IT TO STARS
.DO#USE1 MNOTE *,'*********&CHR1*********************&CHR2&CHR3'
         MNOTE *,'REGISTER &SYSLIST(&PNDX) PREVIOUSLY BASED ON &USELAB(@
               &UNDX+&UNDX-1)&USELAB(&UNDX+&UNDX)'
         MNOTE *,'*********&CHR1*********************&CHR2&CHR3'
.DO#USE2 ANOP                           LOG THE REG USE HERE
&CHR1    SETC  '&SYSLIST(1)'            GET A DEFAULT LABEL
&CHR2    SETC  '&T'                     SECOND PIECE IF ANY OR NULL
         AIF   (&PNDX EQ 2).SETLAB      IF FIRST REG, NO +NNNN TO ADD
&TP1     SETA  (&PNDX-2)*4096           ELSE GET ADDED AMOUNT
&CHR2    SETC  '&CHR2'.'+'.'&TP1'       APPEND THE +NN FOR EXTRA REGS
.SETLAB  ANOP                           MOVE IN THE SAVE LABELS HERE
&USELAB(&UNDX+&UNDX-1) SETC '&CHR1'     FIRST 'HALF'
&USELAB(&UNDX+&UNDX)   SETC '&CHR2'     AND THE REST
&USEREG(&UNDX) SETC '&SYSLIST(&PNDX)'   GET THE REG VALUE IN SAVEAREA
&R(&PNDX-1) SETC '&SYSLIST(&PNDX)'      GET THE REG VALUE FOR USING
&C(&PNDX-1) SETC ','                    AND A LEADING COMMA ALSO
&GOTREG  SETB  1                        SAY WE CAN DO USING
.CHK#END AIF   (&PNDX LT &RCNT).COMLOOP LOOP FOR ALL ENTRIES
.USINGGO AIF   (NOT &GOTREG).EXIT       NOW TELL ASSEMBLER IF WE CAN
&U       SETC  '&R(15)'                 SO WE HAVE A SHORTER STRING
&V       SETC  '&C(16)'                 SO WE HAVE A SHORTER STRING
&W       SETC  '&R(16)'                 SO WE HAVE A SHORTER STRING
         USING &S&T&C(1)&R(1)&C(2)&R(2)&C(3)&R(3)&C(4)&R(4)&C(5)&R(5)&C@
               (6)&R(6)&C(7)&R(7)&C(8)&R(8)&C(9)&R(9)&C(10)&R(10)&C(11)@
               &R(11)&C(12)&R(12)&C(13)&R(13)&C(14)&R(14)&C(15)&U&V&W
         MEXIT
.ERR01   MNOTE 4,'MISSING INPUT PARAMETERS'
         MEXIT
.EXIT    MEND
         EJECT ,                                              09/84 DBC
         MACRO
&NFS     ID    &ID,&OPT,&DATE=,&TIME=
.*  ID  --  06-15-77 LDW
.*  UPDATED 01-03-79 LDW
.*  UPDATED 02-21-79 LDW
.*  UPDATED 03-17-79 LDW
.*  UPDATED 11-29-79 LDW    USE $$ASM MACRO FOR DATE
         GBLC  &$$DATE1
         LCLC  &XDATE,&XTIME
         LCLA  &L
&L       SETA  K'&ID
         AIF   ('&OPT' EQ 'ASIS').ASIS
         AIF   ('&OPT' NE 'NODATE').DATE
.ASIS    ANOP
&NFS     DC    AL1(&L),C'&ID'
         MEXIT
.DATE    $$ASM
&XDATE   SETC  '&$$DATE1'
         AIF   ('&DATE' EQ '').OKDATE
&XDATE   SETC  '&DATE'                  USE WHAT HE WANTS
.OKDATE  ANOP
&L       SETA  &L+K'&XDATE+2
         AIF   ('&OPT' NE 'NOTIME').TIME
&NFS     DC    AL1(&L),C'&ID  &XDATE'
         MEXIT
.TIME    ANOP
&XTIME   SETC  '&SYSTIME'               DEFAULT TO CURRENT TIME
         AIF   ('&TIME' EQ '').OKTIME   HE DIDN'T SPECIFY, USE CURRENT
&XTIME   SETC  '&TIME'                  USE WHAT HE WANTS
.OKTIME  ANOP
&L       SETA &L+K'&XTIME+1             =1+8
         AIF   ('&OPT' NE '').BADOPT
&NFS     DC    AL1(&L),C'&ID  &XDATE &XTIME'
         MEXIT
.BADOPT  MNOTE 0,'*** (ID MACRO) OPT=&OPT IS INVALID, IGNORED.'
         MNOTE *,'(MUST BE NULL, "NOTIME", "NODATE", OR "ASIS")'
         MEND
         EJECT ,                                              09/84 DBC
         MACRO
         REGEQU  &F=,&FR=,&PREFIX=R,&STARS=YES
.*$MACRO=REGEQU     DATE=11/26/78       SOURCE=LDW
.*
.* PREFIX=R  SPECIFIES PREFIX FOR GENERAL REGISTER EQUATES.
.* F= (FR=)  SPECIFIES PREFIX FOR FLOATING POINT REG EQUATES.
.*            (DEFAULT IS NO EQUATES FOR F.P. REGS)
.* STARS=YES GENERATE LINE OF ASTERISKS BEFORE AND AFTER EQUATES.
.*
.* MULTIPLE REGEQU'S WITH THE SAME PREFIX WILL BE IGNORED.
.*
         GBLC  &$REGS$(15),&R,&FF
         LCLA  &X
&R       SETC  '&PREFIX'
.RLOOP   ANOP
&X       SETA  &X+1
         AIF   (&X GT 15).GEN
         AIF   ('&$REGS$(&X)' EQ '').GEN
         AIF   ('&R' EQ '&$REGS$(&X)').NOGEN
         AGO   .RLOOP
.GEN     ANOP
&$REGS$(&X) SETC '&R'
         AIF   ('&STARS' NE 'YES').NOSTAR1
***********************************************************************
.*
.NOSTAR1 ANOP
&R.0     EQU   0
&R.1     EQU   1
&R.2     EQU   2
&R.3     EQU   3
&R.4     EQU   4
&R.5     EQU   5                        *************
&R.6     EQU   6                        *  DEFINE   *
&R.7     EQU   7                        * SYMBOLIC  *
&R.8     EQU   8                        * REGISTERS *
&R.9     EQU   9                        *************
&R.10    EQU   10
&R.11    EQU   11
&R.12    EQU   12
&R.13    EQU   13
&R.14    EQU   14
&R.15    EQU   15
.*
         AGO   .CONT11
.NOGEN   ANOP
******** REGEQU ALREADY CODED FOR THIS PREFIX, IGNORED ****************
.CONT11  AIF   ('&F&FR' EQ '').NOF
&X       SETA  0                        RE-INIT
&FF      SETC  '&F&FR'
.FLOOP   ANOP
&X       SETA  &X+1
         AIF   (&X GT 15).FGEN
         AIF   ('&$REGS$(&X)' EQ '').FGEN
         AIF   ('&FF' EQ '&$REGS$(&X)').NOGENF
         AGO   .FLOOP
.FGEN    ANOP
&$REGS$(&X) SETC '&FF'
         SPACE 1
&FF.0    EQU   0
&FF.2    EQU   2
&FF.4    EQU   4
&FF.6    EQU   6
.NOF     AIF   ('&STARS' NE 'YES').NOSTAR2
***********************************************************************
.NOSTAR2 SPACE
         AGO   .MEND
.NOGENF  ANOP
******** REGEQU F= ALREADY CODED FOR THIS PREFIX, IGNORED *************
.MEND    MEND
         EJECT ,                                              09/84 DBC
         MACRO
&NFS     ENTR  &BASE=12,&BASE2=,&BASE3=,&BASE4=,                       $
               &SAVE=*,&REGS=(YES,R),&F=,                              $
               &USING=,&SECTYPE=CSECT,&GETMAIN=,&PARMREG=,&LPARM=,     $
               &SP=1,&ID=*,&EXIT=,&ADDRREG=,&LENREG=,&ENV=CALL,        $
               &RC=,&RCLOC=,&T=T,&PL=,&LOAD=,&SYMREG=,&DSECT=,         $
               &TSFAKE=,&PARSE=,&MACRO=,&PRINT=,&DATE=,&TIME=
.*********************************************************************.
.*                                                                   *.
.*  ENTR  --  09/27/79  --  LDW                                      *.
.*                                                                   *.
.*-------------------------------------------------------------------*.
.*                                                                   *.
.*  THIS MACRO WILL GENERATE THE HOUSEKEEPING CODE NEEDED FOR        *.
.*  STANDARD OS LINKAGE CONVENTIONS (FOR ENTRY AND EXIT)             *.
.*  THE GENERATED CODE WILL OPTIONALLY BE RE-ENTRANT                 *.
.*                                                                   *.
.*  UPDATES:                                                         *.
.*    09-27-79  LDW  FIX BUG IN TSO-CP SIMULATION CODE               *.
.*    02-21-79  LDW  ADD DATE= AND TIME= OPERANDS                    *.
.*    01-12-79  LDW  FIX BUG; ADD MVS CODE FOR LOAD=                 *.
.*    12-29-78  LDW  ADD BASE4=; FIX LENGTH OF GETMAIN IF MACRO=YES; *.
.*                   CHECK FOR RC=(R1) AND DYNAMIC AREA (GETMAIN=);  *.
.*                   ADD PRINT=; FIX FOR BATCH CALL OF ENV=CP PGMCK  *.
.*                                                                   *.
.*-------------------------------------------------------------------*.
.*                                                                   *.
.*  OPERANDS AVAILABLE ARE:                                          *.
.*                                                                   *.
.*                                                                   *.
.*  BASE=    -- DEFAULT:  BASE=12                                    *.
.*              THE BASE REGISTER TO BE USED                         *.
.*                                                                   *.
.*                                                                   *.
.*  BASE2=   -- DEFAULT:  (NONE)                                     *.
.*              A SECOND BASE REGISTER                               *.
.*                                                                   *.
.*                                                                   *.
.*  BASE3=   -- DEFAULT:  (NONE)                                     *.
.*              A THIRD BASE REGISTER (ONLY VALID IF BASE2= IS CODED)*.
.*                                                                   *.
.*  BASE4=   -- DEFAULT:  (NONE)                                     *.
.*              A FOURTH BASE REGISTER (MUST HAVE BASE2= AND BASE3=) *.
.*                                                                   *.
.*                                                                   *.
.*  SAVE=    -- DEFAULT:  SAVE=*                                     *.
.*              NAME OF A SAVE AREA TO BE USED.                      *.
.*              IF SAVE=* IS CODED, AN INLINE SAVE AREA WILL BE      *.
.*              GENERATED, WITH A UNIQUE NAME.  SAVE=* IS IGNORED    *.
.*              IF GETMAIN= IS CODED.  ANY OTHER VALUE OF SAVE=      *.
.*              WILL CAUSE AN ERROR IF GETMAIN= IS ALSO USED.        *.
.*                                                                   *.
.*                                                                   *.
.*  GETMAIN= -- DEFAULT:  (NONE)                                     *.
.*              THERE ARE TWO FORMS TO THIS OPERAND:                 *.
.*              GETMAIN=LENGTH, OR                                   *.
.*              GETMAIN=(LENGTH,DSECTNAME).  THIS OPERAND CAUSES A   *.
.*              GETMAIN FOR "LENGTH" BYTES TO EXPANDED.  THE FIRST   *.
.*              18 WORDS WILL BE RESERVED FOR THE SAVE AREA.  THE    *.
.*              ADDRESS OF THE AREA OBTAINED IS PLACED IN REG. 13,   *.
.*              AND IF "DSECTNAME" IS GIVEN, A USING IS DONE.        *.
.*              IF MACRO=YES IS CODED, THE DEFAULT FOR GETMAIN= IS   *.
.*              GETMAIN=(TSDSECTL,TSDSECT) AND THE EQU FOR TSDSECTL  *.
.*              WILL BE GENERATED BY ENTR.                           *.
.*                                                                   *.
.*                                                                   *.
.*  SP=      -- DEFAULT:  SP=1                                       *.
.*              THE SUBPOOL FOR THE WORKAREA OBTAINED BY GETMAIN=    *.
.*                                                                   *.
.*                                                                   *.
.*  REGS=    -- DEFAULT:  REGS=(YES,R)                               *.
.*              THE FIRST OPERAND (YES/NO) INDICATES WHETHER THE     *.
.*              REGEQU MACRO WILL BE USED TO GENERATE EQU'S FOR      *.
.*              SYMBOLIC REGISTERS.  THE SECOND OPERAND IS THE       *.
.*              PREFIX TO BE USED.                                   *.
.*              NOTE:  REGS=(YES,Q) IS THE SAME AS REGS=(,Q)         *.
.*                                                                   *.
.*                                                                   *.
.*  F=       -- DEFAULT:  (NONE)                                     *.
.*              THE PREFIX TO BE USED FOR SYMBOLIC FLOATING POINT    *.
.*              REGISTER NAMES.                                      *.
.*                                                                   *.
.*                                                                   *.
.*  SECTYPE= -- DEFAULT:  SECTYPE=CSECT                              *.
.*              THE SECTION TYPE TO BE GENERATED.                    *.
.*              POSSIBLE VALUES:  CSECT/DSECT/ENTRY/NONE             *.
.*                                                                   *.
.*                                                                   *.
.*  USING=   -- DEFAULT:  (NONE)                                     *.
.*              A USING WILL BE DONE FOR EACH PAIR OF OPERANDS.      *.
.*              CODED AS FOLLOWS:                                    *.
.*              USING=(DSECT1,REG1,DSECT2,REG2,...)                  *.
.*                                                                   *.
.*                                                                   *.
.*  EXIT=    -- DEFAULT:  (NONE)                                     *.
.*              THE NAME OF AN EXIT ROUTINE TO BE BRANCHED TO THAT   *.
.*              WILL FREE THE WORKAREA (IF ONE WAS OBTAINED BY       *.
.*              GETMAIN=), DECHAIN SAVE AREAS, SET THE RETURN CODE,  *.
.*              AND RETURN TO CALLER.                                *.
.*                                                                   *.
.*                                                                   *.
.*  RC=      -- DEFAULT:  RC=(15)                                    *.
.*              THE RETURN CODE TO BE PASSED BACK TO THE CALLER.     *.
.*              THIS OPERAND IS IGNORED IF EXIT= IS NOT CODED.       *.
.*              RC= CAN BE CODED AS RC=(REG) OR RC=EXPRESSION.       *.
.*              THIS OPERAND IS MUTUALLY EXCLUSIVE WITH THE RCLOC=   *.
.*              OPERAND.                                             *.
.*                                                                   *.
.*                                                                   *.
.*  RCLOC=   -- DEFAULT:  (NONE)                                     *.
.*              THE STORAGE LOCATION FROM WHICH THE RETURN CODE WILL *.
.*              BE OBTAINED.  MUST HAVE FULLWORD OR HALFWORD TYPE    *.
.*              ATTRIBUTE.  THIS OPERAND IS MUTUALLY EXCLUSIVE       *.
.*              WITH THE RC= OPERNAND.                               *.
.*                                                                   *.
.*                                                                   *.
.*  T=       -- DEFAULT:  T=T                                        *.
.*              IGNORED IF EXIT= NOT CODED.  SPECIFIES THAT THE OLD  *.
.*              SAVE AREA WILL BE FLAGGED BY A X'FF' AT OFFSET 12    *.
.*              TO INDICATE THAT IT IS INACTIVE.  NOTE:  "T=" SHOULD *.
.*              NOT BE CODED FOR EXIT ROUTINES, SUCH AS STAE ROUTINES*.
.*                                                                   *.
.*                                                                   *.
.*  ID=      -- DEFAULT:  ID=CSECT NAME                              *.
.*              AN ID TO PUT IN CHARACTER FORM NEAR THE BEGINNING    *.
.*              OF THE CSECT, TO AID IN DUMP READING.                *.
.*                                                                   *.
.*                                                                   *.
.*  ENV=     -- DEFAULT:  ENV=CALL                                   *.
.*              THE ENVIRONMENT THAT THE PROGRAM WILL OR SHOULD BE   *.
.*              RUNNING UNDER.  VALID OPERANDS (MORE THAN ONE CAN    *.
.*              BE CODED, IN PARENS):                                *.
.*              CALL -- BATCH EXEC PGM=, OR TSO CALL, OR LINK MACRO  *.
.*              CP -- TSO COMMAND PROCESSOR                          *.
.*              TSOCP -- ALIAS FOR CP                                *.
.*              TSO -- MAY BE RUN ON TSO                             *.
.*              MVT -- PROGRAM WILL BE RUN UNDER MVT.                *.
.*              MVS -- PROGRAM WILL BE RUN UNDER MVS.  (OS/VS2 R3)   *.
.*              PLI -- PROGRAM WILL BE CALLED BY A PLIX PROGRAM.     *.
.*              PLIX -- ALIAS FOR PLIX                               *.
.*              NOTE:  CALL IS MUTUALLY EXCLUSIVE WITH CP/TSOCP.  IF *.
.*              THE PROGRAM MAY BE RUN EITHER THRU CALL OR AS A CP,  *.
.*              SPECIFY ENV=TSO OR ENV=CP (ENV=CP IMPLIES ENV=TSO)   *.
.*                                                                   *.
.*                                                                   *.
.*  PARMREG= -- DEFAULT:  (NONE)                                     *.
.*              THE REGISTER TO SAVE THE PARM POINTER PASSED IN R1   *.
.*              ("LR  PARMREG,R1")                                   *.
.*                                                                   *.
.*                                                                   *.
.*  LPARM=   -- DEFAULT:  (NONE)                                     *.
.*              THE REGISTER INTO WHICH THE PARM ADDR WILL BE LOADED *.
.*              ( "L  LPARM,0(,R1)" )                                *.
.*                                                                   *.
.*                                                                   *.
.*  ADDRREG= -- DEFAULT:  (NONE)                                     *.
.*              THE REGISTER TO CONTAIN THE ADDRESS OF THE ACTUAL    *.
.*              TEXT OF THE PARM.                                    *.
.*              NOTE:  ADDRREG= AND LENREG= ARE AN OPERAND PAIR --   *.
.*              IF ONE IS CODED, THE OTHER MUST ALSO BE CODED.       *.
.*                                                                   *.
.*                                                                   *.
.*  LENREG=  -- DEFAULT:  (NONE)                                     *.
.*              THE REGISTER TO CONTAIN THE LENGTH OF THE PARM TEXT. *.
.*              SEE NOTE FOR ADDRREG=                                *.
.*                                                                   *.
.*                                                                   *.
.*  TSFAKE=  -- DEFAULT:  (NONE)                                     *.
.*              THE ADDRESS OF A WORKAREA IN WHICH A FAKE PARM OR    *.
.*              CPPL AND CBUF WILL BE BUILT, IF THE PROGRAM HAS      *.
.*              BEEN CALLED BY THE OPPOSITE MEANS.                   *.
.*              I.E.  IF ENV=CP IS CODED, AND THE PROGRAM IS CALLED  *.
.*              VIA "CALL", THEN A FAKE CPPL AND CBUF WILL BE BUILT, *.
.*              BASED ON THE INFO IN THE PARM FIELD.  IF ENV=CALL    *.
.*              IS CODED (OR DEFAULTED), A FAKE PARM PTR WORD AND    *.
.*              LENGTH WILL BE BUILT BASED ON THE INFO IN THE CBUF.  *.
.*              IF TSFAKE=YES IS CODED, AN AREA WILL BE GENERATED    *.
.*              AND NAMED EITHER IN THE WORK AREA (IF ANY), OR       *.
.*              INLINE.                                              *.
.*                                                                   *.
.*                                                                   *.
.*  LOAD=    -- DEFAULT:  (NONE)                                     *.
.*              A LIST OF MODULES TO BE LOADED.  THE ADDRESS OF EACH *.
.*              MODULE WILL BE SAVED IN A WORD WITH THE NAME OF THE  *.
.*              MODULE.                                              *.
.*                                                                   *.
.*                                                                   *.
.*  PL=      -- DEFAULT:  (NONE)                                     *.
.*              A LIST OF PARAMETER LISTS TO BE GENERATED AND        *.
.*              INITIALIZED.  THE FOLLOWING PARM LISTS ARE           *.
.*              SUPPORTED:  CSCAN, PARSE, DAIR, IO, MESSAGE.         *.
.*                                                                   *.
.*                                                                   *.
.*  MACRO=   -- DEFAULT:  MACRO=NO                                   *.
.*              IF 'YES' IS CODED, A 'TSWORK' MACRO WILL BE ISSUED   *.
.*              TO DEFINE MORE STORAGE IN THE WORK AREA.  (TSWORK    *.
.*              MACRO IS DEFINED BY THE USER.)                       *.
.*                                                                   *.
.*                                                                   *.
.*  PARSE=   -- DEFAULT:  (NONE)                                     *.
.*              FORMAT:  PARSE=PCLNAME OR PARSE=(PCLNAME,ERRADDR)    *.
.*              WILL USE THE TSPARSE MACRO TO PARSE THE COMMAND LINE *.
.*              (POINTED TO BY CPPLCBUF).  PCLNAME IS THE NAME OF    *.
.*              THE PCL CSECT.  IF ERRADDR IS GIVEN, GENERATES ERROR *.
.*              ANALYSIS ROUTINE ROUTINE WITH TSPARERR MACRO.        *.
.*                                                                   *.
.*  PRINT=   -- DEFAULT:  (NONE)                                     *.
.*              PRINT=NOGEN SPECIFIES THAT THE DSECTS SHOULD NOT BE  *.
.*              PRINTED                                              *.
.*                                                                   *.
.*  DATE=    -- DEFAULT:  (DATE OF ASSEMBLY)                         *.
.*              SPECIFIES ASSEMBLY DATE (SHOULD ONLY BE USED WHEN    *.
.*              COMPARING AGAINST AN OLD LOAD MODULE)                *.
.*                                                                   *.
.*  TIME=    -- DEFAULT:  (TIME OF ASSEMBLY)                         *.
.*              SPECIFIES ASSEMBLY DATE (SHOULD ONLY BE USED WHEN    *.
.*                                                                   *.
.*                                                                   *.
.*********************************************************************.
.*
.*
.*
.*  IHB&SYSNDX LETTERS USED:  ABC EF     L    Q S      Z
.*
         GBLB  &GDAIRM,&GPARSEM         TO AVOID DUPLICATES
         GBLB  &GDAIR,&GPARSE           DAIR OR PARSE LOADED
         LCLC  &BA$E,&$AVE,&Q,&NAME,&RCRC,&LR,&AR,&T$FAKE,&GET1,&GET2
         LCLC  &PARNAME
         LCLC  &IHBNX,&BLANK1,&BLANK2
         LCLC  &R0,&R1,&R2,&R3,&R12,&R13,&R14,&R15
         LCLA  &L,&X
         LCLB  &ENVTSO,&ENVCALL,&ENVCP,&ENVPLI,&ENVMVT,&ENVMVS
         LCLB  &FKCALL,&FKCP,&MVSCVT
         LCLB  &CSPL,&PARS,&DAIR,&IO,&MSG
&IHBNX   SETC  'IHB&SYSNDX'
&BLANK1  SETC  '        '
&BLANK2  SETC  '        '
&PARNAME SETC  ''
         AIF   ('&PRINT' NE 'NOGEN').PRINTOK
         AIF   ('&PRINT' NE '').PRINTOK
         MNOTE 4,'WHAT DOES PRINT=&PRINT MEAN???'
.*
.*
.PRINTOK AIF   ('&SYMREG' EQ '').NOSYMRG
         MNOTE 0,'SYMREG= IS UNSUPPORTED -- USE REGS='
.NOSYMRG AIF   ('&DSECT' EQ '').NOD$ECT
         MNOTE 4,'DSECT= IS UNSUPPORTED'
.NOD$ECT ANOP
.*
.*  ENVIRONMENT
.*
&X       SETA  0
.ENVLOOP AIF   (N'&ENV EQ &X).ENVDONE
&X       SETA  &X+1
         AIF   ('&ENV(&X)' EQ 'TSO'  ).ENVTSO
         AIF   ('&ENV(&X)' EQ 'CALL' ).ENVCALL
         AIF   ('&ENV(&X)' EQ 'CP'   ).ENVCP
         AIF   ('&ENV(&X)' EQ 'TSOCP').ENVCP
         AIF   ('&ENV(&X)' EQ 'MVS'  ).ENVMVS
         AIF   ('&ENV(&X)' EQ 'MVT'  ).ENVMVT
.**      AIF   ('&ENV(&X)' EQ 'PLI'  ).ENVPLI
.**      AIF   ('&ENV(&X)' EQ 'PLIX' ).ENVPLI
         MNOTE 4,'ENV=&ENV(&X) IS INVALID -- IGNORED'
         AGO   .ENVLOOP
.ENVTSO  ANOP
&ENVTSO  SETB  1
         AGO   .ENVLOOP
.ENVCALL ANOP
&ENVCALL SETB  1
         AGO   .ENVLOOP
.ENVCP   ANOP
&ENVCP   SETB  1
&ENVTSO  SETB  1                        ENV=CP IMPLIES ENV=TSO
         AGO   .ENVLOOP
.ENVMVS  ANOP
&ENVMVS  SETB  1
         AGO   .ENVLOOP
.ENVMVT  ANOP
&ENVMVT  SETB  1
         AGO   .ENVLOOP
.ENVPLI  ANOP
&ENVPLI  SETB  1
         AIF   ('&BASE' NE '12' AND '&BASE' NE 'R12').ENVLOOP
         MNOTE 0,'WARNING:  BASE=&BASE IS NOT COMPATIBLE WITH ENV=PLIX'
         AGO   .ENVLOOP
.ENVDONE AIF   (NOT &ENVCALL OR NOT &ENVCP).ENVOK1
        MNOTE 4,'ENV=(CALL,CP) MAY NOT BOTH BE GIVEN.  "CALL" IGNORED.'
&ENVCALL SETB  0                        IGNORE IT
.ENVOK1  AIF   (NOT &ENVMVT OR NOT &ENVMVS).ENVOK2
         MNOTE 4,'MAKE UP YOUR MIND:  ENV=MVT OR ENV=MVS, BUT NOT BOTH.$
                 MVT ASSUMED.'
&ENVMVS  SETB  0                        IGNORE IT
.*
.*  TSFAKE
.*
.ENVOK2  AIF   ('&TSFAKE' EQ '').NOFAKE
&T$FAKE  SETC  '&TSFAKE'
         AIF   ('&TSFAKE' NE 'YES').FAKENO
&T$FAKE  SETC  '&IHBNX.F'
.FAKENO  AIF   ('&PARMREG' NE '').OKFAKE0
         MNOTE 4,'*** PARMREG= MUST BE GIVEN IF TSFAKE= IS GIVEN.  TSFA$
               KE=&TSFAKE IGNORED.'
         AGO   .NOFAKE
.OKFAKE0 AIF   (NOT &ENVCALL).NOFKCAL
&FKCALL  SETB  1
         AGO   .NOFAKE
.NOFKCAL AIF   (NOT &ENVCP).NOFKCP
&FKCP    SETB  1
         AGO   .NOFAKE
.NOFKCP  MNOTE 0,'WHAT TO FAKE?????'
.NOFAKE  ANOP
.*
.*  SAVE/GETMAIN
.*
&$AVE    SETC  '&SAVE'                  INIT DEFAULT
&GET1    SETC  '&GETMAIN(1)'
&GET2    SETC  '&GETMAIN(2)'
         AIF   ('&MACRO' NE 'YES').OKGET2
         AIF   ('&GET1' NE '').OKGET1
&GET1    SETC  'TSDSECTL'               SET DEFAULT
.OKGET1  AIF   ('&GET2' NE '').OKGET2
&GET2    SETC  'TSDSECT'                SET DEFAULT
.OKGET2  AIF   ('&GETMAIN' EQ '').KEEPSAV
         AIF   ('&GETMAIN(1)' NE '').GMOK1
         AIF   ('&MACRO' EQ 'YES').GMOK1
         MNOTE 8,'GETMAIN= CODED INCORRECTLY.  MACRO TERMINATED'
         MEXIT
.GMOK1   ANOP
&$AVE    SETC  ''                       NO SAVE AREA
.KEEPSAV AIF   ('&BASE4' EQ '').NOBASE4
         AIF   ('&BASE3' NE '').BASE3
         MNOTE 8,'*** BASE4 IGNORED, INVALID WITHOUT BASE3= ***'
.NOBASE4 AIF   ('&BASE3' EQ '').OKBASES
.BASE3   AIF   ('&BASE2' NE '').OKBASES
         MNOTE 8,'*** BASE3 IGNORED, INVALID WITHOUT BASE2= ***'
.OKBASES AIF   (('&GETMAIN' EQ '') AND ('&MACRO' NE 'YES')).OK1
         AIF   ('&SAVE'   EQ '*').OK1
         AIF   ('&SAVE'    EQ '').OK1
         MNOTE 12,'*** SAVE= MUTUALLY EXCLUSIVE WITH GETMAIN= AND/OR MA$
               CRO=YES.  MACRO TERMINATED ***'
         MEXIT
.OK1     AIF   ('&NFS' NE '').GOTNAME
         MNOTE 12,'*** CSECT NAME OMMITTED ***'
.*
.*  SECTYPE=
.*
.GOTNAME AIF   ('&SECTYPE' NE 'CSECT').NOCSECT
.DOCSECT ANOP
&NFS     CSECT                          ENTR -- 09/27/79 -- LDW
         AGO   .SECDONE
.NOCSECT AIF   ('&SECTYPE' NE 'DSECT').NODSECT
&NFS     DSECT                          ENTR -- 09/27/79 -- LDW
         AGO   .SECDONE
.NODSECT AIF   ('&SECTYPE' EQ 'NONE').SECNONE
         AIF   ('&SECTYPE' EQ 'ENTRY').ENTRY
       MNOTE 8,'*** SECTYPE=&SECTYPE IS INVALID, SECTYPE=CSECT ASSUMED'
         AGO   .DOCSECT
.ENTRY   ENTRY &NFS
.SECNONE ANOP
*  DEFINE NAME
&NFS     DC    0D'0'                    ENTR -- 09/27/79 -- LDW
.*
.*  REGS=
.*
.SECDONE AIF   ('&REGS(1)' EQ '' AND '&REGS(2)' NE '').DOREGS
         AIF   ('&REGS(1)' EQ 'NO').NOREGS
         AIF   ('&REGS(2)' NE '').DOREGS
&Q       SETC  'R'
         AGO   .CONT1
.DOREGS  ANOP
&Q       SETC  '&REGS(2)'
.CONT1   ANOP                           WAS SPACE 1
&L       SETA  K'&Q
***********************************************************************
*        REGISTER EQUATES                                             *
         REGEQU  PREFIX=&Q,FR=&F
         SPACE 1
.NOREGS  ANOP
&R0      SETC  '&Q'.'0'
&R1      SETC  '&Q'.'1'
&R2      SETC  '&Q'.'2'
&R3      SETC  '&Q'.'3'
&R12     SETC  '&Q'.'12'
&R13     SETC  '&Q'.'13'
&R14     SETC  '&Q'.'14'
&R15     SETC  '&Q'.'15'
&L       SETA  K'&REGS(2)
.*
.*  MISC WORKAREA GOODIES
.*
         AIF   (&ENVCP AND '&PL' NE '').NOGM2   WILL BE GENERATED LATER
         AIF   ('&GET2' EQ '').NOGM2
&GET2    DSECT
         DS    18F                      SAVE AREA
         AIF   ('&TSFAKE' NE 'YES' OR &ENVCP).NOFKY1
&T$FAKE  DS    A,2H,CL100               AREA FOR FAKE PARM FIELD
.NOFKY1  AIF   (NOT &ENVCP).NO$CPPL
         AIF   ('&PL' EQ '').NOTSECB
TSECB    DS    F
.NOTSECB SPACE 1
*        TSCPPL
         TSCPPL
         SPACE 1
.*
.*  LOAD=
.*
.NO$CPPL AIF   ('&LOAD' EQ '').NOLOAD1
&X       SETA  0
.LOADLP1 ANOP
&X       SETA  &X+1
&LOAD(&X) DS   A
         AIF   (&X LT N'&LOAD).LOADLP1
.*
.*  BASE=
.*
.NOLOAD1 SPACE 3
&NFS     CSECT                          RESUME
.NOGM2   AIF   ('&REGS(1)' EQ 'NO').REGBASE
         AIF   ('&BASE'(1,&L) EQ '&REGS(2)').REGBASE
&BA$E    SETC  '&Q&BASE'
         AGO   .CONT2
.REGBASE ANOP
&BA$E    SETC  '&BASE'
.CONT2   USING *,&R15                   TEMPORARY BASE
         B     &IHBNX.B                 AROUND GORF
         DROP  &R15                     DROP TEMP BASE
         USNGX &NFS,&BA$E
.*
.*  ID
.*
         AIF   ('&ID(1)' EQ '*').IDSTAR
         AIF   ('&ID(1)' EQ '' ).IDSTAR
         AIF   ('&ID' EQ '*NONE*').DONEID
         ID    &ID(1),&ID(2),DATE=&DATE,TIME=&TIME
         AGO   .DONEID
.IDSTAR  ID    &NFS,&ID(2),DATE=&DATE,TIME=&TIME
.*
.*  BASE2, BASE3, BASE4
.*
.DONEID  AIF   ('&BASE2' EQ '').NOBASE2
&IHBNX.A DC    A(&NFS+4096)             SECOND BASE REGISTER
         AIF   ('&BASE3' EQ '').NOBASE2
&IHBNX.Z DC    A(&NFS+8192)             LET'S NOT GET CARRIED AWAY...
         AIF   ('&BASE4' EQ '').NOBASE2
&IHBNX.Q DC    A(&NFS+12288)            BUT THIS IS GETTING REDICULOUS
.NOBASE2 AIF   (('&$AVE' NE '*') OR ('&GET1' NE '')).NOSVSTR NO INL SA
.*OBASE2 AIF   ('&$AVE' NE '*').NOSVSTR NO INLINE SAVE AREA
&IHBNX.S DC    18F'0'                   SAVE AREA
&$AVE    SETC  '&IHBNX.S'
.NOSVSTR AIF   ('&TSFAKE' NE 'YES' OR &ENVCP OR '&GET2' NE '').NOFKY2
&T$FAKE  DC    A(0),2H'0',CL100' '      AREA FOR FAKE PARM FIELD
.*
.*  GETMAIN=
.*
.NOFKY2  AIF   ('&GET1&GET2' EQ '').NOSPLEN  NO SP & LENGTH
         AIF   ('&BASE2' NE '').BASE2L
         DC    0A(0)                    ALIGNMENT
.BASE2L  ANOP                           DON'T NEED ALIGNMENT
&IHBNX.L DC    AL1(&SP),AL3(&GET1)      GETMAIN SP AND LENGTH
.NOSPLEN AIF   ('&EXIT' EQ '').NOEXIT
.*
.*  EXIT= AND RC=
.*
         SPACE 2
*=====================================================================*
&RCRC    SETC  '&RC(1)'
         AIF   ('&RC' NE '').OKRC1
&RCRC    SETC  '&R15'
.OKRC1   AIF   ('&RCLOC' EQ '').OKRC3
         AIF   ('&RC'    EQ '').OKRC2
         MNOTE 0,'*** RC= AND RCLOC= MUTUALLY EXCLUSIVE -- RC= IGNORED'
.OKRC2   ANOP
&RCRC    SETC  '&RCLOC'
.OKRC3   ANOP
&X       SETA  8-K'&RCRC                NUMBER OF BLANKS NEEDED
         AIF   (&X GT 0).OKRCL
&BLANK1  SETC  ''
         AGO   .CHAR8RC
.OKRCL   ANOP
&BLANK1  SETC  '&BLANK1'(1,&X)
.CHAR8RC ANOP
&X       SETA  8-K'&EXIT(1)             NUMBER OF BLANKS NEEDED
         AIF   (&X GT 0).OKEXITL
&BLANK2  SETC  ''
         AGO   .CHAR8EX
.OKEXITL ANOP
&BLANK2  SETC  '&BLANK2'(1,&X)
.CHAR8EX AIF   ('&RC' EQ '').MREGRC
         AIF   ('&RC'(1,1) EQ '(').MREGRC
         MNOTE *,'   BRANCH TO "&EXIT" TO EXIT WITH RETURN CODE=&RCRC  X
                 &BLANK1   &BLANK2    *'
         AGO   .MRCCONT
.MREGRC  MNOTE *,'   BRANCH TO "&EXIT" TO EXIT WITH RETURN CODE IN &RCR$
               C &BLANK1   &BLANK2    *'
.MRCCONT ANOP
*=====================================================================*
&NAME    SETC  '&EXIT'
         AIF   ('&RCRC' NE '0').RCNOT0
&NAME    XR    &R15,&R15                SET RETURN CODE ZERO
&NAME    SETC  ''
         AGO   .HAVERC
.RCNOT0  AIF   ('&RCLOC' EQ '').NORCLOC RCLOC NOT GIVEN
         AIF   ('&GET2' EQ '').NORCUSE
         USING &GET2,&R13               IN CASE RCLOC IS IN DSECT
.NORCUSE AIF   (T'&RCLOC EQ 'F').RCLOCF
         AIF   (T'&RCLOC EQ 'H').RCLOCH
         MNOTE 0,'*** UNKNOWN TYPE FOR RCLOC=&RCLOC -- "F" ASSUMED'
.RCLOCF  ANOP
&NAME    L     &R15,&RCLOC              LOAD RETURN CODE
         AGO   .RCCOM1                  GO TO COMMON
.RCLOCH  ANOP
&NAME    LH    &R15,&RCLOC              LOAD RETURN CODE
.RCCOM1  AIF   ('&GET2' EQ '').RCCOM2
         DROP  &R13                     IN CASE RCLOC IS IN DSECT
         AGO   .RCCOM2                  GO TO COMMON
.NORCLOC AIF   ('&RC' EQ '').HAVERC     RC IS IN A REG
         AIF   ('&RC'(1,1) EQ '(').HAVERC   DITTO
&NAME    LA    &R15,&RCRC               LOAD RETURN CODE
.RCCOM2  ANOP                           COMMON POINT
&NAME    SETC  ''
.HAVERC  AIF   ('&GET1' EQ '').NOWORK1  NO DSA TO FREE
&NAME    LR    &R1,&R13                 COPY DSA PTR
&NAME    SETC  ''
.NOWORK1 ANOP
&NAME    L     &R13,4(,&R13)            DECHAIN SAVE AREAS
&NAME    SETC  ''
         AIF   ('&RC' EQ '').WORKE
         AIF   ('&RC'(1,1) NE '(').NOWORKE
.WORKE   AIF   ('&RCLOC' NE '').NOWORKE STORE R15
         AIF   ('&GET1' EQ '').RCNOT1   RC=(1) IS OK IF NO DYNAMIC AREA
         AIF   (('&RCRC' NE '&R1') AND ('&RCRC' NE '1')).RCNOT1
         MNOTE 4,'YOU TURKEY.  RC=(R1) DOESN''T WORK RIGHT IF YOU HAVE $
               A DYNAMIC AREA'
         MNOTE 0,'... I HOPE YOU INSTALLED ZAP...'
.RCNOT1  ST    &RCRC,16(,&R13)          SET RETURN CODE
         AGO   .WASRGRC
.NOWORKE ST    &R15,16(,&R13)           SET RETURN CODE
.WASRGRC AIF   ('&GET1' EQ '').NOWRKE2  NO DSA TO FREE
         L     &R0,&IHBNX.L             PICK UP SP AND LENGTH
*        FREEMAIN  R,A=(1),LV=(0)       FREE THE DSA
         FREEMAIN  R,A=(1),LV=(0)
.NOWRKE2 LM    &R14,&R12,12(&R13)       RESTORE CALLERS REGS
         AIF   ('&T' NE 'T').BR14
         MVI   12(&R13),X'FF'           FLAG SAVEAREA AS INACTIVE
.BR14    BR    &R14                     RETURN TO CALLER
.NOEXIT  SPACE 3
*=====================================================================*
*    ENTRY CODE                                                       *
*=====================================================================*
&IHBNX.B STM   &R14,&R12,12(&R13)       SAVE CALLER'S REGS
.*
.* SET UP BASE REGISTERS
.*
         LR    &BA$E,&R15               LOAD BASE REGISTER
         AIF   ('&BASE2' EQ '').BASEFIN
         L     &BASE2,&IHBNX.A          LOAD SECOND BASE REGISTER
         USNGX &NFS+4096,&BASE2
         AIF   ('&BASE3' EQ '').BASEFIN
         L     &BASE3,&IHBNX.Z          LOAD BASE3 FOR MLE,BMD,VIC
         USNGX &NFS+8192,&BASE3
         AIF   ('&BASE4' EQ '').BASEFIN
         L     &BASE4,&IHBNX.Q          WHAT'S GOING ON HERE???
         USNGX &NFS+12288,&BASE4
.*
.* GENERATE USINGS, IF GIVEN
.*
.BASEFIN AIF   (N'&USING LT 1).NOUSING
&X       SETA  1
.USINGLP USNGX &USING(&X),&USING(&X+1)
&X       SETA  &X+2
         AIF   (&X LT N'&USING).USINGLP
.*
.* FUTZ WITH THE PARM
.*
.NOUSING ANOP
&AR      SETC  '&R14'                   SET DEFAULT FOR LENREG=
&LR      SETC  '&R15'                   SET DEFAULT FOR ADDRREG=
         AIF   (('&ADDRREG' EQ '') AND ('&LENREG' EQ '')).NO$AR
         AIF   (('&ADDRREG' NE '') AND ('&LENREG' NE '')).ARLR
         MNOTE 8,'ADDRREG= AND LENREG= MUST BOTH BE GIVEN'
.ARLR    ANOP
&AR      SETC  '&ADDRREG'
&LR      SETC  '&LENREG'
.NO$AR   AIF   ('&PARMREG' EQ '').NOPARMR
         LR    &PARMREG,&R1             SAVE PARM POINTER
.NOPARMR AIF   ('&LPARM' EQ '').NOLPARM
&NAME    L     &LPARM,0(,&R1)           PICK UP PARM POINTER
&NAME    SETC  ''
         AIF   (&ENVTSO).NOLPARM
         AIF   ('&ADDRREG' EQ '').NOLPARM
         LH    &LR,0(,&LPARM)           GET PARM LENGTH
         LA    &AR,2(,&LPARM)           POINT PAST LENGTH
.*
.* GET A SAVE AREA, EITHER STATIC OR DYNAMIC
.*
.NOLPARM AIF   ('&GET1' EQ '').STATIC
&NAME    L     &R0,&IHBNX.L             PICK UP SP AND LENGTH
&NAME    SETC  ''
*        GETMAIN  R,LV=(0)              GET A WORKAREA (DSA)
         GETMAIN  R,LV=(0)
.USE1    ST    &R1,8(,&R13)             FORW CHAIN SAVE AREAS
         ST    &R13,4(,&R1)             BACK CHAIN SAVE AREAS
         LR    &R13,&R1                 GET NEW SAVE AREA ADDR
         AIF   ('&GET2' EQ '').CONT3
         USNGX &GET2,&R13
         AGO   .CONT3
.*
.* CHAIN SAVE AREAS
.*
.STATIC  AIF   ('&PARMREG' NE '&R15').NOT15
&NAME    LA    &R1,&$AVE                GET SAVE AREA ADDR
&NAME    SETC  ''
         AGO   .USE1
.NOT15   LA    &R15,&$AVE               GET SAVE AREA ADDR
         ST    &R15,8(,&R13)            FORW CHAIN SAVE AREAS
         ST    &R13,4(,&R15)            BACK CHAIN SAVE AREAS
         LR    &R13,&R15                GET NEW SAVE AREA ADDR
.**      SPACE 3
.CONT3   AIF   ('&RCLOC' EQ '').CONT3B
         XC    &RCLOC,&RCLOC            INIT RCLOC TO ZERO
.CONT3B  SPACE 3
         AIF   (NOT &ENVCP).NMVCPPL
         MVC   CPPL(CPPLL),0(&PARMREG)  COPY CPPL TO SAFE PLACE
.NMVCPPL AIF   (&FKCALL OR &FKCP).FAKE$A
         AIF   ('&ADDRREG' EQ '').LOAD
         AIF   (&ENVTSO).FAKE$A
         L     &AR,0(,&PARMREG)         POINT TO PARM (LENGTH)
         LH    &LR,0(,&AR)              GET PARM LENGTH
         LA    &AR,2(,&AR)              POINT PAST LENGTH
         AGO   .INUSE
.FAKE$A  SPACE 2
*  DETERMINE WHETHER WE HAVE BEEN CALLED AS A TSO CP OR THRU CALL
         SPACE 1
         L     &R1,16                   CVTPTR
         L     &R1,0(,&R1)              TCBWORDS
         L     &R1,4(,&R1)              TCB
*%%      TM    148(&R1),X'80'           IS THIS TSO?    %%%
*%%      BNO   &IHBNX.C                 NO - SKIP       %%%
         L     &R1,180(,&R1)            TCB.JSCB
         L     &R1,264(,&R1)            JSCB.PSCB
         LA    &R0,0(,&R1)              CLEAR HIGH BYTE
         L     &R1,8(,&PARMREG)         POSSIBLE PSCB PTR
         LA    &R1,0(,&R1)              CLEAR HIGH BYTE
         TM    0(&PARMREG),X'80'        ONLY 1 PARM?
         BO    &IHBNX.E                 YES - // EXEC OR TSO CALL
         CR    &R0,&R1                  THIRD PARM -> PSCB?
         AIF   (('&ADDRREG' NE '') OR (&FKCALL)).SETCPR
         BE    &IHBNX.C                 YES - WERE CALLED AS A TSO CP
         AGO   .CONT5                   SKIP AROUND
.SETCPR  BNE   &IHBNX.E                 NO - NOT TSO CP
         SPACE 2
*  HAVE BEEN CALLED AS A CP
         SPACE 1
         AIF   ('&ADDRREG' EQ '').NO$AR2
         L     &R1,0(,&PARMREG)         CBUF PTR
         LH    &LR,0(,&R1)              LENGTH OF CBUF
         LH    &AR,2(,&R1)              OFFSET TO FIRST NON-BLANK
         LA    &LR,0(&LR,&R1)           POINT PAST CBUF
         LA    &AR,4(&AR,&R1)           POINT TO FIRST NON-BLANK
         SR    &LR,&AR                  LENGTH OF PARMS
.NO$AR2  AIF   (&FKCALL).CONT4
         B     &IHBNX.C                 CONTINUE
         AGO   .CONT5
.*
.CONT4   AIF   (NOT &FKCALL).NOFAKE1
.*
.*  FAKE A CALL
.*
         STH   &LR,&T$FAKE+4            SET FAKED LENGTH OF PARM
         LTR   &R1,&LR                  COPY LENGTH
         AIF   ('&TSFAKE(2)' EQ '').NOMXCK1
         CH    &R1,&TSFAKE(2)           PARM TOO BIG?
         BNH   *+8                      NO - OK
         LH    &R1,&TSFAKE(2)           TOO BIG - USE MAX
         LTR   &R15,&R15                TEST PARM LENGTH
.NOMXCK1 BNP   *+16                     SKIP IF NO PARM       >=====+
         BCTR  &R1,0                    -1 FOR EXECUTE              ×
         EX    &R1,*+4                  MOVE THE PARM TO WORKAREA   ×
         MVC   &T$FAKE+6(0),0(&AR)      << EXECUTED >>              ×
         LA    &R1,&T$FAKE+4            GET FAKE PARM ADDR    <=====+
         ST    &R1,&T$FAKE              STORE IT
         LA    &PARMREG,&T$FAKE         GET ADDR OF FAKED PARM
         MVI   &T$FAKE,X'80'            SET END OF LIST BIT
         B     &IHBNX.C                 CONTINUE
         AGO   .CONT5
.NOFAKE1 AIF   (NOT &FKCP).LOAD
.CONT5   SPACE 2
*  HAVE BEEN CALLED FROM BATCH, OR TSO CALL
         SPACE 1
&IHBNX.E L     &AR,0(,&PARMREG)         POINT TO PARM LENGTH
         LH    &LR,0(,&AR)              GET LENGTH OF PARM
         LA    &AR,2(,&AR)              POINT PAST LENGTH
         AIF   (NOT &FKCP).NOFAKE2
*  CPPL=ADDR(CBUF,UPT,PSCB,ECT)
         LA    &R1,&T$FAKE              GET ADDR OF FAKE CBUF
         ST    &R1,CPPLCBUF             SET INTO CPPL                +0
         LR    &R1,&R0                  COPY PSCB ADDR
         ST    &R0,CPPLPSCB             SET INTO FAKE CPPL           +8
         MVC   CPPLUPT(4),52(&R1)       MOVE UPT ADDR INTO CPPL      +4
         L     &R1,48(,&R1)             PSCB.RLGB
         L     &R1,256(,&R1)            RLGB.ECT
         ST    &R1,CPPLECT              SET IN CPPL                 +12
         SPACE 1
*  CBUF=Y(CBUF_LEN,OFFSET_TO_NONBLANK),C'CMDNAME',C' ',C'OPERANDS'
         MVC   &T$FAKE+4(8),12(&R1)     MOVE CMD NAME TO CBUF
         MVI   &T$FAKE+4+8,C' '         PUT IN DELIMETER
         NI    28(&R1),X'7F'            TURN OFF "NO OPERANDS" BIT
         LTR   &LR,&LR                  ANY OPERANDS?
         BP    *+8                      YES - SKIP
         OI    28(&R1),X'80'            SET "NO OPERANDS" BIT IN ECT
         SPACE 1
         LA    &R1,8+1                  OFFSET TO FIRST NON-BLANK
         STH   &R1,&T$FAKE+2            SET IN FAKE CBUF
         LA    &R0,8+1+4(,&LR)          GET LENGTH OF CBUF
         STH   &R0,&T$FAKE              SET INTO FAKE CBUF
         AIF   ('&TSFAKE(2)' NE '').MAXCK
         LTR   &R1,&LR                  ANY OPERANDS?
         AGO   .NOMXCK2                 CONTINUE
.MAXCK   LR    &R1,&LR                  COPY PARM LENGTH
         CH    &R1,&TSFAKE(2)           PARM TOO BIG?
         BNH   *+8                      NO - OK
         LH    &R1,&TSFAKE(2)           TOO BIG - USE MAX
         LTR   &LR,&LR                  ANY OPERANDS?
.NOMXCK2 BNP   *+16                     NO - SKIP             >=====+
         BCTR  &R1,0                    -1 FOR EXECUTE              ×
         MVC   &T$FAKE+4+8+1(0),0(&AR)  << EXECUTED >>              ×
         EX    &R1,*-6                  MOVE THE PARM TO FAKE CBUF  ×
         LA    &PARMREG,CPPL            POINT TO CPPL         <=====+
.NOFAKE2 SPACE 2
&NAME    SETC  '&IHBNX.C'
         SPACE 2
.*
.*  LOAD=
.*
.LOAD    AIF   ('&LOAD' EQ '').NOLOAD
&X       SETA  1
.LOAD$LP AIF   ('&LOAD(&X)' EQ '').NOLOAD
         AIF   (NOT &ENVMVS).YESLOAD
&NAME    ENTR1I  &LOAD(&X),IKJPTGT,464
&NAME    ENTR1I  &LOAD(&X),IKJPUTL,444
&NAME    ENTR1I  &LOAD(&X),IKJGETL,348
&NAME    ENTR1I  &LOAD(&X),IKJPARS,524
&NAME    ENTR1I  &LOAD(&X),IKJDAIR,732
&NAME    ENTR1I  &LOAD(&X),IKJSTCK,472
&NAME    ENTR1I  &LOAD(&X),IKJSCAN,480
&NAME    ENTR1I  &LOAD(&X),IKJEHCIR,740
&NAME    ENTR1I  &LOAD(&X),IKJEHDEF,736
&NAME    ENTR1I  &LOAD(&X),IKJEFF02,976                            SDM
.*****  DO ALL OF THESE HAVE THE SAME X'80' = LOADED DEFINITION????
         AIF   (NOT &MVSCVT).YESLOAD    IT WAS NOT ONE OF THE ABOVE
&NAME    SETC  ''                       IT WAS
.YESLOAD MNOTE *,'       LOAD  EPLOC==CL8''&LOAD(&X)'''
&NAME    LOAD  EPLOC==CL8'&LOAD(&X)'
&NAME    SETC  ''
.ADDRSAV ST    &R0,&LOAD(&X)
.SKIPASV SPACE 1
         AIF   ('&LOAD(&X)' NE 'IKJDAIR').NO$DAIR
&GDAIR   SETB  1                        DAIR LOADED
         AGO   .LOADNXT
.NO$DAIR AIF   ('&LOAD(&X)' NE 'IKJPARS').NO$PARS
&GPARSE  SETB  1                        PARSE WAS LOADED
&PARNAME SETC  'IKJPARS'
.NO$PARS ANOP
.LOADNXT ANOP
&X       SETA  &X+1
         AGO   .LOAD$LP
.*
.*  PL=
.*
.NOLOAD  AIF   ('&PL' EQ '').NO$PL$1
&X       SETA  1
.PLLOOP  AIF   ('&PL(&X)' NE 'CSCAN').PL2
&CSPL    SETB  1
         AGO   .PLNEXT
.PL2     AIF   ('&PL(&X)' NE 'PARSE').PL3
&PARS    SETB  1
         AGO   .PLNEXT
.PL3     AIF   ('&PL(&X)' NE 'DAIR').PL4
&DAIR    SETB  1
         AGO   .PLNEXT
.PL4     AIF   ('&PL(&X)' NE 'IO').PL5
&IO      SETB  1
         AGO   .PLNEXT
.PL5     AIF   ('&PL(&X)' NE 'MESSAGE').PL6
&MSG     SETB  1
         AGO   .PLNEXT
.PL6     MNOTE 4,'PL=&PL(&X) UNKNOWN -- IGNORED'
.PLNEXT  ANOP
&X       SETA  &X+1
         AIF   (&X LE N'&PL).PLLOOP
.*
.*
.NO$PL$1 AIF   ('&PARSE(2)' EQ '').PLNOTM
&MSG     SETB  1
.PLNOTM  AIF   (NOT (&CSPL OR &PARS OR &DAIR OR &IO OR &MSG)).NOSETPL
&NAME    L     &R1,CPPLUPT              GET UPT PTR
&NAME    SETC  ''
         L     &R2,CPPLECT              GET ECT PTR
         LA    &R3,TSECB                GET ECB PTR
         SR    &R0,&R0                  GET A 0
         ST    &R0,TSECB                CLEAR ECB
.*
         AIF   (NOT &CSPL).NOSETC
         SPACE 1
         STM   &R1,&R3,CSPL             INITIALIZE CSPL (UPT, ECT, ECB)
         ST    &R0,CSFLG                ZERO CSFLG
         LA    &R0,CSFLG
         ST    &R0,CSPLFLG
         LA    &R0,CSOA
         ST    &R0,CSPLOA
.*
.NOSETC  AIF   (NOT &PARS).NOSETP
         STM   &R1,&R3,PPL              INITIALIZE PPL (UPT, ECT, ECB)
         LA    &R0,TSPARANS             PTR TO PARSE ANSWER PLACE
         ST    &R0,PPLANS
         ST    &R13,PPLUWA              PARSE USER WORK AREA PTR
         XC    TSPARANS(4),TSPARANS     AVOID DUPLICATE IKJRLSA
.*
.NOSETP  AIF   (NOT &DAIR).NOSETD
         STM   &R1,&R3,DAPL             INITIALIZE DMPL (UPT, ECT, ECB)
         MVC   DAPLPSCB(4),CPPLPSCB
.*
.NOSETD  AIF   (NOT &IO).NOSETI
         STM   &R1,&R3,IOPL             INITIALIZE IOPL (UPT, ECT, ECB)
.*
.NOSETI  AIF   (NOT &MSG).NOSETM
         ST    &R3,MPLECB               INIT MPL ECB PTR
         LA    &R0,CPPL
         ST    &R0,MPLCPPL
         LA    &R0,MPLCSECT             PTR TO MSG CSECT
         ST    &R0,MPLCSECP
         XC    MPLSW(MPLZL),MPLSW       INITIALIZE REMAINING MPL TO 0
.NOSETM  ANOP
.NOSETPL AIF   ('&PARSE(1)' EQ '').NOPARSE
         SPACE 2
***********************************************************************
*                                                                     *
*  PARSE THE COMMAND LINE                                             *
*                                                                     *
***********************************************************************
         SPACE 2
         MNOTE *,'       TSPARSE CBUF=(CPPLCBUF,I),PCL=(=V(&PARSE(1)),I$
               ),'
         MNOTE *,'               SYNAD=&PARSE(2),ENTRY=&PARNAME'
         TSPARSE  CBUF=(CPPLCBUF,I),PCL=(=V(&PARSE(1)),I),             $
               SYNAD=&PARSE(2),ENTRY=&PARNAME
&NAME    SETC  ''
         SPACE 5
         AIF   ('&PARSE(2)' EQ '').NOPARSE   NO ERROR ANALYSIS ROUTINE
&NAME    SETC  '&IHBNX.P'
         SPACE 2
         B     &NAME                    SKIP AROUND PARSE ERR ANALYSIS
         SPACE 6
***********************************************************************
*                                                                     *
*  PARSE ERROR ANALYSIS SUBROUTINE                                    *
*                                                                     *
***********************************************************************
         TSPARERR
         SPACE 6
.NOPARSE AIF   ('&NAME' EQ '').NONAME
&NAME    DS    0H
.NONAME  ANOP
.INUSE   INUSE
         SPACE 2
         AIF   ('&PL' EQ '').MEND
         AIF   ('&GET2' NE '').PLOK2
         MNOTE 8,'*** PL= INVALID WITHOUT SECOND OPERAND OF GETMAIN='
         MEXIT
.PLOK2   EJECT
&GET2    DSECT
         DS    18F                      SAVE AREA
TSECB    DS    F                        ECB FOR TSO SERVICES
         SPACE 2
*        TSCPPL
         TSCPPL
         AIF   ('&TSFAKE' NE 'YES').NOFAKED
         SPACE 1
&T$FAKE  DS    2H,CL256                 AREA FOR FAKE CBUF
         AIF   ('&PRINT' NE 'NOGEN').NOFAKED
         PRINT NOGEN                    SUPPRESS THE DSECTS
.NOFAKED AIF   (NOT &CSPL).NOTCSPL
         SPACE 2
         MNOTE *,'       TSCSPL'
         TSCSPL
.NOTCSPL AIF   (NOT &PARS).NOTPARS
         SPACE 2
         MNOTE *,'       TSPPL'
         TSPPL
.NOTPARS AIF   (NOT &DAIR).NOTDAIR
         SPACE 2
         MNOTE *,'       TSDAPL'
         TSDAPL
         SPACE 1
DAPBAREA DS    22F                      AREA FOR DAIR PARAMETER BLOCK
         SPACE 2
         MNOTE *,'       TSDMPL'
         TSDMPL
.NOTDAIR AIF   (NOT &IO).NOTIO
         SPACE 2
         MNOTE *,'       TSIOPL'
         TSIOPL
.NOTIO   AIF   (NOT &MSG).NOTMSG
         SPACE 2
         MNOTE *,'       TSMPL'
         TSMPL
.NOTMSG  AIF   ('&PRINT' NE 'NOGEN').NOTMSGX
         PRINT GEN
.NOTMSGX AIF   ('&LOAD' EQ '').NOLOAD2
         SPACE 2
&X       SETA  1
.NXTLOAD AIF   (&X GT N'&LOAD).NOLOAD2
&LOAD(&X) DS   A
&X       SETA  &X+1
         AGO   .NXTLOAD
.NOLOAD2 SPACE 2
         AIF   ('&MACRO' NE 'YES').NOMACRO
         SPACE 3
***********************************************************************
*                                                                     *
*  DYNAMIC STORAGE DEFINED BY USER TSWORK MACRO                       *
*                                                                     *
***********************************************************************
         SPACE 1
         TSWORK
         SPACE 2
&GET1    EQU   *-&GET2                  LNTH OF DYNAMIC AREA TO GETMAIN
         SPACE 2
.NOMACRO AIF   (NOT &DAIR).NODAPBS
         AIF   (&GDAIRM).NODAPBS
&GDAIRM  SETB  1
         AIF   ('&PRINT' NE 'NOGEN').GEN4
         PRINT NOGEN                    SAVE SOME PAPER
.GEN4    EJECT
         MNOTE *,'       IKJDAP08'
         IKJDAP08
DAPB08L  EQU   *-DAPB08
         SPACE 5
         MNOTE *,'       IKJDAP18'
         IKJDAP18
DAPB18L  EQU   *-DAPB18
         SPACE 5
         MNOTE *,'       IKJDAP1C'
         IKJDAP1C
DAPB1CL  EQU   *-DAPB1C
         SPACE 5
         MNOTE *,'       IKJDAP30'
         IKJDAP30
DAPB30L  EQU   *-DAPB30
         AIF   ('&PRINT' NE 'NOGEN').NODAPBS
         PRINT GEN                      RESTORE
         SPACE 10
.NODAPBS ANOP
&NFS     CSECT
         SPACE 3
.MEND    MEND
         EJECT ,                                              09/84 DBC
         MACRO
&NFS     PRTLN &A,&I
         LCLC  &LQ
         LCLA  &L
&LQ      SETC  'L'''                    TO FOOL THE ASSEMBLER
         AIF   ('&A'(1,1) NE '''').NOTQ NOT QUOTED STRING
&L       SETA  K'&A-2                   SET LENGTH OF IT
&NFS     MVC   OUTBUFF(&L),=C&A
         AGO   .BAL
.NOTQ    AIF   ('&A' EQ 'OUTBUFF').OUTBUFF
         AIF   ('&I' EQ 'I').I
&NFS     MVC   OUTBUFF(&LQ&A),&A
.BAL     BAL   R14,PRTLN
         AGO   .MEND
.I       ANOP
&NFS     L     R15,=A(&A)
         MVC   OUTBUFF(&LQ&A),0(R15)
         AGO   .BAL
.OUTBUFF ANOP
&NFS     BAL   R14,PRTLN
.MEND    SPACE 1
         MEND
         EJECT ,                                              09/84 DBC
         MACRO
&NFS     PRTLN2  &DUMMY
&NFS     BAL   R14,PRTLN2
         MEND
         EJECT ,                                              09/84 DBC
         MACRO
&NFS     TAPIO &CCW,&DUMMY,&TM=UNEXTPMK
         AIF   ('&DUMMY' EQ '').OK
         MNOTE 4,'** TOO MANY POSITIONAL OPERANDS -- IGNORED **'
.OK      ANOP
&NFS     LA    R0,&CCW
         BAL   LKR,TAPIO
         B     &TM                      TAPEMARK FOUND
         SPACE 1
         MEND
         EJECT ,                                              09/84 DBC
         MACRO
&NFS     NEWPAGE  &C,&F
         AIF   ('&C' EQ '').JUSTBAL
         AIF   ('&C' EQ '(R0)').R0
&NFS     LA    R0,&C
.R0      BAL   LKR,NEWPAGE&F
         MEXIT
.JUSTBAL ANOP
&NFS     BAL   LKR,NEWPAGE&F+4
         MEND
         EJECT ,                                              09/84 DBC
         MACRO
&NFS     IFP2  &L,&B
&NFS     TM    TFLAG2,T2@PRT2
         AIF   ('&L'(1,1) EQ 'N').NO
         BO    &B
         MEXIT
.NO      BNO   &B
         MEND
         EJECT ,                                              09/84 DBC
         MACRO
&NFS     ICALL &RTN,&REG,&R1=,&R15=
         LCLC  &NAME
&NAME    SETC  '&NFS'
         AIF   ('&R1' EQ '').A
&NAME    LA    R1,&R1
&NAME    SETC  ''
.A       AIF   ('&R15' EQ '').B
&NAME    LA    R15,&R15
&NAME    SETC  ''
.B       ANOP
&NAME    BAL   &REG,&RTN
         SPACE 1
         MEND
         EJECT
TAPEMAP  ENTR  LPARM=R2,GETMAIN=(WORKLEN,WORKD),                       $
               EXIT=LEAVE,RC=0,BASE2=R11,BASE3=R7
         MVI   BLANKS,C' '
         MVC   BLANKS+1(L'BLANKS+L'OUTBUFF),BLANKS  GET OUTBUFF ALSO
         MVC   OUTCLR2(L'OUTBUFF2+2),OUTCLEAR  GET CC FOR "DASHES" ALSO
         MVC   DASHES(2),=C' -'    PRIME                      06/84 DBC
         MVC   DASHES+2(L'DASHES-2),DASHES+1
         MVC   PARM#MSG+1(L'PARM#MSG-1),PARM#MSG
         XC    JFCB(176),JFCB
         LA    R0,JFCB
         ST    R0,EXLST
         MVI   EXLST,X'87'
         LA    R0,TAPEBUFF              GET ADDR OF DATA BUFFER
         ST    R0,TCCW#DAT              SET INTO CCW
         MVI   TCCW#DAT,RD              RESTORE THE OPCODE
         LA    R1,FL1LABI               GET LABEL BUFFER ADDR
         ST    R1,TCCW#LBL              SET IN CCW
         MVI   TCCW#LBL,RD              RESTORE OPCODE
         LA    R0,FL2LABI               GET LABEL BUFFER ADDR
         ST    R0,TCCW#LBL+8            SET IN CCW
         MVI   TCCW#LBL+8,RD            RESTORE OPCODE
         LA    R1,MV#BUFF2              GET 2ND BUFFER ADDR
         ST    R1,MV#ABUF2              SAVE
         LA    R0,OUTBUFF2+110          GET ADDR OF END OF OUTBUFF2
         ST    R0,OB2END                SAVE FOR FUTURE REFERENCE
         LA    R0,OUTBUFF2+110+10       FOR UPDTE STUFF
         ST    R0,OB2END2
         SPACE 2
         OPEN  MF=(E,OPENMFL)           OPEN PRINT FILE
         L     R1,OPENMFL               GET SYSPRINT DCB ADDR
         TM    48(R1),X'10'             OPEN?
         BO    PRINTOK                  YES
         LA    R1,100                   GET ABEND CODE
         SVC   13                       AND LEAVE
         SPACE 2
PRINTOK  LH    R15,0(,R2)               GET PARM LEN
         LTR   R15,R15                  ANY?
         BNP   DONEPARM                 NO
         LA    R14,2(,R2)               SET ADDR OF FIRST ITEM
         LR    R0,R14                   SAVE IT
         MVC   PARM#MSG(8),=C' PARM='' '
         MVC   PARM#MSG+8(L'PARM#MSG-8),PARM#MSG+7   BLANK THE REST
         CH    R15,=H'21'               PARM TOO LONG FOR "TITLE2"?
         BNH   *+8                      NO - SKIP
         OI    TFLAG2,T2@LPARM          YES - SET FLAG
         EX    R15,MVCPARM              SAVE PARM IN OUTBUFF2
         LA    R1,PARM#MSG+7(R15)       GET ADDR OF END+1
         MVI   0(R1),C''''              PUT IN ENDING QUOTE
         OI    TFLAG1,T1@PARM           SET "HAVE PARM" FLAG
         SPACE 2
NEXTPARM LM    R1,R3,=A(PARMTAB,12,PARMLAST)
TESTPARM LH    R4,0(,R1)                GET LENGTH OF ITEM
         EX    R4,CLCPARM               THIS IT?
         BNE   INCRPARM                 NO - TRY NEXT
         OC    PARMFLAG,11(R1)          TURN ON BITS
         LA    R14,2(R14,R4)            INCR SCAN PTR
         SR    R15,R4                   DECR LENGTH LEFT
         SH    R15,=H'2'
         BP    NEXTPARM                 LOOP IF ANY MORE
         B     DONEPARM                 DONE...
         SPACE 2
NULLPARM SH    R15,=H'5'                DECR LENGTH LEFT            U14
         BNP   DONEPARM                 NOTHING LEFT                U14
         LA    R14,5(,R14)              POINT TO OPERAND            U14
         SR    R1,R1                    CLEAR ACCUMULATOR           U14
         SPACE 1
NULLLOOP CLI   0(R14),C'0'              DIGIT?                      U14
         BL    HAVENULL                 NO - HAVE COMPLETE NUMBER   U14
         IC    R0,0(,R14)               GET A DIGIT                 U14
         N     R0,F15                   STRIP IT                    U14
         MH    R1,=H'10'                SHIFT PREVIOUS              U14
         AR    R1,R0                    ADD NEW                     U14
         LA    R14,1(,R14)              BUMP SCAN PTR               U14
         BCT   R15,NULLLOOP             CONTINUE FOR LENGTH OF PARM U14
         SPACE 2
HAVENULL LTR   R1,R1                    ANYTHING GIVEN?             U14
         BNP   *+8                      YES - USE IT                U14
         STH   R1,NULLNUMB              SET NUMBER                  U14
         LA    R14,1(,R14)              BUMP SCAN PTR               U14
         SH    R15,H1                   DECR LENGTH LEFT            U14
         BP    NEXTPARM                 CONTINUE IF MORE            U14
         B     DONEPARM                 NONE LEFT                   U14
         SPACE 2
INCRPARM BXLE  R1,R2,TESTPARM           KEEP LOOKING
*  DIDN'T FIND IT IN TABLE
         CLC   =C'NULL=',0(R14)         SPECIAL KIND?               U14
         BE    NULLPARM                 YES - PROCESS IT            U14
*  INVALID PARM ITEM
         SR    R14,R0                   COMPUTE OFFSET INTO PARM
         LA    R14,1(,R14)              FIX IT
         CVD   R14,DWD                  CONVERT TO PACKED
         UNPK  PARMERR+28(3),DWD+6(2)   PUT INTO MSG
         OI    PARMERR+30,C'0'          FIX SIGN
         OI    TFLAG1,T1@PERR           SET "PARM ERROR" FLAG
         SPACE 3
DONEPARM LA    LCTR,60                  INIT LINECOUNTER
         PUSH  PRINT
         PRINT GEN
         SPACE 2
         TODAY TTL1DATE,PUNCT=NO,WEEKDAY=TTL1DAY,TIME=TTL1TIME,        $
               F15=F15                                              U14
         POP   PRINT
         SPACE 2
         L     R1,16                    -> CVT
         L     R1,0(,R1)                -> TCBWORDS
         L     R1,4(,R1)                -> TCB
         L     R1,12(,R1)               -> TIOT
         LA    R1,24(,R1)               -> DD SECTION
         ST    R1,DD#PTR                SAVE PTR
         SPACE 1
         TM    PARMFLAG,PF@INLIN+PF@NATTR PARM=INLINE OR NOATTR?
         BNZ   OK$PRT2                  YES - SKIP SECOND PRINT FILE
         L     R2,OPENMFL2              GET SYSPRNT2 DCB ADDR
         ICALL TIOTSCAN,LKR,R15=40(,R2) SEE IF WE HAVE IT
         B     OK$PRT2                  NOPE
         SPACE 1
         OPEN  MF=(E,OPENMFL2)          OPEN SECOND PRINT FILE
         OI    TFLAG2,T2@PRT2           ASSUME IT WORKS.
         TM    48(R2),X'10'             DID IT OPEN?
         BO    OK$PRT2                  YES
         SPACE 2
ABEND99  LA    R1,99                    GET ABEND CODE
         SVC   13                       BYE
         SPACE 2
OK$PRT2  L     R2,OPENMFLI              GET SYSIN DCB ADDR
         ICALL TIOTSCAN,LKR,R15=40(,R2) SEE IF IT'S THERE
         B     RDJFCB                   NOPE
         MVC   RET#ADDR,=A(READCARD)    SET RETURN ADDR
         SPACE 2
         OPEN  MF=(E,OPENMFLI)          OPEN INPUT FILE
         TM    48(R2),X'10'             OPEN?
         BZ    ABEND99                  NO.  (THIS SHOULD NEVER HAPPEN)
         MVI   OPENMFL,0                SET TO CLOSE BOTH FILES
         SPACE 2
READCARD L     R1,OPENMFLI              GET SYSIN DCB ADDR
         GET   (1),INBUFF
         OI    TFLAG1,T1@DATA           SET FLAG
         CLC   =C'./DDNAME',INBUFF      IS IT THIS?
         BE    INDDNAME                 YES - PROCESS
         CLC   =C'./VOLUME',INBUFF      IS IT THIS?
         BNE   *+10                     NO - MUST BE VOL NAME
         MVC   INBUFF(6),INBUFF+9       MOVE OVER
         MVI   JFCB+117,1               # OF VOL SER #'S
         MVC   JFCB+118(6),INBUFF       VOL SER #
         MVI   JFCB+52,X'40'            VOLUME SERIAL LIST CHANGED
         B     TAPEINDX                 SKIP THE RDJFCB, GO TO SUBROUTN
         SPACE 2
INDDNAME L     R1,TAPEMFL               GET ADDR OF TAPEDCB         U14
         MVC   40(8,R1),INBUFF+9        MOVE DDNAME INTO DCB        U15
         SPACE 2
RDJFCB   RDJFCB  MF=(E,TAPEMFL)
         B     TAPEINDX                 GO TO SUBROUTINE
         SPACE 3
EOD2     CLOSE MF=(E,OPENMFL)
         IFP2  N,LEAVE                  SKIP IF NOT OPEN
         CLOSE MF=(E,OPENMFL2)
         B     LEAVE                    RETURN
         SPACE 2
EOD      TM    TFLAG1,T1@DATA           DATA READ IN?
         BO    EOD2                     YES.
         MVC   RET#ADDR,=A(EOD2)        SET NEW RETURN ADDR
         B     RDJFCB
         SPACE 2
MVCPARM  MVC   PARM#MSG+7(0),0(R14)     << EXECUTED >>
CLCPARM  CLC   2(0,R1),0(R14)           << EXECUTED >>
         SPACE 2
******** PRINT GEN
         EJECT
***********************************************************************
*                                                                     *
* T A P E I N D X                                                     *
*                                                                     *
*    A ROUTINE WHICH READS IN THE VOLUME NAME & ALL THE DATA SET NAMES*
*        (FROM THE TRAILER LABELS) OF A TAPE (WITH STANDARD LABELS)   *
*        AND FORMATS AND PRINTS THE INFORMATION FROM THE LABELS.      *
*                                                                     *
***********************************************************************
         SPACE 1
TAPEINDX SR    LCTR2,LCTR2              INIT SECOND LINE COUNTER
         STH   LCTR2,NUMBNULL           INIT COUNT OF NULL FILES    U14
         OI    TFLAG1,T1@PAGE1+T1@ANLZ  1ST PAGE/THIS VOL + ANLZ LABEL
         SPACE 1
* OPEN TAPE VOLUME FOR LABEL=BLP
         MVC   JFCB+44(8),BLANKS        BLANK OUT ELEM NAME
         MVC   JFCB+68(2),=H'1'         FILE SEQ #                 WBF
         MVC   JFCB+70(2),=H'1'         VOL SEQ #
         MVC   JFCB+83(3),=X'620000'    SET EXPDT=98000 FOR UCC-1  WBF
         MVI   JFCB+98,X'40'            DSORG=PS
         MVI   JFCB+100,X'90'           RECFM=FB
         MVC   TITLE1+5(6),JFCB+118     INIT IN CASE NOT SL
         XC    FILE#SEQ,FILE#SEQ
         SPACE 1
         OPEN  MF=(E,TAPEMFL),TYPE=J
         L     R1,TAPEMFL               GET ADDR OF TAPEDCB         U14
         TM    48(R1),X'10'             DATA SET OPEN?              U14
         BO    TPOPENOK                 YES.
         NEWPAGE ,                      PRINT THE HEADER
         PRTLN '-*** TAPE VOLUME COULD NOT BE OPENED ***'
         B     RETURN
         SPACE 3
TPOPENOK NI    42(R1),X'F7'             BLOCK COUNT INACCURATE.     U14
         XC    LEN#TAPE(4*2),LEN#TAPE   CLEAR SL & NL LENGTHS
         NI    TFLAG1,255-T1@BADEN-T1@SL RESET FLAGS
         MVI   WHERE,0                  SET "WHERE ARE WE" FLAG
         TAPIO TCCW#RWD,TM=*+4     INSURE PROPER POSITION     09/84 DBC
         TAPIO TCCW#DAT,TM=LEADTPMK     READ IN VOLUME LABEL
         MVC   VOLLABI(80),TAPEBUFF     SAVE VOLUME LABEL
         SPACE 1
DO$SENSE L     R2,LASTSIZE         PRESERVE LENGTH OVER SENSE 09/84 DBC
         TAPIO TCCW#SNS                 READ SENSE DATA
         LA    R1,C'3'                  ASSUME 1600 BPI
         TM    SENSDATA+3,B'00000100'   PE MODE?
         BO    TRUE$GOT                 YES
         LA    R1,C'4'                  ASSUME 6250 BPI
         TM    SENSDATA+9,B'00001000'   CAPABLE OF 6250 BPI?
         BO    TRUE$GOT                 YES
         LA    R1,C'2'                  ELSE, 800 BPI
         SPACE 2
TRUE$GOT LR    R0,R1                    COPY DENSITY CHAR
         N     R1,F15                   STRIP IT
         SLL   R1,2                     *4
         LA    R1,DEN#LIST(R1)          POINT TO 4 CHAR FORM
         ST    R1,TRUE#DEN              SAVE ADDR
         STC   R0,TRUE#DEN              SAVE 1 CHAR FORM
         SPACE 2
         CLI   NUMBNULL+1,0             HOW MANY NULL SKIPPED?      U14
         BNE   NULL1ST                  MORE THAN ZERO.             U14
         CLC   VOLLABI(4),=C'VOL1VOL1'  VOLUME LABEL?
         BE    TPVOL1OK                 YES.
         SPACE 3
         MVC   VOLSERNO(6),JFCB+118     SET HERE FOR OVERPRINTING   U15
         NEWPAGE ,                      PRINT THE HEADER LINES
         PRTLN '0++++ NO VOL1 LABEL FOUND.  NL ANALYSIS FOLLOWS ++++'
         BCTR  LCTR,0                   ACCOUNT FOR EXTRA BLANK LINE
         PRTLN OUTBUFF                  BLANK LINE
         SPACE 1
NULL1ST  MVC   FL1ID,BLANKS             SET THE DSN                 U14
         SPACE 3
NL$NEXT  ST    R2,LASTSIZE         RESTORE SIZE OF FIRST BLOC 09/84 DBC
         ST    R2,BYTECNT          INIT TOTAL BYTES READ      09/84 DBC
         ST    R2,MAXBLKSI         INIT BIGGEST BLOCK READ    09/84 DBC
         MVC   BLOCKCNT,F1              INIT # OF BLOCKS READ
         MVI   NLFLAGS,NL@F             INIT NL TYPE FLAGS
         CH    R2,TAPEBUFF              IS FIRST BLOCK RECFM=V?
         BNE   *+8                      NO - SKIP
         OI    NLFLAGS,NL@V             YES - SET FLAG
         MVI   WHERE,3                  SET "WHERE ARE WE" FLAG
         MVC   UNLOADER,UNLOADER-1      CLEAR INDICATOR
         LH    R1,FILE#SEQ              GET FILE NUMBER
         LA    R1,1(,R1)                INCR
         STH   R1,FILE#SEQ              PUT BACK
         CVD   R1,DWD                   -> PACKED
         UNPK  DWD(5),DWD+5(3)          -> EBCDIC
         OI    DWD+4,C'0'               FIX SIGN
         MVC   FL1FILSQ,DWD+1           PUT INTO "LABEL"
         SPACE 1
*  NOW SEE IF THIS FILE IS ANYTHING SPECIAL THAT WE KNOW ABOUT.
***      CLC   =H'800',LASTSIZE         RIGHT SIZE?
***      BNE   NL$NMOVE                 NOT IEHMOVE
         BAL   LKR,TEST$MV              IS IT IEHMOVE?
         B     NL$NMOVE                 NO
         B     IEHMOVE2                 YES - 2 PRINT FILE FORMAT
         B     IEHMOVE1                 YES - 1 PRINT FILE FORMAT
         SPACE 2
NL$NMOVE CLC   TAPEBUFF(8),=H'60,0,56,0' RECFM=V,BLK=60,REC=56?
         BNE   NL$NCOPY                 NO - NOT IEBCOPY
         BAL   LKR,TEST$CPY             IS IT VS2COPY?
         B     NL$NCOPY                 NO
         B     IEBCOPY2                 YES - 2 PRINT FILE FORMAT
         B     IEBCOPY1                 YES - 1 PRINT FILE FORMAT
         SPACE 2
NL$NCOPY BAL   LKR,TEST$DMP             IS IT IEHDASDR?
         B     NL$NDSDR                 NO
         NOP   0                        YES - BUT DON'T USE 2ND     WBF
*                                             PRINT FILE            WBF
         B     IHDASDR1
         SPACE 2
NL$NDSDR BAL   LKR,TEST$UPS             MAYBE IEBUPDTE INPUT STREAM?
         B     NL$NUPDT                 BOY WILL THIS BE UNRELIABLE
         B     IEBUPDT2                 YES - 2 PRINT FILE FORMAT
         MVC   OUTBUFF2+8(27),=C'IS AN IEBUPXXX INPUT STREAM' 06/84 DBC
         MVC   OUTBUFF2+14(8),IEBUPXXX CORRECT RELOADER NAME  06/84 DBC
         B     NL$LOOP
         SPACE 2
NL$NUPDT BAL   LKR,TEST$FDR             IS IT FDR?
         B     NL$NFDR                  NO
         B     FDR2                     YES - 2 PRINT FILE FORMAT   WBF
         B     FDR1                     YES,- 1 PRINT FILE FORMAT   WBF
         SPACE 2
NL$NFDR  BAL   LKR,TEST$IS              IS IT IEBISAM?
         B     NL$NIS                   DIDN'T THINK SO...
         B     IEBISAM2                 YES - 2 PRINT FILE FORMAT
         B     IEBISAM1                 YES - 1 PRINT FILE FORMAT
         SPACE 3
NL$NIS   BAL   LKR,TEST$SLK             IS IT A SLICK BACKUP?
         B     NL$NSLK                  DIDN'T THINK SO...
         B     SLK2                     YES - 2 PRINT FILE FORMAT
         B     SLK1                     YES - 1 PRINT FILE FORMAT
         SPACE 3
NL$NSLK  BAL   LKR,TEST$MAP             IS IT A TAPEMAP PRINT FILE?
         B     NL$LOOP                  NO
         B     MAP2                     YES - 2 PRINT FILE FORMAT
****     B     NL$LOOP                  YES - 1 PRINT FILE FORMAT
         SPACE 3
NL$LOOP  TAPIO TCCW#DAT,TM=NL$EOF       READ A BLOCK
         B     NL$LOOP                  DO THAT TILL EOF
         SPACE 2
NL$EOF   CLI   UNLOADER,C' '            A SECOND LINE?
         BE    *+12                     NO - SKIP
         NEWPAGE  2                     MAKE SURE WE HAVE ENOUGH
         SPACE 1
         LH    R1,FILE#SEQ              GET THE FILE SEQ #
         CVD   R1,DWD                   TO PACKED
         MVC   #FILE-2(6),=X'402020202120'                    09/84 DBC
         ED    #FILE-2(6),DWD+5
         SPACE 1                                              09/84 DBC
         MVC   #UNLOAD,UNLOADER
         SPACE 3
NL$SL    CLC   =C'(NULL)',UNLOADER+2 SL NULL FILE?            06/84 DBC
         BE    NLSLDONE                 YES - CAN'T DO ANYTHING
         SPACE 1
         MVC   #INFOSRC,=C' SCAN ' IDENTIFY INFO SOURCE       06/84 DBC
         MVI   #RECFM,C'V'              ASSUME RECFM=V
         TM    NLFLAGS,NL@V             IS IT?
         BO    NL$1                     YES - CONTINUE
         MVI   #RECFM,C'F'              ASSUME RECFM=F
         TM    NLFLAGS,NL@F             IS IT?
         BO    NL$1                     YES - CONTINUE
         MVI   #RECFM,C'U'              ANYTHING ELSE IS RECFM=U
         SPACE 2
NL$1     L     R0,MAXBLKSI         GET SIZE OF LARGEST BLOCK  09/84 DBC
         CVD   R0,DWD
         MVC   #BLKSIZE(5),=X'2020202120'
         ED    #BLKSIZE-1(6),DWD+5
         SPACE 1
*******  MVI   #LRECL+4,C'?'
         SPACE 1
         L     R0,BLOCKCNT              GET BLOCK COUNT
         CVD   R0,DWD
         MVC   #BLKCNT-1(7),=X'20202020202120'
         ED    #BLKCNT-2(8),DWD+4
         SPACE 1
         MVC   #DEN+1(1),TRUE#DEN
         L     R14,TRUE#DEN
         TM    PARMFLAG,PF@DEN1
         BO    *+10
         MVC   #DEN,20(R14)
         SPACE 1
         L     R15,BLOCKCNT             COUNT # OF GAPS
         L     R1,BYTECNT
         M     R1-1,=F'100'             SCALE
         D     R1-1,0(,R14)             DIVIDE BY BYTES/INCH
         AH    R1,=Y(375)               ADD 1 TAPEMARK
         TM    TFLAG1,T1@SL             REALLY SL?
         BNO   *+12                     NO - SKIP
         AH    R1,=Y(2*375)             YES - 2 MORE TAPEMARKS
         LA    R15,4(,R15)              INCR # OF GAPS
         M     R15-1,=F'60'             EACH GAP IS .60 INCH
         CLI   TRUE#DEN,C'4'            UNLESS IT'S A 6250 TAPE
         BNE   *+8                      IT ISN'T
         SRL   R15,1                    THEN THEY'RE .3 INCH EACH
         AR    R1,R15                   ADD IN LENGTH OF GAPS
         LR    R2,R1                    SAVE
         ICALL TAPEFEET,R14,R15=#LENGTH-2                     06/84 DBC
         A     R2,LEN#TAPE+4
         ST    R2,LEN#TAPE+4
         LR    R1,R2                    COPY FOR SUBROUTINE
         ICALL TAPEFEET,R14,R15=#CUMLEN-2                     06/84 DBC
         SPACE 2
         PRTLN OUTBUFF
         CLI   UNLOADER,C' '            ANY SECOND PRINT LINE?
         BE    NL$DONE                  NO - SKIP
         TM    PARMFLAG,PF@INLIN        PARM=INLINE?
         BNO   NL$DONE                  NO - NO SECOND LINE
         PRTLN OUTBUFF2
         MVC   OUTBUFF2,OUTCLR2
         SPACE 2
NL$DONE  TM    TFLAG1,T1@SL             THIS TAPE SL?
         BO    NLSLDONE                 YES - DIFFERENT HANDLING
         SPACE 1
NL$DONEX TAPIO TCCW#DAT,TM=NULL$NL      READ NEXT FILE'S FIRST BLK  U14
         L     R2,LASTSIZE         GET SIZE OF LAST BLOCK     09/84 DBC
         B     NL$NEXT                  PROCESS NEXT FILE
         SPACE 2
NLSLDONE PRTLN OUTBUFF                  BLANK LINE
         B     NEXTFILE                 NEXT SL FILE
         SPACE 2
NULL$NL  LH    R1,NUMBNULL              GET NUMBER OF NULL FILES    U14
         LA    R1,1(,R1)                INCR                        U14
         STH   R1,NUMBNULL              SAVE NEW COUNT              U14
         CH    R1,NULLNUMB              DONE ENOUGH?                U14
         BH    HAVE$EOV                 YES - STOP                  U14
         LH    R1,FILE#SEQ              MUST INCR...                U14
         LA    R1,1(,R1)                ...THIS ALSO...             U14
         STH   R1,FILE#SEQ              ...                         U14
         MVC   #FILE-1(5),=X'2020202120'  MOVE IN EDIT MASK         U14
         CVD   R1,DWD                                               U14
         ED    #FILE-2(6),DWD+5                                     U14
         MVC   #UNLOAD+2(6),=C'(NULL)'  PUT IN INDICATOR      06/84 DBC
         PRTLN OUTBUFF                                              U14
         L     R0,LEN#TAPE+4            GET ACCUMULATED TAPE LENGTH U14
         AH    R0,=Y(375)               COUNT 1 TAPEMARK            U14
         ST    R0,LEN#TAPE+4            SAVE UPDATED                U14
         B     NL$DONEX                                             U14
         SPACE 3
TPVOL1OK OI    TFLAG1,T1@SL
         MVC   TITLE1+5(6),VOLSERNO
         MVC   TITLE1+19(10),VOLOWNER
         MVC   TITLE1+13(6),TITLE1+12   BLANK OUT KEYWORD
         CLC   VOLOWNER,BLANKS          OWNER ALL BLANK?
         BE    *+10
         MVC   TITLE1+13(6),=C'OWNER='
         NI    TFLAG2,255-T2@RQVOL      TURN OFF FLAG
         CLC   VOLSERNO(6),JFCB+118     GET WHAT WE ASKED FOR?
         BE    MATCHVOL                 YES - CONTINUE
         OI    TFLAG2,T2@RQVOL          SET FLAG
         SPACE 2
MATCHVOL NEWPAGE ,                      PRINT HEADER LINES
         NI    TFLAG1,255-T1@ANLZ       RESET FLAG
         TM    PARMFLAG,PF@NL      NL PROCESSING FORCED?      06/84 DBC
         BNZ   ANLZ1               YES, SET ANALYZE SIGNAL    06/84 DBC
         TM    PARMFLAG,PF@NOCHK   NO, SCAN BYPASSED?         06/84 DBC
         BNZ   NOANLZ1             YES, SKIP                  06/84 DBC
ANLZ1    OI    TFLAG1,T1@ANLZ      NO, SET ANALYZE SIGNAL     06/84 DBC
NOANLZ1  DS    0H                                             06/84 DBC
         SPACE 1
         TM    PARMFLAG,PF@NL           FORCE NL ANALYSIS?
         BNO   *+12                     NO - CONTINUE
         XI    TFLAG1,T1@SL             YES - TURN OFF FLAG
         B     NL$NEXT                  AND GO TO NL ROUTINE
         SPACE 1
         MVI   WHERE,1                  SET "WHERE ARE WE" FLAG
         TAPIO TCCW#LBL,TM=IEHINITT     READ THE HDR LABELS
         B     DATAREAD                 SKIP FIRST TIME
         SPACE 1
NEXTFILE TAPIO TCCW#FSF                 FWD SPACE
         MVI   WHERE,1                  SET "WHERE ARE WE" FLAG
         TAPIO TCCW#LBL,TM=HAVE$EOV     READ HDR LABELS
         SPACE 1
DATAREAD MVC   UNLOADER,UNLOADER-1      CLEAR UNLOADED FLAG
         TAPIO TCCW#FSF                 SKIP TO END OF HDR LABELS
         MVI   NLFLAGS,NL@V+NL@F        ASSUME RECFM=V & RECFM=F
         MVI   WHERE,3                  SET "WHERE ARE WE" FLAG
         TAPIO TCCW#DAT,TM=NULLFILE     READ DATA
         L     R1,LASTSIZE         GET SIZE OF (FIRST) BLOCK  09/84 DBC
         ST    R1,MAXBLKSI         INIT BIGGEST BLOCK READ    09/84 DBC
         AH    R1,=Y(4*80)              2 HDR + 2 EOF LABELS
         ST    R1,BYTECNT               INIT TOTAL BYTES READ
         MVC   BLOCKCNT,F1              INIT NUMBER OF BLOCKS READ
         NI    NLFLAGS,255-NL@CHANG     FIRST BLOCK NOT A CHANGE
         OI    NLFLAGS,NL@F             STILL COULD BE RECFM=F
         SPACE 2
         CLI   FL2RECFM,C'F'            RECFM=FB?
         BNE   NOT$RF$F                 NO - NOT IEHMOVE OR IEBISAM
         CLC   FL2LRECL,C00080          LRECL=80?
         BNE   FIND$EOF                 NO - NOT IEHMOVE OR IEBISAM
***      CLC   FL2BLKL,C00800           BLKSIZE=800?
***      BNE   TST$UPDT                 NO - NOT IEHMOVE'D
         CLI   FL2BLKA,C'B'             BLOCKED?
         BNE   TST$UPDT                 NO - NOT IEHMOVE'D
         BAL   LKR,TEST$MV              IS IT IEHMOVE?
         B     TST$UPDT                 NO - TRY NEXT
         B     IEHMOVE2                 YES - 2 PRINT FILE FORMAT
         B     TEST$LCT                 YES - 1 PRINT FILE FORMAT
         SPACE 3
TST$UPDT BAL   LKR,TEST$UPS             SEE IF IEBUPDTE INPUT STREAM
         B     TST$ISAM                 PROBABLY NOT
         B     IEBUPDT2                 YES - 2 PRINT FILE FORMAT
         MVC   OUTBUFF2+8(27),=C'IS AN IEBUPXXX INPUT STREAM' 06/84 DBC
         MVC   OUTBUFF2+14(8),IEBUPXXX CORRECT RELOADER NAME  06/84 DBC
         B     TEST$LCT
         SPACE 3
TST$ISAM BAL   LKR,TEST$IS              IS IT IEBISAM?
         B     TST$MAP                  NO
         B     IEBISAM2                 YES - 2 PRINT FILE FORMAT
         B     TEST$LCT                 YES - 1 PRINT FILE FORMAT
         SPACE 3
TST$MAP  BAL   LKR,TEST$MAP             IS IT A TAPEMAP PRINT FILE?
         B     FIND$EOF                 NO
         B     MAP2                     YES - 2 PRINT FILE FORMAT
         B     TEST$LCT                 YES - 1 PRINT FILE FORMAT
         SPACE 3
NOT$RF$F CLI   FL2RECFM,C'V'            RECFM=V?
         BNE   NOT$RF$V                 NO - NOT IEBCOPY'D
         CLI   FL2BLKA,C'S'             RECFM=VS?
         BNE   FIND$EOF                 NO - NOT IEBCOPY'D
         BAL   LKR,TEST$CPY             IS IT VS2COPY?
         B     FIND$EOF                 NO
         B     IEBCOPY2                 YES - 2 PRINT FILE FORMAT
         B     TEST$LCT                 YES - 1 PRINT FILE FORMAT
         SPACE 3
NOT$RF$V CLI   FL2RECFM,C'U'            RECFM=U?
         BNE   FIND$EOF                 NO - NOT IEHDASDR
         BAL   LKR,TEST$DMP             IS IT IEHDASDR?
         B     TST$FDR                  NO
         NOP   0                        DON'T USE 2ND PRINT FILE    WBF
         B     TEST$LCT                 CONTINUE
         SPACE 3
TST$FDR  BAL   LKR,TEST$FDR             IS IT FDR?
         B     TST$SLK                  NO
         B     FDR2                     YES - 2 PRINT FILE FORMAT   WBF
         B     TEST$LCT                 YES - 1 PRINT FILE FORMAT   WBF
         SPACE 3
TST$SLK  BAL   LKR,TEST$SLK             IS IT IEBISAM?
         B     FIND$EOF                 NO
         B     SLK2                     YES - 2 PRINT FILE FORMAT
         B     TEST$LCT                 YES - 1 PRINT FILE FORMAT
         SPACE 2
TEST$LCT TM    PARMFLAG,PF@INLIN        PARM=INLINE?
         BNO   FIND$EOF                 NO - SKIP THIS
         NEWPAGE  2                     MORE THAN 1 LINE LEFT?
         SPACE 1
         CLC   IEBCOPY,UNLOADER         UNLOADED BY IEBCOPY?
         BE    IEBCOPY1                 YES - PRINT EXTRA INFO
         CLC   IEHMOVE,UNLOADER         UNLOADED BY IEHMOVE?
         BE    IEHMOVE1                 YES - PRINT EXTRA INFO
         CLC   IEBISAM,UNLOADER         UNLOADED BY IEBISAM?
         BE    IEBISAM1                 YES - PRINT EXTRA INFO
         CLC   IEHDASDR,UNLOADER        DUMPED BY IEHDASDR?
         BE    IHDASDR1                 YES - PRINT EXTRA INFO
         CLC   FDR,UNLOADER             DUMPED BY FDR?
         BE    FDR1                     YES - PRINT EXTRA INFO
         CLC   SLICKMNG,UNLOADER        UNLOADED BY SLICK?
         BE    SLK1                     YES - PRINT EXTRA INFO
****     CLC   CTAPEMAP,UNLOADER        CREATED FOR TAPEMAP?
****     BE    MAP1                     DOESN'T MATTER - MORE THAN
****                                    ONE LINE OF INFO, SO CAN'T
****                                    PRINT IT INLINE
         SPACE 3
FIND$EOF TM    PARMFLAG,PF@NOCHK        CHECKING SL TAPE?     06/84 DBC
         BZ    SCAN$EOF                 YES - READ TILL EOF   06/84 DBC
         SPACE 1
         TAPIO TCCW#FSF                 FSF PAST REST OF DATA
         SPACE 2
READ$EOF MVI   WHERE,2                  SET "WHERE ARE WE" FLAG
         TAPIO TCCW#LBL,TM=MISS$EOF     READ TRAILER LABEL
TEST$EOF CLC   =C'EOF1',FL1LABI         TRAILER LABEL?
         BE    HAVE$EOF                 YES - OK
         CLC   =C'EOV1',FL1LABI         OTHER KIND?
         BE    HAVE$EOF                 YES - OK
         SPACE 1
MISS$EOF PRTLN '0EOF OR EOV LABEL NOT FOUND WHERE EXPECTED'
         B     REWINDIT                 REWIND AND LEAVE    %%%%%%%%%
         SPACE 2
SCAN$EOF TAPIO TCCW#DAT,TM=SL$SAVE      READ & TALLY A DATA BLOCK
         B     SCAN$EOF                 DO THAT TILL EOF
         SPACE 2
SL$SAVE  MVC   NL#SAVE(16),MAXBLKSI SAVE ALL INFO            09/84 DBC
         MVC   NL#FLAGX,NLFLAGS         MORE...
         B     READ$EOF                 GO READ THE EOF LABELS
         SPACE 2
HAVE$EOF LA    R1,1                     ASSUME 1-LINE GROUPS
         TM    PARMFLAG,PF@NOCHK        CHECKING?             06/84 DBC
         BNZ   *+8                      NO - SKIP             06/84 DBC
         LA    R1,2(,R1)                YES - NEED 2 MORE EACH
         CLI   UNLOADER,C' '            IS THIS FILE UNLOADED?
         BE    *+8                      NO - SKIP
         LA    R1,1(,R1)                YES - NEED 1 MORE LINE
         LR    R0,R1                    COPY FOR STUPID MACRO
         NEWPAGE  (R0)                  CHECK FOR ENOUGH LINES
         SPACE 2
         MVC   #UNLOAD,UNLOADER         SAY WHO UNLOADED IT
         MVC   #FILE(4),FL1FILSQ        FILE #
         ICALL DEZERO,R14,R1=#FILE      REMOVE LEADING ZEROES
         MVC   #DSN(17),FL1ID           DSN
         CLI   FL1FSEC,C'0'             PASSWORD PROTECTED?
         BE    NOTPSWD                  NO - SKIP
         CLI   FL1FSEC,C'1'             PASSWORD PROTECTED?
         BE    YESPSWD                  YES - MOVE IT IN
         CLI   FL1FSEC,C'3'             NOPWREAD?
         BNE   WHATPSWD                 NO - WHAT THEN????
         MVC   #PSWD,=C' WRT'           YES                   06/84 DBC
         B     NOTPSWD                  CONTINUE
WHATPSWD MVC   #PSWD,=C' ???'           SAY WHAT?             06/84 DBC
         B     NOTPSWD
YESPSWD  MVC   #PSWD,=C' YES'           SAY SO.               06/84 DBC
         SPACE 3
NOTPSWD  MVC   #CDATE(2),FL1CREDT+1     YEAR CREATED
         MVI   #CDATE+2,C'.'
         MVC   #CDATE+3(3),FL1CREDT+3   DAY CREATED
         MVC   #EDATE(2),FL1EXPDT+1     YEAR EXPIRES
         MVI   #EDATE+2,C'.'
         MVC   #EDATE+3(3),FL1EXPDT+3   DAY EXPIRES
         SPACE 3                                              06/84 DBC
         MVC   #INFOSRC,=C'LABELS' SHOW INFO SOURCE           06/84 DBC
         MVC   #BLKCNT(6),FL1BLKCT      BLOCK COUNT
         ICALL DEZERO,R14,R1=#BLKCNT    REMOVE LEADING ZEROES
         SPACE 2
         MVC   #RECFM(1),FL2RECFM       RECFM
         MVC   #RECFM+1(1),FL2BLKA      BLOCK ATTRIBUTE
         MVC   #RECFM+2(1),FL2CNTRL     CONTROL CHARACTER
         CLI   #RECFM+1,C'R'            WEIRDO RECFM?  (FR OR VR)
         BNE   NOT$RF$R                 NOT RECFM=FR OR VR
         MVC   #RECFM+3(1),#RECFM+2     MOVE CTL CHAR OVER
         MVC   #RECFM+1(2),=C'BS'       IT'S REALLY FBS OR VBS
NOT$RF$R MVC   #BLKSIZE(5),FL2BLKL      BLOCK LENGTH
         ICALL DEZERO,R14,R1=#BLKSIZE   REMOVE LEADING ZEROES
         MVC   #LRECL(5),FL2LRECL       RECORD LENGTH
         ICALL DEZERO,R14,R1=#LRECL     REMOVE LEADING ZEROES
         IC    R15,FL2DEN               GET TAPE DENSITY
         STC   R15,#DEN+1               SET IN PRINT LINE
         CLC   TRUE#DEN(1),FL2DEN       LABEL CORRECT?
         BE    *+8                      YES - OK
         OI    TFLAG1,T1@BADEN          SET BAD DENSITY FLAG
         N     R15,F15                  JUST DIGIT
         SLL   R15,2                    MULTIPLY BY 4
         LA    R3,DEN#LIST(R15)         POINT TO DENSITY VALUE
         TM    PARMFLAG,PF@DEN1         PARM=DEN1?
         BO    DEN$1                    YES - LEAVE 1 CHAR DEN
         CLI   FL2DEN,C'4'              TOO HIGH?
         BH    DEN$1                    YES - SKIP
         CLI   FL2DEN,C'0'              TOO LOW?
         BL    DEN$1                    YES - SKIP
         MVC   #DEN,20(R3)              MOVE CHAR FORM OF DENSITY
         SPACE 1
DEN$1    MVC   #TRTCH+1(2),FL2TRTCH     TAPE RECORDING TECHNI 06/84 DBC
         SPACE 1                                              06/84 DBC
         MVC   #CREATOR(8),FL2JOBD GET CREATING JOBNAME       06/84 DBC
         CLI   FL2STEPD,C' '       IS THERE A STEPNAME?       06/84 DBC
         BE    GOTCREAT            NO, SKIP                   06/84 DBC
         MVI   #CREATOR-1,C'X'     YES, SET SCAN STOPPER      06/84 DBC
         LA    R1,#CREATOR+8       LOAD BACK-SCANNER          06/84 DBC
         BALR  R14,0               LOAD LOOP HEAD             06/84 DBC
         BCTR  R1,0                BACK SCAN                  06/84 DBC
         CLI   0(R1),C' '          EO-JOBNAME YET?            06/84 DBC
         BER   R14                 NO, CONTINUE BACKSCAN      06/84 DBC
         MVI   1(R1),C'/'          YES, INSERT SEPARATOR      06/84 DBC
         MVC   2(8,R1),FL2STEPD    GET STEPNAME               06/84 DBC
         MVI   #CREATOR-1,C' '     CLEAR STOPPER              06/84 DBC
GOTCREAT DS    0H                                             06/84 DBC
         SPACE 2
*    *****  COMPUTE THE LENGTH (INCHES) OF THIS TAPE DATA SET.
         SPACE 1                                              06/84 DBC
         TM    PARMFLAG,PF@NOCHK   DON'T DO IT IF A SCAN IS - 06/84 DBC
         BZ    SKIPGUES             BEING DONE ANYWAY         06/84 DBC
         SPACE 1
         PACK  DWD,FL1BLKCT(6)          BLOCK COUNT
         CVB   R15,DWD                  SAVE BLOCK COUNT
         LA    R1,4(,R15)               ADD 4 GAPS TO BLOCK COUNT.
         M     R1-1,=F'60'              EACH GAP IS 6/10 INCH
*  NOTE - LENGTH KEPT IN .01 INCHES
         L     R3,TRUE#DEN              GET PTR TO TRUE DENSITY
         CLI   TRUE#DEN,C'4'            6250 BPI?
         BNE   *+8                      NO - SKIP
         SRL   R1,1                     GAPS AT 6250 ARE .3 INCH
         LR    R2,R1                    SAVE LENGTH OF GAPS
         PACK  DWD,FL2BLKL(5)           BLKSIZE.
         CVB   R1,DWD
         MR    R1-1,R15                 BLKSIZE * BLOCK_COUNT
         AH    R1,=Y(4*80)              2 HDR & 2 EOF LABELS
         M     R1-1,=F'100'             CONVERT TO .01
         D     R1-1,0(,R3)              DIVIDE BY DENSITY.
         AH    R1,=Y(375*3)             3 TAPEMARKS @ 3.75 INCH
         AR    R2,R1                    ADD TO LENGTH OF DATA
         LR    R1,R2                    COPY FOR SUBROUTINE
         ICALL TAPEFEET,R14,R15=#LENGTH-2 FORMAT FILE LENGTH  06/84 DBC
         A     R2,LEN#TAPE              ADD TO TOTAL LENGTH
         ST    R2,LEN#TAPE              SAVE NEW TOTAL LENGTH
         LR    R1,R2                    COPY FOR SUBROUTINE
         ICALL TAPEFEET,R14,R15=#CUMLEN-2 FORMAT CUMULATIVE L 06/84 DBC
SKIPGUES DS    0H                                             06/84 DBC
         SPACE 1
         PRTLN OUTBUFF
         CLC   =C'0001',FL1VOLSQ        FIRST VOLUME OF FILE?
         BE    TEST$EOV                 YES.
         MVC   FVOL#MSG+22(4),FL1VOLSQ  VOL SEQ #
         MVC   FVOL#MSG+80(6),FL1FILSR  FIRST VOLSER
         PRTLN FVOL#MSG
         SPACE 2
TEST$EOV CLC   =C'EOV2',FL2LABI
         BNE   NOT$EOV                  EOV.
         PRTLN ' *** THE ABOVE FILE IS CONTINUED ON ANOTHER VOLUME'
         B     HAVE$EOV
         SPACE 2
NOT$EOV  TM    PARMFLAG,PF@NOCHK        SL WITH NL ANALYSIS?  06/84 DBC
         BNZ   NO$CHECK                 NO - SEE IF SECOND LI 06/84 DBC
         MVC   MAXBLKSI(16),NL#SAVE RESTORE INFO             09/84 DBC
         MVC   NLFLAGS,NL#FLAGX         MORE...
         B     NL$SL                    YES - GO DO IT
         SPACE 2
NO$CHECK TM    PARMFLAG,PF@INLIN        INLINE MESSAGES?
         BNO   NEXTFILE                 NO - DO NEXT FILE
         CLI   UNLOADER,C' '            UNLOADED?
         BE    NEXTFILE                 NO - DO NEXT FILE
         PRTLN OUTBUFF2                 PRINT TRUE ATTRS OF UNLOADED DS
         MVC   OUTBUFF2,OUTCLR2         CLEAR OTHER PRINT LINE
         B     NEXTFILE                 DO NEXT FILE
         SPACE 3
HAVE$EOV PRTLN '-     *** EOV ***'
         LTR   LCTR2,LCTR2              ANYTHING PRINTED ON OTHER PAGE?
         BZ    NO$EOV2                  NO - SKIP
         MVC   OUTBUFF2(17),=C'-     *** EOV ***'
         PRTLN2                         FLAG END OF OTHER PRINT FILE
         SPACE 1
NO$EOV2  TM    TFLAG1,T1@BADEN          ANY INCORRECT DENSITIES?
         BNO   NO$BADEN                 NO - SKIP
         LA    R0,9                     ASSUME NOT PARM=NONOTE
         TM    PARMFLAG,PF@NONOT        WANT THE NOTE?
         BNO   *+8                      YES - SO USE 9
         LA    R0,6                     PARM=NONOTE, SO USE 6
         NEWPAGE  (R0)                  GO TO TOP OF PAGE IF NEEDED
         LA    LCTR,1(,LCTR)            WILL CALL PRTLN 1 EXTRA TIME
         MVC   OUTBUFF(113),=C'-*****  ONE OR MORE FILES HAVE DENSITY I$
               NDICATED INCORRECTLY IN LABELS.  ALL FILES ARE WRITTEN A$
               T XXXX BPI  *****'
         L     R2,TRUE#DEN              GET PTR TO 4 CHAR TRUE DEN
         CLI   TRUE#DEN,C'2'            800 BPI?
         BNE   *+6                      NO - OK
         BCTR  R2,0                     RIGHT JUSTIFY THE "800"
         MVC   OUTBUFF+98(4),20(R2)     MOVE INTO PRINT LINE
         PRTLN OUTBUFF
         MVI   OUTBUFF,C'+'             SET FOR OVERPRINT
         MVC   OUTBUFF+98(4),20(R2)     LIGHT UP THE DENSITY
         LA    R0,OUTBUFF               POINT TO OUTPUT LINE
         BAL   R14,PUTPRTLN             PRINT IT ONCE (NO CLEAR OUTBUFF
         PRTLN OUTBUFF                  AND THE THIRD TIME
         SPACE 2
NO$BADEN TM    PARMFLAG,PF@NONOT        WANT THE NOTE?
         BO    REWINDIT                 NO - SO DON'T
         NEWPAGE  4                     ENOUGH LINES LEFT ON PAGE?
         PRTLN '0NOTE:  LENGTH(S) ARE COMPUTED, (BASED ON BLKSIZE, BLKC$
               OUNT, AND DENSITY), AND ARE THEREFORE ONLY APPROXIMATE.'
         TM    TFLAG1,T1@ANLZ           ANALYZING?
         BO    REWINDIT                 YES - GOOD LENGTHS PRINTED
         PRTLN '        LENGTHS FOR RECFMS OTHER THAN F,FB,ETC MAY NOT $
               BE VERY CLOSE TO THE TRUE LENGTH.'
         SPACE 2
REWINDIT TAPIO TCCW#RWD                 REWIND THE TAPE
         SPACE 2
CLOSE$TP CLOSE MF=(E,TAPEMFL)
         SPACE 2
RETURN   L     R14,RET#ADDR             GET RETURN ADDR
         BR    R14
         SPACE 2
NULLFILE MVC   UNLOADER+2(6),=C'(NULL)' PUT IN INDICATOR      06/84 DBC
         TAPIO TCCW#LBL   %%%%%         READ EOF'S                %%%%%
         B     TEST$EOF   %%%%%         TEST FOR 'EOF'            %%%%%
         SPACE 2
UNEXTPMK PRTLN '0*** UNEXPECTED TAPE MARK ***'
         B     REWINDIT                 CLOSE UP & LEAVE
         SPACE 2
LEADTPMK NEWPAGE  ,                     PRINT THE HEADER LINES
         PRTLN '0++++ TAPE HAS LEADING TAPE MARK ++++'
         BCTR  LCTR,0                   ACCOUNT FOR EXTRA BLANK LINE
         PRTLN OUTBUFF                  BLANK LINE
         MVI   VOLLABI,C'X'             INSURE NL ROUTINE
         MVI   FILE#SEQ+1,1             INIT FILE SEQUENCE NUMBER   U14
         MVI   NUMBNULL+1,1             INIT NUMBER OF NULL FILES   U14
         TAPIO TCCW#DAT,TM=LEAD$EOV     READ FIRST BLOCK FROM FILE  U14
         B     DO$SENSE                 DO NL ANALYSIS
         SPACE 2
LEAD$EOV MVI   NUMBNULL+1,2             SET NUMBER OF NULL FILES    U14
         CLI   NULLNUMB+1,2             TOO MANY?                   U14
         BL    HAVE$EOV                 YES - STOP                  U14
         MVC   #UNLOAD+2(6),=C'(NULL)'  FLAG IT               06/84 DBC
         MVI   #FILE+3,C'1'             SET FOR PRINT               U14
         MVI   FILE#SEQ+1,2             INIT COUNTER                U14
         PRTLN OUTBUFF                                              U14
         B     DO$SENSE                                             U14
         SPACE 2
IEHINITT PRTLN '-++++ TAPE HAS BEEN RE-LABELLED WITH IEHINITT ++++'
         B     REWINDIT                 ...
         EJECT
TEST$MV  CLC   =C'UNLOADED',TAPEBUFF+16 IEHMOVE'S TRADEMARK?
         BNER  LKR                      NO
         MVC   UNLOADER(7),IEHMOVE      SAY WHO
         SPACE 1
TEST$RET IFP2  Y,4(,LKR)                RETURN POINT FOR 2 PRINT FILES
         B     8(,LKR)                  RETURN POINT FOR 1 PRINT FILE
         SPACE 2
TEST$CPY CLC   =X'00CA6D0F',TAPEBUFF+8  VS2COPY'S TRADEMARK?
         BNER  LKR                      NO
         MVC   UNLOADER(7),IEBCOPY      SAY WHO
         B     TEST$RET                 RETURN
         SPACE 2
TEST$UPS ST    LKR,DWD                  SAVE MY RETURN ADDR
         LA    R2,80                    BXLE INCR
         LA    R15,TAPEBUFF             BXLE START
         LR    R3,R15                   COPY FOR END
         A     R3,LASTSIZE         POINT PAST END            09/84 DBC
         SR    R3,R2                    POINT TO LAST CARD IN BLOCK
         SPACE 1
TEST$UPL LR    R1,R15                   COPY CARD START ADDR
         BAL   LKR,TEST$UP              IS THIS IEBUPDTE CTL CARD?
         B     TEST$UPB                 NO - GO BXLE
         MVC   UNLOADER(8),IEBUPXXX SAY WHO                   06/84 DBC
         L     LKR,DWD                  GET BACK MY RETURN ADDR
         B     TEST$RET                 AND RETURN TO CALLER
         SPACE 1
TEST$UPB BXLE  R15,R2,TEST$UPL          TRY ALL CARDS IN THIS BLOCK
         L     LKR,DWD                  RESTORE RETURN ADDR
         BR    LKR                      NOT IEBUPDTE INPUT STREAM
         SPACE 2
TEST$UP  CLC   =C'./',0(R1)             START RIGHT?
         BNER  LKR                      NO - THAT WAS QUICK
         LA    R1,2(,R1)                POINT TO SCAN START
         LA    R0,69                    MAX SCAN LENGTH
         BAL   R14,F$BLANK              FIND END OF NAME FIELD
         BAL   R14,F$CHARS              FIND THE VERB
         CLC   =C'ADD ',0(R1)
         BE    TU$SAVE
         CLC   =C'REPL ',0(R1)
         BE    TU$SAVE
         CLC   =C'CHANGE ',0(R1)
         BE    TU$SAVE
         CLC   =C'CHNGE ',0(R1)    IEBUPDAT TYPE CHANGE?      06/84 DBC
         BNER  LKR                 NO, RETURN EMPTY HANDED    06/84 DBC
         SPACE 2
TU$SAVE  MVC   UPDT#TYP(1),0(R1)        A,R,C
         MVC   IEBUPXXX,=C'IEBUPDTE' ASSUMPTION               06/84 DBC
         STM   R0,R1,TU$SAVE2      SAVE SCANNER               06/84 DBC
         SPACE 1
TU$LOOP  LA    R1,1(,R1)
         CLC   =C'MEMBER=',0(R1)
         BE    TU$MEM
         CLC   =C'NAME=',0(R1)
         BE    TU$NAM
         BCT   R0,TU$LOOP               SCAN THE REST OF THE CARD
         SPACE 3                                              06/84 DBC
************************************************************* 06/84 DBC
*        THIS IS NOT AN INTERESTING IEBUPDTE TYPE CARD, BUT * 06/84 DBC
*        IT STILL MIGHT BE AN INTERESTING IEBUPDAT TYPE     * 06/84 DBC
*        CARD. SCAN TO SEE IF THE OPERAND FIELDS START WITH * 06/84 DBC
*        A FIRST POSITIONAL PARAMETER THAT IS A MEMBER      * 06/84 DBC
*        NAME.                                              * 06/84 DBC
************************************************************* 06/84 DBC
         SPACE 1                                              06/84 DBC
         LM    R0,R1,TU$SAVE2      RESTORE VERB PTR           06/84 DBC
         BAL   R14,F$BLANK         SCAN PAST THE VERB         06/84 DBC
         BAL   R14,F$CHARS         SCAN TO THE OPERANDS       06/84 DBC
         STM   R0,R1,TU$SAVE2      SAVE OPERANDS PTR          06/84 DBC
         SPACE 1                                              06/84 DBC
         LA    R0,9                MAX L'NAME+1               06/84 DBC
         BALR  R14,0               LOOP HEAD                  06/84 DBC
         CLI   0(R1),C'='          IEBUPDTE TYPE CARD?        06/84 DBC
         BER   LKR                 YES, GIVE UP               06/84 DBC
         CLI   0(R1),C','          NO, EO-1ST OPERAND?        06/84 DBC
         BE    TU$UPDAT            YES, GO SAVE               06/84 DBC
         CLI   0(R1),C' '          MAYBE, CHECK AGAIN         06/84 DBC
         BE    TU$UPDAT            YES, GO SAVE               06/84 DBC
         LA    R1,1(,R1)           NO, ADVANCE SCANNER        06/84 DBC
         BCTR  R0,R14              LOOP BACK                  06/84 DBC
         BR    LKR                 1ST OPERAND TOO LONG; GVUP 06/84 DBC
         SPACE 1                                              06/84 DBC
TU$UPDAT MVC   IEBUPXXX,=C'IEBUPDAT' RESET "UNLOADER" NAME    06/84 DBC
         LM    R0,R1,TU$SAVE2      RESTORE NAME POINTER       06/84 DBC
         B     4(,LKR)             RETURN WITH NAME           06/84 DBC
         SPACE 2
TU$MEM   LA    R1,7(,R1)                POINT TO MEMBER NAME
         B     *+8                      SKIP OTHER LA
         SPACE 1
TU$NAM   LA    R1,5(,R1)                POINT TO MEMBER NAME
         SPACE 1
         MVI   8(R1),C','               BE SURE TO STOP
         B     4(,LKR)                  FOUND A NAME
         SPACE 2
F$BLANK  BCTR  R0,0                     -1 FROM LENGTH
         CLI   0(R1),C' '               GOT A BLANK YET?
         BER   R14                      YES - RETURN
         LA    R1,1(,R1)                MOVE SCAN PTR
         BCT   R0,F$BLANK+2             KEEP SCANNING
         BR    LKR                      NONE--RETURN TO CALLER'S CALLER
         SPACE 2
F$CHARS  BCTR  R0,0                     -1 FROM LENGTH
         CLI   0(R1),C' '               FIND A CHAR?
         BNER  R14                      YES - RETURN
         LA    R1,1(,R1)                INCR SCAN PTR
         BCT   R0,F$CHARS+2             KEEP SCANNING
         BR    LKR                      NONE--RETURN TO CALLER'S CALLER
         SPACE 2
TEST$DMP CLC   =X'F47006016663B24D',TAPEBUFF+12  IEHDASDR'S TRADEMARK?
         BNER  LKR                      NO
         MVC   UNLOADER(8),IEHDASDR     SAY WHO
         MVC   DASDRSAV(24),TAPEBUFF    SAVE HEADER RECORD
         LR    R2,LKR                   SAVE RETURN ADDR
         TAPIO TCCW#DAT                 IGNORE CCWS
         SPACE 1
COM$DUMP TAPIO TCCW#DAT                 READ FIRST TRK'S DATA
         MVC   FDRSAVE(8),TAPEBUFF+12   SAVE IN CASE FDR
         LR    LKR,R2                   RETURN
         B     TEST$RET
         SPACE 2
TEST$FDR CLC   =C'THATS ALL FOLK',TAPEBUFF+5   HIS TRADEMARK?
         BNER  LKR                      NO
         LR    R2,LKR                   SAVE RETURN ADDR
         MVC   DASDRSAV(24),TAPEBUFF    SAVE HEADER RECORD
         MVC   UNLOADER(3),FDR          SAY FDR FOR NOW
         CLI   TAPEBUFF+19,C'S'         WAS IT FDR?
         BE    COM$DUMP                 YES
         MVC   UNLOADER(6),FDRDSF       NO  - MAYBE FDRDSF
         CLI   TAPEBUFF+19,C'F'         FDRDSF?
         BE    COM$DUMP                 YES
         MVC   UNLOADER(6),FDRXXX       NO  - BUT SOME KIND OF FDR?
         B     COM$DUMP                 CONTINUE
         SPACE 2
TEST$SLK CLC   =F'20',LASTSIZE     RIGHT LENGTH FOR SLICK HDR 09/84 DBC
         BNER  LKR
         CLC   TAPEBUFF+8(12),FFS         FF'S AT END OF RECORD?
         BNER  LKR
         CLI   TAPEBUFF+1,C'B'          BACKUP FLAG PRESENT?
         BNER  LKR
         MVC   DASDRSAV(20),TAPEBUFF    SAVE THE FIRST RECORD
         LR    R2,LKR                   SAVE RETURN ADDR
         TAPIO TCCW#DAT                 GET 2ND RECORD
         LR    LKR,R2                   RESTORE RETURN ADDR
         CLC   TAPEBUFF(2),=H'0'        1ST HALFWORD = 0?
         BNER  LKR
         CLC   TAPEBUFF+2(2),=H'0'      2ND HALFWORD = 0 OR FF'S?
         BE    TEST$SK1
         CLC   TAPEBUFF+2(2),FFS
         BNER  LKR
TEST$SK1 LH    R2,TAPEBUFF+4            VERIFY LENGTH OF RECORD
         LTR   R2,R2
         BNPR  LKR
         LA    R2,8(,R2)
         C     R2,LASTSIZE         LENGTH OK?                09/84 DBC
         BNER  LKR
         CLC   TAPEBUFF+6(2),=H'0'      LAST HALF OF RDW = 0?
         BNER  LKR
         MVC   UNLOADER(8),SLICKMNG     SHOW SLICKMNG AS UNLOADER
         B     TEST$RET                 RETURN TO MAINLINE
         SPACE 3
* FOR IEBISAM, THE BEGINNING OF THE DCB IS UNLOADED TO THE FIRST
* TWO CARDS.  SO CHECK (GUESS?) IF IT LOOKS LIKE AN ISAM DCB
TEST$IS  CLC   TAPEBUFF(4),=Y(0,154)    SEQ # AND LENGTH CORRECT?
         BNER  LKR                      NO
         CLC   TAPEBUFF+80(2),H1        SECOND SEQ # CORRECT
         BNER  LKR                      NO
         TM    TAPEBUFF+4+48,X'10'      DCBOFLGS,DCBOFOPN
         BNOR  LKR                      NOT "OPEN"
         CLI   TAPEBUFF+4+26,X'80'      DSORG=IS?
         BE    *+10                     YES - CONTINUE
         CLI   TAPEBUFF+4+26,X'81'      DSORG=ISU?
         BNER  LKR                      NO
         MVC   UNLOADER(7),IEBISAM      SAY WHO
         B     TEST$RET                 RETURN
         SPACE 3
TEST$MAP CLC   =C'$$TAPEMAP.PRINT.FILE$$',TAPEBUFF  CHECK FOR HEADER
         BNER  LKR                      NO
         L     R1,LASTSIZE         VERIFY BLOCK MULT OF 80 BY 09/84 DBC
         SR    R0,R0
         LA    R2,80
         DR    R0,R2
         LTR   R0,R0
         BNZR  LKR                      NO
         MVC   UNLOADER(7),CTAPEMAP     YES - THIS IS FOR US
         B     TEST$RET
         EJECT
IEHMOVE1 MVC   #BLKCNT+OUTBUFF2-OUTBUFF(4),=C'DSN='
         MVC   #BLKCNT+OUTBUFF2-OUTBUFF+4(44),TAPEBUFF+85 MOVE DISK DSN
         SPACE 1
         BAL   LKR,SET$ONE
         DC    Y(169)                   DSORG OFFSET
         DC    Y(171)                   RECFM OFFSET
         DC    Y(173)                   BLKSIZE OFFSET
         DC    Y(175)                   LRECL OFFSET
         SPACE 3
IEBCOPY1 BAL   LKR,SET$ONE
         DC    Y(12)                    DSORG OFFSET
         DC    Y(18)                    RECFM OFFSET
         DC    Y(14)                    BLKSIZE OFFSET
         DC    Y(16)                    LRECL OFFSET
         SPACE 3
IEBISAM1 BAL   LKR,SET$ONE
         DC    Y(4+26)                  DSORG OFFSET
         DC    Y(4+36)                  RECFM OFFSET
         DC    Y(4+62)                  BLKSIZE OFFSET
         DC    Y(4+2+82)                LRECL OFFSET
         SPACE 3
SET$ONE  MVC   OUTBUFF2+8(24),=C'TRUE ATTRIBUTES:  DSORG='
         ICALL CNVDSORG,R14,R15=OUTBUFF2+32 FORMAT THE DSORG
         ICALL CNVRECFM,R14,R15=#RECFM+OUTBUFF2-OUTBUFF
         SPACE 1
         LA    R1,TAPEBUFF
         AH    R1,4(,LKR)               POINT TO BLKSIZE
         ICALL CONVHALF,R14,R15=#BLKSIZE-1+OUTBUFF2-OUTBUFF
         SPACE 1
         LA    R1,TAPEBUFF
         AH    R1,6(,LKR)               POINT TO LRECL
         ICALL CONVHALF,R14,R15=#LRECL-1+OUTBUFF2-OUTBUFF
         SPACE 2
PRT$ONE  TM    TFLAG1,T1@ANLZ           ANALYZING?
         BNO   FIND$EOF                 NO
         B     NL$LOOP                  YES - KEEP SCANNING NL TAPE
         SPACE 3
*  FIRST RECORD SAVED IN "DASDRSAV"
IHDASDR1 MVC   OUTBUFF2+8(15),=C'DUMP FROM CCHH='
         UNPK  OUTBUFF2+23(9),DASDRSAV+0(5)
         TR    OUTBUFF2+23(8),HEXTAB    MAKE EBCDIC
         MVC   OUTBUFF2+31(5),=C' OF A'
         IC    R1,DASDRSAV+21           GET DEVTYPE
         N     R1,=F'255'               CLEAN
         MH    R1,=H'6'
         LA    R14,=C'2321  2311  2314  2302  2301  2305-12305-23330  3*
               340  3350  3375  3330-13380  '                 06/84 DBC
         LA    R14,0(R14,R1)            GET ADDR OF THIS DEVTYPE
         MVC   OUTBUFF2+37(6),0(R14)    MOVE TO PRINT LINE
         CLC   =F'0',DASDRSAV+8         THIS TAPE START AT 0?
         BNE   PRT$ONE                  NO - CAN'T FIND VOLSER
*  SECOND RECORD IS IN "TAPEBUFF"
         CLC   =C'VOL1VOL1',TAPEBUFF+216  LABEL?
         BNE   PRT$ONE                  NO - SKIP
         MVC   OUTBUFF2+46(7),=C'VOLUME='
         MVC   OUTBUFF2+53(6),TAPEBUFF+224
         MVC   OUTBUFF2+61(6),=C'OWNER='
         MVC   OUTBUFF2+67(10),TAPEBUFF+261
         B     PRT$ONE
         SPACE 3
* FIRST RECORD SAVED IN "DASDRSAV"
FDR1     MVC   OUTBUFF2+8(20),=C'DUMPED FROM A UUUUUU'
         MVC   FDRDVEND(1),DASDRSAV+4   SET UP FENCE FOR DEV TYPE
         LA    R1,FDRDVTAB              POINT TO FDR DEV TYPE TABLE
FDR1LOOP CLC   DASDRSAV+4(1),0(R1)      MATCH?
         BE    FDR1FND                  YES
         LA    R1,7(,R1)                NO  - BUMP TO NEXT ENTRY
         B     FDR1LOOP
FDR1FND  MVC   OUTBUFF2+22(6),1(R1)     PUT DEV TYPE IN MESSAGE
         CLC   =C'DUMMYDSF',FDRSAVE     IS IT A NORMAL DUMP?
         BE    PRT$ONE                  YES - ALL FOR NOW
*                                       NO  - MUST BE ABS TRK DUMP
         MVC   OUTBUFF2+28(22),=C' (ABSOLUTE TRACK DUMP)'
         B     PRT$ONE
         SPACE 3
SLK1     MVC   OUTBUFF2+8(30),=C'SLICK LIBRARY BACKUP, CYCLE = '
         MVC   OUTBUFF2+38(1),DASDRSAV  PUT IN THE CYCLE NUMBER
         MVC   OUTBUFF2+39(12),=C', MAXSIZE = '
         ICALL CONVHALF,R14,R1=DASDRSAV+2,R15=OUTBUFF2+41
         B     PRT$ONE                  PRINT THE INFO LINE
         EJECT
IEHMOVE2 LA    R0,7                     ASSUME PARM=NOMEM
         TM    PARMFLAG,PF@NOMEM        IS IT?
         BO    *+8                      YES
         LA    R0,9                     NO
         TM    TAPEBUFF+169,X'02'       DSORG=PO?
         BO    *+8                      YES
         LA    R0,7                     NO
         NEWPAGE  (R0),2                ENOUGH LINES LEFT ON PAGE?
         SPACE 1
         BAL   LKR,SET$FULL             SET UP HEADER
         DC    Y(169)                   DSORG OFFSET
         DC    Y(171)                   RECFM OFFSET
         DC    Y(173)                   BLKSIZE OFFSET
         DC    Y(175)                   LRECL OFFSET
         SPACE 1
         MVC   OUTBUFF2+47(7),IEHMOVE   WHO IT WAS UNLOADED BY
         SPACE 1
         ICALL CONVUNIT,LKR,R1=TAPEBUFF+282 CONVERT UNIT TYPE
         SPACE 1
         PRTLN2                         PRINT FIRST INFO LINE
         SPACE 1
         MVI   OUTBUFF2,C'0'            DOUBLE SPACE FOR MSM
         MVC   OUTBUFF2+25(7),=C'C-DATE='
         ICALL CONVDATE,LKR,R1=TAPEBUFF+138,R15=OUTBUFF2+32 C-DATE
         SPACE 1
         MVC   OUTBUFF2+42(7),=C'E-DATE='
         ICALL CONVDATE,LKR,R1=TAPEBUFF+141,R15=OUTBUFF2+49 E-DATE
         SPACE 1
         MVC   OUTBUFF2+59(4),=C'DSN='
         MVC   OUTBUFF2+63(44),TAPEBUFF+85       MOVE IN OLD DSN
         SPACE 1
****     CLC   =C'VS2',TAPEBUFF+152     CHECK PROGRAMMING SYSTEM
****     BE    MV$NOVOL                 SKIP IF OS/VS2
         TM    TAPEBUFF+132,X'0F'       SEE IF LOOKS LIKE PACKED DATE
         BO    MV$NOVOL                 SKIP IF NEW FORMAT IEHMOVE DS
         CLI   TAPEBUFF+135,0           INVALID FOR VOLSER ANYWAY?
         BE    MV$NOVOL                 SKIP IF NEW FORMAT IEHMOVE DS
         MVC   OUTBUFF2+120(4),=C'VOL='
         MVC   OUTBUFF2+124(6),TAPEBUFF+130
         SPACE 1
MV$NOVOL PRTLN2                         PRINT SECOND INFO LINE
         SPACE 2
         TM    TAPEBUFF+169,X'02'       DSORG=PO?
         BNO   STAR$TWO                 NO - SKIP
         BAL   LKR,FMU$                 PRINT HEADER
         SPACE 2
         L     BLEN,LASTSIZE       GET SIZE OF BLOCK          09/84 DBC
         SH    BLEN,=H'80'              MINUS FIRST CARD USED
         LA    BPTR,TAPEBUFF+80         -> NEXT CARD TO USE
         BAL   LKR,SEG$NEXT             NOW HAVE CARDS 1 & 2
         BAL   LKR,SEG$NEXT             NOW 2 & 3
         BAL   LKR,SEG$NEXT             NOW 3 & 4
         BAL   LKR,SEG$NEXT             NOW 4 & 5
         LA    DPTR,MV#BUFF1+46         -> FIRST MEMBER NAME -4
         CLI   0(DPTR),X'C8'            START OF MEMBER?
         BE    MV$GOT1                  YES
         LA    DPTR,3(,DPTR)            -> OTHER PLACE
         CLI   0(DPTR),X'C8'            START OF MEMBER?
         BE    MV$GOT1                  YES
         BAL   R14,BOOM                 PRINT LOGIC ERROR MSG
         SPACE 2
MV$GOT1  LA    DPTR,4(,DPTR)            -> FIRST MEMBER NAME
         SPACE 2
MV$LOOP  BAL   LKR,MOVE$MEM             MEMBER NAME TO PRINT LINE
         BAL   LKR,SEG$TEST             SEE IF WITHIN RANGE
         SPACE 2
*  RECORDS IN AN IEHMOVE UNLOADED DATASET HAVE THE FOLLOWING FORMAT:
*  FIRST 2 BYTES OF EACH CARD IS A BINARY SEQUENCE NUMBER.
*  AFTER THAT, THERE IS SOME HEADER INFO (THE FMT1 DSCB + OTHER JUNK),
*  THEN THE RECORDS IN THIS FORMAT:  LENGTH OF THIS "RECORD", 1 BYTE
*  INDICATOR WITH THE FOLLOWING BIT MEANINGS:
*    X'80' -> 3 BYTE TTR FOLLOWS INDICATOR BYTE
*    X'40' -> UNLOADED DS IS PDS
*    X'20' -> RECORD IS PART OF A MEMBER
*    X'10' -> RECORD IS A NOTE LIST
*    X'08' -> RECORD IS A DIRECTORY ENTRY
*    X'04' -> RECORD IS A DUMMY RECORD
*  THIS INFORMATION IS IN THE SOURCE TO MODULE IEHMVSRA
         SPACE 1
MV$NXTBL CLI   2(DPTR),X'E0'            DATA RECORD?
         BE    MV$REC                   YES
         CLI   2(DPTR),X'D0'            NOTE LIST RECORD?
         BE    MV$REC                   YES
         CLI   2(DPTR),X'C8'            DIRECTORY RECORD?
         BE    MV$MEND                  YES
         CLI   2(DPTR),X'C4'            DUMMY RECORD?
         BE    MV$DUMMY                 YES
         CLI   2(DPTR),X'0A'            END OF DS?
         BNH   DIR$END                  YES
*** LOGIC ERROR ***
         PRTLN2                         PRINT (POSSIBLY) UNFINISHED LIN
         BAL   R14,BOOM                 PRINT LOGIC ERROR MSG
         SPACE 2
MV$DUMMY MVC   DWD(2),0(DPTR)           COPY LENGTH TO ALIGNED PLACE
         LH    DLEN,DWD                 LOAD LENGTH OF DUMMY RECORD
         LA    DPTR,12(DPTR,DLEN)       POINT TO NEXT
         BAL   LKR,SEG$TEST             MAKE SURE STILL WITHIN RANGE
         B     MV$LOOP                  DO NEXT MEMBER NAME
         SPACE 2
MV$REC   MVC   DWD(2),0(DPTR)           COPY LEN TO ALIGNED PLACE
         LH    DLEN,DWD                 GET BLOCK LENGTH
         LA    DPTR,6(DPTR,DLEN)        POINT PAST LEN,E0,TTR,DATA
         SPACE 2
MV$SCAN  CL    DPTR,MV#ABUF2            WITHIN RANGE?
         BL    MV$NXTBL                 YES - PROCESS NEXT BLOCK
         BAL   LKR,SEG$NEXT             SKIP 78 BYTES
         B     MV$SCAN                  KEEP GOING
         SPACE 2
MV$MEND  LA    DPTR,6(,DPTR)            -> MEMBER NAME
         BAL   LKR,SEG$TEST             WITHIN RANGE?
         B     MV$LOOP                  GO PRINT NEXT NAME
         SPACE 2
SEG$TEST CL    DPTR,MV#ABUF2            WITHIN RANGE?
         BLR   LKR                      YES - JUST RETURN
         SPACE 1
SEG$NEXT MVC   MV#BUFF1,MV#BUFF2
         LTR   BLEN,BLEN                ANY LEFT?
         BP    SEG$MVC                  YES - USE IT
         BZ    *+8                      NO
* RAN OFF END OF DATASET
***      EX    0,*                      *** LOGIC ERROR ***
         B     DIR$END                  FORGET THAT - IT'S THE END
         SPACE 1
         ST    LKR,LKRSAVE              SAVE RETURN ADDR
         TAPIO TCCW#DAT,TM=SEG$EOF      READ ANOTHER BLOCK
         L     LKR,LKRSAVE              RESTORE RETURN ADDR
         LA    BPTR,TAPEBUFF            RESET PTR
         L     BLEN,LASTSIZE       AND LENGTH LEFT            09/84 DBC
         SPACE 1
SEG$MVC  SH    BLEN,=H'80'              DECR LENGTH LEFT / THIS BLOCK
         MVC   MV#BUFF2,2(BPTR)         MOVE A SEGMENT
         LA    BPTR,80(,BPTR)           -> NEXT SEGMENT
         SH    DPTR,=H'78'              BACK UP DATA PTR
         BR    LKR                      RETURN TO CALLER
         SPACE 2
SEG$EOF  BCTR  BLEN,0                   SET FLAG
         L     LKR,LKRSAVE              RESTORE RETURN ADDR
         OI    TFLAG1,T1@MVEOF          REMEMBER HIT EOF
         BR    LKR                      RETURN TO CALLER
         SPACE 3
CONVDATE SR    R0,R0                    CLEAR FOR IC
         IC    R0,0(,R1)                GET THE YEAR
         CVD   R0,DWD                   CONVERT TO PACKED
         UNPK  0(3,R15),DWD+6(2)        AND THEN TO EBCDIC
         OI    2(R15),C'0'              FIX SIGN
         MVC   0(2,R15),1(R15)          MOVE YEAR OVER
         MVI   2(R15),C'.'              PUT IN THE DOT
         MVC   DWD(2),1(R1)             MOVE DAY TO ALIGNED PLACE
         LH    R0,DWD                   GET THE YEAR
         CVD   R0,DWD                   CONVERT TO PACKED
         UNPK  3(3,R15),DWD+6(2)        AND THEN TO EBCDIC
         OI    5(R15),C'0'              FIX THE SIGN
         BR    LKR                      RETURN TO CALLER
         EJECT
IEBCOPY2 LA    R0,7                     ASSUME MEMBERS
         TM    PARMFLAG,PF@NOMEM        PARM=NOMEMBERS?
         BNO   *+8                      NOPE - OK
         LA    R0,5                     NO MEMBERS
         NEWPAGE  (R0),2                TEST LINE COUNTER
         SPACE 1
         BAL   LKR,SET$FULL             SET UP HEADER
         DC    Y(12)                    DSORG OFFSET
         DC    Y(18)                    RECFM OFFSET
         DC    Y(14)                    BLKSIZE OFFSET
         DC    Y(16)                    LRECL OFFSET
         SPACE 1
         MVC   OUTBUFF2+47(7),IEBCOPY   WHO IT WAS UNLOADED BY
         SPACE 1
         ICALL CONVUNIT,LKR,R1=TAPEBUFF+24  FORMAT THE UNIT TYPE
         SPACE 2
         BAL   LKR,FMU                  'FOLLOWING MEMBERS UNLOADED:'
         SPACE 2
         TAPIO TCCW#DAT                 IGNORE THE NEXT BLOCK
         SPACE 2
IBCPY$LP TAPIO TCCW#DAT                 READ A DIRECTORY BLOCK
         LH    BLEN,TAPEBUFF+4          GET RDW
         SH    BLEN,=H'8'               -8 FOR BDR & RDW
         LA    BPTR,TAPEBUFF+8          INIT BLOCK PTR
         SPACE 2
DIR$NEXT LA    DPTR,22(,BPTR)           INIT DIR BLK PTR
         LH    DLEN,20(,BPTR)           GET LENGTH USED
         SH    DLEN,=H'2'               LENGTH OF DATA
         SPACE 2
DIR$LP   CLC   0(8,DPTR),=8X'FF'        END OF DIRECTORY?
         BE    DIR$END                  YES - DONE
         BAL   LKR,MOVE$MEM             MOVE NAME TO PRINT LINE
         LTR   DLEN,DLEN                ANYTHING LEFT?
         BP    DIR$LP                   CONTINUE IF MORE LEFT
         LA    BPTR,256+12+8(,BPTR)     NEXT DIRECTORY BLOCK
         SH    BLEN,=Y(256+12+8)        DECR LENGTH LEFT
         BP    DIR$NEXT                 MORE IN THIS TAPE BLOCK
         B     IBCPY$LP                 GET NEXT BLOCK FROM TAPE
         SPACE 2
DIR$END  LA    R0,OUTBUFF2+20           GET START PTR FOR COMPARE
         CR    R0,PPTR                  ANY ON THIS LINE?
         BE    STAR$TWO                 NO - DONE
         PRTLN2                         PRINT PARTIAL LINE
         B     STAR$TWO                 CONTINUE PROCESSING
         SPACE 3
MOVE$MEM MVC   0(8,PPTR),0(DPTR)        MOVE NAME TO PRINT LINE
         IC    R1,11(,DPTR)             GET USER DATA LENGTH
         N     R1,=F'31'                STRIP OFF JUNK
         LA    R1,12(R1,R1)             GET LENGTH OF ENTRY
         AR    DPTR,R1                  ADVANCE DIR PTR
         SR    DLEN,R1                  DECR LENGTH LEFT
         SPACE 1
         LA    PPTR,10(,PPTR)           NEXT PRINT LINE POSITION
         CL    PPTR,OB2END              END OF PRINT LINE?
         BNHR  LKR                      NO - RETURN
         LR    PPTR,LKR                 SAVE RETURN ADDR
         PRTLN2                         PRINT IT
         LR    LKR,PPTR                 RESTORE RETURN ADDR
         LA    PPTR,OUTBUFF2+20         RESET PTR
         BR    LKR                      RETURN TO CALLER
         EJECT ,                                              09/84 DBC
IEBUPDT2 LA    R0,7
         TM    PARMFLAG,PF@NOMEM        PARM=NOMEM?
         BNO   *+8                      NO
         LA    R0,5                     YES
         NEWPAGE  (R0),2
         BAL   LKR,SET$FULD             SET UP HEADER INFO
         DC    4Y(0)                    FILLER
         MVC   OUTBUFF2+31(27),=C'IS AN IEBUPXXX INPUT STREAM' 6/84 DBC
         MVC   OUTBUFF2+37(8),IEBUPXXX CORRECT RELOADER NAME  06/84 DBC
         BAL   LKR,FMU                  'FOLLOWING MEMBERS UNLOADED:'
         SPACE 2
UPDTE$L1 LA    BLEN,80                  BXLE INCR
         LA    DPTR,TAPEBUFF            POINT TO START
         LR    BPTR,DPTR                COPY START ADDR
         A     BPTR,LASTSIZE       POINT PAST END OF BLOCK    09/84 DBC
         SR    BPTR,BLEN                BACK UP FOR BXLE
         SPACE 1
UPDTE$L2 LR    R1,DPTR                  COPY CARD ADDR
         BAL   LKR,TEST$UP              IS THIS ONE?
         B     UPDTE$BX                 NO - SKIP
         SPACE 1
         MVC   0(1,PPTR),UPDT#TYP       MOVE A,R,C
         MVI   1(PPTR),C'-'             SEPARATOR
         MVC   2(8,PPTR),0(R1)          MEMBER NAME
         LA    R1,1(,PPTR)
UPDTE$L3 CLI   0(R1),C','               END OF MEMBER NAME?
         BE    UPDTE$EM                 YES
         CLI   0(R1),C' '               END OF MEMBER NAME?
         BE    UPDTE$EM                 YES
         LA    R1,1(,R1)                INCR SCAN PTR
         B     UPDTE$L3                 CONTINUE
         SPACE 1
UPDTE$EM MVC   0(7,R1),OUTBUFF+1        BLANK OUT GARBAGE
         LA    PPTR,11(,PPTR)           BUMP PRINT LINE PTR
         CL    PPTR,OB2END2             PAST END?
         BNH   UPDTE$BX                 NO - CONTINUE
         PRTLN2                         PRINT THE MEMBERS
         LA    PPTR,OUTBUFF2+20         RESET PTR
         SPACE 1
UPDTE$BX BXLE  DPTR,BLEN,UPDTE$L2       KEEP SCANNING
         TAPIO TCCW#DAT,TM=UPDT$EOF     GET NEXT BLOCK
         B     UPDTE$L1                 GO CHECK IT
         SPACE 2
UPDT$EOF OI    TFLAG1,T1@MVEOF          SET "HIT EOF"
         B     DIR$END                  CLEAN UP
         SPACE 3
IEBISAM2 BAL   LKR,SET$FULL             SET UP HEADER
         DC    Y(4+26)                  DSORG OFFSET
         DC    Y(4+36)                  RECFM OFFSET
         DC    Y(4+62)                  BLKSIZE OFFSET
         DC    Y(4+2+82)                LRECL OFFSET
         SPACE 1
         MVC   OUTBUFF2+47(7),IEBISAM   WHO IT WAS UNLOADED BY
         SPACE 1
         ICALL CONVUNIT,LKR,R1=TAPEBUFF+4+17-3  CONVERT UNIT TYPE
         SPACE 1
         PRTLN2                         PRINT SECOND INFO LINE
         B     STAR$TWO
         EJECT ,                                              09/84 DBC
FDR2     NEWPAGE 9,2                    CHECK FOR ROOM ON PAGE
         BAL   LKR,SET$FULD             SET UP HEADER INFO
         DC    4Y(0)                    FILLER
         MVC   OUTBUFF2+31(14),=C'WAS DUMPED BY ' SET UP UNLOADER
         MVC   OUTBUFF2+45(6),UNLOADER            MESSAGE
         CLC   FDRSAVE,=C'DUMMYDSF'     NORMAL DUMP?
         BE    *+10                     YES
*                                       NO  - WARN USER
         MVC   OUTBUFF2+54(22),=C' (ABSOLUTE TRACK DUMP)'
         PRTLN2                         PRINT THE HEADER
         TM    PARMFLAG,PF@NOMEM        DETAILS WANTED?
         BO    FDR2NODT                 NO
*                                       YES - CHECK DUMP TYPE
         CLC   FDRSAVE,=C'DUMMYDSF'     WAS IT A DSF'ABLE DUMP?
         BNE   FDR2ABS                  NO
*                                       YES - ISSUE MESSAGE
         MVI   OUTBUFF2,C'0'
         MVC   OUTBUFF2+16(27),=C'FOLLOWING DATA SETS DUMPED:'
         PRTLN2
         MVC   OUTBUFF2,DSFHDING        SET UP COLUMN HEADING
         PRTLN2
FDR2LOOP CLC   =C'DUMMYDSF',TAPEBUFF+12 IS THIS A DSCB BLOCK?
         BNE   FDR2VOL                  NO  - TRY FOR VOLSER
*                                       YES
         LA    R5,TAPEBUFF+40           POINT TO FIRST DSCB
         LH    R6,TAPEBUFF+30           GET DSCB COUNT THIS BLOCK
FDR2DSCB LTR   R6,R6                    MORE DSCB'S TO GO?
         BNP   FDR2NBLK                 NO  - GET NEXT BLOCK
*                                       YES
         CLI   44(R5),C'1'              FORMAT 1 DSCB?
         BNE   FDR2NDSC                 NO
*                                       YES
         C     LCTR2,=F'1'              ROOM ON PAGE FOR NEXT LINE?
         BH    FDR2DSCC                 NO
         NEWPAGE ,2                     FORCE EJECT
         MVC   OUTBUFF2,DSFHDING        SET COL HEADINGS AGAIN
         PRTLN2                         PRINT THEM
FDR2DSCC MVC   OUTBUFF2+DSFDSN(44),0(R5)   MOVE IN DSNAME
         LH    R14,98(,R5)                 GET LAST TRACK USED
         LA    R14,1(,R14)                 MAKE 1 RELATIVE
         STH   R14,98(,R5)                 SAVE IT BACK
         ICALL CONVHALF,R14,R1=98(,R5),R15=OUTBUFF2+DSFTRK
         ICALL CNVRECFX,R14,R1=84(,R5),R15=OUTBUFF2+DSFRECFM
         ICALL CONVHALF,R14,R1=88(,R5),R15=OUTBUFF2+DSFLRECL-1
         ICALL CONVHALF,R14,R1=86(,R5),R15=OUTBUFF2+DSFBLKSZ+1
         ICALL CNVDSORX,R14,R1=82(,R5),R15=OUTBUFF2+DSFDSORG
         ICALL CONVDATE,LKR,R1=53(,R5),R15=OUTBUFF2+DSFCDATE
         ICALL CONVDATE,LKR,R1=56(,R5),R15=OUTBUFF2+DSFEDATE
         TM    93(R5),X'40'            RACF DEFINED?
         BZ    *+10                    NO
         MVC   OUTBUFF2+DSFSECUR+5(4),=C'RACF'   YES
         TM    93(R5),X'10'            PASSWORD?
         BZ    FDR2PRT                 NO
         MVC   OUTBUFF2+DSFSECUR(4),=C'WPWD'  YES - ASSUME WPWD
         TM    93(R5),X'04'            READ PSWD REQUIRED?
         BO    *+8                     NO
         MVI   OUTBUFF2+DSFSECUR,C'R'  YES
         TM    93(R5),X'50'            BOTH RACF/PSWD?
         BNO   FDR2PRT                 NO
         MVI   OUTBUFF2+DSFSECUR+4,C'/'  YES
FDR2PRT  PRTLN2                        PRINT THE LINE
FDR2NDSC LA    R5,148(,R5)             BUMP PAST DSCB/COUNT FIELD
         S     R6,=F'1'
         B     FDR2DSCB
FDR2NBLK TAPIO TCCW#DAT,TM=FDR2EOF     GET NEXT BLOCK
         B     FDR2LOOP
FDR2EOF  MVI   OUTBUFF2,C'0'
         OI    TFLAG1,T1@MVEOF         REMEMBER WE HIT EOF
       MVC  OUTBUFF2+12(63),=C'0***LISTING TERMINATED. FDR FILE NOT COM$
               PLETE ON THIS VOLUME***'
         PRTLN2
FDR2FAKE MVC   TAPEBUFF+4(4),=X'FFFFFFFF'   FAKE OUT FDR2VOL
FDR2VOL  MVI   OUTBUFF2,C'0'
         MVC   OUTBUFF2+8(20),=C'DUMPED FROM A UUUUUU'
         MVC   FDRDVEND(1),DASDRSAV+4   SET UP FENCE FOR DEV TYPE
         LA    R1,FDRDVTAB              POINT TO FDR DEV TYPE TABLE
FDR2VOLA CLC   DASDRSAV+4(1),0(R1)      MATCH?
         BE    FDR2VOLB                 YES
         LA    R1,7(,R1)                NO  - BUMP TO NEXT ENTRY
         B     FDR2VOLA
FDR2VOLB MVC   OUTBUFF2+22(6),1(R1)     PUT DEV TYPE IN MESSAGE
         MVC   OUTBUFF2+28(16),=C'         VOLSER='
         CLC   UNLOADER(6),FDRDSF       WAS THIS DSF?
         BE    FDR2VOLM                 YES - NO VOLSER AVAILABLE
         CLC   =XL4'00',TAPEBUFF+4      DOES DUMP INCLUDE CYL/TRK 0/0?
         BNE   FDR2VOLM                 NO  - NO VOLSER AVAILABLE
*                                       YES
         LA    R1,TAPEBUFF+20           POINT TO FIRST COUNT FIELD
         LA    R0,TAPEBUFF              POINT TO 2ND TRACK IN BLOCK
         AH    R0,TAPEBUFF+2
FDR2VOLC CLC   0(5,R1),=X'0000000003'   POINTING TO REC 3 ON TRK 0?
         BE    FDR2VOLG                 YES
         BH    FDR2VOLM                 NO - AND NO VOLSER AVAIL
         SR    R15,R15
         IC    R15,5(,R1)               GET KEY LENGTH
         AH    R15,6(,R1)               ADD IN DATA LENGTH
         LA    R1,8(R15,R1)             POINT TO NEXT RECORD
         CR    R1,R0                    PAST TRACK 0?
         BNL   FDR2VOLM                 YES
         B     FDR2VOLC                 NO  - KEEP GOING
FDR2VOLG CLC   8(8,R1),=C'VOL1VOL1'     GOT VOL LABEL?
         BNE   FDR2VOLM                 NO  - STRANGE
         MVC   OUTBUFF2+44(6),16(R1)    YES - MOVE IT INTO MSG
         B     FDR2VOLP
FDR2VOLM MVC   OUTBUFF2+43(14),=C' NOT AVAILABLE'
FDR2VOLP PRTLN2
         B     STAR$TWO
FDR2ABS  MVI   OUTBUFF2,C'0'
         MVC   OUTBUFF2+16(63),=C'ABSOLUTE TRACK DETAILS NOT AVAILABLE $
               IN THIS VERSION OF TAPEMAP'
         PRTLN2
         B     FDR2FAKE
FDR2NODT CLC   =C'DUMMYDSF',TAPEBUFF+12  DSCB BLOCK?
         BNE   FDR2VOL                   NO  - CHECK FOR VOLSER
         TAPIO TCCW#DAT,TM=FDR2EOF       YES - CHECK NEXT BLOCK
         B     FDR2NODT
         SPACE 3
SLK2     NEWPAGE 9,2                    CHECK FOR ROOM ON PAGE
         BAL   LKR,SET$FULD             SET UP HEADER INFO
         DC    4Y(0)                    FILLER
         MVC   OUTBUFF2+31(16),=C'WAS UNLOADED BY ' SET UP UNLOADER
         MVC   OUTBUFF2+47(8),UNLOADER            MESSAGE
         PRTLN2                         PRINT THE HEADER
         MVC   OUTBUFF2+8(30),=C'SLICK LIBRARY BACKUP, CYCLE = '
         MVC   OUTBUFF2+38(1),DASDRSAV  PUT IN THE CYCLE NUMBER
         MVC   OUTBUFF2+39(12),=C', MAXSIZE = '
         ICALL CONVHALF,R14,R1=DASDRSAV+2,R15=OUTBUFF2+41
         PRTLN2                         PRINT FIRST INFO LINE
         TM    PARMFLAG,PF@NOMEM        DETAILS WANTED?
         BO    STAR$TWO                 NO
*                                       YES
         MVI   OUTBUFF2,C'0'
         MVC   OUTBUFF2+16(27),=C'FOLLOWING MEMBERS UNLOADED:'
         PRTLN2
         MVC   OUTBUFF2,SLKHDING        SET UP COLUMN HEADING
         PRTLN2
SLK2LOOP OC    TAPEBUFF(2),TAPEBUFF     IS THIS A HEADER BLOCK?
         BNZ   SLK2NBLK                 NO  - TRY NEXT BLOCK
*                                       YES
         C     LCTR2,=F'1'              ROOM ON PAGE FOR NEXT LINE?
         BH    SLK2MGO                  NO
         NEWPAGE ,2                     FORCE EJECT
         MVC   OUTBUFF2,SLKHDING        SET COL HEADINGS AGAIN
         PRTLN2                         PRINT THEM
SLK2MGO  MVC   OUTBUFF2+SLKMEM(10),TAPEBUFF+8   MEMBER NAME
         MVI   OUTBUFF2+SLKSTAT-1,C'.'          .
         MVC   OUTBUFF2+SLKSTAT(4),TAPEBUFF+18  STATUS
         ICALL CONVP2,R14,R1=TAPEBUFF+32,       REVISION               X
               R15=OUTBUFF2+SLKREV
         MVC   OUTBUFF2+SLKINFO(8),TAPEBUFF+34  INFO
         MVC   OUTBUFF2+SLKTYPE(8),TAPEBUFF+42  TYPE
         ICALL CONVP4,R14,R1=TAPEBUFF+58,       ACTST                  X
               R15=OUTBUFF2+SLKACTST
         ICALL CONVP4,R14,R1=TAPEBUFF+62,       DELST                  X
               R15=OUTBUFF2+SLKDELST
         ICALL CONVP3,R14,R1=TAPEBUFF+66,       BLOCKS                 X
               R15=OUTBUFF2+SLKBLKS
         ICALL CONVMDY,R14,R1=TAPEBUFF+74,      C-DATE                 X
               R15=OUTBUFF2+SLKCREAT
         ICALL CONVMDY,R14,R1=TAPEBUFF+122,     U-DATE                 X
               R15=OUTBUFF2+SLKUPD
         PRTLN2
SLK2NBLK TAPIO TCCW#DAT,TM=SLK2EOF         GET NEXT BLOCK
         B     SLK2LOOP
SLK2EOF  OI    TFLAG1,T1@MVEOF             SET "HIT EOF"
         B     STAR$TWO
         EJECT ,                                              09/84 DBC
MAP2     NEWPAGE 9,2                    CHECK FOR ROOM ON PAGE
         BAL   LKR,SET$FULD             SET UP HEADER INFO
         DC    4Y(0)                    FILLER
         MVC   OUTBUFF2+31(49),=C'CONTAINS THE FOLLOWING USER-SUPPLIED $
               INFORMATION:'
         PRTLN2                         PRINT THE HEADER INFO
** USE R5 TO POINT TO INFO TO BE PRINTED,
** AND R6 TO CONTROL DEBLOCKING LOOP
         LA    R5,TAPEBUFF+80           SKIP FILE HEADER INFO
         L     R6,LASTSIZE                                    09/84 DBC
         SH    R6,=H'80'
         MVI   OUTBUFF2,C'0'            DOUBLE SPACE FIRST LINE
         B     MAPLOOPX                 BRANCH TO MIDDLE OF LOOP
MAPLOOP  LA    R5,80(,R5)               GET TO NEXT INFO LOGICAL RECORD
         SH    R6,=H'80'                CHECK FOR END OF BLOCK
MAPLOOPX BNP   MAPNEXT                  GET NEXT BLOCK IF NECESSARY
MAPLOOPY MVC   OUTBUFF2+16(72),0(R5)    PRINT 72 CHARS OF INFO
         PRTLN2
         B     MAPLOOP                  GET NEXT LOGICAL RECORD
MAPNEXT  TAPIO TCCW#DAT,TM=MAPEOF       READ NEXT BLOCK
         L     R1,LASTSIZE         VERIFY BLOCK MULT OF 80 BY 09/84 DBC
         SR    R0,R0
         LA    R2,80
         DR    R0,R2
         LTR   R0,R0
         BNZ   MAPERR                   NO  - ERROR
         LA    R5,TAPEBUFF              RESET LOOP REGS
         L     R6,LASTSIZE                                    09/84 DBC
         B     MAPLOOPY
MAPERR   MVC   OUTBUFF2+12(53),=C'*** LISTING TERMINATED, INVALID BLOCK$
                ENCOUNTERED ***'
         PRTLN2
         B     STAR$TWO
MAPEOF   OI    TFLAG1,T1@MVEOF          REMEMBER EOF FOUND
****     B     STAR$TWO
         EJECT ,                                              09/84 DBC
STAR$TWO MVC   OUTBUFF2(2),=C'0*'
         MVC   OUTBUFF2+2(L'OUTBUFF2-2),OUTBUFF2+1
         PRTLN2
         TM    TFLAG1,T1@MVEOF          ALREADY HIT EOF?
         BO    CHKMVEOF                 YES - SEE WHERE TO GO
         TM    TFLAG1,T1@SL             SL TAPE?
         BO    FIND$EOF                 YES - CONTINUE PROCESSING
         B     NL$LOOP                  SCAN THRU REST OF FILE
         SPACE 1
CHKMVEOF NI    TFLAG1,255-T1@MVEOF      RESET FLAG
         TM    TFLAG1,T1@SL             SL TAPE?
         BO    SL$SAVE                  YES - GO READ THE EOF LABELS
         B     NL$EOF                   NO
         SPACE 3
FMU      PRTLN2                         PRINT INFO LINE
FMU$     TM    PARMFLAG,PF@NOMEM        WANT MEMBER LISTING?
         BO    STAR$TWO                 NO - DONE
         MVI   OUTBUFF2,C'0'            SET CC
         MVC   OUTBUFF2+16(27),=C'FOLLOWING MEMBERS UNLOADED:'
         PRTLN2                         PRINT HEADER
         MVI   OUTBUFF2,C'0'            DOUBLE SPACE FIRST MEMBER LINE
         LA    PPTR,OUTBUFF2+20         INIT PRINT LINE PTR
         BR    LKR                      RETURN TO CALLER
         SPACE 3
SET$FULL MVC   OUTBUFF2+54(17),=C'...  WAS:  DSORG='
         ICALL CNVDSORG,R14,R15=OUTBUFF2+71  CONVERT DSORG
         SPACE 1
         MVC   OUTBUFF2+76(6),=C'LRECL='
         LA    R1,TAPEBUFF
         AH    R1,6(,LKR)               GET LRECL ADDR
         ICALL CONVHALF,R14,R15=OUTBUFF2+82  CONVERT LRECL
         BAL   R14,SLIDE                MOVE IT LEFT
         SPACE 1
         MVC   OUTBUFF2+90(6),=C'RECFM='
         ICALL CNVRECFM,R14,R15=OUTBUFF2+96  CONVERT RECFM
         SPACE 1
         MVC   OUTBUFF2+104(8),=C'BLKSIZE='
         LA    R1,TAPEBUFF
         AH    R1,4(,LKR)               GET BLKSIZE ADDR
         ICALL CONVHALF,R14,R15=OUTBUFF2+112 CONVERT BLKSIZE
         BAL   R14,SLIDE                MOVE IT LEFT
         SPACE 2
SET$FULD MVI   OUTBUFF2,C'-'            SET CC
         MVC   OUTBUFF2+1(17),FL1ID     MOVE IN (TAPE) DSN
         MVC   OUTBUFF2+19(5),=C'(FILE'
         MVC   OUTBUFF2+25(4),FL1FILSQ  MOVE IN FILE SEQ#
         MVC   OUTBUFF2+29(17),=C') WAS UNLOADED BY'
         B     8(,LKR)                  RETURN TO CALLER
         SPACE 3
BOOM     STM   R0,R15,BOOMREGS          SAVE ALL REGS
         MVC   OUTBUFF2(50),=C'0*** TAPEMAP LOGIC ERROR - CONTACT TEC S$
               UPPORT ***'                                          WBF
         PRTLN2                         PRINT ERROR MSG
         TM    PARMFLAG,PF@TEST         ABEND?
         BNO   STAR$TWO                 NO - IGNORE REST OF FILE
         SPACE 1
         CLOSE MF=(E,OPENMFL)           CLOSE SYSPRINT
         IFP2  N,BOOM2                  SKIP IF NOT OPEN
         CLOSE MF=(E,OPENMFL2)          CLOSE SYSPRNT2
         SPACE 1
BOOM2    LA    R14,BOOMREGS             POINT TO REG SAVE AREA
         EX    0,*                      AND AWAY WE GO
         EJECT
***********************************************************************
*                                                                     *
*  SUBROUTINE TO DO I/O TO TAPE                                       *
*                                                                     *
***********************************************************************
TAPIO    ST    R0,TAPEIOB+16            SET CCW ADDR
         EXCP  TAPEIOB
         WAIT  ECB=TAPEECB
         CLI   TAPEECB,X'7F'            DID IT WORK?
         BE    TAPIO$OK                 YES - CONTINUE
         CLI   TAPEECB,X'41'            CHANNEL PROGRAM ERROR?
         BNE   *+10                     NO - ERROR
         CLI   IOBCSW+4,X'0D'           CHEND, DEVEND, UNITEXCPT?
         BER   LKR                      YES - IT'S REALLY A TAPEMARK
         ST    LKR,LKRTAPIO             SAVE LKR FOR RECURSION      U16
         CH    LCTR,=H'60'              ANYTHING ON PAGE?           U13
         BL    *+8                      YES - CONTINUE              U13
         NEWPAGE  ,                     PRINT THE TITLE             U13
         MVC   OUTBUFF(44),=C'-*** TAPE I/O ERROR *** ECB CODE=XX *** C$
               SW='                                                 U13
         HEX   OUTBUFF+33,TAPEECB,LEN=1                             U13
         HEX   OUTBUFF+44,IOBCSW+1,LEN=7                            U13
         MVC   OUTBUFF+59(24),=C'*** IOBSENSE0,1=XXXX ***'          U13
         HEX   OUTBUFF+75,TAPEIOB+2,LEN=2                           U13
         PRTLN OUTBUFF
         SPACE 1
**       L     R1,DD#PTR                -> DD SECTION OF TIOT       U13
**       SH    R1,=H'24'                -> TIOT                     U13
**       AH    R1,TAPEDCB+40            -> DD ENTRY FOR TAPE        U13
**       L     R1,16(,R1)               -> UCB                      U13
         L     R1,TAPEMFL               -> DCB                      U13
         L     R1,44(,R1)               -> DEB                      U13
         L     R1,32(,R1)               -> UCB                      U13
         L     R2,20(,R1)               -> EXTENDED SENSE INFO      U13
         MVC   OUTBUFF(16),=C' *** SENSE DATA='                     U13
         HEX   OUTBUFF+16,(00,R2),LEN=4                             U13
         HEX   OUTBUFF+25,(04,R2),LEN=4                             U13
         HEX   OUTBUFF+35,(08,R2),LEN=4                             U13
         HEX   OUTBUFF+44,(12,R2),LEN=4                             U13
         HEX   OUTBUFF+54,(16,R2),LEN=4                             U13
         HEX   OUTBUFF+63,(20,R2),LEN=4                             U13
         PRTLN OUTBUFF                  PRINT THE SENSE DATA        U13
         SPACE 3
         NEWPAGE  10                    NEXT PAGE IF NEED ROOM      U15
         MVC  OUTBUFF(35),=C'0    BITS SET ARE FLAGGED ''*'' BELOW' U15
         PRTLN OUTBUFF                  PRINT HEADER                U15
         MVI   OUTBUFF,C'0'             DOUBLE SPACE FIRST ONE      U15
         SPACE 2
*  R2 -> SENSE DATA                                                 U15
         LA    R3,10                    NUMBER OF BYTES             U15
         L     R4,=A(ERR#LIST)          -> ERROR MESSAGES           U15
         SPACE 1
NEXTBYTE LA    R6,OUTBUFF+5             -> LINE POS                 U15
         LA    R1,X'80'                 MASK BIT                    U15
         SPACE 1
TEST$BIT MVC   2(10,R6),0(R4)           MOVE TEXT                   U15
         EX    R1,BIT$TM                IS THIS BIT SET?            U15
         BZ    *+8                      NO - SKIP                   U15
         MVI   0(R6),C'*'               FLAG THIS ONE               U15
         SPACE 1
         LA    R4,10(,R4)               -> NEXT MSG                 U15
         LA    R6,16(,R6)               -> NEXT PRINT LINE POS      U15
         SRA   R1,1                     MOVE BIT RIGHT              U15
         BNZ   TEST$BIT                 CONTINUE WITH THIS BYTE     U15
         PRTLN OUTBUFF                  PRINT DESC OF THIS BYTE     U15
         LA    R2,1(,R2)                -> NEXT BYTE OF SENSE DATA  U15
         BCT   R3,NEXTBYTE              CONTINUE IF MORE            U15
         SPACE 3
         CLI   WHERE,3                  READING DATA?
         BNE   CLOSE$TP                 NO - CLOSE UP AND LEAVE
         L     R1,TAPEIOB+16            GET CCW ADDR
         CLI   0(R1),RD                 WAS IT A READ?
         BNE   CLOSE$TP                 NO - CLOSE UP AND LEAVE
         LA    R0,TCCW#FSF              SKIP REST OF DATA...
         L     LKR,LKRTAPIO             RESTORE LKR                 U16
         B     TAPIO                    START AT TOP OF THIS SUBRTN
         SPACE 2
BIT$TM   TM    0(R2),*-*                << EXECUTED >>              U15
         SPACE 2
TAPIO$OK L     R0,=A(BUFFSIZE)          GET LENGTH REQUESTED
         MVC   DWD+2(2),IOBCSW+6        COPY LENGTH LEFT
         XC    DWD(2),DWD               CLEAR HIGH 2 BYTES
         S     R0,DWD                   MINUS LENGTH UNUSED
         ST    R0,LASTSIZE         EQUALS SIZE READ           09/84 DBC
         TM    TFLAG1,T1@ANLZ           ANALYZING?
         BNO   4(,LKR)                  NO - SKIP THIS JUNK
         A     R0,BYTECNT               ADD PREVIOUS BYTE COUNT
         ST    R0,BYTECNT               SAVE NEW TOTAL
         L     R1,BLOCKCNT              GET BLOCK COUNT
         LA    R1,1(,R1)                INCR
         ST    R1,BLOCKCNT              SAVE NEW COUNT
         CLC   LASTSIZE+2(2),TAPEBUFF START WITH BLKSIZE?     09/84 DBC
         BE    *+8                      YES - COULD BE RECFM=V
         NI    NLFLAGS,255-NL@V         NO - NOT RECFM=V
         CLC   LASTSIZE,MAXBLKSI        SAME SIZE?
         BE    4(,LKR)                  YES - DONE HERE
         BH    TAPIO$H                  LAST BLOCK IS BIGGEST
         TM    NLFLAGS,NL@CHANG         ALREADY CHANGED?
         BO    TAPIO$NL                 YES - TURN OFF RECFM=F
         OI    NLFLAGS,NL@CHANG         SET "CHANGED"
         B     4(,LKR)                  RETURN
         SPACE 1
TAPIO$H  OI    NLFLAGS,NL@CHANG         SET "CHANGED"
         MVC   MAXBLKSI,LASTSIZE        SAVE NEW BIGGEST BLKSIZE
TAPIO$NL NI    NLFLAGS,255-NL@F         NOT RECFM=F
         B     4(,LKR)                  RETURN TO CALLER
         EJECT
***********************************************************************
*                                                                     *
*  SUBROUTINE TO HANDLE PRINT OUTPUT                                  *
*                                                                     *
***********************************************************************
NEWPAGE  CR    LCTR,R0                  ENOUGH LINES LEFT?
         BNLR  LKR                      YES - JUST RETURN
         LA    LCTR,LINESPP-2           RESET LINE COUNTER
         PRTLN TITLE1
         TM    TFLAG1,T1@PAGE1          IS THIS FIRST PAGE OF VOL?
         BNO   NEWPAG$2                 NO - SKIP THIS STUFF.
         NI    TFLAG1,255-T1@PAGE1      TURN OFF FLAG
         MVC   TITLE2+1(28),TITLE2      BLANK IT OUT
         SPACE 1
NEWPAG$3 TM    TFLAG1,T1@PARM           HAVE PARM FIELD?
         BNO   NEWPAG$4                 NO - SKIP
         TM    TFLAG2,T2@LPARM          IS IT TOO LONG?
         BO    NEWPAG$4                 YES - SKIP
         MVC   TITLE2+1(28),PARM#MSG+1  MOVE IN THE PARM FIELD
         SPACE 1
NEWPAG$4 PRTLN TITLE2                   PRINT AUTHOR LINE
         SPACE 1
NEWPAG$1 TM    TFLAG1,T1@PARM           HAVE PARM FIELD?
         BNO   NEWPAG$2                 NO - DON'T PRINT IT
         TM    TFLAG2,T2@LPARM          LONG PARM FIELD?
         BNO   NEWPAG$5                 NO - ALREADY PRINTED        U15
         PRTLN PARM#MSG                 PRINT IT
NEWPAG$5 TM    TFLAG1,T1@PERR           ERROR IN PARM FIELD?
         BNO   NEWPAG$2                 NO - DON'T PRINT IT
         PRTLN PARMERR                  PRINT IT
         SPACE 1
NEWPAG$2 LA    R0,DASHES
         BAL   R14,PUTPRTLN             SEPARATOR LINE
         PRTLN COLHEAD1,I
         PRTLN COLHEAD2,I
         LA    R0,DASHES
         BAL   R14,PUTPRTLN             SEPARATOR LINE
         MVI   OUTBUFF,C'0'             DOUBLE SPACE THE FIRST FILE U15
         BCTR  LCTR,0                   ADJUST THE LINE COUNT       U15
         TM    TFLAG2,T2@RQVOL          WRONG VOLUME MOUNTED?       U15
         BNOR  LKR                      NO - ALL DONE               U15
         NI    TFLAG2,255-T2@RQVOL      TURN OFF FLAG NOW           U15
         MVI   OUTBUFF,C'-'             TRIPLE SPACE                U15
         MVI   OUTBUFF+41,C'*'          START OF BOX                U15
         MVC   OUTBUFF+42(49),OUTBUFF+41  REST OF IT                U15
         PRTLN OUTBUFF                  PRINT TOP OF BOX            U15
         MVC   OUTBUFF+41(50),=C'* ID OF MOUNTED VOLUME DIFFERS FROM ID$
                REQUESTED *'            MOVE IN MSG                 U15
         PRTLN OUTBUFF                  PRINT MSG                   U15
         SH    LCTR,=H'2'               ACCOUNT FOR TRIPLE SPACE    U15
         MVI   OUTBUFF+41,C'*'          START OF BOX                U15
         MVC   OUTBUFF+42(49),OUTBUFF+41  REST OF IT                U15
         PRTLN OUTBUFF                  PRINT BOTTOM OF BOX         U15
         MVI   OUTBUFF,C'0'             DOUBLE SPACE FIRST FILE     U15
         BR    LKR                      RETURN
         SPACE 3
PRTLN    ST    R14,PRT#SAVE             SAVE RETURN ADDR
         LA    R0,OUTBUFF               POINT TO OUTPUT LINE
         BAL   R14,PUTPRTLN             WRITE OUTPUT LINE
         L     R14,PRT#SAVE             RESTORE RETURN ADDR
         MVC   OUTBUFF,OUTCLEAR         CLEAR OUTPUT LINE
         BCTR  LCTR,R14                 RETURN IF MORE LINES LEFT
         ST    R14,R14SAVE              SAVE MY R14
         ST    LKR,LKRSAVE              SAVE SOMEONE'S LKR
         NEWPAGE ,                      DO A NEW PAGE
         L     R14,R14SAVE              RESTORE MY R14
         L     LKR,LKRSAVE              RESTORE SOMEONE'S LKR
         BR    R14                      RETURN TO CALLER
         SPACE 2
PUTPRTLN L     R1,OPENMFL               GET DCB ADDR
         PUT   (1),(0)                  WRITE OUTPUT LINE
         ORG   *-2                      BACK OVER BALR
         BR    R15                      MAKE HIM RETURN TO MY CALLER
         SPACE 3
NEWPAGE2 CR    R0,LCTR2                 ENOUGH LINES LEFT?
         BLR   LKR                      YES - JUST RETURN
         SPACE 1
         LA    R0,TITLE1                GET RECORD ADDR
         BAL   R14,PUTPRNT2+4           WRITE IT OUT
         LA    R0,DASHES
         BAL   R14,PUTPRNT2+4           WRITE IT OUT
         LA    LCTR2,LINESPP-2          RESET LINE COUNTER
         BR    LKR                      RETURN TO CALLER
         SPACE 3
PRTLN2   ST    R14,PRT#SAVE             SAVE RETURN ADDR
         LA    R1,3                     ASSUME TRIPLE SPACE
         CLI   OUTBUFF2,C'-'            IS IT?
         BE    P2$OK                    YES
         BCTR  R1,0                     ASSUME DOUBLE SPACE
         CLI   OUTBUFF2,C'0'            IS IT?
         BE    P2$OK                    YES
         BCTR  R1,0                     ASSUME SINGLE SPACE
         CLI   OUTBUFF2,C' '            IS IT?
         BE    P2$OK                    YES
         MVI   OUTBUFF2,C' '            MAKE A BLANK
         SPACE 1
P2$OK    SR    LCTR2,R1                 DECR LINE COUNT
         BP    P2$GO                    CONTINUE IF OK
         NEWPAGE  ,2                    SET NEW PAGE
         MVI   OUTBUFF2,C'-'            TRIPLE SPACE FIRST LINE     U13
         SH    LCTR2,=H'3'              ACCOUNT FOR IT              U13
         SPACE 1
P2$GO    BAL   R14,PUTPRNT2             WRITE OUTPUT LINE
         MVC   OUTBUFF2,OUTCLR2         CLEAR OUTPUT LINE
         L     R14,PRT#SAVE             GET RETURN ADDR
         BR    R14                      RETURN TO CALLER
         SPACE 3
PUTPRNT2 LA    R0,OUTBUFF2              GET RECORD ADDR
         L     R1,OPENMFL2              GET SYSPRNT2 DCB ADDR
         PUT   (1),(0)                  WRITE IT OUT
         ORG   *-2                      BACK OVER BALR
         BR    R15                      MAKE HIM RETURN TO MY CALLER
         SPACE 3
         PUSH  PRINT                                                U13
         PRINT GEN                                                  U13
         SPACE 1
PRT$EXIT DCBEXIT  BLKSIZE=3192,BUFNO=1                              U15
         POP   PRINT                                                U13
         EJECT
***********************************************************************
*                                                                     *
*    ICALLABLE SUBROUTINES                                            *
*                                                                     *
***********************************************************************
         SPACE 3
*  SUBROUTINE TO CONVERT A HALFWORD TO PRINTABLE FORM
CONVHALF MVC   DWD(2),0(R1)             MOVE FIELD TO AN ALIGNED PLACE
         LH    R0,DWD                   PICK IT UP
         CVD   R0,DWD                   CONVERT TO PACKED
         MVC   1(5,R15),=X'2020202120'  MOVE IN EDIT MASK
         ED    0(6,R15),DWD+5           DO THE EDIT
         BR    R14                      RETURN TO CALLER
         SPACE 3
*  SUBROUTINE TO CONVERT A 2-BYTE PACKED FIELD TO PRINTABLE FORM
CONVP2   MVC   1(3,R15),=X'202120'      MOVE EDIT PATTERN TO OUT AREA
         ED    0(4,R15),0(R1)           CONVERT PACKED TO DECIMAL
         BR    R14
         SPACE 3
*  SUBROUTINE TO CONVERT A 3-BYTE PACKED FIELD TO PRINTABLE FORM
CONVP3   MVC   1(5,R15),=X'2020202120'  MOVE EDIT PATTERN TO OUT AREA
         ED    0(6,R15),0(R1)           CONVERT PACKED TO DECIMAL
         BR    R14
         SPACE 3
*  SUBROUTINE TO CONVERT A 4-BYTE PACKED FIELD TO PRINTABLE FORM
CONVP4   MVC   1(7,R15),=X'20202020202120'  MOVE EDIT PATTERN
         ED    0(8,R15),0(R1)           CONVERT PACKED TO DECIMAL
         BR    R14
         SPACE 3
*  SUBROUTINE TO CONVERT A PACKED DATE FIELD TO PRINTABLE FORM
CONVMDY  MVC   MDYP(4),=PL4'0'          ZERO MDYP (4-BYTES PACKED)
         MVC   MDYP(3),0(R1)            GET MMDDYY (PACKED W/O SIGN)
         UNPK  MDYU(7),MDYP(4)          UNPACK IT
         MVC   0(2,R15),MDYU            MOVE MM
         MVI   2(R15),C'/'                   /
         MVC   3(2,R15),MDYU+2               DD
         MVI   5(R15),C'/'                   /
         MVC   6(2,R15),MDYU+4               YY
         BR    R14                      RETURN
         SPACE 3
*  SUBROUTINE TO REMOVE LEADING BLANKS
SLIDE    CLI   0(R15),C' '              NON-BLANK YET?
         BNER  R14                      YES - RETURN TO CALLER
         MVC   0(6,R15),1(R15)          MOVE IT LEFT 1 POS
         B     SLIDE                    AND CHECK IT AGAIN
         SPACE 3
*  SUBROUTINE TO REMOVE LEADING ZEROES
DEZERO   CLI   0(R1),C'0'               NON-ZERO YET?
         BNER  R14                      YES - RETURN
         MVI   0(R1),C' '               MAKE IT A BLANK
         A     R1,=F'1'                 ADVANCE
         B     DEZERO                   LOOP
         SPACE 3
*  SUBROUTINE TO CONVERT A UNIT TYPE
CONVUNIT MVC   OUTBUFF2+120(9),=C'UNIT=????'
         CLI   3(R1),X'0E'              TOO BIG?              06/84 DBC
         BHR   LKR                      YES - RETURN
         IC    R14,3(,R1)               ELSE GET BYTE
         N     R14,=F'255'              ISOLATE IT
         BZR   LKR                      INVALID IF ZERO
         BCTR  R14,0                    -1 BECAUSE NO ZERO
         MH    R14,=H'6'                LENGTH OF A TABLE ENTRY
         LA    R15,=C'2311  2301  2303  2302  2321  2305-12305-22314  3$
               330  3340  3350  3375  3330-13380  '           06/84 DBC
         LA    R14,0(R14,R15)           POINT TO CORRECT ENTRY
         MVC   OUTBUFF2+125(6),0(R14)   MOVE DEVTYPE TO LINE
         BR    LKR                      RETURN TO CALLER
         SPACE 3
*  SUBROUTINE TO CONVERT A DSORG
CNVDSORG LA    R1,TAPEBUFF
         AH    R1,0(,LKR)               GET DSORG ADDR
         SPACE 1
CNVDSORX TM    0(R1),X'01'              DSORG=**U
         BNO   *+8                      NO - SKIP
         MVI   2(R15),C'U'
         SPACE 1
         MVC   0(2,R15),=C'PO'          ASSUME DSORG=PO
         TM    0(R1),X'02'              IS IT?
         BOR   R14                      YES - RETURN TO CALLER
         SPACE 1
         MVC   0(2,R15),=C'DA'          ASSUME DSORG=DA
         TM    0(R1),X'20'              IS IT?
         BOR   R14                      YES - RETURN TO CALLER
         SPACE 1
         MVC   0(2,R15),=C'PS'          ASSUME DSORG=PS
         TM    0(R1),X'40'              IS IT?
         BOR   R14                      YES - RETURN TO CALLER
         SPACE 1
         MVC   0(2,R15),=C'IS'          ASSUME DSORG=IS
         TM    0(R1),X'80'              IS IT?
         BOR   R14                      YES - RETURN TO CALLER
         SPACE 1
         MVC   0(4,R15),=C'VSAM'        ASSUME VSAM
         CLC   0(2,R1),=X'0008'         IS IT?
         BER   R14                      YES - RETURN TO CALLER
         SPACE 1
         MVC   0(4,R15),=C'**  '        NONE OF THE ABOVE???
         BR    R14                      RETURN TO CALLER
         SPACE 3
*  SUBROUTINE TO CONVERT A RECFM
CNVRECFM LA    R1,TAPEBUFF
         AH    R1,2(,LKR)               GET RECFM ADDR
         SPACE 1
CNVRECFX TM    0(R1),X'C0'              RECFM=U?
         BNO   *+12                     NO - TRY NEXT
         MVI   0(R15),C'U'
         B     RECFM$2                  CONTINUE
         SPACE 1
         TM    0(R1),X'80'              RECFM=F?
         BNO   *+12                     NO - TRY NEXT
         MVI   0(R15),C'F'
         B     RECFM$2                  CONTINUE
         SPACE 1
         TM    0(R1),X'40'              RECFM=V?
         BNO   *+8                      NO - TRY NEXT
         MVI   0(R15),C'V'
         SPACE 1
RECFM$2  LA    R15,1(,R15)
         TM    0(R1),X'10'              BLOCKED?
         BNO   *+12                     NO - TRY NEXT
         MVI   0(R15),C'B'
         LA    R15,1(,R15)
         SPACE 1
         TM    0(R1),X'08'              SPANNED?
         BNO   *+12                     NO - TRY NEXT
         MVI   0(R15),C'S'
         LA    R15,1(,R15)
         SPACE 1
         TM    0(R1),X'20'              TRK OVFL?
         BNO   *+12                     NO - TRY NEXT
         MVI   0(R15),C'T'
         LA    R15,1(,R15)
         SPACE 1
         TM    0(R1),X'02'              RECFM=A?
         BNO   *+12                     NO - TRY NEXT
         MVI   0(R15),C'A'
         LA    R15,1(,R15)
         SPACE 1
         TM    0(R1),X'01'              RECFM=M?
         BNOR  R14                      NO - RETURN TO CALLER
         MVI   0(R15),C'M'
         BR    R14                      RETURN TO CALLER
         SPACE 3
*  SUBROUTINE TO COMPUTE TAPEFEET
TAPEFEET XR    R0,R0
         D     R0,=F'1200'              GET LENGTH IN FEET
         CH    R0,=H'600'               ROUND UP?
         BL    *+8                      NO
         A     R1,=F'1'                 ROUND UP.
         CVD   R1,DWD
         MVC   1(5,R15),=X'2020202120'
         ED    0(6,R15),DWD+5
         BR    R14                      RETURN TO CALLER
         SPACE 3
*  SUBROUTINE TO FIND A TIOT ENTRY
TIOTSCAN L     R1,DD#PTR                -> DD SECTION
         XR    R0,R0                    CLEAR FOR IC
         BAL   R14,*+6                  SET LOOP ADDR & SKIP
         SPACE 1
         AR    R1,R0                    POINT TO NEXT ENTRY
         IC    R0,0(,R1)                GET LENGTH OF THIS ENTRY
         LTR   R0,R0                    END OF TIOT?
         BZR   LKR                      YES - "NOT FOUND" RETURN
         CLC   4(8,R1),0(R15)           THIS IT?
         BNER  R14                      NO - LOOP
         CLC   =F'0',16(R1)             DD DUMMY? (LIKE MSM?)
         BNE   4(,LKR)                  NO - RETURN (FOUND)
         BR    LKR                      SAY NOT FOUND
         EJECT
         LTORG ,
         SPACE 6
*  REGISTERS USED IN ROUTINES TO LIST IEHMOVE & IEBCOPY UNLOADED MEMBRS
BLEN     EQU   R2      *PAIR*           BLOCK LENGTH LEFT
BPTR     EQU   R3      *PAIR*           -> CURRENT POS IN BLOCK
DLEN     EQU   R4                       DIRBLK OR DATA LENGTH LEFT
DPTR     EQU   R5                       -> CURRENT POS IN BLOCK
PPTR     EQU   R6                       -> POS IN PRINT LINE
         SPACE 1
*  OTHER MISC REGISTERS
LCTR     EQU   R8                       # OF LINES LEFT THIS PAGE
LCTR2    EQU   R9                       SAME FOR OTHER FILE
LKR      EQU   R10                      INTERNAL LINKAGE REGISTER   U14
         SPACE 1
CC       EQU   X'40'                    COMMAND CHAINING
SLI      EQU   X'20'                    SUPPRESS LENGTH INDIC.
         SPACE 1
RD       EQU   X'02'                    READ
FSF      EQU   X'3F'                    FORWARD SPACE FILE
RWD      EQU   X'07'                    REWIND
         SPACE 1
BUFFSIZE EQU   X'FFFF'             SIZE OF TAPE BUFFER        09/84 DBC
LINESPP  EQU   60                       LINES PRINTED PER PAGE
         SPACE 2
OPENMFL2 OPEN  (SYSPRNT2,OUTPUT),MF=L
OPENMFL  OPEN  (SYSPRINT,OUTPUT),MF=L
OPENMFLI OPEN  SYSIN,MF=L
TAPEMFL  OPEN  TAPEDCB,MF=L
         SPACE 1
EXLST    DC    A(0)
PRTEXLST DC    X'85',AL3(PRT$EXIT)
         SPACE 2
TAPEECB  DC    A(0)
TAPEIOB  DC    X'42000000'              IOBFLAG1 (SET FOR CMD CHAINING)
         DC    A(TAPEECB)               ECB ADDR
IOBCSW   DC    2F'0'                    CSW
         DC    A(0)                     CHANNEL PGM ADDR
         DC    A(TAPEDCB),A(0)          DCB ADDR
         DC    H'1',H'0'                TAPE BLOCK COUNT INCREMENT
         SPACE 1
TCCW#FSF CCW   FSF,0,0,1                FWD SPACE FILE
         SPACE 1
TCCW#LBL CCW   RD,*-*,CC,80             READ 80 BYTE BLOCK INTO FL1LABI
         CCW   RD,*-*,00,80             READ IN NEXT BLOCK INTO FL2LABI
         SPACE 1
TCCW#DAT CCW   RD,*-*,SLI,BUFFSIZE      READ DATA BLOCK
         SPACE 1
TCCW#RWD CCW   RWD,0,0,1                REWIND THE TAPE
         SPACE 1
TCCW#SNS CCW   4,SENSDATA,SLI,24        READ SENSE DATA
         SPACE 2
SENSDATA DC    XL24'00'                 SENSE DATA BUFFER
         SPACE 2
TFLAG1   DC    X'00'                    FLAGS
T1@PARM  EQU   X'80'                    HAVE PARM FIELD
T1@PERR  EQU   X'40'                    ERROR IN PARM FIELD
T1@PAGE1 EQU   X'20'                    THIS IS FIRST TITLE GROUP
T1@BADEN EQU   X'10'                    DENSITY ERROR IN TAPE LABEL(S)
T1@SL    EQU   X'08'                    THIS TAPE IS SL
T1@ANLZ  EQU   X'04'                    PARM=CHECK OR NL TAPE
T1@MVEOF EQU   X'02'                    IEHMOVE2 HAS READ TILL EOF
T1@DATA  EQU   X'01'                    HAVE INPUT DATA
         SPACE 1
TFLAG2   DC    X'00'                    MORE
T2@RQVOL EQU   X'80'                    REQUESTED VOL MISMATCH
T2@LPARM EQU   X'40'                    PARM FIELD LONGER THAN 21 CHARS
T2@PRT2  EQU   X'20'                    SECOND PRINT FILE IN USE
         SPACE 1
NLFLAGS  DC    X'00'                    NON-LABELLED TAPE FLAGS
NL@V     EQU   X'80'                    RECFM=V
NL@F     EQU   X'40'                    RECFM=F
NL@CHANG EQU   X'20'                    BLOCKSIZE HAS CHANGED
         SPACE 1
PARMFLAG DC    X'00'
PF@TEST  EQU   X'80'                    TEST
PF@INLIN EQU   X'40'                    INLINE
PF@NOMEM EQU   X'20'                    NOMEMBERS (NOMEM)
PF@DEN1  EQU   X'10'                    DEN1
PF@NATTR EQU   X'08'                    NOATTR
PF@NONOT EQU   X'04'                    NONOTE
PF@NOCHK EQU   X'02'                    NOCHECK (NOSCAN)      06/84 DBC
PF@NL    EQU   X'01'                    NL
         SPACE 1
PARMTAB  DC    H'3',C'TEST     ',AL1(PF@TEST)
         DC    H'5',C'INLINE   ',AL1(PF@INLIN)
         DC    H'8',C'NOMEMBERS',AL1(PF@NOMEM)
         DC    H'4',C'NOMEM    ',AL1(PF@NOMEM)
         DC    H'3',C'DEN1     ',AL1(PF@DEN1)
         DC    H'5',C'NOATTR   ',AL1(PF@NATTR)
         DC    H'5',C'NONOTE   ',AL1(PF@NONOT)
         DC    H'6',C'NOCHECK  ',AL1(PF@NOCHK)                06/84 DBC
         DC    H'5',C'NOSCAN   ',AL1(PF@NOCHK)                06/84 DBC
PARMLAST DC    H'1',C'NL       ',AL1(PF@NL)
         SPACE 2
IEBCOPY  DC    C'IEBCOPY'
IEHMOVE  DC    C'IEHMOVE'
IEBISAM  DC    C'IEBISAM'
IEHDASDR DC    C'IEHDASDR'
IEBUPXXX DC    C'IEBUPXXX'         IEBUPDTE OR IEBUPDAT       06/84 DBC
FDR      DC    C'FDR   '
FDRDSF   DC    C'FDRDSF'
FDRXXX   DC    C'FDR???'
SLICKMNG DC    C'SLICKMNG'                                    09/84 DBC
CTAPEMAP DC    C'TAPEMAP'
         SPACE 2
         DC    C' '                     FOR CLEARING "UNLOADER"
UNLOADER DC    CL8' '             /   /IEBCOPY/IEHMOVE/IEBISA 06/84 DBC
C00080   DC    C'00080'
         ORG   C00080+1
C00800   DC    C'00800'
RET#ADDR DC    A(EOD2)                  RETURN ADDR
DEN#LIST DC    F'200,556,800,1600,6250' DENSITY VALUES.
         DC    C'200 556 800 16006250'  MUST BE RIGHT AFTER ABOVE LINE
TRUE#DEN DC    C'3',AL3(DEN#LIST+8)     REAL DEN;  -> 4 CHAR REAL DEN
F1       DC    F'1'                                                 U14
H1       EQU   F1+2                                                 U14
F15      DC    F'15'                                                U14
NULLNUMB DC    H'0'                     # OF NULL FILES TO SKIP     U14
NUMBNULL DC    H'0'                     # OF NULL FILES / THIS TAPE U14
WHERE    DC    X'00'                    WHERE-WE-ARE FLAG
         SPACE 1
         PUSH  PRINT
         PRINT GEN
         SPACE 1
HEXTAB   HEXTAB  DUAL=NO
         SPACE 1
         POP   PRINT
         SPACE 1
FDRDVTAB DS    0C                                             09/84 DBC
         DC    C'A2305-1'                                     09/84 DBC
         DC    C'C2305-2'                                     09/84 DBC
         DC    C'M3380  '                                     09/84 DBC
         DC    C'N3375  '                                     09/84 DBC
         DC    C'T2314  '                                     09/84 DBC
         DC    C'U3340-1'          TABLE OF FDR DEVICE TYPES  09/84 DBC
         DC    C'V3340-2'          AND CODES
         DC    C'X3330  '
         DC    C'Y3330-1'
         DC    C'Z3350  '
FDRDVEND DC    C' ??????'          FENCE FOR UNKNOWN FDR DEVICES
         SPACE 1
REQ#VOL  DC    C'+** REQUESTED VOL="123456" **'
         SPACE 1
FVOL#MSG DC    C' *** THIS IS VOLUME # XXXX OF THE ABOVE MULTIPLE VOLUM$
               E FILE.  FIRST VOLUME WAS XXXXXX.'
         SPACE 1
PARMERR  DC    C' UNKNOWN PARM OPTION AT COL=XXX.  ANY REMAINING PARM I$
               GNORED.'
FFS      DC    XL12'FFFFFFFFFFFFFFFFFFFFFFFF'
         SPACE 4
PATCH    DC    50S(*)                   GUESS WHAT...
         EJECT
WORKD    DSECT                          RESUME
DD#PTR   DS    A                        -> DD SECTION OF TIOT
LEN#TAPE DS    F                        TAPE LENGTH
         DS    F                        NL LENGTH
FILE#SEQ DS    H                        NL FILE SEQ #
         DS    H                        (UNUSED)
PRT#SAVE DS    A                        SAVE FOR RETURN ADDR
LKRSAVE  DS    A                        MORE...
LKRTAPIO DS    A                        ...OF THE...
R14SAVE  DS    A                        ...SAME
TU$SAVE2 DS    2A                  USED BY TEST$UP            06/84 DBC
BOOMREGS DS    16F                      REG SAVE AREA FOR LOGIC ERROR
MAXBLKSI DS    F                   BIGGEST BLOCK READ SO FAR  09/84 DBC
LASTSIZE DS    F                   SIZE OF THE LAST BLK READ  09/84 DBC
BLOCKCNT DS    F                        # OF BLOCKS READ
BYTECNT  DS    F                        TOTAL # OF BYTES READ
NL#SAVE  DS    4F                  SAVE FOR NL STUFF IF SL    09/84 DBC
NL#FLAGX DS    X                        SAME
UPDT#TYP DS    C                        A,R,C FOR UPDTE
BLANKS   DS    0CL17,CL16' '
OUTCLEAR DC    C' '                     FOR CLEARING OUTBUFF
OUTBUFF  DS    CL133
OUTCLR2  DC    C' '                     FOR CLEARING OUTBUFF2
OUTBUFF2 DS    CL133,7C                                             U14
DASHES   DS    CL133
INBUFF   DS    CL80
LABELS   DS    3CL80                    FOR VOL,FL1,FL2
MV#ABUF2 DS    A(MV#BUFF2)              ADDR OF SECOND DE-SPANNING BUFF
MV#BUFF1 DS    CL78                     FIRST DE-SPANNING BUFFER
MV#BUFF2 DS    CL78                     SECOND DE-SPANNING BUFFER
PARM#MSG DS    CL110                    FOR PARM
OB2END   DS    A(OUTBUFF2+110)          ADDR OF END OF OUTBUFF2
OB2END2  DS    A(OUTBUFF2+110+10)       SAME FOR UPDTE
DASDRSAV DS    XL24                     FOR HEADER RECORD
FDRSAVE  DS    CL8                      FOR 'DUMMYDSF' IF PRESENT
MDYP     DS    PL4'0'                   FOR CONVMDY
MDYU     DS    CL7                      FOR CONVMDY
DWD      DS    D
JFCB     DS    XL176                    DWD ALIGNED
         ORG   WORKD+2048               ALIGN THE BUFFER REAL WELL
TAPEBUFF DS    CL(BUFFSIZE)             TAPE INPUT DATA BUFFER
WORKLEN  EQU   *-WORKD
         SPACE 2
         ORG   OUTBUFF+1
#UNLOAD  DS    CL8,1C                                         06/84 DBC
#FILE    DS    CL4,2C                                         06/84 DBC
#DSN     DS    CL17,2C
#PSWD    DS    CL4,2C                                         06/84 DBC
#CDATE   DS    CL6,2C
#EDATE   DS    CL6,2C                                         06/84 DBC
#INFOSRC DS    CL6,2C                                         06/84 DBC
#RECFM   DS    CL5,2C                                         06/84 DBC
#LRECL   DS    CL5,2C
#BLKSIZE DS    CL5,2C
#BLKCNT  DS    CL6,2C
#DEN     DS    CL4,1C                                         06/84 DBC
#TRTCH   DS    CL3,2C                                         06/84 DBC
#LENGTH  DS    CL4,2C                                         06/84 DBC
#CUMLEN  DS    CL4,2C                                         06/84 DBC
#CREATOR DS    CL17                                           06/84 DBC
         SPACE 2
         PUSH  PRINT
         PRINT GEN
         SPACE 2
         ORG   LABELS
         SPACE 2
         VOL   DSECT=NO
         FL1   DSECT=NO
         FL2   DSECT=NO
         POP   PRINT
         EJECT
TAPEMAP  CSECT                          RESUME
         SPACE 2
         XYZZY NOGEN               SUPPRESS EXPANSION         06/84 DBC
         SPACE 1                                              06/84 DBC
TAPEDCB  DCB   DSORG=PS,MACRF=E,DDNAME=SYSUT1,DEVD=TA,EXLST=EXLST,     $
               IOBAD=TAPEIOB
         XYZZY GEN                                            09/84 DBC
         SPACE 2
TITLE1   DC    C'1VOL=                             TAPE ANALYSIS PROGRA$
               M   (T A P E M A P)                DAYDAYDAY  MON DD, 19$
               YY  (YY.DDD)  HH:MM:SS'
TTL1TIME EQU   *-9
TTL1DATE EQU   TTL1TIME-23
TTL1DAY  EQU   TTL1DATE-11
         SPACE 2
TITLE2   DC    C'                                                      $
                                                                       $
                                    '
         SPACE 2
DSFHDING DS    CL133
         ORG   DSFHDING
         DC    CL17'0'
DSFDSN   EQU   *-DSFHDING
         DC    CL44'-------------------DSNAME-------------------',C'-'
DSFTRK   EQU   *-DSFHDING
         DC    CL9'TRKS USED',C'-'                     TRACKS USED
DSFRECFM EQU   *-DSFHDING
         DC    CL5'RECFM',C'-'                         RECFM
DSFLRECL EQU   *-DSFHDING
         DC    CL5'LRECL',C'-'                         LRECL
DSFBLKSZ EQU   *-DSFHDING
         DC    CL7'BLKSIZE',C'-'                       BLKSIZE
DSFDSORG EQU   *-DSFHDING
         DC    CL5'DSORG',C'-'                         DSORG
DSFCDATE EQU   *-DSFHDING
         DC    CL7'CREATED',C'-'                       C-DATE
DSFEDATE EQU   *-DSFHDING
         DC    CL7'EXPIRES',C'-'                       E-DATE
DSFSECUR EQU   *-DSFHDING
         DC    CL8'SECURITY',C'-'                      SECURITY
         ORG   ,
SLKHDING DS    CL133
         ORG   SLKHDING
         DC    CL17'0'
SLKMEM   EQU   *-SLKHDING
         DC    CL10'NAME------.'          MEMBER
SLKSTAT  EQU   *-SLKHDING
         DC    CL4'STAT',C'-'             STATUS
SLKREV   EQU   *-SLKHDING-1
         DC    CL3'REV',C'-'              REVISION
SLKINFO  EQU   *-SLKHDING
         DC    CL10'---INFO---',C'-'      INFO
SLKTYPE  EQU   *-SLKHDING
         DC    CL8'--TYPE--',C'-'         TYPE
SLKACTST EQU   *-SLKHDING-1
         DC    CL7'--ACTST',C'-'          ACTST
SLKDELST EQU   *-SLKHDING-1
         DC    CL7'--DELST',C'-'          DELST
SLKBLKS  EQU   *-SLKHDING-1
         DC    CL5'-BLKS',C'-'            BLOCKS
SLKCREAT EQU   *-SLKHDING
         DC    CL8'-CREATED',C'-'         CREATE DATE
SLKUPD   EQU   *-SLKHDING
         DC    CL8'-UPDATED'              LAST UPDATE DATE
         ORG   ,
         SPACE 2
         XYZZY NOGEN                                          09/84 DBC
         SPACE 1                                              09/84 DBC
SYSIN    DCB  DSORG=PS,MACRF=GM,DDNAME=SYSIN,LRECL=80,EODAD=EOD,BUFNO=1
         SPACE 2
SYSPRINT DCB   DSORG=PS,MACRF=PM,DDNAME=SYSPRINT,LRECL=133,            $
               RECFM=FBA,EXLST=PRTEXLST
         SPACE 2
SYSPRNT2 DCB   DSORG=PS,MACRF=PM,DDNAME=SYSPRNT2,LRECL=133,            $
               RECFM=FBA,EXLST=PRTEXLST
         SPACE 1                                              06/84 DBC
         XYZZY GEN                 RESTORE EXPANSIONS         06/84 DBC
         SPACE 3
COLHEAD1 DC    CL133' '            1ST TITLE LINE             06/84 DBC
         ORG   COLHEAD1+1          RELOCATE BACK              06/84 DBC
         DC    CL8'RELOAD',C' '    #UNLOAD                    06/84 DBC
         DC    CL4'FILE',C'  '     #FILE                      06/84 DBC
         DC    CL17' ',C'  '       #DSN                       06/84 DBC
         DC    CL4'PSWD',C'  '     #PSWD                      06/84 DBC
         DC    CL6' ',C'  '        #CDATE                     06/84 DBC
         DC    CL6' ',C'  '        #EDATE                     06/84 DBC
         DC    CL6' INFO',C'  '    #INFOSRC                   06/84 DBC
         DC    CL5' ',C'  '        #RECFM                     06/84 DBC
         DC    CL5' ',C'  '        #LRECL                     06/84 DBC
         DC    CL5'BLOCK',C'  '    #BLKSIZE                   06/84 DBC
         DC    CL6' BLOCK',C'  '   #BLKCNT                    06/84 DBC
         DC    CL3' ',C'  '        #DEN                       06/84 DBC
         DC    CL3' ',C'  '        #TRTCH                     06/84 DBC
         DC    CL4'LNTH',C'  '     #LENGTH                    06/84 DBC
         DC    CL4'TOTL',C'  '     #CUMLEN                    06/84 DBC
         DC    C'CREATOR'          #CREATOR                   06/84 DBC
         ORG   ,                   RESTORE                    06/84 DBC
         SPACE 3                                              06/84 DBC
COLHEAD2 DC    CL133' '            2ND TITLE LINE             06/84 DBC
         ORG   COLHEAD2+1          RELOCATE BACK              06/84 DBC
         DC    CL8'FORMAT',C' '    #UNLOAD                    06/84 DBC
         DC    CL4'SEQ#',C'  '     #FILE                      06/84 DBC
         DC    CL17'DATASET NAME',C'  ' #DSN                  06/84 DBC
         DC    CL4'REQD',C'  '     #PSWD                      06/84 DBC
         DC    CL6'C-DATE',C'  '   #CDATE                     06/84 DBC
         DC    CL6'E-DATE',C'  '   #EDATE                     06/84 DBC
         DC    CL6'SOURCE',C'  '   #INFOSRC                   06/84 DBC
         DC    CL5'RECFM',C'  '    #RECFM                     06/84 DBC
         DC    CL5'LRECL',C'  '    #LRECL                     06/84 DBC
         DC    CL5' SIZE',C'  '    #BLKSIZE                   06/84 DBC
         DC    CL6' COUNT',C'  '   #BLKCNT                    06/84 DBC
         DC    CL3'DEN',C'  '      #DEN                       06/84 DBC
         DC    CL3'TRT',C'  '      #TRTCH                     06/84 DBC
         DC    CL4'(FT)',C'  '     #LENGTH                    06/84 DBC
         DC    CL4'LNTH',C'  '     #CUMLEN                    06/84 DBC
         DC    C'JOBNAME/STEPNAME' #CREATOR                   06/84 DBC
         ORG   ,                   RESTORE                    06/84 DBC
         SPACE 3                                              06/84 DBC
         PRINT GEN
         SPACE 1
DAYS     DAYS  LEFT
MONTHS   MONTHS
         EJECT
ERR#LIST DC    0F'0'                                                U15
*                                                                   U15
*  ERROR MSGS FOR EACH SENSE BIT FOR 3420 TAPE DRIVES               U15
*                                                                   U15
         SPACE 1
*** BYTE 0                       BIT                                U15
         DC    C'CMD REJ   '      0     80                          U15
         DC    C'INT REQ   '      1     40                          U15
         DC    C'BUS OUT CK'      2     20                          U15
         DC    C'EQC CHK   '      3     10                          U15
         DC    C'DATA CHK  '      4     08                          U15
         DC    C'OVERRUN   '      5     04                          U15
         DC    C'WORD CNT 0'      6     02                          U15
         DC    C'DATA CNVTR'      7     01                          U15
         SPACE 1
*** BYTE 1                       BIT                                U15
         DC    C'NOISE     '      0     80                          U15
         DC    C'SEL+RDY+NB'      1     40                          U15
         DC    C'NOT READY '      2     20                          U15
         DC    C'7 TRK FEAT'      3     10                          U15
         DC    C'@ LOAD PT '      4     08                          U15
         DC    C'WRITE STAT'      5     04                          U15
         DC    C'FILE PROT '      6     02                          U15
         DC    C'NOT CAPABL'      7     01                          U15
         SPACE 1
*** BYTE 2                       BIT                                U15
         DC    C'TIE BIT 0 '      0     80                          U15
         DC    C'TIE BIT 1 '      1     40                          U15
         DC    C'TIE BIT 2 '      2     20                          U15
         DC    C'TIE BIT 3 '      3     10                          U15
         DC    C'TIE BIT 4 '      4     08                          U15
         DC    C'TIE BIT 5 '      5     04                          U15
         DC    C'TIE BIT 6 '      6     02                          U15
         DC    C'TIE BIT 7 '      7     01                          U15
         SPACE 1
*** BYTE 3                       BIT                                U15
         DC    C'R/W VRC   '      0     80                          U15
         DC    C'MT/LRC    '      1     40                          U15
         DC    C'SKEW      '      2     20                          U15
         DC    C'END DC/CRC'      3     10                          U15
         DC    C'ENV/ECC   '      4     08                          U15
         DC    C'1600 BPI  '      5     04                          U15
         DC    C'BACKWARD  '      6     02                          U15
         DC    C'C/P COMPAR'      7     01                          U15
         SPACE 1
*** BYTE 4                       BIT                                U15
         DC    C'MP H E    '      0     80                          U15
         DC    C'DROP READY'      1     40                          U15
         DC    C'TAPE INDIC'      2     20                          U15
         DC    C'W T VRC   '      3     10                          U15
         DC    C'MICROPGM  '      4     08                          U15
         DC    C'LWR       '      5     04                          U15
         DC    C'UNIT CHECK'      6     02                          U15
         DC    C'RSRVD RPQ '      7     01                          U15
         SPACE 1
*** BYTE 5                       BIT                                U15
         DC    C'NEW SUBSYS'      0     80                          U15
         DC    C'NEW SUBSYS'      1     40                          U15
         DC    C'WTM CHECK '      2     20                          U15
         DC    C'ID BURST  '      3     10                          U15
         DC    C'START READ'      4     08                          U15
         DC    C'PART''L REC'     5     04                          U15
         DC    C'POSTAMBLE '      6     02                          U15
         DC    C'RSRVD RPQ '      7     01                          U15
         SPACE 1
*** BYTE 6                       BIT                                U15
         DC    C'7 TRK UNIT'      0     80                          U15
         DC    C'WRT CURR  '      1     40                          U15
         DC    C'DUAL DEN  '      2     20                          U15
         DC    C'NOT 1600  '      3     10                          U15
         DC    C'MOD 4,6,8 '      4     08                          U15
         DC    C'MD 5,6,7,8'      5     04                          U15
         DC    C'MOD 3,4   '      6     02                          U15
         DC    C'MD 3,4,7,8'      7     01                          U15
         SPACE 1
*** BYTE 7                       BIT                                U15
         DC    C'LAMP FAIL '      0     80                          U15
         DC    C'BOTM LEFT '      1     40                          U15
         DC    C'BOTM RIGHT'      2     20                          U15
         DC    C'RESET KEY '      3     10                          U15
         DC    C'DSE       '      4     08                          U15
         DC    C'ERASE HEAD'      5     04                          U15
         DC    C'AIR BEARNG'      6     02                          U15
         DC    C'LOAD FAIL '      7     01                          U15
         SPACE 1
*** BYTE 8                       BIT                                U15
         DC    C'IBG       '      0     80                          U15
         DC    C'SPARE ?   '      1     40                          U15
         DC    C'SPARE ?   '      2     20                          U15
         DC    C'EARLY READ'      3     10                          U15
         DC    C'CTL BURST '      4     08                          U15
         DC    C'SLOW RD B '      5     04                          U15
         DC    C'SLOW RD E '      6     02                          U15
         DC    C'VELOCITY  '      7     01                          U15
         SPACE 1
*** BYTE 9                       BIT                                U15
         DC    C'6250 CORR '      0     80                          U15
         DC    C'WRT VEL CH'      1     40                          U15
         DC    C'CHAN BUFF '      2     20                          U15
         DC    C'CRC III   '      3     10                          U15
         DC    C'6250 FEAT '      4     08                          U15
         DC    C'SPARE ?   '      5     04                          U15
         DC    C'SPARE ?   '      6     02                          U15
         DC    C'TCU RSRVD '      7     01                          U15
         SPACE 2
         END   TAPEMAP
