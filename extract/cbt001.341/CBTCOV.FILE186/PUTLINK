00043860*PROCESS MACRO,INTERRUPT;
00043870 /* PUTLINK:  PROC TO SEND DATA TO AN INTELLIGENT TERMINAL
00043880    FROM A USER SELECTED TSO FILE */
00043890 PUTLINK:  PROC (PARM) OPTIONS (MAIN);
00043900 /* 09/12/77  -  APB */
00043910 /* TPUT CALLS CHANGED TO TPUTH TO ENSURE PROPER TIMING - 03/06/80 - APB */
00043920 %SKIP;
00043930 /* THIS PROC IS TO BE USED AS A LINK TO TRINITY COLLEGE'S PDP-11 */
00043940 /* THE USER INVOKES THIS PROGRAM THROUGH A CLIST WHICH BUILDS THE
00043950    PARM STRING.  THE CLIST IS:  */
00043960 %SKIP;
00043970     /*
00043980     PROC 1 DA USER(&SYSUID.) QUAL(LIST) NUM(5) LOG(LINKLOG.DATA) COPIES(1)
00043990     SET DSN=&USER..&DA..&QUAL
00044000     ALLOC F(INPUT)    DA('&DSN') OLD
00044010     ALLOC F(PLIDUMP)  SYSOUT(A)
00044020     ALLOC F(SYSPRINT) DA(&LOG) MOD
00044030     SET N=0
00044040     DO WHILE &N < &COPIES  &&  &MAXCC=0
00044050         CALL LOADLIB(PUTLINK) '/''&NUM'' ''&DSN'''
00044060         SET N=&N+1
00044070         END
00044080     IF MAXCC=0 THEN WRITE PUTLINK COMPLETED SUCCESSFULLY
00044090     ELSE WRITE ERROR IN PUTLINK, PLEASE REVIEW THE LOG FILE
00044100     ALLOC F(SYSPRINT) DA(*)
00044110     FREE  F(PLIDUMP)
00044120     FREE  DA('&DSN')
00044130     END
00044140     */
00044150 %SKIP;
00044160 /* THE FOLLOWING CLIST IS USED TO CREATE THE LOG DATASET:  */
00044170     /*
00044180     PROC 0 LOGNAME(LINKLOG.DATA)
00044190     <* CREATE LOG DATASET FOR GETLINK/PUTLINK *>
00044200     ATTRIB GETLOG DSORG(PS) RECFM(V B A) LRECL(85) BLKSIZE(4253)
00044210     ALLOC  DA(&LOGNAME) USING(GETLOG) SPACE(5 5) TRACKS
00044220     FREE   ATTR(GETLOG)
00044230     END
00044240     */
00044250 %PAGE;
00044260 /* USER'S GUIDE: */
00044270     /*
00044280                                     PUTLINK
00044290     FUNCTION:
00044300          PUTLINK will get a data file from YCC's IBM-370 and transmit it to
00044310     an intelligent terminal (in this case Trinity's PDP-11).
00044320     
00044330     SYNTAX:
00044340          PUTLINK DA USER() QUAL() NUM() COPIES() LOG()
00044350     Except for the first parameter (DA) which is positional, all parameters
00044360     are keyword type, ie. there is only one required operand.  Operands
00044370     followed by a () are specified by name with a value in the parentheses.
00044380     
00044390     OPERANDS:
00044400          DA      - unqualified dataset name, no default.
00044410          USER    - userid, default is the userid of the current user.
00044420          QUAL    - dataset qualifier, default - LIST.  Note that USER, DA, and
00044430                    QUAL are used to make the dataset name.
00044440          NUM     - block number:  the number of lines sent between
00044450                    acknowledgements, range 1 - 8, default - 5.
00044460          COPIES  - the number of times the dataset is to be sent, default - 1.
00044470          LOG     - the name of the dataset that logs the use of PUTLINK,
00044480                    default - LINKLOG.DATA.  To initialize this dataset, enter:
00044490                    ATTRIB GETLOG DSORG(PS) RECFM(V B A) LRECL(85) BLKSIZE(4253)
00044500                    ALLOC  DA(&LOG) USING(GETLOG) SPACE(5 5) TRACKS
00044510     */
00044520 %PAGE;
00044530 /* INPUTS:  PARM - PARSED BY GET STRING INTO:
00044540    NBLK  -  CHAR (1)            # LINES SENT BETWEEN ACKNOWLEDGEMENTS
00044550    DSN   -  CHAR (44) VAR       NAME OF THE INPUT DATASET
00044560             INPUT - FILE ALLOCATED TO THE INPUT DATASET (DSN) */
00044570 %SKIP;
00044580 /* OUTPUTS:  THE LOG FILE, SYSPRINT, WHICH IS USED TO CONTAIN
00044590    PROGRAM INFORMATION AND ANY DIAGNOSTIC MESSAGES.  THIS FILE IS
00044600    NOT ALLOCATED TO THE TERMINAL SINCE IT WOULD DISRUPT THE LINE
00044610    PROTOCOL.  ANY OF THE THREE SUBROUTINES MAY WRITE TO SYSPRINT.
00044620    THIS FILE SERVES AS A LOG FOR THE USE OF THIS PROGRAM, EVERY TIME
00044630    PUTLINK IS RUN THE NEW SESSION IS MOD-ED ONTO THE LOG DATASET.
00044640              THE TERMINAL LINK, WHICH RECEIVES THE XMITTED DATA. */
00044650 %SKIP;
00044660 /* ALGORITHM:
00044670    1) INITIALIZE LOG FILE.
00044680    2) PARSE PARMS.
00044690    3) CALL INITIALIZATION ROUTINES.
00044700    4) LOOP THROUGH PROCESSING ROUTINES WHILE RETURN CODE SIGNALS THAT
00044710       THERE IS STILL MORE DATA, OR UNTIL AN ASYNCHRONOUS ERROR OCCURS.
00044720    5) CALL FINALIZATION ROUTINES.
00044730    6) SET PROGRAM RETURN CODE.
00044740    7) FINALIZE LOG FILE. */
00044750 %SKIP;
00044760 /* THE PROGRAM HAS THREE BASIC SUBROUTINES:
00044770         FILE    - HANDLES THE TSO INPUT FILE
00044780         PROTCOL - HANDLES THE OUTPUT LINK PROTOCOL
00044790         TRANS   - HANDLES ANY REQUIRED DATA TRANSLATION
00044800    EACH OF THESE ROUTINES HAS AN INITIALIZATION AND FINALIZATION ENTRY.
00044810    SEE THE INDIVIDUAL ROUTINES FOR INPUTS, OUTPUTS AND ALGORITHMS. */
00044820 %PAGE;
00044830 /* GLOBAL VARIABLES: */
00044840 DCL PARM     CHAR(*) VAR;               /* EXECUTION PARAMETERS */
00044850 /* VARIABLES ASSIGNED BY GET STRING FROM PARM */
00044860 DCL NBLK     CHAR(1);                   /* # LINES BETWEEN ACKNOWLEDGMENTS,
00044870                                            (SEE PROTOCOL SECTION) */
00044880 DCL DSN      CHAR(44) VAR;              /* NAME OF THE TSO INPUT DATASET */
00044890 %SKIP;
00044900 DCL BUF      CHAR(899) VAR;             /* BUFFER FOR ONE LINE OF DATA
00044910                                            NOTE - 899 IS PROTOCOL MAX SIZE
00044920                                            (SEE PROTOCOL SECTION) */
00044930 DCL RC       FIXED BIN INIT(0);         /* PROGRAM RETURN CODE */
00044940                                         /* RETURN CODES FROM SUBROUTINES:
00044950                                            0  - MORE DATA TO GO
00044960                                            4  - ALL DATA SENT
00044970                                            8  - ENDED DUE TO USER REQUEST
00044980                                            10 - ENDED DUE TO INVALID ACKNOLEDGEMENT
00044990                                            12 - ENDED DUE TO PERMANENT DATA ERROR */
00045000                                         /* ASYNCHRONOUS RETURN CODE:
00045010                                            16 - ENDED DUE TO ERROR CONDITION
00045020                                            NOTE THAT THIS CONDITION MAY OCCUR
00045030                                            AT ANY TIME DUE TO A DELIBERATE
00045040                                            SIGNAL STATEMENT, OR (HORRORS!)
00045050                                            A PROGRAM BUG. */
00045060 %INCLUDE BITDEF;
00045070 DCL DTYPE    BIT ALIGNED INIT(FALSE);   /* TRUE IF DATA IS PRINTABLE */
00045080 DCL NATTN    BIT ALIGNED INIT(FALSE);   /* TRUE AFTER ONE ATTN HAS BEEN STRUCK */
00045090 %PAGE;
00045100 DCL DATE     BUILTIN;
00045110 DCL DIM      BUILTIN;
00045120 DCL INDEX    BUILTIN;
00045130 DCL LENGTH   BUILTIN;
00045140 DCL ONCODE   BUILTIN;
00045150 DCL PLIRETC  BUILTIN;
00045160 DCL PLIRETV  BUILTIN;
00045170 DCL SUBSTR   BUILTIN;
00045180 DCL TIME     BUILTIN;
00045190 DCL VERIFY   BUILTIN;
00045200 %SKIP;
00045210 %INCLUDE SYSIO;
00045220 %INCLUDE DATEC;
00045230 %INCLUDE TIMEC;
00045240 %SKIP;
00045250 ON ERROR BEGIN;
00045260     ON ERROR SYSTEM;    /* WE DO NOT WANT TO RECURSE WITHIN THIS ON-UNIT */
00045270     IF (ONCODE ^= 9 /* SIGNAL ERROR */) THEN PUT FILE (SYSPRINT) SKIP EDIT
00045280         ('PUTLINK ABORTING DUE TO PL/I ERROR CONDITION # ',ONCODE) (COL(5),A,F(5));
00045290     RC=16;      /* SET ASYNCHRONOUS ERROR RETURN CODE */
00045300     GO TO FIN;
00045310     END;
00045320 %SKIP;
00045330 ON ATTN BEGIN;
00045340     /* TWO ATTENTION INTERRUPTS WILL KILL PUTLINK */
00045350     IF (NATTN) THEN DO;
00045360         PUT FILE (SYSPRINT) SKIP EDIT
00045370             ('PUTLINK ABORTING DUE TO ATTENTION INTERRUPTS') (COL(5),A);
00045380         SIGNAL ERROR;
00045390         END;
00045400     NATTN=TRUE;
00045410     END;
00045420 %SKIP;
00045430 ON UNDEFINEDFILE (SYSPRINT) SIGNAL ERROR;
00045440 %PAGE;
00045450 /* EXECUTIVE ROUTINE */
00045460 OPEN FILE (SYSPRINT) LINESIZE (80);     /* 80 TO BE EASILY READ ON A CRT */
00045470 PUT FILE (SYSPRINT) PAGE EDIT
00045480     (DATEC,'PUTLINK TO TRINITY COLLEGE',TIMEC) (COL(10),A,COL(27),A,COL(62),A);
00045490 PUT FILE (SYSPRINT) SKIP(2) EDIT
00045500     ('INPUT PARM:  ',PARM) (A,A);
00045510 GET STRING (PARM) LIST (NBLK, DSN);     /* GET PARMS */
00045520 %SKIP;
00045530 CALL FILEINI;
00045540 CALL PROTINI;
00045550 CALL TRANINI;
00045560 DO WHILE (RC = 0);
00045570     CALL TRANS;
00045580     CALL FILE;
00045590     CALL PROTCOL;
00045600     END;
00045610 FIN:
00045620 ON ERROR SYSTEM;    /* WE DO NOT WANT TO LOOP BETWEEN HERE AND ON-UNIT */
00045630 CALL TRANFIN;
00045640 CALL PROTFIN;
00045650 CALL FILEFIN;
00045660 %SKIP;
00045670 SELECT (RC);
00045680 /* NOTE - PLIRETC IS USED BY THE INVOKING CLIST TO DETERMINE PROPER ACTION */
00045690     WHEN (4) DO;    /* NORMAL END */
00045700         PUT FILE (SYSPRINT) SKIP(2) EDIT
00045710             ('PUTLINK COMPLETED SUCCESSFULLY') (COL(25),A);
00045720         CALL PLIRETC(0);
00045730         END;
00045740     WHEN (8) DO;
00045750         PUT FILE (SYSPRINT) SKIP(2) EDIT
00045760             ('PUTLINK ABORTING DUE TO USER REQUEST') (COL(5),A);
00045770         CALL PLIRETC(8);
00045780         END;
00045790     WHEN (10) DO;
00045800         PUT FILE (SYSPRINT) SKIP(2) EDIT
00045810             ('PUTLINK ABORTING DUE TO INVALID ACKNOWLEDGEMENTS') (COL(5),A);
00045820         CALL PLIRETC(12);
00045830         END;
00045840     WHEN (12) DO;
00045850         PUT FILE (SYSPRINT) SKIP(2) EDIT
00045860             ('PUTLINK ABORTING DUE TO PERMANENT DATA ERROR') (COL(5),A);
00045870         CALL PLIRETC(12);
00045880         END;
00045890     OTHERWISE CALL PLIRETC(16);     /* MESSAGE HAS ALREADY BEEN WRITTEN */
00045900     END;
00045910 %SKIP;
00045920 CLOSE FILE (SYSPRINT);
00045930 /* END OF EXECUTION */
00045940 %PAGE;
00045950 FILE:  PROC;        /* ROUTINE TO GET A BUFFER FROM THE INPUT FILE */
00045960 DCL INPUT    EXT FILE RECORD INPUT;     /* THE DATASET FILE */
00045970 DCL 1 FILSTAT CTL,                      /* STATUS VARIABLES FOR FILE */
00045980         2 NREC     FIXED BIN INIT(0);   /* # OF DATA LINES IN DATASET */
00045990 %SKIP;
00046000 ON ENDFILE (INPUT) RC=4;
00046010 ON RECORD  (INPUT);     /* SINCE BUF IS A VARYING STRING THERE ARE NO
00046020     PROBLEMS WITH SHORT LINES.  LONG LINES WILL BE PICKED UP BY PROTOCOL
00046030     WHEN IT HAS TO TRUNCATE THE LAST FOUR CHARACTERS TO INSERT THE CONTROL
00046040     FIELD. */
00046050 %SKIP;
00046060 READ FILE (INPUT) INTO (BUF);
00046070 IF (RC = 0) THEN NREC=NREC+1;
00046080 RETURN;
00046090 %SKIP(3);
00046100 FILEINI:  ENTRY;    /* INITIALIZE FILE STATUS VARIABLES AND OPEN FILE */
00046110 %SKIP;
00046120 ON UNDEFINEDFILE (INPUT) BEGIN;
00046130     PUT FILE (SYSPRINT) SKIP EDIT
00046140         ('PUTLINK ABORTING - ',DSN,' WAS NOT ALLOCATED') (COL(5),A,A,A);
00046150     SIGNAL ERROR;
00046160     END;
00046170 %SKIP;
00046180 ALLOCATE FILSTAT;
00046190 OPEN FILE (INPUT);
00046200 RETURN;
00046210 %SKIP(3);
00046220 FILEFIN:  ENTRY;    /* CLOSE FILE */
00046230 CLOSE FILE (INPUT);
00046240 PUT FILE (SYSPRINT) SKIP EDIT
00046250     (NREC,' DATA LINE(S) READ FROM ',DSN) (F(7),A,A);
00046260 FREE FILSTAT;
00046270 RETURN;
00046280 %SKIP;
00046290 END FILE;
00046300 %PAGE;
00046310 PROTCOL:  PROC;     /* PROTOCOL FOR 11/370 LINK */
00046320 /* THIS ROUTINE HANDLES THE LINE PROTOCOL.  INFORMATION IS SENT BI-DIRECTIONALLY
00046330    IN ONE OF TWO FORMATS:  (NOTE - THE TRANSMITTING END USES BOTH FORMATS)
00046340    1) DATA FORMAT:
00046350       BLLLDDDD...DDDD
00046360       B - 1 BYTE BLOCK SEQUENCE NUMBER
00046370       L - 3 BYTE LENGTH CODE
00046380       D - DATA (LENGTH L-4)
00046390    2) CONTROL FORMAT:
00046400       B9CM
00046410       B - 1 BYTE BLOCK SEQUENCE NUMBER
00046420       9 - 1 BYTE, THE CHAR '9', WHICH SPECIFIES CONTROL
00046430       C - 1 BYTE CONTROL CODE
00046440       M - 1 BYTE CONTROL CODE MODIFIER
00046450    IN EITHER CASE THE FIRST FOUR BYTES MUST BE NUMERIC CHARACTERS. */
00046460 %SKIP;
00046470 /* EVERY LINE HAS A BLOCK SEQUENCE NUMBER RANGING FROM 1 TO 9 INCLUSIVE.
00046480    THESE ARE USED TO IDENTIFY ONE LINE FROM A BLOCK OF LINES.  THE
00046490    NUMBERS RUN IN ASCENDING WRAPAROUND SEQUENCE.  BOTH THE XMITTING AND
00046500    THE RECEIVING ENDS OF THE LINK HAVE SEPARATE BLOCK SEQUENCES.
00046510    THE XMITTING END (THE IBM/370 (US)) SENDS A BLOCK OF LINES AND THEN WAITS
00046520    FOR AN ACKNOWLEDGEMENT FROM THE RECEIVING END (THE TERMINAL (THEM)).  THERE
00046530    ARE NBLK (SPECIFIED IN THE CLIST) LINES SENT BETWEEN ACKNOWLEDGEMENTS.
00046540    THE ACKNOWLEDGEMENT CONSISTS OF THE ACKNOWLEDGEMENT CODE FOLLOWED BY
00046550    THE BLOCK SEQUENCE NUMBER OF THE LAST LINE CORRECTLY RECEIVED.  THIS
00046560    WAY THE XMITTING PROGRAM KNOWS WHICH LINE TO SEND NEXT (IE. IT CAN
00046570    RESEND ALL LINES FROM THE LAST LINE ACKNOWLEDGED IF THE SEQUENCE NUMBERS
00046580    DISAGREE.  OF COURSE, IF THE SEQUENCE NUMBERS DO AGREE, WE STILL SEND A
00046590    LINE FROM THE LAST LINE ACKNOWLEDGED (UNLESS RC = 4). */
00046600 %SKIP;
00046610 /* INPUTS:  BUF - DATA STRING GOTTEN FROM THE TSO DATASET */
00046620 /* OUTPUTS: RC  - RETURN CODE
00046630                 = 0  - THERE IS MORE DATA TO GO
00046640                 = 4  - ALL DATA HAS BEEN SENT
00046650                 = 8  - LINK IS ENDING DUE TO USER ERROR CODE
00046660                 = 10 - LINK IS ENDING DUE TO INVALID ACKNOWLEDGEMENTS
00046670                 = 12 - LINK IS ENDING DUE TO PERMANENT DATA ERROR
00046680             TERMINAL LINK - RECEIVES THE TRANSMITTED DATA */
00046690 %PAGE;
00046700 /* ALGORITHM:
00046710    1)  WE SEND THE READY TO TRANSMIT CODE WITH NBLK AS THE CODE MODIFIER.
00046720    2)  THEY SEND THE READY TO RECEIVE CODE WITH NBLK AS THE CODE MODIFIER.
00046730    3)  WE SEND NBLK DATA LINES AND WAIT FOR AN ACKNOWLEDGEMENT.
00046740    4)  IF THE FORMAT OF THE ACKNOWLEDGEMENT IS INCORRECT THEN WE
00046750    REQUEST A RESEND OF THE ACKNOWLEDGEMENT, WITH THE SEQUENCE NUMBER OF THE
00046760    LAST ACKNOWLEDGEMENT RECEIVED CORRECTLY AS THE MODIFIER.  IF THE FORMAT IS
00046770    STILL INCORRECT THEN THE ACKNOWLEDGEMENT IS CONSIDERED INVALID.  IF THE
00046780    ACKNOWLEDGEMENT SPECIFIES THAT LINES HAVE BEEN LOST, WE RESEND THEM.
00046790    IF THE SAME LINES ARE TRIED TO BE RESENT MORE THAN MAXRETRY TIMES THEN
00046800    IT IS CONSIDERED A PERMANENT DATA ERROR.
00046810    5)  (3 & 4) ARE REPEATED UNTIL FILE SIGNALS (RC = 4) THAT ALL OF THE DATA
00046820    LINES HAVE BEEN GOTTEN FROM THE DATASET.  WE THEN SEND THE
00046830    END CODE AND WAIT FOR AN ACKNOWLEDGEMENT (WITH THE SAME ACTION AS (4)).
00046840    6)  WHEN THE CORRECT ACKNOWLEDGEMENT IS RECEIVED DIRECTLY AFTER OUR
00046850    SENDING AN END CODE, WE SEND A SECOND END CODE TO CLOSE THE LINK. */
00046860 %SKIP;
00046870 /* NOTE 1 - AT ANY TIME EITHER END MAY SEND THE ERROR CODE TO TERMINATE
00046880    THE LINK.
00046890    NOTE 2 - THE XMITTING PROGRAM HAS A TIMER RUNNING WHILE WAITING FOR
00046900    AN ACKNOWLEDGEMENT SO THAT AFTER A CERTAIN PERIOD OF TIME IT WILL
00046910    REQUEST A 'RESEND' OF THE ACKNOWLEDGEMENT.
00046920    NOTE 3 - SINCE A '9' IN BYTE TWO OF A LINE SPECIFIES CONTROL, 899 IS
00046930    THE MAXIMUM LINESIZE.  SINCE EACH LINE IS PREFIXED BY THE 4 BYTE CONTROL
00046940    SEQUENCE, THE MAXIMUM DATA LENGTH IS 895 BYTES.
00046950    NOTE 4 - IF THE FIRST LINE THEY RECEIVE IS BAD THEN THEY WILL
00046960    ACKNOWLEDGE '0' AS THE LAST LINE RECEIVED. */
00046970 %PAGE;
00046980 DCL 1 PROSTAT  CTL,                     /* STATUS VARIABLES FOR PROTCOL */
00046990         2 TOTAL    FIXED BIN INIT(0),   /* TOTAL # DATA LINES SENT */
00047000         2 COUNT    FIXED BIN INIT(0),   /* # LINES IN CURRENT BLOCK */
00047010         2 ERRCNT   FIXED BIN INIT(0),   /* # LINES ORIGINALLY IN ERROR */
00047020         2 RETRY    FIXED BIN INIT(0),   /* # RETRIES FOR CURRENT BLOCK */
00047030         2 SBLK     CHAR (1) INIT('1'),  /* # OF LINE BEING SENT */
00047040         2 RBLK     CHAR (1) INIT('9'),  /* # OF LINE RECEIVED */
00047050                                         /* 1ST RBLK WE GET SHOULD BE '1' */
00047060         2 ABLK     CHAR (1),            /* # OF LINE ACKNOWLEDGED */
00047070         2 BLEN     PIC '999',           /* LENGTH OF ENTIRE LINE */
00047080         2 ENDSET   BIT ALIGNED INIT(FALSE), /* TRUE AFTER ALL LINES ACKNOWLEDGED */
00047090         2 FIRST    BIT ALIGNED INIT(FALSE), /* TRUE AFTER THEY HAVE SENT
00047100                                                READY TO RECEIVE */
00047110         2 FIRSTL   BIT ALIGNED INIT(FALSE), /* TRUE AFTER THEY HAVE ACKNOWLEDGED
00047120                                                AT LEAST ONE LINE */
00047130         2 INIT     BIT ALIGNED INIT(FALSE), /* TRUE AFTER INITIALIZATION
00047140                                                CODE HAS BEEN PERFORMED */
00047150         2 BUFARR(9) CHAR(899) VAR;          /* CIRCULAR BUFFER STORAGE
00047160                                                FOR RESENDING LOST LINES */
00047170 %SKIP;
00047180 /* CONSTANTS */
00047190 %DCL CNTLEN   CHAR;                     /* LENGTH OF THE CONTROL FIELD
00047200                                            (ALSO THE MINIMUM LINE LENGTH) */
00047210 %CNTLEN='4';
00047220 %DCL MAXLEN  CHAR;                      /* MAX DATA LINE LENGTH */
00047230 %MAXLEN='895';
00047240 %DCL MAXRETRY CHAR;                     /* MAXIMUM # RETRIES/LINE */
00047250 %MAXRETRY='10';
00047260 %DCL NUMRALS  CHAR;                     /* NUMERIC CHARACTERS */
00047270 %NUMRALS='''0123456789''';
00047280 %DCL NUM9     CHAR;                     /* NUMERIC CHARACTERS 1-9 */
00047290 %NUM9='''123456789''';
00047300 %DCL BLANK    CHAR;                     /* BLANK CHARACTER */
00047310 %BLANK=''' ''';
00047320 /* CONTROL NUMBERS */
00047330 %DCL CNTL     CHAR;                     /* SPECIFIES CONTROL */
00047340 %CNTL='''9''';
00047350 %DCL ENDC     CHAR;                     /* END OF LINK CODE */
00047360 %ENDC='''9''';
00047370 %DCL ACK      CHAR;                     /* ACKNOWLEDGEMENT CODE */
00047380 %ACK='''8''';
00047390 %DCL REACK    CHAR;                     /* REACKNOWLEDGE CODE */
00047400 %REACK='''7''';
00047410 %DCL ERR      CHAR;                     /* ERROR CODE */
00047420 %ERR='''5''';
00047430 %DCL XMT      CHAR;                     /* XMISSION SIDE MODIFIER */
00047440 %XMT='''2''';
00047450 %DCL REC      CHAR;                     /* RECEIVE SIDE MODIFIER */
00047460 %REC='''1''';
00047470 %DCL NUL      CHAR;                     /* NULL CODE */
00047480 %NUL='''0''';
00047490 %PAGE;
00047500 %INCLUDE TERMIO;
00047510 %INCLUDE WAIT;
00047520 %INCLUDE STRIP;
00047530 %SKIP(2);
00047540 SELECT (RC);
00047550     WHEN (0)                /* BUF CONTAINS A GOOD DATA LINE */
00047560         SEND:  DO;
00047570             /* PROCESS ACKNOWLEDGEMENT */
00047580             DO WHILE (COUNT >= INDEX(NUM9,NBLK));
00047590                 CALL GETACK;
00047600                 IF (RC > 0) THEN LEAVE SEND;    /* INVALID ACKNOWLEDGEMENT */
00047610                 IF (ABLK ^= SBLK) THEN DO;      /* LINES WERE LOST */
00047620                     CALL RESEND;
00047630                     IF (RC > 0) THEN LEAVE SEND;/* PERMANENT DATA ERROR */
00047640                     END;
00047650                 END;
00047660             RETRY=0;
00047670             /* SEND CURRENT LINE */
00047680             CALL STRIP(BUF,BLANK);              /* STRIP BLANKS OFF END */
00047690             IF (LENGTH(BUF) > MAXLEN) THEN DO;  /* WE WILL HAVE TO TRUNCATE */
00047700                 PUT FILE (SYSPRINT) SKIP EDIT
00047710                     ('WARNING - LINE # ',TOTAL+1,' TRUNCATED') (A,F(7),A);
00047720                 BUF=SUBSTR(BUF,MAXLEN);
00047730                 END;
00047740             BLEN=LENGTH(BUF)+4;
00047750             SBLK=GETNXT(SBLK);
00047760             BUFARR(INDEX(NUM9,SBLK))=SBLK||BLEN||BUF;
00047770             CALL TPUTH(BUFARR(INDEX(NUM9,SBLK)));
00047780             COUNT=COUNT+1;
00047790             TOTAL=TOTAL+1;
00047800             END;
00047810 %SKIP;
00047820     WHEN (4) DO;            /* ALL DATA LINES HAVE BEEN SENT */
00047830         CALL ENDOUT(XMT);
00047840         PEND:  DO UNTIL (ENDSET);
00047850             CALL GETACK;
00047860             IF (RC > 4) THEN LEAVE PEND;    /* INVALID ACKNOWLEDGEMENT */
00047870             IF (ABLK ^= SBLK) THEN DO;      /* LINES WERE LOST */
00047880                 CALL RESEND;
00047890                 IF (RC > 4) THEN LEAVE PEND;/* PERMANENT DATA ERROR */
00047900                 END;
00047910             ELSE ENDSET=TRUE;
00047920             END;
00047930         END;
00047940 %SKIP;
00047950     OTHERWISE;              /* LET RC FALL THROUGH TO EXECUTIVE ROUTINE */
00047960     END;
00047970 %SKIP;
00047980 RETURN;
00047990 %PAGE;
00048000 PROTINI:  ENTRY;    /* OPEN LINK */
00048010 IF ((VERIFY(NBLK,NUM9) ^= 0) |      /* NON-NUMERIC CHARACTER (OR 0) */
00048020     (NBLK = SUBSTR(NUM9,LENGTH(NUM9),1)))
00048030     /* NBLK MUST BE ONE LESS THAN THE NUMBER OF BLOCK SEQUENCE NUMBERS
00048040        AVAILABLE, OTHERWISE WE WOULD NOT BE ABLE TO DIFFERENTIATE BETWEEN
00048050        AN ACKNOWLEDGEMENT SPECIFYING THAT ALL LINES WERE RECEIVED AND
00048060        AN ACKNOWLEDGEMENT SPECIFYING THAT NO LINES WERE RECEIVED. */
00048070     THEN DO;
00048080         PUT FILE (SYSPRINT) SKIP EDIT
00048090             ('PUTLINK ABORTING DUE TO INVALID BLOCK NUMBER') (COL(5),A);
00048100         SIGNAL ERROR;
00048110         END;
00048120 ALLOCATE PROSTAT;
00048130 CALL TPUTH(SBLK||CNTL||XMT||NBLK);  /* INITIALIZE */
00048140 CALL GETACK;
00048150 INIT=TRUE;
00048160 RETURN;
00048170 %SKIP(3);
00048180 PROTFIN:  ENTRY;    /* CLOSE LINK */
00048190 IF (INIT) THEN DO;  /* CLOSE LINK ONLY IF ALREADY OPEN */
00048200     IF (RC > 12) THEN CALL ERROUT(NUL);     /* ASYNCHRONOUS ERROR */
00048210     CALL ENDOUT(NUL);
00048220     PUT FILE (SYSPRINT) SKIP EDIT
00048230         (ERRCNT,' DATA LINE(S) REQUIRED RETRANSMISSION') (F(7),A);
00048240     PUT FILE (SYSPRINT) SKIP EDIT
00048250         (TOTAL,' DATA LINE(S) SENT') (F(7),A);
00048260     END;
00048270 FREE PROSTAT;
00048280 RETURN;
00048290 %SKIP(3);
00048300 ERROUT:  PROC (TYPE);   /* SEND ERROR MESSAGE */
00048310     DCL TYPE     CHAR (1);
00048320     SBLK=GETNXT(SBLK);
00048330     CALL TPUTH(SBLK||CNTL||ERR||TYPE);
00048340     END ERROUT;
00048350 %SKIP(3);
00048360 ENDOUT:  PROC (TYPE);   /* SEND END CODE */
00048370     DCL TYPE     CHAR (1);
00048380     SBLK=GETNXT(SBLK);
00048390     BUFARR(INDEX(NUM9,SBLK))=SBLK||CNTL||ENDC||TYPE;
00048400     CALL TPUTH(BUFARR(INDEX(NUM9,SBLK)));
00048410     END ENDOUT;
00048420 %PAGE;
00048430 GETACK:  PROC;      /* GET AND PROCESS ACKNOWLEDGMENT */
00048440     DCL GOTCMD   BIT ALIGNED INIT(FALSE);   /* TRUE IF ACKNL IS OK */
00048450     DCL ACKBAD   BIT ALIGNED INIT(FALSE);   /* TRUE IF ACKNL FORMAT IS BAD */
00048460     DCL CMDBUF   CHAR(899) VAR;             /* BUFFER FOR ACKNOWLEDGEMENT */
00048470 %SKIP;
00048480 %BADACK:  PROC RETURNS (CHAR);      /* MACRO PROC TO INCLUDE THE FOLLOWING CODE */
00048490     RETURN('
00048500     DO;     /* HANDLE INCORRECT ACKNOWLEDGEMENT FORMATS */
00048510         IF (ACKBAD) THEN DO;
00048520             /* WE HAVE ALREADY RETRIED THIS ACKNOWLEDGEMENT */
00048530             CALL ERROUT(XMT);
00048540             RC=10;
00048550             END;
00048560         ELSE DO;
00048570             ACKBAD=TRUE;    /* THIS IS THE 1ST RETRY */
00048580             /* NOTE THAT OUR BLOCK SEQUENCE NUMBER IS NULL
00048590                (TO PRESERVE THE ORDERING OF BUFARR) */
00048600             IF (FIRST) THEN CALL TPUTH(NUL||CNTL||REACK||RBLK);
00048610             ELSE CALL TPUTH(NUL||CNTL||REACK||NUL); /* HAVE NOT RECEIVED 1ST ACKNL YET */
00048620             END;
00048630         END;
00048640     ');
00048650     %END BADACK;
00048660 %ACTIVATE BADACK;
00048670 %SKIP(2);
00048680     COUNT=0;
00048690     DO UNTIL (GOTCMD | RC > 4);
00048700         CALL TWTGET(CMDBUF);                /* GET THE ACKNOWLEDGEMENT */
00048710         SELECT;
00048720             WHEN (PLIRETV ^= 0)
00048730                 BADACK                      /* NO ACKNOWLEDGEMENT */
00048740             WHEN (LENGTH(CMDBUF) < CNTLEN)
00048750                 BADACK                      /* SHORT LINE */
00048760             WHEN (VERIFY(SUBSTR(CMDBUF,1,CNTLEN),NUMRALS) ^= 0)
00048770                 BADACK                      /* NON-NUMERIC CONTROL FIELD */
00048780             WHEN (SUBSTR(CMDBUF,1,1) ^= GETNXT(RBLK))
00048790                 BADACK                      /* OUT OF SEQUENCE */
00048800             WHEN (SUBSTR(CMDBUF,2,1) ^= CNTL)
00048810                 BADACK                      /* NON-CONTROL DATA */
00048820 %PAGE;
00048830             OTHERWISE DO;                   /* 1ST TWO BYTES ARE OK */
00048840                 SELECT (SUBSTR(CMDBUF,3,1));
00048850                     WHEN (ACK) DO;          /* ACKNOWLEDGEMENT */
00048860                         ABLK=SUBSTR(CMDBUF,4,1);
00048870                         IF (ABLK = NUL)     /* THEY HAVE NOT RECEIVED 1ST LINE? */
00048880                             THEN IF (FIRSTL)
00048890                                 THEN BADACK /* THEY HAVE RECEIVED THE 1ST LINE */
00048900                             ELSE ABLK='2';  /* 1ST LINE WAS NOT RECEIVED */
00048910                                             /* 1ST LINE IS IN BUFARR(2) */
00048920                         ELSE IF (^FIRSTL)   /* THEY HAVE NOW RECEIVED THE 1ST LINE */
00048930                             THEN FIRSTL=TRUE;
00048940                         IF (DIFF9(ABLK,SBLK) > NBLK)
00048950                             THEN BADACK     /* INCORRECT ABLK */
00048960                         ELSE DO;            /* OK */
00048970                             ACKBAD=FALSE;
00048980                             GOTCMD=TRUE;
00048990                             END;
00049000                         END;
00049010                     WHEN (ERR) DO;          /* USER ERROR CODE */
00049020                         /* NOTE - A MODIFIER CODE COULD BE SETUP SO THAT
00049030                            AN ERROR MESSAGE SENT BY THEM (WHICH WOULD BE
00049040                            SUBSTR(CMDBUF,5)) COULD BE PUT INTO THE LOG FILE. */
00049050                         CALL ERROUT(REC);
00049060                         RC=8;
00049070                         END;
00049080                     WHEN (REC) DO;          /* RECEIVE INITIALIZE */
00049090                         IF (FIRST)
00049100                             THEN BADACK     /* ALREADY GOT READY TO RECEIVE */
00049110                         ELSE DO;
00049120                             FIRST=TRUE;
00049130                             IF (SUBSTR(CMDBUF,4,1) ^= NBLK)
00049140                                 THEN BADACK /* INCORRECT MODIFIER */
00049150                             ELSE DO;        /* OK */
00049160                                 ACKBAD=FALSE;
00049170                                 GOTCMD=TRUE;
00049180                                 END;
00049190                             END;
00049200                         END;
00049210                     OTHERWISE BADACK        /* INVALID CONTROL CODE */
00049220                     END;
00049230                 IF (^ACKBAD) THEN           /* UPDATE RBLK ON GOOD ACKNL */
00049240                     RBLK=SUBSTR(CMDBUF,1,1);
00049250                 END;
00049260             END;
00049270         END;
00049280 %SKIP;
00049290 %DEACTIVATE BADACK;
00049300     END GETACK;
00049310 %PAGE;
00049320 RESEND:  PROC;      /* PROC TO RESEND LOST DATA LINES */
00049330     IF (RETRY = 0) THEN ERRCNT=ERRCNT+1;    /* THIS LINE IS IN ERROR
00049340         (UNTIL RETRY IS RESET ALL OTHER LINES PROCESSED HERE ARE
00049350          SECONDARY RETRIES) */
00049360     RETRY=RETRY+1;
00049370     IF (RETRY > MAXRETRY) THEN DO;  /* PERMANENT DATA ERROR */
00049380         CALL ERROUT(XMT);
00049390         RC=12;
00049400         END;
00049410     ELSE DO UNTIL (ABLK = SBLK);    /* RESEND LINES */
00049420         ABLK=GETNXT(ABLK);
00049430         CALL TPUTH(BUFARR(INDEX(NUM9,ABLK)));
00049440         COUNT=COUNT+1;
00049450         END;
00049460     END RESEND;
00049470 %SKIP(3);
00049480 TWTGET:  PROC (STR);        /* PROC TO GET TERMINAL INPUT WITHIN A TIME LIMIT */
00049490     /* WE DO NOT WANT TO WAIT ANY LONGER THAN NECESSARY, YET WE DO WANT
00049500        TO GIVE THE OTHER END EVERY CHANCE TO RESPOND.  THUS THE FIRST
00049510        WAITS ARE SHORT, WHILE THE FOLLOWING WAITS GET LONGER. */
00049520     DCL STR      CHAR(*) VAR;
00049530     DCL RETC     FIXED BIN INIT(4); /* RETURN CODE FROM TGETW */
00049540     DCL RET2     FIXED BIN (31,0);  /* FULLWORD FOR PLIRETC */
00049550     DCL I        FIXED BIN;
00049560     DCL TWAIT(5) FIXED BIN INIT(    /* TIME TO WAIT IN 1/100 SECONDS */
00049570                  1,10,100,500,1000);
00049580     DO I = 1 TO 5 UNTIL (RETC=0);
00049590         CALL WAITH(TWAIT(I));
00049600         IF (PLIRETV = 8) THEN SIGNAL ATTN;
00049610         CALL TGETW(STR,RETC);
00049620         END;
00049630     RET2=RETC;
00049640     CALL PLIRETC(RET2);             /* SET RETURN CODE */
00049650     END TWTGET;
00049660 %PAGE;
00049670 GETNXT:  PROC (PREV) RETURNS (CHAR (1));
00049680     /* GET THE NEXT NUMBER IN THE ASCENDING WRAPAROUND SEQUENCE 1 - 9 */
00049690     DCL PREV     CHAR (*);              /* PREVIOUS SEQUENCE NUMBER */
00049700     DCL NXT      CHAR (1);              /* NEXT SEQUENCE NUMBER */
00049710     DCL I        FIXED BIN;
00049720     I=INDEX(NUM9,PREV);
00049730     IF (I = 0) THEN DO;     /* ERROR IN SEQUENCE NUMBER */
00049740         CALL ERROUT(XMT);
00049750         PUT FILE (SYSPRINT) SKIP EDIT
00049760             ('PUTLINK ABORTING DUE TO ERROR IN SEQUENCE NUMBERS') (COL(5),A);
00049770         SIGNAL ERROR;
00049780         END;
00049790     IF (I = 9) THEN I=1;
00049800     ELSE I=I+1;
00049810     NXT=SUBSTR(NUM9,I,1);
00049820     RETURN (NXT);
00049830     END GETNXT;
00049840 %SKIP(3);
00049850 DIFF9:  PROC (P1,P2) RETURNS (CHAR(1));
00049860     /* PROC TO FIND THE DISTANCE BETWEEN TWO BLOCK SEQUENCE NUMBERS */
00049870     DCL P1       CHAR(*);       /* FROM */
00049880     DCL P2       CHAR(*);       /* TO */
00049890     DCL DIST     CHAR(1);       /* DISTANCE */
00049900     DCL (N1, N2, ND) FIXED BIN; /* NUMERIC VALUES OF P1, P2 AND DIST */
00049910     N1=INDEX(NUM9,P1);
00049920     N2=INDEX(NUM9,P2);
00049930     IF (N1 = 0  |  N2 = 0) THEN DO;
00049940         CALL ERROUT(XMT);
00049950         PUT FILE (SYSPRINT) SKIP EDIT
00049960             ('PUTLINK ABORTING DUE TO ERROR IN SEQUENCE NUMBERS') (COL(5),A);
00049970         SIGNAL ERROR;
00049980         END;
00049990     IF (N2 < N1) THEN N2=N2+9;
00050000     ND=N2-N1;
00050010     IF (ND > 9  |  ND < 0) THEN DO;
00050020         CALL ERROUT(XMT);
00050030         PUT FILE (SYSPRINT) SKIP EDIT
00050040             ('PUTLINK ABORTING DUE TO ERROR IN SEQUENCE NUMBERS') (COL(5),A);
00050050         SIGNAL ERROR;
00050060         END;
00050070     DIST=SUBSTR(NUMRALS,ND+1,1);
00050080     RETURN (DIST);
00050090     END DIFF9;
00050100 %SKIP;
00050110 END PROTCOL;
00050120 %PAGE;
00050130 TRANS:  PROC;       /* TRANSLATE DATA */
00050140 RETURN;             /* CURRENTLY A NULL ROUTINE */
00050150                     /* NOTE THAT TRANINI IS USED TO SET DTYPE */
00050160 /* ONE POSSIBLE USE WOULD BE TO DECODE BINARY DATA THAT WAS
00050170    ENCODED INTO PRINTABLE CHARACTERS TO BE SENT OVER TCAM */
00050180 %SKIP;
00050190 TRANINI:  ENTRY;
00050200 DTYPE=TRUE;
00050210 RETURN;
00050220 %SKIP;
00050230 TRANFIN:  ENTRY;
00050240 RETURN;
00050250 %SKIP;
00050260 END TRANS;
00050270 %PAGE;
00050280 END PUTLINK;
