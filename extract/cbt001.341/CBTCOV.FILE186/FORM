00007510/*                            FORM                                      */
00007520/*                                                                       *
00007530**************************************************************************
00007540*                                                                        *
00007550*                     DESCRIPTION                                        *
00007560*                                                                        *
00007570*FORM IS A PL/I SUBROUTINE WHICH WHEN CALLED ACTIVATES A DATA ENTRY      *
00007580*SYSTEM. FORM PERMITS THE DIRECT ENTRY OF DATA INTO THE SYSTEM THUR      *
00007590*A 'FORM' WHICH IS DISPLAYED ON THE VIDEO DEVICE DESIGNATED BY THE       *
00007600*PARAMETER 'TERMCODE'. FORM UNPACKES THE INPUT RECORD, 'CONT', AND       *
00007610*DISPLAYS IT TOGETHER WITH ASSOCIATED LABELS DESCRIBING SUBFIELDS OF     *
00007620*THE INPUT REOCRD ON THE CURRENT VIDEO DEVICE. LABEL FIELDS AND THE      *
00007630*CONTENTS OF THE LABEL FIELDS ARE DIFFERENCIATED BY COLOR HIGHLIGHTING.  *
00007640*EDITING THE CONTENTS OF THE 'FORM' AND BLK XFERING THE 'FORM' RETURNS   *
00007650*AN UPDATED RECORD TO THE CALLING TASK, AND A RETURN CODE. THE USER/OPER *
00007660*IS PROMPTED FOR TRANSMISSION ERRORS, OR ILL-DEFINED PARAMETERS. FORM    *
00007670*HAS A RECOVERY PROCEEDURE ALLOWING THE USER/OPER TO RETRY OR RECOVER    *
00007680*FROM TRANSMITION ERRORS OR RETURN TO THE CALLING TASK.                  *
00007690*                                                                        *
00007700*                                                                        *
00007710*                                                                        *
00007720*                                                                        *
00007730*                    PARAMETERS OF CALL                                  *
00007740*                                                                        *
00007750*                                                                        *
00007760*FORMMAP: ARRAY OF STRUCTURES, EACH ELEMENT OF WHICH CORRESPONDS TO
00007770*    A DESIRED LABEL-CONTENT COMBINATION IN THE FORM
00007780*        LBL  : VARYING LENGTH TITLE FIELD
00007790*        LBLWHER: WHERE ON THE LINE THE LABEL SHOULD GO(0 FOR NEXT POS)
00007800*        WHERE: OFFSET IN "INPUT" (1-INDEXED) OF THE CONTENT FIELD
00007810*        LEN  : LENGTH OF THE CONTENT FIELD
00007820*INPUT: INPUT RECORD, A VARYING LENGTH STRING
00007830*FORMOPTS: A STRUCTURE GIVING OPTIONS CONCERNING FORM DISPLAY
00007840*       FORMAT  : BIT IF TRUE REQUESTS A FORMATTED FORM,ELSE UNFORMATTED
00007850*       DSPLY   : BIT IF TRUE DESIGNATED A DISPLAYED-ONLY FOR
00007860*       TERMCODE: FIXED BIN-0 FOR ONTEL,NO OTHERS DEFINED NOW
00007870*RETCODE: RETURN CODE, SET BY FORM.                                      *
00007880*                                                                        *
00007890*                                                                        *
00007900*                                                                        *
00007910*                        OUTPUT                                          *
00007920*                                                                        *
00007930*                                                                        *
00007940*AS OUTPUT FORM RETURNS THE EDITED 'INPUT' RECORD AND A RETURN CODE.      *
00007950*IF A TRANSMISSION ERROR OCCURS AND 'N' IS SPECIFIED AS ANSWER TO      *
00007960*THE PROMPT MESSAGE THEN THE INPUT RECORD, 'INPUT' IS RETURNED TO THE     *
00007970*CALLING TASK UNCHANGED.                                                 *
00007980*                                                                        *
00007990*                                                                        *
00008000*                     RETURN CODES                                       *
00008010*                                                                        *
00008020*0=SUCESS, ALL FUNCS COMPLETE.                                           *
00008030*4=PAGESIZE_ERROR, FORM TOO LARGE FOR PHYSICAL SIZE OF VIDEO DISPLAY     *
00008040*8=TERMCODE_ERROR, UNDEFINED TERMINAL CODE, NO CORRESPONDING TUBE.       *
00008050*12=WHERE_ERROR,  IMPROPER POSITION SPECIFIED IN LBLWHER
00008060*16=LENGTH_ERROR,  IMPROPER "WHERE"-"LEN" COMBO W.R.T. "INPUT"
00008070*20=XFER_ERROR, TRANSMISSION ERROR OCCURED AND USER/OPER COMMANDED       *
00008080*               A RETURN TO CALLING TASK WITH INPUT RECORD, 'CONT',      *
00008090*               UNMODIFIED.                                              *
00008100*                                                                        *
00008110*                                                                        *
00008120*       DEFINITION OF SYMBOLS USED IN DOCUMENTING FORM                   *
00008130*                                                                        *
00008140*                                                                        *
00008150*ASSN=ASSOCIATED                                                         *
00008160*BLK=BLOCK                                                               *
00008170*BUF=BUFFER                                                              *
00008180*CHAR=CHARACTER                                                          *
00008190*CONT=CONTENTS                                                           *
00008200*CT=COUNT                                                                *
00008210*DEF=DEFINITION                                                          *
00008220*DEV=DEVICE                                                              *
00008230*EXEC=EXECUTE                                                            *
00008240*EXT=EXTENT                                                              *
00008250*FM=FORM                                                                 *
00008260*FLD=FIELD                                                               *
00008270*INIT=INITIALIZE                                                         *
00008280*LEN=LENGTH                                                              *
00008290*LBL=LABEL                                                               *
00008300*NXT=NEXT                                                                *
00008310*PROT=PROTECT                                                            *
00008320*PTR=POINTER                                                             *
00008330*REP=REPRESENT                                                           *
00008340*RET=RETURN                                                              *
00008350*STG=STRING                                                              *
00008360*XFER=TRANSFER                                                           *
00008370*                                                                        *
00008380*                                                                        *
00008390**************************************************************************/
00008400%PAGE;
00008410FORM: PROC(FORMMAP,INPUT,FORMOPTS,RETCODE) REORDER;
00008420%SKIP(3);
00008430/*DCL PARAMETERS*/
00008440%SKIP;
00008450     DCL 1 FORMMAP(*),
00008460         2 LBL CHAR(*) VAR,
00008470         2 LBLWHER FIXED BIN,
00008480         2 WHERE FIXED BIN,
00008490         2 LEN   FIXED BIN,
00008500         INPUT CHAR(*) VAR, /*INPUT RECORD*/
00008510         1 FORMOPTS,
00008520           2 FORMAT BIT(1),
00008530           2 DSPLY BIT(1),
00008540           2 TERMCODE FIXED BIN,
00008550         RETCODE FIXED BIN; /*RETURN CODE, SET BY FORM*/
00008560%SKIP(2);
00008570/*DCL I/O FILES AND I/O VARIBLES*/
00008580%SKIP;
00008590DCL   (TEMP,FORMREC) CHAR(SUM(FORMMAP.LEN)) VAR, /*STORE FOR THE DATA OF THE RECORD */
00008600      READ_CT FIXED BIN INIT(0); /*VALUE REPRESENTING THE NUMBER OF FORM SEGMENTS WHICH MUST
00008610                                                         BE READ*/
00008620%SKIP(2);
00008630/*DCL BUILTIN FUNCTIONS*/
00008640%SKIP;
00008650DCL (ADDR,LBOUND,HBOUND,LENGTH,SUBSTR,SUM,UNSPEC) BUILTIN;
00008660%SKIP(2);
00008670/************************************************************************************
00008680*  TERMINAL TABLE (TT) IS A STRUCTURE DEFINING                                      *
00008690*THE PHYSICAL AND OPERATIONAL CHARACTERISTICS OF ANY VIDEO DEVICE FORM              *
00008700*MAY CURRENTLY BE IN COMMUNICATION WITH. AS A FUNCTION OF THE TERMCODE              *
00008710*'TT' IS SUPERIMPOSED OVER A REAL STRUCTURE DEFINING THE CURRENT VIDEO DEVICE FM IS *
00008720*COMMUNICATING WITH. FOR EACH NEW VIDEO DEVICE FORM COMMUNICATES WITH A             *
00008730*NEW STRUCTURE MUST BE CONSTRUCTED. THIS NEW STRUCTURE, LIKE THE 'ONTEL' STRUCTURE  *
00008740*BELOW, MUST HAVE IDENTICAL STRUCTURING AS THE BASED 'TT' STRUCTURE. EACH SUCH NEW  *
00008750*STRUCTURE MUST CONTAIN ENTRY VARIABLES DEFINING ENTRY POINTS TO TWO FUNCTIONS      *
00008760*IMPLEMENTING VIDEO SCREEN ADDRESSING FOR THAT PARTICULAR VIDEO DEVICE,             *
00008770*FUTHERMORE, EACH SUCH NEW STRUCTURE SHALL CONTAIN A POINTER TO A BASED CONTROL BLK *
00008780*DESCRIBING DECICE DEPENDENT VIDEO SCREEN ADDRESSING COORDINATES.                   *
00008790*************************************************************************************/
00008800%SKIP;
00008810DCL 1 TT BASED(TERMPTR), /*TERMINAL TABLE STRUCTURE*/
00008820  2 ANY_TERMINAL,
00008830     3 PHYSICAL_CHAR,
00008840        4 LINESIZE FIXED BIN INIT(0),
00008850        4 PAGESIZE FIXED BIN INIT(0),
00008860     3 OPER_CHAR,
00008870        4 ESC CHAR(1), /*ESCAPE CHAR*/
00008880        4 SPA CHAR(2), /*START PROT AREA*/
00008890        4 EPA CHAR(2), /*END PROT AREA*/
00008900        4 CUH CHAR(2), /*CURSOR HOME*/
00008910        4 CUP CHAR(2), /*CURSOR POSITION*/
00008920        4 EED CHAR(2), /*ERASE TO END OF DISPLAY*/
00008930        4 BLK CHAR(2), /*BLK MODE*/
00008940        4 FMTAB CHAR(2), /*FORMAT TAB*/
00008950        4 J CHAR(1), /*BECOMES LINEFEED*/
00008960        4 M CHAR(1), /*BECOMES CR*/
00008970        4 BIK CHAR(3), /*WARNING BLINK*/
00008980        4 ETX CHAR(2), /*END OF XFER*/
00008990        4 SD CHAR(2), /*SCROLL DOWN*/
00009000        4 POSITION ENTRY VARIABLE RETURNS(CHAR(6) VAR) INIT(NOTHING),
00009010        4 INITRTN ENTRY RETURNS(POINTER) INIT(DUMMY),
00009020        4 MEMPTR POINTER, /*POINTER TO BASED ADDRESSING CONTROL BLOCK*/
00009030        4 ENDSEQ CHAR(6); /*ENDING SEQUENCE*/
00009040%SKIP(3);
00009050/*THIS STRUCTURE DESCRIBES AN ONTEL VIDEO DEVICE, TERMCODE=0*/
00009060%SKIP;
00009070DCL 1 ONTEL,
00009080     2 TERMINAL,
00009090        3 PHYSICAL_CHAR,
00009100           4 LINESIZE FIXED BIN INIT(80),
00009110           4 PAGESIZE FIXED BIN INIT(19),
00009120        3 OPER_CHAR,
00009130         4 ESC CHAR(1), /*ESCAPE CHAR*/
00009140         4 SPA CHAR(2), /*START PROT AREA*/
00009150         4 EPA CHAR(2), /*END PROT AREA*/
00009160         4 CUH CHAR(2), /*CURSOR HOME*/
00009170         4 CUP CHAR(2), /*CURSOR POSITION*/
00009180         4 EED CHAR(2), /*ERASE TO END OF DISPLAY*/
00009190         4 BLK CHAR(2), /*BLK MODE*/
00009200         4 FMTAB CHAR(2), /*FORMAT TAB*/
00009210         4 J CHAR(1), /*BECOMES LINE FEED*/
00009220         4 M CHAR(1), /*BECOMES CR*/
00009230         4 BIK CHAR(3), /*WARNING BLINK*/
00009240         4 ETX CHAR(2), /*END OF XFER*/
00009250         4 SD CHAR(2), /*SCROLL DOWN*/
00009260         4 POSITION ENTRY VARIABLE RETURNS(CHAR(6) VAR) INIT(ADDRESS),
00009270         4 INITRTN ENTRY RETURNS(POINTER) INIT(INITONTEL),
00009280         4 MEMPTR POINTER, /*POINTER TO BASED ADDRESSING CONTROL BLOCK*/
00009290         4 ENDSEQ CHAR(6); /*ENDING SEQUENCE*/
00009300%PAGE;
00009310/*************************************************************************
00009320ENTER HERE A STRUCTURE DESCRIBING THE NEXT VIDEO DEVICE, TERMCODE=1      *
00009330*************************************************************************/
00009340%SKIP(2);
00009350/*THIS DESCRIBES A BASED CONTROL BLOCK CONTAINING DEVICE DEPENDENT VIDEO SCREEN ADDRESSING
00009360COORDINATES AND IS POINTED TO BY 'MEMPTR' LOCATED WITHIN THE ONTEL STRUCTURE*/
00009370%SKIP;
00009380DCL 1 ONTELMEM BASED(TT.MEMPTR),
00009390  2 LINE PIC'99' INIT(0), /*X SCREEN COORDINATE*/
00009400  2 COLUMN PIC'99' INIT(0); /*Y SCREEN COORDINATE*/
00009410%SKIP(2);
00009420/***************************************************************************
00009430ENTER HERE THE NEXT BASED STRUCTURE DEFINING VIDEO SCREEN ADDRESSING       *
00009440COORDINATES.                                                               *
00009450***************************************************************************/
00009460%SKIP(2);
00009470/*DCL OFFSET AND TEST VARIABLES*/
00009480%SKIP;
00009490DCL LENSUM FIXED BIN INIT(4), /*CURRENT LEN OF THE CONTENTS OF FORM*/
00009500    THISLEN FIXED BIN, /*BUFFER FOR LEN(I) IN LOOP */
00009510    THISLBL CHAR(256) VAR, /*BUFFER FOR LBL(I) IN LOOP */
00009520    POS FIXED BIN,   /*TO DISTRIBUTE EDITED INFO TO INPUT RECORD*/
00009530    (NOTDONE,PROMPTABLE) BIT(1),  /*FOR WHILE BLOCK CONTROL */
00009540    CARMODE BIT(1) INIT('1'B),  /*TO KEEP TRACK OF WHETHER BLOCK OR CAR MODE*/
00009550    RECPOS FIXED BIN INIT(1), /*OFFSET REP 1ST CHAR OF NXT RECORD FLD*/
00009560    LINELEN FIXED BIN INIT(0), /*LINELEN=LEN(CURRENT LINE EMBEDDED IN SRMFM)*/
00009570    LABELST FIXED BIN, /* SET TO WHERE CURRENT LABEL STARTED ON SCREEN */
00009580    DUMMY FIXED BIN INIT(1), /*THIS IS A DUMMY VARIABLE, DUMMY*/
00009590    TCAMLIM FIXED BIN INIT(TCAM_CONSTANT) , /*MAX TCAM BUF SIZE*/
00009600    TCAM_CONSTANT FIXED BIN INIT(256) STATIC; /*LIMIT ON READABLE TCAM
00009610                                                          SEGMENT*/
00009620%SKIP(2);
00009630/*DCL SCAN VARIABLES*/
00009640%SKIP;
00009650DCL THEFORM CHAR(2400) VAR INIT(''), /*THEFORM=SCREEN FORM,BUFFER WHICH WHEN SENT TO DISPLAY
00009660                      DEVICE GENERATES THE FORM, THEFORM IS BUILT BY 'BUILDFM' SUBROUTINE*/
00009670    WKAREA CHAR(TCAM_CONSTANT) VAR INIT(''), /*NEEDED SCRATCH MEMORY SPACE*/
00009680    CARSLEFT FIXED BIN INIT(0), /*CARSLEFT=REMAINING AVAILABLE POSITIONS IN THE
00009690                        CURRENT LINE EMBEDDED IN THEFORM*/
00009700    MIDDLE FIXED BIN; /*NUM OF LINES THE FORM MUST BE SCROLLED DOWN TO ACHIEVE CENTERING,
00009710                                          MIDDLE=[(TT.PAGESIZE-LINE/2)]*/
00009720%SKIP(2);
00009730/*DCL RETURN CODES*/
00009740%SKIP;
00009750 DCL SUCESS FIXED BIN INIT(0), /*ALL FUNCTIONS COMPLETED*/
00009760    PAGESIZE_ERROR FIXED BIN INIT(4), /*PAGESIZE ERROR*/
00009770    TERMCODE_ERROR FIXED BIN INIT(8), /*NO CORRESPONDING VIDEO DEVICE
00009780                                         EXISTS FOR DESIGNATED TERMCODE*/
00009790    WHERE_ERROR  FIXED BIN INIT(12), /*A WHERLEN DOESNT MAKE SENSE */
00009800    LENGTH_ERROR FIXED BIN INIT(16), /*STRINGRANGE ON SUBSTR(INPUT,WHERE,LEN) */
00009810    XFER_ERROR FIXED BIN INIT(20); /*XFER ERROR OCCURED AND USER/OPER
00009820                                   COMMANDED A RETURNTO CALLING TASK*/
00009830%SKIP(2);
00009840/*DCL MISCELLANEOUS*/
00009850%SKIP;
00009860DCL TELLCTL ENTRY(CHAR(*) VAR),
00009870    ASK ENTRY EXT,
00009880    ARRAYEXT FIXED BIN, /*EXTENT OF LBL ARRAY*/
00009890    BLINK1 CHAR(2) INIT('=>'),
00009900    BLINK2 CHAR(2) INIT('<='),
00009910    NOTHING, /*USED AS A DUMMY IN THE BASED STRUCTURE, "TT" */
00009920    TERMPTR PTR, /*POINTER TO THE TERMINAL TABLE DEFINING THE CURRENT VIDEO DEVICE*/
00009930    I FIXED BIN, /*USED AS INDEX*/
00009940    K FIXED BIN, /*USED AS INDEX*/
00009950    RECOVER CHAR(256) VAR INIT('REC'); /*RECOVERY SIGNAL*/
00009960%SKIP(3);
00009970/*               DECLARATIONS END HERE                            */
00009980%PAGE;
00009990/*           INITIALIZATIONS AND ERROR HANDLING ROUTINES                      */
00010000%SKIP(2);
00010010RETCODE=SUCESS;  /*UNLESS OTHERWISE CHANGED */
00010020%SKIP(3);
00010030/*DETERMINE WHAT VIDEO DEVICE FORM MUST COMMUNICATE WITH AND
00010040SUPERIMPOSE THE 'TT' BASED STRUCTURE OVER THE CORRECT CORRESPONDING
00010050REAL TERMINAL STRUCTURE*/
00010060%SKIP;
00010070    IF TERMCODE=0 THEN TERMPTR=ADDR(ONTEL); /*POINT THE BASE OF TT TO THE ONTEL
00010080                                                             STRUCTURE*/
00010090/**************************************************************************
00010100ENTER HERE TESTS FOR FUTURE VIDEO DEVICES, NXT VIDEO DEVICE, TERMCODE=1   *
00010110**************************************************************************/
00010120    ELSE  /*UNDEFINED TERMCODE, THERE IS NO CORRESPONDENCE BETWEEN A
00010130                                 HARDWARE VIDEO DEVICE AND PRESENT TERMCODE*/
00010140         RETCODE=TERMCODE_ERROR;
00010150 
00010160 IF RETCODE=SUCESS THEN DO;
00010170   TT.MEMPTR=TT.INITRTN( ); /*INIT PTR TO ALLOCATED STORAGE CONTAINING DEVICE
00010180                               DEPENDENT VIDEO SCREEN ADDRESSING COORDINATES*/
00010190   CALL DEFTERM(TERMCODE); /*DEFINE CURRENT TERMINAL TO FORM BY INITIALIZING
00010200                             THE TERMINAL TABLE STRUCTURE BY TERMCODE*/
00010210END;
00010220%PAGE;
00010230IF RETCODE=SUCESS THEN CALL BUILDFM; /*BUILDS THE FORM INTO THE VARIABLE
00010240                                       "THEFORM" AND SETS "RETCODE" */
00010250 
00010260NOTDONE='1'B;
00010270DO WHILE(NOTDONE & RETCODE=SUCESS);  /*KEEP DOING UNTIL ACCEPTABLE TRANSMISSION */
00010280   NOTDONE='0'B;  /*WILL BE RESET BY ANYTHING WISHING RETRY */
00010290 IF CARMODE THEN DO; CARMODE='0'B; CALL TELLCTL(TT.EED||TT.BLK||THEFORM); END;
00010300             ELSE CALL TELLCTL(TT.EED||THEFORM);
00010310%SKIP(3);
00010320/************************************************************************************
00010330**THIS BLK OF LOGIC CAN BE ACTIVATED AT SOME FUTURE DATE. IT WILL CENTER THE FORM   *
00010340*IN THE MIDDLE OF THE VIDEO DEVICE. IF IT IS ACTIVATED THEN 'CENTER'
00010350*MUST BE ADDED TO THE BITS IN THE PARAMETER "FORMOPTS"
00010360*************************************************************************************
00010370**ORIENT FORM TO CENTER SCREEN**                                                 *
00010380%SKIP$                                                                              *
00010390  IF CENTER                                                                       *
00010400     THEN DO$                                                                       *
00010410        MIDDLE=(TT.PAGESIZE-LINE)/2$                                                *
00010420        IF MIDDLE<1 **THE SCREEN IS FULL**                                          *
00010430           THEN DO$                                                                 *
00010440              CALL TELLCTL(TT.CUH)$ **DO NOT ORIENTATE FORM**                        *
00010450           END$                                                                     *
00010460           ELSE DO$                                                                 *
00010470SCROLL:       CALL TELLCTL(TT.SD)$ **ORIENTATE**                                     *
00010480              MIDDLE=MIDDLE-1$                                                      *
00010490              IF MIDDLE^=0 THEN GO TO SCROLL$                                       *
00010500              CALL TELLCTL(TT.CUH||TT.FMTAB)$ **DRIVE CURSOR HOME TO FIRST UNPROTECTED*
00010510           END$                                                                     *
00010520      END$                                                                          *
00010530%SKIP$                                                                              *
00010540      ELSE CALL TELLCTL(TT.CUH)$ **DRIVE CURSOR HOME AFTER THEFORM IS WRITTEN TO VIDEO**
00010550*************************************************************************************/
00010560%SKIP(3);
00010570/*                     I/O PROCEEDURE                                 */
00010580%SKIP(3);
00010590IF ^DSPLY THEN DO;
00010600  CALL TELLCTL(''||TT.CUH);  /*DRIVE CURSOR HOME*/
00010610  CALL ASK(TEMP); /*PUT UP READ FOR FIRST BLK XFER*/
00010620%SKIP(2);
00010630/*USER/OPERATOR EDITS FORM THEN ACTIVATES BLK XFER.*/
00010640%SKIP(2);
00010650  IF READ_CT^=0 /*IF MULTIPLE SEGMENTED FORM THEN DO AS MANY READS AS ARE SEGMENTS*/
00010660     THEN DO K=1 TO READ_CT;
00010670        CALL TELLCTL(''||TT.FMTAB); /*XFER SATISFIED SO FM TAB */
00010680        CALL ASK(WKAREA);
00010690        TEMP=TEMP||WKAREA;
00010700     END;
00010710%SKIP(2);
00010720/*IF USER/OPERATOR DID NOT CORRECTLY BLK XFER THE FORM CONTENT THEN RETRY*/
00010730%SKIP;
00010740   PROMPTABLE='1'B;
00010750   IF LENGTH(FORMREC)^=LENGTH(TEMP)
00010760      THEN DO WHILE(PROMPTABLE);
00010770        PROMPTABLE='0'B; /*WILL BE RESET BY A RETRY */
00010780        /*GET INTO CHARACTER MODE */
00010790        IF ^CARMODE THEN DO; CARMODE='1'B; CALL TELLCTL(''||TT.BLK); END;
00010800        CALL TELLCTL(TT.EED||'TRANSMISSION ERROR-RETRY?'
00010810                     ||TT.M||TT.J||'ENTER Y FOR YES,N FOR NO');
00010820        CALL ASK(RECOVER);
00010830        IF RECOVER='Y'
00010840          THEN NOTDONE='1'B;  /*CALLS FOR A RETRY */
00010850          ELSE IF RECOVER='N'
00010860             THEN DO;
00010870                CALL TELLCTL(''||TT.EED); /*INIT DISPLAY*/
00010880                RETCODE=XFER_ERROR; /*COMMUNICATE TO CALLING TASK THAT
00010890                                     INPUT RECORD REMAINS UNCHANGED*/
00010900             END;
00010910             ELSE PROMPTABLE='1'B;
00010920      END;
00010930 %SKIP(2);
00010940 END; /*ENDS ^DISPLAY BLOCK */
00010950 END; /*ENDS WHILE BLOCK FOR FORM EDITING */
00010960 
00010970 /*ARE HERE AFTER SUCCESSFUL FORM TRANSMISSION-EITHER DISPLAY OR EDITABLE*/
00010980%PAGE;
00010990  /* STICK THE INFO FROM THE FORM BACK INTO PROPER PLACES
00011000     OF "INPUT"  */
00011010 IF (^DSPLY) & RETCODE=SUCESS THEN DO;
00011020 POS=1;  /*WHERE TO EXTRACT FROM THE FORM("TEMP")  */
00011030 DO K=LBOUND(LEN,1) TO HBOUND(LEN,1);
00011040    SUBSTR(INPUT,WHERE(K),LEN(K))=SUBSTR(TEMP,POS,LEN(K));
00011050    POS=POS+LEN(K);
00011060    END;
00011070  CALL TELLCTL(''||TT.EED); /*INIT SCREEN */
00011080  END;
00011090 
00011100 /*GET INTO CHARACTER MODE */
00011110IF ^CARMODE
00011120   THEN DO; CARMODE='1'B; CALL TELLCTL(''||TT.BLK); END;
00011130RETURN; /*RETURN TO CALLING TASK*/
00011140%PAGE;
00011150BUILDFM: PROC;
00011160%SKIP(3);
00011170/*             DESCRIPTION OF BUILD FORM ALGORITHM                                   */
00011180%SKIP(2);
00011190/*BUILDFM ALGORITHM CONSTRUCTS SCREEN FORM (THEFORM) WHICH CONTAINS FORM LABELS,FORM CONTENT
00011200TERMINAL CONTROL COMMANDS AND ADDRESSING COORDINATES. EACH ITERATION OF BUILD LOOP (BL)
00011210BUILDS AN ORDERED PAIR (LABEL,CONTENT). THE LABEL IS PROTECTED AND IN A WHITE FLD,
00011220THE LABEL'S ASSOCIATED CONTENTS IS READ-WRITEABLE AND IS IN A BLACK FLD. ON COMPLETION
00011230OF THE CONSTRUCTION OF THEFORM AN ASSEMBLY LANGUAGE SUBROUTINE (TELLCTL) IS CALLED
00011240WHICH DOES A 'TPUT CONTROL' ON THEFORM AND THEREBY CREATES THE FORM ON THE VIDEO DEVICE*/
00011250%SKIP(3);
00011260 /*CHECK TO SEE THAT THE LBLWHER'S MAKE SENSE */
00011270 %SKIP(1);
00011280 DO K=LBOUND(LBLWHER,1) TO HBOUND(LBLWHER,1);
00011290    IF LBLWHER(K)<0 | LBLWHER(K)>=TT.LINESIZE
00011300       THEN DO;
00011310            RETCODE=WHERE_ERROR;
00011320            GO TO ENDBUILD;
00011330            END;
00011340 END;
00011350%SKIP(2);
00011360 /*BUILD THE RECORD TO BE FORMED */
00011370ON STRINGRANGE BEGIN; RETCODE=LENGTH_ERROR; GO TO ENDBUILD; END;
00011380FORMREC='';
00011390DO K=LBOUND(LEN,1) TO HBOUND(LEN,1);
00011400   (STRINGRANGE):FORMREC=FORMREC||SUBSTR(INPUT,WHERE(K),LEN(K));
00011410   END;
00011420 
00011430ARRAYEXT=HBOUND(LBL,1);
00011440 %PAGE;
00011450  /*LOOP THROUGH THE INPUT ARRAYS TO BUILD THE FORM */
00011460BL: DO I=LBOUND(LBL,1) TO ARRAYEXT;
00011470%SKIP(2);
00011480/*INTERROGATE LEN(THEFORM) FOR FOR TCAM VIOLATION, IF VIOLATION INIT MULTIPLE READ LOGIC*/
00011490     LENSUM=LENSUM+LEN(I);
00011500     IF LENSUM>=TCAMLIM
00011510        THEN DO;
00011520           READ_CT=READ_CT+1; /*REMEMBER HOW MANY SUBSEQUENT READS MUST BE EXEC PER FORM
00011530                                                          SEGMENT*/
00011540           TCAMLIM=TCAMLIM+TCAM_CONSTANT; /*BUMP TCAMLIM FORM NXT SEGMENT*/
00011550           IF LINELEN+11>TT.LINESIZE
00011560              THEN CALL BLANKIT; /*FILL OUT REMAINDER OF LINE WITH BLANKS*/
00011570           THEFORM=THEFORM||TT.SPA||TT.BIK||BLINK1||TT.BIK||TT.EPA||TT.ENDSEQ||
00011580                 TT.ETX||TT.SPA||TT.BIK||BLINK2||TT.BIK||TT.EPA;
00011590           LINELEN=LINELEN+11; /*BUMP LINELEN BY THE NUMBER OF POS"S */
00011600       END;
00011610%SKIP(5);
00011620             /*          START LABEL SCAN          */
00011630         THISLBL=LBL(I); /*BUFFER FOR CURRENT LABEL */
00011640%SKIP(2);
00011650/*IF CURRENT LBL WILL SPAN THE LINESIZE AND FORMATTING REQUIRED
00011660  OR IF THE LABEL MUST START AT AN "EARLIER" POSITION IN THE LINE
00011670  THEN BLANK OUT REMAINDER OF LINE AND BEGIN LBL ON NXT LINE*/
00011680      IF ((LENGTH(THISLBL)+LINELEN>TT.LINESIZE) & FORMAT)
00011690         | ((LBLWHER(I)>0) & (LBLWHER(I)<=LINELEN))
00011700           THEN CALL BLANKIT;
00011710 %SKIP(1);
00011720%SKIP(1);
00011730 /*FILL OUT WITH BLANKS TO THE PROPER POSITION IN THE LINE */
00011740  IF LBLWHER(I)>0 & (LBLWHER(I)-LINELEN)>1
00011750     THEN DO;
00011760          THEFORM=THEFORM||TT.SPA||REPEAT(' ',LBLWHER(I)-LINELEN-2)||TT.EPA;
00011770          LINELEN=LBLWHER(I)-1;
00011780          END;
00011790%SKIP(2);
00011800  LABELST=LINELEN+1;  /* FOR FUTURE DECISION   5/5/76 GB */
00011810%SKIP;
00011820  /*KEEP PUTTING OUT SEGMENTS OF THE LABEL UNTIL NO LONGER SPANS LINE */
00011830         DO WHILE (LENGTH(THISLBL)+LINELEN>=TT.LINESIZE) ;
00011840                   CARSLEFT=(TT.LINESIZE-LINELEN);
00011850                   THEFORM=THEFORM||TT.SPA||SUBSTR(THISLBL,1,CARSLEFT)
00011860                           ||TT.EPA||TT.POSITION( );
00011870                   LINELEN=0;
00011880                   THISLBL=SUBSTR(THISLBL,CARSLEFT+1);
00011890              END;
00011900%SKIP(2);
00011910/*THE FOLLOWING LABEL SEGMENT IS ASSURED NOT TO SPAN A LINE */
00011920        DO;
00011930           THEFORM=THEFORM||TT.SPA||THISLBL||TT.EPA;
00011940           LINELEN=LINELEN+LENGTH(THISLBL);
00011950        END;
00011960%SKIP(5);
00011970                     /*START CONTENTS SCAN*/
00011980  THISLEN=LEN(I); /*PUT THE CURRENT LENGTH IN A BUFFER */
00011990%SKIP;
00012000/*IF CURRENT CONTENT FLD WILL SPAN THE LINE AND FORMATTING
00012010  IS REQUIRED THEN BLANK OUT REMAINDER OF LINE */
00012020 /* CHANGE 3/25/76--DON'T START NEW LINE IF LABEL STARTED ON FIRST POS  GB */
00012030     IF((THISLEN+LINELEN>=TT.LINESIZE)   & FORMAT   &LABELST^=1 )
00012040        THEN CALL BLANKIT;
00012050%SKIP(2);
00012060 /*IF AT LEFT BORDER AND FORMATTING,THEN PUT IN A PROTECTED SPACE */
00012070     IF LINELEN=0 & FORMAT
00012080        THEN DO;
00012090             THEFORM=THEFORM||TT.SPA||' '||TT.EPA;
00012100             LINELEN=1;
00012110             END;
00012120 %SKIP(3);
00012130 /*WHILE CONTENTS EXTENDS OVER THE CURRENT LINE,
00012140   PUT IN AS MUCH AS YOU CAN ON THIS LINE     */
00012150     DO WHILE (THISLEN+LINELEN>=TT.LINESIZE) ;
00012160           CARSLEFT=(TT.LINESIZE-LINELEN);
00012170           IF FORMAT THEN CARSLEFT=CARSLEFT-1; /*LEAVE ROOM FOR PROTECTED BLANK */
00012180           THEFORM=THEFORM||SUBSTR(FORMREC,RECPOS,CARSLEFT);
00012190           RECPOS=RECPOS+CARSLEFT;
00012200           THISLEN=THISLEN-CARSLEFT;
00012210           IF FORMAT
00012220              THEN DO;  /* PUT IN APPROPRIATE PROTECTED BLANKS */
00012230                    THEFORM=THEFORM||TT.SPA||' '||TT.EPA||TT.POSITION( )||
00012240                            TT.SPA||' '||TT.EPA;
00012250                    LINELEN=1;
00012260                    END;
00012270              ELSE DO;  /*JUST END THE LINE */
00012280                    THEFORM=THEFORM||TT.POSITION( );
00012290                    LINELEN=0;
00012300                    END;
00012310        END;
00012320%SKIP(2);
00012330     DO;  /*PUT IN CURRENT NON-SPANNING LINE SEGMENT */
00012340        THEFORM=THEFORM||SUBSTR(FORMREC,RECPOS,THISLEN);
00012350        RECPOS=RECPOS+THISLEN;
00012360        LINELEN=LINELEN+THISLEN;
00012370     END;
00012380%SKIP(2);
00012390     /* IF TOO MANY LINES THEN RETURN WITH PAGESIZE ERROR */
00012400     IF LINE>TT.PAGESIZE
00012410        THEN DO;
00012420            RETCODE=PAGESIZE_ERROR;
00012430            GO TO ENDBUILD;
00012440            END;
00012450%SKIP(2);
00012460  END BL; /*END OF BUILD LOOP (BL)*/
00012470 %PAGE;
00012480/*INSERT ENDING SEQENCE (OVERBAR 'J' OVERBAR 'M'), ETX MARK AND BLANK FILLER INTO THEFORM
00012490  AND RETURN TO FORM FOR I/O PROCEEDURE*/
00012500  DO;
00012510  IF LINELEN+11>TT.LINESIZE /*IF STUFF GOES PAST LINE */
00012520     THEN CALL BLANKIT; /*BLANK OUT THE REMAINDER OF LINE*/
00012530  THEFORM=THEFORM||TT.SPA||TT.BIK||BLINK1||TT.BIK||TT.EPA||TT.ENDSEQ||
00012540         TT.ETX||TT.SPA||TT.BIK||BLINK2||TT.BIK||TT.EPA;
00012550  LINELEN=LINELEN+11; /*BUMP LINELEN BY THE NUMBER OF POS"S */
00012560  IF FORMAT THEN DO; CALL BLANKIT; CALL BLANKIT; END; END;
00012570 %SKIP(2);
00012580  IF LINE>TT.PAGESIZE  /*CHECK FOR TOO MANY LINES IN FORM */
00012590    THEN DO;
00012600         RETCODE=PAGESIZE_ERROR;
00012610         GO TO ENDBUILD;
00012620         END;
00012630  RETCODE=SUCESS;
00012640%SKIP(2);
00012650ENDBUILD:
00012660  RETURN;
00012670%PAGE;
00012680BLANKIT: PROC; /*BLANKS OUT REMAINDER OF LINE*/
00012690%SKIP;
00012700   CARSLEFT=(TT.LINESIZE-LINELEN);
00012710   IF CARSLEFT>0 THEN
00012720   THEFORM=THEFORM||TT.SPA||REPEAT(' ',CARSLEFT-1)||TT.EPA||TT.POSITION( );
00012730   ELSE THEFORM=THEFORM||TT.POSITION( );
00012740   LINELEN=0;
00012750END BLANKIT;
00012760%SKIP(3);
00012770  END BUILDFM;
00012780%PAGE;
00012790/*FOR EACH NEW VIDEO DEVICE MANAFACTURE WITH DIFFERENT ADDRESSING DISCIPLINES
00012800A NEW FUNCTION MUST BE DEFINED TO PERFORM THE VIDEO SCREEN ADDRESSING FOR THAT
00012810PARTICULAR SCOPE*/
00012820%SKIP(4);
00012830/*THIS FUNCTION RETURNS A CALCULATED ONTEL ADDRESS*/
00012840%SKIP;
00012850ADDRESS: PROC RETURNS(CHAR(6) VAR);
00012860   LINE=LINE+1;
00012870   COLUMN=0; /*START AT FIRST POSITION OF COLUMN AT ALL TIMES*/
00012880   RETURN(TT.CUP||LINE||COLUMN);
00012890END ADDRESS;
00012900%SKIP(2);
00012910/**************************************************************************
00012920ENTER HERE A FUNCTION DEFINNING AN ADDRESSING DISCIPLINE FOR ANOTHER     **
00012930TERMINAL                                                                  *
00012940**************************************************************************/
00012950%SKIP(2);
00012960/*ALLOCATE STORAGE FOR DEVICE DEPENDENT VIDEO SCREEN ADDRESSING COORDINATES*/
00012970%SKIP;
00012980INITONTEL: PROC RETURNS(POINTER);
00012990  DCL P POINTER;
00013000  ALLOCATE ONTELMEM SET(P);
00013010  RETURN(P);
00013020END INITONTEL;
00013030%SKIP;
00013040/**************************************************************************
00013050ENTER HERE A FUNCTION WHICH RETURNS A POINTER TO DEVICE DEPENDENT VIDEO   *
00013060SCREEN ADDRESSING COORDINATES FOR A PROPOSED VIDEO DEVICE FORM IS TO      *
00013070COMMUNICATE WITH                                                          *
00013080**************************************************************************/
00013090%PAGE;
00013100/*THIS SUBR CONTAINS DEV DEP CODE WHICH DEFINES THE CURRENT TERMINAL
00013110FORM IS COMMUNICATING WITH*/
00013120%SKIP;
00013130DEFTERM: PROC(TRMCODE);
00013140%SKIP;
00013150DCL TRMCODE FIXED BIN;
00013160%SKIP(2);
00013170IF TRMCODE=0
00013180  THEN DO;
00013190    UNSPEC(ONTEL.ESC)='00100111'B;
00013200    UNSPEC(ONTEL.J)='00100101'B;
00013210    UNSPEC(ONTEL.M)='00001101'B;
00013220    ONTEL.SPA=ONTEL.ESC||'N';
00013230    ONTEL.EPA=ONTEL.ESC||'O';
00013240    ONTEL.CUH=ONTEL.ESC||'_';
00013250    ONTEL.CUP=ONTEL.ESC||'-';
00013260    ONTEL.BLK=ONTEL.ESC||'1';
00013270    ONTEL.EED=ONTEL.ESC||'L';
00013280    ONTEL.FMTAB=ONTEL.ESC||'3';
00013290    ONTEL.ETX=ONTEL.ESC||'C';
00013300    ONTEL.SD=ONTEL.ESC||'Z';
00013310    ONTEL.BIK=ONTEL.ESC||'9'||'/';
00013320    ONTEL.ENDSEQ=ONTEL.ESC||'"'||ONTEL.J||ONTEL.ESC||'"'||ONTEL.M;
00013330    RETURN; /*RETURN TO MAINLINE FORM*/
00013340  END;
00013350%SKIP;
00013360IF TRMCODE=1
00013370    THEN DO;
00013380         DUMMY=DUMMY+1; /*DEF DEV ASSN WITH TERMCODE=1 HERE*/
00013390         RETURN; /*RET TO MAINLINE FORM*/
00013400    END;
00013410   END DEFTERM;
00013420%SKIP(4);
00013430  END FORM;
