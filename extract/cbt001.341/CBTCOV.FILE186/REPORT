00051250*PROCESS MARGINI(' ');
00051260(STRINGRANGE,SUBSCRIPTRANGE,SIZE): REPORT: /*REPORT GENERATING SYSTEM*/
00051270PROC(PARM) REORDER OPTIONS(MAIN);
00051280%SKIP;
00051290DCL PARM CHAR(100) VAR;
00051300%SKIP(2);
00051310/*REPORT IS A REPORT GENERATOR, IT IS A SUBSYSTEM OF RAVE AND AS SUCH GERNERATES
00051320REPORTS ON RAVE TYPE DIRECT ACCESS DATA BASES. FOR USER DOCUMENTATION REFER TO
00051330SYSTEM.DOCLIB.TEXT(REPORT) BOB IRWIN 25 FEB. 77*/
00051340%SKIP(2);
00051350/*ASSIGN VALUE SPECIFYING THE SIZE OF REPORT SEGMENTS PER OUTPUT PAGE*/
00051360%SKIP;
00051370 /*IF RSIZE IS ZERO THEN DYNAMICALLY CALCULATE REPORT SIZE*/
00051380%SKIP;
00051390GET STRING(SUBSTR(PARM,1,INDEX(PARM,',')-1)) LIST(RSIZE);
00051400GET STRING(SUBSTR(PARM,INDEX(PARM,',')+1)) LIST(RNUM);   
00051410                                     /*RNUM 'REPORT NUMBER' EXPLICITLY RESTRICTS THE NUM
00051420                                       OF REPORT SEGMENTS PER OUTPUT PAGE. IF RNUM
00051430                                       IS ZERO THEN RNUM IS DYMAMICALLY CALCULATED.*/
00051440%SKIP;
00051450/*INFORMATION NEEDED TO BUILD SORT RECORDS*/
00051460%SKIP;
00051470    DCL 1 FORMMAP(*) CTL, /*FILLED IN FROM INFO FILE-SEE USE OF FORM*/
00051480         2 FMLBL CHAR(80) VAR,
00051490         2 LBLWHER FIXED BIN,
00051500         2 FMWHER FIXED BIN,
00051510         2 FMLEN FIXED BIN;
00051520%SKIP;
00051530    DCL 1 COMMAND(*) CTL, /*FILLED FROM INFO FILE, ASSOCIATES COMMAND
00051540                                                   PARAMETERS WITH AND INDEX INTO FORMMAP*/
00051550         2 TYPE CHAR(10) VAR,
00051560         2 CMDFLD FIXED BIN;
00051570%SKIP;
00051580/*DCL WORK BUFFERS AND WORK VARIABLES*/
00051590%SKIP;
00051600    DCL REPORTCMD CHAR(CMDLIM) VAR,     /*BUFFER CONTAINING GOTTEN REPORT COMMAND
00051610                                       WHOSE MAX COMMAND LEN IS CMDLIM CHAR(S)*/
00051620         SORTRECD CHAR(1000) VAR INIT(''),     /*RECORD BUILT FOR SORT*/ 
00051630         (HEADER,CMDTEMP,CMDTEMP1,DATA,DESCRIP) CHAR(CMDLIM) VAR,     /*PARSING VARIABLES*/
00051640         RECORD CTL CHAR(RECLENGTH) VAR,     /*CONTAINS DBASE RECORDS*/
00051650         OFF FIXED BIN INIT(0),     /*OFFSET TO SUBFIELDS IN DBASE RECORD*/
00051660         LEN FIXED BIN INIT(0),     /*LENGTH OF SUBFIELDS IN DBASE REC*/
00051670         RECLENGTH FIXED BIN INIT(0),     /*REC LENGTH OF DATA BASE RECORD*/
00051680         KEYLENGTH FIXED BIN INIT(0),     /*KEY LENGTH OF DBASE REC*/
00051690         BLOCKS FIXED BIN INIT(0),     /*NUM OF BLOCKS IN DBASE*/
00051700         CMDCARD CHAR(130) VAR,     /* USED TO READ RECORD FROM SYSIN */
00051710         DECISION BIT(1),     /* BIT CONTROL */
00051720         (TEMPBEG,TEMPEND,ANDPLACE) FIXED BIN,     /*PARSING INDEX VARIABLES*/
00051730         SORTRETC FIXED BIN(31,0) INIT(0),     /*RETURN CODE FROM SORT PROCESSOR*/
00051740         RETCODE FIXED BIN INIT(0),     /*RETURN CODE FROM REPORT PROCESSOR*/
00051750         LSIZE FIXED BIN STATIC INIT(133),     /*LINE SIZE USED IN REPORT FORMATTING*/
00051760         PSIZE FIXED BIN STATIC INIT(60),     /*PAGE SIZE USED IN REPORT FORMATTING*/
00051770         PAGE# FIXED BIN(31,0) STATIC INIT(0),     /*PAGE NUMBERS OF REPORT*/
00051780         CTIME CHAR(9),     /*CURRENT TIME OF DAY*/
00051790         CDATE CHAR(6),     /*CURRENT DATE*/
00051800         RSIZE FIXED BIN INIT(0),     /*SIZE OF RSEGMENTS PER OUTPUT PAGE*/
00051810         RNUM FIXED BIN INIT(0),      /*NUMBER OF RSEGMENTS PER OUTPUT PAGE*/
00051820         CMDLIM FIXED BIN STATIC INIT(240);     /*MAX SIZE OF REPORT  COMMAND, 
00051830                                               MAX IS ARBITRARY*/
00051840%SKIP;
00051850/*DCL BUILT IN FUNCTIONS*/
00051860%SKIP;
00051870    DCL (DIM,LENGTH,INDEX,SUBSTR,NULL,PLIRETC,CHAR,PLISRTD,LOW,DATE,TIME,ADDR,MAX,
00051880         LINENO,MOD,ABS) BUILTIN;
00051890%SKIP;
00051900/*DCL LOGIC SUBROUTINE DECISION VARIABLES*/
00051910%SKIP;
00051920    DCL NO BIT(1) INIT(0B) STATIC,
00051930        YES BIT(1) INIT(1B) STATIC;
00051940%SKIP;
00051950/*DCL INDICES*/
00051960%SKIP;
00051970    DCL (I,J) FIXED BIN INIT(1);
00051980    DCL K FIXED BIN; /*USED IN REFER OPTION*/
00051990%SKIP;
00052000/*DCL FILES*/
00052010%SKIP;
00052020    DCL DBASE FILE INPUT ENV(F REGIONAL(2)) SEQUENTIAL KEYED,
00052030         INFOFIL FILE STREAM INPUT,
00052040         SYSPRINT FILE ENV(RECSIZE(220),BLKSIZE(3120),VB),
00052050         SYSIN FILE RECORD INPUT,
00052060         REPRTIT FILE RECORD OUTPUT, /*CONTAINS SELECTED AND SORTITED RECORDS WHICH
00052070                                      MAY BE USED FOR FUTHER PROCESSING*/
00052080         CRT FILE OUTPUT;    /*ERROR MSG ARE WRITTEN TO THIS FILE*/
00052090%SKIP;
00052100/*DCL FLAGS SET BY "ON" CONDITIONS*/
00052110%SKIP;
00052120 DCL MOREDB BIT(1) INIT('1'B);
00052130 DCL NOCMDS BIT(1) INIT('0'B); /* ENDFILE ON SYSIN */
00052140 DCL WRITEIT BIT(1) INIT('1'B);
00052150%SKIP;
00052160/*DCL EXTERNAL ENTRIES*/
00052170%SKIP;
00052180  DCL (ASK,TELL) ENTRY;
00052190%PAGE;
00052200/*DCL LIST PROCESSING STRUCTURES AND ASSOCIATED POINTERS. SEE DATA
00052210STRUCTURE LOGIC IN SYSTEM ROOM FILES UNDER PROJECT COMPONENET NAMED REPORT. FUNCTION
00052220OF LIST STRUCTURES: HEAD IS A HEADER NODE OF A HOROZONTAL LIST OF HEADERS, EACH
00052230HEADER CONTAINS MULTIPLE POINTERS TO VERTICAL SUBLISTS. THESE VERTICAL SUBSLISTS
00052240ARE 'SELECTOR, TITLES, AND RPTCMD', THERE IS A SET OF SUCH VERTICAL LISTS ASSOCIATED
00052250WITH EACH HEADER AND THERE EXISTS AS MANY HEADERS AS ARE INDIVIDUAL REPORTS. SELECTOR
00052260IS A LIST CONTAINING THE CHARACTERS STRINGS PARSED FROM THE REPORT COMMAND AND
00052270USED TO 'SELECT' PARTICULAR DATABASE RECORDS FOR INCLUSION IN THE REPORT. TITLES
00052280IS A LIST OF 'TITLES' THE SUM OF WHICH COMPRISE A REPORT SEGMENT. ASSOCIATED WITH
00052290EACH TITLE IS A SUBSTRING OF THE DATA BASE RECORD. RPTCMD IS A LIST OF REPORT
00052300COMMAND FRAGMENTS THE CONCATENATION OF WHICH IS A REPORT COMMAND. THIS IS LATER
00052310USED TO SUMMARIZE THE REPORT AND CONSTITUTES PART OF THE REPORT HEADER. OUTBUF IS A
00052320INDEPENDENT LINEAR LIST AND WAS IMPLEMENTED TO BUFFER HOROZONTAL REPORT RSEGMENTS
00052330IN THE CASE WHERE THERE IS TWO OR MORE REPORT SEGMENTS TO BE PRINTED ACORSS A PAGE
00052340OF OUTPUT. EACH LINE OF OUTPUT CONSISTS OF THE CONCATENATION OF A.) THE INFORMATION WHICH
00052350THE RECORD IS TO BE SORTED ON, THIS INFORMATION IS A SUBSET OF THE SELECTED DATA
00052360BASE RECORD. AND B.) A SUBSET OF THE SELECTED DATA BASE RECORD WHICH CONSTITUTES
00052370ONE REPORT SEGMENT AFTER IT IS PARSED FROM THE DBSE REC. THE FIRST TWO BYTES OF THIS 
00052380RECORD IS THE REPORT NUMBER WHICH ACTS AS A KEY TO PHYSICALLY SEPERATE REPORTS.*/
00052390%SKIP;
00052400    DCL (HEADBEG,OLDP,PHEAD,PSEL,PTIT,PCMD,OBUF,OBUFBEG,P) PTR INIT(NULL);
00052410%SKIP;
00052420    DCL 1 HEAD BASED(PHEAD),
00052430         2 REPORT# PIC'99',
00052440         2 SELLISTP PTR INIT(NULL),
00052450         2 TITLISTP PTR INIT(NULL),
00052460         2 CMDLISTP PTR INIT(NULL),
00052470         2 NXTHEAD PTR INIT(NULL);
00052480%SKIP;
00052490    DCL 1 SELECTORS BASED(PSEL),
00052500         2 NXTSEL PTR INIT(NULL),
00052510         2 (OFFSET,LENGTH,SELLEN) FIXED BIN,
00052520         2 SELECTOR CHAR(K REFER(SELECTORS.SELLEN)) VAR;
00052530%SKIP;
00052540    DCL 1 TITLES BASED(PTIT),
00052550         2 NXTTIT PTR INIT(NULL),
00052560         2 (OFFSET,LENGTH,TITLEN) FIXED BIN,  /*LEN OF TITLE, OFF/LEN IN IN DBSE RECORD*/
00052570         2 TITLE CHAR(K REFER(TITLES.TITLEN)) VAR; /*OF INFO ASSN/TITLE*/
00052580%SKIP;
00052590    DCL 1 RPTCMD BASED(PCMD),
00052600         2 NXTCMD PTR INIT(NULL),
00052610         2 COMMAND CHAR(130) VAR;
00052620%SKIP; 
00052630/*DCL OUTPUT BUFFER LIST STRUCTURE*/
00052640%SKIP;
00052650DCL 1 OUTBUF BASED(OBUF),
00052660  2 NEXT PTR INIT(NULL),
00052670  2 COL FIXED BIN,
00052680  2 LINE CHAR(1000) VAR,
00052690  2 TEMPLINE CHAR(500) VAR;      /*CONTAINS ONE REPORT SEGMENT LINE TO BE PRINTED*/
00052700%PAGE;
00052710/*OPEN SYSIN AND SYSPRINT FILES*/
00052720%SKIP;
00052730OPEN FILE(SYSIN);
00052740OPEN FILE(SYSPRINT) PRINT PAGESIZE(PSIZE);
00052750%SKIP;
00052760/*INPUT RTNES AND INPUT ERROR ANALYSIS RTNES*/
00052770%SKIP(1);
00052780    ON UNDEFINEDFILE(INFOFIL) GO TO NOINFO; /*ABORT REPORT*/
00052790    OPEN FILE(INFOFIL) ;
00052800    ON CONVERSION GO TO BADINFO; /*BAD INFO IN INFO FILE*/
00052810    ON ENDFILE(INFOFIL) GO TO LACKINFO; /*NO DATA*/
00052820    ON UNDEFINEDFILE(DBASE) GO TO NODIRECT; /*ABORT, NO DBASE*/
00052830    OPEN FILE(DBASE) ; /*DBSE IS OPEN FOR SEQUENCIAL*/
00052840%SKIP;
00052850/*LOAD ARRAYS USED IN PARSING DBASE RECORDS*/
00052860    GET FILE(INFOFIL) LIST(RECLENGTH,BLOCKS,KEYLENGTH);
00052870    GET FILE(INFOFIL) LIST(I); /*GET EXTENT OF FORMMAP*/
00052880    ALLOC FORMMAP(I); /*NOW ALLOCATE IT*/
00052890    GET FILE(INFOFIL) LIST(FMLBL,LBLWHER,FMWHER,FMLEN);
00052900    GET FILE(INFOFIL) LIST(J); /*GET EXTENT OF COMMAND ARRAY*/
00052910    ALLOC COMMAND(J); /*AND ALLOCATE IT*/
00052920    GET FILE(INFOFIL) LIST(TYPE,CMDFLD);
00052930    CLOSE FILE(INFOFIL);
00052940%SKIP;
00052950/*ALLOCATE WORK BUFFERS*/
00052960%SKIP;
00052970    ALLOC RECORD;
00052980%SKIP;
00052990/*ON CONDITIONS*/
00053000%SKIP;
00053010    ON ENDFILE(DBASE) MOREDB='0'B;
00053020    ON RECORD(DBASE) GO TO BADLRECL;
00053030    ON UNDEFINEDFILE(SYSIN) GO TO NOSYSIN;
00053040    ON RECORD(SYSIN) GO TO SYSINBAD;
00053050    ON ENDFILE(SYSIN) NOCMDS='1'B;
00053060    ON UNDEFINEDFILE(REPRTIT) WRITEIT='0'B;
00053070%SKIP;
00053080%PAGE;
00053090/*PARSE REPORT COMMANDS AND CONSTRUCT A LINK LIST OF REPORTS*/
00053100%SKIP(2);
00053110/*EXTRACT SELECTOR, DESCRIPTOR AND REPORT HEADER ELEMENTS*/
00053120%SKIP;
00053130CALL TELL('ENTER REPORT COMMAND');
00053140READ FILE(SYSIN) INTO(CMDCARD);
00053150DO WHILE (^NOCMDS);
00053160  CALL ADDHEAD; /*ADD A REPORT HEAD FOR THIS REPORT TO LINK LIST*/
00053170  CALL ADDCMD(CMDCARD); /*LINK IN COMMAND NODE FOR LATER OUTPUT PROCESSING*/
00053180  REPORTCMD=CMDCARD;
00053190  DO WHILE(^NOCMDS & INDEX(REPORTCMD,'.')=0);
00053200        CALL TELL('ENTER REMAINDER OF REPORT COMMAND');
00053210        READ FILE(SYSIN) INTO(CMDCARD);
00053220        CALL ADDCMD(CMDCARD);
00053230        REPORTCMD=REPORTCMD||CMDCARD;
00053240     END;
00053250  IF INDEX(REPORTCMD,'.')=0 THEN GO TO NOPERIOD;
00053260  CMDTEMP,CMDTEMP1=REPORTCMD;
00053270%SKIP;
00053280/*EXTRACT REPORT HEADER ELEMENTS, TRANSFORM THEM INTO TITLES AND
00053290ASSOCIATED INDICES INTO TARGET DATA BASE RECORD AND ADD THIS INFO TO THE TITLE SUBLST*/
00053300%SKIP;
00053310  TEMPBEG=INDEX(CMDTEMP,'('); TEMPEND=INDEX(CMDTEMP,')');
00053320  IF TEMPBEG=0|TEMPEND=0|TEMPEND<TEMPBEG THEN GO TO BADPAREN;
00053330  HEADER=SUBSTR(CMDTEMP,TEMPBEG+1,(TEMPEND-TEMPBEG)-1);
00053340  CALL TAKEOUT(HEADER,' '); /*EXTRACT IMBEDDED BLANKS FROM HEADER*/
00053350  IF HEADER=':ALL:' THEN CALL DOALL;
00053360  ELSE DO WHILE(HEADER^='');
00053370     ANDPLACE=MYINDEX(HEADER,'&');
00053380     DATA=SUBSTR(HEADER,1,ANDPLACE-1);
00053390     CALL TAKEOUT(DATA,' ');
00053400     IF ANDPLACE>=LENGTH(HEADER) THEN HEADER='';
00053410     ELSE DO;
00053420       HEADER=SUBSTR(HEADER,ANDPLACE+1);
00053430       END;
00053440     J=0;
00053450     DO I=1 TO DIM(COMMAND.CMDFLD,1) WHILE(DATA^=COMMAND.TYPE(I));
00053460        J=I; END;
00053470     IF J=DIM(COMMAND.CMDFLD,1) THEN GO TO BADHEADER;
00053480     OFF=FMWHER(CMDFLD(J+1));          /*OFF/LEN DEFINE WHERE IN DB REC THE INFO CORR TO 
00053490                                       THE TITLE EXISTS*/
00053500     LEN=FMLEN(CMDFLD(J+1));
00053510     DATA=FMLBL(CMDFLD(J+1));          /*TITLE OF CORRESPONDING INFO IN DB REC*/
00053520     CALL ADDTIT(OFF,LEN,DATA);
00053530     END;
00053540%SKIP(2);
00053550  CMDTEMP=SUBSTR(CMDTEMP,TEMPEND+1); /*TRUNCATE CMDTEMP BY HEADER */
00053560  DO WHILE(CMDTEMP^='.'); /*PARSE SELECTORS AND DESCRIPTORS IN PAIRS UNTILL CMD END*/
00053570    TEMPBEG=INDEX(CMDTEMP,'('); TEMPEND=INDEX(CMDTEMP,')');
00053580    IF TEMPBEG=0|TEMPEND=0|TEMPEND<TEMPBEG THEN GO TO BADPAREN;
00053590    DATA=SUBSTR(CMDTEMP,TEMPBEG+1,(TEMPEND-TEMPBEG)-1);
00053600%SKIP;
00053610/*EXTRACT ASSOCIATED DESCRIPTOR TO OBTAIN OFFSET AND LENGTH OF FIELD WITHIN
00053620DATABASE RECORD TO WHICH THE SELECTOR IS COMPARED TO*/
00053630%SKIP;
00053640    J=INDEX(CMDTEMP,' BY ');
00053650    IF J=0 THEN GO TO BADBY;
00053660    CMDTEMP1=SUBSTR(CMDTEMP,J+3);
00053670    DESCRIP=SUBSTR(CMDTEMP1,1,INDEX(CMDTEMP1,'(')-1);
00053680%SKIP;
00053690    CALL TAKEOUT(DESCRIP,' '); /* DEBLANK DESCRIPTOR */
00053700%SKIP;
00053710/*VERIFY THAT DESCRIPTOR IS VALID AND OBTAIN APPROPRIATE OFFSET AND
00053720LENGTH INTO DATA BASE RECORD*/
00053730%SKIP;
00053740/*IF A LITERAL DESCRIPTOR THAN OFFSET AND LENGTH IS GIVEN*/
00053750%SKIP;
00053760    IF INDEX(DESCRIP,':')>0 THEN DO; /*A LITERAL DESCRIPTOR IS OF THE FORM :OF,LEN:*/
00053770      TEMPBEG=INDEX(DESCRIP,':');
00053780      TEMPEND=INDEX(DESCRIP,',');
00053790      GET STRING(SUBSTR(DESCRIP,TEMPBEG+1,(TEMPEND-TEMPBEG)+1)) LIST(OFF);
00053800      DESCRIP=SUBSTR(DESCRIP,TEMPEND+1);
00053810      TEMPEND=INDEX(DESCRIP,':');
00053820      GET STRING(SUBSTR(DESCRIP,1,TEMPEND-1)) LIST(LEN);
00053830      CALL ADDSEL(OFF,LEN,DATA);
00053840      END;
00053850    ELSE DO;
00053860      J=0;
00053870      DO I=1 TO DIM(COMMAND.CMDFLD,1) WHILE(INDEX(DESCRIP,COMMAND.TYPE(I))=0);
00053880             J=I; END;
00053890      IF J= DIM(COMMAND.CMDFLD,1) THEN GO TO BADCOMMANDFIELD;
00053900      OFF=FMWHER(COMMAND.CMDFLD(J+1));
00053910      LEN=FMLEN(COMMAND.CMDFLD(J+1));
00053920      CALL ADDSEL(OFF,LEN,DATA);
00053930      END;
00053940    CMDTEMP=SUBSTR(CMDTEMP,INDEX(CMDTEMP,')')+1); /*TRUNCATE FOR NEXT PASS*/
00053950  END; /*CLOSES THE 'DO WHILE(CMDTEMP^='.')' LOOP*/
00053960CALL TELL('ENTER NEXT REPORT COMMAND OR AN END OF FILE');
00053970READ FILE(SYSIN) INTO(CMDCARD);
00053980END; /*CLOSES THE 'DO WHILE(^NOCMDS)' LOOP*/
00053990%SKIP;
00054000/*END OF PARSE*/
00054010%PAGE;
00054020/*PREPARE FOR CALL TO SORT*/
00054030%SKIP(2);
00054040READ FILE(DBASE) INTO(RECORD);
00054050PHEAD=HEADBEG;                  /*INITIALIZE LINK LIST PTR TO BEGINNING*/
00054060CALL PLISRTD(' SORT FIELDS=(5,256,CH,A) ',' RECORD TYPE=V,LENGTH=1000 ',
00054070                50000,SORTRETC,SORTIN,SORTOUT);
00054080IF SORTRETC=16 THEN GO TO BADSORT;
00054090ELSE IF SORTRETC=0 THEN GO TO DONE;
00054100  ELSE GO TO BADSORTCODE;
00054110%SKIP(3);
00054120/*PROGRAM NARATIVE OF SORT INTERFACE WITH REPORT, SEE SYSTEM FILES UNDER PAROJECT
00054130COMPONENT NAMED REPORT FOR GRAPHIC REPRESENTATION OF NARATIVE.*/
00054140%SKIP;
00054150/*REPORT MAIN READS INFO FILE DEFINING THE ASSOCIATION BETWEEN THE FORM FLASHED
00054160ON THE CRT SCREEN AND THE PROPERTIES OF THE DBSE AND ITS RECORDS, READS AND
00054170INTERPRETS INPUT REPORT COMMANDS, CONSTRUCTS SORT RECORD ACCORDING TO SELCTION
00054180CRITERIA ON REPORT COMMAND, THEN MAIN CALLS PL/I SORT.*/
00054190%SKIP;
00054200/*SORT THEN CALLS SORTIN PROC OF REPORT REQUESTING A RECORD TO BE SORTED. SORTIN
00054210THEN READS A (ONE) RECORD. THE RECORD IS THEN SELECTED AGANIST EACH POSSIBLE REPORT
00054220IN THE CASE OF MULTIPLE REPORTS. IF IT IS SLECTED THEN SORT IS CALLED WITH THE
00054230RECORD TO BE SORTED, IF NOT ALL LIST POINTERS ARE RESET THE NEXT RECORD IS READ IN
00054240AND THE SELECTION PROCESS BEGINS AGAIN.*/                  
00054250%SKIP;
00054260/*SORTOUT: AFTER ALL RECORDS FROM THE DBSE HAVE BEEN READ THE FIRST HEADER
00054270PAGE OF THE REPORT IS GENERATED, THE NUMBER OF REPORT SEGMENTS WHICH CAN BE
00054280FIT ACROSS A PAGE OF OUTPUT AND THE NUMBER OF CORRESPONDING IN CORE BUFFERS
00054290IS CALCULATED, THEN SORT IS RETURNED TO BY SORTIN WITH A RETURN CODE SPECIFYING THAT 
00054300NO MORE RECODS ARE TO BE READ. SORT THEN CALLS SORTOUT WITH A SORTED RECORD, SORTOUT BUFFERS
00054310ENOUGH SORTED RECORDS TO FIT ACROSS A PAGE OF OUTPUT AND PRINTS THEM OUT.*/
00054320%PAGE;
00054330/*SELECT AND BUILD RECORDS FOR SORT*/
00054340%SKIP(1);
00054350SORTIN: PROC RETURNS(CHAR(1000) VAR);
00054360%SKIP;
00054370DO WHILE(MOREDB);
00054380%SKIP;
00054390  DO WHILE(PHEAD^=NULL); /*DO TILL END OF LIST*/
00054400%SKIP;
00054410  /* INTERROGATE ALL RECORDS AGAINST SELECTION CRITERIA */
00054420    PSEL=SELLISTP; DECISION=YES;   /*PSEL NOW LOCATES FIRST SELECTOR NODE*/
00054430    DO WHILE(PSEL^=NULL & DECISION=YES);
00054440       IF INDEX(SELECTOR,'-')>0 THEN DECISION=DATETEST(SELECTOR);
00054450                               ELSE DECISION=LOGIC(SELECTOR);
00054460       PSEL=NXTSEL;
00054470       END;
00054480    %SKIP(1);
00054490    IF DECISION=YES  /* MEANS SHOULD BUILD THE SORT RECORD */
00054500       THEN DO;
00054510            PSEL=SELLISTP;
00054520            SORTRECD=CHAR(REPORT#);
00054530            DO WHILE(PSEL^=NULL); /* BUILD SORT RECORD */
00054540               SORTRECD=SORTRECD||SUBSTR(RECORD,SELECTORS.OFFSET,SELECTORS.LENGTH);
00054550               PSEL=NXTSEL; /* OBTAIN NEXT ELEMENT OF SORT RECORD */
00054560               END;
00054570         /* NOW MOD ON THE SUBFIELDS OF THE DATA BASE RECORDS */
00054580             PTIT=TITLISTP;
00054590             DO WHILE(PTIT^=NULL);
00054600                SORTRECD=SORTRECD||SUBSTR(RECORD,TITLES.OFFSET,TITLES.LENGTH);
00054610                PTIT=NXTTIT;
00054620                END;
00054630          /* CALL SORT AND CHAIN DOWN HEAD LIST */
00054640            IF LENGTH(SORTRECD)<256 THEN SORTRECD=SORTRECD
00054650               || LOW(256-LENGTH(SORTRECD));
00054660            PHEAD=NXTHEAD;
00054670            CALL PLIRETC(12);     /*RETURN TO SORT WITH SELECTED DB RECORD*/
00054680            RETURN(SORTRECD);
00054690            END;
00054700            PHEAD=NXTHEAD;
00054710%SKIP;
00054720     END; /* END OF DO WHILE(PHEAD^=NULL) LOOP */
00054730%SKIP;
00054740   READ FILE(DBASE) INTO(RECORD);
00054750   PHEAD=HEADBEG;
00054760   END; /* END OF DO WHILE(MOREDB) LOOP */
00054770%SKIP;
00054780PHEAD=HEADBEG; /*GET READY TO TRAVERSE LIST IN SORTOUT RTNE*/
00054790CALL BALLOC; /*ALLOCATE AS MANY REPORT OUTPUT BUFFERS AS WILL FIT ACROSS A PAGE OF OUTPUT*/
00054800CALL NEWPAGE; /*GENERATE FIRST TITLE PAGE*/
00054810PUT SKIP(2); /*SEPERATE REPORT FROM REPORT COMMAND*/
00054820OPEN FILE(REPRTIT);
00054830CALL PLIRETC(8);
00054840END SORTIN;
00054850%PAGE;
00054860SORTOUT: PROC(SORTREC);
00054870%SKIP;
00054880DCL SORTREC CHAR(*);
00054890DCL INDEX FIXED BIN INIT(1);
00054900%SKIP;
00054910IF WRITEIT THEN WRITE FILE(REPRTIT)  FROM(SORTREC);
00054920%SKIP;
00054930ON ENDPAGE(SYSPRINT) CALL NEWPAGE;
00054940IF SUBSTR(SORTREC,1,2)^=CHAR(REPORT#) THEN DO; /*DO IF SORTREC CORRESPONDES
00054950                                                  TO THIS REPORT*/
00054960  CALL WRITEOUT; /*FLUSH OUT ANY BUFFERS FOR THIS REPORT*/
00054970  CALL BFREE; /*AND FREE THEM*/
00054980  PHEAD=NXTHEAD;
00054990  CALL BALLOC; /*ALLOCATE BUFFERS FOR THIS REPORT*/
00055000  CALL NEWPAGE; /*HEADER FOR OUTPUT PAGE*/
00055010  END;
00055020IF OBUF=NULL THEN CALL WRITEOUT;
00055030OUTBUF.LINE=SUBSTR(SORTREC,3);  /*SORT RECORD LESS REPORT NUMBER*/
00055040OBUF=OUTBUF.NEXT; /*OBUF PTR IS RESET IN WRITEOUT RTNE*/
00055050CALL PLIRETC(4); /*REQUEST ANOTHER SORTED REPORT RECORD FORM SORT*/
00055060END SORTOUT;
00055070%PAGE;
00055080WRITEOUT: PROC;
00055090%SKIP;
00055100DCL INDEX FIXED BIN INIT(1);
00055110%SKIP;
00055120%SKIP;
00055130  PSEL=SELLISTP; /*CALULATE OFFSET OF FIRST TITLE FIELD*/
00055140  DO WHILE(PSEL^=NULL);
00055150    INDEX=INDEX+SELECTORS.LENGTH;
00055160    PSEL=NXTSEL;
00055170    END;
00055180%SKIP;
00055190/*WILL THIS REPORT SEGMENT FIT ON REMAINDER OF OUTPUT PAGE*/
00055200%SKIP;
00055210  J=0; /*'J' WILL CONTAIN THE NUMBER OF LINES TO BE PRINTED FOR THIS REPORT SEGMENT*/
00055220  PTIT=TITLISTP;
00055230  DO WHILE(PTIT^=NULL);
00055240    J=J+1;
00055250    PTIT=NXTTIT;
00055260    END;
00055270  IF J+LINENO(SYSPRINT)>PSIZE THEN CALL NEWPAGE;
00055280%SKIP;
00055290  PTIT=TITLISTP; /*NOW PROCESS TITLES AND THIER CONTENTS*/
00055300  DO WHILE (PTIT^=NULL);
00055310%SKIP;
00055320/*IF REPORT SIZE SPECIFIED IS SMALLER THAN CURRENT TITLE AND INFO THAN
00055330FOLD THE EXTRA LONG LINES OVER TO THE NEXT LINE*/
00055340%SKIP; 
00055350    IF TITLES.LENGTH+TITLEN+2>RSIZE & RSIZE^=0 THEN CALL FOLD(INDEX);
00055360     ELSE CALL NOFOLD(INDEX);
00055370%SKIP;
00055380    PTIT=NXTTIT;
00055390    END;
00055400  PUT SKIP; /*SEPERATES REPORT SEGMENTS*/
00055410%SKIP;
00055420/*NOW NULLIFY ALL REPORT RECORDS FOR SUBSEQUENT PROCESSING*/
00055430%SKIP;
00055440OBUF=OBUFBEG;
00055450DO WHILE(OBUF^=NULL);
00055460  OUTBUF.LINE='';
00055470  OBUF=OUTBUF.NEXT;
00055480  END;
00055490OBUF=OBUFBEG; /*REINIT PTR TO OUTBUF*/
00055500%SKIP; 
00055510END WRITEOUT;
00055520%PAGE;
00055530NOFOLD: PROC(OFFSET);
00055540%SKIP;
00055550DCL OFFSET FIXED BIN;
00055560%SKIP;
00055570    OBUF=OBUFBEG;
00055580%SKIP; 
00055590    DO WHILE(OBUF^=NULL & OUTBUF.LINE^='');
00055600      PUT FILE(SYSPRINT)  EDIT(TITLE||': '||SUBSTR(OUTBUF.LINE,OFFSET,TITLES.LENGTH))
00055610      (COL(OUTBUF.COL),A);
00055620      OBUF=OUTBUF.NEXT;
00055630      END;
00055640    PUT SKIP; /*SEPERATES REPORT LINES*/
00055650    OFFSET=OFFSET+TITLES.LENGTH;
00055660%SKIP; 
00055670END NOFOLD; 
00055680%PAGE; 
00055690FOLD: PROC(OFFSET);
00055700%SKIP;
00055710DCL OFFSET FIXED BIN,
00055720 OFFSET1 FIXED BIN INIT(1),
00055730 FOLDS FIXED BIN,
00055740 I FIXED BIN,
00055750 SUMSIZE FIXED BIN INIT(0), /*SUM OF RSIZES*/
00055760 CFACT FIXED BIN INIT(0), /*CORRECTION FACTOR*/
00055770 BLANK BIT(1) INIT('1'B); /*TEST FOR IMBEDDED BLANK LINES IN REPORT SEGMENT*/
00055780%SKIP;
00055790IF MOD((TITLES.LENGTH+(TITLEN+2)),RSIZE)=0 THEN FOLDS=((TITLES.LENGTH+(TITLEN+2))/RSIZE);
00055800 ELSE FOLDS=((TITLES.LENGTH+(TITLEN+2))/RSIZE)+1;
00055810%SKIP;
00055820%SKIP;
00055830DO I=1 TO FOLDS;
00055840  OBUF=OBUFBEG;
00055850  SUMSIZE=SUMSIZE+RSIZE;                       
00055860  IF SUMSIZE>TITLES.LENGTH+TITLEN+2     /*THE CONSTANT '2' ACCOUNTS FOR THE BLANK
00055870                                         AND THE COLON IN THE FINAL OUTPUT*/
00055880     THEN CFACT=SUMSIZE-(TITLES.LENGTH+TITLEN+2);
00055890  ELSE;
00055900%SKIP;
00055910/*PUT OUT LINES OF REPORT SEGMENTS ACROSS THE OUPUT PAGE. THE EXECUTION OF THIS
00055920LOOP PUTS ONE OR MORE REPORT LINES ACROSS THE PAGE.*/
00055930%SKIP;
00055940  DO WHILE(OBUF^=NULL & OUTBUF.LINE^='');
00055950    IF I=1  
00055960        THEN DO;
00055970        OUTBUF.TEMPLINE=TITLE||': '||SUBSTR(OUTBUF.LINE,OFFSET,TITLES.LENGTH);
00055980        PUT FILE(SYSPRINT) EDIT(SUBSTR(OUTBUF.TEMPLINE,OFFSET1,RSIZE-CFACT))
00055990          (COL(OUTBUF.COL),A);
00056000     END;
00056010    ELSE DO;
00056020      IF SUBSTR(OUTBUF.TEMPLINE,OFFSET1,RSIZE-CFACT)^=' '
00056030       THEN PUT FILE(SYSPRINT) EDIT(' '||SUBSTR(OUTBUF.TEMPLINE,OFFSET1,RSIZE-CFACT))
00056040          (COL(OUTBUF.COL),A);
00056050          ELSE BLANK='0'B;
00056060     END;
00056070    OBUF=OUTBUF.NEXT;
00056080    END;
00056090%SKIP;
00056100/*SEPERATE REPORT LINES ONLY IF THIS LINE IS NON BLANK*/
00056110%SKIP;
00056120    IF BLANK THEN PUT SKIP; ELSE;
00056130    OFFSET1=OFFSET1+(RSIZE-CFACT);
00056140    BLANK='1'B; /*TURN BLANKER BACK ON*/
00056150  END;
00056160   OFFSET=OFFSET+TITLES.LENGTH;
00056170%SKIP;
00056180%SKIP;
00056190END FOLD; 
00056200%PAGE; 
00056210NEWPAGE: PROC;
00056220%SKIP;
00056230PUT PAGE;
00056240CDATE=DATE;
00056250CTIME=TIME;
00056260PAGE#=PAGE#+1;
00056270PUT FILE(SYSPRINT) EDIT('REPORT SYSTEM', 'REPORT NUMBER:'||CHAR(REPORT#),
00056280        'DATE:'||DATEFORM(CDATE),'TIME:'||TIMEFORM(CTIME),'PAGE'||PAGE#) (COL(1),A,
00056290         COL(19),A,COL(40),A,COL(65),A,COL(115),A);
00056300%SKIP;
00056310/*PRINT OUT REPORT COMMAND FOR THIS REPORT*/
00056320%SKIP;
00056330PUT SKIP; /*SEPERATES REPORT HEADER FROM REPORT COMMAND*/
00056340PCMD=CMDLISTP;
00056350DO WHILE(PCMD^=NULL);
00056360  PUT FILE(SYSPRINT) EDIT(RPTCMD.COMMAND) (COL((LSIZE-INDEX(RPTCMD.COMMAND,'.'))/2),A) SKIP;
00056370  PCMD=NXTCMD;
00056380  END;
00056390PUT SKIP(2); /*SEPERATES REPORT COMMAND FROM REPORT*/
00056400END NEWPAGE;
00056410%PAGE;
00056420 LOGIC: PROC(STRING) RETURNS(BIT(1));
00056430    DCL STRING CHAR(*) VAR,OP CHAR(1);
00056440    DCL FOUND BIT(1),LOPOS FIXED BIN INIT(1),
00056450        HIPOS FIXED BIN INIT(LENGTH(STRING));
00056460    %SKIP(2);
00056470    IF STRING=' ' THEN RETURN(YES);
00056480    IF INDEX(STRING,'&') >0 THEN OP='&';
00056490       ELSE IF INDEX(STRING,'|') > 0 THEN OP='|';
00056500       ELSE IF INDEX(STRING,'^')>0 THEN DO; OP='^'; LOPOS=LOPOS+1; END;
00056510       ELSE OP=' ';
00056520      %SKIP(1);
00056530      DO WHILE(LOPOS<=LENGTH(STRING));
00056540         IF OP^=' ' THEN HIPOS=MYINDEX(SUBSTR(STRING,LOPOS),OP)-1;
00056550         FOUND=INDEX(SUBSTR(RECORD,SELECTORS.OFFSET,SELECTORS.LENGTH),
00056560                     SUBSTR(STRING,LOPOS,HIPOS))>0;
00056570         LOPOS=LOPOS+HIPOS+1;
00056580         IF OP=' ' THEN IF FOUND THEN RETURN(YES); ELSE RETURN(NO);
00056590                   ELSE IF OP='|' THEN IF FOUND THEN RETURN(YES);
00056600                                                ELSE ;
00056610                                  IF OP='&' THEN IF ^FOUND THEN RETURN(NO); ELSE;
00056620                                  ELSE IF FOUND THEN RETURN(NO);
00056630         END;
00056640    IF OP='&' THEN RETURN(YES);
00056650    ELSE IF OP^='^' THEN RETURN(NO);
00056660    ELSE RETURN(YES);
00056670   END LOGIC;
00056680%PAGE;
00056690DATEFORM: PROC(DATA) RETURNS(CHAR(8));
00056700%SKIP;
00056710  DCL DATA CHAR(6);
00056720  DCL (YR,DY,MN) CHAR(2);
00056730%SKIP;
00056740  YR=SUBSTR(DATA,1,2);
00056750  MN=SUBSTR(DATA,3,2);
00056760  DY=SUBSTR(DATA,5,2);
00056770  RETURN(MN||'/'||DY||'/'||YR);
00056780  END DATEFORM;
00056790%SKIP(4);
00056800TIMEFORM: PROC(DATA) RETURNS(CHAR(8));
00056810%SKIP;
00056820  DCL DATA CHAR(9);
00056830  DCL (HH,MM,SS) CHAR(2);
00056840%SKIP;
00056850  HH=SUBSTR(DATA,1,2);
00056860  MM=SUBSTR(DATA,3,2);
00056870  SS=SUBSTR(DATA,5,2);
00056880  RETURN(HH||':'||MM||':'||SS);
00056890  END TIMEFORM;
00056900%SKIP(3);
00056910DOALL: PROC;
00056920%SKIP;
00056930  DO I=1 TO DIM(FMLBL,1);
00056940    OFF=FMWHER(I);
00056950    LEN=FMLEN(I);
00056960    DATA=FMLBL(I);
00056970    CALL ADDTIT(OFF,LEN,DATA);
00056980    END;
00056990  END DOALL;
00057000%PAGE;
00057010 DATETEST: PROC(STRING) RETURNS(BIT(1));
00057020   DCL STRING CHAR(*) VAR;
00057030    DCL (DATE1,DATE2) CHAR(LENGTH(STRING)+2) VAR;
00057040    DCL DATA CHAR(SELECTORS.LENGTH+2) VAR;
00057050    DATE1=SUBSTR(STRING,1,INDEX(STRING,'-')-1);
00057060    DATE2=SUBSTR(STRING,INDEX(STRING,'-')+1);
00057070    DATA=SUBSTR(RECORD,SELECTORS.OFFSET,SELECTORS.LENGTH);
00057080    IF DATA=' ' THEN DO;
00057090      PUT SKIP LIST('BLANK DATE FIELD ENCOUNTERED IN FOLLOWING  DATA BASE RECORD, '||
00057100                    'PROCESSING WILL CONTINUE WITH NEXT RECORD');
00057110      PUT SKIP(1); /*SEPERATE MESSAGE FROM REPORT SEGMENT*/
00057120      PTIT=TITLISTP; /*WRITE OUT OFFENDING RECORD FOR LATER VERIFICATION*/
00057130      DO WHILE(PTIT^=NULL);
00057140        PUT SKIP LIST(TITLE||': '||SUBSTR(RECORD,TITLES.OFFSET,TITLES.LENGTH));
00057150        PTIT=NXTTIT;
00057160        END; PUT SKIP(3); /*SEPERATE REPORT SEGMENT FROM NEXT MESSAGE*/
00057170      RETURN(NO);
00057180      END;
00057190    CALL DATEVER(DATE1,RETCODE);
00057200    IF RETCODE>0 THEN GO TO BADDATE;
00057210    ELSE CALL DATEVER(DATE2,RETCODE);
00057220    IF RETCODE>0 THEN GO TO BADDATE;
00057230    ELSE CALL DATEVER(DATA,RETCODE);
00057240    IF RETCODE>0 THEN RETURN(NO);
00057250    RETURN(DATA>=DATE1 & DATA<=DATE2);
00057260    END DATETEST;
00057270%PAGE;
00057280/*LIST PROCESSING SUBROUTINES*/
00057290%SKIP(3);
00057300ADDHEAD: PROC;
00057310%SKIP;
00057320%SKIP;
00057330/*HEADBEG ALWAYS LOCATES BEGINNING OF LIST, IE, FIRST REPORT HEAD.
00057340AND PHEAD ALWAYS LOCATES THE NEWLY ALLOCATED REPORT HEAD WHILE OLDP
00057350ALWAYS LOCATES THE PREVIOUSLY GENERATED NODE*/
00057360%SKIP;
00057370OLDP=PHEAD;
00057380ALLOC HEAD;
00057390IF HEADBEG=NULL THEN
00057400 DO; /*DO IF THIS IS THE FIRST REPORT HEAD TO BE ALLOCATED*/
00057410    HEADBEG=PHEAD;
00057420    REPORT#=1;
00057430    NXTHEAD=NULL; /*DESIGNATE END OF LIST*/
00057440 END;
00057450 ELSE DO;
00057460    OLDP->NXTHEAD=PHEAD; /*LINK THE PREVIOUS HEAD TO THE NEWLY ALLOCATED HEAD*/
00057470    REPORT#=OLDP->REPORT#+1; /*BUMP REPORT NO., EACH NUMBER REPRESENTS A DIFFERENT REPORT*/
00057480    PHEAD->NXTHEAD=NULL; /*SIGNAL END OF LIST EACH TIME A CALL IS MADE*/
00057490 END;
00057500END ADDHEAD;
00057510%SKIP(3);
00057520ADDSEL: PROC(OFF,LEN,DATA);
00057530%SKIP;
00057540DCL (OFF,LEN) FIXED BIN;
00057550DCL DATA CHAR(*) VAR;
00057560%SKIP;
00057570OLDP=PSEL;
00057580K=LENGTH(DATA); /*DYNAMIC ALLOCATION*/
00057590ALLOC SELECTORS; /*PSEL ALWAYS LOCATES NEWLY ALLOCATED SELECTORS*/
00057600IF PHEAD->SELLISTP=NULL THEN
00057610 DO; /*DO IF THIS IS THE FIRST SELECTOR TO BE ALLOCATED*/
00057620    PHEAD->SELLISTP=PSEL; /*LINK FIRST SELECTOR TO REPORT HEAD*/
00057630    SELECTORS.OFFSET=OFF; /*OFFSET AND LENGTH IN DATA BASE REC OF CORRESPONDING SELECTOR*/
00057640    SELECTORS.LENGTH=LEN;
00057650     SELECTOR=DATA;
00057660     NXTSEL=NULL; /*DESIGNATE END OF SELECTOR SUBLIST*/
00057670 END;
00057680 ELSE DO; /*DO THIS IF NOT FIRST SELECTOR ELEMENT*/
00057690    OLDP->NXTSEL=PSEL; /*LINK PREVIOUS SELECTOR TO NEW SELECTOR NODE*/
00057700    SELECTORS.OFFSET=OFF;
00057710    SELECTORS.LENGTH=LEN;
00057720    SELECTOR=DATA;
00057730    NXTSEL=NULL;
00057740 END;
00057750END ADDSEL;
00057760%SKIP(3);
00057770ADDCMD: PROC(DATA);
00057780%SKIP;
00057790DCL DATA CHAR(*) VAR;
00057800%SKIP;
00057810OLDP=PCMD;
00057820ALLOC RPTCMD;
00057830IF PHEAD->CMDLISTP=NULL THEN DO;
00057840  PHEAD->CMDLISTP=PCMD;
00057850  RPTCMD.COMMAND=DATA;
00057860  NXTCMD=NULL;
00057870  END;
00057880ELSE DO;
00057890  OLDP->NXTCMD=PCMD;
00057900  RPTCMD.COMMAND=DATA;
00057910  NXTCMD=NULL;
00057920  END;
00057930END ADDCMD;
00057940%PAGE;
00057950%SKIP(3);
00057960ADDTIT: PROC(OFF,LEN,DATA);
00057970%SKIP;
00057980DCL (OFF,LEN) FIXED BIN,
00057990    DATA CHAR(*) VAR;
00058000%SKIP;
00058010OLDP=PTIT; /*SET TRAILING POINTER*/
00058020K=LENGTH(DATA); /*DYNAMIC ALLOCATION*/
00058030ALLOC TITLES;
00058040IF (PHEAD->TITLISTP=NULL)  THEN
00058050 DO;
00058060    PHEAD->TITLISTP=PTIT; /*LINK REPORT TITLE LIST TO HEAD LIST*/
00058070    TITLES.OFFSET=OFF;           /*OFFSET IN DBSE REC OF INFO ASSN/TITLE*/
00058080    TITLES.LENGTH=LEN;           /*LENGTH OF SAME*/
00058090    TITLE=DATA;              /*TITLE ASSOCIATED WITH ABOVE SUBFIELDS OF DATA BASE RECORD*/
00058100    NXTTIT=NULL;          /*DESIGNATE END OF LIST*/
00058110 END;
00058120 ELSE DO;                /*DO THIS IS NOT FIRST TIME THRU*/
00058130    OLDP->NXTTIT=PTIT;    /*LINK NODES OF REPRT LIST*/
00058140    TITLES.OFFSET=OFF;
00058150    TITLES.LENGTH=LEN;
00058160    TITLE=DATA;
00058170    NXTTIT=NULL;
00058180 END;
00058190END ADDTIT;
00058200%PAGE;
00058210BALLOC: PROC;  /*ALLOCATE REPORT BUFFERS FOR SUBSEQUENT PRINTING AND FORMATTING*/
00058220%SKIP;
00058230DCL (I,J,K) FIXED BIN;
00058240%SKIP;
00058250/*FIND THE MAXIMUM LINESIZE TO BE PRINTED FOR THIS REPORT*/
00058260%SKIP;
00058270/*MAKE SURE THAT RSIZE AND/OR RNUM DOES NOT CONFLICT WITH WITH LINE SIZE OF OUTPUT LISTING*/
00058280%SKIP;
00058290IF RSIZE>LSIZE|RNUM*RSIZE>LSIZE THEN GO TO BADCALC;
00058300%SKIP;
00058310IF RSIZE=0 & RNUM=0 THEN DO; /*DO IF NO SPECIFIED REPORT SIZE OR RNUM ON EXEC CARD*/
00058320   PTIT=TITLISTP;
00058330   I=0;
00058340   DO WHILE(PTIT^=NULL);
00058350       IF I<TITLEN+TITLES.LENGTH THEN I=TITLEN+TITLES.LENGTH;
00058360       PTIT=NXTTIT;
00058370       END;
00058380   K=I+3;
00058390   I=MAX(1,LSIZE/K);   /*GAURANTEE THAT AT LEAST ONE HOROZONTAL REPORT GETS PRINTED*/
00058400   END;
00058410IF RSIZE>0 & RNUM=0 THEN DO; /*REPORT SIZE WAS SPECIFIED ON EXEC CARD*/
00058420  K=RSIZE+3;
00058430  I=MAX(1,LSIZE/K);
00058440  END;
00058450IF RSIZE>0 & RNUM>0 THEN DO;
00058460  K=RSIZE+3;
00058470  I=RNUM;
00058480  END;
00058490%SKIP;
00058500/*NOW ALLOCATE AS MANY REPORT BUFFERS AS CAN BE FORMATTED ACROSS A PAGE OF OUTPUT*/
00058510%SKIP;
00058520P=ADDR(OBUFBEG);
00058530DO J=1 TO I;
00058540  ALLOC OUTBUF;
00058550  OUTBUF.COL=1+(LSIZE-I*K)/2+(J-1)*K; 
00058560  P->OUTBUF.NEXT,P=OBUF;
00058570  END;
00058580OUTBUF.NEXT=NULL;
00058590OBUF=OBUFBEG;
00058600END BALLOC;
00058610%SKIP(3);
00058620BFREE: PROC;
00058630%SKIP;
00058640DO WHILE(OBUFBEG^=NULL);
00058650  OBUF=OBUFBEG->OUTBUF.NEXT;
00058660  FREE OBUFBEG->OUTBUF;
00058670  OBUFBEG=OBUF;
00058680  END;
00058690END BFREE;
00058700%PAGE;
00058710%SKIP(2);
00058720%INCLUDE TAKEOUT;
00058730%SKIP(2);
00058740%INCLUDE MYINDEX;
00058750%PAGE;
00058760%INCLUDE DATEVER;
00058770%PAGE;
00058780/*ERROR EXITS*/
00058790%SKIP(2);
00058800NOINFO:
00058810  PUT FILE(CRT) SKIP LIST('NO INFOFIL DD CARD');
00058820  CALL PLIRETC(4);
00058830  RETURN;
00058840BADINFO:
00058850  PUT FILE(CRT) SKIP LIST('CHARCTER INFORMATION RECIEVED WHEN EXPECTING '||
00058860               'NUMBER IN INFORMATION FILE');
00058870  CALL PLIRETC(8);
00058880  RETURN;
00058890LACKINFO:
00058900  PUT FILE(CRT) SKIP LIST('END OF FILE ON INFORMATION FILE REACHED');
00058910  CALL PLIRETC(12);
00058920  RETURN;
00058930NODIRECT:
00058940  PUT FILE(CRT) SKIP LIST('NO DBASE DD CARD');
00058950  CALL PLIRETC(20);
00058960  RETURN;
00058970BADLRECL:
00058980  PUT FILE(CRT) SKIP LIST('IMPROPER RECORD LENGTH IN FILE DBASE');
00058990  CALL PLIRETC(24);
00059000SYSINBAD:
00059010  PUT FILE(CRT) SKIP LIST('SYSIN FILE DOES NOT CONSIST OF CARD IMAGES');
00059020  CALL PLIRETC(28);
00059030  RETURN;
00059040BADHEADER:
00059050 PUT FILE(CRT) SKIP LIST('INVALID TITLE FIELDS OF REPORT COMMAND');
00059060  CALL PLIRETC(36);
00059070  RETURN;
00059080NOSYSIN:
00059090  PUT FILE(CRT) SKIP LIST('NO SYSIN REPORT COMMANDS');
00059100  CALL PLIRETC(40);
00059110  RETURN;
00059120BADCOMMANDFIELD:
00059130  PUT FILE(CRT) SKIP LIST('REPORT COMMAND KEYWORD DOES NOT CORRESPOND TO ANY '||
00059140               'SUBFIELD OF DATA BASE RECORD, SEE INFO FILE '||
00059150               'FOR POSSIBLE KEYWORDS');
00059160  CALL PLIRETC(44);
00059170  RETURN;
00059180BADSORT:
00059190  PUT FILE(CRT) SKIP LIST('SORT FAILED WITH RETURN CODE OF '||SORTRETC);
00059200  CALL PLIRETC(48);
00059210  RETURN;
00059220BADDATE:
00059230  PUT FILE(CRT) SKIP LIST('INVALID DATE SPECIFICATION');
00059240  CALL PLIRETC(52);
00059250  RETURN;
00059260DONE:
00059270  CALL WRITEOUT; /*FLUSH OUT ANY REMAINING BUFFERS*/
00059280  CALL BFREE; /*AND FREE ANY BUFFERS*/
00059290  PUT SKIP(2) LIST('END REPORT');
00059300  PUT FILE(CRT) SKIP(2) LIST('END REPORT');
00059310  CALL PLIRETC(0);
00059320  RETURN;
00059330BADSORTCODE:
00059340  PUT FILE(CRT) SKIP LIST('UNDEFINED RETURN CODE OF '||SORTRETC);
00059350  CALL PLIRETC(56);
00059360  RETURN;
00059370NOPERIOD:
00059380  PUT FILE(CRT) SKIP LIST('REPORT COMMANDS CONTAIN NO DELIMITING PERIOD');
00059390  CALL PLIRETC(60);
00059400  RETURN;
00059410BADPAREN:
00059420  PUT FILE(CRT) SKIP LIST('INVALID USE OF PARENTHESES');
00059430  CALL PLIRETC(64);
00059440  RETURN;
00059450BADBY:
00059460  PUT FILE(CRT) SKIP LIST('INVALID USE OF THE ''BY'' KEYWORD');
00059470  CALL PLIRETC(68);
00059480  RETURN;
00059490BADCALC:
00059500   PUT FILE(CRT) SKIP LIST('INCOMPATIBILITY OF RSIZE AND/OR RNUM WITH LINE SIZE OF '||
00059510                          'OUTPUT LISTING');
00059520END REPORT;
