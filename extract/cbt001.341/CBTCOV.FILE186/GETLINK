00014550*PROCESS MACRO,INTERRUPT;
00014560 /* GETLINK:  PROC TO RECEIVE DATA FROM AN INTELLIGENT TERMINAL
00014570    AND WRITE IT OUT TO USER SELECTED TSO FILES */
00014580 GETLINK:  PROC (PARM) OPTIONS (MAIN);
00014590 /* 09/12/77  -  APB */
00014600 %SKIP;
00014610 /* THIS PROC IS TO BE USED AS A LINK TO TRINITY COLLEGE'S PDP-11 */
00014620 /* THE USER INVOKES THIS PROGRAM THROUGH A CLIST WHICH BUILDS THE
00014630    PARM STRING.  THE CLIST IS:  */
00014640 %SKIP;
00014650     /*
00014660     PROC 0 DA() USER(&SYSUID.) QUAL(CNTL) NUM(5) BATCH OLD -
00014670         RECFM('F B') LRECL(80) BLKSIZE(4240) SPACE('5 5') LOG(LINKLOG.DATA)
00014680     IF &DA=  THEN SET DSN=  <* BLANK OUT DSN *>
00014690     ELSE DO
00014700         <* ALLOCATE THE DATASET *>
00014710         SET DSN=&USER..&DA..&QUAL
00014720         IF &OLD=OLD THEN ALLOC F(TF1) DA('&DSN') OLD
00014730         ELSE DO
00014740             FREE ATTR(GLDSN)     <* FREE PREVIOUS USE *>
00014750             ATTRIB GLDSN RECFM(&RECFM) LRECL(&LRECL) BLKSIZE(&BLKSIZE)
00014760             ALLOC  F(TF1) DA('&DSN') USING(GLDSN) TRACKS SPACE(&SPACE)
00014770             END
00014780         END
00014790     ALLOC F(PLIDUMP)  SYSOUT(A)
00014800     ALLOC F(SYSPRINT) DA(&LOG) MOD
00014810     CALL LOADLIB(GETLINK) '/''&NUM'' ''&LRECL'' ''&RECFM'' ''&DSN'' ''&BATCH'''
00014820     <* TEST RETURN CODE *>
00014830     IF &LASTCC=0 THEN WRITE GETLINK COMPLETED SUCCESSFULLY
00014840     ELSE WRITE ERROR IN GETLINK, PLEASE REVIEW THE LOG FILE
00014850     ALLOC F(SYSPRINT) DA(*)     <* RESTORE SYSPRINT *>
00014860     FREE  F(PLIDUMP)
00014870     END
00014880     */
00014890 %SKIP;
00014900 /* THE FOLLOWING CLIST IS USED TO CREATE THE LOG DATASET:  */
00014910     /*
00014920     PROC 0 LOGNAME(LINKLOG.DATA)
00014930     <* CREATE LOG DATASET FOR GETLINK/PUTLINK *>
00014940     ATTRIB GETLOG DSORG(PS) RECFM(V B A) LRECL(85) BLKSIZE(4253)
00014950     ALLOC  DA(&LOGNAME) USING(GETLOG) SPACE(5 5) TRACKS
00014960     FREE   ATTR(GETLOG)
00014970     END
00014980     */
00014990 %SKIP;
00015000 /* NOTE THAT THE CLIST COMMENT DELIMETERS HAVE BEEN CHANGED */
00015010 %PAGE;
00015020 /* USER'S GUIDE: */
00015030     /*
00015040                                     GETLINK
00015050     FUNCTION:
00015060          GETLINK will get a data file from an intelligent terminal (in this
00015070     case Trinity's PDP-11) and transmit it to YCC's IBM-370.  The file can
00015080     be sent either to a 370 disk dataset, to the internal reader for batch
00015090     execution, or both.
00015100     
00015110     SYNTAX:
00015120          GETLINK DA() USER() QUAL() RECFM() LRECL() BLKSIZE() SPACE() OLD -
00015130                  LOG() NUM() BATCH
00015140     All parameters are keyword type, ie. there are no required operands.
00015150     Operands followed by a () are specified by name with a value in the
00015160     parentheses, the other operands are specified by name only.
00015170     
00015180     OPERANDS:
00015190          BATCH   - if specified, the file will be submitted as a batch job.
00015200          NUM     - block number:  the number of lines sent between
00015210                    acknowledgements, range 1 - 8, default - 5.
00015220          LOG     - the name of the dataset that logs the use of GETLINK,
00015230                    default - LINKLOG.DATA.  To initialize this dataset, enter:
00015240                    ATTRIB GETLOG DSORG(PS) RECFM(V B A) LRECL(85) BLKSIZE(4253)
00015250                    ALLOC  DA(&LOG) USING(GETLOG) SPACE(5 5) TRACKS
00015260     The remaining operands are used only when a dataset is being accessed.
00015270     Note that this is specified by using the DA operand (if DA is not
00015280     specified, the following operands will have no effect):
00015290          DA      - unqualified dataset name, no default.
00015300          USER    - userid, default is the userid of the current user.
00015310          QUAL    - dataset qualifier, default - CNTL.  Note that USER, DA, and
00015320                    QUAL are used to make the dataset name.
00015330          RECFM   - record format, syntax as in the TSO ATTRIBUTE command,
00015340                    except that the string must be enclosed by quotes,
00015350                    default - 'F B' (fixed blocked).
00015360          LRECL   - logical record length, syntax as in the TSO ATTRIBUTE
00015370                    command, default - 80.
00015380          BLKSIZE - block size, syntax as in the TSO ATTRIBUTE command,
00015390                    default - 4240.
00015400          SPACE   - primary and secondary allocation of tracks, syntax as
00015410                    in the TSO ALLOCATE command, except that the string must
00015420                    be enclosed by quotes, default - '5 5'.
00015430          OLD     - if specified, the dataset already exists and will be reused.
00015440     */
00015450 %PAGE;
00015460 /* INPUTS:  PARM - PARSED BY GET STRING INTO:
00015470    NBLK  -  CHAR (1),
00015480    LRECL -  CONVERTED TO FIXED BIN,
00015490    RECFM -  CHAR (5) VAR,
00015500    DSN   -  CHAR (44) VAR,
00015510    BCH   -  CHAR (10) VAR,
00015520    (SEE DECLARES BELOW FOR DESCRIPTIONS) */
00015530 %SKIP;
00015540 /* OUTPUTS:  THE LOG FILE, SYSPRINT, WHICH IS USED TO CONTAIN
00015550    PROGRAM INFORMATION AND ANY DIAGNOSTIC MESSAGES.  THIS FILE IS
00015560    NOT ALLOCATED TO THE TERMINAL SINCE IT WOULD DISRUPT THE LINE
00015570    PROTOCOL.  ANY OF THE THREE SUBROUTINES MAY WRITE TO SYSPRINT.
00015580    THIS FILE SERVES AS A LOG FOR THE USE OF THIS PROGRAM, EVERY TIME
00015590    GETLINK IS RUN THE NEW SESSION IS MOD-ED ONTO THE LOG DATASET. */
00015600 %SKIP;
00015610 /* ALGORITHM:
00015620    1) INITIALIZE LOG FILE.
00015630    2) PARSE PARMS.
00015640    3) CALL INITIALIZATION ROUTINES.
00015650    4) LOOP THROUGH PROCESSING ROUTINES WHILE PROTOCOL SIGNALS THAT
00015660       THERE IS STILL MORE DATA, OR UNTIL AN ASYNCHRONOUS ERROR OCCURS.
00015670    5) CALL FINALIZATION ROUTINES.
00015680    6) SET PROGRAM RETURN CODE.
00015690    7) FINALIZE LOG FILE. */
00015700 %SKIP;
00015710 /* THE PROGRAM HAS THREE BASIC SUBROUTINES:
00015720         FILE    - HANDLES THE TSO OUTPUT FILES
00015730         PROTCOL - HANDLES THE INPUT LINK PROTOCOL
00015740         TRANS   - HANDLES ANY REQUIRED DATA TRANSLATION
00015750    EACH OF THESE ROUTINES HAS AN INITIALIZATION AND FINALIZATION ENTRY.
00015760    SEE THE INDIVIDUAL ROUTINES FOR INPUTS, OUTPUTS AND ALGORITHMS. */
00015770 %PAGE;
00015780 /* GLOBAL VARIABLES: */
00015790 DCL PARM     CHAR(*) VAR;               /* EXECUTION PARAMETERS */
00015800 /* VARIABLES ASSIGNED BY GET STRING FROM PARM */
00015810 DCL NBLK     CHAR(1);                   /* # LINES BETWEEN ACKNOWLEDGMENTS,
00015820                                            (SEE PROTOCOL SECTION) */
00015830 DCL LRECL    FIXED BIN;                 /* RECORD LENGTH OF DATASET FILE */
00015840 DCL RECFM    CHAR(10) VAR;              /* RECORD FORMAT OF DATASET FILE */
00015850 DCL DSN      CHAR(44) VAR;              /* NAME OF THE DATASET, OR NULL
00015860                                            IF DATASET NOT REQUESTED */
00015870 DCL BCH      CHAR(5) VAR;               /* KEYWORD TO SPECIFY THE
00015880                                            INTERNAL READER */
00015890 %SKIP;
00015900 DCL BUF      CHAR(899) VAR;             /* BUFFER FOR ONE LINE OF DATA
00015910                                            NOTE - 899 IS PROTOCOL MAX SIZE
00015920                                            (SEE PROTOCOL SECTION) */
00015930 DCL RC       FIXED BIN INIT(0);         /* PROGRAM RETURN CODE */
00015940                                         /* RETURN CODES FROM PROTOCOL:
00015950                                            0  - MORE DATA TO COME
00015960                                            4  - ALL DATA RECEIVED
00015970                                            8  - ENDED DUE TO USER ERROR CODE
00015980                                            12 - ENDED DUE TO PERMANENT DATA ERROR */
00015990                                         /* ASYNCHRONOUS RETURN CODE:
00016000                                            16 - ENDED DUE TO ERROR CONDITION
00016010                                            NOTE THAT THIS CONDITION MAY OCCUR
00016020                                            AT ANY TIME DUE TO A DELIBERATE
00016030                                            SIGNAL STATEMENT, OR (HORRORS!)
00016040                                            A PROGRAM BUG. */
00016050 %INCLUDE BITDEF;
00016060 DCL DTYPE    BIT ALIGNED INIT(FALSE);   /* TRUE IF DATA IS PRINTABLE */
00016070 DCL NATTN    BIT ALIGNED INIT(FALSE);   /* TRUE AFTER ONE ATTN HAS BEEN STRUCK */
00016080 %PAGE;
00016090 DCL ADDR     BUILTIN;
00016100 DCL DATE     BUILTIN;
00016110 DCL INDEX    BUILTIN;
00016120 DCL LENGTH   BUILTIN;
00016130 DCL MIN      BUILTIN;
00016140 DCL ONCODE   BUILTIN;
00016150 DCL PLIRETC  BUILTIN;
00016160 DCL SUBSTR   BUILTIN;
00016170 DCL TIME     BUILTIN;
00016180 DCL UNSPEC   BUILTIN;
00016190 DCL VERIFY   BUILTIN;
00016200 %SKIP;
00016210 %INCLUDE SYSIO;
00016220 %INCLUDE DATEC;
00016230 %INCLUDE TIMEC;
00016240 %SKIP;
00016250 ON ERROR BEGIN;
00016260     ON ERROR SYSTEM;    /* WE DO NOT WANT TO RECURSE WITHIN THIS ON-UNIT */
00016270     IF (ONCODE ^= 9 /* SIGNAL ERROR */) THEN PUT FILE (SYSPRINT) SKIP EDIT
00016280         ('GETLINK ABORTING DUE TO PL/I ERROR CONDITION # ',ONCODE) (COL(5),A,F(5));
00016290     RC=16;      /* SET ASYNCHRONOUS ERROR RETURN CODE */
00016300     GO TO FIN;
00016310     END;
00016320 %SKIP;
00016330 ON ATTN BEGIN;
00016340     /* TWO ATTENTION INTERRUPTS WILL KILL GETLINK */
00016350     IF (NATTN) THEN DO;
00016360         PUT FILE (SYSPRINT) SKIP EDIT
00016370             ('GETLINK ABORTING DUE TO ATTENTION INTERRUPTS') (COL(5),A);
00016380         SIGNAL ERROR;
00016390         END;
00016400     NATTN=TRUE;
00016410     END;
00016420 %SKIP;
00016430 ON UNDEFINEDFILE (SYSPRINT) SIGNAL ERROR;
00016440 %PAGE;
00016450 /* EXECUTIVE ROUTINE */
00016460 OPEN FILE (SYSPRINT) LINESIZE (80);     /* 80 TO BE EASILY READ ON A CRT */
00016470 PUT FILE (SYSPRINT) PAGE EDIT
00016480     (DATEC,'GETLINK TO TRINITY COLLEGE',TIMEC) (COL(10),A,COL(27),A,COL(62),A);
00016490 PUT FILE (SYSPRINT) SKIP(2) EDIT
00016500     ('INPUT PARM:  ',PARM) (A,A);
00016510 GET STRING (PARM) LIST (NBLK, LRECL, RECFM, DSN, BCH);  /* GET PARMS */
00016520 %SKIP;
00016530 CALL FILEINI;
00016540 CALL PROTINI;
00016550 CALL TRANINI;
00016560 DO WHILE (RC = 0);
00016570     CALL TRANS;
00016580     CALL FILE;
00016590     CALL PROTCOL;
00016600     END;
00016610 FIN:
00016620 ON ERROR SYSTEM;    /* WE DO NOT WANT TO LOOP BETWEEN HERE AND ON-UNIT */
00016630 CALL TRANFIN;
00016640 CALL PROTFIN;
00016650 CALL FILEFIN;
00016660 %SKIP;
00016670 SELECT (RC);
00016680 /* NOTE - PLIRETC IS USED BY THE INVOKING CLIST TO DETERMINE PROPER ACTION */
00016690     WHEN (4) DO;    /* NORMAL END */
00016700         PUT FILE (SYSPRINT) SKIP(2) EDIT
00016710             ('GETLINK COMPLETED SUCCESSFULLY') (COL(25),A);
00016720         CALL PLIRETC(0);
00016730         END;
00016740     WHEN (8) DO;
00016750         PUT FILE (SYSPRINT) SKIP(2) EDIT
00016760             ('GETLINK ABORTING DUE TO USER REQUEST') (COL(5),A);
00016770         CALL PLIRETC(8);
00016780         END;
00016790     WHEN (12) DO;
00016800         PUT FILE (SYSPRINT) SKIP(2) EDIT
00016810             ('GETLINK ABORTING DUE TO PERMANENT DATA ERROR') (COL(5),A);
00016820         CALL PLIRETC(12);
00016830         END;
00016840     OTHERWISE CALL PLIRETC(16);     /* MESSAGE HAS ALREADY BEEN WRITTEN */
00016850     END;
00016860 %SKIP;
00016870 CLOSE FILE (SYSPRINT);
00016880 /* END OF EXECUTION */
00016890 %PAGE;
00016900 FILE:  PROC;        /* ROUTINE TO WRITE A BUFFER TO OUTPUT FILES */
00016910 /* THIS ROUTINE HANDLES THE TSO OUTPUT FILES.  THERE ARE TWO POSSIBLE
00016920    FILES, EITHER OF THE TWO, OR BOTH MAY BE USED.  THE FIRST FILE IS
00016930    A DISK DATASET THAT IS ALLOCATED IN THE CLIST (IF REQUESTED).  IT
00016940    MAY HAVE VARYING OR FIXED LENGTH RECORDS.  THE RECORD FORMAT AND
00016950    THE RECORD LENGTH OF THE DATASET ARE PASSED FROM THE CLIST THRU
00016960    THE INPUT PARM.  THE SECOND FILE IS THE INTERNAL READER
00016970    WHICH ALLOWS THE USER TO SUBMIT A JOB DIRECTLY TO JES.  THIS FILE
00016980    IS ALLOCATED DYNAMICALLY IF THE APPROPRIATE KEYWORD IS SELECTED IN
00016990    THE CLIST.  THIS FILE MUST BE FIXED WITH AN LRECL OF INTREC. */
00017000 %SKIP;
00017010 /* CONSTANTS */
00017020 %DCL INTREC   CHAR;                     /* LRECL FOR THE INTERNAL READER */
00017030 %INTREC='80';
00017040 %SKIP(2);
00017050 DCL TF1      EXT FILE STREAM OUTPUT;    /* THE DATASET FILE */
00017060 DCL TF2      EXT FILE STREAM OUTPUT ENV (F  RECSIZE(INTREC)  BLKSIZE(INTREC));
00017070                                         /* THE INTERNAL READER FILE */
00017080 %SKIP;
00017090 DCL 1 FILSTAT CTL,                      /* STATUS VARIABLES FOR FILE */
00017100         2 TFLG1    BIT ALIGNED,         /* TRUE IF DATASET REQUESTED */
00017110         2 TFLG2    BIT ALIGNED,         /* TRUE IF INTRDR  REQUESTED */
00017120         2 FIXT     BIT ALIGNED,         /* TRUE DATASET IS FIXED LENGTH */
00017130         2 INTRUNC  BIT ALIGNED,         /* TRUE IF AN INTRDR LINE GETS
00017140                                            TRUNCATED */
00017150         2 NREC     FIXED BIN INIT(0);   /* NUMBER OF OUTPUT RECORDS */
00017160 %SKIP(2);
00017170 /* NOTE - IF THE DATA LINE IS LONGER THAN THE DATASET OR INTRDR LRECL,
00017180    THE LINE WILL BE TRUNCATED TO THE CORRECT LRECL FOR EACH FILE.
00017190    ALSO, ANY DATA LINE SHORTER THAN A FIXED LENGTH FILE LRECL WILL BE PADDED
00017200    WITH BLANKS.  IF TRUNCATION OCCURS, THE USER WILL BE NOTIFIED VIA THE LOG
00017210    DATASET. */
00017220 %PAGE;
00017230 IF (TFLG1) THEN DO;     /* PUT BUFFER TO TSO DATASET */
00017240     IF (LENGTH(BUF) > LRECL) THEN DO;   /* WE WILL HAVE TO TRUNCATE */
00017250         IF (DTYPE) THEN PUT FILE (SYSPRINT) SKIP EDIT    /* PRINTABLE */
00017260             ('WARNING - LINE # ',NREC+1,' OF '||DSN||' TRUNCATED, THE LINE WAS:',
00017270              BUF) (A,F(7),A,A,A,SKIP,A);    /* DATA LINE WILL WRAPAROUND */
00017280         ELSE PUT FILE (SYSPRINT) SKIP EDIT      /* NON-PRINTABLE */
00017290             ('WARNING - LINE # ',NREC+1,' OF '||DSN||' TRUNCATED, THE LENGTH WAS:',
00017300             LENGTH(BUF)) (A,F(7),A,A,A,F(7));
00017310         END;
00017320     IF (FIXT) THEN PUT FILE (TF1) SKIP EDIT     /* FIXED LENGTH FILE */
00017330         (BUF) (A(LRECL));
00017340     ELSE PUT FILE (TF1) SKIP EDIT               /* VARYING LENGTH FILE */
00017350         (BUF) (A(MIN(LRECL,LENGTH(BUF))));
00017360     END;
00017370 %SKIP;
00017380 IF (TFLG2) THEN DO;     /* PUT BUFFER TO THE INTERNAL READER */
00017390     IF (LENGTH(BUF) > INTREC) THEN DO;  /* WE WILL HAVE TO TRUNCATE */
00017400         IF (DTYPE) THEN PUT FILE (SYSPRINT) SKIP EDIT    /* PRINTABLE */
00017410             ('WARNING - LINE # ',NREC+1,' TO INTERNAL READER TRUNCATED, ',
00017420              'THE LINE WAS:',BUF) (A,F(7),A,A,SKIP,A);   /* DATA LINE WILL WRAPAROUND */
00017430         ELSE PUT FILE (SYSPRINT) SKIP EDIT      /* NON-PRINTABLE */
00017440             ('WARNING - LINE # ',NREC+1,' TO INTERNAL READER TRUNCATED, ',
00017450              'THE LENGTH WAS:',LENGTH(BUF)) (A,F(7),A,A,F(7));
00017460         INTRUNC=TRUE;   /* JOB NOW HAS BAD DATA, SO IT MUST BE HELD */
00017470         END;
00017480     PUT FILE (TF2) SKIP EDIT
00017490         (BUF) (A(INTREC));
00017500     END;
00017510 %SKIP;
00017520 NREC=NREC+1;
00017530 %SKIP;
00017540 RETURN;
00017550 %PAGE;
00017560 FILEINI:  ENTRY;    /* INITIALIZE FILE RELATED VARIABLES AND OPEN FILES */
00017570 DCL IXF      FIXED BIN;
00017580 DCL IXV      FIXED BIN;
00017590 /* CONSTANTS */
00017600 %DCL BATCH CHAR;                        /* PARM SPECIFYING INTRDR */
00017610 %BATCH='''BATCH''';
00017620 %SKIP;
00017630 %INCLUDE DYNALLOC;
00017640 %SKIP(2);
00017650 /* INITIALIZE DATASET FILE */
00017660 ALLOCATE FILSTAT;
00017670 ON UNDEFINEDFILE (TF1) TFLG1=FALSE;
00017680 TFLG1=TRUE;                         /* ASSUME DATASET ALLOCATED */
00017690 OPEN FILE (TF1);                    /* FLAG WILL NOW BE SET PROPERLY */
00017700 IF (TFLG1) THEN DO;
00017710     PUT FILE (SYSPRINT) SKIP EDIT
00017720         (DSN,' OPENED FOR OUTPUT') (A,A);
00017730     /* DETERMINE IF DATASET IS FIXED LENGTH OR VARYING */
00017740     IXF=INDEX(RECFM,'F');
00017750     IXV=INDEX(RECFM,'V');
00017760     IF ((IXF > 0 & IXV > 0) | (IXF = 0 & IXV = 0)) THEN DO;
00017770         /* BOTH OR NEITHER OF FIXED AND VARYING SPECIFIED */
00017780         PUT FILE (SYSPRINT) SKIP EDIT
00017790             ('GETLINK ABORTING DUE TO ERROR IN INPUT PARM') (COL(5),A);
00017800         SIGNAL ERROR;
00017810         END;
00017820     IF (IXF > 0) THEN FIXT=TRUE;    /* FIXED LENGTH DATASET */
00017830     ELSE FIXT=FALSE;                /* VARYING LENGTH DATASET */
00017840     END;
00017850 ELSE IF (DSN^='') THEN DO;          /* ERROR IN ALLOCATION */
00017860     PUT FILE (SYSPRINT) SKIP EDIT
00017870         ('GETLINK ABORTING - ',DSN,' WAS NOT ALLOCATED') (COL(5),A,A,A);
00017880     SIGNAL ERROR;
00017890     END;
00017900 %PAGE;
00017910 /* INITIALIZE INTERNAL READER FILE */
00017920 IF (BCH = BATCH) THEN DO;
00017930     TFLG2=TRUE;
00017940     INTRUNC=FALSE;
00017950     DYNALLOC FILE (TF2) INTRDR FREE;    /* ALLOCATE THE INTERNAL READER */
00017960     /* IF DYNALLOC IS NOT SUCCESSFUL, IT WILL PUT A MESSAGE TO SYSPRINT
00017970        AND SIGNAL ERROR */
00017980     OPEN FILE (TF2);
00017990     PUT FILE (SYSPRINT) SKIP EDIT
00018000         ('INTERNAL READER OPENED FOR OUTPUT') (A);
00018010     END;
00018020 ELSE TFLG2=FALSE;
00018030 %SKIP(2);
00018040 IF (^(TFLG1 | TFLG2)) THEN DO;
00018050     PUT FILE (SYSPRINT) SKIP EDIT
00018060         ('GETLINK ABORTING - NO FILES ALLOCATED') (COL(5),A);
00018070     SIGNAL ERROR;
00018080     END;
00018090 %SKIP;
00018100 %DEACTIVATE DYNALLOC;
00018110 RETURN;
00018120 %PAGE;
00018130 FILEFIN:  ENTRY;    /* CLOSE FILES */
00018140 /* JCL TO PUT JOB IN HOLD QUEUE */
00018150 DCL HLDMSG1  CHAR (30) STATIC INIT('/*SETUP        PLEASE CONSULT ');
00018160 DCL HLDMSG2  CHAR (42) STATIC INIT(' BEFORE RELEASING THIS JOB');
00018170 DCL USER     CHAR (8);                  /* USERID OF THE CURRENT USER */
00018180 DCL GETUSER  EXT ENTRY (CHAR (8));      /* PROC TO GET USERID */
00018190 %SKIP;
00018200 IF (TFLG1) THEN CLOSE FILE (TF1);
00018210 IF (TFLG2) THEN DO;
00018220     IF (INTRUNC | RC > 4) THEN DO;
00018230         /* ERRORS HAVE OCCURED SO WE DO NOT WANT THE SUBMITTED JOB
00018240            TO GO INTO EXECUTION YET */
00018250         PUT FILE (SYSPRINT) SKIP EDIT
00018260             ('DUE TO TRANSMISSION OR TRUNCATION ERRORS, YOUR JOB IS BEING HELD',
00018270              'PLEASE INFORM THE OPERATOR IF HE SHOULD RUN OR CANCEL THE JOB')
00018280             (A,SKIP,A);
00018290         CALL GETUSER(USER);
00018300         PUT FILE (TF2) SKIP EDIT
00018310             (HLDMSG1||USER||HLDMSG2) (A(INTREC));
00018320         END;
00018330     CLOSE FILE (TF2);
00018340     END;
00018350 PUT FILE (SYSPRINT) SKIP EDIT
00018360     (NREC,' DATA LINE(S) SENT') (F(7),A);
00018370 FREE FILSTAT;
00018380 %SKIP;
00018390 RETURN;
00018400 %SKIP;
00018410 END FILE;
00018420 %PAGE;
00018430 PROTCOL:  PROC RECURSIVE;   /* PROTOCOL FOR 11/370 LINK */
00018440 /* THIS ROUTINE HANDLES THE LINE PROTOCOL.  INFORMATION IS SENT BI-DIRECTIONALLY
00018450    IN ONE OF TWO FORMATS:  (NOTE - THE RECEIVING END ONLY USES CONTROL FORMAT)
00018460    1) DATA FORMAT:
00018470       BLLLDDDD...DDDD
00018480       B - 1 BYTE BLOCK SEQUENCE NUMBER
00018490       L - 3 BYTE LENGTH CODE
00018500       D - DATA (LENGTH L-4)
00018510    2) CONTROL FORMAT:
00018520       B9CM
00018530       B - 1 BYTE BLOCK SEQUENCE NUMBER
00018540       9 - 1 BYTE, THE CHAR '9', WHICH SPECIFIES CONTROL
00018550       C - 1 BYTE CONTROL CODE
00018560       M - 1 BYTE CONTROL CODE MODIFIER
00018570    IN EITHER CASE THE FIRST FOUR BYTES MUST BE NUMERIC CHARACTERS. */
00018580 %SKIP;
00018590 /* EVERY LINE HAS A BLOCK SEQUENCE NUMBER RANGING FROM 1 TO 9 INCLUSIVE.
00018600    THESE ARE USED TO IDENTIFY ONE LINE FROM A BLOCK OF LINES.  THE
00018610    NUMBERS RUN IN ASCENDING WRAPAROUND SEQUENCE.  BOTH THE XMITTING AND
00018620    THE RECEIVING ENDS OF THE LINK HAVE SEPARATE BLOCK SEQUENCES.
00018630    THE XMITTING END (THE TERMINAL (THEM)) SENDS A BLOCK OF LINES AND THEN WAITS
00018640    FOR AN ACKNOWLEDGEMENT FROM THE RECEIVING END (THE IBM/370 (US)).  THERE
00018650    ARE NBLK (SPECIFIED IN THE CLIST) LINES SENT BETWEEN ACKNOWLEDGEMENTS.
00018660    THE ACKNOWLEDGEMENT CONSISTS OF THE ACKNOWLEDGEMENT CODE FOLLOWED BY
00018670    THE BLOCK SEQUENCE NUMBER OF THE LAST LINE CORRECTLY RECEIVED.  THIS
00018680    WAY THE XMITTING PROGRAM KNOWS WHICH LINE TO SEND NEXT (IE. IT CAN
00018690    RESEND ALL LINES FROM THE LAST LINE ACKNOWLEDGED IF THE SEQUENCE NUMBERS
00018700    DISAGREE. */
00018710 %SKIP;
00018720 /* INPUTS:  BUF - DATA STRING SENT FROM THE TERMINAL */
00018730 /* OUTPUTS: RC  - RETURN CODE
00018740                 = 0  - BUF HAS GOOD DATA
00018750                 = 4  - ALL DATA HAS BEEN RECEIVED
00018760                 = 8  - LINK IS ENDING DUE TO USER ERROR CODE
00018770                 = 12 - LINK IS ENDING DUE TO PERMANENT DATA ERROR */
00018780 %PAGE;
00018790 /* ALGORITHM:
00018800    1)  WE SEND THE READY TO RECEIVE CODE WITH NBLK AS THE CODE MODIFIER.
00018810    2)  WE GET NBLK DATA LINES AND SEND AN ACKNOWLEDGEMENT.
00018820    3)  IF THE LENGTH CODE IS INCORRECT OR A LINE IS OUT OF SEQUENCE WE WILL
00018830    THROW AWAY ALL LINES UNTIL NBLK LINES HAVE BEEN RECEIVED AND THEN
00018840    ACKNOWLEDGE THE LAST CORRECT LINE RECEIVED.  LINES ARE THROWN AWAY
00018850    BY NOT UPDATING RBLK SO THAT EVERY FOLLOWING LINE WILL BE OUT OF SEQUENCE.
00018860    THERE IS A MAXIMUM NUMBER OF LINES THAT MAY BE THROWN AWAY
00018870    CONSECUTIVELY.  THIS IMPLIES THAT A BAD DATA LINE WILL BE RETRIED
00018880    MAXTA/NBLK TIMES BEFORE IT IS CONSIDERED A PERMANENT DATA ERROR.
00018890    4)  (2 & 3) ARE REPEATED UNTIL THEY SEND AN END CONTROL CODE.  WE
00018900    THEN SEND AN ACKNOWLEDGEMENT.  IF ALL LINES WERE NOT RECEIVED
00018910    CORRECTLY IN THE LAST BLOCK THEY ARE RESENT FOLLOWED BY ANOTHER END CODE.
00018920    5)  (4) IS REPEATED UNTIL OUR ACKNOWLEDGEMENT IS FOLLOWED DIRECTLY BY
00018930    A SECOND END CODE (UNLESS MAXTA IS EXCEEDED, OF COURSE).
00018940    6)  WE SEND AN END CODE TO CLOSE THE LINK. */
00018950 %SKIP;
00018960 /* NOTE 1 - AT ANY TIME EITHER END MAY SEND THE ERROR CODE TO TERMINATE
00018970    THE LINK.
00018980    NOTE 2 - THE XMITTING PROGRAM HAS A TIMER RUNNING WHILE WAITING FOR
00018990    AN ACKNOWLEDGEMENT SO THAT AFTER A CERTAIN PERIOD OF TIME IT WILL
00019000    SEND GARBAGE LINES (IN CASE WHOLE LINES WERE LOST) IN ORDER TO FLUSH
00019010    AN ACKNOWLEDGEMENT.
00019020    NOTE 3 - SINCE A '9' IN BYTE TWO OF A LINE SPECIFIES CONTROL, 899 IS
00019030    THE MAXIMUM LINESIZE.  SINCE EACH LINE IS PREFIXED BY THE 4 BYTE CONTROL
00019040    SEQUENCE, THE MAXIMUM DATA LENGTH IS 895 BYTES.
00019050    NOTE 4 - IF THE FIRST LINE RECEIVED IS BAD THEN WE WILL ACKNOWLEDGE
00019060    '0' AS THE LAST LINE RECEIVED. */
00019070 %PAGE;
00019080 DCL 1 PROSTAT  CTL,                     /* STATUS VARIABLES FOR PROTCOL */
00019090         2 TOTAL    FIXED BIN INIT(0),   /* TOTAL # DATA LINES RECEIVED */
00019100         2 COUNT    FIXED BIN INIT(0),   /* # LINES IN CURRENT BLOCK */
00019110         2 ERRCNT   FIXED BIN INIT(0),   /* # LINES ORIGINALLY IN ERROR */
00019120         2 NTA      FIXED BIN INIT(0),   /* # LINES THROWN AWAY CONSECUTIVELY */
00019130         2 SBLK     CHAR (1) INIT('1'),  /* # OF LINE BEING SENT */
00019140         2 RBLK     CHAR (1) INIT('9'),  /* # OF LAST LINE RECEIVED CORRECTLY */
00019150                                         /* 1ST RBLK WE GET SHOULD BE '1' */
00019160         2 ENDSET   BIT ALIGNED INIT(FALSE), /* TRUE AFTER RECEIVING END CODE */
00019170         2 FIRST    BIT ALIGNED INIT(FALSE), /* TRUE AFTER 1ST LINE REC'D OK */
00019180         2 INIT     BIT ALIGNED INIT(FALSE); /* TRUE AFTER INITIALIZATION
00019190                                                CODE HAS BEEN PERFORMED */
00019200 %SKIP;
00019210 /* CONSTANTS */
00019220 %DCL CNTLEN   CHAR;                     /* LENGTH OF THE CONTROL FIELD
00019230                                            (ALSO THE MINIMUM LINE LENGTH) */
00019240 %CNTLEN='4';
00019250 %DCL MAXTA    CHAR;                     /* MAX # LINES TO THROW AWAY */
00019260 %MAXTA='80';                            /* INSURES AT LEAST 10 RETRIES/LINE */
00019270 %DCL NUMRALS  CHAR;                     /* NUMERIC CHARACTERS */
00019280 %NUMRALS='''0123456789''';
00019290 %DCL NUM9     CHAR;                     /* NUMERIC CHARACTERS 1-9 */
00019300 %NUM9='''123456789''';
00019310 /* CONTROL NUMBERS */
00019320 %DCL CNTL     CHAR;                     /* SPECIFIES CONTROL */
00019330 %CNTL='''9''';
00019340 %DCL ENDC     CHAR;                     /* END OF LINK CODE */
00019350 %ENDC='''9''';
00019360 %DCL ACK      CHAR;                     /* ACKNOWLEDGEMENT CODE */
00019370 %ACK='''8''';
00019380 %DCL ERR      CHAR;                     /* ERROR CODE */
00019390 %ERR='''5''';
00019400 %DCL XMT      CHAR;                     /* XMISSION SIDE MODIFIER */
00019410 %XMT='''2''';
00019420 %DCL REC      CHAR;                     /* RECEIVE SIDE MODIFIER */
00019430 %REC='''1''';
00019440 %DCL NUL      CHAR;                     /* NULL CODE */
00019450 %NUL='''0''';
00019460 %SKIP;
00019470 %INCLUDE TERMIO;
00019480 %PAGE;
00019490 %BADLINE:  PROC RETURNS (CHAR);     /* MACRO PROC TO INCLUDE THE FOLLOWING CODE */
00019500     RETURN('
00019510         DO;     /* CURRENT DATA LINE IS BAD */
00019520             IF (NTA = 0) THEN ERRCNT=ERRCNT+1; /* THIS LINE IS IN ERROR
00019530                 (UNTIL NTA IS RESET TO 0, ALL OTHER LINES PROCESSED HERE ARE
00019540                  EITHER THROWAWAYS OR RETRIES OF THIS LINE) */
00019550             NTA=NTA+1;
00019560             IF (NTA > MAXTA) THEN RC=12;       /* USER DATA MUST BE BOGUS */
00019570             ELSE DO;
00019580                IF (COUNT >= INDEX(NUM9,NBLK)) THEN CALL ACKNL;
00019590                CALL PROTCOL;
00019600                END;
00019610             END;
00019620     ');
00019630     %END BADLINE;
00019640 %ACTIVATE BADLINE;
00019650 %SKIP(3);
00019660 CALL TGET(BUF);
00019670 COUNT=COUNT+1;
00019680 %SKIP;
00019690 SELECT;
00019700     WHEN (LENGTH(BUF) < CNTLEN)
00019710         BADLINE         /* SHORT DATA LINE */
00019720 %SKIP;
00019730     WHEN (VERIFY(SUBSTR(BUF,1,CNTLEN),NUMRALS) ^= 0)
00019740         BADLINE         /* NON-NUMERIC CONTROL FIELD */
00019750 %SKIP;
00019760     WHEN (SUBSTR(BUF,1,1) ^= GETNXT(RBLK))
00019770         BADLINE         /* LINE OUT OF SEQUENCE OR WE ARE THROWING AWAY */
00019780 %PAGE;
00019790     WHEN (SUBSTR(BUF,2,1) = CNTL)
00019800         /* CONTROL MESSAGE */
00019810         SELECT (SUBSTR(BUF,3,1));
00019820             WHEN (ENDC) DO;
00019830                 IF (ENDSET) THEN RC=4;      /* ALL DATA RECEIVED */
00019840                 ELSE DO;
00019850                     ENDSET=TRUE;
00019860                     RBLK=SUBSTR(BUF,1,1);   /* UPDATE CORRECT LINE */
00019870                     CALL ACKNL;
00019880                     CALL PROTCOL;           /* GET 2ND END OR MORE DATA */
00019890                     END;
00019900                 END;
00019910             WHEN (ERR) DO;
00019920                 CALL ERROUT(XMT);
00019930                 RC=8;
00019940                 END;
00019950             OTHERWISE
00019960                 BADLINE         /* INVALID CONTROL CODE */
00019970             END;
00019980 %SKIP;
00019990     WHEN (SUBSTR(BUF,2,3) ^= LENGTH(BUF))
00020000         BADLINE         /* BAD LINE LENGTH */
00020010 %SKIP;
00020020     OTHERWISE DO;
00020030         /* GOOD DATA */
00020040         IF (^FIRST) THEN FIRST=TRUE;    /* 1ST LINE HAS BEEN REC'D OK */
00020050         IF (ENDSET) THEN ENDSET=FALSE;  /* THERE WAS MORE DATA */
00020060         NTA=0;                  /* CLEAR THROW-AWAY COUNT */
00020070         RBLK=SUBSTR(BUF,1,1);   /* UPDATE CORRECT LINE */
00020080         TOTAL=TOTAL+1;
00020090         BUF=SUBSTR(BUF,5);      /* STRIP OFF CONTROL CHARS */
00020100         IF (COUNT >= INDEX(NUM9,NBLK)) THEN CALL ACKNL;
00020110         RC=0;
00020120         END;
00020130     END;
00020140 %SKIP;
00020150 %DEACTIVATE BADLINE;
00020160 RETURN;
00020170 %PAGE;
00020180 PROTINI:  ENTRY;    /* OPEN LINK AND GET FIRST LINE */
00020190 IF ((VERIFY(NBLK,NUM9) ^= 0)  |     /* NON-NUMERIC CHARACTER (OR 0) */
00020200     (NBLK = SUBSTR(NUM9,LENGTH(NUM9),1)))
00020210     /* NBLK MUST BE ONE LESS THAN THE NUMBER OF BLOCK SEQUENCE NUMBERS
00020220        AVAILABLE, OTHERWISE THEY WOULD NOT BE ABLE TO DIFFERENTIATE BETWEEN
00020230        AN ACKNOWLEDGEMENT SPECIFYING THAT ALL LINES WERE RECEIVED AND
00020240        AN ACKNOWLEDGEMENT SPECIFYING THAT NO LINES WERE RECEIVED. */
00020250     THEN DO;
00020260         PUT FILE (SYSPRINT) SKIP EDIT
00020270             ('GETLINK ABORTING DUE TO INVALID BLOCK NUMBER') (COL(5),A);
00020280         SIGNAL ERROR;
00020290         END;
00020300 ALLOCATE PROSTAT;
00020310 CALL TPUT(SBLK||CNTL||REC||NBLK);   /* INITIALIZE */
00020320 INIT=TRUE;
00020330 CALL PROTCOL;
00020340 RETURN;
00020350 %SKIP(3);
00020360 PROTFIN:  ENTRY;    /* CLOSE LINK */
00020370 IF (INIT) THEN DO;  /* CLOSE LINK ONLY IF ALREADY OPEN */
00020380     IF (RC > 12) THEN CALL ERROUT(NUL);     /* ASYNCHRONOUS ERROR */
00020390     CALL ENDOUT(NUL);
00020400     PUT FILE (SYSPRINT) SKIP EDIT
00020410         (ERRCNT,' DATA LINE(S) REQUIRED RETRANSMISSION') (F(7),A);
00020420     PUT FILE (SYSPRINT) SKIP EDIT
00020430         (TOTAL,' DATA LINE(S) RECEIVED') (F(7),A);
00020440     END;
00020450 FREE PROSTAT;
00020460 RETURN;
00020470 %PAGE;
00020480 ACKNL:  PROC;   /* SEND ACKNOWLEDGEMENT */
00020490     SBLK=GETNXT(SBLK);
00020500     IF (FIRST) THEN CALL TPUT(SBLK||CNTL||ACK||RBLK);
00020510     ELSE CALL TPUT(SBLK||CNTL||ACK||NUL);   /* HAVE NOT REC'D 1ST LINE YET */
00020520     COUNT=0;
00020530     END ACKNL;
00020540 %SKIP(3);
00020550 ERROUT:  PROC (TYPE);   /* SEND ERROR MESSAGE */
00020560     DCL TYPE     CHAR (1);
00020570     SBLK=GETNXT(SBLK);
00020580     CALL TPUT(SBLK||CNTL||ERR||TYPE);
00020590     END ERROUT;
00020600 %SKIP(3);
00020610 ENDOUT:  PROC (TYPE);   /* SEND END CODE */
00020620     DCL TYPE     CHAR (1);
00020630     SBLK=GETNXT(SBLK);
00020640     CALL TPUT(SBLK||CNTL||ENDC||TYPE);
00020650     END ENDOUT;
00020660 %SKIP(3);
00020670 GETNXT:  PROC (PREV) RETURNS (CHAR (1));
00020680     /* GET THE NEXT NUMBER IN THE ASCENDING WRAPAROUND SEQUENCE 1 - 9 */
00020690     DCL PREV     CHAR (*);              /* PREVIOUS SEQUENCE NUMBER */
00020700     DCL NXT      CHAR (1);              /* NEXT SEQUENCE NUMBER */
00020710     DCL I        FIXED BIN;
00020720     I=INDEX(NUM9,PREV);
00020730     IF (I = 0) THEN DO;     /* ERROR IN SEQUENCE NUMBER */
00020740         PUT FILE (SYSPRINT) SKIP EDIT
00020750             ('GETLINK ABORTING DUE TO ERROR IN SEQUENCE NUMBERS') (COL(5),A);
00020760         SIGNAL ERROR;
00020770         END;
00020780     IF (I = 9) THEN I=1;
00020790     ELSE I=I+1;
00020800     NXT=SUBSTR(NUM9,I,1);
00020810     RETURN (NXT);
00020820     END GETNXT;
00020830 %SKIP;
00020840 END PROTCOL;
00020850 %PAGE;
00020860 TRANS:  PROC;       /* TRANSLATE DATA */
00020870 RETURN;             /* CURRENTLY A NULL ROUTINE */
00020880                     /* NOTE THAT TRANINI IS USED TO SET DTYPE */
00020890 /* ONE POSSIBLE USE WOULD BE TO DECODE BINARY DATA THAT WAS
00020900    ENCODED INTO PRINTABLE CHARACTERS TO BE SENT OVER TCAM */
00020910 %SKIP;
00020920 TRANINI:  ENTRY;
00020930 DTYPE=TRUE;         /* DATA IS PRINTABLE */
00020940 RETURN;
00020950 %SKIP;
00020960 TRANFIN:  ENTRY;
00020970 RETURN;
00020980 %SKIP;
00020990 END TRANS;
00021000 %PAGE;
00021010 END GETLINK;
