00021030 /* GPPP: GENERAL PURPROSE PRE-PROCESSOR (YALE)                      */
00021040 GPPP: PROC OPTIONS(MAIN);
00021050 /* PROC:     GPPP                                                   */
00021060 /* FUNCTION:    GENERAL PURPOSE PRE PROCESSOR                       */
00021070 /* VERSION:  DEC 5, 1977                                            */
00021080 /* AUTHOR:   HOWARD GILBERT  YALE COMPUTER CENTER                   */
00021090 /* ATTRIBUTES: NONE                                                 */
00021100 /* THIS IS A MAIN PROCEDURE.                                        */
00021110 /* INPUT IS FROM A CARD IMAGE DATASET ALLOCATED TO DDNAME SYSIN     */
00021120 /* PRINTOUT GOES TO SYSPRINT                                        */
00021130 /* THE GENERATED OUTPUT GOES TO DDNAME MDECKY                       */
00021140 /* INPUT SYNTAX IS DETERMINED BY THE ACCEPTABLE INPUT TO GETWORD    */
00021150 /*  AND THE MACROS AVAILABLE IN THE USER PROVIDED GRAMMARS.         */
00021160 /* EXTERNAL:    CALLS GETWORD DIRECTLY, AND THE GRAMMERS AND        */
00021170 /*    MACRO ENTRIES INDIRECTLY                                      */
00021180 /* MACROS:   REQUIRES THE GPPPTCA AND GPPPSYM MAPPING MACRO         */
00021190 %PAGE;
00021200 DCL SYSIN                        /* PRIMARY INPUT DATASET           */
00021210          INPUT RECORD            /*    CARD IMAGE                   */
00021220          ENV(FB RECSIZE(80));    /*                                 */
00021230 DCL SYSPUN                       /* PRIMARY OUTPUT DATASET          */
00021240          OUTPUT RECORD           /*                                 */
00021250          ENV(FB RECSIZE(80)      /*                                 */
00021260          BLKSIZE(4240));         /*                                 */
00021270 DCL CARD                         /* INPUT RECORD BUFFER             */
00021280          CHAR(80);               /*                                 */
00021290 DCL BUFF                         /* FULL TRACK BUFFER FOR SYSLIB    */
00021300         (162) CHAR(80);          /*   INPUT BLOCKS                  */
00021310 DCL INCL#                        /* DEPTH OF INCLUDED MEMBERS       */
00021320         FIXED BIN                /*                                 */
00021330         INIT(0);                 /*                                 */
00021340 DCL REC#                         /* LAST RECORD OFFSET IN BLOCK     */
00021350         FIXED BIN;               /*   TO DEBLOCK CARDS              */
00021360 DCL TTRSAVE(0:10)                /* REMEMBER TTR OF BLOCKS          */
00021370         FIXED BIN(31);           /*   WHERE INCL WAS INTERRUPTED    */
00021380 DCL RECSAVE(0:10)                /* REMEMBER REC# OF INCLUDE IN     */
00021390         FIXED BIN;               /*   INCLUDED MEMBER               */
00021400 DCL 1 SYSLBBLK,                  /* PARAMETER BLOCK FOR SYSLIBR     */
00021410         2 MEMBER CHAR(8)         /*   MEMBER NAME (REQMEM)          */
00021420              INIT(' '),          /*                                 */
00021430         2 TTR FIXED BIN(31),     /* TTR (REQREC)                    */
00021440         2 BUFFAD PTR             /* ADDR OF INPUT BUFFER            */
00021450              INIT((ADDR(BUFF))), /*                                 */
00021460         2 WORKAPTR PTR           /* WORK AREA USED BY SYSLIBR       */
00021470              INIT((NULL)),       /*   TO HOLD DCB & DECB            */
00021480         2 BUFFLEN FIXED BIN      /* LENGTH OF INPUT BUFFER          */
00021490              INIT(12960),        /*   SET TO FULL 3330 TRK          */
00021500         2 RECSIZE FIXED BIN,     /* RETURNED LENGTH OF INPUT        */
00021510         2 REQUEST BIT(8) ALIGNED,/* REQUEST TYPE,SEE BELOW          */
00021520         2 ERRORS  BIT(8) ALIGNED,/* ERROR FLAGS, SEE BELOW          */
00021530     REQMEM BIT(8) INIT('1000'B), /*  REQUEST NEW MEMBER             */
00021540     REQREC BIT(8) INIT('0100'B), /*  REQUEST TTR SEARCH             */
00021550     ERREOF BIT(8) INIT('1000'B), /*  END OF FILE                    */
00021560     ERRIO  BIT(8) INIT('0100'B), /*  IO ERROR (USUSED NOW)          */
00021570     ERROPN BIT(8) INIT('0010'B), /*  OPEN ERROR                     */
00021580     ERRMEM BIT(8) INIT('0001'B); /*  MEMBER NOT FOUND               */
00021590 DCL SYSLIBR ENTRY(*)             /* SYSLIB READER                   */
00021600         OPTIONS(ASM INTER);      /*                                 */
00021610 DCL STRING                       /* HOLDS COMPLETE MACRO STATEMENT  */
00021620          CHAR(256) VAR;          /*   FOR CALL TO MACCALL           */
00021630 DCL MAXRETC                      /* HIGHEST RETURN CODE FOR         */
00021640          FIXED BIN(31)           /*   JOB STEP COMPLETION           */
00021650          INIT(0);                /*                                 */
00021660 DCL CARDNUM                      /* CARD SEQUENCE NUMBER TO BE      */
00021670          PIC'99999999';          /*   INCREMENTED BY GEN            */
00021680 DCL SYMBOLSTORE                  /* BUFFER FOR SYMBOL TABLES        */
00021690          CHAR(32000);            /*                                 */
00021700 DCL MAXSTORE                     /* SIZE OF SYMBOLSTORE             */
00021710          FIXED BIN(31)           /*   TESTED BY SYMALLOC            */
00021720          INIT(32000);            /*                                 */
00021730 DCL MAXLEVEL                     /* DIMENSION OF LEVELPTR VECTOR    */
00021740          FIXED BIN               /*   TESTED BY PUSH                */
00021750          INIT(40);               /*                                 */
00021760 DCL STOREADDR                    /* CONVERTED VALUE OF SYMBOLSTORE  */
00021770          FIXED BIN(31);          /*   ADDRESS FOR PTR ARITHMETIC    */
00021780 DCL I                            /*                                 */
00021790          FIXED BIN;              /*                                 */
00021800 DCL (ADDR,                       /*                                 */
00021810      PLIRETC,                    /*                                 */
00021820      NULL,                       /*                                 */
00021830      MAX,                        /*                                 */
00021840      SUBSTR,                     /*                                 */
00021850      HBOUND)                     /*                                 */
00021860          BUILTIN;                /*                                 */
00021870 DCL PTRIN                        /* ENTRY TO PERMIT PTR ARITHMETIC  */
00021880          ENTRY(PTR)              /*   CONVERTS PTR TO NUMBER        */
00021890          RETURNS(FIXED BIN(31)); /*                                 */
00021900 DCL PTROUT                       /* INVERSE OF PTRIN, CONVERTS A    */
00021910          ENTRY(FIXED BIN(31))    /*   NUMBER TO A POINTER           */
00021920          RETURNS(PTR);           /*                                 */
00021930 DCL NULLPGM ENTRY;               /* IEFBR14-TYPE USED FOR TSO TEST  */
00021940 %PAGE;
00021950 % INCLUDE GPPPTCA;
00021960 %PAGE;
00021970 /*   THE SYMBOL TABLE IS STORED IN ARRAY SYMBOLSTORE. IT IS         */
00021980 /*   ORGANIZED AS:                                                  */
00021990 /*                                                                  */
00022000 /*          LEVELPTR(0) ->   ---------------                        */
00022010 /*                           |   LEVEL 0   |                        */
00022020 /*          LEVELPTR(1) ->   ---------------                        */
00022030 /*                           |   LEVEL 1   |                        */
00022040 /*                           |    . . .    |                        */
00022050 /*    LEVELPTR(LEVEL#)  ->   ---------------                        */
00022060 /*                           | CURRENTLEVEL|                        */
00022070 /*                           ---------------                        */
00022080 /*                           |UNUSED AREA  |                        */
00022090 /*   EACH LEVEL BEGINS WITH A MAJOR SYMBOL TABLE, THEN              */
00022100 /*   CONTAINS STORAGE FOR THE STATIC AND VARIABLE DATA AREAS        */
00022110 /*   FOR THE SYMBOLS USED AT THAT LEVEL.                            */
00022120 /*  THE VARIABLE AND STATIC DATA PARTS ARE CHAINED OFF THE          */
00022130 /*  SYMBOL TABLE ENTRY, AND EACH VARIABLE PART POINTS BACK          */
00022140 /*  THROUGH SYMPTR TO ITS ORIGINATING SYMBOL TABLE ENTRY.           */
00022150 /*   FOR CLEANUP AT EACH LEVEL, THERE IS A CHAIN FROM 'VARCHAIN'    */
00022160 /*  THROUGH EACH VARIABLE DATA ITEM AT THIS LEVEL USING THE         */
00022170 /*  'NEXTVAR' POINTER:                                              */
00022180 /*     (NULL)  <-  <VAR 1>  <-  ...  <- <VAR N-1> <- <VAR N>        */
00022190 /*                                                      |           */
00022200 /*     VARCHAIN -----------------------------------------           */
00022210 /*                (LEVEL CLEAN UP CHAIN)                            */
00022220 /*                                                                  */
00022230 /*   FOR EACH SYMBOL, ALL OF THE COPIES OF THE VARIABLE INFO        */
00022240 /*  AT EACH LEVEL ARE CHAINED UP USING THE 'BACKVAR' PTR.           */
00022250 /*   |SYMBOL TABLE ENTRY|          <STATIC> <VAR +0>                */
00022260 /*      VARPTR -------------                    |                   */
00022270 /*                          |                   |                   */
00022280 /*     INTERMEDIATE LEVEL   |               <VAR +I>                */
00022290 /*                          |                   |                   */
00022300 /*     CURRENT LEVEL        --------------> <VAR +N>                */
00022310 /*                  (VAR INFO GENERATION CHAIN)                     */
00022320 /*                                                                  */
00022330 /*   THERE IS ONE MAJOR SYMBOL TABLE AT THE BEGINNING OF            */
00022340 /*  THE DATA FOR ANY LEVEL, BUT IT IS POSSIBLE FOR ANY SYMBOL       */
00022350 /*  TO CONTAIN WITHIN ITS STATIC OR VARIABLE INFORMATION A          */
00022360 /*  SIMILARLY FORMATTED MINOR (SUB)SYMBOL TABLE AND ITS             */
00022370 /*  ENTRIES CAN ACQUIRE STATIC AND VARIABLE DATA AREAS. THE         */
00022380 /*  TABLE SCAN, SYMBOL ADD, AND LEVEL CLEANUP DO NOT                */
00022390 /*  DISTINGUISH MINOR TABLES AND THEIR VARIABLE AREAS FROM          */
00022400 /*  MAJOR SYMBOLS.                                                  */
00022410 %PAGE;
00022420 % INCLUDE GPPPSYM;
00022430 %PAGE;
00022440 ON ENDFILE(SYSIN) GO TO FINN;
00022450 ON ERROR CALL PLIDUMP('NF');
00022460 %SKIP;
00022470 GEN=GENNER;
00022480 NOTE=NOTER;
00022490 QUIT=QUITTER;
00022500 ERR=ERRER;
00022510 MACCALL=MCALLER;
00022520 PARSE=PARSER;
00022530 PUSH=PUSHER;
00022540 POP=POPPER;
00022550 FIND=FINDER;
00022560 SCAN=SCANNER;
00022570 NEWSYM=SYMADD;
00022580 CPYVAR=VARCPYER;
00022590 GRAMMAR=GRAMMER;
00022600 MACADD=MACADDER;
00022610 %SKIP;
00022620 CALL NULLPGM(GPPPTCA);
00022630 /*    TO ALLOW DEBUGGING USING THE TSO TEST COMMAND, WE NOW         */
00022640 /* CALL A DUMMY ENTRY POINT PASSING IT THE TCA ADDRESS. IF          */
00022650 /* YOU SET A BREAKPOINT AT .NULLPGM, YOU CAN USE THE TCA            */
00022660 /* ADDRESS TO SET BREAKPOINTS AT ANY INTERNAL PROCEDURE             */
00022670 /* ENTRY POINT, AND IF YOU REMEMBER THE TCA, YOU CAN INTERACTIVELY  */
00022680 /* INTERROGATE THE SYMBOL TABLE AND STATUS INFO                     */
00022690 %PAGE;
00022700 /* INITIALIZE THE SYMBOL TABLE INFO                                 */
00022710 PRINTON,PRINTGEN,GENON='1'B;
00022720 SYMBOLSTORE=LOW(32000);
00022730 LEVEL#=0;
00022740 SYMBOLTABPTR,LEVELPTR(0)=ADDR(SYMBOLSTORE);
00022750 STOREADDR=PTRIN(ADDR(SYMBOLSTORE));
00022760 VARCHAIN=NULL;
00022770 MAXKEYS=300;
00022780 USEDKEYS=0;
00022790 NEXTSTORE=STPREFIXLEN+300*ITEMLEN;
00022800 %SKIP;
00022810 SYMBOLPTR=NEWSYM('%GRAMMARS%',NAMELEN+STPREFIXLEN+20*ITEMLEN,12,NULL);
00022820 TYPENAME='%SYSTEM%';
00022830 SYMBOLTABPTR=ADDR(STATICTEXT);
00022840 VARCHAIN=NULL;
00022850 MAXKEYS=40;
00022860 USEDKEYS=0;
00022870 %SKIP;
00022880 SYMBOLPTR=NEWSYM('%MACROS%',NAMELEN+STPREFIXLEN+300*ITEMLEN,12,NULL);
00022890 TYPENAME='%SYSTEM%';
00022900 SYMBOLTABPTR=ADDR(STATICTEXT);
00022910 VARCHAIN=NULL;
00022920 MAXKEYS=300;
00022930 USEDKEYS=0;
00022940 I=MACADD('GRAMMAR',GRAMMARMAC);
00022950 I=MACADD('PRINT',PRINTMAC);
00022960 I=MACADD('INCLUDE',INCLDMAC);
00022970 %PAGE;
00022980 /* THIS IS THE BASIC READ LOOP. ITS FUNCTION IS TO                  */
00022990 /*   READ A CARD                                                    */
00023000 /*   SEE IF IT IS A MACRO                                           */
00023010 /*   IF NOT, REPRODUCE IT IN THE OUTPUT STREAM                      */
00023020 /*   OTHERWISE, PASS IT TO MACCALL FOR EXPANSION                    */
00023030 /* THE ERROR ROUTINES MAY PASS CONTROL BACK TO THE READLOOP         */
00023040 /* LABEL IF EXPANSION OF THE CURRENT STATEMENT CANNOT PROCEED       */
00023050 READLOOP:
00023060         IF INCL#=0 THEN
00023070              READ FILE(SYSIN) INTO(CARD);
00023080         ELSE
00023090              DO;
00023100              REC#=REC#+1;
00023110              IF REC#*80>RECSIZE THEN
00023120                   DO;
00023130                   REQUEST='0'B;
00023140                   CALL SYSLIBR(SYSLBBLK);
00023150                   IF ERRORS THEN
00023160                        DO;
00023170                        INCL#=INCL#-1;
00023180                        IF INCL#=0 THEN GO TO READLOOP;
00023190                        TTR=TTRSAVE(INCL#);
00023200                        REC#=RECSAVE(INCL#);
00023210                        REQUEST=REQREC;
00023220                        CALL SYSLIBR(SYSLBBLK);
00023230                        GO TO READLOOP;
00023240                        END;
00023250                   REC#=1;
00023260                   END;
00023270              CARD=BUFF(REC#);
00023280              END;
00023290         IF SUBSTR(CARD,1,1)^='%' THEN
00023300              DO;
00023310              IF PRINTON THEN
00023320               PUT FILE(SYSPRINT) EDIT(CARD)(COL(1),X(20),A(80));
00023330              WRITE FILE(SYSPUN) FROM(CARD);
00023340              GO TO READLOOP;
00023350              END;
00023360         STRING=SUBSTR(CARD,2,71);
00023370         CARDNUM=SUBSTR(CARD,73);
00023380         SUBSTR(CARD,1,3)='*/*';
00023390         SUBSTR(CARD,70,2)='*/';
00023400         IF PRINTON THEN
00023410               PUT FILE(SYSPRINT) EDIT(CARD)(COL(1),X(20),A(80));
00023420         WRITE FILE(SYSPUN) FROM(CARD);
00023430         CALL MACCALL(STRING);
00023440         GO TO READLOOP;
00023450 FINN:
00023460          CALL PLIRETC(MAXRETC);
00023470          RETURN;
00023480 %PAGE;
00023490 /* PROCEDURE:   GENNER                                              */
00023500 /* FUNCTION:    GENERATE ONE CARD IMAGE IN SYSPUNCH DATASET AND     */
00023510 /*              PRINT IT ON SYSPRINT UNDER CONTROL OF THE CURRENT   */
00023520 /*              'PRINT GEN' OPTION.                                 */
00023530 /* LINKAGE:     THIS ROUTINE IS KNOWN IN THE TCA UNDER THE ALIAS    */
00023540 /*              'GEN'. A MACRO LINKS BY                             */
00023550 /*                   CALL GEN(CARDIMAGE);                           */
00023560 /* EXTERNAL:    NONE                                                */
00023570 GENNER:PROC(OUTCARD);
00023580 DCL OUTCARD CHAR(80);
00023590 DCL MYCARD CHAR(80);
00023600         MYCARD=OUTCARD;
00023610         CARDNUM=CARDNUM+1;
00023620         SUBSTR(MYCARD,73)=CARDNUM;
00023630         IF PRINTON & PRINTGEN THEN
00023640               PUT FILE(SYSPRINT) EDIT(MYCARD)(COL(1),X(20),A(80));
00023650         WRITE FILE(SYSPUN) FROM(MYCARD);
00023660 END GENNER;
00023670 %PAGE;
00023680 /* PROCEDURE    NOTER                                               */
00023690 /* FUNCTION     GENERATE AN 'MNOTE' MESSAGE IN SYSPRINT DATASET     */
00023700 /* LINKAGE      THIS PROCEDURE IS KNOW IN THE TCA UNDER THE ALIAS   */
00023710 /*          'NOTE'. A MACRO CALLS IT BY                             */
00023720 /*             CALL NOTE(RETURNCODE,MESSAGE)                        */
00023730 /*          WHERE                                                   */
00023740 /*             RETURNCODE IS A FIXED BIN NUMBER WHICH IS COMPARED   */
00023750 /*             WITH THE CURRENT MAXIMUM RETURN CODE TO BE PASSED    */
00023760 /*             BACK WHEN THE JOBSTEP ENDS,                          */
00023770 /*             MESSAGE IS AN ERROR MESSAGE TO BE PRINTED ON THE     */
00023780 /*             OUTPUT                                               */
00023790 /* EXTERNAL     NONE                                                */
00023800 NOTER:PROC(RETC,MSG);
00023810 DCL RETC FIXED BIN;
00023820 DCL MSG CHAR(*) VAR;
00023830               PUT FILE(SYSPRINT) EDIT('*** NOTE  ',RETC,MSG)
00023840      (COL(1),A(11),F(4),COL(40),A);
00023850 MAXRETC=MAX(MAXRETC,RETC);
00023860 END NOTER;
00023870 %PAGE;
00023880 /* PROCEDURE    QUITTER                                             */
00023890 /* FUNCTION     TO TERMINATE THE CURRENT JOBSTEP IMMEDIATELY        */
00023900 /* LINKAGE      QUITTER IS KNOWN IN THE TCA UNDER THE ALIAS         */
00023910 /*             'QUIT'. A MACRO INVOKES IT BY                        */
00023920 /*                CALL QUIT;                                        */
00023930 /* EXTERNAL     NONE                                                */
00023940 /* EXIT         RETURNS TO THE TERMINATION LABEL OF THE MAIN        */
00023950 /* PROCEDURE                                                        */
00023960 QUITTER: PROC;
00023970 GO TO FINN;
00023980 END QUITTER;
00023990 %PAGE;
00024000 /* PROCEDURE    ERRER                                               */
00024010 /* FUNTION  SIGNALS AN ERROR IN THE INPUT                           */
00024020 /*          THIS ROUTINE WILL PRINT AN ERROR MESSAGE LINE,          */
00024030 /*             ONE STATEMENT FROM THE INPUT DECK                    */
00024040 /*             AND PUT A '$' UNDER THAT LINE AT THE CURRENT         */
00024050 /*             SCAN POSITION. IT IS INTENDED FOR SYNTAX             */
00024060 /*             ERRORS AND NOT FOR MACRO DETECTED ERRORS             */
00024070 /*             (SEE NOTER ABOVE).                                   */
00024080 /* LINKAGE      THIS ROUTINE IS KNOWN IN THE TCA AS 'ERR'.          */
00024090 /* EXTERNAL     NONE                                                */
00024100 /* EXIT         RETURNS TO THE READ LABEL OF THE MAIN PROCEDURE TO  */
00024110 /*            GET THE NEXT STATEMENT.                               */
00024120 ERRER: PROC(TEXT,STR,POSITION);
00024130 DCL TEXT CHAR(*) VAR;
00024140 DCL STR CHAR(*) VAR;
00024150 DCL POSITION FIXED BIN;
00024160               PUT FILE(SYSPRINT) EDIT('*** ERROR ',TEXT,STR,'$')
00024170     (COL(1),A,COL(20),A,COL(20),COL(19+POSITION),A(1));
00024180 MAXRETC=MAX(MAXRETC,12);
00024190 GO TO READLOOP;
00024200 END ERRER;
00024210 %PAGE;
00024220 /* PROCEDURE    MCALLER                                             */
00024230 /* FUNCTION     PERFORM AN INTERPRETIVE MACRO CALL                  */
00024240 /* LINKAGE      THIS PROCEDURE IS KNOWN IN THE TCA UNDER THE        */
00024250 /*             ALIAS 'MACCALL'. IT IS INVOKED BY                    */
00024260 /*               CALL MACCALL(STATEMENT);                           */
00024270 /*             WHERE STATEMENT IS A CHARACTER STRING CONTAINING A   */
00024280 /*             MACRO STATEMENT                                      */
00024290 /* EXTERNAL     CALLS THE MACRO ENTRY POINT WHICH IT FINDS          */
00024300 /*             IN THE SYMBOL TABLE.                                 */
00024310 /*             CALLS FIND,SCAN, AND GETWORD                         */
00024320 MCALLER:PROC(STRING) RECURSIVE;
00024330 DCL STRING CHAR(256) VAR;
00024340 DCL POSITION FIXED BIN;
00024350 DCL RETCODE FIXED BIN;
00024360 DCL ENTRYPT ENTRY VARIABLE BASED(ADDR(VARTEXT));
00024370 DCL NEXTWORD CHAR(256) VAR INIT('');
00024380 DCL MACNAME CHAR(12);
00024390 %INCLUDE GPPPSYM;
00024400 %SKIP;
00024410         POSITION=1;
00024420 MACN:
00024430         NEXTWORD=GETWORD(STRING,POSITION,RETCODE);
00024440         IF NEXTWORD='' THEN
00024450              CALL ERR('ERROR IN STATEMENT',STRING,POSITION);
00024460         IF SUBSTR(STRING,POSITION,1)=':' THEN
00024470              DO;
00024480              POSITION=POSITION+1;
00024490              GO TO MACN;
00024500              END;
00024510         SYMBOLPTR=SCAN('%MACROS%',LEVELPTR(0));
00024520         SYMBOLTABPTR=ADDR(STATICTEXT);
00024530         MACNAME=NEXTWORD;
00024540         SYMBOLPTR=SCAN(MACNAME,SYMBOLTABPTR);
00024550         IF SYMBOLPTR=NULL THEN
00024560              CALL ERR('VERB NOT FOUND',STRING,POSITION);
00024570         CALL ENTRYPT(STRING,GPPPTCA);
00024580 END MCALLER;
00024590 %PAGE;
00024600 /* PROCEDURE    PARSER                                              */
00024610 /* FUNCTION     TO PARSE A MACRO STATEMENT AND EXTRACT THE          */
00024620 /*          KEYWORDS AND POSITIONAL PARAMETERS.                     */
00024630 /* LINKAGE      THIS PROCEDURE IS KNOWN IN THE TCA UNDER THE        */
00024640 /*          ALIAS 'PARSE'. IT IS INVOKED BY                         */
00024650 /*             CALL PARSE(STATEMENT,PARMNAMES,PARMRETURN);          */
00024660 /*          WHERE STATEMENT IS A CHARACTER STRING CONTAINING A      */
00024670 /*          MACRO CALL STATEMENT.                                   */
00024680 /*          PARMNAMES IS AN ARRAY OF PARAMETER NAMES (IE. KEYWORDS) */
00024690 /*          PARMRETURN IS AN ARRAY (STARTING WITH DIMENSION 0)      */
00024700 /*          WHICH WILL RECEIVE THE VALUES OF THE POSITIONAL AND     */
00024710 /*          KEYWORD PARAMETERS. PARMRETURN(0) GETS THE VALUE        */
00024720 /*          OF THE MACRO STATEMENT LABEL. THIS ARRAY CAN BE         */
00024730 /*          INITIALIZED BY THE CALLER WITH DEFAULT VALUES.          */
00024740 /* EXTERNAL     CALLS GETWORD                                       */
00024750 /* EXIT         FOR SYNTAX ERROR, CALLS 'ERR' TO EXIT               */
00024760 PARSER:PROC(STRING,PARMNAMES,PARMS);
00024770 DCL STRING CHAR(256) VAR;
00024780 DCL POSITION FIXED BIN;
00024790 DCL RETCODE FIXED BIN;
00024800 DCL PARMS(*) CHAR(*) VAR;
00024810 DCL PARMNAMES(*) CHAR(12);
00024820 DCL (NEXTWORD,VALUE) CHAR(256) VAR INIT('');
00024830 DCL PARM# FIXED BIN;
00024840 DCL POSPARM FIXED BIN INIT(0);
00024850 DCL GOTAKEY BIT INIT('0'B);
00024860 %SKIP;
00024870         POSITION=1;
00024880 MACN:
00024890         NEXTWORD=GETWORD(STRING,POSITION,RETCODE);
00024900         IF SUBSTR(STRING,POSITION,1)=':'
00024910              THEN
00024920                   DO;
00024930                   PARMS(0)=NEXTWORD;
00024940                   POSITION=POSITION+1;
00024950                   GO TO MACN;
00024960                   END;
00024970 %SKIP;
00024980 PARMLOOP:
00024990         NEXTWORD=GETWORD(STRING,POSITION,RETCODE);
00025000         SELECT (RETCODE);
00025010              WHEN (16) CALL ERR('ERROR IN CARD, SCAN IS',
00025020                        STRING,POSITION);
00025030              WHEN (12) RETURN;
00025040              WHEN (8) RETURN;
00025050              WHEN (4)
00025060                   DO;
00025070                   GOTAKEY='1'B;
00025080                        DO PARM#=1 TO HBOUND(PARMS,1);
00025090                        IF NEXTWORD=PARMNAMES(PARM#)
00025100                             THEN GO TO GOTPARM;
00025110                        END;
00025120                   CALL ERR('UNRECOGNIZED KEYWORD',
00025130                        STRING,POSITION);
00025140 GOTPARM:
00025150                   VALUE=GETWORD(STRING,POSITION,RETCODE);
00025160                   PARMS(PARM#)=VALUE;
00025170                   END;
00025180              WHEN (2)
00025190                   DO;
00025200                   IF GOTAKEY THEN
00025210                        CALL ERR('IMPROPER POSITIONAL PARM',
00025220                             STRING,POSITION);
00025230                   POSPARM=POSPARM+1;
00025240                   IF POSPARM>HBOUND(PARMS,1) THEN
00025250                        CALL ERR('TOO MANY PARMS',STRING,POSITION);
00025260                   PARMS(POSPARM)=NEXTWORD;
00025270                   END;
00025280              WHEN (0)
00025290                   DO;
00025300                        DO PARM#=1 TO HBOUND(PARMS,1);
00025310                        IF NEXTWORD=PARMNAMES(PARM#)
00025320                             THEN
00025330                                  DO;
00025340                                  GOTAKEY='1'B;
00025350                                  PARMS(PARM#)='';
00025360                                  GO TO PARMLOOP;
00025370                                  END;
00025380                        END;
00025390                   IF GOTAKEY THEN
00025400                        CALL ERR('IMPROPER POSITIONAL PARM',
00025410                             STRING,POSITION);
00025420                   POSPARM=POSPARM+1;
00025430                   IF POSPARM>HBOUND(PARMS,1) THEN
00025440                        CALL ERR('TOO MANY PARMS',STRING,POSITION);
00025450                   PARMS(POSPARM)=NEXTWORD;
00025460                   END;
00025470         END;
00025480         GOTO PARMLOOP;
00025490 END PARSER;
00025500 %PAGE;
00025510 /* PROCEDURE    PUSHER                                              */
00025520 /* FUNCTION     PUSHES THE CURRENT SYMBOL TABLE LEVEL DOWN ONE      */
00025530 /* LINKAGE      KNOWN IN THE TCA UNDER THE ALIAS 'PUSH'.            */
00025540 /*             CALL PUSH(SYMBOLCOUNT);                              */
00025550 /*          WHERE SYMBOLCOUNT IS THE MAXIMUM NUMBER OF SYMBOLS      */
00025560 /*          IN THE MAJOR SYMBOL TABLE FOR THIS LEVEL.               */
00025570 /* EXTERNAL     NONE                                                */
00025580 PUSHER: PROC(SYMCOUNT);
00025590 DCL SYMCOUNT FIXED BIN;
00025600 %INCLUDE GPPPSYM;
00025610 IF LEVEL#>=MAXLEVEL THEN
00025620         CALL INTERR('STACK OVERFLOW');
00025630 SYMBOLTABPTR,LEVELPTR(LEVEL#+1)=
00025640          SYMALLOC(STPREFIXLEN+SYMCOUNT*ITEMLEN);
00025650 LEVEL#=LEVEL#+1;
00025660 VARCHAIN=NULL;
00025670 MAXKEYS=SYMCOUNT;
00025680 USEDKEYS=0;
00025690 END PUSHER;
00025700 %PAGE;
00025710 /* PROCEDURE    POPPER                                              */
00025720 /* FUNCTION     POPS THE CURRENT SYMBOL TABLE STACK                 */
00025730 /* LINKAGE      KNOWN IN THE TCA AS 'POP'                           */
00025740 /*             CALL POP;                                            */
00025750 POPPER: PROC;
00025760 DCL MYVARPTR PTR;
00025770 % INCLUDE GPPPSYM;
00025780 SYMBOLTABPTR=LEVELPTR(LEVEL#);
00025790 IF LEVEL#<0 THEN
00025800         CALL INTERR('STACK UNDERFLOW');
00025810         DO MYVARPTR=VARCHAIN REPEAT NEXTVAR UNTIL(MYVARPTR=NULL);
00025820         MYVARPTR -> SYMPTR -> VARPTR= MYVARPTR -> BACKVAR;
00025830         END;
00025840 NEXTSTORE=PTRIN(LEVELPTR(LEVEL#))-STOREADDR;
00025850 LEVEL#=LEVEL#-1;
00025860 END;
00025870 %PAGE;
00025880 /* PROCEDURE    FINDER                                              */
00025890 /* FUNCTION     SCAN ALL MAJOR SYMBOL TABLES STARTING AT THE        */
00025900 /*          CURRENT LEVEL FOR AN OCCURENCE OF THE NAMED SYMBOL      */
00025910 /* LINKAGE      KNOWN IN THE TCA UNDER THE ALIAS 'FIND'             */
00025920 /*       SYMBOLPTR= FIND(SYMBOLNAME);                               */
00025930 /* EXTERNAL     CALLS SCAN TO DO THE WORK                           */
00025940 FINDER: PROC(SYMNAME) RETURNS(PTR);
00025950 DCL I FIXED BIN;
00025960 DCL P PTR INIT(NULL);
00025970 DCL SYMNAME CHAR(12);
00025980         DO I=LEVEL# TO 0 BY -1 WHILE(P=NULL);
00025990         P=SCANNER(SYMNAME,LEVELPTR(I));
00026000         END;
00026010 RETURN(P);
00026020 END;
00026030 %PAGE;
00026040 /* PROCEDURE    SCANNER                                             */
00026050 /* FUNCTION     EXAMINE A SPECIFIED SYMBOL TABLE FOR                */
00026060 /*          A NAMED SYMBOL                                          */
00026070 /* LINKAGE      THIS ROUTINE IS KNOWN IN THE TCA UNDER THE          */
00026080 /*          ALIAS 'SCAN'.                                           */
00026090 /*              SYMBOLPTR= SCAN(SYMBOLNAME,SYMBOLTABLEPTR);         */
00026100 /* XTERNAL  NONE                                                    */
00026110 SCANNER: PROC(SYMNAME,SYMBOLTABPTR) RETURNS(PTR);
00026120 DCL SYMNAME CHAR(12);
00026130 DCL I FIXED BIN;
00026140 %INCLUDE GPPPSYM;
00026150         DO I=1 TO USEDKEYS;
00026160         SYMBOLPTR=ADDR(ITEM(I));
00026170         IF SYMNAME=KEY THEN RETURN(SYMBOLPTR);
00026180         END;
00026190 RETURN(NULL);
00026200 END;
00026210 %PAGE;
00026220 /* PROCEDURE    SYMADD                                              */
00026230 /* FUNCTION     ADD A NEW SYMBOL TO A SYMBOL TABLE                  */
00026240 /* LINKAGE      THIS PROCEDURE IS KNOWN UNDER THE ALIAS 'NEWSYM'    */
00026250 /*    SYMBOLPTR= NEWSYM(SYMBOLNAME,STATICAREASIZE,VARIABLEAREASIZE, */
00026260 /*              SYMBOLTABLEPTR);                                    */
00026270 /*          WHERE SYMBOLNAME IS THE NEW SYMBOL NAME                 */
00026280 /*          STATICAREASIZE IS THE SIZE OF ITS ASSOCIATED STATIC     */
00026290 /*          DATA AREA (MINIMUM SIZE IS 12).                         */
00026300 /*          VARIABLEAREASIZE IS THE SIZE OF THE ASSOCIATED VARIABLE */
00026310 /*          DATA AREA (MINIMUM SIZE IS 12).                         */
00026320 /*          SYMBOLTABLEPTR IS NULL() IF THE SYMBOL IS TO GO IN      */
00026330 /*          MAJOR SYMBOL TABLE AT THE CURRENT LEVEL, OR IS THE      */
00026340 /*          ADDRESS OF THE SYMBOL TABLE THE NEW ENTRY IS TO GO IN.  */
00026350 /* EXTERNAL     CALLS FIND AND SCAN                                 */
00026360 SYMADD: PROC(SYMNAME,STATSIZE,VARSIZE,STPTR)
00026370          RETURNS(PTR);
00026380 DCL SYMNAME CHAR(12);
00026390 DCL STATSIZE FIXED BIN;
00026400 DCL VARSIZE FIXED BIN;
00026410 DCL STPTR PTR;
00026420 %INCLUDE GPPPSYM;
00026430 IF STPTR^=NULL
00026440         THEN
00026450              SYMBOLTABPTR=STPTR;
00026460         ELSE
00026470              SYMBOLTABPTR=LEVELPTR(LEVEL#);
00026480 SYMBOLPTR=SCAN(SYMNAME,SYMBOLTABPTR);
00026490 IF SYMBOLPTR^=NULL
00026500         THEN RETURN(NULL);
00026510 IF USEDKEYS>=MAXKEYS THEN
00026520         CALL INTERR('TABLE OVERFLOW');
00026530 USEDKEYS=USEDKEYS+1;
00026540 SYMBOLPTR=ADDR(ITEM(USEDKEYS));
00026550 KEY=SYMNAME;
00026560 STATICLEN=MAX(STATSIZE,12);
00026570 VARLEN=MAX(VARSIZE,12);
00026580 STATICPTR=SYMALLOC(STATICLEN);
00026590 VARPTR=SYMALLOC(VARLEN);
00026600 SYMPTR=SYMBOLPTR;
00026610 NEXTVAR=VARCHAIN;
00026620 VARCHAIN=VARPTR;
00026630 BACKVAR=NULL;
00026640 RETURN(SYMBOLPTR);
00026650 END;
00026660 %PAGE;
00026670 /* PROCEDURE    SYMALLOC                                            */
00026680 /* FUNCTION     ALLOCATES STORAGE IN THE SYMBOL TABLE FOR SOME      */
00026690 /*          DATA AREA                                               */
00026700 /* LINKAGE      POINTER=SYMALLOC(AREASIZE)                          */
00026710 /* EXTERNAL     NONE                                                */
00026720 SYMALLOC: PROC(SIZE) RETURNS(PTR);
00026730 DCL SIZE FIXED BIN;
00026740 DCL P PTR;
00026750 P=PTROUT(STOREADDR+NEXTSTORE);
00026760 NEXTSTORE=NEXTSTORE+SIZE;
00026770 IF NEXTSTORE>MAXSTORE THEN
00026780         CALL INTERR('SYMBOL OVERFLOW');
00026790 RETURN(P);
00026800 END;
00026810 %PAGE;
00026820 /* PROCEDURE    INTERR                                              */
00026830 /* FUNCTION     PRINT AN INTERNAL ERROR MESSAGE ASSOCIATED          */
00026840 /*          WITH SOME TABLE OVERFLOW, ETC.                          */
00026850 /* LINKAGE      CALL INTERR(MESSAGE);                               */
00026860 /* EXTERNAL     NONE                                                */
00026870 /* EXIT         SIGNALS ERROR CONDITION AND TERMINATES PROCESSING   */
00026880 INTERR: PROC(MSG);
00026890 DCL MSG CHAR(*) VAR;
00026900          PUT FILE(SYSPRINT) EDIT('INTERNAL ERROR: ',MSG)(COL(1),A,A);
00026910 CALL NULLPGM(GPPPTCA);
00026920 SIGNAL ERROR;
00026930 END;
00026940 %PAGE;
00026950 /* PROCEDURE    VARCPYER                                            */
00026960 /* FUNCTION     PROVIDE A COPY OF THE CURRENT VARIABLE DATA         */
00026970 /*          ASSOCIATED WITH A SYMBOL TO THE CURRENT LEVEL FOR       */
00026980 /*          MODIFICATION BY THE MACRO.                              */
00026990 /* LINKAGE      THIS PROCEDURE IS KNOWN IN THE TCA UNDER THE        */
00027000 /*             ALIAS 'VARCPY'. THE CALL IS                          */
00027010 /*                CALL VARCPY(SYMBOLPTR);                           */
00027020 /*          WHERE SYMBOLPTR IS THE ADDRESS OF THE SYMBOLTABLE       */
00027030 /*          ENTRY FOR THE ITEM WHOSE DATA IS TO BE COPIED. IF       */
00027040 /*          A COPY EXISTS AT THE CURRENT LOGICAL LEVEL ALREADY,     */
00027050 /*          WE RETURN WITHOUT DOING ANYTHING.                       */
00027060 /*          OTHERWISE, STORAGE IS ALLOCATED AND THE APPROPRIATE     */
00027070 /*          CHAINS ARE UPDATED.                                     */
00027080 /* EXTERNAL     CALLS SYMALLOC                                      */
00027090 VARCPYER: PROC(SYMBOLPTR);
00027100 DCL P PTR;
00027110 %INCLUDE GPPPSYM;
00027120 SYMBOLTABPTR=LEVELPTR(LEVEL#);
00027130 IF PTRIN(VARPTR)>PTRIN(LEVELPTR(LEVEL#)) THEN RETURN;
00027140 P=SYMALLOC(VARLEN);
00027150 P -> BACKVAR = VARPTR;
00027160 VARPTR = P;
00027170 SYMPTR=SYMBOLPTR;
00027180 NEXTVAR=VARCHAIN;
00027190 VARCHAIN=P;
00027200 SUBSTR(VARTEXT,1,VARLEN-12)=SUBSTR(BACKVAR -> VARTEXT,1,VARLEN-12);
00027210 RETURN;
00027220 END;
00027230 %PAGE;
00027240 /* PROCEDURE    GRAMMER                                             */
00027250 /* FUNCTIONS    ADD A GRAMMER TO THE SYSTEM, AND LINK TO IT         */
00027260 /* LINKAGE      THIS ROUTINE IS KNOW IN THE TCA UNDER THE           */
00027270 /*              ALIAS 'GRAMMAR'. IT IS INVOKED BY                   */
00027280 /*                 CALL GRAMMAR(GRAMMARNAME);                       */
00027290 /* EXTERNAL     CALLS PLILOAD TO LOAD THE GRAMMAR MODULE,           */
00027300 /*              THEN BRANCHES TO ITS ENTRY POINT.                   */
00027310 GRAMMER: PROC(GRAMMARNAME);
00027320 DCL GRAMMARNAME CHAR(12);
00027330 DCL PLILOAD ENTRY(CHAR(8),ENTRY,FIXED BIN);
00027340 DCL RETC FIXED BIN;
00027350 DCL ENTRYPT ENTRY VARIABLE;
00027360 DCL ENTRYNAME CHAR(8);
00027370 % INCLUDE GPPPSYM;
00027380         ENTRYNAME=SUBSTR(GRAMMARNAME,1,8);
00027390         SYMBOLPTR=SCAN('%GRAMMARS%',LEVELPTR(0));
00027400         SYMBOLTABPTR=ADDR(STATICTEXT);
00027410         SYMBOLPTR=SCAN(GRAMMARNAME,SYMBOLTABPTR);
00027420         IF SYMBOLPTR ^= NULL THEN RETURN;
00027430         SYMBOLPTR=NEWSYM(GRAMMARNAME,12,12,SYMBOLTABPTR);
00027440         TYPENAME='GRAMMAR';
00027450         CALL PLILOAD(ENTRYNAME,ENTRYPT,RETC);
00027460         IF RETC>0 THEN
00027470              CALL INTERR('GRAMMER NOT IN LIB');
00027480         CALL ENTRYPT(GPPPTCA);
00027490 END;
00027500 %PAGE;
00027510 /* PROCEDURE    MACADDER                                            */
00027520 /* FUNCTION     ADD A MACRO NAME AND ENTRY POINT TO THE TABLE       */
00027530 /* LINKAGE      THIS ROUTINE IS KNOWN IN THE TCA UNDER THE          */
00027540 /*              ALIAS 'MACADD'. IT IS CALLED BY                     */
00027550 /*                   CALL MACADD(MACRONAME,MACROENTRY);             */
00027560 /* EXTERNAL     NONE                                                */
00027570 MACADDER: PROC(MACNAME,ENTRYPT) RETURNS(FIXED BIN);
00027580 DCL MACNAME CHAR(12);
00027590 DCL ENTRYPT ENTRY;
00027600 DCL ENTRYENTRY ENTRY BASED(ADDR(VARTEXT));
00027610 % INCLUDE GPPPSYM;
00027620         SYMBOLPTR=SCAN('%MACROS%',LEVELPTR(0));
00027630         SYMBOLTABPTR=ADDR(STATICTEXT);
00027640         SYMBOLPTR=SCAN(MACNAME,SYMBOLTABPTR);
00027650         IF SYMBOLPTR ^= NULL THEN RETURN(4);
00027660         SYMBOLPTR=NEWSYM(MACNAME,12,20,SYMBOLTABPTR);
00027670         TYPENAME='MACRO';
00027680         ENTRYENTRY=ENTRYPT;
00027690         RETURN(0);
00027700 END;
00027710 %PAGE;
00027720 /* PROCEDURE    GRAMMARMAC                                          */
00027730 /* FUNCTION     IMPLIMENTS THE 'GRAMMAR' MACRO STATEMENT            */
00027740 /* NOTE         THIS PROCEDURE CAN BE USED AS AN EXAMPLE OF         */
00027750 /*              A TYPICAL EXTERNAL MACRO PROCEDURE. IT              */
00027760 /*              PERFORMS ALL THE BASIC FUNTIONS OF A MACRO          */
00027770 /*                  1) DECLARE THE PARMNAMES AND PARM RETURN        */
00027780 /*                     VECTOR.                                      */
00027790 /*                  2) CALL PARSE TO ANALYZE THE MACRO STATEMENT.   */
00027800 /*                  3) CALL ONE OR MORE SYSTEM PRIMITIVES TO        */
00027810 /*                     GEN STATEMENTS, NOTE ERRORS, OR UPDATE       */
00027820 /*                     THE SYMBOL TABLE.                            */
00027830 /*              ALTHOUGH INTERNAL TO GPPP, IT IS WRITTEN AS IF      */
00027840 /*              IT WERE EXTERNAL. SEE ALSO 'PRINTMAC' BELOW.        */
00027850 GRAMMARMAC: PROC(STRING,GPPPTCA);
00027860 DCL STRING CHAR(256) VAR;
00027870 DCL PARMS(0:1) CHAR(72) VAR;
00027880 DCL PARMNAME(1) CHAR(12) INIT('GRAMMARNAME');
00027890 DCL GRAMMARNAME CHAR(12);
00027900 %INCLUDE GPPPTCA;
00027910 %INCLUDE GPPPSYM;
00027920 CALL PARSE(STRING,PARMNAME,PARMS);
00027930 GRAMMARNAME=PARMS(1);
00027940 CALL GRAMMAR(GRAMMARNAME);
00027950 END;
00027960 %PAGE;
00027970 /* PROCEDURE    PRINTMAC                                            */
00027980 /* FUNCTION     IMPLIMENTS THE PRINT MACRO COMMAND                  */
00027990 /* SYNTAX            PRINT (ON|OFF|GEN|NOGEN);                      */
00028000 PRINTMAC: PROC(STRING,GPPPTCA);
00028010 DCL STRING CHAR(256) VAR;
00028020 DCL PARMS(0:1) CHAR(72) VAR;
00028030 DCL PARMOPTION(1) CHAR(12) INIT('PRINTOPTION');
00028040 %INCLUDE GPPPTCA;
00028050 %INCLUDE GPPPSYM;
00028060 CALL PARSE(STRING,PARMOPTION,PARMS);
00028070 IF PARMS(1)='ON' THEN PRINTON='1'B;
00028080 ELSE IF PARMS(1)='OFF' THEN PRINTON='0'B;
00028090 ELSE IF PARMS(1)='GEN' THEN PRINTGEN='1'B;
00028100 ELSE IF PARMS(1)='NOGEN' THEN PRINTGEN='0'B;
00028110 ELSE CALL NOTE(8,'INVALID PRINT OPTION');
00028120 END;
00028130 %PAGE;
00028140 /* PROCEDURE    INCLDMAC                                            */
00028150 /* FUNCTION     IMPLIMENTS THE INCLUDE MACRO COMMAND                */
00028160 /* SYNTAX            INCLUDE MEMBERNAME                             */
00028170 INCLDMAC: PROC(STRING,GPPPTCA);
00028180 DCL STRING CHAR(256) VAR;
00028190 DCL PARMS(0:1) CHAR(72) VAR;
00028200 DCL PARMOPTION(1) CHAR(12) INIT('INCLDOPTION');
00028210 %INCLUDE GPPPTCA;
00028220 %INCLUDE GPPPSYM;
00028230 CALL PARSE(STRING,PARMOPTION,PARMS);
00028240 MEMBER=PARMS(1);
00028250 TTRSAVE(INCL#)=TTR;
00028260 RECSAVE(INCL#)=REC#;
00028270 INCL#=INCL#+1;
00028280 IF INCL#>10 THEN CALL INTERR('INCLUDE STACK');
00028290 REQUEST=REQMEM;
00028300 REC#=0;
00028310 CALL SYSLIBR(SYSLBBLK);
00028320 IF ERRORS&ERROPN THEN CALL INTERR('CANT OPEN SYSLIB');
00028330 IF ERRORS THEN
00028340         DO;
00028350         CALL NOTE(8,'INCLUDED MEMBER NOT FOUND');
00028360         INCL#=INCL#-1;
00028370         TTR=TTRSAVE(INCL#);
00028380         REC#=RECSAVE(INCL#);
00028390         REQUEST=REQREC;
00028400         CALL SYSLIBR(SYSLBBLK);
00028410         IF ERRORS THEN CALL INTERR('SYSLIB READ ERROR');
00028420         END;
00028430 END;
00028440 %PAGE;
00028450 /* PROCEDURE    GETWORD                                             */
00028460 /* FUNCTION     RETURN THE NEXT WORD OR SUBSTRING OF THE            */
00028470 /*              CURRENT MACRO STATEMENT.                            */
00028480 /* LINKAGE      NEXTWORD=GETWORD(STRING,POSITION,RETCODE);          */
00028490 /*              WHERE                                               */
00028500 /*              STRING IS A CHARACTER STRING CONTAINING A MACRO     */
00028510 /*              STATEMENT                                           */
00028520 /*              POSITION IS THE CHARACTER OFFSET IN STRING TO BEGIN */
00028530 /*              THE SYNTAX SCAN.                                    */
00028540 /*              NEXTWORD RECEIVES THE NEXT 'WORD' (DEFINED BELOW).  */
00028550 /*              RETCODE RECEIVES THE RETURN CODE.                   */
00028560 /* SYNTAX       A 'WORD' IS DELIMITED BY THE FOLLOWING:             */
00028570 /*              1) IF THE FIRST NON-BLANK CHARACTER IS '(', THEN    */
00028580 /*                 THE WORD ENDS WHEN A BALENCING ')' IS FOUND.     */
00028590 /*              2) IF IT STARTS WITH DOUBLE QUOTE '"', THEN THE     */
00028600 /*                 WORD ENDS WHEN ANOTHER DOUBLE QUOTE IS FOUND     */
00028610 /*                 WHICH IS NOT IMMEDIATELY FOLLOWED BY A SECOND    */
00028620 /*                 DOUBLE QUOTE. TWO ADJACENT DOUBLE QUOTES         */
00028630 /*                 PRODUCE ONE DOUBLE QUOTE IN THE RETURNED         */
00028640 /*                 STRING.                                          */
00028650 /*              3) IF A DOUBLE QUOTE IS FOUND IN PARENTHESES,       */
00028660 /*                 THEN THE SCAN PROCEEDS AS IN RULE 2) UNTIL       */
00028670 /*                 THE QUOTE ENDS, AND PARENTHESES IN THE QUOTE     */
00028680 /*                 ARE IGNORED, BUT AFTER THE QUOTE ENDS, THE       */
00028690 /*                 SCAN CONTINUES TILL THE PARENTHESES ARE MATCHED. */
00028700 /*              4) OTHERWISE (IE, THE FIRST CHAR IS A LETTER OR     */
00028710 /*                 DIGIT, ETC), THE SCAN PROCEEDS UNTIL ONE OF      */
00028720 /*                 FOUR CHARACTERS ARE FOUND: BLANK, COLON,         */
00028730 /*                 OPEN PARENTHESES, OR SEMICOLON.                  */
00028740 /*              THIS IS GOOD FOR PARSING STATEMENTS OF THE FORM     */
00028750 /*             LABEL: MACRONAME POSIT POSIT KEYWORD(VALUE) KEYWORD; */
00028760 /* RETURN       0 = WORD ENCOUNTERED (IE RULE 4 ABOVE)              */
00028770 /*              2 = OBJECT WAS IN () OR QUOTES                      */
00028780 /*              4 = OBJECT WAS WORD AND ENDED IN '('                */
00028790 /*              8 = OBJECT WAS ';'                                  */
00028800 /*              12= END OF STRING AND NO ';'                        */
00028810 /*              16= SYNTAX ERROR                                    */
00028820 GETWORD: PROC(STRING,POSITION,RETCODE) RETURNS(CHAR(256) VAR);
00028830 DCL STRING CHAR(*) VAR;
00028840 DCL POSITION FIXED BIN;
00028850 DCL RETCODE FIXED BIN;
00028860 DCL STRLEN FIXED BIN;
00028870 DCL RETSTR CHAR(256) VAR INIT('');
00028880 DCL PAREN FIXED BIN INIT(0);
00028890 DCL CH CHAR(1);
00028900 DCL I FIXED BIN;
00028910 DCL (LENGTH,SUBSTR) BUILTIN;
00028920         STRLEN=LENGTH(STRING);
00028930 %PAGE;
00028940 /* BLOCK: PREWORD                                                   */
00028950 /* FUNCTION: SKIPS BLANKS BEFORE A WORD                             */
00028960 /* ENTRY:                                                           */
00028970 /*    POSITION POINTS TO NEXT CHAR OR PAST END OF STRING            */
00028980 /* EXIT:                                                            */
00028990 /*    FALLS THROUGH TO NEXTSCAN WITH UPDATED POSITION               */
00029000 %SKIP;
00029010 PREWORD:
00029020              DO POSITION=POSITION TO STRLEN
00029030                   WHILE(SUBSTR(STRING,POSITION,1)=' ');
00029040              END;
00029050 %PAGE;
00029060 /* BLOCK: NEXTSCAN                                                  */
00029070 /* FUNCTION: DETERMINE WHAT IS NEXT                                 */
00029080 /* ENTRY:                                                           */
00029090 /*   POSITION POINTS TO NEXT NON-BLANK, OR PAST END OF STRING       */
00029100 /* EXIT:                                                            */
00029110 /*   GO THE THE RIGHT BLOCK DEPENDING ON THE NEXT CHAR              */
00029120 /*   CHAR   MEANING                                                 */
00029130 /*   ;      END OF STATEMENT                                        */
00029140 /*   (      PARENTHESIS VALUE                                       */
00029150 /*   "      QUOTED VALUE                                            */
00029160 /*   A-Z@$# KEYWORD OR POSITIONAL                                   */
00029170 /*   POSITION IS INCREMENTED FOR '(' OR '"'                         */
00029180 /*   IF WE ARE PAST END OF STRING ON ENTRY, RETURN '' RC=12         */
00029190 %SKIP;
00029200         RETCODE=12;
00029210         IF POSITION>STRLEN THEN RETURN('');
00029220 %SKIP;
00029230         RETCODE=16;
00029240         CH=SUBSTR(STRING,POSITION,1);
00029250         IF CH=';'
00029260              THEN
00029270                   DO;
00029280                   RETCODE=8;
00029290                   RETURN('');
00029300                   END;
00029310         IF CH='('
00029320              THEN
00029330                   DO;
00029340                   PAREN=1;
00029350                   POSITION=POSITION+1;
00029360                   GO TO PARENTHESES;
00029370                   END;
00029380         IF CH='"'
00029390              THEN
00029400                   DO;
00029410                   POSITION=POSITION+1;
00029420                   GO TO QUOTE;
00029430                   END;
00029440 %PAGE;
00029450 /* BLOCK: WORD                                                      */
00029460 /* FUNCTION: TO ANALYZE A KEYWORD OR POSITIONAL PARM NOT            */
00029470 /*     IN QUOTES                                                    */
00029480 /* ENTRY:                                                           */
00029490 /*     POSITION POINTS TO FIRST LETTER                              */
00029500 /* EXIT:                                                            */
00029510 /*     WHEN NEXT CHAR IS NOT ALPHAMERICNATIONAL,                    */
00029520 /*     RETURN INTERVENING CHARACTERS. IF NEXT CHAR                  */
00029530 /*     IS '(', SIGNAL KEYWORD BY RC=4                               */
00029540 %SKIP;
00029550 WORD:
00029560         RETSTR=CH;
00029570              DO POSITION=POSITION+1 TO STRLEN;
00029580              CH=SUBSTR(STRING,POSITION,1);
00029590              IF CH=' ' | CH=':' | CH='(' | CH=';'
00029600                   THEN
00029610                        GO TO ENDWORD;
00029620                   ELSE
00029630                        RETSTR=RETSTR||CH;
00029640              END;
00029650 ENDWORD:
00029660         RETCODE=0;
00029670         IF POSITION<=STRLEN
00029680              THEN
00029690                   IF CH='('
00029700                        THEN
00029710                             RETCODE=4;
00029720         RETURN(RETSTR);
00029730 %PAGE;
00029740 /* BLOCK: PARENTHESES                                               */
00029750 /* FUNCTION: PROCESS A VALUE STRING TILL PARENS MATCH.              */
00029760 /* ENTRY:                                                           */
00029770 /*   POSITION POINTS PAST FIRST PAREN                               */
00029780 /*   PAREN=1                                                        */
00029790 /* ENTRY ALSO FROM QUOTE WITH                                       */
00029800 /*   POSITION PAST "                                                */
00029810 /*   PAREN UNCHANGED                                                */
00029820 /* EXIT:                                                            */
00029830 /*   POSITION PAST CLOSING )                                        */
00029840 /*   IF A " IS HIT, GO TO QUOTE WITH PAREN>0                        */
00029850 %SKIP;
00029860 PARENTHESES:
00029870              DO POSITION=POSITION TO STRLEN;
00029880              CH=SUBSTR(STRING,POSITION,1);
00029890              IF CH='('
00029900                   THEN
00029910                        PAREN=PAREN+1;
00029920              IF CH=')'
00029930                   THEN
00029940                        DO;
00029950                        PAREN=PAREN-1;
00029960                        IF PAREN=0 THEN GO TO PAREND;
00029970                        END;
00029980              IF CH='"'
00029990                   THEN
00030000                        DO;
00030010                        POSITION=POSITION+1;
00030020                        GO TO QUOTE;
00030030                        END;
00030040              RETSTR=RETSTR||CH;
00030050              END;
00030060 PAREND:
00030070         POSITION=POSITION+1;
00030080         RETCODE=2;
00030090         RETURN(RETSTR);
00030100 %PAGE;
00030110 /* BLOCK: QUOTE                                                     */
00030120 /* FUNCTION: TO PROCESS QUOTED BLOCK                                */
00030130 /* ENTRY:                                                           */
00030140 /*   POSITION POINTS PAST OPENING "                                 */
00030150 /* EXIT:                                                            */
00030160 /*   COMPRESS "" TO A SINGLE "                                      */
00030170 /*   TERMINATE WHEN SINGLE " ENCOUNTERED                            */
00030180 %SKIP;
00030190 QUOTE:
00030200         DO POSITION=POSITION TO STRLEN;
00030210         CH=SUBSTR(STRING,POSITION,1);
00030220         IF CH='"'
00030230              THEN
00030240                   IF POSITION=STRLEN
00030250                        THEN
00030260                             GOTO ENDQUOTE;
00030270                        ELSE
00030280                             IF SUBSTR(STRING,POSITION+1,1)='"'
00030290                              THEN
00030300                               DO;
00030310                               RETSTR=RETSTR||'"';
00030320                               POSITION=POSITION+1;
00030330                               END;
00030340                              ELSE
00030350                               GOTO ENDQUOTE;
00030360              ELSE
00030370                   RETSTR=RETSTR||CH;
00030380         END;
00030390 ENDQUOTE:
00030400         IF POSITION>STRLEN
00030410              THEN
00030420                   DO;
00030430                   RETCODE=16;
00030440                   RETURN('');
00030450                   END;
00030460         POSITION=POSITION+1;
00030470         IF PAREN>0 THEN GO TO PARENTHESES;
00030480         RETCODE=2;
00030490         RETURN(RETSTR);
00030500 %SKIP;
00030510 END GETWORD;
00030520 END GPPP;
