         TITLE 'SAFECOPY - USER ENQUEUE THEN WRITE TO A DATASET'
**********************************************************************
***                                                                ***
***                      SAFECOPY COMMAND                          ***
***                                                                ***
***  GENERAL FUNCTION:                                             ***
***                                                                ***
***      THIS COMMAND ENQUEUES THE OUTPUT DATASET NAME, COPIES     ***
***      DATA FROM THE INPUT DATASET TO THE OUTPUT DATASET, THEN   ***
***      DEQUEUES THE NAME.  BY USING SAFECOPY, A USER DOES NOT    ***
***      HAVE TO WAIT FOR EXCLUSIVE CONTROL OF A DATASET BEFORE    ***
***      COPYING INTO IT.  THE USER WILL NOT CONFLICT WITH OTHERS  ***
***      READING THE DATASET, OR WITH OTHERS WHO ARE ALSO WRITING  ***
***      TO THE DATASET WITH SAFECOPY.                             ***
***                                                                ***
***      THE INPUT AND OUTPUT DATASETS CAN BE DESIGNATED BY        ***
***      DATASET NAME OR FILE NAME.  ADDITIONALLY, THE INPUT       ***
***      DATA CAN COME DIRECTLY FROM THE TIMESHARING TERMINAL      ***
***      OR FROM INSTREAM DATA IN A COMMAND LIST (CLIST).          ***
***                                                                ***
***                                                                ***
***  FORMAT:                                                       ***
***                                                                ***
***    SAFECOPY                                                    ***
***                                                                ***
***       FROMDSNAME(DSNAME×*)    TODSNAME(DSNAME)    OLD   NONUM  ***
***       FROMDATASET(DSNAME×*)   TODATASET(DSNAME)   MOD   NUM    ***
***       FROMDDNAME(DDNAME)      TODDNAME(DDNAME)                 ***
***       FROMFILE(DDNAME)        TOFILE(DDNAME)                   ***
***                                                                ***
***    REQUIRED:                                                   ***
***      1. FROMDSNAME/FROMDATASET OR FROMDDNAME/FROMFILE          ***
***      2. TODSNAME/TODATASET OR TODDNAME/TOFILE                  ***
***                                                                ***
***    DEFAULTS:                                                   ***
***      1. OLD                                                    ***
***      2. NONUM                                                  ***
***                                                                ***
**********************************************************************
         EJECT
**********************************************************************
***                                                                ***
***  RETURN CODES -                                                ***
***       00 - NORMAL COMPLETION                                   ***
***   NON-00 - CORRESPOND TO ERROR MESSAGES                        ***
***                                                                ***
***  REGISTER USAGE                                                ***
***                                                                ***
***      R0-R1 - MACROS, LINKAGE CONVENTIONS                       ***
***      R2-R3 - MACROS, WORK                                      ***
***      R4-R5 - WORK                                              ***
***         R6 - WORK, BASE FOR WORK2 FILE I/O AREA                ***
***         R7 - << NOT USED >>                                    ***
***         R8 - BASE FOR SECOND HALF OF PROGRAM (SEE R12)         ***
***         R9 - BASE FOR PARM DESCRIPTOR LIST CREATED BY PARSE    ***
***        R10 - BAL REGISTER                                      ***
***        R11 - BASE FOR WORK1 PROGRAM VARIABLES AREA             ***
***        R12 - BASE FOR FIRST HALF OF PROGRAM (SEE R8)           ***
***        R13 - BASE OF WORK0 AREA, REG SAVE AREA AND CODES       ***
***        R14 - MACROS, LINKAGE CONVENTIONS                       ***
***        R15 - MACROS, WORK, LINKAGE CONVENTIONS                 ***
***          +---------------------------------------------+       ***
***          ×  EXCEPT FOR BASE REGISTERS, DATA IS NEVER   ×       ***
***          ×  PASSED IN REGISTERS BETWEEN SUBSECTIONS OF ×       ***
***          ×  CODE.  IF YOU WRITE NEW ROUTINES TO WHICH  ×       ***
***          ×  YOU BAL USING R10, YOU ARE FREE TO USE     ×       ***
***          ×  R0-R5 WITHOUT SAVING AND RESTORING THEM.   ×       ***
***          +---------------------------------------------+       ***
***                                                                ***
***  NON-IBM MACROS USED:                                          ***
***     LINKSAVE - LINKAGE CONVENTIONS IN                          ***
***     EQ$R     - REGISTER EQUATES                                ***
***     LINKBACK - LINKAGE CONVENTIONS BACK                        ***
***     GTEDADAT - CREATE SVC-99 AND IKJEFF18 CONTROL BLOCKS       ***
***     GTEDASET - INITIALIZE AND LINK SVC-99 AND IKJEFF18 CONTROL ***
***                BLOCKS                                          ***
***     GTEDAALC - PERFORM DYNAMIC ALLOCATION AND DAIRFAIL         ***
***                ANALYSIS OF FAILURES                            ***
***                                                                ***
***  ASSEMBLER OPTIONS:       RENT                                 ***
***  LINKAGE EDITOR OPTIONS:  RENT, REUS, ALIAS(SAFEC)             ***
***                                                                ***
***  CULPRIT:                                                      ***
***     CHUCK HOFFMAN, SYSTEMS PROGRAMMING                         ***
***     GTE LABORATORIES                                           ***
***     TECHNICAL COMPUTATION CENTER                               ***
***     40 SYLVAN ROAD                                             ***
***     WALTHAM, MASSACHUSETTS  617/466-2131    V/N 679-2131       ***
***                                                                ***
***                                                                ***
**********************************************************************
         EJECT
**********************************************************************
***                                                                ***
***  MAINTENANCE HISTORY:                                          ***
***                                                                ***
***                                                                ***
***                                                                ***
***                                                                ***
***                                                                ***
***                                                                ***
***                                                                ***
***                                                                ***
***                                                                ***
***                                                                ***
***                                                                ***
***                                                                ***
***                                                                ***
***                                                                ***
***                                                                ***
***                                                                ***
***                                                                ***
***                                                                ***
***                                                                ***
***                                                                ***
***                                                                ***
***                                                                ***
***                                                                ***
***                                                                ***
***                                                                ***
***                                                                ***
***                                                                ***
***                                                                ***
**********************************************************************
         EJECT
**********************************************************************
***                                                                ***
***  PROGRAM LOGIC:                                                ***
***                                                                ***
***  SAFECOPY:  PERFORMS LINKAGE CONVENTIONS, GETS WORK SPACE,     ***
***             ASSIGNS BASE REGISTERS.                            ***
***                                                                ***
***  MAINLINE:  CONTROLS BALS TO SUBSECTIONS OF CODE.              ***
***                                                                ***
***    PPLSETUP:  CREATES PARSE PARAMETER LIST.                    ***
***                                                                ***
***    PARSE:     PARSES PARMS WITH IKJPARS.                       ***
***                                                                ***
***    IOPLSET:   CREATES THE IO PARM LIST, GETLINE PARM LIST,     ***
***               AND PUTLINE PARM LIST.                           ***
***                                                                ***
***    GETPARMS:  CONTROLS EXECUTION OF BALS TO SUBSECTIONS TO     ***
***               INITIALIZE PARM FIELDS.  ENSURES THAT DSNAMES    ***
***               ARE DIFFERENT FOR INPUT AND OUTPUT.              ***
***                                                                ***
***      DFNGET:    GETS THE DATASET NAME IF THE FROMDSN PARM      ***
***                 IS IN USE.  UNALLOCATES THE DATASET NAME, THEN ***
***                 ALLOCATES IT SHR AND SAVES THE DDNAME.  CHECKS ***
***                 FOR A NONBLANK MEMBER NAME IF THE DSORG IS PO  ***
***                 (UNLESS FROMDSN(*) IS IN USE).                 ***
***                                                                ***
***      DGET:      GETS THE DDNAME IF THE FROMDDNAME PARM         ***
***                 IS IN USE.  GETS THE DSNAME AND SAVES IT.      ***
***                 CHECKS FOR A NONBLANK MEMBER NAME IF THE       ***
***                 DSORG IS PO.                                   ***
***                                                                ***
***      DSNGET:    SAME AS DFNGET, BUT FOR OUTPUT DSNAME.         ***
***                 (*) IS NOT AN OPTION FOR OUTPUT.               ***
***                                                                ***
***      DDNGET:    SAME AS DGET, BUT FOR OUTPUT DDNAME.           ***
***                                                                ***
***    ENQUEUE:   ENQUEUES THE OUTPUT DATASET NAME USING MAJOR     ***
***               NAME 'USERDSN' AND MINOR NAME MATCHING THE DSN.  ***
***                                                                ***
***    OPENSETS:  OPENS THE INPUT DATASET.  OPENS THE OUTPUT       ***
***               DATASET.  CHECKS FOR INVALID USE OF 'MOD'        ***
***               IF OUTPUT DATASET IS PARTITIONED.                ***
***                                                                ***
***      SETCHK:    CHECKS FOR VALID COMBINATIONS OF INPUT AND     ***
***                 OUTPUT RECORD FORMATS.  SETS SWITCH BITS IN    ***
***                 SWITCH1 VARIABLE FOR LATER USE BY EDIT         ***
***                 SUBSECTION.                                    ***
***                                                                ***
***    COPY:      GETS WORK SPACE FOR FILE I/O.  AMOUNT IS THE     ***
***               LARGER BLOCKSIZE OF THE INPUT OR OUTPUT DATASET. ***
***               MINIMUM IS 320 BYTES.                            ***
***                                                                ***
***      GTREC:     GETS RECORD FROM QSAM FOR FILE INPUT, OR USES  ***
***                 GETLINE FOR TERMINAL/INSTREAM INPUT.  FOR      ***
***                 TERMINAL/INSTREAM, CHECKS FOR 'END' ENTRY      ***
***                 TO INDICATE TERMINATION OF INPUT.  IF SO,      ***
***                 BRANCHES TO EODAD POINT IN COPY SUBROUTINE.    ***
***                                                                ***
***      EDIT:      FORMATS OUTPUT LOGICAL RECORD FROM INPUT.      ***
***                 HANDLES DIFFERENCES IN RECORD FORMAT AND       ***
***                 LOGICAL RECORD LENGTHS.                        ***
***                                                                ***
***      PTREC:     PUTS A LOGICAL RECORD WITH QSAM.               ***
***                                                                ***
***                                                                ***
***    CLOSSETS:  BUILDS PARM LISTS AND CLOSES THE DATASETS.       ***
***                                                                ***
***    DEQUEUE:   DEQUEUES THE OUTPUT DATASET NAME.                ***
***                                                                ***
***  ENDING:    RELEASES SPACE USED BY PARM DESCRIPTOR LIST,       ***
***             AND WORK SPACE ACQUIRED BY PROGRAM.  SETS          ***
***             RETURN CODE.  FOLLOWS LINKAGE CONVENTIONS BACK     ***
***             TO CALLER.                                         ***
***                                                                ***
***  MSGPUT:    SELECTS MESSAGE ON THE BASIS OF INTERNAL RETCDE,   ***
***             USED AS AN INPUT ARGUMENT.  COMPLETES OUTPUT       ***
***             LINE DESCRIPTOR (O.L.D.) AND DISPLAYS THE MESSAGE  ***
***             WITH PUTLINE.                                      ***
***                                                                ***
**********************************************************************
         EJECT
         PRINT NOGEN
**********************************************************************
***                                                                ***
***   PROLOGUE                                                     ***
***                                                                ***
**********************************************************************
*
SAFECOPY LINKSAVE BASE=12,GETMAIN=YES
         EQ$R
         USING WORK0,R13                ADDRESSABILITY OF WORK0
         USING PARMPDL,R9               ADDRESSABILITY OF PRM DESC LST
         L     R8,AHALF2                R8 BASE FOR SECOND HALF OF PGM
         USING HALF2,R8
         ST    R1,CPPLPTR               SAVE CPPL POINTER
         GETMAIN  R,LV=WORK1LEN         GET MAIN STORAGE
         LR    R11,R1                   ADDRESS OF MAIN STORAGE
         USING WORK1,R11                ADDRESSABILITY OF WORK1
         XC    COMPCODE,COMPCODE        CLEAR PROGRAM RETURN CODE
         XC    RETCDE,RETCDE            CLEAR INTERNAL RETURN CODE
         B     MAINLINE
*
HALF2    EQU   SAFECOPY+4096
AHALF2   DC    A(HALF2)                 SECOND BASE ADDRESS
*
         EJECT
**********************************************************************
***                                                                ***
***   MAIN LINE ROUTINE                                            ***
***                                                                ***
**********************************************************************
*
MAINLINE BAL   R10,PPLSETUP             SET UP PARSE PARM LIST
         BAL   R10,PARSE                PARSE THE INPUT PARAMETERS
*
         BAL   R10,IOPLSET              SET UP IOPL AND GTPB
*
         BAL   R10,GETPARMS             GET AND CHECK PARMS
         CLC   RETCDE(4),DZIPS          IF RETCDE 0
         BE    *+14                       BRANCH AROUND
         MVC   COMPCODE(4),RETCDE       ELSE SET COMPLETION CODE
         B     ENDING                     AND BRANCH TO ENDING
*
         BAL   R10,ENQUEUE              PERFORM ENQUEUE
*
         BAL   R10,OPENSETS             OPEN THE DATASETS
         CLC   RETCDE(4),DZIPS          IF RETCDE 0
         BE    *+14                       BRANCH AROUND
         MVC   COMPCODE(4),RETCDE       ELSE SET COMPLETION CODE
         B     ENDING                     AND BRANCH TO ENDING
*
         BAL   R10,COPY                 COPY THE DATA
         CLC   RETCDE(4),DZIPS          IF RETCDE 0
         BE    *+14                       BRANCH AROUND
         MVC   COMPCODE(4),RETCDE       ELSE SET COMPLETION CODE
*
         BAL   R10,CLOSSETS             CLOSE THE DATASETS
*
         BAL   R10,DEQUEUE              PERFORM DEQUEUE
*
         B     ENDING                   BRANCH TO ENDING
         EJECT
**********************************************************************
***                                                                ***
***   EPILOGUE                                                     ***
***                                                                ***
**********************************************************************
ENDING   LA       R4,MYPPL+(PPLANS-PPL)   ADDRESS OF PTR TO PDL
         L        R4,0(0,R4)              R4 POINTS TO PDL
         IKJRLSA  (R4)                    FREE STORAGE OF PDL
*
         CLC      COMPCODE,DZIPS          IF COMPLETION CODE NOT ZERO
         BNE      *+14                      BRANCH AROUND
         XC       RETCDE,RETCDE           ELSE SET CODE=00 FOR MSG 00
         BAL      R10,MSGPUT                AND PUT OUT MESSAGE
*
         FREEMAIN R,LV=WORK1LEN,A=(R11) , FREE MAIN STORAGE
         LINKBACK RCADDR=COMPCODE
*
         EJECT
**********************************************************************
***                                                                ***
***        CREATE PARSE PARAMETER LIST                             ***
***                                                                ***
**********************************************************************
PPLSETUP ST    R10,PPR10SAV             SAVE RETURN ADDRESS
         XC    RETCDE,RETCDE            SET ERROR CODE TO ZERO
*
         L     R4,CPPLPTR               ADDRESS OF CMD PROC PARM LIST
         USING CPPL,R4                    ADDRESSABILITY
         MVC   MYPPL+(PPLUPT-PPL)(4),CPPLUPT              UPT  (CPPL)
         MVC   MYPPL+(PPLECT-PPL)(4),CPPLECT              ECT  (CPPL)
         LA    R5,MYECB
         ST    R5,MYPPL+(PPLECB-PPL)                      ECB  (MINE)
         MVC   MYPPL+(PPLPCL-PPL)(4),VPARMPCL             PCL  (CSECT)
         LA    R5,MYANS
         ST    R5,MYPPL+(PPLANS-PPL)                      ANS  (MINE)
         MVC   MYPPL+(PPLCBUF-PPL)(4),CPPLCBUF            CBUF (CPPL)
         XC    MYPPL+(PPLUWA-PPL)(4),MYPPL+(PPLUWA-PPL)   UWA  (MINE)
         DROP  R4
*
PPEND    L     R10,PPR10SAV             RESTORE RETURN ADDRESS
         BR    R10                      RETURN
         EJECT
**********************************************************************
***                                                                ***
***    PARSE THE INPUT PARAMETER STRING                            ***
***                                                                ***
**********************************************************************
PARSE    ST    R10,PAR10SAV             SAVE RETURN ADDRESS
         XC    RETCDE,RETCDE            SET ERROR CODE TO ZERO
*
         XC    MYECB,MYECB              ZERO THE ECB FOR PARSE
PARSEIT  CALLTSSR EP=IKJPARS,MF=(E,MYPPL)  PARSE THE PARMS
         L     R9,MYPPL+(PPLANS-PPL)    POINTER TO PDL ADDRESS
         L     R9,0(0,R9)               ADDRESSABILITY OF PDL
*
PAEND    L     R10,PAR10SAV             RESTORE RETURN ADDRESS
         BR    R10                      RETURN
         EJECT
**********************************************************************
***                                                                ***
***    SET UP THE INPUT OUTPUT PARM LIST.                          ***
***                                                                ***
***    IOPLIOPB, THE ADDR OF THE GETLINE/PUTLINE/PUTGET PARM       ***
***    BLOCK WILL BE FILLED IN BEFORE EACH GETLINE/PUTLINE/PUTGET. ***
***                                                                ***
***    INITIALIZE MY GETLINE PARM BLOCK.                           ***
***    INITIALIZE MY PUTLINE PARM BLOCK.                           ***
***    INITIALIZE MY OUTPUT LINE DESCRIPTOR BLOCK.                 ***
***                                                                ***
**********************************************************************
IOPLSET  ST    R10,IOR10SAV             SAVE RETURN ADDRESS
         XC    RETCDE,RETCDE            SET ERROR CODE TO ZERO
*
         L     R4,CPPLPTR               R4 POINTS TO CPPL
         USING CPPL,R4                  ADDRESSABILITY
         LA    R5,MYIOPL                R5 POINTS TO IOPL
         USING IOPL,R5                  ADDRESSABILITY
*
         MVC   IOPLUPT(4),CPPLUPT       GET ADDR OF UPT FROM CPPL
         MVC   IOPLECT(4),CPPLECT       GET ADDR OF ECT FROM CPPL
         LA    R6,MYECB                 ADDR OF MY ECB
         ST    R6,IOPLECB                 SET IN IOPL
         XC    IOPLIOPB(4),IOPLIOPB     CLEAR IOPB ADDRESS
*
         MVC   MYGTPB(8),GTPBPROT       INITIALIZE MY GTPB
*
         MVC   MYPTPB(12),PTPBPROT      INITIALIZE MY PTPB
*
         MVC   MYOLD(8),OLDPROT         INITIALIZE MY OLD
*
IOEND    L     R10,IOR10SAV             RESTORE RETURN ADDRESS
         BR    R10                      RETURN
*
         DROP  R4
         DROP  R5
*
         EJECT
**********************************************************************
***                                                                ***
***    GET AND ANALYZE THE PARMS                                   ***
***                                                                ***
**********************************************************************
GETPARMS ST    R10,GER10SAV             SAVE RETURN ADDRESS
         XC    RETCDE,RETCDE            SET ERROR CODE TO ZERO
*
GECKFDSN CLC   KFROMDSN(2),DZIPS        IF FROMDSNAME OPRND NOT IN USE
         BE    GECKFDDN                   GO TO CHECK FOR FROMDDNAME
         BAL   R10,DFNGET               ELSE PERFORM DSN GET/ALLOCATE
         CLC   RETCDE,DZIPS             IF RETURN NOT 0
         BNE   GEEND                      GO TO ENDING
         B     GECKTDSN                 GO TO CHECK FOR TODSNAME
*
GECKFDDN CLC   KFROMDDN(2),DZIPS        IF FROMDDNAME OPRND NOT IN USE
         BE    GEERR18                    BRANCH TO ERROR 18
         BAL   R10,DGET                 ELSE PERFORM FROMDDNAME GET
         CLC   RETCDE,DZIPS             IF RETURN NOT 0
         BNE   GEEND                      GO TO ENDING
         B     GECKTDSN                 GO TO CHECK FOR TODSNAME
*
GECKTDSN CLC   KTODSN(2),DZIPS          IF TODSNAME OPERAND NOT IN USE
         BE    GECKTDDN                   GO TO CHECK FOR TODDNAME
         BAL   R10,DSNGET               ELSE PERFORM DSN GET/ALLOCATE
         CLC   RETCDE,DZIPS             IF RETURN NOT 0
         BNE   GEEND                      GO TO ENDING
         B     GECKDIFF                 ELSE GO TO NEXT CHECK
*
GECKTDDN CLC   KTODDN(2),DZIPS          IF TODDNAME OPERAND NOT IN USE
         BE    GEERR04                    BRANCH TO ERROR 04
         BAL   R10,DDNGET               ELSE PERFORM TODDNAME GET
         CLC   RETCDE,DZIPS             IF RETURN NOT 0
         BNE   GEEND                      GO TO ENDING
         B     GECKDIFF                 ELSE GO TO NEXT CHECK
*
GECKDIFF LH    R4,RLEN2                 INPUT DSN LENGTH TO R4
         CH    R4,RLEN1                 COMPARE WITH OUTPUT LENGTH
         BNE   GEEND                      IF DIFFERENT, GO TO ENDING
         BCTR  R4,0                     R4 -1 FOR EXEC
         B     *+10                     BRANCH AROUND EXECUTED INSTR
         CLC   RNAM2(0),RNAM1             COMPARE DATASET NAMES
         EX    R4,*-6                   EXECUTE THE COMPARE
         BE    GEERR44                  IF NAMES ARE SAME, GO TO ERROR
         B     GEEND                      ELSE GO TO ENDING
*
GEERR04  LA    R15,X'04'(0,0)           CONSTANT TO R15
         ST    R15,RETCDE               SET INTERNAL RETURN CODE
         BAL   R10,MSGPUT               PUT OUT ERROR MESSAGE
         B     GEEND                    GO TO END OF ROUTINE
*
GEERR18  LA    R15,X'18'(0,0)           CONSTANT TO R15
         ST    R15,RETCDE               SET INTERNAL RETURN CODE
         BAL   R10,MSGPUT               PUT OUT ERROR MESSAGE
         B     GEEND                    GO TO END OF ROUTINE
*
GEERR44  LA    R15,X'44'(0,0)           CONSTANT TO R15
         ST    R15,RETCDE               SET INTERNAL RETURN CODE
         BAL   R10,MSGPUT               PUT OUT ERROR MESSAGE
         B     GEEND                    GO TO END OF ROUTINE
*
GEEND    L     R10,GER10SAV             RESTORE RETURN ADDRESS
         BR    R10                      RETURN
         EJECT
**********************************************************************
***                                                                ***
***    GET/ALLOCATE FROMDSNAME                                     ***
***                                                                ***
**********************************************************************
DFNGET   ST    R10,DFR10SAV             SAVE RETURN ADDRESS
         XC    RETCDE,RETCDE            SET ERROR CODE TO ZERO
*
         LA    R4,DS3LEN(0,0)           LENGTH OF DDSAME UNALLOC T.U.
         BCTR  R4,0                       MINUS 1 FOR EXEC
         EX    R4,DFMVC4                EXECUTE MOVE
         LA    R4,DS4LEN(0,0)           LENGTH OF DSNAME ALLOC T.U.
         BCTR  R4,0                       MINUS 1 FOR EXEC
         EX    R4,DFMVC5                EXECUTE MOVE
         L     R4,EFROMDSN              R4 IS POINTER TO DSN
         LH    R5,EFROMDSN+4            R5 IS LENGTH OF DSN
         STH   R5,RLEN2                 SAVE FOR LATER
         BCTR  R5,0                     R5 -1 FOR EXEC
         EX    R5,DFMVC1                EXECUTE MOVE TO RNAM2
         EX    R5,DFMVC2                  AND TO DEALLOCATE T.U.
         EX    R5,DFMVC3                  AND TO ALLOCATE T.U.
*
         CLI   0(R4),C'*'               IF FROMDSN(*) IS IN USE
         BNE   *+12                     THEN
         OI    SWITCH1,X'80'              TURN ON SWITCH1-0
         B     DFEND                      AND BYPASS ALLOCATIONS
*
         XC    RMEMLEN2(2),RMEMLEN2     ZERO MEMBER LENGTH
         MVC   RMEM2(8),BLANKS          BLANK MEMBER NAME
         TM    EFROMDSN+14,X'80'        IF MEMBER NAME IN USE
         BZ    DF0KEY                     THEN
         L     R4,EFROMDSN+8                R4 POINTS TO MEMBER NAME
         LH    R5,EFROMDSN+12               R5 IS LENGTH OF MEMBER NME
         STH   R5,RMEMLEN2                  SAVE THE LENGTH
         BCTR  R5,0                         -1 FOR EXEC
         EX    R5,DFMVC6                    MOVE NAME TO ALLOC T.U.
         EX    R5,DFMVC7                    MOVE NAME TO WORK AREA
         B     DFSET                      ELSE
DF0KEY   XC    DSDMEMBR-6(2),DSDMEMBR-6     ZERO ALLOC T.U. KEY
*
DFSET    GTEDASET DSC,CPPLPTR=CPPLPTR , LINK CONTROL BLOCKS TOGETHER
         GTEDAALC DSC,VERB=UN,ERRMSG=NO UNALLOCATE DATASET NAME
         GTEDASET DSD,CPPLPTR=CPPLPTR , LINK CONTROL BLOCKS TOGETHER
         GTEDAALC DSD,VERB=AL         , ALLOCATE DATASET NAME
         CLC   DSDS99RC(4),DZIPS        IF RETURN CODE NOT ZERO
         BNE   DFERR10                    SET RETURN CODE TO 16
         MVC   RDDN2(8),DSDRTDDN        SAVE RETURNED DDNAME
         LA    R4,DD3LEN(0,0)           LENGTH OF INFO T.U.
         BCTR  R4,0                       MINUS 1 FOR EXEC
         EX    R4,DFMVC8                EXECUTE THE MOVE
         MVC   DDCDDNAM(8),RDDN2        SET THE DDNAME
         GTEDASET DDC,CPPLPTR=CPPLPTR , LINK CONTROL BLOCKS TOGETHER
         GTEDAALC DDC,VERB=IN         , GET INFO
         TM    DDCINORG,X'02'           IF NOT PARTITIONED ORGANIZATION
         BNO   DFEND                      BRANCH TO ENDING
         CLC   DDCRTMEM(8),BLANKS       ELSE IF MEMBER NAME NOT BLANK
         BNE   DFEND                      BRANCH TO ENDING
         B     DFERR3C                  ELSE (IF PO AND BLANK) ERROR
*
DFERR10  LA    R15,X'10'(0,0)           CONSTANT TO R15
         ST    R15,RETCDE               SET INTERNAL RETURN CODE
         BAL   R10,MSGPUT               PUT OUT MESSAGE
         B     DFEND                    GO TO ENDING
*
DFERR3C  LA    R15,X'3C'(0,0)           CONSTANT TO R15
         ST    R15,RETCDE               SET INTERNAL RETURN CODE
         BAL   R10,MSGPUT               PUT OUT ERROR MESSAGE
         B     DFEND                    GO TO END OF ROUTINE
*
DFEND    L     R10,DFR10SAV             RESTORE RETURN ADDRESS
         BR    R10                      RETURN
*
DFMVC1   MVC   RNAM2(0),0(R4)           EXECUTED INSTRUCTION
DFMVC2   MVC   DSCDSNAM(0),0(R4)        EXECUTED INSTRUCTION
DFMVC3   MVC   DSDDSNAM(0),0(R4)        EXECUTED INSTRUCTION
DFMVC4   MVC   DSC(0),DS3               MOVE CONSTANTS
DFMVC5   MVC   DSD(0),DS4               MOVE CONSTANTS
DFMVC6   MVC   DSDMEMBR(0),0(R4)        EXECUTED INSTRUCTION
DFMVC7   MVC   RMEM2(0),0(R4)           EXECUTED INSTRUCTION
DFMVC8   MVC   DDC(0),DD3               MOVE CONSTANTS
         EJECT
**********************************************************************
***                                                                ***
***         GET FROMDDNAME                                         ***
***                                                                ***
**********************************************************************
DGET     ST    R10,DGR10SAV             SAVE RETURN ADDRESS
         XC    RETCDE,RETCDE            SET ERROR CODE TO ZERO
*
         LA    R4,DD2LEN(0,0)           LENGTH OF DDNAME T.U.
         BCTR  R4,0                       MINUS 1 FOR EXEC
         B     *+10                     BRANCH AROUND EXECUTED INSTR
         MVC   DDB(0),DD2                 MOVE CONSTANTS
         EX    R4,*-6                   EXECUTE MOVE
         L     R4,EFROMDDN              R4 POINTS TO DDNAME
         MVC   RDDN2(8),BLANKS          BLANK WORK DDNAME
         LH    R5,EFROMDDN+4            R5 IS LENGTH OF DDNAME
         C     R5,F8                    IF MORE THAN 8 CHARS
         BNH   *+8                      THEN
         L     R5,F8                      SET LENGTH TO 8
         BCTR  R5,0                     R5 MINUS 1 FOR EXEC
         B     *+16                     BRANCH AROUND EXECUTED INSTR
         MVC   DDBDDNAM(0),0(R4)          MOVE DDNAME TO T.U.
         MVC   RDDN2(0),0(R4)             ALSO TO WORK AREA
         EX    R5,*-12                  EXECUTE MOVE TO T.U.
         EX    R5,*-10                  EXECUTE MOVE TO WORK AREA
         GTEDASET  DDB,CPPLPTR=CPPLPTR , LINK CONTROL BLOCKS TOGETHER
         GTEDAALC  DDB,VERB=IN,ERRMSG=YES
         L     R4,DDBS99RC              LOAD SVC-99 RETURN CODE
         LTR   R4,R4                    IF NOT ZERO
         BNZ   DGERR14                    BRANCH TO ERROR 20
         MVC   RNAM2(44),DDBINDSN       SAVE RETURNED DSNAME
         MVC   RLEN2(2),DDBINDSN-2        AND LENGTH
         TM    DDBINORG,X'02'           IF NOT PARTITIONED ORGANIZATION
         BNO   DGEND                      BRANCH TO ENDING
         CLC   DDBRTMEM(8),BLANKS       ELSE IF MEMBER NAME NOT BLANK
         BNE   DGEND                      BRANCH TO ENDING
         B     DGERR3C                  ELSE (IF PO AND BLANK) ERROR
*
DGERR14  LA    R15,X'14'(0,0)           CONSTANT TO R15
         ST    R15,RETCDE               SET INTERNAL RETURN CODE
         BAL   R10,MSGPUT               PUT OUT THE MESSAGE
         B     DGEND                    GO TO ENDING
*
DGERR3C  LA    R15,X'3C'(0,0)           CONSTANT TO R15
         ST    R15,RETCDE               SET INTERNAL RETURN CODE
         BAL   R10,MSGPUT               PUT OUT THE MESSAGE
         B     DGEND                    GO TO END OF ROUTINE
*
DGEND    L     R10,DGR10SAV             RESTORE RETURN ADDRESS
         BR    R10                      RETURN
*
         EJECT
**********************************************************************
***                                                                ***
***    GET/ALLOCATE TODSNAME                                       ***
***                                                                ***
**********************************************************************
DSNGET   ST    R10,DSR10SAV             SAVE RETURN ADDRESS
         XC    RETCDE,RETCDE            SET ERROR CODE TO ZERO
*
         LA    R4,DS1LEN(0,0)           LENGTH OF DDSAME UNALLOC T.U.
         BCTR  R4,0                       MINUS 1 FOR EXEC
         EX    R4,DSMVC4                EXECUTE MOVE
         LA    R4,DS2LEN(0,0)           LENGTH OF DSNAME ALLOC T.U.
         BCTR  R4,0                       MINUS 1 FOR EXEC
         EX    R4,DSMVC5                EXECUTE MOVE
         L     R4,ETODSN                R4 IS POINTER TO DSN
         LH    R5,ETODSN+4              R5 IS LENGTH OF DSN
         STH   R5,RLEN1                 SAVE FOR LATER
         BCTR  R5,0                     R5 -1 FOR EXEC
         EX    R5,DSMVC1                EXECUTE MOVE TO RNAM1
         EX    R5,DSMVC2                  AND TO DEALLOCATE T.U.
         EX    R5,DSMVC3                  AND TO ALLOCATE T.U.
         XC    RMEMLEN1(2),RMEMLEN1     ZERO MEMBER LENGTH
         MVC   RMEM1(8),BLANKS          BLANK MEMBER NAME
         TM    ETODSN+14,X'80'          IF MEMBER NAME IN USE
         BZ    DS0KEY                     THEN
         L     R4,ETODSN+8                  R4 POINTS TO MEMBER NAME
         LH    R5,ETODSN+12                 R5 IS LENGTH OF MEMBER NME
         STH   R5,RMEMLEN1                  SAVE THE LENGTH
         BCTR  R5,0                         -1 FOR EXEC
         EX    R5,DSMVC6                    MOVE NAME TO ALLOC T.U.
         EX    R5,DSMVC7                    MOVE NAME TO WORK AREA
         B     DSSET                      ELSE
DS0KEY   XC    DSBMEMBR-6(2),DSBMEMBR-6     ZERO ALLOC T.U. KEY
*
DSSET    GTEDASET DSA,CPPLPTR=CPPLPTR , LINK CONTROL BLOCKS TOGETHER
         GTEDAALC DSA,VERB=UN,ERRMSG=NO UNALLOCATE DATASET NAME
         GTEDASET DSB,CPPLPTR=CPPLPTR , LINK CONTROL BLOCKS TOGETHER
         GTEDAALC DSB,VERB=AL         , ALLOCATE DATASET NAME
         CLC   DSBS99RC(4),DZIPS        IF RETURN CODE NOT ZERO
         BNE   DSERR0C                    SET RETURN CODE TO 12
         MVC   RDDN1(8),DSBRTDDN        SAVE RETURNED DDNAME
         LA    R4,DD3LEN(0,0)           LENGTH OF INFO T.U.
         BCTR  R4,0                       MINUS 1 FOR EXEC
         EX    R4,DSMVC8                EXECUTE THE MOVE
         MVC   DDCDDNAM(8),RDDN1        SET THE DDNAME
         GTEDASET DDC,CPPLPTR=CPPLPTR , LINK CONTROL BLOCKS TOGETHER
         GTEDAALC DDC,VERB=IN         , GET INFO
         TM    DDCINORG,X'02'           IF NOT PARTITIONED ORGANIZATION
         BNO   DSEND                      BRANCH TO ENDING
         CLC   DDCRTMEM(8),BLANKS       ELSE IF MEMBER NAME NOT BLANK
         BNE   DSMOD                      BRANCH TO NEXT CHECK
         B     DSERR38                  ELSE (IF PO AND BLANK) ERROR
DSMOD    CLI   KMOD+1,X'01'             IF PO AND NONBLANK AND 'MOD'
         BE    DSERR40                    GO TO ERROR
         B     DSEND                    ELSE GO TO ENDING
*
DSERR0C  LA    R15,X'0C'(0,0)           CONSTANT TO R15
         ST    R15,RETCDE               SET INTERNAL RETURN CODE
         BAL   R10,MSGPUT               PUT OUT THE MESSAGE
         B     DSEND                    GO TO ENDING
*
DSERR38  LA    R15,X'38'(0,0)           CONSTANT TO R15
         ST    R15,RETCDE               SET INTERNAL RETURN CODE
         BAL   R10,MSGPUT               PUT OUT THE MESSAGE
         B     DSEND                    GO TO END OF ROUTINE
*
DSERR40  LA    R15,X'40'(0,0)           CONSTANT TO R15
         ST    R15,RETCDE               SET INTERNAL RETURN CODE
         BAL   R10,MSGPUT               PUT OUT THE MESSAGE
         B     DSEND                    GO TO END OF ROUTINE
*
DSEND    L     R10,DSR10SAV             RESTORE RETURN ADDRESS
         BR    R10                      RETURN
*
DSMVC1   MVC   RNAM1(0),0(R4)           EXECUTED INSTRUCTION
DSMVC2   MVC   DSADSNAM(0),0(R4)        EXECUTED INSTRUCTION
DSMVC3   MVC   DSBDSNAM(0),0(R4)        EXECUTED INSTRUCTION
DSMVC4   MVC   DSA(0),DS1               MOVE CONSTANTS
DSMVC5   MVC   DSB(0),DS2               MOVE CONSTANTS
DSMVC6   MVC   DSBMEMBR(0),0(R4)        EXECUTED INSTRUCTION
DSMVC7   MVC   RMEM1(0),0(R4)           EXECUTED INSTRUCTION
DSMVC8   MVC   DDC(0),DD3               MOVE CONSTANTS
         EJECT
**********************************************************************
***                                                                ***
***         GET TODDNAME                                           ***
***                                                                ***
**********************************************************************
DDNGET   ST    R10,DDR10SAV             SAVE RETURN ADDRESS
         XC    RETCDE,RETCDE            SET ERROR CODE TO ZERO
*
         LA    R4,DD1LEN(0,0)           LENGTH OF DDNAME T.U.
         BCTR  R4,0                       MINUS 1 FOR EXEC
         B     *+10                     BRANCH AROUND EXECUTED INSTR
         MVC   DDA(0),DD1                 MOVE CONSTANTS
         EX    R4,*-6                   EXECUTE MOVE
         L     R4,ETODDN                R4 POINTS TO DDNAME
         MVC   RDDN1(8),BLANKS          BLANK WORK DDNAME
         LH    R5,ETODDN+4              R5 IS LENGTH OF DDNAME
         C     R5,F8                    IF MORE THAN 8 CHARS
         BNH   *+8                      THEN
         L     R5,F8                      SET LENGTH TO 8
         BCTR  R5,0                     R5 MINUS 1 FOR EXEC
         B     *+16                     BRANCH AROUND EXECUTED INSTR
         MVC   DDADDNAM(0),0(R4)          MOVE DDNAME TO T.U.
         MVC   RDDN1(0),0(R4)             ALSO TO WORK AREA
         EX    R5,*-12                  EXECUTE MOVE TO T.U.
         EX    R5,*-10                  EXECUTE MOVE TO WORK AREA
         GTEDASET  DDA,CPPLPTR=CPPLPTR , LINK CONTROL BLOCKS TOGETHER
         GTEDAALC  DDA,VERB=IN,ERRMSG=YES
         L     R4,DDAS99RC              LOAD SVC-99 RETURN CODE
         LTR   R4,R4                    IF NOT ZERO
         BNZ   DDERR08                    BRANCH TO ERROR 08
         MVC   RNAM1(44),DDAINDSN       SAVE RETURNED DSNAME
         MVC   RLEN1(2),DDAINDSN-2        AND LENGTH
         TM    DDAINORG,X'02'           IF NOT PARTITIONED ORGANIZATION
         BNO   DDEND                      BRANCH TO ENDING
         CLC   DDARTMEM(8),BLANKS       ELSE IF MEMBER NAME NOT BLANK
         BNE   DDMOD                      BRANCH TO NEXT CHECK
         B     DDERR38                  ELSE (IF PO AND BLANK) ERROR
DDMOD    CLI   KMOD+1,X'01'             IF PO AND NONBLANK AND 'MOD'
         BE    DDERR40                    GO TO ERROR
         B     DDEND                    ELSE GO TO ENDING
*
DDERR08  LA    R15,X'08'(0,0)           CONSTANT TO R15
         ST    R15,RETCDE               SET INTERNAL RETURN CODE
         BAL   R10,MSGPUT               PUT OUT ERROR MESSAGE
         B     DDEND                    GO TO ENDING
*
DDERR38  LA    R15,X'38'(0,0)           CONSTANT TO R15
         ST    R15,RETCDE               SET INTERNAL RETURN CODE
         BAL   R10,MSGPUT               PUT OUT ERROR MESSAGE
         B     DDEND                    GO TO END OF ROUTINE
*
DDERR40  LA    R15,X'40'(0,0)           CONSTANT TO R15
         ST    R15,RETCDE               SET INTERNAL RETURN CODE
         BAL   R10,MSGPUT               PUT OUT ERROR MESSAGE
         B     DDEND                    GO TO END OF ROUTINE
*
DDEND    L     R10,DDR10SAV             RESTORE RETURN ADDRESS
         BR    R10                      RETURN
*
         EJECT
**********************************************************************
***                                                                ***
***    ENQUEUE THE RNAM1 NAME                                      ***
***                                                                ***
**********************************************************************
ENQUEUE  ST    R10,ENR10SAV             SAVE RETURN ADDRESS
         XC    RETCDE,RETCDE            SET ERROR CODE TO ZERO
*
         MVC   ENQLIST(12),ENQPROTO     INITIALIZE PARM LIST FOR ENQ
         MVC   ENQLIST+1(1),RLEN1+1     LENGTH TO PARM LIST
         LA    R5,RNAM1                 ADDR OF MINOR NAME TO R5
         ST    R5,ENQLIST+8               THEN TO PARM LIST
         ENQ   MF=(E,ENQLIST)           ENQUEUE THE NAME
*
ENEND    L     R10,ENR10SAV             RESTORE RETURN ADDRESS
         BR    R10                      RETURN
*
         SPACE 6
**********************************************************************
***                                                                ***
***    DEQUEUE THE RNAM1 NAME                                      ***
***                                                                ***
**********************************************************************
DEQUEUE  ST    R10,DER10SAV             SAVE RETURN ADDRESS
         XC    RETCDE,RETCDE            SET ERROR CODE TO ZERO
*
         MVC   DEQLIST(12),DEQPROTO     INITIALIZE PARM LIST FOR DEQ
         MVC   DEQLIST+1(1),RLEN1+1     LENGTH TO PARM LIST
         LA    R5,RNAM1                 ADDR OF MINOR NAME TO R5
         ST    R5,DEQLIST+8               THEN TO PARM LIST
         DEQ   MF=(E,DEQLIST)           DEQUEUE THE NAME
*
DEEND    L     R10,DER10SAV             RESTORE RETURN ADDRESS
         BR    R10                      RETURN
*
         EJECT
**********************************************************************
***                                                                ***
***    OPEN THE DATASETS                                           ***
***                                                                ***
**********************************************************************
OPENSETS ST    R10,OPR10SAV             SAVE RETURN ADDRESS
         XC    RETCDE,RETCDE            SET ERROR CODE TO ZERO
*
         USING IHADCB,R4                ADDRESSABILITY OF DCB
*
         LA    R5,DCBILEN(0,0)          LENGTH OF INPUT DCB
         BCTR  R5,0                       -1 FOR EXEC
         EX    R5,OPMVC1                INITIALIZE DCB
         LA    R5,DCBOLEN(0,0)          LENGTH OF OUTPUT DCB
         BCTR  R5,0                       -1 FOR EXEC
         EX    R5,OPMVC2                INITIALIZE DCB
*
OPENINCK TM    SWITCH1,X'80'            IF USING FROMDSN(*)
         BO    OPENOUT                    SKIP OPENING INPUT FILE
*
OPENIN   LA    R4,INDCB                 R5 POINTS TO INPUT DCB
         MVC   DCBDDNAM(8),RDDN2        FILL IN DDNAME
         MVC   OPENLIST(4),OPENLI       INPUT OPTIONS TO PARM LIST
         LA    R5,INDCB                 ADDRESS OF INPUT DCB
         STCM  R5,7,OPENLIST+1            INTO OPEN PARM LIST
         OPEN  MF=(E,OPENLIST)        , OPEN THE INPUT DATASET
         TM    DCBOFLGS,X'10'           IF NOT SUCCESSFUL
         BZ    OPERR1C                    GO TO ERROR ROUTINE
         MVC   RECFMI(1),DCBRECFM       SAVE THE RECORD FORMAT
         MVC   LRECLI(2),DCBLRECL         AND THE LRECL
         MVC   BLKSIZEI(2),DCBBLKSI       AND THE BLOCKSIZE
         B     OPENOUT                  GO TO OPEN OTHER FILE
*
OPENOUT  LA    R4,OUTDCB                R5 POINTS TO OUTPUT DCB
         MVC   DCBDDNAM(8),RDDN1        FILL IN DDNAME
         CLI   KMOD+1,X'01'             IF 'MOD' OPERAND IS USED
         BNE   *+14                       THEN
         MVC   OPENLIST(4),OPENLOX          'EXTEND' OPTIONS TO LIST
         B     *+10                       ELSE
         MVC   OPENLIST(4),OPENLO           'OUTPUT' OPTIONS TO LIST
         LA    R5,OUTDCB                ADDRESS OF OUTPUT DCB
         STCM  R5,7,OPENLIST+1            INTO OPEN PARM LIST
         OPEN  MF=(E,OPENLIST)        , OPEN THE DATASET
         TM    DCBOFLGS,X'10'           IF NOT SUCCESSFUL
         BZ    OPERR20                    GO TO ERROR ROUTINE
         MVC   RECFMO(1),DCBRECFM       SAVE THE RECORD FORMAT
         MVC   LRECLO(2),DCBLRECL         AND THE LRECL
         MVC   BLKSIZEO(2),DCBBLKSI       AND THE BLOCKSIZE
         B     OPSETCHK                 GO TO CHECK FORMATS, ETC.
*
         DROP  R4
*
OPSETCHK BAL   R10,SETCHK               CHECK DATASET INFORMATION
         B     OPEND                    BRANCH TO END OF ROUTINE
*
OPERR1C  LA    R15,X'1C'(0,0)           CONSTANT TO R15
         ST    R15,RETCDE               SET INTERNAL RETURN CODE
         BAL   R10,MSGPUT               PUT OUT THE MESSAGE
         B     OPEND                    GO TO ENDING
*
OPERR20  LA    R15,X'20'(0,0)           CONSTANT TO R15
         ST    R15,RETCDE               SET INTERNAL RETURN CODE
         BAL   R10,MSGPUT               PUT OUT THE MESSAGE
         B     OPEND                    GO TO ENDING
*
OPEND    L     R10,OPR10SAV             RESTORE RETURN ADDRESS
         BR    R10                      RETURN
*
OPMVC1   MVC   OUTDCB(0),DCBPROTO       INITIALIZE DCB
OPMVC2   MVC   INDCB(0),DCBPROTI        INITIALIZE DCB
         EJECT
**********************************************************************
***                                                                ***
***   CLOSE THE DATASETS                                           ***
***                                                                ***
**********************************************************************
CLOSSETS ST    R10,CLR10SAV             SAVE RETURN ADDRESS
         XC    RETCDE,RETCDE            SET ERROR CODE TO ZERO
*
         TM    SWITCH1,X'80'            IF USING FROMDSN(*)
         BO    CLOSOUT                    BRANCH AROUND CLOSE INPUT
*
CLOSIN   LA    R4,INDCB                 ADDRESS OF INPUT DCB
         MVC   CLOSLIST(4),CLOSPRTI     INITIALIZE PARM LIST
         CLOSE ((R4)),MF=(E,CLOSLIST)   CLOSE THE DATASETS
         LTR   R15,R15                  IF RETURN CODE NOT ZERO
         BNZ   CLERR24                    GO TO ERROR ROUTINE
*
CLOSOUT  LA    R4,OUTDCB                ADDRESS OF INPUT DCB
         MVC   CLOSLIST(4),CLOSPRTO     INITIALIZE PARM LIST
         CLOSE ((R4)),MF=(E,CLOSLIST)   CLOSE THE DATASETS
         LTR   R15,R15                  IF RETURN CODE NOT ZERO
         BNZ   CLERR28                    GO TO ERROR ROUTINE
*
         B     CLEND
*
CLERR24  LA    R15,X'24'(0,0)           CONSTANT TO R15
         ST    R15,RETCDE               SET INTERNAL RETURN CODE
         BAL   R10,MSGPUT               PUT OUT THE MESSAGE
         B     CLEND                    GO TO ENDING
*
CLERR28  LA    R15,X'28'(0,0)           CONSTANT TO R15
         ST    R15,RETCDE               SET INTERNAL RETURN CODE
         BAL   R10,MSGPUT               PUT OUT THE MESSAGE
         B     CLEND                    GO TO ENDING
*
CLEND    L     R10,CLR10SAV             RESTORE RETURN ADDRESS
         BR    R10                      RETURN
         EJECT
**********************************************************************
***                                                                ***
***   CHECK DATASET INFORMATION (BLKSIZE, LRECL, ETC.)             ***
***                                                                ***
**********************************************************************
SETCHK   ST    R10,SER10SAV             SAVE RETURN ADDRESS
         XC    RETCDE,RETCDE            SET ERROR CODE TO ZERO
*
         TM    SWITCH1,X'80'            IF USING FROMDSN(*)
         BO    SECKO                      SKIP CHECKING INPUT DATASET
*
SECKI    TM    RECFMI,DCBRECU           IF UNDEFINED FORMAT (F+V)
         BO    SEERR30                    BRANCH TO ERROR
         TM    RECFMI,DCBRECF           IF FIXED FORMAT
         BNO   *+12                       THEN
         OI    SWITCH1,X'40'              TURN ON SWITCH1-1
         B     SECKO                      AND GO TO CHECK OUTPUT D'SET
         TM    RECFMI,DCBRECV           ELSE
         BNO   *+12                     IF VARIABLE FORMAT
         OI    SWITCH1,X'20'              TURN ON SWITCH1-2
         B     SECKO                      AND GO TO CHECK OUTPUT D'SET
         B     SEERR30                  ELSE GO TO ERROR ROUTINE
*
SECKO    TM    RECFMO,DCBRECU           IF UNDEFINED FORMAT (F+V)
         BO    SEERR30                    BRANCH TO ERROR
         TM    RECFMO,DCBRECF           IF FIXED FORMAT
         BNO   *+12                       THEN
         OI    SWITCH1,X'10'              TURN ON SWITCH1-3
         B     SEEND                      AND GO TO CHECK OUTPUT D'SET
         TM    RECFMO,DCBRECV           ELSE
         BNO   *+12                     IF VARIABLE FORMAT
         OI    SWITCH1,X'08'              TURN ON SWITCH1-4
         B     SEEND                      AND GO TO CHECK OUTPUT D'SET
         B     SEERR30                  ELSE GO TO ERROR ROUTINE
*
SEERR30  LA    R15,X'30'(0,0)           CONSTANT TO R15
         ST    R15,RETCDE               SET INTERNAL RETURN CODE
         BAL   R10,MSGPUT               PUT OUT THE MESSAGE
         B     SEEND                    GO TO ENDING
*
SEEND    L     R10,SER10SAV             RESTORE RETURN ADDRESS
         BR    R10                      RETURN
         EJECT
**********************************************************************
***                                                                ***
***     PERFORM THE DATA COPY                                      ***
***                                                                ***
**********************************************************************
COPY     ST    R10,COR10SAV             SAVE RETURN ADDRESS
         XC    RETCDE,RETCDE            SET ERROR CODE TO ZERO
*
         USING IHADCB,R4                ADDRESSABILITY OF DCB
         LA    R4,INDCB                 POINT TO INPUT DCB
         LH    R5,DCBBLKSI              R5 HAS INPUT BLOCKSIZE
         STH   R5,BLKSIZEI              SAVE THE BLOCKSIZE
         LA    R4,OUTDCB                POINT TO OUTPUT DCB
         LH    R6,DCBBLKSI              R6 HAS OUTPUT BLOCKSIZE
         STH   R6,BLKSIZEO              SAVE THE BLOCKSIZE
         CR    R6,R5                    IF R6 GREATEST SIZE
         BNL   *+6                        BRANCH AROUND
         LR    R6,R5                    ELSE PUT GREATEST SIZE TO R6
         STH   R6,BLKSIZE               SAVE THE BLOCKSIZE
         C     R6,F320                  IF BLOCKSIZE GREATER THAN 320
         BH    *+8                        BRANCH AROUND
         L     R6,F320                  ELSE USE 320
         STH   R6,USESIZE                 SAVE LENGTH FOR FREEMAIN
         GETMAIN R,LV=(R6)              GET ONE BLOCKSIZE OF SPACE
         LR    R6,R1                    R6 POINTS TO NEW SPACE
         USING WORK2,R6                 ADDRESSABILITY
*
         DROP  R4                       DROP ADDRESSABILITY
*
COGET    BAL   R10,GTREC                GET A RECORD
         CLC   RETCDE(4),DZIPS          IF RETURN NOT ZERO
         BNE   COEOF                      TERMINATE INPUT
COEDIT   BAL   R10,EDIT                 EDIT THE DATA
         CLC   RETCDE(4),DZIPS          IF RETURN NOT ZERO
         BNE   COEOF                      TERMINATE INPUT
COPUT    BAL   R10,PTREC                PUT THE RECORD
         B     COGET                    LOOP BACK UNTIL END OF FILE
COEOF    LH    R5,USESIZE               LENGTH OF GETMAIN AREA
         LA    R4,WORK2                 ADDRESS OF GETMAIN AREA
         FREEMAIN R,LV=(R5),A=(R4)      FREE THE AREA
*
COEND    L     R10,COR10SAV             RESTORE RETURN ADDRESS
         BR    R10                      RETURN
         EJECT
**********************************************************************
***                                                                ***
***     GET AN INPUT RECORD                                        ***
***                                                                ***
***     GTFILE IS USED TO GET DATA FROM AN INPUT DATASET.          ***
***     GTTRM  IS USED TO GET DATA FROM THE KEYBOARD OR DATA       ***
***       STACKED INSTREAM BY A CLIST.                             ***
***                                                                ***
**********************************************************************
GTREC    ST    R10,GTR10SAV             SAVE RETURN ADDRESS
         XC    RETCDE,RETCDE            SET ERROR CODE TO ZERO
*
         LA    R4,INDCB                 POINT TO INPUT DCB
         USING IHADCB,R4                ADDRESSABILITY
*
         TM    SWITCH1,X'80'            IF USING FROMDSN(*)
         BO    GTTRM                      BRANCH TO TERMINAL READ
*
GTFILE   GET   INDCB,DATAWK24           GET ONE LOGICAL RECORD
         MVC   LRECLI(2),DCBLRECL       SAVE THE INPUT LRECL
         B     GTEND                    BRANCH TO ENDING
*
         DROP  R4
*
GTTRM    GETLINE PARM=MYGTPB,MF=(E,MYIOPL)  GET ONE LINE FROM STACK
         C     R15,F4                   IF RETURN CODE GREATER THAN 4
         BH    GTERR2C                    BRANCH TO ERROR ROUTINE
         L     R4,MYGTPB+4              R4 POINTS TO INPUT AREA
         LH    R1,0(0,R4)               R1 IS TOTAL LENGTH OF INPUT
         C     R1,F4                    IF INPUT IS 4 CHARS (NULL LINE)
         BNH   COEOF                      BRANCH TO EODAD POINT
         MVC   ENDCK(7),0(R4)           MOVE TO CHECK WORK AREA
         OC    ENDCK+4(3),BLANKS        CAPITALIZE
         CLC   ENDCK(7),ENDWORD         IF X'00070000',C'END'
         BE    COEOF                      BRANCH TO EODAD POINT
         STH   R1,LRECLI                SAVE THE INPUT LENGTH
         BCTR  R1,0                     R1 -1 FOR EXEC
         B     *+10                     BRANCH AROUND EXECUTED INSTR
         MVC   DATAWK24(0),0(R4)          MOVE DATA TO OUTPUT AREA
         EX    R1,*-6                   EXECUTE THE MOVE
         B     GTEND                    GO TO ENDING
*
GTERR2C  LA    R15,X'2C'(0,0)           CONSTANT TO R15
         ST    R15,RETCDE               SET INTERNAL RETURN CODE
         BAL   R10,MSGPUT               PUT OUT THE MESSAGE
         B     GTEND                    GO TO ENDING
*
GTEND    L     R10,GTR10SAV             RESTORE RETURN ADDRESS
         BR    R10                      RETURN
         EJECT
**********************************************************************
***                                                                ***
***     EDIT THE DATA                                              ***
***                                                                ***
**********************************************************************
EDIT     ST    R10,EDR10SAV             SAVE RETURN ADDRESS
         XC    RETCDE,RETCDE            SET ERROR CODE TO ZERO
*
EDFF     TM    SWITCH1,X'50'            IF NOT (IN F AND OUT F)
         BNO   EDTF                       THEN BRANCH TO NEXT CHECK
         LA    R2,DATAWK24              R2 OUTPUT ADDRESS
         ST    R2,OUTBEGIN              SAVE OUTPUT ADDRESS
         LH    R3,LRECLO                R3 OUTPUT LENGTH
         LA    R4,DATAWK24              R4 INPUT ADDRESS
         LH    R5,LRECLI                R5 INPUT LENGTH
         CR    R3,R5                    IF OUTPUT LEN NGT INPUT LEN
         BNH   *+10                       BRANCH AROUND
         ICM   R5,8,BLANKS              ELSE PAD CHAR X'40' TO R5
         MVCL  R2,R4                      MOVE OVER SELF, THEN PAD
         BAL   R10,FFNUM                PERFORM LINE NUMBER PROCESSING
         B     EDEND                    BRANCH TO ENDING
*
EDTF     TM    SWITCH1,X'90'            IF NOT (IN * AND OUT F)
         BNO   EDVF                       THEN BRANCH TO NEXT CHECK
         B     *+12                     ELSE BRANCH INTO (V TO F)
EDVF     TM    SWITCH1,X'30'            IF NOT (IN V AND OUT F)
         BNO   EDTV                       THEN BRANCH TO NEXT CHECK
         LA    R2,DATAWK28              R2 OUTPUT ADDRESS
         ST    R2,OUTBEGIN              SAVE OUTPUT ADDRESS
         LH    R3,LRECLO                R3 OUTPUT LENGTH
         LA    R4,DATAWK28              R4 INPUT ADDRESS
         LH    R5,LRECLI                R5 INPUT LENGTH
         S     R5,F4                      -4 FOR LOSING RCW
         CR    R3,R5                    IF OUTPUT LEN NGT INPUT LEN
         BNH   *+10                       BRANCH AROUND
         ICM   R5,8,BLANKS              ELSE PAD CHAR X'40' TO R5
         MVCL  R2,R4                      MOVE OVER SELF, THEN PAD
         TM    SWITCH1,X'30'            IF NOT (IN V AND OUT F)
         BNO   EDEND                      BRANCH TO ENDING
         BAL   R10,VFNUM                ELSE PERFORM LINENO PROCESSING
         B     EDEND                      AND BRANCH TO ENDING
*
EDTV     TM    SWITCH1,X'88'            IF NOT (IN * AND OUT V)
         BNO   EDVV                       THEN BRANCH TO NEXT CHECK
         B     *+12                     ELSE BRANCH INTO (V TO V)
EDVV     TM    SWITCH1,X'28'            IF NOT (IN V AND OUT V)
         BNO   EDFV                       THEN BRANCH TO NEXT CHECK
         LH    R4,LRECLO                R4 HAS OUTPUT MAX LRECL
         CH    R4,DATAWK24              IF MAX ALLOWED NL DATA LENGTH
         BNL   *+8                        BRANCH AROUND
         STH   R4,DATAWK24              ELSE USE MAX ALLOWED
         LA    R4,DATAWK24              R4 IS ADDR OF OUTPUT
         ST    R4,OUTBEGIN              SAVE OUTPUT ADDRESS
         B     EDEND                    BRANCH TO ENDING
*
EDFV     TM    SWITCH1,X'48'            IF NOT (IN F AND OUT V)
         BNO   EDERR34                    THEN BRANCH TO ERROR
         XC    DATAWK20(4),DATAWK20     CLEAR NEW RCW
         LH    R4,LRECLI                R4 HAS INPUT LRECL
         LA    R4,4(0,R4)                 PLUS LENGTH OF RCW
         STH   R4,DATAWK20              WRITE LENGTH INTO RCW
         LH    R4,LRECLO                R4 HAS OUTPUT MAX LRECL
         CH    R4,DATAWK20              IF MAX ALLOWED NL DATA LENGTH
         BNL   *+8                        BRANCH AROUND
         STH   R4,DATAWK20              ELSE USE MAX ALLOWED
         LA    R4,DATAWK20              R4 IS ADDR OF OUTPUT
         ST    R4,OUTBEGIN              SAVE OUTPUT ADDRESS
         BAL   R10,FVNUM                PERFORM LINENO PROCESSING
         B     EDEND                    BRANCH TO ENDING
*
EDERR34  LA    R15,X'34'(0,0)           CONSTANT TO R15
         ST    R15,RETCDE               SET INTERNAL RETURN CODE
         BAL   R10,MSGPUT               PUT OUT THE MESSAGE
         B     EDEND                    GO TO ENDING
*
EDEND    L     R10,EDR10SAV             RESTORE RETURN ADDRESS
         BR    R10                      RETURN
         EJECT
**********************************************************************
***                                                                ***
***     MOVE LINE NUMBERS IN RECFM=F TO F CONVERSION               ***
***                                                                ***
***     AT ENTRY, OUTBEGIN POINTS TO DATAWK24                      ***
***                                                                ***
**********************************************************************
FFNUM    ST    R10,FFR10SAV             SAVE RETURN ADDRESS
         XC    RETCDE,RETCDE            SET ERROR CODE TO ZERO
*
         CLI   KNUM+1,X'01'             IF 'NUM' OPERAND NOT IN USE
         BNE   FFEND                      BYPASS THIS PROCESS
*
         LH    R4,LRECLI                R4 HAS INPUT LRECL
         C     R4,F8                    IF LESS THAN 8
         BL    FFERR48                    BRANCH TO ERROR
         LH    R5,LRECLO                R5 HAS OUTPUT LRECL
         C     R5,F8                    IF LESS THAN 8
         BL    FFERR48                    BRANCH TO ERROR
*
         CR    R4,R5                    IF LRECLS IN AND OUT ARE SAME
         BE    FFEND                      BYPASS THE REMAINDER
*
         LA    R4,DATAWK24-8(R4)        R4 POINTS TO INPUT LINE NUM
         LA    R5,DATAWK24-8(R5)        R5 POINTS TO OUTPUT LINE NUM
         MVC   TEMPNUM(8),0(R4)         SAVE THE INPUT LINE NUMBER
         MVC   0(8,R4),BLANKS           CLEAR INPUT LINE NUM TO BLANKS
         MVC   0(8,R5),TEMPNUM          LINE NUM TO OUTPUT LINE NUM FLD
         B     FFEND                    GO TO ENDING
*
FFERR48  LA    R15,X'48'(0,0)           CONSTANT TO R15
         ST    R15,RETCDE               SET INTERNAL RETURN CODE
         BAL   R10,MSGPUT               PUT OUT THE MESSAGE
         B     FFEND                    GO TO ENDING
*
FFEND    L     R10,FFR10SAV             RESTORE RETURN ADDRESS
         BR    R10                      RETURN
         EJECT
**********************************************************************
***                                                                ***
***     MOVE LINE NUMBERS IN RECFM=F TO V CONVERSION               ***
***                                                                ***
***     AT ENTRY, OUTBEGIN POINTS TO DATAWK20                      ***
***                                                                ***
**********************************************************************
FVNUM    ST    R10,FVR10SAV             SAVE RETURN ADDRESS
         XC    RETCDE,RETCDE            SET ERROR CODE TO ZERO
*
         CLI   KNUM+1,X'01'             IF 'NUM' OPERAND NOT IN USE
         BNE   FVEND                      BYPASS THIS PROCESS
*
         LA    R4,DATAWKM8              POINT 8 PLACES BEFORE RECORD
         ST    R4,OUTBEGIN              RESET POINTER
         MVC   DATAWKM8(4),DATAWK20     MOVE RCW TO NEW BEGINNING
         LH    R5,DATAWKM8              R5 IS LENGTH OF RECORD
         C     R5,F12                   IF LESS THAN 12
         BL    FVERR48                    BRANCH TO ERROR
         LA    R5,DATAWKM8(R5)          R5 POINTS TO OLD LINE NUMBER
         MVC   DATAWKM8+4(8),0(R5)      MOVE OLD LINE NUMBER TO NEW
         B     FVEND                    GO TO END OF ROUTINE
*
FVERR48  LA    R15,X'48'(0,0)           CONSTANT TO R15
         ST    R15,RETCDE               SET INTERNAL RETURN CODE
         BAL   R10,MSGPUT               PUT OUT THE MESSAGE
         B     FVEND                    GO TO ENDING
*
FVEND    L     R10,FVR10SAV             RESTORE RETURN ADDRESS
         BR    R10                      RETURN
         EJECT
**********************************************************************
***                                                                ***
***     MOVE LINE NUMBERS IN RECFM=V TO F CONVERSION               ***
***                                                                ***
***     AT ENTRY, OUTBEGIN POINTS TO DATAWK28                      ***
***                                                                ***
**********************************************************************
VFNUM    ST    R10,VFR10SAV             SAVE RETURN ADDRESS
         XC    RETCDE,RETCDE            SET ERROR CODE TO ZERO
*
         CLI   KNUM+1,X'01'             IF 'NUM' OPERAND NOT IN USE
         BNE   VFEND                      BYPASS THIS PROCESS
*
         LA    R4,DATAWK28              R4 POINTS TO NONUM OUT AREA
         LA    R5,DATAWK36              R5 POINTS TO NUM OUTPUT AREA
         ST    R5,OUTBEGIN              UPDATE POINTER
         LH    R5,LRECLO                R5 IS LENGTH OF OUTPUT REC
         C     R5,F8                    IF LESS THAN 8
         BL    VFERR48                    BRANCH TO ERROR
         LA    R5,DATAWK28(R5)          R5 POINTS TO NUM LINENO AREA
         MVC   0(8,R5),DATAWK28         MVE NONUM LINENO TO NUM LINENO
         B     VFEND                    GO TO END OF ROUTINE
*
VFERR48  LA    R15,X'48'(0,0)           CONSTANT TO R15
         ST    R15,RETCDE               SET INTERNAL RETURN CODE
         BAL   R10,MSGPUT               PUT OUT THE MESSAGE
         B     VFEND                    GO TO ENDING
*
VFEND    L     R10,VFR10SAV             RESTORE RETURN ADDRESS
         BR    R10                      RETURN
         EJECT
**********************************************************************
***                                                                ***
***     PUT AN OUTPUT RECORD                                       ***
***                                                                ***
**********************************************************************
PTREC    ST    R10,PTR10SAV             SAVE RETURN ADDRESS
         XC    RETCDE,RETCDE            SET ERROR CODE TO ZERO
*
         L     R4,OUTBEGIN              ADDRESS OF OUTPUT AREA
         PUT   OUTDCB,(R4)              PUT THE RECORD
*
PTEND    L     R10,PTR10SAV             RESTORE RETURN ADDRESS
         BR    R10                      RETURN
         EJECT
**********************************************************************
***                                                                ***
***     PUT A PUTLINE MESSAGE                                      ***
***                                                                ***
***                                                                ***
***   +++  NOTE, RETCDE IS AN INPUT ARGUMENT.  IS NOT ZEROED.      ***
***                                                                ***
**********************************************************************
MSGPUT   ST    R10,MSR10SAV             SAVE RETURN ADDRESS
*
         L     R4,RETCDE                R4 HAS OFFSET (MESSAGE NUMBER)
         L     R4,MSGTBLA(R4)           R4 HAS ADDR OF MESSAGE
         ST    R4,MYOLD+4               ADDRESS INTO O.L.D.
*
         PUTLINE PARM=MYPTPB,OUTPUT=MYOLD,MF=(E,MYIOPL)
*
MSEND    L     R10,MSR10SAV             RESTORE RETURN ADDRESS
         BR    R10                      RETURN
         EJECT
**********************************************************************
***                                                                ***
***   DATA CONSTANTS                                               ***
***                                                                ***
**********************************************************************
CONSTDTA DS    0D                       AREA FOR DATA CONSTANTS
VPARMPCL DC    V(PARMPCL)               ADDR OF PARM CONTROL LIST
DZIPS    DS    0D                       DOUBLE WORD OF ZEROES
         DC    2F'0'
BLANKS   DC    CL80' '                  10 DOUBLE WORDS OF BLANKS
DD1      GTEDADAT  DDNAM=X,INDSN=X,RTMEM=X,INORG=X
DS1      GTEDADAT  DSNAM=X
DS2      GTEDADAT  DSNAM=X,RTDDN=X,MEMBR=X,                            X
               STATS=SHR,NDISP=KEEP,CDISP=KEEP
DD2      GTEDADAT  DDNAM=X,INDSN=X,RTMEM=X,INORG=X
DS3      GTEDADAT  DSNAM=X
DS4      GTEDADAT  DSNAM=X,RTDDN=X,MEMBR=X,                            X
               STATS=SHR,NDISP=KEEP,CDISP=KEEP
DD3      GTEDADAT  DDNAM=X,INORG=X,RTMEM=X
*
MSGTBLA  DC    A(MSG00),A(MSG04),A(MSG08),A(MSG0C)
         DC    A(MSG10),A(MSG14),A(MSG18),A(MSG1C)
         DC    A(MSG20),A(MSG24),A(MSG28),A(MSG2C)
         DC    A(MSG30),A(MSG34),A(MSG38),A(MSG3C)
         DC    A(MSG40),A(MSG44),A(MSG48)
*
ENQPROTO ENQ   (QNAM1,,E,,SYSTEM),RET=NONE,MF=L
DEQPROTO ENQ   (QNAM1,,E,,SYSTEM),RET=NONE,MF=L
QNAM1    DC    CL8'USERDSN'             MAJOR NAME
         DS    0D
DCBPROTI DCB   DSORG=PS,MACRF=GM,EODAD=COEOF
DCBILEN  EQU   *-DCBPROTI
         DS    0D
DCBPROTO DCB   DSORG=PS,MACRF=PM
DCBOLEN  EQU   *-DCBPROTO
OPENLI   OPEN  (,(INPUT)),MF=L
OPENLO   OPEN  (,(OUTPUT)),MF=L
OPENLOX  OPEN  (,(EXTEND)),MF=L
CLOSPRTI CLOSE (,),MF=L                 CLOSE PARM LIST, INPUT FILE
CLOSPRTO CLOSE (,),MF=L                 CLOSE PARM LIST, OUTPUT FILE
ENDWORD  DC    X'00070000',C'END'       LITERAL 'END', LENGTH 7
F4       DC    F'4'                     CONSTANT
F8       DC    F'8'                     CONSTANT
F12      DC    F'12'                    CONSTANT
F320     DC    F'320'                   CONSTANT
GTPBPROT GETLINE MF=L
PTPBPROT PUTLINE MF=L
OLDPROT  DC    F'1',A(0)
*SG--  DC  H'--',H'0',C'SCY00--E .+....2....+....3....+....4....+....5.X
               ...+....6....+....7
MSG00  DC  H'36',H'0',C'SCY0000I COPY OPERATION COMPLETE'
MSG04  DC  H'50',H'0',C'SCY0004E ''TO'' DATASET OR FILE NAME IS REQUIREX
               D'
MSG08  DC  H'49',H'0',C'SCY0008E UNABLE TO ALLOCATE ''TO'' FILE/DD NAMEX
               '
MSG0C  DC  H'49',H'0',C'SCY000CE UNABLE TO ALLOCATE ''TO'' DATASET NAMEX
               '
MSG10  DC  H'51',H'0',C'SCY0010E UNABLE TO ALLOCATE ''FROM'' DATASET NAX
               ME'
MSG14  DC  H'51',H'0',C'SCY0014E UNABLE TO ALLOCATE ''FROM'' FILE/DD NAX
               ME'
MSG18  DC  H'52',H'0',C'SCY0018E ''FROM'' DATASET OR FILE NAME IS REQUIX
               RED'
MSG1C  DC  H'38',H'0',C'SCY001CE UNABLE TO OPEN INPUT FILE'
MSG20  DC  H'39',H'0',C'SCY0020E UNABLE TO OPEN OUTPUT FILE'
MSG24  DC  H'39',H'0',C'SCY0024E UNABLE TO CLOSE INPUT FILE'
MSG28  DC  H'40',H'0',C'SCY0028E UNABLE TO CLOSE OUTPUT FILE'
MSG2C  DC  H'55',H'0',C'SCY002CE UNABLE TO READ DATA FROM TERMINAL OR CX
               LIST'
MSG30  DC  H'60',H'0',C'SCY0030E UNABLE TO PROCESS INPUT OR OUTPUT RECOX
               RD FORMAT'
MSG34  DC  H'65',H'0',C'SCY0034E UNABLE TO CONVERT FROM INPUT TO OUTPUTX
                RECORD FORMAT'
MSG38  DC  H'67',H'0',C'SCY0038E ''TO'' MEMBER NAME IS REQUIRED.  DATASX
               ET IS PARTITIONED.'
MSG3C  DC  H'69',H'0',C'SCY003CE ''FROM'' MEMBER NAME IS REQUIRED.  DATX
               ASET IS PARTITIONED.'
MSG40  DC  H'69',H'0',C'SCY0040E ''MOD'' IS INVALID WHEN COPYING INTO AX
                PARTITIONED DATASET'
MSG44  DC  H'55',H'0',C'SCY0044E ''FROM'' AND ''TO'' DATASETS MUST BE DX
               IFFERENT'
MSG48  DC  H'61',H'0',C'SCY0048E RECORD TOO SHORT FOR LINE NUMBER.  USEX
                ''NONUM.'''
*
CONSTEND DS    0D
CONSTLEN EQU   *-CONSTDTA               TOTAL LENGTH OF CONSTANTS
*
         EJECT
**********************************************************************
***                                                                ***
***    COMMAND OPERANDS                                            ***
***                                                                ***
**********************************************************************
PARMPCL  IKJPARM  DSECT=PARMPDL
*
KFROMDSN IKJKEYWD
         IKJNAME 'FROMDSNAME',SUBFLD=SFROMDSN
         IKJNAME 'FROMDATASET',SUBFLD=SFROMDSN
*
KFROMDDN IKJKEYWD
         IKJNAME 'FROMDDNAME',SUBFLD=SFROMDDN
         IKJNAME 'FROMFILE',SUBFLD=SFROMDDN
*
KTODSN   IKJKEYWD
         IKJNAME 'TODSNAME',SUBFLD=STODSN
         IKJNAME 'TODATASET',SUBFLD=STODSN
*
KTODDN   IKJKEYWD
         IKJNAME 'TODDNAME',SUBFLD=STODDN
         IKJNAME 'TOFILE',SUBFLD=STODDN
*
KNUM     IKJKEYWD DEFAULT='NONUM'
         IKJNAME 'NUM'
         IKJNAME 'NONUM'
*
KMOD     IKJKEYWD DEFAULT='OLD'
         IKJNAME 'MOD'
         IKJNAME 'OLD'
*
SFROMDSN IKJSUBF
EFROMDSN IKJPOSIT DSTHING,USID,PROMPT='''FROM'' DATASET NAME'
*
SFROMDDN IKJSUBF
EFROMDDN IKJPOSIT DSNAME,DDNAM,PROMPT='''FROM'' DD/FILE NAME'
*
STODSN   IKJSUBF
ETODSN   IKJPOSIT DSNAME,USID,PROMPT='''TO'' DATASET NAME'
*
STODDN   IKJSUBF
ETODDN   IKJPOSIT DSNAME,DDNAM,PROMPT='''TO'' DD/FILE NAME'
*
         IKJENDP
*
         EJECT
**********************************************************************
***                                                                ***
***   DATA AREA OBTAINED WITH LINKSAVE                             ***
***                                                                ***
**********************************************************************
WORK0    DSECT                          AREA-0 FOR VARIABLES
MYSAVE   DS    18F                      REGISTER SAVE AREA
CPPLPTR  DS    F                        INITIAL VALUE OF R1 (CPPLADDR)
RETCDE   DS    F                        INTERNAL RETURN CODE
COMPCODE DS    F                        PROGRAM COMPLETION CODE
*
         EJECT
**********************************************************************
***                                                                ***
***  DATA VARIABLES                                                ***
***                                                                ***
**********************************************************************
WORK1    DSECT                          AREA-1 FOR VARIABLES
PPR10SAV DS    F                        RETURN ADDRESS SAVE AREA
PAR10SAV DS    F                        RETURN ADDRESS SAVE AREA
IOR10SAV DS    F                        RETURN ADDRESS SAVE AREA
GER10SAV DS    F                        RETURN ADDRESS SAVE AREA
ENR10SAV DS    F                        RETURN ADDRESS SAVE AREA
DER10SAV DS    F                        RETURN ADDRESS SAVE AREA
DSR10SAV DS    F                        RETURN ADDRESS SAVE AREA
DDR10SAV DS    F                        RETURN ADDRESS SAVE AREA
DFR10SAV DS    F                        RETURN ADDRESS SAVE AREA
DGR10SAV DS    F                        RETURN ADDRESS SAVE AREA
OPR10SAV DS    F                        RETURN ADDRESS SAVE AREA
SER10SAV DS    F                        RETURN ADDRESS SAVE AREA
CLR10SAV DS    F                        RETURN ADDRESS SAVE AREA
COR10SAV DS    F                        RETURN ADDRESS SAVE AREA
GTR10SAV DS    F                        RETURN ADDRESS SAVE AREA
EDR10SAV DS    F                        RETURN ADDRESS SAVE AREA
PTR10SAV DS    F                        RETURN ADDRESS SAVE AREA
MSR10SAV DS    F                        RETURN ADDRESS SAVE AREA
FFR10SAV DS    F                        RETURN ADDRESS SAVE AREA
FVR10SAV DS    F                        RETURN ADDRESS SAVE AREA
VFR10SAV DS    F                        RETURN ADDRESS SAVE AREA
MYPPL    DS    7F                       PARSE PARAMETER LIST
MYECB    DS    F                        ECB FOR PARSE
MYANS    DS    F                        POINTER TO THE PDL
MYIOPL   DS    4F                       IOP LIST FOR PUT/GET LINE
MYPTPB   DS    3F                       PUTLINE PARM BLOCK
MYGTPB   DS    2F                       GETLINE PARM BLOCK
MYOLD    DS    2F                       OUTPUT LINE DESCRIPTR BLOCK
RLEN1    DS    H                        MINOR QUEUE NAME LENGTH
RLEN2    DS    H                        FROM DATASET NAME LENGTH
RNAM1    DS    CL44                     MINOR QUEUE NAME
RNAM2    DS    CL44                     FROM DATASET NAME
RDDN1    DS    CL8                      RETURNED DDNAME
RDDN2    DS    CL8                      RETURNED DDNAME
RMEM1    DS    CL8                      MEMBER NAME
RMEM2    DS    CL8                      MEMBER NAME
RMEMLEN1 DS    H                        LENGTH OF MEMBER NAME
RMEMLEN2 DS    H                        LENGTH OF MEMBER NAME
RECFMI   DS    BL1                      INPUT RECORD FORMAT
RECFMO   DS    BL1                      OUTPUT RECORD FORMAT
DDA      GTEDADAT  MAP=ONLY,DDNAM=X,INDSN=X,RTMEM=X,INORG=X
DSA      GTEDADAT  MAP=ONLY,DSNAM=X
DSB      GTEDADAT  MAP=ONLY,DSNAM=X,RTDDN=X,MEMBR=X,                   X
               STATS=SHR,NDISP=KEEP,CDISP=KEEP
DDB      GTEDADAT  MAP=ONLY,DDNAM=X,INDSN=X,RTMEM=X,INORG=X
DSC      GTEDADAT  MAP=ONLY,DSNAM=X
DSD      GTEDADAT  MAP=ONLY,DSNAM=X,RTDDN=X,MEMBR=X,                   X
               STATS=SHR,NDISP=KEEP,CDISP=KEEP
DDC      GTEDADAT  MAP=ONLY,DDNAM=X,INORG=X,RTMEM=X
ENQLIST  DS    3F                       PARM LIST FOR ENQUEUE
DEQLIST  DS    3F                       PARM LIST FOR DEQUEUE
OPENLIST DS    2F                       PARM LIST FOR OPEN
CLOSLIST DS    2F                       PARM LIST FOR CLOSE
OUTDCB   DCB   DSORG=PS,MACRF=PM
INDCB    DCB   DSORG=PS,MACRF=GM,EODAD=COEOF
BLKSIZE  DS    H                        LARGEST OF INPUT/OUTPUT BLKSIZE
USESIZE  DS    H                        SIZE USED FOR WORK2 GETMAIN
BLKSIZEI DS    H                        INPUT BLOCKSIZE
BLKSIZEO DS    H                        OUTPUT BLOCKSIZE
LRECLI   DS    H                        INPUT LRECL
LRECLO   DS    H                        OUTPUT LRECL
SWITCH1  DC    B'00000000'              SWITCHES AREA #1
*                1.......   X'80'         FROMDSN(*) IS IN USE
*                .1......   X'40'         INPUT RECFM IS F
*                ..1.....   X'20'         INPUT RECFM IS V
*                ...1....   X'10'         OUTPUT RECFM IS F
*                ....1...   X'08'         OUTPUT RECFM IS V
ENDCK    DS    CL7                      WORK AREA FOR 'END'
TEMPNUM  DS    CL8                      TEMP STORAGE FOR LINE NUMBER
OUTBEGIN DS    F
*
WORK1END DS    0D
WORK1LEN EQU   *-WORK1                  TOTAL LENGTH OF WORK-1 AREA
         EJECT
**********************************************************************
***                                                                ***
***     DATA WORK AREA                                             ***
***                                                                ***
**********************************************************************
WORK2    DSECT
DATAWKM8 DS    XL8   OUTPUT AREA FOR RECFM=F TO V CONVERSION (NUM)
DATAWK20 DS    XL4   OUTPUT AREA FOR RECFM=F TO V CONVERSION (NONUM)
DATAWK24 DS    XL4   OUTPUT AREA FOR RECFM=F TO F AND RECFM=V TO V
DATAWK28 DS    XL8   OUTPUT AREA FOR RECFM=V TO F CONVERSION (NONUM)
DATAWK36 DS    XL4   OUTPUT AREA FOR RECFM=V TO F CONVERSION (NUM)
         EJECT
**********************************************************************
***                                                                ***
***   MAPPING MACROS                                               ***
***                                                                ***
**********************************************************************
         CVT   DSECT=YES              , CVTMAP FOR IKJPARS
         PRINT GEN
         IKJCPPL                        COMMAND PROCESSOR PARM LIST
         IKJPPL                         PARSE PARM LIST
         IKJIOPL                        IO PARM LIST FOR GET/PUTLINE
         IKJGTPB                        GETLINE PARM BLOCK
         IKJPTPB                        PUTLINE PARM BLOCK
         PRINT NOGEN
         IEFZB4D0                       MAPS SVC-99 CONTROL BLOCKS
         IKJEFFDF DFDSECT=YES,DFDSEC2=YES  MAPS IKJEFF18 CONTROL BLOCKS
         IHADCB DSORG=PS,DEVD=DA      , MAPS THE DCB FOR DA DEVICES
         END
