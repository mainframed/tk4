UICM     TITLE 'UICMON OBTAINS UNREFERENCED INTERVAL COUNT FOR JOB'
*   THIS PROGRAM WAS INSPIRED BY JACK MACLEAN'S VARIABLE STORAGE FENCE.
*ITS PURPOSE IS TO MONITOR THE UNREFERENCED INTERVAL COUNT RECEIVED BY
*AN IMPORTANT ON-LINE JOB, SO THAT THIS INFORMATION CAN BE CORRELATED
*WITH THE PERFORMANCE OR RESPONSE TIME OF THE ON-LINE SYSTEM.
*THIS VERSION OF THE PROGRAM CAN ONLY MONITOR THE UNREFERENCED INTERVAL
*COUNT FOR ONE JOB, AND CANNOT MONITOR THE UIC FOR A STARTED TASK.
*   THE NAME OF THE ON-LINE JOB MUST BE SPECIFIED IN THE PARM FIELD ON
*THE EXEC STATEMENT FOR UICMON.  THE ONLY REQUIRED DD CARD, OTHER THAN
*STEPLIB, IS SYSPRINT, WITH RECFM=FB AND LRECL=80.  OUTPUT WRITTEN TO
*SYSPRINT CONSISTS OF THREE PARTS.  THE FIRST IS A LOG OF ALL SAMPLES
*TAKEN, GIVING TIME AND UIC VALUE.  THE SECOND GIVES THE NUMBER OF TIMES
*EACH UIC VALUE WAS ENCOUNTERED, AND THE THIRD GIVES THE AVERAGE UIC
*VALUE ROUNDED TO THE NEAREST INTEGER.
*   IF SYMBOL INTVL IN THE ASSEMBLY IS SET TO A TIME INTERVAL JUST
*LESS THAN THE DETECTED WAIT TIME ON THE CPU BEING USED, THE PROGRAM
*WILL KEEP ITSELF SWAPPED IN MOST OF THE TIME, AND NEED NOT BE MADE
*NON-SWAPPABLE.
         EJECT
         MACRO
&NAME    PROGRAM &BASE,&SAVE=SAVE,&EXIT=EXIT,&EXN=,&WTO=NO,&RENT=NO,   .
               &VER=,&ROUTCDE=2,&REGEQ=YES,&WORKA=0,&DATE=YES,&PATCH=0
.*       NOTE... THIS MACRO USES GLOBALS &SYSDATE AND &SYSTIME
.*               WHICH ARE ONLY AVAILABLE IN ASSEMBLERS XF AND H
         GBLB  &REGEQS
         LCLA  &A,&B,&C,&D,&E,&F
         LCLB  &FAIL,&B13
         LCLC  &GNAM
&GNAM    SETC  'IHB'.'&SYSNDX'
&FAIL    SETB  0
&D       SETA  K'&NAME
.*CW*&F    SETA  72+(8*&WORKA)   DON'T REQUIRE WORKA TO BE NUMERIC *CW*
         AIF   ('&DATE' EQ 'NO').T0
&D       SETA  &D+17                  CHANGED FROM 15 (ASMG ONLY?) *CW*
.T0      AIF   (T'&VER EQ 'O').T1
&D       SETA  &D-1+K'&VER
.T1      AIF   ('&NAME' NE '').T2
.E1      MNOTE 12,'CSECT NAME IS REQUIRED'
&FAIL    SETB  1
.T2      AIF   (N'&BASE GE 1).T3
.E2      MNOTE 12,'AT LEAST ONE BASE REG IN RANGE 2-12 MUST BE SPECIFIE.
               D'
&FAIL    SETB  1
.T3      AIF   (N'&BASE LE 11).T4
.E3      MNOTE 12,'MORE THAN 11 REGISTERS SPECIFIED IN &BASE'
&FAIL    SETB  1
.T4      AIF   (&BASE(1) NE 13).TEST
&B13     SETB  1
&A       SETA  2
         AIF   ('&RENT' EQ 'YES').E5
         AGO   .TEST2
.TEST    ANOP
&A       SETA  1
.TEST1   AIF   (&BASE(&A) LT 2 OR &BASE(&A) GT 12).E4
&A       SETA  &A+1
.TEST2   ANOP
         AIF   (&A LE N'&BASE).TEST1
         AIF   (&FAIL).END
&NAME    CSECT
         USING &NAME,15                TEMPORARY BASE REG
         B     &GNAM.A                 BRANCH AROUND NAME
         DC    AL1(&D)                 COUNT
         DC    C'&NAME'                NAME
         AIF   ('&DATE' EQ 'NO').NODAT
         DC    C' &SYSDATE &SYSTIME'   DATE-TIME OF ASSEMBLY
.NODAT   AIF   (T'&VER EQ 'O').NOVER
         DC    C' ',C&VER              VERSION
.NOVER   ANOP
&GNAM.A  STM   14,12,12(13)            SAVE REGS
         AIF   ('&RENT' EQ 'YES').RENT1
         LR    14,13                   CHAIN SAVE AREAS
         ST    13,&SAVE.+4
         LA    13,&SAVE
         ST    13,8(14)                FOR & BACK CHAINING
         AGO   .RENT2
.RENT1   ANOP
         LR    &BASE(1),13             CHAIN SAVE AREAS
&GNAM.W  EQU   ((72+&WORKA+7)/8)*8     LENGTH OF GETMAINED AREA    *CW*
         MNOTE  *,'GETMAIN  R,LV=&GNAM.W     GET A SAVE AREA'      *CW*
         GETMAIN  R,LV=&GNAM.W             GET A SAVE AREA         *CW*
         ST    &BASE(1),4(1)
         LR    13,1
         LM    14,1,12(&BASE(1))       RESTORE REG 14,15,0 & 1
         ST    13,8(&BASE(1))          FOR & BACK CHAINING
.RENT2   ANOP
         DROP  15                      RELEASE TEMP BASE
         AIF   (&B13).ISB13
         LR    &BASE(1),15
         USING &NAME,&BASE(1)          FIRST BASE REG
         AGO   .NOTB13
.ISB13   USING &SAVE,13                BASE REGISTER
.NOTB13  ANOP
&A       SETA  1
.LOOP1   AIF   (N'&BASE EQ &A).OUT
&A       SETA  &A+1
&B       SETA  (&A-2)*4
&C       SETA  4096*(&A-1)
         L     &BASE(&A),&GNAM.+&B     LOAD NEXT BASE
         USING &NAME.+&C,&BASE(&A)
         AGO   .LOOP1
.OUT     AIF   ('&EXN' EQ '').OUT1
         B     &EXN
         AGO   .OUT2
.OUT1    B     &GNAM.B
.OUT2    AIF   ('&RENT' EQ 'YES').OUT3
&SAVE    DC    18F'0'                  SAVE AREA
.OUT3    ANOP
         AIF   (N'&BASE EQ 1).PASS
&A       SETA  1
&GNAM    DC    A(&NAME.+4096)          ADCONS FOR BASE REGS
.LOOP2   ANOP
&A       SETA  &A+1
         AIF   (N'&BASE EQ &A).PASS
&B       SETA  4096*&A
         DC    A(&NAME.+&B)
         AGO   .LOOP2
.PASS    ANOP
         AIF   (&PATCH LE 0).NOPATCH                               *CW*
&F       SETA  0                                                   *CW*
PATCH    DS    0H                      START OF PATCH SPACE        *CW*
.PATGEN  DC    S(*)                                                *CW*
&F       SETA  &F+2                                                *CW*
         AIF   (&F LE &PATCH).PATGEN                               *CW*
.NOPATCH ANOP  ,                                                   *CW*
&EXIT    DS    0H
         AIF   ('&WTO' NE 'YES').EXIT1
         STM   15,1,16(13)             SAVE 15 - 1
         WTO   '&NAME ENDED',ROUTCDE=&ROUTCDE
         LM    15,1,16(13)             RESTORE 15 - 1
.EXIT1   L     13,4(13)
         AIF   ('&RENT' NE 'YES').EXIT2
         STM   0,1,20(13)              SAVE 0 & 1 AROUND FREEMAIN
         L     1,8(13)                 AREA TO BE RELEASED
         MNOTE  *,'FREEMAIN  R,LV=&GNAM.W,A=(1)    FREE SAVE AREA' *CW*
         FREEMAIN  R,LV=&GNAM.W,A=(1)  FREE SAVE AREA              *CW*
         LM    0,1,20(13)              RESTORE 0 & 1
.EXIT2   MVI   12(13),X'FF'            MARK SAVE AREA USED
         L     14,12(13)               RESTORE 14
         LM    2,12,28(13)             RESTORE 2-12
         BR    14                      RETURN
&GNAM.B  DS    0H
.REGEQ   AIF   ('&REGEQ' NE 'YES' OR &REGEQS).END
*
*              REGISTER EQUATES
*
R0       EQU   0
R1       EQU   1
R2       EQU   2
R3       EQU   3
R4       EQU   4
R5       EQU   5
R6       EQU   6
R7       EQU   7
R8       EQU   8
R9       EQU   9
R10      EQU   10
R11      EQU   11
R12      EQU   12
R13      EQU   13
R14      EQU   14
R15      EQU   15
&REGEQS  SETB  1
         AGO   .END
.E4      MNOTE 12,'ONE OR MORE OF BASE REGISTERS &BASE NOT IN RANGE 2-1.
               2 (13 CAN ONLY BE FIRST BASE REG.)'
         AGO   .END
.E5      MNOTE 12,'BASE REGISTER 13 CANT BE USED IN RE-ENTRANT PROGRAM'
.END     EJECT
         MEND
         EJECT
UICMON   PROGRAM 12,VER='IMSMON'
*                                 OBTAIN TARGET JOBNAME FROM PARM FIELD
         L     R1,0(,1)           LOAD ADDRESS OF PARM FIELD
         LH    R2,0(,R1)          LOAD LENGTH OF PARM FIELD
         LTR   R2,R2              IS THERE A PARM FIELD?
         BNP   BEGIN              USE DEFAULT OF I9900000 IF NOT
         MVC   JSOUGHT,BLANKS     BLANK OUT IN CASE JOBNAME IS SHORT
         LA    R8,8               LOAD MAXIMUM LENGTH
         CR    R2,R8              TEST FOR PARM TOO LONG
         BNH   *+6                SKIP NEXT IF NOT
         LR    R2,R8              ELSE USE MAX
         BCTR  R2,0               LESS ONE FOR MVC
         EX    R2,GETJOBN         MOVE JOBNAME FROM PARM FIELD
BEGIN    L     R2,16              LOAD ADDRESS OF CVT
         LA    R8,4               LIMIT SEARCH
FINDJOB  L     R3,564(,R2)        CVTASCBH = GET HIGHEST ASCB IN SYSTEM
*                                 IT SHOULD BE ASCB OF *MASTER*
NEXTASCB L     R4,4(,R3)          ASCBFWDP = NEXT LOWER PRIORITY ASCB
         CLC   0(4,R4),ASCBID     MAKE SURE IT'S AN ASCB
         BE    GETNAME            IF SO, IDENTIFY IT
         BCT   R8,FINDJOB         IF CHAIN BROKEN, TRY AGAIN
         ABEND 99,DUMP            LOSE PATIENCE AND QUIT
GETJOBN  MVC   JSOUGHT(1),2(R1)   *** EXECUTED INSTRUCTION ***
GETNAME  L     R5,172(,R4)        ASCBJBNI = JOBNAME
         LR    R3,R4              COPY ASCB ADDRESS FOR LOOP
         CLC   0(8,R5),JSOUGHT    IS IT THE JOB WE WANT?
         BNE   NEXTASCB           SEARCH ASCB CHAIN IF NOT
         LA    R9,LBUCKET
         GETMAIN R,LV=(R9)        GET CORE FOR COUNTERS
         LR    R6,R1              SAVE ADDRESS OF COUNTER AREA
         LR    R8,R1              COPY ADDRESS TO EVEN REGISTER
         SR    R15,R15            SETUP TO CLEAR CORE BY MVCL
         SR    R14,R14            MEANINGLESS WHEN R15 = 0
         MVCL  R8,R14             CLEAR GOTTEN CORE
*
         OPEN  (PRINT,(OUTPUT))   OPEN PRINT DATA SET
         BAL   R11,DOWTOR         PUT UP OUTSTANDING REPLY
         LA    R2,1               USEFUL CONSTANT = 1
*
*                                 INITIALIZATION COMPLETE
*                                 BEGIN DATA GATHERING LOOP
*
RESET    MVC   BUFFER,BUFFER-1    CLEAR PRINT BUFFER
         LA    R10,BUFFER-16      POINT TO START OF BUFFER
         LA    R8,5               BUFFER CONTAINS 5 16-BYTE SLOTS
*
LOOK     LA    R10,16(,R10)       ADVANCE TO NEXT BUFFER SLOT
         CLC   0(4,R4),ASCBID     VERIFY WE STILL HAVE ASCB
         BNE   CLEANUP            STOP MONITOR IF NOT
         L     R3,148(,R4)        ASCBOUXB = ADDRESS OF OUXB
         TM    134(R3),X'80'      VALIDATE NOT NEGATIVE
         BZ    *+6                CONTINUE IF OK
         DC    H'0'               ELSE DUMP
         LH    R3,134(,R3)        OUXBUIC = HIGH UIC FOR ADDRESS SPACE
         CH    R3,NBUCKET         IS IT ABOVE MAX WE COUNT?
         BL    *+8                BRANCH IF NOT
         LH    R3,NBUCKET         PRETEND IT EQUALS OUR MAX
*
         TIME  DEC                GET A TIME STAMP
         ST    0,WORK             STORE HHMMSSTH, UNPACK ONE MORE
         UNPK  2(9,R10),WORK(5)   MOVE TIME STAMP TO OUTPUT BUFFER
         MVI   10(R10),C' '       CLEAN UP EXTRA BYTE
         CVD   R3,WORK
         OI    WORK+7,X'0F'
         UNPK  12(4,R10),WORK     MOVE MEASURED UIC TO OUTPUT BUFFER
*
         AR    R3,R3              DOUBLE UIC FOR 2 BYTE INDEXING
         LH    R1,0(R3,R6)        LOAD CONTENTS OF APPROPRIATE BUCKET
         AR    R1,R2              ADD ONE
         STH   R1,0(R3,R6)        STORE UPDATED COUNT IN BUCKET
*
         LH    R1,NUMINTVL        COUNT OF PREVIOUS STIMERS
         AR    R1,R2              ADD ONE
         CH    R1,MAXINTVL        MAXIMUM EXCEEDED?
         BH    CLEANUP            END JOB IF SO
         STH   R1,NUMINTVL        ELSE STORE UPDATED COUNT
*
         XC    TIMECB,TIMECB      CLEAR STIMER ECB
         STIMER REAL,TIMEXIT,BINTVL=INTVL   START TIME INTERVAL
*                                 EXIT ROUTINE IS NEEDED SO THAT
*                                 WE CAN WAIT ON 2 ECB'S
         WAIT  ECBLIST=ECBLST,LONG=NO   TRY TO GET SOME RESPONSE
*
         TM    WTORECB,X'40'      WAS OUTSTANDING REPLY ANSWERED?
         BZ    NEXTNTVL           IF NOT, MUST HAVE BEEN TIMER
         TTIMER CANCEL            CLEAN UP FOR NEW STIMER
         CLC   REPLY,ENDREPLY     WAS PROPER REPLY ENTERED?
         BE    CLEANUP            PERFORM DATA ANALYSIS IF SO
         BAL   R11,DOWTOR         ELSE REINSTATE THE WTOR
*
NEXTNTVL BCT   R8,LOOK            GO BACK FOR ANOTHER LOOK
*                                 HERE IF BUFFER WAS FILLED
         PUT   PRINT,BUFFER       SO WRITE IT OUT
         B     RESET              GO CLEAR BUFFER AND CONTINUE
         EJECT
CLEANUP  PUT   PRINT,BUFFER       PUT OUT INCOMPLETE BUFFER
         LA    R2,2               LENGTH OF INDIVIDUAL BUCKET
         LA    R3,LBUCKET         LENGTH OF ALL BUCKETS
         AR    R3,R6              END OF BUCKET AREA
         LR    R11,R6             POINT TO FIRST BUCKET
         SR    R9,R9              INITIALIZE UIC NUMBER
         MVC   BUFFER,BUFFER-1    CLEAR PRINT BUFFER AGAIN
         SR    R4,R4              INITIALIZE TOTAL
         SR    R5,R5              INITIALIZE COUNTER
RESET2   LA    R10,BUFFER-10
         LA    R8,8               8 SLOTS OF 10 BYTES EACH
         MVC   BUFFER,BUFFER-1    CLEAR THE BUFFER AGAIN
COUNTEM  LH    R15,0(,R11)        LOAD CONTENTS OF BUCKET
         LA    R10,10(,R10)       BUMP BUFFER POINTER
         CVD   R9,WORK
         OI    WORK+7,X'0F'       CLEAN UP SIGN
         UNPK  1(3,R10),WORK      MOVE UIC VALUE TO PRINTOUT
         CVD   R15,WORK
         OI    WORK+7,X'0F'
         UNPK  5(5,R10),WORK      PRINT COUNT FOR THIS VALUE
         AR    R5,R15             ADD TO COUNTER
         MR    R14,R9             MULTIPLY BY UIC FOR BUCKET
         AR    R4,R15             ADD TO TOTAL
         LA    R9,1(,R9)          INCREMENT VALUE OF UIC
         BCT   R8,NEXTSLOT        CHECK FOR FULL BUFFER
         PUT   PRINT,BUFFER       PUT OUT PRINT RECORD IF SO
         BXLE  R11,R2,RESET2      GO CLEAR BUFFER AND CONTINUE
         B     GETAVG             TERMINATE THE PROGRAM
NEXTSLOT BXLE  R11,R2,COUNTEM     CONTINUE WITH NEXT UIC VALUE
GETAVG   PUT   PRINT,BUFFER       PRINT INCOMPLETE BUFFER
         LR    R15,R5             COPY INTERVAL COUNT
         SRL   R15,1              HALVE TO GET ROUNDING FACTOR
         AR    R15,R4             ADD ROUNDING FACTOR TO TOTAL
         SR    R14,R14            CLEAR HIGH REGISTER FOR DIVIDE
         DR    R14,R5             COMPUTE AVERAGE HIGH UIC FOR JOB
         MVC   BUFFER,BUFFER-1    CLEAR BUFFER ONE LAST TIME
         CVD   R5,WORK
         OI    WORK+7,X'0F'
         UNPK  BUFFER+1(8),WORK   MOVE INTERVAL COUNT TO BUFFER
         CVD   R15,WORK
         OI    WORK+7,X'0F'
         UNPK  BUFFER+11(3),WORK  MOVE AVERAGE HIGH UIC TO BUFFER
         PUT   PRINT,BUFFER       PRINT ONE LAST RECORD
*
         CLOSE (PRINT)            CLOSE PRINT DATA SET
         BCR   0,0                ZAP TO ABEND IF NEEDED
         B     EXIT               AND TERMINATE THE PROGRAM
         EJECT
DOWTOR   EQU   *
         XC    WTORECB,WTORECB    CLEAR ECB USED BY WTOR
         WTOR  'REPLY ''ENDXB'' TO BRING DOWN UIC MONITOR',            *
               REPLY,REPLYLN,WTORECB,ROUTCDE=(1,11)
         BR    R11                RETURN TO CALLER
*
TIMEXIT  EQU   *                  STIMER EXIT ROUTINE
         USING TIMEXIT,15         REQUIRED BECAUSE OF MULTIPLE WAIT
         STM   14,12,12(13)       SYSTEM PROVIDED SAVE AREA
         POST  TIMECB             JUST POST OUR ECB
         LM    14,12,12(13)       RESTORE THE REGISTERS
         BR    14                 AND RETURN TO THE SYSTEM
*
NUMINTVL DC    H'0'               RUNNING COUNT OF STIMERS ISSUED
MAXINTVL DC    H'8000'            MAXIMUM NUMBER OF INTERVALS FOR RUN
*
HIGHEST  EQU   59                 HIGHEST UIC TO BE COUNTED
NBUCKET  DC    AL2(HIGHEST)       NUMBER OF COUNTING BUCKETS
LBUCKET  EQU   2*HIGHEST+2        LENGTH NEEDED FOR GETMAIN ETC.
REPLY    DS    CL5
REPLYLN  EQU   *-REPLY
ENDREPLY DC    C'ENDXB'
INTVL    DC    F'100'             1 SEC INTERVAL, AVOID DETECTED WAIT
ECBLST   DC    A(TIMECB)
         DC    X'80',AL3(WTORECB)
TIMECB   DC    F'0'               ECB USED FOR STIMER
WTORECB  DC    F'0'               ECB USED BY WTOR
ASCBID   DC    C'ASCB'            ASCB IDENTIFIER FOR VERIFICATION
JSOUGHT  DC    C'I9900000'        JOBNAME OF IMS CONTROL REGION
PRINT    DCB   DDNAME=SYSPRINT,MACRF=(PM),DSORG=PS,                    *
               RECFM=FB,LRECL=80,BLKSIZE=3600
WORK     DS    D
BLANKS   DC    CL8' '
BUFFER   DS    CL80
         END
