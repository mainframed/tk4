 ANAL: PROC(PARM) OPTIONS(MAIN) REORDER;
 /*UICC PACKLIST/ORDER CARD GENERATOR - VERSION 2 - 7/13/77
     THIS PROGRAM TAKES THE INPUT FROM A PSW SAMPLER PROGRAM
    (PSWSAMP OR STATDIE/OURMF) AND THE A DIRECTORY LISTER
    (DIRECT OR MODMAP) AND CREATES PACKLIST OR ORDER CARDS
    BASED ON THE USAGE PATTERN SEEN FROM THE SAMPLED PSWS.
    ITS FUNCTIONAL FLOW IS AS FOLLOWS:

      1. READ THE FIRST RECORD FROM THE "DIRECT" INPUT.  THIS
         CONTAINS THE NUMBER OF LPA/CSECT ENTRIES, AND THE
         LPA/MODULE LOWER AND UPPER BOUNDS.
      2. ALLOCATE THE STRUCTURES AND ARRAYS TO THE APPROPRIATE
         SIZE BASED ON THIS INFORMATION.
      3. READ IN THE LPA/MODULE DIRECTORY (THE DIRECT OR MODMAP
         PROGRAM HAS ALREADY SORTED THE ENTRIES SO THEY ARE IN
         ASCENDING ORDER BY STARTING ADDRESSES.
      4. COMPUTE THE ENDING ADDRESS OF EACH MODULE/CSECT, ZERO THE
         MODULE/CSECT HIT COUNTS, AND TURN OFF THE MODULE/CSECT SELECTED
         INDICATORS.
      5. READ IN THE MODULE/CSECT HIT LIST FROM FILE "COUNTS", SEARCH
         THE MODULE TABLE FOR THE APPROPRIATE MODULE/CSECT, AND SET ITS
         SAMPLE COUNT.
      6. CALCULATE THE USE-FACTORS FOR THE MODULES/CSECTS.  THIS IS
         A FLOATING POINT NUMBER WHICH IS BASED ON THE FOLLOWING
         FORMULA:

                     (LPAHIGH-LPALOW)*MODULE_COUNT
          FACTOR =   -------------------------------
                     MODULE_LENGTH*TOTAL_COUNT

     THIS FACTOR WILL BE 1 IF THE MODULE IS GETTING ITS PROPORTION
        OF SAMPLES BASED ON ITS SIZE.  A NUMBER GREATER THAN 1
        INDICATES THAT THE MODULE IS GETTING HEAVIER THAN NORMAL
        USAGE.
     7. THE MODULES ARE THEN SORTED IN ALPHABETICAL ORDER AND THE
        FIRST REPORT IS PRINTED.
     8. THE MODULES ARE THEN SORTED BY THE USE-FACTORS AND THE SECO
        REPORT IS PRINTED.
     9. THE SYSIN FILE IS OPENED.  IF IT IS UNDEFINED, THE REST OF
        STEP IS SKIPPED.  THE SYSIN FILE MAY CONTAIN CONTROL CARDS
        HANDLE ANY SPECIAL CASES LIKE PURE DATA MODULES AND SPECIAL
        MODULE SEQUENCING.  ALSO THE CONTROL CARDS MAY SPECIFY THAT
        NO MODULE OF ANY SIGNIFICANCE SHOULD BE PACKED WITH THE
        DESIGNATED MODULES.  THE FORMAT OF THE INPUT CONTROL CARDS
        IS AS FOLLOWS:
           COMMAND MODULE1,MODULE2,...,MODULEN
        WHERE COMMAND IS:
         ZERO - ZERO THE USE-FACTORS OF THE FOLLOWING MODULES.
             (WE USE IT FOR THE DIFFERENT SSSM MODULES WHICH
              ARE SWITCHED PERIODICALLY.  SO THE USE-FACTORS
              ARE NOT SIGNIFICANT FOR THEM).
         EQUATE - EQUATES THE USE-FACTOR OF A PURE DATA MODULE
              WITH A CORRESPONDING CODE MODULE (DEVNAMET,DEVMASKT
              WITH IEFW21SD FOR EXAMPLE).
         PACK - FORCES THE MODULES TO BE PACKED TOGETHER
    10. THE MODULES ARE THEN RE-SORTED IN PSEUDO-ALPHABETICAL ORDER
        BASED ON THE FOLLOWING ALGORITHM:
         IF THE MODULE NAME DOES NOT START WITH "IGC" THE NAME
         IS USED AS IS, IF THE MODULE NAME IS "IGCXXYYY" THE
         SORT KEY WILL BE "IGCYYYXX".  THIS SORTS MULTIPLE LOADS
         OF THE SAME SVC TOGETHER.
    11.  THE MODULES ARE THEN SORTED BY USE-FACTOR.  THE TABLE
         IS NOW IN ITS FINAL FORM FOR INPUT INTO THE PACK LIST
         PROCESS.
    12.  MODULES ARE NOW SELECTED FOR PACKING FROM THE TOP OF
         THE TABLE.  AS MODULES ARE SELECTED, THEIR USED BIT
         IS TURNED ON TO INDICATE THAT THEY ARE NO LONGER
         CANDIDATES FOR SELECTION.  THE FIRST MODULE IS CHOSEN,
         ITS LENGTH IS TAKEN MODULO 4096, AND THE REST OF THE
         PAGE IS FILLED GOING DOWN THE TABLE.  WHEN THE PAGE
         IS FULL, OR THERE ARE NO MODULES THAT WILL FIT IN THE
         REMAINDER OF THE PAGE, THE GROUP IS TERMINATED AND THE
         NEXT MODULE FROM THE TOP OF THE TABLE IS CHOSEN TO START
         THE NEXT GROUP.
    13.  THE COMPOSITE GROUP FACTORS ARE CALCULATED ALONG WITH
         EACH GROUPS LENGTH, AND THE PACK GROUPS ARE LISTED.
    14.  THE CARDS FOR THE IEAPAK00 LIST OR THE LINKAGE EDITOR
         ORDER CARDS ARE GENERATED STARTING FROM THE MOST ACTIVE
         GROUP AND MOVING TO THE LEAST ACTIVE GROUP.

    THIS PROGRAM WAS WRITTEN USING THE PL/1 OPTIMIZING COMPILER BY:

              BARRY SCHRAGER
              COMPUTER CENTER
              UNIVERSITY OF ILLINOIS AT CHICAGO CIRCLE
              BOX 4348
              CHICAGO, ILLINOIS 60680

              (312) 996-2478

              VERSION 2 DATED 7/13/77                              */
   DCL (DIRECT,COUNTS) FILE RECORD SEQUENTIAL,
       CARDS FILE STREAM OUTPUT EXTERNAL,
       PARM CHAR(100) VAR,
       TYPRUN CHAR(4),
     1 MODULE(*) CONTROLLED,
       2 NAME CHAR(8),
       2 (LENGTH,COUNT) FIXED BIN(31),
       2 FACTOR FLOAT DECIMAL(6),
       2 USED BIT(1),
     1 STATS,
       2 (MODCOUNT,LPALOW,LPAHIGH,FILL) FIXED BIN(31),
     1 STAT2,
       2 (MODCOUNT2,FILL1,FILL2) FIXED BIN(31),
     1 DIRIN BASED(DIRPTR),
       2 NAME CHAR(8),
       2 (START,LENGTH) FIXED BIN(31),
     1 COUNTIN BASED(CNTPTR),
       2 NAME CHAR(8),
       2 COUNT FIXED BIN(31),
       IND(*) FIXED BIN(31) CONTROLLED,
       GIND(*) FIXED BIN(31) CONTROLLED,
       GROUP(*) FIXED BIN(31) CONTROLLED,
       ADR FIXED BIN(31) BASED(PADR),
       SEARCHING BIT(1),
       TOT FIXED BIN(31) INIT(0),
       (DATE,LENGTH) BUILTIN,
       (I,J,K,L,M,N,P,SIZE,MAXGROUP) FIXED BIN(31),
       CARD CHAR(70) VAR,
       HEX(0:15) CHAR(1) INIT('0','1','2','3','4','5','6','7',
        '8','9','A','B','C','D','E','F'),
      TDATE CHAR(8), CTEMP CHAR(6), CWORK CHAR(80) VAR,
      COMMAND CHAR(8),CMODS(20) CHAR(8),
      MODNAME CHAR(8) VAR,
      GFACT FLOAT DECIMAL(6);
1  TOHEX: PROC(A) RETURNS(CHAR(6));
      DCL C CHAR(6) VAR INIT(''), (A,I,AD) FIXED BIN(31);
      AD=A;
   DO I=1 TO 6;
    C=HEX(MOD(AD,16))××C; AD=AD/16;
   END;
    RETURN(C);
    END TOHEX;
0  ALPHA: PROC(A) RETURNS(CHAR(8));
     DCL (A,C) CHAR(8);
     IF SUBSTR(A,1,3)='IGC' THEN
       C=SUBSTR(A,1,3)××SUBSTR(A,6,3)××SUBSTR(A,4,2);
      ELSE C=A;
     RETURN(C);
     END ALPHA;
1 /*PROCESS PARM FIELD OPTION  -  DEFAULT IS PACK
    LINK SPECIFIES THAT ORDER CARDS ARE TO BE PRODUCED */
   IF LENGTH(PARM)=0 THEN TYPRUN='PACK';
    ELSE DO;
      SELECT;
       WHEN (PARM='PACK') TYPRUN='PACK';
       WHEN (SUBSTR(PARM,1,4)='LINK') DO;
         CWORK=SUBSTR(PARM,5);
         IF SUBSTR(CWORK,1,1)^='(' THEN DO;
           PUT EDIT('MODULE NAME FOR LINK MUST BE SPECIFIED')(A) SKIP;
           STOP;
         END;
         I=INDEX(CWORK,')');
         IF I<2 × I>10 THEN DO;
           PUT EDIT('INVALID MODULE NAME SYNTAX')(A) SKIP;
           STOP;
         END;
         MODNAME=SUBSTR(CWORK,2,I-2);
         TYPRUN='LINK';
       END;
       OTHER DO;
        PUT EDIT('ILLEGAL PARM FIELD OPTION',PARM,
        'EXECUTION TERMINATING')(A,X(1),A,X(1),A) SKIP;
        STOP;
      END;
     END;
    END;
1  ON ERROR PUT DATA;
  CTEMP=DATE;
  TDATE=SUBSTR(CTEMP,3,2)××'/'××SUBSTR(CTEMP,5,2)××'/'××SUBSTR(CTEMP,1,2
 );
  OPEN FILE(DIRECT) INPUT, FILE(COUNTS) INPUT;
  READ FILE(DIRECT) INTO(STATS);
  MAXGROUP=(LPAHIGH-LPALOW+4096)/2048;
  ALLOCATE MODULE(MODCOUNT), IND(MODCOUNT), GIND(MODCOUNT), GROUP(
 MAXGROUP);
  FILDIR: DO I=1 TO MODCOUNT;
    READ FILE(DIRECT) SET(DIRPTR);
    MODULE(I)=DIRIN, BY NAME;
    END FILDIR;
  MODULE(*).COUNT=0; MODULE(*).USED='0'B;
  READ FILE(COUNTS) INTO(STAT2);
  DO I=1 TO MODCOUNT2;
     READ FILE(COUNTS) SET(CNTPTR);
     SEARCHING = 1B;
     DO J=1 TO MODCOUNT WHILE(SEARCHING);
        IF MODULE(J).NAME = COUNTIN.NAME THEN DO;
           MODULE(J).COUNT = COUNTIN.COUNT;
           TOT = TOT + COUNTIN.COUNT;
           SEARCHING = 0B;
        END;
     END;
  END;
1 CALC: MODULE(*).FACTOR=(FLOAT(LPAHIGH-LPALOW)/FLOAT(MODULE(*).LENGTH))
      *(FLOAT(MODULE(*).COUNT)/FLOAT(TOT));
0  DO I=1 TO MODCOUNT; IND(I)=I; END;
0  SORTA: DO I=MODCOUNT-1 TO 1 BY -1;
     DO J=1 TO I;
      IF MODULE(IND(J)).NAME>MODULE(IND(J+1)).NAME THEN DO;
    K=IND(J); IND(J)=IND(J+1); IND(J+1)=K; END SORTA;
1 PLPA: DO I=1 TO MODCOUNT BY 200;
  PUT EDIT('UICC PACKLIST GENERATOR','MODULES/CSECTS SORTED ALPHABETICAL
 Y',TDATE)
   (COL(1),A,COL(43),A,COL(111),A) SKIP;
  PUT SKIP;
  CWORK='  NAME   LENGTH   FACTOR';
  PUT EDIT(CWORK,CWORK,CWORK,CWORK)(COL(1),A,COL(33),A,COL(65),A,COL(97)
 ,A) SKIP;
  PUT SKIP;
  K=(MIN(I+200,MODCOUNT+1)-I+3)/4;
  DO L=I TO I+K-1;
  PUT EDIT((MODULE(IND(L+J)).NAME,TOHEX(MODULE(IND(L+J)).LENGTH),
       MODULE(IND(L+J)).FACTOR DO J=0 TO 3*K BY K WHILE(L+J<=MODCOUNT)))
       ((4)(A(8),X(1),A(6),X(1),F(8,3),X(8))) SKIP;
   END;
  PUT PAGE;
 END PLPA;
0  SORT: DO I=MODCOUNT-1 TO 1 BY -1;
     DO J=1 TO I;
      IF MODULE(IND(J)).FACTOR<MODULE(IND(J+1)).FACTOR THEN DO;
       K=IND(J); IND(J)=IND(J+1); IND(J+1)=K;
   END SORT;
0 PLP1: DO I=1 TO MODCOUNT BY 200;
  PUT EDIT('UICC PACKLIST GENERATOR','MODULES/CSECTS SORTED BY USE FACTO
 R',TDATE)
   (COL(1),A,COL(43),A,COL(111),A) SKIP;
  PUT SKIP;
  CWORK='  NAME   LENGTH   FACTOR';
  PUT EDIT(CWORK,CWORK,CWORK,CWORK)(COL(1),A,COL(33),A,COL(65),A,COL(97)
 ,A) SKIP;
  PUT SKIP;
  K=(MIN(I+200,MODCOUNT+1)-I+3)/4;
  DO L=I TO I+K-1;
  PUT EDIT((MODULE(IND(L+J)).NAME,TOHEX(MODULE(IND(L+J)).LENGTH),
       MODULE(IND(L+J)).FACTOR DO J=0 TO 3*K BY K WHILE(L+J<=MODCOUNT)))
       ((4)(A(8),X(1),A(6),X(1),F(8,3),X(8))) SKIP;
   END;
  PUT PAGE;
 END PLP1;
1  ON ENDFILE(SYSIN) GO TO ESYSIN;
     ON UNDEFINEDFILE(SYSIN) GO TO NSYSIN;
     OPEN FILE(SYSIN) INPUT;
   PUT EDIT('UICC PACKLIST GENERATOR','SYSIN CONTROL CARD LISTING',TDATE
 )
     (COL(1),A,COL(45),A,COL(111),A) SKIP;
   PUT SKIP(2);
0 N=1; M=0;
0  CGET: GET EDIT(CWORK) (COL(1),A(80)); L=0;
   PUT EDIT(CWORK) (COL(1),A(80)) SKIP;
   PUT SKIP;
    COMMAND=SUBSTR(CWORK,1,INDEX(CWORK,' ')-1);
    I=INDEX(CWORK,' ');
    DO WHILE(SUBSTR(CWORK,I,1)=' '); I=I+1; END;
   CLOOP: CWORK=SUBSTR(CWORK,I);
    J=INDEX(CWORK,',');
    IF J=0 THEN J=INDEX(CWORK,' ');
    IF J>1 THEN DO;
     L=L+1; CMODS(L)=SUBSTR(CWORK,1,J-1); I=J+1; GO TO CLOOP; END;
    GFACT=0;
   SLOOP: DO I=1 TO L;
    DO J=1 TO MODCOUNT;
     IF CMODS(I)=MODULE(J).NAME THEN GO TO ESLOOP;
    END;
    PUT LIST('MODULE '××CMODS(I)××' NOT FOUND') SKIP; STOP;
   ESLOOP: IND(I)=J; GFACT=MAX(GFACT,MODULE(J).FACTOR);
   END SLOOP;
0  IF COMMAND = 'PACK' THEN DO;
      M = M + 1;
      GROUP(M) = N;
      DO I = 1 TO L;
         J = IND(I);
         GIND(N) = J; N = N + 1;
         MODULE(J).USED = '1'B;
      END;
      GO TO OKCOMD;
   END;
0  IF COMMAND='ZERO' THEN DO;
    GFACT=0; GO TO OKCOMD; END;
   IF COMMAND='EQUATE' THEN GO TO OKCOMD;
   PUT LIST(COMMAND××' IS NOT VALID') SKIP; STOP;
0  OKCOMD: PUT EDIT('THE USE-FACTOR OF THE FOLLOWING MODULES WILL BE SET
  TO',
     GFACT) (COL(3),A,X(1),F(8,3)) SKIP;
   DO I=1 TO L; MODULE(IND(I)).FACTOR=GFACT; END;
   PUT EDIT((MODULE(IND(I)).NAME DO I=1 TO L))
      (COL(10),(12)(A(8),X(1))) SKIP;
   PUT SKIP;
  GO TO CGET;
0 ESYSIN: PUT SKIP(3);
   PUT EDIT('END OF FILE ON SYSIN')(COL(1),A) SKIP;
   PUT PAGE;
 NSYSIN:
0  DO I=1 TO MODCOUNT; IND(I)=I; END;
0  PBSORT: DO I=MODCOUNT-1 TO 1 BY -1;
     DO J=1 TO I;
      IF ALPHA(MODULE(IND(J)).NAME)>ALPHA(MODULE(IND(J+1)).NAME) THEN DO
 ;
       K=IND(J); IND(J)=IND(J+1); IND(J+1)=K;
   END PBSORT;
0  BSORT: DO I=MODCOUNT-1 TO 1 BY -1;
     DO J=1 TO I;
      IF MODULE(IND(J)).FACTOR<MODULE(IND(J+1)).FACTOR THEN DO;
       K=IND(J); IND(J)=IND(J+1); IND(J+1)=K;
   END BSORT;
1 MAIN: DO I=1 TO MODCOUNT;
   J=IND(I);
   IF ^MODULE(J).USED THEN DO;
     MODULE(J).USED='1'B; M=M+1; GROUP(M)=N; GIND(N)=J; N=N+1;
     SIZE=MOD(MODULE(J).LENGTH,4096);
0    DO K=I TO MODCOUNT;
      L=IND(K);
      IF ^MODULE(L).USED THEN DO;
       IF MODULE(L).LENGTH<=4096-SIZE THEN DO;
        MODULE(L).USED='1'B; GIND(N)=L; N=N+1;
        SIZE=SIZE+MODULE(L).LENGTH;
       END;
      END;
     END;
    END;
    END MAIN;
0 GROUP(M+1)=N;
 PUT EDIT('UICC PACKLIST GENERATOR','PACK GROUPS GENERATED',TDATE)
     (COL(1),A,COL(50),A,COL(111),A) SKIP;
 PUT SKIP;
 PUT EDIT('PAGE NUM  LENGTH   FACTOR','MODULES')
     (COL(3),A,COL(75),A) SKIP;
 PUT SKIP;
0  N=1;
0 PLP2: DO I=1 TO M;
  J=GROUP(I); K=GROUP(I+1)-1;
  SIZE=0; P=0;
  IPLP2: DO L=J TO K;
    SIZE=SIZE+MODULE(GIND(L)).LENGTH;
    P=P+MODULE(GIND(L)).COUNT;
   END IPLP2;
    GFACT=(FLOAT(LPAHIGH-LPALOW)/FLOAT(SIZE))*(FLOAT(P)/FLOAT(TOT));
  PUT EDIT(N,TOHEX(SIZE),GFACT,(MODULE(GIND(L)).NAME DO L=J TO K))
   (COL(5),F(3),COL(13),A(6),COL(20),F(8,3),(99)(COL(30),(10)(A(8),X(1))
 )) SKIP;
   PUT SKIP;
  N=N+(SIZE+4095)/4096;
  END PLP2;
1 CARD='';
  PUT PAGE;
  PUT EDIT('UICC PACKLIST GENERATOR','CARDS PRODUCED',TDATE)
    (COL(1),A,COL(49),A,COL(111),A) SKIP;
  PUT SKIP;
  SELECT;
    WHEN (TYPRUN='PACK') DO;
  FOUT: DO I=1 TO M;
    J=GROUP(I); K=GROUP(I+1)-1; CARD=CARD××'(';
    DO L=J TO K;
     N=GIND(L);
     P=INDEX(MODULE(N).NAME,' '); IF P=0 THEN P=8; ELSE P=P-1;
     CARD=CARD××SUBSTR(MODULE(N).NAME,1,P);
     IF L<K THEN CARD=CARD××',';
      ELSE IF I<M THEN CARD=CARD××'),';
       ELSE CARD=CARD××')';
     IF LENGTH(CARD)>59 THEN DO;
     PUT FILE(CARDS) EDIT(CARD) (X(1),A(70)) SKIP;
     PUT EDIT(CARD)(COL(25),A) SKIP;
     CARD='';
     END;
   END FOUT;
     IF LENGTH(CARD)>0 THEN DO;
     PUT FILE(CARDS) EDIT(CARD) (X(1),A(70)) SKIP;
     PUT EDIT(CARD)(COL(25),A) SKIP;
     END;
    END;
    WHEN (TYPRUN='LINK') DO;
      CARD='INCLUDE SYSLIB('××MODNAME××')';
      PUT FILE(CARDS) EDIT(CARD) (X(1),A(70)) SKIP;
      PUT EDIT(CARD) (COL(25),A) SKIP;
0 COUT: DO I=1 TO M;
    J=GROUP(I); K=GROUP(I+1)-1;
    N=GIND(J);
    P=INDEX(MODULE(N).NAME,' '); IF P=0 THEN P=8; ELSE P=P-1;
    CARD='ORDER '××SUBSTR(MODULE(N).NAME,1,P)××'(P)';
    CWORK=',';
    DO L=J+1 TO K;
     N=GIND(L);
     P=INDEX(MODULE(N).NAME,' '); IF P=0 THEN P=8; ELSE P=P-1;
     CARD=CARD××CWORK××SUBSTR(MODULE(N).NAME,1,P);
     CWORK=',';
     IF LENGTH(CARD)>59 & L<K THEN DO;
       PUT FILE(CARDS) EDIT(CARD) (X(1),A(70)) SKIP;
       PUT EDIT(CARD) (COL(25),A) SKIP;
       CARD='';
       CWORK='ORDER ';
     END;
    END;
   PUT FILE(CARDS) EDIT(CARD) (X(1),A(70)) SKIP;
   PUT EDIT(CARD) (COL(25),A) SKIP;
  END COUT;
   CARD='NAME '××MODNAME××'(R)  INSERT PROPER ALIAS CARDS ABOVE';
   PUT FILE(CARDS) EDIT(CARD) (X(1),A(70)) SKIP;
   PUT EDIT(CARD) (COL(25),A) SKIP;
    END;
    OTHER PUT DATA;
  END;
 END ANAL;
