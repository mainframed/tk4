         LCLC  &OPSYS
*        &OPSYS IS THE TYPE OF OPERATING SYSTEM:
*              VS2 OR MVT FOR THE VS2 OR MVT OPERATING SYSTEMS
*              VS1 OR MFT FOR THE VS1 OR MFT OPERATING SYSTEMS
*              ANYTHING ELSE HAS THE EFFECT OF SPECIFYING VS2
*        NOTE: OPERATING SYSTEMS STUFF NOT IMPLEMENTATED AT THIS TIME
*        THE NEXT STATEMENT IS USED TO SET &OPSYS
&OPSYS   SETC  'VS2'
         AIF   ('&OPSYS' EQ 'VS2').LBL1
         AIF   ('&OPSYS' NE 'MVT').LBL2
.LBL3    ANOP
&OPSYS   SETC  'VS2'
         AGO   .LBL1
.LBL2    AIF   ('&OPSYS' EQ 'VS1').LBL1
         AIF   ('&OPSYS' NE 'MFT').LBL3
&OPSYS   SETC  'VS1'
.LBL1    ANOP
PLEATRAP CSECT
*
*              THE PURPOSE OF THIS PROGRAM IS TO GATHER RUN TIME
*              STATISTICS ON A PL/I PROGRAM DURING ITS EXECUTION
*              PLOTRAP ACTS AS A MONITOR WHICH LOADS THE PL/I
*              PROGRAM AND PERIODICALLY GETS CONTROL TO RECORD DATA
*              ON THE CURRENT ACTIVITY IN THE PROGRAM. THIS DATA IS
*              WRITTEN OUT FOR USE BY THE SUCCEEDING TABULATOR STEP.
*              THE DATA IS RECORDED ON RECORDS CONSISTING OF 6
*              FIELDS EACH 4 BYTES LONG. THE RECORDS ARE OF SEVERAL
*              TYPES, AND THEIR FIELDS ARE AS FOLLOWS.
*
* TYPE1  WRD1  'STRT' FIRST RECORD IN RUN.
*        WRD2  LOAD POINT OF PL/I PROGRAM.
*        WRD3  ENTRY POINT OF LOAD MODULE
*        WRD4  SAMPLE INTERVAL IN 100THS OF A SEC
*        WRD5,6 NAME OF PL/I PROGRAM.
*
* TYPE2  WRD1  'RUN' STANDARD SAMPLE RECORD
*              FLAGS IN LAST BYTE:
*              X'80' THIS RECORD APPLIES TO MAIN PROC.
*              X'40' THIS RECORD CONTAINS A LINE NUMBER
*        WRD2  PSW ADDRESS WHEN TIMER INTERRUPTED.
*        WRD3  STATEMENT/LINE NO BEING EXECUTED
*        WRD4  FIRST BYTE: INTERRUPT CODE FROM PSW WHEN TIME EXPIRED
*              LAST 3 BYTES: OFFSET OF PROC IN LOAD MODULE
*        WRD5,6 NAME OF CLOSEST PL/I PROC CONTAINING STATEMENT
*
* TYPE3  WRD1  'LOAD' TRANSIENT MODULE RECORD.
*        WRD2  LOAD POINT OF TRANSIENT MODULE
*        WRD3  SIZE OF TRANSIENT MODULE.
*        WRD4  SPARE
*        WRD5,6 NAME OF TRANSIENT MODULE.
*
* TYPE4  WRD1  'PGCK' PROGRAM CHECK DURING ANALYSIS.
*        WRD2  OFFSET OF INTERRUPT WITHIN PLOTRAP.
*        WRD3  ORIGINAL INTERRUPT ADDR FROM RUN WRD2
*        WRD4  INTERRUPT CODE FROM PLOTRAP SPIE PICA.
*        WRD5,6 SPARE
*
* TYPE5  WRD1  'MESG' ERROR MESSAGE
*        WRD2  MESSAGE NUMBER
*        WRD3,4,5,6 MESSAGE TEXT (IF ANY).
*
* TYPE6  WRD1  'END' LAST RECORD IN RUN
*        WRD2  NO OF INTERRUPTS
*        WRD3  SPARE
*        WRD4  START TIME FOR RUN.
*        WRD5  END TIME FOR RUN.
*        WRD6  SPARE.
         EJECT
R0       EQU   0
R1       EQU   1
R2       EQU   2
R3       EQU   3
R4       EQU   4
R5       EQU   5
R6       EQU   6
R7       EQU   7
R8       EQU   8
R9       EQU   9
R10      EQU   10
R11      EQU   11
R12      EQU   12
R13      EQU   13
R14      EQU   14
R15      EQU   15
*
         PRINT NOGEN
         USING *,R15
         B     CODE                BRANCH AROUND CONSTANTS
         DC    X'08',CL9'PLEATRAP' NAME OF THIS PROGRAM
CODE     STM   R14,R12,12(R13)     SAVE CALLERS REGS IN HIS SAVE AREA
         LR    R10,R13             R10 -> CALLERS SAVE AREA
         LA    R13,SAV             R13 -> OUR SAVE AREA
         ST    R13,8(R10)          CHAIN FWD FROM HIM TO US
         ST    R10,4(R13)          CHAIN BACK FROM US TO HIM
         DROP  R15
         BALR  R12,0               SET UP
         USING *,R12               LOCAL BASE
R12BASE  L     R2,0(R1)            R2 -> PARM STRING
         TIME  BIN                 RECORD START TIME OF RUN
         ST    R0,TIMEIN           AND SAVE IT
         OPEN  (DCBOUT,(OUTPUT))   OPEN TRACE FILE
         LH    R3,0(R2)            R3 = LENGTH OF PARM FIELD
         LA    R4,2(R2)            R4 -> FIRST PARM BYTE
         LR    R5,R4               R5 -> FIRST PARM BYTE
STCL02   CLI   0(R4),C','          TEST AND
         BE    STCL04              BRANCH IF
         CLI   0(R4),C'/'          DELIMITER IS
         BE    STCL04              FOUND
         LA    R4,1(R4)            R4 -> NEXT PARM BYTE
         BCT   R3,STCL02           LOOK FOR DELIM OR END OF LIST
*
*        AT THIS POINT R3 CONTAINS NO OF CHARS REMAINING IN
*        PARMLIST (IF ANY), AND R4 -> BYTE FOLLOWING PLIST
*
STCL04   LR    R6,R4               R6 -> '/' OR END OF LIST
         SR    R6,R5               R6=LENGTH OF LANGUAGE ID
         BZ    NOLANG              GIVE A DEFAULT LANG OF PL/I OPT
         BCTR  R6,0                PREPARE FOR EXECUTE INST
         N     R6,MASK             MOVE MAX OF 8 CHARS
         EX    R6,LANGMVC          SAVE LANGUAGE NAME
         LA    R7,LANGTBL          START OF LANGUAGE ID TABLE
         LA    R8,L'LANGTBL        TABLE ENTRY LENGTH FOR BXLE
         LA    R9,LANGEND
         LA    R10,1               TABLE SUBSCRIPT
LANGLOOP CLC   LANG(8),0(7)        PROPER ENTRY
         BE    GOTLANG             YES, SET FLAGS
         LA    R10,1(,R10)         NO, UP SUBSCRIPT
         BXLE  R7,R8,LANGLOOP      TRY NEXT LANGUAGE
BADLANG  MVC   MESSNO,F990         NO SUCH LANGUAGE
         PUT   DCBOUT,MSGREC       SAVE IT FOR PLOTAB
         B     FINISH2             GIVE UP AND GO HOME
NOLANG   LA    10,1
GOTLANG  STC   R10,LANGBYTE        SAVE LANGUAGE SUBSCRIPT
         LTR   R3,R3               ARE THERE ANY CHARS LEFT
         BZ    LOADLAB             NO, GO LOAD
         CLI   0(R4),C'/'          IS THERE A MODULE NAME
         BE    LOADLAB             NO, GO LOAD STUFF
         LA    R4,1(,R4)           BUMP PAST LANGUAGE PARM
         BCTR  R3,0                ONE LESS CHAR IN PARM TO WORRY ABOUT
         LTR   R3,R3               IS THERE ANYTHING LEFT
         BZ    LOADLAB             NO, LOAD UP AND GET GOING
         LR    R5,R4               SAVE POINTER IN R5
STCL09   CLI   0(R4),C','          CHECK FOR MID DELIMITER
         BE    STCL10              GO PROCESS PARMS
         CLI   0(R4),C','          CHECK FOR DELIMITER
         BE    STCL10              GO PROCESS PARMS
         LA    R4,1(,R4)           NEXT CHARACTER
         BCT   R3,STCL09           TRY AGAIN
STCL10   LR    R6,R4               R6 -> DELIMITER OR END OF PARM
         SR    R6,R5               R6=LENGTH OF LOAD MODULE NAME
         LTR   R6,R6               IS THERE A LOAD MODULE NAME
         BZ    STCL07              NO, USE DEFAULT
         BCTR  R6,0                R6 = EXECUTE LENGTH
         N     R6,MASK             MOVE NO MORE THAN 8 CHARS
         EX    R6,NAMEMVC          MOVE MOD NAME FROM PARM
STCL07   LTR   R3,R3               ANYTHING LEFT
         BZ    LOADLAB             NO, GO LOAD
*
*        WE NOW SCAN FOR MORE PLEA PARMS. THESE PARMS
*        ARE POSITIONAL, NUMERIC, SEPARATED BY COMMAS AND HAVE
*        THE FOLLOWING FUNCTION:
*        P1.   TRACE INTERVAL IN HUNDREDTHS OF A SECOND
*        P2.   INTERRUPT COUNT LIMIT.
*        P3.   PL/I PROGRAM CPU TIME LIMIT, SECONDS
*
         BAL   R14,PARMSCAN
         B     PARM2               NULL PARM
         ST    R7,TRCINTVL         TRACE INTERVAL
*
PARM2    BAL   R14,PARMSCAN
         B     PARM3               NULL PARM
         ST    R7,ERRLIMIT         INTERRUPT COUNT LIMIT
*
PARM3    BAL   R14,PARMSCAN
         B     PARM4               NULL PARM
         SR    R6,R6               CONVERT EXECUTION
         M     R6,F100             SECONDS TO HUNDREDTHS
         ST    R7,TIMLIMIT         CPU TIME LIMIT
PARM4    BAL   R14,PARMSCAN
         B     LOADLAB             NULL PARM
         ST    R7,CNTLIMIT
*
LOADLAB  LOAD  EPLOC=NAME          LOAD PL/I PROGRAM
*
*              THE LOAD MACRO RETURNS WITH R0 CONTAINING THE ENTRY
*              POINT TO THE PL/I MODULE, PLISTART.
*
         ST    R0,WRD3             RECORD THE LOAD MODULE ENTRY POINT
*
*        INSERT CODE HERE TO DO ANY WORK ON THE LOAD MODULE BEFORE
*        EXECUTION.
*
CONTINUE MVC   WRD1,STRT           INITIALISE THE
         MVC   WRD4,TRCINTVL       FIRST TRACE
         MVC   WRD5(8),NAME        RECORD
         STIMER  TASK,EXIT,BINTVL=TRCINTVL SET CPU TIMER
         PUT   DCBOUT,BUFFER       WRITE OUT STARTER RECORD
*
*        NOW SET UP THE USER PROGRAM PARMLIST (IF ANY)
         LTR   R3,R3               TEST AND BRANCH IF
         BZ    STCL06              NO USER PARM LIST
*
         BCTR  R3,0                TEST AND
         LTR   R3,R3               BRANCH IF '/'
         BZ    STCL06              ENDS THE LIST
         STH   R3,PL1PARM          RECORD LENGTH
         BCTR  R3,0                EXECUTE LENGTH OF PROGRAM PLIST
         EX    R3,STCMV            PUT REST OF CHARS IN PL/I PARM
*
STCL06   EQU   *
         LINK  EPLOC=NAME,PARAM=(PL1PARM) LINK TO USER PROGRAM
         SPACE 10
*        WHEN THE PL/I PROGRAM FINISHES, CONTROL RETURNS HERE
         SPACE
FINISH   ST    R15,SAVRETN         SAVE PL/1 RETURN CODE
         CLI   ENDSW,C'1'          TEST AND BRANCH IF
         BE    FINISH1             SAMPLING ALREADY FINISHED
         TTIMER  CANCEL            FINISHED WITH TIMER
         TIME  BIN                 GET TIME OF DAY
         ST    R0,TIMEOUT
FINISH1  EQU   *
         PUT   DCBOUT,LASTREC      WRITEOUT LAST RECORD
FINISH2  CLOSE  DCBOUT             AND CLOSE THE TRACE FILE
         L     R13,SAV+4           GET CALLER SAVE AREA
         L     R14,12(R13)         RESTORE RETURN ADDRESS
         L     R15,SAVRETN         RESTORE PL/1 RETURN CODE
         LM    R0,R12,20(R13)      RESTORE OS REGS
         BR    R14                 RETURN
         EJECT
*        PARMSCAN IS ENTERED TO SCAN AND VALIDATE THE NEXT PLEA
*        PARAMETER FROM THE EXEC CARD. THE PARAMETER MUST BE
*        NUMERIC. REGISTERS ARE USED AS FOLLOWS:
*        R3 CONTAINS NO OF BYTES REMAINING IN PARMLIST
*        R4 IS SCAN POINTER
*        R5 SAVES START OF PARM
*        R6 IS LENGTH OF PARM IN BYTES
*        R7 RETURNS THE ARITHMETIC VALUE OF THE PARM
*        R14 IS RETURN REGISTER:
*              0(R14)    NULL PARM
*              4(R14)    VALID PARM
         SPACE 2
PARMSCAN EQU   *
         LTR   R3,R3               TEST AND BRANCH
         BZ    LOADLAB             IF END OF COMPLETE PARMLIST
         CLI   0(R4),C'/'          TEST AND BRANCH
         BE    LOADLAB             IF END OF PLEA PARMLIST
         LA    R4,1(R4)            BUMP SCAN POINTER
         BCTR  R3,0                TEST AND BRANCH
         LTR   R3,R3               IF END OF
         BZ    LOADLAB             COMPLETE LIST
*
         LR    R5,R4               SAVE START OF NEXT PARM
TIMSCAN  CLI   0(R4),C','          TEST AND BRANCH
         BE    TIMLAB              IF END
         CLI   0(R4),C'/'          OF THIS
         BE    TIMLAB              PARAMETER
*
         CLI   0(R4),X'F0'         VALIDATE
         BL    PARMERR             DIGITS
         CLI   0(R4),X'F9'         IN
         BH    PARMERR             PARAMETER
         LA    R4,1(R4)            KEEP
         BCT   R3,TIMSCAN          SCANNING
*
TIMLAB   LR    R6,R4               R6 -> '/' OR ',' OR END OF PLIST
         SR    R6,R5               R6 = LENGTH OF THIS PARM
         BCR   8,R14               NULL PARM RETURN
         BCTR  R6,0                EXECUTE LENGTH
         EX    R6,EXPACK           CONVERT TO DECIMAL
         CVB   R7,DECWSP           AND THEN TO BINARY
         B     4(R14)              NORMAL RETURN
*
PARMERR  EQU   *                   ERROR IN PARMLIST, ABANDON ANALYSIS
         MVC   MESSNO,F989         SINCE IT WILL LIKELY BE A WASTED RUN
         MVC   MESSTXT,0(R4)       RECORD BAD PARM IN CASE NEEDED
         PUT   DCBOUT,MSGREC       PASS MESSAGE TO TABULATOR
         B     FINISH2
         SPACE 5
EXPACK   PACK  DECWSP(8),0(0,R5)   PACK TIME LIMIT PARM
LANGMVC  MVC   LANG(0),0(R5)       SAVING LANGUAGE ID
NAMEMVC  MVC   NAME(0),0(R5)       SAVING LOAD MODULE ID
STCMV    MVC   PARMLIST(0),1(R4)   SAVE PARM CHARS FOR PL/I PGM
  TITLE  'TRACE EXIT ROUTINE'
*              CONTROL IS TRANSFERRED TO EXIT EACH TIME THE TIMER
*              EXPIRES. THE EXIT ROUTINE DETERMINES THE STATEMENT/
*        LINE NUMBER CURRENTLY BEING EXECUTED.
*
EXIT   EQU  *
         STM   R14,R12,12(R13)
         BALR  R12,0                    SET UP
         USING  *,R12                   LOCAL BASE
         ST    R13,SAV2+4               CHAIN BACK
         LA    R13,SAV2                 SET UP OUR SAVE AREA
         SPIE  SPIEXIT,((1,8))          SET UP OUR SPIE
         ST    R1,PICA                  AND STACK THE PL/I SPIE
*
*        WE NOW CHECK WHETHER THE JOB HAS EXCEEDED EITHER OF ITS
*        LIMITS.
*
         L     R2,TIMTAKEN              INCREMENT THE
         A     R2,TRCINTVL              CPU TIME TAKEN
         ST    R2,TIMTAKEN              SO FAR
         C     R2,TIMLIMIT              TEST AND BRANCH
         BL    COUNTCHK                 IF LIMIT NOT EXCEEDED
*
         MVC   MESSNO,F980              ISSUE DIAGNOSTIC
         PUT   DCBOUT,MSGREC            FOR PRINTING BY PLOTAB
*
         TIME  BIN                      NOTE TIME ENDED
         ST    R0,TIMEOUT               AND RECORD IN LAST RECORD
         PUT   DCBOUT,LASTREC
         CLOSE DCBOUT
         ABEND 980,DUMP,STEP       TERMINATE THIS STEP. IF YOU WANT
*              THE DUMP PUT A SYSUDUMP CARD IN THE GO STEP. TO
*              CONTINUE ON TO THE TABULATOR, CODE COND=EVEN ON ITS
*              EXEC CARD.
*
COUNTCHK L     R2,COUNT            TEST IF COUNT EXCEEDED
         LA    R2,1(R2)            BUMP COUNTER
         ST    R2,COUNT            AND STORE IT
         C     R2,CNTLIMIT         TEST AND BRANCH IF
         BNE   FIRST               NOT YET EXCEEDED
*
         MVC   MESSNO,F988         INTERRUPT COUNT LIMIT
         PUT   DCBOUT,MSGREC       WAS EXCEEDED
         B     ABENDRTN            TERMINATE ANALYSIS
*
FIRST    BC    0,NOTFIRST          FIRST TIME, FIND TCB AND PL/I PRB
         OI    FIRST+1,X'F0'       SKIP THE FOLLOWING CODE NEXT TIME ON
*
*        THE FOLLOWING CODE IS EXECUTED DURING THE FIRST INTERRUPT
*        ONLY. WE FIND OUR TCB AND THE PRB CHAIN, AND LOCATE THE
*        PL/I PROGRAM PRB.
*
         L     R2,16               R2 -> CVT
         L     R2,0(R2)            R2 -> TCB PTR IN CVT
         L     R2,0(R2)            R2 -> OUR TCB
         LA    R2,0(R2)            CLEAR HI BYTE
         ST    R2,TCBAD            AND RECORD TCB ADDRESS
         L     R3,0(R2)            R3 -> OUR IRB (START OF RB CHAIN)
LOOKCDE  L     R3,28(R3)           R3 -> NEXT RB
         C     R3,TCBAD            TEST AND BRANCH
         BE    NOPRB               END OF RB CHAIN
         L     R4,12(R3)           R4 -> CDE IF PRB
         CLC   8(8,R4),NAME        IS IT THE NAME OF THE USER PROGRAM?
         BE    FOUNDCDE            BRANCH IF YES
         B     LOOKCDE             KEEP LOOKING
*
*        WE HAVEN'T FOUND THE PL/I PRB AFTER 8 TRIES, SO
*        SOMETHING IS LIKELY WRONG. A DIAGNOSTIC IS ISSUED FOR
*        PRINTING BY PLOTAB, AND THE ANALYSIS IS TERMINATED.
*
NOPRB    EQU   *
         MVC   MESSNO,F981         DIAGNOSE NO PRB
         PUT   DCBOUT,MSGREC       WRITE OUT MESSAGE
         TIME  BIN                 NOTE TIME ENDED
         ST    R0,TIMEOUT          WRITE OUT
         PUT   DCBOUT,LASTREC      LAST RECORD
         CLOSE DCBOUT
         ABEND 981,DUMP,STEP       SEE ABEND 980 FOR DEBUG PROCEDURE
*
FOUNDCDE LA    R3,0(R3)            CLEAR HI ORDER BYTE
         ST    R3,PRBAD            SAVE POINTER TO PL/I PROGRAM'S PRB
*
*              WE NOW FIND THE LOAD POINT OF THE PL/I PROGRAM, IN
*              CASE WE HAVE SOME DEBUGGING TO DO LATER. WE DON'T USE
*              THE EP FOUND AFTER THE LOAD MACRO SINCE PLISTART MAY
*              NOT ALWAYS BE THE FIRST CSECT.
*
         L      R4,20(R4)          R4 -> EXTENT LIST FOR PL/I PROGRAM
         LA         R4,8(R4)       R4 -> FIRST POSSIBLE EXTENT ADDR - 4
SCANXL   L     R6,0(,R4)           SAVE POSSIBLE END OF LOAD MODULE
         LA    R4,4(,R4)           SCAN DOWN THE EXTENT LIST LENGTHS
         TM    0(R4),X'80'         UNTIL THE FIRST EXTENT ADDR
         BO    SCANXL              IS FOUND
         MVC   WRD2,0(R4)          RECORD ORIGIN OF PL/I LOAD MODULE
         MVC   ORIGIN,WRD2         IN THE 'STRT' RECORD
*
         PUT   DCBOUT,BUFFER       WRITE OUT 'STRT' RECORD BUILT
*                                  BEFORE PLEA LINKED TO PL/I PGM
         LA    R6,0(,R6)           CLEAR HIGH ORDER BYTE
         L     R7,0(,R4)           GET LOAD MODULE LENGTH
         LA    R7,0(,R7)           CLEAR HIGH ORDER BYTE
         AR    R6,R7               SUM TO GET LOAD MOD END
         ST    R6,LMODEND          SAVE IT.
  SPACE  3
NOTFIRST EQU   *
*** R2  TCB AD
*** R3  SCAN RB
*** R4  PREV RB
*** R5  AD LEAST ACTIVE RB WITH A SAVEAREA
*              THIS IS THE NORMAL ENTRY FOR 2ND THROUGH NTH INTERRUPTS
*              FIRST TIME FALLS THROUGH FROM ABOVE. HERE WE LOCATE THE
*              RB, CLOSEST TO THE PROBLEM PROGRAM PRB, WHICH CONTAINS
*              A SAVE AREA. THIS IS EITHER THE IRB FOR THE PLEA TIMER
*              IF THE TIMER EXPIRED DURING PL/I CODE OR
*              LIBRARY CODE, OR AN SVRB CREATED BY AN SVC CALL
*              ISSUED BY THE PL/I LIBRARY BEFORE THE TIMER EXPIRED.
*              THIS SAVE AREA GIVES US ACCESS TO THE PL/I SAVE AREA
*              CHAIN, SO WE CAN PICK UP ANY GOODIES WE WANT.
*
         L     R2,TCBAD
         L     R3,0(R2)            R3 -> MOST RECENT RB
         LR    R4,R3               SAVE THIS
         LR    R5,R3               RB ADDRESS
SCANCHN  EQU   *
         CLI   9(R4),X'0C'         TEST AND BRANCH IF RB NOT BIG
         BL    SCANLAB             ENOUGH FOR A SAVE AREA
         LR    R5,R4               R5 -> RB WITH A SAVE AREA. THIS
*                                  ONE MIGHT NOT BE THE OLDEST
*                                  ONE MIGHT NOT BE THE OLDEST
SCANLAB  C     R3,PRBAD            WAS IT CREATED NEXT TO PROGRAM PRB?
         BE    FOUND               IF SO, THEN THE SAVED REGISTERS
*                                  WITHIN IT ARE PL/I REGISTERS
         LR    R4,R3               R4 SAVES THE POINTER TO THIS RB
         L     R3,28(R4)           R3 -> NEXT PREVIOUS RB
         CR    R2,R3               TEST AND BRANCH IF
         BNE   SCANCHN             NOT END OF CHAIN
*
*        WE CAN'T FIND AN RB WHICH WILL PROVIDE US WITH A SAVE
*        AREA, SO SOMETHING IS LIKELY WRONG. A DIAGNOSTIC IS ISSUED
*        FOR PRINTING BY PLOTAB, AND THIS INTERRUPT IS ABANDONED.
*
         MVC   MESSNO,F982         DIAGNOSE NO SAVEAREA
         B     DIAGNOSE            PATCH POINT
  SPACE  3
FOUND  EQU  *
***            R3 -> PL/I PROGRAM PRB
*** R4  AD NEXT RB
*** R5  AD LEAST ACTIVE RB WITH A SAVEAREA
*              THE PL/I PROGRAM PRB CONTAINS THE PSW IN THE PL/I
*              PROGRAM AT THE TIME OF INTERRUPT. THIS INTERRUPT WAS
*              EITHER OUR TIMER, OR AN SVC ISSUED BY PL/I. IN EITHER
*              CASE, WE IDENTIFY THE PROCEDURE CONTAINING THE
*              INTERRUPTED STATEMENT, AND THE STATEMENT/LINE NUMBER
*              IF THE GOSTMT/GONUMBER OPTION WAS ACTIVE IN THE BLOCK.
*
         XC    WRD1(24),WRD1       ZERO OUT BUFFER
         MVC   WRD2+1(3),21(R3)    SAVE PSW INTERRUPT ADDRESS
         MVC   INTERRPT,WRD2       SAVE INTERRUPT ADDRESS
         MVC   WRD4(1),19(R3)      INTERRUPT CODE FROM PSW
         LA    R9,R10              10 LIB LEVELS MAX
*
         ST    R5,SAVRB            SAVE RB ADDRESS
*
         L     R6,84(,R5)          ENTER PL/I SAVE AREA CHAIN FROM THE
*                                  R13 SLOT IN R5->RB SAVE AREA. R6 IS
*                                  USED AS THE BACK CHAIN SA POINTER.
         LA    R6,0(,R6)           CLEAR HI BYTE AND SAVE
         ST    R6,RBR13            THE VALUE OF R13 AT INTERRUPT
         SPACE 2
SCAN13   EQU   *
         C     R6,ENTERAD          GIVE UP IF CHAIN GOES BELOW REGION
         BL    MSG984              PLEATRAP, LOADED FIRST BY OS, IS AT
*                                  THE LOWER END OF THE REGION, WITH NO
*                                  DSA BELOW IT.
         MVC   WRD1(3),RUN         INDICATE THIS IS A RUN SAMPLE RECORD
         MVC   WRD5(8),BLANKS      BLANK OUT PROGRAM NAME
         CLI   LANGBYTE,X'03'      ARE WE PLAYING WITH FORTRAN
         BNE   PLISTUFF            NO,THANK HEAVENS
         L     R8,4(,R6)           GET CALLER SAVE AREA
         L     R7,TCBAD            GET TCB
         L     R7,FSA(,R7)         GET TOP SAVE AREA ADDRESS
         LR    R6,R7               SAVE THIS SAVE AREA ADDRESS
SALOOP   L     R7,8(,R7)           GO DOWN ONE SAVE AREA
         LA    R7,0(,R7)           CLEAR HIGH ORDER BYTE
         C     R7,ENTERAD          ARE WE TOO LOW?
         BL    MSG985              IF SO, GIVE UP
         C     R7,LMODEND          ARE WE TOO HIGH?
         BH    MSG985              IF SO, GIVE UP
         CLI   12(R7),X'FF'        IS IT BEING USED
         BE    FORTSAVE            NO, R6 HAS CURRENT SAVE AREA
         LR    R6,R7               HOLD THIS ADDRESS
         CR    R6,R8               IS THIS THE BOTTOM
         BNE   SALOOP              NO, GO DOWN ANOTHER ONE
FORTSAVE L     R7,16(,R6)          GET ENTRY POINT
         LA    R7,0(,R7)           CLEAR HIGH ORDER BYTE
         C     R7,ORIGIN           IS THE EP DREK?
         BM    MSG985              YES, GIVE UP
         C     R7,LMODEND          MAKE SURE IT'S USEFUL
         BH    MSG985              IF NOT, CROAK THE BUGGER
         LA    R8,0                CLEAR R8 FOR NUMBER OF ENTRY CHARS
         IC    R8,4(,R7)           R8 IS NUMBER OF CHARS
         BCTR  R8,0                PREPARE FOR EX
         N     R8,MASK             MOVE NO MORE THAN 8 CHARS
         XC    WRD3(4),WRD3        SHOW NO STMT NO. AVAILABLE
         EX    R8,MAINCLC          IS NAME 'MAIN'
         BNE   NOTFMAIN            NO, IT'S A SUBROUTINE
         OI    WRD1+3,X'80'        SHOW MAIN PROGRAM
NOTFMAIN EX    R8,MOVENAME         PUT PGM NAME IN RECORD
         S     R7,ORIGIN           GET CSECT OFFSET
         ST    R7,FULLWD           SAVE IT
         MVC   WRD4+1(3),FULLWD+1  MOVE IT INTO THE RUN RECORD
         B     WRITERUN            WRITE REC AND GO ON
MOVENAME MVC   WRD5(0),5(R7)       EXECUTED TO MOVE PGM NAME
MAINCLC  CLC   5(0,R7),MAIN        MAIN PROGRAM NAME CHECK
PLISTUFF CLI   0(R6),X'82'         IS THIS THE DUMMY DSA?
         BNE   SCAN13A             IF NOT, CHECK WHAT KIND IT IS
*
*        DUMMY DSA FALLS THRU. THIS MEANS WE HAVE BEEN UNABLE TO
*        LOCATE A PL/I DSA. THIS IS EITHER AN ERROR, OR WE ARE IN
*        HOUSEKEEPING ROUTINES BEFORE OR AFTER THE PL/I PROGRAM IS
*        EXECUTED. WE ISSUE A MESSAGE IN CASE WE WANT TO DEBUG LATER.
*
         MVC   MESSNO,F983         MESSAGE NO
         B     DIAGNOSE            PATCH POINT
*
         B     SCAN13B             GOTO COMMON CODE
SCAN13A  TM    0(R6),X'80'         IS THIS A DSA NOT IN LWS?
         BO    CHKBLOCK            BRANCH IF SO,CHECK FOR PROC,BEGIN,ON
*
SCAN13B  L     R6,4(R6)            CHAIN BACK TO CALLERS SA
         LA    R6,0(R6)            CLEAR SCAN PTR HI BYTE
         BCT   R9,SCAN13           TEST DSA FLAGS
MSG984   EQU   *
         MVC   MESSNO,F984         MESSAGE NO. (> 10 LEVELS)
         B     DIAGNOSE            PATCH POINT
         SPACE 2
CHKBLOCK EQU   *
         CLI   LANGBYTE,X'02'      ARE WE PLAYING WITH PL/I(F)
         BE    PL1DSA              SKIP FUN FOR PL/I(F)
         TM    0(R6),X'10'         THIS BIT MUST
         BO    SCAN13B             BE ZERO FOR DSA'S
         TM    1(R6),X'80'         THIS BIT MUST
         BO    SCAN13B             BE ZERO FOR DSA'S
         MVC   TESTBYTE,0(R6)      MOVE DSA FLAG BYTE INTO WORK SPACE
         NI    TESTBYTE,X'0C'      EXAMINE BITS 4 AND 5
         CLI   TESTBYTE,X'08'      TEST AND RESUME BACK SCAN IF
         BE    SCAN13B             THIS IS A LIBRARY DSA
*
*              PROCS X'X0', BEGINS X'X4' AND ON UNITS X'XC' FALL THRU
*        USERS SHOULD NOTE THAT SOME TRANSIENT LIBRARY MODULES DO NOT
*        OBEY THIS CONVENTION. IBMBPEQA FOR EXAMPLE, USES A DSA WHICH
*        HAS PROC FLAGS SET. THIS CAN GIVE RISE TO SOME ERRONEOUS
*        SAMPLING, BUT IT IS DIFFICULT TO DETECT SINCE WE'D NEED SOME
*        GENERAL RULE FOR DISTINGUISHING BETWEEN LIBRARY AND PL/I
*        CSECTS OTHER THAN THE DSA FLAGS.
*
*        WE HAVE NOW FOUND R13 -> SAVE AREA BELONGING TO THE DEEPEST
*        ACTIVE PL/I BLOCK.
*        IF THIS VALUE OF R13 IS THE SAME AS THE ONE IN THE RB, THEN
*        WE HAVE TRAPPED THE PROGRAM IN THE PL/I BLOCK. IF THEY DIFFER
*        THEN THE TRAP TOOK PLACE IN A NESTED SUBROUTINE. THE ACTION
*        TAKEN DEPENDS ON THE CASE.
         SPACE 2
PL1DSA   C     R6,RBR13            TEST AND BRANCH IF
         BE    USERB               THEY MATCH
*
*        R13 VALUES DIFFER, SO INTERRUPT TOOK PLACE IN A NESTED
*        SUBROUTINE, AND WE USE THE DSA REGISTERS FOR ANALYSIS.
*        THE ADDRESS OF THE INTERRUPTED PL/I STATEMENT IS THE R14
*        SLOT IN THE PL/I DSA.
*
         ST    R6,SAVDSA SAVE PL/I DSA POINTER
         MVI   INTERRPT,X'00' SAVE REVISED INTERRUPT
         MVC   INTERRPT+1(3),13(R6)     ADDRESS
         MVC   SAVR6(4),44(R6)     SAVE VALUES OF R6 AND
         MVC   SAVR14(4),12(R6)    R14 AT INTERRUPT IN CASE OF
         B     ANALYSE   COMP GEN SUBROUTINE
         SPACE 2
USERB    EQU   *
*        R13 VALUES AGREE, WHICH MEANS THAT THE INTERRUPT TOOK PLACE
*        IN 1) STRAIGHT PL/I CODE, IN WHICH CASE THE PL/I RB PSW IS
*        THE INTERRUPT ADDRESS, OR 2) IN A SUBROUTINE CALLED BY PL/I
*        WHICH DOESN'T ALLOCATE A SAVE AREA OF ITS OWN. WE USE
*        THE RB REGISTERS FOR THE ANALYSIS.
         SPACE
         ST    R6,SAVDSA SAVE PL/I DSA POINTER
         L     R7,SAVRB  SAVE VALUES OF R6 AND
         MVC   SAVR6,56(R7)   R14 AT INTERRUPT IN
         MVC   SAVR14,88(R7)  CASE COMP GEN SUBROUTINE
         SPACE 2
ANALYSE  EQU   *
         CLI   LANGBYTE,X'02'      IS THIS PL/I(F)
         BE    PL1STMT             YES
         TM    1(R6),X'04'         TEST AND BRANCH IF
         BZ    FINDNAME            NO STATEMENT NUMBER
*
*              A STATEMENT NUMBER TABLE EXISTS FOR THIS BLOCK. WE
*              PROCEED TO IDENTIFY THE STATEMENT NO. CORRESPONDING
*              TO THE INTERRUPT ADDRESS.
*
         L     R3,INTERRPT         REDUCE THE INTERRUPT ADDRESS BY 1
         BCTR  R3,0                TO GET ROUND THE UPDATED PSW EFFECT
*              THIS CAN CAUSE PROBLEMS WHEN THE PSW POINTS AT
*              THE TARGET OF A BRANCH, BUT THE EFFECT WOULD ONLY
*              BE NOTICEABLE IN A SMALL NUMBER OF CASES, SINCE
*              FALL THRU HAPPENS MORE OFTEN THAN BRANCHING, AND
*              MOST STATEMENTS HAVE MORE THAN 1 OR 2 INSTRUCTIONS
*
         L     R6,SAVDSA           R6 -> CONTAINERS SAVE AREA. THE R15
         L     R6,4(R6)            SLOT HERE CONTAINS THE ADDRESS OF
*                                  THE ENTRY POINT TO INTERRUPTED BLOCK
         L     R8,16(R6)           R8 -> EP OF INTERRUPTED BLOCK
         L     R8,8(,R8)           R8 - INTERRUPTED BLOCK STATNO TABLE
         S     R3,0(R8)            SUBTRACT FROM THE INTERRUPT ADDRESS,
*                                  LOCATION OF THE START OF THE BLOCK,
*                                  (1ST WORD IN STATNO TABLE). R3 IS
*                                  NOW THE INTERRUPT OFFSET.
*
         LTR   R3,R3               CHECK FOR -VE OFFSET
         BNM   NOTUNDER
*
*              -VE OFFSET USUALLY MEANS WE HAVE TRAPPED THE PL/I PGM
*              WHILE IT WAS USING A COMPILER GENERATED SUBROUTINE.
*              THE CONVENTIONAL LINKAGE TO THESE ROUTINES IS VIA
*        BALR R6,R7 OR BALR R14,R15. WE TRY R6 FIRST SINCE R14
*        USUALLY CONTAINS AN ADDRESS AND COULD MISLEAD US.
*
TRYCGS   L     R3,SAVR6            RECALCULATE
         LA    R3,0(R3)            THE
         BCTR  R3,0                OFFSET
         S     R3,0(R8)            AGAIN
         LTR   R3,R3               TEST AND TRY R14
         BM    TRYCG14             IF STILL -VE
         C     R3,4(R8)            IF SAVR6 FITS INTO
         BNH   NOTOVER             THE BLOCK, GO GET STATNO
*
TRYCG14  EQU   *
         L     R3,SAVR14           RECALCULATE
         LA    R3,0(R3)            THE
         BCTR  R3,0                OFFSET
         S     R3,0(R8)            AGAIN USING R14
         LTR   R3,R3               TEST AND TRY NO SAVE AREA
         BM    TRYNSA              IF STILL -VE
         C     R3,4(R8)            IF SAVR14 FITS INTO
         BNH   NOTOVER             THE BLOCK, GO GET STATNO
*
*        OUR LAST ATTEMPT HERE IS TO SEE WHETHER WE ARE IN A
*        ROUTINE WHICH DIDN'T ALLOCATE A DSA (YET OR EVER).
*        THIS INTERRUPT IS CHARGED TO THE CALLER BY USING THE
*        R14 SLOT IN THE CURRENT (CALLERS) DSA.
*
TRYNSA   EQU   *
         L     R3,SAVDSA           R3 -> CURRENT DSA
         L     R3,12(R3)           R3 -> RETURN ADDR
         LA    R3,0(R3)            RECALCULATE
         BCTR  R3,0                THE OFFSET
         S     R3,0(R8)            AGAIN
         LTR   R3,R3               IF -VE
         BM    MSG985              ABANDON SEARCH
         C     R3,4(R8)            LOOKS OK
         BNH   NOTOVER             SO GET STATNO
*
MSG985   EQU   *
         MVC   MESSNO,F985         MESSAGE NUMBER
         B     DIAGNOSE            PATCH POINT
ABEND985 EQU   *
         ABEND 985,DUMP,STEP       DEBUG
*
NOTUNDER C     R3,4(R8)            CHECK FOR OFFSET > BLOCK SIZE
         BNH   NOTOVER             BRANCH TO ANALYSIS IF INSIDE BLOCK
*
*        AN OFFSET > BLOCKSIZE USUALLY MEANS WE HAVE TRAPPED THE PL/I
*        PROGRAM WHILE IT WAS USING A ROUTINE WHICH DIDN'T ALLOCATE
*        A SAVE AREA OF ITS OWN, AND IS USING R13 -> DSA. WE WANT THE
*        RETURN ADDRESS FROM THIS SUBROUTINE, WHICH IS USUALLY THE
*        R14 SLOT IN THE DSA. THIS CAN ALSO HAPPEN IN THE PROLOG
*        OF A CALLED BLOCK BEFORE THE NEW DSA IS SET UP.
*        THERE IS A SPECIAL CASE WHEN TOTAL OPTIMISED I/O CALLS DATA
*        MANAGEMENT. IGG ROUTINES SAVE THEIR R14 AT OFFSET 20 IN THE
*        DSA, SO WE TRY THAT FIRST.
*
         L     R3,SAVDSA           R3 -> RETURN ADDR
         L     R3,20(R3)           R3 -> IGG RETURN ADDR
         LA    R3,0(R3)           RECALCULATE
         BCTR  R3,0                THE OFFSET
         S     R3,0(R8)            AGAIN
         LTR   R3,R3               TEST AND TRY
         BM    TRY2R14             OTHER R14 SLOT IF -VE
         C     R3,4(R8)            TEST AND BRANCH
         BNH   NOTOVER             TO ANALYSIS
*
TRY2R14  EQU   *                   TRY USUAL R14 LOCATION
         L     R3,SAVDSA           R3 -> PL/I DSA
         L     R3,12(R3)           R3 -> RETURN ADDR
         LA    R3,0(R3)            RECALCULATE
         BCTR  R3,0                OFFSET
         S     R3,0(R8)            AGAIN
         LTR   R3,R3               GOTO COMPILER GEN SUBROUTINE
         BM    TRYCGS              CODE IF NOW -VE, SINCE THEY CAN BALR
         C     R3,4(,R8)           14,15 IF WE ARE STILL TOO HIGH
         BNH   NOTOVER             THEN WE HAVE A PROBLEM
*
         MVC   MESSNO,F986         MESSAGE NO.
         B     DIAGNOSE            PATCH POINT
*
*        AT THIS POINT R8 -> STATNO TABLE FOR THE INTERRUPTED
*        PL/I PROCEDURE AND R3 CONTAINS THE OFFSET OF THE
*        INTERRUPTED STATEMENT WITHIN THE BLOCK. THE STATEMENT/
*        LINE NO TABLE IS DIVIDED INTO SECTIONS, EACH SECTION
*        COVERING AN OFFSET OF X'7FFF' MAX, SO WE FIRST HAVE
*        TO LOCATE THE CORRECT SECTION OF THE TABLE. EACH TABLE
*        SECTION STARTS WITH A POINTER TO THE END OF THE SECTION,
*        WHICH IS ALSO THE START OF THE NEXT SECTION (IF ANY).
*
NOTOVER  LR    R7,R3               LOAD R7 WITH OFFSET AND IGNORE 15
         SRL   R7,15               LOW ORDER BITS. R7 IS NOW NO. OF
*                                  THE TABLE SECTION, (1ST SECTN = #0)
         LA    R8,8(R8)            R8 -> FIRST SECTION OF STATNO TABLE
         LTR   R7,R7               TEST AND BRANCH IF OFFSET IS
         BZ    GOTSECTN            WITHIN FIRST TABLE
         LR    R9,R7               SAVE TABLE NUMBER
TABSCAN  MVC   FULLWD,0(R8)        LINE NO TABLES CAN BE HWD ALGN
         L     R8,FULLWD           R8 -> NEXT SECTION OF TABLE
         BCT   R7,TABSCAN          KEEP LOOPING UNTIL SECTION FOUND
*
         SLL   R9,15               DERIVE THE OFFSET WITHIN THIS
         SR    R3,R9               SECTION OF THE STATNO TABLE
*
*              AT THIS POINT R8 -> THE SECTION OF THE STATEMENT/LINE NO
*              TABLE CONTAINING THE INTERRUPTED STATEMENT/LINE NO,
*              AND R3 IS THE OFFSET WITHIN THIS TABLE SECTION.
*        WE NOW CHECK WHETHER STATEMENT NUMBERS OR LINE NUMBERS ARE
*        BEING USED IN THIS BLOCK. FIRST OF ALL, INITIALISE FOR
*        THE STATEMENT NUMBER CASE.
*
GOTSECTN MVC   FULLWD,0(R8)        LINE NO TABLES CAN BE HWD ALGN
         L     R9,FULLWD           R9 -> END OF THIS TABLE
*                                  R8->FIRST ELEMENT IN OFFSET TABLE-4
         LA    R7,4                EACH ELEMENT CONSISTS OF 2 PARTS,
*                                  FIRST IS HWD OFFSET OF START OF
*                                  STATEMENT CODE WHOSE STAT/LINE NO IS
*                                  GIVEN BY 2ND PART. R7 IS INCREMENT.
*
         L     R6,SAVDSA           R6 -> DSA
         TM    1(R6),X'01'         TEST AND BRANCH
         BZ    TABLOOP             IF NO DSA FLAGS2
         TM    X'76'(R6),X'04'     TEST AND BRANCH
         BZ    TABLOOP             IF NO LINE NUMBERS
*
         BCTR  R8,0                R8=R8-2 FOR ADDR OF 1ST SLOT-6.
         BCTR  R8,0                SINCE LINE NOS OCCUPY 4 BYTES EACH
         LA    R7,6                +2 FOR THE OFFSET=6 BYTES PER TABLE
*                                  SLOT.
         OI    WRD1+3,X'40'        FLAG 'LINE NUMBER'
TABLOOP  AR    R8,R7               R8 -> NEXT TABLE SLOT
         CR    R8,R9               IF WE HAVE REACHED THE END, THEN THE
         BE    GOTIT               STATEMENT MUST BE THE LAST.
*
         CH    R3,0(R8)            COMPARE THE INTERRUPT OFFSET TO THE
*                                  TABLE OFFSET. KEEP LOOPING UNTIL THE
         BH    TABLOOP             CURRENT OFFSET IS TOO HIGH.
*
GOTIT    SR    R8,R7               R8 -> CORRECT TABLE SLOT
         TM    WRD1+3,X'40'        TEST AND BRANCH
         BZ    GETSTMT             IF STATEMENT NUMBERS
*
         MVC   WRD3(4),2(R8)       RECORD LINE NUMBER
         B     FINDNAME            CONTINUE
*
GETSTMT  MVC   WRD3+2(2),2(R8)     RECORD STATEMENT NUMBER
         B     FINDNAME            GO GET PROC NAME
PL1STMT  TM    0(R6),X'40'         TEST AND BRANCH IF
         BZ    PL1BLOCK            NO STATEMENT NUMBER
         MVC   WRD3(4),96(R6)
         SPACE 5
*              WE NOW FIND THE NAME OF THE CURRENT BLOCK. IF THE BLOCK
*              IS BEGIN OR ON-UNIT, THEN WE SCAN BACK TO FIND THE
*              NAME OF THE NEAREST CONTAINING PROC
*
         B     PL1BLOCK
FINDNAME L     R6,SAVDSA           R6 -> INTERRUPTED BLOCK'S DSA
         CLI   LANGBYTE,X'02'      IS THIS PL/I(F)
         BE    PL1BLOCK            USE PL/I(F) CONVENTIONS
NXTBLOCK TM    0(R6),X'0C'         TEST AND BRANCH IF THE
         BZ    FNDPROC             CURRENT BLOCK IS A PROCEDURE
         L     R8,88(R6)           IF THE STATIC BACKCHAIN
         LTR   R8,R8               IS NON-ZERO THEN
         BZ    USEDYN              USE IT. OTHERWISE
         LR    R6,R8               USE THE DYNAMIC
         B     NXTBLOCK            BACKCHAIN
PL1BLOCK TM    0(R6),X'80'         IS THIS A DSA?
         BZ    USEDYN              NO, SO CHAIN UPWARDS.
         TM    0(R6),X'10'         IS IT A PROCEDURE?
         BZ    FNDPROC             YES, PROCESS IT.
USEDYN   EQU   *
         L     R6,4(R6)            KEEP LOOKING FOR
         B     NXTBLOCK            CONTAINING PROC
*
FNDPROC  L     R6,4(R6)            PICK UP PROCS REGISTERS IN CONTNR SA
         CLI   LANGBYTE,X'02'      IS THIS PL/I(F)
         BE    PL1PROC             YES
         CLI   0(R6),X'82'         IF THIS CONTAINER IS DUMMY DSA THEN
         BNE   NOTMAIN             THE PROC WE FOUND IS THE MAIN PROC
         OI    WRD1+3,X'80'        SO FLAG IT
*
NOTMAIN  L     R6,16(R6)           PICK PROC EP FROM CONTNR SA
         LA    R8,8                REDUCE THE POINTER BY 8
         SR    R6,R8               SO THAT R6 -> PROCEDURE NAME FIELD
*
         LR    R7,R6               R7 -> CSECT
         S     R7,ORIGIN           R7 = OFFSET OF PROC IN MODULE
         ST    R7,FULLWD           STORE THIS OFFSET
         MVC   WRD4+1(3),FULLWD+1  IN THE RUN RECORD
*
         MVC   WRD5(8),BLANKS      BLANK OUT NAME FIELD
         CLI   7(R6),X'04'         TEST AND BRANCH
         BL    SHORTNAM            IF SHORT NAME (1 -> 3 CHARS)
*
         MVC   WRD5+1(7),0(R6)     RECORD LONG NAME
         B     WRITERUN
*
SHORTNAM MVC   WRD5+1(3),4(R6)     RECORD SHORT NAME
         B     WRITERUN
PL1PROC  MVI   WRD1+3,X'00'        CLEAR FLAGS
         CLI   0(R6),X'29'         PRV VDA
         BNE   NOTMAIN2            NOT THE MAIN PROC
         OI    WRD1+3,X'80'        FLAG THE BIT FOR MAIN PROC
         L     R6,4(,R6)           GET BACK ONE MORE AREA FOR MAIN PROC
NOTMAIN2 L     R6,16(,R6)          PICK UP PROC EP FROM CONTAINER DSA
         LR    R7,R6               R7 -> CSECT
         S     R7,ORIGIN           R7 = OFFSET OF PROC IN MODULE
         ST    R7,FULLWD           STORE THIS OFFSET
         MVC   WRD4+1(3),FULLWD+1  IN THE RUN RECORD
         MVC   WRD1(3),RUN         RECORD ID
         MVC   WRD5(8),BLANKS      BLANK OUT NAME FIELD
         LA    R7,0                CLEAR R7
         IC    R7,4(,R6)           MOVE IN PROC NAME LENGTH
         BCTR  R7,0                PREPARE FOR EX
         N     R7,MASK             MOVE 8 CHARS MAX
         EX    R7,NAMEMOVE         MOVE PROC NAME
         B     WRITERUN            GO TO WRITE RECORD
NAMEMOVE MVC   WRD5+1(0),5(R6)     MOVE PROC NAME
WRITERUN PUT   DCBOUT,BUFFER       WRITE RUN RECORD
         EJECT
*        EVERY TIMER EXIT FALLS THROUGH INTO THE LOAD LIST SCAN
*        ROUTINE BELOW. TO SAVE TIME WE ONLY PROCESS THE 10TH AND EVERY
*        SUBSEQUENT 40TH TIMER INTERRUPT.
*
         LH    R9,MODSCNB          TEST WHETHER WE DO A
         BCT   R9,NOMODSCN         SCAN THIS TIME THROUGH
         MVC   MODSCNB,MODSCNA     RESET MODULE SCAN COUNT
         SPACE 2
********** SCAN CDE ENTRIES AND OUTPUT RECORDS FOR MODULES IN CORE ***
         MVC   WRD1,LOAD
         XC    WRD4,WRD4         CLEAR UNUSED SPACE
         L     R2,TCBAD
         L     R3,36(,R2)          LLE
         SPACE 3
LLSCAN   EQU   *                   PICK UP MODULES ON LOAD LIST
         L     R4,4(,R3)           CDE ADDRESS
         BAL   R8,STARTCDE         REPORT
         L     R3,0(,R3)           NEXT LLE
         LTR   R3,R3               LAST ONE REPORTED=END OF LIST?
         BNZ   LLSCAN              IF NOT, LOOP
         SPACE 2
**************** PICK UP MODULES W/ RBS
         L     R3,0(,R2)           RB POINTER FROM TCB
RBSCAN   EQU   *
         TM    10(R3),X'C0'
         BNZ   NEXTRB              IF NOT PRB, DON'T LOOK AT CDE
         L     R4,12(,R3)          CDE ADDRESS FROM RB
         BAL   R8,STARTCDE         GO REPORT
NEXTRB   EQU   *
         L     R3,28(,R3)          NEXT RB ADDRESS
         LA    R3,0(,R3)
         CR    R3,R2               ADDRESS OF TCB?
         BNE   RBSCAN              IF NOT, LOOP
         B     MODSCAND            END MODULUE REPORTING
         SPACE 2
STARTCDE   EQU  *
XLFIND   EQU   *
***   ON ENTRY, REG 4 POINTS TO CDE
         TM    20(R4),X'20'        XL EXIST?
         BO    EXTENT              YES
         L     R4,20(,R4)          NEXT CDE
         LA    R4,0(,R4)           CLEAR
         LTR   R4,R4               NO VALUE?
         BNZ   XLFIND              IF VALUE, LOOK AT NEXT
         BR    R8                  SKIP THIS MOD IF NO XL OR MAJ
         B     XLFIND
EXTENT   EQU   *
         L     R5,20(,R4)          XL ADDRESS FROM CDE
         L     R6,4(,R5)           NUMBER OF ENTRIES
         SLL   R6,2                TIMES 4
         LA    R6,0(R5,R6)         TO FIRST LOCATION -8
         MVC   WRD2(4),8(R6)       BEGIN ADDRESS
         SR    R7,R7
SIZEADD  EQU   *
         A     R7,8(,R5)           LENGTH
         LA    R7,0(,R7)           CLEAR HIGH ORDER BYTE
         LA    R5,4(,R5)           INCREMENT
         CR    R5,R6
         BL    SIZEADD             IF NOT THERE, LOOP AGAIN
         ST    R7,WRD3             TOTSIZE
         MVC   WRD5(8),8(R4)       NAME FROM CDE
         PUT   DCBOUT,BUFFER
         BR    R8                  RETURN TO LLSCAN OR RBSCAN
NOMODSCN EQU   *
         STH   R9,MODSCNB
MODSCAND EQU   *
         SPACE 3
RETURN   EQU   *                   NORMAL RETURN, RESET TIMER
         L     R0,ADEXIT           SET R0 TO ADDR OF TIMER EXIT
         STIMER  TASK,(0),BINTVL=TRCINTVL  RESET TIMER FOR INTERVAL
         B     RETURN2
*
ABENDRTN  EQU  *
*        A BRANCH TO ABENDRTN WITHOUT RESETTING THE TIMER TERMINATES
*        THE SAMPLING, ALLOWING THE PL/I PROBLEM PROGRAM TO RUN TO
*        COMPLETION
*
         TIME  BIN                 NOTE TIME SAMPLING STOPPED
         ST    R0,TIMEOUT          WRITE OUT
         MVI   ENDSW,C'1'          FLAG END OF SAMPLING
*
RETURN2  EQU   *
         L     R1,PICA             REVERT SPIE
         SPIE  MF=(E,(1))          TO PL/I STATUS
         L     R13,SAV2+4          RETURN
         LM    R14,R12,12(R13)     TO PL/I PROGRAM
         BR    R14
    TITLE  'ERROR MESSAGE ROUTINE'
*        DIAGNOSE IS ENTERED WHEN AN INTERRUPT ANALYSIS HAS TO BE
*        ABANDONED. A MESSAGE IS WRITTEN AND IF MORE THEN ERRLIMIT
*        CALLS ARE ABANDONED, NO FURTHER INTERRUPTS ARE MADE.
*
DIAGNOSE EQU   *
         PUT   DCBOUT,MSGREC       WRITE OUT FIRST ERROR MESSAGE
         L     R9,ERRLIMIT         CHECK WHETHER
         BCT   R9,DIAG2            LIMIT EXCEEDED
*
         MVC   MESSNO(4),F987      DIAGNOSE 'TOO MANY ERRORS'
         PUT   DCBOUT,MSGREC
         B     ABENDRTN            ABNORMAL RETURN
*
DIAG2    ST    R9,ERRLIMIT         KEEP COUNT OF ERRORS
         B     RETURN              NORMAL RETURN TO PL/I PROGRAM
  TITLE  'SPIE EXIT ROUTINE'
SPIEXIT   EQU  *
******************** SPIE EXIT ROUTINE  ****************************
*
*              THIS ROUTINE IS ENTERED IF AN INTERRUPT TAKES PLACE
*              DURING PLEATRAP PROCESSING. WE RECORD RELEVANT DATA
*              FOR DEBUGGING PURPOSES.
*
         DROP  R12
         BALR  R2,0
         USING  *,R2
         ST    R13,SAV3+4
         LA    R13,SAV3
         ST    R14,SAV3
         MVC   WRD3(4),WRD2        SAVE ORIGINAL INTERRUPT ADDRESS
         MVI   8(R1),X'00'         CLEAR HIGH ORDER BYTE
         L     R15,8(,R1)          LOAD INTERRUPT ADDRESS FROM PICA
         S     R15,ENTERAD         CALCULATE INTERRUPT OFFSET
         ST    R15,WRD2            RECORD IN PGCK RECORD
         XC    WRD4(3),WRD4        CLEAR HIGH ORDER 3 BYTES
         MVC   WRD4+3(1),7(R1)     RECORD INTERRUPT CODE FROM PICA
         MVC   WRD1(4),PGCK        PUT IN PROGRAM CHECK IDENTIFIER
         B     ERRCHK              PATCH POINT
         ABEND 999,DUMP,STEP
*
ERRCHK   EQU   *
         L     R14,ERRLIMIT
         BCT   R14,NOTQUIT
         MVC   MESSNO,F987         DIAGNOSE 'TOO MANY ERRORS'
         PUT   DCBOUT,MSGREC
         MVC   8(4,R1),ABENDAD     ADDR OF ABNORMAL RETN TO PL/I
         B     SPIERETN
NOTQUIT  EQU  *
         ST    R14,ERRLIMIT
         MVC   8(4,R1),RETURNAD    ADDR OF NORMAL RETURN TO PL/I
         PUT  DCBOUT,BUFFER
SPIERETN EQU   *
         L     R14,SAV3
         L     R13,SAV3+4
         BR    R14
   TITLE  'DCB AND CONSTANTS'
DCBOUT   DCB   DSORG=PS,DDNAME=TRACE,MACRF=(PM),LRECL=24,RECFM=FB,     *
               BLKSIZE=480
  EJECT
*              STORAGE AREA
*
DECWSP   DS    D                   DECIMAL WORKSPACE
TIMTAKEN DC    F'0'                CPU TIME TAKEN BY PROGRAM SO FAR
TIMLIMIT DC    F'10000000'         DEFAULT LIMIT EXCEEDING 24 HRS
MODSCNA  DC    H'40'               EVERY X INTERRUPTS, SCAN CDE'S
MODSCNB  DC    H'10'               FIRST LOAD LIST SCAN AFTER 10
*                                  INTERVALS
PRBAD    DC    F'0'                ADDRESS OF PL/I PROGRAM PRB
TRCINTVL DC    F'2'                TRACE INTERVAL EVERY .02 SECS
TCBAD    DC    F'0'                ADDRESS OF OUR TCB
FULLWD   DC    F'0'                ALIGNED WORKSPACE
ERRLIMIT DC    F'1000000'          ACCEPTABLE NO OF ERRORS
SAV      DC    18F'0'
         DC    X'FDFD'             SAVEAREA FLAG (USED IN SCAN13 ABOVE)
SAV2     DC    18F'0'              SAVE AREA
SAV3     DC    18F'0'              SAVE AREA
NAME     DC    CL8'GO      '
PICA     DS    F                   SAVES PTR TO PL/I PIE
ORIGIN   DC    F'0'                LOAD POINT OF PL/I PROGRAM
LMODEND  DC    F'0'                END OF USER LOAD MODULE
CNTLIMIT DC    F'1000000'          MAXIMUM NUMBR OF INTERRUPTS
MASK     DC    F'7'                MVC MASK FOR MOVE OF 8 CHARS MAX
F100     DC    F'100'
F980     DC    F'980'              ERROR NUMBER
F981     DC    F'981'              ERROR NUMBER
F982     DC    F'982'              ERROR NUMBER
F983     DC    F'983'              ERROR NUMBER
F984     DC    F'984'              ERROR NUMBER
F985     DC    F'985'              ERROR NUMBER
F986     DC    F'986'              ERROR NUMBER
F987     DC    F'987'              ERROR NUMBER
F988     DC    F'988'              ERROR NUMBER
F989     DC    F'989'              ERROR NUMBER
F990     DC    F'990'              ERROR NUMBER
ENTERAD  DC    A(PLEATRAP)         ADDRESS OF MAIN ENTRY POINT
RETURNAD DC    A(RETURN)
ABENDAD  DC    A(ABENDRTN)
ADEXIT   DC    A(EXIT)             ADDRESS OF TIMER EXIT ROUTINE
*
BUFFER   EQU   *
WRD1     DC    F'0'
WRD2     DC    F'0'
WRD3     DC    F'0'
WRD4     DC    F'0'
WRD5     DC    F'0'
WRD6     DC    F'0'
*
LASTREC  DS    0F                  LAST RECORD WRITTEN TO TRACE FILE
ENDCC    DC    C'END'              LABEL
FLAGS    DC    X'00'               FLAGS TO SEND INFO TO PLEATAB
COUNT    DC    F'0'                COUNT OF SAMPLES
SPARE1   DC    F'0'                NOT USED
TIMEIN   DC    F'0'                TIME RUN STARTED
TIMEOUT  DC    F'0'                TIME RUN ENDED
SPARE2   DC    F'0'                NOT USED
*
MSGREC   DS    0F                  DIAGNOSTIC MESSAGE BUFFER
MSGCC    DC    C'MESG'
MESSNO   DC    F'0'                MESSAGE NUMBER
MESSTXT  DC    CL16' '             MESSAGE TEXT
*
INTERRPT DC    F'0'                SAVE AREA FOR INTERRUPT ADDRESS
SAVDSA   DC    F'0'                SAVE AREA FOR PL/I DSA POINTER
SAVRB    DC    F'0'                ADDRESS OF REQUEST BLOCK
RBR13    DC    F'0'                REGISTER 13 FROM REQUEST BLOCK
SAVR6    DC    F'0'
SAVR14   DC    F'0'
SAVRETN  DC    C'0'                SAVE PL/I RETURN CODE
PL1PARM  DC    H'0'                LENGTH OF PARMLIST
PARMLIST DS    CL100               PARAMETERS
TESTBYTE DS    C                   USED TO DETERMINE TYPE OF DSA
ENDSW    DC    C'0'                'I' MEANS SAMPLING ENDED EARLY
CTR1     DC    F'0'                ****************************
BLANKS   DC    CL8' '              BLANKS
STRT     DC    CL4'STRT'           MESSAGE IDENTIFIER
LOAD     DC    CL4'LOAD'           RECORD IDENTIFIER
PGCK     DC    CL4'PGCK'           RECORD IDENTIFIER
RUN      DC    CL4'RUN'            RECORD IDENTIFIER
MAIN     DC    CL8'    MAIN'       FOR FORTRAN
LANG     DC    CL8' '              LANGUAGE ID
LANGTBL  DC    CL8'PLI'
         DC    CL8'PL1'
         DC    CL8'FORTRAN'
         DC    CL8'COBOL'
LANGEND  EQU   *-L'LANGTBL
LANGBYTE DC    X'00'
FSA      EQU   X'70'               TCB OFFSET OF FIRST (TOP) SAVE AREA
         END
